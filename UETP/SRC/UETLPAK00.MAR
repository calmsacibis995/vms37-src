	.TITLE UETLPAK00 VAX/VMS UETP DEVICE TEST FOR THE LPA11-K
	.IDENT	'V03-000'
	.ENABLE SUPPRESSION
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:
;	This module will be distributed with VAX/VMS under the [SYSTEST]
;	account.
;
; ABSTRACT:
;	This program tests an LPA11-K on a VAX/VMS system in all the LPA11-K's
;	modes of operation.
;
; ENVIRONMENT:
; 	This program will run in user access mode, with ASTs enabled except
;	during error processing.  It is dependent on the LPA11-K microcode
;	loader process ([SYSMGR]LPA11STRT.COM) having already been started.
;	This program requires the following privileges and quotas:
;		ALTPRI (Not normally used.  See functional spec.)
;
;--
;
; AUTHOR: Richard Holstein,	CREATION DATE: August, 1981
;
; MODIFIED BY:
;
;	V03-004	MTR0001		Michael T. Rhodes,	17-Mar-1982
;		Fix continuation of .ASCID string defined at CONFIG_MSG:
;
;	V03-003	RNH0003		Richard N. Holstein,	24-Dec-1981
;		Miscellaneous cleanup.
;
;	V03-002	RNH0002		Richard N. Holstein,	12-Oct-1981
;		Do multiuser testing asynchronously to prevent buffer overruns
;		on fully laden LPA11-Ks.  Set SETPRI so we can change priority.
;
;	V03-001	RNH0001		Richard N. Holstein,	28-Aug-1981
;		Final testing and development for Field Test 1.
;
;**

	.SBTTL	Declarations
;
; INCLUDE FILES:
;
;	SYS$LIBRARY:LIB.MLB	for general definitions
;	SHRLIB$:UETP.MLB	for UETP definitions

;
; MACROS:
;
	$CHFDEF				; Condition handler frame definitions
	$DEVDEF				; Device definitions
	$DIBDEF				; Device Information Block
	$JPIDEF				; Job/process info
	$LADEF				; LPA11-K specific
	$PRVDEF				; Privileges
	$SHRDEF				; Shared messages
	$STSDEF				; Status return
	$UETUNTDEF			; UETP unit block offset definitions
	$UETPDEF			; UETP
;
; EQUATED SYMBOLS:
;
;   Facility number definitions:
	UETP_K = 116
	RMS_K = 1

;   SHR message definitions:
	UETP = UETP_K@STS$V_FAC_NO	; Define the UETP facility code
;
	UETP$_ABENDD = UETP!SHR$_ABENDD	; Define the UETP message codes
	UETP$_BEGIND = UETP!SHR$_BEGIND
	UETP$_ENDEDD = UETP!SHR$_ENDEDD
	UETP$_OPENIN = UETP!SHR$_OPENIN
	UETP$_TEXT   = UETP!SHR$_TEXT

;   Internal flag bits...:
	TEST_OVERV   = 1		; Set when test is over
	SAFE_TO_UPDV = 2		; Set when it's safe to update UETINIDEV
	BEGIN_MSGV   = 3		; Set when "begin" msg has been output
	ONE_SHOTV    = 4		; Set if running in one-shot mode
	DUMP_MODEV   = 5		; Set if additional error info printed
;   ...and corresponding masks:
	TEST_OVERM   = 1@TEST_OVERV
	SAFE_TO_UPDM = 1@SAFE_TO_UPDV
	BEGIN_MSGM   = 1@BEGIN_MSGV
	ONE_SHOTM    = 1@ONE_SHOTV
	DUMP_MODEM   = 1@DUMP_MODEV

;   Miscellany:
	LC_BITM       = ^X20		; Mask to convert lower case to upper
	REC_SIZE      = 20		; UETINIDEV.DAT record size
	TEXT_BUFFER   = 300		; Internal text buffer size
	EFN2          = 4		; EFN used for three minute timer
	MAX_PROC_NAME = 15		; Longest possible process name
	MAX_DEV_DESIG = 8		; Longest possible controller name
	MAX_UNIT_DESIG= 5		; Longest possible unit number

;   LPA11-K specific definitions:
	JOB_PRIORITY  = 0		; Priority to run LPA11-K test if...
					; ...(.GT. 0) and (.GT. base priority)
	JPI_EFN       = EFN2+1		; EFN for $GETJPI completion
	CLOCK_SPEED   = ^F0.0002	; LPA11-K clock A rate
	MGT_BUF_SIZE  = 50		; Size of channel status area
	NUM_CHANNELS  = 7		; Channels to test on LPA11-K I/O bus
	LA_K_OVERRUN  = ^O243		; LPA11-K error code for data overrun
	SETIBF        = 0		; Code for LPA$SETIBF in ONCE_FOR_EACH
	SWEEP         = 1		; Code for sweep routines in ONCE_FOR_EACH
	RLSBUF        = 2		; Code for LPA$RLSBUF in ONCE_FOR_EACH
	LAST_FUNCTION = 2		; Maximum ONCE_FOR_EACH code value
	MU_TIME_OUT   = 24		; Maximum times we'll poll SWEEP_COUNT...
					; ...to see if multiuser sweeps have...
					; ...finished. We actually wait for...
					; ...MU_TIME_OUT*FIVE_SECONDS

	WRITE_SIZE    = 2048		; Data buffer size (write/read)
.IIF NE WRITE_SIZE&1, .ERROR 0-
			; WRITE_SIZE must be even for dedicated sweeps
.IIF LT WRITE_SIZE-258, .ERROR 0-
			; WRITE_SIZE must be .GE. 258 for dedicated transfers
.IIF GE <WRITE_SIZE*NUM_CHANNELS*2>-32768, .ERROR 0-
			; Aggregate buffer size exceeds 32768

	RAMP_HEIGHT   = WRITE_SIZE	; Size of AA11-K ramp data buffers
	DEVDEP_SIZE   = 0		; Device dependent part size of node
	BUFFER_SIZE   = 0		; We don't use this - allocated statically

	PAGES = <<UETUNT$C_INDSIZ+-	; Add together all of the pieces...
		  DEVDEP_SIZE+-		; ...which make up a UETP unit block...
		  BUFFER_SIZE+-		; ...to give to the $EXPREG service...
		  511>/512>		; ...later

;++
;	In order to allow for word size displacement when linking this image,
;	and to make for a nice layout of the program text, some mucking about
;	with .PSECTs has been done.  In particular, the BUFFERS .PSECT, because
;	of its attributes, is the first .PSECT to be loaded into virtual
;	memory, allowing word displacement fo other .PSECTs (i.e., longword
;	displacement addressing mode is only needed to reference items in the
;	BUFFERS .PSECT).  BE CAREFUL when changing anything which might change
;	the order in which .PSECTs are loaded!
;--

	.SBTTL	Read-Only Data
	.PSECT	RODATA,EXE,NOWRT,PAGE	; EXE attribute changes .PSECT ordering!

ACNT_NAME:				; Process name on exit
	.ASCID	/SYSTEST/

TEST_NAME:				; This test name
	.ASCID	/UETLPAK00/

SUPDEV_GBLSEC:				; How we access UETSUPDEV.DAT
	.ASCID	/UETSUPDEV/

CONTROLLER:				; Logical name of controller
	.ASCID	/CTRLNAME/

MODE:					; Run mode logical name
	.ASCID	/MODE/

CS1:					; Device class and type control string
	.ASCID	/!2XB !2XB /

CS3:					; Device class-only control string
	.ASCID	/!2XB **/

TTNAME_ROPTR:				; Descriptor for recursive...
	.WORD	63,0			; ...translation of TTNAME
	.ADDRESS TTNAME

CNTRLCMSG:
	.ASCID	\Aborted via a user CTRL/C\

NO_CTRLNAME:
	.ASCID	/No controller specified./

DEAD_CTRLNAME:
	.ASCID	/Can't test controller !AS, marked as unusable in UETINIDEV.DAT./

NOUNIT_SELECTED:
	.ASCID	/No units selected for testing./

ILLEGAL_REC:
	.ASCID	/Illegal record format in file UETINIDEV.DAT!/

PASS_MSG:
	.ASCID	/End of pass !UL with !UL iterations at !%D./

THREEMIN:				; 3 minute delta time
	.LONG	-10*1000*1000*180,-1

CONT_DESC:				; Descriptor used to convert controller...
	.WORD	REC_SIZE,0		; ...from lowercase to uppercase
	.ADDRESS BUFFER

FILE:					; Fills in RMS_ERR_STRING
	.ASCID	/file/

RECORD:					; Fills in RMS_ERR_STRING
	.ASCID	/record/

RMS_ERR_STRING:				; Announces an RMS error
	.ASCID	/RMS !AS error in file !AD/

PROMPT:
	.ASCII	/Controller designation?: /
	PMTSIZ = .-PROMPT

LPA11K_PRIORITY:			; Logical name allows user...
	.ASCID	/LPA11KPRIORITY/	; ...to easily set job priority

LITERAL_0:				; For miscellaneous subroutine calls
	.LONG	0

LITERAL_1:				; For miscellaneous subroutine calls
	.LONG	1

FIVE_SECONDS:				; 5-second delta time
	.LONG	-10000000*5,-1

NEEDED_PRIVS:				; Privileges needed to run our test
	.LONG	1@PRV$V_SETPRI,0

MU_MCODE:				; Each of these...
	.ASCIC	/multiuser/
AD_MCODE:				; ...may be used in messages...
	.ASCIC	/analogue-to-digital/
DA_MCODE:				; ...to distinguish the mcode...
	.ASCIC	/digital-to-analogue/
FO_MCODE:				; ...or section of the test
	.ASCIC	/forced overrun/

LOAD_BAD_ERR_MSG:			; Bad error during microcode loading
	.ASCID	\Error loading !AC microcode,!/!_LPA11-K Status Out: %O!OB,\-
		\ Control Out: %O!OB,!/!_Maint Status high,low: %O!OB,%O!OB.\

LOAD_MISC_ERR_MSG:			; Misc error during microcode loading
	.ASCID	\Error loading !AC microcode.\

BADRATE_ERR_MSG:			; Error calculating clock A rate
	.ASCID	/Can't compute clock A rate and preset value./

SETUP_ERR_MSG:				; Error setting up buffers
	.ASCID	/Error setting up !AC data buffers./

RELEASE_ERR_MSG:			; Error releasing buffers
	.ASCID	/Error releasing !AC data buffers./

SWEEP_ERR_MSG:				; Data not passed correctly
	.ASCID	/Error starting up !AC sweeps./

IWTBUF_MISC_ERR_MSG:			; Miscellaneous error
	.ASCID	/Error returning from !AC data transfer./

IWTBUF_BAD_ERR_MSG:			; Error code with add'l data in IOSB
	.ASCID	\Error during !AC data transfer,!/!_LPA11-K Status Out: %O!OB,\-
		\ Control Out: %O!OB,!/!_Maint Status high,low: %O!OB,%O!OB.\

OVERRUN_ERR_MSG:			; Unexpected buffer overrun/underrun
	.ASCID	\Error during !AC data transfer,!/!_LPA11-K Status Out: %O!OB,\-
		\ Control Out: %O!OB,!/!_Maint Status high,low: %O!OB,\-
		\%O!OB.!/	Buffer overrun/underrun.  Try retesting with\-
		\ higher job priority.\

CLOCK_ERR_MSG:				; Clock didn't start correctly
	.ASCID	/Error starting clock during !AS test./

AD11K_ERR_MSG:				; Incorrect a-to-d setup
	.ASCID	/Error setting !AC AD11-K channel info./

NO_OVRN_ERR_MSG:			; Couldn't force data overrun
	.ASCID	/Could not detect data overrun./

NAKED_ERR_MSG:				; No LPA11-K peripherals outboard
	.ASCID	\No devices found on LPA11-K input/output bus.\

LALOADER_PROC:				; System mcode loader process name
	.ASCID	/LALOADER/

LALOADER_IMAGE:				; System mcode loader process image
	.ASCID	/SYSEXE]LALOADER.EXE/

NO_LALOADER:				; Warns of incorrect system setup
	.ASCID	\The system LPA11-K microcode loader process wasn't started,\-
		\ i.e.,\<13><10>\	couldn't see process LALOADER with\-
		\ UIC=[1,4] running\<13><10>-
		\	the image SYS$SYSTEM:LALOADER.EXE.\

BAD_CASE_MSG:				; Impossible condition in ONCE_FOR_EACH
	.ASCID	/Internal consistency error:  !UB dispatch code./

COUNTED_OUT_MSG:			; Some multiuser sweep(s) hung
	.ASCID	/Timed out waiting for multiuser sweeps to complete./

CONFIG_MSG:				; Gives LPA11-K I/O bus configuration
	.ASCID	\LPA11-K configuration:  !UB AD11-K!AC, !UB AA11-K!AC, !UB \-
\DR11-K!AC!/	Intersample time will be !AS seconds.\

S_MSG:					; This because $FAO !%S is too smart
	.ASCIC	\'s\
NULL_MSG:				; Alternative to S_MSG
	.ASCIC	\\

MU_BEG_MSG:				; Tells when multiuser test begins
	.ASCID	/Multiuser test beginning./

MU_END_MSG:				; Tells when multiuser test ends
	.ASCID	/Multiuser test ending./

AD_BEG_MSG:				; Tells when AD11-K test begins
	.ASCID	/Dedicated A-to-D test beginning./

AD_END_MSG:				; Tells when AD11-K test ends
	.ASCID	/Dedicated A-to-D test ending./

DA_BEG_MSG:				; Tells when AA11-K test begins
	.ASCID	/Dedicated D-to-A test beginning./

DA_END_MSG:				; Tells when AA11-K test ends
	.ASCID	/Dedicated D-to-A test ending./

GENERIC_ERR_MSG:			; Use this if error exit but STATUS = 0
	.ASCID	/Non-recoverable error testing LPA11-K./

	.SBTTL	Read/Write Data
	.PSECT	RWDATA,WRT,NOEXE,PAGE	; .PSECT name affects ordering!

TTCHAN:					; Channel associated with ctrl. term.
	.WORD	0

TTNAME_RWPTR:				; Descriptor for recursive...
	.WORD	TTNAME_LEN,0		; ...translation of TTNAME
	.ADDRESS TTNAME
TTNAME:
	.ASCII	/SYS$INPUT/
	TTNAME_LEN=.-TTNAME
	.BLKB	63-TTNAME_LEN

FLAG:					; Miscellaneous flag bits
	.WORD	0			; (See Equated Symbols for definitions)

FAO_BUF:				; FAO output string descriptor
	.WORD	TEXT_BUFFER,0
	.ADDRESS BUFFER

BUFFER_PTR:				; Fake .ASCID buffer for misc. strings
	.WORD	TEXT_BUFFER,0		; A word for length, a word for desc.
	.ADDRESS BUFFER

BUFFER:					; FAO output and other misc. buffer
	.BLKB	TEXT_BUFFER

DEVDSC:					; Device name descriptor
	.WORD	MAX_DEV_DESIG,0
	.ADDRESS DEV_NAME


; NOTE THAT THE CODE DEPENDS ON THE FOLLOWING TWO ITEMS BEING TOGETHER.
PROCESS_NAME:				; Process name
	.ASCID	/UETLPAK00_/
DEV_NAME:				; Device name buffer
	.BLKB	MAX_DEV_DESIG+MAX_UNIT_DESIG
	NAME_LEN = .-DEV_NAME
; END OF ITEMS WHICH CODE DEPENDS ON BEING TOGETHER.


DIB:					; Device Information Block
	.WORD	DIB$K_LENGTH,0
	.ADDRESS DIBBUF
DIBBUF:
	.BLKB	DIB$K_LENGTH

ERROR_COUNT:				; Cumulative error count at runtime
	.LONG	0

STATUS:					; Status value on program exit
	.LONG	0

STAT:					; IO status block
	.QUAD	0

AST_MODE:				; Prior setting of AST delivery
	.LONG	0

SS_FAIL_MODE:				; Prior setting of SS failure mode
	.LONG	0

INADDRESS:				; $CRMPSC address storage
	.LONG	0,0
OUTADDRESS:
	.LONG	0,0

DEVNAM_LEN:				; Current device name length
	.WORD	0

RANDOM1:				; Random word #1
	.LONG	^XAAAAAAAA

RANDOM2:				; Random word #2
	.LONG	^XA72EA72E

ITERATION:				; # of times all tests were executed
	.LONG	0

PASS:					; Pass count
	.LONG	0

MSG_BLOCK:				; Auxiliary $GETMSG info
	.BLKB	4

EXIT_DESC:				; Exit handler descriptor
	.LONG	0
	.ADDRESS EXIT_HANDLER
	.LONG	1
	.ADDRESS STATUS

ARG_COUNT:				; Argument counter used by ERROR_EXIT
	.LONG	0

	.ALIGN QUAD			; For self-relative queue of unit blocks

UNIT_LIST:				; Head of unit block circular list
	.QUAD	0

NEW_NODE:				; Newly acquired node address
	.QUAD	0

PRIB_ITMLST:				; Argument for $GETJPI's base priority
	.WORD	4,JPI$_PRIB
	.ADDRESS BASE_PRIORITY
	.LONG	0
	.WORD	0,0
BASE_PRIORITY:				; A place for our process base priority
	.LONG	0

IMAGNAM_ITMLST:				; Argument for $GETJPI's image name
	.WORD	64,JPI$_IMAGNAME
	.ADDRESS MCODE_IMAGNAM
	.ADDRESS MCODE_IMAGLEN
	.WORD	0,0
MCODE_IMAGNAM:				; A place for LALOADER's process name
	.BLKB	64
MCODE_IMAGLEN:				; A place to hold the process name's length
	.WORD	0

IMAGNAM_IOSB:				; Final $GETJPI status
	.QUAD	0

	.ALIGN	LONG			; Required for data transfer
RAMP_DATA:				; Ramp data for AA11-K test
	.BLKW RAMP_HEIGHT		; Forms a [1:N,0:1] word buffer
RAMP_DATA1:
	.BLKW RAMP_HEIGHT

SWEEP_COUNT:				; Number of multiuser channels...
	.BYTE	0			; ...which successfully started sweeps

MCODE_TYPE:				; Holds mcode type constant
	.LONG	0

MCODE_ADDR:				; Holds address of mcode name
	.ADDRESS 0

FLOAT_PTR:				; For FOR$CVT_D_TF arguments
	.WORD	7,0
	.ADDRESS .+4
	.BLKB	7

	.ALIGN	LONG			; LPA11-K requirement
TRANSFER_TABLE:				; Data Transfer Command Table
	.WORD	^X010A			;	mode (cf. LPA11-K User's Guide)
	.BYTE	1			;	highest buffer available (0-7)
	.BLKB	1			;	(unused)
	.ADDRESS USER_STATUS		;	pointer to user status word
	.LONG	2*WRITE_SIZE*2		;	overall data buffer length (bytes)
	.ADDRESS LA_AK_BUF11		;	overall data buffer address
	.LONG	0			;	random channel list length
	.ADDRESS 0			;	random channel list address
	.WORD	100			;	delay
	.BYTE	0			;	start channel number
	.BYTE	0			;	channel increment
	.WORD	10			;	number of samples in sequence
	.WORD	10			;	dwell
	.BYTE	0			;	digital trigger channel
	.BYTE	0			;	event mark channel
	.WORD	^XFFFF			;	digital trigger mask
	.WORD	^XFFFF			;	event mark mask
	.BLKW	1			;	(unused)

	.ALIGN	WORD			; LPA11-K requirement
USER_STATUS:				; User status word from transfer table
	.WORD	0			; (cf. LPA11-K User's Guide, p.2-19)

AINTRVL:				; Holds CLOCK A speed
	.QUAD	CLOCK_SPEED		; "D_FLOATING" for FOR$CVT_D_TF

COMP_RATE:				; Receives computed actual CLOCK A...
	.QUAD	0			; ...speed for debugging info

;
; For a note concerning the names of the following items, see the text where
; the GEN_ARG_LIST macro is defined.
;
LA_W_LBUF:				; Size in words of data buffers
	.WORD	WRITE_SIZE

LA_B_DRS:				; Number of DR11-K's on this LPA11-K
	.BLKB	1+3			; (Count + filler to make PUSHL easy)

LA_B_ADS:				; Number of AD11-K's on this LPA11-K
	.BLKB	1+3			; (Count + filler to make PUSHL easy)

LA_B_DAS:				; Number of AA11-K's on this LPA11-K
	.BLKB	1+3			; (Count + filler to make PUSHL easy)

LA_W_NCHN:				; Number of AD11-K samples/sequence
	.BLKW	1

LA_K_LAMSKB:				; LPA11-K select mask
	.BLKW	4

LA_W_NUM:				; LPA11-K number ($ DEFINE/SYS LPA11$'NUM)
	.BLKW	1

LA_L_IND:				; Return status from support routines
	.BLKL	1

LA_L_IERROR:				; More LPA11-K status
	.BLKL	1

LA_W_IPRSET:				; Hardware clock preset value
	.BLKL	1

LA_L_IRATE:				; Clock rate.  Cf. I/O User's Guide
	.BLKL	1

LA_L_NBUF:				; Number of times to fill buffers/request
	.BLKL	1

LA_W_MODE:				; Sampling options.  Cf. I/O User's Guide
	.BLKW	1

LA_W_DWELL:				; Number of hardware clock overflows between
	.BLKW	1			; ...sample sequences in multirequest mode

LA_W_LDELAY:				; Delay from sweep start until first...
	.BLKW	1			; ...sample is taken

LA_B_ICHN:				; First LPA11-K channel to be sampled
	.BLKB	1

	.SBTTL	General Data Buffers
	.PSECT	BUFFERS,WRT,NOEXE,PAGE	; .PSECT name affects ordering!

;
; GEN_BUFFERS generates parallel sets of buffers of a given size and data type.
; Each call to GEN_BUFFERS defines an inner macro, GENERATOR, with the
; arguments specific to each kind of buffer, and then repeatedly calls the
; GENERATOR macro to set up each buffer.  The GENERATOR macro is needed in
; order to define labels for individual buffers.  The labels differ from one
; another by the last character of their name, a digit.  For a note concerning
; the names of the following items, see the text where the GEN_ARG_LIST macro
; is defined.
;
.MACRO	GEN_BUFFERS	BUF_TYPE,SIZE,DATA_TYPE,NUMBER

	.MACRO	GENERATOR	COUNT	; Defined specific to each buffer type
		.ALIGN	LONG		; Required by LPA11-K support routines
		LA_AK_'BUF_TYPE''COUNT:
			.BLK'DATA_TYPE	SIZE
			.NOSHOW	MEB	; Keep listings neat
	.ENDM	GENERATOR

	N = 1
	.REPEAT	NUMBER
		GENERATOR	\N	; Generate buffers
		N = N+1
	.ENDR	; NUMBER
.ENDM	GEN_BUFFERS

.SHOW	MEB	; Show first expansion of the first macro call as an example

GEN_BUFFERS	BUF1,WRITE_SIZE,W,2	; Data buffers on LPA11-K channel 1

GEN_BUFFERS	BUF2,WRITE_SIZE,W,2	; Data buffers on LPA11-K channel 2
GEN_BUFFERS	BUF3,WRITE_SIZE,W,2	; Data buffers on LPA11-K channel 3
GEN_BUFFERS	BUF4,WRITE_SIZE,W,2	; Data buffers on LPA11-K channel 4
GEN_BUFFERS	BUF5,WRITE_SIZE,W,2	; Data buffers on LPA11-K channel 5
GEN_BUFFERS	BUF6,WRITE_SIZE,W,2	; Data buffers on LPA11-K channel 6
GEN_BUFFERS	BUF7,WRITE_SIZE,W,2	; Data buffers on LPA11-K channel 7
GEN_BUFFERS	IBUF,MGT_BUF_SIZE,L,NUM_CHANNELS ; Buffer management buffers
GEN_BUFFERS	BFNUM,1,L,NUM_CHANNELS	; Points to next buffer to fill

	.SBTTL	LPA11-K Subroutine Library Argument Lists
	.PSECT	RODATA,EXE,NOWRT,PAGE	; EXE attribute changes .PSECT ordering!

;
; GEN_ARG_LIST generates sets of argument lists for a given subroutine call.
; Generally the names of these argument lists correspond to the unique part
; of the name of the subroutine call which uses them.  Only those LPA11-K
; support routines which must be called once per LPA11-K I/O bus channel
; have their argument lists defined here.  They will be called by CALLG
; instructions because the lists are static, one need not take the time to
; set up the list each time the routine is called, and the code to do the
; calls will be simpler.  Other LPA11-K routines will use CALLS instructions.
;
; Each call to GEN_ARG_LIST defines an inner macro, GENERATOR, with the
; arguments specific to each kind of arg list, and then repeatedly calls the
; GENERATOR macro to set up each arg list.  The GENERATOR macro is needed in
; order to define labels for individual arg lists.  The labels differ from one
; another by the last character of their name, a digit.  Where an individual
; argument references storage defined by the GEN_BUFFERS macro, one must
; specify the argument name less the last character.  Instead of that last
; character, one gives the string, "'L", which will cause the last character
; of the argument list to be appended.  The listing file produced by assembling
; this file shows the expansion of the first argument of the first call of
; GEN_ARG_LIST (viz., SWEEP_ARGL_1).  One can see the symbol defined for the
; beginning of the arg list, the count of the arguments to follow, and the
; arguments themselves.
;
; The GENERATOR macro creates two kinds of items on an argument list:
; addresses and longwords.  It decides which to create based on the first three
; characters of the item to place on the arglist.  If the first three
; characters are "LA_", the decision is made that the item is an address of
; some named location in the code.  Otherwise, it is assumed that the item for
; the arglist is just a literal value to be placed in a longword.
;
.MACRO	GEN_ARG_LIST	ARGL_TYPE,NUMBER,ARGS

	.MACRO	GENERATOR	L,M	; Defined specific to each arg list
		ARGL_TYPE'_ARGL_'L:
			.BYTE	M,0,0,0
			.IRP	EACH_ARG,<ARGS>
				.IF EQ %LOCATE(<LA_>,EACH_ARG)
					.ADDRESS EACH_ARG
				.IFF
					.LONG	EACH_ARG
				.ENDC	; IF EQ LOCATE
			.ENDR	; EACH_ARG
			.NOSHOW	MEB	; Keep listings neat
	.ENDM	GENERATOR

	M = 0
	.IRP	EACH_ARG,<ARGS>
		M = M+1
	.ENDR	; EACH_ARG
	N = 1
	.REPEAT	NUMBER
		GENERATOR	\N,\M	; Generate each argument list
		N = N+1
	.ENDR	; NUMBER
.ENDM	GEN_ARG_LIST

.SHOW	MEB	; Show first expansion of the first macro call as an example

GEN_ARG_LIST	SWEEP,NUM_CHANNELS,-
		<LA_AK_IBUF'L,LA_W_LBUF,LA_L_NBUF,LA_W_MODE,LA_W_DWELL,-
		LA_A_IGTBUF_'L,LA_W_LDELAY,LA_B_ICHN,LA_W_NCHN,LA_L_IND>
		; Start an asynchronous sweep

GEN_ARG_LIST	SYSWP,2,-
		<LA_AK_IBUF'L,LA_W_LBUF,LA_L_NBUF,LA_W_MODE,LA_W_DWELL,-
		10+'L,LA_W_LDELAY,LA_B_ICHN,LA_W_NCHN,LA_L_IND>
		; Start a synchronous sweep

GEN_ARG_LIST	SETIBF,NUM_CHANNELS,-
		<LA_AK_IBUF'L,LA_L_IND,LA_K_LAMSKB,LA_AK_BUF'L'1,LA_AK_BUF'L'2>
		; Set up buffer array for sweeps

GEN_ARG_LIST	IWTBUF,2,<LA_AK_IBUF'L,0,LA_AK_BFNUM'L>
		; Wait for the next free buffer

GEN_ARG_LIST	IGTBUF,NUM_CHANNELS,<LA_AK_IBUF'L,LA_AK_BFNUM'L>
		; Tell me which buffer to process

GEN_ARG_LIST	RLSBUF,NUM_CHANNELS,<LA_AK_IBUF'L,LA_L_IND,LITERAL_0,LITERAL_1>
		; Put a buffer into the ready queue

	.SBTTL	RMS-32 Data Structures
	.PSECT	RWDATA,WRT,NOEXE,PAGE	; .PSECT name affects ordering!
	.ALIGN	LONG

SYSIN_FAB:				; Allocate FAB for SYS$INPUT
	$FAB-
	FNM = <SYS$INPUT:>

SYSIN_RAB:				; Allocate RAB for SYS$INPUT
	$RAB-
	FAB = SYSIN_FAB,-
	ROP = PMT,-
	PBF = PROMPT,-
	PSZ = PMTSIZ,-
	UBF = DEV_NAME,-
	USZ = NAME_LEN

INI_FAB:				; Allocate FAB for UETINIDEV
	$FAB-
	FAC = <GET,PUT,UPD>,-
	RAT = CR,-
	SHR = <GET,PUT,UPI>,-
	FNM = <UETINIDEV.DAT>

INI_RAB:				; Allocate RAB for UETINIDEV
	$RAB-
	FAB = INI_FAB,-
	RBF = BUFFER,-
	UBF = BUFFER,-
	USZ = REC_SIZE

DDB_RFA:				; RFA storage for INI_RAB
	.BLKB	6

	.ALIGN	LONG
SUP_FAB:				; Allocate FAB for UETSUPDEV
	$FAB-
	FAC = GET,-
	SHR = <UPI,GET>,-
	RAT = CR,-
	FOP = UFO,-
	FNM = <UETSUPDEV.DAT>

	.SBTTL	Test and Device Initialization
	.PSECT	LPA11K,EXE,NOWRT,PAGE

	.DEFAULT DISPLACEMENT,WORD

;+
;	Start up the LPA11-K test. This entails some overhead necessary to cope
;	with both expected and unforseen conditions, figuring out just what
;	devices are to be tested, making sure we can test the indicated devices
;	and setting up writeable space for each device to be tested.
;-

.ENTRY UETLPAK00,^M<>			; Entry mask

	MOVAL	SSERROR,(FP)		; Declare exception handler
	$SETSFM_S ENBFLG = #1		; Enable system service failure mode
	$DCLEXH_S DESBLK = EXIT_DESC	; Declare an exit handler
	$TRNLOG_S LOGNAM = TTNAME_RWPTR,- ; See if there is some SYS$INPUT
		  RSLBUF = BUFFER_PTR
	CMPL	R0,#SS$_NOTRAN		; Is there some translation?
	BEQL	20$			; BR if no SYS$INPUT assigned
	$OPEN	FAB = SYSIN_FAB,-	; Open SYS$INPUT
		ERR = RMS_ERROR
	$CONNECT RAB = SYSIN_RAB,-	; Connect RAB to SYS$INPUT
		 ERR = RMS_ERROR
	BBC	#DEV$V_TRM,-		; BR if SYS$INPUT is NOT a terminal
		SYSIN_FAB+FAB$L_DEV,10$
 	$TRNLOG_S LOGNAM = CONTROLLER,-	; Get the name of our LPA11-K
		  RSLLEN = DEVNAM_LEN,-
		  RSLBUF = DEVDSC
	CMPL	R0,#SS$_NORMAL		; Was a controller specified?
	BEQL	PROC_CONT_NAME		; BR if it was - go process it
10$:
	$GET	RAB = SYSIN_RAB,-	; Read SYS$INPUT for controller name
		ERR = RMS_ERROR
	MOVW	SYSIN_RAB+RAB$W_RSZ,-	; Save the name length
		DEVNAM_LEN
	BNEQ	PROC_CONT_NAME		; BR if we got something
20$:
	MOVL	#SS$_BADPARAM,STATUS	; Save the exit status
	PUSHAL	NO_CTRLNAME		; Prepare for message...
	PUSHL	#1			; ...
	PUSHL	#UETP$_TEXT!STS$K_ERROR ; ...
	PUSHL	#3			; ...
	BRW	ERROR_EXIT		; ...to tell of bad setup

PROC_CONT_NAME:
	MOVW	DEVNAM_LEN,DEVDSC	; Set the device name length
	PUSHAL	DEVDSC			; Make sure...
	PUSHAL	DEVDSC			; ...that the specified controller...
	CALLS	#2,G^STR$UPCASE		; ...is all uppercase for later comaparison
	ADDW2	DEVNAM_LEN,PROCESS_NAME	; Get true process name length
	CMPW	PROCESS_NAME,#MAX_PROC_NAME ; Is the result too long for VMS?
	BLEQ	10$			; BR if not
	MOVW	#MAX_PROC_NAME,PROCESS_NAME ; Make it as long as you can
10$:
	CLRL	-(SP)			; Set the time stamp flag
	PUSHAL	PROCESS_NAME		; Set the test name
	PUSHL	#2			; Push the argument count
	PUSHL	#UETP$_BEGIND!STS$K_SUCCESS ; Set the message code
	CALLS	#4,G^LIB$SIGNAL		; Print the startup message
	BISW2	#BEGIN_MSGM,FLAG	; Set flag so we don't output it again
	$SETPRN_S PRCNAM = PROCESS_NAME	; Set the process name to UETLPAK00_yyn
	BBS	#DEV$V_TRM,-		; BR if SYS$INPUT is a terminal
		SYSIN_FAB+FAB$L_DEV,20$
	BRW	40$
20$:
	$TRNLOG_S LOGNAM = TTNAME_RWPTR,- ; Recursively translate the name...
		  RSLLEN = TTNAME_RWPTR,- ; ...of our controlling terminal
		  RSLBUF = TTNAME_ROPTR
	MOVAL	TTNAME,TTNAME_RWPTR+4	; Undo possible previous PPF fixup
	CMPL	R0,#SS$_NOTRAN		; Have we reached the end yet?
	BEQL	30$			; BR if we have
	CMPW	#^X001B,TTNAME		; Is this a Process Permanent File?
	BNEQ	20$			; Recursively translate if not
	SUBW	#4,TTNAME_RWPTR		; Remove RMS overhead from PPF name
	ADDL2	#4,TTNAME_RWPTR+4
	BRB	20$
30$:
	$ASSIGN_S DEVNAM = TTNAME_RWPTR,- ; We always need to assign a channel
		  CHAN   = TTCHAN	  ; Returned channel number
	$QIOW_S	CHAN     = TTCHAN,-	; Enable CTRL/C AST's...
		FUNC     = #IO$_SETMODE!IO$M_CTRLCAST,-
		P1       = CCASTHAND
	PUSHAL	TEST_NAME		; ...and tell the user...
	PUSHL	#1			; ...
	PUSHL	#UETP$_ABORTC!STS$K_SUCCESS ; ...how to abort gracefully...
	CALLS	#3,G^LIB$SIGNAL		; ...
40$:
	$TRNLOG_S LOGNAM = MODE,-	; Get the run mode
		  RSLLEN = BUFFER_PTR,-
		  RSLBUF = FAO_BUF
	BICB2	#LC_BITM,BUFFER		; Convert to upper case
	CMPB	#^A/O/,BUFFER		; Is this a one shot?
	BNEQ	45$			; BR if not
	BISW2	#ONE_SHOTM,FLAG		; Set flag for one-shot mode
45$:
	CMPL	#^A/DUMP/,BUFFER	; Special dump mode info wanted?
	BNEQ	47$			; BR if not
	BISW2	#DUMP_MODEM,FLAG	; Set flag for dump mode messages
47$:

;
; From UETINIDEV.DAT and UETSUPDEV.DAT, get information which gives controller
; and unit configuration and lets us know if the setup to run this test was
; done correctly.
;
	$OPEN	FAB = INI_FAB,-		; Open file "UETINIDEV.DAT"
		ERR = RMS_ERROR
	$CONNECT RAB = INI_RAB,-	; Connect the RAB and FAB
		 ERR = RMS_ERROR
	$MGBLSC_S  INADR = INADDRESS,-	; Connect to UETSUPDEV global section
		  RETADR = OUTADDRESS,-
		  GSDNAM = SUPDEV_GBLSEC,-
		   FLAGS = #SEC$M_EXPREG
	CMPL	R0,#SS$_NOSUCHSEC	; Was the section already there?
	BNEQ	50$			; BR if it was...
	$OPEN	FAB = SUP_FAB,-		; ...else open "UETSUPDEV.DAT"
		ERR = RMS_ERROR
	$CRMPSC_S CHAN = SUP_FAB+FAB$L_STV,- ; Create the global section
		 INADR = INADDRESS,-
		RETADR = OUTADDRESS,-
		GSDNAM = SUPDEV_GBLSEC,-
		 FLAGS = #SEC$M_EXPREG!SEC$M_GBL
50$:
	SUBL3	OUTADDRESS,OUTADDRESS+4,R6 ; Create global section length

FIND_IT:
	$GET	RAB = INI_RAB,-		; Get the first record
		ERR = RMS_ERROR
	PUSHAL	CONT_DESC		; Make sure...
	PUSHAL	CONT_DESC		; ...that the controller name...
	CALLS	#2,G^STR$UPCASE		; ...is all uppercase letters
	CMPB	#^A/D/,BUFFER		; Is this a DDB?
	BEQL	10$			; Go on if not
	CMPB	#^A/E/,BUFFER		; Is this the end of the file?
	BNEQ	FIND_IT			; Continue on if not
	PUSHAL	DEVDSC			; Push device not supported message
	PUSHAL	PROCESS_NAME		; Parameters on the stack
	PUSHL	#2
	PUSHL	#UETP$_DENOSU
	INSV	#STS$K_ERROR,-
		#STS$V_SEVERITY,-
		#STS$S_SEVERITY,(SP)	; Set the severity code...
	MOVL	(SP),STATUS		; ...and save it as the exit status
	PUSHL	#4
	BRW	ERROR_EXIT		; Exit in error
10$:
	CMPC	DEVNAM_LEN,BUFFER+6,DEV_NAME ; Is this the right controller?
	BNEQ	FIND_IT			; BR if not
	MOVC3	#6,INI_RAB+RAB$W_RFA,DDB_RFA ; Save the Record File Address
	CMPB	#^A/T/,BUFFER+4		; Can we test this controller?
	BEQL	FOUND_IT		; BR if we can...
	$FAO_S	CTRSTR = DEAD_CTRLNAME,- ; ...and yell at user if we can't
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = #DEVDSC
	MOVL	#SS$_BADPARAM,STATUS	; Set return status
	PUSHAL	BUFFER_PTR		; ...
	PUSHL	#1			; ...
	PUSHL	#UETP$_TEXT!STS$K_ERROR	; ...
	PUSHL	#3			; ...
	BRW	ERROR_EXIT		; We can't test what we can't test

FOUND_IT:
	$GET	RAB = INI_RAB,-		; Get a record
		ERR = RMS_ERROR
	PUSHAL	CONT_DESC		; Make sure...
	PUSHAL	CONT_DESC		; ...that this line...
	CALLS	#2,G^STR$UPCASE		; ...is all uppercase letters
	CMPB	#^A/U/,BUFFER		; Is this a UCB?
	BEQL	20$			; BR if it is
	CMPB	#^A/D/,BUFFER		; Is this a DDB?
	BEQL	10$			; BR if yes
	CMPB	#^A/E/,BUFFER		; Is this the end?
	BEQL	10$			; BR if yes
	PUSHAL	ILLEGAL_REC		; Then this is an error in the record
	PUSHL	#1			; Push the error message
	PUSHL	#UETP$_TEXT!STS$K_ERROR ; Push the signal name
	PUSHL	#3			; Push the temp arg count
	BRW	ERROR_EXIT		; Finish for good
10$:
	BRW	ALL_SET			; Found DDB or END
20$:
	CMPB	#^A/T/,BUFFER+4		; Is the unit testable?
	BNEQ	FOUND_IT		; BR if not
	SKPC	#^A/ /,#MAX_UNIT_DESIG,- ; Find out where unit number really is
		BUFFER+6
	DECL	R0			; We want to skip...
	SKPC	#^A/0/,R0,(R1)		; ...any leading zeroes in the unit...
	INCL	R0			; ...but leave last digit if it's 0
	ADDW3	R0,DEVNAM_LEN,DEVDSC	; Calculate device'unit string length
	MOVZWL	DEVNAM_LEN,R2		; Offset to unit number in DEVDSC
	MOVC3	R0,(R1),L^DEV_NAME(R2)	; Append unit number to device
	$GETDEV_S DEVNAM = DEVDSC,-	; Get the device characteristics
		  PRIBUF = DIB
	MOVZBL	DIBBUF+DIB$B_DEVCLASS,R7 ; Save the device class
	MOVZBL	DIBBUF+DIB$B_DEVTYPE,R8	; Save the device type
	$FAO_S	CTRSTR = CS1,-
		OUTBUF = FAO_BUF,-
		P1     = R7,-
		P2     = R8		; Make it into a string
	MATCHC	#6,BUFFER,R6,@OUTADDRESS ; Find the device class and type
	BEQL	30$			; BR if it was found
	$FAO_S	CTRSTR = CS3,-		; Try for full class support
		OUTBUF = FAO_BUF,-
		    P1 = R7
	MATCHC	#6,BUFFER,R6,@OUTADDRESS ; Find the device class only
	BNEQ	40$			; BR if not found
30$:
	MOVZBL	TEST_NAME,R5		; Get the test name length
	CMPC3	R5,(R3),TEST_NAME+8	; Are we the right test?
	BEQL	50$			; BR if yes
40$:
	PUSHAL	DEVDSC			; Push device not supported message
	PUSHAL	PROCESS_NAME		; Parameters on the stack
	PUSHL	#2			; Push the argument count
	PUSHL	#UETP$_DENOSU
	INSV	#STS$K_ERROR,-
		#STS$V_SEVERITY,-
		#STS$S_SEVERITY,(SP)	; Set the severity code...
	MOVL	(SP),STATUS		; ...and save it as the exit status
	PUSHL	#4			; Push the partial arg count...
	BRW	ERROR_EXIT		; ...and split this scene
50$:
	$EXPREG_S PAGCNT = #PAGES,-	; Get a new node of demand zero memory
		  RETADR = NEW_NODE
	INSQTI	@NEW_NODE,UNIT_LIST	; Put the new node in the unit list
	MOVL	NEW_NODE,R6		; Save a copy of its address
	MOVB	#1,UETUNT$B_TYPE(R6)	; Set the structure type
	MOVW	#UETUNT$C_INDSIZ+DEVDEP_SIZE,-
		UETUNT$W_SIZE(R6)	; Set the structure size
	BISB2	#UETUNT$M_TESTABLE,-	; By default, the unit is testable
		UETUNT$B_FLAGS(R6)
	MOVB	DEVDSC,UETUNT$T_FILSPC(R6) ; Set the device name size
	MOVC3	DEVDSC,@DEVDSC+4,-
		UETUNT$T_FILSPC+1(R6)	; Save the device name
	SUBW3	#1,DEVNAM_LEN,R7	; Pick off the letter giving controller...
	SUBB3	#^A/A/,@DEVDSC+4[R7],LA_W_NUM ; ...and convert to a number
	PUSHAL	LA_W_NUM		; Specify which LPA11-K we will use...
	PUSHAL	LA_K_LAMSKB		; ...
	CALLS	#2,G^LPA$LAMSKS		; ...
;
; Fill the sets of buffers for the LPA11-K with random data.  There are seven
; contiguous sets of two contiguous buffers each.
;
	MOVL	#WRITE_SIZE*NUM_CHANNELS,R7 ; Total buffer size in longwords
	MOVAL	L^LA_AK_BUF11,R8	; Point to first buffer
60$:
	ADDL2	RANDOM2,RANDOM1		; Create a "random" longword
	MOVL	RANDOM1,(R8)+		; Stuff it into our buffer...
	SOBGTR	R7,60$			; ...until the buffer is full

	BRW	FOUND_IT		; Do the next UCB

;
; Arrive here when we have the device configuration.  In normal or loop forever
; mode, set a timer far enough in the future such that we can do a reasonable
; set of tests before the timer expires, but if our device gets hung, the
; program won't waste too much time before noticing.  Let one-shot mode be a
; special case.
;
ALL_SET:
	TSTL	UNIT_LIST		; Anything to test?
	BNEQ	10$			; BR if yes
	PUSHAL	NOUNIT_SELECTED		; Else set up the error message...
	PUSHL	#1			; ...argument count...
	PUSHL	#UETP$_TEXT!STS$K_ERROR	; ...signal name...
	PUSHL	#3			; ...and parameter count
	MOVL	#SS$_BADPARAM,STATUS	; Set return status
	BRW	ERROR_EXIT		; ...and give up, complaining
10$:
	BISW2	#SAFE_TO_UPDM,FLAG	; OK safe to update UETINIDEV.DAT now
	$GETJPI_S ITMLST = PRIB_ITMLST	; Get & save our process' base priority
	CLRL	R6			; Clear collector for changed priority
	$TRNLOG_S LOGNAM = LPA11K_PRIORITY,- ; See if the user...
		  RSLLEN = BUFFER_PTR,-	     ; ...wants to boost...
		  RSLBUF = FAO_BUF	     ; ...our base priority easily
	CMPW	#SS$_NOTRAN,R0		; We'll try if user asked
	BEQL	20$			; BR if not requested this way
	PUSHL	#0			; We have string, value goes to stack
	PUSHL	SP			; Value address for OTS$CVT below
	PUSHAL	BUFFER_PTR		; String for OTS$CVT
	CALLS	#2,G^OTS$CVT_TI_L	; Convert translated string to number
	POPL	R6			; Collect whatever value we got
	BNEQ	30$			; Runtime value has precedence, if we got it
20$:
	MOVL	#JOB_PRIORITY,R6	; Zero or no translation, try built in
30$:
	CMPL	R6,BASE_PRIORITY	; Do we want to boost our priority?
	BLEQ	40$			; BR if we're as good as we can get
	$SETPRV_S ENBFLG = #1,-		; Give us SETPRI privilege
		  PRVADR = NEEDED_PRIVS
	$SETPRI_S PRI = R6		; Boost our base priority
40$:
	$GETJPI_S ITMLST = IMAGNAM_ITMLST,- ; We depend on system LPA11-K...
		EFN    = #JPI_EFN,-	  ; ...microcode loader process...
		PRCNAM = LALOADER_PROC,-  ; ...in order to load microcode
		IOSB   = IMAGNAM_IOSB
	$WAITFR_S EFN    = #JPI_EFN	; $GETJPI of another process is asynch
	CMPW	#SS$_NONEXPR,IMAGNAM_IOSB ; Is the mcode loader proc running?
	BEQL	50$			; BR if not
	MATCHC	LALOADER_IMAGE,LALOADER_IMAGE+8,- ; Proc name OK, check image name
		MCODE_IMAGLEN,MCODE_IMAGNAM
	BEQL	60$			; BR if correct image, too
50$:
	PUSHAL	NO_LALOADER		; Someone forgot to do correct setup
	PUSHL	#1			; We're unhappy about that
	PUSHL	#UETP$_TEXT!STS$K_ERROR	; And we've got something to say!
	PUSHL	#3
	MOVL	#SS$_NONEXPR-STS$K_WARNING+STS$K_ERROR,STATUS
	BRW	ERROR_EXIT
60$:
	BBC	#ONE_SHOTV,FLAG,TIME_IT	; BR if not one-shot...
	BISW2	#TEST_OVERM,FLAG	; ...else end after one iteration...
	BRW	ONE_SHOT_TEST		; ...and do a special test
TIME_IT:
	$SETIMR_S DAYTIM = THREEMIN,-	; Set timer AST to 3 minutes
		  ASTADR = TIME_OUT,-
		  EFN    = #EFN2

	.SBTTL	Test the LPA11-K
RESTART:
;+
; At this point the device designation is in location DEV_NAME pointed to by
; descriptor DEVDSC. The device is known to be supported by this test.
;
; The LPA11-K is capable of supporting up to eight different users at once
; with the multiuser microcode loaded.  This test uses that microcode to test
; as many devices as are present on the LPA bus.  There will be a request for
; each device and each request will be double buffered.  Each individual
; buffer will be WRITE_SIZE words long.  The requests will be started one
; immediately after the other, with the result that there should be several
; active requests at the same time.  Once the sweeps are all started, the
; program will wait for all the requests to complete and test that they all
; completed without an error.  No comparisons of data will be made, however.
;-

MU_TEST:
	BBC	#DUMP_MODEV,FLAG,10$	; BR if not typing debug info
	PUSHAL	MU_BEG_MSG
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_INFO
	CALLS	#3,G^LIB$SIGNAL		; Give some reassurance
10$:

	MOVAL	MU_MCODE,MCODE_ADDR	; We'll be dealing with...
	MOVL	#LA$K_MRMCODE,MCODE_TYPE ; ...multiuser mcode

	PUSHAL	LA_L_IERROR
	PUSHAL	LA_L_IND
	PUSHAL	LA_W_NUM
	PUSHAL	MCODE_TYPE
	CALLS	#4,G^LPA$LOADMC		; Load multiuser microcode
	BSBW	LOADMC_CHECK		; Check for errors
;
; Determine the configuration of the LPA11-K I/O bus before entering test mode.
; We must redo the original $GETDEV for this LPA11-K now that we know for sure
; that there is microcode loaded into it.  Devices present on the bus are made
; known by a bit mask in the device dependent characteristics longword.
;
	$GETDEV_S DEVNAM = DEVDSC,-	; Get the LPA11-K configuration
		  PRIBUF = DIB
	MOVL	DIBBUF+DIB$L_DEVDEPEND,R7 ; Save in register for easy access
	FFC	#LA$V_AD1,#2,R7,R8	; Count each type...
	SUBB3	#LA$V_AD1,R8,LA_B_ADS	; (AD11-K)
	BBC	#LA$V_DA,R7,20$		; ...of device which can...
	BISB2	#1,LA_B_DAS		; (AA11-K)
20$:
	FFC	#LA$V_DIO1,#5,R7,R8	; ...be on the LPA11-K I/O bus
	SUBB3	#LA$V_DIO1,R8,LA_B_DRS	; (DR11-K)
	BSBW	CONFIG_CHECK

	PUSHAB	LITERAL_0
	PUSHAW	LA_W_IPRSET
	PUSHAL	LA_L_IRATE
	PUSHAQ	AINTRVL
	CALLS	#4,G^LPA$XRATE		; Calculate the clock A rate
	MOVL	R0,COMP_RATE		; Computed rate for debug info
	BSBW	XRATE_CHECK

	BBS	#DUMP_MODEV,FLAG,30$	; BR if typing debug info
	BRW	70$			; BR around debug typeout
30$:
	PUSHL	#5
	PUSHAQ	FLOAT_PTR
	PUSHAQ	COMP_RATE
	CALLS	#3,G^FOR$CVT_D_TF	; Convert clock speed to text
	MOVAL	S_MSG,R6		; Assume for now...
	MOVAL	S_MSG,R7		; ...that we will not have...
	MOVAL	S_MSG,R8		; ...exactly one...
	CMPB	#1,LA_B_ADS		; ...AD11-K,...
	BNEQ	40$			; ...
	MOVAL	NULL_MSG,R6		; ...(but change the message if we do)
40$:
	CMPB	#1,LA_B_DAS		; ...AA11-K,...
	BNEQ	50$			; ...
	MOVAL	NULL_MSG,R7		; ...(but change the message if we do)
50$:
	CMPB	#1,LA_B_DRS		; ...or DR11-K...
	BNEQ	60$			; ...
	MOVAL	NULL_MSG,R8		; ...(change the message if we do)
60$:
	$FAO_S	CTRSTR = CONFIG_MSG,-	; Form configuration message
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = LA_B_ADS,-
		P2     = R6,-
		P3     = LA_B_DAS,-
		P4     = R7,-
		P5     = LA_B_DRS,-
		P6     = R8,-
		P7     = #FLOAT_PTR
	PUSHAL	BUFFER_PTR
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_INFO
	CALLS	#3,G^LIB$SIGNAL		; Type LPA11-K configuration
70$:

	PUSHAW	LA_W_NUM
	PUSHAL	LA_L_IND
	PUSHAW	LA_W_IPRSET
	PUSHAL	LA_L_IRATE
	CALLS	#4,G^LPA$CLOCKA		; Preset the real time clock
	BSBW	CLOCKA_CHECK
;
; Set up the buffer structure necessary to transmit and keep track of data.
; Issue test requests based on the devices detected on the LPA11-K I/O bus.
;
	PUSHL	#SETIBF			; Indicate the function we want done
	CALLS	#1,ONCE_FOR_EACH	; Set up buffers for each channel

	TSTB	LA_B_ADS		; If there are no AD11-K's to test...
	BEQL	80$			; ...BR, else...
	MULB3	#64,LA_B_ADS,LA_W_NCHN	; ...calc AD11-K samples/seq
	PUSHAL	LA_L_IND
	PUSHAL	LITERAL_1
	PUSHAW	LA_W_NCHN
	PUSHAL	LITERAL_0
	PUSHL	#0
	PUSHAL	LA_AK_IBUF1
	CALLS	#6,G^LPA$SETADC		; ...and set up A-to-D channel info
	BSBW	SETADC_CHECK
80$:
;
; Release to the queue for initial LPA11-K use the buffers used by the test
; requests.
;
	PUSHL	#RLSBUF
	CALLS	#1,ONCE_FOR_EACH	; Release buffers for each channel
;
; Start the sweeps.  First, initialize some parameters common to all sweep
; routines.  Then set up a counter, SWEEP_COUNT, which will be incremented
; for each sweep we successfully start.  Its use is explained below.
;
	MOVW	#1,LA_W_DWELL		; # of clock overflows between samples
	MOVW	#1,LA_W_NCHN		; # of I/O device channels to sample
	MOVL	#2,LA_L_NBUF		; Count of total buffers to be filled
	CLRB	SWEEP_COUNT		; Clear counter for successful sweeps
	PUSHL	#SWEEP
	CALLS	#1,ONCE_FOR_EACH	; Start sweeps on each channel
;
; Wait for sweeps to complete.  Since notification of sweep completion happens
; at AST level but we want to continue with the rest of the test only when all
; sweeps have completed, we'll wait until SWEEP_COUNT gets back down to zero,
; polling it occasionally.  We don't want to wait too long, however, so provide
; an escape.  Other error checking is done by the AST completion routines.
;
	CLRL	R6			; Counter for times we've polled
90$:
	TSTB	SWEEP_COUNT		; Finished all sweeps yet?
	BEQL	100$			; BR if we have
	$SCHDWK_S DAYTIM = FIVE_SECONDS	; No, give them more time
	$HIBER_S
	AOBLSS	#MU_TIME_OUT,R6,90$	; Loop to see if finished now
	PUSHAL	COUNTED_OUT_MSG		; LPA11-K seems to be hung
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_ERROR
	PUSHL	#3
	BRW	ERROR_EXIT
100$:

	BBC	#DUMP_MODEV,FLAG,110$	; BR if not typing debug info
	PUSHAL	MU_END_MSG
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_INFO
	CALLS	#3,G^LIB$SIGNAL		; Give some reassurance
110$:

;+
; This section will be skipped if there are no AD11-K's on the LPA11-K I/O
; bus.  If there are, exercise each by initiating a request.  There will be two
; buffers for each AD11-K, and 200 buffers of information will be passed to the
; test program before the request terminates.  The sweep will be started and
; run at the same clock rate as before.  Wait for the sweep to finish and check
; for completion without errors.  Again, no data comparison is done.
;-

AD_TEST:
	TSTB	LA_B_ADS		; Have we any AD11-K's?
	BNEQ	10$			; BR if we do
	BRW	100$			; Skip this section if not
10$:
	BBC	#DUMP_MODEV,FLAG,20$	; BR if not typing debug info
	PUSHAL	AD_BEG_MSG
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_INFO
	CALLS	#3,G^LIB$SIGNAL
20$:

	MOVAL	AD_MCODE,MCODE_ADDR	; We'll be dealing with A-to-D mcode
	MOVL	#LA$K_ADMCODE,MCODE_TYPE

	PUSHAL	LA_L_IERROR		; Load dedicated A-to-D microcode
	PUSHAL	LA_L_IND
	PUSHAW	LA_W_NUM
	PUSHAL	MCODE_TYPE
	CALLS	#4,G^LPA$LOADMC
	BSBW	LOADMC_CHECK

	PUSHAB	LITERAL_0
	PUSHAW	LA_W_IPRSET
	PUSHAL	LA_L_IRATE
	PUSHAQ	AINTRVL
	CALLS	#4,G^LPA$XRATE		; Calculate the clock rate and...
	BSBW	XRATE_CHECK

	PUSHAW	LA_W_NUM
	PUSHAL	LA_L_IND
	PUSHAW	LA_W_IPRSET
	PUSHAL	LA_L_IRATE
	CALLS	#4,G^LPA$CLOCKA		; ...preset the real time clock
	BSBW	CLOCKA_CHECK

	MOVAL	SETIBF_ARGL_1,R2	; (Pacify error checking routine)
	CALLG	(R2),G^LPA$SETIBF	; Set up buffer structure
	BSBW	SETIBF_CHECK

	MULB3	#64,LA_B_ADS,LA_W_NCHN	; Calculate AD11-K samples/sequence
	PUSHAL	LA_L_IND
	PUSHAL	LITERAL_1
	PUSHAW	LA_W_NCHN
	PUSHAL	LITERAL_0
	PUSHL	#0
	PUSHAL	LA_AK_IBUF1
	CALLS	#6,G^LPA$SETADC		; Set A-to-D channel information
	BSBW	SETADC_CHECK

	MOVAL	RLSBUF_ARGL_1,R2	; (Pacify error checking routine)
	CALLG	(R2),G^LPA$RLSBUF	; Release buffers for initial use
	BSBW	RLSBUF_CHECK

;
; Start the sweep of the dedicated A-to-D test.  LA_W_MODE is set to a
; default value of 0 if there is but one AD11-K, a value of 8192 if there
; are two AD11-K's.
;
	CLRW	LA_W_MODE		; Default is one AD11-K
	BBC	#1,LA_B_ADS,30$		; BR if that is the case
	BBSS	#13,LA_W_MODE,30$	; Otherwise indicate two AD11-K's
30$:
	MOVL	#200,LA_L_NBUF		; Count of buffers to be filled
	MOVW	#1,LA_W_DWELL		; Time between sample sequences
	MOVW	#1,LA_W_LDELAY		; Delay until first sample is taken
	CLRB	LA_B_ICHN		; First I/O channel to be sampled
	MOVW	#1,LA_W_NCHN		; I/O channels to sample per sequence
	MOVAL	SYSWP_ARGL_1,R2		; (Pacify error checking routine)
	CALLG	(R2),G^LPA$ADSWP	; Start the sweep
	BSBW	SWEEP_CHECK

;
; Loop while the sweep is continuing.  Release a buffer whenever one is
; returned.
;
40$:
	MOVAL	IWTBUF_ARGL_1,R2	; (Pacify error checking routine)
	CALLG	(R2),G^LPA$IWTBUF	; Wait for a buffer to be ready
	MOVL	LA_AK_BFNUM1,R0		; Put return status where convenient
	BLSS	50$			; BR when sweep finishes
	PUSHAL	LA_AK_BFNUM1		; More to go, release the buffer again
	PUSHAL	LA_L_IND
	PUSHAL	LA_AK_IBUF1
	CALLS	#3,G^LPA$RLSBUF
	BSBW	RLSBUF_CHECK
	BRB	40$			; Loop
50$:
	BSBW	IWTBUF_CHECK

	BBC	#DUMP_MODEV,FLAG,100$	; BR if not typing debug info
	PUSHAL	AD_END_MSG
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_INFO
	CALLS	#3,G^LIB$SIGNAL
100$:

;+
; If there is an AA11-K on the LPA11-K I/O bus, start the dedicated D-to-A
; test.  This test will be slightly different from the previous ones in that
; it will allow the user to view a test pattern on an oscilloscope if s/he
; wishes.  The test will fill two adjacent buffers with "ramp data".  This
; data will be output to channel 0 for several seconds and the user may view
; the resultant waveform.  The test will run with the real time clock set at
; the same speed as in the previous tests.
;-

DA_TEST:
	TSTB	LA_B_DAS		; Have we any AA11-K's off the LPA11-K?
	BNEQ	10$			; Continue with D-to-A test if so
	BRW	100$			; Skip this section if not
10$:
	BBC	#DUMP_MODEV,FLAG,20$	; BR if not typing debug info
	PUSHAL	DA_BEG_MSG
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_INFO
	CALLS	#3,G^LIB$SIGNAL
20$:

;
; Fill the "ramp" data buffer with data which will appear as a sawtooth shape
; when the AA11-K is watched with an oscilloscope.
;
	CLRL	R7			; Used as both index and data
30$:
	MOVW	R7,RAMP_DATA[R7]	; RAMP1(R7) := R7
	MOVW	R7,RAMP_DATA1[R7]	; RAMP2(R7) := R7
	AOBLSS	#RAMP_HEIGHT,R7,30$	; Loop until top of ramp is reached

	MOVAL	DA_MCODE,MCODE_ADDR	; We'll be dealing with D-to-A mcode
	MOVL	#LA$K_DAMCODE,MCODE_TYPE

	PUSHAL	LA_L_IERROR		; Load dedicated D-to-A microcode
	PUSHAL	LA_L_IND
	PUSHAW	LA_W_NUM
	PUSHAL	MCODE_TYPE
	CALLS	#4,G^LPA$LOADMC
	BSBW	LOADMC_CHECK

	PUSHAB	LITERAL_0
	PUSHAW	LA_W_IPRSET
	PUSHAL	LA_L_IRATE
	PUSHAQ	AINTRVL
	CALLS	#4,G^LPA$XRATE		; Calculate the clock rate and...
	BSBW	XRATE_CHECK

	PUSHAW	LA_W_NUM
	PUSHAL	LA_L_IND
	PUSHAW	LA_W_IPRSET
	PUSHAL	LA_L_IRATE
	CALLS	#4,G^LPA$CLOCKA		; ...preset the real time clock
	BSBW	CLOCKA_CHECK

	PUSHAL	RAMP_DATA1		; Set up...
	PUSHAL	RAMP_DATA		; ...a special...
	PUSHAL	LA_K_LAMSKB		; ...argument list...
	PUSHAL	LA_L_IND		; ...for this...
	PUSHAL	LA_AK_IBUF2		; ...one call
	PUSHL	#5
	MOVL	SP,R2			; Pacify error checking & fake CALLG
	CALLG	(R2),G^LPA$SETIBF	; Set up buffer structure
	BSBW	SETIBF_CHECK
	ADDL2	#20,SP			; Clean up the stack

	MOVAL	RLSBUF_ARGL_2,R2	; (Pacify error checking routine)
	CALLG	(R2),G^LPA$RLSBUF	; Release buffers for initial use
	BSBW	RLSBUF_CHECK

	MOVL	#75,LA_L_NBUF		; Count of buffers to be filled
	CLRW	LA_W_MODE		; Sampling options
	MOVW	#1,LA_W_DWELL		; Time between sample sequences
	MOVW	#1,LA_W_LDELAY		; Delay until first sample is taken
	CLRB	LA_B_ICHN		; First I/O channel to be sampled
	MOVW	#1,LA_W_NCHN		; I/O channels to sample per sequence
	MOVAL	SYSWP_ARGL_2,R2		; (Pacify error checking routine)
	CALLG	(R2),G^LPA$DASWP	; Start the sweep
	BSBW	SWEEP_CHECK

;
; Loop while the sweep is continuing.  Release a buffer whenever one is
; returned.
;
40$:
	MOVAL	IWTBUF_ARGL_2,R2	; (Pacify error checking routine)
	CALLG	(R2),G^LPA$IWTBUF	; Wait for a buffer to be ready
	MOVL	LA_AK_BFNUM2,R0		; Put return status where convenient
	BLSS	50$			; BR when sweep finishes
	PUSHAL	LA_AK_BFNUM2		; More to go, release the buffer again
	PUSHAL	LA_L_IND
	PUSHAL	LA_AK_IBUF2
	CALLS	#3,G^LPA$RLSBUF
	BSBW	RLSBUF_CHECK
	BRB	40$			; Loop
50$:
	BSBW	IWTBUF_CHECK

	BBC	#DUMP_MODEV,FLAG,100$	; BR if not typing debug info
	PUSHAL	DA_END_MSG
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_INFO
	CALLS	#3,G^LIB$SIGNAL
100$:


	INCL	ITERATION		; Increment iteration count
	BBS	#TEST_OVERV,FLAG,110$	; BR if the test is over
	BRW	RESTART			; Loop until the test is over
110$:
	BRW	SUC_EXIT

	.SBTTL	One-Shot Testing
;+
; The forced overrun test will run only in one shot mode.  It will do a couple
; of regular data transfers using the multiuser microcode, then force a data
; overrun to see if the LPA11-K can detect the situation.  Instead of using
; the high level language interface routines, it will use $QIOs to access the
; LPA11-K most of the time.  The exception is in initializing the LPA11-K.
; This is an error prone task which is better performed by the system
; microcode loader process.  We rationalize by saying that unless a user had
; special microcode to load, he, too, would always use the standard procedure.
; Using $QIOs in other places permits us to take advantage of the $QIO's
; flexibility:  when we force an overrun, we don't want the user to think his
; LPA11-K is malfunctioning, so inhibit error logging with the IO$M_INHERLOG
; modifier.  The forced overrun test will be implemented in a future release.
;-
ONE_SHOT_TEST:
FO_TEST:
	MOVAL	AD_MCODE,MCODE_ADDR	 ; Try loading all types of ucode...
	MOVL	#LA$K_ADMCODE,MCODE_TYPE ; ...analog-to-digital...
	BSBB	100$
	MOVAL	DA_MCODE,MCODE_ADDR	 ; ...
	MOVL	#LA$K_DAMCODE,MCODE_TYPE ; ...digital-to-analogue...
	BSBB	100$
	MOVAL	MU_MCODE,MCODE_ADDR	 ; ...and finishing up with...
	MOVL	#LA$K_MRMCODE,MCODE_TYPE ; ...multiuser mcode
	BSBB	100$
	BRW	SUC_EXIT

100$:
	PUSHAL	LA_L_IERROR
	PUSHAL	LA_L_IND
	PUSHAL	LA_W_NUM
	PUSHAL	MCODE_TYPE
	CALLS	#4,G^LPA$LOADMC		; Load multiuser microcode
	BRW	LOADMC_CHECK		; Check for errors
	; Note that LOADMC_CHECK returns via RSB if it returns at all.
	; Branching to it is equivalent to BSBW followed by RSB.

	.SBTTL	Finish Testing
SUC_EXIT:
	$TRNLOG_S LOGNAM = MODE,-
		  RSLLEN = BUFFER_PTR,-
		  RSLBUF = FAO_BUF	; Get the run mode
	BICB2	#LC_BITM,BUFFER		; Convert to upper case
	CMPB	#^A/L/,BUFFER		; Is this a loop for ever?
	BNEQ	10$			; BR if not
	BICW2	#TEST_OVERM,FLAG	; Reset the termination flag
	INCL	PASS			; Bump the pass count
	$FAO_S	CTRSTR = PASS_MSG,-
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = PASS,-
		P2     = ITERATION,-
		P3     = #0		; Make the end of pass message
	PUSHAL	BUFFER_PTR		; Push the string desc.
	PUSHL	#1			; Push arg count
	PUSHL	#UETP$_TEXT!STS$K_INFO	; Push the signal name
	CALLS	#3,G^LIB$SIGNAL		; Print the end of pass message
	CLRL	ITERATION		; Reset the iteration count
	BRW	TIME_IT			; Do the next pass
10$:
	MOVL	#SS$_NORMAL!STS$M_INHIB_MSG,STATUS ; Set successful exit status
	$EXIT_S STATUS			; Exit with the status

	.SBTTL	Common Subroutine Caller for Multirequest Mode
;++
; FUNCTIONAL DESCRIPTION:
;	This routine will be called whenever there is a common function to
;	perform for each LPA11-K I/O bus channel in multirequest mode.  For
;	example, setting up channel buffer management info needs to be done
;	for all connected devices.  The routine provides a way to pool common
;	code and make the main listing somewhat more readable.
;
; CALLING SEQUENCE:
;	CALLx	#1,ONCE_FOR_EACH
;
; INPUT PARAMETERS:
;	4(AP) has the function code for what each channel needs done.
;
; IMPLICIT INPUTS:
;	The argument lists for all subroutine calls are defined by the
;	GEN_ARG_LIST macro.
;	Various buffers and other subroutine parameters are elsewhere defined.
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Buffers and parameters mentioned above may be modified by subroutine
;	calls.
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	An error will result in an explanatory message and program abort.
;
;--

ONCE_FOR_EACH:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	CASEB	4(AP),#0,#LAST_FUNCTION	; Go our separate ways based on function
10$:
		.WORD	SETIBF_SECTION-10$
		.WORD	SWEEP_SECTION-10$
		.WORD	RLSBUF_SECTION-10$
; Fall through only if there is a bad argument list.

	$FAO_S	CTRSTR = BAD_CASE_MSG,-	; Bad parameter passed to ONCE_FOR_EACH
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = 4(AP)
	PUSHAL	BUFFER_PTR
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_SEVERE
	PUSHL	#3
	MOVL	#SS$_ABORT,STATUS	; This has to be a serious problem...
	BRW	ERROR_EXIT		; ...and we can't possibly recover

SETIBF_SECTION:				; Do a call(s) to LPA$SETIBF
	TSTB	LA_B_ADS		; Any AD11-Ks configured?
	BEQL	10$			; BR if not
	MOVAL	SETIBF_ARGL_1,R2	; Set up AD11-K arg list
	BSBB	SETIBF_COMMON		; Set up buffers
10$:
	TSTB	LA_B_DAS		; Any AA11-Ks configured?
	BEQL	20$			; BR if not
	MOVAL	SETIBF_ARGL_2,R2	; Set up AA11-K arg list
	BSBB	SETIBF_COMMON		; Set up buffers
20$:
	CASEB	LA_B_DRS,#1,#5-1	; Dispatch on the number of DR11-Ks
30$:		.WORD	80$-30$,70$-30$,60$-30$,50$-30$,40$-30$
	RET				; Fall through if none configured
40$:
	MOVAL	SETIBF_ARGL_7,R2	; Set up DR11-K #5 arg list
	BSBB	SETIBF_COMMON		; Set up buffers
50$:
	MOVAL	SETIBF_ARGL_6,R2	; Set up DR11-K #4 arg list
	BSBB	SETIBF_COMMON		; Set up buffers
60$:
	MOVAL	SETIBF_ARGL_5,R2	; Set up DR11-K #3 arg list
	BSBB	SETIBF_COMMON		; Set up buffers
70$:
	MOVAL	SETIBF_ARGL_4,R2	; Set up DR11-K #2 arg list
	BSBB	SETIBF_COMMON		; Set up buffers
80$:
	MOVAL	SETIBF_ARGL_3,R2	; Set up DR11-K #1 arg list
	BSBB	SETIBF_COMMON		; Set up buffers
	RET

SETIBF_COMMON:				; Common code for each type of device
	CALLG	(R2),G^LPA$SETIBF	; Set up buffer array for sweeps
	BRW	SETIBF_CHECK		; Return fat and happy via error check

RLSBUF_SECTION:				; Do a call(s) to LPA$RLSBUF
	TSTB	LA_B_ADS		; Any AD11-Ks configured?
	BEQL	10$			; BR if not
	MOVAL	RLSBUF_ARGL_1,R2	; Set up AD11-K arg list
	BSBB	RLSBUF_COMMON		; Release buffers
10$:
	TSTB	LA_B_DAS		; Any AA11-Ks configured?
	BEQL	20$			; BR if not
	MOVAL	RLSBUF_ARGL_2,R2	; Set up AA11-K arg list
	BSBB	RLSBUF_COMMON		; Release buffers
20$:
	CASEB	LA_B_DRS,#1,#5-1	; Dispatch on the number of DR11-Ks
30$:		.WORD	80$-30$,70$-30$,60$-30$,50$-30$,40$-30$
	RET				; Fall through if none configured
40$:
	MOVAL	RLSBUF_ARGL_7,R2	; Set up DR11-K #5 arg list
	BSBB	RLSBUF_COMMON		; Release buffers
50$:
	MOVAL	RLSBUF_ARGL_6,R2	; Set up DR11-K #4 arg list
	BSBB	RLSBUF_COMMON		; Release buffers
60$:
	MOVAL	RLSBUF_ARGL_5,R2	; Set up DR11-K #3 arg list
	BSBB	RLSBUF_COMMON		; Release buffers
70$:
	MOVAL	RLSBUF_ARGL_4,R2	; Set up DR11-K #2 arg list
	BSBB	RLSBUF_COMMON		; Release buffers
80$:
	MOVAL	RLSBUF_ARGL_3,R2	; Set up DR11-K #1 arg list
	BSBB	RLSBUF_COMMON		; Release buffers
	RET

RLSBUF_COMMON:				; Common code for each type of device
	CALLG	(R2),G^LPA$RLSBUF	; Release buffer array for sweeps
	BRW	RLSBUF_CHECK		; Return fat and happy via error check

SWEEP_SECTION:				; Do a call(s) to LPA$SWEEP
	TSTB	LA_B_ADS		; Any AD11-Ks configured?
	BEQL	10$			; BR if not
	MOVW	#64,LA_W_MODE		; Set up call specific...
	MOVW	#00,LA_W_LDELAY		; ...arguments...
	MOVB	#00,LA_B_ICHN		; ...
	MOVAL	G^LPA$ADSWP,R3
	MOVAL	SWEEP_ARGL_1,R2		; Set up AD11-K arg list
	BSBW	SWEEP_COMMON		; Start up a sweep
10$:
	TSTB	LA_B_DAS		; Any AA11-Ks configured?
	BEQL	20$			; BR if not
	MOVW	#64,LA_W_MODE		; Set up call specific...
	MOVW	#25,LA_W_LDELAY		; ...arguments...
	MOVB	#00,LA_B_ICHN		; ...
	MOVAL	G^LPA$DASWP,R3
	MOVAL	SWEEP_ARGL_2,R2		; Set up AA11-K arg list
	BSBW	SWEEP_COMMON		; Start up a sweep
20$:
	MOVW	#00,LA_W_MODE		; Value for all DISWP calls
	MOVAL	G^LPA$DISWP,R3
	CASEB	LA_B_DRS,#1,#5-1	; Dispatch on the number of DR11-Ks
30$:		.WORD	80$-30$,70$-30$,60$-30$,50$-30$,40$-30$
	RET				; Fall through if none configured
40$:
	MOVW	#00,LA_W_LDELAY		; Set up call specific...
	MOVB	#04,LA_B_ICHN		; ...arguments
	MOVAL	SWEEP_ARGL_7,R2		; Set up DR11-K #5 arg list
	BSBB	SWEEP_COMMON		; Start up a sweep
50$:
	MOVW	#25,LA_W_LDELAY		; Set up call specific...
	MOVB	#03,LA_B_ICHN		; ...arguments
	MOVAL	SWEEP_ARGL_6,R2		; Set up DR11-K #4 arg list
	BSBB	SWEEP_COMMON		; Start up a sweep
60$:
	MOVW	#00,LA_W_LDELAY		; Set up call specific...
	MOVB	#02,LA_B_ICHN		; ...arguments
	MOVAL	SWEEP_ARGL_5,R2		; Set up DR11-K #3 arg list
	BSBB	SWEEP_COMMON		; Start up a sweep
70$:
	MOVW	#25,LA_W_LDELAY		; Set up call specific...
	MOVB	#01,LA_B_ICHN		; ...arguments
	MOVAL	SWEEP_ARGL_4,R2		; Set up DR11-K #2 arg list
	BSBB	SWEEP_COMMON		; Start up a sweep
80$:
	MOVW	#00,LA_W_LDELAY		; Set up call specific...
	MOVB	#00,LA_B_ICHN		; ...arguments
	MOVAL	SWEEP_ARGL_3,R2		; Set up DR11-K #1 arg list
	BSBB	SWEEP_COMMON		; Start up a sweep
	RET

SWEEP_COMMON:				; Common code for each type of device
	CALLG	(R2),(R3)		; Start up a sweep
	INCB	SWEEP_COUNT		; Assume sweep started successfully
	BRW	SWEEP_CHECK		; Return fat and happy via error check

	.SBTTL	AST Level Completion Routines
;++
; FUNCTIONAL DESCRIPTION:
;	These routines are called whenever the LPA11-K signals that it has
;	a buffer ready to process.  Although we do nothing with the buffer,
;	we have to appease the LPA11-K by picking up the buffer number.
;
; CALLING SEQUENCE:
;	Called at AST level by LPA11-K support routines via CALLx.  Indicated
;	for use by the LPA$ sweep routine IEFN argument.
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	Because each LPA11-K channel gets the address of a different routine
;	when the sweeps are started, the entry point to each of these routines
;	effectively tells us which channel has a waiting buffer.
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Buffers and parameters mentioned above may be modified by subroutine
;	calls.
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	An error will result in an explanatory message and program abort.
;
;--

LA_A_IGTBUF_7:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	MOVAL	IGTBUF_ARGL_7,R2	; Set up DR11-K #5 arg list
	BRB	IGTBUF_COMMON

LA_A_IGTBUF_6:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	MOVAL	IGTBUF_ARGL_6,R2	; Set up DR11-K #4 arg list
	BRB	IGTBUF_COMMON

LA_A_IGTBUF_5:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	MOVAL	IGTBUF_ARGL_5,R2	; Set up DR11-K #3 arg list
	BRB	IGTBUF_COMMON

LA_A_IGTBUF_4:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	MOVAL	IGTBUF_ARGL_4,R2	; Set up DR11-K #2 arg list
	BRB	IGTBUF_COMMON

LA_A_IGTBUF_3:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	MOVAL	IGTBUF_ARGL_3,R2	; Set up DR11-K #1 arg list
	BRB	IGTBUF_COMMON

LA_A_IGTBUF_2:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	MOVAL	IGTBUF_ARGL_2,R2	; Set up AA11-K arg list
	BRB	IGTBUF_COMMON

LA_A_IGTBUF_1:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	MOVAL	IGTBUF_ARGL_1,R2	; Set up AD11-K arg list
	;BRB	IGTBUF_COMMON

IGTBUF_COMMON:
	CALLG	(R2),G^LPA$IGTBUF	; Get next buffer to process
	MOVL	@08(R2),R0		; Save the return status
	BSBW	IGTBUF_CHECK		; See if sweep went correctly
	RET				; Dismiss the AST

	.SBTTL	Error Checking Subroutines
;++
; FUNCTIONAL DESCRIPTION:
;	This set of routines checks for errors returned by the various high
;	level LPA11-K support routines.  It was decided to isolate them from
;	the inline code because they greatly diminished the readability of the
;	text.
;
; CALLING SEQUENCE:
;	They are typically invoked immediately following one of the LPA$...
;	routines.  Called by BSBW.
;
; INPUTS, OUTPUTS, COMPLETION CODES AND SIDE EFFECTS:
;	The code executes in the context of the portion of the main code which
;	called it.  Forming subroutines of these is an attempt to avoid the
;	space overhead which would be incurred were they implemented as macros.
;	Therefore, there are no explict input/output parameters or returns.  If
;	an error is found, an appropriate message is formed and the program is
;	exited.  It is the responsibility of the programmer to see that each
;	routine is called uniformly throughout the program.
;--

CONFIG_CHECK:				; Here when we determine I/O bus configuration
	ADDB3	LA_B_ADS,LA_B_DAS,R7	; See...
	ADDB2	LA_B_DRS,R7		; ...if we can see any devices at all
	BEQL	10$
	RSB
10$:
	MOVL	#SS$_BADPARAM&<^C^B111>!STS$K_SEVERE,STATUS
	PUSHAL	NAKED_ERR_MSG		; Nothing configured, must be busted
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_SEVERE
	PUSHL	#3
	BRW	ERROR_EXIT



SETADC_CHECK:				; Here when A-to-D channel info set up
	BLBC	LA_L_IND,10$		; No error message if call succeeded
	RSB
10$:
	$FAO_S	CTRSTR = AD11K_ERR_MSG,- ; Yell if it failed (impossible, but)
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = MU_MCODE
	PUSHAL	BUFFER_PTR
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_ERROR
	PUSHL	#3
	BRW	ERROR_EXIT

LOADMC_CHECK:				; Here when mcode just loaded
	BLBC	LA_L_IND,10$		; Microcode loaded correctly?
	RSB				; Return if all is well
10$:
	ADDL3	#UNIT_LIST,UNIT_LIST,R6	; Point to unit data block
	BICB2	#UETUNT$M_TESTABLE,-	; This unit is no longer testable
		UETUNT$B_FLAGS(R6)	; (LOADMC_CHECK called in ONE-SHOT mode)
	CMPW	#SS$_DEVREQERR,LA_L_IND	; Is this...
	BEQL	20$
	CMPW	#SS$_CTRLERR,LA_L_IND	; ...an error code which...
	BEQL	20$
	CMPW	#SS$_DEVCMDERR,LA_L_IND	; ...yields additional info?
	BEQL	20$			; BR if it is
	MOVAL	LOAD_MISC_ERR_MSG,R4	; It's not - give a dumb message
	CLRL	R0			; Supply dummies for $FAO below
	CLRL	R1
	CLRL	R2
	CLRL	R3
	BRB	30$
20$:
	MOVAL	LOAD_BAD_ERR_MSG,R4	; Give msg with additional info
	MOVZBL	LA_L_IERROR+0,R0	; Get LPA11-K Control Out register...
	MOVZBL	LA_L_IERROR+1,R1	; ...Status Out register...
	MOVZBL	LA_L_IERROR+2,R2	; ...low byte Maintenance Status...
	MOVZBL	LA_L_IERROR+3,R3	; ...and high byte Maintenance Status
30$:
	$FAO_S	CTRSTR = (R4),-		; Form whichever error message
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = MCODE_ADDR,-
		P2     = R1,-
		P3     = R0,-
		P4     = R3,-
		P5     = R2
	MOVL	LA_L_IND,STATUS
	PUSHL	STATUS
	PUSHAL	BUFFER_PTR
	PUSHL	#1
	PUSHL	#UETP$_TEXT
	INSV	LA_L_IND,#STS$V_SEVERITY,#STS$S_SEVERITY,(SP)
	PUSHL	#4
	BRW	ERROR_EXIT



XRATE_CHECK:				; Here when clock A rate calculated
	TSTL	R0			; Error only when function value is 0
	BEQL	10$
	RSB
10$:
	PUSHAL	BADRATE_ERR_MSG
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_ERROR
	PUSHL	#3
	BRW	ERROR_EXIT

CLOCKA_CHECK:				; Here when real time clock gets preset
	BLBC	LA_L_IND,10$		; Any error?
	RSB				; Return if not
10$:
	$FAO_S	CTRSTR = CLOCK_ERR_MSG,-
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = MCODE_ADDR
	MOVL	LA_L_IND,STATUS
	PUSHL	STATUS
	PUSHAL	BUFFER_PTR
	PUSHL	#1
	PUSHL	#UETP$_TEXT
	INSV	LA_L_IND,#STS$V_SEVERITY,#STS$S_SEVERITY,(SP)
	PUSHL	#4
	BRW	ERROR_EXIT



SETIBF_CHECK:				; Here when buffer list initialized
	BLBC	@08(R2),10$		; BR if some error was found
	RSB
10$:
	$FAO_S	CTRSTR = SETUP_ERR_MSG,- ; Complain if we found an error
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = MCODE_ADDR
	PUSHAL	BUFFER_PTR		; ...
	PUSHL	#1			; ...
	PUSHL	#UETP$_TEXT!STS$K_ERROR	; ...
	PUSHL	#3			; ...
	BRW	ERROR_EXIT		; We can't continue



SWEEP_CHECK:				; Here when returning from sweeps
	BLBC	LA_L_IND,10$		; Any indication of an error?
	RSB				; No, return
10$:
	;DECB	SWEEP_COUNT		; This sweep failed, don't wait for it
	$FAO_S	CTRSTR = SWEEP_ERR_MSG,- ; Complain about the error
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = MCODE_ADDR
	MOVL	LA_L_IND,STATUS		; Supply an exit status
	PUSHL	STATUS
	PUSHAL	BUFFER_PTR
	PUSHL	#1
	PUSHL	#UETP$_TEXT
	INSV	LA_L_IND,#STS$V_SEVERITY,#STS$S_SEVERITY,(SP)
	PUSHL	#4
	BRW	ERROR_EXIT

IGTBUF_CHECK:				; See if buffer got filled correctly
IWTBUF_CHECK:				; Here after waiting for a buffer to be filled
	TSTL	R0			; Did the sweep terminate?
	BLSS	10$			; BR if it did
	RSB				; Return if it hasn't yet
10$:
	MOVL	04(R2),R1		; Point to IOSB for this sweep
	TSTW	(R1)			; Is the sweep still active?
	BNEQ	20$			; BR if not
	RSB				; We do nothing if it is
20$:
	DECB	SWEEP_COUNT		; This sweep has terminated, don't wait
					; (This has no effect unless multiuser)
	BLBC	(R1),30$		; Any indication of an error?
	RSB				; No, return
30$:
	MOVZWL	(R1),STATUS		; Supply an exit status
	CMPW	#SS$_DEVREQERR,(R1)	; Is this...
	BEQL	40$
	CMPW	#SS$_CTRLERR,(R1)	; ...an error code which...
	BEQL	40$
	CMPW	#SS$_DEVCMDERR,(R1)	; ...yields additional info?
	BEQL	40$			; BR if it is
	MOVAL	IWTBUF_MISC_ERR_MSG,R4	; It's not - give a dumb message
	CLRL	R0			; Supply dummies for $FAO below
	CLRL	R1
	CLRL	R2
	CLRL	R3
	BRB	50$
40$:
	MOVAL	IWTBUF_BAD_ERR_MSG,R4	; Give msg with additional info
	MOVZBL	04(R1),R0		; Get LPA11-K Control Out register...
	MOVZBL	06(R1),R2		; ...low byte Maintenance Status...
	MOVZBL	07(R1),R3		; ...high byte Maintenance Status...
	MOVZBL	05(R1),R1		; ...and Status Out register...
	CMPB	#LA_K_OVERRUN,R1	; Error was buffer overrun/underrun?
	BNEQ	50$			; BR if it was something else
	MOVAL	OVERRUN_ERR_MSG,R4	; Supply specific error msg if it was
50$:
	$FAO_S	CTRSTR = (R4),-		; Form whichever error message
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = MCODE_ADDR,-
		P2     = R1,-
		P3     = R0,-
		P4     = R3,-
		P5     = R2
	PUSHL	STATUS
	PUSHAL	BUFFER_PTR
	PUSHL	#1
	PUSHL	#UETP$_TEXT
	INSV	STATUS,#STS$V_SEVERITY,#STS$S_SEVERITY,(SP)
	PUSHL	#4
	BRW	ERROR_EXIT

RLSBUF_CHECK:				; Here after buffers are made again available
	BLBC	LA_L_IND,10$		; Any indication of an error?
	RSB				; No, return
10$:
	$FAO_S	CTRSTR = RELEASE_ERR_MSG,- ; Yes, complain
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = MCODE_ADDR
	MOVL	LA_L_IND,STATUS		; Supply an exit status
	PUSHAL	BUFFER_PTR
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_ERROR
	PUSHL	#3
	BRW	ERROR_EXIT

	.SBTTL	Timer Expiration Routine
;++
; FUNCTIONAL DESCRIPTION:
;	This routine will be called when the timer to mark the end of the test
;	goes off.
;
; CALLING SEQUENCE:
;	Called via AST at $SETIMR expiration.
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

TIME_OUT:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	BISW2	#TEST_OVERM,FLAG	; Tell test to stop when convenient
	RET

	.SBTTL	System Service Exception Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine is executed if a software or hardware exception occurs or
;	if a LIB$SIGNAL system service is used to output a message.
;	Information about this method of handling messages and errors can be
;	found in the VMS COMMON RUN-TIME manual and in the VMS SYSTEM SERVICE
;	manual.
;
; CALLING SEQUENCE:
;	Entered via an exception from the system
;
; INPUT PARAMETERS:
;	ERROR_COUNT   = previous cumulative error count
;	                -----------------
;	   AP ---->     !       2       !
;			!---------------!
;			! SIGNL ARY PNT !
;			!---------------!
;			! MECH  ARY PNT !
;			!---------------! ---------
;			!       4       !         ^
;			!---------------!         !
;			! ESTABLISH FP  !         !
;			!---------------!         !
;			!    DEPTH      ! Mechanism Array
;			!---------------!         !
;			!      R0       !         !
;			!---------------!         !
;			!      R1       !         v
;			!---------------! ---------
;			!       N       !         ^
;			!---------------!         !
;			! CONDITION NAME!         !
;			!---------------!         !
;			! N-3 ADDITIONAL!    Signal Array
;			! LONG WORD ARGS!         !
;			!---------------!         !
;			!      PC       !         !
;			!---------------!         !
;			!      PSL      !         v
;			!---------------! ---------
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	May branch to ERROR_EXIT
;--

SSERROR:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	$SETAST_S ENBFLG = #0		; Disable AST delivery
	CLRL	AST_MODE		; Assume it was disabled
	CMPL	R0,#SS$_WASSET		; Were AST's enabled?
	BNEQ	10$			; BR if not enabled
	MOVL	#1,AST_MODE		; Set it to be reenabled
10$:	$SETSFM_S ENBFLG = #0		; Disable SS failure mode for PUTMSG
	CLRL	SS_FAIL_MODE		; Assume it was disabled
	CMPL	R0,#SS$_WASSET		; Was SS failure mode enabled?
	BNEQ	20$			; BR if not enabled
	MOVL	#1,SS_FAIL_MODE		; Set it to be reenabled
20$:	MOVL	CHF$L_SIGARGLST(AP),R6	; Get the signal array pointer
	CMPZV	#STS$V_FAC_NO,#STS$S_FAC_NO,- ; Is this a message from LIB$SIGNAL?
		CHF$L_SIG_NAME(R6),#UETP_K
	BNEQ	30$			; BR if this is a system exception
	SUBL2	#2,CHF$L_SIG_ARGS(R6)	; Drop the PC and PSL
	$PUTMSG_S MSGVEC = CHF$L_SIG_ARGS(R6) ; Print the message
	$SETSFM_S ENBFLG = SS_FAIL_MODE	; Set to previous state
	$SETAST_S ENBFLG = AST_MODE	; Set to previous state
	RET				; Return to the program
30$:
	CMPZV	#STS$V_FAC_NO,#STS$S_FAC_NO,- ; Is it an RMS failure?
		CHF$L_SIG_ARG1(R6),#RMS_K
	BNEQ	40$			; BR if not
	$SETSFM_S ENBFLG = SS_FAIL_MODE	; Set to previous state
	$SETAST_S ENBFLG = AST_MODE	; Set to previous state
	RET				; Yes, RMS_ERROR gets to handle them
40$:
	MOVL	CHF$L_SIG_NAME(R6),STATUS ; Save the status
	CLRL	R8			; Assume for now it's not SS failure
	CMPL	#SS$_SSFAIL,STATUS	; But is it a System Service failure?
	BNEQ	60$			; BR if not - no special case message
	$GETMSG_S MSGID = CHF$L_SIG_ARG1(R6),- ; Get SS failure code associated text
		 MSGLEN = BUFFER_PTR,-
		 BUFADR = FAO_BUF,-
		 FLAGS  = #14,-
		 OUTADR = MSG_BLOCK
	TSTB	MSG_BLOCK+1		; Get FAO arg count for SS failure code
	BEQL	50$			; Don't use $GETMSG if no $FAO args...
	PUSHAL	BUFFER_PTR		; ...else build up...
	PUSHL	#1			; ...a message describing...
	PUSHL	#UETP$_TEXT		; ...why the System Service failed
	INSV	CHF$L_SIG_ARG1(R6),-	; Give the message...
		#STS$V_SEVERITY,-	; ...the correct severity code
		#STS$S_SEVERITY,(SP)
	MOVL	#3,R8			; Count the number of args we pushed
	BRB	60$
50$:
	PUSHL	CHF$L_SIG_ARG1(R6)	; Save SS failure code
	MOVL	#1,R8			; Count the number of args we pushed
60$:
	MULL3	#4,CHF$L_SIG_ARGS(R6),R7 ; Convert longwords to bytes
	SUBL2	R7,SP			; Save the current signal array...
	MOVC3	R7,CHF$L_SIG_NAME(R6),(SP) ; ...on the stack
	ADDL3	R8,CHF$L_SIG_ARGS(R6),-(SP) ; Push the current arg count
	BRW	ERROR_EXIT

	.SBTTL	RMS Error Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles error returns from RMS calls.
;
; CALLING SEQUENCE:
;	Called by RMS when a file processing error is found.
;
; INPUT PARAMETERS:
;	The FAB or RAB associated with the RMS call.
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Error message
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	Program may exit, depending on severity of the error.
;
;--

RMS_ERROR:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	MOVL	4(AP),R6		; See whether we're dealing with...
	CMPB	#FAB$C_BID,FAB$B_BID(R6) ; ...a FAB or a RAB
	BNEQ	10$			; BR if it's a RAB
	MOVAL	FILE,R7			; FAB-specific code:  text string...
	MOVL	R6,R8			; ...address of FAB...
	PUSHL	FAB$L_STV(R6)		; ...STV field for error...
	PUSHL	FAB$L_STS(R6)		; ...STS field for error...
	MOVL	FAB$L_STS(R6),STATUS	; ...and save the error code
	BRB	COMMON			; FAB and RAB share other code
10$:
	MOVAL	RECORD,R7		; RAB-specific code:  text string...
	MOVL	RAB$L_FAB(R6),R8	; ...address of associated FAB...
	PUSHL	RAB$L_STV(R6)		; ...STV field for error...
	PUSHL	RAB$L_STS(R6)		; ...STS field for error...
	MOVL	RAB$L_STS(R6),STATUS	; ...and save the error code
COMMON:
	MOVZBL	FAB$B_FNS(R8),R10	; Get the file name size
	$FAO_S	CTRSTR = RMS_ERR_STRING,- ; Common code, prepare error message...
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = R7,-
		P2     = R10,-
		P3     = FAB$L_FNA(R8)
	PUSHAL	BUFFER_PTR		; ...and arguments for ERROR_EXIT...
	PUSHL	#1			; ...
	PUSHL	#UETP$_TEXT		; ...
	EXTZV	#STS$V_SEVERITY,-
		#STS$S_SEVERITY,-
		STATUS,R9 		; ...get the severity code...
	BISB2	R9,(SP)			; ...and add it into the signal name
	PUSHL	#5			; Current arg count
	BRW	ERROR_EXIT

	.SBTTL	CTRL/C Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles CTRL/C AST's
;
; CALLING SEQUENCE:
;	Called via AST
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

CCASTHAND:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	PUSHAL	CNTRLCMSG		; Set message pointer
	PUSHL	#1			; Set arg count
	PUSHL	#UETP$_TEXT!STS$K_WARNING ; Set signal name
	PUSHL	#0			; Indicate an abnormal termination
	PUSHAL	PROCESS_NAME		; ...
	PUSHL	#2			; ...
	PUSHL	#UETP$_ABENDD!STS$K_WARNING ; ...
	CALLS	#7,G^LIB$SIGNAL		; Output the message
	MOVL	#<SS$_CONTROLC-STS$K_SUCCESS+STS$K_WARNING>,-
		STATUS			; Set the exit status
	$EXIT_S	STATUS			; Terminate program cleanly

	.SBTTL	Error Exit
;++
; FUNCTIONAL DESCRIPTION:
;	This routine prints an error message and exits.
;
; CALLING SEQUENCE:
;	MOVx  error status value,STATUS
;	PUSHx error specific information on the stack
;	PUSHL current argument count
;	BRW   ERROR_EXIT
;
; INPUT PARAMETERS:
;	Arguments to LIB$SIGNAL, as above
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	Message to SYS$OUTPUT and SYS$ERROR
;
; IMPLICIT OUTPUTS:
;	Program exit
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

ERROR_EXIT:

	$SETAST_S ENBFLG = #0		; ASTs can play havoc with messages
	BBS	#BEGIN_MSGV,FLAG,10$	; BR if "begin" msg has already been output
	CLRL	-(SP)			; Set the time stamp flag
	PUSHAL	PROCESS_NAME		; Set the test name
	PUSHL	#2			; Push the argument count
	PUSHL	#UETP$_BEGIND!STS$K_SUCCESS ; Set the message code
	CALLS	#4,G^LIB$SIGNAL		; Print the startup message
10$:
	ADDL3	(SP)+,#7,ARG_COUNT	; Get total # args, pop partial count
	TSTL	STATUS			; Could we get any real exit status?
	BNEQ	20$			; BR if we did
	MOVL	#UETP$_ABENDD!STS$K_ERROR,- ; Supply a made up exit status...
		STATUS
	PUSHAL	GENERIC_ERR_MSG		; ...and a miscellaneous error message
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_ERROR
	ADDL2	#3,ARG_COUNT		; Keep an honest count for LIB$SIGNAL
20$:
	INCL	ERROR_COUNT		; Keep running error count
	PUSHL	#0			; Push the time parameter
	PUSHAL	PROCESS_NAME		; Push test name...
	PUSHL	#2			; ...arg count...
	PUSHL	#UETP$_ABENDD!STS$K_ERROR ; ...and signal name
	PUSHL	ERROR_COUNT		; Finish off arg list...
	PUSHL	#1			; ...
	PUSHL	#UETP$_ERBOX!STS$K_ERROR ; ...for error box message
	CALLS	ARG_COUNT,G^LIB$SIGNAL	; Truly bitch

	BISL	#STS$M_INHIB_MSG,STATUS	; Don't print messages twice!
	$EXIT_S STATUS			; Exit in error

	.SBTTL	Exit Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles cleanup at exit.  If the MODE logical name is
;	equated to "ONE", the routine will update the test flag in the
;	UETINIDEV.DAT file depending on the UETUNT$M_TESTABLE flag state in the
;	UETUNT$B_FLAGS field of the unit block for each unit for the device
;	under test.
;
; CALLING SEQUENCE:
;	Invoked automatically by $EXIT System Service.
;
; INPUT PARAMETERS:
;	STATUS  contains the exit status.
;	FLAG    has synchronizing bits.
;	DDB_RFA contains the RFA of the DDB record for this device in UETINIDEV.
;
; IMPLICIT INPUTS:
;	UNIT_LIST points to the head of a doubly linked circular list of unit
;		  blocks for the device under test.
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Various files are de-accessed, the process name is reset, and any
;	necessary synchronization with UETPDEV01 is carried out.
;	If the MODE logical name is equated to "ONE", the routine will update
;	the test flag in the UETINIDEV.DAT file depending on the 
;	UETUNT$M_TESTABLE flag state in the UETUNT$B_FLAGS field of the unit
;	block for each unit for the device under test.
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

EXIT_HANDLER:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	$SETSFM_S ENBFLG = #0		; Turn off System Service failure mode
	$SETAST_S ENBFLG = #0		; We're finished - no more ASTs
	$TRNLOG_S LOGNAM = MODE,-	; Get the run mode
		  RSLLEN = BUFFER_PTR,-
		  RSLBUF = FAO_BUF
	BICB2	#LC_BITM,BUFFER		; Convert to upper case
	CMPB	#^A/O/,BUFFER		; Is this a one shot?
	BEQL	10$			; BR if yes...
	BRW	END_UPDATE		; ...else don't update UETINIDEV.DAT
10$:
	BBS	#SAFE_TO_UPDV,FLAG,20$	; Only update if it's safe
	BRW	END_UPDATE		; Else forget it
20$:
	MOVAL	INI_RAB,R10		; Set the RAB address
	MOVB	#RAB$C_RFA,RAB$B_RAC(R10) ; Set RFA mode
	MOVC3	#6,DDB_RFA,RAB$W_RFA(R10) ; Set RFA to DDB line
	$GET	RAB = (R10)		; Go back to the DDB record
	BLBS	R0,30$
	BRW	END_UPDATE		; If failure then forget it
30$:
	MOVB	#RAB$C_SEQ,RAB$B_RAC(R10) ; Set back to sequential mode
	ADDL3	#UNIT_LIST,UNIT_LIST,R11 ; Set the unit block list header
	CLRL	R9			; Init an index
UNIT_LOOP:
	BITB	#UETUNT$M_TESTABLE,-
		UETUNT$B_FLAGS(R11)	; Is this unit testable?
	BEQL	10$			; BR if not
	INCL	R9			; Another unit that's testable
10$:
	ADDL2	(R11),R11		; Next unit block
	CMPL	R11,#UNIT_LIST		; Are we full circle in the list?
	BNEQ	UNIT_LOOP		; BR if not
	TSTL	R9			; Any testable units?
	BNEQ	20$			; BR if yes...
	MOVB	#^A/N/,BUFFER+4		; ...else disable the DDB record...
	$UPDATE RAB = (R10)		; ...here
	BLBC	R0,END_UPDATE		; If error then forget it
20$:
	ADDL2	(R11),R11		; Next unit block
	CMPL	R11,#UNIT_LIST		; Are we full circle in the list?
	BEQL	END_UPDATE		; BR if yes
	$GET	RAB = (R10)		; Get a record
	BLBC	R0,END_UPDATE		; If error then forget it
	BICB2	#LC_BITM,BUFFER		; Convert to uppercase
	CMPB	#^A/U/,BUFFER		; Is it a UCB record?
	BNEQ	END_UPDATE		; BR if not
	BITB	#UETUNT$M_TESTABLE,-
		UETUNT$B_FLAGS(R11)	; Is this unit testable?
	BNEQ	20$			; BR if yes...
	MOVB	#^A/N/,BUFFER+4		; ...else disable the UCB record...
	$UPDATE RAB = (R10)		; ...here
	BLBC	R0,END_UPDATE		; If error then forget it
	BRB	20$			; Look at the next record
END_UPDATE:
	TSTL	BASE_PRIORITY		; Could we have changed our priority?
	BEQL	10$			; BR if not - don't try to reset
	$SETPRI_S PRI = BASE_PRIORITY	; Restore our base priority
10$:
	PUSHL	#0			; Set the time flag
	PUSHAL	PROCESS_NAME		; Push the test name
	PUSHL	#2			; Push arg count
	PUSHL	#UETP$_ENDEDD!STS$K_SUCCESS ; Push signal name
	EXTZV	#STS$V_SEVERITY,-	; Get the proper exit severity
		#STS$S_SEVERITY,-
		STATUS,R0
	INSV	R0,#STS$V_SEVERITY,-	; Set the end message severity
		#STS$S_SEVERITY,(SP)
	CALLS	#4,G^LIB$SIGNAL		; Output the message
	$DISCONNECT  RAB = INI_RAB	; Disconnect the RAB from the FAB
	$CLOSE	     FAB = INI_FAB	; Close the file
	$SETPRN_S PRCNAM = ACNT_NAME	; Reset the process name
	RET				; That's all folks!

	.END	UETLPAK00
