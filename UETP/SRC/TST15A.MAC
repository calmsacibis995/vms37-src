	.TITLE	TST15A
	.IDENT	/V03000/
	.PSECT	TST15A
;
;
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; VERSION X01-1
;
; WRITTEN BY TREVOR W KEMPSELL, FEBRUARY 1973
;
; MODIFIED BY CLARK A. D'ELIA, MARCH 1973
; 	(ALL REFERENCES TO DEVICE 'RK' WERE CHANGED TO 'DK')
; MODIFIED BY CLARK A. D'ELIA, APRIL 1973
; MODIFIED BY TOM MILLER FOR RSX-11M, AUGUST,1974
;		TOM MILLER	OCTOBER 1974
;		LARRY JONES	DECEMBER 1977	(FOR VAX/VMS)
; MODIFIED BY ROBERT PERRON, NOV 1981
;	(DISABLE 'LP' TEST - IT DOESN'T UNDERSTAND SPOOLED DEVICES)
;
;+
; MODULE 'TST15A' IS DESIGNED TO TEST THE FOLLOWING
; RSX-11M DIRECTIVES
;
;	ASSIGN LUN
;	GET LUN INFORMATION
;
;-
	.PAGE
;
;	.MCALLS FOR THE FIRST DEPTH OF MACROS
;
	.MCALL GLUN$,ALUN$,EXIT$S,CALL,RETURN,WTSE$,QIO$
 
;
; LOCAL EQUATED SYMBOLS
;
LF = 12				;LINE FEED ASCII CODE
 
;
;	INITIAL SETTINGS USED IN THE ASSIGN LUN DIRECTIVE
;	FOR DK0,TI,LP0
;
	LUNDK=1.
	LUNTT=2.
	LUNLP=3.
;
;	UNIT NUMBER USED IN THE ASSIGN DIRECTIVE
;	FOR DK0,TI,LP0
;
	UNT0=0
;
;	THESE ARE THE BUFFERS
;	FOR THE  'GET LUN' DIRECTIVE
;

DK0BA:	.WORD	0			;NAME OF ASSIGNED DEVICE
	.WORD	0			;UNIT NUM OF ASSIGNED DEVICE +FLAGS
	.WORD	0			;DEVICE CHARACTERISTICS WD #1
	.WORD	0			;DEVICE CHARACTERISTICS WD #2
	.WORD	0			;DEVICE CHARACTERISTICS WD #3
	.WORD	0			;DEVICE CHARACTERISTICS WD #4
;
;
TIBA:	.BLKW	6
;
;
LP0BA:	.BLKW	6
	.PAGE
;
;	THIS PSECT CONTAINS THE DPB'S
;	FOR THE 'GET LUN' DIRECTIVE
;
	.PSECT	DPBGLN
DK0GL:	GLUN$	LUNDK,DK0BA
;
;
TIGL:	GLUN$	LUNTT,TIBA
;
;
LP0GL:	GLUN$	LUNLP,LP0BA
;
;	THIS PSECT CONTAINS THE DPB'S
;	FOR THE ASSIGN LUN DIRECTIVE
;
	.PSECT	DPBLUN
DK0LN:	ALUN$	LUNDK,DK,UNT0
;
;
TILN:	ALUN$	LUNTT,TT,UNT0
;
;
TILN1:	ALUN$	LUNTT,TI,UNT0
;
;
LP0LN:	ALUN$	LUNLP,LP,UNT0
;
;	THIS IS THE DPB FOR SENDING THE ERROR MESSAGES
;
	.PSECT	$DPB$$
MSGDPB:	QIO$	IO.WLB,TI,1,,,,<.OBUF,0,40>
;
;	THIS IS THE DPB FOR WAIT DIRECTIVE
;
WT1:	WTSE$	1
;	
;	THESE DPB'S CONTAIN THE WRONG SIZE
;	FOR THE GET LUN AND ASSIGN LUN DIRECTIVE
;
GETDPE:	.BYTE	5,7
	.WORD	LUNDK
	.WORD	DK0BA
ASSDPE:	.BYTE	7,10.
	.WORD	LUNDK
	.ASCII	/DK/
	.WORD	UNT0
	.PAGE

	.PSECT	TST15A
;
;	DEVICE NAME STRINGS FOR ERROR MESSAGES
;
DKASC:	.ASCII	/DK/
TTASC:	.ASCII	/TT/
LPASC:	.ASCII	/LP/
;
;	ARGUMENT LISTS FOR $EDMSG ROUTINE
;
;	ASSIGNED ARGUMENT LIST
;
ARGA:	.WORD	0			;LOGICAL UNIT NUMBER
	.WORD	0			;ADDRESS OF DEVICE NAME STRING
	.WORD	0			;DEVICE NUMBER
;
;	GET LUN ARGUMENT LIST
;
ARGG:	.WORD	0			;LOGICAL UNIT NUMBER
	.WORD	0			;ADDRESS OF DEVICE NAME STRING
	.WORD	0			;DEVICE NUMBER
;
;	THE TEXT OF ERROR MESSAGE
;
	.NLIST	BEX
ASTEX:	.ASCIZ/ ERROR IN 'LUN' INFORMATION%N/
INTEX:	.ASCIZ	/LUN %D.: DEV %2A: DEV# %D.:/
GLTEX:	.ASCIZ	/%NRETRIEVED%N /
LMG01:	.ASCIZ	<LF>/+++ SYSTEM REPORTS NO LINE PRINTER SUPPORT/

	.LIST	BEX
	.EVEN
	.PAGE

;+
;	INITIALLY THE START TEST MESSAGE
;	IS ISSUED
;-
	$$TEST	15,A
	CALL	.STST
;+
;	THE NEXT STEP ASSIGN'S
;	LOGICAL UNIT NUMBER 1 TO THE MOVING HEAD DISK DEVICE
;	NUMBER 0
;	THE GET LUN DIRECTIVE IS THEN USED TO RETRIEVE
;	THE INFORMATION FROM THE ABOVE ASSIGNMENT
;	THE RETRIEVED INFORMATION IS THEN CHECKED WITH THE
;	ASSIGNED INFORMATION
;-
	$$STEP
;*****
	JMP	NEXS1			; STEP 1 DISABLED
;*****
	DIR$	#DK0LN,.RJCT		;ASSIGN LUN 1 TO DK0
	CALL	.SUCC		;CHECK FOR VALID RETURN CODE
	DIR$	#DK0GL,.RJCT		;GET LUN INFORMATION LUN 1
	CALL	.SUCC		;CHECK FOR VALID RETURN CODE
;
;	SET UP ERROR ARGUMENTS
;	IN CASE OF COMPARISON ERROR IN CHECKING
;
;
;	FIRST ASSIGNED ARGUMENTS
;
	MOV	#LUNDK,ARGA		;LUN 1
	MOV	#DKASC,ARGA+2		;DK IS DEVICE
	MOV	#UNT0,ARGA+4		;UNIT NUMBER 0
;
;	GET LUN ARGUMENTS
;
	MOV	#LUNDK,ARGG		;LUN 1
	MOV	#DK0BA,ARGG+2		;MOVE DEVICE NAME
	MOVB	DK0BA+2,ARGG+4		;MOVE UNIT NUMBER
;
;	COMPARE  ASSIGNED INFORMATION
;	WITH  GET LUN  INFORMATION RETRIEVED
;
	MOV	#DK0BA,R1		;R1=DK GET LUN BUFFER
	CMP	(R1)+,DK0LN+A.LUNA	;COMPARE NAMES
	BEQ	OK1			;BRANCH IF EQUAL
	CALL	COMPER			;PRINT ERROR MESSAGE IF NOT
	JMP	NEXS1			;GO TO NEXT TEST
OK1:	MOVB	(R1),R2			;R2=DEVICE NUMBER
	CMP	R2,DK0LN+A.LUNU		;COMPARE DEVICE NUMBERS
	BEQ	NEXS1			;BRANCH IF EQUAL
	CALL	COMPER			;PRINT ERROR MESSAGE IF NOT
	.PAGE

NEXS1:
;+
;	THE NEXT STEP ASSIGNS
;	LOGICAL UNIT NUMBER 2 TO THE TELETYPE DEVICE
;	NUMBER 0
;	THE GET LUN DIRECTIVE IS THEN USED TO RETRIEVE
;	THE INFORMATION FROM THE ABOVE ASSIGNMENT
;	THE RETRIEVED INFORMATION IS THEN CHECKED WITH THE
;	ASSIGNED INFORMATION
;-
	$$STEP
;*****
	JMP	NEXS2			;SKIP STEP 2
;*****
	DIR$	#TILN,.RJCT		;ASSIGN LUN 2 TO TI
	CALL	.SUCC		;CHECK FOR VALID RETURN CODE
	DIR$	#TIGL,.RJCT		;GET LUN INFORMATION LUN 2
	CALL	.SUCC		;CHECK FOR VALID RETURN CODE
;
;	SET UP ERROR ARGUMENTS
;	IN CASE OF COMPARISON ERROR IN CHECKING
;
;	FIRST ASSIGNED ARGUMENTS
;
	MOV	#LUNTT,ARGA		;LUN 2
	MOV	#TTASC,ARGA+2		;TT IS DEVICE
	MOV	#UNT0,ARGA+4		;UNIT NUMBER 0
;
;	GET LUN ARGUMENTS
;
	MOV	#LUNTT,ARGG		;LUN 2
	MOV	#TIBA,ARGG+2		;MOVE DEVICE NAME
	MOVB	TIBA+2,ARGG+4		;MOVE UNIT NUMBER
;
;	COMPARE ASSIGNED INFORMATION
;	WITH GET LUN INFORMATION RETRIEVED
;
	MOV	#TIBA,R1		;R1=TT GET LUN BUFFER
	CMP	(R1)+,TILN+A.LUNA	;COMPARE NAMES
	BEQ	OK2			;BRANCH IF EQUAL
	CALL	COMPER			;PRINT ERROR MESSAGE IF NOT
	JMP	NEXS2			;GO TO NEXT TEST
OK2:	MOVB	(R1),R2			;R2=DEVICE NUMBER
	CMP	R2,TILN+A.LUNU		;COMPARE DEVICE NUMBERS
	BEQ	NEXS2			;BRANCH IF EQUAL
	CALL	COMPER			;PRINT ERROR MESSAGE IF NOT
NEXS2:
	.PAGE

;+
;
;	THE NEXT STEP ASSIGN'S
;	LOGICAL UNIT NUMBER 3 TO THE LINE PRINTER DEVICE
;	NUMBER 0
;	THE GET LUN DIRECTIVE IS THEN USED TO RETRIEVE
;	THE INFORMATION FROM THE ABOVE ASSIGNMENT
;	THE RETRIEVED INFORMATION IS THEN CHECKED WITH THE
;	ASSIGNED INFORMATION
;-
	$$STEP
;***
	JMP	NEXS3		;SKIP LP0: TESTING
;***
	DIR$	#LP0LN		;ASSIGN LUN 3 TO LP0
	BCC	20$		;BRANCH IF SUCCESSFUL
	CMP	@#$DSW,#IE.IDU	;WAS ERROR INVALID DEVICE?
	BEQ	10$		;YES, SKIP TO INFORM USER
	CALL	.RJCT		;NO, REPORT DIRECTIVE FAILURE
	BR	30$		;CONTINUE TESTING
10$:	MOV	#.OBUF,R0	;ELSE, PUT ADDR OF OUTPUT BUFFER IN R0
	MOV	#LMG01,R1	;AND ADDR OF MESSAGE IN R1
	CALL	.PRTMG		;REPORT NO EXEC SUPPORT OF LP0:
	BR	NEXS3		;SKIP LP0: TESTING
20$:	CALL	.SUCC		;CHECK FOR SUCCESS RETURN STATUS
30$:	DIR$	#LP0GL,.RJCT	;GET LUN 3 INFORMATION
	CALL	.SUCC		;CHECK FOR SUCCESS RETURN STATUS
;
;	SET UP ERROR ARGUMENTS
;	IN CASE OF COMPARISON ERROR IN CHECKING
;
;	FIRST ASSIGN ARGUMENTS
;
	MOV	#LUNLP,ARGA		;LUN 3
	MOV	#LPASC,ARGA+2		;LP IS DEVICE
	MOV	#UNT0,ARGA+4		;UNIT NUMBER 0
;
;	GET LUN ARGUMENTS
;
	MOV	#LUNLP,ARGG		;LUN 3
	MOV	#LP0BA,ARGG+2		;MOVE DEVICE NAME ADDRESS
	MOVB	LP0BA+2,ARGG+4		;MOVE DEVICE NUMBER
;
;	COMPARE ASSIGNED INFORMATION
;	WITH GET LUN INFORMATION RETRIEVED
;
	MOV	#LP0BA,R1		;R1=LP GET LUN BUFFER
	CMP	(R1)+,LP0LN+A.LUNA	;COMPARE NAMES
	BEQ	OK3			;BRANCH IF EQUAL
	CALL	COMPER			;PRINT ERROR MESSAGE IF NOT
	JMP	NEXS3			;GO TO NEXT TEST
OK3:	MOVB	(R1),R2			;R2=DEVICE NUMBER
	CMP	R2,LP0LN+A.LUNU		;COMPARE DEVICE NUMBERS
	BEQ	NEXS3			;BRANCH IF EQUAL
	CALL	COMPER			;PRINT ERROR MESSAGE IF NOT
NEXS3:
	.PAGE
;+
;	THE NEXT STEP RE-ASSIGNS LUN 3
;	LUN 3 IS CURRENTLY ASSIGNED TO THE
;	LINE PRINTER IT WILL BE RE ASSIGNED
;	TO THE MOVING HEAD DISK DK0
;	THE GET LUN DIRECTIVE IS THEN USED TO RETRIEVE
;	THE INFORMATION FROM THE ABOVE ASSIGNMENT
;	THE RETRIEVED INFORMATION IS THEN CHECKED WITH THE
;	ASSIGNED INFORMATION
;-
	$$STEP
;*****
	JMP	STP5			; STEP 4 DISABLED
;*****
	MOV	#LUNLP,DK0LN+A.LULU	;DEPOSIT LUN 3 IN DK ASSIGN DPB
	MOV	#LUNLP,DK0GL+G.LULU	;DEPOSIT LUN 3 IN DK GET LUN DPB
	DIR$	#DK0LN,.RJCT		;RE-ASSIGN LUN 3 TO DK0
	CALL	.SUCC		;CHECK FOR VALID RETURN CODE
	DIR$	#DK0GL,.RJCT		;GET LUN INFORMATION LUN 3
	CALL	.SUCC		;CHECK FOR VALID RETURN CODE

;
;	SET UP ERROR ARGUMENTS
;	IN CASE OF COMPARISON ERROR IN CHECKING
;
;	FIRST  ASSIGN ARGUMENTS
;
	MOV	#LUNLP,ARGA		;LUN 3
	MOV	#DKASC,ARGA+2		;DK IS DEVICE
	MOV	#UNT0,ARGA+4		;UNIT NUMBER 0
;
;	GET LUN ARGUMENTS
;
	MOV	#LUNLP,ARGG		;LUN 3
	MOV	#DK0BA,ARGG+2		;MOVE DEVICE NAME ADDRESS
	MOVB	DK0BA+2,ARGG+4		;MOVE DEVICE NUMBER
;
;
;	COMPARE ASSIGNED INFORMATION
;	WITH GET LUN INFORMATION RETRIEVED
;
	MOV	#DK0BA,R1		;R1=DK GET LUN BUFFER
	CMP	(R1)+,DK0LN+A.LUNA	;COMPARE NAMES
	BEQ	OK4			;BRANCH IF EQUAL
	CALL	COMPER			;PRINT ERROR MESSAGE IF NOT
	JMP	NEXS4			;GO TO NEXT TEST
OK4:	MOVB	(R1),R2			;R2=DEVICE NUMBER
	CMP	R2,DK0LN+A.LUNU		;COMPARE DEVICE NUMBERS
	BEQ	NEXS4			;BRANCH IF EQUAL
	CALL	COMPER			;PRINT ERROR MESSAGE IF NOT
NEXS4:
	.PAGE
;+
;	WILL NOW TEST THE ERROR CONDITIONS
;	ON THE GET LUN DIRECTIVE
;
;	FIRST AN UNASSIGNED LUN  (12)
;-
	$$STEP
	MOV	#12.,DK0GL+G.LULU	;DEPOSIT UNASSIGNED LUN
	MOV	#IE.ULN,R1		;MOVE EXPECTED ERR STATUS
	DIR$	#DK0GL		;GET LUN FOR UNASSIGNED LUN
	CALL	.FAIL		;CHECK THE STATUS
;+
;	NOW WITH A NEGATIVE LUN  (-1)  INVALID LUN
;-
	$$STEP
	MOV	#-1,DK0GL+G.LULU	;DEPOSIT NEGATIVE LUN
	MOV	#IE.ILU,R1		;MOVE EXPECTED ERR STATUS
	DIR$	#DK0GL		;GET LUN FOR INVALID LUN
	CALL	.FAIL		;CHECK STATUS
	.PAGE
;+
;	WILL NOW TEST THE ERROR CONDITIONS
;	ON THE ASSIGN LUN DIRECTIVE
;
;	FIRST AN INVALID DEVICE NAME SAY 'YY'
;-
	$$STEP
	MOV	#"YY,DK0LN+A.LUNA	;PUT YY AS DEVICE NAME
	MOV	#IE.IDU,R1		;MOVE EXPECTED ERROR STATUS
	DIR$	#DK0LN		;ASSIGN INVALID DEVICE NAME
	CALL	.FAIL		;CHECK STATUS
	MOV	#"DK,DK0LN+A.LUNA	;PUT BACK LEGAL DEVICE NAME  'DK'
;+
;	NOW WITH AN INVALID UNIT NUMBER
;-
	$$STEP
	MOV	#100,DK0LN+A.LUNU	;PUT INVALID UNIT NUMBER
	MOV	#IE.IDU,R1		;MOVE EXPECTED ERROR STATUS
	DIR$	#DK0LN		;ASSIGN INVALID DEVICE NUMBER
	CALL	.FAIL		;CHECK STATUS
	MOV	#0,DK0LN+A.LUNU		;PUT BACK LEGAL DEVICE NUMBER
;+
;	NOW TRY AN INVALID LOGICAL UNIT NUMBER (600)
;-
	$$STEP
	MOV	#600.,DK0LN+A.LULU	;PUT INVALID LUN
	MOV	#IE.ILU,R1		;MOVE EXPECTED ERROR STATUS
	DIR$	#DK0LN		;ASSIGN INVALID LUN
	CALL	.FAIL		;CHECK STATUS
;+
;	WILL NOW TRY INVALID DPB SIZES
;	ON GET LUN AND ASSIGN LUN DIRECTIVES
;-
	$$STEP
	MOV	#IE.SDP,R1		;MOVE EXPECTED ERROR
	DIR$	#GETDPE		;GET LUN ILLEGAL DPB SIZE
	CALL	.FAIL		;CHECK STATUS
	MOV	#IE.SDP,R1		;MOVE EXPECTED ERROR
	DIR$	#ASSDPE		;ASSIGN LUN ILL DPB SIZE
	CALL	.FAIL		;CHECK STATUS
;+
;	THIS IS THE END OF TST15A
;	PRINT THE END MESSAGE THEN
;	EXIT VIA THE EXIT DIRECTIVE
;-
	$$STEP
	DIR$	#TILN1,.RJCT		; SWITCH BACK TO USER TTY
	CALL	.ETST			;PRINT END MESSAGE
	EXIT$S	.RJCT			;EXIT
	.PAGE
;
;	THE FOLLOWING ROUTINE OUTPUTS AN ERROR MESSAGE
;	FOR DESCREPANCES BETWEEN ASSIGNED INFORMATION
;	AND INFORMATION OBTAINED USING THE GET LUN DIRECTIVE
;
;	THE FORMAT OF THE MESSAGE IS AS FOLLOWS
;
;	*** TEST XX: SUBTEST X: STEP X ERROR IN 'LUN' INFORMATION
;	LUN XX.: DEV AA: DEV# XX.:
;	RETRIEVED
;	LUN XX.: DEV AA: DEV# XX.:
;


COMPER:	MOV	R2,-(SP)		;SAVE REGISTER R2
	MOV	R1,-(SP)		;SAVE REGISTER R1
	MOV	R0,-(SP)		;SAVE REGISTER R0
	CALL	.IDOUT			;CREATE OUTPUT OF STEP IDENTIFICATION
	MOV	#ASTEX,R1		;MOVE ADDRESS NEXT PART OF MESS
	CALL	$EDMSG			;CREATE OUTPUT OF NEXT PART
	MOV	#ARGA,R2		;MOVE ADDRESS OF ARG LIST FOR
					;2ND LINE TO R2
	MOV	#INTEX,R1		;MOVE ADDRESS 2ND LINE ERROR MESS
	CALL	$EDMSG			;CREATE OUTPUT OF 2ND LINE
	MOV	#GLTEX,R1		;MOVE ADDRESS OF 3RD LINE ERROR MESSAGE
	CALL	$EDMSG			;CREATE OUTPUT OF 3RD LINE
	MOV	#INTEX,R1		;MOVE ADDRESS OF 4TH LINE ERROR MESSAGE
	MOV	#ARGG,R2		;MOVE ADDRESS OF ARG LIST
					;FOR 4TH LINE
	CALL	$EDMSG			;CREATE OUTPUT OF 4TH LINE
	SUB	#.OBUF,R0		;CALCULATE LENGTH OF OUTPUT
	MOV	R0,MSGDPB+Q.IOPL+2	;PUT BYTE COUNT IN DPB
	DIR$	#MSGDPB,.RJCT		;OUTPUT  MESSAGE
	DIR$	#WT1,.RJCT		;AND WAIT
	MOV	(SP)+,R0		;RESTORE REGISTERS  R0
	MOV	(SP)+,R1		;RESTORE REGISTERS  R1
	MOV	(SP)+,R2		;RESTORE REGISTERS  R2
	RETURN				;RETURN




	.END	STP0
