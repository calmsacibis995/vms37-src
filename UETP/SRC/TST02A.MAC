	.TITLE	TST02A
	.IDENT	/V03000/
	.PSECT	TST02A
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; VERSION  X02
;
; WRITTEN BY CLARK A. D'ELIA, OCTOBER 1972
;
; MODIFIED BY:
;	C.A. D'ELIA	AUGUST 1974  (FOR RSX-11M)
;	THOMAS J MILLER	7/15/75 (CHANGE EXPECTED ERRORS FORDPB SIZES)
;	LARRY JONES AUGUST 1978 (VAX/VMS SUPPORT)
;
;
;+
;
; MODULE 'TST02A' IS DESIGNED TO TEST THE FOLLOWING RSX-11M SYSTEM
; DIRECTIVES:
;		CLEAR EVENT FLAG
;		DECLARE SIGNIFICANT EVENT
;		READ ALL EVENT FLAGS
;		REQUEST
;		SET EVENT FLAG
;		WAITFOR LOGICAL 'OR' OF EVENT FLAGS
;		WAITFOR SINGLE EVENT FLAG
;
;-
 
	.MCALL	CALL,RETURN,CLEF$,CLEF$S,RDAF$,RQST$,SETF$S
	.MCALL	DECL$S,WTSE$,WTSE$S,WTLO$C,WTLO$S,EXIT$S,RDAF$S
 
;
; LOCAL EQUATED SYMBOLS
;
 
CLEAR=0				;EVENT FLAG RETURN, CLEAR = 0
SET=2				;EVENT FLAG RETURN, SET = 2
 
 
;
; LOCAL MACRO DEFINITIONS
;
;
; MACRO TO CALL A SUBROUTINE TO SIMULATE THE RSX-11D READ SINGLE
; EVENT FLAG DIRECTIVE.
;
 
	.MACRO	RDEF$S	EFN,ERR,?LBL
	RDAF$S	#$RDFBF,ERR
	CALL	.SUCC
	BCS	LBL
	MOV	EFN,R0
	CALL	RDEF$
LBL:
	.ENDM	RDEF$S
 
 
;
; MACRO TO SET UP THE CODE FOR ISSUING AN EVENT FLAG DIRECTIVE AND
; EVENT FLAG POLARITY CHECKING
;
	.MACRO	$SETUP	DIR,EFN,POL,?L
	.IF NB	<DIR>
	DIR'$S	EFN,.RJCT
	BCS	L
	.ENDC
	CMP	#POL,@#$DSW
	BEQ	L
	MOV	EFN,R1
	MOV	#POL,R0
	CALL	POLERR
L:
	.ENDM	$SETUP
 
 
;
; LOCAL DATA
;
 
$RDFBF:	.BLKW	4		;USED TO SIMULATE RDEF$ WITH RDAF$
 
 
EVFLGS:	.BLKW	4		;FOUR WORDS NECESSARY TO STORE FLAG POLARITIES
 
 
TST02Z:	.RAD50	/02Z/
 
 
TST02A:	.RAD50	/02A/
 
 
TST02B:	.RAD50	/TST02B/
 
	.NLIST	BEX
 
LEM01:	.ASCIZ	/LOCAL FLAG #%D. WAS NOT CLEAR/
 
LEM02:	.ASCIZ	/EVENT FLAG POLARITY ERROR%NEFN: %D., EXP'D: %D., RCV'D: %D./
 
	.LIST	BEX
	.PAGE
	.PSECT	$DPB$$
 
;
; THIS PSECT CONTAINS ONLY DPB'S.
;
 
CL35:	CLEF$	35.
 
 
RAFDPB:	RDAF$	EVFLGS
 
 
RQDPB:	RQST$	TST02B
 
 
WT35:	WTSE$	35.
	.PAGE
	.PSECT	TST02A
	.EVEN
;+
;
; THE INITIAL STEP OF THIS TASK IS TO IDENTIFY ITSELF TO THE USER
; AT TI:  VIA THE "QUEUE I/O" DIRECTIVE.
;
;-
	$$TEST	2,A
	CALL	.STST		;PRINT START OF TEST MESSAGE
;+
;
; NOW WE WILL READ ALL OF THE FLAGS USING THE "READ ALL EVENT FLAGS"
; DIRECTIVE.  PRESENTLY THE ASSUMPTION IS THAT UPON TASK INSTALLATION,
; ALL OF THE LOCAL FLAGS ARE CLEAR.  THIS STEP WILL CHECK THEM AND
; REPORT AND CLEAR ALL OF THOSE THAT ARE NOT.
;
;-
	$$STEP
	DIR$	#RAFDPB,.RJCT	;READ ALL EVENT FLAGS
	CALL	.SUCC		;CHECK PROPER SUCCESS STATUS RETURNED
	BCS	6$		;IGNORE FOLLOWING TESTS IF DIRECTIVE FAILED
 
;
; CHECK LOCAL FLAGS (FIRST CHECK THEM BY LOOKING AT A BLOCK OF 16 AT A TIME)
;
 
	MOV	#EVFLGS,R4	;PUT ADDR OF FIRST GRP OF LOCAL FLAGS IN R4
	CLR	R3		;R3 WILL HOLD THE ACTUAL FLAG NUMBERS
1$:	TST	(R4)		;TEST A GROUP OF 16 FLAGS
	BNE	2$		;IF NOT ZERO, INDIVIDUALLY CHECK THOSE FLAGS
	ADD	#16.,R3		;ELSE, PUSH UP THE FLAG NUMBER BY 16.
	BR	5$		;AND BRANCH
2$:	MOV	#16.,R5		;THERE ARE 16 FLAGS IN EACH GROUP
3$:	INC	R3		;INCREMENT THE ACTUAL FLAG NUMBER
	CMP	R3,#.MGFLG	;ARE WE UP TO THE MESSAGE FLAG?
	BGE	6$		;IF SO, CHECK NO FURTHER
	ROR	(R4)		;ROTATE LOW BIT OF FLAG GROUP INTO C-BIT
	BCC	4$		;IF C-BIT IS CLEAR, THAT FLAG IS CLEAR
 
;
; OTHERWISE, WE MUST CLEAR THE FLAG AND REPORT ITS NUMBER
;
 
	CLEF$S	R3,.RJCT
	MOV	#IS.SET,R1	;PUT EFN SET STATUS IN R1
	CALL	.STAT		;CHECK FOR PROPER RETURN STATUS
	CALL	.IDOUT		;SETUP STEP IDENTIFICATION
	MOV	R3,-(SP)	;PUT LOCAL FLAG NUMBER ON STACK
	MOV	SP,R2		;PUT STACK ADDR IN R2
	MOV	#.OBUF,R0	;PUT ADDR OF OUTPUT BUFFER IN R0
	MOV	#LEM01,R1	;PUT ADDR OF 'LOCAL FLAG' FORMAT IN R1
	CALL	.PRTMG		;CREATE OUTPUT OF LOCAL FLAG NUMBER & PRINT
	TST	(SP)+		;POP THE STACK
4$:	SOB	R5,3$		;DECR THE COUNTER AND REPEAT UNTIL ZERO
	CLR	(R4)		;NOW CLEAR THE WORD HAVING SET FLAGS
5$:	TST	(R4)+		;INCR R4 TO ADDR OF NEXT GROUP OF FLAGS
	CMP	#EVFLGS+4,R4	;CMP R4 TO ADDR OF FIRST GROUP OF GLOBAL FLAGS
	BNE	1$		;AND REPEAT TEST LOOP IF NOT THE SAME
6$:
;+
;
; TESTS WILL NOW BE PERFORMED ON ONE LOCAL FLAG (16) AND ONE GLOBAL FLAG (34).
;
; THE FOLLOWING STEP SETS EVENT FLAGS #16 & #34.  IN ADDITION, A CHECK IS 
; MADE OF THE POLARITY RETURN OF FLAG #16, BECAUSE IT SHOULD HAVE
; BEEN CLEAR.
;
;-
	$$STEP
	$SETUP	SETF,#16.,IS.CLR
	SETF$S	#34.,.RJCT	;CLEAR FLAG #34.
;+
;
; THIS NEXT STEP READS THE POLARITY OF THE TWO FLAGS JUST SET.  IN ADDITION,
; THE READS ARE PERFORMED INDIVIDUALLY AND POLARITY ERRORS ARE REPORTED.
;
;-
	$$STEP
	$SETUP	RDEF,#16.,IS.SET
	$SETUP	RDEF,#34.,IS.SET
;+
;
; ALL OF THE EVENT FLAGS ARE READ AGAIN USING THE "READ ALL EVENT FLAGS"
; DIRECTIVE.  ONLY THE TWO FLAGS (16 AND 34) WILL BE CHECKED TO INSURE THAT
; THEY ARE MARKED AS BEING SET.
;
;-
	$$STEP
	DIR$	#RAFDPB,.RJCT	;READ ALL EVENT FLAGS
	CALL	.SUCC		;CHECK FOR SUCCESSFUL RETURN STATUS
 
;
; CHECK THE TWO FLAGS AND USE ROUTINE 'POLERR' TO REPORT ERRORS
;
 
	TST	EVFLGS		;TEST FLAG #16
	BMI	1$		;AND BRANCH IF IT'S SET
	MOV	#16.,R1		;ELSE, PUT FLAG NUMBER (16) IN R1,
	MOV	#IS.SET,R0	;EXPECTED STATUS IN R0,
	MOV	#IS.CLR,@#$DSW	;RETURNED STATUS IN DSW,
	CALL	POLERR		;AND REPORT THE ERROR
1$:	BIT	#2,EVFLGS+4	;TEST FLAG #34
	BNE	2$		;AND BRANCH IF IT'S SET
	MOV	#34.,R1		;ELSE, PUT FLAG NUMBER (34) IN R1,
	MOV	#IS.SET,R0	;EXPECTED STATUS IN R0,
	MOV	#IS.SET,@#$DSW	;RETURNED STATUS IN DSW,
	CALL	POLERR		;AND REPORT THE ERROR
2$:
;+
;
; NOW THE TWO FLAGS ARE INDIVIDUALLY CLEARED.  IN ADDITION, ANOTHER CHECK
; IS PERFORMED TO INSURE THAT POLARITY RETURNS ARE WORKING CORRECTLY.
;
;-
	$$STEP
	$SETUP	CLEF,#16.,IS.SET
	$SETUP	CLEF,#34.,IS.SET
;+
;
; THE TWO FLAGS ARE READ AGAIN.  THEY SHOULD REPORT POLARITY CLEAR.
;
;-
	$$STEP
	$SETUP	RDEF,#16.,IS.CLR
	$SETUP	RDEF,#34.,IS.CLR
;+
;
; A TEST WILL BE MADE TO INSURE THAT AN ATTEMPT TO CLEAR EVENT FLAGS
; THAT ARE ALREADY CLEAR WILL WORK PROPERLY.
;
;-
	$$STEP
	$SETUP	CLEF,#16.,IS.CLR
	$SETUP	CLEF,#34.,IS.CLR
;+
;
; TO CONTINUE TESTING, THE TWO EVENT FLAGS INVOLVED WILL BOTH BE SET.
;
;-
	$$STEP
	$SETUP	SETF,#16.,IS.CLR
	$SETUP	SETF,#34.,IS.CLR
;+
;
; A TEST WILL BE MADE TO INSURE THAT AN ATTEMPT TO SET EVENT FLAGS
; THAT ARE ALREADY SET WILL WORK PROPERLY.
;
;-
	$$STEP
	$SETUP	SETF,#16.,IS.SET
	$SETUP	SETF,#34.,IS.SET
;+
;
; LATER TESTING REQUIRES THAT THE TWO FLAGS SHOULD NOW
; BE CLEARED.
;
;-
	$$STEP
	$SETUP	CLEF,#16.,IS.SET
	$SETUP	CLEF,#34.,IS.SET
;+
;
; TO PROPERLY CONTINUE TESTING OF INDIVIDUAL EVENT FLAGS AND THE ASSOCIATED
; SYSTEM DIRECTIVES, IT WILL BE NECESSARY TO HAVE ANOTHER TASK IN COOPERATIVE
; EXECUTION.  THAT TASK MUST ALREADY BE INSTALLED IN THE SYSTEM.  HOWEVER,
; ITS EXECUTION CAN BE STARTED VIA THE SYSTEM DIRECTIVE "REQUEST".  THE
; TWO TASKS WILL COMMUNICATE VIA GLOBAL EVENT FLAGS #34., #35., AND
; #36..  HOWEVER, TO INSURE PROPER INITIAL COMMUNICATION, THESE FLAGS
; MUST FIRST BE CLEARED.
;
; NOW REQUEST THE EXECUTION OF THE COOPERATIVE TASK.  IT SHOULD HAVE BEEN
; GIVEN A LOWER THAN DEFAULT PRIORITY.  THEREFORE, UNTIL BLOCKED, THE
; CURRENT TASK WILL BE GIVEN EXECUTION.
;
;-
	$$STEP
;*****
	JMP	STP23
;*****
	CLEF$S	#35.,.RJCT	;CLEAR FLAG #35.
	CLEF$S	#36.,.RJCT	;CLEAR FLAG #36.
	DIR$	#RQDPB,.RJCT	;INVOKE TASK 'TST02B'
	CALL	.SUCC		;CHECK PROPER SUCCESS STATUS RETURNED
 
;
; NOW CHECK EVENT FLAG #34.  IF IT'S SET A SCHEDULING ERROR OCCURRED.
;
 
	$SETUP	RDEF,#34.,IS.CLR
;+
;
; NOW ISSUE ANOTHER "REQUEST" FOR 'TST02B'.  IT SHOULD NATURALLY FAIL, BECAUSE
; IT IS ALREADY ACTIVE.
;
;-
	$$STEP
;	DIR$	#RQDPB		;INVOKE REQUEST
;	MOV	#IE.ACT,R1	;PUT EXPECTED ERROR STATUS IN R1
;	CALL	.FAIL		;CHECK PROPER FAILURE RETURN STATUS
;+
;
; 'TST02B' SHOULD NOW BE ACTIVATED.  ITS EXECUTION, HOWEVER, HAS NOT YET
; STARTED.  THIS STEP WILL ISSUE A "WAITFOR LOGICAL 'OR' OF FLAGS" #34,
; #35, OR #36.  IT WILL BLOCK THIS TASK'S EXECUTION, PERMITTING THE
; OTHER TO COMMENCE.  ONCE THE WAIT IS COMPLETE, ALL THREE EVENT
; FLAGS SHOULD HAVE BEEN SET BY THE OTHER TEST TASK.
;
;-
	$$STEP
	WTLO$C	2,16,TST02A,.RJCT
	CALL	.SUCC		;CHECK PROPER SUCCESS STATUS RETURNED
 
;
; NOW CHECK THE THREE FLAGS.  THEY SHOULD ALL BE SET.
;
 
	MOV	#34.,R3		;R3 WILL HOLD THE EVENT FLAG NUMBER
	MOV	#3.,R4		;R4 WILL BE THE COUNTER
1$:	$SETUP	RDEF,R3,IS.SET
	INC	R3		;INCREMENT THE FLAG NUMBER
	SOB	R4,1$		;DECR COUNTER & REPEAT UNTIL ZERO
;+
;
; EVENT FLAG # 34 IS NO LONGER INVOLVED IN TESTING -- IT WILL BE CLEARED.
; THEN ISSUE A "WAIT" FOR EVENT FLAG #35.  SINCE IT IS STILL SET, THIS TASK
; SHOULD CONTINUE ITS EXECUTION.  TO PROVE IT, FLAG #36 IS READ AND CHECKED.
; SINCE THE OTHER TASK ('TST02B') HAS NOT BEEN ALLOWED TO PROCEED, THE FLAG
; SHOULD STILL BE SET.
;
;-
	$$STEP
	CLEF$S	#34.,.RJCT	;CLEAR FLAG 34
	MOV	#IS.SET,R1	;PUT EFN SET STATUS IS R1
	CALL	.STAT		;CHECK FOR PROPER RETURN STATUS
	DIR$	#WT35,.RJCT	;WAIT FOR FLAG 35
	CALL	.SUCC		;CHECK PROPER SUCCESS STATUS RETURNED
	$SETUP	RDEF,#36.,IS.SET
;+
;
; THE "WAIT" WILL BE ISSUED AGAIN AFTER FLAG #35 IS CLEARED.
; THIS WILL ALLOW THE OTHER TASK TO CONTINUE.
;
;-
	$$STEP
	DIR$	#CL35,.RJCT	;CLEAR FLAG 35
	DIR$	#WT35,.RJCT	;WAIT FOR FLAG 35
	CALL	.SUCC		;CHECK PROPER SUCCESS STATUS RETURNED
;+
;
; EXECUTION HAS JUST RETURNED TO THIS TASK.  TO INSURE THAT THINGS WORKED
; PROPERLY, CHECK THAT FLAG #36 IS CLEAR.  THEN CLEAR FLAG #35.
;
;-
	$$STEP
	$SETUP	RDEF,#36.,IS.CLR
	DIR$	#CL35,.RJCT	;CLEAR FLAG 35
	MOV	#IS.SET,R1	;PUT EFN SET STATUS IN R1
	CALL	.STAT		;CHECK FOR PROPER RETURN STATUS
;+
;
; NOW IT IS TIME TO TRY TO CONFUSE THINGS BY ISSUING DIRECTIVES WITH
; ERRORS.
;
; FIRST, TEST "REQUEST"  BY ASKING FOR THE EXECUTION OF A TASK THAT
; DOES NOT EXIST WITHIN THE SYSTEM.
;
;-
	$$STEP
	MOV	TST02Z,RQDPB+R.QSTN+2 ;PUT PHONY NAME IN DPB
	DIR$	#RQDPB		;AND INVOKE REQUEST
	MOV	#IE.INS,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK PROPER FAILURE RETURN STATUS
;+
;
; NOW WE TRY TO REQUEST THE EXECUTION OF THIS TASK.  NATURALLY, THIS ONE SHOULD
; NOT BE HONORED.
;
;-
	$$STEP
	MOV	TST02A,RQDPB+R.QSTN+2 ;PUT THIS TASK NAME IN DPB
	DIR$	#RQDPB		;AND INVOKE REQUEST
	MOV	#IE.ACT,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK PROPER FAILURE RETURN STATUS
;+
;
; NOW REQUEST THE EXECUTION OF A TASK WITH A NULL NAME.
;
;-
	$$STEP
	CLR	RQDPB+R.QSTN	;CLEAR BOTH WORDS OF
	CLR	RQDPB+R.QSTN+2	;THE TASK NAME IN DPB
	DIR$	#RQDPB		;AND INVOKE REQUEST
	MOV	#IE.INS,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK PROPER FAILURE RETURN STATUS
 
;
; RESTORE THE PROPER TASK NAME INTO THE DPB
;
 
	MOV	TST02B,RQDPB+R.QSTN ;PUT 'TST02B' IN THE TASK NAME
	MOV	TST02B+2,RQDPB+R.QSTN+2 ;IN THE DPB
;+
;
; TESTING OF THE "REQUEST" DIRECTIVE IS NOW COMPLETE.  THE EVENT FLAG
; DIRECTIVES WILL BE DEALT WITH.
;
; TRY TO CLEAR, SET, AND WAIT FOR WITH A NEGATIVE EVENT FLAG NUMBER.
;
;-
	$$STEP
	CLEF$S	#-1
	MOV	#IE.IEF,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK PROPER FAILURE RETURN STATUS
 
	SETF$S	#-1
	CALL	.FAIL		;CHECK PROPER FAILURE RETURN STATUS
 
	WTSE$S	#-1
	CALL	.FAIL		;CHECK PROPER FAILURE RETURN STATUS
 
;+
;
; TRY TO SET, CLEAR, AND WAIT FOR EVENT FLAG ZERO.
;
;-
	$$STEP
	SETF$S
	CALL	.FAIL		;CHECK PROPER FAILURE RETURN STATUS
 
	CLEF$S
	CALL	.FAIL		;CHECK PROPER FAILURE RETURN STATUS
 
	WTSE$S
	CALL	.FAIL		;CHECK PROPER FAILURE RETURN STATUS
;+
;
; TRY TO CLEAR, SET, AND WAIT FOR EVENT FLAG NUMBER 65. .
;
;-
	$$STEP
	CLEF$S	#65.
	CALL	.FAIL		;CHECK PROPER FAILURE RETURN STATUS
 
	SETF$S	#65.
	CALL	.FAIL		;CHECK PROPER FAILURE RETURN STATUS
 
	WTSE$S	#65.
	CALL	.FAIL		;CHECK PROPER FAILURE RETURN STATUS
 
;+
;
; TRY TO "WAITFOR LOGICAL 'OR' OF FLAGS" IN AN INVALID SET.
;
;-
	$$STEP
	WTLO$S	-1,PC
	CALL	.FAIL		;CHECK PROPER FAILURE RETURN STATUS
;+
;
; ATTEMPT TO "WAITFOR LOGICAL 'OR' OF FLAGS" WITH NONE SPECIFIED
;
;-
	$$STEP
	WTLO$S	0,#0
	CALL	.FAIL		;CHECK PROPER FAILURE RETURN STATUS
;+
;
; ATTEMPT TO INVOKE THE "READ ALL EVENT FLAGS" DIRECTIVE WITH A
; BUFFER SPECIFIED OUT OF THE SEGMENT.
;
;-
	$$STEP
	CALL	$ADCHK		;IS ADDRESS CHECKING SUPPORTED?
	BCS	SKPACK		;SKIP IF NOT
	RDAF$S	#160000		;ELSE, RDAF$ WITH BAD BUFFER ADDRESS
	MOV	#IE.ADP,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK PROPER FAILURE RETURN STATUS
;+
;
; THE "READ ALL EVENT FLAGS" DIRECTIVE IS NOW ISSUED WITH A BUFFER
; ON AN ODD ADDRESS.
;
;-
	$$STEP
	RDAF$S	#EVFLGS+1
	CALL	.FAIL		;CHECK PROPER FAILURE RETURN STATUS
 
SKPACK:				;BRANCH TO HERE IF NO ADDRESS CHECKING
 
;+
;
; THE "CLEAR EVENT FLAG", "DECLARE SIGNIFICANT EVENT", "READ ALL
; EVENT FLAGS",  "SET EVENT FLAG", "REQUEST", "WAIT FOR LOGICAL
; 'OR' OF EVENT FLAGS", AND "WAIT FOR SINGLE EVENT FLAG"
; DIRECTIVES ARE INVOKED WITH INVALID DPB SIZES.
;
;-
	$$STEP
 
 
	.PSECT	$DPB$$
 
	.ENABL	LSB
 
10$:	.BYTE	11.,8.		;INVALID "REQUEST" DPB
 
20$:	.BYTE	31.,0		;INVALID "CLEAR EVENT FLAG" DPB
 
30$:	.BYTE	35.,0		;INVALID "DECL SIGNIFICANT EVENT" DPB
 
40$:	.BYTE	39.,10.		;INVALID "READ ALL EVENT FLAGS" DPB
 
50$:	.BYTE	33.,0		;INVALID "SET EVENT FLAGS" DPB
 
60$:	.BYTE	41.,0		;INVALID "WAIT FOR SINGLE EVENT FLAG" DPB
 
70$:	.BYTE	43.,1		;INVALID "WAIT FOR LOGICAL 'OR' OF FLAGS" DPB
 
 
	.PSECT	TST02A
 
	DIR$	#10$		;INVOKE INVALID DPB
	MOV	#IE.SDP,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK PROPER FAILURE RETURN STATUS
 
	DIR$	#20$		;INVOKE INVALID DPB
;	MOV	#IE.ADP,R1	;SET EXPECTED ERROR STATUS
	CALL	.FAIL		;CHECK PROPER FAILURE RETURN STATUS
 
	DIR$	#30$		;INVOKE INVALID DPB
	CALL	.FAIL		;CHECK PROPER FAILURE RETURN STATUS
 
	DIR$	#40$		;INVOKE INVALID DPB
	MOV	#IE.SDP,R1	;SET EXPECTED ERROR STATUS
	CALL	.FAIL		;CHECK PROPER FAILURE RETURN STATUS
 
	DIR$	#50$		;INVOKE INVALID DPB
;	MOV	#IE.ADP,R1	;SET EXPECTED ERROR STATUS
	CALL	.FAIL		;CHECK PROPER FAILURE RETURN STATUS
 
	DIR$	#60$		;INVOKE INVALID DPB
	CALL	.FAIL		;CHECK PROPER FAILURE RETURN STATUS
 
	DIR$	#70$		;INVOKE INVALID DPB
	MOV	#IE.SDP,R1	;SET EXPECTED ERROR STATUS
	CALL	.FAIL		;CHECK PROPER FAILURE RETURN STATUS
 
	.DSABL	LSB
 
;+
;
; THIS IS THE END OF TEST02.  A MESSAGE WILL BE SENT TO TI: INDICATING THIS.
; THEN THE "EXIT" DIRECTIVE WILL BE ISSUED.
;
;-
	$$STEP
	CALL	.ETST		;PRINT END OF TEST MESSAGE
	EXIT$S	.RJCT
	.PAGE
;
;
; THIS SUBROUTINE IS USED TO REPORT ERRORS IN POLARITY RETURNS.  A MESSAGE
; IS SENT TO TT0 GIVING THE OFFENDING FLAG NUMBER, THE EXPECTED POLARITY, AND
; THE ACTUAL RETURNED POLARITY.  THE FLAG NUMBER IS IN R1, AND THE EXPECTED
; POLARITY IS IN R0.
;
;
POLERR:	MOV	R2,-(SP)	;SAVE R2
	MOV	@#$DSW,-(SP)	;PUT RETURNED POLARITY IN THE STACK
	MOV	R0,-(SP)	;PUT EXPECTED POLARITY IN THE STACK
	MOV	R1,-(SP)	;PUT EVENT FLAG NUMBER IN THE STACK
	CALL	.IDOUT		;CREATE OUTPUT OF STEP IDENTIFICATION
	MOV	#LEM02,R1	;PUT ADDR OF 'POLARITY' FORMAT IN R1
	MOV	SP,R2		;PUT ADDR OF ARG LIST IN R2
	CALL	.PRTMG		;CREATE OUTPUT OF ERROR INFO & PRINT
	MOV	(SP)+,R1	;RESTORE THE SAVED INFO
	MOV	(SP)+,R0	;
	MOV	(SP)+,@#$DSW	;
	MOV	(SP)+,R2	;
	RETURN			;NOW RETURN
 
 
;
;
; THIS SUBROUTINE IS USED TO SIMULATE THE ACTION OF THE RSX-11D READ
; SINGLE EVENT FLAG DIRECTIVE.
;
;
RDEF$:	DEC	R0		;DECREMENT THE EVENT FLAG NUMBER
	MOV	R0,-(SP)	;COPY IT INTO THE STACK
	BIC	#17,(SP)	;DELETE EFN LOW ORDER BITS
	ASR	(SP)		;CALCULATE THE OFFSET IN THE ...
	ASR	(SP)		;... READ ALL FLAGS BUFFER OF ...
	ASR	(SP)		;... WORD WITH DESIRED FLAG BIT
	ADD	#$RDFBF,(SP)	;CALC THE WORD'S ADDRESS
	BIC	#177760,R0	;DELETE EFN HIGH ORDER BITS
	CLR	-(SP)		;CLEAR TEMP WORK WORD
	SEC			;AND SET C-BIT
10$:	ROL	(SP)		;MOVE BIT ACROSS WORD UNTIL ...
	DEC	R0		;... DESIRED BIT POSITION IS ...
	BGE	10$		;... REACHED
	MOV	#IS.SET,@#$DSW	;ASSUME FLAG WAS SET
	BIT	(SP)+,@(SP)+	;EXAMINE THE FLAG BIT
	BNE	20$		;SKIP IF ASSUMPTION WAS CORRECT
	MOV	#IS.CLR,@#$DSW	;ELSE, INDICATE FLAG WAS CLEAR
20$:	CLC			;INSURE THAT C-BIT IS CLEAR
	RETURN			;RETURN WITH RESULT IN DSW
 
 
 
; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
 
	.END	STP0
