	.NLIST

	.IDENT 'V03-000'
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; MODIFIED BY:
;
;	V03-002 RNP0001		Robert N. Perron,		15-Aug-1981
;		Changed severity code in beginning and ending messages from
;		information to success to conform to Test Control program.
;
;	V03-001 RNH0001		Richard N. Holstein,		16-Jun-1981
;		Modified all references to RTL routines to have G^ address
;		specification for the new linker.
;
;**
;
; This MACRO is being included at the beginning of all RMS test programs
; since it is a private MACRO and not in any system libraries
;

.MACRO	$BEGIN MODNAM,IDNUM,PSNAME,TITL,PSATR=NOWRT
	.TITLE	MODNAM TITL	;
	.IDENT	/IDNUM/
	.MACRO	$DPSECT
	.PSECT	PSNAME,GBL,PSATR
	.ENDM
	$DPSECT
	$$.PSECT_EP=0
	$$RMSTEST=30				; get test point increment,
						;  USER MODE PRIV, RMSBUG,
						;  and optional debug code
	$$RMS_UMODE=4
	$$RMS_TBUGCHK=8
	$$RMS_PBUGCHK=16
	.DSABL	DBG
.ENDM	$BEGIN

;
;  The $BEGIN MACRO defines the following switches for RMS assembly
;	(bits in $$RMSTEST):
;
;	BIT 0			include TSTPT GLOBAL SYMBOLS
;	BIT 1			include TSTPT COUNTER INCREMENT
;	BIT 2	($$RMS_UMODE)	assemble code for USER MODE
;	BIT 3	($$RMS_TBUGCHK)	include optional DEBUGGING CODE
;	BIT 4	($$RMS_PBUGCHK)	include "SEMI-PERMANENT" DEBUGGING CODE
;
;

	.LIST
	$BEGIN	RMSTEST,028,__RMSTEST,<USER ROUTINE TO CALL AND TEST RMS>,<LONG,GBL>
	.ENABL	DBG

;
.NLIST	MEB
;
;  MACROS:
;

	.MACRO	BUFF NAM,SIZE
NAM'BUF::
	.BLKB	SIZE
	NAM'BSZ==SIZE
	.ENDM	BUFF

;

	.MACRO	PROMPT STRING,NULL,?L
	STORE	<STRING>,<.BYTE 13,10>
	MOVL	#$$.TMPX,CMDIRAB+RAB$L_PBF
	MOVB	#$$.TMPX1,CMDIRAB+RAB$B_PSZ
	$GET	RAB=CMDIRAB
	BLBS	R0,L
	BSBW	EOFDET
L:
	.IF	NB NULL
	TSTW	CMDIRAB+RAB$W_RSZ
	BEQL	NULL
	.ENDC
	.ENDM	PROMPT

;
;

	.MACRO	TYPE STRING,?L
	STORE	<STRING>
	BLBC	VERBOSITY,L
	MOVL	#$$.TMPX,CMDORAB+RAB$L_RBF
	MOVW	#$$.TMPX1,CMDORAB+RAB$W_RSZ
	$PUT	RAB=CMDORAB,ERR=REPORT_ERROR
	BSBW	ERR
L:
	.ENDM	TYPE

;

	.MACRO	STORE STRING,PRE
	.SAVE
	.PSECT	__$RMSNAM
	$$.TMPX=.
	PRE						; store any carriage
	.ASCII	%STRING%				;  control info
	$$.TMPX1=.-$$.TMPX
	.RESTORE
	.ENDM	STORE

	.MACRO	BEGIN TSTNAM
	STORE	<TSTNAM>
	MOVL	#$$.TMPX,BEG_DESCR+4			; addr
	MOVL	#$$.TMPX1,BEG_DESCR			; len
	BSBW	BEGPUT
	.ENDM	BEGIN
	.MACRO	FINISH TSTNAM
	STORE	<TSTNAM>
	MOVL	#$$.TMPX,FIN_DESCR+4			; addr
	MOVL	#$$.TMPX1,FIN_DESCR			; len
	BSBW	FINPUT
	.ENDM	FINISH
	.MACRO	FIELD FLDNAM
	STORE	<FLDNAM>
	MOVL	#$$.TMPX,FLD_DESCR+4			; addr
	MOVL	#$$.TMPX1,FLD_DESCR			; len
	BSBW	FLDPUT
	.ENDM	FIELD
	.MACRO	MBPT ?L					; BPT, maybe?
	BLBC	VERBOSITY,L
	BPT
L:
	.ENDM	MBPT

	.MACRO	SFNM STRING
	STORE	<STRING>
	MOVB	#$$.TMPX1,STICKY_FAB2+FAB$B_FNS
	MOVL	#$$.TMPX,STICKY_FAB2+FAB$L_FNA
	.ENDM	SFNM

	.MACRO	ALWAYS STRING
	STORE	<STRING>
	MOVL	#$$.TMPX,CMDORAB+RAB$L_RBF
	MOVW	#$$.TMPX1,CMDORAB+RAB$W_RSZ
	$PUT	RAB=CMDORAB,ERR=REPORT_ERROR
	BSBW	ERR
	.ENDM	ALWAYS

	RBRACK=93
	SEMI=59

	.PSECT	__RMSTEST,GBL,LONG

;

RELZERO:
.IF	DF RMSDEBUG
CMDIFAB::
	$FAB	FAC=<GET>,FNM=TST$INPUT:,MRS=132,RAT=CR
CMDOFAB::
	$FAB	FAC=PUT,FNM=TST$OUTPUT:,MRS=132,RAT=CR,RFM=VAR
.IFF
CMDIFAB::
	$FAB	FAC=<GET>,FNM=SYS$INPUT:,MRS=132,RAT=CR
CMDOFAB::
	$FAB	FAC=PUT,FNM=SYS$OUTPUT:,MRS=132,RAT=CR,RFM=VAR
.ENDC
CMDIRAB::
	$RAB	UBF=CMDBUF,USZ=CMDBSZ,FAB=CMDIFAB,ROP=PMT
CMDORAB::
	$RAB	UBF=CMDBUF,USZ=CMDBSZ,FAB=CMDOFAB

;

INFAB::	$FAB	FAC=GET,FNA=PNSBUF,DNA=DNSBUF,NAM=NAMBLK
INRAB::	$RAB	UBF=CPYBUF,USZ=CPYBSZ,FAB=INFAB,RHB=RHBBUF,-
		MBC=4,MBF=-2
OUTFAB::
	$FAB	FAC=PUT,FNA=PNSBUF,DNA=DNSBUF,NAM=NAMBLK
OUTRAB::
	$RAB	UBF=CPYBUF,USZ=CPYBSZ,RBF=CPYBUF,FAB=OUTFAB,ROP=EOF,-
		RHB=RHBBUF,MBC=8,MBF=1
NAMBLK::
	$NAM	ESA=CMDBUF,ESS=CMDBSZ,RSA=RESBUF,RSS=RESBSZ
WCDNAM::
	$NAM	ESA=WCDBUF,ESS=WCDBSZ,RSA=RWCBUF,RSS=RWCBSZ

;

STICKY_FAB2:
	$FAB	NAM=STICKY_NAMBLK,FOP=<OFP,CBT,SUP>,-
		ALQ=4,FAC=PUT,DNM=<TST$DISK:>
STICKY_NAMBLK:
	$NAM	RLF=RELATED_NAM,RSA=RESBUF,RSS=RESBSZ,ESA=EXPBUF,ESS=EXPBSZ
RELATED_NAM:
	$NAM	RSA=REL_FILE			; must set RSL at RUN-TIME
REL_FILE:
	.ASCII	/TS.DAT/
	REL_FILE_SIZE=.-REL_FILE
	.ALIGN	WORD
SAVE_FID:
	.BLKB	6				; to save FID
	.ALIGN	LONG
OLDFAB::
	$FAB	FNM=<TS.DAT>,DNM=<TST$DISK:>,NAM=OLDNAM
NEWFAB::
	$FAB	FNM=<TST$DISK:RENAMED.TST;32>,nam=newnam
OLDNAM::
	$NAM	ESA=OLD_ESBUF,ESS=NAM$C_MAXRSS,-
		RSA=OLD_RSBUF,RSS=NAM$C_MAXRSS
NEWNAM::
	$NAM	ESA=NEW_ESBUF,ESS=NAM$C_MAXRSS,-
		RSA=NEW_RSBUF,RSS=NAM$C_MAXRSS
OLD_ESBUF:
	.BLKB	NAM$C_MAXRSS
OLD_RSBUF:
	.BLKB	NAM$C_MAXRSS
NEW_ESBUF:
	.BLKB	NAM$C_MAXRSS
NEW_RSBUF:
	.BLKB	NAM$C_MAXRSS
	.ALIGN	LONG

;

	BUFF	WCD,80
	BUFF	RWC,80
	BUFF	EXP,64
	BUFF	RES,64
RHBBUF::
	.BLKB	16
DIRLEN:	.LONG	0
DIRBUF:	.BLKB	40
DIRDESC:
	.LONG	40
	.LONG	DIRBUF
ECHOBF:	.ASCII	/RMSTEST:/			; must immediately precede
	BUFF	CMD,132				;  CMDBUF
PNSBUF::
	.BLKB	80
	BUFF	DNS,80
	BUFF	CPY,512
	.BLKW	4
DNSSIZ:	.WORD	0				; size of DEFAULT NAME STRING
NAM::	.LONG	0				; addr of NAMBLK for TST$SHOWNAM
CPYFLG:	.BYTE	0				; zero for COPY, 1 for APPEND
WCFLG:	.BYTE	0				; 1 if wild card spec
ORGFLG:	.BYTE	0				; 1 if choice of org
VSW:	.BYTE	-1				; verify switch
CMD:	.BYTE	0				; character of current command
	.ALIGN	LONG
CPYBUFDSC:
	.LONG	CPYBSZ,CPYBUF


;
;  FAO data
;

FAOSTR:	.LONG	FSTR1LEN,FSTR1
FAOBUF::
	.LONG	CMDBSZ,CMDBUF
FSTR1:	.ASCII	'RMS OPERATION ERROR!/   RMSTEST REL. PC = !XL'
	.ASCII	'  ABS. PC. = !XL!/'
FSTR1LEN=.-FSTR1
RDMSG:	.ASCII	'RUN DOWN FAILURE - CONTINUING'
	RDMSGLEN=.-RDMSG

;
;  Descriptors for ASCII inserts into messages
;

	.ALIGN	LONG
BEG_DESCR::
	.LONG	0,0
FIN_DESCR::
	.LONG	0,0
FLD_DESCR::
	.LONG	0,0
KRF_DESC:
	.LONG	0,0				; KEY OF REFERENCE desc
INTEGER:
	.LONG	0				; return from int. input conv
ILLSERDEC:
	.LONG	ILLSERL,ILLSER
EOF_DSC:
	.LONG	EXPEOF_LEN,EXPEOF
EXPEOF:	.ASCII	/EOF/
EXPEOF_LEN=.-EXPEOF

;

ILLSER:	.ASCII	/illegal/
ILLSERL=.-ILLSER


;
;  Setups
;

START::	.WORD	0
	$OPEN	FAB=CMDIFAB
	BLBC	R0,.				; trap on error
	$CONNECT	RAB=CMDIRAB
	BLBC	R0,.				; trap on error
	$OPEN	FAB=CMDOFAB
	BLBC	R0,.				; trap on error
	$CONNECT	RAB=CMDORAB
	BLBC	R0,.				; trap on error
	MOVAL	NAMBLK,NAM			; in case of error
	BSBW	TRAN				; set up verbosity flag

;
;  Get a command and execute it
;

CMD_LOOP:
	CLRB	ORGFLG
	BICL2	#RAB$M_ASY,CMDORAB+RAB$L_ROP	; insure cmd output sync.
	PROMPT	RMSTEST:,NULL=BR_COPY		; get command
ECHOIT:	BSBW	ECHO				; echo cmd line if non-interactive
	MOVB	CMDBUF,R0			; pick up input character
	CMPB	R0,#^A/!/			; comment?
	BEQL	CMD_LOOP			; branch if yes
	CMPW	CMDIRAB+RAB$W_RSZ,#1		; single byte input?
	BNEQ	QMARK
	MOVB	R0,CMD				; store cmd for possible action
	CLRL	FAB$L_FOP+OUTFAB		; turn off any stale options

;
; Decide where to go
;

	CASE	TYPE=B,SRC=R0,LIMIT=#^A/A/,-
	DISPLIST=<TST$APPEND,TST$BLOCK,TST$COPY,TST$DEBUG,QMARK,TST$F,-
	TST$GENERAL,HELP,TST$SHR,QMARK,TST$STICKY,TST$RELATIVE,-
	TST$MTAPE,TST$NET,TST$ORG,TST$PRINT,QMARK,TST$RUNDWN,TST$SETDFLT,-
	QMARK,TST$SETDDIR,SETVSW,QMARK,TST$INDEX,QMARK,QMARK>

QMARK:	ALWAYS	<?>				; type always

CMD_LOOP_BR:
	BRW	CMD_LOOP

BR_COPY:
	MOVB	#^A/C/,CMDBUF			; default to 'C' command
	INCW	CMDIRAB+RAB$W_RSZ		; say 1 char input
	BRW	ECHOIT				; go process

;

SETVSW:
	BLBC	VERBOSITY,QMARK
	MNEGB	VSW,VSW				; toggle the verify switch
	BRB	CMD_LOOP_BR


;
;  COPY routine  -  copy input file to output file
;

TST$COPY:
	CLRB	WCFLG
	CLRB	CPYFLG
	MOVAL	NAMBLK,NAM
COPY_PROMPT:
	MOVB	#^A/C/,CMD			; no matter how we got here
						;  (A,O,C,NULL)
						;  signal this is a COPY
PROMPT	<INPUT FILE:>,NULL=CMD_LOOP_BR
	MOVC3	CMDIRAB+RAB$W_RSZ,CMDBUF,PNSBUF	; save PRIMARY NAME STRING
	MOVW	CMDIRAB+RAB$W_RSZ,-		; and its length
		INFAB+FAB$B_FNS
	MOVB	DNSSIZ,INFAB+FAB$B_DNS		; set DEFAULT STRING len
	MOVB	#FAB$M_CR,INFAB+FAB$B_RAT	; get implicit LF if TRM
	$PARSE	FAB=INFAB,ERR=REPORT_ERROR	; parse, checking for WC
	BSBW	ERR
	BBS	#NAM$V_WILDCARD,NAM$L_FNB+NAMBLK,WC
	BRW	NOWC
WC:
	MOVB	#1,WCFLG			; it is a wildcard spec
	MOVZBL	NAMBLK+NAM$B_ESL,R0
	MOVC3	R0,CMDBUF,WCDBUF		; save parsed string
						;  len must be a word, at least
	MOVC3	#NAM$C_BLN,NAMBLK,WCDNAM	; copy the whole NAMBLK
	$NAM_STORE	NAM=WCDNAM,-
			ESA=WCDBUF,-
			ESS=WCDBSZ,-
			RSA=RWCBUF,-
			ESS=RWCBUF
	MOVL	R0,INFAB+FAB$L_NAM		; use WC NAMBLK for now on
	MOVL	R0,NAM				; set up for TST$SHOWNAM
	$SEARCH	INFAB				; find 1st one
	CMPL	R0,#RMS$_FNF			; are there any?
	BNEQ	GOT_ONE				; guess so
	ALWAYS	<NO SUCH FILES>
	BRW	CLEAN				; clean up and start over
GOT_ONE:
	BLBS	R0,10$
	MOVAL	INFAB,R10
	BSBW	REPORT_ERR
	BSBW	ERR
10$:	BISL	#FAB$M_NAM,FAB$L_FOP+INFAB	; now can open by FID
NOWC:	$OPEN	FAB=INFAB
	BLBS	R0,5$				; branch on success
	MOVAL	INFAB,R10
	BSBW	REPORT_ERR
	BSBW	ERR
5$:	BSBW	TST$SHOWNAM
	CLRL	INTEGER				; init return
	BLBC	ORGFLG,CON			; skip if not org test
	BITB	#FAB$C_IDX,INFAB+FAB$B_ORG	; is input file index file?
	BEQL	CON				; eql no
PROMPT	<INPUT FILE KEY OF REFERENCE:>,NULL=CON
	MOVW	CMDIRAB+RAB$W_RSZ,KRF_DESC	; set up descriptor
	MOVAB	CMDBUF,KRF_DESC+4
	PUSHAB	INTEGER
	PUSHAB	KRF_DESC
	CALLS	#2,G^FOR$CNV_IN_I
	MOVB	INTEGER,INRAB+RAB$B_KRF
CON:
	$CONNECT	RAB=INRAB,ERR=REPORT_ERROR
	BSBW	ERR

;

PROMPT	<OUTPUT FILE:>,NULL=10$
	BRB	20$
10$:	BRW	CLSINF
20$:	MOVC3	CMDIRAB+RAB$W_RSZ,CMDBUF,PNSBUF
	MOVW	CMDIRAB+RAB$W_RSZ,OUTFAB+FAB$B_FNS
	MOVB	DNSSIZ,OUTFAB+FAB$B_DNS
	MOVB	INFAB+FAB$B_RAT,OUTFAB+FAB$B_RAT	; same record attributes
	MOVB	INFAB+FAB$B_RFM,OUTFAB+FAB$B_RFM

;
;  Create specific setups
;

	BLBC	ORGFLG,SAME_ORG			; if plain copy, then copy org
	PROMPT	<OUTPUT FILE ORG:>,-		; else ask for it,
		NULL=SEQ_ORG			;  default is SEQ
	MOVB	CMDBUF,R0
	CMPB	R0,#^A/R/
	BNEQ	SEQ_ORG				; if not 'R', then SEQ
	MOVB	#FAB$C_REL,OUTFAB+FAB$B_ORG	; make it RELATIVE
	BRB	GO
SAME_ORG:
	MOVB	INFAB+FAB$B_ORG,-		; copy org
		OUTFAB+FAB$B_ORG
	BRB	GO
SEQ_ORG:
	MOVB	#FAB$C_SEQ,OUTFAB+FAB$B_ORG	; make it SEQ
GO:
	BICL3	#FAB$M_NAM,INFAB+FAB$L_FOP,R0
	BISL2	R0,OUTFAB+FAB$L_FOP		; copy ctg bit
	MOVW	INFAB+FAB$W_MRS,OUTFAB+FAB$W_MRS
	MOVL	INFAB+FAB$L_MRN,OUTFAB+FAB$L_MRN
	MOVB	INFAB+FAB$B_FSZ,OUTFAB+FAB$B_FSZ
	MOVL	INFAB+FAB$L_ALQ,OUTFAB+FAB$L_ALQ
	CLRW	OUTFAB+FAB$W_BLS
	BLBS	CPYFLG,APPEND
	BEGIN	<COPY>
	$CREATE	FAB=OUTFAB,ERR=REPORT_ERROR
	BSBW	ERR
	CLRL	RAB$L_ROP+OUTRAB
	BRB	CPYNAM

;

APPEND:	BEGIN	<APPEND>
	BISL2	#FAB$M_CIF,FAB$L_FOP+OUTFAB
	$CREATE	FAB=OUTFAB,ERR=REPORT_ERROR
	BSBW	ERR
	MOVL	#RAB$M_EOF,RAB$L_ROP+OUTRAB	; connect to EOF
	BICL2	#FAB$M_CIF,FAB$L_FOP+OUTFAB
	CMPL	FAB$L_STS+OUTFAB,#RMS$_CREATED	; was file created?
	BNEQ	CPYNAM				; branch if not
	TYPE	<OUTPUT FILE CREATED!>
CPYNAM:	MOVAL	NAMBLK,NAM			; for TST$SHOWNAM
	BSBW	TST$SHOWNAM
	$CONNECT	RAB=OUTRAB,ERR=REPORT_ERROR
	BSBW	ERR

;

COPY_LOOP:
	$GET	INRAB
	CMPL	R0,#RMS$_EOF
	BEQL	COPY_DONE
	BLBS	R0,10$
	MOVAL	INRAB,R10
	BSBW	REPORT_ERR
	BSBW	ERR
10$:	MOVW	INRAB+RAB$W_RSZ,OUTRAB+RAB$W_RSZ
	$PUT	RAB=OUTRAB,ERR=REPORT_ERROR
	BSBW	ERR
	BRB	COPY_LOOP

;

COPY_DONE:
	TYPE	<END OF INPUT FILE>
	BLBC	WCFLG,DONE			; if no WC, then really done
	BSBW	CLS_IN_FL
	MOVAL	WCDNAM,NAM			; use WC NAMBLK for duration
	$SEARCH	INFAB				; look for next file
	CMPL	R0,#RMS$_NMF
	BEQL	NO_MORE_FILES
	BLBS	R0,10$
	MOVAL	INFAB,R10
	BSBW	REPORT_ERR
	BSBW	ERR
10$:	$OPEN	FAB=INFAB,ERR=REPORT_ERROR	; by FID, as set before
	BSBW	TST$SHOWNAM
	$CONNECT	RAB=INRAB,ERR=REPORT_ERROR
	BRW	COPY_LOOP
DONE:	BSBW	CLS_OUT_FL
CLSINF:	BSBW	CLS_IN_FL
	BSBW	REPORT_END
	BRW	CMD_LOOP

NO_MORE_FILES:
	TYPE	<NO MORE FILES>
	BSBW	CLS_OUT_FL			; CLOSE output file
	BSBW	REPORT_END
CLEAN:	BICL	#FAB$M_NAM,FAB$L_FOP+INFAB	; no more open by FID
	MOVAL	NAMBLK,INFAB+FAB$L_NAM		; can use ordinary NAMBLK again
	MOVAL	NAMBLK,NAM			; ditto
	BRW	CMD_LOOP

;
;
;  APPEND command
;

TST$APPEND:
	MOVB	#1,CPYFLG
	CLRB	WCFLG
	MOVAL	NAMBLK,NAM
	BRW	COPY_PROMPT
TST$ORG:
						; choice of org for output
	MOVB	#1,ORGFLG
	BRW	TST$COPY
CLS_IN_FL:
						; routine to CLOSE input file
	$DISCONNECT	RAB=INRAB,-
			ERR=REPORT_ERROR
	BSBW	ERR
	$CLOSE	FAB=INFAB,ERR=REPORT_ERROR
	BSBW	ERR
	RSB

CLS_OUT_FL:
	$DISCONNECT	RAB=OUTRAB,ERR=REPORT_ERROR
	BSBW	ERR
	$CLOSE	FAB=OUTFAB,ERR=REPORT_ERROR
	BSBW	ERR
	RSB

REPORT_END:
	BLBC	CPYFLG,CPYEND			; branch if doing copy
	FINISH	<APPEND>
	RSB
CPYEND:	FINISH	<COPY>
	RSB

TST$DEBUG:
	BLBS	VERBOSITY,10$
	BRW	QMARK
10$:	TYPE	<RMS DEBUG>
	BPT
	BRW	CMD_LOOP			; more code to go here

;
;
;  Set up DEFAULT NAME STRING
;

TST$SETDFLT:
PROMPT	<DEFAULT FILENAME STRING:>
	MOVB	CMDIRAB+RAB$W_RSZ,DNSSIZ
	MOVC3	DNSSIZ,CMDBUF,DNSBUF
	BRW	CMD_LOOP

;

CLOSE_UP:
	ALWAYS	[EOF]
	$DISCONNECT	CMDIRAB
	$CLOSE	CMDIFAB
	$CLOSE	CMDOFAB
	$EXIT_S

;
; Subroutine to detect EOF (^Z) and errors after prompt
;

EOFDET:
	CMPL	R0,#RMS$_EOF			; is it EOF?
	BEQL	CLOSE_UP			; must be
	MOVAL	CMDIRAB,R10			; some other error
	BSBW	REPORT_ERR			; report it
	BSBW	ERR				; continue?
	RSB					; that's it


REPORT_ERROR::

;
; REPORT_ERROR - Subroutine to report error
;
;
; AST to call report
;

	.WORD	^M<R2,R3,R4,R5,R6,-
		R7,R8,R9,R10,R11>
	MOVL	4(AP),R10			; structure from RMS call
	BSBW	REPORT
	RET
REPORT_ERR::

;
; REPORT_ERR - Entry point to enter report in-line, as opposed to by AST
;              save R0, then push STV and R0 to set up for CALL to REPORT
;

	PUSHL	R0				; error code in R0
						;  not in structure
	PUSHL	FAB$L_STV(R10)
	PUSHL	R0
	$WAIT	CMDORAB
	BRB	R
REPORT::

;
; REPORT - Subroutine to print out error
;          R10 is the structure at fault
;

	ASSUME	FAB$L_STS EQ RAB$L_STS		; could be either structure
	PUSHL	FAB$L_STS(R10)			; save status code
	$WAIT	CMDORAB
	PUSHL	FAB$L_STV(R10)			; set up for LIB$PUT_MESG
	PUSHL	FAB$L_STS(R10)
R:	PUSHL	#0				; no. of args for FAO
	PUSHL	#SHR$_RMSERROR+<RMSTEST@16>+3	; "RMS ERROR" message
	CALLS	#4,G^LIB$SIGNAL
						; if FNF is the error,
						;  print filename
	CMPL	(SP),#RMS$_FNF			; error is on the top of the STACK
	BNEQ	10$
	MOVL	FAB$L_NAM(R10),R11		; R10 is the guilty FAB,
						;  get NAMBLK addr
	BEQL	10$				; if no NAMBLK, exit
	MOVZBW	NAM$B_ESL(R11),-		; length of FILENAM
		RAB$W_RSZ+CMDORAB
	BEQL	10$				; if there is no name, exit
	MOVL	NAM$L_ESA(R11),-		; addr of FILENAM
		RAB$L_RBF+CMDORAB
	$PUT	CMDORAB				; print it
	BLBC	R0,.				; trap if error
10$:	POPR	#^M<R0>				; restore R0
	RSB

;
; This is a routine to ask the interactive user if it is desired to continue.
; The ABSOLUTE and RELATIVE PC'S are displayed and then 'CONTINUE' is asked.
;

ERR::
	BLBC	R0,ERR1
	RSB					; return if no error
ERR1:						; (secondary entry point in
						;  case R0 might have been OK)
	CMPL	R0,#SS$_ILLSER			; if illegal service, no
	BNEQ	10$				;  mesg output yet
	SUBL3	#20,(SP),R2			; so output one
	PUSHL	R0				; better save R0
	PUSHL	R2				; PC of error
	PUSHAL	ILLSERDEC			; descriptor
	PUSHL	#2				; number of args
	PUSHL	#SHR$_SYSERROR+<RMSTEST*65536>+2 ; mesg ID
	CALLS	#4,G^LIB$SIGNAL
	POPR	#^M<R0>				; restore R0 after mesg
10$:
	SUBL3	#20,(SP),-(SP)
	SUBL3	#RELZERO,(SP),-(SP)
	PUSHAQ	FAOBUF
	PUSHAW	CMDORAB+RAB$W_RSZ
	PUSHAQ	FAOSTR
	CALLS	#5,G^SYS$FAO
	BLBC	R0,.
	MOVAB	CMDBUF,CMDORAB+RAB$L_RBF
	$PUT	CMDORAB
	BLBC	R0,.
	BLBC	VERBOSITY,POPPC
	PROMPT	<CONTINUE?>,NULL=POPPC
	CMPB	CMDBUF,#^A/Y/
	BNEQ	POPPC
	RSB					; continue
POPPC:	POPR	#^M<R0>				; remove RETURN PC
	CMPB	CMD,#^A/C/			; is it a copy command?
	BNEQ	CLBR1
	$CLOSE	FAB=INFAB			; if so, clean up, ignoring errors
	$CLOSE	FAB=OUTFAB
	BICL	#FAB$M_NAM,FAB$L_FOP+INFAB
	MOVAL	NAMBLK,INFAB+FAB$L_NAM
	MOVAL	NAMBLK,NAM			; make it completely restartable
CLBR1:	BRW	CMD_LOOP


;
;  'U' command  -  Set default user file directory
;

TST$SETDDIR:
PROMPT	<DEFAULT UFD:>,NULL=CLBR1
	MOVC3	CMDIRAB+RAB$W_RSZ,CMDBUF,PNSBUF
	MOVZWL	CMDIRAB+RAB$W_RSZ,R2		; copy NAME STRING
	MOVW	R2,INFAB+FAB$B_FNS		; and length
	CLRW	INFAB+FAB$B_DNS
	PUSHAL	CMDBUF				; build descriptor for new
	PUSHL	R2				;  default dir (addr & length)
	PUSHAL	DIRDESC				; push args for SETDDIR
						;  (output buff)
	PUSHAL	DIRLEN				; output length
	PUSHAL	8(SP)				; addr of descriptor
	.IF	NDF RMSDEBUG
	CALLS	#3,SYS$SETDDIR			; set default directory name
	.IFF
	CALLS	#3,RMD$SETDDIR
	.ENDC
	POPR	#^M<R1,R2>			; clean up STACK
	BLBS	R0,CLBR2
	MOVAL	INFAB,R10
	BSBW	REPORT_ERR
	BSBW	ERR
CLBR2:	BRW	CMD_LOOP			; get next command

;

BADUFD:	ALWAYS	<BAD DIRECTORY SPEC!>
	BRB	CLBR2
BADPARSE:
	FIELD	<PARSED DIRECTORY SPEC>
	MBPT
	BRB	CLBR2


;
;  'R' command  -  Call I/O RUNDOWN
;

TST$RUNDWN:
	BLBS	VERBOSITY,10$
	BRW	QMARK
10$:
	TYPE	<I/O RUNDOWN - IF SUCCESSFUL NO MORE IMAGE I/O!>
RD1:	PUSHL	#0				; RUNDOWN image only
	PUSHAL	CPYBUFDSC
	.IF	NDF RMSDEBUG
	CALLS	#2,G^SYS$RMSRUNDWN
	.IFF
	CALLS	#2,G^RMD$RMSRUNDWN
	.ENDC
	BLBS	R0,RD2

;
;  Got a problem  -  Try writing to CMD
;

	MOVAL	RDMSG,CMDORAB+RAB$L_RBF
	MOVW	#RDMSGLEN,CMDORAB+RAB$W_RSZ
	$PUT	RAB=CMDORAB
	BLBS	R0,RD1
	BSBB	REOPEN_CMD
	TYPE	<RUNDOWN ERROR - CONTINUING>
	BRB	RD1

;
;  RUN DOWN succeeded  -  REOPEN command input channel
;

RD2:	BSBB	REOPEN_CMD
	TYPE	<RUN DOWN SUCCEEDED>
	CLRW	INFAB+FAB$W_IFI
	CLRW	OUTFAB+FAB$W_IFI
	CLRW	INRAB+RAB$W_ISI
	CLRW	OUTRAB+RAB$W_ISI
	BRW	CMD_LOOP

;

REOPEN_CMD:
	CLRW	CMDIFAB+FAB$W_IFI
	CLRW	CMDIRAB+RAB$W_ISI
	$OPEN	CMDIFAB
	BLBC	R0,.
	$CONNECT	CMDIRAB
	BLBC	R0,.
	CLRW	CMDOFAB+FAB$W_IFI
	CLRW	CMDORAB+RAB$W_ISI
	$OPEN	CMDOFAB
	BLBC	R0,.
	$CONNECT	CMDORAB
	BLBC	R0,.
	ALWAYS	<COMMAND FAB REOPENED.>
	RSB


;
;	'K' command - Set STICKINESS of RELATED FILE
;		    - Then test REMOVE, SEARCH, ENTER, SEARCH in that order
;		    - Also tests CONTIGUOUS-BEST-TRY on create
;
;


TST$STICKY:
	BEGIN	<RELATED FILENAME AND DIRECTORY TESTS>
	MOVAL	STICKY_NAMBLK,NAM		; in case of FNF error
	MOVB	#REL_FILE_SIZE,NAM$B_RSL+RELATED_NAM

;
; 	Check for separate PARSE followed by CREATE
;
;	FNM=TST$DISK:[]TS.*
;	RELATED FILE SPEC=TS.DAT
;

	SFNM	<[]TS.*;1>			; special test for wildcards
	$PARSE	FAB=STICKY_FAB2,ERR=REPORT_ERROR
	BSBW	ERR
	BISL2	#FAB$M_NAM,-			; do CREATE with NAM BLK
		FAB$L_FOP+STICKY_FAB2
	$CREATE	FAB=STICKY_FAB2,ERR=REPORT_ERROR
	BSBW	ERR
	$CLOSE	FAB=STICKY_FAB2,ERR=REPORT_ERROR
	BSBW	ERR
	BSBW	MORE

;
;	CREATE a file with FNM=TST$DISK:.;1
;		and RELATED FILE SPEC = TS.DAT
;	hopefully getting TS.DAT w/ current DEV and UIC
;

	SFNM	<;1>				; new filename
						; NOTE: Can't have .;1
						;  since that implies
						;  explicit filetype
						;  ( albeit null)
	BICL2	#FAB$M_NAM,FAB$L_FOP+STICKY_FAB2
	$CREATE	FAB=STICKY_FAB2,ERR=REPORT_ERROR
	BSBW	ERR
	CMPL	R0,#RMS$_SUPERSEDE
	BEQL	OKSUP
	FIELD	<STS (NOT = SUPERSEDE)>
OKSUP:	$CLOSE	FAB=STICKY_FAB2,ERR=REPORT_ERROR
	BSBW	ERR
	BSBB	MORE				; verify RESULTANT NAME
	BRB	NEXT

;
;  Verify RESULTANT NAME
;

MORE:	LOCC	#RBRACK,#RESBSZ,RESBUF		; try to find right bracket
	BEQL	10$				; bad string
	MOVAL	REL_FILE,R0
	INCL	R1				; pass bracket by
	MOVL	#REL_FILE_SIZE,R2
5$:	CMPB	(R0)+,(R1)+			; comp NAM and TYP
	BNEQ	10$
	SOBGTR	R2,5$
	CMPB	(R1),#SEMI			; end of RES too?
	BNEQ	10$
	RSB					; worked
10$:	FIELD	<RESULTANT STRING>
	MBPT
	BRW	CMD_LOOP

;

NEXT:	TYPE	<STICKY CREATE WORKED>

;
; CREATEd it alright - Now enter it checking for lower version
; and SEARCH for it 
;

	SUBB2	#2,STICKY_NAMBLK+NAM$B_ESL	; get rid of VERSION in EXP STR
						;  just for good measure zero
						;  FNA
	CLRL	STICKY_FAB2+FAB$L_FNA		; no PRIMARY NAM STRING
	CLRB	STICKY_FAB2+FAB$B_FNS		; therefore clear length
	$ENTER	FAB=STICKY_FAB2,-		; enter takes EXP STR as input
		ERR=REPORT_ERROR
	BSBW	ERR
	BBS	#NAM$V_LOWVER,STICKY_NAMBLK+NAM$L_FNB,SOK
	FIELD	<LOWER VERSION BIT IN FNB>
	BRB	REM_SRCH
SOK:
	MOVAL	STICKY_NAMBLK,R0
	MOVAL	RESBUF,NAM$L_ESA(R0)
	MOVB	NAM$B_RSL(R0),NAM$B_ESL(R0)
	$SEARCH	FAB=STICKY_FAB2,ERR=REPORT_ERROR
	BSBW	ERR
	TYPE	<ENTER WITH LOWER VERSION AND SEARCH OK >

;
; Now remove that newest entry and SEARCH for it, hoping the SEARCH fails
;

REM_SRCH:
	MOVAL	STICKY_NAMBLK,R0
	MOVL	NAM$W_FID(R0),SAVE_FID
	MOVW	NAM$W_FID+4(R0),SAVE_FID+4	; save FID for later
	$NAM_STORE	NAM=STICKY_NAMBLK,-	; zero FID and CONTEXT
			FID=#0,WCC=#0
	$REMOVE	FAB=STICKY_FAB2,-		; remove the DIR. entry
		ERR=REPORT_ERROR
	BSBW	ERR
	MOVAL	STICKY_NAMBLK,R0
	MOVAL	RESBUF,NAM$L_ESA(R0)		; move RESULTANT STR ADDR
						; to ESA
	MOVB	NAM$B_RSL(R0),NAM$B_ESL(R0)
	$SEARCH	STICKY_FAB2			; look for it
	MOVAL	EXPBUF,NAM$L_ESA+STICKY_NAMBLK
	CMPL	R0,#RMS$_NMF			; better not be there
	BEQL	OK
	CMPL	R0,#RMS$_NORMAL			; but it was
	BNEQ	CHK
	TYPE	<SYS$REMOVE DIDN'T DO ITS JOB>
	BRB	OUT
CHK:	BLBS	R0,10$
	MOVAL	STICKY_FAB2,R10
	BSBW	REPORT_ERR
	BSBW	ERR
10$:
OK:
	TYPE	<REMOVE AND SEARCH OK>
OUT:
	$NAM_STORE	NAM=STICKY_NAMBLK,-	; restore FID
			FID=SAVE_FID

;
;  Now test $RENAME function by renaming TS.DAT to RENAMED.TST;32 and back.
;

	$NAM_STORE	NAM=OLDNAM,ESL=#0,RSL=#0
	$NAM_STORE	NAM=NEWNAM,ESL=#0,RSL=#0
	$RENAME	OLDFAB=OLDFAB,NEWFAB=NEWFAB,ERR=REPORT_ERROR
	BSBW	ERR
	TYPE	<FILE RENAMED!>
	TSTB	VSW
	BLSS	RERENM				; omit printout if not wanted
TYPE	<OLD NAME:>
	MOVAL	OLDNAM,NAM
	BSBW	TST$SHOWNAM
TYPE	<NEW NAME:>
	MOVAL	NEWNAM,NAM
	BSBW	TST$SHOWNAM
RERENM:	$RENAME	OLDFAB=NEWFAB,-			; re-rename file
		NEWFAB=OLDFAB,ERR=REPORT_ERROR
	BSBW	ERR
	TYPE	<ORIGINAL FILENAME RESTORED>

;
; Now OPEN the original file by FILE ID and DELETE it on CLOSE by FID
;

	BISL	#FAB$M_NAM,-			; OPEN by FID
		FAB$L_FOP+STICKY_FAB2
	BICL	#FAB$M_CBT!FAB$M_CTG,-		; to do CBT test
		FAB$L_FOP+STICKY_FAB2
	$OPEN	FAB=STICKY_FAB2,-		; OPEN orig. file
		ERR=REPORT_ERROR
	BSBW	ERR
	BBS	#FAB$V_CBT,FAB$L_FOP+STICKY_FAB2,CBTOK
	FIELD	<CBT BIT CLEAR, THEREFORE>
CBTOK:
	BBC	#FAB$V_CTG,FAB$L_FOP+STICKY_FAB2,CTGOK
	FIELD	<CTG BIT SET, THEREFORE>
CTGOK:
	BISL	#FAB$M_DLT, FAB$L_FOP+STICKY_FAB2
	$CLOSE	FAB=STICKY_FAB2,-		; DELETE by FID on CLOSE
		ERR=REPORT_ERROR
	BSBW	ERR
	TYPE	<TS.DAT DELETED ON CLOSE>
	BICL	#FAB$M_NAM!FAB$M_DLT,-		; for next time
		FAB$L_FOP+STICKY_FAB2
	MOVAL	NAMBLK,NAM			; ditto
	FINISH	<RELATED FILENAME AND DIRECTORY TESTS>
	BRW	CMD_LOOP



;
;  General RMS tests
;
;	TEST 1
;
;  SEQUENTIAL FILE ORG, DISK, VFC RFM
;

TST$GENERAL:
	CALLS	#0,RMT$TEST_1A
	BRW	CMD_LOOP



;
;	SHARED FILE Tests
;
;

TST$SHR:
	CALLS	#0,SHRSTRT
	BRW	CMD_LOOP



;
;	BLOCK I/O Tests
;
;
;		TEST	2
;

TST$BLOCK:
	CALLS	#0,TST$BLOCKIO
	BRW	CMD_LOOP



;
;	RELATIVE Tests
;
;		TEST 3
;

TST$RELATIVE:
	CALLS	#0,RMT$TEST_3A
	BRW	CMD_LOOP

;
;	INDEXED Tests
;
;		RMSTEST8
;

TST$INDEX:
	CALLS	#0,RMT$INDEX
	BRW	CMD_LOOP






;
;	FLUSH and FHC XAB Tests
;
;		TEST 4
;

TST$F:
	CALLS	#0,RMT$TEST_4A
	BRW	CMD_LOOP



;
;	MAGTAPE Tests
;
;		TEST 6
;

TST$MTAPE:
	CALLS	#0,TST$MTA
	BRW	CMD_LOOP


;
;	NETWORK Tests
;
;

TST$NET:

;
;	COMMENT CALL until TST$NETWORK is implemented
;	to prevent an undefined symbol at link-time
;	CALLS	#0,TST$NETWORK
;

ABORTP:	BRW	CMD_LOOP

;
;	PRINT or SUBMIT OUTPUT File
;
;

TST$PRINT:
	PROMPT	<PRINT (P) OR SUBMIT COMMAND FILE (S)?>,NULL=ABORTP
	CMPB	CMDBUF,#^A/P/
	BNEQ	10$
	BISL2	#FAB$M_SPL,FAB$L_FOP+OUTFAB
	BRB	20$
10$:	CMPB	CMDBUF,#^A/S/
	BNEQ	ABORTP
	BISL2	#FAB$M_SCF,FAB$L_FOP+OUTFAB
20$:	PROMPT	<DELETE FILE AFTER QUEUING?>,NULL=30$
	CMPB	CMDBUF,#^A/Y/
	BNEQ	30$
	BISL2	#FAB$M_DLT,FAB$L_FOP+OUTFAB
30$:	BRW	TST$COPY


;
;  Subroutine to PRINT the EXPANDED and RESULTANT NAME STRINGS from
;  the NAM BLOCK -- The address of the NAM BLOCK is found in NAM
;

TST$SHOWNAM:
	TSTB	VSW				; long typeout wanted?
	BLSS	RTN				; branch if yes
	MOVL	NAM,R4				; get addr of NAMBLK in R4
TYPE	<EXPANDED NAME STRING:>
	BSBB	TYPEXP				; type EXPANDED NAME STRING
TYPE	<RESULTANT NAME STRING:>
	MOVZBW	NAM$B_RSL(R4),CMDORAB+RAB$W_RSZ
	MOVL	NAM$L_RSA(R4),CMDORAB+RAB$L_RBF
	$PUT	RAB=CMDORAB,ERR=REPORT_ERROR
	BSBW	ERR
RTN:	RSB

;
;  PRINT EXPANDED NAME STRING
;  R4 must point to a NAMBLK
;

TYPEXP:	MOVZBW	NAM$B_ESL(R4),CMDORAB+RAB$W_RSZ
	MOVL	NAM$L_ESA(R4),CMDORAB+RAB$L_RBF
	$PUT	RAB=CMDORAB,ERR=REPORT_ERROR
	BSBW	ERR
	RSB

;
;	Routines to issue messages
;
;

	RMSTEST	== 1001				; FACILITY CODE for RMSTEST

;
;

BEGPUT::
	PUSHL	#0				; get current TIME
	PUSHAL	BEG_DESCR			; string descr
	PUSHL	#2				; # of FAO args
	PUSHL	#SHR$_BEGINT+<RMSTEST*65536>+1	; MESSAGE CODE
	CALLS	#4,G^LIB$SIGNAL
	RSB
FINPUT::
	PUSHL	#0				; current TIME
	PUSHAL	FIN_DESCR			; string descr
	PUSHL	#2				; # of FAO args
	PUSHL	#SHR$_ENDEDT+<RMSTEST*65536>+1	; MESSAGE ID
	CALLS	#4,G^LIB$SIGNAL
	RSB
FLDPUT::
	SUBL3	#21,(SP),R2			; try to find ABS. PC of ERROR
	PUSHL	R0				; save status code, if nec.
	PUSHL	R2				; PC
	PUSHAL	FLD_DESCR			; string descr
	PUSHL	#2				; # of FAO args
	PUSHL	#SHR$_BADFIELD+<RMSTEST*65536>+2  ; MESSAGE ID
	CALLS	#4,G^LIB$SIGNAL
	POPR	#^M<R0>				; restore R0
	RSB

;
; Subroutine to issue "EXPECTED EOF NOT RECEIVED" mesg, and display actual
; error R10 points to the structure at fault, for REPORT_ERR
;

EOFPUT::
	SUBL3	#5,(SP),R2
	PUSHL	R0				; save STATUS, if nec.
	PUSHAL	EOF_DSC				; "EOF" arg for  FAO
	PUSHL	#1				; # of args, for FAO
	PUSHL	#SHR$_UNXPCTSTS+<RMSTEST@16>+3	; error code
	CALLS	#3,G^LIB$SIGNAL
	POPR	#^M<R0>				; restore STATUS
	BSBW	REPORT_ERR			; find out what error was
	BRW	ERR1				; continue?,even if R0=SUC

;
;  Routine to echo the command if command output not to a terminal
;

ECHO:	BLBC	VERBOSITY,10$			; omit if low verbosity
	BBS	#DEV$V_TRM,-			; or if terminal output
		CMDOFAB+FAB$L_DEV,10$
	ADDW3	#8,CMDIRAB+RAB$W_RSZ,-		; add size of PROMPT to len
		CMDORAB+RAB$W_RSZ
	MOVAL	ECHOBF,CMDORAB+RAB$L_RBF	; address of output line
	$PUT	RAB=CMDORAB,ERR=REPORT_ERROR
	BSBW	ERR
10$:	RSB

	.MDELETE	$FAB,$RAB,$NAM
	.MDELETE	$FAB_STORE,$NAM_STORE,$RAB_STORE

;
;
;		'H' Switch for HELP !!!!!!
;

HELP:
	BLBS	VERBOSITY,10$
	BRW	QMARK
10$:
	.SAVE
	.PSECT	__$RMSNAM
HLPMSG:
	.ASCII	/A -- APPEND/<13><10>
	.ASCII	%B -- BLOCK I/O%<13><10>
	.ASCII	/C -- COPY/<13><10>
	.ASCII	/D -- DEBUG/<13><10>
	.ASCII	/F -- $FLUSH AND FHC XAB TESTS/<13><10>
	.ASCII	/G -- GENERAL SEQUENTIAL TESTS/<13><10>
	.ASCII	/H -- THIS MESSAGE/<13><10>
	.ASCII	/K -- STICKY CREATE,DIRECTORY TESTS/<13><10>
	.ASCII	/L -- GENERAL RELATIVE TESTS/<13><10>
	.ASCII	/M -- MAGTAPE TESTS/<13><10>
	.ASCII	/N -- DECNET TESTS/<13><10>
	.ASCII	/O -- COPY WITH CHOICE OF FILE ORG FOR OUTPUT FILE/<13><10>
	.ASCII	/P -- PRINT OR SUBMIT COMMAND FILE/<13><10>
	.ASCII	%R -- I/O RUNDOWN%<13><10>
	.ASCII	/S -- SET DEFAULT NAME STRING/<13><10>
	.ASCII	/U -- SET DEFAULT UFD/<13><10>
	.ASCII	/V -- VERIFY FILE SPECIFICATIONS/<13><10>
	.ASCII	/X -- INDEXED FILE TEST/<13><10>
	.ASCII	/ALL OTHER LETTERS ARE INVALID/<13><10>
HLPMSGSZ=.-HLPMSG
	.RESTORE
	MOVAL	HLPMSG,CMDORAB+RAB$L_RBF
	MOVW	#HLPMSGSZ,CMDORAB+RAB$W_RSZ
	$PUT	RAB=CMDORAB,ERR=REPORT_ERROR
	BSBW	ERR
	BRW	CMD_LOOP
	.END	START
