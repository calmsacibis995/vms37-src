	.TITLE	TST20A
	.IDENT	/V03000/
	.PSECT	TST20A
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; VERSION X02
;
; WRITTEN BY CLARK A. D'ELIA, FEBRUARY 1973
; MODIFIED BY TOM MILLER FOR RSX-11M, SEPTEMBER,1974
;	7/15/75 (CHANGE EXPECTED ERROR CODE ON INVALID DPB SIZE)
; MODIFIED BY LARRY JONES FOR VAX/VMS, AUGUST, 1978
;
;+
;
; MODULE 'TST20A' IS THE MAIN TASK OF TEST20.  IT IS DESIGNED TO TEST
; THE FOLLOWING RSX-11M SYSTEM DIRECTIVES:
;
;	GET TASK PARAMETERS
;	REQUEST
;	RUN
;
;
; THIS TASK IS ASSUMED TO HAVE THE FOLLOWING ATTRIBUTES:
;
;	1)  LUN'S = 8.
;	2)  PRIORITY = 50.
;	3)  UIC = [200,200]
;
;-
	.PAGE

	.MCALL	CALL,RETURN,GTSK$S,SVTK$C,GSSW$S,MRKT$S
	.MCALL	WTSE$S,CLEF$S,RUN$C,RQST$C,EXIT$S,GPRT$C

 
;
; LOCAL ASSIGNMENTS
;
DEFPRI=	50.	;DEFAULT PRIORITY
G.TSTS=	32	;TASK SIZE OFFSET IN TASK PAREMETERS BUFFER

;
; LOCAL DATA
;

TASKB:	.BLKW	16.		;GET TASK PARAMETERS BUFFER

;
; GET TASK PARAMETERS CHECK PARAMETER BLOCKS
;
ARG20A:	.WORD	G.TSTN+TASKB	;TASK NAME ADDR
	.WORD	2		;ARG WORD COUNT
	.RAD50	/TST20A/	;TASK NAME
	.ASCII	/R /		;DATA TYPE

ARGPRI:	.WORD	G.TSPR+TASKB	;PRIORITY ADDR
	.WORD	1		;COUNT
	.WORD	DEFPRI		;PRIORITY
	.ASCII	/D./		;DATA TYPE

ARGLUN:	.WORD	G.TSNL+TASKB	;NUMBER OF LUN'S ADDR
	.WORD	1		;COUNT
	.WORD	8.		;NUMBER OF LUN'S
	.ASCII	/D./		;DATA TYPE
 
ARGSVA:	.WORD	G.TSVA+TASKB	;ADDR OF SST VECTOR ADDR
	.WORD	1		;COUNT
	.BLKW	1		;SST VECTOR ADDR
	.ASCII	/O /		;DATA TYPE

ARGSVL:	.WORD	G.TSVL+TASKB	;ADDR OF SST VECTOR LENGTH
	.WORD	1		;COUNT
	.BLKW	1		;SST VECTOR LENGTH
	.ASCII	/D./		;DATA TYPE

ARGSPR:	.WORD	G.TSPC+TASKB	;ADDRESS OF UIC
	.WORD	1		;COUNT
	.BYTE	200,200		;EXPECTED UIC
	.ASCII	/P /		;DATA TYPE
ARGSIZ:	.WORD	G.TSTS+TASKB	;ADDRESS OF TASK SIZE
	.WORD	1		;COUNT
	.BLKW	1		;EXPECTED SIZE TO BE FILLED IN
	.ASCII	/P /		;DATA TYPE
 
 
PARNAM:	.BLKW	2
 
PARBUF:	.BLKW	3		;GPRT BUFFER

	.NLIST	BEX

LEM01:	.ASCII	/TASK PARAMETER ERROR%NOFFSET: %O, EXP'D: %V/
DATYP1:	.ASCII	/??, RCV'D: %V/
DATYP2:	.ASCIZ	/??/
 
LEM02:	.ASCIZ	/%N+++ SWITCH REGISTER READ AS %P/
 
LEM03:	.ASCII	/%N+++ THE PARAMETERS OF THE PARTITION IN WHICH THIS /
	.ASCII	/TASK IS RUNNING ARE:/
	.ASCII	/%N	NAME:  %R%R/
	.ASCII	/%N	BASE ADDRESS (IN 32. WORD BLOCKS):  %O/
	.ASCII	/%N	SIZE (IN 32. WORD BLOCKS):  %O/
	.ASCIZ	/%N	FLAGS WORD:  %P%N/

	.EVEN
	.LIST	BEX
	.PAGE

;+
;
; INITIALLY, THIS TASK SENDS AN IDENTIFYING MESSAGE TO THE USER
; AT TT0.  THE MESSAGE INDICATES THE START OF TASK EXECUTION,
; AND IT IDENTIFIES THE TEST NUMBER.
;
;-
	$$TEST	20,A		;DECLARE TEST #20, SUBTEST-A, STEP #0
	CALL	.STST		;SEND THE START OF TEST MESSAGE
 
;+
;
; THE "GET TASK PARAMETERS" DIRECTIVE IS INVOKED AND THE TASK INFORMATION
; IS CHECKED.
;
;-
	$$STEP
	GTSK$S	#TASKB,.RJCT	;GET TASK PARAMETERS
	CALL	.SUCC		;CHECK FOR VALID RETURN CODE

;
; THE TASK NAME IS CHECKED
;

	MOV	#ARG20A,R5	;PUT ADDR OF ARG BLOCK IN R5
	CALL	CKPARM		;CHECK THE PARAMETER


;
; THE TASK PRIORITY IS CHECKED
;

;	MOV	#ARGPRI,R5	;PUT ADDR OF ARG BLOCK IN R5
;	CALL	CKPARM		;CHECK THE PARAMETER

;
; THE NUMBER OF LOGICAL UNITS IS CHECKED
;

;	MOV	#ARGLUN,R5	;PUT ADDR OF ARG BLOCK IN R5
;	CALL	CKPARM		;CHECK THE PARAMETER
	.PAGE
 
 

;
; CHECK THE SST VECTOR ADDRESS
; IF THE SST VECTOR ADDRESS HAS NOT BEEN SPECIFIED, THEN THE SIZE
; OF THE SST VECTOR RETURNED IS MEANINGLESS, AND IS THEREFORE NOT
; CHECKED
;

	CLR	ARGSVA+4	;INITIALLY, ADDR SHOULD BE ZERO
	MOV	#ARGSVA,R5	;PUT ADDR OF ARG BLOCK IN R5
	CALL	CKPARM		;CHECK THE PARAMETER


;
; CHECK THE UIC
;
;	MOV	#ARGSPR,R5	;PUT ADDRESS OF ARGBLK IN R5
;	CALL	CKPARM		;CHECK IT
;
; CHECK THE TASK SIZE
; THE TASK SIZE IN RSX-11M IS EQUAL TO THE SIZE OF THE PARTITION
; THAT THE TASK IS RUNNING IN.  THEREFORE THE ARGBLK IS FILLED IN
; WITH THE SIZE RETURNED FROM A GET PARTITION PARAMETERS CALL.
; IF THE TEST IS BEING RUN ON RSX-11D (ADDRESS OF $DSW=0), THEN THIS
; TEST IS SKIPPED.
;
	TST	#$DSW		;RUNNING ON RSX-11M?
	BEQ	NOTM		;NO,SKIP THIS TEST
	MOV	TASKB+G.TSPN,PARDPB+G.PRPN ;MOVE PARTITION OF TASK INTO DPB
	MOV	TASKB+G.TSPN+2,PARDPB+G.PRPN+2
	GPRT$C	,PARBUF,TST20A,.RJCT ;GET PARTITION PARAMETERS
PARDPB=	$$$
	MOV	PARBUF+2,-(SP)	;EXTRACT SIZE IN 32 WORD UNITS
	.REPT	6		;CONVERT TO BYTES
	ASL	@SP
	.ENDR
	MOV	(SP)+,ARGSIZ+4	;MOVE INTO ARGBLK
	MOV	#ARGSIZ,R5	;ADDRESS OF ARGBLK TO R5
	CALL	CKPARM		;CHECK IT
NOTM:
	.PAGE
;+
;
; AN SST VECTOR TABLE WILL BE SPECIFIED.  THE "GET TASK PARAMETERS"
; DIRECTIVE WILL BE INVOKED AND THE INFORMATION WILL BE CHECKED TO INSURE
; THE CHANGE WAS NOTED.
;
;-
	$$STEP
	SVTK$C	ARGSVA,1,TST20A,.RJCT ;SPECIFY A VECTOR TABLE ADDR
	GTSK$S	#TASKB,.RJCT	;GET PARAMETERS


;
; CHECK THE SST VECTOR ADDRESS
;
	MOV	#ARGSVA,R5	;PUT ADDR OF ARG BLOCK IN R5
	MOV	R5,4(R5)	;AND IN THE ARG BLOCK (IT'S THE V.A.)
	CALL	CKPARM		;CHECK THE PARAMETER

;
; CHECK THE SST VECTOR (WORD) LENGTH
;

	MOV	#ARGSVL,R5	;PUT ADDR OF ARG BLOCK IN R5
	MOV	#1,4(R5)	;SPECIFY LENGTH OF ONE WORD
	CALL	CKPARM
	.PAGE
;+
;
; THE OPTIONAL UIC PARAMETERS OF THE "REQUEST" DIRECTIVE WILL BE
; TESTED.  TASK 'TST20B' WAS BUILT WITH THE UIC [200,200], BUT IT
; WILL NOW BE ACTIVATED WITH THE UIC [SYSTEST].  EVANT FLAG #40. WILL
; BE USED TO INSURE PROPER TASK COORDINATION.
;
;-
	$$STEP
	CLEF$S	#40.,.RJCT	;INITIALLY, CLEAR EFN #40.
	RQST$C	TST20B,,,1,7,TST20A,.RJCT  ;ACTIVATE 'TST20B'
	BCS	100$		;SKIP IF DIRECTIVE FAILED
	WTSE$S	#40.,.RJCT	;WAIT FOR 'TST20B' TO COMPLETE
100$:
;+
;
; TEST THE OPTIONAL UIC PARAMETER OF THE "RUN" DIRECTIVE.  AGAIN
; TASK 'TST20B' WILL BE USED.
;
;-
	$$STEP
	CLEF$S	#40.,.RJCT	;CLEAR EFN #40. AGAIN
	RUN$C	TST20B,,,300,1,5,SECOND,5,SECOND,TST20A,.RJCT
	BCS	100$		;SKIP IF DIRECTIVE FAILED
	WTSE$S	#40.,.RJCT	;WAIT FOR 'TST20B' TO COMPLETE
	MRKT$S	#1,#20.,#SECOND,,.RJCT  ;MARK-TIME TO ALLOW THE ...
	BCS	100$		;... RESCHEDULE OPTION OF 'TST20B' ...
	WTSE$S	#1,.RJCT	;... TO TAKE A FEW TIMES
100$:
	.PAGE
;+
;
; TO COMPLETE TESTING, THE ABILITY OF THE "GET TASK PARAMETERS"
; DIRECTIVE TO RECOGNIZE ERRORS WILL BE CHECKED.  THIS STEP SUPPLIES
; AN ODD BUFFER ADDRESS.
;
;-
	CALL	$ADCHK		;IS SYSTEM PERFORMING ADDRESS CHECKING?
	BCS	NADCK1		;IF NOT, SKIP TESTS REQUIRING CHECKING
	$$STEP
	GTSK$S	#TASKB+1
	MOV	#IE.ADP,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK THE RETURNED DIRECTIVE STATUS
;+
;
; THE "GET TASK PARAMETERS" DIRECTIVE IS INVOKED WITH A BUFFER ADDRESS
; THAT IS OUT OF THE SEGMENT.
;
;-
	$$STEP
	MOV	#IE.ADP,R1	;PUT EXPECTED ERROR STATUS IN R1
	GTSK$S	#160000
	CALL	.FAIL		;CHECK THE STATUS
;+
;
; THE "GET TASK PARAMETERS" DIRECTIVE IS ISSUED WITH AN INVALID DPB SIZE.
;
;-
NADCK1:
	$$STEP
;*****
	JMP	STP11
;*****
	MOV	(PC)+,-(SP)	;PUT BAD DPB ON STACK
	.BYTE	63.,0		;INVALID "GET TASK PARMS" DPB
	DIR$			;INVOKE BAD DPB
	MOV	#IE.ADP,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK DIRECTIVE STATUS
	MOV	(PC)+,-(SP)	;PUT BAD DPB ON STACK
	.BYTE	63.,1		;
	DIR$			;INVOKE DPB
	MOV	#IE.SDP,R1	;SET EXPECTED ERROR CODE
	CALL	.FAIL		;CHECK EXPECTED ERROR CODE
;+
;
; IN THIS STEP WE WILL USE THE GET TASK PARAMETERS DIRECTIVE TO OBTAIN
; THE PARAMETERS OF THE PARTITION IN WHICH THIS TASK IS RUNNING.  THE
; THE PARAMETERS WILL SIMPLY BE OUTPUT TO TI FOR VERIFICATION BY THE USER.
; THE PARAMETERS FOR OUTPUT WILL BE COLLECTED IN A VECTOR STARTING AT
; #PARNAM.  FIRST THE PARTITION WILL BE MOVED THERE FROM THE GET TASK
; PARAMETERS BUFFER.  THE GET PARTITION PARAMETERS DIRECTIVE WILL BE USED
; TO FILL IN THE REMAINING THREE WORDS OF THE VECTOR.  THE ROUTINE
; .PRTMG WILL BE USED TO FORMAT THE OUTPUT MESSAGE AND PRINT IT.
;
;-
	MOV	TASKB+G.TSPN,PARNAM ;FIRST WORD OF PARTITION NAME
	MOV	TASKB+G.TSPN+2,PARNAM+2 ;SECOND WORD OF PARTITION NAME
	GPRT$C	,PARBUF,TST20A,.RJCT ;GET REMAINING THREE PARAMETERS
	MOV	#.OBUF,R0	;SET UP OUTPUT BUFFER POINTER
	MOV	#LEM03,R1	;SET UP MESSAGE POINTER
	MOV	#PARNAM,R2	;SET UP POINTER TO PARAMETER VECTOR
	CALL	.PRTMG		;PRINT IT
;+
;
; IN THIS STEP WE WILL BEGIN CHECKING ERROR CONDITIONS OF CALLS TO THE
; GET PARTITION PARAMETERS DIRECTIVE.  FIRST A NONEXISTENT PARTITION
;
;-
	$$STEP
	GPRT$C	PARX,TASKB,TST20A ;INVOKE DIRECTIVE
	MOV	#IE.INS,R1	;EXPECTED ERROR CODE TO R1
	CALL	.FAIL		;CHECK ERROR CODE RETURNED
;+
;
; NEXT AN ODD BUFFER ADDRESS
;
;-
	$$STEP
	CALL	$ADCHK		;IS SYSTEM PERFORMING ADDRESS CHECKING?
	BCS	NADCK2		;IF NOT, SKIP TESTS REQUIRING CHECKING
	GPRT$C	,TASKB+1,TST20A	;INVOKE DIRECTIVE
	MOV	#IE.ADP,R1	;EXPECTED ERROR CODE TO R1
	CALL	.FAIL		;CHECK ERROR CODE RETURNED
NADCK2:
;+
;
; NEXT AN INVALID DPB SIZE
;
;-
	$$STEP
	MOV	(PC)+,-(SP)	;DIC WITH BAD DPB SIZE TO STACK
	.BYTE	65.,1
	DIR$			;INVOKE IT
	MOV	#IE.SDP,R1	;EXPECTED ERROR CODE TO R1
	CALL	.FAIL		;CHECK ERROR CODE RETURNED
;+
;
; IN THIS STEP WE WILL TEST THE GET SENSE SWITCHES DIRECTIVE.
;
;-
	$$STEP
;*****
	JMP	STP15	;THERE ARE NO SWITCHS ON A VAX!
;*****
	GSSW$S	.RJCT		;INVOKE DIRECTIVE
	MOV	$DSW,-(SP)	;PUSH RETURNED SENSE SWITCH WORD
	MOV	SP,R2		;PUT POINTER TO IT IN R2
	MOV	#LEM02,R1	;MESSAGE POINTER TO R1
	MOV	#.OBUF,R0	;OUTPUT BUFFER POINTER TO R0
	CALL	.PRTMG		;PRINT MESSAGE WITH VALUE READ FROM
				;SWITCH REGISTER
;+
;
; IN THIS STEP WE WILL INVOKE THE GET SENSE SWITCHES DIRECTIVE WITH
; AN INVALID DPB SIZE
;
;-
	$$STEP
	MOV	(PC)+,-(SP)	;DIC WITH INVALID DPB SIZE TO STACK
	.BYTE	125.,0
	DIR$			;INVOKE DIRECTIVE
	MOV	#IE.ADP,R1	;EXPECTED ERROR CODE TO R1
	CALL	.FAIL		;CHECK ERROR CODE RETURNED
	MOV	(PC)+,-(SP)	;PUSH INVALID DPB
	.BYTE	225.,1
		;
	DIR$			;INVOKE DPB
	MOV	#IE.SDP,R1	;SET EXPECTED ERROR CODE
	CALL	.FAIL		;CHECK ERROR CODE
;+
;
; TESTING IS COMPLETE -- SEND THE END OF TEST MESSAGE AND EXIT.
;
;-
	$$STEP
	CALL	.ETST		;SEND END MESSAGE
	EXIT$S	.RJCT		;EXIT
	.PAGE
;
;		'CKPARM'
;
; THIS SUBROUTINE IS USED TO CHECK THE INFORMATION RETURNED BY THE "GET
; TASK PARAMETERS" DIRECTIVE.  THE INFORMATION IS ASSUMED TO BE IN THE
; BUFFER NAMED 'TASKB', AND THE ADDRESS OF THE PARAMETER COMPARE BLOCK
; MUST BE IN R5.  THE BLOCK MUST HAVE (IN ORDER) THE FOLLOWING PIECES
; OF INFORMATION:
;
;		1) THE PARAMETER ADDRESS,
;		2) THE PARAMETER WORD COUNT,
;		3) THE PARAMETER,
;		4) THE DATA TYPE TO BE USED IN ERROR REPORTING.
;
; REGISTERS R0, R1, R2, AND R3 ARE ASSUMED TO BE VULNERABLE.
;
;
CKPARM:	CLR	-(SP)		;CLEAR ERROR INDICATOR
	MOV	R5,R0		;COPY R5
	MOV	(R0)+,R1	;PUT PARAMETER ADDR IN R1
	MOV	(R0)+,R2	;PUT PARM WORD COUNT IN R2
1$:	CMP	(R0)+,(R1)+	;COMPARE PARMS
	BEQ	2$		;SKIP IF MATCH
	INC	(SP)		;ELSE, SET ERROR INDICATOR
2$:	SOB	R2,1$		;LOOP 'TIL ALL PARM WORDS ARE CHECKED
	TST	(SP)+		;CHECK (AND POP) ERROR INDICATOR
	BEQ	5$		;SKIP TO RETURN IF NO ERRORS
	MOVB	(R0),DATYP1	;ELSE, MOVE BOTH LETTERS OF
	MOVB	1(R0),DATYP1+1	;DATA TYPE INTO FIRST PART OF FORMAT
	MOVB	(R0),DATYP2	;AND INTO SECOND PART
	MOVB	1(R0),DATYP2+1	;OF FORMAT
	MOV	SP,R3		;SAVE STACK ADDR
	MOV	2(R5),R2	;PUT PARM WORD COUNT IN R2
3$:	MOV	-(R1),-(SP)	;PUT RCV'D PARM IN STACK
	SOB	R2,3$		;PUT ALL WORDS IN
	MOV	2(R5),R2	;PUT PARM WORD COUNT IN R2
	MOV	R2,-(SP)	;AND IN THE STACK
4$:	MOV	-(R0),-(SP)	;PUT EXP'D PARM IN STACK
	SOB	R2,4$		;PUT ALL WORDS IN
	MOV	2(R5),-(SP)	;PUT PARM WORD COUNT IN STACK
	MOV	(R5),-(SP)	;PUT PARM ADDR IN STACK
	SUB	#TASKB,(SP)	;AND CALC THE ELEMENT'S OFFSET
	CALL	.IDOUT		;SETUP STEP IDENTIFICATION
	MOV	#LEM01,R1	;PUT FORMAT ADDR IN R1
	MOV	SP,R2		;PUT ARG LIST ADDR IN R2
	CALL	.PRTMG		;CREATE REST OF MESSAGE AND PRINT
	MOV	R3,SP		;RESTORE STACK
5$:	RETURN			;RETURN TO THE PROGRAM
	.END	STP0
