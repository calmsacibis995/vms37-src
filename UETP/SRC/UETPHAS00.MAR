	.TITLE TSTCNTRL TEST PACKAGE CONTROL PROGRAM
	.IDENT	'V03-000'
	.ENABLE SUPPRESSION
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:
;	TEST PACKAGE CONTROL PROGRAM
;
; ABSTRACT:
;	This program will serve as the controlling program between various
;	test programs.  It will create the test programs (either .EXE or
;	.COM) as detached processes and run them either sychronously or
;	asychronously.
;
; ENVIRONMENT:
; 	This program will run in user access mode, with interrupts enabled
;	at all times.  This program requires the following privileges and
;	quotas:
;		either SETPRIV or (DETACH and WORLD)
;
;
; AUTHOR: Brian A. Axtell,	CREATION DATE: January, 1981
;
; MODIFIED BY:
;
;	V03-005	BAA004		Brian A. Axtell,	25-Jan-1982
;		Changed logical name for controlling device from SYS$INPUT
;		to SYS$COMMAND.  This was so Control-C's worked from
;		command procedures.
;
;	V03-004 BAA003		Brian A. Axtell,	13-Jan-1982
;		Changed scanning the data records from looking for blanks
;		to looking for any non-printing character.
;
;	V03-003	BAA0002		Brian A. Axtell,	11-Jan-1982
;		Put branch around enable Control-C handler if not running
;		from a terminal.
;		Corrected misspellings in error messages.
;
;	V03-002 BAA0001		Brian A. Axtell,	22-Dec-1981
;		1) Modified EXIT_HANDLER so it will wait for stopped processes
;		   to return before continuing.  Included a timer to prevent
;		   permanent hangs.
;		2) Added a repeated Control-C handler to "eat up" extra Control-
;		   C's.
;		3) Changed required privilege from GROUP to WORLD to insure we
;		   can stop detached processes.
;		4) Changed where the PID flag is set in the PROCESS_INFO data
;		   structure to include it where AST's are disabled.
;		5) Changed servity of the Control-C message to be consistent.
;		6) Changed the RSB's in PARSE_RCRD to BRW END_PARSE_RCRD to
;		   be consistent.
;		7) Raise base priority of TSTCNTRL one higher when stopping 
;		   processes so it is not competing with detached processes.
;
;	V03-001	RNH0001		Richard N. Holstein,	15-Sep-1981
;		Include explicit ENQLM when creating processes.
;
;**

	.SBTTL	Declarations

; INCLUDE FILES:

; MACROS:

	$SSDEF					; for system services
	$DCDEF					; for device characteristics
	$JPIDEF					; for GETJPI system service
	$PQLDEF					; for CREPRC system service
	$CHFDEF					; Condition handler frame definitions
	$DIBDEF					; Device Information Block
	$SHRDEF					; Shared messages
	$STSDEF					; Status return
	$ACCDEF					; accounting messages
	$PRVDEF					; privilege offset values

; EQUATED SYMBOLS:

;   Facility number definitions:
	TCNTRL_K = 116				; define the facility code
	RMS_K = 1

;   SHR message definitions:
	TCNTRL = TCNTRL_K@STS$V_FAC_NO		; Define the TCNTRL facility code
;
	TCNTRL$_ABENDD   = TCNTRL!SHR$_ABENDD	; Define the TCNTRL message codes
	TCNTRL$_ABORT    = TCNTRL!SS$_ABORT
	TCNTRL$_CONTROLC = TCNTRL!SS$_CONTROLC
	TCNTRL$_BEGIND   = TCNTRL!SHR$_BEGIND
	TCNTRL$_ENDEDD   = TCNTRL!SHR$_ENDEDD
	TCNTRL$_OPENIN   = TCNTRL!SHR$_OPENIN
	TCNTRL$_TEXT     = TCNTRL!SHR$_TEXT

; set up definitions

; first set up field bit positions in FLAG
	
						;  DESCRIPTION  -- INITIALIZATION
	EOF_FLGV       = 0			; end-of-file --          0
	FRST_TIME_FLGV = 1			; first time flag --      1
	STRT_MORE_FLGV = 2			; start more flag --      1
	DELLOG_FLGV    = 3			; delete log file flag -- 1
	REPORT_FLGV    = 4			; long or short report -- 1 (long)
	WRAP_FLGV      = 5			; wrap around flag --     1
	FILE_FLGV      = 6			; is there a file spec? -- 1
	RUN_ALONE_FLGV = 7			; the process runs by itself -- 0
	STRT_AGN_FLGV  = 8			; start from begin of file? -- 0
	WRT_MSG_FLGV   = 9			; do we write the message -- 1
	COMMENTS_FLGV  = 10			; do we print comments --  0
	WAKE_FLGV      = 11			; do we wake from hiber -- 0
	SET_LOGNAM_FLGV= 12			; is a log file name set -- 0
	PRINT_ERR_FLGV = 13			; do we print error messages? -- 1
	TIM_SET_FLGV   = 14			; is the timer currently set? -- 0
	TERMINAL_FLGV  = 15			; are we running from a TTY? -- 0

; and set up corresponding mask

	EOF_FLGM       = 1@EOF_FLGV
	FRST_TIME_FLGM = 1@FRST_TIME_FLGV	
	STRT_MORE_FLGM = 1@STRT_MORE_FLGV
	DELLOG_FLGM    = 1@DELLOG_FLGV
	REPORT_FLGM    = 1@REPORT_FLGV
	WRAP_FLGM      = 1@WRAP_FLGV
	FILE_FLGM      = 1@FILE_FLGV
	RUN_ALONE_FLGM = 1@RUN_ALONE_FLGV
	STRT_AGN_FLGM  = 1@STRT_AGN_FLGV
	WRT_MSG_FLGM   = 1@WRT_MSG_FLGV
	COMMENTS_FLGM  = 1@COMMENTS_FLGV
	WAKE_FLGM      = 1@WAKE_FLGV
	SET_LOGNAM_FLGM= 1@SET_LOGNAM_FLGV
	PRINT_ERR_FLGM = 1@PRINT_ERR_FLGV
	TIM_SET_FLGM   = 1@TIM_SET_FLGV
	TERMINAL_FLGM  = 1@TERMINAL_FLGV

; define returns from PARSE routine

	EOF = 1					; end-of-file
	COM = 2					; comment
	FIL = 3    				; file 
	ASG = 4					; assignment
	ERR = 5					; error

; define the maximum number of processes which can run concurrently

	MAX_PROC = 1000
	PCKT_SIZ = 20				; size of process packet

	; set up offsets for the Packet data structure
	PCKT$L_PID  = 0				; offset of the PID
	PCKT$T_NAM  = 4				; offset of the filespec name
	PCKT$L_ID   = 13			; offset of the file ID#
	PCKT$B_FLAG = 17			; offset of the flag byte
	PCKT$W_CHAN = 18			; offset for mailbox channel

; define bit fields in process flag

	PID_FLGV = 0				; this is set if 1st lngwrd is PID

; and corresponding mask

	PID_FLGM = 1@PID_FLGV

; misc. assignments
	
	TEXT_BUFFER  =  132			; size of output text strings
	LARGE_BUFFER =  256			; size of large output strings
	NAME_SIZE    =    9			; max size of a filename
	MAILBOX_SIZE =   84			; size of AST mailbox
	PAGE         =  512			; size of a page

	NO_AUTH = 6
	NO_AUTH_FLG = 1@NO_AUTH			; says we don't go thru the UAF

	; define event flags for exit_handler

	QIO_EVNT_FLG    = 8			; to wait for the QIO
	ABORT_EVNT_FLG  = 9			; for time-out
	EVNT_FLG_MSK    = ^X00000300		; QIO_EVNT_FLG ! ABORT_EVNT_FLG
 

	.SBTTL	Read-Only Data
	.PSECT	RODATA,NOEXE,NOWRT,PAGE


CNTRLCMSG:
	.ASCID	\Aborted via a user CTRL/C.\

; logical name descriptors

DELLOG_DESC:
	.ASCID  /DELLOG/

FILNAM_DESC:
	.ASCID  /FILNAM/

PARCNT_DESC:
	.ASCID  /PARCNT/

REPORT_DESC:
	.ASCID  /REPORT/

COM_IMAGE:
	.ASCID  /SYS$SYSTEM:LOGINOUT.EXE/	; image name for com file

NULL_FIL:
	.ASCII /].;/				; match string for null filename

; data area for assign routine. to add new assignment, put address of string
;  descriptor of keyword in ASGN_VEC and keyword descriptor in that address

ASGN_VEC:	
	.ADDRESS ASG_NAM
	.ADDRESS ASG_START
	.ADDRESS ASG_STOP
	.ADDRESS ASG_COM
	.ADDRESS ASG_LOG
	.ADDRESS ASG_TIME
	ASG_CNT = <<. - ASGN_VEC>/4>		; # of possible assignments
	.ADDRESS ASG_TMP1
	.ADDRESS ASG_TMP2			; for furthur enhancement

; list of string descriptors for assignments

ASG_NAM:
	.ASCID /NAME/
ASG_START:
	.ASCID /START/
ASG_STOP:
	.ASCID /STOP/
ASG_COM:
	.ASCID /COMMENTS/
ASG_LOG:
	.ASCID /LOG/
ASG_TIME:
	.ASCID /MAXTIME/
ASG_TMP1:
	.ASCID /      /
ASG_TMP2:
	.ASCID /      /				; for furthur enhancement

	; 256 byte block for the SPANC instruction

SPAN_TABLE:
	.REPEAT	33
	.BYTE 	1				; mask is one for non-print chars
	.ENDR
	.REPEAT 94
	.BYTE	0				; mask is zero for printable chars
	.ENDR
	.REPEAT 129
	.BYTE	1				; mask is one for the rest
	.ENDR

; space for $GETJPI to get the quotas of the parent process

QUOTA_LIS:
	.WORD 4
	.WORD JPI$_ASTLM
	.ADDRESS ASTLM
	.LONG 0
	.WORD 4
	.WORD JPI$_BIOLM
	.ADDRESS BIOLM
	.LONG 0
	.WORD 4
	.WORD JPI$_BYTLM
	.ADDRESS BYTLM
	.LONG 0
	.WORD 4
	.WORD JPI$_CPULIM
	.ADDRESS CPULM
	.LONG 0
	.WORD 4
	.WORD JPI$_DIOLM
	.ADDRESS DIOLM
	.LONG 0
	.WORD 4
	.WORD JPI$_ENQLM
	.ADDRESS ENQLM
	.LONG 0
	.WORD 4
	.WORD JPI$_FILLM
	.ADDRESS FILLM
	.LONG 0
	.WORD 4
	.WORD JPI$_PGFLQUOTA
	.ADDRESS PGFLQUOTA
	.LONG 0
	.WORD 4
	.WORD JPI$_PRCLM
	.ADDRESS PRCLM
	.LONG 0
	.WORD 4
	.WORD JPI$_TQLM
	.ADDRESS TQELM
	.LONG 0
	.WORD 4
	.WORD JPI$_WSQUOTA
	.ADDRESS WSQUOTA
	.LONG 0
	.WORD 4
	.WORD JPI$_PRIB
	.ADDRESS BASPRI
	.LONG 0
	.LONG 0

; error messages

FILNAM_ERR:
	.ASCID /FILNAM invalid or not found./

DELLOG_ERR:
	.ASCID /Invalid DELLOG, default used./

REPORT_ERR:
	.ASCID /Invalid REPORT, default used./

RCRD_ERR:
	.ASCID \Error with record -- !/ !AD \

OPN_TMP_ERR:
	.ASCID /There was an error opening the temporary log file. The message is --/

CON_TMP_ERR:
	.ASCID /There was an error connecting the temporary log file. The message is -/

CLS_TMP_ERR:
	.ASCID /There was an error closing the temporary log file. The message is _/

ERS_TMP_ERR:
	.ASCID /There was an error erasing the temporary log file. The message is -/

ERS_TCOM_ERR:
	.ASCID /There was an error erasing the temporary .COM file. The message is -/

GET_TMP_ERR:
	.ASCID /There was an error getting from the temporary log file. The message is -/

PUT_PERM_ERR:
	.ASCID /There was an error writing to the permanent log file. The message is -/

IN_CON_ERR:
	.ASCID / !AS was not able to be converted into an integer./

OUT_CON_ERR:
	.ASCID / !UL was not able to be converted into a text string./

BAD_SYM:
	.ASCID \ /!AS/ is an invalid symbol in this field.\

FILSPC_ERR:
	.ASCID /Error in filespec, using no filespec./

KEYWRD_ERR:
	.ASCID /No keyword in record./

DATSTRUC_ERR:
	.ASCID /Internal data structure corrupted, returned process not found./

BAD_STATUS:
	.ASCID/The process - !AS- returned a non-success message of:/

BAD_EXT:
	.ASCID /Invalid file extension./

BAD_FNM:
	.ASCID /Invalid file name./

NO_CRT_PRC:
	.ASCID \The process -!AS- was unable to be created,!/  the error message is\

CASE_ERR:
	.ASCID /Went through case statement, internal program error./

TIME_OUT_ERR:
	.ASCID /Maximum time exceeded.  The following processes were remaining:/

NO_SET_TIM:
	.ASCID /Maximum timer is already set, unable to change it./

FILE:	
	.ASCID /file/				; fills in RMS_ERR_STRING

RECORD:
	.ASCID /record/				; fills in RMS_ERR_STRING

RMS_ERR_STRING:					; announces an RMS error
	.ASCID /RMS !AS error in file !AD/

ZERO_PARCNT:
	.ASCID /PARCNT is less than, or equal to zero, TSTCNTRL stopped./

BAD_DELIM:
	.ASCID /Unbalanced delimiters in parameter string, record skipped./

NO_SET_LOG:
	.ASCID /Unable to change log file name, assignment skipped./


TTNAME_ROPTR:
	.WORD 63,0				; descriptor for recursive
	.ADDRESS TTNAME				;   translation of TTNAME

CNTRLC_MSK:					; mask which holds ASCII code for
	.LONG 0					;  the CNTRL-C
	.LONG ^X0008

	.SBTTL	Read/Write Data
	.PSECT	RWDATA,WRT,NOEXE,PAGE


; set up space to hold the values

PROCESS_CNT:
	.LONG 0					; # of active detached processes

NUMBER_FILES:
	.LONG 0 				; total # of detached processes

PROCESS_LIMIT:					; PARCNT, limit of active
	.LONG 1					;   detached processes

NUMBER_LIMIT:				 	; PARCNT, limit of total 
	.LONG 0					;   detached processes

FLAG:
	.LONG ^X227E				; holds all bit flags

PRIV_MSK:
	.QUAD 0					; quadword to hold privileges

; descriptor areas for logical names

FILE_DESC:					; descriptor for translated FILNAM
FILE_SIZE:	
	.LONG LARGE_BUFFER
FILE_ADDR:
	.LONG FILE_NAM
FILE_NAM:
	.BLKB LARGE_BUFFER

LOGNAM_DESC:					; desc for other logical names
LOGNAM_SIZE:
	.LONG LARGE_BUFFER
LOGNAM_ADDR:
	.LONG LOGNAM_STR
LOGNAM_STR:
	.BLKB LARGE_BUFFER

DATA_RCRD:
	.BLKB TEXT_BUFFER			; buffer to hold input record

STR_LEN:
	.WORD 0					; size of data record w/ filename

MBX_CHAN:
	.WORD 0					; channel # of termination mailbox

TERM_BUFF:
	.BLKB MAILBOX_SIZE			; buffer to hold mailbox

PARAM_DLIMIT:
	.BYTE 0					; holds parameter delimiter char.

PARAM_DESC:					; descriptor for parameter string
	.LONG PAGE
	.ADDRESS PARAM_STR

COM_PARAM_DESC:					; descriptor for command file params
	.LONG PAGE+1
	.ADDRESS COM_PARAM_STR

;+++
; the following must remain contiguous

COM_PARAM_STR:
	.ASCII / /				; add a leading blank

PARAM_STR:
	.BLKB PAGE
;---


TTNAME_RWPTR:
	.WORD TTNAME_LEN,0			; descriptor for recursive
	.ADDRESS TTNAME				;  translation of TTNAME

TTNAME:
	.ASCII /SYS$COMMAND/
	TTNAME_LEN = .-TTNAME
	.BLKB  63-TTNAME_LEN


LOG_FIL_DESC:					; desc. for perm. log  file name
	.LONG 11
	.ADDRESS LOG_FIL_STR

LOG_FIL_STR:
	.ASCII /TSTCNTRL.LOG/			; default name
	.BLKB NAME_SIZE				; room for more

MSG_BLOCK:
	.BLKB 4					; hold $GETMSG info


; descriptors for start and stop sentinels

START_DESC:
	.LONG START_STR_LEN			; fill in with default
	.ADDRESS START_STR

START_STR:
	.ASCII /BEGIN/
	START_STR_LEN = .-START_STR
	.BLKB TEXT_BUFFER			; extra space if needed


STOP_DESC:
	.LONG STOP_STR_LEN			; fill in with default
	.ADDRESS STOP_STR

STOP_STR:
	.ASCII /ENDED/
	STOP_STR_LEN = .-STOP_STR
	.BLKB TEXT_BUFFER			; extra space if needed


COM_DESC:					; buffer to print out comments
	.LONG TEXT_BUFFER
	.ADDRESS COM_STR

COM_STR:
	.BLKB TEXT_BUFFER

 
GETCHN_DESC:
	.LONG DIB$K_LENGTH
	.ADDRESS GETCHN_BUF


GETCHN_BUF:
	.BLKB DIB$K_LENGTH			; buffer to hold get channel info


MBX_UNIT:
	.WORD 0					; hold the mailbox unit number

;++
; This area is for the $CREPRC parameter list.  It gets changed by the 
;  Create Process Subroutine.  The default values are the ones shown.
;--

CREPRC_LIS:
	.LONG 12				; number of parameters
PIDADR:
	.LONG 0
IMAGE:
	.LONG 0
INPUT:
	.LONG 0
OUTPUT:
	.LONG 0
ERROR:
	.LONG 0
PRVADR:
	.LONG 0
QUOTA:
	.ADDRESS QUOTA_TABLE				; use same quota's as parent
PRCNAM:
	.LONG 0
BASPRI:
	.LONG 2
UIC:
	.LONG 0
MBXUNT:
	.LONG 0
STSFLG:
	.LONG 0

; table to hold results of $GETJPI of the quota's of the parent process
;  to be used for $CREPRC

QUOTA_TABLE:
	.BYTE PQL$_ASTLM
ASTLM:
	.LONG 6
	.BYTE PQL$_BIOLM
BIOLM:
	.LONG 6
	.BYTE PQL$_BYTLM
BYTLM:
	.LONG 8192
	.BYTE PQL$_CPULM
CPULM:
	.LONG 0
	.BYTE PQL$_DIOLM
DIOLM:
	.LONG 6
	.BYTE PQL$_ENQLM
ENQLM:
	.LONG 50
	.BYTE PQL$_FILLM
FILLM:
	.LONG 10
	.BYTE PQL$_PGFLQUOTA
PGFLQUOTA:
	.LONG 2048
	.BYTE PQL$_PRCLM
PRCLM:
	.LONG 8
	.BYTE PQL$_TQELM
TQELM:
	.LONG 8
	.BYTE PQL$_WSDEFAULT
WSDEFAULT:
	.LONG 100
	.BYTE PQL$_WSQUOTA
WSQUOTA:
	.LONG 120
	.BYTE PQL$_LISTEND

;++
; Now make a buffer to hold information regarding the detached processes.
;  Each packet is large enough to hold MAX_PROC number of processes and 
;  it will have the following format --
;
;	+-----------------------------------------------------------------+
;	|          |                    |      ID       |	|         |
;	|  PID     |  FILE NAME         | (# FILES)     | FLAG	|  CHAN   |
;	+-----------------------------------------------------------------+
;         4 BYTES  |      9 BYTES       |    4 BYTES    |1 BYTE	| 2 BYTES |
;
;  which gives a total of 20 bytes/process created.
;   
; When a packet is not being used, the first long word will hold the address
;  of the next free packet.  The last free packet will hold zero.  A pointer,
;  FREE_PKT, points to the first available packet.
;
;--

FREE_PKT:
	.ADDRESS PROCESS_INFO			; pointer to first free packet

PROCESS_INFO:
	.BLKB MAX_PROC * PCKT_SIZ		; buffer as described above

; area for expiration timer and related items
	
TIMER_DESC:					; holds the ASCII time string
	.LONG  7
	.ADDRESS  TIMER_STR

;++
; the following must remain contiguous

TIMER_STR:
	.ASCII /0 /				; number of days

TIMER_HOURS:
	.ASCII /00/				; number of hours
	.ASCII /:/				; required syntax

TIMER_MINS:
	.ASCII /00/				; number of minutes


TIMER_DELT:
	.QUAD 0					; holds converted delta time

HUNG_PROC_DESC:					; temporary descriptor to hold
	.LONG NAME_SIZE				;   name of hung process

HUNG_PROC_ADDR:
	.LONG 0					; put addr. from PCKT structure here
;--

STOP_TIM_DESC:					; timer for thirty seconds
	.ASCID /0 00:00:30/

STOP_TIME:	; watchdog timer for stopping the detached processes
	.QUAD 0					; wait for thirty seconds

ABORT_IOSB:	; IOSB to hold status of QIOW for mailbox after abort a process
	.QUAD 0

PROC_TERM_IOSB:		; IOSB to hold status of QIO for a terminated process
	.QUAD 0

COMMENT_DESC:					; descriptor for command line
	.LONG 0
	.ADDRESS COM_SPEC

IMAGE_DESC:					; descriptor for process 
	.BLKL 1					;   to be created
	.ADDRESS FILE_SPEC

COM_SPEC:					; leader for command line
	.ASCII /$ @/

FILE_SPEC:
	.BLKB LARGE_BUFFER			; holds filespec after $PARSE

FILNAM_BUF:
	.BLKB NAME_SIZE				; holds only the filename

TEMP_COM_DESC:					; descriptor for temporary 
	.LONG 13				;   command file
	.ADDRESS TMP_COM_STR

ID_DESC:					; desc. to hold # of detached proc
	.LONG 4					; ID is 4 bytes long
	.ADDRESS ID_STR				
;+++
; the following string must remain contiguous

TMP_COM_STR:					; temporary command file name
	.ASCII /TCNTL/

ID_STR:
	.BLKB 4

	.ASCII /.TMP/				; rest of temporary command file name
;---

TEMP_NAM_DESC:					; hold process name for detached
	.LONG 14			
	.ADDRESS TEMP_NAM_STR
;+++
; the following string must remain contiguous

TEMP_NAM_STR:
	.BLKB NAME_SIZE				; filename goes here
	.ASCII /_/				; then underscore
ID_BUFF:
	.BLKB 4					; then the ID number
;---

TEMP_LOG_DESC:
	.LONG 13				; hold the name of the
	.ADDRESS TEMP_LOG_STR			;  logfile for SYS$OUTPUT

TEMP_LOG_STR:
	.BLKB NAME_SIZE				; holds the file name and #
	.ASCII /.LOG/				;  with a .LOG extension

GETUIC:
	.WORD 4					; buffer for UIC from $GETJPI
	.WORD JPI$_UIC				; code for UIC
	.ADDRESS UIC_CODE			; put it in this address
	.LONG 0					; not used here
	.WORD 15				; size for process name
	.WORD JPI$_PRCNAM			; get user process name
	.ADDRESS PRCNAMSTR			; put it here
	.ADDRESS PRCNAMDESC			; put size in descriptor
	.LONG 0					; terminate block

UIC_CODE:
	.LONG 0					; holds current UIC

PRCNAMDESC:					; descriptor for user process name
	.LONG 0
	.ADDRESS PRCNAMSTR
PRCNAMSTR:
	.BLKB 15

EXIT_DESC:					; Exit handler descriptor
	.LONG	0
	.ADDRESS EXIT_HANDLER
	.LONG	1
	.ADDRESS STATUS

STATUS:
	.LONG 0					; status on exit

ARG_COUNT:					; Arg. counter used by ERROR_EXIT
	.LONG	0

AST_MODE:					; hold previous mode of AST
	.LONG  0

SS_FAIL_MODE:					; hold previous mode of SS failure
	.LONG  0

; read/write area for termination AST

TRMNTN_PID:
	.LONG 0					; PID of terminated process


TRMNTN_COM_DESC:				; descriptor to delete temporary
	.LONG 13				;  command file
	.ADDRESS TRMNTN_COM_STR

TRMNTN_ID_DESC:
	.LONG 4					; put termination ID string
	.ADDRESS TRMNTN_ID_STR

;+++
; the following string must remain contiguous

TRMNTN_COM_STR:
	.ASCII /TCNTL/				; temporary command file name

TRMNTN_ID_STR:
	.BLKB 4

	.ASCII /.TMP/				; rest of temporary command file name
;---

LOG_DESC:	
	.LONG 0					; descriptor to hold log file record
	.ADDRESS LOG_RCRD

LOG_RCRD:
	.BLKB LARGE_BUFFER


TEMP_BUFF_DESC:
	.WORD TEXT_BUFFER,0			; temp buffer to hold capitalized
	.ADDRESS TEMP_BUFF_STR			; record to check for END sentenial

TEMP_BUFF_STR:
	.BLKB LARGE_BUFFER


TRMNTN_FIL_DESC:				; descriptor for terminated file name
	.LONG 0	
	.ADDRESS TRMNTN_FIL_STR


TRMNTN_FIL_STR:
	.BLKB 9


TRMNTN_LOG_STR: 
	.BLKB 9					; name of terminated log file
	.ASCII  /.LOG/


PRC_NAM_DESC:
	.LONG 8					; holds process name of TSTCNTRL
	.ADDRESS PRC_NAM_STR

PRC_NAM_STR:
	.ASCII /TSTCNTRL/			; default process name
	.BLKB 7					; space for a different name


RTN_NAM_DESC:					; descriptor for the 
	.LONG 14
	.ADDRESS RTN_NAM_STR			;  returned process name
;+++
; the following must remain contiguous

RTN_NAM_STR:
	.BLKB  9 
	.ASCII /_/
RTN_ID:	.BLKB  4
;---

; for error messages
RCRD_ERR_DESC:
	.WORD LARGE_BUFFER+TEXT_BUFFER,0
	.ADDRESS RCRD_ERR_STR
RCRD_ERR_INP:
	.WORD LARGE_BUFFER+TEXT_BUFFER,0
	.ADDRESS RCRD_ERR_STR
RCRD_ERR_STR:
	.BLKB LARGE_BUFFER+TEXT_BUFFER

SYM_DESC:
	.LONG 1
	.ADDRESS SYM_STR
SYM_STR:
	.BLKB 1

FAO_BUF:					; FAO output string descriptor
	.WORD TEXT_BUFFER,0
	.ADDRESS BUFFER
BUFFER_PTR:					; fake buffer for misc. strings
	.WORD TEXT_BUFFER,0
	.ADDRESS BUFFER
BUFFER:						; FAO output buffer
	.BLKB TEXT_BUFFER

GETMSG_DESC:					; descriptor for $GETMSG string
	.WORD TEXT_BUFFER,0
	.ADDRESS GETMSG_BUF
GETMSG_PTR:
	.WORD TEXT_BUFFER,0
	.ADDRESS GETMSG_BUF
GETMSG_BUF:
	.BLKB TEXT_BUFFER

TTCHAN:
	.LONG 0					; channel associated w/ contrl. terminal


	.SBTTL	RMS-32 Data Structures
	.ALIGN	LONG

FILE_FAB:	
	$FAB -					; FAB for the data file
	 FNA = FILE_NAM,-
	 ORG = <SEQ>,-				; sequential file only
	 MRS = 132,-
	 RFM = VAR				; allow variable records

FILE_RAB:
	$RAB -					; RAB for the data file records
	 FAB = FILE_FAB,-
	 UBF = DATA_RCRD,-			; put get record here
	 USZ = 132

PARSE_FAB:					; psuedo FAB to parse the filename
	$FAB -
	 FNA = DATA_RCRD+4, -			; starting address of filespec
	 NAM = PARSE_NAM

PARSE_NAM:					; NAM block for parsing record
	$NAM -
	 ESA = FILE_SPEC,-			; buffer for file spec
	 ESS = 63				; and size

TMP_LOG_FAB:
	$FAB -					; FAB for temporary log files
	 ORG = <SEQ>,-				; FNA & FNS will be done dynamically
	 MRS = LARGE_BUFFER,-
	 RFM = VAR

TMP_LOG_RAB:
	$RAB -
	 FAB = TMP_LOG_FAB,-
	 UBF = LOG_RCRD,-
	 USZ = LARGE_BUFFER

CNTRL_LOG_FAB:
	$FAB - 					; FAB for perm log file
	 FNA = LOG_FIL_STR,-			; holds the name
	 FNS = 13,-				; holds the default size
	 ORG = <SEQ>,-
	 MRS = LARGE_BUFFER,-
	 RFM = VAR,-
	 RAT = <CR>

CNTRL_LOG_RAB:
	$RAB -					; RBF & RSZ fields will be 
	 FAB = CNTRL_LOG_FAB			;  inserted dynamically

COM_FAB:
	$FAB -					; FAB for temporary file used to 
	 FNA = TMP_COM_STR,-			;  start up .COM files with parameters
	 FNS = 13,-
	 ORG = <SEQ>,-
	 MRS = LARGE_BUFFER,-
	 RFM = VAR

COM_RAB:
	$RAB -					; RAB for .COM file with parameters
	 FAB = COM_FAB				; RBF and RSZ will be inserted dynamically

DEL_COM_FAB:					; FAB to erase temp. command files
	$FAB -
	 ORG = <SEQ>,-
	 MRS = LARGE_BUFFER,-
	 RFM = VAR


	.SBTTL	Main Program
;++
; FUNCTIONAL DESCRIPTION:
;
;	This is the main routine of the TSTCNTRL, it will determine what 
;	the input record is and take appropiate action according to what
;	the record is.
;
; CALLING SEQUENCE:
;
;	None
;
; INPUT PARAMETERS:
;
; 	The logical names: FILNAM, PARCNT, DELLOG, and REPORT.  The ASCII
;	data file -- FILNAM.
;
; IMPLICIT INPUTS:
;
;	None
;
; OUTPUT PARAMETERS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	None
;
; COMPLETION CODES:
;
; 	The final status of the TSTCNTRL is sent to EXIT_HANDLER by the
;	longword STATUS.
;
; SIDE EFFECTS:
;
;	Leaves a log file called TSTCNTRL.LOG, may leave other log files
;	if DELLOG is false.
;
;--
	.PSECT	TSTCNTRL,EXE,NOWRT,PAGE

	.DEFAULT DISPLACEMENT,WORD

.ENTRY TSTCNTRL,^M<>				; Entry mask

	MOVAL	SSERROR,(FP)			; Declare exception handler
	$SETSFM_S ENBFLG = #1			; Enable system service failure mode
	$DCLEXH_S DESBLK = EXIT_DESC		; Declare an exit handler


	INSV	#1,#PRV$V_SETPRI,#1,PRIV_MSK	; raise priority to stop procs. faster
	INSV	#1,#PRV$V_WORLD,#1,PRIV_MSK	; need world in order to stop processes
	INSV	#1,#PRV$V_DETACH,#1,PRIV_MSK	; set mask for detach privilege
	$SETPRV_S ENBFLG = #1,-			; Get the detached privilege
		  PRVADR = PRIV_MSK

10$:	; find out the name of the controlling terminal
	$TRNLOG_S LOGNAM = TTNAME_RWPTR,-
		  RSLLEN = TTNAME_RWPTR,-	; Recursively translate the name
		  RSLBUF = TTNAME_ROPTR		;  of our controlling terminal
	MOVAL	TTNAME,TTNAME_RWPTR+4		; Undo possible previous PPF fixup
	CMPL	R0,#SS$_NOTRAN			; have we reached the end yet?
	BEQL	20$				; yes, so get out
	CMPW	#^X001B,TTNAME			; is this a Process Permanent File
	BNEQ	10$				; recursively translate if not
	SUBW	#4,TTNAME_RWPTR			; remove RMS overhead from PPF name
	ADDL2	#4,TTNAME_RWPTR+4
	BRB	10$				; continue

20$:	; set up for control c's
	$ASSIGN_S DEVNAM = TTNAME_RWPTR,-
		  CHAN   = TTCHAN
	$GETCHN_S CHAN   = TTCHAN,-		; use getchan to see if we have a tty
		  PRIBUF = GETCHN_DESC
	MOVAL	GETCHN_BUF,R2			; starting addr of getchn buffer
	CMPB	#DC$_TERM,DIB$B_DEVCLASS(R2)	; is device a terminal?
	BNEQ	30$				; no, so don't enable CNTRL/C
	BISL2	#TERMINAL_FLGM,FLAG		; we are running from a TTY, set flag
	$QIOW_S	  CHAN   = TTCHAN,-		; enable for CNTRL/C's
		  FUNC   = #IO$_SETMODE!IO$M_CTRLCAST,-
		  P1     = CCASTHAND

30$:	$CREMBX_S CHAN = MBX_CHAN,-		; create termination mailbox
		  MAXMSG = #MAILBOX_SIZE,-	; message from process
		  BUFQUO = <#MAILBOX_SIZE*10>	; enough room for 10 messages
	$QIO_S    CHAN = MBX_CHAN,-		; do a read to mailbox
		  FUNC = #IO$_READVBLK,-
		  ASTADR = PROC_TERM,-		; on read, goto process termination
		  IOSB = PROC_TERM_IOSB,-
		  P1 = TERM_BUFF,-
		  P2 = #MAILBOX_SIZE

	$GETCHN_S CHAN = MBX_CHAN,-		; want unit # of mailbox
		  PRIBUF = GETCHN_DESC
	MOVAL	 GETCHN_BUF, R2			; get starting addr of getchan 
	MOVW	 DIB$W_UNIT(R2), MBX_UNIT	; get the unit #

	MULL3	 #PCKT_SIZ,#MAX_PROC,R2		; get the number of bytes of buff
	MOVC5	 #0,PROCESS_INFO,#0,-		; zero out process info buffer
		 R2,PROCESS_INFO

; now initialize the pointers of free packets in PROCESS_INFO

	MOVL	#1,R2				; initialize the counter
	MOVL 	FREE_PKT,R3			; get the address of a free packet
50$:	ADDL3 	#PCKT_SIZ,R3,(R3)		; put next packet addr in this one
	MOVL 	(R3),R3				; adjust the addr of packet
	AOBLSS	#MAX_PROC,R2,50$		; do this for whole buffer
	MOVL 	#0,(R3)				; put sentinel in last one

; now get the UIC of the TSTCNTRL program

	$GETJPI_S ITMLST = GETUIC,-		; all we want is the UIC
		  EFN	 = #1
	$WAITFR_S EFN = #1			; wait till this is done

; now get the quotas and base priority of the parent process
	
	$GETJPI_S ITMLST = QUOTA_LIS,-		; all quotas and priority
		  EFN    = #1
	$WAITFR_S EFN = #1			; wait till this is done

; translate all logical names

	$TRNLOG_S LOGNAM = FILNAM_DESC,-	; translate FILNAM
		  RSLLEN = FILE_SIZE,-
		  RSLBUF = FILE_DESC

	CMPL 	R0,#SS$_NOTRAN			; was it translated?
	BNEQ	100$				; yes, continue

;****PRINT ERROR FOR NOTRANSLATION****
	MOVL	#SS$_NOTRAN!STS$K_SEVERE,R2	; get the error code
	BICL2	#^X0001,R2			; make it a non-success message

	PUSHAL	FILNAM_ERR
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_ERROR
	PUSHL	R2				; the modified error
	MOVL	(SP),STATUS
	PUSHL	#4
	BRW 	ERROR_EXIT			; severe get out

100$:	$FAB_STORE FAB = FILE_FAB,-
		   FNS = FILE_SIZE		; put size of filename in FAB

	$TRNLOG_S LOGNAM = PARCNT_DESC,-	; translate PARCNT
		  RSLLEN = LOGNAM_SIZE,-
		  RSLBUF = LOGNAM_DESC
	CMPL 	R0,#SS$_NOTRAN			; was it translated?
	BNEQ	200$				; yes, continue

	BRB	300$				; no translation, use default (1)

200$:	; convert the string into a number
	PUSHAL	PROCESS_LIMIT			; place for converted number
	PUSHAL	LOGNAM_DESC			; string to be converted
	CALLS 	#2,G^OTS$CVT_TI_L		; convert text to longword
	CMPL	R0,#OTS$_INPCONERR		; did it work right?
	BNEQ	300$				; yes, continue

;****PRINT ERROR FOR CONVERSION****
	$FAO_S	CTRSTR = IN_CON_ERR,-
		OUTLEN = FAO_BUF,-
		OUTBUF = BUFFER_PTR,-
		P1     = #LOGNAM_DESC
	PUSHAL	FAO_BUF
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_SEVERE
	MOVL	(SP),STATUS
	PUSHL	#3
	BRW 	ERROR_EXIT			; severe get out

300$:
	CMPL	PROCESS_LIMIT,#0		; is PARCNT <= 0?
	BGTR	310$				; no, continue
	PUSHAL	ZERO_PARCNT			; yes, print error message
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_INFO
	CALLS	#3,G^LIB$SIGNAL
	BRW	END_TCNTRL			; get out
310$:
	MOVL 	#64,LOGNAM_SIZE			; reset size field
	MOVL	PROCESS_LIMIT,NUMBER_LIMIT 	; initialize number_limit
	$TRNLOG_S LOGNAM = DELLOG_DESC,-	; translate DELLOG
		  RSLLEN = LOGNAM_SIZE,-
	  	  RSLBUF = LOGNAM_DESC
	CMPL 	R0,#SS$_NOTRAN			; was it there?
	BEQL	500$				; no -- use default
	BICW2	#^X20,LOGNAM_STR		; change first letter to cap
	CMPB	LOGNAM_STR,#^A/N/		; was dellog no?
	BNEQ	400$				; no, check again
	BICL2	#DELLOG_FLGM,FLAG		; yes, change flag
	BRB	500$

400$:	CMPB	LOGNAM_STR,#^A/Y/		; is dellog yes?
	BEQL	500$				; yes, change nothing

;****PRINT ERROR FOR WRONG INPUT, DEFAULT USED  ; no, error, use default
	PUSHAL	DELLOG_ERR
	PUSHL	#1
	PUSHL 	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#3,G^LIB$SIGNAL

500$:	MOVL 	#64,LOGNAM_SIZE			; reset size field
	$TRNLOG_S LOGNAM = REPORT_DESC,-	; translate REPORT
		  RSLLEN = LOGNAM_SIZE,-
	 	  RSLBUF = LOGNAM_DESC
	CMPL	R0, #SS$_NOTRAN			; was it there?
	BEQL 	OPEN_FILE			; no, use default
	BICW2	#^X20,LOGNAM_STR		; change first letter to cap
	CMPB	LOGNAM_STR,#^A/S/		; was report short?
	BNEQ 	600$				; no, check again
	BICL2	#REPORT_FLGM,FLAG		; yes, change flag
	BRB	OPEN_FILE

600$:	CMPB	LOGNAM_STR,#^A/L/		; is report long?
	BEQL	OPEN_FILE			; yes, change nothing

;****ERROR FOR WRONG INPUT, DEFAULT USED****	; no, error, default used
	PUSHAL	REPORT_ERR
	PUSHL	#1
	PUSHL 	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#3,G^LIB$SIGNAL

OPEN_FILE:
	MOVAL	FILE_RAB,R11			; keep RAB in R11
	$OPEN	FAB = @RAB$L_FAB(R11),-		; open the data file
		ERR = RMS_ERR

	$CONNECT RAB = R11,-			; connect the file stream
		 ERR = RMS_ERR

10$:	$GET	RAB = R11,-			; get a record
		ERR = RMS_ERR
	MOVZWL	RAB$W_RSZ(R11),R4		; get the size of the record
	BBS	#EOF_FLGV,FLAG,13$		; if EOF, don't do SPAN
	SPANC	R4,DATA_RCRD,SPAN_TABLE,#01	; look for printable characters
	BEQL	10$				; if none, get another line

13$:	$FAO_S	CTRSTR = RCRD_ERR,-		; FAO in case of error
		OUTLEN = RCRD_ERR_DESC,-
		OUTBUF = RCRD_ERR_INP,-
		P1     = R4,-
		P2     = #DATA_RCRD

	BSBW	PARSE_RCRD			; parse the record
	MOVL 	R0,R10				; put results in more permanent reg
	CMPL	R10,#ASG			; do we have an assignment?
	BEQL	15$				; yes, continue
	BRW	STRT_MSG			; no, start without it
15$:	BSBW	ASSIGN				; yes, do assignment

20$:	$GET	RAB = R11,-			; get a record
		ERR = RMS_ERR
	MOVZWL	RAB$W_RSZ(R11),R4		; get the size of the record
	BBS	#EOF_FLGV,FLAG,25$		; if EOF, then don't do SPAN
	SPANC	R4,DATA_RCRD,SPAN_TABLE,#01	; look for printable characters
	BEQL	20$				; if none, get another line

	$FAO_S	CTRSTR = RCRD_ERR,-		; FAO in case of error
		OUTLEN = RCRD_ERR_DESC,-
		OUTBUF = RCRD_ERR_INP,-
		P1     = R4,-
		P2     = #DATA_RCRD

25$:	BSBW	PARSE_RCRD			; parse the record
	MOVL 	R0,R10				; put results in more permanent reg
	CMPL	R10,#ASG			; do we have an assignment?
	BNEQ	STRT_MSG			; no, start without it
	BSBW	ASSIGN				; yes, do assignment

30$:	$GET	RAB = R11,-			; get another record
		ERR = RMS_ERR		
	MOVZWL	RAB$W_RSZ(R11),R4		; get size of rcrd
	BBS	#EOF_FLGV,FLAG,40$		; if EOF, don't do SPAN
	SPANC	R4,DATA_RCRD,SPAN_TABLE,#01	; look for printable characters
	BEQL	30$				; if none, get another line

	$FAO_S	CTRSTR = RCRD_ERR,-		; FAO in case of error
		OUTLEN = RCRD_ERR_DESC,-
		OUTBUF = RCRD_ERR_INP,-
		P1     = R4,-
		P2     = #DATA_RCRD

40$:	BSBW	PARSE_RCRD			; parse it
	MOVL	R0,R10

STRT_MSG:
	MOVAL 	CNTRL_LOG_RAB,R7		; RAB for main log file
	BISL2	#SET_LOGNAM_FLGM,FLAG		; cannot change the logfile name
	$CREATE FAB = @RAB$L_FAB(R7),-		; make the file
		ERR = RMS_ERR
	$CONNECT RAB = R7,-			; establish a stream
		 ERR = RMS_ERR
	$SETPRN_S  PRCNAM = PRC_NAM_DESC	; set default of process name

;****PRINT STARTING MESSAGE AND SET PROCESS NAME****
	CLRL	-(SP)
	PUSHAL	PRC_NAM_DESC
	PUSHL	#2
	PUSHL	#TCNTRL$_BEGIND!STS$K_INFO
	CALLS	#4,G^LIB$SIGNAL

MAIN_LOOP:
	BBS	#STRT_MORE_FLGV,FLAG,10$	; more processes, so continue
	BRW	END_MAIN			; no, get out of loop

10$:	CASEB	R10,#1,#5			; case results of PARSE_RCRD
15$:	.WORD	EOF_BLK - 15$
	.WORD	COM_BLK - 15$
	.WORD	FIL_BLK - 15$
	.WORD 	ASG_BLK - 15$
	.WORD 	ERR_BLK - 15$
;****PRINT ERROR, WENT THRU CASE WITH NO MATCH****
	PUSHAL 	CASE_ERR
	PUSHL 	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_SEVERE
	MOVL	(SP),STATUS
	PUSHL	#3
	BRW	ERROR_EXIT			; severe, get out

EOF_BLK:
	;++
	; the end-of-file indicator was set by last read, we want to test
	; the following boolean expression to see if we are to rewind FILNAM
	;  if WRAP & (NUMBER_FILES < NUMBER_LIMIT) & ~FIRST_TIME_FLAG, then
	;  rewind
	;--

	CMPL	NUMBER_FILES,NUMBER_LIMIT	; is #files<#limit?
	BGEQ	ALL_DONE			; no, expression is false
	BBC	#WRAP_FLGV,FLAG,ALL_DONE	; WRAP is false, expr is false
	BBS	#FRST_TIME_FLGV,FLAG,ALL_DONE	; 1st time true, expr is false
	$REWIND	RAB = R11,-			; if here, then expression is true
		ERR = RMS_ERR			; so rewind FILNAM
	BICL2	#EOF_FLGM,FLAG			; clear EOF flag
	BISL2	#STRT_AGN_FLGM,FLAG		; and lets start over
	BICL2	#PRINT_ERR_FLGM,FLAG		; wrapping enabled, don't print mesg
	BRW	CONTIN_MAIN			; continue

ALL_DONE:
	BICL2 	#STRT_MORE_FLGM,FLAG		; set start more to false
	BRW	CONTIN_MAIN

COM_BLK:	
	; a comment was found, ...
	BRW	CONTIN_MAIN			;...skip it

FIL_BLK:
	; we found a filename, create a detached process
	; but first check first byte of record for Y or N

	CMPB	DATA_RCRD,#^A/N/		; is it a no?
	BNEQ	5$				; no, continue
	BRW	END_FIL				; yes, skip it
5$:	CMPB	DATA_RCRD,#^A/Y/		; is it a yes?
	BEQL	10$				; yes, continue

;****PRINT ERROR,INVALID SYMBOL IN FIELD****
	BBC	#PRINT_ERR_FLGV,FLAG,7$		; skip message if wrapping
	MOVB	DATA_RCRD,SYM_STR
	$FAO_S	CTRSTR = BAD_SYM,-
		OUTLEN = FAO_BUF,-
		OUTBUF = BUFFER_PTR,-
		P1     = #SYM_DESC
	PUSHAL	RCRD_ERR_DESC
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_INFO
	PUSHAL	FAO_BUF
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#6,G^LIB$SIGNAL
7$:	BRW	END_FIL

10$:	; we can start a detached process
	BICL2 	#FRST_TIME_FLGM,FLAG		; turn off first time flag
	CMPB	DATA_RCRD+2,#^A/N/		; is 3rd byte no?
	BEQL	RUNS_ALONE			; yes, it runs alone
	CMPB	DATA_RCRD+2,#^A/Y/		; is byte yes?
	BEQL 	20$				; yes, it runs w/ others

;****PRINT ERROR,INVALID SYMBOL IN FIELD****
	BBC	#PRINT_ERR_FLGV,FLAG, 15$	; skip message if wrapping
	MOVB	DATA_RCRD+2,SYM_STR
	$FAO_S	CTRSTR = BAD_SYM,-
		OUTLEN = FAO_BUF,-
		OUTBUF = BUFFER_PTR,-
		P1     = #SYM_DESC
	PUSHAL	RCRD_ERR_DESC
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_INFO
	PUSHAL	FAO_BUF
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#6,G^LIB$SIGNAL
15$:	BRW	END_FIL

20$:	BRW 	MULTI_RUNS			; can run asychronous, so do it

RUNS_ALONE:
	; process runs alone
	BICL2	#WRAP_FLGM,FLAG			; turn wrap to alone
	BISL2	#RUN_ALONE_FLGM,FLAG		; tell AST that this runs alone
	
	$SETAST_S ENBFLG = #0			; turn off any AST's
	CMPL	#0,PROCESS_CNT			; are any processes running?
	BEQL	10$				; no, so don't sleep
	BISL2	#WAKE_FLGM,FLAG			; try and wake now
	$SETAST_S ENBFLG = #1			; yes, wait till done
	$HIBER_S				; wait for PROCESS_CNT = 0
10$:	$SETAST_S ENBFLG = #1			; make sure AST is set

	BBC	#FILE_FLGV,FLAG,NO_NAME		; no filenam so skip creating

	; now goto subroutine to create the detached process
	BISL2	#WAKE_FLGM,FLAG			; enable WAKE incase we go to HIBER
	BSBW	CREATE_PROC
	CMPL	R0,#SS$_NORMAL			; did it work right
	BEQL	30$				; yes, so continue
	CMPL	R0,#-1				; did we get error before creating
	BNEQ	20$				; no, so keep checking
	BRW	END_FIL				; yes, so skip the record
20$:	BRB	NO_CREAT			; otherwise, error with creating

30$:	BISL2	#WAKE_FLGM,FLAG			; try and wake now
	$HIBER_S				; wait for process cnt = 0

NO_NAME:
	BRW	END_FIL				; no name, skip record

NO_CREAT:	; for some reason process wasn't created, print a warning
	MOVL	R0,STATUS			; retain the error code
	$FAO_S 	CTRSTR = NO_CRT_PRC,-
		OUTLEN = FAO_BUF,-
		OUTBUF = BUFFER_PTR,-
		P1     = #TEMP_NAM_DESC

	PUSHL	STATUS				; use this error code to ...
	CALLS	#1,CHK_ERR 			; ... see if any FAO arguments

	CMPL	#-1,R0				; do we have an FAO descriptor?
	BNEQ	10$				; no, then we have a status code

	PUSHL	R1				; send the descriptor address ...
	PUSHL	#1				; ... and the error message
	PUSHAL	FAO_BUF
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#5,G^LIB$SIGNAL
	BRW	END_FIL

10$:	PUSHL	R1				; send the status code
	PUSHAL	FAO_BUF				; and the error message
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#4,G^LIB$SIGNAL
	BRW	END_FIL				; try again


MULTI_RUNS:	; file can run with other files
	BICL2	#RUN_ALONE_FLGM,FLAG		; tell AST that this runs w/ others
	$SETAST_S  ENBFLG = #0			; turn off AST's
	CMPL	PROCESS_CNT,PROCESS_LIMIT	; can we start one?
	BLSS	10$				; yes, do it
	BISL2	#WAKE_FLGM,FLAG			; try and wake now
	$SETAST_S  ENBFLG = #1			; no, turn on AST's and wait
	$HIBER_S				; no, wait till we can

10$:	$SETAST_S  ENBFLG = #1			; make sure AST is on
	BBC	#FILE_FLGV,FLAG,NO_NAME2	; no filename, skip create

	; now goto subroutine to create the detached process
	BICL2	#WAKE_FLGM,FLAG			; don't wake until HIBER
	BSBW	CREATE_PROC
	CMPL	R0,#SS$_NORMAL			; did it work right
	BNEQ	20$				; no, why
	BRW	END_FIL				; yes, continue
20$:	CMPL	R0,#-1				; did we get error before creating
	BNEQ	NO_CREAT2			; no,  error WITH creating
	BRW	END_FIL				; yes, so skip the record
	
NO_NAME2:

	;****PRINT ERROR WITH FILENAME, SKIPPED RECORD****
	BBC	#PRINT_ERR_FLGV,FLAG, 10$	; skip message if wrapping
	PUSHAL	RCRD_ERR_DESC
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_INFO
	PUSHAL 	BAD_FNM
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#6,G^LIB$SIGNAL
10$:	BRW	END_FIL

NO_CREAT2:	; for some reason process wasn't created, print a warning
	MOVL	R0,STATUS			; retain the error code
	$FAO_S 	CTRSTR = NO_CRT_PRC,-
		OUTLEN = FAO_BUF,-
		OUTBUF = BUFFER_PTR,-
		P1     = #TEMP_NAM_DESC

	PUSHL	STATUS				; use this error code to ...
	CALLS	#1,CHK_ERR 			; ... see if any FAO arguments

	CMPL	#-1,R0				; do we have an FAO descriptor?
	BNEQ	10$				; no, then we have a status code

	PUSHL	R1				; send the descriptor address ...
	PUSHL	#1				; ... and the error message
	PUSHAL	FAO_BUF
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#5,G^LIB$SIGNAL
	INCL	NUMBER_FILES			; assume we're running a process
						;  so any loops will eventually stop	BRW	END_FIL

10$:	PUSHL	R1				; send the status code
	PUSHAL	FAO_BUF
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#4,G^LIB$SIGNAL
	INCL	NUMBER_FILES			; assume we're running a process
						;  so any loops will eventually stop
	BRW	END_FIL				; try again

END_FIL:
	BRW	CONTIN_MAIN			; continue with main loop


ASG_BLK:
	; we have an assignment, try and do it
	BSBW	ASSIGN				; do assignment
	BRW	CONTIN_MAIN			; and continue with main loop


ERR_BLK:
	; there is an error in the record, skip that record

;****PRINT ERROR IN RECORD, SKIPPED RECORD****
	BBC	#PRINT_ERR_FLGV,FLAG, 10$
	PUSHAL	RCRD_ERR_DESC
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS 	#3,G^LIB$SIGNAL
10$:	BRW 	CONTIN_MAIN

CONTIN_MAIN:
	; see if we are to continue
	BBC	#STRT_MORE_FLGV,FLAG,END_MAIN	; start more is off, time to stop
	BBC	#WRAP_FLGV,FLAG,10$		; running sychronously, so continue
	BBC	#STRT_AGN_FLGV,FLAG,10$		; not wrapping, so continue
	CMPL	NUMBER_FILES,NUMBER_LIMIT	; did we run all we're supposed to?
	BLSS	10$				; no, keep going
	BICL2	#STRT_MORE_FLGM,FLAG		; get out of loop
	BRB	END_MAIN

10$:	; get another record
	$GET	RAB = R11,-
		ERR = RMS_ERR			; get record
	MOVZWL	RAB$W_RSZ(R11),R4		; get size of string
	BBS	#EOF_FLGV,FLAG,20$		; if EOF, then don't do SPAN
	SPANC	R4,DATA_RCRD,SPAN_TABLE,#01	; look for printable characters
	BEQL	10$				; if none, get another line

	$FAO_S	CTRSTR = RCRD_ERR,-		; FAO in case of error
		OUTLEN = RCRD_ERR_DESC,-
		OUTBUF = RCRD_ERR_INP,-
		P1     = R4,-
		P2     = #DATA_RCRD

20$:	BSBW	PARSE_RCRD			; parse the record
	MOVL	R0,R10				; put results in perm regr
	BRW	MAIN_LOOP			; continue loop


END_MAIN:
	; clean up
	$CLOSE	FAB = @RAB$L_FAB(R11),-		; close data file
		ERR = RMS_ERR

	BISL2	#RUN_ALONE_FLGM,FLAG		; tell AST to signal when process cnt=0
	$SETAST_S  ENBFLG = #0  		; turn off any AST's
	CMPL	#0,PROCESS_CNT			; are there any processes running?
	BEQL	10$				; no, so all done
	BISL2	#WAKE_FLGM,FLAG			; try and wake now
	$SETAST_S  ENBFLG = #1			; turn AST's on
	$HIBER_S				; wait till then
10$:	$SETAST_S  ENBFLG = #1			; make sure AST's are on

	; print ending time stamp
	PUSHL	#0
	PUSHAL	PRC_NAM_DESC
	PUSHL	#2
	PUSHL	#TCNTRL$_ENDEDD!STS$K_INFO
	CALLS	#4,G^LIB$SIGNAL

	$CLOSE	FAB = @RAB$L_FAB(R7),-		; close the perm log file
		ERR = RMS_ERR

END_TCNTRL:
	MOVL	#SS$_NORMAL,STATUS		; clean exit
	$EXIT_S	 STATUS				; all done

	.SBTTL  Create Process Subroutine
;++
; FUNCTIONAL DESCRIPTION:
;
;	This subroutine will take the file spec from DATA_RCRD and from
;	it make a process name and a temp. log file name.  It insures that
;	all previous temp log files of the same name are deleted, and then
;	creates a detached process of either a .COM or .EXE file.	
;
; CALLING SEQUENCE:
;
;	This routine is called from the main procedure when it has reached
;	a point to create a detached process.
;	via:  BSBW CREATE_PROC
;	
; INPUT PARAMETERS:
;
;	None
;
; IMPLICIT INPUTS:
;
;	The file spec to be created is in buffer DATA_RCRD.
;	The ID# passed by NUMBER_FILES
;
; OUTPUT PARAMETERS:
;
;	Completion code in R0
;	
; IMPLICIT OUTPUTS:
;
;	None
;
; COMPLETION CODES:
;	
;	If the detached process was successfully created, then R0 holds
;	SS$_NORMAL.
;	If there was an error before the process had a chance to be created,
;	then R0 holds minus one (-1).
;	And if the process tried to be created and failed, then R0 holds
;	the falure code of $CREPRC.
;
; SIDE EFFECTS:
;	NONE
;--

CREATE_PROC:
	;start to create the detached process, first let's make the process name
	; get the local id #

	PUSHL	#4				; four ascii digits
	PUSHAQ	ID_DESC				; where converted string goes
	PUSHAL	NUMBER_FILES			; number to convert
	CALLS	#3,G^OTS$CVT_L_TI		; convert number to text
	CMPL 	R0,#OTS$_OUTCONERR		; work right?
	BNEQ	10$				; yes, continue

;****PRINT ERROR FOR CONVERSION****
	$FAO_S	CTRSTR = OUT_CON_ERR,-
		OUTLEN = FAO_BUF,-
		OUTBUF = BUFFER_PTR,-
		P1     = #NUMBER_FILES
	PUSHAL	FAO_BUF
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_ERROR
	MOVL	(SP),STATUS
	PUSHL	#3
	BRW 	ERROR_EXIT			; severe get out

10$:	MOVC3	#4,ID_STR,ID_BUFF		; pad id w/ _ and blank

; now concatenate this with filename, add leading blanks if required

	MOVL	RAB$L_CTX(R11),R3		; get size of filename
	SUBL3   R3,#9,R4			; number of blanks needed
	BEQL	25$				; no blanks are needed
	CLRL	R2
20$:	MOVB	#^A/ /,TEMP_NAM_STR(R2)		; put blanks in
	AOBLSS	R4,R2,20$			; all of them in?
25$:	MOVC3	RAB$L_CTX(R11),FILNAM_BUF,-
		TEMP_NAM_STR(R2)		; we now have full process name

; now set up descriptor for the log file

	CMPW	RAB$L_CTX(R11),#5		; is size of filespec .GE. 5?
	BGEQ	30$				; yes, handle differently
	ADDW3	#8,RAB$L_CTX(R11),R3		; get size of completed spec
	MOVW	R3,TEMP_LOG_DESC		; & put it in descriptor
	SUBW3	RAB$L_CTX(R11),#5,R3		; difference in starting address
	ADDL3	R3,#TEMP_LOG_STR,R4		; R4 now holds new address
	MOVL	R4,TEMP_LOG_DESC+4		; put it in the descriptor
	MOVC3	RAB$L_CTX(R11),FILNAM_BUF,-
		@<TEMP_LOG_DESC+4>		; put the filename in
	BRB	40$				; finish up

30$:	; filespec is at least 5 characters
	MOVW	#13,TEMP_LOG_DESC		; put size in
	MOVAL	TEMP_LOG_STR,TEMP_LOG_DESC+4	; put addr in
	MOVC3	#5,FILNAM_BUF,TEMP_LOG_STR	; put 1st five char in
40$:	MOVC3	#4,ID_STR,TEMP_LOG_STR+5	; concatenate with ID #

	MOVL	FREE_PKT,R2			; get addr of a free packet
	MOVL	(R2),FREE_PKT			; put new addr into free packet

; finally ready to create detached process

	; now fill in the data packet, it starts at R2 and the PID will 
	;  be put there
	
	MOVL 	R2,R8				; perm regr for the $CREPRC
	MOVC3	#NAME_SIZE,TEMP_NAM_STR,-	; put filename there, front 
		 PCKT$T_NAM(R8)			;   padded with blanks
	MOVL	NUMBER_FILES,PCKT$L_ID(R8)	; put ID # in

; before creating a process, delete any left-over log files
	$FAB_STORE  FAB = TMP_LOG_FAB,-		; put in the name of current log file
		    FNA = TEMP_LOG_STR,-
		    FNS = TEMP_LOG_DESC
	$ERASE	    FAB = TMP_LOG_FAB		; erase the log file

60$:	; set up parameter list for $CREPRC
	MOVAL	PCKT$L_PID(R8),PIDADR		; get the PID
	MOVAQ	TEMP_LOG_DESC,OUTPUT		; and what SYS$OUTPUT is
	MOVAQ	TEMP_NAM_DESC,PRCNAM		; and the process name
	MOVL	UIC_CODE,UIC			; and the UIC
	MOVZWL	MBX_UNIT,MBXUNT			; don't forget the mailbox

; first is it a .COM or a .EXE file, R9 has the address of the period
	MOVW	#-1,PCKT$W_CHAN(R8)		; put invalid chan # in, if no params
	MOVL	R9,R2				; don't hurt R9
	INCL	R2				; now R2 points to the first char
	BICL2	#^X20,(R2)			; change to cap
	CMPB	(R2),#^A/C/			; is it a .COM?
	BEQL	COM_FIL				; yes, do it!
	CMPB	(R2),#^A/E/			; is it a .EXE
	BNEQ	65$				; no, error
	BRW	EXE_FIL				; yes, do it!

;****PRINT SEVERE ERROR, INVALID FILE EXTENSION
65$:
	BBC	#PRINT_ERR_FLGV,FLAG, 80$	; skip message if wrapping
	PUSHAL	RCRD_ERR_DESC
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_INFO
	PUSHAL	BAD_EXT
	PUSHL 	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#6,G^LIB$SIGNAL
80$:	MOVL 	#-1,STATUS			; keep error temp. in STATUS
	BRW	END_CREATE

COM_FIL:	
	; create a detached procss for com file
	; first set up parameters for command file
	MOVAQ	COM_IMAGE,IMAGE			; run under LOGINOUT
	MOVL	#NO_AUTH_FLG,STSFLG		; and bypass UAF

	CMPL	PARAM_DESC,#0			; are there any parameters?
	BNEQ	10$				; yes, do them
	BRW	25$				; no, work the easy way

10$:	; set up the record to handle .COM files with parameters by using
	;  COMMENT_DESC, concatenating a hyphen and a blank to the end of 
	;  file spec and letting the size of COMMENT_DESC <-- IMAGE_DESC + 5

	MOVL 	IMAGE_DESC,R2			; get size of complete file spec
	ADDL2	#FILE_SPEC,R2			; R2 holds address of first byte
						;  after file spec
	ADDL3	#1,PARAM_DESC,COM_PARAM_DESC	; adjust size to include blank
	MOVW	#^A/- /,(R2)			; put a hyphen and blank with spec
	ADDL3	IMAGE_DESC,#5,COMMENT_DESC	; adjust COMMENT_DESC to new size
	$CREATE	   FAB = COM_FAB,-		; create the temporary command file
		   ERR = RMS_ERR
	$CONNECT   RAB = COM_RAB,-		; connect the stream
		   ERR = RMS_ERR
	$RAB_STORE RAB = COM_RAB,-
		   RSZ = COMMENT_DESC,-		; store the file spec we are going 
		   RBF = COM_SPEC		;  to use
	$PUT	   RAB = COM_RAB,-		; write that record
	  	   ERR = RMS_ERR
	$RAB_STORE RAB = COM_RAB,-
		   RSZ = COM_PARAM_DESC,-	; store info of the parameters we
		   RBF = COM_PARAM_STR		;  wish to use
	$PUT	   RAB = COM_RAB,-		; write that record
	 	   ERR = RMS_ERR
	$CLOSE	   FAB = COM_FAB,-		; close the file
		   ERR = RMS_ERR

	; now create the process
	$SETSFM_S  ENBFLG = #0			; catch this error by hand
	$SETAST_S  ENBFLG = #0			; turn off AST's

	; set up remaining parameters . . .
	BISB2	#PID_FLGM,PCKT$B_FLAG(R8)	; say that this is PID
	MOVAQ	TEMP_COM_DESC,INPUT		; input is temp command file
	$CREPRC_G  CREPRC_LIS			; . . . and create the process

	MOVL	R0,STATUS			; put code in STATUS to save it
	CMPL	R0,#SS$_NORMAL			; was the process created?
	BEQL	20$
	BRW	END_CREATE			; no, return with error
20$:	BRW 	INC_COUNT			; started process, increment counter


25$:	; no parameters if here
	$SETSFM_S  ENBFLG = #0			; catch this error by hand
	$SETAST_S  ENBFLG = #0			; turn off AST's

	; set up remaining parameters for $CREPRC . . .
	BISB2	#PID_FLGM,PCKT$B_FLAG(R8)	; say that this is PID
	MOVAQ	IMAGE_DESC,INPUT		; run with .COM as input
	$CREPRC_G  CREPRC_LIS			; . . . and create the process

	MOVL	R0,STATUS			; put code in STATUS to save it
	CMPL	R0,#SS$_NORMAL			; was the process created?
	BEQL	30$
	BRW	END_CREATE			; no, return with error
30$:	BRW 	INC_COUNT			; started process, increment counter

EXE_FIL:
	;create a detached process for exe file
	; first set up parameters for .EXE files
	MOVAQ	IMAGE_DESC,IMAGE		; run the image
	MOVL	#0,STSFLG			; clear the status flag

	CMPL 	PARAM_DESC,#0			; if no parameters, 
	BEQL	20$				; then don't send SYS$INPUT
	$SETAST_S  ENBFLG = #0			; turn off AST's
	$CREMBX_S  CHAN   = PCKT$W_CHAN(R8),-	; make mailbox for parameters
		   BUFQUO = PARAM_DESC,-	; only as large as needed
		   LOGNAM = TEMP_NAM_DESC	; called the same as process name
	$QIOW_S	   CHAN = PCKT$W_CHAN(R8),-	; put string in mailbox
		   FUNC = #IO$_WRITEVBLK!IO$M_NOW,-  ; do IO now!
		   P1   = PARAM_STR,-		; buffer of the string
		   P2   = PARAM_DESC		; size of the string

	$SETSFM_S  ENBFLG = #0			; catch this error by hand

	; this has parameters, so send input
	BISB2	#PID_FLGM,PCKT$B_FLAG(R8)	; say that this is PID
	MOVAQ	TEMP_NAM_DESC,INPUT		; input is parameter mailbox
	$CREPRC_G  CREPRC_LIS			; and create the process

	MOVL	R0,STATUS			; put code in STATUS to save it
	CMPL	R0,#SS$_NORMAL			; was the process created?
	BEQL	10$				; yes, then continue
	BRW	END_CREATE			; no, exit with error
10$:	BRW	INC_COUNT			; started process, incr. counter

20$:	; no parameters, so don't send SYS$INPUT
	$SETSFM_S  ENBFLG = #0			; catch this error by hand
	$SETAST_S  ENBFLG = #0			; turn off AST's

	BISB2	#PID_FLGM,PCKT$B_FLAG(R8)	; say that this is PID
	MOVL	#0,INPUT			; no input
	$CREPRC_G  CREPRC_LIS			; create the process

	MOVL	R0,STATUS			; put code in STATUS to save it
	CMPL	R0,#SS$_NORMAL			; was the process created?
	BNEQ	END_CREATE			; no, exit with error

INC_COUNT:
	$SETSFM_S  ENBFLG = #1			; turn error catch back on
	INCL 	NUMBER_FILES			; one more file started
	INCL	PROCESS_CNT			; and one running

	; print the begin time stamp for detached process
	BICL2	#WRT_MSG_FLGM,FLAG		; write only if long
	CLRL	-(SP)				; set up for begin time stamp
	PUSHAL	TEMP_NAM_DESC
	PUSHL	#2
	PUSHL	#TCNTRL$_BEGIND!STS$K_INFO
	CALLS	#4,G^LIB$SIGNAL

	;print out the comments?
	BBC	#COMMENTS_FLGV,FLAG,END_CREATE	; no comments wanted
	BICL2	#WRT_MSG_FLGM,FLAG		; write only if long
	PUSHAL	COM_DESC
	PUSHL	#1
	PUSHL  	#TCNTRL$_TEXT!STS$K_INFO
	CALLS	#3,G^LIB$SIGNAL			; print comment

END_CREATE:
	$SETAST_S  ENBFLG = #1			; get any AST's	
	$SETSFM_S  ENBFLG = #1			; make sure failure mode is on
	MOVL	STATUS,R0			; return completion code
	RSB					; return with status in R0

	.SBTTL  Parse Record Subroutine
;++
; FUNCTIONAL DESCRIPTION:
;
;	This subroutine parses a record to determine whether it is a 
;	comment, an assignment, a filespec, an end-of-file, or an error.
;
; CALLING SEQUENCE:
;
;	This is called by TSTCNTRL main routine to parse a newly inputed
;	record.
;	via: BSBW PARSE_RCRD
;
; INPUT PARAMETERS:
;
;	None
;
; IMPLICIT INPUTS:
;
;	The current record is in buffer DATA_RCRD.
;
; OUTPUT PARAMETERS:
;
;	The results of the parse is returned as a numeric value in R0.
;
; IMPLICIT OUTPUTS:
;
;	R9 holds the address of a period in the file spec if one is found.
;	STR_LEN holds length of record without comment.
;	COM_DESC holds the comment of the record.
;	The RAB CTX field holds the size of the filename.
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;
;	Registers R1, R2, R4, R5, R6 R8 may be modified.
;
;--

PARSE_RCRD:
	; first see if end-of-file
	BBC	#EOF_FLGV,FLAG,10$		; not EOF, so continue
	MOVL	#EOF,R0				; is EOF, so return EOF
	BRW	END_PARSE_RCRD			; exit

10$:	; check for comment
	CMPB 	DATA_RCRD,#^A/!/		; is first byte a comment?
	BNEQ	20$				; no, continue
	MOVL	#COM,R0				; yes, return COM
	BRW	END_PARSE_RCRD			; exit

20$:	; check for a filename by checking byte 2 for a blank
	CMPB	DATA_RCRD+1,#^A/ /		; if a blank, then a filename
	BNEQ	30$				; no filename
	BRB	CHCK_SYNTAX			; filename, check its syntax

30$:	; look for assignment	
	LOCC	#^A/!/,RAB$W_RSZ(R11),-
		DATA_RCRD			; find comment, if any
	SUBW3	R0,RAB$W_RSZ(R11),STR_LEN	; STR_LEN holds length w/out com.
	LOCC	#^A/=/,STR_LEN,DATA_RCRD	; now search for equal sign
	BEQL	40$				; didn't find one
	MOVL 	#ASG,R0				; found it, return ASG
	BRW	END_PARSE_RCRD			; exit

40$:	; if here, then didn't find anything -- so error
	MOVL 	#ERR,R0				; return ERR
	BRW	END_PARSE_RCRD			; exit

CHCK_SYNTAX:
	; this will look at the filename and insure that it is 
	;  of proper syntax

	MOVW	RAB$W_RSZ(R11),STR_LEN		; get the length
	LOCC	#^A/!/,STR_LEN,DATA_RCRD	; find where comment starts
	SUBW2	R0,STR_LEN			; take comment out of string length
	
	; now put comment in buffer for output
	MOVL	R0,COM_DESC			; put the size in
	MOVC3	R0,(R1),COM_STR			; and put the comment there
; see if a file spec
	CMPW	STR_LEN,#4			; see if just a return
	BGTR	10$				; no, continue
	BICL2	#FILE_FLGM,FLAG			; yes, set no file spec
	MOVL 	#FIL,R0				; return FIL
	BRW	END_PARSE_RCRD			; exit

10$:	SUBW3	#4,STR_LEN,R2			; make length to be just "file spec"
	PUSHL	R2				; save the length of file spec
	SCANC	R2,DATA_RCRD+4,SPAN_TABLE,#01	; find end of file spec
	MOVL	(SP)+,R2			; pop length of file spec into r2
	MOVL	R1,R8				; R8 is address of blank after file spec
	SUBW2	R0,R2				; R2 is size without parameters
	MOVAL	PARSE_FAB,R5			; get FAB address
	$FAB_STORE FAB = R5,-
		   FNS = R2			; put size of "file spec" in FAB
	$PARSE	   FAB = R5

	CMPL	FAB$L_STS(R5),#RMS$_NORMAL	; did it parse OK?
	BEQL	20$				; yes, continue
	BICL2	#FILE_FLGM, FLAG		; no, set no file-spec

;****PRINT ERROR IN FILESPEC, USING NO FILESPEC****
	BBC	#PRINT_ERR_FLGV,FLAG, 15$	; skip message if wrapping
	PUSHAL	RCRD_ERR_DESC
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_INFO
	PUSHAL	FILSPC_ERR
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#6,G^LIB$SIGNAL

15$:	MOVL	#FIL,R0				; return FIL
	BRW	END_PARSE_RCRD			; exit

20$:	; we made it through PARSE, but may have a null filename
	; check for that by looking in the results of PARSE  for
	; a ].;

	MOVAL	PARSE_NAM,R4			; get nam block addr
	MOVZBL	NAM$B_ESL(R4),R6		; get the size of spec
	MATCHC	#3,NULL_FIL,R6,FILE_SPEC	; is there a null file name
	BNEQ	30$				; no, real filename, continue
	BICL2	#FILE_FLGM,FLAG			; yes, so no filename
	MOVL	#FIL,R0	        		; return FIL
	BRW	END_PARSE_RCRD			; exit

30$:
	; at this time a complete filespec is in FILE_SPEC.
	; extract just the filname from complete spec and put the size
	; of it in the CTX field of the RAB

	BISL2	#FILE_FLGM,FLAG			; we do have a filespec
	MOVL	R6,IMAGE_DESC			; put size in descriptor block
	LOCC	#^A/]/,R6,FILE_SPEC		; find where spec begins
	MOVL	R1,R5				; save where we found it
	ADDL2	#1,R5				; point to first character
	LOCC	#^A/;/,R6,FILE_SPEC		; find end of file extension
	SUBL2	#4,R1				; move pointer to what may be period
	LOCC 	#^A/./,#4,(R1)			; find just where period is
	MOVL	R1,R9				; save location in perm regr
	SUBL3	R5,R1,R4			; find size of filename
	MOVL 	R4,RAB$L_CTX(R11)		; put the size in CTX field
	MOVC3	R4,(R5),FILNAM_BUF		; put filename in its buffer
	
	; now parse away the parameter text, and put it in its buffer.
	; The location of the beginning of the "text" (though there may be
	; leading blanks) is in R8.
	
	; find length of parameter field
	SUBL3	#DATA_RCRD,R8,R2		; R2 is length from beginning of 
						;   string to beginning of parameter
	SUBW3	R2,STR_LEN,R2			; now R2 is length of parameter string
	CLRL	PARAM_DESC			; clear size of descriptor
	SPANC	R2,(R8),SPAN_TABLE,#01		; skip all non-printable characters
	BEQL	50$				; no parameters, so continue
	MOVL	R0,R4				; save the remaining length of string
	MOVB	(R1),PARAM_DLIMIT		; get the delimiter
	ADDL3	R1,#1,R3			; point to next char in string
	DECL	R4				; take the delim away from length
	LOCC	PARAM_DLIMIT,R4,(R3)		; find the end delimiter
	BNEQ	40$				; find delimiter O.K.?

; print error, unbalanced delimiters
	BBC	#PRINT_ERR_FLGV,FLAG, 35$	; skip message if wrapping
	BICL2	#FILE_FLGM, FLAG		;  set no file spec
	PUSHAL	RCRD_ERR_DESC
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_INFO
	PUSHAL	BAD_DELIM
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#6,G^LIB$SIGNAL

35$:	MOVL	#FIL,R0				; return file
	BRW	END_PARSE_RCRD			; exit

40$:	SUBL3	R3,R1,R2			; R2 is length of param. string 
	MOVL	R2,PARAM_DESC			; put size in descriptor
	MOVC3	R2,(R3),PARAM_STR		; put text in

50$:
	BISL2 	#FILE_FLGM,FLAG			; set filespec flag
	MOVL	#FIL,R0				; return FIL

END_PARSE_RCRD:					; exit
	RSB

	.SBTTL Assignment Expression Subroutine
;++
; FUNCTIONAL DESCRIPTION:
;
;	This subroutine determines if the keyword in an assignment statement
;	is valid or not.  If it is valid, the proper assignment then takes
;	place.
;
; CALLING SEQUENCE:
;
;	This is called from the main routine when an ASG value is returned 
;	by PARSE_RCRD by BSBW ASSIGN
;
; INPUT PARAMETERS:
;
;	None
;
; IMPLICIT INPUTS:
;
;	The record which contains the assignment is in DATA_RCRD.
;	STR_LEN is length of record without comment.
;
; OUTPUT PARAMETERS:
;
;	None
;
; IMPLICIT OUTPUTS:
;	
;	None
;
; COMPLETION CODES:
;	
;	None
;
; SIDE EFFECTS:
;	
;	Registers R0,R1,R2,R3,R4,R5,R6,R8 may be modified.
;	PROC_DESC, START_DESC, and STOP_DESC may be modified.
;
;--

ASSIGN:
	; find out what assignment is
	; parse the keyword out of DATA_RCRD, keyword must be in first col.
	LOCC	#^A/=/,STR_LEN,DATA_RCRD	; find the equal sign
	MOVZWL	R0,R5				; save the size remaining
	MOVZWL	R1,R6				; and the addr or =
	SCANC	STR_LEN,DATA_RCRD,SPAN_TABLE,#01 ; find non-printable character
	CMPL	R0,R5				; what came first, blank of =?
	BGTR	10$				; if branch, then blank was first
	SUBL3	R5,STR_LEN,R8			; R8 holds size of keyword
	BRB	20$				; now find it
10$:	SUBL3	R0,STR_LEN,R8			; R8 holds size of keyword
20$:	MOVL	#0,R4				; offset of ASG_VEC
30$:	MULL3	R4,#4,R2			; displacement off ASG_VEC
	ADDL3	#4,ASGN_VEC(R2),R3		; R3 is addr of addr of string
	MOVL	(R3),R3				; it is now addr of string
	MATCHC	R8,DATA_RCRD,@ASGN_VEC(R2),(R3)	; is keyword in record?
	BNEQ	40$				; no,try again
	
; found a keyword. now try and find the start of the assignment

	INCL	R6				; skip over the equal sign
	DECL	R5				; size is now one shorter
	SPANC	R5,(R6),SPAN_TABLE,#01		; find start of assign value
	BRB	50$				; do assignment

40$:	INCL	R4				; do next keyword
	CMPL	R4,#ASG_CNT			; are we done?
	BNEQ	30$				; no, keep trying

;****PRINT ERROR, KEYWORD NOT FOUND, SKIPPED RECORD****
	BBC	#PRINT_ERR_FLGV,FLAG,45$	; skip message if wrap
	PUSHAL	RCRD_ERR_DESC
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_INFO
	PUSHAL	KEYWRD_ERR
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#6,G^LIB$SIGNAL

45$:	BRW	END_ASG

50$:	CASEB	R4,#0,#ASG_CNT-1		; goto proper routine
60$:	.WORD	NAME_ASG  - 60$
	.WORD	START_ASG - 60$
	.WORD	STOP_ASG  - 60$
	.WORD	COM_ASG   - 60$
	.WORD	LOG_ASG   - 60$
	.WORD	TIM_ASG   - 60$
;****PRINT ERROR, WENT THRU CASE WITH NO MATCH****
	PUSHAL 	CASE_ERR
	PUSHL 	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_SEVERE
	MOVL	(SP),STATUS
	PUSHL	#3
	BRW	ERROR_EXIT			; severe, get out

NAME_ASG:
	; R1 holds addr of start of new process name & R0 holds # chars left
	PUSHL	R1				; put addr on stack
	SCANC	R0,(R1),SPAN_TABLE,#01		; find end of asg
	MOVL	(SP)+,R3			; pop addr into R3
	SUBL3	R3,R1,R2			; this is size of string
	MOVL	R2,PRC_NAM_DESC			; put size in descriptor
	MOVC3	R2,(R3),PRC_NAM_STR		; put in new name
	$SETPRN_S  PRCNAM = PRC_NAM_DESC	; set the process name
	BRW	END_ASG

START_ASG:
	; R1 holds addr of start of new process name & R0 holds # chars left
	PUSHL	R1				; put addr on stack
	SCANC	R0,(R1),SPAN_TABLE,#01		; find end of asg
	MOVL	(SP)+,R3			; pop addr into R3
	SUBL3	R3,R1,R2			; this is size of string
	MOVL	R2,START_DESC			; put size in descriptor
	MOVC3	R2,(R3),START_STR		; put in new name
	PUSHAQ	START_DESC			; convert the sentinal to 
	PUSHAQ	START_DESC			;   upper case
	CALLS	#2,G^STR$UPCASE
	BRW	END_ASG

STOP_ASG:
	; R1 holds addr of start of new process name & R0 holds # chars left
	PUSHL	R1				; put addr on stack
	SCANC	R0,(R1),SPAN_TABLE,#01		; find end of asg
	MOVL	(SP)+,R3			; pop addr into R3
	SUBL3	R3,R1,R2			; this is size of string
	MOVL	R2,STOP_DESC			; put size in descriptor
	MOVC3	R2,(R3),STOP_STR		; put in new name
	PUSHAQ	STOP_DESC			; convert the sentinal to
	PUSHAQ	STOP_DESC			;   upper case
	CALLS	#2,G^STR$UPCASE
	BRW	END_ASG

COM_ASG:
	; set flag to print out the comment field
	; look at first character for a Y or N, char is at R1
	MOVL	R1,R2				; put it in more perm reg
	BICB2	#^X20,(R2)			; turn it into cap
	CMPB	(R2),#^A/Y/			; is it yes?
	BNEQ 	10$				; no, try again
	BISL2	#COMMENTS_FLGM,FLAG		; yes, turn it on
	BRW	END_ASG				; all done
10$:	CMPB	(R2),#^A/N/			; is it no?
	BNEQ	20$				; no, error
	BICL2	#COMMENTS_FLGM,FLAG		; make sure it is off
	BRW	END_ASG
20$:	; invalid symbol print error, use default
	BICL2	#COMMENTS_FLGM,FLAG		; make sure it is off
	MOVB	(R2),SYM_STR			; move char for error mesg
	$FAO_S	CTRSTR = BAD_SYM,-
		OUTLEN = FAO_BUF,-
		OUTBUF = BUFFER_PTR,-
		P1     = #SYM_DESC
	PUSHAL	RCRD_ERR_DESC
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_INFO
	PUSHAL	FAO_BUF
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#6,G^LIB$SIGNAL			; print error
	BRW	END_ASG

LOG_ASG:
	; first check to see if the SET_LOGNAM flag has been set, then
	;  do the assignment
	BBC	#SET_LOGNAM_FLGV,FLAG,10$	; has not been set, so do assign
	BBC	#PRINT_ERR_FLGV,FLAG, 5$	; skip message if wrapping
	PUSHAL	NO_SET_LOG			; say we can't change log name
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#3,G^LIB$SIGNAL

5$:	BRW	END_ASG				; if set, then skip it!

10$:	; R1 holds addr of start of log name and R0 holds # char left
	PUSHL	R1				; put addr on stack
	SCANC	R0,(R1),SPAN_TABLE,#01		; find end of asg
	MOVL	(SP)+,R3			; pop addr into R3
	SUBL3	R3,R1,R2			; this is size of string
	MOVL	R2,LOG_FIL_DESC			; put size in descriptor
	MOVC3	R2,(R3),LOG_FIL_STR		; put in new name
	$FAB_STORE  FAB = CNTRL_LOG_FAB,-
		    FNS = LOG_FIL_DESC		; put size in FAB
	BRW	END_ASG

TIM_ASG:
	; if timer is currently set, then print a warning, otherwise
	;   just do assignment

	BBC	#TIM_SET_FLGV,FLAG,20$		; not set, do assignment
	BBC	#PRINT_ERR_FLGV,FLAG,10$	; skip message if wrapping

	PUSHAQ	NO_SET_TIM			; say that we can't set it
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#3,G^LIB$SIGNAL

10$:	BRW	END_ASG

20$:	; R1 holds start of time, R0 holds # chars left
	PUSHL	R1				; put addr on stack
	SCANC	R0,(R1),SPAN_TABLE,#01		; find end of asg
	MOVL	(SP)+,R3			; pop addr into R3
	SUBL3	R3,R1,R2			; this is size of string

	MOVW	#^A/00/,TIMER_HOURS		; make sure timer is zero

	; look for colon to see if time is of form -->
	;                hh:mm
	; otherwise, we just have minutes
	LOCC	#^A/:/,R2,(R3)			; is there a colon?
	BEQL	30$				; no, so just have minutes

	; Since leading zeros may be omitted, find the number of characters
	;  omitted by doing 5 (size of hh:mm) - length.
	;  Then use this as offset off of TIMER_HOURS.
	
	SUBL3	R2,#5,R1			; so, R1 is the offset
	MOVC3	R2,(R3),TIMER_HOURS(R1)		; put time is string
	BRB	40$				; convert the time

30$:	; we just have minutes
	MOVW	#^A/00/,TIMER_MINS		; make sure timer minutes is zero
	SUBL3	R2,#2,R1			; get offset off of TIMER_MINS
	MOVC3	R2,(R3),TIMER_MINS(R1)		; put time in string

40$:	; now convert the string
	$BINTIM_S  TIMBUF = TIMER_DESC,-	; convert time string into
		   TIMADR = TIMER_DELT		;   system delta time

	$SETIMR_S  DAYTIM = TIMER_DELT,-	; start the timer
		   ASTADR = TIME_EXP_AST,-	; if expire, go here
		   REQIDT = #1			; timer id is 1

	BISL2	#TIM_SET_FLGM,FLAG		; say that a timer is active
	BRW	END_ASG				; all done


END_ASG:
	RSB

	.SBTTL  Process Termination Routine
;++
; FUNCTIONAL DESCRIPTION:
;
;	This subroutine is utilized whenever a detached process is completed.
;	It determines whether or not the detached process succeeded and
;	it will print to the console and the log file the proper records from
;	the process' temporary log file.
;
; CALLING SEQUENCE:
;
;	This is called as an AST routine when a termination mailbox is 
;	received.
;
; INPUT PARAMETERS:
;
;	The Process Termination Mailbox
;
; IMPLICIT INPUTS:
;
;	None
;
; OUTPUT PARAMETERS:
;
;	None
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;--


PROC_TERM:	
	.WORD  ^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	; AST routine to be executed on the termination of a detached process,
	; reached by a mailbox AST

	; see if the QIO to the mailbox has been canceled or aborted
	CMPW 	#SS$_ABORT,PROC_TERM_IOSB	; has QIO been aborted?	
	BNEQ	3$				; no
	BRW	END_PROC_TERM			; yes, exit
3$:	CMPW	#SS$_CANCEL,PROC_TERM_IOSB	; has QIO been canceled?
	BNEQ	4$				; no
	BRW	END_PROC_TERM			; yes, exit

4$:	DECL	PROCESS_CNT			; one less process running

	; now see if timer should be canceled
	CMPL	#0,PROCESS_CNT			; are any processes running?
	BNEQ	5$				; yes, so just continue
	$CANTIM_S  REQIDT = #1			; none running, so cancel timer
	BICL2	#TIM_SET_FLGM,FLAG		; no timer running, so clear flag

5$:
	MOVAL	CNTRL_LOG_RAB,R7		; get addr of perm log RAB
	MOVAL	TERM_BUFF,R8			; get starting address of term mbx
	MOVL	ACC$L_PID(R8),TRMNTN_PID	; get PID of term mbx
	MOVAL	PROCESS_INFO,R9			; get starting addr of info buffer
10$:	CMPL	(R9),#0				; are we at the end?
	BNEQ 	15$				; no, so keep looking

;****PRINT ERROR, PROCESS NOT FOUND****
	PUSHAL	DATSTRUC_ERR
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_ERROR
	MOVL	(SP),STATUS
	PUSHL	#3
	BRW	ERROR_EXIT

15$:	BBC	#PID_FLGV,PCKT$B_FLAG(R9),20$	; if no PID, keep trying
	CMPL	TRMNTN_PID,(R9)			; there is a PID, is it right?
	BEQL 	FND_PID				; yes, continue from found PID
20$:	ADDL	#PCKT_SIZ,R9			; goto next packet
	BRB	10$				; and try again

FND_PID:	
	; we now know which block we are in, create the name of the 
	;  temp log file

	; but first, deassign the mailbox channel--if there is one
	CMPW	#-1,PCKT$W_CHAN(R9)		; is there a channel?
	BEQL	50$				; no, continue
	$DASSGN_S  CHAN = PCKT$W_CHAN(R9)	; yes, deassign it

50$:	PUSHL 	#4				; four ascii digits
	PUSHAQ	TRMNTN_ID_DESC			; where converted string goes
	PUSHAL	PCKT$L_ID(R9)			; # to convert
	CALLS	#3,G^OTS$CVT_L_TI		; convert # to text
	CMPL	R0,#OTS$_OUTCONERR		; work right?
	BNEQ	100$				; yes, continue

;****PRINT ERROR FOR CONVERSION****
	$FAO_S	CTRSTR = OUT_CON_ERR,-
		OUTLEN = FAO_BUF,-
		OUTBUF = BUFFER_PTR,-
		P1     = PCKT$L_ID(R9)
	PUSHAL	FAO_BUF
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_ERROR
	MOVL	(SP),STATUS
	PUSHL	#3
	BRW 	ERROR_EXIT			; severe get out

100$:
	; delete the temporary command log file (if any), use TMP_LOG_RAB
	$FAB_STORE FAB = DEL_COM_FAB,-
		   FNA = TRMNTN_COM_STR,-	; the file name is already made
		   FNS = #13
	$ERASE	   FAB = DEL_COM_FAB		; erase the file, 
	CMPL	R0,#RMS$_NORMAL			; did it work?
	BEQL	150$				; yes, continue
	CMPL	R0,#RMS$_FNF			; was a file there?
	BEQL	150$				; no, but that's OK too

	PUSHL	R0				; there was an error, so print it
	PUSHAQ	ERS_TCOM_ERR			; and say why we got it
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#4,G^LIB$SIGNAL

	
	; now do the temporary log file
150$:	MOVAL 	TMP_LOG_RAB,R11			; get addr of RAB
	SKPC	#^A/ /,#9,PCKT$T_NAM(R9)	; find beginning of filename
	MOVL	R0,TRMNTN_FIL_DESC		; save size of the filename
	MOVL 	R0,R3				; save size in perm. regr
	CMPW	R3,#5				; is size of filespec .GE. 5?
	BGEQ	200$				; yes, handle differently
	ADDW3	#8,R3,R2			; get size of completed spec
	$FAB_STORE FAB = @RAB$L_FAB(R11),-	
	 	   FNS = R2			; store the size
	SUBW3	R3,#5,R2			; get diff in starting addr
	MOVZWL	R2,R2				; clean out garbage in R2
	ADDL2	#TRMNTN_LOG_STR,R2		; get new address
	$FAB_STORE FAB = @RAB$L_FAB(R11),-
		   FNA = (R2)			; store the address
	MOVZWL	R3,R10				; save in even more perm regr
	MOVL 	R1,R6				; save address in perm regr
	MOVC3	R10,(R6),(R2)			; move the filespec in
	MOVC3	R10,(R6),TRMNTN_FIL_STR		; save the filename
	BRB	300$				; finish up

200$:	; filespec is at least 5 char
	$FAB_STORE FAB = @RAB$L_FAB(R11),-
		   FNS = #13,-			; size is 13 chars
		   FNA = TRMNTN_LOG_STR		; and can be found here
	MOVL  	R1,R6				; save address in perm regr
	MOVC3	R3,(R6),TRMNTN_FIL_STR		; save file name
	MOVC3	#5,(R6),TRMNTN_LOG_STR		; put spec in
300$:	MOVC3	#4,TRMNTN_ID_STR,-
		TRMNTN_LOG_STR+5		; concatenate ID #

	; now make the process name
	MOVC3	#4,TRMNTN_ID_STR,RTN_ID		; put the ID # in
	SUBL3	TRMNTN_FIL_DESC,#9,R4		; # of blanks needed
	BEQL	340$				; none are needed
	CLRL	R2
330$:	MOVB	#^A/ /,RTN_NAM_STR(R2)		; put blanks in
	AOBLSS	R4,R2,330$			; all of them in?
340$:	MOVC3	TRMNTN_FIL_DESC,TRMNTN_FIL_STR,-
		RTN_NAM_STR(R2)			; put the filename in now


	; now see if a log file exist, if it does, print its records

	$OPEN	FAB = @RAB$L_FAB(R11)		; open the temp  log file
	CMPL	R0,#RMS$_NORMAL			; if didn't work, then get out
	BNEQ	343$				; didn't work, so look at it more
	BRW	400$				; worked, so continue

343$:	CMPL	R0,#RMS$_FNF			; was the log file there?
	BEQL	345$				; no, so see if process succeeded
	BRW	370$				; otherwise, there was an error w/ OPEN

	; there was no log file, if process returned an error, print it
345$:	BBC	#0,ACC$L_FINALSTS(R8),350$	; not success, print error
	BRW	CLEAN_OUT			; was success, just leave

	; it was a non-success, so print an error
350$:	$FAO_S	CTRSTR = BAD_STATUS,-
		OUTLEN = FAO_BUF,-
		OUTBUF = BUFFER_PTR,-
		P1     = #RTN_NAM_DESC
	INSV	#0,#28,#1,ACC$L_FINALSTS(R8)	; set the status to print

	PUSHL	ACC$L_FINALSTS(R8)		; use this error code to ...
	CALLS	#1,CHK_ERR 			; ... see if any FAO arguments

	CMPL	#-1,R0				; do we have an FAO descriptor?
	BNEQ	360$				; no, then we have a status code

	PUSHL	R1				; send the descriptor address ...
	PUSHL	#1				; ... and the error message
	PUSHL	#TCNTRL$_TEXT!STS$K_INFO	; appended to an INFO header
	PUSHAL	FAO_BUF
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#6,G^LIB$SIGNAL
	BRW	CLEAN_OUT

360$:	PUSHL	R1				; send the status code
	PUSHAL  FAO_BUF				; created the message, print it
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#4,G^LIB$SIGNAL
	BRW 	CLEAN_OUT			; print time stamp and leave

370$:	PUSHL	R0				; print the error
	PUSHAQ	OPN_TMP_ERR			; and say why we got it
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#4,G^LIB$SIGNAL
	BRW	CLEAN_OUT			; leave with a time stamp

400$:	$CONNECT RAB = R11
	BLBS	R0,500$				; worked alright, so continue

	PUSHL	R0				; didn't work, so tell someone
	PUSHAQ	CON_TMP_ERR			; and say why we got it
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#4,G^LIB$SIGNAL
	BRW	TRMNTN_END			; leave with a time stamp

500$:	PUSHAQ	TRMNTN_FIL_DESC
	PUSHAQ	TRMNTN_FIL_DESC	
	CALLS	#2,G^STR$UPCASE			; change filename to upper case

GET_RCRD:
	$GET	RAB = R11
	BLBS	R0,10$				; worked alright, so continue
	CMPL	#RMS$_EOF,R0			; was error end-of-file?
	BEQL	5$				; yes, then exit

	PUSHL	R0				; print the error
	PUSHAQ	GET_TMP_ERR			; and say why we got it
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#4,G^LIB$SIGNAL
5$:	BRW	TRMNTN_END			; no, clean up and leave
						;  this includes EOF's

10$:						; try again
	MOVZWL 	RAB$W_RSZ(R11),LOG_DESC		; put size in descriptor
	PUSHAQ	LOG_DESC
	PUSHAQ	LOG_DESC
	CALLS	#2,G^STR$UPCASE			; change record to upper case

	MATCHC	START_DESC,START_STR,-
		LOG_DESC,LOG_RCRD		; is there a begin?
	BNEQ	GET_RCRD			; no, try again
	MATCHC	TRMNTN_FIL_DESC,TRMNTN_FIL_STR,-
		LOG_DESC,LOG_RCRD		; is filename in same record?
	BNEQ	GET_RCRD			; no, keep trying

COPY_RCRD:
	; we found a begin sentinel, now copy anything to SYS$OUTPUT
	; and perm log file

	$GET	RAB = R11
	BLBS	R0,5$				; work alright, so continue
	CMPL	#RMS$_EOF,R0			; was error end-of-file?
	BEQL	3$				; yes, then exit

	PUSHL	R0				; print the error
	PUSHAQ	GET_TMP_ERR			; and say why we got it
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#4,G^LIB$SIGNAL
3$:	BRW	TRMNTN_END			; no, clean up and leave
						;  this includes EOF's

5$:						; no, so continue
	MOVZWL	RAB$W_RSZ(R11),LOG_DESC		; put size in descriptor
	PUSHAQ	LOG_DESC
	PUSHAQ	TEMP_BUFF_DESC	
	CALLS	#2,G^STR$UPCASE			; change record to upper case

	MATCHC	STOP_DESC,STOP_STR,-
		TEMP_BUFF_DESC,TEMP_BUFF_STR	; are we at end?
	BNEQ	10$				; no, continue
	MATCHC	TRMNTN_FIL_DESC,TRMNTN_FIL_STR,-
		TEMP_BUFF_DESC,TEMP_BUFF_STR	; are we sure we're at end?
	MOVW	#TEXT_BUFFER,TEMP_BUFF_DESC	; reset the size of the buffer
	TSTL 	R0				; did the match succeed?
	BEQL	TRMNTN_END			; yes, stop

10$:	; now print record
	PUSHAL	LOG_DESC
	CALLS	#1,G^LIB$PUT_OUTPUT		; first to SYS$OUTPUT
	$RAB_STORE RAB = R7,-
	 	   RSZ = LOG_DESC,-		; size to be outputted
		   RBF = LOG_RCRD		; where located
	$PUT RAB = R7				; and then to perm file
	BLBC	R0,20$				; didn't work, so error
	BRW	COPY_RCRD			; did work, so continue

20$:	PUSHL	R0				; print the error
	PUSHAQ	PUT_PERM_ERR			; and say why we got it
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#4,G^LIB$SIGNAL


TRMNTN_END:
	; all done, so clean up
	
10$:
	$CLOSE	FAB = @RAB$L_FAB(R11)
	BLBS	R0,20$				; no error, so continue
	PUSHL	R0				; error, so print it
	PUSHAQ	CLS_TMP_ERR			; and say why we got it
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#4,G^LIB$SIGNAL
	BRW	CLEAN_OUT			; leave with a time stamp

	; do we delete temp log file?
20$:	BBC	#DELLOG_FLGV,FLAG,CLEAN_OUT	; no
	$ERASE	FAB = @RAB$L_FAB(R11)
	BLBS	R0,CLEAN_OUT			; no error, so leave
	PUSHL	R0				; error, so print it
	PUSHAQ	ERS_TMP_ERR			; and say why we got it
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#4,G^LIB$SIGNAL
	BRW	CLEAN_OUT			; leave with a time stamp

CLEAN_OUT:
		; print out ending message
	BICL2	#WRT_MSG_FLGM,FLAG		; long report only
	PUSHAL	ACC$Q_TERMTIME(R8)		; addr of time process ended
	PUSHAL 	RTN_NAM_DESC
	PUSHL 	#2
	PUSHL	#TCNTRL$_ENDEDD!STS$K_INFO
	CALLS	#4,G^LIB$SIGNAL

	; put free process info block back on avail list
	BICB	#PID_FLGM,PCKT$B_FLAG(R9)		; 1st longword no longer PID
	MOVL	FREE_PKT,(R9)			; point to free packet
	MOVL	R9,FREE_PKT			; this is now a free packet

	BBC	#WAKE_FLGV,FLAG,50$		; no wake set, so skip it
	CMPL	PROCESS_CNT,#0			; are there any processes running?
	BEQL	40$				; no, so wake up
	CMPL	PROCESS_CNT,PROCESS_LIMIT	; is process cnt < parcnt?
	BGEQ	50$				; no, so don't wake up
	BBS	#RUN_ALONE_FLGV,FLAG,50$	; if RUN_ALONE, then don't wake

40$:	$WAKE_S					; wake up if sleeping

50$:	$QIO_S	CHAN   = MBX_CHAN,-		; try & read another mailbox
		FUNC   = #IO$_READVBLK,-
		ASTADR = PROC_TERM,-
		IOSB   = PROC_TERM_IOSB,-
		P1     = TERM_BUFF,-
		P2     = #MAILBOX_SIZE

END_PROC_TERM:
	RET

	.SBTTL	Maximum Timer Expiration AST 

;++
; FUNCTIONAL DESCRIPTION:
;	This routine is called if the maximum time as defined by the
;	assignment statement MAXTIME =  hh:mm  has expired.  The routine 
;	will go through the PCKT data structure and print the names of 
;	the processes which remain after timeout.  It then sends control
;	to EXIT_HANDLER to stop the processes and abort.
;
; CALLING SEQUENCE:
;	Called via an AST when timer expires.
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

TIME_EXP_AST:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> 	; Entry mask

	; print out message saying that time has expired.
	PUSHAQ	TIME_OUT_ERR				; time was exceeded
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_SEVERE
	CALLS	#3,G^LIB$SIGNAL

	; now go through data structure and write names of remaining processes
	MOVL	#1,R2					; set up counter
	MOVAL	PROCESS_INFO,R3				; get starting addr of PCKT
	
10$:	BBC	#PID_FLGV,PCKT$B_FLAG(R3),20$		; no PID, so continue
	MOVAL	PCKT$T_NAM(R3),HUNG_PROC_ADDR		; a program was hung, so
							;   get address of filename

	PUSHAQ	HUNG_PROC_DESC 				; now print the filename
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_INFO
	CALLS	#3,G^LIB$SIGNAL

20$:	ADDL2	#PCKT_SIZ,R3				; point to next packet
	AOBLEQ	#MAX_PROC,R2,10$			; go thru entire structure

	; print abort message
	PUSHL	#0					; time parameter
	PUSHAQ	PRC_NAM_DESC				; test name
	PUSHL	#2
	PUSHL	#TCNTRL$_ABENDD!STS$K_ERROR
	CALLS	#4,G^LIB$SIGNAL

	; make exit status
	MOVL	#TCNTRL$_ABORT,STATUS			; put the exit code in status
	BISL2	#STS$M_INHIB_MSG,STATUS			; don't print error message
	$EXIT_S  STATUS					; then leave thru exit handler

	.SBTTL	Check returned error for FAO arguments

;++
; FUNCTIONAL DESCRIPTION:
;	This subroutine checks the error message returned from a detached 
;	 process to see if it has any FAO arguments associated with it.  If
;	 it does, it will return the meassage without the FAO text.
;
; CALLING SEQUENCE:
;	Called from either MAIN or PROC_TERM via 
;	 PUSHL	error_code
;	 CALLS	#1, CHK_ERR
;
; INPUT PARAMETERS:
;	4(AP) --> error code
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	R0 --> status describing what R1 is -- 
;		R0 = -1 => R1 is descriptor address
;		R0 = -2 => R1 is the status code
;
;	R1 --> either same error code (if no FAO args) or address of GETMSG 
;	        descriptor
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

CHK_ERR:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> 	; Entry mask
	$GETMSG_S MSGID  = 4(AP),-			; get the message that goes with
		  MSGLEN = GETMSG_PTR,-			;  this message
		  BUFADR = GETMSG_DESC,-
		  FLAGS  = #14,-			; but don't include text
		  OUTADR = MSG_BLOCK
	
	TSTB	MSG_BLOCK+1				; does message have FAO args?
	BEQL	10$					; no, so return same message
	MOVL	#-1,R0					; say that we're sending 
							;   an FAO descriptor
	MOVAQ	GETMSG_PTR,R1				; this is the descriptor
	RET

10$:	MOVL	#-2,R0					; say that we're sending
							;   a status code
	MOVL	4(AP),R1				; this is the status code
	RET

	.SBTTL	System Service Exception Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine is executed if a system service or RMS error occurs or
;	if a LIB$SIGNAL system service is used to output a message.
;	Information about this method of handling messages and errors can be
;	found in the VMS COMMON RUN-TIME manual and in the VMS SYSTEM SERVICE
;	manual.
;
; CALLING SEQUENCE:
;	Entered via an exception from the system
;
; INPUT PARAMETERS:
;	ERROR_COUNT   = previous cumulative error count
;	                -----------------
;	   AP ---->     !       2       !
;			!---------------!
;			! SIGNL ARY PNT !
;			!---------------!
;			! MECH  ARY PNT !
;			!---------------! ---------
;			!       4       !         ^
;			!---------------!         !
;			! ESTABLISH FP  !         !
;			!---------------!         !
;			!    DEPTH      ! Mechanism Array
;			!---------------!         !
;			!      R0       !         !
;			!---------------!         !
;			!      R1       !         v
;			!---------------! ---------
;			!       N       !         ^
;			!---------------!         !
;			! CONDITION NAME!         !
;			!---------------!         !
;			! N-3 ADDITIONAL!    Signal Array
;			! LONG WORD ARGS!         !
;			!---------------!         !
;			!      PC       !         !
;			!---------------!         !
;			!      PSL      !         v
;			!---------------! ---------
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;--

SSERROR:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	$SETAST_S ENBFLG = #0			; disable AST delivery
	CLRL	AST_MODE			; assume it was disabled
	CMPL	R0,#SS$_WASSET			; were AST's enabled?
	BNEQ	10$				; no, so continue
	MOVL	#1,AST_MODE			; save it to be reenabled

10$:	$SETSFM_S ENBFLG = #0			; Disable SS failure mode for PUTMSG
	CLRL	SS_FAIL_MODE			; assume it was disabled
	CMPL	R0,#SS$_WASSET			; was SS failure mode enabled?
	BNEQ	20$				; no, so continue
	MOVL	#1,SS_FAIL_MODE			; save it to be reenabled

20$:	MOVAL	CNTRL_LOG_RAB,R7		; get addr of perm log RAB

	MOVL	CHF$L_SIGARGLST(AP),R6		; Get the signal array pointer
	CMPZV	#STS$V_FAC_NO,#STS$S_FAC_NO,- 	; Is this a message from LIB$SIGNAL?
		CHF$L_SIG_NAME(R6),#TCNTRL_K
	BNEQ	30$				; BR if this is a system exception
	SUBL2	#2,CHF$L_SIG_ARGS(R6)		; Drop the PC and PSL
	$PUTMSG_S MSGVEC = CHF$L_SIG_ARGS(R6),-	; Print the message
		  ACTRTN = LNG_FORMAT
	$SETSFM_S ENBFLG = SS_FAIL_MODE		; set to previous state
	$SETAST_S ENBFLG = AST_MODE		; set to previous state
	RET					; Return to the program
30$:
	CMPZV	#STS$V_FAC_NO,#STS$S_FAC_NO,- 	; Is it an RMS failure?
		CHF$L_SIG_ARG1(R6),#RMS_K
	BNEQ	40$				; BR if not
	$SETSFM_S ENBFLG = SS_FAIL_MODE		; set to previous state
	$SETAST_S ENBFLG = AST_MODE		; set to previous state
	RET					; Yes, RMS_ERROR gets to handle them
40$:
	MOVL	CHF$L_SIG_NAME(R6),STATUS 	; Save the status
	CLRL	R8				; Assume that it is not SS failure
	CMPL	#SS$_SSFAIL,STATUS		; But, is it a SS failure?
	BNEQ	60$				; No, so no special message
	$GETMSG_S MSGID  = CHF$L_SIG_ARG1(R6),- ; Get message for failure code
		  MSGLEN = GETMSG_PTR,-
		  BUFADR = GETMSG_DESC,-
		  FLAGS  = #14,-		; but without the text
		  OUTADR = MSG_BLOCK

	TSTB	MSG_BLOCK+1			; any FAO arguments?
	BEQL	50$				; no, so skip alternate message
	PUSHAL 	GETMSG_PTR			; write message w/out FAO text
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT			; put the message with an info message
	INSV	CHF$L_SIG_ARG1(R6),-		; and put correct severity code
		#STS$V_SEVERITY,-		;  with the message
		#STS$S_SEVERITY,(SP)
	MOVL	#3,R8				; number of arguments we pushed
	BRB	60$				; leave

50$:	PUSHL	CHF$L_SIG_ARG1(R6)		; no FAO text, so write entire mesg.
	MOVL	#1,R8				; pushed one argument

60$:
	MULL3	#4,CHF$L_SIG_ARGS(R6),R7 	; Convert longwords to bytes
	SUBL2	R7,SP				; Save the current signal array...
	MOVC3	R7,CHF$L_SIG_NAME(R6),(SP) 	; ...on the stack
	ADDL3	R8,CHF$L_SIG_ARGS(R6),-(SP) 	; Push the current arg count
	BRW	ERROR_EXIT

LNG_FORMAT:	; prints the time stamps to the logfile
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVAL	CNTRL_LOG_RAB,R3		; get addr of perm log RAB
	MOVL	4(AP),R2			; get the message descriptor address
	MOVW	(R2),RAB$W_RSZ(R3)		; put the size in
	MOVL	4(R2),RAB$L_RBF(R3)		; put the address in
	$PUT	RAB = R3			; write the record
	MOVL	#SS$_NORMAL,R0			; set return status
	BBS	#WRT_MSG_FLGV,FLAG,10$		; print mesg if suppose to
	BBS	#REPORT_FLGV,FLAG,10$		; print mesg if report is long
	CLRL	R0				; else, don't print mesg
	BISL2	#WRT_MSG_FLGM,FLAG		; turn wrt mesg back on
10$:	RET					; keep working

	.SBTTL	RMS Error Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles error returns from RMS calls.
;
; CALLING SEQUENCE:
;	Called by RMS when a file processing error is found.
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	The FAB or RAB associated with the RMS call.
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Error message
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	Program may exit, depending on severity of the error.
;
;--

RMS_ERR:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	MOVL	4(AP),R6			; See whether we're dealing with...
	CMPB	#FAB$C_BID,FAB$B_BID(R6) 	; ...a FAB or a RAB
	BNEQ	10$				; BR if it's a RAB
	MOVAL	FILE,R7				; FAB-specific code:  text string...
	MOVL	R6,R8				; ...address of FAB...
	PUSHL	FAB$L_STV(R6)			; ...STV field for error...
	PUSHL	FAB$L_STS(R6)			; ...STS field for error...
	MOVL	FAB$L_STS(R6),STATUS		; ...and save the error code
	BRB	COMMON				; FAB and RAB share other code
10$:
	CMPL	#TMP_LOG_RAB,R6			; did error come from temp log file
	BNEQ	20$				; no, continue
	CMPL	RAB$L_STS(R6),#RMS$_EOF		; is it an EOF?
	BNEQ 	30$				; no, print error
	RET					; yes, no error

20$:
	CMPL	RAB$L_STS(R6),#RMS$_EOF		; is it an EOF?
	BNEQ	30$				; no, so print error
	BISL2	#EOF_FLGM,FLAG			; yes, so EOF flag for data file
	RET					; and go back to work

30$:
	MOVAL	RECORD,R7			; RAB-specific code:  text string...
	MOVL	RAB$L_FAB(R6),R8		; ...address of associated FAB...
	PUSHL	RAB$L_STV(R6)			; ...STV field for error...
	PUSHL	RAB$L_STS(R6)			; ...STS field for error...
	MOVL	RAB$L_STS(R6),STATUS		; ...and save the error code
COMMON:	
	MOVZBL	FAB$B_FNS(R8),R10
	$FAO_S	CTRSTR = RMS_ERR_STRING,- 	; Common code, prepare error message...
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = R7,-
		P2     = R10-
		P3     = FAB$L_FNA(R8)
	PUSHAL	BUFFER_PTR			; ...and arguments for ERROR_EXIT...
	PUSHL	#1				; ...
	PUSHL	#TCNTRL$_TEXT			; ...
	EXTZV	#STS$V_SEVERITY,-
		#STS$S_SEVERITY,-
		STATUS,R9 			; ...get the severity code...
	BISW2	R9,(SP)				; ...and add it into the signal name
	PUSHL	#5				; Current arg count
	BRW	ERROR_EXIT

	.SBTTL	CTRL/C Handler
	.DEFAULT DISPLACEMENT,LONG
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles CTRL/C AST's
;
; CALLING SEQUENCE:
;	Called via AST
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

CCASTHAND:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	$QIO_S	CHAN = TTCHAN,-			; do a read from the TTY
		FUNC = #IO$_SETMODE!IO$M_OUTBAND,-   ; look at the control character
		P1 = RPT_CNTRLC_AST,-		; and handle it if it is a ^C
		P2 = #CNTRLC_MSK

	PUSHAL	CNTRLCMSG			; Set message pointer
	PUSHL	#1				; Set arg count
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING	; Set signal name
	PUSHL	#0				; Indicate an abnormal termination
	PUSHAL	PRC_NAM_DESC			; ...
	PUSHL	#2				; ...
	PUSHL	#TCNTRL$_ABENDD!STS$K_WARNING 	; ...
	CALLS	#7,G^LIB$SIGNAL			; Output the message
	MOVL	#TCNTRL$_CONTROLC,STATUS	; ... and exit status
	$EXIT_S STATUS				; Terminate program cleanly

RPT_CNTRLC_AST:
	.WORD ^M<>
	; enter this AST if repeated CNTL-C's are issued. To handle the
	;   additional CNTRL-C, simply exit.
	RET


	.SBTTL	Error Exit
;++
; FUNCTIONAL DESCRIPTION:
;	This routine prints an error message and exits.
;
; CALLING SEQUENCE:
;	MOVx  error status value,STATUS
;	PUSHx error specific information on the stack
;	PUSHL current argument count
;	BRW   ERROR_EXIT
;
; INPUT PARAMETERS:
;	Arguments to LIB$SIGNAL, as above
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	Message to SYS$OUTPUT and SYS$ERROR
;
; IMPLICIT OUTPUTS:
;	Program exit
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

ERROR_EXIT:

	ADDL3	(SP)+,#4,ARG_COUNT		; Get total # args, pop partial count
	PUSHL	#0				; Push the time parameter
	PUSHAL	PRC_NAM_DESC			; Push test name...
	PUSHL	#2				; ...arg count...
	PUSHL	#TCNTRL$_ABENDD!STS$K_ERROR 	; ...and signal name
	CALLS	ARG_COUNT,G^LIB$SIGNAL		; Truly bitch

	BISL	#STS$M_INHIB_MSG,STATUS		; Don't print messages twice!
	$EXIT_S STATUS				; Exit in error

	.SBTTL	Exit Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles cleanup on exits, and stops all running detached
;	processes.
;
; CALLING SEQUENCE:
;	Invoked automatically by $EXIT System Service.
;
; INPUT PARAMETERS:
;	Location STATUS contains the exit status.
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Various files are de-accessed and the process name is reset.
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

EXIT_HANDLER:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	$SETSFM_S ENBFLG = #0			; Turn off System Service failure mode
	BBC	#TERMINAL_FLGV,FLAG,5$		; we are not from TTY, skip QIO
	$QIO_S	CHAN = TTCHAN,-			; do a read from the TTY
		FUNC = #IO$_SETMODE!IO$M_OUTBAND,-   ; look at the control character
		P1 = RPT_CNTRLC_AST,-		; and handle it if it is a ^C
		P2 = #CNTRLC_MSK

5$:	$CANCEL_S CHAN = MBX_CHAN		; cancel any pending I/O's to mailbox

	; stop all detached processes
	MOVL	#1,R2				; set up counter
	MOVAL	PROCESS_INFO,R3			; get starting addr of info structure
	$BINTIM_S TIMBUF = STOP_TIM_DESC,-	; convert 30 sec. string to delta
		  TIMADR = STOP_TIME		; time
	MOVL	BASPRI,R1			; get current base priority ...
	INCL	R1				; ... and increase it by one
	$SETPRI_S PRI = R1			; now change priority so TSTCNTRL
						;   is higher than detached processes

10$:
	BBC	#PID_FLGV,PCKT$B_FLAG(R3),20$	; no PID, so continue
	$SETIMR_S DAYTIM = STOP_TIME,-		; set a timer in case we get 
		  EFN    = #ABORT_EVNT_FLG,-	;  stuck in the QIO
		  REQIDT = #2

	$DELPRC_S PIDADR = (R3)			; stop the process
	CMPL 	R0,#SS$_NORMAL			; did we delete the process
	BNEQ	15$				; no, so don't wait for mailbox
	$QIO_S  EFN  = #QIO_EVNT_FLG,-
		CHAN = MBX_CHAN,-		; wait for termination mailbox
		IOSB = ABORT_IOSB,-		;  to make sure that the process
		FUNC = #IO$_READVBLK,-		;  terminates
		P1   = TERM_BUFF,-
		P2   = #MAILBOX_SIZE
	$WFLOR_S EFN  = #QIO_EVNT_FLG,-		; wait till either QIO is done,
		 MASK = #EVNT_FLG_MSK		; or timer expired

15$:	$CANTIM_S REQIDT = #2			; stop the timer to start again

20$:	ADDL2	#PCKT_SIZ,R3			; point to next packet
	AOBLEQ	#MAX_PROC,R2,10$		; go thru entire structure

30$:	; clean up all loose items
	$SETPRI_S PRI = BASPRI			; set back to original priority
	$DASSGN_S CHAN = MBX_CHAN		; deassign the mailbox channel
	$DASSGN_S CHAN = TTCHAN			; deassign CNTRL/C channel
	$CLOSE 	FAB = FILE_FAB			; close & disconnect the data file
	$CLOSE  FAB = CNTRL_LOG_FAB		; close & disconnect perm log file
	$SETPRN_S PRCNAM = PRCNAMDESC		; reset users process name
	RET					; BYE NOW!

	.END TSTCNTRL
