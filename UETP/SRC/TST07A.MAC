	.TITLE	TST07A
	.IDENT	/V03000/
	.PSECT	TST07A
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; VERSION X02
;
; WRITTEN BY CLARK A. D'ELIA, FEBRUARY 1973
;
; MODIFIED BY:
;	C.A. D'ELIA	SEPTEMBER 1974  (FOR RSX-11M)
;	THOMAS J MILLER	7/15/75 (CHANGE TESTS FOR INVALID DPB SIZES)
;	LARRY D JONES	12/09/77	(FOR VAX/VMS)
;
;+
;
; MODULE 'TST07A' IS THE ONLY TASK OF TEST07.  IT IS DESIGNED TO TEST
; THE FOLLOWING RSX-11M SYSTEM DIRECTIVES:
;
;	AST SERVICE EXIT
;	ENABLE AST RECOGNITION
;	DISABLE AST RECOGNITION
;	SPECIFY FLOATING POINT EXCEPTION AST
;	SPECIFY POWER RECOVERY AST
;
;-

	.MCALL	ASTX$S,MRKT$S,QIO$,SFPA$S,SETF$S,DSAR$S,ENAR$S,MRKT$C
	.MCALL	SPRA$,SPRA$S,WTSE$S,MRKT$,WTSE$,EXIT$S,SVTK$S,SVTK$
	.MCALL	CALL,RETURN
 

;
; LOCAL ASSIGNMENTS
;
 
LF=12				;LINE FEED
 
AC0=0				;USED IN 11/45 FLOATING POINT INSTRUCTION
SETF=170001			;45-FPU OPCODE (SET SINGLE PRECISION MODE) 
DIVF=174400			;45-FPU OPCODE (DIVIDE FLOATING)
FP.ZDV=4			;45-FPU ZERO DIVIDE ERROR STATUS
 

;
; LOCAL MACRO DEFINITIONS
;
 
	.MACRO	.SETF
	.WORD	SETF
	.ENDM
 
	.MACRO	.DIVF	FSRC,AC,LBL
	MOV	#FSRC,-(SP)
LBL	.WORD	DIVF ! <AC*100> ! 36	;DIVF  @(SP)+,AC
	.ENDM
 
	.MACRO	.WAIT	?LBL
	MOV	#10.,R0
LBL:	DEC	R0
	BNE	LBL
	.ENDM
 
 
;
; LOCAL DATA
;

V45:	.WORD	0,0,0,0,ILLINS	;SST VECTOR TO TRAP ILLEGAL INSTRUCTIONS
 
ASTERR:	.WORD	ODDSST		;SST VECOTR TO TRAP BAD AST ADDRESSES
	.WORD	SEGSST
 
AST:	.BLKW	1		;PROGRAM AST INDICATOR

IOSTAT:	.BLKW	2		;I/O STATUS BLOCK

QAST:	.BLKW	1		;QUEUED AST INDICATOR

QCNT:	.BLKW	1		;QUEUED AST COUNT
 
STKPNT:	.BLKW	1		;HOLDS ADDR OF STACK FOR PROPER AST EXIT

MTYPE:	.BLKW	1		;MACHINE TYPE
 
FP45:	.BLKW	1		;PDP-11/45 FPU SUPPORT IN EXEC

FZERO:	.WORD	0,0		;USED TO CAUSE F.P. EXCEPTION

	.NLIST	BEX
 
LEM01:	.ASCIZ	/, EVENT FLAG NOT SET IN AST SERVICE/

LEM02:	.ASCIZ	/, AST WAS NOT SERVICED/

LEM03:	.ASCIZ	', I/O STATUS NOT SET IN AST SERVICE'

LEM04:	.ASCIZ	/, ONLY %D. QUEUED AST'S OCCURRED/

LEM05:	.ASCII	/, AST QUEUING ERROR%NAST NUMBER %D. IMMEDIATELY /
	.ASCIZ	/FOLLOWED AST NUMBER %D./

LEM06:	.ASCII	/, F.P. EXCEPTION AST STACK ERROR%NEXP'D: %O AND %O,/
	.ASCIZ	/ BUT RCV'D: %O AND %O/

LEM07:	.ASCIZ	/, %D AST'S WERE NOT INHIBITED/

LEM08:	.ASCIZ	/, ERROR IN AST STACK CONTENTS%NEXP'D: %O, RCV'D: %O/
 
LEM09:	.ASCIZ	/, ERROR IN AST STACK ADDRESS%NINCORRECT BY %D. WORDS/
 
LMG01:	.ASCII	/%N++++ FOR APPROXIMATELY ONE MINUTE, THIS TASK WILL SERVICE%N/
	.ASCIZ	/     "POWER RECOVERY AST'S"/
 
LMG02:	.ASCIZ	/-*- POWER RECOVERY TRAP # %D./
 
LMG03:	.ASCIZ	/%N++++ NO "POWER RECOVERY AST'S" WERE SERVICED/<LF>

	.LIST	BEX
	.PAGE
	.PSECT	$DPB$$

;
; THIS CONTROL SECTION CONTAINS ONLY DPB'S
;

SVCT45:	SVTK$	V45,5		;USED TO TRAP ILLEGAL FPU INSTRUCTIONS
 
 
MKT1:	MRKT$	1,100,TICK


QASDPB:	MRKT$	0,0,TICK


WT1:	WTSE$	1
 

PWRFL:	SPRA$	POWAST		;SPECIFY POWER RECOVERY AST
 
 
QIODPB:	QIO$	IO.WVB,TI,1,,,,<.OBUF,-1,0>
	.PAGE
	.PSECT	TST07A
	.EVEN
;+
;
; INITIALLY, THIS TASK SENDS AN IDENTIFYING MESSAGE TO THE USER
; AT TI:.  THE MESSAGE INDICATES THE START OF TASK EXECUTION,
; AND IT IDENTIFIES THE TEST NUMBER.
;
;-
	$$TEST	7,A		;DECLARE TEST #7, SUBTEST-A, STEP #0
	CALL	.STST		;SEND THE START OF TEST MESSAGE
;+
;
; SINCE THIS TASK WILL TEST RSX-11M AST'S, THE "AST SERVICE EXIT"
; DIRECTIVE IS FIRST CHECKED.  IT WILL BE INVOKED DESPITE THE FACT
; THAT THIS IS NOT AN AST SERVICE ROUTINE.  IT SHOULD FAIL.
;
;-
	$$STEP
	SUB	#8.,SP		;IF THE EXIT DOES WORK, THE PROGRAM WILL
	CLR	-(SP)		;NOT BRANCH INTO OBLIVION IF THE STACK
	MOV	#1$,-(SP)	;LOOKS CORRECT
	CLR	-(SP)
	ASTX$S			;INVOKE THE AST EXIT
1$:	MOV	#IE.AST,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
	BCS	2$		;SKIP IF THE EXIT WORKED
	ADD	#14.,SP		;ELSE, CLEAN THE STACK
2$:
;+
;
; THE "MARK TIME" DIRECTIVE IS INVOKED, SPECIFYING AN AST ADDRESS BUT NO
; EVENT FLAG.  THE AST ROUTINE WILL CHECK FOR PROPER INFO ON THE STACK.
;
;-
	$$STEP
	MOV	SP,STKPNT	;SAVE THE ADDR OF STACK FOR PROPER ...
	SUB	#14.,STKPNT	;... AST EXITS
	INC	AST		;SET PROGRAM AST INDICATOR
	DIR$	#MKT1,.RJCT	;SETUP FOR FUTURE EVENT
	CLR	R5		;CONTENTS OF R5 SHOULD MATCH AST STK TOP
	MRKT$S	,#1,#TICK,#AST1,.RJCT
	BCS	1$		;SKIP IF FAILURE
	DIR$	#WT1,.RJCT	;WAIT FOR EVENT
	CALL	ASTCHK		;CHECK PROGRAM AST INDICATOR
1$:
;+
;
; THE "MARK TIME" DIRECTIVE IS USED AGAIN TO CAUSE AN AST.  THIS TIME AN
; EVENT FLAG IS SPECIFIED AND CHECKED.
;
;-
	$$STEP
	INC	AST		;SET AST INDICATOR
	INC	R5		;SET R5 TO ONE (EFN NUMBER)
	MOV	R5,R4		;AND COPY IT INTO R4
	MRKT$S	R4,#2,#TICK,#AST2,.RJCT
	BCS	1$		;SKIP IF DIRECTIVE FAILED
	DIR$	#WT1,.RJCT
	CALL	ASTCHK		;EXAMINE THE AST INDICATOR
1$:
;+
;
; THE "QUEUE I/O" DIRECTIVE IS INVOKED TO GENERATE AN AST.  FURTHERMORE,
; NO I/O STATUS BLOCK IS SPECIFIED.
;
;-
	$$STEP
	INC	AST		;SET AST INDICATOR
	DIR$	#MKT1,.RJCT	;SETUP FOR FUTURE EVENT
	CLR	R5		;TOP OF AST STACK SHOULD BE ZERO
	MOV	#QIODPB,R3	;PUT QUEUE I/O DPB ADDR IN R3
	CLR	Q.IOEF(R3)	;CLEAR EFN WORD IN DPB
	MOV	#AST1,Q.IOAE(R3)  ;SPECIFY AST ADDR
	DIR$	R3,.RJCT	;QUEUE I/O REQUEST W/ AST SERVICE
	BCS	1$		;SKIP IF DIRECTIVE FAILED
	DIR$	#WT1,.RJCT	;WAIT FOR EVENT
	CALL	ASTCHK		;EXAMINE AST INDICATOR
1$:
;+
;
; THE "QUEUE I/O" DIRECTIVE IS AGAIN USED TO CAUSE AN AST.  AN I/O STATUS
; BLOCK IS SPECIFIED, AND IT WILL BE CHECKED BY THE AST SERVICE.
;
;-
	$$STEP
	INC	AST		;SET PROGRAM AST INDICATOR
	MOV	#1,R4		;PUT EFN IN R4
	MOV	#IOSTAT,R5	;PUT ADDR OF STATUS BLOCK IN R5
	MOV	R4,Q.IOEF(R3)	;SPECIFY EVENT FLAG IN DPB
	MOV	R5,Q.IOSB(R3)	;SPECIFY I/O STATUS BLOCK ADDR
	MOV	#AST3,Q.IOAE(R3)  ;SPECIFY A NEW AST ADDR
	DIR$	R3,.RJCT	;QUEUE I/O WITH AST SERVICE
	CLR	Q.IOSB(R3)	;REMOVE I/O STATUS BLOCK ADDR FROM DPB
	BCS	10$		;SKIP IF DIRECTIVE FAILED
	DIR$	#WT1,.RJCT	;WAIT FOR I/O DONE
	CALL	ASTCHK		;CHECK PROGRAM AST INDICATOR
10$:
;+
;
; THIS STEP TESTS THE SYSTEM'S AST QUEUING (FIFO).  TO ACCOMPLISH THIS,
; A "MARK TIME" IS ISSUED WITH AN EVENT FLAG SPECIFIED.  AT THE TIME,
; 'QAST' IS ZERO.  ONCE THE AST OCCURS, IT ISSUES THREE ADDITIONAL "MARK
; TIME" DIRECTIVES TO GENERATE AST'S AND WAIT FOR THE LAST TO QUEUE UP.
; EACH AST SERVICE ROUTINE CHECKS THAT IT IS IN THE PROPER ORDER AND
; EXITS.  WHEN CONTROL IS RETURNED HERE, A CHECK IS MADE TO INSURE THAT
; ALL AST'S OCCURRED AND WERE SERVICED.
;
;-
	$$STEP
	CLR	QCNT		;CLEAR QUEUED AST COUNT
	CLR	QAST		;CLEAR QUEUED AST INDICATOR
	MOV	#QASDPB,R3	;PUT ADDR OF DPB IN R3
	MOV	#1,M.KTEF(R3)	;PUT EFN IN DPB
	MOV	#2,M.KTMG(R3)	;USE TIME OF 2 CLOCK TICKS
	MOV	#AST10,M.KTAE(R3) ;PUT AST ADDR IN DPB
	DIR$	R3,.RJCT	;INVOKE THE MARK TIME
	BCS	1$		;SKIP IF DIRECTIVE FAILED
	DIR$	#WT1,.RJCT	;WAIT FOR EVENT FLAG
	CMP	#6,QCNT		;CHECK TO SEE IF ALL AST'S WERE DONE
	BEQ	1$		;SKIP IF O.K.
	CALL	.IDOUT		;ELSE, SETUP STEP IDENTIFICATION
	MOV	#LEM04,R1	;PUT FORMAT ADDR IN R1
	MOV	#QCNT,R2	;PUT ARG ADDR IN R2
	CALL	.PRTMG		;CREATE REST OF MESSAGE & PRINT
1$:
;+
;
; IF THE MACHINE ON WHICH THE TASK IS RUNNING IS A PDP-11/45, CHECK OUT
; THE FLOATING POINT EXCEPTION AST.  IN EITHER CASE, ISSUE THE "SPECIFY
; FLOATING POINT EXCEPTION AST" DIRECTIVE.
;
;-
 
	.ENABL	LSB
 
	$$STEP
;*****
	JMP	STP13			; DISABLE STEPS 7,10,11,12
;*****
	CLR	MTYPE		;ASSUME MACHINE IS NOT PDP-11/45
	CLR	FP45		;ASSUME EXEC DOESN'T SUPPORT 45-FPU
	SFPA$S	#AST20		;SPECIFY A 45 FLOATING POINT AST ADDR
	BCC	100$		;BRANCH ON SUCCESS
	CMP	@#$DSW,#IE.SDP	;ERROR--WAS IT ILLEGAL DIRECTIVE?
	BEQ	2$		;BRANCH IF TRUE
	CALL	.RJCT		;ELSE, REPORT AN ERROR
	BR	2$		;IN ANY CASE, IGNORE FP AST TESTING
100$:	INC	FP45		;INDICATE 45-FPU SUPPORT IN EXEC
	DIR$	#SVCT45,.RJCT	;SETUP SST VECTOR TO TRAP ILLEGAL INSTR
	BCS	2$		;BRANCH IF THAT FAILED
	.SETF			;EXEC 45-FPU INSTRUCTION--TRAP IF ILLEGAL
	MOV	#45.,MTYPE	;ELSE, INDICATE MACHINE IS PDP-11/45
	INC	AST		;SET AST INDICATOR
	MOV	#FP.ZDV,R4	;PUT F.P. ERROR CODE IN R4
	MOV	#1$,R5		;PUT ADDR OF INSTR IN R5
	.DIVF	FZERO,AC0,<1$:>	;CAUSE THE ERROR
	.WAIT			;WAIT UNTIL 45-FPU TRAPS
	CALL	ASTCHK		;EXAMINE AST INDICATOR
2$:
 
	.PSECT	ILLINS
ILLINS:	CMP	(SP)+,(SP)+	;CLEAN PC/PS FROM STACK
	JMP	2$		;IGNORE 45-FPU TESTING
 
	.PSECT	TST07A
 
	.DSABL	LSB
 

;+
;
; THE "DISABLE AST RECOGNITION" DIRECTIVE WILL BE TESTED.  IT WILL BE
; ISSUED AND FOLLOWED BY DIRECTIVES TO PRODUCE AST'S.  THEN SUFFICIENT
; TIME WILL BE ALLOWED TO EXPIRE TO CHECK THAT AST'S WERE ACTUALLY
; DISABLED.
;
;-
	$$STEP
	CLR	QAST		;CLEAR QUEUED AST INDICATOR
	CLR	QCNT		;CLEAR QUEUED AST COUNT
	TST	FP45		;CHECK FOR EXECUTIVE 45-FPU SUPPORT
	BEQ	1$		;SKIP IF NOT SUPPORTED
	SFPA$S	#AST30,.RJCT	;SPECIFY A NEW FLOATING POINT AST ADDR
	CALL	.SUCC		;CHECK FOR SUCCESS RETURN STATUS
1$:	DSAR$S	.RJCT		;DISABLE AST RECOGNITION
	CALL	.SUCC		;CHECK FOR SUCCESS RETURN STATUS
	CMP	#45.,MTYPE	;CHECK MACHINE TYPE
	BNE	2$		;AND SKIP IF MACHINE IS NOT PDP-11/45
	DEC	QAST		;ELSE, SET QUEUED AST INDICATOR TO -1
	DIR$	#MKT1,.RJCT	;SET FLAG 1 IN A WHILE
	.DIVF	FZERO,AC0	;CAUSE THE ERROR
	DIR$	#WT1,.RJCT	;WAIT FOR FLAG 1 (& FOR AST TO QUEUE)
2$:	MOV	#AST11,QIODPB+Q.IOAE  ;SPECIFY A NEW AST ADDR
	DIR$	#QIODPB,.RJCT	;QUEUE I/O WITH AST SERVICE
	BCS	3$		;SKIP IF QUEUE I/O FAILED
	DIR$	#WT1,.RJCT	;WAIT FOR THE I/O DONE
3$:	MOV	#QASDPB,R3	;PUT ADDR OF DPB IN R3
	CLR	M.KTEF(R3)	;CLEAR EVENT FLAG
	MOV	#2,M.KTMG(R3)	;SPECIFY TIME MAGNITUDE OF 2
	MOV	#AST12,M.KTAE(R3)  ;PUT AST ADDR IN DPB
	DIR$	#MKT1,.RJCT	;USE MARK TIME TO GET THIS TASK...
	DIR$	#WT1,.RJCT	;...JUST PAST CLOCK TICK BOUNDARY
	DIR$	R3,.RJCT	;CAUSE AN AST IN 2 TICKS
	MOV	#AST13,M.KTAE(R3) ;USE NEW AST ADDR
	DIR$	R3,.RJCT	;CAUSE AST IN 2 TICKS
	MOV	#AST14,M.KTAE(R3) ;USE ANOTHER NEW AST ADDRESS
	DIR$	R3,.RJCT	;GENERATE AST IN 2 CLOCK TICKS
	INC	M.KTEF(R3)	;SPECIFY EFN 1
	MOV	#AST15,M.KTAE(R3)  ;PUT NEW AST ADDR IN DPB
	DIR$	R3,.RJCT	;CAUSE AN AST IN 2 TICKS
	DIR$	#WT1,.RJCT	;WAIT FOR LAST MKT TO HAPPEN
	TST	QCNT		;TEST TO DETERMINE IF AST'S WERE QUEUED
	BEQ	4$		;SKIP IF THEY WERE
	CALL	.IDOUT		;ELSE, SETUP STEP IDENTIFICATION
	MOV	#LEM07,R1	;PUT FORMAT ADDR IN R1
	MOV	#QCNT,R2	;PUT ARG ADDR IN R2
	CALL	.PRTMG		;CREATE REST OF MESSAGE AND PRINT
4$:
;+
;
; WHILE AST'S ARE ALREADY DISABLED, ATTEMPT TO INVOKE THE "DISABLE AST
; RECOGNITION", "SPECIFY POWER RECOVERY AST", AND "SPECIFY FLOATING
; POINT AST" DIRECTIVES.
;
;-
	$$STEP
	DSAR$S			;ISSUE THE DIRECTIVE
	MOV	#IE.ITS,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
	DIR$	#PWRFL		;ATTEMPT TO SPECIFY POWERFAIL AST
	MOV	#IE.AST,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
	TST	FP45		;CHECK FOR EXEC 45-FPU SUPPORT
	BEQ	10$		;SKIP IF NONE
	SFPA$S	#AST30		;ATTEMPT TO SPECIFY 45-FPU AST
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
10$:
;+
;
; ISSUE THE "ENABLE AST RECOGNITION" DIRECTIVE TO ALLOW THE QUEUED AST'S
; TO OCCUR.  THE AST SERVICE ROUTINES CHECK FOR PROPER DE-QUEUING.  A
; CHECK IS MADE HERE TO INSURE THAT ALL WERE SERVICED.
;
;-
	$$STEP
	ENAR$S	.RJCT		;ENABLE AST RECOGNITION
	CALL	.SUCC		;CHECK FOR SUCCESS RETURN STATUS
	MOV	#5,R3		;PUT EXPECTED AST COUNT IN R3
	CMP	#45.,MTYPE	;CHECK MACHINE TYPE
	BNE	1$		;AND SKIP IF NOT PDP-11/45
	TST	FP45		;CHECK FOR FP45 SUPPORT
	BEQ	1$		;SKIP IF IT DOESN'T EXIST
	INC	R3		;ELSE, ADD IN 1 MORE AST  (F.P. EXCP)
1$:	CMP	R3,QCNT		;CHECK THE QUEUED AST COUNT
	BEQ	2$		;SKIP IF O.K.
	CALL	.IDOUT		;SETUP STEP IDENTIFICATION
	MOV	#LEM04,R1	;PUT FORMAT ADDR IN R1
	MOV	#QCNT,R2	;PUT ARG ADDR IN R2
	CALL	.PRTMG		;CREATE REST OF MESSAGE & PRINT
2$:
;+
;
; ATTEMPT TO INVOKE THE "ENABLE AST RECOGNITION" DIRECTIVE AGAIN, NOTING
; THAT IT IS CURRENTLY IN EFFECT.
;
;-
	$$STEP
	ENAR$S			;INVOKE DIRECTIVE
	MOV	#IE.ITS,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
;+
;
; THE DIRECTIVE ERROR CONDITIONS WILL BE TESTED.  THE "SPECIFY FLOATING
; POINT EXCEPTION AST" DIRECTIVE WILL BE USED FIRST TO UN-SPECIFY THE
; CURRENTLY EXISTING ONE.
;
;-
	TST	FP45		;CHECK FOR EXEC 45-FPU SUPPORT
	BEQ	SK45FP		;IF NONE, SKIP FOLLOWING SEVERAL TESTS
	$$STEP
	SFPA$S	,.RJCT		;UN-SPECIFY OLD AST
	CALL	.SUCC		;CHECK FOR SUCCESS RETURN STATUS
;+
;
; THIS STEP WILL INVOKE THE "SPECIFY FLOATING POINT EXCEPTION AST"
; DIRECTIVE TO ATTEMPT TO UN-SPECIFY THE AST AGAIN.
;
;-
	$$STEP
	SFPA$S			;UN-SPECIFY AGAIN
	MOV	#IE.ITS,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.STAT		;CHECK THE DIRECTIVE STATUS
;+
;
; AN ATTEMPT WILL BE MADE TO INVOKE THE "SPECIFY FLOATING POINT EXCEPTION
; AST" DIRECTIVE WHILE IN AN AST SERVICE ROUTINE.
;
;-
	$$STEP
;*****
	JMP	STP24			; DISABLE STEPS 16,17,20,21,22,23
;*****
	INC	AST		;SET PROGRAM AST INDICATOR
	MRKT$C	1,1,TICK,AST4,TST07A,.RJCT
	DIR$	#WT1,.RJCT	;WAIT FOR THE EVENT
	CALL	ASTCHK		;CHECK RESULTS
;+
;
; THE "SPECIFY FLOATING POINT EXCEPTION AST" DIRECTIVE WILL BE ISSUED
; WITH AN INVALID DPB SIZE.
;
;-
	$$STEP
 
 
	.PSECT	$DPB$$
	.ENABL	LSB
 
10$:	.BYTE	111.,0		;INVALID SFPA$ DPB
20$:	.BYTE	111.,1		;INVALID SFPA$ DPB
 
 
	.PSECT	TST07A
 
	DIR$	#10$		;INVOKE THE DPB
	MOV	#IE.ADP,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
	DIR$	#20$		;INVOKE THE DPB
	MOV	#IE.SDP,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
 
	.DSABL	LSB
 
SK45FP:				;SKIP TO HERE IF NO EXEC 45-FPU SUPPORT
 

;+
;
; SINCE THERE IS CURRENTLY NO AST ADDRESS FOR POWER RECOVERY, AN ATTEMPT
; TO UN-SPECIFY USING THE "SPECIFY POWER RECOVERY AST" DIRECTIVE SHOULD
; FAIL.
;
;-
	$$STEP
	SPRA$S			;UN-SPECIFY AST
	MOV	#IE.ITS,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
;+
;
; THE "SPECIFY POWER RECOVERY AST", "DISABLE AST RECOGNITION", AND
; "ENABLE AST RECOGNITION" DIRECTIVES WILL ALL BE INVOKED WITH
; INVALID DPB'S.
;
;-
	$$STEP
;*****
	JMP	STP24		;STEP 21,22,23 DISABLED
;*****
	.PSECT	$DPB$$
	.ENABL	LSB
 
10$:	.BYTE	109.,0		;INVALID SPRA$ DPB
 
20$:	.BYTE	99.,0		;INVALID DSAR$ DPB
 
30$:	.BYTE	101.,20.	;INVALID ENAR$ DPB
 
 
	.PSECT	TST07A
 
	DIR$	#10$		;INVOKE INVALID SPRA$ DPB
	MOV	#IE.ADP,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
	DIR$	#20$		;INVOKE INVALID DSAR$ DPB
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
	DIR$	#30$		;INVOKE INVALID ENAR$ DPB
	MOV	#IE.SDP,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
 
	.DSABL	LSB
 
;+
;
; THIS STEP WILL ATTEMPT TO SERVICE AST'S AT AN ODD ADDRESS AND AT
; AN ADDRESS THAT IS NOT WITHIN THIS TASK'S ADDRESS RANGE.  SUCH
; ACTION SHOULD RESULT IN THE ACTIVATION OF A TASK SST.
;
;-
	$$STEP
	SVTK$S	#ASTERR,#2,.ABORT  ;SPECIFY A TASK SST VECTOR
	MOV	#AST2,R3	;SET ADDR OF AST SERVICE CODE
	MOV	#1,R4		;SPECIFY EFN #1
	MOV	R4,R5		;COPY IT INTO R5
	MRKT$S	R4,#1,#TICK,#1,.RJCT  ;SETUP FOR A FUTURE AST
	BCS	10$		;SKIP IF DIRECTIVE FAILED
	DIR$	#WT1,.RJCT	;WAIT FOR THE EVENT TO OCCUR
10$:	MOV	#160000,QIODPB+Q.IOAE  ;SPECIFY AN INVALID I/O AST ADDR
	MOV	#AST1,R3	;SPECIFY ADDR OF AST SERVICE CODE
	CLR	R5		;SET TOP OF STACK TO BE CLEAR
	DIR$	#QIODPB,.RJCT	;QUEUE I/O WITH AST SERVICE
	BCS	20$		;SKIP IF DIRECTIVE FAILED
	DIR$	#WT1,.RJCT	;WAIT FOR THE EVENT
20$:	TST	FP45		;CHECK FOR 45-FPU EXEC SUPPORT
	BEQ	30$		;SKIP IF NONE
	SFPA$S	#1,.RJCT	;ELSE, SPECIFY ODD FP-AST ADDR
	CALL	.SUCC		;CHECK FOR SUCCESS RETURN STATUS
	CMP	#45.,MTYPE	;IS MACHINE A PDP-11/45?
	BNE	30$		;SKIP IF NOT
	MOV	#AST20,R3	;SPECIFY ADDR OF AST SERVICE CODE
	MOV	#FP.ZDV,R4	;SET 45-FPU ERROR STATUS
	MOV	#25$,R5		;SET INSTRUCTION ADDR
	.DIVF	FZERO,AC0,<25$:>  ;ELSE, CAUSE 45-FP ZERO DIVIDE FAULT
	.WAIT			;WAIT FOR 45-FPU TRAP TO OCCUR
30$:	SPRA$S	#160000,.RJCT	;SPECIFY INVALID POWER RECOVERY AST ADDR
	CALL	.SUCC		;CHECK FOR SUCCESS RETURN STATUS
 
	.PSECT	ASTSST
 
SEGSST:	ADD	#6,SP		;STRIP SEG-FAULT SST ARGUMENTS FROM STK
ODDSST:	CMP	(SP)+,(SP)+	;CLEAN PC/PS FROM STACK
	JMP	(R3)		;PROCESS VIA DESIRED AST SERVICE CODE
 
 
	.PSECT	TST07A
 
;+
;
; THIS STEP ALLOWS THE USER TO PHYSICALLY TEST FOR THE ABILITY OF THE
; SYSTEM TO HANDLE POWERFAIL/RECOVERY AST'S.  FIRST, A MESSAGE IS SENT
; TO TI: ANNOUNCING THIS STEP.  DURING THE TIME SPAN, A SHORT
; MESSAGE IS SENT WHENEVER THE AST OCCURS.  AT THE END OF THE STEP
; A MESSAGE WILL BE PRINTED IF NO AST'S WERE SERVICED.
;
;-
	.ENABL	LSB
 
	$$STEP
	INC	AST		;SET AST INDICATOR
	CLR	QCNT		;CLEAR COUNT
	DIR$	#PWRFL,.RJCT	;SPECIFY POWER RECOVERY AST ENTRY
	BCS	100$		;SKIP IF DIRECTIVE FAILED
	CALL	.SUCC		;CHECK FOR SUCCESS RETURN STATUS
	MRKT$C	1,75.,SECOND,,TST07A,.RJCT  ;SET A FUTURE EVENT
	MOV	#.OBUF,R0	;PUT OUTPUT BUFFER ADDR IN R0
	MOV	#LMG01,R1	;PUT FORMAT ADDR IN R1
	MOV	SP,R2		;PUT ANY EVEN ADDR IN R2
	CALL	.PRTMG		;CREATE MESSAGE AND PRINT
	DIR$	#WT1,.RJCT	;WAIT
	TST	AST		;CHECK AST INDICATOR
	BEQ	100$		;SKIP IF POWER RECOVERY AST OCCURRED
	MOV	#.OBUF,R0	;ELSE, SETUP TO SEND MESSAGE ...
	MOV	#LMG03,R1	;... THAT NO AST'S WERE SERVICED
	MOV	SP,R2		;(PUT ANY EVEN ADDR IN R2)
	CALL	.PRTMG		;CREATE MESSAGE AND PRINT IT
100$:
 
	.DSABL	LSB
 
	.PSECT	PWFAST
 
POWAST:	CLR	AST		;UNSET THE AST INDICATOR
	INC	QCNT		;INCREMENT THE COUNT
	MOV	#.OBUF,R0	;PUT OUTPUT BUFFER ADDR IN R0
	MOV	#LMG02,R1	;PUT FORMAT ADDR IN R1
	MOV	#QCNT,R2	;PUT ARG ADDR IN R2
	CALL	.PRTMG		;CREATE MESSAGE AND PRINT
	JMP	ASTXT		;EXIT AST VIA COMMON CODE
 
	.PSECT	TST07A
 
;+
;
; THE TEST IS COMPLETE -- SEND MESSAGE AND EXIT.
;
;-
	$$STEP
	CALL	.ETST		;SEND END OF TEST MESSAGE
	EXIT$S	.RJCT		;AND EXIT
	.PAGE
;
; THE AST SERVICE ROUTINES FOLLOW.
;

;
;		'AST1'
;
; THIS IS THE TYPE ONE AST SERVICE ROUTINE.  IT COMPARES THE TOP OF THE
; STACK WITH R5.  IT CLEARS THE PROGRAM AST INDICATOR AND RETURNS.
;
;
AST1:	CLR	AST		;CLEAR PROGRAM AST INDICATOR
	CMP	R5,(SP)		;CHECK TOP OF STACK
	BEQ	1$		;SKIP IF O.K.
	CALL	.IDOUT		;ELSE, SETUP STEP IDENTIFICATION
	MOV	#LEM08,R1	;PUT FORMAT ADDR IN R1
	MOV	R5,-(SP)	;PUT ARG IN STACK

	MOV	SP,R2		;PUT ARG ADDR IN R2

	CALL	.PRTMG		;CREATE REST OF MESSAGE AND PRINT
	TST	(SP)+		;REMOVE MESSAGE ARG FROM STACK
1$:	TST	(SP)+		;REMOVE AST PARAMETER FROM STACK
 
ASTXT:	CMP	SP,STKPNT	;CHECK FOR PROPER STACK ADDRESS
	BEQ	10$		;SKIP IF IT'S O.K.
	MOV	STKPNT,-(SP)	;ELSE, CALCULATE THE NUMBER OF BYTES ...

	SUB	SP,(SP)		;... BY WHICH STACK ADDR IS WRONG
	SUB	#2,(SP)		;
	ASR	(SP)		;CONVERT RESULT TO WORDS
	CALL	.IDOUT		;SETUP STEP IDENTIFICATION
	MOV	#LEM09,R1	;PUT ERROR FORMAT ADDR IN R1
	MOV	SP,R2		;PUT ADDR OF ARGUMENT LIST IN R2
	CALL	.PRTMG		;FORMAT REST OF MESSAGE AND PRINT
	MOV	STKPNT,SP	;RESET STACK TO PROPER VALUE
10$:	ASTX$S	.ABORT		;RETURN FROM AST (OR ABORT)
;
;		'AST2'
;
; THIS IS THE TYPE TWO AST SERVICE ROUTINE.  IT CHECKS THE POLARITY OF
; THE EVENT FLAG SPECIFIED IN R4.  THEN IT RETURNS VIA AST1.
;
;
AST2:	SETF$S	R4,.RJCT	;SET EFN AND GET FORMER POLARITY
	BCS	1$		;LEAVE IF DIRECTIVE FAILED
	CMP	#IS.SET,@#$DSW	;CHECK FOR EVENT FLAG POLARITY SET
	BEQ	1$		;AND SKIP IF FLAG WAS SET
	CALL	.IDOUT		;SETUP STEP IDENTIFICATION
	MOV	#LEM01,R1	;PUT FORMAT ADDR IN R1
	CALL	.PRTMG		;CREATE REST OF MESSAGE & PRINT
1$:	BR	AST1		;BRANCH TO AST1 TO CONTINUE TESTING
;
;		'AST3'
;
; THIS IS THE TYPE 3 AST SERVICE ROUTINE.  IT CHECKS THAT THE I/O STATUS
; BLOCK AS SPECIFIED IN R5 IS NOT ZERO.  THEN IT JUMPS TO AST1 OR
; AST2 TO COMPLETE TESTING AND EXIT.
;
;
AST3:	TST	(R5)		;CHECK THE RETURNED I/O STATUS
	BNE	1$		;AND SKIP IF IT'S NOT ZERO
	CALL	.IDOUT		;ELSE, SETUP STEP IDENTIFICATION
	MOV	#LEM03,R1	;PUT FORMAT ADDR IN R1
	CALL	.PRTMG		;CREATE REST OF MESSAGE & PRINT
1$:	TST	R4
	BEQ	AST1		;BRANCH TO AST1 IF NO EFN SPECIFIED
	BR	AST2		;ELSE, AST2 CHECKS THE EVENT FLAG

;
;		'AST4'
;
; THIS AST WILL ATTEMPT TO INVOKE THE "SPECIFY FLOATING POINT EXCEPTION
; AST" AND THE "SPECIFY POWER RECOVERY AST" DIRECTIVES.  THEY SHOULD
; BOTH FAIL.
;
;
AST4:	CLR	AST		;CLEAR AST INDICATOR
	TST	FP45		;CHECK FOR EXEC 45-FPU SUPPORT
	BEQ	10$		;SKIP IF NONE
	SFPA$S			;SPECIFY F.P. AST
	MOV	#IE.AST,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
10$:	SPRA$S			;SPECIFY P.R. AST
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
	TST	(SP)+		;CLEAN STACK
	JMP	ASTXT		;EXIT AST VIA COMMON CODE
;
;		'AST10'
;
; THE FOLLOWING AST SERVICE ROUTINES ARE USED TO TEST FIFO AST QUEUING.
; THE DESCRIPTION OF THE TESTING IS FOUND IN THE MAIN TEST.
;
;
AST10:	CLR	M.KTEF(R3)	;CLEAR EVENT FLAG NUMBER IN THE DPB
	MOV	#AST11,M.KTAE(R3) ;SPECIFY AST ADDR
	DIR$	R3,.RJCT	;INVOKE "MARK TIME"
	MOV	#AST12,M.KTAE(R3) ;RESPECIFY AST ADDR
	DIR$	R3,.RJCT	;INVOKE MARK TIME AGAIN
	MOV	#AST13,M.KTAE(R3) ;USE NEW AST ADDR
	DIR$	R3,.RJCT	;INVOKE MARK TIME
	MOV	#AST14,M.KTAE(R3) ;USE NEW AST ADDR
	DIR$	R3,.RJCT	;INVOKE MARK TIME
	MOV	#2,M.KTEF(R3)	;SPECIFY EFN 2, AND
	INC	M.KTMG(R3)	;A TIME OF 2 TICKS, AND
	MOV	#AST15,M.KTAE(R3) ;A NEW AST ADDR
	DIR$	R3,.RJCT	;INVOKE MARK TIME AGAIN
	WTSE$S	#2,.RJCT	;WAIT FOR LAST TO QUEUE UP
	BR	QRTN		;BRANCH TO LEAVE THE AST SERVICE
;
;		'AST11'
;
;
AST11:	CLR	R5		;PUT EXPECTED STATE OF 'QAST' IN R5
	BR	QCHK		;AND CHECK OUT AST ORDER
;
;		'AST12'
;
;
AST12:	MOV	#1,R5		;'QAST' SHOULD BE ONE
	BR	QCHK		;CHECK THE QUEUED ORDER
;
;		'AST13'
;
;
AST13:	MOV	#2,R5		;'QAST' SHOULD BE TWO
	BR	QCHK		;BRANCH TO CHECK AST ORDER
;
;		'AST14'
;
;
AST14:	MOV	#3,R5		;'QAST' SHOULD BE 3 WHEN ENTER HERE
	BR	QCHK		;BRANCH TO CHECK AST ORDERING
;
;		'AST15'
;
;
AST15:	MOV	#4,R5		;WHEN HERE, 'QAST' SHOULD BE 4
QCHK:	CMP	R5,QAST		;IS IT RIGHT?
	BEQ	1$		;SKIP IF O.K.
	MOV	QAST,-(SP)	;PUSH ARGUMENTS ON STACK
	MOV	R5,-(SP)	;
	INC	(SP)		;CALC AST QUEUE NUMBER
	CALL	.IDOUT		;SETUP STEP IDENTIFICATION
	MOV	#LEM05,R1	;PUT FORMAT ADDR IN R1
	MOV	SP,R2		;PUT ADDR OF ARG LIST IN R2
	CALL	.PRTMG		;CREATE REST OF MESSAGE & PRINT
	ADD	#4,SP		;CLEAN MESSAGE PARAMETERS FROM STACK
1$:	INC	R5		;CALC AST NUMBER
	MOV	R5,QAST		;AND STORE IN 'QAST'
QRTN:	TST	(SP)+		;REMOVE "MARK TIME" ARG FROM AST STACK
	INC	QCNT		;INCREMENT QUEUED AST COUNT
	JMP	ASTXT		;EXIT AST VIA COMMON CODE
;
;		'AST30'
;
; THIS AST SERVICE ROUTINE IS USED TO HANDLE THE FLOATING POINT EXCEPTION
; TRAP USED TO TEST AST INHIBITION AND QUEUING.
;
;
AST30:	MOV	#-1,R5		;'QAST' IS EXPECTED TO BE MINUS ONE
	TST	(SP)+		;CLEAN ONE OF THE F.P. PARAMETERS FROM STK
	BR	QCHK		;CHECK THE QUEUED ORDER
;
;		'AST20'
;
; THIS IS THE AST SERVICE FOR FLOATING POINT EXCEPTION.  IT CHECKS R4 &
; R5 WITH THE TOP TWO ELEMENTS OF THE STACK.
;
;
AST20:	CLR	AST		;CLEAR AST INDICATOR
	CMP	R5,(SP)		;COMPARE ADDRESSES OF FAULTING INSTR
	BNE	1$		;SKIP IF NO MATCH
	CMP	R4,2(SP)	;COMPARE THE 45-FP ERROR CODES
	BEQ	2$		;SKIP IF THEY DO MATCH
1$:	CALL	.IDOUT		;ELSE, SETUP STEP IDENTIFICATION
	MOV	#LEM06,R1	;PUT FORMAT ADDR IN R1
	MOV	R4,-(SP)	;PUT EXPECTED CODE IN STACK
	MOV	R5,-(SP)	;PUT EXPECTED ADDR IN STACK
	MOV	SP,R2		;PUT ARG ADDR IN R2
	CALL	.PRTMG		;CREATE REST OF MESSAGE AND PRINT
	ADD	#4,SP		;CLEAN STACK OF MESSAGE ARGS
2$:	ADD	#4,SP		;CLEAN STACK OF F.P. AST ARGUMENTS
	JMP	ASTXT		;EXIT AST VIA COMMON CODE
	.PAGE
;
;		'ASTCHK'
;
; THIS SUBROUTINE IS USED TO CHECK THE PROGRAM AST INDICATOR.  IT SHOULD
; BE CLEAR AFTER LEAVING AN AST.  HENCE, IT DETECTS THE FAILURE TO SERVICE
; AN AST.
;
;
ASTCHK:	TST	AST		;TEST THE AST INDICATOR
	BEQ	1$		;SKIP IF CLEAR
	CALL	.IDOUT		;ELSE, SETUP STEP IDENTIFICATION
	MOV	#LEM02,R1	;PUT ADDR OF FORMAT IN R1
	CALL	.PRTMG		;CREATE REST OF MESSAGE AND SEND
1$:	RETURN			;RETURN TO THE TESTING


; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	.END	STP0
