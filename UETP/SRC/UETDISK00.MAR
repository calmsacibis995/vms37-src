	.TITLE	UETDISK00 - VAX/VMS UETP DISK EXERCISER
	.IDENT	'V03-000'
	.ENABLE	SUPPRESSION
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:
;	This module will be distributed with VAX/VMS under the [SYSTEST]
;	account.
;
; ABSTRACT:
;	Exercise testable units of a disk controller by writing and verifying
;	miscellaneous blocks of test files on those units.
;
; ENVIRONMENT:
;	This program will run in user access mode, with ASTs enabled except
;	during error processing.  The program requires an AST limit of 6, a
;	buffered I/O limit of 10(10) and no privileges.
;
;--
;
; AUTHOR: Richard N. Holstein, CREATION DATE: August, 1981
;
; MODIFIED BY:
;
;	V03-001	RNH0001		Richard N. Holstein,	11-Dec-1981
;		Allow further flexibility in testing by recovering from most
;		RMS$_FUL situations when creating a file.  Include PATTERN to
;		force a definite pattern to disk.  Give a message when we've
;		completely stopped testing a unit.  Suppress leading zeroes
;		when reading and remembering disk unit numbers.  Clean up old
;		files before creating new ones.
;
;**

	.SBTTL	Declarations
;
; INCLUDE FILES:
;
;	SYS$LIBRARY:LIB.MLB	for general definitions
;	SHRLIB$:UETP.MLB	for UETP definitions
;
; MACROS:
;
	$CHFDEF				; Condition handler frame definitions
	$DEVDEF				; Device definitions
	$DIBDEF				; Device Information Block
	$SHRDEF				; Shared messages
	$STSDEF				; Status return
	$UETUNTDEF			; UETP unit block offset definitions
	$UETPDEF			; UETP
;
; EQUATED SYMBOLS:
;
;   Facility number definitions:
	UETP_K = 116
	RMS_K = 1

;   SHR message definitions:
	UETP = UETP_K@STS$V_FAC_NO	; Define the UETP facility code
;
	UETP$_ABENDD = UETP!SHR$_ABENDD	; Define the UETP message codes
	UETP$_BEGIND = UETP!SHR$_BEGIND
	UETP$_ENDEDD = UETP!SHR$_ENDEDD
	UETP$_OPENIN = UETP!SHR$_OPENIN
	UETP$_TEXT   = UETP!SHR$_TEXT

;   Internal flag bits...:
	TEST_OVERV   = 1		; Set when test is over
	SAFE_TO_UPDV = 2		; Set when it's safe to update UETINIDEV
	BEGIN_MSGV   = 3		; Set when "begin" msg has been output
	ONE_SHOTV    = 4		; Set if running in one-shot mode
	PATTERNV     = 5		; Set if specific pattern data to write
;   ...and corresponding masks:
	TEST_OVERM   = 1@TEST_OVERV
	SAFE_TO_UPDM = 1@SAFE_TO_UPDV
	BEGIN_MSGM   = 1@BEGIN_MSGV
	ONE_SHOTM    = 1@ONE_SHOTV
	PATTERNM     = 1@PATTERNV

;   Miscellany:
	LC_BITM       = ^X20		; Mask to convert lower case to upper
	REC_SIZE      = 20		; UETINIDEV.DAT record size
	TEXT_BUFFER   = 132		; Internal text buffer size
	EFN2          = 4		; EFN used for three minute timer
	MAX_PROC_NAME = 15		; Longest possible process name
	MAX_DEV_DESIG = 8		; Longest possible controller name
	MAX_UNIT_DESIG= 5		; Longest possible unit number

;   Disk specific definitions:
	WRITE_SIZE      = 512*4		; RSZ buffer size
	READ_SIZE       = WRITE_SIZE	; USZ buffer size (both use same buffer)
	PERCENTAGE      = ^F0.05	; Percentage for incrementing files
	TOP_PCT         = ^F0.75	; Maximum percentage of unit we use
	FN_LEN          = 9		; Assumed maximum file name length
	BAKERS          = 20		; Baker's dozen: determine when to expand
	DISK_K_PATTERN  = ^X55555555	; Contents of test file FAB's CTX field
	DISK_K_CREATE   = 1		; Code to say current func is $CREATE
	DISK_V_NOCREATE = UETUNT$V_TESTABLE+1 ; On if $CREATE failed
	DISK_M_NOCREATE = 1@DISK_V_NOCREATE
	DISK_V_NOEXTEND = DISK_V_NOCREATE+1 ; On if $EXTEND failed
	DISK_M_NOEXTEND = 1@DISK_V_NOEXTEND

;
; For each file on each unit, there will be a data structure set up, called a
; node.  These nodes will be linked together in a self-relative queue whose
; header is UNIT_LIST.  The first part of each node will be the standard
; definition from $UETUNTDEF.  Following that will come the device test
; dependent stuff, defined below.  NOTE THAT THIS DEFINITION IS DONE WITH AN
; ABSOLUTE PSECT.  This means that what look like declarations are really
; definitions and the labels are really just offsets into a given node on the
; queue.  (A not necessarily obvious consequence of using an ABS PSECT is that
; space must be reserved with .BLKx operations, since .BYTE, etc., attempt to
; store data.)  This data structure differs from most other device tests in
; that there is more than one node per unit in normal and loop forever modes.
;
	.PSECT	DEVDEP_STR_DEF,ABS,NOEXE,NOWRT ; Note ABS attribute!

	.BLKB	UETUNT$C_DEVDEP		; Skip over standard UETUNT block

DISK_W_UNIT:				; This unit number
	.BLKW	1

DISK_B_FILE:				; Number of this file on this unit
	.BLKB	1

DISK_L_OTHER_PTR:			; Ptr to other file node on this unit
	.BLKL	1

DISK_L_TOP_PCT:				; Maximum space we'll use on this unit
	.BLKL	1

DISK_L_SIZE:				; Cur. size of this file on this unit
	.BLKL	1

	DEVDEP_SIZE = .-UETUNT$C_DEVDEP ; Device dependent part size of node
					; Note that this excludes buffers

DISK_K_BUFFER:				; I/O buffer for both reads and writes
	.BLKB	WRITE_SIZE

	PAGES = <<UETUNT$C_INDSIZ+-	; Add together all of the pieces...
		  DEVDEP_SIZE+-		; ...which make up a UETP unit block...
		  WRITE_SIZE+511>/512>	; ...to give to the $EXPREG service

	.SBTTL	Read-Only Data
	.PSECT	RODATA,NOEXE,NOWRT,PAGE

ACNT_NAME:				; Process name on exit
	.ASCID	/SYSTEST/

TEST_NAME:				; This test name
	.ASCID	/UETDISK00/

SUPDEV_GBLSEC:				; How we access UETSUPDEV.DAT
	.ASCID	/UETSUPDEV/

CONTROLLER:				; Logical name of controller
	.ASCID	/CTRLNAME/		;

MODE:					; Run mode logical name
	.ASCID	/MODE/

CS1:					; Device class and type control string
	.ASCID	/!2XB !2XB /

CS3:					; Device class-only control string
	.ASCID	/!2XB **/

TTNAME_ROPTR:				; Descriptor for recursive...
	.WORD	63,0			; ...translation of TTNAME
	.ADDRESS TTNAME

CNTRLCMSG:
	.ASCID	\Aborted via a user CTRL/C\

NO_CTRLNAME:
	.ASCID	/No controller specified./

DEAD_CTRLNAME:
	.ASCID	/Can't test controller !AS, marked as unusable in UETINIDEV.DAT./

NOUNIT_SELECTED:
	.ASCID	/No units selected for testing./

ILLEGAL_REC:
	.ASCID	/Illegal record format in file UETINIDEV.DAT!/

PASS_MSG:
	.ASCID	/End of pass !UL with !UL iterations at !%D./

THREEMIN:				; 3 minute delta time
	.LONG	-10*1000*1000*180,-1

UNIT_DESC:				; Descriptor used to convert unit #
	.LONG	5
	.ADDRESS BUFFER+6

CONT_DESC:				; Descriptor used to convert controller...
	.WORD	REC_SIZE,0		; ...from lowercase to uppercase
	.ADDRESS BUFFER

FILE:					; Fills in RMS_ERR_STRING
	.ASCID	/file/

RECORD:					; Fills in RMS_ERR_STRING
	.ASCID	/record/

RMS_ERR_STRING:				; Announces an RMS error
	.ASCID	/RMS !AS error in file !AD/

PROMPT:
	.ASCII	/Controller designation?: /
	PMTSIZ = .-PROMPT

SYSTEST_DIR:				; Part of filespec for test files...
	.ASCIC	/[SYSTEST]/		; ...if they're on a scratch pack

SYS0_SYSTEST_DIR:			; Part of filespec for test files...
	.ASCIC	/[SYS0.SYSTEST]/	; ...if they're on a V3 system pack

DOTTST:					; Part of filespec for test files
	.ASCIC	/.TST/

PATTERN:				; Logical name to specify pattern...
	.ASCID	/PATTERN/		; ...to write to test files

	.SBTTL	Read/Write Data
	.PSECT	RWDATA,WRT,NOEXE,PAGE

TTCHAN:					; Channel associated with ctrl. term.
	.WORD	0

TTNAME_RWPTR:				; Descriptor for recursive...
	.WORD	TTNAME_LEN,0		; ...translation of TTNAME
	.ADDRESS TTNAME
TTNAME:					; Logical name of controlling terminal
	.ASCII	/SYS$INPUT/
	TTNAME_LEN = .-TTNAME
	.BLKB	63-TTNAME_LEN		; Space for recursive translation

FLAG:					; Miscellaneous flag bits
	.WORD	0			; (See Equated Symbols for definitions)

FAO_BUF:				; FAO output string descriptor
	.WORD	TEXT_BUFFER,0
	.ADDRESS BUFFER

BUFFER_PTR:				; Fake .ASCID buffer for misc. strings
	.WORD	TEXT_BUFFER,0		; A word for length, a word for desc.
	.ADDRESS BUFFER

BUFFER:					; FAO output and other misc. buffer
	.BLKB	TEXT_BUFFER

DEVDSC:					; Device name descriptor
	.WORD	MAX_DEV_DESIG,0
	.ADDRESS DEV_NAME


; NOTE THAT THE CODE DEPENDS ON THE FOLLOWING TWO ITEMS BEING TOGETHER.
PROCESS_NAME:				; Process name
	.ASCID	/UETDISK00_/
DEV_NAME:				; Device name buffer
	.BLKB	MAX_DEV_DESIG+MAX_UNIT_DESIG
	NAME_LEN = .-DEV_NAME
; END OF ITEMS WHICH CODE DEPENDS ON BEING TOGETHER.


DIB:					; Device Information Block
	.WORD	DIB$K_LENGTH,0
	.ADDRESS DIBBUF
DIBBUF:
	.BLKB	DIB$K_LENGTH

ERROR_COUNT:				; Cumulative error count at runtime
	.LONG	0

STATUS:					; Status value on program exit
	.LONG	0

STAT:					; IO status block
	.QUAD	0

AST_MODE:				; Prior setting of AST delivery
	.LONG	0

SS_FAIL_MODE:				; Prior setting of SS failure mode
	.LONG	0

INADDRESS:				; $CRMPSC address storage
	.LONG	0,0
OUTADDRESS:
	.LONG	0,0

UNIT_NUMBER:				; Current dev unit number
	.WORD	0

DEVNAM_LEN:				; Current device name length
	.WORD	0

; RANDOM1 and RANDOM2 may be combined to produce a set of pseudo-random numbers
RANDOM1:				; Random word #1
	.LONG	^XAAAAAAAA

RANDOM2:				; Random word #2
	.LONG	^XA72EA72E

ITERATION:				; # of times all tests were executed
	.LONG	0

PASS:					; Pass count
	.LONG	0

MSG_BLOCK:				; Auxiliary $GETMSG info
	.BLKB	4

EXIT_DESC:				; Exit handler descriptor
	.LONG	0
	.ADDRESS EXIT_HANDLER
	.LONG	1
	.ADDRESS STATUS

ARG_COUNT:				; Argument counter used by ERROR_EXIT
	.LONG	0

	.ALIGN QUAD			; For self-relative queue of unit blocks

UNIT_LIST:				; Head of unit block circular list
	.QUAD	0

NEW_NODE:				; Newly acquired node address
	.QUAD	0

RANDOM_DATA:				; Buffer to fill with "random" data
	.BLKL	<WRITE_SIZE+3>/4	; Ensure it's a multiple of longwords

PATTERN_DATA:				; Holds pattern to write to test...
	.BLKL	1			; ...files if PATTERN is defined

	.SBTTL	RMS-32 Data Structures
	.ALIGN	LONG

SYSIN_FAB:				; Allocate FAB for SYS$INPUT
	$FAB-
	FNM = <SYS$INPUT:>

SYSIN_RAB:				; Allocate RAB for SYS$INPUT
	$RAB-
	FAB = SYSIN_FAB,-
	ROP = PMT,-
	PBF = PROMPT,-
	PSZ = PMTSIZ,-
	UBF = DEV_NAME,-
	USZ = NAME_LEN

INI_FAB:				; Allocate FAB for UETINIDEV
	$FAB-
	FAC = <GET,PUT,UPD>,-
	RAT = CR,-
	SHR = <GET,PUT,UPI>,-
	FNM = <UETINIDEV.DAT>

INI_RAB:				; Allocate RAB for UETINIDEV
	$RAB-
	FAB = INI_FAB,-
	RBF = BUFFER,-
	UBF = BUFFER,-
	USZ = REC_SIZE

DDB_RFA:				; RFA storage for INI_RAB
	.BLKB	6

	.ALIGN	LONG
SUP_FAB:				; Allocate FAB for UETSUPDEV
	$FAB-
	FAC = GET,-
	SHR = <UPI,GET>,-
	RAT = CR,-
	FOP = UFO,-
	FNM = <UETSUPDEV.DAT>
;
; Dummy FAB and RAB to copy to the UETP unit blocks
; The following FAB and RAB must be contiguous and in this order!
;

DUMMY_FAB:
	$FAB-
	CTX = DISK_K_PATTERN,-		; This will identify a test file
	FAC = <BIO,PUT,GET>,-
	MRS = WRITE_SIZE,-
	ORG = SEQ,-
	RFM = UDF

DUMMY_RAB:
	$RAB-
	ROP = <ASY,BIO>,-		; RAB$M_ASY cleared in one-shot mode
	RSZ = WRITE_SIZE,-
	USZ = READ_SIZE

	.SBTTL	Test and Device Initialization
	.PSECT	DISK,EXE,NOWRT,PAGE

	.DEFAULT DISPLACEMENT,WORD

;+
;	Start up the disk test.  This entails some overhead necessary to cope
;	with both expected and unforseen conditions, figuring out just what
;	devices are to be tested, making sure we can test the indicated devices
;	and setting up writeable space for each device to be tested.
;-

.ENTRY	UETDISK00,^M<>			; Entry mask

	MOVAL	SSERROR,(FP)		; Declare exception handler
	$SETSFM_S ENBFLG = #1		; Enable system service failure mode
	$DCLEXH_S DESBLK = EXIT_DESC	; Declare an exit handler
	$TRNLOG_S LOGNAM = TTNAME_RWPTR,- ; See if there is some SYS$INPUT
		  RSLBUF = BUFFER_PTR
	CMPL	R0,#SS$_NOTRAN		; Is there some translation?
	BEQL	20$			; BR if no SYS$INPUT assigned
	$OPEN	FAB = SYSIN_FAB,-	; Open SYS$INPUT
		ERR = RMS_ERROR
	$CONNECT RAB = SYSIN_RAB,-	; Connect RAB to SYS$INPUT
		 ERR = RMS_ERROR
	BBC	#DEV$V_TRM,-		; BR if SYS$INPUT is NOT a terminal
		SYSIN_FAB+FAB$L_DEV,10$
	$TRNLOG_S LOGNAM = CONTROLLER,-	; Get the name of our disk
		  RSLLEN = DEVNAM_LEN,-
		  RSLBUF = DEVDSC
	CMPL	R0,#SS$_NORMAL		; Was a controller specified?
	BEQL	PROC_CONT_NAME		; BR if it was - go process it
10$:
	$GET	RAB = SYSIN_RAB,-	; Read SYS$INPUT for controller name
		ERR = RMS_ERROR
	MOVW	SYSIN_RAB+RAB$W_RSZ,-	; Save the name length
		DEVNAM_LEN
	BNEQ	PROC_CONT_NAME		; BR if we got something
20$:
	MOVL	#SS$_BADPARAM,STATUS	; Save the exit status
	PUSHAL	NO_CTRLNAME		; Prepare for message...
	PUSHL	#1			; ...
	PUSHL	#UETP$_TEXT!STS$K_ERROR ; ...
	PUSHL	#3			; ...
	BRW	ERROR_EXIT		; ...to tell of bad setup

PROC_CONT_NAME:
	MOVW	DEVNAM_LEN,DEVDSC	; Set the device name length
	PUSHAL	DEVDSC			; Make sure...
	PUSHAL	DEVDSC			; ...that the specified controller...
	CALLS	#2,G^STR$UPCASE		; ...is all uppercase for later comparison
	ADDW2	DEVNAM_LEN,PROCESS_NAME	; Get true process name length
	CMPW	PROCESS_NAME,#MAX_PROC_NAME ; Is the result too long for VMS?
	BLEQ	10$			; BR if not
	MOVW	#MAX_PROC_NAME,PROCESS_NAME ; Make it as long as you can
10$:
	CLRL	-(SP)			; Set the time stamp flag
	PUSHAL	PROCESS_NAME		; Set the test name
	PUSHL	#2			; Push the argument count
	PUSHL	#UETP$_BEGIND!STS$K_SUCCESS ; Set the message code
	CALLS	#4,G^LIB$SIGNAL		; Print the startup message
	BISW2	#BEGIN_MSGM,FLAG	; Set flag so we don't output it again
	$SETPRN_S PRCNAM = PROCESS_NAME	; Set the process name to UETDISK00_yyn
	BBS	#DEV$V_TRM,-		; BR if SYS$INPUT is a terminal
		SYSIN_FAB+FAB$L_DEV,20$
	BRW	40$
20$:
	$TRNLOG_S LOGNAM = TTNAME_RWPTR,- ; Recursively translate the name...
		  RSLLEN = TTNAME_RWPTR,- ; ...of our controlling terminal
		  RSLBUF = TTNAME_ROPTR
	MOVAL	TTNAME,TTNAME_RWPTR+4	; Undo possible previous PPF fixup
	CMPL	R0,#SS$_NOTRAN		; Have we reached the end yet?
	BEQL	30$			; BR if we have
	CMPW	#^X001B,TTNAME		; Is this a Process Permanent File?
	BNEQ	20$			; Recursively translate if not
	SUBW	#4,TTNAME_RWPTR		; Remove RMS overhead from PPF name
	ADDL2	#4,TTNAME_RWPTR+4
	BRB	20$
30$:
	$ASSIGN_S DEVNAM = TTNAME_RWPTR,- ; We always need to assign a channel
		  CHAN   = TTCHAN	  ; Returned channel number
	$QIOW_S	CHAN     = TTCHAN,-	; Enable CTRL/C AST's...
		FUNC     = #IO$_SETMODE!IO$M_CTRLCAST,-
		P1       = CCASTHAND
	PUSHAL	TEST_NAME		; ...and tell the user...
	PUSHL	#1			; ...
	PUSHL	#UETP$_ABORTC!STS$K_SUCCESS ; ...how to abort gracefully...
	CALLS	#3,G^LIB$SIGNAL		; ...
40$:
	$TRNLOG_S LOGNAM = MODE,-	; Get the run mode
		  RSLLEN = BUFFER_PTR,-
		  RSLBUF = FAO_BUF
	BICB2	#LC_BITM,BUFFER		; Convert to upper case
	CMPB	#^A/O/,BUFFER		; Is this a one shot?
	BNEQ	45$			; BR if not
	BISW2	#ONE_SHOTM,FLAG		; Set flag for one-shot mode...
	BICL2	#RAB$M_ASY,DUMMY_RAB+RAB$L_ROP ; ...and clear asynchronous flag
45$:
	$TRNLOG_S LOGNAM = PATTERN,-	; Do we have a specific pattern...
		  RSLLEN = BUFFER_PTR,-	; ...to write to all buffers?
		  RSLBUF = FAO_BUF
	BLBC	R0,47$			; BR if we don't
	PUSHAL	PATTERN_DATA		; We may...
	PUSHAL	BUFFER_PTR		; ...
	CALLS	#2,G^OTS$CVT_TZ_L	; ...convert ASCII pattern to binary
	BLBC	R0,47$			; BR if there's an error
	BISW2	#PATTERNM,FLAG		; Indicate the presence of a pattern
47$:

;
; From UETINIDEV.DAT and UETSUPDEV.DAT, get information which gives controller
; and unit configuration and lets us know if the setup to run this test was
; done correctly.  Allocate space for each file on a unit.
;
	$OPEN	FAB = INI_FAB,-		; Open file "UETINIDEV.DAT"
		ERR = RMS_ERROR
	$CONNECT RAB = INI_RAB,-	; Connect the RAB and FAB
		 ERR = RMS_ERROR
	$MGBLSC_S  INADR = INADDRESS,-	; Connect to UETSUPDEV global section
		  RETADR = OUTADDRESS,-
		  GSDNAM = SUPDEV_GBLSEC,-
		   FLAGS = #SEC$M_EXPREG
	CMPL	R0,#SS$_NOSUCHSEC	; Was the section already there?
	BNEQ	50$			; BR if it was...
	$OPEN	FAB = SUP_FAB,-		; ...else open "UETSUPDEV.DAT"
		ERR = RMS_ERROR
	$CRMPSC_S CHAN = SUP_FAB+FAB$L_STV,- ; Create the global section
		 INADR = INADDRESS,-
		RETADR = OUTADDRESS,-
		GSDNAM = SUPDEV_GBLSEC,-
		 FLAGS = #SEC$M_EXPREG!SEC$M_GBL
50$:
	SUBL3	OUTADDRESS,OUTADDRESS+4,R6 ; Create global section length

FIND_IT:
	$GET	RAB = INI_RAB,-		; Get the first record
		ERR = RMS_ERROR
	PUSHAL	CONT_DESC		; Make sure...
	PUSHAL	CONT_DESC		; ...that the controller name...
	CALLS	#2,G^STR$UPCASE		; ...is all uppercase letters
	CMPB	#^A/D/,BUFFER		; Is this a DDB?
	BEQL	10$			; Go on if not
	CMPB	#^A/E/,BUFFER		; Is this the end of the file?
	BNEQ	FIND_IT			; Continue on if not
	PUSHAL	DEVDSC			; Push device not supported message
	PUSHAL	PROCESS_NAME		; Parameters on the stack
	PUSHL	#2
	PUSHL	#UETP$_DENOSU
	INSV	#STS$K_ERROR,-
		#STS$V_SEVERITY,-
		#STS$S_SEVERITY,(SP)	; Set the severity code...
	MOVL	(SP),STATUS		; ...and save it as the exit status
	PUSHL	#4
	BRW	ERROR_EXIT		; Exit in error
10$:
	CMPC	DEVNAM_LEN,BUFFER+6,DEV_NAME ; Is this the right controller?
	BNEQ	FIND_IT			; BR if not
	MOVC3	#6,INI_RAB+RAB$W_RFA,DDB_RFA ; Save the record file address
	CMPB	#^A/T/,BUFFER+4		; Can we test this controller?
	BEQL	FOUND_IT		; BR if we can...
	$FAO_S	CTRSTR = DEAD_CTRLNAME,- ; ...and yell at user if we can't
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = #DEVDSC
	MOVL	#SS$_BADPARAM,STATUS	; Set return status
	PUSHAL	BUFFER_PTR		; ...
	PUSHL	#1			; ...
	PUSHL	#UETP$_TEXT!STS$K_ERROR	; ...
	PUSHL	#3			; ...
	BRW	ERROR_EXIT		; We can't test what we can't test

FOUND_IT:
	$GET	RAB = INI_RAB,-		; Get a record
		ERR = RMS_ERROR
	PUSHAL	CONT_DESC		; Make sure...
	PUSHAL	CONT_DESC		; ...that this line...
	CALLS	#2,G^STR$UPCASE		; ...is all uppercase letters
	CMPB	#^A/U/,BUFFER		; Is this a UCB?
	BEQL	20$			; BR if it is
	CMPB	#^A/D/,BUFFER		; Is this a DDB?
	BEQL	10$			; BR if yes
	CMPB	#^A/E/,BUFFER		; Is this the end?
	BEQL	10$			; BR if yes
5$:
	PUSHAL	ILLEGAL_REC		; Then this is an error in the record
	PUSHL	#1			; Push the error message
	PUSHL	#UETP$_TEXT!STS$K_ERROR ; Push the signal name
	PUSHL	#3			; Push the temp arg count
	BRW	ERROR_EXIT		; Finish for good
10$:
	BRW	ALL_SET			; Found DDB or END
20$:
	CMPB	#^A/T/,BUFFER+4		; Is the unit testable?
	BNEQ	FOUND_IT		; BR if not
	PUSHL	#1			; Flag to ignore blanks when converting
	PUSHL	#2			; Set byte size of results
	PUSHAL	UNIT_NUMBER		; Set address to receive word
	PUSHAL	UNIT_DESC		; Push string address
	CALLS	#4,G^OTS$CVT_TZ_L	; Convert ASCII unit number to hex
	BLBC	R0,5$			; Don't allow a bogus unit to pass
	SKPC	#^A/ /,#MAX_UNIT_DESIG,-
		BUFFER+6		; Find out where unit number really is
	DECL	R0			; Units must all be at least one digit
	SKPC	#^A/0/,R0,(R1)		; Skip leading zeroes in the unit
	INCL	R0			; Correct for the above DECL
	ADDW3	R0,DEVNAM_LEN,DEVDSC	; Calculate device'unit string length
	MOVZWL	DEVNAM_LEN,R2		; Offset to unit number in DEVDSC
	MOVC3	R0,(R1),DEV_NAME(R2)	; Append unit number to device
	$GETDEV_S DEVNAM = DEVDSC,-	; Get the device characteristics
		  PRIBUF = DIB
	MOVZBL	DIBBUF+DIB$B_DEVCLASS,R7 ; Save the device class
	MOVZBL	DIBBUF+DIB$B_DEVTYPE,R8	; Save the device type
	$FAO_S	CTRSTR = CS1,-
		OUTBUF = FAO_BUF,-
		P1     = R7,-
		P2     = R8		; Make it into a string
	MATCHC	#6,BUFFER,R6,@OUTADDRESS ; Find the device class and type
	BEQL	30$			; BR if it was found
	$FAO_S	CTRSTR = CS3,-		; Try for full class support
		OUTBUF = FAO_BUF,-
		    P1 = R7
	MATCHC	#6,BUFFER,R6,@OUTADDRESS ; Find the device class only
	BNEQ	40$			; BR if not found
30$:
	MOVZBL	TEST_NAME,R5		; Get the test name length
	CMPC3	R5,(R3),TEST_NAME+8	; Are we the right test?
	BEQL	50$			; BR if yes
40$:
	PUSHAL	DEVDSC			; Push device not supported message
	PUSHAL	PROCESS_NAME		; Parameters on the stack
	PUSHL	#2			; Push the argument count
	PUSHL	#UETP$_DENOSU
	INSV	#STS$K_ERROR,-
		#STS$V_SEVERITY,-
		#STS$S_SEVERITY,(SP)	; Set the severity code...
	MOVL	(SP),STATUS		; ...and save it as the exit status
	PUSHL	#4			; Push the partial arg count...
	BRW	ERROR_EXIT		; ...and split this scene
50$:
	PUSHL	#0			; Allocate and initialize...
	CALLS	#1,UNIT_FILE_SETUP	; ...space for file 0 on this unit
	BBS	#ONE_SHOTV,FLAG,60$	; Set up file 0 only if one-shot mode
	PUSHL	R0			; Save pointer so file 1 can point here
	PUSHL	#1			; Allocate and initialize...
	CALLS	#1,UNIT_FILE_SETUP	; ...space for file 1 on this unit
	POPL	R1			; Have file 0...
	MOVL	R0,DISK_L_OTHER_PTR(R1)	; ...point to file 1...
	MOVL	R1,DISK_L_OTHER_PTR(R0)	; ...and file 1 point to file 0
60$:
	BRW	FOUND_IT		; Do the next UCB

;
; Arrive here when we have the device configuration.  In normal or loop forever
; mode, set a timer far enough in the future such that we can do a reasonable
; set of tests before the timer expires, but if our device gets hung, the
; program won't waste too much time before noticing.  Let one-shot mode be a
; special case.
;
ALL_SET:
	TSTL	UNIT_LIST		; Anything to test?
	BNEQ	10$			; BR if yes
	PUSHAL	NOUNIT_SELECTED		; Else set up the error message...
	PUSHL	#1			; ...argument count...
	PUSHL	#UETP$_TEXT!STS$K_ERROR	; ...signal name...
	PUSHL	#3			; ...and parameter count
	MOVL	#SS$_BADPARAM,STATUS	; Set return status
	BRW	ERROR_EXIT		; ...and give up, complaining
10$:
	BISW2	#SAFE_TO_UPDM,FLAG	; OK, safe to update UETINIDEV.DAT now
	MOVL	DEVNAM_LEN,DEVDSC	; DEVDSC will describe controller name
	BBS	#ONE_SHOTV,FLAG,RESTART	; In one-shot mode start testing now...
					; ...else fall into TIME_IT

TIME_IT:
	$SETIMR_S DAYTIM = THREEMIN,-	; Set timer AST to 3 minutes
		  ASTADR = TIME_OUT,-
		  EFN    = #EFN2

	.SBTTL	Test the Disk

RESTART:
;
; At this point the controller designation is in location DEV_NAME pointed to
; by descriptor DEVDSC.  The controller is known to be supported by this test.
;
	BBC	#PATTERNV,FLAG,5$	; BR if we're allowing various patterns
	MOVL	PATTERN_DATA,RANDOM1	; We're forcing a specific pattern
5$:
	MOVAL	RANDOM_DATA,R6		; Set up...
	MOVL	#<WRITE_SIZE+3>/4,R7	; ...a bufferful of longwords...
10$:
	BBS	#PATTERNV,FLAG,15$	; ...which can be either pattern...
	ADDL2	RANDOM2,RANDOM1		; ...or pseudo_random...
15$:
	MOVL	RANDOM1,(R6)+		; ...data...
	SOBGTR	R7,10$			; ...
;
; For each unit-file node in the queue, clean up any old version of the file we
; want to create and create a new file.  The FABs are already set up such that
; each file uses PERCENTAGE blocks of the total space on the disk, the files
; names are controller'unit'x, where "x" is either "0" or "1", and the files
; will be accessed in Block I/O mode by RMS.  In normal and loop forever modes,
; the test will proceed asynchronously with the file I/O.  In one-shot mode,
; I/O will be a single, synchronous write/read per file, handled separately.
;
	ADDL3	UNIT_LIST,#UNIT_LIST,R6	; R6 will point to the current node
20$:
	BSBW	PRE_CLEAN		; Remove leftover files from previous run
	MOVW	#DISK_K_CREATE,UETUNT$W_FUNC(R6) ; Indicate func in case error
	BISB2	#UETUNT$M_TESTABLE,-	; Assume file will be testable and...
		UETUNT$B_FLAGS(R6)
	BICB2	#DISK_M_NOCREATE!DISK_M_NOEXTEND,-
		UETUNT$B_FLAGS(R6)	; ...$CREATE and $EXTEND succeed
	$CREATE	FAB = UETUNT$K_FAB(R6)	; Try to create a file on a disk unit
	BSBW	CREATE_CHECK		; Check for errors, recover from some
	BBC	#UETUNT$V_TESTABLE,-	; Skip $CONNECT if $CREATE failed
		UETUNT$B_FLAGS(R6),40$
	CLRW	UETUNT$W_FUNC(R6)	; Reset func for error handling
	MOVL	UETUNT$K_FAB+FAB$L_ALQ(R6),- ; Set current file size
		DISK_L_SIZE(R6)
	CLRL	UETUNT$K_RAB+RAB$L_BKT(R6) ; Initialize current block
	CLRL	UETUNT$L_ITER(R6)	; Reset iteration count if loop forever
	MOVAL	WRITE_NEXT,R7		; Assume normal or loop mode asynch I/O
	BBC	#ONE_SHOTV,FLAG,30$	; BR if that is indeed the case
	CLRL	R7			; One-shot mode, no SUC= return
30$:
	$CONNECT RAB = UETUNT$K_RAB(R6),- ; Set up the file's record access
		 ERR = RMS_ERROR,-
		 SUC = (R7)
40$:
	ADDL2	(R6),R6			; Loop through all units in the queue
	CMPL	R6,#UNIT_LIST		; Back at the head of the queue?
	BNEQ	20$			; BR if not

;
; All the $CREATEs and $CONNECTs are done.  Before we try to hibernate in
; normal or loop forever modes, or start I/O in one-shot mode, see if any
; files were started successfully.  R6 is still points to UNIT_LIST.
;
50$:
	ADDL2	(R6),R6			; Point to the next possible node
	CMPL	R6,#UNIT_LIST		; Back at the head of the queue?
	BNEQ	60$			; Check this node if not
	BRW	TEST_OVER		; Nothing left to test so go home
60$:
	BBC	#UETUNT$V_TESTABLE,-	; Pass to next node if this one...
		UETUNT$B_FLAGS(R6),50$	; ...isn't testable
					; Otherwise start testing

	BBS	#ONE_SHOTV,FLAG,ONE_SHOT_TEST ; Synchronous I/O if one-shot mode
;
; We'll arrive here in normal or loop forever testing modes.
; All testable units have their files started up.  Life proceeds asynchronously
; as write requests are issued and the results are verified.  The AST routines
; are responsible for that as well as file expansion.  The process terminates
; when the $SETIMR alarm goes off and wakes us from the following...
;
	$HIBER_S			; File testing continues via ASTs
;
; We return when all testing est finis.  Clean up any messy files.
;
	BSBW	CLEAN_UP		; This closes and erases files
	BRB	SUC_EXIT		; Go finish off this pass of the test

;
; Get here only in one-shot testing mode.
; All testable units have their files started up.  We'll do one write/verify
; pair per file.  Since everything is synchronous except error handling, all
; the code is inline.
;
ONE_SHOT_TEST:
	ADDL3	UNIT_LIST,#UNIT_LIST,R7	; This will point to the current node
10$:
	MOVAL	UETUNT$K_RAB(R7),R6	; Point to the RAB in current node
	BBC	#UETUNT$V_TESTABLE,-	; Skip node if not testable
		UETUNT$B_FLAGS(R7),20$
	MOVL	#1,RAB$L_BKT(R6)	; Pick a record to write
	MOVAL	RANDOM_DATA,RAB$L_RBF(R6) ; Indicate write buffer
	$WRITE	RAB = (R6),-		; Write a record
		ERR = RMS_ERROR
	BBC	#UETUNT$V_TESTABLE,-	; Skip node if not testable
		UETUNT$B_FLAGS(R7),20$
	MOVC5	#0,(R7),#0,#WRITE_SIZE,DISK_K_BUFFER(R7) ; Clear the read buffer
	$READ	RAB = (R6),-		; Read a record
		ERR = RMS_ERROR
	CMPC3	#READ_SIZE,RANDOM_DATA,- ; Verify a record
		DISK_K_BUFFER(R7)
	BEQL	20$
	CLRL	RAB$L_BKT(R6)		; Indicate random data for last...
					; ...block read (see GET_PATTERN)
	BSBW	VERIFY_ERROR		; Yell out the error
20$:
	ADDL2	(R7),R7			; Loop through all units in the queue
	CMPL	R7,#UNIT_LIST		; Back at the head of the queue?
	BNEQ	10$			; BR if more nodes to test

	BISW2	#TEST_OVERM,FLAG	; Indicate a normal test termination
	BSBW	CLEAN_UP		; Close and erase files
	;BRW	SUC_EXIT		; Fall into finishing off the test

SUC_EXIT:
	$TRNLOG_S LOGNAM = MODE,-
		  RSLLEN = BUFFER_PTR,-
		  RSLBUF = FAO_BUF	; Get the run mode
	BICB2	#LC_BITM,BUFFER		; Convert to upper case
	CMPB	#^A/L/,BUFFER		; Is this a loop for ever?
	BNEQ	TEST_OVER		; BR if not
	BICW2	#TEST_OVERM,FLAG	; Reset the termination flag
	INCL	PASS			; Bump the pass count
	$FAO_S	CTRSTR = PASS_MSG,-
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = PASS,-
		P2     = ITERATION,-
		P3     = #0		; Make the end of pass message
	PUSHAL	BUFFER_PTR		; Push the string desc.
	PUSHL	#1			; Push arg count
	PUSHL	#UETP$_TEXT!STS$K_INFO	; Push the signal name
	CALLS	#3,G^LIB$SIGNAL		; Print the end of pass message
	CLRL	ITERATION		; Reset the iteration count
	BRW	TIME_IT			; Do the next pass

TEST_OVER:
	MOVL	#SS$_NORMAL!STS$M_INHIB_MSG,STATUS ; Set successful exit status
	$EXIT_S STATUS			; Exit with the status

	.SBTTL	Setup Routine for One File on a Unit
;++
; FUNCTIONAL DESCRIPTION:
;	This routine is called to allocate space and do the general
;	initialization for the data structure associated with a file on a unit.
;
; CALLING SEQUENCE:
;	PUSHL	number-of-this-file-on-this-unit
;	CALLS	#1,UNIT_FILE_SETUP
;
; INPUT PARAMETERS:
;	A byte giving the cardinal number of the current file being set up on
;	the current unit (4(AP)).
;
; IMPLICIT INPUTS:
;	DEVDSC is a descriptor to the current device and unit name in DEV_NAME.
;	DIBBUF is the result of a $GETDEV on that device.
;	UNIT_NUMBER has the current unit number.
;	UNIT_LIST is the queue header to which a new node will be added.
;	DUMMY_FAB and DUMMY_RAB are adjacent and contain templates of a FAB and
;	a RAB, respectively.
;
; OUTPUT PARAMETERS:
;	R0 will have the address of the node just created.
;
; IMPLICIT OUTPUTS:
;	A new node will be added to the queue headed by UNIT_LIST.
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	The space just allocated will be initialized.
;
;--
UNIT_FILE_SETUP:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	$EXPREG_S PAGCNT = #PAGES,-	; Get a new node of demand zero memory
		  RETADR = NEW_NODE
	INSQTI	@NEW_NODE,UNIT_LIST	; Put the new node in the unit list
	MOVL	NEW_NODE,R6		; Save a copy of its address
	MOVB	#1,UETUNT$B_TYPE(R6)	; Set the structure type
	MOVW	#UETUNT$C_INDSIZ+DEVDEP_SIZE,-
		UETUNT$W_SIZE(R6)	; Set the structure size
	MOVC3	#FAB$C_BLN+RAB$C_BLN,-
		DUMMY_FAB,UETUNT$C_FAB(R6) ; Save a FAB and a RAB away
	MOVAL	UETUNT$K_FAB(R6),R7	; Save the FAB address
	MOVAL	UETUNT$K_RAB(R6),R8	; Save the RAB address
	MOVL	R7,RAB$L_FAB(R8)	; Set the FAB address in the RAB
	MOVAL	DISK_K_BUFFER(R6),RAB$L_UBF(R8) ; Set read buffer address...
	MOVAL	DISK_K_BUFFER(R6),RAB$L_RBF(R8) ; ...and write buffer address

	CVTLF	DIBBUF+DIB$L_MAXBLOCK,R9 ; Use the total space on the disk...
	MULF3	#TOP_PCT,R9,R10		; ...to get the max we'll use...
	MULF2	#PERCENTAGE,R9		; ...and how much each file is extended
	CVTFL	R10,DISK_L_TOP_PCT(R6)	; Store the max space for the unit...
	CVTFL	R9,FAB$L_ALQ(R7)	; ...and the original file size

	MOVAL	UETUNT$T_FILSPC(R6),FAB$L_FNA(R7); Set addr of filspec
	ADDW3	#1,DEVDSC,R9		; Device names are device'unit':
					; NOTE:  VMS guarantees length is OK
	MOVW	R9,R10			; Make file names as device'unit'x,...
	CMPW	R10,#FN_LEN		; ...up to a maximum length
	BLEQ	10$			; BR if length is OK
	MOVW	#FN_LEN,R10		; Otherwise force length to be OK
					; In this case, file number is lost...
					; ...but files may be distinguished...
					; ...by their version number
10$:
	ADDB3	#^A/0/,4(AP),R11	; Form final filename char (file number)
	MOVC5	DEVDSC,DEV_NAME,#^A/:/,R9,UETUNT$T_FILSPC(R6) ; Store device...
	MOVC5	DEVDSC,DEV_NAME,R11,R10,(R3) ; ...filename...
	MOVZBW	DOTTST,R0		; ...
	MOVC3	R0,DOTTST+1,(R3)	; ...and extension
	MOVAL	SYSTEST_DIR+1,FAB$L_DNA(R7) ; Set up typical default directory

	; Note that MOVCx thinks length is a word but RMS thinks it's a byte.
	ADDB3	R9,R10,FAB$B_FNS(R7)	; Store the file name string length...
	ADDB2	DOTTST,FAB$B_FNS(R7) 	; ...(dev:file.ext)
	MOVB	SYSTEST_DIR,FAB$B_DNS(R7) ; Store typical default directory length
	MOVW	UNIT_NUMBER,DISK_W_UNIT(R6) ; Save the unit number...
	MOVB	4(AP),DISK_B_FILE(R6)	; ...and the file number on this unit
	BISB2	#UETUNT$M_TESTABLE,-	; Assume file will be testable
		UETUNT$B_FLAGS(R6)
	MOVL	R6,R0			; Return node address as function value
	RET

	.SBTTL	Successful $READ AST Routine
;++
; FUNCTIONAL DESCRIPTION:
;	This routine will receive the AST when a $READ operation finishes for
;	a file on a unit.  It verifies that the data read were correct and
;	starts up the next $WRITE.  In situations detailed below, it will try
;	to extend the file.
;
; CALLING SEQUENCE:
;	Called via AST at I/O completion for all files on all units.
;
; INPUT PARAMETERS:
;	4(AP) is RAB address
;
; IMPLICIT INPUTS:
;	All FABs and RABs.
;	An AST argument list with the ASTPRM value equal to the address of the
;	associated RAB.
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Fields may be modified in FABs and RABs.
;	If a file is being processed correctly and the test has not terminated,
;	a new block of the file is written.
;	A file may be extended.
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	Other fields in the node associated with this file may be modified.
;--
WRITE_NEXT:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	MOVL	4(AP),R6		; Get the address of our RAB...
	MOVL	RAB$L_FAB(R6),R7	; ...and its associated FAB
	MOVAL	-UETUNT$K_RAB(R6),R8	; Set up a node pointer
					; These registers remain constant...
					; ...throughout this routine

;
; Verify that the data read back were those that were written out.  GET_PATTERN
; below explains how we figure that out.  Block 0 is an exception, however.  To
; RMS, block 0 would imply "write (or read) the next block of the file."  We
; therefore avoid its use in choosing a next block and additionally reserve
; it to mean that the test has just started and there is no data to verify.
;
	TSTL	RAB$L_BKT(R6)		; If the last block accessed was 0...
	BNEQ	10$			; ...
	BRW	DO_THE_WRITE		; ...then we have nothing to verify; BR
10$:
	BBS	#PATTERNV,FLAG,15$	; BR if we're forcing a pattern
	BITL	#3,RAB$L_BKT(R6)	; Determine which pattern was used last
	BNEQ	20$			; BR if any bits are set
15$:
	CMPC3	#READ_SIZE,RANDOM_DATA,@RAB$L_RBF(R6) ; Either ^B00 or pattern
	BRB	30$			; Rejoin common code
20$:
	BSBW	GET_PATTERN		; Fill R9 with the pattern to verify
	CMPC5	#0,(R6),R9,#READ_SIZE,@RAB$L_RBF(R6) ; Verify the buffer
30$:
	BEQL	CHECK_EXTEND		; BR if the strings were the same
	BSBW	VERIFY_ERROR		; Yell if strings differed (bad news)
	RET				; No more I/O to this file
;
; The data are verified.  See if it's time to try to extend the file.  File
; extension is meant to test software as much as anything else.  We will
; attempt it if there is no flag contraindicating it for this file, we've done
; a positive multiple of BAKERS $WRITEs to the file and the total space across
; all files on this unit doesn't exceed the value in DISK_L_TOP_PCT.
; Most of the errors we will get from $EXTEND will be caused by exceeding disk
; quota or filling up a pack.  RMS_ERROR has code to ignore these two and we
; must compensate here when FAB$L_ALQ is cleared by an $EXTEND failure.
;
CHECK_EXTEND:
	BBS	#DISK_V_NOEXTEND,-	; BR if flag says don't try to extend
		UETUNT$B_FLAGS(R8),DO_THE_WRITE
	MOVL	UETUNT$L_ITER(R8),R9	; See if we've done...
	BEQL	DO_THE_WRITE		; ...a positive...
	CLRL	R10			; ... (EDIV wants quadword divisor)
	EDIV	#BAKERS,R9,R9,R9	; ...multiple of BAKERS...
	TSTL	R9			; ...writes to this file
	BNEQ	DO_THE_WRITE		; BR if there's a remainder
	MOVL	DISK_L_OTHER_PTR(R8),R9	; Calculate...
	ADDL3	DISK_L_SIZE(R9),-	; ...the total space we're using...
		DISK_L_SIZE(R8),R9	; ...on this unit
	CMPL	R9,DISK_L_TOP_PCT(R8)	; Have we used as much as we should?
	BGEQ	DO_THE_WRITE		; BR if we've reached maximum space
	$EXTEND	FAB = (R7),-		; We're OK, try to expand the file
		ERR = RMS_ERROR
	ADDL2	FAB$L_ALQ(R7),DISK_L_SIZE(R8) ; Compute new current size
	BLBS	R0,DO_THE_WRITE		; BR if we're OK
	BISB2	#DISK_M_NOEXTEND,-	; Prevent further attempts to extend
		UETUNT$B_FLAGS(R8)
	DIVL3	#BAKERS,UETUNT$L_ITER(R8),R9 ; Number writes/writes-per-extend...
	DIVL3	R9,DISK_L_SIZE(R8),FAB$L_ALQ(R7) ; ...divides file size giving extension

;
; Get the next block number to write.
;
DO_THE_WRITE:
	BBC	#TEST_OVERV,FLAG,10$	; BR if the test is still going
	RET				; Finished.  Dismiss AST
10$:
	ADDL2	RANDOM2,RANDOM1		; Generate a "random" number
	BICL3	#^X80000000,RANDOM1,R9	; From it get a new block number,...
	CLRL	R10			; ... (EDIV wants quadword dividend)
	EDIV	DISK_L_SIZE(R8),R9,R9,R9 ; ...modulus the file size,...
	MOVL	R9,RAB$L_BKT(R6)	; ...for next $WRITE
	BEQL	10$			; But don't allow 0 as a block number!
;
; We have the block number to write next;  now we must determine what data will
; be written.
;
	BBS	#PATTERNV,FLAG,15$	; BR if we've forced pattern data
	BITL	#3,RAB$L_BKT(R6)	; Determine which pattern to write next
	BNEQ	20$			; BR if any bits are set
15$:
	MOVC3	#WRITE_SIZE,-		; Either random or forced pattern
		RANDOM_DATA,@RAB$L_RBF(R6) 
	BRB	30$			; Go write the block
20$:
	BSBW	GET_PATTERN		; Fill R9 with the pattern to write
	MOVC5	#0,(R6),R9,#WRITE_SIZE,@RAB$L_RBF(R6) ; Buffer gets pattern data
30$:		
	INCL	UETUNT$L_ITER(R8)	; Count this file's writes
	$WRITE	RAB = @4(AP),-		; Write another block to current file
		ERR = RMS_ERROR,-
		SUC = READ_NEXT
	RET				; Dismiss the AST




;
; Subroutine to fill the low order byte of R9 with the bit pattern of bits 0
; and 1 of the block number (presumably random) in RAB$L_BKT.  The pattern will
; be carried throughout the buffer on a $WRITE and later used to verify that
; the data were written out and read in correctly.  This subroutine will not
; be used if the bit pattern is ^B00 or if the flag PATTERNM is set; in those
; cases the contents of the RANDOM_DATA buffer will be used.
;
GET_PATTERN:
	EXTV	#0,#2,RAB$L_BKT(R6),R9	; Get sign-extended bit pattern
	BLSS	10$			; BR if ^B11 or ^B10 pattern
	MOVB	#^B01010101,R9		; Prepare to propagate the bit pattern
	RSB
10$:
	BLBS	R9,20$			; BR if ^B11 pattern (R9 will have -1)
	MOVB	#^B10101010,R9		; Prepare to propagate the bit pattern
20$:
	RSB

	.SBTTL	Successful $WRITE AST Routine
;++
; FUNCTIONAL DESCRIPTION:
;	This routine will receive the AST when a $WRITE operation finishes for
;	a file on a unit.  It starts up a $READ operation and dismisses the
;	AST.
;
; CALLING SEQUENCE:
;	Called via AST at I/O completion for any file on any unit.
;
; INPUT PARAMETERS:
;	4(AP) is RAB address
;
; IMPLICIT INPUTS:
;	All RABs (and FABs, implicitly).
;	An AST argument list with the ASTPRM value equal to the address of the
;	associated RAB.
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Fields may be modified in RABs.
;	If a file is being processed correctly and the test has not terminated,
;	the block of the file just written is read back in as verification.
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

READ_NEXT:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	BBS	#TEST_OVERV,FLAG,10$	; Stop ASAP if test is over
	MOVL	4(AP),R6		; Get the address of our RAB
	MOVC5	#0,(R6),#0,#WRITE_SIZE,@RAB$L_RBF(R6) ; Clear the read buffer
	$READ	RAB = @4(AP),-		; Read back the block just written
		ERR = RMS_ERROR,-
		SUC = WRITE_NEXT
10$:
	RET				; Dismiss the AST

	.SBTTL	Left Over File Cleanup Routine
;++
; FUNCTIONAL DESCRIPTION:
;	If there are files left over from a previous run of the disk test (as
;	would happen, for example, if the system crashed during a run), this
;	routine will clean up the highest version of the file we're about to
;	create.  This is preferred over a supersede operation because supersede
;	will not delete the old file's space until after the new file is
;	created.
;
; CALLING SEQUENCE:
;	BSBW	PRE_CLEAN
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	Current FAB, pointed to as UETUNT$K_FAB(R6).
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	File may be deleted.  R0 is trashed.
;
;--

PRE_CLEAN:
	PUSHR	#^M<R1,R2,R3,R4,R5,R6,R7,R8,R9,R10> ; We clobber nothing here...
	MOVL	SP,R10			; ...including our stack!
	MOVAL	UETUNT$K_FAB(R6),R7	; Use R7 for more visible access
	MOVZBL	FAB$B_BLN(R7),R8	; Again, we clobber nothing...
	SUBL2	R8,SP			; ...so we'll do our RMS access...
	MOVC3	R8,(R7),(SP)		; ...using a FAB on the stack
	MOVL	SP,R9			; Save a pointer to our new FAB
	$OPEN	FAB = R9		; See if old version of file is there
	BLBC	R0,10$			; We can do nothing if any error
	$CLOSE	FAB = R9		; We found one...
	$ERASE	FAB = R9		; ...get rid of it
10$:
	MOVL	R10,SP			; Restore our stack...
	POPR	#^M<R1,R2,R3,R4,R5,R6,R7,R8,R9,R10> ; ...and all our registers
	RSB

	.SBTTL	File Cleanup Routine
;++
; FUNCTIONAL DESCRIPTION:
;	This routine will clean up the files used for the test.
;
; CALLING SEQUENCE:
;	BSBW	CLEAN_UP
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	All FABs.  UNIT_LIST points to a queue with unit-file nodes.
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	Files are closed, deleted and erased.  All registers may be trash.
;
;--

CLEAN_UP:
	MOVAL	UNIT_LIST,R6		; This will point to the current unit
10$:
	ADDL2	(R6),R6			; Loop through all nodes
	CMPL	R6,#UNIT_LIST		; Back at the head of the queue yet?
	BEQL	40$			; BR if we've finished

	BBS	#DISK_V_NOCREATE,-	; Don't try $CLOSE if $CREATE failed
		UETUNT$B_FLAGS(R6),10$
	MOVAL	UETUNT$K_FAB(R6),R8	; Get FAB address
20$:
	$CLOSE	FAB = (R8)		; Try to close the file
	CMPL	R0,#RMS$_ACT		; Has this file finished all I/O yet?
	BNEQ	30$			; BR if it has
	$WAIT	RAB = UETUNT$K_RAB(R6)	; Twiddle thumbs until I/O completes
	BRB	20$			; Try closing this file again
30$:
	ADDL2	UETUNT$L_ITER(R6),ITERATION ; Count total I/O for test
	$ERASE	FAB = (R8)		; File closed, remove directory entry
	BRB	10$
40$:
	RSB				; We're all cleaned up

	.SBTTL	Bum Data Routine
;++
; FUNCTIONAL DESCRIPTION:
;	Print an error message if we get a mismatch during data verification.
;
; CALLING SEQUENCE:
;	CMPCx	...@RAB$L_RBF(R6)
;	BEQL	data-was-good
;	BSBW	VERIFY_ERROR
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	R1 points to the good data if we just read random data or forced
;	pattern data, never-never land if we read generated pattern data.
;	R3 points to the offending byte of differing data.
;	R6 points to the RAB for the bad file.
;	R9 will have the pattern if we matched generated pattern data.
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Message to SYS$OUTPUT and SYS$ERROR.
;	Registers R2-R8 and R10-R11 returned unscathed.
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

VERIFY_ERROR:
	BBS	#PATTERNV,FLAG,5$	; BR if we used forced pattern data
	BITL	#3,RAB$L_BKT(R6)	; Did we have random data?
	BNEQ	10$			; BR if we used generated pattern data
5$:
	MOVB	(R1),R9			; Copy the byte where failure was found
10$:
	MOVZBL	(R3),-(SP)		; Save the bad...
	MOVZBL	R9,-(SP)		; ...the good...
	SUBL3	RAB$L_RBF(R6),R3,-(SP)	; ...the place...
	MOVZWL	DISK_W_UNIT-UETUNT$K_RAB(R6),-(SP) ; ...the unit...
	PUSHAL	DEVDSC			; ...the controller...
	PUSHL	#5			; ...
	PUSHL	#UETP$_DATAER!STS$K_ERROR ; ...and the ugly info
	INCL	ERROR_COUNT		; Keep a running error count
	PUSHL	ERROR_COUNT		; ...
	PUSHL	#1			; ...
	PUSHL	#UETP$_ERBOX!STS$K_ERROR ; Have the error stand out in log file
	CALLS	#10,G^LIB$SIGNAL	; Let the user know what happened
	BICB2	#UETUNT$M_TESTABLE,-	; Indicate that this file is no good
		UETUNT$B_FLAGS-UETUNT$K_RAB(R6)
	BRW	DESTP_CHECK		; Exit via possible additional message

	.SBTTL	Check if We've Stopped Testing a Unit
;++
; FUNCTIONAL DESCRIPTION:
;	In normal and loop forever modes, we warn the user that a device is
;	seen to be totally untestable (at least during this pass).
;
; CALLING SEQUENCE:
;	BSBW	DESTP_CHECK
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	R8 points to the unit data block
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	Possible error message if all files for this unit are marked as
;	untestable.
;
;--

DESTP_CHECK:
	PUSHL	R6			; We'll affect no registers herein
	BBS	#ONE_SHOTV,FLAG,20$	; This is meaningless in one-shot mode
	MOVL	R8,R6			; Set up a working pointer to node
10$:
	BBS	#UETUNT$V_TESTABLE,-	; If this file is still good...
		UETUNT$B_FLAGS(R6),20$	; ...then we need no message
	MOVL	DISK_L_OTHER_PTR(R6),R6	; Point to next node for this unit
	CMPL	R6,R8			; Back where we started?
	BNEQ	10$			; BR if not - check this one, too
	PUSHL	#0			; None testable - we need message
	MOVZWL	DISK_W_UNIT(R8),-(SP)	; Unit number
	PUSHAL	DEVDSC			; Controller
	PUSHAL	PROCESS_NAME		; Image name
	PUSHL	#4
	PUSHL	#UETP$_DESTP!STS$K_ERROR
	CALLS	#6,G^LIB$SIGNAL
20$:
	POPL	R6
	RSB

	.SBTTL	$CREATE-Specific Error Checker
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles error returns from $CREATEs of test files.  It
;	allows us to first try creating a file in device:[SYSTEST], and then
;	for system packs with multiple system directory hierarchies, to try
;	creating the file in device:[SYS0.SYSTEST].  This means we can test
;	all packs, whether mounted as system packs or not.  The routine also
;	allows us to recover from most RMS$_FUL errors by trying to allocate
;	a file that is only 1% of the total space on a pack.
;
; CALLING SEQUENCE:
;	BSBW	CREATE_CHECK
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	R6 points to our unit data block for this file on this device.
;	The FAB associated with the RMS $CREATE as UETUNT$K_FAB(R6).
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Error message
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	If the error can be corrected by retrying with a different directory,
;	the test file will be created.  If the file can be created with a
;	smaller allocation, it will be.  Otherwise, the program may exit,
;	depending on severity of the error.  If the program does not exit
;	and the file is not created, DISK_M_NOCREATE is set in UETUNT$B_FLAGS
;	by the RMS error handler.  R0 and R2 are trashed.
;
;--

CREATE_CHECK:
	BLBS	R0,30$			; BR if there was no error
	MOVAL	UETUNT$K_FAB(R6),R2	; Point to our FAB for convenience
	CMPL	#RMS$_DNF,FAB$L_STS(R2)	; Did we get directory not found error?
	BNEQ	10$			; BR if not
	MOVB	SYS0_SYSTEST_DIR,-	; Yes, try it again...
		FAB$B_DNS(R2)
	MOVAL	SYS0_SYSTEST_DIR+1,-	; ...using...
		FAB$L_DNA(R2)		; ...V3 system directory hierarchies
	BSBW	PRE_CLEAN		; Try again to clean up old file
	$CREATE	FAB = (R2)		; Try again to create new file
	BLBS	R0,30$			; BR if we got it this time

10$:
	CMPL	#RMS$_FUL,R0		; Did we fail because file was too big?
	BNEQ	20$			; BR if not
	MULF3	#^F100.0,#PERCENTAGE,R0	; Try to get...
	CVTFL	R0,R0			; ...
	DIVL2	R0,FAB$L_ALQ(R2)	; ...1% of this unit's space...
	$CREATE	FAB = (R2)		; ...and try again for the file
	BLBS	R0,30$			; BR if we got the file

20$:
	PUSHL	R2			; We don't know which error we got...
	CALLS	#1,RMS_ERROR		; ...so let real routine handle it
30$:
	RSB

	.SBTTL	Timer Expiration Routine
;++
; FUNCTIONAL DESCRIPTION:
;	This routine will signal the end of the test when we time out.
;
; CALLING SEQUENCE:
;	Called via AST at $SETIMR expiration.
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	The TEST_OVER flag is set in FLAG.  This will tell the AST level
;	routines to not schedule any further I/O.
;	The program is aWAKEned from its HIBERnating state.
;	Note that no cleanup is done here.
;
;--

TIME_OUT:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	BISW2	#TEST_OVERM,FLAG	; Tell AST routines to stop
	$WAKE_S				; Resume normal execution
	RET

	.SBTTL	System Service Exception Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine is executed if a software or hardware exception occurs or
;	if a LIB$SIGNAL system service is used to output a message.
;	Information about this method of handling messages and errors can be
;	found in the VMS COMMON RUN-TIME manual and in the VMS SYSTEM SERVICE
;	manual.
;
; CALLING SEQUENCE:
;	Entered via an exception from the system
;
; INPUT PARAMETERS:
;	ERROR_COUNT   = previous cumulative error count
;	                -----------------
;	   AP ---->     !       2       !
;			!---------------!
;			! SIGNL ARY PNT !
;			!---------------!
;			! MECH  ARY PNT !
;			!---------------! ---------
;			!       4       !         ^
;			!---------------!         !
;			! ESTABLISH FP  !         !
;			!---------------!         !
;			!    DEPTH      ! Mechanism Array
;			!---------------!         !
;			!      R0       !         !
;			!---------------!         !
;			!      R1       !         v
;			!---------------! ---------
;			!       N       !         ^
;			!---------------!         !
;			! CONDITION NAME!         !
;			!---------------!         !
;			! N-3 ADDITIONAL!    Signal Array
;			! LONG WORD ARGS!         !
;			!---------------!         !
;			!      PC       !         !
;			!---------------!         !
;			!      PSL      !         v
;			!---------------! ---------
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	May branch to ERROR_EXIT
;--

SSERROR:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	$SETAST_S ENBFLG = #0		; Disable AST delivery
	CLRL	AST_MODE		; Assume it was disabled
	CMPL	R0,#SS$_WASSET		; Were AST's enabled?
	BNEQ	10$			; BR if not enabled
	MOVL	#1,AST_MODE		; Set it to be reenabled
10$:	$SETSFM_S ENBFLG = #0		; Disable SS failure mode for PUTMSG
	CLRL	SS_FAIL_MODE		; Assume it was disabled
	CMPL	R0,#SS$_WASSET		; Was SS failure mode enabled?
	BNEQ	20$			; BR if not enabled
	MOVL	#1,SS_FAIL_MODE		; Set it to be reenabled
20$:	MOVL	CHF$L_SIGARGLST(AP),R6	; Get the signal array pointer
	CMPZV	#STS$V_FAC_NO,#STS$S_FAC_NO,- ; Is this a message from LIB$SIGNAL?
		CHF$L_SIG_NAME(R6),#UETP_K
	BNEQ	30$			; BR if this is a system exception
	SUBL2	#2,CHF$L_SIG_ARGS(R6)	; Drop the PC and PSL
	$PUTMSG_S MSGVEC = CHF$L_SIG_ARGS(R6) ; Print the message
	$SETSFM_S ENBFLG = SS_FAIL_MODE	; Set to previous state
	$SETAST_S ENBFLG = AST_MODE	; Set to previous state
	RET				; Return to the program
30$:
	CMPZV	#STS$V_FAC_NO,#STS$S_FAC_NO,- ; Is it an RMS failure?
		CHF$L_SIG_ARG1(R6),#RMS_K
	BNEQ	40$			; BR if not
	$SETSFM_S ENBFLG = SS_FAIL_MODE	; Set to previous state
	$SETAST_S ENBFLG = AST_MODE	; Set to previous state
	RET				; Yes, RMS_ERROR gets to handle them
40$:
	MOVL	CHF$L_SIG_NAME(R6),STATUS ; Save the status
	CLRL	R8			; Assume for now it's not SS failure
	CMPL	#SS$_SSFAIL,STATUS	; But is it a System Service failure?
	BNEQ	60$			; BR if not - no special case message
	$GETMSG_S MSGID = CHF$L_SIG_ARG1(R6),- ; Get SS failure code associated text
		 MSGLEN = BUFFER_PTR,-
		 BUFADR = FAO_BUF,-
		 FLAGS  = #14,-
		 OUTADR = MSG_BLOCK
	TSTB	MSG_BLOCK+1		; Get FAO arg count for SS failure code
	BEQL	50$			; Don't use $GETMSG if no $FAO args...
	PUSHAL	BUFFER_PTR		; ...else build up...
	PUSHL	#1			; ...a message describing...
	PUSHL	#UETP$_TEXT		; ...why the System Service failed
	INSV	CHF$L_SIG_ARG1(R6),-	; Give the message...
		#STS$V_SEVERITY,-	; ...the correct severity code
		#STS$S_SEVERITY,(SP)
	MOVL	#3,R8			; Count the number of args we pushed
	BRB	60$
50$:
	PUSHL	CHF$L_SIG_ARG1(R6)	; Save SS failure code
	MOVL	#1,R8			; Count the number of args we pushed
60$:
	MULL3	#4,CHF$L_SIG_ARGS(R6),R7 ; Convert longwords to bytes
	SUBL2	R7,SP			; Save the current signal array...
	MOVC3	R7,CHF$L_SIG_NAME(R6),(SP) ; ...on the stack
	ADDL3	R8,CHF$L_SIG_ARGS(R6),-(SP) ; Push the current arg count
	BRW	ERROR_EXIT


	.SBTTL	General RMS Error Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles error returns from RMS calls.
;
; CALLING SEQUENCE:
;	Called by RMS when a file processing error is found.  Will also be
;	called by TRY_SYS0 if an error other than directory-not-found is
;	encountered when creating a test file.
;
; INPUT PARAMETERS:
;	The FAB or RAB associated with the RMS call.
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Error message
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	Program may exit, depending on severity of the error.
;
;--

RMS_ERROR:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	MOVL	4(AP),R6		; See whether we're dealing with...
	CMPB	#FAB$C_BID,FAB$B_BID(R6) ; ...a FAB or a RAB
	BNEQ	10$			; BR if it's a RAB
	MOVAL	FILE,R7			; FAB-specific code:  text string...
	MOVL	R6,R8			; ...address of FAB...
	PUSHL	FAB$L_STV(R6)		; ...STV field for error...
	PUSHL	FAB$L_STS(R6)		; ...STS field for error...
	MOVL	FAB$L_STS(R6),STATUS	; ...and save the error code
	BRB	COMMON			; FAB and RAB share other code
10$:
	MOVAL	RECORD,R7		; RAB-specific code:  text string...
	MOVL	RAB$L_FAB(R6),R8	; ...address of associated FAB...
	PUSHL	RAB$L_STV(R6)		; ...STV field for error...
	PUSHL	RAB$L_STS(R6)		; ...STS field for error...
	MOVL	RAB$L_STS(R6),STATUS	; ...and save the error code
COMMON:
	MOVZBL	FAB$B_FNS(R8),R10
	$FAO_S	CTRSTR = RMS_ERR_STRING,- ; Common code, prepare error message...
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = R7,-
		P2     = R10,-
		P3     = FAB$L_FNA(R8)
	PUSHAL	BUFFER_PTR		; ...and arguments for ERROR_EXIT...
	PUSHL	#1			; ...
	PUSHL	#UETP$_TEXT		; ...
	EXTZV	#STS$V_SEVERITY,-
		#STS$S_SEVERITY,-
		STATUS,R9 		; ...get the severity code...
	BISB2	R9,(SP)			; ...and add it into the signal name
	CMPL	FAB$L_CTX(R8),#DISK_K_PATTERN ; A test or an overhead file?
	BEQL	TEST_FILE_ERROR		; BR if it's a test file
	PUSHL	#5			; Current arg count
	BRW	ERROR_EXIT		; Can't complete test normally

TEST_FILE_ERROR:
	MOVAL	-UETUNT$K_FAB(R8),R11	; Point to node for this FAB
	CMPW	#DISK_K_CREATE,UETUNT$W_FUNC(R11) ; Were we doing a $CREATE?
	BEQL	10$			; BR if so (all errors count)

; We sometimes expect SS$_EXDISKQUOTA or RMS$_FUL errors as a natural
; consequence of trying to extend a test file.  Ignore them here and let
; inline code where the $EXTEND is done handle the error.  That same code will
; prevent further attempts at expansion because R0 is immediately returned
; with an error value and DISK_M_NOEXTEND is set for the file.  Note that the
; RET instruction below will clean up the stack.
	CMPL	#SS$_EXDISKQUOTA,FAB$L_STV(R8) ; Quota exhausted error?
	BEQL	20$			; BR if so
	CMPL	#RMS$_FUL,FAB$L_STS(R8)	; Error because unit was full?
	BEQL	20$			; BR if so

10$:
	INCL	ERROR_COUNT		; Keep a running error count
	PUSHL	ERROR_COUNT		; Have the error stand out in log file
	PUSHL	#1			; ...
	PUSHL	#UETP$_ERBOX		; Set the message code...
	BISB2	R9,(SP)			; ...and the severity
	CALLS	#8,G^LIB$SIGNAL		; Let the user know what happened
	BICB2	#UETUNT$M_TESTABLE,-	; Indicate that this file is no good
		UETUNT$B_FLAGS(R11)
	CMPW	UETUNT$W_FUNC(R11),#DISK_K_CREATE ; Were we doing a $CREATE?
	BNEQ	20$			; BR if not
	BISB2	#DISK_M_NOCREATE,-	; Prevent trying to $CLOSE
		UETUNT$B_FLAGS(R11)
20$:
	MOVL	R11,R8			; Set up args to see...
	BSBW	DESTP_CHECK		; ...if additional message is needed
	RET				; No more I/O to this file


	.SBTTL	CTRL/C Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles CTRL/C AST's by printing a message and exiting.
;
; CALLING SEQUENCE:
;	Called via AST
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	$EXIT status value
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

CCASTHAND:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	PUSHAL	CNTRLCMSG		; Set message pointer
	PUSHL	#1			; Set arg count
	PUSHL	#UETP$_TEXT!STS$K_WARNING ; Set signal name
	PUSHL	#0			; Indicate an abnormal termination
	PUSHAL	PROCESS_NAME		; ...
	PUSHL	#2			; ...
	PUSHL	#UETP$_ABENDD!STS$K_WARNING ; ...
	CALLS	#7,G^LIB$SIGNAL		; Output the message
	MOVL	#<SS$_CONTROLC-STS$K_SUCCESS+STS$K_WARNING>,-
		STATUS			; Set the exit status
	$EXIT_S	STATUS			; Terminate program cleanly

	.SBTTL	Error Exit
;++
; FUNCTIONAL DESCRIPTION:
;	This routine prints an error message and exits.
;
; CALLING SEQUENCE:
;	MOVx  error status value,STATUS
;	PUSHx error specific information on the stack
;	PUSHL current argument count
;	BRW   ERROR_EXIT
;
; INPUT PARAMETERS:
;	Arguments to LIB$SIGNAL, as above
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	Message to SYS$OUTPUT and SYS$ERROR
;
; IMPLICIT OUTPUTS:
;	Program exit
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

ERROR_EXIT:

	$SETAST_S ENBFLG = #0		; ASTs can play havoc with messages
	BBS	#BEGIN_MSGV,FLAG,10$	; BR if "begin" msg has already been output
	CLRL	-(SP)			; Set the time stamp flag
	PUSHAL	PROCESS_NAME		; Set the test name
	PUSHL	#2			; Push the argument count
	PUSHL	#UETP$_BEGIND!STS$K_SUCCESS ; Set the message code
	CALLS	#4,G^LIB$SIGNAL		; Print the startup message
10$:
	ADDL3	(SP)+,#7,ARG_COUNT	; Get total # args, pop partial count
	INCL	ERROR_COUNT		; Keep running error count
	PUSHL	#0			; Push the time parameter
	PUSHAL	PROCESS_NAME		; Push test name...
	PUSHL	#2			; ...arg count...
	PUSHL	#UETP$_ABENDD!STS$K_ERROR ; ...and signal name
	PUSHL	ERROR_COUNT		; Finish off arg list...
	PUSHL	#1			; ...
	PUSHL	#UETP$_ERBOX!STS$K_ERROR ; ...for error box message
	CALLS	ARG_COUNT,G^LIB$SIGNAL	; Truly bitch

	BISL	#STS$M_INHIB_MSG,STATUS	; Don't print messages twice!
	$EXIT_S STATUS			; Exit in error

	.SBTTL	Exit Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles cleanup at exit.  If the MODE logical name is
;	equated to "ONE", the routine will update the test flag in the
;	UETINIDEV.DAT file depending on the UETUNT$M_TESTABLE flag state in the
;	UETUNT$B_FLAGS field of the unit blocks corresponding to a line in the
;	file.
;
; CALLING SEQUENCE:
;	Invoked automatically by $EXIT System Service.
;
; INPUT PARAMETERS:
;	STATUS	contains the exit status.
;	FLAG	has synchronizing bits.
;	DDB_RFA	contains the RFA of the DDB record for this device in UETINIDEV
;
; IMPLICIT INPUTS:
;	UNIT_LIST points to the head of a doubly linked circular list of unit
;		  blocks for the device under test.
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Various files are de-accessed, the process name is reset, and any
;	necessary synchronization with UETPDEV01 is carried out.
;	If the MODE logical name is equated to "ONE", the routine will update
;	the test flag in the UETINIDEV.DAT file depending on the
;	UETUNT$M_TESTABLE flag state in the UETUNT$B_FLAGS field of the unit
;	blocks corresponding to the units on the disk controller.
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

EXIT_HANDLER:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	$SETSFM_S ENBFLG = #0		; Turn off System Service failure mode
	$SETAST_S ENBFLG = #0		; We're finished - no more ASTs
	BBS	#ONE_SHOTV,FLAG,10$	; If one-shot, update testability...
	BRW	END_UPDATE		; ...else don't update UETINIDEV.DAT
10$:
	BBS	#SAFE_TO_UPDV,FLAG,20$	; Only update if it's safe
	BRW	END_UPDATE		; Else forget it
20$:
	MOVAL	INI_RAB,R10		; Set the RAB address
	MOVB	#RAB$C_RFA,RAB$B_RAC(R10) ; Set RFA mode
	MOVC3	#6,DDB_RFA,RAB$W_RFA(R10) ; Set RFA to DDB line
	$GET	RAB = (R10)		; Go back to the DDB record
	BLBS	R0,30$
	BRW	END_UPDATE		; If failure then forget it
30$:
	MOVB	#RAB$C_SEQ,RAB$B_RAC(R10) ; Set back to sequential mode
	ADDL3	#UNIT_LIST,UNIT_LIST,R11 ; Set the unit block list header
	CLRL	R9			; Init an index
UNIT_LOOP:
	BITB	#UETUNT$M_TESTABLE,-
		UETUNT$B_FLAGS(R11)	; Is this unit testable?
	BEQL	10$			; BR if not
	INCL	R9			; Another unit that's testable
10$:
	ADDL2	(R11),R11		; Next unit block
	CMPL	R11,#UNIT_LIST		; Are we full circle in the list?
	BNEQ	UNIT_LOOP		; BR if not
	TSTL	R9			; Any testable units?
	BNEQ	20$			; BR if yes...
	MOVB	#^A/N/,BUFFER+4		; ...else disable the DDB record...
	$UPDATE RAB = (R10)		; ...here
	BLBC	R0,END_UPDATE		; If error then forget it
20$:
	ADDL2	(R11),R11		; Next unit block
	CMPL	R11,#UNIT_LIST		; Are we full circle in the list?
	BEQL	END_UPDATE		; BR if yes
	TSTB	DISK_B_FILE(R11)	; Is this node for file 0 on a unit?
	BNEQ	20$			; BR if not; we'll only $GET for first node
	$GET	RAB = (R10)		; Get a record
	BLBC	R0,END_UPDATE		; If error then forget it
	BICB2	#LC_BITM,BUFFER		; Convert to uppercase
	CMPB	#^A/U/,BUFFER		; Is it a UCB record?
	BNEQ	END_UPDATE		; BR if not
	BITB	#UETUNT$M_TESTABLE,-
		UETUNT$B_FLAGS(R11)	; Is this unit testable?
	BNEQ	20$			; BR if yes
	MOVL	DISK_L_OTHER_PTR(R11),R8 ; See if other file on this unit...
	BEQL	30$			; ...if there is one...
	BITB	#UETUNT$M_TESTABLE,-	; ...might be testable
		UETUNT$B_FLAGS(R8)
	BNEQ	20$			; BR if yes
30$:
	MOVB	#^A/N/,BUFFER+4		; None testable, disable the UCB record...
	$UPDATE RAB = (R10)		; ...here
	BLBC	R0,END_UPDATE		; If error then forget it
	BRB	20$			; Look at the next record
END_UPDATE:
	BBS	#TEST_OVERV,FLAG,10$	; Did the test end normally (timeout)?
	BSBW	CLEAN_UP		; It didn't so must erase files
10$:
	PUSHL	#0			; Set the time flag
	PUSHAL	PROCESS_NAME		; Push the test name
	PUSHL	#2			; Push arg count
	PUSHL	#UETP$_ENDEDD!STS$K_SUCCESS ; Push signal name
	EXTZV	#STS$V_SEVERITY,-	; Get the proper exit severity
		#STS$S_SEVERITY,-
		STATUS,R0
	INSV	R0,#STS$V_SEVERITY,-	; Set the end message severity
		#STS$S_SEVERITY,(SP)
	CALLS	#4,G^LIB$SIGNAL		; Output the message
	$DISCONNECT  RAB = INI_RAB	; Disconnect the RAB from the FAB
	$CLOSE	     FAB = INI_FAB	; Close the file
	$SETPRN_S PRCNAM = ACNT_NAME	; Reset the process name
	RET				; That's all folks!

	.END	UETDISK00
