	.TITLE	TST10A
	.IDENT	/V03000/
	.PSECT	TST10A
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; VERSION X01
;
; WRITTEN BY LOUIS REICH, FEBRUARY, 1973
; MODIFIED BY TOM MILLER FOR RSX-11M, SEPTEMBER,1974
; MODIFIED BY LARRY JONES FOR VAX/VMS, FEBRUARY,1978
;+
; MODULE 'TST10A' IS PART OF TEST10 OF THE RSX-11M TEST SYSTEM,
; DESIGNED TO TEST THE FOLLOWING RSX-11M SYSTEM DIRECTIVES:
;	SEND DATA
;	RECEIVE DATA
;	SPECIFY RECEIVE AST
;	RECEIVE DATA OR EXIT
;
;-
	.MCALL	CALL,RQST$,CLEF$S,WTSE$S,EXIT$S,SDAT$,MRKT$
;
; LOCAL DATA
;
TST10B:	.RAD50	/10B/
TST10X:	.RAD50	/10X/
BDDPB:	.BYTE	71.,1
GDDPB:	.BYTE	71.,5
SBLK1:	.ASCII	/1BCDEFGHIJKLMNOPQRSTUVWXYZ/
SBLK2:	.ASCII	/2BCDEFGHIJKLMNOPQRSTUVWXYZ/
SBLK3:	.ASCII	/3BCDEFGHIJKLMNOPQRSTUVWXYZ/
LEM1:	.ASCII	/%NRECEIVE DATA OR EXIT ALLOWED TASK TO EXIT/
	.ASCIZ	/ WITH A MESSAGE PENDING/
	.EVEN
	.PAGE
	.PSECT	$DPB$$
;
; THIS PSECT CONTAINS ONLY DPB'S
;
SDPB:	SDAT$	TST10B,SBLK1,47.
RQDPB:	RQST$	TST10B
MKTDPB:	MRKT$	11.,10.,SECOND
	.PAGE
	.PSECT	TST10A
;+
;
; THIS MODULE INITIATES TEST10. IN THE FIRST STEP IT SENDS THREE
; DIFFERENT BLOCKS TO TST10B WHICH VERIFIES THE ACCURATE TRANSMISSION
; AND FIFO ORDERING OF SENT AND RECEIVED BLOCKS.
;
;-
	$$TEST	10,A
	CALL	.STST		;OUTPUT START OF TEST MESSAGE
	MOV	#SDPB,R3	;GET ADDRESS OF SEND DPB
	CLEF$S	#47.,.RJCT	;CLEAR EF47 (FLAG SPECIFIED IN SDAT$)
	DIR$	R3,.RJCT	;INVOKE SEND
	CALL	.SUCC		;CHECK FOR VALID RETURN CODE
	MOV	#SBLK2,S.DABA(R3) ;MOVE SBLK2 INTO SEND BUFFER ADDRESS
	DIR$	R3,.RJCT	;INVOKE SEND DIRECTIVE
	MOV	#SBLK3,S.DABA(R3) ;MOVE SBLK3 INTO SEND BUFFER ADDRESSS
	DIR$	R3,.RJCT	;INVOKE SEND DIRECTIVE
	CLEF$S	#48.,.RJCT	;CLEAR EF48
	DIR$	#RQDPB,.RJCT	;REQUEST TST10B
	WTSE$S	#48.,.RJCT	;WAIT
	.PAGE
;+
;
; THE NEXT SERIES OF STEPS TESTS THE ERROR CHECKING CAPABILITIES
; OF THE SEND DIRECTIVE. FIRST ATTEMPT TO SEND TO A NON-INSTALLED TASK.
;
;-
	$$STEP
	MOV	TST10X,S.DATN+2(R3) ;MOVE TST10X INTO SEND TASKNAME
	DIR$	R3		;INVOKE SEND DIRECTIVE
	MOV	#IE.INS,R1	;PUT EXPECTED ERROR CODE IN R1
	CALL	.FAIL		;CHECK ERROR CODE
	MOV	TST10B,S.DATN+2(R3) ;RESTORE DPB
;+
;
; NEXT A BAD EVENT FLAG SPECIFICATION
;
;-
	$$STEP
	MOV	#100.,S.DAEF(R3) ;MOVE BAD EFN INTO DPB
	DIR$	R3		;INVOKE DIRECTIVE
	MOV	#IE.IEF,R1	;PUT EXPECTED RETURN CODE IN R1
	CALL	.FAIL		;CHECK RETURN CODE
	MOV	#47.,S.DAEF(R3) ;RESTORE DPB
;+
;
; NEXT A BAD DPB SIZE
;
;-
	$$STEP
	MOV	BDDPB,(R3)	;MOVE BAD DPB SIZE TO DPB
	DIR$	R3		;INVOKE SEND DIRECTIVE
	MOV	#IE.SDP,R1	;PUT EXPECTED ERROR CODE IN R1
	CALL	.FAIL		;CHECK ERROR CODE
	MOV	GDDPB,(R3)	;RESTORE DPB
;+
;
; NEXT BAD BUFFER ADDRESSES. FIRST AN ODD BUFFER ADDRESS.
;
;-
	CALL	$ADCHK		;IS SYSTEM PERFORMING ADDRESS CHECKING?
	BCS	NADCK		;IF NOT, SKIP TESTS REQUIRING CHECKING
	$$STEP
;*****
	JMP STP6		;TEMP FOR FIX TO C BIT SET BUG
;*****
	INC	S.DABA(R3)	;MOVE AN ODD BUFFER ADDRESS INTO DPB
	DIR$	R3		;INVOKE SEND DIRECTIVE
	MOV	#IE.ADP,R1	;MOVE EXPECTED ERROR CODE TO R1
	CALL	.FAIL		;CHECK RETURN CODE
;+
;
; NEXT A BUFFER ADDRESS OUTSIDE THE ADDRESS SPACE OF THE TASK
;
;-
	$$STEP
	MOV	#160000,S.DABA(R3) ;MOVE BAD ADDRESS INTO DPB
	DIR$	R3
	MOV	#IE.ADP,R1	;PUT EXPECTED ERROR CODE IN R1
	CALL	.FAIL		;CHECK ERROR CODE
	MOV	#SBLK3,S.DABA(R3) ;RESTORE DPB
	.PAGE
;+
;
; IN THIS STEP TST10A SENDS THREE MESSAGES TO TST10B WAITING
; AFTER EACH ONE ON EF48 FOR TST10B TO ALLOW IT TO CONTINUE
;
;-
NADCK:
	$$STEP
	MOV	#3,R4		;LOAD R4 WITH REPTITION COUNT
REP:
	CLEF$S	#48.,.RJCT	;CLEAR EF48
	DIR$	R3,.RJCT	;INVOKE SEND DIRECTIVE
	WTSE$S	#48.,.RJCT	;WAIT
	SOB	R4,REP
;+
;
; NOW SEND ONE MORE MESSAGE FOR TST10B TO RECEIVE WITH THE RECEIVE
; OR EXIT DIRECTIVE.  WAIT FOR 10 SECONDS THEN MAKE SURE TST10B DID
; NOT EXIT BY SEEING IF IT SET EF48.  AN ERROR MESSAGE IS PRINTED
; IF THE FLAG IS NOT SET.
;
;-
	CLEF$S	#48.,.RJCT	;CLEAR EF48 INITIALLY
	DIR$	R3,.RJCT	;SEND A MESSAGE
	DIR$	#MKTDPB,.RJCT	;MARK TIME FOR 10 SECONDS
	WTSE$S	#11.,.RJCT	;AND WAIT
	CLEF$S	#48.,.RJCT	;USE CLEAR FLAG TO READ EF48
	CMP	$DSW,#IS.SET	;WAS FLAG SET?
	BEQ	OK		;OK IF IT WAS
	CALL	.IDOUT		;OTHERWISE TST10B MUST HAVE EXITTED
	MOV	#LEM1,R1	;PASS ADDRESS OF ERROR MESSAGE
	CALL	.PRTMG		;AND PRINT IT
;+
;
; TST10 IS NOW COMPLETED.  PRINT END OF TEST MESSAGE AND THEN EXIT.
;
;-
OK:
	CALL	.ETST		;PRINT END OF TEST MESSAGE
	EXIT$S	.RJCT		;EXIT
	.END	STP0

