	.TITLE UETTAPE00 VAX/VMS UETP DEVICE TEST FOR TAPE
	.IDENT	'V03-000'
	.ENABLE SUPPRESSION
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:
;	This module will be distributed with VAX/VMS under the [SYSTEST]
;	account.
;
; ABSTRACT:
;	This program tests all supported mag tapes.  It uses QIO's in the
;	ONE PASS mode and RMS block mode with variable record size in the
;	NORMAL and LOOP modes. Tapes are rewound, dismounted and initialized
;	on exit.
;
; ENVIRONMENT:
; 	This program will run in user access mode, with AST's enabled except
;	during error processing. This program requires the following privileges
;	and quotas.
;
;		GRPNAM, LOG_IO
;		AST queue = 2 + number of tape units under test
;
;
; AUTHOR: Robert N. Perron		CREATION DATE: Feb., 1981
;
; MODIFIED BY:
;
;	V03-009 RNP0008		Robert N. Perron,	02-Mar-1982
;		Enable loop mode.
;
;	V03-008	RNP0007		Robert N. Perron,	23-Jan-1982
;		Changed to conform to new mount system service interface.
;
;	V03-007 RNP0006		Robert N. Perron,	17-Nov-1981
;		Activated code to utilize mount system service.
;		Changed the .ENTRY and .TITLE to UETTAPE00.
;
;	V03-006 RNP0005		Robert N. Perron,	28-Sep-1981
;		Changed TEST_NAME to agree with UETSUPDEV.DAT. 
;		Changed watch dog timers from using event flag #0 (default).
;
;	V03-005	RNP0004		Robert N. Perron,	22-Sep-1981
;		Changed INIT process to be detached instead of sub.
;
;	V03-004	LDJ0001		Larry D. Jones,		21-Sep-1981
;		Changed the .ENTRY and .TITLE to be UETTAPE01
;
;	V03-003	RNP0003		Robert N. Perron,	14-Sep-1981
;		Increased dismount watch dog timer interval.
;
;	V03-002	RNP0002		Robert N. Perron,	11-Sep-1981
;		Fixed race condition between dismount and init routines.
;
;	V03-001	RNP0001		Robert N. Perron,	02-Sep-1981
;		Modified so that UETINIDEV.DAT is updated only when in
;		oneshot mode.
;
;**
;--

	.SBTTL	Declarations
;
; INCLUDE FILES:
;
;	SYS$LIBRARY:LIB.MLB	for general definitions
;	SHRLIB$:UETP.MLB	for UETP definitions

;
; MACROS:
;
	$ACCDEF				; Accounting definitions
	$CHFDEF				; Condition handler frame definitions
	$DEVDEF				; Device definitions
	$DIBDEF				; Device Information Block
	$DMTDEF				; Dismount system service definitions
	$FIBDEF				; Define file info block symbols
	$IODEF				; Define I/O function codes
	$JPIDEF				; Getjpi definitions
	$MNTDEF				; Mount system sevice definitions
	$MTDEF				; Magtape definitions
	$SHRDEF				; Shared messages
	$STSDEF				; Status return
	$UETUNTDEF			; UETP unit block offset definitions
	$UETPDEF			; UETP
;
; EQUATED SYMBOLS:
;
;   Facility number definitions:
	UETP_K = 116
	RMS_K = 1

;   SHR message definitions:
	UETP = UETP_K@STS$V_FAC_NO	; Define the UETP facility code
;
	UETP$_ABENDD = UETP!SHR$_ABENDD	; Define the UETP message codes
	UETP$_BEGIND = UETP!SHR$_BEGIND
	UETP$_ENDEDD = UETP!SHR$_ENDEDD
	UETP$_OPENIN = UETP!SHR$_OPENIN
	UETP$_TEXT   = UETP!SHR$_TEXT

;   Internal flag bits...:
	TEST_OVERV    = 1		; Set when pass timer expires
	SAFE_TO_UPDV  = 2		; Set when its safe to update UETINIDEV
	BEGIN_MSGV    = 3		; Set when "begin" msg is output
	ONESHOT_MODEV = 4		; Set when "MODE" is "oneshot"
	LOOP_MODEV    = 5		; Set when "MODE" is "loop"
	DATA_ERRORV   = 6		; Set when compare of read & write data
					; ...fails in "one shot" mode
	TEST_STARTV   = 7		; Set when testing is started in normal
					; or loop modes

;   ...and corresponding masks:
	TEST_OVERM     = 1@TEST_OVERV
	SAFE_TO_UPDM   = 1@SAFE_TO_UPDV
	BEGIN_MSGM     = 1@BEGIN_MSGV
	ONESHOT_MODM   = 1@ONESHOT_MODEV
	LOOP_MODM      = 1@LOOP_MODEV
	DATA_ERRM      = 1@DATA_ERRORV
	TEST_STARTM    = 1@TEST_STARTV

;   Unit block device dependent flag bits:
	UETUNT$V_MOUNTED  = 3		; Set when tape is mounted
	UETUNT$V_MODIFIED = 4		; Set if we try to do a CREATE

;   ...and corresponding masks:
	UETUNT$M_MOUNTED  = 1@UETUNT$V_MOUNTED
	UETUNT$M_MODIFIED = 1@UETUNT$V_MODIFIED 

;   Miscellany:
	LC_BITM       = ^X20		; Mask to convert lower case to upper
	REC_SIZE      = 20		; UETINIDEV.DAT record size
	TEXT_BUFFER   = 132		; Internal text buffer size
	REQIDT1	      = 1		; AST parameter for pass completion
	REQIDT2	      = 2		; AST parameter for device hung
	MAX_DEV_DESIG = 8		; Longest possible controller name
	MAX_UNIT_DESIG= 5		; Longest possible unit number
	MAX_PROC_NAME = 15		; Longest possible process name
	MBX_SIZE      = 256		; Termination mailbox size
	DENS_LEN      = 5		; Length of density string
	ESC	      = ^X1B		; Escape character

;
;   Device dependent definitions:
;

; Orginal tape density
	UETUNT$K_DENSITY  = UETUNT$K_DEVDEP
; Device name descriptor
	UETUNT$Q_DEVDSC   = UETUNT$K_DEVDEP+DENS_LEN
; Device name buffer
	UETUNT$K_DEV_NAM  = UETUNT$K_DEVDEP+8+DENS_LEN  
; Index for buffer size list
	UETUNT$B_BUFPTR   = UETUNT$K_DEVDEP+8+DENS_LEN+MAX_DEV_DESIG+MAX_UNIT_DESIG 
; Index for density list
	UETUNT$B_DENSPTR  = UETUNT$K_DEVDEP+9+DENS_LEN+MAX_DEV_DESIG+MAX_UNIT_DESIG
; Unit read buffer
	UETUNT$K_RBUF     = UETUNT$K_DEVDEP+10+DENS_LEN+MAX_DEV_DESIG+MAX_UNIT_DESIG  

;   The following definitions are set depending on the device under test.
;   (all in bytes)

	DEVDEP_SIZE   = 10+DENS_LEN+MAX_DEV_DESIG+MAX_UNIT_DESIG  ; Size of
					; device dependent part of unit block
	WRITE_SIZE    = 32768		; Size of device write buffer
	READ_SIZE     = 32768		; Size of device read buffer

	PAGES = <<UETUNT$C_INDSIZ+-	; Add together all of the pieces...
		  DEVDEP_SIZE+-		; ...which make up a UETP unit block...
		  READ_SIZE+-		; ...to give to the $EXPREG service
		  511>/512>


	.SBTTL	Read-Only Data
	.PSECT	RODATA,NOEXE,NOWRT,PAGE

ACNT_NAME:				; Process name on exit
	.ASCID	/SYSTEST/

TEST_NAME:				; This test name
	.ASCID	/UETTAPE00/

SUPDEV_GBLSEC:				; How we access UETSUPDEV.DAT
	.ASCID	/UETSUPDEV/

CONTROLLER:				; Logical name of controller
	.ASCID	/CTRLNAME/

MODE:					; Run mode logical name
	.ASCID	/MODE/

LABEL:					; Required tape label
	.ASCID	/UETP        /		; 12 characters, same as DIB field

CS1:					; Device class and type control string
	.ASCID	/!2XB !2XB /

CS3:					; Device class-only control string
	.ASCID	/!2XB **/

CNTRLCMSG:
	.ASCID	\Aborted via a user CTRL/C\

TTNAME_ROPTR:				; Descriptor for recursive...
	.WORD	63,0			; ...translation of TTNAME
	.ADDRESS TTNAME

NO_CTRLNAME:
	.ASCID	/No controller specified./

DEAD_CTRLNAME:
	.ASCID	/Can't test controller !AS, marked as unusable in UETINIDEV.DAT./

NOUNIT_SELECTED:
	.ASCID	/No units selected for testing./

NOUNIT_TESTABLE:
	.ASCID	/No testable units ./

ILLEGAL_REC:
	.ASCID	/Illegal record format in file UETINIDEV.DAT!/

PASS_MSG:
	.ASCID	/End of pass !UL with !UL iterations at !%D./

TIME_OUT_MSG:				; Used by one shot mode
	.ASCID	/Time out - drive off line or not testable./

DATA_ERR_MSG:
	.ASCID	/Data compare error while testing !AS ./

MNT_ERR_MSG:
	.ASCID	/Error while mounting !AS ./

LABEL_ERR_MSG:
	.ASCID	/ !AS's label !AC is incorrect - sb !AS ./

HWL_ERR_MSG:
	.ASCID	/ !AS is write-locked./

DENSITY_ERR:
	.ASCID	/Unrecognizable density./

INIT_ERR_MSG:
	.ASCID	/Error while initializing !AS ./

DISMNT_ERR_MSG:
	.ASCID	/Error while dismounting !AS ./

THIRTYSEC:
	.LONG	10*1000*1000*30		; 30 seconds  time

THIRTYSEC_DELTA:
	.LONG	-10*1000*1000*30,-1	; 30 seconds delta time

THREEMIN:				; 3 minutes time
	.LONG	10*1000*1000*180

THREEMIN_DELTA:				; 3 minutes delta time 
	.LONG	-10*1000*1000*180,-1

CONT_DESC:				; Descriptor used to convert controller...
	.WORD	REC_SIZE,0		; ...from lowercase to uppercase
	.ADDRESS BUFFER

RMS_ERR_MSG:				; Announces an RMS error
	.ASCID	/RMS error in file !AD/

DROP_UNIT_MSG:			; Follows above msg if testing started
	.ASCID	/Device !AS dropped from testing./

PROMPT:
	.ASCII	/Controller designation?: /
	PMTSZ = .-PROMPT

; List of buffer sizes to use (in bytes, max= 32768).
BUF_SZ_LIST:
	.LONG	512
	.LONG	511
	.LONG	18
	.LONG	2048
	.LONG	32768
	FILE_SZ=.-BUF_SZ_LIST/4
	.LONG	0			; terminator

; Densities- (The length of all entries must be equal to DENS_LEN and
;	      end with a space)

DENS_LIST:
NRZI:	.ASCII	/ 800 /
PE:	.ASCII	/1600 /
GCR:	.ASCII	/6250 /
	.LONG	0			; terminator

; $GETJPI to get the base priority of the parent process

GET_LIS:
	.WORD 4
	.WORD JPI$_PRIB
	.ADDRESS BASPRI
	.LONG 0
	.LONG 0

; The following data is used for creating and running indirect commands.

LOGINOUT:
	.ASCID	/SYS$SYSTEM:LOGINOUT.EXE/

CMD_OUT:				; Command file output descriptor
	.WORD OUT_LEN,0
	.ADDRESS OUT_DEV
OUT_DEV:				; Output to null device
	.ASCII /NL:/
	OUT_LEN = .-OUT_DEV

CMD_FILE:
	.ASCID	/MAGTAPE.COM/




	.SBTTL	Read/Write Data
	.PSECT	RWDATA,WRT,NOEXE,PAGE

TTCHAN:					; Channel associated with SYS$INPUT
	.WORD	0

TTNAME_RWPTR:				; Descriptor for recursive...
	.WORD	TTNAME_LEN,0		; ...translation of TTNAME
	.ADDRESS TTNAME

TTNAME:
	.ASCII	/SYS$INPUT/
	TTNAME_LEN=.-TTNAME
	.BLKB	63-TTNAME_LEN

FLAG:					; Miscellaneous flag bits
	.WORD	0			; (See Equated Symbols for definitions)

FAO_BUF:				; FAO output string descriptor
	.WORD	TEXT_BUFFER,0
	.ADDRESS BUFFER

BUFFER_PTR:				; Fake .ASCID buffer for misc. strings
	.WORD	TEXT_BUFFER,0		; A word for length, a word for desc.
	.ADDRESS BUFFER

BUFFER:					; FAO output and other misc. buffer
	.BLKB	TEXT_BUFFER

CUR_UNTBLK:				; Address of current unit block
	.LONG	0

DEVDSC:					; Device name descriptor
	.WORD	MAX_DEV_DESIG,0		; -This will have actual length of DDcn string-
	.ADDRESS DEV_NAME

LOGNAM_DESC:				; Logical name for first testable device
	.LONG	LOGNAM_LEN		;  found that can be used by other tests
	.ADDRESS LOGNAM

LOGNAM:	.ASCII	/UET$MAGTAP/
	LOGNAM_LEN=.-LOGNAM

ONESHOT_DESC:				; File name descriptor - used for tape
	.WORD	ONESHOT_LEN,0		; ... record in oneshot mode
	.ADDRESS OS_FILNM

OS_FILNM:
	.ASCII /UETP.DAT;1/		; File version num. required for QIO's
	ONESHOT_LEN=.-OS_FILNM

FILNM_DESC:				; File name for tape records - normal
	.WORD	FILNM_LEN,0		;  and loop mode
	.ADDRESS FILNM

FILNM:	
	.ASCII	/:UETP.DAT/
	FILNM_LEN=.-FILNM

TIME:					; Pass duration
	.LONG	-10*1000*1000*180,-1	; three minutes to start with


; NOTE THAT THE CODE DEPENDS ON THE FOLLOWING TWO ITEMS BEING TOGETHER.

PROCESS_NAME:				; Process name
	.ASCID	/UETTAPE00_/

DEV_NAME:				; Device name buffer
	.BLKB	MAX_DEV_DESIG+MAX_UNIT_DESIG
	NAME_LEN = .-DEV_NAME

; END OF ITEMS WHICH CODE DEPENDS ON BEING TOGETHER.

DIB:					; Device Information Block
	.WORD	DIB$K_LENGTH,0
	.ADDRESS DIBBUF

DIBBUF:
	.BLKB	DIB$K_LENGTH

ERROR_COUNT:				; Cumulative error count at runtime
	.LONG	0

STATUS:					; Status value on program exit
	.LONG	0

IOSTAT:					; IO status block
	.QUAD	0

BASPRI:					; Base priority received from $Getjpi
	.LONG	2

AST_MODE:				; Prior setting of AST delivery
	.LONG	0

SS_FAIL_MODE:				; Prior setting of SS failure mode
	.LONG	0

INADDRESS:				; $CRMPSC address storage
	.LONG	0,0

OUTADDRESS:
	.LONG	0,0

UNIT_CNT:				; Number of units found
	.BYTE	0

DEVNAM_LEN:				; Current device name length
	.WORD	0

RANDOM1:				; Used for generating random data
	.LONG	^XAAAAAAAA
RANDOM2:
	.LONG	^XA72EA72E

ITERATION:				; Count of the number of files created
	.LONG	0			; ...in normal and loop modes

PASS:					; Pass count (loop mode)
	.LONG	0

MSG_BLOCK:				; Auxiliary $GETMSG info
	.BLKB	4

START_CNT:				; Number of units running
	.BYTE	0

EXIT_DESC:				; Exit handler descriptor
	.LONG	0
	.ADDRESS EXIT_HANDLER
	.LONG	1
	.ADDRESS STATUS

ARG_COUNT:				; Argument counter used by ERROR_EXIT
	.LONG	0

RMSRUNDWN_BUF:				; Return buffer for SYS$RMSRUNDWN close
	.WORD	22,0			;  failures
	.ADDRESS RUNDWN_BUF

RUNDWN_BUF:
	.BLKB 22

; Head of self-relative UETP unit block list.

	.ALIGN QUAD

UNIT_LIST:				; Head of unit block circular list
	.QUAD	0

NEW_NODE:				; Newly acquired node address
	.QUAD	0

; Shared write buffer address

WRITE_BUF:
	.QUAD	0			; $EXPREG gets beginning and ending address

; List of buffer start addresses.

BUF_ADR_LIST:
	.BLKL	FILE_SZ

; The following is used for the INITIALIZE command file creation

LABEL_CMD:
	.ASCII	\: UETP\			; ...label
	LABEL_LEN=.-LABEL_CMD

CMD_BUF:
	.ASCII	\$INIT/DENS=\			; Command
	INIT_LEN=.-CMD_BUF
	.BLKB	DENS_LEN			; ...density
	.BLKB	MAX_DEV_DESIG+MAX_UNIT_DESIG+LABEL_LEN ; ...unit

; The following is used for subprocess termination mail box - INIT_TAPE

MBX_BUF:
	.BLKB	MBX_SIZE

MBX_CHAN:
	.WORD	0

MBX_UNIT:
	.WORD	0

; define a FIB for oneshot mode (QIO)

FIB_DESC:				
	.LONG	FIB_LEN			
	.ADDRESS FIB

FIB:	.LONG	FIB$M_WRITE!FIB$M_NOWRITE ; Read/write access allowed
	.WORD	0,0,0			; File ID
	.WORD	0,0,0			; Directory ID
	.LONG	0			; Context
	.WORD	0			; Name flags
	.WORD	0			; Extend control
	.LONG	0			; Control value
	FIB_LEN=.-FIB

MNT_LIST:	; Item list for mount system service
	.WORD	MAX_DEV_DESIG+MAX_UNIT_DESIG	; Device name length
	.WORD	MNT$_DEVNAM		; Item code
	.ADDRESS DEV_NAME		; Device name buffer
	.LONG	0			; Unused
	.WORD	4			
	.WORD	MNT$_FLAGS		; Item code
	.ADDRESS MNT_FLAGS		; Mount flags buffer
	.LONG	0			; Unused
	.LONG	0			; List terminator

MNT_FLAGS:				; Mount flags
	.LONG	<<MNT$M_NOASSIST>!<MNT$M_OVR_IDENT>>



	.SBTTL	RMS-32 Data Structures

	.ALIGN  LONG
INFAB:					; Allocate FAB for SYS$INPUT
	$FAB-
	FNM=<SYS$INPUT:>
INRAB:					; Allocate RAB for SYS$INPUT
	$RAB-
	FAB=INFAB,-
	ROP=PMT,-
	PBF=PROMPT,-
	PSZ=PMTSZ,-
	UBF=DEV_NAME,-
	USZ=NAME_LEN

	.ALIGN	LONG
INI_FAB:				; Allocate FAB for UETINIDEV
	$FAB-
	FAC = <GET,PUT,UPD>,-
	RAT = CR,-
	SHR = <GET,PUT,UPI>,-
	FNM = <UETINIDEV.DAT>

INI_RAB:				; Allocate RAB for UETINIDEV
	$RAB-
	FAB = INI_FAB,-
	RBF = BUFFER,-
	UBF = BUFFER,-
	USZ = REC_SIZE

DDB_RFA:				; RFA storage for INI_RAB
	.BLKB	6

	.ALIGN	LONG
SUP_FAB:				; Allocate FAB for UETSUPDEV
	$FAB-
	FAC = GET,-
	SHR = <UPI,GET>,-
	RAT = CR,-
	FOP = UFO,-
	FNM = <UETSUPDEV.DAT>

; Dummy FAB and RAB to copy to the UETP unit blocks
; The following FAB and RAB must be contiguous and in this order!

DUMMY_FAB:
	$FAB-
		BLS = 512,-
		FAC = <BRO,GET,PUT>,-
		ORG = SEQ,-
		RFM = VAR

DUMMY_RAB:
	$RAB-
		ROP = <ASY,BIO>,-
		USZ = READ_SIZE

	.ALIGN	LONG
CMD_FAB:				; Command file FAB for INIT_TAPE
	$FAB-
		FNM = <MAGTAPE.COM>,-
		FAC = PUT,-
		RAT = CR
INIT_RAB:				; Initialize command RAB
	$RAB-
		FAB = CMD_FAB,-
		RBF = CMD_BUF

	.SBTTL	Main Program
	.PSECT	TAPE,EXE,NOWRT,PAGE

	.DEFAULT DISPLACEMENT,WORD

;+
;	Start up the tape test.  This entails some overhead necessary to cope
;	with both expected and unforseen conditions, figuring out just what
;	devices are to be tested, making sure we can test the indicated devices
;	and setting up writeable space for each device to be tested.
;-

.ENTRY UETTAPE00,^M<>			; Entry mask

	MOVAL	SSERROR,(FP)		; Declare exception handler
	$SETSFM_S ENBFLG = #1		; Enable system service failure mode
	$DCLEXH_S DESBLK = EXIT_DESC	; Declare an exit handler
	$TRNLOG_S LOGNAM = TTNAME_RWPTR,- ; Try SYS$INPUT to make sure it
		  RSLBUF = BUFFER_PTR	;  it points somewhere
	CMPL	R0,#SS$_NOTRAN		; Is there something there?
	BEQL	20$			; BR if no SYS$INPUT assigned
	$OPEN	FAB = INFAB,-		; Open SYS$INPUT
		ERR = RMS_ERROR
	$CONNECT-			; Connect RAB to SYS$INPUT
		RAB = INRAB,-
		ERR = RMS_ERROR
	BBC	#DEV$V_TRM,-		; BR if SYS$INPUT is NOT a terminal
		INFAB+FAB$L_DEV,10$
	$TRNLOG_S LOGNAM = CONTROLLER,-	; Get the name of controller if
		  RSLLEN = DEVNAM_LEN,-	;   logical name exists
		  RSLBUF = DEVDSC
	CMPL	R0,#SS$_NORMAL		; Was a controller specified?
	BEQL	PROC_CONT_NAME		; Yes, go process it 
10$:
	$GET	RAB = INRAB,-		; Read SYS$INPUT for controller name
		ERR = RMS_ERROR
	MOVW	INRAB+RAB$W_RSZ,-	; Save the name length
		DEVNAM_LEN
	BNEQ	PROC_CONT_NAME		; BR if we got something
20$:
	MOVL	#SS$_BADPARAM,STATUS	; Save the exit status
	PUSHAL	NO_CTRLNAME		; Prepare for message...
	PUSHL	#1			; ...arg count
	PUSHL	#UETP$_TEXT!STS$K_ERROR ; ...signal name
	PUSHL	#3			; ...arg count
	BRW	ERROR_EXIT		; ...go tell of bad setup

PROC_CONT_NAME:
	MOVW	DEVNAM_LEN,DEVDSC	; Set the device name length
	PUSHAL	DEVDSC			; Make sure...
	PUSHAL	DEVDSC			; ...that the specified controller...
	CALLS	#2,G^STR$UPCASE		; ...is all uppercase for later comaparison
	ADDW2	DEVNAM_LEN,PROCESS_NAME	; Get true process name length
	CMPW	PROCESS_NAME,#MAX_PROC_NAME ; Is the result too long for VMS?
	BLEQ	10$			; BR if not
	MOVW	#MAX_PROC_NAME,PROCESS_NAME ; Make it as long as you can
10$:
	CLRL	-(SP)			; Set the time stamp flag
	PUSHAL	PROCESS_NAME		; Set the test name
	PUSHL	#2			; Push the argument count
	PUSHL	#UETP$_BEGIND!STS$K_SUCCESS ; Set the message code
	CALLS	#4,G^LIB$SIGNAL		; Print the startup message
	BISW2	#BEGIN_MSGM,FLAG	; Set flag so we don't output it again
	$SETPRN_S PRCNAM = PROCESS_NAME	; Set the process name to UETDEVS00_x
	BBS	#DEV$V_TRM,-		; BR if SYS$INPUT is a terminal
		INFAB+FAB$L_DEV,20$
	BRW	40$
20$:
	$TRNLOG_S LOGNAM = TTNAME_RWPTR,- ; Recursively translate the name
		  RSLLEN = TTNAME_RWPTR,- ;   of our controlling terminal
		  RSLBUF = TTNAME_ROPTR
	MOVAL	TTNAME,TTNAME_RWPTR+4	; Undo possible previous PPF fixup
	CMPL	R0,#SS$_NOTRAN		; Have we reached the end yet?
	BEQL	30$			; BR if we have
	CMPW	#ESC,TTNAME		; Is this a Process Permanent File?
	BNEQ	20$			; Recursively translate if not
	SUBW	#4,TTNAME_RWPTR		; Remove RMS overhead from PPF name
	ADDL2	#4,TTNAME_RWPTR+4
	BRB	20$

30$:	; SYS$INPUT translation finished

	$ASSIGN_S DEVNAM = TTNAME_RWPTR,- ; We always need to assign a channel
		  CHAN   = TTCHAN	  ; Returned channel number
	$QIOW_S-			  ; Enable CTRL/C AST's...we are interractive
		CHAN     = TTCHAN,-
		FUNC     = #IO$_SETMODE!IO$M_CTRLCAST,-
		P1       = CCASTHAND	; Handler address
	PUSHAL	TEST_NAME		; ...and tell the user...
	PUSHL	#1			; ...
	PUSHL	#UETP$_ABORTC!STS$K_SUCCESS ; ...how to abort gracefully...
	CALLS	#3,G^LIB$SIGNAL		; ...
40$:


; From UETINIDEV.DAT and UETSUPDEV.DAT, get information which gives controller
; and unit configuration and lets us know if the setup to run this test was
; done correctly.

	$OPEN	FAB = INI_FAB,-		; Open file "UETINIDEV.DAT"
		ERR = RMS_ERROR
	$CONNECT RAB = INI_RAB,-	; Connect the RAB and FAB
		 ERR = RMS_ERROR
	$MGBLSC_S  INADR = INADDRESS,-	; Connect to UETSUPDEV global section -
		  RETADR = OUTADDRESS,-	;   if it is there
		  GSDNAM = SUPDEV_GBLSEC,-
		   FLAGS = #SEC$M_EXPREG
	CMPL	R0,#SS$_NOSUCHSEC	; Was the section already there?
	BNEQ	60$			; BR if it was...
	$OPEN	FAB = SUP_FAB,-		; ...else open "UETSUPDEV.DAT"
		ERR = RMS_ERROR
	$CRMPSC_S CHAN = SUP_FAB+FAB$L_STV,- ; Create the global section
		 INADR = INADDRESS,-
		RETADR = OUTADDRESS,-
		GSDNAM = SUPDEV_GBLSEC,-
		 FLAGS = #SEC$M_EXPREG!SEC$M_GBL

60$:	; We have a global section

	SUBL3	OUTADDRESS,OUTADDRESS+4,R9 ; Create global section length

FIND_IT: ; Let's look for a DDB

	$GET	RAB = INI_RAB,-		; Get the first record
		ERR = RMS_ERROR
	PUSHAL	CONT_DESC		; Make sure...
	PUSHAL	CONT_DESC		; ...that the controller name...
	CALLS	#2,G^STR$UPCASE		; ...is all uppercase letters
	CMPB	#^A/D/,BUFFER		; Is this a DDB?
	BEQL	10$			; BR if it is
	CMPB	#^A/E/,BUFFER		; Is this the end of the file?
	BNEQ	FIND_IT			; If not - look again
	PUSHAL	DEVDSC			; We are at EOF and a matching DDB was
	PUSHAL	PROCESS_NAME		; not found, bitch about it and quit
	PUSHL	#2			; ...arg count
	PUSHL	#UETP$_DENOSU		; ...signal name
	INSV	#STS$K_ERROR,-
		#STS$V_SEVERITY,-
		#STS$S_SEVERITY,(SP)	; Set the severity code...
	MOVL	(SP),STATUS		; ...and save it as the exit status
	PUSHL	#4			; ...arg count
	BRW	ERROR_EXIT		; Exit in error

10$:	; We found a DDB

	CMPC	DEVNAM_LEN,BUFFER+6,DEV_NAME ; Is this the right controller?
	BNEQ	FIND_IT			; If not, look some more
	MOVC3	#6,INI_RAB+RAB$W_RFA,DDB_RFA ; Save the Record File Address
	CMPB	#^A/T/,BUFFER+4		; Is controller marked testable?
	BEQL	FOUND_IT		; BR if it is testable
	$FAO_S	CTRSTR = DEAD_CTRLNAME,- ; ...and yell at user if it isn't
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = #DEVDSC	; Bad controller designation
	MOVL	#SS$_BADPARAM,STATUS	; Set return status
	PUSHAL	BUFFER_PTR		; ...
	PUSHL	#1			; ...
	PUSHL	#UETP$_TEXT!STS$K_ERROR	; ...
	PUSHL	#3			; ...
	BRW	ERROR_EXIT		; We can't test what we can't test

FOUND_IT: ; We have the right controller - let's look for UCB's

	$GET	RAB = INI_RAB,-		; Get a record
		ERR = RMS_ERROR
	PUSHAL	CONT_DESC		; Make sure...
	PUSHAL	CONT_DESC		; ...that this line...
	CALLS	#2,G^STR$UPCASE		; ...is all uppercase letters
	CMPB	#^A/U/,BUFFER		; Is this a UCB?
	BEQL	20$			; BR if it is
	CMPB	#^A/D/,BUFFER		; Is this a DDB?
	BEQL	10$			; BR if yes
	CMPB	#^A/E/,BUFFER		; Is this the end?
	BEQL	10$			; BR if yes
	PUSHAL	ILLEGAL_REC		; Then this is an error in the record
	PUSHL	#1			; Push the error message
	PUSHL	#UETP$_TEXT!STS$K_ERROR ; Push the signal name
	PUSHL	#3			; Push the temp arg count
	BRW	ERROR_EXIT		; Finish for good

10$:	; Found another DDB or END

	BRW	ALL_SET

20$:	; We found a UCB

	CMPB	#^A/T/,BUFFER+4		; Is the unit testable?
	BNEQ	FOUND_IT		; If not, look some more
	SKPC	#^A/ /,#MAX_UNIT_DESIG,- ; Find out where unit number really is
		BUFFER+6 
	ADDW3	R0,DEVNAM_LEN,DEVDSC	; Calculate device'unit string length
	MOVZWL	DEVNAM_LEN,R2		; Offset to unit number in DEVDSC
	MOVC3	R0,(R1),DEV_NAME(R2)	; Append unit number to device
	$GETDEV_S DEVNAM = DEVDSC,-	; Get the device characteristics
		  PRIBUF = DIB
	MOVZBL	DIBBUF+DIB$B_DEVCLASS,R7 ; Save the device class
	MOVZBL	DIBBUF+DIB$B_DEVTYPE,R8	; Save the device type
	$FAO_S	CTRSTR = CS1,-		; Make it into a string
		OUTBUF = FAO_BUF,-
		P1     = R7,-
		P2     = R8
	MATCHC	#6,BUFFER,R9,@OUTADDRESS ; Find the device class and type
	BEQL	30$			; BR if it was found
	$FAO_S	CTRSTR = CS3,-		; Try for full class support
		OUTBUF = FAO_BUF,-
		    P1 = R7
	MATCHC	#6,BUFFER,R9,@OUTADDRESS ; Find the device class only
	BNEQ	40$			; BR if not found

30$:	; Device type and class are correct - what about test?

	MOVZBL	TEST_NAME,R5		; Get the test name length
	CMPC3	R5,(R3),TEST_NAME+8	; Are we the right test?
	BEQL	50$			; BR if yes

40$:	; Can't make heads or tails out of this device - bitch and quit

	PUSHAL	DEVDSC			; Push device not supported message
	PUSHAL	PROCESS_NAME		; Parameters on the stack
	PUSHL	#2			; Push the argument count
	PUSHL	#UETP$_DENOSU
	INSV	#STS$K_ERROR,-
		#STS$V_SEVERITY,-
		#STS$S_SEVERITY,(SP)	; Set the severity code...
	MOVL	(SP),STATUS		; ...and save it as the exit status
	PUSHL	#4			; Push the partial arg count...
	BRW	ERROR_EXIT		; ...and split this scene


;+
; The following code dynamically allocates enough memory for a unit block,
; a device dependent parameter area and I/O buffers. The unit block is inserted
; into the queue header UNIT_LIST.  It then initializes the unit block.
; A comment indicates where the device dependent parameters should be
; initialized.  The unit block format is as follows:
;
;			+---------------+ -------
;	UETUNT$L_FLINK	!		!	^
;			+---------------+	!
;	UETUNT$L_BLINK	!		!	!
;			+-----------+---+	!
;	UETUNT$B_TYPE		    !   !	!
;			    +-------+---+	!
;	UETUNT$W_SIZE	    !   !   !    contains DEVDEP_SIZE + UETUNT$C_INDSIZ
;			+---+-------+		!
;	UETUNT$B_FLAGS  !   !			!
;			+---+   +-------+	!
;	UETUNT$W_CHAN	        !   !   !	!
;			+-------+-------+	!
;	UETUNT$W_FUNC	!   !   !		!
;			+-------+-------+	+----- UETUNT$C_SIZE
;	UETUNT$L_ITER	!		!	!
;			+---------------+	!
;	UETUNT$T_FILSPC	!		!	!
;			!/\/\/\/\/\/\/\/!	!
;			     128 bytes		!
;			!/\/\/\/\/\/\/\/!	!
;			!		!	!
;	UETUNT$K_FAB	!---------------!	!
;			!		!	!
;			!/\/\/\/\/\/\/\/!	!
;			 FAB$C_BLN bytes	!
;			!/\/\/\/\/\/\/\/!	!
;			!		!	!
;	UETUNT$K_RAB	+---------------+	!
;			!		!	!
;			!\/\/\/\/\/\/\/\!	!
;			 RAB$C_BLN bytes	!
;			!\/\/\/\/\/\/\/\!	!
;			!		!	v
;	UETUNT$K_DEVDEP +---------------+ -------
;	UETUNTK$_DENSITY!	    	!	^
;			!/\/\/\/\/\/\/\/!	!
;			    DENS_LEN		!
;			!/\/\/\/\/\/\/\/!	!
;			!		!	!
;			+---------------+	!
;	UETUNT$Q_DEVDSC	!	    	!	!
;			+---------------+	!
;			!		!	!
;			+---------------+	+-----DEVDEP_SIZE
;	UETUNT$K_DEV_NAM!	    	!	!
;			!\/\/\/\/\/\/\/\!	!
;			  MAX_DEV_DESIG+	!
;			  MAX_UNIT_DESIG	!
;			!/\/\/\/\/\/\/\/!	!
;			!		!	!
;			+-----------+---+	!
;	UETUNT$B_BUFPTR             !   !       !
;	 			+---+---+	!
;	UETUNT$B_DENSPTR	!   !		v
;			+-------+---+  ----------
;	UETUNT$K_RBUF	!	!    		^
;			!	+-------+	!
;			!\/\/\/\/\/\/\/\!	+----- READ_SIZE
;	READ buffer 	    READ_SIZE		!
;			!/\/\/\/\/\/\/\/!	!
;			!		!	v
;			+---------------+ -------
;-

50$:	$EXPREG_S PAGCNT = #PAGES,-
		  RETADR = NEW_NODE	; Get a new node of demand zero memory
	INSQTI	@NEW_NODE,UNIT_LIST	; Put the new node in the unit list
	MOVL	NEW_NODE,R6		; Save a copy of its address
	MOVB	#1,UETUNT$B_TYPE(R6)	; Set the structure type
	MOVW	#UETUNT$C_INDSIZ+DEVDEP_SIZE,-
		UETUNT$W_SIZE(R6)	; Set the structure size
	ADDB3	#FILNM_LEN,DEVDSC,-
		UETUNT$T_FILSPC(R6)	; Set the device name size
	MOVC3	DEVDSC,@DEVDSC+4,-
		UETUNT$T_FILSPC+1(R6)	; Save the device name
	MOVC3	#FILNM_LEN,FILNM,(R3)	; Rest of name
	MOVC3	#FAB$C_BLN+RAB$C_BLN,-
		DUMMY_FAB,UETUNT$C_FAB(R6) ; Save a FAB and a RAB away
	MOVAL	UETUNT$K_FAB(R6),R7	; Save the FAB address
	MOVAL	UETUNT$K_RAB(R6),R8	; Save the RAB address
	MOVL	R7,RAB$L_FAB(R8)	; Set the FAB address in the RAB
	MOVB	UETUNT$T_FILSPC(R6),-
		FAB$B_FNS(R7)		; Set the FNS field in the FAB
	MOVAL	UETUNT$T_FILSPC+1(R6),-
		FAB$L_FNA(R7)		; Set the FNA field in the FAB
	MOVAL	(R6),RAB$L_CTX(R8)	; Set the UETUNT address in the RAB
	MOVAL	(R6),FAB$L_CTX(R7)	;   and in the FAB
	MOVAL	UETUNT$K_DEV_NAM(R6),-	; Setup addr of device name descriptor
		UETUNT$Q_DEVDSC+4(R6)	;   in the unit block
	MOVL	DEVDSC,UETUNT$Q_DEVDSC(R6) ; Setup device name length
	MOVC3	DEVDSC,DEV_NAME,-
		UETUNT$K_DEV_NAM(R6)	; Save the device name
	BRW	FOUND_IT		; We are doing so well let's look
					;   for more UCB's


; Arrive here when we have the device configuration.  In normal or loop forever
; mode, set a timer far enough in the future such that we can do a reasonable
; set of tests before the timer expires, but if our device gets hung, the
; program won't waste too much time before noticing.  Let one-shot mode be a
; special case.

ALL_SET:
	TSTL	UNIT_LIST		; Anything to test?
	BNEQ	10$			; BR if yes
	PUSHAL	NOUNIT_SELECTED		; Else set up the error message...
	PUSHL	#1			; ...argument count...
	PUSHL	#UETP$_TEXT!STS$K_ERROR	; ...signal name...
	PUSHL	#3			; ...and parameter count
	MOVL	#SS$_BADPARAM,STATUS	; Set return status
	BRW	ERROR_EXIT		; ...and give up, complaining
10$:
	$EXPREG_S-			; Get memory for common write buffer
		PAGCNT = #WRITE_SIZE+511/512,-
		RETADR = WRITE_BUF

; Load write buffer with random data.

	MOVL	WRITE_BUF,R6		; Get buffer address
	MOVL	#WRITE_SIZE+3/4,R7	; Longword size
20$:
	ADDL2	RANDOM2,RANDOM1		; Get random longword
	MOVL	RANDOM1,(R6)+		; Save it
	SOBGTR	R7,20$			; Continue until done

; The following code gets buffer starting addresses.
; Buffers start at different places in the common buffer
; to vary the data pattern between records.

	MOVAL	BUF_SZ_LIST,R7		; Address of size list
	MOVAL	BUF_ADR_LIST,R8		; Address of address list
	MOVL	WRITE_BUF+4,R9		; Get end of buffer
30$:
	SUBL3	(R7)+,R9,(R8)+		; Subtract size to get start address
	TSTL	(R7)			; End of list?
	BNEQ	30$			; If not
	PUSHL	#0			; Zero indicates startup (not loop)
	BISW2	#SAFE_TO_UPDM,FLAG	; OK safe to update UETINIDEV.DAT now
	CALLS	#1,MOUNT_TAPE		; Let's go mount the tape(s)
	$TRNLOG_S LOGNAM = MODE,-	; Get the run mode
		  RSLLEN = BUFFER_PTR,-
		  RSLBUF = FAO_BUF
	BICB2	#LC_BITM,BUFFER		; Convert to upper case
	CMPB	#^A/O/,BUFFER		; Is this a one shot?
	BEQL	50$
	CMPB	#^A/L/,BUFFER		; Is this loop?
	BNEQ	40$
	BISW2	#LOOP_MODM,FLAG		; Set loop mode
40$:
	CMPB	#1,UNIT_CNT		; Is there only one unit to test?
	BEQL	RESTART			; If only one unit go ahead and start
	MOVZBL	UNIT_CNT,R11		; Get unit count
	DECL	R11			; Subtract first unit
	MULL3	R11,THIRTYSEC,R10	; Add thirty seconds of run time for
	ADDL2	THREEMIN,R10		; ...each unit after the first
	MNEGL	R10,TIME		; Compliment for delta time
	BRB	RESTART
50$:
	BISW2	#ONESHOT_MODM,FLAG	; Set one shot mode flag
	BRW	ONE_SHOT



RESTART:   ; Here we start testing in normal and loop modes.

;******************************************************************************
;
;  This routine starts off each unit by first synchronously creating a tape
; file and connecting to it, then it starts an asynchronous WRITE. Once started,
; all units are then run asycronously using AST's. WRITEs are continued until
; all buffer sizes in the buffer size list are written.  The file is CLOSEd 
; and SPACEd in reverse to prepare for reading the records.  Then READs are
; done to the end of the file with each record data checked.  When all records
; have been read a new file is started with a CREATE, and WRITEs are started
; again.  This continues until a timeout (three minutes + <the number of units
; - 1> * 30 seconds) occurs which was set at the start. After the timeout a
; thirty second watch dog timer is set and each unit completes the file it is
; processing and does a REWIND. If loop mode is set, the whole routine is
; repeated indefinitely.

	$SETIMR_S DAYTIM = TIME,-	; Testing will continue until this
		  EFN	 = #2,-
		  ASTADR = TIME_OUT,-	; timer expires
		  REQIDT = #REQIDT1	; End of pass ID
	BISW2	#TEST_STARTM,FLAG	; Testing has started
	CLRB	START_CNT		; Initialize units started counter
	ADDL3	#UNIT_LIST,UNIT_LIST,R7 ; Set the unit block list header

LOOP:	; We return here until all units are started.

	DECB	UNIT_CNT		; Decr the number of units to start
	BBC	#UETUNT$V_TESTABLE,-	; If unit not testable skip to next one
		UETUNT$B_FLAGS(R7),20$
	INCB	START_CNT		; Count the units as we start them
	BISB2	#UETUNT$M_MODIFIED,-	; Let's flag tape as modified before we
		UETUNT$B_FLAGS(R7)	; ...do it in case we get an error
	$CREATE-			; Create a file
		FAB = UETUNT$K_FAB(R7),-
		ERR = RMS_ERROR
	BLBC	R0,20$			; BR on error
	MOVAL	UETUNT$K_RAB(R7),R6	; Get RAB address
	$CONNECT-			; Connect RAB
		RAB = (R6),-
		ERR = RMS_ERROR
	BLBC	R0,20$			; BR on error
	CLRB	UETUNT$B_BUFPTR(R7)	; Initialize buffer list index
	MOVW	BUF_SZ_LIST,RAB$W_RSZ(R6) ; Set first buffer size in RAB
	MOVL	BUF_ADR_LIST,RAB$L_RBF(R6) ; Set first buffer addr in RAB
	$WRITE-				; Write a record
		RAB = (R6),-
		SUC = AST_WRITE,-
		ERR = RMS_ERROR
	BLBC	R0,20$			; BR on error

20$:	; Time to start next unit - if there is more

	ADDL2	(R7),R7			; Next unit block
	CMPL	R7,#UNIT_LIST		; Done all units?
	BNEQ	60$			; If not, start another
	TSTB	START_CNT		; Any unit started ok?
	BLEQ	40$			; BR if none
	$HIBER_S			; All testable units started- wait here
30$:
	TSTB	START_CNT		; Have all units finished?
	BGTR	50$			; If not branch
40$:
	$CANTIM_S			; Cancel pass timer if no units started
					; sucessfully, otherwise cancel 
					; watch dog timer.
	BICW2	#TEST_STARTM,FLAG	; We are done testing - clear flag
	BRW	END_PASS		; Exit the pass
50$:
	$HIBER_S			; Wait here for all to finish
	BRB	30$
60$:	BRW	LOOP			; Go start next unit

; Enter here after a WRITE.  Issues the next WRITE unless we are at
; end of buffer list, when it SPACEs back over records to prepare
; for READs.

AST_WRITE:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask
	MOVL	4(AP),R6		; Get RAB address
	MOVL	RAB$L_CTX(R6),R7	; Get unit block address
	BBC	#UETUNT$V_TESTABLE,-	; If unit not testable quit trying
		UETUNT$B_FLAGS(R7),20$
	ADDB	#4,UETUNT$B_BUFPTR(R7)	; Set index for next buffer
	MOVZBL	UETUNT$B_BUFPTR(R7),R8	; Get buffer list index
	TSTL	BUF_SZ_LIST(R8)		; Is it the terminator?
	BNEQ	10$			; If not
	MOVL	#-FILE_SZ,RAB$L_BKT(R6)	; Set blocks to skip(reverse)
	$SPACE-				; If done writing, get ready to read
		RAB = (R6),-
		SUC = AST_SPACE,-
		ERR = RMS_ERROR
	BRB	20$
10$:
	MOVW	BUF_SZ_LIST(R8),RAB$W_RSZ(R6) ; Set RAB buffer size
	MOVL	BUF_ADR_LIST(R8),RAB$L_RBF(R6) ; Set buffer address
	$WRITE-				; Write the next record
		RAB = (R6),-
		SUC = AST_WRITE,-
		ERR = RMS_ERROR
20$:	RET


; Entered from a space function.  Starts up a READ on the first record
; in the file.

AST_SPACE:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask
	MOVL	4(AP),R6		; Get RAB address
	MOVL	RAB$L_CTX(R6),R7	; Get unit block address
	BBC	#UETUNT$V_TESTABLE,-	; If unit not testable quit trying
		UETUNT$B_FLAGS(R7),10$
	CLRB	UETUNT$B_BUFPTR(R7)	; Initialize buffer list index
	MOVW	BUF_SZ_LIST,RAB$W_USZ(R6) ; Use 1st list entry
	MOVAL	UETUNT$K_RBUF(R7),RAB$L_UBF(R6) ; Read buffer address
	$READ-				; Read 1st record
		RAB = (R6),-
		SUC = AST_READ,-
		ERR = RMS_ERROR
10$:	RET

; Entered from READ function.  Checks the record just read and starts
; another READ, unless at the end of the buffer size list, when it
; CLOSEs the file.

AST_READ:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask
	MOVL	4(AP),R6		; Get RAB address
	MOVL	RAB$L_CTX(R6),R7	; Get unit block address
	BBC	#UETUNT$V_TESTABLE,-	; If unit not testable quit trying
		UETUNT$B_FLAGS(R7),05$
	MOVZBL	UETUNT$B_BUFPTR(R7),R8	; Get buffer list index
	MOVL	BUF_SZ_LIST(R8),R9	; Get size of last read
	MOVL	BUF_ADR_LIST(R8),R10	; Get write buffer address
	MOVAL	UETUNT$K_RBUF(R7),R11	; Get read buffer address
	BRB	10$
05$:
	BRW	40$			; Branch byte won't reach

10$:	; Compare data read to data writtem

	CMPB	(R10)+,(R11)+		; Check the byte
	BNEQ	20$			; BR if mismatch
	SOBGTR	R9,10$			; Do the whole buffer
	BRW	25$			; Done the whole buffer

20$:	; Output data compare error message

	INCL	ERROR_COUNT		; Bump the error count
	MOVAL	UETUNT$Q_DEVDSC(R7),R5	; Get address of unit name descriptor
	$FAO_S	CTRSTR = DATA_ERR_MSG,- ; prepare message
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1 = R5			; Unit name descriptor
	PUSHAL	BUFFER_PTR		; ...push error msg adr
	PUSHL	#1			; ...push arg count
	PUSHL	#UETP$_TEXT!STS$K_ERROR	; ...push signal name
	PUSHL	ERROR_COUNT		; ...and the error count...
	PUSHL	#1			; ...and the argument count...
	PUSHL	#UETP$_ERBOX!STS$K_ERROR ; ...and the signal name...
	CALLS	#6,G^LIB$SIGNAL		; ...and print the error
	$FAO_S	CTRSTR = DROP_UNIT_MSG,- ; prepare message
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1 = R5			; Unit name descriptor
	PUSHAL	BUFFER_PTR		; Dropped unit message
	PUSHL	#1			; Arg count
	PUSHL	#UETP$_TEXT!STS$K_ERROR	; Msg code and severity
	CALLS	#3,G^LIB$SIGNAL		; and print message
	BICB2	#UETUNT$M_TESTABLE,-	; Mark unit untestable
		UETUNT$B_FLAGS(R7)
	DECB	START_CNT		; No more testing for this unit!
	BGTR	40$			; BR if there are still units running
	$WAKE_S				; Wake up the start routine so testing
					; will end (no more units)
	RET
25$:
	ADDB	#4,UETUNT$B_BUFPTR(R7)	; Set index for next buffer
	MOVZBL	UETUNT$B_BUFPTR(R7),R8	; Get buffer list index
	TSTL	BUF_SZ_LIST(R8)		; End of list?
	BNEQ	30$			; If not branch
	$CLOSE-				; End of this file
		FAB = UETUNT$K_FAB(R7),-
		SUC = AST_CLOSE,-
		ERR = RMS_ERROR
	INCL	ITERATION		; Count the files completed
	BRB	40$
30$:
	MOVW	BUF_SZ_LIST(R8),RAB$W_USZ(R6) ; Set next size
	MOVAL	UETUNT$K_RBUF(R7),RAB$L_UBF(R6) ; Set read buffer address
	$READ-				; Read the next record
		RAB = (R6),-
		SUC = AST_READ,-
		ERR = RMS_ERROR
40$:	RET

; Entered from CLOSE function.  Starts a new file with CREATE, unless
; an end-of-pass timeout has occured, then it does a REWIND QIO.

AST_CLOSE:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask
	MOVL	4(AP),R6		; Get FAB address
	MOVL	FAB$L_CTX(R6),R7	; Get unit block address
	BBC	#TEST_OVERV,FLAG,10$	; BR if normal time-out has not occured
	BBC	#UETUNT$V_TESTABLE,-	; If unit not testable quit trying
		UETUNT$B_FLAGS(R7),20$
	MOVAL	UETUNT$K_RAB(R7),R6	; Get RAB address
	$ASSIGN_S-			; Get channel number for async rewind
		DEVNAM = UETUNT$Q_DEVDSC(R7),-
		CHAN = UETUNT$W_CHAN(R7)
	$QIO_S-				; Rewind to BOT
		CHAN = UETUNT$W_CHAN(R7),-
		FUNC = #IO$_REWIND!IO$M_NOWAIT,- ; Do it asycronously
		ASTADR = AST_REWIND,-
		ASTPRM = R6
	BRB	20$
10$:
	$CREATE-			; Start a new file
		FAB = (R6),-
		SUC = AST_CREATE,-
		ERR = RMS_ERROR
20$:	RET

; Entered from CREATE function.  Does a CONNECT to start writing again.

AST_CREATE:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask
	MOVL	4(AP),R6		; Get FAB address
	MOVL	FAB$L_CTX(R6),R7	; Get unit block address
	BBC	#UETUNT$V_TESTABLE,-	; If unit not testable quit trying
		UETUNT$B_FLAGS(R7),10$
	MOVAL	UETUNT$K_RAB(R7),R6	; Get RAB address
	MOVB	#-4,UETUNT$B_BUFPTR(R7)	; Initialize the buffer list pointer
	$CONNECT-			; Connect the RAB
		RAB = (R6),-
		SUC = AST_WRITE,-
		ERR = RMS_ERROR
10$:	RET

; Entered from a REWIND QIO. Decrements the active count and issues a WAKE to
; the start routine.

AST_REWIND:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask
	MOVL	4(AP),R6		; Get RAB address
	MOVL	RAB$L_CTX(R6),R7	; Get unit block address
	BBC	#UETUNT$V_TESTABLE,-	; If unit not testable quit trying
		UETUNT$B_FLAGS(R7),10$
	$DASSGN_S-			; Release channel
		CHAN = UETUNT$W_CHAN(R7)
	DECB	START_CNT		; Decrease active count
	$WAKE_S				; Wake up the start routine
10$:	RET





; ONE SHOT MODE - This routine performs synchronous QIO's to verify the
; testablity of each unit. A record of random data is written, read in reverse,
; compared and if  no errors are detected the unit is marked testable. 

ONE_SHOT:
	$SETSFM_S ENBFLG = #0		; Disable system service failure mode
	ADDL3	#UNIT_LIST,UNIT_LIST,R7 ; Set the unit block list header

ONESHOT_LOOP:	; Repeat for each unit

	BBS	#UETUNT$V_TESTABLE,-	; If unit not testable skip to next one
		UETUNT$B_FLAGS(R7),5$
	BRW	NEXT_UNIT
5$:
	MOVL	R7,CUR_UNTBLK		; Save address of current unit block
	$SETIMR_S DAYTIM = THIRTYSEC_DELTA,- ; Set a thirty second watch dog timer.
		  EFN	 = #2,-
		  ASTADR = UNIT_TIMEOUT	; Where we go if something hangs
	$ASSIGN_S-			; Assign a channel to the tape unit
		DEVNAM = UETUNT$Q_DEVDSC(R7),-
		CHAN   = UETUNT$W_CHAN(R7)
	MOVL	R0,IOSTAT		; Save return status code
	BSBW	ERROR_CHECK		; Check for errors

; Create and access the file

	BISB2	#UETUNT$M_MODIFIED,-	; Let's flag tape as modified before we
		UETUNT$B_FLAGS(R7)	; ...do it in case we get an error
	$QIOW_S	CHAN = UETUNT$W_CHAN(R7),-
		FUNC = #IO$_CREATE!IO$M_ACCESS!IO$M_CREATE,-
		IOSB = IOSTAT,-		; Address of I/O status word
		P1 = FIB_DESC,-		; FIB descriptor
		P2 = #ONESHOT_DESC	; Name descriptor
	BSBW	ERROR_CHECK		; Check for errors

; Write a block of random data

	$QIOW_S	CHAN = UETUNT$W_CHAN(R7),-
		FUNC = #IO$_WRITEVBLK,- ; Write virtual block
		IOSB = IOSTAT,-		; Address of I/O status word
		P1   = @WRITE_BUF,-	; Random data buffer
		P2   = #WRITE_SIZE	; Byte count
	BSBW	ERROR_CHECK		; Check for errors

; Preform a space reverse zero blocks so that the ACP will allow read access.

	CLRL	FIB+FIB$L_CNTRLVAL	; Set up to space zero blocks
	MOVW	#FIB$C_SPACE,-		; Set up for space function
		FIB+FIB$W_CNTRLFUNC
	$QIOW_S CHAN = UETUNT$W_CHAN(R7),-
		FUNC = #IO$_ACPCONTROL,- ; Perform ACP control function
		IOSB = IOSTAT,-		; Address of I/O status word
		P1   = FIB_DESC
	BSBW	ERROR_CHECK		; Check for errors

; Read the file in reverse

	$QIOW_S	CHAN = UETUNT$W_CHAN(R7),-
		FUNC = #IO$_READVBLK!IO$M_REVERSE,-
		IOSB = IOSTAT,-
		P1   = UETUNT$K_RBUF(R7),- ; Read buffer
		P2   = #WRITE_SIZE	
	BSBW	ERROR_CHECK		; Check for errors

; Compare data read to data written

	MOVL	#WRITE_SIZE,R9		; Get size of buffers
	MOVAL	UETUNT$K_RBUF(R7),R10	; Get read buffer
	MOVAL	@WRITE_BUF,R11		; Get write buffer
10$:
	CMPB	(R10)+,(R11)+		; Check the byte
	BNEQ	20$			; BR if bytes are same
	SOBGTR	R9,10$			; Go do next byte-until done
	BRB	30$			; Data check complete

20$:	; Data compare failed

	BISW2	#DATA_ERRM,FLAG		; Set data error flag
	CLRQ	IOSTAT			; Clear possible left over error code
	BRW	REPORT_ERROR		; Go report error

30$:	; Data compare ok - deaccess the file

	$QIOW_S	CHAN = UETUNT$W_CHAN(R7),-	; Deaccess the file
		FUNC = #IO$_DEACCESS,-
		IOSB = IOSTAT
	BSBW	ERROR_CHECK		; Check for errors
	$DASSGN_S  CHAN = UETUNT$W_CHAN(R7)	; Deassign the channel
	BSBW	ERROR_CHECK		; Check for errors
	$CANTIM_S			; Forget the watchdog timer

NEXT_UNIT: ; Do the next unit - if there is more

	ADDL2	(R7),R7			; Next unit block
	CMPL	R7,#UNIT_LIST		; Done all units?
	BNEQ	10$			; Go check next unit
	$SETSFM_S ENBFLG = #1		; Enable system service failure mode
	BRW	END_PASS		; All done!
10$:
	BRW	ONESHOT_LOOP	

ERROR_CHECK: ; Here we check for QIO errors

	BLBS	R0,10$			; BR if I/O request queued OK
	TSTL	R0			; Test R0 for return status of zero
	BEQL	REPORT_ERROR		; BR if zero
	MOVL	R0,IOSTAT		; Set error code
	BRB	REPORT_ERROR		; Go print error
10$:
	BLBC	IOSTAT,REPORT_ERROR	; BR if QIO failed
	RSB				; Return to test - no errors detected

REPORT_ERROR: ; We got an error - output appropriate message(s)

	BICB2	#UETUNT$M_TESTABLE,-	; Mark unit untestable
		UETUNT$B_FLAGS(R7)
	$CANTIM_S			; Forget the watchdog timer
	INCL	ERROR_COUNT		; Bump the error count
	PUSHL	IOSTAT			; Push the error code...
	PUSHL	IOSTAT			; ...and the error code...
	PUSHAL	UETUNT$Q_DEVDSC(R7)	; ...and the device designation.
	PUSHAL	TEST_NAME		; ...and the test name...
	PUSHL	#3			; ...and the arg count...
	PUSHL	#UETP$_DEUNUS!STS$K_ERROR ; ...and the signal name...
	PUSHL	ERROR_COUNT		; ...and the error count...
	PUSHL	#1			; ...and the argument count...
	PUSHL	#UETP$_ERBOX!STS$K_ERROR ; ...and the signal name...
	CALLS	#9,G^LIB$SIGNAL		; ...and print the error
	CMPW	IOSTAT,#SS$_CANCEL	; Was IO canceled because of timeout?
	BEQL	10$			; BR if it was
	CMPW	IOSTAT,#SS$_ABORT	; Was IO aborted because of timeout?
	BNEQ	20$			; BR if it wasn't

10$:	; Something must of hung and watch dog timer went off

	PUSHAL	TIME_OUT_MSG		; ...push the error message adr
	PUSHL	#1			; ...push the arg count...
	PUSHL	#UETP$_TEXT!STS$K_ERROR ; ...push the signal name...
	CALLS	#3,G^LIB$SIGNAL		; ...report the error...
	BRB	30$

20$:	; Data compare error? Output error msg if it was

	BBC	#DATA_ERRORV,FLAG,30$	; BR if not data compare error
	MOVAL	UETUNT$Q_DEVDSC(R7),R8	; Get address of unit name descriptor
	$FAO_S	CTRSTR = DATA_ERR_MSG,- ; prepare message
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1 = R8			; Unit name descriptor
	PUSHAL	BUFFER_PTR		; ...push error msg adr
	PUSHL	#1			; ...push arg count
	PUSHL	#UETP$_TEXT!STS$K_ERROR	; ...push signal name
	CALLS	#3,G^LIB$SIGNAL		; ...report the error
	BICW2	#DATA_ERRM,FLAG		; Clear flag - error has been printed
30$:
	BRW	NEXT_UNIT

UNIT_TIMEOUT: ; Go here with watchdog timer timeout

	.WORD	0
	MOVL	CUR_UNTBLK,R6		   ; Get the unit block address
	$CANCEL_S CHAN = UETUNT$W_CHAN(R6) ; This IO will never complete
	RET



END_PASS:

;  This routine is entered on completion of a pass. In normal and
; one-shot modes the image exits. In loop mode  the end of pass message is
; output, the units are dismount, initialized, remounted and another pass is 
; started.

	BBC	#LOOP_MODEV,FLAG,10$	; BR if not loop forever
	BICW2	#TEST_OVERM,FLAG	; Reset the termination flag
	INCL	PASS			; Bump the pass count
	$FAO_S	CTRSTR = PASS_MSG,-	; Format the end of pass msg
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = PASS,-
		P2     = ITERATION,-
		P3     = #0
	PUSHAL	BUFFER_PTR		; Push the string desc.
	PUSHL	#1			; Push arg count
	PUSHL	#UETP$_TEXT!STS$K_INFO	; Push the signal name
	CALLS	#3,G^LIB$SIGNAL		; Print the end of pass message
	CLRL	ITERATION		; Reset the iteration count
	CALLS	#0,DISMOUNT_TAPE	; Let's go dismount the tape(s)
	PUSHL	#1			; Set loop mode
	CALLS	#1,INIT_TAPE		; Let's go init the tape(s) we modified
	PUSHL	#1			; Set loop mode
	CALLS	#1,MOUNT_TAPE		; Go mount tape(s) for another pass
	BRW	RESTART			; Do the next pass
10$:
	MOVL	#SS$_NORMAL!STS$M_INHIB_MSG,STATUS ; Set successful exit status
	$EXIT_S STATUS			; Exit with the status


	.SBTTL	Mount Routine
;++
; FUNCTIONAL DESCRIPTION:
;	This routine calls the $MOUNT system service for each tape drive. If 
;	the mount completes successfully the label and hardware write
;	protection are all checked. If the tape passes all the tests the
;	UETUNT$M_MOUNTED and UETUNT$M_TESTABLE flags are set and the density
;	is saved in UETUNT$K_DENSITY. If the tape fails any of the above tests
;	the unit is dismounted and an error message is output. In loop mode
;	if the UETUNT$M_TESTABLE flag is not set the unit is skipped.
;	If no units are mounted successfully an error message is printed and
;	ERROR_EXIT is called.
;
; CALLING SEQUENCE:
;	PUSHL	#0 or #1	; 0 for startup, 1 for loop mode
;	CALLS	#1,MOUNT_TAPE
;
; INPUT PARAMETERS:
;	N0NE
;
; IMPLICIT INPUTS:
;	UNIT_LIST points to the head of a doubly linked circular list of unit
;		  blocks for the device(s) under test.
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Error message if $MOUNT fails or tape label and hardware
;	protection is not correct.
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	Image will exit if no units are mounted successfully.
;
;--

MOUNT_TAPE:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	MOVL	4(AP),R5		; Get mode argument
  	ADDL3	#UNIT_LIST,UNIT_LIST,R7 ; Set the unit block list header
	CLRB	UNIT_CNT		; Clear the number of testable units
	CLRB	ARG_COUNT		; Initialize the error arg count

MOUNT_LOOP: ; Return here for each unit

	BLBC	R5,10$			; BR if we are just starting up
	BBS	#UETUNT$V_TESTABLE,-	; BR if unit is still testable
		UETUNT$B_FLAGS(R7),10$
	BRW	NEXT_UNT		; This unit failed last pass - skip it
10$:
	MOVL	UETUNT$Q_DEVDSC(R7),-	; Setup device name length
		DEVDSC
	MOVW	UETUNT$Q_DEVDSC(R7),-	; Also set device name length in mount
		MNT_LIST		;   item list
	MOVC3	DEVDSC,UETUNT$K_DEV_NAM(R7),- ; Get the device name
		DEV_NAME
	$MOUNT_S-			; This amounts to MOUNT/NOASSIST/OV=ID
		ITMLST = MNT_LIST
	CMPL	R0,#SS$_NORMAL
	BEQL	20$			; BR if no errors
	PUSHL	R0			; Set the error code
	$FAO_S	CTRSTR = MNT_ERR_MSG,- ; prepare message
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = #DEVDSC	; Unit name descriptor
	PUSHL	#1			; ...push partial arg count	
	BRW	MNT_ERROR		; Go tell everyone

20$:	; Unit mounted ok - let's find out what we got

	$GETDEV_S-			; Get info on this device
		DEVNAM = DEVDSC,-
		PRIBUF = DIB

	; Here we verify the tape label

	MOVZBL	DIBBUF+DIB$W_VOLNAMOFF,R6 ; Get volume name offset
	CMPC3	LABEL,LABEL+8,DIBBUF+1(R6) ; Check for correct label
	BEQL	30$			; BR if label is correct
	ADDL2	#DIBBUF,R6		; Get address of label descriptor
	$FAO_S	CTRSTR = LABEL_ERR_MSG,- ; prepare message
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = #DEVDSC,-	; Unit name descriptor
		P2     = R6,-		; Tape label
		P3     = #LABEL		; Expected label
	PUSHL	#0			; ...push partial arg count	
	BRW	DISMNT			; We can't test this one - dismount it

30$:	; Here we check to see if the unit is hardware write-locked

	BBC	#MT$V_HWL,DIBBUF+DIB$L_DEVDEPEND,50$ ; BR if not write-locked
	$FAO_S	CTRSTR = HWL_ERR_MSG,- ; prepare message
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = #DEVDSC	; Unit name descriptor
	PUSHL	#0			; ...push partial arg count	
	BRW	DISMNT			; We can't test this one - dismount it

50$:	; Tape passed tests - let's get the density

	EXTZV	#MT$V_DENSITY,#MT$S_DENSITY,- ; Get density field
		DIBBUF+DIB$L_DEVDEPEND,R8
	CASEB	R8,#3,#5		; BR according to density
60$:	.WORD	0800$-60$		; 0800 bpi - MT$K_NRZI_800
	.WORD	1600$-60$		; 1600 bpi - MT$K_PE_1600
	.WORD	6250$-60$		; 6250 bpi - MT$K_GCR_6250

; Case fell through, unrecognized density

	MOVL	DENSITY_ERR,BUFFER_PTR	; Move error msg to buffer
	MOVC3	DENSITY_ERR,DENSITY_ERR+8,BUFFER
	PUSHL	#0
	BRW	DISMNT
0800$:
	MOVL	#NRZI,R9		; Get address of density 800
	BRB	70$
1600$:
	MOVL	#PE,R9			; Get address of density 1600
	BRB	70$
6250$:
	MOVL	#GCR,R9			; Get address of density 6250

70$:	; If we made it here we have what looks like a testable unit

	MOVC3	#DENS_LEN,(R9),-	; Save density
		UETUNT$K_DENSITY(R7)
	BISB2	#UETUNT$M_TESTABLE,- 	; Mark unit testable
		UETUNT$B_FLAGS(R7)
	BISB2	#UETUNT$M_MOUNTED,-	; Set mounted flag
		UETUNT$B_FLAGS(R7)
	INCB	UNIT_CNT		; Bump the unit count

NEXT_UNT: ; Do next unit - if there is more

	ADDL2	(R7),R7			; Get next unit block
	CMPL	R7,#UNIT_LIST		; End of list?
	BEQL	10$			; BR if end
	BRW	MOUNT_LOOP
10$:
	TSTL	UNIT_CNT		; Any units to test?
	BEQL	MOUNT_EXIT		; BR if no units mounted
	RET

DISMNT:	; here we dismount the untestable units

	$DISMOU_S-			; Dismount and let it unload
		DEVNAM = UETUNT$Q_DEVDSC(R7)

MNT_ERROR: ; If we got here we have a unit in trouble - tell everyone and go on
	   ; to next unit

	ADDL3	(SP)+,#6,ARG_COUNT	; Get total # args, pop partial count
	INCL	ERROR_COUNT		; Keep running error count
	PUSHAL	BUFFER_PTR		; Get error msg
	PUSHL	#1			; ...argument count...
	PUSHL	#UETP$_TEXT!STS$K_ERROR	; ...signal name...
	PUSHL	ERROR_COUNT		; Finish off arg list...
	PUSHL	#1			; ...
	PUSHL	#UETP$_ERBOX!STS$K_ERROR ; ...for error box message
	CALLS	ARG_COUNT,G^LIB$SIGNAL	; Truly bitch
	BICB2	#UETUNT$M_TESTABLE,-	; Mark unit untestable - we could be in
		UETUNT$B_FLAGS(R7)	; ... loop mode
	CLRB	ARG_COUNT		; Initialize the error arg count
	BRB	NEXT_UNT

MOUNT_EXIT:  ; If no testable units it's time to bail out

	PUSHAL	NOUNIT_TESTABLE		; Get error msg
	PUSHL	#1			; ...argument count...
	PUSHL	#UETP$_TEXT!STS$K_ERROR	; ...signal name...
	PUSHL	#3			; ...and parameter count
	CLRL	STATUS			; We already said enough
	BRW	ERROR_EXIT		; ...and give up, complaining



	.SBTTL	Dismount Routine
;++
; FUNCTIONAL DESCRIPTION:
;	This routine checks the UETUNT$M_MOUNTED flag for each tape drive and 
;	if it is set the $DISMOUNT system service is called with the nounload 
;	qualifier. When the dismount is complete the UETUNT$M_MOUNTED flag is 
;	cleared.
;
; CALLING SEQUENCE:
;	CALLS	#0,DISMOUNT_TAPE
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	UNIT_LIST points to the head of a doubly linked circular list of unit
;		  blocks for the device under test.
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

DISMOUNT_TAPE:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

  	ADDL3	#UNIT_LIST,UNIT_LIST,R7 ; Set the unit block list header
	$SETAST_S ENBFLG = #1		; Enable AST delivery
	CLRL	AST_MODE		; Assume it was disabled
	CMPL	R0,#SS$_WASSET		; Were AST's enabled?
	BNEQ	10$			; BR if not enabled
	MOVL	#1,AST_MODE		; Set it to be reenabled
10$:	$SETSFM_S ENBFLG = #0		; Disable SS failure mode 
	CLRL	SS_FAIL_MODE		; Assume it was disabled
	CMPL	R0,#SS$_WASSET		; Was SS failure mode enabled?
	BNEQ	DISMNT_LOOP		; BR if not enabled
	MOVL	#1,SS_FAIL_MODE		; Set it to be reenabled

DISMNT_LOOP: ; Return here for each unit

	BBS	#UETUNT$V_MOUNTED,-	; BR if tape is mounted
		UETUNT$B_FLAGS(R7),5$
	BRW	NEXT1			; Skip to next unit
5$:
	$DISMOU_S-			; Dismount/nounload
		DEVNAM = UETUNT$Q_DEVDSC(R7),-
		FLAGS  = #DMT$M_NOUNLOAD
	CMPL	R0,#SS$_NORMAL		; Dismount ok?
	BEQL	10$			; BR if no errors
	MOVL	R0,IOSTAT		; Set error code
	BICB2	#UETUNT$M_TESTABLE,-	; Mark unit untestable
		UETUNT$B_FLAGS(R7)
	INCL	ERROR_COUNT		; Bump the error count
	PUSHL	IOSTAT			; Push the error code...
	MOVAL	UETUNT$Q_DEVDSC(R7),R8	; Get address of unit name descriptor
	$FAO_S	CTRSTR = DISMNT_ERR_MSG,- ; prepare message
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = R8		; Unit name descriptor
	PUSHAL	BUFFER_PTR		; ...push error msg adr
	PUSHL	#1			; ...push arg count
	PUSHL	#UETP$_TEXT!STS$K_ERROR	; ...push signal name
	PUSHL	ERROR_COUNT		; ...and the error count...
	PUSHL	#1			; ...and the argument count...
	PUSHL	#UETP$_ERBOX!STS$K_ERROR ; ...and the signal name...
	CALLS	#7,G^LIB$SIGNAL		; ...and print the error
	BRB	NEXT1

10$:	; Here we set a watch dog timer and wait for dismount to complete

	$SETIMR_S DAYTIM = THREEMIN_DELTA,- ; Set a three minute watch dog timer.
		  EFN	 = #2,-
		  ASTADR = DISMOUNT_TIMEOUT	; Where we go if something hangs
	MOVL	R7,CUR_UNTBLK		; Save the unit block address
20$:
	$GETDEV_S-			; Get info on this device
		DEVNAM = UETUNT$Q_DEVDSC(R7),-
		PRIBUF = DIB
	BBS	#DEV$V_MNT,DIBBUF+DIB$L_DEVCHAR,20$ ; BR if still mounted
	$CANTIM_S			; Cancel watch dog timer
	BICB2	#UETUNT$M_MOUNTED,-	; Clear mounted flag
		UETUNT$B_FLAGS(R7)

NEXT1:	; Do next unit - if there is more

	ADDL2	(R7),R7			; Get next unit block
	CMPL	R7,#UNIT_LIST		; End of list?
	BEQL	10$			; BR if end
	BRW	DISMNT_LOOP		; Go do next unit
10$:	RET				; All done

DISMOUNT_TIMEOUT: ; We get here if dismount doesn't finish within three minutes

	.WORD	0
	MOVL	CUR_UNTBLK,R6		; Get the unit block address
	MOVL	#SS$_TIMEOUT,IOSTAT	; Set exit code
	PUSHL	IOSTAT
	MOVAL	UETUNT$Q_DEVDSC(R6),R8	; Get address of unit name descriptor
	$FAO_S	CTRSTR = DISMNT_ERR_MSG,- ; prepare message
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = R8		; Unit name descriptor
	PUSHAL	BUFFER_PTR		; ...push error msg adr
	PUSHL	#1			; ...push arg count
	PUSHL	#UETP$_TEXT!STS$K_ERROR	; ...push signal name
	PUSHL	ERROR_COUNT		; ...and the error count...
	PUSHL	#1			; ...and the argument count...
	PUSHL	#UETP$_ERBOX!STS$K_ERROR ; ...and the signal name...
	CALLS	#7,G^LIB$SIGNAL		; ...and print the error
	$CANEXH_S			; Cancel all exit handlers
	$EXIT_S


	.SBTTL	Initialize Routine
;++
; FUNCTIONAL DESCRIPTION:
;	This routine initializes each tape drive in which the UETUNT$M_MODIFIED
;	flag is set. A DCL command file is created containing an INITIALIZE
;	command and is then executed as a subprocess. This is repeated for each
;	unit. In loop mode the tapes are initialized on subseqent passes 
;	to different densities selected by rotating though a list of supported 
;	densities. When testing is complete the tapes are initialized to their
;	orginally density.
;
; CALLING SEQUENCE:
;	PUSHL	#0 or #1	; 1 for loop mode - 0 for all others
;	CALLS	#1,INIT_TAPE
;
; INPUT PARAMETERS:
;	Argument on stack for loop mode or other.
;
; IMPLICIT INPUTS:
;	UNIT_LIST points to the head of a doubly linked circular list of unit
;		  blocks for the device under test.
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Command file MAGTAPE.COM is created temporarily. A subprocess is
;	temporarily created.
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	If this routine aborts before it completes MAGTAPE.COM may be left
;	on the disk.
;
;--

INIT_TAPE:

	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	MOVL	4(AP),R5		; Get mode argument
  	ADDL3	#UNIT_LIST,UNIT_LIST,R7 ; Set the unit block list header
	$SETAST_S ENBFLG = #1		; Enable AST delivery
	CLRL	AST_MODE		; Assume it was disabled
	CMPL	R0,#SS$_WASSET		; Were AST's enabled?
	BNEQ	10$			; BR if not enabled
	MOVL	#1,AST_MODE		; Set it to be reenabled
10$:
	$SETSFM_S ENBFLG = #0		; Disable SS failure mode 
	CLRL	SS_FAIL_MODE		; Assume it was disabled
	CMPL	R0,#SS$_WASSET		; Was SS failure mode enabled?
	BNEQ	INIT_LOOP		; BR if not enabled
	MOVL	#1,SS_FAIL_MODE		; Set it to be reenabled

INIT_LOOP: ; Return here for each unit

	BBS	#UETUNT$V_MODIFIED,-	; Init tape only if we wrote on it
		UETUNT$B_FLAGS(R7),10$
	BRW	NEXT			; Skip to next unit
10$:
	$CREATE-			; Create the command file
		FAB = CMD_FAB
	BSBW	ERR_CHK			; Go check for errors
	$CONNECT-			; Connect the selected RAB
		RAB = INIT_RAB
	BSBW	ERR_CHK			; Go check for errors
	MOVL	#INIT_LEN,R6		; Get init command length
	TSTL	R5			; Loop mode?
	BNEQ	20$			; BR if loop mode
	MOVC3	#DENS_LEN,UETUNT$K_DENSITY(R7),- ; Get original density
		CMD_BUF(R6)
	BRB	40$

20$:	; Get new density for next pass if loop mode

	ADDB2	#DENS_LEN,UETUNT$B_DENSPTR(R7)	; Move index pointer to next density
	MOVZBL	UETUNT$B_DENSPTR(R7),R10 ; Get the index
	TSTL	DENS_LIST(R10)		; Terminator?
	BNEQ	30$			; BR if it isn't
	CLRB	UETUNT$B_DENSPTR(R7)	; Point to start of list
	CLRL	R10
30$:
	MOVC3	#DENS_LEN,DENS_LIST(R10),- ; Fill in density in command string
		CMD_BUF(R6)

40$:	; finish command string

	ADDL2	#DENS_LEN,R6		; Update length
	MOVC3	UETUNT$Q_DEVDSC(R7),-	; Fill in device name
		UETUNT$K_DEV_NAM(R7),CMD_BUF(R6)
	ADDW2	UETUNT$Q_DEVDSC(R7),R6	; Udate length
	MOVC3	#LABEL_LEN,LABEL_CMD,-	; Fill in the label
		CMD_BUF(R6)
	ADDL3	#LABEL_LEN,R6,-		; Update length and put it in RAB
		INIT_RAB+RAB$W_RSZ

; Write command string to file

	$PUT	RAB = INIT_RAB
	BSBW	ERR_CHK			; Go check for errors

; Close command file

	$CLOSE	FAB = CMD_FAB
	BSBW	ERR_CHK			; Go check for errors

; Create a termination mailbox

	$CREMBX_S-
		CHAN = MBX_CHAN
	BSBW	ERR_CHK			; Go check for errors
	$GETCHN_S-			; Get its unit number
		CHAN = MBX_CHAN,-
		PRIBUF = DIB
	BSBW	ERR_CHK			; Go check for errors
	MOVW	DIBBUF+DIB$W_UNIT,MBX_UNIT	; Save mbx unit number

; now get the base priority of the parent process
	
	$GETJPI_S ITMLST = GET_LIS,-
		  EFN    = #1
	$WAITFR_S EFN = #1		; wait till this is done

; Run command file as a subprocess

	$CREPRC_S-
		IMAGE  = LOGINOUT,-
		INPUT  = CMD_FILE,- 
		OUTPUT = CMD_OUT,-
		BASPRI = BASPRI,-
		MBXUNT = MBX_UNIT
	BSBW	ERR_CHK			; Go check for errors

; It shouldn't take more than 30 seconds to complete

	$SETIMR_S DAYTIM = THIRTYSEC_DELTA,- ; Set a thirty second watch dog timer.
	  	EFN	 = #2,-
		ASTADR    = INIT_TIMEOUT
	BSBW	ERR_CHK			; Go check for errors
	$QIOW_S-			; Wait for process to finish
		CHAN = MBX_CHAN,-
		EFN  = #1,-
		FUNC = #IO$_READVBLK,-
		IOSB = IOSTAT,-
		P1   = MBX_BUF,-
		P2   = #MBX_SIZE
	BSBW	QIO_ERROR		; Subprocess complete ok?;
	BICL2	#UETUNT$M_MODIFIED,-	; Clear modified flag
		UETUNT$B_FLAGS(R7)

ERASE:	; Delete the temporary command file

	$ERASE	FAB = CMD_FAB

NEXT:	; Do next unit - if there is more

	ADDL2	(R7),R7			; Get next unit block
	CMPL	R7,#UNIT_LIST		; End of list?
	BEQL	10$			; BR if end
	BRW	INIT_LOOP
10$:
	TSTL	ERROR_COUNT		; Any errors?
	BEQL	20$			; BR if none
	MOVL	#STS$K_ERROR!STS$M_INHIB_MSG,STATUS ; Set exit code
20$:
	$SETSFM_S ENBFLG = SS_FAIL_MODE ; Set to previous state
	$SETAST_S ENBFLG = AST_MODE	; Set to previous state
	RET				; All done

QIO_ERROR: ; Here we check for QIO errors

	BLBS	R0,10$			; BR if I/O request queued ok
	TSTL	R0			; Test R0 for a return status of zero
	BEQL	20$
10$:
	CMPW	IOSTAT,#SS$_NORMAL	; I/O  successful?
	BEQL	30$			; BR if error
20$:
	MOVL	IOSTAT,R0		; Set error code
	BRB	ERR_CHK			; Go print error
30$:
	$CANTIM_S			; If we got here we don't need timer
					; ....any longer
	CMPL	MBX_BUF+ACC$L_FINALSTS,- ; Check subprocess exit status
		#SS$_NORMAL
	BNEQ	40$			; BR if error
	RSB				; Return to test - no errors detected
40$:
	MOVL	MBX_BUF+ACC$L_FINALSTS,- ; Set error code
		IOSTAT
	BICL2	#STS$M_INHIB_MSG,IOSTAT	; Clear inhibit msg bit
	BRB	OUTPUT_ERR

ERR_CHK: ; We come here to check for system service and RMS errors

	CMPL	R0,#SS$_NORMAL		; System service normal return?
	BEQL	10$
	CMPL	R0,#RMS$_NORMAL		; RMS normal return?
	BEQL	10$
	MOVL	R0,IOSTAT		; Set error code
	BRB	OUTPUT_ERR
10$:	RSB

OUTPUT_ERR:	; Sigh, something went wrong - better tell everyone

	BICB2	#UETUNT$M_TESTABLE,-	; Mark unit untestable
		UETUNT$B_FLAGS(R7)
	INCL	ERROR_COUNT		; Bump the error count
	PUSHL	IOSTAT			; Push the error code...
	MOVAL	UETUNT$Q_DEVDSC(R7),R8	; Get address of unit name descriptor
	$FAO_S	CTRSTR = INIT_ERR_MSG,- ; prepare message
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = R8		; Unit name descriptor
	PUSHAL	BUFFER_PTR		; ...push error msg adr
	PUSHL	#1			; ...push arg count
	PUSHL	#UETP$_TEXT!STS$K_ERROR	; ...push signal name
	PUSHL	ERROR_COUNT		; ...and the error count...
	PUSHL	#1			; ...and the argument count...
	PUSHL	#UETP$_ERBOX!STS$K_ERROR ; ...and the signal name...
	CALLS	#7,G^LIB$SIGNAL		; ...and print the error
	BRW	ERASE		

INIT_TIMEOUT:	; We get here if subprocess doesn't complete in 30 seconds

	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	$CANCEL_S CHAN = MBX_CHAN	; This IO will never complete 
	RET
	

	.SBTTL	Timer Expiration Routine
;++
; FUNCTIONAL DESCRIPTION:
;	This routine will be called from a $SETIMR timeout.
;	This could be the normal timer to end the pass, or the
;	timer set to check for hung devices.
;
; CALLING SEQUENCE:
;	Called via AST at $SETIMR expiration.
;
; INPUT PARAMETERS:
;	REGIDT value in AST parameter.
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	Done flag set for pass termination.
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	Timeout status if device hung error.
;
; SIDE EFFECTS:
;	NONE
;
;--

TIME_OUT:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	CMPL	#REQIDT1,4(AP)		; Is this the pass timer?
	BEQL	20$			; BR if yes

; Some thing must have hung - let's try to cancel it

	PUSHL	#0			; Run down of image and indirect I/O
	PUSHAL	RMSRUNDWN_BUF		; Buffer to receive device & file
					;  name of improperly closed files
	CALLS	#2,G^SYS$RMSRUNDWN
	DECB	START_CNT		; No more testing for this unit
	BGTR	10$			; BR if there are still units running
	$WAKE_S				; Wake main routine
	RET

10$:	; Set timer again in case something else hangs

	$SETIMR_S-
		DAYTIM = THIRTYSEC_DELTA,- 
		EFN    = #2,-
		ASTADR = TIME_OUT,-
		REQIDT = #REQIDT2	; Hung device ID
	RET

20$:	; Set test over flag and start a watch dog timer

	BISW2	#TEST_OVERM,FLAG	; Ready to stop gracefully
	$SETIMR_S-			; Set timer after first rewind is 
		DAYTIM = THIRTYSEC_DELTA,- ; completed to check for device hung
		EFN    = #2,-
		ASTADR = TIME_OUT,-
		REQIDT = #REQIDT2	; Hung device ID
	$WAKE_S				; Wake startup routine
	RET


	.SBTTL	System Service Exception Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine is executed if a software or hardware exception occurs or
;	if a LIB$SIGNAL system service is used to output a message.
;	Information about this method of handling messages and errors can be
;	found in the VMS COMMON RUN-TIME manual and in the VMS SYSTEM SERVICE
;	manual.
;
; CALLING SEQUENCE:
;	Entered via an exception from the system
;
; INPUT PARAMETERS:
;	ERROR_COUNT   = previous cumulative error count
;	                -----------------
;	   AP ---->     !       2       !
;			!---------------!
;			! SIGNL ARY PNT !
;			!---------------!
;			! MECH  ARY PNT !
;			!---------------! ---------
;			!       4       !         ^
;			!---------------!         !
;			! ESTABLISH FP  !         !
;			!---------------!         !
;			!    DEPTH      ! Mechanism Array
;			!---------------!         !
;			!      R0       !         !
;			!---------------!         !
;			!      R1       !         v
;			!---------------! ---------
;			!       N       !         ^
;			!---------------!         !
;			! CONDITION NAME!         !
;			!---------------!         !
;			! N-3 ADDITIONAL!    Signal Array
;			! LONG WORD ARGS!         !
;			!---------------!         !
;			!      PC       !         !
;			!---------------!         !
;			!      PSL      !         v
;			!---------------! ---------
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	May branch to ERROR_EXIT
;--

SSERROR:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	$SETAST_S ENBFLG = #0		; Disable AST delivery
	CLRL	AST_MODE		; Assume it was disabled
	CMPL	R0,#SS$_WASSET		; Were AST's enabled?
	BNEQ	10$			; BR if not enabled
	MOVL	#1,AST_MODE		; Set it to be reenabled
10$:
	$SETSFM_S ENBFLG = #0		; Disable SS failure mode for PUTMSG
	CLRL	SS_FAIL_MODE		; Assume it was disabled
	CMPL	R0,#SS$_WASSET		; Was SS failure mode enabled?
	BNEQ	20$			; BR if not enabled
	MOVL	#1,SS_FAIL_MODE		; Set it to be reenabled
20$:
	MOVL	CHF$L_SIGARGLST(AP),R6	; Get the signal array pointer
	CMPZV	#STS$V_FAC_NO,#STS$S_FAC_NO,- ; Is this a message from LIB$SIGNAL?
		CHF$L_SIG_NAME(R6),#UETP_K
	BNEQ	30$			; BR if this is a system exception
	SUBL2	#2,CHF$L_SIG_ARGS(R6)	; Drop the PC and PSL
	$PUTMSG_S MSGVEC = CHF$L_SIG_ARGS(R6) ; Print the message
	BRB	35$
30$:
	CMPZV	#STS$V_FAC_NO,#STS$S_FAC_NO,- ; Is it an RMS failure?
		CHF$L_SIG_ARG1(R6),#RMS_K
	BNEQ	40$			; BR if not
35$:
	$SETSFM_S ENBFLG = SS_FAIL_MODE	; Set to previous state
	$SETAST_S ENBFLG = AST_MODE	; Set to previous state
	RET				; Yes, RMS_ERROR gets to handle them
40$:
	MOVL	CHF$L_SIG_NAME(R6),STATUS ; Save the status
	CLRL	R8			; Assume for now it's not SS failure
	CMPL	#SS$_SSFAIL,STATUS	; But is it a System Service failure?
	BNEQ	60$			; BR if not - no special case message
	$GETMSG_S MSGID = CHF$L_SIG_ARG1(R6),- ; Get SS failure code associated text
		 MSGLEN = BUFFER_PTR,-
		 BUFADR = FAO_BUF,-
		 FLAGS  = #14,-
		 OUTADR = MSG_BLOCK
	TSTB	MSG_BLOCK+1		; Get FAO arg count for SS failure code
	BEQL	50$			; Don't use $GETMSG if no $FAO args...
	PUSHAL	BUFFER_PTR		; ...else build up...
	PUSHL	#1			; ...a message describing...
	PUSHL	#UETP$_TEXT		; ...why the System Service failed
	INSV	CHF$L_SIG_ARG1(R6),-	; Give the message...
		#STS$V_SEVERITY,-	; ...the correct severity code
		#STS$S_SEVERITY,(SP)
	MOVL	#3,R8			; Count the number of args we pushed
	BRB	60$
50$:
	PUSHL	CHF$L_SIG_ARG1(R6)	; Save SS failure code
	MOVL	#1,R8			; Count the number of args we pushed
60$:
	MULL3	#4,CHF$L_SIG_ARGS(R6),R7 ; Convert longwords to bytes
	SUBL2	R7,SP			; Save the current signal array...
	MOVC3	R7,CHF$L_SIG_NAME(R6),(SP) ; ...on the stack
	ADDL3	R8,CHF$L_SIG_ARGS(R6),-(SP) ; Push the current arg count
	BRW	ERROR_EXIT


	.SBTTL	RMS Error Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles error returns from RMS calls. If an error occurs
;	before testing is started the error codes are pushed on the stack
;	and  control is transfered to ERROR_EXIT. If an error occurs during
;	unit startup an error message is output and control is returned 
;	to the startup routine. If testing is in progress when an error occurs
;	an error message is printed for the failing unit and the unit is marked
;	untestable. If additional units are still running we exit, otherwise 
;	if there are units remaining to be started then control is returned to
;	the startup routine. If the failing unit is the last or only unit 
;	running then a WAKE is queued and the pass timer is canceled.
;
; CALLING SEQUENCE:
;	Called by RMS when a file processing error is found.
;
; INPUT PARAMETERS:
;	TEST_START - Test started flag 
;	START_CNT - Count of units started
;	UNIT_CNT - Count of units to be started
;	UETUNT$M_TESTABLE - Unit testable flag in unit block
;
; IMPLICIT INPUTS:
;	The FAB or RAB associated with the RMS call.
;	
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Error message
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	Program may exit, depending on were we are when the error occurs.
;
;--

RMS_ERROR:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	MOVL	4(AP),R6		; See whether we're dealing with...
	CMPB	#FAB$C_BID,FAB$B_BID(R6) ; ...a FAB or a RAB
	BNEQ	10$			; BR if it's a RAB
	MOVL	R6,R8			; ...address of FAB...
	PUSHL	FAB$L_STV(R6)		; ...STV field for error...
	PUSHL	FAB$L_STS(R6)		; ...STS field for error...
	MOVL	FAB$L_STS(R6),STATUS	; ...and save the error code
	BRB	COMMON			; FAB and RAB share other code
10$:
	MOVL	RAB$L_FAB(R6),R8	; ...address of associated FAB...
	PUSHL	RAB$L_STV(R6)		; ...STV field for error...
	PUSHL	RAB$L_STS(R6)		; ...STS field for error...
	MOVL	RAB$L_STS(R6),STATUS	; ...and save the error code
COMMON:
	MOVZBL	FAB$B_FNS(R8),R10	; Get the file name size
	$FAO_S	CTRSTR = RMS_ERR_MSG,- ; Common code, prepare error message.
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = R10,-
		P2     = FAB$L_FNA(R8)
	PUSHAL	BUFFER_PTR		; ...and arguments for ERROR_EXIT...
	PUSHL	#1			; ...
	PUSHL	#UETP$_TEXT		; ...
	EXTZV	#STS$V_SEVERITY,-
		#STS$S_SEVERITY,-
		STATUS,R9 		; ...get the severity code...
	BISB2	R9,(SP)			; ...and add it into the signal name
	BBS	#TEST_STARTV,FLAG,10$	; BR if testing in progress
	PUSHL	#5			; Current arg count
	BRW	ERROR_EXIT		; Time to bail-out
10$:
	INCL	ERROR_COUNT		; Update running error count
	PUSHL	ERROR_COUNT
	PUSHL	#1
	PUSHL	#UETP$_ERBOX		; Set the message code
	BISB2	R9,(SP)			; ...and the severity code
	CALLS	#8,G^LIB$SIGNAL		; Report error
	MOVL	RAB$L_CTX(R6),R7	; Get unit block address
	MOVAL	UETUNT$Q_DEVDSC(R7),R10	; Get address of unit name descriptor
	$FAO_S	CTRSTR = DROP_UNIT_MSG,- ; prepare message
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1 = R10		; Unit name descriptor
	PUSHAL	BUFFER_PTR		; Dropped unit message
	PUSHL	#1			; Arg count
	PUSHL	#UETP$_TEXT!STS$K_ERROR	; Msg code and severity
	CALLS	#3,G^LIB$SIGNAL		; Report message
	BICB2	#UETUNT$M_TESTABLE,-	; Mark unit untestable
		UETUNT$B_FLAGS(R7)
	DECB	START_CNT		; No more testing for this unit
	BGTR	20$			; BR if there are still units running
	TSTB	UNIT_CNT		; Are there units not yet started?
	BGTR	20$			; BR if there are
	$WAKE_S				; Wake up the start routine so testing
					; will end (no more units)
	$CANTIM_S			; Cancel pass timer - we are all done
20$:	RET



	.SBTTL	CTRL/C Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles CTRL/C AST's. It calls RMSRUNDWN to make sure
;	there are no open files left around or any hung RMS I/O's pending.
;
; CALLING SEQUENCE:
;	Called via AST
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

CCASTHAND:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

; Output the abort message

	PUSHAL	CNTRLCMSG		; Set message pointer
	PUSHL	#1			; Set arg count
	PUSHL	#UETP$_TEXT!STS$K_WARNING ; Set signal name
	PUSHL	#0			; Indicate an abnormal termination
	PUSHAL	PROCESS_NAME		; ...
	PUSHL	#2			; ...
	PUSHL	#UETP$_ABENDD!STS$K_WARNING ; ...
	CALLS	#7,G^LIB$SIGNAL		; Output the message
	MOVL	#<SS$_CONTROLC-STS$K_SUCCESS+STS$K_WARNING>,-
		STATUS			; Set the exit status
	$EXIT_S	STATUS			; Terminate program cleanly


	.SBTTL	Error Exit
;++
; FUNCTIONAL DESCRIPTION:
;	This routine prints an error message and exits.
;
; CALLING SEQUENCE:
;	MOVx  error status value,STATUS
;	PUSHx error specific information on the stack
;	PUSHL current argument count
;	BRW   ERROR_EXIT
;
; INPUT PARAMETERS:
;	Arguments to LIB$SIGNAL, as above
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	Message to SYS$OUTPUT and SYS$ERROR
;
; IMPLICIT OUTPUTS:
;	Program exit
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

ERROR_EXIT:

	$SETAST_S ENBFLG = #0		; ASTs can play havoc with messages
	BBS	#BEGIN_MSGV,FLAG,10$	; BR if "begin" msg has already been output
	CLRL	-(SP)			; Set the time stamp flag
	PUSHAL	PROCESS_NAME		; Set the test name
	PUSHL	#2			; Push the argument count
	PUSHL	#UETP$_BEGIND!STS$K_SUCCESS ; Set the message code
	CALLS	#4,G^LIB$SIGNAL		; Print the startup message
10$:
	ADDL3	(SP)+,#7,ARG_COUNT	; Get total # args, pop partial count
	INCL	ERROR_COUNT		; Keep running error count
	PUSHL	#0			; Push the time parameter
	PUSHAL	PROCESS_NAME		; Push test name...
	PUSHL	#2			; ...arg count...
	PUSHL	#UETP$_ABENDD!STS$K_ERROR ; ...and signal name
	PUSHL	ERROR_COUNT		; Finish off arg list...
	PUSHL	#1			; ...
	PUSHL	#UETP$_ERBOX!STS$K_ERROR ; ...for error box message
	CALLS	ARG_COUNT,G^LIB$SIGNAL	; Truly bitch
	BISL	#STS$M_INHIB_MSG,STATUS	; Don't print messages twice!
	$EXIT_S STATUS			; Exit in error


	.SBTTL	Exit Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles cleanup at exit.  If the MODE logical name is
;	equated to "ONE", this routine will update the test flag in the
;	UETINIDEV.DAT file depending on the UETUNT$M_TESTABLE flag state in the
;	UETUNT$B_FLAGS field of the unit block for each unit for the device
;	under test. All mounted units will be dismounted and all modified
;	tapes will be initialized.
;
; CALLING SEQUENCE:
;	Invoked automatically by $EXIT System Service.
;
; INPUT PARAMETERS:
;	STATUS  contains the exit status.
;	FLAG    has synchronizing bits.
;	DDB_RFA contains the RFA of the DDB record for this device in UETINIDEV.
;
; IMPLICIT INPUTS:
;	UNIT_LIST points to the head of a doubly linked circular list of unit
;		  blocks for the device under test.
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Various files are de-accessed, the process name is reset, and any
;	necessary synchronization with UETPDEV01 is carried out.
;	If the MODE logical name is equated to "ONE", the routine will update
;	the test flag in the UETINIDEV.DAT file depending on the 
;	UETUNT$M_TESTABLE flag state in the UETUNT$B_FLAGS field of the unit
;	block for each unit for the device under test.
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

EXIT_HANDLER:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	$SETAST_S ENBFLG = #0		; Disable AST delivery
	$SETSFM_S ENBFLG = #0		; Turn off System Service failure mode
	BBS	#ONESHOT_MODEV,FLAG,5$	; Skip RMS run down if oneshot mode

; Here we cancel any RMS I/O so the channels will be deassigned

	PUSHL	#0			; Run down of image and indirect I/O
	PUSHAL	RMSRUNDWN_BUF		; Buffer to receive device & file
					;  name of any improperly closed files
	CALLS	#2,G^SYS$RMSRUNDWN
5$:
	CALLS	#0,DISMOUNT_TAPE	; Let's go dismount the tape(s)
	PUSHL	#0
	CALLS	#1,INIT_TAPE		; Let's go init the tape(s) we modified
	BBC	#ONESHOT_MODEV,FLAG,10$	; BR if not oneshot mode
	BBS	#SAFE_TO_UPDV,FLAG,20$	; Is it ok to update?
10$:	BRW	END_UPDATE		; No updating to be done

20$:	; See if we can find our place in uetinidev.dat

	MOVAL	INI_RAB,R10		; Set the RAB address
	MOVB	#RAB$C_RFA,RAB$B_RAC(R10) ; Set RFA mode
	MOVC3	#6,DDB_RFA,RAB$W_RFA(R10) ; Set RFA to DDB line
	$GET	RAB = (R10)		; Go back to the DDB record
	BLBS	R0,30$			; BR  if successful
	BRW	END_UPDATE		; If failure then forget it

30$:	; Let's  find out if we have any testable units

	MOVB	#RAB$C_SEQ,RAB$B_RAC(R10) ; Set back to sequential mode
	ADDL3	#UNIT_LIST,UNIT_LIST,R11 ; Set the unit block list header
	CLRL	R8			; Clear logical name flag
	CLRL	R9			; Init an index

UNIT_LOOP:	; Return here until all units are checked

	BBC	#UETUNT$V_TESTABLE,-	; BR if unit is not testable
		UETUNT$B_FLAGS(R11),10$
	INCL	R9			; Another unit that's testable
	TSTL	R8			; Have we created logical name for RMS?
	BNEQ	10$			; BR if we have

; If we have a testable unit tell the other tests about it

	$CRELOG_S #1,LOGNAM_DESC,-	; Create logical device name for
		UETUNT$Q_DEVDSC(R11)	; RMS test.
	INCL	R8			; Set flag

10$:	; Do next unit - if there is more

	ADDL2	(R11),R11		; Next unit block
	CMPL	R11,#UNIT_LIST		; Are we full circle in the list?
	BNEQ	UNIT_LOOP		; BR if not
	TSTL	R9			; Any testable units?
	BNEQ	20$			; BR if yes...

; If no testable units mark the controller as untestable in uetinidev.dat

	MOVB	#^A/N/,BUFFER+4		; ...else disable the DDB record...
	$UPDATE RAB = (R10)		; ...here
	BLBC	R0,END_UPDATE		; If error then forget it

20$:	; We have testable unit(s) - update uetinidev.dat to reflect what we
	; found

	ADDL2	(R11),R11		; Next unit block
	CMPL	R11,#UNIT_LIST		; Are we full circle in the list?
	BEQL	END_UPDATE		; BR if yes
	$GET	RAB = (R10)		; Get a record
	BLBC	R0,END_UPDATE		; If error then forget it
	BICB2	#LC_BITM,BUFFER		; Convert to uppercase
	CMPB	#^A/U/,BUFFER		; Is it a UCB record?
	BNEQ	END_UPDATE		; BR if not
	BBS	#UETUNT$V_TESTABLE,-	; BR if unit is testable
		UETUNT$B_FLAGS(R11),20$
	MOVB	#^A/N/,BUFFER+4		; ...else disable the UCB record...
	$UPDATE RAB = (R10)		; ...here
	BLBC	R0,END_UPDATE		; If error then forget it
	BRB	20$			; Look at the next record

END_UPDATE:

; Output the ending message

	PUSHL	#0			; Set the time flag
	PUSHAL	PROCESS_NAME		; Push the test name
	PUSHL	#2			; Push arg count
	PUSHL	#UETP$_ENDEDD		; Push signal name
	EXTZV	#STS$V_SEVERITY,-	; Get the exit severity from STATUS
		#STS$S_SEVERITY,-
		STATUS,R0
	INSV	R0,#STS$V_SEVERITY,-	; Add the severity to the exit code
		#STS$S_SEVERITY,(SP)
	CALLS	#4,G^LIB$SIGNAL		; Output the message

; Finish last minute clean up

	$DASSGN_S   CHAN = SUP_FAB+FAB$L_STV ; Deassign the channel
	$DISCONNECT  RAB = INI_RAB	; Disconnect the RAB from the FAB
	$CLOSE	     FAB = INI_FAB	; Close the file
	$SETPRN_S PRCNAM = ACNT_NAME	; Reset the process name
	RET				; That's all folks!

	.END	UETTAPE00
