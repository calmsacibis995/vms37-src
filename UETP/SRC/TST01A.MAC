	.TITLE	TST01A
	.IDENT	/V03000/
	.PSECT	TST01A
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; VERSION  X01
;
; WRITTEN BY CLARK A. D'ELIA, OCTOBER 1972
; MODIFIED BY TOM MILLER FOR RSX-11M, SEPTEMBER, 1974
; MODIFIED BY JO ANN KASSON, JUNE 1976 (ADDED TESTS FOR QIOW)
; MODIFIED BY LARRY JONES, MAY 1978 (VAX/VMS SUPPORT)
;
;+
;
; MODULE 'TST01A' IS DESIGNED TO TEST THE RSX11-M SYSTEM DIRECTIVE
; "QUEUE I/O".  ONLY THE I/O FUNCTIONS 'READ LOGICAL RECORD' AND
; 'WRITE LOGICAL RECORD' ARE SUPPORTED AT THIS TIME.  ALSO USED IN
; THIS PROGRAM ARE THE SYSTEM DIRECTIVES "WAITFOR SINGLE EVENT FLAG"
; AND "TASK EXIT".  HOWEVER, TESTING WILL ONLY BE PERFORMED ON THE
; "QUEUE I/O" DIRECTIVE.
;
;-
 
	.MCALL	CALL,RETURN,QIO$,WTSE$,WTSE$S,EXIT$S,QIO$C,GSSW$S
	.MCALL	MRKT$S,RQST$,CLEF$S,SDAT$,RCVD$,SETF$S,DECL$S,WSIG$S
	.MCALL	QIOW$,MRKT$,CMKT$S,CLEF$
 

;
; LOCAL MACRO DEFINITIONS
;

;
; MACRO TO CHECK FOR INPUT DATA ERRORS
;
	.MACRO	$DATCK	ADR,DAT,NUM,?L1,?L2
	.IF GT	NUM-1
	MOV	#ADR,R2   	;PUT ADDR OF DATA IN R2
	MOV	#NUM,R3		;PUT NUMBER OF BYTES IN R3
L2:	CMPB	#DAT,(R2)+	;COMPARE EXPECTED WITH RETURNED DATA
	.IFF
	CMPB	#DAT,ADR	;COMPARE EXPECTED WITH RETURNED DATA
	.IFTF
	BEQ	L1		;O.K. IF THEY MATCH
	MOV	#1.,R5		;ELSE, PUT "DATA ERROR" CODE IN R5
	CLR	R1		;THE HIGH BYTE OF R1 MUST BE CLEAR
	.IFT
	BISB	-1(R2),R1	;INSERT THE RETURNED DATA BYTE
	.IFF
	BISB	ADR,R1		;INSERT THE RETURNED DATA BYTE
	.IFTF
	CLR	R0		;HIGH BYTE OF R0 MUST BE CLEAR, TOO
	BISB	#DAT,R0		;INSERT THE EXPECTED DATA BYTE
	CALL	IOERR		;AND REPORT THE I/O ERROR
	.IFF
L1:
	.IFT
L1:	SOB	R3,L2		;DECR CNTR & REPEAT UNTIL ZERO
	.ENDC
	.ENDM	$DATCK


;
; MACRO TO CHECK FOR DATA SPILL OVER IN BUFFER
;
	.MACRO	$SPLCK	ADR,?L
	TSTB	ADR     	;TEST THE BYTE IN INPUT BUFFER
	BEQ	L		;O.K. IF IT IS ZERO
	MOV	#2.,R5		;ELSE, PUT "DATA SPILL" CODE IN R5
	CALL	IOERR		;AND REPORT THE I/O ERROR
L:
	.ENDM	$SPLCK


;
; MACRO TO CHECK FOR CORRECT I/O RETURN STATUS
;
	.MACRO	$RSTCK	STAT,?L
	CMPB	#STAT,IOSTAT	;COMPARE EXPECTED WITH RETURNED STATUS
	BEQ	L		;O.K. IF THEY MATCH
	MOV	#3.,R5		;ELSE PUT "INCORRECT STATUS" CODE IN R5
	MOVB	IOSTAT,R1	;PUT THE RETURNED STATUS IN R1
	MOVB	#STAT,R0   	;PUT EXPECTED STATUS IN R0
	CALL	IOERR		;AND REPORT THE I/O ERROR
L:
	.ENDM	$RSTCK


;
; MACRO TO CHECK FOR CORRECT RETURN BYTE COUNT
;
	.MACRO	$CNTCK	CNT,?L
	CMP	#CNT,IOSTAT+2	;COMPARE EXPECTED WITH RETURNED COUNT
	BEQ	L		;O.K. IF THEY MATCH
	MOV	#4.,R5		;ELSE PUT "INCORRECT COUNT" CODE IN R5
	MOV	#CNT,R0		;PUT EXPECTED COUNT IN R0
	MOV	IOSTAT+2,R1	;PUT RETURNED COUNT IN R1
	CALL	IOERR		;AND REPORT THE I/O ERROR
L:
	.ENDM	$CNTCK


;
; LOCAL DATA
;
 
CL=	3
CR=	15
ESC=	33
IOSTAT:	.BLKW	2		;I/O STATUS BLOCK
 
;
; THE FOLLOWING TABLE CONTAINS THE I/O ERROR SERVICE ROUTINE ADDRESSES.
;
SVCTBL:	.WORD	CODE1		;CODE1 = DATA ERROR 
	.WORD	CODE2		;CODE2 = DATA SPILL OVER
	.WORD	CODE3		;CODE3 = STATUS ERROR
	.WORD	CODE4		;CODE4 = COUNT ERROR
RBUF:	.BLKW	2		;DUMMY RECEIVE BUFFER
SBUF:	.BLKW	13.		;DUMMY SEND BUFFER
 
IPTBUF:	.BLKW	10.		;A TEN WORD INPUT BUFFER
	.NLIST	BEX
 
LMG01:	.ASCIZ	/*** PRINT TEST ***/
 
LMG02:	.ASCIZ	/ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789/
 
LMG03:	.ASCIZ	/PLEASE TYPE A LINE OF TEN ZEROES AND A CARRIAGE RETURN:/
LMG04:	.ASCII	/%NPLEASE CHANGE THE SWITCH REGISTER WITHIN THE NEXT 30/
	.ASCII	/ SECONDS%NIF YOU WISH TO PERFORM THE TESTS REQUIRING/
	.ASCIZ	/ TELETYPE INPUT.%N/
 
LMG05:	.ASCIZ	"%NPLEASE TYPE AN ESCAPE/ALTMODE"
LMG06:	.ASCIZ	/%NPLEASE TYPE A CONTROL-Z/
LEM00:	.ASCIZ	'I/O ERROR, CODE %D.%N'
 
LEM01:	.ASCIZ	/INPUT DATA ERROR, EXP'D: %O, RCV'D: %O/
 
LEM02:	.ASCIZ	/TOO MUCH DATA STORED IN BUFFER/
 
LEM03:	.ASCIZ	/INCORRECT RETURN STATUS, EXP'D: %D., RCV'D: %D./
 
LEM04:	.ASCIZ	/INCORRECT BYTE COUNT, EXP'D: %D., RCV'D: %D./
LEM05:	.ASCII	/%NTASK WAS ALLOWED TO CONTINUE AFTER ISSUING AN ATTACH/
	.ASCIZ	/%NFOR A DEVICE ATTACHED TO ANOTHER PROCESS./
LEM06:	.ASCII	/%NTHE SECOND TASK ATTEMPTING TO ATTACH A DEVICE WAS NOT/
	.ASCIZ	/%NALLOWED TO CONTINUE AFTER A DETACH BY THE FIRST TASK./
LEM07:	.ASCIZ	/QIOW IS NOT WAITING ON SPECIFIED EFN/
LEM10:	.ASCIZ	/QIOW IS WAITING WHEN AN EFN WAS NOT SPECIED/
	.EVEN
	.LIST	BEX
	.PAGE
	.PSECT	$DPB$$
 
;
; THIS PSECT CONTAINS ONLY DPB'S.
;

CLDPB:	QIO$	IO.WVB,CL,1,,IOSTAT,,<0,0,0>


RDDPB:	QIO$	IO.RVB,TI,1,,IOSTAT,,<IPTBUF,0,0>


RWDPB:	QIOW$	IO.RVB,TI,1,,IOSTAT,,<IPTBUF,0,0>

WWDPB:	QIOW$	IO.WVB,TI,1,,IOSTAT,,<LMG02,36.,40>




TSTDPB:	QIO$	IO.WVB,TI,1,,IOSTAT,,<.OBUF,0,0>


WT1:	WTSE$	1
WT2:	WTSE$	2
RQDPB:	RQST$	TST01B
SEND:	SDAT$	TST01A,SBUF
RECV:	RCVD$	,RBUF
KILLIO:	QIOW$	IO.KILL,TI
CLREF:	CLEF$	1
MRKT:	MRKT$	,2,2,AST
	.PAGE
	.PSECT	TST01A
	.EVEN
;+
;
; INITIALLY, THE FUNCTION 'WRITE LOGICAL RECORD' TO TI WILL BE
; ISSUED.
;
;-
	$$TEST	1,A
	CALL	.STST		;PRINT 'START' MESSAGE
;+
;
; THE USER HAS THE OPTION OF SKIPPING OR USING THE STEPS THAT
; REQUEST TELETYPE INPUT.  THE DEFAULT CONDITION WILL BE TO SKIP.
; HOWEVER, THE STEPS WILL BE DONE IF THE USER CHANGES THE
; SWITCH REGISTER AT RUN TIME.  FIRST THE USER IS INFORMED OF THIS
; OPTION AND GIVEN 30 SECONDS IN WHICH TO CHANGE THE SWITCH REGISTER.
;
;-
;	GSSW$S	.RJCT		;GET CURRENT SWITCH REGISTER SETTING
;	MOV	$DSW,-(SP)	;AND SAVE IT
;	MOV	#.OBUF,R0	;SET UP POINTER TO OUTPUT BUFFER IN R0
;	MOV	#LMG04,R1	;MESSAGE POINTER TO R1
;	CALL	.PRTMG		;PRINT IT
;	MRKT$S	#2,#30.,#SECOND,,.RJCT ;MARK TIME FOR 30 SECONDS
;	DIR$	#WT2,.RJCT	;AND WAIT
;	GSSW$S	.RJCT		;READ SWITCHES
;	CMP	$DSW,(SP)+	;COMPARE PREVIOUS AND CURRENT VALUE
;	BNE	1$		;IF ZERO, DO ALL TESTS
	JMP	SKPIPT		;ELSE, SKIP THE INPUT TESTS
1$:
;+
;
; THE NEXT STEP SENDS A MESSAGE TO TI REQUESTING THAT THE USER TYPE
; A SPECIFIC LINE OF INPUT (10 ZEROES & CARRIAGE RETURN).  BEFORE
; ACTUALLY REQUESTING THE INPUT, A SUBROUTINE WILL CLEAR THE BUFFER
; INTO WHICH THE DATA WILL BE PASSED, AND IT WILL ALSO CLEAR THE
; I/O STATUS BLOCK FOR ACCURATE TESTING.  A CHECK IS ALSO MADE TO
; VERIFY THAT THE CONTENTS OF THE STATUS BUFFER IS IS.PND IMMEDIATELY
; AFTER ISSUANCE OF THE READ.
;
;-
	$$STEP
	CALL	SETIPT		;SUBROUTINE SETS UP FOR INPUT
	MOV	#72.,RDDPB+Q.IOPL+2 ;PUT BYTE COUNT IN DPB
	DIR$	#RDDPB,.RJCT	;INVOKE QIO
	$RSTCK	IS.PND		;VERIFY PENDING STATUS
	DIR$	#WT1,.RJCT	;AND WAIT
 
;
; TEST THE VALIDITY OF THE DATA RECEIVED (ASSUME ACCURATE TYPEIN)
;
 
	$DATCK	IPTBUF,'0,10.
 
;
; CHECK TO INSURE THAT THE CARRIAGE RETURN IS NOT IN THE BUFFER.
;
 
	$SPLCK	IPTBUF+10.
 
;
; EXAMINE THE RETURNED I/O STATUS
;
 
	$RSTCK	IS.SUC
 
;
; EXAMINE THE LINE TERMINATOR CHARACTER
;
 
	$DATCK	IOSTAT+1,CR,1
 
;
; CHECK THE RETURNED BYTE COUNT
;
 
	$CNTCK	10.
;+
;
; THE NEXT STEP SENDS A MESSAGE TO TI REQUESTING THAT THE USER TYPE
; A SPECIFIC LINE OF INPUT (10 ZEROES & CARRIAGE RETURN).  BEFORE
; ACTUALLY REQUESTING THE INPUT, A SUBROUTINE WILL CLEAR THE BUFFER
; INTO WHICH THE DATA WILL BE PASSED, AND IT WILL ALSO CLEAR THE
; I/O STATUS BLOCK FOR ACCURATE TESTING.
;
;-
	$$STEP
	CALL	SETIPT		;SUBROUTINE SETS UP FOR INPUT
	MOV	#72.,RWDPB+Q.IOPL+2 ;PUT BYTE COUNT IN DPB
	DIR$	#RWDPB,.RJCT	;INVOKE QIOW
	DIR$	#KILLIO,.RJCT	;ABORT READ - IT SHOULD BE DONE
				;BEFORE THIS POINT IS REACHED.
 
;
; TEST THE VALIDITY OF THE DATA RECEIVED (ASSUME ACCURATE TYPEIN)
;
 
	$DATCK	IPTBUF,'0,10.
 
;
; CHECK TO INSURE THAT THE CARRIAGE RETURN IS NOT IN THE BUFFER.
;
 
	$SPLCK	IPTBUF+10.
 
;
; EXAMINE THE RETURNED I/O STATUS
;
 
	$RSTCK	IS.SUC
 
;
; EXAMINE THE LINE TERMINATOR CHARACTER
;
 
	$DATCK	IOSTAT+1,CR,1
 
;
; CHECK THE RETURNED BYTE COUNT
;
 
	$CNTCK	10.

;+
;
; THE FOLLOWING STEP ALSO REQUESTS A TI INPUT .  HOWEVER, IT WANTS
; FEWER CHARACTERS IN THE BUFFER THAN WILL ACTUALLY BE TYPED IN.
; THE SAME SETUP ROUTINE IS USED TO PREPARE FOR THE INPUT.
;
;-
	$$STEP
	CALL	SETIPT		;SUBROUTINE SETS UP FOR INPUT
	MOVB	#377,IOSTAT+1	;RETURNED TERMINATOR SHOULD BE '000'
	MOV	#5,RDDPB+Q.IOPL+2 ;PUT BYTE COUNT IN DPB
	DIR$	#RDDPB,.RJCT	;INVOKE QIO
	DIR$	#WT1,.RJCT	;AND WAIT
 
;
; CHECK DATA VALIDITY
;
 
	$DATCK	IPTBUF,'0,5.
 
;
; NOW ALSO CHECK FOR DATA SPILL OVER (TOO MUCH DATA)
;
 
	$SPLCK	IPTBUF+5.
 
;
; EXAMINE RETURNED I/O STATUS
;
 
	$RSTCK	IS.SUC
 
;
; EXAMINE THE LINE TERMINATOR CHARACTER
;
 
	$DATCK	IOSTAT+1,0,1
 
;
; LASTLY, LOOK AT THE RETURNED BYTE COUNT
;
 
	$CNTCK	5.
;+
;
; THERE SHOULD STILL BE FIVE CHARACTERS (AND A CARRIAGE RETURN) IN THE READ
; AHEAD BUFFER.  TO GET THEM, ANOTHER READ IS ISSUED.
;
;-
	$$STEP
	CLR	IOSTAT		;CLEAR BOTH WORDS OF
	CLR	IOSTAT+2	;THE I/O STATUS BLOCK
	CLR	IPTBUF		;CLEAR FIRST THREE
	CLR	IPTBUF+2	;WORDS OF THE
	CLR	IPTBUF+4	;INPUT BUFFER
	MOV	#65.,RDDPB+Q.IOPL+2 ;PUT BYTE COUNT IN DPB
	DIR$	#RDDPB,.RJCT	;INVOKE QIO
	DIR$	#WT1,.RJCT	;AND WAIT
 
;
; EXAMINE THE DATA PLACED IN THE BUFFER
;
 
	$DATCK	IPTBUF,'0,5
 
;
; CHECK THE RETURNED I/O STATUS
;
 
	$RSTCK	IS.SUC
 
;
; LOOK AT THE LINE TERMINATOR CHARACTER
;
 
	$DATCK	IOSTAT+1,CR,1
 
;
; LASTLY, EXAMINE THE BYTE COUNT
;
  
	$CNTCK	5
 
;+
;
; IN THIS STEP THE USER WILL BE ASKED TO TYPE 10 ZEROES FOLLOWED BY
; ESCAPE/ALTMODE TO VERIFY THAT A CODE OF IS.ESC IS RETURNED
;
;-
	$$STEP
	MOV	#.OBUF,R0	;SET UP POINTER TO OUTPUT BUFFER
	MOV	#LMG05,R1	;SET UP POINTER TO MESSAGE
	CALL	.PRTMG		;PRINT MESSAGE TO USER
	MOV	#72.,RDDPB+Q.IOPL+2 ;SET CHARACTER COUNT TO 10
	MOV	#IO.RLB,RDDPB+Q.IOFN ;SET READ LOGICAL BLOCK FUNCTION
	DIR$	#RDDPB,.RJCT	;ISSUE READ
	DIR$	#WT1,.RJCT	;WAIT
	$RSTCK	IS.SUC		;CHECK FOR SUCCESSFUL RETURN CODE
	$DATCK	IOSTAT+1,ESC	;CHECK FOR IS.ESC (ESC IN UPPER BYTE OF STATUS)
;+
;
; IN THIS STEP THE USER WILL BE ASKED TO TYPE AN END OF FILE (CONTROL-Z)
; AND IE.EOF SHOULD BE RETURNED IN THE STATUS BUFFER.
;
;-
	$$STEP
	MOV	#.OBUF,R0	;SET UP POINTER TO OUTPUT BUFFER
	MOV	#LMG06,R1	;SET UP POINTER TO MESSAGE TO USER
	CALL	.PRTMG		;PRINT MESSAGE
	DIR$	#RDDPB,.RJCT	;ISSUE READ
	DIR$	#WT1,.RJCT	;AND WAIT
	$RSTCK	IE.EOF		;CHECK FOR VALID RETURNED STATUS
SKPIPT:		;JUMP TO HERE TO SKIP INPUT TESTS
 
;+
;
; THIS NEXT STEP SENDS A SHORT MESSAGE TO CL.  IT THEN CHECKS THE I/O
; STATUS BLOCK TO INSURE THAT THE FUNCTION PERFORMED CORRECTLY.
;
;-
	$$STEP
	CLRB	IOSTAT		;CLEAR I/O STATUS BYTE
	MOV	#CLDPB,R3	;PUT DPB ADDR IN R3
	MOVB	#1,Q.IOEF(R3)	;SPECIFY EVENT FLAG 1 IN DPB
	ADD	#Q.IOPL,R3	;MAKE R3 POINT TO DPB PARAMETER LIST
	MOV	#LMG01,(R3)+	;PUT BUFFER ADDR IN DPB
	MOV	#18.,(R3)+	;PUT BYTE COUNT IN DPB
	MOV	#'1,(R3)	;PUT CARRIAGE CONTROL IN DPB
	DIR$	#CLDPB,.RJCT	;INVOKE QIO
	DIR$	#WT1,.RJCT	;AND WAIT
;
; CHECK THE RETURNED I/O STATUS
;

	$RSTCK	IS.SUC

 
;
; TEST THE WAIT FUNCTION OF THE QIOW DIRECTIVE
; BY ISSUING A WRITE USING THE QIOW, 
; KILLING THE IO AND THEN TESTING
; THE STATE OF THE EVENT FLAG.
;
	$$STEP
	DIR$	#CLREF,.RJCT	;CLEAR EVENT FLAG #1
	CLRB	IOSTAT		;CLEAR STATUS BYTE
	DIR$	#WWDPB,.RJCT	;INVOKE QIOW
	DIR$	#KILLIO,.RJCT	;INVOKE QIOW TO KILL IO
;
; CHECK RETURNED STATUS
;
	$RSTCK	IS.SUC
	DIR$	#CLREF,.RJCT	;CLEAR EVENT FLAG TO GET STATUS
	CMP	#IS.SET,$DSW	;WAS EVENT FLAG #1 SET?
	BEQ	10$		;IF EQ YES
	CALL	.IDOUT	;OTHERWISE OUTPUT ERROR MESSAGE
	MOV	#LEM07,R1
	CALL	.PRTMG
10$:
;
; TEST THAT THE WAIT IN A QIOW DOES NOT
; OCCUR WHEN AN EVENT FLAG IS NOT SPECIFIED
;
	$$STEP
;*****
	JMP	STP12
;*****
	CLR	WWDPB+Q.IOEF	;ZERO EVENT FLAG
	DIR$	#MRKT,.RJCT	;ISSUE A MARK TIME OF 2 SECONDS
	DIR$	#WWDPB,.RJCT	;INVOKE QIOW WITHOUT EFN SPECIFIED
	CMKT$S	,,.RJCT	;CANCEL MARK
	DIR$	#KILLIO,.RJCT	;KILL IO
	MOV	#2,MRKT+M.KTEF	;INSERT EFN INTO MRKT DPB
	 CLR	MRKT+M.KTAE	;ZERO AST ADDRESS
	DIR$	#MRKT,.RJCT	;MARK TIME WITH EVENT FLAG
	DIR$	#WT2,.RJCT	;WAIT ON EVENT FLAG
	$RSTCK	IE.ABO		;CHECK THE RETURNED I/O STATUS
				;FROM THE KILL
	BR	NXTSTP		;CONTINUE WITH NEXT STEP
;
; AST ROUTINE - GET HERE FROM THE MARK TIME IF QIOW WAITS WHEN
; AN EVENT FLAG WAS NOT SPECIFIED
;
AST:
	CALL	.IDOUT		;OUTPUT ERROR MESSAGE
	MOV	#LEM10,R1
	CALL	.PRTMG
NXTSTP:
;+
;
; THE NEXT STEP WILL SEND A BURST OF 5 LINES TO CL.  NO CHECKING OF I/O
; STATUS WILL BE PERFORMED.
;
;-
	$$STEP
	MOV	#4.,R1		;PRINT FIRST 4 LINES WITH NO EVENT FLAG SETTING
	CLRB	CLDPB+Q.IOEF	;CLEAR EVENT FLAG IN DPB
	MOV	#LMG02,-4(R3)	;SPECIFY NEW BUFFER ADDR IN DPB
	MOV	#36.,-2(R3)	;SPECIFY NEW BYTE COUNT IN DPB
1$:
	MOV	#'$,(R3)	;PUT CARRIAGE CONTROL IN DPB
	DIR$	#CLDPB		;INVOKE QIO
	BCC	20$		;CONTINUE IF NO ERROR
	CALL	UPNCHK		;IF OUT OF DYN MEMORY, WAIT FOR SIG EVENT
	BCC	1$		;RETRY IF ERROR WAS LACK OF DYN MEMORY
20$:
	TST	R1		;TEST THE COUNTER
	BNE	2$		;SKIP IF NOT ZERO
	MOVB	#1,CLDPB+Q.IOEF	;IF ZERO, SPECIFY EVENT FLAG IN DPB
2$:	MOV	#'+,(R3)	;PUT NEW CARRIAGE CONTROL IN DPB
	DIR$	#CLDPB		;INVOKE QIO
	BCC	30$		;CONTINUE IF NO ERROR
	CALL	UPNCHK		;IF OUT OF DYN MEMORY WAIT FOR SIG EVENT
	BCC	2$		;RETRY IF ERROR WAS LACK OF DYN MEMORY
30$:
	DEC	R1		;DECREMENT THE COUNTER
	BGE	1$		;LOOP UNTIL IT'S NEGATIVE
	DIR$	#WT1,.RJCT	;THEN WAIT FOR LAST I/O DONE
	BR	NEXT		;SKIP AROUND ROUTINE
UPNCHK:	CMP	#IE.UPN,$DSW	;OUT OF DYNAMIC MEMORY?
	BNE	40$		;REPORT ERROR IF OTHER
	WSIG$S	.RJCT		;OTHERWISE WAIT FOR FREE DYN MEMORY
	BR	50$		;AND RETURN WITH CARRY CLEAR
40$:	CALL	.RJCT		;REPORT UNEXPECTED ERROR, RETURN CARRY SET
50$:	RETURN
NEXT:
;+
;
; THE FOLLOWING GROUP OF TESTS ARE ALL TRYING TO SCREW UP THE I/O HANDLERS.
;
; THE FIRST WILL REQUEST OUTPUT OF A LINE TO TI WITH A LENGTH OF ZERO.
;
;-
	MOV	#TSTDPB,R3	;INITIALIZE TEST DPB POINTER
	CALL	$ADCHK		;IS SYSTEM PERFORMING ADDRESS CHECKING?
	BCC	3$		;CONTINUE IF IT IS
	JMP	NADCK1		;OTHERWISE SKIP TESTS REQUIRING CHECKING
3$:
	$$STEP
;	CLR	IOSTAT		;CLEAR FIRST WORD OF I/O STATUS BLOCK
;	MOV	#TI,Q.IOLU(R3)	;SPECIFY TI IN DPB
;	CLR	Q.IOPL+2(R3)	;BYTE COUNT OF ZERO
;	DIR$	R3,.RJCT	;INVOKE QIO
 
;
; EXAMINE THE RETURNED I/O STATUS
;
 
;	$RSTCK	IE.SPC
;+
;
; THE "QUEUE I/O" DIRECTIVE IS INVOKED WITH AN OUTPUT REQUEST OF LENGTH
; MINUS ONE TO TI.
;
;-
	$$STEP
;*****
	JMP	STP15
;*****
	CLR	IOSTAT		;CLEAR FIRST WORD OF I/O STATUS BLOCK
	DEC	Q.IOPL+2(R3)	;MAKE BYTE COUNT NEGATIVE
	DIR$	R3,.RJCT	;INVOKE QIO
 
;
; CHECK THE RETURNED I/O STATUS
;
 
	$RSTCK	IE.SPC
;+
;
; THIS STEP WILL REQUEST A LINE OF INPUT FROM TI OF LENGTH ZERO.
;
;-
	$$STEP
;	CLR	IPTBUF		;CLEAR FIRST WORD OF 'IPTBUF'
;	MOV	#177777,IOSTAT	;SET IOSTAT TO ALL ONES
;	MOV	SP,IOSTAT+2	;MAKE BYTE COUNT NON-ZERO
;	CLR	RDDPB+Q.IOPL+2	;CLEAR BYTE COUNT
;	DIR$	#RDDPB,.RJCT	;INVOKE QIO
 
;
; CHECK THE RETURNED I/O STATUS
;
 
;	$RSTCK	IE.SPC
 
;
; CHECK THE RETURNED BYTE COUNT
;
 
;	$CNTCK	0
;+
;
; THIS STEP IS SIMILAR BUT THE LENGTH OF ITS INPUT REQUEST WILL BE
; NEGATIVE ONE.
;
;-
	$$STEP
;*****
	JMP	STP20
;*****
	CLR	IOSTAT		;CLEAR FIRST WORD OF I/O STATUS BLOCK
	MOV	SP,IOSTAT+2	;MAKE BYTE COUNT G.T. ZERO & EVEN
	DEC	RDDPB+Q.IOPL+2	;MAKE BYTE COUNT NEGATIVE
	DIR$	#RDDPB,.RJCT	;INVOKE QIO
	DIR$	#WT1,.RJCT	;AND WAIT
 
;
; CHECK THE RETURNED I/O STATUS
;
 
	$RSTCK	IE.SPC
 
;
; FINALLY, CHECK THE RETURNED BYTE COUNT
;
 
	$CNTCK	0.
;+
;
; NOW ATTEMPT TO REQUEST OUTPUT TO TI FROM A BUFFER OUTSIDE OF THIS TASK'S
; SEGMENT.
;
;-
	$$STEP
	CLR	IOSTAT		;CLEAR FIRST WORD OF I/O STATUS BLK
	MOV	#TI,Q.IOLU(R3)	;SPECIFY TI IN DPB
	MOV	#1,Q.IOPL+2(R3)	;SPECIFY BYTE COUNT OF ONE
	MOV	#160000,Q.IOPL(R3) ;SPECIFY AN INVALID I/O BUFFER ADDR
	DIR$	R3,.RJCT	;INVOKE QIO
	DIR$	#WT1,.RJCT	;AND WAIT
	MOV	#IPTBUF,Q.IOPL(R3) ;RESTORE NORMAL BUFFER ADDR
 
;
; THE I/O STATUS SHOULD INDICATE THE FAILURE.
;
 
	$RSTCK	IE.SPC
;+
;
; THIS STEP WILL ISSUE A QIO WITH AN INVALID FUNCTION CODE TO TI.
;
;-
NADCK1:
	$$STEP
	CLR	IOSTAT		;CLEAR THE I/O STATUS WORD
	MOV	#12*400,Q.IOFN(R3) ;INVALID FUNCTION CODE 
				;FIRST UNUSED GENERAL FUNCTION CODE
	DIR$	R3,.RJCT	;INVOKE QIO
	DIR$	#WT1,.RJCT	;AND WAIT
	MOV	#IO.RLB,Q.IOFN(R3) ;RESTORE FUNCTION CODE TO READ LOGICAL
 
;
; NOW CHECK THAT I/O STATUS
;
 
	$RSTCK	IE.IFC
;+
;
; NOW IT'S TIME TO TEST THE "QUEUE I/O" DIRECTIVE AGAIN (RATHER THAN THE
; I/O HANDLERS). THIS STARTS A SERIES OF STEPS THAT ARE DESIGNED TO
; PURPOSELY FAIL.
;
; TRY QUEUING TO AN INVALID LOGICAL UNIT NUMBER
;
;-
	$$STEP
	MOV	#-1,Q.IOLU(R3)	;SPECIFY NEGATIVE LUN
	DIR$	R3		;INVOKE QIO
	MOV	#TI,Q.IOLU(R3)	;RESTORE LUN TO TI
	MOV	#IE.ILU,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CALL STATUS CHECKING ROUTINE
;+
;
; TRY TO SPECIFY AN INVALID EVENT FLAG NUMBER
;
;-
	$$STEP
	MOVB	#-1,Q.IOEF(R3)	;SPECIFY NEGATIVE EVENT FLAG
	DIR$	R3		;INVOKE QIO
	MOVB	#1,Q.IOEF(R3)	;RESTORE EVENT FLAG TO ONE
	MOV	#IE.IEF,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CALL STATUS CHECKING ROUTINE
;+
;
; TRY QUEUING TO AN UNASSIGNED LOGICAL UNIT NUMBER
;
;-
	$$STEP
	MOV	#8.,Q.IOLU(R3) ;SPECIFY UNASSIGNED LUN
	DIR$	R3		;INVOKE QIO
	MOV	#TI,Q.IOLU(R3) ;RESTORE LUN TO TI
	MOV	#IE.ULN,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CALL STATUS CHECKING ROUTINE
;+
;
; ISSUE A "QUEUE I/O" WITH A ONE WORD DPB.  THAT IS AN ILLEGAL
; DPB SIZE.
;
;-
	$$STEP
	MOV	(PC)+,-(SP)	;PUT THE DPB IN THE STACK
	.BYTE	1.,1.		;"QUEUE I/O" DIC & INVALID DPB SIZE
	DIR$			;TRAP TO THE MONITOR
	MOV	#IE.SDP,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK THE RETURNED DIRECTIVE STATUS
;+
;
; THE "QUEUE I/O" DIRECTIVE IS ISSUED SPECIFYING AN I/O STATUS BLOCK
; ADDRESS OUT OF THIS SEGMENT.
;
;-
	CALL	$ADCHK		;IS SYSTEM PERFORMING ADDRESS CHECKING?
	BCS	NADCK2		;IF NOT, SKIP TESTS REQUIRING CHECKING
	$$STEP
	MOV	#160000,Q.IOSB(R3) ;SPECIFY I/O STAT BLK ADR OUT OF SEG
	DIR$	R3		;INVOKE QIO
	MOV	#IOSTAT+1,Q.IOSB(R3) ;RESTORE TO NORMAL ADDR PLUS ONE
	MOV	#IE.ADP,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CALL STATUS CHECKING ROUTINE
;+
;
; THE "QUEUE I/O" DIRECTIVE IS ISSUED SPECIFYING AN I/O STATUS BLOCK
; ON AN ODD ADDRESS.
;
;-
	$$STEP
	DIR$	R3		;INVOKE QIO
	DEC	Q.IOSB(R3)	;RESTORE I/O STAT BLK ADDR
	CALL	.FAIL		;CALL STATUS CHECKING ROUTINE
;+
;
; THIS STEP WILL ISSUE A SUCCESION OF READS WITH NO WAIT IN BETWEEN FOR
; I/O DONE.  THIS STEP IS MEANT TO FORCE AN ERROR CONDITION WHEN THERE IS
; NO DYNAMIC MEMORY LEFT FOR THE TASK.  FIRST THE TASK WILL SEND A DUMMY MESSAGE
; MESSAGE TO ITSELF TO HOLD SOME DYNAMIC MEMORY TO BE RELEASED LATER
; FOR AN I/O KILL OPERATION.
;
;-
NADCK2:
	$$STEP
;	MOV	#72.,RDDPB+Q.IOPL+2 ;INITIALIZE BYTE COUNT
;	DIR$	#SEND,.RJCT	;USE SEND TO GRAB DYNAMIC MEMORY
;1$:	DIR$	#RDDPB		;INVOKE QIO
;	BCS	NODMEM		;EXIT LOOP ON ERROR
;	BR	1$		;QUEUE ANOTHER REQUEST UNTIL IT FAILS
 
;
; WHEN HERE, IT MEANS THAT THE DIRECTIVE FINALLY FAILED.
; FIRST THE DUMMY MESSAGE WILL B3 RECEIVED TO FREE DYNAMIC MEMORY.
; THEN THE ERROR CODE IS CHECKED.
;
 
;NODMEM:	MOV	$DSW,-(SP)	;SAVE ERROR CODE FOR LATER
;	DIR$	#RECV,.RJCT	;RECEIVE DUMMY MESSAGE TO FREE DYNAMIC MEM
;	MOV	(SP)+,$DSW	;RESTORE PREVIOUS DSW
;	MOV	#IE.UPN,R1	;EXPECTED ERROR CODE TO R1
;	CALL	.STAT		;CHECK ERROR CODE
;+
;
; NOW THE READS WILL BE FLUSHED BY ISSUING A QIO WITH A IO.KIL FUNCTION.
; A CHECK IS MADE THAT THE STATUS RETURNED ON THE READS IS IE.ABO.
;
;-
	$$STEP
;	MOV	#IO.KIL,RDDPB+Q.IOFN ;SET FUNCTION CODE
;	CLR	RDDPB+Q.IOSB	;NO STATUS IS TO BE RETURNED FOR THE KILL
;	CLRB	RDDPB+Q.IOEF	;NO EVENT FLAG TO BE SET
;	DIR$	#RDDPB,.RJCT	;ISSUE KILL
;	CALL	.SUCC		;CHECK FOR VALID RETURN FROM DIRECTIVE
;	DIR$	#WT1,.RJCT	;WAIT FOR KILL TO COMPLETE
;	$RSTCK	IE.ABO		;CHECK FOR ABORT STATUS ON READS
;	MOVB	#1,RDDPB+Q.IOEF	;RESTORE TO EF01
;	MOV	#IOSTAT,RDDPB+Q.IOSB ;RESTORE STATUS BUFFER POINTER
;+
;
; IN THE LAST SET OF STEPS THE ATTACH AND DETACH FUNCTIONS WILL BE TESTED
; FIRST A VALID ATTACH TO TI.
;
;-
	$$STEP
	MOV	#IO.ATT,RDDPB+Q.IOFN ;SET FOR I/O ATTACH FUNCTION
	DIR$	#RDDPB,.RJCT	;ISSUE THE ATTACH
	CALL	.SUCC		;CHECK FOR VALID RETURN CODE
	DIR$	#WT1,.RJCT	;WAIT FOR ATTACH TO COMPLETE
;+
;
; NOW AN ATTACH WILL BE ISSUED AGAIN, WHICH SHOULD CAUSE AN ERR.
;
;-
	$$STEP
;*****
	JMP	STP33
;*****
	DIR$	#RDDPB,.RJCT	;ATTACH
	DIR$	#WT1,.RJCT	;WAIT FOR ATTACH
	$RSTCK	IE.DAA		;CHECK RETURN CODE
;+
;
; NOW TST01B IS REQUESTED.  TST01B IMMEDIATELY ATTEMPTS TO SEND AN
; ERROR MESSAGE TO TI, BUT IT SHOULD PRINT SINCE TI IS ATTACHED TO THIS
; TASK.  AFTER A 10 SECOND WAIT, THIS TASK SETS EF48 (THE FLAG SPECIFIED
; IN TST01B'S QIO DIRECTIVE) ALLOWING TST01B TO CONTINUE.TST01B THEN
; KILLS THE ERROR MESSAGE.
;
;-
	$$STEP
	DIR$	#RQDPB,.RJCT	;REQUEST TST01B
	MRKT$S	#2,#10.,#SECOND,,.RJCT ;MARK TIME FOR 10 SECONDS
	DIR$	#WT2,.RJCT	;AND WAIT
	SETF$S	#48.,.RJCT	;ALLOW TST01B TO CONTINUE
	DECL$S	,.RJCT		;DECLARE SIGNIFICANT EVENT
;+
;
; NOW TST01B HAS ISSUED AN ATTACH FOR TI AND HAS ENTERED INTO A WAIT
; FOR THE ATTACH (ON EF48).  AFTER A 5 SECOND WAIT THIS TASK SHOULD
; FIND EF48 STILL CLEAR, MEANING THAT THE ATTACH IS STILL PENDING.
; IF THIS IS NOT TRUE, AN APPRORIATE ERROR IS PRINTED.
;
;-
	$$STEP
;*****
	JMP	STP37
;*****
	MRKT$S	#2,#5,#SECOND,,.RJCT ; MARK TIME FOR 5 SECONDS
	DIR$	#WT2,.RJCT	;AND WAIT
	CLEF$S	#48.,.RJCT	;USE CLEAR FLAG TO READ EF48
	CMP	$DSW,#IS.CLR	;WAS IT CLEAR?
	BEQ	1$		;OK IF IT WAS
	CALL	.IDOUT		;OTHERWISE IDENTIFY STEP
	MOV	#LEM05,R1	;PASS ERROR MESSAGE POINTER
	CALL	.PRTMG		;AND PRINT IT
1$:
;+
;
; NOW A VALID DETACH IS ISSUED, WHICH SHOULD ALLOW THE ATTACH BY TST01B
; TO COMPLETE.  WHEN THE ATTACH IS COMPLETE, THE SYSTEM SHOULD SET EF48
; (THE FLAG SPECIFIED IN THE ATTACH) ALLOWING TST01B TO CONTINUE AND
; EXIT.  AFTER A 5 SECOND WAIT, TST01A USES SET FLAG TO SEE IF EF48 WAS
; SET BY THE SYSTEM (I.E. THE ATTACH COMPLETED).  IF EF48 WAS CLEAR AN
; APPRORIATE ERROR MESSAGE IS PRINTED.  IN THIS CASE THE SET FLAG WHICH
; WAS USED INSURES THAT TST01B IS ALLOWED TO CONTINUE AND EXIT.
;
;-
	$$STEP
	MOV	#IO.DET,RDDPB+Q.IOFN ;SET DETACH FUNCTION IN DPB
	DIR$	#RDDPB,.RJCT	;ISSUE DETACH
	CALL	.SUCC		;CHECK FOR VALID RETURN CODE
	DIR$	#WT1,.RJCT	;WAIT FOR DETACH
	MRKT$S	#2,#5,#SECOND,,.RJCT ;NOW WAIT FOR 5 SECONDS TO ALLOW
				     ;TST01B TO SET EF48
	DIR$	#WT2,.RJCT
	CMP	$DSW,#IS.SET	;WAS IT SET?
	BEQ	2$		;OK IF IT WAS
	CALL	.IDOUT		;OTHERWISE IDENTIFY STEP
	MOV	#LEM06,R1	;PASS POINTER TO ERROR MESSAGE
	CALL	.PRTMG		;PRINT IT
2$:
;+
;
; NOW AN ATTACH WILL BE ISSUED WHEN THE DEVICE IS ALREADY DETACHED
;
;-
	$$STEP
	DIR$	#RDDPB,.RJCT	;DETACH
	DIR$	#WT1,.RJCT	;WAIT FOR DETACH
	$RSTCK	IE.DNA		;CHECK ERROR CODE RETURNED
;
; THIS IS THE END OF 'TEST01' .  HERE WE PRINT OUT A MESSAGE AND
; TELL THE USER OF THE FACT THAT THE TASK IS DONE.  THEN AN
; "EXIT" DIRECTIVE IS ISSUED.
;
;-
	$$STEP
	SETF$S	#48.,.RJCT	;USE SET FLAG TO READ EF48
				;(AND INSURE THAT TST01B CONTINUES)
	CALL	.ETST		;PRINT END OF TEST MESSAGE
	EXIT$S	.RJCT
	.PAGE
;
;
; THIS ROUTINE IS USED TO REPORT ERRORS DISCOVERED WITH THE 'QUEUE I/O'
; FUNCTIONS.  THE INDICATOR OF THE ERROR IS CONTAINED IN R5 AND IS
; INTERPRETED AS FOLLOWS:
;
;		1 = DATA ERROR (INVALID INPUT)
;		2 = DATA SPILL OVER (TOO MUCH INPUT STORED)
;		3 = INCORRECT I/O STATUS
;		4 = INCORRECT BYTE COUNT
;
; THE ROUTINE FIRST PRINTS OUT THE FACT THAT AN I/O ERROR OCCURRED,
; GIVING SUCH INFORMATION AS THE ERROR CODE, AND THE SUBTEST/STEP
; NUMBER IN WHICH THE ERROR OCCURRED.  THEN IT JUMPS INTO THE
; PARTICULAR SERVICE ROUTINE WRITTEN TO HANDLE THE ERROR.
;
;
IOERR:	MOV	R2,-(SP)	;SAVE REGISTERS R2,
	MOV	R1,-(SP)	;		R1,
	MOV	R0,-(SP)	;		& R0.
	CALL	.IDOUT		;CREATE OUTPUT OF STEP IDENTIFICATION
	MOV	#LEM00,R1	;PUT ADDR OF 'I/O ERROR' FORMAT IN R1
	MOV	R5,-(SP)	;PUSH ERROR CODE ON STACK
	MOV	SP,R2		;PUT SP ADDR IN R2 (ARG LIST)
	CALL	$EDMSG		;CREATE OUTPUT OF ERROR CODE
	TST	(SP)+		;POP ERROR CODE FROM STACK
 
;
; NOW DETERMINE WHICH SERVICE ROUTINE TO USE
;
 
	ASL	R5		;CONVERT ERROR CODE INTO A WORD OFFSET
	JMP	@SVCTBL-2(R5)	;AND JUMP TO THE SERVICE ROUTINE
 
;
; THIS IS THE COMMON RETURN FROM THE I/O ERROR HANDLERS.
;
 
IOFRTN:	MOV	(SP)+,R0	;RESTORE R0,
	MOV	(SP)+,R1	;	 R1,
	MOV	(SP)+,R2	;	 & R2.
	SEC			;SET PS C-BIT TO INDICATE ERROR
	RETURN			;AND RETURN


;
; THIS IS THE 'DATA ERROR' SERVICE ROUTINE.  THE EXPECTED DATA IS IN
; THE LOW BYTE OF LOCATION '(SP)', AND THE RECEIVED DATA IS IN
; THE LOW BYTE OF LOCATION '2(SP)'.  THE ROUTINE CONVERTS (INTO
; ASCII REPRESENTATION) AND STORES BOTH DATA BYTES AND SENDS THE
; INFORMATION TO TI.
;
CODE1:	MOV	#LEM01,R1	;PUT ADDR OF CODE1 FORMAT IN R1
	BR	OUTERM		;BRANCH TO OUTPUT THE MESSAGE
 
 
;
; THIS IS THE 'DATA SPILL OVER' SERVICE ROUTINE.  IT SIMPLY SENDS A
; MESSAGE TO TI INFORMING THE USER OF THE ERROR.
;
CODE2:	MOV	#LEM02,R1	;PUT ADDR OF CODE2 FORMAT IN R1
	BR	OUTERM		;BRANCH TO OUTPUT THE MESSAGE
 
 
;
; THIS IS THE 'INCORRECT I/O STATUS' SERVICE ROUTINE.  THE EXPECTED
; STATUS IS IN LOCATION '(SP)', AND THE RETURNED STATUS IS IN
; LOCATION '2(SP)' .  THE ROUTINE WILL HAVE THEM CONVERTED INTO
; DECIMAL REPRESENTATION AND STORE THEM IN A MESSAGE TO BE SENT TO
; THE USER AT TI.
;
CODE3:	MOV	#LEM03,R1	;PUT ADDR OF CODE3 FORMAT IN R1
	BR	OUTERM		;BRANCH TO OUTPUT THE MESSAGE
 
 
;
; THIS IS THE 'INCORRECT BYTE COUNT' SERVICE ROUTINE.  THE EXPECTED
; COUNT IS IN LOCATION '(SP)', AND THE RETURNED COUNT IS IN LOCATION
; '2(SP)'.  BOTH COUNTS WILL BE CONVERTED INTO DECIMAL REPRESENTATION

; AND STORED IN A MESSAGE TO BE SENT TO TI.
;
CODE4:	MOV	#LEM04,R1	;PUT ADDR OF CODE4 FORMAT IN R1
 
OUTERM:	MOV	SP,R2		;PUT ADDR OF ARG LIST IN R2
	CALL	.PRTMG		;CREATE THE LINE OF OUTPUT & PRINT
	JMP	IOFRTN		;JUMP TO COMMON RETURN


;
; THIS SHORT UTILITY SUBROUTINE IS USED BY 'TST01A' TO SET UP FOR INPUT
; FROM TI.  IT CLEARS BOTH WORDS OF THE TASK'S I/O STATUS BLOCK

; (IOSTAT) AND CLEARS THE 20 BYTE BUFFER (IPTBUF).  THEN IT SENDS A
; MESSAGE TO TI REQUESTING A SPECIFIC LINE OF INPUT BE ENTERED AT
; TI.
;
SETIPT:	CLR	IOSTAT		;CLEAR BOTH WORDS OF THE TASK'S
	CLR	IOSTAT+2	;I/O STATUS BLOCK
	MOV	#IPTBUF,R2	;PUT ADDRESS OF INPUT BUFFER IN R2
	MOV	#10.,R1		;AND WORD SIZE IN R1
1$:	CLR	(R2)+		;CLEAR A WORD OF THE BUFFER
	SOB	R1,1$		;DECR CNTR & REPEAT UNTIL ZERO
 
;
; SEND THE MESSAGE TO TI
;
 
	QIO$C	IO.WVB,TI,1,,,,<LMG03,56.,'$>,TST01A,.RJCT
	DIR$	#WT1,.RJCT
	RETURN			;RETURN
 
 
; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


	.END	STP0
