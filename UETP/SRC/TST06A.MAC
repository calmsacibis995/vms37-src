	.TITLE	TST06A
	.IDENT	/V03000/
	.PSECT	TST06A
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; VERSION X02-1
;
; WRITTEN BY CLARK A. D'ELIA, JANUARY 1973
;
; MODIFIED BY:
;	C.A. D'ELIA	SEPTEMBER 1974  (FOR RSX-11M)
;	C.A. D'ELIA	OCTOBER 1974
;	L.D. JONES	DECEMBER 1977	(FOR VAX/VMS)
;
;+
;
; MODULE 'TST06A' IS TEST06 OF THE RSX-11M TEST SYSTEM.  IT IS
; DESIGNED TO TEST THE FOLLOWING SYSTEM DIRECTIVES:
;
;	GET MCR COMMAND LINE
;	SPECIFY SST VECTOR TABLE FOR DEBUGGING AID
;	SPECIFY SST VECTOR TABLE FOR TASK
;
;-


	.MCALL	SVTK$,SVDB$,GMCR$C,SVTK$C,SVDB$C,SVDB$S,SVTK$S
	.MCALL	CALL,RETURN,SFPA$S,EXIT$S


;
; LOCAL EQUATED SYMBOLS
;
 
LF=12				;LINE FEED ASCII CODE

ILLINS=000101			;ILLEGAL INSTRUCTION  [JMP R1]

RSVINS=007777			;RESERVED INSTRUCTION CODE
 
TSTINS=010141			;HDW INCOMPATIBLE INSTR  [MOV R1,-(R1)]

TBIT=20				;NEEDED TO TURN T-BIT ON/OFF
 

;
; LOCAL MACRO DEFINITIONS
;

; MACRO USED TO SETUP THE SST TRAP HANDLERS
 
	.MACRO	$$SST	TYP,NAM,NUM,CHK
TYP'NAM:	JSR	PC,TYP'MOD
	.IF IDN	<TYP>,<TSK>
NAM'SST:	CMP	#NUM,SSTNUM
	.IF B	<CHK>
	BEQ	RTNSST
	.IFF
	BEQ	NAM'CK
	.ENDC
	MOV	#NUM,-(SP)
	JMP	NUMERR
	.IFF
	BR	NAM'SST
	.ENDC
	.ENDM	$$SST


;
; LOCAL DATA
;
 
FZERO:	.WORD	0,0,0,0		;USED TO CAUSE DIVIDE BY ZERO

SSTMOD:	.BLKW	1		;KEEPS TRACK OF CURRENT SST MODE
 
SSTNUM:	.BLKW	1		;KEEPS TRACK OF SST NUMBER
 
NEWSST:	.WORD	0		;WHEN SET, USE RE-SPECIFIED VECTOR
 
MTYPE:	.WORD	0		;MACHINE TYPE
 
FIS40:	.BLKW	1		;SET IF EXEC AND MACHINE SUPPORT ...
				;... PDP-11/40 FIS
 
MEMGT:	.BLKW	1		;MEMORY MANAGEMENT FLAG
 
STKPNT:	.BLKW	1		;USED TO VERIFY CORRECTNESS OF STACK...
				;... WHILE IN SST TRAP CODE
 
SSTADR:	.BLKW	1		;USED FOR PROPER RETURN AFTER SST ERRORS
 
 

TSKSST:				;TASK SST VECTOR TABLE
	.WORD	TSKODD
	.WORD	TSKSEG
	.WORD	TSKBPT
	.WORD	TSKIOT
	.WORD	TSKRES
	.WORD	TSKEMT
	.WORD	TSKTRP
	.WORD	TSKFLT

DBGSST:				;DEBUGGING AID SST VECTOR TABLE
	.WORD	DBGODD
	.WORD	DBGSEG
	.WORD	DBGBPT
	.WORD	DBGIOT
	.WORD	DBGRES
	.WORD	DBGEMT
	.WORD	DBGTRP
	.WORD	DBGFLT
 
TS2SST:				;SECOND SST VECTOR FOR TASK
	.WORD	TS2ODD
 
DB2SST:				;SECOND SST VECTOR FOR DEBUGGING AID
	.WORD	DB2ODD
	.WORD	0,0
 
SSTER1:				;SST VECTOR TO GENERATE ERROR CONDITIONS
	.WORD	ODDSST
	.WORD	0,0
	.WORD	IOTERR
 
SSTER2:				;SST VECTOR TO GENERATE ERROR CONDITIONS
	.WORD	ODDTRP
	.WORD	SEGTRP
	.WORD	160000
	.WORD	1
 
 
	.NLIST	BEX

LMG01:	.ASCII	<LF>'+++ 11/40 FLOATING POINT "SST" DID NOT OCCUR%N'
	.ASCIZ	'    SYSTEM MAY NOT SUPPORT THIS OPTION'<LF>
 
LEM01:	.ASCIZ	/%N"SST" NUMBER %D. DID NOT TRAP/

LEM02:	.ASCIZ	/%N"SST" NUMBER %D. ENTERED TRAP NUMBER %D./

LEM03:	.ASCII	/%N"SST" NUMBER %D. TRAPPED THROUGH THE/
	.ASCIZ	/ VECTOR FOR /

LEM04:	.ASCIZ	/'TASK'/

LEM05:	.ASCIZ	/'DEBUGGING-AID'/
 
LEM06:	.ASCIZ	/, RE-SPECIFIED VECTOR TABLE IGNORED/
 
LEM07:	.ASCIZ	/%N"SST" NUMBER %D. HAD IMPROPER STACK -- OFF BY %D. WORDS/
 
LEM08:	.ASCII	/%N"SST" NUMBER %D. HAD IMPROPER 'PC' ON STACK/
VAL08:	.ASCIZ	/%NEXPECTED: %P , RECEIVED: %P/
 
LEM09:	.ASCIZ	/%N"SST" NUMBER %D. HAD IMPROPER VALUE ON STACK/
 
	.LIST	BEX
	.PAGE
	.PSECT	$DPB$$

;
; THIS CONTROL SECTION CONTAINS ONLY DPB'S
;

VDBDPB:	SVDB$	DBGSST

VTKDPB:	SVTK$	TSKSST
	.PAGE
	.PSECT	TST06A
	.EVEN
;+
;
; THE INITIAL STEP PERFORMED BY THIS TASK IS THAT OF IDENTIFICATION TO
; THE USER.  A MESSAGE SENT TO TI:  INFORMS THE USER OF TASK EXECUTION
; AND TASK NUMBER.
;
;-
	$$TEST	6,A
	CALL	.STST		;SEND THE START OF TEST MESSAGE
 
;+
;
; TESTING WILL NOW BE PERFORMED ON THE "SPECIFY SST VECTOR TABLE FOR
; TASK" DIRECTIVE.  THIS ISSUES THE DIRECTIVE, AND THE FOLLOWING STEPS
; TEST THE TRAP MECHANISM.
;
;-
	$$STEP
	SVTK$C	TSKSST,8.,TST06A,.RJCT
	CALL	.SUCC		;CHECK FOR SUCCESS RETURN STATUS
	CLR	SSTMOD		;WHEN CLEAR, TRAP VIA TASK SST VECTOR
	MOV	SP,STKPNT	;NEEDED TO VERIFY THE CORRECTNESS OF ...
	SUB	#4,STKPNT	;... STACK WHILE IN SST TRAP CODE
;+
;
; TO BEGIN TESTING OF THE SST'S, GENERATE AN "ODD ADDRESS" ERROR.
;
;-
	$$STEP
	;*****
	JMP	STP4		; STEP 2,3 DISABLED
;*****
	MOV	#1,SSTNUM	;"ODD ADDR" (FIRST WORD IN VECTOR)
	MOV	#100$,SSTADR	;SAVE PROPER RETURN ADDRESS
	TST	1		;GENERATE THE ERROR
100$:	CALL	CHKSST		;CHECK TO SEE IF SST HANDLED O.K.
;+
;
; THE FOLLOWING STEP WILL GENERATE A MEMORY PROTECT FAILURE (SEGMENT FAULT)
; IF RUNNING ON A MAPPED SYSTEM OR A NON-EXISTENT MEMORY FAILURE
; (TRAP AT FOUR) IF RUNNING ON AN UNMAPPED SYSTEM.
;
;-
	$$STEP
	CLR	MEMGT		;ASSUME NO MEMORY MANAGEMENT UNIT
	MOV	#100$,R0	;PUT PROPER RETURN ADDR IN R0
	MOV	R0,SSTADR	;AND SAVE IT
	CMP	R0,#10000	;IF RUNNING ON A MAPPED SYSTEM ...
				;... VIRTUAL ADDRESSES WILL BE SMALL
	BHI	10$		;BRANCH IF REAL MEMORY SYSTEM
	INC	MEMGT		;SET MAPPED SYSTEM FLAG
	MOV	#2,SSTNUM	;"SEGMENT FAULT" (SECOND VECTOR WORD)
	BR	20$		;BRANCH TO COMMON CODE
10$:	MOV	#1,SSTNUM	;"NON-EXISTENT MEMORY" (FIRST VECTOR WORD)
20$:	TST	160000		;GENERATE THE ERROR
100$:	CALL	CHKSST		;INSURE THAT SST WAS SERVICED
;+
;
; THE THIRD TYPE OF SST CAN BE INVOKED SEVERAL WAYS.  THIS STEP GENERATES
; A TRAP BY EXECUTING A "BPT" INSTRUCTION.
;
;-
	$$STEP
	MOV	#3,SSTNUM	;"BPT" INSTRUCTION (THIRD VECTOR WORD)
	MOV	#100$,SSTADR	;SAVE PROPER RETURN ADDRESS
	BPT			;GENERATE THE TRAP
100$:	CALL	CHKSST		;AND CHECK
;+
;
; THE FOURTH TYPE OF SST IS CAUSED BY EXECUTING THE "IOT" INSTRUCTION.
;
;-
	$$STEP
	MOV	#4,SSTNUM	;"IOT" INSTRUCTION (FOURTH VECTOR WORD)
	MOV	#100$,SSTADR	;SAVE PROPER RETURN ADDRESS
	IOT			;GENERATE THE TRAP
100$:	CALL	CHKSST		;AND TEST THE RESULTS
;+
;
; THE FIFTH TYPE OF SST IS CAUSED BY THE EXECUTION OF A RESERVED
; INSTRUCTION (OTHER THAN THE ONES ABOVE).  THIS STEP EXECUTES
; AN INSTRUCTION CODE THAT IS RESERVED FOR FUTURE EXPANSION.
;
;-
	$$STEP
;*****
	JMP	STP7		; STEP 6 DISABLED
;*****
	MOV	#5,SSTNUM	;"RESERVED" (FIFTH VECTOR WORD)
	MOV	#100$,SSTADR	;SAVE PROPER RETURN ADDRESS
	.WORD	RSVINS		;EXECUTE THE RESERVED INSTRUCTION CODE
100$:	CALL	CHKSST		;CHECK RESULTS
;+
;
; TO PROPERLY TEST FOR THE "ILLEGAL INSTRUCTION" TRAP, THE MACHINE TYPE
; MUST BE KNOWN.  THIS IS NECESSARY BECAUSE THE PDP-11/45 HANDLES AN
; ILLEGAL INSTRUCTION LIKE A RESERVED INSTRUCTION (SST VECTOR WORD 5).
; HOWEVER, THE PDP-11/10/20/40 HANDLE ILLEGAL INSTRUCTIONS AS TRAPS TO
; FOUR (SST VECTOR WORD 1).
;
;-
	$$STEP
	CLR	MTYPE		;CLEAR MACHINE TYPE INDICATOR
	MOV	#5,SSTNUM	;SETUP FOR POSSIBLE RESERVED INSTR TRAP
	MOV	#100$,SSTADR	;
	SUB	#4,STKPNT	;ACCOUNT FOR TWO EXTRA WORDS ON STACK
	CLR	-(SP)		;... A TRAP WILL OCCUR IF MACHINE IS NOT
	MOV	#100$,-(SP)	;... A PDP-11/40 OR A PDP-11/45
	RTT			;
100$:	ADD	#4,STKPNT	;RESTORE SST STACK POINTER WORD
	TST	SSTNUM		;CHECK FOR EVIDENCE OF TRAP HANDLING
	BGT	150$		;SKIP IF NONE OCCURRED
	CMP	(SP)+,(SP)+	;CLEAN STACK
	BR	200$		;CONTINUE, MACHINE IS NOT PDP-11/40/45
150$:	MOV	#40.,MTYPE	;ASSUME MACHINE IS A PDP-11/40
	MOV	#.OBUF-2,R1	;POINT R1 ARBITRARILY INTO A BUFFER
	.WORD	TSTINS		;MOV  R1,-(R1)  INCOMPATIBLE INSTRUCTION
	CMP	R1,(R1)		;IF MACHINE IS PDP-11/45/10, THEN THE
	BEQ	200$		;... CONTENTS OF @R1 WILL BE R1+2
	MOV	#45.,MTYPE	;IF TRUE, THEN MACHINE IS PDP-11/45
200$:
;+
;
; THE TESTING OF PROPGRAM TRAPS IS CONTINUED BY ATTEMPTING TO EXECUTE
; AN ILLEGAL INSTRUCTION (AN INSTRUCTION WITH AN ILLEGAL OPERAND ADDRESS).
; THIS WILL TRAP TO SST VECTOR ENTRY ONE IF THE MACHINE IS AN 11-10/20/40,
; AND TRAP TO SST VECTOR ENTRY FIVE IF THE MACHINE IS AN 11-45.
;
;-
	$$STEP
;*****
	JMP	STP12		; STEP 10,11 DISABLED
;*****
	MOV	#1,SSTNUM	;ASSUME TRAP TO FOUR (11-10/20/40)
	CMP	#45.,MTYPE	;IS MACHINE A PDP-11/45?
	BNE	10$		;SKIP IF NOT
	MOV	#5,SSTNUM	;ELSE, TRAP AS RESERVED INSTRUCTION
10$:	MOV	#100$,SSTADR	;SAVE PROPER RETURN ADDRESS
	.WORD	ILLINS		;EXECUTE ILLEGAL INSTR  [JMP R1]
100$:	CALL	CHKSST		;CHECK THE RESULTS
;+
;
; AN SST WILL BE CAUSED BY THE EXECUTION OF A "NON-RSX EMT".
;
;-
	$$STEP
	MOV	#6,SSTNUM	;"NON-RSX EMT" (SIXTH VECTOR WORD)
	MOV	#100$,SSTADR	;SAVE PROPER RETURN ADDRESS
	EMT	1		;GENERATE A TRAP
100$:	CALL	CHKSST
;+
;
; THE SEVENTH SST IS GENERATED BY THE EXECUTION OF A "TRAP" INSTRUCTION.
;
;-
	$$STEP
	MOV	#7,SSTNUM	;"TRAP" INSTRUCTION (SEVENTH VECTOR WORD)
	MOV	#100$,SSTADR	;SAVE PROPER RETURN ADDRESS
	TRAP	200		;GENERATE A TRAP
100$:	CALL	CHKSST
;+
;
; IF THE MACHINE ON WHICH THIS TASK IS NOW RUNNING IS A PDP-11/40,
; AND IF THE EXECUTIVE IS NOT BUILT TO SUPPORT AN 11/45-FPU,
; THE "11/40 FLOATING POINT EXCEPTION" SST WILL BE TESTED.
;
;-
	$$STEP
;*****
	JMP	STP15		; STEP 13,14 DISABLED
;*****
	CLR	FIS40		;ASSUME NO SYSTEM 11/40-FIS SUPPORT
	MOV	#5,SSTNUM	;SETUP TO HANDLE A RESERVED INSTRUCTION
	MOV	#100$,SSTADR	;SAVE PROPER RETURN ADDRESS
	MOV	#FZERO,R4	;POINT R4 TO NULL FLOATING POINT DATA
	FADD	R4		;EXECUTE A PDP-11/40 FIS INSTRUCTION
100$:	TST	SSTNUM		;CHECK TO SEE IF SST WAS HANDLED
	BEQ	1$		;AND SKIP IF NO 11/40-FIS HARDWARE
	SFPA$S	.ABORT		;TRY TO SPECIFY AN 11/45-FPU AST ADDR
	BCC	1$		;SKIP IF EXEC IS BUILT FOR 11/45-FPU
	CMP	#IE.SDP,@#$DSW	;WAS ERROR CODE ILLEGAL DIRECTIVE?
	BEQ	150$		;SKIP IF TRUE--NOT AN 11/45-FPU EXEC
	CALL	.RJCT		;ELSE, REPORT DIRECTIVE FAILURE
	BR	1$		;SKIP 11/40-FIS TRAP (AVOID POSSIBLE ...
				;... SYSTEM CRASH)
150$:	MOV	#8.,SSTNUM	;"11/40 FLT PNT" (EIGTH VECTOR WORD)
	MOV	#200$,SSTADR	;SAVE PROPER RETURN ADDRESS
	FDIV	R4		;CAUSE THE FLOATING POINT EXCEPTION
200$:	TST	SSTNUM		;CHECK FOR SST ACTION
	BNE	300$		;SKIP IF IT DID NOT OCCURRED
	INC	FIS40		;INDICATE PDP-11/40 FIS SUPPORT
	BR	1$		;BRANCH TO CONTINUE
300$:	MOV	#.OBUF,R0	;ELSE, REPORT LACK OF 11/40-FIS SUPPORT
	MOV	#LMG01,R1	;
	MOV	SP,R2		;
	CALL	.PRTMG		;
1$:
;+
;
; THE TESTING OF THE THIRD SST IS COMPLETED BY CAUSING A "T-BIT" TRAP.
;
;-
	$$STEP
	MOV	#3,SSTNUM	;"T-BIT" TRAP (THIRD VECTOR WORD)
	MOV	#100$,SSTADR	;PROPER RETURN ADDR (FOR PDP-11/40/45)
	CMP	#40.,MTYPE	;IS MACHINE A PDP-11/40/45?
	BLE	10$		;SKIP IF TRUE
	MOV	#200$,SSTADR	;UPDATE RETURN ADDR (FOR PDP-11/10/20)
10$:	MOV	#TBIT,-(SP)	;PUSH "T-BIT" PS WORD ON STACK
	MOV	#100$,-(SP)	;AND PC ON STACK
	RTI			;LOAD NEW PS & PC FROM STACK
100$:	NOP
200$:	CALL	CHKSST		;CHECK FOR SST HANDLING
;+
;
; TESTING IS CONTINUED WITH THE ISSUANCE OF "SPECIFY SST VECTOR TABLE
; FOR DEBUGGING AID".  THIS DIRECTIVE SERVES TO OVERIDE THE SST VECTOR
; TABLE FOR TASK.
;
;-
	$$STEP
	SVDB$C	DBGSST,8.,TST06A,.RJCT
	CALL	.SUCC		;CHECK FOR SUCCESS RETURN STATUS
	INC	SSTMOD		;WHEN NOT ZERO,TRAP VIA DEBUG SST VECTOR
;+
;
; THE FOLLOWING STEPS GENERATE ONE OF EACH KIND OF SST.  THE FIRST IS THE
; "ODD ADDRESS" ERROR.
;
;-
	$$STEP
;*****
	JMP	STP20		; STEP 16,17 DISABLED
;*****
	MOV	#1,SSTNUM	;"ODD ADDR" (FIRST VECTOR WORD)
	MOV	#100$,SSTADR	;SAVE PROPER RETURN ADDRESS
	TST	1		;CREATE THE ERROR
100$:	CALL	CHKSST		;CHECK RESULTS
;+
;
; IF RUNNING ON A MAPPED SYSTEM, GENERATE A "SEGMENT FAULT" TRAP.
; IF RUNNING ON A REAL MEMORY SYSTEM, GENERATE A NON-EXISTENT MEMORY
; FAILURE (TRAP AT FOUR).
;
;-
	$$STEP
	MOV	#1,SSTNUM	;ASSUME NON-MAPPED (NON-EXISTENT MEMORY)
	TST	MEMGT		;CHECK MEMORY MANAGEMENT FLAG
	BEQ	10$		;BRANCH IF CORRECT ASSUMPTION
	MOV	#2,SSTNUM	;ELSE, "SEGMENT FAULT" (SECOND VECTOR WORD)
10$:	MOV	#100$,SSTADR	;SAVE PROPER RETURN ADDRESS
	TST	160000		;GENERATE ERROR
100$:	CALL	CHKSST		;AND CHECK
;+
;
; GENERATE AN SST BY EXECUTING THE "BPT" INSTRUCTION.
;
;-
	$$STEP
	MOV	#3,SSTNUM	;"BPT" INSTRUCTION (THIRD VECTOR WORD)
	MOV	#100$,SSTADR	;SAVE PROPER RETURN ADDRESS
	BPT			;CAUSE THE TRAP
100$:	CALL	CHKSST		;CHECK THE RESULTS

;+
;
; CAUSE AN SST BY EXECUTING THE "IOT" INSTRUCTION.
;
;-
	$$STEP
	MOV	#4,SSTNUM	;"IOT" INSTRUCTION (FOURTH VECTOR WORD)
	MOV	#100$,SSTADR	;SAVE PROPER RETURN ADDRESS
	IOT			;GENERATE THE TRAP
100$:	CALL	CHKSST		;CHECK THE RESULTS
;+
;
; GENERATE AN SST BY ATTEMPTING TO USE A "RESERVED INSTRUCTION".
;
;-
	$$STEP
;*****
	JMP	STP25		; STEP 22,23,24 DISABLED
;*****
	MOV	#5,SSTNUM	;"RES'VD" INSTR. (FIFTH VECTOR WORD)
	MOV	#100$,SSTADR	;SAVE PROPER RETURN ADDRESS
	.WORD	RSVINS		;CAUSE THE ERROR
100$:	CALL	CHKSST		;CHECK THE RESULTS
;+
;
; AN ATTEMPT WILL BE MADE TO EXECUTE AN ILLEGAL INSTRUCTION.  THIS 
; WILL TRAP THROUGH SST VECTOR WORD ONE FOR THE PDP-11/10/20/40, AND
; THROUGH SST VECTOR WORD FIVE FOR THE PDP-11/45.
;
;-
	$$STEP
	MOV	#1,SSTNUM	;ASSUME TRAP THROUGH SST WORD ONE
	CMP	#45.,MTYPE	;IS MACHINE A PDP-11/45?
	BNE	10$		;SKIP IF NOT
	MOV	#5,SSTNUM	;ELSE, TRAP THROUGH SST WORD FIVE
10$:	MOV	#100$,SSTADR	;SAVE PROPER RETURN ADDRESS
	.WORD	ILLINS		;JMP R1  ILLEGAL INSTRUCTION
100$:	CALL	CHKSST		;CHECK FOR SST TRAP HANDLING
;+
;
; CAUSE AN SST TO OCCUR BY USING A "NON-RSX EMT" INSTRUCTION.
;
;-
	$$STEP
	MOV	#6,SSTNUM	;"NON-RSX EMT" (SIXTH VECTOR WORD)
	MOV	#100$,SSTADR	;SAVE PROPER RETURN ADDRESS
	EMT	1
100$:	CALL	CHKSST
;+
;
; GENERATE AN SST BY EXECUTING THE "TRAP" INSTRUCTION.
;
;-
	$$STEP
	MOV	#7,SSTNUM	;"TRAP" INSTRUCTION (SEVENTH VECTOR WORD)
	MOV	#100$,SSTADR	;SAVE PROPER RETURN ADDRESS
	TRAP	200
100$:	CALL	CHKSST
;+
;
; IF THE MACHINE ON WHICH THIS TASK IS RUNNING IS AN 11/40, A
; "FLOATING POINT EXCEPTION" WILL BE GENERATED.
;
;-
	$$STEP
	TST	FIS40		;IS THERE PDP-11/40 FIS SUPPORT?
	BEQ	1$		;SKIP IF NOT
	MOV	#8.,SSTNUM	;"11/40 FLT PNT" (EIGTH VECTOR WORD)
	MOV	#100$,SSTADR	;SAVE PROPER RETURN ADDRESS
	MOV	#FZERO,R4	;PUT FLOATING POINT STACK ADDR IN R4
	FDIV	R4		;CAUSE THE FLOATING POINT EXCEPTION
100$:	CALL	CHKSST		;CHECK RESULTS
1$:
;+
;
; A NEW VECTOR TABLE FOR DEBUGGING AID WILL BE SPECIFIED.  IT WILL
; CONTAIN ONLY THREE ENTRIES (SECOND & THIRD ARE ZERO).  THIS STEP WILL
; CHECK THAT THE SST TRAPS TO THE NEW "ODD ADDRESS" ERROR ROUTINE.
;
;-
	$$STEP
;*****
	JMP	STP30		; STEP 27 DISABLED
;*****
	SVDB$C	DB2SST,2,TST06A,.RJCT
	CALL	.SUCC		;CHECK FOR SUCCESS RETURN STATUS
	INC	NEWSST		;USE NEW SST TABLE
	MOV	#1,SSTNUM	;"ODD ADDR" (FIRST VECTOR WORD)
	MOV	#100$,SSTADR	;SAVE PROPER RETURN ADDRESS
	TST	1		;CAUSE THE ERROR
100$:	CALL	CHKNEW		;CHECK THE RESULTS
;+
;
; THE THIRD ENTRY IS ZERO, AND, THEREFORE, A "BPT" INSTRUCTION
; SHOULD TRAP VIA THE TASK VECTOR TABLE.  THIS STEP WILL
; CHECK IT OUT.
;
;-
	$$STEP
;*****
	JMP	STP36		;STEP 30,31,32,33,34,35,36 DISABLED
;*****
	CLR	SSTMOD		;USE TASK VECTOR
	MOV	#3,SSTNUM	;"BPT INSTRUCTION" (THIRD VECTOR WORD)
	MOV	#100$,SSTADR	;SAVE PROPER RETURN ADDRESS
	BPT			;CAUSE THE ERROR
100$:	CALL	CHKSST		;CHECK THE RESULTS
;+
;
; THE SST VECTOR FOR DEBUGGING AID WILL BE RE-SPECIFIED, BUT IT WILL
; BE GIVEN A LENGTH OF ZERO.  THIS SHOULD HAVE THE SAME EFFECT AS
; DELETING IT.  THIS WILL BE CHECKED.
;
;-
	$$STEP
	SVDB$S	#DBGSST,,.RJCT	;SPECIFY NEW DEBUG VECTOR W/ LENGTH ZERO
	CALL	.SUCC		;CHECK FOR SUCCESS RETURN STATUS
	MOV	#1,SSTNUM	;"ODD ADDRESS ERROR" (FIRST VECTOR WORD)
	MOV	#100$,SSTADR	;SAVE PROPER RETURN ADDRESS
	TST	1		;GENERATE THE ERROR
100$:	CALL	CHKSST		;CHECK FOR SST HANDLING
;+
;
; THE SST VECTOR TABLE FOR DEBUGGING AID WILL BE DELETED.  THEN AN SST
; WILL BE GENERATED TO INSURE THAT IT IS SERVICED VIA THE TASK'S SST
; VECTOR TABLE.
;
;-
	$$STEP
	SVDB$S	,,.RJCT		;DELETE DEBUGGING AID VECTOR
	CALL	.SUCC		;CHECK FOR SUCCESS RETURN STATUS
	MOV	#1,SSTNUM	;"ODD ADDR" ERROR (FIRST VECTOR WORD)
	MOV	#100$,SSTADR	;SAVE PROPER RETURN ADDRESS
	TST	1		;CAUSE THE ERROR
100$:	CALL	CHKSST		;CHECK
;+
;
; THE SST VECTOR TABLE FOR TASK WILL BE RE-SPECIFIED.  THEN A
; CHECK WILL BE MADE TO INSURE THAT IT IS USED.
;
;-
	$$STEP
	SVTK$C	TS2SST,1,TST06A,.RJCT
	CALL	.SUCC		;CHECK FOR SUCCESS RETURN STATUS
	INC	NEWSST		;USE NEW VECTOR
	MOV	#1,SSTNUM	;"ODD ADDR" (FIRST VECTOR WORD)
	MOV	#100$,SSTADR	;SAVE PROPER RETURN ADDRESS
	TST	1		;CAUSE THE ERROR
100$:	CALL	CHKNEW		;CHECK THE RESULTS
;+
;
; A NEW SST VECTOR FOR TASK WILL BE SPECIFIED.  THEN AN "IOT" TRAP
; WILL BE GENERATED.  HOWEVER, IN THE SST HANDLER CODE, AN "ODD
; ADDRESS" TRAP WILL BE GENERATED.
;
;-
	$$STEP
	SVTK$S	#SSTER1,#4,.RJCT  ;SPECIFY A NEW TASK SST VECTOR
	CALL	.SUCC		;CHECK FOR SUCCESS RETURN STATUS
	MOV	#4,SSTNUM	;"IOT" (FOURTH VECTOR WORD)
	MOV	#100$,SSTADR	;SAVE PROPER RETURN ADDRESS
	IOT			;GENERATE THE FIRST LEVEL OF TRAP
100$:	CALL	CHKSST		;CHECK FOR SST HANDLING
 
 
	.PSECT	SSTERS
 
IOTERR:	CMP	#4,SSTNUM	;CHECK FOR PROPER TRAP CONDITION
	BEQ	10$		;BRANCH IF O.K.
	MOV	#4,-(SP)	;ELSE, PUT EXPECTED CONDITION ON STK
	JMP	NUMERR		;REPORT ERROR AND RETURN
10$:	CMP	SP,STKPNT	;INSURE THAT STACK IS IN PROPER STATE
	BEQ	20$		;BRANCH IF O.K.
	JMP	STKERR		;ELSE, REPORT ERROR IN SST STACK
20$:	CMP	(SP),SSTADR	;INSURE PROPER RETURN ADDR IS ON STK
	BEQ	30$		;BRANCH IF O.K.
	JMP	ADRERR		;ELSE, REPORT ERROR IN RETURN ADDR
30$:	MOV	#1,SSTNUM	;"ODD ADDRESS"
	MOV	STKPNT,-(SP)	;SAVE OLD STACK POINTER, AND
	MOV	SSTADR,-(SP)	;... RETURN ADDRESS
	MOV	SP,STKPNT	;SETUP NEW STACK POINTER
	SUB	#4,STKPNT	;
	MOV	#50$,SSTADR	;... AND NEW RETURN ADDRESS
	TST	1		;GENERATE ODD ADDRESS ERROR
50$:	CALL	CHKSST		;CHECK FOR SST HANDLING
	MOV	(SP)+,SSTADR	;RESTORE OLD RETURN ADDRESS, AND
	MOV	(SP)+,STKPNT	;... AND STACK POINTER
	JMP	RTNSST		;RETURN THROUGH COMMON SST EXIT CODE
 
 
	.PSECT	TST06A
 
;+
;
; A NEW SST VECTOR FOR TASK WILL BE SPECIFIED.  HOWEVER, THIS ONE
; WILL HAVE AN ODD ADDRESS IN THE "IOT" TRAP WORD AND AN ADDRESS
; THAT IS NOT WITHIN THIS TASK'S RANGE IN THE "BPT" TRAP WORD.
;
;-
	$$STEP
	SVTK$S	#SSTER2,#4,.RJCT
	MOV	#1,SSTNUM	;SETUP FOR ULTIMATE ODD-ADDR TRAP
	MOV	#100$,SSTADR	;SAVE PROPER RETURN ADDR

	IOT			;CAUSE TRAP-TO-A-TRAP
100$:	CALL	CHKSST		;CHECK FOR SST HANDLING
 
	MOV	#1,SSTNUM	;ASSUME NO MEMORY MGT (NON-EXIST MEM FLT)
	TST	MEMGT		;LOOK AT MEMORY MANAGEMENT FLAG
	BEQ	10$		;SKIP IF CORRECT ASSUMPTION
	MOV	#2,SSTNUM	;ELSE, SETUP FOR SEGMENT FAULT
10$:	MOV	#200$,SSTADR	;SAVE PROPER RETURN ADDR
	BPT			;TRAP-TO-A-TRAP
200$:	CALL	CHKSST		;CHECK FOR SST HANDLING
 
 
	.PSECT	SSTERS
 
ODDTRP:	CMP	(SP)+,(SP)+	;CLEAN ODD PC/PS FROM STACK
	JMP	ODDSST		;PROCESS AS NORMAL SST
 
SEGTRP:	CMP	(SP)+,(SP)+	;CLEAN TWO WORDS FROM STACK (FROM FIRST
				;LEVEL OF SST TRAP)
	JMP	SEGSST		;PROCESS AS NORMAL SST
 
 
	.PSECT	TST06A
 

 

;+
;
; DELETE THE SST VECTOR TABLE FOR THE TASK BEFORE CONTINUING THE TESTING.
;
;-
	$$STEP
	SVTK$S	,,.RJCT		;DELETE TASK VECTOR
	CALL	.SUCC		;CHECK FOR SUCCESS RETURN STATUS
;+
;
; TESTING CONTINUES BY CHECKING THE ERROR HANDLING ABILITY OF THE
; SPECIFY SST VECTOR TABLE DIRECTIVES.  BOTH ARE INVOKED WITH A TABLE
; LENGTH THAT IS TOO LARGE.
;
;-
	$$STEP
	MOV	#VTKDPB,R2	;PUT ADDR OF TASK DPB IN R2
	MOV	#32.,S.VTTL(R2)	;MAKE TABLE LENGTH 32.
	DIR$	R2		;INVOKE SVTK$
	MOV	#IE.ADP,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
	MOV	#VDBDPB,R3	;PUT ADDR OF DEBUGGING DPB IN R3
	MOV	#32.,S.VDTL(R3)	;MAKE TABLE LENGTH 32.
	DIR$	R3		;INVOKE SVDB$
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
;+
;
; BOTH DIRECTIVES ARE INVOKED WITH A NEGATIVE TABLE LENGTH.
;
;-
	$$STEP
	MOV	#-1,S.VTTL(R2)	;MAKE LENGTH NEGATIVE
	DIR$	R2		;INVOKE SVTK$
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
	MOV	#-1,S.VDTL(R3)	;MAKE LENGTH NEGATIVE
	DIR$	R3		;INVOKE SVDB$
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
;+
;
; BOTH DIRECTIVES ARE INVOKED WITH TABLE ADDRESSES THAT ARE ODD.
;
;-
	$$STEP
	CALL	$ADCHK		;IS ADDRESS CHECKING SUPPORTED?
	BCS	SKPACK		;SKIP IF NOT
	MOV	#1,S.VTTL(R2)	;SET BOTH ...
	MOV	#1,S.VDTL(R3)	;TABLE LENGTHS TO ONE
	INC	S.VTTA(R2)	;MAKE ADDR ODD
	DIR$	R2		;INVOKE SVTK$
	MOV	#IE.ADP,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
	INC	S.VDTA(R3)	;MAKE ADDR ODD
	DIR$	R3		;INVOKE SVDB$
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
;+
;
; THE DIRECTIVES ARE INVOKED WITH TABLE ADDRESSES OUT OF RANGE OF THIS
; TASK'S ADDRESS SPACE.
;
;-
	$$STEP
;*****
	JMP	STP43		; STEP 42 DISABLED
;*****
	MOV	#160000,S.VTTA(R2)	;PUT BAD ADDR IN DPB
	DIR$	R2		;INVOKE SVTK$
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
	MOV	#160000,S.VDTA(R3)	;LIKEWISE WITH
	DIR$	R3		;SVDB$
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
	MOV	#TSKSST,S.VTTA(R2) ;RESTORE PROPER ADDRESSES
	MOV	#DBGSST,S.VDTA(R3) ;IN THE DPB'S
 
SKPACK:				;BRANCH HERE IF NO ADDRESS CHECKING
 
;+
;
; AN ATTEMPT WILL BE MADE TO USE THE "GET MCR COMMAND LINE" DIRECTIVE.
; SINCE THIS IS NOT AN MCR TASK, AN ERROR SHOULD BE RETURNED.
;
;-
	$$STEP
	GMCR$C	TST06A		;ATTEMPT TO READ MCR LINE
	MOV	#IE.AST,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
;+
;
; THE "SPECIFY SST VECTOR FOR TASK", "SPECIFY SST VECTOR FOR DEBUGGING
; AID", AND "GET MCR COMMAND LINE" DIRECTIVES ARE ALL ISSUED WITH
; INVALID DPB'S.
;
;-
	$$STEP
 
 
	.PSECT	$DPB$$
	.ENABL	LSB
 
10$:	.BYTE	105.,1		;INVALID SVTK$ DPB
 
20$:	.BYTE	103.,5		;INVALID SVDB$ DPB
 
30$:	.BYTE	127.,10.	;INVALID GMCR$ DPB
	.BLKW	40.
 
 
	.PSECT	TST06A
 
	DIR$	#10$		;INVOKE INVALID DPB
	MOV	#IE.SDP,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
	DIR$	#20$		;INVOKE BAD SVDB$ DPB
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
	DIR$	#30$		;INVOKE INVALID GMCR$ DPB
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
 
	.DSABL	LSB
 
;+
;
; FINALLY, THE SST VECTORS ARE ONCE AGAIN DELETED, BUT THIS TIME
; AN ALTERNATE FORM OF THE DPB IS USED.
;
;-
	$$STEP
	SVTK$S	,#2,.RJCT	;DELETE SST VECTOR FOR TASK
	CALL	.SUCC		;CHECK FOR SUCCESS RETURN STATUS
	SVDB$S	,#2,.RJCT	;DELETE SST VECTOR FOR DEBUGGING AID
	CALL	.SUCC		;CHECK FOR SUCCESS RETURN STATUS
;+
;
; TESTING IS FINISHED -- SEND FINAL MESSAGE AND EXIT
;
;-
	$$STEP
	CALL	.ETST		;SEND END OF TEST MESSAGE
	EXIT$S	.RJCT		;EXIT
	.PAGE
;
; FOLLOWING ARE THE SST ENTRY POINTS AS SPECIFIED IN BOTH THE 'TASK' AND
; THE 'DEBUGGING AID' VECTOR TABLES.
;
	$$SST	TSK,ODD,1	;"ODD ADDRESS" ERROR


	$$SST	TSK,SEG,2,1	;"SEGMENT FAULT" (W/ STACK CHECK)


	$$SST	TSK,BPT,3	;"BPT" INSTRUCTION OR T-BIT TRAP


	$$SST	TSK,IOT,4	;"IOT" INSTRUCTION


	$$SST	TSK,RES,5	;"RESERVED OR ILLEGAL" INSTRUCTION


	$$SST	TSK,EMT,6,1	;"NON-RSX EMT" INSTRUCTION (W/ STACK CHECK)


	$$SST	TSK,TRP,7,1	;"TRAP" INSTRUCTION (W/ STACK CHECK)
 
 
	$$SST	TSK,FLT,8.	;"11/40 FLOATING POINT EXCEPTION"


	$$SST	DBG,ODD,1	;"ODD ADDRESS" ERROR


	$$SST	DBG,SEG,2	;"SEGMENT FAULT"


	$$SST	DBG,BPT,3	;"BPT" INSTRUCTION OR T-BIT TRAP


	$$SST	DBG,IOT,4	;"IOT" INSTRUCTION


	$$SST	DBG,RES,5	;"RESERVED OR ILLEGAL" INSTRUCTION


	$$SST	DBG,EMT,6	;"NON-RSX EMT" INSTRUCTION


	$$SST	DBG,TRP,7	;"TRAP" INSTRUCTION
 
 
	$$SST	DBG,FLT,8.	;"11/40 FLOATING POINT EXCEPTION"
 
 
TS2ODD:	CLR	NEWSST		;PROVES USE OF NEW VECTOR TABLE
	BR	TSKODD		;BRANCH TO NORMAL SST SERVICE
 
 
DB2ODD:	CLR	NEWSST		;PROVES USE OF NEW VECTOR TABLE
	BR	DBGODD		;BRANCH TO NORMAL SST SERVICE


;
; THIS IS THE COMMON RETURN FOR ALL SST'S
;

RTNSST:	CMP	SP,STKPNT	;STACK POINTER SHOULD MATCH THE ...
	BNE	STKERR		;... EXPECTED ADDRESS--ELSE, ERROR
	CMP	(SP),SSTADR	;THEN, TOP OF STACK SHOULD MATCH ...
	BNE	ADRERR		;... PROPER RETURN ADDR--ELSE, ERROR
SSTRTN:	CLR	SSTNUM		;THIS INDICATES SST WAS SERVICED
	BIC	#TBIT,2(SP)	;CLEAR T-BIT IN RETURN PS WORD
	RTI			;EXIT FROM SST
	.PAGE
;
; THE FOLLOWING ROUTINES ARE CALLED DURING SST TRAP HANDLING TO
; VERIFY THE CONTENTS OF THE STACK IMMEDIATELY FOLLOWING THE
; SST.  FOR THE "SEGMENT FAULT" THIS JUST MEANS REMOVING THE
; PROPER NUMBER OF ARGUMENTS FROM THE STACK.  HOWEVER, FOR THE
; "NON-RSX EMT" AND "TRAP" FAULTS, THIS ALSO INCLUDES CHECKING
; THE TOP WORD OF THE STACK FOR AN EXPECTED VALUE.
;
;
SEGCK:	ADD	#6.,SP		;POP THREE WORDS FROM STACK
	BR	RTNSST		;BRANCH FOR COMMON SST EXIT
 
 
	.ENABL	LSB
 
EMTCK:	MOVB	#1,-(SP)	;PUT EXPECTED 'EMT' VALUE ON STACK
	BR	100$		;BRANCH INTO COMMON CHECKING CODE
 
TRPCK:	MOVB	#200,-(SP)	;PUT EXPECTED 'TRAP' VALUE ON STACK
 
100$:	CLRB	1(SP)		;CLEAR HIGH BYTE OF VALUE WORD
	ASL	(SP)		;MULTIPLY VALUE BY TWO
	CMP	(SP),2(SP)	;COMPARE W/ RECEIVED VALUE
	BNE	200$		;BRANCH IF THEY DON'T MATCH
	ADD	#4,SP		;ELSE, CLEAN UP THE STACK
	BR	RTNSST		;BRANCH TO COMMON SST EXIT CODE
 
200$:	CALL	.IDOUT		;FORM STEP IDENTIFICATION
	MOV	#LEM09,R1	;PUT FORMAT ADDRESS IN R1
	MOV	#SSTNUM,R2	;POINT R2 TO SST NUMBER
	CALL	$EDMSG		;FORM NEXT PART OF MESSAGE
	MOV	#VAL08,R1	;PUT FORMAT ADDRESS IN R1
	BR	COMMSG		;USE COMMON CODE TO FORM & PRINT MESSAGE
 
	.DSABL	LSB
	.PAGE
;
;
;		'NUMERR'
;
; THIS ROUTINE IS USED TO SEND AN ERROR MESSAGE TO REPORT A BAD SST.
;
NUMERR:	CALL	.IDOUT		;SETUP STEP IDENTIFICATION
	MOV	#LEM02,R1	;PUT ADDR OF FORMAT IN R1
	MOV	SSTNUM,-(SP)	;PUT DESIRED SST NUMBER IN STACK
	MOV	SP,R2		;PUT ADDR OF ARG LIST IN R2
	CALL	.PRTMG		;CREATE REST OF MESSAGE & SEND IT
	CMP	(SP)+,(SP)+	;CLEAN STACK (MSG ARG AND SST NUMBER)
	JMP	RTNSST		;BRANCH TO EXIT THE SST

;
;		'STKERR'
;
; THIS ERROR REPORTING ROUTINE IS CALLED WHEN IT HAS BEEN DETERMINED
; THAT THE NUMBER OF ARGUMENTS PLACED ON THE STACK FOLLOWING AN
; SST ARE INCORRECT.
;
;
STKERR:	MOV	STKPNT,-(SP)	;PUT EXPECTED SP ADDRESS ON STACK
	SUB	SP,(SP)		;CALCULATE THE NUMBER OF BYTES ...
	SUB	#2,(SP)		;... BY WHICH THE STACKS DIFFER
	ASR	(SP)		;CONVERT THAT TO NUMBER OF WORDS
	MOV	#LEM07,-(SP)	;PUT FORMAT ADDRESS ON STACK
	BR	COMERR		;REPORT ERROR THROUGH COMMON CODE
 
;
;		'ADRERR'
;
; THIS SUBROUTINE IS USED TO REPORT AN ERROR WHEN IT HAS BEEN
; DETERMINED THAT THE ADDRESS LEFT ON THE STACK WHEN RETURNING
; FROM AN SST TRAP HANDLER IS NOT THE PROPER RETURN ADDRESS.
;
;
ADRERR:	MOV	SSTADR,-(SP)	;PUT PROPER RETURN ADDRESS ON STACK
	MOV	#LEM08,-(SP)	;PUT FORMAT ADDRESS ON STACK
 
COMERR:	CALL	.IDOUT		;ASSEMBLE STEP IDENTIFICATION
	MOV	(SP)+,R1	;PUT FORMAT STRING ADDRESS IN R1
	MOV	SSTNUM,-(SP)	;PUT SST NUMBER ON STACK
 
COMMSG:	MOV	SP,R2		;POINT R2 TO ARGUMENT LIST
	CALL	.PRTMG		;FORMAT REST OF MESSAGE AND PRINT
	MOV	STKPNT,SP	;RESTORE SP TO PROPER ADDRESS
	MOV	SSTADR,(SP)	;RESTORE PROPER RETURN ADDRESS
	BR	SSTRTN		;RETURN THROUGH COMMON SST EXIT CODE
	.PAGE
;
;		'TSKMOD'
;
; THIS SUBROUTINE IS USED TO INSURE THAT THE TEST WAS IN TASK SST MODE
; AT THE TIME IT USED A TASK SST ENTRY ADDRESS.
;
;
TSKMOD:	TST	SSTMOD		;EXAMINE SST MODE WORD (CLR=TASK MODE)
	BEQ	RTNMOD		;IF CLEAR (O.K.) BRANCH TO RETURN
	MOV	#LEM04,-(SP)	;PUT ADDR OF ERROR FORMAT IN  STACK
	BR	MODERR		;AND BRANCH TO OUTPUT THE ERROR

;
;		'DBGMOD'
;
; THIS SUBROUTINE IS USED TO INSURE THAT THE TEST WAS IN DEBUGGING-AID
; MODE AT THE TIME IT USED A DEBUGGING-AID SST ENTRY ADDRESS.
;
;
DBGMOD:	TST	SSTMOD		;EXAMINE SST MODE WORD (SET=DEBUG MODE)
	BNE	RTNMOD		;IF SET BRANCH TO RETURN
	MOV	#LEM05,-(SP)	;ELSE, PUT ADDR OF ERROR FORMAT IN STK
MODERR:	CALL	.IDOUT		;CREATE STEP IDENTIFICATION
	MOV	#LEM03,R1	;PUT FORMAT ADDR IN R1
	MOV	#SSTNUM,R2	;PUT ADDR OF ARGUMENT IN R2
	CALL	$EDMSG		;CREATE MORE OF THE MESSAGE
	MOV	(SP)+,R1	;PUT LAST FORMAT ADDR IN R1
	JMP	.PRTMG		;CREATE REST OF MESSAGE & PRINT IT
RTNMOD:	RETURN			;RETURN TO THE SST
	.PAGE
;
;		'CHKSST'
;
; THIS SUBROUTINE IS USED TO CHECK WHETHER AN SST WAS GENERATED AND
; HANDLED PROPERLY.  TO DO THIS, LOCATION 'SSTNUM' IS TESTED.  AN ERROR
; MESSAGE IS PRINTED IF A BAD CONDITION IS DETECTED.
;
;
CHKSST:	TST	SSTNUM		;SST HANDLERS SHOULD CLEAR THIS LOCATION
	BEQ	1$		;IF CLEAR, BRANCH TO RETURN
	CALL	.IDOUT		;ELSE, SETUP STEP IDENTIFICATION
	MOV	#LEM01,R1	;PUT ADDR OF FORMAT IN R1
	MOV	#SSTNUM,R2	;PUT ADDR OF ARGUMENT IN R2
	CALL	.PRTMG		;CREATE REST OF MESSAGE & PRINT IT
	SEC			;INDICATE ERROR
1$:	RETURN			;RETURN TO TEST
 
 
;
;		'CHKNEW'
;
; THIS SUBROUTINE IS USED TO CHECK WHETHER OR NOT A RE-SPECIFIED
; SST VECTOR TABLE WAS USED.  IT CAN TELL BY TESTING 'NEWSST',
; WHICH IS CLEARED BY NEW SST SERVICE ROUTINES.
;
;
CHKNEW:	CALL	CHKSST		;FIRST CHECK FOR SST ACTION
	BCS	1$		;IF NONE, BRANCH TO LEAVE
	TST	NEWSST		;NOW TEST IF NEW VECTOR WAS USED
	BEQ	1$		;BRANCH TO LEAVE IS O.K.
	CALL	.IDOUT		;ELSE, SETUP STEP IDENTIFICATION
	MOV	#LEM06,R1	;PUT FORMAT ADDR IN R1
	CALL	.PRTMG		;CREATE REST OF MESSAGE AND PRINT
1$:	RETURN			;RETURN TO THE TESTING

; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


	.END	STP0
