	.TITLE	TSTREJ
	.IDENT	/V03000/
	.PSECT	TSTREJ
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; VERSION  1.03
;
; WRITTEN BY CLARK A. D'ELIA, OCTOBER 1972
;
; MODIFIED BY:
;	C.A. D'ELIA	AUGUST 1974 (FOR RSX-11M)
;	THOMAS J MILLER	7/15/75 (ELIMINATE Z ERROR)
;	L. D. JONES 02/02/78 (FOR VAX-11/VMS)
;	R.A. BATOR   08-NOV-78  (CHANGE BEGIN,END MSG ID TO RSXTST11M)
;
;+
;
; THIS ROUTINE IS THE SERVICE ROUTINE WRITTEN TO HANDLE THE CASES WHERE
; A DIRECTIVE IS REJECTED.  WHEN A DIRECTIVE CALL IS EXPANDED BY A MACRO
; CALL, THE USER HAS THE OPTION OF SPECIFYING AN ERROR SERVICE ADDRESS.
; WHEN ONE IS SPECIFIED, A 'JSR PC,ADDR' IS GENERATED TO HANDLE THE
; ERROR. THIS ROUTINE ORGANIZES ALL OF THE INFORMATION AVAILABLE ABOUT
; THE DIRECTIVE AND ATTEMPTS TO NOTIFY THE USER AT TI:.  IN THE EVENT
; A DIRECTIVE REJECTION OCCURS IN THIS ROUTINE, IT IS CONSIDERED TO BE
; FATAL, AND IT IS HANDLED BY 'JSR PC,FATAL'.  THIS ROUTINE PLACES THE
; STATUS OF THE FAILING DIRECTIVE IN LOCATION '.EIB+14.', THE PC OF
; THE DIRECTIVE'S JSR IN LOCATION '.EIB+16.', AND THE DIC (ALREADY IN
; LOCATION '.EIB')  IN LOCATION '.EIB+12'. THEN THE DIC, PC, AND
; DS ARE ALL CONVERTED INTO DECIMAL REPRESENTATION AND STORED IN A
; MESSAGE TO BE SENT TO TI:.  CONTROL IS RETURNED TO THE TEST TASK
; FOLLOWING THE 'JSR' INSTRUCTION.  THEN THE PS C-BIT IS SET ON EXIT.
;
;-
 
	.MCALL	EXIT$S,QIO$C,QIO$,WTSE$,CALL,RETURN,DECL$S
 
;
; LOCAL (AND GLOBAL) ASSIGNMENTS
;
 
CR=15				;CARRIAGE RETURN
LF=12				;LINE FEED
 
.MGFLG == 24.			;EVENT FLAG USED IN MESSAGE I/O
 

;
;
; LOCAL (AND GLOBAL) DATA
;
;
 
;
; THE 'ERROR INFORMATION BLOCK'
;
.EIB::	.WORD	0		;'DIC' OF LAST DIRECTIVE
	.WORD	0		;'DS' OF ERROR HANDLER DIRECTIVE
	.WORD	0		;ERROR HANDLER 'PC'
	.WORD	0		;TEST NUMBER
	.WORD	.EIB+18.	;POINTER TO SUBTEST LETTER
	.WORD	0		;STEP NUMBER
	.WORD	0		;'DIC' OF PROGRAM DIRECTIVE
	.WORD	0		;'DS' OF PROGRAM DIRECTIVE
	.WORD	0		;PROGRAM 'PC'
	.WORD	0		;SUBTEST LETTER
 
 
.OBUF::	.BLKW	100.		;200. CHARACTER OUTPUT BUFFER
 
	.NLIST	BEX
 
.GMG01::.ASCIZ	<CR><LF>/UETP-E-GMG01, *** TEST %O: SUBTEST-%A: STEP %O  /
 
LEM01:	.ASCIZ	<CR><LF>/UETP-E-LEM01, DIRECTIVE FAILURE!%NDIC: %D., DS: %D./

LEM02:	.ASCIZ	<CR><LF>/UETP-E-LEM02, ***** CRUCIAL STEP FAILURE -- TEST %O  HALTED *****/
 
 
LEM03:	.ASCII	<CR><LF>/UETP-E-LEM03, ERROR IN DIRECTIVE STATUS%N/
	.ASCIZ	<CR><LF>/-UETP-E-LEM03, DIC: %D., EXP'D: %D., RCV'D: %D./
 
LEM04:	.ASCIZ	<CR><LF>/UETP-E-LEM04, C-BIT NOT SET AS EXPECTED%NDIC: %D., DS: %D./
 
LMG01:	.ASCIZ	<CR><LF>/UETP-I-BEGIN, RSXTST11M BEGINNING TEST  %O/<LF>
 
LMG02:	.ASCIZ	<CR><LF>/UETP-I-ENDED, RSXTST11M ENDING  TEST %O/<LF><LF>
 
	.LIST	BEX
	.PAGE
	.PSECT	$DPB$$
 
;
; THIS PSECT CONTAINS ONLY DPB'S.
;
 
.MGDPB::QIO$	IO.WVB,TI,.MGFLG,,,,<.OBUF,0,40>
 
 
.WTMGF::WTSE$	.MGFLG
	.PAGE
	.PSECT	TSTREJ
	.EVEN
SETREJ:	MOV	R1,-(SP)	;SAVE R1 AND R2
	MOV	R2,-(SP)
	MOV	4(SP),-(SP)	;PUT RETURN ADDRESS IN STACK
	MOV	R0,6(SP)	;SAVE R0
	MOV	#.EIB+12.,R2	;USE R2 AS A POINTER INTO '.EIB'
	MOV	.EIB,(R2)+	;PUT FAILING 'DIC' IN .EIB+12.
	MOV	@#$DSW,(R2)+	;PUT DIRECTIVE STATUS (DS) IN .EIB+14.
	MOV	8.(SP),(R2)+	;PUT PROGRAM 'PC' IN .EIB+16.
	CALL	.IDOUT		;CREATE OUTPUT OF STEP IDENTIFICATION
	RETURN			;RETURN
 
 
 
.RJCT::	CALL	SETREJ		;SAVE ERROR INFO AND SETUP STEP INFO
	MOV	#LEM01,R1	;PUT ADDR OF FORMAT IN R1
REJMSG:	MOV	#.EIB+12.,R2	;PUT ADDR OF ARG LIST IN R2
	CALL	$EDMSG		;CREATE OUTPUT OF ERROR INFORMATION
RTNREJ:	SUB	#.OBUF,R0	;DETERMINE THE LINE LENGTH
	MOV	R0,.MGDPB+Q.IOPL+2 ;PUT BYTE COUNT IN DPB
	MOV	#40,.MGDPB+Q.IOPL+4 ;PUT CARRIAGE CONTROL IN DPB
	DIR$	#.MGDPB,FATAL	;INVOKE QIO
	DIR$	#.WTMGF,FATAL	;AND WAIT
	MOV	#.EIB+12.,R2	;USE R2 AS A POINTER IN '.EIB'
	CLR	(R2)+		;WIPE OUT INFO REGARDING FAILING DIRECTIVE
	CLR	(R2)+		;
	CLR	(R2)+		;
	MOV	(SP)+,R2	;RESTORE THE REGISTERS
	MOV	(SP)+,R1
	MOV	(SP)+,R0
	SEC			;SET PS C-BIT TO INDICATE ERROR
REJRTN:	RETURN			;RETURN BACK TO THE TEST
 
 
;+
;
; THERE ARE TIMES WHEN A USER WANTS A DIRECTIVE TO FAIL. THIS ROUTINE ALLOWS
; THAT TO OCCUR AND BE TREATED IN A SPECIAL WAY.  THE USER SPECIFIES THE
; EXPECTED ERROR STATUS IN R1 BEFORE CALLING THE DIRECTIVE.  THEN THIS
; ADDRESS IS SPECIFIED TO HANDLE ERRORS.  THIS ROUTINE COMPARES THE
; EXPECTED AND RETURNED ERROR STATUS.  IF THEY AGREE, CONTROL IS RETURNED
; TO THE USER PROGRAM WITH THE C-BIT CLEARED.  OTHERWISE, CONTROL IS GIVEN
; TO THE NORMAL ERROR HANDLER '.RJCT'.
;
;-
 
.FAIL::	BCS	.STAT		;IF C-BIT OK (SET), CHECK DESIRED STATUS
	CALL	SETREJ		;SAVE ERROR INFO AND SETUP STEP INFO
	MOV	#LEM04,R1	;PUT FORMAT STRING ADDR IN R1
	BR	REJMSG		;REPORT ERROR AND RETURN VIA COMMON CODE
 
	.ENABL	LSB
 
.SUCC::	BCS	REJRTN		;JUST RETURN IF C-BIT IS SET
	CMP	#IS.SUC,@#$DSW	;CHECK FOR NORMAL SUCCESS RETURN STATUS
	BEQ	REJRTN		;JUST REUTRN IF O.K.
	MOV	#IS.SUC,R1	;ELSE, INDICATE SUCCESS CODE DESIRED
	BR	1$		;USE COMMON CODE TO REPORT ERROR
 
.STAT::	CMP	@#$DSW,R1	;COMPARE THE EXPECTED WITH RETURNED STATUS
	BEQ	REJRTN		;JUST RETURN IF THEY MATCH
1$:	CALL	SETREJ		;SAVE ERROR INFO AND SETUP STEP INFO
	MOV	#LEM03,R1	;PUT FORMAT ADDR IN R1
	MOV	@#$DSW,-(SP)	;PUT CURRENT DSW IN STACK
	MOV	4(SP),-(SP)	;PUT EXP'D DSW IN STACK
	MOV	.EIB,-(SP)	;PUT CURRENT DIC IN STACK
	MOV	SP,R2		;PUT ADDR OF ARG LIST IN R2
	CALL	$EDMSG		;CREATE THE MESSAGE
	ADD	#6,SP		;CLEAN THE STACK
	BR	RTNREJ		;BRANCH TO PRINT MESSAGE AND LEAVE
 
	.DSABL	LSB
 
 
;+
;
; THIS ROUTINE IS ENTERED WHEN A DIRECTIVE REJECTION OCCURRED WHILE IN
; THE DIRECTIVE REJECTION ERROR SERVICE ROUTINE.  IT PLACES THE
; FAILING DIRECTIVE STATUS IN LOCATION '.EIB+4', THE PC OF THE DIRECTIVE
; 'EMT' IN LOCATION '.EIB+2', AND THE ADDRESS OF THE '.EIB' IN VIRTUAL
; LOCATION ZERO.  THEN IT PLACES THE FOLLOWING INFORMATION IN REGISTERS
; R0 THROUGH R5:
; 		R0 - ADDRESS OF ERROR INFORMATION BLOCK,
;		R1 - FATAL 'DIC',
;		R2 - FATAL 'DS',
;		R3 - TASK STEP NUMBER,
;		R4 - TASK 'DIC',
;		R5 - TASK 'DS'.
;
; THEN A HALT COMMAND IS ATTEMPTED TO ABORT THE TASK.
;
;-
FATAL:	MOV	@#$DSW,.EIB+2	;PUT FAILING DS IN .EIB+2.
	MOV	@SP,.EIB+4	;PUT ADDR OF 'JSR' IN .EIB+4.
	MOV	#.EIB,R0	;PUT ADDR OF '.EIB' IN R0
	MOV	R0,@#$DSW	;PUT .EIB ADDR IN TASK DSW
	MOV	(R0),R1		;PUT FATAL 'DIC' IN R1
	MOV	2(R0),R2	;PUT FATAL 'DS' IN R2
	MOV	10.(R0),R3	;PUT TASK STEP NUMBER IN R3
	MOV	12.(R0),R4	;PUT TASK 'DIC' IN R4
	MOV	14.(R0),R5	;PUT TASK 'DS' IN R5
;
	BPT			;TERMINATE TASK (NOTE GLOBAL SYMBOL)
.CRASH::


 
;+
;
; THIS SHORT ROUTINE WILL CREATE AN OUTPUT LINE IN '.OBUF' CONTAINING THE
; STEP IDENTIFICATION INFORMATION (TEST, SUBTEST, & STEP NUMBERS) IN THE
; FORMAT STRING '.GMG01'.  WHEN IT RETURNS, R0 POINTS TO THE LAST CHARACTER
; PLACED IN THE BUFFER, R1 POINTS TO THE END OF THE FORMAT STRING, AND R2 POINTS
; TO '.EIB+12.'.
;
;-
.IDOUT::MOV	#.OBUF,R0	;PUT ADDR OF OUTPUT BUFFER IN R0
	MOV	#.GMG01,R1	;PUT ADDR OF 'STEP ID' FORMAT IN R1
	MOV	#.EIB+6,R2	;PUT ADDR OF ARG LIST IN R2
	CALL	$EDMSG		;CREATE OUTPUT OF STEP IDENTIFICATION
	RETURN			;THEN RETURN
 
;+
;
; THIS SHORT ROUTINE IS USED ONLY BY THE TEST PROGRAMS WHEN THE TEST STARTS OR
; ENDS.  ALL THAT IS DONE, IS THAT A MESSAGE IS SENT STATING THE APPROPRIATE
; STAGE OF EXECUTION ALONG WITH THE IDENTIFYING TEST NUMBER.
;
;-
.STST::	MOV	#LMG01,R1	;PUT ADDR OF 'START' FORMAT IN R1
	BR	OUTLIN		;AND SKIP
.ETST::	MOV	#LMG02,R1	;PUT ADDR OF 'END' FORMAT IN R1
OUTLIN:	MOV	#.OBUF,R0	;PUT ADDR OF OUTPUT BUFFER IN R0
	MOV	#.EIB+6,R2	;PUT ADDR OF TEST NUMBER IN R2
	CALL	.PRTMG		;CREATE MESSAGE AND PRINT
	RETURN			;RETURN TO THE TEST PROGRAM


;+
;
; THIS SHORT ROUTINE IS USED BY THE TEST PROGRAMS TO ABORT THE
; TEST TASK.  IT WAS DETERMINED BY THE AUTHOR THAT THE DIRECTIVE
; FAILURE THAT OCCURRED WAS CRUCIAL TO THE TEST SYSTEM.  THERE-
; FORE, THE TASK IS BEING ABORTED AND A MESSAGE WILL BE SENT TO
; TT0.
;
;-
.ABORT::CALL	.RJCT		;FIRST REPORT THE STANDARD ERROR INFO
	MOV	#.OBUF,R0	;PUT ADDR OF OUTPUT BUFFER IN R0
	MOV	#LEM02,R1	;PUT ADDR OF 'ABORT' FORMAT IN R1
	MOV	#.EIB+6,R2	;PUT ADDR OF TEST NUMBER IN R2
	CALL	$EDMSG		;CREATE OUTPUT LINE
	SUB	#.OBUF,R0	;CALCULATE LENGTH OF OUTPUT
	MOV	R0,.MGDPB+Q.IOPL+2 ;PUT BYTE COUNT IN DPB
	MOV	#'0,.MGDPB+Q.IOPL+4 ;PUT CARRIAGE CONTROL IN DPB
	DIR$	#.MGDPB,FATAL	;INVOKE QIO
	DIR$	#.WTMGF,FATAL	;AND WAIT
	EXIT$S	FATAL		;THEN EXIT

;+
;
; THIS SHORT SUBROUTINE IS USED TO ELIMINATE REPETITIVE CODE TO OUTPUT
; A MESSAGE TO TT0.  IT ASSUMES THAT THE USER WANTED '.OBUF' AS THE OUTPUT
; BUFFER AND '.MGDPB' AS THE QUEUE I/O DPB.  THE USER IS EXPECTED TO SET UP
; TO CALL '$EDMSG' AND CALL THIS ROUTINE INSTEAD.
;
;-
.PRTMG::CALL	$EDMSG		;CREATE OUTPUT LINE
	SUB	#.OBUF,R0	;CALCULATE THE BYTE COUNT, AND
	MOV	R0,.MGDPB+Q.IOPL+2 ;STORE IT IN THE DPB
	DIR$	#.MGDPB,.RJCT	;INVOKE THE QIO
	DIR$	#.WTMGF,.RJCT	;AND WAIT FOR I/O DONE
	RETURN			;RETURN TO THE USER
 
 
;+
;
; THIS ROUTINE IS CALLED BY THE TEST THAT MUST KNOW WHETHER OR NOT
; THE SYSTEM UPON WHICH IT IS RUNNING SUPPORTS ADDRESS CHECKING.  IF
; THE SYSTEM IS MAPPED, THEN ADDRESS CHECKING IS SUPPORTED.  OTHERWISE,
; A QUEUE I/O TO THE TELETYPE WITH AN UNSUPPORTED TTY FUNCTION BUT
; WITH AN I/O STATUS BLOCK ADDRESS THAT IS WITHIN THE TASK HEADER.  IF
; IT FAILS WITH THE CODE "IE.ADP" THEN ADDRESS CHECKING IS SUPPORTED.
; A RETURN OF C-BIT CLEAR INDICATES ADDRESS CHECKING IS SUPPORTED.
;
;-
ADRLIM:	.LIMIT			;TASK BUILDER RETURNS TASK ADDRESS LIMITS
 
 
	.ENABL	LSB
 
$ADCHK::CMP	#10000,PC	;EXAMINE THE TASK 'PC'
	BHI	200$		;SKIP IF THIS IS A MAPPED SYSTEM
	MOV	ADRLIM,-(SP)	;PUT ADDR OF STACK BOTTOM IN STACK
	SUB	#8.,(SP)	;POINT INTO TASK GUARD AREA
	MOV	(SP)+,QIOACK+Q.IOSB  ;USE IT AS I/O STATUS ADDR
	QIO$C	IO.RWD,TI,,,,,,TSTREJ
QIOACK=$$$
	BCC	100$		;SUCCESS--NO ADDRESS CHECK MADE
	CMP	@#$DSW,#IE.ADP	;FAILURE--WAS IT DUE TO ADDRESS CHECK?
	BEQ	200$		;YES, RETURN SUCCESS
100$:	SEC			;INDICATE NO ADDRESS CHECKING
	BR	300$		;SKIP TO RETURN
200$:	CLC			;INDICATE ADDRESS CHECKING SUPPORTED
300$:	RETURN
 
	.DSABL	LSB
 
 

 

; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


	.END
