MODULE PATENC (
		%IF %VARIANT EQL 1
		%THEN
			ADDRESSING_MODE (EXTERNAL = LONG_RELATIVE, NONEXTERNAL = LONG_RELATIVE),
		%FI
		IDENT = 'V03-001'
	      ) =
BEGIN

!++
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!--

!++
! FACILITY:	PATCH
!	VAX INSTRUCTION ENCODER.
!
! Version:	V03-001
!
! History:
!	Author:
!		Kevin Pammett, April 1977: Version 01
!
! MODIFIED BY:
!
!	V03-001	MTR0004		Michael T. Rhodes	24-MAR-1982
!		Fix endless loop conditions in routine GET_OPERAND,
!		within loops located at OPERATOR_CODE and at GET_PATHNAME,
!		which were caused by not advancing the instruction string
!		pointer.  Fixes SPR #11-43576.
!
!	V02-022	KDM0052		Kathleen D. Morse	28-APR-1981
!		Fix bug that found any address ending in 2D illegal.
!
!	V02-021	PCG0001		Peter George		02-FEB-1981
!		Add require statement for LIB$:PATDEF.REQ
!
!
!--

FORWARD ROUTINE
	PAT$INS_ENCODE,						! Encode an instruction
	GET_NEXT_TOKEN,						! Extract next token from input stream.
	GET_LABEL : NOVALUE,					! Extracts a label from instruction string if one exists
	GET_OPCODE,						! Extract opcode from instruction string.
	GET_OPERAND,						! Acquires a lexical operand
	ENC_OPERAND,						! Encode an operand reference.
	ASSUME_AT_PC,						! Temporary 'look ahead' routine
								!  to implement <operand> ::= <number>
	INST_OUTPUT,						! Output bytes of instruction.
	OPCODE_MATCH,						! Find opcode in OPINFO table.
	MAR_GET_LEX,						! Gets a MARS lexeme
	ADD_LEX_T_OPRND : NOVALUE,				! Annexes a lexical string onto an operand string
	PAT$REDUCE_INS : NOVALUE,				! Reduces expressions and symbols in instructions for command output
	PAT$RESOLVE_INS : NOVALUE;				! Resolves forward references for command

LIBRARY 'SYS$LIBRARY:LIB.L32';
REQUIRE 'SRC$:SYSLIT.REQ';
REQUIRE 'SRC$:VXSMAC.REQ';
REQUIRE 'SRC$:PATGEN.REQ';
REQUIRE 'SRC$:PATPCT.REQ';
REQUIRE 'SRC$:PATTER.REQ';
REQUIRE 'SRC$:PATTOK.REQ';
REQUIRE 'SRC$:VAXOPS.REQ';					! Literals and macros related to opcodes
REQUIRE 'LIB$:PATDEF.REQ';				! Defines literals
REQUIRE 'LIB$:PATMSG.REQ';					! PATCH error reporting
REQUIRE 'SRC$:SYSSER.REQ';					! Macros for diagnostic output.
REQUIRE 'SRC$:PREFIX.REQ';					! Define structure macro
REQUIRE 'SRC$:PATPRE.REQ';					! Defines ASD structure
REQUIRE 'SRC$:BSTRUC.REQ';
REQUIRE 'SRC$:DLLNAM.REQ';

EXTERNAL ROUTINE
	PAT$BUILD_PATH,						! Builds a path name structure
	PAT$DELETE_PATH : NOVALUE,				! Deletes a path name structure
	PAT$DEFINE_SYM,						! Defines a user symbol
	PAT$FILL_BUF : NOVALUE,					! Routine to allocate and fill a buffer
	PAT$FIND_SYM,						! Find symbol in a doubly-linked symbol table
	PAT$FIND_VAL,						! Find value for symbol in a doubly-linked symbol table
	PAT$FREERELEASE : NOVALUE,				! Deallocates free storage
	PAT$FREEZ,						! Allocates and zeros some free storage
	PAT$SUBST_INS,						! Routine to create branch instruction substitutes
	RAD50,							! Routine to convert ASCII to RAD50
	SYS$FAOL : ADDRESSING_MODE(ABSOLUTE),			! System service to do formatted output
	PAT$FAO_PUT : NOVALUE,					! Formatted ASCII output
	PAT$MAR_GET_LEX,					! Lexical scanner
	PAT$OUT_PUT : NOVALUE,					! Actually write out lines to tty
	PAT$REG_MATCH;						! See if a char string is a reference
								!   to a register.

EXTERNAL
	PAT$GL_SYMTBPTR,					! Pointer to current symbol table listhead entry
	PAT$GL_OLDLABLS,					! Pointer to old label table listhead entry
	PAT$GL_TEMP_BUF : BLOCK[,BYTE],				! Temporary instruction buffer
	PAT$GL_BR_DISPL,					! Branch displacement that did not fit
	PAT$GL_CONTEXT : BITVECTOR,				! Context bits for PATCH commands
	PAT$GL_ERRCODE,						! Error code
	PAT$CP_OUT_STR : REF VECTOR[,BYTE],			! Points into output string
	PAT$GB_MOD_PTR : REF VECTOR[,BYTE],
	PAT$GB_OPINFO : OPCODE_TBL,				! General OPcode information structure
	PAT$GB_OPINFO1 : BLOCKVECTOR[SIZOPINFO1,OPTSIZE,BYTE],	! Single byte OPcodes
	PAT$GB_OPINFO2 : BLOCKVECTOR[SIZOPINFO2,OPTSIZE,BYTE],	! Double byte OPcodes
	PAT$GB_ALIAS : BLOCKVECTOR[SIZALIAS,ALTSIZE,BYTE],	! OPcode alias table
	PAT$GL_BUF_SIZ,						! Data vector that describes opcodes
	PAT$GL_FWRLHD;						! Forward reference table listhead

OWN
	BYTES_IN_OPRND;						! Number of encoded bytes in current operand

LITERAL
	PAT$K_BR_RANGE = 2,					! Error code for branch displacement out of range
	MAX_REG		= 15,					! Maximum number of registers - 1
	MAX_BUF_SIZ	= 512,					! Maximum buffer size for pathname and operand string

!++
! Return values for routine GET_OPERAND.
!--
	OPR_FOUND = 1,						! Operand found and successfully reduced
	NO_MORE_OPR = 0,					! No more operands
	OPR_ERROR = 2,						! Expression reduction error found in operand
	OPR_FORW_REF = 3,					! Forward reference inside operand

!++
! Bit masks for operand length indicators:  B^,W^,L^, and [.
! Note that the masks for B^, W^ and L^ are also the number of bytes
! to be included in the operand by these indicators.  [ always indicates
! context indexed and always donates one additional byte.
!--
B_HAT_MASK = 1,							! B^ mask
W_HAT_MASK = 2,							! W^ mask
L_HAT_MASK = 4,							! L^ mask
CONT_INDX_MASK = 8;						! Context indexed mask

GLOBAL ROUTINE PAT$INS_ENCODE( INST_CS, OUT_BYTE_STREAM, OUT_PC, ASM_DIR_TBL, BUFFER_DSC ) =

!++
! 
! FUNCTIONAL DESCRIPTION:
!
!	This routine examines an ascii stream which it is passed a pointer to,
!	and tries to come up with the instruction byte stream this would
!	correspond to.
!
! CALLING SEQUENCE:
!
!	PAT$INS_ENCODE ();
!
! INPUTS:
!
!	INST_CS		- A pointer to the counted string which
!			the user input as the supposed intsruction.
!
!	OUT_BYTE_STREAM	- The address of where to put the
!			  counted instruction stream genereated.
!	OUT_PC		- The PC (memory address) where the instruction
!			  will eventually reside.  This is used only for
!			  PC-relative address calculations.
!	ASM_DIR_TBL	- Address of descriptor for assembler directive table.
!	BUFFER_DSC	- String descriptor for current encoded instruction buffer.
!
! IMPLICIT INPUTS:
!
!	PAT$GB_OPINFO	- Data vector which contains the instruction
!			  mnemonics and related information.
!
! OUTPUTS:
!
!	The counted instruction (byte) stream is put in the byte vector
!	pointed to by the input parameter.
!
! IMPLICIT OUTPUTS:
!
!	NONE.
!
! ROUTINE VALUE:
!
!	TRUE or FALSE, depending on whether the encoding
!	'worked' or not.
!
! SIDE EFFECTS:
!
!	None.
!
!--

BEGIN

MAP
	OUT_BYTE_STREAM : REF VECTOR[,BYTE],
	INST_CS : REF VECTOR[,BYTE],
	ASM_DIR_TBL : REF BLOCK[,BYTE],
	BUFFER_DSC : REF BLOCK[,BYTE];

LOCAL
	COUNT,							! Count of bytes in encoded operand
	OPR_FLAG,						! Flag if operand found valid
	ASD_TBL_ENTRY : BLOCK[ASD$C_SIZE, BYTE],		! One entry in assembler directive table
	TOKEN,							! Next token from instruction
	ACT_NUM_OPRNDS,						! Actual number of operands processed
	PC_START,						! PC of start of instruction
	INSTR_STRING : VECTOR[NO_OF_INP_CHARS,BYTE],		! We make our own copy of the instruction
								! string so we don't have to worry about
								! overwriting parts of it.
	INST_STG_DESC : BLOCK [8, BYTE],			! Instruction string descriptor
	OPINFO_PTR : REF BLOCK[ OPTSIZE, BYTE],			! Pointer into the OPINFO table
	OUT_BYTE_PTR : REF VECTOR[,BYTE],			! This pointer contains the address
								!  of where each successive byte of 
								!  instruction is to be placed.
	BRANCH_SIZE,
	OPRNDS,							! Number of operands to expect.
	OPRND_STG_DESC : BLOCK[12,BYTE],			! String descriptor for next operand
	OPRND_BUF : VECTOR[MAX_BUF_SIZ,BYTE],			! Buffer to hold next operand
	OPCODE_NAME : REF VECTOR[,BYTE];			! Pointer to ascii opcode name of instruction

LITERAL
	JMP_OPCODE = %X'17',					! JMP instruction opcode
	JSB_OPCODE = %X'16';					! JSB instruction opcode

!++
! Remember starting PC for instruction in case substitution is required.
!--
PC_START = .OUT_PC;

!++
! Copy the instruction string into a local area so that it won't be overwritten.
! Then put a terminator at the end of it as this will make recognizing the EOS
! easier for the scanner.  Also initialize the pointer to the return buffer.
!--
CH$MOVE( .INST_CS[0] +1, INST_CS[0], INSTR_STRING );
INSTR_STRING [.INSTR_STRING [0] + 1] = 0;
INSTR_STRING [0] = .INSTR_STRING [0] + 1;
INST_STG_DESC [DSC$W_LENGTH] = .INSTR_STRING [0];
INST_STG_DESC [DSC$A_POINTER] = INSTR_STRING [1];
OUT_BYTE_PTR = OUT_BYTE_STREAM[1];

!++
! Check if there is a label on the instruction.  If so, GET_LABEL removes it
! and enters it into the definition table.
!--
GET_LABEL(INST_STG_DESC, .OUT_PC, TRUE);

!++
! Extract the opcode mnemonic from the instruction string and encode the
! corresponding opcode into the output byte stream.  Pass the address of the
! local, OPINFO_PTR, so that GET_OPCODE can initialize this.  This is done in
! this way because it is GET_OPCODE who looks up the opcode (and hence finds
! the OPINFO record), but it is here that the other OPINFO information is
! needed.  GET_OPCODE does not return if the opcode is unrecognized.
!--
OPCODE_NAME = GET_OPCODE( INST_STG_DESC, OUT_BYTE_PTR, OPINFO_PTR, OUT_PC);

!++
! GET_OPCODE has stuffed the opcode into the instruction stream (for all MACRO
! instructions but not assembler directives).  The pointer has been updated so
! that further code will go into successive bytes.
!--
IF (.OPINFO_PTR[OP_NUMOPS] NEQ ASM_DIR_OP)
THEN
	BEGIN

	!++
	! The instruction-stream counted-string pointer now points to the
	! beginning of the operand reference string, if there is one.  This must
	! be the case unless this opcode has no operands.
	!--
	OPRNDS = .OPINFO_PTR [ OP_NUMOPS ];
	END
ELSE
	!++
	! Set a large number of operands as it is unknown how many operands
	! an assembler directive may have.  Also set up an entry in the
	! assembler directive table.  This is for PATCH verification output to
	! the journal file.
	!--
	BEGIN
	OPRNDS = MAXOPRNDS - 1;
	ASD_TBL_ENTRY[ASD$L_PC] = .OUT_PC;
	ASD_TBL_ENTRY[ASD$L_OPINFO] = .OPINFO_PTR;
	ASD_TBL_ENTRY[ASD$B_NUM_OPRND] = 0;
	END;

!++
! Loop trying to extract each operand reference.
!--
ACT_NUM_OPRNDS = 1;
WHILE .ACT_NUM_OPRNDS LEQ .OPRNDS
	DO
	BEGIN
	!++
	! Decide what type of branching the following routine will be allowed
	! to use, if any.  This is done now as the OPINFO information is
	! available.   For the same reason, the PC-relative context information
	! is passed.  Start by assuming the usual case.
	! All assembler directive operands are handled as a special case.
	! The number of bytes to be encoded is the OP_BR_TYPE value.
	!--
	BRANCH_SIZE = NO_BR;
	IF (.ACT_NUM_OPRNDS EQL .OPRNDS) OR (.OPINFO_PTR[OP_NUMOPS] EQL ASM_DIR_OP)
	THEN
		!++
		! Branching can only be considered for the last operand of an
		! instruction which has less than the maximum number of
		! operands.  This assumption was made in constructing the
		! data structure (OPINFO) from which encoding (and decoding)
		! works.  See PATINS.B32 for more information.
		!--
		IF (.ACT_NUM_OPRNDS LSS MAXOPRNDS) OR (.OPINFO_PTR[OP_NUMOPS] EQL ASM_DIR_OP)
		THEN
			BEGIN
			BRANCH_SIZE = .OPINFO_PTR[OP_BR_TYPE];
			IF (.BRANCH_SIZE EQLU BR_LG)
			THEN
				BRANCH_SIZE = A_LONGWORD;
			END;

	!++
	! Preprocess the operand, evaluating all expressions and symbols.
	!--
	OPRND_STG_DESC[DSC$W_LENGTH] = 0;
	OPRND_STG_DESC[DSC$A_POINTER] = OPRND_BUF;
	OPRND_STG_DESC[DSC$W_MAXLEN] = MAX_BUF_SIZ;
	IF NOT (OPR_FLAG = GET_OPERAND( INST_STG_DESC, OPRND_STG_DESC, TRUE))
	THEN
		BEGIN
		IF (.OPR_FLAG EQLU OPR_ERROR)
		THEN
			RETURN(FALSE);				! Invalid expression
		IF (.OPINFO_PTR[OP_NUMOPS] EQL ASM_DIR_OP)
		THEN
			EXITLOOP				! An assembler directive has indeterminate # of operands
		ELSE
			BEGIN
			SIGNAL(PAT$_INSOPRND+MSG$K_INFO);
			RETURN(FALSE);				! Insufficient operands
			END;
		END;

	!++
	! Check for forward referenced symbol.  If this is the case,
	! update the pointers past this operand and create an entry
	! in the ForWard Reference table for this operand.
	!--
	IF (.OPR_FLAG EQLU OPR_FORW_REF)
	THEN
		BEGIN
		LOCAL
			POINTER : REF BLOCK[,BYTE];
		POINTER = PAT$FREEZ((FWR$C_SIZE + A_LONGWORD -1)/A_LONGWORD);
		POINTER[FWR$L_FLINK] = .PAT$GL_FWRLHD;
		PAT$GL_FWRLHD = .POINTER;
		POINTER[FWR$L_PC] = .OUT_PC;
		POINTER[FWR$B_BUFOFF] = .BUFFER_DSC[DSC$W_LENGTH] +
					.OUT_BYTE_PTR - OUT_BYTE_STREAM[1];
		POINTER[FWR$W_OPRNDLNG] = .OPRND_STG_DESC[DSC$W_LENGTH];
		POINTER[FWR$A_OPRNDADR] = INST_CS[1] +
					(.OPRND_STG_DESC[DSC$A_POINTER] - INSTR_STRING[1]);
		POINTER[FWR$A_OPINFO] = .OPINFO_PTR;
		COUNT = 0;
		IF ((COUNT = .BYTES_IN_OPRND AND CONT_INDX_MASK) NEQ 0)
		THEN
			BEGIN
			COUNT = 1;
			BYTES_IN_OPRND = .BYTES_IN_OPRND - CONT_INDX_MASK;
			END;
		IF ((.OUT_BYTE_STREAM[1] EQL JMP_OPCODE) OR
		   (.OUT_BYTE_STREAM[1] EQL JSB_OPCODE))
		THEN
			BYTES_IN_OPRND = L_HAT_MASK;
		IF (.BRANCH_SIZE NEQ NO_BR)
		THEN
			COUNT = .BRANCH_SIZE
		ELSE
			COUNT = .COUNT + .BYTES_IN_OPRND + 1;
		POINTER[FWR$B_NUMBYTES] = .COUNT;
		POINTER[FWR$B_NTHOPRND] = .ACT_NUM_OPRNDS;
		OUT_PC = .OUT_PC + .COUNT;
		OUT_BYTE_PTR = .OUT_BYTE_PTR + .COUNT;
		OPRND_STG_DESC[DSC$W_LENGTH] = 0;
		END
	ELSE
		!++
		! Extract and encode one operand reference.  Give up if this fails.
		!--
		BEGIN
		IF NOT (PAT$GL_ERRCODE = ENC_OPERAND( OPRND_STG_DESC, OUT_BYTE_PTR,
				    1 ^ .OPINFO_PTR[ OP_CONTEXT(.ACT_NUM_OPRNDS) ],
				    .BRANCH_SIZE,  OUT_PC, .OPINFO_PTR))
		THEN
			BEGIN
			!++
			! "Operand Syntax" error.  If instruction substution is enabled,
			! then attempt to substitute other instructions for this branch
			! instruction.
			!--
			IF (.PAT$GL_ERRCODE EQL PAT$K_BR_RANGE) AND
			   (.PAT$GL_CONTEXT[INST_SUBST]) AND
			   (.OPINFO_PTR[OP_NUMOPS] NEQ ASM_DIR_OP)	! Don't substitute for assembler directives
			THEN
				BEGIN
				OUT_BYTE_STREAM[0] = .OUT_BYTE_PTR - OUT_BYTE_STREAM[1];
				PAT$SUBST_INS(.OUT_BYTE_STREAM, .PC_START);
				END;
			RETURN(FALSE);
			END;
		END;

	!++
	! Check that the operand was completely used. If not, error.
	!--
	IF (.OPRND_STG_DESC[DSC$W_LENGTH] NEQ 0)
	THEN
		RETURN(FALSE);

	ACT_NUM_OPRNDS = .ACT_NUM_OPRNDS + 1;
	END;

!++
! Check that there are not any extra operands.
!--
OPRND_STG_DESC[DSC$W_LENGTH] = 0;
OPRND_STG_DESC[DSC$A_POINTER] = OPRND_BUF;
OPRND_STG_DESC[DSC$W_MAXLEN] = MAX_BUF_SIZ;
IF GET_OPERAND( INST_STG_DESC, OPRND_STG_DESC, TRUE)
THEN
	BEGIN
	SIGNAL(PAT$_NUMOPRNDS+MSG$K_INFO, 2, .OPCODE_NAME, .OPRNDS); ! Too many operands
	RETURN(FALSE);
	END;

!++
! Calculate the number of bytes in the 'instruction' stream and copy this value
! into the 0th byte of the output vector.  This makes it now a counted byte stream.
!--
OUT_BYTE_STREAM[0] = .OUT_BYTE_PTR - OUT_BYTE_STREAM[1];

!++
! Now if this was an assembler directive.  Compute the number of operands it
! had and enter that into the assembler directive entry.  Then add this entry
! to the assembler directive table.
!--
ACT_NUM_OPRNDS = .ACT_NUM_OPRNDS - 1;
IF (.OPINFO_PTR[OP_NUMOPS] EQL ASM_DIR_OP)
THEN
	BEGIN
	ASD_TBL_ENTRY[ASD$B_NUM_OPRND] = .ACT_NUM_OPRNDS;
	PAT$FILL_BUF(.ASM_DIR_TBL, ASD_TBL_ENTRY, ASD$C_SIZE);
	END;

!++
! This is the only place where this routine returns the OK completion status.
! If some error was encountered, then a message was signaled and an
! UNWIND or RETURN(FALSE) occurred.  The only exception is branch of
! out of range.  In this case instruction substitution has been attempted.
!--
RETURN(TRUE);
END;

ROUTINE GET_NEXT_TOKEN ( INST_STG_DESC, LEX_BUFFER ) =

!++
! Functional Description:
!
!	Scan the input stream and extract the next token from it.  This routine
!	is similar to the one that the parser uses - it is just that this one
!	does a little more, and is a little more selective about what it accepts.
!
! Calling Sequence:
!
!	GET_NEXT_TOKEN (INST_STG_DESC, LEX_BUFFER)
!
! Inputs:
!
!	INST_CS_PTR	-Contains the address of the current instruction
!			 counted-string pointer.  We pick up and update
!			 this pointer via this address.
!	LEX_BUFFER	-A pointer to where we can pass back a value
!			 which is associated with whatever token we
!			 discover.  If this value is 0, we don't
!			 try to pass back anything.
!
! Implicit Inputs:
!
!	PAT$GL_MOD_PTR	- is used by the radix convert routine
!			  to convert numeric input.
!
! Outputs:
!
!	None.
!
! Implicit Outputs:
!
!	Via LEX_BUFFER, we pass back:
!			-a counted byte stream in LEX_BUFFER if the token
!			 is LONG_VAL_TOKEN, WORD_VAL_TOKEN, ABS_LIT_TOKEN,
!			 or BYTE_VAL_TOKEN.  Even though only <count> bytes
!			 of this value are valid as far as operand size is
!			 concerned, the value is written out as a (sign-extended)
!			 longword so that we can do arithmetic on it and worry
!			 about the size only when we want to extract it again.
!			-a REGister number in a 1-byte field of LEX_BUFFER
!			 for REGISTER_TOKEN, INDEXING_TOKEN, or AT_REG_TOKEN.
!			-A 5-byte sequence for BRANCH_TOKEN.  The first byte
!			 of this is 1 => PC-relative type, or 0 => absolute
!			 type.  The remaining 4 bytes are the
!			 longword representation of the branch operand.
!
! Return Value:
!
!	The literal that stands for the token type we have
!	extracted.  This is either one of those mentioned
!	above, or it is BAD_TOKEN.
!--

BEGIN

MAP
	INST_STG_DESC : REF BLOCK [, BYTE],
	LEX_BUFFER : REF VECTOR[,BYTE];

LOCAL
	LEX_STG_DESC : BLOCK [12, BYTE],			! Lexeme string descriptor
	TOKEN_BUFFER : VECTOR[ CHS_PER_LEXEME+1, BYTE ],
	GARBAGE : VECTOR[ CHS_PER_LEXEME, BYTE ],
	INST_CS : REF VECTOR[,BYTE],
	REG_NUM,
	MODE,
	RETURN_PTR,
	TOKEN_TYPE : BYTE;					! The returned value.

MACRO
	PASS_BACK( BYTES, VALUE ) =				! Used to pass back the indicated
		(.RETURN_PTR)<0,BYTES*BITS_PER_BYTE> = VALUE %;	! number of bytes, if requested.

!++
! If a value is associated with the token extracted, this value is returned via
! the pointer, LEX_BUFFER.  If, however, this pointer is 0, then the caller does
! not want such information.  To avoid having to check this several times, then,
! a local pointer, RETURN_PTR, is used to point either to where the user wants
! the value, or to some local garbage location.
!--
IF ((RETURN_PTR = .LEX_BUFFER) EQL 0)
THEN
	RETURN_PTR = GARBAGE;

!++
! Pick up the current instruction counted-string pointer.
!--
LEX_STG_DESC [DSC$W_LENGTH] = 0;
LEX_STG_DESC [DSC$A_POINTER] = TOKEN_BUFFER;
LEX_STG_DESC [DSC$W_MAXLEN] = CHS_PER_LEXEME + 1;

!++
! Extract the next token and take the appropriate action.
!--
TOKEN_TYPE = MAR_GET_LEX(.INST_STG_DESC, LEX_STG_DESC);

!++
! Sometimes a keyword token is returned when the user
! really input a symbolic name of some sort.
!--
IF (.TOKEN_TYPE GTR 0) AND (.TOKEN_TYPE LEQ KEYWORD_RANGE)
THEN
	TOKEN_TYPE = ALPHA_STR_TOKEN;
TOKEN_TYPE = ( SELECTONE .TOKEN_TYPE OF

	SET

	[HASH_TOKEN]:	! '#'
		!++
		! Extract the literal and pass it back.
		!--
		IF (MAR_GET_LEX(.INST_STG_DESC, LEX_STG_DESC) NEQ DIGIT_STR_TOKEN)
		THEN
			BAD_TOKEN
		ELSE
			BEGIN
			PASS_BACK (LONG_LENGTH, .(.LEX_STG_DESC [DSC$A_POINTER]));
			ABS_LIT_TOKEN
			END;


	[AT_SIGN_TOKEN,	! '@', For @#const, @(reg), and @displ(reg)
	 PLUS_TOKEN,	! '+', for (reg)+
	 MINUS_TOKEN,	! '-', For -(sp) Etc.
	 COMMA_TOKEN,	! ',', For arg1, arg2, Etc.
	 EOL_TOKEN ]:	!  LF, Terminates the command line.
		!++
		! Just return the token type directly.
		!--
		.TOKEN_TYPE;


	[DIGIT_STR_TOKEN,		! For branch operands where we interpret
					! the operand as an absolute address.
	 PERIOD_TOKEN]:			! We also handle operands of the
					! form '.' <sign> <number>, where
					! <sign> must be '+' or '-'.

		BEGIN
		LOCAL
			BR_FLAG,NUMBER,SIGN;

		!++
		! In this case we build a token string consisting of a flag byte
		! followed by the branch operand in a longword.  Assume
		! PC-relative type branching.
		!--
		BR_FLAG = 1;

		!++
		! Handling the more-difficult syntax requires more work.
		!--
		SIGN = 0;
		IF (.TOKEN_TYPE EQL PERIOD_TOKEN)
		THEN
			BEGIN
			BR_FLAG = 0;
			SIGN = (
				IF ((TOKEN_TYPE = MAR_GET_LEX(.INST_STG_DESC, LEX_STG_DESC)
						   ) EQL PLUS_TOKEN)
				THEN
					'+'
				ELSE
					IF (.TOKEN_TYPE EQL MINUS_TOKEN )
					THEN
						'-'
					ELSE
						RETURN(BAD_TOKEN)
				);

			!++
			! After the <sign>, a <number> is expected.
			!--
			IF (MAR_GET_LEX(.INST_STG_DESC, LEX_STG_DESC) NEQ DIGIT_STR_TOKEN)
			THEN
				RETURN(BAD_TOKEN);
			END;

		!++
		! Pass back the flag and operand.
		!--
		NUMBER = .(.LEX_STG_DESC [DSC$A_POINTER]);
		IF (.SIGN EQL '-')
		THEN
			NUMBER = - .NUMBER;
		PASS_BACK(BYTE_LENGTH, .BR_FLAG);
		RETURN_PTR = .RETURN_PTR + BYTE_LENGTH;
		PASS_BACK(LONG_LENGTH, .number);
		BRANCH_TOKEN					! Pass back the token type
		END;


	[ALPHA_STR_TOKEN]:		! For now, this must be a register reference,
					! or a displacement indicator ("B", "W", or "L").
		BEGIN
		LOCAL
			LEXEME_PTR,
			CHAR;

		LEXEME_PTR = CH$PTR (.LEX_STG_DESC [DSC$A_POINTER]);
		CHAR = CH$RCHAR (.LEXEME_PTR);
		IF ((REG_NUM = PAT$REG_MATCH(LEX_STG_DESC)) GEQ 0)
		THEN
			BEGIN
			PASS_BACK(BYTE_LENGTH, .REG_NUM);	! Return the number of this register.
			IF (.REG_NUM LEQ MAX_REG)
			THEN
				REGISTER_TOKEN			! Valid register number
			ELSE
				BAD_TOKEN			! Invalid register number
			END
		ELSE IF (.LEX_STG_DESC [DSC$W_LENGTH] NEQ 1)
		THEN
			BAD_TOKEN	     		! Error.  The string must be only 1 CHARacter long.
		ELSE IF (.CHAR NEQ 'B') AND (.CHAR NEQ 'W') AND (.CHAR NEQ 'L')
		THEN
			!++
			! The string must be one of the valid
			! displacement CHARacters only.
			!--
			BAD_TOKEN


		ELSE IF (MAR_GET_LEX(.INST_STG_DESC, LEX_STG_DESC) NEQ UP_ARROW_TOKEN)
		THEN
			!++
			! <Size> must be followed by '^' to produce <size indicator>.
			!--
			BAD_TOKEN
		ELSE
			!++
			! Extract the following number and pass it back.
			! \This is where we would like to switch grammars
			!  to take advantage of what PATCH already
			!  knows about expression evaluation\.
			!--
			BEGIN
			IF (MAR_GET_LEX(.INST_STG_DESC, LEX_STG_DESC) NEQ DIGIT_STR_TOKEN)
			THEN
				!++
				! The following token must be <number>.
				!--
				BAD_TOKEN
			ELSE
				BEGIN
				!++
				! See what displacement mode was requested.
				!--
				MODE = 0;
				IF (.CHAR EQL 'B')
				THEN
					MODE = BYTE_LENGTH;
				IF (.CHAR EQL 'W')
				THEN
					MODE = WORD_LENGTH;
				IF (.CHAR EQL 'L')
				THEN
					MODE = LONG_LENGTH;
				IF (.MODE EQL 0)
				THEN
					RETURN(BAD_TOKEN);

				!++
				! Return the number as a counted byte stream.
				! The <number> part of it is passed back as a
				! sign-extended longword so that it can be
				! checked for truncation.
				!--
				PASS_BACK(BYTE_LENGTH, .MODE);
				RETURN_PTR = .RETURN_PTR + BYTE_LENGTH;
				PASS_BACK(LONG_LENGTH, .(.LEX_STG_DESC [DSC$A_POINTER]));
				VAL_TOKEN + .MODE		! Return the token type.
				END
			END
		END;


	[OP_PAREN_TOKEN,		! ( reg ), ETC.
	 LSQUARE_TOKEN]:		! [ reg ], for INDEXing mode.
		!++
		! This case looks for an 'at register' reference or an indexing
		! mode indicator.  The reason why they are lumped together is
		! simply due their similarity.  The two tokens are in no
		! other way related.  The REGister number is passed back in the
		! 1st byte of LEX_BUFFER.
		!--
		IF (MAR_GET_LEX(.INST_STG_DESC, LEX_STG_DESC) NEQ ALPHA_STR_TOKEN)
		THEN
			BAD_TOKEN				! No parens or brackets around register
		ELSE
		IF ((REG_NUM = PAT$REG_MATCH(LEX_STG_DESC)) LSS 0)
		THEN
			BAD_TOKEN				! Invalid register name
		ELSE
			!++
			! Make sure that the register is not PSL
			!--
			IF (.REG_NUM GTR MAX_REG)
			THEN
				BAD_TOKEN
			ELSE
				BEGIN
				!++
				! The next token must be a closing parenthesis
				! or square bracket.  If it is not, error.
				!--	
				IF (MAR_GET_LEX(.INST_STG_DESC, LEX_STG_DESC)
				    NEQ ( IF (.TOKEN_TYPE EQL OP_PAREN_TOKEN)
					  THEN
						CL_PAREN_TOKEN
					  ELSE
						RSQUARE_TOKEN
				        ))
				THEN
					BAD_TOKEN
				ELSE
					BEGIN
					!++
					! The operand was complete.  Return the
					! number and token type.
					!--
					PASS_BACK(BYTE_LENGTH, .REG_NUM);
	
					IF (.TOKEN_TYPE EQL OP_PAREN_TOKEN)
					THEN
						AT_REG_TOKEN
					ELSE
						!++
						! You can't index off the PC
						!--	
						IF (.REG_NUM EQL PC_REG)
						THEN
							BAD_TOKEN
						ELSE
							INDEXING_TOKEN
					END
				END;
	

	[OTHERWISE]:			! ERROR.
					! Unrecognized token.  Terminate the encoding.
		BAD_TOKEN;

	TES);

!++
! Update the counted string pointer which is being maintained elsewhere.
! The returned value is whatever was arrived at in the above CASE statement.
!--
RETURN (.TOKEN_TYPE);
END;

ROUTINE GET_LABEL ( INST_STG_DESC, OUT_PC, DEFINE_FLAG ) : NOVALUE =

!++
! Functional Description:
!
!	Scan the supposed instruction string to see if it has a label.
!	If there is a label, then extract it and the following colon and
!	update the instruction string descriptor, INST_STG_DESC.  Then
!	enter the label as an user defined symbol with a value equal to the
!	current PC.
!
! Calling Sequence:
!
!	GET_LABEL (INST_STG_DESC, OUT_PC, DEFINE_FLAG)
!
! Inputs:
!
!	INST_STG_DESC	-A pointer to the counted string which contains
!			 the instruction string we are working on.
!	OUT_PC		-PC at which the instruction will reside
!	DEFINE_FLAG	-Indicator if the label should be entered into the
!			 user's symbol table. TRUE=enter it; FALSE=don't enter it
!
! Implicit Inputs:
!
!	none
!
! Outputs:
!
!	none
!
! Implicit Outputs:
!
!	The instruction string descriptor is updated to exclude the label and
!	colon.  The symbol is entered into the user defined symbol table.
!
! Returned Value:
!
!	none
!
!--

BEGIN

MAP
	INST_STG_DESC : REF BLOCK [, BYTE];

LOCAL
	CHAR,							! Next character in instruction string
	TOKEN_TYPE,						! Type of token found
	INS_PTR : REF VECTOR[,BYTE],				! Pointer to first byte of instruction
	INS_DESC : BLOCK[8,BYTE],				! Local copy of instruction string descriptor
	LABEL_DESC : BLOCK [12, BYTE],				! String descriptor for current token
	LABEL_BUF : VECTOR[ CHS_PER_LEXEME, BYTE];		! Buffer to hold label string

!++
! Initialize the local instruction string descriptor.  This routine uses
! its own copy in case there is no label on the instruction.  Also initialize
! the label string descriptor.
!--
INS_DESC [DSC$W_LENGTH] = .INST_STG_DESC[DSC$W_LENGTH];
INS_DESC [DSC$A_POINTER] = .INST_STG_DESC[DSC$A_POINTER];
LABEL_DESC [DSC$W_LENGTH] = 0;
LABEL_DESC [DSC$A_POINTER] = LABEL_BUF;
LABEL_DESC [DSC$W_MAXLEN] = CHS_PER_LEXEME;
TOKEN_TYPE = MAR_GET_LEX(INS_DESC, LABEL_DESC);
IF ((.TOKEN_TYPE NEQ ALPHA_STR_TOKEN) AND (.TOKEN_TYPE NEQ DIGIT_STR_TOKEN))
THEN
	RETURN;							! No label
INS_PTR = CH$PTR(.INS_DESC[DSC$A_POINTER], 0);
DO
	CHAR = CH$RCHAR_A(INS_PTR)
UNTIL ((.CHAR NEQU ' ') AND (.CHAR NEQU '	'));
IF (.CHAR NEQU ':')
THEN
	RETURN;							! No label

!++
! Now update the return instruction descriptor.
!--
INST_STG_DESC[DSC$W_LENGTH] = .INST_STG_DESC[DSC$W_LENGTH] - (.INS_PTR - .INST_STG_DESC[DSC$A_POINTER]);
INST_STG_DESC[DSC$A_POINTER] = .INS_PTR;

!++
! Now define the label as an user symbol with a value of the current PC.
!--
PAT$DEFINE_SYM(LABEL_DESC, .OUT_PC, FALSE);
RETURN;
END;

ROUTINE GET_OPCODE ( INST_STG_DESC, F_OUT_BYTE_PTR, OPINFO_PTR, OUT_PC ) =

!++
! Functional Description:
!
!	Scan the supposed instruction string to extract the opcode from it.  
!
! Calling Sequence:
!
!	GET_OPCODE (INST_STG_DESC, F_OUT_BYTE_PTR, OPINFO_PTR, OUT_PC)
!
! Inputs:
!
!	INST_STG_DESC	-A pointer to the counted string which contains
!			 the instruction string we are working on.
!	F_OUT_BYTE_PTR	-A pointer to where we should stuff the
!			 opcode if we find a valid one.
!	OPINFO_PTR	-A pointer to where we should stuff the address
!			 of the OPINFO record which we find as a match
!			 to the opcode we extract from the instruction string.
!	OUT_PC		-A pointer to a loc that is bumped for each byte
!			 placed in the instruction stream.
!
! Implicit Inputs:
!
!	The OPINFO data structure which is described in PATINS.B32
!
! Outputs:
!
!	None other than via the parameters given above.
!
! Implicit Outputs:
!
!	None.
!
! Returned Value:
!
!	A pointer to a counted string (built by this routine) which is the
!	name of the opcode.  If the opcode is invalid, an error message is
!	SIGNALed and there is no return.
!--

BEGIN

MAP
	OPINFO_PTR : REF VECTOR[,LONG],				! Pointer into the OPINFO table
	OUT_PC : REF VECTOR[,LONG],
	F_OUT_BYTE_PTR : REF VECTOR[,BYTE],
	INST_STG_DESC : REF BLOCK [,BYTE];

BIND
	OPINFO_RECORD = .OPINFO_PTR : REF BLOCK[OPTSIZE,BYTE],
	OUT_BYTE_PTR = .F_OUT_BYTE_PTR : REF VECTOR;

OWN
	OPCODE_NAME : VECTOR[8,BYTE];				! Buffer to hold opcode string

LOCAL
	TOKEN_TYPE,
	OPCODE,							! Numeric Opcode.
	OPCO_STG_DESC : BLOCK [12, BYTE],
	USER_OPCODE : VECTOR[ CHS_PER_LEXEME, BYTE];

!++
! Make sure that the first token is a potential opcode.
!--
OPCO_STG_DESC [DSC$W_LENGTH] = 0;
OPCO_STG_DESC [DSC$A_POINTER] = USER_OPCODE;
OPCO_STG_DESC [DSC$W_MAXLEN] = CHS_PER_LEXEME;
IF ((TOKEN_TYPE = MAR_GET_LEX(.INST_STG_DESC, OPCO_STG_DESC)) NEQ ALPHA_STR_TOKEN)
THEN
	IF (.TOKEN_TYPE GTR KEYWORD_RANGE)
	THEN
		SIGNAL(PAT$_BADOPCODE+MSG$K_WARN, 2, .OPCO_STG_DESC[DSC$W_LENGTH],
			.OPCO_STG_DESC[DSC$A_POINTER]);	! No return

!++
! Look in the opcode table for a match to this string.
!--
IF ((OPCODE = OPCODE_MATCH( OPCO_STG_DESC, .OPINFO_PTR)) LSS 0)
THEN
	SIGNAL(PAT$_BADOPCODE+MSG$K_WARN, 2, .OPCO_STG_DESC[DSC$W_LENGTH], .OPCO_STG_DESC[DSC$A_POINTER]); ! No return

!++
! Found it.  Put the opcode byte into the instruction stream being built, unless
! there is insufficient information to continue.  This only happens when the
! opcode is reserved, because PATCH does not know how many operands to expect.
! If this is an assembler directive, then don't try to put an opcode into
! the byte stream.  Just return successfully.
!--
IF (.OPINFO_RECORD[OP_NUMOPS] EQL NOT_AN_OP)
THEN
	SIGNAL(PAT$_RESOPCODE+MSG$K_WARN, 2, .OPCO_STG_DESC[DSC$W_LENGTH], .OPCO_STG_DESC[DSC$A_POINTER]); ! No return
IF (.OPINFO_RECORD[OP_NUMOPS] NEQ ASM_DIR_OP)
THEN
	BEGIN
	IF (.OPCODE AND %X'FF') EQL %X'FD'
	THEN
		BEGIN			! Output 1st byte of 2 byte OPcode
		OUT_BYTE_PTR[0] = %X'FD';
		OUT_BYTE_PTR = .OUT_BYTE_PTR + 1;
		OUT_PC[0] = .OUT_PC[0] + 1;
		OPCODE = .OPCODE ^ -8;
		END;
	OUT_BYTE_PTR[0] = .OPCODE;
	OUT_BYTE_PTR = .OUT_BYTE_PTR + 1;
	OUT_PC[0] = .OUT_PC[0] + 1;
	END;

!++
! Build a counted string which contains the name of the opcode for possible
! use later in error reporting.  Return a pointer to this string as the
! result of this routine.
!--
CH$MOVE(.OPCO_STG_DESC[DSC$W_LENGTH], .OPCO_STG_DESC[DSC$A_POINTER],
		OPCODE_NAME[1]);
OPCODE_NAME[0] = .OPCO_STG_DESC[DSC$W_LENGTH];
RETURN(OPCODE_NAME);
END;

ROUTINE GET_OPERAND ( INS_STG_DESC, OPRND_STG_DESC, USER_SYM_FLAG ) =

!++
! Functional Description:
!
!	This routine scans the input stream and extracts the next operand from
!	it.  During this scan, all expressions and symbolic names are evaluated.
!	The resultant "operand" string is placed in the buffer pointed to by
!	OPRND_STG_DESC.  This string can then be encoded by ENC_OPERAND into
!	a binary operand for the instruction.
!
! Calling Sequence:
!
!	GET_OPERAND (INS_STG_DESC, OPRND_STG_DESC, USER_SYM_FLAG)
!
! Inputs:
!
!	INS_STG_DESC	- Address of string descriptor for remaining operands of
!			  instruction being encoded.
!	OPRND_STG_DESC	- Address of string descriptor for buffer into which the
!			  "pre-processed" operand string will be placed
!	USER_SYM_FLAG - Indicator whether or not to reduce user-defined symbols.
!			This feature is for command file output.
!				(TRUE=reduce, FALSE=don't reduce)
!
! Implicit Inputs:
!
!	PAT$GL_MOD_PTR	- is used by the radix convert routine
!			  to convert numeric input.
!
! Outputs:
!
!	None.
!
! Implicit Outputs:
!
!	OPRND_STG_DESC[DSC$W_LENGTH] will be set to the length of the operand.
!	The buffer pointed to by OPRND_STG_DESC[DSC$A_POINTER] will contain the
!	ASCII operand string.
!
! Return Value:
!
!	OPR_FOUND (1)	- if an operand is found.
!	NO_MORE_OPR (0)	- if there are no more operands.
!	OPR_ERROR (2)	- if there was an error in the operand.
!	OPR_FORW_REF (3)- if there was a forward reference to a symbol
!
! Side Effects:
!
!	All errors in expressions or undefined symbols are SIGNALed, causing
!	an INFORMATIONAL message to be printed.  Then an error code is returned
!	so that the routine that called PAT$INS_ENCODE will output the
!	instruction that could not be encoded.
!
!	Also, PAT$CP_OUT_STR and PAT$GL_BUF_SIZ are destroyed.
!
!--

BEGIN

MAP
	INS_STG_DESC : REF BLOCK [,BYTE],			! String descriptor for remaining operands
	OPRND_STG_DESC : REF BLOCK[,BYTE];			! String descriptor for returned operand

LABEL
	DIGIT_CODE,						! Digit string token code
	OPERATOR_CODE,						! Operator handling code
	RANGLE_CODE,						! Right angle bracket handling code
	ALPHA_CODE,						! Alpha_str_token handling code
	GET_PATHNAME;						! Code to get a pathname

BIND
	EXP_STG = UPLIT BYTE (%ASCIC '^X!XL');			! FAO control string to convert binary numbers to ASCII

MACRO
	EXP$L_VALUE = 0, 0, 32, 0%,				! EXP$L_VALUE (expression value stacked)
	EXP$B_OPERATOR = 0, 32, 8, 1%;				! EXP$B_OPERATOR (token_type for stacked operator)

LITERAL
	EXP$C_SIZE = 5,						! Length of one expression stack entry
	EXPR_STK_SIZ = EXP$C_SIZE * 20,				! Allow 20 entries on expression stack
	NEGATION_TOKEN = -1;					! Token value for unary '-'

LOCAL
	INS_START_PTR : REF VECTOR[,BYTE],			! Pointer to first byte of this operand
	FLAG,							! Flag to exit operator select loop
	CUR_VALUE,						! Current numeric value found
	CUR_OPERATOR,						! Current operator to process
	NUMBER_FLAG,						! Flag set if operand contained a numeric value
	PREV_TOKEN,						! Previous token_type value
	TOKEN_TYPE,						! Encoded type of token found by PAT$MAR_GET_LEX
	LEX_STG_DESC : BLOCK[12,BYTE],				! String descriptor for current lexeme
	STACK_PTR : REF BLOCK[,BYTE],				! Pointer to next free position on expression stack
	EXPR_STACK : BLOCK[EXPR_STK_SIZ,BYTE],			! Expression stack (grows from low address to high address)
	LEX_BUF : VECTOR[CHS_PER_LEXEME,BYTE];			! Buffer to hold ascii lexeme string

!++
! First check that there is more input in the remaining operand string.
!--
IF (.INS_STG_DESC[DSC$W_LENGTH] EQL 0)
THEN
	RETURN(NO_MORE_OPR);

!++
! Initialize local variables before starting lexical scan.
!--
CUR_VALUE = 0;
CUR_OPERATOR = 0;
NUMBER_FLAG = FALSE;
TOKEN_TYPE = 0;
STACK_PTR = CH$PTR(EXPR_STACK, 0);
INS_START_PTR = CH$PTR(.INS_STG_DESC[DSC$A_POINTER], 0);
BYTES_IN_OPRND = 0;						! Initialize to no bytes

!++
! Zero the buffer which will hold the return operand.
!--
ZEROCOR (.OPRND_STG_DESC[DSC$A_POINTER], (.OPRND_STG_DESC[DSC$W_MAXLEN]/4));

!++
! Now enter a loop to process the operand.  There are two ways out of this loop.
! The first is by SIGNALing an error.  The second is by encountering a comma or
! end of line.  Some tokens may be passed directly into the operand string and
! others indicate expressions or symbols.  There is no check in this routine
! of the validity of the resultant operand string.
!--
REPEAT
	BEGIN
	!++
	! Get the next token.  The process this token based on its
	! encoded token_type.
	!--
	LEX_STG_DESC[DSC$W_LENGTH] = 0;
	LEX_STG_DESC[DSC$A_POINTER] = LEX_BUF;
	LEX_STG_DESC[DSC$W_MAXLEN] = CHS_PER_LEXEME;
	PREV_TOKEN = .TOKEN_TYPE;
	TOKEN_TYPE = MAR_GET_LEX(.INS_STG_DESC, LEX_STG_DESC);
	SELECTONE .TOKEN_TYPE OF

		SET

	[CL_PAREN_TOKEN,				! ')' as in (reg)
	 RSQUARE_TOKEN,					! ']' as in [reg]
	 HASH_TOKEN,					! '#' as in #literal
	 UP_ARROW_TOKEN,				! '^' as in B^,W^,...
	 PERIOD_TOKEN]:					! '.' as in .+offset, .-offset
		BEGIN
		!++
		! All of these tokens are passed directly into the resultant
		! operand string.
		!--
		ADD_LEX_T_OPRND( LEX_STG_DESC, .OPRND_STG_DESC);
		END;


	[OP_PAREN_TOKEN,				! '(' as in (reg)
	 LSQUARE_TOKEN]:				! '[' as in [reg]
		BEGIN
		!++
		! These tokens signify the end of an expression, if there is
		! one.  The expression and the token should be passed through.
		!--
		IF (.NUMBER_FLAG)
		THEN
			BEGIN
			!++
			! Output the literal to the operand string.  The case
			! here is number(reg) or number[reg].
			!--
			IF (.STACK_PTR NEQU EXPR_STACK)
			THEN
				BEGIN
				SIGNAL(PAT$_NOANGLE+MSG$K_INFO); ! Invalid expression - no closing ">"
				RETURN(OPR_ERROR);
				END;
			PAT$GL_BUF_SIZ = 0;
			PAT$CP_OUT_STR = CH$PTR(.OPRND_STG_DESC[DSC$A_POINTER],
						.OPRND_STG_DESC[DSC$W_LENGTH]);
			PAT$FAO_PUT(EXP_STG, .CUR_VALUE);
			OPRND_STG_DESC[DSC$W_LENGTH] = .OPRND_STG_DESC[DSC$W_LENGTH] + .PAT$GL_BUF_SIZ;
			NUMBER_FLAG = FALSE;			! Reset literal flag
			CUR_VALUE = 0;
			END;

		!++
		! Now pass through the '(' or the '['.
		!--
		ADD_LEX_T_OPRND( LEX_STG_DESC, .OPRND_STG_DESC);
		IF (.TOKEN_TYPE EQLU LSQUARE_TOKEN)
		THEN
			BYTES_IN_OPRND = .BYTES_IN_OPRND OR CONT_INDX_MASK;
		END;


	[AT_SIGN_TOKEN,					! '@' shift operator or @(reg)
	 PLUS_TOKEN,					! '+' addition operator of (reg)+
	 MINUS_TOKEN,					! '+' subtraction operator of -(reg)
	 SLASH_TOKEN,					! '/' division operator
	 ASTERISK_TOKEN]:				! '*' multiplication operator
	   OPERATOR_CODE:
		BEGIN
		!++
		! All operators are handled here.  Later additions should be the
		! ampersand (&) for logical AND and exclamation point (!) for
		! logical OR.  These are not currently passed through the
		! lexical scanner.
		!--
		IF (.TOKEN_TYPE EQLU AT_SIGN_TOKEN) AND (.PREV_TOKEN EQL 0)
		THEN
			BEGIN
			!++
			! There is no previous token therefore this must the
			! @(reg) case.  Just pass the operator through to the
			! resultant operand string.
			!--
			ADD_LEX_T_OPRND( LEX_STG_DESC, .OPRND_STG_DESC);
			LEAVE OPERATOR_CODE;
			END;

		IF ((.TOKEN_TYPE EQLU PLUS_TOKEN) OR (.TOKEN_TYPE EQLU MINUS_TOKEN)) AND
		   (.PREV_TOKEN EQLU PERIOD_TOKEN)
		THEN
			BEGIN
			!++
			! This is the case of .+offset or .-offset; pass through
			! the operator to the resultant string.
			!--
			ADD_LEX_T_OPRND( LEX_STG_DESC, .OPRND_STG_DESC);
			LEAVE OPERATOR_CODE;
			END;

		IF (.TOKEN_TYPE EQLU PLUS_TOKEN) AND (.PREV_TOKEN EQLU CL_PAREN_TOKEN)
		THEN
			BEGIN
			!++
			! This is the case (reg)+.  Pass through the operator.
			!--
			ADD_LEX_T_OPRND( LEX_STG_DESC, .OPRND_STG_DESC);
			LEAVE OPERATOR_CODE;
			END;

		IF (.TOKEN_TYPE EQLU MINUS_TOKEN)
		THEN
			BEGIN
			!++
			! Check for the case -(reg).
			!--
			LOCAL
				NEXT_CHAR : BYTE,		! Next character from operand stream
				INS_PTR : REF VECTOR[,BYTE];	! Pointer to next character in operand stream

			!++
			! Find the next character in the operand stream that is
			! not a space or a tab.  This to check if the next
			! character is a '('.
			!--
			INS_PTR = CH$PTR(.INS_STG_DESC[DSC$A_POINTER],0);
			DO
				NEXT_CHAR = CH$RCHAR_A(INS_PTR)
			UNTIL ((.NEXT_CHAR NEQU ' ') AND (.NEXT_CHAR NEQU '	'));
			IF (.NEXT_CHAR EQLU '(')
			THEN
				BEGIN
				!++
				! This was a case of -(reg).  Pass through the '-'.
				!--
				ADD_LEX_T_OPRND( LEX_STG_DESC, .OPRND_STG_DESC);
				LEAVE OPERATOR_CODE;
				END;
			END;

		!++
		! There should never be two successive operators unless the
		! second is the unary negation operator.  If the second is the
		! negation operator, then stack it and the current value.
		! Then set the current operator to be negation_token.
		!--
		IF (.CUR_OPERATOR NEQ 0)
		THEN
			IF (.TOKEN_TYPE NEQU MINUS_TOKEN)
			THEN
				BEGIN
				SIGNAL(PAT$_MULTOPR+MSG$K_INFO); ! Two sequential operators found
				RETURN(OPR_ERROR);
				END
			ELSE
				BEGIN
				IF ((.STACK_PTR + EXP$C_SIZE) GTRU (EXPR_STACK + EXPR_STK_SIZ))
				THEN
					BEGIN
					SIGNAL(PAT$_EXPSTKOVR+MSG$K_INFO); ! Stack overflow
					RETURN(OPR_ERROR);
					END;

				!++
				! Stack the current operator and value.
				!--
				STACK_PTR[EXP$L_VALUE] = .CUR_VALUE;
				STACK_PTR[EXP$B_OPERATOR] = .CUR_OPERATOR;
				STACK_PTR = CH$PTR(.STACK_PTR, EXP$C_SIZE);
				CUR_VALUE = 0;
				CUR_OPERATOR = NEGATION_TOKEN;
				LEAVE OPERATOR_CODE;
				END;

		!++
		! Set the new current operator and go get the next token.
		!--
		CUR_OPERATOR = .TOKEN_TYPE;
		END;


	[LANGLE_TOKEN]:					! '<' encloses expression
		BEGIN
		!++
		! Check for expression stack overflow.
		!--
		IF ((.STACK_PTR + EXP$C_SIZE) GTRU (EXPR_STACK + EXPR_STK_SIZ))
		THEN
			BEGIN
			SIGNAL(PAT$_EXPSTKOVR+MSG$K_INFO);	! Stack overflow
			RETURN(OPR_ERROR);
			END;

		!++
		! Put new entry on expression stack.  Then reset the pointer
		! to the next unused entry.  Push the current operator if there
		! is one, otherwise push a '<' as the operator.
		!--
		STACK_PTR[EXP$L_VALUE] = .CUR_VALUE;
		STACK_PTR[EXP$B_OPERATOR] = (IF (.CUR_OPERATOR NEQ 0)
					     THEN
						    .CUR_OPERATOR
					     ELSE
						    .TOKEN_TYPE);
		STACK_PTR = CH$PTR(.STACK_PTR, EXP$C_SIZE);
		CUR_VALUE = 0;
		CUR_OPERATOR = 0;
		END;


	[RANGLE_TOKEN]:					! '>' encloses expression
	   RANGLE_CODE:
		BEGIN
		!++
		! The right angle bracket causes one entry to be taken off the
		! expression stack.  This entry always immediately precedes the
		! next free entry pointed to by STACK_PTR.  When an entry is
		! removed, the current value and the stacked value must be
		! combined using the stacked operator.  If the operator is a
		! left angle bracket, then there were two consecutive left
		! angle brackets in the expression and there is no stacked value
		! to be combined.
		!--
		IF (.STACK_PTR EQLU EXPR_STACK)			! Check for stack underflow
		THEN
			BEGIN
			SIGNAL(PAT$_NOANGLE+MSG$K_INFO);	! Stack underflow
			RETURN(OPR_ERROR);
			END;
		IF (.CUR_OPERATOR NEQU 0) OR (.PREV_TOKEN EQLU LANGLE_TOKEN) ! Check for missing operand
		THEN
			BEGIN
			SIGNAL(PAT$_NOOPRND+MSG$K_INFO);	! Missing operand (got operator>)
			RETURN(OPR_ERROR);
			END;
		STACK_PTR = CH$PTR(.STACK_PTR, -EXP$C_SIZE);	! Point to last entry
		DO
		BEGIN
		FLAG = TRUE;
		SELECTONE .STACK_PTR[EXP$B_OPERATOR] OF
			SET
		[PLUS_TOKEN]:		CUR_VALUE = .STACK_PTR[EXP$L_VALUE] + .CUR_VALUE;
		[MINUS_TOKEN]:		CUR_VALUE = .STACK_PTR[EXP$L_VALUE] - .CUR_VALUE;
		[ASTERISK_TOKEN]:	CUR_VALUE = .STACK_PTR[EXP$L_VALUE] * .CUR_VALUE;
		[SLASH_TOKEN]:		CUR_VALUE = .STACK_PTR[EXP$L_VALUE] / .CUR_VALUE;
 		[AT_SIGN_TOKEN]:	CUR_VALUE = .STACK_PTR[EXP$L_VALUE] ^ .CUR_VALUE;
		[LANGLE_TOKEN]:		0;			! No operation to perform
! * FUTURE *	[AMPERSAND_TOKEN]:		CUR_VALUE = .STACK_PTR[EXP$L_VALUE] + .CUR_VALUE;
! * FUTURE *	[EXCLAM_PT_TOKEN]:		CUR_VALUE = .STACK_PTR[EXP$L_VALUE] + .CUR_VALUE;
		[NEGATION_TOKEN]:		BEGIN
						FLAG = FALSE;
						CUR_VALUE = -.CUR_VALUE;
						IF (.STACK_PTR NEQU EXPR_STACK) ! Check for stack underflow
						THEN
							STACK_PTR = CH$PTR(.STACK_PTR, -EXP$C_SIZE); ! Point to last entry
						END;
		[OTHERWISE]:			BEGIN
						SIGNAL(PAT$_INVOPR+MSG$K_INFO); ! Unrecognized operand
						RETURN(OPR_ERROR);
						END;
			TES;
		END
		UNTIL (.FLAG);

		CUR_OPERATOR = 0;
		NUMBER_FLAG = TRUE;
		END;


	[DIGIT_STR_TOKEN]:				! numeric string
		BEGIN
		IF (.CUR_OPERATOR EQL 0)
		THEN
			CUR_VALUE = .(.LEX_STG_DESC[DSC$A_POINTER])
		ELSE
			DO
			BEGIN
			FLAG = TRUE;
			IF (.CUR_OPERATOR EQL NEGATION_TOKEN)
			THEN
				CUR_VALUE = .(.LEX_STG_DESC[DSC$A_POINTER]);
			SELECTONE .CUR_OPERATOR OF
				SET
			[PLUS_TOKEN]:	CUR_VALUE = .CUR_VALUE + .(.LEX_STG_DESC[DSC$A_POINTER]);
			[MINUS_TOKEN]:	CUR_VALUE = .CUR_VALUE - .(.LEX_STG_DESC[DSC$A_POINTER]);
			[ASTERISK_TOKEN]: CUR_VALUE = .CUR_VALUE * .(.LEX_STG_DESC[DSC$A_POINTER]);
			[SLASH_TOKEN]:	CUR_VALUE = .CUR_VALUE / .(.LEX_STG_DESC[DSC$A_POINTER]);
			[AT_SIGN_TOKEN]: CUR_VALUE = .CUR_VALUE ^ .(.LEX_STG_DESC[DSC$A_POINTER]);
			[LANGLE_TOKEN]:		0;		! No operation to perform
! * FUTURE *		[AMPERSAND_TOKEN]: CUR_VALUE = .CUR_VALUE AND .(.LEX_STG_DESC[DSC$A_POINTER]);
! * FUTURE *		[EXCLAM_PT__TOKEN]: CUR_VALUE = .CUR_VALUE OR .(.LEX_STG_DESC[DSC$A_POINTER]);
			[NEGATION_TOKEN]:	BEGIN
						FLAG = FALSE;
						CUR_VALUE = -.CUR_VALUE;
						IF (.STACK_PTR NEQU EXPR_STACK) ! Check for stack underflow
						THEN
							BEGIN
							STACK_PTR = CH$PTR(.STACK_PTR, -EXP$C_SIZE); ! Point to last entry
							CUR_OPERATOR = .STACK_PTR[EXP$B_OPERATOR];
							.LEX_STG_DESC[DSC$A_POINTER] = .CUR_VALUE;
							CUR_VALUE = .STACK_PTR[EXP$L_VALUE];
							END;
						END;
			[OTHERWISE]:	BEGIN
					SIGNAL(PAT$_INVOPR+MSG$K_INFO); ! Unrecognized operand
					RETURN(OPR_ERROR);
					END;
				TES;
			END
			UNTIL (.FLAG);
		CUR_OPERATOR = 0;
		NUMBER_FLAG = TRUE;
		END;


	[EOL_TOKEN,
	 COMMA_TOKEN]:					! End of operand string
		BEGIN
		!++
		! Either of these tokens signals the end of the operand string.
		! Check if there is a numeric value to be written to the
		! resultant string.  Check for expressions left on the stack.
		!--
		IF (.NUMBER_FLAG)
		THEN
			BEGIN
			!++
			! Output the current value as an ASCII string.
			!--
			PAT$GL_BUF_SIZ = 0;
			PAT$CP_OUT_STR = CH$PTR(.OPRND_STG_DESC[DSC$A_POINTER],
						.OPRND_STG_DESC[DSC$W_LENGTH]);
			PAT$FAO_PUT(EXP_STG, .CUR_VALUE);
			OPRND_STG_DESC[DSC$W_LENGTH] = .OPRND_STG_DESC[DSC$W_LENGTH] + .PAT$GL_BUF_SIZ;
			END;

		!++
		! Check that there is not a missing operand, i.e., there exists
		! a current operator.
		!--
		IF (.CUR_OPERATOR NEQ 0)
		THEN
			BEGIN
			SIGNAL(PAT$_NOOPRND+MSG$K_INFO);	! Missing operand (got operator>)
			RETURN(OPR_ERROR);
			END;

		!++
		! Check that there was nothing left on the expression stack.
		!--
		IF (.STACK_PTR NEQU EXPR_STACK)
		THEN
			BEGIN
			SIGNAL(PAT$_NOANGLE+MSG$K_INFO);	! Expression stack not empty
			RETURN(OPR_ERROR);
			END;
		IF (.OPRND_STG_DESC[DSC$W_LENGTH] EQL 0)
		THEN
			RETURN(NO_MORE_OPR)				! Got , or EOL_TOKEN and no operand
		ELSE
			RETURN(OPR_FOUND);
		END;


	[ALPHA_STR_TOKEN]:				! Register, L^,B^,... or symbolic name
	   ALPHA_CODE:
		BEGIN
		!++
		! First check if the string is a register.  If so then pass
		! it through.
		!--
		LOCAL
			STATUS,					! Return status from symbol definition
			SYMBOL_BUF : VECTOR[MAX_BUF_SIZ,BYTE],	! Buffer to hold all of pathname
			SYMBOL_DESC : BLOCK[12,BYTE],		! String descriptor for pathname
			NEXT_CHAR : BYTE,			! Next ASCII character in input stream
			INS_PTR : REF VECTOR[,BYTE],		! Pointer to next character in input stream
			REG_NUM,				! Number of register found
			LEXEME_PTR,				! Pointer to ASCII lexeme
			TEMP_VALUE,				! Value of pathname
			CHAR : BYTE;				! First ASCII character in lexeme

		IF ((REG_NUM = PAT$REG_MATCH(LEX_STG_DESC)) GEQ 0) AND
		    (.REG_NUM LEQ MAX_REG)
		THEN
			BEGIN
			!++
			! Found a register.  Pass it through.
			!--
			ADD_LEX_T_OPRND( LEX_STG_DESC, .OPRND_STG_DESC);
			LEAVE ALPHA_CODE;
			END;

		!++
		! It was not a register.  Check if it is one of the following
		! directives:  L^, W^, B^, I^, or S^.  If so, pass the token
		! through.
		!--
		LEXEME_PTR = CH$PTR(.LEX_STG_DESC[DSC$A_POINTER], 0);
		CHAR = CH$RCHAR(.LEXEME_PTR);
		IF (.LEX_STG_DESC[DSC$W_LENGTH] EQL 1)
		THEN
			IF (.CHAR EQLU 'B') OR
			   (.CHAR EQLU 'W') OR
			   (.CHAR EQLU 'L') OR
			   (.CHAR EQLU 'I') OR
			   (.CHAR EQLU 'S')
			THEN
				BEGIN
				INS_PTR = CH$PTR(.INS_STG_DESC[DSC$A_POINTER], 0);
				NEXT_CHAR = CH$RCHAR(.INS_PTR);
				IF (.NEXT_CHAR EQLU '^')
				THEN
					BEGIN
					LEX_BUF[1] = '^';
					LEX_STG_DESC[DSC$W_LENGTH] = .LEX_STG_DESC[DSC$W_LENGTH] + 1;
					INS_STG_DESC[DSC$W_LENGTH] = .INS_STG_DESC[DSC$W_LENGTH] - 1;
					INS_STG_DESC[DSC$A_POINTER] = .INS_STG_DESC[DSC$A_POINTER] + 1;
					ADD_LEX_T_OPRND(LEX_STG_DESC, .OPRND_STG_DESC);
					IF (.CHAR EQLU 'B')
					THEN
						BYTES_IN_OPRND = .BYTES_IN_OPRND OR B_HAT_MASK;
					IF (.CHAR EQLU 'W')
					THEN
						BYTES_IN_OPRND = .BYTES_IN_OPRND OR W_HAT_MASK;
					IF (.CHAR EQLU 'L')
					THEN
						BYTES_IN_OPRND = .BYTES_IN_OPRND OR L_HAT_MASK;
					LEAVE ALPHA_CODE;
					END;
				END;

		!++
		! The alpha string must be a symbolic name.
		! Add the current token to the path name by calling PAT$BUILD_PATH.
		! Also build an ascii string of the pathname using ADD_LEX_T_OPRND
		! in case the symbol turns out to be undefined.  This will be
		! used for forward branching in patch area.
		!--
		SYMBOL_DESC[DSC$W_LENGTH] = 0;
		SYMBOL_DESC[DSC$A_POINTER] = SYMBOL_BUF;
		SYMBOL_DESC[DSC$W_MAXLEN] = MAX_BUF_SIZ;
		ADD_LEX_T_OPRND(LEX_STG_DESC, SYMBOL_DESC);
		IF NOT PAT$BUILD_PATH(LEX_STG_DESC, 0, FALSE)
		THEN
			SIGNAL(PAT$_NOFREE)			! Insufficient free memory
		ELSE
		   GET_PATHNAME:
			BEGIN
			!++
			! Now loop to get the rest of the pathname (if any).
			!--
			REPEAT
			BEGIN
			INS_PTR = CH$PTR(.INS_STG_DESC[DSC$A_POINTER], 0);
			DO
				NEXT_CHAR = CH$RCHAR_A(INS_PTR)
			UNTIL ((.NEXT_CHAR NEQU ' ') AND (.NEXT_CHAR NEQU '	'));
			IF (.NEXT_CHAR NEQU '\')
			THEN
				LEAVE GET_PATHNAME
			ELSE
				BEGIN
				!++
				! Found a backslash.  There must be another
				! piece of the pathname.
				!--
				LOCAL
					TEMP_TOKEN;		! Temporary token type

				!++
				! Now PATCH should be able to get the next two
				! tokens (BACK_SLASH_TOKEN and ALPHA_STR_TOKEN).
				! Any other token types are errors.
				!--
				LEX_STG_DESC[DSC$W_LENGTH] = 0;
				LEX_STG_DESC[DSC$A_POINTER] = LEX_BUF;
				LEX_STG_DESC[DSC$W_MAXLEN] = CHS_PER_LEXEME;
				IF (TEMP_TOKEN = MAR_GET_LEX( .INS_STG_DESC, LEX_STG_DESC)) NEQU BACKSLASH_TOKEN
				THEN
					BEGIN
		! ******** THIS NEEDS AN OPERAND!!!!!!!! WHICH ONE?
					SIGNAL(PAT$_INVPATH+MSG$K_INFO); ! Invalid pathname
					RETURN(OPR_ERROR);
					END;
				ADD_LEX_T_OPRND(LEX_STG_DESC, SYMBOL_DESC);
				LEX_STG_DESC[DSC$W_LENGTH] = 0;
				LEX_STG_DESC[DSC$A_POINTER] = LEX_BUF;
				LEX_STG_DESC[DSC$W_MAXLEN] = CHS_PER_LEXEME;
				IF (TEMP_TOKEN = MAR_GET_LEX(.INS_STG_DESC, LEX_STG_DESC)) NEQU ALPHA_STR_TOKEN
				THEN
					BEGIN
		! ******** THIS NEEDS AN OPERAND!!!!!!!! WHICH ONE?
					SIGNAL(PAT$_INVPATH+MSG$K_INFO); ! Invalid pathname
					RETURN(OPR_ERROR);
		! ******** THIS NEEDS AN OPERAND!!!!!!!! WHICH ONE?
					END;
				IF NOT PAT$BUILD_PATH(LEX_STG_DESC, 0, FALSE)
				THEN
					SIGNAL(PAT$_NOFREE);	! Insufficient free memory
				ADD_LEX_T_OPRND(LEX_STG_DESC, SYMBOL_DESC);
				END;
			END;
			END;

		!++
		! Now the complete pathname has been acquired.  Try to
		! convert it into a numerical value.  First search the current
		! symbol table for a label.  Then search the old label symbol
		! table.  Lastly, if the symbol is not defined then
		! PAT$BUILD_PATH returns FALSE.
		!--
		STATUS = PAT$FIND_SYM(SYMBOL_DESC);
		IF (.STATUS EQLA 0)
		THEN
			BEGIN
			!++
			! Remember the current symbol table but force
			! PAT$FIND_SYM to use the old contents label table.
			!--
			LOCAL
				TEMP_SYMTB_PTR;
			TEMP_SYMTB_PTR = .PAT$GL_SYMTBPTR;
			PAT$GL_SYMTBPTR = .PAT$GL_OLDLABLS;
			STATUS = PAT$FIND_SYM(SYMBOL_DESC);
			PAT$GL_SYMTBPTR = .TEMP_SYMTB_PTR;
			END;
		IF (.STATUS NEQA 0)
		THEN
			BEGIN
			!++
			! Symbol was defined as a label.  Get the value and
			! then change STATUS from the table entry address to
			! a code which would be returned by PAT$BUILD_PATH.
			!--
			TEMP_VALUE = .SYM_VALUE(.STATUS);
			STATUS = PAT$K_USER_DEF;
			PAT$DELETE_PATH();
			END
		ELSE
			STATUS = PAT$BUILD_PATH(0, TEMP_VALUE, FALSE);
		IF (NOT .STATUS) OR				! If undefined symbol or
		   ((.STATUS EQLU PAT$K_USER_DEF) AND (NOT .USER_SYM_FLAG)) ! symbol is user-defined and not to be reduced
		THEN
			BEGIN
			!++
			! Either the symbol was undefined and assumed to be a
			! forward reference or it is a user-defined symbol and
			! this is a reduction for command file output and thus
			! the symbol is not to be reduced.  In the case of a
			! forward reference, the symbol will be defined later
			! in the current PATCH command.  Since PATCH cannot
			! handle the operand now, set the operand string
			! descriptor to point to the un-reduced ascii string
			! in the instruction buffer.
			!--
			DO
				BEGIN
				!++
				! This loop finds the end of the operand.
				!--
				LEX_STG_DESC[DSC$W_LENGTH] = 0;
				LEX_STG_DESC[DSC$A_POINTER] = LEX_BUF;
				TOKEN_TYPE = MAR_GET_LEX(.INS_STG_DESC, LEX_STG_DESC);
				IF (.TOKEN_TYPE EQLU LSQUARE_TOKEN)
				THEN
					BYTES_IN_OPRND = .BYTES_IN_OPRND OR CONT_INDX_MASK;
				END
			UNTIL ((.TOKEN_TYPE EQL EOL_TOKEN) OR (.TOKEN_TYPE EQL COMMA_TOKEN));
			OPRND_STG_DESC[DSC$W_LENGTH] = .INS_STG_DESC[DSC$A_POINTER]
						- .INS_START_PTR;
			OPRND_STG_DESC[DSC$A_POINTER] = CH$PTR(.INS_START_PTR, 0);
			RETURN(OPR_FORW_REF);
			END;
		!++
		! Now that a value has been found, process it as if a
		! DIGIT_STR_TOKEN had been found.
		!--
		IF (.CUR_OPERATOR EQL 0)
		THEN
			CUR_VALUE = .TEMP_VALUE
		ELSE
			DO
			BEGIN
			FLAG = TRUE;
			IF (.CUR_OPERATOR EQL NEGATION_TOKEN)
			THEN
				CUR_VALUE = .TEMP_VALUE;
			SELECTONE .CUR_OPERATOR OF
				SET
			[PLUS_TOKEN]:	CUR_VALUE = .CUR_VALUE + .TEMP_VALUE;
			[MINUS_TOKEN]:	CUR_VALUE = .CUR_VALUE - .TEMP_VALUE;
			[ASTERISK_TOKEN]: CUR_VALUE = .CUR_VALUE * .TEMP_VALUE;
			[SLASH_TOKEN]:	CUR_VALUE = .CUR_VALUE / .TEMP_VALUE;
			[AT_SIGN_TOKEN]: CUR_VALUE = .CUR_VALUE ^ .TEMP_VALUE;
			[LANGLE_TOKEN]:		0;		! No operation to perform
! * FUTURE *		[AMPERSAND_TOKEN]: CUR_VALUE = .CUR_VALUE AND .TEMP_VALUE;
! * FUTURE *		[EXCLAM_PT__TOKEN]: CUR_VALUE = .CUR_VALUE OR .TEMP_VALUE;
			[NEGATION_TOKEN]:	BEGIN
						FLAG = FALSE;
						CUR_VALUE = -.CUR_VALUE;
						IF (.STACK_PTR NEQU EXPR_STACK) ! Check for stack underflow
						THEN
							BEGIN
							STACK_PTR = CH$PTR(.STACK_PTR, -EXP$C_SIZE); ! Point to last entry
							CUR_OPERATOR = .STACK_PTR[EXP$B_OPERATOR];
							TEMP_VALUE = .CUR_VALUE;
							CUR_VALUE = .STACK_PTR[EXP$L_VALUE];
							END;
						END;
			[OTHERWISE]:	BEGIN
					SIGNAL(PAT$_INVOPR+MSG$K_INFO); ! Unrecognized operand
					RETURN(OPR_ERROR);
					END;
				TES;
			END
			UNTIL (.FLAG);
		CUR_OPERATOR = 0;
		NUMBER_FLAG = TRUE;
		END;


	[OTHERWISE]:					! Illegal token type
		BEGIN
		SIGNAL(PAT$_INVOPR+MSG$K_INFO);		! Unrecognized operand
		RETURN(OPR_ERROR);
		END;

		TES;
	END;							! End of REPEAT loop
END;

ROUTINE ENC_OPERAND ( INST_STG_DESC, OUT_BYTE_STREAM, PC_REL_CONTEXT, BRANCH_SIZE, OUT_PC_PTR, OPINFO_PTR ) =

!++
! Functional Description:
!
!	Scan (parse, whatever) the string that supposedly
!	represents one operand reference, and come up
!	with the machine code representation for it. 
!
! Inputs:
!
!	INST_STG_DESC	-A pointer to the counted string that
!			 contains the operand reference.
!	OUT_BYTE_STREAM	-A pointer to the output byte stream pointer
!			 that is being maintained by the routine
!			 we are called by.
!	PC_REL_CONTEXT	-The number of bytes that we should encode
!			 into the output byte stream to correspond to
!			 a PC-relative (literal) operand.  
!	BRANCH_SIZE	-The number of  bytes that we should allow
!			 if the current operand tries to use branch
!			 type addressing.  0 => do not allow branch operands.
!	OUT_PC_PTR	-A pointer to the pointer that we maintain that
!			 indicates where the next byte of instruction we
!			 generate will go.  This is used to calculate
!			 PC-displacement values.
!
! Implicit Inputs:
!
!	None.
!
! Outputs:
!
!	The bytes that correspond to the operand reference are
!	stuffed into the vector pointed to by the pointer
!	contained in the location pointed to by OUT_BYTE_STREAM.
!	This pointer is also updated so that it points to the
!	next vacant byte position.
!
! Routine Value:
!
!	TRUE - If successfully encoded.
!	PAT$K_BR_RANGE - If branch offset exceeds range allowed for instruction.
!	SIGNALs if an error is found and returns FALSE for the caller to
!	output the instruction.
!
! Side Effects:
!
!	None.
!--

BEGIN
MAP
	!++
	! The reason why the following 2 are REFs to LONGs instead of to BYTEs
	! is because they are actually REF REF VECTOR[,BYTE], which we can only
	! achieve (so far!?) via a REF LONG.  Even this only works because LONG
	! happens to be the size of a REF BYTE (or of any REF, for that matter).
	!--
	OPINFO_PTR : REF BLOCK[OPTSIZE, BYTE],
	OUT_PC_PTR : REF VECTOR[,LONG],
	OUT_BYTE_STREAM : REF VECTOR[,LONG],
	INST_STG_DESC : REF BLOCK [, BYTE];

LOCAL
	TOKEN_STRING : VECTOR[ CHS_PER_LEXEME, BYTE],
	LEXEME_BUFFER : VECTOR[ CHS_PER_LEXEME, BYTE],
	lexeme_stg_desc : BLOCK [12, BYTE],
	OUT_BYTE_PTR : REF VECTOR[,BYTE],
	TOKEN_TYPE : BYTE,
	AT_FLAG,
	MODE;

BIND
	TOKEN_LONG = TOKEN_STRING : VECTOR[,LONG];

MACRO
	!++
	! This macro is used to call the routine to check for indexing and
	! actually output the bytes of 'instruction' into the instruction
	! stream.  The reason why we use this macro is because it inserts the
	! first 2 parameters for us, (we may later use GLOBALs for this),
	! and because we may later have to make the control string parameter a
	! counted string if we find that 4 characters (a longword) are not enough.
	!--
	OUT_CODE ( CTRL_STRING ) =
		BEGIN
		IF (NOT INST_OUTPUT (	.OUT_BYTE_STREAM,
					.OUT_PC_PTR,
					.INST_STG_DESC,
					CTRL_STRING,
					%REMAINING
				    ) )
		THEN
			RETURN FALSE;
		END
		%,

	!++
	! How we usually make up the dominant mode addressing byte.
	!--
	MAKE_A_MODE ( DMODE ) =
		( (DMODE ^ 4) OR .TOKEN_STRING[0])
		%,

	!++
	! This macro creates the dominant mode for PC addressing.
	!--
	MAKE_PC_MODE ( DMODE ) =
		( (DMODE ^4) OR PC_REG )
		%;

!++
! Fetch the first token from the instruction string, and take action depending
! on it.  If the first token is an 'at' sign, simply set a flag for later
! reference, extract the next token, and continue on.
!--
AT_FLAG = FALSE;
OUT_BYTE_PTR = .OUT_BYTE_STREAM[0];
IF ((TOKEN_TYPE = GET_NEXT_TOKEN(.INST_STG_DESC, TOKEN_STRING)) EQL AT_SIGN_TOKEN)
THEN
	BEGIN
	AT_FLAG = TRUE;
	TOKEN_TYPE = GET_NEXT_TOKEN(.INST_STG_DESC, TOKEN_STRING);
	END;

!++
! Enforce branch-type syntax only when a branch operand
! is expected, and vice versa.
!--
IF (.TOKEN_TYPE NEQ BRANCH_TOKEN)
THEN
	IF (.BRANCH_SIZE NEQ 0)
	THEN
		BEGIN
		SIGNAL(PAT$_NOBRANCH+MSG$K_INFO);		! "Branch Operand Expected" error.
		RETURN(FALSE);
		END;

SELECTONE .TOKEN_TYPE OF
	SET

	[REGISTER_TOKEN]:

		!++
		! The operand is Rn, where 'n' was returned in the TOKEN_STRING.
		! Output the proper addressing mode byte, and increment the 
		! instruction stream pointer.  Note that indexing is not allowed
		! to follow REGISTER. Neither is the old MACRO11 notion of @Rx.
		!--
		BEGIN
		IF .AT_FLAG
		THEN
			BEGIN
			SIGNAL(PAT$_OPSYNTAX+MSG$K_INFO);	! "@Rx not equivalent to (Rx)" error.
			RETURN(FALSE);
			END
		ELSE
			OUT_CODE ( 'NB', (REGISTER_AMODE^4) OR .TOKEN_STRING[0] );
		END;

	[ABS_LIT_TOKEN]:
		!++
		! This is either 'short literal', 'PC-Relative Literal', or
		! Absolute addressing, depending on whether the string began
		! with '@' or not, and on the number of bits needed to encode
		! the number.
		!--
		IF .AT_FLAG
		THEN
			!++
			! Absolute addressing is actually a PC-relative
			! mode with longword context.  Note that this
			! one may be followed by [ Rx ], which means
			! that we have indexing.
			!--
			OUT_CODE( 'YBD',
				  MAKE_PC_MODE(AT_PC_REL_MODE),
				  A_LONGWORD,
				  TOKEN_STRING)
		ELSE
			!++
			! This is an immediate operand.  If it will fit into 6
			! bits, generate 'short literal' addressing, otherwise
			! generate a PC-relative (immediate) mode.
			!--	
			IF (.TOKEN_LONG[0] GTRU 63)
			THEN
				BEGIN
				!++
				! The literal is too big for a 6-bit field.
				! Therefore use a PC-relative mode and insert
				! the literal into the instruction stream.
				! Unfortunately, the number of bits to use is
				! NOT a function of how large the literal is,
				! instead this is dictated by the so-called
				! 'context' of this instruction.
				!--
				IF (.PC_REL_CONTEXT GTR A_LONGWORD)
				THEN
					BEGIN
					!++
					! QUADword literals not supported.
					! GET_NEXT_TOKEN (i.e. PAT$RADX_CONVRT)
					! would have to be changed to insert 8
					! bytes into TOKEN_STRING.
					!--
					SIGNAL (PAT$_NOTDONE+MSG$K_INFO);
					RETURN(FALSE);
					END;
	
				!++
				! See if truncation will occur by checking
				! on whether the longword which the number is
				! taken from is different from the number as
				! extracted by the hardware - ie, with sign extension.
				!--
				IF (.TOKEN_LONG[0] NEQ
				    .(TOKEN_STRING[0])<0,.PC_REL_CONTEXT*BITS_PER_BYTE, 1>)
				THEN
					! The following code may be eliminated 
					! when RADX_CONVRT takes the length into
					! account.  For now a further check is
					! made to see if the bits discarded 
					! simply weren't given.
					!--
					INCR I FROM .PC_REL_CONTEXT TO LONG_LENGTH -1
						DO
						IF (.TOKEN_STRING[.I] NEQ 0)
						THEN
							BEGIN
							SIGNAL (PAT$_NUMTRUNC);
							EXITLOOP;
							END;

				!++
				! SRM says that #constant[Rx] is
				! supported, however, to be like MARS,
				! PATCH generates an error for it.
				!--
				OUT_CODE( 'NBD',
					  MAKE_PC_MODE( PC_REL_MODE ),
					  .PC_REL_CONTEXT,
					  TOKEN_STRING)
				END
			ELSE
				!++
				! Short literals have to fit in 6 bits.
				! They also can not be indexed.
				!--
				OUT_CODE( 'NB', MAKE_A_MODE( SHORT_LIT_AMODE ) );


	[BRANCH_TOKEN]:			! For branch type operand addressing,
					! and for assumed PC-displacement addressing.
		BEGIN
		BIND
			ACTUAL_OPRND = TOKEN_STRING[1] : VECTOR[,LONG];

		!++
		! Check the flag passed in byte 0 of the token string.  A zero
		! here means that the associated number is a branch operand
		! exactly what is to be placed in the instruction.  A 1 here
		! means that the number must be made into a PC-relative offset
		! - ie, it is absolute, and that it may or may not be a branch
		! operand.
		!--
		IF (.TOKEN_STRING[0]) AND (.OPINFO_PTR[OP_NUMOPS] NEQ ASM_DIR_OP)
		THEN
			BEGIN
			!++
			! To calculate the PC-relative value, start with a
			! pointer to where the actual operand will be placed,
			! add in the length of the operand because that will
			! be the VAX PC after it has been used to
			! pick up the operand, and then subtract
			! from that the absolute (virtual) destination.
			! This gives the number of bytes which have to be
			! added to the PC to get the address of the destination
			!--
			ACTUAL_OPRND[0] = .ACTUAL_OPRND[0] - (.OUT_PC_PTR[0] + .BRANCH_SIZE);
			IF (.BRANCH_SIZE EQL 0)
			THEN
				!++
				! If BRANCH_SIZE is not the right size
				! (of displacement) to add, assume and use
				! LONGWORD displacement. Take into consideration
				! the fact that there will be a 1-byte MODE
				! field before the displacement, and perhaps
				! also a 1-byte index field, as well as the
				! displacement itself.
				!--
				ACTUAL_OPRND[0] = .ACTUAL_OPRND[0]
						- (A_LONGWORD + A_BYTE +
							ASSUME_AT_PC(.INST_STG_DESC));
		END;

		!++
		! Check for branch overflow - the user trying to branch further
		! than the instruction can 'reach'.  First, check this is a branch.
		!--
		IF (.BRANCH_SIZE NEQ 0)
		THEN
			BEGIN
			!++
			! Overflow happens when all bits in the unused part of
			! the LONG which we are using to contain the branch
			! operand are not the same as the 'sign' bit of the
			! branch operand.  We find this out by extracting the
			! branch operand as the hardware would (ie, with sign
			! extension), and then comparing to see if this is the
			! same as what we have calculated.
			! For assembler directives, there is no such thing as
			! the "sign bit".  Therefore the test is made with a
			! zero extend extraction.
			!--	
			IF (.OPINFO_PTR[OP_NUMOPS] NEQ ASM_DIR_OP)
			THEN
				BEGIN
				IF (.ACTUAL_OPRND[0] NEQ
					 .(ACTUAL_OPRND)<0,.BRANCH_SIZE*BITS_PER_BYTE, 1>)
				THEN
					!++
					! "Branching Out-of-Range" error.
					!--
					BEGIN
					PAT$GL_BR_DISPL = .ACTUAL_OPRND[0];
					OUT_CODE('ND', .BRANCH_SIZE, ACTUAL_OPRND[0]);
					RETURN(PAT$K_BR_RANGE);
					END;
				END
			ELSE
				BEGIN
				IF (.ACTUAL_OPRND[0] NEQ
					 .(ACTUAL_OPRND)<0,.BRANCH_SIZE*BITS_PER_BYTE, 0>)
				THEN
					SIGNAL(PAT$_NUMTRUNC);
				END;
	
			!++
			! Branch operand is OK.  Output
			! the code and don't allow indexing.
			!--
			OUT_CODE('ND', .BRANCH_SIZE, ACTUAL_OPRND[0]);
			END
		ELSE
			BEGIN
			!++
			! PC-displacement operands are similar at this point
			! except that indexing must be allowed and longword
			! (deferred) displacement.  This code is the same as
			! that at the end of case [BYTE_VAL_TOKEN], etc, below;
			! PATCH relys on the compiler to combine the code rather
			! than putting it into a special-purpose routine.
			!--
			LEXEME_BUFFER[0] = PC_REG;
			TOKEN_STRING[0] = A_LONGWORD;
			MODE = DISP_LONG_AMODE;
			IF .AT_FLAG
			THEN
				MODE = .MODE +1;

			!++
			! Pass back the single mode byte followed by the counted
			! byte stream calculated.  Indexing is allowed in all cases.
			!--
			OUT_CODE( 'YBC',
				  ((.MODE^4) OR .LEXEME_BUFFER[0]),
				  TOKEN_STRING);
			END;
		END;
	

	[MINUS_TOKEN]:
		BEGIN
		!++
		! This must be auto decrement, '-(Rn)', or
		! auto decrement indexed, '-(Rn)[Rx]'.
		!--
		IF (GET_NEXT_TOKEN(.INST_STG_DESC, TOKEN_STRING) NEQ AT_REG_TOKEN)
		THEN
			BEGIN
			SIGNAL(PAT$_OPSYNTAX+MSG$K_INFO);	! (Rn) required for auto-decrement
			RETURN(FALSE);
			END;

		!++
		! Check for indexing and output the instruction.
		!--
		IF .AT_FLAG 
		THEN
			BEGIN
			!++
			! "Deferred Auto Decrement Not Allowed" error.
			!--
			SIGNAL(PAT$_OPSYNTAX+MSG$K_INFO);
			RETURN(FALSE);
			END
		ELSE
			OUT_CODE('YB', MAKE_A_MODE(AUTO_DEC_AMODE));
		END;


	[AT_REG_TOKEN]:
		BEGIN

		LOCAL
			INPUT_PTR,
			CHAR;

		!++
		! This form is either register deferred, '(reg)', auto increment,
		! '(reg)+', auto increment deferred, '@(reg)+', or any one of
		! these plus indexing.
		!--
		MODE = REG_DEF_AMODE;

		!++
		! A following '+' indicates one of the auto inc modes.
		!--
		INPUT_PTR = .INST_STG_DESC [dsc$a_pointer];
		CHAR = CH$RCHAR (.INPUT_PTR);
		IF (.CHAR EQL '+')
		THEN
			BEGIN
			!++
			! Update the counted-string pointer,
			! and decide which auto inc mode we have.
			!--
			MODE = AUTO_INC_AMODE;
			IF .AT_FLAG
			THEN
				MODE = .MODE +1;
				! MODE = AUTO_INC_DEF_AMODE;  ! Generates longer code.
			INST_STG_DESC [dsc$a_pointer] = CH$PLUS (.INPUT_PTR, 1);
			INST_STG_DESC [DSC$W_LENGTH] = .INST_STG_DESC [DSC$W_LENGTH] - 1;
			END
		ELSE
			IF .AT_FLAG
			THEN
				BEGIN
				SIGNAL(PAT$_OPSYNTAX+MSG$K_INFO);! "@(Rn) Not Supported" error.
				RETURN(FALSE);
				END;

		!++
		! In all cases PATCH allows indexing.
		!--
		OUT_CODE( 'YB', MAKE_A_MODE( .MODE ) );
		END;

	[BYTE_VAL_TOKEN,
	 WORD_VAL_TOKEN,
	 LONG_VAL_TOKEN]:
		BEGIN
		BIND
			ACTUAL_OPRND = TOKEN_STRING[1] : VECTOR[,LONG];
		LOCAL
			INDEXING;
		
		!++
		! Displacement or Deferred Displacement addressing.
		!
		! Here PATCH must 'look ahead' to see if an actual register to
		! displace off has been given.  If not, assume "(PC)" and 
		! treat the displacement as a virtual address, calculating what
		! real displacement must be used given that the PC is the same
		! as the address into which the instruction is being deposited.
		!--
		IF ((INDEXING = ASSUME_AT_PC(.INST_STG_DESC)) GEQ 0)
		THEN
			BEGIN
			!++
			! Ok to assume PC-displacement mode.  This means that
			! the given displacement is the virtual address to be
			! reached, so this field must be converted to a real
			! displacement.  To do this PATCH calculates what the PC
			! will be after it has been used to pick up the
			! displacement to find out how much this displacement
			! must be.   The INDEXING value returned above indicates
			! how many bytes will be output due to indexed addressing.
			!--
			ACTUAL_OPRND[0] = .ACTUAL_OPRND[0]
					- (.OUT_PC_PTR[0] + .TOKEN_STRING[0] + A_BYTE + .INDEXING);

			!++
			! Also fake the user having said "(PC)"
			! by filling in LEXEME_BUFFER with the
			! right AT_REGister name.
			!--
			LEXEME_BUFFER[0] = PC_REG;

			!++
			! Check for trying to branch too far.  Here, the check
			! must be ensuring that the unused bits in the LONG
			! version of ACTUAL_OPRND are the same as the sign bit
			! of the actual displacement part of ACTUAL_OPRND.
			!--
			REPEAT
				BEGIN
				IF (.ACTUAL_OPRND[0] NEQ
				    .(ACTUAL_OPRND)<0,.TOKEN_STRING[0]*BITS_PER_BYTE, 1>)
				THEN
					IF (.PAT$GL_CONTEXT[INST_SUBST]) AND
					   (.TOKEN_STRING[0] LSS LONG_LENGTH)
					THEN
						BEGIN
						ACTUAL_OPRND[0] = .ACTUAL_OPRND[0] + .TOKEN_STRING[0];
						IF (.TOKEN_TYPE EQL BYTE_VAL_TOKEN)
						THEN
							BEGIN
							TOKEN_STRING[0] = WORD_LENGTH;
							TOKEN_TYPE = WORD_VAL_TOKEN;
							END
						ELSE
							BEGIN
							TOKEN_STRING[0] = LONG_LENGTH;
							TOKEN_TYPE = LONG_VAL_TOKEN;
							END;
						ACTUAL_OPRND[0] = .ACTUAL_OPRND[0] - .TOKEN_STRING[0];
						END
					ELSE
						BEGIN
						SIGNAL(PAT$_BRTOOFAR+MSG$K_INFO, 1, .ACTUAL_OPRND[0]);
						EXITLOOP;
						END
				ELSE
					EXITLOOP;
				END;
			END
		ELSE
			BEGIN
			!++
			! Check that the displacement is followed
			! by a register reference in parenthesis.
			!--
			IF (GET_NEXT_TOKEN(.INST_STG_DESC, LEXEME_BUFFER) NEQ AT_REG_TOKEN)
			THEN
				BEGIN
				SIGNAL(PAT$_OPSYNTAX+MSG$K_INFO); ! "Must Displace off a Reg" error.
				RETURN(FALSE);
				END;

			!++
			! Check for displacement truncation and produce a
			! message if this will occur.  Here the check is based
			! on the sign bit of the actual displacement, as done
			! to check this above.  Here, however, check whether or
			! not the upper bits of the given displacement are all
			! 0, and 'forgive' if this is true.  This nonsense is
			! necessary to avoid complaining when one says
			! "B^95(reg)".  Here the 95 is taken as a negative
			! number rather than assuming a large positive one was
			! intended.
			!--	
			IF (.ACTUAL_OPRND[0] NEQ
			    .(ACTUAL_OPRND)<0,.TOKEN_STRING[0]*BITS_PER_BYTE, 1 >)
			THEN
				!++
				! When RADX_CONVRT is changed to take size into
				! account (ie, to complain if the number is too
				! big), just produce a message at this point.
				! For now, however, ignore it if the unused
				! bytes are all zero.
				!--	
				BEGIN
	
				BIND
					ACTUAL_BYTES = ACTUAL_OPRND[0] : VECTOR[,BYTE];
	
				INCR I FROM .TOKEN_STRING[0] TO LONG_LENGTH -1
					DO
					IF(.ACTUAL_BYTES[.I] NEQ 0)
					THEN
						BEGIN
						REPEAT
							BEGIN
							IF (.ACTUAL_OPRND[0] NEQ
							    .(ACTUAL_OPRND)<0,.TOKEN_STRING[0]*BITS_PER_BYTE, 1>)
							THEN
								IF (.PAT$GL_CONTEXT[INST_SUBST]) AND
								   (.TOKEN_STRING[0] LSS LONG_LENGTH)
								THEN
									BEGIN
									ACTUAL_OPRND[0] = .ACTUAL_OPRND[0] + .TOKEN_STRING[0];
									IF (.TOKEN_TYPE EQL BYTE_VAL_TOKEN)
									THEN
										BEGIN
										TOKEN_STRING[0] = WORD_LENGTH;
										TOKEN_TYPE = WORD_VAL_TOKEN;
										END
									ELSE
										BEGIN
										TOKEN_STRING[0] = LONG_LENGTH;
										TOKEN_TYPE = LONG_VAL_TOKEN;
										END;
									ACTUAL_OPRND[0] = .ACTUAL_OPRND[0] - .TOKEN_STRING[0];
									END
								ELSE
									BEGIN
									SIGNAL(PAT$_BRTOOFAR+MSG$K_INFO, 1, .ACTUAL_OPRND[0]);
									EXITLOOP;
									END
							ELSE
								EXITLOOP;
							END;
						EXITLOOP;
						END;
				END;
			END;
		!++
		! Now calculate the right mode to use.  The following code is
		! extremely instruction-set dependent, and relies on the
		! relative values of the various displacement modes.
		! Essentially just start out with the lowest mode and keep
		! incrementing the mode.  This code is shorter but relies
		! on the relationship of the modes.
		!--
		MODE = DISP_BYTE_AMODE;
		IF (.TOKEN_TYPE GTR BYTE_VAL_TOKEN)
		THEN
			MODE = .MODE +2;
		IF (.TOKEN_TYPE GTR WORD_VAL_TOKEN)
		THEN
			MODE = .MODE +2;
		IF .AT_FLAG
		THEN
			MODE = .MODE +1;

		!++
		! Return the single mode byte followed by the counted byte
		! stream passed.  Indexing is allowed in all cases.
		!--
		OUT_CODE( 'YBC',
			  ((.MODE^4) OR .LEXEME_BUFFER[0]),
			  TOKEN_STRING);
		END;

	[OTHERWISE]:			! Error.

		BEGIN
		SIGNAL(PAT$_OPSYNTAX+MSG$K_INFO);		! "Operand Syntax" error.
		RETURN(FALSE);
		END;

	TES;

!++
! Return a pointer to the counted string which contains the rest of the operand
! reference.
!--
RETURN TRUE
END;

ROUTINE ASSUME_AT_PC( INST_STG_DESC ) =

!++
! Functional Description:
!
! This temporary routine is called when PATCH has read the <size> ^ <number>
! part of an <operand reference> to decide whether the person has left out the
! "(pc)".  This decision is made by looking ahead way to see if what follows
! could be legal assuming that he meant "(PC)".  In this case the only
! possibilities are that he wants indexing, or that this is the end of
! the operand reference.
!
! Inputs:
!
!	INST_STG_DESC	- String descriptor to what is left
!		 of the operand reference after the displacement
!		 or virtual address has been extracted.
!
! Returned Value:
!
!	0 or 1, if "(PC)" can be assumed,
!	-1, otherwise.  (DO_NOT_ASSUME)
!
!	0 => no indexing byte will be output, 
!	1 => one byte will be output for [ Rx ].
!
!	In no case is any part of the instruction string changed.
!	This routine has no side effects whatsoever.
!--

BEGIN

MAP
	INST_STG_DESC : REF BLOCK [, BYTE];

LOCAL
	INPUT_PTR : REF VECTOR[,BYTE];

MACRO
		DO_NOT_ASSUME = -1 %;				! Value returned if unable to make PC assumption

!++
! PATCH must believe the count part of the counted string and not overrun it.
! This should not be a problem, though, because the string ends with a null
! byte.  Also detect whether the reason for returning OK-to-assume-"(PC)" is
! because the operand is going to include indexing or not.  Do this based on the
! presence or absence of '['.
!--
IF (.INST_STG_DESC[DSC$W_LENGTH] EQL 0)
THEN
	RETURN(FALSE);
INPUT_PTR = CH$PTR (.INST_STG_DESC [DSC$A_POINTER]);
IF (.INPUT_PTR[0] EQL ASC_SQ_OPN_BRAK)
THEN
	RETURN(TRUE)
ELSE
	RETURN(DO_NOT_ASSUME);
END;

ROUTINE INST_OUTPUT (	OUT_BYTE_STREAM,
			OUT_PC_PTR,
			INST_STG_DESC,
			CTRL_STRING,
			ARG0,
			ARG1,
			ARG2
		    ) =
!++
! Functional Description:
!
!	This routine serves two purposes.
!	1) It checks whether an indexed operand reference
!	   has been made, and outputs the proper mode byte
!	   if it has.
!	2) It takes care of all other instruction byte
!	   output as well - not that this routine computes
!	   any of this - it just localizes such output.
!
! Calling Sequence:
!
!	INST_OUTPUT ()
!
! Inputs:
!
!	OUT_BYTE_STREAM	-The address of a pointer to where
!			 we are in the output stream.  The address
!			 is passed here so that we can both
!			 use and update this pointer.
!	OUT_PC_PTR	-The address of a pointer to where we
!			 will eventually be stuffing the encoded
!			 instruction in memory.  We both read
!			 and write (update) this pointer.
!	INST_CS_PTR	-The address of a pointer to the counted
!			 string which describes where we are at
!			 in operand encoding.  Again, a pointer is
!			 passed here so that we may update the cs-pointer.
!	CTRL_STRING	-A 4-character 'string' (a longword) which effectively
!			 controls the action taken by this routine.  The first
!			 (0th) character should be 'Y' or 'N', and is taken to
!			 indicate whether we should allow indexing
!			 for the current operand reference or not.
!			 The next 2 or 3 characters must be 1 of 'B', 'C', or 'D',
!			 and are used to indicate how the remaining parameters
!			 should be interpreted.  See below.
!			 The last of these characters must be 0 (null) to
!			 indicate when the routine should stop.
!	ARG?		-These args are interpretted differently depending
!			 on the 'control string'.  See above and below.
!
! Implicit Inputs:
!
!	None.
!
! Outputs:
!
!	None.
!
! Implicit Outputs:
!
!	The instruction bytes are copied into the output vector.
!
! Routine Value:
!
!	TRUE - if all went OK,
!	FALSE otherwise.  The only thing that can go wrong
!	is that we are prepared to allow indexing, see that the
!	indexing reference is started, ('[' is encountered),
!	but then don't get a proper completion of this token.
!--

BEGIN

MAP
	!++
	! The reason why the following 3 are REFs to LONGs instead of to BYTEs
	! is because they are actually REF REF VECTOR[,BYTE], which we can only
	! achieve (so far!?) via a REF LONG.
	!--
	OUT_PC_PTR  : REF VECTOR[,LONG],
	INST_STG_DESC : REF BLOCK [, BYTE],
	OUT_BYTE_STREAM : REF VECTOR[,LONG];

LOCAL
	CTRL_PTR : REF VECTOR[,BYTE],				! Examine the control string.
	OUT_BYTE_PTR : REF VECTOR[,BYTE],			! Pass back instruction bytes.
	ARG_PTR : REF VECTOR[,LONG],				! Used to pick up ARGx.
	TOKEN_BUFFER : VECTOR[ CHS_PER_LEXEME, BYTE],
	TOKEN_STG_DESC : BLOCK [12, BYTE];

!++
! Set up the various pointers.  The ARG_PTR is used to access each successive
! ARGx actual parameter.  Since this routine loops thru them, it can't use the
! formal parameter's name.
!--
ARG_PTR = ARG0;

!++
! CTRL_PTR points to the individual characters passed in the actual parameter,
! 'CTRL_STRING'.  Note that this is actually a literal, because the characters
! are contained within the parameter.
!--
CTRL_PTR = CTRL_STRING;

!++
! OUT_BYTE_PTR points to the location for the next byte in the instruction
! stream to be written.  This value is found by loading the contents of the cell
! pointed to by OUT_BYTE_STREAM.  The address of this pointer must be passed to
! enable the pointer to be incremented.
!--
OUT_BYTE_PTR = .OUT_BYTE_STREAM[0];

!++
! Likewise, the address of the current instruction-stream counted-string
! pointer, INST_CS, is passed.  Once again this provides the ability to update
! the pointer.
!--
TOKEN_STG_DESC [DSC$W_LENGTH] = 0;
TOKEN_STG_DESC [DSC$A_POINTER] = TOKEN_BUFFER;
TOKEN_STG_DESC [DSC$W_MAXLEN] = CHS_PER_LEXEME;

!++
! Whether or not indexing mode is allowed, is indicated by the first character
! in the control string.  'Y' means yes, and anything else means no.
!--
IF (.CTRL_PTR[0] EQL 'Y')
THEN
	BEGIN
	!++
	! Check for indexing.  The difficulty here is that this routine must
	! 'look ahead' before calling GET_NEXT_TOKEN because it will overwrite
	! the instruction string.  The string must be left untouched unless
	! indexing mode was actually specified.
	!--
	LOCAL
		INPUT_PTR,
		CHAR;

	INPUT_PTR = .INST_STG_DESC [DSC$A_POINTER];
	CHAR = CH$RCHAR (.INPUT_PTR);
	IF (.CHAR EQL '[')
	THEN
		BEGIN
		!++
		! Error if this is not an indexed reference.
		!--
		IF (GET_NEXT_TOKEN(.INST_STG_DESC, TOKEN_BUFFER) NEQ INDEXING_TOKEN)
		THEN
			BEGIN
			SIGNAL(PAT$_OPSYNTAX+MSG$K_INFO);
			RETURN(FALSE);
			END;

		!++
		! Output the indexing mode byte.
		!--
		OUT_BYTE_PTR[0] = (INDEXING_MODE ^ 4) OR .TOKEN_BUFFER[0];
		OUT_BYTE_PTR = .OUT_BYTE_PTR + BYTE_LENGTH;
		END;
	END;

!++
! Continue on according to the control string, breaking out of the loop when
! the first 0 byte is encountered.
!--
CTRL_PTR = .CTRL_PTR +1;
DO
	BEGIN
	BIND
		ARG_BYTE	= (.ARG_PTR) : REF VECTOR[,BYTE];
	
	SELECTONE .CTRL_PTR[0] OF
		SET

		['B']:	! Pass back 1 byte.

			BEGIN
			OUT_BYTE_PTR[0] = .ARG_PTR[0];
			OUT_BYTE_PTR = .OUT_BYTE_PTR +BYTE_LENGTH;
			ARG_PTR = .ARG_PTR +LONG_LENGTH;
			END;

		['C']:	! Counted byte string.

			BEGIN
			CH$MOVE(.ARG_BYTE[0], ARG_BYTE[1], .OUT_BYTE_PTR);
			OUT_BYTE_PTR = .OUT_BYTE_PTR + .ARG_BYTE[0];
			ARG_PTR = .ARG_PTR + LONG_LENGTH;
			END;

		['D']:	! Count + byte address.

			BEGIN
			CH$MOVE(.ARG_PTR[0], .ARG_PTR[1], .OUT_BYTE_PTR);
			OUT_BYTE_PTR = .OUT_BYTE_PTR + .ARG_PTR[0];
			ARG_PTR = .ARG_PTR + 2*LONG_LENGTH;
			END;

		[OTHERWISE]:	! Error.
			RETURN(0);

		TES;

	!++
	! Loop back to consider the next control character
	! until a null character is encountered.
	!--
	CTRL_PTR = .CTRL_PTR + 1;
	END

WHILE (.CTRL_PTR[0] NEQ 0);

!++
! Update the instruction-stream pointer which is being maintained by the routine
! which called this one.  This can be done as the address of the pointer was
! passed.  Also, this is possible this routine remembers the number of bytes it
! has written to the output byte stream.
!--
OUT_PC_PTR[0] = .OUT_PC_PTR[0] + (.OUT_BYTE_PTR - .OUT_BYTE_STREAM[0]);
OUT_BYTE_STREAM[0] = .OUT_BYTE_PTR;

!++
! Likewise, update the caller's instruction string pointer.
!--
RETURN(TRUE);
END;

ROUTINE OPCODE_MATCH (OPCO_STG_DESC, OPINFO_PTR) = 

!++
! Functional Description:
!
!	Look up the given opcode mnemonic in the OPINFO
!	table to see if it is there.  If so, return the
!	opcode and a pointer to the OPINFO table entry which 
!	corresponds to this opcode.
!
! Calling Sequence:
!
!	OPCODE_MATCH ()
!
! Inputs:
!
!	OPCO_STG_DESC	-String descriptor for the given opcode.
!	OPINFO_PTR	-The address of where we should copy the
!			 OPINFO record pointer when we find the
!			 one which corresponds to the given opcode.
! Implicit Inputs:
!
!	The OPINFO table.  See PATINS.B32
!
! Outputs:
!
!	None.
!
! Implicit Outputs:
!
!	A pointer to the OPINFO table entry that
!	corresponds to the found opcode mnemonic
!	is returned via the formal pointer OPINFO_PTR.
!
! Returned Value:
!
!	-1	-if the lookup fails or if there is insufficient
!		 information in the table entry for the program
!		 to continue.
!	The found OPCODE, otherwise.  This is non-standard,
!	so we use a local macro to draw attention to it.
!--

BEGIN

MACRO
	OPC_MATCH_ERROR = -1 %;					!  Error return for this routine.

MAP
	OPCO_STG_DESC : REF BLOCK [, BYTE],
	OPINFO_PTR : REF VECTOR[,LONG];

LOCAL
	ALIAS,
	OPCODE,
	OP_SIZE,
	OP_RAD50,
	OP_FROM_USER	:	VECTOR[ OP_CH_SIZE, BYTE ];

!++
! First check that the supposed opcode is not too long or too short.
! A zero cannot be returned as zero is a valid opcode.
!--
OP_SIZE = .OPCO_STG_DESC [DSC$W_LENGTH];
IF (.OP_SIZE GTR OP_CH_SIZE) OR (.OP_SIZE LEQ 0)
THEN
	RETURN(OPC_MATCH_ERROR);

!++
! Otherwise do the lookup linearly by first filling a local vector with spaces,
! copying in the given opcode mnemonic, and converting to RAD50 so longword
! compares can be used with the OPcodes encoded in the table.
!--
CH$COPY(.OP_SIZE, CH$PTR(.OPCO_STG_DESC[DSC$A_POINTER], 0), ASC_SPACE,
			OP_CH_SIZE, OP_FROM_USER);
OP_RAD50 = RAD50( OP_FROM_USER );
INCR OPCODE FROM 0 TO SIZOPINFO1-1 DO
	BEGIN
	!++
	! Extract the opcode from the OPINFO table, converting it to ASCII, and
	! compare this with what is being sought.
	!--
	IF .PAT$GB_OPINFO1[.OPCODE, OP_NAME] EQL .OP_RAD50
	THEN
		BEGIN
		!++
		! Pass back both the opcode (the current index into the table),
		! and the pointer to the current table entry.
		!--
		OPINFO_PTR[0] = PAT$GB_OPINFO1[ .OPCODE, OP_NAME ];
		RETURN(.OPCODE);
		END;
	END;

INCR OPCODE FROM 0 TO SIZOPINFO2-1 DO
	BEGIN
	!++
	! Extract the opcode from the OPINFO table, converting it to ASCII, and
	! compare this with what is being sought.
	!--
	IF .PAT$GB_OPINFO2[.OPCODE, OP_NAME] EQL .OP_RAD50
	THEN
		BEGIN
		!++
		! Pass back both the opcode (the current index into the table),
		! and the pointer to the current table entry.
		!--
		OPINFO_PTR[0] = PAT$GB_OPINFO2[ .OPCODE, OP_NAME ];
		RETURN(.OPCODE^8+%X'FD');
		END;
	END;

INCR ALIAS FROM 0 TO SIZALIAS-1 DO
	BEGIN
	!++
	! Extract the opcode from the ALIAS table, converting it to ASCII, and
	! compare this with what is being sought.
	!--
	IF .PAT$GB_ALIAS[.ALIAS, OP_NAME] EQL .OP_RAD50
	THEN
		BEGIN
		!++
		! Pass back both the opcode (the current index into the table),
		! and the pointer to the current table entry.
		!--
		OPCODE = .PAT$GB_ALIAS[ .ALIAS, AL_OPC ];
		OPINFO_PTR[0] = PAT$GB_OPINFO[ .OPCODE, OP_NAME ];
		RETURN(.OPCODE);
		END;
	END;

!++
! Failure, if routine falls through loop.
!--
RETURN(OPC_MATCH_ERROR);
END;

ROUTINE MAR_GET_LEX (INPUT_STG_DESC, LEXEME_STG_DESC) = 

!++
! Functional Description:
!
!	Extracts a lexeme from the input stream by calling the routine
!	PAT$MAR_GET_LEX.  First MAR_GET_LEX zeros the lexeme buffer.
!	The value of the routine is the token in the character string
!	pointed to by LEXEME_STG_DESC, the string descriptor for the lexeme.
!	Also the input buffer string descriptor is updated.
!
! Calling Sequence:
!
!	MAR_GET_LEX ( INPUT_STG_DESC, LEXEME_STG_DESC)
!
! Inputs:
!
!	INPUT_STG_DESC - String descriptor for input line
!	LEXEME_STG_DESC - String descriptor for lexeme found
!
! Implicit Inputs:
!
!	NONE
!
! Outputs:
!
!	None.
!
! Implicit Outputs:
!
!	The string descriptors are updated.
!
! Returned Value:
!
!	An encoded representation of the token found.
!
!--

BEGIN

MAP
	INPUT_STG_DESC : REF BLOCK [, BYTE],
	LEXEME_STG_DESC : REF BLOCK[,BYTE];

!++
! First zero out the buffer which will hold the lexeme found.
!--
ZEROCOR (.LEXEME_STG_DESC[DSC$A_POINTER], (.LEXEME_STG_DESC[DSC$W_MAXLEN]/4));
RETURN(PAT$MAR_GET_LEX(.INPUT_STG_DESC, .LEXEME_STG_DESC));
END;

ROUTINE ADD_LEX_T_OPRND (LEX_STG_DESC, OPRND_STG_DESC, MAX_BUF_SIZ) : NOVALUE = 

!++
! Functional Description:
!
!	This routine takes an ASCII lexeme and adds it to an operand buffer.
!	It may be used to take any ASCII string described by a string
!	descriptor and add it to a buffer described by another string
!	descriptor.  The string descriptor for the latter is updated to
!	include the new ASCII string.  The third input parameter gives the
!	maximum size of the operand buffer.
!
! Calling Sequence:
!
!	ADD_LEX_T_OPRND ( LEX_STG_DESC, OPRND_STG_DESC)
!
! Inputs:
!
!	LEX_STG_DESC - String descriptor for input lexeme
!	OPRND_STG_DESC - String descriptor for resultant operand string
!	MAX_BUF_SIZ - Size of the buffer pointed to by OPRND_STG_DESC
!
! Implicit Inputs:
!
!	NONE
!
! Outputs:
!
!	None.
!
! Implicit Outputs:
!
!	The lexeme string is written into the next free bytes of the operand
!	buffer.  The string descriptor for the resultant string, OPRND_STG_DESC,
!	is updated.  If the combined string is too large for the buffer
!	then an error is SIGNALed.
!
! Returned Value:
!
!	none
!
!--

BEGIN

MAP
	LEX_STG_DESC : REF BLOCK [, BYTE],
	OPRND_STG_DESC : REF BLOCK[,BYTE];

!++
! Fisrt check that there is room in the operand buffer for the lexeme string.
!--
IF ((.LEX_STG_DESC[DSC$W_LENGTH] + .OPRND_STG_DESC[DSC$W_LENGTH]) GTR .OPRND_STG_DESC[DSC$W_MAXLEN])
THEN
	SIGNAL(PAT$_OPRNDLNG+MSG$K_WARN, 4, .OPRND_STG_DESC[DSC$W_LENGTH],
		.OPRND_STG_DESC[DSC$A_POINTER], .LEX_STG_DESC[DSC$W_LENGTH],
		.LEX_STG_DESC[DSC$A_POINTER]);

!++
! Plenty of room in buffer.  Move the lexeme string into the buffer, starting
! at the next unused byte in the buffer.
!--
CH$MOVE(.LEX_STG_DESC[DSC$W_LENGTH], .LEX_STG_DESC[DSC$A_POINTER],
	CH$PTR(.OPRND_STG_DESC[DSC$A_POINTER], .OPRND_STG_DESC[DSC$W_LENGTH]));

!++
! Now update the operand string descriptor to include the appended lexeme.
!--
OPRND_STG_DESC[DSC$W_LENGTH] = .OPRND_STG_DESC[DSC$W_LENGTH] + .LEX_STG_DESC[DSC$W_LENGTH];
RETURN;
END;

GLOBAL ROUTINE PAT$REDUCE_INS (INS_PTR, EDITED_INS_DESC) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine takes an ASCIC symbolic instruction and outputs a
!	reduced ASCII instruction, that is, one with expressions reduces to
!	single values and symbolic names replaced with values.  The resultant
!	instruction is written into the buffer pointed to by EDITED_INS_DESC.
!	The string descriptor is updated to contain the edited length.
!
! FORMAL PARAMETERS:
!
!	INS_PTR - Pointer to the symbolic instruction to be reduced
!	EDITED_INS_DESC - String descriptor for output buffer
!
! IMPLICIT INPUTS:
!
!	EDITED_INS_DESC is already initialized.
!
! IMPLICIT OUTPUTS:
!
!	The reduced instruction is written into the output buffer.
!
! ROUTINE VALUE:
!
!	none
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	If the reduction could not be performed, then an error message is
!	SIGNALed and an UNWIND is performed.
!	EDITED_INS_DESC contains an updated length.
!
!--

BEGIN

MAP
	EDITED_INS_DESC : REF BLOCK[,BYTE],			! String descriptor for reduced instruction
	INS_PTR : REF VECTOR[,BYTE];				! Pointer to input instruction (ASCIC)
LOCAL
	CHAR : BYTE,						! Next character in instruction string
	INSTRUC_PTR : REF VECTOR[,BYTE],			! Local pointer into instruction
	LABEL_FLAG,						! Label flag
	INS_STG_DESC : BLOCK[8,BYTE],				! String descriptor for non-reduced part of input instruction
	LEXEME_DESC : BLOCK[12,BYTE],				! String descriptor for current lexeme
	LEX_BUF : BLOCK[CHS_PER_LEXEME,BYTE],			! Buffer to hold current lexeme
	OPR_FLAG;						! Operand flag

LITERAL
	SPACE = %X'20',						! ASCII value for space
	COMMA = %X'2C';						! ASCII value for comma

!++
! Define a string descriptor for the instruction to be reduced.
!--
INS_STG_DESC[DSC$W_LENGTH] = .INS_PTR[0];
INS_STG_DESC[DSC$A_POINTER] = INS_PTR[1];
INS_PTR[.INS_PTR[0]+1] = 0;					! Set an end-of-line indicator

!++
! Get the first lexeme which will be either a label or the opcode.
! Put it into the output buffer.  Then search for the next significant
! character.  If it is a colon, then move the colon into the output buffer
! and get the opcode and move it in also.
!--
LABEL_FLAG = TRUE;
EDITED_INS_DESC[DSC$W_LENGTH] = 0;
LEXEME_DESC[DSC$A_POINTER] = LEX_BUF;
LEXEME_DESC[DSC$W_MAXLEN] = CHS_PER_LEXEME;
REPEAT
	BEGIN
	LEXEME_DESC[DSC$W_LENGTH] = 0;
	MAR_GET_LEX(INS_STG_DESC, LEXEME_DESC);
	CH$COPY(.LEXEME_DESC[DSC$W_LENGTH], .LEXEME_DESC[DSC$A_POINTER], SPACE,
		  .LEXEME_DESC[DSC$W_LENGTH]+1,
		  CH$PTR(.EDITED_INS_DESC[DSC$A_POINTER], .EDITED_INS_DESC[DSC$W_LENGTH]));
	EDITED_INS_DESC[DSC$W_LENGTH] = .EDITED_INS_DESC[DSC$W_LENGTH] +
					.LEXEME_DESC[DSC$W_LENGTH] + 1;
	IF .LABEL_FLAG
	THEN
		BEGIN
		INSTRUC_PTR = .INS_STG_DESC[DSC$A_POINTER];
		DO
			CHAR = CH$RCHAR_A(INSTRUC_PTR)
		UNTIL ((.CHAR NEQU ' ') AND (.CHAR NEQU '	'));
		IF (.CHAR NEQU ':')
		THEN
			EXITLOOP;
		CH$MOVE(1, CHAR, CH$PTR(.EDITED_INS_DESC[DSC$A_POINTER], .EDITED_INS_DESC[DSC$W_LENGTH]));
		EDITED_INS_DESC[DSC$W_LENGTH] = .EDITED_INS_DESC[DSC$W_LENGTH] + 1;
		INS_STG_DESC[DSC$W_LENGTH] = .INS_STG_DESC[DSC$W_LENGTH] +
				.INS_STG_DESC[DSC$A_POINTER] - .INSTRUC_PTR;
		INS_STG_DESC[DSC$A_POINTER] = .INSTRUC_PTR;
		LABEL_FLAG = FALSE;
		END
	ELSE
		EXITLOOP;
	END;

!++
! Now loop to get each operand.  The call to GET_OPERAND reduces all
! the expressions and symbols in the operand to absolute numbers.
! The only exception is user defined symbols.  These remain un-reduced
! to allow correct use of PATCH area addresses in the command file.
!--
REPEAT
	BEGIN
	LEXEME_DESC[DSC$W_LENGTH] = 0;
	LEXEME_DESC[DSC$A_POINTER] = LEX_BUF;
	IF NOT (OPR_FLAG = GET_OPERAND(INS_STG_DESC, LEXEME_DESC, FALSE))
	THEN
		BEGIN
		!++
		! No more operands.  Return successfully.
		!--
		EDITED_INS_DESC[DSC$W_LENGTH] = .EDITED_INS_DESC[DSC$W_LENGTH] - 1;
		RETURN;
		END;

	!++
	! If this is an operand containing an user-defined symbol, then
	! the string ends with a comma or null.  Ignore this character.
	!--
	IF (.OPR_FLAG EQLU OPR_FORW_REF)
	THEN
		LEXEME_DESC[DSC$W_LENGTH] = .LEXEME_DESC[DSC$W_LENGTH] - 1;
	IF (.LEXEME_DESC[DSC$W_LENGTH] + .EDITED_INS_DESC[DSC$W_LENGTH] + 1)
		 GTR .EDITED_INS_DESC[DSC$W_MAXLEN]
	THEN
		BEGIN
		SIGNAL(PAT$_OUTCMDLNG+MSG$K_SEVERE);
		END;
	CH$COPY(.LEXEME_DESC[DSC$W_LENGTH], .LEXEME_DESC[DSC$A_POINTER], COMMA,
	  .LEXEME_DESC[DSC$W_LENGTH]+1,
	  CH$PTR(.EDITED_INS_DESC[DSC$A_POINTER], .EDITED_INS_DESC[DSC$W_LENGTH]));
	EDITED_INS_DESC[DSC$W_LENGTH] = .EDITED_INS_DESC[DSC$W_LENGTH] +
					.LEXEME_DESC[DSC$W_LENGTH] + 1;
	END;
END;								! End of PAT$REDUCE_INS

GLOBAL ROUTINE PAT$RESOLVE_INS (BUFFER_PTR) : NOVALUE  =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine resolves all the forward references in the FWR table.
!	It encodes the operands and enters them into the appropriate bytes
!	in the buffers.
!
! FORMAL PARAMETERS:
!
!	BUFFER_PTR - Address of the descriptor for the buffer holding the
!			binary instruction stream to be resolved
!
! IMPLICIT INPUTS:
!
!	PAT$GL_FWRLHD - ForWard Reference table listhead
!
! IMPLICIT OUTPUTS:
!
!	The resolved operands are witten into the instruction byte streams.
!
! ROUTINE VALUE:
!
!	FALSE - if any resolution fails.
!	TRUE - if all resolutions were successful.
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	none
!
!--

BEGIN

MAP
	BUFFER_PTR : REF BLOCK[,BYTE];				! String descriptor for binary instruction buffer

LOCAL
	OUT_BYTE_PTR,						! Pointer into output buffer
	POINTER : REF BLOCK[,BYTE],				! Pointer to forward reference table entry
	OPR_FLAG,						! Flag if operand found valid
	INST_STG_DESC : BLOCK [8, BYTE],			! Instruction string descriptor
	OPINFO_PTR : REF BLOCK[ OPTSIZE, BYTE],			! Pointer into the OPINFO table
	BRANCH_SIZE,
	OPRND_STG_DESC : BLOCK[12,BYTE],			! String descriptor for next operand
	OPRND_BUF : VECTOR[MAX_BUF_SIZ,BYTE];			! Buffer to hold next operand

!++
! Now loop, resolving each forward reference in the table.
!--
WHILE (.PAT$GL_FWRLHD NEQA 0)
DO
	BEGIN
	POINTER = .PAT$GL_FWRLHD;
	INST_STG_DESC [DSC$W_LENGTH] = .POINTER[FWR$W_OPRNDLNG];
	INST_STG_DESC [DSC$a_pointer] = .POINTER[FWR$A_OPRNDADR];
	OPRND_STG_DESC[DSC$W_LENGTH] = 0;
	OPRND_STG_DESC[DSC$A_POINTER] = OPRND_BUF;
	OPRND_STG_DESC[DSC$W_MAXLEN] = MAX_BUF_SIZ;
	OPR_FLAG = GET_OPERAND( INST_STG_DESC, OPRND_STG_DESC, TRUE);
	IF (NOT .OPR_FLAG) OR (.OPR_FLAG EQLU OPR_FORW_REF)
	THEN
		SIGNAL(PAT$_INVOPRND+MSG$K_WARN, 2, .POINTER[FWR$W_OPRNDLNG], .POINTER[FWR$A_OPRNDADR]);

	!++
	! Extract and encode one operand reference.  Give up if this fails.
	!--
	BRANCH_SIZE = NO_BR;
	OUT_BYTE_PTR = CH$PTR(.BUFFER_PTR[DSC$A_POINTER], .POINTER[FWR$B_BUFOFF]);
	OPINFO_PTR = .POINTER[FWR$A_OPINFO];
	IF (.OPINFO_PTR[OP_NUMOPS] EQL .POINTER[FWR$B_NTHOPRND]) OR
	   (.OPINFO_PTR[OP_NUMOPS] EQL ASM_DIR_OP)
	THEN
		IF (.POINTER[FWR$B_NTHOPRND] LSS MAXOPRNDS) OR
		   (.OPINFO_PTR[OP_NUMOPS] EQL ASM_DIR_OP)
		THEN
			BEGIN
			BRANCH_SIZE = .OPINFO_PTR[OP_BR_TYPE];
			IF (.BRANCH_SIZE EQLU BR_LG)
			THEN
				BRANCH_SIZE = A_LONGWORD;
			END;
	IF NOT (PAT$GL_ERRCODE = ENC_OPERAND( OPRND_STG_DESC, OUT_BYTE_PTR,
				    1 ^ .OPINFO_PTR[ OP_CONTEXT(.POINTER[FWR$B_NTHOPRND]) ],
				    .BRANCH_SIZE,  POINTER[FWR$L_PC], .OPINFO_PTR))
	THEN
		BEGIN
		!++
		! "Operand Syntax" error.  Instruction substution cannot be
		! done as it would alter all the offsets in the ForWard Reference
		! table (FWR$B_BUFOFF fields) and the remaining resolutions
		! would be written into the wrong places in the buffer.
		!--
		IF (.PAT$GL_ERRCODE EQL PAT$K_BR_RANGE)
		THEN
			SIGNAL(PAT$_BRTOOFAR+MSG$K_INFO);
		SIGNAL(PAT$_INVOPRND+MSG$K_WARN, 2, .POINTER[FWR$W_OPRNDLNG], .POINTER[FWR$A_OPRNDADR])
		END;
	IF (.OPRND_STG_DESC[DSC$W_LENGTH] NEQ 0)
	THEN
		SIGNAL(PAT$_INVOPRND+MSG$K_WARN, 2, .POINTER[FWR$W_OPRNDLNG],
			.POINTER[FWR$A_OPRNDADR]);
	PAT$GL_FWRLHD = .POINTER[FWR$L_FLINK];
	PAT$FREERELEASE(.POINTER, (FWR$C_SIZE + 3)/4);
	END;
RETURN;
END;								! End of PAT$RESOLVE_INS

END
ELUDOM

