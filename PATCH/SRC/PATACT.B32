MODULE PATACT (
		ADDRESSING_MODE (EXTERNAL = GENERAL, NONEXTERNAL = LONG_RELATIVE),
		IDENT = 'V03-000') =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	PATCH
!
! ABSTRACT:
!
!	End of command line action routine plus a few other parsing
!	action routines.
!
! ENVIRONMENT:	STARLET, user mode, interrupts disabled.
!
! Version:	V02-029
!
! History:
!	Author:
!		Carol Peters, 03 Jul 1976: Version 01
!
!
! MODIFIED BY:
!
!	V02-029	MTR0003		Mike Rhodes		03-Feb-1982
!		Modify the SET PATCH_AREA/INITIALIZE logic to check for
!		a minimum available patch area size of 12 bytes.  This
!		allows 8 bytes for the descriptor plus 1 longword of data.
!
!	V02-028	MTR0002		Mike Rhodes		01-Oct-1981
!		Add new qualifier to the SET PATCH_AREA command to allow
!		the user to Initialize a descriptor within the patch area.
!
!		SET PATCH_AREA /INITIALIZE=Size_Expression Patch_Area_Address
!
!		The code for reconstructing the command line and writing
!		it to the journal and/or command files as well as the
!		PATCH command text area in the image are also included.
!
!	V02-027	MTR0001		Mike Rhodes		20-Aug-1981
!		1.  Add new command, HELP.  The associated command verb
!		HELP_CMD and action routine LBR$OUTPUT_HELP (plus its
!		servent routines LIB$GET_INPUT and LIB$PUT_OUTPUT) have 
!		been added to the appropriate places.
!
!		2.  The procedure for writing command file entries has
!		been modified to selectively make enrties only when the
!		commands correspond to the current ECO level.  Also, the
!		Evaluate, Examine, and Show commands are no longer written
!		to the command file.  The respective action routines in
!		WRITE_CMD have been set to <null> 0.					
!
!	V02-026	KDM0042		Kathleen D. Morse	03-MAR-1981
!		Fix spelling of current patch area message.
!
!	V02-025	PCG0001		Peter George		02-FEB-1981
!		Add require statement for LIB$:PATDEF.REQ
!
!--

FORWARD ROUTINE
	PAT$END_OF_CMD : NOVALUE,				! End of command processing routine
	PAT$END_OF_LINE : NOVALUE,				! End of command line processing routine
	PAT$PERFORM_CMD,					! Executes a patch command
	WRITE_CMD : NOVALUE,					! Writes command line to command file
	PAT$SET_OVERS : NOVALUE,				! Sets mode level to local or override level
	PAT$SET_COMQUAL: NOVALUE,				! Sets bit to indicate qualifier in command line
	PAT$GET_COMQUAL : NOVALUE;				! Finds all command qualifiers specified

LIBRARY 'SYS$LIBRARY:LIB.L32';
REQUIRE 'SRC$:PATPCT.REQ';
REQUIRE 'SRC$:VXSMAC.REQ';
REQUIRE 'SRC$:PATGEN.REQ';
REQUIRE 'SRC$:BSTRUC.REQ';
REQUIRE 'SRC$:DLLNAM.REQ';
REQUIRE 'SRC$:LISTEL.REQ';
REQUIRE 'LIB$:PATDEF.REQ';					! Defines literals
REQUIRE 'LIB$:PATMSG.REQ';
REQUIRE 'SRC$:PATTER.REQ';
REQUIRE 'SRC$:SYSSER.REQ';
REQUIRE 'SRC$:PREFIX.REQ';
REQUIRE 'SRC$:PATPRE.REQ';
REQUIRE 'SRC$:PATRST.REQ';
REQUIRE 'HELPDEF';						! Help options value definitions.

EXTERNAL ROUTINE
	LBR$OUTPUT_HELP,					! Interactive help facility
	LIB$GET_INPUT,						! Not currently required...here for future use
	LIB$PUT_OUTPUT,						! Writes the help text for LBR$OUTPUT_HELP
	PAT$ADD_PAL,						! Adds patch area to list
	PAT$ALIGN_CMD,						! Align command
	PAT$DELETE_PATH,					! Free up pathname storage
	PAT$CANC_MODULE,					! Cancels symbols for modules
	PAT$DEFINE_SYM,						! Define command
	PAT$DEPOSIT_CMD,					! Deposit command
	PAT$ECO_CMDS,						! Set eco level and check eco level commands
	PAT$EXAMINE_CMD,					! Examine command
	PAT$FAO_PUT,						! Formats an FAO line
	PAT$FILL_BUF,						! Updates and enlarges a buffer from a string descriptor
	PAT$FREE_ARG,						! Frees elements of a command argument list
	PAT$FREERELEASE,					! Releases storage in dynamic allocation area
	PAT$INIT_MODES,						! Initializes modes
	PAT$MAP_ADDR : NOVALUE,					! Maps a virtual address
	PAT$OPEN_COMFIL : NOVALUE,				! Opens command file for output
	PAT$OUT_MEM_LOC,					! Outputs values to output device
	PAT$OUT_PAL_EXP,					! Outputs PATCH Area address and size expressions
	PAT$REPLACE_CMD,					! Replace command
	PAT$RESET_DEF,						! Resets modes to initialization mode
	PAT$SAVE_SCOPE,						! Saves a current path name
	PAT$SET_CONTEXT,					! Initializes context bits
	PAT$SET_MODULE,						! Sets up symbols for modules
	PAT$SET_MOD_LST,					! Sets mode list
	PAT$SET_MOD_LVL,					! Sets mode pointer
	PAT$SET_NEW_MOD,					! Sets new modes
	PAT$SHOW_DEFAL,						! Show default command
	PAT$SHOW_MODULE,					! Show module command
	PAT$SHOW_SCOPE,						! Show scope command
	PAT$WRITE_EXP1 : NOVALUE,				! Writes expressions to the command file
	PAT$WRITEFILE : NOVALUE,				! Writes data to a file
	PAT$WRITE_INS : NOVALUE,				! Writes instruction-type command arguments to the command file
	PAT$WRITE_NAME : NOVALUE,				! Writes names to the command file
	PAT$WRTIMG : NOVALUE;					! Writes out new patched image

EXTERNAL
	PAT$GL_HELP_LIN : BLOCK [8,BYTE],			! Global descriptor to remainder of command line (for HELP)
	PAT$GB_MOD_PTR : REF VECTOR[,BYTE],			! Current mode pointer
	PAT$GL_ECO_UPD : BITVECTOR,				! Update qualifier eco mask
	PAT$GB_EXEC_CMD : BYTE,					! Indicator whether or not to execute patch command
	PAT$GL_CSP_PTR : REF PATHNAME_VECTOR,			! Current scope position
	PAT$GL_COMQUAL : BITVECTOR,				! Command qualifier indicators
	PAT$GL_IHPPTR : REF BLOCK[,BYTE],			! Pointer to patch section of image header
	PAT$CP_OUT_STR,						! Pointer to output buffer
	PAT$GL_BUF_SIZ,						! Size of data written into output buffer
	PAT$GL_COMRAB,						! Command file RAB
	PAT$GL_FLAGS,						! CLI flags
	PAT$GL_RLOC_BUF : BLOCK[,BYTE],				! Descriptor for relocation buffer
	PAT$GL_TEMP_BUF : BLOCK[,BYTE],				! Descriptor temporary deposit buffer
	PAT$GL_OLD_ASD : BLOCK[,BYTE],				! Descriptor for old contents assembler directive table
	PAT$GL_NEW_ASD : BLOCK[,BYTE],				! Descriptor for new contents assembler directive table
	PAT$GB_SUBST_IN : VECTOR[,BYTE],			! Buffer for substitution instructions
	PAT$GL_FWRLHD,						! FoWard Reference table listhead
	PAT$CP_INP_DSCS : REF VECTOR [, LONG],			! Table of input string descriptors
	PAT$GB_TAKE_CMD: BYTE,					! Flag which says continue to accept commands
	PAT$GL_CONTEXT: BITVECTOR,				! Context word
	PAT$GL_HEAD_LST,					! Head of command argument list
	PAT$GL_JNLRAB,						! Journal file RAB
	PAT$GL_SEMAN1 : VECTOR,					! Token stack for parser
	PAT$GL_IMGHDR : REF BLOCK[,BYTE],			! Image header pointer
	PAT$GL_PATAREA : REF BLOCK[,BYTE],			! Patch area descriptor pointer
	PAT$GL_OLDLABLS,					! Pointer to listhead for old contents label list
	PAT$GL_NEWLABLS,					! Pointer to listhead for new contents un-relocated label list
	PAT$GL_RLCLABLS,					! Pointer to listhead for new contents relocated label list
	PAT$GL_SYMTBPTR,					! Pointer to current symbol table listhead
	PAT$GL_SYMHEAD;						! Listhead for user-defined symbol table

!
! COMMAND VERB STRINGS
!
BIND
	ALIGN_CMD	=	UPLIT BYTE (%ASCIC 'AL ') : VECTOR[,BYTE],
	CANCEL_MODE_CMD	=	UPLIT BYTE (%ASCIC 'CA M') : VECTOR[,BYTE],
	CANCEL_MODU_CMD	=	UPLIT BYTE (%ASCIC 'CA MODU') : VECTOR[,BYTE],
	CAN_MOD_ALL_CMD =	UPLIT BYTE (%ASCIC 'CA MODU /ALL') : VECTOR[,BYTE],
	CANCEL_SCO_CMD	=	UPLIT BYTE (%ASCIC 'CA SC') : VECTOR[,BYTE],
	CANCEL_PAT_CMD	=	UPLIT BYTE (%ASCIC 'CA PAT') : VECTOR[,BYTE],
	CHECK_N_ECO_CMD	=	UPLIT BYTE (%ASCIC 'CH NOT EC') : VECTOR[,BYTE],
	CHECK_ECO_CMD	=	UPLIT BYTE (%ASCIC 'CH EC') : VECTOR[,BYTE],
	DEFINE_CMD	=	UPLIT BYTE (%ASCIC 'DEF') : VECTOR[,BYTE],
	DELETE_CMD	=	UPLIT BYTE (%ASCIC 'DEL ') : VECTOR[,BYTE],
	DEPOSIT_CMD	=	UPLIT BYTE (%ASCIC 'D ') : VECTOR[,BYTE],
	EXAMINE_CMD	=	UPLIT BYTE (%ASCIC 'E ') : VECTOR[,BYTE],
	EVALUATE_CMD	=	UPLIT BYTE (%ASCIC 'EV') : VECTOR[,BYTE],
	EXIT_CMD	=	UPLIT BYTE (%ASCIC 'EXI') : VECTOR[,BYTE],
	HELP_CMD	=	UPLIT BYTE (%ASCIC 'H ') : VECTOR[,BYTE],
	INSERT_CMD	=	UPLIT BYTE (%ASCIC 'INSE ') : VECTOR[,BYTE],
	NAME_CMD	=	UPLIT BYTE (%ASCIC '!AD') : VECTOR[,BYTE],
	REPLACE_CMD	=	UPLIT BYTE (%ASCIC 'RE ') : VECTOR[,BYTE],
	SCO_NAM_CMD	=	UPLIT BYTE (%ASCIC '!AC') : VECTOR[,BYTE],
	SET_ECO_CMD	=	UPLIT BYTE (%ASCIC 'SE EC') : VECTOR[,BYTE],
	SET_MODE_CMD	=	UPLIT BYTE (%ASCIC 'SE M') : VECTOR[,BYTE],
	SET_MODU_CMD	=	UPLIT BYTE (%ASCIC 'SE MODU') : VECTOR[,BYTE],
	SET_MOD_ALL_CMD =	UPLIT BYTE (%ASCIC 'SE MODU /ALL') : VECTOR[,BYTE],
	SET_PAT_CMD	=	UPLIT BYTE (%ASCIC 'SE PAT') : VECTOR[,BYTE],
	SET_SCO_CMD	=	UPLIT BYTE (%ASCIC 'SE SC') : VECTOR[,BYTE],
	SHOW_MODE_CMD	=	UPLIT BYTE (%ASCIC 'SH M') : VECTOR[,BYTE],
	SHOW_MODU_CMD	=	UPLIT BYTE (%ASCIC 'SH MODU') : VECTOR[,BYTE],
	SHOW_SCO_CMD	=	UPLIT BYTE (%ASCIC 'SH SC') : VECTOR[,BYTE],
	UPDATE_CMD	=	UPLIT BYTE (%ASCIC 'U') : VECTOR[,BYTE],
	VALUE_CMD	=	UPLIT BYTE (%ASCIC '^X!XL') : VECTOR[,BYTE],
	VERIFY_CMD	=	UPLIT BYTE (%ASCIC 'V ') : VECTOR[,BYTE],

!++
! Qualifiers for align command.
!--
	ALIGN_QUAL_TBL	=	UPLIT BYTE (
						%ASCII '/BYT',
						%ASCII '/WOR',
						%ASCII '/LON',
						%ASCII '/QUA',
						%ASCII '/PAG'
								) : VECTOR[,BYTE];

LITERAL
	ALIGN_QUAL_LNG = 4,					! Length of align qualifiers
	NO_CASE_TABLE = 0,					! Don't print CASE dispatch tables
	CASE_TABLE = 1,						! Print CASE dispatch tables
	HELP_FLAGS =	HLP$M_PROCESS	OR			! Disallow HELP prompting only.
			HLP$M_GROUP	OR			! Default Logical Name Table searching to
			HLP$M_SYSTEM;				!	Process, Group, and System.

GLOBAL ROUTINE PAT$END_OF_CMD (SEMSP) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Resets all PATCH context that is exclusive to a single PATCH command.
!	This includes resetting default modes from single line overrides back
!	to the actual default modes and resetting a large number of context bits.
!
!	This routine also releases any storage associated with parameters
!	stored for this command, more specifically for commands which
!	build descriptors for symbolic names.  It also releases any storage
!	used for assembler directive tables, forward reference tables, and
!	temporary deposit buffers.
!
! CALLING SEQUENCE:
!
!	PAT$END_OF_CMD (SEMSP)
!
! INPUTS:
!
!	SEMSP - Offset to command verb token on parse stack
!
! IMPLICIT INPUTS:
!
!	PAT$GL_RLOC_BUF - Descriptor for relocation buffer, if used
!	PAT$GL_TEMP_BUF - Descriptor for temporary buffer used on depositing
!			  new values into memory
!	PAT$GL_OLD_ASD - Descriptor for old contents assembler directive table
!	PAT$GL_NEW_ASD - Descriptor for new contents assembler directive table
!	PAT$GL_FWRLHD - Listhead for ForWard Reference table for instructions
!	PAT$GL_OLDLABLS - Pointer to listhead for old contents label list
!	PAT$GL_NEWLABLS - Pointer to listhead for new contents un-relocated label list
!	PAT$GL_RLCLABLS - Pointer to listhead for new contents relocated label list
!	PAT$GL_SYMTBPTR - Pointer to current symbol table listhead
!	PAT$GL_SYMHEAD - Pointer to user-defined symbol table listhead
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	Defaults are re-established.
!	Any free storage used in symbolic name descriptors, forward reference
!	tables, and symbolic label lists is released.
!
!--

BEGIN

LOCAL
	POINTER,						! Pointer to current command parameter
	DESC_PTR : REF BLOCK[,BYTE];				! Pointer to symbolic name descriptor

!++
! This routine guarantees the internal consistency
! of PATCH, and must succeed or give up.
!--
PAT$GL_SYMTBPTR = .PAT$GL_SYMHEAD;				! Reset the current symbol table to be user-defined one
PAT$INIT_MODES (OVERRIDE_MODE, USER_DEF_MODE);
PAT$SET_MOD_LVL (USER_DEF_MODE);
PAT$SET_CONTEXT ();
PAT$GB_SUBST_IN[0] = 0;						! Allow no substitution instructions
PAT$GL_COMQUAL = 0;						! Set no qualifiers specified

!++
! Now release any symbolic name descriptors used for this command.  The commands
! which have these string descriptors are:  ALIGN, SET MODULE, CANCEL MODULE,
! and DEFINE.
!--
IF (.PAT$GL_SEMAN1[.SEMSP] EQL ALIGN_TOKEN) OR
   (.PAT$GL_SEMAN1[.SEMSP] EQL DEFINE_TOKEN) OR
   (.PAT$GL_CONTEXT[MODULE_BIT])
THEN
	BEGIN
	POINTER = .PAT$GL_HEAD_LST;
	WHILE .POINTER NEQA 0
	DO
		BEGIN
		DESC_PTR = .LIST_ELEM_EXP1(.POINTER);
		PAT$FREERELEASE(.DESC_PTR, ((.DESC_PTR[DSC$W_LENGTH] + 3) /A_LONGWORD) + 2);
		POINTER = .LIST_ELEM_FLINK(.POINTER);
		END;
	END;

!++
! Free all storage used in argument accumulation and pathname building.
!--
PAT$FREE_ARG ();
PAT$DELETE_PATH ();

!++
! Now release any temporary buffer storage used to deposit new values
! into memory.  This is for commands REPLACE, INSERT, and DEPOSIT.
!--
IF (.PAT$GL_TEMP_BUF[DSC$W_LENGTH] NEQ 0)
THEN
	BEGIN
	PAT$FREERELEASE ( .PAT$GL_TEMP_BUF[DSC$A_POINTER],
			(.PAT$GL_TEMP_BUF[DSC$W_LENGTH] + 3)/4);
	PAT$GL_TEMP_BUF[DSC$W_LENGTH] = 0;
	PAT$GL_TEMP_BUF[DSC$A_POINTER] = 0;
	END;

!++
! Now release any relocation buffer storage used to deposit new instructions
! into memory.  This is for commands REPLACE and INSERT.
!--
IF (.PAT$GL_RLOC_BUF[DSC$W_LENGTH] NEQ 0)
THEN
	BEGIN
	PAT$FREERELEASE ( .PAT$GL_RLOC_BUF[DSC$A_POINTER],
			(.PAT$GL_RLOC_BUF[DSC$W_LENGTH] + 3)/4);
	PAT$GL_RLOC_BUF[DSC$W_LENGTH] = 0;
	PAT$GL_RLOC_BUF[DSC$A_POINTER] = 0;
	END;

!++
! Now release any temporary buffer storage used for the new contents assembler
! directive table.
!--
IF (.PAT$GL_NEW_ASD[DSC$W_LENGTH] NEQ 0)
THEN
	BEGIN
	PAT$FREERELEASE ( .PAT$GL_NEW_ASD[DSC$A_POINTER],
			(.PAT$GL_NEW_ASD[DSC$W_LENGTH] + 3)/4);
	PAT$GL_NEW_ASD[DSC$W_LENGTH] = 0;
	PAT$GL_NEW_ASD[DSC$A_POINTER] = 0;
	END;

!++
! Now release any temporary buffer storage used for the old contents assembler
! directive table.
!--
IF (.PAT$GL_OLD_ASD[DSC$W_LENGTH] NEQ 0)
THEN
	BEGIN
	PAT$FREERELEASE ( .PAT$GL_OLD_ASD[DSC$A_POINTER],
			(.PAT$GL_OLD_ASD[DSC$W_LENGTH] + 3)/4);
	PAT$GL_OLD_ASD[DSC$W_LENGTH] = 0;
	PAT$GL_OLD_ASD[DSC$A_POINTER] = 0;
	END;

!++
! There may also be some ForWard Reference table (FWR) to be released.
!--
WHILE (.PAT$GL_FWRLHD NEQA 0)
DO
	BEGIN
	LOCAL
		TEMP_PTR : REF BLOCK[,BYTE];
	TEMP_PTR = .PAT$GL_FWRLHD;
	PAT$GL_FWRLHD = .TEMP_PTR[FWR$L_FLINK];
	PAT$FREERELEASE(.TEMP_PTR, (FWR$C_SIZE + 3)/4);
	END;

!++
! Now release any space used temporarily for symbolic instruction labels on
! old contents of locations.
!--
WHILE (.DLL_RLINK(.PAT$GL_OLDLABLS) NEQA .PAT$GL_OLDLABLS)
DO
	BEGIN
	POINTER = .DLL_RLINK(.PAT$GL_OLDLABLS);
	DLL_RLINK(.PAT$GL_OLDLABLS) = .DLL_RLINK(.POINTER);
	PAT$FREERELEASE(.POINTER, (.SYM_CHCOUNT(.POINTER) + 1 + 3)/4 + OVERHEAD_SYM - 1);
	END;

!++
! Now release any space used temporarily for un-relocated symbolic instruction
! labels on new contents of locations.
!--
WHILE (.DLL_RLINK(.PAT$GL_NEWLABLS) NEQA .PAT$GL_NEWLABLS)
DO
	BEGIN
	POINTER = .DLL_RLINK(.PAT$GL_NEWLABLS);
	DLL_RLINK(.PAT$GL_NEWLABLS) = .DLL_RLINK(.POINTER);
	PAT$FREERELEASE(.POINTER, (.SYM_CHCOUNT(.POINTER) + 1 + 3)/4 + OVERHEAD_SYM - 1);
	END;

!++
! Now release any space used temporarily for relocated symbolic instruction
! labels on old contents of locations.
!--
WHILE (.DLL_RLINK(.PAT$GL_RLCLABLS) NEQA .PAT$GL_RLCLABLS)
DO
	BEGIN
	POINTER = .DLL_RLINK(.PAT$GL_RLCLABLS);
	DLL_RLINK(.PAT$GL_RLCLABLS) = .DLL_RLINK(.POINTER);
	PAT$FREERELEASE(.POINTER, (.SYM_CHCOUNT(.POINTER) + 1 + 3)/4 + OVERHEAD_SYM - 1);
	END;
END;

GLOBAL ROUTINE PAT$END_OF_LINE (SEMSP) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Calls the PAT$END_OF_CMD to reset all patch context that is
!	exclusive to a singe PATCH command.  This includes resetting default
!	modes from single line overrides back to the actual default modes and
!	resetting a large number of context bits.  In addition, any free
!	storage required temporarily is released.
!
!	Also, the command line buffer is released.
!
! CALLING SEQUENCE:
!
!	PAT$END_OF_LINE (SEMSP)
!
! INPUTS:
!
!	SEMSP - Offset to command verb on parse stack
!
! IMPLICIT INPUTS:
!
!	PAT$CP_INP_DSCS - Address of vector of command line buffer descriptors,
!			  first longword of which is count of descriptors
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	Defaults are reestablished.  The command line buffer space is released.
!
!--

BEGIN

LOCAL
	temp_loc;

!++
! This routine guarantees the internal consistency
! of PATCH, and must succeed or give up.
!--
PAT$END_OF_CMD(.SEMSP);

!++
! Now release the command line buffer space.
!--
INCR LOOP FROM 1 TO .PAT$CP_INP_DSCS[0]*2 BY 2
DO
	IF .PAT$CP_INP_DSCS[.LOOP] NEQ 0
	THEN
		BEGIN
		PAT$FREERELEASE (.PAT$CP_INP_DSCS [.LOOP+1],
				(.PAT$CP_INP_DSCS [.LOOP] + 3) / 4);
		PAT$CP_INP_DSCS [.LOOP] = 0;
		PAT$CP_INP_DSCS [.LOOP+1] = 0;
		END
	ELSE
		RETURN;
END;

GLOBAL ROUTINE PAT$PERFORM_CMD (SEMSP) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Action routine for a single PATCH command.  Based on the command verb
!	various routines are called to execute the command.  After the command
!	is executed, a cleanup is done to reset the "one line" modes to the
!	default modes and reset the context switches.  The command line is
!	written to the output command file, if one is being created.
!
! CALLING SEQUENCE:
!
!	PAT$PERFORM_CMD ()
!
! INPUTS:
!
!	SEMSP - Offset in parse stack which holds current verb token
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	TRUE or FALSE, depending on whether parsing is to continue or not.
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	 TRUE or FALSE
!
! SIDE EFFECTS:
!
!	A PATCH command is actually executed.
!
!--

BEGIN

LOCAL
	BIT_NUMBER,						! ECO bit number
	ECOLVL_PTR : REF BITVECTOR,				! Pointer to ECO bits in image header
	OUTPUT_BUF : VECTOR[NO_OF_INP_CHARS,BYTE],		! Buffer for journal file output
	ISE_PTR;						! Pointer to image section descriptor

!++
! If the /UPDATE qualifier was specified, then the execute command indicator,
! PAT$GB_EXEC_CMD, may be set to FALSE indicating the current patch session
! should be skipped.  If this is the case, then don't bother to execute the
! command unless it is a new "SET ECO" level, indicating a new patch session.
! If /UPDATE was not specified, then the execute command indicator is always
! TRUE.  In this case, execute the complete command.  In all cases, the "EXIT"
! command must be executed.
!--
IF (.PAT$GB_EXEC_CMD) OR
   (.PAT$GL_CONTEXT[SET_ECO]) OR
   (.PAT$GL_SEMAN1[.SEMSP] EQL EXIT_TOKEN)
THEN
	BEGIN
	CASE .PAT$GL_SEMAN1 [.SEMSP] FROM ALIGN_TOKEN TO VERIFY_TOKEN OF

	SET

	[ALIGN_TOKEN]:
		PAT$ALIGN_CMD ();

	[CANCEL_TOKEN]:
		SELECTONE TRUE OF
		SET

		[.PAT$GL_CONTEXT[PAT_AREA_BIT]]:
			BEGIN
			PAT$GL_PATAREA = CH$PTR(PAT$GL_IHPPTR[IHP$L_RW_PATSIZ], 0);
			END;

		[.PAT$GL_CONTEXT[MODE_BIT]]:
			BEGIN
			PAT$RESET_DEF();
			END;

		[.PAT$GL_CONTEXT[MODULE_BIT]]:
			BEGIN
			PAT$CANC_MODULE();
			END;

		[.PAT$GL_CONTEXT[SCOPE_BIT]]:
			BEGIN
			PAT$SAVE_SCOPE(FALSE);
			END;
		TES;

	[CHECK_TOKEN]:
		PAT$ECO_CMDS ();

	[CREATE_TOKEN]:
		PAT$OPEN_COMFIL(0, 0);

	[DEFINE_TOKEN]:
		BEGIN

		LOCAL
			POINTER;

		POINTER = .PAT$GL_HEAD_LST;
		WHILE (.POINTER NEQ 0)
		DO
			BEGIN
			PAT$DEFINE_SYM (.LIST_ELEM_EXP1 (.POINTER), .LIST_ELEM_EXP2 (.POINTER), TRUE);
			POINTER = .LIST_ELEM_FLINK (.POINTER);
			END;
		END;

	[DELETE_TOKEN]:
		BEGIN
		PAT$GL_CONTEXT [DELETE_BIT] = TRUE;
		PAT$DEPOSIT_CMD ();
		END;

	[DEPOSIT_TOKEN]:
		PAT$DEPOSIT_CMD ();

	[EXAMINE_TOKEN]:
		BEGIN
		PAT$GL_CONTEXT [EXAMINE_BIT] = TRUE;
		PAT$EXAMINE_CMD ();
		END;

	[EVALUATE_TOKEN]:
		BEGIN
		LOCAL
			POINTER;
		POINTER = .PAT$GL_HEAD_LST;
		WHILE (.POINTER NEQ 0)
		DO
			BEGIN
			PAT$OUT_MEM_LOC (LIST_ELEM_EXP1 (.POINTER), 0, CASE_TABLE);
			POINTER = .LIST_ELEM_FLINK (.POINTER);
			END;
		END;

	[EXIT_TOKEN]:
		BEGIN
		PAT$GB_TAKE_CMD = FALSE;
		IF (.PAT$GL_FLAGS AND PAT$M_UPDATE) NEQ 0
		THEN
			BEGIN
			ECOLVL_PTR = CH$PTR(PAT$GL_IHPPTR[IHP$L_ECO1], 0);
			INCR BIT_NUMBER FROM PAT$K_MIN_ECO-1 TO PAT$K_MAX_ECO-1
			DO
				IF .PAT$GL_ECO_UPD[.BIT_NUMBER]
				THEN
					IF NOT .ECOLVL_PTR[.BIT_NUMBER] 
					THEN
						SIGNAL(PAT$_NOUPDATE, 1, .BIT_NUMBER+1);
			END;
		END;

	[HELP_TOKEN]:
		BEGIN
		LBR$OUTPUT_HELP (LIB$PUT_OUTPUT,,PAT$GL_HELP_LIN, %ASCID 'PATCHHELP', %REF (HELP_FLAGS), LIB$GET_INPUT);
		END;

	[INSERT_TOKEN]:
		BEGIN
		IF (NOT .PAT$GB_MOD_PTR[MODE_INSTRUC])
		THEN
			SIGNAL(PAT$_INVCMD);
		PAT$GL_CONTEXT [INSERT_BIT] = TRUE;
		PAT$REPLACE_CMD ();
		END;

	[REPLACE_TOKEN]:
		PAT$REPLACE_CMD ();

	[SET_TOKEN]:
		SELECTONE TRUE OF
		SET
		[.PAT$GL_CONTEXT[SCOPE_BIT]]:
			BEGIN
			PAT$SAVE_SCOPE (TRUE);
			END;

		[.PAT$GL_CONTEXT[SET_ECO]]:
			BEGIN
			PAT$ECO_CMDS ();
			END;

		[.PAT$GL_CONTEXT[MODE_BIT]]:
			BEGIN
			!++
			! The "SET MODE" command verb must be written to the
			! indirect command file here as the modes to be "SET"
			! are output in PAT$SET_MOD_LST and the information
			! lost.  Therefore, only the "EXIT" to the "NEW>" prompt
			! will be output in the routine, WRITE_CMD.
			!--
			PAT$WRITEFILE(.SET_MODE_CMD[0], SET_MODE_CMD[1], PAT$GL_COMRAB);
			PAT$SET_MOD_LST (USER_DEF_MODE);
			END;

		[.PAT$GL_CONTEXT[PAT_AREA_BIT]]:
 
			BEGIN
			PAT$MAP_ADDR(.LIST_ELEM_EXP1(.PAT$GL_HEAD_LST), 
					PAT$GL_PATAREA, ISE_PTR);
			!++
			!The SET PATCH_AREA command may have a /INITIALIZE=size expression
			!qualifier included.  If its present, then check first that the size
			!value is not larger than the patch area.  If size is to big then, we
			!assure that sufficient space exists to accomodate the patch area
			!descriptor plus a longword (12 bytes).  If space does exists then we
			!set the default size to the size of the unused portion of the patch
			!area image section, informing the user of course.  Else, we signal
			!an informative error message stating the address and amount of space
			!available.  Next, check to make sure that the patch area has not already
			!been initialized.  If it has, issue a warning to the user and set up the
			!descriptor info.  If it has not been previously initialized then take the
			!size value and insert it into the first long word of the patch area and
			!set the second long word to point to the succeeding long word (eg. .+4).
			!
			!*** NOTE ***  The size value that is inserted into the first long word
			! is reduced by 8 (the size of the descriptor) to reflect the fact that
			! we have eaten up this space with the descriptor.
			!
			!	Also note, that since the address of the patch area is synomous
			! with the address of the patch area descriptor, updating the pointer
			! PAT$GL_PATAREA is not necessary.  
			!--

				IF (.PAT$GL_CONTEXT [INIT_PAT_BIT]) THEN
					BEGIN
					BIND	PATCH_AREA = .PAT$GL_PATAREA : VECTOR [, LONG],
						FIRST_AVAIL_ADR = LIST_ELEM_EXP1[.PAT$GL_HEAD_LST],
						INITIAL_SIZE = LIST_ELEM_EXP2[.PAT$GL_HEAD_LST];

					LOCAL
						AVAIL_BYTE_CNT,				!Number of available bytes in this section.
						ISD_PTR : REF BLOCK [, BYTE];		!Points to the current ISD.	

					ISD_PTR = CH$PTR (.ISE_PTR, ISE$C_SIZE);
					AVAIL_BYTE_CNT = (.ISD_PTR[ISD$W_PAGCNT] * 512)
							- (.FIRST_AVAIL_ADR - (.ISD_PTR[ISD$L_VPNPFC] * 512));

					IF (.AVAIL_BYTE_CNT LSS 12) THEN		!Can we accomodate the descriptor plus
						BEGIN					! a longword (total of 12 bytes)?
						SIGNAL (PAT$_NOPATAREA, 2, .FIRST_AVAIL_ADR, .AVAIL_BYTE_CNT); !NO -- Let'em know.
						PAT$END_OF_LINE (.SEMSP);		!Clean up after ourselves.
						RETURN FALSE				!Go process next command line.
						END;

					IF ((.INITIAL_SIZE LEQ 0) OR (.INITIAL_SIZE GTR .AVAIL_BYTE_CNT)) THEN
						BEGIN					!Set the default patch area size to the
						INITIAL_SIZE = .AVAIL_BYTE_CNT;		!available space in patch ISD.
						IF (.PATCH_AREA[0] LEQ 0) THEN		!Should the user be notified?
						 SIGNAL(PAT$_BADINITSZ, 1, .INITIAL_SIZE - 8);!YES, they will be informed by
						END;					!signalling the adjusted size value.

											
					IF (.PATCH_AREA[0] LEQ 0) THEN
						BEGIN					!Initialize a descriptor to the patch
						PATCH_AREA[0] = .INITIAL_SIZE - 8;	!area in the first two long words of the
						PATCH_AREA[1] = .FIRST_AVAIL_ADR + 8;	!patch area.  Adjusting the size and
						END					!address values to reflect this usage.
					ELSE
						SIGNAL (PAT$_PREVINIT);			!Patch Area was previously Init'd.

					END;
 
			PAT$ADD_PAL(.PAT$GL_PATAREA[DSC$A_POINTER],
				.PAT$GL_PATAREA[DSC$A_POINTER]+.PAT$GL_PATAREA[DSC$W_LENGTH],
				PAL$K_ADD_PAREA);
			END;

		[.PAT$GL_CONTEXT[MODULE_BIT]]:
			BEGIN
			PAT$SET_MODULE(0);
			END;
		TES;

	[SHOW_TOKEN]:
		SELECTONE TRUE OF
		SET

		[.PAT$GL_CONTEXT[MODE_BIT]]:
			BEGIN
			PAT$SHOW_DEFAL ();
			END;

		[.PAT$GL_CONTEXT[SCOPE_BIT]]:
			BEGIN
			PAT$SHOW_SCOPE ();
			END;

		[.PAT$GL_CONTEXT[MODULE_BIT]]:
			BEGIN
			PAT$SHOW_MODULE();
			END;

		[.PAT$GL_CONTEXT[PAT_AREA_BIT]]:
			BEGIN
			$FAO_TT_OUT('current patch area size:	!XL',
					.PAT$GL_PATAREA[DSC$W_LENGTH]);
			$FAO_TT_OUT('current patch area address:	!XL',
					.PAT$GL_PATAREA[DSC$A_POINTER]);
			END;
		TES;

	[UPDATE_TOKEN]:
		PAT$WRTIMG();

	[VERIFY_TOKEN]:
		BEGIN
		PAT$GL_CONTEXT[VERIFY_BIT] = TRUE;
		PAT$REPLACE_CMD ();
		END;

	[OUTRANGE]:
		IF .PAT$GL_SEMAN1[.SEMSP] EQL EOL_TOKEN
		THEN
			BEGIN
			PAT$END_OF_LINE (.SEMSP);
			RETURN FALSE
			END;

	TES;
	END;

!++
! Now output the command to the appended patch command text.  Since the command
! has already been successfully executed, call WRITE_CMD to reconstruct the
! command and write it to the command file, if desired.  PAT$WRITEFILE
! handles output to the command file and to the appended patch command text
! buffers, PAT$GL_TXTxxxx.
!--
WRITE_CMD(.SEMSP);

!++
! Check for end of command line.  If this is the end of the command line, then
! prompt for another command otherwise process the next command in this command
! line.
!--
IF (.PAT$GL_SEMAN1 [.SEMSP + PAT$K_SPOS_ONE] EQL EOL_TOKEN)
THEN
	BEGIN
	PAT$END_OF_LINE(.SEMSP);
	RETURN FALSE;
	END
ELSE
	PAT$END_OF_CMD (.SEMSP);

RETURN TRUE;
END;

GLOBAL ROUTINE WRITE_CMD (SEMSP) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine builds the command lines for the output command file
!	and the appended patch command text.  The command has already been
!	executed successfully, the command verb is on the stack, and the
!	parameters are in the parameter list.  The routine PAT$WRITEFILE does
!	all the output to the command file and to the text buffers.  If a
!	command file is not being created, then the commands are only entered
!	in the text buffers.
!
! CALLING SEQUENCE:
!
!	WRITE_CMD (SEMSP)
!
! INPUTS:
!
!	SEMSP - Offset in parse stack which holds current verb token
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	A PATCH command is entered into the appended command text buffers
!	and written to the output command file, if one is being created.
!
!--

BEGIN

LITERAL
	BLANK_FILL = %X'20';					! Ascii value for space

LOCAL
	ALIGN_QUAL_OFF,						! Offset into ALIGN qualifier table
	COMMAND_BUF : VECTOR[NO_OF_INP_CHARS,BYTE],		! Buffer for output of command line to file
	COUNT;							! Counter for scope name loop

!++
! Execute the complete command.
!--
IF .PAT$GB_EXEC_CMD
THEN
	CASE .PAT$GL_SEMAN1 [.SEMSP] FROM ALIGN_TOKEN TO VERIFY_TOKEN OF

	SET

	[ALIGN_TOKEN]:
		BEGIN
		CH$COPY(.ALIGN_CMD[0], ALIGN_CMD[1], BLANK_FILL,
			.ALIGN_CMD[0], CH$PTR(COMMAND_BUF, 0));
		IF .PAT$GL_CONTEXT[ALIGN_BYTE]
		THEN
			ALIGN_QUAL_OFF = 0
		ELSE
			IF .PAT$GL_CONTEXT[ALIGN_WORD]
			THEN
				ALIGN_QUAL_OFF = ALIGN_QUAL_LNG
			ELSE
				IF .PAT$GL_CONTEXT[ALIGN_LONG]
				THEN
					ALIGN_QUAL_OFF = ALIGN_QUAL_LNG*2
				ELSE
					IF .PAT$GL_CONTEXT[ALIGN_QUAD]
					THEN
						ALIGN_QUAL_OFF = ALIGN_QUAL_LNG*3
					ELSE
						ALIGN_QUAL_OFF = ALIGN_QUAL_LNG*4;
		CH$COPY(ALIGN_QUAL_LNG, ALIGN_QUAL_TBL[.ALIGN_QUAL_OFF],
			BLANK_FILL, ALIGN_QUAL_LNG,
			CH$PTR(COMMAND_BUF, .ALIGN_CMD[0]));
		PAT$WRITEFILE(.ALIGN_CMD[0]+ALIGN_QUAL_LNG,
				CH$PTR(COMMAND_BUF, 0), PAT$GL_COMRAB);
		PAT$WRITE_NAME(.SEMSP);
		END;

	[CANCEL_TOKEN]:
		SELECTONE TRUE OF
		SET

		[.PAT$GL_CONTEXT[PAT_AREA_BIT]]:
			BEGIN
			PAT$WRITEFILE(.CANCEL_PAT_CMD[0], CANCEL_PAT_CMD[1], PAT$GL_COMRAB);
			END;

		[.PAT$GL_CONTEXT[MODE_BIT]]:
			BEGIN
			PAT$WRITEFILE(.CANCEL_MODE_CMD[0], CANCEL_MODE_CMD[1], PAT$GL_COMRAB);
			END;

		[.PAT$GL_CONTEXT[MODULE_BIT]]:
			BEGIN
			IF (.PAT$GL_HEAD_LST NEQU 0)
			THEN
				BEGIN
				PAT$WRITEFILE(.CANCEL_MODU_CMD[0], CANCEL_MODU_CMD[1], PAT$GL_COMRAB);
				PAT$WRITE_NAME(.SEMSP);
				PAT$WRITEFILE(.EXIT_CMD[0], EXIT_CMD[1], PAT$GL_COMRAB);
				END
			ELSE
				PAT$WRITEFILE(.CAN_MOD_ALL_CMD[0], CAN_MOD_ALL_CMD[1], PAT$GL_COMRAB);
			END;

		[.PAT$GL_CONTEXT[SCOPE_BIT]]:
			BEGIN
			PAT$WRITEFILE(.CANCEL_SCO_CMD[0], CANCEL_SCO_CMD[1], PAT$GL_COMRAB);
			END;
		TES;

	[CHECK_TOKEN]:
		BEGIN
		IF .PAT$GL_CONTEXT[SET_NOT_ECO]
		THEN
			PAT$WRITEFILE(.CHECK_N_ECO_CMD[0], CHECK_N_ECO_CMD[1],
					PAT$GL_COMRAB)
		ELSE
			PAT$WRITEFILE(.CHECK_ECO_CMD[0], CHECK_ECO_CMD[1],
					PAT$GL_COMRAB);
		PAT$WRITE_EXP1(.SEMSP);
		PAT$WRITEFILE(.EXIT_CMD[0], EXIT_CMD[1], PAT$GL_COMRAB);
		END;

	[CREATE_TOKEN]:
		0;

	[DEFINE_TOKEN]:
		BEGIN
		PAT$WRITEFILE(.DEFINE_CMD[0], DEFINE_CMD[1], PAT$GL_COMRAB);
		PAT$WRITE_NAME(.SEMSP);
		PAT$WRITEFILE(.EXIT_CMD[0], EXIT_CMD[1], PAT$GL_COMRAB);
		END;

	[DELETE_TOKEN]:
		BEGIN
		CH$COPY(.DELETE_CMD[0], DELETE_CMD[1], BLANK_FILL,
			.DELETE_CMD[0], CH$PTR(COMMAND_BUF, 0));
		PAT$GET_COMQUAL( COMMAND_BUF, .DELETE_CMD[0], .SEMSP);
		PAT$WRITE_INS(.SEMSP);
		PAT$WRITEFILE(.EXIT_CMD[0], EXIT_CMD[1], PAT$GL_COMRAB);
		END;

	[DEPOSIT_TOKEN]:
		BEGIN
		CH$COPY(.DEPOSIT_CMD[0], DEPOSIT_CMD[1], BLANK_FILL,
			.DEPOSIT_CMD[0], CH$PTR(COMMAND_BUF, 0));
		PAT$GET_COMQUAL( COMMAND_BUF, .DEPOSIT_CMD[0], .SEMSP);
		PAT$WRITE_INS(.SEMSP);
		PAT$WRITEFILE(.EXIT_CMD[0], EXIT_CMD[1], PAT$GL_COMRAB);
		END;

	[EXAMINE_TOKEN]:
		0;

	[EVALUATE_TOKEN]:
		0;

	[EXIT_TOKEN]:
		PAT$WRITEFILE(.EXIT_CMD[0], EXIT_CMD[1], PAT$GL_COMRAB);

	[HELP_TOKEN]:
		0;

	[INSERT_TOKEN]:
		BEGIN
		CH$COPY(.INSERT_CMD[0], INSERT_CMD[1], BLANK_FILL,
			.INSERT_CMD[0], CH$PTR(COMMAND_BUF, 0));
		PAT$GET_COMQUAL( COMMAND_BUF, .INSERT_CMD[0], .SEMSP);
		PAT$WRITE_INS(.SEMSP);
		PAT$WRITEFILE(.EXIT_CMD[0], EXIT_CMD[1], PAT$GL_COMRAB);
		END;

	[REPLACE_TOKEN]:
		BEGIN
		CH$COPY(.REPLACE_CMD[0], REPLACE_CMD[1], BLANK_FILL,
			.REPLACE_CMD[0], CH$PTR(COMMAND_BUF, 0));
		PAT$GET_COMQUAL( COMMAND_BUF, .REPLACE_CMD[0], .SEMSP);
		PAT$WRITE_INS(.SEMSP);
		PAT$WRITEFILE(.EXIT_CMD[0], EXIT_CMD[1], PAT$GL_COMRAB);
		END;

	[SET_TOKEN]:
		SELECTONE TRUE OF
		SET

		[.PAT$GL_CONTEXT[SCOPE_BIT]]:
			BEGIN
			PAT$WRITEFILE(.SET_SCO_CMD[0], SET_SCO_CMD[1], PAT$GL_COMRAB);
			PAT$GL_BUF_SIZ = 0;
			PAT$CP_OUT_STR = CH$PTR(COMMAND_BUF, 0);
			COUNT = 0;
			WHILE .PAT$GL_CSP_PTR[ .COUNT ] NEQA 0
			DO
				BEGIN
				PAT$FAO_PUT(SCO_NAM_CMD, .PAT$GL_CSP_PTR[.COUNT]);
				COUNT = .COUNT + 1;
				END;
			PAT$WRITEFILE(.PAT$GL_BUF_SIZ, COMMAND_BUF, PAT$GL_COMRAB);
			END;

		[.PAT$GL_CONTEXT[SET_ECO]]:
			BEGIN
			PAT$WRITEFILE(.SET_ECO_CMD[0], SET_ECO_CMD[1], PAT$GL_COMRAB);
			PAT$WRITE_EXP1(.SEMSP);
			END;

		[.PAT$GL_CONTEXT[MODE_BIT]]:
			BEGIN
			PAT$WRITEFILE(.EXIT_CMD[0], EXIT_CMD[1], PAT$GL_COMRAB);
			END;

		[.PAT$GL_CONTEXT[PAT_AREA_BIT]]:
			BEGIN
			IF (.PAT$GL_CONTEXT[INIT_PAT_BIT]) THEN
				BEGIN
				LOCAL
					OUTPUT_BUFFER : BLOCK [132, BYTE];

				PAT$CP_OUT_STR = CH$PTR (OUTPUT_BUFFER, 0);
				CH$COPY (.SET_PAT_CMD[0], SET_PAT_CMD[1], BLANK_FILL,
					 .SET_PAT_CMD[0], CH$PTR (COMMAND_BUF, 0));
				PAT$GET_COMQUAL (COMMAND_BUF, .SET_PAT_CMD[0], .SEMSP);
				PAT$GL_BUF_SIZ = 0;
				PAT$CP_OUT_STR = CH$PTR (OUTPUT_BUFFER, 0);
				PAT$OUT_PAL_EXP (.LIST_ELEM_EXP2 (.PAT$GL_HEAD_LST), 0);
				PAT$WRITEFILE (.PAT$GL_BUF_SIZ, OUTPUT_BUFFER, PAT$GL_COMRAB);
				PAT$GL_BUF_SIZ = 0;
				PAT$CP_OUT_STR = CH$PTR (OUTPUT_BUFFER, 0);
				PAT$OUT_PAL_EXP (.LIST_ELEM_EXP1 (.PAT$GL_HEAD_LST), 0);
				PAT$WRITEFILE (.PAT$GL_BUF_SIZ, OUTPUT_BUFFER, PAT$GL_COMRAB);
				END
			ELSE
				BEGIN
				PAT$WRITEFILE(.SET_PAT_CMD[0], SET_PAT_CMD[1], PAT$GL_COMRAB);
				PAT$WRITE_EXP1(.SEMSP);
				END;
			END;

		[.PAT$GL_CONTEXT[MODULE_BIT]]:
			BEGIN
			IF (.PAT$GL_HEAD_LST NEQU 0)
			THEN
				BEGIN
				PAT$WRITEFILE(.SET_MODU_CMD[0], SET_MODU_CMD[1], PAT$GL_COMRAB);
				PAT$WRITE_NAME(.SEMSP);
				PAT$WRITEFILE(.EXIT_CMD[0], EXIT_CMD[1], PAT$GL_COMRAB);
				END
			ELSE
				PAT$WRITEFILE(.SET_MOD_ALL_CMD[0], SET_MOD_ALL_CMD[1], PAT$GL_COMRAB);
			END;
		TES;

	[SHOW_TOKEN]:
		0;

	[UPDATE_TOKEN]:
		PAT$WRITEFILE(.UPDATE_CMD[0], UPDATE_CMD[1], PAT$GL_COMRAB);

	[VERIFY_TOKEN]:
		BEGIN
		CH$COPY(.VERIFY_CMD[0], VERIFY_CMD[1], BLANK_FILL,
			.VERIFY_CMD[0], CH$PTR(COMMAND_BUF, 0));
		PAT$GET_COMQUAL( COMMAND_BUF, .VERIFY_CMD[0], .SEMSP);
		PAT$WRITE_INS(.SEMSP);
		PAT$WRITEFILE(.EXIT_CMD[0], EXIT_CMD[1], PAT$GL_COMRAB);
		END;

	[OUTRANGE]:
		0;

	TES;
RETURN
END;

GLOBAL ROUTINE PAT$SET_OVERS (LEVEL, TOKEN) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Sets OVERRIDE or LOCAL modes by setting the new mode level, and
!	then setting the mode itself.
!
! CALLING SEQUENCE:
!
!	PAT$SET_OVERS ()
!
! INPUTS:
!
!	LEVEL		- Level of modes to set
!	TOKEN		- Mode token to be set in the mode stack
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! SIDE EFFECTS:
!
!	The appropriate modes are set.
!--

BEGIN
PAT$SET_MOD_LVL (.LEVEL);
PAT$SET_NEW_MOD (.TOKEN);
END;

GLOBAL ROUTINE PAT$SET_COMQUAL (QUAL_OFFSET) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Sets a bit in the command qualifier longword, PAT$GL_COMQUAL,
!	corresponding to the qualifier specified.  These bits are used to
!	reconstruct the command line for the output command file and the
!	appended patch text.
!
! CALLING SEQUENCE:
!
!	PAT$SET_COMQUAL( QUAL_OFFSET)
!
! INPUTS:
!
!	QUAL_OFFSET	- Offset to position in parse stack which contains
!			  the qualifier
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! SIDE EFFECTS:
!
!	The appropriate bit is set.
!--

BEGIN

!++
! The command qualifier table is a stream of bytes.  Each entry consists of two
! bytes.  The first byte is the token value for the qualifier (which is the
! value on the parse stack).  The second byte is the corresponding bit number
! to be set in the command qualifier longword, PAT$GL_COMQUAL.
!--
BIND
	COM_QUAL_TABLE = UPLIT BYTE (
					INSTRUCTI_TOKEN, INSTR_QUAL,
					DECIMAL_TOKEN, DECIMAL_QUAL,
					WORD_TOKEN, WORD_QUAL,
					BYTE_TOKEN, BYTE_QUAL,
					PATCH_ARE_TOKEN, PATCH_QUAL,
					NOINSTRUC_TOKEN, NOINSTR_QUAL,
					LONG_TOKEN, LONG_QUAL,
					HEXADECIM_TOKEN, HEX_QUAL,
					ASCII_TOKEN, ASCII_QUAL,
					NOASCII_TOKEN, NOASCII_QUAL,
					OCTAL_TOKEN, OCTAL_QUAL,
					LITERAL_TOKEN, LITER_QUAL,
					INITIALIZ_TOKEN, INITIALIZE_QUAL
									) : VECTOR[,BYTE];

LOCAL
	TOKEN_INDEX;						! Index into command qualifier table

!++
! Loop, searching the command table for a token matching the one in the
! parse stack.  The corresponding command qualifier bit is set when a match
! is found.
!--
INCR TOKEN_INDEX FROM MIN_QUAL TO MAX_QUAL*2 BY 2
DO
	IF (.COM_QUAL_TABLE[.TOKEN_INDEX] EQL .PAT$GL_SEMAN1[.QUAL_OFFSET])
	THEN
		BEGIN
		PAT$GL_COMQUAL [ .COM_QUAL_TABLE[.TOKEN_INDEX+1] ] = TRUE;
		EXITLOOP;
		END;
RETURN;

END;

GLOBAL ROUTINE PAT$GET_COMQUAL (COMMAND_BUF, COMMAND_SIZE, SEMSP) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine enters the command qualifiers into the command line
!	buffer being constructed.  The qualifiers are indicated by bits
!	set in the command qualifier indicator longword, PAT$GL_COMQUAL.
!	The routine writes the command line to the output command file
!	after it enters the qualifiers.  Note that the command verb has
!	already been entered into the buffer.
!
! CALLING SEQUENCE:
!
!	PAT$GET_COMQUAL (COMMAND_BUF, COMMAND_SIZE, SEMSP)
!
! INPUTS:
!
!	COMMAND_BUF - Address of command line buffer
!	COMMAND_SIZE - Number of command bytes already entered in the buffer
!	SEMSP - Offset in parse stack to command token
!
! IMPLICIT INPUTS:
!
!	PAT$GL_COMQUAL - Indicator for qualifiers specified in command
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! SIDE EFFECTS:
!
!	The command verb and qualifiers are written to the output command file.
!--

BEGIN

MAP
	COMMAND_BUF : REF VECTOR[,BYTE];			! Command line buffer

LITERAL
	HYPHEN = %X'2D',					! Ascii continuation character (hyphen)
	BLANK_FILL = %X'20';					! Ascii fill character (space)

LOCAL
	COM_SIZE,						! Number of bytes written into command line
	QUALIFIER_BIT;						! Number of qualifier bit

BIND
	CQ_TABLE = UPLIT BYTE (
				%ASCIC '/I',
				%ASCIC '/DEC',
				%ASCIC '/W',
				%ASCIC '/B',
				%ASCIC '/PAT',
				%ASCIC '/NOI',
				%ASCIC '/LO',
				%ASCIC '/H',
				%ASCIC '/AS',
				%ASCIC '/NOAS',
				%ASCIC '/OC',
				%ASCIC '/LI',
				%ASCIC '/INIT='
								) : VECTOR[,BYTE],
	CQ_OFFSET_TBL = UPLIT BYTE (
					0,
					0+3,
					0+3+5,
					0+3+5+3,
					0+3+5+3+3,
					0+3+5+3+3+5,
					0+3+5+3+3+5+5,
					0+3+5+3+3+5+5+4,
					0+3+5+3+3+5+5+4+3,
					0+3+5+3+3+5+5+4+3+4,
					0+3+5+3+3+5+5+4+3+4+6,
					0+3+5+3+3+5+5+4+3+4+6+4,
					0+3+5+3+3+5+5+4+3+4+6+4+4
								) : VECTOR[,BYTE];


!++
! Loop, testing each qualifier bit.  If it is set then write the qualifier
! into the command buffer and update the size of the command line.
!--
COM_SIZE = .COMMAND_SIZE;
INCR QUALIFIER_BIT FROM MIN_QUAL TO MAX_QUAL BY 1
DO
	IF .PAT$GL_COMQUAL [.QUALIFIER_BIT] 
	THEN
		BEGIN
		CH$COPY(.CQ_TABLE [ .CQ_OFFSET_TBL[.QUALIFIER_BIT] ],
			CH$PTR(CQ_TABLE[1], .CQ_OFFSET_TBL[.QUALIFIER_BIT]),
			BLANK_FILL,
			.CQ_TABLE [ .CQ_OFFSET_TBL[.QUALIFIER_BIT] ],
			CH$PTR(COMMAND_BUF[0], .COM_SIZE));
		COM_SIZE = .COM_SIZE + .CQ_TABLE [ .CQ_OFFSET_TBL[.QUALIFIER_BIT] ];
		END;

!++
! Check if this is an EXAMINE command.  If so, put a continuation character
! on the end of the line.  This is due to the special syntax for the EXAMINE
! command enabling one to examine sequential locations without specifying
! the address.
!--
IF (.PAT$GL_SEMAN1[.SEMSP] EQL EXAMINE_TOKEN)
THEN
	BEGIN
! ****** THIS CH$PTR IS HERE TO GET AROUND A COMPILER BUG.
! ****** IT SHOULD EVENTUALLY BE REMOVED AND BECOME:
!	COMMAND_BUF[.COM_SIZE] = BLANK_FILL;
!	COMMAND_BUF[.COM_SIZE + 1] = HYPHEN;
	CH$PTR(COMMAND_BUF[.COM_SIZE], 0) = BLANK_FILL;
	CH$PTR(COMMAND_BUF[.COM_SIZE], 1) = HYPHEN;
	COM_SIZE = .COM_SIZE + 2;
	END;

!++
! Now write out the command verb and qualifiers to the command file.
!--
PAT$WRITEFILE(.COM_SIZE, COMMAND_BUF[0], PAT$GL_COMRAB);
RETURN;
END;

END
ELUDOM
