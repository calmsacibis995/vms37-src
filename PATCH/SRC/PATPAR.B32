MODULE PATPAR (
		%IF %VARIANT EQL 1
		%THEN
			ADDRESSING_MODE (EXTERNAL = LONG_RELATIVE, NONEXTERNAL = LONG_RELATIVE),
		%FI
		IDENT = 'V03-000') =
BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! FACILITY:	PATCH
!
!++
! FUNCTIONAL DESCRIPTION:
!
!	Parser for MARS PATCH syntax
!
! Version:	V02-025
!
! History:
!	Author:
!		Carol Peters, 03 Jul 1976: Version 01
!
!	Modified by:
!		Kathleen Morse, 13-Oct-77: Version X01.00
!
! MODIFIED BY:
!
!	V02-025	MTR0002		Mike Rhodes		01-Oct-1981
!		Modify the Macro SET_PATAREA_BIT and add a new macro
!		SET_INIT_BIT to handle the /INITIALIZE qualifier.
!		The macros set the appropriate context bits and
!		will set the correct values of the address of the
!		patch area descriptor and initial size value into
!		the first element of the linked argument list.
!
!	V02-024	MTR0001		Mike Rhodes		20-AUG-1981
!		Add HELP command.  This includes a new macro for
!		saving a descriptor to the rest of the command line
!		while faking the parser into believing its reached
!		the end of the line (which causes the command to be
!		executed).  The macro is called GET_HELP_TOPIC.
!
!	V02-023	PCG0001		Peter George		02-FEB-1981
!		Add require statement for LIB$:PATDEF.REQ
!
! Revision history:
!
!  NO	DATE		PROGRAMMER		PURPOSE
!  --	----		----------		-------
!
!  00	18-OCT-77	K.D. MORSE		ADAPT VERSION 31 TO PATCH
!  01	29-DEC-77	K. D. MORSE		ADD SET/SHOW MODULE/SCOPE CMDS. (44)
!  02	4-JAN-78	K.D. MORSE		NO CHANGES FOR VERS 32-41.
!						IN MACRO GET_QUOTED_STG, DON'T
!						ACCEPT INPUT UNLESS EITHER
!						INSTRUCTION MODE OR ASCII MODE
!						IS SET. (42)
!						NO CHANGES FOR 43,45.
!						DON'T ALLOW DIVISION BY ZERO (46).
!						NO CHANGES FOR 47.
!						CHANGE PARSE STACK OFFSETS TO
!						NAMES DEFINED IN PATMSG.REQ. (48)
!						PLACE TYPE ON ARGUMENT LIST AS
!						WELL AS EXPRESSION. (48)
!						CHANGE EACH ELEMENT OF THE PARSE
!						STACKS TO BE PAT$K_STELM_SIZ (48).
!						FOLLOW A FINAL CALL TO BUILD_PATH
!						WITH PLACING INTERGER TYPE ON
!						SEMAN2. (49)
!  03	24-JAN-78	K.D. MORSE		NO CHANGES FOR VERS 50.
!  04	27-JAN-78	K.D. MORSE		ADD MACRO LINK_EXIT FOR THE
!						REPLACE AND VERIFY COMMANDS.
!  05	28-FEB-78	K.D. MORSE		CHANGE MACRO GET_QUOTED_STG
!						TO ACCEPT ' AND " .  (51)
!  06	01-MAR-78	K.D. MORSE		NO CHANGES FOR 52.
!  07	24-MAR-78	K.D. MORSE		NO CHANGES FOR 53-54.
!  08	07-APR-78	K.D. MORSE		INIT THE DELIMITER IN GET_QUOTED_STG (55).
!						BUILD_PATH IS NOT THE FINAL WORD
!						IN MACRO REDUCE_PATHNAME. (56)
!  09	14-APR-78	K.D. MORSE		NO CHANGES FOR VERS. 57-59.
!  10	18-APR-78	K.D. MORSE		ADD ACTION ROUTINES TO SET BIT
!						LITERAL_BIT.
!  11	18-APR-78	K.D. MORSE		ADD MACRO GET_FILE_SPEC FOR THE
!						CREATE COMMAND.
!  12	25-APR-78	K.D. MORSE		CONVERT TO NATIVE COMPILER.
!  13	09-MAY-78	K.D. MORSE		ADD CHECK IN LINK_ARG_PAIR AND
!						LINK_ARG TO CHECK THAT ASCII OR
!						INSTRUCTION MODES ARE NOT SET.
!						ADD LINK_VAL TO AVOID THE CHECK.
!  14	16-MAY-78	K.D. MORSE		CHANGED CALLS TO PAT$SET_OVERS
!						TO PASS VALUE INSTEAD OF STACK
!						POINTER. (60)
!						NO CHANGES FOR VERS 61.
!						REMOVED (.STACK_PTR) FROM MACRO
!						CALL TO "SET_DEC_OVERS". (62)
!  15	18-MAY-78	K.D. MORSE		SET OVERRIDE_MODE IN "SET_DEC_OVERS"
!						BEFORE SETTING DECIMAL_TOKEN. (63)
!  16	18-MAY-78	K.D. MORSE		NO CHANGES FOR VERS 64.
!  17	18-MAY-78	K.D. MORSE		NO CHANGES FOR VERS 65.
!  18	18-MAY-78	K.D. MORSE		NO CHANGES FOR VERS 66.
!  19	13-JUN-78	K.D. MORSE		ADD FAO COUNTS TO SIGNALS.
!  20	16-JUN-78	K.D. MORSE		ALWAYS CALL PAT$SET_COMQUAL
!						FOR CORRECT APPENDED PATCH
!						COMMAND TEXT QUALIFIERS.
!  21	21-JUN-78	K. D. MORSE		ADD PAT$_SYNTAX ERROR MESSAGE
!						TO THE PAT$_INVCMD MESSAGE. (67)
!  22	28-JUN-78	K.D. MORSE		NO CHANGES FOR VERS 68-72.
!						ERROR HANDLING FOR DIGIT_TOKEN (73).
!						CHANGE CALLING SEQUENCE FOR
!						PAT$FIND_MODULE. (74)
!						NO CHANGES FOR VERS 75-81.
!
!--


FORWARD ROUTINE
	MAR_REDUCTN,						! MARS action routines
	PAT$PARS_A_LINE: NOVALUE;				! Global routine to parse an input line

LIBRARY 'SYS$LIBRARY:LIB.L32';
REQUIRE 'SRC$:PREFIX.REQ';
REQUIRE 'SRC$:PATPRE.REQ';
REQUIRE 'SRC$:VXSMAC.REQ';
REQUIRE 'LIB$:PATDEF.REQ';				! Defines literals
REQUIRE 'LIB$:PATMSG.REQ';
REQUIRE 'SRC$:PATRST.REQ';
REQUIRE 'SRC$:PATPCT.REQ';
REQUIRE 'SRC$:PATGEN.REQ';
REQUIRE 'SRC$:PATTER.REQ';
REQUIRE 'SRC$:PATTOK.REQ';
REQUIRE 'SRC$:BSTRUC.REQ';
REQUIRE 'SRC$:LISTEL.REQ';
REQUIRE 'SRC$:VXPALT.REQ';
REQUIRE 'SRC$:SYSSER.REQ';
REQUIRE 'SRC$:PATACT.REQ';					! Case labels for MARS syntax
REQUIRE 'SRC$:PATTAB.REQ';					! Parse tables for MARS

EXTERNAL ROUTINE
	PAT$ADD_ARG,						! Adds arguments to the command argument list
	PAT$BUILD_PATH,						! Routine to build a path name
	PAT$FIND_MODULE,					! Finds the RST address of a module
	PAT$FREEZ,						! Allocate a block of free storage
	PAT$GET_A_TOKEN,					! Get a single token from input buffer
	PAT$INIT_MODES,						! Initializes input and output modes
	PAT$PERFORM_CMD,					! Executes a complete command
	PAT$PROMPT_READ,					! Prompts and reads a command line
	PAT$SET_COMQUAL,					! Sets command qualifier indicators
	PAT$SET_MOD_LVL,					! Resets modes to a certain level
	PAT$SET_OVERS,						! Sets override or local modes
	PAT$TRANS_NAME;						! Translates a name into a binary value

EXTERNAL
	PAT$GL_HELP_LIN : BLOCK [8,BYTE],			! Global descriptor to remainder of command line (for HELP)
	PAT$GL_FLAGS,						! CLI flags
	PAT$GB_MOD_PTR : REF VECTOR [, BYTE],			! Current mode
	PAT$GL_COMQUAL: BITVECTOR,				! Contains the command qualifier indicators
	PAT$GL_CONTEXT: BITVECTOR,				! Context word
	PAT$GL_HEAD_LST,					! Head of linked argument list
	PAT$GL_TAIL_LST,					! Tail of linked argument list
	PAT$GL_SEMAN1: VECTOR,					! Semantic stack for tokens
	PAT$GL_SEMAN2: VECTOR;					! Semantic stack for string pointers

!
! OWN STORAGE
!
OWN
	QUOTE_INDIC;						! Indicator if parameter was quoted string

!++
! The following macros are simple actions to perform with reductions to
! the grammar.  They correspond to the action routines in PATACT.REQ.  Instead
! of calling global routines, these macros are simply expanded in line.
!--
MACRO

!++
! The first set of macros do arithmetic.
!--

	!++
	! The ADDITION macro adds the value at the top of the stack
	! to the value at the third position in the stack and places
	! the result at the top of the stack.
	!--
	ADDITION (SEMSP) =
		PAT$GL_SEMAN1 [SEMSP] = .PAT$GL_SEMAN1 [SEMSP] + .PAT$GL_SEMAN1 [SEMSP + PAT$K_SPOS_TWO]%,

	!++
	! The DIVISION macro divides the value at the top of the stack
	! by the value at the third position in the stack and places
	! the result at the top of the stack.
	!--
	DIVISION (SEMSP) =
		BEGIN
		IF .PAT$GL_SEMAN1 [SEMSP + PAT$K_SPOS_TWO] EQL 0
		THEN SIGNAL(PAT$_DIVZERO+MSG$K_WARN);
		PAT$GL_SEMAN1 [SEMSP] = .PAT$GL_SEMAN1 [SEMSP] / .PAT$GL_SEMAN1 [SEMSP + PAT$K_SPOS_TWO];
		END%,

! ******** I BET THIS WILL NOT WORK DUE TO MAPPED ADDRESSES. *******
	!++
	! The INDIRECTION macro considers the value at the second position
	! in the stack to be an address. It takes the contents of that
	! address and places it on the top of the stack.
	!--
	INDIRECTION (SEMSP) =
		PAT$GL_SEMAN1 [SEMSP] = ..PAT$GL_SEMAN1 [SEMSP + PAT$K_SPOS_ONE]%,

	!++
	! The MULTIPLICATION macro multiplies the value at the top of
	! the stack to the value at the third position on the stack
	! and places the result at the top of the stack.
	!--
	MULTIPLICATION (SEMSP) =
		PAT$GL_SEMAN1 [SEMSP] = .PAT$GL_SEMAN1 [SEMSP] * .PAT$GL_SEMAN1 [SEMSP + PAT$K_SPOS_TWO]%,

	!++
	! The NEGATION macro negates the value found in the second
	! position on the stack and places the result on the top of
	! the stack.
	!--
	NEGATION (SEMSP) =
		PAT$GL_SEMAN1 [SEMSP] = - .PAT$GL_SEMAN1 [SEMSP + PAT$K_SPOS_ONE]%,

	!++
	! The POSITIVE macro takes the value found in the second
	! position on the stack and places it on the top of the stack.
	!--
	POSITIVE (SEMSP) =
		PAT$GL_SEMAN1 [SEMSP] = .PAT$GL_SEMAN1 [SEMSP + PAT$K_SPOS_ONE]%,

	!++
	! The REMOVE_PARENS macro takes the value found in the second
	! position on the stack and places it on the top of the stack.
	!--
	REMOVE_PARENS (SEMSP) =
		PAT$GL_SEMAN1 [SEMSP] = .PAT$GL_SEMAN1 [SEMSP + PAT$K_SPOS_ONE]%,

	!++
	! The ARITH_SHIFT macro shifts the value at the top of the
	! stack by the value found in the third position on the stack
	! and places the result on the top of the stack.
	!--
	ARITH_SHIFT (SEMSP) =
		PAT$GL_SEMAN1 [SEMSP] = .PAT$GL_SEMAN1 [SEMSP] ^ .PAT$GL_SEMAN1 [SEMSP + PAT$K_SPOS_TWO]%,

	!++
	! The SUBTRACTION macro subtracts the value found in the third
	! position on the stack from the value at the top of the stack
	! and places the result on the top of the stack.
	!--
	SUBTRACTION (SEMSP) =
		PAT$GL_SEMAN1 [SEMSP] = .PAT$GL_SEMAN1 [SEMSP] - .PAT$GL_SEMAN1 [SEMSP + PAT$K_SPOS_TWO]%,

	!++
	! The COMPLEMENT macro applies the NOT operator to the value
	! found in the second position on the stack and places the
	! result on the top of the stack.
	!--
	COMPLEMENT (SEMSP) =
		PAT$GL_SEMAN1 [SEMSP] = NOT .PAT$GL_SEMAN1 [SEMSP + PAT$K_SPOS_ONE]%,

	!++
	! The LOGICAL_OR macro applies the OR operator to the values found
	! in the first and third position on the stack and places the
	! result on the top of the stack.
	!--
	LOGICAL_OR (SEMSP) =
		PAT$GL_SEMAN1 [SEMSP] = .PAT$GL_SEMAN1 [SEMSP] OR
					 .PAT$GL_SEMAN1 [SEMSP + PAT$K_SPOS_TWO]%,

	!++
	! The LOGICAL_AND macro applies the AND operator to the values
	! found in the first and third position on the stack and places
	! the result on the top of the stack.
	!--
	LOGICAL_AND (SEMSP) =
		PAT$GL_SEMAN1 [SEMSP] = .PAT$GL_SEMAN1 [SEMSP] AND
					 .PAT$GL_SEMAN1 [SEMSP + PAT$K_SPOS_TWO]%,

	!++
	! The EXTRACT_BITS macro extracts a bit field from the value
	! on the top of the stack and places that bit field on the
	! top of the stack. The starting bit number of the bit field
	! is in the fifth position on the stack. The end position
	! of the bit field is in the third position. After the value
	! is extracted, the mode is reset to override level.
	!--
	EXTRACT_BITS (SEMSP) =
		BEGIN

		LOCAL
			VALUE : BLOCK [4, BYTE];

		VALUE = .PAT$GL_SEMAN1 [SEMSP];
		IF (.PAT$GL_SEMAN1 [SEMSP + PAT$K_SPOS_TWO] GTR 31) OR 
		   (.PAT$GL_SEMAN1 [SEMSP + PAT$K_SPOS_FOUR] GTR 31) OR
		   (.PAT$GL_SEMAN1 [SEMSP + PAT$K_SPOS_FOUR] GTR 
				.PAT$GL_SEMAN1 [SEMSP + PAT$K_SPOS_TWO])
		THEN
			SIGNAL (PAT$_EXTBIT+MSG$K_WARN);
		PAT$GL_SEMAN1 [SEMSP] = .VALUE [0, .PAT$GL_SEMAN1 [SEMSP + PAT$K_SPOS_FOUR],
			.PAT$GL_SEMAN1 [SEMSP + PAT$K_SPOS_TWO] -
				 .PAT$GL_SEMAN1 [SEMSP + PAT$K_SPOS_FOUR] + 1, 0];
		PAT$INIT_MODES (LOCAL_MODE, OVERRIDE_MODE);
		PAT$SET_MOD_LVL (OVERRIDE_MODE);
		END%,

!++
! The next few macros put items into linked lists.
!--

	!++
	! The LINK_ARG_PAIR macro calls the routine PAT$ADD_ARG to place
	! the value at the top of the stack as a new link in the command
	! argument list. If the new link is created successfully, then
	! the value found at the third position on the stack is placed
	! in the new link as well, at the position called LINK_ELEM_EXP2.
	!--
	LINK_ARG_PAIR (SEMSP) =
		BEGIN
		IF (.QUOTE_INDIC)
		THEN
			SIGNAL(PAT$_INVQUO+MSG$K_WARN);
		PAT$ADD_ARG (.PAT$GL_SEMAN1 [SEMSP]);
		LIST_ELEM_EXP2 (.PAT$GL_TAIL_LST) = .PAT$GL_SEMAN1 [SEMSP + PAT$K_SPOS_TWO];
		END%,

	!++
	! The LINK_ARG macro calls the routine PAT$ADD_ARG to create
	! a new link in the command argument list, and to insert in that
	! link the value found at the top of the stack.
	!--
	LINK_ARG (SEMSP) =
		BEGIN
		IF (.PAT$GB_MOD_PTR[MODE_INSTRUC] OR .PAT$GB_MOD_PTR[MODE_ASCII]) AND
		   (NOT .QUOTE_INDIC)
		THEN
			SIGNAL(PAT$_NOTQUO+MSG$K_WARN);
		QUOTE_INDIC = FALSE;
		PAT$ADD_ARG (.PAT$GL_SEMAN1 [SEMSP]);
		END%,

	!++
	! The LINK_NUM macro calls the routine PAT$ADD_ARG to create
	! a new link in the command argument list, and to insert in that
	! link the location found at the top of the stack.  This macro expects
	! an address and so no quoted string should have been given.
	!--
	LINK_NUM (SEMSP) =
		BEGIN
		IF (.QUOTE_INDIC)
		THEN
			SIGNAL(PAT$_INVQUO+MSG$K_WARN);
		PAT$ADD_ARG (.PAT$GL_SEMAN1 [SEMSP]);
		END%,

	!++
	! The LINK_EXP_NAME macro calls the routine PAT$ADD_ARG to create
	! a new link in the command argument list and to place in that
	! link the address value found at the top of the second parse
	! stack. This address is the address of a string descriptor.
	! If the new link is created successfully, the value found at
	! the third position on the first parse stack is placed in the
	! link in the position called LIST_ELEM_EXP2.
	!--
	LINK_EXP_NAME (SEMSP) =
		BEGIN
		IF (.PAT$GB_MOD_PTR[MODE_INSTRUC] OR .PAT$GB_MOD_PTR[MODE_ASCII]) AND
		   (NOT .QUOTE_INDIC)
		THEN
			SIGNAL(PAT$_NOTQUO+MSG$K_WARN);
		QUOTE_INDIC = FALSE;
		PAT$ADD_ARG (.PAT$GL_SEMAN2 [SEMSP]);
		LIST_ELEM_EXP2 (.PAT$GL_TAIL_LST) = .PAT$GL_SEMAN1 [SEMSP + PAT$K_SPOS_TWO];
		END%,


	!++
	! The LINK_NAME macro calls the routine PAT$ADD_ARG to create
	! a new link in the command argument list, and to insert in that
	! link the string descriptor address found at the top of the stack.
	!--
	LINK_NAME (SEMSP) =
		PAT$ADD_ARG (.PAT$GL_SEMAN2 [SEMSP])%,


	!++
	! The LINK_EXIT macro puts an EXIT_TOKEN into the second expression
	! location of the last argument on the argument list.  The location
	! of this argument is known via PAT$GL_TAIL_LST, which is updated
	! whenever any argument is added.  Note that LINK_EXIT may only be
	! called for arguments that are not ranges.
	!--
	LINK_EXIT =
		LIST_ELEM_EXP2(.PAT$GL_TAIL_LST) = EXIT_TOKEN%,

!++
! The next macro does special translation of a module name.
!--

	!++
	! The ADD_MODULE macro translates the ascii name of a module into
	! the address of that module's record in the RST, and puts that
	! address onto the top of the parse stack.
	!--
	ADD_MODULE (SEMSP) =
		PAT$GL_SEMAN1 [SEMSP] = PAT$FIND_MODULE (LEX_STG_DESC, TRUE)%,

	!++
	! The SAVE_NAME macro allocates an area of free storage to hold
	! the name of a symbol and a string descriptor to that symbol.
	! This macro is called when a name occurs in a DEFINE command,
	! and the name stored in free storage is used by PAT$DEFINE_SYM.
	! The storage is freed by PAT$PERFORM_CMD.
	!
	! All this string descriptor baggage seems rather cumbersome
	! here. Maybe at some later point, the use of string descriptors
	! in this case should be changed to counted strings.
	!--
	SAVE_NAME (SEMSP) =
		BEGIN

		LOCAL
			POINTER : REF VECTOR;
		POINTER = PAT$FREEZ (((.LEX_STG_DESC [DSC$W_LENGTH] + 3) / A_LONGWORD) + 2);
		CH$MOVE (.LEX_STG_DESC [DSC$W_LENGTH], .LEX_STG_DESC [DSC$A_POINTER],
				POINTER [2]);
		POINTER [0] = .LEX_STG_DESC [DSC$W_LENGTH];
		POINTER [1] = POINTER [2];
		PAT$GL_SEMAN2 [SEMSP] = .POINTER;
		END%,

!++
! The next set of macros manipulates mode settings.
!--

	!++
	! The SET_OVERR_MODE macro calls the routine PAT$SET_OVERS to
	! set the mode pointer to OVERRIDE level, and to set the mode
	! according to the token found at the top of the stack.
	!--
	SET_OVERR_MODE (SEMSP) =
		BEGIN
		PAT$SET_OVERS (OVERRIDE_MODE, .PAT$GL_SEMAN1[SEMSP]);
		PAT$SET_COMQUAL(SEMSP);
		END%,

	!++
	! The SET_DEC_OVERS macro calls the routine PAT$SET_OVERS to
	! set the mode pointer to LOCAL level, and to set the mode
	! to decimal.
	!--
	SET_DEC_OVERS =
		BEGIN
		PAT$SET_MOD_LVL(OVERRIDE_MODE);
		PAT$SET_OVERS (LOCAL_MODE, DECIMAL_TOKEN);
		END%,

	!++
	! The SET_MODE_BIT macro turns on the default bit in the
	! PATCH context word.
	!--
	SET_MODE_BIT =
		PAT$GL_CONTEXT [MODE_BIT] = TRUE%,

!++
! The next macro is GET_QUOTED_STG. Its major failing is
! that it writes into the input stream. This could be solved by
! calling it with another argument, the string descriptor for a
! writable string. For the nonce, it writes into an otherwise pure
! stream.
!--

!++
! The next macro collects a string that is enclosed in quotes.
!--

	!++
	! The GET_QUOTED_STG macro reads characters from the input string.  It
	! picks up the delimiting character (' or ") and reads until the next
	! occurance of that character.  If none is found, the invalid command
	! message is output, and end of line processing is done. Otherwise, the
	! length of the string is placed in the position of the opening quote.
	! A zero is placed in the position of the closing quote for end-of-line.
	! If the current mode is instruction mode, the address of the string is
	! placed on the top of the first parse stack.  Otherwise, the string
	! must be ASCII, so it is reduced to four characters or less and placed
	! on the top of stack. The parse string descriptor is updated to address
	! the character after the closing quote.
	!--
	GET_QUOTED_STG (SEMSP) =
		BEGIN

		MAP
			PARSE_STG_DESC : REF BLOCK [, BYTE];

		LOCAL
			CHAR,
			COUNT,
			DELIMITER,
			INPUT_PTR : REF VECTOR[,BYTE],
			TEMP_PTR;

		IF (NOT .PAT$GB_MOD_PTR[MODE_INSTRUC]) AND
		   (NOT .PAT$GB_MOD_PTR[MODE_ASCII])
		THEN
			SIGNAL(PAT$_INVQUO+MSG$K_WARN);
		QUOTE_INDIC = TRUE;
		INPUT_PTR = CH$PLUS (.PARSE_STG_DESC [DSC$A_POINTER], -1); ! Point to delimiter
		TEMP_PTR = CH$PTR(.INPUT_PTR, 0);
		DELIMITER = CH$RCHAR_A(INPUT_PTR);
		COUNT = 0;
		REPEAT
			BEGIN
			CHAR = CH$RCHAR_A (INPUT_PTR);
			IF (.CHAR EQL 0)			! Line always ends with zero
			THEN
				BEGIN
				!++
				! This message has been made informational
				! instead of warning, to allow user typo's
				! of eliminating the closing quote on symbolic
				! instructions.  This will eliminate annoyance
				! of aborting the command after multiple input lines.
				!--
				SIGNAL (PAT$_MISSQUO+MSG$K_INFO);
				CHAR = .DELIMITER;
				END;
			IF (.CHAR EQL .DELIMITER)
			THEN
				BEGIN
				!++
				! Found a closing quote. Replace the opening
				! quote with the length of the quoted string.
				! Replace th closing quote with a zero.  This
				! is for forward referencing inside symbolic
				! instructions.
				!--
				CH$WCHAR (.COUNT, .TEMP_PTR);
				INPUT_PTR[-1] = 0;
				EXITLOOP
				END
			ELSE
				BEGIN
				COUNT = .COUNT + 1;
				END;
			END;

		!++
		! Quoted string found. Put the QTD_STG_TOKEN on the
		! the first parse stack. Put the address of the string on
		! the first parse stack.
		!--
		IF .PAT$GB_MOD_PTR [MODE_INSTRUC]
		THEN PAT$GL_SEMAN1 [SEMSP] = .TEMP_PTR
		ELSE
			BEGIN

			MAP
				TEMP_PTR : REF VECTOR [, BYTE];

			LOCAL
				VALUE : VECTOR [A_LONGWORD, BYTE];

			VALUE = 0;
			INCR INDEX FROM 0 TO
				(IF .TEMP_PTR [0] LEQ 4
				 THEN .TEMP_PTR [0] - 1
				 ELSE 3)
			DO VALUE [.INDEX] = .TEMP_PTR [.INDEX + 1];
			IF .TEMP_PTR [0] GTR .PAT$GB_MOD_PTR [MODE_LENGTH]
			THEN
				 SIGNAL (PAT$_STGTRUNC);
			PAT$GL_SEMAN1 [SEMSP] = .VALUE;
			END;

		!++
		! Now update the parse string descriptor so that the
		! address of the buffer is the address of the character
		! after the closing quote.
		!--
		PARSE_STG_DESC [DSC$A_POINTER] = CH$PTR (.INPUT_PTR, 0);
		PARSE_STG_DESC [DSC$W_LENGTH] = .PARSE_STG_DESC [DSC$W_LENGTH] - (.COUNT + 1);
		END%,


!++
! This macro collects a file specification.
!--

	!++
	! The GET_FILE_SPEC macro reads from the input string starting
	! at the character after the keyword CREATE until a character is
	! found that is not a space, tab, or a zero. If such a character
	! is found before the end of line is reached, then the position
	! of the character before is noted for storage of the length of
	! the file spec string. Then the string is read until a zero 
	! or carriage return character is encountered. The length
	! of the string is stored in the previously saved position.
	! Finally, the address of the file specification is placed in 
	! a new link of the command argument list by a call to the
	! routine PAT$ADD_ARG. This address is the address of a counted
	! string.
	!--
GET_FILE_SPEC =

		BEGIN

		MAP
			PARSE_STG_DESC : REF BLOCK [, BYTE];

		LOCAL 
			CHAR,
			COUNT,
			INPUT_PTR,
			TEMP_PTR;

		INPUT_PTR = CH$PTR (.PARSE_STG_DESC [DSC$A_POINTER]);
		CHAR = CH$RCHAR (.INPUT_PTR);


		!++
		! This loop skips spaces and tabs that delimit the CREATE
		! verb and precede the file specification. At the end of
		! this loop, the character pointer INPUT_PTR is pointing
		! to the first character of the file specification.
		!--
		COUNT = 0;
		REPEAT
			BEGIN

			!++
			! The character we recognize as the beginning
			! of the file specification is the first
			! character after the delimiter of the CREATE verb.
			!--
			IF .CHAR NEQ ASC_SPACE AND .CHAR NEQ ASC_TAB
			THEN EXITLOOP
			ELSE
				BEGIN
				COUNT = .COUNT + 1;
				CHAR = CH$A_RCHAR (INPUT_PTR);
				END;
			END;

		!++
		! Check if there was no file name specified.
		! If there was no file name, then PATCH wants to return
		! successfully from this action routine.  The only reason
		! this macro can contain a "RETURN TRUE" statement, is that
		! MAR_REDUCTN merely returns after executing it.
		!--
		IF (.CHAR EQL 0)
		THEN
			EXITLOOP(TRUE);

		!++
		! The beginning of the file specification has been
		! found. If the delimiter was non-null, then
		! collect the rest of the string.
		!--
		IF (.COUNT LEQ 0)
		THEN
			BEGIN
			IF (.TOKEN EQL DIGIT_STR_TOKEN) OR (.TOKEN EQL EOL_TOKEN)
			THEN
				SIGNAL (PAT$_INVCMD)
			ELSE
				BEGIN
				SIGNAL(PAT$_SYNTAX+MSG$K_WARN, 1, LEX_STG_DESC);
				RETURN;
				END
			END;

		PARSE_STG_DESC [DSC$W_LENGTH] = .PARSE_STG_DESC [DSC$W_LENGTH] - .COUNT;
		TEMP_PTR = CH$PLUS (.INPUT_PTR, -1);
		COUNT = 0;
		REPEAT
			BEGIN
			IF .CHAR EQL 0 
!				OR .CHAR EQL CARRIAGE_RET		!***line always ends in zero***
			THEN
				BEGIN

				!++
				! Found the end of the file specification.
				! Exit this loop after setting the count
				! byte of this counted string.
				!--
				IF (.COUNT LEQ 0)
				THEN
					BEGIN

					SIGNAL (PAT$_INVCMD);
					END;
				CH$wCHAR (.COUNT, .TEMP_PTR);
				EXITLOOP
				END
			ELSE
				BEGIN
				COUNT = .COUNT + 1;
				CHAR = CH$A_RCHAR (INPUT_PTR);
				END;
			END;
		!++
		! Now put the address of the file specification into
		! a new link in the command argument list.
		! Also, increment the address of the parse string in
		! the parse string descriptor to address the delimiting
		! carriage return or null byte.
		!--
		PAT$ADD_ARG (.TEMP_PTR);
		PARSE_STG_DESC [DSC$A_POINTER] = .INPUT_PTR;
		PARSE_STG_DESC [DSC$W_LENGTH] = .PARSE_STG_DESC [DSC$W_LENGTH] - .COUNT;
		END%,

!++
! The macros below manipulate names of data specified in commands.
!--

	!++
	! The TRANSLATE_NAME macro calls the routine PAT$TRANS_NAME to
	! translate a token into a binary value. If the routine fails in
	! the translation, a signal and unwind occurs.
	!--
	TRANSLATE_NAME (SEMSP) =
		PAT$TRANS_NAME (SEMSP, LEX_STG_DESC)%,

!++
! The next macro is called when a complete command has been collected.
!--

	!++
	! The EXECUTE_CMD macro calls PAT$PERFORM_CMD and returns
	! from PARSE_A_LINE if that routine returns a false value.
	!--
	EXECUTE_CMD (SEMSP) =
		IF NOT PAT$PERFORM_CMD (SEMSP)
		THEN
			RETURN%,


!++
! The next macros manipulate scope and pathnames.
!--

	!++
	! The REDUCE_PATHNAME macro calls PAT$BUILD_PATH to convert a
	! pathname into an equivalent value. If the conversion fails,
	! then the symbol does not exist, a message is produced, and an
	! UNWIND is done.
	!--
	REDUCE_PATHNAME (SEMSP) =
		PAT$BUILD_PATH (0, PAT$GL_SEMAN1 [SEMSP], TRUE)%,


	!++
	! The macro SET_SCOPE_BIT turns on the appropriate context
	! bit so that a path name will be saved.
	!--
	SET_SCOPE_BIT =
		PAT$GL_CONTEXT [SCOPE_BIT] = TRUE%,

!++
! The next macro sets the context bit indicating the "SET PATCH_AREA" command.
!
! The macro also tests to see if the address of the patch area descriptor was declared before
! the /INITIALIZE qualifier (if it was present).  If the /INITIALIZE qualifier came first, then
! move the initial size value into the second expression location in the linked argument list,
! followed by copying the address of the patch area descriptor into the first expression location. 
!--

	SET_PATAREA_BIT =
		BEGIN
		PAT$GL_CONTEXT [PAT_AREA_BIT] = TRUE;
		IF .PAT$GL_HEAD_LST NEQ .PAT$GL_TAIL_LST THEN
			BEGIN
			LIST_ELEM_EXP2 (.PAT$GL_HEAD_LST) = .LIST_ELEM_EXP1 (.PAT$GL_HEAD_LST);
			LIST_ELEM_EXP1 (.PAT$GL_HEAD_LST) = .LIST_ELEM_EXP1 (.PAT$GL_TAIL_LST);
			END;
		END%,

!++
! The next macro sets the context bit indicating that the /INITIALIZE qualifier
! was present in the SET PATCH_AREA command.
!
! The macro also checks to see if the /Initialize qualifier was specified after
! the patch area descriptor.  If this is the case, all we have to do is to copy
! the initial size value into the second expression location of the first element
! of the linked argument list.
!--

	SET_INIT_BIT (SEMSP) =
		BEGIN
		PAT$GL_CONTEXT [INIT_PAT_BIT] = TRUE;
		PAT$GL_COMQUAL [INITIALIZE_QUAL] = TRUE;
		IF .PAT$GL_HEAD_LST NEQ .PAT$GL_TAIL_LST THEN
			LIST_ELEM_EXP2 (.PAT$GL_HEAD_LST) = .LIST_ELEM_EXP1 (.PAT$GL_TAIL_LST);
		END%,

!++
! The next macro sets the context bit for the keyword "MODULE".
!--

	SET_MODULE_BIT =
		PAT$GL_CONTEXT [MODULE_BIT] = TRUE%,

!++
! The next macro sets the context bit for the LITERAL qualifier.
!--
	SET_LIT_BIT =
		PAT$GL_CONTEXT[LITERAL_BIT] = TRUE%,

!++
! The next two macros set bits indicating what type of ECO command is
! to be executed.
!--

	!++
	! The macro SET_NOT_ECO_BIT sets a bit to indicate the command
	! was CHECK NOT ECO, i.e., check that the eco level bits
	! are NOT set.
	!--
	SET_NOT_ECO_BIT (SEMSP) =
		BEGIN
		PAT$GL_CONTEXT [SET_NOT_ECO] = TRUE;
		SET_DEC_OVERS;
		END%,

	!++
	! The macro SET_ECO_BIT sets a context bit to indicate the command
	! was setting ECO bits.
	!--
	SET_ECO_BIT (SEMSP) =
		BEGIN
		PAT$GL_CONTEXT [SET_ECO] = TRUE;
		SET_DEC_OVERS;
		END%,

!++
! The next five macros set the align context bits.
!--

	SET_BYTE_BIT =
		PAT$GL_CONTEXT [ALIGN_BYTE] = TRUE%,

	SET_LONG_BIT =
		PAT$GL_CONTEXT [ALIGN_LONG] = TRUE%,

	SET_PAGE_BIT =
		PAT$GL_CONTEXT [ALIGN_PAGE] = TRUE%,

	SET_QUAD_BIT =
		PAT$GL_CONTEXT [ALIGN_QUAD] = TRUE%,

	SET_WORD_BIT = 
		PAT$GL_CONTEXT [ALIGN_WORD] = TRUE%,

!++
! The next six macros perform a logical test between the two items
! and then place TRUE or FALSE on the top of the stack.
!--

	EQ_EXPR (SEMSP) =
		PAT$GL_SEMAN1 [SEMSP] = .PAT$GL_SEMAN1 [SEMSP] EQL 
						.PAT$GL_SEMAN1 [SEMSP + PAT$K_SPOS_TWO]%,

	GE_EXPR (SEMSP) =
		PAT$GL_SEMAN1 [SEMSP] = .PAT$GL_SEMAN1 [SEMSP] GEQ 
						.PAT$GL_SEMAN1 [SEMSP + PAT$K_SPOS_TWO]%,

	GT_EXPR (SEMSP) =
		PAT$GL_SEMAN1 [SEMSP] = .PAT$GL_SEMAN1 [SEMSP] GTR 
						.PAT$GL_SEMAN1 [SEMSP + PAT$K_SPOS_TWO]%,

	LE_EXPR (SEMSP) =
		PAT$GL_SEMAN1 [SEMSP] = .PAT$GL_SEMAN1 [SEMSP] LEQ 
						.PAT$GL_SEMAN1 [SEMSP + PAT$K_SPOS_TWO]%,

	LT_EXPR (SEMSP) =
		PAT$GL_SEMAN1 [SEMSP] = .PAT$GL_SEMAN1 [SEMSP] LSS 
						.PAT$GL_SEMAN1 [SEMSP + PAT$K_SPOS_TWO]%,

	NE_EXPR (SEMSP) =
		PAT$GL_SEMAN1 [SEMSP] = .PAT$GL_SEMAN1 [SEMSP] NEQ 
						.PAT$GL_SEMAN1 [SEMSP + PAT$K_SPOS_TWO]%,

!++
! This macro collects a HELP topic specification.
!--

	!++
	! The GET_HELP_TOPIC macro reads from the input string starting
	! at the character after the keyword HELP until a character is
	! found that is not a space, tab, or a zero. If such a character
	! is found before the end of line is reached, then the position
	! of the character is noted for storage in the pointer field of
	! PAT$GL_HELP_LIN [DSC$A_POINTER].  Then the string is read until
	! a zero or carriage return character is encountered.
	!--

GET_HELP_TOPIC =

		BEGIN

		MAP
			PARSE_STG_DESC : REF BLOCK [, BYTE];

		LOCAL 
			HELP_CHAR,
			HELP_COUNT,
			HELP_INPUT_PTR;

		HELP_INPUT_PTR = CH$PTR (.PARSE_STG_DESC [DSC$A_POINTER]);
		HELP_CHAR = CH$RCHAR (.HELP_INPUT_PTR);


		!++
		! This loop skips spaces and tabs that delimit the HELP
		! verb and precede the topic specification. At the end of
		! this loop, the character pointer HELP_INPUT_PTR is pointing
		! to the first character of the topic specification.
		!--

		HELP_COUNT = 0;
		REPEAT
			BEGIN

			!++
			! The character we recognize as the beginning
			! of the topic specification is the first
			! character after the delimiter of the HELP verb.
			!--

			IF .HELP_CHAR NEQ ASC_SPACE AND .HELP_CHAR NEQ ASC_TAB
			THEN EXITLOOP
			ELSE
				BEGIN
				HELP_COUNT = .HELP_COUNT + 1;
				HELP_CHAR = CH$A_RCHAR (HELP_INPUT_PTR);
				END;
			END;

		!++
		! Check if there was no HELP topic specified.
		! If there was no topic, then PATCH wants to return
		! successfully from this action routine.  The only reason
		! this macro can contain a "RETURN TRUE" statement, is that
		! MAR_REDUCTN merely returns after executing it.
		! Stated another way...
		!	We will be leaving the current parse string pointing
		! to the end of the line, hence the EOL token is going to
		! cause us to call the real action routine, which can deal
		! with not having any topic specified on the command line.
		!--

		IF (.HELP_CHAR EQL 0)		!***line always ends in zero***
		THEN
			EXITLOOP(TRUE);

		!++
		! With the HELP topic now in hand, we now reduce the remaining number of
		! characters in the parse string.  Don't forget to set the global pointer
		! PAT$GL_HELP_LIN [DSC$A_POINTER] to the beginning of the topic string.
		!--

		PARSE_STG_DESC [DSC$W_LENGTH] = .PARSE_STG_DESC [DSC$W_LENGTH] - .HELP_COUNT;
		PAT$GL_HELP_LIN [DSC$A_POINTER] = .HELP_INPUT_PTR;

		!++
		! Now we will busy ourselves with faking out the parser...
		!	The reason for this action, is to allow the LBR$OUTPUT_HELP routine
		! to do its own parsing of the remainder of the command string.
		! Further, the parser doesn't quit easily.  Sooo, we kinda force it to
		! execute the command by simulating the end of line condition.
		!	This is done by counting the number of characters remaining in the
		! parse string (between the beginning character of the topic string and the
		! end of line mark) then reducing the parse string count by that amount.
		! We also at this time update the length portion of the global length
		! PAT$GL_HELP_LIN [DSC$W_LENGTH].
		!--

		HELP_COUNT = 0;
		REPEAT
			BEGIN

			IF .HELP_CHAR EQL 0		!***line always ends in zero***
			THEN
				EXITLOOP
			ELSE
				BEGIN
				HELP_COUNT = .HELP_COUNT + 1;
				HELP_CHAR = CH$A_RCHAR (HELP_INPUT_PTR);
				END;
			END;
		!++
		! Now set the length of the Help topic, into the global
		! descriptor field PAT$GL_HELP_LIN [DSC$W_LENGTH].
		! Also, increment the address of the parse string in
		! the parse string descriptor to address the delimiting
		! carriage return or null byte.
		!--

		PAT$GL_HELP_LIN [DSC$W_LENGTH] = .HELP_COUNT;		
		PARSE_STG_DESC [DSC$A_POINTER] = .HELP_INPUT_PTR;
		PARSE_STG_DESC [DSC$W_LENGTH] = .PARSE_STG_DESC [DSC$W_LENGTH] - .HELP_COUNT;
		END%;


GLOBAL ROUTINE PAT$PARS_A_LINE (PARSE_STG_DESC) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Parses a line of PATCH commands and performs associated action routines.
!
! CALLING SEQUENCE:
!
!	PAT$PARS_A_LINE ()
!
! INPUTS:
!
!	PARSE_STG_DESC	- string descriptor of the buffer that holds
!			  the input string.
!
! IMPLICIT INPUTS:
!
!	the parsing tables
!
! OUTPUTS:
!
!	No value returned.
!	Outputs are the effects of the action routines called.
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	novalue
!
! SIDE EFFECTS:
!
!	none
!--
BEGIN

MAP
	PARSE_STG_DESC : REF BLOCK[,BYTE];

LOCAL
	ACTION_TO_TAKE,						! Action from PAT_ACT_TABLE
	CUR_PARSE_STATE,					! The state of the parse machine
	J,							! Control variable
	LEXEME_ADDR: VECTOR [CHS_PER_LEXEME, BYTE],		! Buffer for string lexeme
	LAHEAD_ADDR: VECTOR [CHS_PER_LEXEME, BYTE],		! Buffer for a lookahead
	LEX_STG_DESC: BLOCK [12, BYTE]	,			! String descriptor for lexemes
	LAHEAD_STG_DESC: BLOCK [8, BYTE],			! Lookahead for one lexeme
	LAST_STG_DESC : BLOCK[8,BYTE],				! Previous place in PARSE_STG_DESC
	MATCH_TRANSIT,						! Boolean, TRUE if matching transition is found
	NEXT_TOKEN,						! Saves next token
	OLD_J,							! Saves state 
	OLD_TOKEN,						! Saved token
	PARSE_MORE,						! Boolean, says whether to parse more
	PARSE_STACK: VECTOR [MAX_STACK_PTR * PAT$K_STELM_SIZ, WORD], ! Parse state stack
	REDUCE_WAS_LAST,					! TRUE if reduction was last action
	SCAN_NEXT_SYM,						! Boolean, TRUE if next symbol needs to be scanned
	STACK_POINTER,						! Stack INDEX
	TOKEN,							! holds latest token
	TRANSIT_CODE;						! Transition code from PAT_STATE_TABLE

LABEL
	MATCH_LOOP;

!++
! Initialize control variables.  Get a token from the input string.
!--
OLD_TOKEN = 0;
REDUCE_WAS_LAST = FALSE;
STACK_POINTER = 0;
QUOTE_INDIC = FALSE;
CH$FILL (0,DSC$C_S_BLN,PAT$GL_HELP_LIN);
!++
! Initialize the look-ahead string descriptor.
!--
LEX_STG_DESC [DSC$W_LENGTH] = 0;
LEX_STG_DESC [DSC$W_MAXLEN] = CHS_PER_LEXEME;
LEX_STG_DESC [DSC$A_POINTER] = LEXEME_ADDR;
LAHEAD_STG_DESC [DSC$A_POINTER] = LAHEAD_ADDR;

!++
! Maintain a 'last' string descriptor which is always what 'PARSE_STG_DESC'
! was before the last time it was changed.
!--
LAST_STG_DESC[DSC$W_LENGTH] = .PARSE_STG_DESC[DSC$W_LENGTH];
LAST_STG_DESC[DSC$A_POINTER] = .PARSE_STG_DESC[DSC$A_POINTER];

!++
! Get the first token from the command line.
!--
TOKEN = PAT$GET_A_TOKEN (.PARSE_STG_DESC, LEX_STG_DESC);

!++
! Initialize the parse control variables.
!--
CUR_PARSE_STATE = 0;
SCAN_NEXT_SYM = TRUE;
PARSE_MORE = TRUE;
MATCH_TRANSIT = FALSE;

!++
! This is the main loop of the parser.  It continues
! until the variable "PARSE_MORE" has a value of FALSE.
!--
DO
	BEGIN
	J = .CUR_PARSE_STATE;

	!++
	! The following loop searches for a matching token
	! and exits when a match is found.
	!--
	DO
MATCH_LOOP:	BEGIN
		MATCH_TRANSIT = FALSE;
		TRANSIT_CODE = .PAT_STATE_TABLE [.J];

		!++
		! See whether this transit code is an else code,
		! and at the same time the token is a keyword
		! token. In these circumstances, try passing
		! through the loop again with the pretense
		! that the token is a ALPHA_STR_TOKEN. The current
		! token and state must be saved so that
		! if ALPHA_STR_TOKEN does not make a valid sentence,
		! then the effect of the else code can be reestablished.
		!--
		IF (.TRANSIT_CODE EQL ELSE_CODE) AND (.TOKEN LEQ KEYWORD_RANGE)
		THEN
			BEGIN
			OLD_TOKEN = .TOKEN;
			OLD_J = .J;
			J = .CUR_PARSE_STATE;
			TOKEN = ALPHA_STR_TOKEN;
			LEAVE MATCH_LOOP;
			END;

		!++
		! Now allow for restoring the original token
		! in the case that the newly inserted ALPHA_STR_TOKEN
		! brought no better results.
		!--
		IF (.TRANSIT_CODE EQL ELSE_CODE) AND (.TOKEN EQL ALPHA_STR_TOKEN)
			AND (.OLD_TOKEN NEQ 0)
		THEN
			BEGIN
			TOKEN = .OLD_TOKEN;
			J = .OLD_J;
			OLD_TOKEN = 0;
			END;

		!++
		! No special handling here. Just compare the
		! token and the transit code.
		!--
		IF (.TRANSIT_CODE EQL .TOKEN) OR
		   (.TRANSIT_CODE EQL ELSE_CODE)
		THEN
			BEGIN
			!++
			! A match has been found, so the lexical string can be
			! read or reduced.
			!--
			MATCH_TRANSIT = TRUE;
			ACTION_TO_TAKE = .PAT_ACT_TABLE [.J];
			IF (.ACTION_TO_TAKE NEQ ERROR_CODE)
			THEN
				BEGIN
				IF (.ACTION_TO_TAKE GTR - SCAN_CODE)
				THEN
					!++
					! Nothing else to scan.  Perform the
					! associated action routine for this
					! lexical entity.
					!--
					BEGIN
					PARSE_STACK [.STACK_POINTER] = .CUR_PARSE_STATE;

					!++
					! Put the token on the top of the parse stack
					!--
					IF NOT .REDUCE_WAS_LAST
					THEN PAT$GL_SEMAN1 [.STACK_POINTER] = .TOKEN;
					END;
				
				IF (.ACTION_TO_TAKE GEQ 0)
				THEN
					!++
					! This is a read state.
					!--
					BEGIN
					CUR_PARSE_STATE = .ACTION_TO_TAKE;
					REDUCE_WAS_LAST = FALSE;
					IF (.STACK_POINTER GEQ (MAX_STACK_PTR * PAT$K_STELM_SIZ))
					THEN
						BEGIN
						SIGNAL (PAT$_PARSEERR)
						END
					ELSE STACK_POINTER = .STACK_POINTER + PAT$K_SPOS_ONE;

					!++
					! Now input the next token if more
					! reading is necessary.
					!--
					IF .SCAN_NEXT_SYM
					THEN 
						BEGIN
						ZEROCOR(.LAHEAD_STG_DESC[DSC$A_POINTER],
							(.LAHEAD_STG_DESC[DSC$W_MAXLEN]/4));
						LAHEAD_STG_DESC [DSC$W_LENGTH] =
							.LEX_STG_DESC [DSC$W_LENGTH];
						CH$MOVE (.LEX_STG_DESC [DSC$W_LENGTH],
							.LEX_STG_DESC [DSC$A_POINTER],
							.LAHEAD_STG_DESC [DSC$A_POINTER]);
						LAST_STG_DESC[DSC$W_LENGTH] = .PARSE_STG_DESC[DSC$W_LENGTH];
						LAST_STG_DESC[DSC$A_POINTER] = .PARSE_STG_DESC[DSC$A_POINTER];
						TOKEN = PAT$GET_A_TOKEN (.PARSE_STG_DESC, LEX_STG_DESC);
						END
					ELSE
						!++
						! If no more scanning is needed,
						! put the next token in the
						! variable "TOKEN".
						BEGIN
						SCAN_NEXT_SYM = TRUE;
						TOKEN = .NEXT_TOKEN;
						END;

					!++
					! This is the end of the read.
					!--
					END
				ELSE
					!++
					! This is a reduction.
					!--
					BEGIN
					IF (.ACTION_TO_TAKE LEQ - SCAN_CODE)
					THEN
						!++
						! This is a noscan reduction,
						! which takes an extra stack pop.
						!--
						BEGIN
						ACTION_TO_TAKE = .ACTION_TO_TAKE + SCAN_CODE;
						SCAN_NEXT_SYM = FALSE;
						STACK_POINTER = .STACK_POINTER - PAT$K_SPOS_ONE;
						NEXT_TOKEN = .TOKEN;
						END;

					ACTION_TO_TAKE = - .ACTION_TO_TAKE;
					STACK_POINTER = .STACK_POINTER -
						(.PAT_POP_TABLE [.ACTION_TO_TAKE] * PAT$K_STELM_SIZ);
					CUR_PARSE_STATE = .PARSE_STACK [.STACK_POINTER];
					TOKEN = .PAT_LHS_TABLE [.ACTION_TO_TAKE];
					REDUCE_WAS_LAST = TRUE;

					!++
					! In here go the semantic actions for each reduction.
					!--
					IF NOT MAR_REDUCTN (.PAT_SEM_TABLE [.ACTION_TO_TAKE],
						.STACK_POINTER)
					THEN SELECTONE .PAT_SEM_TABLE [.ACTION_TO_TAKE] OF
						SET
						[PATGETHLP]:	GET_HELP_TOPIC;
						[PATDEFNAM]:	SAVE_NAME (.STACK_POINTER);
						[PATGETFIL]:	GET_FILE_SPEC;
						[PATOLDPMT]:	IF NOT PAT$PROMPT_READ(OLDPMT_TOKEN, .PARSE_STG_DESC) THEN RETURN;
						[PATNEWPMT]:	IF NOT PAT$PROMPT_READ(NEWPMT_TOKEN, .PARSE_STG_DESC) THEN RETURN;
						[PATLOCPMT]:	IF NOT PAT$PROMPT_READ(LOCPMT_TOKEN, .PARSE_STG_DESC) THEN RETURN;
						[PATNAMPMT]:	IF NOT PAT$PROMPT_READ(NAMPMT_TOKEN, .PARSE_STG_DESC) THEN RETURN;
						[PATEXPPMT]:	IF NOT PAT$PROMPT_READ(EXPPMT_TOKEN, .PARSE_STG_DESC) THEN RETURN;
						[PATECOPMT]:	IF NOT PAT$PROMPT_READ(ECOPMT_TOKEN, .PARSE_STG_DESC) THEN RETURN;
						[PATQUOTEC]:	GET_QUOTED_STG (.STACK_POINTER);
						[PATSAVMDL]:	ADD_MODULE (.STACK_POINTER);
						[PATSAVPAT]:	PAT$BUILD_PATH (LEX_STG_DESC, 0, TRUE);
						[PATTRNNAM]:	REDUCE_PATHNAME (.STACK_POINTER);
						[PATUQUNAM]:	TRANSLATE_NAME (.STACK_POINTER);
						[OTHERWISE]:	RETURN;
						TES;

					END;
				END

			!++
			! This is the ERROR_CODE processing.
			! It is the else portion of the (.ACTION_TO_TAKE
			! EQL ERROR_CODE) IF statement.
			!--
			ELSE
				BEGIN
				IF (.TOKEN NEQ DIGIT_STR_TOKEN)
				THEN
					BEGIN
					!++
					! Truncate the string to 10 characters
					! unless it is already shorter than 10.
					!--
					IF (.LAST_STG_DESC[DSC$W_LENGTH] GTR 10)
					THEN
						LAST_STG_DESC[DSC$W_LENGTH] = 10;
					SIGNAL(PAT$_SYNTAX+MSG$K_WARN, 1, LAST_STG_DESC);
					END;
				IF (.TOKEN NEQ EOL_TOKEN)
				THEN
					SIGNAL(PAT$_INVCMD)
				ELSE
					SIGNAL (PAT$_INVTOKEN+MSG$K_WARN, 1, LEX_STG_DESC);
				END
			END
		ELSE
			!++
			! This is the ELSE portion of the IF statement
			! (.TRANSIT_CODE EQL .TOKEN) OR
			! (.TRANSIT_CODE EQL ELSE_CODE)
			!--
			IF (.TRANSIT_CODE EQL CONT_CODE)
			THEN J = .PAT_ACT_TABLE [.J]
			ELSE J = .J + 1;
		END						! End of MATCH_LOOP
	UNTIL .MATCH_TRANSIT
	END
	!++
	! Continue processing until an action routine sets this
	! flag to false.
	!--
WHILE .PARSE_MORE;
END;

ROUTINE MAR_REDUCTN (ACTION_KEY, STACK_POINTER) =

!++
! Functional description:
!
!	Does the action associated with a reduction. The action is chosen
!	based on the ACTION_KEY, which is the name of an action routine
!	as specified in the semantics table.
!
! Calling sequence:
!
!	CALLS #2, MAR_REDUCTN
!
! Inputs:
!
!	ACTION_KEY	- name of the action routine
!	STACK_POINTER	- top of stack in the context of the reduction
!
! Implicit inputs:
!
!	The names of the two parse stacks, PAT$GL_SEMAN1 and
!	PAT$GL_SEMAN2.
!
! Outputs:
!
!	TRUE if the action occurred and does not want to cause a return
!	from the parser.  Otherwise a FALSE.
!
!	none
!
! Routine value:
!
!	TRUE or FALSE
!
! Side effects:
!
!	The top of stack is often changed. Arguments are put into
!	linked lists, context values are altered.
!--

BEGIN

CASE .ACTION_KEY FROM 1 TO PATNONE OF

	SET

	[PATADDEXP]:	ADDITION (.STACK_POINTER);
	[PATALIBYT]:	SET_BYTE_BIT;
	[PATALILNG]:	SET_LONG_BIT;
	[PATALINM0]:	LINK_NAME(.STACK_POINTER);
	[PATALINM1]:	LINK_NAME(.STACK_POINTER + PAT$K_SPOS_ONE);
	[PATALIPAG]:	SET_PAGE_BIT;
	[PATALIQAD]:	SET_QUAD_BIT;
	[PATALIWRD]:	SET_WORD_BIT;
	[PATANDOPR]:	LOGICAL_AND (.STACK_POINTER);
	[PATCHKNEC]:	SET_NOT_ECO_BIT (.STACK_POINTER);
	[PATCOMLIN]:	EXECUTE_CMD (.STACK_POINTER);
	[PATDEFONE]:	LINK_EXP_NAME (.STACK_POINTER + PAT$K_SPOS_ONE);
	[PATDEFTWO]:	LINK_EXP_NAME (.STACK_POINTER + PAT$K_SPOS_TWO);
	[PATDEFZER]:	LINK_EXP_NAME (.STACK_POINTER);
	[PATDIVEXP]:	DIVISION (.STACK_POINTER);
!	[PATEQEXPR]:	EQ_EXPR (.STACK_POINTER);
	[PATEXITOK]:	LINK_EXIT;
	[PATEXPONE]:	LINK_ARG (.STACK_POINTER + PAT$K_SPOS_ONE);
	[PATEXPTWO]:	LINK_ARG (.STACK_POINTER + PAT$K_SPOS_TWO);
	[PATEXPZER]:	LINK_ARG (.STACK_POINTER);
	[PATEXTBIT]:	EXTRACT_BITS (.STACK_POINTER);
!	[PATGEEXPR]:	GE_EXPR (.STACK_POINTER);
!	[PATGTEXPR]:	GT_EXPR (.STACK_POINTER);
	[PATINDEXP]:	INDIRECTION (.STACK_POINTER);
!	[PATLEEXPR]:	LE_EXPR (.STACK_POINTER);
!	[PATLTEXPR]:	LT_EXPR (.STACK_POINTER);
	[PATMULEXP]:	MULTIPLICATION (.STACK_POINTER);
!	[PATNEEXPR]:	NE_EXPR (.STACK_POINTER);
	[PATNEGEXP]:	NEGATION (.STACK_POINTER);
	[PATNOTOPR]:	COMPLEMENT (.STACK_POINTER);
	[PATNUMONE]:	LINK_NUM (.STACK_POINTER + PAT$K_SPOS_ONE);
	[PATNUMTWO]:	LINK_NUM (.STACK_POINTER + PAT$K_SPOS_TWO);
	[PATNUMZER]:	LINK_NUM (.STACK_POINTER);
	[PATOROPER]:	LOGICAL_OR (.STACK_POINTER);
	[PATOVROP2]:	SET_OVERR_MODE (.STACK_POINTER + PAT$K_SPOS_TWO);
	[PATOVROP1]:	SET_OVERR_MODE (.STACK_POINTER + PAT$K_SPOS_ONE);
	[PATPOSEXP]:	POSITIVE (.STACK_POINTER);
	[PATRANGE0]:	LINK_ARG_PAIR (.STACK_POINTER);
	[PATRANGE1]:	LINK_ARG_PAIR (.STACK_POINTER + PAT$K_SPOS_ONE);
	[PATRANGE2]:	LINK_ARG_PAIR (.STACK_POINTER + PAT$K_SPOS_TWO);
	[PATREMPAR]:	REMOVE_PARENS (.STACK_POINTER);
	[PATSETDEC]:	SET_DEC_OVERS;
	[PATSETECO]:	SET_ECO_BIT (.STACK_POINTER);
	[PATSETLIT]:	SET_LIT_BIT;
	[PATSETMDL]:	SET_MODULE_BIT;
	[PATSETMOD]:	SET_MODE_BIT;
	[PATSETPAT]:	SET_PATAREA_BIT;
	[PATSETINI]:	SET_INIT_BIT (.STACK_POINTER);
	[PATSETSCO]:	SET_SCOPE_BIT;
	[PATSHFEXP]:	ARITH_SHIFT (.STACK_POINTER);
	[PATSUBEXP]:	SUBTRACTION (.STACK_POINTER);
	[PATNONE]:	0;

	[INRANGE, OUTRANGE]:
		RETURN FALSE;

	TES;

RETURN TRUE
END;

END
ELUDOM
