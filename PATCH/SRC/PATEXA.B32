MODULE PATEXA (
		%IF %VARIANT EQL 1
		%THEN
			ADDRESSING_MODE (EXTERNAL = LONG_RELATIVE, NONEXTERNAL = LONG_RELATIVE),
		%FI
		IDENT = 'V03-000') =
BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! FACILITY:	PATCH
!
!++
! FUNCTIONAL DESCRIPTION:
!
!	EXAMINE, DEPOSIT, AND DELETE ROUTINES FOR STARLET PATCH FACILITY
!
! Version:	V02-023
!
! History:
!	Author:	Carol Peters, 21 Jul 1976: Version 01
!
!		Kathleen Morse, 19 Oct 1977: Version X01.00
!
! Modified by:
!
!	V02-023	PCG0001		Peter George		04-FEB-1981
!		Add require statement for LIB$:PATDEF.REQ
!
!	V0122	BLS0039		Benn Schreiber		3-Feb-1981
!		Correct handling of patch area.
!
!	V0121	CNH0014		Chris Hume		21-Sep-1979	11:00
!		Added relocation support for the ACBG and ACBH instructions.
!
!	V0120	CNH0008		Chris Hume		28-Jun-1979	14:00
!		Fix CASE replacement bug and disallow relocation of these
!		instructions.  (PATMAI.B32 V0222, PATACT.B32 V0124,
!		PATMAC.B32 V0217, PATMSG.MDL V0202)
!
! Revision history:
!  NO	DATE		PROGRAMMER		PURPOSE
!  --	----		----------		-------
!
!  00	19-OCT-77	K.D. MORSE		ADAPT VERSION 49 FOR PATCH
!  01	01-DEC-77	K.D. MORSE		ADD DELETE ROUTINE.
!  02	27-DEC-77	K.D. MORSE		CHANGE PAT$OUT_VALUE CALLS. (57)
!						ADD PAT$SYM_DEPOS. (58)
!  03	2-JAN-78	K.D. MORSE		ADD CHECK FOR NO SYMBOLS IN IMAGE.
!  04	3-JAN-78	K.D. MORSE		ADD CHECK FOR NO PATCHAREA
!						ALLOCATED BEFORE DEPOSIT /PAT.
!  05	4-JAN-78	K.D. MORSE		NO CHANGES FOR VERS 50-53.
!  06	5-JAN-78	K.D. MORSE		CHANGE PAT$INS_DECODE CALLS. (54)
!						NO CHANGES FOR VERS 55,56.
!  07	24-JAN-78	K.D. MORSE		NO CHANGES FOR VERS 59.
!  08	27-JAN-78	K.D. MORSE		ADD CHECK FOR EXIT_TOKEN IN
!						PAT$REPLACE_CMD TO RECOGNIZE
!						END OF OLD LIST.
!  09	28-JAN-78	K.D. MORSE		BUILD REPLACEMENT CODE INTO
!						TEMPORARY BUFFER.
!  10	01-MAR-78	K.D. MORSE		CHANGE ERRONEOUS PAT$_DECODE
!						ERROR MSGS TO PAT$_ENCODE.
!  11	24-MAR-78	K.D. MORSE		NONE FOR VERS 60-61.
!  12	04-APR-78	K.D. MORSE		NONE FOR VERS 62.
!  13	25-APR-78	K.D. MORSE		CONVERT TO NATIVE COMPILER.
!  14	28-APR-78	K.D. MORSE		ADD ASSEMBLER DIRECTIVE FLAG
!						TO PAT$OUT_MEM_LOC.
!  15	18-MAY-78	K.D. MORSE		NO CHANGES FOR VERS 63.
!  16	26-MAY-78	K.D. MORSE		ADD CODE TO ALLOW FORWARD
!						REFERENCING IN SYMBOLIC
!						INSTRUCTION OPERANDS.
!  17	13-JUN-78	K.D. MORSE		ADD FAO COUNTS TO SIGNALS.
!  18	19-JUN-78	K.D. MORSE		NO CHANGES FOR VERS 64.
!  19	28-JUN-78	K.D. MORSE		NO CHANGES FOR VERS 65-67.
!						ADD CODE FOR EV/LITERAL AND
!						ROUTINE DISPLAY_LVTS. (66)
!						NO CHANGES FOR VERS 69-74.
!
!--

FORWARD ROUTINE
	PAT$DEPOSIT_CMD : NOVALUE,				! Deposits a datum into an address
	PAT$EXAMINE_CMD : NOVALUE,				! Examines a location
	PAT$REPLACE_CMD : NOVALUE,				! Replaces an instruction
	RELOCAT_INS : NOVALUE,					! Relocates instructions to patch area
	PAT$SUBST_INS,						! Substitutes instructions in patch area
	PAT$OUT_MEM_LOC,					! Outputs the contents of a memory location
	DISPLAY_LVTS : NOVALUE,					! Search LVT and display pathnames
	PAT$REG_MATCH,						! Matches a string to a register name
	PAT$FILL_BUF : NOVALUE;					! Writes data into temporary buffers

LIBRARY 'SYS$LIBRARY:LIB.L32';					! System definitions
REQUIRE 'SRC$:VXSMAC.REQ';
REQUIRE 'SRC$:BSTRUC.REQ';
REQUIRE 'SRC$:LISTEL.REQ';
REQUIRE 'SRC$:PATPCT.REQ';
REQUIRE 'SRC$:PATGEN.REQ';
REQUIRE 'LIB$:PATDEF.REQ';				! Defines literals
REQUIRE 'LIB$:PATMSG.REQ';
REQUIRE 'SRC$:SYSLIT.REQ';
REQUIRE 'SRC$:PATRST.REQ';
REQUIRE 'SRC$:SYSSER.REQ';
REQUIRE 'SRC$:PATTER.REQ';
REQUIRE 'SRC$:PREFIX.REQ';
REQUIRE 'SRC$:PATPRE.REQ';
REQUIRE 'SRC$:VAXOPS.REQ';

EXTERNAL
	PAT$GB_SYMBOLS,						! Indicator if image had symbols
	PAT$GL_OLD_ASD,						! Descriptor for old contents assembler directive table
	PAT$GL_NEW_ASD,						! Descriptor for new contents assembler directive table
	PAT$GL_TEMP_BUF : BLOCK[,BYTE],				! Descriptor for temporary buffer for deposit values
	PAT$GL_RLOC_BUF : BLOCK[,BYTE],				! Descriptor for relocated instruction stream
	PAT$GB_SUBST_IN : VECTOR[,BYTE],			! Buffer for substitution instruction streams
	PAT$GL_BR_DISPL,					! Branch displacement that does not fit
	PAT$GL_PATAREA : REF BLOCK[,BYTE],			! Pointer to patch area descriptor
	PAT$GL_IMGHDR : REF BLOCK[,BYTE],			! Pointer to image header
	PAT$GB_LOC_TYPE: BYTE,					! Type of end range argument
	PAT$GB_MOD_PTR: REF VECTOR [, BYTE],			! Pointer to mode level
	PAT$GL_IHPPTR : REF BLOCK[,BYTE],			! Pointer to image header patch area
	PAT$CP_OUT_STR : REF VECTOR[,BYTE],			! Points into current output buffer
	PAT$GL_CONTEXT: BITVECTOR,				! Context bits longword
	PAT$GL_BUF_SIZ,						! Holds count in output buffer
	PAT$GL_HEAD_LST,					! Head of linked list of expressions
	PAT$GL_LAST_LOC,					! Last location displayed
	PAT$GL_LAST_VAL,					! Last value displayed
	PAT$GL_NEXT_LOC,					! Next location to display
	PAT$GL_SYMTBPTR,					! Pointer to current symbol table
	PAT$GL_OLDLABLS,					! Listhead for old contents labels (from current command)
	PAT$GL_NEWLABLS,					! Listhead for new contents un-relocated labels (from current command)
	PAT$GL_RLCLABLS;					! List head for new contents relocated labels (from current command)

EXTERNAL ROUTINE
	PAT$ADD_LABELS : NOVALUE,				! Adds labels to user-defined symbol table
	PAT$ADD_NT_T_PV : NOVALUE,				! Build pathname vectors from NT_PTRs
	PAT$EXP_AREA : NOVALUE,					! Expands patch area
	PAT$FAO_PUT : NOVALUE,					! Formats buffered output
	PAT$FREERELEASE,					! Deallocates free memory
	PAT$FREEZ,						! Allocates and zeroes free memory
	PAT$GET_NXT_LVT,					! Provide access to the LVT
	PAT$GET_VALUE : NOVALUE,				! Gets byte stream of values from image
	PAT$INS_DECODE,						! Routine to output memory as
								! symbolic instructions
	PAT$INS_ENCODE,						! Routine to encode a symbolic instruction
	PAT$MAP_ADDR : NOVALUE,					! Computes mapped addresses
	PAT$OUT_NUM_VAL,					! Outputs numeric values
	PAT$OUT_PUT : NOVALUE,					! Actually does the terminal I/O
	PAT$OUT_SYM_VAL,					! Outputs symbol name with value
	PAT$PRINT_PATH : NOVALUE,				! Print out pathnames
	PAT$RESOLVE_INS : NOVALUE,				! Resolves forward references in symbolic instruction operands
	PAT$SYMBOL_VALU,					! Finds the value bound to a symbol name
	PAT$UNMAP_ADDR : NOVALUE,				! Computes unmapped addresses
	PAT$VAL_TO_SYM,						! Translates a value to a symbol name
	PAT$WRITE_MEM;						! Routine to write to user's memory

!++
!
! REGISTER_TABLE holds one entry per register.  Each entry is made
! up of one longword.  The first byte holds the character count of
! the register name.  The second through fourth bytes hold the
! register name string.  A sample entry follows:
!
!	+---------------------------------------------------------------+
!	!		!	0       !	R       !	2       !
!	+---------------------------------------------------------------+
!
!--

MACRO
	REGISTER_ENTRY (STRING) =
		%CHARCOUNT (STRING), %ASCII STRING, REP 3 - %CHARCOUNT (STRING) OF BYTE (0)%;

BIND
	REGISTER_TABLE = UPLIT BYTE (
		REGISTER_ENTRY ('R0'),
		REGISTER_ENTRY ('R1'),
		REGISTER_ENTRY ('R2'),
		REGISTER_ENTRY ('R3'),
		REGISTER_ENTRY ('R4'),
		REGISTER_ENTRY ('R5'),
		REGISTER_ENTRY ('R6'),
		REGISTER_ENTRY ('R7'),
		REGISTER_ENTRY ('R8'),
		REGISTER_ENTRY ('R9'),
		REGISTER_ENTRY ('R10'),
		REGISTER_ENTRY ('R11'),
		REGISTER_ENTRY ('AP'),
		REGISTER_ENTRY ('FP'),
		REGISTER_ENTRY ('SP'),
		REGISTER_ENTRY ('PC'),
		REGISTER_ENTRY ('PSL')):

	BLOCK [, LONG];

!++
! These field definitions control access to the register table.
!--
MACRO
	REG_NAME	=8, 24, 0%,
	CTD_REG_NAME	=0, 24, 0%,
	REG_CH_CNT	=0,  8, 0%;

!++
! Common ascii counted strings used in FAO calls.
!--

BIND
	CS_ASCII	= UPLIT ( %ASCIC '''!AD'''),
	COLON_TAB_STG	= UPLIT ( %ASCIC ':  '),
	CAR_CTL_STG	= UPLIT ( %ASCIC '!/'),
	OLD_TAB_STG	= UPLIT ( %ASCIC 'old:	'),
	NEW_TAB_STG	= UPLIT ( %ASCIC 'new:	');

LITERAL
	NO_CASE_TABLE	= 0,					! Don't print case dispatch table
	CASE_TABLE	= 1;					! Print CASE dispatch table

SWITCHES NOOPTIMIZE;
GLOBAL ROUTINE PAT$DEPOSIT_CMD : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine handles all delete and deposit commands, those for
!	instructions and those for values.  The instruction(s)/value(s)
!	specified in the delete command must be identical to those actually
!	contained in the location(s), otherwise an error message is produced and
!	the command ends prematurely.  For a deposit command, the instruction(s)
!	/value(s) specified are written to consecutive locations.  The image is
!	not modified in either case unless the entire command works.
!
!	The command argument list is made up of entries that are
!	each three longwords long. The first is a forward link to the
!	next entry. The second longword in the first entry in the list
!	is the address into which some value(s) is (are) to be deleted or deposited.
!	The third longword is unused. The second longword in the second
!	and subsequent entries are the values to be deleted or deposited.
!	The first value should be the contents of the specified location;
!	the second, the contents of that location plus the current mode_length, etc.
!
!	For instructions, the increment is the length of each subsequent 
!	instruction. The second longword contains the address of a counted byte
!	stream that is to be translated into a binary instruction which is the
!	old contents of that location.
!
! CALLING SEQUENCE:
!
!	PAT$DEPOSIT_CMD ()
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	PAT$GL_HEAD_LST, the head of the linked PATCH command argument list.
!	The current mode.
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	The values PAT$GL_LAST_LOC, PAT$GL_LAST_VAL, and PAT$GL_NEXT_LOC
!	are set after each deposit is done.
!
! ROUTINE VALUE:
!
!	novalue
!
! SIDE EFFECTS:
!
!	The specified addresses have their values changed.
!	If a failure in a write occurs, the routine SIGNALs an error.
!
!--

BEGIN

LITERAL
	NOP_INSTR	= 1,					! Fill char for instructions
	ZERO_BYTE	= 0,					! Fill char for data
	ONE_PAGE	= 1,					! Number of pages to expand patch area
	MAX_INST_LEN	= 80;					! Maximum number of binary bytes in an instruction

LOCAL
	INSTRUC_BUF: VECTOR [MAX_INST_LEN, BYTE],
	FILL_CHAR: BYTE,					! Fill character for delete command
	OLD_CONTENTS:	VECTOR[TTY_OUT_WIDTH, BYTE],		! Buffer to hold old contents of location
	MAPPED_LOC,						! Mapped address of deposit destination
	UNMAPPED_LOC,						! Unmapped address of deposit destination
	ISE_ADDR,						! Image section entry for deposit destination
	DEP_SRC_ADR,						! Pointer to deposit source
	DEP_SIZ,						! Size of deposit to be made
	POINTER;

!++
! Check that all parameters were specified on the command.
!--
POINTER = .PAT$GL_HEAD_LST;
IF (.POINTER EQLA 0) OR (.LIST_ELEM_FLINK(.POINTER) EQLA 0)
THEN
	SIGNAL (PAT$_INVCMD);

!++
! Initialize unmapped address and PAT$GL_CONTEXT.  The context bit causes
! the routine PAT$OUT_MEM_LOC to display a location instead of evaluating
! a numeric expression.
!--
UNMAPPED_LOC = .LIST_ELEM_EXP1 (.POINTER);
PAT$GL_CONTEXT[EXAMINE_BIT] = TRUE;

!++
! For DEPOSIT commands only:
!
! Check if DEPOSIT qualifier, "/PATCH_AREA", was specified.
! If so, check that the address specified is identical to the
! start of the current patch area.  If it is not, report an
! error and abort the DEPOSIT command.
!--
IF .PAT$GL_CONTEXT [PAT_AREA_BIT]
THEN
	BEGIN
	IF (.PAT$GL_PATAREA[DSC$W_LENGTH] EQL 0)
	THEN
		IF (.PAT$GL_PATAREA [DSC$A_POINTER] EQLA .PAT$GL_IHPPTR[IHP$L_RW_PATADR])
		THEN
			PAT$EXP_AREA(ONE_PAGE);
	IF (.PAT$GL_PATAREA [DSC$A_POINTER] NEQA .UNMAPPED_LOC)
	THEN
		SIGNAL(PAT$_NOTPATADR, 2, .PAT$GL_PATAREA[DSC$A_POINTER], .UNMAPPED_LOC);
	END;

!++
! Set the fill character for DELETE commands.
!--
IF (.PAT$GB_MOD_PTR [MODE_INSTRUC])
THEN
	BEGIN
	PAT$GL_SYMTBPTR = .PAT$GL_NEWLABLS;			! Use new contents label table
	FILL_CHAR = NOP_INSTR;					! Fill character for instructions
	END
ELSE
	FILL_CHAR = ZERO_BYTE;					! Fill character for data

!++
! Loop to DEPOSIT (DELETE) all parameters specified in the command.
!--
REPEAT
	BEGIN
	POINTER = .LIST_ELEM_FLINK (.POINTER);

	!++
	! Now determine the length of the instruction or data
	! which is to be deposited or deleted.
	!--
	IF .PAT$GB_MOD_PTR [MODE_INSTRUC]
	THEN
		BEGIN
		!++
		! This is a symbolic instruction to be deposited or deleted.
		! It is currently in the form of a counted ASCII string that
		! must be translated into binary form. The call to PAT$INS_ENCODE
		! needs the address for which the instruction is encoded in
		! order to resolve branches correctly.
		!--
		IF NOT PAT$INS_ENCODE (.LIST_ELEM_EXP1 (.POINTER),
			INSTRUC_BUF, .UNMAPPED_LOC,
			(IF .PAT$GL_CONTEXT[DELETE_BIT]
				 THEN PAT$GL_OLD_ASD
				 ELSE PAT$GL_NEW_ASD),
			PAT$GL_TEMP_BUF)
		THEN
			SIGNAL (PAT$_NOENCODE, 1, .LIST_ELEM_EXP1(.POINTER)); ! This instruction is invalid.
		DEP_SRC_ADR = INSTRUC_BUF [1];
		DEP_SIZ = .INSTRUC_BUF [0];
		END
	ELSE
		BEGIN
		!++
		! Determine length and address for deposits or deletes which are
		! not symbolic instructions.  Then check for truncation of new value.
		!--
		DEP_SRC_ADR = LIST_ELEM_EXP1 (.POINTER);
		DEP_SIZ = .PAT$GB_MOD_PTR [MODE_LENGTH];
		IF (.LIST_ELEM_EXP1(.POINTER) LSS 0)
		THEN
			BEGIN
			IF .(LIST_ELEM_EXP1(.POINTER))<0, .DEP_SIZ*8, 1> NEQ .LIST_ELEM_EXP1(.POINTER)
			THEN
				SIGNAL(PAT$_NUMTRUNC);
			END
		ELSE
			IF .(LIST_ELEM_EXP1(.POINTER))<0, .DEP_SIZ*8, 0> NEQ .LIST_ELEM_EXP1(.POINTER)
			THEN
				SIGNAL(PAT$_NUMTRUNC);
		END;

	!++
	! Now write the new values into a temporary buffer.  They are not
	! written directly into memory in case part of the command fails.
	!--
	PAT$FILL_BUF (PAT$GL_TEMP_BUF, .DEP_SRC_ADR, .DEP_SIZ);

	!++
	! Finished with current value.  Reset last location,
	! next location, and last value, and exitloop.
	!--
	PAT$GL_LAST_LOC = .UNMAPPED_LOC;
	UNMAPPED_LOC = .UNMAPPED_LOC + .DEP_SIZ;
	IF NOT .PAT$GB_MOD_PTR [MODE_INSTRUC]
	THEN
		PAT$GL_LAST_VAL = .LIST_ELEM_EXP1 (.POINTER);

	!++
	! If there are no more values, then exit loop which builds 
	! temporary deposit buffer.
	!--
	IF (.LIST_ELEM_FLINK (.POINTER) EQLA 0)
	THEN
		EXITLOOP;
	END;

!++
! For DEPOSIT command only:
!
! First check if this is writing into the patch area.  If so, check that there
! is enough room in the patch area.  If not, then expand the patch area if
! possible (that is, if the current patch area is the one defined int the image
! header).  Otherwise, report an error and abort this command.
!--
IF .PAT$GL_CONTEXT[PAT_AREA_BIT]
THEN
	BEGIN
	IF (.PAT$GL_PATAREA[DSC$W_LENGTH] LSS .PAT$GL_TEMP_BUF[DSC$W_LENGTH])
	THEN
		BEGIN
		IF (.PAT$GL_PATAREA[DSC$A_POINTER] EQLA .PAT$GL_IHPPTR[IHP$L_RW_PATADR])
		THEN
			PAT$EXP_AREA((.PAT$GL_TEMP_BUF[DSC$W_LENGTH] + 
					A_PAGE - 1)/A_PAGE)
		ELSE
			SIGNAL(PAT$_INSUFPAT, 2, .PAT$GL_TEMP_BUF[DSC$W_LENGTH],
				.PAT$GL_PATAREA[DSC$A_POINTER],
				.PAT$GL_PATAREA[DSC$W_LENGTH]);
		END;
	END;

!++
! Now resolve any forward references inside the symbolic instruction operands.
!--
PAT$RESOLVE_INS(PAT$GL_TEMP_BUF);

!++
! Output the old values.
!--
PAT$GL_NEXT_LOC = .LIST_ELEM_EXP1(.PAT$GL_HEAD_LST);
WHILE .PAT$GL_NEXT_LOC LSSA .UNMAPPED_LOC
DO
	PAT$OUT_MEM_LOC(.PAT$GL_NEXT_LOC, OLD_TAB_STG, PAT$GL_OLD_ASD, CASE_TABLE);

!++
! For DELETE commands only:
!
! Verify that the old values were actually in memory for DELETE commands.
! Then fill the temporary buffer with the appropriate fill character.
!--
IF .PAT$GL_CONTEXT[DELETE_BIT]
THEN
	BEGIN
	!++
	! Now get the actual value in the location and
	! check that it equals the specified value.
	!--
	LOCAL
		BYTE_COUNT,					! Count of bytes verified
		BUF_SIZE;					! Size of old contents buffer to get
	BYTE_COUNT = 0;
	WHILE (.BYTE_COUNT LSS .PAT$GL_TEMP_BUF[DSC$W_LENGTH])
	DO
		BEGIN
		IF ((BUF_SIZE = .PAT$GL_TEMP_BUF[DSC$W_LENGTH] - .BYTE_COUNT) GTR TTY_OUT_WIDTH)
		THEN
			BUF_SIZE = TTY_OUT_WIDTH;		! Request only as much as buffer can hold
		PAT$GET_VALUE(.LIST_ELEM_EXP1(.PAT$GL_HEAD_LST)+.BYTE_COUNT,
				 .BUF_SIZE, OLD_CONTENTS);
		IF CH$NEQ(.BUF_SIZE, .PAT$GL_TEMP_BUF[DSC$A_POINTER]+.BYTE_COUNT,
				 .BUF_SIZE, OLD_CONTENTS)
		THEN
			SIGNAL(PAT$_DIFVAL+MSG$K_WARN);
		BYTE_COUNT = .BYTE_COUNT + .BUF_SIZE;
		END;
	CH$FILL(.FILL_CHAR, .PAT$GL_TEMP_BUF[DSC$W_LENGTH],
		 .PAT$GL_TEMP_BUF[DSC$A_POINTER]);
	END;

!++
! Now write the temporary buffer into memory.
!--
PAT$GL_NEXT_LOC = .LIST_ELEM_EXP1(.PAT$GL_HEAD_LST);
PAT$WRITE_MEM (.PAT$GL_NEXT_LOC, .PAT$GL_TEMP_BUF[DSC$A_POINTER],
			 .PAT$GL_TEMP_BUF[DSC$W_LENGTH]);

!++
! Output the new values.
!--
WHILE .PAT$GL_NEXT_LOC LSSA .UNMAPPED_LOC
DO
	PAT$OUT_MEM_LOC(.PAT$GL_NEXT_LOC, NEW_TAB_STG, PAT$GL_NEW_ASD, CASE_TABLE);
!++
! Now check if the deposit was into the current patch area.  If so,
! update the patch area descriptor.
!--
IF .PAT$GL_CONTEXT [PAT_AREA_BIT]
THEN
	BEGIN
	PAT$GL_PATAREA[DSC$A_POINTER] = .PAT$GL_PATAREA[DSC$A_POINTER] + 
					.PAT$GL_TEMP_BUF[DSC$W_LENGTH];
	PAT$GL_PATAREA[DSC$W_LENGTH] = .PAT$GL_PATAREA[DSC$W_LENGTH] - 
					.PAT$GL_TEMP_BUF[DSC$W_LENGTH];
	END;
!++
! Now add the new labels to the user-defined symbol table.
!--
PAT$ADD_LABELS(PAT$GL_NEWLABLS);


RETURN;
END;
SWITCHES OPTIMIZE;

GLOBAL ROUTINE PAT$EXAMINE_CMD : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Examines a list of addresses.
!
! CALLING SEQUENCE:
!
!	PAT$EXAMINE_CMD ()
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	The address of the first element of a list of addresses.
!	The last address examined, and the next logical address to examine.
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	New values for last and next location, and last value
!
! ROUTINE VALUE:
!
!	novalue
!
! SIDE EFFECTS:
!
!	The values of various addresses are output.
!	If an error occurs, the routine returns without further
!	processing except to output an error message to the output
!	device.
!
!--

BEGIN

LOCAL
	MAPPED_NEXT_LOC,					! Mapped address of next location
	ISE_ADDR,						! ISE address for mapped address
	POINTER;

POINTER = .PAT$GL_HEAD_LST;
IF (.POINTER EQL 0)
THEN

	!++
	! No location was specified. Examine the next location in sequence.
	!--
	PAT$OUT_MEM_LOC (.PAT$GL_NEXT_LOC, 0, PAT$GL_OLD_ASD, CASE_TABLE)
ELSE DO
	BEGIN

	LOCAL
		LAST_LOC;

	!++
	! Pick up the next value which we will try to
	! display and copy it into LAST_LOC.
	!--
	LAST_LOC = .LIST_ELEM_EXP1 (.POINTER);

	!++
	! If the end range argument is null, then make it the same as the start
	! range argument so that only one location will be displayed.
	!--
	IF .LIST_ELEM_EXP2 (.POINTER) EQL 0
	THEN LIST_ELEM_EXP2 (.POINTER) = .LIST_ELEM_EXP1 (.POINTER);

	!++
	! Check for range reversal.
	!--
	IF( .LIST_ELEM_EXP2(.POINTER) LSSA .LIST_ELEM_EXP1(.POINTER) )
	THEN
		BEGIN
		SIGNAL (PAT$_EXARANGE);
		RETURN;
		END;
	WHILE (.LAST_LOC LEQ .LIST_ELEM_EXP2 (.POINTER)) DO
		BEGIN
		IF NOT PAT$OUT_MEM_LOC (.LAST_LOC, 0, PAT$GL_OLD_ASD, CASE_TABLE)
		THEN RETURN;
		LAST_LOC = .PAT$GL_NEXT_LOC;
		END;
	END
UNTIL (POINTER = .LIST_ELEM_FLINK (.POINTER)) EQL 0;

END;

GLOBAL ROUTINE PAT$REPLACE_CMD : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine handles all REPLACE, INSERT and VERIFY commands, those for
!	instructions and those for values.  The instruction/value specified in
!	the command must be identical to those actually contained in the
!	location, otherwise an error message is produced and the command
!	ends prematurely.
!
!	The command argument list is made up of entries that are
!	each three longwords long. The first is a forward link to the
!	next entry. The second longword in the first entry in the list
!	is the address into which some value(s) is (are) to be replaced.
!	The third longword is unused. The second longword in successive
!	arguments is the old values/instructions and thier replacemeents.
!	The first value should be the contents of the specified location;
!	the second, the contents of that location plus the current mode_length,
!	etc.  The last old value has an EXIT_TOKEN in the third longword
!	(all others have zero).
!
!	For instruction replacement, the second longword contains
!	the address of a counted ascii stream that is to be translated
!	into a binary instruction.
!
!	The VERIFY command is identical to the replace command save
!	that it has no replacement values.  The INSERT command has only one
!	old instruction and causes it to be moved to the patch area instead
!	of replaced.
!
!	There are three label tables used to differentiate between old labels,
!	new un-relocated labels, and new relocated labels.  The table(s) used
!	to resolve symbols inside symbolic instructions depends updon which
!	instruction is being encoded (old or new) and whether or not they are
!	being relocated to patch area.  Three tables are necessary to handle
!	relocation correctly, i.e., old labels can be used for all instructions
!	but new labels cannot be used for relocated instructions.  No labels
!	can be added to the user-defined symbol table until the PATCH command
!	is successfully executed.
!
! CALLING SEQUENCE:
!
!	PAT$REPLACE_CMD ()
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	PAT$GL_HEAD_LST, the head of the linked PATCH command argument list.
!	the current mode, and the current patch area descriptor.
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	novalue
!
! SIDE EFFECTS:
!
!	If a failure in a write or contents verification occurs,
!	the routine returns immediately.  If the command is executed
!	successfully, then the specified addresses have new values and any
!	labels in the command are added to the user-defined symbol table.
!
!--

BEGIN

LITERAL
	NOP_INSTR = 1,						! Fill character for instructions
	ZERO_BYTE = 0,						! Fill characters for data
	MAX_INST_LEN	= 80;					! Maximum number of binary bytes in an instruction

LOCAL
	BYTE_COUNT,						! Count of bytesverified
	BUF_SIZE,						! Size of OLD_CONTENTS to compare
	INSTRUC_BUF: VECTOR [MAX_INST_LEN, BYTE],
	OLD_CONTENTS : VECTOR[TTY_OUT_WIDTH,BYTE],		! Buffer to hold actual contents of location
	UNMAPPED_LOC,						! Unmapped address of DEPOSIT destination
	OLD_VALUE_PTR : REF VECTOR[,BYTE],			! Pointer of actual contents of location
	VAL_SIZ,						! Size of current value/instruction
	HOLE_SIZ,						! Cumulative size to replace
	NEXT_LOC,						! Pointer to next consecutive location
	FILL_CHAR : BYTE,					! Fill character for data/instructions
	POINTER,
	OLD_INS_SIZ,						! Number of bytes of old instruction moved for INSERT command
	NEW_INS_PTR;						! Pointer to first new instruction argument

!++
! Check for required parameter.
!--
POINTER = .PAT$GL_HEAD_LST;
IF  (.POINTER EQLA 0) OR (.LIST_ELEM_FLINK (.POINTER) EQLA 0)
THEN
	SIGNAL(PAT$_INVCMD);

!++
! Set the examine bit for PAT$OUT_MEM_LOC.
!
PAT$GL_CONTEXT [EXAMINE_BIT] = TRUE;
UNMAPPED_LOC = .LIST_ELEM_EXP1 (.POINTER);
NEXT_LOC = .LIST_ELEM_EXP1 (.POINTER);
HOLE_SIZ = 0;
PAT$GL_SYMTBPTR = .PAT$GL_OLDLABLS;				! Use old contents label list

!++
! Now loop, validating the old contents are the expected values.
! The last old value argument contains an EXIT_TOKEN in position LIST_ELEM_EXP2.
!--
REPEAT
	BEGIN
	POINTER = .LIST_ELEM_FLINK (.POINTER);

	!++
	! Now compute the binary instruction stream that should be in
	! the location.
	!--
	IF .PAT$GB_MOD_PTR [MODE_INSTRUC]
	THEN
		BEGIN
		!++
		! This is a symbolic instruction.  It is currently
		! in the form of a counted ASCII string that must be translated
		! into binary form. The call to PAT$INS_ENCODE needs the address
		! into which the instruction is being deposited in order to
		! resolve branches correctly.
		!--
		IF NOT PAT$INS_ENCODE (.LIST_ELEM_EXP1 (.POINTER),
			INSTRUC_BUF, .NEXT_LOC, PAT$GL_OLD_ASD, PAT$GL_TEMP_BUF)
		THEN
			SIGNAL (PAT$_NOENCODE, 1, .LIST_ELEM_EXP1(.POINTER)); ! This instruction is not valid.
		OLD_VALUE_PTR = INSTRUC_BUF [1];
		VAL_SIZ = .INSTRUC_BUF [0];
		END
	ELSE
		BEGIN
		!++
		! Value is not an instruction.  Therefore it is on the parse
		! stack.  The current mode for length tells the number of bytes
		! of the value.  Set pointer to data and size indicator.  Then
		! check for a truncation error.
		!--
		OLD_VALUE_PTR = LIST_ELEM_EXP1 (.POINTER);
		VAL_SIZ = .PAT$GB_MOD_PTR [MODE_LENGTH];
		IF .LIST_ELEM_EXP1(.POINTER) LSS 0
		THEN
			BEGIN
			IF .(LIST_ELEM_EXP1(.POINTER))<0, .VAL_SIZ*8, 1> NEQ .LIST_ELEM_EXP1(.POINTER)
			THEN
				SIGNAL(PAT$_NUMTRUNC);
			END
		ELSE
			IF .(LIST_ELEM_EXP1(.POINTER))<0, .VAL_SIZ*8, 0> NEQ .LIST_ELEM_EXP1(.POINTER)
			THEN
				SIGNAL(PAT$_NUMTRUNC);
		END;

	PAT$FILL_BUF(PAT$GL_TEMP_BUF, .OLD_VALUE_PTR, .VAL_SIZ);
	HOLE_SIZ = .HOLE_SIZ + .VAL_SIZ;			! Add current size to cumulative
								! Output old contents
	PAT$OUT_MEM_LOC(.NEXT_LOC, OLD_TAB_STG, PAT$GL_OLD_ASD, NO_CASE_TABLE);
	NEXT_LOC = .PAT$GL_NEXT_LOC;				! Point to next location

	!++
	! Check if this is the last old argument.
	!--
	IF .LIST_ELEM_EXP2(.POINTER) EQL EXIT_TOKEN
	THEN
		EXITLOOP;
	END;

!++
! Resolve any forward references in symbolic instruction operands.
!--
PAT$RESOLVE_INS(PAT$GL_TEMP_BUF);

!++
! Now get the actual values in the locations and
! check that they equal the specified values.
!--
BYTE_COUNT = 0;
WHILE (.BYTE_COUNT LSS .HOLE_SIZ)
DO
	BEGIN
	IF ((BUF_SIZE = .HOLE_SIZ - .BYTE_COUNT) GTR TTY_OUT_WIDTH)
	THEN
		BUF_SIZE = TTY_OUT_WIDTH;
	PAT$GET_VALUE(.LIST_ELEM_EXP1(.PAT$GL_HEAD_LST)+.BYTE_COUNT,
			 .BUF_SIZE, OLD_CONTENTS);
	IF CH$NEQ(.BUF_SIZE, .PAT$GL_TEMP_BUF[DSC$A_POINTER]+.BYTE_COUNT,
			 .BUF_SIZE, OLD_CONTENTS)
	THEN
		SIGNAL(PAT$_DIFVAL+MSG$K_WARN);
	BYTE_COUNT = .BYTE_COUNT + .BUF_SIZE;
	END;

!++
! Release the storage holding the old instructions.
!--
PAT$FREERELEASE(.PAT$GL_TEMP_BUF[DSC$A_POINTER], (.PAT$GL_TEMP_BUF[DSC$W_LENGTH]+3)/4);
PAT$GL_TEMP_BUF[DSC$W_LENGTH] = 0;
PAT$GL_TEMP_BUF[DSC$A_POINTER] = 0;
!++
! If this was a VERIFY command, we are all done.  Return for next command.
!--
IF .PAT$GL_CONTEXT[VERIFY_BIT]
THEN
	RETURN;

!++
! Check if old instruction should be moved to patch area, i.e., is this an
! INSERT command.  Remember the number of bytes of old instructions moved
! in case there are forward referenced symbols to relocate in the new
! instructions.
!--
IF .PAT$GL_CONTEXT [INSERT_BIT]
THEN
	BEGIN
	PAT$FILL_BUF(PAT$GL_TEMP_BUF, INSTRUC_BUF[1], .INSTRUC_BUF[0]);
	OLD_INS_SIZ = .PAT$GL_TEMP_BUF[DSC$W_LENGTH];		! Remember # of bytes of old instructions moved
	END
ELSE
	BEGIN
	OLD_INS_SIZ = 0;					! No old instructions moved
	NEXT_LOC = .UNMAPPED_LOC;				! Set next deposit location for REPLACE command
	END;

!++
! Now fit the replacement value/instruction into the location.
!--
IF (NEW_INS_PTR = .LIST_ELEM_FLINK(.POINTER)) EQLA 0		! If no replacement argument
THEN								! then report error
	SIGNAL(PAT$_INVCMD);
PAT$GL_SYMTBPTR = .PAT$GL_NEWLABLS;				! Use the new contents label table

!++
! Now build a buffer containing the new values to be deposited.  The deposits
! are not done directly to memory in case part of the command is invalid.
!--
WHILE (POINTER = .LIST_ELEM_FLINK(.POINTER)) NEQA 0		! Point to next argument
DO
	BEGIN
	IF .PAT$GB_MOD_PTR [MODE_INSTRUC]			! Test for instruction or data replacement
	THEN
		BEGIN
		!++
		! Now encode the replacement instruction.
		!--
		FILL_CHAR = NOP_INSTR;				! Set the fill character
		IF NOT PAT$INS_ENCODE(.LIST_ELEM_EXP1(.POINTER), INSTRUC_BUF,
				 .NEXT_LOC, PAT$GL_NEW_ASD, PAT$GL_TEMP_BUF)
		THEN
			SIGNAL(PAT$_NOENCODE, 1, .LIST_ELEM_EXP1(.POINTER));
		PAT$FILL_BUF(PAT$GL_TEMP_BUF, INSTRUC_BUF[1], .INSTRUC_BUF[0]); ! Insert instruction into temporary buffer
		NEXT_LOC = .NEXT_LOC + .INSTRUC_BUF[0];
		END
	ELSE
		!++
		! The replacement is for a value.  Therefore it is on the parse
		! stack.  Check for a truncation error.  Then set the fill
		! character and write the value to the temporary buffer.
		!--
		BEGIN
		IF .LIST_ELEM_EXP1(.POINTER) LSS 0
		THEN
			BEGIN
			IF .(LIST_ELEM_EXP1(.POINTER))<0, .VAL_SIZ*8, 1> NEQ .LIST_ELEM_EXP1(.POINTER)
			THEN
				SIGNAL(PAT$_NUMTRUNC);
			END
		ELSE
			IF .(LIST_ELEM_EXP1(.POINTER))<0, .VAL_SIZ*8, 0> NEQ .LIST_ELEM_EXP1(.POINTER)
			THEN
				SIGNAL(PAT$_NUMTRUNC);
		FILL_CHAR = ZERO_BYTE;				! Set the fill character
		PAT$FILL_BUF(PAT$GL_TEMP_BUF, LIST_ELEM_EXP1(.POINTER), .VAL_SIZ);
		NEXT_LOC = .NEXT_LOC + .VAL_SIZ;
		END;
	END;
!++
! Resolve the forward references in symbolic instruction operands.
!--
PAT$RESOLVE_INS(PAT$GL_TEMP_BUF);

!++
! Now check the replacement size against old instruction size.
!--
IF .PAT$GL_TEMP_BUF[DSC$W_LENGTH] LSS .HOLE_SIZ			! Make temporary buffer at least as large as hole
THEN
	BEGIN
	LOCAL
		TEMP_PTR;					! Temporary pointer to temporary buffer

	TEMP_PTR = PAT$FREEZ((.HOLE_SIZ + A_LONGWORD - 1)/A_LONGWORD);
	CH$COPY(.PAT$GL_TEMP_BUF[DSC$W_LENGTH], .PAT$GL_TEMP_BUF[DSC$A_POINTER],
		.FILL_CHAR, .HOLE_SIZ, .TEMP_PTR);
	PAT$FREERELEASE(.PAT$GL_TEMP_BUF[DSC$A_POINTER], (.PAT$GL_TEMP_BUF[DSC$W_LENGTH] +3)/4);
	PAT$GL_TEMP_BUF[DSC$A_POINTER] = CH$PTR(.TEMP_PTR, 0);
	PAT$GL_TEMP_BUF[DSC$W_LENGTH] = .HOLE_SIZ;
	END;

!++
! Now write the temporary buffer over the mapped input image.
!--
IF .PAT$GL_TEMP_BUF[DSC$W_LENGTH] EQL .HOLE_SIZ
THEN
	BEGIN
	!++
	! Replacement data fits.  Write it to memory and output new contents.
	!--
	PAT$WRITE_MEM(.UNMAPPED_LOC, .PAT$GL_TEMP_BUF[DSC$A_POINTER], .PAT$GL_TEMP_BUF[DSC$W_LENGTH]);
	NEXT_LOC = .UNMAPPED_LOC + .HOLE_SIZ;
	PAT$GL_NEXT_LOC = .UNMAPPED_LOC;
	WHILE .PAT$GL_NEXT_LOC LSSA .NEXT_LOC			! Output new contents
	DO
		PAT$OUT_MEM_LOC(.PAT$GL_NEXT_LOC, NEW_TAB_STG, PAT$GL_NEW_ASD, CASE_TABLE);
	END
ELSE
	BEGIN
	!++
	! The replacement instruction is too large.  It
	! must be relocated to the patch area.
	!--
	IF .PAT$GB_MOD_PTR [MODE_INSTRUC]
	THEN
		RELOCAT_INS(.UNMAPPED_LOC, .HOLE_SIZ, .OLD_INS_SIZ, .NEW_INS_PTR)
	ELSE
		SIGNAL(PAT$_REPLACEERR);			! Internal error if patch area needed for data replacements
	END;
!++
! Now add all the new labels to the user-defined symbol table.
!--
PAT$ADD_LABELS(PAT$GL_OLDLABLS);
PAT$ADD_LABELS(PAT$GL_NEWLABLS);
PAT$ADD_LABELS(PAT$GL_RLCLABLS);
RETURN;
END;								! End of PAT$REPLACE_CMD

ROUTINE RELOCAT_INS (OLD_LOC, HOLE_SIZE, OLD_INS_SIZ, ASC_INS_PTR) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine relocates an instruction from an old address to the patch
!	area.  It then moves in any new instructions, specified as an argument
!	list for a patch command.  A branch or jump instruction is then put
!	into the old address.  If there is not enough room left by the
!	removal of the instruction, then more instructions are moved to the
!	patch area until the branch instruction iwll fit.  Lastly, a return
!	branch instruction is placed in the patch area to return execution
!	to the next sequential instruction past the old address.
!
!	Any new instructions to be inserted are in a command argument
!	list, created by the parser.  Each argument entry is made up of
!	three longwords. The first is a forward link to the next entry.
!	The second longword contains the address of a counted byte stream
!	that is to be translated into a binary instruction which is
!	to be inserted into the patch area.  The third longword is unused.
!
! CALLING SEQUENCE:
!
!	RELOCATE_CMD (OLD_LOCATION, NEW_INSTRUCTION_PTR)
!
! INPUTS:
!
!	OLD_LOC - Unmapped address of instruction to be moved
!	HOLE_SIZE - Number of free bytes at OLD_LOC
!	OLD_INS_SIZ - Number of bytes of old instruction preceding new instruction
!	ASC_INS_PTR - Pointer to first new instruction on command argument list
!
! IMPLICIT INPUTS:
!
!	PAT$GL_TEMP_BUF - String descriptor for counted binary instructions
!
!	The head of the linked list, the current mode, and
!	the current patch area descriptor.
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	novalue
!
! SIDE EFFECTS:
!
!	The patch area now contains the moved instruction and the new ones
!	plus a branch instruction back to the inline code.  The old
!	instruction location contains a branch to the patch area.
!	If a failure in a write or contents verification occurs,
!	the routine returns immediately.
!
!--

BEGIN

LITERAL
	MAX_BYTE_DISP = 127,					! Maximum displacement for BRB
	MIN_BYTE_DISP = -128,					! Minimum displacement for BRB
	MAX_WORD_DISP = 32767,					! Maximum displacement for BRW
	MIN_WORD_DISP = -32768,					! Minimum displacement for BRW
	BRB_OPCODE = %X'11',					! Opcode for BRB
	BRW_OPCODE = %X'31',					! Opcode for BRW
	JMP_OPCODE = %X'17',					! Opcode for JMP
	BRB_INS_SIZ = 2,					! Size of BRB instruction
	BRW_INS_SIZ = 3,					! Size of BRW instruction
	JMP_INS_SIZ = 6,					! Size of JMP instruction
	PC_DEFERRED = %X'EF',					! PC deferred instruction mode
	NOP_INSTR = 1,						! Fill character for instruction
	MAX_INST_LEN	= 80;					! Maximum number of binary bytes in an instruction

LOCAL
	SUCC_OLD_INS,						! Number of bytes of successive old instructions moved
	DECODED_INS,						! Pointer to ascii instruction
	NXT_ASC_INS,						! Pointer to next ascii instruction in argument list
	NEXT_PC,						! PC of next instruction to decode
	NEW_INS_PTR : REF VECTOR[,BYTE],			! Pointer to relocated instruction stream
	BR_DISPLACEMENT : SIGNED LONG,				! Displacement for branch instruction
	BR_INSTRUC : VECTOR[JMP_INS_SIZ+1,BYTE],		! Encoded counted string branch instruction
	NEW_LOC,						! Address in patch area for relocated instructions
	NEXT_LOC,						! Address of next instruction of inline code
	CUR_LOC,						! Address of current instruction to be moved
	LOCAL_BUF : VECTOR[MAX_INST_LEN, BYTE],			! Local buffer for binary instruction stream
	INSTRUC_BUF: VECTOR [MAX_INST_LEN, BYTE];		! Local buffer for ascic instructions

!++
! Enable instruction substitution.
!--
PAT$GL_CONTEXT[INST_SUBST] = TRUE;
PAT$GL_SYMTBPTR = .PAT$GL_RLCLABLS;

!++
! Check that there is enough room in the patch area for the instructions
! encoded in the temporary buffer, PAT$GL_TEMP_BUF.  This is the minimum size
! that may be required.  Instruction substitution may enlarge this size.  This
! will also insure that a patch area address is defined.
!--
IF (.PAT$GL_PATAREA[DSC$W_LENGTH] LSS .PAT$GL_TEMP_BUF[DSC$W_LENGTH])
THEN
	BEGIN
	IF (.PAT$GL_PATAREA[DSC$A_POINTER] EQLA .PAT$GL_IHPPTR[IHP$L_RW_PATADR])
	THEN
		BEGIN
		PAT$EXP_AREA((.PAT$GL_TEMP_BUF[DSC$W_LENGTH] + A_PAGE - 1)/A_PAGE);
		IF (.PAT$GL_PATAREA[DSC$W_LENGTH] LSS .PAT$GL_TEMP_BUF[DSC$W_LENGTH])
		THEN
			SIGNAL(PAT$_INSUFPAT, 3, .PAT$GL_TEMP_BUF[DSC$W_LENGTH],
			 .PAT$GL_PATAREA[DSC$A_POINTER], .PAT$GL_PATAREA[DSC$W_LENGTH]);
		END
	ELSE
		SIGNAL(PAT$_INSUFPAT, 3, .PAT$GL_TEMP_BUF[DSC$W_LENGTH],
		 .PAT$GL_PATAREA[DSC$A_POINTER], .PAT$GL_PATAREA[DSC$W_LENGTH]);
	END;

!++
! Set pointer to relocation address.
!--
NEW_LOC = CH$PTR(.PAT$GL_PATAREA[DSC$A_POINTER], 0);

!++
! Now compute the branch displacement size.  Then build the binary code
! based on the displacement.
!--
BR_DISPLACEMENT = .NEW_LOC - .OLD_LOC - BRB_INS_SIZ;
IF (.BR_DISPLACEMENT LEQ MAX_BYTE_DISP) AND (.BR_DISPLACEMENT GEQ MIN_BYTE_DISP)
THEN
	BEGIN
	BR_INSTRUC[0] = BRB_INS_SIZ;
	BR_INSTRUC[1] = BRB_OPCODE;
	CH$MOVE(.BR_INSTRUC[0], CH$PTR(BR_DISPLACEMENT,0), CH$PTR(BR_INSTRUC[2],0));
	END
ELSE
	IF (.BR_DISPLACEMENT LEQ MAX_WORD_DISP) AND (.BR_DISPLACEMENT GEQ MIN_WORD_DISP)
	THEN
		BEGIN
		BR_INSTRUC[0] = BRW_INS_SIZ;
		BR_INSTRUC[1] = BRW_OPCODE;
		BR_DISPLACEMENT = .BR_DISPLACEMENT - (BRW_INS_SIZ - BRB_INS_SIZ);
		CH$MOVE(.BR_INSTRUC[0], CH$PTR(BR_DISPLACEMENT,0), CH$PTR(BR_INSTRUC[2],0));
		END
	ELSE
		BEGIN
		BR_INSTRUC[0] = JMP_INS_SIZ;
		BR_INSTRUC[1] = JMP_OPCODE;
		BR_INSTRUC[2] = PC_DEFERRED;
		BR_DISPLACEMENT = .BR_DISPLACEMENT - (JMP_INS_SIZ - BRB_INS_SIZ);
		CH$MOVE(.BR_INSTRUC[0], CH$PTR(BR_DISPLACEMENT,0), CH$PTR(BR_INSTRUC[3],0));
		END;

!++
! Now see if the branch instruction will fit in the hole left at the old
! location.  If not, then move more instructions to the patch area until it
! will fit.
!--
NEXT_LOC = .OLD_LOC + .HOLE_SIZE;				! Compute address of next inline instruction
NEXT_PC = .OLD_LOC + .HOLE_SIZE;				! Compute address of next inline instruction
SUCC_OLD_INS = .PAT$GL_TEMP_BUF[DSC$W_LENGTH];			! Remember where extra old instructions moved are
WHILE .BR_INSTRUC[0] GTR .HOLE_SIZE
DO
	BEGIN
	!++
	! First decode the instruction at the next old location.  Then
	! re-encode it to get the binary stream.  Then insert it into
	! the temporary buffer.
	!--
	PAT$OUT_MEM_LOC(.NEXT_LOC, OLD_TAB_STG, PAT$GL_OLD_ASD, NO_CASE_TABLE);
	PAT$GL_BUF_SIZ = 0;
	PAT$CP_OUT_STR = CH$PTR(LOCAL_BUF[1]);

	!++
	! Because the instruction is actually in the code, the PC is the
	! same as the address of the byte stream.  PAT$INS_DECODE will update
	! the NEW_PC automatically.  To determine the length of the instruction
	! binary stream just decoded (for updating the HOLE_SIZE), NEXT_LOC must
	! be preserved.  Therefore, the return value from the routine is written
	! into NEW_PC not NEXT_LOC.  This will be the same value, unless the
	! routine failed.
	!--
	IF (NEXT_PC = PAT$INS_DECODE(.NEXT_LOC, 0, NEXT_PC, PAT$GL_OLD_ASD, NO_CASE_TABLE)) EQL 0
	THEN
		SIGNAL(PAT$_NODECODE);
	LOCAL_BUF[0] = .PAT$GL_BUF_SIZ;
	NEW_INS_PTR = CH$PTR(INSTRUC_BUF, 0);
	IF NOT PAT$INS_ENCODE(LOCAL_BUF, INSTRUC_BUF,
		 .OLD_LOC + .PAT$GL_TEMP_BUF[DSC$W_LENGTH], PAT$GL_NEW_ASD, PAT$GL_TEMP_BUF)
	THEN
		IF (.PAT$GB_SUBST_IN[0] NEQ 0)
		THEN
			NEW_INS_PTR = CH$PTR(PAT$GB_SUBST_IN, 0)
		ELSE
			SIGNAL(PAT$_NOENCODE, 1, LOCAL_BUF);
	!++
	! There is a temporary restriction on relocation of CASE instructions
	!--
	IF (.NEW_INS_PTR[1] EQL OP_CASEB) OR
	   (.NEW_INS_PTR[1] EQL OP_CASEW) OR
	   (.NEW_INS_PTR[1] EQL OP_CASEL)
	THEN
		SIGNAL(PAT$_NORELOC + MSG$K_SEVERE);
	PAT$FILL_BUF(PAT$GL_TEMP_BUF, NEW_INS_PTR[1], .NEW_INS_PTR[0]);
	HOLE_SIZE = .HOLE_SIZE + .NEXT_PC - .NEXT_LOC;
	NEXT_LOC = .NEXT_PC;
	END;

!++
! Decode the instructions in the temporary buffer and re-encode them at the
! patch area address.  This will alter the addresses within the instructions.
!--
CUR_LOC = .PAT$GL_TEMP_BUF[DSC$A_POINTER];
NEXT_PC = .OLD_LOC;
NXT_ASC_INS = .ASC_INS_PTR;					! Get pointer to next new instruction argument
WHILE .CUR_LOC LSSA (.PAT$GL_TEMP_BUF[DSC$A_POINTER] + .PAT$GL_TEMP_BUF[DSC$W_LENGTH])
DO
	BEGIN
	PAT$GL_BUF_SIZ = 0;
	PAT$CP_OUT_STR = CH$PTR(LOCAL_BUF[1]);
	IF (.CUR_LOC GEQA .PAT$GL_TEMP_BUF[DSC$A_POINTER] + .OLD_INS_SIZ) AND
	   (.CUR_LOC LSSA .PAT$GL_TEMP_BUF[DSC$A_POINTER] + .SUCC_OLD_INS)
	THEN
		BEGIN
		!++
		! Take the new instructions out of the argument list in
		! case there are any labels which will be relocated.
		! This is only done for new instructions being deposited.
		! The old instructions being relocated are decoded and re-encoded.
		!--
		DECODED_INS = .LIST_ELEM_EXP1(.NXT_ASC_INS);
		NXT_ASC_INS = .LIST_ELEM_FLINK(.NXT_ASC_INS);
		PAT$GL_SYMTBPTR = .PAT$GL_RLCLABLS;		! Use reolcated label table
		END
	ELSE
		BEGIN
		!++
		! The instruction is an old instruction.  Therefore use the
		! old label table and encode it from the decoded instruction.
		!--
		DECODED_INS = LOCAL_BUF;			! Point to ascii instruction
		PAT$GL_SYMTBPTR = .PAT$GL_OLDLABLS;		! Assume this is an old instruction
		END;
	IF (CUR_LOC = PAT$INS_DECODE(.CUR_LOC, 0, NEXT_PC, PAT$GL_NEW_ASD, NO_CASE_TABLE)) EQL 0
	THEN
		SIGNAL(PAT$_NODECODE);
	LOCAL_BUF[0] = .PAT$GL_BUF_SIZ;
	NEW_INS_PTR = CH$PTR(INSTRUC_BUF, 0);			! Set pointer to counted stream buffer
	IF NOT PAT$INS_ENCODE(.DECODED_INS, INSTRUC_BUF,
		 .NEW_LOC + .PAT$GL_RLOC_BUF[DSC$W_LENGTH], PAT$GL_NEW_ASD, PAT$GL_RLOC_BUF)
	THEN
		IF (.PAT$GB_SUBST_IN[0] NEQ 0)
		THEN
			NEW_INS_PTR = CH$PTR(PAT$GB_SUBST_IN, 0)
		ELSE
			SIGNAL(PAT$_NOENCODE, 1, LOCAL_BUF);
	!++
	! There is a temporary restriction on relocation of CASE instructions
	!--
	IF (.NEW_INS_PTR[1] EQL OP_CASEB) OR
	   (.NEW_INS_PTR[1] EQL OP_CASEW) OR
	   (.NEW_INS_PTR[1] EQL OP_CASEL)
	THEN
		SIGNAL(PAT$_NORELOC + MSG$K_SEVERE);
	PAT$FILL_BUF(PAT$GL_RLOC_BUF, NEW_INS_PTR[1], .NEW_INS_PTR[0]);
	END;
PAT$GL_SYMTBPTR = .PAT$GL_RLCLABLS;				! Set relocated labels as default (old always gets searched)
PAT$RESOLVE_INS(PAT$GL_RLOC_BUF);

!++
! Now a return branch instruction must be placed in the relocation buffer.
! Compute the branch displacement size.  Then build the binary code based on
! the displacement.
!--
BR_DISPLACEMENT = .NEXT_LOC - (.PAT$GL_PATAREA[DSC$A_POINTER] + 
			.PAT$GL_RLOC_BUF[DSC$W_LENGTH]) - BRB_INS_SIZ;
IF (.BR_DISPLACEMENT LEQ MAX_BYTE_DISP) AND (.BR_DISPLACEMENT GEQ MIN_BYTE_DISP)
THEN
	BEGIN
	INSTRUC_BUF[0] = BRB_INS_SIZ;
	INSTRUC_BUF[1] = BRB_OPCODE;
	CH$MOVE(.INSTRUC_BUF[0], CH$PTR(BR_DISPLACEMENT,0), CH$PTR(INSTRUC_BUF[2],0));
	END
ELSE
	IF (.BR_DISPLACEMENT LEQ MAX_WORD_DISP) AND (.BR_DISPLACEMENT GEQ MIN_WORD_DISP)
	THEN
		BEGIN
		INSTRUC_BUF[0] = BRW_INS_SIZ;
		INSTRUC_BUF[1] = BRW_OPCODE;
		BR_DISPLACEMENT = .BR_DISPLACEMENT - (BRW_INS_SIZ - BRB_INS_SIZ);
		CH$MOVE(.INSTRUC_BUF[0], CH$PTR(BR_DISPLACEMENT,0), CH$PTR(INSTRUC_BUF[2],0));
		END
	ELSE
		BEGIN
		INSTRUC_BUF[0] = JMP_INS_SIZ;
		INSTRUC_BUF[1] = JMP_OPCODE;
		INSTRUC_BUF[2] = PC_DEFERRED;
		BR_DISPLACEMENT = .BR_DISPLACEMENT - (JMP_INS_SIZ - BRB_INS_SIZ);
		CH$MOVE(.INSTRUC_BUF[0], CH$PTR(BR_DISPLACEMENT,0), CH$PTR(INSTRUC_BUF[3],0));
		END;
PAT$FILL_BUF(PAT$GL_RLOC_BUF, INSTRUC_BUF[1], .INSTRUC_BUF[0]);

!++
! Now insert all new instructions into the patch area.
!--
IF (.PAT$GL_RLOC_BUF[DSC$W_LENGTH] GTR .PAT$GL_PATAREA[DSC$W_LENGTH])
THEN
	BEGIN
	IF (.PAT$GL_PATAREA[DSC$A_POINTER] EQLA .PAT$GL_IHPPTR[IHP$L_RW_PATADR])
	THEN
		BEGIN
		PAT$EXP_AREA((.PAT$GL_RLOC_BUF[DSC$W_LENGTH] + A_PAGE - 1)/A_PAGE);
		IF (.PAT$GL_PATAREA[DSC$W_LENGTH] LSS .PAT$GL_RLOC_BUF[DSC$W_LENGTH])
		THEN
			SIGNAL(PAT$_INSUFPAT, 3, .PAT$GL_RLOC_BUF[DSC$W_LENGTH],
			 .PAT$GL_PATAREA[DSC$A_POINTER], .PAT$GL_PATAREA[DSC$W_LENGTH]);
		END
	ELSE
		SIGNAL(PAT$_INSUFPAT, 3, .PAT$GL_RLOC_BUF[DSC$W_LENGTH],
		 .PAT$GL_PATAREA[DSC$A_POINTER], .PAT$GL_PATAREA[DSC$W_LENGTH]);
	END;
PAT$WRITE_MEM(.PAT$GL_PATAREA[DSC$A_POINTER], .PAT$GL_RLOC_BUF[DSC$A_POINTER], .PAT$GL_RLOC_BUF[DSC$W_LENGTH]);
PAT$GL_PATAREA[DSC$W_LENGTH] = .PAT$GL_PATAREA[DSC$W_LENGTH] - .PAT$GL_RLOC_BUF[DSC$W_LENGTH];
PAT$GL_PATAREA[DSC$A_POINTER] = .PAT$GL_PATAREA[DSC$A_POINTER] + .PAT$GL_RLOC_BUF[DSC$W_LENGTH];

!++
! Now there is room for the branch instruction at the old location hole.
! Set up a buffer with the encoded branch instruction followed by NOP's to
! insert there.  Then write it to the old location hole.
!--
IF (.HOLE_SIZE GTR .BR_INSTRUC[0])
THEN
	BEGIN
	NEW_INS_PTR = PAT$FREEZ((.HOLE_SIZE + A_LONGWORD - 1)/A_LONGWORD);
	CH$COPY(.BR_INSTRUC[0], CH$PTR(BR_INSTRUC[1], 0), NOP_INSTR,
		 .HOLE_SIZE, CH$PTR(.NEW_INS_PTR, 0));
	PAT$WRITE_MEM(.OLD_LOC, CH$PTR(.NEW_INS_PTR, 0), .HOLE_SIZE);
	PAT$FREERELEASE(CH$PTR(.NEW_INS_PTR, 0), (.HOLE_SIZE + 3)/4);
	END
ELSE
	PAT$WRITE_MEM(.OLD_LOC, CH$PTR(BR_INSTRUC[1], 0), .HOLE_SIZE);

!++
! Now write out all the new instructions deposited.
!--
NEXT_LOC = .OLD_LOC;
WHILE (.NEXT_LOC LSS .OLD_LOC+.HOLE_SIZE)
DO
	BEGIN
	PAT$OUT_MEM_LOC(.NEXT_LOC, NEW_TAB_STG, PAT$GL_NEW_ASD, NO_CASE_TABLE);
	NEXT_LOC = .PAT$GL_NEXT_LOC;
	END;
NEXT_LOC = .NEW_LOC;
WHILE (.NEXT_LOC LSS .PAT$GL_PATAREA[DSC$A_POINTER])
DO
	BEGIN
	PAT$OUT_MEM_LOC(.NEXT_LOC, NEW_TAB_STG, PAT$GL_NEW_ASD, NO_CASE_TABLE);
	NEXT_LOC = .PAT$GL_NEXT_LOC;
	END;

RETURN;
END;								! End of RELOCAT_INS

GLOBAL ROUTINE PAT$SUBST_INS (OLD_INS_PTR, INS_PC) =

!++
! FUNCTIONAL DESCRIPTION:
!
! This routine substitutes other instruction sequences for branch-type
! instructions that have been relocated to a new address and whose branch
! displacements are now too small.  The following table describes the
! possible substitutions.  If the branch in the first replacement choice does
! not reach, then the second replacement choice is used.  Notice that the blank
! lines in the table separate groups of instructions that are handled
! similarly for substitutions.
!
! OPC	INSTRUC		REPLACEMENT 1			REPLACEMENT 2
! ---	-------		-------------			-------------
!
! 12	BNEQ <X>	BEQL .+03, BRW <X>		BEQL .+06, JMP <X>
! 13	BEQL <X>	BNEQ .+03, BRW <X>		BNEQ .+06, JMP <X>
! 14	BGTR <X>	BLEQ .+03, BRW <X>		BLEQ .+06, JMP <X>
! 15	BLEQ <X>	BGTR .+03, BRW <X>		BGTR .+06, JMP <X>
! 18	BGEQ <X>	BLSS .+03, BRW <X>		BLSS .+06, JMP <X>
! 19	BLSS <X>	BLSS .+03, BRW <X>		BLSS .+06, JMP <X>
! 1A	BGTRU <X>	BLEQU .+03, BRW <X>		BLEQU .+06, JMP <X>
! 1B	BLEQU <X>	BGTRU .+03, BRW <X>		BGTRU .+06, JMP <X>
! 1C	BVC <X>		BVS .+03, BRW <X>		BVS .+06, JMP <X>
! 1D	BVS <X>		BVC .+03, BRW <X>		BVC .+06, JMP <X>
! 1E	BGEQU <X>	BLSSU .+03, BRW <X>		BLSSU .+06, JMP <X>
! 1F	BLSSU <X>	BGEQU .+03, BRW <X>		BGEQU .+06, JMP <X>
! E0	BBS <X>		BBC .+03, BRW <X>		BBC .+06, JMP <X>
! E1	BBC <X>		BBS .+03, BRW <X>		BBS .+06, JMP <X>
! E2	BBSS <X>	BBCS .+03, BRW <X>		BBCS .+06, JMP <X>
! E3	BBCS <X>	BBSS .+06, BRW <X>		BBSS .+03, JMP <X>
! E4	BBSC <X>	BBCC .+03, BRW <X>		BBCC .+06, JMP <X>
! E5	BBCC <X>	BBSC .+03, BRW <X>		BBSC .+06, JMP <X>
! E8	BLBS <X>	BLBC .+03, BRW <X>		BLBC .+06, JMP <X>
! E9	BLBC <X>	BLBS .+03, BRW <X>		BLBS .+06, JMP <X>
!
! E6	BBSSI <X>	BBSSI .+02, BRB .+03, BRW <X>	BBSSI .+02, BRB .+06, JMP <X>
! E7	BBCCI <X>	BBCCI .+02, BRB .+03, BRW <X>	BBCCI .+02, BRB .+06, JMP <X>
! F2	AOBLSS <X>	AOBLSS .+02, BRB .+03, BRW <X>	AOBLSS .+02, BRB .+06, JMP <X>
! F3	AOBLEQ <X>	AOBLEQ .+02, BRB .+03, BRW <X>	AOBLEQ .+02, BRB .+06, JMP <X>
! F4	SOBGEQ <X>	SOBGEQ .+02, BRB .+03, BRW <X>	SOBGEQ .+02, BRB .+06, JMP <X>
! F5	SOBGTR <X>	SOBGTR .+02, BRB .+03, BRW <X>	SOBGTR .+02, BRB .+06, JMP <X>
!
! 9D	ACBB <X>	ACBB .+02, BRB .+06, JMP <X>
! 3D	ACBW <X>	ACBW .+02, BRB .+06, JMP <X>
! F1	ACBL <X>	ACBL .+02, BRB .+06, JMP <X>
! 4F	ACBF <X>	ACBF .+02, BRB .+06, JMP <X>
! 6F	ACBD <X>	ACBD .+02, BRB .+06, JMP <X>
! 4FFD	ACBG <X>	ACBG .+02, BRB .+06, JMP <X>
! 6FFD	ACBH <X>	ACBH .+02, BRB .+06, JMP <X>
!
! 11	BRB <X>		BRW <X>				JMP <X>
! 10	BSBB <X>	BSBW <X>			JSB <X>
!
! 31	BRW <X>		JMP <X>
! 30	BSBW <X>	JSB <X>
!
! In addition to the above instructions, there are also three case
! instructions.  None of these has a replacement.  (In fact, the encoder
! does not know how to insert a case instruction correctly; it will only
! insert the instruction parameters.  The branch displacements must be
! inserted as .WORD directives.)
!
! CALLING SEQUENCE:
!
!	PAT$SUBST_INS (OLD-ENCODED-INSTRUCTION-ADDRESS, PC-OF-INSTRUCTION)
!
! INPUTS:
!
!	OLD_INS_PTR - Address of counted instruction stream to be substituted
!	INS_PC - Unmapped address of where to put instruction
!
! IMPLICIT INPUTS:
!
!	PAT$GB_SUBST_IN - Buffer for substitution counted byte stream
!
! OUTPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	The substitution binary stream is written into INSTRUC_BUF
!	as a counted byte stream.
!
! ROUTINE VALUE:
!
!	FALSE if no substitution instructions were possible.
!	TRUE if substitution was successful.
!
! SIDE EFFECTS:
!
!	A substitution stream can now be written to memory, or an error
!	reported.  However, if an instruction had a label associated with it
!	any branches elsewhere in the code to it will no longer work!!!
!
!--

BEGIN

MAP
	OLD_INS_PTR : REF VECTOR[,BYTE];			! Old binary instruction stream

LITERAL
	MIN_WORD_DISP = -32768,					! Minimum displacement for BRW
	MAX_WORD_DISP = 32767,					! Maximum displacement for BRW
	BRB_OPCODE = %X'11',					! Opcode for BRB instruction
	BRW_OPCODE = %X'31',					! Opcode for BRW instruction
	JMP_OPCODE = %X'17',					! Opcode forJMP instruction
	BNEQ_OPCODE = %X'12',					! Opcode for BNEQ instruction
	BLEQ_OPCODE = %X'15',					! Opcode for BLEQ instruction
	BGEQ_OPCODE = %X'18',					! Opcode for BGEQ instruction
	BLSSU_OPCODE = %X'1F',					! Opcode for BLSSU instruction
	BBS_OPCODE = %X'E0',					! Opcode for BBS instruction
	BBCC_OPCODE = %X'E5',					! Opcode for BBCC instruction
	BLBS_OPCODE = %X'E8',					! Opcode for BLBS instruction
	BLBC_OPCODE = %X'E9',					! Opcode for BLBC instruction
	BBSSI_OPCODE = %X'E6',					! Opcode for BBSSI instruction
	BBCCI_OPCODE = %X'E7',					! Opcode for BBCCI instruction
	AOBLSS_OPCODE = %X'F2',					! Opcode for AOBLSS instruction
	SOBGTR_OPCODE = %X'F5',					! Opcode for SOBGTR instruction
	ACBB_OPCODE = %X'9D',					! Opcode for ACBB instruction
	ACBW_OPCODE = %X'3D',					! Opcode for ACBW instruction
	ACBL_OPCODE = %X'F1',					! Opcode for ACBL instruction
	ACBF_OPCODE = %X'4F',					! Opcode for ACBF instruction
	ACBD_OPCODE = %X'6F',					! Opcode for ACBD instruction
	ACBG_HICODE = %X'4F',					! High byte of Opcode for ACBG instruction
	ACBH_HICODE = %X'6F',					! High byte of Opcode for ACBH instruction
	CASEB_OPCODE = %X'8F',					! Opcode for CASEB instruction
	CASEW_OPCODE = %X'AF',					! Opcode for CASEW instruction
	CASEL_OPCODE = %X'CF',					! Opcode for CASEL instruction
	BSBW_OPCODE = %X'30',					! Opcode for BSBW instruction
	BSBB_OPCODE = %X'10',					! Opcode for BSBB instruction
	JSB_OPCODE = %X'16',					! Opcode for JSB instruction
	BRB_INS_SIZ = 2,					! Size of BRB instruction
	BRW_INS_SIZ = 3,					! Size of BRW instruction
	JMP_INS_SIZ = 6,					! Size of JMP instruction
	PC_DEFERRED = %X'EF',					! PC deferred instruction mode
	MAX_INST_LEN	= 80;					! Maximum number of binary bytes in an instruction

LOCAL
	BR_DISPLACEMENT : SIGNED LONG;				! Displacement for branch instruction

!++
! Handle the first group of substitutions.  These may be replaced with
! their complement and a BRW, i.e., opcodes BGTR through BLBC in the above
! table.  The complement instruction must be set to branch around the BRW
! instruction.  Therefore, the instruction stream changes from:
!		<BR INS> TO <X>
! TO:
!		<BR COM INS> TO .+03		BRW <X>
!--
IF (.OLD_INS_PTR[1] GEQU BNEQ_OPCODE AND .OLD_INS_PTR[1] LEQU BLEQ_OPCODE) OR
   (.OLD_INS_PTR[1] GEQU BGEQ_OPCODE AND .OLD_INS_PTR[1] LEQU BLSSU_OPCODE) OR
   (.OLD_INS_PTR[1] GEQU BBS_OPCODE  AND .OLD_INS_PTR[1] LEQU BBCC_OPCODE ) OR
   (.OLD_INS_PTR[1] GEQU BLBS_OPCODE AND .OLD_INS_PTR[1] LEQU BLBC_OPCODE )
THEN
	BEGIN
	!++
	! Build the binary instruction stream for the complement branch.
	! Then build the BRW instruction with the old branch's displacement.
	!--
	PAT$GB_SUBST_IN[0] = BRW_INS_SIZ + .OLD_INS_PTR[0];	! Set the entire stream length
	PAT$GB_SUBST_IN[1] = (IF .OLD_INS_PTR[1] THEN (.OLD_INS_PTR[1] - 1)
					 ELSE (.OLD_INS_PTR[1] + 1));	! Set complement opcode
	CH$MOVE(.OLD_INS_PTR[0]-2, CH$PTR(OLD_INS_PTR[2]), CH$PTR(PAT$GB_SUBST_IN[2])); ! Move in instruction parameters
	PAT$GB_SUBST_IN[.OLD_INS_PTR[0]] = BRW_INS_SIZ;		! Set complement branch around BRW instruction
	PAT$GB_SUBST_IN[.OLD_INS_PTR[0]+1] = BRW_OPCODE;	! Set BRW instruction opcode
	BR_DISPLACEMENT = .PAT$GL_BR_DISPL + .OLD_INS_PTR[0] - .PAT$GB_SUBST_IN[0]; ! Compute new PC-relative displacement
	IF (.BR_DISPLACEMENT LEQ MAX_WORD_DISP) AND
	   (.BR_DISPLACEMENT GEQ MIN_WORD_DISP)			! Does displacement fit
	THEN
		(PAT$GB_SUBST_IN[ .OLD_INS_PTR[0]+2 ])<0,16,1> = .BR_DISPLACEMENT	! Yes, move it into stream
	ELSE
		BEGIN
		!++
		! No, it did not fit.  Use a JMP instead of a BRW, which
		! is the second choice in the table.  The complement branch
		! displacement must be changed, too.
		!--
		PAT$GB_SUBST_IN[0] = .PAT$GB_SUBST_IN[0] + (JMP_INS_SIZ - BRW_INS_SIZ); ! Set new instruction stream length
		PAT$GB_SUBST_IN[ .OLD_INS_PTR[0] ] = JMP_INS_SIZ; ! Set complement branch around JMP instruction
		PAT$GB_SUBST_IN[ .OLD_INS_PTR[0]+1 ] = JMP_OPCODE; ! Set JMP opcode
		PAT$GB_SUBST_IN[ .OLD_INS_PTR[0]+2 ] = PC_DEFERRED; ! Set instruction mode
		(PAT$GB_SUBST_IN[ .OLD_INS_PTR[0]+3 ])<0,32,1> = .BR_DISPLACEMENT -
					 (JMP_INS_SIZ - BRW_INS_SIZ); ! Set new branch displacement

		END
	END
ELSE
!++
! The opcode was not one of the first group, therefore check to see if
! it was one of the second group.
!--
IF (.OLD_INS_PTR[1] EQLU BBSSI_OPCODE) OR
   (.OLD_INS_PTR[1] EQLU BBCCI_OPCODE) OR
   (.OLD_INS_PTR[1] GEQU AOBLSS_OPCODE AND .OLD_INS_PTR[1] LEQU SOBGTR_OPCODE)
THEN
	BEGIN
	!++
	! Handle the second group of substitutions.  THese may be replaced with
	! the instruction branch, a BRB instruction, and a BRW or JMP
	! instruction.  This group includes instructions BBSSI through ACBD in
	! the above table.  The instruction branch must be set to branch around
	! the BRB instruction.  The BRB instruction must be set to branch around
	! the BRW instruction.  Therefore, the instruction stream changes from:
	!	<BR INS> TO <X>
	! TO:
	!	<BR INS> TO .+02	BRB TO .+03	BRW <X>
	!--
	PAT$GB_SUBST_IN[0] = .OLD_INS_PTR[0] + BRB_INS_SIZ + BRW_INS_SIZ; ! Set the stream length
	CH$MOVE(.OLD_INS_PTR[0]-1, CH$PTR(OLD_INS_PTR[1]), CH$PTR(PAT$GB_SUBST_IN[1]));	! Copy old ins stream minus branch displ
	PAT$GB_SUBST_IN[ .OLD_INS_PTR[0] ] = BRB_INS_SIZ;	! Set displ to br around BRB ins
	PAT$GB_SUBST_IN[ .OLD_INS_PTR[0]+1 ] = BRB_OPCODE;	! Set BRB opcode
	PAT$GB_SUBST_IN[ .OLD_INS_PTR[0]+2 ] = BRW_INS_SIZ;	! Set BRB around BRW ins
	PAT$GB_SUBST_IN[ .OLD_INS_PTR[0]+3 ] = BRW_OPCODE;	! Set BRW opcode
	BR_DISPLACEMENT = .PAT$GL_BR_DISPL + .OLD_INS_PTR[0] - .PAT$GB_SUBST_IN[0]; ! Compute new PC-relative displacement
	IF (.BR_DISPLACEMENT LEQ MAX_WORD_DISP) AND
	   (.BR_DISPLACEMENT GEQ MIN_WORD_DISP)			! Does displacement fit?
	THEN
		(PAT$GB_SUBST_IN[ .PAT$GB_SUBST_IN[0]-1 ])<0,16,1> = .BR_DISPLACEMENT ! Yes, move in displacement
	ELSE
		BEGIN
		!++
		! No, displacement did not fit, therefore use the
		! second substitution choice.  This includes changing
		! the BRW to a JMP, and altering the branch around it.
		!--
		PAT$GB_SUBST_IN[0] = .PAT$GB_SUBST_IN[0] + (JMP_INS_SIZ - BRW_INS_SIZ); ! Set a new stream size
		PAT$GB_SUBST_IN[ .OLD_INS_PTR[0]+2 ] = JMP_INS_SIZ; ! Change BRB displacement around JMP
		PAT$GB_SUBST_IN[ .OLD_INS_PTR[0]+3 ] = JMP_OPCODE; ! Replace the BRW opcode
		PAT$GB_SUBST_IN[ .OLD_INS_PTR[0]+4 ] = PC_DEFERRED; ! Set the instruction mode
		(PAT$GB_SUBST_IN[ .PAT$GB_SUBST_IN[0] + A_BYTE - A_LONGWORD ])<0,32,1> =
			 .BR_DISPLACEMENT - (JMP_INS_SIZ - BRW_INS_SIZ); ! Adjust the displ
		END;
	END
ELSE
!++
! The opcode was not one of the second group, therefore check to see if it
! was one of the third group.
!--
IF (.OLD_INS_PTR[1] EQLU ACBB_OPCODE) OR
   (.OLD_INS_PTR[1] EQLU ACBW_OPCODE) OR
   (.OLD_INS_PTR[1] EQLU ACBL_OPCODE) OR
   (.OLD_INS_PTR[1] EQLU ACBF_OPCODE) OR
   (.OLD_INS_PTR[1] EQLU ACBD_OPCODE) OR
   (.OLD_INS_PTR[1] EQLU %X'FD' AND .OLD_INS_PTR[2] EQLU ACBG_HICODE) OR
   (.OLD_INS_PTR[1] EQLU %X'FD' AND .OLD_INS_PTR[2] EQLU ACBH_HICODE)
THEN
	BEGIN
	!++
	! Handle the third group of substitutions.  These may be replaced with
	! the instruction branch, a BRB instruction, and a JMP instruction.
	! This group includes instructions ACBB through ACBD in the above table.
	! The instruction branch must be set to branch around the BRB
	! instruction.  The BRB instruction must be set to branch around the
	! BRW instruction.  THerefore, the instruction stream changes from:

	! CHANGES FROM:
	!	<BR INS> TO <X>
	! TO:
	!	<BR INS> TO .+02	BRB TO .+06	JMP <X>
	!--
	PAT$GB_SUBST_IN[0] = .OLD_INS_PTR[0] + (JMP_INS_SIZ + BRB_INS_SIZ); ! Set the stream length
	CH$MOVE(.OLD_INS_PTR[0]-2, CH$PTR(OLD_INS_PTR[1]), CH$PTR(PAT$GB_SUBST_IN[1])); ! Copy old ins stream minus branch displ
	PAT$GB_SUBST_IN[.OLD_INS_PTR[0]-1] = BRB_INS_SIZ;	! Set displ to br around BRB ins
	PAT$GB_SUBST_IN[.OLD_INS_PTR[0]] = 0;			! Clear other byte of displ word
	PAT$GB_SUBST_IN[.OLD_INS_PTR[0]+1] = BRB_OPCODE;	! Set BRB opcode
	PAT$GB_SUBST_IN[.OLD_INS_PTR[0]+2] = JMP_INS_SIZ;	! Set BRB around JMP instruction
	PAT$GB_SUBST_IN[.OLD_INS_PTR[0]+3] = JMP_OPCODE;	! Set BRW opcode
	PAT$GB_SUBST_IN[.OLD_INS_PTR[0]+4] = PC_DEFERRED;	! Set instruction mode
	BR_DISPLACEMENT = .PAT$GL_BR_DISPL + .OLD_INS_PTR[0] - .PAT$GB_SUBST_IN[0]; ! Compute new PC-relative displacement
	(PAT$GB_SUBST_IN[ .PAT$GB_SUBST_IN[0] + A_BYTE - A_LONGWORD ])<0,32,1> = .BR_DISPLACEMENT; ! Adjust the displ
	END
ELSE
!++
! The opcode was not one of the third group, therefore check to see if it
! was one of the fourth group.
!--
IF (.OLD_INS_PTR[1] EQL BRB_OPCODE) OR (.OLD_INS_PTR[1] EQL BSBB_OPCODE)
THEN
	BEGIN
	!++
	! Handle the fourth group of substitutions.  THese may be replaced with
	! the next larger displacement branch instruction of the same type.
	! This group includes instrucitons BRB and BSBB.  These instructions
	! can be handled similarly because:
	! (1) They have the same binary format, and
	! (2) The difference in opcodes for this branch
	!      displacement and the next larger is the same.
	! Therefore, because of (1), the variables BRB_INS_SIZ and
	! BRW_INS_SIZ would be identical to BSBB_INS_SIZ and
	! BSBW_INS_SIZ.  Also, because of (2), (BRW_OPCODE - BRB_OPCODE)
	! is the same as (BSBW_OPCODE - BSBB_OPCODE).
	!--
	PAT$GB_SUBST_IN[0] = BRW_INS_SIZ;			! Set ins stream size
	PAT$GB_SUBST_IN[1] = .OLD_INS_PTR[1] + (BRW_OPCODE - BRB_OPCODE); ! Set new opcode
	BR_DISPLACEMENT = .PAT$GL_BR_DISPL + .OLD_INS_PTR[0] - .PAT$GB_SUBST_IN[0]; ! Compute new displ
	IF (.BR_DISPLACEMENT LEQ MAX_WORD_DISP) AND
	   (.BR_DISPLACEMENT GEQ MIN_WORD_DISP)			! Does displ fit?
	THEN
		(PAT$GB_SUBST_IN[2])<0,16,1> = .BR_DISPLACEMENT	! Yes, move displ into stream
	ELSE
		BEGIN
		!++
		! No, displacement did not fit.  A longword displacement must be
		! used.  Therefore, convert to a JSB or JMP instruction.
		!--
		PAT$GB_SUBST_IN[0] = JMP_INS_SIZ;		! Set new stream size
		PAT$GB_SUBST_IN[1] = .PAT$GB_SUBST_IN[1] + (JMP_OPCODE - BRW_OPCODE); ! Set new opcode
		PAT$GB_SUBST_IN[2] = PC_DEFERRED;		! Set instruction mode
		(PAT$GB_SUBST_IN[3])<0,32,1> = .BR_DISPLACEMENT -
			 (JMP_INS_SIZ - BRW_INS_SIZ);		! Compute new displacement
		END
	END
ELSE
!++
! The opcode was not one of the fourth group, therefore check to see if it
! was one of the fifth group.
!--
IF (.OLD_INS_PTR[1] EQL BRW_OPCODE) OR (.OLD_INS_PTR[1] EQL BSBW_OPCODE)
THEN
	BEGIN
	!++
	! Handle the fifth group of substitutions.  These may be replaced with
	! the next larger displacement branch instruction of the same type.
	! This group includes instructions BRW and BSBW.  These instructions
	! can be handled similarly because:
	! (1) They have the same binary format, and
	! (2) The difference in opcodes for this branch displacement
	!     and the next larger is the same.
	! Therefore, beacuse of (1), the variables JSB_INS_SIZ and JMP_INS_SIZ
	! would be identical.  Also, because of (2), (JMP_OPCODE - BRW_OPCODE)
	! is the same as (JSB_OPCODE - BSBW_OPCODE).
	!--
	PAT$GB_SUBST_IN[0] = JMP_INS_SIZ;			! Set ins stream size
	PAT$GB_SUBST_IN[1] = .OLD_INS_PTR[1] + (JMP_OPCODE - BRW_OPCODE); ! Set opcode
	PAT$GB_SUBST_IN[2] = PC_DEFERRED;			! Set ins mode
	BR_DISPLACEMENT = .PAT$GL_BR_DISPL + .OLD_INS_PTR[0] - .PAT$GB_SUBST_IN[0]; ! Get displacement
	(PAT$GB_SUBST_IN[3])<0,32,1> = .BR_DISPLACEMENT;	! Compute br displ
	END
ELSE
	RETURN (FALSE);

RETURN (TRUE);	
END;								! End of PAT$SUBST_INS

GLOBAL ROUTINE PAT$OUT_MEM_LOC (LOCATION, PREFIX_STG, ASM_DIR_TBL, CASE_TBL) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Outputs the value of a memory location to the output
!	device. If this routine is called as a result of an EXAMINE
!	command, the location itself is also displayed, followed by
!	a colon and a tab.
!
!	The appropriate mode settings are used to control the output
!	style.
!
! CALLING SEQUENCE:
!
!	PAT$OUT_MEM_LOC ()
!
! INPUTS:
!
!	LOCATION	- Unmapped location whose contents are to be displayed.
!	PREFIX_STG	- Prefix string to output before the location
!			  0 = NONE
!	ASM_DIR_TBL	- Address of assembler directive table descriptor
!	CASE_TBL	- TRUE => Print CASE dispatch tables
!
! IMPLICIT INPUTS:
!
!	PAT$GL_CONTEXT [EXAMINE_BIT]	- If this bit is set, the address of the
!					  value is also displayed.
!	PAT$GL_MOD_PTR			- Pointer to the current mode level
!
! OUTPUTS:
!
!	TRUE for success, FALSE for failure.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	TRUE or FALSE
!
! SIDE EFFECTS:
!
!	Data is output to the data device.  An error message is produced if the
!	memory location is not readable.
!
!--

BEGIN
LOCAL
	MAPPED_LOC : REF VECTOR[,BYTE],				! Mapped address of deposit location
	ISE_ADDR: REF VECTOR[,BYTE],				! ISE address for deposit location
	OUT_VALUES : VECTOR[ TTY_OUT_WIDTH, BYTE],
	OUTPUT_BUFFER : VECTOR[ TTY_OUT_WIDTH, BYTE];

!++
! Initialize buffer address and size.
!--
PAT$CP_OUT_STR = OUTPUT_BUFFER + 1;
PAT$GL_BUF_SIZ = 0;

!++
! First check if there is a prefix string to be output.
!--
IF (.PREFIX_STG NEQ 0)
THEN
	PAT$FAO_PUT(.PREFIX_STG);

!++
! Now if the examine bit is set then output a location which is mapped
! by PATCH.  If the examine bit is not set, then output an expression
! for the EVALUATE command.
!--
IF .PAT$GL_CONTEXT [EXAMINE_BIT]
THEN
	BEGIN
	!++
	! Print the address, making it come out as a longword regardless of
	! the current output mode length.
	!--
	PAT$MAP_ADDR(.LOCATION,MAPPED_LOC,ISE_ADDR);		! Compute mapped address
	PAT$OUT_SYM_VAL(.LOCATION, LONG_LENGTH, 0);
	PAT$GL_LAST_LOC = .LOCATION;
	PAT$GB_LOC_TYPE = MEMORY_LOC;
	PAT$FAO_PUT ( COLON_TAB_STG );

	!++
	! Handle output as symbolic instructions separately.
	!--
	IF( .PAT$GB_MOD_PTR[ MODE_INSTRUC ] )
	THEN
		IF ((LOCATION = PAT$INS_DECODE (.LOCATION, OUTPUT_BUFFER, LOCATION, .ASM_DIR_TBL, .CASE_TBL)) EQL 0)
		THEN
			BEGIN
			SIGNAL (PAT$_NODECODE);
			RETURN(FALSE);
			END
		ELSE
			BEGIN
			PAT$MAP_ADDR (.LOCATION, MAPPED_LOC, ISE_ADDR);
			IF .PAT$GL_CONTEXT [EXAMINE_BIT]
			THEN
				PAT$GL_NEXT_LOC = .LOCATION;

			!++
			! PAT$GL_LAST_VAL may be set within PAT$INS_DECODE.
			!--
			END
	ELSE	
		BEGIN
		!++
		! Special attention for ascii output.
		!--
		IF (.PAT$GB_MOD_PTR [MODE_ASCII])
		THEN
			!++
			! Simply output the number of characters
			! implied by the current MODE_LENGTH setting.
			!--
			BEGIN
			PAT$GET_VALUE (.LOCATION, .PAT$GB_MOD_PTR[MODE_LENGTH], OUT_VALUES);
			PAT$FAO_PUT (CS_ASCII, .PAT$GB_MOD_PTR[MODE_LENGTH], OUT_VALUES);
			PAT$GL_NEXT_LOC = .LOCATION + .PAT$GB_MOD_PTR [MODE_LENGTH];
			PAT$GL_LAST_VAL = .(.MAPPED_LOC) <0, .PAT$GB_MOD_PTR [MODE_LENGTH] * 8>;
			END
		ELSE						! Otherwise we have one of the usual modes
			IF .PAT$GL_CONTEXT [EXAMINE_BIT]
			THEN
				BEGIN
				PAT$GET_VALUE(.LOCATION, .PAT$GB_MOD_PTR[MODE_LENGTH], OUT_VALUES);
				PAT$OUT_NUM_VAL(.OUT_VALUES, 0, 0, TRUE);
				PAT$GL_NEXT_LOC = .LOCATION + .PAT$GB_MOD_PTR [MODE_LENGTH];
				PAT$GL_LAST_VAL = .OUT_VALUES <0, .PAT$GB_MOD_PTR [MODE_LENGTH] * 8>;
				END;
		END
	END
ELSE
	BEGIN
	!++
	! Output the value for the EVALUATE command here then return.
	! All other commands have set the examine bit.  Check for different
	! output modes, literal or instruction.
	!--
	IF (.PAT$GL_CONTEXT[LITERAL_BIT])
	THEN
		BEGIN
		!++
		! Call a routine which does the whole thing - including
		! flushing the output and producing an error message if no
		! such literal translation can be found.
		!--
		DISPLAY_LVTS(..LOCATION);

		!++
		! If the above routine returns then at least one literal
		! translation was found.  This form of evaluate sets the
		! psuedo '\' (last value displayed) only.
		!--
		PAT$GL_LAST_VAL = ..LOCATION;
		RETURN(TRUE);
		END;

	!++
	! Instruction mode works only if /LITERAL was not specified.
	!--
	IF (.PAT$GB_MOD_PTR[MODE_INSTRUC])
	THEN
		BEGIN
		LOCAL
			COUNT,
			ENCODED_BUF : VECTOR[38,BYTE];
		IF (NOT PAT$INS_ENCODE(..LOCATION, ENCODED_BUF, 0))
		THEN
			SIGNAL(PAT$_NOENCODE, 1, ..LOCATION);
		COUNT = .ENCODED_BUF[0];
		DO
			BEGIN
			PAT$OUT_NUM_VAL(.ENCODED_BUF[.COUNT], BYTE_LENGTH, HEX_RADIX, FALSE);
			COUNT = .COUNT - 1;
			END
		UNTIL .COUNT EQL 0;
		END
	ELSE
		BEGIN
		PAT$OUT_NUM_VAL(..LOCATION, 0, 0, TRUE);
		PAT$GL_LAST_VAL = .(LOCATION) <0, .PAT$GB_MOD_PTR [MODE_LENGTH] * 8>;
		END;
	END;

!++
! Write out the string and return.
!--
PAT$OUT_PUT( OUTPUT_BUFFER );

RETURN TRUE
END;

ROUTINE DISPLAY_LVTS (VALUE) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Given a value, display the pathnames of all literals in the LVT which
!	have this value.
!
! CALLING SEQUENCE:
!
!	CALLS #1, DISPLAY_LVTS
!
! INPUTS:
!
!	VALUE - Literal value to be translated to symbols
!
! IMPLICIT INPUTS:
!
!	The initial set up for standard PATCH I/O has already been done.
!	This routine (re)uses this buffer for its output.
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	All the literal symbols associated with the value are printed.
!
! ROUTINE VALUE:
!
!	novalue
!
! SIDE EFFECTS:
!
!	Either output is sent to SYS$OUTPUT or a SIGNAL is generated and
!	no return is done.
!
!--

BEGIN

LOCAL
	OUTPUT_BUFFER : REF VECTOR[,BYTE],			! Output buffer for SYS$OUTPUT writes
	LVT_PTR : REF LVT_RECORD,				! Pointer to LVT match
	ONE_FOUND;						! Indicator if at least one symbol was found

!++
! Initialize a flag which is used to know whether or not at least one match
! to the given value has been found.  Also save a pointer to current output
! buffer so that it can be reused.
!--
ONE_FOUND = FALSE;
OUTPUT_BUFFER = .PAT$CP_OUT_STR;

!++
! Access to the LVT is via a 'canned' function.  Before using it, this routine
! must signal its intention to do so.
!--
PAT$GET_NXT_LVT(SL_ACCE_INIT);

!++
! Loop through the LVT sequentially, asking to see all currently valid records.
!--
WHILE ((LVT_PTR = PAT$GET_NXT_LVT(SL_ACCE_RECS)) NEQA 0)
	DO
	BEGIN
	IF (.LVT_PTR[LVT_VALUE] EQL .VALUE)
	THEN
		BEGIN
		LOCAL
			NT_PTR : REF NT_RECORD,
			PATH_VEC : PATHNAME_VECTOR;

		!++
		! Found a match.  Print out the corresponding pathname by
		! first building a pathname vector based on the returned NT_PTR.
		!--
		ONE_FOUND = TRUE;
		NT_PTR = .LVT_PTR[LVT_NT_PTR];
		PAT$ADD_NT_T_PV(.NT_PTR, PATH_VEC);
		PAT$PRINT_PATH(PATH_VEC);

		!++
		! Write out the string and reset the global buffer pointers.
		!--
		PAT$OUT_PUT(.OUTPUT_BUFFER-1);
		PAT$CP_OUT_STR = .OUTPUT_BUFFER;
		PAT$GL_BUF_SIZ = 0;
		END;
	END;							! Loop back to consider the next LVT record

!++
! At this point, the LVT has been completely searched.  If no matches were
! found, then signal a warning.
!--
IF (NOT .ONE_FOUND)
THEN
	SIGNAL(PAT$_NOLITERAL+MSG$K_WARN, 1, .VALUE);
RETURN;
END;								! End of DISPLAY_LVTS

GLOBAL ROUTINE PAT$REG_MATCH (STRING_DESC) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Compares a string described by the string descriptor passed as the
!	routine formal to each of the names of the machine registers.  If the
!	string matches a register name, return the number of the register (0-16,
!	where 16 is the PSL).  Otherwise return a -1.
!
! CALLING SEQUENCE:
!
!	CALLS #1, PAT$REG_MATCH
!
! INPUTS:
!
!	STRING_DESC - String descriptor to symbol string
!
! IMPLICIT INPUTS:
!
!	The VAX machine register table.
!
! OUTPUTS:
!
!	The number of the register whose name matched the string.
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	0-16 for the corresponding register
!	-1 for no match
!
! SIDE EFFECTS:
!
!	none
!
!--

BEGIN

MAP
	STRING_DESC : REF BLOCK [, BYTE];

LOCAL
	INDEX;

INDEX = 0;
REPEAT
	BEGIN
	IF CH$EQL (.STRING_DESC [DSC$W_LENGTH], CH$PTR (.STRING_DESC [DSC$A_POINTER]),
			.REGISTER_TABLE [.INDEX, REG_CH_CNT],
			CH$PTR (REGISTER_TABLE [.INDEX, REG_NAME]))
	THEN RETURN .INDEX
	ELSE
		BEGIN
		INDEX = .INDEX + 1;
		IF .INDEX GTR REGISTER_COUNT - 1
		THEN RETURN -1
		END;
	END;
END;

GLOBAL ROUTINE PAT$FILL_BUF(BUF_DESC, DATA_PTR, DATA_SIZ) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Takes the data defined as the input arguments and puts them in the
!	temporary deposit buffer.  This is accomplished by allocating a new
!	larger buffer, copying in the old buffer, and then deallocating it.
!	Then the buffer descriptor is updated.
!
! CALLING SEQUENCE:
!
!	CALLS #2, PAT$FILL_BUF
!
! INPUTS:
!
!	BUF_DESC - Buffer descriptor
!	DATA_PTR - Address of the data to be put in the buffer
!	DATA_SIZ - Number of bytes of data to be put in the buffer
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	The buffer descriptor is updated.
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	The data is written into the buffer.
!
!--

BEGIN

MAP
	BUF_DESC : REF BLOCK[,BYTE];				! Buffer descriptor

LOCAL
	TEMP_PTR;						! Pointer to new buffer

TEMP_PTR = PAT$FREEZ((.BUF_DESC[DSC$W_LENGTH] + .DATA_SIZ + A_LONGWORD -1)/A_LONGWORD); ! Allocate larger buffer
IF .BUF_DESC[DSC$W_LENGTH] NEQ 0
THEN
	BEGIN
	CH$MOVE(.BUF_DESC[DSC$W_LENGTH], .BUF_DESC[DSC$A_POINTER], .TEMP_PTR); ! Move in previous data
	PAT$FREERELEASE(.BUF_DESC[DSC$A_POINTER], (.BUF_DESC[DSC$W_LENGTH] +3)/4); ! Release old buffer
	END;
CH$MOVE(.DATA_SIZ, .DATA_PTR, CH$PTR(.TEMP_PTR, .BUF_DESC[DSC$W_LENGTH])); ! Move in new data
BUF_DESC[DSC$A_POINTER] = CH$PTR(.TEMP_PTR);			! Reset buffer dsc addr
BUF_DESC[DSC$W_LENGTH] = .BUF_DESC[DSC$W_LENGTH] + .DATA_SIZ;	! Reset buf dsc siz
END;

END
ELUDOM
