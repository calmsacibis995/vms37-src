MODULE PATINT (							! RST interface routines for PATCH
		%IF %VARIANT EQL 1
		%THEN
			ADDRESSING_MODE (EXTERNAL = LONG_RELATIVE, NONEXTERNAL = LONG_RELATIVE),
		%FI
		IDENT = 'V03-000'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	PATCH
!
! ABSTRACT:	This is  the RST/DST/PATCH interface module.
!		 This module exists because the DST/RST
!		 module simply declares how it wants to see
!		 the world, and leaves it up to this module
!		 to interface to PATCH to make things look
!		 that way.
!
!	This module defines the interface between the
!	PATCH RST builder/manipulator and the LINKER-produced
!	DST.  The former would like to show as little
!	concern for where DST records are actually stored as
!	possible.  The latter would like to provide this facility,
!	but it must do so simply, (because we don't want to
!	re-invent the world), efficiently, and in such
!	as way as to allow us to do radically different
!	things about where the DST actually exists.
!
!	Essentially what we do to solve this is to restrict the
!	DST user to requesting records before he uses them,
!	(probably) saying something about how long he wants
!	to use them (or, equivalently, when he is willing to give
!	them up), and using them given that they exist at the
!	address he is told they are currently at.  This means that
!	he can never make any assumptions about where a record is at.
!	To get around this we introduce the concept of "Record Ids",
!	which are simply identifiers by which the two sides of the
!	interface agree to call records.  The first time you
!	get a record, the interface tells you how you must
!	henceforth refer to it.
!
!	The other aspect of the interface concerns so-called
!	RST-pointers.  These pointers are used throught the
!	RST module to access various (all) records.  The code
!	uses these pointers implicitly, knowing nothing
!	about what they actually are, and leaves it up to this
!	interface to define them.  This is done by
!	having a special storage allocator for the RST
!	module.  It uses whatever kind of pointer this
!	allocator returns, and leaves it up to
!	the definition of the RST structures (RST_NT,
!	RST_MC, etc.  see PATRST.REQ) to make
!	sure that these RST-pointers do the job.
!
! Version:	V02-017
!
! ENVIRONMENT:	This module runs on VAX under STARLET, user mode, non-AST level.
!
! AUTHOR:	Kevin Pammett, CREATION DATE: 12 JULY 77
!
! MODIFIED BY:
!
!	V02-017	MTR0002		Mike Rhodes		30-Nov-1981
!		Modify routine PAT$GET_NXT_GST to skip global symbol
!		definitions for PSECT definition in shareable images.
!
!	V02-016	MTR0001		Mike Rhodes		14-Oct-1981
!		Modify routine PAT$FIND_DST to allow the create and map
!		section system service to do expand region calls, instead
!		of trying to remember the last mapped address in P0 space.
!		The last mapped address array is updated within the calls.
!
!	V02-015	PCG0001		Peter George		02-FEB-1981
!		Add require statement for LIB$:PATDEF.REQ
!
!  NO	DATE		PROGRAMMER		PURPOSE
!  --	----		----------		-------
!
!  00	13-DEC-77	K.D. MORSE		ADAPT VERSION 19 FOR PATCH.
!  01	2-JAN-78	K.D. MORSE		ALLOW NO GST IN IMAGE.
!  02	23-JAN-78	K.D. MORSE		ADD CODE FOR MORE SPECIFIC
!						ERROR MESSAGES. (20)
!  03	28-FEB-78	K.D. MORSE		SAVE_SCOPE NOW DOES A SET
!						MODULE ON THE SCOPE'S MODULE.
!  04	06-APR-78	K.D. MORSE		PAT$FIND_DST now maps the GST
!						instead of reading it.(22)  Added
!  						routine POSITION_GST to chain
!						through the mapped GST.  Also 
!						the logic in DBG$GET_NXT_GST
!						now calls POSITION_GST. (23)
!						Bug fix in FIND_DST to skip the
!						first 2 GST records OK. (24)  
!						Bug fix in POSITION_GST - round
!						up a record byte count. (24)
!						GSR_NEXT_ADDR is now a REF VECTOR[,byte]. (24)
!						Added code to BUILD_PATH to check
!						for DEFine symbols before
!						consulting the RST.  BUILD_PATH
!						has the final word on whether
!						a symbol has a value or not. (25)
!						None for vers 26.
!  05	25-APR-78	K.D. MORSE		CONVERT TO NATIVE COMPILER.
!  06	17-MAY-78	K.D. MORSE		ERROR MESSGES FROM GST/DST INIT.
!						ARE NOW INFOR SEVERITY. (27)
!						POSITION_GST CHECKS FOR NO GST (27).
!						NO CHANGES FOR VERS 28.
!						DELETE_PATH IS GLOBAL AND HAS NO
!						FORMAL INPUT AND ALWAYS ZEROS
!						THE PATH_VEC_PTR. (29)
!						BETTER ERROR MSG IN SAVE_SCOPE (30).
!  07	18-MAY-78	K.D. MORSE		CANCEL THE SCOPE IF THE MODULE
!						IT POINTS TO IS CANCELLED. (31)
!						POSITION_GST NOW SEES GST AS 3
!						RECORDS LESS THAN HEADER SAYS
!						NOT 2. (32)
!						NOTE THE "ROUND UP" IN GET_NXT_GST
!						TO RECOGNIZE END OF GST RECORD. (32)
!						NO CHANGES FOR VERS 33.
!  08	24-MAY-78	K.D. MORSE		ADD GSD TYPE 3 - PROCEDURE
!						DEFINITION WITH FORMAL ARGUMENT
!						DESCRIPTIONS.
!  09	25-MAY-78	K.D. MORSE		ADD SIGNAL_FLAG PARAMETER TO
!						PAT$BUILD_PATH FOR FORWARD
!						REFERENCED SYMBOLS.
!  10	13-JUN-78	K.D. MORSE		ADD FAO COUNT TO SIGNALS.
!  11	20-JUN-78	K.D. MORSE		NO CHANGES FOR VERS 34-36.
!  12	28-JUN-78	K.D. MORSE		NO CHANGES FOR 37-38.
!						PAT$FIND_MODULE HAS NEW ARG
!						INDICATING WHETHER OR NOT TO
!						SIGNAL IF MODULE IS NOT FOUND (39).
!  13	29-JUN-78	K.D. MORSE		NO CHANGES FOR VERS 40.
!  14	07-JUL-78	K.D. MORSE		NO CHANGES FOR VERS 41.
!
!--

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
	PAT$SAVE_SCOPE,						! Store away the current scope position
								! (CSP) vector.
	PAT$BUILD_PATH,						! Collect symbol pathnames and eventually
								!  try to evaluate them.
	PAT$DELETE_PATH : NOVALUE,				! Throw away a pathvector.
	PAT$FIND_MODULE,					! Scan MC for a given module name.
	PAT$RST_FREEZ,						! Storage allocator for anything which
								!  which is accessed via RST-pointers.
	PAT$RST_RELEASE : NOVALUE,				! Storage deallocator for anything which
								!  which is allocated by PAT$RST_FREEZ.
	PAT$FIND_DST : NOVALUE,					! Find the DST and make it available.
	PAT$GET_DST_REC,					! Make a certain DST record available.
	PAT$POSITON_DST,					! Make a certain DST record available
								! and set up for PAT$GET_NXT_DST
	POSITION_GST,						! Make a certain GST record available
	PAT$GET_NXT_DST,					! Make the next DST record available.
	PAT$GET_NXT_GST;					! Make the next GST record available


!
! INCLUDE FILES:
!

LIBRARY 'SYS$LIBRARY:LIB.L32';
REQUIRE 'SRC$:PATPCT.REQ';
REQUIRE 'LIB$:PATDEF.REQ';				! Defines literals
REQUIRE 'LIB$:PATMSG.REQ';
REQUIRE 'SRC$:IMGDEF.REQ';
REQUIRE 'SRC$:PATGEN.REQ';
REQUIRE 'SRC$:BSTRUC.REQ';
REQUIRE 'SRC$:LISTEL.REQ';
REQUIRE 'SRC$:DLLNAM.REQ';
REQUIRE 'SRC$:PATRST.REQ';
REQUIRE 'SRC$:VXSMAC.REQ';
REQUIRE 'SRC$:SYSSER.REQ';
REQUIRE 'SRC$:SYSLIT.REQ';
REQUIRE 'SRC$:PREFIX.REQ';
REQUIRE 'SRC$:PATPRE.REQ';

!
! MACROS:
!

!
! EQUATED SYMBOLS:
!

!
! OWN STORAGE:
!

OWN
	PATH_VEC_PTR : REF PATHNAME_VECTOR INITIAL( 0 ),	! Pointer to the pathname vector we are 
								! currently building.  If 0, no such vector
								! is under construction.
	DST_BEGIN_ADDR,						! virtual address where DST begins.
								! 0 => no DST.  Initially we do not
								! want to assume this.
	DST_END_ADDR,						! Virtual address of last byte in DST.
	DST_NEXT_ADDR,						! Virtual address where 'next' DST record begins.

	!++
	! Now GST symbols corresponding to the above DST symbols.
	!--
	GSR_BEGIN_ADDR,						! Virtual address where GST begins (0=no GST)
	GSR_NEXT_ADDR : REF VECTOR[,WORD],			! Virtual address where 'next' GST record begins
	GST_BEGIN_ADDR : REF GST_RECORD,			! Virtual address of current GST record (used only by GET_NXT_GSD)
	GSD_REC_COUNT;						! Count-down of GSD records.

!
! EXTERNAL REFERENCES:
!
EXTERNAL ROUTINE
	PAT$PV_TO_CS,						! Encode pathname vectors for printing.
	PAT$FIND_SYM,						! Lookup DEFine symbols
	PAT$SET_MODULE : NOVALUE,				! Adds module to the RST
	PAT$SYM_TO_VAL,						! Correspong pathnames and values.
	PAT$SYM_TO_VALU,					! Sym_to_val + goodies.
	PAT$INIT_RST : NOVALUE,					! Build all RST data structures.
	PAT$FREEZ,						! Standard PATCH storage allocator.
	PAT$FREERELEASE : NOVALUE,				! Standard PATCH storage deallocator.
	LIB$_CREMAPSEC;						! Creates and maps a global section

EXTERNAL
	PAT$GB_SYMBOLS,						! Indicator if image contains symbols
	PAT$GL_IMGHDR : REF BLOCK[,BYTE],			! Pointer to image header
	PAT$GL_OLDNBK : BLOCK[,BYTE],				! Name block for input image file
	PAT$GB_OLDNAME,						! Ascii name of input image file
	PAT$GL_OLDRAB : BLOCK[,BYTE],				! Rab for input image file
	PAT$GL_ISVADDR : VECTOR[,LONG],				! Last pair of virtual addresses used
	PAT$GL_CSP_PTR : REF PATHNAME_VECTOR,			! The Current Scope Position (CSP)
								! is defined by a pointer to the
								! pathname vector which is the CSP.
	PAT$GL_MC_PTR : REF MC_RECORD,				! The module chain
	PAT$GL_RST_BEGN,					! Address of start of RST
	PAT$GL_HEAD_LST,					! Head of PATCH argument list
	PAT$GL_SYMTBPTR,					! Pointer to current symbol table
	PAT$GL_SYMHEAD;						! Pointer to user-defined symbol table listhead

GLOBAL ROUTINE PAT$BUILD_PATH( SYMBOL_DESC, PASS_BACK_VALUE, SIGNAL_FLAG ) =

!++
! Functional Description:
!
!    This routine serves two fairly distinct purposes.
!
! 1. If SYMBOL_DESC is a valid string descriptor, (ie not = 0),
!    then the call was made to BUILD_PATH so that it could
!    accumulate the elements of a pathname in order to
!    build up a pathname vector.
!
! 2. Otherwise, the 0 SYMBOL_DESC is a flag which signals that
!    no more elements are to come and what we have accumulated
!    is supposedly a complete pathname.  What we are to do then
!    is to simply look up this pathname in the RST data base and
!    return the corresponding value via the PASS_BACK_VALUE pointer.
!
!	When a lookup is done, the following priority is observed:
!
!	1) a pathname consisting of 1 element may first be:
!		1) a permanent symbol name (e.g. "R0")
!		2) a DEFine symbol
!	2) if 1), above, is not the case, or if the pathname
!	   is longer than 1 element, then the symbol must
!	   be found in the RST or an error occurs.
!
! Calling Sequence:
!
!	PAT$BUILD_PATH ( SYMBOL_DESC, PASS_BACK_VALUE, SIGNAL_FLAG)
!
! Inputs:
!
!	SYMBOL_DESC	- String descriptor for next peice of pathname or
!			  zero indicating accumulated pathname is to be
!			  evaluated.
!	PASS_BACK_VALUE	- Address of where to return the symbol's value
!	SIGNAL_FLAG	- Flag indicating whether to signal error message
!			  if symbol is undefined. (TRUE=yes, FALSE=no)
!
! Implicit Inputs:
!
!	This routine works from the OWN that is local to this
!	module, PATH_VEC_PTR, which points to the current pathname vector
!	we are building.  The reason why this is not local to BUILD_PATH
!	is so that it can be shared by SAVE_SCOPE.
!
! Return Value:
!
!	On pathname accumulation, we return TRUE unless some error
!	like PATCH running out of free storage occurs; then an error is SIGNALed.
!
!	On symbol evaluation, we return TRUE if the symbol was found
!	in the image symbol tables and PAT$K_USER_DEF if the symbol was found
!	in the user-defined symbol table.  If the symbol is undefined,
!	then depending upon SIGNAL_FLAG either an error message is SIGNALed
!	and an UNWIND is done, or PAT$BUILD_PATH returns FALSE.  This is to
!	handle forward references inside symbolic instructions.
!--

BEGIN

MAP
	SYMBOL_DESC : REF BLOCK[,BYTE],				! This describes the element of the
								! pathname which we are to add on
								! to our list.
	PASS_BACK_VALUE : REF VECTOR[,LONG];			! This is where we are to pass back
								! the pathname value to.

OWN
	PV_INDEX;						! We use an OWN index into the OWN
								! pathname vector so that on each call
								! we know where we're at.

LOCAL
	CS_PTR : CS_POINTER,					! Temp counted string pointer.
	STATUS;							! Success/failure indication that we return.

!++
! Now see whether a pathname translation to symbolic value
! is to occur. This is signaled by the flag SYMBOL_DESC being
! equal to 0.
!--
IF (.SYMBOL_DESC EQL 0)
THEN
	BEGIN
	!++
	! Evaluate the symbol.  First, for single-element pathnames we give
	! priority to the so-called PATCH permanent symbols, and to the symbols
	! DEFined by the user at PATCH-time.  No longer pathname could be such
	! a thing.
	!-- 
	STATUS = 0;
	IF (.PATH_VEC_PTR[1] EQL 0)
	THEN
		BEGIN
		LOCAL
			TEMP_SYM_TBL,
			DEF_SYM_DESC : BLOCK[8,BYTE];

		!++
		! A 1-element pathname may be or a DEFine symbol.  First build
		! a string descriptor for the name (since this is what
		! PAT$FIND_SYM wants).
		!--
		CS_PTR = .PATH_VEC_PTR[0];
		DEF_SYM_DESC[DSC$W_LENGTH] = .CS_PTR[0];
		DEF_SYM_DESC[DSC$A_POINTER] = CS_PTR[1];

		!++
		! The symbol is not a permanent one.  Now lookup it up in the
		! linked list reserved for DEFine symbols.
		!--	
		TEMP_SYM_TBL = .PAT$GL_SYMTBPTR;		! Remember curren symbol table
		PAT$GL_SYMTBPTR = .PAT$GL_SYMHEAD;		! Use user-defined symbol table
		STATUS = PAT$FIND_SYM(DEF_SYM_DESC);
		PAT$GL_SYMTBPTR = .TEMP_SYM_TBL;		! Restore current symbol table

		!++
		! If we found something, pass back the associated value
		! and set STATUS to the appropriate success code.
		!--	
		IF (.STATUS NEQ 0)
		THEN
			BEGIN
			PASS_BACK_VALUE[0] = .SYM_VALUE(.STATUS);
			STATUS = PAT$K_USER_DEF;
			END;
		END;

	!++
	! Now, if we didn't get something from the DEFine
	! or permanent symbol data bases, try the RST.
	!--
	IF (NOT .STATUS)
	THEN
		STATUS = PAT$SYM_TO_VAL( .PATH_VEC_PTR, .PASS_BACK_VALUE);
		
	!++
	! If no translation can be found, Check whether to SIGNAL an error
	! and cause an UNWIND or return FALSE.
	!--	
	IF (NOT .STATUS)
	THEN
		BEGIN
		LOCAL MESSAGE_BUF : VECTOR[TTY_OUT_WIDTH,BYTE];

		!++
		! Encode the pathname into a counted
		! string, and output the associated message.
		!--
		PAT$PV_TO_CS( .PATH_VEC_PTR, MESSAGE_BUF );
		PAT$DELETE_PATH();
		PATH_VEC_PTR = 0;

		!++
		! Check if this might be a forward reference and therefore
		! should not be signaled as an error.
		!--
		IF (NOT .SIGNAL_FLAG)
		THEN
			RETURN(FALSE)
		ELSE
			SIGNAL(PAT$_NOSYMBOL, 1, MESSAGE_BUF ); ! no return
		END;

	!++
	! If the evaluation succeeded, discard the pathname vector and 
	! return success.
	!--
	PAT$DELETE_PATH();
	RETURN(.STATUS);
	END;

!++
! A real string descriptor is supposed to pass on to us another pathname
! element to accumulate.
!
! If this is the first call for a new pathname, we must allocate the storage
! we will need for the vector of pointers to the element strings.
!--
IF (.PATH_VEC_PTR EQL 0)
THEN
	BEGIN
	IF ((PATH_VEC_PTR = PAT$freez(RST_UNITS(%SIZE(PATHNAME_VECTOR)))) EQL 0)
	THEN
		SIGNAL(PAT$_NOFREE);				! No more storage.

	!++
	! The storage manager zeros out the pathname vector for us, so we only
	! have to set up the right pathname vector index.
	!--
	PV_INDEX = 0;
	END;

!++
! Now we need space for the element name itself, (including the count! ).
!--
IF ((CS_PTR = PAT$freez(RST_UNITS(.SYMBOL_DESC[DSC$W_LENGTH]+1))) EQL 0)
THEN
	SIGNAL(PAT$_NOFREE);					! No more storage.

!++
! Copy the string into the allocated storage. Note that we must make up a counted
! string because this is what pathname vector pointers are defined to point to.
!--
CS_PTR[0] = .SYMBOL_DESC[DSC$W_LENGTH];
CH$MOVE( .SYMBOL_DESC[DSC$W_LENGTH], .SYMBOL_DESC[DSC$A_POINTER], CS_PTR[1] );

!++
! Now store the address of this counted string in  the 'next' slot in the
! pathname vector.
!--
PATH_VEC_PTR[.PV_INDEX] = .CS_PTR;

!++
! And set up so that the next call to this routine stores the CS pointer into the
! next slot.
!--
IF ((PV_INDEX = .PV_INDEX +1) GTR MAX_PATH_SIZE)
THEN
	BEGIN
	SIGNAL (PAT$_PATHTLONG);
	RETURN(FALSE);
	END;
RETURN(TRUE);
END;

GLOBAL ROUTINE PAT$DELETE_PATH : NOVALUE =

!++
! Functional Description:
!
!	Delete the pathname vector we are passed a pointer to by the OWN,
!	PATH_VEC_PTR, which several routines in this module work from.  Also,
!	zero out this pointer so that the next call to BUILD_PATH knows
!	there is no 'current' pathname vector being built.
!
! Formal Parameters:
!
!	none
!
! Implicit Inputs:
!
!	PATH_VEC_PTR - See above.
!
! Return Value:
!
!	NOVALUE - because the only thing which can go wrong
!		  is a free storage error and in that
!		  case the manager itself SIGNALs its way out.
!
!--

BEGIN

LOCAL
	CS_PTR : CS_POINTER;					! Each element of the pathname vector
								! is a pointer to a counted string.

!++
! Now see if there is really a pathname vector currently pointed to by the
! pointer, PATH_VEC_PTR.
!--
IF (.PATH_VEC_PTR EQLA 0)
THEN
	RETURN;

!++
! Simply throw away the storage which we allocated
! for each element of the vector.
!-
INCR I FROM 0 TO MAX_PATH_SIZE
DO
	!++
	! The first 0 entry ends the vector.
	!--
	IF ((CS_PTR = .PATH_VEC_PTR[.I]) EQL 0)
	THEN
		EXITLOOP
	ELSE
		PAT$FREERELEASE( .CS_PTR, RST_UNITS(.CS_PTR[0]+1) );

!++
! Then throw away the vector itself.
!--
PAT$FREERELEASE( .PATH_VEC_PTR, RST_UNITS( %SIZE(PATHNAME_VECTOR) ));

!++
! Zero out the pointer so that subsequent re-uses know there is no longer
! one there.
!--
PATH_VEC_PTR = 0;

END;

GLOBAL ROUTINE PAT$SAVE_SCOPE( SET_SCOPE_FLAG ) =

!++
! Functional Description:
!
!    This routine serves two fairly distinct purposes.
!
! 1. IF SET_SCOPE_FLAG is ON, then this routine was
!    called to SET the new current scope position (CSP).
!    In this case we delete the storage taken by the old
!    CSP, if there was any, and install the new CSP
!    having checked its validity.
!	SET SCOPE also implies SET MODULE.
!
! 2. If SET_SCOPE_FLAG is OFF, then the call was made to simply
!    install a null CSP vector.  This happens as a result of the user
!    cancelling scope, or cancelling a module whose name is the same as what the
!    CSP pathname begins with.  The latter avoids the 'dangling scope' problem.
!
! Implicit Inputs:
!
!	This routine works from the OWN that is local to this
!	module, PATH_VEC_PTR, which points to the current pathname vector
!	which was (presumably) built by BUILD_PATH.  We store
!	away this pathname vector pointer, and then zero out the
!	one that BUILD_PATH uses so that it 'forgets' completely
!	about having built it.
!
! Return Value:
!
! TRUE, if we are simply throwing away the old CSP,
!       or if we installed a new one which was acceptable,
! FALSE, otherwise.  (we were asked to install one which was invalid).
!
!--

BEGIN

LOCAL
	NEW_CSP_PTR : REF PATHNAME_VECTOR,
	MC_PTR : REF MC_RECORD,					! Used to chain along the MC.
	CS_PTR : CS_POINTER,					! Temp counted string pointer.
	STATUS;							! Success/failure indication that we return.

!++
! The gross structure of this routine just implements the two-function logic.
!--
IF (.SET_SCOPE_FLAG)
THEN
	BEGIN
	!++
	! Install a new CSP vector. Check that the CSP we were given is valid.
	! First, see if the beginning element of the pathvector (which must be
	! MODULE) is in the MC.  Note that we don't consider the first entry in
	! the MC since it is used for globals only and hence is nameless.
	!--
	CS_PTR = .PATH_VEC_PTR[0];
	MC_PTR = .PAT$GL_MC_PTR;
	WHILE ((MC_PTR = .MC_PTR [MC_NEXT]) NEQ 0)
	DO
		BEGIN
		IF (CH$EQL(.MC_PTR[MC_NAME_CS], MC_PTR[MC_NAME_ADDR],
				.CS_PTR[0], CS_PTR[1]))
		THEN
			EXITLOOP				! Found.  Continue on to do further checking.
		END;

	!++
	! If the module name was not found, we must not accept the CSP.
	!--
	IF (.MC_PTR EQL 0)
	THEN
		BEGIN
		!++
		! This is an error.  Note that if there was previous to this
		! call a valid CSP, it is not affected by this error.  ALso note
		! that the storage for the CSP we just found to be invalid is
		! discarded by the end-of-line processing AFTER the SIGNAL
		! produces the message.
		!--
		SIGNAL(PAT$_NOSUCHMODU,1,.CS_PTR);
		RETURN(FALSE);
		END;

	!++
	! Make sure that the indicated module is in the RST so that
	! further checking can be done and because a "set scope" implies a
	! "SET MODULE" command.
	!--
	IF NOT .MC_PTR[MC_IN_RST]
	THEN
		PAT$SET_MODULE(.MC_PTR);			! IF THIS FAILS, THERE IS NOT RETURN FROM THIS CALL

	!++
	! The module name is valid and in the RST.  Any further checking depends
	! on whether the given CSP is any longer than simply "module".  If this
	! is the case, we've done all the validating we can.
	!--
	IF (.PATH_VEC_PTR[1] NEQ 0)
	THEN
		BEGIN
		!++
		! Further checking is RST-dependent.
		!--
		LOCAL
			VAL_DESC : VALU_DESCRIPTOR,
			NT_PTR : REF NT_RECORD;

		!++
		! For initialized modules, we can do a complete check.
		! This means that we effectively do a lookup, and then
		! make sure that the path leads to a symbol of type
		! ROUTINE.
		!--
		IF (NOT PAT$SYM_TO_VALU( .PATH_VEC_PTR, VAL_DESC))
		THEN
			BEGIN
			!++
			! Encode the pathname into a counted string and output
			! the associated message.
			!--
			LOCAL MESSAGE_BUF : VECTOR[TTY_OUT_WIDTH, BYTE];

			PAT$PV_TO_CS(.PATH_VEC_PTR, MESSAGE_BUF);
			SIGNAL(PAT$_NOSYMBOL, 1, MESSAGE_BUF);	! No return
			RETURN(FALSE);			!****** THIS SHOULDN'T BE NEEDED
			END;

		!++
		! Now we simply have to see that the valid path leads
		! to ROUTINE.  First we pick up the pointer to this
		! symbol's name table record.
		!--	
		NT_PTR = .VAL_DESC [VALU_NT_PTR];
		IF (NOT .NT_PTR[NT_TYPE] EQL DSC$K_DTYPE_RTN)
		THEN
			BEGIN
			!++
			! A valid path, but we can't accept it as a CSP
			! because perpending it to any symbol would
			! never result in a valid path.
			!--	
			SIGNAL(PAT$_BADCSP);
			RETURN(FALSE);
			END;
		END;
	!++
	! The CSP we are to SET has been checked out OK.
	!--
	NEW_CSP_PTR = .PATH_VEC_PTR;
	END;

!++
! If we get this far, the new CSP will be accepted. First, we have to release
! the storage we used up in accumulating the pathname elements of the  old CSP,
! if there was one.
!--
IF ((PATH_VEC_PTR = .PAT$GL_CSP_PTR) NEQ 0)
THEN
	BEGIN
	PAT$DELETE_PATH();
	END;
!++
! If we were only throwing away the old vector, then we must be done.
!--
IF (NOT .SET_SCOPE_FLAG)
THEN
	BEGIN
	PAT$GL_CSP_PTR = 0;
	RETURN(TRUE);
	END;

!++
! Installing a new CSP is simply a matter of saving away the pointer to the
! PATHNAME_VECTOR.  We must also zero out the pointer to the vector which
! BUILD_PATH uses to deal with these vectors, since we have effectively taken
! this one away.
!--
PAT$GL_CSP_PTR = .NEW_CSP_PTR;
PATH_VEC_PTR = 0;

RETURN(TRUE);
END;

GLOBAL ROUTINE PAT$FIND_MODULE( MOD_NAME_DESC, SIGNAL_FLAG ) =

!++
! Functional Description:
!
!	Search the MC to see if the given module is there.
!
! Formal Parameters:
!
!	MOD_NAME_DESC	-a string descriptor for the supposed
!			 module name.
!	SIGNAL_FLAG	-indicator whether or not this routine should
!			 SIGNAL if the module is not found
!
! Implicit Inputs:
!
!	none.
!
! Implicit Outputs:
!
!	none
!
! Returned Value:
!
!	0 - if the module is not found,
!	an MC_PTR (non-zero) to the indicated MC record, otherwise.
!
! Side Effects:
!
!	none
!--

BEGIN
MAP
	MOD_NAME_DESC : REF BLOCK[,BYTE];			! The supposed module name is
								! described via an SRM string descriptor.

LOCAL
	MODU_CS_NAME : VECTOR[SYM_MAX_LENGTH+1, BYTE],		! COPY OF MODULE NAME FOR NOSUCHMODU ERROR MSG
	MC_PTR : REF MC_RECORD;					! We chain along the MC via this temp pointer.

!++
! Scan along the MC comparing the given string with the module name stored
! therein.  Note that we skip the first MC record because it is reserved for
! globals and is therefore nameless.
!--
MC_PTR = .PAT$GL_MC_PTR;
WHILE ((MC_PTR = .MC_PTR [MC_NEXT]) NEQ 0)
DO
	BEGIN
	IF (CH$EQL(.MC_PTR[MC_NAME_CS],MC_PTR[MC_NAME_ADDR],
			.MOD_NAME_DESC[DSC$W_LENGTH],.MOD_NAME_DESC[DSC$A_POINTER] ))
	THEN
		BEGIN
		!++
		! Found.  Internally in PATCH we agree that the 'value' of a
		! module string will be the RST address of its MC record.
		!--
		RETURN(.MC_PTR);
		END;
	END;

!++
! If we fall out of the above loop, then the given module name was not found.
! Therefore if a SIGNAL is allowed, then construct a COUNTED_STRING pointer and
! pass it as the error message argument.
!--
IF .SIGNAL_FLAG
THEN
	BEGIN
	MODU_CS_NAME[0] = .MOD_NAME_DESC[DSC$W_LENGTH];
	CH$MOVE (.MODU_CS_NAME[0], .MOD_NAME_DESC[DSC$A_POINTER], MODU_CS_NAME[1]);
	SIGNAL(PAT$_NOSUCHMODU, 1, MODU_CS_NAME[0]);		! No return
	END;

RETURN (0);
END;

GLOBAL ROUTINE PAT$FIND_DST : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Find out where the DST begins and make it available for
!	PAT$GET_NXT_DST and PAT$GET_DST_REC.
!	(or make it so that these routines return EOF if no DST exists).
!	Then do the same for the GST.
!
! Calling Sequence:
!
!	PAT$FIND_DST()
!
! FORMAL PARAMETERS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	The image header has been read and PAT$GL_IMGHDR points to it.
!	The old image file is open and ready to read the DST and GST.
!	The variables pointing to the file are:
!		PAT$GL_OLDRAB, PAT$GL_OLDFAB, AND PAT$GL_OLDNAME.
!
! IMPLICIT OUTPUTS:
!
!	none
!
! COMPLETION CODES:
!	none
!
! SIDE EFFECTS:
!
!	The notion of 'next' DST record is initialized
!	here so that a call to PAT$GET_NXT_DST made after
!	a call to this routine will fetch the first record.
!
!	The begin and end address of the DST are also established,
!	but only for the purposes of the interface routines.
!	There is no explicit requirement for this from the RST's 
!	viewpoint - so long as the interface can somehow
!	know when the last record has been passed on.
!
!	If anything goes wrong during the GST/DST initializations,
!	(can't EXPREG, etc.), we output the corresponding message forcing
!	the severity to -I-, and then continue on without the GST or DST.
!	The exceptions to this are that there must be symbol table info in 
!	the header (even if what's there is simply a pointer to say that 
!	there is no DST or GST).
!--

BEGIN

BIND
	SYM_TBL_DATA = .PAT$GL_IMGHDR + .PAT$GL_IMGHDR [IHD$W_SYMDBGOFF]
					: BLOCK [, BYTE],
	EXESECNAM = UPLIT BYTE (%ASCIC 'DST'),
	GSTSECNAM = UPLIT BYTE (%ASCIC 'GST');

LITERAL
	GL_OVERHEAD_REC	= 2,					! GST overhead records from Linker
	SYMS_PER_GLREC	= 28,					! Average GSTs per GST record.
	START_ADDRESS	= 0,					! Starting address offset
	END_ADDRESS	= 1;					! Ending address offset

LOCAL
	STATUS : BLOCK[%UPVAL, BYTE],
	GLOBAL_RECORD : BLOCK [A_PAGE, BYTE],
	EXESECNAM_DESC : VECTOR [2, LONG],
	EXEFILNAM_DESC : VECTOR [2, LONG],
	GL_SYM_COUNT;

!++
! Check if this .EXE file has symbols at all.  There are two kinds of checks
! which we make.  First, we see if the image header is consistent.
! There are two checks for this - one which is always relevant, and one which
! is relevant only if we have already determined that there will be DSTs.
!--
IF (.PAT$GL_IMGHDR [IHD$W_SYMDBGOFF] EQL 0)
THEN
	BEGIN
	GST_BEGIN_ADDR = 0;
	DST_BEGIN_ADDR = 0;
	PAT$GB_SYMBOLS = FALSE;					! Indicate image has no symbols
	SIGNAL(PAT$_NOGBL+MSG$K_INFO);
	SIGNAL(PAT$_NOLCL+MSG$K_INFO);
	RETURN;
	END
ELSE
	PAT$GB_SYMBOLS = TRUE;					! Indicate image has symbols

!++
! Then we see if this is a simple case of there legitimately not being a DST.
! (i.e. the modules were simply not compiled with /DEBUG on).
!--
IF ((DST_BEGIN_ADDR = .SYM_TBL_DATA[IHS$W_DSTBLKS]) EQL 0)
THEN
	BEGIN
	!++
	! Check that the VBN of the DST is also zero.  If it is not,
	! then the image header is contradictory.  Therefore, inform the
	! user and fix the header by setting the DST fields to zero.
	! This should only be an informational message.
	!--
	IF (.SYM_TBL_DATA[IHS$L_DSTVBN] NEQ 0)
	THEN
		SIGNAL(PAT$_INVIMGHDR+MSG$K_INFO);
	SIGNAL(PAT$_NOLCL+MSG$K_INFO);
	DST_BEGIN_ADDR = 0;
	SYM_TBL_DATA[IHS$L_DSTVBN] = 0;
	SYM_TBL_DATA[IHS$W_DSTBLKS] = 0;
	END
ELSE
	!++
	! Check that the VBN is legal.  If not, then this is an inconsistent
	! header.  Inform the user that it is invalid and
	! fix up the header, ignoring the symbols that might be there.
	!--
	IF (.SYM_TBL_DATA[IHS$L_DSTVBN] LEQ 2) OR
	   (.SYM_TBL_DATA[IHS$W_DSTBLKS] LSS 0)
	THEN
		BEGIN
		SIGNAL(PAT$_INVIMGHDR+MSG$K_INFO);
		SIGNAL(PAT$_NOLCL+MSG$K_INFO);
		DST_BEGIN_ADDR = 0;
		SYM_TBL_DATA[IHS$L_DSTVBN] = 0;
		SYM_TBL_DATA[IHS$W_DSTBLKS] = 0;
		END;

!++
! Check that a GST exists.  If not, set an indicator.  Also make a valid image
! header.  This insures PAT$WRTIMG will work correctly.
!--
IF ((GST_BEGIN_ADDR = .SYM_TBL_DATA[IHS$W_GSTRECS]) EQL 0)
THEN
	BEGIN
	!++
	! Check that the VBN of the GST is also zero.  If it is not,
	! then the image header is contradictory.  Therefore, inform the
	! user and fix the header by setting the GST fields to zero.
	! This should only be an informational message.
	!--
	IF (.SYM_TBL_DATA[IHS$L_GSTVBN] NEQ 0)
	THEN
		SIGNAL(PAT$_INVIMGHDR+MSG$K_INFO);
	SIGNAL(PAT$_NOGBL+MSG$K_INFO);
	GST_BEGIN_ADDR = 0;
	SYM_TBL_DATA[IHS$L_GSTVBN] = 0;
	SYM_TBL_DATA[IHS$W_GSTRECS] = 0;
	END
ELSE
	!++
	! Check that the VBN is legal.  If not, then this is an inconsistent
	! header.  Inform the user that it is invalid and
	! fix up the header, ignoring the symbols that might be there.
	!--
	IF (.SYM_TBL_DATA[IHS$L_GSTVBN] LEQ 2) OR
	   (.SYM_TBL_DATA[IHS$W_GSTRECS] LSS 0)
	THEN
		BEGIN
		SIGNAL(PAT$_INVIMGHDR+MSG$K_INFO);
		SIGNAL(PAT$_NOGBL+MSG$K_INFO);
		GST_BEGIN_ADDR = 0;
		SYM_TBL_DATA[IHS$L_GSTVBN] = 0;
		SYM_TBL_DATA[IHS$W_GSTRECS] = 0;
		END;

!++
! Don't try to create and map the DST if there is not one in the .EXE file to map in.
!--
IF (.DST_BEGIN_ADDR NEQ 0)
THEN
	BEGIN
	PAT$GL_OLDRAB [RAB$L_UBF] = GLOBAL_RECORD;		! Set input buffer address
	PAT$GL_OLDRAB [RAB$W_USZ] = A_PAGE;			! Set input buffer size
	PAT$GL_ISVADDR [START_ADDRESS] = 200;			! Set the address vectors to point to the
	PAT$GL_ISVADDR [END_ADDRESS] = 200;			!  first available addresses in P0 space.
	EXESECNAM_DESC [0] = 3;
	EXESECNAM_DESC [1] = EXESECNAM;
	EXEFILNAM_DESC [0] = .PAT$GL_OLDNBK[NAM$B_RSL];
	EXEFILNAM_DESC [1] = PAT$GB_OLDNAME;

	IF NOT (STATUS = LIB$_CREMAPSEC (PAT$GL_ISVADDR
					, PAT$GL_ISVADDR
					, SEC$M_EXPREG
					, EXESECNAM_DESC
					, 0
					, EXEFILNAM_DESC
					, .SYM_TBL_DATA [IHS$W_DSTBLKS]
					, .SYM_TBL_DATA [IHS$L_DSTVBN]))
	THEN
		BEGIN
		!++
		! Unconditionally make the severity level informational so
		! that the message will be produced with no side effects.
		!--
!		STATUS[STS$V_SEVERITY] = SYS$K_INFO;
		STATUS[STS$V_SEVERITY] = 3;
		DST_BEGIN_ADDR =0;
		SIGNAL(PAT$_CRMPSC-MSG$K_FATAL+MSG$K_INFO, 1, .STATUS);
		SIGNAL(.STATUS);
		END
	ELSE
		!++
		! Now load up the addresses of the beginning
		! and end of the DST.
		!--
		BEGIN
		DST_BEGIN_ADDR = .PAT$GL_ISVADDR [START_ADDRESS];
		DST_END_ADDR = .PAT$GL_ISVADDR [END_ADDRESS];
		DST_NEXT_ADDR = .DST_BEGIN_ADDR;
		END;
	END;							! For no DSTs.

!++
! Now map in the GST in the same way we did the DST.  Don't try to create and
! map the GST if there is not one in the .exe file to map in.
!--
IF (.GST_BEGIN_ADDR NEQ 0)
THEN
	BEGIN
	LOCAL
		GST_REC_PTR : REF VECTOR[,WORD];

	!++
	! Find the last mapped address used and compute the addresses into
	! which the GST will be mapped.
	!--
	PAT$GL_OLDRAB[RAB$L_UBF] = GLOBAL_RECORD;		! Set input buffer address
	PAT$GL_OLDRAB[RAB$W_USZ] = A_PAGE;			! Set input buffer size
	PAT$GL_ISVADDR[START_ADDRESS] = 200;			! Set the address vectors to point to the
	PAT$GL_ISVADDR[END_ADDRESS] = 200;			!  first available addresses in P0 space.
	EXESECNAM_DESC [0] = 3;
	EXESECNAM_DESC [1] = GSTSECNAM;
	EXEFILNAM_DESC [0] = .PAT$GL_OLDNBK[NAM$B_RSL];
	EXEFILNAM_DESC [1] = PAT$GB_OLDNAME;

	IF NOT (STATUS = LIB$_CREMAPSEC (PAT$GL_ISVADDR
					, PAT$GL_ISVADDR
					, SEC$M_EXPREG
					, EXESECNAM_DESC
					, 0
					, EXEFILNAM_DESC
					, .SYM_TBL_DATA [IHS$W_GSTRECS]
					, .SYM_TBL_DATA [IHS$L_GSTVBN]
					))
	THEN
		BEGIN
		!++
		! Unconditionally make the severity level informational so
		! that the message will be produced with no side effects.
		!--
!		STATUS[STS$V_SEVERITY] = SYS$K_INFO;
		STATUS[STS$V_SEVERITY] = 3;
		GST_BEGIN_ADDR =0;
		GSR_BEGIN_ADDR =0;
		SIGNAL (PAT$_CRMPSC-MSG$K_FATAL+MSG$K_INFO, 1, .STATUS);
		SIGNAL(.STATUS);
		END
	ELSE
		BEGIN
		!++
		! Now skip the first two records because they
		! are module header and module sub-header, respectively.
		! NOTE: this builds in the knowledge of how these
		! usually-RMS records are formatted.
		!--
		GST_REC_PTR = .PAT$GL_ISVADDR[START_ADDRESS];

		!++
		! Get to the next record by adding the rounded-up
		! record byte count to the previous beginning
		! virtual address, then adding on 2 because the count
		! field is 2 bytes long.
		!--
		GST_REC_PTR = .GST_REC_PTR + 2 + ((.GST_REC_PTR[0] +1)/2)*2;

		!++
		! Now skip the sub-module header.
		!--
		GST_REC_PTR = .GST_REC_PTR + 2 + ((.GST_REC_PTR[0] +1)/2)*2;

		!++
		! And this is the address we wanted.  Both the first, and, at this
		! point, the 'next' records, start at this address.
		!--
		GSR_BEGIN_ADDR = .GST_REC_PTR;
		GSR_NEXT_ADDR = .GSR_BEGIN_ADDR;

		!++
		! Tell the inner mechanism how many GST records there will be.
		! This number is the number that the LINKer gave us, -3,
		! because of the 2 records we just skipped over, PLUS the
		! module-end record at the end of the GST.
		!--
		POSITION_GST( .SYM_TBL_DATA[IHS$W_GSTRECS] - 3 );
		END;
	END;							! For no GSTs.

PAT$INIT_RST (.GL_SYM_COUNT);
END;

GLOBAL ROUTINE PAT$GET_DST_REC ( REC_ID ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Make the indicated DST record available.
!
! FORMAL PARAMETERS:
!
!	REC_ID	- The ID of the record we are to fetch.
!		  This ID must be one which was previously returned
!		  by a call to PAT$GET_NXT_DST.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	0, if the indicated record does not exist,
!	the address of where is can now be referenced, otherwise.
!
! SIDE EFFECTS:
!
!	The DST record is made available.
!
!--

BEGIN

BIND
	DST_RECRD = .REC_ID : DST_RECORD;

!++
! If there is no DST, simply return as though we were asked to read one
! past the last one. (The interface's notion of EOF).
!--
IF (.DST_BEGIN_ADDR EQL 0)
THEN
	RETURN(0);

!++
! The record ID is the same as the virtual address at which it can be
! referenced.  The next record, then, is simply the one which is virtually
! contiguous to this one, excepting for the case of the last record.
! Here we are lenient - we say that the DST ended OK if one asks for a
! record which is past the end marker, OR, if the count field
! for a supposed 'next' record is 0.
!--
IF (.REC_ID EQL .DST_END_ADDR +1)
THEN
	RETURN(0);

!++
! Now that it is safe, check for 0-length records.
!--
IF (.DST_RECRD [DSTR_SIZE] EQL 0)
THEN
	RETURN(0);

!++
! Then check that the ID is valid.  
!--
IF (.REC_ID LSSA .dst_begin_addr)   OR    (.REC_ID GTRA .dst_end_addr)
THEN
	BEGIN
	!++
	! This should not happen - we check and report
	! errors here only to help us while debugging.
	!--
	SIGNAL (PAT$_INVDSTREC);				! Severe error
	RETURN(0);
	END;

RETURN( .REC_ID );
END;

GLOBAL ROUTINE PAT$POSITON_DST ( REC_ID ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Make the indicated DST record available in such
!	a way that PAT$GET_NXT_DST's idea of 'next' is
!	defined to be the one after this routine fetches.
!
! FORMAL PARAMETERS:
!
!	REC_ID	- The ID of the record we are to fetch.
!		  This ID must be one which was previously returned
!		  by a call to PAT$GET_NXT_DST.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	0, if the indicated record does not exist,
!	the address of where is can now be referenced, otherwise.
!
! SIDE EFFECTS:
!
!	The DST record is made available.
!	The 'next' DST record is henceforth defined to
!	be the one after the one fetched by this call.
!
!--

BEGIN

LOCAL
	REC_ADDR : REF DST_RECORD;

!++
! PAT$GET_DST_REC does most of the work - 
! we just include the above-described side effect.
!--
IF ((REC_ADDR = PAT$GET_DST_REC( .REC_ID )) EQL 0 )
THEN
	RETURN(0);

!++
! RE-initialize INT's notion of 'next' DST record.
!--
DST_NEXT_ADDR = .REC_ADDR + .REC_ADDR [DSTR_SIZE] +1;
RETURN( .REC_ADDR );
END;

ROUTINE POSITION_GST ( GST_REC_COUNT ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine, if called with a positive value initializes its OWN
!	storage to remember the number of RMS-type records in the GST.
!	If it is called with a negative or zero value, it returns the address
!	of the next RMS-type record in the GST.  A negative value also causes
!	the pointers to be positioned at the start of the GST.
!
! FORMAL PARAMETERS:
!
!	GST_REC_COUNT	- The number of RMS records in the GST.
!			  (negative value) re-position to start and return
!			  address of first GLOBAL.
!			  (zero) return address of the next GLOBAL.
!
! IMPLICIT INPUTS:
!
!	GSR_BEGIN_ADDR	- Holds the starting address of the GST.
!			  If the value is not GTR 0 or 1, then the GST
!			  has not been mapped in so this routine returns 0.
!
! IMPLICIT OUTPUTS:
!
!	GSR_NEXT_ADDR	- Holds the address of the next RMS record in the GST
!			  or the GST was not mapped in.
!
! ROUTINE VALUE:
!
!	0		- If there are no more records in the GST.
!	non-zero	- The address of the next GST RMS record.
!
! SIDE EFFECTS:
!
!	The next GST record can now be accessed, and an OWN pointer to the next
!	one is maintained.  The number of GST records yet to go is also updated
!	so that the end of the GST can be detected.
!
!--

BEGIN

OWN
	TOTAL_RECORDS,
	RECORDS_LEFT;

LOCAL
	BLOCK_ADDR;

!++
! If there is no mapped GST, then return 0, no atter why this routine
! was called.
!--
IF (NOT .GSR_BEGIN_ADDR GTRA 1)
THEN
	RETURN(0);

IF (.GST_REC_COUNT GTR 0)
THEN
	BEGIN
	TOTAL_RECORDS = .GST_REC_COUNT;
	RETURN (0);
	END;

IF (.GST_REC_COUNT NEQ 0)
THEN
	BEGIN
	GSR_NEXT_ADDR = .GSR_BEGIN_ADDR;
	RECORDS_LEFT  = .TOTAL_RECORDS;
	END;

!++
! Stop the following from faulting if some caller ignores the end condition and
! effectively causes us to 'run off the end' of the mapped GST.
!--
IF (NOT .RECORDS_LEFT GEQ 1)
THEN
	RETURN(0);

!++
! Pick up the address of the current record, and update the pointer to the
! subsequent one.
!--
BLOCK_ADDR = .GSR_NEXT_ADDR + 2;
GSR_NEXT_ADDR = .GSR_NEXT_ADDR + 2 + ((.GSR_NEXT_ADDR[0] +1)/2)*2;
RECORDS_LEFT = .RECORDS_LEFT - 1;
RETURN (.BLOCK_ADDR);
END;

GLOBAL ROUTINE PAT$GET_NXT_DST ( REC_ID_PTR ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Make the next DST record available,
!	and return both a pointer to where it
!	can now be referenced, as well as an ID
!	for it so that we can ask for it later.
!
! FORMAL PARAMETERS:
!
!	REC_ID_PTR - the address of where this routine will
!		     stuff the ID it wants subsequent calls
!		     to PAT$GET_DST_REC to use to refer
!		     to the record fetched by this call.
!
! IMPLICIT INPUTS:
!
!	To be defined.
!	(whatever context these routines work from).
!
! IMPLICIT OUTPUTS:
!
!	none
!
! COMPLETION CODES:
!
!	0, if the indicated record does not exist,
!	the address of where is can now be referenced, otherwise.
!
! SIDE EFFECTS:
!
!	The DST record after the last one fetched is made available.
!	If no record has yet been fetched, the first record in
!	the DST is made available.
!
!--

BEGIN

MAP
	REC_ID_PTR : REF VECTOR[,LONG];

!++
! Since for us record IDs are the same as their virtual addresses, we can get
! the next one the same way we can get ANY one.  The only detail to fill in is
! passing back the ID for this next one.
!--
RETURN(REC_ID_PTR[0] = PAT$POSITON_DST( .DST_NEXT_ADDR ));
END;

GLOBAL ROUTINE PAT$GET_NXT_GST (ACCESS_FLAG) =

!++
! Functional description:
!
!	This routine returns the address of a fixed length record that
!	contains a global symbol name and its associated value. This
!	routine expects to be called repeatedly until each global symbol
!	has been returned to the caller.
!
!	Before this routine is ever called, the location of the GST in
!	the image file is found, and it is mapped into PATCH's image.
!	The address of this buffer is held in the OWN variable GST_BEGIN_ADDR.
!	This routine analyzes the GST record, and moves through the buffer,
!	returning the buffer address of each global symbol entry as it is seen.
!	When the buffer is exhausted, this routine reads in the next GST record.
!	It halts at end of file and returns a value of zero to the caller.
!
!	This routine keeps the variable GST_BEGIN_ADDR up to date.
!
!	The format of one of these concatenated records is a single
!	leading byte containing the value 1, indicating that the record
!	is indeed a GSD record. The variable GST_BEGIN_ADDR addresses
!	the byte following this leading byte.
!
!	Each entry in the record has a fixed number of overhead
!	bytes followed by a symbol name that is a variable number of
!	bytes. The entries we are interested in processing are the
!	global symbol definitions, entry point symbol and mask
!	definitions, and procedure definitions with formal argument descriptions.
!	The other defined type, PSECT definition, is noted only because it
!	must be successfully passed over.  The format of each of these types is
!	illustrated below:
!
!
!	Global symbol definition:
!
!		-----------------
!	0	!   GSD type 1  !
!		-----------------
!	1	!   data type   !	ignored for now
!		-----------------
!	2	!     flag      !	bit 1 set means that this is
!	3	!     bytes     !	a definition. ignore bit 0.
!		-----------------
!	4	!  psect index  !	ignored.
!		-----------------
!	5	!		!
!		!     value     !	4 bytes
!		!		!
!		-----------------
!	9	!		!
!		!    symbol     !	stock counted character
!		!     name      !	string.
!		!		!
!		-----------------
!
!	The entry point symbol and mask definition entry is identical to
!	the global symbol definition illustrated above, with the 
!	addition of a two byte field for the procedure's register save
!	mask. This two byte field is located after the symbol value
!	field (which is an entry point address).
!
!		-----------------
!	0	!   GSD type 2  !
!		-----------------
!	1	!   data type   !	ignored for now
!		-----------------
!	2	!     flag      !	not relevant for
!	3	!     bytes     !	entry point def.
!		-----------------
!	4	!  psect index  !	ignored
!		-----------------
!		!		!
!	5	!     value     !	4 bytes
!		!		!
!		-----------------
!	9	!   register    !	ignored,
!	10	!   save mask   !	2 bytes
!		-----------------
!	11	!		!
!		!    symbol     !	stock counted character
!		!     name      !	string
!		!		!
!		-----------------
!
!	The procedure definition with formal argument descriptions is
!	identical to the entry point with mask definition above, save 
!	that it has some additional fields.  There is a minimum number
!	of arguments byte and a maximum number of arguments byte.  These
!	are followed by a formal argument description for each possible
!	argument (i.e., the maximum number).  The formal argument descriptions
!	consist of an argument value control byte and a remaining count byte.
!	The remaining count byte tells the number of bytes in the detailed
!	argument description (from 0 to 255).
!
!		-----------------
!	0	!   GSD type 3  !
!		-----------------
!	1	!   data type   !	ignored for now
!		-----------------
!	2	!     flag      !	bit 1 set means that this is
!	3	!     bytes     !	a definition. ignore bit 0.
!		-----------------
!	4	!  psect index  !	ignored
!		-----------------
!		!		!
!	5	!     value     !	4 bytes
!		!		!
!		-----------------
!	9	!   register    !	ignored,
!	10	!   save mask   !	2 bytes
!		-----------------
!	11	!		!
!		!    symbol     !	stock counted character
!		!     name      !	string
!		!		!
!		-----------------
!		! min # act arg !	1 byte
!		-----------------
!		! max # act arg !	1 byte
!		-----------------
!		! formal arg #1 !
!		!  description  !
!		-----------------
!		!       .       !
!		!       .       !
!		!       .       !
!		-----------------
!		! formal arg #n !
!		!  description  !
!		-----------------
!
!	Each formal argument description has the following format:
!
!		-----------------
!	0	! arg. val. ctl.!	1 byte
!		-----------------
!	1	! rem. byte cnt.!	1 byte
!		-----------------
!		!   detailed    !	anywhere
!		!   argument    !	from 0-255
!		!  description  !	bytes
!		-----------------
!
!	PSECT definition:
!
!		-----------------
!	0	!   GSD type 0  !
!		-----------------
!	1	!   alignment   !
!		-----------------
!	2	!     flag      !
!	3	!     bytes     !
!		-----------------
!	4	!		!
!		!  allocation   !	4 bytes
!		!		!
!		-----------------
!	8	!		!
!		!    symbol     !	stock counted character
!		!     name      !	string.
!		!		!
!		-----------------
!
!
!	PSECT definition in a Shareable Image:
!
!		-----------------
!	0	!   GSD type 0  !
!		-----------------
!	1	!   alignment   !
!		-----------------
!	2	!     flag      !
!	3	!     bytes     !
!		-----------------
!	4	!		!
!		!  allocation   !	4 bytes
!		!		!
!		-----------------
!	8	!  base address	!
!		! within Share-	!	4 bytes
!		!  able Image	!
!		-----------------
!	12	!		!
!		!    symbol     !	stock counted character
!		!     name      !	string.
!		!		!
!		-----------------
!
! Calling sequence:
!
!	CALLS #0, PAT$GET_NXT_GST
!
! Inputs:
!
!	none
!
! Implicit inputs:
!
!	GST_BEGIN_ADDR	- Current address of record buffer
!
! Outputs:
!
!	The address of the next global symbol entry, or 0, if EOF.
!
! Implicit outputs:
!
!	GST_BEGIN_ADDR is updated to address the next entry.
!
! Routine value:
!
!	An address or 0
!
! Side effects:
!
!	Another record may be read in.
!--

BEGIN

LOCAL
	OLD_ADDRESS : REF BLOCK [, BYTE];

LABEL
	GET_RECORD;

IF (.ACCESS_FLAG NEQ 0)
THEN
	BEGIN
	IF ((GST_BEGIN_ADDR = POSITION_GST(-1)) EQL 0)
	THEN
		GST_BEGIN_ADDR = %X'FFFFFFFF';
	RETURN(0);
	END;

!++
! See whether the current buffer address is beyond the
! end of the last GST record we looked at.  Note that we
! rounded up GSR_NEXT_ADDR when calculating where the next
! GST record will begin.  Therefore we must temporarily round
! it down again when comparing it with GST_BEGIN_ADDR since it
! may point to the last unused byte in a GST record.
!--
REPEAT
GET_RECORD:
	BEGIN
	!++
	! First check that there is a GST in this image.
	!--
	IF (.GST_BEGIN_ADDR EQL 0)
	THEN
		RETURN(0);

	IF (.GST_BEGIN_ADDR GEQA .GSR_NEXT_ADDR-1)
	THEN
		BEGIN
		!++
		! Record was finished.  Check that there are more records.
		! If so, then get another record.
		!--
		IF ((GST_BEGIN_ADDR = POSITION_GST(0)) EQL 0)
		THEN
			RETURN(0)
		ELSE
			BEGIN
			!++
			! If the next record is a GST record, then initialize
			! the variable GST_BEGIN_ADDR to point to the first
			! global symbol definition block in this record. 
			!--
			LOCAL
				BUFFER_ADDRESS : REF VECTOR [, BYTE];

			BUFFER_ADDRESS = .GST_BEGIN_ADDR;
			IF .BUFFER_ADDRESS [GST_RECORD_TYPE] EQL GST_TYPE
			THEN
				GST_BEGIN_ADDR = .GST_BEGIN_ADDR + 1
			ELSE
				BEGIN
				!++
				! This record is not a GST record.
				! Go on to the next.
				!--
				GST_BEGIN_ADDR = %X'FFFFFFFF';
				LEAVE GET_RECORD;
				END;
			END;
		END
	ELSE
		BEGIN
		!++
		! This is a global symbol. Save its address.
		! Then update the variable GST_BEGIN_ADDR to
		! point to the next symbol.
		!--
		OLD_ADDRESS = .GST_BEGIN_ADDR;
		CASE .OLD_ADDRESS [ENTRY_TYPE] FROM GSD$C_PSC TO GSD$C_SPSC OF

			SET

			[GSD$C_PSC]:
				BEGIN
				GST_BEGIN_ADDR = .OLD_ADDRESS +
						(OLD_ADDRESS[GPS$T_NAME] - OLD_ADDRESS[GPS$T_START])
						+ .OLD_ADDRESS [GPS$B_NAMLNG];
				END;


			[GSD$C_SYM]:
				BEGIN
				GST_BEGIN_ADDR = .OLD_ADDRESS +
						(OLD_ADDRESS[SDF$T_NAME] - OLD_ADDRESS[SDF$T_START])
						+ .OLD_ADDRESS [SDF$B_NAMLNG];
				RETURN .OLD_ADDRESS
				END;


			[GSD$C_EPM]:
				BEGIN
				GST_BEGIN_ADDR = .OLD_ADDRESS +
						(OLD_ADDRESS[EPM$T_NAME] - OLD_ADDRESS[EPM$T_NAME])
						+ .OLD_ADDRESS [EPM$B_NAMLNG];
				RETURN .OLD_ADDRESS
				END;


			[GSD$C_PRO]:
				BEGIN
				LOCAL
					NUM_ARGS;		! Max formal args
				GST_BEGIN_ADDR = .OLD_ADDRESS +
						(OLD_ADDRESS[EPM$T_NAME] - OLD_ADDRESS[EPM$T_NAME])
						+ .OLD_ADDRESS [EPM$B_NAMLNG];
				NUM_ARGS = .GST_BEGIN_ADDR[GST_P_MAX_ARG];
				GST_BEGIN_ADDR = .GST_BEGIN_ADDR + MINMAX_OVERHEAD;
				WHILE (.NUM_ARGS GTR 0)
				DO
					BEGIN
					GST_BEGIN_ADDR = .GST_BEGIN_ADDR +
							 .GST_BEGIN_ADDR[GST_P_REM_CNT] + ARGDSC_OVERHEAD;
					NUM_ARGS = .NUM_ARGS - 1;
					END;
				RETURN .OLD_ADDRESS
				END;


			[GSD$C_SPSC]:
				BEGIN
				GST_BEGIN_ADDR = .OLD_ADDRESS +
						(OLD_ADDRESS[SGPS$T_NAME] - OLD_ADDRESS[SGPS$T_START])
						+ .OLD_ADDRESS [SGPS$B_NAMLNG];
				END;


			[INRANGE]:
				BEGIN
				GST_BEGIN_ADDR = %X'FFFFFFFF';
				END;

			[OUTRANGE]:
				BEGIN
				GST_BEGIN_ADDR = %X'FFFFFFFF';
				END;

			TES;

		END;
	END;
END;

GLOBAL ROUTINE PAT$RST_FREEZ ( UNITS ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Isolate storage allocation for the RST builder/manipulator.
!	i.e. Do exactly what PAT$FREEZ does for the rest of 
!	PATCH, but take care of any differences (which may
!	or may not exits), when it is the RST interface
!	which wants the storage.
!
!	For now, there IS a difference - an RST-pointer is 
!	returned, NOT the usual longword pointer.  RST-pointers
!	are something internal to the RST builder/manipulator,
!	and it doesn't want to ever see anything but RST-pointers
!	(even if someday RST-pointers are the same thing as
!	virtual addresses).  This is really the motivation for
!	having PAT$RST_FREEZ.
!
! Formal Parameters:
!
!	UNITS - the number of units of storage which are
!		required.  This unit will remain whatever
!		unit PAT$FREEZ knows about.
!
! Implicit Inputs:
!
!	See PAT$FREEZ
!
! Implicit Outputs:
!
!	See PAT$FREEZ
!
! Routine Value:
!
!	0, if something goes wrong, an RST-pointer to the
!	allocated storage, otherwise.
!
! Side Effects:
!
!	See PAT$FREEZ
!--

BEGIN
LOCAL
	STORAGE_PTR;

STORAGE_PTR = PAT$FREEZ( .UNITS );

!++
! Currently an RST-pointer is just like a virtual
! address except that the top 16 bits are 0 in the
! former, and hex 7FFF0000 in the latter.
! NOTE:  THIS IS ONLY TRUE IF THE DEBUGGER INDICATOR IS TURNED OFF IN
! PAT$FREE_INIT.  IF IT IS TURNED ON, THEN THE STORAGE IS OWN STORAGE, NOT
! CONTAINED IN SYSTEM SPACE.
!--
RETURN( .STORAGE_PTR - .PAT$GL_RST_BEGN );

END;

GLOBAL ROUTINE PAT$RST_RELEASE ( RST_PTR, SIZE ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Isolate storage deallocation for all storage which
!	is accessed via RST-pointers.
!
!	i.e. Do exactly what PAT$FREERELEASE does for the rest of 
!	PATCH, but take care of any differences (which may
!	or may not exits), when it is the RST interface
!	which wants to free up this special-access storage.
!
!	For now, there IS a difference - an RST-pointer is
!	given to indicate which storage to free up.  This makes
!	PAT$RST_RELEASE the inverse of PAT$RST_FREEZ, just
!	as is true for the standard PATCH storage primitives.
!
! Formal Parameters:
!
!  RST_PTR - this indicates which storage
!		 is to be freed.  This must be the same as
!		 one which was returned by DBG$RST_FREEZ.
!  SIZE		-The number of units which corresponds
!		 to the storage to be freed.
!
! Implicit Inputs:
!
!	See PAT$FREEZ
!
! Implicit Outputs:
!
!	See PAT$FREEZ
!
! Routine Value
!
!	NOVALUE
!
! Side Effects:
!
!	See PAT$FREEZ
!--

BEGIN

!++
! Currently an RST-pointer is just like a virtual
! address except that the top 16 bits are 0 in
! in the former and hex 7FFF0000 in the latter.
!--
PAT$FREERELEASE( .RST_PTR + .PAT$GL_RST_BEGN, .SIZE );
END;

END								! End of module
ELUDOM
