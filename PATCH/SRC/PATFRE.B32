MODULE PATFRE (
		%IF %VARIANT EQL 1
		%THEN
			ADDRESSING_MODE (EXTERNAL = LONG_RELATIVE, NONEXTERNAL = LONG_RELATIVE),
		%FI
		IDENT = 'V03-000') =
BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! FACILITY:	PATCH
!
!++
! FUNCTIONAL DESCRIPTION:
!
!	Free storage allocator and manager for symbol table.
!
! Version:	V02-008
!
! History:
!	Author:
!		Isaac Nassi, 7 Jul 1976: Version 01
!
! MODIFIED BY:
!
!	V02-008	PCG0001		Peter George		02-FEB-1981
!		Add require statement for LIB$:PATDEF.REQ
!
!	Modified by:
!		Carol Peters, 11 Oct 1977: Version 13
!
!	Modified by:
!		Kathleen Morse, 13 Oct 1977: Version 14
!
! Revision history:
!
!  NO	DATE		PROGRAMMER		PURPOSE
!  --	----		----------		-------
!
!  00	13-OCT-77	K.D. MORSE		MODIFY VERSION 13 FOR PATCH
!  01	27-DEC-77	K.D. MORSE		ADD ROUTINE PAT$REPORT_FREE.
!  02	27-DEC-77	K.D. MORSE		INITIALIZE PAT$GL_RST_BEGN.
!  03	5-JAN-78	K.D. MORSE		NO CHANGES FOR VERS 14-16.
!  04	14-APR-78	K.D. MORSE		NO CHANGES FOR VERS 17.
!  05	25-APR-78	K.D. MORSE		CONVERT TO NATIVE COMPILER.
!  06	18-MAY-78	K.D. MORSE		NO CHANGES FOR VERS 18-19.
!  07	13-JUN-78	K.D. MORSE		ADD FAO COUNTS TO SIGNALS.
!
!--

!++
! Abstract:
!
!	THIS MODULE CONTAINS PROCEDURES TO MANAGE AN AREA OF FREE
!	STORAGE.
!
!	THE ROUTINE PAT$FREEINIT IS CALLED AT SYSTEM INITIALIZATION
!	TO INITIALIZE THE MODULE.  IT TAKES AS INPUT THE ADDRESS
!	OF THE PROCEDURE TO BE CALLED IN THE EVENT AN ERROR
!	IS ENCOUNTERED.  CODES FOR ERROR CONDITIONS ARE CONTAINED IN
!	FILE 'PATMSG.REQ'.
!
!	THE ROUTINE FREEGET IS CALLED TO ALLOCATE A USER SPECIFIED
!	NUMBER OF LONGWORDS.  IF THE REQUEST CAN BE SATISFIED,
!	FREEGET RETURNS A POINTER TO THE BLOCK OF LONGWORDS.
!	THE RETURNED BLOCK CONTAINS ONE EXTRA WORD CONTAINING
!	THE SIZE REQUEST AT WORD -1 IN THE BLOCK.  THIS SIZE
!	IS CHECKED WHEN THE STORAGE IS RETURNED.  IT SHOULD
!	NOT BE MODIFIED.  THE ALGORITHM USED IS A FIRST FIT
!	ALGORITHM WHICH WHILE NOT OPTIMAL SHOULD GIVE REASONABLE
!	RESULTS, AND DO A MINIMUM OF SEARCHING.
!
!	Dynamic storage is the last 64K bytes of the per process
!	address space. It is made accessible by a $CRETVA system
!	service call made in FREEINIT.
!
!	PAT$FREERELEASE IS CALLED TO RELEASE STORAGE NO LONGER NEEDED.
!	IT ATTEMPTS TO DO AS MUCH COMPACTION AS IS POSSIBLE.
!
!	ROUTINE PAT$FREEZ IS CALLED TO ALLOCATE A BLOCK OF 
!	CLEARED FREE STORAGE.
!
!	ROUTINE PAT$REPORT_FREE REPORTS THE NUMBER OF BYTES LEFT IN FREE STORAGE.
!
!--

!
! TABLE OF CONTENTS
!

FORWARD ROUTINE
	PAT$FREEINIT : NOVALUE,					! routine to initialize free storage
	FREEGET,						! routine to get some free storage
	PAT$FREERELEASE : NOVALUE,				! routine to release some free storage
	PAT$FREEZ,						! routine to get and zero some free storage
	PAT$REPORT_FREE;					! ROUTINE TO REPORT FREE STORAGE LEFT

!
! INCLUDE FILES
!

LIBRARY 'SYS$LIBRARY:STARLET.L32';
REQUIRE 'SRC$:PATPCT.REQ';
REQUIRE 'SRC$:VXSMAC.REQ';
REQUIRE 'SRC$:PATGEN.REQ';
REQUIRE 'SRC$:BSTRUC.REQ';
REQUIRE 'LIB$:PATDEF.REQ';				! Defines literals
REQUIRE 'LIB$:PATMSG.REQ';
REQUIRE 'SRC$:SYSSER.REQ';

!
! EXTERNAL REFERENCES
!

EXTERNAL
	PAT$GL_RST_BEGN,					! START OF RST
	PAT$GL_ERRCODE;						! ERROR CODE
!
! EQUATED SYMBOLS
!

LITERAL
	DEBUGGER = TRUE;					! COMPILE TIME CONDITIONAL FOR DEBUGGING

%IF DEBUGGER
%THEN
	LITERAL
		NUM_OF_WRK_PAG=128,				! NUMBER OF WORK AREA PAGES
		STORESIZE=(512*NUM_OF_WRK_PAG)/4;		! GET 65K OF WORK AREA FROM P0 NOT P1
%ELSE
	LITERAL							! GET WORK SPACE FROM P1 AREA
		SYM_TAB_START	=%X'7FFF0000',			! virtual address of symbol table beginning
		SYM_TAB_END	=%X'7FFFFFFF',
		STORESIZE	= (SYM_TAB_END - SYM_TAB_START) / 4;
%FI

!
! OWN STORAGE
!

OWN
%IF DEBUGGER
%THEN
	PAT$GL_STORAGE: VECTOR[STORESIZE],			! SET ASIDE WORK AREA IN P0
%FI
	PAT$STORE: REF VECTOR,					! pointer to free storage area
	PAT$FREELIST : VECTOR [2];				! describes remaining unallocated free storage

BASED_STRUCTURE (FR, 2,
	SIZE,	0,	0,	32,	0,
	NEXT,	1,	0,	32,	0);

GLOBAL ROUTINE PAT$FREEINIT : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	PAT$FREEINIT IS CALLED TO INITIALIZE THE FREE STORAGE
!	PACKAGE.
!
! CALLING SEQUENCE:
!
!	PAT$FREEINIT ()
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	NONE
!
! OUTPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	PAT$FREELIST AND THE FIRST ELEMENT OF PAT$STORE ARE INITIALIZED.
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! SIDE EFFECTS:
!
!	NONE
!--

BEGIN
!
!++
! THIS ROUTINE HAS TWO VERSIONS, DEPENDING UPON WHETHER IT MUST LEAVE THE
! P1 SPACE FOR THE DEBUGGER TO USE, OR CAN USE IT FOR ITS OWN PURPOSES.
! IF THE DEBUGGER IS TO BE LINKED WITH PATCH, THEN THE COMPILE-TIME VARIABLE "DEBUGGER"
! IS SET TO TRUE, CAUSING PATCH TO ALLOCATE THE WORK SPACE FROM P0 SPACE
! INSTEAD OF P1 SPACE.  OTHERWISE, "DEBUGGER" IS SET TO FALSE AND PATCH
! USES THE P1 SPACE FOR WORK AREA.
!--

!++
! FIRST HANDLE THE CASE WHERE THE DEBUGGER IS NOT TO BE LINKED IN.
!--
%IF NOT DEBUGGER
%THEN

LITERAL
	START_TAB	= 0,					! offset for start of symbol table
	END_TAB		= 1;					! offset for end of symbol table.

LOCAL
	SYMTAB_DESC : VECTOR [2];				! descriptor for space to create

SYMTAB_DESC [START_TAB] = SYM_TAB_START;
SYMTAB_DESC [END_TAB] = SYM_TAB_END;
PAT$GL_ERRCODE = $CRETVA (INADR = SYMTAB_DESC, RETADR = SYMTAB_DESC);
IF NOT .PAT$GL_ERRCODE
THEN
	SIGNAL (.PAT$GL_ERRCODE);

!++
! The create virtual page system service was successful.
! Now initialize the first few words of the space, and the
! freelist values.
!--
PAT$STORE = .SYMTAB_DESC [START_TAB];

!++
! NOW HANDLE THE CASE WHERE THE DEBUGGER IS LINKED IN.
!--

%ELSE
PAT$STORE = PAT$GL_STORAGE;
%FI

FR_SIZE (.PAT$STORE) = STORESIZE;
FR_NEXT (.PAT$STORE) = NULL;
FR_NEXT (PAT$FREELIST) = .PAT$STORE;
FR_SIZE (PAT$FREELIST) = 2;

!++
! NOW SET THE ADDRESS OF THE START OF THE RST.
!--
PAT$GL_RST_BEGN = .PAT$STORE;

END;

ROUTINE FREEGET (NEED1) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	PROCEDURE FREEGET IS CALLED WITH ONE INPUT ARGUMENT,
!	NEED1, WHICH REPRESENTS THE NUMBER OF WORDS OF FREE
!	STORAGE NEEDED.  IT SEARCHES THE FREELIST FOR A
!	NODE THAT HAS AT LEAST THE REQUIRED NUMBER OF WORDS.
!	IF THE NODE HAS MORE THAN THE REQUIRED NUMBER OF WORDS,
!	THE NODE IS SPLIT INTO TWO NODES, AND ONE IS RETURNED.
!
! CALLING SEQUENCE:
!
!	FREEGET ()
!
! INPUTS:
!
!	NEED1	- THE NUMBER OF WORDS NEEDED OF FREE STORAGE
!
! IMPLICIT INPUTS:
!
!	THE CURRENT STATE OF PAT$FREELIST.
!
! OUTPUTS:
!
!	THE ADDRESS OF THE FREE STORAGE ACQUIRED.
!
! IMPLICIT OUTPUTS:
!
!	THE STATE OF PAT$FREELIST AND THE COUNT OF WORDS
!	OF STORAGE LEFT ARE CHANGED.
!
! ROUTINE VALUE:
!
!	THE ADDRESS OF THE BLOCK
!
! SIDE EFFECTS:
!
!	IF THERE IS NO FREE STORAGE, THEN A SEVERE ERROR IS REPORTED WHICH
!	CAUSES AN "UNWIND" FOR THE NEXT COMMAND (INTERACTIVE MODE) OR AN
!	EXIT FROM PATCH (BATCH MODE).
!--

BEGIN

LOCAL
	NEED,
	OLDNODE,
	LIST,
	HAVE;

NEED = .NEED1 + 1 ;						! ONE WORD BIAS FOR SIZE
IF .NEED LSS 0
THEN
	SIGNAL (PAT$_NOFREE);
LIST = .FR_NEXT (PAT$FREELIST);
OLDNODE = PAT$FREELIST;
WHILE .LIST NEQ NULL
DO
	BEGIN							! FIND FIRST FIT
	IF ((HAVE = .FR_SIZE (.LIST)) EQL .NEED)
		OR (.have GEQ (.need + 2))
	THEN
		BEGIN						! FOUND 
		IF .HAVE EQL .NEED
		THEN FR_NEXT (.OLDNODE) = .FR_NEXT (.LIST)
		ELSE
			BEGIN					! LARGER THAN NEEDED
			FR_NEXT (.LIST + .NEED * 4) = .FR_NEXT (.LIST);
			FR_SIZE (.LIST + .NEED * 4 ) = .FR_SIZE (.LIST) - .NEED;
			FR_NEXT (.OLDNODE)  = .LIST + .NEED * 4;
			END;					! LARGER THAN NEEDED
		FR_SIZE (.LIST) = .NEED;

		RETURN (.LIST + 4);				! CONTAINS SIZE
		END						! FOUND
	ELSE LIST = .FR_NEXT (.LIST);
	OLDNODE = .FR_NEXT (.OLDNODE);
	END;							! FIND FIRST FIT
SIGNAL (PAT$_NOFREE);						! Signal error
RETURN NULL
END;	

GLOBAL ROUTINE PAT$FREERELEASE (INODE1, NUM1) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	PROCEDURE PAT$FREERELEASE IS CALLED TO RETURN STORAGE
!	BACK INTO THE FREE STORAGE POOL.  IT MAINTAINS A
!	FREELIST IN ASCENDING ORDER OF STORAGE ADDRESSES,
!	AND FINDS THE PROPER LOCATION FOR INODE IN THIS
!	LIST.  THEN IT ATTEMPTS TO MERGE WITH THE LEFT HAND 
!	NEIGHBOR AND WITH THE RIGHT HAND NEIGHBOR.
!
! CALLING SEQUENCE:
!
!	PAT$FREERELEASE ()
!
! INPUTS:
!
!	INODE1	- ADDRESS OF A NODE
!	NUM1	- LENGTH OF A NODE
!
! IMPLICIT INPUTS:
!
!	THE FREE STORAGE POOL, AND THE CURRENT CONTENTS OF PAT$FREELIST.
!
! OUTPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	AN ERROR MESSAGE CALL ON ERROR
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! SIDE EFFECTS:
!
!	THE STORAGE IS RETURNED TO THE POOL.
!--

BEGIN

LOCAL
	INODE,
	NUM,
	NODE,
	OLDNODE;

INODE = .INODE1 - 4 ;						! BIAS FOR SIZE WORD
NUM = .NUM1 + 1 ;						! INVISIBLE TO USER
IF .INODE GEQA .PAT$STORE 
    AND .INODE LEQA .PAT$STORE + (STORESIZE * 4) - 1
    AND .FR_SIZE (.INODE) EQL .NUM				! CORRECT SIZE
THEN
	BEGIN							! IN RANGE
	NODE = .FR_NEXT (PAT$FREELIST);
	OLDNODE = PAT$FREELIST;
	WHILE .INODE GTRA .NODE AND .NODE NEQ NULL
	DO
		BEGIN						! FIND CORRECT SLOT
		OLDNODE = .NODE;
		NODE = .FR_NEXT (.NODE);
		END;						! FIND CORRECT SLOT
	FR_NEXT (.INODE) = .NODE;				! MERGE INTO LIST
	FR_NEXT (.OLDNODE) = .INODE;
	INCR I FROM 1 TO 2 DO
		IF .OLDNODE + .FR_SIZE (.OLDNODE) * 4 EQLA .FR_NEXT (.OLDNODE)
			AND .OLDNODE NEQA PAT$FREELIST 	!NOT FIRST ON LIST
		THEN
			BEGIN					! MERGE A NEIGHBOR
			FR_SIZE (.OLDNODE) = .FR_SIZE (.OLDNODE) + .FR_SIZE (.FR_NEXT (.OLDNODE));
			FR_NEXT (.OLDNODE) = .FR_NEXT (.FR_NEXT (.OLDNODE));
			END				 	 !MERGE A NEIGHBOR
		ELSE OLDNODE = .FR_NEXT (.OLDNODE);
	END							! IN RANGE
ELSE
	BEGIN
	SIGNAL (IF .FR_SIZE (.INODE) NEQ .NUM
			THEN PAT$_FRESIZE
			ELSE PAT$_FRERANGE);			! alarm
	END;
END;

GLOBAL ROUTINE PAT$FREEZ (NEED) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	CALLS FREEGET TO ALLOCATE STORAGE, AND CLEARS IT
!
! CALLING SEQUENCE:
!
!	PAT$FREEZ ()
!
! INPUTS:
!
!	LENGTH OF AREA WANTED (IN LONGWORDS)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! OUTPUTS:
!
!	ADDRESS OF AREA
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! SIDE EFFECTS:
!
!	NONE
!--

BEGIN

LOCAL
	P;

IF (P = FREEGET (.NEED)) NEQ 0
THEN ZEROCOR (.P, .NEED);
RETURN .P
END;

GLOBAL ROUTINE PAT$REPORT_FREE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	REPORTS THE NUMBER OF BYTES LEFT IN FREE STORAGE.
!
! CALLING SEQUENCE:
!
!	PAT$REPORT_FREE ()
!
! INPUTS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	THE ELEMENTS OF THE FREE LIST.
!
! OUTPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	THE NUMBER OF BYTES OF STROAGE THAT IS FREE.
!
! SIDE EFFECTS:
!
!	NONE
!--

BEGIN

LOCAL
	COUNT,
	POINTER;

COUNT = 0;

!++
! STEP THROUGH THE FREE LIST.
!--
POINTER = .FR_NEXT (PAT$FREELIST);
WHILE .POINTER NEQ NULL
DO
	BEGIN
	COUNT = .COUNT + .FR_SIZE (.POINTER);
	POINTER = .FR_NEXT (.POINTER);
	END;
RETURN .COUNT * 4
END;

END
ELUDOM
