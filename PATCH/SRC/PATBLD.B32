MODULE PATBLD (	!
		%IF %VARIANT EQL 1
		%THEN
			ADDRESSING_MODE (EXTERNAL = LONG_RELATIVE, NONEXTERNAL = LONG_RELATIVE),
		%FI
		IDENT = 'V03-000'
		) =
BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	PATCH
!
! ABSTRACT:	Initialize and build the Runtime Symbol Table (RST) data structures.
!
!
! ENVIRONMENT:	This module runs on VAX under STARLET, user mode, non-AST level.
!
! Author:	Kevin Pammett, August 12, 1977.
!
!
! Modified by:
!
!	V02-018	PCG0001		Peter George		02-FEB-1981
!		Add require statement for LIB$:PATDEF.REQ
!
!	V0117	CNH0023		Chris Hume		16-Nov-1979	14:00
!		Turn off ISD$V_LASTCLU for all ISD's when PATCH Area is added
!		to an image.  Also unrecognized languages will now be processed
!		as though they were MACRO.
!		([PATCH]PATMAI.B32 02.28, PATSPA.B32 01.05)
!
! MODIFICATIONS:
!
!  NO	DATE		PROGRAMMER		PURPOSE
!  --	----		----------		-------
!
!  00	19-DEC-77	K.D. MORSE		ADAPT VERSION 36 FOR PATCH.
!  01	2-JAN-78	K.D. MORSE		MINOR CHANGES IN
!						CASE THERE IS NO GST.
!  02	4-JAN-78	K.D. MORSE		FIX BUG THAT COMPUTES LENGTH
!						OF TYPED VARIABLE.
!  03	4-JAN-78	K.D. MORSE		PAT$DST_VALUE NOW DISTINGUISHES
!						BETWEEN EVALUATE ERRORS. (37)
!						FIX BUG IN ADD_MODULE BY SETTING
!						THE NT_IS_BOUNDED BIT ONCE THE
!						SYMBOL IS BOUNDED. (38)
!						NO CHANGES FOR VERS 39.
!  04	11-JAN-78	K.D. MORSE		ADD CHECKS FOR BIT FIELDS IN
!						SECOND TYPE BYTE IN DST,
!						(DSTR_ACC01 AND DSTR_ACC23).
!  05	24-JAN-78	K.D. MORSE		NO CHANGES FOR 39-40.
!  06	28-FEB-78	K.D. MORSE		CHANGE BUILD_MC TO IGNORE THE
!						REST OF THE DST IF >50% OF THE
!						RST SPACE HAS BEEN TAKEN UP FOR
!						MC'S ONLY. (41)
!  07	01-MAR-78	K.D. MORSE		NO CHANGES FOR 42-43, PATCH
!						WILL NOT ACCEPT FORTRAN ARRAYS
!						AS INPUT AND SO SHOULD NOT
!						OUTPUT THEM.
!  08	24-MAR-78	K.D. MORSE		NO CHANGES FOR 44-45.
!  09	28-MAR-78	K.D. MORSE		ADD CODE TO ACCEPT ARRAYS AND
!						"PC" RELATIVE DESCRIPTORS.
!  10	07-APR-78	K.D. MORSE		REWORKED GLOBALS SO THAT THEY
!						ARE NOW MAPPED INSTEAD OF IN
!						THE RST.  (46) REMOVED CODE IN
!						ADD_SAT THAT CHECKED IF A
!						SYMBOL WAS PREVIOUSLY THERE (47).
!						MC_GBL_LOCKED IS INITIALIZED (48).
!						NO CHANGES FOR VERS 49
!  11	25-APR-78	K.D. MORSE		CONVERT TO NATIVE COMPILER.
!  12	12-MAY-78	K.D. MORSE		NO CHANGES FOR 50.
!						INIT_MC_GLOBALS NOW SETS THE
!						MC_IN_RST BIT TO FALSE FOR THE
!						SPECIAL GLOBAL MC.  THIS IS
!						NECESSARY BECAUSE THE SAT/LVT
!						ACCESS FUNCTIONS MAY LOOK THERE
!						BUT THERE ARE NO STORAGE
!						DESCRIPTORS. (51)
!  13	18-MAY-78	K.D. MORSE		NO CHANGES FOR VERS 52.
!  14	18-MAY-78	K.D. MORSE		NO CHANGES FOR VERS 53.
!  15	13-JUN-78	K.D. MORSE		ADD FAO COUNTS TO SIGNALS.
!  16	28-JUN-78	K.D. MORSE		CHECK FOR DUPLICATE MODULE NAMES
!						IN PAT$BUILD_MC AND IF FOUND
!						THEN SKIP SECOND ONE THROUGH
!						THE NEXT EOM RECORD. (54)
!						NO CHANGES FOR 55-57.
!
!--

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
	PAT$INIT_RST : NOVALUE,					! Do the RST initialization.
	INIT_MC_GLOBALS : NOVALUE,				! Initialize the MC chain.
	BUILD_MC,						! Build the Module Chain (MC).
	BUILD_RST,						! Initialize the RST so that it
								!  contains a given set of modules.
	OK_TO_ADD,						! Check, initialize, and set up to ADD_MODULE
	PAT$ADD_MODULE,						! Add a module to the RST.
	ADD_NT,							! Add a DST symbol to the RST.
	ADD_SAT,						! Make a SAT entry for a symbol.
	ADD_LVT,						! Make an LVT entry for a symbol.
	PAT$GET_BOUNDS : NOVALUE;				! Calculate the bounds of an array.

!
! INCLUDE FILES:
!

LIBRARY 'SYS$LIBRARY:LIB.L32';
REQUIRE 'SRC$:PATPCT.REQ';					! Define PATCH PSECTS
REQUIRE 'LIB$:PATDEF.REQ';				! Defines literals
REQUIRE 'LIB$:PATMSG.REQ';
REQUIRE 'SRC$:VXSMAC.REQ';
REQUIRE 'SRC$:PATGEN.REQ';
REQUIRE 'SRC$:PATRST.REQ';
REQUIRE 'SRC$:SYSSER.REQ';

!
! MACROS:
!

!
! EQUATED SYMBOLS:
!


!
! EXTERNAL REFERENCES:
!

EXTERNAL
	PAT$GB_SYMBOLS : BYTE,					! Indicator if symbols are in the image
	PAT$GL_RST_BEGN,					! Starting address of RST
	PAT$GL_MC_PTR	: REF MC_RECORD,			! Pointer to the Module Chain (MC).
	PAT$GL_NT_HASH	: REF RST_POINTER;			! Pointer to the name table (NT) hash vector.

EXTERNAL ROUTINE
	PAT$FIND_MODULE,					! Scans module chanin for a module name
	PAT$SORT_SA_LVT : NOVALUE,				! Sort the SAT or LVT
	PAT$VS_INIT : NOVALUE,					! Initialize a vector storage area.
	PAT$VS_GET,						! Allocate records from a so-called
								!  "vector storage" vector.
	PAT$VS_FREE : NOVALUE,					! Release vector storage.
	PAT$VS_SHRINK : NOVALUE,				! Free up unused vector storage.
	PAT$MODULE_SIZE,					! Deduce how much RST space adding
								!   a module will take.
	PAT$DST_VALUE,						! Evaluate a DST
	PAT$SYMBOL_VALU,					! Evaluate a symbol given its NT_PTR.
	PAT$NT_HASH_FCN,					! Hashing function for calculating 
								!   dispersal of NT entries.
	PAT$POSITON_DST,					! Make a certain DST record available
								!   and 'SRC$:position' the DST for GET_NXT_DST.
	PAT$GET_NXT_DST,					! Make the next DST record available.
	PAT$GET_NXT_GST,					! Make the next GST record available.

	PAT$GET_NXT_SAT,					! Sequential access to the SAT.
	PAT$GET_NXT_LVT,					! Sequential access to the LVT.

	!++
	! We use two storage allocators - one when we want to allocate or
	! free up storage we want to address via RST-pointers, and one when
	! we deal with free storage in the same way that the rest
	! of PATCH does.
	!--

	PAT$FREEZ,						! Allocate and zero a block of ordinary storage.
	PAT$RST_FREEZ,						! Allocate and zero RST-pointer storage.
	PAT$REPORT_FREE;					! Report on remaining available RST storage.

!
! OWN STORAGE:
!

!++
! We maintain a pointer to the MC record for the module we are currently
! (de)allocating vector storage for.  This is done simply to avoid passing this
! parameter around.
!--

OWN
	CURRENT_MODULE : REF MC_RECORD;

GLOBAL ROUTINE PAT$INIT_RST : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Do the once-only initialization of PATCH's
!	Runtime Symbol Table (RST) data structures.
!
! FORMAL PARAMETERS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	In general, we expect that error reporting is done at
!	the innermost level.  This means that we simply
!	return bad status codes all the way out, without saying
!	anything.
!
! IMPLICIT OUTPUTS:
!
!	none
!
! COMPLETION CODES:
!
!	NOVALUE - the only thing which can go wrong that we
!		  don't handle is running out of free storage
!		  when we ask for it blindly (i.e. not checking
!		  that there is enough before we ask for it).
!		- This must fail because we only assume that we
!		  have enough storage for the NT hash vector and
!		  a 1-element MC chain.  If there is really
!		  not enough for this, PATCH is surely in trouble.
!		- The storage manager doesn't return control to us
!		  in any case...
!
! SIDE EFFECTS:
!
!	The RST gets initialized.
!
!--

BEGIN

LOCAL
	LIST_ALL,
	PTR	: REF VECTOR[,BYTE];

!++
! Before we can do much we must have the NT hash vector.  It is a fixed size and
! gets allocated once-and-for-all.
!--
PAT$GL_NT_HASH = PAT$FREEZ( RST_UNITS(NT_HASH_SIZE * %SIZE(NT_HASH_RECORD)));

!++
! Add the global symbol definitions to the RST structures, and start off the
! module chain with the 'fake' MC record reserved for globals. This code assumes
! that PAT$GET_NXT_GST has already been set up so that the first time we call
! it the first GST record is returned.  Begin adding MC's to the chain in a
! forward-linked fashion.
!--
INIT_MC_GLOBALS();

!++
! Build the Module Chain, giving up if it doesn't work.  Note that this routine
! only works when the 'next' record, as defined by PAT$GET_NXT_DST, is the first
! record in the DST.  If we really wanted to do some manipulating of the DST
! before building the module chain, we would have to invent a fake REWIND_DST or
! something, or pass BUILD_MC the ID of where to start.  This would mean
! that BUILD_MC would have to 'special-case' the first record instead of
! just calling 'next' for them all.
!--
IF (NOT BUILD_MC())
THEN
	RETURN;

!++
! Build an RST that contains those modules flagged as eligible in the module
! chain. We also pass on the estimate of the number of globals that the RST
! will contain.	
!--
IF (NOT BUILD_RST())
THEN
	RETURN;
		
!++
! Sort the SAT and LVT vectors so that we can access them (later) more efficiently.
!--
PAT$SORT_SA_LVT( PAT$GET_NXT_SAT );
PAT$SORT_SA_LVT( PAT$GET_NXT_LVT );

END;

ROUTINE INIT_MC_GLOBALS : NOVALUE =

!++
! Functional Description:
!
!	This routine initializes the module chain.  It builds the dummy
!	entry which is always the first link in the module chain.  All
!	the global symbols are linked to the dummy module. This routine
!	does that part of RST initialization which MUST
!	work if PATCH is to survive.  
!
! Formal Parameters:
!
!	NONE
!
! Implicit Inputs:
!
!	none.
!
! Routine Value:
!
!	NONE
!
! Side Effects:
!
!	PAT$GL_MC_PTR gets initialized.
!
!--

BEGIN

!++
! Build the single MC record which must always exist. This one does NOT
! correspond to a module, but rather we use it to 'hang' the globals off.  The
! building of this record must go OK - the storage manager doesn't give us
! back control.
!--
PAT$GL_MC_PTR = PAT$RST_FREEZ(RST_UNITS(RST_MC_SIZE));

!++
! Initialize the few fields which this special MC record must have.  We assume
! the rest of the record is 0.  The global MC is never marked 'MC_IN_RST'
! because globals are not really 'in' the RST.
!--
PAT$GL_MC_PTR [MC_IS_GLOBAL] = TRUE;
PAT$GL_MC_PTR [MC_IN_RST] = FALSE;
PAT$GL_MC_PTR [MC_TYPE] = DSC$K_DTYPE_MOD;

!++
! Permanently allocate the storage which 'hangs' off this MC entry.  Since
! the globals now remain in their own data base (the GST), the RST needs only
! one NT and one SAT record for 'cache' use - i.e., we fill them when we
! bring a GST entry into the RST for SYM_TO_VAL, etc.
!--
PAT$GL_MC_PTR[MC_GBL_NT_PTR] = PAT$RST_FREEZ(RST_UNITS(RST_NT_SIZE));
PAT$GL_MC_PTR[MC_GBL_SAT_PTR] = PAT$FREEZ(RST_UNITS(RST_SAT_SIZE));

!++
! Sometimes we do not want the GST consulted in a SYM_TO_VAL, and some
! times we have consulted it and do not want some other call to overwrite the
! two cache GBL/RST records.  For this reason, the following field is turned
! on and off to indicate if the GST is 'locked' or not.
!--
PAT$GL_MC_PTR[MC_GBL_LOCKED] = FALSE;
RETURN;
END;

ROUTINE BUILD_MC =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine builds the Module Chain (MC) directly from the DST.
!	This is part of a once-only PATCH initialization procedure.
!
!	If there is no DST (because none of the module
!	were compiled with /debug symbols on), then this
!	routine simply returns(true) when the first attempt
!	it makes to fetch a DST record returns EOF.
!
! FORMAL PARAMETERS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	-It is assumed that the first call to PAT$GET_NXT_DST
!	that we make will retreive us the first record
!	in the DST.
!
!	-The free-storage manager zeros-out the storage returned.
!	(We therefore don't bother to zero-out 
!	link fields, etc, in newly-obtained MC records).
!
!	-We assume that PAT$GL_MC_PTR has already been set to
!	 point to the 'dummy' global MC record.
!
! IMPLICIT OUTPUTS:
!
!	The MC is built - it contains a host of implications.
!
! ROUTINE VALUE:
!
!	NONE
!
! COMPLETION CODES:
!
!	TRUE, if all goes OK,
!	FALSE, otherwise.
!
! SIDE EFFECTS:
!
!	-The MC is built.
!	-The DST is 'read' straight through to the end unless going any further
!	 would take too much of the RST just for MC's.  In this case, the last
!	 part of the DST is henceforth ignored by PATCH.
!
!--

BEGIN

LOCAL
	SAT_COUNT,						! Count up per-module SAT entries,
	LVT_COUNT,						! Count up per-module LVT entries,
	NT_COUNT,						! Count up per-module NT entries,
	IN_MODULE,						! Flag to say whether we are 'in between'
								!  MODULE_BEGIN - MODULE_END pairs.
	DST_REC_ID,						! Record ID passed back by PAT$GET_NXT_DST.
	CURRENT : REF MC_RECORD,				! Pointer to the MC record we are
								! currently initializing.
	DST_RECRD : REF DST_RECORD;			 	! Pointer to the current record
								! of the DST we are reading.

!++
! Initialize the context flag IN_MODULE, and begin going thru the DST
! sequentially. We assume that someone else, namely PATCH's INIT routine, has
! made sure that the DST is available and that the 'next' record is the first
! one.  The chain starts off with the 'fake' global MC record.  Other MC's are
! added in forward-linked fashion.
!--
CURRENT = .PAT$GL_MC_PTR;
IN_MODULE = FALSE;
WHILE( (DST_RECRD = PAT$GET_NXT_DST( DST_REC_ID )) NEQ 0 )
DO
	BEGIN
	!++
	! Process each record depending on its DST type.
	!--
	CASE .DST_RECRD [DSTR_TYPE] FROM DST_DST_LOWEST TO DST_DST_HIGHEST OF

	    SET

	    [DSC$K_DTYPE_MOD]:					! Module Begin Record.
		BEGIN
		LOCAL
			MOD_NAME_DESC : BLOCK[8,BYTE],
			NEW_PTR : REF MC_RECORD;
		IF (.IN_MODULE)					! Check for misplaced MODULE record.
		THEN
			BEGIN
			$FAO_TT_OUT( 'Module Begin Phase Error.' );
			RETURN(FALSE);
			END;

		!++
		! Now check to see if this module is already in the chain.
		! If found, skip until the next EOM record.
		!--
		MOD_NAME_DESC[DSC$W_LENGTH] = .DST_RECRD[DSTR_NAME];
		MOD_NAME_DESC[DSC$A_POINTER] = DST_RECRD[DSTR_NAME] + 1;
		IF (PAT$FIND_MODULE(MOD_NAME_DESC, FALSE) NEQ 0)
		THEN
			BEGIN
			$FAO_TT_OUT('Duplicate module !AD ignored.',
				.MOD_NAME_DESC[DSC$W_LENGTH],.MOD_NAME_DESC[DSC$A_POINTER]);
			DO
			DST_RECRD = PAT$GET_NXT_DST(DST_REC_ID)
			UNTIL .DST_RECRD[DSTR_TYPE] EQL DSC$K_DTYPE_EOM;
			END
		ELSE
		BEGIN
		!++
		! See if taking the RST space for this new MC record still
		! leaves a reasonable amount for subsequent "SET MODULE"
		! commands, (i.e., 50% of the RST).  If this is not the case,
		! then ignore the rest of the modules and exit from this loop.
		!--
		IF NOT PAT$REPORT_FREE() GTR RST_MODU_SIZE
		THEN
			BEGIN
			!++
			! Report informational message.  This routine must
			! do a normal return and not an UNWIND.
			!--
			SIGNAL(PAT$_LONGDST);
			EXITLOOP;
			END;

		!++
		! Allocate space for the new MC record.
		!--
		IF ((NEW_PTR = PAT$RST_FREEZ(RST_UNITS(RST_MC_SIZE))) EQL 0)
		THEN
			RETURN(FALSE);
		CURRENT [MC_NEXT] = .NEW_PTR;			! Link this one onto the previous one.

		!++
		! Initialize the new 'current' node, and those fields belonging
		! to it that we know the value of at this point. (Some values
		! get initialized only after  we have read the DST for this
		! module).
		!--
		IN_MODULE = TRUE;
		CURRENT = .NEW_PTR;
		SAT_COUNT = 0;
		LVT_COUNT = 0;
		NT_COUNT = 0;
		CURRENT [MC_TYPE] = .DST_RECRD [DSTR_TYPE];
		CURRENT [MC_DST_START] = .DST_REC_ID;
		CURRENT [MC_IS_MAIN] = FALSE;
		CURRENT [MC_IS_GLOBAL] = FALSE;

		!++
		! Encode the language indicator into 3 bits. This only
		! accomodates values 0-7, enough for now.  We may have to
		! enlarge this field later.
		!--
		CURRENT [MC_LANGUAGE] = .DST_RECRD [DSTR_VALUE];

		!++
		! If we want all modules to be IN the RST by default, set the
		! following to TRUE.  Otherwise set it to FALSE, and make the
		! decision as to whether or not we want a module after its
		! DST has been read.  (See DSC$K_DTYPE_EOM, below).
		!--
		CURRENT [MC_IN_RST] = FALSE;

		!++
		! Moving the name could cause problems if we change the data
		! representation.  Note that here we move both the name-size
		! count as well as the name itself.
		!--
		CH$MOVE( .DST_RECRD [DSTR_NAME] + 1,
			DST_RECRD [DSTR_NAME],
			CURRENT [MC_NAME_CS]);
		END;
		END;

	    [DSC$K_DTYPE_EOM]:					! Module End Record.
		BEGIN
		IF (NOT .IN_MODULE)				! Check for misplaced END_MODULE record.
		THEN
			BEGIN
			$FAO_TT_OUT( '!/Module End Phase Error.' );
			RETURN(FALSE);
			END;

		!++
		! Reset the 'in MODULE' context flag, and initialize the
		! settings of all MC flag bits.
		!--
		IN_MODULE = FALSE;

		!++
		! Record the module statistics.
		!--
		CURRENT [MC_STATICS] = .SAT_COUNT;
		CURRENT [MC_LITERALS] = .LVT_COUNT;
		CURRENT [MC_NAMES] = .NT_COUNT;
		END;

	    [DSC$K_DTYPE_RTN,					! Routine DSTs.
	     DSC$K_DTYPE_SLB]:					! Labels in FORTRAN and BLISS.
		BEGIN
		!++
		! Just tally up the needed statistics so that we can build
		! the other data  structures later.
		!--
		NT_COUNT = .NT_COUNT +1;
		SAT_COUNT = .SAT_COUNT +1;
		END;

	    [DSC$K_DTYPE_EOR,					! BLISS-only End-of-Routine.
	     DSC$K_DTYPE_FLD]:					! BLISS-only FIELD records.
		;						! We can safely ignore these for now.

	    [DSC$K_DTYPE_LBL]:					! Label or Literal DSTs. (MARS only)
		BEGIN
		!++
		! This contributes 1 to NT, and another one to either LVT or SAT.
		!--
		NT_COUNT = .NT_COUNT +1;
		IF (.DST_RECRD [DSTR_ACC01] EQL ACCS_VALUEADR)
		THEN
			SAT_COUNT = .SAT_COUNT + 1		! The symbol is an ADDRESS.
		ELSE
			IF (.DST_RECRD [DSTR_ACC01] EQL ACCS_LITERAL)
			THEN
				LVT_COUNT = .LVT_COUNT +1;	! The symbol is a LITERAL.
		END;

	    [DSC$K_DTYPE_PCT]:					! PSECT DSTs.
		BEGIN
		IF (NOT.IN_MODULE )
		THEN
			BEGIN
			$FAO_TT_OUT('!/Misplaced PSECT.');
			RETURN(FALSE);
			END;
		NT_COUNT = .NT_COUNT +1;			! PSECTs also count as a symbol name.
		SAT_COUNT = .SAT_COUNT +1;
		END;
	
	    [INRANGE, OUTRANGE]:
		BEGIN
		!++
		! The only reason for not making the "SRM types"
		! part of the above CASE is because of the huge
		! case table which gets generated otherwise.
		!--
		IF (.DST_RECRD [DSTR_TYPE] EQL DSC$K_DTYPE_Z)
		THEN
			BEGIN
			!++
			! BLISS type ZERO records. Whatever symbol this is,
			! it contributes a name, for sure, and either a literal
			! or a static.  We assume the worst!
			!--
			NT_COUNT = .NT_COUNT +1;
			LVT_COUNT = .LVT_COUNT +1;
			SAT_COUNT= .SAT_COUNT +1;
			END
		ELSE
		IF (.DST_RECRD [DSTR_TYPE] LEQ DST_TYP_HIGHEST)
		THEN
			BEGIN
			!++
			! These types are candidates for the LVT and NT tables only.
			!--
			NT_COUNT = .NT_COUNT +1;
			SAT_COUNT = .SAT_COUNT +1;
			END
		ELSE
			BEGIN
			!++
			! Probably an error in the DST data.
			!--
			END;
		END;
	    TES;
	END;							! Go back and process the next DST record.
!++
! Make sure we didn't run off the end of the DST unexpectedly.  This means that
! we insist that EOM be the last record encountered.
!--
IF (.IN_MODULE)
THEN
	BEGIN
	$FAO_TT_OUT('Premature End-of-DST Encountered.' );
	RETURN(FALSE);
	END;

RETURN( TRUE );							! The chain has been built OK.
END;

ROUTINE BUILD_RST =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Initialize the RST given a module chain.
!
! FORMAL PARAMETERS:
!
!	none.
!
! IMPLICIT INPUTS:
!
!	PAT$GL_MC_PTR	-is assumed to RST-point (in the sense
!			 that an RST-pointer points) to the beginning
!			 of the MC.  This MC is assumed to contain
!			 all necessary information about those
!			 modules marked elegible to be in the RST.
!
! IMPLICIT OUTPUTS:
!
!	There will be at least RST_AVAIL_SIZE bytes of
!	free storage left after this routine finishes.
!
! ROUTINE VALUE:
!
!	none
!
! COMPLETION CODES:
!
!	TRUE, if all went OK, FALSE otherwise.
!
! SIDE EFFECTS:
!
!	A warning message is produced if any of the
!	modules marked MC_IN_RST are not added to
!	the RST.  This happens when we don't have
!	enough space.
!
!--

BEGIN

LOCAL
	NOT_ALL_ADDED,						! A flag to tell if we added all the
								!  modules we wanted to.
	MC_PTR : REF MC_RECORD;					! Pointer to current MC record.

!++
! Initialize the flag that we use to detect when we didn't get to add all
! modules we wanted to.
!--
NOT_ALL_ADDED = FALSE;

!++
! Loop thru the module chain trying to add the indicated modules to the RST.
!  Note that we purposely don't look at the first MC record in the chain because
! is is reserved for globals.
!--
MC_PTR = .PAT$GL_MC_PTR;
WHILE( (MC_PTR = .MC_PTR [MC_NEXT]) NEQ 0 )
DO
	IF (.MC_PTR [MC_IN_RST])
	THEN
		IF (NOT PAT$ADD_MODULE( .MC_PTR ))		! Try to add the module.
		THEN
			BEGIN
			not_all_added = true;
			MC_PTR [MC_IN_RST] = FALSE;
			END;

!++
! Produce a warning message if we didn't add all those we tried to.
!--
IF (.NOT_ALL_ADDED) 
THEN
	SIGNAL(PAT$_NOTALLSYM);

RETURN(TRUE);
END;

GLOBAL ROUTINE PAT$ADD_MODULE( MODULE_TO_ADD ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Add the indicated module to the RST data base.
!
! FORMAL PARAMETERS:
!
!	MODULE_TO_ADD	-An RST-pointer to the MC record for
!			 the module we are to initialize.
!			 This is necessary because this module
!			 is scope-wise 'above' all symbols
!			 declared in the outer block of this module.
!
! IMPLICIT INPUTS:
!
!	none.
!
! IMPLICIT OUTPUTS:
!
!	none
!
! COMPLETION CODES:
!
!	TRUE, if all goes OK, FALSE otherwise.
!
! SIDE EFFECTS:
!
!	The symbols for the indicated module get added to
!	the various RST data structures.
!
!--

BEGIN

LABEL
	ADD_DST_LOOP;						! The overall structure of this routine
								! is one large loop in which we add
								! successive DSTs to the RST.

MAP
	MODULE_TO_ADD : REF MC_RECORD;

LOCAL
	DST_REC_ID,						! ID we are passed back so that we can
								!  later refer to DST records.
	DST_RECRD : REF DST_RECORD,				! Pointer to where a fetched DST record lives.
	NT_PTR : REF NT_RECORD;					! Pointer to NT records we build.

!++ 
! A new module must define a new position from which to start as far as building
! in scope structure is concerned.  To do this we reinitialize the scope stack,
! a stack of RST-pointers, the top one of which points to the NT or MC record
! that corresponds to the symbol (MODULE or ROUTINE) that is scope-wise above
! any symbol currently being added to the RST data base.  The reason why we
! need a stack to keep track of this is simply because BLISS allows nested
! ROUTINE declarations.
!
! Likewise we have to stack SAT pointers to ROUTINE SAT records so that when
! we get the corresponding end-of-routine we can go to the SAT and fix up
! the UB value.
!--
LOCAL
	SCOPE_STACK : VECTOR [MAX_SCOPE_DEPTH +1, %SIZE(RST_POINTER)],
	SAT_RTN_STACK : VECTOR [MAX_SCOPE_DEPTH +1, %SIZE(SAT_POINTER)],
	SCOPE_STACK_PTR,					! Index to current top of scope stack.
	CURENT_LANGUAGE;					! Per-module source code language indicator.

!++
! Make sure that we can go ahead and add the indicated module.  Also peform
! any needed checks and initializations.
!--
IF (NOT OK_TO_ADD(.MODULE_TO_ADD, CURENT_LANGUAGE))
THEN
	RETURN(FALSE);

!++
! Initialize the scope and SAT_RTN stacks.  (See above). Since the top-of-stack
! entry is MODULE, the corresponding entry in the SAT_RTN stack is not used,
! in BLISS, always used, in FORTRAN, and never used, in MARS.  This is because
! BLISS has 'real' scoping, FORTRAN's scope is only 1 level deep, and MARS
! doesn't give us DST entries for end-of-routines.
!--
SCOPE_STACK_PTR = 0;
CH$FILL(0, %ALLOCATION(SAT_RTN_STACK), SAT_RTN_STACK );
CH$FILL(0, %ALLOCATION(SCOPE_STACK), SCOPE_STACK );
SCOPE_STACK[0] = .MODULE_TO_ADD;

!++
! Now process the DST record by record, ending when we encounter a module_end
! record, or when some error occurs.
!--
WHILE( (DST_RECRD = PAT$GET_NXT_DST( DST_REC_ID )) NEQ 0 )
DO
   ADD_DST_LOOP:						! Failure to add a DST => we LEAVE add block.
	BEGIN
	!++
	! We process each record depending on its DST type.
	!--
	CASE .DST_RECRD [DSTR_TYPE] FROM DST_DST_LOWEST TO DST_DST_HIGHEST OF
	    SET

	    [DSC$K_DTYPE_EOM]:					! End module record.
		BEGIN
		!++
		! This is the ONLY successful way this routine can terminate
		! since we insist that a group of DST records end with an End
		! Module record.
		! Modules added OK are not about to be deleted.
		!--
		MODULE_TO_ADD [MC_IS_DYING] = FALSE;

		!++
		! See if we can free up some of the vector storage allocated
		! for this module.  This will be the case when we didn't actually
		! add as many of the NTs, SATs, or LVTs as the MC statictics
		! indicated we might. (Which is almost always the case because
		! the gathering  is not as detailed as it might be).
		!--
		PAT$VS_SHRINK( MODULE_TO_ADD [MC_NT_STORAGE] );
		PAT$VS_SHRINK( MODULE_TO_ADD [MC_SAT_STORAGE] );
		PAT$VS_SHRINK( MODULE_TO_ADD [MC_LVT_STORAGE] );
		RETURN(TRUE);
		END;

	    [DSC$K_DTYPE_RTN]:					! Begin a ROUTINE record.
		BEGIN
		!++
		! In all languages, a routine name is at least a symbol, which
		! must therefore appear in the NT. Add the symbol to the NT.
		!--
		IF ((NT_PTR = ADD_NT(.DST_RECRD, .SCOPE_STACK[.SCOPE_STACK_PTR])
		    ) EQL 0 )
		THEN
			LEAVE ADD_DST_LOOP;

		!++
		! Then, in BLISS, each routine record also  implies that we go
		! one level down as far as scope is concerned.  This is why we
		! maintain the so-called scope stack.
		!--
		IF (.CURENT_LANGUAGE EQL BLISS_MODULE)
		THEN
			BEGIN
			!++
			! Check for scope stack overflow.
			!--
			IF ((SCOPE_STACK_PTR = .SCOPE_STACK_PTR +1) GTR MAX_SCOPE_DEPTH)
			THEN
				BEGIN
				$FAO_TT_OUT('!/PAT$add_module: scope depth overflow');
				RETURN(FALSE);
				END;

			!++
			! Push the new scope level onto the scope stack.
			!--
			SCOPE_STACK [.SCOPE_STACK_PTR] = .NT_PTR;
			END;

		!++
		! Routine symbols also go into the SAT. The catch here is that
		! we don't yet know the length of the routine, so we have to
		! stack a pointer to the SAT record we build so that we can
		! fix up this problem when we do get the info.
		!--
		IF ((SAT_RTN_STACK [.SCOPE_STACK_PTR] = 
			ADD_SAT( .NT_PTR, .DST_RECRD [DSTR_VALUE], 0))
		   EQL 0 )
		THEN
			BEGIN
			!++
			! Don't allow the next end_of_routine record
			! to overwrite something invalid.
			!--
			SAT_RTN_STACK [.SCOPE_STACK_PTR] = 0;
			RETURN(FALSE);
			END;
		END;

	    [DSC$K_DTYPE_EOR]:					! End of (BLISS and FORTRAN) routine.
		BEGIN
		!++
		! This is where we finally get to find out the length that the
		! current routine was.  This info allows us to complete the
		! building of the RST record which corresponds to the routine
		! itself.  If we do not have a valid pointer to this routine's
		! SAT, some logic error has occurred.
		!--
		IF (.SAT_RTN_STACK [.SCOPE_STACK_PTR] NEQ 0)
		THEN
			BEGIN
			LOCAL
				FIXUP_SAT_PTR : REF SAT_RECORD,
				RTN_NT_PTR : REF NT_RECORD;

			!++
			! Pickup a pointer to the SAT record which corresponds
			! the associated  ROUTINE NT record.
			!--
			FIXUP_SAT_PTR = .SAT_RTN_STACK [.SCOPE_STACK_PTR];

			!++
			! The upper bound for this routine is the address at
			! which the code for it ends.  NOTE: we have now
			! 'bounded' the symbol.
			!--
			FIXUP_SAT_PTR [SAT_UB] = .FIXUP_SAT_PTR [SAT_LB] 
				+ .DST_RECRD [DSTR_VALUE] -1;
			RTN_NT_PTR = .FIXUP_SAT_PTR [SAT_NT_PTR];	! ++37
			RTN_NT_PTR [NT_IS_BOUNDED] = TRUE;		! ++37
			SAT_RTN_STACK [.SCOPE_STACK_PTR] = 0;
			END
		ELSE
			BEGIN
			$FAO_TT_OUT('!/rtn end without begin');
			RETURN(FALSE);
			END;

		!++
		! Pop a scope level off of the scope stack.
		!--
		IF (.CURENT_LANGUAGE EQL BLISS_MODULE)
		THEN
			IF ((SCOPE_STACK_PTR = .SCOPE_STACK_PTR -1) LSS 0) ! Check for scope stack underflow.
			THEN
				BEGIN
				$FAO_TT_OUT('!/add_module: scope depth underflow');
				RETURN(FALSE);
				END;
		END;

	    [DSC$K_DTYPE_FLD]:				 ! BLISS fields are ignored.
		BEGIN
		END;

	    [DSC$K_DTYPE_LBL,					! Label or Literal DSTs. (MARS only)
	     DSC$K_DTYPE_SLB]:					! Labels in FORTRAN and BLISS.
		BEGIN
		!++
		! Add the symbol to the NT.
		!--
		IF ((NT_PTR = ADD_NT(.DST_RECRD, .SCOPE_STACK[.SCOPE_STACK_PTR])) EQL 0)
		THEN
			LEAVE ADD_DST_LOOP;

		!++
		! Then, add it to the LVT or SAT, depending
		! on whether the symbol is a literal or not.
		! Here PATCH ignores registers while DEBUG does not.
		! Hence, the more specific check of field DSTR_ACC01.
		!--
		IF ((.DST_RECRD [DSTR_TYPE] EQL DSC$K_DTYPE_SLB) OR
		   (.DST_RECRD [DSTR_ACC01] EQL ACCS_VALUEADR))
		THEN
			BEGIN
			IF (ADD_SAT( .NT_PTR, .DST_RECRD [DSTR_VALUE], 0) EQL 0)
			THEN
				RETURN(FALSE);
			END
		ELSE
			BEGIN
			IF (.DST_RECRD [DSTR_ACC01] EQL ACCS_LITERAL)
			THEN
				IF (NOT ADD_LVT( .NT_PTR, .DST_RECRD [DSTR_VALUE]))
				THEN
					RETURN(FALSE);
			END;
		END;
	    [DSC$K_DTYPE_PCT]:					! P-SECT record.
		BEGIN
		LOCAL
			PSECT_LENGTH : REF VECTOR[,LONG];
		!++
		! Add the symbol to the NT.
		!--
		IF ((NT_PTR = ADD_NT(.DST_RECRD, .SCOPE_STACK[.SCOPE_STACK_PTR])) EQL 0)
		THEN
			LEAVE ADD_DST_LOOP;

		!++
		! The symbols also goes into the SAT. Since we have to pass on
		! the length of the PSECT, we must extract a field which is
		! in a variable position within the DST. This code must be
		! changed if the psect length is not directly after the counted
		! string name.
		!--
		PSECT_LENGTH = DST_RECRD[DSTR_NAME] + .DST_RECRD[DSTR_NAME] +1;
		IF (ADD_SAT( .NT_PTR, .DST_RECRD [DSTR_VALUE],
			.DST_RECRD [DSTR_VALUE] + .PSECT_LENGTH[0] ) EQL 0)
		THEN
			RETURN(FALSE);
		END;

	    [INRANGE, OUTRANGE]:
		BEGIN
		!++
		! This should be a separate CASE, but isn't due simply to the
		! size of the case table.  PATCH handles the following types
		! of symbols:
		!	dsc$k_dtype_v		bit
		!	dsc$k_dtype_bu		byte logical
		!	dsc$k_dtype_wu		word logical
		!	dsc$k_dtype_lu		longword logical
		!	dsc$k_dtype_qu		quadword logical
		!	dsc$k_dtype_b		byte integer
		!	dsc$k_dtype_w		word integer
		!	dsc$k_dtype_l		longword integer
		!	dsc$k_dtype_q		quadword integer
		!	dsc$k_dtype_f		single-precision floating
		!	dsc$k_dtype_d		double-precision floating
		!	dsc$k_dtype_fc		complex
		!	dsc$k_dtype_dc		double-precision complex
		!	dsc$k_dtype_t		ascii text
		!	dsc$k_dtype_nu		numeric string, unsigned
		!	dsc$k_dtype_nl		numeric string, left separate sign
		!	dsc$k_dtype_nlo		numeric string, left overpunched sign
		!	dsc$k_dtype_nr		numeric string, right separate sign
		!	dsc$k_dtype_nro		numeric string, right overpunched sign
		!	dsc$k_dtype_nz		numeric string, zoned sign
		!	dsc$k_dtype_p		packed decimal string
		!	dsc$k_dtype_zi		sequence of instructions
		!	dsc$k_dtype_zem		procedure entry mask
		! PATCH ignores the following types of symbols:
		!	dsc$k_dtype_z		unspecified
		!--
		IF (.DST_RECRD [DSTR_TYPE] GEQ DSC$K_DTYPE_V) AND
		   (.DST_RECRD [DSTR_TYPE] LEQ DST_TYP_HIGHEST)
		THEN
			!++
			! Check that PATCH can handle the symbol.  Discard
			! symbols defined as registers or by descriptors,
			! (bits 2+3 equal to 2 or 3) and symbols whose values
			! are based off registers (bits 0+1 equal to 2 or 3).
			! The remaining symbols (literals or value addresses not
			! based off registers) are now added to the NT and SAT.
			!--	
			IF ((.DST_RECRD[DSTR_ACC01] EQL ACCS_LITERAL) OR
			    (.DST_RECRD[DSTR_ACC01] EQL ACCS_VALUEADR))
			AND
			   ((.DST_RECRD[DSTR_ACC23] EQL ACCS_NOTBASDIR) OR
			    (.DST_RECRD[DSTR_ACC23] EQL ACCS_NOTBASIND))
			THEN
				BEGIN
				!++
				! Most of these symbols should also go into the SAT.
				! The ones that should not are the BLISS type 0
				! symbols which are not static.  PATCH
				! completely ignores all records which are type
				! 0 (unspecified) so there is no test to weed
				! them out here.
				! Processing of SRM data types depends
				! on whether the datum is scalar or not.
				! Only scalars are handled here.
				!--
				LOCAL
					SIZE;
				OWN
				    SRM_LENGTHS : VECTOR[12,BYTE]	! Sizes of SRM type data.
				    INITIAL( BYTE (
					1, !	DSC$K_DTYPE_BU,	Byte logical.
					2, !	DSC$K_DTYPE_WU,	Word logical.
					4, !	DSC$K_DTYPE_LU,	Longword logical.
					8, !	DSC$K_DTYPE_QU,	Quadword logical.
					1, !	DSC$K_DTYPE_B,	Byte integer.
					2, !	DSC$K_DTYPE_W,	Word integer.
					4, !	DSC$K_DTYPE_L,	Longword integer.
					8, !	DSC$K_DTYPE_Q,	Quadword integer.
					4, !	DSC$K_DTYPE_F,  single-precision floating
					8, !	DSC$K_DTYPE_D,  double-precision floating
					8, !	DSC$K_DTYPE_FC, complex
					16 !	DSC$K_DTYPE_DC, double-precision complex
				    ));

				!++
				! The only so-called SRM types which we
				! know the size of are those from
				! DSC$k_DTYPE_BU to _DC, inclusive.
				! We simply pick this size value out 
				! of the above vector.
				!--	
				IF ((NT_PTR = ADD_NT(.DST_RECRD, .SCOPE_STACK[.SCOPE_STACK_PTR])) EQL 0)
				THEN
					LEAVE ADD_DST_LOOP;
				SIZE = .DST_RECRD [DSTR_TYPE];
				IF (.SIZE GEQ DSC$K_DTYPE_BU) AND
				    (.SIZE LEQ DSC$K_DTYPE_DC)
				THEN
					SIZE = .DST_RECRD [DSTR_VALUE] - 1 +
						.SRM_LENGTHS [.SIZE - DSC$K_DTYPE_BU]
				ELSE
					!++
					! Unknown upper-bound addresses
					! must be 0.
					!--	
					SIZE = 0;
	
				!++
				! Add the symbols known to be static to the SAT.
				!--	
				IF (ADD_SAT(.NT_PTR, .DST_RECRD [DSTR_VALUE], .SIZE) EQL 0)
				THEN
					RETURN(FALSE);
				END				! end of TYPES _V THRU _Q
			ELSE
				BEGIN
				!++
				! Array types are more complicated than scalars
				! as there is more involved in calculating the
				! lower and upper address bounds.
				!--
				LOCAL
					DESC_ADDRESS,
					BOUNDS : ARRAY_BNDS_DESC;
				!++
				! Eliminate all dynamic arrays.  Those kept are
				! are described within the DST -- so called
				! "PC" based descriptors which have _BASD = 2
				! and _BREG = 15.
				!--
				IF (.DST_RECRD[DSTR_ACCES_TYPE] EQL ACCS_DESCRIPTOR) AND
				   (.DST_RECRD[DSTR_ACCES_BASD] EQL ACCS_BASDIR) AND
				       (.DST_RECRD[DSTR_ACCES_BREG] EQL 15)
				THEN
					BEGIN
					!++
					! If _BASD and _BREG are both zero, then
					! the descriptor may not be complete.
					! In this case the ADD_NT call fails.
					!--
					IF ((NT_PTR = ADD_NT(.DST_RECRD, .SCOPE_STACK[.SCOPE_STACK_PTR])) EQL 0)
					THEN
						LEAVE ADD_DST_LOOP;
					!++
					! Get the address of the array descriptor and
					! use it to build a 'bounds descriptor'.
					!--
					IF (PAT$DST_VALUE(.DST_RECRD, DESC_ADDRESS) EQL 0)
					THEN
						RETURN(FALSE);		! THIS TYPE NOT HANDLED
					PAT$GET_BOUNDS(.DESC_ADDRESS, BOUNDS);

					!++
					! The beginning of the array plus the number of
					! bytes of elements minus one is the address of
					! the end of the array.
					! Add this symbol to the SAT.
					!--
					IF (ADD_SAT(.NT_PTR, .BOUNDS[ARRAY_ADDRESS],
							.BOUNDS[ARRAY_ADDRESS] + 
							.BOUNDS[ARRAY_LENGTH] -1)
					   EQL 0)
					THEN
						RETURN(FALSE);
					END;			! END OF ARRAYS HANDLED CURRENTLY
				END;				! END OF ARRAYS AND DESCRIPTORS
		END;						! END OF INRANGE,OUTRANGE
	    TES;						! END OF CASE LOOP
	END;							! Go back and process the next record. (ADD_DST_LOOP)

!++
! If the above WHILE exits, then we encountered the end of the DST records
! before we got an END_MODULE record to end the beginning MODULE one.  This is
! considered a fatal error.
!--
$FAO_TT_OUT('!/Premature end of DST in routine ADD_MODULE.');

RETURN(FALSE);
END;

ROUTINE OK_TO_ADD( MODULE_TO_ADD, LANGUAGE_ADDR ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	See if it is OK to add the indicated module to the RST data base.
!	Also perform all necessary initializations so that ADD_MODULE
!	can go ahead an do so.
!
! FORMAL PARAMETERS:
!
!	MODULE_TO_ADD	-An RST-pointer to the MC record for
!			 the module we are to initialize.
!	LANGUAGE_ADDR	-The address of where we should pass
!			 back the module's language.  If this
!			 value = 0, we don't position the DST
!			 or check or pass back the language indicator.
!
! IMPLICIT INPUTS:
!
!	We believe the given MC pointer.  In particular,
!	we will not allocate storage for a module
!	if the corresponding storage descriptor
!	already contains a pointer.  (i.e. is not 0).
!
! IMPLICIT OUTPUTS:
!
!	ADD_MODULE will not fail if it is called after this
!	routine successfully completes.
!
!	The language code may be passed back to the caller.
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	TRUE, if all goes OK, FALSE otherwise.
!
! SIDE EFFECTS:
!
!	Storage for all symbols for this module
!	is allocated so that PAT$VS_GET can then
!	simply dole it out.
!
!	The DST is 'positioned' so that PAT$GET_NXT_DST
!	will be able to sequentially read the DST starting
!	at the first record in the DST after the DST record
!	for the indicated module.
!
!--

BEGIN

MAP
	LANGUAGE_ADDR : REF VECTOR,
	MODULE_TO_ADD : REF MC_RECORD;

LOCAL
	DST_RECRD : REF DST_RECORD,				! Pointer to where a fetched DST record lives.
	BEGIN_DST_AT,						! ID of DST record where the DST for
								!  the module we are to add begins.
	DST_REC_ID,						! ID we are passed back so that we can
								!  later refer to DST records.
	CURENT_LANGUAGE,					! Per-module source code language indicator.
	NT_PTR : REF NT_RECORD,					! Pointer to NT records we build.
	STORAGE_DESC : REF VECT_STORE_DESC;			! We use the MC-contained descriptor of
								! vector storage for all indicated symbols.

!++
! Make sure that we have enough space to add this module before we begin.  This
! is necessary because it would be very difficult to 'back out' once we began,
! and we wouldn't like to have modules half initialized.
!--
IF (NOT (PAT$REPORT_FREE() - PAT$MODULE_SIZE(.MODULE_TO_ADD)) GTR RST_AVAIL_SIZE)
THEN
	!++
	! We don't try to handle this one here because what is appropriate
	! depends on when (why) the module was being initialized.
	!--
	RETURN(FALSE);

!++
! Before allocating space for NT symbols, make sure that there will be some.
!  It makes no sense for a module to be added which has no name symbols.
!--
IF (.MODULE_TO_ADD [MC_NAMES] EQL 0)
THEN
	RETURN(FALSE);
!++
! See if NT storage has already been allocated.  To do this, pick up the vector
! storage descriptor for the  indicated NT records and see that it points to 0.
!--
STORAGE_DESC = MODULE_TO_ADD [MC_NT_STORAGE];
IF (.STORAGE_DESC [STOR_BEGIN_RST] NEQ 0)
THEN
	RETURN(FALSE);

!++
! If we are going to allocate stroage for any SATs or LVTs, again check that
! none is already allocated.
!--
IF (.MODULE_TO_ADD [MC_STATICS] NEQ 0)
THEN
	BEGIN
	STORAGE_DESC = MODULE_TO_ADD [MC_SAT_STORAGE];
	IF (.STORAGE_DESC [STOR_BEGIN_RST] NEQ 0)
	THEN
		RETURN(FALSE);
	END;
IF (.MODULE_TO_ADD [MC_LITERALS] NEQ 0)
THEN
	BEGIN
	STORAGE_DESC = MODULE_TO_ADD [MC_LVT_STORAGE];
	IF (.STORAGE_DESC [STOR_BEGIN_RST] NEQ 0)
	THEN
		RETURN(FALSE);
	END;

!++
! At this point there is more to do only if the given MC pointer is to the
! 'global' MC record.  This is  because there is no DST checking or language
! verification for the global MC case.
!--
IF (.LANGUAGE_ADDR NEQ 0)
THEN
	BEGIN
	!++
	! Processing for all DST-originated modules.
	!
	! First, pick up the supposed DST record ID of where the DST for this
	! module begins.	
	!--
	BEGIN_DST_AT = .MODULE_TO_ADD [MC_DST_START];
	
	!++
	! Position the DST to the indicated record, and
	! make sure that it is of type MODULE.
	!--	
	IF ((DST_RECRD = PAT$POSITON_DST( .BEGIN_DST_AT )) EQL 0)
	THEN
		BEGIN
		!++	
		! The supposed record does not exist.
		!--	
		RETURN(FALSE);
		END
	ELSE
		!++
		! The record is reachable.  Make sure it is MODULE.
		!--	
		IF (.DST_RECRD [DSTR_TYPE] NEQ DSC$K_DTYPE_MOD)
		THEN
			BEGIN
			$FAO_TT_OUT('!/DST MODULE misplaced.');
			RETURN(FALSE);
			END;
	
	!++
	! Record type is OK.  Check that we know which source language the
	! module was written in.  If it's not BLISS or FORTRAN then treat it
	! as though it were MACRO.
	!--	
	IF ((CURENT_LANGUAGE = .DST_RECRD[DSTR_VALUE]) NEQ BLISS_MODULE) AND
	   (.CURENT_LANGUAGE NEQ FORTRAN_MODULE)
	THEN
		CURENT_LANGUAGE = MARS_MODULE ;

	!++
	! Pass back the language code in which this module is written.  This is
	! needed because the caller of this routine doesn't get to look at the
	! DST record for this module.
	!--	
	LANGUAGE_ADDR[0] = .CURENT_LANGUAGE;
	END;

!++
! Now that nothing can go wrong, go ahead and allocate all
! NT, and possibly all SAT and/or all LVT storage.
!--
PAT$VS_INIT(	MODULE_TO_ADD [MC_NT_STORAGE],
			.MODULE_TO_ADD [MC_NAMES],
			RST_NT_SIZE
		      );

!++
! NT storage is accessed via RST-pointers.
!--
MODULE_TO_ADD [MC_NT_STORAGE] = FALSE;

!++
! Likewise for SAT and LVT storage.  Only here we don't mind if no storage will
! be needed.
!--
IF (.MODULE_TO_ADD [MC_STATICS] NEQ 0)
THEN
	BEGIN
	PAT$VS_INIT(	MODULE_TO_ADD [MC_SAT_STORAGE],
			.MODULE_TO_ADD [MC_STATICS],
			RST_SAT_SIZE
		      );

	!++
	! SAT storage is not accessed via RST-pointers.
	!--
	MODULE_TO_ADD [MC_SAT_STORAGE] = TRUE;
	END;
IF (.MODULE_TO_ADD [MC_LITERALS] NEQ 0)
THEN
	BEGIN
	PAT$VS_INIT(	MODULE_TO_ADD [MC_LVT_STORAGE],
			.MODULE_TO_ADD [MC_LITERALS],
			RST_LVT_SIZE
		      );

	!++
	! LVT storage is not accessed via RST-pointers.
	!--
	MODULE_TO_ADD [MC_LVT_STORAGE] = TRUE;
	END;

!++
! Set the OWN variable which various other routines in this module work from,
! to indicate which module we are currently building.  This is the only place
! where this variable gets set.
!--
CURRENT_MODULE = .MODULE_TO_ADD;

!++
! Looks like we're OK to go ahead and try to! add the indicated module.  This is
! the only place in this routine where we return TRUE status.
!--
RETURN(TRUE);
END;

ROUTINE ADD_NT( DST_RECRD, UP_SCOPE ) =

!++
! Functional Description:
!
!	Add a symbol to the name table (NT).
!
! Formal Parameters:
!	DST_RECRD	-a pointer to the DST record that corresponds
!			 to the symbol being added.
!	UP_SCOPE	-an RST-pointer to the NT or MC record that
!			 corresponds to the symbol that is scope-wise
!			 above the symbol we are to add.
!
! Implicit Inputs:
!
!	The OWN, CURRENT_MODULE, has been set up to
!	indicate the MC pointer to the module we are
!	currently adding.
!
!	We call PAT$DST_VALUE with a DST_RECRD pointer - NOT a
!	so-called DST_REC_ID.  This works, for now, because these
!	two concepts are still the same.  If/when this is no longer
!	true, we must change it and all calls to it so that only one
!	way of specifying a DST record is used.
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!	FALSE, if some real error occurs,
!	an NT_PTR to where we did add or find it, otherwise.
!
! Side Effects:
!
!	The NT gets updated to reflect the addition of the new
!	symbol if 1) PAT$DST_VALUE knows how to evaluate the
!	given DST, and 2) We have not already built an NT
!	record for this symbol (because it also came in as a GSD).
!--

BEGIN

LABEL
	NEXT_DUP_LOOP;

MAP
	UP_SCOPE : REF MC_RECORD,				! This is an example of a case where we would be
								! in trouble if pointers into the MC were not the
								! same as those into the NT because here we
								! don't yet know to which structure UP_SCOPE points.
	DST_RECRD : REF DST_RECORD;				! Pointer to the given DST record
								! which we use only for 'standard' DST
								! structures.

LOCAL
	LOOKUP_STATUS,						! SUCCESS CODE FROM PAT$DST_VALUE
	NT_HASH : REF NT_RECORD,				! Hash index used to access NT chains.
	NEW_NT_PTR : REF NT_RECORD,				! Pointer to NT record where the new
								! symbol gets inserted.
	NT_PTR : REF NT_RECORD,					! NT pointer used to scan along chains.
	DST_NAME_CS : CS_POINTER,				! Pointer to where the symbol name CS
								! is in the DST record.
	SYMBL_VALUE;						! The value of the symbol we are to add.

!++
! There is no point in adding an NT record for a symbol
! we can't evaluate.
!--
IF ((LOOKUP_STATUS =  PAT$DST_VALUE( .DST_RECRD, SYMBL_VALUE)) EQL 0)	! ++038
THEN
	BEGIN
	RETURN(FALSE);
	END;

!++
! The only difference in building an NT record from either of the three classes
! of DST records we distinguish, (type zero, SRM types, and 'the rest'),
! is the calculation of where in the record the name counted string is found.
!
! This code relies on the fact that the TYPE fields are in the same place in
! the three types of DST records.
!--
DST_NAME_CS = DST_RECRD [DSTR_NAME];

!++
! Add the symbol to the name table.  Now we simply determine whether to add it
! onto the end of an existing hash chain, or whether to begin a new one.
!--
NT_HASH = PAT$NT_HASH_FCN( .DST_NAME_CS );
IF ((NT_PTR = .PAT$GL_NT_HASH [.NT_HASH]) NEQ 0)
THEN
	BEGIN
	!++
	! There are already some symbols that hash to this same value.  This
	! means that we simply link the new  record onto the end of this chain.
	!--	
	WHILE( .NT_PTR [NT_FORWARD] NEQ 0 )
	DO
		!++
		! Skip along to the end of the chain.
		!--	
		NT_PTR = .NT_PTR [NT_FORWARD];
	END
ELSE
	BEGIN
	!++
	! To build a new chain, we only need to know where in the hash vector
	! to link it on. Make this hash-vector address look like a pointer
	! to an NT record so that we can fill in NT_FORWARD below thereby filling
	! in the hash vector.
	!--
	NT_PTR = PAT$GL_NT_HASH [.NT_HASH] - .PAT$GL_RST_BEGN;
	END;

!++
! Allocate space for the new NT record and fill in the fixed fields.  This must
! go without hitch or we give up.  Note that the NT record we build is the same
! no matter what type of DST record we build it from.
!--
IF ((NEW_NT_PTR = PAT$VS_GET( CURRENT_MODULE [MC_NT_STORAGE], RST_NT_OVERHEAD + .DST_NAME_CS[0]))
   EQL 0 )
THEN
	!++
	! We ran out of space.  This should never happen because we supposedly
	! knew how much vector storage to allocate before we began adding any NTs.
	!--
	RETURN(FALSE);

NEW_NT_PTR [NT_UP_SCOPE] = .UP_SCOPE;
NEW_NT_PTR [NT_DST_PTR] = .DST_RECRD;
NEW_NT_PTR [NT_TYPE] = .DST_RECRD [DSTR_TYPE];

!++
! Moving the name could cause problems if we change the data representation.
!  Note that here we move both the name-size count as well as the name itself.
!--
CH$MOVE( .DST_NAME_CS[0] +1, .DST_NAME_CS, NEW_NT_PTR [NT_NAME_CS] );

!++
! Add this new NT record to the name table by connecting up the hash-chain links.
!  The new record points back to a previous NT record, OR, it points
! back to the hash vector itself.  In either case there  is no NT record FORWARD
! of the new record.
!--
NEW_NT_PTR [NT_BACKWARD] = .NT_PTR;
NEW_NT_PTR [NT_FORWARD] = 0;

!++
! The following writes into the NT_FORWARD field of a previous NT record, OR,
! it writes the first chain-pointer into the hash chain itself.  This
! is why NT_FORWARD has to be the first field of the NT_FIELD_SET.
!--
NT_PTR [NT_FORWARD] = .NEW_NT_PTR;

!++
! All went ok so we return an RST-pointer to where this symbol got added.
!--
RETURN(.NEW_NT_PTR);
END;

ROUTINE ADD_SAT( NT_PTR, LOWER, UPPER ) =

!++
! Functional Description:
!
!	Build the SAT record to correspond to an NT record.
!
! Formal Parameters:
!	NT_PTR		-An RST-pointer to the NT record for this symbol.
!	LOWER		-The lower-bound value which is bound to 
!			 this symbol.
!	UPPER		-The upper-bound value which is bound to 
!			 this symbol.
!
! Implicit Inputs:
!
!	Symbols marked NT_IS_GLOBAL have already been added
!	to the SAT so we don't do it again.  We do update
!	SAT information therein, though, once we have found
!	out where we added it the last time.
!
!	The OWN, CURRENT_MODULE, has been set up to
!	indicate the MC pointer to the module we are
!	currently adding.  Storage allocation works
!	from the vector storage descriptors stored therein.
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!	0, if the SAT record was not built,
!	a SAT-pointer to where it was build, otherwise.
!
! Side Effects:
!
!	The SAT gets updated to reflect the addition of the new
!	symbol.
!
!	The NT bit, NT_IS_BOUNDED is set to TRUE or FALSE,
!	depending on whether the given UPPER_BOUND is 0 or not.
!--

BEGIN

MAP
	NT_PTR : REF NT_RECORD;

LOCAL
	SAT_PTR : REF SAT_RECORD;

SAT_PTR = 0;

!++
! Ask for space for the fixed-size record. This should not fail because
! we supposedly knew how much space we wanted and allocated it all
! before we got here.
!--
IF ((SAT_PTR = PAT$VS_GET(CURRENT_MODULE [MC_SAT_STORAGE], RST_SAT_SIZE)) EQL 0)
THEN
	BEGIN
	$FAO_TT_OUT('!/sat overflow');				! Don't allow the SAT to overflow.
	RETURN(FALSE);
	END;

!++
! Otherwise go ahead and fill in the new record or update the old one.
!--
SAT_PTR [SAT_LB] = .LOWER;
SAT_PTR [SAT_UB] = .UPPER;
SAT_PTR [SAT_NT_PTR] = .NT_PTR;

!++
! Mark all NTs _BOUNDED or not depending on whether the (new) upper bound is 0
! or not.
!--
IF (.UPPER NEQ 0)
THEN
	NT_PTR [NT_IS_BOUNDED] = TRUE;

!++
! Return a pointer to where the SAT record was built.  Usually this is only
! tested for non-zero, PAT$ADD_MODULE keeps a stack of SAT record pointers
! for ROUTINEs, though, so it can go back and put in the UB value since we
! don't get that until end-of-routine.
!--
RETURN(.SAT_PTR);
END;

ROUTINE ADD_LVT( NT_PTR, LVT_VAL ) =

!++
! Functional Description:
!
!	Build the LVT record to correspond to the 
!	symbol we have just built the indicated NT
!	record for.
!
! Formal Parameters:
!
!	NT_PTR		-An RST-pointer to the NT record for this symbol.
!	LVT_VAL		-The literal value which is bound to 
!			 this symbol.
!
! Implicit Inputs:
!
!	The OWN, CURRENT_MODULE, has been set up to
!	indicate the MC pointer to the module we are
!	currently adding.  Storage allocation works
!	from the vector storage descriptors stored therein.
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!	TRUE, if all goes OK,
!	FALSE, otherwise.
!
! Side Effects:
!
!	The LVT gets updated to reflect the addition of the new
!	symbol.
!--

BEGIN

MAP
	NT_PTR : REF NT_RECORD;

LOCAL
	LVT_PTR : REF LVT_RECORD;

!++
! Ask for space for the fixed-size record. This should not fail because we
! supposedly knew how much space we wanted and allocated it all before
! we got here.
!--
IF ((LVT_PTR =	PAT$VS_GET(CURRENT_MODULE[MC_LVT_STORAGE], RST_LVT_SIZE))
   EQL 0 )
THEN
	BEGIN
	$FAO_TT_OUT('!/lvt overflow');				! Don't allow the LVT to overflow.
	RETURN(FALSE);
	END;

!++
! Otherwise go ahead and fill in the new record.
!--
LVT_PTR [LVT_VALUE] = .LVT_VAL;
LVT_PTR [LVT_NT_PTR] = .NT_PTR;

RETURN(TRUE);
END;

GLOBAL ROUTINE PAT$GET_BOUNDS( DESCRIP_BLOCK, BOUNDS_DESC ) : NOVALUE =

!++
! Functional Description:
!
!	Deduce the virtual address of the beginning, and the length (in bytes),
!	of the indicated array.  i.e. Given the SRM-defined 'array descriptor',
!	produce the corresponding PATCH/RST-defined 'array bounds descriptor'.
!	The latter is defined in PATRST.REQ
!
! Formal Parameters:
!
!	DESCRIP_BLOCK	-address of SRM array descriptor
!	BOUNDS_DESC	-address of the ARRAY_BNDS_DESC we are
!			 to 'fill in'.
!
! Implicit Inputs:
!
!	The SRM-defined notion of 'array descriptor'.
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!	NOVALUE
!
! Side Effects:
!
!	BOUNDS_DESC is an output parameter.  (see above)
!--

BEGIN

MAP
	DESCRIP_BLOCK : REF BLOCK [,BYTE],
	BOUNDS_DESC : REF ARRAY_BNDS_DESC;

LOCAL
	SPAN_BLOCK : REF VECTOR,
	NUM_ARRAY_ELEMS;

!++
! Check that this is a valid array descriptor.  PATCH handles FORTRAN'S
! _CLASS_A (general array) and _CLASS_S (type CHARACTER).
!--
IF (.DESCRIP_BLOCK [DSC$B_CLASS] EQL DSC$K_CLASS_A)
THEN
	BEGIN
	!++
	! General array descriptors.  Check consistency and return if
	! something is wrong.
	!--
	IF ((NOT .DESCRIP_BLOCK [DSC$V_FL_COLUMN]) OR
	    (NOT .DESCRIP_BLOCK [DSC$V_FL_COEFF]) OR
	    (NOT .DESCRIP_BLOCK [DSC$V_FL_BOUNDS]) OR
	    (.DESCRIP_BLOCK [DSC$B_DIMCT] LEQ 0))
	THEN
		BEGIN
		SIGNAL( PAT$_INVARRDSC );
		RETURN;
		END;

	!++
	! Calculate the required values for general arrays.  The length of the
	! array is simply tallied up by multiplying the total number of elements
	! by each element size.  The total number of elements is the product of
	! the number of elements in each dimension.
	!--
	SPAN_BLOCK = DESCRIP_BLOCK [DSC$L_M1];
	NUM_ARRAY_ELEMS = .SPAN_BLOCK[0];
	INCR COUNT FROM 1 TO (.DESCRIP_BLOCK [DSC$B_DIMCT] -1 )
	DO
		NUM_ARRAY_ELEMS = .NUM_ARRAY_ELEMS * .SPAN_BLOCK[.COUNT];

	!++
	! Calculate the length of the array, in bytes, and return this information.
	!--
	BOUNDS_DESC [ARRAY_LENGTH] = .NUM_ARRAY_ELEMS * .DESCRIP_BLOCK [DSC$W_LENGTH];

	!++
	! End of special processing for _CLASS_A.
	!--
	END
ELSE
	IF (.DESCRIP_BLOCK[DSC$B_CLASS] EQL DSC$K_CLASS_S)
	THEN
		BEGIN
		!++
		! Class S is for static strings.  Return the needed information.
		!--
		BOUNDS_DESC[ARRAY_LENGTH] = .DESCRIP_BLOCK[DSC$W_LENGTH];
		END
	ELSE
		BEGIN
		!++
		! No other classes currently supported.
		!--
		SIGNAL(PAT$_INVARRDSC);
		RETURN;
		END;

!++
! Return the required information common to all types.  Currently, this is
! only the address where the data begins.
!--
BOUNDS_DESC [ARRAY_ADDRESS] = .DESCRIP_BLOCK [DSC$A_POINTER];

END;

END				!End of module
ELUDOM
