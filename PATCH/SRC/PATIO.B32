MODULE PATIO (%IF %VARIANT EQL 1				! I/O ROUTINES FOR PATCH
		%THEN
			ADDRESSING_MODE (EXTERNAL = LONG_RELATIVE,
					 NONEXTERNAL = LONG_RELATIVE),
		%FI
		IDENT = 'V03-000'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY: PATCH
!
! ABSTRACT: THESE ROUTINES HANDLE THE I/O AND CLOSE ALL FILES.
!
! ENVIRONMENT: IT IS PART OF THE IMAGE FILE PATCH UTILTIY.
!
! AUTHOR: K.D. MORSE	, CREATION DATE: 3-OCT-77
!
! MODIFIED BY:
!
!	V02-008	MTR0001		Mike Rhodes		14-Oct-1981
!		Modify routine PAT$CLOSEFILES to not worry about trying
!		to delete virtual addresses that are mapped to the input
!		image file, since these are deleted during image rundown.
!
!	V02-007	PCG0001		Peter George		02-FEB-1981
!		Add require statement for LIB$:PATDEF.REQ
!
! MODIFICATIONS:
!
!  NO	DATE		PROGRAMMER		PURPOSE
!  --	----		----------		-------
!
!  01	14-FEB-78	K.D. MORSE		ADD ROUTINES PAT$WRITE_EXP1,
!						PAT$WRITE_NAME, AND PAT$WRITE_INS.
!  02	7-MAR-78	K.D. MORSE		ADD ROUTINE PAT$OUT_PAL_EXP AND
!						CALLS TO IT.
!  03	25-APR-78	K.D. MORSE		CONVERT TO NATIVE COMPILER.
!  04	05-MAY-78	K.D. MORSE		ADD CALL TO PAT$REDUCE_INS.
!  05	13-JUN-78	K.D. MORSE		ADD FAO COUNTS TO SIGNALS.
!  06	15-JUN-78	K.D. MORSE		ADD OUTPUT TO APPENDED PATCH
!						COMMAND TEXT BUFFERS.
!
!--

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
	PAT$WRITEFILE : NOVALUE,				! OUTPUTS TO A FILE
	PAT$WRITE_EXP1 : NOVALUE,				! WRITES EXPRESSIONS TO COMMAND FILE
	PAT$WRITE_NAME : NOVALUE,				! WRITES NAMES TO COMMAND FILE
	PAT$WRITE_INS : NOVALUE,				! WRITES COMMANDS WITH INSTRUCTIONS TO COMMAND FILE
	PAT$OUT_PAL_EXP : NOVALUE,				! OUTPUTS PATCH AREA ADDRESSES AS NAME+OFFSET
	PAT$CLOSEFILES : NOVALUE;				! CLOSES ALL PATCH FILES OPEN

!
! INCLUDE FILES:
!

LIBRARY 'SYS$LIBRARY:LIB.L32';
REQUIRE 'SRC$:VXSMAC.REQ';
REQUIRE 'SRC$:PATPCT.REQ';					! DEFINE PSECTS
REQUIRE 'SRC$:PREFIX.REQ';					! UTILITY MACROS
REQUIRE 'SRC$:PATPRE.REQ';					! COMMAND LINE LITERALS
REQUIRE 'LIB$:PATDEF.REQ';				! Defines literals
REQUIRE 'LIB$:PATMSG.REQ';					! PATCH ERROR MESSAGE CODES
REQUIRE 'SRC$:SYSLIT.REQ';					! DEFINE OUTPUT BUFFER SIZE
REQUIRE 'SRC$:PATTER.REQ';					! PATCH COMMAND TOKENS
REQUIRE 'SRC$:PATGEN.REQ';					! DEFINE CONTEXT AND MODE BITS
REQUIRE 'SRC$:PATRST.REQ';					! DEFINE MODULE CHAIN OFFSETS
REQUIRE 'SRC$:BSTRUC.REQ';					! STRUCTURE DEFINITIONS
REQUIRE 'SRC$:LISTEL.REQ';					! DEFINE ARGUMENT LIST OFFSETS
REQUIRE 'SRC$:DLLNAM.REQ';					! DEFINE SYMBOLIC NAME STRUCTURES

!
! MACROS:
!

!
! EQUATED SYMBOLS:
!

!
! OWN STORAGE:
!

!
! EXTERNAL REFERENCES:
!

EXTERNAL ROUTINE
	PAT$FIND_VAL,						! Searches user-defined symbols for closest value
	PAT$FAO_PUT,						! FORMATS AN OUTPUT LINE
	PAT$FREEZ,						! Allocates free storage and zeroes it
	PAT$REDUCE_INS : NOVALUE;				! REDUCES EXPRESSIONS AND SYMBOLS INSIDE INSTRUCTIONS

EXTERNAL
	PAT$GL_SYMTBPTR,					! Pointer to current symbol table
	PAT$GL_SYMHEAD,						! Pointer to listhead entry of user-defined symbol table
	PAT$GL_PAL_LHD,						! POINTER TO PATCH AREA LIST (PAL)
	PAT$GL_LAST_LOC,					! LAST LOCATION EXAMINED
	PAT$GL_CONTEXT : BITVECTOR,				! CONTEXT BITS FOR COMMAND
	PAT$GL_SEMAN1 : VECTOR,					! PARSE STACK
	PAT$CP_OUT_STR,						! POINTER TO OUTPUT STRING
	PAT$GL_BUF_SIZ,						! SIZE OF TEXT IN OUTPUT BUFFER
	PAT$GB_MOD_PTR : REF VECTOR[,BYTE],
	PAT$GL_HEAD_LST,					! POINTER TO ARGUMENT LIST FOR COMMAND
	PAT$GL_COMRAB,						! RAB FOR COMMAND FILE
			! POINTER TO MODE LEVEL
	PAT$GL_ISVADDR : VECTOR [,LONG],			! VIRTUAL ADDRESSES OF LAST IMAGE SECTION MAPPED
	PAT$GL_EXPANDVA,					! FIRST EXPREG ADDRESS
	PAT$GL_ERRCODE,						! ERROR CODE
	PAT$GL_FLAGS,						! CLI FLAGS
	PAT$GL_OLDNBK : BLOCK[,BYTE],				! INPUT IMAGE FILE FAB
	PAT$GL_NEWNBK : BLOCK[,BYTE],				! OUTPUT IMAGE FILE FAB
	PAT$GL_JNLNBK : BLOCK[,BYTE],				! JOURNAL FILE FAB
	PAT$GL_COMNBK : BLOCK[,BYTE],				! OUTPUT COMMAND FILE FAB
	PAT$GL_INPFAB : BLOCK[,BYTE],				! INPUT COMMAND CHANNEL FAB
	PAT$GL_OUTFAB : BLOCK[,BYTE],				! INFORMATION CHANNEL FAB
	PAT$GL_ERRFAB : BLOCK[,BYTE],				! ERROR CHANNEL FAB
	PAT$GL_OLDFAB : BLOCK[,BYTE],				! INPUT IMAGE FILE NBK
	PAT$GL_NEWFAB : BLOCK[,BYTE],				! OUTPUT IMAGE FILE NBK
	PAT$GL_JNLFAB : BLOCK[,BYTE],				! JOURNAL FILE NBK
	PAT$GL_COMFAB : BLOCK[,BYTE],				! OUTPUT COMMAND FILE NBK
	PAT$GB_OLDNAME,						! OLD IMAGE FILE NAME
	PAT$GB_NEWNAME,						! NEW IMAGE FILE NAME
	PAT$GB_JNLNAME,						! JOURNAL FILE NAME
	PAT$GB_COMNAME,						! OUTPUT COMMAND FILE NAME
	PAT$GL_TXTLHD : REF BLOCK[,BYTE],			! Pointer to first text buffer
	PAT$GL_TXTTAIL : REF BLOCK[,BYTE],			! Pointer to last text buffer
	PAT$GL_TXTFREE : REF VECTOR[,BYTE];			! Pointer to next free byte in last text buffer

!++
! FAO CONTROL STRINGS
!--
BIND
	ASC_STG = UPLIT BYTE (%ASCIC '''!AD'''),		! FOR ASCII MODE
	COM_HYP_STG = UPLIT BYTE (%ASCIC ',-'),			! CONTINUATION FOR EXAMINE COMMANDS
	EXP_STG = UPLIT BYTE (%ASCIC '^X!XL'),			! FOR NUMERICAL EXPRESSIONS
	RAN_STG = UPLIT BYTE (%ASCIC '^X!XL:^X!XL'),		! FOR NUMERICAL EXPRESSIONS
	NAM_OFF_STG = UPLIT BYTE (%ASCIC '!AD+^X!XL'),		! FOR SYMBOLIC NAME + OFFSET
	NAM_OFF_RAN_STG = UPLIT BYTE (%ASCIC '!AD+^X!XL:!AD+^X!XL'),	! FOR SYMBOLIC NAME + OFFSET RANGES
	INS_STG = UPLIT BYTE (%ASCIC '''!AD'''),		! FOR SYMBOLIC INSTRUCTIONS
	MOD_STG = UPLIT BYTE (%ASCIC '!AC'),			! FOR MODULE NAMES
	NAM_STG = UPLIT BYTE (%ASCIC '!AS'),			! FOR NAMES

!++
! COMMAND STRING FOR EXIT.
!--
	EXIT_CMD = UPLIT BYTE (%ASCIC 'EXIT') : VECTOR[,BYTE];	! EXIT COMMAND STRING

GLOBAL ROUTINE PAT$WRITEFILE (MSGSIZ,MSGADR,WRTRAB) :NOVALUE =	! WRITES FORMATTED MSG TO FILE

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine outputs formatted messages to files.  If the file is the
!	output command file, then the output is also written into the appended
!	patch command text buffers and only written to the command file if one
!	is open for output.  In case of error, an appropriate message is SIGNALed.
!
! FORMAL PARAMETERS:
!
!	MSGSIZ - SIZE IN BYTES OF THE MESSAGE TO BE OUTPUT
!	MSGADR - ADDRESS OF THE MESSAGE TO BE OUTPUT
!	WRTRAB - RAB OF THE FILE MESSAGE IS TO OUTPUT TO
!
! IMPLICIT INPUTS:
!
!	MESSAGE IS ALREADY FORMATTED, FILE IS ALREADY OPEN, AND
!	CHANNEL IS ALREADY CONNECTED.
!	PAT$GL_TXTFREE - Pointer to next free byte in last text block
!	PAT$GL_TXTLHD -  Pointer to first block of command text
!	PAT$GL_TXTTAIL - Pointer to last block of command text
!
! IMPLICIT OUTPUTS:
!
!	THE MESSAGE IS WRITTEN TO THE FILE.  IN CASE OF ERROR, AN
!	ERROR MESSAGE IS WRITTEN TO THE JOURNAL FILE AND 'SYS$ERROR'.
!
! ROUTINE VALUE:
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

BEGIN

MAP
	WRTRAB : REF BLOCK [,BYTE];					! DEFINE AS VECTOR OF BYTES

LOCAL
	FAB_ADDR : REF BLOCK[,BYTE],				! ADDRESS OF FAB
	NAM_BLK_ADDR : REF BLOCK[,BYTE];			! ADDRESS OF NAME BLOCK

!++
! First check if this write is going to the command file.  If so, add it
! to the text buffer.  Text buffers are allocated one block at a time.
! The first longword of the block points the next block of text, zero indicates
! no next block.  The commands are written into the buffer as ASCIC strings.
! They do NOT cross block boundaries.
!--
IF (.WRTRAB EQL PAT$GL_COMRAB)
THEN
	BEGIN
	IF (.PAT$GL_TXTFREE+.MSGSIZ+1 GTRU .PAT$GL_TXTTAIL+A_PAGE)
	THEN
		BEGIN
		!++
		! Allocate a new block of command text and update pointers.
		!--
		PAT$GL_TXTFREE = PAT$FREEZ((A_PAGE + 3)/4);
		PAT$GL_TXTTAIL[TXT$L_NXTBLK] = .PAT$GL_TXTFREE;
		PAT$GL_TXTTAIL = .PAT$GL_TXTFREE;
		PAT$GL_TXTFREE = .PAT$GL_TXTFREE + TXT$C_SIZE;
		END;
	CH$MOVE(.MSGSIZ, .MSGADR, CH$PTR(.PAT$GL_TXTFREE, 1));
	PAT$GL_TXTFREE[0] = .MSGSIZ;
	PAT$GL_TXTFREE = CH$PTR(.PAT$GL_TXTFREE, .MSGSIZ+1);
	IF (.PAT$GL_FLAGS AND PAT$M_COMMAND) EQL 0
	THEN
		RETURN;
	END;

!++
! SET UP THE RAB FOR OUTPUT.
!--
WRTRAB[RAB$W_RSZ]=.MSGSIZ;					! SET SIZE OF MSG
WRTRAB[RAB$L_RBF]=.MSGADR;					! SET MESSAGE ADDRESS
PAT$GL_ERRCODE = $PUT(RAB=.WRTRAB);				! OUTPUT MESSAGE
IF NOT .PAT$GL_ERRCODE		 				! IF ERROR,
THEN								! OUTPUT AN
	BEGIN
	FAB_ADDR=.WRTRAB[RAB$L_FAB];				! GET ADDRESS OF FAB
	NAM_BLK_ADDR=.FAB_ADDR[FAB$L_NAM];			! GET ADDRESS OF NAME BLOCK
	SIGNAL(PAT$_PUTERR,3,.PAT$GL_ERRCODE,.NAM_BLK_ADDR[NAM$B_RSL],.NAM_BLK_ADDR[NAM$L_RSA]);	! APPROPRIATE MESSAGE
	END;
END;								! END OF PAT$WRITEFILE

GLOBAL ROUTINE PAT$WRITE_EXP1 (SEMSP) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE WRITES OUT A SERIES OF EXPRESSIONS TO THE COMMAND FILE.
!	THE EXPRESSIONS ARE TAKEN FROM THE COMMAND ARGUMENT LIST.  IF THE
!	CURRENT MODE IS ASCII, THEN THE ARGUMENTS ARE WRITTEN AS ASCII
!	CHARACTERS WITHIN QUOTES.  ONE EXPRESSION IS WRITTEN PER LINE.
!
!	IF THE COMMAND IS THE "EXAMINE" COMMAND, THEN THE EXPRESSIONS MUST
!	BE FOLLOWED BY A CONTINUATION CHARACTER AS THE "EXAMINE" COMMAND
!	DOES NOT PROMPT.
!
! FORMAL PARAMETERS:
!
!	SEMSP - PARSE STACK OFFSET TO COMMAND VERB TOKEN
!
! IMPLICIT INPUTS:
!
!	THE ARGUMENT LIST FOR THE COMMAND POINTED TO BY PAT$GL_HEAD_LST.
!
! IMPLICIT OUTPUTS:
!
!	THE EXPRESSION IS WRITTEN TO THE COMMAND FILE.  IN CASE OF ERROR, AN
!	ERROR MESSAGE IS WRITTEN TO THE JOURNAL FILE AND 'SYS$ERROR'.
!
! ROUTINE VALUE:
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	PAT$CP_OUT_STR AND PAT$GL_BUF_SIZ ARE DESTROYED.
!
!--

BEGIN

LITERAL
	HYPHEN = %X'2D';					! CONTINUATION CHARACTER (HYPHEN)

LOCAL
	OUTPUT_BUFFER : BLOCK[TTY_OUT_WIDTH,BYTE],		! OUTPUT BUFFER
	POINTER;						! POINTER TO CURRENT ARGUMENT

!++
! INITIALIZE THE POINTER TO THE FIRST ARGUMENT.
!--
POINTER = .PAT$GL_HEAD_LST;
IF (.PAT$GL_SEMAN1[.SEMSP] EQL EXAMINE_TOKEN) AND
   (.POINTER EQLA 0)
THEN
	BEGIN
	PAT$GL_BUF_SIZ = 0;
	PAT$CP_OUT_STR = CH$PTR(OUTPUT_BUFFER, 0);
	PAT$OUT_PAL_EXP(.PAT$GL_LAST_LOC, 0);
	PAT$WRITEFILE(.PAT$GL_BUF_SIZ, OUTPUT_BUFFER, PAT$GL_COMRAB);
	END;

!++
! LOOP, WRITING OUT EACH EXPRESSION.  IF THE CURRENT MODE IS ASCII, WRITE
! THE EXPRESSION AS AN ASCII STRING CONTAINED WITHIN QUOTES.
!--
WHILE .POINTER NEQA 0
DO
	BEGIN
	PAT$GL_BUF_SIZ = 0;
	PAT$CP_OUT_STR = CH$PTR(OUTPUT_BUFFER, 0);
	IF .PAT$GB_MOD_PTR[MODE_ASCII]
	THEN
		PAT$FAO_PUT(ASC_STG, .PAT$GB_MOD_PTR[MODE_LENGTH],
				LIST_ELEM_EXP1(.POINTER))
	ELSE
		IF (.LIST_ELEM_EXP2(.POINTER) EQL 0) OR
		   (.LIST_ELEM_EXP1(.POINTER) EQL .LIST_ELEM_EXP2(.POINTER))
		THEN
			PAT$OUT_PAL_EXP(.LIST_ELEM_EXP1(.POINTER), 0)
		ELSE
			PAT$OUT_PAL_EXP(.LIST_ELEM_EXP1(.POINTER),
					.LIST_ELEM_EXP2(.POINTER));
	IF (.PAT$GL_SEMAN1[.SEMSP] EQL EXAMINE_TOKEN) AND
	   (.LIST_ELEM_FLINK(.POINTER) NEQA 0)
	THEN
		PAT$FAO_PUT(COM_HYP_STG);
	PAT$WRITEFILE(.PAT$GL_BUF_SIZ, OUTPUT_BUFFER, PAT$GL_COMRAB);
	POINTER = .LIST_ELEM_FLINK(.POINTER);
	END;
RETURN;

END;								! END OF PAT$WRITE_EXP1

GLOBAL ROUTINE PAT$WRITE_NAME (SEMSP) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE WRITES OUT A SERIES OF NAMES TO THE COMMAND FILE.
!	THE NAMES ARE TAKEN FROM THE COMMAND ARGUMENT LIST.  ONE NAME IS
!	WRITTEN PER LINE.
!
! FORMAL PARAMETERS:
!
!	SEMSP - OFFSET TO VERB TOKEN ON PARSE STACK
!
! IMPLICIT INPUTS:
!
!	THE COMMAND ARGUMENT LIST POINTED TO BY PAT$GL_HEAD_LST.
!
! IMPLICIT OUTPUTS:
!
!	THE NAME IS WRITTEN TO THE COMMAND FILE.  IN CASE OF ERROR, AN
!	ERROR MESSAGE IS WRITTEN TO THE JOURNAL FILE AND 'SYS$ERROR'.
!
! ROUTINE VALUE:
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	PAT$CP_OUT_STR AND PAT$GL_BUF_SIZ ARE DESTROYED.
!
!--

BEGIN

LOCAL
	MC_PTR : REF MC_RECORD,					! POINTER TO MODULE CHAIN ENTRY
	OUTPUT_BUFFER : VECTOR[TTY_OUT_WIDTH,BYTE],		! OUTPUT BUFFER
	POINTER;						! POINTER TO CURRENT NAME

!++
! INITIALIZE THE POINTER TO THE FIRST ARGUMENT.
!--
POINTER = .PAT$GL_HEAD_LST;

!++
! LOOP, WRITING OUT EACH EXPRESSION.  IF THE CURRENT MODE IS ASCII, WRITE
! THE EXPRESSION AS AN ASCII STRING CONTAINED WITHIN QUOTES.
!--
WHILE .POINTER NEQA 0
DO
	BEGIN
	PAT$GL_BUF_SIZ = 0;
	PAT$CP_OUT_STR = CH$PTR(OUTPUT_BUFFER, 0);
	IF .PAT$GL_CONTEXT[MODULE_BIT]
	THEN
		BEGIN
		MC_PTR = .LIST_ELEM_EXP1(.POINTER);
		PAT$FAO_PUT(MOD_STG, MC_PTR[MC_NAME_CS]);
		END
	ELSE
		PAT$FAO_PUT(NAM_STG, .LIST_ELEM_EXP1(.POINTER));
	PAT$WRITEFILE(.PAT$GL_BUF_SIZ, OUTPUT_BUFFER, PAT$GL_COMRAB);
	IF .PAT$GL_SEMAN1[.SEMSP] EQL DEFINE_TOKEN
	THEN
		BEGIN
		PAT$GL_BUF_SIZ = 0;
		PAT$CP_OUT_STR = CH$PTR(OUTPUT_BUFFER, 0);
		PAT$OUT_PAL_EXP(.LIST_ELEM_EXP2(.POINTER), 0);
		PAT$WRITEFILE(.PAT$GL_BUF_SIZ, OUTPUT_BUFFER, PAT$GL_COMRAB);
		END;
	POINTER = .LIST_ELEM_FLINK(.POINTER);
	END;
RETURN;

END;								! END OF PAT$WRITE_NAME

GLOBAL ROUTINE PAT$WRITE_INS (SEMSP) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE WRITES OUT THE ARGUMENTS TO THE COMMAND FILE FOR THE
!	FOLLOWING COMMAND VERBS, "DEPOSIT", "INSERT", "REPLACE", AND
!	"VERIFY".  THE ARGUMENTS CONSIST OF AN ADDRESS, FOLLOWED BY ONE OR TWO
!	LISTS OF INSTRUCTIONS (DEPENDING UPON THE COMMAND).
!	THE INSTRUCTIONS ARE TAKEN FROM THE COMMAND ARGUMENT LIST.
!	ONE INSTRUCTION IS WRITTEN PER LINE.
!
! FORMAL PARAMETERS:
!
!	SEMSP - OFFSET ONTO PARSE STACK FOR COMMAND VERB TOKEN
!
! IMPLICIT INPUTS:
!
!	THE COMMAND ARGUMENT LIST POINTED TO BY PAT$GL_HEAD_LST.
!	THE PARSE STACK, PAT$GL_SEMAN1, HOLDS THE COMMAND VERB.
!
! IMPLICIT OUTPUTS:
!
!	THE COMMAND ARGUMENTS ARE WRITTEN TO THE COMMAND FILE.  IN CASE OF
!	ERROR, AN ERROR MESSAGE IS WRITTEN TO THE JOURNAL FILE AND 'SYS$ERROR'.
!
! ROUTINE VALUE:
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	PAT$CP_OUT_STR AND PAT$GL_BUF_SIZ ARE DESTROYED.
!
!--

BEGIN

LOCAL
	EDITED_INS_DESC : BLOCK[12,BYTE],			! DESCRIPTOR FOR EDITED INSTRUCTIONS
	EDITED_INS_BUF : VECTOR[TTY_OUT_WIDTH,BYTE],		! BUFFER FOR EDITED INSTRUCTION
	OUTPUT_BUFFER : VECTOR[TTY_OUT_WIDTH,BYTE],		! OUTPUT BUFFER
	POINTER;						! POINTER TO CURRENT NAME

!++
! INITIALIZE THE POINTER TO THE FIRST ARGUMENT.
!--
POINTER = .PAT$GL_HEAD_LST;

!++
! FIRST WRITE OUT THE LOCATION ADDRESS.  THIS IS ALWAYS THE FIRST ARGUMENT.
!--
PAT$GL_BUF_SIZ = 0;
PAT$CP_OUT_STR = CH$PTR(OUTPUT_BUFFER, 0);
PAT$OUT_PAL_EXP(.LIST_ELEM_EXP1(.POINTER), 0);
PAT$WRITEFILE(.PAT$GL_BUF_SIZ, OUTPUT_BUFFER, PAT$GL_COMRAB);

!++
! NOW LOOP, WRITING OUT EACH ARGUMENT.
!--
WHILE (POINTER = .LIST_ELEM_FLINK(.POINTER)) NEQA 0
DO
	BEGIN
	PAT$GL_BUF_SIZ = 0;
	PAT$CP_OUT_STR = CH$PTR(OUTPUT_BUFFER, 0);
	IF .PAT$GB_MOD_PTR[MODE_INSTRUC]
	THEN
		BEGIN
		EDITED_INS_DESC[DSC$W_LENGTH] = 0;
		EDITED_INS_DESC[DSC$A_POINTER] = EDITED_INS_BUF;
		EDITED_INS_DESC[DSC$W_MAXLEN] = TTY_OUT_WIDTH;
		PAT$REDUCE_INS(.LIST_ELEM_EXP1(.POINTER), EDITED_INS_DESC);
		PAT$GL_BUF_SIZ = 0;
		PAT$CP_OUT_STR = CH$PTR(OUTPUT_BUFFER, 0);
		PAT$FAO_PUT(INS_STG, .EDITED_INS_DESC[DSC$W_LENGTH], EDITED_INS_BUF);
		END
	ELSE
		IF .PAT$GB_MOD_PTR[MODE_ASCII]
		THEN
			PAT$FAO_PUT(ASC_STG, .PAT$GB_MOD_PTR[MODE_LENGTH],
					LIST_ELEM_EXP1(.POINTER))
		ELSE
			PAT$OUT_PAL_EXP(.LIST_ELEM_EXP1(.POINTER), 0);
	PAT$WRITEFILE(.PAT$GL_BUF_SIZ, OUTPUT_BUFFER, PAT$GL_COMRAB);
	IF .PAT$GL_SEMAN1[.SEMSP] EQL REPLACE_TOKEN
	THEN
		IF .LIST_ELEM_EXP2(.POINTER) EQL EXIT_TOKEN
		THEN
			PAT$WRITEFILE(.EXIT_CMD[0], EXIT_CMD[1], PAT$GL_COMRAB);
	END;
RETURN;

END;								! END OF PAT$WRITE_INS

GLOBAL ROUTINE PAT$OUT_PAL_EXP (EXPR1, EXPR2) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE FORMATS EXPRESSIONS FOR OUTPUT TO THE COMMAND FILE.
!	IF AN EXPRESSION FALLS WITHIN A PATCH AREA, THEN THE EXPRESSION
!	MUST BE WRITTEN AS A SYMBOLIC NAME PLUS OFFSET.  OTHERWISE IT MAY
!	BE WRITTEN AS AN ABSOLUTE VALUE.  THE PATCH AREA LIST (PAL) IS
!	SEARCHED TO DETERMINE IF THE EXPRESSION FALLS WITHIN A PATCH AREA.
!
!	IF AN EXPRESSION RANGE IS PROVIDED AS INPUT (I.E., EXPR2 IS NOT 0),
!	THEN THE UPPER LIMIT OF THE RANGE IS TREATED IN THE SAME MANNER AS
!	THE LOWER LIMIT WAS TREATED.
!
! FORMAL PARAMETERS:
!
!	EXPR1 - EXPRESSION TO OUTPUT (IF EXPR2 NEQ 0, THEN LOWER LIMIT OF RANGE)
!	EXPR2 - IF NEQ 0, THEN LOWER LIMIT OF RANGE
!		IF EQL 0, THEN INDICATES SINGLE EXPRESSION NOT RANGE
!
! IMPLICIT INPUTS:
!
!	THE PATCH AREA LIST (PAL).
!	THE USER DEFINED SYMBOL TABLE.
!	PAT$GL_BUF_SIZ AND PAT$CP_OUT_STR MUST BE INITIALIZED.
!
! IMPLICIT OUTPUTS:
!
!	THE EXPRESSION IS WRITTEN INTO THE OUTPUT BUFFER SPECIFIED BY
!	PAT$GL_BUF_SIZ AND PAT$CP_OUT_STR.
!
! ROUTINE VALUE:
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	PAT$CP_OUT_STR AND PAT$GL_BUF_SIZ ARE UPDATED TO INCLUDE THE EXPRESSION.
!
!--

BEGIN

LOCAL
	TEMP_PTR : REF BLOCK[,BYTE],				! POINTER TO CURRENT PAL ENTRY
	SYM_PTR;						! POINTER TO SYMBOL TABLE ENTRY

!++
! INITIALIZE THE POINTER TO THE FIRST PATCH AREA IN THE LIST.
!--
TEMP_PTR = .PAT$GL_PAL_LHD;

!++
! SEARCH THE PATCH AREA LIST FOR A PATCH AREA WHICH INCLUDES THE EXPRESSION.
! IF FOUND, THEN SEARCH THE SYMBOL TABLE FOR A CORRESPONDING SYMBOLIC NAME.
! IF THE EXPRESSION IS NOT WITHIN A PATCH AREA, THEN OUTPUT IT AS AN ABSOLUTE
! VALUE.  OTHERWISE, OUTPUT IT AS A SYMBOLIC NAME PLUS OFFSET.
!--
IF (.EXPR1 NEQ 0)						! PREVENT NULL PATCH AREA ADDRESS REPLACING ZERO VALUES
THEN
	BEGIN
	WHILE .TEMP_PTR NEQA 0
	DO
		BEGIN
		IF (.EXPR1 LEQU .TEMP_PTR[PAL$L_END_ADR]) AND
		   (.EXPR1 GEQU .TEMP_PTR[PAL$L_START_ADR])
		THEN
			BEGIN
			PAT$GL_SYMTBPTR = .PAT$GL_SYMHEAD;
			SYM_PTR = PAT$FIND_VAL(.EXPR1, FALSE);
			IF .EXPR2 EQL 0
			THEN
				PAT$FAO_PUT(NAM_OFF_STG,
					.SYM_CHCOUNT(.SYM_PTR), SYM_NAME(.SYM_PTR),
					(.EXPR1-.SYM_VALUE(.SYM_PTR)))
			ELSE
				PAT$FAO_PUT(NAM_OFF_RAN_STG,
					.SYM_CHCOUNT(.SYM_PTR), SYM_NAME(.SYM_PTR),
					(.EXPR1-.SYM_VALUE(.SYM_PTR)),
					.SYM_CHCOUNT(.SYM_PTR), SYM_NAME(.SYM_PTR),
					(.EXPR2-.SYM_VALUE(.SYM_PTR)));
			RETURN;
			END;
		TEMP_PTR = .TEMP_PTR[PAL$L_FLINK];
		END;
	END;

!++
! EXPRESSION DID NOT FALL WITHIN A PATCH AREA.  THEREFORE, OUTPUT IT AS
! AN ABSOLUTE VALUE.
!--
IF .EXPR2 EQL 0
THEN
	PAT$FAO_PUT(EXP_STG, .EXPR1)
ELSE
	PAT$FAO_PUT(RAN_STG, .EXPR1, .EXPR2);

RETURN;

END;								! END OF PAT$OUT_PAL_EXP

GLOBAL ROUTINE PAT$CLOSEFILES : NOVALUE =	! CLOSE ALL OPEN FILES

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE CLOSES ALL THE OPEN FILES BEING USED BY PATCH.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	ALL FABS AND RABS MUST HAVE BEEN INITIALIZED.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	ALL FILES ARE CLOSED.
!	IF ERRORS OCCUR, APPROPRIATE ERROR MESSAGES ARE OUTPUT TO THE
!	JOURNAL FILE AND 'SYS$ERROR'.
!
!--

BEGIN

LITERAL
	START_OFF = 0,						! START VIR ADDR OFFSET
	END_OFF = 1;						! END VIR ADDR OFFSET

!++
! CLOSE OUTPUT COMMAND FILE, IF IT WAS OPEN.
!--
IF (.PAT$GL_FLAGS AND PAT$M_COMMAND) NEQ 0			! IF /COMMAND WAS SPECIFIED
THEN
	BEGIN
	PAT$GL_ERRCODE = $CLOSE(FAB=PAT$GL_COMFAB);		! CLOSE COMMAND FILE
	IF NOT .PAT$GL_ERRCODE
	THEN
		SIGNAL(PAT$_CLSERR,3,.PAT$GL_ERRCODE,.PAT$GL_COMNBK[NAM$B_RSL],
			PAT$GB_COMNAME);			! REPORT CLOSE FAILURE
	END;

!++
! CLOSE JOURNAL FILE, IF OPEN.
!--
IF (.PAT$GL_FLAGS AND PAT$M_JOURNAL) NEQ 0			! IF JOURNAL IS OPEN
THEN
	BEGIN
	PAT$GL_ERRCODE = $CLOSE(FAB=PAT$GL_JNLFAB);		! CLOSE JOURNAL FILE
	IF NOT .PAT$GL_ERRCODE
	THEN
		SIGNAL(PAT$_CLSERR,3,.PAT$GL_ERRCODE,.PAT$GL_JNLNBK[NAM$B_RSL],
			PAT$GB_JNLNAME);			! REPORT CLOSE FAILURE
	END;

!++
! CLOSE INPUT IMAGE FILE, IF OPEN.  
!--
IF (.PAT$GL_FLAGS AND PAT$M_INPUT) NEQ 0			! IF INPUT IMAGE FILE IS OPEN
THEN
	BEGIN
	PAT$GL_ERRCODE = $CLOSE(FAB=PAT$GL_OLDFAB);		! CLOSE INPUT IMAGE FILE
	IF NOT .PAT$GL_ERRCODE
	THEN
		SIGNAL(PAT$_CLSERR,3,.PAT$GL_ERRCODE,.PAT$GL_OLDNBK[NAM$B_RSL],
			PAT$GB_OLDNAME);			! REPORT CLOSE FAILURE
	END;

!++
! CLOSE OUTPUT IMAGE FILE, IF OPEN.
!--
IF (.PAT$GL_FLAGS AND PAT$M_OUTPUT) NEQ 0			! IF OUTPUT IMAGE FILE IS OPEN
THEN
	BEGIN
	PAT$GL_ERRCODE = $CLOSE(FAB=PAT$GL_NEWFAB);		! CLOSE OUTPUT IMAGE FILE
	IF NOT .PAT$GL_ERRCODE
	THEN
		SIGNAL(PAT$_CLSERR,3,.PAT$GL_ERRCODE,.PAT$GL_NEWNBK[NAM$B_RSL],
			PAT$GB_NEWNAME);			! REPORT CLOSE FAILURE
	END;

!++
! CLOSE OTHER MESSAGE CHANNELS.
--!
$CLOSE(FAB=PAT$GL_INPFAB);					! CLOSE INPUT COMMAND FILE
$CLOSE(FAB=PAT$GL_OUTFAB);					! CLOSE OUTPUT INFORMATION FILE
$CLOSE(FAB=PAT$GL_ERRFAB);					! CLOSE ERROR FILE

END;								! END OF PAT$CLOSEFILES

END								! END OF PATIO
ELUDOM
