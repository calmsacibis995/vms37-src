MODULE PATRST (
		%IF %VARIANT EQL 1
		%THEN
			ADDRESSING_MODE (EXTERNAL = LONG_RELATIVE, NONEXTERNAL = LONG_RELATIVE),
		%FI
		IDENT = 'V03-000'
		) =
BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	PATCH
!
! ABSTRACT:	Use the Runtime Symbol Table (RST) data structures.
!
!
! ENVIRONMENT:	This module runs on VAX under VAX/VMS, user mode, non-AST level.
!
! Author:	Kevin Pammett, August 18, 1977.
!
! Version:  V02-014
!
! MODIFIED BY:
!
!	V02-014	PCG0001		Peter George		02-FEB-1981
!		Add require statement for LIB$:PATDEF.REQ
!
! MODIFICATIONS:
!
!  NO	DATE		PROGRAMMER		PURPOSE
!  --	----		----------		-------
!
!  00	21-DEC-77	K.D. MORSE		ADAPT VERSION 30 FOR PATCH.
!  01	4-JAN-78	K.D. MORSE		MAKE PAT$DST_VALUE DISTINGUISH
!						BETWEEN WHAT IT CAN'T EVALUATE
!						BECAUSE OF ERROR AND BECAUSE THE
!						GIVEN CONTEXT (REGISTER SET) IS
!						INAPPROPRIATE. (31)
!  02	24-JAN-78	K.D. MORSE		NO CHANGES FOR 32.
!  03	02-MAR-78	K.D. MORSE		NO CHANGES FOR 33.
!  04	24-MAR-78	K.D. MORSE		NO CHANGES FOR 34.
!  05	28-MAR-78	K.D. MORSE		PAT$DST_VALUE NOW ACCEPTS
!						DESCRIPTORS WHOSE _ACCESS
!						FIELD = 2 FOR THE PC;  THESE
!						ARE FIXED-POSITION DESCS. (35)
!  06	30-MAR-78	K.D. MORSE		ADD RETURN STATUS CODE OF 3
!						TO INDICATE ARRAY DESCRIPTORS
!						FROM PAT$SYM_TO_VALU AND
!						PAT$SYMBOL_VALU.  THIS IS SO
!						THAT PAT$SYM_TO_VAL CAN
!						ALWAYS RETURN THE ADDRESS BOUND
!						TO A SYMBOL.
!  07	06-APR-78	K.D. MORSE		LOOKUP_SYM NOW HANDLES SPECIAL
!						EFFORT IN FINDING GLOBALS. (36)
!						ROUTINES LOOKUP_GBL AND
!						GBL_VAL_TO_SAT ADDED. (36)
!						NEW MC_GBL FIELD 'LOCKED'.  IT 
!						MEANS THAT THE LOOKUP RTNS ARE
!						NOT TO CONSULT THE GST. (37)
!						NO MORE ACCS_DESCRIPTOR'S THAT
!						POINT TO DESCRIPTORS IN THE USER'S
!						IMAGE FROM FORTRAN. (38)
!  08	25-APR-78	K.D. MORSE		CONVERT TO NATIVE COMPILER.
!  09	17-MAY-78	K.D. MORSE		NO CHANGES FOR VERS 39-40.
!  10	18-MAY-78	K.D. MORSE		NO CHANGES FOR VERS 41.
!  11	13-JUN-78	K.D. MORSE		ADD FAO COUNTS TO SIGNALS.
!  12	15-JUN-78	K.D. MORSE		PAT$SYM_TO_VALU RETURNS 0 OR 2
!						FOR FAILURE. CHANGE CHECK IN
!						PAT$SYM_TO_VAL TO TEST FOR LOW BIT.
!  13	28-JUN-78	K.D. MORSE		NO CHANGES FOR VERS 42-43.
!
!--

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
	PAT$ADD_NT_T_PV,					! Build a pathanme vector by 
								! following an NT scope chain.
	PAT$LOOKUP_SYM,						! Find all occurrences of a given
								! symbol in the RST data base.
	LOOKUP_GBL,						! Find all occurrences of a given
								! global symbol in the GST.
	GBL_VAL_TO_SAT,						! Translate VALUE to a global symbol.
	PAT$GET_NXT_DUP,					! Scan along hash chains.
	PAT$SYM_TO_VAL,						! LOOK UP A FULLY QUALIFIED SYMBOL.
	PAT$SYM_TO_VALU,					! Return more info than sym_to_val,
								! but otherwise do the same thing.
	CONCAT_PATHS : NOVALUE,					! Concatenate two pathname vectors together.
	PAT$NT_HASH_FCN,					! Hashing function for calculating
								! dispersal of NT entries.
	PATH_MATCH,						! Match a pathname to the implied
								! path associated with an NT record.
	PAT$VAL_TO_SYM,						! Translate values to PATCH-time symbols.
	LOOKUP_LVT,						! Search the LVT.
	VAL_TO_SAT,						! Search the SAT.
	PAT$SYMBOL_VALU,					! Associate symbols with corresponding values.
	PAT$DST_VALUE,						! Deduce the value associated with a DST
	STD_SYM_EVAL;						! Evaluate dynamic symbols which use
								! a standard encoding for how to do
								! this evaluation.

!
! INCLUDE FILES:
!

LIBRARY 'SYS$LIBRARY:LIB.L32';
REQUIRE 'SRC$:PATPCT.REQ';
REQUIRE 'SRC$:SYSSER.REQ';
REQUIRE 'SRC$:VXSMAC.REQ';
REQUIRE 'SRC$:PATGEN.REQ';
REQUIRE 'SRC$:PATRST.REQ';
REQUIRE 'LIB$:PATDEF.REQ';				! Defines literals
REQUIRE 'LIB$:PATMSG.REQ';

!
! MACROS:
!

!
! EQUATED SYMBOLS:
!


!
! OWN STORAGE:
!

!
! EXTERNAL REFERENCES:
!

EXTERNAL
	PAT$GL_MC_PTR	: REF MC_RECORD,			! Pointer to the Module Chain (MC).
	PAT$GL_NT_HASH	: REF RST_POINTER,			! Pointer to the name table (NT) hash vector.
	PAT$GB_MOD_PTR : REF VECTOR[,BYTE],
	PAT$GL_CSP_PTR : REF PATHNAME_VECTOR;

EXTERNAL ROUTINE
	PAT$GET_NXT_SAT,					! Provide access to the SAT
	PAT$GET_NXT_LVT,					! Provide access to the LVT
	PAT$GET_NXT_GST,					! Scan the global symbol table.
	PAT$GET_DST_REC,					! Make a certain DST record available.
	PAT$MAP_ADDR;						! Map program address


GLOBAL ROUTINE PAT$ADD_NT_T_PV( NT_PTR, PV_PTR ) =

!++
! Functional Description:
!
!	Recur down thru an NT scope chain to build a pathname vector to
!	correspond to the pathname implied by the scope chain.
!
! Formal Parameters:
!
!  NT_PTR	-a pointer to the NT record where
!		 the symbol name is contained.  This is where the
!		 so-called 'scope chain' begins, if you consider such
!		 a pathname to go right to left.
!  PV_PTR	-a pointer to somewhere in the pathname vector we are
!		 building.  Specifically, this points to where we should
!		 store a pointer to the first part (MODULE)
!		 of the pathname.
!
! Implicit Inputs:
!
!	NT scope chains end either when the NT type is MODULE, or when the
!	UP_SCOPE pointer is 0.  (The latter is what we do for NT records which
!	come in to PATCH as global of DEFine symbols).
!
!	Scope chains, as built by simply chaining thru NT records,
!	are 'reverse pathnames', as defined by PATHNAME_VECTOR.  This
!	is why this routine is recursive - we must recur down to
!	the end of the NT chain before we can begin returning
!	and filling in the pathname vector.
!
! Implicit Outputs:
!
!	None.
!
! Return Value:
!
!	The address (supposedly within the pathname vector)
!	of where the next cs_pointer should be stored.
!
! Side Effects:
!
!	This routine will blow up if the NT chain implies a
!	pathname that is longer than is expected by the
!	PATHNAME_VECTOR declaration.
!
!--
BEGIN

MAP
	NT_PTR : REF NT_RECORD,
	PV_PTR : REF PATHNAME_VECTOR;

!++
! There's not much we can do till we've reached the end of the NT scope chain.
!--
IF (.NT_PTR[NT_TYPE] NEQ DSC$K_DTYPE_MOD) AND (.NT_PTR[NT_UP_SCOPE] NEQ 0) 
THEN
	PV_PTR = PAT$ADD_NT_T_PV( .NT_PTR[NT_UP_SCOPE], .PV_PTR );

!++
! The recursive call has modified our idea of where in the pathvector we
! should put the name pointer of the current pathname element.  Once MODULE has
! been reached, though, backing up (and out) is straightforward.
!--
PV_PTR[0] = NT_PTR[NT_NAME_CS];

!++
! The next element's CS pointer goes in the next higher pathname vector element.
! Since we do not recur on the last time around (i.e. after the last ROUTINE
! name was inserted), and since we must guarantee to end the pathname vector
! with a 0 cs pointer, we zero each potential 'next' entry here to ensure this.
! This is the point where damage will be done if/when someone gives a pathname
! that is too long, since the recursion does not 'count' how many times it fills
! in a PATHNAME_VECTOR entry.
!--
PV_PTR[1] = 0;
RETURN( PV_PTR[1] );
END;

GLOBAL ROUTINE PAT$LOOKUP_SYM( SYM_CS ) =

!++
! Functional Description:
!
!	Look for a given symbol (NOT symbol pathname, only the symbol name
!	itself) in the RST's name table (NT) always, and in the GST, sometimes.
!	The latter happens when the MC_GBL_LOCKED field is FALSE.
!
!	Since there may be several such pathnames, this routine actually passes
!	back a pointer to a so-called duplication chain.  This chain must be
!	whatever GET_NXT_DUP requires to 'track down' successive duplicates.
!
! Formal Parameters:
!
!	SYM_CS		-a counted string pointer to the symbol we are
!			 to look for in the NT.
!
! Implicit Inputs:
!
!	none.
!
! Implicit Outputs:
!
!	none.
!
! Return Value:
!
!
!	FALSE, when there is no NT or GST entry for 'sym_cs',
!	an NT-pointer to (a portion of) the hash chain which
!	begins with an NT record which has 'sym_cs' as its symbol,
!	otherwise.  If a global is found to match, its 'fake' NT record begins
!	the hash chain.
!
! Side Effects:
!
!	The GST may be searched linearly until the end or until SYM_CS is found.
!--

BEGIN

MAP
	SYM_CS : CS_POINTER;					! A pointer to the symbol we are to look for.

LOCAL
	GST_RECRD : REF GST_RECORD,				! Pointer to the global symbol table record
	NT_HASH,						! Hash code for the given symbol.
	NT_PTR	: REF NT_RECORD;				! Pointer we go thru the NT with.

!++
! Access to the NT is via hashing.  If there is no pointer in the hash vector
! we get to, then no symbols exist that hash to the same value as the symbol
! we are looking up.  Otherwise we follow the hash chain and pass back a pointer
! to the first symbol we find which matches 'sym_cs'.
!--
NT_HASH = PAT$NT_HASH_FCN( .SYM_CS );

!++
! First see if a global symbol can be found by the given name in the GST.
!--
IF ((GST_RECRD = LOOKUP_GBL(.SYM_CS)) NEQ 0) AND
    ((NT_PTR = .PAT$GL_MC_PTR[ MC_GBL_NT_PTR ]) NEQ 0)
THEN
	BEGIN
	LOCAL
		global_type,
		NAME_CS : CS_POINTER;

	!++
	! Found a global symbol.  Fill in the fake NT record for this global
	! so that the rest of the sym_to_val routines don't have to worry about
	! the special casing for globals.  The symbol name is in a different
	! place depending on which type of GSD this is.  Pick up a pointer
	! to this name, and record the GSD type.
	!--
	IF (.GST_RECRD[GST_ENTRY_TYPE] EQL GST_GLOBAL_DEFN)
	THEN
		BEGIN
		NAME_CS = GST_RECRD[GST_G_NAME_CS];
		GLOBAL_TYPE = DSC$K_DTYPE_GBL;
		END
	ELSE
		BEGIN
		NAME_CS = GST_RECRD[GST_E_NAME_CS];
		GLOBAL_TYPE = DSC$K_DTYPE_ENT;
		END;

	!++
	! Move the relevant fields into the NT record already reserved and
	! pointer to by a field in the global MC record.
	!--
	CH$MOVE( .NAME_CS[0]+1, NAME_CS[0], NT_PTR[NT_NAME_CS]);
	NT_PTR[NT_TYPE] = .GLOBAL_TYPE;
	NT_PTR[NT_IS_GLOBAL] = TRUE;
	NT_PTR[NT_UP_SCOPE] = 0;
	NT_PTR[NT_GBL_VALUE] = .GST_RECRD[GST_VALUE];

	!++
	! Make this NT point forward to the hash chain in the RST for symbols
	! which hash to this same value.  Whether or not there are any such
	! symbols, we have still built a duplication chain.  We carefully don't
	! change the existing hash chain so that nothing in the RST is actually
	! changed by the addition of this new fake NT for the found global symbol.
	!--
	NT_PTR[NT_FORWARD] = .PAT$GL_NT_HASH[.NT_HASH];

	!++
	! The duplication chain has been built.
	!--
	RETURN(.NT_PTR);
	END;

!++
! Access to the NT is via hashing.  If there is no pointer in the hash vector we
! get to, then no symbols exist that hash to the same value as the symbol we are
! looking up.  Otherwise we follow the hash chain and pass back a pointer to the
! first symbol we find which matches 'sym_cs'.
!--
IF ((NT_PTR = .PAT$GL_NT_HASH[.NT_HASH]) EQL 0)
THEN
	!++
	! If there is no hash chain, then there is no 'sym_cs' in the
	! RST data base.
	!--
	RETURN(FALSE);

!++
! There does exist a hash chain for the given symbol. If a match does exist,
! it must be in this chain, so we simply follow along it and compare the symbol
! names found therein for the first match.
!--
DO
	BEGIN
	!++
	! We are only interested in this entry if the symbol names actually do match.
	!--
	IF (CH$EQL(.SYM_CS[0],SYM_CS[1],.NT_PTR[NT_NAME_CS],NT_PTR[NT_NAME_ADDR]))
	THEN
		BEGIN
		!++
		! This is the place in the chain that we want to pass back a pointer to.
		!--
		RETURN(.NT_PTR);
		END;

	!++
	! Otherwise just skip along the chain. The hash chain ends when the
	! NT_FORWARD pointer is 0.
	!--
	END
WHILE( (NT_PTR = .NT_PTR[NT_FORWARD]) NEQ 0 );

!++
! If we fall out of the above loop, we ran off the end of the hash chain
! without finding a match to the symbol we were looking for.
!--
RETURN(FALSE);
END;

ROUTINE LOOKUP_GBL( SYM_CS ) =

!++
! Functional Description:
!
!	Look for a given symbol (NOT symbol pathname, only the
!	symbol name itself) in the Global symbol table (GST).
!
! Formal Parameters:
!
!	SYM_CS		-a counted string pointer to the symbol we are
!			 to look for in the GST.
!
! Implicit Inputs:
!
!
!	We don't consult the GST if MC_GBL_LOCKED is TRUE.
!
!	GET_NXT_GST is all set up to allow us to
!	read thru the (mapped) GST sequentially.
!
! Implicit Outputs:
!	none.
!
! Return Value:
!
!	0, when no GST entry for 'sym_cs' can be found,
!	a pointer to the GST record for
!	the found symbol, otherwise.
!
! Side Effects:
!
!	The GST may be searched sequentially until either
!	the end is encounered, or the symbol is found.
!--

BEGIN

MAP
	SYM_CS : CS_POINTER;

LOCAL
	GST_RECRD : REF GST_RECORD;				! Pointer to where a fetched GST record lives.

!++
! Don't even look in the GST if it is locked.  This happens either because the
! caller specifically does not want a global, or because the caller is using the
! 'cache' NT and SAT records for globals, and doesn't want them overwritten.
!--
IF (.PAT$GL_MC_PTR[MC_GBL_LOCKED])
THEN
	RETURN(0);

!++
! Process the GST records sequentially, giving up if some error occurs.
! First, do an INIT so that subsequent GETs return record pointers starting
! from the beginning.
!--
PAT$GET_NXT_GST(1);

!++
! PAT$GET_NXT_GST returns 0 when there are no more GST records to process.
! Otherwise it returns a pointer to each successive GST record.
!--
WHILE ((GST_RECRD = PAT$GET_NXT_GST(0)) NEQ 0)
DO
	BEGIN
	!++
	! We process each record depending on its GST type.
	!--
	CASE .GST_RECRD[GST_ENTRY_TYPE] FROM GST_LOWEST TO GST_HIGHEST OF
	    SET

	    [ GST_GLOBAL_DEFN ]:				! Definition of a global symbol.
		BEGIN
		!++
		! Check for string match of given and indicated symbols.
		!--
		IF (CH$EQL(.SYM_CS[0], SYM_CS[1], .GST_RECRD[GST_G_NAME_CS],
				GST_RECRD[GST_G_NAME_ADDR]))
		THEN
			!++
			! Found the right record, and we know there are no more
			! (because these are globals).
			!--
			EXITLOOP;
		END;

	    [ GST_ENTRY_DEFN ]:					! Definition of a entry point.
		BEGIN
		!++
		! Check for string match of given and indicated symbols.
		!--
		IF (CH$EQL(.SYM_CS[0], SYM_CS[1], .GST_RECRD[GST_E_NAME_CS],
				GST_RECRD[GST_E_NAME_ADDR]))
		THEN
			!++
			! Found the right record, and we know there are no more
			! (because these are globals).
			!--
			EXITLOOP;
		END;

	    [INRANGE, OUTRANGE]:				! Error.
		BEGIN
		RETURN(0);
		END;

	    TES;

	!++
	! Go back and process the next record.
	!--
	END;

!++
! If the above WHILE exits, then either we encountered the normal end of GST
! processing, or we found the symbol match.  Pass back the address of the given
! symbol's record, of 0, the failure code.
!--
RETURN(.GST_RECRD);
END;

ROUTINE GBL_VAL_TO_SAT( VALUE ) =

!++
! Functional Description:
!
!	Search the GST for the closest global symbol match
!	to the given value.  If found, build a temporary SAT
!	and NT entry for this symbol so that the rest
!	of the RST manipulating routine do not have to
!	special-case globals.
!
! Formal Parameters:
!
!	VALUE	-The key value to match to Global symbol.
!
! Implicit Inputs:
!
!	We don't consult the GST if MC_GBL_LOCKED.
!	This happens because we normally want 
!	to let VAL_TO_SYM consult globals, but to we need 
!	to override this when PC_RULE calls it.
!
!	GET_NXT_GST is all set up to all us to
!	read thru the (mapped) GST sequentially.
!
!	The first MC record is reserved for manipulating
!	globals.  As such, it has two fields which permanently
!	point to the 'fake' NT and SAT records which get
!	filled by this routine (and others).
!
! Implicit Outputs:
!
!	If a match is found, the MC_GBL NT and SAT records
!	are filled in so that they are usable just like
!	other NT/SAT pairs are.
!
! Return Value:
!
!	FALSE, when no candidate is found,
!	a pointer to the SAT record for
!	the found symbol, otherwise.
!
! Side Effects:
!
!	The GST may be searched sequentially until either
!	the end is encountered, or an exact match is found.
!--

BEGIN

LOCAL
	GLOBAL_TYPE,
	NAME_CS : CS_POINTER,
	GST_RECRD : REF GST_RECORD,				! Pointer to where a fetched GST record lives.
	GBL_SAT_PTR : REF SAT_RECORD,				! Pointers to the SAT and NT records we build.
	GBL_NT_PTR : REF NT_RECORD,
	BEST_MATCH : REF GST_RECORD;				! Pointer to so-far 'best' match found.

!++
! If we find a match candidate, we will use the GLOBAL temporary SAT and NT
! records to pass on the needed info.  If no space has been reserved for these
! records, we must give up now.  Moreover, if this space is currently in use
! (for SYM_TO_VAL) then again we must give up.
!--
IF (.PAT$GL_MC_PTR[MC_GBL_LOCKED])
THEN
	RETURN(0);
IF ((GBL_SAT_PTR = .PAT$GL_MC_PTR[MC_GBL_SAT_PTR]) EQL 0)
THEN
	RETURN(0);
IF ((GBL_NT_PTR = .PAT$GL_MC_PTR[MC_GBL_NT_PTR]) EQL 0)
THEN
	RETURN(0);

!++
! Process the GST records sequentially, giving up if some error occurs.
! First, do an INIT so that subsequent GETs return record pointers starting from
! the beginning.
!--
PAT$GET_NXT_GST(1);
BEST_MATCH = 0;

!++
! PAT$GET_NXT_GST returns 0 when there are no more GST records to process.
!--
WHILE ((GST_RECRD = PAT$GET_NXT_GST(0)) NEQ 0)
DO
	BEGIN
	!++
	! We process each record depending on its GST type.
	!--
	CASE .GST_RECRD[GST_ENTRY_TYPE] FROM GST_LOWEST TO GST_HIGHEST OF
	    SET

	    [ GST_GLOBAL_DEFN ,					! Definition of a global symbol.
	      GST_ENTRY_DEFN ]:					! Definition of global ENTRY points.
		BEGIN
		!++
		! Note that the only two types we support can be handled
		! together because the GST_VALUE field is in the same place in
		! both records.  First check for an exact match because then
		! we can abandon any further looking.
		!--
		IF (.VALUE EQLA .GST_RECRD[GST_VALUE])
		THEN
			BEGIN
			BEST_MATCH = .GST_RECRD;
			EXITLOOP;
			END;

		!++
		! Inexact matches are still better than nothing.
		!--
		IF (.VALUE GTRA .GST_RECRD[GST_VALUE])
		THEN
			!++
			! A match.  See if we already have one.
			!--
			IF (.BEST_MATCH EQL 0)
			THEN
				!++
				! Any one is better than none.
				!--
				BEST_MATCH = .GST_RECRD
			ELSE
				!++
				! Take the new one only if this symbol
				! is closer than the previous best one.
				!--
				IF (.BEST_MATCH[GST_VALUE] LSSA .GST_RECRD[GST_VALUE])
				THEN
					BEST_MATCH = .GST_RECRD;
		END;

	    [INRANGE, OUTRANGE]:				! Error.
		BEGIN
		RETURN(FALSE);
		END;

	    TES;

	!++
	! Go back and process the next record.
	!--
	END;

!++
! If the above WHILE exits, then we encountered the normal end of GST processing.
! If we didn't find any possible match, return failure status.
!--
IF (.BEST_MATCH EQL 0)
THEN
	RETURN(0);

!++
! Success - a candidate has been found.  Fill in the required SAT and NT
! records, and pass back a pointer to the former.  These records have already
! been (permanently) allocated space - they are pointed to by fields in the
! global MC record.
!--
GBL_SAT_PTR[SAT_LB] = .BEST_MATCH[GST_VALUE];
GBL_SAT_PTR[SAT_UB] = 0;
GBL_SAT_PTR[SAT_NT_PTR] = .GBL_NT_PTR;

!++
! The symbol name is in a different place depending on which type of GSD this
! is.  Pick up a pointer to this name, and record the GSD type.
!--
IF (.BEST_MATCH[GST_ENTRY_TYPE] EQL GST_GLOBAL_DEFN)
THEN
	BEGIN
	NAME_CS = BEST_MATCH[GST_G_NAME_CS];
	GLOBAL_TYPE = DSC$K_DTYPE_GBL;
	END
ELSE
	BEGIN
	NAME_CS = BEST_MATCH[GST_E_NAME_CS];
	GLOBAL_TYPE = DSC$K_DTYPE_ENT;
	END;
CH$MOVE( .NAME_CS[0]+1, NAME_CS[0], GBL_NT_PTR[NT_NAME_CS]);
GBL_NT_PTR[NT_TYPE] = .GLOBAL_TYPE;
GBL_NT_PTR[NT_IS_GLOBAL] = TRUE;
GBL_NT_PTR[NT_GBL_VALUE] = .BEST_MATCH[GST_VALUE];
GBL_NT_PTR[NT_FORWARD] = 0;
GBL_NT_PTR[NT_UP_SCOPE] = 0;
RETURN(.GBL_SAT_PTR);
END;

GLOBAL ROUTINE PAT$SYM_TO_VAL( PATH_VEC_PTR, VALUE_PTR ) =

!++
! Functional Description:
!
!	Use the RST/GST data base to translate a given symbol pathname to its
!	corresponding value.
!
!	This routine is quite similar PAT$SYM_TO_VALU, except that it is called
!	when ONLY the value is required.  As this builds in less knowledge of
!	the RST and its data structures, this routine should be called whenever
!	possible.
!
! Formal Parameters:
!
!  PATH_VEC_PTR	-a pointer to the pathname vector from a PATCH command
!
!  VALUE_PTR	-The location to hold the returned address bound to the
!		 symbol pathname.
!
! Implicit Inputs:
!
!	The value to be passed back is a longword.
!
! Implicit Outputs:
!
!	None.
!
! Return Value:
!	
!	TRUE, if symbol was located successfully.
!	FALSE, otherwise.
!
! Side Effects:
!
!	The bound address is written into the return location.
!
!--

BEGIN

MAP
	PATH_VEC_PTR : REF PATHNAME_VECTOR,
	VALUE_PTR : REF VECTOR[,LONG];

LOCAL
	STATUS,							! INDICATOR FOR NO SYMBOL (0), ADDR OF SYMBOL (1), ADDR OF ARRAY DESC (3)
	DSC_PTR : REF BLOCK[,BYTE],				! Array descriptor address
	VALU_DESC : VALU_DESCRIPTOR;				! Local value descriptor

!++
! PAT$SYM_TO_VALU does all the work of searching the symbol table.  It returns
! either the address bound to the symbol (STATUS = 1), the address of a
! descriptor for an array (STATUS = 3), or an indication that the symbol was not
! found (STATUS = 0 OR 2).
!--
IF (STATUS =  PAT$SYM_TO_VALU(.PATH_VEC_PTR, VALU_DESC))
THEN
	BEGIN
	!++
	! Now determine if the value returned is the address bound to
	! the symbol or the address of an array descriptor.
	!--
	IF (.STATUS EQL 1)
	THEN
		VALUE_PTR[0] = .VALU_DESC[VALU_VALUE]
	ELSE
		BEGIN
		!++
		! This must be an array descriptor.  Return the address bound
		! to the symbol not the address of the descriptor.
		!--
		DSC_PTR = .VALU_DESC[VALU_VALUE];
		VALUE_PTR[0] = .DSC_PTR[DSC$A_POINTER];
		END;
	RETURN(TRUE);
	END
ELSE
	!++
	! Failure. There is really nothing further we can do.
	!--
	RETURN(FALSE);
END;

GLOBAL ROUTINE PAT$SYM_TO_VALU( PATH_VEC_PTR, VALUE_DESC_ADDR ) =

!++
! Functional Description:
!
!	Use the RST/GST data base to translate a given
!	symbol pathname to its corresponding value.
!	Build and return a so-called 'value descriptor'
!	which corresponds to this found value.  It is
!	within this routine that the notion of "search rules"
!	is implemented.
!
! Formal Parameters:
!
!  PATH_VEC_PTR	-a pointer to the pathname vector which the user
!		 input as the symbol name.  This can be a simple
!		 "name", a compound "rout\rout1 ...\name",
!		 or a fully-qualified "module\...\name".
!
!  VALUE_DESC_ADDR	-The address of a value descriptor which
!			 we are to 'fill in' with the one which
!			 corresponds to the value we find associated
!			 with the given symbol.
!
! Implicit Inputs:
!
!	The value to be passed back is a longword, or at least,
!	the current definition of VALU_DESCRIPTOR facilitates
!	passing around the value we find.
!
!	The current state of the MODE data structure
!	is used, along with the built-in relationship between the
!	setting of these bits and the implied search rules, to
!	pick out which is the correct match from the RST.
!
!
! Implicit Outputs:
!
!	Whatever is implied by the current definition of VALU_DESCRIPTOR.
!
! Return Value:
!	
!	TRUE, if the symbol is found successfully and
!		 the returned value is the address bound to the symbol,
!	3, if the symbol is found successfully and
!		 the returned value is the address of descriptor for an array,
!	FALSE or 2, otherwise.
!
! Side Effects:
!
!	none.
!--

BEGIN

MAP
	PATH_VEC_PTR : REF PATHNAME_VECTOR,
	VALUE_DESC_ADDR : REF VALU_DESCRIPTOR;

LOCAL
	TEMP_PATH_VEC : PATHNAME_VECTOR,			! We use a local pathname vector to concat-
								! enate various other partial pathname
								! vectors into.
	CHAIN_PTR : REF NT_RECORD,				! A pointer to the hash chain which contains
								! all occurrences of the symbol which ends
								! the pathname pointed to by PATH_VEC_PTR.
	NT_PTR : REF NT_RECORD;					! We extract each RST-pointer from the
								! hash chain and use the local NT_PTR
								! to contain the entry.

LOCAL
	INDEX;							! Index of symbol in path vector.

!++
! See that the path vector has at least one entry, and that the RST has been initialized.
!--
IF .path_vec_ptr EQL 0
THEN
	RETURN FALSE;
IF (.PATH_VEC_PTR[0] EQL 0) OR (.PAT$GL_MC_PTR EQL 0)
THEN
	RETURN(FALSE);

!++
! The symbol is the last entry in the given pathname. 
! Pick up what index this is into the pathname vector.
!--
INDEX = 0;

REPEAT
	BEGIN
	IF (.PATH_VEC_PTR[.INDEX+1] EQL 0)
	THEN
		EXITLOOP;					! INDEX points to the symbol name.
	IF ((INDEX = .INDEX +1) GEQ MAX_PATH_SIZE)
	THEN
		RETURN(FALSE);
	END;

!++
! Discover all occurrences of the given symbol in the RST data base.  If some
! error occurs, we must give up.  This is because we consider not finding any
! symbols an error.
!--
IF ((CHAIN_PTR = PAT$LOOKUP_SYM( .PATH_VEC_PTR[.INDEX] )) EQL 0)
THEN
	RETURN(FALSE);						! We can find no such symbol.

!++
! First, before we bother with all the search rules, see if the symbol happens
! to be unique.  To do this, setup to scan the duplication chain.  Grab the
! first one, and  accept it as long as there is no second one, and as long as
! we were given only a symbol name.
!--
IF (.INDEX EQL 0)
THEN
	BEGIN
	!++
	! We have only a symbol name.  Check for uniqueness.
	!--
	PAT$GET_NXT_DUP( 1, .CHAIN_PTR );

	IF ((NT_PTR = PAT$GET_NXT_DUP(0)) EQL 0)
	THEN
		RETURN(FALSE);					! There is not even one.

	IF (PAT$GET_NXT_DUP(0) EQL 0)
	THEN
		BEGIN
		!++
		! The symbol is unique.  Return a corresponding
		! value descriptor and status code.
		!--
		VALUE_DESC_ADDR[VALU_NT_PTR] = .NT_PTR;
		RETURN( PAT$SYMBOL_VALU( .NT_PTR, VALUE_DESC_ADDR[VALU_VALUE] ));
		END;
	END;

!++
! We have all the duplicates, and there are  more than 1 of them.  Now see
! if one of them matches the given pathname.  Note that we have to apply each
! search rule, in order, to ALL of the duplicates before we can go on to the next
! search rule. (As opposed to applying all search rules to each consecutive 
! secutive duplicate - which sounds tempting but doesn't work).
!
! If GLOBAL or DEFine symbols are acceptable first, we can just try to match
! up the two pathnames  directly.
!--
IF (.PAT$GB_MOD_PTR[MODE_GLOBALS])
THEN
	BEGIN
	!++
	! Set up to scan the hash chain, and loop along
	! it until we have considered all duplicates.
	!--
	PAT$GET_NXT_DUP( 1, .CHAIN_PTR);
	WHILE( (NT_PTR = PAT$GET_NXT_DUP(0)) NEQ 0 )
		DO
		BEGIN
		IF (PATH_MATCH( .PATH_VEC_PTR, .NT_PTR))
		THEN
			BEGIN
			!++
			! Return a value descriptor and status code.
			!--
			VALUE_DESC_ADDR[VALU_NT_PTR] = .NT_PTR;
			RETURN( PAT$SYMBOL_VALU( .NT_PTR, VALUE_DESC_ADDR[VALU_VALUE] ));
			END;

		END;						! Loop back and try the next duplicate.
	END;							! It is not a GLOBAL.
!++
! Next, unless asked not to, we try qualifying the given pathname with the one
! that corresponds to  the user-set current scope position (CSP) vector.
! Note that we can't make this check if the CSP is null because this is
! equivalent to allowing a GLOBAL to satisfy the match which we can't allow
! at this point.
!--
IF (.PAT$GB_MOD_PTR[MODE_SCOPE] AND .PAT$GL_CSP_PTR NEQ 0)
THEN
	BEGIN
	!++
	! Set up to scan the hash chain, and loop along
	! it until we have considered all duplicates.
	!--
	PAT$GET_NXT_DUP( 1, .CHAIN_PTR);
	WHILE( (NT_PTR = PAT$GET_NXT_DUP(0)) NEQ 0 )
		DO
		BEGIN
		!++
		! First, build the new pathname by perpending the CSP.
		!--
		CONCAT_PATHS( TEMP_PATH_VEC, .PAT$GL_CSP_PTR, .PATH_VEC_PTR );
		IF (PATH_MATCH( TEMP_PATH_VEC, .NT_PTR))
		THEN
			BEGIN
			!++
			! Return a value descriptor and status code.
			!--
			VALUE_DESC_ADDR[VALU_NT_PTR] = .NT_PTR;
			RETURN( PAT$SYMBOL_VALU( .NT_PTR, VALUE_DESC_ADDR[VALU_VALUE] ));
			END;

		END;						! Go back and try the next duplicate.
	END;							! You can't find it via CSP.

!++
! Next, if we haven't already considered globals, now's the time.
!--
IF (NOT .PAT$GB_MOD_PTR[MODE_GLOBALS])
THEN
	BEGIN
	!++
	! Set up to scan the hash chain, and loop along it until we have
	! considered all duplicates.
	!--
	PAT$GET_NXT_DUP( 1, .CHAIN_PTR);
	WHILE( (NT_PTR = PAT$GET_NXT_DUP(0)) NEQ 0 )
		DO
		BEGIN
		IF (PATH_MATCH( .PATH_VEC_PTR, .NT_PTR))
		THEN
			BEGIN
			!++
			! Return a value descriptor and status code.
			!--
			VALUE_DESC_ADDR[VALU_NT_PTR] = .NT_PTR;
			RETURN( PAT$SYMBOL_VALU( .NT_PTR, VALUE_DESC_ADDR[VALU_VALUE] ));
			END;
		END;						! Go back and try the next duplicate.
	END;							! It is not a GLOBAL.
!++
! We applied all the search rules to all the duplicates and none was the one
! we were looking for.
!--
RETURN(FALSE);
END;

GLOBAL ROUTINE PAT$GET_NXT_DUP( INIT_FLAG, NEW_CHAIN ) =

!++
! Functional Description:
!
!	Facilitate going along hash chains (or whatever
!	it is that symbol duplicates are stored in) when we only
!	want to look at symbols which match a given symbol.
!
! Formal Parameters:
!
!	INIT_FLAG	0 => we are in the middle of a chain so
!			 pass back the next NT and ignore NEW_CHAIN.
!			 (so that we don't have to always pass 2 parameters)
!			1 => this is a real init.  NEW_CHAIN marks the 
!			 beginning of the new chain we want to look at.
!			-The returned value is undefined for INIT_FLAG==1
!			 type calls.  NEW_CHAIN is not defined, otherwise.
!	NEW_CHAIN	-a pointer to a chain of forward-linked
!			 NT records which all hash to the same value.
!			 When an init is done, (INIT_FLAG == 1), the
!			 first element on the new chain
!			 is assumed to be the one that we henceforth
!			 want to 'key' off.
!
! Implicit Inputs:
!
!	-The way that one 'chains' along hash chains.
!
!	-The first element in the chain when INIT==1 is the
!	 'key' element for that chain.  The symbol name therein
!	 defines what subsequent elements on the chain
!	 may be returned by PAT$GET_NXT_DUP(0) calls.
!
! Implicit Outputs:
!	none.
!
! Return Value:
!
!	0 - when there are no more NTs on the chain,
!	an NT_PTR to the next one, otherwise.
!
! Side effects:
!
!	OWN storage for IN_CHAIN and BEGIN_CHAIN get altered.
!--

BEGIN

OWN
	IN_CHAIN : REF NT_RECORD,				! Keep a static pointer to where we are in
								! the current hash chain.
	BEGIN_CHAIN    : REF NT_RECORD;				! If we are somewhere valid in the current
								! chain, then we also need a static pointer to 
								! what was the first element on this chain as
								! this is the one we get the chain symbol name from.

!++
! See if this call marks the beginning of a new hash chain.
!--
IF (.INIT_FLAG)
THEN
	BEGIN
	!++
	! Set up to be looking at a new chain.
	!--
	BEGIN_CHAIN = .NEW_CHAIN;
	IN_CHAIN = .NEW_CHAIN;

	!++
	! We don't define any return value for this type of call.
	!--
	RETURN;
	END;

!++
! Skip along the chain until the next NT record of interest is found.  We may
! already be at the end because of previous calls.
!--
IF (.IN_CHAIN EQL 0)
THEN
	RETURN(0);

!++
! Otherwise scan the chain.
!--
DO
	BEGIN
	!++
	! Simply check that the symbol names match.
	!--
	IF (CH$EQL( .IN_CHAIN[NT_NAME_CS], IN_CHAIN[NT_NAME_ADDR],
	   .BEGIN_CHAIN[NT_NAME_CS], BEGIN_CHAIN[NT_NAME_ADDR])
	  )
	THEN
		BEGIN
		LOCAL
			MATCH_NT : REF NT_RECORD;

		MATCH_NT = .IN_CHAIN;
		IN_CHAIN = .IN_CHAIN[NT_FORWARD];
		RETURN(.MATCH_NT);
		END;
	END

WHILE( (IN_CHAIN = .IN_CHAIN[NT_FORWARD]) NEQ 0 );
!++
! There are no more in the chain to consider.
!--
RETURN(0);
END;

ROUTINE CONCAT_PATHS( DESTINATION, PV_1, PV_2 ) : NOVALUE =

!++
! Functional Description:
!
!	Concatenate two PATHNAME_VECTORS together and place
!	the resultant vector in the indicated location.
!	If the PV_1 vector is the same as the DESTINATION
!	vector, then this routine is equivalent to routine
!	which just 'tacks' one vector onto the end of another.
!
! Formal Parameters:
!
!  DESTINATION		-a pointer to where the concatenation
!			 of the PV_1 and PV_2 vectors should be
!			 be stored.
!  PV_1			-a pointer to the first source vector.  If PV_1[0]
!			 is 0, the PV_1 vector is considered empty.
!  PV_2			-a pointer to the second source vector.  If PV_2[0]
!			 is 0, the PV_2 vector is considered empty.
!
! Implicit Inputs:
!
!	None, other than the assumptions made about PATHNAME_VECTORS,
!	namely their characteristics, given via the 'canned' declaration,
!	and the fact that they must end with a 0 entry.
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!	NOVALUE
!
! Side Effects:
!
!	The two vectors are concatenated.
!--

BEGIN

MAP
	DESTINATION : REF PATHNAME_VECTOR,			! All three input parameters are pointers to
								! pathname vectors.
	PV_1	    : REF PATHNAME_VECTOR,
	PV_2	    : REF PATHNAME_VECTOR;

LOCAL
	I_2,							! Index used for PV_2 vector.
	INDEX;							! Used to index thru the destination vector.

!++
! Initialize an index into the destination and source pathname vectors.
!--
INDEX = 0;
I_2 = 0;

!++
! If we were actually given the first vector, copy each element from it into
! the destination vector.  We do not consider a 0-pointer vector to be an error;
! it just means that that vector doesn't contribute anything to the result.
!--
IF (PV_1[0] NEQ 0)
THEN
	!++
	! Copy each element, making sure not to overflow.
	!--
	WHILE( .INDEX LSS MAX_PATH_SIZE )
		DO
		IF ((DESTINATION[.INDEX] = .PV_1[.INDEX]) EQL 0)
		THEN
			!++
			! The first 0 element => the end.
			!--
			EXITLOOP
		ELSE
			INDEX = .INDEX + 1;
!++
! Then add on the second vector, again making sure that we were actually given
! something.  Note that we don't have to check overflow of the PV_2 vector
! because no matter how long it is, we will overflow the destination vector
! before we overflow it.
!--
IF (PV_2[0] NEQ 0)
THEN
	WHILE( .INDEX LSS MAX_PATH_SIZE )
		DO
		IF ((DESTINATION[.INDEX] = .PV_2[.I_2]) EQL 0)
		THEN
			!++
			! This is the only correct way to return from this routine.
			!--
			RETURN
		ELSE
			BEGIN
			I_2 = .I_2 +1;
			INDEX = .INDEX +1;
			END;

!++
! If we don't return in the above loop, then it is because we were about
! to overflow the destination vector.  We take care of this by effectively wiping
! out the vector we have built.
!--
DESTINATION[0] = 0;
RETURN;
END;

GLOBAL ROUTINE PAT$NT_HASH_FCN( NAME_CS ) =

!++
! Functional Description:
!
!	Calculate what we call the 'hash' code associated
!	with a given symbol name (counted string).
!	This function localizes the dispersal that we
!	use to distribute symbol NT-records into so-called
!	NT-chains.  Currently this works by simply adding
!	up the characters which make up the symbol name,
!	adding in the count as well, and then truncating
!	the resultant value to one byte so that we can
!	then use this byte to index into the NT Hash Vector
!	that then gives us the pointer to the NT chain for
!	all symbols that 'hash' to this same byte index.
!
! Formal Parameters:
!
!	NAME_CS	-the address of a counted string that
!		 is the symbol name we are to 'hash'.
!
! Implicit Inputs:
!
!	The hash index is supposed to be 1 byte long.
!	(See the literal, NT_HASH_SIZE).
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!	The 1-byte hash index, guaranteed not to exceed
!	the range you can reach with an unsigned byte.
!
! Side Effects:
!
!	None.
!--

BEGIN

MAP
	NAME_CS : CS_POINTER;

LOCAL
	TALLY;

!++
! We simply add up the characters in the supposed name, including the count.
!--
DECR I FROM (TALLY = .NAME_CS[0]) TO 1
	DO
	TALLY = .TALLY + .NAME_CS[.I];
	!++
! The hash value is later used as a byte index into the NT hash table.
!--
RETURN( .TALLY<0,8,0> );
END;

ROUTINE PATH_MATCH( PATH_VEC_PTR, NT_PTR ) =

!++
! Functional Description:
!
!	See if the NT record we are passed a pointer to
!	has the same implicit path name as the one 
!	specified in the PATHNAME_VECTOR we are also
!	passed a pointer to.
!
! Formal Parameters:
!
!  PATH_VEC_PTR		-A pointer to the pathname vector which holds
!			 the path name of the symbol we are to match
!			 with the one implied by the NT scope chain.
!  NT_PTR		-A pointer to the NT record which begins a so-called
!			 scope chain.  
!
! Implicit Inputs:
!
!	-Pathname vectors end with a 0 element; NT scope chains
!	 end when PAT$ADD_NT_T_PV says they do.
!	-If the 'top' NT entry in an NT chain IS_GLOBAL,
!	 then we assume that a pathname consisting only
!	 of that global name is sufficient to 'match' the
!	 implicit NT pathname.  This means that PATH_MATCH
!	 had better not be called with the user-given pathname
!	 (ie nothing has been perpended to it) unless
!	 a global answer is acceptable.
!
! Implicit Outputs:
!
!	None.
!
! Return Value:
!	
!	TRUE, if the paths match,
!	FALSE, otherwise.
!
! Side Effects:
!
!	None.
!--

BEGIN

MAP
	PATH_VEC_PTR : REF PATHNAME_VECTOR,
	NT_PTR : REF NT_RECORD;

LOCAL
	CS_SRC : CS_POINTER,
	CS_DST : CS_POINTER,
	PATH_VEC : PATHNAME_VECTOR;

!++
! Since we want to compare to pathnames which  have a radically different data
! structure representation, the simplest thing to do is to convert one of the
! two different things into the same kind of thing as the other is.  Then
! comparing them is easy. In our case it is easiest to build a real 
! PATHNAME_VECTOR to correspond to the one implied by the NT scope chain.
!--
PAT$ADD_NT_T_PV( .NT_PTR, PATH_VEC );

!++
! Now just look thru the two vectors making sure that the CS pointers therein
! point to identical strings.  Note that we do the comparison up to and
! including the symbol name which ends the path, since although we know these
! symbols hash to the same value we don't know that they are identical.
! Also note that even if we go thru the following loop mathing OK up to and
! including the MAX_PATH_SIZE'th time, this is still NOT a valid match since
! we must get a 0 entry to end the pathvectors properly.  This is why we say
! that falling out of this loop implies failure.
!--
INCR I FROM 0 TO MAX_PATH_SIZE
	DO
	BEGIN
	!++
	! Extract the CS pointers from the pathname vectors and make sure
	! that one of them is not 0 unless the other one is.  If the two paths
	! are to match,  they must end at the same time, otherwise the paths
	! do not match because one is longer than the other.
	!--
	CS_SRC = .PATH_VEC_PTR[.I]; 
	CS_DST = .PATH_VEC[.I];
	IF (.CS_SRC EQL 0) AND (.CS_DST EQL 0)
	THEN
		RETURN(TRUE);					! This is one of two places that a match can be detected.

	IF (.CS_SRC EQL 0) OR (.CS_DST EQL 0)
	THEN
		EXITLOOP;					! The pathnames don't match because
								! one of them is too short.

	!++
	! Now it is safe to actually compare the element strings.
	!--
	IF (NOT CH$EQL( .CS_SRC[0], CS_SRC[1], .CS_DST[0], CS_DST[1]))
	THEN
		EXITLOOP;					! Mismatch because two elements are not the same.
		END;						! Corresponding pathname elements match.  Go back
								! and check successive elements.

!++
! If we fall out of the above loop, then the pathnames did not match.
! As well as a straightforward pathvector match, we must also implement a 
! special match for when the user asks for a global symbol which happens
! to be a global from a module we have locals for.  The reason for the special
! case here is because (only) this type of global has a real pathname -
! namely "mod\glob_name".  While we support the user giving such names, we must
! also allow him to say simply "glob_name" as well.  To check this, first see
! that the two symbol names are identical.  Then make sure that this is all
! of the user-given pathname, and that the corresponding NT record _IS_GLOBAL
! and is not MODULE.
!--
CS_SRC = .PATH_VEC_PTR[0]; 
IF (NOT CH$EQL( .CS_SRC[0], CS_SRC[1], .NT_PTR[NT_NAME_CS], NT_PTR[NT_NAME_ADDR]))
THEN
	BEGIN

	RETURN(FALSE);						! Mismatch because two elements are not the same.
	END;

IF (.PATH_VEC_PTR[1] EQL 0 AND .NT_PTR[NT_IS_GLOBAL]) 
THEN
	!++
	! Don't get fooled by the MC_IS_GLOBAL MC record. No module names have
	! values, so can never be PATH_MATCHed.
	!--
	IF (.NT_PTR[NT_TYPE] NEQ DSC$K_DTYPE_MOD)
	THEN
		BEGIN

			RETURN(TRUE);				! This is the second of 2 places were a match can be detected.
		END;

RETURN(FALSE);							! The two pathnames do not match.
END;

GLOBAL ROUTINE PAT$VAL_TO_SYM( VALUE, NT_PTR_ADDR, LVT_FLAG ) =

!++
! Functional Description:
!
!	Implement the search algorithm which PATCH uses to
!	correspond values with symbols.
!
! Formal Parameters:
!
!	VALUE		-The key we use in the lookup.
!	NT_PTR_ADDR	-A pointer to where we should copy back
!			 the NT_POINTER to the record we find
!			 to correspond to the value.  The
!			 contents of this location are not changed
!			 if no such correspondence is discovered.
!	LVT_FLAG	-Whether or not we should even try for a
!			 match in the literal value table (LVT).
!			 (We always lookup in the SAT first).
! Warning:
!	
!	We return an NT pointer via NT_PTR_ADDR.
!	As long as this returned value is NOT a longword,
!	due to BLISS's inability to use the REF NT_RECORD
!	ONLY as an NT pointer, (i.e. BLISS assumes that 
!	REFs are longwords), a caller of this routine should
!	initialize the NT_PTR to 0 before expecting this
!	routine to pass back the value.  This routine
!	can not pass back a longword because we won't know that
!	the address we were passed is not a real NT_PTR
!	field - ie, the 2-bytes that it should be...
!
! Implicit Inputs:
!
!	None.
!
! Implicit Outputs:
!
!	The RESULT parameter via NT_PTR_ADDR.
!	(see above.)
!
! Routine Value:
!
!	TRUE, if a match is found,
!	FALSE, otherwise.
!
! Side Effects:
!
!
!	The SAT (and LVT) table(s) is/are searched.
!--

BEGIN

MAP
	NT_PTR_ADDR : REF RST_POINTER;				! The NT pointer we return is an RST-pointer.

LOCAL
	SAT_PTR : REF SAT_RECORD;

IF (VAL_TO_SAT(.VALUE, SAT_PTR))
THEN
	BEGIN
	!++
	! Make up for the fact that we are supposed to return an NT pointer,
	! not the SAT pointer that VAL_TO_SAT gave us.
	!--
	NT_PTR_ADDR[0] = .SAT_PTR[SAT_NT_PTR];
	RETURN(TRUE);
	END;

RETURN(	IF (.LVT_FLAG)
	THEN
		LOOKUP_LVT( .VALUE, .NT_PTR_ADDR )
	ELSE
		FALSE);
END;

ROUTINE VAL_TO_SAT( VALUE, SAT_PTR_ADDR ) =

!++
! Functional Description:
!
!	Search the Static Address Table (SAT) for the best 
!	match to the given value.
!
! Formal Parameters:
!
!	VALUE		-The key we use in the lookup.
!	SAT_PTR_ADDR	-A pointer to where we should copy back
!			 the SAT_POINTER to the record we find
!			 to correspond to the value.  The
!			 contents of this location are not changed
!			 if no such correspondence is discovered.
!
! Implicit Inputs:
!
!	The way we define a 'match' in the SAT is
!	determined solely in this routine.
!
! Implicit Outputs:
!
!	The RESULT parameter, via SAT_PTR_ADDR, also
!	indicates the corresponding NT record
!	(via SAT_NT_PTR).
!
! Routine Value:
!
!	TRUE, if a match is found,
!	FALSE, otherwise.
!
! Side Effects:
!
!	The SAT is searched.
!--

BEGIN

MAP
	SAT_PTR_ADDR : REF VECTOR;				! The SAT pointer we stuff back is a longword.

LABEL
	SEARCH_SAT;

LOCAL
	CURRENT_NT  : REF NT_RECORD,				! When we look at each record of the SAT_VECTOR,
								! we apply the proper structure.
	CURRENT_SAT : REF SAT_RECORD,
	NEXT_SAT : REF SAT_RECORD,
	BEST_SAT : REF SAT_RECORD;				! When we look at each record of the SAT_VECTOR,
								! we apply the proper structure.
								! same time - the 'current' one, and
								! the previous, or so-far 'best', one.

!++
! There starts out being no 'previous' or  best match.  There is also no initial
! notion of 'current' sat - we made it different from 'best' to begin with
! solely for the diagnostic printout, below.
!--
BEST_SAT = 0;

!++
! Set up to begin the sequential pass of the SAT.
!--
PAT$GET_NXT_SAT( SL_ACCE_INIT );

!++
! Linearly search the SAT looking for an exact match. SAT access type is _RECS
! because we want to quit  when the access-mapping routine recognizes that
! even though there may be more potential records in the SAT, there are no more
! ones currently in use.
!--
WHILE( (NEXT_SAT = PAT$GET_NXT_SAT( SL_ACCE_RECS )) NEQ 0 )
	DO

    SEARCH_SAT:
	BEGIN

	!++
	! Update our idea of the current SAT to consider.
	!--
	CURRENT_SAT = .NEXT_SAT;
	CURRENT_NT = .CURRENT_SAT[SAT_NT_PTR];

	IF (.CURRENT_SAT[SAT_LB] EQL .VALUE)
	THEN
		BEGIN
		!++		
		! We define a match to be 'best' if it is an exact one.  Even
		! better, though, is an exact match which is NOT to a p-sect symbol.
		!--
		IF (.BEST_SAT EQL 0)
		THEN
			BEGIN
			!++
			! Since there were no previous candidates, we take
			! the current one as best.
			!--
			BEST_SAT = .CURRENT_SAT;
			END
		ELSE
			BEGIN
			!++
			! See if the former 'best' match was exact.
			!--
			IF (.BEST_SAT[SAT_LB] NEQ .VALUE)
			THEN
				!++
				! The newer and exact match is preferable to a 
				! previous non-exact one no matter what.
				!--
				BEST_SAT = .CURRENT_SAT
			ELSE
				!++
				! Since there was a previous exact match, 
				! and there now is a current exact match,
				! we choose the one which is not a p-sect
				! (even if we end up with one which was a
				!  match only because its UB is 0).
				!--
				IF (.CURRENT_NT[NT_TYPE] NEQ DSC$K_DTYPE_PCT)
				THEN
					BEST_SAT = .CURRENT_SAT;
			END;

		!++
		! At this point there is nothing further to do
		! until we see if there are any more candidates.
		!--
		LEAVE SEARCH_SAT;
		END;

	!++
	! Now try for a non-exact match.
	!--
	IF (.CURRENT_SAT[SAT_LB] GTRA .VALUE)
	THEN
		!++
		! Once we get past the value we were
		! searching for, we know there will be
		! no other candidates because the SAT
		! is sorted.
		!--
		EXITLOOP;

	!++
	! At this point, we know that the CURRENT lower bound! value is strictly
	! less than VALUE.  Now we are! concerned about the corresponding upper
	! bound value. Normally this UB value is the address which is the
	! upper extent to which the corresponding symbol is bound.  Some symbols
	! don't come with this info, though, so we handle these cases separately.
	!--
	IF (.CURRENT_SAT[SAT_UB] NEQ 0)
	THEN
		BEGIN
		!++
		! Since we have the UB information, we simply see if the
		! CURRENT symbol spans the given VALUE.
		!--
		IF (.CURRENT_SAT[SAT_UB] LSSA .VALUE)
		THEN
			LEAVE SEARCH_SAT;			! This datum ends too soon.

		!++
		! VALUE falls within this symbol's extent. If we already have
		! a match but havn't accepted it as final, then its UB must
		! be 0, or its type is  P-sect.  In either case, this new one
		! is better because its UB is not 0.
		!--
		BEST_SAT = .CURRENT_SAT;

		!++
		! If the best one now is of type P-sect, we  should still
		! look further.
		!--
		IF (.CURRENT_NT[NT_TYPE] NEQ DSC$K_DTYPE_PCT)
		THEN
			!++
			! This is the first non-P-sect match so we'll take it
			! without any further checks.  This is where we might
			! get into trouble later because there may still be a
			! more appropriate match if we were to take SCOPE into
			! account.
			!--
			EXITLOOP;
				
		!++
		! There is nothing further to consider when we know the UB value.
		!  At this point we want to loop back and perhaps find a
		! better match.
		!--
		END
	ELSE
		BEGIN
		!++
		! We must consider it to be a match when the upper bound is 0
		! because we don't know that it isn't a match.
		! It is certainly not a good match, though, so we throw it
		! away unless we don't have anything better.
		!--
		IF (.BEST_SAT EQL 0)
		THEN
			BEST_SAT = .CURRENT_SAT
		ELSE
			IF (.BEST_SAT[SAT_UB] EQL 0)
			THEN
				BEST_SAT = .CURRENT_SAT
			ELSE
				!++
				! BEST must be p-sect
				!--
				IF (.CURRENT_NT[NT_TYPE] NEQ DSC$K_DTYPE_PCT)
				THEN
					BEST_SAT = .CURRENT_SAT;
		END;

	END;							! Loop back and try again with the next  SAT record.

!++
! If we fall out of the above loop, then there are no more candidates from the
! RST to consider.  See if the answer we got was good enough, or if we should
! consult the GST.
!--
IF (.BEST_SAT EQL 0)
THEN
	!++
	! Any global is better than nothing.
	!--
	BEST_SAT = GBL_VAL_TO_SAT(.VALUE)
ELSE
	!++
	! Don't even try for a global if we already got
	! an exact match from the RST.
	!--
	IF (NOT .VALUE EQLA .BEST_SAT[SAT_LB])
	THEN
		BEGIN
		LOCAL
			BEST_NT : REF NT_RECORD;

		!++
		! Check for a better match.
		!--
		BEST_NT = .BEST_SAT[SAT_NT_PTR];
		IF ((.BEST_SAT[SAT_UB] EQL 0) OR
		    (.BEST_NT[NT_TYPE] EQL DSC$K_DTYPE_PCT))
		THEN
			IF ((CURRENT_SAT = GBL_VAL_TO_SAT(.VALUE)) NEQ 0)
			THEN
				!++
				! The global match is better if it is closer.
				!--
				IF (.CURRENT_SAT[SAT_LB] GTRA .BEST_SAT[SAT_LB])
				THEN
					BEST_SAT = .CURRENT_SAT;
		END;

!++
! Now see how we've done.
!--
IF (.BEST_SAT NEQ 0)
THEN
	BEGIN
	!++
	! Pass back the NT-pointer to the match and return a success status.
	!--
	SAT_PTR_ADDR[0] = .BEST_SAT;
	RETURN(TRUE);
	END;

!++
! No 'match' was found - return the standard failure status.
!--
RETURN(FALSE);
END;

ROUTINE LOOKUP_LVT( VALUE, NT_PTR_ADDR ) =

!++
! Functional Description:
!
!	Search the literal value table (LVT) for a match
!	to the given value.
!
! Formal Parameters:
!
!	VALUE		-The key we use in the lookup.
!	NT_PTR_ADDR	-A pointer to where we should copy back
!			 the NT_POINTER to the record we find
!			 to correspond to the value.  The
!			 contents of this location are not changed
!			 if no such correspondence is discovered.
!
! Warning:
!	
!	We return an NT pointer via NT_PTR_ADDR.
!	As long as this returned value is NOT a longword,
!	due to BLISS's inability to use the REF NT_RECORD
!	ONLY as an NT pointer, (i.e. BLISS assumes that 
!	REFs are longwords), a caller of this routine should
!	initialize the NT_PTR to 0 before expecting this
!	routine to pass back the value.  This routine
!	can not pass back a longword because we won't know that
!	the address we were passed is not a real NT_PTR
!	field - ie, the 2-bytes that it should be...
!
! Implicit Inputs:
!
!	The way we define a 'match' in the LVT which is 
!	simply that the given value must be exactly the
!	same as the corresponding one from the LVT.  The
!	first one found is always the one passed back.
!
! Implicit Outputs:
!
!	The RESULT parameter via NT_PTR_ADDR.
!	(see above.)
!
! Routine Value:
!
!	TRUE, if a match is found,
!	FALSE, otherwise.
!
! Side Effects:
!
!	The LVT is searched.
!--

BEGIN

MAP
	NT_PTR_ADDR : REF RST_POINTER;

LOCAL
	LVT_PTR : REF LVT_RECORD;				! When we look at each record of the LVT_VECTOR,
								! we apply the proper structure.

!++
! Set up to begin the sequential pass of the LVT.
!--
PAT$GET_NXT_LVT( SL_ACCE_INIT );

!++
! Linearly search the LVT looking for an exact match. LVT access type is _RECS
! because we want to quit  when the access-mapping routine recognizes that
! even though there may be more potential records in the LVT, there are no more
! ones currently in use.
!--
WHILE ((LVT_PTR = PAT$GET_NXT_LVT( SL_ACCE_RECS )) NEQ 0)
	DO
	BEGIN

	IF (.LVT_PTR[LVT_VALUE] EQL .VALUE)
	THEN
		BEGIN
		!++
		! This is the only place we can find a match and return an OK status.
		!--
		NT_PTR_ADDR[0] = .LVT_PTR[LVT_NT_PTR];
		RETURN(TRUE);
		END;

	!++
	! Loop back and try again with the next  LVT record.
	!--
	END;

!++
! If we fall out of the above loop, no match can be found.
!--
RETURN(FALSE);
END;

GLOBAL ROUTINE PAT$SYMBOL_VALU( NT_PTR, VALUE_PTR ) =

!++
! Functional Description:
!
!	-Look up the value associated with a given
!	 NT record.
!	-Note that we refer to 'value' associated with a symbol
!	 but really mean 'address', since that is as far as RST
!	 manipulation handles symbol-value correlation.
!
! Formal Parameters:
!
!	NT_PTR		-a pointer to the NT_RECORD that corresponds
!			 to the symbol we want the value of.
!	VALUE_PTR	-where we are to copy the value back to.
!
! Implicit Inputs:
!
!	-We can call PAT$DST_VALUE with a DST_REC_ID.
!	 (in BLD's ADD_NT we call it with a DST_RECRD pointer).
!
!	-The value bound to a symbol can be passed
!	 back in a longword.
!	-NT records marked NT_IS_GLOBAL may be 1 of 2 types:
!	   1) one which was first a normal NT record but
!		which was later marked NT_IS_GLOBAL.  In this case
!		there IS scope info, and we pick up the value
!		from the DST.
!	   2) a fake NT record which was created from a GST
!		record.  In this case the 'value' field is stored
!		in the NT_DST_PTR field of the NT record.
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!	TRUE, if the symbol is found successfully and
!		 the returned value is the address bound to the symbol,
!	3, if the symbol is found successfully and the value returned is the
!		 address of an array descriptor for the symbol,
!	FALSE or 2, otherwise.
!
! Side Effects:
!
!	The value gets passed back.
!--

BEGIN

MAP
	NT_PTR    : REF NT_RECORD,
	VALUE_PTR : REF VECTOR[,LONG];

!++
! If this NT record corresponds only to a GLOBAL symbol, there is no associated
! DST record.  In this case we use the DST pointer space from the NT record
! to contain the value associated with the global symbol.
!--
IF (.NT_PTR[NT_IS_GLOBAL] AND .NT_PTR[NT_UP_SCOPE] EQL 0)
THEN
	BEGIN
	VALUE_PTR[0] = .NT_PTR[NT_GBL_VALUE];

	RETURN(TRUE);
	END;

!++
! We localize all DST understanding to yet another routine.
!--
RETURN( PAT$DST_VALUE( .NT_PTR[NT_DST_PTR], .VALUE_PTR));
END;

GLOBAL ROUTINE PAT$DST_VALUE( DST_REC_ID, VALUE_PTR ) =

!++
! Functional Description:
!
!	-Look up the value associated with a given
!	 DST record.
!	-Note that we refer to 'value' associated with a symbol
!	 but really mean 'address', since that is as far as RST
!	 manipulation handles symbol-value correlation.
!	 Normally this 'address' is the virtual address which is
!	 bound to the symbol.  If the symbol is associated with
!	 a descriptor, though, it is the address of the descriptor
!	 which is returned for this symbol.
!
! Formal Parameters:
!
!	DST_REC_ID	-a pointer to the DST RECORD that corresponds
!			 to the symbol we want the value of.
!			-this may also be the DBGINT-defined DST record ID
!			 which it assigns to each DST record it processes.
!			 ***** see implicit inputs below.
!	VALUE_PTR	-where we are to copy the value back to.
!
! Implicit Inputs:
!
!	The concept of a DST_REC_ID vs a DST_RECRD pointer
!	is merged by this routine.  i.e. we don't consider
!	these two things to be different even though everything
!	else in PATCH does not preclude this.  If the
!	DST interface routine is changed so that these two things
!	are no longer the same, we must change calls to this routine
!	to be consistent.  So far this routine is called 
!	by PAT$SYMBOL_VALU and ADD_NT only.
!
!	-The value bound to a symbol can be passed
!	 back in a longword.
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!	TRUE, if the symbol is found successfully and the value returned is the
!		 address bound to the symbol,
!	3, if the symbol is found successfully and the value returned is the
!		 address of an array descriptor for the symbol,
!	FALSE or 2, otherwise.
!
! Side Effects:
!
!	The value gets returned.
!
!	The DST is 'read' in such a way as to ensure that 
!	if any PAT$GET_NXT_DST sequence is in progress it
!	is NOT disturbed by this call.
!--

BEGIN

MAP
	VALUE_PTR : REF VECTOR[,LONG];

LOCAL
	STATUS,							! RETURNED STATUS CODE
	MAPPED_ADR : REF BLOCK[,BYTE],				! Mapped descriptor address
	ISE_ADR,						! Image Section Address
	VALUE,							! Used to accumulate the symbol's value.
	ACCESS,							! The access field from the DST record.
	DST_RECRD : REF DST_RECORD;

!++
! Fetch the indicated DST record.
!--
STATUS = TRUE;						! ASSUME EVERYTHING WORKS
IF ((DST_RECRD = PAT$GET_DST_REC( .DST_REC_ID )) EQL 0)
THEN
	!++
	! The supposed record does not exist.  An error message should already
	! have been produced.
	!--		
	RETURN(FALSE);

!++
! How we pick up the value depends on what class of DST record this is.
!--
IF (.DST_RECRD[DSTR_TYPE] EQL DSC$K_DTYPE_Z)
THEN
	BEGIN
	!++
	! BLISS Type Zero records have a format which is different from
	! standard DST records.
	!--
	BIND
		BLZ_RECRD = DST_RECRD : REF BLZ_RECORD;

	!++
	! We can't make any sense out of these records (yet) unless
	!	1) no optional type into was given
	!	   (i.e. we only get the standard 3 bytes)
	!	2) the structure attribute is 0
	!	3) the sub-type is within the range we currently support.
	!	   (i.e. only FORMALs and SYMBOLs are OK)
	!
	! We have already implicitly checked the first two of these because we
	! wouldn't have entered the symbol into the NT had this check
	! not succeeded.
	!--

	!++
	! Pick up the value of this symbol.
	!--
	STATUS = STD_SYM_EVAL(VALUE, .BLZ_RECRD[BLZ_ACCESS], .BLZ_RECRD[BLZ_VALUE]);

	!++
	! End of special handling for type ZERO variables.
	!--
	END
ELSE
	!++
	! Class 1 is the so-called SRM 'standard' types.
	!--
	IF (.DST_RECRD[DSTR_TYPE] LEQ DST_TYP_HIGHEST)
	THEN
		BEGIN
		IF (.DST_RECRD[DSTR_ACCES_TYPE] EQL ACCS_DESCRIPTOR)
		THEN
			BEGIN
			!++
			! Ignore dynamically-located array descriptors.  This
			! means that only the so-called "PC" relative ones are
			! supported.
			!--
			IF (.DST_RECRD[DSTR_ACCES_BASD] NEQ 2) OR
			   (.DST_RECRD[DSTR_ACCES_BREG] NEQ 15)
			THEN
				RETURN(FALSE);

			!++
			! The descriptor is in the DST record itself.
			! The notion of PC is as though the 'DST' PC
			! were just used to 'pick up' the _VALUE field,
			! which gives how far from there to displace
			! to find the actual array descriptor.
			! For the routine PAT$SYM_TO_VAL, the status
			! code returned must indicate that this value is
			! an array descriptor address.
			!--
			VALUE = .DST_RECRD[DSTR_VALUE];
			VALUE = .VALUE + DST_RECRD[DSTR_VALUE] + %UPVAL;
			STATUS = 3;
			END
		ELSE
			!++
			! For standard types, we simply apply the corresponding
			! standard algorithm.  The various TYPEs will be used
			! mainly to sort out what we do with the value
			! after the algorithm tells us how to get it, but
			! this is handled outside of this routine.
			!--
			STATUS = STD_SYM_EVAL(VALUE, .DST_RECRD[DSTR_ACCESS], .DST_RECRD[DSTR_VALUE]);
		END
	ELSE
		BEGIN
		!++
		! Class 2 is 'the rest'.  We expect them to be from the standard
		! DSTR_TYPEs class.
		!--
		CASE .DST_RECRD[DSTR_TYPE] FROM DST_DST_LOWEST TO DST_DST_HIGHEST OF
		    SET
	
		    [DSC$K_DTYPE_FLD]:	! Bliss fields.

			BEGIN
			$FAO_TT_OUT('!/FLD not supported');
			RETURN(FALSE);
			END;

		    [DSC$K_DTYPE_PCT,
		     DSC$K_DTYPE_LBL,
		     dsc$k_dtype_slb,
		     DSC$K_DTYPE_RTN]:	! These ones have values.

			VALUE = .DST_RECRD[DSTR_VALUE];

		    [INRANGE,OUTRANGE]:	! Probably an error.

			RETURN(FALSE);

		    TES;

		END;

!++
! At this point, the value has been obtained or a RETURN has been done.
! We simply pass back this value and return a good status code.
!--
VALUE_PTR[0] = .VALUE;
RETURN(.STATUS);
END;

ROUTINE STD_SYM_EVAL( PASS_BACK_ADDR, ACCESS, IN_VALUE ) =

!++
! Functional Description:
!
!	Implement the algorithm which comes up with
!	a symbol's value given the so-called ACCESS
!	and IN_VALUE fields taken from (various places within)
!	the DST record for a symbol which uses
!	'standard encoding'.
!
!	See CP0021.MEM, pgs 9-10 for this algorithm.
!
! Formal Parameters:
!
!	PASS_BACK_ADDR	-The address of where we stuff back the value	-LT
!			 the algorithm determines.
!	ACCESS		-The 1-byte field which encodes the
!			 3-element fields described in CP0021.MEM
!			 for so-called 'standard encoding'.
!	IN_VALUE	-The value field which may be used in
!			 conjunction with ACCESS.
!
! Implicit Inputs:
!
!	That the value bound to a symbol can be passed
!	back in a longword.
!
! Implicit Outputs:
!
!	The value which is currently associated with the symbol which
!	presumably corresponds to the ACCESS and IN_VALUE fields given,
!	is passed back.
!
! Routine Value:
!
!	TRUE, if all goes OK and the value gets passed back.
!	NOT TRUE, otherwise.  In this case we distinguish two possibilities:
!			0 => a real error - the symbol could not be evaluated.
!		and	2 => a soft error - the evaluation failed because of an
!						inappropriate context.
!
! Side Effects:
!
!	The value which is currently associated with
!	the symbol which presumably corresponds to
!	the ACCESS and IN_VALUE fields given.
!--

BEGIN

MAP
	PASS_BACK_ADDR : REF VECTOR;				! THE VALUE WE PASS BACK IS A LONGWORD

LOCAL
	RET_VALUE;						! We accumulate the value we return.

!++
! ******* THIS ROUTINE MUST BE WRITTEN WHEN BLISS VARIABLES ARE ADDED. *******
!--
RET_VALUE = .IN_VALUE;
IF (.ACCESS<2,1,0>)						! If "indirect" set
THEN
! ******** WARNING:  Don't know if going indirect is to a mapped or
!			non-mapped address.  Therfore return error for now.
!	RET_VALUE = .(.RET_VALUE);
	RETURN(2);
PASS_BACK_ADDR[0] = .RET_VALUE;
RETURN(TRUE);
END;

END								! End of module
ELUDOM
