MODULE search (		! Search file(s) for a string utility
                        IDENT = 'V03-001',
                        MAIN = main
                        ) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY:  SEARCH
!
! ABSTRACT:
!
!	This utility program searchs a file or files for a specified
!	string and lists all occurrences.
!
! ENVIRONMENT:
!
!	VAX/VMS operating system, unprivileged user mode utility,
!	operates at non-AST level.
!
! AUTHOR:  Len Kawell,	CREATION DATE:  22 Dec 1978
!
! Modified by:
!
!	V03-001	CWH0014		CW Hobbs		22-Mar-1982
!		Change WRITEERR to SEVERE so that only one message is
!		printed when unable to write the output.
!
!	V02-013	CWH0013		CW Hobbs		20-Feb-1982
!		Add nambufs for output file so that the file name is
!		available for error messages.  Change output segmenting
!		to avoid record too big errors.
!
!	V02-012	CWH0012		CW Hobbs		2-Feb-1982
!		Use LIB$FILE_SCAN instead of $PARSE and $SEARCH to
!		perform like other DCL commands.
!
!	V02-011	CWH0009		CW Hobbs		25-Jan-1982
!		Make error messages for insufficient virtual memory
!		more meaningful.
!
!	V02-010	CWH0008		CW Hobbs		18-Jan-1982
!		Use shared messages where possible, add WRITEERR message.
!
!	V02-009	CWH0007		CW Hobbs		14-Dec-1981
!		Fix loop if no directory in resultant string for EXCLUDE.
!
!	V02-008	CWH0006		CW Hobbs		13-Dec-1981
!		Remove dummy routine.  Do $TRNLOG on /EXCLUDE file
!		names.  Correct problem with /WINDOW=0.  Remove 
!		some code for testing.
!
!	V02-007	CWH0004		CW Hobbs		30-Nov-1981
!		Speedups, make /STATISTICS a conditional assembly
!		option.  Restructure for expression matches.
!
!	V02-006	CWH0002		CW Hobbs		28-Oct-1981
!		  Change FOR$CNV_IN_I to OTS$CVT_TI_L entry.  Add more
!		error codes.  Remove MBC from input FAB, use process
!		defaults.  Remove filename header from between windows and
!		change window separator to '********'.  Put output record in
!		several segments if longer than mrs of output file, also
!		check status of rms_put operation.
!		  Make search-string input parameter a list, move match
!		check to separate routine, add /MATCH qualifier to
!		set sense of match.
!		  Redo windowing.  Save vector of RFA's rather than records.
!		Use locate mode exclusively, set SQO only if no prev recs.
!		Replace /ADDITIONAL and /PREVIOUS with /WINDOW qualifier.
!		Print filename only if /WINDOW=0 is specified.
!		  Improve error messages, especially I/O error signalling.
!		Change truncate error to one per file, not one per record.
!		  Other new qualifiers:
!			/EXACT	    - use exact case matches
!			/EXCLUDE    - omit list of files from search
!			/FORMAT	    - convert control chars unless disabled
!			/HEADING    - give control of printing of heading
!			/LOG	    - signal filenames searched
!			/NUMBERS    - print source line #'s
!			/REMAINING  - print from match to EOF
!			/STATISTICS - print some access information
!
!	V02-005	CWH0001		CW Hobbs		24-Aug-1981
!		Define external routines as general addressing mode.
!		Display the filespec header whenever a list of
!		input filenames is given.
!
!	V004	TMH0004		Tim Halvorsen		29-Jun-1981
!		Increase size of input buffer.  Open input file for
!		shared read/write access.  Do not display the filespec
!		header if non-wild search.
!
!	V02-003 CNH0032		Chris Hume		16-Apr-1980
!		Added windowing and (new) CLI callback.
!
!	V02-002			Len Kawell		14-Mar-1980
!		General cleanup, fixups, and added command line parameters.
!
!	V02-001			B.L. Schreiber		18-May-1979
!		Add LIB$SIGNAL to external routines.
!
!--

!
! Include files
!
LIBRARY
    'SYS$LIBRARY:STARLET';		! VAX/VMS common definitions

!
! Define the compile-time switches used for conditional assemblies
!
LITERAL
    switch_statistics	= 0;		! Include the /STATISTICS code
!
! Structure declarations
!
STRUCTURE

	bblockvector [I, O, P, S, E; N, BS] =
		[N*BS]
		((bblockvector+I*BS)+O)<P,S,E>;
!
! Macros
!
MACRO

    dsc_long1 = 0,0,32,0 %,		! First longword of descriptor
    dsc_dynam = dsc$k_class_d^24 OR dsc$k_dtype_t^16 %,  ! dynamic desc

    ! Define shorthand for a single initialized dynamic string desc
    !
    dyn_str_desc = BLOCK [dsc$k_d_bln,BYTE]
			PRESET(	[dsc$b_class] = dsc$k_class_d,
				[dsc$b_dtype] = dsc$k_dtype_t) %,

    ! Define macro for a single initialized static string desc.
    !
    stat_str_desc (L, A) = BLOCK [dsc$k_s_bln,BYTE]
			PRESET(	[dsc$b_class]   = dsc$k_class_s,
				[dsc$b_dtype]   = dsc$k_dtype_t,
				[dsc$w_length]  = (L),
				[dsc$a_pointer] = (A) ) %,

    ! Define different psects for initialized and demand-zero storage.
    !
    OWN_CRF     = PSECT OWN    = $OWN$_CRF     (WRITE); OWN    %,
    OWN_DZRO    = PSECT OWN    = $OWN$_DZRO    (WRITE); OWN    %;
!
! Define special linkages for very frequently called routines
!
LINKAGE
    JSB_FORACTDUM = JSB (REGISTER=2,REGISTER=3,REGISTER=0) 
			: NOPRESERVE(2,3)	NOTUSED(4,5,6,7,8,9,10,11),
    JSB_FORACTTEX = JSB (REGISTER=4,REGISTER=5,REGISTER=2) 
			: NOPRESERVE(2,3,4,5)	NOTUSED(6,7,8,9,10,11),
    JSB_FORPUT    = JSB (REGISTER=2,REGISTER=3,REGISTER=4) 
			: NOPRESERVE(2,3,4)	NOTUSED(10,11),
    JSB_GETNEXREC = JSB (REGISTER=3,REGISTER=4) 
			: NOPRESERVE(2)		NOTUSED(5,6,7,8,9,10,11),
    JSB_PUTOUT    = JSB (REGISTER=2,REGISTER=3) 
			: NOPRESERVE(2,3)	NOTUSED(6,7,8,9,10,11),
    JSB_STDMAT    = JSB (REGISTER=4,REGISTER=5) 
			: NOPRESERVE(2,3)	NOTUSED(9,10,11),
    JSB_UPCASE    = JSB (REGISTER=1, REGISTER=2, REGISTER=3) 
			: NOPRESERVE(2,3)	NOTUSED(4,5,6,7,8,9,10,11);
!
! Table of contents
!
FORWARD ROUTINE
    main,					! Main entry
    scan_success	: NOVALUE,		! Action routine for file found
    scan_failure	: NOVALUE,		!    "     "     file error
    exclude_file,				! Check exclude list
    validate_exclude_file : NOVALUE,		! Verify that filename is OK
    locate_filename,				! Find filename field in name
    locate_version,				! Find version in filename
    match_file,					! Compare filename strings
    search_one_file	: NOVALUE,		! Open and search a file
    get_next_record	: JSB_GETNEXREC,	! Read a record from the file
    advance_window	: NOVALUE,		! Scroll the viewing window
    std_search_file	: NOVALUE,		! Standard string matches
    std_match		: JSB_STDMAT,		! See if search string present
    file_error,					! Signal file I/O error
    upcase		: NOVALUE JSB_UPCASE,	! Convert string to uppercase
    format_n_put	: NOVALUE JSB_FORPUT,	! Format and put to output
    format_action_text	: JSB_FORACTTEX,	! /FORMAT=TEXT routine
    format_action_dump	: JSB_FORACTDUM,	! /FORMAT=DUMP & NONULLS
    srh$put_output	: NOVALUE JSB_PUTOUT;	! Put record to output file

!
! External references
!
EXTERNAL ROUTINE
    lib$file_scan : addressing_mode(general),	! Wildcard file searches
    lib$lookup_key: addressing_mode(general),	! Keyword table lookup
    lib$put_output: addressing_mode(general),	! Put stat to sys$output
    cli$get_value : addressing_mode(general),	! Get qualifier value
    cli$present	  : addressing_mode(general),	! Get qualifier presence
    ots$cvt_ti_l  : addressing_mode(general),	! ASCII decimal to longword
    str$get1_dx	  : addressing_mode(general),	! Allocate Dynamic String
    str$copy_dx	  : addressing_mode(general),	! Copy any class string
    lib$get_vm	  : addressing_mode(general);	! Gets memory

!
! Equated symbols
!
LITERAL
    true		= 1,			! Routine value of TRUE
    false		= 0,			! Routine value of FALSE
    max_infiles		= 136,			! Max files in SOURCE list
    max_srhstr		= 136,			! Max strings in STRING list
    max_exclude		= 136,			! Max files in EXCLUDE list
    io_buff_sz		= 2048,			! Input buffer size
    form_text		= 0,			! Default format
    form_passall	= 1,			! Pass all characters
    form_dump		= 2,			! Reformat, flag 8 bit chars
    form_nonulls	= 3;			! Like DUMP, but no nulls

EXTERNAL LITERAL		! Facility-specific message definitions
    srh$_badexcl,
    srh$_badexclnam,
    srh$_badform,
    srh$_badmatch,
    srh$_matched,
    srh$_nomatch,
    srh$_nofile,
    srh$_nomatches,
    srh$_nostring,
    srh$_nullfile,
    srh$_rfaerr,
    srh$_truncate,
    srh$_wdw_maxprev,
    srh$_wdw_maxprm;

				! Shared message definitions
$SHR_MSGDEF  
    (srh, 215, local,
	(badlogic, error),
	(badvalue, error),
	(insvirmem, error),
	(openin, warning),
	(openout, error),
	(readerr, warning),
	(writeerr, severe));
	

!
! OWN storage, initialized and demand-zero variables are defined
! in separate groups so that the linker will give us a demand-zero
! section rather than storing a bunch of zeroes in the image file
!
OWN_DZRO
    exp_name	: VECTOR [nam$c_maxrss, BYTE],	! RMS expanded name buffer
    res_name	: VECTOR [nam$c_maxrss, BYTE],	! RMS result name buffer
    out_exp_nam	: VECTOR [nam$c_maxrss, BYTE],	! RMS expanded name buffer
    out_res_nam	: VECTOR [nam$c_maxrss, BYTE];	! RMS result name buffer

OWN_CRF
    string_desc	: dyn_str_desc,			! Input search string desc
    mod_desc	: dyn_str_desc,			! Modifier string descriptor
    tmp_desc	: stat_str_desc(0, 0),		! Kosher desc for misc fcns

    rel_nam	: $NAM (			! Dummy NAM for stickyness
	    		RSA = exp_name,
			RSS = nam$c_maxrss),
    nam_block	: $NAM (			! File name block
			RSA = res_name,		!  Result name addr
			RSS = nam$c_maxrss,	!  Result name size
			ESA = exp_name,		!  Expanded name addr
			ESS = nam$c_maxrss,	!  Expanded name size
			RLF = rel_nam),		!  Related NAM block
    fab		: $FAB(				! Input file FAB
			FOP = NAM,		!  Open by name block
			SHR = (GET,PUT,UPI),	!  Allow other readers/writers
    			DNA = UPLIT BYTE('*.*'),!  Default file spec.
			DNS = 3,		!   (DNM doesn't like *'s)
			NAM = nam_block),	!  Name block
    rab		: $RAB(				! Input file RAB
			MBF = 3,		!  Multi-buffer count
			RAC = SEQ,		!  Will also use RFA as needed
			ROP = (RAH,LOC),	!  Read-ahead, locate mode
			USZ = io_buff_sz,	!  User buffer size
			FAB = fab),		!  FAB addr
    out_nam_blk	: $NAM (			! File name block
			RSA = out_res_nam,	!  Result name addr
			RSS = nam$c_maxrss,	!  Result name size
			ESA = out_exp_nam,	!  Expanded name addr
			ESS = nam$c_maxrss),	!  Expanded name size
    outfab	: $FAB(				! Output file FAB
			RAT = CR,		!  Record attributes
    			DNA = UPLIT BYTE('SEARCH.LIS'),	!  Default file spec.
			DNS = 10,
			NAM = out_nam_blk),	!  Name block
    outrab	: $RAB(				! Output file RAB
			ROP = WBH,		!  Write-behind
			FAB = outfab),		!  FAB addr
    !
    ! Build a keyword table for the FORMAT qualifier
    !
    format_keytbl	: VECTOR [9, LONG] PRESET (
		[0] = 8,				! Entries + values
		[1] = UPLIT BYTE (%ASCIC 'TEXT'),	! String for TEXT
		[2] = form_text,			! Value for TEXT
		[3] = UPLIT BYTE (%ASCIC 'PASSALL'),	! String
		[4] = form_passall,			! Value
		[5] = UPLIT BYTE (%ASCIC 'DUMP'),	! String
		[6] = form_dump,				! Value
		[7] = UPLIT BYTE (%ASCIC 'NONULLS'),	! String
		[8] = form_nonulls),			! Value
    !
    ! Build a keyword table for the MATCH qualifier
    !
    match_keytbl	: VECTOR [9, LONG] PRESET (
		[0] = 8,				! Entries + values
		[1] = UPLIT BYTE (%ASCIC 'OR'),		! String for OR
		[2] = 0,				! Value for OR
		[3] = UPLIT BYTE (%ASCIC 'NOR'),	! String
		[4] = 1,				! Value
		[5] = UPLIT BYTE (%ASCIC 'AND'),	! String
		[6] = 2,				! Value
		[7] = UPLIT BYTE (%ASCIC 'NAND'),	! String
		[8] = 3);				! Value

!
! Now define all the non-initialized variables
!
OWN_DZRO
    wdw_pre_recs,				! Previous records requested
    wdw_sub_recs,				! Subsequent records requested
    wdw_pre_cntr,				! Previous records available
    wdw_sub_cntr,				! Subsequent records to list
    wdw_pre_buff,				! Current io_buff index
    cnt_infile,					! Actual # of input files
    cnt_srhstr,					! Actual # of search strings
    cnt_exclude,				! Actual # of exclude files
    max_rec	  : VOLATILE,			! Actual output max rec size
    format,					! Code for output format
    fil_totmat,					! Total matches in one file
    fil_linenum,				! Total lines in one file
    out_file_open : BYTE,			! An output file is open
    out_printing  : BYTE,			! Matched records to output
    wdw_previous  : BYTE,			! RFA windowing active
    wdw_zero	: BYTE,				! We have /WINDOW=0
    wdw_frame	: BYTE,				! Frame discontiguous windows
    wdw_ovfl	: BYTE,				! Window discontiguity flag
    qua_exact	: BYTE,				! Exact case match flag
    qua_log	: BYTE,				! Log filenames searched
    qua_numbers	: BYTE,				! Output line number
    qua_heading	: BYTE,				! Display names of files
    new_file	: BYTE,				! Just opened a new file
    found_file	: BYTE,				! Found at least one file flag
    found_any	: BYTE,				! Any matches found boolean
    fil_found	: BYTE,				! Match found in this file
    mat_and	: BYTE,				! Match is AND if true, OR if false
    mat_negate	: BYTE,				! Turns above to NAND and NOR

    rfa_vec	: REF bblockvector [,rab$s_rfa],! RFA's for previous records

    output_buff	: REF VECTOR [,BYTE],		! For reformatting

    infile_desc	: 				! Array of input filenames
		bblockvector [max_infiles, dsc$k_d_bln],
    srhstr_desc	: 				! Array of search strings
		bblockvector [max_srhstr,  dsc$k_d_bln],
    exclude_desc : 				! Array of exclude filenames
		bblockvector [max_exclude, dsc$k_d_bln];

%IF switch_statistics
%THEN
    OWN_DZRO
	!
	! define the block for the GETJPI for statistics
	!
	qua_statistics,			! Give statistics
	stat_totchr,				! Total characters in all files
	stat_totrec,				! Total records in all files
	stat_totfil,				! Total files searched
	stat_totmat,				! Total matches found
	stat_totput,				! Total records put to output
	stat_jpi_bufio,				! $GETJPI deposits them here
	stat_jpi_cputim,
	stat_jpi_dirio,
	stat_jpi_pageflts,
	stat_bufio,				! Saved from startup getjpi
	stat_cputim,
	stat_dirio,
	stat_pageflts,
	stat_starttime : VECTOR [2, LONG];

    OWN_CRF
	stat_jpi_block : VECTOR [13, LONG] INITIAL (
			(JPI$_BUFIO^16 OR 4),	stat_jpi_bufio, 0,
			(JPI$_CPUTIM^16 OR 4),	stat_jpi_cputim, 0,
			(JPI$_DIRIO^16 OR 4),	stat_jpi_dirio, 0,
			(JPI$_PAGEFLTS^16 OR 4),stat_jpi_pageflts, 0,
			0);
%FI ! switch_statistics

BIND
    stars_30 = UPLIT BYTE ('******************************'),
    null_str = %ASCID '';			! The null string

ROUTINE main =

!++
! Functional description
!
!	This routine is the transfer point and central loop for the
!	utility.  It retrieves filename(s), search string(s) and qualifiers
!	from DCL, and looks up the files and calls the search routines.
!
! Calling sequence
!
!	main ()
!
! Input parameters
!
!	none
!
! Routine value
!
!	Most severe error encountered during processing or SS$_NORMAL
!
!--
BEGIN

LOCAL
    !
    ! Obtain memory for the input buffer and the output buffer
    ! Worst case size of output buffer is 6*input + 8 (when full
    ! length input is all -1's, /FORM=DUMP/NUMBERS)
    !
    out_buffer	: BLOCK [io_buff_sz*6+8, BYTE],	! For reformatting
    inp_buffer	: BLOCK [io_buff_sz, BYTE];	! Input buffer

LOCAL
    wdw_1,					! Flag that first window parm
    wdw_2,					! Flag that 2 window parameters
    window_1,					! Value of window parm 1
    window_2,					! Value of window parm 2
    status,					! Error status
    keyval;					! Will receive keyword value

BIND
    window_str = %ASCID 'WINDOW',		! Qualifier keywords
    string_str = %ASCID 'STRING',
    source_str = %ASCID 'SOURCE';

!
! Get initial run statistics
!
%IF switch_statistics
%THEN
    IF qua_statistics = cli$present(%ASCID 'STATISTICS')
    THEN
	BEGIN

	IF NOT (status = $GETJPI (ITMLST=stat_jpi_block))
	THEN
	    RETURN .status;
	IF NOT (status = $GETTIM (TIMADR=stat_starttime))
	THEN
	    RETURN .status;

	stat_bufio    = .stat_jpi_bufio;	! copy from the JPI return variables
	stat_cputim   = .stat_jpi_cputim;
	stat_dirio    = .stat_jpi_dirio;
	stat_pageflts = .stat_jpi_pageflts;
	END;
%FI
!
! Set some pointers to the local data for this procedure
!

rab [rab$l_ubf] = inp_buffer;			! Address of user buffer
output_buff = out_buffer;			! Buffer for reformatting

!
! Get the simple qualifiers
!
qua_exact      = cli$present(%ASCID 'EXACT');	! Want lower case matches?
qua_log        = cli$present(%ASCID 'LOG');	! Show filenames?
qua_numbers    = cli$present(%ASCID 'NUMBERS');	! Want line numbers?
qua_heading    = cli$present(%ASCID 'HEADING');	! Print file headings?

!
! Get the window size parameters
!
IF wdw_1 = cli$get_value(window_str, mod_desc)
THEN
	BEGIN
	IF NOT ots$cvt_ti_l(mod_desc,window_1)
	THEN
	    BEGIN
	    SIGNAL (srh$_badvalue, 1, mod_desc);
	    RETURN (srh$_badvalue OR %X'10000000');  ! Inhibit DCL PUTMSG
	    END;
	IF .window_1 LSS 0		! BLISS will optimize these together
	THEN
	    BEGIN
	    SIGNAL (srh$_badvalue, 1, mod_desc);
	    RETURN (srh$_badvalue OR %X'10000000');
	    END;
	END;

! Try to get the second window parameter
!
IF wdw_2 = cli$get_value(window_str, mod_desc)
THEN
	BEGIN
	IF NOT ots$cvt_ti_l(mod_desc, window_2)
	THEN
	    BEGIN
	    SIGNAL (srh$_badvalue, 1, mod_desc);
	    RETURN (srh$_badvalue OR %X'10000000');
	    END;
	IF .window_2 LSS 0		! BLISS will optimize these together
	THEN
	    BEGIN
	    SIGNAL (srh$_badvalue, 1, mod_desc);
	    RETURN (srh$_badvalue OR %X'10000000');
	    END;
	END;

IF cli$get_value(window_str, mod_desc) ! Make sure no more in list.
THEN
    RETURN srh$_wdw_maxprm;

! Set the appropriate values for previous recs and subsequent records.  We
! assume that WDW_PRE_RECS and WDW_SUB_RECS are initially zero.
!
IF .wdw_1			! If /NOWINDOW we have nothing to do.
THEN
    BEGIN
    IF .wdw_2			! We have /WINDOW=(pre,sub) format.
    THEN
	BEGIN
	wdw_pre_recs = .window_1;
	wdw_sub_recs = .window_2;
	END
    ELSE			! We have /WINDOW=total format
	BEGIN
	IF .window_1 EQL 0
	THEN
	    wdw_zero = 1	! Set flag for /WINDOW=0 option
	ELSE
	    BEGIN
	    LOCAL		! Help BLISS optimize
		tmp;
	    tmp = .window_1 -1;	! Count the matched line as one of them
	    wdw_pre_recs = .tmp / 2;
	    wdw_sub_recs = .tmp - .wdw_pre_recs;
	    END;
	END;
    END;

IF	(.wdw_pre_recs GTR 0)
    OR	(.wdw_sub_recs GTR 0)
THEN
    wdw_frame = true;		! Don't say "***************" for /WINDOW=1

IF cli$present(%ASCID 'REMAINING')	! Do we want match to end of file?
THEN
    wdw_sub_recs = 2^31 - 1;		! Set to something akin to infinity

!
! Open the output file
!
IF out_file_open = cli$get_value(%ASCID 'OUTPUT', mod_desc)
THEN
	BEGIN
	outfab [fab$b_fns] = .mod_desc [dsc$w_length];
	outfab [fab$l_fna] = .mod_desc [dsc$a_pointer];
	IF NOT (status = $CREATE(FAB = outfab))
	THEN
	    RETURN file_error (srh$_openout,.status,outfab,.outfab [fab$l_stv]);
	IF NOT (status = $CONNECT(RAB = outrab))
	THEN
	    RETURN file_error (srh$_openout,.status,outfab,.outrab [rab$l_stv]);
	max_rec = .outfab [fab$w_mrs];
	IF .max_rec EQL 0 THEN max_rec = 2^15-1;
	END;

out_printing = (NOT .wdw_zero) AND .out_file_open; ! Do we print matched lines?

!
! Get the /MATCH qualifier value, set the bit vector
!
cli$get_value(%ASCID 'MATCH', string_desc);	! Get the string
upcase(.string_desc [dsc$w_length], .string_desc [dsc$a_pointer],
				   .string_desc [dsc$a_pointer]);
IF NOT (status = lib$lookup_key (string_desc, match_keytbl, keyval))
THEN
    SIGNAL_STOP (srh$_badmatch, 0, .status, 1, string_desc);

CASE .keyval FROM 0 TO 3 OF
    SET
	[0] :	;			! 'OR' - No action, both zero already
	[1] :	mat_negate = true;	! 'NOR' - mat_and is already zero
	[2] :	mat_and = true;		! 'AND' - mat_negate is already zero
	[3] :	BEGIN			! 'NAND' - We have to set them both
		mat_and = true;
		mat_negate = true;
		END;
    TES;

!
! If there are no previous records we can set for sequential only
!

IF .wdw_pre_recs EQL 0
THEN
    fab [fab$v_sqo] = true
ELSE
    BEGIN
    wdw_previous = true;
    !
    ! Obtain memory for the vector of RFA's
    !
    IF NOT (status = lib$get_vm(%REF((.wdw_pre_recs + 1)*rab$s_rfa), rfa_vec))
    THEN
	SIGNAL_STOP (srh$_wdw_maxprev, 0, .status);	! Buffer max exceeded.
    END;

!
! Get the /FORMAT qualifier value, set the variable
!
cli$get_value(%ASCID 'FORMAT', string_desc);	! Get the string
upcase(.string_desc [dsc$w_length], .string_desc [dsc$a_pointer],
				   .string_desc [dsc$a_pointer]);
IF NOT (status = lib$lookup_key (string_desc, format_keytbl, format))
THEN
    SIGNAL_STOP (srh$_badform, 0, .status, 1, string_desc);

!
! DCL parameter P1, SOURCE
!
! Get all the input file names so that we will know if a list is specified.
! Max_infiles is large enough so that is is IMPOSSIBLE to overflow
!
WHILE .cnt_infile LSS max_infiles
DO
    BEGIN
    infile_desc [.cnt_infile, dsc_long1] = dsc_dynam;	! Init to dynamic desc
    IF NOT (status = cli$get_value(source_str,
				   infile_desc [.cnt_infile, dsc$w_length]) )
    THEN
	EXITLOOP;
    cnt_infile = .cnt_infile+1;
    END;

!
! The command requires SOURCE, but just in case someone mungs the CLD file
!
IF .cnt_infile LEQ 0
THEN
    RETURN srh$_nofile;

!
! DCL parameter P2, STRING
!
! Get the all the search string entries
! Max_srhstr is large enough so that is is IMPOSSIBLE to overflow
!
WHILE .cnt_srhstr LSS max_srhstr
DO
    BEGIN
    IF NOT (status = cli$get_value(string_str, string_desc))
    THEN
	EXITLOOP;
    !
    ! Copy or upcase the search string
    !
    srhstr_desc [.cnt_srhstr, dsc_long1] = dsc_dynam;	! Init to dynamic desc

    IF .qua_exact THEN 			! Copy to descriptor array
	str$copy_dx (srhstr_desc [.cnt_srhstr,dsc$w_length],
		     string_desc [dsc$w_length])
    ELSE
	BEGIN				! Upcase into the descriptor array
	str$get1_dx (string_desc [dsc$w_length], ! Allocate Destination String
		     srhstr_desc [.cnt_srhstr,dsc$w_length]);
	upcase(					! Uppercase search string
		.srhstr_desc [.cnt_srhstr, dsc$w_length],   !  Length of source
		.string_desc [dsc$a_pointer],		   !  Source addr
		.srhstr_desc [.cnt_srhstr, dsc$a_pointer]); !  Destination addr
	END;

    cnt_srhstr = .cnt_srhstr+1;
    END;

!
! The command requires STRING, but just in case someone changes the CLD file
!
IF .cnt_srhstr LEQ 0
THEN
    RETURN srh$_nostring;

!
! DCL qualifier /EXCLUDE
!
! Get the all the exclude filenames
! Max_exclude is large enough so that is is IMPOSSIBLE to overflow
!
WHILE .cnt_exclude LSS max_exclude
DO
    BEGIN
    LOCAL
	buf : VECTOR [nam$c_maxrss, BYTE],
	inter_desc : BLOCK [8, BYTE],		! Intermediate name
	result_desc : BLOCK [8, BYTE];

    IF NOT (status = cli$get_value(%ASCID 'EXCLUDE', string_desc))
    THEN
	EXITLOOP;

    ! Don't let device and directory sneak in with a logical name
    !
    CH$MOVE (8, string_desc, inter_desc);	! Start with the given name
    CH$MOVE (4, tmp_desc, result_desc);		! Static string desc info
    DO
	BEGIN
	result_desc [dsc$w_length] = nam$c_maxrss;
	result_desc [dsc$a_pointer] = buf;
	status = $trnlog (lognam = inter_desc, rsllen = result_desc, rslbuf = result_desc);
	IF NOT .status
	THEN
	    SIGNAL_STOP (.status);
	CH$MOVE (8, result_desc, inter_desc);	! Ready to translate again
	END
    UNTIL .status EQL ss$_notran;

    !
    ! Make sure that the filename has no device or directory.  Allow for
    ! alternate directory syntax of <dir>
    !
    IF	   CH$FIND_CH(.result_desc [dsc$w_length],
		      .result_desc [dsc$a_pointer], ':') NEQ 0
	OR CH$FIND_CH(.result_desc [dsc$w_length],
		      .result_desc [dsc$a_pointer], ']') NEQ 0
	OR CH$FIND_CH(.result_desc [dsc$w_length],
		      .result_desc [dsc$a_pointer], '>') NEQ 0
    THEN
	SIGNAL_STOP (srh$_badexcl,1,result_desc);	! Scream and shout

    !
    ! Copy, upcase and validate the exclude filename
    !
    exclude_desc [.cnt_exclude, dsc_long1] = dsc_dynam;	! Init to dynamic desc
    validate_exclude_file (result_desc,exclude_desc [.cnt_exclude, dsc$w_length]);
    cnt_exclude = .cnt_exclude+1;
    END;

!
! Search the input files
!
found_file = false;				! Nothing found yet
found_any = false;
INCR ifx FROM 0 TO .cnt_infile-1		! Try all of out
DO							! file spec.
	BEGIN
	fab [fab$l_fna] = .infile_desc [.ifx, dsc$a_pointer];	! Set name addr
	fab [fab$b_fns] = .infile_desc [.ifx, dsc$w_length];	! Set name size
	lib$file_scan (fab, scan_success, scan_failure);	! Do full wildcard scan
	rel_nam [nam$b_rsl] = .nam_block [nam$b_esl];		! Set rel. file length
	fab [fab$l_dna] = 0;					! Allow sticky type
	END;

%IF switch_statistics
%THEN
!
! Display the statistics if desired.
!
IF .qua_statistics
THEN
    BEGIN
    BUILTIN
	SUBM;
    LOCAL
	quadtime : VECTOR [2, LONG],
	tim,
	tim_buf : VECTOR [16, BYTE],
	tim_desc : VECTOR [2, LONG],
	stat,
	out_buf	: VECTOR [80,BYTE];

    IF NOT (stat = $GETJPI (ITMLST=stat_jpi_block))
    THEN
	RETURN .stat;

    tmp_desc [dsc$a_pointer] = out_buf;
    lib$put_output(null_str);

    tmp_desc [dsc$w_length] = 80;
    IF NOT (stat = $FAO( %ASCID 'Files searched:        !10UL       Buffered I/O count:!10UL',
		tmp_desc, tmp_desc, .stat_totfil, .stat_jpi_bufio-.stat_bufio))
    THEN
	RETURN .stat;	! Signal the error
    lib$put_output(tmp_desc);

    tmp_desc [dsc$w_length] = 80;
    IF NOT (stat = $FAO( %ASCID 'Records searched:      !10UL       Direct I/O count:  !10UL',
		tmp_desc, tmp_desc, .stat_totrec, .stat_jpi_dirio-.stat_dirio))
    THEN
	RETURN .stat;	! Signal the error
    lib$put_output(tmp_desc);

    tmp_desc [dsc$w_length] = 80;
    IF NOT (stat = $FAO( %ASCID 'Characters searched:   !10UL       Page faults:       !10UL',
		tmp_desc, tmp_desc, .stat_totchr, .stat_jpi_pageflts-.stat_pageflts))
    THEN
	RETURN .stat;	! Signal the error
    lib$put_output(tmp_desc);

    tmp_desc [dsc$w_length] = 80;
    tim = .stat_jpi_cputim-.stat_cputim;		! get the elapsed CPU time
    IF NOT (stat = $FAO( %ASCID 'Records matched:       !10UL       Elapsed CPU time:!3UL !2ZL:!2ZL:!2ZL.!2ZL',
		tmp_desc, tmp_desc, .stat_totmat,
		(.tim/(100*60*60*24)),		! days
		(.tim/(100*60*60)) MOD 24,	! hours
		(.tim/(100*60)) MOD 60,		! minutes
		(.tim/100) MOD 60,		! seconds
		.tim MOD 100))			! hundredths of seconds
    THEN
	RETURN .stat;	! Signal the error
    lib$put_output(tmp_desc);

    tim_desc [0] = 16;
    tim_desc [1] = tim_buf;
    IF NOT (stat = $GETTIM (TIMADR=quadtime))
    THEN
	RETURN .stat;	! Signal the error
    SUBM (2, quadtime, stat_starttime, quadtime);
    IF NOT (stat = $ASCTIM (TIMLEN=tim_desc, TIMBUF=tim_desc, TIMADR=quadtime))
    THEN
	RETURN .stat;	! Signal the error

    tmp_desc [dsc$w_length] = 80;
    IF NOT (stat = $FAO( %ASCID 'Lines printed:         !10UL       Elapsed time:   !AS',
		tmp_desc, tmp_desc, .stat_totput, tim_desc))
    THEN
	RETURN .stat;	! Signal the error
    lib$put_output(tmp_desc);

    END;
%FI ! switch_statistics

IF .out_file_open				! All through writing
THEN
    $CLOSE(FAB = outfab);

status = ss$_normal;
IF NOT .found_any				! If no matches were found
THEN
	IF .found_file				! set non-success status.
	THEN
		SIGNAL (status = srh$_nomatches)
	ELSE
		status = srh$_nofile;

RETURN .status;
END;

ROUTINE scan_success : NOVALUE =
BEGIN

! Make sure that this file isn't being excluded
!
IF NOT exclude_file()			! Check exclude list
THEN
    BEGIN
    found_file = true;
    search_one_file();			! Open & search a file
    END;

RETURN;
END;

ROUTINE scan_failure : NOVALUE =
BEGIN

    file_error (srh$_openin, .fab [fab$l_sts], fab, .fab [fab$l_stv]);

RETURN;
END;

ROUTINE validate_exclude_file (	in_desc  : REF BLOCK [8, BYTE],
				out_desc : REF BLOCK [8, BYTE]) : NOVALUE =

!++
! Functional description
!
!	This routine checks to see if string_desc is a valid filename
!
! Calling sequence
!
!	validate_exclude_file (in_desc, out_desc)
!
! Input parameters
!
!	in_desc     - Address of any class string descriptor containing a
!		      filename to be validated
!
! Implicit inputs
!
!	none
!
! Output parameters
!
!	out_desc - Address of any class descriptor to receive validated name.
!		   This copy will NOT have node, device or directory.  Leading
!		   zeroes will be stripped from version numbers.  If a name
!		   of the form NAME.TYP; or NAME.TYP;0 is given, the version
!		   will also be stripped.
!
! Implicit outputs
!
!	none
!
! Routine value
!
!	TRUE	- The filename is valid
!	error	- The filename does not parse without errors, the RMS error
!		  code is returned
!
! Side effects
!
!	Errors will be signalled
!
!--

BEGIN

OWN_DZRO
    val_exp	: VECTOR [nam$c_maxrss, BYTE],	! Expanded name string
    val_res	: VECTOR [nam$c_maxrss, BYTE];	! Resultant name string

OWN_CRF
    val_nam	: $NAM (			! File name block
			RSA = val_res,		!  Result name addr
			RSS = nam$c_maxrss,	!  Result name size
			ESA = val_exp,		!  Expanded name addr
			ESS = nam$c_maxrss),	!  Expanded name size
    val_fab	: $FAB(				! Input file FAB
    			DNA = UPLIT BYTE('*.*'),!  Default file spec.
			DNS = 3,		!   (DNM doesn't like *'s)
			NAM = val_nam);		!  Name block

LOCAL
    lve,		! Length from version to end
    len,		! The current length
    adr,		! The current start
    p,			! A pointer into the string
    status;

val_fab [fab$l_fna] = .in_desc [dsc$a_pointer];	! Set name addr
val_fab [fab$b_fns] = .in_desc [dsc$w_length];	! Set name size

IF NOT (status = $PARSE(FAB = val_fab))		! Parse the file spec
THEN
    BEGIN
    file_error (srh$_badexclnam, .status, val_fab, .val_fab [fab$l_stv]);
    RETURN;
    END;

status = $SEARCH(FAB = val_fab);		! Parse the file spec
IF (NOT .status ) AND (.status NEQ RMS$_FNF)
THEN
    BEGIN
    file_error (srh$_badexclnam, .status, val_fab, .val_fab [fab$l_stv]);
    RETURN;
    END;

len = .val_nam [nam$b_esl];		! Get length of expanded string
adr = .val_nam [nam$l_esa];		! Get address of expanded string
p = locate_filename (.len, .adr);	! Skip device and directory
len = .len - (.p - .adr);		! Adjust the length
adr = .p;				! And move the pointer
p = locate_version (.len, .adr);	! Find the version number
lve = .len - (.p - .adr);		! Compute remaining length
WHILE 1				! Trim leading zeroes in length
DO
    BEGIN
    IF (.lve GTR 2) AND (CH$RCHAR(.p+1) EQL '0')
    THEN
	BEGIN
	lve = .lve - 1;		! Remove one from remaining length
	len = .len - 1;		! Also trim one from full length
	CH$MOVE(.lve, .p+2, .p+1);	! Slide it over one byte
	END
    ELSE
	EXITLOOP;
    END;

IF   (.lve LEQ 1)
 OR ((.lve EQL 2) AND (CH$RCHAR(.p+1) EQL '0'))
THEN
    len = .len - .lve;
tmp_desc [dsc$w_length]  = .len;
tmp_desc [dsc$a_pointer] = .adr;
str$copy_dx (.out_desc, tmp_desc);	! Copy to the output descriptor

RETURN;
END;

ROUTINE exclude_file =			! See if the file should be excluded

!++
! Functional description
!
!	This routine checks to see if the current resultant filename in
!	nam_block matches any of the filenames in the exclude list
!
! Calling sequence
!
!	exclude_file()
!
! Input parameters
!
!	none
!
! Implicit inputs
!
!	nam_block	- The NAMe block containing the resultant string
!	exclude_desc	- Array of filenames to exclude
!	cnt_exclude	- Count of items in use in the array
!
! Output parameters
!
!	none
!
! Implicit outputs
!
!	none
!
! Routine value
!
!	TRUE	- The filename matches an item in the exclude list
!	FALSE	- The filename does not match any item
!
! Side effects
!
!	none
!
!--

BEGIN

LOCAL
    p,			! A local character pointer
    lenf,		! Length of file name from nam_block
    adrf,		! Address of  "
    lent,		! Length of target name from exclude list
    adrt;		! Address of  "

IF .cnt_exclude EQL 0 THEN RETURN false;! Don't bother doing anything more

!
! Remove device and directory from the result name
!
lenf = .nam_block [nam$b_rsl];		! Get the res length
adrf = .nam_block [nam$l_rsa];		! Get the result address

p = locate_filename (.lenf, .adrf);	! Look for end of directory
lenf = .lenf - (.p - .adrf);		! Adjust the length
adrf = .p;				! Adjust the pointer

!
! Now compare the file name against each file in the exclude list
!
INCR idx FROM 0 TO .cnt_exclude-1	! No loop if it equals zero
DO
    BEGIN
    !
    ! If the version is not explicitly given in the target, then remove
    ! the version from both the input filename and the target
    !
    lent = .exclude_desc [.idx, dsc$w_length];	! Length of target
    adrt = .exclude_desc [.idx, dsc$a_pointer];	! Address of target

    p = locate_version (.lent, .adrt);		! Look for version in target
    IF .p EQL 0
    THEN			! No version in target, strip from filename
	BEGIN
	p = locate_version (.lenf, .adrf);	! Look for version in filename
	IF .p NEQ 0				! If present
	THEN
	    lenf = .p - .adrf;			! Set length without version
	END;

    IF match_file (.lenf, .adrf, .lent, .adrt)
    THEN
	RETURN true;			! We got a match, exclude this file
    END;

RETURN false;				! Never matched, include this file

END;

ROUTINE locate_version (len, adr) =	! Find version in filename

!++
! Functional description
!
!	This routine finds the version number part of a file specification.
!	Both the standard syntax of NAME.TYP;1 and the alternate syntax of
!	NAME.TYP.1 are allowed.
!
! Calling sequence
!
!	locate_version (.str [dsc$w_length], .str [dsc$a_pointer])
!
! Input parameters
!
!	len - Length of filename string
!	adr - Address of filename string
!
! Output parameters
!
!	none
!
! Implicit inputs/outputs
!
!	none
!
! Routine value
!
!	Address of the character delimiting the version number if found,
!	otherwise 0
!--
BEGIN

LOCAL
    l,				! Remaining length for alternate syntax
    p;				! Local character pointer

p = CH$FIND_CH (.len, .adr, ';');	! Look for version in target
IF .p EQL 0
THEN
    BEGIN
    p = CH$FIND_CH (.len, .adr, '.');	! Check for alternate syntax
    IF .p EQL 0 THEN RETURN false;	! No version
    p = .p + 1;				! Bump past the dot
    l = .len - (.p - .adr);		! Length of remainder
    IF .l LEQ 0 THEN RETURN false;	! It was "NAME.", no version
    p = CH$FIND_CH (.l, .p, '.');	! Look for second dot
    END;

RETURN .p;				! Done, it is zero or pointer

END;

ROUTINE locate_filename (len, adr) =	! Find version in filename

!++
! Functional description
!
!	This routine finds the filename part of a file specification.
!	Node, device and directory are removed from the filespec.
!	Both the standard syntax of [DIR]NAME.TYP and the alternate
!	syntax of <DIR>NAME.TYP are allowed.
!
! Calling sequence
!
!	locate_filename (.str [dsc$w_length], .str [dsc$a_pointer])
!
! Input parameters
!
!	len - Length of filename string
!	adr - Address of filename string
!
! Output parameters
!
!	none
!
! Implicit inputs/outputs
!
!	none
!
! Routine value
!
!	Address of the first character of the filename.  If no node, device
!	or directory is present, then .adr will be returned
!--
BEGIN

LOCAL
    retval,			! Address to return
    p;				! Local character pointer

retval = .adr;				! Assume nothing to remove

p = CH$FIND_CH (.len, .adr, ']');	! Look for end of directory
IF .p NEQ 0
THEN
    retval = .p + 1			! Move the pointer past the ']'
ELSE
    BEGIN
    p = CH$FIND_CH (.len, .adr, '>'); ! Alternate syntax for directory
    IF .p NEQ 0
    THEN
	retval = .p + 1			! Move the pointer past the '>'
    ELSE
	BEGIN
	LOCAL
	    l,
	    a;
	l = .len;			! Get a temporary for the length
	a = .adr;			!  and the address
	WHILE 1				! Loop and remove colons
	DO
	    BEGIN
	    p = CH$FIND_CH (.l, .a, ':');
	    IF .p EQL 0 THEN EXITLOOP;
	    l = .l - (.p - .a + 1);	! Adjust the length
	    a = .p + 1;			! Move the pointer past the ':'
	    END;
	retval = .a;
	END;
    END;

RETURN .retval;				! Pass the address back

END;

ROUTINE match_file (lenf, adrf, lent, adrt) =	! Find version in filename

!++
! Functional description
!
!	This routine compares a filename (result string) with a target
!	filename.  The target filename may contain the wildcard characters
!	"*" and "%".
!
! Calling sequence
!
!	match_file (.lenf, .adrf, .lent, .adrt)
!
! Input parameters
!
!	lenf - Length of filename string
!	adrf - Address of filename string
!	lent - Length of target filename string
!	adrt - Address of target filename string
!
! Output parameters
!
!	none
!
! Implicit inputs/outputs
!
!	none
!
! Routine value
!
!	TRUE (1) if the target name includes the filename, FALSE (0)
!	otherwise
!--
BEGIN

LOCAL
    cht,			! The character from target
    chf;			! The character from the filename

DECR k FROM .lent-1 TO 0
DO
    BEGIN
    lent = .lent-1;			! Decrement target length
    IF .lent LSS 0 THEN SIGNAL_STOP (SS$_BADPARAM);	! Temporary check
    cht = CH$RCHAR_A(adrt);		! Fetch char and bump pointer

    IF .cht EQL '*'		! Found a wildcard in target
    THEN
	BEGIN
	IF .lent EQL 0		! Wildcard at end of target string
	THEN			!  matches everything, return a
	    RETURN true;		!  match
	DECR i FROM .lenf-1 TO 0	! Look through rest of filename
	DO
	    BEGIN
	    IF match_file (.lenf, .adrf, .lent, .adrt)	! Recursively
	    THEN			!  examine rest of filename from this
		RETURN true;	!  point in target, return true if found
	    lenf = .lenf-1;		! Advance one character in the filename
	    adrf = .adrf+1;		!  and repeat recursive call
	    END;
	RETURN false;		! We did not match from wildcard
	END
    ELSE			! No wildcard in target
	BEGIN
	lenf = .lenf-1;			! Decrement the input string
	IF .lenf LSS 0			! If we have exhausted the
	THEN				!  filename string then we did not
	    RETURN false;		!  match and we can return false
	chf = CH$RCHAR_A (adrf);	! Get filename char and bump pointer
	IF NOT (		! If none of the successful tests
		   (.cht EQL .chf)	! Did we match?
		OR (.cht EQL '%')	! Single character wildcard
		OR ((.chf EQL ';') AND	! See if the alternate syntax is
		    (.cht EQL '.')    )	!  in target (assume RMS gives ';')
	       )
	THEN			! We did not match in any way, therefore
	    RETURN false;	!  we can return false from here.
	END;
    END;

IF .lenf EQL 0 THEN RETURN true;	! Matched so far, filename exhausted

RETURN false;			! More characters in filename, no match

END;

ROUTINE search_one_file : NOVALUE =	! Open the file

!++
! Functional description
!
!	This routine opens one file as described by the fab.  Control is then
!	passed to one of the routines which look for one of the search strings
!	and output any occurrences.
!
! Calling sequence
!
!	search_one_file
!
! Input parameters
!
!	none
!
! Implicit inputs
!
!	fab		- The FAB  for the file specification
!	nam		- The related NAMe block
!	rab		- The RAB for the stream
!
! Output parameters
!
!	none
!
! Implicit outputs
!
!	none
!
! Routine value
!
!	novalue
!
! Side effects
!
!	Errors are signaled. Messages are put to SYS$OUTPUT.  Global variables
!	are updated.
!
!--

BEGIN

LOCAL
    status;

IF NOT (status = $OPEN(FAB = fab))		! Open the file
THEN
	BEGIN
	file_error (srh$_openin, .status, fab, .fab [fab$l_stv]);	! Signal the error
	RETURN;					! Exit
	END;

IF NOT (status = $CONNECT(RAB = rab))		! Connect the rab
THEN
	BEGIN
	$CLOSE(FAB = fab);			! Close the file
	file_error (srh$_openin, .status, fab, .rab [rab$l_stv]);	! Signal the error
	RETURN					! Exit
	END;

wdw_pre_buff = 0;				! Initialize the display window
wdw_pre_cntr = 0;
wdw_sub_cntr = 0;
fil_linenum = 0;
fil_totmat = 0;
fil_found = false;
new_file = true;

!
! Search the opened file
!
std_search_file();

%IF switch_statistics
%THEN
    stat_totfil = .stat_totfil+1;	! Bump the count of files
%FI

IF .qua_log
THEN
    BEGIN
    tmp_desc [dsc$w_length] = .nam_block [nam$b_rsl];	! Filename length
    tmp_desc [dsc$a_pointer] = .nam_block [nam$l_rsa];	! Filename address
    IF .fil_found
    THEN
	BEGIN
	LOCAL
	    m_sp;				! Pointer to plural string
	IF .fil_totmat EQL 1
	THEN
	    m_sp = null_str			! No plural
	ELSE
	    m_sp = %ASCID 'es';			! For matches.
	SIGNAL (srh$_matched, 4, tmp_desc, .fil_linenum, .fil_totmat, .m_sp);
	END
    ELSE
	SIGNAL (srh$_nomatch, 2, tmp_desc, .fil_linenum);
    END;

$close(FAB = fab);		! Close the file

END;

ROUTINE get_next_record (len, adr)  : JSB_GETNEXREC =
BEGIN

!++
! Description:
!
!	This routine gets the next record from the current input stream.
!	It returns the length and address of the record.  The routine
!	returns "true" if a record is present, "false" if no record is
!	found.  Calling routines should treat all "false" returns as
!	End of File.  If an actual error occurs, it will be signaled.
!--

OWN_DZRO
    trunc;

LOCAL
    get_recsiz,
    status;

IF .new_file
THEN
    BEGIN
    new_file = false;
    trunc = false;
    END;

status = $GET(RAB = rab);		! Get a record
get_recsiz = .rab [rab$w_rsz];		! Copy length of record

IF (.status EQLU rms$_rtb) OR
   (.status AND (.get_recsiz GTRU io_buff_sz))
THEN
    BEGIN
    get_recsiz = io_buff_sz;
    IF NOT .trunc
    THEN
	BEGIN
	trunc = true;
	tmp_desc [dsc$w_length]  = .nam_block [nam$b_rsl];
	tmp_desc [dsc$a_pointer] = .nam_block [nam$l_rsa];
	SIGNAL (srh$_truncate,2,tmp_desc,io_buff_sz);
	END;
    END
ELSE
    IF NOT .status				! If error
    THEN
	BEGIN
	IF .status NEQ RMS$_EOF		! If not end-of-file
	THEN
	    file_error (srh$_readerr, .status, fab, .rab [rab$l_stv]);
	IF .fil_linenum EQL 0
	THEN
	    BEGIN
	    tmp_desc [dsc$w_length]  = .nam_block [nam$b_rsl];
	    tmp_desc [dsc$a_pointer] = .nam_block [nam$l_rsa];
	    SIGNAL (srh$_nullfile, 1, tmp_desc);
	    END;
	RETURN false;			! and exit
	END;

!
! Bump the statistics info
!
fil_linenum = .fil_linenum + 1;		! Bump the line (record) cntr
%IF switch_statistics
%THEN
    stat_totrec = .stat_totrec + 1;		! Bump the total too
    stat_totchr = .stat_totchr + .get_recsiz;	! Add the character count
%FI

IF .wdw_previous		! Save the window if windowing is active
THEN
    advance_window();

!
! return the length and address and RFA of the new record
!
.len = .get_recsiz;
.adr = .rab [rab$l_rbf];

RETURN true;

END;

ROUTINE advance_window : NOVALUE =
BEGIN
!
! Increment the number of records available for display
!
IF .wdw_pre_cntr LEQU .wdw_pre_recs
THEN
    BEGIN
    wdw_pre_cntr = .wdw_pre_cntr + 1;
    wdw_ovfl = false;
    END
ELSE				! Window can't be contiguous
    wdw_ovfl = true;		! with previous window.
!
! Scroll the window to accomodate the next record, wraparound if needed
!
IF .wdw_pre_buff GTRU .wdw_pre_recs	! if we have hit the end
THEN					! then
    wdw_pre_buff = 1			!  reset to top of array
ELSE					! otherwise
    wdw_pre_buff = .wdw_pre_buff + 1;	!   advance to next position
!
! Save the RFA in the previous record vector
!
CH$MOVE(rab$s_rfa, rab [rab$w_rfa], rfa_vec [.wdw_pre_buff-1,0,0,0,0]);

RETURN;
END;

ROUTINE std_search_file : NOVALUE =			! Searches the file

!++
! Functional description
!
!	This routine searches one file (fab) for one of the search strings
!	and outputs any occurrences.
!
! Calling sequence
!
!	search_file
!
! Input parameters
!
!	none
!
! Implicit inputs
!
!	fab		- The FAB  for the file specification
!	nam		- The related NAMe block
!
! Output parameters
!
!	none
!
! Implicit outputs
!
!	The filename and any occurrences of the string are put to
!	SYS$OUTPUT.
!
! Routine value
!
!	novalue
!
! Side effects
!
!	Errors are signaled. Messages are put to SYS$OUTPUT.
!
!--

BEGIN

WHILE 1 DO					! Main search loop
	BEGIN
	LOCAL
	    rec_siz,		! Length of input record
	    rec_ptr,		! Pointer to record
	    status;

	IF NOT get_next_record (rec_siz, rec_ptr)
	THEN
	    EXITLOOP;

	!
	! See if record contains search string
	!
	IF std_match(.rec_siz, .rec_ptr)	! See if string is present
	THEN
	    BEGIN
	    IF .out_printing			! we know wdw_zero is off
	    THEN
		BEGIN
		IF NOT .fil_found			! If not already found
		    AND (.nam_block [nam$v_wildcard] OR ! and wildcard filespec
			.cnt_infile GTRU 1)		! or list of files
		    AND .qua_heading			! And heading requested
		THEN
		    BEGIN	! Print blank, filename, blank
		    srh$put_output(0, 0);
		    srh$put_output(30, stars_30);
		    srh$put_output(.nam_block [nam$b_rsl], .nam_block [nam$l_rsa]);
		    srh$put_output(0, 0);
		    END
		ELSE
		    BEGIN 
		    IF .fil_found		! If already found,
		    THEN
			BEGIN
			IF      .wdw_frame	! Separate the displays if the
			    AND .wdw_ovfl	! windows are discontiguous
			    AND .qua_heading	! And heading requested
			THEN
			    srh$put_output(15, stars_30);
			END;
		    END;
		!
		! Put the previous records (if any) and the current record
		!
		IF .wdw_pre_cntr LEQ 1
		THEN
		    ! pre_cntr LEQ 1 is our flag then the window EQL 1,
		    ! just print the current record, allowing for reformat
		    !
		    format_n_put(.rec_siz, .rec_ptr, .fil_linenum)
		ELSE
		    BEGIN
		    LOCAL
			status,
			idx;
		    !
		    ! Do a find by RFA to set to start of window
		    !
		    rab [rab$b_rac] = rab$c_rfa;	! Set to random by RFA
		    idx = (.wdw_pre_recs - .wdw_pre_cntr + .wdw_pre_buff + 1)
				MOD (.wdw_pre_recs + 1);
		    CH$MOVE(rab$s_rfa, rfa_vec [.idx,0,0,0,0], rab [rab$w_rfa]);
		    IF NOT (status = $FIND(RAB = rab)) ! Find the record
		    THEN
			BEGIN
			SIGNAL_STOP (srh$_rfaerr, 2, .rfa_vec [.idx,0,0,32,0],
				.rfa_vec [.idx,4,0,16,0], .status, .rab [rab$l_stv]);
			RETURN;
			END;
		    rab [rab$b_rac] = rab$c_seq;	! Back to sequential mode
		    !
		    ! Now do GETs to reread the records for the window
		    !
		    INCRU i FROM 1 TO .wdw_pre_cntr	! Now put the records
		    DO
			BEGIN
			LOCAL
			    actual_line,	! Line number adjusted for wdw
			    len,
			    status;
			status = $GET(RAB = rab);
			len = .rab [rab$w_rsz];	! Get actual length read
			IF (.status EQLU rms$_rtb) OR
			   (.status AND (.len GTRU io_buff_sz))
			THEN
			    len = io_buff_sz	! Would have warned at 1st get
			ELSE
			    IF NOT .status	! If any other error
			    THEN		! signal and stop
				BEGIN
				SIGNAL_STOP (srh$_rfaerr, 2, .rfa_vec [.idx,0,0,32,0],
				    .rfa_vec [.idx,4,0,16,0], .status, .rab [rab$l_stv]);
				RETURN;
				END;
			actual_line = .fil_linenum-(.wdw_pre_cntr-.i);
			format_n_put(.len, .rab [rab$l_rbf], .actual_line);
			END;
		    END;
		wdw_pre_cntr = 0;		! First half of window is done
		wdw_sub_cntr = .wdw_sub_recs;
		END
	    ELSE
		BEGIN
		IF .wdw_zero 			! Print filename if /WIN=0
		THEN 
		    IF NOT .fil_found		! Only need to do it once though
		    THEN
		        srh$put_output(.nam_block [nam$b_rsl], .nam_block [nam$l_rsa]);
		END;
	    fil_found = true;			! Set match flag for this file
	    found_any = true;			! Set global match flag
	    fil_totmat = .fil_totmat+1;		! Count match for this file
	    END
	ELSE			! We don't have a match
	    BEGIN		! If we have subsequent lines to display
	    IF .out_printing AND (.wdw_sub_cntr GTRU 0)
	    THEN
		BEGIN
		format_n_put(.rec_siz, .rec_ptr, .fil_linenum);
		wdw_pre_cntr = 0;	! remember what we've shown.
		wdw_sub_cntr = .wdw_sub_cntr - 1;
		END;
	    END
	END;
RETURN;
END;

ROUTINE std_match (size, buf) : JSB_STDMAT =

!++
! Functional description
!
!	This routine checks to see if any of the search strings
!	is present in the current record
!
! Calling sequence
!
!	std_match(.size, buf);
!
! Input parameters
!
!	size = the length of the record
!	buf  = the address of the record
!
! Implicit inputs
!
!	srhstr_desc	- The array of search string descriptors
!	cnt_srhstr	- The count of search string descriptors
!
! Output parameters
!
!	none
!
! Implicit outputs
!
!	none
!
! Routine value
!
!	0 - None of the search strings was present
!	1 - At least one search string was present
!
! Side effects
!
!	none
!
!--

BEGIN

LOCAL
    rec_ptr	: REF BLOCK [,BYTE],		! Pointer to string
    upc_buf	: BLOCK [io_buff_sz, BYTE],	! In case we must upcase
    match_found;				! String found flag


    IF .qua_exact
    THEN
	rec_ptr = .buf				! Get the input record address
    ELSE
	BEGIN
	upcase(.size, .buf, upc_buf);		! Upcase the record
	rec_ptr = upc_buf;			! Point it to new version
	END;

    match_found = .mat_and;		! 0 if OR or NOR, 1 if AND or NAND

    INCR sdx FROM 0 TO .cnt_srhstr-1
    DO
	BEGIN
	LOCAL
	    ptr;				! Pointer to found string

	ptr = CH$FIND_SUB(.size, .rec_ptr,
				   .srhstr_desc [.sdx, dsc$w_length],
				   .srhstr_desc [.sdx, dsc$a_pointer]);

	IF .mat_and		! If AND or NAND
	THEN
		BEGIN
		IF CH$FAIL(.ptr)
		THEN
		    BEGIN
		    match_found = false;
		    EXITLOOP;
		    END;
		END
	ELSE			! Else OR or NOR
		BEGIN
		IF NOT CH$FAIL(.ptr)
		THEN
		    BEGIN
		    match_found = true;
		    EXITLOOP;
		    END;
		END;
	END;

    IF .mat_negate THEN match_found = NOT .match_found;	! Is it NOR or NAND?

    %IF switch_statistics
    %THEN
	IF .match_found THEN stat_totmat = .stat_totmat+1; ! Bump match count 
    %FI

    RETURN .match_found;
    END;

ROUTINE file_error (	msg,			! The SEARCH message code
			rms_status,		! The main RMS error code
			fabb : REF BLOCK [,BYTE],! Address of FAB for file
			stv) =			! The RMS STV value
BEGIN

LOCAL
    nam_blk : REF BLOCK [,BYTE];	! Pointer to the name block

nam_blk = .fabb [fab$l_nam];		! Get pointer to the name block

IF .nam_blk [nam$b_rsl] GTRU 0
THEN
    BEGIN
    tmp_desc [dsc$w_length]  = .nam_blk [nam$b_rsl];	! Create file name desc
    tmp_desc [dsc$a_pointer] = .nam_blk [nam$l_rsa];	! ...
    END
ELSE IF .nam_blk [nam$b_esl] GTRU 0
THEN
    BEGIN
    tmp_desc [dsc$w_length]  = .nam_blk [nam$b_esl];	! Create file name desc
    tmp_desc [dsc$a_pointer] = .nam_blk [nam$l_esa];	! ...
    END
ELSE
    BEGIN
    tmp_desc [dsc$w_length]  = .fabb [fab$b_fns];	! Create file name desc
    tmp_desc [dsc$a_pointer] = .fabb [fab$l_fna];	! ...
    END;

IF .rms_status EQL rms$_dme		! Does RMS have enough memory?
THEN					! No, print actual error
    BEGIN
    IF .wdw_pre_recs GTR 0		! Do we have a window?
    THEN
	SIGNAL_STOP (.msg, 1, tmp_desc, .rms_status, .stv, srh$_wdw_maxprev)
    ELSE
	SIGNAL_STOP (.msg, 1, tmp_desc, .rms_status, .stv, srh$_insvirmem);
    END
ELSE
    SIGNAL (.msg, 1, tmp_desc, .rms_status, .stv);

RETURN (.msg OR %X'10000000');		! Don't let $EXIT signal also.

END;

ROUTINE upcase(in_siz,in_ptr,out_ptr) : NOVALUE JSB_UPCASE =
!++
! Functional description
!
!	This routine converts a string to uppercase.  In testing it
!	appears to be faster to do this sort of loop than execute the
!	MOVTC instruction on the 11/780.
!
! Input parameters
!
!	in_siz = size of input record to convert
!	in_ptr = address input of record to convert
!	out_ptr = address of output record buffer
!
! Output parameters
!
!	Input record copied to output record buffer and all
!	lowercase alphabetic characters converted to uppercase.
!
!--
BEGIN
REGISTER
    char: BYTE;					! Character to test

DECR count FROM .in_siz-1 TO 0 DO		! Upcase the characters
	BEGIN
	char = CH$RCHAR_A(in_ptr);		!  Get next character
	IF .char GEQU 'a'			!  Lower case letter?
	 AND .char LEQU 'z'
	THEN
		char = .char - %O'40';		! Convert to upper
	CH$WCHAR_A(.char,out_ptr);		! Move character to buffer
	END;
END;

ROUTINE format_n_put(in_siz, in_ptr, line) : NOVALUE JSB_FORPUT =
!++
! Functional description
!
!	The main reason to reformat is to prevent matches in .EXE and
!	.OBJ files from setting terminals in strange states.  The
!	/FORMAT=PASSALL qualifier is included to allow for exotic
!	character sets.
!
!	This routine copies the input buffer to the output file.  If
!	PASSALL is in effect, the input buffer is simply copied to output.
!	If another format is active, a routine will be called to do the
!	reformatting.
!
! Input parameters
!
!	in_siz = size of input record to convert
!	in_ptr = address of input record to convert
!	line = line number to print if .NUMBERS is true
!
! Outputs
!
!	The line will go to the output file if one exists.
!
!--
BEGIN

LOCAL
    len,					! Output length
    op	: REF BLOCK [,BYTE];			! Local output pointer

IF NOT .out_printing
THEN
    RETURN;					! Nothing at all to do

IF (.format EQL form_passall) AND (NOT .qua_numbers)
THEN
    BEGIN
    srh$put_output(.in_siz, .in_ptr);		! Move the buffer.
    RETURN;					! And go back to caller
    END;

!
! We will have to copy the buffer for line numbers or reformatting, or both
!
len = .in_siz;					! Nothing output yet
op = .output_buff;				! Set to start of output

IF .qua_numbers 
THEN
    BEGIN
    LOCAL
	stat,
	tmplen;
    tmp_desc [dsc$w_length] = 7;
    tmp_desc [dsc$a_pointer] = .op;
    IF NOT (stat = $FAO(%ASCID '!6SL	', 0, tmp_desc, .line))
    THEN
	SIGNAL_STOP (.stat);	! Signal the error
    len  = 7+.len;		! Bump our local length.
    op   = 7+.op;		! Bump the pointer to the output
    END;

CASE .format FROM form_text TO form_nonulls OF
    SET
    [form_text]:
		len = format_action_text (.in_siz, .in_ptr, .op);
    [form_passall]:	
		CH$MOVE(.in_siz, .in_ptr, .op);	! Move the input buffer
    [form_dump, form_nonulls]:
		len = format_action_dump (.in_siz, .in_ptr, .op);
    TES;

srh$put_output(.len, .output_buff);		! and then print

RETURN;

END;

ROUTINE format_action_text (len, inp, outp) : JSB_FORACTTEX =
BEGIN

LOCAL
    ip,					! Input pointer
    op,					! Output pointer
    char;				! Local character variable

ip = .inp;
op = .outp;

DECR count FROM .len-1 TO 0 		! Convert the controls
DO
    BEGIN

    char = CH$RCHAR_A (ip);		! Get next character
    char<7,1,0> = 0;			! Clear high bit

    SELECTONE .char OF
	SET
	    [32 TO 126]:	
			BEGIN
			CH$WCHAR_A(.char, op);
			END;

	    [9 TO 13]:	
			BEGIN	! <TAB> <CR> <LF> <VT> <FF> send through as is
			CH$WCHAR_A(.char, op);
			END;

	    [0 TO 8, 14 TO 26, 28 TO 31]:
			BEGIN
			CH$WCHAR_A('^', op);
			CH$WCHAR_A(.char+'@', op);
			END;

	    [27]:	BEGIN	! <ESC>
			CH$MOVE(4, UPLIT BYTE('<ESC'), .op);
			op = .op+4;
			CH$WCHAR_A('>', op);
			END;

	    [127]: 	BEGIN	! <DEL>
			CH$MOVE(4, UPLIT BYTE('<DEL'), .op);
			op = .op+4;
			CH$WCHAR_A('>', op);
			END;

	    [OTHERWISE]:	
			BEGIN
			SIGNAL_STOP (srh$_badlogic);
			END;
	TES;
    END;

RETURN .op-.output_buff;			! Pass the new length back
END;

ROUTINE format_action_dump (len, inp, outp) : JSB_FORACTDUM =
BEGIN

LOCAL
    ip,					! Input pointer
    op,					! Output pointer
    char;				! Local character variable

ip = .inp;
op = .outp;

DECR count FROM .len-1 TO 0 		! Convert the controls
DO
    BEGIN

    char = CH$RCHAR_A (ip);		! Get next character

    IF .char<7,1,0>			! If the high bit is set
    THEN
	BEGIN
	CH$WCHAR_A('%', op);		! Add a '%' to buffer
	char<7,1,0> = 0;		! Clear high bit
	END;

    SELECTONE .char OF
	SET
	    [0]:	BEGIN
			IF .format NEQ form_nonulls
			THEN
			    BEGIN
			    CH$MOVE (2, UPLIT BYTE ('^@'), .op);
			    op = .op + 2;
			    END;
			END;

	    [1 TO 31]:	BEGIN	! All other control characters.
			CH$WCHAR_A('^', op);
			CH$WCHAR_A(.char+'@', op);
			END;

	    [127]: 	BEGIN	! <DEL>
			CH$MOVE(4, UPLIT BYTE('<DEL'), .op);
			op = .op+4;
			CH$WCHAR_A('>', op);
			END;

	    [OTHERWISE]:BEGIN	! All normal characters
			CH$WCHAR_A(.char, op);
			END;
	TES;
    END;

RETURN .op-.output_buff;			! Pass the new length back
END;

ROUTINE srh$put_output(length, buffer) : NOVALUE JSB_PUTOUT =
!++
! Functional description
!
!	Routine to write records to the output file
!
! Input parameters
!
!	length = length of string to output
!	buffer = address of string to output
!
!--
BEGIN

ROUTINE put (len, buf) : NOVALUE =
BEGIN

LOCAL
    status;

outrab [rab$w_rsz] = .len;
outrab [rab$l_rbf] = .buf;

IF NOT (status = $PUT(RAB = outrab))
THEN
    BEGIN

    !+
    ! if the error is due to a record which was too long, shorten the
    ! request and try again
    !-
    IF (
	    (.max_rec GTR 80)		! we aren't pretty short already
	AND
	    (
		(.status EQL RMS$_RSZ)	! error is rec too big (get from tape)
	     OR
		(
		    (.status EQL RMS$_SYS)	! terminal maxbuf error
		 AND
		    (.outrab[rab$l_stv] EQL SS$_EXQUOTA)
		)
	    )
        )
    THEN
	BEGIN
	max_rec = (.len * 90) / 100;	! try with rec 90% as long
	put (.max_rec, .buf);
	RETURN;
	END
    ELSE
	file_error (srh$_writeerr, .status, outfab, .outrab[rab$l_stv]);
    END;

%IF switch_statistics
%THEN
    stat_totput = .stat_totput+1; ! Count this line
%FI

RETURN;
END;

IF .out_file_open
THEN
	BEGIN
	LOCAL
	    len,			! Local length
	    ptr,			! Pointer to current part of buffer.
	    printed;			! Flag that first part printed

	len = .length;			! Copy inputs to local
	ptr = .buffer;
	printed = false;
	!
	! Print the record.  We must allow for a segmented put if the
	! size of the record is larger than the MRS of the output file.
	!
	DO
	    BEGIN
	    IF .printed
	    THEN
		put (11, UPLIT BYTE('(continued)'));
	    put (MIN(.len, .max_rec), .ptr);
	    len = .len - .max_rec;
	    ptr = .ptr + .max_rec;
	    printed = true;
	    END
	UNTIL .len LEQ 0;
	END;
END;

END
ELUDOM
