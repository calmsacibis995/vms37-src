MODULE COPYMAIN (IDENT = 'V03-003',
		MAIN = COPY$COPY
		) =
BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:  COPY
!
! ABSTRACT:
!
!	This utility program creates a copy of one or more user-specified
!	files.  Two or more files may optionally be concatenated to 
!	create a single output file.
!
! ENVIRONMENT:  
!
! AUTHOR:  Ward Clark,	CREATION DATE:  19 August 1977
!
! Modified by:
!
!	V03-003 TSK0003		Tamar Krichevsky	29-Mar-1982
!		Allow /NOTRUNCATE to work for non-contiguous sequential files
!		by correcting the IF statement in COPY$CALC_ALQ which decides 
!		if the output file will be truncated or the same size as
!		the input file.  Previously, non-contiguous sequential files
!		were always being truncated, even if /NOTRUNCATE was specified.
!		Now, if /NOTRUNCATE is given, the allocation of the input file
!		is used for the output file.
!		
!
!	V03-002 TSK0002		Tamar Krichevsky	22-Mar-1982
!		Correct logic in IF statement which forces record mode I/O
!		in RMS_SETUP.  Record mode copies to a foreign disk were being
!		attempted instead of block mode.
!
!	V03-001 TSK0001		Tamar Krichevsky	16-Mar-1982
!		Force record mode operations if input and output devices are 
!		both magtape and one is ANSI while the other is mounted 
!		foreign.
!
!	V021	WMC032		Wayne Cardoza	22-Dec-1981
!		Don't allow copy of a directory as a file.
!		Let the [] be displayed in mag tape log messages.
!
!	V020	WMC026		Wayne Cardoza	10-Dec-1981
!		Fix incorrect ordering of PARSE.
!		Fix log messages for network devices.
!
!	V019	WMC003		Wayne Cardoza	17-Nov-1981
!		Quit when operator aborts a mount request.
!
!	V018	WMC002		Wayne Cardoza	02-Nov-1981
!		Don't try to create directories on record devices.
!		Make sure directory created in correct directory.
!		Don't print directory name for non-directory devices.
!
!	V017	TMH0017		Tim Halvorsen	06-Sep-1981
!		Do not issue "N files created" if the number of files
!		created is only one.
!
!	X0016	KRM0007		Karl Malik	11-Feb-1981
!		Modified COPY$COPY to not attempt to create a directory
!		when the output is a network device. Instead, issue a
!		MSG$_NOTCREDIR (new) warning message and continue.
!
!	X0015	KRM0005		Karl Malik	14-Jan-1981
!		Init the block_count and record_count in CREATE_DIR so as
!		not to use the previous value. Also, modified REPORT_NAMES
!		to issue a "created" message when a subdirectory is created
!		(rather than a "copied" message).
!
!	X0014	LMK0001		Len Kawell	27-Mar-1980
!		Correct computation of USZ and MBC for record mode.
!
!	X0013	TMH0012		Tim Halvorsen	31-Jan-1980
!		Do not use LRL as the USZ for record mode I/O as the LRL
!		can sometimes be incorrect when appending files together
!		with differing LRL's.  COPY should be fixed sometime in
!		the future to make the LRL on a concatenated file correct.
!
!	X0012	JAK0012		J. Krycka	07-Dec-1979
!		Set ASY bit in ROP after $CONNECT when doing block I/O to
!		avoid having to issue a $WAIT after the connect. This is
!		necessary for network block I/O because a network $CONNECT
!		actually causes DAP messages to be exchanged and thus does not
!		complete immediately.
!
!	X00011	TMH0011		T. Halvorsen	19-Dec-1979
!		Do not create a directory on the output side for magtapes.
!
!	X00010	TMH0010		T. Halvorsen	17-Nov-1979
!		Add GLOBAL ROUTINE msg_number from its own module to
!		this module to avoid conflict with require file of the
!		same name in the update procedure.
!		It had one modification:
!				T. Halvorsen	15-Nov-1979
!		Do not add in COPY/APPEND facility unless high-order
!		word is non-zero.
!
!	X00009	TMH0009		T. Halvorsen	24-Oct-1979
!		If input file is a directory file, then either create
!		a directory on the output side or do nothing depending
!		on whether the directory already exists or not.
!
!	X00008	T. Halvorsen	16-Aug-1979
!		Move fixed_overhead to here from COPY.REQ and increase
!		it by another 10 to avoid copy from magtape wsl problems
!
!	X00007	T. Halvorsen	30-Jul-1979
!		Make RMS_SETUP fill the UBF/USZ fields for all device types
!		due to a change in RMS which causes move mode to always be
!		used (locate mode had some timing windows).
!
!	X00006	T. Halvorsen	21-Jul-1979
!		Remove 60 second timeout from input RAB
!
!	X00005	T. Halvorsen	14-Jul-1979
!		Detect insufficient working set size to avoid "internal logic
!		error" message when allocating negative amount of storage.
!
!	X00004	JAK0004		J. Krycka	16-Mar-1978	15:00
!		To support file append over the network, omit 'incompatible
!		attributes' check if NET bit is set.
!
!	X00003	JAK0003		J. Krycka	16-Mar-1978	14:30
!		To support copy of files in VFC format over the network,
!		put RHB address in both input and output RABs if NET bit is set.
!
!
! 01	18-04-78	C. Peters	Change INCLUDE file declarations to suit VMS native compiles.
!					Remove SHR$_HASHCONCAT, SHR$_INCOMPAT literals.
! 02	18-04-78	C. Peters	Change COPY to reflect modified behavior.
!	Include COPY.REQ. Delete LITERAL definitions for general use, status flags. Delete
!		macro definitions for commonly used status flags.
!	Rename COPY_STATUS to COPY$CLI_STATUS.
!	Don't include RMSMAC.L32, STARDE.L32. Include STARLET.L32 from SYS$LIBRARY.
!		Delete external literal declarations of RMS status codes. They are in STARLET.L32 too.
!	Delete GLOBAL variable COPY$CLI_STATUS. Put it in a new module, COPYGBL.B32.
!	Instead of calling GET_OUTFILE, call COPY$GET_OUTFIL, in COPYSPECS.
!	Delete GET_OUTFILE.
!	Instead of calling GET_INFILE, call COPY$GET_INFILE, in COPYSPECS.B32.
!	Delete GET_INFILE from this module.
!	Instead of calling OPEN_INFILE, call COPY$OPN_INFILE, in COPYSPECS.
!	Delete OPEN_INFILE.
!	Rename IN_OPEN_ERROR to COPY$INOPN_ERR; OUT_OPEN_ERROR to COPY$OUTOPN_ERR;
!		CLOSE_OUTFILE to COPY$CLOSE_OUTF.
!	Instead of calling OPEN_OUTFILE, call COPY$OPN_OUTFIL, in COPYSPECS.
!	Rename OUT_CLOSE_ERROR to COPY$OCLOSE_ERR.
!	Remove declaration for STS$K_INFO. Put this in COPY.REQ.
!	Remove declaration for VMSMAC.L32, put it in COPY.REQ.
!	Delete routine OPEN_OUTFILE. This routine is replaced by COPY$OPN_OUTFIL, in COPYSPECS.
!	Rename CALCULATE_ALQ to COPY$CALC_ALQ and make it a global routine.
!	Rename MESSAGE_NUMBER to COPY$MSG_NUMBER and make it a global routine.
!	Rename CLI_RESULT to COPY$CLI_RESULT. Declare it a global in COPYGBL.
!	In main routine, close output file is flag MULTIPLE_OUTPUT is set, instead of testing
!		for the CONCAT_FOLLOWS flag being not set.
!	Move setting of CONCAT_QUAL and NOCONCAT_QUAL into the routine GET_CMD_QUAL.
!	Move OUTFILE_OPEN and APPEND_COMMAND bits into COPY$SEM_STATUS from COPY$CLI_STATUS.
!	Remove RMS declarations for input file descriptions to file called FILINPUT.B32.
!	Remove RMS declarations for output file descriptions to file called FILOUTPUT.B32.
!	Rename PARSE_INFILE to COPY$PARS_INFIL.
!	Move PUT_MESSAGE and PUT_MESSAGEX macro definitions to include file COPYMSG.REQ.
!	Move routine COPY$MSG_NUMBER to new module, COPYMSG.B32.
!	In CALC_ALQ, if /TRUNCATE was specified without /ALLOCATION, calculate allocation
!		value based on actual EOF of input file.
!	Add a global variable COPY$B_INCOMPAT. If this variable is set, don't output
!		incompatible attributes message because it has already been output once
!		for this output file.
!	In RMS_SETUP, when setting the MBC and MBF fields for a record mode copy,
!		set the MBC field to the size of the input file only the size is less than or
!		equal to 127 blocks. Otherwise, MBC goes negative.
!	In RMS_SETUP, a record mode copy from disk or tape loads RAB$W_USZ from XAB$W_LRL if
!		non-zero; otherwise, FAB$W_BLS.
!
!--

!++
! DETAILED FUNCTIONAL DESCRIPTION:
!
!	This utility program creates a copy of one or more user-specified
!	files.  These files can be explicitly named or can be referred to
!	through use of RMS wildcard file naming.  Two or more files may
!	optionally be concatenated to create a single output file.
!
!	All file I/O is done using standard RMS facilities.  Therefore,
!	the input and output files can exist on any device supported by RMS,
!	including devices at remote network nodes.  If possible, file copying
!	is done using block I/O.  Record I/O is used only when an input or
!	output file is record oriented (e.g., terminal, unit record) or when
!	a concatenated file is being copied.
!
!	This utility is intended to interface directly with a Command Language
!	Interpreter (CLI) and cannot be directly invoked from Command Language
!	level or from an executing program.  Numerous command options
!	(i.e., qualifiers) are supported to allow the Command Language user
!	to (1) optionally specify the location and attributes of the input
!	and output files, and (2) control the reporting of each file copy.
!
!	If more than one copy operation is specified in a single COPY request,
!	each file copy is performed independent of the others.  Therefore,
!	the failure of one file copy operation (e.g., I/O error, input
!	file not found) does not affect the remaining copy requests.  The
!	single exception to this rule is that unprocessed concatenated input
!	files are bypassed in the event of a file copy failure.
!
!--

!	NOTE:  This module contains some temporary code that (1) circumvents
!	a system problem or (2) cannot be implemented until an expected
!	system function is available.  In some cases, codes have been added;
!	in other cases, code has been "commented out".  In either case, each
!	statement affected includes a comment of the form "!#n", where "n" is
!	a number from the following table:
!
!		#1 - symbol not currently defined in STARLET.L32
!		#2 - I/O buffers cannot be locked in working set - known restriction
!		#3 - MODIFY does not accept FHC XAB - future feature

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    COPY$COPY,						! Main COPY control routine
    CREATE_DIR, 					! Create directory file
    RMS_SETUP,						! RAB/buffer initialization
    COPY_FILE,						! Copies an input file to the output file
    CLOSE_INFILE :  NOVALUE,				! Closes the current input file
    COPY$CLOSE_OUTF :  NOVALUE,				! Closes the current output file
    RMS_CLEANUP :  NOVALUE,				! RAB/buffer cleanup
    BYPASS_CONCAT :  NOVALUE,				! Bypass concatenated input files after an error
    COPY$PARS_INFIL,					! Parse an input file-specification
    COPY$CALC_ALQ,					! Calculate the output file allocation quantity
    REPORT_NAMES :  NOVALUE,				! Report names of input and output files
    REPORT_BYPASS :  NOVALUE,				! Report name of file bypassed
    COPY$LOG_MSG :  NOVALUE,				! Informational message routine
    COPY$INOPN_ERR :  NOVALUE,				! Input open error routine
    IN_READ_ERROR :  NOVALUE,				! Input read error routine
    IN_CLOSE_ERROR :  NOVALUE,				! Input close error routine
    COPY$OUTOPN_ERR :  NOVALUE,				! Output open error routine
    OUT_WRITE_ERROR :  NOVALUE,				! Output write error routine
    COPY$OCLOSE_ERR :  NOVALUE,				! Output close error routine
    COPY$MSG_NUMBER;					! Compute message number

!
! INCLUDE FILES:
!

LIBRARY 'SYS$LIBRARY:STARLET.L32';			! VAX/VMS common definitions

LIBRARY	'SYS$LIBRARY:CLIMAC.L32';			! CLI macros

REQUIRE	'SRC$:COPY.REQ';				! COPY literal definitions and macros

REQUIRE 'SRC$:COPYMSG.REQ';				! Definition of macros to SIGNAL a message

!
! MACROS:
!

MACRO
    IN_NEQ_OUT[] =					! Compare input and output FHC XAB field
	.INFILE_XABFHC[%REMAINING] NEQ .OUTFILE_XABFHC[%REMAINING] %,

    NAM$B_DVILNG = $DEFINE_BYTE[NAM$T_DVI] %,

    $DEFINE_BYTE( D, B, S, X ) = D, B, 8, 0 %;

!
! EQUATED SYMBOLS:
!

LITERAL
    RME$K_OVERLAY = 0;					!#1 ***** KLUDGE *****

!
! Global variables
!

GLOBAL
    OUTFILE_COUNT :  INITIAL (0),			! Number of output files created

    BLOCK_COUNT,					! Number of input blocks copied (current file)

    RECORD_COUNT,					! Number of input records copied (current file)

    MOST_SEVERE_ERR :  BLOCK[4,BYTE]			! Most severe error encountered
			INITIAL( SS$_NORMAL ),		!

    IO_BUFFER_SIZE :  INITIAL(0),			! Maximum size of I/O buffer pool

    IO_BUFFER_BASE,					! Address of I/O buffer pool
    IO_BUFFER_END :  INITIAL(0),			! Address of last byte of block I/O buffer

    BLOCK_SIZE,						! Input file block size
    BLOCK_IO_LENGTH;					! Block I/O read length (may be multi-block)

!
! EXTERNAL REFERENCES:
!

EXTERNAL
    alloc_value,					! Allocation value specified by user.
    copy$b_incompat	: BYTE,				! Incompatible attributes flag

!
! CLI definitions
!

    cleanup_desc	: BLOCK [, BYTE],		! CLI end of parameter work area
    cli_work_area	: BLOCK [, BYTE],		! CLI dynamic work area
    infile_desc		: BLOCK [, BYTE],		! CLI data block for input file
    initial_desc	: BLOCK [, BYTE],		! CLI data block for COPY and APPEND commands
    outfile_desc	: BLOCK [, BYTE],		! CLI data blick for output file
    copy_trun_qual	: BLOCK [, BYTE],		! CLI data block for the truncation qualifier (this is
    							! needed for calculating the allocation quantity

!
! RMS definitions
!

    infile_fab		: BLOCK [, BYTE],		! Input file FAB block
    infile_rab		: BLOCK [, BYTE],		! Input file RAB block
    infile_name		: VECTOR [, BYTE],		! Input file name after $OPEN
    infile_xname	: VECTOR [, BYTE],		! Input file name before $OPEN
    dummy_nam_blk	: BLOCK [, BYTE],		! Secondary input NAM block
    infile_nam_blk	: BLOCK [, BYTE],		! Primary input NAM block
    infile_xabfhc	: BLOCK [, BYTE],		! File header characteristics XAB block
    infile_xaball	: BLOCK [, BYTE],		! File allocation XAB block
    in_name_desc	: VECTOR,			! Input file name descriptor
    outfile_fab		: BLOCK [, BYTE],		! Output file FAB block
    outfile_rab		: BLOCK [, BYTE],		! Output file RAB block
    outfile_name	: VECTOR [, BYTE],		! Output file name after $OPEN
    outfile_xname	: VECTOR [, BYTE],		! Output file name before $OPEN
    outfile_nam_blk	: BLOCK [, BYTE],		! Output file NAM block
    outfile_xabrdt	: BLOCK [, BYTE],		! Output file revision date/time XAB block
    outfile_xabpro	: BLOCK [, BYTE],		! Output file protection XAB block
    outfile_xabdat	: BLOCK [, BYTE],		! Output file date XAB block
    outfile_xaball	: BLOCK [, BYTE],		! Output file allocation XAB block
    outfile_xabfhc	: BLOCK [, BYTE],		! Output file file header characteristics XAB block
    out_name_desc	: VECTOR;			! Output file name descriptor

EXTERNAL ROUTINE
    COPY$GET_INFILE,					! Gets the name of the input file
    COPY$GET_OUTFIL,					! Gets the name of the output file
    COPY$OPN_INFILE,					! Opens the input file
    COPY$OPN_OUTFIL,					! Opens an output file
    GET_CMD_QUAL,					! Get command level qualifiers
    SYS$ADJWSL :  ADDRESSING_MODE(GENERAL),		! Adjust-working-set-limit system service
    SYS$LKWSET :  ADDRESSING_MODE(GENERAL),		! Lock-in-working-set system service
    SYS$ULWSET :  ADDRESSING_MODE(GENERAL),		! Unlock-from-working-set system service
    LIB$GET_VM :  ADDRESSING_MODE(GENERAL),		! Virtual memory allocation
    LIB$CHECK_DIR :  ADDRESSING_MODE(GENERAL),		! Determine if file is a directory
    LIB$CREATE_DIR :  ADDRESSING_MODE(GENERAL);		! Create a directory file

ROUTINE COPY$COPY =					! Primary COPY control routine

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is the primary control routine for the COPY utility.
!	It determines the basic logical flow and calls support routines
!	which perform each logical function.
!
! FORMAL PARAMETERS:
!
!	AP.rlu.va - Argument list passed from the Command Language Interpreter
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	None
!
! COMPLETION CODES:
!
!	Most severe error encountered during processing or SS$_NORMAL
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    BUILTIN
	AP;						! Declare the name of the argument pointer.

    BIND
	ARGUMENT_LIST = AP :  REF BLOCK[,BYTE];		! Declare the form of the argument list.

    LOCAL
	ptr,						! Temporary variables for character searching
	address,
	size,
	STATUS;						! General routine return code

!
! Initialization
!

    COPY$CLI_RESULT = .ARGUMENT_LIST[CLI$A_UTILSERV];	! Save the address of the CLI result parse routine

    CALL_CLI(						! Call the CLI with the following arguments:
		INITIAL_DESC,				!    CLI initialization request descriptor address
		CLI_WORK_AREA,				!    CLI work area address
		COPY$CLI_STATUS );			!    COPY status bit vector address

!
! Changed this to set CONCATINP bit instead of MOREINP bit, since having the /CONCATENATE
! qualifier on by default makes all commas into plus signs.
!

    INFILE_DESC [CLI$V_CONCATINP] = YES;		! Needed to allow a retrieve of
							! the first input file-specification.

!
! Get the command qualifiers from the Command Language Interpreter (CLI).
!

    GET_CMD_QUAL();					! Get the command qualifiers.

!
! Get the output file-specification and all qualifiers from the CLI.
!

    IF NOT COPY$GET_OUTFIL (				! Get the output file spec from the CLI.
                            OUTFILE_FAB,		!    Specify the output FAB block address,
                            OUTFILE_NAM_BLK,		!    the output NAM block address,
                            OUTFILE_XABFHC)		!    and the output XABFHC block address.
    THEN
        RETURN .MOST_SEVERE_ERR;			!    On error, return to CLI.

!
! The remainder of this routine is executed for each input
! file-specification supplied by the user.
!

    WHILE 1 DO						! Beginning of repeat loop
	BEGIN

!
! Get the next input file-specification from the CLI.  This routine call is a
! NOP if a wildcard file-specification is currently being processed;
! that is, a wildcard specification is repeatedly used until no furthur
! match is found.
!

	STATUS = COPY$GET_INFILE (			! Get an input file-specification.
                                    INFILE_FAB,		!    Specify the address of the input FAB block,
                                    INFILE_NAM_BLK,	!    the address of the input NAM block,
                                    INFILE_XABALL);	!    and the address of the input XABALL block.

	IF .STATUS EQL NO_MORE_FILES			! If there are no more input file-specs,
	THEN						!
	    EXITLOOP;					! exit the input file-spec processing loop.

	IF .STATUS EQL OK				! If everything is OK so far,
	THEN						!
	    BEGIN					! begin normal input file processing.

!
! Open the current input file.
!

	    STATUS = COPY$OPN_INFILE (INFILE_FAB);	! Open the current input file.

!
! If the input file is a directory file, then create the directory file
! on the output side if the file does not already exist.  If the output
! directory already exists, then do nothing.
!

            IF .status EQL ok			! If input opened ok,
		AND lib$check_dir (infile_fab)	! and file is a directory,
		AND NOT .outfile_fab [$FAB_DEV(sdi)] ! and not magtape output,
	    THEN
		IF NOT .outfile_fab[$FAB_DEV(net)]
		    AND NOT .outfile_fab [$FAB_DEV(rec)] ! and not record device,
		THEN
			BEGIN
			IF (.outfile_nam_blk[nam$v_exp_name] AND
				(NOT .outfile_nam_blk[nam$v_wild_name])) OR
			    (.outfile_nam_blk[nam$v_exp_type] AND
				(NOT .outfile_nam_blk[nam$v_wild_type])) OR
			    (.outfile_nam_blk[nam$v_exp_ver] AND
			        (NOT .outfile_nam_blk[nam$v_wild_ver]))
			THEN
			    BEGIN
			    report_bypass(msg$_illdircopy);
			    close_infile();			! Close input file
			    END
			ELSE
			    BEGIN
			    status = create_dir (infile_fab, outfile_fab);
			    IF .status EQL ss$_created	! If file actually created,
			    THEN
				BEGIN
				report_names();		! Report file copied
				outfile_count = .outfile_count + 1;
				END;
			    IF NOT .status			! If successful,
			    THEN
				report_bypass(msg$_notcopied); ! Else report failure
			    close_infile();			! Close input file
			    END
			END
		ELSE
			BEGIN
			report_bypass(msg$_dirnotcre);	! Else report failure
			close_infile();			! Close input file
			END
	    ELSE
	    BEGIN
		

!
! Create (or simply open) the output file (if it is not already open due to
! input file concatenation) and then copy the entire input file to the
! output file.
!

	    IF .STATUS EQL OK				! If the input file was successfully opened,
	    THEN					!
		BEGIN					!
		IF (STATUS = COPY$OPN_OUTFIL (		! create or open the output file unless it is
                                                OUTFILE_FAB,
                                                OUTFILE_RAB,
                                                INFILE_FAB,
                                                OUTFILE_COUNT))
							! already open due to input concatenation.
		THEN
		    IF (STATUS = RMS_SETUP())		! Setup the input and output RABs and buffers.
		    THEN
			BEGIN
			IF (STATUS = COPY_FILE())	! Copy the entire input file to the output file.
			THEN
			    BEGIN
		    	    IF .outfile_fab [$FAB_DEV(rec)] 
				AND NOT .outfile_fab [$FAB_DEV(net)] 
			    THEN
				BEGIN
				size = .out_name_desc[0];
				address = .out_name_desc[1];
				ptr = CH$FIND_CH(.size,.address,':');
				IF .ptr NEQ 0		! If there is anything past the device, remove it
				THEN
				    out_name_desc[0] =  .ptr - .address + 1;
				END;
			    REPORT_NAMES()		! Report the results if the copy was successful.
			    END
			ELSE				! Otherwise, report a partial copy.
			    REPORT_BYPASS( MSG$_NOTCMPLT );

			RMS_CLEANUP();			! Perform any necessary RMS/buffer cleanup.
			END
		    ELSE
		ELSE					! If the output file couldn't be opened,
		    REPORT_BYPASS( MSG$_NOTCOPIED);	! indicate the input file wasn't copied.
		END;

	    CLOSE_INFILE();				! Close the input file.

	    END;					! End of ELSE clause
	    END;					! End of processing a single input file specification.

!
! Bypass any concatenated input files if an error occurred during the file copy.
!

	IF NOT .STATUS					! If the input file was not successfully copied,
	THEN						!
	    BYPASS_CONCAT();				! bypass any concatenated input files.

!
! Close the output file unless another input file is to be
! concatenated to the output file just written.
!

	IF .MULTIPLE_OUTPUT AND NOT .APPEND_COMMAND	! If multiple output files are being created,
	THEN						!    and the command was not APPEND,
            BEGIN
	    COPY$CLOSE_OUTF();				! close the current output file, if any.
            OUTFILE_XABALL[XAB$L_NXT] = OUTFILE_XABDAT;	! Reinitialize XAB chain for new output file.
            OUTFILE_XABDAT[XAB$L_NXT] = OUTFILE_XABPRO;	!    This is due to possible XAB list alteration
            OUTFILE_XABPRO[XAB$L_NXT] = OUTFILE_XABRDT;	!    in routine SETUP_CONC_XAB in COPYSPECS.
            END;

	END;						! End of "WHILE 1 DO" input file-spec processing loop.

!
! Perform any necessary cleanup before exiting.
!

    CLOSE_INFILE();					! Close the current input file if it is open.

    COPY$CLOSE_OUTF();					! Close the output file if it is open.

    COPY$LOG_MSG( MSG$_NEWFILES );			! Report the number of files created.

!
! Return to the caller.
!

    RETURN .MOST_SEVERE_ERR;				! Use the most severe error encountered
							! as the completion code from this routine.

    END;

ROUTINE CREATE_DIR (input_fab, output_fab) =

!---
!
!	This routine is called to create a directory file on
!	the output side if the directory does not already exist.
!	If the directory already exists, do nothing.
!
! Inputs:
!
!	input_fab = Address of FAB describing opened directory file
!	output_fab = Address of FAB describing the device and directory
!			into which the directory file should be created.
!
! Outputs:
!
!	Routine value = status return
!---

BEGIN

MAP
    input_fab:	REF BLOCK[,BYTE],	! Input FAB
    output_fab:	REF BLOCK[,BYTE];	! Output FAB

BIND
    input_nam = .input_fab [fab$l_nam]: BLOCK[,BYTE],
    output_nam = .output_fab [fab$l_nam]: BLOCK[,BYTE];

LOCAL
    ptr,				! String temporary pointer
    addr,size,				! descriptor of search string
    buffer:	VECTOR [nam$c_maxrss,BYTE], ! file spec buffer
    bufdesc:	VECTOR [2],		! descriptor of above buffer
    terminator:	BYTE,			! Directory spec. terminator
    status;				! status variable

record_count = 0;			! Initialize the record count
block_count  = 0;			! Initialize the block count

status = $RMS_PARSE (FAB = .output_fab); ! Get full name of directory file

size = .output_nam [nam$b_esl];		! Get output expanded name
addr = .output_nam [nam$l_esa];

IF NOT .status
THEN
    BEGIN
    put_messagex(.status);
    RETURN .status;
    END;

ptr = CH$FIND_CH(.size, .addr, ']');	! Find end of directory spec
IF .ptr EQL 0				! If not found,
THEN
    BEGIN
    ptr = CH$FIND_CH(.size, .addr, '>');   ! Alternate syntax
    IF .ptr EQL 0			! If still not found,
    THEN
	put_message(rms$_esa);		! return invalid expanded string
    END;

size = .ptr + 1 - .addr;		! Figure length of device and dir.
CH$MOVE(.size, .addr, buffer);		! Copy device and directory into buffer
terminator = .buffer [.size-1];		! Remember terminator on dir. spec.
buffer [.size-1] = '.';			! and overwrite it with '.'

bufdesc [0] = .size;			! Setup buffer descriptor
bufdesc [1] = buffer;

size = .input_nam [nam$b_rsl];		! Get input result name
addr = .input_nam [nam$l_rsa];

ptr = CH$FIND_CH(.size, .addr, ']');	! Find start of file name on input side
IF .ptr EQL 0				! If not found,
THEN
    BEGIN
    ptr = CH$FIND_CH(.size, .addr, '>'); ! Alternate syntax
    IF .ptr EQL 0			! If still not found
    THEN
	put_message(rms$_esa);		! return invalid expanded string
    END;

size = .size - (.ptr + 1 - .addr);	! Figure descriptor of file name
addr = .ptr + 1;

ptr = CH$FIND_CH(.size, .addr, '.');	! Find where file name ends
IF .ptr EQL 0				! If not found,
THEN
    RETURN rms$_esa;			! return invalid expanded string
size = .ptr - .addr;			! Figure descriptor of file name only

CH$MOVE(.size, .addr, buffer+.bufdesc[0]); ! Append subdirectory name to buffer
buffer [.bufdesc[0]+.size] = .terminator;  ! Tack terminator on end of it
bufdesc [0] = .bufdesc[0] + .size + 1;	! Update string descriptor

out_name_desc [0] = .bufdesc [0];	! Copy length of string
CH$MOVE(.bufdesc[0], .bufdesc[1], .out_name_desc[1]);	! and string too

status = LIB$CREATE_DIR (bufdesc);	! Create directory file with defaults

IF NOT .status				! If error detected,
THEN
    put_messagex(.status);		! then signal status

RETURN .status;				! return with status

END;

ROUTINE RMS_SETUP =					! RMS RAB setup routine

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine performs all necessary setup of the input and output file RABs:
!
!		* determine if record-mode is required
!		* allocate I/O buffers
!		* lock block I/O buffers in working set
!		* connect the RABs to their respective FABs
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	EXTEND_OUTFILE - Indicates output file is being extended
!	IO_BUFFER_SIZE - Size of the dynamic I/O buffer
!	INFILE_FAB - Input file FAB
!	OUTFILE_FAB - Output file FAB
!	INFILE_XABs - Input file XABs
!
! IMPLICIT OUTPUTS:
!
!	INFILE_RAB - Input file RAB completed and connected
!	OUTFILE_RAB - Output file RAB completed and connected
!	IO_BUFFER_SIZE - Size of dynamic I/O buffer (1st call only)
!	IO_BUFFER_BASE - Address of dynamic I/O buffer (1st call only)
!	IO_BUFFER_END - Address of last byte of block I/O buffer
!	BLOCK_IO_SIZE - Length of block I/O operations
!
! COMPLETION CODES:
!
!	OK = normal completion
!	ERROR = RAB connect unsuccessful
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

LITERAL
    fixed_overhead	=				! COPY process working set overhead (pages)
                          15 +				!    COPY - stack, own storage, COPY_FILE code
                          30 +				!    VMS process overhead - guess
                          5;				!    RMS code (2), IFABs & IRABs (2), exec stack

    LOCAL
	IN_DEVICE :  BLOCK[1,BYTE],			! Selected input and output
	OUT_DEVICE :  BLOCK[1,BYTE],			! device characteristics

	FORCE_REC_MODE,					! Temporary record-mode I/O indicator
	WORK_SET_SIZE,					! Number of pages in the current working set
	AMT_BUFFER_USED,				! Amount of the dynamic buffer allocated
	STATUS,						! System service completion code
	MAX_MBC,					! Temporary multi-block-count
	MBC,						! Temporary multi-block-count
        END_BLOCK_NO,					! Temporary count of blocks in file.
	MBF;						! Temporary multi-buffer-count

    MACRO						! IN_DEVICE and OUT_DEVICE bit definitions:
	DISK = 0,0,1,0 %,				!    disk device
	TAPE = 0,1,1,0 %;				!    tape device

!
! Allocate a maximum size I/O buffer pool on the 1st call to this routine.
!

    IF .IO_BUFFER_SIZE EQL 0				! If the buffer pool has not been allocated,
    THEN						! create one which is slightly smaller than the
	BEGIN						! current working set limit.

	STATUS = SYS$ADJWSL( 0, WORK_SET_SIZE );	! Add zero pages to the working set in order
							! to find out how large it actually is.

	IF NOT .STATUS					! If the adjustment fails,
	THEN						!
	    PUT_MESSAGE( MSG$_BADLOGIC, 0,		! die with a 3-line error message.
			.STATUS, 0,			!
			MSG$_ATPC, 1 );			!

	IO_BUFFER_SIZE = PAGE_SIZE *			! Calculate the size of the buffer pool.
		(.WORK_SET_SIZE - FIXED_OVERHEAD);	!

	IF .io_buffer_size LSS 5*disk_block_size	! If not enough working set,
	THEN						! (leaving 5 blocks for I/O buffers)
	    put_message(ss$_insfwsl);			! Report insufficient working set size

	STATUS = LIB$GET_VM(				! Obtain a dynamic buffer pool
		IO_BUFFER_SIZE,				! which is slightly smaller than the current working set.
		IO_BUFFER_BASE );			! Save the address of the buffer pool.

	IF NOT .STATUS					! If the necessary area cannot be allocated,
	THEN						!
	    PUT_MESSAGE( MSG$_BADLOGIC, 0,		! die with a 3-line error message.
			.STATUS, 0,			!
			MSG$_ATPC, 1 );			!
	END;

!
! Extract some device information from the input and output file FABs.
!

    IN_DEVICE = 0;					! Clear the input and output
    OUT_DEVICE = 0;					! device characteristics.

    IN_DEVICE[DISK] =					! Turn on the input file disk indicator
	.INFILE_FAB[$FAB_DEV(FOD)] AND			! if the input device is file-structured
	NOT .INFILE_FAB[$FAB_DEV(SQD)];			! and it is not a tape device.

    IN_DEVICE[TAPE] =					! Turn on the input file tape indicator
	.INFILE_FAB[$FAB_DEV(SQD)];			! if the input device is a tape.

    OUT_DEVICE[DISK] =					! Turn on the output file disk indicator
	.OUTFILE_FAB[$FAB_DEV(FOD)] AND			! if the output device is file-structured
	NOT .OUTFILE_FAB[$FAB_DEV(SQD)];		! and it is not a tape device.

    OUT_DEVICE[TAPE] =					! Turn on the output file tape indicator
	.OUTFILE_FAB[$FAB_DEV(SQD)];			! if the output device is a tape.

!
! Determine whether the input and output files have compatible attributes.
!

							! Compare the following input and output XAB fields:
    IF IN_NEQ_OUT(XAB$B_RFO) OR				!    record format and file organization
	IN_NEQ_OUT(XAB$B_ATR) OR			!    record attributes
	IN_NEQ_OUT(XAB$B_BKZ) OR			!    bucket size
	IN_NEQ_OUT(XAB$B_HSZ) OR			!    fixed header size
	(.OUTFILE_XABFHC[XAB$W_MRZ] NEQ 0 AND		!    maximum output record size (if any)
	 .OUTFILE_XABFHC[XAB$W_MRZ] LSS			!       and longest input record
		.INFILE_XABFHC[XAB$W_LRL])		!
    THEN
	BEGIN						! If the input and output attributes are not identical,
        IF NOT .COPY$B_INCOMPAT				! and this message has not appeared yet
        THEN						! for this output file,
            BEGIN
	    IF NOT .INFILE_FAB[$FAB_DEV(NET)] THEN	! and this is not a network operation,
            PUT_MESSAGE( MSG$_INCOMPAT, 2,		! send the user a warning message
                    IN_NAME_DESC, OUT_NAME_DESC );	!
            COPY$B_INCOMPAT = TRUE;			! Set flag saying that message is out.
            END;
	FORCE_REC_MODE = YES;				! and force a record-mode copy.
	END
    ELSE
	FORCE_REC_MODE = NO;				! Otherwise, turn the record-mode indicator off.

!
! Initialize the input and output RABs.
!

    $RAB_INIT( RAB = INFILE_RAB,			! Setup the input file RAB as follows:
		RAC = SEQ,				!    Sequential record access
		ROP = <LOC,RAH>,			!    GET locate, read ahead
		FAB = INFILE_FAB);			!    Input file FAB address

    $RAB_INIT( RAB = OUTFILE_RAB,			! Setup the output file RAB as follows:
		RAC = SEQ,				!    Sequential access
		FAB = OUTFILE_FAB,			!    Output file FAB address
		ROP = <TPT,WBH> );			!    Force EOF on every write or put,
							!    and specify write behind for multi-buffering.

!
!
! Determine whether record-mode I/O is required for this file copy operation.
! At least one of the following conditions must be true for record mode
! operations to be performed:
! 	    - the input and output attributes are incompatible,
! 	    - the output file is being extended,
!	    - the input and output devices are not the same type,
!	    - both devices are record mode devices,
!	    - this is a tape-to-tape copy AND
!		the input and output blocksizes are not the same
!    			OR
!		one tape is mounted foreign and the other is ANSI.
!

    IF .FORCE_REC_MODE
	    OR
	.EXTEND_OUTFILE
	    OR
	.IN_DEVICE NEQ .OUT_DEVICE
	    OR
	.IN_DEVICE EQL 0
	    OR
	(
	.INFILE_FAB [$FAB_DEV (SQD)]
	    AND
	(
	    ( .INFILE_FAB [FAB$W_BLS] NEQ .OUTFILE_FAB [FAB$W_BLS] )
    	    OR
	    ( .INFILE_FAB [$FAB_DEV (FOR)] NEQ .OUTFILE_FAB [$FAB_DEV (FOR)] )
	)
	)
!
! Record mode I/O setup.
!

    THEN
	BEGIN
	RECORD_MODE = YES;				! Indicate (1) that record mode is required,
	INFILE_RAB[RAB$V_BIO] = NO;			! (2) that block I/O will not be used
	OUTFILE_RAB[RAB$V_BIO] = NO;			! for this file,
	INFILE_RAB[RAB$V_ASY] = NO;			! and (3) that both reading and writing
	OUTFILE_RAB[RAB$V_ASY] = NO;			! will be synchronous.
	INFILE_RAB[RAB$L_UBF] = .IO_BUFFER_BASE;	! Set the user buffer address.

	IF .IN_DEVICE[TAPE]				! If the input is from tape,
	THEN
	    INFILE_RAB[RAB$W_USZ] =			! the user buffer must be as big as a tape block.
			.INFILE_FAB [FAB$W_BLS]
	ELSE						! If this input is from a disk file,
            BEGIN
            IF .INFILE_XABFHC[XAB$W_MRZ] NEQ 0		! and the maximum record size is not zero,
            THEN
                INFILE_RAB[RAB$W_USZ] =			! use the maximum record size as the buffer size.
                        .INFILE_XABFHC[XAB$W_MRZ]	!
            ELSE
!                INFILE_RAB[RAB$W_USZ] =		! Otherwise, use the block size.
!                        .INFILE_FAB[FAB$W_BLS];
		INFILE_RAB[RAB$W_USZ] = 		! Use most of I/O buffer
			MIN(.IO_BUFFER_SIZE - DISK_BLOCK_SIZE, MAX_IO_LENGTH);
            END;

	AMT_BUFFER_USED = .INFILE_RAB[RAB$W_USZ];	! Save the amount of the buffer used so far.

	IF .INFILE_FAB[FAB$B_RFM] EQL FAB$C_VFC		! If the input file has VFC format,
	THEN
	    BEGIN
	    INFILE_RAB[RAB$L_RHB] = .IO_BUFFER_BASE	! set the record header buffer address
				+ .AMT_BUFFER_USED;	! in the input file RAB
	    OUTFILE_RAB[RAB$L_RHB] =			! and in the output file RAB.
				.INFILE_RAB[RAB$L_RHB];

	    AMT_BUFFER_USED = .AMT_BUFFER_USED +	! Then update the amount of the buffer used.
			.INFILE_XABFHC[XAB$B_HSZ];
	    END;

	MAX_MBC = (.IO_BUFFER_SIZE - .AMT_BUFFER_USED)/	! Calculate the maximum RMS MBC
		DISK_BLOCK_SIZE;			! for a single disk file.

	IF .IN_DEVICE[DISK] AND .OUT_DEVICE[DISK]	! If both the input and output devices are disks,
	THEN						!
	    BEGIN					! perform special disk-only MBC and MBF setup.

	    IF CH$EQL( .INFILE_NAM_BLK[NAM$B_DVILNG],	! If the same disk is used for both input and output
			INFILE_NAM_BLK[NAM$T_DVI],	! (i.e., they have the same device identifier),
			.INFILE_NAM_BLK[NAM$B_DVILNG],	!
			OUTFILE_NAM_BLK[NAM$T_DVI] )	!
	    THEN					!
		BEGIN					!
		MBF = SINGLE_BUFFER;			! setup for single buffering of both input and output
		MBC = .MAX_MBC / (2 * SINGLE_BUFFER);	! and calculate the MBC for each file.
		END
	    ELSE					! If the input and output disks are different,
		BEGIN					!
		MBF = DOUBLE_BUFFER;			! setup for double buffering of both input and output
		MBC = .MAX_MBC / (2 * DOUBLE_BUFFER);	! and calculate the MBC for each file.
		END;
	    END
	ELSE						! If the input and/or output device is a
	    BEGIN					! tape or a unit record device,
							! perform special "unlike device" setup.

	    MBF = DOUBLE_BUFFER;			! Setup for double buffering of both input and output.

	    IF .INFILE_FAB[FAB$W_BLS] GTR		! If the input block size is greater than
			.OUTFILE_FAB[FAB$W_BLS]		! the output block size,
	    THEN					! (not tape out, anything in, not disk in and out)
		MBC = (.MAX_MBC - (DOUBLE_BUFFER *	! calculate the maximum disk MBC.
			((.INFILE_FAB[FAB$W_BLS] + 511) / DISK_BLOCK_SIZE))
			/ DOUBLE_BUFFER)		!
	    ELSE					! (maybe tape out, anything in, not disk in and out)
		IF .OUTFILE_FAB[FAB$W_BLS] NEQ 0	! Otherwise, calculate the maximum disk MBC
		THEN					! (definitely tape out)
		    MBC = (.MAX_MBC - (DOUBLE_BUFFER *	! using the output block size (tape only)
			    ((.OUTFILE_FAB[FAB$W_BLS] + 511) / DISK_BLOCK_SIZE))
			    / DOUBLE_BUFFER);		!
	    END;

	IF .MBC GTR MAX_IO_LENGTH / DISK_BLOCK_SIZE	! If the calculated MBC is greater
	THEN						!  than the maximum value allowed,
	    MBC = MAX_IO_LENGTH / DISK_BLOCK_SIZE;	! set the temporary MBC value to its maximum value.
	MBC = MAX(1,.MBC);				! Make sure MBC valid

	IF .IN_DEVICE[DISK] AND				! If the input device is a disk
            (.INFILE_XABFHC[XAB$L_EBK] LEQ		! and the file size is less than or equal
                MAX_IO_LENGTH / DISK_BLOCK_SIZE) AND	! MAX_IO_LENGTH,
	    (.MBC * .MBF) GTR .INFILE_XABFHC[XAB$L_EBK]	! and the calculated buffer size is
	THEN						! larger than the size of the input file,
            BEGIN
            MBF = 1;					! Don't double buffer. Just read in the input file
            MBC = .INFILE_XABFHC[XAB$L_EBK];		!    in a single QIO.
            END;

	INFILE_RAB[RAB$B_MBF] = .MBF;			! Setup the input and output MBF and MBC values.
	INFILE_RAB[RAB$B_MBC] = .MBC;			!
	OUTFILE_RAB[RAB$B_MBF] = .MBF;			! NOTE: The MBC values will be ignored by RMS
	OUTFILE_RAB[RAB$B_MBC] = .MBC;			! for non-disk devices.
	END

!
! Block mode I/O setup.
!

    ELSE
	BEGIN
	RECORD_MODE = NO;				! Indicate (1) that record mode is not desired,
	INFILE_RAB[RAB$V_BIO] = YES;			! (2) that block I/O will be used
	OUTFILE_RAB[RAB$V_BIO] = YES;			! for both input and output,
	INFILE_RAB[RAB$V_ASY] = NO;			! and (3) that both reading and writing
	OUTFILE_RAB[RAB$V_ASY] = NO;			! will be asynchronous, however, ASY
							! will be set after $CONNECT to avoid
							! having to issue a $WAIT on the connect.

	IF .IN_DEVICE[TAPE]				! If this is a tape copy,
	THEN						!
	    BEGIN					!
	    BLOCK_SIZE = .INFILE_FAB[FAB$W_BLS];	! save the tape blocksize and
	    BLOCK_IO_LENGTH = .INFILE_FAB[FAB$W_BLS];	! setup to read a block at a time.
	    END
	ELSE
	    BEGIN					! If this is a disk file copy,
	    MBC = (.IO_BUFFER_SIZE/DISK_BLOCK_SIZE)/2;	! calculate the number of blocks
							! in each of 2 block I/O buffers.

	    IF .MBC GTR 65535 / DISK_BLOCK_SIZE		! If this calculated buffer size
	    THEN					! is larger than the maximum I/O allowed,
		MBC = 65535 / DISK_BLOCK_SIZE;		! reset the buffer size.

	    BLOCK_SIZE = DISK_BLOCK_SIZE;		! Save the disk block size.

	    IF (2*.MBC) GTR .INFILE_XABFHC[XAB$L_EBK]	! If the calculated buffer size
	    THEN					! is larger than the size of the file,
		BLOCK_IO_LENGTH =			! calculate a smaller block I/O size.
		    ((.INFILE_XABFHC[XAB$L_EBK]+1) / 2)	!
		    * DISK_BLOCK_SIZE			!
	    ELSE
		BLOCK_IO_LENGTH =			! Otherwise, calculate a maximum buffer size.
			.MBC * DISK_BLOCK_SIZE;
	    END;

	IO_BUFFER_END = .IO_BUFFER_BASE +		! Calculate the address of the last
		(2 * .BLOCK_IO_LENGTH) - 1;		! byte of the 2nd I/O buffer.

							! Put the buffer info into the input and output RABs:
	INFILE_RAB[RAB$L_UBF] = .IO_BUFFER_BASE;	!    1st input buffer address
	INFILE_RAB[RAB$W_USZ] = .BLOCK_IO_LENGTH;	!       and buffer length
	OUTFILE_RAB[RAB$L_RBF] =			!    alternate input buffer address
		.IO_BUFFER_BASE + .BLOCK_IO_LENGTH;	!

!#2	STATUS = SYS$LKWSET( IO_BUFFER_BASE, 0, 0 );	! Lock the buffers in the working set.

!#2	IF NOT .STATUS					! If the buffer locking fails,
!#2	THEN						!
!#2	    PUT_MESSAGE( MSG$_BADLOGIC, 0,		! die with a 3-line error message.
!#2			.STATUS, 0,			!
!#2			MSG$_ATPC, 1 );			!
	END;

!
! Connect the input and output RABs to their respective FABs.
!

    IF NOT $RMS_CONNECT( RAB = INFILE_RAB,		! Connect the input file RAB to the FAB,
			 ERR = COPY$INOPN_ERR )		! specifying an error action routine.

    THEN						! If the connect was not successful,
	RETURN NO_FILE;					! return an error indication to the caller.

    IF .EXTEND_OUTFILE					! If the output file is being extended,
    THEN						!
	OUTFILE_RAB[RAB$V_EOF] = YES;			! force end-of-file positioning on the following CONNECT.

    IF NOT $RMS_CONNECT( RAB = OUTFILE_RAB,		! Connect the output file RAB to the FAB,
			 ERR = COPY$OUTOPN_ERR )	! specifying an error action routine.

    THEN						! If the connect was not successful,
	RETURN NO_FILE;					! return an error indication to the caller.

!
! Set ASY bit in ROP if block I/O mode.
!

    IF NOT .RECORD_MODE					! If block I/O mode
    THEN						!
	BEGIN						!
	INFILE_RAB[RAB$V_ASY] = YES;			! indicate that reading and
	OUTFILE_RAB[RAB$V_ASY] = YES;			! writing will be asynchronous
	END;						!

!
! Return to the caller
!

    RETURN OK;						! Return a success code to the caller.
    END;

PSECT CODE = COPY$COPY_FILE (ALIGN(9));			! Force page alignment for this routine.

ROUTINE COPY_FILE =					! Copies an entire input file to the output file

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine copies an entire input file into the output file,
!	using block mode I/O if possible.
!
!	This routine is page-aligned in order to minimize page faulting
!	due to executing the code which performs the actual file copying.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	RECORD_MODE - Indicates whether record mode I/O is required
!	INFILE_FAB - Input file FAB
!	INFILE_RAB - Input file RAB
!
! IMPLICIT OUTPUTS:
!
!	RECORD_COUNT - Number of input file records copied
!	BLOCK_COUNT - Number of input file blocks copied
!
! COMPLETION CODES:
!
!	OK = successful copy
!	ERROR = I/O error during copy
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    LOCAL
	NEXT_READ;					! Temporary buffer pointer

!
! Initialization
!

    RECORD_COUNT = 0;					! Zero the input file record
    BLOCK_COUNT = 0;					! and block counters.

!
! If necessary, copy the input file to the output file one record at a time.
!

    IF .RECORD_MODE					! Test the record mode I/O indicator.
    THEN
	WHILE 1 DO					! Beginning of the record copying loop which
	    BEGIN					! will be terminated by a RETURN in the event
							! of an input end-of-file or any I/O error.

	    IF NOT $RMS_GET( RAB = INFILE_RAB )		! Get one record from the input file.

	    THEN					! If the get was not successful,
		BEGIN					! begin error processing.
							!
		IF .INFILE_RAB[RAB$L_STS] EQL RMS$_EOF	! If the error was an input end-of-file,
		THEN					!
		    RETURN OK;				! return a success code to the caller.

		IN_READ_ERROR();			! Otherwise, send an error message to the user
		RETURN ERROR;				! and return an error code to the caller.

		END;					! End of input error processing.

	    OUTFILE_RAB[RAB$L_RBF] =			! Copy the input record address
			.INFILE_RAB[RAB$L_RBF];		! and record length
	    OUTFILE_RAB[RAB$W_RSZ] =			! from the input file RAB
			.INFILE_RAB[RAB$W_RSZ];		! to the output file RAB.

	    IF $RMS_PUT( RAB = OUTFILE_RAB )		! Write one record into the output file.

	    THEN					! If the put was successful,
		RECORD_COUNT = .RECORD_COUNT + 1	! increment the record counter.
	    ELSE
		BEGIN					! Otherwise,
		OUT_WRITE_ERROR();			! send an error message to the user
		RETURN ERROR;				! and return to the caller.
		END;

	    END						! End of record mode copy loop.

!
! If possible, copy the input file to the output file a block at a time.
!

    ELSE
	WHILE 1 DO					! Beginning of the block copying loop which
	    BEGIN					! will be terminated by a RETURN in the event
							! of an input end-of-file or any I/O error.

	    $RMS_READ( RAB = INFILE_RAB );		! Begin an asynchronous read from the input file.

	    IF NOT $RMS_WAIT( RAB = OUTFILE_RAB )	! Wait for the previous write to complete.
	    THEN
		BEGIN					! If the write was not successful,
		OUT_WRITE_ERROR();			! send the user an error message,
		$RMS_WAIT( RAB = INFILE_RAB );		! wait for the previous read to complete,
		RETURN ERROR;				! and then return an error code to the caller.
		END;

	    IF $RMS_WAIT( RAB = INFILE_RAB )		! Wait for the previous read to complete.
	    THEN
		BEGIN					! If the read was successful,
		INFILE_RAB[RAB$L_UBF] =			! save the current output buffer address
			.OUTFILE_RAB[RAB$L_RBF];	!
		OUTFILE_RAB[RAB$L_RBF] =		! and copy the input block address and block size
			.INFILE_RAB[RAB$L_RBF];		! from the input file RAB into the output RAB.
		OUTFILE_RAB[RAB$W_RSZ] =		!
			.INFILE_RAB[RAB$W_RSZ];		!

		$RMS_WRITE( RAB = OUTFILE_RAB );	! Initiate an asynchronous write.

		BLOCK_COUNT = .BLOCK_COUNT +		! Increment the count of blocks written.
		    (.INFILE_RAB[RAB$W_RSZ] +		!
		    .BLOCK_SIZE - 1) / .BLOCK_SIZE;	!
		END
	    ELSE					! If the read was unsuccessful,
		BEGIN					! begin special input error processing.

		IF .INFILE_RAB[RAB$L_STS] EQL RMS$_EOF	! If the error was an input end-of-file,
		THEN					!
		    RETURN OK;				! return a success code to the caller.

		IN_READ_ERROR();			! Otherwise, send an error message to the user
		RETURN ERROR;				! and then return an error code to the caller.
		END;

	    END;					! End of block mode copy loop.

    END;
PSECT CODE = $CODE$;					! Resume the default PSECT (see previous routine).

ROUTINE CLOSE_INFILE :  NOVALUE =			! Close the current input file

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine closes the current input file.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	INFILE_OPEN - Input file open indicator
!	INFILE_FAB - Input file FAB
!
! IMPLICIT OUTPUTS:
!
!	INFILE_OPEN - Set to indicate that the input file is not open
!	INFILE_FAB - Input file FAB closed
!
! ROUTINE VALUE:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

!
! Return to the caller if the input file is not open.
!

    IF NOT .INFILE_OPEN					! If the input file is not open,
    THEN						!
	RETURN;						! return to the caller.

    INFILE_OPEN = NO;					! Otherwise, turn off the open indicator.

!
! Close the input file.
!

    $RMS_CLOSE( FAB = INFILE_FAB,			! Close the input file FAB,
		 ERR = IN_CLOSE_ERROR );		! specifying an error action routine.

!
! Return to the caller.
!

    RETURN;						! Return to the caller.

    END;

GLOBAL ROUTINE COPY$CLOSE_OUTF :  NOVALUE =		! Close the current output file

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine closes the current output file.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	OUTFILE_OPEN - Output file open indicator
!	OUTFILE_FAB - Output file FAB
!	TRUNCATE_BIT in COPY$CLI_STATUS if /TRUNCATE was specified.
!
! IMPLICIT OUTPUTS:
!
!	OUTFILE_OPEN - Set to indicate that the output file is not open
!	OUTFILE_FAB - Output file FAB closed
!
! ROUTINE VALUE:
!
!	None
!
! SIDE EFFECTS:
!
!	File is truncated if /TRUNCATE was specified.
!
!--

    BEGIN

!
! Return to the caller if the output file is not open.
!

    IF NOT .OUTFILE_OPEN				! If the output file is not open,
    THEN						!
	RETURN OK;					! return a success code to the caller.

    OUTFILE_OPEN = NO;					! Otherwise, turn off the open indicator.

!
! Close the output file.
!

    $RMS_CLOSE( FAB = OUTFILE_FAB,			! Close the output file FAB,
		 ERR = COPY$OCLOSE_ERR );		! specifying an error action routine.

!
! Reset the incompatible messages flag to FALSE for the next output file. This message
! indicates whether an incompatible attributes has been output for an output file.
!

    COPY$B_INCOMPAT = FALSE;				! Reset incompatible flag

!
! Return to the caller.
!

    RETURN;						! Return to the caller.

    END;

ROUTINE RMS_CLEANUP : NOVALUE =				! RMS cleanup routine

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine performs any necessary RMS cleanup after a file copy:
!
!		* unlocks the block I/O buffers
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	IO_BUFFER_BASE - Address of the dynamic I/O buffer
!	IO_BUFFER_END - Address of the end of the buffer
!
! IMPLICIT OUTPUTS:
!
!	IO_BUFFER_END - End of buffer pointer zeroed
!
! ROUTINE VALUE:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    LOCAL
	STATUS;						! System service completion code

!
! Unlock the block I/O buffers from the working set.
!

    IF .IO_BUFFER_END NEQ 0				! If the block I/O buffers were allocated,
    THEN						!
	BEGIN						!
!#2	STATUS = SYS$ULWSET( IO_BUFFER_BASE, 0, 0 );	! unlock them from the working set.

!#2	IF NOT .STATUS					! If the buffer unlock fails,
!#2	THEN						!
!#2	    PUT_MESSAGE( MSG$_BADLOGIC, 0,		! die with a 3-line error message.
!#2			.STATUS, 0,			!
!#2			MSG$_ATPC, 1 );			!

	IO_BUFFER_END = 0;				! Clear the end of buffer pointer.
	END;

!
! Return to the caller.
!

    RETURN;						! Return to the caller.
    END;

ROUTINE BYPASS_CONCAT					! Bypass concatenated input files
		: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine scans past concatenated input file-specifications.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	Bits in the status words COPY$CLI_STATUS and COPY$SEM_STATUS:
!
!		APPEND_COMMAND	- APPEND command indicator
!		CONCAT_FOLLOWS	- concatentation is occurring
!
!	INFILE_DESC - Input file request descriptor
!	CLEANUP_DESC - Input file cleanup request descriptor
!
! IMPLICIT OUTPUTS:
!
!	CONCAT_FOLLOWS - Concatenation active indicator turned off
!	WILDCARD_ACTIVE - Wildcard active indicator turned off
!
! ROUTINE VALUE:
!
!	None
!
! SIDE EFFECTS:
!
!	INFILE_DESC - Input file request descriptor filled in by the CLI
!	CLEANUP_DESC - Input file cleanup request descriptor filled in by the CLI
!
!--

    BEGIN

!
! Return to the caller if input concatenation is not active.
!

    IF NOT .APPEND_COMMAND AND				! If this is a COPY command
	NOT .CONCAT_FOLLOWS				! and no input concatentation is active,
    THEN						!
	RETURN						!    then return to the caller.
    ELSE
	CONCAT_FOLLOWS = NO;				! Otherwise, turn off the concatenation indicator.

!
! Report an wildcard specification which has not been completely processed.
!

    IF .WILDCARD_ACTIVE					! If a wildcard spec is currently active,
    THEN						!
	BEGIN						!
	WILDCARD_ACTIVE = NO;				! turn off the wildcard indicator.

	IF .INFILE_NAM_BLK[NAM$B_RSL] NEQ 0		! If the wildcard spec is partially processed,
	THEN						!
	    BEGIN					!
	    INFILE_NAM_BLK[NAM$B_RSL] = 0;		! discard the current resultant name string,
	    REPORT_BYPASS( MSG$_NOTCMPLT );		! and report the bypass wildcard spec.
	    END;
	END;

!
! Scan past any concatenated input file-specifications.
!

    WHILE .INFILE_DESC[CLI$V_CONCATINP] DO		! Repeat the remainder of this routine until
	BEGIN						!    all necessary input files have been bypassed.
	CALL_CLI(					! Call the CLI with the following arguments:
		INFILE_DESC,				!    Input file request descriptor address
		CLI_WORK_AREA,				!    CLI work area address
		COPY$CLI_STATUS );			!    COPY status bit vector address

	IF COPY$PARS_INFIL()				! Parse the input file-specification.
	THEN
	    REPORT_BYPASS( MSG$_NOTCOPIED );		! Report that the file was not processed.

	IF NOT .INFILE_DESC[CLI$V_CONCATINP]		! If no concatenated file-specification follows,
	THEN						!
	    CALL_CLI(					! call the CLI with the following arguments:
			CLEANUP_DESC,			!    Parameter cleanup request descriptor
			CLI_WORK_AREA,			!    CLI work area address
			COPY$CLI_STATUS );		!    COPY status bit vector address
	END;

!
! Return to the caller.
!

    RETURN;						! Return to the caller.

    END;

GLOBAL ROUTINE COPY$PARS_INFIL : =			! Input file-spec parse routine

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine calls RMS to parse an input file-specification.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	INFILE_DESC - Input file CLI request descriptor
!	INFILE_FAB - Input file FAB
!	INFILE_NAM_BLK - Input file name block
!	DUMMY_NAM_BLK - Dummy name block for input "stickiness"
!
! IMPLICIT OUTPUTS:
!
!	INFILE_NAM_BLK - Filled in by RMS
!	DUMMY_NAM_BLK - Updated to reflect last input file-specification
!
! COMPLETION CODES:
!
!	OK = Successful parse
!	ERROR = Error from RMS parse
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

!
! Call RMS to parse the input file-specification to resolve a logical name (if any).
!

    INFILE_FAB[FAB$L_FNA] = .INFILE_DESC[CLI$A_RQADDR];	! Move the file name address
    INFILE_FAB[FAB$B_FNS] = .INFILE_DESC[CLI$W_RQSIZE];	! and length into the input file FAB.

    INFILE_NAM_BLK[NAM$B_ESL] = 0;			! Zero the expanded string length so that
							! COPY$INOPN_ERR can determine if an expanded
							! string was created by RMS.

    IF $RMS_PARSE( FAB = INFILE_FAB,			! Call the RMS file-spec parsing routine,
		ERR = COPY$INOPN_ERR )			! specifying an error action routine.
    THEN
	BEGIN						! If the parse was successful,
	DUMMY_NAM_BLK[NAM$B_RSL] =			! setup the dummy name block to point
		.INFILE_NAM_BLK[NAM$B_ESL];		! to the current expanded file name.
							!
	RETURN OK;					! Return a success code to the caller.
	END
    ELSE
	RETURN ERROR;					! Otherwise, return an error to the caller.
    END;

GLOBAL ROUTINE COPY$CALC_ALQ =				! Allocation quantity calculation routine

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine determines the output file allocation/extension quantity.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	EXTEND_OUTFILE	- Output file extension indicator
!	INFILE_FAB	- Input file FAB
!	INFILE_XABALL	- Input file allocation XAB
!	INFILE_XABFHC	- Input file header characteristics XAB
!	COPY$CLI_STATUS bit TRUNCATE_BIT
!		means /TRUNCATE was specified
!	ALLOC_VALUE	- contains a value if /ALLOCATION was specified.
!	COPY_TRUN_QUAL  - CLI data block for the truncate qualifier; the
!			  "explicit bit" will be set if /NOTRUNCATE was 
!			  specified on the input line
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	Size of the input file (i.e., number of blocks)
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    LOCAL
	ALQ;						! Temporary allocation quantity

!
! Return a zero allocation size if the output file is not a disk and it is being extended.
!

    IF .EXTEND_OUTFILE AND				! If the output file is being extended
	(NOT .OUTFILE_FAB[$FAB_DEV(FOD)] OR		! and it is not a file structured device
	 .OUTFILE_FAB[$FAB_DEV(SQD)])			! or it is a magnetic tape,
    THEN						!
	RETURN 0;					! return a zero allocation size to the caller.

!
! Determine the output file allocation size from the size and organization of the input file.
!

    IF NOT .INFILE_FAB[$FAB_DEV(FOD)] OR		! If the input device is not file structured
	.INFILE_FAB[$FAB_DEV(SQD)]			! or if it is a magnetic tape,
    THEN						!
	ALQ = DEFAULT_ALLOC				! assume a default input file size.
    ELSE
	BEGIN
!
! 	If the input file is a non-contiguous sequential file and /NOTRUNCATE was not explicitly given
! 		or 
!	the the input file is being appened to an existing file,
!		or
!	if /TRUNCATE and no /ALLOCATION was given,
!	the file should be truncated.  Otherwise, use the allocation of the input file as the size of
!	the output file.
!
	IF  (
	    (
	    .INFILE_FAB[ FAB$B_ORG ] EQL FAB$C_SEQ
	    	AND NOT 
	    ( EXPLIC_COP_QUAL(TRUN) AND NOT .COPY$CLI_STATUS [TRUNCATE_BIT])
	    )
		AND
	    ( NOT .INFILE_XABALL[ XAB$V_CTG ] OR .EXTEND_OUTFILE )
	    )
	    	OR
	    ( .COPY$CLI_STATUS [TRUNCATE_BIT] AND .ALLOC_VALUE EQL 0 )
	THEN						!
	    IF .INFILE_XABFHC[XAB$W_FFB] EQL 0		! calculate only enough space to hold the actual
	    THEN					! data in the input file.  Note that this calculation
		ALQ = .INFILE_XABFHC[XAB$L_EBK] - 1	! includes the final block only if it actually
	    ELSE					! contains some data.
		ALQ = .INFILE_XABFHC[XAB$L_EBK]		!
	ELSE
	    ALQ = .INFILE_XABFHC[XAB$L_HBK];		! Otherwise, pickup the actual size of the input file.
	END;

    IF .EXTEND_OUTFILE					! If the output file is being extended,
    THEN						!
	ALQ = .OUTFILE_XABFHC[XAB$L_EBK] + .ALQ -	! subtract the remaining output file space
		.OUTFILE_XABFHC[XAB$L_HBK];		! from the calculated extension quantity.

!
! Return the calculated allocation (or extension) quantity to the caller.
!

    IF .ALQ GEQ 0					! If the calculated allocation/extension quantity
    THEN						! is greater than or equal to zero,
	RETURN .ALQ					! return that value to the caller.
    ELSE
	RETURN 0;					! Otherwise, return a zero value to the caller.

    END;

ROUTINE REPORT_NAMES					! Report the results of a file copy
		: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine reports the results of copying a single input file
!	to the output file.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	LOG - Indicator tested to see if activity reporting desired
!	EXTEND_OUTFILE - Indicator tested to see if input concatenation is active.
!	IN_NAME_DESC - Input file name descriptor
!	OUT_NAME_DESC - Output file name descriptor
!	BLOCK_COUNT - Number of input file blocks copied
!	RECORD_COUNT - Number of input file records copied
!	INFILE_FAB - Address of input file FAB
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    LOCAL
	ptr,						! Temporary variables for character searching
	address,
	size;

!
! Determine which message, if any, is needed.
!

    IF NOT .LOG_MSG					! If activity reporting is not requested,
    THEN						!
	RETURN;						! return to the caller.

!
! If this is a record oriented device (not network), the messages should 
! include only the device name.
!

    IF .infile_fab [$FAB_DEV(rec)] 
	AND NOT .infile_fab [$FAB_DEV(net)] 
    THEN
	BEGIN
	size = .in_name_desc[0];
	address = .in_name_desc[1];
	ptr = CH$FIND_CH(.size,.address,':');
	IF .ptr NEQ 0		! If there is anything past the device, remove it
	THEN
	    in_name_desc[0] =  .ptr - .address + 1;
	END;

    IF NOT .EXTEND_OUTFILE				! Test the record mode indicator to see
							! if this is the primary input file or a
							! concatenated input file.
!
! Create a "copied" message if the input file just copied was
! the first file copied into the output file.
!

    THEN						!
	IF .BLOCK_COUNT NEQ 0				! If the input file was copied in block mode,
	THEN						!
	    PUT_MESSAGE( MSG$_COPIEDB,			! signal "file copied" with the following arguments:
		    3,					!    Number of message arguments
		    IN_NAME_DESC,			!    Address of input file name descriptor
		    OUT_NAME_DESC,			!    Address of output file name descriptor
		    .BLOCK_COUNT )			!    Number of blocks copied

	ELSE						! Otherwise,
	    IF (.RECORD_COUNT NEQ 0) OR NOT (LIB$CHECK_DIR (INFILE_FAB)) ! If the input file is not 0 records or
									 !   is not a directory file
	    THEN
		    PUT_MESSAGE( MSG$_COPIEDR,		! signal "file copied" with the following arguments:
			    3,				!    Number of message arguments
			    IN_NAME_DESC,		!    Address of input file name descriptor
			    OUT_NAME_DESC,		!    Address of output file name descriptor
			    .RECORD_COUNT )		!    Number of records copied

	    ELSE					! Otherwise, its a directory file
		    PUT_MESSAGE( MSG$_CREATED,		! signal "created" with the following arguments:
			    1,				!    number of message arguments
			    OUT_NAME_DESC )		!    address of output file descriptor
!
! Create an "appended" message if the input file just copied was
! appended to an existing output file.
!

    ELSE						!
	IF .BLOCK_COUNT NEQ 0				! If the input file was copied in block mode,
	THEN						!
	    PUT_MESSAGE( MSG$_APPENDEDB,		! signal "file appended" with the following arguments:
		    3,					!    Number of message arguments
		    IN_NAME_DESC,			!    Address of input file name descriptor
		    OUT_NAME_DESC,			!    Address of output file name descriptor
		    .BLOCK_COUNT )			!    Number of blocks copied

	ELSE						! Otherwise,
	    PUT_MESSAGE( MSG$_APPENDEDR,		! signal "file appended" with the following arguments:
		    3,					!    Number of message arguments
		    IN_NAME_DESC,			!    Address of input file name descriptor
		    OUT_NAME_DESC,			!    Address of output file name descriptor
		    .RECORD_COUNT );			!    Number of records copied

!
! Return to the caller.
!

    RETURN;						! Return to the caller.

    END;

ROUTINE REPORT_BYPASS (					! Report the bypassing of an input file
			NUMBER )			! Error number
		: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine reports the name of an input file which has been bypassed.
!
! FORMAL PARAMETERS:
!
!	NUMBER.rlu.v - Error number
!
! IMPLICIT INPUTS:
!
!	INFILE_NAM_BLK - Input file name block
!	INFILE_NAME - Input file resultant name
!	INFILE_XNAME - Input file expanded name
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    LOCAL
	NAME_DESC :  VECTOR[2];				! Input file name descriptor

!
! Setup the input file name descriptor.
!

    IF .INFILE_NAM_BLK[NAM$B_RSL] NEQ 0			! If RMS has setup a resultant name string,
    THEN						!
	BEGIN						!
	NAME_DESC[0] = .INFILE_NAM_BLK[NAM$B_RSL];	! setup the name descriptor to use
	NAME_DESC[1] = INFILE_NAME;			! the resultant name string.
	END
    ELSE
	BEGIN						!
	NAME_DESC[0] = .INFILE_NAM_BLK[NAM$B_ESL];	! Otherwise, use the expanded name string.
	NAME_DESC[1] = INFILE_XNAME;			!
	END;

!
! Report the name of the input file which is being bypassed.
!

    PUT_MESSAGEX( .NUMBER, 1, NAME_DESC );		! Report the name of the input file.

!
! Return to the caller.
!

    RETURN;						! Return to the caller.

    END;

GLOBAL ROUTINE COPY$LOG_MSG (				! Signal a COPY message
		NUMBER )				! Error number
		: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine sends an informational message to the user if
!	activity reporting has been requested.
!
! FORMAL PARAMETERS:
!
!	NUMBER.rlu.v - error number
!
! IMPLICIT INPUTS:
!
!	LOG_MSG - Activity reporting indicator
!	OUTFILE_COUNT - Number of output files created
!	OUT_NAME_DESC - Output file name descriptor
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

!
! Return to the caller if activity reporting has not been requested.
!

    IF NOT .LOG_MSG					! If activity reporting is not requested,
    THEN						!
	RETURN;						! return to the caller.

!
! Call FAO to format the error message in the message buffer.
!

    SELECTONE .NUMBER OF				! Select error message processing based
	SET						! on the actual error number.

	[MSG$_NEWFILES]:
	    IF .OUTFILE_COUNT GEQU 2			! If at least 2 files was created,
	    THEN					!
		PUT_MESSAGE( MSG$_NEWFILES,		! signal "<number> files created" with the following args:
			1,				!    number of message arguments
			.OUTFILE_COUNT );		!    number of output files created

	[MSG$_REPLACED, MSG$_OVERLAY, MSG$_CREATED]:
	    PUT_MESSAGEX( .NUMBER,			! signal the message with the following arguments:
			1,				!    number of message arguments
			OUT_NAME_DESC );		!    address of the output name descriptor

	[OTHERWISE]:
	    PUT_MESSAGEX( .NUMBER );			! Signal the appropriate message.
	TES;

!
! Return to the caller.
!

    RETURN;						! Return to the caller.

    END;

GLOBAL ROUTINE COPY$INOPN_ERR (				! RMS input open error action routine
		FAB_RAB_ADDRESS )			! Address of associated FAB or RAB
		: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This RMS error action routine sends an input open error message to the user.
!
! FORMAL PARAMETERS:
!
!	FAB_RAB_ADDRESS.ra.v - Address of the associated FAB or RAB
!
! IMPLICIT INPUTS:
!
!	INFILE_NAM_BLK - Input file name block
!	INFILE_NAME - Input file name after open
!	INFILE_XNAME - Input file name before open
!	INFILE_DESC - Input file request descriptor
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    BIND
	FAB_RAB = .FAB_RAB_ADDRESS :  BLOCK[,BYTE];	! Redefine routine parameter.

    LOCAL
	MESSAGE_ID,					! Local message identifier
	NAME_DESC :  VECTOR[2];				! Input file name descriptor

!
! Fillin the file name descriptor with the most complete name possible.
!

    IF .INFILE_NAM_BLK[NAM$B_RSL] NEQ 0			! If a resultant name string exists,
    THEN						!
	BEGIN						!
	MESSAGE_ID = MSG$_OPENIN;			! indicate an open error
	NAME_DESC[0] = .INFILE_NAM_BLK[NAM$B_RSL];	! and fillin the resultant name length
	NAME_DESC[1] = INFILE_NAME;			! and address.
	END
    ELSE
	IF .INFILE_NAM_BLK[NAM$B_ESL] NEQ 0		! If RMS created an expanded string
	THEN						! but coundn't open the file,
	    BEGIN					!
	    MESSAGE_ID = MSG$_OPENIN;			! indicate an open error
	    NAME_DESC[0] = .INFILE_NAM_BLK[NAM$B_ESL];	! and fillin the expanded name length
	    NAME_DESC[1] = INFILE_XNAME;		! and address.
	    END
	ELSE
	    BEGIN
	    MESSAGE_ID = MSG$_OPENINX;			! Otherwise, indicate a fatal open error
	    NAME_DESC[0] = .INFILE_DESC[CLI$W_RQSIZE];	! and use the file name length
	    NAME_DESC[1] = .INFILE_DESC[CLI$A_RQADDR];	! and length passed by the CLI.
	    END;
!
! If mag tape and operator aborted the mount, make it fatal
!
	IF .FAB_RAB[$FAB_DEV(sdi)]
	    AND .FAB_RAB[FAB$L_STV] EQL SS$_ABORT
	THEN
	    MESSAGE_ID = MSG$_OPENINX;

!
! Signal the error condition.
!

    PUT_MESSAGEX( .MESSAGE_ID,				! Signal "input open error" with the following arguments:
		1,					!    Number of message arguments
		NAME_DESC,				!    Address of input name descriptor
		.FAB_RAB[FAB$L_STS],			!    Primary RMS completion code
		.FAB_RAB[FAB$L_STV] );			!    Secondary RMS completion code

!
! Return to the caller.
!

    RETURN;						! Return to the caller.

    END;

ROUTINE IN_READ_ERROR : NOVALUE =			! RMS input read error action routine

!++
! FUNCTIONAL DESCRIPTION:
!
!	This RMS error action routine sends an input read error message to the user.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	INFILE_RAB - Input file RAB
!	IN_NAME_DESC - Input file name descriptor
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

!
! Signal the input read error.
!

    PUT_MESSAGE( MSG$_READERR,				! Signal a "read error" with the following arguments:
		1,					!    Number of message arguments
		IN_NAME_DESC,				!    Address of input file name descriptor
		.INFILE_RAB[RAB$L_STS],			!    Primary RMS completion code
		.INFILE_RAB[RAB$L_STV] );		!    Secondary RMS completion code

!
! Return to the caller.
!

    RETURN;						! Return to the caller.

    END;

ROUTINE IN_CLOSE_ERROR (				! RMS input close error action routine
		FAB_RAB_ADDRESS )			! Address of associated FAB or RAB
		: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This RMS error action routine sends an input close error message to the user.
!
! FORMAL PARAMETERS:
!
!	FAB_RAB_ADDRESS.ra.v - Address of the associated FAB or RAB
!
! IMPLICIT INPUTS:
!
!	IN_NAME_DESC - Input file name descriptor
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    BIND
	FAB_RAB = .FAB_RAB_ADDRESS :  BLOCK[,BYTE];	! Redefine routine parameter.

!
! Signal an input close error.
!

    PUT_MESSAGE( MSG$_CLOSEIN,				! Signal a "close error" with the following arguments:
		1,					!    Number of message arguments
		IN_NAME_DESC,				!    Address of input file name descriptor
		.FAB_RAB[FAB$L_STS],			!    Primary RMS completion code
		.FAB_RAB[FAB$L_STV] );			!    Secondary RMS completion code

!
! Return to the caller.
!

    RETURN;						! Return to the caller.

    END;

GLOBAL ROUTINE COPY$OUTOPN_ERR (			! RMS output open error action routine
		FAB_RAB_ADDRESS )			! Address of associated FAB or RAB
		: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This RMS error action routine sends an output open error message to the user.
!
! FORMAL PARAMETERS:
!
!	FAB_RAB_ADDRESS.ra.v - Address of the associated FAB or RAB
!
! IMPLICIT INPUTS:
!
!	OUTFILE_NAM_BLK - Output file name block
!	OUTFILE_NAME - Output file name after open
!	OUTFILE_XNAME - Output file name before open
!	OUTFILE_DESC - Output file request descriptor
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    BIND
	FAB_RAB = .FAB_RAB_ADDRESS :  BLOCK[,BYTE];	! Redefine routine parameter.

    LOCAL
	MESSAGE_ID,					! Local message identifier
	NAME_DESC :  VECTOR[2];				! Output file name descriptor

!
! Fillin the file name descriptor with the most complete name possible.
!

    IF .OUTFILE_NAM_BLK[NAM$B_RSL] NEQ 0		! If a resultant name string exists,
    THEN						!
	BEGIN						!
	MESSAGE_ID = MSG$_OPENOUT;			! indicate an open error
	NAME_DESC[0] = .OUTFILE_NAM_BLK[NAM$B_RSL];	! and fillin the resultant name length
	NAME_DESC[1] = OUTFILE_NAME;			! and address.
	END
    ELSE
	IF .OUTFILE_NAM_BLK[NAM$B_ESL] NEQ 0		! If RMS created an expanded string but couldn't open
	THEN						!
	    BEGIN					!
	    MESSAGE_ID = MSG$_OPENOUT;			! indicate an open error
	    NAME_DESC[0] = .OUTFILE_NAM_BLK[NAM$B_ESL];	! and fillin the expanded name length
	    NAME_DESC[1] = OUTFILE_XNAME;		! and address.
	    END
	ELSE
	    BEGIN
	    MESSAGE_ID = MSG$_OPENOUTX;			! Otherwise, indicate a fatal open error
	    NAME_DESC[0] = .OUTFILE_DESC[CLI$W_RQSIZE];	! and use the file name length
	    NAME_DESC[1] = .OUTFILE_DESC[CLI$A_RQADDR];	! and length passed by the CLI.
	    END;
!
! If mag tape and operator aborted the mount, make it fatal
!
	IF .FAB_RAB[$FAB_DEV(sdi)]
	    AND .FAB_RAB[FAB$L_STV] EQL SS$_ABORT
	THEN
	    MESSAGE_ID = MSG$_OPENOUTX;

!
! Signal the error condition.
!

    PUT_MESSAGEX( .MESSAGE_ID,				! Signal "output open error" with the following arguments:
		1,					!    Number of message arguments
		NAME_DESC,				!    Address of output name descriptor
		.FAB_RAB[FAB$L_STS],			!    Primary RMS completion code
		.FAB_RAB[FAB$L_STV] );			!    Secondary RMS completion code

!
! Return to the caller.
!

    RETURN;						! Return to the caller.

    END;

ROUTINE OUT_WRITE_ERROR : NOVALUE =			! RMS output write error action routine

!++
! FUNCTIONAL DESCRIPTION:
!
!	This RMS error action routine sends an output read error message to the user.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	OUTFILE_RAB - Output file RAB
!	OUT_NAME_DESC - Output file name descriptor
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

!
! Signal the output write error.
!

    PUT_MESSAGE( MSG$_WRITEERR,				! Signal a "write error" with the following arguments:
		1,					!    Number of message arguments
		OUT_NAME_DESC,				!    Address of output file name descriptor
		.OUTFILE_RAB[RAB$L_STS],		!    Primary RMS completion code
		.OUTFILE_RAB[RAB$L_STV] );		!    Secondary RMS completion code

!
! Return to the caller.
!

    RETURN;						! Return to the caller.

    END;

GLOBAL ROUTINE COPY$OCLOSE_ERR (			! RMS output close error action routine
		FAB_RAB_ADDRESS )			! Address of associated FAB or RAB
		: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This RMS error action routine sends an output close error message to the user.
!
! FORMAL PARAMETERS:
!
!	FAB_RAB_ADDRESS.ra.v - Address of the associated FAB or RAB
!
! IMPLICIT INPUTS:
!
!	OUT_NAME_DESC - Output file name descriptor
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    BIND
	FAB_RAB = .FAB_RAB_ADDRESS :  BLOCK[,BYTE];	! Redefine routine parameter.

!
! Signal an output close error.
!

    PUT_MESSAGE( MSG$_CLOSEOUT,				! Signal a "close error" with the following arguments:
		1,					!    Number of message arguments
		OUT_NAME_DESC,				!    Address of output file name descriptor
		.FAB_RAB[FAB$L_STS],			!    Primary RMS completion code
		.FAB_RAB[FAB$L_STV] );			!    Secondary RMS completion code

!
! Return to the caller.
!

    RETURN;						! Return to the caller.

    END;

GLOBAL ROUTINE COPY$MSG_NUMBER (			! COPY/APPEND message number generator
			MSG_ID ) =			! Message number

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine return a COPY-specific or APPEND-specific message id
!	by inserting the appropriate facility identifier in the high word
!	of the message id which is passed by the caller.  This routine also
!	records the highest severity message encountered.
!
! FORMAL PARAMETERS:
!
!	MSG_ID.rlu.v - Message id
!
! IMPLICIT INPUTS:
!
!	APPEND_COMMAND = APPEND command indicator
!	MOST_SEVERE_ERR - Current most severe error id
!	OUTFILE_NAM_BLK - Output file name block - wildcard indicator
!
! IMPLICIT OUTPUTS:
!
!	MOST_SEVERE_ERR - Most severe error id may be updated
!
! ROUTINE VALUE:
!
!	Actual message id
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    MAP							!
	MSG_ID :  BLOCK[,BYTE];				! Redefine the form of the input argument

    LOCAL
	ACTUAL_MSG_ID :  BLOCK[1];			! Actual message identifier

!
! Calculate the actual message identifier.
!

IF .MSG_ID<16,16> EQL 0					! If facility unspecified,
THEN
    IF .APPEND_COMMAND					! If this is an APPEND command,
    THEN						!
	ACTUAL_MSG_ID = .MSG_ID + (APPEND_ID * 65536)	! insert the APPEND facility code into the message id.
    ELSE						! If this is a COPY command,
	ACTUAL_MSG_ID = .MSG_ID + (COPY_ID * 65536)	! insert the COPY facility code into the message id.
ELSE
    ACTUAL_MSG_ID = .MSG_ID;				! else use existing code

!
! Update the "most severe error" if the current error is more severe.
!

    IF NOT .ACTUAL_MSG_ID AND				! If the current message is not a success message and
	(.MOST_SEVERE_ERR OR				! either this is the first error message
	.ACTUAL_MSG_ID[STS$V_SEVERITY] GTRU		! or the current message severity
		.MOST_SEVERE_ERR[STS$V_SEVERITY])	! is greater than the previous severity,
    THEN						!
	MOST_SEVERE_ERR = .ACTUAL_MSG_ID OR		! update the most severe message id
				STS$M_INHIB_MSG;	! and turn on the "suppress message" indicator.

!
! Return the actual message id to the caller.
!

    RETURN .ACTUAL_MSG_ID;				! Return the actual message id to the caller.

    END;

END
ELUDOM
