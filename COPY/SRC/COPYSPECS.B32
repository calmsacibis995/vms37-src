MODULE copyspecs (  ! Manipulates input and output specifications for COPY utility
                    LANGUAGE (BLISS32),
                    IDENT = 'V03-000'
                    ) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY:	COPY Command
!
! ABSTRACT:
!
!	This module obtains input and output specifications from the CLI and opens
!	the associated files.
!
! ENVIRONMENT:
!
!	VAX/VMS operating system, unprivileged user mode utility,
!	operates at non-AST level.
!
!--
!++
!
! AUTHOR:	Carol Peters,	CREATION DATE:	14 April 1978 14:17
!
! Modified by:
!
!	X00025  TSK0001		Tamar Krichevsky	5-Feb-1982
!		Have Global Buffer Count (GBC) transferred from input FAB to
!		outout FAB.
!
!	X00024	KRM0038		Karl Malik	12-Jan-1982
!		Warn the user (in COPY$OPN_OUTFIL) if the output file
!		was forced to stream format ( in a network copy to
!		a 10,20 or RT system ).
!
!	X00023	KRM0035		Karl Malik	31-Dec-1981
!		Check for network quoted string in single output filespec
!		& if found, do not force multiple output files.
!
!	X00022	WMC0030		Wayne Cardoza	15-Dec-1981
!		Disallow output directory wildcards remaining after the output
!		file parse with the related input file.
!
!	X00021	WMC0021		Wayne Cardoza	8-Dec-1981
!		Set no_output_spec if only directory is wild and no explicit
!		filename components.
!
!	X00020	KFH0001		Ken Henderson	28-Sep-1981
!		Expiration and Backup dates are not copied from input file,
!		but instead are defaulted.
!
!	X00019	WMC0001		Wayne Cardoza	22-Jul-1981
!		Explicit protection specification should not cause old dates
!		to be preserved if a file spec is also present.
!
!	X00018	SPF0001		S. Forgey	27-Jan-1981
!		Allow wildcard directories in output file specifications to
!		go along with RMS now handling "sticky" directories.
!
!	X00017	JAK0017		J. Krycka	18-Sep-1980
!		Alter the X00006 special check for network access in setting up
!		the output Allocation XAB (i.e., gat ALQ and DEQ values from the
!		FHC XAB).
!
!	X00016	TMH0015		Tim Halvorsen	24-Mar-1980
!		Force creation of a new file (creation date, owner, prot)
!		if the output file specification is explicit to maintain
!		compatibility with release 1 behavior.  This involves changing
!		the previous update to remove remove xabpro,rdt,dat if
!		explicit output filespec as long as /PROT was not specified
!		(If /PROT specified, xabpro must not be removed to allow it
!		to work).
!
!	X00015	TMH0014		Tim Halvorsen	19-Mar-1980
!		Do not remove output XABPRO,RDT,DAT blocks if concat_follows
!		flag is set because we were only trying to prevent changing
!		characteristics on existing files -- concatenation always
!		produces a new file.  Also, inhibit wildcard directories on
!		output file specifications.
!
!	X00014	TMH0013		Tim Halvorsen	17-Mar-1980
!		Issue ENDPRM2 call at the same time as ENDPRM1 call
!		to eliminate problems with parameter ordering (in MCR,
!		the parameters appear in reverse order).
!
!	X00013	JAK0003		J. Krycka	14-Jan-1980
!		Undo X00005 change so that COPY will be able to use block I/O
!		to copy relative and indexed files over the network.
!
!	X00012	TMH0012		T. Halvorsen	29-Dec-1979
!		Remove XABPRO on appends since changing both owner or
!		protection is prohibited (see X00010)
!
!	X00011	TMH0011		T. Halvorsen	15-Nov-1979
!		Call CLI back with ENDPRM2 after output filespec is
!		obtained to signal any unprocessed qualifiers.
!
!	X00010	TMH0010		T. Halvorsen	13-Nov-1979
!		Zero the owner UIC field of the XABPRO on appends since
!		changing the owner UIC for an existing file is prohibited.
!
!	X00009	TMH0009		T. Halvorsen	24-Oct-1979
!		Test for output spec of only an explicit nodename
!		so that the filename is defaulted correctly.
!		Fix relative volume placement control to be hard (issue an
!		error if the file cannot completely be placed on the volume).
!
!	X00008	T. Halvorsen	25-Jul-1979
!		Add relative volume placement control.
!		Fix message to indicate contiguous-best-try is being tried
!		when there is not enough contigous space rather than issuing
!		an error message.
!
!	X00007	T. Halvorsen	14-Jul-1979
!		Fix problem copying ISAM files after another file (BIO
!		was left on from previous file).
!
!	X00006	JAK0002		J. Krycka	16-Mar-1978	14:00
!		To support copy of files over the network, get ALQ and DEQ
!		values from input XABALL if NET bit is set.
!
!	X00005	JAK0001		J. Krycka	16-Mar-1978	14:00
!		To support copy of relative files over the network, set
!		BRO bit in output FAB if NET bit is set.
!
!	X00004	CHP20339	C. Peters	25-Oct-1978	14:10
!		In COPY$GET_INFILE, zero ESL and RSL fields to avoid
!		reporting wrong file specification on error.
!
!	X00003	CHP19547	C. Peters	7-Oct-1978	14:27
!		Don't make version numbers sticky in an APPEND command.
!
!--

!
! Table of Contents
!
FORWARD ROUTINE
    copy$get_infile,					! Obtains the input file specification
    copy$opn_infile,					! Opens the current input file
    copy$get_outfil,					! Obtains the output file specification
    copy$opn_outfil,					! Opens the current output file
    setup_extend,					! Sets up an output file to be extended.
    setup_outxab	: NOVALUE,			! Sets up XAB fields for an output file.
    apply_out_qual	: NOVALUE,			! Sets output fields depending on file qualifiers.
    setup_conc_xab	: NOVALUE,			! Sets up XAB protection fields.
    setup_prot_xab	: NOVALUE;			! Sets up XAB protection fields.

!
! Include files
!

LIBRARY 'SYS$LIBRARY:STARLET.L32';			! VAX/VMS system definitions

LIBRARY 'SYS$LIBRARY:CLIMAC.L32';			! Definitiona for the Command Language Interface

REQUIRE 'SRC$:COPY.REQ';				! Common COPY literal definitions and macros

REQUIRE 'SRC$:COPYMSG.REQ';				! Definition of macros to SIGNAL a message

!
! External variables
!
EXTERNAL
    align_location,					! location alignment for output file
    align_option,					! output alignment option
    align_type,						! type of output file alignment
    alloc_value,					! allocation quantity for output file
    appe_cont_qual	: BLOCK [, BYTE],		! CONTIGUOUS qualifier CLI data area for APPEND
    appe_oread_qual	: BLOCK [, BYTE],		! READ_CHECK qualifier CLI data area for APPEND
    appe_writ_qual	: BLOCK [, BYTE],		! WRITE_CHECK qualifier CLI data area for APPEND
    cli_work_area	: BLOCK [, BYTE],		! CLI dynamic work area
    cleanup_desc	: BLOCK [, BYTE],		! Parameter "cleanup" request work area
    cleanup2_desc	: BLOCK [, BYTE],		! Output param "cleanup" request block
!
!   Note that COPY$CLI_RESULT, COPY$CLI_STATUS, and COPY$SEM_STATUS are declared external
!   in the REQUIRE file COPY.REQ.
!
    copy_conc_qual	: BLOCK [, BYTE],		! CONCATENATE qualifier CLI data area for COPY
    copy_cont_qual	: BLOCK [, BYTE],		! CONTIGUOUS qualifier CLI data area for COPY
    copy_oread_qual	: BLOCK [, BYTE],		! READ_CHECK qualifier CLI data area for COPY
    copy_writ_qual	: BLOCK [, BYTE],		! WRITE_CHECK qualifier CLI data area for COPY
    dummy_nam_blk	: BLOCK [, BYTE],		! Holds input file specification, used for "stickiness" 
    extension_value,					! output extension quantity
    file_max_value,					! maximum number of records for output file
    infile_desc		: BLOCK [, BYTE],		! CLI block for input file request work area
    in_name_desc	: VECTOR,			! Descriptor of input file specification
    outfile_desc	: BLOCK [, BYTE],		! CLI block for output file dynamic work area
    out_name_desc	: VECTOR,			! descriptor for output file specification
    protect_and		: WORD,				! Protection value AND mask
    protect_or		: WORD,				! Protection value OR mask
    volume_value	: WORD;				! VOLUME qualifier value

EXTERNAL ROUTINE
    copy$calc_alq,					! Calculates a file extension quantity.
    copy$close_outf,					! Closes an output file
    copy$inopn_err,					! Handles an input $OPEN error
    copy$log_msg,					! Logs a message about COPY's activities
    copy$oclose_err,					! Handles an output file close error.
    copy$outopn_err,					! Handles an output $OPEN error
    copy$pars_infil,					! Parses an input file specification
    copy$semantics;					! Determines semantics of a command

GLOBAL ROUTINE copy$get_infile (input_fab, input_nam, input_xaball) =
							! Obtain input file specification

!++
! Functional description:
!
!	This routine gets an input file specification and all
!	related qualifiers from the Command Language Interpreter. Then
!	the file specification is parsed.
!
!	If a wildcard specification is still being processed, or if
!	no more input specifications are available, this routine just
!	returns successfully.
!
!	A series of flags are set if certain conditions obtain. These
!	conditions describe the current list of files that are candidates
!	for concatenation. The flags are set if the file specification
!	contains input wildcards, an explicit wildcard version number, or an explicit version number.
!
!	Another flag applies only to this specification and says whether it contains any wildcards.
!
! Calling sequence:
!
!	copy$get_infile (input_fab.ra.v, input_nam.ra.v, input_xaball.ra.v)
!
! Input parameters:
!
!	input_fab	- the FAB to use for this input specification
!	input_nam	- the NAM to use for this input specification
!	input_xaball	- the XABALL to use for this input specification
!
! Implicit inputs:
!
!	wildcard_active	- a bit in COPY$CLI_STATUS that says that we are
!			  already processing an input wildcard.
!	infile_desc	- CLI block for input file specifications
!	cleanup_desc	- CLI block for end of input cleanup operations
!
! Output parameters:
!
!	none
!
! Implicit outputs:
!
!	The fields of the FAB and the NAM block are filled in according
!	to the CLI call and the $PARSE function call.
!
!	The RSL field of the dummy_nam_blk is filled in by the routine COPY$PARS_INFIL. This is later
!	used in parsing the name additional input files or output files.
!
!	A bit in COPY$CLI_STATUS may be set:
!
!		multiple_input	- more than one input file specification in the command
!		wildcard_active	- if a wildcard is present
!
!	Some bits in COPY$SEM_STATUS may be set:
!
!		wild_input	- wildcard fields exist
!		wild_inp_ver	- a wildcard version number exists
!		exp_inp_ver	- an explicit version number exists
!
! Routine value:
!
!	OK		- success
!	NO_MORE_FILES	- success, no more input specifications
!	NO_FILE		- failure
!
! Side effects:
!
!	none
!
!--

    BEGIN

    MAP
        input_fab	: REF BLOCK [, BYTE],		! FAB to use with input file
        input_nam	: REF BLOCK [, BYTE],		! NAM to use with input file
        input_xaball	: REF BLOCK [, BYTE];		! XABALL to use with input file

!
! Return if a wildcard file specification is currently being processed.
!

    IF .wildcard_active					! If a wildcard specification is currently
    THEN						! being processed, then just return to caller.
        RETURN ok;

!
! Also return if there are no more input specifications coming.
!

    IF NOT .infile_desc [cli$v_concatinp]		! If no more input specs are coming,
    THEN
        RETURN no_more_files;				!    then return successfully, without a file.

!
! Get the first input file specification from the Command Language Interpreter.
!

    call_cli (						! Call the CLI with the following arguments:
                infile_desc,				!    Input file descriptor address
                cli_work_area,				!    CLI work area address
                copy$cli_status);			!    COPY status indicator vector address

    IF NOT .infile_desc [cli$v_concatinp]		! If no more file specifications follow,
    THEN
	BEGIN
        call_cli (					! call the CLI with the following arguments:
                    cleanup_desc,			!    Parameter cleanup descriptor address
                    cli_work_area,			!    CLI work area address
                    copy$cli_status);			!    COPY status indicator vector address

        call_cli (  cleanup2_desc,			! Signal any unprocessed qualifiers
		    cli_work_area,
		    copy$cli_status);
	END


    ELSE
        multiple_input = TRUE;				! Otherwise, note that multiple input specifications
							!    will be seen.

!
! Initialize the input file FAB.
!

    $FAB_INIT (						! Setup the input file FAB as follows:
                FAB = .input_fab,			!    FAB address is the input parameter
                FAC = <GET,BRO>,				!    Input file, mixed block and record access
                SHR = GET,				!    Allow others to read the input file
                DNA = 0,				!    No default file specification
                RTV = 0,				!    Use default retrieval window size
                RAT = CR,				!    Carriage control in case unit record input
                FOP = <SQO,NAM>,			!    Sequential I/O only, open by name block
                NAM = .input_nam,			!    NAM block address
                XAB = .input_xaball);			!    XABALL block address.

!
! Reinitialize the RSL and ESL fields of the NAM block so that a parsing
! error does not report an error in the previous file processed.
!

    input_nam [nam$b_esl] = 0;				! Expanded string length of zero.
    input_nam [nam$b_rsl] = 0;				! Resultant string length of zero.

!
! Call RMS $PARSE function to parse the input file specification. This resolves logical names and
! determines if there are wildcards present, or explicit named fields present.
!

    IF NOT copy$pars_infil (				! Parse the input file specification.
                            .input_fab,			!    Specify the input FAB block address
                            .input_nam)			!    and the input NAM block address.
    THEN
        RETURN no_file;					! If the $PARSE fails, return an error code.

!
! Now test the type of expanded name string that we have. Does it contain wildcards? Were
! certain fields explicitly named?
!

    IF .input_nam [nam$v_wildcard]			! If there were any wildcards,
    THEN
        BEGIN
        wildcard_active = TRUE;				!    set WILDCARD_ACTIVE. This says current file
							!    specification contains wildcards.
        wild_input = TRUE;				!    Also set WILD_INPUT. This says that the current
							!    input list contains wildcard specs somewhere.
        END
    ELSE						! If no input wildcards in this spec, turn off
        wildcard_active = FALSE;			!    the WILDCARD_ACTIVE flag.

    IF .input_nam [nam$v_wild_ver]			! If an explicit wildcard version number
    THEN						!    was specified,
        wild_inp_ver = TRUE				!    set the WILD_INP_VER flag.
    ELSE						! Otherwise,
        BEGIN
        IF .input_nam [nam$v_exp_ver]			!    see if an explicit version number was specified.
        THEN						!    If it is, set the EXP_INP_VER flag, meaning
            exp_inp_ver = TRUE;				!    that there is an explicit input version number.
        END;

!
! Return with success.
!

    RETURN ok;
    END;

GLOBAL ROUTINE copy$opn_infile (input_fab) =		! Open the current input file

!++
! Functional description:
!
!	This routine opens the current input file. If the input file
!	specification contains a wildcard field, an RMS $SEARCH for the
!	next wildcard match occurs before the actual file open.
!
!	Any input parameter qualifiers are applied to the file's RMS blocks before
!	the open is performed. For now, the only valid qualifier is /READ_CHECK.
!
!	If the OPEN fails, an error is reported to SYS$ERROR. When input wildcards are present,
!	two types of failure are permitted:
!
!		RMS$_NMF	- no more files match given wildcard
!		open failure	- allowed when a file matching a wildcard spec cannot be
!				  opened, as long as that file would have been copied without concatenation.
!
! Calling sequence:
!
!	copy$opn_infile (input_fab.ra.v)
!
! Input parameters:
!
!	input_fab	- the FAB associated with the input file
!
! Implicit inputs:
!
!	COPY$CLI_STATUS bits are checked:
!
!		iread_check_bit	- This bit is set if the /READ_CHECK qualifier was specified for this file.
!		wildcard_active	- This specification contains wildcards.
!				  Find the next file with a $SEARCH function call.
!
!	input file NAM block is read to obtain the length of the resultant name string
!
!	COPY$SEM_STATUS bits are checked:
!
!		multiple_output	- Multiple files are being produced. This is checked to allow for
!				  open failure on a wildcard specified file.
!
! Output parameters:
!
!	none
!
! Implicit outputs:
!
!	in_name_desc	- the length field of the input name descriptor is written from the RSL
!			  field in the NAM block
!
!	The FAB$V_RCK bit in the input FAB is set if /READ_CHECK was specified.
!
!	COPY$CLI_STATUS bit settings may be altered:
!
!		wildcard_active	- turned off if no more files that match wildcard are found.
!		infile_open	- set if the file is opened successfully
!
! Routine value:
!
!	OK		- input file open
!	NO_MORE_FILES	- no further wildcard match found
!	NO_WILD_OPEN	- open failure on wildcard match file
!	NO_FILE		- input file not found
!
! Side effects:
!
!	The input file is opened.
!	If an RMS SEARCH function fails, then an error is reported on SYS$ERROR.
!
!--

    BEGIN

    MAP
        input_fab	: REF BLOCK [, BYTE];		! input FAB block

    BIND
        input_nam	=				! input NAM block address
                        .input_fab [fab$l_nam] : BLOCK [, BYTE];

    LOCAL
        status;						! RMS status code variable

!
! If a wildcard specification is active, call RMS to search for the next wildcard match.
!

    IF .wildcard_active					! If an input wildcard field is present,
    THEN
        BEGIN
        status = $RMS_SEARCH (				!    then call RMS to search the directory for
                                FAB = .input_fab);	!    the next match.

        IF .status EQL rms$_nmf				! If no more wildcard matches exist,
        THEN
            BEGIN
            wildcard_active = FALSE;			!    turn off the WILDCARD_ACTIVE flag,
            RETURN no_more_files;			!    and return with success status of NO_MORE_FILES.
            END;

        IF NOT .status					! If RMS returned some other error code,
        THEN
            BEGIN
            copy$inopn_err (				!    then call the RMS error action routine.
                            .input_fab);
            wildcard_active = FALSE;			!    Turn off the wildcard flag so that we don't look
            RETURN no_file;				!    for the file again. Return to caller with NO_FILE
            END;					!    error code.
        END;						! End of special wildcard search processing.

!
! If the user specified the input read checking qualifier, turn on the appropriate bit in the FAB.
!

    IF .copy$cli_status [iread_check_bit]		! If input read checking was requested,
    THEN
        input_fab [fab$v_rck] = TRUE			!    then turn on the FAB read check indicator.
    ELSE
        input_fab [fab$v_rck] = FALSE;			!    Otherwise, turn it off.

!
! Open the input file.
!

    IF $RMS_OPEN (					! Open the input file with RMS.
                    FAB = .input_fab,			!    Specify the input parameter for the FAB,
                    ERR = copy$inopn_err)		!    and an error action routine.
    THEN						! If the OPEN is successful,
        BEGIN
        infile_open = TRUE;				!    indicate that the file is open
        in_name_desc [0] = .input_nam [nam$b_rsl];	!    and set the length of the input file name descriptor.
        RETURN ok;					! Return to caller with success code.
        END						! End of successful OPEN processing

    ELSE
        BEGIN

!
! If multiple output files are being produced, and this is a file that matches a wildcard specification,
! allow the open to fail. This means that one file that matches the wildcard specification is not copied
! to a new output file.
!

        IF .wildcard_active AND				! If wildcard input,
            (.multiple_output OR NOT .concat_qual)	!    and multiple output files are being produced
							!    or the /CONCATENATE qualifier was not given explicitly,
        THEN
            RETURN no_wild_open				!    then return a success status code
        ELSE
            RETURN no_file;				! Otherwise, return an error status code.
        END;

    END;

GLOBAL ROUTINE copy$get_outfil (output_fab, output_nam, output_xabfhc) =
							! Obtain the output file specification

!++
! Functional description:
!
!	This routine obtains the output file specification and all
!	related qualifiers from the Command Language Interpreter. Then
!	the file specification is parsed without any help from related input file name
!	blocks. This initial parse determines whether the file specification had null file
!	name, type, and version number fields.
!
!	If no output file name, type, or version number is given, a flag
!	is set in COPY$SEM_STATUS.
!
! Calling sequence:
!
!	copy$get_outfil (output_fab.ra.v, output_nam.ra.v, output_xabfhc.ra.v)
!
! Input parameters:
!
!	output_fab	- the FAB to use for this output specification
!	output_nam	- the NAM to use for this output specification
!	output_xabfhc	- the XABFHC to use for this output specification
!
! Implicit inputs:
!
!	outfile_desc	- the CLI block for the output file specification
!
!	The RLF field of the output NAM block contains the address of the input file NAM block.
!
! Output parameters:
!
!	none
!
! Implicit outputs:
!
!	The fields of the FAB and the NAM block are filled in according
!	to the CLI call, FAB initialization, and the $PARSE function call.
!
!	A bit may be set in COPY$SEM_STATUS:
!
!		no_output_spec	- no output name, type, or version number specified.
!
! Routine value:
!
!	OK		- success
!	NO_FILE		- the $PARSE function call returned an error code
!
! Side effects:
!
!	An error is reported if the $PARSE function returns an error status code and
!	COPY$OUTOPN_ERR is called.
!
!--

    BEGIN

    MAP
        output_fab	: REF BLOCK [, BYTE],		! FAB to use with output file
        output_nam	: REF BLOCK [, BYTE],		! NAM to use with output file
        output_xabfhc	: REF BLOCK [, BYTE];		! XABFHC to use with output file

    LOCAL
        temp_rlf;					! Holds the output RLF field

!
! Get the output file specification from the Command Language Interpreter.
!

    call_cli (						! Call the CLI with the following arguments:
                outfile_desc,				!    Output file request descriptor address
                cli_work_area,				!    CLI work area address
                copy$cli_status);			!    COPY status bit vector address

!
! Initialize the output file FAB.
!

    $FAB_INIT (						! Setup the output file FAB as follows:
                FAB = .output_fab,			!    FAB address is the output parameter
                FAC = <PUT,TRN>,			!    Output file
                SHR = NIL,				!    No file sharing
                FNA = .outfile_desc [cli$a_rqaddr],	!    File name address from CLI
                FNS = .outfile_desc [cli$w_rqsize],	!    File name size from CLI also
                RTV = 0,				!    Use the system default retrieval window size
                FOP = <SQO,OFP,NAM>,			!    Sequential operations only, output file parse,
                NAM = .output_nam,			!    NAM block address
                XAB = .output_xabfhc);			!    XABFHC block address
							!        name block open

!
! Zero the expanded string length so that the COPY error routine, copy$outopn_err, can
! decide if an expanded name string was created by RMS.
!

    output_nam [nam$b_esl] = 0;				! Zero the output expanded string length.

!
! Temporarily remove the RLF field of the output NAM block so that the
! output file specification can be tested for null name, type, and
! version number fields.
!

    temp_rlf = .output_nam [nam$l_rlf];			! Save the RLF field because it may be needed later.
    output_nam [nam$l_rlf] = 0;				! Set the RLF field to null.

!
! Parse the output file specification.
!

    IF NOT $RMS_PARSE (					! Call the RMS function that parses file specifications,
                        FAB = .output_fab,		!    specifying the output FAB parameter,
                        ERR = copy$outopn_err)		!    and an error routine.
    THEN						! If the PARSE is not successful,
        RETURN no_file;					!    then return an error code to the caller.

!
! Test for an absence of the file name, type, and version number fields
! (or the presence of a network quoted string).
!

    IF (NOT .output_nam [nam$v_wild_name]) AND		! If no output wildcards are present,
        (NOT .output_nam [nam$v_wild_type]) AND	
        (NOT .output_nam [nam$v_wild_ver]) AND	
	(NOT .output_nam [nam$v_quoted]) AND		!    and no quoted string
        (NOT .output_nam [nam$v_exp_name]) AND		!    and no output name,
        (NOT .output_nam [nam$v_exp_type]) AND		!    and no output type,
        (NOT .output_nam [nam$v_exp_ver]) AND		!    and no output version number,
        (.output_nam [nam$v_exp_dir] OR			!    and an explicit directory
        .output_nam [nam$v_exp_dev] OR			!    or device name
	.output_nam [nam$v_node])			!    or node name is given,
    THEN
        no_output_spec = TRUE;				!    then set NO_OUTPUT_SPEC bit.

!
! Reload the RLF field. Another PARSE will be performed later in the routine
! COPY$OPN_OUTFIL and may take fields from the input resultant file string.
!

    output_nam [nam$l_rlf] = .temp_rlf;

!
! Return with a success code.
!

    RETURN ok;						! Return successfully.

    END;

GLOBAL ROUTINE copy$opn_outfil (output_fab, output_rab, input_fab, out_file_count) =
							! Opens the current output file

!++
! Functional description:
!
!	This routine opens the current output file. If it is already open due
!	to input file concatenation, the output file RAB is simply disconnected from
!	the FAB to permit switching from block mode I/O to record mode I/O.
!
!	Many of the fields in the input FAB and XAB blocks are copied into the corresponding
!	output FAB and XAB blocks. Also, bits and values are set in the output XAB and FAB blocks
!	because of output file qualifiers specified on the command.
!
!	If the output file already exists, and is being overwritten, it is opened
!	for output. If the output file does not exist, it is allocated and then opened.
!
! Calling sequence:
!
!	copy$opn_outfil (output_fab.ra.v, output_rab.ra.v, input_fab.ra.v, out_file_count.wl.r)
!
! Input parameters:
!
!	output_fab	- the address of the FAB associated with the output file
!	output_rab	- the address of the RAB to be used with the output file
!	input_fab	- the address of the FAB associated with the input file
!
! Implicit inputs:
!
!	copy$cli_status	- the OUTFILE_OPEN bit indicates whether an output file is already open.
!			- bits indicate the settings of the output file qualifiers
!
!	Fields from the input NAM and XAB block are used in the output NAM and XAB blocks.
!
! Output parameters:
!
!	out_file_count	- a counter that is incremented if a new file is opened.
!
! Implicit outputs:
!
!	copy$cli_status	- OUTFILE_OPEN is set once the file is opened.
!			- EXTEND_OUTFILE is set if the output file is being extended.
!
!	Fields are written in the output_fab and its associated NAM and XAB blocks.
!
!	out_name_desc	- a descriptor for the output file. Its length field is written.
!
!	When the output file name is parsed, various bits are set in
!	COPY$SEM_STATUS. These include:
!
!		wild_output	- output spec includes explicit wildcards
!		wild_out_ver	- explicit wildcard version number
!
! Routine value
!
!	OK		- output file successfully created or readied for more output
!	NO_FILE		- output file could not be opened, created, or readied for output
!
! Side effects:
!
!	The routine SETUP_EXTEND is called if the output file is open. The value of this call
!		is returned to the caller.
!	The routine SETUP_OUTXAB is called to write most of the output XAB block fields.
!	Messages are output if a file was created during an APPEND command, if versions were
!		slipped under higher existing versions, or if files were replaced or overlaid.
!
!--

    BEGIN

    MAP
        output_fab	: REF BLOCK [, BYTE],		! FAB to use with output file
        output_rab	: REF BLOCK [, BYTE],		! RAB to use with output file
        input_fab	: REF BLOCK [, BYTE],		! FAB of the current input file
        out_file_count	: REF VECTOR;			! pointer to number of output files written

    BIND
        output_nam	=				! output NAM block address
                .output_fab [fab$l_nam] 	: BLOCK [, BYTE],
        output_xabfhc	=				! output XAB file header characteristics block
                .output_fab [fab$l_xab]		: BLOCK [, BYTE],
        output_xaball	=				! output XAB date block
                .output_xabfhc [xab$l_nxt]	: BLOCK [, BYTE];

    LOCAL
        output_xabpro	: REF BLOCK [, BYTE],		! Pointer to output XAB protection block
        status;						! Status variable for calling semantic routine.

!
! If the output file is already open (due to input file concatenation), call a routine,
! SETUP_EXTEND, to prepare the file to contain more data.
!

    IF .outfile_open					! If the output file is already open,
    THEN
        RETURN setup_extend (				!    call a routine to set the file up
                             .output_rab);		!    to be extended.

!
! Copy a set of FAB attributes from the input to the output FAB.
!

    output_fab [fab$b_org] = .input_fab [fab$b_org];	! The fields copied are file organization,
    output_fab [fab$b_rat] = .input_fab [fab$b_rat];	!    record attributes
    output_fab [fab$w_mrs] = .input_fab [fab$w_mrs];	!    maximum record size
    output_fab [fab$l_mrn] = .input_fab [fab$l_mrn];	!    maximum record number
    output_fab [fab$b_rfm] = .input_fab [fab$b_rfm];	!    record format
    output_fab [fab$b_fsz] = .input_fab [fab$b_fsz];	!    fixed control area size
    output_fab [fab$b_bks] = .input_fab [fab$b_bks];	!    bucket size
    output_fab [fab$w_gbc] = .input_fab [fab$w_gbc];	!    global buffer count

!
! If the input file has read or write checking options, copy them to the output file.
!

    output_fab [fab$l_fop] = .output_fab [fab$l_fop] OR	! OR together the current FOP output field
        (.input_fab [fab$l_fop] AND (fab$m_rck OR fab$m_wck));
							!    and the read and write check bits of the
							!    FOP input field.

!
! Decide on block or record I/O.
!

    IF .input_fab [fab$b_org] EQL fab$c_seq		! If the input file is a sequential file,
    THEN
        output_fab [fab$v_bro] = TRUE			!    then indicate mixed block and record I/O.
    ELSE
	BEGIN
        output_fab [fab$v_bio] = true;			! Otherwise, indicate only block I/O.
	output_fab [fab$v_bro] = false;			! and turn off block/record I/O
	END;

!
! Copy input blocksize for tapes. Otherwise let RMS set the output blocksize.
!

    IF .input_fab [$FAB_DEV (sqd)]			! If input device is a tape,
    THEN
        output_fab [fab$w_bls] = .input_fab [fab$w_bls]	!    then copy the blocksize to the output FAB.
    ELSE
        output_fab [fab$w_bls] = 0;			! Otherwise, let RMS choose blocksize.

!
! If no output file name, type, or version number was given, then the NO_OUTPUT_SPEC bit
! will be set by now. This probably means that no concatenation is occurring. Therefore,
! if this is a COPY (as opposed to an APPEND) command,
! and the command qualifier /CONCATENATE is not present, provide a default
! name string (DNA field) that contains a wildcard version number.
!
! This is because RMS does not apply input version number specifications to a general output
! file parse.
!

    IF (NOT .append_command) AND			! If not APPENDing files to an existing file
        (.no_output_spec)				!    and no output name, type, or version number specified,
    THEN
        BEGIN
        output_fab [fab$l_dna] = UPLIT (';*');		!    then setup a default name string consisting
        output_fab [fab$b_dns] = 2;			!    of ";*", meaning wildcard version number.
        END;

!
! Now $PARSE (this may be a reparse) the output file specification.
!

    IF NOT $RMS_PARSE (					! $PARSE the output file by calling an
                        FAB = .output_fab,		!    RMS function.
                        ERR = copy$outopn_err)		!    Specify an error routine.
    THEN
        RETURN no_file;					! Return on error with error status code.

!
! Now a special check for input wildcard version number not accompanied by wildcard output
! version number or explicit output version number. If this occurs, version scrambling will 
! result. So special case check it, and reparse with default name string of wildcard output
! version number if necessary.
!
! Also apply this default name string to an explicit input wildcard version number not
! accompanied by any output version number. This causes an explicit input version number to
! be carried over to the new file.
!

    IF (((.wild_inp_ver) OR				! If wildcard input version number,
        (.exp_inp_ver)) AND				!    or explicit input version number,
        (NOT .append_command) AND			!    and this is a copy command,
        (NOT .output_nam [nam$v_wild_ver]) AND		!    and no explicit output version
        (NOT .output_nam [nam$v_exp_ver])) 		!    number, wildcard or otherwise,
        OR
        ((NOT .output_nam [nam$v_exp_ver]) AND		! OR if the output file name is only
        (.output_nam [nam$v_wild_type] OR			!    a wildcard name field ("*"),
        (NOT .output_nam [nam$v_exp_type])) AND
        .output_nam [nam$v_wild_name])
    THEN
        BEGIN						! Then provide a default name string
        output_fab [fab$l_dna] = UPLIT (';*');		!    of an explicit output wildcard
        output_fab [fab$b_dns] = 2;			!    version number,

        IF NOT $RMS_PARSE (				!    and redo the parse,
                            FAB = .output_fab,		!    specifying  the output FAB address
                            ERR = copy$outopn_err)	!    and an error action routine.
        THEN
            RETURN no_file;				! On failure, return with an error code.
        END;

!
! No director wildcards allowed to remain at this time
!

    BEGIN
    BIND
	lastchar = .output_nam[nam$l_dir] + .output_nam[nam$b_dir] - 2 : byte;
    IF .lastchar EQL %C'*'  OR
	.lastchar EQl %C'.'
    THEN
	BEGIN
	LOCAL
	   outputstr : vector[2];
	outputstr[0] = .output_nam [nam$b_esl];
	outputstr[1] = .output_nam [nam$l_esa];
	PUT_MESSAGE( MSG$_SYNTAX,
		    1,
		    outputstr,
		    0 );
	RETURN no_file;
	END;	
    END;

!
! Test the expanded name string for the output file. Does it contain wildcards? If so,
! is there an explicit wildcard version number?
!

    IF .output_nam [nam$v_wildcard]			! If there were any wildcards,
    THEN
        wild_output = TRUE;				!    set flag saying that the file specification
							!    contained some wildcard fields.

    IF .output_nam [nam$v_wild_ver]			! If the version number is a wildcard,
    THEN
        BEGIN
        IF .output_fab [fab$b_dns] NEQ 0		!    see whether it was supplied by us.
        THEN
            BEGIN					! This version wildcard was supplied by COPY.
            IF NOT .output_nam [nam$v_wild_name] AND	!    If the file name or type field
                NOT .output_nam [nam$v_wild_type]	!    were not explicitly wild,
            THEN wild_output = FALSE;			!    then turn off the wildcard output flag.
            END
        ELSE						! Otherwise, if the user specified a wildcard
            wild_out_ver = TRUE;			!    output version number, remember it.
        END
    ELSE
        BEGIN
        IF .output_nam [nam$v_exp_ver]			! Otherwise, see if an explicit version number was specified.
        THEN
            exp_out_ver = TRUE;				!    If so, set the EXP_OUT_VER flag.
        END;

!
! Call the routine SETUP_OUTXAB to copy output XAB fields from the corresponding input XAB fields.
!

    setup_outxab (					! Write output XAB fields by calling
                    .output_fab,			!    a routine that selects the necessary fields from
                    .input_fab);			!    the input FAB and writes them into the output FAB.

!
! Call the routine APPLY_OUT_QUAL to write RMS fields according to output parameter qualifiers.
!

    apply_out_qual (					! Process output file qualifiers
                    .output_fab);

!
! Call the routine COPY$SEMANTICS to determine the semantic effects of
! this particular combination of input and output file specifications and qualifiers.
!

    IF NOT copy$semantics (				! Decide what semantic behavior is required.
                                copy$sem_status,	!    Pass the status variable copy$sem_status,
                                .input_fab,		!    the input FAB block address,
                                .output_fab)		!    and the output FAB block address.
    THEN						! If the input/output spec combination makes no sense,
        RETURN no_file;					!    then return with error status code.

!
! Perform special XAB setup if a concatenated file is being created.
!

    setup_conc_xab (.output_fab, .input_fab, output_xabpro);
							! Call a routine to set up protection fields.
							!    Returns with address of XABPRO block.

!
! Create (or simply open) the output file.
!

    extend_outfile = FALSE;				! Assume that the output file is not being extended.

!
! If a file needn't be created, just open an existing file.
!

    IF .append_command AND				! If this is an APPEND command and
        NOT .copy$cli_status [new_bit]			!    and output file creation was not requested,
    THEN
        status = $RMS_OPEN (				!    then $OPEN an existing file,
                            FAB = .output_fab,		!    specifying the output FAB block address,
                            ERR = copy$outopn_err)	!    and an error action routine.

    ELSE
        BEGIN
        status = $RMS_CREATE (FAB = .output_fab);	! Else, create (or open if it exists) file

!
! If the file could not be created as a contiguous file because the disk was too full,
! then try to create it contiguous best try.
!

        IF .status EQL rms$_ful				! If allocation space was not available,
            AND .output_xaball [xab$v_ctg]		!    and the file was being created contiguous,
            AND NOT .copy$cli_status [contiguous_bit]	!    and the used didn't say /CONTIGUOUS explicitly,
        THEN
            BEGIN
            output_xaball [xab$v_ctg] = FALSE;		!    then turn off the contiguous indicator,
            output_xaball [xab$v_cbt] = TRUE;		!    turn on the contiguous best try indicator,
            status = $RMS_CREATE (			!    and retry the create.
                                    FAB = .output_fab,	! Specify the address of the FAB block
                                    ERR = copy$outopn_err);
	    IF .status					! If contig-best-try ok,
	    THEN
		put_message (msg$_cbt);			! then issue message
            END						!    and an error action routine.
	ELSE
	IF NOT .status					! Else, if error,
	THEN
	    copy$outopn_err (.output_fab);		! issue error message

!
! Change the RMS return status to "created" if indeed the file was created.
!

        IF NOT .output_fab [fab$v_cif] AND		! Since RMS returns RMS$_NORMAL whether or not the
            .status EQL rms$_normal			!    file was created, for internal reporting, change
        THEN						!    the status code to RMS$_CREATED if appropriate.
            status = rms$_created;			!    (I.e., if the file was created.)
!
! If the output file was copied to a 10,20 or RT node and it was forced to a
! stream format file, then (if the /LOG qualifier was specified) warn the user
! of the conversion.
!
	IF .status EQL rms$_cre_stm AND .LOG_MSG
	THEN
	   BEGIN			
	   out_name_desc [0] = .output_nam [nam$b_rsl];	! Store the length of the filespec
	   put_message (msg$_createdstm,1,		! Issue the message
			out_name_desc);
	   status = rms$_created;			! Change the status as above
	   END;
        END;

    IF NOT .status					! If the open or create failed,
    THEN
        RETURN no_file;					!    then return an error status code.

    outfile_open = TRUE;				! Otherwise, set a flag saying that an output file is open,
    out_name_desc [0] = .output_nam [nam$b_rsl];	!    and store the length of the file specification.

!
! Set up output protection if user specified it explicitly.
!

    setup_prot_xab (.output_xabpro);			! Set up explicit file protection.

!
! Clean up the output open procedure by reporting to the user if necessary and
! updating more fields.
!

    SELECTONE .status OF				! Select additional processing based on the

        SET						!    RMS completion code from the OPEN or CREATE.

        [rms$_created]:					! Output file was created.
            BEGIN
            out_file_count [0] =			!    Update count of files created.
                .out_file_count [0] + 1;

            IF .append_command				!    If this is an APPEND command,
            THEN
                copy$log_msg (				!    send the following message to the user:
                                msg$_created);		!        "<file-name> created" because creation is unusual.

            IF .output_nam [nam$v_highver] AND		!    If a higher version of this file exists,
                NOT .quiet_slip				!    and warnings about versions are not suppressed,
            THEN
                put_message (				!    send the following message to the user:
                                msg$_highver, 1,	!        "higher version of <file-name> exists"
                                out_name_desc);		!    because this may cause version confusion.

            END;


        [rms$_supersede]:				! Output file caused deletion of file of same name.
            BEGIN
            out_file_count [0] =			!    Update count of files created.
                .out_file_count [0] + 1;

            copy$log_msg (				!    Send the following message to the user:
                            msg$_replaced);		!        "<file-name> replaced" because
							!        supersession is unusual.

            END;


        [rms$_normal]:					! Output file existed previously and was opened.
            BEGIN
            IF .append_command				!    If this is an APPEND command,
            THEN
                BEGIN
                extend_outfile = TRUE;			!    set a flag saying that the file is being extended.

                output_xaball [xab$l_alq] =		!    Calculate the necessary extension quantity
                    copy$calc_alq ();			!    with a call to COPY$CALC_ALQ.

                IF .output_xaball [xab$l_alq] NEQ 0	!    If the extension quantity is not null,
                THEN
                    IF NOT $RMS_EXTEND (		!    then try to extend the file.
                                        FAB = .output_fab,
                                        ERR = copy$outopn_err)
                    THEN				!    If the extend fails,
                        RETURN no_file;			!    then return an error status code.

                END

            ELSE					!    If this is a COPY command,
                BEGIN
                copy$log_msg (				!    send the following message to the user:
                                msg$_overlay);		!        "<file-name> being overwritten"

! ******
!	Omitted here is the revision of the output file's attributes. Ward had this
!	commented out.
! ******

                END;

            END;

        TES;						! End of SELECT expression.

!
! Return to the caller with a success status code.
!

    RETURN ok;						! Return with a success code.
    END;

ROUTINE setup_extend (output_rab) =			! Setup a file to be extended.

!++
! Functional description:
!
!	This routine takes an open file and prepares it to be extended.
!
!	First, a DISCONNECT is performed. This permits switching from block mode I/O
!	to record mode I/O, if desired. Then update the output file allocation information,
!	set a bit in COPY$CLI_STATUS saying that the file is being extended, calculate
!	the file extension quantity, and extend the file.
!
! Calling sequence:
!
!	setup_extend (output_rab.ra.v)
!
! Input parameters
!
!	output_rab	- the RAB connected to the output FAB
!
! Implicit inputs
!
!	The FAB and XAB blocks associated with the specified output RAB block.
!
! Output parameters
!
!	none
!
! Implicit outputs
!
!	The allocation information in the FAB is updated.
!	The EXTEND_OUTFILE bit in COPY$CLI_STATUS is set.
!	The ALQ field in the output XAB block is set to an appropriate extension quantity.
!
! Routine value
!
!	OK		- success
!	NO_FILE		- failure
!
! Side effects
!
!	If the file cannot be extended, the file is closed.
!
!--

    BEGIN

    MAP
        output_rab	: REF BLOCK [, BYTE];		! output FAB of the open output file

    BIND
        output_fab	=				! associated output FAB block
                .output_rab [rab$l_fab]		: BLOCK [, BYTE],
        output_xabfhc	=				! associated output XAB block
                .output_fab [fab$l_xab]		: BLOCK [, BYTE],
        output_xaball	=				!    second XAB in XAB chain
                .output_xabfhc [xab$l_nxt]	: BLOCK [, BYTE];

    LOCAL
        status;						! Holds RMS status values

!
! Disconnect the RAB from the FAB. On error, close the file and return with error status code.
!

    IF NOT $RMS_DISCONNECT (				! Disconnect the output file RAB from its FAB.
                            RAB = .output_rab,		!    Specify the RAB block address
                            ERR = copy$oclose_err)	!    and an error routine.
    THEN
        BEGIN						! If the DISCONNECT fails,
        copy$close_outf (				!    close the output file,
                            output_fab);
        RETURN no_file;					!    and return with an error code.
        END;

!
! Shortening the XAB chain to include only the FHC (file header characteristics) XAB,
! call the RMS function $DISPLAY to update the output file allocation information
! as recorded in the XABFHC.
!

    output_xabfhc [xab$l_nxt] = 0;			! Leave only the FHC XAB on the XAB chain.

    status = $RMS_DISPLAY (				! Call DISPLAY to update the XAB information
                            FAB = output_fab,		!    about the file's allocation.
                            ERR = copy$outopn_err);	!    Specify an error action routine.

    output_xabfhc [xab$l_nxt] = output_xaball;		! Restore the XAB chain.

!
! See if the $DISPLAY function succeeded. If not, close the output file and return
! an error status code.
!

    IF NOT .status					! If the $DISPLAY function failed,
    THEN
        BEGIN
        copy$close_outf (				!    then close the output file,
                            output_fab);
        RETURN no_file;					!    and return an error status code.
        END;

!
! Set the bit in COPY$CLI_STATUS that indicates that the file is to be extended.
!

    extend_outfile = TRUE;				! Set EXTEND_OUTFILE bit.

!
! Calculate the file extension quantity and extend the file with an RMS $EXTEND function call.
! The routine COPY$CALC_ALQ does the calculation. It returns a "zero" in the following cases:
!
!	The output file is on a magtape or a nonfile-structured device.
!	The output file is already long enough to hold the size of the file to be appended.
!

    output_xaball [xab$l_alq] = copy$calc_alq ();	! Setup the output file extension quantity in the XAB.

    IF .output_xaball [xab$l_alq] EQL 0			! If the input file is of zero length,
    THEN
        RETURN ok;					!    then return with success code.

    IF $RMS_EXTEND (					! If the output file can be extended successfully,
                    FAB = output_fab,
                    ERR = copy$outopn_err)		!    (specify an error routine)
    THEN
        RETURN ok					!    then return with success code.
    ELSE
        RETURN no_file;					! Otherwise, return with error code.

    END;

ROUTINE setup_outxab (output_fab, input_fab) : NOVALUE =
							! Setup output XAB fields from input XAB fields

!++
! Functional description:
!
!	This routine copies input XAB fields into corresponding output XAB fields.
!
! Calling sequence:
!
!	setup_outxab (output_fab.ra.v, input_fab.ra.v)
!
! Input parameters:
!
!	output_fab	- FAB block associated with the output file
!	input_fab	- FAB block associated with the input file
!
! Implicit inputs:
!
!	output_xaball	- XABALL block for output file
!	output_xabdat	- XABDAT block for output file
!	output_xabfhc	- XABFHC block for output file
!	output_xabpro	- XABPRO block for output file
!	output_xabrdt	- XABRDT block for output file
!
!	input_xaball	- XABALL block for input file
!	input_xabdat	- XABDAT block for input file
!	input_xabfhc	- XABFHC block for input file
!	input_xabpro	- XABPRO block for input file
!
! Output parameters
!
!	none
!
! Implicit outputs
!
!	The relevant fields in the output XABs are written.
!
! Routine value
!
!	none
!
! Side effects
!
!	none
!
!--

    BEGIN

    MAP
        output_fab	: REF BLOCK [, BYTE],		! output file FAB block
        input_fab	: REF BLOCK [, BYTE];		! input file FAB block

    BIND
        output_xabfhc	=				! output file XABFHC block
                .output_fab [fab$l_xab]		: BLOCK [, BYTE],
        output_xaball	=				! output file XABALL block
                .output_xabfhc [xab$l_nxt]	: BLOCK [, BYTE],
        output_xabdat	=				! output file XABDAT block
                .output_xaball [xab$l_nxt]	: BLOCK [, BYTE],
        output_xabpro	=				! output file XABPRO block
                .output_xabdat [xab$l_nxt]	: BLOCK [, BYTE],
        output_xabrdt	=				! output file XABRDT block
                .output_xabpro [xab$l_nxt]	: BLOCK [, BYTE],
        input_xaball	=				! input file XABALL block
                .input_fab [fab$l_xab]		: BLOCK [, BYTE],
        input_xabdat	=				! input file XABDAT block
                .input_xaball [xab$l_nxt]	: BLOCK [, BYTE],
        input_xabfhc	=				! input file XABFHC block
                .input_xabdat [xab$l_nxt]	: BLOCK [, BYTE],
        input_xabpro	=				! input file XABPRO block
                .input_xabfhc [xab$l_nxt]	: BLOCK [, BYTE];

!
! Write the output allocation XAB.
!

    output_xaball [xab$b_aop] =
                        .input_xaball [xab$b_aop];	! Write the allocation options,
    output_xaball [xab$b_aln] =
                        .input_xaball [xab$b_aln];	!    and the alignment type.

    output_xaball [xab$l_alq] = copy$calc_alq ();	! Calculate and write in the allocation quantity.

    output_xaball [xab$w_deq] =
                        .input_xabfhc [xab$w_dxq];	! Write the default extension quantity.
    output_xaball [xab$b_bkz] =				! Write the default bucket size
                        .input_xaball [xab$b_bkz];	!    from the input XAB bucket size.

    output_xaball [xab$w_vol] = 0;			! Zero the related volume number,
    output_xaball [xab$l_loc] = 0;			!    the allocation location,
    output_xaball [xab$b_aid] = 0;			!    the area id number,
    output_xaball [xab$w_rfi0] = 0;			!    the related file number
    output_xaball [xab$w_rfi2] = 0;			!    the related file sequence number
    output_xaball [xab$w_rfi4] = 0;			!    and the related file revision number.

    IF .input_fab [$fab_dev(net)] AND			! If this is a network operation
       .output_xaball [xab$l_alq] EQL 0			!    and the calculated ALQ = 0,
    THEN output_xaball [xab$l_alq] =			!    then get ALQ from the FHC XAB
			.input_xabfhc [xab$l_hbk];	!

!
! Write the output Date/Time XAB.
!

    output_xabdat [xab$w_rvn] =				! Copy from the input file XABDAT,
                        .input_xabdat [xab$w_rvn];	!    the revision number,
    output_xabdat [xab$l_rdt0] =			!    the revision date,
                        .input_xabdat [xab$l_rdt0];
    output_xabdat [xab$l_rdt4] =			!    the revision time,
                        .input_xabdat [xab$l_rdt4];
    output_xabdat [xab$l_cdt0] =			!    the creation date,
                        .input_xabdat [xab$l_cdt0];
    output_xabdat [xab$l_cdt4] =			!    the creation time,
                        .input_xabdat [xab$l_cdt4];
!
! These values are not copied from the input, but defaulted instead,
! so the user will get new backup and expiration dates.
!
    output_xabdat [xab$l_edt0] =			!    the expiration date,
                        0;
    output_xabdat [xab$l_edt4] =			!    and the expiration time.
                        0;
    output_xabdat [xab$l_bdt0] =			!    the backup date
    			0;
    output_xabdat [xab$l_bdt4] =			!    and the backup time
    			0;

!
! Write the output File Header Characteristics XAB block.
!

    output_xabfhc [xab$b_rfo] =				! The XABFHC includes the
                        .input_xabfhc [xab$b_rfo];	!    record format and file organization,
    output_xabfhc [xab$b_atr] =				!    the record attributes,
                        .input_xabfhc [xab$b_atr];
    output_xabfhc [xab$w_lrl] =				!    the length of the longest record,
                        .input_xabfhc [xab$w_lrl];
    output_xabfhc [xab$b_bkz] =				!    the bucket size,
                        .input_xabfhc [xab$b_bkz];
    output_xabfhc [xab$b_hsz] =				!    the VFC header size,
                        .input_xabfhc [xab$b_hsz];
    output_xabfhc [xab$w_mrz] =				!    the maximum record length,
                        .input_xabfhc [xab$w_mrz];
    output_xabfhc [xab$w_dxq] =				!    and the default extension quantity.
                        .input_xabfhc [xab$w_dxq];

    output_xabfhc [xab$l_sbn] = 0;			! Zero the starting virtual block number.

!
! Write the output Protection XAB block. Most of this XAB can only be setup
! after the output file has been opened or created. Therefore, it is not done here.
!

    output_xabpro [xab$l_uic] = 0;			! Clear the file owner field.

!
! Write the output Revision Date/Time XAB block.
!

    output_xabrdt [xab$w_rvn] =				! Copy from the input XABDAT block
                        .input_xabdat [xab$w_rvn];	!    the input revision number,
    output_xabrdt [xab$l_rdt0] =			!    the input revision date,
                        .input_xabdat [xab$l_rdt0];
    output_xabrdt [xab$l_rdt4] =			!    and the input revision time.
                        .input_xabdat [xab$l_rdt4];

! ******
!	Temporarily, I omit the special saving of XABDAT and XABFHC fields
!	of a file that may be overwritten. This must go back in.
! ******

    END;

ROUTINE apply_out_qual (output_fab) : NOVALUE =		! Applies output parameter qualifiers to FAB and XAB

!++
! Functional description
!
!	This routine looks for the presence of qualifiers on the output file specification,
!	and sets RMS fields according to the semantics of each qualifier.
!
! Calling sequence:
!
!	apply_out_qual (output_fab.ra.v)
!
! Input parameters:
!
!	output_fab	- the FAB block related to the output file specification
!
! Implicit inputs:
!
!	output_xaball	- The XABALL block associated with the output FAB
!
!	The following bits in COPY$CLI_STATUS:
!
!		alignment_bit
!		allocation_bit
!		contiguous_bit
!		extension_bit
!		file_max_bit
!		overlay_bit
!		oread_check_bit
!		replace_bit
!		truncate_bit
!		write_check_bit
!		volume_bit
!
!	Some values associated with qualifiers specified for the output file specification:
!
!		align_type
!		align_option
!		align_location
!		alloc_value
!		extension_value
!		file_max_value
!		volume_value
!
! Output parameters
!
!	none
!
! Implicit outputs
!
!	Some fields in the output XABALL block are written:
!
!		ALN	- alignment type
!		AOP	- alignment option
!		LOC	- alignment location
!		ALQ	- allocation quantity
!		CTG	- contiguous file
!		CBT	- contiguous best try file
!		DEQ	- file extension quantity
!		VOL	- relative volume number
!
!	Some fields in the output FAB are written:
!
!		MRN	- maximum record number
!		CIF	- create if nonexistent file
!		RCK	- read check
!		TEF	- truncate files at EOF mark
!		SUP	- supersede
!		WCK	- write check
!
! Routine value
!
!	novalue
!
! Side effects
!
!	none
!
!--

    BEGIN

    MAP
        output_fab	: REF BLOCK [, BYTE];		! Output file FAB block

    BIND
        output_xabfhc	=				! output file XABFHC block
                .output_fab [fab$l_xab]		: BLOCK [, BYTE],
        output_xaball	=				! output file XABALL block
                .output_xabfhc [xab$l_nxt]	: BLOCK [, BYTE];

!
! Apply the effects of the output file qualifiers to the appropriate XAB blocks.
!

    IF .copy$cli_status [alignment_bit]			! If file alignment specified,
    THEN
        BEGIN
        output_xaball [xab$b_aln] = .align_type;	!    write in the alignment type,
        output_xaball [xab$b_aop] = .align_option;	!    the alignment option,
        IF .copy$cli_status [align_val_bit]		! If a location was specified,
        THEN
            output_xaball [xab$l_loc] = .align_location;!    write in the location too.
        END;

    IF .copy$cli_status [allocation_bit]		! If file allocation quantity specified,
    THEN
        output_xaball [xab$l_alq] = .alloc_value;	!    write in the value.

    IF .copy$cli_status [contiguous_bit]		! If contiguous allocation required,
    THEN
        BEGIN
        output_xaball [xab$v_ctg] = TRUE;		!    set the contiguous bit in the XAB,
        output_xaball [xab$v_cbt] = FALSE;		!    and the contiguous-best-try bit to false.
        END
    ELSE						! Otherwise, if the qualifier was given explicitly,
        BEGIN
        IF explicit_qual [cont]				!    then it was in the negative form -- /NOCONTIGUOUS,
        THEN						!    so turn off all contiguous indicators.
            BEGIN
            output_xaball [xab$v_ctg] = FALSE;		!    Contiguous bit set to FALSE.
            output_xaball [xab$v_cbt] = FALSE;		!    Contiguous-best-try bit set to FALSE.
            END;
        END;

    IF .copy$cli_status [extension_bit]			! If a file extension quantity was given,
    THEN
        output_xaball [xab$w_deq] = .extension_value;	!    then write in the value.

    IF .copy$cli_status [file_max_bit]			! If a maximum record number was specified,
    THEN
        output_fab [fab$l_mrn] = .file_max_value;	!    then write it into the output FAB block.

    IF .copy$cli_status  [overlay_bit] OR		! If COPY is to overlay the existing file, or
        .copy$cli_status [new_bit]			!    APPEND is to create a new file if one does not exist,
    THEN
        output_fab [fab$v_cif] = TRUE;			!    then turn on the create-if-nonexistent bit.

    IF .copy$cli_status [oread_check_bit]		! For read checking on output file,
    THEN
        output_fab [fab$v_rck] = TRUE			!    turn on the read check bit in the output FAB.
    ELSE						! Otherwise, if the qualifier was given explicitly,
        BEGIN						!    then it was given in the negative form --
        IF explicit_qual [oread]			!    /NOREAD_CHECK,
        THEN
            output_fab [fab$v_rck] = FALSE;		!    so set the bit in the FAB to FALSE.
        END;

    IF .copy$cli_status [replace_bit]			! If an existing file is to be replaced,
    THEN
        output_fab [fab$v_sup] = TRUE;			!    set the supersede bit in the output FAB.

    IF .copy$cli_status [truncate_bit]			! If a contiguous file is to be truncated at EOF,
    THEN
        output_fab [fab$v_tef] = TRUE;			!    then set the truncate bit in the FOP of the FAB.

    IF .copy$cli_status [volume_bit]			! If relative volume specified,
    THEN
	BEGIN
	output_xaball [xab$w_vol] = .volume_value;	! then set it
	output_xaball [xab$b_aln] = xab$c_lbn;		! start of disk is special cased
	output_xaball [xab$v_hrd] = 1;			! Set hard bit
	END;

    IF .copy$cli_status [write_check_bit]		! For write checking on the output file,
    THEN
        output_fab [fab$v_wck] = TRUE			!    set the write check bit in the output FAB.
    ELSE						! Otherwise, if the qualifier was explicitly given,
        BEGIN						!    then it was in the negative form --
        IF explicit_qual [writ]				!    /NOWRITE_CHECK,
        THEN
            output_fab [fab$v_wck] = FALSE;		!    so set bit to FALSE in the output FAB.
        END;

!
! Return to caller.
!

    END;						! Return without a value.

ROUTINE setup_conc_xab (output_fab, input_fab, output_xabptr) : NOVALUE =
							! Sets XAB fields for concatenated file

!++
! Functional description
!
!	This routine writes certain XAB fields for concatenated output files.
!
! Calling sequence
!
!	set_conc_xab (output_fab.ra.v, input_fab.ra.v, output_xabptr.wa.r)
!
! Input parameters
!
!	output_fab	- The FAB block for the output file
!	input_fab	- The FAB block for the input file
!
! Implicit inputs
!
!	output_xaball	- The XABALL block for the output file
!	output_xabpro	- The XABPRO block for the output file
!	output_xabdat	- The XABDAT block for the output file
!	output_xabrdt	- The XABRDT block for the output file
!	input_xabpro	- The XABPRO block for the input file
!
!	Bit in COPY$SEM_STATUS:
!
!		APPEND_COMMAND	- this is an APPEND command
!
!	FAB records whether this input device is file structured or not.
!
! Output parameters
!
!	output_xabptr	- The address of the output file XABPRO block.
!
! Implicit outputs
!
!	Fields are written in the output XABALL and XABPRO blocks:
!
!		NXT	- pointer to next XAB block
!		PRO	- default protection of the output file
!
! Routine value
!
!	novalue
!
! Side effects
!
!	none
!
!--

    BEGIN

    MAP
        output_fab	: REF BLOCK [, BYTE],		! Output file FAB block
        input_fab	: REF BLOCK [, BYTE],		! Input file FAB block
        output_xabptr	: REF VECTOR;			! Output file XABPRO block

    BIND
        output_xabfhc	=				! Output file XABFHC block
                .output_fab [fab$l_xab]		: BLOCK [, BYTE],
        output_xaball	=				! Output file XABALL block
                .output_xabfhc [xab$l_nxt]	: BLOCK [, BYTE],
        output_xabdat	=				! Output file XABDAT block
                .output_xaball [xab$l_nxt]	: BLOCK [, BYTE],
        output_xabpro	=				! Output file XABPRO block
                .output_xabdat [xab$l_nxt]	: BLOCK [, BYTE],
        output_xabrdt	=				! Output file XABRDT block
                .output_xabpro [xab$l_nxt]	: BLOCK [, BYTE],
        input_xaball	=				! Input file XABALL block
                .input_fab [fab$l_xab]		: BLOCK [, BYTE],
        input_xabdat	=				! Input file XABDAT block
                .input_xaball [xab$l_nxt]	: BLOCK [, BYTE],
        input_xabfhc	=				! Input file XABFHC block
                .input_xabdat [xab$l_nxt]	: BLOCK [, BYTE],
        input_xabpro	=				! Input file XABPRO block
                .input_xabfhc [xab$l_nxt]	: BLOCK [, BYTE];

    IF (.append_command	 				! If appending to existing file,
	OR .concat_follows				!    or if explicit output spec or concatenating
        OR NOT .input_fab [$fab_dev (fod)])		!    or the input device is not file structured,
    THEN
	BEGIN
        output_xaball [xab$l_nxt] = 0;			! then remove XABDAT,XABPRO and XABRDT blocks
	IF .copy$cli_status [protection_bit]		!  If user did explicitly specify /PROT
	THEN
	    BEGIN
            output_xaball [xab$l_nxt] = output_xabpro;	! include the protection XAB block;
            output_xabpro [xab$l_nxt] = 0;
	    END;
	END

    ELSE
        BEGIN
        output_xaball [xab$l_nxt] = output_xabdat;	! Otherwise, include the output date/time XAB block;
        output_xabpro [xab$w_pro] =			! assume that output protection is identical
            .input_xabpro [xab$w_pro];			!    to input protection;
        output_xabpro [xab$l_nxt] = output_xabrdt;	! and retain input revision XAB data.
        END;

!
! Return the address of the XAB protection block.
!

    output_xabptr [0] = output_xabpro;			! This is needed later to set more protection fields.

    END;

ROUTINE setup_prot_xab (output_xabpro) : NOVALUE =	! Sets up protection XAB fields

!++
! Functional description
!
!	This routine is called for files for whom the /PROTECTION qualifier was specified.
!	Output protection is set according to the protection value given. If no value
!	was given, the default protection is applied.
!
! Calling sequence
!
!	setup_prot_xab (output_xabpro.ra.v)
!
! Input parameters
!
!	output_xabpro	- the XABPRO block associated with the output file
!
! Implicit inputs
!
!	protect_and	- a mask of protection bits
!	protect_or	- a mask of protection bits
!
!	Bits in COPY$CLI_STATUS:
!
!		protection_bit	- the /PROTECTION qualifier was given
!		protect_val_bit	- a protection value was specified
!
!	default_protect	- the default protection for output files
!
! Output parameters
!
!	none
!
! Implicit outputs
!
!	The XAB$W_PRO field in the output XABPRO block is written.
!
! Routine value
!
!	novalue
!
! Side effects
!
!	none
!
!--

    BEGIN

    MAP
        output_xabpro	: REF BLOCK [, BYTE];		! Output XABPRO block

!
! If the /PROTECTION qualifier was specified, set up the special protection.
!

    IF .copy$cli_status [protection_bit]		! If output file protection is requested,
    THEN
        BEGIN						!    set up this protection now.
        IF .copy$cli_status [protect_val_bit]		! If protection information was given,
        THEN
            BEGIN
            output_xabpro [xab$w_pro] =			!    turn off some protection attribute bits,
                .output_xabpro [xab$w_pro] AND .protect_and;

            output_xabpro [xab$w_pro] =			!    and turn on others.
                .output_xabpro [xab$w_pro] OR .protect_or;
            END
        ELSE						! If no protection information was given,
            output_xabpro [xab$w_pro] = default_protect;!    request default output protection.
        END;

    END;

END
ELUDOM
