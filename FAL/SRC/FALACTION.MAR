	.TITLE	FALACTION - STATE TABLE ACTION ROUTINES
	.IDENT	'V03-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; Facility: FAL (DECnet File Access Listener)
;
; Abstract:
;
;	This module contains action routines called by the state table manager.
;
; Environment: VAX/VMS, user mode
;
; Author: James A. Krycka,	Creation Date:	16-JUN-1977
;
; Modified By:
;
;	V03-001	JAK0028		J A Krycka	16-APR-1982
;		Return an RMS$_RFM error if the file opened has STMLF or STMCR
;		format.
;
;	V02-073	KRM0040		K R Malik	26-JAN-1982
;		Removed outdated reference to NAM$L_QUOTED.
;
;	V02-072	JAK0026		J A Krycka	04-JAN-1982
;		Initialize XAB chain for $DISPLAY and $EXTEND.
;
;	V02-071	KRM0034		K R Malik	29-Dec-1981
;		Modified FAL$OPEN and FAL$DIR_SEARCH to init the
;		FAB$W_DEQ value before the $OPEN (so as to avoid
;		reusing the DEQ value as input).
;
;	V02-070	JAK0025		J A Krycka	11-NOV-1981
;		Fix bug in wildcard file retrieval.
;
;	V02-069	JAK0024		J A Krycka	08-OCT-1981
;		Fix bug in reporting file attributes.
;
;	V02-068	JAK0023		J A Krycka	20-SEP-1981
;		Add support for stream format files.
;
;	V02-067	JAK0023		J A Krycka	05-SEP-1981
;		Add FAL$CHANGE and revise FAL$CLOSE routine to properly handle
;		XAB input on close.
;
;	V02-066	JAK0022		J A Krycka	24-AUG-1981
;		Update symbols to correspond to revised DAPDEF.MDL file.
;
;	V02-065	SPR39206	J A Krycka	11-AUG-1981
;		On a DAP DIRECTORY list function, return RMS$_ATR instead of
;		RMS$_FNF if the $SEARCH succeeds but the subsequent $OPEN fails
;		because the file does not exist. This will prevent early
;		termination of a DCL DIRECTORY command for a remote directory.
;
;	V02-064	SPR39662	J A Krycka	06-AUG-1981
;		In performing the DIRECTORY list function, set the file sharing
;		option bits appropriately to avoid file locked errors when
;		opening files to obtain their file attributes. This will prevent
;		most 'file access conflict' errors from the DIRECTORY utility.
;
;	V02-063	JAK0021		J A Krycka	04-AUG-1981
;		Support the RMS $DISPLAY function.
;		Support the RMS $EXTEND function.
;
;	V02-062	JAK0020		J A Krycka	21-JUL-1981
;		Support the Revision Date and Time XAB on close.
;		Support the Protection XAB on close.
;
;	V02-061	JAK0019		J A Krycka	25-JUN-1981
;		Support the RMS $RELEASE function.
;		Support random access by record file address (RFA).
;
;	V02-060	JAK0018		J A Krycka	18-JUN-1981
;		Move initialization related routines to a new module named
;		FALACTINI, move message processing routines to a new module
;		named FALACTMSG, and move the DAP CRC table to a new module
;		named FALDAPCRC.
;
;	V02-059	JAK0018		J A Krycka	10-JUN-1981
;		Revise SEND_3PART_NAM to make use of the extended NAM block
;		fields that return filespec element descriptors.
;
;	V02-058	JAK0017		J A Krycka	01-MAY-1981
;		If all four protection fields are omitted from the DAP
;		Protection message, put 0FFFF instead of 0 in the XAB$W_PRO
;		field of the Protection XAB. An input value of -1 is treated
;		specially by RMS to mean use the default protection in effect
;		for the process. Also, change several assume MACRO calls to use
;		'GE' in place of 'EQ'.
;
;--

	.SBTTL	DECLARATIONS
	.PSECT	FAL$DATA	SHR,NOEXE,RD,WRT,LONG

;
; Include Files:
;

	$DAPPLGDEF			; Define DAP prologue symbols
	$DAPHDRDEF			; Define DAP message header
	$DAPCNFDEF			; Define DAP Configuration message
	$DAPATTDEF			; Define DAP Attributes message
	$DAPACCDEF			; Define DAP Access message
	$DAPCTLDEF			; Define DAP Control message
	$DAPCONDEF			; Define DAP Continue Transfer message
	$DAPACKDEF			; Define DAP Acknowledge message
	$DAPCMPDEF			; Define DAP Access Complete message
	$DAPDATDEF			; Define DAP Data message
	$DAPSTSDEF			; Define DAP Status message
	$DAPKEYDEF			; Define DAP Key Definition message
	$DAPALLDEF			; Define DAP Allocation message
	$DAPSUMDEF			; Define DAP Summary message
	$DAPTIMDEF			; Define DAP Date and Time message
	$DAPPRODEF			; Define DAP Protection message
	$DAPNAMDEF			; Define DAP Name message
	$DAPCRCDEF			; Define DAP CRC checksum symbols
	$DAPFIDDEF			; Define DAP field ID symbols
	$FABDEF				; Define File Access Block symbols
	$FALWRKDEF			; Define FAL Work Area symbols
	$FALSTBDEF			; Define Statistics Block symbols
	$NAMDEF				; Define Name Block symbols
	$RABDEF				; Define Record Access Block symbols
	$XABDEF				; Define symbols common to all XABs
	$XABALLDEF			; Define Allocation XAB symbols
	$XABDATDEF			; Define Date and Time XAB symbols
	$XABFHCDEF			; Define File Header Char XAB symbols
	$XABKEYDEF			; Define Key Definition XAB symbols
	$XABPRODEF			; Define Protection XAB symbols
	$XABRDTDEF			; Define Revision Date and Time symbols
	$XABSUMDEF			; Define Summary XAB symbols

;
; Macros:
;
;	None
;
; Equated Symbols:
;

LF=10					; Line feed
VT=11					; Vertical tab
FF=12					; Form feed
DLE=16					; Data link error  (Control-P)
DC1=17					; Device control 1 (Control-Q)
DC2=18					; Device control 2 (Control-R)
DC3=19					; Device control 3 (Control-S)
DC4=20					; Device control 4 (Control-T)
CTRLZ=26				; Control-Z
ESC=27					; Escape

CRLF=^X0A0D				; ASCII codes for CR and LF

	ASSUME	DAP$Q_DCODE_FLG EQ 0
	ASSUME	FAL$Q_FLG EQ 0

;
; Own Storage:
;
; The following bitmask represents the DAP terminator set for stream (STM)
; format files where each bit position corresponds to an ASCII character code
; for a single-character terminator. Note that the default terminator, CRLF,
; is not expressed in this mask.
;

FAL$STM_MASK::				; DAP stream terminator bitmask
	.LONG	<<1@LF> + <1@FF> + <1@VT> + <1@CTRLZ> + <1@ESC> + -
		<1@DLE> + <1@DC1> + <1@DC2> + <1@DC3> + <1@DC4>>

	.SBTTL	ACTION ROUTINES
	.PSECT	FAL$CODE	NOSHR,EXE,RD,NOWRT,BYTE

;++
; Functional Description:
;
;	This module contains action routines invoked by the state table
;	manager (FAL$STATE).
;
;	The input parameters and completion codes listed below are applicable
;	for all of these action routines. Note that an action routine may use
;	R0-R7 and AP without restoring them on exit. R0 on exit, however, must
;	represent a status code to indicate success/failure of the routine or
;	a true/false condition, as appropriate. This status code is used by
;	the state table manager to advance to the next state.
;
; Calling Sequence:
;
;	BSBW	FAL$name
;
; Input Parameters:
;
;	R8	Address of FAL work area
;	R9	Address of DAP control block
;	R10	Address of FAB
;	R11	Address of RAB
;
; Implicit Inputs:
;
;	None
;
; Output Parameters:
;
;	R0	Completion Code
;	R1-R7	Destroyed
;	AP	Destroyed
;
; Implicit Outputs:
;
;	None
;
; Completion Codes:
;
;	R0	1 = success; 0 = failure
;
; Side Effects:
;
;	None
;
;--

	.SBTTL	FAL$NEXT_MSG, FAL$INTE_MSG

;++
; The following routines have separate entry points but share common code ...
;
; This routine obtains the next DAP message from partner (excluding interrupt
; messages). Then it syntax checks this message and stores the results in the
; DAP control block.
;--

FAL$NEXT_MSG::				; Entry point
	BBCC	#FAL$V_MBXAST,(R8),10$	; Branch if no mailbox message has
					;  been received
	BSBW	FAL$MBX_RCV_QIO		; Ignore any interrupt message and
					;  re-issue mailbox read with AST
10$:	BSBW	FAL$RECEIVE		; Get next DAP message and parse it
CHECK_PARSE:				; FAL$INTE_MSG branches here
	BLBC	DAP$L_DCODE_STS(R9),10$	; Branch on message parse failure

;
; The DAP message parse was successful; use message type as the next state
; table value.
;

	MOVB	DAP$B_DCODE_MSG(R9),-	; Store new state transition value
		FAL$B_VALUE(R8)		;
	BRW	EXIT_SUCCESS		; Exit state with success

;
; Parse of DAP message failed; send Status message to partner.
;

10$:	MOVZBL	DAP$B_DCODE_FID(R9),R0	; Get ID of field in error
	MOVZBL	DAP$B_DCODE_MSG(R9),R1	; Get message type number
	MOVZBL	DAP$B_DCODE_MAC(R9),R2	; Get maccode error value
	BRW	SEND_STS_FAIL		; Send Status message

;++
; This routine obtains the next DAP message from partner sent as an interrupt
; message. Then it syntax checks this message and stores the results in the
; DAP control block.
;--

FAL$INTE_MSG::				; Entry point
	MOVQ	DAP$Q_MSG_BUF1(R9),-(SP); Save decode context
	MOVQ	DAP$Q_MSG_BUF2(R9),-(SP); "
	BSBW	FAL$RECEIVE_MBX		; Get next DAP message delivered as
					;  an interrupt message and parse it
	MOVQ	(SP)+,DAP$Q_MSG_BUF2(R9); Restore decode context
	MOVQ	(SP)+,DAP$Q_MSG_BUF1(R9); "
	BRB	CHECK_PARSE		; Join common code


	.SBTTL	FAL$TEST_MSG

;++
; This routine determines whether or not a DAP message has been received from
; partner. The receive AST flag stored in the FAL work area is used to form
; the state transition status code.
;--

FAL$TEST_MSG::				; Entry point
	EXTZV	#FAL$V_RCVAST,#1,(R8),R0; Form yes/no reply
	RSB				; Exit state with status code in R0

	.SBTTL	FAL$FIL_PARSE

;++
; This routine parses the file specification received from partner for file
; access functions other than the DAP DIRECTORY list function.
;
; Note:	If the $PARSE operation finds a wildcard character, but the partner
;	process declares that it does not support wildcard operations, then
;	an RMS$_WLD error will be returned. This is done to assist systems
;	(such as DECnet-IAS) that do not understand VAX/VMS wildcard file
;	specifications, and therefore cannot determine that one has been
;	specified.
;--

FAL$FIL_PARSE::				; Entry point
	$PARSE	FAB=R10			; Parse the file specification
	BLBC	R0,20$			; Branch on failure
	BBC	#NAM$V_WILDCARD,-	; Branch if non-wild expanded string
		FAL$L_NAM+NAM$L_FNB(R8),10$
	$SETBIT	#FAL$V_WILD,(R8)	; Denote wildcard operation
	BBS	#DAP$V_WILDCARD,-	; Branch if partner supports wildcard
		DAP$Q_SYSCAP(R9),10$	;  operations
	MOVZWL	#<RMS$_WLD&^XFFFF>,R0	; If not, return an error code for
	BRB	20$			;  'invalid wildcard operation'
10$:	BRW	EXIT_SUCCESS		; Exit state with success
20$:	BRW	ERR_FILE_OPEN		; Return error in Status message


	.SBTTL	FAL$CHECK_WILD

;++
; This routine determines whether or not the parsed file specification contains
; any wildcard characters. The wildcard status bit stored in the FAL work area
; is used to form the state transition status code.
;--

FAL$CHECK_WILD::			; Entry point
	EXTZV	#FAL$V_WILD,#1,(R8),R0	; Form yes/no reply
	RSB				; Exit state with status code in R0

	.SBTTL	FAL$FIL_SEARCH

;++
; This routine performs the search operation on a wildcard file specification
; for file access functions other than the DAP DIRECTORY list function.
;--

FAL$FIL_SEARCH::			; Entry point
	$SEARCH	FAB=R10			; Search for next file name match
	BLBC	R0,10$			; Branch on failure

;
; Re-establish the FHCXAB at the head of the XAB chain.
;

	MOVAL	FAL$L_FHCXAB(R8),-	; Store FHCXAB pointer in XAB chain
		FAB$L_XAB(R10)		;
	MOVAL	FAL$L_FHCXAB+XAB$L_NXT(R8),-
		FAL$L_CHAIN_NXT(R8)	; Save address of next chain pointer
	CLRL	@FAL$L_CHAIN_NXT(R8)	; Terminate XAB chain at FHCXAB
	BRW	EXIT_SUCCESS		; Exit state with success

;
; Note that RMS$_NMF converts to an Access Complete message.
;

10$:	CMPW	R0,#<RMS$_NMF&^XFFFF>	; Check for normal termination
	BEQL	20$			;  of wildcard operation
	BRW	ERR_FILE_OPEN		; Return error in Status message
20$:	BRW	SEND_CMP		; Send Access Complete message


	.SBTTL	FAL$CHECK_NMF

;++
; This routine determine whether or not an RMS$_NMF (no more files found)
; completion code was returned on the last $SEARCH call.
;--

FAL$CHECK_NMF::				; Entry point
	CMPW	FAB$L_STS(R10),-	; Branch if last error code was
		#<RMS$_NMF&^XFFFF>	;  RMS$_NMF
	BEQL	10$			;
	BRW	EXIT_FAILURE		; Exit state with failure
10$:	BRW	EXIT_SUCCESS		; Exit state with success

	.SBTTL	FAL$OPEN

;++
; This routine performs the DAP OPEN file function for both single file and
; wildcard requests.
;--

FAL$OPEN::				; Entry point

;
; An Attributes message must precede the Access message. Check for it.
;

	BBS	#FAL$V_ATT_MSG,(R8),10$	; Branch if ok
	BRW	ERR_SYNCHRONIZE		; Return error in Status message

;
; On a wildcard operation return Name messages derived from the resultant name
; string obtained on the $SEARCH call.
;

10$:	BBC	#FAL$V_WILD,(R8),20$	; Branch if not wildcard operation
	BSBW	SEND_3PART_NAM		; Send resultant name in three Name
					;  message format

;
; Open the specified file.
;
; Return an error if the record format of the file is STMLF or STMCR, as these
; formats are not currently supported by DAP.
;

20$:	BSBW	CHAIN_RQST_XABS		; Add required XABs to XAB chain
	CLRW	FAB$W_DEQ(R10)		; Clear the old DEQ value
	$OPEN	FAB=R10			; Open file
	BLBC	R0,40$			; Branch on failure
	BSBW	FAL$LOG_RESNAM		; Log resultant name in print file
	CMPB	FAB$B_RFM(R10),-	; Return error if file has a record
		#FAB$C_STM		;  format that cannot be mapped into
	BGTRU	35$			;  DAP RFM field (not supported by DAP)

;
; Set-up to compute file level CRC checksum if requested.
;

	BBC	#DAP$V_RET_CRC,-	; Branch if checksum option not
		FAL$B_ACCOPT(R8),30$	;  requested by accessing node
	MOVL	#DAP$K_CRC_INIT,-	; Use initial CRC value as first
		DAP$L_CRC_RSLT(R9)	;  CRC resultant value

;
; Return (main) Attributes, Extended Attributes, and (resultant) Name messages
; to partner as directed by request mask, terminated by an Acknowledge message.
;

30$:	BSBW	CHAIN_RQST_PRT2		; Fill in alterate ALLXABs and KEYXABs
					;  as directed by NOA and NOK values
	BLBC	R0,40$			; Branch on failure
	BSBW	SEND_OPTNL_MSGS		; Build and send optional DAP messages
	BRW	SEND_ACK		; Send Acknowledge message
35$:	MOVZWL	#<RMS$_RFM&^XFFFF>,R0	; Generate invalid record format error
	CLRL	FAB$L_STV(R10)		; Zero secondary status value
40$:	BRW	ERR_FILE_OPEN		; Return error in Status message

	.SBTTL	FAL$SUBMIT, FAL$CREATE

;++
; The following routines have separate entry points but share common code ...
;
; This routine performs the DAP SUBMIT file function which consists of creating
; the command file, submitting it to the symbiont manager for execution, and
; finally deleting the command file when the job is finished.
;--

FAL$SUBMIT::				; Entry point
	BISL2	#<<FAB$M_SCF>!-		; Set submit-on-close and
		  <FAB$M_DLT>!-		;  delete-after-execution bits
		0>,FAB$L_FOP(R10)	; Fall thru to FAL$CREATE ...

;++
; This routine performs the DAP CREATE file function.
;--

FAL$CREATE::				; Entry point

;
; An Attributes message must precede the Access message. Check for it.
;

	BBS	#FAL$V_ATT_MSG,(R8),10$	; Branch if ok
	BRW	ERR_SYNCHRONIZE		; Return error in Status message
10$:	BICB2	#FAB$M_SHRGET,-		; ***** This is necessary because RT11
		FAB$B_SHR(R10)		; ***** sets this bit on create
					; ***** which is rejected by RMS32

;
; Create the specified file.
;

	BSBW	CHAIN_RECV_XABS		; Add received XABs to XAB chain
	$CREATE	FAB=R10			; Create file
	BLBC	R0,30$			; Branch on failure
	BSBW	FAL$LOG_RESNAM		; Log resultant name in print file

;
; Set-up to compute file level CRC checksum if requested.
;

	BBC	#DAP$V_RET_CRC,-	; Branch if checksum option not
		FAL$B_ACCOPT(R8),20$	;  requested by accessing node
	MOVL	#DAP$K_CRC_INIT,-	; Use initial CRC value as first
		DAP$L_CRC_RSLT(R9)	;  CRC resultant value

;
; Return (main) Attributes, Extended Attributes, and (resultant) Name messages
; to partner as directed by request mask, followed by an Acknowledge message.
;

20$:	BSBW	SEND_OPTNL_MSGS		; Build and send them
	BRW	SEND_ACK		; Send Acknowledge message
30$:	BRW	ERR_FILE_OPEN		; Return error in Status message

	.SBTTL	FAL$ERASE

;++
; This routine performs the DAP ERASE file function.
;
; Note:	RMS does not return XAB information on $ERASE. The DAP specification,
;	however, allows partner to request that DAP Extended Attributes messages
;	be returned, but it is unlikely that anyone will make a request for
;	anything but a Name message.
;--

FAL$ERASE::				; Entry point
	BSBW	CHAIN_RQST_XABS		; Add required XABs to XAB chain
	$ERASE	FAB=R10			; Erase (delete) file
	BLBC	R0,20$			; Branch on failure
	BSBW	FAL$LOG_RESNAM		; Log resultant name in print file
	BSBW	SEND_OPTNL_MSGS		; Build and send optional DAP messages
	BBS	#FAL$V_WILD,(R8),10$	; Branch if wildcard operation
	BRW	SEND_CMP		; Send Access Complete message
10$:	BRW	EXIT_SUCCESS		; Exit state with success
20$:	BBC	#FAL$V_WILD,(R8),30$	; Branch if not wildcard operation
	BSBW	SEND_3PART_NAM		; Send resultant name in three Name
					;  message format
30$:	BRW	ERR_FILE_OPEN		; Return error in Status message

	.SBTTL	FAL$EXECUTE

;++
; This routine performs the DAP EXECUTE file function which consists of
; submitting a command file to the symbiont manager for execution. The command
; file must exist on the destination node and it is not deleted after execution.
;
; Note:	The DAP specification allows partner to request that DAP Extended
;	Attributes messages be returned, but it is unlikely that anyone will
;	make a request for anything but a Name message.
;--

FAL$EXECUTE::				; Entry point
	$SETBIT	#FAB$V_SCF,FAB$L_FOP(R10);Set submit-on-close bit
	BSBW	CHAIN_RQST_XABS		; Add required XABs to XAB chain
	$OPEN	FAB=R10			; Open file
	BLBC	R0,20$			; Branch on failure
	BSBW	FAL$LOG_RESNAM		; Log resultant name in print file
	CLRL	FAB$L_XAB(R10)		; Remove any XABs from chain
	$CLOSE	FAB=R10			; Close file and submit it
	BLBC	R0,40$			; Branch on failure
	BSBW	SEND_OPTNL_MSGS		; Build and send optional DAP messages
	BBS	#FAL$V_WILD,(R8),10$	; Branch if wildcard operation
	BRW	SEND_CMP		; Send Access Complete message
10$:	BRW	EXIT_SUCCESS		; Exit state with success
20$:	BBC	#FAL$V_WILD,(R8),30$	; Branch if not wildcard operation
	BSBW	SEND_3PART_NAM		; Send resultant name in three Name
					;  message format
30$:	BRW	ERR_FILE_OPEN		; Return error in Status message
40$:	BBC	#FAL$V_WILD,(R8),50$	; Branch if not wildcard operation
	BSBW	SEND_3PART_NAM		; Send resultant name in three Name
					;  message format
50$:	BRW	ERR_FILE_CLOS		; Return error in Status message

	.SBTTL	FAL$DIR_PARSE

;++
; This routine performs the parse phase of the DAP DIRECTORY list function.
;--

FAL$DIR_PARSE::				; Entry point
	MOVB	#5,FAB$B_DNS(R10)	; Store size of wildcard string
	MOVAL	FAL$T_DFILESPEC(R9),-	; Store address of default file
		FAB$L_DNA(R10)		;  specification string buffer
	MOVQ	#^A\*.*;*   \,-		; Copy wildcard string to buffer
		@FAB$L_DNA(R10)		;
	$PARSE	FAB=R10			; Parse the directory file specification
	BLBC	R0,20$			; Branch on failure
	CLRB	FAB$B_DNS(R10)		; Discard default file name string
					;  in case an $OPEN is performed
	BSBW	CHAIN_RQST_XABS		; Add required XABs to XAB chain for
					;  use on subsequent $SEARCH or $OPEN
	MOVB	#<<FAB$M_SHRGET>!-	; Specify shared access to files
		  <FAB$M_SHRPUT>!-	;  so that subsequent $OPEN to obtain
		  <FAB$M_UPI>!-		;  file attributes will be less likely
		0>,FAB$B_SHR(R10)	;  to fail with RMS$_FLK error
	BBC	#NAM$V_WILDCARD,-	; Branch if non-wild expanded string
		FAL$L_NAM+NAM$L_FNB(R8),10$
	$SETBIT	#FAL$V_WILD,(R8)	; Denote wildcard operation
10$:	BRW	EXIT_SUCCESS		; Exit state with success
20$:	BRW	ERR_FILE_OPEN		; Return error in Status message


	.SBTTL	FAL$DIR_END

;++
; This routine performs the final phase of the DAP DIRECTORY list function.
;--

FAL$DIR_END::				; Entry point
	BRW	SEND_CMP		; Send Access Complete message

	.SBTTL	FAL$DIR_SEARCH

;++
; This routine performs the search phase of the DAP DIRECTORY list function.
;
; Note:	This routine performs only one search operation and therefore it
;	must be called repeatedly to find all requested files.
;--

FAL$DIR_SEARCH::			; Entry point
	MOVL	FAB$L_NAM(R10),R7	; Get address of NAM block
	BICW3	#DAP$M_DSP_NAM,-	; Are any attributes requested
		FAL$W_DISPLAY(R8),R0	;  (excluding resultant name)?
	BEQL	10$			; Branch if not
	BBC	#NAM$V_NODE,-		; Branch if this is the end node
		NAM$L_FNB(R7),10$	;  (i.e., not an intermediate node)
	MOVL	#^A\XABS\,FAB$L_CTX(R10); Request return of attributes to avoid
					;  opening file to get its attributes
10$:	$SEARCH	FAB=R10			; Search for next file specification
	BLBC	R0,20$			; Branch on failure
	BSBW	FAL$LOG_RESNAM		; Log resultant name in print file

;
; Return Name messages to partner.
;

	BSBW	SEND_3PART_NAM		; Send resultant name in three Name
					;  message format
	BRB	SEND_ATTRIBUTES		;

;
; Note that RMS$_NMF is converted to an Access Complete message.
;

20$:	CMPW	R0,#<RMS$_NMF&^XFFFF>	; Check for normal termination
	BEQL	30$			;  of directory search sequence
	BRW	ERR_FILE_OPEN		; Return error in Status message
30$:	BRW	SEND_CMP		; Send Access Complete message

;+
; Open and close the file specified in the resultant string to obtain its
; attributes, unless this is an intermediate node. (If the file name given to
; $SEARCH contained a node name, then attributes have already been returned.)
;-

SEND_ATTRIBUTES:			;
	MOVL	FAB$L_NAM(R10),R7	; Get address of NAM block
	BICW3	#DAP$M_DSP_NAM,-	; Are any attributes requested
		FAL$W_DISPLAY(R8),R0	;  (excluding resultant name)?
	BEQL	30$			; Branch if not
	BBC	#NAM$V_NODE,-		; Branch if this is the end node
		NAM$L_FNB(R7),10$	;  (i.e., not an intermediate node)
	MOVL	FAB$L_STV(R10),R1	; Branch if not partial success
	BEQL	20$			;  (i.e., file attributes were returned
					;  as requested on $SEARCH)
	BSBB	MAP_SS_TO_RMS		; Convert SS code to RMS code and
	BRB	40$			;  say error occurred on file open

;
; Now open and close the file to obtain file attributes. Note that the required
; XABs have already been chained into the XAB chain by FAL$DIR_PARSE.
;

10$:	CLRW	FAB$W_DEQ(R10)		; Clear the old DEQ value
	$OPEN	FAB=R10			; Open the file
	BLBC	R0,35$			; Branch on failure
	PUSHL	FAB$L_XAB(R10)		; Save XAB chain pointer
	CLRL	FAB$L_XAB(R10)		; Remove any XABs from chain
	$CLOSE	FAB=R10			; Close the file
	POPL	FAB$L_XAB(R10)		; Restore XAB chain pointer
	BLBC	R0,50$			; Branch on failure

;
; Return (main) Attributes, Extended Attributes, and (resultant) Name messages
; to partner as directed by request mask.
;

20$:	BSBW	SEND_OPTNL_MSGS		; Build and send them

;
; Exit paths
;

30$:	BRW	EXIT_SUCCESS		; Exit state with success
35$:	CMPW	R0,#<RMS$_FNF&^XFFFF>	; Convert RMS$_FNF to RMS$_ATR if
	BNEQ	40$			;  $SEARCH succeeds but subsequent
	MOVZWL	#<RMS$_ATR&^XFFFF>,R0	;  $OPEN fails because file does not
					;  exist although directory entry does
40$:	BRW	ERR_FILE_OPEN		; Return error in Status message
50$:	BRW	ERR_FILE_CLOS		; Return error in Status message

;+
; This routine maps a System Service code to an RMS completion code.
;-

MAP_SS_TO_RMS:				; Entry point
	CMPW	R1,#SS$_ACCONFLICT	; Check for file access locked error
	BNEQ	10$			; Branch if no match
	MOVZWL	#<RMS$_FLK&^XFFFF>,R0	; Convert to FLK (lower 16 bits)
	RSB				; Exit
10$:	CMPW	R1,#SS$_NOPRIV		; Check for privilege violation
	BNEQ	20$			; Branch if no match
	MOVZWL	#<RMS$_PRV&^XFFFF>,R0	; Convert to PRV (lower 16 bits)
	RSB				; Exit
20$:	CMPW	R1,#SS$_FILELOCKED	; Check for file deaccess locked error
	BNEQ	30$			; Branch if no match
	MOVZWL	#<RMS$_ACC&^XFFFF>,R0	; Convert to ACC (lower 16 bits)
	RSB				; Exit
30$:	CMPW	R1,#SS$_FCPREADERR	; Check for read attributes error
	BNEQ	40$			; Branch if no match; map to ATR
40$:	MOVZWL	#<RMS$_ATR&^XFFFF>,R0	; Convert to ATR (lower 16 bits)
	RSB				; Exit

	.SBTTL	FAL$LOAD_IMAGE

;++
; This routine performs the VMS system specific load image function to support
; the DCL command '$RUN node::file.exe'. To accomplish this, FAL ceases to use
; DAP after the file is opened to send the image file to the VMS image activator
; at the requesting node. Instead, FAL sends the image file in 512 byte chunks
; via QIOs until end-of-file is reached, then waits for the requesting node to
; disconnect the logical link.
;--

FAL$LOAD_IMAGE::			; Entry point
	$CONNECT RAB=R11		; Establish record stream
	BLBC	R0,30$			; Branch on failure
	MOVL	FAL$Q_XMT+4(R8),-	; Put address of transmit buffer
		RAB$L_UBF(R11)		;  in RAB
	MOVW	FAL$W_DAPBUFSIZ(R8),-	; Put size of transmit buffer
		RAB$W_USZ(R11)		;  in RAB
	MOVAL	FAL$L_STB(R8),R7	; Get address of Statistics Block
10$:	$GET	RAB=R11			; Get next record
	BLBC	R0,20$			; Branch on error
	MOVZWL	RAB$W_RSZ(R11),R2	; Get record size
	MOVL	R2,FAL$Q_XMT(R8)	; Update XMT descriptor
	$SETBIT	#FAL$V_LAST_MSG,(R8)	; Declare this last message to block
	BSBW	FAL$TRANSMIT		; Send record to partner
	INCL	FAL$L_XMT_DAT(R7)	; Increment XMT record/block count
	ADDL2	R2,FAL$L_XMT_USR(R7)	; Update XMT user data byte count
	BRB	10$			; Loop until EOF or error
20$:	CMPW	R0,#<RMS$_EOF&^XFFFF>	; Is it an end-of-file?
	BNEQ	30$			; Branch if not
	BRW	EXIT_SUCCESS		; Exit state with success
30$:	BRW	EXIT_FAILURE		; Exit state with failure

	.SBTTL	FAL$CONNECT

;++
; This routine performs the DAP CONNECT record stream function.
;--

FAL$CONNECT::				; Entry point
	$CONNECT RAB=R11		; Establish record stream
	BLBC	R0,10$			; Branch on failure
	BRW	SEND_ACK		; Send Acknowledge message
10$:	BRW	ERR_FILE_XFER		; Return error in Status message


	.SBTTL	FAL$CHECK_FTM

;++
; This routine determines whether or not DAP file transfer mode has been
; specified. The file transfer mode flag stored in the FAL work area is used
; to form the state transition status code.
;--

FAL$CHECK_FTM::				; Entry point
	EXTZV	#FAL$V_FTM,#1,(R8),R0	; Form yes/no reply
	RSB				; Exit state with status code in R0

	.SBTTL	FAL$GET_READ

;++
; This routine performs the DAP GET/READ record/block function.
; (Also called the retrieve record/block function in the DAP specification.)
;--

FAL$GET_READ::				; Entry point

;
; Build the Data message.
;
; Note:	A Status message must be returned after the Data message if:
;	(1) record transfer mode is being used, and
;	(2) the accessing process has implemented to DAP since V5.6.
;	Otherwise, only a Data message is returned (or just a Status message
;	on an error condition).
;

	BBS	#FAL$V_FTM,(R8),10$	; Branch if in file transfer mode
	BBS	#DAP$V_GEQ_V56,(R9),10$	; Branch if partner used DAP since V5.6
	$SETBIT	#FAL$V_LAST_MSG,(R8)	; Declare this last message to block
10$:	MOVL	#DAP$K_DAT_MSG,R0	; Get message type value
	BSBW	FAL$BUILD_HEAD		; Construct message header
	CLRB	(R3)+			; Do not return record number
	MOVL	R3,R6			; Save current address (i.e., start of
					;  DAP FILEDATA field in message)
	BBS	#FAL$V_BLK_IO,(R8),20$	; Branch if block I/O access
	CMPB	FAB$B_RFM(R10),#FAB$C_VFC
	BNEQ	20$			; Branch if not VFC format
	MOVL	R3,RAB$L_RHB(R11)	; Store address of record header buffer
	MOVZBL	FAB$B_FSZ(R10),R0	; Get size of record header
	ADDL2	R0,R3			; Skip over RHB storage area in DAP msg
20$:	MOVL	R3,RAB$L_UBF(R11)	; Store buffer address
	SUBL3	FAL$Q_XMT+4(R8),R3,R7	; Compute # bytes preceding data record
	BBS	#FAL$V_BLK_IO,(R8),30$	; Branch if block I/O access
	SUBW3	R7,FAL$W_DAPBUFSIZ(R8),-; Compute max # bytes that can
		RAB$W_USZ(R11)		;  be read into rest of buffer
	CMPB	FAB$B_RFM(R10),#FAB$C_STM
	BNEQ	25$			; Branch if not STM format
	ADDW2	#2,RAB$W_USZ(R11)	; Reserve space for probable addition
					;  of CRLF to record
25$:	$GET	RAB=R11			; Get record
	BRB	40$			;
30$:	MOVW	FAB$W_BLS(R10),-	; Request exactly one block
		RAB$W_USZ(R11)		;
	$READ	RAB=R11			; Read block
	BBC	#FAL$V_FTM,(R8),40$	; Branch if not in file transfer mode
	TSTL	RAB$L_BKT(R11)		; Check VBN specified
	BEQL	40$			; Branch if zero as it implies NBP
	INCL	RAB$L_BKT(R11)		; Increment VBN for next time thru
40$:	BLBC	R0,70$			; Branch on failure
	MOVZWL	RAB$W_RSZ(R11),R0	; Get record size
	ADDL2	R0,R3			; Update next byte pointer
	BBS	#FAL$V_BLK_IO,(R8),45$	; Branch if block I/O access
	CMPB	FAB$B_RFM(R10),#FAB$C_STM
	BNEQ	45$			; Branch if not STM format
	TSTL	R0			; Branch if null record
	BEQL	43$			;
	MOVZBL	-1(R3),R0		; Get record terminator character
	CMPB	R0,#31			; Branch if out-of-range for a stream
	BGTRU	43$			;  terminator character
	BBS	R0,W^FAL$STM_MASK,45$	; Branch on stream terminator
43$:	MOVW	#CRLF,(R3)+		; Add CRLF to terminate record
45$:	BSBW	FAL$BUILD_TAIL		; Finish building message

;
; Compute file level CRC checksum if requested.
;

	BBC	#DAP$V_RET_CRC,-	; Branch if checksum option not
		FAL$B_ACCOPT(R8),50$	;  requested by accessing node
	SUBL2	R6,R3			; Compute length of DAP FILEDATA field
	CRC	W^FAL$CRC_TABLE,-	; Compute CRC (destroying R0-R3)
		DAP$L_CRC_RSLT(R9),-	;  using result of previous CRC
		R3,(R6)			;  calculation as initial CRC value
	MOVL	R0,DAP$L_CRC_RSLT(R9)	; Store CRC resultant value

;
; Send Data message containing record/block to partner.
;

50$:	BSBW	FAL$TRANSMIT		; Send Data message
	MOVAL	FAL$L_STB(R8),R7	; Get address of Statistics Block
	INCL	FAL$L_XMT_DAT(R7)	; Increment XMT record/block count
	MOVZWL	RAB$W_RSZ(R11),R2	; Update XMT user data byte count
	ADDL2	R2,FAL$L_XMT_USR(R7)	;

;
; Send Status message to partner if in record transfer mode with partner using
; DAP since V5.6.
;

	BBS	#FAL$V_FTM,(R8),60$	; Branch if in file transfer mode
	BBC	#DAP$V_GEQ_V56,(R9),60$	; Branch if partner used DAP before V5.6
	$SETBIT	#FAL$V_RET_RFA,(R8)	; Return RFA of record
	MOVZWL	#<RMS$_SUC&^XFFFF>,R0	; Signal success
	BRW	SEND_STS_SUC		; Branch aid
60$:	BRW	EXIT_SUCCESS		; Exit state with success
70$:	BRW	ERR_FILE_XFER		; Return error in Status message

	.SBTTL	FAL$PUT_WRITE

;++
; This routine performs the DAP PUT/WRITE record/block function.
; (Also called the store record/block function in the DAP specification.)
;--

FAL$PUT_WRITE::				; Entry point

;+
; Process the DAP record number field of the Data message.
; Its format and content are context dependent:
;   (1)	for random block I/O access, it contains the virtual block number.
;   (2)	for random access by key value for relative (or fixed length
;	sequential) files, it contains the relative record number.
;   (3) otherwise, it is not used.
;-

	BBS	#FAL$V_FTM,(R8),-	; Ignore record number field
		FILEDATA_FIELD		;  if in file transfer mode
	BBC	#DAP$V_X_RECNUM,(R9),-	; Branch if DAP record number field
		FILEDATA_FIELD		;  was null (as opposed to specified
					;  with a zero value)
	BBC	#FAL$V_BLK_IO,(R8),10$	; Branch if not block I/O access
	MOVL	DAP$L_RECNUM1(R9),-	; Store VBN # in BKT field of RAB
		RAB$L_BKT(R11)		;
	BRB	FILEDATA_FIELD		; Continue
10$:	CMPB	RAB$B_RAC(R11),#RAB$C_KEY ; Branch if not random access
	BNEQ	FILEDATA_FIELD		  ;  by key value
	CMPB	FAB$B_ORG(R10),#FAB$C_IDX ; Branch if index organization
	BEQL	FILEDATA_FIELD		; Fall thru if relative or sequential
	MOVL	DAP$L_RECNUM1(R9),-	; Update relative record number
		FAL$L_NUMBER(R8)	;  for next put operation

;+
; Process the DAP FILEDATA field.
; If VFC format, it contains the record header prefixed to the record.
;-

FILEDATA_FIELD:				; Store the record/block data
	MOVQ	DAP$Q_FILEDATA(R9),R4	; Store record descriptor in <R4,R5>

;
; Compute file level CRC checksum if requested.
;

	BBC	#DAP$V_RET_CRC,-	; Branch if checksum option not
		FAL$B_ACCOPT(R8),10$	;  requested by accessing node
	CRC	W^FAL$CRC_TABLE,-	; Compute CRC (destroying R0-R3)
		DAP$L_CRC_RSLT(R9),-	;  using result of previous CRC
		R4,(R5)			;  calculation as initial CRC value
	MOVL	R0,DAP$L_CRC_RSLT(R9)	; Store CRC resultant value
10$:	BBS	#FAL$V_BLK_IO,(R8),20$	; Branch if block I/O access
	CMPB	FAB$B_RFM(R10),#FAB$C_VFC
	BNEQ	20$			; Branch if not VFC format
	MOVL	R5,RAB$L_RHB(R11)	; Store address of record header buffer
	MOVZBL	FAB$B_FSZ(R10),R2	; Get size of record header
	SUBL2	R2,R4			; Compute size of record
	ADDL2	R2,R5			; Compute address of record
20$:	MOVW	R4,RAB$W_RSZ(R11)	; Store record size
	MOVL	R5,RAB$L_RBF(R11)	; Store record address
	MOVAL	FAL$L_STB(R8),R7	; Get address of Statistics Block
	INCL	FAL$L_RCV_DAT(R7)	; Increment RCV record/block count
	ADDL2	R4,FAL$L_RCV_USR(R7)	; Update RCV user data byte count
	BBS	#FAL$V_BLK_IO,(R8),30$	; Branch if block I/O access
	$PUT	RAB=R11			; Put record
	BRB	40$			;
30$:	$WRITE	RAB=R11			; Write block
	BBC	#FAL$V_FTM,(R8),40$	; Branch if not in file transfer mode
	TSTL	RAB$L_BKT(R11)		; Check VBN specified
	BEQL	40$			; Branch if zero as it implies NBP
	INCL	RAB$L_BKT(R11)		; Increment VBN for next time thru
40$:	BLBC	R0,60$			; Branch on failure

;
; Send Status message to partner if in record transfer mode with partner using
; DAP since V5.6.
;

	BBS	#FAL$V_FTM,(R8),50$	; Branch if in file transfer mode
	BBC	#DAP$V_GEQ_V56,(R9),50$	; Branch if partner used DAP before V5.6
	$SETBIT	#FAL$V_RET_RFA,(R8)	; Return RFA of record
	BRW	SEND_STS_SUC		; Branch aid
50$:	BRW	EXIT_SUCCESS		; Exit state with success
60$:	BRW	ERR_FILE_XFER		; Return error in Status message

	.SBTTL	FAL$FIND, FAL$UPDATE

;++
; The following routines have separate entry points but share common code ...
;
; This routine performs the DAP FIND record function.
;--

FAL$FIND::				; Entry point
	$FIND	RAB=R11			; Find record
	BRB	SEND_STS_RFA		; Join common code

;++
; This routine performs the DAP UPDATE record function.
;--

FAL$UPDATE::				; Entry point
	MOVQ	DAP$Q_FILEDATA(R9),R4	; Store record descriptor in <R4,R5>

;
; Compute file level CRC checksum if requested.
;

	BBC	#DAP$V_RET_CRC,-	; Branch if checksum option not
		FAL$B_ACCOPT(R8),10$	;  requested by accessing node
	CRC	W^FAL$CRC_TABLE,-	; Compute CRC (destroying R0-R3)
		DAP$L_CRC_RSLT(R9),-	;  using result of previous CRC
		R4,(R5)			;  calculation as initial CRC value
	MOVL	R0,DAP$L_CRC_RSLT(R9)	; Store CRC resultant value
10$:	CMPB	FAB$B_RFM(R10),#FAB$C_VFC
	BNEQ	20$			; Branch if not VFC format
	MOVL	R5,RAB$L_RHB(R11)	; Store address of record header buffer
	MOVZBL	FAB$B_FSZ(R10),R2	; Get size of record header
	SUBL2	R2,R4			; Compute size of record
	ADDL2	R2,R5			; Compute address of record
20$:	MOVW	R4,RAB$W_RSZ(R11)	; Store record size
	MOVL	R5,RAB$L_RBF(R11)	; Store record address
	MOVAL	FAL$L_STB(R8),R7	; Get address of Statistics Block
	INCL	FAL$L_RCV_DAT(R7)	; Increment RCV record/block count
	ADDL2	R4,FAL$L_RCV_USR(R7)	; Update RCV user data byte count
	$UPDATE	RAB=R11			; Update record

;+
; Common exit path for $FIND and $UPDATE.
;-

SEND_STS_RFA:				; Check status of RMS function call
	BLBC	R0,20$			; Branch on failure

;
; Send Status message if partner implemented to DAP since V5.6.
;

	BBC	#DAP$V_GEQ_V56,(R9),10$	; Branch if partner used DAP before V5.6
	$SETBIT	#FAL$V_RET_RFA,(R8)	; Return RFA of record
	BRW	SEND_STS_SUC		; Branch aid
10$:	BRW	EXIT_SUCCESS		; Exit state with success
20$:	BRW	ERR_FILE_XFER		; Return error in Status message

	.SBTTL	FAL$DELETE

;++
; This routine performs the DAP DELETE record function.
;--

FAL$DELETE::				; Entry point
	$DELETE RAB=R11			; Delete record
	BLBC	R0,20$			; Branch on failure

;
; Send Status message if partner implemented to DAP since V5.6.
;

	BBC	#DAP$V_GEQ_V56,(R9),10$	; Branch if partner used DAP before V5.6
	BRW	SEND_STS_SUC		; Branch aid
10$:	BRW	EXIT_SUCCESS		; Exit state with success
20$:	BRW	ERR_FILE_XFER		; Return error in Status message

	.SBTTL	FAL$DISPLAY

;++
; This routine performs the DAP DISPLAY file attributes function.
;
; Note:	RMS returns only XAB information on $DISPLAY. The DAP specification,
;	however, allows partner to request that the DAP Attributes and Name
;	messages be returned in addition to Extended Attributes messages.
;	If Attributes or Name messages are requested, they will be built from
;	information in the FAB and NAM blocks, respectively, that were updated
;	at open/create time.
;--

FAL$DISPLAY::				; Entry point
	CLRL	FAB$L_XAB(R10)		; Remove any XABs from chain
	MOVAL	FAB$L_XAB(R10),-	;
		FAL$L_CHAIN_NXT(R8)	; Save address of next chain pointer
	BSBW	CHAIN_RQST_XABS		; Add required XABs to XAB chain
	$DISPLAY FAB=R10		; Obtain file attributes
	BLBC	R0,10$			; Branch on failure
	BSBW	CHAIN_RQST_PRT2		; Fill in alterate ALLXABs and KEYXABs
					;  as directed by NOA and NOK values
	BLBC	R0,10$			; Branch on failure

;
; Return (main) Attributes, Extended Attributes, and (resultant) Name messages
; to partner as directed by request mask, terminated by an Acknowledge message.
;

	BSBW	SEND_OPTNL_MSGS		; Build and send optional DAP messages
	BRW	SEND_ACK		; Send Acknowledge message
10$:	BRW	ERR_FILE_XFER		; Return error in Status message

	.SBTTL	FAL$EXTEND

;++
; This routine performs the DAP EXTEND file allocation function.
;--

FAL$EXTEND::				; Entry point
	CLRL	FAB$L_XAB(R10)		; Remove any XABs from chain
	MOVAL	FAB$L_XAB(R10),-	;
		FAL$L_CHAIN_NXT(R8)	; Save address of next chain pointer
	BSBW	CHAIN_RECV_XABS		; Add received XABs to XAB chain
	$EXTEND FAB=R10			; Extend file
	BLBC	R0,10$			; Branch on failure

;
; Return Allocation message(s) terminated by an Acknowledge message.
;

	BSBW	SEND_OPTNL_MSGS		; Build and send optional DAP messages
	BRW	SEND_ACK		; Send Acknowledge message
10$:	BRW	ERR_FILE_XFER		; Return error in Status message

	.SBTTL	FAL$REWIND
	.SBTTL	FAL$TRUNCATE, FAL$FLUSH
	.SBTTL	FAL$FREE, FAL$RELEASE

;++
; The following routines have separate entry points but share common code ...
;
; This routine performs the DAP REWIND file function.
;--

FAL$REWIND::				; Entry point
	$REWIND RAB=R11			; Rewind record stream
	BRB	SEND_STS_ALWAYS		; Join common code

;++
; This routine performs the DAP TRUNCATE file function.
;--

FAL$TRUNCATE::				; Entry point
	$TRUNCATE RAB=R11		; Truncate file
	BRB	SEND_STS_ALWAYS		; Join common code

;++
; This routine performs the DAP FLUSH file function.
;--

FAL$FLUSH::				; Entry point
	$FLUSH RAB=R11			; Flush I/O buffers and write modified
					;  file attributes
	BRB	SEND_STS_ALWAYS		; Join common code

;++
; This routine performs the DAP FREE locked record function.
;--

FAL$FREE::				; Entry point
	$FREE RAB=R11			; Free all locked records
	BRB	SEND_STS_ALWAYS		; Join common code

;++
; This routine performs the DAP RELEASE all locked records function.
;--

FAL$RELEASE::				; Entry point
	$RELEASE RAB=R11		; Release specified locked record
	BRB	SEND_STS_ALWAYS		; Join common code

	.SBTTL	FAL$SPACE_BW, FAL$SPACE_FW

;++
; These routines perform the DAP SPACE functions, space-forward and
; space-backward.
;
; Note:	They return the actual # blocks spaced as an unsigned number obtained
;	from STV which may be non-zero for RMS$_NORMAL, RMS$_BOF, and RMS$_EOF
;	completion codes.
;--

FAL$SPACE_BW::				; Entry point for space backward
	MNEGL	RAB$L_BKT(R11),-	; DAP sends an absolute value,
		RAB$L_BKT(R11)		;  so negate it
FAL$SPACE_FW::				; Entry point for space forward
	$SPACE	RAB=R11			; Skip or backspace specified # blocks
	$SETBIT	#FAL$V_RET_RECN,(R8)	; Always return actual # blocks spaced
					;  as an unsigned number in RECNUM2
	MOVL	RAB$L_STV(R11),-	; Copy STV value to BKT field so that
		RAB$L_BKT(R11)		;  STV value will be returned in DAP
					;  RECNUM2 field per DAP spec

;
; Common exit path for $REWIND, $TRUNCATE, $FLUSH, $FREE, $RELEASE, and $SPACE.
;

SEND_STS_ALWAYS:			; Check status of RMS function call
	BLBC	R0,10$			; Branch on failure

;
; Send Status message to partner.
;

	BRW	SEND_STS_SUC		; Branch aid
10$:	BRW	ERR_FILE_XFER		; Join common code

	.SBTTL	FAL$DISCONNECT

;++
; This routine performs the DAP DISCONNECT record stream function.
; (Also called the end-of-stream function in the DAP specification.)
;--

FAL$DISCONNECT::			; Entry point
	$DISCONNECT RAB=R11		; Destroy record stream
	BLBC	R0,20$			; Branch on failure
	BBC	#DAP$V_GEQ_V42,(R9),10$	; Branch if partner used DAP before V4.2
					;  (namely, DAP V4.1)
	BRW	SEND_CMP		; Send Access Complete message
10$:	BRW	EXIT_SUCCESS		; Exit state with success
20$:	BRW	ERR_FILE_XFER		; Return error in Status message

	.SBTTL	FAL$RESET, FAL$CHANGE

;++
; The following routines have separate entry points but share common code ...
;
; This routine performs the DAP RESET file function. RESET is similar to CLOSE
; except that the file is erased if it was created by this access operation.
; 
; Note:	Before DAP V6.0 this function was called PURGE.
;--

FAL$RESET::				; Entry point
	CMPB	FAL$B_ACCFUNC(R8),-	; Erase file if this was a
		#DAP$K_CREATE		;  file creation
	BEQL	10$			;
	CMPB	FAL$B_ACCFUNC(R8),-	;  or a
		#DAP$K_SUBMIT		;  file submission
	BNEQ	CLOSE_COMMON		;  operation
10$:	$SETBIT	#FAB$V_DLT,FAB$L_FOP(R10);Set delete-on-close bit
	BRB	CLOSE_COMMON		; Join common close code

;++
; This routine performs the DAP CHANGE file attributes on close function.
;--

FAL$CHANGE::				; Entry point

;
; Protection and Revision Date and Time XABs are input on close, so create an
; XAB chain with these XABs if DAP Protection and/or Date and Time messages
; have been received from partner.
;

	BICW2	#FAL$M_DATXAB,-		; Clear DATXAB flag as both DATXAB and
		FAL$W_RECEIVED(R8)	;  RDTXABs are generated when a Date
					;  and Time message is received
	BSBW	CHAIN_RECV_XABS		; Add received XABs to XAB chain
	BRB	CLOSE_COMMON		; Join common close code

	.SBTTL	FAL$CLOSE

;++
; This routine performs the DAP CLOSE file function.
;--

FAL$CLOSE::				; Entry point
	CLRL	FAB$L_XAB(R10)		; Remove any XABs from chain
	MOVAL	FAB$L_XAB(R10),-	;
		FAL$L_CHAIN_NXT(R8)	; Save address of next chain pointer

;
; Simulate support of the Revision Date and Time XAB on close if all of the
; following are true:
;   (1)	partner does not support change of revision information on close
;   (2)	this is a file creation operation
;   (3) a DAP Date and Time message was received on create
;
; If a Date and Time message is received on create, FAL$CREATE generates a
; RDTXAB for use on create. This XAB can now be used as input on close to
; preserve the revision date and time and revision number of the file that was
; established on create. This is the desired action for a file COPY operation
; where the remote node is not capable of specifying this action when the file
; is closed.
;

	BBS	#DAP$V_CHGTIM,-		; Branch if partner supports change
		DAP$Q_SYSCAP(R9),-	;  of revision information on close
		CLOSE_COMMON		;
	CMPB	FAL$B_ACCFUNC(R8),-	; Branch if this was not a file
		#DAP$K_CREATE		;  creation operation
	BNEQ	CLOSE_COMMON		;
	MOVAL	FAL$L_RDTXAB(R8),R7	; Get address of RDTXAB
	CMPB	XAB$B_COD(R7),#XAB$C_RDT; Branch if RDTXAB has not been
	BNEQ	CLOSE_COMMON		;  initialized (and filled in on create)
	BSBW	CHAIN_THIS_XAB		; Add this XAB to XAB chain
	CLRL	XAB$L_NXT(R7)		; Be sure XAB chain is terminated as
					;  RDTXAB was on chain during create!

;+
; Common code path for FAL$RESET, FAL$CHANGE, and FAL$CLOSE.
;-

CLOSE_COMMON:				; Code common to all close operations

;
; Process optional DAP level CRC checksum value.
;

	BBC	#DAP$V_RET_CRC,-	; Branch if checksum option not
		FAL$B_ACCOPT(R8),10$	;  requested by accessing node
	BBC	#DAP$V_X_CHECK,(R9),10$	; Branch if checksum value not
					;  explicitly sent by partner
	CMPW	DAP$W_CHECK(R9),-	; Compare the checksums
		DAP$L_CRC_RSLT(R9)	;  (order 16 CRC)
	BEQLU	10$			; Branch if they match
	BSBW	FAL$CRC_LOGERR		; Log the DAP CRC error
	MOVZWL	#<RMS$_CRC&^XFFFF>,R0	; Stuff error code (lower 16 bits)
	BRB	30$			; Return CRC error to partner

;
; Close the file.
;

10$:	$CLOSE	FAB=R10			; Close file
	BLBC	R0,30$			; Branch on failure
	BBS	#FAL$V_WILD,(R8),20$	; Branch if wildcard operation
	BRW	SEND_CMP		; Send Access Complete message
20$:	BICL2	#<<FAB$M_DLT>!-		; Clear FOP options (DLT, SCF, SPL)
		  <FAB$M_SCF>!-		;  as wildcard file retrieval operation
		  <FAB$M_SPL>!-		;  will not re-initialize the FAB and
		0>,FAB$L_FOP(R10)	;  these bits are input to RMS for
					;  both open and close operations
	BRW	EXIT_SUCCESS		; Exit state with success
30$:	BRW	ERR_FILE_CLOS		; Return error in Status message

	.SBTTL	STATE TRANSITION ERRORS

;++
; The following routines are called by the state table manager to report state
; table transition errors. These are due to an inappropriate DAP message being
; received for the current state, or an invalid or unsupported operation being
; requested for the current state. Each of these routines sends a Status message
; to the partner process.
;--


	.SBTTL	FAL$OUT_OF_SEQ

;++
; The DAP message being processed is incorrect (out-of-sequence) for the state.
;--

FAL$OUT_OF_SEQ::			; Entry point
	BRW	ERR_SYNCHRONIZE		; Return error in Status message


	.SBTTL	FAL$INV_ACCFUNC
	.SBTTL	FAL$INV_CTLFUNC
	.SBTTL	FAL$INV_CONFUNC, FAL$UNS_CONFUNC
	.SBTTL	FAL$INV_CMPFUNC

;++
; The ACCFUNC field value is invalid for state table context.
;--

FAL$INV_ACCFUNC::			; Entry point
	MOVL	#DAP$_ACCFUNC,R0	; Get field ID code
	BRW	ERR_INVALID		; Return error in Status message

;++
; The CTLFUNC field value is invalid for state table context.
;--

FAL$INV_CTLFUNC::			; Entry point
	MOVL	#DAP$_CTLFUNC,R0	; Get field ID code
	BRW	ERR_INVALID		; Return error in Status message

;++
; The CONFUNC field value is invalid for state table context.
;--

FAL$INV_CONFUNC::			; Entry point
	MOVL	#DAP$_CONFUNC,R0	; Get field ID code
	BRW	ERR_INVALID		; Return error in Status message

;++
; The CONFUNC field value is unsupported for state table context.
;--

FAL$UNS_CONFUNC::			; Entry point
	MOVL	#DAP$_CONFUNC,R0	; Get field ID code
	BRW	ERR_UNSUPPORT		; Return error in Status message

;++
; The CMPFUNC field value is invalid for state table context.
;--

FAL$INV_CMPFUNC::			; Entry point
	MOVL	#DAP$_CMPFUNC,R0	; Get field ID code
	BRW	ERR_INVALID		; Return error in Status message

;++
; This routine returns a Status message with an unsupported-key-field error
; code. It is actually an internal support routine for FAL$DECODE_CTL.
;--

FAL$UNS_KEY::				; Entry point
	MOVL	#DAP$_KEY,R0		; Get field ID code
	BRW	ERR_UNSUPPORT		; Return error in Status message

	.SBTTL	SUPPORT ROUTINES


	.SBTTL	CHAIN_RQST_XABS

;++
; This routine initializes XABs and adds them to the XAB chain as necessary
; to obtain the requested file attribute information when the subsequent $OPEN
; is performed.
;
; Note:	Only requests for the DAP KEY, ALL, SUM, TIM, and PRO messages are
;	handled here by chaining in the appropriate XABs. Furthermore, only
;	primary Allocation and Key Definition XABs are chained into the list
;	at this time, as the NOA and NOK values from the Summary XAB are not
;	known yet.
;
; Inputs include:
;
;	FAL$W_DISPLAY
;	FAL$L_CHAIN_NXT
;--

CHAIN_RQST_XABS:			; Entry point
	MOVZWL	FAL$W_DISPLAY(R8),AP	; Copy display mask to scratch register
					;  (i.e., list of DAP Extended
					;  Attributes messages to return)
	CLRL	FAL$L_ALLXABINI(R8)	; Zero list of ALLXABs initialized
	CLRL	FAL$L_KEYXABINI(R8)	; Zero list of KEYXABs initialized
	BITW	#<<DAP$M_DSP_ALL>!-	; Branch if neither Allocation nor
		  <DAP$M_DSP_KEY>!-	;  Key Definition messages are to be
		0>,AP			;  returned
	BEQL	10$			;
	$SETBIT	#DAP$V_DSP_SUM,AP	; Include Summary XAB (to obtain NOA and
					;  NOK values) in case an indexed file
					;  is opened
10$:	CLRL	R6			; Indicate AID=0 and REF=0 for
					;  Allocation and Key Definition XABs

	ASSUME	DAP$V_DSP_ATT+1 EQ DAP$V_DSP_KEY
	ASSUME	DAP$V_DSP_KEY+1 EQ DAP$V_DSP_ALL
	ASSUME	DAP$V_DSP_ALL+1 EQ DAP$V_DSP_SUM
	ASSUME	DAP$V_DSP_SUM+1 EQ DAP$V_DSP_TIM
	ASSUME	DAP$V_DSP_TIM+1 EQ DAP$V_DSP_PRO

CHAIN_RQST_LOOP:			;
	FFS	#DAP$V_DSP_KEY,#5,AP,R0	; Get position of next bit set
	$CLRBIT	R0,AP			; Clear request bit just found
	PUSHAB	B^10$			; Push return address on stack
	$CASEB	SELECTOR=R0-		; Next XAB to add to chain:
		BASE=#DAP$V_DSP_KEY-	;
		DISPL=<-		;
		    FAL$INIT_KEYXAB-	;  Key Definition
		    FAL$INIT_ALLXAB-	;  Allocation
		    FAL$INIT_SUMXAB-	;  Summary
		    FAL$INIT_DATXAB-	;  Date and Time
		    FAL$INIT_PROXAB-	;  Protection
		>			;
	POPR	#^M<R0>			; Throw away loop return address
	RSB				; Exit
10$:	BSBW	CHAIN_THIS_XAB		; Add this XAB to XAB chain
	BRB	CHAIN_RQST_LOOP		; Handle next request

	.SBTTL	CHAIN_RQST_PRT2

;++
; This routine creates an XAB chain of alternate Allocation and Key Definition
; XABs (as required) and then calls $DISPLAY to fill them in.
;
; If an indexed file was opened and DAP Allocation and/or Key Definition
; messages are to be returned, then the NOA and NOK values from the Summary XAB
; are used to determine how may alternate XABs are required to be filled.
;--

CHAIN_RQST_PRT2:			; Entry point
	MOVL	#1,R0			; Assume success
	CMPB	FAB$B_ORG(R10),-	; Branch if not IDX organization
		#FAB$C_IDX		;
	BNEQ	50$			;
	BITW	#<<DAP$M_DSP_ALL>!-	; Branch if neither Allocation nor
		  <DAP$M_DSP_KEY>!-	;  Key Definition messages are to be
		0>,FAL$W_DISPLAY(R8)	;  returned
	BEQL	50$			;
	MOVAL	FAB$L_XAB(R10),-	; Get address of start of XAB chain
		FAL$L_CHAIN_NXT(R8)	;  and store it

;
; Initialize multiple Allocation XABs as required and chain them in.
;

	BBC	#DAP$V_DSP_ALL,-	; Branch if DAP Allocation message
		FAL$W_DISPLAY(R8),20$	;  is not requested
	MOVZBL	FAL$L_SUMXAB+XAB$B_NOA(R8),AP ; Get number of areas value
	CMPL	AP,#1			; Branch if there are no alternate
	BLEQU	20$			;  areas
	CLRL	R6			; Initialize area ID value
10$:	BSBW	FAL$INIT_ALLXAB		; Initialize next Allocation XAB
					;  on return R7 = address of XAB
	BLBC	R0,20$			; Branch on failure (AID too large)
	BSBW	CHAIN_THIS_XAB		; Add this XAB to XAB chain
	INCL	R6			; Increment area ID value
	SOBGTR	AP,10$			; Branch if more to process

;
; Initialize multiple Key Definition XABs (as required) and chain them in.
;

20$:	BBC	#DAP$V_DSP_KEY,-	; Branch if DAP Key Definition message
		FAL$W_DISPLAY(R8),40$	;  is not requested
	MOVZBL	FAL$L_SUMXAB+XAB$B_NOK(R8),AP ; Get number of keys value
	CMPL	AP,#1			; Branch if there are no alternate
	BLEQU	40$			;  keys
	CLRL	R6			; Initialize key of reference value
30$:	BSBW	FAL$INIT_KEYXAB		; Initialize next Key Definition XAB
					;  on return R7 = address of XAB
	BLBC	R0,40$			; Branch on failure (REF too large)
	BSBW	CHAIN_THIS_XAB		; Add this XAB to XAB chain
	INCL	R6			; Increment key of reference value
	SOBGTR	AP,30$			; Branch if more to process

;
; Obtain additional file attribute information.
;

40$:	$DISPLAY FAB=R10		; Fill in primary and alternate
					;  Allocation and Key Definition XABs
50$:	RSB				; Exit

	.SBTTL	CHAIN_RECV_XABS

;++
; This routine adds XABs to the XAB chain that were received from the partner
; process for use when a subsequent $CREATE, $EXTEND, or $CLOSE is performed.
;
; Note:	Only XABs generated from the DAP KEY, ALL, TIM, and PRO messages are
;	handled here by chaining in the appropriate XABs. However, in contrast
;	To CHAIN_RQST_XABs, multiple Allocation and Key Definition XABs are
;	chained into the list (if present).
;
; Inputs include:
;
;	FAL$W_RECEIVED
;	FAL$L_KEYXABINI
;	FAL$L_ALLXABINI
;	FAL$L_CHAIN_NXT
;--

CHAIN_RECV_XABS:			; Entry point
	MOVZWL	FAL$W_RECEIVED(R8),AP	; Copy received mask to scratch register
					;  (i.e., list of XABs generated from
					;  receipt of optional DAP messages)

	ASSUME	FAL$V_KEYXAB   EQ 0
	ASSUME	FAL$V_KEYXAB+1 EQ FAL$V_ALLXAB
	ASSUME	FAL$V_ALLXAB+1 EQ FAL$V_DATXAB
	ASSUME	FAL$V_DATXAB+1 EQ FAL$V_PROXAB
	ASSUME	FAL$V_PROXAB+1 EQ FAL$V_RDTXAB

CHAIN_RECV_LOOP:			;
	FFS	#FAL$V_KEYXAB,#5,AP,R0	; Get position of next bit set
	$CLRBIT	R0,AP			; Clear request bit just found
	$CASEB	SELECTOR=R0-		; Next XAB to add to chain:
		DISPL=<-		;
		    10$-		;  Key definition
		    20$-		;  Allocation
		    30$-		;  Date and Time
		    40$-		;  Protection
		    50$-		;  Revision Date and Time
		>			;
	RSB				; Exit

;
; Chain Key Definition XAB(s).
;

10$:	MOVL	FAL$L_KEYXABINI(R8),R5	; Put list of KEYXABs received in
					;  scratch register; at least one bit
					;  in range is guaranteed to be set
15$:	FFS	#0,#FAL$K_MAX_REF+1,R5,R6 ; Get REF value of next KEYXAB
	BEQL	CHAIN_RECV_LOOP		; Branch if mask exhausted
	$CLRBIT	R6,R5			; Clear bit just found
	MULL2	#FAL$K_KEYXAB,R6	; Using REF as an index, compute
	MOVAB	FAL$L_KEYXAB(R8)[R6],R7	;  address of KEYXAB to use
	BSBW	CHAIN_THIS_XAB		; Add this XAB to XAB chain
	BRB	15$			; Handle next alternate KEYXAB

;
; Chain Allocation XAB(s).
;

20$:	MOVL	FAL$L_ALLXABINI(R8),R5	; Put list of ALLXABs received in
					;  scratch register; at least one bit
					;  in range is guaranteed to be set
25$:	FFS	#0,#FAL$K_MAX_AID+1,R5,R6 ; Get AID value of next ALLXAB
	BEQL	CHAIN_RECV_LOOP		; Branch if mask exhausted
	$CLRBIT	R6,R5			; Clear bit just found
	MULL2	#FAL$K_ALLXAB,R6	; Using AID as an index, compute
	MOVAB	FAL$L_ALLXAB(R8)[R6],R7	;  address of ALLXAB to use
	BSBW	CHAIN_THIS_XAB		; Add this XAB to XAB chain
	BRB	25$			; Handle next alternate ALLXAB

;
; Chain Date and Time, Protection, and Revision Date and Time XABs.
;

30$:	MOVAL	FAL$L_DATXAB(R8),R7	; Get address of Date and Time XAB
	BRB	60$			;
40$:	MOVAL	FAL$L_PROXAB(R8),R7	; Get address of Protection XAB
	BRB	60$			;
50$:	MOVAL	FAL$L_RDTXAB(R8),R7	; Get address of Rev Date and Time XAB
60$:	BSBW	CHAIN_THIS_XAB		; Add this XAB to XAB chain
	BRB	CHAIN_RECV_LOOP		; Handle next request

	.SBTTL	CHAIN_THIS_XAB

;++
; This routine chains the specified XAB into the XAB chain.
;
; Inputs include:
;
;	R7 contains address of XAB
;
;	FAL$L_CHAIN_NXT
;--

CHAIN_THIS_XAB:				; Entry point
	MOVL	R7,@FAL$L_CHAIN_NXT(R8)	; Insert XAB address into XAB chain
	ADDL3	R7,#XAB$L_NXT,-		; Compute address of next chain pointer
		FAL$L_CHAIN_NXT(R8)	;  and save it
	RSB				; Exit

	.SBTTL	SEND_OPTNL_MSGS

;++
; Build and send (main) Attributes, Extended Attributes, and Name messages to
; partner as directed by the request mask (FAL$W_DISPLAY).
;
; Note:	The Summary message will be sent before any of the other Extended
;	Attributes messages (per DAP V6.0 specification).
;
; Inputs include:
;
;	FAL$W_DISPLAY
;	FAL$L_KEYXABINI
;	FAL$L_ALLXABINI
;--

SEND_OPTNL_MSGS:			; Entry point
	MOVZWL	FAL$W_DISPLAY(R8),AP	; Copy display mask to scratch register
					;  (i.e., list of DAP Extended
					;  Attributes messages to return)

	ASSUME	DAP$V_DSP_ATT   EQ 0
	ASSUME	DAP$V_DSP_ATT+1 EQ DAP$V_DSP_KEY
	ASSUME	DAP$V_DSP_KEY+1 EQ DAP$V_DSP_ALL
	ASSUME	DAP$V_DSP_ALL+1 EQ DAP$V_DSP_SUM
	ASSUME	DAP$V_DSP_SUM+1 EQ DAP$V_DSP_TIM
	ASSUME	DAP$V_DSP_TIM+1 EQ DAP$V_DSP_PRO
	ASSUME	DAP$V_DSP_PRO+3 EQ DAP$V_DSP_NAM

	EXTZV	#DAP$V_DSP_KEY,#2,AP,R0	; Rearrange display mask to put
	EXTZV	#DAP$V_DSP_SUM,#1,AP,R1	;  Summary message ahead of
	INSV	R1,#DAP$V_DSP_KEY,#1,AP	;  Key Definition and
	INSV	R0,#DAP$V_DSP_ALL,#2,AP	;  Allocation messages
SEND_OPTNL_LOOP:			;
	FFS	#0,#DAP$V_DSP_NAM+1,AP,R0 ; Get position of next bit set
	$CLRBIT	R0,AP			; Clear request bit just found
	PUSHAB	B^40$			; Push return address on stack
	$CASEB	SELECTOR=R0-		; Next message:
		DISPL=<-		;
		    FAL$ENCODE_ATT-	;  Attributes
		    FAL$ENCODE_SUM-	;  Summary
		    10$-		;  Key Definition
		    20$-		;  Allocation
		    FAL$ENCODE_TIM-	;  Date and Time
		    FAL$ENCODE_PRO-	;  Protection
		    30$-		;  (reserved)
		    30$-		;  (reserved)
		    FAL$ENCODE_NAM-	;  (resultant) Name
		>			; Exit loop
	POPR	#^M<R0>			; Throw away loop return address
	RSB				; Exit
10$:	PUSHL	AP			; Save register
	MOVL	FAL$L_KEYXABINI(R8),AP	; Put list of KEYXABs initialized in
					;  scratch register; at least one bit
					;  is guaranteed to be set
15$:	FFS	#0,#FAL$K_MAX_REF+1,AP,R6 ; Get REF value of next KEYXAB
	BEQL	28$			; Branch if mask exhausted
	$CLRBIT	R6,AP			; Clear bit just found
	MULL3	R6,#FAL$K_KEYXAB,R0	; Using REF as an index, compute
	MOVAB	FAL$L_KEYXAB(R8)[R0],R7	;  address of KEYXAB to use
	BSBW	FAL$ENCODE_KEY		; Build next Key Definition message
	BSBW	FAL$TRANSMIT		; Send message just built
	BRB	15$			; Handle next alternate KEYXAB
20$:	PUSHL	AP			; Save register
	MOVL	FAL$L_ALLXABINI(R8),AP	; Put list of ALLXABs initialized in
					;  scratch register; at least one bit
					;  in range is guaranteed to be set
25$:	FFS	#0,#FAL$K_MAX_AID+1,AP,R6 ; Get AID value of next ALLXAB
	BEQL	28$			; Branch if mask exhausted
	$CLRBIT	R6,AP			; Clear bit just found
	MULL3	R6,#FAL$K_ALLXAB,R0	; Using AID as an index, compute
	MOVAB	FAL$L_ALLXAB(R8)[R0],R7	;  address of ALLXAB to use
	BSBW	FAL$ENCODE_ALL		; Build next Allocation message
	BSBW	FAL$TRANSMIT		; Send message just built
	BRB	25$			; Handle next alternate ALLXAB
28$:	POPL	AP			; Restore register
30$:	POPR	#^M<R0>			; Throw away loop return address
	BRB	SEND_OPTNL_LOOP		; Handle next request
40$:	BSBW	FAL$TRANSMIT		; Send message just built
	BRB	SEND_OPTNL_LOOP		; Loop until done

	.SBTTL	SEND_3PART_NAM

;++
; Build and send the (volume) Name, (directory) Name, and (file) Name messages
; to partner.
;
; On output R1-R7 and AP are destroyed.
;--

SEND_3PART_NAM:				; Entry point
	PUSHR	#^M<R0>			; Save status code
	MOVL	FAB$L_NAM(R10),AP	; Get address of NAM block

;+
; Return DAP (volume) Name message to partner.
; The volume string in this context means nodespec (if present) plus device name
; string.
;-

SEND_VOL_NAM:				;
	MOVQ	FAL$Q_VOLNAME(R8),R4	; <R4,R5> => previous volume name
	MOVZBL	NAM$B_NODE(AP),R6	; Get size of node name string
	ADDB2	NAM$B_DEV(AP),R6	; Add size of device name string
	MOVL	NAM$L_NODE(AP),R7	; <R6,R7> => current volume name
	CMPC5	R4,(R5),#0,R6,(R7)	; Branch if previous and current
	BEQL	SEND_DIR_NAM		;  strings match
	MOVL	R6,FAL$Q_VOLNAME(R8)	; It's a new one, so save it
	MOVC3	R6,(R7),(R5)		;  (making it the previous one)
	MOVZBL	#DAP$M_VOLNAME,R5	; Get name type parameter
	BSBW	FAL$ENCODE_NAM1		; Build (volume) Name message
	BSBW	FAL$TRANSMIT		; Send Name message

;+
; Return DAP (directory) Name message to partner.
;-

SEND_DIR_NAM:				;
	MOVQ	FAL$Q_DIRNAME(R8),R4	; <R4,R5> => previous directory name
	MOVZBL	NAM$B_DIR(AP),R6	; Get size of directory name string
	MOVL	NAM$L_DIR(AP),R7	; <R6,R7> => current directory name
	CMPC5	R4,(R5),#0,R6,(R7)	; Branch if previous and current
	BEQL	SEND_FIL_NAM		;  strings match
	MOVL	R6,FAL$Q_DIRNAME(R8)	; It's a new one, so save it
	MOVC3	R6,(R7),(R5)		;  (making it the previous one)
	MOVZBL	#DAP$M_DIRNAME,R5	; Get name type parameter
	BSBW	FAL$ENCODE_NAM1		; Build (directory) Name message
	BSBW	FAL$TRANSMIT		; Send Name message

;+
; Return DAP (file) Name message to partner.
; The file string in this context can be either:
;   (1)	file name plus file type plus file version strings concatenated,
;	which is the normal case, or
;   (2) quoted string (if FAL received a file specification of the form
;	nodespec::"foreign-filespec").
;-


SEND_FIL_NAM:				;
	MOVZBL	NAM$B_NAME(AP),R6	; Get size of file name string
	ADDB2	NAM$B_TYPE(AP),R6	; Add size of file type string
	ADDB2	NAM$B_VER(AP),R6	; Add size of file version string
	MOVL	NAM$L_NAME(AP),R7	; <R6,R7> => current file name
	MOVZBL	#DAP$M_FILNAME,R5	; Get name type parameter
	BSBW	FAL$ENCODE_NAM1		; Build (file) Name message
	BSBW	FAL$TRANSMIT		; Send Name message
	POPR	#^M<R0>			; Restore status code
	RSB				; Exit

	.SBTTL	STATE EXIT ROUTINES

;++
; Return DAP file open error.
; R0 contains RMS completion code on input.
;--

ERR_FILE_OPEN:				; Entry point
	MOVL	#DAP$_FILE_OPEN,R2	; Get DAP MACCODE value
	MOVL	FAB$L_STV(R10),R1	; Get status value from FAB
	BRB	ERR_FILE		; Send Status message

;++
; Return DAP file transfer error.
; R0 contains RMS completion code on input.
;--

ERR_FILE_XFER:				; Entry point
	MOVL	#DAP$_FILE_XFER,R2	; Get DAP MACCODE value
	MOVL	RAB$L_STV(R11),R1	; Get status value from RAB
	BRB	ERR_FILE		; Send Status message

;++
; Return DAP file close error.
; R0 contains RMS completion code on input.
;--

ERR_FILE_CLOS:				; Entry point
	MOVL	#DAP$_FILE_CLOS,R2	; Get DAP MACCODE value
	MOVL	FAB$L_STV(R10),R1	; Get status value from FAB
ERR_FILE:				;
	BEQL	10$			; Branch on zero STV
	BBC	#DAP$V_VAXVMS,(R9),10$	; Branch if partner is not VAX/VMS
	$SETBIT	#FAL$V_RET_STV,(R8)	; Request return of STV field in
					;  DAP Status message
10$:	BRB	SEND_STS_FAIL		; Send Status message

;++
; Return DAP invalid error.
; R0 contains DAP field ID code on input.
;--

ERR_INVALID:				; Entry point
	MOVZBL	DAP$B_TYPE(R9),R1	; Get DAP message type
	MOVL	#DAP$_INVALID,R2	; Get DAP MACCODE value
	BRB	SEND_STS_FAIL		; Send Status message

;++
; Return DAP unsupported error.
; R0 contains DAP field ID code on input.
;--

ERR_UNSUPPORT:				; Entry point
	MOVZBL	DAP$B_TYPE(R9),R1	; Get DAP message type
	MOVL	#DAP$_UNSUPPORT,R2	; Get DAP MACCODE value
	BRB	SEND_STS_FAIL		; Send Status message

;++
; Return DAP message-out-of-sequence error.
;--

ERR_SYNCHRONIZE:			; Entry point
	MOVZBL	DAP$B_TYPE(R9),R1	; Get DAP message type
	MOVL	#DAP$_MSG_SYNC,R2	; Get DAP MACCODE value

;++
; Build and send (failure) Status message to partner.
; Declare this last message of a response sequence and exit state with failure.
; R0 contains RMS completion code on input.
;--

SEND_STS_FAIL:				; Entry point
	$SETBIT	#FAL$V_LAST_MSG,(R8)	; Declare this last message to block
	BSBW	FAL$ENCODE_STS		; Build Status message
	BSBW	FAL$TRANSMIT		; Send Status message to partner

;++
; Exit state with failure.
;--

EXIT_FAILURE:				; Entry point
	CLRL	R0			; Signal state transition failure
	RSB				; Exit to state table manager

;++
; Build and send (success) Status message to partner.
; Declare this last message of a response sequence and exit state with success.
; R0 contains RMS (success) completion code on input.
;--

SEND_STS_SUC:				; Entry point
	$SETBIT	#FAL$V_LAST_MSG,(R8)	; Declare this last message to block
	MOVL	#DAP$_SUCCESS,R2	; Get DAP MACCODE value
	BSBW	FAL$ENCODE_STS		; Build Status message
	BSBW	FAL$TRANSMIT		; Send Status message to partner

;++
; Exit state with success.
;--

EXIT_SUCCESS:				; Entry point
	MOVL	#1,R0			; Signal state transition success
	RSB				; Exit to state table manager

;++
; Build and send Acknowledge message to partner.
; Declare this last message of a response sequence and exit state with success.
;--

SEND_ACK:				; Entry point
	$SETBIT	#FAL$V_LAST_MSG,(R8)	; Declare this last message to block
	MOVL	#DAP$K_ACK_MSG,R0	; Get message type value
	BSBW	FAL$BUILD_HEAD		; Construct message header
					; There are no fields in message body!
	BSBW	FAL$BUILD_TAIL		; Finish building message
	BSBW	FAL$TRANSMIT		; Send Acknowledge message
	BRB	EXIT_SUCCESS		; Exit state with success

;++
; Build and send Access Complete message to partner
; Declare this last message of a response sequence and exit state with success.
;--

SEND_CMP:				; Entry point
	$SETBIT	#FAL$V_LAST_MSG,(R8)	; Declare this last message to block
	MOVL	#DAP$K_CMP_MSG,R0	; Get message type value
	BSBW	FAL$BUILD_HEAD		; Construct message header
	MOVB	#DAP$K_RESPONSE,(R3)+	; Store CMPFUNC field
	BSBW	FAL$BUILD_TAIL		; Finish building message
	BSBW	FAL$TRANSMIT		; Send Access Complete message
	BRB	EXIT_SUCCESS		; Exit state with success

	.END				; End of module
