	.TITLE	FALDECODE - DECODE DAP MESSAGE
	.IDENT	'V03-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; Facility: FAL (DECnet File Access Listener)
;
; Abstract:
;
;	This module decodes (parses) the next DAP message and stores the
;	validated fields in the DAP control block.
;
; Environment: VAX/VMS, user mode
;
; Author: James A. Krycka,	Creation Date:	16-JUN-1977
;
; Modified By:
;
;	V03-001	JAK0028		J A Krycka	23-APR-1982
;		Add hundredths of second digits to ASCII time string before
;		calling $BINTIM system service.
;
;	V02-037	JAK0022		J A Krycka	24-AUG-1981
;		Update symbols to correspond to revised DAPDEF.MDL file.
;
;	V02-036	JAK0019		J A Krycka	23-JUN-1981
;		Support the LEN256 field in the DAP message header.
;		Support the DAP RELEASE function.
;		Set the DAP$V_GEQ_V60 status flag as appropriate.
;		Set the DAP$V_STM_ONLY status flag for TOPS-10 file system.
;
;	V02-035	JAK0016		J A Krycka	12-DEC-1980
;		Set DAP$V_RMS and DAP$V_FCS status flags as appropriate.
;
;--

	.SBTTL	DECLARATIONS

;
; Include Files:
;

	$DAPPLGDEF			; Define DAP prologue symbols
	$DAPHDRDEF			; Define DAP message header
	$DAPSSPDEF			; Define DAP system specific field
	$DAPCNFDEF			; Define DAP Configuration message
	$DAPATTDEF			; Define DAP Attributes message
	$DAPACCDEF			; Define DAP Access message
	$DAPCTLDEF			; Define DAP Control message
	$DAPCONDEF			; Define DAP Continue Transfer message
	$DAPACKDEF			; Define DAP Acknowledge message
	$DAPCMPDEF			; Define DAP Access Complete message
	$DAPDATDEF			; Define DAP Data message
	$DAPSTSDEF			; Define DAP Status message
	$DAPKEYDEF			; Define DAP Key Definition message
	$DAPALLDEF			; Define DAP Allocation message
	$DAPSUMDEF			; Define DAP Summary message
	$DAPTIMDEF			; Define DAP Date and Time message
	$DAPPRODEF			; Define DAP Protection message
	$DAPNAMDEF			; Define DAP Name message
	$DAPFIDDEF			; Define DAP field ID symbols

;
; Macros:
;
;	See next page for local macro definitions.
;
; Equated Symbols:
;

K_EXT=0					; Extensible field format
K_FIX=1					; Fixed length field format
K_IMG=2					; Image field format
K_ROM=3					; Rest-of-message field format

V_DESC=4				; Store descriptor of source field
V_TRUNC=5				; Truncate source field if necessary
V_SRCR3=6				; Source field size in R3
					;  (applicable only if K_FIX specified)

M_DESC=<1@V_DESC>			; Mask for V_DESC
M_TRUNC=<1@V_TRUNC>			; Mask for V_TRUNC
M_SRCR3=<1@V_SRCR3>			; Mask for V_SRCR3

	ASSUME	DAP$Q_DCODE_FLG EQ 0

;
; Own Storage:
;
;	None
;

	.SBTTL	LOCAL MACRO DEFINITIONS

;++
; STORE_FIELD obtains the next field (if any) from the DAP message being parsed,
; converts it to an appropriate format, and stores the result in the designated
; field of the DAP control block. The arguments (coded in-line) are:
;
;	NAME  = the symbolic name of DAP field used to generate symbolic DAP
;		control block offset and field ID values.
;	SIZE  = the size in bytes of designated field in DAP control block.
;	FORMAT= the format or structure of the source field. Choices are:
;		K_EXT = extensible field (bit7 of each byte is used to signify
;			termination/continuation (0/1) of the field).
;		K_FIX = fixed length field.
;		K_IMG = image field (counted string).
;		K_ROM = rest-of-message is taken as the next field.
;	MASK  = the flags to control field processing:
;		M_DESC= store only descriptor of the source field.
;		M_TRUNC=truncate extra bytes if SRC field size is larger than
;			DST field size (instead of declaring an error).
;		M_SRCR3=size of source field is given in R3 (applicable only if
;			K_FIX is also specified).
;--

	.MACRO	STORE_FIELD NAME,SIZE=1,FORMAT=1,MASK=0
	BSBW	STORE_FIELD
	.BYTE	SIZE
TMP1..=.
	.IIF EQ	<SIZE-1>,	.BYTE	DAP$B_'NAME
	.IIF EQ	<SIZE-2>,	.BYTE	DAP$W_'NAME
	.IIF EQ	<SIZE-4>,	.BYTE	DAP$L_'NAME
	.IIF EQ	<SIZE-6>,	.BYTE	DAP$W_'NAME
	.IIF EQ	<SIZE-8>,	.BYTE	DAP$Q_'NAME
TMP2..=.
	.IIF EQ	<TMP2..-TMP1..>,.ERROR	;***** invalid field size *****;
	.BYTE	DAP$_'NAME
	.BYTE	FORMAT!MASK
	.ENDM	STORE_FIELD

;++
; CHECK_MASKS examines the designated field of the DAP control block for
; invalid and unsupported bits set. The arguments (coded in-line) are:
;
;	NAME  =	the symbolic name of the DAP field used to generate symbolic
;		invalid and unsupported mask values.
;	SIZE  =	the size in bytes of designated field in the DAP control block.
;--

	.MACRO	CHECK_MASKS NAME,SIZE=1
	BSBW	CHECK_MASKS
	.BYTE	SIZE
TMP1..=.
	.IIF EQ	<SIZE-1>,	.BYTE	DAP$K_'NAME'_I,DAP$K_'NAME'_U
	.IIF EQ	<SIZE-2>,	.WORD	DAP$K_'NAME'_I,DAP$K_'NAME'_U
	.IIF EQ	<SIZE-4>,	.LONG	DAP$K_'NAME'_I,DAP$K_'NAME'_U
TMP2..=.
	.IIF EQ	<TMP2..-TMP1..>,.ERROR	;***** invalid field size *****;
	.ENDM	CHECK_MASKS

	.SBTTL	FAL$DECODE_MSG - DECODE DAP MESSAGE
	.PSECT	FAL$CODE	NOSHR,EXE,RD,NOWRT,BYTE

;++
; Functional Description:
;
;	FAL$DECODE_MSG is responsible for parsing a DAP message into its
;	constituent fields, storing these field values into corresponding fields
;	in the DAP control block, and finally performing validity checks on the
;	contents of the converted fields to screen out invalid and unsupported
;	bit options or field values.
;
;	Each DAP message logically consists of two parts:
;	(1) a message header (called the operator field in DAP).
;	(2) a message body (called the operand field in DAP).
;	In addition, the message header may optionally contain a system
;	specific field for use by homogeneous systems which is treated as a
;	mini-message with discrete fields.
;
; Calling Sequence:
;
;	CALLS	#1,FAL$DECODE_MSG
;
; Input Parameters:
;
;	4(AP)	Address of DAP control block
;
; Implicit Inputs:
;
;	None
;
; Output Parameters:
;
;	R0	Status code
;	R1	Destroyed
;
; Implicit Outputs:
;
;	Various fields of the DAP control block are updated.
;
; Completion Codes:
;
;	DAP$L_DCODE_STS is returned in R0 where bit 0 indicates success/failure.
;
; Side Effects:
;
;	None
;
;--

	.ENTRY	FAL$DECODE_MSG,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
					; Entry point

;
; Perform initialization.
;

	MOVL	4(AP),R9		; Get address of DAP control block
	MOVL	#1,DAP$L_DCODE_STS(R9)	; Assume successful parse
	MOVQ	DAP$Q_MSG_BUF1(R9),R10	; R10 = size of message
					; R11 = address of start-of-message
	MOVQ	R10,DAP$Q_MSG_BUF2(R9)	; Store in result descriptor
	ADDL2	R11,R10			; R10 = address of end-of-message + 1
	$ZERO_FILL-			; Zero current message work area
		DST=DAP$L_CMWA(R9)-	;  in DAP control block
		SIZE=#DAP$K_CMWA	;
	CLRB	DAP$B_X_FLAGS(R9)	; Clear 'explicitly specified' flags

;+
; Note the current status of registers R8-R11:
;
;	R8	Currently undefined; later it will be used to contain the
;		address of the routine to execute on reaching end-of-message
;	R9	Address of DAP control block
;	R10	Address of end-of-message-buffer + 1; later it will contain
;		the address of end-of-message + 1
;	R11	Address of start-of-message; it will be continually updated
;		to contain the address of the next byte to parse
;-

	.SBTTL	HEADER - DECODE MESSAGE HEADER

;++
; Decode the header of the DAP message (operator portion of the message).
; Then dispatch on message type to parse the body of the DAP message (operand
; portion of the message).
;--

HEADER:					; Continuation of mainline

	ASSUME	DAP$K_CNF_MSG EQ 1
	ASSUME	DAP$K_ATT_MSG EQ 2
	ASSUME	DAP$K_ACC_MSG EQ 3
	ASSUME	DAP$K_CTL_MSG EQ 4
	ASSUME	DAP$K_CON_MSG EQ 5
	ASSUME	DAP$K_ACK_MSG EQ 6
	ASSUME	DAP$K_CMP_MSG EQ 7
	ASSUME	DAP$K_DAT_MSG EQ 8
	ASSUME	DAP$K_STS_MSG EQ 9
	ASSUME	DAP$K_KEY_MSG EQ 10
	ASSUME	DAP$K_ALL_MSG EQ 11
	ASSUME	DAP$K_SUM_MSG EQ 12
	ASSUME	DAP$K_TIM_MSG EQ 13
	ASSUME	DAP$K_PRO_MSG EQ 14
	ASSUME	DAP$K_NAM_MSG EQ 15

;
; For optional fields, apply default values as appropriate.
;

	MOVAQ	(R9),DAP$Q_SYSPEC+4(R9)	; Initialize descriptor

;
; Process the DAP message type field (required).
;

	MOVAB	W^ERROR_FORMAT,R8	; Specify transfer address on EOM
	STORE_FIELD	TYPE,1,K_FIX	; Save type field
	TSTB	(R6)			; Test for valid value
	BEQL	10$			; Branch if out-of-range
	CMPB	(R6),#DAP$K_NAM_MSG	; Test for valid value
	BGTRU	10$			; Branch if out-of-range
	MOVB	(R6),DAP$B_DCODE_MSG(R9); Return message type in status code
	BRB	20$			; Continue
10$:	BRW	ERROR_INVALID		; Branch aid

;+
; Process the DAP message flags field (required for most messages).
; This is a combination menu and bit option field whereby each bit set denotes
; that either an associated field is included in the message or a message
; option is specified.
;
; Note:	If no flags field is found (i.e., its a one-byte message), the
;	associated operand parse routine for the message will still be entered
;	(via DISPATCH_TABLE) to determine if the message is valid and to apply
;	operand field default values.
;-

	ASSUME	DAP$V_STREAMID+1 EQ DAP$V_LENGTH
	ASSUME	DAP$V_LENGTH+1 EQ DAP$V_LEN256
	ASSUME	DAP$V_LEN256+1 EQ DAP$V_BITCNT
	ASSUME	DAP$V_BITCNT+2 EQ DAP$V_SYSPEC
	ASSUME	DAP$V_SYSPEC+1 EQ DAP$V_SEGMENT

20$:	MOVAB	W^DISPATCH_TABLE,R8	; Specify transfer address on EOM
	STORE_FIELD	FLAGS,1,K_EXT	; Save flags field
	CHECK_MASKS	FLAGS,1		; Validate bit options
	MOVAB	W^ERROR_FORMAT,R8	; Specify transfer address on EOM
	MOVZBL	(R6),AP			; Copy menu to scratch register
HDR_LOOP:				;
	FFS	#0,#DAP$V_SEGMENT+1,AP,R0; Get position of next bit set
	$CLRBIT	R0,AP			; Clear menu bit just found
	PUSHAB	B^HDR_LOOP		; Push return address on stack
	$CASEB	SELECTOR=R0-		; Next field/option:
		DISPL=<-		;
		    10$-		;  STREAMID
		    20$-		;  LENGTH
		    30$-		;  LEN256
		    ERROR_UNSUPPORT-	;  BITCNT
		    ERROR_FORMAT-	;  Reserved
		    60$-		;  SYSPEC
		    ERROR_UNSUPPORT-	;  SEGMENT
		>			;
	BRB	DISPATCH_TABLE		; Message header syntax is correct

;
; Process each field/option specified in the menu (optional).
;

10$:	STORE_FIELD	STREAMID,1,K_FIX; Save data stream identification field
	TSTB	(R6)			; Currently, multi-streams are
					;  not supported, so check value
	BNEQ	HDR_UNSUPPORT		; Branch on error
	RSB				;
20$:	STORE_FIELD	LENGTH,1,K_FIX	; Save length field
	BBC	#DAP$V_LEN256,AP,35$	; Branch if length value in header is
					;  expressed in one byte (i.e., there
	RSB				;  is no LEN256 field present)
30$:	STORE_FIELD	LEN256,1,K_FIX	; Save length extension field

;
; Determine end-of-message based on operand length value in message header.
;

	ASSUME	DAP$B_LENGTH+1 EQ DAP$B_LEN256

35$:	MOVZWL	DAP$B_LENGTH(R9),R0	; Get operand length value
	ADDL3	R0,R11,R1		; Compute new end-of-message + 1 address
	CMPL	R1,R10			; Error if not enough bytes in buffer
	BGTRU	HDR_INVALID		;  to contain message
	MOVL	R1,R10			; Update end-of-message address
	RSB				;

;+
; Suggested code to support the BITCNT field is shown below.
;
;40$:	STORE_FIELD	BITCNT,1,K_FIX	; Save bit count field
;	CMPB	DAP$B_TYPE(R9),-	; BITCNT field allowed only in
;		#DAP$K_DAT_MSG		;  Data message
;	BNEQ	80$			; Branch on error
;	CMPB	(R6),#7			; Check for value in the range 0-7
;	BGTRU	HDR_INVALID		; Branch on error
;	RSB				;
;-

60$:	STORE_FIELD	SYSPEC,8,K_IMG,<M_DESC>
					; Save descriptor of system specific
					;  field
	CMPB	DAP$B_TYPE(R9),-	; SYSPEC field not allowed in
		#DAP$K_CNF_MSG		;  Configuration message
	BEQL	80$			; Branch on error
	BBC	#DAP$V_VAXVMS,(R9),80$	; SYSPEC field allowed only if
					;  systems are homogeneous
	RSB				;
80$:	JMP	(R8)			; Branch to error_format routine

;
; Branch here on exception condition.
;

HDR_INVALID:				;
	BRW	ERROR_INVALID		; Branch aid
HDR_UNSUPPORT:				;
	BRW	ERROR_UNSUPPORT		; Branch aid

	.SBTTL	DISPATCH_TABLE - CASE ON MESSAGE TYPE

;+
; The DAP messasge header has been successfully parsed. Now dispatch on message
; type to the appropriate code segment to process the body of the message.
;
; Note:	The case table entries below should match the DAP$K_VALID_R2F message
;	mask!
;-

DISPATCH_TABLE:				; Continuation of mainline
	MOVZBL	#DAP$_UNKNOWN,R7	; Set field ID to 'unknown'
	$CASEB	SELECTOR=DAP$B_TYPE(R9)-; Dispatch to message specific decode
		BASE=#DAP$K_CNF_MSG-	;  routine to process:
		DISPL=<-		;
		    CNF_MSG-		;  Configuration message
		    ATT_MSG-		;  Attributes message
		    ACC_MSG-		;  Access message
		    CTL_MSG-		;  Control message
		    CON_MSG-		;  Continue Transfer message
		    ERROR_SYNC-		;  Acknowledge message
		    CMP_MSG-		;  Access Complete message
		    DAT_MSG-		;  Data message
		    ERROR_SYNC-		;  Status message
		    KEY_MSG-		;  Key Definition message
		    ALL_MSG-		;  Allocation message
		    ERROR_SYNC-		;  Summary message
		    TIM_MSG-		;  Date and Time message
		    PRO_MSG-		;  Protection message
		    ERROR_SYNC-		;  Name message
		>			;

;
; The message type value has been validated (bounds checked), so the type value
; will not be outside the range of the case table above.
;

	.SBTTL	CNF_MSG - DECODE CONFIGURATION MESSAGE

;++
; Decode the operand fields of the Configuration message.
;--

CNF_MSG:				; Code segment of mainline
	MOVAB	W^ERROR_FORMAT,R8	; Specify transfer address on EOM

;
; Process the buffer size field (required).
;

	STORE_FIELD	BUFSIZ,2,K_FIX	; Save buffer size field

;
; Process system software and DAP protocol version number fields (required).
; These fields are for information purposes only; hence no bounds checking
; on their values is performed.
;

	STORE_FIELD	OSTYPE,1,K_FIX	; Save operating system type field
	STORE_FIELD	FILESYS,1,K_FIX	; Save file system type field
	STORE_FIELD	VERNUM,1,K_FIX	; Save DAP version # field
	STORE_FIELD	ECONUM,1,K_FIX	; Save ECO version # field
	STORE_FIELD	USRNUM,1,K_FIX	; Save user protocol version # field
	STORE_FIELD	SOFTVER,1,K_FIX	; Save DEC software release # field
	STORE_FIELD	USRSOFT,1,K_FIX	; Save user software release # field

;
; Process the system capabilities field (required).
; Bits set that are not defined in the DAP spec are ignored (not flagged as
; an error) to facilitate compatibility with earlier implementations of DAP.
;

	STORE_FIELD	SYSCAP,8,K_EXT,<M_TRUNC>
					; Save system capabilities field

;
; Set status flag if partner is running VAX/VMS.
;

	CMPB	DAP$B_OSTYPE(R9),-	; Branch if partner is not VAX/VMS
		#DAP$K_VAXVMS		;
	BNEQ	10$			;
	$SETBIT	#DAP$V_VAXVMS,(R9)	; Set flag

;
; Set status flag if partner implemented to DAP spec since V4.1.
;

10$:	MOVZBL	DAP$B_VERNUM(R9),R0	; Combine version number and ECO
	ASHL	#8,R0,R0		;  number fields into one 16-bit
	ADDB2	DAP$B_ECONUM(R9),R0	;  value
	CMPW	R0,#^X0401		; Did partner implement since DAP V4.1?
	BLSSU	20$			; Branch if not
	$SETBIT	#DAP$V_GEQ_V41,(R9)	; Set flag

;
; Set status flag if partner implemented to DAP spec since V4.2.
;

	CMPW	R0,#^X0402		; Did partner implement since DAP V4.2?
	BLSSU	20$			; Branch if not
	$SETBIT	#DAP$V_GEQ_V42,(R9)	; Set flag

;
; Set status flag if partner implemented to DAP spec since V5.2.
;

	CMPW	R0,#^X0502		; Did partner implement since DAP V5.2?
	BLSSU	20$			; Branch if not
	$SETBIT	#DAP$V_GEQ_V52,(R9)	; Set flag

;
; Set status flag if partner implemented to DAP spec since V5.4.
;

	CMPW	R0,#^X0504		; Did partner implement since DAP V5.4?
	BLSSU	20$			; Branch if not
	$SETBIT	#DAP$V_GEQ_V54,(R9)	; Set flag

;
; Set status flag if partner implemented to DAP spec since V5.6.
;

	CMPW	R0,#^X0506		; Did partner implement since DAP V5.6?
	BLSSU	20$			; Branch if not
	$SETBIT	#DAP$V_GEQ_V56,(R9)	; Set flag

;
; Set status flag if partner implemented to DAP spec since V6.0.
;

	CMPW	R0,#^X0600		; Did partner implement since DAP V6.0?
	BLSSU	20$			; Branch if not
	$SETBIT	#DAP$V_GEQ_V60,(R9)	; Set flag

;
; Set status flag pertaining to the type of file system used by the remote node.
;

	ASSUME	DAP$K_RMS11 EQ 1
	ASSUME	DAP$K_RMS20 EQ 2
	ASSUME	DAP$K_RMS32 EQ 3
	ASSUME	DAP$K_FCS11 EQ 4
	ASSUME	DAP$K_RT11FS EQ 5
	ASSUME	DAP$K_NO_FS EQ 6
	ASSUME	DAP$K_TOPS20FS EQ 7
	ASSUME	DAP$K_TOPS10FS EQ 8

20$:	$CASEB	SELECTOR=DAP$B_FILESYS(R9)-; Type of remote file system:
		BASE=#DAP$K_RMS11-	;
		DISPL=<-		;
		    40$-		;  RMS11
		    40$-		;  RMS20
		    40$-		;  RMS32
		    50$-		;  FCS11
		    30$-		;  RT11FS
		    60$-		;  NO_FS
		    30$-		;  TOPS20FS
		    30$-		;  TOPS10FS
		>			;
	BRB	60$			;
30$:	$SETBIT	#DAP$V_STM_ONLY,(R9)	; Set stream ASCII file system flag
	BRB	60$			;
40$:	$SETBIT	#DAP$V_RMS,(R9)		; Set RMS based file system flag
	BRB	60$			;
50$:	$SETBIT	#DAP$V_FCS,(R9)		; Set FCS based file system flag
60$:	BRW	EXIT_SUCCESS		; Message syntax is correct

	.SBTTL	ATT_MSG - DECODE ATTRIBUTES MESSAGE

;++
; Decode the operand fields of the Attributes message.
;--

ATT_MSG:				; Code segment of mainline

;
; For optional fields, apply default values as appropriate.
;

	MOVB	#DAP$K_DATATYP_D,DAP$B_DATATYPE(R9)
	MOVB	#DAP$K_ORG_D,DAP$B_ORG(R9)
	MOVB	#DAP$K_RFM_D,DAP$B_RFM(R9)
	MOVW	#DAP$K_BLS_D,DAP$W_BLS(R9)
	MOVB	#DAP$K_BSZ_D,DAP$B_BSZ(R9)
	MOVAQ	(R9),DAP$Q_RUNSYS+4(R9)	; Initialize descriptor

;
; Process the attributes menu field (optional).
; Each bit set denotes that its associated field follows in the message.
;

	ASSUME	DAP$V_DATATYPE+1 EQ DAP$V_ORG
	ASSUME	DAP$V_ORG+1 EQ DAP$V_RFM
	ASSUME	DAP$V_RFM+1 EQ DAP$V_RAT
	ASSUME	DAP$V_RAT+1 EQ DAP$V_BLS
	ASSUME	DAP$V_BLS+1 EQ DAP$V_MRS
	ASSUME	DAP$V_MRS+1 EQ DAP$V_ALQ1
	ASSUME	DAP$V_ALQ1+1 EQ DAP$V_BKS
	ASSUME	DAP$V_BKS+1 EQ DAP$V_FSZ
	ASSUME	DAP$V_FSZ+1 EQ DAP$V_MRN
	ASSUME	DAP$V_MRN+1 EQ DAP$V_RUNSYS
	ASSUME	DAP$V_RUNSYS+1 EQ DAP$V_DEQ1
	ASSUME	DAP$V_DEQ1+1 EQ DAP$V_FOP1
	ASSUME	DAP$V_FOP1+1 EQ DAP$V_BSZ
	ASSUME	DAP$V_BSZ+1 EQ DAP$V_DEV
	ASSUME 	DAP$V_DEV+2 EQ DAP$V_LRL
	ASSUME	DAP$V_LRL+1 EQ DAP$V_HBK
	ASSUME	DAP$V_HBK+1 EQ DAP$V_EBK
	ASSUME	DAP$V_EBK+1 EQ DAP$V_FFB
	ASSUME	DAP$V_FFB+1 EQ DAP$V_SBN

	MOVAB	W^EXIT_SUCCESS,R8	; All done if end-of-message
	STORE_FIELD	ATTMENU,4,K_EXT	; Save attributes menu field
	CHECK_MASKS	ATTMENU,4	; Validate bit options
	MOVAB	W^ERROR_FORMAT,R8	; Specify transfer address on EOM
	MOVL	(R6),AP			; Copy menu to scratch register
ATT_LOOP:				;
	FFS	#0,#DAP$V_SBN+1,AP,R0	; Get position of next bit set
	$CLRBIT	R0,AP			; Clear menu bit just found
	PUSHAB	B^ATT_LOOP		; Push return address on stack
	$CASEB	SELECTOR=R0-		; Next field:
		DISPL=<-		;
		    10$-		;  DATATYPE
		    20$-		;  ORG
		    30$-		;  RFM
		    40$-		;  RAT
		    50$-		;  BLS
		    60$-		;  MRS
		    70$-		;  ALQ1
		    80$-		;  BKS
		    90$-		;  FSZ
		    100$-		;  MRN
		    110$-		;  RUNSYS
		    120$-		;  DEQ1
		    130$-		;  FOP1
		    140$-		;  BSZ
		    150$-		;  DEV
		    ERROR_FORMAT-	;  Reserved
		    170$-		;  LRL
		    180$-		;  HBK
		    190$-		;  EBK
		    200$-		;  FFB
		    210$-		;  SBN
		>			;
	BRW	EXIT_SUCCESS		; Message syntax is correct

;
; Process each field specified in the menu (optional).
;

40$:	STORE_FIELD	RAT,1,K_EXT	; Save record attributes field
	CHECK_MASKS	RAT,1		; Validate bit options
	RSB				;
50$:	STORE_FIELD	BLS,2,K_FIX	; Save block size field
	RSB				;
60$:	STORE_FIELD	MRS,2,K_FIX	; Save maximum record size field
	RSB				;
70$:	STORE_FIELD	ALQ1,4,K_IMG	; Save allocation quantity field
	RSB				;
80$:	STORE_FIELD	BKS,1,K_FIX	; Save bucket size field
	RSB				;
90$:	STORE_FIELD	FSZ,1,K_FIX	; Save fixed control area size field
	RSB				;
100$:	STORE_FIELD	MRN,4,K_IMG	; Save maximum record number field
	RSB				;
110$:	STORE_FIELD	RUNSYS,8,K_IMG,<M_DESC>
					; Save descriptor of run-time
					;  system string
	RSB				;
120$:	STORE_FIELD	DEQ1,2,K_FIX	; Save default extension quantity field
	RSB				;
130$:	STORE_FIELD	FOP1,4,K_EXT	; Save file options field
	CHECK_MASKS	FOP,4		; Validate bit options
	RSB				;
10$:	STORE_FIELD	DATATYPE,1,K_EXT; Save data type field
	CHECK_MASKS	DATATYP,1	; Validate bit options
	RSB				;
20$:	STORE_FIELD	ORG,1,K_FIX	; Save file organization field

	ASSUME	DAP$K_SEQ EQ 0
	ASSUME	DAP$K_REL EQ 16
	ASSUME	DAP$K_IDX EQ 32

	TSTB	(R6)			; Check for valid value
	BEQL	25$			; Branch if ok
	CMPB	(R6),#DAP$K_REL		; Check for valid value
	BEQL	25$			; Branch if ok
	CMPB	(R6),#DAP$K_IDX		; Check for valid value
	BEQL	25$			; Branch if ok
	BRB	ATT_INVALID		; Branch on error
25$:	RSB				;
30$:	STORE_FIELD	RFM,1,K_FIX	; Save record format field

	ASSUME	DAP$K_UDF EQ 0
	ASSUME	DAP$K_FIX EQ 1
	ASSUME	DAP$K_VAR EQ 2
	ASSUME	DAP$K_VFC EQ 3
	ASSUME	DAP$K_STM EQ 4

	CMPB	(R6),#DAP$K_STM		; Check for valid value
	BGTRU	ATT_INVALID		; Branch if out-of-range
	RSB				;
140$:	STORE_FIELD	BSZ,1,K_FIX	; Save byte size field
	RSB				;
150$:	STORE_FIELD	DEV,4,K_EXT	; Save device characteristics field
	CHECK_MASKS	DEV,4		; Validate bit options
	RSB				;
170$:	STORE_FIELD	LRL,2,K_FIX	; Save longest record length field
	RSB				;
180$:	STORE_FIELD	HBK,4,K_IMG	; Save highest virtual block number
	RSB				;  field
190$:	STORE_FIELD	EBK,4,K_IMG	; Save end-of-file block number field
	RSB				;
200$:	STORE_FIELD	FFB,2,K_FIX	; Save first free byte in EOF block
	RSB				;  field
210$:	STORE_FIELD	SBN,4,K_IMG	; Save starting logical block number
	RSB				;  field

;
; Branch here on exception condition.
;

ATT_INVALID:				;
	BRW	ERROR_INVALID		; Branch aid

	.SBTTL	ACC_MSG - DECODE ACCESS MESSAGE

;++
; Decode the operand fields of the Access message.
;--

ACC_MSG:				; Code segment of mainline

;
; For optional fields, apply default values as appropriate.
;
; Note:	The default value for the DISPLAY field is applied after the ACCFUNC
;	field is processed.
;

	MOVB	#DAP$K_FAC_D,DAP$B_FAC(R9)
	MOVB	#DAP$K_SHR_D,DAP$B_SHR(R9)
	MOVAQ	(R9),DAP$Q_FILESPEC+4(R9) ; Initialize descriptor
	MOVAQ	(R9),DAP$Q_PASSWORD+4(R9) ; Initialize descriptor

;
; Process the access function field (required).
;

	MOVAB	W^ERROR_FORMAT,R8	; Specify transfer address on EOM
	STORE_FIELD	ACCFUNC,1,K_FIX	; Save access function field

	ASSUME	DAP$K_OPEN EQ 1
	ASSUME	DAP$K_CREATE EQ 2
	ASSUME	DAP$K_RENAME EQ 3
	ASSUME	DAP$K_ERASE EQ 4
	ASSUME	DAP$K_DIR_LIST EQ 6
	ASSUME	DAP$K_SUBMIT EQ 7
	ASSUME	DAP$K_EXECUTE EQ 8

	$CASEB	SELECTOR=(R6),-		; Check for valid value
		BASE=#DAP$K_OPEN-	;
		DISPL=<-		; Function:
		    10$-		;  $OPEN
		    10$-		;  $CREATE
		    ERROR_UNSUPPORT-	;  $RENAME
		    20$-		;  $ERASE
		    ERROR_INVALID-	;  Reserved
		    20$-		;  Directory list
		    10$-		;  Submit command file
		    20$-		;  Execute command file
		>			;
	BRW	ERROR_INVALID		; Value out-of-range
10$:	MOVW	#DAP$M_DSP_ATT,-	; Apply default DISPLAY value
		DAP$W_DISPLAY1(R9)	;  per ACCFUNC value

;
; Process the access options and filespec fields (required).
;

20$:	STORE_FIELD	ACCOPT,1,K_EXT	; Save access options field
	CHECK_MASKS	ACCOPT,1	; Validate bit options
	STORE_FIELD	FILESPEC,8,K_IMG,<M_DESC>
					; Save descriptor of file
					;  specification string
	CMPB	(R6),#128		; Check for string too long
	BGTRU	ACC_INVALID		; Branch on error

;
; Process the file access and file sharing fields (optional).
;

	MOVAB	W^EXIT_SUCCESS,R8	; All done if end-of-message
	STORE_FIELD	FAC,1,K_EXT	; Save file access field
	CHECK_MASKS	FAC,1		; Validate bit options
	STORE_FIELD	SHR,1,K_EXT	; Save file sharing field
	CHECK_MASKS	SHR,1		; Validate bit options

;
; Process the display and password fields (optional).
;

	STORE_FIELD	DISPLAY1,2,K_EXT; Save display attributes field
	CHECK_MASKS	DISPLAY,2	; Validate bit options
	STORE_FIELD	PASSWORD,8,K_IMG,<M_DESC>
					; Save descriptor of password string
	JMP	(R8)			; Message syntax is correct

;
; Branch here on exception condition.
;

ACC_INVALID:				;
	BRW	ERROR_INVALID		; Branch aid

	.SBTTL	CTL_MSG - DECODE CONTROL MESSAGE

;++
; Decode the operand fields of the Control message.
;--

CTL_MSG:				; Code segment of mainline

;
; For optional fields, apply default values as appropriate.
;

	MOVAQ	(R9),DAP$Q_KEY+4(R9)	; Initialize descriptor

;
; Process the control function field (required).
;

	MOVAB	W^ERROR_FORMAT,R8	; Specify transfer address on EOM
	STORE_FIELD	CTLFUNC,1,K_FIX	; Save control function field

	ASSUME	DAP$K_GET_READ EQ 1
	ASSUME	DAP$K_CONNECT EQ 2
	ASSUME	DAP$K_UPDATE EQ 3
	ASSUME	DAP$K_PUT_WRITE EQ 4
	ASSUME	DAP$K_DELETE EQ 5
	ASSUME	DAP$K_REWIND EQ 6
	ASSUME	DAP$K_TRUNCATE EQ 7
	ASSUME	DAP$K_RELEASE EQ 9
	ASSUME	DAP$K_FREE EQ 10
	ASSUME	DAP$K_EXTEND_B EQ 11
	ASSUME	DAP$K_FLUSH EQ 12
	ASSUME	DAP$K_FIND EQ 14
	ASSUME	DAP$K_EXTEND_E EQ 15
	ASSUME	DAP$K_DISPLAY EQ 16
	ASSUME	DAP$K_SPACE_FW EQ 17
	ASSUME	DAP$K_SPACE_BW EQ 18

	$CASEB	SELECTOR=(R6)-		; Check for valid value
		BASE=#DAP$K_GET_READ-	;
		DISPL=<-		; Function:
		    10$-		;  $GET or $READ
		    10$-		;  $CONNECT
		    10$-		;  $UPDATE
		    10$-		;  $PUT or $WRITE
		    10$-		;  $DELETE
		    10$-		;  $REWIND
		    10$-		;  $TRUNCATE
		    ERROR_INVALID-	;  Reserved for $MODIFY
		    10$-		;  $RELEASE
		    10$-		;  $FREE
		    10$-		;  $EXTEND (beginning message of seq)
		    10$-		;  $FLUSH
		    ERROR_UNSUPPORT-	;  Reserved for $NXTVOL--was defined
		    10$-		;  $FIND
		    10$-		;  $EXTEND (ending message of seq)
		    10$-		;  $DISPLAY
		    10$-		;  $SPACE (forward)
		    10$-		;  $SPACE (backward)
	>				;  Reserved for checkpoint-file function
					;  Reserved for recovery-get function
					;  Reserved for recovery-put function
	BRW	ERROR_INVALID		; Value is out-of-range

;
; Process the control menu field (optional).
; Each bit set denotes that its associated field follows in the message.
;

	ASSUME	DAP$V_RAC+1 EQ DAP$V_KEY
	ASSUME	DAP$V_KEY+1 EQ DAP$V_KRF
	ASSUME	DAP$V_KRF+1 EQ DAP$V_ROP
	ASSUME	DAP$V_ROP+2 EQ DAP$V_DISPLAY2

10$:	MOVAB	W^EXIT_SUCCESS,R8	; All done if end-of-message
	STORE_FIELD	CTLMENU,2,K_EXT	; Save control menu field
	CHECK_MASKS	CTLMENU,2	; Validate bit options
	MOVAB	W^ERROR_FORMAT,R8	; Specify transfer address on EOM
	MOVZWL	(R6),AP			; Copy menu to scratch register
CTL_LOOP:				;
	FFS	#0,#DAP$V_DISPLAY2+1,AP,R0 ; Get position of next bit set
	$CLRBIT	R0,AP			; Clear menu bit just found
	PUSHAB	B^CTL_LOOP		; Push return address on stack
	$CASEB	SELECTOR=R0-		; Next field:
		DISPL=<-		;
		    10$-		;  RAC
		    20$-		;  KEY
		    30$-		;  KRF
		    40$-		;  ROP
		    ERROR_FORMAT-	;  Reserved
		    60$-		;  DISPLAY2
		>			;
	BRW	EXIT_SUCCESS		; Message syntax is correct

;
; Process the fields specified in the menu (optional).
;

10$:	STORE_FIELD	RAC,1,K_FIX	; Save record access field

	ASSUME	DAP$K_SEQ_ACC EQ 0
	ASSUME	DAP$K_KEY_ACC EQ 1
	ASSUME	DAP$K_RFA_ACC EQ 2
	ASSUME	DAP$K_SEQ_FILE EQ 3
	ASSUME	DAP$K_BLK_VBN EQ 4
	ASSUME	DAP$K_BLK_FILE EQ 5

	CMPB	(R6),#DAP$K_BLK_FILE	; Check for value too high
	BGTRU	CTL_INVALID		; Branch on error
	RSB				;
20$:	STORE_FIELD	KEY,8,K_IMG,<M_DESC>
					; Save descriptor of key string
	RSB				;
30$:	STORE_FIELD	KRF,1,K_FIX	; Save key of reference field
	RSB				;
40$:	STORE_FIELD	ROP,4,K_EXT	; Save record options field
	CHECK_MASKS	ROP,4		; Validate bit options
	RSB				;
60$:	STORE_FIELD	DISPLAY2,2,K_EXT; Save display attributes field
	CHECK_MASKS	DISPLAY,2	; Validate bit options
	RSB				;

;
; Branch here on exception condition.
;

CTL_INVALID:				;
	BRW	ERROR_INVALID		; Branch aid

	.SBTTL	CON_MSG - DECODE CONTINUE TRANSFER MESSAGE

;++
; Decode the operand fields of the Continue Transfer message.
;--

CON_MSG:				; Code segment of mainline

;
; Process the continue transfer function field (required).
;

	MOVAB	W^ERROR_FORMAT,R8	; Specify transfer address on EOM
	STORE_FIELD	CONFUNC,1,K_FIX	; Save continue transfer function field

	ASSUME	DAP$K_RETRY EQ 1
	ASSUME	DAP$K_SKIP_REC EQ 2
	ASSUME	DAP$K_ABORT EQ 3
	ASSUME	DAP$K_RESUME EQ 4

	TSTB	(R6)			; Branch if value is
	BEQL	CON_INVALID		;  too low
	CMPB	(R6),#DAP$K_RESUME	;  or
	BGTRU	CON_INVALID		;  too high
	BRW	EXIT_SUCCESS		; Message syntax is correct

;
; Branch here on exception condition.
;

CON_INVALID:				;
	BRW	ERROR_INVALID		; Branch aid

	.SBTTL	CMP_MSG - DECODE ACCESS COMPLETE MESSAGE

;++
; Decode the operand fields of the Access Complete message.
;--

CMP_MSG:				; Code segment of mainline

;
; For optional fields, apply default values as appropriate.
;

;	<there are no defaults to apply>

;
; Process the access complete function field (required).
;

	MOVAB	W^ERROR_FORMAT,R8	; Specify transfer address on EOM
	STORE_FIELD	CMPFUNC,1,K_FIX	; Save access complete function field

	ASSUME	DAP$K_CLOSE EQ 1
	ASSUME	DAP$K_RESPONSE EQ 2
	ASSUME	DAP$K_RESET EQ 3
	ASSUME	DAP$K_DISCONN EQ 4
	ASSUME	DAP$K_SKIP_FILE EQ 5
	ASSUME	DAP$K_CHANGE_B EQ 6
	ASSUME	DAP$K_CHANGE_E EQ 7
	ASSUME	DAP$K_TERMINATE EQ 8

	TSTB	(R6)			; Branch if value is
	BEQL	CMP_INVALID		;  too low
	CMPB	(R6),#DAP$K_TERMINATE	;  or
	BGTRU	CMP_INVALID		;  too high

;
; Process the file options field (optional).
;

	MOVAB	W^EXIT_SUCCESS,R8	; All done if end-of-message
	STORE_FIELD	FOP2,4,K_EXT	; Save file options field
	CHECK_MASKS	FOP,4		; Validate bit options

;
; Process the CRC checksum field (optional).
;

	STORE_FIELD	CHECK,2,K_FIX	; Save CRC checksum field
	$SETBIT	#DAP$V_X_CHECK,(R9)	; Denote field explicitly specified
					;  (to distinguish between CRC value
					;  of zero and none specified)
	JMP	(R8)			; Message syntax is correct

;
; Branch here on exception condition.
;

CMP_INVALID:				;
	BRW	ERROR_INVALID		; Branch aid

	.SBTTL	DAT_MSG - DECODE DATA MESSAGE

;++
; Decode the operand fields of the Data message.
;--

DAT_MSG:				; Code segment of mainline

;
; For optional fields, apply default values as appropriate.
;

	MOVAQ	(R9),DAP$Q_FILEDATA+4(R9) ; Initialize descriptor

;
; Process the record number field (required).
;
; Note:	Since there is no menu for the Data message (an unfortunate oversight
;	in the DAP spec), this field must be present. However, it is necessary
;	to distinguish between receiving a null value and a zero value, so that
;	it can be determined whether the RECNUM field overrides the KEY field.
;	To solve this problem, the DAP spec states that a byte count of zero
;	for this image field means that no value has been specified. I.e.,
;	<byte0 = 0> means ignore field, whereas <byte0 = 1 and byte1 = 0> means
;	a value of zero overrides the KEY field value.
;

	MOVAB	W^ERROR_FORMAT,R8	; Specify transfer address on EOM
	ADDL3	#1,R11,AP		; Mark address of next byte + 1
	STORE_FIELD	RECNUM1,4,K_IMG	; Save record number field
	CMPL	R11,AP			; Branch if this image field was
	BEQLU	10$			;  exactly one byte long
	$SETBIT	#DAP$V_X_RECNUM,(R9)	; Denote field explicitly specified

;
; Process the file data field (optional for zero length record).
;

10$:	MOVAB	W^EXIT_SUCCESS,R8	; All done if end-of-message
	STORE_FIELD	FILEDATA,8,K_ROM,<M_DESC>
					; Save descriptor of user data string
					;  (the record/block just received)
	JMP	(R8)			; Message syntax is correct

	.SBTTL	KEY_MSG - DECODE KEY DEFINITION MESSAGE

;++
; Decode the operand fields of the Key Definition message.
;--

KEY_MSG:				; Code segment of mainline

;
; For optional fields, apply default values as appropriate.
;

	MOVAQ	(R9),DAP$Q_KNM+4(R9)	; Initialize descriptor

;
; Process the key menu field (optional).
; Each bit set denotes that its associated field follows in the message.
;

	ASSUME	DAP$V_FLG+1 EQ DAP$V_DFL
	ASSUME	DAP$V_DFL+1 EQ DAP$V_IFL
	ASSUME	DAP$V_IFL+1 EQ DAP$V_NSG
	ASSUME	DAP$V_NSG+1 EQ DAP$V_REF
	ASSUME	DAP$V_REF+1 EQ DAP$V_KNM
	ASSUME	DAP$V_KNM+1 EQ DAP$V_NUL
	ASSUME	DAP$V_NUL+1 EQ DAP$V_IAN
	ASSUME	DAP$V_IAN+1 EQ DAP$V_LAN
	ASSUME	DAP$V_LAN+1 EQ DAP$V_DAN
	ASSUME	DAP$V_DAN+1 EQ DAP$V_DTP
	ASSUME	DAP$V_DTP+1 EQ DAP$V_RVB
	ASSUME	DAP$V_RVB+2 EQ DAP$V_DVB
	ASSUME	DAP$V_DVB+1 EQ DAP$V_DBS
	ASSUME	DAP$V_DBS+1 EQ DAP$V_IBS
	ASSUME	DAP$V_IBS+1 EQ DAP$V_LVL
	ASSUME	DAP$V_LVL+1 EQ DAP$V_TKS
	ASSUME	DAP$V_TKS+1 EQ DAP$V_MRL

	MOVAB	W^EXIT_SUCCESS,R8	; All done if end-of-message
	STORE_FIELD	KEYMENU,4,K_EXT	; Save key definition menu field
	CHECK_MASKS	KEYMENU,4	; Validate bit options
	MOVAB	W^ERROR_FORMAT,R8	; Specify transfer address on EOM
	MOVL	(R6),AP			; Copy menu to scratch register
KEY_LOOP:				;
	FFS	#0,#DAP$V_MRL+1,AP,R0	; Get position of next bit set
	$CLRBIT	R0,AP			; Clear menu bit just found
	PUSHAB	B^KEY_LOOP		; Push return address on stack
	$CASEB	SELECTOR=R0-		; Next field:
		DISPL=<-		;
		    10$-		;  FLG
		    20$-		;  DFL
		    30$-		;  IFL
		    40$-		;  NSG, POS, SIZ
		    50$-		;  REF
		    60$-		;  KNM
		    70$-		;  NUL
		    80$-		;  IAN
		    90$-		;  LAN
		    100$-		;  DAN
		    110$-		;  DTP
		    120$-		;  RVB
		    ERROR_FORMAT-	;  Reserved
		    140$-		;  DVB
		    150$-		;  DBS
		    160$-		;  IBS
		    170$-		;  LVL
		    180$-		;  TKS
		    190$-		;  MRL
	>				;
	BRW	EXIT_SUCCESS		; Message syntax is correct

;
; Process each field specified in the menu (optional).
;

10$:	STORE_FIELD	FLG,1,K_EXT	; Save key options field
	CHECK_MASKS	FLG,1		; Validate bit options
	RSB				;
20$:	STORE_FIELD	DFL,2,K_FIX	; Save data bucket fill quantity field
	RSB				;
30$:	STORE_FIELD	IFL,2,K_FIX	; Save index bucket fill quantity field
	RSB				;
40$:	STORE_FIELD	NSG,1,K_FIX	; Save number of key segments field
	MOVZBL	(R6),R2			; Use number of segments as loop count
	BEQL	47$			; Branch if zero
	CMPL	R2,#8			; Check for value too high
	BGTRU	49$			; Branch on error
	MOVAW	DAP$W_POS(R9),R0	; Get address of POS array
	MOVAB	DAP$B_SIZ(R9),R1	; Get address of SIZ array
45$:	PUSHR	#^M<R0,R1,R2>		;
	STORE_FIELD	POS_TMP,2,K_FIX	; Find next key segment size field
	POPR	#^M<R0>			;
	MOVW	(R6),(R0)+		; Save it in array
	PUSHR	#^M<R0>			;
	STORE_FIELD	SIZ_TMP,1,K_FIX	; Find next key segment size field
	POPR	#^M<R0,R1,R2>		;
	MOVB	(R6),(R1)+		; Save it in array
	SOBGTR	R2,45$			; Branch if more segments to go
47$:	RSB				;
49$:	BRB	KEY_INVALID		; Branch aid
50$:	STORE_FIELD	REF,1,K_FIX	; Save key of reference field
	RSB				;
60$:	STORE_FIELD	KNM,8,K_IMG,<M_DESC>
					; Save descriptor of key name string
	CMPB	(R6),#40		; Check for string too long
	BGTRU	KEY_INVALID		; Branch on error
	CMPB	(R6),#32		; Check for string too long
	BGTRU	KEY_INVALID		; Branch on error
	RSB				;
70$:	STORE_FIELD	NUL,1,K_FIX	; Save null key character field
	RSB				;
80$:	STORE_FIELD	IAN,1,K_FIX	; Save index area number field
	RSB				;
90$:	STORE_FIELD	LAN,1,K_FIX	; Save lowest level index area number
					;  field
	RSB				;
100$:	STORE_FIELD	DAN,1,K_FIX	; Save data area number field
	RSB				;
110$:	STORE_FIELD	DTP,1,K_FIX	; Save key data type field

	ASSUME	DAP$K_STG EQ 0
	ASSUME	DAP$K_IN2 EQ 1
	ASSUME	DAP$K_BN2 EQ 2
	ASSUME	DAP$K_IN4 EQ 3
	ASSUME	DAP$K_BN4 EQ 4
	ASSUME	DAP$K_PAC EQ 5

	CMPB	(R6),#DAP$K_PAC		; Check for value too high
	BGTRU	KEY_INVALID		; Branch on error
	RSB				;
120$:	STORE_FIELD	RVB,4,K_IMG	; Save root bucket start VBN field
	RSB				;
140$:	STORE_FIELD	DVB,4,K_IMG	; Save first data bucket start VBN field
	RSB				;
150$:	STORE_FIELD	DBS,1,K_FIX	; Save data bucket fill size field
	RSB				;
160$:	STORE_FIELD	IBS,1,K_FIX	; Save index bucket fill size field
	RSB				;
170$:	STORE_FIELD	LVL,1,K_FIX	; Save level of root buckets field
	RSB				;
180$:	STORE_FIELD	TKS,1,K_FIX	; Save total key size field
	RSB				;
190$:	STORE_FIELD	MRL,2,K_FIX	; Save minimum record length to contain
	RSB				;  key field

;
; Branch here on exception condition.
;

KEY_INVALID:				;
	BRW	ERROR_INVALID		; Branch aid

	.SBTTL	ALL_MSG - DECODE ALLOCATION MESSAGE

;++
; Decode the operand fields of the Allocation message.
;--

ALL_MSG:				; Code segment of mainline

;
; For optional fields, apply default values as appropriate.
;

;	<there are no defaults to apply>

;
; Process the allocation menu field (optional).
; Each bit set denotes that its associated field follows in the message.
;

	ASSUME	DAP$V_VOL+1 EQ DAP$V_ALN
	ASSUME	DAP$V_ALN+1 EQ DAP$V_AOP
	ASSUME	DAP$V_AOP+1 EQ DAP$V_LOC
	ASSUME	DAP$V_LOC+2 EQ DAP$V_ALQ2
	ASSUME	DAP$V_ALQ2+1 EQ DAP$V_AID
	ASSUME	DAP$V_AID+1 EQ DAP$V_BKZ
	ASSUME	DAP$V_BKZ+1 EQ DAP$V_DEQ2

	MOVAB	W^EXIT_SUCCESS,R8	; All done if end-of-message
	STORE_FIELD	ALLMENU,2,K_EXT	; Save allocation menu field
	CHECK_MASKS	ALLMENU,2	; Validate bit options
	MOVAB	W^ERROR_FORMAT,R8	; Specify transfer address on EOM
	MOVZWL	(R6),AP			; Copy menu to scratch register
ALL_LOOP:				;
	FFS	#0,#DAP$V_DEQ2+1,AP,R0	; Get position of next bit set
	$CLRBIT	R0,AP			; Clear menu bit just found
	PUSHAB	B^ALL_LOOP		; Push return address on stack
	$CASEB	SELECTOR=R0-		; Next field:
		DISPL=<-		;
		    10$-		;  VOL
		    20$-		;  ALN
		    30$-		;  AOP
		    40$-		;  LOC
		    ERROR_FORMAT-	;  Reserved
		    60$-		;  ALQ2
		    70$-		;  AID
		    80$-		;  BKZ
		    90$-		;  DEQ2
		>			;
	BRW	EXIT_SUCCESS		; Message syntax is correct

;
; Process each field specified in the menu (optional).
;

10$:	STORE_FIELD	VOL,2,K_FIX	; Save volume number field
	RSB				;

	ASSUME	DAP$K_ANY EQ 0
	ASSUME	DAP$K_CYL EQ 1
	ASSUME	DAP$K_LBN EQ 2
	ASSUME	DAP$K_VBN EQ 3
	ASSUME	DAP$K_RFI EQ 4

20$:	STORE_FIELD	ALN,1,K_FIX	; Save alignment options field
	CMPB	(R6),#DAP$K_VBN		; Check for value too high
	BGTRU	ALL_INVALID		; Branch on error
	RSB				;
30$:	STORE_FIELD	AOP,1,K_EXT	; Save allocation options field
	CHECK_MASKS	AOP,1		; Validate bit options
	RSB				;
40$:	STORE_FIELD	LOC,4,K_IMG	; Save starting location field
	RSB				;
60$:	STORE_FIELD	ALQ2,4,K_IMG	; Save allocation quantity field
	RSB				;
70$:	STORE_FIELD	AID,1,K_FIX	; Save area identification field
	RSB				;
80$:	STORE_FIELD	BKZ,1,K_FIX	; Save bucket size field
	RSB				;
90$:	STORE_FIELD	DEQ2,2,K_FIX	; Save default extension quantity field
	RSB				;

;
; Branch here on exception condition.
;

ALL_INVALID:				;
	BRW	ERROR_INVALID		; Branch aid

	.SBTTL	TIM_MSG - DECODE DATE AND TIME MESSAGE

;++
; Decode the operand fields of the Date and Time message.
;--

TIM_MSG:				; Code segment of mainline

;
; For optional fields, apply default values as appropriate.
;

;	<there are no defaults to apply>

;
; Process the date and time menu field (optional).
; Each bit set denotes that its associated field follows in the message.
;

	ASSUME	DAP$V_CDT+1 EQ DAP$V_RDT
	ASSUME	DAP$V_RDT+1 EQ DAP$V_EDT
	ASSUME	DAP$V_EDT+1 EQ DAP$V_RVN
	ASSUME	DAP$V_RVN+1 EQ DAP$V_BDT
	ASSUME	DAP$V_BDT+1 EQ DAP$V_PDT
	ASSUME	DAP$V_PDT+1 EQ DAP$V_ADT

	MOVAB	W^EXIT_SUCCESS,R8	; All done if end-of-message
	STORE_FIELD	TIMENU,2,K_EXT	; Save date and time menu field
	CHECK_MASKS	TIMENU,2	; Validate bit options
	MOVAB	W^ERROR_FORMAT,R8	; Specify transfer address on EOM
	MOVZWL	(R6),AP			; Copy menu to scratch register
TIM_LOOP:				;
	MOVL	#18,R3			; Declare size of time (CDT, RDT, etc.)
					;  fields containing ASCII strings
	FFS	#0,#DAP$V_ADT+1,AP,R0	; Get position of next bit set
	$CLRBIT	R0,AP			; Clear menu bit just found
	PUSHAB	B^TIM_LOOP		; Push return address on stack
	$CASEB	SELECTOR=R0-		; Next field:
		DISPL=<-		;
		    10$-		;  CDT
		    20$-		;  RDT
		    30$-		;  EDT
		    40$-		;  RVN
		    50$-		;  BDT
		    60$-		;  PDT
		    70$-		;  ADT
		>			;
	BRW	EXIT_SUCCESS		; Message syntax is correct

;
; Process each field specified in the menu (optional).
;

10$:	STORE_FIELD	CDT,8,K_FIX,<M_SRCR3!M_DESC>
					; Save descriptor of creation
					;  date and time string
	BRB	100$			;
20$:	STORE_FIELD	RDT,8,K_FIX,<M_SRCR3!M_DESC>
					; Save descriptor of revision
					;  date and time string
	BRB	100$			;
30$:	STORE_FIELD	EDT,8,K_FIX,<M_SRCR3!M_DESC>
					; Save descriptor of expiration
					;  date and time string
	BRB	100$			;
40$:	STORE_FIELD	RVN,2,K_FIX	; Save revision number field
	RSB				;
50$:	STORE_FIELD	BDT,8,K_FIX,<M_SRCR3!M_DESC>
					; Save descriptor of backup
					;  date and time string
	BRB	100$			;
60$:	STORE_FIELD	PDT,8,K_FIX,<M_SRCR3!M_DESC>
					; Save descriptor of physical creation
					;  date and time string
	BRB	100$			;
70$:	STORE_FIELD	ADT,8,K_FIX,<M_SRCR3!M_DESC>
					; Save descriptor of accessed
					;  date and time string
	BRB	100$			;

;+
; This sequence converts an ASCII time string into a 64-bit VMS binary time
; value. Note that the 64-bit result is stored in the quadword descriptor
; pointing to the time string on input.
;
; DAP defines network standard time as an 18 byte counted ASCII string in the
; format "dd-mmm-yybhh:mm:ss", whereas VMS uses a 23-byte ASCII string in the
; format "dd-mmm-yyyybhh:mm:ss.cc".
;-

100$:	SUBL2	#<24+8>,SP		; Allocate space from stack
	MOVL	#<18+2+3>,24(SP)	; Form descriptor of buffer to receive
	MOVL	SP,28(SP)		;  altered ASCII string
	MOVC3	#7,@4(R6),(SP)		; Copy bytes 1-7 of input string
	CMPB	(R1),#^A\6\		; Compare decade against base decade
	BGTRU	110$			; Branch if '70 - '99
					; Else it's '00 - '69
	MOVW	#^A\20\,(R3)+		; Insert missing century digits
	BRB	120$			; Continue
110$:	MOVW	#^A\19\,(R3)+		; Insert missing century digits
120$:	MOVC3	#11,(R1),(R3)		; Copy bytes 8-18 of input string
	MOVL	#^A\.00 \,(R3)+		; Add hundredths of second digits
					; Note R3 now points to time descriptor
	BICB2	#^X20,3(SP)		; Upcase 3-digit month string
	BICB2	#^X20,4(SP)		;  because $BINTIM objects to
	BICB2	#^X20,5(SP)		;  lowercase month
	$BINTIM_S-			; Convert ASCII time to binary time
		TIMBUF=(R3)-		;  Address of descriptor of ASCII string
		TIMADR=(R6)		;  Address of 64-bit result value
	ADDL2	#<24+8>,SP		; Deallocate space from the stack
	BLBC	R0,TIM_INVALID		; Branch on conversion error
	RSB				; Exit

;
; Branch here on exception condition.
;

TIM_INVALID:				;
	BRW	ERROR_INVALID		; Branch aid

	.SBTTL	PRO_MSG - DECODE PROTECTION MESSAGE

;++
; Decode the operand fields of the Protection message.
;--

PRO_MSG:				; Code segment of mainline

;
; For optional fields, apply default values as appropriate.
;

	MOVAQ	(R9),DAP$Q_OWNER+4(R9)	; Initialize descriptor

;
; Process the protection menu field (optional).
; Each bit set denotes that its associated field follows in the message.
;

	ASSUME	DAP$V_OWNER+1 EQ DAP$V_PROSYS
	ASSUME	DAP$V_PROSYS+1 EQ DAP$V_PROOWN
	ASSUME	DAP$V_PROOWN+1 EQ DAP$V_PROGRP
	ASSUME	DAP$V_PROGRP+1 EQ DAP$V_PROWLD

	MOVAB	W^EXIT_SUCCESS,R8	; All done if end-of-message
	STORE_FIELD	PROMENU,2,K_EXT	; Save proection menu field
	CHECK_MASKS	PROMENU,2	; Validate bit options
	MOVAB	W^ERROR_FORMAT,R8	; Specify transfer address on EOM
	MOVZWL	(R6),AP			; Copy menu to scratch register
PRO_LOOP:				;
	FFS	#0,#DAP$V_PROWLD+1,AP,R0; Get position of next bit set
	$CLRBIT	R0,AP			; Clear menu bit just found
	PUSHAB	B^PRO_LOOP		; Push return address on stack
	$CASEB	SELECTOR=R0-		; Next field:
		DISPL=<-		;
		    10$-		;  OWNER
		    20$-		;  PROSYS
		    30$-		;  PROOWN
		    40$-		;  PROGRP
		    50$-		;  PROWLD
		>			;
	BRW	EXIT_SUCCESS		; Message syntax is correct

;
; Process each field specified in the menu (optional).
;

10$:	STORE_FIELD	OWNER,8,K_IMG,<M_DESC>
					; Save descriptor of file owner string
	CMPB	(R6),#40		; Declare an error if owner string
	BGTRU	PRO_INVALID		;  is too long
	RSB				;
20$:	STORE_FIELD	PROSYS,2,K_EXT	; Save system protection field
	BRB	100$			;
30$:	STORE_FIELD	PROOWN,2,K_EXT	; Save owner protection field
	BRB	100$			;
40$:	STORE_FIELD	PROGRP,2,K_EXT	; Save group protection field
	BRB	100$			;
50$:	STORE_FIELD	PROWLD,2,K_EXT	; Save world protection field

;
; Perform common validity checks on data in the protection field being
; processed.
;

100$:	CHECK_MASKS	PROTECT,2	; Validate bit options
	RSB				;

;
; Branch here on exception condition.
;

PRO_INVALID:				;
	BRW	ERROR_INVALID		; Branch aid

	.SBTTL	STORE_FIELD - STORE NEXT FIELD ROUTINES

;++
; Functional Description:
;
;	STORE_FIELD invoked from the STORE_FIELD macro results in the execution
;	of one of the following routines:
;
;	STORE_EXT interprets the next field of the DAP message as an
;	extensible field of 1 to 16 bytes and stores the data portion of
;	the field in the designated field of the DAP control block.
;
;	STORE_FIX interprets the next field of the DAP message as a
;	fixed length field of 1 to 255 bytes and stores the string in the
;	designated field of the DAP control block.
;
;	STORE_IMG interprets the next field of the DAP message as an
;	image field of 1 to 256 bytes and stores the data portion of the
;	field in the designated field of the DAP control block.
;
;	STORE_ROM interprets the next field of the DAP message as a
;	binary field of 1 to 65535 bytes consisting of the rest of the
;	message and stores the string in the designated field of the DAP
;	control block.
;
; Calling Sequence:
;
;	BSBW	STORE_FIELD
;
; Input Parameters:
;
;	R3	Size in bytes of source field iff V_SRCR3 set and field is in
;		fixed length format
;	R8	Address of routine to execute if end-of-message encountered
;	R9	Address of DAP control block
;	R10	Address of last byte + 1 of DAP message being parsed
;	R11	Address of next byte of DAP message being parsed
;
;	In-line coded arguments:
;
;	Byte0	Size in bytes of the destination field in DAP control block
;	Byte1	Offset of destination field in DAP control block
;	Byte2	DAP field identifier (used to build DAP status code on error)
;	Byte3	Control byte to direct processing of DAP field:
;		Bits 0-3:		; Format of source field:
;			K_EXT=	^X00	;  Extensible field format
;			K_FIX=	^X01	;  Fixed length field format
;			K_IMG=	^X02	;  Image field format
;			K_ROM=	^X03	;  Rest-of-message field format
;		Bits 4-7:		; Field processing flags:
;			M_DESC=	^X10	;  Store only descriptor of SRC field
;			M_TRUNC=^X20	;  Truncate extra bytes if SRC field
;					;  size is larger than DST field size
;			M_SRCR3=^X40	;  Size of SRC field is in R3
;					;  (applicable only if K_FIX specified)
;
; Implicit Inputs:
;
;	None
;
; Output Parameters:
;
;	R0-R5	Destroyed
;	R6	Address of destination field in DAP control block
;	R7	Field ID value
;	R8-R10	Unchanged
;	R11	Updated next byte pointer
;
; Implicit Outputs:
;
;	The specified field of the DAP control block is updated.
;
; Completion Codes:
;
;	None
;
; Side Effects:
;
;	If end-of-message is encountered, control is given to the specified
;	action routine.
;
;	If a parse error is detected, control is given to an appropriate
;	error routine.
;
;	An exception exit described above, leaves the return address on the
;	stack.
;
;--

STORE_FIELD:				; Entry point

;
; Obtain the in-line coded arguments, check for end-of-message, and transfer
; control to the appropriate routine.
;

	MOVL	(SP),R0			; Get address of in-line arguments
	MOVZBL	(R0)+,R5		; Get DST field size
	MOVZBL	(R0)+,R6		; Get DST field offset
	ADDL2	R9,R6			; Compute DST field address
	MOVZBL	(R0)+,R7		; Get DAP field ID value
	MOVZBL	(R0)+,R2		; Get control byte value
	MOVL	R0,(SP)			; Bump return address past argument list
	CMPL	R11,R10			; Is there at least one byte left?
	BGEQ	10$			; Branch if end-of-message
	EXTZV	#0,#4,R2,R1		; Get index of routine
	$CASEB	SELECTOR=R1-		; Dispatch on field format:
		DISPL=<-		;
		    STORE_EXT-		;  Extensible
		    STORE_FIX-		;  Fixed length
		    STORE_IMG-		;  Image
		    STORE_ROM-		;  Rest-of-message
		>			;
10$:	JMP	(R8)			; Jump to designated EOM routine

	.SBTTL	STORE_EXT - STORE EXTENSIBLE FIELD

;++
; This routine interprets the next field of the DAP message as an extensible
; field of 1 to 16 bytes where bit7 of each byte determines whether to
; continue (1) the field to the next byte or to terminate (0) the field.
; First, the source field is compressed in a work area (i.e., bit7 of each byte
; is discarded and the remaining bits are squeezed together). Then, the
; compressed string is copied to the specified destination field in the DAP
; control block.
;--

	ASSUME	DAP$K_TEMP GE 16

STORE_EXT:				; Code segment of STORE_FIELD
	MOVAB	DAP$L_TEMP(R9),R4	; Get address of scratch work area
	CLRL	R0			; Initialize bit position index
	CLRL	R3			; Initialize byte count
10$:	CMPL	R11,R10			; Error if end-of-message is reached
	BGEQ	ERROR_FORMAT		;  before end-of-field is reached
	INCL	R3			; Increment byte count
	CMPL	R3,#16			; Branch if SRC field is longer than
	BGTRU	ERROR_FORMAT		;  scratch work area
	INSV	(R11),R0,#7,(R4)	; Copy lower 7 bits of next byte
	ADDL2	#7,R0			; Update bit position index
	BBS	#7,(R11)+,10$		; Loop if field extends to next byte
	INSV	#0,R0,R3,(R4)		; Zero fill rest of SRC field
					;  (1 bit for each byte compressed)
	BRB	MOVE_FIELD		; Copy string to DST field

	.SBTTL	STORE_FIX - STORE FIXED LENGTH FIELD

;++
; This routine interprets the next field of the DAP message as a fixed length
; field of 1 to 255 bytes and copies the string to the specified field in the
; DAP control block.
;--

STORE_FIX:				; Code segment of STORE_FIELD
	BBS	#V_SRCR3,R2,10$		; Branch if SRC field size is in r3
	MOVL	R5,R3			; DST field size = SRC field size
10$:	CMPL	R3,#1			; Branch if field is longer than
	BGTRU	STORE_IMG1		;  one byte
	MOVB	(R11)+,(R6)		; Store field in DAP control block
	RSB				; Exit

	.SBTTL	STORE_IMG - STORE IMAGE FIELD

;++
; This routine interprets the next field of the DAP message as an image field
; of 1 to 256 bytes where the first byte contains a count of the number of
; data bytes to follow. The data portion of the field is copied to the
; specified field of the DAP control block.
;--

STORE_IMG:				; Code segment of STORE_FIELD
	MOVZBL	(R11)+,R3		; Get byte count of SRC field
STORE_IMG1:				;
	MOVL	R11,R4			; Copy address of data string
	ACBL	R10,R3,R11,MOVE_FIELD	; Ok if <R3+R11> LEQ <R10>
	BRB	ERROR_FORMAT		; Error if not enough bytes in
					;  message to contain field

	.SBTTL	STORE_ROM - STORE REST OF MESSAGE

;++
; This routine interprets the next field of the DAP message as a binary field
; of 1 to 65535 bytes consisting of the rest of the message. The string is
; copied to the specified field of the DAP control block.
;--

STORE_ROM:				; Code segment of STORE_FIELD
	SUBL3	R11,R10,R3		; Compute SRC field size
	MOVL	R11,R4			; Copy SRC field address
	MOVL	R10,R11			; Advance next byte pointer to EOM

;
; <R3,R4> contains descriptor of SRC field, and
; <R5,R6> contains descriptor of DST field.
;

MOVE_FIELD:				; Copy SRC field to DST field with
					;  zero fill
	BBS	#V_DESC,R2,DESCRIPTOR	; Branch if only descriptor desired
	MOVC5	R3,(R4),#0,R5,(R6)	; Move field to DAP control block
	BLEQU	20$			; Done if all SRC bytes are copied
					;  (i.e., SRC size LEQU DST size)
	MOVL	(SP),R2			; Get address of control flag
					;  parameter + 1 (i.e., return address)
	BBS	#V_TRUNC,-1(R2),20$	; Done if extra bytes are to be
					;  truncated; note:
					;  R0 = # unmoved bytes
					;  R1 = address of unmoved string
10$:	TSTB	(R1)+			; Error if any unmoved bytes are
	BNEQ	ERROR_UNSUPPORT		;  non-zero
	SOBGTR	R0,10$			; Continue until all extra bytes
					;  are checked
20$:	RSB				; Exit
DESCRIPTOR:				; DST field is a descriptor
	MOVQ	R3,(R6)			; Store only quadword descriptor
	RSB				;  of SRC field and exit

	.SBTTL	ERROR AND SUCCESS EXIT ROUTINES

;++
; Message parse has failed.
; Build DAP Status message and exit to caller.
;--

ERROR_FORMAT:				; Format of message in incorrect
	MOVB	#DAP$_FORMAT,-		; Return MACCODE value
		DAP$B_DCODE_MAC(R9)	;
	CMPL	DAP$Q_MSG_BUF2(R9),#1	; Check for one-byte message
	BNEQ	ERROR_COMMON		; Take common path if not
	MOVZBL	#DAP$_FLAGS,R7		; Change to flags field ID code
					;  because format error was caused
					;  by no flags field in message
	BRB	ERROR_COMMON		; Take common path
ERROR_INVALID:				; Field of message has invalid value
	MOVB	#DAP$_INVALID,-		; Return MACCODE value
		DAP$B_DCODE_MAC(R9)	;
	BRB	ERROR_COMMON		; Take common path
ERROR_SYNC:				; Message received is out-of-sequence
	MOVB	#DAP$_MSG_SYNC,-	; Return MACCODE value
		DAP$B_DCODE_MAC(R9)	;
	BRB	ERROR_COMMON		; Take common path
ERROR_UNSUPPORT:			; Field of message has unsupported value
	MOVB	#DAP$_UNSUPPORT,-	; Return MACCODE value
		DAP$B_DCODE_MAC(R9)	;
ERROR_COMMON:				; Common error exit sequence
	MOVB	R7,DAP$B_DCODE_FID(R9)	; Return ID of field in error
	CLRB	DAP$L_DCODE_STS(R9)	; Indicate failure
	BRB	EXIT_COMMON		; Join common exit code

;++
; Message parse has been successful so far, ...
; Make additional validity checks.
;--

EXIT_SUCCESS:				; Enter here on successful parse
	MOVZBL	#DAP$_UNKNOWN,R7	; Set field ID to 'unknown'
	CMPL	R11,R10			; Branch if there are any unparsed
	BNEQ	ERROR_FORMAT		;  bytes left in DAP message
	MOVZBL	DAP$B_DCODE_MSG(R9),R0	; Get DAP message type
	BBC	R0,DAP$L_MSG_MASK(R9),-	; Branch if this is not a valid
		ERROR_SYNC		;  message to receive

;
; Check for system specific fields in message header.
;

	TSTL	DAP$Q_SYSPEC(R9)	; Any system specific fields?
	BNEQ	SSP_MINI_MSG		; If yes, process them

;
; Update message descriptors in DAP control block.
;

EXIT_COMMON:				; Common exit sequence
	SUBL3	DAP$Q_MSG_BUF2+4(R9),-	; Compute size of message just parsed
		R10,DAP$Q_MSG_BUF2(R9)	;  and store it in descriptor
	MOVL	R10,DAP$Q_MSG_BUF1+4(R9); Store address of next (blocked)
					;  message in buffer to parse
	SUBL2	DAP$Q_MSG_BUF2(R9),-	; Store size of next (blocked)
		DAP$Q_MSG_BUF1(R9)	;  message in buffer to parse
	MOVL	DAP$L_DCODE_STS(R9),R0	; Get return status code
	RET				; Return to caller

	.SBTTL	CHECK_MASKS - VALIDATE FIELD BIT OPTIONS

;++
; Functional Description:
;
;	CHECK_MASKS invoked from the CHECK_MASKS macro examines the designated
;	field for invalid and unsupported bits set.
;
; Calling Sequence:
;
;	BSBW	CHECK_MASKS
;
; Input Parameters:
;
;	R6	Address of designated field in DAP control block
;	R7	Field ID value
;
;	In-line coded arguments:
;
;	Byte0	Size in bytes of the designated field in DAP control block
;	Byten	Mask of invalid bits (1-4 bytes; size specified in byte0)
;	Bytem	Mask of unsupported bits (1-4 bytes; size specified in byte0)
;
; Implicit Inputs:
;
;	None
;
; Output Parameters:
;
;	R0-R1	Destroyed
;	R6-R7	Unchanged
;
; Implicit Outputs:
;
;	The specified field of the DAP control block is validated.
;
; Completion Codes:
;
;	None
;
; Side Effects:
;
;	If any invalid or unsupported bits are set, control is given to an
;	appropriate error routine.
;
;	An exception exit described above, leaves the return address on the
;	stack.
;
;--

CHECK_MASKS:				; Entry point
	MOVL	(SP),R0			; Get address of in-line arguments
	MOVZBL	(R0)+,R1		; Get DST field size
	$CASEB	SELECTOR=R1-		; Dispatch on field size:
		BASE=#1-		;
		DISPL=<-		;
		    10$-		;  1-byte
		    20$-		;  2-bytes
		    30$-		;  Error
		    40$-		;  4-bytes
		>			;
30$:	BRB	ERROR_FORMAT		; Value is out-of-range
10$:	BITB	(R6),(R0)+		; Check for invalid bits
	BNEQ	ERROR_INVALID		; Branch on error
	BITB	(R6),(R0)+		; Check for unsupported bits
	BRB	50$			; Join common code
20$:	BITW	(R6),(R0)+		; Check for invalid bits
	BNEQ	ERROR_INVALID		; Branch on error
	BITW	(R6),(R0)+		; Check for unsupported bits
	BRB	50$			; Join common code
40$:	BITL	(R6),(R0)+		; Check for invalid bits
	BNEQ	ERROR_INVALID		; Branch on error
	BITL	(R6),(R0)+		; Check for unsupported bits
50$:	BNEQ	ERROR_UNSUPPORT		; Branch on error
	MOVL	R0,(SP)			; Bump return address past argument list
	RSB				; Exit

	.SBTTL	SSP_MINI_MSG - DECODE SYSTEM SPECIFIC FIELD

;++
; Decode the system specific field found in the message header.
; Treat it as the operand portion of a mini-message that has a menu field
; and related fields.
;--

SSP_MINI_MSG:				; Code segment of mainline
	PUSHL	R10			; Save end-of-message + 1 address
	MOVQ	DAP$Q_SYSPEC(R9),R10	; R10 = size of syspec field
					; R11 = address of start-of-field
	ADDL2	R11,R10			; R10 = address of end-of-field + 1
	$ZERO_FILL-			; Zero system specific work area
		DST=DAP$L_SSPWA(R9)-	;  in DAP control block
		SIZE=#DAP$K_SSPWA	;

;
; Process the system specific menu field (optional).
; Each bit set denotes that its associated field follows in the message.
;

	ASSUME	DAP$V_SSP_CAP+1 EQ DAP$V_SSP_FLG

	MOVAB	W^SSP_SUCCESS,R8	; Specify transfer address on EOM
	STORE_FIELD	SSP_MENU,2,K_EXT; Save system specific menu field
	CHECK_MASKS	SSP_MEN,2	; Validate bit options
	MOVAB	W^ERROR_FORMAT,R8	; Specify transfer address on EOM
	MOVZWL	(R6),AP			; Copy menu to scratch register
SSP_LOOP:				;
	FFS	#0,#DAP$V_SSP_FLG+1,AP,R0; Get position of next bit set
	$CLRBIT	R0,AP			; Clear menu bit just found
	PUSHAB	B^SSP_LOOP		; Push return address on stack
	$CASEB	SELECTOR=R0-		; Next field:
		DISPL=<-		;
		    10$-		;  SSP_CAP
		    20$-		;  SSP_FLG
		>
	BRB	SSP_SUCCESS		; All fields parsed

;
; Process each field specified in the menu (optional).
;

10$:	STORE_FIELD	SSP_CAP,4,K_EXT,<M_TRUNC>
					; Save system specific capabilities
	RSB				;  field
20$:	STORE_FIELD	SSP_FLG,4,K_EXT	; Save system specific flags field
	CHECK_MASKS	SSP_FLG,4	; Validate bit options
	RSB				;

;
; System specific mini-message has been parsed successfully!
;

SSP_SUCCESS:				;
	POPL	R0			; Throw away return address on stack
	POPL	R10			; Restore address of end-of-message + 1
	BRW	EXIT_COMMON		; Exit here because this routine
					;  was entered from EXIT_SUCCESS

	.END				; End of module
