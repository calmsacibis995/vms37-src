MODULE object (IDENT='V03-001') =

BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY:  The MESSAGE compiler
!
! ABSTRACT:
!
!	This compiler translates a message definition language
!	and produces object modules suitable for the $GETMSG
!	system service.
!
! ENVIRONMENT:
!
!	VAX/VMS operating system. unprivileged user mode,
!
! AUTHOR:  Tim Halvorsen, Nov 1979
!
! Modified by:
!
!	001	JWT0024		Jim Teague	17-Mar-1982
!		Corrects the bug which prevented pointer psects from being
!		output when /notext is explicitly specified.
!
!--

!
! Include files
!

LIBRARY 'SYS$LIBRARY:STARLET';		! VMS common definitions

REQUIRE 'SRC$:MSG.REQ';			! Message common definitions

!
! Table of contents
!

FORWARD ROUTINE
    output_object,			! Output object module
    create_section,			! Create message section
    create_indirect,			! Create indirect message section
    output_mhd,				! Output module header record
    output_psects,			! Output psect definitions
    output_gsd,				! Output global symbol records
    output_section,			! Output message section
    output_eom,				! Output end of module record
    set_psect,				! Set to selected psect
    put_record,				! Put object record to file
    start_record,			! Start of GSD/TIR record
    put_entry,				! Output GSD/TIR entry
    end_record;				! End of GSD/TIR entries

!
! Macros
!

MACRO
    perform(command) =
	BEGIN
	LOCAL status;
	status = command;
	IF NOT .status
	THEN
	    BEGIN
	    SIGNAL(.status);
	    RETURN .status;
	    END;
	END%;

!
! Literals
!

LITERAL
    psect_flags = gps$m_pic OR gps$m_rel OR gps$m_rd OR gps$m_vec;

!
! Module storage
!

OWN
    section:		REF BBLOCK,	! Address of message section
    record_buffer:	BBLOCK[obj$c_maxrecsiz],	! record buffer
    rec_filled;				! Space used in record_buffer so far

!
! External storage
!

EXTERNAL
    object_fab:		BBLOCK,		! Object module FAB
    object_rab:		BBLOCK,		! Object module RAB
    object_nam:		BBLOCK,		! Object module NAM block
    cli_flags:		BITVECTOR,	! CLI qualifier flags
    module_name:	VECTOR,		! Name of object module
    filename_desc:	VECTOR,		! Descriptor of /FILE value
    facility_header,			! Facility list head
    message_header,			! Message list head
    symbol_header,			! Symbol list head
    num_messages,			! Number of messages defined
    msg_space,				! Total space used by MSG records
    num_facilities,			! Number of facilities defined
    fac_space,				! Total space needed for facility table
    version_num:	VECTOR,		! Descriptor for version/ident
    num_files;				! Total files parsed

!
! External routines
!

EXTERNAL ROUTINE
    get_module_name,			! Extract module name
    rms_error,				! Signal RMS-type error
    allocate;				! Allocate dynamic memory

GLOBAL ROUTINE output_object =

!---
!
!	This routine generates the object module file from the
!	message definition blocks generated by input parse routines.
!
! Inputs:
!
!	object_fab/rab = FAB/RAB for object module file
!	facility_header = Facility list head
!	message_header = Message definition list head
!
! Outputs:
!
!	The object module file
!---

BEGIN

LOCAL
    status;				! status code

!
!	Create the object module file
!

status = $CREATE (FAB = object_fab);	! Create the output file
IF NOT .status				! If error detected,
THEN
    BEGIN
    rms_error(emsg(openout),object_fab);	! then signal the error
    RETURN .status;			! and return with status
    END;

status = $CONNECT (RAB = object_rab);	! Connect to the object file
IF NOT .status				! If error detected,
THEN
    BEGIN
    rms_error(emsg(openout),object_fab,object_rab);	! then signal it
    RETURN .status;			! and return with status
    END;

IF .num_files GTR 1			! If more than 1 input file,
THEN
    get_module_name(object_fab);	! Use object file name as module name

!
!	Create the index message structure in dynamic storage.
!

IF NOT .cli_flags [qual_file]		! If /FILE not specified,
THEN
    perform(create_section())		! Create the message structure
ELSE
    perform(create_indirect());		! Else, create indirect section

!
!	Output the module header record
!

perform(output_mhd());			! Output the module header record

!
!	Define the psects used for the message section.  If
!	constructing an indirect message section, make the psects
!	writable.
!

IF NOT .cli_flags [qual_file]		! If /FILE qualifier not specified,
THEN
    perform(output_psects(psect_flags))	! Make normal NOWRT
ELSE
    perform(output_psects(psect_flags OR gps$m_wrt));	! Make indirect WRT

!
!	Output the GSD records for the symbols
!

IF .cli_flags [qual_symbols]		! If /SYMBOLS specified,
THEN
    perform(output_gsd());		! Output the GSD records

!
!	Output the TIR records which describe the message structure
!

IF .cli_flags [qual_text] OR .cli_flags [qual_file]  ! If /TEXT or /FILE
THEN
    perform(output_section());		! Output section TIR records

!
!	Output the end-of-module record
!

perform(output_eom());			! Output the EOM record

!
!	Close the object module file
!

status = $CLOSE(FAB = object_fab);	! Close the file
IF NOT .status				! If error,
THEN
    BEGIN
    rms_error(emsg(closedel),object_fab); ! signal the error
    RETURN .status;			! and return with status
    END;

RETURN true;

END;

ROUTINE create_section =

!---
!
!	This routine creates the message section exactly as
!	it will look when linked into the user image.  The
!	resulting structure will be output as TIR records to
!	the object module.
!
! Inputs:
!
!	facility_header = List head for facility definitions
!	message_header = List head for message definitions
!	num_messages = Number of message definitions in the list
!	msg_space = Space used by MSG records alone
!	num_facilities = Number of facility definitions in the list
!	fac_space = Space needed for facility table
!
! Outputs:
!
!	r0 = status (unsignaled)
!	section = Address of final message section
!---

BEGIN

LITERAL
    bucket_size = 512,			! Size of each index bucket
    bucket_overhead = midx$c_entries,	! Overhead in each bucket
    usable_size = bucket_size-bucket_overhead,	! Useable space in each bucket
    entry_size = 8,			! Size of each index entry
    entries_per_blk = usable_size/entry_size,
    max_1level = 3*bucket_size;		! Maximum size of 1 level index
					! before 2 level index will be created

LOCAL
    prim_index_len,			! Length of primary index
    sec_index_len,			! Length of secondary index (0 if none)
    sec_index_bkts,			! # buckets in secondary index
    section_size,			! Total size of message section
    prim_index:		REF VECTOR,	! Current position in primary index
    bucket:		REF BBLOCK,	! Address of current index bucket
    bucket_filled,			! Bytes allocated in current bucket
    data:		REF BBLOCK,	! Address of next available data byte
    code:		REF BBLOCK,	! Address of current CODE block
    fac:		REF BBLOCK,	! Address of current FAC block
    status;				! Status code

MACRO
    round_div(i,j) =
	((i/j) + ((i MOD j) NEQ 0))%; ! i/j rounded up if remainder GTR 0

IF .num_messages LEQ 0			! If no messages defined,
THEN
    RETURN emsg(nomsgs);		! then return with error

!
!	Compute the amount of space needed to hold the index
!	and text portions of the message section.
!

prim_index_len = .num_messages * entry_size + bucket_overhead;

IF .prim_index_len GTR max_1level	! If index too large,
THEN
    BEGIN				! Setup a 2 level index
    sec_index_bkts = round_div(.num_messages*entry_size,usable_size);

    sec_index_len = .num_messages * entry_size	! Size of secondary index
	+ .sec_index_bkts * bucket_overhead;	! plus bucket overhead

    prim_index_len = .sec_index_bkts * entry_size ! Set size of primary index
			+ bucket_overhead	! plus bucket overhead
    END
ELSE
    sec_index_len = 0;			! Else no secondary index (useless)

!
!	Compute the amount of space needed for the entire message section
!	including the facility table.
!

section_size = msc$c_length + .prim_index_len + .sec_index_len
		+ .fac_space + .msg_space;

!
!	Allocate enough space for the entire thing
!

status = allocate(.section_size,section);! Allocate the space, signal error
IF NOT .status				! If error detected,
THEN
    RETURN .status;			! then return with status

!
!	Construct the index and data portions of the section
!

CH$FILL(0,msc$c_length,.section);	! Zero the section header
section [msc$b_type] = msc$c_msg;	! Set type of section
section [msc$w_sanity] = msc$c_sanity;	! Set sanity check word
section [msc$l_size] = .section_size;	! Set size of entire section
section [msc$l_index_off] = msc$c_length; ! Offset to primary index
section [msc$l_text_off] = msc$c_length+.prim_index_len+.sec_index_len;
section [msc$l_fac_off] = .section [msc$l_text_off] + .msg_space;

!
!	Initialize the primary index
!

BEGIN
BIND
    prim_bucket = .section+msc$c_length: BBLOCK;	! Address primary index
prim_bucket [midx$w_size] = .prim_index_len;	! Set length of index
prim_bucket [midx$b_sanity] = midx$c_sanity;	! Set sanity check byte
prim_index = prim_bucket + midx$c_entries;		! Position at entry 1
END;

!
!	Setup the secondary index pointers
!

bucket = .section+msc$c_length + .prim_index_len;	! Point at sec. index
bucket_filled = 0;			! Nothing filled yet

code = .message_header;			! Point at first message definition
data = .section + .section [msc$l_text_off];	! Point at data area

!
!	Loop thru each message definition storing the
!	message definition record and the index entry.
!

INCR i FROM 1 TO .num_messages		! For each message definition,
DO
    BEGIN
    BIND
        msg = code [code$c_msg,0,0,0]: BBLOCK;	! Reference MSG block
    LOCAL
	sec_index:	REF VECTOR;	! Address of secondary index entry

    !
    !	Store the index to the record in the primary or secondary
    !	index depending on whether we're doing a 1 or 2 level index.
    !

    IF .sec_index_len NEQ 0		! If doing a 2 level index,
    THEN
	BEGIN
        IF .bucket_filled EQL 0		! If at start of bucket,
        THEN
	    BEGIN
	    bucket [midx$w_size] = 0;		! Preset size of bucket
	    bucket [midx$b_sanity] = midx$c_sanity;	! Set sanity check byte
	    bucket_filled = bucket_overhead;	! Account for space
	    sec_index = .bucket + bucket_overhead;	! Set to first entry
	    END;
	END
    ELSE
	sec_index = .prim_index;	! Else, store directly into primary

    IF .sec_index GEQ .section + .section [msc$l_text_off] ! If overflow,
    THEN
	BEGIN
	SIGNAL(emsg(indexovfl));		! Signal index area overflow
	RETURN emsg(indexovfl);
	END;

    sec_index [0] = .code [code$l_number]	! Insert message code in index
			AND NOT sts$m_severity;	! but leave severity bits zero
    sec_index [1] = .data - .section;		! Store offset to record

    !
    !	Store message definition record into data area
    !

    IF .data GEQ .section + .section [msc$l_fac_off] ! If overflow,
    THEN
	BEGIN
	SIGNAL(emsg(dataovfl));			! Signal data area overflow
	RETURN emsg(dataovfl);
	END;

    CH$MOVE(.msg [mrec$w_size], msg, .data); 	! Store MSG record in data area

    data = .data + .msg [mrec$w_size];		! Skip to next available byte

    !
    !	If doing 2 level index, increment space used in bucket.
    !	Check for secondary index bucket full.  If full, then
    !	put the highest key in the bucket into the primary index.
    !

    IF .sec_index_len NEQ 0		! If doing 2 level index,
    THEN
	BEGIN
        bucket_filled = .bucket_filled + entry_size;! Account for space used

        IF .bucket_filled GTR bucket_size-entry_size ! If last entry in bucket,
	    OR .i EQL .num_messages		! or last message
        THEN
	    BEGIN
	    bucket [midx$w_size] = .bucket_filled;	! Set size of bucket
	    IF .prim_index GEQ .section + .section [msc$l_index_off]
				+ .prim_index_len ! If overflow,
	    THEN
		BEGIN
		SIGNAL(emsg(indexovfl));	! Signal index area overflow
		RETURN emsg(indexovfl);
		END;
	    prim_index [0] = .sec_index [0];	! Store highest entry in bucket
	    prim_index [1] = (.bucket - .section) ! Store offset to bucket
			OR 1;			! with bottom bit set (subindex)
	    prim_index = .prim_index + entry_size;	! Set to next entry
	    bucket = .bucket + bucket_size;		! Set to next bucket
	    bucket_filled = 0;			! reset usage counter
	    END
        ELSE				! Else, if still more room in bucket,
	    sec_index = .sec_index + entry_size;	! Set to next entry
	END

    !
    !	If only doing a 1 level index, then we need only to
    !	increment to the next position in the primary index.
    !

    ELSE				! Else, if only doing primary index,
	prim_index = .prim_index + entry_size;	! Set to next primary entry

    code = .code [code$l_link];		! and skip to next CODE block
    END;

!
!	Generate the facility definition table in the section
!

data [0,0,16,0] = .fac_space - 2;	! Set size of entire table (excl. size)
data = .data + 2;

fac = .facility_header;			! Start at first entry in list
INCR i FROM 1 TO .num_facilities	! For each facility definition,
DO
    BEGIN
    IF .data GEQ .section + .section [msc$l_size] ! If overflow,
    THEN
	BEGIN
	SIGNAL(emsg(facovfl));		! Signal facility table overflow
	RETURN emsg(facovfl);
	END;
    data [mfac$w_number] = .fac [fac$w_number];	! Store facility number
    data [mfac$b_namelen] = .fac [fac$b_namelen]; ! and facility name
    CH$MOVE(.fac [fac$b_namelen], fac [fac$t_name], data [mfac$t_name]);
    data = .data + $BYTEOFFSET(mfac$t_name) + .fac [fac$b_namelen];
    fac = .fac [fac$l_link];		! Link to next in chain
    END;

RETURN true;

END;

ROUTINE create_indirect =

!---
!
!	Create the indirect message section.  This section
!	will merely contain the name of the message file which
!	should be mapped at run-time by SYS$GETMSG.
!
! Inputs:
!
!	filename_desc = Descriptor of /FILE value
!
! Outputs:
!
!	r0 = status (unsignaled)
!	section = Address of section
!---

BEGIN

LOCAL
    status,				! status code
    section_size;			! Size of section in bytes

section_size = $BYTEOFFSET(msc$t_indname) + .filename_desc [0];

status = allocate(.section_size,section); ! Allocate space for section
IF NOT .status				! If error allocating space
THEN
    RETURN .status;			! then return with status

section [msc$b_type] = msc$c_ind;	! Set type to indirect
section [msc$w_sanity] = msc$c_sanity;	! Set sanity check word
section [msc$l_size] = .section_size;	! Set size of section
section [msc$b_indnamlen] = .filename_desc [0];	! Set length of name
CH$MOVE(.filename_desc [0], .filename_desc [1], section [msc$t_indname]);

RETURN true;				! return with success

END;

ROUTINE output_mhd =

!---
!
!	Output a module header record.
!
! Inputs:
!
!	None
!
! Outputs:
!
!	Module header record is output.
!---

BEGIN

BIND
    lang_name = UPLIT('VAX-11 Message V03.00');

LITERAL
    lang_length = 21;

LOCAL
    rec:	BBLOCK[128],		! Allocate record buffer
    offset,				! Offset to current spot in record
    bufdesc:	VECTOR[2];		! General buffer descriptor

rec [obj$b_rectyp] = obj$c_hdr;		! Set record type = HDR
rec [mhd$b_hdrtyp] = mhd$c_mhd;		! Main module header record
rec [mhd$b_strlvl] = 0;			! Structure level 0
rec [mhd$w_recsiz] = obj$c_maxrecsiz;	! Maximum record size

rec [mhd$b_namlng] = .module_name [0];	! Length of module name
CH$MOVE(.module_name [0], .module_name[1], rec [mhd$t_name]);
offset = $BYTEOFFSET(mhd$t_name) + .module_name [0];

IF .version_num [0]  EQL  0
THEN
    !
    ! No .IDENT was specified
    !
    BEGIN
    rec [.offset,0,8,0] = 1;
    rec [.offset,8,8,0] = '0';
    offset = .offset + 2;
    END

ELSE
    !
    ! .IDENT was specified
    !
    BEGIN
    rec [.offset,0,8,0] = .version_num [0];	
    offset = .offset + 1;
    CH$MOVE(.version_num [0],.version_num [1],rec [.offset,0,0,0]);
    offset = .offset + .version_num [0] ;
    version_num [0] = 0;
    END;

bufdesc [0] = 17;			! Length of date/time string
bufdesc [1] = rec + .offset;		! Address to put creation date/time
$ASCTIM(TIMBUF=bufdesc);		! Put creation date/time into buffer
offset = .offset + 17;

bufdesc [1] = .bufdesc [1] + 17;	! Address to put last patch date/time
$ASCTIM(TIMBUF=bufdesc);		! Put time of last patch into buffer
offset = .offset + 17;

put_record (rec, .offset);		! Output record

rec [mhd$b_hdrtyp] = mhd$c_lnm;		! Language name and version
CH$MOVE(lang_length, lang_name, rec + $BYTEOFFSET(mhd$b_hdrtyp)+1);

put_record(rec, $BYTEOFFSET(mhd$b_hdrtyp)+1+lang_length);

RETURN true;

END;

ROUTINE output_eom =

!---
!
!	Output an end of module record
!
! Inputs:
!
!	None
!
! Outputs:
!
!	The record is output.
!---

BEGIN

LOCAL
    rec:	BBLOCK[128];		! Allocate record buffer

rec [obj$b_rectyp] = obj$c_eom;		! Set record type = EOM
rec [eom$b_comcod] = eom$c_success;	! Set completion severity

put_record(rec, 2);			! Output record

RETURN true;

END;

ROUTINE output_psects (psect_flags) =

!---
!
!	This routine outputs all the psect definitions
!	for normal message sections.  Only the absolute
!	psect is output if /NOTEXT is specified.
!
! Inputs:
!
!	psect_flags = Psect attributes
!
! Outputs:
!
!	The records are output.
!---

BEGIN

LOCAL
    entry:	BBLOCK[129];		! Entry buffer

start_record(obj$c_gsd);		! Signal start of GSD record

!
!	Define psects used in this object module
!

entry [gps$b_gsdtyp] = gsd$c_psc;	! Psect definition entry
entry [gps$b_align] = 0;		! Psect alignment (byte)
entry [gps$w_flags] = gps$m_exe OR gps$m_rd OR gps$m_wrt; ! Psect attributes
entry [gps$l_alloc] = 0;		! Set size of section
entry [gps$b_namlng] = 5;		! Length of psect name
CH$MOVE(5,UPLIT('$ABS$'),entry [gps$t_name]);	! Set psect name
put_entry(entry, $BYTEOFFSET(gps$t_name)+5);	! Output entry

IF NOT .cli_flags [qual_text]  AND		! If /NOTEXT specified,
   NOT .cli_flags [qual_file]			!      and no pointers
THEN
    BEGIN
    end_record();			! then flush absolute psect only
    RETURN true;			! and return
    END;

entry [gps$w_flags] = .psect_flags;	! Psect attributes
entry [gps$l_alloc] = .section [msc$l_size];	! Set size of section

IF .cli_flags[qual_file]
THEN
    BEGIN
    entry [gps$b_namlng] = 14;		! Length of psect name
    CH$MOVE(14,UPLIT('MSGPTR$SECTION'),entry [gps$t_name]);! Set ptr psect name
    put_entry(entry, $BYTEOFFSET(gps$t_name)+14);	! Output entry
    END
ELSE
    BEGIN
    entry [gps$b_namlng] = 11;		! Length of psect name
    CH$MOVE(11,UPLIT('MSG$SECTION'),entry [gps$t_name]);   ! Set psect name
    put_entry(entry, $BYTEOFFSET(gps$t_name)+11);	! Output entry
    END;

entry [gps$b_align] = 2;		! Psect alignment (longword)
entry [gps$w_flags] = .psect_flags OR gps$m_ovr; ! This psect is overlayed
entry [gps$l_alloc] = 4*4;		! Size of psect contribution
entry [gps$b_namlng] = 15;		! Length of psect name

IF .cli_flags[qual_file]
THEN
    CH$MOVE(15,UPLIT('MSGPTR$AAAAAAAA'),entry [gps$t_name])! Set ptr psect name
ELSE
    CH$MOVE(15,UPLIT('MSG$AAAAAAAAAAA'),entry [gps$t_name]); ! Set psect name

put_entry(entry, $BYTEOFFSET(gps$t_name)+15);	! Output entry

entry [gps$w_flags] = .psect_flags;	! Normal psect flags
entry [gps$l_alloc] = 4;		! Size of psect contribution

IF .cli_flags[qual_file]
THEN
    CH$MOVE(15,UPLIT('MSGPTR$AAAAAAAB'),entry [gps$t_name])! Set ptr psect name
ELSE
    CH$MOVE(15,UPLIT('MSG$AAAAAAAAAAB'),entry [gps$t_name]); ! Set psect name

put_entry(entry, $BYTEOFFSET(gps$t_name)+15);	! Output entry

entry [gps$w_flags] = .psect_flags OR gps$m_ovr; ! This psect is overlayed

IF .cli_flags[qual_file]
THEN
    CH$MOVE(15,UPLIT('MSGPTR$AAAAAAAC'),entry [gps$t_name])! Set ptr psect name
ELSE
    CH$MOVE(15,UPLIT('MSG$AAAAAAAAAAC'),entry [gps$t_name]); ! Set psect name

put_entry(entry, $BYTEOFFSET(gps$t_name)+15);	! Output entry

end_record();				! Flush rest of record buffer

RETURN true;

END;

ROUTINE output_gsd =

!---
!
!	This routine outputs all the global symbol
!	definitions to symbolically refer to the
!	messages.
!
! Inputs:
!
!	None
!
! Outputs:
!
!	The records are output.
!---

BEGIN

LOCAL
    entry:	BBLOCK[129],		! Entry buffer
    ptr:	REF BBLOCK;		! Address of current symbol entry

start_record(obj$c_gsd);		! Signal start of GSD record

entry [sdf$b_gsdtyp] = gsd$c_sym;	! Global symbol definition
entry [sdf$b_datyp] = 0;		! Data type undefined
entry [sdf$w_flags] = gsy$m_def;	! Definition rather than reference
entry [sdf$b_psindx] = 0;		! Owning psect number 0 ($ABS$)

ptr = .symbol_header;			! Point at first symbol entry

WHILE .ptr NEQ 0			! Until end of list
DO
    BEGIN
    entry [sdf$l_value] = .ptr [sym$l_value];
    entry [sdf$b_namlng] = .ptr [sym$b_symlen];
    CH$MOVE(.ptr [sym$b_symlen], ptr [sym$t_symbol], entry [sdf$t_name]);
    put_entry(entry, $BYTEOFFSET(sdf$t_name)+.entry [sdf$b_namlng]);
    ptr = .ptr [sym$l_link];		! Skip to next in chain
    END;

end_record();				! Flush rest of record buffer

RETURN true;

END;

ROUTINE output_section =

!---
!
!	This routine outputs the TIR records to the object
!	module file to describe the message section.
!
! Inputs:
!
!	None
!
! Outputs:
!
!	The records are written.
!---

BEGIN

LOCAL
    entry:	VECTOR[129,BYTE],	! TIR command buffer
    position,				! Position within section
    bytes_left;				! Bytes left of section to output

start_record(obj$c_tir);		! Signal start of TIR record

!
!	Output the message section vector dispatcher (psect 1)
!	The name of the psect is set so that it will be loaded
!	in front of the message	section list.
!

set_psect(2,0);				! Set to psect 2

entry [0] = -16;			! Store immedate 16 bytes
BEGIN
LOCAL
    vector: REF BBLOCK;			! Address buffer as longwords

vector = entry [1];			! Address the start of the vector
vector [plv$l_type] = plv$c_typ_msg;	! Type of vector
vector [plv$l_version] = 0;		! (reserved)
vector [plv$l_msgdsp] = 6;		! Self-rel offset to dispatcher code
vector [12,0,32,0] = %x'65160101';	! NOP, NOP, JSB (R5) instructions
END;
put_entry(entry,17);			! Output TIR command

!
!	Output the self-relative offset to the mssage section (psect 3).
!	It will be contributed to the section list psect at
!	the end - resulting in a list of section offsets.
!	Each offset to the sections is relative to the start
!	of the longword itself.
!

set_psect(3,0);				! Set to psect 3

entry [0] = tir$c_sta_sb;		! Stack signed byte
entry [1] = -1;				! Sign extended -1
entry [2] = tir$c_sta_pb;		! Stack psect base plus offset
entry [3] = 1;				! psect number of message section
entry [4] = 0;				! start of psect
entry [5] = tir$c_sto_pirr;		! Store self-relative offset to psect 1

put_entry(entry,6);			! Output TIR command

!
!	Output a zero list terminator (psect 4).
!	This psect is an overlayed psect of length 4 which
!	contains a zero.  The name of the psect is set
!	so that it will be loaded following the message
!	section list as a list terminator.
!

set_psect(4,0);				! Set to psect 4

entry [0] = tir$c_sta_sb;		! Stack signed byte
entry [1] = 0;				! value = 0 (byte to store)
entry [2] = tir$c_sta_sb;		! Stack signed byte
entry [3] = 4;				! value = 4 (repeat count)
entry [4] = tir$c_sto_rb;		! Store repeated byte (4 zero bytes)

put_entry(entry,5);			! Output TIR commands

!
!	Output the message section text
!

set_psect(1,0);				! Set to psect 1

position = .section;			! Start at beginning of section
bytes_left = .section [msc$l_size];	! Bytes left to output

WHILE .bytes_left GTR 0			! While stuff left to output,
DO
    BEGIN
    LOCAL bytes;

    bytes = MINU(.bytes_left,128);	! Max 128 bytes per record
    entry [0] = -.bytes;		! Number of bytes to output
    CH$MOVE(.bytes,.position,entry[1]);	! Move the bytes
    put_entry (entry, .bytes+1);	! Output the TIR command
    position = .position + .bytes;	! Skip past stuff output
    bytes_left = .bytes_left - .bytes;	! Decrement amount remaining
    END;

end_record();			! Flush remaining record buffer

RETURN true;

END;

ROUTINE set_psect(psect_number, offset) =

!---
!
!	Output an object module command to set the
!	current psect to the specified value to
!	signal the start of contributions to that
!	psect.
!
! Inputs:
!
!	psect_number = Psect number to set to
!	offset = Offset into psect
!
! Outputs:
!
!	None
!---

BEGIN
LOCAL
    entry:	VECTOR[4,BYTE];		! Allocate buffer

entry [0] = tir$c_sta_pb;		! Stack psect base
entry [1] = .psect_number;		! psect number
entry [2] = .offset;			! offset into psect
entry [3] = tir$c_ctl_setrb;		! Set relocation base
put_entry(entry,4);			! Output TIR command

RETURN true;

END;

ROUTINE put_record (address, length) =

!---
!
!	Output a record to the object module file.
!
! Inputs:
!
!	address = Address of record
!	length = Length of record
!
! Outputs:
!
!	None
!---

BEGIN

LOCAL
    status;

object_rab [rab$w_rsz] = .length;
object_rab [rab$l_rbf] = .address;

status = $PUT(RAB = object_rab);	! Put the record to the file
IF NOT .status				! If error detected,
THEN
    BEGIN
    rms_error(emsg(writeerr),object_fab,object_rab);	! signal error
    RETURN .status;			! and return with status
    END;

RETURN true;

END;

ROUTINE start_record (type) =

!---
!
!	This routine is called when a variable size record
!	(like GSD or TIR) is about to be output.
!
! Inputs:
!
!	type = Type of variable record (GSD or TIR)
!
! Outputs:
!
!	rec_filled = Address of next available byte in record
!---

BEGIN

record_buffer [obj$b_rectyp] = .type;		! Set record type
rec_filled = 1;					! Set offset to beginning

RETURN true;

END;

ROUTINE put_entry (address, length) =

!---
!
!	This routine outputs a GSD/TIR entry into the current record
!	buffer.  The record buffer will be output automatically
!	when full.
!
! Inputs:
!
!	address = Address of GSD entry buffer
!	length = Length of entry
!	rec_filled = Current offset into record buffer
!
! Outputs:
!
!	rec_filled updated.
!---

BEGIN

IF (.rec_filled+.length) GTR obj$c_maxrecsiz	! If record too large,
THEN
    BEGIN
    put_record(record_buffer,.rec_filled);	! Output the record
    rec_filled = 1;				! Start at beginning again
    END;

CH$MOVE(.length, .address, record_buffer+.rec_filled); ! Move into record buffer

rec_filled = .rec_filled + .length;		! Update buffer position

RETURN true;

END;

ROUTINE end_record =

!---
!
!	This routine is called to signal that all entries have
!	been output for now and to flush the current record buffer.
!
! Inputs:
!
!	rec_filled = Amount left in buffer
!
! Outputs:
!
!	None
!---

BEGIN

IF .rec_filled GTR 1				! If anything in buffer
THEN
    put_record(record_buffer, .rec_filled);	! then output record

RETURN true;

END;

END
ELUDOM
