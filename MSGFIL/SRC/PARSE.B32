MODULE parse (IDENT = 'V03-001') =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY:  Message compiler
!
! ABSTRACT:
!
!	This compiler translated message definition language
!	into object modules
!
! ENVIRONMENT:
!
!	VAX/VMS operating system. unprivileged user mode,
!
! AUTHOR:  Tim Halvorsen, Nov 1979
!
! Modified by:
!
!	001	JWT0025		Jim Teague	17-Mar-1982
!		Add the / delimiter for .IDENT fields
!
!
!--

!
! Include files
!

LIBRARY 'SYS$LIBRARY:STARLET';		! VAX/VMS common definitions

LIBRARY 'SYS$LIBRARY:TPAMAC';		! TPARSE definitions

REQUIRE 'SRC$:MSG.REQ';			! Command definitions

!
! Table of contents
!

FORWARD ROUTINE
    parse_file,				! Parse input file
    get_record,				! Get next input record
    message_init,			! Initialize for next message
    message_defn,			! Process a message definition
    add_message,			! Add message to msg defn list
    facility_init,			! Initialize for next facility
    facility_defn,			! Process a facility definition
    add_facility,			! Add facility to fac defn list
    add_symbol,				! Add symbol to symbol table
    lookup_symbol,			! Lookup symbol in symbol table
    find_eos,				! Find end of message string
    find_endvers,			! Store delimited ident/version string
    get_cont_line,			! Get continuation line and plug in
    define_literal,			! Define a user literal
    set_title,				! Store title string
    set_module,				! Store module name string
    build_version,			! Store undelimited version/ident string
    store_number,			! Store/check numeric qualifier value
    store_string,			! Store/check string qualifier value
    allocate,				! Allocate dynamic storage
    deallocate,				! Deallocate dynamic storage
    comment;				! Call MDL or SDL to output comment

!
! Storage definitions
!

LITERAL
    form_feed = 12,			! Form feed character
    facility_bufsiz = 9,		! Maximum size of facility name
    prefix_bufsiz = obj$c_symsiz,	! Max size of facility prefix
    defpre_bufsiz = 9,			! Maximum size of /PREFIX string
    macro_bufsiz = 15,			! Maximum size of facility macro name
    symbol_bufsiz = obj$c_symsiz,	! Maximum size of symbol name
    sym_plus_pre = obj$c_symsiz,	! Maximum size of symbol + prefix
    ident_bufsiz = 15,			! Maximum size of /IDENT string
    message_bufsiz = 256,		! Maximum size of message text string
    title_bufsiz = 128;			! Maximum size of title string

GLOBAL
    message_header:	INITIAL(0),	! Listhead for CODE blocks
    facility_header:	INITIAL(0),	! Listhead for FAC blocks
    symbol_header:	INITIAL(0),	! Listhead for symbol table list
    num_messages:	INITIAL(0),	! Number of messages defined
    msg_space:		INITIAL(0),	! Total space used by MSG blocks
    num_facilities:	INITIAL(0),	! Number of facilities defined
    fac_space:		INITIAL(2),	! Total space needed for facility table
					! initially 2 bytes (list terminator)
    num_files:		INITIAL(0),	! Total files acceped as input
    title_buffer:	BBLOCK[title_bufsiz],	! Title text buffer
    title_text:		VECTOR[2]	! Module title text
			INITIAL(0,title_buffer),
    input_record:	VECTOR[2],	! Input record descriptor
    input_linenum,			! Line number of input record
    version_buffer:	BBLOCK[obj$c_symsiz],	! Version/ident string buffer
    version_num :	VECTOR[2]	! Descriptor for version/ident
			INITIAL (0,version_buffer);

OWN
    tparse_block: BBLOCK[tpa$c_length0]	! TPARSE parameter block
		PRESET( [tpa$l_count]	= tpa$k_count0,
			[tpa$l_options]	= tpa$m_abbrev),

    facility_buffer:	BBLOCK [facility_bufsiz], ! Facility name buffer
    facility_name:	VECTOR [2]	! Descriptor of facility name
			INITIAL(0,facility_buffer),
    facility_number,			! Current facility number
    facility_flags:	BITVECTOR [32],	! Flags describing current facility
    defpre_buffer:	BBLOCK [defpre_bufsiz],	! Default prefix buffer
    prefix_buffer:	BBLOCK [prefix_bufsiz],	! Prefix buffer
    default_prefix:	VECTOR [2]	! Symbol prefix for current facility
			INITIAL(0,defpre_buffer),
    default_sev,			! Default severity
    default_lang,			! Default language ident number
    macro_buffer:	BBLOCK [macro_bufsiz],	! Macro name buffer
    macro_name:		VECTOR [2]	! MDL macro name for facility
			INITIAL(0,macro_buffer),
    message_number,			! Current message number
    symbol_buffer:	BBLOCK [symbol_bufsiz],	! Symbol name buffer
    symbol_name:	VECTOR [2]	! Symbol name descriptor
			INITIAL(0,symbol_buffer),
    severity_value,			! Severity for message
    faocnt_value,			! FAOCNT value
    ident_buffer:	BBLOCK [ident_bufsiz],	! IDENT string buffer
    ident_value:	VECTOR [2]	! IDENT descriptor
			INITIAL(0,ident_buffer),
    detail_value,			! DETAIL value
    lang_value,				! LANG numeric value (see $MSGDEF)
    userval_value,			! USERVAL value
    message_buffer:	BBLOCK [message_bufsiz], ! Message text buffer
    message_text:	VECTOR [2]	! Message text descriptor
			INITIAL(0,message_buffer),
    module_buffer:	BBLOCK [obj$c_symsiz],	! Module name string buffer
    literal_name:	VECTOR [2],	! Descriptor of literal symbol name
    literal_value,			! Value to be assigned to literal

    line_output:	BYTE,		! True if line was output
    new_line:		INITIAL(true);	! True if new line should be started for comment

LITERAL
    shared_bit = 0,			! /SHARED bit number
    shared_mask = 1,			! /SHARED mask
    system_bit = 1,			! /SYSTEM bit number
    system_mask = 2,			! /SYSTEM mask
    prefix_bit = 2,			! /PREFIX bit number
    prefix_mask = 4,			! /PREFIX mask
    macro_mask = 8,			! /MACRO mask
    literal_flag = 0;			! Indicate literal call to mdlgen or sdlgen

!
! External storage
!

EXTERNAL
    cli_flags:		BITVECTOR,	! CLI qualifier bitmap
    module_name:	VECTOR,		! Module name descriptor
    input_fab:		BBLOCK,		! Input file FAB
    input_rab:		BBLOCK;		! Input file RAB

!
! External routines
!

EXTERNAL ROUTINE
    line_with_value,			! Output a line with a hex value
    echo_record,			! Output a line w/only record
    new_page,				! Cause a page eject
    syntax_error,			! Report syntax error
    lib$tparse: ADDRESSING_MODE(GENERAL),	! Parsing routines
    lib$get_vm: ADDRESSING_MODE(GENERAL),	! Allocate dynamic storage
    lib$free_vm: ADDRESSING_MODE(GENERAL),	! Deallocate dynamic storage
    rms_error,				! Signal RMS-type error
    mdl_start_struc,			! Start structure definition
    mdl_define_constant,		! Define message or literal constant
    mdl_end_struc,			! End structure definition
    mdl_comment,			! Output a comment
    mdl_put_record,			! Output a record

    sdl_start_mod,			! Start SDL module definition
    sdl_define_constant,		! Define message or literal constant
    sdl_end_mod,			! End SDL module definition
    sdl_comment,			! Output a comment
    sdl_put_record;			! Output a record

!
!	Message definition language parse tables
!

MACRO ap_setup = BUILTIN AP; MAP ap: REF BBLOCK%;
ROUTINE set_number = (ap_setup; ap [tpa$l_number] = .ap [tpa$l_param]; true);
ROUTINE find_bracket = (ap_setup; BUILTIN CALLG; ap [tpa$l_char] = '>';
			callg(.ap, find_eos));
FORWARD ROUTINE init_stack;

$init_state(parse_states,parse_keys);	! Define start of parse table

!
!	Dispatch to the various command parsers
!

$state(,
	(tpa$_lambda,,init_stack));	! Init the stack each time thru

$state(,
	(tpa$_lambda,,message_init));	! Init message cells each time thru

$state(main,
	((contin),main,get_cont_line),
	('!',tpa$_exit,comment),
	(tpa$_eos,tpa$_exit),
	('.',directive),
	(tpa$_symbol,definition,store_string,,,
		PLIT(symbol_name,1,symbol_bufsiz)));

$state(directive,
	('FACILITY',facility,facility_init),
	('SEVERITY',severity),
	('LANGUAGE',language),
	('IDENT',ident1),
	('BASE',base),
	('LITERAL',literal_stmt),
	('PAGE',end_line,new_page),
	('TITLE',title),
	('END',end_line,facility_init));

!
!	Check for continuation line (trailing dash followed by eos or comment)
!

$state(contin,
	('-'));
$state(,
	('!',tpa$_exit,comment),
	(tpa$_eos,tpa$_exit));

!
!	Come here after command processed - check for end of string or comment
!

$state(end_line,
	((contin),end_line,get_cont_line),
	('!',tpa$_exit,comment),
	(tpa$_eos,tpa$_exit));

!
!	Process FACILITY command to set facility name and number
!

$state(facility,
	((contin),facility,get_cont_line),
	('/'),
	(tpa$_lambda,fac10));

$state(,
	((facil_qual),facility));

$state(fac10,
	(tpa$_symbol,,store_string,,,PLIT(facility_name,1,facility_bufsiz)));

$state(fac15,
	((contin),fac15,get_cont_line),
	(','),
	(tpa$_lambda));

$state(fac18,
	((contin),fac18,get_cont_line),
	((expression),,store_number,,,
		PLIT(facility_number,0,1^($FIELDWIDTH(sts$v_fac_no)-1)-1)));

$state(fac20,
	((contin),fac20,get_cont_line),
	('/'),
	(tpa$_lambda,end_line,facility_defn));

$state(,
	((facil_qual),fac20));

$state(facil_qual,
	('SHARED',tpa$_exit,,shared_mask,facility_flags),
	('SYSTEM',tpa$_exit,,system_mask,facility_flags),
	('PREFIX',fac_prefix),
	('MACRO',fac_macro));

$state(fac_prefix,
	('='),
	(':'));

$state(,
	(tpa$_symbol,tpa$_exit,store_string,,,
		PLIT(default_prefix,1,defpre_bufsiz)));

$state(fac_macro,
	('='),
	(':'));

$state(,
	(tpa$_symbol,tpa$_exit,store_string,,,
		PLIT(macro_name,1,macro_bufsiz)));

!
!	Parse .IDENT specification
!

$state( ident1,
	((contin),ident1,get_cont_line),
	(tpa$_symbol,ident2,build_version),
	('"', ident2,find_endvers),
	('''',ident2,find_endvers), 
	('/', ident2,find_endvers) );


$state( ident2,
	((contin),ident2,get_cont_line),
	(tpa$_lambda,end_line) );


!
!	Parse .SEVERITY command to set default severity
!

$state(severity,
	((contin),severity,get_cont_line),
	((parse_severity),end_line,store_number,,,
		PLIT(default_sev)));

!
!	Parse .BASE command to set new message number
!

$state(base,
	((contin),base,get_cont_line),
	((expression),end_line,store_number,,,
		PLIT(message_number,0,1^$FIELDWIDTH(sts$v_code)-1)));


!
!	Parse .LITERAL command to define literals
!

$state(literal_stmt,
	((contin),literal_stmt,get_cont_line),
	(tpa$_lambda,,set_number,,,1));		! Default 1st literal = 1

$state(,
	(tpa$_lambda,,store_number,,,PLIT(literal_value)));

$state(next_literal,
	((contin),next_literal,get_cont_line),
	(tpa$_symbol,,,,literal_name));

$state(,
	('='),
	(':'),
	(tpa$_lambda,set_literal));

$state(,
	((expression),,store_number,,,PLIT(literal_value)));

$state(set_literal,
	(tpa$_lambda,,define_literal));

$state(end_literal,
	(',',next_literal),
	(tpa$_lambda,end_line));

!
!	Parse .LANGUAGE command to set default language
!

$state(language,
	((contin),language,get_cont_line),
	((parse_lang),end_line,store_number,,,
		PLIT(default_lang)));

!
!	Parse .TITLE command
!

$state(title,
	((contin),title,get_cont_line),
	(tpa$_symbol,,set_module));

$state(title2,
	((contin),title2,get_cont_line),
	(tpa$_any,end_line,set_title),
!	(tpa$_symbol,end_line,set_title),
	(tpa$_lambda,end_line));

!
!	Parse message definition line
!

$state(definition,
	((contin),definition,get_cont_line),
	('/'),
	('<',def1,find_bracket),
	('"',def1,find_eos));

$state(,
	((def_qual),definition));

$state(def1,
	((contin),def1,get_cont_line),
	('/'),
	(tpa$_lambda,end_line,message_defn));

$state(,
	((def_qual),def1));

$state(def_qual,
	((parse_severity),tpa$_exit,store_number,,,
		PLIT(severity_value)),
	('FAO_COUNT',faocnt),
	('IDENTIFICATION',ident),
	('DETAIL',detail),
	('LANGUAGE',lang),
	('USER_VALUE',userval));

$state(faocnt,
	('='),
	(':'));

$state(,
	((expression),tpa$_exit,store_number,,,
		PLIT(faocnt_value,0,31)));

$state(ident,
	('='),
	(':'));

$state(,
	(tpa$_symbol,tpa$_exit,store_string,,,
		PLIT(ident_value,1,ident_bufsiz)));

$state(detail,
	('='),
	(':'));

$state(,
	((expression),tpa$_exit,store_number,,,
		PLIT(detail_value,0,255)));

$state(lang,
	('='),
	(':'));

$state(,
	((parse_lang),tpa$_exit,store_number,,,
		PLIT(lang_value)));

$state(userval,
	('='),
	(':'));

$state(,
	((expression),tpa$_exit,store_number,,,
		PLIT(userval_value,0,255)));

!
!	Translate the language keyword into a number
!

$state(parse_lang,
	('ENGLISH',tpa$_exit,set_number,,,mrec$c_english),
	('FRENCH',tpa$_exit,set_number,,,mrec$c_french),
	('GERMAN',tpa$_exit,set_number,,,mrec$c_german));

!
!	Translate the SEVERITY keyword into the severity number
!

$state(parse_severity,
	('FATAL',tpa$_exit,set_number,,,sts$k_severe),
	('SEVERE',tpa$_exit,set_number,,,sts$k_severe),
	('INFORMATIONAL',tpa$_exit,set_number,,,sts$k_info),
	('SUCCESS',tpa$_exit,set_number,,,sts$k_success),
	('ERROR',tpa$_exit,set_number,,,sts$k_error),
	('WARNING',tpa$_exit,set_number,,,sts$k_warning));



!
!	Expression evaluation
!

OWN
    estack:	VECTOR[50],	! Expression stack
    esp;			! Expression stack pointer

MACRO pop = (LOCAL temp; temp=..esp; esp=.esp+4; .temp)%;
MACRO push(value) = (esp=.esp-4; .esp=value)%;
MACRO save = (ap_setup; AP [tpa$l_number] = ..esp; true)%;

ROUTINE init_stack = (esp = estack[50]; true);
ROUTINE add2 = (.esp = pop + ..esp; save);
ROUTINE sub2 = (LOCAL temp; temp = pop; .esp = ..esp - .temp; save);
ROUTINE mul2 = (.esp = pop * ..esp; save);
ROUTINE div2 = (LOCAL temp; temp = pop; .esp = ..esp / .temp; save);
ROUTINE shift2 = (LOCAL temp; temp = pop; .esp = ..esp ^ .temp; save);
ROUTINE neg1 = (.esp = - ..esp; save);
ROUTINE push_constant = (ap_setup; push(.ap[tpa$l_number]); true);
ROUTINE push_symbol = (ap_setup; esp=.esp-4;
		IF lookup_symbol (ap [tpa$l_tokencnt],.esp)
		THEN BEGIN save; RETURN true; END
		ELSE RETURN false;);

$state(expression,
	((term)));
$state(,
	('+',addition),
	((subtraction),tpa$_exit),	! Only if followed by valid expression
					! to allow for continuation dash (-)
	(tpa$_lambda,tpa$_exit));

$state(addition,
	((expression),tpa$_exit,add2));

$state(subtraction,
	('-'));
$state(,
	((expression),tpa$_exit,sub2));

$state(term,
	((factor)));
$state(,
	('@',arith_shift),
	('*',multiplication),
	((division),tpa$_exit),		! Only if followed by valid term
					! to allow for qualifier slash (/)
	(tpa$_lambda,tpa$_exit));

$state(arith_shift,
	((term),tpa$_exit,shift2));

$state(multiplication,
	((term),tpa$_exit,mul2));

$state(division,
	('/'));
$state(,
	((term),tpa$_exit,div2));

$state(factor,
	('-',negate),
	('(',parens),
	((constant),tpa$_exit,push_constant),
	(tpa$_symbol,tpa$_exit,push_symbol));

$state(negate,
	((factor),tpa$_exit,neg1));

$state(parens,
	((expression)));
$state(,
	(')',tpa$_exit));

$state(constant,
	('+',constant),
	('^',radix),
	((decimal),tpa$_exit));

$state(radix,
	('O',octal),
	('X',hex),
	('D',decimal));

$state(octal,
	(tpa$_octal,tpa$_exit));

$state(hex,
	(tpa$_hex,tpa$_exit));

$state(decimal,
	(tpa$_decimal,tpa$_exit));

GLOBAL ROUTINE parse_file =

!---
!
!	This routine performs the parsing on the already open
!	input file of message definitions.
!
! Inputs:
!
!	None
!
! Outputs:
!
!	Various control blocks describing the definitions.
!	(see $MSGDEF)
!---

BEGIN

LOCAL
    status;			! Status code

IF .num_files EQL 0		! First file processed
THEN BEGIN

     facility_init();		! Initialize facility cells

     input_linenum = 0;		! Zero input line number

     title_text [0] = 19;	! Length of default title
     CH$MOVE(.title_text [0], UPLIT('Message definitions'), .title_text [1]);

     END;

num_files = .num_files + 1;	! Increment total files parsed

new_page();			! Page eject on each new file

WHILE get_record()
DO
    BEGIN
    tparse_block [tpa$l_stringcnt] = .input_record [0];
    tparse_block [tpa$l_stringptr] = .input_record [1];

    status = lib$tparse(tparse_block,parse_states,parse_keys);
    IF NOT .status		! If syntax error detected,
    THEN
	BEGIN
	MAP status: BBLOCK;	! Get at fields
	IF NOT .status [sts$v_inhib_msg]	! If not yet signaled
	THEN
	    syntax_error(tparse_block,emsg(syntax),tparse_block [tpa$l_tokencnt]);
	END
    ELSE
	IF NOT .line_output	! If line not yet output,
	THEN
	    echo_record();	! then echo the input record
    END;

IF .cli_flags [qual_mdl] 	! Output last buffered line of MDL file
THEN mdl_put_record ( UPLIT (0, UPLIT(0) ), true );

IF .cli_flags [qual_sdl] 	! Output last buffered line of SDL file
THEN 
    sdl_put_record ( UPLIT (0, UPLIT(0) ), true );

RETURN true;

END;

ROUTINE get_record =

!---
!
!	This routine gets the next input record and upcases
!	the record if necessary.
!
! Inputs:
!
!	input_rab = Input RAB block
!
! Outputs:
!
!	input_record = Descriptor of input record
!
!	r0 = status (already signaled if error)
!---

BEGIN

OWN
    buffer:	VECTOR [256,BYTE];	! Upcased input record

LOCAL
    status;

status = $GET (RAB = input_rab);	! Get next record

IF NOT .status			! If error detected,
THEN
    BEGIN
    IF .status NEQ rms$_eof	! If unexpected GET error,
    THEN
	rms_error(emsg(readerr),input_fab,input_rab);

    RETURN .status;		! return with status
    END;

input_linenum = .input_linenum + 1;	! Increment input line number
line_output = false;		! Mark line not yet output

IF .input_rab [rab$w_rsz] GEQ 1		! If at least 1 character,
    AND .(.input_rab [rab$l_rbf])<0,8> EQL form_feed ! and if char = FF,
THEN
    BEGIN
    new_page();			! Cause page eject
    input_rab [rab$w_rsz] = .input_rab [rab$w_rsz] - 1;
    input_rab [rab$l_rbf] = .input_rab [rab$l_rbf] + 1;
    END;

INCR i FROM 0 TO .input_rab [rab$w_rsz]-1
DO
    BEGIN
    BIND
	old = .input_rab [rab$l_rbf]: VECTOR[,BYTE];
    buffer [.i] = .old [.i];
    SELECTONEU .old [.i] OF
	SET
	['a' TO 'z']: buffer [.i] = .buffer [.i] + ('A'-'a');

	['<','"']:
		BEGIN
		LOCAL p,len;
		p = CH$FIND_CH(.input_rab [rab$w_rsz]-1-.i, old [.i+1],
			(IF .old [.i] EQL '<' THEN '>' ELSE '"'));
		IF .p NEQ 0			! If terminator found,
		THEN
		    BEGIN
		    len = .p - old [.i];	! length to skip over
		    CH$MOVE(.len, old [.i+1], buffer [.i+1]);
		    i = .i + .len;		! then skip to terminator+1
		    END;
		END;
	TES;
    END;

input_record [0] = .input_rab [rab$w_rsz];
input_record [1] = buffer;

RETURN true;

END;

ROUTINE message_init =

!---
!
!	This routine initializes all the local variables set
!	during parsing of a message definition line so that
!	nothing is taken from a previous definition.
!
! Inputs:
!
!	See OWN storage in the module header.
!
! Outputs:
!
!	Same
!---

BEGIN

symbol_name [0] = 0;			! Clear length of symbol name
severity_value = -1;			! Set to illegal value
lang_value = .default_lang;		! Set current language default
faocnt_value = 0;			! Default is 0
ident_value [0] = 0;			! Default is use symbol_name
detail_value = 0;			! Default is 0
userval_value = 0;			! Default is 0

RETURN true;

END;

ROUTINE message_defn =

!---
!
!	This routine processes the information stored by the
!	TPARSE action routines and created the necessary message
!	definition blocks to store the data.
!
! Inputs:
!
!	See OWN storage in the module header.
!
! Outputs:
!
!	Control blocks are allocated and linked into the
!	message definitions.
!---

BEGIN

BUILTIN
    AP,					! Address of tparse block
    INSQUE;				! Insert into linked list

MAP
    ap: REF BBLOCK;

LOCAL
    code:	REF BBLOCK,		! Address of CODE block
    status,
    msglen;				! Length of MSG block

!
!	Check size of global symbol name.  This must be done
!	here because it is made up of the 2 separate strings.
!

IF .symbol_name [0] + .default_prefix [0] GTR sym_plus_pre
THEN
    RETURN(syntax_error(.ap,emsg(symtoolng)));	! then signal it

!
!	Default any unspecified values
!

IF .ident_value [0] EQL 0		! If /IDENT not specified,
THEN
    BEGIN
    ident_value [0] = .symbol_name [0];	! then use symbol name
    IF .ident_value [0] GTR ident_bufsiz ! If symbol larger than max. ident
    THEN
	ident_value [0] = ident_bufsiz;	! then truncate to maximum size
    CH$MOVE(.ident_value [0], .symbol_name [1], .ident_value [1]);
    END;

!
!	Allocate the space for the definition
!

msglen = mrec$c_fixedlen + .ident_value [0] + .message_text [0] + 2;
IF .msglen AND 1			! If not on word boundary
THEN
    msglen = .msglen + 1;		! Force to word boundary

IF NOT allocate(code$c_length+.msglen,code)	! Allocate block
THEN					! and signal any error
    RETURN true;			! Return no syntax error

!
!	Setup the fields of the CODE/MSG block
!

BEGIN

LOCAL
    symbol_buffer: VECTOR [symbol_bufsiz,BYTE],	! Global symbol name
    symbol_desc: VECTOR [2];		! Descriptor of above symbol

BIND
    msg = code [code$c_msg,0,0,0]: BBLOCK,	! MSG block is hung off CODE block
    msg_code = code [code$l_number]: BBLOCK;	! To get at STS fields

code [code$l_number] = 0;			! Preset longword
msg_code [sts$v_fac_no] = .facility_number;	! Set facility number
msg_code [sts$v_code] = .message_number;	! Set message number

IF .severity_value LSS 0		! If severity unspecified,
THEN
    IF .default_sev GEQ 0		! If default severity specified,
    THEN
        severity_value = .default_sev	! use default severity
    ELSE
        BEGIN				! Else,
	syntax_error(.ap,emsg(nosever));	! signal unspecified severity level
	severity_value = sts$k_error;	! use error to keep going
	END;

msg_code [sts$v_severity] = .severity_value;	! Set severity

IF NOT .facility_flags [shared_bit]	! If /SHARED,
THEN
    msg_code [sts$v_fac_sp] = true;	! then this is facility specific

CH$COPY(.default_prefix[0], .default_prefix [1],
	.symbol_name [0], .symbol_name [1],
	0, sym_plus_pre, symbol_buffer);	! Copy symbol name

symbol_desc [0] = .default_prefix [0] + .symbol_name [0]; ! Setup descriptor
symbol_desc [1] = symbol_buffer;

status = add_symbol(symbol_desc, .code [code$l_number]); ! Add to symbol table

IF NOT .status				! If error detected,
THEN
    BEGIN
    deallocate(code$c_length+.msglen, .code);	! Send CODE block back
    RETURN true;			! then return, error already signaled
    END;

CH$FILL(0,.msglen,msg);			! Zero MSG block
msg [mrec$w_size] = .msglen;		! Set length of block
msg [mrec$b_flags] = 0;			! Initialize flags
msg [mrec$b_level] = .detail_value;	! Set detail level value
msg [mrec$b_faocnt] = .faocnt_value;	! Set FAO count value
msg [mrec$b_userval] = .userval_value;	! Set user value
msg [mrec$b_lang] = .lang_value;		! Set language number
msg [mrec$b_identlen] = .ident_value [0];! Set ident string (ASCIC)
CH$MOVE(.ident_value[0], .ident_value[1], msg [mrec$t_ident]);
msg [mrec$c_fixedlen + .ident_value [0]+1,0,8,0] =
	.message_text [0];		! Set message text string (ASCIC)
CH$MOVE(.message_text [0], .message_text [1],
	msg [mrec$c_fixedlen+.ident_value[0]+2,0,0,0]);
END;

status = add_message (.code);		! Add message to linked list

IF NOT .status				! If error detected,
THEN
    BEGIN
    deallocate(code$c_length+.msglen, .code);	! Send CODE block back
    RETURN true;			! return, error already signaled
    END;

msg_space = .msg_space + .msglen;	! Total all space used by MSG blocks
num_messages = .num_messages + 1;	! Count number of messages in list
message_number = .message_number + 1;	! Skip to next message number

IF .cli_flags [qual_mdl]		! If /MDL specified, then define a constant
THEN BEGIN
     mdl_define_constant (symbol_name, code [code$l_number], (NOT literal_flag), .ap);
     IF .ap [tpa$l_stringcnt] NEQ 0	! Still a comment left to parse in this record 
     THEN new_line = false;		! Do not start a new line for any comment
     END;

IF .cli_flags [qual_sdl]		! If /SDL specified, then define a constant
THEN BEGIN
     sdl_define_constant (symbol_name, code [code$l_number], (NOT literal_flag), .ap);
     IF .ap [tpa$l_stringcnt] NEQ 0	! Still a comment left to parse in this record 
     THEN new_line = false;		! Do not start a new line for any comment
     END;

line_with_value (.code [code$l_number]); ! Output line w/msg number
line_output = true;			! Mark line already output

RETURN true;

END;

ROUTINE add_message (code) =

!---
!
!	This routine adds the specified CODE definition block
!	to the linked list.
!
! Inputs:
!
!	code = Address of CODE block
!	tparse_block = Address of TPARSE block
!	message_header = List head of CODE list
!
! Outputs:
!
!	r0 = status (already signaled)
!
!---

BEGIN

MAP
    code:	REF BBLOCK;		! Address of CODE block

LOCAL
    ptr:	REF BBLOCK,		! Current position in linked list
    prev:	REF BBLOCK;		! Previous entry in linked list

prev = message_header;			! Start at list head
ptr = .prev [code$l_link];		! First entry in list

WHILE .ptr NEQ 0			! Until we reach end of list,
DO
    BEGIN
    IF (.ptr [code$l_number] AND sts$m_cond_id) GEQU 
	(.code [code$l_number] AND sts$m_cond_id)	! If found position,
    THEN
	EXITLOOP;			! then exit the search
    prev = .ptr;			! Save address of previous entry
    ptr = .ptr [code$l_link];		! Skip to next entry
    END;

IF .ptr NEQ 0
    AND ((.ptr [code$l_number] AND sts$m_cond_id) EQL
	(.code [code$l_number] AND sts$m_cond_id))	! If already there,
THEN
    BEGIN
    BIND msg = ptr [code$c_msg,0,0,0]: BBLOCK;	! Access msg defn block
    syntax_error(tparse_block, 		! signal dup error
		emsg(dupmsg), .code [code$l_number],
		.msg [mrec$b_identlen], msg [mrec$t_ident]);
    RETURN emsg(dupmsg);
    END;

code [code$l_link] = .prev [code$l_link];	! Link into list
prev [code$l_link] = .code;

RETURN true;

END;

ROUTINE facility_init =

!---
!	This routine initializes the various OWN cells
!	so that no data is left over from the previous
!	facility.
!
! Inputs:
!
!	See OWN storage in module header.
!
! Outputs:
!
!	Same
!---

BEGIN

facility_number = 0;			! Clear facility number
facility_name [0] = 0;			! and name
facility_flags = 0;			! Clear flags
message_number = 1;			! Start at message 1 (default)
default_sev = -1;			! Mark no severity defined yet
default_prefix [0] = 0;			! No default prefix

IF .cli_flags [qual_mdl] 
THEN BEGIN
     mdl_end_struc ();			! If /MDL specified, then end structure
     END;

IF .cli_flags [qual_sdl] 
THEN BEGIN
     sdl_end_mod ();			! If /SDL specified, then end module
     END;

RETURN true;

END;

ROUTINE facility_defn =

!---
!
!	This routine generates the necessary control blocks
!	to describe a newly defined facility.
!
! Inputs:
!
!	See OWN storage in module header.
!
! Outputs:
!
!	The FAC descriptor block is generated.
!---

BEGIN

BUILTIN
    AP;

MAP
    ap: REF BBLOCK;

LOCAL
    status,
    fac:	REF BBLOCK;		! Address of FAC block

!
!	Do not allow a facility number other than 0 with /SHARED
!

IF .facility_flags [shared_bit] AND .facility_number NEQ 0
THEN
    BEGIN
    syntax_error(.ap, emsg(sharconf));	! Signal syntax error
    RETURN true;			! return no syntax error
    END;

!
!	Allocate memory for FAC block and fill it
!

IF NOT allocate(fac$c_length,fac)	! Allocate block
THEN					! and signal any error
    RETURN true;			! Return no syntax error

IF NOT .facility_flags [system_bit]	! If not /SYSTEM,
THEN
    facility_number = .facility_number
	 OR (sts$m_cust_def ^ -$BITPOSITION(sts$v_fac_no));

fac [fac$w_number] = .facility_number;	! Set facility number
fac [fac$b_namelen] = .facility_name [0];	! Set name length
CH$MOVE(.facility_name [0], .facility_name [1],	! Set string into block
	fac [fac$t_name]);

IF .macro_name [0] NEQ 0 		! If /MACRO specified
THEN facility_flags = .facility_flags OR macro_mask;

IF .ap [tpa$l_stringcnt] NEQ 0		! Still a comment left in record
THEN new_line = false;			! Do not start a new line for a comment

IF .default_prefix [0] EQL 0		! If no default prefix specified,
THEN
    BEGIN
    LOCAL delimdesc:	VECTOR [2];

    delimdesc [0] = 2;
    delimdesc [1] = UPLIT('$_');	! Set delimiter to '$_'

    IF .cli_flags [qual_mdl]		! If /MDL specified, then start structure
    THEN BEGIN
	 mdl_start_struc (facility_name, .facility_number, macro_name, facility_flags);
	 END;

    IF .cli_flags [qual_sdl]		! If /SDL specified, then start module
    THEN BEGIN
	 sdl_start_mod (facility_name, .facility_number, macro_name, facility_flags);
	 END;

    IF NOT .facility_flags [system_bit]	! If user facility,
    THEN
	BEGIN
	delimdesc [0] = .delimdesc [0] - 1; ! Use '_' as delimiter
	delimdesc [1] = .delimdesc [1] + 1;
	END;

    default_prefix [0] = .facility_name [0] + .delimdesc [0];
    default_prefix [1] = prefix_buffer;
    CH$COPY(.facility_name [0], .facility_name [1], ! Setup default prefix
	.delimdesc [0], .delimdesc [1],
	0, prefix_bufsiz, prefix_buffer);
    END

ELSE BEGIN
     facility_flags = .facility_flags OR prefix_mask;

     IF .cli_flags [qual_mdl] 		! If /MDL specified, then start structure
     THEN BEGIN
	  mdl_start_struc (default_prefix, .facility_number, macro_name, facility_flags );
	  END;

     IF .cli_flags [qual_sdl] 		! If /SDL specified, then start structure
     THEN BEGIN
	  sdl_start_mod (default_prefix, .facility_number, macro_name, facility_flags );
	  END;

     END;

BEGIN
LOCAL
    name_buffer:VECTOR [obj$c_symsiz,BYTE],
    name_desc:	VECTOR [2];

CH$COPY(.fac [fac$b_namelen], fac [fac$t_name],	! Make fac$_FACILITY name
	10, UPLIT('$_FACILITY'),
	0, obj$c_symsiz, name_buffer);
name_desc [0] = .fac [fac$b_namelen] + 10;	! Make descriptor of name
name_desc [1] = name_buffer;
IF NOT lookup_symbol(name_desc, status)	! If not already in symbol table,
THEN
    BEGIN
    status = add_symbol(name_desc, .fac [fac$w_number]); ! Add to symbol table
    IF NOT .status			! If error detected,
    THEN
        BEGIN
        deallocate(fac$c_length,.fac);	! Send FAC block back
        RETURN true;			! return, error already signaled
        END;
    END;
END;

line_with_value (.fac [fac$w_number]);	! Output line w/fac number
line_output = true;			! Mark line already output

status = add_facility(.fac);		! Add facility to facility list

IF NOT .status				! If error detected,
THEN
    BEGIN
    deallocate(fac$c_length,.fac);	! Send FAC block back
    RETURN true;
    END;

num_facilities = .num_facilities + 1;	! Increment facilities in list
fac_space = .fac_space + $BYTEOFFSET(mfac$t_name) + .facility_name [0];
					! Add space to facility table
RETURN true;

END;

ROUTINE add_facility (fac) = 

!---
!
!	This routine adds a specified facility definition
!	block (FAC) to the defined facility list.
!
! Inputs:
!
!	fac = Address of FAC block
!	tparse_block = Address of TPARSE block
!	facility_header = List head for defined facilities
!
! Outputs:
!
!	r0 = status (already signaled)
!
!---

BEGIN

MAP
    fac:	REF BBLOCK;		! Address of FAC block

LOCAL
    ptr:	REF BBLOCK,		! Current position in linked list
    prev:	REF BBLOCK;		! Previous entry in linked list

prev = facility_header;			! Start at list head
ptr = .prev [fac$l_link];		! First entry in list

WHILE .ptr NEQ 0			! Until we reach end of list
DO
    BEGIN
    IF .ptr [fac$w_number] GEQU .fac [fac$w_number]	! If found position,
    THEN
	EXITLOOP;			! then exit the search
    prev = .ptr;			! Save address of previous entry
    ptr = .ptr [fac$l_link];		! Skip to next entry
    END;

IF .ptr NEQ 0
    AND .ptr [fac$w_number] EQL .fac [fac$w_number]	! If already defined,
THEN
    BEGIN
    IF CH$NEQ(.fac [fac$b_namelen], fac [fac$t_name],
		.ptr [fac$b_namelen], ptr [fac$t_name], 0)
					! and the facility names are different
	AND .fac [fac$w_number] NEQ 0	! excluding facility number 0
    THEN
        syntax_error(tparse_block,	! signal facility conflict error
		emsg(conffac),
		.fac [fac$w_number],
		.ptr [fac$b_namelen],ptr [fac$t_name]);
    RETURN emsg(conffac);
    END;

fac [fac$l_link] = .prev [fac$l_link];	! Link into facility list
prev [fac$l_link] = .fac;

RETURN true;

END;

ROUTINE add_symbol (name_desc, value) =

!---
!
!	This routine adds a given symbol name and value to
!	the symbol table.
!
! Inputs:
!
!	name_desc = Address of descriptor of symbol name
!	value = Value to be assigned to the symbol
!
! Outputs:
!
!	r0 = status (already signaled)
!---

BEGIN

MAP
    name_desc:	REF VECTOR;		! Address of name descriptor

LOCAL
    entry:	REF BBLOCK,		! Address of symbol table entry
    status;

IF lookup_symbol (.name_desc, status)	! If already in symbl table,
THEN
    BEGIN
    syntax_error(tparse_block,emsg(dupsym));
    RETURN emsg(dupsym);		! return duplicate symbol
    END;

IF .name_desc [0] GTRU obj$c_symsiz	! If symbol length GTR max,
THEN
    name_desc [0] = obj$c_symsiz;	! then truncate it

status = allocate(sym$c_length,entry);	! Allocate a symbol entry

IF NOT .status				! If could not allocate storage,
THEN
    BEGIN
    syntax_error(tparse_block,.status);
    RETURN .status;			! return with status (already signaled)
    END;

entry [sym$l_value] = .value;		! Set value of symbol
entry [sym$b_symlen] = .name_desc [0];	! Set length of symbol
CH$MOVE(.name_desc [0], .name_desc [1], entry [sym$t_symbol]);

entry [sym$l_link] = .symbol_header;	! Link into front of symbol table list
symbol_header = .entry;

RETURN true;

END;

ROUTINE lookup_symbol (name_desc, value) =

!---
!
!	This routine looks up a given symbol in the symbol
!	table and returns the value associated with it.
!
! Inputs:
!
!	name_desc = Descriptor of desired symbol name
!	value = Address of longword to receive value if found
!
! Outputs:
!
!	value = Value of symbol if found
!	r0 = status
!---

BEGIN

MAP
    name_desc:	REF VECTOR;		! Address of descriptor

LOCAL
    ptr:	REF BBLOCK;		! Pointer into list

ptr = .symbol_header;			! Start at first entry

WHILE .ptr NEQ 0			! Until end of list
DO
    BEGIN
    IF CH$EQL(.ptr [sym$b_symlen], ptr [sym$t_symbol],
		.name_desc [0], .name_desc [1])
    THEN
	BEGIN
	.value = .ptr [sym$l_value];	! Return value of symbol
	RETURN true;			! and exit successful
	END;
    ptr = .ptr [sym$l_link];		! If no match, go to next entry
    END;

RETURN false;				! return symbol not found

END;

ROUTINE find_eos =

!---
!
!	This action routine finds the end of the message text string.
!	It uses the first character of the token (tpa$l_char) as the
!	string terminator - other routines may place a specific
!	terminator in tpa$l_char and call this routine.  The descriptor
!	of the message text is stored away.
!
! Inputs:
!
!	tpa$l_char = String terminator
!
! Outputs:
!
!	message_text = Descriptor of actual message text
!---

BEGIN

BUILTIN AP,CALLG;
MAP ap: REF BBLOCK;

LOCAL p;			! Temporary string pointer

p = CH$FIND_CH(.ap [tpa$l_stringcnt], .ap [tpa$l_stringptr], .ap [tpa$l_char]);
IF .p EQL 0			! If terminator not found,
THEN
    RETURN false;		! then return syntax error

ap [tpa$l_tokencnt] = .p - .ap [tpa$l_stringptr];
ap [tpa$l_tokenptr] = .ap [tpa$l_stringptr];
ap [tpa$l_stringcnt] = .ap [tpa$l_stringcnt] - (.ap [tpa$l_tokencnt]+1);
ap [tpa$l_stringptr] = .ap [tpa$l_tokenptr] + (.ap [tpa$l_tokencnt]+1);

ap [tpa$l_param] = PLIT(message_text,0,message_bufsiz);
CALLG(.ap, store_string)	! Call store string with tparse_block

END;

ROUTINE find_endvers =

!++
!
!	This routine finds the end of the version (.IDENT) text string.
!	It uses the first character of the token (tpa$l_char) as the
!	string terminator.  The descriptor of the ident string is stored.
!
!  Inputs:
!
!	tpa$l_char -- string terminator
!
!  Outputs:
!
!	version_num -- descriptor of version string
!
!--

BEGIN

BUILTIN AP, CALLG;
MAP ap: REF BBLOCK;

LOCAL p;			!temporary string pointer

p = CH$FIND_CH(.ap[tpa$l_stringcnt], .ap[tpa$l_stringptr], .ap[tpa$l_char]);

IF .p EQL 0			! If terminator not found...
THEN
    RETURN FALSE;		!  then signal syntax error

ap [tpa$l_tokencnt] = .p - .ap [tpa$l_stringptr];
ap [tpa$l_tokenptr] = .ap [tpa$l_stringptr];
ap [tpa$l_stringcnt] = .ap [tpa$l_stringcnt] - (.ap [tpa$l_tokencnt]+1);
ap [tpa$l_stringptr] = .ap [tpa$l_tokenptr] + (.ap [tpa$l_tokencnt]+1);

ap [tpa$l_param] = PLIT(version_num,0,obj$c_symsiz);
CALLG(.ap, store_string)	! Call store string with tparse_block

END;

ROUTINE get_cont_line =

!---
!
!	This routine is called as an action routine if
!	a dash (-) is the last token on the line before
!	a comment or end of line.  The next record is
!	retrieved and the tparse block is updated so that
!	parsing continues with the continuation line.
!
! Inputs:
!
!	ap = tparse block
!
! Outputs:
!
!	tparse block is updated
!---

BEGIN

BUILTIN
    AP;				! Address of tparse block

MAP
    AP:		REF BBLOCK;	! Address as structure

LOCAL
    count,			! Count of characters passed over
    status;			! status code

IF NOT .line_output		! If line not yet output,
THEN
    echo_record();		! then echo the input record

status = get_record();		! Get next record from input stream
IF NOT .status			! If error detected,
THEN
    RETURN .status;		! return with status

ap [tpa$l_stringcnt] = .input_record [0];
ap [tpa$l_stringptr] = .input_record [1];

RETURN true;

END;

ROUTINE define_literal =

!---
!
!	This routine adds a user specified literal to the
!	symbol table to be output in the object module.
!
! Inputs:
!
!	literal_name = Descriptor of symbol name
!	literal_value = Value to assign to the symbol
!
! Outputs:
!
!	literal_value has been automatically incremented by one
!		to provide default for next literal parameter.
!---

BEGIN

BUILTIN
    AP;					! Address of tparse block

MAP
    ap: REF BBLOCK;

IF NOT add_symbol (literal_name, .literal_value) ! add to symbol table
THEN
    RETURN true;			! return, error already signaled

IF .cli_flags [qual_mdl] 		! If /MDL specified, then define a constant
THEN BEGIN
     mdl_define_constant (literal_name, literal_value, literal_flag, tparse_block);
     IF .ap [tpa$l_stringcnt] NEQ 0	! Still a comment left in record
     THEN new_line = false;		! Do not start a new line for a comment
     END;

IF .cli_flags [qual_sdl] 		! If /SDL specified, then define a constant
THEN BEGIN
     sdl_define_constant (literal_name, literal_value, literal_flag, tparse_block);
     IF .ap [tpa$l_stringcnt] NEQ 0	! Still a comment left in record
     THEN new_line = false;		! Do not start a new line for a comment
     END;

literal_value = .literal_value + 1;	! Autoincrement for next symbol

RETURN true;

END;

ROUTINE set_title =

!---
!
!	This routine saves the string from the current position
!	to the end of the line as the listing title.
!
! Inputs:
!
!	tpa$l_tokenptr = Address of start of title string
!
! Outputs:
!
!	title_text = Descriptor of title text
!---

BEGIN

BUILTIN
    AP,CALLG;

MAP
    AP:		REF BBLOCK;		! Address of tparse block

ap [tpa$l_tokencnt] = .input_record [1] + .input_record [0] -
		.ap [tpa$l_tokenptr];
ap [tpa$l_stringcnt] = 0;		! Gobble rest of line

ap [tpa$l_param] = PLIT(title_text,0,title_bufsiz); ! Place to store text
CALLG(.ap,store_string)			! Call store string and save it

END;

ROUTINE set_module =

!---
!
!	This routine saves the current token as the module name.
!
! Inputs:
!
!	tpa$l_tokenptr = Descriptor of module name
!
! Outputs:
!
!	module_name = Descriptor of module name
!---

BEGIN

BUILTIN AP,CALLG;

MAP AP:		REF BBLOCK;		! Address of tparse block

module_name [1] = module_buffer;	! Set address of buffer
ap [tpa$l_param] = PLIT(module_name,1,obj$c_symsiz); ! Place to store text
CALLG(.ap,store_string)			! Call store string and save it

END;

ROUTINE build_version =

!---
!
!	This routine builds a version or ident string for the 
!	 	message object file. 
!
! Inputs:
!
!	tpa$l_tokenptr = Pointer to current version character
!
! Outputs:
!
!	version_num = Descriptor of version string
!---

BEGIN

BUILTIN
    AP,CALLG;

MAP 
    ap:		REF BBLOCK;		! Address of tparse block

version_num [1] = version_buffer;
ap[tpa$l_param] = PLIT (version_num,0,obj$c_symsiz);
CALLG(.ap,store_string);

RETURN true;

END;

ROUTINE store_number =

!---
!
!	This routine stores the numeric value of a qualifier
!	into a specified location as long as it is within
!	certain limits.  If not, a syntax error is signaled.
!
! Inputs:
!
!	tpa$l_number = Number to be stored
!	tpa$l_param = Address of a 3-longword argument list:
!			1) Address of longword to receive value
!			2) Minimum legal value (unsigned)
!			3) Maximum legal value (unsigned)
!		If 2nd and 3rd arguments are not specified, no
!			checking will be done.
!
! Outputs:
!
!	Either the number is stored or an error is signaled.
!---

BEGIN

BUILTIN
    AP;					! Register AP

MAP
    AP:		REF BBLOCK;		! Define TPARSE block format

LOCAL
    args:	REF VECTOR,		! Address of argument list
    value;				! Value of expression

args = .ap [tpa$l_param]-4;		! Get address of arguments
					! (PLIT value is addr of FIRST arg)

value = .ap [tpa$l_number];		! Get value
IF .args [0] GEQ 2			! If 2nd, 3rd args specified,
THEN IF .value LSSU .args [2]		! If less than minimum
    OR .value GTRU .args [3]		! or greater than maximum,
THEN
    RETURN(syntax_error(.ap,emsg(badvalue)));	! then signal illegal value

.args [1] = .value;			! Store value into longword

RETURN true;

END;

ROUTINE store_string =

!---
!
!	This routine stores the string value of a qualifier
!	into a specified location as long as the length is within
!	certain limits.  If not, a syntax error is signaled.
!
! Inputs:
!
!	tpa$l_tokencnt/ptr = String to be stored
!	tpa$l_param = Address of a 3-longword argument list:
!			1) Address of descriptor were the string
!				length is stored in the first longword
!				and the second longword is the place to
!				store the string.
!			2) Minimum legal length (unsigned)
!			3) Maximum legal length (unsigned)
!
! Outputs:
!
!	Either the string is stored or an error is signaled.
!---

BEGIN

BUILTIN
    AP;					! Register AP

MAP
    AP:		REF BBLOCK;		! Define TPARSE block format

LOCAL
    args:	REF VECTOR,		! Address of argument list
    dest:	REF VECTOR,		! Address of descriptor
    length;				! Length of string

args = .ap [tpa$l_param]-4;		! Get address of arguments
					! (PLIT value is addr of FIRST arg)

length = .ap [tpa$l_tokencnt];		! Get length
IF .args [0] GEQ 2			! If 2nd, 3rd args specified,
THEN IF .length LSSU .args [2]		! If less than minimum
    OR .length GTRU .args [3]		! or greater than maximum,
THEN
    RETURN(syntax_error(.ap,emsg(symtoolng)));	! then signal illegal value

dest = .args [1];			! Get address to store descriptor
dest [0] = .ap [tpa$l_tokencnt];	! Store descriptor into quadword
CH$MOVE(.ap [tpa$l_tokencnt], .ap [tpa$l_tokenptr], .dest [1]);

RETURN true;

END;

GLOBAL ROUTINE allocate (bytes, address) =

!---
!
!	Allocate dynamic storage and return the address.
!	If an error occurs, the error is signaled.
!
! Inputs:
!
!	bytes = Number of bytes to allocate
!	address = Longword to receive address of storage
!
! Outputs:
!
!	address = Address of storage
!---

BEGIN

LOCAL
    status;

status = lib$get_vm(bytes,.address);

IF NOT .status			! if unsuccessful,
THEN
    SIGNAL(.status);		! then signal the error

RETURN .status;			! return with status;

END;

GLOBAL ROUTINE deallocate (bytes, address) =

!---
!
!	Deallocate dynamic storage.
!	If an error occurs, the error is signaled.
!
! Inputs:
!
!	bytes = Number of bytes to deallocate
!	address = Address of storage to deallocate
!
! Outputs:
!
!	None
!---

BEGIN

LOCAL
    status;

status = lib$free_vm(bytes,address);

IF NOT .status			! if unsuccessful,
THEN
    SIGNAL(.status);		! then signal the error

RETURN .status;			! return with status;

END;

GLOBAL ROUTINE comment =

!---
!
!	If MDL or SDL file is being generated, then output a
!	comment record for the appropriate file.
!
! Inputs:
!
!	All inputs are drawn from tparse_block.
!
! Outputs:
!
!	None
!
!---

BEGIN

LOCAL
     comment_desc:    VECTOR[2];			! Comment descriptor

IF ( NOT .cli_flags [qual_mdl] ) AND			! If not generating MDL
   ( NOT .cli_flags [qual_sdl] )			!   and not gen'ing SDL
THEN							!   then exit
    RETURN true;

comment_desc[0] = .tparse_block[tpa$l_stringcnt];	! Initialize comment_desc
comment_desc[1] = .tparse_block[tpa$l_stringptr];

IF .cli_flags [qual_mdl]
THEN
    mdl_comment (comment_desc,				! Call mdl_comment with string
	     .new_line);

IF .cli_flags [qual_sdl]
THEN
    sdl_comment (comment_desc,				! Call sdl_comment with string
	     .new_line);

new_line = true;					! Reset new comment line indicator

RETURN true;

END;

END
ELUDOM
