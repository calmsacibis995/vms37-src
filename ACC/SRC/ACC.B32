MODULE
ACC (IDENT = 'V03-005', MAIN = ACC) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY:  ACC, Account file dumper
!
! ABSTRACT:
!
!	This utility dumps the system accounting file in a readable, labelled
!	format, and allows searching for particular entries.  Also, two
!	binary output files may be created containing the selected and
!	unselected records respectively.
!
! ENVIRONMENT:
!
!	VAX/VMS operating system. unprivileged user mode,
!
! AUTHOR:  Greg Robert and Steve Forgey, January 1982
!
! Modified by:
!
!	V03-005	SPF0113		Steve Forgey	19-Apr-1982
!		Don't use RETURN_IF_ERROR macro where the variable STATUS
!		is already defined.
!
!	V03-004	SPF0112		Steve Forgey	10-Apr-1982
!		Format pre-Version 3 queue names as counted ASCII strings.
!
!	V03-003	SPF0105		Steve Forgey	27-Mar-1982
!		Get input file defaults from previous input file specs.
!
!	V03-002	SPF0104		Steve Forgey	27-Mar-1982
!		Specify correct max record size to SOR$INIT_SORT.
!
!	V03-001	SPF0102		Steve Forgey	27-Mar-1982
!		Don't add null value to selection list when parsing the
!		exclusion qualifier, "-".
!
!	V02-002	SPF0081		Steve Forgey 	Feb-06-1982
!		Fix value errors.
!
!	V02-001	SPF0070		Steve Forgey	Jan-23-1982
!		Accept <> as directory delimiters in image file spec as well
!		as [].  Also improve SORT performance.
!
!--

!-----------------------------------------------------------------------------+
!									      !
! 				INCLUDE  FILES				      !
!									      !
!-----------------------------------------------------------------------------+

REQUIRE 'MSRC$:ACCDEF.REQ';		! Common ACC definitions

!-----------------------------------------------------------------------------+
!									      !
! 			TABLE  OF  CONTENTS				      !
!									      !
!-----------------------------------------------------------------------------+

FORWARD ROUTINE
	ACC,				! Top level routine
	ACC_CONTROL,			! Main control loop
	PROCESS_FILE,			! Processes one input file
	PROCESS_RECORD,			! Analyze input record
	PROCESS_V2_RECORD,		! Analyze V2 record
	PROCESS_V3_RECORD,		! Analyze V3 record
	RECORD_SELECTED,		! Determine output disposition
	PARSE_COMMAND,			! Analyze command line
	PARSE_DATES,			! Handles /DATE, /BEFORE, /SINCE
	PARSE_KEYS;			! Handles /REPORT, /SORT, /SUMMARY


!-----------------------------------------------------------------------------+
!									      !
! 			EXTERNAL STORAGE  DEFINITIONS			      !
!									      !
!-----------------------------------------------------------------------------+

EXTERNAL
	INPUT_NAM:	BBLOCK [],
	INPUT_FAB:	BBLOCK [],
	INPUT_RAB:	BBLOCK [],
	OUTPUT_FAB:	BBLOCK [],
	OUTPUT_RAB:	BBLOCK [],
	REJECTED_FAB:	BBLOCK [],
	REJECTED_RAB:	BBLOCK [];

!-----------------------------------------------------------------------------+
!									      !
! 			GLOBAL STORAGE  DEFINITIONS			      !
!									      !
!-----------------------------------------------------------------------------+

GLOBAL

KEY_BUF: BBLOCK [1024],			! Key/record buffer

HOLD_BIOCNT,
HOLD_DIOCNT,
HOLD_ELAPSED: VECTOR [2],
HOLD_EXECUTION,
HOLD_PAGEFLTS,
HOLD_GETCNT,
HOLD_QIOCNT,
HOLD_PAGCNT,
HOLD_PGFLPEAK,
HOLD_PAGEREADS,
HOLD_WSPEAK,
HOLD_CPUTIM: VECTOR [2],
HOLD_VOLUMES,

CUSTOMER,				! Customer type (V3 format only)
RECORD_LENGTH,				! Record length
RECORD_SUBTYPE,				! Record subtype (V3 format only)
RECORD_TYPE,				! Record type
VERSION,				! Record format version

GROUP,					! UIC group
MEMBER,					! UIC member

QUAD_CPU_TIME:	VECTOR [2],		! CPU time (quadword format)
ELAPSED_TIME:	VECTOR [2],		! Calculated elapsed time
WAIT_TIME:	VECTOR [2],		! Calculated queue wait time

ACCOUNT_DESC:		VECTOR [2],	! Describes account name
ADDRESS_DESC:		VECTOR [2],	! Describes remote node address
BUFFERED_IO_DESC:	VECTOR [2],	! Describes buffered I/O count
CPU_TIME_DESC:		VECTOR [2],	! Describes cpu time
DIRECT_IO_DESC:		VECTOR [2],	! Describes direct I/O count
ENTRY_DESC:		VECTOR [2],	! Describes job id number
ELAPSED_DESC:		VECTOR [2],	! Describes elapsed time
EXECUTION_DESC:		VECTOR [2],	! Describes image execution count
FILE_DESC:		VECTOR [2],	! Describes file name
FINISH_TIME_DESC:	VECTOR [2],	! Describes finish time
IDENT_DESC:		VECTOR [2],	! Describes process id (IDENT)
IMAGE_FILE_DESC:	VECTOR [2],	! Describes image file specification
IMAGE_DESC:		VECTOR [2],	! Describes image name
JOB_DESC:		VECTOR [2],	! Describes job name
NODE_DESC:		VECTOR [2],	! Describes remote node name
OWNER_DESC:		VECTOR [2],	! Describes owner IDENT
PAGE_FAULTS_DESC:	VECTOR [2],	! Describes page fault count
PAGE_FILE_DESC:		VECTOR [2],	! Describes page file peak usage
PAGE_READS_DESC:	VECTOR [2],	! Describes page read count
PRIORITY_DESC:		VECTOR [2],	! Describes process base priority
PRIVILEGE_DESC:		VECTOR [2],	! Describes process privilege mask
PROCESS_DESC:		VECTOR [2],	! Describes process type
QUEUE_DESC:		VECTOR [2],	! Describes queue name
QUEUE_TIME_DESC:	VECTOR [2],	! Describes queue time
REMOTE_ID_DESC:		VECTOR [2],	! Describes remote id
START_TIME_DESC:	VECTOR [2],	! Describes start time
STATUS_DESC:		VECTOR [2],	! Describes final exit status code
STATUS_TEXT_DESC:	VECTOR [2],	! Describes final exit status text
SUBTYPE_DESC:		VECTOR [2],	! Describes record subtype
SYM_GET_DESC:		VECTOR [2],	! Describes symbiont get count
SYM_QIO_DESC:		VECTOR [2],	! Describes symbiont qio count
SYM_PAGE_DESC:		VECTOR [2],	! Describes symbiont page count
TERMINAL_DESC:		VECTOR [2],	! Describes terminal name
TYPE_DESC:		VECTOR [2],	! Describes record type
TYPE_TEXT_DESC:		VECTOR [2],	! Describes full record type text
UIC_BINARY_DESC:	VECTOR [2],	! Describes process UIC (binary)
UIC_GROUP_DESC:		VECTOR [2],	! Describes process UIC group (binary)
UIC_MEMBER_DESC:	VECTOR [2],	! Describes process UIC member (binary)
UIC_DESC:		VECTOR [2],	! Describes process UIC (ascii)
USER_DATA_DESC:		VECTOR [2],	! Describes user data
USER_DESC:		VECTOR [2],	! Describes user name
VOLUMES_DESC:		VECTOR [2],	! Describes volume mount count
WORKING_SET_DESC:	VECTOR [2],	! Describes working set peak

!
! When selection qualifiers are specified these switches indicate
! whether the qualifier "selects" or "rejects" records.  If true
! then members of the list are selected, if false then rejected.
! If the qualifier is not specified then the switch is never interogated.
!

ACCOUNT_SWITCH,
ADDRESS_SWITCH,
ENTRY_SWITCH,
IDENT_SWITCH,
IMAGE_SWITCH,
JOB_SWITCH,
NODE_SWITCH,
OWNER_SWITCH,
PRIORITY_SWITCH,
PROCESS_SWITCH,
QUEUE_SWITCH,
REMOTE_ID_SWITCH,
STATUS_SWITCH,
TERMINAL_SWITCH,
TYPE_SWITCH,
UIC_SWITCH,
UIC_GROUP_SWITCH,
UIC_MEMBER_SWITCH,
USER_SWITCH,

SELECTED,		! Count of selected records - this file
TOTAL_SELECTED,		! Count of selected records - all files
TOTAL_REJECTED,		! Count of rejected records - all files

SORT_KEY_SIZE,		! Total length of sort keys

DATE_HEADER,		! Holds pointer to descriptor

STATUS_TEXT_BUFFER: BBLOCK [80],

!
! STORAGE FOR QUALIFIER VALUES AND COUNTS  --
!
UIC_BUF:	VECTOR [16, BYTE],	! process UIC (ascii)
A_DATE_BUF:	VECTOR [23, BYTE],	! DD-MMM-YYYY HH:MM:SS.CC
A_DATE_DESC:	VECTOR [2]		! Describes date in ascii
  INITIAL	(23, A_DATE_BUF),

NUMERIC_DATE:	VECTOR [7, WORD],	! Holds date in numeric format
					! Year, month, hour, day, minute,
					! second, hundredths -- binary words

S_DATE_BUF:	VECTOR [10, BYTE]	! YYYY MM DD
  INITIAL	(BYTE('          ')),
S_DATE_DESC:	VECTOR [2]		! Describes date in ascii (sort format)
  INITIAL	(10, S_DATE_BUF),

YEAR_DESC:	VECTOR [2]		! Ascii year
  INITIAL	(4, S_DATE_BUF + 0),

MONTH_DESC:	VECTOR [2]		! Ascii number string from 01 - 12
  INITIAL	(2, S_DATE_BUF + 5),

DAY_DESC:	VECTOR [2]		! Ascii number string from 01 - 31
  INITIAL	(2, S_DATE_BUF + 8),

WEEKDAY,				! Day of week
WEEKDAY_DESC:	VECTOR [2]		! Ascii number string from 0 - 6
  INITIAL	(1, WEEKDAY),

HOUR_DESC:	VECTOR [2]		! Ascii number string from 00 - 23
  INITIAL	(2, A_DATE_BUF + 12),

MESSAGE_DESC:	VECTOR [2],		! Descibes user message text

REPORT_HDR1_FAO:BBLOCK [DSC$K_D_BLN]	! FAO for /REPORT header 1
  PRESET([DSC$B_CLASS] = DSC$K_CLASS_D),
REPORT_HDR2_FAO:BBLOCK [DSC$K_D_BLN]	! FAO for /REPORT header 2
  PRESET([DSC$B_CLASS] = DSC$K_CLASS_D),
REPORT_HDR3_FAO:BBLOCK [DSC$K_D_BLN]	! FAO for /REPORT header 3
  PRESET([DSC$B_CLASS] = DSC$K_CLASS_D),
REPORT_DET_FAO:	BBLOCK [DSC$K_D_BLN]	! FAO for /REPORT detail line
  PRESET([DSC$B_CLASS] = DSC$K_CLASS_D),
REPORT_VALUE:	VECTOR [MAX_REPORT],	! Holds /REPORT values
REPORT_ITEMS,				! Holds number of report items
BUCKET_SIZE,				! Size of summation bucket in bytes

SUM_KEY_FAO:	BBLOCK [DSC$K_D_BLN]	! FAO for /SUMMARY keys
  PRESET([DSC$B_CLASS] = DSC$K_CLASS_D),
SUM_KEY_VALUE:	VECTOR [MAX_SUM],	! Argument table for key FAO 
SUMMATION_TABLE:INITIAL (7),		! Symbol tab. numb. for summation recs

DATE_DESC_ADDR,				! Address of selected date desc

BEFORE_DATE:				! Selection cuttof date
	BLOCKVECTOR [2, LONG, BYTE]	!  -allocate one quadword
	INITIAL				!  -initial value is:
	(%X'FFFFFFFF',%X'7FFFFFFF'),	!  -futurest describable date

SINCE_DATE:				! Selection cutoff date
	VECTOR [2, LONG]		!  -allocate one quadword
	INITIAL (0,0),			!  -default = oldest describable date

LAST_DATE:				! Last date encountered
	VECTOR [2, LONG]		!  -allocate one quadword
	INITIAL (0,0),			!  -default = oldest describable date

FIRST_DATE:				! Earliest date encountered
	BLOCKVECTOR [2, LONG, BYTE]	!  -allocate one quadword
	INITIAL				!  -initial value is:
	(%X'FFFFFFFF',%X'7FFFFFFF'),	!  -futurest describable date


!
! POSITION DEPENDENT DATA
!	The next two items, SORT_KEY_COUNT and SORT_TABLE must be
!	in the given order.  They are passed as a unit to the sort
!

SORT_KEY_COUNT: WORD,			! Number of sort keys
SORT_TABLE:				! Sort key list
	BLOCKVECTOR [MAX_SORT+1, QUAD, BYTE];


$init_state (uic_stb, uic_ktb);		! UIC parse state table

$state	(,
	('['),
	('<')
	);
$state	(,
	('*'),
	(tpa$_octal,,,,group)
	);
$state	(,
	(',')
	);
$state	(,
	('*'),
	(tpa$_octal,,,,member)
	);
$state	(,
	(']'),
	('>')
	);
$state	(,
	(tpa$_eos, tpa$_exit)
	);

ROUTINE ACC =				! Main routine for ACC

!++
! Functional description
!
!	This is the top level routine for the ACC facility.
!	It calls the main control loop.  Any errors encountered
!	will be passed back to this routine.
!
! Calling sequence
!
!	ACC () from the command language interpreter
!
! Input parameters
!
!	AP = Address of argument list passed from CLI
!
! Output parameters
!
!	None
!
! Routine value
!
!	Worst error is returned.
!
!----

BEGIN

EXTERNAL worst_error;

LOCAL channel, status;

!
!SET UP HANDLERS ---
! Declare condition handler to record severest
! error message issued, to be returned on exit of image.
!

ENABLE handler;



!
!CALL MAIN CONTROL ---
! Invoke the main subroutine.  If any errors are encountered they
! will be returned immediately, if fatal, or saved in WORST_ERROR
! for exit processing.
!

Perform (acc_control ());


!
!RETURN TO USER ---
!	Return to the user.  Variable WORST_ERROR is maintained by
!	the error handler (see routine HANDLER).  If no messages have
!	been signaled then the initial value of WORST_ERROR, SS$_NORMAL,
!	will be returned.
!

Return .worst_error;		! Return contents of WORST_ERROR

END;

ROUTINE ACC_CONTROL =			! Main control routine

!++
! Functional description
!
!	This is the main control routine for the ACC facility.
!	It calls the main loop.  Any errors encountered
!	will be passed back to this routine.
!
! Calling sequence
!
!	ACC_CONTROL ()
!
! Input parameters
!
!	AP = Address of argument list passed from CLI
!
! Output parameters
!
!	None
!
! Routine value
!
!	Worst error is returned.
!
!----

BEGIN

EXTERNAL
    worst_error;			! Worst error status

LOCAL
    temp_file_count,			! Place to save input file count
    desc:	vector [2, long],	! Work descriptor
    status;				! Local variable used as a "catch-all"
					!  bucket for R0 values returned by
					!  called procedures

OWN
    input_desc:	bblock [dsc$k_d_bln]	! Allocate dynamic descriptor
		preset([dsc$b_class] = dsc$k_class_d);



!
! PROCESS THE COMMAND LINE ---
!  Call CLI interface routines to parse the command line.  Set up
!  internal tables as needed for further processing
!

Perform (parse_command ());		! Analyze the command line




!
!PARSE INPUT FILES --
!	Get the list of input files from the CLI.  Call FILE_SCAN
!	with each input file name.  FILE_SCAN will handle wild-carding
!	and stickiness and call PROCESS_FILE for each matching file 
!	that is found.
!

While GET_VALUE ('INPUT', input_desc) do
	BEGIN
	input_fab [fab$b_fns] = .input_desc [dsc$w_length];
	input_fab [fab$l_fna] = .input_desc [dsc$a_pointer];
	input_fab [fab$l_ctx] = msg$_searchfail;! Load the error message
	lib$file_scan (				! Call file scanner with
		input_fab,			!  -address of FAB
		process_file,			!  -success action routine
		log_filename);			!  -error action routine
	END;



!
! SAVE INPUT FILE COUNT --
!	The input file count is simply the highest value of the file
!	number field that is prepended to each record to be carried
!	through the sort.  Save the contents of this field prior to
!	beginning the sort.
!


BEGIN
BIND	input_file_count = key_buf + .sort_key_size;
	temp_file_count = .input_file_count;		! Save input file count
END;


!
!COMPLETE THE SORT --
!	If sort processing is active then trigger the merge phase with
!	a call to SOR$SORT_MERGE.  When the merge reaches the final pass,
!	get the sorted records with calls to SOR$RETURN_REC and dispatch
!	them to the output routines.
!



If PRESENT (SORT) then			! If sorting is active
   BEGIN
   BIND input_buf = key_buf + rec_prefix;	! Locate record
   LOCAL temp;					! Sort insists on a bucket

   if PRESENT (LOG) then signal (acc_merge, 1, .total_selected);

   perform (sor$sort_merge ());			! Do merge phases

   desc [0] = 512;				! Initialize descriptor
   desc [1] = key_buf;

   while status = sor$return_rec (desc, temp)	! While input remains
      do BEGIN
	 if PRESENT (BINARY) then
	      perform (write_binary (input_buf, output_rab))
	 ELSE BEGIN
	      perform (process_record (input_buf));	!  -handle formats
	      perform (show_record (input_buf, output_rab));!  -call output routines
	      END;
	 END;

   if not (.status eql ss$_endoffile) then	! If not normal end then
      signal (.status);				!  signal the user

   perform (sor$end_sort ());			! End the sort
   END;

!
! SET UP REPORT --
!	Establish the "From" "To" dates for the report.  If explicit
!	dates were specified then use them, else allow the earliest
!	and latest dates incountered stand.
!

If PRESENT (SINCE) then MOVE_QUAD (since_date, first_date);

If PRESENT (BEFORE) then MOVE_QUAD (before_date, last_date);



!
! DO SUMMARY AND TOTALS --
!	If /SUMMARY was specified then call the routines that
!	output the summary report and a totals page.
!

If PRESENT (SUMMARY)				! If /SUMMARY
then if PRESENT (BAR_GRAPH)			! If bar graphs
then BEGIN
  perform (scan_symbols (
	.summation_table, find_watermark));	! Find all high watermarks
!  incru i to .report_items do
	perform (scan_symbols (			! Graph each summed field
 	.summation_table, write_bar_graph));
  END
else perform (scan_symbols			! Call write_summary for
	     (.summation_table, write_summary));! each summation record
Perform (write_totals ());			! Write a totals page



!
! LOG RESULTS --
!	If logging was requested and the saved input file count is
!	greater than 1 then display the totals message.
!


if PRESENT (LOG) and				!  If logging requested
   .temp_file_count gtru 1 then			!  and more than one input file
   signal (acc_total, 3,			!  then notify the user with
   .total_selected,				!   -total selected
   .total_rejected,				!   -total rejected
   .temp_file_count);				!   -number of files



!
!CLOSE OUTPUT FILES --
!	Assign the error messages to be used and close the output
!	files.  The files are closed only if they have been created.
!	Creation is inferred if contents of stream pointers is non-zero.
!


Output_fab [fab$l_ctx] = msg$_closeout;		! Assign error message
Rejected_fab [fab$l_ctx] = msg$_closeout;	! Assign error message

If PRESENT (OUTPUT) and PRESENT (BINARY)	! If local FAB is open
   then perform ($close (			! -then close it
		fab = output_fab,		! --address of FAB
		err = log_filename));		! --error action routine

If PRESENT (REJECTED)				! If secondary output open
   then perform ($close (			! -then close it
		fab = rejected_fab,		! --address of FAB
		err = log_filename));		! --error action routine


!
!RETURN TO USER ---
!	Return to the user.  Variable WORST_ERROR is maintained by
!	the error handler (see routine HANDLER).  If no messages have
!	been signaled then the initial value of WORST_ERROR, SS$_NORMAL,
!	will be returned.
!

Return .worst_error;		! Return contents of WORST_ERROR

END;

ROUTINE PROCESS_FILE (FAB) =

!----
!
! Functional description
!
!	This routine processes one input file.  It is called as an action
!	routine from FILESCAN.
!
! Input parameters
!
!
! Output parameters
!
!	Record processing routines are called as necessary.
!	Any errors encountered are RETURNed immediately.
!	TRUE is returned on a normal exit.
!
!----

BEGIN

MAP
	fab:	ref bblock;		! Define as a block structure

EXTERNAL
	related_nam: BBLOCK [],		! Related NAM block for input parse
	input_xabfhc: BBLOCK [],	! Input file FHC XAB block
	key_table;

BIND
	input_file_count	= key_buf + .sort_key_size,
	record_number		= key_buf + .sort_key_size + 4,
	input_buf		= key_buf + .sort_key_size + rec_prefix;

LOCAL
	status:	bblock [long],		! Local "catch all" status return
	desc:	vector [2, long];	! Temporary string descriptor

OWN
	first: initial (true),		! First input file parse flag
	sort_init: initial (false);	! Sort initialization flag

!
! ESTABLISH THE BUFFER ADDRESS --
!

input_rab [rab$l_ubf] = input_buf;	! Set input buffer address


!
! OPEN AND CONNECT ---
!	To the input accounting file.  Exit immediately if any errors
!	are detected. The error handlers will have been invoked if an
!	error occured, and the user will have been notified.  The error
!	message used by	the LOG_FILENAME routine is drawn from the
!	CTX field of the FAB or INPUT_RAB as needed.
!

fab [fab$l_ctx] = msg$_openin;				! Load the error mess.
if	not .first
then	BEGIN
	ch$move (.input_nam [nam$b_rsl], .input_nam [nam$l_rsa],
		.related_nam [nam$l_rsa]);
	related_nam [nam$b_rsl] = .input_nam [nam$b_rsl];
	END
else	first = false;
perform ($open (fab=.fab, err=log_filename));		! OPEN the input file

perform ($connect (rab=input_rab, err=log_filename));	! CONNECT to input file



!
! INITIALIZE THE SORT --
!	If sorting was requested then initialize the sort.
!

(sort_key_count+2)<0,16> = .sort_key_count;	! *** HACK

If PRESENT (SORT) AND (.sort_init eql false) then
   BEGIN
   LOCAL
	lrl, ebk;
   lrl = .input_xabfhc [xab$w_lrl] + .sort_key_size + rec_prefix;
   ebk = .input_xabfhc [xab$l_ebk];
   perform (sor$init_sort (sort_key_count+2, lrl, ebk));
   sort_init = true;
   END;



!
!INITIALIZE OUTPUT FILES --
!	The processing of the output files has been deferred until now
!	so that a fully parsed input file name would be available (as
!	a related file name) for default file name components
!

If .input_file_count eql 0 then			! If this is the first pass
   perform (parse_output_files ());		! then open the output files

input_file_count = .input_file_count + 1;	! Bump the file count.




!
!RESET THE RECORD COUNTERS--
! 	Reset the file-relative record number such that records in each
!	file will be numbered in ascending order beginning with one.
!	Reset the selected count so it is also on a per-file basis.
!

record_number = 0;				! Reset the record number
selected = 0;					! Reset file select count




!
!READ AND LOOP UNTIL EOF ---
!	Now read the file until EOF or an error is detected.  Process
!	each record as specified in the command line
!

While status = $get (rab=input_rab, err=log_filename) do ! Read a record
   BEGIN
   record_number = .record_number + 1;		! Update the record number
   perform (process_record (input_buf));	! Analyze the recored

   if record_selected (input_buf)
   then if PRESENT (SORT)
	then perform (release_to_sort (input_buf,sort_table,key_table,key_buf))
	else if PRESENT (BINARY) then
		perform (write_binary (input_buf, output_rab))
	     else perform (show_record (input_buf, output_rab))
   else if PRESENT (REJECTED)			! If secondary stream open
	then perform (write_binary (input_buf, rejected_rab));
   END;

Total_selected = .total_selected + .selected;	! Accumulate totals
Total_rejected = .total_rejected + (.record_number - .selected);




!
!CHECK STATUS AT END OF LOOP ---
! Now check the return status to make sure it was a normal EOF.  If not,
! notify the user.
!

If not (.status eql rms$_eof)		! If any status other than
   then	return .status;			!  expected eof, return it



!
! CLOSE ---
!	Input file processing is now complete.  Revise the stored error
!	message (which is passed to the error routine via the 'user context'
!	field [CTX] of the FAB) and $CLOSE the input file.
!


If PRESENT (LOG) then			! If logging requested
   BEGIN
   desc [0] = .input_nam [nam$b_rsl];		!  then notify the user
   desc [1] = .input_nam [nam$l_rsa];		!  with file and counts
   signal (acc_input, 3, desc, .selected, .record_number - .selected);
   END;

Fab [fab$l_ctx] = msg$_closein;				! Assign error message

Perform ($close (fab=.fab, err=log_filename));		! Close the input file

Return true;

END;

ROUTINE PROCESS_RECORD (BUFFER) =

!----
!
! Functional description
!
!	This routine is called to analyze a record from the system
!	accounting file.
!
! Input parameters
!
!	BUFFER = Address of a buffer containing the record to be detailed.
!		 The record can be of any type from the V2 and V3 accounting
!		 formats
!
! Output parameters
!
!	Based on the contents of the record, values are established.
!	These values are used in later processing.
!	Any errors encountered are RETURNed immediately.
!	TRUE is returned on a normal exit.
!
!----

BEGIN

MAP	
	buffer: ref bblock;		! Define buffer format

LOCAL
	day_number,			! Temporary output of LIB$DAY
	day_time;			! Temporary output of LIB$DAY


!
! Initialize descriptors
!
customer		= 0;
record_length		= 0;
record_type		= 0;
record_subtype		= 0;
version			= 0;

account_desc [0]	= 0;
account_desc [1]	= 0;
address_desc [0]	= 0;
address_desc [1]	= 0;
buffered_io_desc [0]	= 0;
buffered_io_desc [1]	= 0;
cpu_time_desc [0]	= 0;
cpu_time_desc [1]	= 0;
direct_io_desc [0]	= 0;
direct_io_desc [1]	= 0;
elapsed_desc [0]	= 0;
elapsed_desc [1]	= elapsed_time;
elapsed_time [0]	= 0;
elapsed_time [1]	= 0;
execution_desc [0]	= 0;
execution_desc [1]	= 0;
file_desc [0]		= 0;
file_desc [1]		= 0;
finish_time_desc [0]	= 0;
finish_time_desc [1]	= 0;
image_file_desc [0]	= 0;
image_file_desc [1]	= 0;
image_desc [0]		= 0;
image_desc [1]		= 0;
entry_desc [0]		= 0;
entry_desc [1]		= 0;
job_desc [0]		= 0;
job_desc [1]		= 0;
node_desc [0]		= 0;
node_desc [1]		= 0;
owner_desc [0]		= 0;
owner_desc [1]		= 0;
page_faults_desc [0]	= 0;
page_faults_desc [1]	= 0;
page_file_desc [0]	= 0;
page_file_desc [1]	= 0;
page_reads_desc [0]	= 0;
page_reads_desc [1]	= 0;
ident_desc [0]		= 0;
ident_desc [1]		= 0;
priority_desc [0]	= 0;
priority_desc [1]	= 0;
privilege_desc [0]	= 0;
privilege_desc [1]	= 0;
process_desc [0]	= 0;
process_desc [1]	= 0;
quad_cpu_time [0]	= 0;
quad_cpu_time [1]	= 0;
queue_desc [0]		= 0;
queue_desc [1]		= 0;
queue_time_desc [0]	= 0;
queue_time_desc [1]	= 0;
remote_id_desc [0]	= 0;
remote_id_desc [1]	= 0;
start_time_desc [0]	= 0;
start_time_desc [1]	= 0;
status_desc [0]		= 0;
status_desc [1]		= 0;
status_text_desc [0]	= 0;
status_text_desc [1]	= 0;
subtype_desc [0]	= 0;
subtype_desc [1]	= 0;
sym_get_desc [0]	= 0;
sym_get_desc [1]	= 0;
sym_page_desc [0]	= 0;
sym_page_desc [1]	= 0;
sym_qio_desc [0]	= 0;
sym_qio_desc [1]	= 0;
terminal_desc [0]	= 0;
terminal_desc [1]	= 0;
type_desc [0]		= 0;
type_desc [1]		= 0;
type_text_desc [0]	= 0;
type_text_desc [1]	= 0;
uic_desc [0]		= 0;
uic_desc [1]		= 0;
uic_binary_desc [0]	= 0;
uic_binary_desc [1]	= 0;
uic_group_desc [0]	= 0;
uic_group_desc [1]	= 0;
uic_member_desc [0]	= 0;
uic_member_desc [1]	= 0;
user_data_desc [0]	= 0;
user_data_desc [1]	= 0;
user_desc [0]		= 0;
user_desc [1]		= 0;
volumes_desc [0]	= 0;
volumes_desc [1]	= 0;
wait_time [0]		= 0;
wait_time [1]		= 0;
working_set_desc [0]	= 0;
working_set_desc [1]	= 0;

version = .buffer [acr$v_version];

SELECTONEU .version of
	SET
	[acr$k_version2]:
		perform (process_v2_record(.buffer));
	[acr$k_version3t, acr$k_version3]:
		perform (process_v3_record(.buffer));
	[OTHERWISE]:
		return false;
	TES;

If PRESENT (REPORT)
	THEN BEGIN
	IF .buffered_io_desc [0] neq 0
		THEN BEGIN
		hold_biocnt = ..buffered_io_desc [1];
		END;
	IF .cpu_time_desc [0] neq 0
		THEN BEGIN
		hold_cputim [0] = .quad_cpu_time [0];
		hold_cputim [1] = .quad_cpu_time [1];
		END;
	IF .direct_io_desc [0] neq 0
		THEN BEGIN
		hold_diocnt = ..direct_io_desc [1];
		END;
	hold_elapsed [0] = .elapsed_time [0];
	hold_elapsed [1] = .elapsed_time [1];
!	perform (lib$day (day_number, hold_elapsed, day_time));
!	hold_elapsed [0] = (.day_time/1000) + (.day_number * 24 * 60 * 60);
!	hold_elapsed [1] = 0;
	IF .execution_desc [0] neq 0
		THEN BEGIN
		hold_execution = ..execution_desc [1];
		END;
	IF .page_faults_desc [0] neq 0
		THEN BEGIN
		hold_pageflts = ..page_faults_desc [1];
		END;
	IF .page_file_desc [0] neq 0
		THEN BEGIN
		hold_pgflpeak = ..page_file_desc [1];
		END;
	IF .page_reads_desc [0] neq 0
		THEN BEGIN
		hold_pagereads = ..page_reads_desc [1];
		END;
	IF .sym_get_desc [0] neq 0
		THEN BEGIN
		hold_getcnt = ..sym_get_desc [1];
		END;
	IF .sym_qio_desc [0] neq 0
		THEN BEGIN
		hold_qiocnt = ..sym_qio_desc [1];
		END;
	IF .sym_page_desc [0] neq 0
		THEN BEGIN
		hold_pagcnt = ..sym_page_desc [1];
		END;
	IF .volumes_desc [0] neq 0
		THEN BEGIN
		hold_volumes = ..volumes_desc [1];
		END;
	IF .working_set_desc [0] neq 0
		THEN BEGIN
		hold_wspeak = ..working_set_desc [1];
		END;
	END;

If PRESENT (SORT) OR PRESENT (EXPAND_DATE)
	THEN BEGIN
	!
	! Form an ascii date string in the form:
	!
	!			DD-MMM-YYYY HH:MM:SS.CC
	!

	Perform (lib$sys_asctim (0, a_date_desc, ..date_desc_addr, 0));
	END;

If PRESENT (EXPAND_DATE)
	THEN BEGIN

	!
	! Calculate day-of-week in binary byte range of 0-6
	! First get total days since epoch date
	! Shift it 3 days to make 0 = Sunday
	! Convert to modulo 7
	! Convert to ascii byte as a temporary hack
	!

	perform (lib$day (weekday, ..date_desc_addr));

	weekday = ((.weekday + 3) mod 7) + '0';


	!
	! Form an ascii date string suitable for sorting in the form:
	!
	!			YYYY MM DD
	!

	perform (sys$numtim (numeric_date, ..date_desc_addr));

	perform (lib$sys_fao (ad ('!4ZW !2ZW !2ZW'),
			0,				! No output length
			s_date_desc,			! Output buf desc
			.numeric_date [0],		! Year
			.numeric_date [1],		! Month
			.numeric_date [2]		! Day of month
		));
	END;

return true;

END;

ROUTINE PROCESS_V2_RECORD (BUFFER) =

!----
!
! Functional description
!
!	This routine is called to analyze a record from the system
!	accounting file.
!
! Input parameters
!
!	BUFFER = Address of a buffer containing the record to be detailed.
!		 The record can be any type of record from the V2 format.
!		 -- (ACC$W_MSGTYP can have any value)
!
! Output parameters
!
!	Based on the contents of the record, values are established.
!	These values are used in later processing.
!	Any errors encountered are RETURNed immediately.
!	TRUE is returned on a normal exit.
!
!----

BEGIN

MAP
	buffer:	ref bblock;		! Define buffer block format

LOCAL
	day_number,			! Temporary output of LIB$DAY
	day_time;			! Temporary output of LIB$DAY


record_type		= .buffer [acc$w_msgtyp];
SELECTONEU .record_type of
	SET
	[acc$k_logtrm]:				! Login failure
		BEGIN
		type_desc [0]		= 7;
		type_desc [1] 		= uplit ('LOGFAIL');
		type_text_desc [0]	= 13;
		type_text_desc [1]	= uplit ('LOGIN FAILURE');
		END;

	[acc$k_insmsg]:				! Arbitrary message
		BEGIN
		type_desc [0]		= 4;
		type_desc [1]		= uplit ('USER');
		type_text_desc [0]	= 12;
		type_text_desc [1]	= uplit ('USER Message');
		END;

	[acc$k_inttrm]:				! Interactive process
		BEGIN
		type_desc [0]		= 7;
		type_desc [1] 		= uplit ('PROCESS');
		subtype_desc [0]	= 11;
		subtype_desc [1]	= uplit ('INTERACTIVE');
		process_desc [0]	= .subtype_desc [0];
		process_desc [1]	= .subtype_desc [1];
		type_text_desc [0]	= 19;
		type_text_desc [1]	= uplit ('Process Termination');
		END;
	[acc$k_prctrm]:				! Non-interactive process
		BEGIN
		type_desc [0]		= 7;
		type_desc [1] 		= uplit ('PROCESS');
		type_text_desc [0]	= 19;
		type_text_desc [1]	= uplit ('Process Termination');
		if	.buffer [acc$l_owner] NEQ 0
		then
			BEGIN
			subtype_desc [0]	= 10;
			subtype_desc [1]	= uplit ('SUBPROCESS');
			END
		else
			BEGIN
			subtype_desc [0]	= 8;
			subtype_desc [1]	= uplit ('DETACHED');
			END;
		process_desc [0]	= .subtype_desc [0];
		process_desc [1]	= .subtype_desc [1];
		END;

	[acc$k_battrm]:				! Batch job
		BEGIN
		type_desc [0]		= 7;
		type_desc [1] 		= uplit ('PROCESS');
		subtype_desc [0]	= 5;
		subtype_desc [1]	= uplit ('BATCH');
		process_desc [0]	= .subtype_desc [0];
		process_desc [1]	= .subtype_desc [1];
		type_text_desc [0]	= 19;
		type_text_desc [1]	= uplit ('Process Termination');
		END;

	[acc$k_prtjob]:				! Print job
		BEGIN
		type_desc [0]	= 5;
		type_desc [1]	= uplit ('PRINT');
		type_text_desc [0]	= 21;
		type_text_desc [1]	= uplit ('PRINT Job Termination');
		END;

	[otherwise]:				! Unknown record type
		BEGIN
		type_desc [0]	= 7;
		type_desc [1]	= uplit ('UNKNOWN');
		type_text_desc [0]	= 19;
		type_text_desc [1]	= uplit ('UNKNOWN Record Type');
		END;
	TES;

record_length		= .buffer [acc$w_msgsiz];
status_desc [0]		= 4;
status_desc [1]		= buffer [acc$l_finalsts];
status_text_desc [0]	= 80;
status_text_desc [1]	= status_text_buffer;
translate_status (..status_desc [1], status_text_desc);
ident_desc [0]		= 4;
ident_desc [1]		= buffer [acc$l_pid];
if .buffer [acc$l_jobid] NEQ 0 then
	BEGIN
	entry_desc [0]	= 4;
	entry_desc [1]	= buffer [acc$l_jobid];
	END;
finish_time_desc [0]	= 8;
finish_time_desc [1]	= buffer [acc$q_termtime];
account_desc [0]	= acc$s_account;
account_desc [1]	= buffer [acc$t_account];
strip_trail		(account_desc);
user_desc [0]		= acc$s_username;
user_desc [1]		= buffer [acc$t_username];
strip_trail		(user_desc);

SELECTU .record_type of 
	SET
	[acc$k_inttrm, acc$k_prctrm, acc$k_battrm, acc$k_logtrm]:
		BEGIN

		BUILTIN emul;

		cpu_time_desc [0]	= 4;
		cpu_time_desc [1]	= buffer [acc$l_cputim];
		emul (%ref(100000), buffer [acc$l_cputim], %ref(0),
			quad_cpu_time [0]);
		page_faults_desc [0]	= 4;
		page_faults_desc [1]	= buffer [acc$l_pageflts];
		page_file_desc [0]	= 4;
		page_file_desc [1]	= buffer [acc$l_pgflpeak];
		working_set_desc [0]	= 4;
		working_set_desc [1]	= buffer [acc$l_wspeak];
		buffered_io_desc [0]	= 4;
		buffered_io_desc [1]	= buffer [acc$l_biocnt];
		direct_io_desc [0]	= 4;
		direct_io_desc [1]	= buffer [acc$l_diocnt];
		volumes_desc [0]	= 4;
		volumes_desc [1]	= buffer [acc$l_volumes];
		start_time_desc [0]	= 8;
		start_time_desc [1]	= buffer [acc$q_login];
		perform (lib$subx (
			.finish_time_desc [1],
			.start_time_desc [1],
			elapsed_time, %ref(2)));
		elapsed_desc [0]	= 8;
		owner_desc [0]		= 4;
		owner_desc [1]		= buffer [acc$l_owner];
		END;

	[acc$k_battrm]:
		BEGIN
		job_desc [0]		= acc$s_job_name;
		job_desc [1]		= buffer [acc$t_job_name];
		strip_trail		(job_desc);
		queue_desc [0]		= .(buffer [acc$t_job_que])<0,8>;
		queue_desc [1]		= buffer [acc$t_job_que] + 1;
		END;

	[acc$k_prtjob]:
		BEGIN

		BUILTIN emul;

		cpu_time_desc [0]	= 4;
		cpu_time_desc [1]	= buffer [acc$l_cputim];
		emul (%ref(100000), buffer [acc$l_cputim], %ref(0),
			quad_cpu_time [0]);
		sym_page_desc [0]	= 4;
		sym_page_desc [1]	= buffer [acc$l_pagcnt];
		sym_qio_desc [0]	= 4;
		sym_qio_desc [1]	= buffer [acc$l_qiocnt];
		sym_get_desc [0]	= 4;
		sym_get_desc [1]	= buffer [acc$l_getcnt];
		queue_time_desc [0]	= 8;
		queue_time_desc [1]	= buffer [acc$q_quetime];
		perform (lib$subx (
			.finish_time_desc [1],
			.queue_time_desc [1],
			elapsed_time, %ref(2)));
		elapsed_desc [0]	= 8;
		job_desc [0]		= acc$s_prt_name;
		job_desc [1]		= buffer [acc$t_prt_name];
		strip_trail		(job_desc);
		queue_desc [0]		= .(buffer [acc$t_prt_que])<0,8>;
		queue_desc [1]		= buffer [acc$t_prt_que] + 1;
		END;

	[acc$k_insmsg]:
		BEGIN
		user_data_desc [0]	= .(buffer [acc$t_user_data])<0,8>;
		user_data_desc [1]	= buffer [acc$t_user_data] + 1;
		strip_trail		(user_data_desc);
		END;
	TES;	
	

return true;

END;

ROUTINE PROCESS_V3_RECORD (BUFFER) =

!----
!
! Functional description
!
!	This routine is called to analyze a record from the system
!	accounting file.
!
! Input parameters
!
!	BUFFER = Address of a buffer containing the record to be detailed.
!		 The record can be any type of record from the V3 format.
!		 -- (ACR$W_TYPE can have any value)
!
! Output parameters
!
!	Based on the contents of the record, values are established.
!	These values are used in later processing.
!	Any errors encountered are RETURNed immediately.
!	TRUE is returned on a normal exit.
!
!----

BEGIN

MAP
	buffer:	ref bblock;		! Define buffer block format

LABEL
	pkt;

OWN
	packet;

!------------------------------------------------------------------------------
!
! Record header
!
!------------------------------------------------------------------------------
!
! Record type and subtype
!
if 	.buffer [acr$v_packet] NEQ 0
then	return false;
record_type	= .buffer [acr$v_type];
record_subtype	= .buffer [acr$v_subtype];
customer	= .buffer [acr$v_customer];
if	NOT .customer
then
	BEGIN
	SELECTU .record_type of
	SET
	[acr$k_prcdel, acr$k_prcpur, acr$k_imgdel, acr$k_imgdel]:
		BEGIN
		SELECTONEU .record_subtype of
		SET
		[acr$k_interactive]:
			BEGIN
			process_desc [0] = 11;
			process_desc [1] = uplit ('INTERACTIVE');
			END;
		[acr$k_subprocess]:
			BEGIN
			process_desc [0] = 10;
			process_desc [1] = uplit ('SUBPROCESS');
			END;
		[acr$k_detached]:
			BEGIN
			process_desc [0] = 8;
			process_desc [1] = uplit ('DETACHED');
			END;
		[acr$k_batch]:
			BEGIN
			process_desc [0] = 5;
			process_desc [1] = uplit ('BATCH');
			END;
		[acr$k_network]:
			BEGIN
			process_desc [0] = 7;
			process_desc [1] = uplit ('NETWORK');
			END;
		TES;
		END;
	[acr$k_prcdel, acr$k_prcpur]:
		BEGIN
		type_desc [0] = 7;
		type_desc [1] = uplit ('PROCESS');
		type_text_desc [0]	= 19;
		type_text_desc [1]	= uplit ('Process Termination');
		subtype_desc [0] = .process_desc [0];
		subtype_desc [1] = .process_desc [1];
		END;
	[acr$k_imgdel, acr$k_imgpur]:
		BEGIN
		type_desc [0] = 5;
		type_desc [1] = uplit ('IMAGE');
		type_text_desc [0]	= 17;
		type_text_desc [1]	= uplit ('Image Termination');
		END;
	[acr$k_sysinit]:
		BEGIN
		type_desc [0] = 7;
		type_desc [1] = uplit ('SYSINIT');
		type_text_desc [0]	= 21;
		type_text_desc [1]	= uplit ('SYSTEM INITIALIZATION');
		END;
	[acr$k_settime]:
		BEGIN
		type_desc [0] = 7;
		type_desc [1] = uplit ('SETTIME');
		type_text_desc [0]	= 18;
		type_text_desc [1]	= uplit ('System Time Change');
		END;
	[acr$k_logfail]:
		BEGIN
		type_desc [0] = 7;
		type_desc [1] = uplit ('LOGFAIL');
		type_text_desc [0]	= 13;
		type_text_desc [1]	= uplit ('LOGIN FAILURE');
		END;
	[acr$k_print]:
		BEGIN
		type_desc [0] = 5;
		type_desc [1] = uplit ('PRINT');
		type_text_desc [0]	= 21;
		type_text_desc [1]	= uplit ('PRINT Job Termination');
		END;
	[acr$k_user]:
		BEGIN
		type_desc [0] = 4;
		type_desc [1] = uplit ('USER');
		type_text_desc [0]	= 12;
		type_text_desc [1]	= uplit ('USER Message');
		END;
	[acr$k_enable]:
		BEGIN
		type_desc [0] = 6;
		type_desc [1] = uplit ('ENABLE');
		type_text_desc [0]	= 17;
		type_text_desc [1]	= uplit ('Enable Accounting');
		END;
	[acr$k_disable]:
		BEGIN
		type_desc [0] = 7;
		type_desc [1] = uplit ('DISABLE');
		type_text_desc [0]	= 18;
		type_text_desc [1]	= uplit ('Disable Accounting');
		END;
	[acr$k_altacm]:
		BEGIN
		type_desc [0] = 6;
		type_desc [1] = uplit ('ALTACM');
		type_text_desc [0]	= 28;
		type_text_desc [1]	= uplit ('Alternate Accounting Manager');
		END;
	[acr$k_file_bl]:
		BEGIN
		type_desc [0] = 4;
		type_desc [1] = uplit ('FILE_BL');
		type_text_desc [0]	= 32;
		type_text_desc [1]	= uplit 
					('ACCOUNTING FILE backward pointer');
		END;
	[acr$k_file_fl]:
		BEGIN
		type_desc [0] = 4;
		type_desc [1] = uplit ('FILE_FL');
		type_text_desc [0]	= 31;
		type_text_desc [1]	= uplit
					('ACCOUNTING FILE forward pointer');
		END;
	[OTHERWISE]:
		BEGIN
		type_desc [0] = 7;
		type_desc [1] = uplit ('UNKNOWN');
		type_text_desc [0]	= 19;
		type_text_desc [1]	= uplit ('UNKNOWN Record Type');
		END;
	TES;
	END
else
	BEGIN
	type_desc [0] = 8;
	type_desc [1] = uplit ('CUSTOMER');
	type_text_desc [0]	= 20;
	type_text_desc [1]	= uplit ('CUSTOMER Record Type');
	END;
!
! Record length
!
record_length	= .buffer [acr$w_length];
!
! Record creation time
!
if	.(buffer [acr$q_systime])<0,32> NEQ 0 OR
	.(buffer [acr$q_systime] + 4)<0,32> NEQ 0
then
	BEGIN
	finish_time_desc [0]	= 8;
	finish_time_desc [1]	= buffer [acr$q_systime];
	END;

!------------------------------------------------------------------------------
!
! Packet processing
!
!------------------------------------------------------------------------------
!
! Find and detail all known packets
!
packet	= .buffer + $BYTEOFFSET(acr$k_hdrlen);
while	.packet LSSU .buffer + .record_length do
	BEGIN
	MAP
		packet: 	ref bblock;
		PKT: BEGIN
		if (.packet [acr$v_packet] EQL 0) then return false;
		if (.packet [acr$v_customer] NEQ 0) then leave pkt;
		SELECTONEU .packet [acr$v_type] of
		SET
		[acr$k_id]:
			!
			! ID packet
			!
			BEGIN

			BIND
				id = .packet:	bblock;

			BEGIN
			ident_desc [0] = 4;
			ident_desc [1] = id [acr$l_pid];
			END;

			if (.id [acr$l_owner] NEQ 0) then
				BEGIN
				owner_desc [0] = 4;
				owner_desc [1] = id [acr$l_owner];
				END;

			BEGIN
			EXTERNAL ROUTINE
				OTS$CVT_L_TO;
			LOCAL
				ptr,
				grp_buf: vector [3, byte],
				grp_desc: vector [2],
				mem_buf: vector [3, byte],
				mem_desc: vector [2];
			uic_binary_desc [0] = 4;
			uic_binary_desc [1] = id [acr$l_uic];
			uic_group_desc [0]  = 2;
			uic_group_desc [1]  = id [acr$w_grp];
			uic_member_desc [0] = 2;
			uic_member_desc [1] = id [acr$w_mem];
			grp_desc [0] = 3;
			grp_desc [1] = grp_buf;
			perform (ots$cvt_l_to (	id [acr$w_grp],
						grp_desc, 1, 2));
			mem_desc [0] = 3;
			mem_desc [1] = mem_buf;
			perform (ots$cvt_l_to (	id [acr$w_mem],
						mem_desc, 1, 2));
			uic_desc [0] = 9;
			uic_desc [1] = uic_buf;
			perform (lib$sys_fao (ad('[!AS,!AS]'),
					uic_desc [0],
					uic_desc [0],
					grp_desc,
					mem_desc));
			END;

			BEGIN
			privilege_desc [0] = 8;
			privilege_desc [1] = id [acr$q_priv];
			END;

			BEGIN
			priority_desc [0] = 1;
			priority_desc [1] = id [acr$b_pri];
			END;

			if (.id [acr$w_username] NEQ 0) then
				BEGIN
				user_desc [0] =
					.(id + .id [acr$w_username])<0,8>;
				user_desc [1] =
					id + .id [acr$w_username] + 1;
				END;
			if (.id [acr$w_account] NEQ 0) then
				BEGIN
				account_desc [0] =
					.(id + .id [acr$w_account])<0,8>;
				account_desc [1] =
					id + .id [acr$w_account] + 1;
				END;
			if (.id [acr$w_nodename] NEQ 0) then
				BEGIN
				node_desc [0] =
					.(id + .id [acr$w_nodename])<0,8>;
				node_desc [1] =
					id + .id [acr$w_nodename] + 1;
				END;
			if (.id [acr$w_terminal] NEQ 0) then
				BEGIN
				terminal_desc [0] =
					.(id + .id [acr$w_terminal])<0,8>;
				terminal_desc [1] =
					id + .id [acr$w_terminal] + 1;
				END;
			if (.id [acr$w_jobname] NEQ 0) then
				BEGIN
				job_desc [0] =
					.(id + .id [acr$w_jobname])<0,8>;
				job_desc [1] =
					id + .id [acr$w_jobname] + 1;
				END;
			if (.id [acr$l_jobid] NEQ 0) then
				BEGIN
				entry_desc [0] = 4;
				entry_desc [1] = id [acr$l_jobid];
				END;
			if (.id [acr$w_queue] NEQ 0) then
				BEGIN
				queue_desc [0] =
					.(id + .id [acr$w_queue])<0,8>;
				queue_desc [1] =
					id + .id [acr$w_queue] + 1;
				END;
			if (.version EQL acr$k_version3) then
				BEGIN
				if (.id [acr$w_nodeaddr] NEQ 0) then
					BEGIN
					address_desc [0] =
						.(id + .id [acr$w_nodeaddr])<0,8>;
					address_desc [1] =
						id + .id [acr$w_nodeaddr] + 1;
					END;
				if (.id [acr$w_remoteid] NEQ 0) then
					BEGIN
					remote_id_desc [0] =
						.(id + .id [acr$w_remoteid])<0,8>;
					remote_id_desc [1] =
						id + .id [acr$w_remoteid] + 1;
					END;
				END;
			END;

		[acr$k_resource]:
			!
			! Resource packets
			!
			BEGIN

			BIND
				resource = .packet:	bblock;

			BEGIN
			start_time_desc [0] = 8;
			start_time_desc [1] = resource [acr$q_login];
			if .finish_time_desc [0] NEQ 0 then
				BEGIN
				perform	(lib$subx (
					.finish_time_desc [1],
					.start_time_desc [1],
					elapsed_time, %ref(2)));
				elapsed_desc [0] = 8;
				END;
			END;

			BEGIN
			status_desc [0] = 4;
			status_desc [1] = resource [acr$l_status];
			status_text_desc [0] = 80;
			status_text_desc [1] = status_text_buffer;
			translate_status 
				(..status_desc [1], status_text_desc);
			END;

			BEGIN
			execution_desc [0] = 4;
			execution_desc [1] = resource [acr$l_imgcnt];
			END;

			BEGIN

			BUILTIN emul;

			cpu_time_desc [0] = 4;
			cpu_time_desc [1] = resource [acr$l_cputime];
			emul (%ref(100000), resource [acr$l_cputime],
				%ref(0),quad_cpu_time [0]);
			END;

			BEGIN
			page_faults_desc [0] = 4;
			page_faults_desc [1] = resource [acr$l_faults];
			END;

			BEGIN
			page_reads_desc [0] = 4;
			page_reads_desc [1] = resource [acr$l_faultio];
			END;

			BEGIN
			working_set_desc [0] = 4;
			working_set_desc [1] = resource [acr$l_wspeak];
			END;

			BEGIN
			page_file_desc [0] = 4;
			page_file_desc [1] = resource [acr$l_pagefl];
			END;

			BEGIN
			direct_io_desc [0] = 4;
			direct_io_desc [1] = resource [acr$l_diocnt];
			END;

			BEGIN
			buffered_io_desc [0] = 4;
			buffered_io_desc [1] = resource [acr$l_biocnt];
			END;

			BEGIN
			volumes_desc [0] = 4;
			volumes_desc [1] = resource [acr$l_volumes];
			END;
			END;

		[acr$k_imagename]:
			!
			! Imagename packets
			!
			BEGIN
	
			BIND
				image = .packet:	bblock;
			LOCAL
				name_end;

			if (.(image [acr$t_imagename])<0,8> NEQ 0) then
				BEGIN
				LOCAL
					ptr;
				image_file_desc [0] =
					.(image [acr$t_imagename])<0,8>;
				image_file_desc [1] =
					image [acr$t_imagename] + 1;
				ptr =
					CH$FIND_CH(
						.image_file_desc [0],
						.image_file_desc [1],
						%C']');
				if .ptr eql 0 then
					ptr =
						CH$FIND_CH(
							.image_file_desc [0],
							.image_file_desc [1],
							%C'>');
				if .ptr neq 0 then
					BEGIN
					image_desc [1] = .ptr + 1;
					image_desc [0] =
						CH$FIND_CH(
						.image_file_desc [0] -
							(.image_desc [1] -
							.image_file_desc [1]),
						.image_desc [1],
						%C'.') -
						.image_desc [1];
					subtype_desc [0] = .image_desc [0];
					subtype_desc [1] = .image_desc [1];
					END;
				END;
			END;

		[acr$k_filename]:
			!
			! Filename packets
			!
			BEGIN

			BIND
				file = .packet:	bblock;

			if (.(file [acr$t_filename])<0,8> NEQ 0) then
				BEGIN
				file_desc [0] = .(file [acr$t_filename])<0,8>;
				file_desc [1] =   file [acr$t_filename] + 1;
				END;
			END;

		[acr$k_user_data]:
			!
			! User data packets
			!
			BEGIN

			BIND
				user_data = .packet:	bblock;

			if (.(user_data [acr$t_user_data])<0,8> NEQ 0) then
				BEGIN
				user_data_desc [0] =
					.(user_data [acr$t_user_data])<0,8>;
				user_data_desc [1] =
					user_data [acr$t_user_data] + 1;
				END;
			END;

		[acr$k_print]:
			!
			! Print resource packets
			!
			BEGIN

			BIND
				print = .packet:	bblock;

				BEGIN
				status_desc [0] = 4;
				status_desc [1] = print [acr$l_printsts];
				status_text_desc [0] = 80;
				status_text_desc [1] = status_text_buffer;
				translate_status 
					(..status_desc [1], status_text_desc);
				END;
			if (.(print [acr$q_begtime])<0,32> NEQ 0) OR
			   (.(print [acr$q_begtime] + 4)<0,32> NEQ 0) then
				BEGIN
				start_time_desc [0] = 8;
				start_time_desc [1] = print [acr$q_begtime];
				if .finish_time_desc [0] NEQ 0 then
					BEGIN
					perform	(lib$subx (
						.finish_time_desc [1],
						.start_time_desc [1],
						elapsed_time, %ref(2)));
					elapsed_desc [0] = 8;
					END;
				END;
			if (.(print [acr$q_quetime])<0,32> NEQ 0) OR
			   (.(print [acr$q_quetime] + 4)<0,32> NEQ 0) then
				BEGIN
				queue_time_desc [0] = 8;
				queue_time_desc [1] = print [acr$q_quetime];
				if .finish_time_desc [0] NEQ 0 then
					perform	(lib$subx (
						.finish_time_desc [1],
						.queue_time_desc [1],
						elapsed_time, %ref(2)));
				END;

			BEGIN

			BUILTIN emul;

			cpu_time_desc [0] = 4;
			cpu_time_desc [1] = print [acr$l_symcputim];
			emul (%ref(100000), print [acr$l_symcputim],
				%ref(0), quad_cpu_time [0]);
			END;

			BEGIN
			sym_page_desc [0] = 4;
			sym_page_desc [1] = print [acr$l_pagecnt];
			END;

			BEGIN
			sym_qio_desc [0] = 4;
			sym_qio_desc [1] = print [acr$l_qiocnt];
			END;

			BEGIN
			sym_get_desc [0] = 4;
			sym_get_desc [1] = print [acr$l_getcnt];
			END;
			END;

		TES;
		END;
	packet = .packet + .packet [acr$w_length];
	END;


return true;

END;

ROUTINE RECORD_SELECTED (BUFFER) =

!----
!
! Functional description
!	
!	This routine tests the record pointed to by BUFFER against
!	user specified selection criteria.  If any test is failed
!	then an immediate failed return is made.  Else true is retured.
!
! Inputs:
!
!	BUFFER = Address of the current record
!
! Outputs:
!
!	True or false.  There are no error exits/returns from this routine.
!
!---

BEGIN

MAP buffer:	ref bblock;		! Define buffer block format

MACRO
    SELECT_OR_REJECT (name) =
	IF PRESENT (name) then
		BEGIN
		LOCAL FOUND, VALUE;
		FOUND = LOOKUP_SYMBOL (name, %NAME(name,'_DESC'), VALUE);
		IF .FOUND XOR .%NAME(name,'_SWITCH') THEN RETURN FALSE;
		END%;




!
!TEST THE RECORD --
!	Using tables and values built by PARSE_COMMAND test the input
!	record.  Any time a record fails a selection test, or matches
!	an exclusion test, return immediately with an indicator to use
!	the secondary output stream.  If all tests are passed, then return
!	TRUE.
!

Select_or_reject (account);

Select_or_reject (address);

Select_or_reject (entry);

Select_or_reject (ident);

Select_or_reject (image);

Select_or_reject (job);

Select_or_reject (node);

Select_or_reject (owner);

Select_or_reject (priority);

Select_or_reject (process);

Select_or_reject (queue);

Select_or_reject (remote_id);

Select_or_reject (status);

Select_or_reject (terminal);

Select_or_reject (type);

Select_or_reject (uic_group);

Select_or_reject (uic_member);

Select_or_reject (user);



!
!TEST DATES --
!
!	Check to see if this is the oldest or newest record
!	encountered.  Update the date watermarks if so.
!

if COMPARE_QUAD (..date_desc_addr, lssu, first_date)
   then MOVE_QUAD (..date_desc_addr, first_date);

if COMPARE_QUAD (..date_desc_addr, gtru, last_date)
   then MOVE_QUAD (..date_desc_addr, last_date);



!
!	BEFORE_DATE and SINCE_DATE define a date range that the
!	record under test must satisfy.  DATE_DESC_ADDR points to
!	one of three possible dates in the record to use in the
!	test.  If the date pointed to does not fall inside the
!	range then return to the caller.
!

if (COMPARE_QUAD (..date_desc_addr, gtru, before_date)) or
   (COMPARE_QUAD (..date_desc_addr, lssu, since_date))
   then return  false;


!
! If code path falls through to here then the record has passed all
! selection and rejection tests so count it as selected and return true.
!

selected = .selected + 1;		! Bump the selected record count
return true;				! Default is selected

END;


ROUTINE PARSE_COMMAND =

!---
!
! Functional description
!
!	This routine is called from the main loop to process the command
!	line.  Based on the presence of qualifiers and modifiers, routines
!	are called to parse the line.
!
!	Internal tables are defined, based on command line values, for later
!	processing.
!
! Output parameters
!
!	Any errors encountered are RETURNed immediately.
!	TRUE is returned on a normal exit.
!
!----

BEGIN

UNDECLARE
	uic_stb,
	uic_ktb;

EXTERNAL
	uic_stb,
	uic_ktb;

LOCAL
	first,				! First time switch
	temp;				! Temporary work area

OWN
	desc:	bblock [dsc$k_d_bln]	! Dynamic work descriptor
		preset([dsc$b_class] = dsc$k_class_d),


!
!DEFINE KEYWORD TABLES ---
! Define a keyword table for LIB$LOOKUP_KEY.  Associate a number
! with each keyword.
!


type_keyword:	$lib_key_table	(		! Keyword table -- record type
   (CUSTOMER,	ad ('CUSTOMER')),		!  -Customer record
   (FILE,	ad ('FILE')),			!  -File record
   (IMAGE,	ad ('IMAGE')),			!  -Image termination
   (LOGFAIL,	ad ('LOGFAIL')),		!  -Login failure
   (PROCESS,	ad ('PROCESS')),		!  -Process termination
   (PRINT,	ad ('PRINT')),			!  -Print job termination
   (SETTIME,	ad ('SETTIME')),		!  -System set time~r
   (SYSINIT,	ad ('SYSINIT')),		!  -System initialization
   (UNKNOWN,	ad ('UNKNOWN')),		!  -Unknown record types
   (USER,	ad ('USER')),			!  -User messages
		),

process_keyword: $lib_key_table	(		! Keyword table -- process type
   (BATCH,	ad ('BATCH')),			!  -Batch process
   (DETACHED,	ad ('DETACHED')),		!  -Detached process
   (INTERACTIVE, ad ('INTERACTIVE')),		!  -Interactive process
   (NETWORK,	ad ('NETWORK')),		!  -Network process
   (SUBPROCESS,	ad ('SUBPROCESS')),		!  -Sub process
		);


	

!
!PARSE COMMAND LINE MODIFIERS ---
! Call routines as necessary to parse command line modifiers and
! value lists.  Exit immediately if any errors are returned by the
! parsing subroutines.
!

map_qualifiers ();	! Establish bitmask


!
!PARSE /ACCOUNT VALUE LIST --
!

First = true;
While GET_VALUE ('ACCOUNT', desc) do
	BEGIN
	if	.first
	then	BEGIN
		account_switch = strip_negator (desc);
		if	.desc [dsc$w_length] neq 0
		then	perform (add_symbol (ACCOUNT, desc, 0));
		first = false;
		END
	else	perform (add_symbol (ACCOUNT, desc, 0));
	END;




!
!PARSE DATES --
!

perform (parse_dates ());			! Handle /DATE /BEFORE /SINCE




!
!PARSE /ADDRESS VALUE LIST --
!

First = true;
While GET_VALUE ('ADDRESS', desc) do
	BEGIN
	if .first then (address_switch = strip_negator (desc); first = false);
	if .desc [dsc$w_length] neq 0 then
	BEGIN
	if not (lib$cvt_dtb (			! Convert decimal to binary
		.desc [dsc$w_length],		!  -byte count of input string
		.desc [dsc$a_pointer],		!  -address of input string
		.desc [dsc$a_pointer]))		!  -address for resultant value
	then signal_return (msg$_syntax, 1, desc);! Tell user if error occured
	desc [dsc$w_length] =4;			! Set symbol length
	perform (add_symbol (address, desc, 0));
	END;
	END;



!
!PARSE /ENTRY VALUE LIST --
!

First = true;
While GET_VALUE ('ENTRY', desc) do
	BEGIN
	if .first then (entry_switch = strip_negator (desc); first = false);
	if .desc [dsc$w_length] neq 0 then
	BEGIN
	If not (lib$cvt_dtb (			! Convert decimal to binary
		.desc [dsc$w_length],		!  -byte count of input string
		.desc [dsc$a_pointer],		!  -address of input string
		.desc [dsc$a_pointer]))		!  -address for resultant value
	then signal_return (msg$_syntax, 1, desc);! Tell user if error occured
	desc [dsc$w_length] =4;			! Set symbol length
	perform (add_symbol (entry, desc, 0));
	END;
	END;



!
!PARSE /IDENTIFICATION VALUE LIST --
!

First = true;
While GET_VALUE ('IDENT', desc) do
	BEGIN
	if .first then (ident_switch = strip_negator (desc); first = false);
	if .desc [dsc$w_length] neq 0 then
	BEGIN
	If not (lib$cvt_htb (			! Convert hex value to binary
		.desc [dsc$w_length],		!  -byte count of input string
		.desc [dsc$a_pointer],		!  -address of input string
		.desc [dsc$a_pointer]))		!  -address for resultant value
	then signal_return (msg$_syntax, 1, desc);! Tell user if error occured
	desc [dsc$w_length] =4;			! Set symbol length
	perform (add_symbol (IDENT, desc, 0));
	END;
	END;



!
!PARSE /IMAGE VALUE LIST --
!

First = true;
While GET_VALUE ('IMAGE', desc) do
	BEGIN
	if	.first
	then	BEGIN
		image_switch = strip_negator (desc);
		if	.desc [dsc$w_length] neq 0
		then	perform (add_symbol (IMAGE, desc, 0));
		first = false;
		END
	else	perform (add_symbol (IMAGE, desc, 0));
	END;



!
!PARSE /JOB VALUE LIST --
!

First = true;
While GET_VALUE ('JOB', desc) do
	BEGIN
	if	.first
	then	BEGIN
		job_switch = strip_negator (desc);
		if	.desc [dsc$w_length] neq 0
		then	perform (add_symbol (JOB, desc, 0));
		first = false;
		END
	else	perform (add_symbol (JOB, desc, 0));
	END;


!
!PARSE /NODE VALUE LIST --
!

First = true;
While GET_VALUE ('NODE', desc) do
	BEGIN
	if	.first
	then	BEGIN
		node_switch = strip_negator (desc);
		if	.desc [dsc$w_length] neq 0
		then	perform (add_symbol (NODE, desc, 0));
		first = false;
		END
	else	perform (add_symbol (NODE, desc, 0));
	END;




!
!PARSE /OWNER VALUE LIST --
!

First = true;
While GET_VALUE ('OWNER', desc) do
	BEGIN
	if .first then (owner_switch = strip_negator (desc); first = false);
	if .desc [dsc$w_length] neq 0 then
	BEGIN
	If not (lib$cvt_htb (			! Convert hex value to binary
		.desc [dsc$w_length],		!  -byte count of input string
		.desc [dsc$a_pointer],		!  -address of input string
		.desc [dsc$a_pointer]))		!  -address for resultant value
	then signal_return (msg$_syntax, 1, desc);! Tell user if error occured
	desc [dsc$w_length] =4;			! Set symbol length
	perform (add_symbol (OWNER, desc, 0));
	END;
	END;


!
!PARSE /PRIORITY VALUE LIST --
!

First = true;
While GET_VALUE ('PRIORITY', desc) do
	BEGIN
	if .first then (priority_switch = strip_negator (desc); first = false);
	if .desc [dsc$w_length] neq 0 then
	BEGIN
	If not (lib$cvt_dtb (			! Convert decimal value to binary
		.desc [dsc$w_length],		!  -byte count of input string
		.desc [dsc$a_pointer],		!  -address of input string
		.desc [dsc$a_pointer]))		!  -address for resultant value
	then signal_return (msg$_syntax, 1, desc);! Tell user if error occured
	desc [dsc$w_length] =4;			! Set symbol length
	perform (add_symbol (PRIORITY, desc, 0));
	END;
	END;




!
!PARSE /PROCESS VALUE LIST --
!

First = true;
While GET_VALUE ('PROCESS', desc) do
	BEGIN
	LOCAL process_value;
	if	.first
	then	BEGIN
		process_switch = strip_negator (desc);
		if	.desc [dsc$w_length] neq 0
		then	BEGIN
			LOOKUP (desc, process_keyword, process_value);
			perform (ADD_SYMBOL (PROCESS, .process_value, 0));
			END;
		first = false;
		END
	else	BEGIN
		LOOKUP (desc, process_keyword, process_value);
		perform (ADD_SYMBOL (PROCESS, .process_value, 0));
		END;
	END;




!
!PARSE /QUEUE VALUE LIST --
!

First = true;
While GET_VALUE ('QUEUE', desc) do
	BEGIN
	if	.first
	then	BEGIN
		queue_switch = strip_negator (desc);
		if	.desc [dsc$w_length] neq 0
		then	perform (add_symbol (QUEUE, desc, 0));
		first = false;
		END
	else	perform (add_symbol (QUEUE, desc, 0));
	END;



!
!PARSE /REMOTE_ID VALUE LIST --
!

First = true;
While GET_VALUE ('REMOTE_ID', desc) do
	BEGIN
	if	.first
	then	BEGIN
		remote_id_switch = strip_negator (desc);
		if	.desc [dsc$w_length] neq 0
		then	perform (add_symbol (REMOTE_ID, desc, 0));
		first = false;
		END
	else	perform (add_symbol (REMOTE_ID, desc, 0));
	END;



!
!PARSE /REPORT, /SORT, /SUMMARY --
!

Perform (parse_keys ());


!
!PARSE /STATUS VALUE LIST --
!

First = true;
While GET_VALUE ('STATUS', desc) do
	BEGIN
	if .first then (status_switch = strip_negator (desc); first = false);
	if .desc [dsc$w_length] neq 0 then
	BEGIN
	LOCAL status_status;
	If not (lib$cvt_htb (			! Convert hex value to binary
		.desc [dsc$w_length],		!  -byte count of input string
		.desc [dsc$a_pointer],		!  -address of input string
		.desc [dsc$a_pointer]))		!  -address for resultant value
	then signal_return (msg$_syntax, 1, desc);! Tell user if error occured
	desc [dsc$w_length] =4;			! Set symbol length
	status_status = add_symbol (STATUS, desc, 0);
	if not .status_status then return .status_status;
	END;
	END;



!
!PARSE /TERMINAL VALUE LIST --
!

First = true;
While GET_VALUE ('TERMINAL', desc) do
	BEGIN
	if	.first
	then	BEGIN
		terminal_switch = strip_negator (desc);
		if	.desc [dsc$w_length] neq 0
		then	perform (add_symbol (TERMINAL, desc, 0));
		first = false;
		END
	else	perform (add_symbol (TERMINAL, desc, 0));
	END;



!
!PARSE /TYPE VALUE LIST --
!

First = true;
While GET_VALUE ('TYPE', desc) do
	BEGIN
	LOCAL type_value;
	if	.first
	then	BEGIN
		type_switch = strip_negator (desc);
		if	.desc [dsc$w_length] neq 0
		then	BEGIN
			LOOKUP (desc, type_keyword, type_value);
			perform (ADD_SYMBOL (TYPE, .type_value, 0));
			END;
		first = false;
		END
	else	BEGIN
		LOOKUP (desc, type_keyword, type_value);
		perform (ADD_SYMBOL (TYPE, .type_value, 0));
		END;
	END;

!
!PARSE /UIC VALUE LIST --
!

BEGIN

OWN
	group_desc: vector [2] initial (2, group),
	member_desc: vector [2] initial (2, member),
	tparse_block:	BBLOCK [tpa$k_length0]
			INITIAL (tpa$k_count0,tpa$m_blanks OR tpa$m_abbrev);

First = true;
uic_group_switch = 0;
uic_member_switch = 0;
While GET_VALUE ('UIC', desc) do
	BEGIN
	if .first then (uic_switch = strip_negator (desc); first = false);
	if .desc [dsc$w_length] neq 0 then
	BEGIN
	tparse_block [tpa$l_stringcnt] = .desc [dsc$w_length];
	tparse_block [tpa$l_stringptr] = .desc [dsc$a_pointer];
	group = 0;
	member = 0;
	if	not lib$tparse (tparse_block,uic_stb,uic_ktb)
	then	signal_return (msg$_syntax, 1, desc);
	if	.group neq 0 
	then	BEGIN
		EXTERNAL qualifiers: BITVECTOR [];
		qualifiers [uic_group] = 1;
		uic_group_switch = .uic_switch;
		add_symbol (UIC_GROUP, group_desc, 0);
		END;
	if	.member neq 0 
	then	BEGIN
		EXTERNAL qualifiers: BITVECTOR [];
		qualifiers [uic_member] = 1;
		uic_member_switch = .uic_switch;
		add_symbol (UIC_MEMBER, member_desc, 0);
		END;
	END;
	END;
END;

!
!PARSE /USER VALUE LIST --
!

First = true;
While GET_VALUE ('USER', desc) do
	BEGIN
	if	.first
	then	BEGIN
		user_switch = strip_negator (desc);
		if	.desc [dsc$w_length] neq 0
		then	perform (add_symbol (USER, desc, 0));
		first = false;
		END
	else	perform (add_symbol (USER, desc, 0));
	END;



return true;

END;

ROUTINE PARSE_DATES =

!----
!
! Functional description
!
!	This routine is called to parse the /DATE, /BEFORE and /SINCE
!	command switches.
!
! Input parameters
!
!	None
!
! Output parameters
!
!	
!	Store dates for future processing.
!	Set up an offset to the date in the record to be
!	  used for displays and selection criteria.
!	Any errors encountered are RETURNed immediately.
!
!----

BEGIN

OWN
	desc:	bblock [dsc$k_d_bln]	! Dynamic work descriptor
		preset([dsc$b_class] = dsc$k_class_d),

!
!DEFINE KEYWORD TABLES --
!	Define a keyword table for LIB$LOOKUP_KEY.  Associate a byte
!	offset with each of the date keywords.  This offset defines
!	the location within an accounting file of that date.
!

time_keyword:	$lib_key_table	(		! Keyword table -- time type
   (FINISHED,	finish_time_desc [1]),		!  -Time job terminated
   (LOGOUT,	finish_time_desc [1]),		!  -Ditto
   (STOPPED,	finish_time_desc [1]),		!  -Ditto

   (STARTED,	start_time_desc [1]),		!  -Time job logged in
   (LOGIN,	start_time_desc [1]),		!  -Ditto

   (QUEUED,	queue_time_desc [1]),		!  -Time job was queued
   (SUBMITTED,	queue_time_desc [1])		!  -Ditto
		);



!
!PARSE /DATE VALUE --
!
!
!If GET_VALUE ('DATE', desc) then	! /DATE type
!   LOOKUP (desc, time_keyword, date_desc_addr);

date_desc_addr = finish_time_desc [1];
date_header = addrdesc ('finished');		! Set default date header

!If .date_desc_addr eql queue_time_desc [1]	! If /DATE=QUEUED
!   then date_header = addrdesc ('queued');	! Fix date header
!
!If .date_desc_addr eql start_time_desc [1]		! If /DATE=STARTED
!   then date_header = addrdesc ('started');	! Fix date header

!
!PARSE /BEFORE AND /SINCE DATE VALUES --
!

If GET_VALUE ('BEFORE', desc) then	! /BEFORE value
   perform (lib$cvt_time (desc, before_date));

If GET_VALUE ('SINCE', desc) then	! /SINCE value
   perform (lib$cvt_time (desc, since_date));

Return true;
END;

ROUTINE PARSE_KEYS =

!---
!
! Functional description
!
!	This routine is called from the main parser to handle those
!	qualifiers that causes dynamic strings to be built.  That is,
!	sort keys, report items, and summarization keys.
!
! Output parameters
!
!	Any errors encountered are RETURNed immediately.
!	TRUE is returned on a normal exit.
!
!----

BEGIN

LOCAL
	result:	ref vector [2];		! Holds pointer returned by lookup

!
! Each of the three element entries below consists of the following:
!
!	1) Key type (1=char, 2=binary)
!	3) Address of record item descriptor
!	4) Maximum size in bytes of the target field
!
GLOBAL

key_table: blockvector [32, 3] initial	(

1, account_desc, 8,			! Account name
2, entry_desc, 4,			! Entry (job id)
2, finish_time_desc, 8,			! Termination time
2, ident_desc, 4,			! Process ID
1, image_desc, 9,			! Image name
1, job_desc, 9,				! Job name
1, node_desc, 6,			! Remote node name
2, owner_desc, 4,			! Owner process ID
1, process_desc, 11,			! Process type
1, queue_desc, 16,			! Queue name
2, queue_time_desc, 8,			! Queue time
2, start_time_desc, 8,			! Start time
2, status_desc, 4,			! Final status
1, terminal_desc, 8,			! Terminal name
1, type_desc, 8,			! Record type
1, user_desc, 12,			! User name
2, address_desc, 4,			! Remote node address
2, buffered_io_desc, 4,			! Buffered IO count
2, direct_io_desc, 4,			! Direct IO count
2, cpu_time_desc, 4,			! Cpu time
2, page_faults_desc, 4,			! Page faults
2, page_reads_desc, 4,			! Page IO
2, page_file_desc, 4,			! Page file peak
2, working_set_desc, 4,			! Working set peak
2, execution_desc, 4,			! Image execution count
2, uic_binary_desc, 4,			! UIC
2, elapsed_desc, 8,			! Elapsed time
2, priority_desc, 1,			! Priority
2, volumes_desc, 4,			! Volumes mounted
2, sym_page_desc, 4,			! Pages printed
2, sym_get_desc, 4,			! Symbiont gets
2, sym_qio_desc, 4			! Symbiont qios
					);

OWN
	desc:	bblock [dsc$k_d_bln]	! Dynamic work descriptor
		preset([dsc$b_class] = dsc$k_class_d),

!
! Now build a table that associates each sort keyword
! with one of the sort key descriptor elements
!

sort_keyword:	$lib_key_table (	! Keywords for /SORT qualifier

	(ACCOUNT,	00),		! User's account name
	(ENTRY,		01),		! Number of batch or print job
	(FINISHED,	02),		! Termination time
	(IDENT,		03),		! Process identification
	(IMAGE,		04),		! Image name
	(JOB,		05),		! Name of batch or print job
	(NODE,		06),		! Node name
	(OWNER,		07),		! Owner process identification
	(PROCESS,	08),		! Process type
	(QUEUE,		09),		! Name of queue
	(QUEUED,	10),		! Time job was queued
	(STARTED,	11),		! Start time
	(STATUS,	12),		! Final exit status
	(TERMINAL,	13),		! Terminal name
	(TYPE,		14),		! Record type
	(USER,		15),		! User's name
	(ADDRESS,	16),		! Remote node address
	(BUFFERED_IO,	17),		! Buffered IO count
	(DIRECT_IO,	18),		! Direct IO count
	(PROCESSOR,	19),		! CPU time
	(FAULTS,	20),		! Page faults
	(PAGE_READS,	21),		! Page IO
	(PAGE_FILE,	22),		! Page file peak
	(WORKING_SET,	23),		! Working set peak
	(EXECUTION,	24),		! Image execution count
	(UIC,		25),		! UIC
	(ELAPSED,	26),		! Elapsed time
	(PRIORITY,	27),		! Priority
	(VOLUMES,	28),		! Volumes mounted
	(PAGES,		29),		! Pages printed
	(GETS,		30),		! Symbiont gets
	(QIOS,		31)		! Symbiont qios
	),


!
! Build a lookup table that associates each summary option keyword with
! a three longword structure.  The first longword contains the address
! of a descriptor of the data field in the record.  The second longword
! contains the address of a descriptor of a FAO control string that
! is used to concatenate keys.  The third longword contains the address
! of a descriptor of a string suitable for use in the header FAO.
!


summary_keyword: $lib_key_table (	! Keywords for /SUMMARY qualifier

(ACCOUNT,UPLIT (account_desc,	ad('!9AS'),  ad('Account  '))),	! Account
(DATE,	UPLIT (s_date_desc,	ad('!11AS'),  ad('YYYY MM DD '))),! Date
(DAY,	UPLIT (day_desc,	ad('!3AS'),  ad('DD '))),	! Day of month
(HOUR,	UPLIT (hour_desc,	ad('!3AS'),  ad('HH '))),	! Hour of day
(IMAGE, UPLIT (image_desc,	ad('!11AS'),  ad('Image name '))),! Image name
(JOB,	UPLIT (job_desc,	ad('!9AS'),  ad('Job name '))),	! Batch/print
(MONTH,	UPLIT (month_desc,	ad('!3AS'),  ad('MM '))),	! Month of year
(NODE,	UPLIT (node_desc,	ad('!10AS'),  ad('Node name '))),! Node name
(PROCESS,UPLIT (process_desc,	ad('!13AS'),  ad('Process type '))),! Process
(QUEUE,	UPLIT (queue_desc,	ad('!16AS'), ad('Job/print queue '))),! Queue
(TERMINAL, UPLIT (terminal_desc,ad('!9AS'),  ad('Terminal '))),	! Terminal name
(TYPE,	UPLIT (type_desc,	ad('!8AS'),  ad('Type    '))),	! Record type
(UIC,	UPLIT (uic_desc,	ad('!10AS'), ad(' U  I  C  '))),! UIC
(USER,	UPLIT (user_desc,	ad('!13AS'), ad('Username     '))),! User
(WEEKDAY,UPLIT (weekday_desc,	ad('!3AS'),  ad('DD '))),	! Day of week
(YEAR,	UPLIT (year_desc,	ad('!5AS'),  ad('Year '))),	! Year
				),

!
! Build a table that associates each report option keyword with
! a structure of longwords that contains:
!
!	1) Summation type (additive, peak, elapsed time, etc)
!	2) Summation value (address of value, constant, etc)
!	3) Number of longwords needed in accumulator
!	4) Descriptor of FAO control string for eventual output
!	5) Descriptor of FAO control string for title line 1
!	6) Descriptor of FAO control string for title line 2
!

report_keyword: $lib_key_table (	! Keywords for /REPORT qualifier

(BUFFERED_IO,	UPLIT (sum_type_add, hold_biocnt, 1,
		ad (' !8UL'), ad (' Buffered'), ad ('    I/O  '))),

(DIRECT_IO,	UPLIT (sum_type_add, hold_diocnt, 1,
		ad (' !8UL'), ad ('   Direct'), ad ('    I/O  '))),

(ELAPSED,	UPLIT (sum_type_addx, hold_elapsed, 3,
		ad (' !2UL !%T'), ad ('     Elapsed   '),
		ad ('       Time    '))),

(EXECUTION,	UPLIT (sum_type_add, hold_execution, 1,
		ad (' !8UL'), ad ('  Image  '), ad ('   Count '))),

(FAULTS,	UPLIT (sum_type_add, hold_pageflts, 1,
		ad (' !8UL'), ad ('    Page '), ad ('   Faults'))),

(GETS,		UPLIT (sum_type_add, hold_getcnt, 1,
		ad (' !8UL'), ad (' Symbiont'), ad ('   Gets  '))),

(PAGES,		UPLIT (sum_type_add, hold_pagcnt, 1,
		ad (' !8UL'), ad ('    Pages'), ad ('  Printed'))),

(PAGE_FILE,	UPLIT (sum_type_peak, hold_pgflpeak, 1,
		ad (' !8UL'), ad (' Peakpage'), ad (' File use'))),

(PAGE_READS,	UPLIT (sum_type_add, hold_pagereads, 1,
		ad (' !8UL'), ad (' Page IO '), ad (' Reads   '))),

(PROCESSOR,	UPLIT (sum_type_addx, hold_cputim, 3,
		ad (' !2UL !%T'), ad ('    Processor  '),
		ad ('       Time    '))),

(QIOS,		UPLIT (sum_type_add, hold_qiocnt, 1,
		ad (' !8UL'), ad (' Symbiont'), ad ('   QIO''s '))),

(RECORDS,	UPLIT (sum_type_incr, 0, 1,
		ad (' !8UL'), ad ('    Total'), ad ('  Records'))),

(VOLUMES,	UPLIT (sum_type_add, hold_volumes, 1,
		ad (' !8UL'), ad ('  Volumes'), ad ('  Mounted'))),

(WORKING_SET,	UPLIT (sum_type_peak, hold_wspeak, 1,
		ad (' !8UL'), ad (' Peakwork'), ad (' Set page')))

				);



!
!PARSE /SORT VALUE LIST --
!	Fetch the value(s) associated with the /SORT qualifier.  Use
!	LIB$LOOKUP_KEY to parse them.  If successful, an index into
!	a sort key descriptor table is returned.  The descriptors are
!	copied (in the user specified order) to the SORT_TABLE.
!
!	Note that the first entry in SORT_TABLE is NOT used to store
!	the number and type of entries as is done with the other tables.
!	The sort keys must be preceeded by a single word (SORT_KEY_COUNT)
!	that gives the number of keys.
!
sort_key_count = 0;				! Initialize sort key count
Incr i from 0 to max_sort do
   BEGIN					! /SORT value list
   Local key_order, index;

   If not (GET_VALUE ('SORT', desc))
      then exitloop;

   Key_order = 0;				! Assume ascending
   If not strip_negator (desc) then
      key_order = 1;				! No, set descending

   LOOKUP (desc, sort_keyword, index);



!
! MOVE KEY DESCRIPTORS
!	Move the key descriptors.  Note that more than one descriptor
!	may be needed to describe a key.  The number of descriptors
!	is stored in the order field (ascend/descend) of the first 
!	descriptor since this field is dynamically set based on the negator.
!

   Sort_table [.sort_key_count,key_w_type] = .key_table [.index, sort_type];
   Sort_table [.sort_key_count,key_w_order] = .key_order;
   Sort_table [.sort_key_count,key_w_pos] = .index;
   Sort_table [.sort_key_count,key_w_length] = .key_table [.index, sort_length];
   Sort_key_size = .sort_key_size + .key_table [.index, sort_length];
   Sort_key_count = .sort_key_count + 1;

   END;




!
! PARSE /SUMMARY VALUE LIST --
!	Parse the list of values associated with the /SUMMARY qualifier.
!	For each value store the address of the value descriptor in a
!	table and build a concatenated FAO control string.
!
!	In build_summary the FAO control string and the list of descriptors
!	is used to build the summation key.
!
!	Also, the FAO control string which prints the column header is
!	modified to reflect the contents of the summation key.
!

Incra i do
    if not GET_VALUE ('SUMMARY', desc) then exitloop	! Get value
    else BEGIN
	If str$compare (desc, ad ('USER')) eqlu 0	! Special case
	   AND not PRESENT (TYPE)
	   then BEGIN
		EXTERNAL qualifiers: bitvector [];	! Establish def type
		qualifiers [TYPE] = true;
		perform (add_symbol (type, ad ('LOGFAIL'), true));
		END;

	If    str$compare (desc, ad('HOUR')) eqlu 0
	   or str$compare (desc, ad('WEEKDAY')) eqlu 0
	   or str$compare (desc, ad('DAY')) eqlu 0
	   or str$compare (desc, ad('MONTH')) eqlu 0
	   or str$compare (desc, ad('YEAR')) eqlu 0
	   or str$compare (desc, ad('DATE')) eqlu 0
	then BEGIN
	   EXTERNAL qualifiers: bitvector [];
	   qualifiers [expand_date] = TRUE;
	     END;

	LOOKUP (desc, summary_keyword, result);			! Lookup
	sum_key_value [.i] = .result [0];			! Store addr
	perform (str$append (sum_key_fao, .result [1]));	! Build FAO
	perform (str$append (report_hdr1_fao, .result [2]));	! Build FAO
	perform (str$append (report_hdr3_fao, .result [2]));	! Build FAO
	END;
!
! Fill the front of report header 2 with spaces equal to the length
! of the symbol header (which is equal to length of report header 1)
!

Perform (str$dupl_char (
		report_hdr2_fao, %REF (.report_hdr1_fao [dsc$w_length])));


!
! PARSE /REPORT VALUE LIST --
!	Parse the list of values associated with the /REPORT qualifier.
!	For each value store the address of the control structure in the
!	value table and build  concatenated FAO control strings for
!	report writing time.  One string describes the header for the
!	report, the other the detail line.
!

! Place a FAO arguement at the front of the report detail FAO control
! string to print the summation key at WRITE_SUMMARY time.

Perform (str$append (report_det_fao, ad('!AS')));

Incra i do
    if not GET_VALUE ('REPORT', desc) then exitloop
    else BEGIN
         LOOKUP (desc, report_keyword, result);
         report_value [.i] = .result;
	 bucket_size = .bucket_size + (.result [sum_ent_bsize] * 4);
         perform (str$append (report_det_fao, .result [sum_ent_fao]));
         perform (str$append (report_hdr1_fao, .result [sum_ent_hdr1]));
         perform (str$append (report_hdr2_fao, .result [sum_ent_hdr2]));
	 report_items = .report_items + 1;
         END;

!
! If /REPORT is active then reserve one more slot in the bucket 
! for the symbol descriptor address
!

If .bucket_size neq 0 then bucket_size = .bucket_size + 4;

return true;

END;

END
ELUDOM
