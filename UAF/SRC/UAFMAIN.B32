MODULE UAFMAIN( MAIN = START,
		IDENT = 'V03-001',
		ADDRESSING_MODE(EXTERNAL=GENERAL)
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY:	System Management Utility Program
!
! ABSTRACT:
!
!	This program allows the system manager to maintain the user
!	authorization file which contains usernames, passwords, quotas,
!	and defaults.  The following functions are provided:
!
!		ADD - add a new user record to the authorization file (UAF)
!     		COPY - copy a user record, give copied record a new name
!		DEFAULT - change a default value
!		EXIT - exit program and update file
!		HELP - ask for explanation
!		LIST - complete list of records to file
!		MODIFY - change one or more values for a user
!		REMOVE - remove a user record
!		RENAME - rename a user record ( COPY; REMOVE )
!		SHOW - display the values from a user record
!
! ENVIRONMENT:
!
! AUTHOR:	Henry M. Levy	, CREATION DATE: 1-June-1977
!
! MODIFIED BY:
!
!	001	JWT0022		Jim Teague	17-Mar-1982
!		Fix bug that caused failure to reparse command line for
!		wildcard modifications.  List default device on its own
!		line for show/full.
!
!--

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
	START,				! controlling code
	SETUP		:NOVALUE,	! open initial files
	ADD_UAF		:NOVALUE,	! insert new user record
	ADD_PROXY	:NOVALUE,	! insert new proxy record
	REMOTE_PARSE,			! parses "node::remoteuser"
 	COPY_UAF                ,       ! copy user record
	CREATE_PROXY	:NOVALUE,	! create NETUAF.DAT proxy file
!	MODIFY_UAF_ACCT :NOVALUE,
	MODIFY_UAF	:NOVALUE,	! update user record(s)
	MODIFY_REC,			! update a user record action routine
	REMOVE_UAF	:NOVALUE,	! remove username from file
	REMOVE_PROXY	:NOVALUE,	! remove a proxy record
	RENAME_UAF	:NOVALUE,	! rename user record
	ADJUST_PROXY	:NOVALUE,	! implicitly remove/update proxy record
	DEFAULT_UAF	:NOVALUE,	! change default record
	DISPLAY_PROXY   :NOVALUE,	! format and output a proxy entry
	LIST_UAF	:NOVALUE,	! list file routine
	LIST_PROXY	:NOVALUE,	! list proxy entries in NETUAF.LIS
	SHOW_USER_UAF	:NOVALUE,	! display user record
	SHOW_PROXY 	:NOVALUE,	! display proxy record at terminal
	LOCATE_PROXY,			! access given proxy record(s)
 	GET_PROXY_RECORD,		! read single proxy record
	WILD_USER,			! user wild card routine
	DISPLAY_BRIEF,			! writes a brief user display
	CLASSIFY_PRIV,			! classifies contents of priv vector
	DISPLAY_FULL,			! writes the full user display
	PRINT_PRIV	:NOVALUE,	! print privilege bits
	BUILD_INI_RECS	:NOVALUE,	! build initial file records for default
					! and system manager
	GET_USER_RECORD,		! get username and lookup record
	LOCATE_USER,			! lookup user record in UAF
	GET_UAF_RECORD,			! routine to deal with record locking
	GET_CMD_LINE	:NOVALUE,	! input user command line
	ASK		:NOVALUE,	! prompt terminal for input
	FMT_SYS_MSG	:NOVALUE,	! output system message file message
	FAOOUT,				! output formatted message
	HELP_UAF	:NOVALUE,	! help routine
	EXIT_UAF	:NOVALUE,	! normal exit routine
	ACC$EXIT	:NOVALUE;	! exit and cleanup routine

LINKAGE
	fmg_match = JSB ( REGISTER = 2, REGISTER = 3, REGISTER = 4,
			  REGISTER = 5 ) : NOTUSED (10, 11);

!
! EXTERNAL REFERENCES:
!

EXTERNAL LITERAL
	cli$_bufovf,
	cli$_noclint;


EXTERNAL ROUTINE
	lbr$output_help,
	lib$get_foreign,
	lib$get_input,
	lib$put_output,
	fmg$match_name : fmg_match,
	cli$dcl_parse,
	cli$dispatch,
	cli$present,
	cli$get_value,
	UPDATE_RECORD,			! modify all specified fields
	PARSE_WILD,			! parses a wildcarded user specification
	LGI$HPWD;			! hash password routine

EXTERNAL
	AUTHORIZE_COMMANDS,		! AUTHORIZE command parse tables
	PRV$AB_NAMES;			! address of privilege name table

!
! INCLUDE FILES:
!
  
  
LIBRARY 'SYS$LIBRARY:LIB.L32';

LIBRARY 'SYS$LIBRARY:TPAMAC.L32';


!
! MACROS:
!

MACRO

    NAMELEN  =
	BEGIN
	LOCAL
	    size,
	    text,
	    len;

!	IF .by_account
!	THEN
!	    BEGIN
!	    size = UAF$S_ACCOUNT;
!	    text = RECBUF [UAF$T_ACCOUNT];
!	    END 
!	ELSE
!  	    BEGIN
	    size = UAF$S_USERNAME;
	    text = RECBUF [UAF$T_USERNAME];
!	    END;

	IF CH$FAIL( len = CH$FIND_CH( .size,
				      .text, ' '))
	THEN
	    len = .size
	ELSE
	    len = .len - .text;
	.len
	END  %,

    CSTRING[] = (UPLIT BYTE(%CHARCOUNT(%STRING(%REMAINING)),
		%STRING(%REMAINING)) )%,

    FATAL[] = ( FMT_SYS_MSG(%REMAINING) ; ACC$EXIT() )%,

!
! Macros to check for success or failure from RMS
!

    RMSBAD(STRING) = (NOT(RMSERR = STRING)) %,
    RMSOK(STRING) = (RMSERR = STRING) %,

!
! Macros to set up and write an FAO string.
!

    FAOMAC( FAOMSG )[] =
	FAODSC[DSC$W_LENGTH] = . %NAME( FAOMSG ) <0,8> ;
	FAODSC[DSC$A_POINTER] = %NAME( FAOMSG ) + 1 ;
	$FAO( FAODSC , RABPTR[RAB$W_RSZ] , DISDSC $COMMA(%REMAINING)
			%REMAINING ) ;
	$PUT(RAB = .RABPTR) ; %,

    $COMMA[] = , %,

!
! Macro to create string descriptor for command parameters and
!	qualifiers
!
    SD[A] =
	BIND %NAME('SD_',A) = $descriptor(a)%;

     SD(
      	'token1',	'token2',	'DISCTLY',	'DEFCLI',
	'CAPTIVE',	'LOCKPWD',	'DISDIALUP',	'DISNETWORK',
	'MONDAY',	'TUESDAY',	'WEDNESDAY',	'THURSDAY',
	'FRIDAY',	'SATURDAY',	'SUNDAY',	
	'brief',	'full',		'DISUSER',	'DISNEWMAIL',
	'DISWELCOME'
       );


!
! EQUATED SYMBOLS:
!

LITERAL
	FALSE = 0 ,			! logical false
	TRUE = 1 ,			! logical true

	update_records = 0,		! flag for proxy file adjustment
	remove_records = 1,		!  "    "    "    "       "

	copy_flag = 1,			! used in routine copy_uaf
	rename_flag = 1,		! used in routine rename_uaf

	BYTE_LENGTH = 8 ,		! bits per byte
	WORD_LENGTH = 16 ,		! bits per word
	LONG_LENGTH = 32 ,		! bits per longword

	ENCRYPT = UAF$C_Purdy,		! encryption algorithm to use

	RETRY_RLK = 2,			! number of retries for a locked record
	SLEEP_RLK = 75,			! ms to sleep before retrying

	LF = 10,
	ZERO = 0,

	CMDBUFLEN = 1024 ,		! size of user command buffer
	DISBUFLEN = 132 ;		! size of display file output buffer

GLOBAL LITERAL
	num_flags = 7,		! number of FLAG_TABLE entries
	num_opflags = 2,	! number of OPFLAG_TABLE entries
	num_pdflags = 7;	! number of entries in prime days table
BIND

dbl_colon = $descriptor('::'),

!
! Define the system delta time to sleep before retrying to GET a locked record.
!

    WAKEDELTA = UPLIT LONG(-10*1000*SLEEP_RLK,-1),

!
! Default values for authorization file record.  These values are
! only used when a new authorization file is created.  If the file
! already exists, the default values are read from the first file
! record.
!

    DEFUSER = CSTRING('DEFAULT'),	! default username
    DEFPASS = CSTRING('USER'),		! default password
    DEFACT = CSTRING(''),		! default account name
    DEFCLI = CSTRING('DCL'),		! default command interpreter
    DEFOWNER = CSTRING(''),		! owner's name
    DEFLGICMD = CSTRING(''),		! default login command file
    DEFGRP = %O'200' ,			! default group
    DEFMEM = %O'200' ,			! default member
    DEFDIR = CSTRING('[USER]'),		! default directory name
    DEFDEV = CSTRING(''),		! default device name
    DEFBIOLM = 6 ,			! default buffered I/O limit
    DEFBYTLM = 4096 ,			! default buffered I/O buffer space
    DEFDIOLM = 6 ,			! default direct I/O limit
    DEFFILLM = 20 ,			! default open file limit
    DEFFLAGS = 0 ,			! default flag bits
    DEFTQCNT = 10 ,			! default time queue entries
    DEFPRCCNT = 2 ,			! default subprocess count
    DEFPRI = 4 ,			! default process priority
    DEFWSQUOTA = 200 ,			! default working set limit
    DEFDFWSCNT = 150 ,			! "default" working set default size
    DEFWSEXTENT = 500 ,			! default working set extent
    DEFCPUTIM = 0 ,			! default CPU time quota
    DEFASTLM = 10 ,			! default AST queue limit
    DEFPGFLQUOTA = 10000 ,		! default paging file limit in pages
    DEFENQLM = 10 ,			! default enqueue limit
    DEFPBYTLM = 0 ,			! default paged buffer I/O limit
    DEFSHRFILLM = 0 ,			! default shared file limit
    DEFMAXJOBS = 0 ,			! default maximum concurrent jobs
    DEFMAXACCTJOBS = 0 ,		! default maximum concurrent group jobs
    DEFPRIMEDAYS = (			! Sat, Sun are default non-prime days
	( 1 ^ $BITPOSITION(UAF$V_SATURDAY) ) OR
	( 1 ^ $BITPOSITION(UAF$V_SUNDAY) )
	) , 
    DEFHOURS = 0 ,			! default all hours to allow access
    DEFACCESSFLAGS = 0 ,		! default access flags to all
    DEFPRIV = UPLIT(			! default privilege vector
	(
	( 1 ^ $BITPOSITION(PRV$V_NETMBX) ) OR
	( 1 ^ $BITPOSITION(PRV$V_TMPMBX) )
	) , 0 ),

!
! The following are the default values for the SYSTEM user.  When
! a new file is created, a system manager record is created.
!

    SYSUSER = CSTRING('SYSTEM'),
    SYSPASS = CSTRING('MANAGER'),
    SYSACT = CSTRING('SYSTEM'),
    SYSCLI = CSTRING('DCL'),
    SYSOWNER = CSTRING('SYSTEM MANAGER'),
    SYSLGICMD = CSTRING(''),
    SYSGRP = %O'1' ,
    SYSMEM = %O'4' ,
    SYSDIR = CSTRING('[SYSMGR]'),
    SYSDEV = CSTRING(''),
    SYSBIOLM = 12 ,
    SYSBYTLM = 20480 ,
    SYSDIOLM = 12 ,
    SYSFILLM = 20 ,
    SYSFLAGS = 0 ,
    SYSTQCNT = 20 ,
    SYSPRCCNT = 10 ,
    SYSPRI = 4 ,
    SYSWSQUOTA = 1024 ,
    SYSWSEXTENT = 1024 ,
    SYSDFWSCNT = 150 ,
    SYSCPUTIM = 0 ,
    SYSASTLM = 20,
    SYSPGFLQUOTA = 10000 ,
    SYSENQLM = 20 ,
    SYSPBYTLM = 0 ,
    SYSSHRFILLM = 0 ,
    SYSMAXJOBS = 0 ,
    SYSMAXACCTJOBS = 0 ,
    SYSPRIMEDAYS = (			! Sat, Sun are default non-prime days
	( 1 ^ $BITPOSITION(UAF$V_SATURDAY) ) OR
	( 1 ^ $BITPOSITION(UAF$V_SUNDAY) )
	) , 
    SYSHOURS = 0 ,
!    SYSACCESSFLAGS = (			! disallow network/dialin use of SYSTEM
!	( 1 ^ $BITPOSITION(UAF$V_DISNETWORK) ) OR
!	( 1 ^ $BITPOSITION(UAF$V_DISDIALUP) )
!	) , 
    SYSACCESSFLAGS = 0,
    SYSPRIV = UPLIT(REP 2 OF (%X'FFFFFFFF')) ;

!
! OWN STORAGE:
!
OWN

!
! This flag specifies the type of access allowed to SYSUAF.DAT and NETUAF.DAT
!
    read_only,

!
! This flag indicates whether the DEFAULT record is being updated by
!   the MODIFY command rather than by the DEFAULT command
!
    mod_default,

!
! "found_match" flag indicates at least one wildcard match was found
!
    found_match,

!
! Modify flag indicates if the file has been changed.  If no change
! is made, exit will not rename the file.
!

    MODIFY_FLAG: LONG ,

!
! Variables used for RENAME_UAF operations
!
    savedlen: LONG,
    rename_ph2: BYTE INITIAL(false),


!
! A place to save tokens
!
    savedtoken: VECTOR [UAF$S_USERNAME,BYTE],

!
! Buffer to read in user command line.  This buffer must be long
! enough to hold multi-line commands.
!

    CMDBUF: VECTOR[CMDBUFLEN,BYTE] ,

!
! Display file output buffer and a descriptor for the FAO system service.
!

    DISBUF: VECTOR[DISBUFLEN,BYTE] ,
    DISDSC: BLOCK[8,BYTE] INITIAL(DISBUFLEN,DISBUF),

!
! A general purpose FAO source string descriptor.
!

    FAODSC: BLOCK[8,BYTE] ,

!
! Default record.  The record in the UAF file which contains
! default values is read into this space.
!

    DEFAULT_SIZE: WORD,
    DEFAULT_RECORD: BLOCK[UAF$C_LENGTH,BYTE],

!
! Descriptor for password strings
!

    PWDDSC: BLOCK[8,BYTE] ,

!
! Variable to contain number of characters read on terminal input.
!

    INSIZE: LONG ,

!
! A pointer to aim the display routines at the correct RAB.
!

    RABPTR: REF BLOCK[RAB$C_BLN,BYTE] ,

!
! Display option flags
!

    BRIEF_FLAG: LONG ,
    FULL_FLAG: LONG ,

!
! A flag to allow display routines to decide when to output headers.
!

    HEADER_FLAG: LONG ,

!
! Location to store RMS error codes.
!

    RMSERR: LONG ,

!
! FAB and RAB for terminal I/O
!

    INFAB: $FAB(
	FAC = (GET,PUT),
	RAT = CR ,
	FNM = 'SYS$INPUT'
	),

    INRAB: $RAB(
	RAC = SEQ ,
	ROP = PMT ,			! convert all input to upper case
	FAB = INFAB
	),

    OUTFAB: $FAB(
	FAC = (PUT),
	RAT = CR ,
	FNM = 'SYS$OUTPUT'
	),

    OUTRAB: $RAB(
	RAC = SEQ ,
	RBF = DISBUF ,
	FAB = OUTFAB
	),

!
! RMS data structures for LIST command
!

    LSTNAM: $NAM (),			! needed for the DLT option

    LSTFAB: $FAB (
	FAC = PUT ,
	RAT = CR ,
	FNM = 'SYSUAF.LIS' ,
	SHR = NIL ,
	ORG = SEQ ,
	RFM = VAR ,
	MRS = DISBUFLEN ,
	NAM = LSTNAM
	),

    LSTRAB: $RAB (
	RAC = SEQ ,
	RBF = DISBUF ,
	FAB = LSTFAB
	),

!
! RMS data structures for NETUAF.LIS
!

    NLSTNAM: $NAM (),

    NLSTFAB: $FAB (
	FAC = PUT,
	RAT = CR,
	FNM = 'NETUAF.LIS',
	SHR = NIL,
	ORG = SEQ,
	RFM = VAR,
	MRS = DISBUFLEN,
	NAM = NLSTNAM
	),

    NLSTRAB: $RAB (
	RAC = SEQ,
	RBF = DISBUF,
	FAB = NLSTFAB
	),
	

!
! RMS data structures for the User Authorization File.
!

    UAFKEY2: $XABKEY (			! XAB for User number key
	KREF = 2 ,			! alternate key
	POS0 = $BYTEOFFSET(UAF$W_MEM),
	SIZ0 = 2 ,
	DTP = BN2 ,
	FLG = (CHG,DUP)
	),

    UAFKEY1: $XABKEY (			! XAB for Group number key
	KREF = 1 ,			! alternate key
	POS0 = $BYTEOFFSET(UAF$L_UIC),
	SIZ0 = 4 ,
	DTP = BN4 ,
	FLG = (CHG,DUP),
	NXT = UAFKEY2
	),

    UAFKEY0: $XABKEY (			! XAB for USERNAME key
	KREF = 0 ,			! primary key
	POS0 = $BYTEOFFSET(UAF$T_USERNAME),
	SIZ0 = UAF$S_USERNAME ,
	NXT = UAFKEY1
	),

    UAFPRO: $XABPRO (			! XAB for file protection
	PRO = (RWED,RWED),		! deny world access
	NXT = UAFKEY0
	),

    UAFFAB: $FAB (			! FAB for work file
	FOP = CIF ,			! allow only one version
	FAC = (GET,PUT,DEL,UPD),	! access types
	FNM = 'SYSUAF' ,		! user authorization file name
	DNM = '.DAT' ,
	SHR = (GET,PUT,DEL,UPD),
	ORG = IDX ,			! indexed operations
	RFM = VAR ,
	MRS = UAF$C_LENGTH ,		! maximum record size
	ALQ = 10 ,			! initial allocation
	DEQ = 10 ,			! extend size
	XAB = UAFPRO			! file protection XAB
	) ,

!
! FAB for NETUAF Proxy Login File
!
!

	NAFKEY1: $XABKEY (
		KREF = 1,
		POS0 = $BYTEOFFSET(NAF$T_LOCALUSER),
		SIZ0 = NAF$S_LOCALUSER,
		FLG = (CHG,DUP)
		),

	NAFKEY0: $XABKEY (
		KREF = 0,
		POS0 = $BYTEOFFSET(NAF$T_REMNAME),
		SIZ0 = NAF$S_REMNAME,
		NXT = NAFKEY1
		),

	NAFPRO: $XABPRO (
		PRO = (RWED,RWED),
		NXT = NAFKEY0
		),

	NAFFAB: $FAB (
		FOP = CIF,
		FAC = (GET,PUT,DEL,UPD),
		FNM = 'NETUAF',
		DNM = '.DAT',
		SHR = (GET,PUT,DEL,UPD),
		ORG = IDX,
		RFM = FIX,
		MRS = NAF$C_LENGTH,
		ALQ = 10,
		DEQ = 10,
		XAB = NAFPRO
		);

!
! GLOBAL STORAGE:
!
GLOBAL

!
! Flag to indicate a RENAME to UAFPARSE 
!
    rename:		LONG INITIAL(false),

!
! Flag to indicate an ADD to UAFPARSE
!
    add:		LONG INITIAL(false),

!
! Flag to indicate a COPY to UAFPARSE
!
    copy:		LONG INITIAL(false),

!
! Flag to indicate processing by account
!
!    by_account:	LONG INITIAL(false),

!
!   Place to save match string for fmg$match_name
!
    match_token   : VECTOR [UAF$S_USERNAME, BYTE],
    match_tokenlen: LONG,

!
! Flag to indicate whether access to proxy entries is wild
!
    wild_netuser,

!
! Counter for re-parsing command line
!
    call_count: LONG INITIAL (0),

!
! Input parsing descriptors.
!

    TOKENDSC : BLOCK [8,BYTE] PRESET ([dsc$b_class]=dsc$k_class_d) ,
    CMDLINDSC: BLOCK [8,BYTE] ,

    netuaf_exists,		! A self-explanatory flag...

!
! Record buffer for file I/O.  Records are generally read into RECBUF,
! modified, and output.
!

    RECBUF: BLOCK[UAF$C_LENGTH,BYTE] ,
    NETBUF: BLOCK[NAF$C_LENGTH,BYTE] ,

!
! UAFRAB is global to allow UPDATE_RECORD to modify RAB$W_RSZ.
!

    UAFRAB: $RAB (			! RAB for work file
	ROP = RLK ,			! allow others to read locked records
	KRF = 0 ,			! key of reference
	KBF = RECBUF[UAF$T_USERNAME] ,	! key buffer overlays record buffer
	KSZ = UAF$S_USERNAME ,
	USZ = UAF$C_LENGTH ,		! establish record size for input
	FAB = UAFFAB
	),

!
! RAB for NETUAF Proxy Login File
!

	NAFRAB: $RAB (
		ROP = RLK,
		KRF = 0,
		KBF = NETBUF [NAF$T_REMNAME],
		KSZ = NAF$S_REMNAME,
		USZ = NAF$C_LENGTH,
		RSZ = NAF$C_LENGTH,
		RAC = KEY,
		FAB = NAFFAB
		),


!
! Buffer to receive current system time.
!

    TIME_BUF: BLOCK[8,BYTE] ,

!
! Password default flag.  Cleared if the GETPASSWORD action is taken.
!

    PWD_FLAG: LONG ,

!
! Wildcard parsing flags set by PARSE_WILD for use in WILD_USER.
!

    UIC_FLAG: LONG ,
    GRP_WILD: LONG ,
    MEM_WILD: LONG ,
    STR_WILD: LONG ;

GLOBAL BIND
!
! Address and length of the current token being processed from the
! input command line.
!

    TOKENLEN  = TOKENDSC  [DSC$W_LENGTH]  : WORD,
    TOKENPTR  = TOKENDSC  [DSC$A_POINTER]       ,
    
!
! Descriptors for the Username and Password fields in RECBUF.
!

    REC_USER_DSC = UPLIT(UAF$S_USERNAME, RECBUF[UAF$T_USERNAME]),
    REC_ENCRYPT_DSC = UPLIT(UAF$S_PWD, RECBUF[UAF$Q_PWD]),

!
! Valid usernames consist of the following characters:
!

SYMBOL_STR = CSTRING('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_'),

!
! Global message strings.
!

KEYNOTFND = CSTRING('invalid option name \!AD\'),
KEYNOTUNQ = CSTRING('option name not unique \!AD\'),
NOARG = CSTRING('missing argument for option \!AD\');

GLOBAL


!
! The definition table for flag bits for UAF$B_FLAGS.
!

    FLAG_TABLE : VECTOR [2 * num_flags + 1,LONG] INITIAL (
	2 * num_flags,
	UPLIT (%ASCIC'DISCTLY')      ,	$BITPOSITION(UAF$V_DISCTLY),
	UPLIT (%ASCIC'DEFCLI')	     ,	$BITPOSITION(UAF$V_DEFCLI),
	UPLIT (%ASCIC'LOCKPWD')	     ,	$BITPOSITION(UAF$V_LOCKPWD),
	UPLIT (%ASCIC'CAPTIVE')	     ,	$BITPOSITION(UAF$V_CAPTIVE),
	UPLIT (%ASCIC'DISUSER')	     ,	$BITPOSITION(UAF$V_DISACNT),
	UPLIT (%ASCIC'DISNEWMAIL')   ,	$BITPOSITION(UAF$V_DISMAIL),
	UPLIT (%ASCIC'DISWELCOME')   ,	$BITPOSITION(UAF$V_DISWELCOM)
	),
!
! The definition table for flag bits for UAF$B_PDAYFLAGS and  UAF$B_SDAYFLAGS.
!

    OPFLAG_TABLE : VECTOR [2 * num_opflags + 1,LONG] INITIAL (
	2 * num_opflags,
	UPLIT (%ASCIC'DISDIALUP')  ,	$BITPOSITION(UAF$V_DISDIALUP),
	UPLIT (%ASCIC'DISNETWORK') ,	$BITPOSITION(UAF$V_DISNETWORK)
	),
!
! The definition table for flag bits for UAF$B_PRIMEDAYS.
!

    PDFLAG_TABLE : VECTOR [2 * num_pdflags + 1,LONG] INITIAL (
	2 * num_pdflags,
	UPLIT (%ASCIC'MONDAY')	 ,	$BITPOSITION(UAF$V_MONDAY),
	UPLIT (%ASCIC'TUESDAY')	 ,	$BITPOSITION(UAF$V_TUESDAY),
	UPLIT (%ASCIC'WEDNESDAY'),	$BITPOSITION(UAF$V_WEDNESDAY),
	UPLIT (%ASCIC'THURSDAY') ,	$BITPOSITION(UAF$V_THURSDAY),
	UPLIT (%ASCIC'FRIDAY')	 ,	$BITPOSITION(UAF$V_FRIDAY),
	UPLIT (%ASCIC'SATURDAY') ,	$BITPOSITION(UAF$V_SATURDAY),
	UPLIT (%ASCIC'SUNDAY')	 ,	$BITPOSITION(UAF$V_SUNDAY)
	);


BIND
!
! Message strings.
!

ACCPRMPT = CSTRING(%CHAR(LF),'UAF>'),
ACCPRMPT2 = CSTRING(%CHAR(LF),'_'),
NAFADDERR = CSTRING('unable to add record to NETUAF.DAT'),
RONLY = CSTRING('Read-only access'),
ADDERR = CSTRING('unable to add user record'),
NAFADDMSG = CSTRING('record successfully added to NETUAF.DAT'),
BADNODFORM = CSTRING('improper node::remoteuser format'),
NODTOOBIG = CSTRING('node name too long'),
NAFDNE = CSTRING('NETUAF.DAT does not exist'),
ADDMSG = CSTRING('user record successfully added'),
BADUSR = CSTRING('username does not exist \!AD\'),
BADSPC = CSTRING('no user matched specification'),
CONERR = CSTRING('connect error'),
COPMSG = CSTRING('user record copied'),
CREERR = CSTRING('unable to create SYSUAF.DAT'),
NODEFPWD = CSTRING('Warning: DEFAULT password change has no effect on ADDed records'),
DEFPWD = CSTRING('Warning: copied or renamed records must receive new password'),
DONEMSG = CSTRING('SYSUAF.DAT modified'),
GETERR = CSTRING('get error'),
INVCMD = CSTRING('invalid command'),
INVRSP = CSTRING('invalid response'),
INVUSERNAME = CSTRING('username syntax error'),
DEFERR = CSTRING('unable to obtain DEFAULT record'),
NETLSTMSG = CSTRING('listing file NETUAF.LIS complete'),
HELPERR  = CSTRING('error finding or outputting HELP information'),
LSTERR = CSTRING('error generating listing file'),
LSTMSG1 = CSTRING('writing listing file'),
LSTMSG2 = CSTRING('listing file SYSUAF.LIS complete'),
LSTPRVA = CSTRING('All'),
LSTPRVB = CSTRING('Files'),
LSTPRVC = CSTRING('System'),
LSTPRVD = CSTRING('Devour'),
LSTPRVE = CSTRING('Group'),
LSTPRVF = CSTRING('Normal'),
LSTPRVG = CSTRING('None'),
LSTSTR1 = CSTRING('       Owner         Username        UIC    Account  Privs',
	' Pri Default Directory!/'),
LSTSTR2 = CSTRING('!20AD !12AD [!3OW,!3OW] !8AF !6AC !2UL !AC!AC'),
MDFYERR = CSTRING('unable to update record'),
MDFYMSG = CSTRING('user record(s) updated'),
NAFAEX  = CSTRING('NETUAF.DAT already exists'),
NAFCONERR = CSTRING('connect error on NETUAF.DAT'),
NAFCREERR = CSTRING('unable to create NETUAF.DAT'),
NAMETOOBIG = CSTRING('username too long'),
NEWMSG10 = CSTRING('unable to open SYSUAF.DAT'),
NEWMSG15 = CSTRING('unable to open NETUAF.DAT'),
NEWMSG20 = CSTRING(%CHAR(LF),'Do you want to create a new file? '),
NOUSERNAME = CSTRING('missing username'),
NOMODS = CSTRING('no modifications made to SYSUAF.DAT'),
NOTUNQ = CSTRING('command is not unique'),
PRVSTR1 = CSTRING('Privileges: '),
PUTERR = CSTRING('put error'),
REMDEF = CSTRING('the DEFAULT record may not be removed'),
REMERR = CSTRING('unable to delete record'),
PREMMSG = CSTRING('record removed from NETUAF.DAT'),
REMMSG = CSTRING('record removed from SYSUAF.DAT'),
REMSYS = CSTRING('the SYSTEM record may not be removed'),
RENDEF = CSTRING('the DEFAULT record may not be renamed'),
RENMSG = CSTRING('user record renamed'),
RENSYS = CSTRING('the SYSTEM record may not be renamed'),
NAFHDR = CSTRING(' Node   Remote User     Local User!/'),
SHOWNAF = CSTRING('!6AD::!12AD    !12AD'),
SHOWERR = CSTRING('error during SHOW'),
SHOWMSG1 = CSTRING('!/Username:  !12AD Owner:  !AD'),
SHOWMSG2 = CSTRING('Account:   !8AF     UIC:    [!3OW,!3OW]'),
SHOWMSG3 = CSTRING('CLI:       !9AD    LGICMD: !AC'),
SHOWMSG35 = CSTRING('Default Device: !AC'),
SHOWMSG4 = CSTRING('Default Directory: !AC!/Login Flags:!7(AC)'),
SHOWMSG45 = CSTRING('Primary days:  !7(AC) !2(AC)!/Secondary days:!7(AC) !2(AC)'),
SHOWMSG46 = CSTRING('No hourly restrictions') ,
SHOWMSG47 = CSTRING(
'   00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23'),
SHOWMSG48 = CSTRING('P- !24(3AC)'),
SHOWMSG49 = CSTRING('S- !24(3AC)'),
SHOWMSG5 = CSTRING('PRIO:    !2UL  BYTLM:       !5UL  BIOLM:      !5UL'),
SHOWMSG6 = CSTRING('PRCLM:!5UL  PBYTLM: !10UL  DIOLM:      !5UL'),
SHOWMSG7 = CSTRING('ASTLM:!5UL  WSDEFAULT:   !5UL  FILLM:      !5UL'),
SHOWMSG8 = CSTRING('ENQLM:!5UL  WSQUOTA:     !5UL  SHRFILLM:   !5UL'),
SHOWMSG9 = CSTRING('TQELM:!5UL  WSEXTENT:    !5UL  CPU:!%D'),
SHOWMSG10 = CSTRING('TQELM:!5UL  WSEXTENT:    !5UL  CPU:     no limit'),
SHOWMSG11 = CSTRING('MAXJOBS:!3UL  MAXACCTJOBS:   !3UL  PGFLQUOTA:!7UL'),
SYSMSG1 = CSTRING('!AS'),
SYSMSG2 = CSTRING('ERROR CODE %X''!XL'''),
NAFUAEERR = CSTRING('entry already exists in NETUAF.DAT'),
UAEERR = CSTRING('invalid username, username already exists') ;

ROUTINE START =
BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Main procedure of AUTHORIZE.  Call SETUP to initialize
!	all needed files.  Prompt the user for the functions which
!	he/she wants, and call the proper function service routine.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--
OWN
  	status;

MAP
	CMDLINDSC: VECTOR;

BIND
	foreign_cmdlindsc = uplit(cmdbuflen, cmdbuf);

MODIFY_FLAG = FALSE ;					! note no modifications

!
! Set up terminal I/O
!

$OPEN(FAB = INFAB) ;
$CONNECT(RAB = INRAB) ;
$OPEN(FAB = OUTFAB) ;
$CONNECT(RAB = OUTRAB) ;

SETUP() ;

!
! Files have been initialized.  Prompt user for command line
! and perform requested function.
!

IF lib$get_foreign(foreign_cmdlindsc, 0 , cmdlindsc)  AND  .cmdlindsc [0] NEQ 0
THEN
    !
    ! If defined foreign, and there are commands on the line...
    !
    BEGIN
    cmdlindsc [1] = cmdbuf;

 	 IF (status = cli$dcl_parse ( cmdlindsc, authorize_commands))
	 THEN
	    BEGIN
	    cli$dispatch();
	    RETURN TRUE;
	    END
	ELSE
	    !
	    ! See if no CLINT exists ( Kludge City, USA  37916 )
	    !	
	    IF .status EQL cli$_noclint
            THEN
 	        SIGNAL_STOP(cli$_noclint)
	    ELSE
		ACC$EXIT()
    END;

IF .read_only
THEN
    FAOOUT ( RONLY );

WHILE TRUE
DO
    BEGIN

    !
    ! Input the command line, taking care of continuations.  Pull off
    ! the first token, assuming it is the command name, and look it up
    ! in the table of commands.
    !

    GET_CMD_LINE() ;

        IF (status = cli$dcl_parse ( cmdlindsc, authorize_commands))
        THEN
            cli$dispatch()

	ELSE
	    IF .status EQL cli$_noclint
	    THEN
		SIGNAL_STOP(cli$_noclint)
    END;

RETURN TRUE;

END;

ROUTINE SETUP: NOVALUE =
BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine does all of the initial file manipulation for the program.
!	It determines whether or not a previous SYSUAF.DAT exists.  If not, it
!	creates one (if the user wishes to proceed).
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--

LOCAL
	curpriv  :  VECTOR [2],
	procpriv :  VECTOR [2],
	item_priv:  BLOCK[16,BYTE],
	NEWFILE ;				! indicates new file must
						! be created.

item_priv [0,0,16,0] = 8;
item_priv [2,0,16,0] = jpi$_curpriv;
item_priv [4,0,32,0] = curpriv ;
item_priv [8,0,32,0] = 0;

$GETJPI( ITMLST = item_priv ); 		! Obtain current privs

item_priv [2,0,16,0] = jpi$_procpriv;
item_priv [4,0,16,0] = procpriv;
item_priv [8,0,32,0] = 0;

$GETJPI( ITMLST = item_priv ); 		! Obtain proc privs

!
! Now, remove ONLY the incremental image privs
!
curpriv [0] = NOT ( .curpriv [0]  AND  .procpriv [0] )  AND  .curpriv [0];
curpriv [1] = NOT ( .curpriv [1]  AND  .procpriv [1] )  AND  .curpriv [1];

$SETPRV( PRVADR = curpriv,		! Remove only the incremental
	 ENBFLG = 0          );		!   image privs

!************************************************************************
!
!                           Open SYSUAF.DAT
!
!************************************************************************

NEWFILE = FALSE ;				! note no new file yet
!
! Try to open sysuaf.dat without incremental image privs
!
IF RMSBAD( $OPEN ( FAB = UAFFAB ) )
THEN
    !
    ! sysuaf.dat doesn't exist
    !
    IF .RMSERR EQL RMS$_FNF
    THEN
	BEGIN
	FMT_SYS_MSG ( NEWMSG10, .RMSERR );
	WHILE TRUE
	DO
  	    !
	    ! Ask if a new one is desired
	    !
	    BEGIN
	    ASK ( NEWMSG20, CMDBUF[0] ,CMDBUFLEN);
	    IF .CMDBUF [0] EQL 'Y'
	    THEN EXITLOOP NEWFILE = TRUE;
	    IF .CMDBUF [0] EQL 'N'
	    THEN ACC$EXIT ();
	    FAOOUT ( INVRSP );
	    END;
	END
    ELSE
	!
	! Without incremental image privs, this user can't open
	!   sysuaf.dat -- grant read-only access, set privs back on,
	!   and re-attempt to open the file
	!
	IF .RMSERR EQL RMS$_PRV
	THEN
	    BEGIN
	    read_only = true;
	    $SETPRV ( PRVADR = curpriv,
		      ENBFLG = 1		);
	    IF RMSBAD ( $OPEN ( FAB = UAFFAB ) )
	    THEN
	   	BEGIN
		FMT_SYS_MSG( NEWMSG10, .RMSERR );
		ACC$EXIT ();
		END;
	    END
	ELSE
	    ACC$EXIT ()
ELSE
    !
    ! This user could open the file even without the incremental 
    !    image privs -- grant read/write access and reenable privs
    !
    BEGIN
    read_only = false;
    $SETPRV ( PRVADR = curpriv,
	      ENBFLG = 1		);
    END;


!
! The file will be created if it does not already exist.
! In any case connect the RAB.
!

IF .NEWFILE
THEN
    !
    ! A new file is requested
    !
    IF RMSBAD( $CREATE(FAB = UAFFAB) )
    THEN 
	!
	! Quit regardless of error on a $CREATE: don't
	!   want to give read-only user ability to create a file
	!
	FATAL( CREERR , .RMSERR ) 

    ELSE
	!
	! File created ok -- if we get here, the user had sufficient
	!    privs without incremental image privs, 'cause the $CREATE
	!    would have died on RMS$_PRV.  Set read-only flag false and
	!    reenable privs.
	!
	BEGIN
	$SETPRV ( PRVADR = curpriv,
		  ENBFLG = 1		);
	read_only = false;
	END;

IF RMSBAD( $CONNECT(RAB = UAFRAB) )
THEN FATAL( CONERR , .RMSERR) ;
UAFRAB[RAB$B_RAC] = RAB$C_KEY ;			! normal access is by key

!
! Check to see if there was no old file to use.  If so write a default and
! a system manager record.
!

IF .NEWFILE
THEN
    BEGIN
    MODIFY_FLAG = TRUE ;			! must rename when done
    BUILD_INI_RECS() ;				! build default and system manager records
    UAFRAB[RAB$W_RSZ] = UAF$C_FIXED ;

    DEFAULT_SIZE = UAF$C_FIXED ;
    UAFRAB[RAB$L_RBF] = DEFAULT_RECORD ;	! insert default record address
    IF RMSBAD( $PUT(RAB = UAFRAB) )
    THEN
	FATAL( PUTERR , .RMSERR ) ;		! report error
    UAFRAB[RAB$L_RBF] = RECBUF ;		! establish proper address (and
						! address of system record)
    IF RMSBAD( $PUT(RAB = UAFRAB) )		! output system record
    THEN
	FATAL( PUTERR , .RMSERR ) ;
    END
ELSE
    !
    ! Read in the default record.
    !
    BEGIN
    UAFRAB[RAB$L_UBF] = DEFAULT_RECORD ;
    IF NOT LOCATE_USER( .DEFUSER<0,8> , DEFUSER+1 , FALSE )
    THEN FATAL( DEFERR , .RMSERR ) ;
    DEFAULT_SIZE = .UAFRAB[RAB$W_RSZ] ;
    END;

UAFRAB[RAB$L_UBF] = RECBUF ;			! establish proper addresses
UAFRAB[RAB$L_RBF] = RECBUF ;

!************************************************************************
!
!                           Open NETUAF.DAT
!
!************************************************************************

netuaf_exists = true;			! Assume NETUAF.DAT exists...

!
! Try to open NETUAF.DAT and see what happens...
!
IF RMSBAD ( $OPEN ( FAB = NAFFAB ))
THEN
    !
    ! Couldn't open it
    !
    IF .RMSERR EQL RMS$_FNF
    THEN
	netuaf_exists = false			! it doesn't exist
    ELSE
	FMT_SYS_MSG ( NEWMSG15, .RMSERR)	! open error for some other reason

ELSE
    !
    ! NETUAF.DAT opened without error
    !
    IF RMSBAD ( $CONNECT ( RAB = NAFRAB ))
    THEN
	FAOOUT ( NAFCONERR ) 			! connect error
    !
    ! Everything opened and connected, establish proper NETUAF addresses
    !
    ELSE
	BEGIN
	NAFRAB [RAB$L_UBF] = NETBUF;
	NAFRAB [RAB$L_RBF] = NETBUF;
 	END;

END;

GLOBAL ROUTINE ADD_UAF: NOVALUE =
BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Routine to add new user to authorization file.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	A record is added to SYSUAF.DAT
!--

MAP
    TOKENPTR: REF  VECTOR[,BYTE];

IF .read_only 
THEN
    RETURN NOT (FAOOUT ( RONLY ));

!
! Make sure a username was specified.
!

IF NOT cli$present(sd_token1) OR
   NOT cli$get_value(sd_token1,tokendsc) OR
   .TOKENLEN EQL 0 
THEN
    RETURN FAOOUT( nousername );
!
! ADD must check that the username supplied is not too long.
!

IF .TOKENLEN GTR  UAF$S_USERNAME
THEN
    RETURN FAOOUT( NAMETOOBIG ) ;

!
! Make sure a legal username was entered, otherwise the account may not be
! accessible via LOGIN or the Input Symbiont.
!

INCRU I TO .TOKENLEN - 1
DO
    IF CH$FAIL( CH$FIND_CH( .SYMBOL_STR<0,8>, 
                            SYMBOL_STR + 1,
                            .TOKENPTR [.I]) )
    THEN
	RETURN FAOOUT( INVUSERNAME );

!
! Move the default record to the current record buffer, so that
! fields which are not entered will receive the default
! value.  Then insert the username just entered.
!

CH$MOVE( .DEFAULT_SIZE , DEFAULT_RECORD , RECBUF ) ;
CH$COPY( .TOKENLEN, .TOKENPTR , ' ' ,
			UAF$S_USERNAME , RECBUF[UAF$T_USERNAME] ) ;

!
! Call routine to fill in all supplied values.  Exit if any errors
! were found.
!

PWD_FLAG = TRUE ;				! plan to supply a password
UAFRAB[RAB$W_RSZ] = .DEFAULT_SIZE ;
add = true;
IF NOT UPDATE_RECORD() 
THEN
    BEGIN
    add = false;
    RETURN;
    END;

add = false;

IF .PWD_FLAG					! if no explicit password
THEN
    BEGIN
    PWDDSC[DSC$W_LENGTH] = .DEFPASS<0,8> ;	! build password descriptor
    PWDDSC[DSC$A_POINTER] = DEFPASS+1 ;
    $GETTIM(TIMADR = TIME_BUF) ;		! obtain a 16 bit salt
    RECBUF[UAF$W_SALT] = .TIME_BUF<3*8,16> ;
    RECBUF[UAF$B_ENCRYPT] = ENCRYPT ;
    LGI$HPWD( REC_ENCRYPT_DSC, PWDDSC, .RECBUF[UAF$B_ENCRYPT],
			    .RECBUF[UAF$W_SALT], REC_USER_DSC ) ;
    END;

!
! Now output the new record.
!

IF RMSBAD( $PUT(RAB = UAFRAB) ) 
THEN
    IF .RMSERR EQL RMS$_DUP
    THEN RETURN FAOOUT( UAEERR )		! This username already exists.
    ELSE FMT_SYS_MSG( ADDERR , .RMSERR )
ELSE
    BEGIN

    !
    ! Tell user that addition was successful.  Note that file was changed.
    !

    FAOOUT( ADDMSG ) ;
    MODIFY_FLAG = TRUE ;
    END;
END;

GLOBAL ROUTINE ADD_PROXY: NOVALUE =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine adds an entry to the NETUAF.DAT Proxy Login File
!
! INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	TOKENLEN, TOKENPTR
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	A record is added to NETUAF.DAT
!
!--
LOCAL
    node_len,
    node_ptr,
    remuser_len,
    remuser_ptr,
    locuser_len,
    locuser_ptr;

IF .read_only
THEN
    RETURN NOT (FAOOUT ( RONLY ));

!
! Can't do anything if there is no NETUAF.DAT...
!
IF NOT .netuaf_exists
THEN
    RETURN FAOOUT( NAFDNE );

!
! Clear NETUAF.DAT buffer
!
CH$FILL ( ' ', NAF$C_LENGTH, NETBUF );

!
! Retrieve token from command line
!
cli$get_value(sd_token1, tokendsc);

!
! Make sure entry is in proper node::remoteuser format
!
IF NOT REMOTE_PARSE ( node_ptr, node_len, remuser_ptr, remuser_len )
THEN
    RETURN;
!
! Fill in NETBUF with new remotename field
!
CH$COPY ( .node_len, .node_ptr, ' ', NAF$S_NODE, NETBUF[NAF$T_NODE] );
CH$COPY ( .remuser_len, .remuser_ptr, ' ', NAF$S_REMUSER,
                    NETBUF[NAF$T_REMUSER] );

!
! Now get second token, the local user name
!
cli$get_value(sd_token2, TOKENDSC);

locuser_len = .TOKENLEN;
locuser_ptr = .TOKENPTR;

!
! If local name is *, then use same name as remote user
!
IF .TOKENLEN EQL 1  AND  .(.TOKENPTR)<0,8> EQL '*'
THEN
    ( locuser_len = .remuser_len;
      CH$MOVE(NAF$S_REMUSER, NETBUF[NAF$T_REMUSER], NETBUF[NAF$T_LOCALUSER]);)
!
! Otherwise just copy into localuser field in NETBUF
!
ELSE
    CH$COPY ( .locuser_len, .locuser_ptr, ' ', NAF$S_LOCALUSER,
                    NETBUF[NAF$T_LOCALUSER] );

!
! Make sure that the local user does indeed exist in SYSUAF.DAT
!	(unless local user is *)
!
IF NOT LOCATE_USER ( .locuser_len, NETBUF[NAF$T_LOCALUSER], 0)
   AND NOT (.locuser_len EQL 1 AND .(NETBUF[NAF$T_LOCALUSER])<0,8> EQL '*')
THEN
    RETURN FAOOUT( BADUSR, .locuser_len, NETBUF[NAF$T_LOCALUSER]);

NAFRAB[RAB$W_RSZ] = NAF$C_LENGTH;

!
! Add NETUAF.DAT record
!
IF RMSBAD ( $PUT ( RAB = NAFRAB ))
THEN
    IF .RMSERR EQL RMS$_DUP
    THEN
	RETURN FAOOUT ( NAFUAEERR )
    ELSE
   	FMT_SYS_MSG ( NAFADDERR, .RMSERR )
ELSE
    FAOOUT ( NAFADDMSG );

END;

ROUTINE REMOTE_PARSE ( node_ptr, node_len, remuser_ptr, remuser_len) =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!	
!	This routine parses a remote user specification in the form
!	   node::remuser, and returns the two components by lengths
!	   and pointers to the strings
!
! INPUTS:
!	
!	node_ptr - returned as pointer to nodename
!	node_len -    "     " length of nodename
!	remuser_ptr - returned as pointer to remote user name
!	remuser_len -     "    "    length of remote user name
!
! IMPLICIT INPUTS:
!
!	TOKENLEN and TOKENPTR -- the remote user specification is assumed
!	   to have just been fetched from the command line
!
! OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	TRUE if parsed successfully
!	FALSE if error encountered in parsing
!
!--
MAP
    dbl_colon: VECTOR;

LOCAL
    dbl_colon_ptr;

!
! Better be able to find a double colon in the remotename...
!
dbl_colon_ptr = CH$FIND_SUB (.TOKENLEN, .TOKENPTR, 2, .dbl_colon [1]);

IF .dbl_colon_ptr EQL 0  OR				! no double colon found
   .dbl_colon_ptr EQL .TOKENPTR  OR			! no node found
   .dbl_colon_ptr EQL (.TOKENPTR + .TOKENLEN - 2)	! no remote user found
THEN
    RETURN FAOOUT ( BADNODFORM );

!
! Determine node length and pointer
!
.node_len = .dbl_colon_ptr - .TOKENPTR;
.node_ptr = .TOKENPTR;

!
! Make sure node name isn't too long
!
IF .(.node_len) GTR NAF$S_NODE
THEN
    RETURN FAOOUT ( NODTOOBIG );

!
! Determine remote username length and pointer
!
.remuser_len = .TOKENLEN - .(.node_len) - 2;
.remuser_ptr = .dbl_colon_ptr + 2;

!
! And make sure name isn't too long
!
IF .(.remuser_len) GTR NAF$S_REMUSER
THEN
    RETURN FAOOUT( NAMETOOBIG );

RETURN TRUE;
END;

GLOBAL ROUTINE COPY_UAF  =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Routine to copy a user authorization record, giving the
!           new authorization record a different name.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	 false if the copy fails;
!        true  if the copy succeeds.
!
! SIDE EFFECTS:
!
!	A user record is added.
!
!
!--

LOCAL
    status,
    flag,
    LOCK_REC,
    DEF_SYS ;

MAP
    TOKENPTR	: REF VECTOR [,BYTE];

IF .read_only
THEN
    RETURN NOT (FAOOUT ( RONLY ));

copy = NOT .rename;
!
! If this is a COPY directly from the UAF> prompt, the authorization
! record need not be locked, and the default and system records may be
! copied.  HOWEVER, if this COPY is part of a RENAME operation, the record
! must be locked, and the default and system records may not be renamed.
! (The RENAME operation is similar to the COPY operation except that
!  the original record is REMOVE'd.  COPY leaves both records.)
!
IF NOT .rename
THEN
    BEGIN
    LOCK_REC = FALSE ;		! A COPY operation
    DEF_SYS  = TRUE  ;
    flag = false;
    END
ELSE
    BEGIN
    LOCK_REC = TRUE ;  		! A RENAME operation
    DEF_SYS  = FALSE;
    flag = true;
    END;

!
!  Place record to be copied into RECBUF
!  ( If the third argument is true, the call to GET_USER_RECORD
!       is part of a RENAME operation, and the first token should be saved.
!       If the third argument is false, the call is part of a COPY
!       operation, and the first token need not be saved.) 
!

IF GET_USER_RECORD( .LOCK_REC , .DEF_SYS , .flag )
THEN                                ! Make sure a username was
    BEGIN                           !    specified
    IF NOT cli$present ( sd_token2 ) OR
       NOT cli$get_value (sd_token2, TOKENDSC) OR
           .TOKENLEN EQL 0
    THEN
        RETURN FAOOUT( NOUSERNAME );

    !
    !  Make sure that the new username isn't too long
    !
    IF .TOKENLEN  GTR UAF$S_USERNAME
    THEN
	RETURN FAOOUT( NAMETOOBIG );

    !
    ! Make sure that the new username is legal
    !
    INCRU I TO .TOKENLEN - 1
    DO
	IF CH$FAIL( CH$FIND_CH( .SYMBOL_STR<0,8>,
                                 SYMBOL_STR + 1,
                                .TOKENPTR [.I] ) )
	THEN
	    RETURN FAOOUT( INVUSERNAME );

    !
    ! Place the new username in RECBUF
    !
    CH$COPY( .TOKENLEN, .TOKENPTR, ' ', UAF$S_USERNAME,
			RECBUF[UAF$T_USERNAME] );
    
    PWD_FLAG = true;

    status = UPDATE_RECORD();

    IF NOT .status
    THEN 
	RETURN false;

    !
    ! Now output the new record
    !
    IF RMSBAD( $PUT( RAB = UAFRAB ) )
    THEN
	IF .RMSERR EQL RMS$_DUP
	THEN
	    RETURN FAOOUT( UAEERR )		! username already exists

	ELSE
	    BEGIN
	    FMT_SYS_MSG( ADDERR, .RMSERR );
            RETURN FALSE;
      	    END
    ELSE
	!
	! The copy was successful -- tell the user and set modify flag
	!
	BEGIN
	IF NOT .rename
	THEN
	    BEGIN
	    FAOOUT( COPMSG );
	    !
	    ! Since passwords are folded in with the username, passwords for 
	    !	COPYed records will no longer work--warn the user
	    !
	    IF .PWD_FLAG
	    THEN
	    	FAOOUT ( DEFPWD );
	    copy = false;
	    END;
	MODIFY_FLAG = TRUE;
    	END;

    END

!
! The attempt to GET_USER_RECORD failed...
!
ELSE RETURN FALSE;

!
! If we get here, everything succeeded -- return true
!
RETURN TRUE;

END;

GLOBAL ROUTINE CREATE_PROXY: NOVALUE =
BEGIN
!++
!
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine will create a DECnet Proxy Login File,
!	called NETUAF.DAT, in order to map remote users into
!	local accounts.  
!
! INPUTS:
!
!    none
!
! OUTPUTS:
!
!    none
!
! IMPLICIT INPUTS:
!
! 	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! SIDE EFFECTS:
!
!	NETUAF.DAT is created and initialized 	
!
!--

IF .read_only
THEN
    RETURN NOT (FAOOUT ( RONLY ));

!
! NETUAF.DAT should not already exist
!
IF .netuaf_exists
THEN
    BEGIN
    FAOOUT ( NAFAEX );
    RETURN ;
    END;

!
! Should be able to create NETUAF.DAT with no problems
!
IF RMSBAD ( $CREATE ( FAB = NAFFAB ) )
THEN
    FATAL ( NAFCREERR, .RMSERR );

!
! Should connect ok, too
!
IF RMSBAD ($CONNECT ( RAB = NAFRAB ))
THEN
    FATAL ( NAFCONERR, .RMSERR );

!
! Normal access is by key
!
NAFRAB [RAB$B_RAC] = RAB$C_KEY;

!
! Establish proper addresses
!
NAFRAB [RAB$L_UBF] = NETBUF;
NAFRAB [RAB$L_RBF] = NETBUF;

!
! Set NETUAF.DAT existence flag
!
netuaf_exists = true;

END;

!GLOBAL ROUTINE MODIFY_UAF_ACCT: NOVALUE =
!BEGIN
!
!!++
!!
!! FUNCTIONAL DESCRIPTION:
!!
!!	This routine simply sets the by_account flag to indicate 
!!	that UAF record modification is to be done by account rather
!!	than by username.
!!
!!--
!
!by_account = true;
!
!MODIFY_UAF();
!
!by_account = false;
!
!END;

GLOBAL ROUTINE MODIFY_UAF: NOVALUE =
BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Routine to modify any of the fields in one or more user records.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!--
LOCAL
    status;

IF .read_only
THEN
    RETURN NOT (FAOOUT ( RONLY ));

!
! Obtain the user specification.  This sets wildcard flags and initializes
! the appropriate key in RECBUF.
!

IF NOT PARSE_WILD( FALSE )		! Null string is disallowed
THEN
    RETURN ;

UAFRAB[RAB$V_NLK] = 0 ;			! Specify record locking
					! reset in MODIFY_REC
RABPTR = OUTRAB ;
found_match = false;

IF RMSBAD( status = WILD_USER ( MODIFY_REC ))	! Modify each record
THEN
    IF .RMSERR EQL RMS$_RNF
    THEN
	FAOOUT( BADSPC )
    ELSE
	(IF .RMSERR NEQ 0
	 THEN
	     FMT_SYS_MSG( MDFYERR , .RMSERR ))

ELSE
    IF .status AND .found_match
    THEN
	FAOOUT ( MDFYMSG ); 
END;

ROUTINE MODIFY_REC = 
BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Modify an individual user record.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	RABPTR - RMS data structure for the file
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!
! ROUTINE VALUE:
!
!	If an error is encountered the appropriate status is returned
!	except if the error message has already been output in which
!	case 0 is returned.
!--

!
! User record has been read into RECBUF by caller.  Update values
! and modify the record.
!
! When accessing records by uic, this routine is called repeatedly
!    from WILD_USER. UPDATE_RECORD is called to modify the appropriate
!    record fields for each requested record, and therefore must 
!    reparse the command line each time.  If call_count is greater
!    than 0, the command line is reparsed.
!

!IF .by_account
!THEN
!    (IF NOT fmg$match_name( NAMELEN, RECBUF[UAF$T_ACCOUNT],
!				    .match_tokenlen, match_token )
!     THEN
!	RETURN TRUE)
!ELSE
   IF .STR_WILD AND NOT fmg$match_name( NAMELEN, RECBUF[UAF$T_USERNAME],
                                        .match_tokenlen,  match_token )
    THEN
        RETURN TRUE;
found_match = true;

IF CH$EQL( .DEFUSER<0,8> , DEFUSER+1, .TOKENLEN, .TOKENPTR, ' ')  OR
   CH$EQL( .DEFUSER<0,8> , DEFUSER+1, NAMELEN, RECBUF[UAF$T_USERNAME], ' ')
THEN
    BEGIN
    mod_default = true;
    DEFAULT_UAF();
    call_count = .call_count + 1;
    RETURN TRUE;
    END;


IF UPDATE_RECORD()
THEN
    IF RMSBAD( $UPDATE(RAB = UAFRAB) )
    THEN
	BEGIN
	FMT_SYS_MSG( MDFYERR , .RMSERR ) ;
	RETURN .RMSERR
	END
    ELSE
	BEGIN
	MODIFY_FLAG = TRUE ;		! mark file as modified
	call_count = .call_count + 1;
	RETURN TRUE
	END
ELSE
    BEGIN
    $RELEASE(RAB = UAFRAB) ;		! unlock the record
    RETURN FALSE
    END
END;

GLOBAL ROUTINE REMOVE_UAF: NOVALUE =
BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Routine to delete a user record from the UAF file.
!
! INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	rename: a logical flag which indicates whether this COPY is part
!		of a RENAME operation
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!  This routine also deletes any NETUAF entries for the
!	local user which is to be removed( If NETUAF.DAT exists)
!
!--

IF .read_only
THEN
    RETURN NOT (FAOOUT ( RONLY ));

!
! Look for the record specified by the user.  Make sure
! the DEFAULT and SYSTEM records are not removed.
!

IF GET_USER_RECORD( TRUE , FALSE )
THEN
    !
    ! User record has been found and read into RECBUF
    ! Zero the username field and update the record in the file
    !

    IF RMSBAD( $DELETE( RAB=UAFRAB ) )
    THEN
	FMT_SYS_MSG( REMERR , .RMSERR ) 
    ELSE
	BEGIN
	MODIFY_FLAG = TRUE ;			! mark file as modified
	IF NOT .rename
	THEN
	    BEGIN
	    !
	    ! If there is a proxy login file, delete entries for
	    !     the user just removed from SYSUAF.DAT
	    !
	    IF .netuaf_exists
            THEN
	        ADJUST_PROXY ( remove_records );

	    FAOOUT( REMMSG );
	    END;
	END;
END;

GLOBAL ROUTINE REMOVE_PROXY: NOVALUE =
BEGIN
!++
!
!
! FUNCTIONAL CHARACTERISTICS:
!
!	This routine removes proxy login entries from NETUAF.DAT
!
! INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
! 	none
!
! SIDE EFFECTS:
!
!	An entry is removed from NETUAF.DAT
!
!--
LOCAL
    node_len,
    node_ptr,
    remuser_len,
    remuser_ptr,
    COUNTER,
    SUCCESS;

IF .read_only
THEN
    RETURN NOT (FAOOUT ( RONLY ));

!
! Make sure NETUAF.DAT exists
!
IF NOT .netuaf_exists
THEN
    RETURN FAOOUT ( NAFDNE );

!
! Retrieve remote name in node::remotename form
!
cli$get_value(sd_token1, tokendsc);

!
! Verify proper format
!
IF NOT REMOTE_PARSE( node_ptr, node_len, remuser_ptr, remuser_len )
THEN
    RETURN;

!
! Copy into appropriate fields
!
CH$COPY(.node_len, .node_ptr, ' ', NAF$S_NODE, NETBUF[NAF$T_NODE]);
CH$COPY(.remuser_len, .remuser_ptr, ' ', NAF$S_REMUSER, NETBUF[NAF$T_REMUSER]);

NAFRAB[RAB$V_NLK] = false;

SUCCESS = GET_PROXY_RECORD();

!
! Delete the record
!
IF .SUCCESS
THEN
    IF RMSBAD( $DELETE ( RAB = NAFRAB ))
    THEN
	FMT_SYS_MSG ( REMERR, .RMSERR )
    ELSE
    	FAOOUT ( PREMMSG )
ELSE
    FAOOUT ( REMERR );

END;

GLOBAL ROUTINE RENAME_UAF: NOVALUE =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!  	Effect a user authorization record rename, by 
!	performing a COPY and a REMOVE operation.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! SIDE EFFECTS:
!
!	A user authorization record is copied with a newname; the
!	original record is then deleted.
!       This routine also causes updating of any NETUAF entries for the
!	local user which is to be renamed.
!
!--

IF .read_only
THEN
    RETURN NOT (FAOOUT ( RONLY ));

rename = true;
!
! Copy the new authorization record
!
IF  ( COPY_UAF( ) )
THEN
    BEGIN
    !
    ! Remove the old authorization record
    !
    REMOVE_UAF( );
    FAOOUT( RENMSG );
    !
    ! Because passwords are folded in with the username, passwords for
    !	RENAMEd records will no longer work--warn the user
    !
    IF .PWD_FLAG
    THEN
  	FAOOUT ( DEFPWD );
    END;
!
! Reset flags
!
rename_ph2 = false;
rename = false;

END;

GLOBAL ROUTINE ADJUST_PROXY ( remove ) : NOVALUE =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine performs the operations implicitly indicated by
!	REMOVE or RENAME operations on SYSUAF.DAT.  If a SYSUAF.DAT 
!	record is removed, then any corresponding NETUAF.DAT entries must
!	also be deleted.  If a SYSUAF.DAT record is renamed, then any
!	corresponding NETUAF.DAT entries must be updated.
!
! INPUTS:
!
!	remove - a flag which indicates that the NETUAF.DAT record
!		 should be removed.  If false, then the record 
!		 should be updated.
!
! OUTPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	savedlen - the old username length for a RENAME
!	savedtoken - the old username string for a RENAME
!	TOKENPTR - the new username for RENAME, the removed username for REMOVE
!	TOKENLEN - "    "    "  length " "    ,  "    "      "  length "   "
!
! IMPLICIT OUTPUTS:
!
!	none
!
! SIDE EFFECTS:
!
!	 A  record is removed/updated in NETUAF.DAT
!
!--
LOCAL
    STATUS;

!
! Set access to sequential because we need to check for 
!	multiple entries
!
NAFRAB[RAB$B_RAC] = RAB$C_SEQ;
$REWIND ( RAB = NAFRAB );
!
! Until EOF...
!
WHILE STATUS = GET_PROXY_RECORD ()
DO
    BEGIN
    LOCAL
        locuser_len,
        blank_ptr;    

    !
    ! Find end of user name...
    !
    !
    ! If not found in 12 characters, it must be the full 12 
    !	characters in length
    !
    IF CH$FAIL( blank_ptr = CH$FIND_CH( NAF$S_LOCALUSER,
			NETBUF[NAF$T_LOCALUSER], ' '))
    THEN 
        locuser_len = NAF$S_LOCALUSER
    ELSE
   	locuser_len = .blank_ptr - NETBUF[NAF$T_LOCALUSER];

    !
    ! If this is a record to be removed, delete it
    !
    IF .remove
    THEN
        (IF .TOKENLEN EQL .locuser_len
            AND  CH$EQL(.TOKENLEN,.TOKENPTR, .locuser_len,
                                         NETBUF[NAF$T_LOCALUSER])
        THEN
            $DELETE ( RAB = NAFRAB ))
   !
   ! otherwise, change the localusername field to reflect the
   !	new username in SYSUAF.DAT
   !
    ELSE
        IF .savedlen EQL .locuser_len
		AND  CH$EQL(.savedlen, savedtoken, .locuser_len,
				NETBUF[NAF$T_LOCALUSER])
        THEN
            BEGIN
            CH$COPY ( .TOKENLEN, .TOKENPTR, ' ', NAF$S_LOCALUSER,
			NETBUF[NAF$T_LOCALUSER] );
            $UPDATE ( RAB = NAFRAB );
            END; 
    END;
!
! Return to keyed access
!
NAFRAB[RAB$B_RAC] = RAB$C_KEY;
END;

GLOBAL ROUTINE DEFAULT_UAF: NOVALUE =
BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Change a default value in the default record.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--


IF .read_only
THEN
    RETURN NOT (FAOOUT ( RONLY ));

!
! Locate default record and load it into RECBUF
!    if not already there (via an indirect MODIFY DEFAULT)
!

IF NOT .mod_default  
THEN
    IF NOT LOCATE_USER( .DEFUSER<0,8> , DEFUSER+1 , TRUE )
    THEN
	BEGIN
	FMT_SYS_MSG( DEFERR , .RMSERR ) ;
	RETURN ;
	END ;
!
! The encrypted password field of the DEFAULT record can not be propagated
! to another user, because the encryption algorithm takes the user name as
! an input.  The user is merely warned that this qualifier has no effect.
!

PWD_FLAG = TRUE ;

!
! Update values supplied and exit if errors.
!

IF UPDATE_RECORD()
THEN
    BEGIN
    IF NOT .PWD_FLAG
    THEN
	FAOOUT( NODEFPWD ) ;		! password change has no effect

    !
    ! Now write the modified record back into the DEFAULT_RECORD buffer.
    !

    DEFAULT_SIZE = .UAFRAB[RAB$W_RSZ] ;
    CH$MOVE( .DEFAULT_SIZE , RECBUF , DEFAULT_RECORD  ) ;

    !
    ! Update the default record in the file.  Note that file has changed.
    !

    IF NOT RMSOK( $UPDATE(RAB = UAFRAB) )
    THEN
        FMT_SYS_MSG( MDFYERR , .RMSERR )
    ELSE
	BEGIN
	MODIFY_FLAG = TRUE ;
	IF NOT .mod_default
	THEN
	    FAOOUT( MDFYMSG ) 
        ELSE
            mod_default = false;
	END;
    END

ELSE
    $RELEASE(RAB = UAFRAB);			! unlock the record

END;

GLOBAL ROUTINE LIST_PROXY: NOVALUE =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine produces a listing of the entire NETUAF.DAT file
!	in NETUAF.LIS.
!
! INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! SIDE EFFECTS:
!
!	A listing file is produced
!
!--
LOCAL
   ACTION;

!
! Make sure NETUAF.DAT exists
!
IF NOT .netuaf_exists
THEN
    RETURN FAOOUT ( NAFDNE );

!
! Set up the listing file FAB and connect RAB
!
NLSTFAB[FAB$V_DLT] = FALSE;
IF RMSBAD ( $CREATE ( FAB = NLSTFAB ))
THEN
   RETURN FMT_SYS_MSG ( LSTERR, .RMSERR );

IF RMSBAD ( $CONNECT ( RAB = NLSTRAB ))
THEN
    RETURN FMT_SYS_MSG ( LSTERR, .RMSERR);

!
! Set action routine and rab pointer
!
wild_netuser = true;
RABPTR = NLSTRAB;
ACTION = DISPLAY_PROXY;
HEADER_FLAG = true;

FAOOUT ( LSTMSG1 );

!
! LOCATE_PROXY will call the action routine for each proxy record
!
IF RMSBAD ( LOCATE_PROXY ( .ACTION ))
THEN
    IF .RMSERR EQL RMS$_RNF
    THEN
 	FAOOUT ( BADSPC )
    ELSE
	FMT_SYS_MSG ( LSTERR, .RMSERR )
ELSE
    FAOOUT ( NETLSTMSG );

!
! Disconnect RAB and close FAB
!
$DISCONNECT ( RAB = NLSTRAB );
$CLOSE ( FAB = NLSTFAB );

END;

GLOBAL ROUTINE LIST_UAF: NOVALUE =
BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Display the specified users in a file named 'SYSUAF.LIS'.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--

LOCAL
    ACTION ;

!
! Obtain the user specification.  This sets wildcard flags and initializes
! the appropriate key in RECBUF.
!

IF NOT PARSE_WILD( TRUE )		! Null string defaults to *
THEN
    RETURN ;

!
! Obtain qualifiers.  This determines which display should be used.
!
full_flag = false;
brief_flag = true;

IF cli$present(sd_full) OR (NOT cli$present(sd_brief))
THEN
    BEGIN
    brief_flag = false;
    full_flag  = true;
    END;

!
! Create the listing file.
!

LSTFAB[FAB$V_DLT] = FALSE ;		! initialize DLT bit
IF RMSBAD( $CREATE(FAB = LSTFAB) )
THEN RETURN FMT_SYS_MSG( LSTERR , .RMSERR ) ;

IF RMSBAD( $CONNECT(RAB = LSTRAB) )
THEN RETURN FMT_SYS_MSG( LSTERR , .RMSERR ) ;

!
! Request a header record for the file and aim RABPTR at our RAB.
!

HEADER_FLAG = TRUE ;
RABPTR = LSTRAB ;
found_match = false;

!
! Choose the appropriate display.
!

ACTION = DISPLAY_BRIEF ;
IF .FULL_FLAG
THEN
    ACTION = DISPLAY_FULL ;

FAOOUT( LSTMSG1 ) ;			! announce starting

IF RMSBAD( WILD_USER( .ACTION ) )
THEN
    BEGIN
    IF .RMSERR EQL RMS$_RNF
    THEN
	FAOOUT( BADSPC )
    ELSE
	FMT_SYS_MSG( LSTERR , .RMSERR ) ;
    LSTFAB[FAB$V_DLT] = TRUE ;		! press delete button
    END
ELSE
    FAOOUT( LSTMSG2 ) ;

$DISCONNECT(RAB = LSTRAB) ;
$CLOSE(FAB = LSTFAB) ;
END;

GLOBAL ROUTINE SHOW_USER_UAF: NOVALUE =
BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Display the specified users on SYS$OUTPUT.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--

LOCAL
    ACTION ;

!
! Obtain the user specification.  This sets wildcard flags and initializes
! the appropriate key in RECBUF.
!

IF NOT PARSE_WILD( FALSE )		! Null string is disallowed.
THEN
    RETURN ;

!
! Obtain qualifiers.  This determines which display should be used.
!
full_flag = true;
brief_flag = false;

IF cli$present(sd_brief) OR (NOT cli$present(sd_full))
THEN
    BEGIN
    brief_flag = true;
    full_flag  = false;
    END;

!
! Request a header record for the file and aim RABPTR at our RAB.
!

HEADER_FLAG = TRUE ;
RABPTR = OUTRAB ;
found_match = false;

!
! Choose the appropriate display.
!

ACTION = DISPLAY_FULL ;
IF .BRIEF_FLAG
THEN
    ACTION = DISPLAY_BRIEF ;

IF RMSBAD( WILD_USER( .ACTION ) )
THEN
    IF .RMSERR EQL RMS$_RNF
    THEN
	FAOOUT( BADSPC )
    ELSE
	FMT_SYS_MSG( SHOWERR , .RMSERR ) ;
END;

GLOBAL ROUTINE SHOW_PROXY: NOVALUE =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine will display a specific proxy record or
!	will display all proxy entries to the user terminal.
!
! INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	TOKENLEN, TOKENPTR
!
! IMPLICIT OUTPUTS:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!
!--
LOCAL
    node_len,
    node_ptr,
    remuser_len,
    remuser_ptr,
    ACTION,
    COUNTER,
    SUCCESS;

!
! Make sure that NETUAF.DAT exists
!
IF NOT .netuaf_exists
THEN
    RETURN FAOOUT ( NAFDNE );

!
! Retrieve token
!
cli$get_value(sd_token1, tokendsc);

HEADER_FLAG = true;

!
! Wild token for all entries?
!
IF .TOKENLEN EQL 1  AND  .(.TOKENPTR)<0,8> EQL '*'
THEN
    wild_netuser = true

!
! Otherwise, just display a single entry
!
ELSE
    BEGIN
    wild_netuser = false;
    IF NOT REMOTE_PARSE( node_ptr, node_len, remuser_ptr, remuser_len )
    THEN
        RETURN;

    CH$COPY(.node_len, .node_ptr, ' ', NAF$S_NODE, NETBUF[NAF$T_NODE]);
    CH$COPY(.remuser_len, .remuser_ptr, ' ', NAF$S_REMUSER,
             NETBUF[NAF$T_REMUSER]);
    END;

!
! Set up action routine and rab pointer
!
RABPTR = OUTRAB;
ACTION = DISPLAY_PROXY;

!
! Make call(s) necessary to display the rquested entry or entries
!
IF RMSBAD ( LOCATE_PROXY ( .ACTION ))
THEN
    IF .RMSERR EQL RMS$_RNF
    THEN
	FAOOUT( BADSPC )
    ELSE
	FMT_SYS_MSG( SHOWERR, .RMSERR );

END;

ROUTINE LOCATE_PROXY ( ACTION ) =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
! 	This routine will call a requested action routine a number of times.
!
! INPUTS:
!
!	ACTION - the action routine to call for each NEUAF record
!
! OUTPUTS:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!
!--
LOCAL
    STATUS;

!
! If wild user, set acces to sequential and fetch all records
!
IF .wild_netuser
THEN
    BEGIN
    NAFRAB[RAB$B_RAC] = RAB$C_SEQ;
    $REWIND (RAB = NAFRAB);
    END;

STATUS = GET_PROXY_RECORD();

!
! Fetch record and call action routine until EOF
!
IF .STATUS
THEN
    IF STATUS = (.ACTION)()
    THEN
	IF .wild_netuser
	THEN
	    BEGIN
	    WHILE STATUS = GET_PROXY_RECORD()
	    DO
	        IF NOT (STATUS = (.ACTION)())
		THEN
		    EXITLOOP;
	    IF .STATUS EQL RMS$_EOF
	    THEN
		STATUS = TRUE;
	    END;

!
! Restore keyed access
!
NAFRAB[RAB$B_RAC] = RAB$C_KEY;

.STATUS
END;

ROUTINE GET_PROXY_RECORD =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine accesses a specific NETUAF.DAT record
!
! INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! SIDE EFFECTS:
!
! 	none
!
!--
LOCAL
    COUNTER,
    SUCCESS;

COUNTER = RETRY_RLK;

WHILE ((SUCCESS = $GET(RAB = NAFRAB)) EQL RMS$_RLK)
	AND  ((COUNTER = .COUNTER - 1) GEQ 0)
DO
   IF $SCHDWK ( DAYTIM = WAKEDELTA) THEN $HIBER;

.SUCCESS
END;

ROUTINE DISPLAY_PROXY: NOVALUE =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine formats and outputs a line of a NETUAF.DAT entry
!
! INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!
!--

IF .HEADER_FLAG
THEN
    BEGIN
    FAOMAC ( NAFHDR )
    HEADER_FLAG = false;
    END;

FAOMAC ( SHOWNAF,
    NAF$S_NODE,      NETBUF[NAF$T_NODE],
    NAF$S_REMUSER,   NETBUF[NAF$T_REMUSER],
    NAF$S_LOCALUSER, NETBUF[NAF$T_LOCALUSER] )

END;

ROUTINE WILD_USER( ACTION ) =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Provide a general means of accessing the User Authorization File
!	records.  There are six methods:
!
!			UGMS
!			IRET
!			CPMR
!			\\\\
!			FWWW
!			LIII
!			ALLL
!	Syntax		GDDD	Interpretation
!	------			--------------
!	Username	FFFF	Exactly one user is to be located
!	*		FFFT	All users (alphabetically)
!	[Group,Member]	TFFF	All users with the specified UIC
!	[Group,*]	TFTF	All users in the specified group (by member)
!	[*,Member]	TTFF	A FIFO listing of the groups with this member
!	[*,*]		TTTF	All users by UIC
!
! INPUTS:
!
!	ACTION - Pointer to routine to call after each successful GET
!
! IMPLICIT INPUTS:
!
!	UIC_FLAG - UIC form (instead of username)
!	GRP_WILD - Group wild card (must imply UIC_FLAG)
!	MEM_WILD - Member wild card (must imply UIC_FLAG)
!	STR_WILD - all users alphabetically (must imply NOT UIC_FLAG)
!	UAFRAB - RMS data structure for SYSUAF.DAT
!	RECBUF - The current record
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	If an abnormal condition is encountered the appropriate status
!	is returned.
!
! SIDE EFFECTS:
!
!	none
!--
MACRO
    LMT_L_UIC = 0,0,32,0%,		! User ID Code
    LMT_W_MEM = 0,0,16,0%,		! Member subfield
    LMT_W_GRP = 2,0,16,0%;		! Group subfield
LOCAL
    STATUS,				! This routine's status
    LMTKEY: BLOCK[4,BYTE] ;		! Limiting key value for sequential loop
LABEL
    SEQUENTIAL ;

IF .UIC_FLAG
THEN
    !
    ! Change the key of reference and the key buffer if a UIC form was
    ! specified.
    !
    IF .GRP_WILD AND NOT .MEM_WILD
    THEN
	BEGIN
	!
	! The UIC requested was of the form [*,Member]
	!
	UAFRAB[RAB$B_KRF] = 2 ;
	UAFRAB[RAB$L_KBF] = RECBUF[UAF$W_MEM] ;
	UAFRAB[RAB$B_KSZ] = 2 ;
	END
    ELSE
	BEGIN
	UAFRAB[RAB$B_KRF] = 1 ;
	UAFRAB[RAB$L_KBF] = RECBUF[UAF$L_UIC] ;
	UAFRAB[RAB$B_KSZ] = 4 ;
	END ;

IF .MEM_WILD AND NOT .GRP_WILD
THEN
    !
    ! The UIC requested was of the form [Group,*]
    !
    UAFRAB[RAB$V_KGE] = TRUE ;

!
! LMTKEY need be loaded only IF .UIC_FLAG AND NOT (.GRP_WILD AND .MEM_WILD)
! but it is simpler to always load it.
!

LMTKEY[LMT_L_UIC] = .RECBUF[UAF$L_UIC] ;

!
! Locate the first user meeting the specification.
!

IF .STR_WILD OR (.GRP_WILD AND .MEM_WILD)
THEN
    BEGIN
    !
    ! Every user in the file is to be accessed.
    !
    UAFRAB[RAB$B_RAC] = RAB$C_SEQ ;
    $REWIND(RAB = UAFRAB) ;
    STATUS = GET_UAF_RECORD() ;
    END
ELSE
    BEGIN
    STATUS = GET_UAF_RECORD() ;
    IF .UIC_FLAG
    THEN
	BEGIN
	!
	! Even an explicit UIC requires sequential reads to locate duplicates.
	!
	UAFRAB[RAB$B_RAC] = RAB$C_SEQ ;
	IF .MEM_WILD AND NOT .GRP_WILD
	THEN
	    BEGIN
	    !
	    ! RAB$V_KGE is set on the initial access for specifications of the
	    ! form [Group,*] so if the specified group has no members the record
	    ! will be that of a user in another group.
	    !
	    UAFRAB[RAB$V_KGE] = FALSE ;
	    IF .LMTKEY[LMT_W_GRP] NEQU .RECBUF[UAF$W_GRP]
	    THEN
		STATUS = RMS$_RNF ;
	    END ;
	END ;
    END ;

IF .STATUS
THEN
    !
    ! Feed the action routine the first record.  In the case of an explicit
    ! username specification this will be the only record.
    !
    IF STATUS = (.ACTION)()
    THEN
	IF .STR_WILD OR .UIC_FLAG
	THEN
SEQUENTIAL:
	    BEGIN
	    WHILE STATUS = GET_UAF_RECORD()
	    DO
		BEGIN
		IF .UIC_FLAG
		THEN
		    BEGIN
		    !
		    ! The limiting key value is used in different ways depending
		    ! on the form of the UIC specification.
		    !
		    IF .GRP_WILD AND NOT .MEM_WILD
		    THEN
			!
			! [*,Member]
			!
		        IF .LMTKEY[LMT_W_MEM] NEQU .RECBUF[UAF$W_MEM]
		        THEN
			    LEAVE SEQUENTIAL ;
		    IF .MEM_WILD AND NOT .GRP_WILD
		    THEN
		        !
			! [Group,*]
			!
			IF .LMTKEY[LMT_W_GRP] NEQU .RECBUF[UAF$W_GRP]
			THEN
			    LEAVE SEQUENTIAL ;
		    IF NOT (.GRP_WILD OR .MEM_WILD)
		    THEN
			!
			! [Group,Member]
			!
			IF .LMTKEY[LMT_L_UIC] NEQU .RECBUF[UAF$L_UIC]
			THEN
			    LEAVE SEQUENTIAL ;
		    END ;
		IF NOT (STATUS = (.ACTION)())
		THEN
		    LEAVE SEQUENTIAL ;
		END ;
	    IF .STATUS EQL RMS$_EOF
	    THEN
		STATUS = TRUE ;		! Hitting EOF is ok
	    END ;

IF .STR_WILD AND .found_match EQL false
THEN
    FAOOUT ( BADSPC );


!
! The RAB must be returned to its former state before exiting.
!

UAFRAB[RAB$B_RAC] = RAB$C_KEY ;		! needed only IF .STR_WILD OR .UIC_FLAG

IF .UIC_FLAG
THEN
    BEGIN
    UAFRAB[RAB$B_KRF] = 0 ;
    UAFRAB[RAB$L_KBF] = RECBUF[UAF$T_USERNAME] ;
    UAFRAB[RAB$B_KSZ] = UAF$S_USERNAME ;
    END ;

!
! Reset parse count
!
call_count = 0;

.STATUS
END;

ROUTINE DISPLAY_BRIEF =
BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Provide an ASCII listing of the most important record information
!	(username, owner, etc.) for each record supplied.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	RABPTR - RMS data structure for the file
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--

!
! Output a header if one was requested.
!

IF .HEADER_FLAG
THEN
    BEGIN
    FAOMAC( LSTSTR1 )
    HEADER_FLAG = FALSE ;
    END ;



IF .STR_WILD AND NOT fmg$match_name( NAMELEN, RECBUF[UAF$T_USERNAME],
		                   .match_tokenlen,  match_token )
THEN
    RETURN TRUE;

found_match = true;

!
! Output the record.
!

CH$FILL( ' ' , DISBUFLEN , DISBUF ) ;

FAOMAC( LSTSTR2 ,
    UAF$S_OWNER , RECBUF[UAF$T_OWNER] ,
    UAF$S_USERNAME , RECBUF[UAF$T_USERNAME] ,
    .RECBUF[UAF$W_GRP] ,
    .RECBUF[UAF$W_MEM] ,
    UAF$S_ACCOUNT , RECBUF[UAF$T_ACCOUNT] ,
    CLASSIFY_PRIV( RECBUF[UAF$Q_PRIV] ),
    .RECBUF[UAF$B_PRI] ,
    RECBUF[UAF$T_DEFDEV] ,
    RECBUF[UAF$T_DEFDIR] )

TRUE
END;

ROUTINE CLASSIFY_PRIV( PRVADR ) =
BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Classifies privilege bits and reports the highest class available
!	to the owner of the supplied vector.
!
! INPUTS:
!
!	PRVADR - Address of the privilege vector
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--

MAP
    PRVADR: REF BLOCK[8,BYTE] ;

IF .PRVADR[PRV$V_CMKRNL] OR
   .PRVADR[PRV$V_CMEXEC] OR
   .PRVADR[PRV$V_SYSNAM] OR
   .PRVADR[PRV$V_DETACH] OR
   .PRVADR[PRV$V_LOG_IO] OR
   .PRVADR[PRV$V_SETPRV] OR
   .PRVADR[PRV$V_PHY_IO] OR
   .PRVADR[PRV$V_PFNMAP] OR
   .PRVADR[PRV$V_SYSPRV] OR
   .PRVADR[PRV$V_BYPASS]
THEN
    RETURN LSTPRVA ;			! Universal Privilege

IF .PRVADR[PRV$V_DIAGNOSE] OR
   .PRVADR[PRV$V_VOLPRO] OR
   .PRVADR[PRV$V_SYSGBL]
THEN
    RETURN LSTPRVB ;			! Potentially Comprimises File Security

IF .PRVADR[PRV$V_PSWAPM] OR
   .PRVADR[PRV$V_SETPRI] OR
   .PRVADR[PRV$V_WORLD] OR
   .PRVADR[PRV$V_OPER]
THEN
    RETURN LSTPRVC ;			! Can Interfere with System Operation

IF .PRVADR[PRV$V_GRPNAM] OR
   .PRVADR[PRV$V_ALLSPOOL] OR
   .PRVADR[PRV$V_NOACNT] OR
   .PRVADR[PRV$V_PRMCEB] OR
   .PRVADR[PRV$V_PRMMBX] OR
   .PRVADR[PRV$V_EXQUOTA] OR
   .PRVADR[PRV$V_BUGCHK] OR
   .PRVADR[PRV$V_PRMGBL] OR
   .PRVADR[PRV$V_SHMEM]
THEN
    RETURN LSTPRVD ;			! Can Devour System Resources

IF .PRVADR[PRV$V_GROUP]
THEN
    RETURN LSTPRVE ;			! Can Interfere with Group Members

IF .PRVADR[PRV$V_TMPMBX] OR
   .PRVADR[PRV$V_NETMBX] OR
   .PRVADR[PRV$V_MOUNT]
THEN
    RETURN LSTPRVF ;			! Normal Privileges

LSTPRVG					! Not Privileged
END;

ROUTINE DISPLAY_FULL =
BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Display the fields of a UAF record.
!
! INPUTS:
!
!	RABPTR - RMS data structure for the file
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--

!
! Strings for login flag settings
!

BIND
    FLGSTR1 = CSTRING(' DISCTLY'),
    FLGSTR2 = CSTRING(' DEFCLI'),
    FLGSTR3 = CSTRING(' LOCKPWD'),
    FLGSTR4 = CSTRING(' CAPTIVE'),
    FLGSTR7 = CSTRING(' DISNEWMAIL'),
    FLGSTR8 = CSTRING(' DISWELCOME'),
    FLGSTR9 = CSTRING(' DISUSER'),
    FLGSTR5 = CSTRING(' DISDIALUP'),
    FLGSTR6 = CSTRING(' DISNETWORK'),
    NULLSTR = CSTRING(''),

    YES = CSTRING('ok'),
    NO  = CSTRING('--'),

    MON   = CSTRING(' Mon'),
    TUE   = CSTRING(' Tue'),
    WED   = CSTRING(' Wed'),
    THU   = CSTRING(' Thu'),
    FRI   = CSTRING(' Fri'),
    SAT   = CSTRING(' Sat'),
    SUN   = CSTRING(' Sun'),
    NODAY = CSTRING('    '),

    RECBUFK = (RECBUF+($BYTEOFFSET(UAF$B_SDAYFLAGS)
		     -$BYTEOFFSET(UAF$B_PDAYFLAGS)) ): BLOCK[,BYTE],

    CPUTIME = RECBUF[UAF$L_CPUTIM];	! CPU limit in hundredths of a second

LOCAL
    DELTA_TIME: VECTOR[LONG,2];		! Scratch area for system delta time

BUILTIN
    EMUL;



IF .STR_WILD AND NOT fmg$match_name( NAMELEN, RECBUF[UAF$T_USERNAME],
		                   .match_tokenlen,  match_token  )
THEN
    RETURN TRUE;

found_match = true;

FAOMAC( SHOWMSG1 ,
    UAF$S_USERNAME , RECBUF[UAF$T_USERNAME] ,
    UAF$S_OWNER , RECBUF[UAF$T_OWNER] )

FAOMAC( SHOWMSG2 ,
    UAF$S_ACCOUNT , RECBUF[UAF$T_ACCOUNT] ,
    .RECBUF[UAF$W_GRP],
    .RECBUF[UAF$W_MEM] )

FAOMAC( SHOWMSG3 ,
    UAF$S_DEFCLI , RECBUF[UAF$T_DEFCLI] ,
    RECBUF[UAF$T_LGICMD] )

FAOMAC( SHOWMSG35,
    RECBUF[UAF$T_DEFDEV] )

FAOMAC( SHOWMSG4 ,
    RECBUF[UAF$T_DEFDIR] ,
    IF .RECBUF[UAF$V_DISCTLY] THEN FLGSTR1 ELSE NULLSTR ,
    IF .RECBUF[UAF$V_DEFCLI] THEN FLGSTR2 ELSE NULLSTR ,
    IF .RECBUF[UAF$V_LOCKPWD] THEN FLGSTR3 ELSE NULLSTR ,
    IF .RECBUF[UAF$V_CAPTIVE] THEN FLGSTR4 ELSE NULLSTR ,
    IF .RECBUF[UAF$V_DISMAIL] THEN FLGSTR7 ELSE NULLSTR,
    IF .RECBUF[UAF$V_DISWELCOM] THEN FLGSTR8 ELSE NULLSTR,
    IF .RECBUF[UAF$V_DISACNT] THEN FLGSTR9 ELSE NULLSTR)

FAOMAC( SHOWMSG45 ,
    IF .RECBUF[UAF$V_MONDAY]      THEN NODAY   ELSE MON ,
    IF .RECBUF[UAF$V_TUESDAY]     THEN NODAY   ELSE TUE ,
    IF .RECBUF[UAF$V_WEDNESDAY]   THEN NODAY   ELSE WED ,
    IF .RECBUF[UAF$V_THURSDAY]    THEN NODAY   ELSE THU ,
    IF .RECBUF[UAF$V_FRIDAY]      THEN NODAY   ELSE FRI ,
    IF .RECBUF[UAF$V_SATURDAY]    THEN NODAY   ELSE SAT ,
    IF .RECBUF[UAF$V_SUNDAY]      THEN NODAY   ELSE SUN ,
    IF .RECBUF[UAF$V_DISDIALUP]   THEN FLGSTR5 ELSE NULLSTR ,
    IF .RECBUF[UAF$V_DISNETWORK]  THEN FLGSTR6 ELSE NULLSTR ,
    IF .RECBUF[UAF$V_MONDAY]      THEN MON     ELSE NODAY,
    IF .RECBUF[UAF$V_TUESDAY]     THEN TUE     ELSE NODAY,
    IF .RECBUF[UAF$V_WEDNESDAY]   THEN WED     ELSE NODAY,
    IF .RECBUF[UAF$V_THURSDAY]    THEN THU     ELSE NODAY,
    IF .RECBUF[UAF$V_FRIDAY]      THEN FRI     ELSE NODAY,
    IF .RECBUF[UAF$V_SATURDAY]    THEN SAT     ELSE NODAY,
    IF .RECBUF[UAF$V_SUNDAY]      THEN SUN     ELSE NODAY,
    IF .RECBUFK[UAF$V_DISDIALUP]  THEN FLGSTR5 ELSE NULLSTR ,
    IF .RECBUFK[UAF$V_DISNETWORK] THEN FLGSTR6 ELSE NULLSTR )

IF .(RECBUF[UAF$L_SDAYHOURS])<0,24> EQL 0 AND
   .(RECBUF[UAF$L_PDAYHOURS])<0,24> EQL 0
THEN
    BEGIN
	FAOMAC( SHOWMSG46 )
    END
ELSE
    BEGIN
	FAOMAC( SHOWMSG47 )
	FAOMAC( SHOWMSG48 ,
		IF .(RECBUF[UAF$L_PDAYHOURS])<0,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_PDAYHOURS])<1,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_PDAYHOURS])<2,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_PDAYHOURS])<3,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_PDAYHOURS])<4,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_PDAYHOURS])<5,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_PDAYHOURS])<6,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_PDAYHOURS])<7,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_PDAYHOURS])<8,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_PDAYHOURS])<9,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_PDAYHOURS])<10,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_PDAYHOURS])<11,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_PDAYHOURS])<12,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_PDAYHOURS])<13,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_PDAYHOURS])<14,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_PDAYHOURS])<15,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_PDAYHOURS])<16,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_PDAYHOURS])<17,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_PDAYHOURS])<18,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_PDAYHOURS])<19,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_PDAYHOURS])<20,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_PDAYHOURS])<21,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_PDAYHOURS])<22,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_PDAYHOURS])<23,1> THEN NO ELSE YES )
	FAOMAC( SHOWMSG49 ,
		IF .(RECBUF[UAF$L_SDAYHOURS])<0,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_SDAYHOURS])<1,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_SDAYHOURS])<2,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_SDAYHOURS])<3,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_SDAYHOURS])<4,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_SDAYHOURS])<5,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_SDAYHOURS])<6,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_SDAYHOURS])<7,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_SDAYHOURS])<8,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_SDAYHOURS])<9,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_SDAYHOURS])<10,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_SDAYHOURS])<11,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_SDAYHOURS])<12,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_SDAYHOURS])<13,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_SDAYHOURS])<14,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_SDAYHOURS])<15,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_SDAYHOURS])<16,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_SDAYHOURS])<17,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_SDAYHOURS])<18,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_SDAYHOURS])<19,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_SDAYHOURS])<20,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_SDAYHOURS])<21,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_SDAYHOURS])<22,1> THEN NO ELSE YES ,
		IF .(RECBUF[UAF$L_SDAYHOURS])<23,1> THEN NO ELSE YES )
    END;

FAOMAC( SHOWMSG5 ,
    .RECBUF[UAF$B_PRI] ,
    .RECBUF[UAF$L_BYTLM] ,
    .RECBUF[UAF$W_BIOLM] )

FAOMAC( SHOWMSG6 ,
    .RECBUF[UAF$W_PRCCNT] ,
    .RECBUF[UAF$L_PBYTLM] ,
    .RECBUF[UAF$W_DIOLM] )

FAOMAC( SHOWMSG7 ,
    .RECBUF[UAF$W_ASTLM] ,
    .RECBUF[UAF$W_DFWSCNT] ,
    .RECBUF[UAF$W_FILLM] )

FAOMAC( SHOWMSG8 ,
    .RECBUF[UAF$W_ENQLM] ,
    .RECBUF[UAF$W_WSQUOTA] ,
    .RECBUF[UAF$W_SHRFILLM] )

IF .CPUTIME NEQ 0
THEN
    BEGIN
    EMUL( %REF(-200000), %REF(.CPUTIME<1,31>),
	%REF(IF .CPUTIME<0,1> THEN -100000 ELSE 0), DELTA_TIME ) ;
    FAOMAC( SHOWMSG9 ,
	.RECBUF[UAF$W_TQCNT] ,
	MAX(.RECBUF[UAF$W_WSEXTENT], .RECBUF[UAF$W_WSQUOTA] ) ,
	DELTA_TIME )
    END
ELSE
    BEGIN
    FAOMAC( SHOWMSG10 ,
	.RECBUF[UAF$W_TQCNT] ,
	MAX(.RECBUF[UAF$W_WSEXTENT], .RECBUF[UAF$W_WSQUOTA] ) )
    END;

FAOMAC( SHOWMSG11 ,
	.RECBUF[UAF$B_MAXPROC] ,
	.RECBUF[UAF$B_MAXGRPROC] ,
	.RECBUF[UAF$L_PGFLQUOTA] )

PRINT_PRIV( RECBUF[UAF$Q_PRIV] ) ;

TRUE
END;

ROUTINE PRINT_PRIV( PRVADR ): NOVALUE =
BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Routine to output the names of the privilege bits set
!	in the privilege vector supplied.
!
! INPUTS:
!
!	PRVADR - Address of the privilege vector
!
! IMPLICIT INPUTS:
!
!	PRV$AB_NAMES - table of privilege names and bit numbers
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!
!--

LOCAL
	POINTER ,			! current location in PRV$AB_NAMES
	PRVCNT ,			! number of names in DISBUF
	SYMLEN ,			! length of bit name string
	SYMMIN ,			! minimum symbol length
	SYMVAL ;			! value ( bit number )

!
! Output the privilege message and initialize the buffer.
!

FAOMAC( PRVSTR1 )

DISBUF = ' ' ;				! insert blank at start
PRVCNT = 0 ;
RABPTR[RAB$W_RSZ] = 1 ;
POINTER = PRV$AB_NAMES ;		! point to symbol name table

WHILE (SYMMIN = .(.POINTER)<0,8>) NEQ 0	! pick up min symbol size
DO
    BEGIN

    !
    ! Pick up the next bit name and number.  If the bit is set, insert
    ! the bit name into the buffer.   When the buffer fills up output them
    ! to the user.
    !

    POINTER = .POINTER + 1 ;
    SYMVAL = .(.POINTER)<0,8> ;		! get bit number
    POINTER = .POINTER + 1 ;
    SYMLEN = .(.POINTER)<0,8> ;		! get name string length
    POINTER = .POINTER + 1 ;		! point to string
    IF .(.PRVADR)<.SYMVAL,1>
    THEN
	BEGIN

	!
	! Bit is set.  See if there's room in the buffer and insert it if so,
	! else output the buffer and start from scratch.
	!

	IF .RABPTR[RAB$W_RSZ] + .SYMLEN GEQ 64
	THEN
	    BEGIN

	    $PUT(RAB = .RABPTR) ;

	    PRVCNT = 0 ;		! reset counts
	    RABPTR[RAB$W_RSZ] = 1 ;
	    END ;

	!
	! Insert a blank and append symbol name.
	!

	DISBUF[.RABPTR[RAB$W_RSZ]] = %CHAR(' ') ;
	RABPTR[RAB$W_RSZ] = .RABPTR[RAB$W_RSZ] + 1 ;
	CH$MOVE( .SYMLEN , .POINTER , DISBUF[.RABPTR[RAB$W_RSZ]] ) ;
	RABPTR[RAB$W_RSZ] = .RABPTR[RAB$W_RSZ] + .SYMLEN ;
	PRVCNT = .PRVCNT + 1 ;		! one more name in buffer
	END;

    POINTER = .POINTER + .SYMLEN ;	! update table pointer over name
    END;

!
! Table used up.  If anything is in the buffer, print it.
!

IF .PRVCNT GTR 0
THEN
    $PUT(RAB = .RABPTR) ;

END;

ROUTINE BUILD_INI_RECS: NOVALUE =
BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Build the initial records for the creation of a new UAF file.
!	The user default record is built in the DEFAULT_RECORD
!	buffer and the system manager record is built in RECBUF.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	default record is built in DEFAULT_RECORD
!	system record is built in RECBUF
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--

!
! username is blank filled
!

CH$COPY ( .DEFUSER<0,8> , DEFUSER+1 , %CHAR(' ') ,
		UAF$S_USERNAME , DEFAULT_RECORD[UAF$T_USERNAME] ) ;

!
! account name is blank filled
!

CH$COPY ( .DEFACT<0,8> , DEFACT+1 , %CHAR(' ') ,
		UAF$S_ACCOUNT , DEFAULT_RECORD[UAF$T_ACCOUNT] ) ;

!
! quadword privilege mask
!

CH$MOVE( 8 , DEFPRIV , DEFAULT_RECORD[UAF$Q_PRIV] ) ;

!
! directory name is counted string
!

CH$COPY ( .DEFDIR<0,8> + 1 , DEFDIR , %CHAR(' ') ,
		UAF$S_DEFDIR , DEFAULT_RECORD[UAF$T_DEFDIR] ) ;

!
! device name is counted string
!

CH$COPY ( .DEFDEV<0,8> + 1 , DEFDEV , %CHAR(' ') ,
		UAF$S_DEFDEV , DEFAULT_RECORD[UAF$T_DEFDEV] ) ;

!
! CLI name is blank filled
!

CH$COPY ( .DEFCLI<0,8> , DEFCLI+1 , %CHAR(' ') ,
		UAF$S_DEFCLI , DEFAULT_RECORD[UAF$T_DEFCLI] ) ;

!
! owner name is blank filled
!

CH$COPY ( .DEFOWNER<0,8> , DEFOWNER+1 , %CHAR(' ') ,
		UAF$S_OWNER , DEFAULT_RECORD[UAF$T_OWNER] ) ;

!
! login command file name is counted string
!

CH$COPY( .DEFLGICMD<0,8>+1 , DEFLGICMD , %CHAR('') ,
		UAF$S_LGICMD , DEFAULT_RECORD[UAF$T_LGICMD] ) ;

DEFAULT_RECORD[UAF$W_GRP] = DEFGRP ;
DEFAULT_RECORD[UAF$W_MEM] = DEFMEM ;
DEFAULT_RECORD[UAF$W_BIOLM] = DEFBIOLM ;
DEFAULT_RECORD[UAF$L_BYTLM] = DEFBYTLM ;
DEFAULT_RECORD[UAF$W_DIOLM] = DEFDIOLM ;
DEFAULT_RECORD[UAF$W_FILLM] = DEFFILLM ;
DEFAULT_RECORD[UAF$B_FLAGS] = DEFFLAGS ;
DEFAULT_RECORD[UAF$W_TQCNT] = DEFTQCNT ;
DEFAULT_RECORD[UAF$W_PRCCNT] = DEFPRCCNT ;
DEFAULT_RECORD[UAF$W_WSQUOTA] = DEFWSQUOTA ;
DEFAULT_RECORD[UAF$W_WSEXTENT] = DEFWSEXTENT ;
DEFAULT_RECORD[UAF$W_DFWSCNT] = DEFDFWSCNT ;
DEFAULT_RECORD[UAF$L_CPUTIM] = DEFCPUTIM ;
DEFAULT_RECORD[UAF$W_ASTLM] = DEFASTLM ;
DEFAULT_RECORD[UAF$L_PGFLQUOTA] = DEFPGFLQUOTA ;
DEFAULT_RECORD[UAF$W_ENQLM] = DEFENQLM ;
DEFAULT_RECORD[UAF$L_PBYTLM] = DEFPBYTLM ;
DEFAULT_RECORD[UAF$W_SHRFILLM] = DEFSHRFILLM ;
DEFAULT_RECORD[UAF$B_PRI] = DEFPRI ;
DEFAULT_RECORD[UAF$B_MAXPROC] = DEFMAXJOBS ;
DEFAULT_RECORD[UAF$B_MAXGRPROC] = DEFMAXACCTJOBS ;
DEFAULT_RECORD[UAF$B_PRIMEDAYS] = DEFPRIMEDAYS ;
DEFAULT_RECORD[UAF$L_PDAYHOURS] = DEFHOURS ;		!Hours and flags are
DEFAULT_RECORD[UAF$B_PDAYFLAGS] = DEFACCESSFLAGS ;	!order dependent
DEFAULT_RECORD[UAF$L_SDAYHOURS] = DEFHOURS ;		!Hours and flags are
DEFAULT_RECORD[UAF$B_SDAYFLAGS] = DEFACCESSFLAGS ;	!order dependent

CH$COPY( .SYSUSER<0,8> , SYSUSER+1 , %CHAR(' ') ,
		UAF$S_USERNAME , RECBUF[UAF$T_USERNAME] ) ;
CH$COPY( .SYSACT<0,8> , SYSACT+1 , %CHAR(' ') ,
		UAF$S_ACCOUNT , RECBUF[UAF$T_ACCOUNT] ) ;
CH$MOVE( 8 , SYSPRIV , RECBUF[UAF$Q_PRIV] ) ;
CH$COPY ( .SYSDIR<0,8> + 1 , SYSDIR , %CHAR(' ') ,
		UAF$S_DEFDIR , RECBUF[UAF$T_DEFDIR] ) ;
CH$COPY ( .SYSDEV<0,8> + 1 , SYSDEV , %CHAR(' ') ,
		UAF$S_DEFDEV , RECBUF[UAF$T_DEFDEV] ) ;
CH$COPY ( .SYSCLI<0,8> , SYSCLI+1 , %CHAR(' ') ,
		UAF$S_DEFCLI , RECBUF[UAF$T_DEFCLI] ) ;
CH$COPY( .SYSOWNER<0,8> , SYSOWNER+1 , %CHAR(' ') ,
		UAF$S_OWNER , RECBUF[UAF$T_OWNER] ) ;
CH$COPY( .SYSLGICMD<0,8>+1 , DEFLGICMD , %CHAR('') , 
		UAF$S_LGICMD , RECBUF[UAF$T_LGICMD] ) ;

PWDDSC[DSC$W_LENGTH] = .SYSPASS<0,8> ;
PWDDSC[DSC$A_POINTER] = SYSPASS+1 ;
$GETTIM(TIMADR = TIME_BUF) ;			! Obtain a 16 bit salt
RECBUF[UAF$W_SALT] = .TIME_BUF<3*8,16> ;
RECBUF[UAF$B_ENCRYPT] = ENCRYPT ;
LGI$HPWD( REC_ENCRYPT_DSC, PWDDSC, .RECBUF[UAF$B_ENCRYPT],
			.RECBUF[UAF$W_SALT], REC_USER_DSC ) ;

RECBUF[UAF$W_GRP] = SYSGRP ;
RECBUF[UAF$W_MEM] = SYSMEM ;
RECBUF[UAF$W_BIOLM] = SYSBIOLM ;
RECBUF[UAF$L_BYTLM] = SYSBYTLM ;
RECBUF[UAF$W_DIOLM] = SYSDIOLM ;
RECBUF[UAF$W_FILLM] = SYSFILLM;
RECBUF[UAF$B_FLAGS] = SYSFLAGS;
RECBUF[UAF$W_TQCNT] = SYSTQCNT ;
RECBUF[UAF$W_PRCCNT] = SYSPRCCNT ;
RECBUF[UAF$W_WSQUOTA] = SYSWSQUOTA ;
RECBUF[UAF$W_WSEXTENT] = SYSWSEXTENT ;
RECBUF[UAF$W_DFWSCNT] = SYSDFWSCNT ;
RECBUF[UAF$L_CPUTIM] = SYSCPUTIM ;
RECBUF[UAF$W_ASTLM] = SYSASTLM ;
RECBUF[UAF$L_PGFLQUOTA] = SYSPGFLQUOTA ;
RECBUF[UAF$W_ENQLM] = SYSENQLM ;
RECBUF[UAF$L_PBYTLM] = SYSPBYTLM ;
RECBUF[UAF$W_SHRFILLM] = SYSSHRFILLM ;
RECBUF[UAF$B_PRI] = SYSPRI ;
RECBUF[UAF$B_MAXPROC] = SYSMAXJOBS ;
RECBUF[UAF$B_MAXGRPROC] = SYSMAXACCTJOBS ;
RECBUF[UAF$B_PRIMEDAYS] = SYSPRIMEDAYS ;
RECBUF[UAF$L_PDAYHOURS] = SYSHOURS ;		!Hours and flags are
RECBUF[UAF$B_PDAYFLAGS] = SYSACCESSFLAGS ;	!order dependent
RECBUF[UAF$L_SDAYHOURS] = SYSHOURS ;		!Hours and flags are
RECBUF[UAF$B_SDAYFLAGS] = SYSACCESSFLAGS ;	!order dependent
END;

ROUTINE GET_USER_RECORD( LOCK_RECORD , PERMANENT_OK ) =
BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine pulls the next token out of the command
!	buffer, assuming it is the username, and looks up the
!	UAF record for that name.  If the record is found,
!	it is loaded into RECBUF (by routine LOCATE_USER) .
!
! INPUTS:
!
!	LOCK_RECORD - specifies that the GET shall lock the record
!	PERMANENT_OK - specifies that the DEFAULT and SYSTEM records are allowed
!
! IMPLICIT INPUTS:
!
!	TOKENPTR - address of delimiter following last token processed,
!		  which was the command name.
!	TOKENLEN - global variable to contain length of current token
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	true -> user record found
!	false -> user record not found
!
! SIDE EFFECTS:
!
!	none
!--

BUILTIN
    NULLPARAMETER;

!
! Is this the second phase of a RENAME?
!
IF .rename_ph2
THEN
    BEGIN
    IF .netuaf_exists
    THEN
	ADJUST_PROXY ( update_records );
    CH$MOVE (.savedlen, savedtoken, .tokenptr); 
    tokenlen = .savedlen;
    rename_ph2 = false;
    END
!
! Not the second phase of a RENAME.  Get first token, and if this
!    is the first phase of a RENAME (COPY phase) , save token for 
!    the second phase (REMOVE phase).
!
ELSE
    BEGIN
        !
	! Get token
	!
        IF NOT cli$present(sd_token1) OR
           NOT cli$get_value(sd_token1,tokendsc) OR
           .TOKENLEN EQL 0
        THEN
            RETURN FAOOUT( NOUSERNAME ) ;
	!
	! If the third argument is present, this is the first phase of a 
	!   RENAME,  so save the token for the next call 
	!    
	IF NOT NULLPARAMETER(3)
	THEN
	    BEGIN
	    CH$MOVE( .tokenlen, .tokenptr, savedtoken );
	    savedlen = .tokenlen;
	    rename_ph2 = true;
	    END;
	END;

IF NOT .PERMANENT_OK
THEN
    BEGIN
    IF CH$EQL( .DEFUSER<0,8> , DEFUSER+1 , .TOKENLEN , .TOKENPTR  , ' ' )
    THEN
	IF NULLPARAMETER(3)
	THEN
	    RETURN FAOOUT( REMDEF )
	ELSE
	    RETURN FAOOUT( RENDEF );

    IF CH$EQL( .SYSUSER<0,8> , SYSUSER+1 , .TOKENLEN , .TOKENPTR , ' ' )
    THEN
	IF NULLPARAMETER(3)
	THEN
	    RETURN FAOOUT( REMSYS )
	ELSE
	    RETURN FAOOUT( RENSYS );
    END;

IF LOCATE_USER( .TOKENLEN , .TOKENPTR , .LOCK_RECORD ) 
THEN
    RETURN TRUE; 

IF .RMSERR EQL RMS$_RNF
THEN
    FAOOUT( BADUSR , .TOKENLEN , .TOKENPTR )
ELSE
    FMT_SYS_MSG( GETERR , .RMSERR ) ;
FALSE
END;

ROUTINE LOCATE_USER( SIZE , BUFFER , LOCK_RECORD ) =
BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Routine to locate a user record in the UAF file.
!
! INPUTS:
!
!	SIZE - size of the username string
!	BUFFER - address of the username string
!	LOCK_RECORD - specifies that the GET shall lock the record
!
! IMPLICIT INPUTS:
!
!	UAFRAB - RMS data structure for SYSUAF.DAT
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	If record is found, RECBUF contains the located record.
!
! ROUTINE VALUE:
!
!	true -> record found
!	false -> record not found
!
! SIDE EFFECTS:
!
!	none
!--

LOCAL
	FOUND ;					! record found indicator

FOUND = TRUE ;					! assume record was found

CH$COPY( .SIZE , .BUFFER , %CHAR(' ') ,
		UAF$S_USERNAME , RECBUF[UAF$T_USERNAME] ) ;

UAFRAB[RAB$V_NLK] = NOT .LOCK_RECORD ;

IF NOT (RMSERR = GET_UAF_RECORD())
THEN
    FOUND = FALSE ;

RETURN .FOUND ;					! return indicator
END;

ROUTINE GET_UAF_RECORD =
BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	A common routine to GET records from SYSUAF.DAT, deal with retries 
!	when the record is locked, and insure that UAF$L_BYTLM contains a 
!	valid value.  If the value read for UAF$L_BYTLM is zero, this 
!	routine copies UAF$W_BYTLM into it.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	UAFRAB - RMS data structure for SYSUAF.DAT
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	RECBUF - The user's record
!
!		 RECBUF[UAF$L_BYTLM] is guaranteed to contain a reasonable 
!		 value, either the non-zero value found in the actual 
!		 record or the value found in UAF$W_BYTLM, the old cell 
!		 for storing this value.
!
! ROUTINE VALUE:
!
!	RMS status code
!
! SIDE EFFECTS:
!
!	none
!--
LOCAL
    COUNTER ,				! number of retries remaining
    SUCCESS ;

!
! If anybody's record is locked it shouldn't remain that way for long.
!

COUNTER = RETRY_RLK ;
WHILE ((SUCCESS = $GET(RAB = UAFRAB)) EQL RMS$_RLK)
			AND ((COUNTER = .COUNTER - 1) GEQ 0)
DO
    IF $SCHDWK(DAYTIM = WAKEDELTA) THEN $HIBER ;

!
! If a zero UAF$L_BYTLM was successfully read, 
! copy UAF$W_BYTLM to UAF$L_BYTLM.
!
IF .SUCCESS AND .RECBUF[UAF$L_BYTLM] EQL 0 THEN
    RECBUF[UAF$L_BYTLM] = .RECBUF[UAF$W_BYTLM];

.SUCCESS
END;

ROUTINE GET_CMD_LINE: NOVALUE =
BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine reads in the command line from the user, 
!	reading additional lines if continuation is specified by
!	a '-' as the last character on the input line.
!	A zero byte is inserted following the last input character read.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	CMDBUF - buffer to receive the user's command line
!	CMDBUFLEN - literal length of CMDBUF
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	CMDBUF is filled with command line
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--

MAP
    CMDLINDSC: VECTOR;

LOCAL
	PTR,					! index into CMDBUF
	BUFLEN ;				! remaining buffer length

!
! Prompt with normal prompt string until some input is supplied.
!

DO
    ASK( ACCPRMPT , CMDBUF[0] , CMDBUFLEN )
UNTIL
    .INSIZE NEQ 0 ;

!
! Now that line has been read, continue reading until
! last character is not a '-'.
!

PTR = .INSIZE - 1 ;				! index to last character read
BUFLEN = CMDBUFLEN ;				! initial buffer size

WHILE
    .CMDBUF[.PTR] EQL '-'
DO
    BEGIN

    !
    ! Read starting at the position of the '-'. Then adjust the
    ! index and remaining length to point to the last character
    ! of the next input.
    !

    BUFLEN = .BUFLEN - ( .INSIZE + 1 ) ;
    ASK( ACCPRMPT2 , CMDBUF[.PTR] , .BUFLEN ) ;
    PTR = .PTR + .INSIZE - 1 ;
    END;

CMDBUF[.PTR+1] = 0 ;				! mark end of string

CMDLINDSC [0] = .PTR + 1;
CMDLINDSC [1] = CMDBUF;

END;

GLOBAL ROUTINE ASK( STRING , BUFFER , LEN ): NOVALUE =
BEGIN

!++
!
! FUNCTIONAL DESCTIPTION:
!
!	Routine to prompt user for input.  The input string is read
!	into the user specified buffer and the size read
!	is placed in the global INSIZE.
!
! INPUTS:
!
!	STRING - the address of a counted ascii prompt string
!	BUFFER - address of the input buffer
!	LEN - length of the input buffer
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	INSIZE - size of the input string
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--

MAP
	BUFFER: REF VECTOR[,BYTE] ;

INRAB[RAB$L_PBF] = .STRING + 1 ;			! prompt string address
INRAB[RAB$B_PSZ] = .(.STRING)<0,8> ;			! prompt size
INRAB[RAB$L_UBF] = .BUFFER ;				! buffer address
INRAB[RAB$W_USZ] = .LEN ;				! buffer size

!
! If end of file encountered on get (either ^Z from terminal or
! end of file on indirect command file) then take exit path.
!

IF $GET( RAB=INRAB ) EQL RMS$_EOF
THEN
    EXIT_UAF() ;

IF (INSIZE = .INRAB[RAB$W_RSZ]) NEQ 0			! get input size
THEN
    INCRU I TO .INSIZE - 1				! Upcasing is done here because the CVT
    DO							! option does not work under batch.
	IF .BUFFER[.I] GEQU 'a' AND .BUFFER[.I] LEQU 'z'
	THEN
	    BUFFER[.I] = .BUFFER[.I] AND NOT %O'040';

BUFFER[.INSIZE] = 0 ;					! zero end of buffer
END;

ROUTINE FMT_SYS_MSG( FAOSTR , MSGID ): NOVALUE =
BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine outputs an error message followed by
!	the text found in the system message file for the 
!	error condition.  If the message is not found, the message
!	ID itself is printed.
!
! INPUTS:
!
!	FAOSTR - address of counted ascii message to be printed
!	MSGID - error number
!
! IMPLICIT INPUTS:
!
!	None
!
! OUTPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!--

LOCAL
	BUFFER: VECTOR[200,BYTE] ,		! buffer to receive message
	BUFDSC:	VECTOR[2,LONG] ,		! string descriptor
	CODE ;					! save return code

BUFDSC[0] = 200 ;				! construct string descriptor
BUFDSC[1] = BUFFER ;

CODE = $GETMSG( MSGID = .MSGID , MSGLEN = BUFDSC[0] , BUFADR = BUFDSC[0] );

!
! Output internal message.  Then output system error or error number.
!

FAOOUT( .FAOSTR ) ;
IF .CODE EQL SS$_MSGNOTFND
    THEN FAOOUT( SYSMSG2 , .MSGID )
    ELSE FAOOUT( SYSMSG1 , BUFDSC[0] ) ;
END;

GLOBAL ROUTINE FAOOUT( STRING , P1 ) =
BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Routine to output a formatted string.
!
! INPUTS:
!
!	STRING - address of a counted ASCII FAO control string.
!	P1 - the first of possibly several parameters to FAO
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	FAOOUT always returns FALSE, as it is often used on the
!	return from an error condition.
!
! SIDE EFFECTS:
!
!	none
!--


FAODSC[DSC$W_LENGTH] = .(.STRING)<0,8> ;	! input string descriptor
FAODSC[DSC$A_POINTER] = .STRING+1 ;
$FAOL(	CTRSTR = FAODSC ,
	OUTLEN = OUTRAB[RAB$W_RSZ] ,
	OUTBUF = DISDSC ,
	PRMLST = P1) ;

$PUT(RAB = OUTRAB) ;

FALSE
END;

GLOBAL ROUTINE HELP_UAF: NOVALUE =
BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Print out the help message or messages.
!
! INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--
MAP
    cmdlindsc: VECTOR;

LOCAL
    line_dsc: VECTOR [2];

line_dsc [0] = .cmdlindsc [0];
line_dsc [1] = .cmdlindsc [1];

!
! The first thing to do is to remove 'help' from the command line
!    	and give the help routine the remainder of the command line.
!       Find the beginning of the word 'help'.
!
IF .(.line_dsc [1])<0,8> EQL ' '
THEN
    BEGIN
    line_dsc [1] = CH$FIND_NOT_CH(.line_dsc [0], .line_dsc [1], ' ');
    line_dsc [0] = .line_dsc [0] - ( .line_dsc [1] - .cmdlindsc [1] );
    END;

!
! Now skip past the 'help' to the first blank (if there is one)
!
IF CH$FAIL( line_dsc [1] = CH$FIND_CH(.line_dsc [0], .line_dsc [1], ' '))
THEN
    !
    ! No blank, set empty string
    !
    line_dsc [0] = 0
ELSE
    !
    ! Found a blank, set pointer to it
    !
    line_dsc [0] = .cmdlindsc [0] - ( .line_dsc [1] - .cmdlindsc [1] );

!
! Start an interactive HELP session
!

IF NOT lbr$output_help( lib$put_output, 0, line_dsc,
			 $descriptor('uafhelp'), 0,
			 lib$get_input )
THEN
    FAOOUT ( HELPERR );

END;

GLOBAL ROUTINE EXIT_UAF: NOVALUE =
BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Normal exit routine.
!
! INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	image exits
!--

$CLOSE(FAB = UAFFAB) ;

!
! Inform user of file modifications.
!

IF .MODIFY_FLAG
THEN
    !
    ! File has been modified
    !
    FAOOUT( DONEMSG )			! tell user all is done
ELSE
    !
    ! Here, no modifications were made to file.
    !
    FAOOUT( NOMODS ) ;
$EXIT(CODE = TRUE) ;
END;

ROUTINE ACC$EXIT: NOVALUE =
BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Exit on error condition.
!
! INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!--

$EXIT();
END;

END				!End of module
ELUDOM
