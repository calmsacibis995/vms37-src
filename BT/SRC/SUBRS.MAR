	.TITLE	SUBRS - SUBROUTINES INVOKED BY BACKTRANSLATOR MACROS
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; H.J.	AUGUST 1977
;
; BACKTRANSLATOR SUBROUTINES
;

;
; MACRO LIBRARY CALLS
;
	$BTDEFS				;DEFINE VALUES TO BE USED LOCALLY

;
; LOCAL SYMBOLS
;

;
; ARGUMENT LIST OFFSET DEFINITIONS
;

;
; LOCAL DATA
;
	IMPURE
;
;
;
VALUE_DESC::
	$CLIREQDESC -			;REQUEST BLOCK FOR SINGLE VALUE
		RQTYPE=CLI$K_ASCIIVAL	;ASCII STRING VALUE


; HANDLE UP TO FOUR POSITIONAL SUB VALUES

SUBVALS:.BYTE	^A\:\,0,0,0,0,0,0,0 ;SEVEN BYTES TO STORE POSITIONAL NUMBER
	.BYTE	^A\:\,0,0,0,0,0,0,0 ;SEVEN BYTES TO STORE POSITIONAL NUMBER
	.BYTE	^A\:\,0,0,0,0,0,0,0 ;SEVEN BYTES TO STORE POSITIONAL NUMBER
	.BYTE	^A\:\,0,0,0,0,0,0,0 ;SEVEN BYTES TO STORE POSITIONAL NUMBER

	.SBTTL	SETSTRING - INSERT A STRING INTO RESULT LIST
	PURE
;+
; BACKTRANSLATOR SUBROUTINE
;
;  SETSTRING  PLACES THE PASSED STRING INTO THE RESULT LIST
;
;
;   INPUTS:
;	A PARAMETER CONTROL BLOCK CREATED BY THE $SETSTRING MACRO
;
;   OUTPUTS:
;	THE RESULT STRING TEXT OR AN ERROR MESSAGE AND ABORT
;
;-
SETSTRING::
	BSBW	PROGSET			;PERFORM COMMON INITIALIZATION
					;AND SET THE PROGRAM TO INVOKE
	MOVZBL	(R10)+,R9		;PICK UP THE RESULT STRING COUNT
	BSBW	INSERTSTR		;CREATE RESULT STRING TEXT
	ADDL	R9,R10			;UPDATE RETURN POINTER FOR RETURNS
	BBS	#BTR$V_RETURN,R8,10$	;RETURN TO CLI OR CALLER?

	RET				;RETURN TO CLI
10$:	JMP	(R10)			;RETURN TO CALLER

	.PAGE
	.SBTTL	GETSTRING - STRING VALUE ARGUMENT GETTER
;+
;  GETSTRING  PICKS UP A STRING QUALIFIER AND GENERATES
;		THE RESULTANT TEXT STRING
;
;   INPUTS:
;	A PARAMETER CONTROL BLOCK CREATED BY $GETSTRING OR $GETDECNUM MACRO
;
;   OUTPUTS:
;	THE RESULT STRING TEXT OR AN ERROR MESSAGE AND ABORT
;
;-
DECNUMARG::
GETSTRING::
	BSBW	PROGSET			;PERFORM COMMON INITIALIZATION
					;AND SET THE PROGRAM TO INVOKE
	MOVZBL	(R10)+,R9		;PICK UP THE RESULT STRING COUNT
	BSBW	INSERTSTR		;CREATE RESULT STRING TEXT
	ADDL	R9,R10			;UPDATE RETURN POINTER FOR LATER
	BSBW	GETSUBVAL		;GO GET A SUBVALUE
	BLBC	R0,70$			;BRANCH IF THERE WAS NO VALUE
	BBS	#BTR$V_VALREQ,R8,20$	;BRANCH TO SUPPRESS DELIMITER
10$:	MOVB	#^A\:\,R7		;SET UP CHARACTER TO INSERT
	BSBW	ADDCHAR			;INSERT THE ':'
20$:	PUSHR	#^M<R9,R10>		;SAVE SOME REGS
	MOVQ	W^CLI$Q_RQDESC+VALUE_DESC,R9 ;GET SIZE AND ADDRESS OF VALUE
	BSBW	ADDSTR			;ADD THE VALUE TEXT ONTO THE PARAMETER
	BBC	#BTR$V_DECIMAL,R8,30$	;BRANCH IF A STRING VALUE (NOT NUMBER)
	MOVB	#^A\.\,R7		;FORCE A DECIMAL POINT
	CMPB	R7,-(R10)[R9]		;WAS A DECIMAL POINT GIVEN?
	BEQL	30$			;BRANCH IF YES
	BSBW	ADDCHAR			;ADD THE DECIMAL POINT
30$:	POPR	#^M<R9,R10>		;RESTORE REGS
	BSBW	GETSUBVAL		;TRY TO GET ANOTHER VALUE
	BLBS	R0,60$			;BRANCH IF ANOTHER VALUE, IS IT LEGAL?
40$:	BBS	#BTR$V_RETURN,R8,50$	;SHOULD WE RETURN TO CALLER OR CLI?

	RET				;RETURN TO CLI
50$:	JMP	(R10)			;RETURN TO CALLER

60$:	BBS	#BTR$V_LIST,R8,10$	;BRANCH TO COLLECT A STRING LIST
	ERROR	UNEXPLIST,FATAL		;REPORT ERROR AND ABORT
70$:	BBC	#BTR$V_VALREQ,R8,40$	;BRANCH IF VALUE NOT REQUIRED, NO ERROR
NOVAL:	ERROR	MISSNGVAL,FATAL		;REPORT ERROR AND ABORT
	.PAGE
	.SBTTL	GETKEYWORD - VERIFY KEYWORD AND RETURN INDEX
;+
; GETKEYWORD  CALLS MATCHKEY TO RETURN INDEX OF KEYWORD IN LIST
; GETKEYWORDNVAL IS THE SIMILAR BUT ASSUMES THE GETSUBVAL CALL HAS BEEN DONE
;
;  INPUTS:
;   A STRING TABLE BUILT BY THE $GETKEYWORD MACRO
;   A CLI QUALIFIER DESCRIPTOR BLOCK DESCRIBING THE QUALIFIER VALUE
;
;  OUTPUTS:
;   THE INDEX OF THE QUALIFIER VALUE IN THE KEYWORD LIST OR FAILURE FLAG
;
;-
	.ENABL	LSB

GETKEYWORDNVAL::
	MOVL	(SP)+,R10		;GET THE RETURN ADDRESS
	MOVZBL	(R10)+,R9		;GET THE LENGTH OF THE KEYWORD TABLE
	BRB	10$			;USE COMMON CODE

GETKEYWORD::
	MOVL	(SP)+,R10		;GET THE RETURN ADDRESS
	MOVZBL	(R10)+,R9		;GET THE LENGTH OF THE KEYWORD TABLE
	BSBB	GETSUBVAL		;GET THE SUBVALUE
10$:	BLBC	R0,20$			;BRANCH IF NO VALUE, CHECK FOR ERROR
	PUSHAB	W^CLI$Q_RQDESC+VALUE_DESC ;CREATE AN ARGUMENT BLOCK FOR MATCHKEY
	PUSHL	R10			;PUSH POINTER TO KEYWORD TABLE
	CALLS	#2,W^MATCHKEY		;LOCATE THE OPTION
	TSTL	R0			;WHAT KIND OF RETURN OCCURED?
	BGTR	30$			;BRANCH IF GOOD MATCH ON KEYWORD
	BEQL	40$			;BRANCH IF NOT FOUND
	ERROR	AMBIGKEYW,FATAL

20$:	BBSC	#BTR$V_VALREQ,R8,NOVAL;BRANCH IF NO KEYWORD AND ONE REQUIRED

	CLRL	R0			;INDICATE NO VALUE
30$:	JMP	(R10)[R9]		;RETURN TO CALLER

40$:	ERROR	INVALKEYW,FATAL

	.DSABL	LSB
	.PAGE
	.SBTTL	GETSUBVAL - SUBROUTINE TO DO CALL BACK TO CLI FOR SUBVALUE
;+
; BACKTRANSLATOR SUBROUTINE
;
;  GETSUBVAL GETS THE DESCRIPTOR FOR THE VALUE INTO 'VALUE_DESC'
;
;  GETSUBKEYVAL IS AN ALTERNATE ENTRY TO PICK UP DESCRIPTORS OF KEYWORD
;	     SUBVALUES INTO 'VALUE_DESC'.  THIS ENTRY MAY ONLY BE USED
;	     AFTER A CALL THAT SETS UP VALUE_DESC CORRECTLY (E.G. GETKEYWORD).
;
;
;   INPUTS:
;	AP IS SET UP AS RESULT OF CALLBACK FROM CLI
;
;   OUTPUTS:
;	THE RESULT STRING DESC OR AN ERROR MESSAGE AND ABORT
;	R0 LOW BIT = 0 MEANS SUBVALUE DOESN'T EXIST
;
;-
	.ENABL	LSB

GETSUBKEYVAL::
	BBC	#CLI$V_KEYVALU,W^CLI$B_RQSTAT+VALUE_DESC,10$ ;FAIL IF KEYWORD
					;SUB VALUE DOESN'T EXIST
GETSUBVAL::
	MOVL	4(AP),R0		;GET POINTER TO QUALIFIER BLOCK
	TSTW	CLI$W_QDVALSIZ(R0)	;WAS THERE A SUBVALUE?
	BEQL	10$			;BRANCH IF NOT
	PUSHAB	(R0)			;CREATE A QUALIFIER VALUE ARG BLOCK
	PUSHAB	W^CLIWORKAREA		;POINTER TO THE WORK AREA
	PUSHAB	W^VALUE_DESC		;POINTER TO THE VALUE DESCRIPTOR
	CALLS	#3,@CLI$A_UTILSERV(AP)	;GET THE VALUE
	BLBS	R0,20$			;BRANCH ON SUCCESSFUL RETURN
	ERROR	INTFAIL,FATAL		;ABORT
10$:	CLRL	R0			;INDICATE NO SUBVALUE
20$:	RSB				;RETURN

	.DSABL	LSB
	.PAGE
	.SBTTL	REPLACE - TRANSLATE A KEYWORD VALUE
;+
; REPLACE  PLACES THE STRING INDICATED BY THE INDEX INTO RESULT OPTION
;
;  INPUTS:
;    R0 CONTAINS INDEX OF STRING IN TABLE
;    BYTE FOLLOWING RETURN ADDRESS CONTAINS OFFSET TO RETURN TO
;    BYTES FOLLOWING ARE THE TABLE
;
;  OUTPUTS:
;    THE STRING IS CONCATENATED ONTO THE RESULT OPTION LIST
;
;-
REPLACE::
	MOVL	(SP)+,R10		;GET THE RETURN ADDRESS
	CVTBL	(R10)+,R9		;GET OFFSET TO RETURN TO
	MNEGL	R0,R0			;MAKE INDEX NEGATIVE FOR LOCC
	BEQL	10$			;BRANCH IF NO VALUE TO RETURN
	PUSHR	#^M<R9,R10>		;SAVE REGS
	LOCC	R0,#200,(R10)		;LOCATE THE STRING, LENGTH IS DUMMY
	INCL	R1			;POINT TO COUNT FIELD OF ARGUMENT
	MOVZBL	(R1)+,R9		;GET LENGTH FOR ADDSTR CALL
	MOVL	R1,R10			;SET UP ADDRESS ARGUMENT
	BSBW	ADDSTR			;ADD THE TEXT TO THE RESULT STRING
	POPR	#^M<R9,R10>		;RESTORE REGS
	JMP	(R10)[R9]		;RETURN TO CALLER
10$:	RET				;RETURN TO CLI

	.PAGE
	.SBTTL	ORDERSUBVAL - SAVE NUMERIC SUB VALUES INTO POSITIONAL OREDR
;+
; BACKTRANSLATOR SUBROUTINE
;
;  ORDERSUBVAL  SAVES THE NUMERIC STRING INTO AN ORDERED LIST
;
;
;   INPUTS:
;	R0 CONTAINS THE POSITION NUMBER TO PUT THE RESULT STRING
;
;   OUTPUTS:
;	THE OUTPUT IS THE NUMERIC LIST IN THE REQUESTED POSITIONAL ORDER
;
;-
ORDERSUBVAL::
	PUSHL	R0			;IS THERE A VALUE?
					;WARNING- STACK IS NOT CLEAN
	BEQL	20$			;BRANCH IF NOT
	BSBW	GETSUBKEYVAL		;GET THE SUB VALUE STRING
	BLBC	R0,70$			;BRANCH IF THERE WAS NO VALUE
	MOVQ	W^CLI$Q_RQDESC+VALUE_DESC,R9 ;GET SIZE AND ADDRESS OF VALUE
	CMPW	#5,R9			;MAKE SURE STRING WILL FIT IN TABLE
	BLSS	60$			;BRANCH IF SUBVALUE TOO LONG
	ASHL	#3,(SP)+,R0		;PUT VALUE INTO CORRECT SLOT
	MOVC3	R9,(R10),W^SUBVALS-7[R0];SAVE THE NUMERIC VALUE
	CMPB	#^A\.\,-(R1)		;MAKE SURE IT'S DECIMAL
	BEQL	10$			;BRANCH IF IT IS
	MOVB	#^A\.\,(R3)+		;FORCE THE PERIOD
10$:	CLRB	(R3)+			;MAKE IT ASCIZ
	MOVL	#1,R0			;SET R0 TO INDICATE KEYWORD LOOP
	RSB				;RETURN FOR NEXT SUBFIELD KEYWORD

20$:	POPR	#^M<R0>			;CLEAN STACK AND CLEAR R0
	JSB	@(SP)+			;CALL BACK TO GET LIST SIZE
	CLRL	R9			;START AT FIRST SUBFIELD
30$:	MOVAQ	W^SUBVALS[R9],R10	;POINT TO NEXT FIELD
	BRB	50$			;JUMP INTO LOOP
40$:	BSBW	ADDCHAR			;PUT THE CHARACTER IN
50$:	MOVB	(R10)+,R7		;GET A CHARACTER
	BNEQ	40$			;BRANCH IF AT END OF STRING
	AOBLSS	R6,R9,30$		;LOOP THROUGH THE SUB FIELDS
	RET				;RETURN BACK TO CLI PARSER-CLEAN STACK

60$:	ERROR	KEYVALOVR,FATAL		;ABORT ON ERROR
70$:	ERROR	MISSNGVAL,FATAL		;ABORT ON ERROR


	.END
