	.TITLE	RSXTERMIN - IMAGE EXIT,TERMINATION AND ABORT ROUTINES
	.IDENT	'V03-002'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:
;
;	VAX/VMS RSX-11M AME
;
; ABSTRACT:
;
;	TERMINATION AND ABORT ROUTINES
;
; AUTHOR: R.HEINEN 4-NOV-76
;
; PREVIOUSLY MODIFIED BY:
;
;	Tim Halvorsen
;
; MODIFIED BY:
;
;	V001	MSH026		Michael S. Harvey	22-Mar-82
;		Eliminate dependencies on VMS Executive symbols.
;
;	V002	MSH025		Michael S. Harvey	25-Mar-82
;		Clean up unsolicited and control/c AST control
;		blocks for terminal LUTs.
;
;--
	
;
; EXTERNAL SYMBOLS
;
	$RSXDEF			; DEFINE RSX SYMBOLS
	LBLDF$			; DEFINE LABEL FOR RSX11M TASK IMAGES
	$STSDEF			; STATUS CODE DEFINITIONS
	$FABDEF			; DEFINE FAB
	$RABDEF			; DEFINE RAB
 

	.SBTTL	OUTPUT STRINGS
 
	.PSECT	RSXPURE,EXE,NOWRT,LONG,SHR,PIC
 
;
; REGISTER NAME LINES
;
PCM:	.ASCIZ	<2>/PC/
PSM:	.ASCIZ	<2>/PS/
R0M:	.ASCIZ	<2>/R0/
R1M:	.ASCIZ	<2>/R1/
R2M:	.ASCIZ	<2>/R2/
R3M:	.ASCIZ	<2>/R3/
R4M:	.ASCIZ	<2>/R4/
R5M:	.ASCIZ	<2>/R5/
SPM:	.ASCIZ	<2>/SP/

	.SBTTL	RSX$FORCEEXIT/RSX$RETEXIT - TERMINATION HANDLERS
 
;++
	.PSECT	RSXCODE,NOWRT,SHR,PIC
; RSX$FORCEEXIT - FORCE EXIT TERMINATION HANDLER FOR THE RSX
; RSX$RETEXIT - NULL EXIT HANDLER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS CALLED WHEN THIS IMAGE IS TO BE EXITED AS DIRECTED
; FROM AN EXTERNAL SOURCE. THE ACTION IS TO CAUSE A TERMINATION MESSAGE
; SET ON THE ERROR DEVICE.
;
; INPUTS:
;
; OUTPUTS:
;
;	CONTROL IS PASSED TO THE RSX TERMINATION ROUTINES
;	REASON = AB_ABORT
;--
RSX$FORCEEXIT::				; ABORTED IMAGE EXECUTION
	.WORD	0
	MOVL	G^SYS$GL_CMCNTX,R10	; ADDRESS IMPURE DATA AREA
	CLRL	I_BAILOUTFP(R10)	; SET NO RETURN ADDRESS
	BRW	RSX$EXIT		; EXIT WITH SUCCESS (NO MESSAGE)

RSX$RETEXIT::				; NO ACTION EXIT HANDLER
	.WORD	0
	RET				; RETURN TO CALLER

	.SBTTL	RSX$ABORT - ABORT IMAGE EXECUTION
;++
; RSX$ABORT - ABORT EXECUTION AS A RESULT OF AN UNVECTORED CM TRAP OR RSX ERROR
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED AS A RESULT OF AN UNVECTORED CM TRAP OR AN ERROR
; IN THE EXECUTION OF THE RSX.
;
; INPUTS:	
;
;	R0 = ABORT CODE
;	R10 = ADDRESS OF THE IMAGE DATA BASE
;	R11 = ADDRESS OF THE IMAGE HEADER
;
; OUTPUTS:
;
;  THE RSX CALLER IS RETURNED TO WITH R0 SIGNALING THE ERROR.
;--
ACCVIO:
	$EXIT_S	R9			; EXIT WITH OUT MESSAGE
RSX$ABORT::				; ABORT A CM IMAGE
	MOVAB	W^RSX$RETEXIT,W^RSX$A_EXITBLOCK+4; CHANGE ADDRESS OF EXIT
	MOVL	R0,R9			; COPY ABORT REASON
	BISW	#^X08000,R9		; SET MESSAGE TAKEN CARE OF
	MOVL	G^SYS$GL_CMCNTX,R10	; ADDRESS IMPURE DATA AREA
;
; OUTPUT HEADER MESSAGE
;
	PUSHL	#0
	PUSHL	R9
	PUSHL	#2
	CLRQ	-(SP)
	PUSHAB	8(SP)
	CALLS	#3+3,@#SYS$PUTMSG
;
; OUTPUT NAME OF IMAGE MESSAGE
;
	PUSHL	#0			; ADDRESS OF TIME/DATE (USE CURRENT)
	PUSHAB	I_ASCIINAME(R10)	; ADDRESS NAME STRING
	PUSHL	#2
	PUSHL	#RSX$_IMAGETERM		; SET MESSAGE ID
	PUSHL	#4
	CLRQ	-(SP)
	PUSHAB	8(SP)
	CALLS	#3+5,@#SYS$PUTMSG	; OUTPUT TERMINATION MESSAGE
;
; OUTPUT PC
;
	MOVAB	W^PCM,R3		; ADDRESS SPECIFIC MESSAGE
	MOVAB	I_PC(R10),R4		; ADDRESS DATA
	BSBB	50$			; OUTPUT IT
;
; OUTPUT THE PSL
;
	CMPL	(R3)+,(R4)+
	BSBB	50$			; 
;
; OUTPUT THE REGISTERS
;
	MOVAB	W^R0M,R3		; ADDRESS NORMAL REGISTER MESSAGES
	MOVL	G^SYS$GL_CMCNTX,R4	; ADDRESS REGISTER CONTENTS
20$:	BSBB	50$			; OUTPUT THE LINE
	TSTL	(R4)+
	CMPL	(R3)+,W^SPM		; REGISTER 6 DONE?
	BNEQ	20$			; IF NEQ THEN NO
;
; COMPLETE THE OPERATION BY EXITING
;
40$:	BBSS	#STS$V_INHIB_MSG,R9,41$	; SIGNAL MESSAGE ALREADY OUTPUT
41$:	BITW	#TS$PMD,I_STATE+2(R10)	; PMD REQUEST?
	BEQL	45$			; IF EQL THEN NO
	BSBW	RSX$PMD			; PMD THE IMAGE
45$:	$ABORT	R9			; EXIT THE IMAGE
;
; UTILITY OUTPUT SUBROUTINE
;
50$:	PUSHL	(R4)
	PUSHL	(R4)
	PUSHL	R3
	PUSHL	#3
	PUSHL	#RSX$_REGMSG
	PUSHL	#5+<1@16>		; SHOW ONLY MESSAGE TEXT, NO PREFIX
	CLRQ	-(SP)
	PUSHAB	8(SP)
	CALLS	#3+6,@#SYS$PUTMSG
	RSB

	.SBTTL	RSX$EXST - EXIT WITH STATUS
;++
; RSX$EXST - RSX11M EXIT WITH STATUS DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IMPLEMENTS THE RSX11M EXIT WITH STATUS DIRECTIVE.
;
; CALLING SEQUENCE:
;
;	CALLED VIA CASE FROM RSXEXCEPT.
;
; INPUTS:
;
;	R5 = ADDRESS OF THE DPB
;	R6 = ADDRESS OF THE IMAGE STACK
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	R10,R11 ARE PRESERVED.
;
;--
RSX$EXST::				; EXIT WITH STATUS
	MOVL	#RSX$_EXITSTATUS,R0	; SET ERROR CODE
	BICW3	#^X0FFF8,(R5),R1	; GET HIS EXIT STATUS
	BISB	R1,R0			; SET THE ERROR
	BBCS	#STS$V_INHIB_MSG,R0,10$	; MARK MESSAGE NOT TO BE DISPLAYED
10$:	$ABORT	R0			; EXIT THE IMAGE

	.SBTTL	RSX$EXIT - EXIT
;++
; RSX$EXIT - RSX11M EXIT DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IMPLEMENTS THE RSX11M EXIT DIRECTIVE.
;
; CALLING SEQUENCE:
;
;	CALLED VIA CASE FROM RSXEXCEPT.
;
; INPUTS:
;
;	R5 = ADDRESS OF THE DPB
;	R6 = ADDRESS OF THE IMAGE STACK
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	R10,R11 ARE PRESERVED.
;
;--
RSX$EXIT::				; EXIT
	MOVZBL	#SS$_NORMAL,R0		; SET SUCCESS

	.SBTTL RSX$INTERNEXIT - TERMINATE IMAGE EXECUTION
;++
; RSX$INTERNEXIT - TERMINATE IMAGE EXECUTION
;
; FUNCTIONAL DESCRIPION:
;
; THIS ROUTINE CLEANS UP THE EXECUTION OF THIS IMAGE AND RETURNS TO THE
; ORIGIONAL CALLER VIA RET.
; 
; INPUTS:
;
;	R0 = STATUS OF THE EXECUTION
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	ABORT MESSAGE IS DISPLAYED.
;
;	R0 = STATUS OF THE EXECUTION, WITH INHIB_MSG BIT SET
;--
RSX$INTERNEXIT::			; EXIT THE IMAGE
	MOVAB	W^RSX$RETEXIT,W^RSX$A_EXITBLOCK+4; CHANGE ADDRESS OF EXIT HANDLER
	MOVL	R0,R9			; COPY STATUS VALUE
	BLBS	R0,100$			; BRANCH IF SUCCESSFUL EXECUTION
	BBS	#STS$V_INHIB_MSG,R9,100$ ; SKIP IF MESSAGE ALREADY OUTPUT
	PUSHL	#0			; NUMBER OF FAO ARGUMENTS
	PUSHL	R9			; FINAL STATUS CODE
	PUSHL	#2			; NUMBER OF LONGWORDS IN MESSAGE VECTOR
	CLRQ	-(SP)
	PUSHAB	8(SP)			; ADDRESS OF MESSAGE VECTOR
	CALLS	#3+3,G^SYS$PUTMSG	; OUTPUT FINAL MESSAGE
	BBSS	#STS$V_INHIB_MSG,R9,100$ ; SET MESSAGE ALREADY DISPLAYED
;
; CLEAN UP THE COMMON EVENT FLAGS
;
100$:	$DACEFC_S	#95		; DISASSOCIATE WITH COMMON EVENT FLAGS
;
; DEASSIGN RECEIVE MAILBOX
;
	$DASSGN_S	I_RCVMAIL(R10)	; DEASSIGN CHANNEL TO MAILBOX
;
; SETUP FAB FOR CLOSING FILES USING RMS
;
	MOVAB	W^RSX$G_FAB,R6		; ADDRESS GENERAL FAB
	MOVC5	#0,(R6),#0,#FAB$C_BLN,(R6)
	MOVB	#FAB$C_BID,FAB$B_BID(R6)
	MOVB	#FAB$C_BLN,FAB$B_BLN(R6)
;
; DEASSIGN ALL ASSIGNED DEVICES
;
	MOVAB	I_LOGNAME(R10),R7	; ADDRESS LIST OF LOGICAL NAMES
	MOVL	(R7),R8			; ADDRESS FIRST ENTRY
	BEQL	20$			; IF EQL THEN NOT THERE YET
1$:	TSTW	LUT_TYPE(R8)		; RMS OR DEVICE?
	BEQL	5$			; IF EQL THEN RMS
	$DASSGN_S	LUT_CHAN(R8)	; DEASSIGN THE CHANNEL
	BRB	10$			; CONTINUE
5$:	MOVW	LUT_CHAN(R8),FAB$W_IFI(R6); SET UP FAB
	$CLOSE	FAB=(R6)
10$:	CLRL	LUT_CHAN(R8)		; SET NO CHANNEL
	CLRW	LUT_REF(R8)		; ZERO REFERENCE COUNT
	BSBW	RSX$DSABL_TTY		; DISABLE TERMINAL ASTS
15$:	MOVL	(R8),R8			; GET THE NEXT ENTRY
	CMPL	R8,R7			; DONE?
	BNEQ	1$			; IF NEQ THEN NO
;
; DEALLOCATE SPACE USED BY OVERLAY CACHE
;
20$:	MOVL	I_OVERLAYS(R10),I_SCRATCH(R10) ; STARTING ADDRESS OF SECTION
	BEQL	30$			; BRANCH IF NONE
	MOVL	I_OVERLEN(R10),R0	; PICK UP LENGTH OF SECTION
	BEQL	30$			; BRANCH IF NONE
	DECL	R0			; OFFSET TO LAST BYTE
	ADDL3	I_OVERLAYS(R10),R0,I_SCRATCH+4(R10) ; ENDING ADDRESS
	$DELTVA_S INADR=I_SCRATCH(R10)	; DELETE OVERLAY SECTION
;
; RESTORE PROCESS NAME BACK TO ORIGINAL NAME
;
30$:	MOVL	I_PROCNAME(R10),R1	; GET ADDRESS OF ASCIC PROCESS NAME
	BEQL	50$
	MOVZBL	(R1)+,I_SCRATCH(R10)	; SET DESCRIPTOR OF NAME
	MOVL	R1,I_SCRATCH+4(R10)
	$SETPRN_S I_SCRATCH(R10)	; RESET PROCESS NAME
	MOVL	I_PROCNAME(R10),R0	; GET ADDRESS OF BUFFER
	MOVL	#17,R1			; SET LENGTH OF BUFFER
	BSBW	RSX$DEALLOCATE		; DEALLOCATE PROCESS NAME STORAGE
	CLRL	I_PROCNAME(R10)		; MARK DEALLOCATED
;
; RETURN TO ORIGINAL CALLER
;
50$:	MOVL	R9,R0			; SET UP STATUS
	MOVL	I_BAILOUTFP(R10),R1	; SET UP ORIGIONAL FP
	BEQL	90$			; IF EQL THEN FORCE EXIT DONE
	MOVL	R1,FP			; RESET FP
90$:	RET				; RETURN
;
	.END	
