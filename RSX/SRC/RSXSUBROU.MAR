	.TITLE	RSXSUBROUTINES
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:
;
;	VAX/VMS RSX-11M AME
;
; ABSTRACT:
;
; 	THIS MODULE CONTAINS UTILITY SUBROUTINES FOR THE RSX.
;
; AUTHOR: R. HEINEN 1-OCT-76 
;
; PREVIOUSLY MODIFIED BY:
;
;	Andrew C. Goldstein
;	T. Halvorsen
;
; MODIFIED BY:
;
;	V001	MSH015		Michael S. Harvey	28-Jan-82
;		Modify the VMS/RSX QIO status translation routine
;		to handle multiple types of I/O success statuses.
;
;--
 
;
; EXTERNAL SYMBOLS
;
	$RSXDEF			; DEFINE RSX SYMBOLS
	DRERR$			; DEFINE DIRECTIVE ERROR CODES
	IOERR$			; DEFINE I/O ERROR CODES
 

	.PSECT	RSXCODE,NOWRT,SHR,PIC
	.SBTTL	RSX$ASCIIR50 - CONVERT ASCII STRING TO RAD50
;++
; RSX$ASCIIR50 - CONVERT ASCII STRING TO RAD50
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE CONVERTS A ASCIZ STRING TO RAD50, PLACING THE RAD50
; VALUES IN A SPECIFIED BUFFER. DOT CAN BE LEGAL OR ILLEGAL.
;
; INPUTS:
;
;	R0 = 0 IF DOT ILLEGAL
;	R1 = ADDRESS OF THE ASCIZ STRING
;	R4 = ADDRESS TO PLACE THE RAD50
;	R6 = IMAGE STACK
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	R1 = ADDRESS OF THE TERMINATING CHARACTER
;	R4 = ADDRESS OF THE NEXT WORD IN THE OUTPUT BUFFER
;	
;	R5,R7,R8 ARE DISTROYED.
;	R6,R10,R11 ARE PRESERVED.
;--
RSX$ASCR503::				;
	BSBB	RSX$ASCR501		; CONVERT THREE WORDS
RSX$ASCR502::				;
	BSBB	RSX$ASCR501		; CONVERT TWO WORDS
RSX$ASCR501::				; CONVERT ONE WORD
	MOVZBL	#3,R8			; SET UP COUNTER
	CLRL	R5			; RESET ACCUM.
5$:	MOVZBL	(R1),R7			; GET THE CHARACTER
	BEQL	22$			; IF EQL THEN DONE
	SUBL	#32,R7			; SPACE OR LESS?
	BLSS	22$			; IF LESS THEN DONE
	BEQL	30$			; IF EQL THEN ADD ZERO
	SUBL	#48-32,R7		; ADJUST FOR NUMBERS
	BLSSU	15$			; IF LSS THEN TRY $ OR .
	CMPL	#9,R7			; IS IT A NUMBER?
	BGEQU	25$			; ADD DIRECTLY IF YES
	SUBL	#64-48,R7		; GET CHARACTERS
	BLSSU	22$			; IF LSS THEN ILLEGAL
	CMPL	#90-64,R7		; IN CHARACTER RANGE?
	BLSSU	22$			; IF LSSU THEN ILLEGAL
	BRB	30$
;
; CHARACTER MUST BE DOT OR $
;
15$:	CMPB	(R1),#^A/$/		; DOLLAR?
	BEQL	20$			; IF EQL THEN CONTINUE
	CMPB	(R1),#^A/./		; DOT?
	BNEQ	22$			; IF NEQ THEN ILLEGAL CHARACTER
	TSTL	R0			; DOT LEGAL?
	BEQL	22$			; IF EQL THEN NO
	MOVZBL	#28,R7			; SET DOT CODE
	BRB	30$			; AND CONTINUE
20$:	MOVZBL	#27,R7			; SET CODE FOR DOLLAR
	BRB	30$			; CONTINUE
22$:	CLRL	R7			; CONVERT ILLEGAL CHARACTERS TO BLANK
	BRB	35$			;
25$:	ADDL	#30,R7			; PLACE IN NUMERIC RANGE
30$:	INCL	R1			; POINT TO NEXT INPUT CHARACTER
35$:	MULL	#40,R5			; CONVERT
	ADDL	R7,R5			;
	SOBGTR	R8,5$			; CONTINUE
	MOVW	R5,(R4)+		; INSERT CONVERTED WORD
	RSB

	.SBTTL	CONVERT TASK NAME
;++
; RSX$CVTNAME  -  CONVERT TASK NAME
;
; FUNCTIONAL DESCRIPTION:
;
; CONVERT A RAD50 TASK NAME TO ASCII AND PUT THE RESULTANT STRING
; IN THE IMAGE SCRATCH AREA.
;
; INPUTS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = CM IMAGE STACK POINTER
;	R10 = IMAGE DATA BASE ADDRESS
;	R11 = IMAGE HEADER ADDRESS
;
; OUTPUTS:
;
;	R7 = SIZE OF THE RESULTANT STRING
;	R10,R10 ARE PRESERVED
;--
RSX$CVTNAME::
	MOVAB	I_SCRATCH+12(R10),R7	; ADDRESS TARGET PLACE
	MOVL	R7,I_SCRATCH(R10)	; SET UP FOR SIZE CALC
	MOVL	R7,I_SCRATCH+4(R10)	; SET UP DESCRIPTOR
	MOVL	R5,R4			; ADDRESS RAD50 BLOCK
	BSBB	RSX$R50CVT2		; CONVERT STRING
	SUBL3	I_SCRATCH(R10),R7,I_SCRATCH(R10); CALC SIZE
	RSB				; AND RETURN

	.SBTTL	CONVERT RAD50 TO ASCII
;++
; RSX$R50CVTN - CONVERT RAD50 TO ASCII
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE CONVERTS A VARRIABLE NUMBER OF WORDS OF RAD50 TO AN ASCII STRING.
;
; CALLING SEQUENCE:
;
;	BSBW	RSX$R50ASCII
;
;
; INPUT PARAMETERS:
;
;	R4 = RAD50 BLOCK ADDRESS
;	R7 = ADDRESS OF TARGET STRING
;
; OUTPUT PARAMETERS:
;
;	R4 = POINTER TO NEXT WORD TO CONVERT
;	R7 = NEXT FREE BYTE IN TARGET STRING
;
; STRING IS IN STANDARD COUNT,TEXT FORMAT. BLANKS STOP THE CONVERTION.
;--
RSX$R50CVT3::				; CONVERT THREE WORDS
	MOVZWL	(R4)+,R0		; GET THE WORD
	BSBB	CVT			; CONVERT A WORD
RSX$R50CVT2::				; CONVERT TWO WORDS
	MOVZWL	(R4)+,R0		; GET WORD
	BSBB	CVT			; CONVERT A WORD
RSX$R50CVT1::				; CONVERT ONE WORD
	MOVZWL	(R4)+,R0		; GET THE WORD
CVT:	CLRL	R1			; SET HIGH HALF
	EDIV	#40,R0,R0,-(SP)		; GET REMAINDER FOR EACH CHARACTER
	EDIV	#40,R0,R0,-(SP)		;
	EDIV	#40,R0,R0,-(SP)		;
	CVTLB	(SP)+,(R7)		; CONVERT FIRST CHARACTER
	BSBB	50$			; 
	CVTLB	(SP)+,(R7)		; CONVERT SECOND CHARACTER
	BSBB	50$			; 
	CVTLB	(SP)+,(R7)		; CONVERT THIRD CHARACTER
50$:	TSTB	(R7)			; DONE?
	BEQL	DONE			; IF EQL THEN YES
	CMPB	#27,(R7)		; LETTER?
	BGTRU	60$			; IF EQL THEN YES
	BEQL	55$			; IF EQL THEN DOLLAR
	ADDB	#9,(R7)			;
55$:	ADDB	#-55,(R7)		;
60$:	ADDB	#32,(R7)		;
65$:	ADDB	#32,(R7)+		;
DONE:	RSB				;

	.SBTTL	MEMORY ALLOCATION SUBROUTINE
;++
; RSX$ALLOCATE - ALLOCATE MEMORY FROM DYNAMIC STORAGE POOL
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE ALLOCATES CORE BLOCKS FROM THE PER IMAGE CORE POOL
; WHICH IS RESIDENT JUST BELOW THE USER STACK. IF THE REQUIRED MEMORY
; IS NOT AVAILABLE, THEN A PAGE IS REQUESTED,LINKED INTO THE LIST AND
; THE OPERATION RETRIED.
;
; INPUTS:
;
;	R1 = SIZE OF BLOCK TO ALLOCATE
;	R10 = ADDRESS OF THE IMAGE DATA BASE
;	R11 = ADDRESS OF THE IMAGE HEADER
;
; OUTPUTS:
;
;	R0 = ADDRESS OF THE BLOCK ALLOCATED
;	R1 = SIZE OF ALLOCATED BLOCK
;	R8 = ADDRESS OF THE IMAGE REGISTER SAVE AREA
;	R10 = ADDRESS IF THE IMAGE DATA BASE
;	R11 = ADDRESS OF THE IMAGE HEADER
;--
RSX$ALLOCATE::				; ALLOCATE BLOCK
	ADDL	#7,R1			; ROUND BLOCK SIZE TO QUAD WORD
	BICL	#7,R1			;
	MOVAB	W^RSX$A_POOL,R0		; ADDRESS CORE POOL LIST HEAD
10$:	MOVL	R0,R2			; COPY CURRENT BLOCK ADDRESS
	MOVL	(R2),R0			; ADDRESS NEXT BLOCK
	BEQL	100$			; IF EQUAL THEN FAILURE TO ALLOCATE
	CMPL	R1,4(R0)		; IS THE NEXT BLOCK LARGE ENOUGH?
	BGTRU	10$			; IF GTRU THEN NO
	BEQL	20$			; IF EQL THEN EXACT FIT
	SUBL	R1,4(R0)		; CALC NEW BLOCK SIZE
	ADDL	R0,R1			; CALC ADDRESS OF NEW NEXT ENTRY
	MOVL	(R0),(R1)		; INSERT LINK WORD
	MOVL	4(R0),4(R1)		; INSERT SIZE
	MOVL	R1,(R0)			; INSERT LINK TO FREE BLOCK
	SUBL	R0,R1			; CALC ALLOCATED SIZE
20$:	MOVL	(R0),(R2)		; LINK TO LIST
	RSB				; RETURN
;
; ALLOCATION FAILURE
;
100$:	PUSHR	#^M<R1,R3>		; SAVE NEEDED SIZE
	CLRQ	-(SP)
	MOVL	SP,R2
	$EXPREG_S	#2,(R2),,#0	; CREATE THE SPACE
	BLBC	R0,120$			; IF LOW CLEAR THEN FAILURE
	MOVZWL	#1024,R1		; SET SIZE OF BLOCK
	MOVL	(R2),R0			; ADDRESS BLOCK
	BSBB	RSX$DEALLOCATE		; DEALLOCATE IT TO POOL
	POPR	#^M<R1,R2>		; REMOVE RETURN DATA
	POPR	#^M<R1,R3>		; RESTORE SIZE
	BRB	RSX$ALLOCATE		; TRY AGAIN
;
; FAILURE TO ALLOCATE ADDITIONAL SPACE
;
120$:	$ABORT	#RSX$_INSFDYNMEM	; ABORT IMAGE - OUT OF SPACE

	.SBTTL	DEALLOCATE MEMORY BLOCK
;++
; RSX$DEALLOCATE - DEALLOCATE MEMORY BLOCK TO CORE POOL
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE RETURNS ALLOCATED STORAGE TO THE PER IMAGE CORE POOL.
;
; INPUTS:
;
;	R0 = ADDRESS OF BLOCK TO RETURN
;	R1 = SIZE OF BLOCK TO RETURN
;	R8 = ADDRESS OF THE IMAGE REGISTER SAVE AREA
;	R10 = ADDRESS OF THE IMAGE DATA BASE
;	R11 = ADDRESS OF THE IMAGE HEADER
;
; OUTPUTS:
;
;	R8 = ADDRESS OF THE IMAGE REGISTER SAVE AREA
;	R10 = ADDRESS OF THE IMAGE DATA BASE
;	R11 = ADDRESS OF THE IMAGE HEADER
;--
RSX$DEALLOCATE::			; DEALLOCATE MEMORY
	ADDL	#7,R1			; ROUND BLOCK SIZE
	BICL	#7,R1			;
	MOVAB	W^RSX$A_POOL,R3		; ADDRESS LIST HEAD
10$:	MOVL	R3,R2			; ADDRESS NEXT ENTRY
	MOVL	(R2),R3			; COPY LINK WORD
	BEQL	20$			; IF EQL THEN END OF LIST
	CMPL	R0,R3			; DEALLOCATE HERE?
	BGEQU	10$			; IF GEQU THEN NO
20$:	MOVL	R3,(R0)			; ASSUME NO AGLOMERATION
	ADDL3	R0,R1,-(SP)		; CALC END OF BLOCK ADDRESS
	CMPL	R3,(SP)+		; AGLOMERATE?
	BNEQ	30$			; IF NEQ THEN NO
	MOVL	(R3)+,(R0)		; SAVE LINK TO NEXT
	ADDL	(R3),R1			; CALC NEW SIZE
30$:	PUSHL	R2			; CALC ADDRESS OF BLOCK
	MOVL	R0,(R2)+		; ASSUME NO AGLOMERATION
	ADDL	(R2),(SP)		; ADD IN SIZE
	CMPL	R0,(SP)+		; END EQUAL TO BLOCK RELEASED?
	BNEQ	40$			; IF YES THEN DONE
	ADDL	(R2),R1			; ACCUMULATE BLOCK SIZE
	MOVL	(R0),-(R2)		; MOVE LINK TO PREVIOUS
	MOVL	R2,R0			; ADDRESS NEW FREE BLOCK
40$:	MOVL	R1,4(R0)		; INSERT SIZE OF BLOCK
	RSB				; AND RETURN

	.SBTTL	CONVERT RSX11M TIME DATA TO DELTA TIME
;++
; RSX$TIMEMAG - CONVERT RSX11M TIME DATA TO DELTA TIME
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE CONVERTS AN RSX11M TIME SPECIFICATION OF UNITS AND
; MAGNITUDE TO A DELTA TIME QUAD WORD.
;
; INPUT:
;
;	R0 = TIME UNITS (1-4)
;	R2 = TIME MAGNITUDE
;	R10 = ADDRESS OF THE IMAGE DATA BASE
;	R11 = ADDRESS OF THE IMAGE HEADER
;
; OUTPUTS:
;
;	R0,R1 = DELTA TIME QUAD WORD
;	R2 = INDICATION OF SUCCESS (LOW SET IS SUCCESS)
;
;	R10,R11 ARE PRESERVED.
;--
;
; LOCAL STORAGE
;
	.PSECT	RSXPURE,NOWRT,EXE,SHR,LONG,PIC
;
; MILLISECONDS PER UNIT TIME (TICKS, SECONDS, MINUTES, HOURS)
;
TICKS:	.LONG	10			; 10 MSECS PER TICK
	.LONG	1000			; 1000 MSECS IN A SECOND
	.LONG	60*1000			; 60*1000 MSECS IN A MIN.
	.LONG	60*60*1000		; 3600*1000 MSECS IN AN HOUR
;
; MAXIMUM MAGNITUDE PER UNIT TIME
;
MAX:	.WORD	1@15			; 15 BITS TICKS
	.WORD	1@15			; 15 BITS FOR SECOND
	.WORD	60*24			; MINUTE
	.WORD	24			; HOUR
 
	.PSECT	RSXCODE,NOWRT
 
RSX$TIMEMAG::				; CONVERT TIME TO DELTA TIME
	CMPL	R0,#4			; UNITS IN RANGE?
	BGTRU	30$			; IF GTRU THEN YES
	CMPW	R2,W^MAX-2[R0]		; IN RANGE?
	BGTRU	30$			; IF GTR THEN NO
	MULL	W^TICKS-4[R0],R2	; GET NUMBER OF MSECS
	EMUL	#-10000,R2,#0,R0	; CONV MSECS TO 100 NSEC (QUAD)
	MOVZBL	#1,R2			; SET SUCCESS
	RSB				; AND RETURN
;
; SET PARAM ERROR
;
30$:	CLRL	R2			; SET ERROR
	RSB				; AND RETURN

	.SBTTL	RSX$RSXQIOERR - MAP VAX/VMS I/O STATUS TO RSX
;++
; RSX$RSXQIOERR - MAP VAX/VMS I/O STATUS TO RSX
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE MAPS A VAX/VMS I/O STATUS VALUE TO A RSX VALUE
; BY TABLE LOOKUP.
;
; INPUTS:
;
;	R0 = VAX/VMS STATUS CODE
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	R0 = VAX/VMS STATUS CODE
;	R1 = RSX VALUE
;
;	R10,R11 ARE PRESERVED.
;--
RSX$RSXQIOERR::				; MAP VAX/VMS TO RSX STATUS VALUE FOR QIO
	MOVAB	W^RSX$A_RSXQIOSUC,R1	; ASSUME SUCCESS STATUS
	BLBC	R0,20$			; IF LBC, THEN ERROR STATUS
	BSBB	50$			; MAP THE SUCCESS STATUS
	BNEQ	5$			; IF NEQ, SUCCESSFUL MAPPING
	MOVZBL	#IS.SUC,R1		; SET DEFAULT SUCCESS STATUS
5$:	RSB				; RETURN CONVERTED CODE

20$:	MOVAB	W^RSX$A_RSXQIOERR,R1	; ADDRESS ERROR MAP TABLE
	BSBB	50$			; MAP THE ERROR STATUS
	BNEQ	25$			; IF NEQ, SUCCESSFUL MAPPING
	CVTWL	#IE.ICE,R1		; SET DEFAULT ERROR STATUS
25$:	RSB				; RETURN CONVERTED ERROR CODE

;
; TABLE SCANNING SUBROUTINE
;

50$:	CMPW	R0,(R1)+		; VMS STATUS CODE MATCHED?
	BEQL	55$			; IF EQL YES
	TSTW	(R1)+			; END OF TABLE?
	BNEQ	50$			; IF NEQ NO, CONTINUE SCAN
	RSB				; RETURN, STATUS NOT MATCHED

55$:	CVTWL	(R1),R1			; CONVERT STATUS TO RSX CODE
	RSB				; AND RETURN IT (NEVER ZERO)
;
	.END
