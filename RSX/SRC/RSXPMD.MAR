	.TITLE	RSXPMD - PMD ROUTINE FOR RSX11M AME
	.IDENT	'V03-001'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
;
; FACILITY:
;
;	VAX/VMS RSX-11M AME
;
; ABSTRACT:
;
;	PMD ROUTINE FOR IMAGE TERMINATION.
;
; AUTHOR: R.HEINEN 3-JUN-77
;
; PREVIOUSLY MODIFIED BY:
;
;	Michael S. Harvey
;
; MODIFIED BY:
;
;	V001	MSH026		Michael S. Harvey	22-Mar-82
;		Eliminate dependencies on VMS Executive symbols.
;
;--
;
; EXTERNAL DEFINITIONS
;
	$RSXDEF				; DEFINE INTERNAL RSX DEFINITIONS
;
; LOCAL STORAGE
;
;
	.PSECT	RSXIMPURE,LONG,EXE,NOSHR
;
; FAB AND RAB FOR OUTPUT FILE
;
PMDFAB:	$FAB	FAC=<PUT>,RAT=<CR>,DNA=DEFAUL,DNS=16,NAM=RESULT
PMDRAB:	$RAB	FAB=PMDFAB
RESULT:	$NAM	ESA=FILENAM,ESS=50
	.BLKB	1
FILENAM:	.BLKB	50
 
	.PSECT	RSXPURE,NOWRT,LONG,EXE,SHR,PIC
 
DEFAUL:	.ASCII	/SYS$DISK:PMD.PMD/
INPUTOUTPUT:	.ASCIC	\SYS$INPUT:/SYS$OUTPUT\
;
; MESSAGES FOR OUTPUT
;
FORM:	.BYTE	1,12		
HDRMSG:	.ASCIC	<13><10>/			POST-MORTEM DUMP/
LUNMSG:	.ASCIC	<13><10>/ LOGICAL UNIT   DEVICE/
OVLYMSG:.ASCIC	<13><10>/ OVERLAY SEGMENTS LOADED/<13><10>
STKMSG:	.ASCIC	<13><10>/ STACK  ADDRESS CONTENTS ASCII RAD50/
;
; FAO CONTROL STRINGS
;
NAMFAO:
	.ASCIC	<13><10>/ TASK: !AC				TIME: !%D/
PCFAO:
	.ASCIC	<13><10>/ PC: !OW	!AD/
REG1FAO:
	.ASCIC	<13><10>/ REGS:	RO - !OW  R1 - !OW  R2 - !OW  R3 - !OW/
REG2FAO:
	.ASCIC	/        R4 - !OW  R5 - !OW  SP - !OW  PS - !OW/
STSFAO:	.ASCIC	<13><10>/ TASK STATUS: /
EFNFAO:
	.ASCIC	<13><10>/ EVENT FLAGS: !OW !OW !OW !OW/
UICFAO:
	.ASCIC	<13><10>/ CURRENT DIRECTORY: !AS    DSW: !OW/
PRIFAO:
	.ASCIC	<13><10>/ PRIORITY:  !ZB/
LOAFAO:
	.ASCIC	<13><10>/ LOAD DEVICE - !AC:/
LUTFAO:
	.ASCIC	/        !OW  !AC:/
OVLYFAO:
	.ASCIC	/ STARTING RELATIVE BLOCK: !OW  BASE: !OW  LENGTH: !OW/
STKFAO:
	.ASCIC	/        !OW  !OW   !AF    !AC/
LIMFAO:
	.ASCIC	<13><10>/ VIRTUAL LIMITS: !OW - !OW/<13><10>
DMPFAO:
	.ASCIC	/ !OW  !OW  !OW  !OW  !OW   !! !AD!! !AF/
BYTFAO:
	.ASCIC	/        !OB !OB !OB !OB !OB !OB !OB !OB/
DUPFAO:
	.ASCIC	<13><10>/ DUPLICATE FROM !OW TO !OW/<13><10>

	.SBTTL	RSX$PMD - PMD EXITING IMAGE
 
	.PSECT	RSXCODE,NOWRT,SHR,PIC
;++
; RSX$PMD - PMD THE EXITING IMAGE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED DURING IMAGE EXIT IF AN ABORT HAS OCCURED 
; AND THE TASK HAS THE PMD ON EXIT BIT SET.
; A FILE IS CREATED THAT CONTAINS THE DUMP. THE FILE IS CALLED:
;
; DISK:[DIRECTORY]PROCESSNAME.PMD OR DISK:[DIRECTORY]INPUTDEVICE.PMD
;
; INPUTS:
;
;	R9 = RSX ABORT CODE
;	R10 = ADDRESS OF THE IMAGE IMPURE VECTOR
;
; OUPUTS:
;
;	R10 IS PRESERVED
;--
BAD_OPEN:	RSB
RSX$PMD::				; PMD THE CURRENT IMAGE
;
; OPEN PMD FILE
;
	MOVAB	I_ASCIINAME+1(R10),R1	; ADDRESS NAME
	MOVZBL	I_ASCIINAME(R10),R0	; GET NAME SIZE
	BEQL	12$			; IF EQL THEN NONE
	CMPB	#^A/_/,(R1)		; START WITH "_"?
	BNEQ	10$			; IF NEQ THEN OK
	INCL	R1			; POINT PAST IT
	DECL	R0			; AND ADJUST COUNT
	BEQL	12$			;
10$:	CMPB	-1(R1)[R0],#^A/:/	; END WITH ":"?
	BNEQ	12$			; IF NEQ THEN OK
	DECL	R0			; ADJUST SIZE
12$:	MOVL	R1,W^FAB$L_FNA+PMDFAB	;
	MOVB	R0,W^FAB$B_FNS+PMDFAB
	$CREATE	FAB=W^PMDFAB
	BLBC	R0,14$			; IF LOW CLEAR THEN RMS ERROR
	MOVL	#RSX$_PMD,R0		; ASSUME PMD MESSAGE
	BRB	15$			; CONTINUE
14$:	MOVL	#RSX$_NOPMD,R0		; SET FAILED PMD
15$:	PUSHAB	W^FILENAM		; SET UP RESULT NAME DESC
	MOVZBL	W^RESULT+NAM$B_ESL,-(SP);
	PUSHL	#2
	PUSHL	R0			; SET MESSAGE NUMBER
	PUSHL	#3+<15@16>
	CLRQ	-(SP)
	PUSHAB	8(SP)
	CALLS	#8,@#SYS$PUTMSG		; OUTPUT THE MESSAGE
	MOVAB	W^PMDRAB,R11		; ADDRESS RAB
	$CONNECT RAB=R11		; CONNECT RAB TO DATA STREAM
	BLBS	R0,16$			; IF LOW SET THEN SUCCESS
	BRW	BAD_OPEN		;
;
; OUTPUT HEADER
;
16$:	MOVAB	W^HDRMSG,R0		;
	BSBW	OUTPUT			; OUTPUT LINE
;
; OUTPUT NAME MESSSAGE
;
	MOVAB	I_SCRATCH(R10),R8	; ADDRESS DESCRIPTOR
	MOVAB	12(R8),4(R8)
	MOVZBL	#100,(R8)		;
	MOVAB	I_ASCIINAME(R10),R1	;
	MOVAB	W^NAMFAO,R0
	BSBW	SETFAO
	$FAO_S	(R0),8(R8),(R8),R1,#0
	BSBW	OUTFAO			; OUTPUT THE LINE
;
; OUTPUT PC MESSAGE
;
	MOVAB	I_SCRATCH+92(R10),R2	; ADDRESS DESC
	MOVZBL	#40,(R2)		;
	MOVAB	8(R2),4(R2)		;
	EXTZV	#0,#20,R9,R0		;
	$GETMSG_S	R0,(R2),(R2),#1
	MOVAB	W^PCFAO,R0
	BSBW	SETFAO
	$FAO_S	(R0),8(R8),(R8),I_PC(R10),(R2),4(R2)
	BSBW	OUTFAO
;
; OUTPUT THE REGISTERS
;
	MOVL	R10,R4
	MOVAB	W^REG1FAO,R0
	BSBW	SETFAO
	$FAO_S	(R0),8(R8),(R8),(R4),4(R4),8(R4),12(R4)
	BSBW	OUTFAO
	MOVAB	W^REG2FAO,R0
	BSBW	SETFAO
	$FAO_S	(R0),8(R8),(R8),16(R4),20(R4),24(R4),I_PS(R10)
	BSBW	OUTFAO		
;
; OUTPUT THE STATUS
;
	MOVAB	W^STSFAO,R2		; ADDRESS THE STATUS MESSAGE HEADER
	MOVZBL	(R2)+,R3		; GET ITS SIZE AND ADDRESS IT
	MOVC3	R3,(R2),I_SCRATCH+12(R10); COPY IT TO IMPURE STORAGE
;
; AST LEVEL?
;
	BBC	#SV_ASTLVL,I_STATE(R10),17$; BR IF NOT IS AST
	MOVL	#^A/AST /,(R3)+		; INSERT AST MESSAGE
;
; ASTS DISABLED?
;
17$:	BBC	#SV_NOAST,I_STATE(R10),18$; BR IF AST'S ENABLED
	MOVL	#^A/DST /,(R3)+		; INSERT CODE WORD
;
; WAIT FOR IN PROGRESS?
;
18$:	BBC	#SV_WAIT,I_STATE(R10),20$; BR IF NOT IN WAIT
	MOVL	#^A/WFR /,(R3)+		; INSERT CODE WORD
20$:	SUBL3	I_SCRATCH+4(R10),R3,I_SCRATCH+8(R10); INSERT PROPER SIZE
	BSBW	OUTFAO			; OUTPUT THE LINE
;
; OUTPUT THE EVENT FLAGS
;
	CLRL	I_SCRATCH+104(R10)	; SET COMMONS TO 0 IN CASE NONE PRESENT
	$READEF_S	#32,I_SCRATCH+100(R10)
	$READEF_S	#64,I_SCRATCH+104(R10)
	MOVAB	W^EFNFAO,R0
	BSBW	SETFAO
	$FAO_S	(R0),8(R8),(R8),I_SCRATCH+100(R10),I_SCRATCH+102(R10),-
			I_SCRATCH+104(R10),I_SCRATCH+106(R10)
	BSBW	OUTFAO
;
;
; OUTPUT THE DIRECTORY AND DSW
;
	SUBL2	#40,SP			; GET SCRATCH SPACE ON STACK
	MOVL	#32,(SP)		; LENGTH OF SCRATCH STRING
	MOVAB	8(SP),4(SP)		; COMPLETE STRING DESCRIPTOR
	MOVL	SP,R4			; POINT TO STRING DESCRIPTOR
	PUSHAB	(SP)			; POINT TO STRING DESC, AGAIN
	PUSHL	(SP)			; COPY IT
	CLRL	-(SP)			;
	CALLS	#3,G^SYS$SETDDIR	; ACCESS UIC STRING
	MOVAB	W^UICFAO,R0
	BSBW	SETFAO
	$FAO_S	(R0),8(R8),(R8),R4,H.DSW
	BSBW	OUTFAO
	ADDL2	#40,SP			; CLEAN STACK
;
; OUTPUT THE PRIORITY
;
	MOVAB	W^PRIFAO,R0
	BSBW	SETFAO
	$FAO_S	(R0),8(R8),(R8),H.SPRI
	BSBW	OUTFAO
;
; OUTPUT THE LOAD DEVICE
;
	MOVAB	W^RSX$A_OVDEV+LUT_REALNAME,R4
	MOVAB	W^LOAFAO,R0
	BSBW	SETFAO
	$FAO_S	(R0),8(R8),(R8),R4,-
				I_IMAGEVBN+2(R10),-
				I_IMAGEVBN(R10)
	BSBW	OUTFAO
;
; OUTPUT LUT STATUS
;
	MOVAB	W^LUNMSG,R0		;
	BSBW	OUTPUT
	MOVZWL	I_NLUN(R10),R6		; GET NUMBER OF LUTS
	BEQL	35$			; IF EQL THEN NONE
	MOVZBL	#1,R4			; START WITH LUN 1
25$:	MOVL	@I_LUT(R10)[R4],R5	; GET LUT ENTRY
	BEQL	30$			; IF EQL THEN NOT ASSIGNED
	MOVAB	LUT_REALNAME(R5),R3	;
	CMPW	#^A/TI/,LUT_RSXNAME(R5)	; TI?
	BNEQ	28$			; IF NEQ THEN NO
	MOVAB	W^INPUTOUTPUT,R3	; OUTPUT ALTERNATE STRING
28$:	MOVAB	W^LUTFAO,R0
	BSBW	SETFAO
	$FAO_S	(R0),8(R8),(R8),R4,R3
	BSBW	OUTFAO
30$:	INCL	R4			; NEXT LUN
	SOBGTR	R6,25$			; CONTINUE UNTIL DONE
35$:	
;
; OUTPUT STATUS OF OVERLAYS
;
	MOVAB	W^OVLYMSG,R0		; OUTPUT OVERLAY HEADER
	BSBW	OUTPUT			;
	MOVZWL	@#H.OVLY,R2		; ADDRESS OVERLAY IMPURE AREA
	BEQL	47$			; IF EQL THEN NO OVERLAYS
	MOVZWL	2(R2),R3		; ADDRESS SEGMENT DESC LIST
	MOVZWL	10(R2),R2		; GET SIZE OF DESC.
40$:	BBS	#12,(R3),45$		; LOADED?
	EXTZV	#0,#12,(R3),R4		; GET BLOCK ADDRESS
	ADDL2	I_IMAGEVBN(R10),R4	; COMPUTE VIRTUAL BLOCK NUMBER
	DECL	R4			; CALC. RELATIVE BLOCK OFFSET
	MOVAB	W^OVLYFAO,R0
	BSBW	SETFAO
	$FAO_S	(R0),8(R8),(R8),R4,2(R3),4(R3); FORMAT
	BSBW	OUTFAO
45$:	ADDL	R2,R3			; POINT TO NEXT ENTRY
	TSTW	(R3)			; PRESENT?
	BNEQ	40$			; IF NEQ THEN YES
;
; OUTPUT THE STACK
;
47$:	MOVAB	W^STKMSG,R0		;
	BSBW	OUTPUT
	MOVL	I_R6(R10),R4		; GET CURRENT STACK ADDRESS
50$:	MOVAB	I_SCRATCH+101(R10),R7	; ADDRESS RAD50 TARGET
	MOVL	R7,R6			; COPY BUFFER ADDRESS
	BSBW	RSX$R50CVT1		; CONVERT TO RAD50
	TSTW	-(R4)			; POINT TO PREVIOUS
	SUBL3	R6,R7,R0		; GET SIZE
	MOVB	R0,-(R6)		; INSERT
	MOVAB	W^STKFAO,R0
	BSBW	SETFAO
	$FAO_S	(R0),8(R8),(R8),R4,(R4),#2,R4,R6
	BSBW	OUTFAO
	TSTW	(R4)+			; POINT TO NEXT WORD
	CMPW	R4,H.ISP		; DONE?
	BLEQ	50$			; COMPLETE
;
; OUTPUT THE IMAGE
;
	MOVAB	I_ADR0(R10),R6		; DO ADR 0
60$:	BSBB	DUMP			; OUTPUT IT
	ADDL	#ADR_SIZE,R6		; ADDRESS NEXT DESC
	TSTL	(R6)			; IN USE
	BNEQ	60$			; IF NEQ THEN YES
;
; CLOSE FILE
;
70$:	$DISCONNECT RAB=R11
	$CLOSE	FAB=W^PMDFAB		;
RESET:	RSB				; RETURN
;
; MEMORY DUMP SUBROUTINE
;
DUMP:
	MOVAB	W^FORM,R0		; FORM FEED
	BSBW	OUTPUT			;
;
; OUTPUT THE IMAGE LIMITS
;
	MOVZWL	ADR_LOWLIM(R6),R4
	IFNORD	#8,(R4),RESET		; SKIP IF NO READ ALLOWED
	MOVZWL	ADR_HIGHLIM(R6),R1
	MOVAB	W^LIMFAO,R0
	BSBW	SETFAO
	$FAO_S	(R0),8(R8),(R8),R4,R1
	BSBW	OUTFAO
;
; LOOP TO OUTPUT IMAGE
;
	MOVL	R4,R5			; COPY ADDRESS FOR DUPLICATE TEST
20$:	MOVAB	I_SCRATCH+100(R10),R7	; ADDRESS PLACE TO PUT RAD50
	IFNORD	#8,(R4),RESET		; AND STOP ON NO ACCESS
	PUSHR	#^M<R4,R5>		; SAVE VA AND COMPARISON
	MOVC5	#0,(R7),#32,#20,(R7)	; BLANK AREA
	MOVL	(SP),R4			; RESTORE SOURCE ADDRESS
	PUSHL	R7			; SAVE RAD50 BUFFER ADDRESS
	BSBW	RSX$R50CVT1		; CONVERT DUMP TO RAD50
	MOVB	#^A/ /,(R7)		;
	ADDL3	#4,(SP),R7		;
	BSBW	RSX$R50CVT1		;
	MOVB	#^A/ /,(R7)		;
	ADDL3	#8,(SP),R7		;
	BSBW	RSX$R50CVT1		;
	MOVB	#^A/ /,(R7)		;
	ADDL3	#12,(SP),R7		;
	BSBW	RSX$R50CVT1		;
	MOVB	#^A/ /,(R7)		;
	POPR	#^M<R1,R4,R5>		; RESTORE VA AND R50 ADDRESS
	MOVAB	W^DMPFAO,R0
	BSBW	SETFAO
	$FAO_S	(R0),8(R8),(R8),-
		R4,-
		(R4),-
		2(R4),-
		4(R4),-
		6(R4),-
		#20,R1,-
		#8,R4
	BSBW	OUTFAO
	MOVAB	W^BYTFAO,R0
	BSBW	SETFAO
	$FAO_S	(R0),8(R8),(R8),-
		(R4),1(R4),-
		2(R4),3(R4),-
		4(R4),5(R4),-
		6(R4),7(R4)
	BSBW	OUTFAO
60$:	MOVL	R4,R3
	CMPL	(R4)+,(R4)+		; POINT TO NEXT GROUP
	CMPW	R4,ADR_HIGHLIM(R6)	; DONE?
	BGEQU	80$			; IF GEQU THEN YES
	IFNORD	#8,(R4),90$		; SKIP COMPARE IF NO READ
	CMPL	(R4),(R5)		; NEXT GROUP A DUPLICATE?
	BNEQ	70$			; IF NEQ THEN NO
	CMPL	4(R4),4(R5)		;
	BEQL	60$			; IF EQL THEN KEEP SEARCHING
70$:	CMPL	R3,R5			; ONE LINE DIFFERENCE?
	BEQL	75$
	BSBB	85$			; OUTPUT DUPLICATE MESSAGE
75$:	MOVL	R4,R5			; SET NEW TEST ADDRESS
	BRW	20$			; DUMP THIS SECTION
;
; END CONDITION ON DUPLICATE?
;
80$:	CMPL	R3,R5			; SAME?
	BEQL	90$			; IF EQL THEN DONE
;
; OUTPUT DUPLICATE MESSAGE
;
85$:	MOVAB	W^DUPFAO,R0
	BSBW	SETFAO
	$FAO_S	(R0),8(R8),(R8),R5,R4
	BSBW	OUTFAO
90$:	RSB				;
;
;
; UTILITY SUBROUTINES
;
OUTFAO:					;
	MOVAB	12(R8),RAB$L_RBF(R11)	;
	MOVW	8(R8),RAB$W_RSZ(R11)
	BRB	OUT
OUTPUT:	MOVZBW	(R0)+,RAB$W_RSZ(R11)	;
	MOVL	R0,RAB$L_RBF(R11)
OUT:	$PUT	RAB=R11
	RSB				; IGNORE ERRORS
;
; BUILD FAO DESC
;
SETFAO:					;
	MOVZBL	(R0)+,I_FLOATCSR(R10)
	MOVL	R0,I_FLOATCSR+4(R10)
	MOVAB	I_FLOATCSR(R10),R0
	RSB
	.END	
