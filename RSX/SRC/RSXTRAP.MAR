	.TITLE	RSXTRAP - RSX11M TRAP ASSOCIATED DIRECTIVES
	.IDENT	'V03-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:
;
;	VAX/VMS RSX AME.
;
; ABSTRACT:
;
;	RSX11M TRAP ASSOCIATED DIRECTIVES.
;
; AUTHOR:
;
;	R.HEINEN 4-NOV-76
;
; MODIFIED BY:
;
; 101	TIM HALVORSEN 10-DEC-1978
;	FIX SRDA$S TO RETURN IE.AST IF ALREADY ENABLED.
;	FIX AST ENABLES TO NOT SET CARRY ON IO$_SETMODE SUCCESS.
;--
;
; EXTERNAL SYMBOLS
;
	$RSXDEF			; DEFINE RSX SYMBOLS
	DRERR$			; DEFINE RSX11M DIRECTIVE STATUS CODES
 

	.PSECT	RSXCODE,NOWRT,SHR,PIC
	.SBTTL	RSX$DSAR - RSX11M DSAR$ DIRECTIVE
;++
; RSX$DSAR - RSX11M DISABLE AST RECOGNITION DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS A RSX DIRECTIVE HANDLER WHICH IMPLEMENTS AN RSX11M
; "DSAR$" DIRECTIVE.
;
; INPUT PARAMETERS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = CM IMAGE STACK ADDRESS
;	R10 = ADDRESS OF CM IMAGE DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUT PARAMETERS:
;
;	R10,R11 ARE PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	THE PROPER DIRECTIVE STATUS IS PLACED IN THE IMAGE DSW
;	ALONG WITH THE PROPER SETTING OF THE C-BIT.
;
; DSW RETURN CODES:
;
;	IS.SUC	SUCCESSFUL
;	IE.ITS	AST'S ALREADY DISABLED
;--
RSX$DSAR::				; DISABLE AST RECOGNITION DIRECTIVE
	BBC	#SV_NOAST,I_STATE(R10),10$; BR IF AST'S NOT ALREADY DISABLED
;
; AST'S ALREADY DISABLED
;
	$DSW	#IE.ITS			; SET DSW AND RETURN
;
; DISABLE AST'S
;
10$:	BBSSI	#SV_NOAST,I_STATE(R10),15$; SET AST'S DISABLED
15$:	RSB				; AND RETURN

	.SBTTL	RSX$ENAR - RSX11M ENAR$ DIRECTIVE
;++
; RSX$ENAR - RSX11M ENABLE AST RECOGNITION DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS A RSX DIRECTIVE HANDLER WHICH IMPLEMENTS AN RSX11M
; "ENAR$" DIRECTIVE.
;
; INPUT PARAMETERS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = CM IMAGE STACK ADDRESS
;	R10 = ADDRESS OF CM IMAGE DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUT PARAMETERS:
;
;	R10,R11 ARE PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	THE PROPER DIRECTIVE STATUS IS PLACED IN THE IMAGE DSW
;	ALONG WITH THE PROPER SETTING OF THE C-BIT.
;
; DSW RETURN CODES:
;
;	IS.SUC	SUCCESSFUL
;	IE.ITS	AST'S ALREADY ENABLED
;--
RSX$ENAR::				; ENABLE AST RECOGNITION DIRECTIVE
	BBS	#SV_NOAST,I_STATE(R10),10$; IF ALREADY ENABLED THEN ERROR
;
; AST'S ALREADY ENABLED
;
5$:	$DSW	#IE.ITS			; SET DSW AND RETURN
;
; ENABLE AST'S
;
10$:	BBCCI	#SV_NOAST,I_STATE(R10),15$; SET AST'S ENABLED
15$:	BISW	#1@SV_PENDWAIT,I_STATE(R10); FORCE AST SEARCH ON EXIT
	RSB

	.SBTTL	RSX$SFPA - RSX11M SFPA$ DIRECTIVE
;++
; RSX$SFPA - RSX11M SPECIFY FLOATING EXCEPTION AST
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS A RSX DIRECTIVE HANDLER WHICH IMPLEMENTS AN RSX11M
; "SFPA$" DIRECTIVE.
;
; INPUT PARAMETERS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = CM IMAGE STACK ADDRESS
;	R10 = ADDRESS OF CM IMAGE DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUT PARAMETERS:
;
;	R10,R11 ARE PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	THE PROPER DIRECTIVE STATUS IS PLACED IN THE IMAGE DSW
;	ALONG WITH THE PROPER SETTING OF THE C-BIT.
;
; DSW RETURN CODES:
;
;	IS.SUC	SUCCESSFUL
;	IE.ITS	AST ALREADY UNSPECIFIED
;
;--
RSX$SFPA::				; SPECIFY FLOATING EXCEPTION AST
	BBS	#SV_NOAST,I_STATE(R10),10$; BR IF AST'S DISABLED
	BLBS	(R5),5$			; BR IF ODD
	MOVZWL	(R5),R4			; GET USER AST ADDRESS
	BNEQ	15$			; IF NEQ THEN ENABLING
;
; DISABLE FUNCTION
;
	BBCCI	#SV_FLOATAST,I_STATE(R10),10$; BR IF DISABLED AND DISABLE
	RSB				; RETURN
5$:	$DSW	#IE.ADP			;
10$:	$DSW	#IE.ITS			; ALREADY DISABLED
;
; ENABLE THE AST
;
15$:	IFNORD	#2,(R4),5$		; PROBE THE ADDRESS
	BBSSI	#SV_FLOATAST,I_STATE(R10),10$; BR IF ENABLED AND ENABLE
	MOVL	I_FLOATAST(R10),R2	; GET PRESENT BLOCK
	BEQL	20$			; IF EQL THEN GET A NEW ONE
;
; IF THE BLOCK HAS ALREADY BEEN ALLOCATED, IT IS POSSIBLE THAT THE AST
; HAS NOT BEEN DELIVERED. IF THIS IS THE CASE THEN THE ENABLE WILL
; BE DONE ON AST EXIT.
;
	BBC	#ACBV_INPROG,ACB_FLAGS(R2),25$; BR IF NOT IN PROGRESS
	RSB				; ELSE RETURN SUCCESS
;
; ALLOCATE A CONTEXT BLOCK
;
20$:	BSBW	RSX$SETUPAST		; SET UP THE AST CONTEXT
;
; SET UP AST CONTEXT BLOCK
;
25$:	MOVL	R2,I_FLOATAST(R10)	; SAVE ADDRESS OF BLOCK
	MNEGW	#1,ACB_UPRM(R2)		; SET NO OPTIONAL DATA
	MOVW	R4,ACB_UPC(R2)		; SAVE AST ADDRESS
	MOVW	#<1@ACBV_PERM>+<ACBC_FLOATAST@ACBV_TYPE>,ACB_FLAGS(R2); SET UP FLAGS WORD
	RSB				; DONE

	.SBTTL	RSX$SPRA - RSX11M SPRA$ DIRECTIVE
;++
; RSX$SPRA - RSX11M SPECIFY POWER RECOVERY AST DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS A RSX DIRECTIVE HANDLER WHICH IMPLEMENTS AN RSX11M
; "SPRA$" DIRECTIVE.
;
; INPUT PARAMETERS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = CM IMAGE STACK ADDRESS
;	R10 = ADDRESS OF CM IMAGE DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUT PARAMETERS:
;
;	R10,R11 ARE PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	THE PROPER DIRECTIVE STATUS IS PLACED IN THE IMAGE DSW
;	ALONG WITH THE PROPER SETTING OF THE C-BIT.
;
; DSW RETURN CODES:
;
;	IS.SUC	SUCCESSFUL
;	IE.ITS	AST ALREADY UNSPECIFIED
;
;--
RSX$SPRA::				; SPECIFY POWER RECOVERY AST DIRECTIVE
	BBS	#SV_NOAST,I_STATE(R10),10$; BR IF AST'S DISABLED
	BLBS	(R5),5$			; BR IF ODD
	MOVZWL	(R5),R4			; GET USER AST ADDRESS
	BNEQ	15$			; IF NEQ THEN ENABLING
;
; DISABLE FUNCTION
;
	BBCCI	#SV_PWRAST,I_STATE(R10),10$; BR IF DISABLED AND DISABLE
	$SETPRA_S	0		; DISABLE FUNCTION
	RSB				; RETURN
5$:	$DSW	#IE.ADP			;
10$:	$DSW	#IE.ITS			; ALREADY DISABLED
;
; ENABLE THE AST
;
15$:	IFNORD	#2,(R4),5$		; PROBE THE ADDRESS
	BBSSI	#SV_PWRAST,I_STATE(R10),10$; BR IF ENABLED AND ENABLE
	MOVL	I_PWRAST(R10),R2	; GET PRESENT BLOCK
	BEQL	20$			; IF EQL THEN GET A NEW ONE
;
; IF THE BLOCK HAS ALREADY BEEN ALLOCATED, IT IS POSSIBLE THAT THE AST
; HAS NOT BEEN DELIVERED. IF THIS IS THE CASE THEN THE ENABLE WILL
; BE DONE ON AST EXIT.
;
	BBC	#ACBV_INPROG,ACB_FLAGS(R2),25$; BR IF NOT IN PROGRESS
	RSB				; ELSE RETURN SUCCESS
;
; ALLOCATE A CONTEXT BLOCK
;
20$:	BSBW	RSX$SETUPAST		; SET UP THE AST CONTEXT
;
; SET UP AST CONTEXT BLOCK
;
25$:	MOVL	R2,I_PWRAST(R10)	; SAVE ADDRESS OF BLOCK
	MNEGW	#1,ACB_UPRM(R2)		; SET NO OPTIONAL DATA
	MOVW	R4,ACB_UPC(R2)		; SAVE AST ADDRESS
	MOVW	#<1@ACBV_PERM>+<ACBC_PWRAST@ACBV_TYPE>,ACB_FLAGS(R2); SET UP FLAGS WORD

	.SBTTL	RSX$POWEREN - ENABLE POWER FAIL AST
;++
; RSX$POWEREN - ENABLE POWERFAIL AST
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE ENABLES POWERFAIL AST'S FOR THE IMAGE.
;
; ENTERED IN POST AST PROCESSING.
;
; INPUTS:
;
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	R10,R11 ARE PRESERVED.
;--
RSX$POWEREN::				; ENABLE POWERFAIL AST'S
	MOVL	I_PWRAST(R10),R2	; ADDRESS CONTEXT BLOCK
	BBC	#SV_PWRAST,I_STATE(R10),30$; BR IF NO LONGER ENABLED
	$SETPRA_S	W^RSX$POWERAST	; CAUSE POWER AST TO BLOCK
	BLBS	R0,30$			; IF LOW SET THEN SUCCESS
	BBCC	#SV_PWRAST,I_STATE(R10),5$; SET NOT ENABLED
5$:	$DSWIO	#IE.PRI			; CALL IT PRIVILEGE VIOLATION
30$:	RSB				; RETURN

	.SBTTL	RSX$SRDA - RSX11M SRDA$ DIRECTIVE
;++
; RSX$SRDA - RSX11M SPECIFY RECEIVE AST DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS A RSX DIRECTIVE HANDLER WHICH IMPLEMENTS AN RSX11M
; "SRDA$" DIRECTIVE.
;
; INPUT PARAMETERS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = CM IMAGE STACK ADDRESS
;	R10 = ADDRESS OF CM IMAGE DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUT PARAMETERS:
;
;	R10,R11 ARE PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	THE PROPER DIRECTIVE STATUS IS PLACED IN THE IMAGE DSW
;	ALONG WITH THE PROPER SETTING OF THE C-BIT.
;
; DSW RETURN CODES:
;
;	IS.SUC	SUCCESSFUL
;	IE.ITS	AST'S ARE ALREADY DISABLED
;	IE.SDP	NO MAILBOX AVAILABLE
;	IE.ADP	ILLEGAL ADDRESS
;	IE.AST	AST ALREADY ENABLED
;--
RSX$SRDA::				; SPECIFY RECEIVE AST DIRECTIVE
	BBS	#SV_NOAST,I_STATE(R10),10$; BR IF AST'S DISABLED
	BLBS	(R5),5$			; BR IF ODD ADDRESS
	MOVZWL	(R5),R4			; GET USER AST ADDRESS
	BNEQ	15$			; IF NEQ THEN ENABLE
	BBCCI	#SV_RCVAST,I_STATE(R10),10$; BR IN DISABLED AND DISABLE
	$QIOW_S	#5,I_RCVMAIL(R10),#IO$_SETMODE,,,,0
	RSB
5$:	$DSW	#IE.ADP			; ILLEGAL ADDRESS
10$:	$DSW	#IE.ITS			; ALREADY DISABLED
12$:	$DSW	#IE.AST			; ALREADY ENABLED
;
; ENABLE FUNCTION
;
15$:	IFNORD	#2,(R4),5$		; PROBE ADDRESS
	TSTL	I_RCVMAIL(R10)		; MAILBOX PRESENT?
	BNEQ	20$			; IF NEQ THEN YES
	$DSW	#IE.SDP			; SET STATUS AND RETURN
;
; ALREADY ENABLED?
;
20$:	BBSSI	#SV_RCVAST,I_STATE(R10),12$; BR IF ENABLED AND ENABLE
;
; ENABLE FUNCTION
;
	MOVL	I_RCVAST(R10),R2	; GET CURRENT BLOCK IF ANY
	BEQL	25$			; IF EQL THEN ALLOCATE NEW BLOCK
;
; IF THE CONTEXT BLOCK EXISTS THEN IT IS POSSIBLE THAT THE AST IS STILL
; IN PROGRESS AND THE ENABLE WILL BE DONE ON AST EXIT.
;
	BBC	#ACBV_INPROG,ACB_FLAGS(R2),30$; BR IF NOT IN PROGRESS
	RSB				; ELSE RETURN
;
; ALLOCATE A CONTEXT BLOCK FOR RECEIVE DATA AST'S
;
25$:	BSBW	RSX$SETUPAST		; SET UP THE AST BLOCK
;
; SET UP THE CONTEXT BLOCK
;
30$:	MOVL	R2,I_RCVAST(R10)	; SAVE CONTEXT BLOCK ADDRESS
	MOVW	R4,ACB_UPC(R2)		; SAVE THE ADDRESS OF THE AST SERIVCE
	MNEGW	#1,ACB_UPRM(R2)		; SET NO DATA ON AST STACK
	MOVW	#<1@ACBV_PERM>+<ACBC_RCVAST@ACBV_TYPE>,ACB_FLAGS(R2); SAVE TYPE FOR POST AST 

	.SBTTL	RSX$RCVASTEN - ENABLE RECEIVE DATA AST
;++
; RSX$RCVASTEN - ENABLE IMAGE FOR MAILBOX UNSOLICITED AST'S
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED FOR RECEIVE DATA AST ENABLE OR
; AS A RESULT OF AN AST EXIT AFTER A RECEIVE AST DELIVERY.
;
; INPUTS:
;
;	R10 = ADDRESS OF THE IMAGE DATA BASE
;	R11 = ADDRESS OF THE IMAGE HEADER
;
; OUTPUTS:
;
;	R10,R11 ARE PRESERVED
;--
RSX$RCVASTEN::				; ENABLE FOR RECEIVE DATA AST'S
	BBC	#SV_RCVAST,I_STATE(R10),20$; BR IF NO LONGER ENABLED
	$QIOW_S	#6,I_RCVMAIL(R10),#IO$_SETMODE,,,,W^RSX$RCVAST,I_RCVAST(R10)
	BSBW	RSX$RSXQIOERR		; MAP ERROR STATUS
	BLBS	R0,20$			; IF LOW SET THEN SUCCESS
	BBCC	#SV_RCVAST,I_STATE(R10),10$; MARK NOT ENABLED
10$:	$DSWIO	R1			; RETURN IT
20$:	RSB				; 

	.SBTTL	RSX$SVDB - RSX11M SVDB$ DIRECTIVE
;++
; RSX$SVDB - RSX11M SPECIFY DEBUG VECTOR DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS A RSX DIRECTIVE HANDLER WHICH IMPLEMENTS AN RSX11M
; "SVDB$" DIRECTIVE.
;
; INPUT PARAMETERS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = CM IMAGE STACK ADDRESS
;	R10 = ADDRESS OF CM IMAGE DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUT PARAMETERS:
;
;	R10,R11 ARE PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	THE PROPER DIRECTIVE STATUS IS PLACED IN THE IMAGE DSW
;	ALONG WITH THE PROPER SETTING OF THE C-BIT.
;
; DSW RETURN CODES:
;
;	IS.SUC	SUCCESSFUL
;--
RSX$SVDB::				; SPECIFY DEBUG VECTOR DIRECTIVE
	MOVZWL	(R5)+,R4		; GET ADDRESS
	BLBS	R4,10$			; BR IF ODD
	MOVZWL	(R5),R3			; GET SIZE IN WORDS
	BEQL	5$			; IF EQL THEN DISABLE
	CMPW	#9,R3			; IN RANGE
	BLSSU	10$			; IF LSSU THEN NO
	TSTW	(R5)			; PROBE BY EXCEPTION
	TSTW	(R5)[R3]		;
5$:	MOVW	R4,H.ODVA(R11)		; SAVE PARAMS
	MOVW	R4,I_DEBVEC(R10)	;
	MOVW	R3,H.ODVL(R11)
	MOVW	R3,I_DEBVECL(R10)	;
	RSB				;
10$:	$DSW	#IE.ADP			;

	.SBTTL	RSX$SVTK - RSX11M SVTK$ DIRECTIVE
;++
; RSX$SVTK - RSX11M SPECIFY TASK VECTOR DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS A RSX DIRECTIVE HANDLER WHICH IMPLEMENTS AN RSX11M
; "SVTK$" DIRECTIVE.
;
; INPUT PARAMETERS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = CM IMAGE STACK ADDRESS
;	R10 = ADDRESS OF CM IMAGE DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUT PARAMETERS:
;
;	R10,R11 ARE PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	THE PROPER DIRECTIVE STATUS IS PLACED IN THE IMAGE DSW
;	ALONG WITH THE PROPER SETTING OF THE C-BIT.
;
; DSW RETURN CODES:
;
;	IS.SUC	SUCCESSFUL
;--
RSX$SVTK::				; SPECIFY TASK VECTOR DIRECTIVE
	MOVZWL	(R5)+,R4		; GET ADDRESS
	BLBS	R4,10$			; BR IF ODD
	MOVZWL	(R5),R3			; GET SIZE IN WORDS
	BEQL	5$			; IF EQL THEN DISABLE
	CMPW	#9,R3			; IN RANGE
	BLSSU	10$			; IF LSSU THEN NO
	TSTW	(R5)			; PROBE BY EXCEPTION
	TSTW	(R5)[R3]		;
5$:	MOVW	R4,H.TKVA(R11)		; SAVE PARAMS
	MOVW	R4,I_SSTVEC(R10)	;
	MOVW	R3,H.TKVL(R11)
	MOVW	R3,I_SSTVECL(R10)
	RSB				;
10$:	$DSW	#IE.ADP			; ADDRESS CHECK
;
	.END
