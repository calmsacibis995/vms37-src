	.TITLE	RSXEFN - RSX11M EVENT FLAG DIRECTIVES
	.IDENT	'V03-000'

;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:
;
;	VAX/VMS RSX AME.
;
; ABSTRACT:
;
;	RSX11M EVENT FLAG DIRECTIVE EMULATION.
;
; AUTHOR:
;
;	R.HEINEN 4-NOV-76
;
; MODIFIED BY:
;
;	V007	MSH001	Michael S. Harvey	18-Aug-81
;		Ignore high byte of event flag word as is done in
;		RSX-11M. This also ensures that the priority field
;		in the Queue I/O directives is ignored.
;
;	V006	TMH0006		Tim Halvorsen		29-Jun-1981
;		Do not attempt match EFN or AST parameter in CMKT$ if zero.
;
;	V005	TMH0005		Tim Halvorsen		25-May-1981
;		Allow selective cancelation of timer requests via 3-word
;		form of CMKT$ directive, and deallocate ACB's when any
;		timer request is canceled.
;
;	V004	TMH0004		Tim Halvorsen		13-May-1980
;		Do not set carry bit when returning IS.CLR
;--
;
; EXTERNAL SYMBOLS
;
	$RSXDEF			; DEFINE RSX SYMBOLS
	DRERR$			; DEFINE RSX11M DIRECTIVE STATUS CODES
 
	.PSECT	RSXCODE,NOWRT,SHR,PIC
	.SBTTL	RSX$CLEF - RSX11M CLEF$$ DIRECTIVE
;++
; RSX$CLEF - RSX11M CLEAR EVENT FLAG DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS A RSX DIRECTIVE HANDLER WHICH IMPLEMENTS AN RSX11M
; "CLEF$$" DIRECTIVE.
;
; INPUT PARAMETERS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = CM IMAGE STACK ADDRESS
;	R10 = ADDRESS OF CM IMAGE DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUT PARAMETERS:
;
;	R10,R11 ARE PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	THE PROPER DIRECTIVE STATUS IS PLACED IN THE IMAGE DSW
;	ALONG WITH THE PROPER SETTING OF THE C-BIT.
;
; DSW RETURN CODES:
;
;	IS.CLR FLAG WAS CLEAR
;	IS.SET FLAG WAS SET
;	IE.IEF INVALID EVENT FLAG SPECIFIED
;--
RSX$CLEF::				; CLEAR EVENT FLAG TASK DIRECTIVE
	BSBW	CVTEFN			; CONVERT EFN
	$CLREF_S R1			; CLEAR IT
	BRW	SETCLRDSW		; MAP THE DSW RETURN CODE

	.SBTTL	RSX$CMKT - RSX11M CMKT$ DIRECTIVE
;++
; RSX$CMKT - RSX11M CANCEL MARK TIME DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS A RSX DIRECTIVE HANDLER WHICH IMPLEMENTS AN RSX11M
; "CMKT$" DIRECTIVE.
;
; INPUT PARAMETERS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = CM IMAGE STACK ADDRESS
;	R10 = ADDRESS OF CM IMAGE DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUT PARAMETERS:
;
;	R10,R11 ARE PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	THE PROPER DIRECTIVE STATUS IS PLACED IN THE IMAGE DSW
;	ALONG WITH THE PROPER SETTING OF THE C-BIT.
;
; DSW RETURN CODES:
;	IS.SUC	SUCCESSFUL
;--
RSX$CMKT::				; CANCEL MARK TIME DIRECTIVE
	$SETAST_S ENBFLG=#0		; DISABLE AST'S TEMPORARILY
	CMPB	-1(R5),#1		; 1 O 3 WORD FORM?
	BGTRU	50$			; BRANCH IF SELECTIVE CANCELATION
	$CANTIM_S			; CANCEL ALL OUTSTANDING REQUESTS
10$:	REMQUE	@I_MRKTQUEUE(R10),R2	; GET NEXT ENTRY FROM MRKT QUEUE
	BVS	90$			; BRANCH IF NONE LEFT
	INSQUE	(R2),I_ASTPOOL(R10)	; RELEASE THE BLOCK
	BRB	10$			; LOOP UNTIL ENTIRE QUEUE DEALLOCATED
90$:	$SETAST_S ENBFLG=#1		; RE-ENABLE AST'S
	RSB				; RETURN
;
;	CANCEL ONLY THOSE TIMER REQUESTS WITH A GIVEN ASTADR OR EFN
;
50$:	MOVAB	I_MRKTQUEUE(R10),R3	; START AT QUEUE HEAD
	MOVL	R3,R4			; END OF QUEUE
60$:	MOVL	(R3),R3			; SKIP TO NEXT IN LIST
65$:	CMPL	R3,R4			; END OF QUEUE?
	BEQL	90$			; BRANCH IF DONE
	TSTW	2(R5)			; ASTADR SPECIFIED?
	BEQL	68$			; IF NOT, SKIP ASTADR COMPARISON
	CMPW	ACB_UPC(R3),2(R5)	; ASTADR MATCH?
	BEQL	70$			; BRANCH IF SO
68$:	TSTW	(R5)			; EFN SPECIFIED?
	BEQL	60$			; IF NOT, SKIP EFN COMPARISION
	CMPW	ACB_UPRM(R3),(R5)	; EFN MATCH?
	BNEQ	60$			; IF NOT, KEEP LOOPING
70$:	$CANTIM_S REQIDT=R3		; CANCEL THIS TIMER REQUEST
	MOVL	(R3),R2			; SAVE LINK TO NEXT ENTRY IN QUEUE
	REMQUE	(R3),(R3)		; REMOVE FROM OUTSTANDING REQUEST QUEUE
	INSQUE	(R3),I_ASTPOOL(R10)	; RELEASE THE BLOCK
	MOVL	R2,R3			; SKIP TO NEXT ENTRY IN QUEUE
	BRB	65$			; KEEP SEARCHING FOR MATCHES

	.SBTTL	RSX$CRGF - RSX11M CRGF$ DIRECTIVE
;---
;
;	CREATE GROUP GLOBAL EVENT FLAGS
;
;	THIS DIRECTIVE ASSOCIATES THE GROUP GLOBAL EVENT FLAG
;	CLUSTER WITH THE CURRENT TASK.
;
; INPUTS:
;
;	R5 = ADDRERSS OF DPB+2
;	R10 = ADDRESS OF CM DATA AREA
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUTS:
;
;	R10,R11 ARE PRESERVED
;	DIRECTIVE STATUS IS PLACED IN DSW; C-BIT IS SET.
;
; DSW RETURN CODES:
;
;	IS.SUC	SUCCESSFUL
;	IE.PRI	PRIVILEGE VIOLATION
;	IE.IUI	INVALID GROUP NUMBER
;---
GROUPEFC:
	.ASCIC	'RSXGROUPEFN'		; GROUP CLUSTER NAME

RSX$CRGF::
	MOVZWL	(R5)+,R1		; GET GROUP NUMBER
	BEQL	10$			; BRANCH IF NOT SPECIFIED
	MOVZBL	H.CUIC+1(R11),R2	; GET USER UIC IN HEADER
	CMPL	R1,R2			; ONLY ALLOW OWN GROUP
	BNEQ	50$			; BRANCH IF SOME OTHER GROUP
10$:	MOVAB	GROUPEFC,R0		; ADDRESS GROUP CLUSTER NAME
	MOVZBL	(R0)+,I_SCRATCH(R10)	; SETUP DESCRIPTOR OF NAME
	MOVL	R0,I_SCRATCH+4(R10)
	$ASCEFC_S #96,I_SCRATCH(R10),-	; ASSOCIATE WITH GROUP CLUSTER
		PERM=#1			; TRY MAKING PERMANENT FIRST
	CMPW	R0,#SS$_NOPRIV		; NO PRIVILEGE FOR PERM CEB?
	BNEQ	15$			; BRANCH IF THATS NOT IT
	$ASCEFC_S #96,I_SCRATCH(R10)	; TRY AGAIN USING TEMPORARY
15$:	BLBC	R0,20$			; BRANCH IF ERROR
	MOVZBL	#127,I_HIGHEFN(R10)	; SET NEW HIGH EFN
	RSB
;
;	TRANSLATE ERROR FROM $ASCEFC SERVICE
;
20$:	CMPW	R0,#SS$_NOPRIV		; NO PRIVILEGE?
	BNEQ	30$			; BRANCH IF NOT
25$:	$DSW	#IE.PRI			; PRIVILEGE VIOLATION
30$:	CMPW	R0,#SS$_INSFMEM		; INSUFFICIENT MEMORY?
	BNEQ	40$			; BRANCH IF NOT
	$DSW	#IE.UPN			; INSUFFICIENT DYNAMIC STORAGE
40$:	$DSW	#IE.NOD			; QUOTA EXCEEDED
50$:	$DSW	#IE.IUI			; INVALID GROUP

	.SBTTL	RSX$ELGF - RSX11M ELGF$ DIRECTIVE
;---
;
;	ELGF$ - ELIMINATE GROUP GLOBAL EVENT FLAGS
;
;	THIS DIRECTIVE CAUSES THE GROUP EVENT FLAG CLUSTER
;	TO BE MARKED FOR DELETION WHEN THE USE COUNT GOES TO ZERO.
;
; INPUTS:
;
;	R5 = ADDRESS OF DPB+2
;	R10 = ADDRESS OF CM DATA AREA
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUTS:
;
;	R10,R11 ARE PRESERVED
;	DIRECTIVE STATUS IS PLACED IN DSW; C-BIT IS SET.
;
; DSW RETURN CODES:
;
;	IS.SUC	SUCCESSFUL
;	IE.PRI	PRIVILEGE VIOLATION
;---
RSX$ELGF::
	MOVZWL	(R5)+,R1		; GET GROUP NUMBER
	BEQL	10$			; BRANCH IF NOT SPECIFIED
	MOVZBL	H.CUIC+1(R11),R2	; GET CURRENT UIC
	CMPL	R1,R2			; ONLY ALLOW CURRENT GROUP
	BNEQ	20$			; BRANCH IF SOME OTHER GROUP
10$:	$DACEFC_S #96			; DISASSOCIATE GROUP CLUSTER
	RSB
20$:	$DSW	#IE.IUI			; PRIVILEGE VIOLATION

	.SBTTL	RSX$DECL/RSX$WSIG - RSX11M DECL$ AND WSIG$ DIRECTIVES
;++
; RSX$DECL - RSX11M DECLARE SIGNIFICANT EVENT DIRECTIVE
; RSX$WSIG - RSX11M WAIT FOR SIGNIFICANT EVENT DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS A RSX DIRECTIVE HANDLER WHICH IMPLEMENTS AN RSX11M
; "DECL$" DIRECTIVE.
;
; INPUT PARAMETERS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = CM IMAGE STACK ADDRESS
;	R10 = ADDRESS OF CM IMAGE DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUT PARAMETERS:
;
;	R10,R11 ARE PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	THE PROPER DIRECTIVE STATUS IS PLACED IN THE IMAGE DSW
;	ALONG WITH THE PROPER SETTING OF THE C-BIT.
;
; DSW RETURN CODES:
;	IS.SUC	SUCCESSFUL
;--
RSX$DECL::				; DECLARE SIGNIFICANT EVENT DIRECTIVE
RSX$WSIG::				; WAIT FOR SIGNIFICANT EVENT DIRECTIVE
	RSB				; AND RETURN

	.SBTTL	RSX$EXIF - RSX11M EXIF$ DIRECTIVE
;++
; RSX$EXIF - RSX11M EXIT IF DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS A RSX DIRECTIVE HANDLER WHICH IMPLEMENTS AN RSX11M
; "EXIF$" DIRECTIVE.
;
; INPUT PARAMETERS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = CM IMAGE STACK ADDRESS
;	R10 = ADDRESS OF CM IMAGE DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUT PARAMETERS:
;
;
; IMPLICIT OUTPUTS:
;
;	THE PROPER DIRECTIVE STATUS IS PLACED IN THE IMAGE DSW
;	ALONG WITH THE PROPER SETTING OF THE C-BIT.
;
; DSW RETURN CODES:
;	IS.SUC	SUCCESSFUL
;	IE.IEF	INVALID EVENT FLAG SPECIFIED
;--
RSX$EXIF::				; EXIT IF DIRECTIVE
	BSBW	CVTEFN			; CONVERT EFN
	EXTZV	#0,#5,R1,R2		; GET FLAG NUMBER OF CLUSTER
	$READEF_S	R1,I_SCRATCH(R10); READ THE EVENT FLAG
	BBC	R2,I_SCRATCH(R10),10$	; IF CLEAR THEN NO EXIT
	BRW	RSX$EXIT		; EXIT THE IMAGE
10$:	RSB				;

	.SBTTL	RSX$MRKT - RSX11M MRKT$ DIRECTIVE
;++
; RSX$MRKT - RSX11M MARK TIME DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS A RSX DIRECTIVE HANDLER WHICH IMPLEMENTS AN RSX11M
; "MRKT$" DIRECTIVE.
; THE ACTION IS TO SET UP A TIMER AND IF AN AST SERVICE ROUTINE IS
; SPECIFIED, THEN ALSO ALLOCATE AN AST CONTEXT BLOCK FOR THE DELIVERY
; OT THE AST.
;
; INPUT PARAMETERS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = CM IMAGE STACK ADDRESS
;	R10 = ADDRESS OF CM IMAGE DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUT PARAMETERS:
;
;	R10,R11 ARE PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	THE PROPER DIRECTIVE STATUS IS PLACED IN THE IMAGE DSW
;	ALONG WITH THE PROPER SETTING OF THE C-BIT.
;
; DSW RETURN CODES:
;	IS.SUC	SUCCESSFUL
;	IE.UPN INSUFFICIENT DYNAMIC MEMORY -- SS$_INSFMEM
;	IE.NOD QUOTA EXCEEDED -- SS$_EXQUOTA
;	IE.ITI	INVALID TIME UNIT
;	IE.IEF	INVALID EVENT FLAG
;--
RSX$MRKT::				; MARK TIME DIRECTIVE
	MOVZWL	(R5)+,R1		; GET EVENT FLAG NUMBER
	BEQL	5$			; IF EQL THEN NONE
	TSTW	-(R5)			; POINT TO EFN
	BSBW	CVTEFN			; CONVERT EFN
5$:	MOVL	R1,R7			; COPY EFN
	MOVZWL	(R5)+,R2		; GET MAGNITUDE OF TIME
	BEQL	IEITI			; IF EQL THEN ERROR
	MOVZWL	(R5)+,R0		; GET UNITS
	BEQL	IEITI			; IF EQL THEN ERROR
	BSBW	RSX$TIMEMAG		; CONVERT TIME TO QUAD
	BLBC	R2,IEITI		; IF LOW CLEAR THEN ERROR IN CONVERT
	MOVQ	R0,I_SCRATCH(R10)	; INSERT IN ARG LIST
	BSBW	RSX$SETUPAST		; BUILD CONTEXT BLOCK
	INSQUE	(R2),@I_MRKTQUEUE+4(R10); INSERT INTO END OF MRKT QUEUE
	CLRW	ACB_FLAGS(R2)		; SET NO POST AST PROCESSING
	MOVW	(R5),ACB_UPC(R2)	; INSERT AST SERVICE ADDRESS
	MOVW	R7,ACB_UPRM(R2)		; INSERT EFN USED
	BEQL	25$			; IF EQL THEN NONE
	SUBW	#31,ACB_UPRM(R2)	; CONVERT TO HIS EFN MAP
25$:	$SETIMR_S EFN=R7,-
		DAYTIM=I_SCRATCH(R10),-
		ASTADR=W^RSX$MARKAST,-
		REQIDT=R2
	BLBS	R0,40$			; IF LOW SET THEN SUCCESS
;
; IF ERROR DETECTED, DEALLOCATE THE AST CONTEXT BLOCK
;
	INSQUE	(R2),I_ASTPOOL(R10)	; RELEASE THE BLOCK
;
; ERROR IS EITHER SS$_INSFMEM OR SS$_EXQUOTA
;
	CMPW	#SS$_INSFMEM,R0		; INSUFFICIENT MEMORY?
	BNEQ	30$			; IF NEQ THEN NO
	$DSW	#IE.UPN			; SET ERROR AS NO MEMORY
30$:	$DSWIO	#IE.NOD			; EXCEEDED QUOTA
40$:	RSB				; RETURN
;
; BAD TIME UNIT VALUE
;
IEITI:	$DSW	#IE.ITI			; SET STATUS AND RETURN

	.SBTTL	RSX$RDAF - RSX11M RDAF$, RDXF$ DIRECTIVE
;---
;
;	RDAF$ - READ NORMAL EVENT FLAGS (DPB SIZE = 2)
;	RDXF$ - READ EXTENDED EVENT FLAGS (DPB SIZE = 3)
;
;	THIS DIRECTIVE WAS ADDED IN ADDITION TO RDAF$ TO PROVIDE
;	ACCESS TO THE GROUP EVENT FLAG CLUSTER.  IT RETURNS THE
;	LOCAL, COMMON AND GROUP EVENT CLUSTERS IN A 6 WORD BUFFER.
;
; INPUTS:
;
;	R5 = ADDRESS OF DPB+2
;	R10 = ADDRESS OF CM DATA AREA
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUTS:
;
;	R10, R11 ARE PRESERVED
;	DIRECTIVE STATUS IS PLACED IN DSW; C-BIT IS SET.
;
; DSW RETURN CODES:
;
;	IS.SUC	SUCCESSFUL
;	IS.CLR	GROUP GLOBAL FLAGS DO NOT EXIST, ZEROS RETURNED.
;	IE.ADP	ILLEGAL BUFFER ADDRESS
;---
RSX$RDAF::
	CMPB	-1(R5),#2		; DPB SIZE CAN BE 2 (RDAF)
	BLSSU	15$			; BRANCH IF ILLEGAL
	CMPB	-1(R5),#3		; OR 3 (RDXF)
	BGTRU	15$			; BRANCH IF ILLEGAL
	MOVZWL	(R5),R2			; ADDRESS BUFFER
	IFNOWRT	#8,(R2),50$		; ERROR IF CANNOT ACCESS
	BLBS	R2,50$			; ERROR IF ON ODD BOUNDARY
	CLRQ	(R2)			; PRESET BUFFER TO ZERO
	$READEF_S #32,(R2)		; READ LOCAL EVENT FLAGS
	$READEF_S #64,4(R2)		; READ COMMON EVENT FLAGS
	CASE	-1(R5),LIMIT=#2,TYPE=B,- ; CASE ON DPB SIZE (2 OR 3)
		<20$,30$>		; RDAF IF 2, RDXF IF 3
15$:	$DSW	#IE.SDP			; ILLEGAL DPB SIZE
30$:	IFNOWRT	#4,8(R2),50$		; BRANCH IF NO WRITE ACCESS
	$READEF_S #96,8(R2)		; READ GROUP EVENT FLAGS
	BLBC	R0,10$			; BRANCH IF NOT ASSOCIATED
20$:	RSB
10$:	CLRL	8(R2)			; RETURN ZERO CLUSTER
	CVTBW	#IS.CLR,H.DSW(R11)	; NO GROUP FLAGS - CLEARED
	RSB
50$:	$DSW	#IE.ADP			; ILLEGAL BUFFER ADDRESS

	.SBTTL	RSX$SETF - RSX11M SETF$ DIRECTIVE
;++
; RSX$SETF - RSX11M SET EVENT FLAG DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS A RSX DIRECTIVE HANDLER WHICH IMPLEMENTS AN RSX11M
; "SETF$" DIRECTIVE.
;
; INPUT PARAMETERS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = CM IMAGE STACK ADDRESS
;	R10 = ADDRESS OF CM IMAGE DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUT PARAMETERS:
;
;	R10,R11 ARE PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	THE PROPER DIRECTIVE STATUS IS PLACED IN THE IMAGE DSW
;	ALONG WITH THE PROPER SETTING OF THE C-BIT.
;
; DSW RETURN CODES:
;	IS.SET  FLAG WAS SET
;	IS.CLR  FLAG WAS CLEAR
;	IE.IEF	INVALID EVENT FLAG SPECIFIED
;--
RSX$SETF::				; SET EVENT FLAG DIRECTIVE
	BSBW	CVTEFN			; CONVERT EFN
	$SETEF_S R1			; SET EVENT FLAG
SETCLRDSW:				; COMMON DSW MAP CODE FOR CLEAR/SET
	CVTBW	#IS.SET,H.DSW(R11)	; ASSUME SET
	CMPW	R0,#SS$_WASSET		; SET?
	BEQL	10$			; IF EQL THEN YES
	CVTBW	#IS.CLR,H.DSW(R11)	; SET WAS CLEAR
10$:	RSB				; RETURN

	.SBTTL	RSX$WTLO - RSX11M WTLO$ DIRECTIVE
;++
; RSX$WTLO - RSX11M WAIT FOR LOGICAL OR DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS A RSX DIRECTIVE HANDLER WHICH IMPLEMENTS AN RSX11M
; "WTLO$" DIRECTIVE.
; THE ACTION IS TO SET UP THE ARGUMENTS FOR THE WAIT AND TO ENTER
; THE RSX WAIT FOR EVENT CODE "RSX$WAIT".
;
; INPUT PARAMETERS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = CM IMAGE STACK ADDRESS
;	R10 = ADDRESS OF CM IMAGE DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUT PARAMETERS:
;
;	R10,R11 ARE PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	THE PROPER DIRECTIVE STATUS IS PLACED IN THE IMAGE DSW
;	ALONG WITH THE PROPER SETTING OF THE C-BIT.
;
; DSW RETURN CODES:
;	IS.SUC	SUCCESSFUL
;	IE.IEF  BAD EVENT FLAG
;--
RSX$WTLO::				; WAIT FOR LOGICAL OR DIRECTIVE
	MOVZWL	(R5)+,R1		; GET GROUP NUMBER
	CMPB	R1,#3			; TEST RANGE
	BGTRU	20$			; IF GTRU THEN ERROR
	MOVZWL	(R5),R2			; GET MASK
	BEQL	20$			; IF EQL THEN ERROR
	BLBC	R1,10$			; IF LOW CLEAR THEN LOW MAP
	ASHL	#16,R2,R2		; SHIFT MASK TO HIGH ORDER
10$:	ACBL	I_HIGHEFN(R10),#62,R1,RSX$WAIT ; ADJUST AND TEST GROUP
20$:	$DSW	#IE.IEF			; ILLEGAL EFN

	.SBTTL	RSX$STLO - RSX11M STLO$ DIRECTIVE
;---
;
;	STLO$ - STOP FOR LOGICAL OR OF EVENT FLAGS
;
;	SET UP THE ARGUMENTS FOR THE WAIT AND TO ENTER
;	THE RSX WAIT FOR EVENT CODE "RSX$WAIT".
;
; INPUTS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = CM IMAGE STACK ADDRESS
;	R10 = ADDRESS OF CM IMAGE DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUTS:
;
;	R10,R11 ARE PRESERVED
;	DIRECTIVE STATUS IS PLACED IN IMAGE DSW; C-BIT IS SET.
;
; DSW RETURN CODES:
;
;	IS.SUC	SUCCESSFUL
;	IE.IEF  BAD EVENT FLAG
;	IE.AST	TASK WAS IN AST STATE
;---
RSX$STLO::
	BBS	#SV_ASTLVL,I_STATE(R10),30$	; BRANCH IF AST STATE
	MOVZWL	(R5)+,R1		; GET GROUP NUMBER
	CMPB	R1,#1			; TEST RANGE
	BGTRU	20$			; IF GTRU THEN ERROR
	MOVZWL	(R5),R2			; GET MASK
	BEQL	20$			; IF EQL THEN ERROR
	BLBC	R1,10$			; IF LOW CLEAR THEN LOW MAP
	ASHL	#16,R2,R2		; SHIFT MASK TO HIGH ORDER
10$:	ACBL	I_HIGHEFN(R10),#62,R1,RSX$WAIT ; ADJUST AND TEST GROUP
20$:	$DSW	#IE.IEF			; ILLEGAL EFN
30$:	$DSW	#IE.AST			; TASK IS AT AST STATE

	.SBTTL	RSX$STSE - RSX11M STSE$ DIRECTIVE
;---
;
;	STSE$ - STOP FOR SINGLE EVENT FLAG
;
;	THIS DIRECTIVE CAUSES THE TASK TO BE STOPPED UNTIL THE
;	SPECIFIED EVENT FLAG IS SET.
;
; INPUTS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = STACK POINTER OF CM IMAGE
;	R10 = ADDRESS OF CM DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUTS:
;
;	R10,R11 ARE PRESERVED.
;	DIRECTIVE STATUS IS PLACED IN IMAGE DSW; C-BIT IS SET.
;
; DSW RETURN CODES:
;
;	IS.SUC	SUCCESSFUL
;	IE.IEF	INVALID EVENT FLAG
;	IE.AST	ISSUED WHILE IN AST STATE
;
;---
RSX$STSE::
	BBC	#SV_ASTLVL,I_STATE(R10),RSX$WTSE ; IF NOT AT AST STATE
	$DSW	IE.AST			; ILLEGAL AT AST STATE

	.SBTTL	RSX$WTSE - RSX11M WTSE$ DIRECTIVE
;++
; RSX$WTSE - RSX11M WAIT FOR SINGLE DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS A RSX DIRECTIVE HANDLER WHICH IMPLEMENTS AN RSX11M
; "WTSE$" DIRECTIVE.
; THE ACTION IS TO SET UP THE ARGUMENTS FOR THE WAIT AND TO ENTER THE
; RSX WAIT ROUTINE "RSX$WAIT".
;
;
; INPUT PARAMETERS:
;
;	R5 = ADDRESS OF THE EVENT FLAG IN THE DPB
;	R6 = CM IMAGE STACK ADDRESS
;	R10 = ADDRESS OF CM IMAGE DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUT PARAMETERS:
;
;	R10,R11 ARE PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	THE PROPER DIRECTIVE STATUS IS PLACED IN THE IMAGE DSW
;	ALONG WITH THE PROPER SETTING OF THE C-BIT.
;
; DSW RETURN CODES:
;	IS.SUC	SUCCESSFUL
;	IE.IEF	INVALID EVENT FLAG SPECIFIED
;--
RSX$WTSE::				; WAIT FOR SINGLE DIRECTIVE
	BSBW	CVTEFN			; CONVERT EFN
	EXTZV	#0,#5,R1,R2		; GET THE FLAG NUMBER IN THE EFN
	ASHL	R2,#1,R2		; SET THE BIT

	.SBTTL	RSX$WAIT - COMMON CODE FOR WAIT FOR SINGLE AND OR OF EVENTS
;++
; RSX$WAIT - WAITFOR COMMON CODE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE SETS UP AND POSSIBLY DOES A WAIT FOR LOGICAL OR OF EVENTS.
; THE NORMAL ACTION IS TO LOAD THE WAIT FOR CONTEXT INTO THE IMPURE DATA
; BASE AND DO A WAIT FOR LOGICAL OR ON THAT CONTEXT. IF AN AST OCCURS
; DURING THIS WAIT AND THE AST CAUSES AN IMAGE AST TO BE QUEUED, THEN THIS WAIT
; MUST BE INTERRUPTED FOR THE AST. THE AST LOGIC, DETECTING THIS CONDITION,
; SAVES THE CURRENT WAIT CONTEXT AND SETS UP AN ILLEGAL ARGUMENT LIST.
; AFTER THE RET FROM AST LEVEL THE WAIT IS RE-STARTED AND WILL FAIL.
; WHEN IT FAILS, THIS ROUTINE WILL COMPLETE BY RETURNING TO THE DIRECTIVE
; PROCESSING LOGIC. AT THAT TIME, THE AST IS DELIVERED. ON AST EXIT,
; THE SAVED WAIT FOR CONTEXT IS PUT BACK AND THIS ROUTINE REENTERED.
;
; INPUTS:
;
;	R1,R2 = QUAD WORD WAIT FOR CONTEXT
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	R10,R11 ARE PRESERVED.
;
; THE WAIT FOR CONTEXT IN THE IMPURE DATA BASE IS CLEARED.
;--
RSX$WAIT::				; WAIT FOR EVENT
;
; SETUP I_WAIT TO PERFORM $WFLOR CALL. IT IS OK TO BE INTERRUPTED
; UP UNTIL THE WAIT BIT IS SET TO INDICATE TO THE AST DELIVERY CODE
; THAT WE ARE PERFORMING A WAIT SERVICE.
;
	MOVAB	I_WAIT(R10),R0		; ADDRESS WAIT ARG LIST
	MOVQ	R1,(R0)			; INSERT MASK AND CLUSTER DATA
	MOVZBL	#2,-(R0)		; INSERT SIZE OF LIST
	BBSS	#SV_WAIT,I_STATE(R10),10$; SET WAIT SET UP IN PROGRESS
;
; IF SV_PENDWAIT IS SET, THAT MEANS AN AST HAS OCCURED WHILE PROCESSING
; DIRECTIVES IN NATIVE MODE.  THIS MEANS THAT THE AST SHOULD BE DONE
; FIRST, THEN THE WAIT WILL BE RESTARTED LATER.
;
10$:	BBS	#SV_PENDWAIT,I_STATE(R10),30$ ; BR IF SHOULD SKIP WAIT
;
; THIS WAIT COULD BE FLUSHED AT AST LEVEL BY CLEARING THE WAIT MASK
; AND CLUSTER DATA IN ORDER TO DELIVER ANOTHER AST. IF IT IS FLUSHED,
; $WLFOR WILL RETURN A ERROR CONDITION BECAUSE OF AN INVALID CLUSTER.
;
	$WFLOR_G (R0)			; DO SERVICE
;
; CLEAR THE WAIT STATUS AFTER THE $WFLOR COMPLETES TO SIGNAL WAIT DONE.
;
20$:	CLRQ	I_WAIT(R10)		; CLEAR WAIT STATUS
	BICL	#1@SV_WAIT,I_STATE(R10)	; SIGNAL NO LONGER WAITING
;
; NOTE THAT A WINDOW EXISTS HERE AFTER THE WAIT BIT IS CLEARED SUCH
; THAT AN AST COULD INTERRUPT AND THE DELIVERY CODE WOULD SAVE AN
; ILLEGAL VALUE OF I_WAIT.  WE CHECK IF I_WAIT WAS SET AGAIN AND ZERO
; IT UNTIL IT STAYS ZERO.
;
	TSTL	I_WAIT(R10)		; WAS I_WAIT SET AGAIN?
	BNEQ	20$			; ZERO AGAIN IF IT WAS
	RSB
;
; COME HERE WHEN PENDWAIT IS SET ON ENTRY TO THIS ROUTINE.  THIS MEANS
; THAT WE ARE TRYING TO FLUSH A WAIT SO WE JUST SAVE THE WAIT CLUSTER
; DIRECTLY INTO I_WAITSAVE AND SKIP THE WAIT FOR NOW.  IT WILL BE
; RE-STARTED LATER AFTER THE AST IS DELIVERED.
;
30$:	MOVQ	R1,I_WAITSAVE(R10)	; SAVE WAIT CLUSTER INFO
	BRB	20$			; AND CLEAR I_WAIT

	.SBTTL	CVTEFN - CONVERT EVENT FLAG NUMBER
;++
; CVTEFN - CONVERT EVENT FLAG NUMBER TO RSX MAP AND CHECK FOR VALID
;
; INPUTS:	
;
;	R5 = ADDRESS OF THE EVENT FLAG VALUE
;
; OUTPUTS:
;
;	R1 = EVENT FLAG NUMBER
;	R5 = R5+2
;--
CVTEFN:	MOVZBL	(R5)+,R1		; GET SPECIFIED RSX EVENT FLAG
	BEQL	10$			; IF EQL THEN ERROR
	ACBL	I_HIGHEFN(R10),#31,R1,15$; MAP TO RSX EVENT FLAGS
10$:	TSTL	(SP)+			; POP RETURN ADDRESS
	$DSW	#IE.IEF			; SET STATUS AND RETURN

15$:	INCL	R5			; IGNORE HIGH BYTE
	RSB				; DONE

	.END
