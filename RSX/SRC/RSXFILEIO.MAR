	.TITLE	RSXFILEIO - RSX RSX11M FILES-ACP I/O MODULE
	.IDENT	'V03-002'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
;
; FACILITY:
;
;	VAX/VMS RSX-11M AME
;
; ABSTRACT:
;
; 	RSX11M FILES-ACP FILES I/O ROUTINES
;
; AUTHOR: R.HEINEN  1-FEB-77
;
; PREVIOUSLY MODIFIED BY:
;
;	Tim Halvorsen
;	Andrew C. Goldstein
;	Peter H. Lipman
;	Michael S. Harvey
;
; MODIFIED BY:
;
;	V001	MSH020		Michael S. Harvey	18-Feb-82
;		Add support for ANSI "a" file names.
;
;		MSH022		Michael S. Harvey	20-Feb-82
;		Handle negative version numbers correctly. In
;		particular, recognize ;-0.
;
;		MSH023		Michael S. Harvey	22-Feb-82
;		Trap attempts to read buffer offset value along with
;		blocksize because VMS doesn't support it yet, while
;		RSX does. Handle the attempt transparently by forcing
;		an offset value of zero to always be returned, rather
;		than aborting the I/O attempt.
;
;	V002	MSH026		Michael S. Harvey	22-Mar-82
;		Eliminate dependencies on VMS Executive symbols.
;
;--
 
;
; EXTERNAL SYMBOLS
;
	$RSXDEF			; DEFINE RSX SYMBOLS
	FCSBT$			; DEFINE FCS BITS
	NBOFF$	DEF$L		; DEFINE RSX FILE NAME BLOCK
	$FIBDEF			; DEFINE FIB BLOCK 
	$ATRDEF				; DEFINE ATTRIBUTE CODES

	.PSECT	RSXCODE,NOWRT,SHR,PIC
	.SBTTL	COMMON FILES I/O INITIATION
 
	.ENABL	LSB
;++
; RSX$FILEIO - RSX RSX11M FILES I/O ROUTINE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS THE ENTRY POINT FROM RSX$QIO FOR FILES I/O FUNCTIONS.
; THE OBJECT IS TO SET UP THE REQUIRED QIO ARGUMENT LIST IN THE SCRATCH
; MEMORY, SET UP THE RSX'S FILE I/O CONTROL BLOCK (FCB) AND SEPARATE THE
; FLOW IN TO THE SPECIFIC FUNCTION HANDLERS.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE QIO AST CONTEXT BLOCK
;	R3 = MAJOR FUNCTION CODE
;	R5 = ADDRESS OF THE OPERATION DPB
;	R6 = IMAGE STACK
;	R8 = ADDRESS OF THE LUT
;	R10 = ADDRESS OF THE IMAGE DATA BASE
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	THIS ROUTINE PASSES CONTROL TO "RSX$ISSUQIO" OR
;	"RSX$DLVRQIOAST" IN THE CASE OF AN ERROR.
;
;	R0 = STATUS OF THE OPERATION
;
;	R2,R10,R11 ARE PRESERVED.
;--
RSX$FILEIO::				; COMMON ENTRY FOR FILES I/O
;
; SET UP THE FCB FOR THIS OPERATION
;
	PUSHL	R8			; SAVE LUT ADDRESS
	MOVL	R2,R7			; COPY QIO CONTEXT
	REMQUE	@I_FCBPOOL(R10),R0	; ADDRESS BLOCK IF ANY
	BVC	2$			; IF V-CLEAR THEN FOUND
	MOVZBL	#FCB_SIZE,R1		; GET THE FCB SIZE
	BSBW	RSX$ALLOCATE		; ALLOCATE THE BLOCK
2$:	MOVL	R0,R8			; COPY THE ADDRESS OF THE BLOCK
;
; SET UP FCB
;
	MOVW	(R5),(R0)+		; SAVE FID POINTER
	MOVW	10(R5),(R0)+		; SAVE FNB POINTER
	PUSHR	#^M<R2,R3,R5>
	MOVC5	#0,(R0),#0,#FCB_SIZE-4,(R0); CLEAR BLOCK
	POPR	#^M<R2,R3,R5>
;
; SET UP QIO PARAMETERS P1 THROUGH P4
;
	MOVAB	FCB_FIB(R8),I_SCRATCH+100(R10); INSERT ADDRESS OF FIB
	MOVZBL	#FIB$C_LENGTH,I_SCRATCH+96(R10);
	MOVAB	I_SCRATCH+96(R10),I_SCRATCH+28(R10) ; -P1- FIB DESCRIPTOR
	MOVAB	FCB_FNAMEDESC(R8),I_SCRATCH+32(R10) ; -P2- FILENAME DESCRIPTOR
	MOVAB	FCB_RESULTDESC+2(R8),I_SCRATCH+36(R10) ; -P3- RESULT STRING SIZE WORD
	MOVAB	FCB_RESULT(R8),FCB_RESULTDESC+4(R8); SET UP TARGET AREA
	MOVZBL	#FCB_FIB-FCB_RESULT,FCB_RESULTDESC(R8);
	SUBL3	#2,I_SCRATCH+36(R10),I_SCRATCH+40(R10) ; -P4- RESULT STRING DESCRIPTOR
;
; COPY ACCESS CONTROL INFO
;
	BICB3	#^X080,9(R5),FIB$L_ACCTL+FCB_FIB(R8);
;
; SET UP THE QIO CONTEXT BLOCK FOR A FILE OPERATION
;
	MOVL	R8,QIO_SECONDBLK(R7)	; INSERT ADDRESS
	BBSS	#QIOV_FILES,QIO_FLAGS(R7),10$; SET TYPE
10$:
;
; CASE TO THE FUNCTION PROCESSOR
;
	MOVL	(SP),R2			; ADDRESS OF LUT
	PUSHAB	B^50$			; SET UP FOR COMMON RETURN
	CASE	R3,LIMIT=#9,<-
		FNAINI,-		; FIND FILE
		IFC,-			; ILLEGAL FUNCTION
		RNAINI,-		; REMOVE FILE
		ENAINI,-		; ENTER FILE
		ACRINI,-		; ACCESS FILE FOR READ
		ACWINI,-		; ACCESS FILE FOR WRITE
		ACEINI,-		; ACCESS FILE FOR EXTEND
		DACINI,-		; DEACCESS FILE
		IFC,-			; READ VIRTUAL
		IFC,-			; WRITE VIRTUAL
		EXTINI,-		; EXTEND FILE
		CREINI,-		; CREATE FILE AND ACCESS
		DELINI,-		; DELETE FILE
		RATINI,-		; READ ATTRIBUTES
		WATINI,-		; WRITE ATTRIBUTES
		APCINI,-		; ACP CONTROL
		>
;
; ILLEGAL FUNCTION
;
IFC:					; THIS IS A RSX BUG
	MOVZWL	#SS$_ILLIOFUNC,R0	; SET UP ERROR CONDITION
	RSB				; RETURN
;
; RETURN FROM FUNCTION PROCESSORS COMES HERE
;
;	R0 = STATUS OF FUNCTION
;
; IF R0 = SS$_NORMAL THEN THE I/O IS ISSUED. IF NOT THEN THE I/O IS
; COMPLETED VIA "RSX$DLVRQIOAST".
;
50$:	MOVL	R7,R2			; RESTORE ADDRESS OF THE CONTEXT BLOCK
	POPL	R8			; RESTORE LUT ADDRESS
	BLBC	R0,60$			; BR IF ERROR IN FUNCTION PROCESSOR
;
; ISSUE QIO
;
	BRW	RSX$ISSUQIO		;
;
; NOOP FUNCTION
;
55$:	MOVZBL	#SS$_NORMAL,R0		; SET TO NOOP FUNCTION
;
; ERROR - DELIVER STATUS VIA AST
;
60$:	BRW	RSX$DLVRQIOAST		;
 
	.DSABL	LSB

	.SBTTL IO.FNA AND IO.RNA - FIND AND REMOVE FILE
 
	.ENABL	LSB
;++
; FNAINI - IO.FNA - FIND FILE NAME INITIAL ROUTINE
; RNAINI - IO.RNA - REMOVE FILE NAME INITIAL ROUTINE
;
; FUNCTIONAL DESCRIPTION:
;
; IO.FNA - FIND FILE NAME CAUSES AN IO$_ACCESS.
; IO.RNA - REMOVE FILE NAME CAUSES AN IO$_DELETE.
;
; THE RSX DPB CONTAINS ONLY THE ADDRESS OF THE FILE NAME BLOCK.
; THE DIRECTORY ID AND FILE NAME ARE EXTRACTED AND PASSED IN THE FIB.
; 
;	FIB$V_ALLNAME <-- NB.SNM
;	FIB$V_ALLTYP  <-- NB.STP
;	FIB$V_ALLVER  <-- NB.SVR
;	FIB$V_WILD    <-- NB.SVR!NB.SNM!NB.STP
;
; THE FILE ID AND RESULTANT FILE NAME ARE RETURNED TO THE RSX FNB.
;
; INPUTS:
;
;	R2 = ADDRESS OF LUT
;	R5 = ADDRESS OF THE OPERATION DPB
;	R6 = ADDRESS OF IMAGE STACK
;	R7 = ADDRESS OF THE QIO CONTEXT BLOCK
;	R8 = ADDRESS OF THE FILE I/O OPERATION BLOCK (FCB)
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	R0 = STATUS OF THE FUNCTION DE-CODE
;
;	R6,R8,R10,R11 ARE PRESERVED.
;--
FNAINI:					; FIND FILE NAME
	MOVZWL	#IO$_ACCESS,I_SCRATCH+12(R10); INSERT PROPER FUNCTION
	BRB	5$			; CONTINUE IN COMMON
RNAINI:					; REMOVE FILE NAME
	MOVZWL	#IO$_DELETE,I_SCRATCH+12(R10); INSERT PROPER FUNCTION
;
; COMMON ROUTINE FOR IO.FNA AND IO.RNA
;
5$:	BSBW	GTDID			; GET DIRECTORY ID
	MOVZWL	N.NEXT(R4),FIB$L_WCC+FCB_FIB(R8); INSERT WILD CARD CONTEXT
;
; SET UP I/O DONE POST PROCESSING ROUTINE
;
	MOVAB	W^FINDDONE,FCB_PC(R8)	;
;
; SET UP PROPER ACCESS CONTROL BITS IN FIB$_NMCTL
;
	BICB3	#^C<NB.STP!NB.SNM!NB.SVR>,-
		N.STAT(R4),FIB$W_NMCTL+FCB_FIB(R8); SET CONTROL BITS
	BEQL	25$			; BR IF NONE
	BBSS	#FIB$V_WILD,FIB$W_NMCTL+FCB_FIB(R8),25$
25$:	BITW	#^X01000,N.STAT(R4)	; NB.WLV SET? IF SO, FID RVN
					; CONTAINS VERSION NUMBER
	BEQL	50$			; IF EQL THEN NO WILDCARD
	BITW	#NB.ANS,N.STAT(R4)	; ANSI "A" FILE NAME BLOCK?
	BNEQ	50$			; IF NEQ YES, NO WILDCARDING HERE
;
; THIS CODE ENABLES WILD CARD SEARCHING TO WORK. THE NEED FOR THIS IS
; BASED ON THE FACT THAT N.NEXT IS NOT QUITE GOOD ENOUGH ON ODS-II
; AT INDICATING WHERE WE WERE LAST IN THE DIRECTORY BEING SEARCHED.
; BEING A STRICTLY POSITIONAL POINTER, IT IS POSSIBLE THAT FILES MAY
; HAVE BEEN CREATED OR DELETED SO THAT THE FILE NAME LAST ACCESSED
; MAY HAVE CHANGED POSITION, OUT FROM UNDER THE POINTER STORED IN
; N.NEXT. HENCE, THE RESULT STRING IS USED AS INPUT TO AUGMENT THE
; WILDCARD SEARCH BY PROVIDING THE FILE NAME THAT WAS LAST ACCESSED.
; THIS WAY, THE CURRENT POSITION IN THE DIRECTORY CAN BE QUICKLY
; DETERMINED.
;
; BECAUSE OF THE STRUCTURE OF THE FILE NAME BLOCK, ALL THE PARTS
; OF THE FILE SPECIFICATION MAY BE MULTIPLEXED TO ACCOMPLISH THIS,
; EXCEPT FOR THE VERSION FIELD. THAT IS WHY IT IS HANDLED SPECIALLY.
;
; THIS MECHANISM HAS NO MEANING ON MAGTAPE VOLUMES. IT WON'T WORK
; IN CASE THE FILE NAME BLOCK CONTAINS AN ANSI "A" FILE NAME.
;
	PUSHR	#^M<R4,R5,R6,R7>	;
	MOVAB	FCB_RESULT(R8),R6	; ADDRESS PLACE TO PUT FILENAME
	MOVL	R6,R7			; COPY ADDRESS
	MOVAB	N.FNAM(R4),R4		; ADDRESS FNB NAME
	BSBW	RSX$R50CVT3		; CONVERT FILE NAME
	MOVB	#^A/./,(R7)+		; INSERT .
	BSBW	RSX$R50CVT1		; CONVERT TYPE
	MOVB	#^A/;/,(R7)+		; INSERT SEMI COLON
	POPR	#^M<R4,R5>		; RESTORE SOME REGISTERS
	CVTWL	N.FID+4(R4),R1		; GET VERSION NUMBER
	BGEQ	30$			; IF GEQ THEN PLUS
	MOVB	#^A/-/,(R7)+		; INSERT MINUS SIGN
	MNEGL	R1,R1			; CONVERT TO POSITIVE
	CMPW	R1,N.FID+4(R4)		; DID VALUE CHANGE?
	BNEQ	30$			; IF NEQ YES, NOT VERSION -0
	CLRL	R1			; VERSION NUMBER IS -0
30$:	CLRL	R2			; RESET ACCUM
	MOVAB	5(R7),R3		; ADDRESS STRING END
	SUBL3	R6,R3,R0		; CALCULATE STRING SIZE
	MOVW	R0,@I_SCRATCH+36(R10)	; SAVE IN QIO P3 PARAMETER
35$:	EDIV	#10,R1,R1,R0		;
	ADDB3	#^A/0/,R0,-(R3)		; INSERT CHARACTER
	CMPL	R3,R7			; CONVERTED ENOUGH?
	BNEQ	35$			; IF NEQ THEN NO
	POPR	#^M<R6,R7>		;
;
; CONVERT FNB FILE NAME TO ASCII IN FIB
;
50$:	BRW	CONSTFILENAME		; CONSTRUCT FILE NAME AND ISSUE QIO
 
	.DSABL 	LSB

	.SBTTL	IO.ENA - ENTER FILE NAME
;++
; ENAINI - IO.ENA - ENTER FILE NAME INITIAL ROUTINE
;
; FUNCTIONAL DESCRIPTION:
;
; IO.ENA CAUSES A IO$_CREATE.
;
; THE RSX DPB PROVIDES AN FNB ONLY AND THE FILE ID AND DIRECTORY ID
; ARE COPIED TO THE FIB. THEN THE FILE NAME IS CONSTRUCTED.
;
; NO CONTROL BITS ARE SET.
;
; THE RESULTANT STRING IS GIVE BACK TO THE FNB ON I/O DONE.
;
; INPUTS:
;
;	R2 = ADDRESS OF LUT
;	R6 = ADDRESS OF THE IMAGE STACK
;	R7 = ADDRESS OF THE QIO AST CONTEXT
;	R8 = ADDRESS OF THE FILE OPERATION CONTROL BLOCK (FCB)
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE 
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	R0 = STATUS OF THE OPERATION
;
;	R6,R7,R8,R10,R11 ARE PRESERVED.
;--
ENAINI:					; ENTER FILE NAME
	MOVZWL	#IO$_CREATE,I_SCRATCH+12(R10); SET PROPER FUNCTION
;
; GET THE DIRECTORY ID
;
	BSBW	GTDID			;
;
; SET UP I/O DONE POST PROCESSING
;
	MOVAB	W^RETURNFILENAME,FCB_PC(R8);
;
; COPY FILE ID
;
	MOVW	N.FID(R4),FIB$W_FID+FCB_FIB(R8);
	MOVL	#^X010001,FIB$W_FID+FCB_FIB+2(R8) ; ASSUME ANSI "A" FNB
	BITW	#NB.ANS,N.STAT(R4)	; IS IT?
	BNEQ	10$			; IF NEQ YES, 1 WORD FID
	MOVL	N.FID+2(R4),FIB$W_FID+FCB_FIB+2(R8)
10$:	BRW	CONSTFILENAME		; CONTRUCT THE FILE NAME AND GO

	.SBTTL	GTDID - GET DIRECTORY ID
;++
; GTDID - GET THE DIRECTORY ID FROM THE FILE NAME BLOCK
;
; FUNCTIONAL DESCRIPTION:
;
; THE ROUTINE VALIDATES THE FNB AND COPIES THE DIRECTORY ID TO THE FCB.
; IF THE FNB IS NOT PRESENT OR NOT ACCESSIBLE THEN AN ERROR IS RETURNED
; TO THE CALLER'S CALLER.
;
; INPUTS:
;
;	R2 = ADDRESS OF LUT
;	R5 = ADDRESS OF THE DPB
;	R6 = ADDRESS OF THE IMAGE STACK
;	R7 = ADDRESS OF THE QIO CONTEXT BLOCK
;	R8 = ADDRESS OF THE FCB
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	R0 = STATUS OF THE OPERATION - IF FAILURE THEN RETURN
;				       IS TO THE CALLER'S CALLER.
;	R4 = ADDRESS OF FILE NAME BLOCK
;
;	R2,R5,R6,R7,R8,R10,R11 ARE PRESERVED.
;--
GTDID:					; COPY THE DIRECTORY ID
	MOVZWL	#SS$_BADPARAM,R0	; ASSUME NO FNB
	MOVZWL	10(R5),R4		; GET THE ADDRESS OF THE FNB
	BEQL	20$			; IF EQL THEN NONE AND ERROR
;
; CHECK ACCESS TO THE FNB
;
	MOVZWL	#SS$_ACCVIO,R0		; ASSUME ACCESS VIOLATION
	IFNORD	#N.UNIT+2,(R4),20$	; READABLE?
;
; COPY DIRECTORY ID. IF THE DIRECTORY ID IS THE MFD, WE ZERO THE RVN.
; THIS IS BECAUSE IN RSX-11M, ON MFD LOOKUPS FCS PASSES DOWN THE BINARY
; UIC FORM OF THE ENTRY NAME BEING SEARCHED FOR IN THE RVN WORD. HANDING
; THIS GARBAGE RVN TO THE ACP CAUSES A NO SUCH VOLUME ERROR, AND HENCE
; MUST BE AVOIDED SO WE CAN STILL RUN UNWASHED 11M IMAGES.
;
; IF THE DEVICE IS A MAGTAPE, THE DIRECTORY ID IS GARBAGE. THIS IS
; FINE SINCE THIS CAUSES THE MAGTAPE ACP TO SEARCH BY FILE NAME
; INSTEAD OF A SEARCH BY FILE ID. WE ARE SET UP TO DO THE FORMER.
;
	MOVW	N.DID(R4),FIB$W_DID+FCB_FIB(R8);
	MOVL	N.DID+2(R4),FIB$W_DID+2+FCB_FIB(R8);
	CMPL	N.DID(R4),#^X40004	; IS THIS THE MFD?
	BNEQ	10$			; BRANCH IF NOT
	CLRW	FIB$W_DID+4+FCB_FIB(R8)	; IF YES, CLEAR RVN
;
; MAKE FIND, ENTER, AND REMOVE OPERATIONS FOR THE MFD ON ROOTED
; DEVICES LIKE "LB0:" ACTUALLY OPERATE ON THE ROOT DIRECTORY INSTEAD.
;
	MOVL	LUT_ROOT_DID(R2),R0	; SEE IF ROOT DIRECTORY ID IS SET
	BEQL	10$			; BRANCH IF NOT, USE MFD
	MOVL	R0,FIB$W_DID+FCB_FIB(R8); GET THE ROOT DID FOR LB
	MOVW	LUT_ROOT_DID+4(R2),FIB$W_DID+4+FCB_FIB(R8); GET RVN AS WELL
10$:	MOVZBL	#SS$_NORMAL,R0		; SET SUCCESS
	RSB
;
; ERROR RETURN
;
20$:	TSTL	(SP)+			; POP CALLER'S RETURN
	RSB				; RETURN

	.SBTTL	FINDDONE - I/O DONE ROUTINE FOR IO.FNA AND IO.RNA
;++
; FINDDONE - I/O DONE ROUTINE FOR IO.FNA AND IO.RNA
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED ON SUCCESSFUL COMPLETION OF A IO.FNA OR IO.RNA.
; IT IS ENTERED FROM THE I/O DONE AST SERVICE ROUTINE.
; THE ACTION IS TO RETURN THE FILE ID AND THE RESULTANT FILE NAME.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE QIO AST CONTEXT BLOCK
;	R3 = ADDRESS OF THE FCB FOR THIS OPERATION
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	R2,R3,R10,R11 ARE PRESERVED.
;--
FINDDONE:				;
;
; RETURN THE FILE ID IN THE FILE NAME BLOCK
;
	MOVZWL	FCB_FNB(R3),R4		; GET THE ADDRESS OF THE FILE NAME BLOCK
	IFNOWRT	#6,(R4),RETURNFILENAME	; SKIP IF NO ACCESS
	MOVW	FIB$W_FID+FCB_FIB(R3),(R4) ; RETURN FILE ID
	BITW	#NB.ANS,N.STAT(R4)	; ANSI "A" FNB
	BNEQ	10$			; IF NEQ YES, 1 WORD FID
	MOVL	FIB$W_FID+2+FCB_FIB(R3),N.FID+2(R4) ; GET REST OF FID
10$:	MOVW	FIB$L_WCC+FCB_FIB(R3),N.NEXT(R4) ; RETURN WILD CARD CONTEXT
;
; RETURN THE FILE NAME
;

	.SBTTL	RETURNFILENAME - RETURN FILE NAME FOR IO.ENA,IO.FNA,IO.RNA
;++
; RETURNFILENAME - RETURN FILE NAME
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED ON I/O DONE FOR IO.FNA,IO.RNA AND IO.ENA
; IF THE OPERATION WAS SUCCESSFUL. THE ACTION IS TO OUTPUT THE FILE
; NAME TO THE FILE NAME BLOCK FROM THE RESULTANT FILE NAME.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE QIO AST CONTEXT BLOCK
;	R3 = ADDRESS OF THE OPERATION FCB
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	NONE
;
;	R2,R3,R10,R11 ARE PRESERVED.
;--
RETURNFILENAME:				; RETURN FILE NAME
	MOVZWL	FCB_FNB(R3),R4		; GET ADDRESS OF FNB
	BEQL	50$			; IF NONE THEN DONE
	IFNOWRT	#N.UNIT+2,(R4),50$	; IF ACCESS VIOLATION THEN DONE
	MOVZWL	FCB_RESULTDESC+2(R3),R0	; GET SIZE
	BEQL	50$			; IF EQL THEN DONE
	MOVL	FCB_RESULTDESC+4(R3),R7	; GET ADDRESS
	CLRB	(R7)[R0]		; SET END BYTE
	BSBW	RSX$RETFNAME		; RETURN FILENAME TO FNB
50$:	RSB				; RETURN

	.SBTTL	CONSTFILENAME - CONSTRUCT FILE NAME FORM FNB
;++
; CONSTFILENAME - BUILD AN ASCII FILE NAME FROM THE RSX FNB
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS THE FINAL PROCESSING FOR IO.FNA,IO.RNA AND IO.ENA.
; IT EXTRACTS THE FILE NAME FROM AN FCS-11 FNB, CONVERTS IT FROM EITHER
; RAD50 OR AS A STORED ANSI "A" FILE NAME TO AN ASCII STRING, AND
; STORES IT IN THE CURRENT FCB.
;
; INPUTS:
;
;	R2 = ADDRESS OF LUT
;	R4 = ADDRESS OF THE FNB
;	R5 = ADDRESS OF THE CURRENT QIO DPB
;	R7 = ADDRESS OF THE QIO AST CONTEXT BLOCK
;	R8 = ADDRESS OF THE FCB
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA AREA
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	R0 = STATUS OF THE OPERATION
;
;	SS$_NORMAL
;
;	R6,R7,R8,R10,R11 ARE PRESERVED.
;--
CONSTFILENAME:				; CONSTRUCT FILE NAME FROM FNB
	PUSHL	R7 			; SAVE QIO CONTEXT ADDRESS
	MOVAB	FCB_FNAME(R8),R7	; ADDRESS THE TARGET AREA
	MOVL	R7,FCB_FNAMEDESC+4(R8)	;
;
; IF THE WILDCARD FILENAME IS SET (NB.SNM) AND THIS IS AN ANSI "A"
; FILE NAME BLOCK, ALWAYS GENERATE A STANDARD NULL FILE STRING SO
; THE MAGTAPE ACP WON'T COMPLAIN. PULL THE VERSION OUT OF THE FNB
; FOR THIS STRING.
;
	BBC	#FIB$V_ALLNAM,N.STAT(R4),5$ ; BRANCH IF NOT WILDCARD FILENAME
	BITW	#NB.ANS,N.STAT(R4)	; ANSI "A" FILE NAME BLOCK?
	BEQL	5$			; IF EQL NO, READ FNB
	PUSHAB	7$			; SET UP RETURN ADDRESS
	PUSHR	#^M<R2,R3,R4,R5,R6>	; SAVE SOME CONTEXT
	MOVL	R7,R6			; COPY START ADDRESS
	MOVAB	N.FVER(R4),R4		; POINT TO VERSION FIELD
	MOVB	#^A/./,(R7)+		; NULL FILE NAME AND TYPE
	BRW	RSX$BLDVER		; GO GET VERSION NUMBER

5$:	BSBW	RSX$BLDFNAME		; BUILD FILE NAME FROM FNB
7$:	MOVL	R0,FCB_FNAMEDESC(R8)	; INSERT FILE STRING SIZE
;
; ENTER COMMON FILES I/O CODE FOR QIO
;
	MOVZWL	#SS$_NORMAL,R0		; SET SUCCESS STATUS
	MOVL	(SP)+,R7		; RESTORE QIO CONTEXT ADDRESS
	RSB				; AND RETURN
	.PAGE
	.SBTTL	IO.ACR - IO.ACW - IO.ACE PROCESSORS
;++
; ACRINI - ACCESS FOR READ
; ACWINI - ACCESS FOR WRITE
; ACEINI - ACCESS FOR EXTEND
;
; FUNCTIONAL DESCRIPTION:
;
; IO.ACR CAUSES AN IO$_ACCESS!IO$M_ACCESS.
;
; IO.ACE AND IO.ACW CAUSE AN IO$_ACCESS!IO$M_ACCESS WITH FIB$V_WRITE=1.
;
; FIB$W_FID <-- RSX DPB PARAM #1
; FIB$B_WSIZE <-- RSX DPB PARAM #5
; ATTRIBUTE LIST CONSTRUCTED FROM RSX PARAM #2.
;
; INPUTS:
;
;	R2 = ADDRESS OF LUT
;	R5 = ADDRESS OF THE OPERATION DPB
;	R6 = ADDRESS OF THE IMAGE STACK
;	R7 = ADDRESS OF THE QIO AST CONTEXT
;	R8 = ADDRESS OF THE FILE OPERATION CONTROL BLOCK (FCB)
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	R0 = STATUS OF THE OPERATION
;
;	R5,R6,R7,R8,R10,R11 ARE PRESERVED.
;--
ACWINI:					; ACCESS FOR WRITE
ACEINI:					; ACCESS FOR EXTEND
	BBSS	#FIB$V_WRITE,FIB$L_ACCTL+FCB_FIB(R8),ACRINI; SET CONTROL BIT
ACRINI:					; ACCESS FOR READ
	MOVZWL	#IO$_ACCESS!IO$M_ACCESS,I_SCRATCH+12(R10); SET FUNCTION
;
; COPY FILE ID FROM RSX FID
;
	BSBW	GTFID			; GET THE FILE ID
;
; SET UP WINDOW SIZE
;
	MOVB	8(R5),FIB$B_WSIZE+FCB_FIB(R8)	; 
;
; BUILD ATTRIBUTE LIST
;
	BRW	CONSTATTRIBUTE		; BUILD LIST

	.SBTTL	IO.CRE  FUNCTION PROCESSOR
;++
; CREINI - IO.CRE - CREATE FILE
;
; FUNCTIONAL DESCRIPTION:
;
; IO.CRE CAUSES AN IO$_CREATE!IO$M_CREATE.
;
; FIB$W__FID <-- RSX DPB #1
; FIB$L_EXSZ <-- RSX DPB #3,4
; 
; ATTRIBUTE LIST CONSTRUCTED FROM RSX DPB #2.
;
; INPUTS:
;
;	R5 = ADDRESS OF THE OPERATION DPB
;	R6 = ADDRESS OF THE IMAGE STACK
;	R7 = ADDRESS OF TH QIO AST CONTEXT 
;	R8 = ADDRESS OF THE FILE I/O CONTROL BLOCK (FCB)
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	R0 = STATUS OF THE OPERATION
;
;	SS$_NORMAL
;	SS$_ACCVIO - ACCESS VIOLATION ON FID OR ATTRIBUTE LIST
;
;	R5,R6,R7,R8,R10,R11 ARE PRESERVED.
;--
CREINI:					; CREATE FILE
	MOVZWL	#IO$_CREATE!IO$M_CREATE,I_SCRATCH+12(R10); SET FUNCTION CODE
;
; SET UP I/O DONE COMPLETION ROUTINE
;
	MOVAB	B^CREDONE,FCB_PC(R8)	; I/O DONE GOES THERE
;
; COPY EXTEND INFORMATION
;
	BICW3	#^X0FF00,5(R5),FIB$W_EXCTL+FCB_FIB(R8); SET CONTROL BITS
	MOVW	6(R5),FIB$L_EXSZ+FCB_FIB(R8); INSERT EXTEND SIZE
	MOVZBW	4(R5),FIB$L_EXSZ+2+FCB_FIB(R8);
;
; SET UP ATTRIBUTES CONTROL LIST
;
	MOVAB	FCB_ATTRIBS(R8),R3	; ADDRESS ATTRIBUTE LIST
	MOVL	#<2@16>+2,(R3)+		; INSERT ATTRIBUTE AND SIZE
	MOVAL	I_SCRATCH+92(R10),(R3)	; ADDRESS PLACE FOR FILE PROTECTION
	PUSHAL	@(R3)+			; ADDRESS TO RETURN PROTECTION
	CLRL	-(SP)			; SPECIFY NO NEW PROTECTION
	CALLS	#2,G^SYS$SETDFPROT	; GET PROTECTION
	BRW	CONSTATTR2		; CONTINUE LIST

	.SBTTL	CREDONE - I/O DONE FOR CREATE
;++
; CREDONE - I/O DONE PROCESSING FOR IO.CRE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED ON I/O DONE FOR IO.CRE IF THE STATUS
; OF THE OPERATION WAS SUCCESSFUL. THE ACTION IS TO COPY THE FILE
; ID INTO THE QIO SPECIFIED PLACE.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE AIO AST CONTEXT BLOCK +4
;	R3 = ADDRESS OF THE OPERATION FCB
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	R2,R3,R10,R11 ARE PRESERVED.
;--
CREDONE:				; IO.CRE I/O DOEN PROCESSING
	MOVZWL	(R3),R4			; ADDRESS TARGET FOR FID
	BEQL	MOVEIOSB		; IF EQL THEN NONE
;
; CHECK FID ACCESS
;
	IFNOWRT	#6,(R4),MOVEIOSB	; SKIP PROCEEDURE IF FAILURE
;
; COPY FID
;
	MOVW	FIB$W_FID+FCB_FIB(R3),(R4)+;
	MOVL	FIB$W_FID+FCB_FIB+2(R3),(R4);
;
; MOVE EXTEND SIZE TO HIS IOSB
;
MOVEIOSB:				; COPY SECOND WORD OF IOSB TO HIS IOSB
	MOVW	QIO_IOSB+4(R2),QIO_IOSB+2(R2); I/O DONE WILL MOVE THIS AS TRANSFER SIZE
	MOVZWL	ACB_UPRM(R2),R0		; GET ADDRESS OF HIS IOSB
	BEQL	10$			; IF EQL THEN NONE
	IFNOWRT	#4,(R0),10$		; ACCESSIBLE?
	MOVB	QIO_IOSB+6(R2),1(R0)	; INSERT THE REST
10$:	RSB

	.SBTTL IO.EXT - EXTEND FILE
;++
; EXTINI - IO.EXT - FUNCTION PROCESSOR
;
; FUNCTIONAL DESCRIPTION:
;
; IO.EXT CAUSES AN IO$_MODIFY.
;
; FIB$W_FID <-- RSX DPB PARAM #1
; EXTEND CONTROL FROM RSX DPB PARAM #3,4
;
; INPUTS:
;
;	R2 = ADDRESS OF LUT
;	R5 = ADDRESS OF THE OPERATION DPB
;	R6 = ADDRESS OF THE IMAGE STACK
;	R7 = ADDRESS OF THE QIO AST CONTEXT
;	R8 = ADDRESS OF THE FILE CONTROL BLOCK (FCB)
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	R0 = STATUS OF THE OPERATION
;
;	R5,R6,R7,R8,R10,R11 ARE PRESERVED.
;--
EXTINI:
	MOVZBL	#SS$_NORMAL,R0		; ASSUME NO ERROR
	MOVZWL	#IO$_MODIFY,I_SCRATCH+12(R10); SET FUNCTION
	TSTW	(R5)			; ANY FID?
	BEQL	10$			; IF EQL THEN NO
	BSBW	GTFID			; COPY THE FILE ID
;
; SET UP EXTEND DATA
;
10$:	BICW3	#^X0FF00,5(R5),FIB$W_EXCTL+FCB_FIB(R8); INSERT CONTROL
	MOVAB	W^MOVEIOSB,FCB_PC(R8)	; SET UP POST PROCESSING
	MOVW	6(R5),FIB$L_EXSZ+FCB_FIB(R8); INSERT EXTEND SIZE
	MOVZBW	4(R5),FIB$L_EXSZ+2+FCB_FIB(R8);
	BRW	CONSTATTRIBUTE		; GET PLACEMENT ATTRIBUTES, IF ANY

	.SBTTL IO.APC - ACP CONTROL
;++
; APCINI - IO.APC - FUNCTION PROCESSOR
;
; FUNCTIONAL DESCRIPTION:
;
; IO.APC CAUSES AN IO$_ACPCONTROL.
;
; FIB$W_CNTRLFUNC <-- HIGH BYTE OF EXTEND SIZE
; FIB$L_CNTRLVAL <-- LOW WORD OF ENTEND SIZE
;
; INPUTS:
;
;	R2 = ADDRESS OF LUT
;	R5 = ADDRESS OF THE OPERATION DPB
;	R6 = ADDRESS OF THE IMAGE STACK
;	R7 = ADDRESS OF THE QIO AST CONTEXT
;	R8 = ADDRESS OF THE FILE CONTROL BLOCK (FCB)
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	R0 = STATUS OF THE OPERATION
;
;	R5,R6,R7,R8,R10,R11 ARE PRESERVED.
;--
APCINI:					; ACP CONTROL
	MOVZBL	#SS$_NORMAL,R0		; ASSUME NO ERROR
	MOVZWL	#IO$_ACPCONTROL,I_SCRATCH+12(R10); SET FUNCTION
	TSTW	(R5)			; ANY FID?
	BEQL	10$			; IF EQL THEN NO
	BSBW	GTFID			; COPY THE FILE ID
10$:	CVTWL	6(R5),FIB$L_CNTRLVAL+FCB_FIB(R8); INSERT VALUE
	MOVZBW	4(R5),FIB$W_CNTRLFUNC+FCB_FIB(R8); INSERT FUNCTION
	RSB				; RETURN

	.SBTTL	IO.RAT - IO.WAT - IO.DAC - FUNCTION PROCESSORS
 
	.ENABL	LSB
;++
; RATINI - READ ATTRIBUTES
; WATINI - WRITE ATTRIBUTES
; DACINI - DEACCESS FILE
;
; FUNCTIONAL DESCRIPTION:
;
; IO.RAC CAUSES AN IO$_ACCES.
; IO.WAC CAUSES AN IO$_MODIFY
; IO.DAC CAUSES AN IO$_DEACCESS
;
; FIB$W_FID <-- FROM RSX DPB PARAM #1
; ATTRIBUTE CONTROL LIST CONSTRUCTED FROM RSX DPB PARAM #2
;
; INPUTS:
;
;	R2 = ADDRESS OF LUT
;	R5 = ADDRESS OF THE OPERATION DPB
;	R6 = ADDRESS OF THE IMAGE STACK
;	R7 = ADDRESS OF THE QIO CONTEXT BLOCK
;	R8 = ADDRESS OF THE FILE OPERATION CONTROL BLOCK (FCB)
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;	
;	R0 = STATUS OF THE OPERATION
;
;	R5,R6,R7,R8,R10,R11 ARE PRESERVED.
;--
RATINI:					; READ ATTRIBUTES
	MOVZWL	#IO$_ACCESS,I_SCRATCH+12(R10); SET FUNCTION
	BRB	15$			; CONTINUE IN COMMON
WATINI:					; WRITE ATTRIBUTES
	MOVZWL	#IO$_MODIFY,I_SCRATCH+12(R10); SET FUNCTION
	BRB	15$			;
DACINI:					; DEACCESS FILE
	MOVZWL	#IO$_DEACCESS,I_SCRATCH+12(R10); SET FUNCTION
;
; COPY FILE ID
;
15$:	TSTW	(R5)			; ANY FID PRESENT?
	BEQL	20$			; IF EQL THEN NO
	BSBW	GTFID			; 
;
; GET ATTRIBUTES LIST
;
20$:	BRW	CONSTATTRIBUTE		; CONSTRUCT LIST
 
	.DSABL	LSB

	.SBTTL	IO.DEL - FUNCTION PROCESSOR
;++
; DELINI - IO.DEL - DELETE FILE 
;
; FUNCTIONAL DESCRIPTION:
;
; IO.DEL CAUSES--
;
; IF EX.ENA = 0 THEN IO$_DELETE!IO$M_CREATE.
; IF EX.ENA=1 THEN IO$_MODIFY WITH FIB$V_TRUNC = 1.
;
; FIB$W_FID <-- RSX DPB PARAM #1
;
; INPUTS:
;
;	R2 = ADDRESS OF LUT
;	R5 = ADDRESS OF THE OPERATION DPB
;	R6 = ADDRESS OF THE IMAGE STACK
;	R7 = ADDRESS OF THE QIO AST CONTEXT BLOCK
;	R8 = ADDRESS OF THE FILE OPERATION CONTROL BLOCK (FCB)
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	R0 = STATUS OF THE OPERATION
;
;	R5,R6,R7,R8,R10,R11 ARE PRESERVED.
;--
DELINI:					; DELETE FILE
;
; GET THE FID COPIED
;
	BSBW	GTFID			;
	MOVAB	W^MOVEIOSB,FCB_PC(R8)	; SET UP PSOT PROCESSING
;
; TEST FOR EXTEND ENABLE
;
10$:	BBS	#15,4(R5),20$		; BR IF ENABLED
	MOVZWL	#IO$_DELETE!IO$M_DELETE,I_SCRATCH+12(R10); SET FUNCTION
	BRB	30$			; AND CONTINUE
;
; TRUNCATE FILE
;
20$:	MOVZWL	#IO$_MODIFY,I_SCRATCH+12(R10); SET FUNCTION
	BBSS	#FIB$V_TRUNC,FIB$W_EXCTL+FCB_FIB(R8),25$; SET TRUNCATE BIT
30$:	MOVZBL	#SS$_NORMAL,R0		; RETURN STATUS
25$:	MOVW	6(R5),FIB$L_EXVBN+FCB_FIB(R8); INSERT EXTEND SIZE
	MOVZBW	4(R5),FIB$L_EXVBN+2+FCB_FIB(R8);
	INCL	FIB$L_EXVBN+FCB_FIB(R8)	;
	RSB	

	.SBTTL	GTFID - GET FILE ID
;++
; GTFID - GET THE FILE ID FROM THE FILE NAME BLOCK
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE VALIDATES THE FILE ID BLOCK (6 BYTES) AND COPIES THE
; FILE ID TO THE FCB. IF THE FILE ID BLOCK IS NOT PRESENT OR NOT
; ACCESSIBLE, THEN AN ERROR IS RETURNED TO THE CALLER'S CALLER.
;
; INPUTS:
;
;	R2 = ADDRESS OF LUT
;	R5 = ADDRESS OF THE DPB
;	R6 = ADDRESS OF THE IMAGE STACK
;	R7 = ADDRESS OF THE QIO CONTEXT BLOCK
;	R8 = ADDRESS OF THE FCB
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	R0 = STATUS OF THE OPERATION - IF FAILURE THEN RETURN
;				       IS TO THE CALLER'S CALLER.
;
;	R2,R5,R6,R7,R8,R10,R11 ARE PRESERVED.
;--
GTFID:					; COPY THE FILE ID
	MOVZWL	#SS$_BADPARAM,R0	; ASSUME NO FILE ID BLOCK
	MOVZWL	(R5),R4			; GET ADDRESS OF FILE ID BLOCK
	BEQL	20$			; IF EQL THEN NONE AND ERROR
;
; CHECK ACCESS TO THE FILE ID BLOCK
;
	MOVZWL	#SS$_ACCVIO,R0		; ASSUME ACCESS VIOLATION
	IFNORD	#6,(R4),20$		; READABLE?
;
; COPY FILE ID
;
	MOVW	N.FID(R4),FIB$W_FID+FCB_FIB(R8);
	MOVL	#^X010001,FIB$W_FID+2+FCB_FIB(R8) ; ASSUME MAGTAPE FID
	CMPB	LUT_TYPE(R2),#LUTC_TAPE	; MAGTAPE FID?
	BEQL	10$			; IF EQL YES, 1 WORD INPUT FID
	MOVL	2(R4),FIB$W_FID+2+FCB_FIB(R8) ; GET FILE SEQUENCE AND RVN
10$:	MOVZBL	#SS$_NORMAL,R0		; SET SUCCESS
	RSB				;
;
; ERROR RETURN
;
20$:	TSTL	(SP)+			; POP CALLER'S RETURN
	RSB				; RETURN

	.SBTTL	CONSTATTRIBUTE	- CONSTRUCT ATTRIBUTE LIST
;++
; CONSTATTRIBUTE - CONSTRUCT ATTRIBUTE LIST FROM RSX LIST
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE CONSTRUCTS A VAX/VMS FILES I/O ATTRIBUTE LIST FROM
; AN RSX FILES I/O ATTRIBUTE LIST. THE ATTRIBUTE LIST IS CONTAINED
; IN THE FCB.
;
; INPUTS:
;
;	R5 = ADDRESS OF THE OPERATION DPB
;	R6 = ADDRESS OF THE IMAGE STACK
;	R7 = ADDRESS OF THE QIO AST CONTEXT BLOCK
;	R8 = ADDRESS OF THE FILE I/O CONTROL BLOCK
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	R0 = STATUS ODF THE OPERATION
;
;	SS$_ACCVIO - ACCESS VIOLATION ON THE ATTRIBUTE LIST
;
;	R5,R6,R7,R8,R10,R11 ARE PRESERVED.
;--
CONSTATTRIBUTE:				; CONSTRUCT ATTRIBUTE LIST
	MOVAB	FCB_ATTRIBS(R8),R3	; COPY ADDRESS
CONSTATTR2:
;
; GET THE ATTRIBUTE LIST
;
	MOVZWL	2(R5),R4		; GET ADDRESS OF LIST
	BNEQ	5$			; IF NEQ THEN IT'S THERE
	BRW	30$			; DONE
3$:	BRW	100$			; ACCESS VIOLATION ON ATTRIBUTE LIST
4$:	BRW	25$			; DONE

5$:	PUSHL	R7			; PRESERVE R7
	
;
; CHECK ACCESS TO RSX ATTRIBUTE LIST
;
10$:	IFNORD	#1,(R4),3$		; ATTRIBUTE DESCRIPTOR THERE?
	CVTBL	(R4)+,R0		; GET THE REQUEST TYPE
	BEQL	4$			; IF EQL THEN DONE
	BGTR	15$			; IF GTR THEN NO CONVERT NEEDED
	MNEGL	R0,R0			; CONVERT TO ABS VALUE
15$:	IFNORD	#3,(R4),3$		; PROBE REMAINDER
	MOVZBW	(R4)+,(R3)+		; INSERT SIZE
	BNEQ	20$			; IF NEQ THEN SPECIFIED
	MOVW	#512,-2(R3)		; INSERT 512
20$:	MOVZBW	R0,(R3)+		; INSERT TYPE IN LIST
;
; THE NORMAL CODE PATH FOR SPECIFICATION OF FILE NAMES AS AN ATTRIBUTE
; INVOLVES ONLY THE ATTRIBUTE ATR$C_FILNAM. THIS ALWAYS CONTAINS THE
; FILE NAME, FILE TYPE AND VERSION IN RAD50, REPLETE WITH PUNCTUATION.
; THIS ATTRIBUTE IS DIRECTLY TRANSLATABLE FROM RSX TO VMS FOR ALL BUT
; THE FOLLOWING CASE. IF THE FILE NAME IS OF ANSI 'A' TYPE, FCS STILL
; USES THE RAD50 FILE NAME ATTRIBUTE WHICH CAN'T WORK, OF COURSE. SO,
; FCS PROVIDES MORE CONTEXT TO WORK AROUND THIS PROBLEM. IF THE FILE
; NAME IS OF ANSI 'A' FORM, THEN THE FILE NAME BLOCK IS PROVIDED IN
; RSX P6. THEN, WHEN THIS CODE ENCOUNTERS THE ATR$C_FILNAM ATTRIBUTE,
; IT WILL EXAMINE THE FNB, IF THERE, AND IF IT'S AN ANSI 'A' FNB, THEN
; WE WILL REPLACE THE ATR$C_FILNAM ATTRIBUTE WITH THE ATR$C_ASCNAME
; ATTRIBUTE AND CREATE THE APPROPRIATE STRING IN FCB_ASCNAM. OTHERWISE,
; IT SIMPLY TRANSLATES THE ATR$C_FILNAM ATTRIBUTE FROM RSX TO VMS AS
; USUAL.
;
; NOTE THAT IF IT IS NECESSARY TO REPLACE THE ATR$C_FILNAM ATTRIBUTE
; WITH THE ATR$C_ASCNAME ATTRIBUTE, THE STRING THAT GOES INTO FCB_ASCNAM
; IS ONLY THE 17 CHARACTER ANSI 'A' FILE NAME, STRAIGHT OUT OF THE
; FNB. A SPECIAL SHORT STRING MUST BE SET UP FOR THE VMS P2 PARAMETER
; THAT HAS THE VERSION SPECIFIED.
;
	CMPB	R0,#ATR$C_FILNAM	; FILE NAME STRING ATTRIBUTE?
	BNEQ	21$			; IF NEQ NO, CONTINUE PROCESSING
	MOVZWL	10(R5),R0		; IS FILE NAME BLOCK PRESENT?
	BEQL	22$			; IF EQL NO, NO SPECIAL ACTION
	IFNORD	#N.UNIT+2,(R0),100$
	BITW	#NB.ANS,N.STAT(R0)	; ANSI "A" FILE NAME?
	BEQL	22$			; IF EQL NO, NO SPECIAL ACTION
	MOVL	#<ATR$C_ASCNAME@16>!17,-4(R3) ; RESET ATTRIBUTE
	MOVQ	N.ANM1(R0),FCB_ASCNAM(R8) ; GET FIRST 8 CHARACTERS
	MOVL	N.ANM1+8(R0),FCB_ASCNAM+8(R8) ; GET NEXT 4 CHARACTERS
	MOVL	N.ANM2(R0),FCB_ASCNAM+12(R8) ; GET NEXT 4 CHARACTERS
	MOVB	N.ANM2+4(R0),FCB_ASCNAM+16(R8) ; GET LAST CHARACTER
	MOVAB	FCB_ASCNAM(R8),(R3)+	; SET ATTRIBUTE ADDRESS
	TSTW	(R4)+			; SKIP REPLACED ATTRIBUTE ADDRESS
	MOVZBL	#6,FCB_FNAMEDESC(R8)	; SET SIZE OF VERSION INPUT STRING
	PUSHAB	10$			; SET RETURN ADDRESS
	PUSHR	#^M<R2,R3,R4,R5,R6>	; SAVE REGISTERS
	MOVAB	N.FVER(R0),R4		; POINT TO VERSION CELL IN FNB
	MOVAB	FCB_FNAME(R8),R7	; POINT TO DESTINATION STRING - P2
	MOVL	R7,FCB_FNAMEDESC+4(R8)	; STORE ADDRESS IN DESCRIPTOR
	BRW	RSX$BLDVER		; GO BUILD VERSION STRING
;
; THE FOLLOWING CODE SOLVES A TEMPORARY INCOMPATIBILITY BETWEEN VMS
; AND RSX-11. THE PROBLEM IS THAT A VALID LENGTH FOR THE BLOCKSIZE
; ATTRIBUTE (TAPES) IS 2 OR 3 BYTES. THE OLD VALUE IS 2 BYTES AND
; INDICATES THE STANDARD 2 BYTE FIELD FOR RECEIVING THE BLOCKSIZE.
; THE NEW VALUE, 3 BYTES, INDICATES THAT A BYTE FOLLOWS THE BLOCKSIZE
; FIELD WHICH WILL RECEIVE THE BLOCK OFFSET VALUE. FOR THIS RELEASE
; OF VMS, THIS LATTER FEATURE IS NOT SUPPORTED. THIS CODE INTERCEPTS
; THE 3 BYTE REFERENCE, CONVERTS TO IT A 2 BYTE REFERENCE AND CLEARS
; THE THIRD BYTE, FORCING THE OFFSET VALUE TO ALWAYS BE RETURNED AS
; ZERO. AFTER THIS FEATURE IS ADDED TO VMS, THIS CODE MAY BE REMOVED.
;
21$:	CMPL	R0,#ATR$C_BLOCKSIZE	; BLOCKSIZE ATTRIBUTE?
	BNEQ	22$			; IF NEQ NO
	CMPW	-4(R3),#2		; 2 BYTE REFERENCE?
	BEQL	22$			; IF EQL YES, COMPATIBLE
	MOVZBW	#2,-4(R3)		; CONVERT TO 2 BYTE REFERENCE
	MOVZWL	(R4),R0			; GET BUFFER ADDRESS
	IFNOWRT	#3,(R0),100$		; CHECK FOR WRITE ACCESS
	CLRB	2(R0)			; FORCE OFFSET VALUE TO ZERO
;
; END OF SPECIAL CASE CODE TO BE REMOVED IN A FUTURE RELEASE
22$:	MOVZWL	(R4)+,(R3)+		; INSERT ADDRESS TO STORE
	BRW	10$			; AND CONTINUE
25$:	CLRL	(R3)+			; END LIST
	MOVL	(SP)+,R7		; RESTORE R7
	MOVAB	FCB_ATTRIBS(R8),I_SCRATCH+44(R10); INSERT ADDRESS IN QIO ARGS
30$:	MOVZWL	#SS$_NORMAL,R0		; SET STATUS
	RSB				; RETURN
;
; ACCESS VIOLATION ON ATTRIBUTE LIST
;
100$:	MOVZWL	#SS$_ACCVIO,R0		; SET STATUS
	RSB				; RETURN
;
	.END
