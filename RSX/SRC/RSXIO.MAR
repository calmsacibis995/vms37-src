	.TITLE	RSXIO - RSX11M GMCR$,RCVD$,RCVX$,SDAT$ DIRECTIVES
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:
;
;	VAX/VMS RSX11M AME
;
; ABSTRACT:
;
;	RSX11M MISC. I/O DIRECTIVES
;
; AUTHOR:
;
;	R.HEINEN 4-NOV-76
;
; MODIFIED BY:
;
;	V005	MSH009		Michael S. Harvey	4-Sep-1981
;		Spawn CREF with the null device as its TI:, so that
;		null files created when the spawning process's TI:
;		is a process permanent file aren't created.
;
;	V004	TMH0004		Tim Halvorsen		24-Sep-1980
;		Fix CRF-11 support; wait for CRF subprocess completion
;		before exiting image so that the mailbox isn't deleted
;		before CRF even gets a chance to run, fix name of image
;		to SYS$SYSTEM:CRF rather than just CRF.
;
;	V003	TMH0003		Tim Halvorsen		12-May-1980
;		Do not use $DSW macro to set alternate successes (IS.SET)
;		because the $DSW macro also sets the carry bit.
;
;--
;
; EXTERNAL SYMBOLS
;
	$RSXDEF			; DEFINE RSX SYMBOLS
	DRERR$			; DEFINE RSX DIRECTIVE STATUS CODES
	$DEVDEF			; DEFINE DEVICE CHARACTERISTICS BITS
	$JPIDEF			; DEFINE GETJPI SYMBOLS
	$SMRDEF			; DEFINE SYMBIONT SYMBOLS
 

	.PSECT	RSXCODE,NOWRT,SHR,PIC
	.SBTTL	RSX$GMCR - RSX11M GMCR$ DIRECTIVE
;++
; RSX$GMCR - RSX11M GET MCR LINE DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS A RSX DIRECTIVE HANDLER WHICH IMPLEMENTS AN RSX11M
; "GMCR$" DIRECTIVE.
;
; INPUT PARAMETERS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = CM IMAGE STACK ADDRESS
;	R10 = ADDRESS OF CM IMAGE DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUT PARAMETERS:
;
;	R10,R11 ARE PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	THE PROPER DIRECTIVE STATUS IS PLACED IN THE IMAGE DSW
;	ALONG WITH THE PROPER SETTING OF THE C-BIT.
;
; DSW RETURN CODES:
;
;	IS.SUC	SUCCESSFUL
;	IE.AST	NO DATA AVAILABLE
;--
RSX$GMCR::				; GET MCR LINE DIRECTIVE
	CLRL	R0
	PUSHAB	I_SCRATCH(R10)		; ADDRESS TARGET
	CALLS	#1,@I_CMDROUT(R10)	; CALL CALLER BACK
	BLBC	R0,20$			; IF LOW CLEAR THEN NONE
	CMPW	#80,I_SCRATCH(R10)	; 80 OR GREATER?
	BGEQU	5$			; IF GEQU THEN OK
	MOVZBL	#80,I_SCRATCH(R10)	; SET MAX SIZE
5$:	MOVW	I_SCRATCH(R10),H.DSW(R11); INSERT COMMAND SIZE
	BEQL	20$			; IF EQL THEN ERROR
;
; MOVE THE COMMAND TO THE USER BUFFER - BUFFER HAS BEEN VALIDATED
;
	MOVC3	I_SCRATCH(R10),@I_SCRATCH+4(R10),(R5); MOVE COMMAND TEXT
	CMPW	#80,I_SCRATCH(R10)	; EXACTLY 80?
	BEQL	10$			; IF EQL THEN YES
	MOVB	#^X0D,(R3)		; INSERT CR AS TERMINATOR
10$:	RSB				; RETURN
;
; NO COMMAND LINE
;
20$:	$DSW	#IE.AST			;

	.SBTTL	RSX$RCVD/RSX$RCVX - RSX11M RCVD$ AND RCVX$ DIRECTIVES
 
	.ENABL	LSB
;++
; RSX$RCVD - RSX11M RECEIVE DATA DIRECTIVE
; RSX$RCVX - RSX11M RECEIVE DATA OR EXIT DIRECTIVE
; RSX$RCST - RSX11M RECEIVE DATA OR STOP DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS A RSX DIRECTIVE HANDLER WHICH IMPLEMENTS THE RSX11M
; RCVD$, RCVX$ AND RCST$ DIRECTIVES.
;
; INPUT PARAMETERS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = CM IMAGE STACK ADDRESS
;	R10 = ADDRESS OF CM IMAGE DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUT PARAMETERS:
;
;	R10,R11 ARE PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	THE PROPER DIRECTIVE STATUS IS PLACED IN THE IMAGE DSW
;	ALONG WITH THE PROPER SETTING OF THE C-BIT.
;
; DSW RETURN CODES:
;
;	IS.SUC	SUCCESSFUL
;	IE.ADP	BUFFER ACCESS VIOLATION
;	IE.ITS	NO DATA ( ANY QIO ERROR )
;	IE.AST	RCST$ WHILE IN AST STATE
;--
RSX$RCST::
	MOVZBL	#2,R7			; SET STOP FLAG
	BRB	10$			; AND CONTINUE IN COMMON
RSX$RCVX::				; RECEIVE OR EXIT
	MOVZBL	#1,R7			; SET EXIT FLAG
	BRB	10$			; AND CONTINUE IN COMMON
RSX$RCVD::				; RECEIVE DATA DIRECTIVE
	CLRL	R7			; SET FLAG FOR NO EXIT
10$:					; COMMON ENTRY POINT TO RECEIVES
	MOVZWL	4(R5),R4		; ADDRESS BUFFER SPECIFIED
	BLBS	R4,22$			; IF LOW SET THEN ERROR
	MOVL	I_RCVMAIL(R10),R2	; GET MAILBOX CHANNEL
	BEQL	20$			; IF EQL THEN NO BOX AND NO DATA
;
; READ THE MAILBOX
;
	$QIOW_S	#7,I_RCVMAIL(R10),#IO$_READVBLK!IO$M_NOW,I_SCRATCH(R10)-
	,,,4(R4),#26
	BLBC	R0,20$			; BR IF NOT SUCCESS
	MOVZWL	I_SCRATCH(R10),R0	; SET ERROR CODE IF ANY
	BLBS	R0,25$			; IF LOW SET THEN SUCCESS
20$:	CASE	R7,TYPE=B,-		; BRANCH ON NO DATA FLAG
		<35$,40$,45$>

22$:	$DSW	#IE.ADP			; ADDRESS INVALID ERROR
;
; RETURN MESSAGE TO IMAGE
;
; CONVERT NAME OF SENDER TO RAD50
;
25$:	MOVAB	I_SCRATCH+28(R10),I_SCRATCH+12(R10); SET UP DESC. FOR NAME SERVICE
	MOVAB	I_SCRATCH(R10),I_SCRATCH+16(R10);
	MOVL	#16+<JPI$_PRCNAM@16>,I_SCRATCH+8(R10)
	CLRL	I_SCRATCH+20(R10)
	CLRL	(R4)			; ASSUME NO NAME
	$GETJPI_S	,I_SCRATCH+4(R10),,I_SCRATCH+8(R10)
	BLBC	R0,30$			; IF LOW CLEAR THEN ERROR
	MOVZBL	I_SCRATCH(R10),R0	; GET STRING SIZE
	MOVAB	I_SCRATCH+28(R10),R1	; ADDRESS STRING
	CLRB	(R1)[R0]		; MAKE IT ASCIZ
	MOVZBL	#1,R0			; SET DOT LEGAL
	BSBW	RSX$ASCR502		; CONVERT NAME
30$:	RSB				; RETURN
;
; NO DATA OR OTHER ERROR
;
35$:	$DSW	#IE.ITS			; SET STATUS AND EXIT
;
; NO DATA - EXIT IMAGE
;
40$:	MOVZWL	#SS$_NORMAL,R0
	BRW	RSX$INTERNEXIT		; EXIT IMAGE
;
; NO DATA - "STOP" IMAGE UNTIL UNSTOP DIRECTIVE ISSUED
;
45$:	BBS	#SV_ASTLVL,I_STATE(R10),48$	; ERROR IF IN AST STATE
	$HIBER_S			; HIBERNATE WAITING FOR UNSTOP
	CVTBW	#IS.SET,H.DSW(R11)	; INDICATE TASK WAS STOPPED
	RSB
48$:	$DSW	#IE.AST			; ILLEGAL AT AST STATE
 
	.DSABL	LSB

	.SBTTL	RSX$SDAT - RSX11M SDAT$ DIRECTIVE
;++
; RSX$SDAT - RSX11M SEND DATA DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS A RSX DIRECTIVE HANDLER WHICH IMPLEMENTS AN RSX11M
; "SDAT$" DIRECTIVE.
;
; INPUT PARAMETERS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = CM IMAGE STACK ADDRESS
;	R10 = ADDRESS OF CM IMAGE DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUT PARAMETERS:
;
;	R10,R11 ARE PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	THE PROPER DIRECTIVE STATUS IS PLACED IN THE IMAGE DSW
;	ALONG WITH THE PROPER SETTING OF THE C-BIT.
;
; DSW RETURN CODES:
;
;	IS.SUC	SUCCESSFUL
;	IE.INS	RECEIVER IS UNKNOWN
;	IE.IEF	ILLEGAL EVENT FLAG
;	IE.ADP	BUFFER ACCESS VIOLATION
;--
NOBOX:					; NO MAILBOX ERROR
	$DSW	#IE.INS			;
RSX$SDAT::				; SEND DATA DIRECTIVE
	BSBW	RSX$CVTNAME		; CONVERT TARGET NAME TO ASCII
	CMPL	(R5),#^XB37C66E4	; SEND TO "PRT..."?
	BNEQ	1$
	BRW	200$
1$:	CMPL	(R5),#^XB37C1596	; CRF...?
	BNEQ	2$			; BRANCH IF NOT
;
;	SPECIAL CASE FOR CRF...
;
	BSBW	CREATE_CRF_MBX		; CREATE CRF MAILBOX
	BSBB	B^2$			; SEND DATA TO CRF MAILBOX
	BSBW	SPWN_CRF		; SPAWN CRF IMAGE
	BSBW	WAIT_FOR_CRF		; WAIT FOR CRF COMPLETION
	RSB
;
;	SEND DATA TO SPECIFIED TASK MAILBOX
;
2$:	MOVL	#C_RCVDSTR,I_SCRATCH+8(R10); INSERT PREFIX
	ADDL	#4,I_SCRATCH(R10)	; ADJUST SIZE
	SUBL	#4,I_SCRATCH+4(R10)	; ADJUST POINTER
	MOVZWL	4(R5),R4		; GET ADDRESS OF MESSAGE
	BLBS	R4,40$			; BR IF LOW SET
	MOVAB	6(R5),R5		; SET THE EVENT FLAG
	$ASSIGN_S	I_SCRATCH(R10),I_SCRATCH+20(R10); ASSIGN TO MAILBOX
	BLBC	R0,NOBOX		; IF NO MAILBOX THEN NO SEND
	MOVZBL	(R5),R0			; GET EFN IF ANY
	BEQL	10$			; BR IF NONE
	ACBL	I_HIGHEFN(R10),#31,R0,10$; SET UP ACTUAL EFN AND TEST
	$DSW	#IE.IEF			; ILLEGAL EFN
10$:	$QIOW_S	R0,I_SCRATCH+20(R10),#IO$_WRITEVBLK!IO$M_NOW,I_SCRATCH(R10),,,-
		(R4),#26		; SEND MESSAGE
	MOVL	R0,R4			; SAVE STATUS
	BLBC	R0,13$			; IF LOW CLEAR THE QIO ERROR
	MOVL	I_SCRATCH(R10),R4	; SET UP IOSB STATUS
13$:	$DASSGN_S	I_SCRATCH+20(R10); DEASSIGN CHANNEL
	BLBS	R4,25$			; IF LOW SET THEN SUCCESS
	$DSW	#IE.ITS			; RETURN THE ERROR
25$:	RSB
40$:	$DSW	#IE.ADP
;
; SPECIAL CASE SEND TO PRT...
;
100$:	$DSW	#IE.ADP			;
200$:	MOVZWL	4(R5),R5		; ADDRESS BUFFER
	BLBS	R5,40$			; BR IF LOW SET
	IFNORD	#26,(R5),100$		; IF NO ACCESS THEN ERROR
	MOVZWL	10(R5),R0		; GET DEVICE NAME
	MOVZWL	12(R5),R1		; GET DEVICE UNIT
	PUSHR	#^M<R5,R6>		;
	BSBW	RSX$SRCHDEV_BIN		; FIND THE DEVICE
	BEQL	210$
	BRW	300$
210$:	MOVAB	W^RSX$T_SYSPRINT,R0	; ADDRESS SYSPRINT STRING
	MOVZBL	(R0)+,I_SCRATCH(R10)	; TRANSLATE THE STRING
	MOVL	R0,I_SCRATCH+4(R10)	;
	MOVL	#3,R2			; SET LOOP COUNT
220$:	
	BSBW	RSX$TRANS_LOGIC		;
	SOBGTR	R2,220$			; CONTINUE UNTIL DONE
	MOVZBL	I_SCRATCH(R10),R0	; GET STRING SIZE
	MOVB	R0,I_SCRATCH+2(R10)	; INSERT IT
	MOVC5	R0,@I_SCRATCH+4(R10),#0,#15,I_SCRATCH+3(R10); MOVE Q NAME
	MOVZWL	LUT_INFONAME(R6),R0	; GET DEVICE NAME 
	MOVZBL	LUT_INFOUNIT(R6),R1	; AND UNIT
	MOVAB	(R3)+,R7		; COPY STARTING ADDRESS AND SKIP
	BSBW	RSX$BLDPHYDEV		; BUILD DEVICE NAME
	SUBL	R7,R3			; GET SIZE
	SUBB3	#1,R3,(R7)		; ADJUST AND STORE
	MOVL	(SP),R5			; GET BUFFER ADDRESS
	MOVL	14(R5),I_SCRATCH+34(R10); INSERT FID
	MOVW	18(R5),I_SCRATCH+38(R10);
	MOVL	20(R5),I_SCRATCH+40(R10); INSERT DID
	MOVW	24(R5),I_SCRATCH+44(R10);
	MOVAB	I_SCRATCH+47(R10),R7	; CONVERT NAME
	PUSHL	R7
	MOVAB	-6(R5),R4		; ADDRESS RAD50 SOURCE AS FNB
	BSBW	RSX$BLDFNAME		; BUILD FILE NAME
	CLRQ	(R7)
	CLRQ	8(R7)
	SUBL	(SP)+,R7		; GET SIZE OF FILE NAME STRING
	MOVB	R7,I_SCRATCH+46(R10)	; INSERT IT IN MESSAGE
	MOVW	#SMR$K_ENTER,I_SCRATCH(R10);
	MOVAB	I_SCRATCH(R10),I_SCRATCH+74(R10)
	MOVZBL	#66,I_SCRATCH+70(R10)	;
	CLRL	-(SP)			; NO MAILBOX
	PUSHAB	I_SCRATCH+70(R10)		; 
	CALLS	#2,@#SYS$SNDSMB		; SEND MESSAGE TO SYMBIONT
	BLBS	R0,300$			; IF LOW SET THEN SUCCESS
	POPR	#^M<R5,R6>		;
	$DSW	#IE.ITS			;
;
300$:	POPR	#^M<R5,R6>
	RSB
;
;	SPAWN CRF IMAGE
;
; THIS CODE USES A SPECIAL VARIATION OF THE SPAWN FUNCTIONALITY THAT
; IS NOT AVAILABLE UNDER RSX-11M, AND WAS CREATED ESPECIALLY FOR THIS
; CASE. CREF SHOULD HAVE ITS SYS$INPUT AND SYS$OUTPUT SET TO THE NULL
; DEVICE. A MECHANISM IS USED HERE TO ENSURE THIS. THE NULL DEVICE IS
; NOT A LEGAL RSX-11M TI: SPECIFICATION FOR A TASK.
;
SPWN_CRF:
	MOVW	#^A/NL/,-(SP)		; SPECIFY NL: AS CRF'S TI:
	SUBL	#12*2,SP		; ALLOCATE ROOM FOR 12 WORDS
	MOVC5	#0,(SP),#0,#12*2,(SP)	; AND ZERO THEM
	MOVL	SP,R5			; R5 = DPB+2
	MOVB	#15,-(SP)		; FORCE SPAWN TO ACCEPT NL:
	CLRB	-(SP)			; FINISH OFF THE DPB
	MOVAB	B^CRFNAM,R1		; GET ADDRESS OF ASCIC NAME
	MOVZBL	(R1)+,R0		; MAKE DESCRIPTOR OF NAME
	MOVQ	R0,I_SCRATCH(R10)	; SET FOR $SPWN DIRECTIVE
	BSBW	RSX$SPWN2		; SPWN WITH NAME ALREADY SET UP
	ADDL	#14*2,SP		; REMOVE FAKE SPAWN DPB
	RSB				; RETURN WITH STATUS SET

CRFNAM:	.ASCIC	'SYS$SYSTEM:CRF'	; IMAGE NAME TO SPWN

;
;	CREATE CRF RECEIVE MAILBOX
;
CREATE_CRF_MBX:
	MOVAB	I_SCRATCH(R10),R0	; ADDRESS OF ASCII DESCRIPTOR
	ADDL	#4,(R0)+		; ADJUST FOR APPEND
	SUBL	#4,(R0)
	MOVL	#^A'RCVD',@(R0)		; APPEND "RCVD" TO FRONT OF NAME
	$CREMBX_S CHAN=I_SCRATCH+20(R10),- ; CREATE CRF MAILBOX
		MAXMSG=#30,-		; MAX MESSAGES IN MAILBOX
		BUFQUO=#RSX$_RCVMBXSIZ,- ; MAXIMUM BYTES OF MSGS IN MAILBOX
		PROMSK=#^XF00F,-	; GROUP,OWNER ALL ACCESS
		LOGNAM=I_SCRATCH(R10)
	SUBL	#4,I_SCRATCH(R10)	; RESTORE DESCRIPTOR
	ADDL	#4,I_SCRATCH+4(R10)
	RSB

;
;	WAIT FOR COMPLETION OF THE CRF SUBPROCESS
;

WAIT_FOR_CRF:
	$QIOW_S	CHAN=OCB_CHAN(R9),-	; CANCEL ATTENTION AST ON MAILBOX
		FUNC=#IO$_SETMODE
	PUSHL	R9			; ADDRESS OF OCB FOR AST
	CALLS	#1,W^RSX$TERMINAST	; FORCE READ ON MAILBOX
					; AND RETURN ON COMPLETION
	RSB

	.END
