	.TITLE	RSXTSKCTL - RSX AME TASK CONTROL DIRECTIVES
	.IDENT	'V03-001'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:
;
;	VAX/VMS RSX AME.
;
; ABSTRACT:
;
;	RSX TASK CONTROL DIRECTIVES.
;
; AUTHOR:
;
;	R.HEINEN 29-SEPT-76
;
; PREVIOUSLY MODIFIED BY:
;
;	Tim Halvorsen
;	Michael S. Harvey
;
; MODIFIED BY:
;
;	V001	MSH026		Michael S. Harvey	23-Mar-82
;		Eliminate dependencies on VMS Executive symbols.
;
;--
;
; EXTERNAL SYMBOLS
;
	$RSXDEF			; DEFINE RSX SYMBOLS
	$DIBDEF			; DEVICE INFORMATION DEFINITIONS
	$IHDDEF			; IMAGE HEADER DESCRIPTOR
	$IHADEF			; IMAGE HEADER ACTIVATION DATA
	$IACDEF			; IMAGE ACTIVATOR FLAGS

	DRERR$			; DEFINE RSX11M DIRECTIVE ERROR CODES
	IOERR$			; DEFINE I/O ERROR CODES

	.PSECT	RSXPURE,EXE,NOWRT,LONG,SHR,PIC

	.MACRO	ERRDEF	VMS,RSX
	.WORD	SS$_'VMS,IE.'RSX
	.ENDM

SPWN_ERRTAB:
	ERRDEF	DUPLNAM,ACT
	ERRDEF	EXQUOTA,NOD
	ERRDEF	INSFMEM,UPN
	ERRDEF	NOPRIV,PRI
	ERRDEF	ACCVIO,ADP
	.WORD	0,0

NOVERIFY:
	.ASCID	/$V='F$VERIFY(0)'/	; TURN OFF VERIFICATION
LOGOUT:
	.ASCID	'$STOP/ID=0'		; LOGOUT COMMAND
NULL:
	.ASCID	'_NL:'			; NULL DEVICE
 
	.PSECT	RSXCODE,NOWRT,SHR,PIC

	.SBTTL	RSX$ABRT - RSX11M ABRT$ DIRECTIVE
;++
; RSX$ABRT - RSX11M ABORT TASK DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS A RSX DIRECTIVE HANDLER WHICH IMPLEMENTS AN RSX11M
; "ABRT$" DIRECTIVE. THE SPECIFIED TASK NAME IS CONVERTED TO ASCII
; AND A "$FORCEX" IS DONE TO AFFECT THE DIRECTIVE. 
;
; INPUT PARAMETERS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = CM IMAGE STACK ADDRESS
;	R10 = ADDRESS OF CM IMAGE DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUT PARAMETERS:
;
;	R10,R11 ARE PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	THE PROPER DIRECTIVE STATUS IS PLACED IN THE IMAGE DSW
;	ALONG WITH THE PROPER SETTING OF THE C-BIT.
;
; DSW RETURN CODES:
;
;	IS.SUC	SUCCESSFUL
;	IS.PRI	PRIVILEGE VIOLATION -- SS$_NOPRIV
;	IE.UPN	INSUFICIENT MEMORY -- SS$_INSFMEM
;	IE.NOD	QUOTA EXCEEDED -- SS$_EXQUOTA
;	IE.PRI	PRIVILEGE VIOLATION
;	IE.INS	UNKNOWN PROCESS
;--
RSX$ABRT::				; ABORT TASK DIRECTIVE
	BSBW	RSX$CVTNAME		; CONVERT R50 NAME TO ASCII
	MOVAB	I_SCRATCH(R10),R0	; ADDRESS NAME STRING
	TSTB	(R0)			; ANY DATA?
	BNEQ	10$			; IF NEQ THEN YES
	CLRL	R0			; SET NO TASK NAME
10$:
	$FORCEX_S	,(R0),#SS$_ABORT; FORCE TERMINATION
	BRW	MAPDSW			; MAP THE PROPER DSW RETURN

	.SBTTL	RSX$ALTP - RSX11M ALTP$ DIRECTIVE
;++
; RSX$ALTP - RSX11M ALTER PRIORITY DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS A RSX DIRECTIVE HANDLER WHICH IMPLEMENTS AN RSX11M
; "ALTP$" DIRECTIVE.
;
; THIS DIRECTIVE IN THE VAX/VMS ENVIRONMENT IS A NOOP.
;
; INPUT PARAMETERS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = CM IMAGE STACK ADDRESS
;	R10 = ADDRESS OF CM IMAGE DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUT PARAMETERS:
;
;	R10,R11 ARE PRESERVED
; IMPLICIT OUTPUTS:
;
;	THE PROPER DIRECTIVE STATUS IS PLACED IN THE IMAGE DSW
;	ALONG WITH THE PROPER SETTING OF THE C-BIT.
;
; DSW RETURN CODES:
;
;	IS.SUC	SUCCESSFUL
;--
RSX$ALTP::				; ALTER PRIORITY DIRECTIVE
	RSB				; RETURN 

	.SBTTL	RSX$CSRQ - RSX11M CSRQ$ DIRECTIVE
;++
; RSX$CSRQ -  RSX11M CANCEL TIME BASED INITIATION REQUESTS DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IMPLEMENTS THE RSX11M CANCEL TIMED INITIATION DIRECTIVE.
; THE SPECIFIED TASK NAME IS CONVERTED TO ASCII FOLLOWED BY A "$CANWAK".
;
; INPUTS:
;
;	R5 = ADDRESS OF THE DPB+2
;	R10 = ADDRESS OF THE IMAGE DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUTS:
;
;	R10,R11 ARE PRESERVED.
;
; IMPLICIT OUTPUTS:
;
;	THE PROPER DIRECTIVE STATUS IS SET IN THE DSW ALONG WITH
;	THE PROPER SETTING OF THE C-BIT.
;
; DSW RETURN CODES:
;
;	IS.SUC	SUCCESSFUL
;	IS.PRI	PRIVILEGE VIOLATION -- SS$_NOPRIV
;	IE.UPN	INSUFICIENT MEMORY -- SS$_INSFMEM
;	IE.NOD	QUOTA EXCEEDED -- SS$_EXQUOTA
;	IE.PRI	PRIVILEGE VIOLATION
;	IE.INS	UNKNOWN PROCESS
;--
RSX$CSRQ::				; CANCEL TIMED INITIATION
	BSBW	RSX$CVTNAME		; CONVERT R50 TASK NAME TO ASCII
	MOVAB	I_SCRATCH(R10),R0	; ADDRESS NAME STRING
	TSTB	(R0)			; ANY DATA?
	BNEQ	10$			; IF NEQ THEN YES
	CLRL	R0			; SET NO TASK NAME
10$:	
	$CANWAK_S	,(R0)		; CANCEL WAKEUP FOR PROCESS
	BRW	MAPDSW			; MAP THE PROPER DSW RETURN

	.SBTTL	RSX$EXTK - RSX11M EXTK$ DIRECTIVE
;++
; RSX$EXTK - RSX11M EXTEND TASK DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS A RSX DIRECTIVE HANDLER WHICH IMPLEMENTS AN RSX11M
; "EXTK$" DIRECTIVE.
;
; INPUT PARAMETERS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = CM IMAGE STACK ADDRESS
;	R10 = ADDRESS OF CM IMAGE DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUT PARAMETERS:
;
;	R10,R11 ARE PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	THE PROPER DIRECTIVE STATUS IS PLACED IN THE IMAGE DSW
;	ALONG WITH THE PROPER SETTING OF THE C-BIT.
;
; DSW RETURN CODES:
;
;	IS.SUC	SUCCESSFUL
;	IS.PRI	PRIVILEGE VIOLATION -- SS$_NOPRIV
;	IE.UPN	INSUFICIENT MEMORY -- SS$_INSFMEM
;	IE.NOD	QUOTA EXCEEDED -- SS$_EXQUOTA
;	IE.ALG	INVALID EXTENSION OR CONTRACTION
;--
RSX$EXTK::				; EXTEND TASK DIRECTIVE
	MOVAB	I_SCRATCH(R10),R4	; ADDRESS ARGLIST
	CVTWL	(R5),R5			;
	ASHL	#6,R5,R5		; MAKE BYTES
	BGTR	50$			; IF GTRU THEN EXPAND
	BNEQ	10$			; IF NEQ THEN CONTRACT
;
; MAKE INITIAL SIZE
;
	MOVL	I_INISIZE(R10),(R4)	; SET UP LOWER LIMIT
	MOVL	I_ADR0+ADR_HIGHLIM(R10),4(R4); SET UP UPPER LIMIT
	SUBL3	4(R4),(R4),R5		; GET DIFFERENCE
	BLSS	10$			; IF LSS THEN CONTRACT
	BGTR	50$			; IF GTR THEN EXPAND
	RSB				; IF EQL THEN NO CHANGE
10$:	ADDL3	R5,I_ADR0+ADR_HIGHLIM(R10),(R4); SET UP LOW LIMIT BY FUNNY SUBTRACT
15$:	MOVL	I_ADR0+ADR_HIGHLIM(R10),4(R4);
	MOVL	(R4),R5			; SAVE BOT AS NEW HIGH SIZE
	CMPW	I_GARD(R10),R5		; DELETE TOO MUCH?
	BGTRU	75$			; IF GTRU THEN ERROR
	BSBB	100$			; CHECK AND ROUND PARAMS
	$DELTVA_S	(R4)		; DELETE THE SPACE
	BLBC	R0,75$			; IF LOW CLEAR THEN ERROR
	BRB	60$			; CONTINUE
50$:	MOVL	I_ADR0+ADR_HIGHLIM(R10),(R4); INSERT HIGH LIMIT
	ADDL3	R5,(R4),4(R4)		;
	MOVL	4(R4),R5		; SAVE TOP AS NEW HIGH LIM
	BSBB	100$			; ROUND SIZE
	CMPL	4(R4),I_HIGHSIZE(R10)	; IN RANGE?
	BGEQU	75$			; BR IF ERROR
	$CRETVA_S	(R4)
	BLBC	R0,75$
60$:	MOVL	R5,I_ADR0+ADR_HIGHLIM(R10)
	RSB
75$:	$DSW	#IE.ALG			; SET ALLOCATION FAILURE
;
; SUBROUTINE TO CHECK AND ROUND PARAMETERS
;
100$:	
	BICW	#511,(R4)
	BICW	#511,4(R4)
	CMPL	(R4),4(R4)		; IF EQL THEN NO CHANGE NEEDED
	BNEQ	110$
	MOVL	R5,I_ADR0+ADR_HIGHLIM(R10); ASSUME SUCCESS
	POPR	#^M<R0>
110$:	ADDW	#512,(R4)		; ROUND LOWER LIMIT UP TO NEXT PAGE
	RSB

	.SBTTL	RSX$RQST - RSX11M RQST$ DIRECTIVE
;++
; RSX$RQST - RSX11M REQUEST DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IMPLEMENTS THE RSX11M RQST$ DIRECTIVE.
; THE SPECIFIED PROCESS NAME IS COMVERTED TO ASCII AND THEN "$WAKE"'D.
;
; THIS DIRECTIVE IS EITHER REQUEST OR SPAWN DEPENDING ON DPB SIZE.
;
; INPUTS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = CM IMAGE STACK POINTER
;	R10 = ADDRESS OF IMAGE DATA
;	R11 = ADDRESS OF IMAGE HEADER
;
; IMPLICIT INPUTS:
;
;	THE DPB IS ALREADY VALIDATED FOR READ ACCESS.
;
; OUTPUTS:
;
;	R10,R11 ARE PRESERVED.
;
; IMPLICIT OUTPUTS:
;
;	THE REQUESTED PROCESS IS "$WAKE"'D AND "RSX$MAPDSW" IS ENTERED.
;
; DSW RETURN CODES:
;
;	IS.SUC	SUCCESSFUL
;	IS.PRI	PRIVILEGE VIOLATION -- SS$_NOPRIV
;	IE.UPN	INSUFICIENT MEMORY -- SS$_INSFMEM
;	IE.NOD	QUOTA EXCEEDED -- SS$_EXQUOTA
;	IE.PRI	PRIVILEGE VIOLATION
;	IE.INS	UNKNOWN PROCESS
;--
RSX$RQST::				; REQUEST DIRECTIVE
	CMPB	-1(R5),#7		; REQUEST OR SPAWN?
	BNEQ	RSX$SPWN		; BRANCH IF SPAWN
;	BOTH PRT AND CRF ARE HANDLED BY SDAT, GIVE SUCCESS
	CMPL	(R5),#^X0B37C66E4	; PRT...?
	BEQL	11$			; IF EQL THEN SUCCESS
	CMPL	(R5),#^XB37C1596	; CRF...?
	BEQL	11$			; IF EQL THEN SUCCESS
	BSBW	RSX$CVTNAME		; CONVERT TASK NAME TO ASCII
	MOVAB	I_SCRATCH(R10),R0	; ADDRESS NAME STRING
	TSTB	(R0)			; ANY DATA?
	BNEQ	10$			; IF NEQ THEN YES
	$DSW	#IE.INS
10$:	
	$WAKE_S	,(R0)			; WAKE PROCESS
	BRW	MAPDSW			; MAP RETURN STATUS
11$:	RSB

	.SBTTL	RSX$SPWN - RSX11M SPWN$ DIRECTIVE
;---
;
;	SPWN$ - SPAWN SUBTASK WITH OPTIONAL COMMAND LINE
;
;	THIS DIRECTIVE IS DONE IN VMS BY CREATING A SUBPROCESS
;	SPECIFYING "LOGINOUT" AS THE IMAGE TO EXECUTE.  THE INPUT
;	FILE NAME WILL BE SET TO A MAILBOX CONTAINING THE COMMAND
;	SPECIFIED IN THE DIRECTIVE AND THE OUTPUT SET TO THE SPECIFIED
;	TERMINAL.
;
; INPUTS:
;
;	R5 = ADDRESS OF DPB+2
;	R10 = ADDRESS OF CM DATA AREA
;	R11 = ADDRESS OF CM IMAGE HEADER
;
; OUTPUTS:
;
;	R9 = ADDRESS OF OCB (FOR INTERNAL USE ONLY WITH RSX$SPWN2)
;	R10,R11 ARE PRESERVED
;	DIRECTIVE STATUS IS PLACED IN DSW; C-BIT IS SET.
;
; DSW RETURN CODES:
;
;	IS.SUC	SUCCESSFUL
;	IE.ACT	PROCESS ALREADY EXISTS
;	IE.INS	INVALID TASK NAME
;	IE.NOD	QUOTA EXCEEDED
;	IE.UPN	INSUFFICIENT DYNAMIC MEMORY
;---

SPWN$Q_TSKNAM	= I_SCRATCH		; DESCRIPTOR OF IMAGE NAME
SPWN$T_TSKNAM	= I_SCRATCH+8		; IMAGE NAME STRING (10 CHARS)
SPWN$W_CHAN	= I_SCRATCH+18		; INPUT MAILBOX CHANNEL
SPWN$Q_INPUT	= I_SCRATCH+20		; DESCRIPTOR OF SYS$INPUT STRING
SPWN$Q_OUTPUT	= I_SCRATCH+28		; DESCRIPTOR OF SYS$OUTPUT
SPWN$A_INPUT	= I_SCRATCH+36		; TI: TRANSLATATION (16 CHARS)
SPWN$Q_GETCHN	= I_SCRATCH+52		; BUFFER DESCRIPTOR
SPWN$Q_PRCNAM	= I_SCRATCH+52		; -- ALSO DESCRIPTOR OF PROCESS NAME
SPWN$A_GETCHN	= I_SCRATCH+60		; ADDRESS OF GETCHN BUFFER

RSX$SPWN::
	CMPB	-1(R5),#13		; DPB SIZE CAN BE EITHER 13 OR 14
	BLSSU	15$			; BRANCH IF ILLEGAL
	CMPB	-1(R5),#14		; CHECK UPPER LIMIT
	BGTRU	15$			; BRANCH IF ILLEGAL
	BSBW	RSX$CVTNAME		; CONVERT TASK NAME TO ASCII
	TSTW	SPWN$Q_TSKNAM(R10)	; NULL IMAGE NAME STRING?
	BNEQ	RSX$SPWN2		; BRANCH IF OK
	$DSW	#IE.INS			; NO TASK NAME SPECIFIED
15$:	$DSW	#IE.SDP			; ILLEGAL DPB SIZE

;---
;	SPAWN SUBPROCESS
;
; INPUTS:
;
;	I_SCRATCH = DESCRIPTOR OF IMAGE NAME
;
; OUTPUTS:
;
;	THE SUBPROCESS IS CREATED AND THE OCB IS QUEUED.
;---

RSX$SPWN2::				; ENTRY WITH TSKNAM SETUP (RQST CRF)
;
;	SETUP OFFSPRING CONTROL BLOCK FOR SUBPROCESS
;
	MOVL	#OCB_LENGTH,R1		; LENGTH OF BLOCK TO ALLOCATE
	BSBW	RSX$ALLOCATE		; ALLOCATE A NEW BLOCK
	MOVL	R0,R9			; SAVE ADDRESS
	PUSHL	R5			; SAVE DPB ADDRESS
	MOVC5	#0,(R9),#0,#OCB_LENGTH,(R9)	; ZERO THE BLOCK
	ADDL3	#12,(SP)+,R5		; BYPASS UNUSED WORDS
	MOVW	(R5)+,OCB_EFN(R9)	; SAVE EFN TO SET ON EXIT
	BEQL	30$			; BRANCH IF NONE
	MOVZWL	OCB_EFN(R9),R1
	ADDL	#31,R1			; MAP TO RSX EVENT FLAGS
	$CLREF_S R1			; PRE-CLEAR EVENT FLAG
30$:	MOVW	(R5)+,OCB_AST(R9)	; ADDRESS OF AST ROUTINE
	MOVW	(R5)+,OCB_ESB(R9)	; ADDRESS OF EXIT STATUS BLOCK
	MOVZWL	OCB_ESB(R9),R1
	BEQL	40$			; BRANCH IF NONE
	IFWRT	#16,(R1),40$		; BRANCH IF WRITABLE
	$DSW	#IE.ADP			; UNABLE TO ACCESS MEMORY
;
;	CREATE THE TERMINATION MAILBOX
;
40$:	$CREMBX_S CHAN=OCB_CHAN(R9)	; CREATE A TEMPORARY MAILBOX
	BLBC	R0,50$			; BRANCH ON ERROR
	MOVAB	SPWN$A_GETCHN(R10),R2
	MOVZBL	#DIB$W_UNIT+2,SPWN$Q_GETCHN(R10) ; INIT. DESCRIPTOR
	MOVL	R2,SPWN$Q_GETCHN+4(R10)
	$GETCHN_S CHAN=OCB_CHAN(R9),-	; GET MAILBOX INFO
		PRIBUF=SPWN$Q_GETCHN(R10)
	BLBC	R0,50$			; BRANCH ON GETCHN ERROR
	MOVZWL	DIB$W_UNIT(R2),R7	; SAVE MAILBOX UNIT NUMBER
	$QIO_S	CHAN=OCB_CHAN(R9),-	; SET ATTENTION AST ON MAILBOX
		FUNC=#IO$_SETMODE,-
		P1=RSX$TERMINAST,-	; ADDRESS OF AST ROUTINE
		P2=R9			; ADDRESS OF OCB FOR SUBPROCESS
	BLBS	R0,60$			; BRANCH ON SUCCESS
50$:	BRW	SPAWN_ERROR		; TRANSLATE AND RETURN ERROR
;
;	IF TI: SPECIFIED, USE THAT DEVICE AS SYS$INPUT AND SYS$OUTPUT.
;
60$:	CLRL	R1			; ASSUME TI: UNIT ZERO
	CMPB	-19(R5),#14		; TI: SPECIFIED?
	BLSS	70$			; BRANCH IF SHORT DPB (NO DNAM)
	BGTR	65$			; IF GTR, SPECIAL DPB FOR CREF
	MOVZWL	4(R5),R1		; SET UNIT NUMBER
	BEQL	70$			; BRANCH IF NONE
65$:	MOVZWL	6(R5),R0		; SET DEVICE NAME (NL: FOR CRF)
	MOVAB	SPWN$A_INPUT(R10),R3	; ADDRESS OF OUTPUT BUFFER
	BSBW	W^RSX$BLDPHYDEV		; CONSTRUCT DEVICE NAME
	MOVB	#^A':',(R3)+		; INSERT TRAILING COLON
	MOVAB	SPWN$A_INPUT(R10),SPWN$Q_INPUT+4(R10)
	SUBL3	SPWN$Q_INPUT+4(R10),R3,SPWN$Q_INPUT(R10)
	BRB	80$
;
;	TI: NOT SPECIFIED, PROPAGATE THE PARENT'S TI:
;
70$:	MOVL	#16,SPWN$Q_INPUT(R10)	; INIT. OUTPUT DESCRIPTOR
	MOVAB	SPWN$A_INPUT(R10),SPWN$Q_INPUT+4(R10)
	$TRNLOG_S LOGNAM=W^RSX$Q_SYSINPUT,- ; TRANSLATE SYS$INPUT
		RSLBUF=SPWN$Q_INPUT(R10),-
		RSLLEN=SPWN$Q_INPUT(R10)
	MOVAB	SPWN$Q_INPUT(R10),R2	; ADDRESS THE DESCRIPTOR
	CMPB	@4(R2),#^X1B		; LEADING ESCAPE CHARACTER?
	BNEQ	80$			; BRANCH IF NOT
	SUBL	#4,(R2)			; REMOVE ESCAPE SEQUENCE
	ADDL	#4,4(R2)
;
;	CREATE AN INPUT MAILBOX IF A COMMAND LINE IS SPECIFIED
;
80$:	MOVQ	SPWN$Q_INPUT(R10),SPWN$Q_OUTPUT(R10)	; ASSUME TI:
	MOVAB	SPWN$Q_TSKNAM(R10),R8	; ASSUME TASK = IMAGE NAME
	TSTW	2(R5)			; COMMAND LINE = NULL STRING?
	BEQL	90$			; IF SO, BYPASS THIS STUFF
	$CREMBX_S CHAN=SPWN$W_CHAN(R10)	; CREATE INPUT MAILBOX
	BLBC	R0,85$			; BRANCH ON ERROR
	$GETCHN_S CHAN=SPWN$W_CHAN(R10),-	; GET MAILBOX INFO
		PRIBUF=SPWN$Q_GETCHN(R10)
	BLBC	R0,85$			; BRANCH ON GETCHN ERROR
	MOVZWL	#^A'MB',R0		; DEVICE NAME = MB
	MOVAB	SPWN$A_GETCHN(R10),R2	; ADDRESS THE GETCHN BUFFER
	MOVZWL	DIB$W_UNIT(R2),R1	; GET MAILBOX UNIT NUMBER
	MOVAB	SPWN$A_GETCHN(R10),R3	; SET ADDRESS OF RESULT BUFFER
	BSBW	W^RSX$BLDASCDEV		; CONSTRUCT THE DEVICE NAME
	MOVB	#^A':',(R3)+		; INSERT TRAILING COLON
	MOVAB	SPWN$A_GETCHN(R10),SPWN$Q_INPUT+4(R10)
	SUBL3	SPWN$Q_INPUT+4(R10),R3,SPWN$Q_INPUT(R10)
	MOVAB	W^RSX$Q_LOGINOUT,R8	; SET ADDRESS OF CLI INSTEAD
	BRB	90$			; CREATE THE PROCESS

85$:	BRW	SPAWN_ERROR		; PROCESS ERROR CONDITION
;
;	USE FILE NAME PORTION OF FILESPEC AS THE PROCESS NAME
;
90$:	MOVQ	SPWN$Q_TSKNAM(R10),R2	; GET IMAGE FILE SPECIFICATION
91$:	LOCC	#^A']',R2,(R3)		; LOOK FOR START OF FILE NAME
	BNEQ	92$
	LOCC	#^A'>',R2,(R3)
	BNEQ	92$
	LOCC	#^A':',R2,(R3)
	BEQL	95$			; IF NOT FOUND, USE ENTIRE STRING
92$:	MOVAB	-(R0),R2		; CHOP OFF UP TO TERMINATOR
	MOVAB	1(R1),R3
	BRB	91$			; AND KEEP CHOPPING UNTIL NOTHING FOUND
95$:	LOCC	#^A'.',R2,(R3)		; LOOK FOR START OF FILE TYPE
	SUBL	R0,R2			; AND CHOP OFF FILE TYPE
	MOVQ	R2,SPWN$Q_PRCNAM(R10)	; STORE PROCESS NAME
;
;	CREATE THE SUBPROCESS
;
SPAWN_PROCESS:
	CLRQ	-(SP)			; TERMINATOR, RET. LENGTH ADDR.
	PUSHAB	-2*4(SP)		; SET UP BUFFER ADDRESS
	PUSHL	#JPI$_PRIB@16+4		; ITEM CODE AND BUFFER LENGTH
	MOVL	SP,R0			; GET DESCRIPTOR ADDRESS
	$GETJPI_S ITMLST=(R0)		; GET CURRENT BASE PRIORITY
	POPL	R0			; ... INTO R0
	ADDL	#3*4,SP			; CLEAN STACK
	$CREPRC_S IMAGE=(R8),-		; CREATE THE PROCESS
		INPUT=SPWN$Q_INPUT(R10),-
		OUTPUT=SPWN$Q_OUTPUT(R10),-
		ERROR=W^NULL,-
		BASPRI=R0,-
		PRCNAM=SPWN$Q_PRCNAM(R10),-
		MBXUNT=R7		; TERMINATION MAILBOX
	BLBC	R0,SPAWN_ERROR
;
;	WRITE THE COMMAND LINE TO THE MAILBOX AND WAIT FOR THE
;	SUBPROCESS CLI TO READ IT.
;
	MOVZWL	(R5)+,R3		; ADDRESS OF COMMAND LINE
	MOVZWL	(R5)+,R2		; LENGTH OF COMMAND LINE
	BNEQ	20$			; BRANCH IF COMMAND TO BE PASSED
	RSB				; EXIT DIRECTIVE
20$:	$QIOW_S	CHAN=SPWN$W_CHAN(R10),-	; WRITE SET NOVERIFY COMMAND
		FUNC=#IO$_WRITEVBLK,-	; AND WAIT FOR SUBPROCESS READ
		P1=@W^NOVERIFY+4,P2=W^NOVERIFY
	BLBC	R0,SPAWN_ERROR
	$QIOW_S	CHAN=SPWN$W_CHAN(R10),-	; WRITE THE LINE TO MAILBOX
		FUNC=#IO$_WRITEVBLK!IO$M_NOW,-	; WITHOUT WAITING
		P1=(R3),P2=R2		; ADDRESS/LENGTH OF BUFFER
	BLBC	R0,SPAWN_ERROR
	$QIOW_S	CHAN=SPWN$W_CHAN(R10),-	; WRITE LOGOUT COMMAND
		FUNC=#IO$_WRITEVBLK!IO$M_NOW,-	; WITHOUT WAITING
		P1=@W^LOGOUT+4,P2=W^LOGOUT
;
;	THE DIRECTIVE IS ESSENTIALLY COMPLETE.  CLEANUP AND REPORT
;	ANY ERRORS WHICH WERE DETECTED.
;
SPAWN_ERROR:
	PUSHL	R0			; SAVE ERROR STATUS
	$DASSGN_S CHAN=SPWN$W_CHAN(R10)	; DEASSIGN MAILBOX CHANNEL
	BLBS	(SP),10$		; BRANCH IF EVERYTHING IS OK
	$DASSGN_S CHAN=OCB_CHAN(R9)	; DELETE TERMINATION MAILBOX
	MOVL	R9,R0			; ADDRESS OF CONTROL BLOCK
	MOVL	#OCB_LENGTH,R1		; LENGTH OF BLOCK
	BSBW	RSX$DEALLOCATE		; DEALLOCATE CONTROL BLOCK
10$:	POPL	R0			; RESTORE ERROR STATUS
	BLBC	R0,20$			; REPORT ANY ERRORS DETECTED
	RSB				; EXIT DIRECTIVE
;
;	MAP THE VMS STATUS CODE TO RSX11M CODES
;
20$:	MOVAB	W^SPWN_ERRTAB,R1	; ADDRESS STATUS MAP TABLE
30$:	CMPW	(R1)+,R0		; MATCH?
	BEQL	40$			; BRANCH IF YES
	TSTW	(R1)+			; END OF TABLE?
	BNEQ	30$			; BRANCH IF MORE TO GO
	$DSW	#IE.VER			; SET MISC. ERROR CODE
40$:	MOVZWL	(R1),R0			; GET RSX EQUIVALENT CODE
	$DSW	R0

	.SBTTL	RSX$RSUM - RSX11M RSUM$ DIRECTIVE
;++
; RSX$RSUM - RSX11M RESUME TASK DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS A RSX DIRECTIVE HANDLER WHICH IMPLEMENTS AN RSX11M
; "RSUM$" DIRECTIVE. THE SPECIFIED TASK NAME IS CONVERTED TO ASCII
; AND A "$WAKE" IS DONE TO AFFECT THE DIRECTIVE. 
; NOTE THE DIFFERENCE BETWEEN VAX/VMS'S RESUME AND 11M'S.
;
; INPUT PARAMETERS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = CM IMAGE STACK ADDRESS
;	R10 = ADDRESS OF CM IMAGE DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUT PARAMETERS:
;
;	R10,R11 ARE PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	THE PROPER DIRECTIVE STATUS IS PLACED IN THE IMAGE DSW
;	ALONG WITH THE PROPER SETTING OF THE C-BIT.
;
; DSW RETURN CODES:
;
;	IS.SUC	SUCCESSFUL
;	IE.PRI	PRIVILEGE VIOLATION
;	IE.INS	UNKNOWN PROCESS
;--
RSX$RSUM::				; RESUME DIRECTIVE
RSX$USTP::
	BSBW	RSX$CVTNAME		; CONVERT TASK NAME
	MOVAB	I_SCRATCH(R10),R0	; ADDRESS NAME STRING
	TSTB	(R0)			; ANY DATA?
	BNEQ	10$			; IF NEQ THEN YES
	CLRL	R0			; SET NO TASK NAME
10$:	
	$WAKE_S	,(R0)			; WAKE PROCESS
	BRW	MAPDSW			; MAP RETURN STATUS

	.SBTTL	RSX$RUN - RSX11M RUN$ DIRECTIVE
;++
; RSX$RUN - RSX11M RUN TASK DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS A RSX DIRECTIVE HANDLER WHICH IMPLEMENTS AN RSX11M
; "RUN$" DIRECTIVE. THE SPECIFIED TASK NAME IS CONVERTED TO ASCII
; AND A "$SCHDWK" IS DONE TO AFFECT THE DIRECTIVE. 
;
; INPUT PARAMETERS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = CM IMAGE STACK ADDRESS
;	R10 = ADDRESS OF CM IMAGE DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUT PARAMETERS:
;
;	R10,R11 ARE PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	THE PROPER DIRECTIVE STATUS IS PLACED IN THE IMAGE DSW
;	ALONG WITH THE PROPER SETTING OF THE C-BIT.
;
; DSW RETURN CODES:
;
;	IS.SUC	SUCCESSFUL
;	IS.PRI	PRIVILEGE VIOLATION -- SS$_NOPRIV
;	IE.UPN	INSUFICIENT MEMORY -- SS$_INSFMEM
;	IE.NOD	QUOTA EXCEEDED -- SS$_EXQUOTA
;	IE.PRI	PRIVILEGE VIOLATION
;	IE.INS	UNKNOWN PROCESS
;	IE.ITI	INVALID TIME PARAMETER
;--
RSX$RUN::				; ABORT TASK DIRECTIVE
	BSBW	RSX$CVTNAME		; CONVERT TASK NAME TO ASCII
	TSTB	I_SCRATCH(R10)		; ANY NAME?
	BNEQ	10$			; IF NEQ THEN YES
	$DSW	#IE.INS			; BAD NAME
10$:	ADDL	#12,R5			; POINT TO SCHEDULE MAG.
	MOVZWL	(R5)+,R2		; GET THE SCHEDULE MAGNITUDE
	BEQL	100$			; IF EQL THEN ILLEGAL
	MOVZWL	(R5)+,R0		; GET UNITS OF SCHEDULE MAG.
	BEQL	100$			; IF EQL THEN ILLEGAL
	BSBW	RSX$TIMEMAG		; CONVERT TIME PARAMS
	BLBC	R2,100$			; IF LOW CLEAR THEN ERROR
	MOVQ	R0,I_SCRATCH+24(R10)	; SAVE VALUE
	CLRQ	I_SCRATCH+32(R10)	; SET NO RESCHEDULE
	CLRL	R7			; ASSUME NO RESCHD
	MOVZWL	(R5)+,R2		; GET RESCHEDULE MAGNITUDE
	BEQL	50$			; IF EQL THEN NONE
	MOVZWL	(R5),R0			; GET THE UNITS FOR THE MAG.
	BEQL	100$			; IF EQL THEN ILLEGAL
	BSBW	RSX$TIMEMAG		; CONVERT TIME PARAMS
	BLBC	R2,100$			; IF LOW CLEAR THEN ERROR
	MOVQ	R0,I_SCRATCH+32(R10)	; SAVE NEGITIVE OF RETURN VALUE
	MOVAB	I_SCRATCH+32(R10),R7
50$:	MOVAB	I_SCRATCH(R10),R0	; ADDRESS NAME STRING
	TSTB	(R0)			; ANY DATA?
	BNEQ	60$			; IF NEQ THEN YES
	CLRL	R0			; SET NO TASK NAME
60$:	
	$SCHDWK_S  ,(R0),I_SCRATCH+24(R10),(R7); SCHEDULE WAKE UP
	CMPW	R0,#SS$_IVTIME		; INVALID TIME PARAMETER?
	BEQL	100$			; IF EQL THEN SET ERROR
	BRW	MAPDSW			; MAP RETURN CODE
;
; BAD TIME VALUE
;
100$:	$DSW	#IE.ITI			; SET STATUS AND RETURN

	.SBTTL	RSX$SPND - RSX11M SPND$ DIRECTIVE		
;++
; RSX$SPND - RSX11M SUSPEND TASK DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS A RSX DIRECTIVE HANDLER WHICH IMPLEMENTS AN RSX11M
; "SPND$" DIRECTIVE.
;
; THIS DIRECTIVE HIBERNATES THE CURRENT PROCESS. NOTE THE DIFFERENCE
; BETWEEN THE VAX/VMS SUSPEND AND 11M'S.
;
; INPUT PARAMETERS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = CM IMAGE STACK ADDRESS
;	R10 = ADDRESS OF CM IMAGE DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUT PARAMETERS:
;
;	R10,R11 ARE PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	THE PROPER DIRECTIVE STATUS IS PLACED IN THE IMAGE DSW
;	ALONG WITH THE PROPER SETTING OF THE C-BIT.
;
; DSW RETURN CODES:
;
;	IS.SUC	SUCCESSFUL
;	IE.UPN INSUFICIENT MEMORY -- SS$_INSFMEM
;	IE.NOD QUOTA EXCEEDED -- SS$_EXQUOTA
;	IS.PRI	PRIVILEGE VIOLATION -- SS$_NOPRIV
;--
RSX$SPND::				; SUSPEND TASK DIRECTIVE
	BBS	#SV_PENDHIBER,I_STATE(R10),50$ ; BRANCH IF SHOULD SKIP HIBER
	BISW	#1@SV_HIBER,I_STATE(R10) ; MARK HIBERNATE IN PROGRESS
	$HIBER_S			; HIBER THIS IMAGE
	BICW	#1@SV_HIBER,I_STATE(R10) ; CLEAR HIBERNATE IN PROGRESS
	BRW	MAPDSW			; MAP THE DSW
;
; THE HIBERNATE SHOULD BE SKIPPED IN ORDER TO DELIVER AN AST WHICH CAME
; IN WHILE WE WERE GETTING DISPATCHED HERE.  MARK THAT WE REALLY WANTED
; TO DO A HIBERNATE AND THAT IT SHOULD BE RESTARTED WHEN THE AST IS DONE.
;
50$:	BBSS	#SV_RESTARTHIBER,I_STATE(R10),55$ ; MARK TO RESTART HIBERNATE
55$:	RSB

	.SBTTL	RSX$STOP - RSX11M STOP$ DIRECTIVE
;---
;
;	THIS IS THE RSX DIRECTIVE WHICH STOPS A TASK.  A TASK IN
;	A STOPPED STATE IS SIMILIAR TO BLOCKED STATE (WAIT) BUT CAN
;	BE CHECKPOINTED AS WELL.  IN THE VMS ENVIRONMENT, THIS WILL
;	BE IMPLEMENTED USING THE HIBERNATE DIRECTIVES.
;
;   INPUTS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = STACK POINTER OF CM IMAGE
;	R10 = ADDRESS OF CM IMAGE DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
;   OUTPUTS:
;
;	R10, R11 ARE PRESERVED
;	DIRECTIVE STATUS IS PLACED IN THE IMAGE DSW; C-BIT SET.
;
;   DSW RETURN CODES:
;
;	IS.SET	SUCCESSFUL
;	IE.AST	ISSUING TASK IS AT AST STATE
;
;---
RSX$STOP::
	BBC	#SV_ASTLVL,I_STATE(R10),RSX$SPND ; IF NOT IN AST STATE
	$DSW	#IE.AST			; CANNOT ISSUE FROM AST ROUTINE

	.SBTTL	RSX$DSCP - RSX11M DSCP$ DIRECTIVE
;++
; RSX$DSCP - RSX11M DISABLE CHECKPOINTING TASK DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS A RSX DIRECTIVE HANDLER WHICH IMPLEMENTS AN RSX11M
; "DSCP$ DIRECTIVE.
;
; INPUT PARAMETERS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = CM IMAGE STACK ADDRESS
;	R10 = ADDRESS OF CM IMAGE DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUT PARAMETERS:
;
;	R10,R11 ARE PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	THE PROPER DIRECTIVE STATUS IS PLACED IN THE IMAGE DSW
;	ALONG WITH THE PROPER SETTING OF THE C-BIT.
;
; DSW RETURN CODES:
;
;	IS.SUC	SUCCESSFUL
;	IS.PRI	PRIVILEGE VIOLATION -- SS$_NOPRIV
;	IE.UPN	INSUFICIENT MEMORY -- SS$_INSFMEM
;	IE.NOD	QUOTA EXCEEDED -- SS$_EXQUOTA
;	IE.ITS	CHECKPOINTING IS DISABLED ALREADY
;	IE.PRI	PRIVILEGE VIOLATION
;--
RSX$DSCP::				; DISABLE CHECKPOINTING TASK DIRECTIVE
	$SETSWM_S #1			; INHIBIT PROCESS SWAPPING
	CMPW	R0,#SS$_WASCLR		; IF WAS CLEAR THEN NO ERROR
	BEQL	15$			; IF EQL THEN NO ERROR
	CMPW	R0,#SS$_WASSET		; IF WAS SET THEN ERROR
	BNEQ	10$			; IF NEQ THEN PRIVILEGE ERROR
	$DSW	#IE.ITS			; SET ERROR
10$:	$DSWIO	#IE.PRI			; SET ERROR
15$:	RSB				;

	.SBTTL	RSX$ENCP - RSX11M ENCP$ DIRECTIVE
;++
; RSX$ENCP - RSX11M ENABLE CHECKPOINTING TASK DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS A RSX DIRECTIVE HANDLER WHICH IMPLEMENTS AN RSX11M
; "ENCP$" DIRECTIVE. THE ONLY FUNCTION OF THEI DIRECTIVE, IS TO
; RETURN THE PROPER STATUS VALUE.
;
; INPUT PARAMETERS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = CM IMAGE STACK ADDRESS
;	R10 = ADDRESS OF CM IMAGE DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUT PARAMETERS:
;
;	R10,R11 ARE PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	THE PROPER DIRECTIVE STATUS IS PLACED IN THE IMAGE DSW
;	ALONG WITH THE PROPER SETTING OF THE C-BIT.
;
; DSW RETURN CODES:
;
;	IS.SUC	SUCCESSFUL
;	IS.PRI	PRIVILEGE VIOLATION -- SS$_NOPRIV
;	IE.UPN	INSUFICIENT MEMORY -- SS$_INSFMEM
;	IE.NOD	QUOTA EXCEEDED -- SS$_EXQUOTA
;	IE.ITS	CHECKPOINTING IS ALREADY ENABLED
;--
RSX$ENCP::				; ENABLE CHECKPOINTING TASK DIRECTIVE
	$SETSWM_S #0			; ALLOW PROCESS TO BE SWAPPED
	CMPW	R0,#SS$_WASSET		; IF WAS SET THEN NO ERROR
	BEQL	15$			; IF EQL THEN NO ERROR
	CMPW	R0,#SS$_WASCLR		; IF CLEAR THEN ERROR
	BNEQ	10$			; IF NEQ THEN PRIVILEGE ERROR
	$DSW	#IE.ITS			; SET ERROR
10$:	$DSWIO	#IE.PRI			; SET ERROR
15$:	RSB				;

	.SBTTL	MAPDSW - MAP DSW RETURN AFTER TASK CONTROL SERIVCE
;++
; MAPDSW - MAP THE PROPER DSW RETURN FOR THE TASK CONTROL DIRECTIVES
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED AFTER A SYSTEM SERVICE TO MAP THE VAX/VMS
; RETURN CODE INTO A DSW RETURN CODE.
; IF THE OPERATION WAS NOT SUCCESSFUL THEN THE POSSIBLE ERRORS
; ARE:
;
;	IE.PRI	PRIVILEGE VIOLATION
;	IE.INS	UNKNOWN	PROCESS
;
; INPUTS:
;
;	R0 = STATUS TO MAP
;	R10 = ADDRESS OF IMAGE DATA BASE
;	R11 = ADDRESS OF THE IMAGE HEADER
;
; OUTPUTS:
;
;	R10,R11 ARE PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	THE IMAGE DSW IS SET UP TO REFLECT THE STATUS OF THE
;	SYSTEM SERVICE. SUCCESSFUL IS IMPLIED.
;--
MAPDSW:					; MAP DSW RETURN
	BLBS	R0,20$			; IF LOW SET THEN SUCCESSFUL
	CMPW	R0,#SS$_NOPRIV		; PRIVILEGE VIOLATION?
	BNEQ	5$			; IF NEQ THEN NO
	$DSWIO	#IE.PRI			; SET STATUS AND RETURN
5$:	CMPW	R0,#SS$_INSFMEM		; NO MEMORY?
	BNEQ	10$			; IF NEQ THEN NO
	$DSW	#IE.UPN			; SET NO MEMORY ERROR
10$:	CMPW	R0,#SS$_EXQUOTA		; QUOTA PROBLEM?
	BNEQ	15$			; IF NEQ THEN NO
	$DSWIO	#IE.NOD			; SET QUOTA ERROR
15$:	$DSW	#IE.INS			; SET NO SUCH PROCESS ERROR
20$:	RSB				; RETURN

	.SBTTL	RSX$CHAN - IMAGE CHAIN DIRECTIVE
;---
; RSX$CHAN - IMAGE CHAIN DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE HANDLES THE BASIC+2 CHAIN COMMAND. IT WILL FORCE
; THE TERMINATION OF THE CURRENT TASK AND OBTAIN THE NAME OF THE
; NEW IMAGE AND ACTIVATE THAT IMAGE.
;
; DPB FORMAT:
;
;	WD. 00 -- DIC(145),DPB SIZE(4)
;	WD. 01 -- MODE=6
;	WD. 02 -- ADDRESS OF IMAGE NAME
;	WD. 03 -- LENGTH OF IMAGE NAME
;
; INPUTS:
;
;	R5 = ADDRESS OF DPB+2
;	R10 = ADDRESS OF CM DATA AREA
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUTS:
;
;	NEW IMAGE HAS BEEN EXECUTED.
;
; DSW RETURN CODES:
;
;	IE.ADP	ACCESS VIOLATION ON IMAGE NAME STRING
;
;---
RSX$CHAN::
	ADDL	#2,R5			; BYPASS MODE WORD
	MOVZWL	(R5)+,R3		; ADDRESS OF IMAGE FILE NAME
	CVTWL	(R5)+,R2		; LENGTH OF IMAGE NAME
	IFNORD	R2,(R3),10$		; BRANCH IF NO READ ACCESS
	CLRL	-(SP)			; NULL CLI AP ARGUMENT
	EXTZV	#SV_DCL,#1,I_STATE(R10),-(SP) ; EXTRACT CLI TYPE
	CLRL	-(SP)			; NO CLI CALLBACK ROUTINE
	MOVQ	R2,-(SP)		; PASS DESCRIPTOR OF FILE NAME
	$CANEXH_S W^RSX$A_EXITBLOCK	; CANCEL EXIT HANDLER
	CALLS	#0,W^RSX$FORCEEXIT	; TERMINATE CURRENT IMAGE
	CALLS	#5,W^RSX$ACTIVATE	; ACTIVATE THE IMAGE
	RET				; RETURN TO ORIGINAL CALLER
10$:	$DSW	#IE.ADP			; NO ACCESS TO BUFFER

	.SBTTL	RSX$NATV - EXECUTE NATIVE MODE CODE DIRECTIVE
;---
; RSX$NATV - EXECUTE NATIVE MODE CODE DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS DIRECTIVE ALLOWS A COMPATIBILITY MODE PROGRAM TO EXECUTE
; A NATIVE MODE GLOBAL SECTION. THE NAMES AND ADDRESS OF
; MAPPED GLOBAL SECTIONS ARE STORED IN A LIST TO PREVENT HAVING TO
; MAP THE SECTION ON EACH CALL.
;
; DPB FORMAT:
;
;	WD. 00 -- DIC(145),DPB SIZE(4)
;	WD. 01 -- MODE=4
;	WD. 02 -- ADDRESS OF GLOBAL SECTION NAME
;	WD. 03 -- LENGTH OF GLOBAL SECTION NAME
;
; INPUTS:
;
;	R5 = ADDRESS OF DPB+2
;	R10 = ADDRESS OF CM DATA AREA
;	R11 = ADDRESS OF IMAGE HEADER
;
; OUTPUTS:
;
;	THE NATIVE MODE GLOBAL SECTION IS MAPPED AND EXECUTED.
;
; DSW RETURN CODES:
;
;	IS.SUC	SUCCESSFUL
;	IE.ADP	ACCESS VIOLATION ON GLOBAL SECTION NAME STRING
;	IE.NSF	NO SUCH GLOBAL SECTION
;---
RSX$NATV::
	ADDL	#2,R5			; BYPASS MODE WORD
	MOVZWL	(R5)+,R3		; ADDRESS OF IMAGE FILE NAME
	CVTWL	(R5)+,R2		; LENGTH OF IMAGE NAME
	IFRD	R2,(R3),5$		; BRANCH IF HAVE READ ACCESS
	$DSW	#IE.ADP			; NO READ ACCESS TO DPB
5$:	BSBW	SEARCH_GLOBAL		; SEARCH GLOBAL SECTION LIST
	BLBS	R0,20$			; IF FOUND, DON'T MAP IT
;
;	THIS IS THE FIRST TIME WE HAVE INVOKED THIS IMAGE.
;	MERGE THE IMAGE INTO EXISTING P0 ADDRESS SPACE.
;
	MOVAB	W^RSX$T_LIBDEF,R1	; ADDRESS OF 'SYS$LIBRARY:.EXE'
	MOVZBL	(R1)+,R0		; GET LENGTH OF STRING
	MOVQ	R0,-(SP)		; PUT DEFAULT DESCRIPTOR ON STACK
	MOVQ	R2,-(SP)		; PUT INPUT DESCRIPTOR ON STACK
	CLRQ	-(SP)			; SPECIFY P0 REGION
	PUSHR	#^M<R2,R3>		; SAVE REGISTERS
	MOVL	#512,R1			; LENGTH OF IMAGE ACTIVATOR WORK AREA
	BSBW	RSX$ALLOCATE		; ALLOCATE A PAGE FOR IT
	POPR	#^M<R2,R3>		; RESTORE REGISTERS
	MOVL	R0,R7			; SAVE ADDRESS OF WORK AREA
	MOVL	SP,R1			; GET ADDRESS OF STACK
	$IMGACT_S NAME=8(R1),-		; MERGE IMAGE INTO ADDRESS SPACE
		DFLNAM=16(R1),-		; USING SYS$LIBRARY:.EXE AS DEFAULT
		HDRBUF=(R7),-		; ADDRESS OF WORK AREA
		IMGCTL=#IAC$M_MERGE!IAC$M_EXPREG,- ; MERGE INTO REGION
		INADR=(R1),-		; ADDRESS RANGE TO MAP INTO
		RETADR=(R1)		; ADDRESS TO RETURN RANGE TO
	BLBC	R0,80$			; BRANCH IF ERROR
	$IMGFIX_S			;
	BLBC	R0,80$			; IF LBC, ERROR
	MOVQ	(R7),R8			; ADDRESS OF IHD (IMAGE HEADER DESC)
	MOVZWL	IHD$W_ACTIVOFF(R8),R0	; GET OFFSET TO ACTIVATION DATA
	MOVAB	IHA$L_TFRADR1(R8)[R0],R1 ; ADDRESS OF TRANSFER ADDRESS ARRAY
	BSBB	ADD_GLOBAL		; ADD TO GLOBAL SECTION LIST
	ADDL	#24,SP			; DEALLOCATE DESCRIPTORS
;
;	CALL THE IMAGE
;
20$:	MOVQ	(R7),R8			; ADDRESS OF IHD (IMAGE HEADER DESC)
	MOVZWL	IHD$W_ACTIVOFF(R8),R0	; GET OFFSET TO ACTIVATION DATA
	MOVAB	IHA$L_TFRADR1(R8)[R0],R1 ; ADDRESS OF TRANSFER ADDRESS ARRAY
	PUSHR	#^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,AP,FP>
	PUSHL	R5			; ADDRESS OF DPB+8
	PUSHL	#0			; NO CLI OPTION FLAGS
	PUSHL	IHD$L_LNKFLAGS(R8)	; PASS THRU LINK OPTION FLAGS
	MOVQ	R8,-(SP)		; ADDRESS OF IHD AND IFD
	PUSHAB	B^CLICALLBACK		; ADDRESS OF DUMMY CALL BACK ROUTINE
	PUSHL	R1			; ADDRESS OF TRANSFER ADDRESS ARRAY
	CALLS	#7,@(R1)		; CALL NATIVE MODE CODE
	POPR	#^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,AP,FP>
	MOVW	R0,H.DSW(R11)		; SET DSW STATUS CODE
	BGEQ	30$			; BRANCH IF SUCCESSFUL
	BISW	#1@PSL_CC,I_PS(R10)	; SET CARRY BIT TO INDICATE ERROR
30$:	RSB				; EXIT FROM DIRECTIVE
;
;	ERROR FROM $IMGACT CALL - MAP TO IE.NSF (NO SUCH FILE)
;
80$:	ADDL	#24,SP			; CLEANUP DESCRIPTORS AND WORK PAGE
	MOVL	R7,R0			; ADDRESS OF WORK PAGE
	MOVL	#512,R1			; LENGTH OF WORK PAGE
	BSBW	RSX$DEALLOCATE		; DEALLOCATE IT
	$DSW	#IE.NSF			; NO SUCH FILE

;
; SUBROUTINE TO SEARCH THE GLOBAL SECTION LIST
;
SEARCH_GLOBAL:
	MOVL	I_SECTION(R10),R7	; ADDRESS OF FIRST ENTRY
10$:	BEQL	50$			; BRANCH IF NOT FOUND
	MOVZBL	8(R7),R0		; LENGTH OF STRING NAME
	CMPC5	R0,9(R7),#0,R2,(R3)	; STRING MATCH?
	BEQL	20$			; BRANCH IF FOUND
	MOVL	(R7),R7			; NEXT ENTRY IN LIST
	BRB	10$			; AND CONTINUE SEARCHING
20$:	MOVL	4(R7),R7		; RETURN ADDRESS OF IMGACT WORK PAGE
	MOVL	#1,R0			; SUCCESS
	RSB
50$:	CLRL	R0			; FAILURE
	RSB

;
; SUBROUTINE TO ADD ENTRY TO GLOBAL SECTION LIST
;
ADD_GLOBAL:
	PUSHR	#^M<R1,R2,R3>		; SAVE ADDRESS, DESCRIPTOR
	ADDL3	#9,R2,R1		; LENGTH DESIRED
	BSBW	RSX$ALLOCATE		; ALLOCATE MEMORY
	POPR	#^M<R1,R2,R3>		; RESTORE ADDRESS, DESCRIPTOR
	MOVL	I_SECTION(R10),(R0)	; INSERT INTO LIST
	MOVL	R0,I_SECTION(R10)
	MOVL	R7,4(R0)		; STORE ADDRESS OF IMGACT WORK PAGE
	MOVB	R2,8(R0)		; STORE LENGTH OF COUNTED STRING
	PUSHR	#^M<R1,R2,R3,R4,R5>	; SAVE REGISTERS
	MOVC	R2,(R3),9(R0)		; STORE STRING ITSELF
	POPR	#^M<R1,R2,R3,R4,R5>	; RESTORE REGISTERS
	RSB

;
; DUMMY CLI CALL BACK ROUTINE
;
CLICALLBACK:
	.WORD	0
	CLRL	R0			; RETURN FAILURE
	RET

;
	.END
