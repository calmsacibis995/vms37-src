	.TITLE	RSXTTYDRV - VAX/VMS RSX11M AME TERMINAL DRIVER
	.IDENT	'V03-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:
;
;	VAX/VMS RSX11M AME 
;
; ABSTRACT:
;
;	TERMINAL I/O DRIVER
;
; AUTHOR: R.HEINEN 4-NOV-76
;
; PREVIOUSLY MODIFIED BY:
;
;	Tim Halvorsen
;	Michael S. Harvey
;
; MODIFIED BY:
;
;	V001	MSH025		Michael S. Harvey	16-Mar-82
;		Revamp unsolicited and control-c AST handling for
;		terminal attach/detach functions.
;--
;
; EXTERNAL SYMBOLS
;
	$RSXDEF			; DEFINE RSX SYMBOLS
	DRERR$			; DEFINE RSX11M DIRECTIVE STATUS CODES
	SPCIO$			; DEFINE RSX11M SPECIAL I/O CODES
	FILIO$			; DEFINE RSX11M FILE I/O CODES
	$DEVDEF			; DEFINE DEVICE CHARACTERISTICS BITS
	$DIBDEF			; DEFINE GETCHN BUFFER OFFSETS
	$TTDEF			; DEFINE TERMINAL SPECIAL SYMBOLS
	$QIODEF			; DEFINE QIO ARGUMENT LIST
	TTSYM$			; DEFINE RSX TERMINAL CODES
;
; LOCAL MACROS
;
; THIS MACRO DEFINES THE TERMINAL TYPE TRANSLATION TABLE WITH ALL
; ASSOCIATED IMPLICIT CHARACTERISTICS. THE ARGUMENTS ARE AS FOLLOWS:
;
;	VTYP	VMS TERMINAL TYPE CODE
;	RTYP	RSX TERMINAL TYPE CODE
;	WID	PAGE WIDTH FOR THE SPECIFIED TERMINAL TYPE
;	LPP	PAGE LENGTH FOR THE SPECIFIED TERMINAL TYPE
;	HFF	1 IF TERMINAL HAS HARDWARE FORMFEED CAPABILITY
;	HHT	1 IF TERMINAL HAS HARDWARE HORIZONTAL TAB CAPABILITY
;	HFL	NUMBER OF FILL CHARACTERS TO BE INSERTED AFTER <CR>
;	VFL	1 IF 4 FILL CHARACTERS MUST BE INSERTED AFTER <LF>
;	SCP	1 IF SCOPE
;
; A TABLE IS PRODUCED AS FOLLOWS:
;
;	BYTE CONTAINING THE VMS TERMINAL TYPE CODE
;	BYTE CONTAINING THE RSX TERMINAL TYPE CODE
;	1ST CHARACTERISTICS LONGWORD FOR THIS TYPE
;	BIT CLEAR MASK FOR SECOND CHARACTERISTICS LONGWORD
;	BIT SET MASK FOR SECOND CHARACTERISTICS LONGWORD
;	BYTE CONTAINING THE PAGE LENGTH
;	WORD CONTAINING FILL INFORMATION FOR SETMODE P4 ARGUMENT
;
; A TABLE ENTRY IS 17 BYTES LONG.
;
	.MACRO	TERM	VTYP,RTYP,WID,LPP,HFF=0,HHT=0,HFL=0,VFL=0,SCP=0
	.BYTE	VTYP,RTYP
	.LONG	<WID@16>+<VTYP@8>+DC$_TERM
	$CLR$$=0
	$SET$$=0
	.IF EQ	HFF
	$CLR$$=$CLR$$!TT$M_MECHFORM
	.IFF
	$SET$$=$SET$$!TT$M_MECHFORM
	.ENDC
	.IF EQ	HHT
	$CLR$$=$CLR$$!TT$M_MECHTAB
	.IFF
	$SET$$=$SET$$!TT$M_MECHTAB
	.ENDC
	.IF EQ	HFL
	$CLR$$=$CLR$$!TT$M_CRFILL
	.IFF
	$SET$$=$SET$$!TT$M_CRFILL
	.ENDC
	.IF EQ	VFL
	$CLR$$=$CLR$$!TT$M_LFFILL
	.IFF
	$SET$$=$SET$$!TT$M_LFFILL
	.ENDC
	.IF EQ	SCP
	$CLR$$=$CLR$$!TT$M_SCOPE
	.IFF
	$SET$$=$SET$$!TT$M_SCOPE
	.ENDC
	.LONG	$CLR$$,$SET$$
	.BYTE	LPP
	.WORD	<VFL*4>@8+HFL
	.ENDM	TERM
;
; LOCAL SYMBOLS
;
; THIS SYMBOL DEFINES THE START OF THE SCRATCH AREA PAST THAT PART
; USED ALREADY BY THE QIO DIRECTIVE PROCESSING CODE.
;
I_CHARACTER=	I_SCRATCH+I_QIOSCRATCH	; START OF LOCAL SCRATCH AREA
;
; LOCAL STORAGE
;
	.PSECT	RSXPURE,NOWRT,EXE,LONG,PIC,SHR
SETGETTAB:				; TABLE OF TERMINAL CHARACTERISTIC RELATIONS
	.BYTE	TC.ESQ,TT$V_ESCAPE	;
	.BYTE	TC.SCP,TT$V_SCOPE	;
	.BYTE	TC.NEC,TT$V_NOECHO	;
	.BYTE	TC.SMR,TT$V_LOWER	;
	.BYTE	TC.HLD,TT$V_HOLDSCREEN	;
	.BYTE	TC.PRI,32		;
	.BYTE	TC.SLV,TT$V_NOTYPEAHD	;
	.BYTE	TC.BIN,TT$V_PASSALL	;
	.BYTE	0			;
					; EXTENDED TERM. CHARS. TABLE
	.BYTE	0			;
;
; TERMINAL TYPE TRANSLATION TABLE
;
TYPETAB:
	TERM	DT$_LA36,T.LA36,WID=132,LPP=66
	TERM	DT$_VT05,T.VT05,WID=72,LPP=20,HHT=1,VFL=1,SCP=1
	TERM	DT$_VT52,T.VT52,WID=80,LPP=24,HHT=1,SCP=1
	TERM	DT$_VT55,T.VT55,WID=80,LPP=24,HHT=1,SCP=1
	TERM	DT$_VT100,T.V100,WID=80,LPP=24,HHT=1,SCP=1
	TERM	DT$_LA120,T.L120,WID=132,LPP=66,HFF=1
	TERM	DT$_LA34,T.LA34,WID=132,LPP=66,HFF=1
	TERM	DT$_LA38,T.LA38,WID=132,LPP=66,HFF=1
	TERM	DT$_LA12,T.LA12,WID=132,LPP=66,HHT=1,HFF=1
	TERM	DT$_VT101,T.V101,WID=80,LPP=24,HHT=1,SCP=1
	TERM	DT$_VT102,T.V102,WID=80,LPP=24,HHT=1,SCP=1
	TERM	DT$_VT105,T.V105,WID=80,LPP=24,HHT=1,SCP=1
	TERM	DT$_VT125,T.V125,WID=80,LPP=24,HHT=1,SCP=1
	TERM	DT$_VT131,T.V131,WID=80,LPP=24,HHT=1,SCP=1
	TERM	DT$_VT132,T.V132,WID=80,LPP=24,HHT=1,SCP=1
	.BYTE	0
;
; TERMINAL READ TERMINATOR TABLE
;
TERMINATOR:
	.LONG	0			;
	.LONG	<1@13>+<1@26>+<1@27>	; CR,ESC AND ^Z
SPECIALTRM:				; 11M READ WITH SPECIAL TERMINATORS
	.LONG	16			;
	.LONG	10$
10$:	.LONG	-1
	.LONG	0
	.LONG	0
	.LONG	1@31
RSX$GL_CARRIAGE::			; CARRIAGE CONTROL CONVERTION
	.BYTE	1,128+13,^A/ /		; SPACE
	.BYTE	2,128+13,^A/0/		; 0
	.BYTE	128+12,128+13,^A/1/	; 1
	.BYTE	0,128+13,^A/+/		; +
	.BYTE	1,0,^A/$/		; $
	.BYTE	1,128+13,0		; DEFAULT

	.SBTTL	RSX$TTY_DRV - RSX11M AME TERMINAL I/O DRIVER
	.PSECT	RSXCODE,NOWRT,SHR,PIC
;++
; RSX$TTY_DRV TERMINAL I/O DRIVER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE PROCESSES TERMINAL DIRECTED I/O.
;
; INPUTS:
;
;	R0/R1 = PRESET I/O STATUS
;	R2 = ADDRESS OF THE QIO CONTEXT BLOCK
;	R3 = MAJOR FUNCTION CODE
;	R5 = QIO DPB AREA ADDRESS
;	R6 = IMAGE STACK POINTER
;	R7 = ENTIRE FUNCTION CODE
;	R8 = LUT ADDRESS
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	R6,R10,R11 ARE PRESERVED.
;--
RSX$TTY_DRV::
;
; IF THE LUN BEING USED IS "TI", THEN FORCE THE USE OF THE STANDARD
; TI LUT ENTRIES, RSX$A_TIIDEV AND RSX$A_TIODEV (THIS IS USED BY KILL
; IN PARTICULAR).  THIS MUST BE DONE BEFORE THE FOLLOWING TERMINAL I/O
; COUNT IS INCREMENTED.
;
	ASHL	R3,#1,R4		; SHIFT INTO BIT POSITION
	BITL	R4,#<-			; TEST IF ANY READ FUNCTIONS
		<1@2>!-			; 2 = RLB
		<1@9>!-			; 9 = RPR
		<1@17>>			; 17 = RVB
	BEQL	10$			; BRANCH IF NONE
	BSBW	RSX$CHK_TI_INP		; FORCE STANDARD TI LUN
	BRB	20$
10$:	BITL	R4,#<-			; TEST IF ANY WRITE FUNCTIONS
		<1@1>!-			; 1 = WLB
		<1@18>>			; 18 = WVB
	BEQL	20$			; BRANCH IF NONE
	BSBW	RSX$CHK_TI_OUT		; RE-DIRECT TI FOR OTHER DEVICES

20$:	CASE	R3,<-			;
		TTY_KILL,-		; I/O KILL
		TTY_WLB,-		; WRITE LOGICAL BLOCK
		TTY_RLB,-		; READ LOGICAL BLOCK
		TTY_ATT,-		; ATTACH DEVICE
		TTY_DET,-		; DETACH DEVICE
		TTY_SET,-		; SET CHARACTERISTICS
		TTY_HANG,-		; HANGUP TERMINAL FUNCTION
		RSX$IEIFC,-		; FUNCTION CODE 7
		RSX$IEIFC,-		; FUNCTION CODE 8
		TTY_RPR,-		; READ WITH PROMPT
		TTY_RTT,-		; READ WITH TERMINATOR TABLE
		RSX$DLVRQIOAST,-	; REMOVE FILE NAME
		RSX$DLVRQIOAST,-	; ENTER FILE NAME
		RSX$DLVRQIOAST,-	; ACCESS FOR READ
		RSX$DLVRQIOAST,-	; ACCESS FOR WRITE
		RSX$DLVRQIOAST,-	; ACCESS FOR EXTEND
		RSX$DLVRQIOAST,-	; DEACCESS
		TTY_RVB,-		; READ VIRTUAL BLOCK
		TTY_WVB,-		; WRITE VIRTUAL BLOCK
		RSX$DLVRQIOAST,-	; EXTEND FILE
		RSX$DLVRQIOAST,-	; CREATE FILE
		RSX$DLVRQIOAST,-	; DELETE FILE
		RSX$DLVRQIOAST,-	; READ ATTRIBUTES
		RSX$DLVRQIOAST,-	; WRITE ATTRIBUTES
		RSX$DLVRQIOAST,-	; ACP CONTROL
		>
	BRW	RSX$IEIFC		; ILLEGAL FUNCTION

	.SBTTL	TTY_RPR,TTY_RVB AND TTY_RLB FUNCTIONS
	.ENABL	LSB
;
; READ PROMPT FUNCTION
;
TTY_RPR:				; TERMINAL READ PROMPT
	MOVZWL	#IO$_READPROMPT,I_SCRATCH+12(R10); ASSUME PROMPTED READ
	MOVZWL	6(R5),I_SCRATCH+44(R10)	; INSERT PROMPT ADDRESS
	MOVZWL	8(R5),I_SCRATCH+48(R10)	; INSERT SIZE OF PROMPT
	MOVZWL	4(R5),I_SCRATCH+36(R10)	; INSERT TIMEOUT COUNT
	BEQL	10$			; IF EQL THEN NO TIMEOUT
	BISW	#IO$M_TIMED,I_SCRATCH+12(R10)
	BRB	10$			; CONTINUE IN COMMON
;
; READ WITH TERMINATOR TABLE (IO.RTT)
;
TTY_RTT:
	MOVZWL	#IO$_READVBLK!IO$M_TRMNOECHO!IO$M_NOFILTR,I_SCRATCH+12(R10)
	MOVAB	I_SCRATCH+60(R10),I_SCRATCH+40(R10) ; ADDRESS OF DESCRIPTOR
	MOVL	#32,I_SCRATCH+60(R10)	; CREATE DESCRIPTOR OF TERM. TABLE
	MOVZWL	6(R5),I_SCRATCH+64(R10)	; AND GET ADDRESS FROM USER
	MOVZWL	4(R5),I_SCRATCH+36(R10)	; INSERT TIMEOUT COUNT
	BEQL	20$			; BRANCH IF NOT SPECIFIED
	BISW	#IO$M_TIMED,I_SCRATCH+12(R10) ; ELSE READ WITH TIMEOUT
	BRB	20$
;
; READ VIRTUAL FUNCTIONS
;
TTY_RVB:				; TERMINAL READ VIRTUAL
	CLRB	R7			; REMOVE SUBFUNCTION BITS
	MOVZWL	#IO$_READVBLK,I_SCRATCH+12(R10); SET UP FUNCTION CODE
	BRB	10$			; CONTINUE IN COMMON
;
; READ LOGICAL FUNCTION
;
TTY_RLB:				; READ LOGICAL
	MOVZWL	#IO$_READLBLK,I_SCRATCH+12(R10); SET UP FUNCTION CODE
;
; ASSUME NORMAL RSX TERMINATORS
;
10$:	MOVAB	W^TERMINATOR,I_SCRATCH+40(R10); SET TERMINATOR BITMASK
;
; READ - SPECIAL TERMINATORS - IO.RST
;
	BITB	#<IO.RST&^X0FF>,R7	; READ SPECIAL TERMINATORS?
	BEQL	20$			; IF EQL THEN NO
	BISW	#IO$M_TRMNOECHO!IO$M_NOFILTR,I_SCRATCH+12(R10); SET FUNCTION CODE
	MOVAB	W^SPECIALTRM,I_SCRATCH+40(R10); SET TERMINATORS
;
; CLEAR CONTROL O CANCEL ON TERMINAL
;
20$:	BBCC	#LUTV_CTRLO,LUT_FLAGS(R8),22$; CLEAR CONTROL O
22$:
;
; READ - PASSALL
;
30$:	BITB	#IO.RAL&^X0FF,R7	; READ PASSALL?
	BEQL	40$			; IF EQL THEN NOT SPECIFIED
;
; READ PASSALL WITHOUT THE NOECHO BIT IS A READ NO FILTER
; READ PASSALL AND NOECHO IS A READ READ PASSALL.
;
	BISW	#IO$M_NOFILTR,I_SCRATCH+12(R10); ASSUME NO FILTER
	MOVAB	I_SCRATCH+60(R10),I_SCRATCH+40(R10);SET UP PASSALL DESC
	MOVL	#1,I_SCRATCH+60(R10)
	MOVAB	I_SCRATCH+68(R10),I_SCRATCH+64(R10)
	CLRL	I_SCRATCH+68(R10)
;
; READ - NOECHO
;
40$:	BITB	R7,#<IO.RNE&^X0FF>	; READ NO ECHO?
	BEQL	50$			; IF EQL THEN NO
	BISW	#IO$M_NOECHO,I_SCRATCH+12(R10); INSERT READ NO ECHO
;
; CHECK FOR READ PHYSICAL BLOCK
;
50$:	BITW	#<IO.RPB&^X0FF>,R7	; READ PHYSICAL SET?
	BEQL	60$			; IF EQL THEN NO
	INSV	#IO$_READPBLK,#0,#6,I_SCRATCH+12(R10); SET READ PHYSICAL FUNCTION
	MOVAB	I_SCRATCH+60(R10),I_SCRATCH+40(R10); SET UP PASSALL DESC
	MOVL	#1,I_SCRATCH+60(R10)
	MOVAB	I_SCRATCH+68(R10),I_SCRATCH+64(R10)
	CLRL	I_SCRATCH+68(R10)
;
; ISSUE I/O
;
60$:	BBSS	#QIOV_READ,QIO_FLAGS(R2),65$ ; MARK I/O IS A READ FUNCTION
65$:	BRW	RSX$ISSUQIO		; EXECUTE QIO
 
	.DSABL	LSB

	.SBTTL	TTY_WVB AND TTY_WLB FUNCTIONS
 
	.ENABL	LSB
;
; TERMINAL WRITE VIRTUAL BLOCK
;
TTY_WVB:				; WRITE VIRTUAL BLOCK
	CLRB	R7			; REMOVE SUBFUNCTION BITS
	MOVZWL	#IO$_WRITEVBLK,I_SCRATCH+12(R10); SET FUNCTION CODE
	BRB	10$			; CONTINUE IN COMMON
;
; TERMINAL WRITE LOGICAL BLOCK
;
TTY_WLB:				; WRITE LOGICAL BLOCK
	MOVZWL	#IO$_WRITELBLK,I_SCRATCH+12(R10); SET FUNCTION CODE
;
; TERMINAL WRITE SUBFUNCTIONS
;
10$:	BITB	R7,#<IO.WAL&^X0FF>	; RSX WRITE PHYSICAL?
	BEQL	20$			; IF EQL THEN NO
	BISW	#IO$M_NOFORMAT,I_SCRATCH+12(R10); SET FUNCTION
20$:	BITB	R7,#<IO.CCO&^X0FF>	; CANCEL CONTROL O?
	BNEQ	30$			; SET SUBFUNCTION IF YES
	BBCC	#LUTV_CTRLO,LUT_FLAGS(R8),40$; BR IF NOT SPECIAL CASE
30$:	BISW	#IO$M_CANCTRLO,I_SCRATCH+12(R10); SET CANCEL CONTROL O
;
; ISSUE THE QIO
;
40$:	BRW	RSX$ISSUQIO		; ISSUE THE QIO

	.DSABL	LSB

;
; TTY_KILL - I/O KILL  FUNCTION
;
TTY_KILL:				; I/O KILL
;
; SPECIAL CASE TI:
;
	CMPW	#^A/TI/,LUT_RSXNAME(R8)	; BR IF NOT TI
	BNEQ	10$			; IF NEQ THEN NOT TI
	MOVAB	W^RSX$A_TIIDEV,R0	; ADDRESS TI INPUT LUT
	CMPW	LUT_CHAN(R8),LUT_CHAN(R0); OUTPUT SAME AS INPUT?
	BNEQ	5$			;
	MOVAB	W^RSX$A_TIODEV,R0	; GET OTHER LUT
5$:	$CANCEL_S	LUT_CHAN(R0)	; CANCEL I/O ON COMPLEMENT LUT
10$:	BRW	RSX$IOKILL		; KILL THE I/O

	.SBTTL	TTY_ATT - ATTACH FUNCTION

CTRLC	=	^X03			; CONTROL/C CHARACTER

;
; TTY_ATT - ATTACH DEVICE FUNCTION
;
TTY_ATT:				;  ATTACH DEVICE
	BISB	#1@LUTV_CTRLO,LUT_FLAGS(R8); SET THE CANCEL CONDITION
	MOVL	R8,R1			; COPY ADDRESS OF DEVICE LUT
	CMPW	#^A/TI/,LUT_RSXNAME(R8)	; BR IF NOT TI
	BNEQ	10$			; IF NEQ THEN NOT TI
	MOVAB	W^RSX$A_TIIDEV,R1	; USE TI (INPUT) LUT FOR DEVICE FLAGS
	BISB	#1@LUTV_CTRLO,W^LUT_FLAGS+RSX$A_TIIDEV; SET CANCEL
	BISB	#1@LUTV_CTRLO,W^LUT_FLAGS+RSX$A_TIODEV; SET CANCEL
;
; IF TERMINAL ALREADY ATTACHED, RETURN AN ERROR
;
10$:	BBCS	#LUTV_ATTACHED,LUT_FLAGS(R1),11$ ; BRANCH IF OK
	MOVZWL	#SS$_DEVALLOC,R0	; RETURN WITH IE.DAA
	BRB	12$			; REPORT ERROR IN IOSB

11$:	CMPB	#<IO.ATA&^X0FF>,R7	; ATTACH FOR UNSOLICITED DATA?
	BEQL	15$			; BRANCH IF REQUESTED
12$:	BRW	110$			; EXIT SUCCESSFULLY
;
; AST SPECIFIED
;
15$:	MOVZWL	(R5),R4			; GET P1 ADDRESS (FIRST AST)
	BNEQ	18$			; BRANCH IF SPECIFIED
	MOVZWL	4(R5),R4		; GET P3 ADDRESS
	BNEQ	60$			; PROCESS CONTROL-C AST ROUTINE
16$:	MOVZBL	#SS$_ACCVIO,R0		; INVALID AST ADDRESS SPECIFIED
	BRW	110$			; EXIT SUCCESSFULLY
;
; QIO ARGUMENTS ARE:
;	P1 = UNSOLICITED AST ROUTINE ADDRESS
;	P3 = CONTROL/C AST ROUTINE ADDRESS
;
18$:	BLBS	R4,16$			; IF LBS, INVALID AST ADDRESS
	BBSS	#SV_UNSOLAST,I_STATE(R10),50$ ; ENABLE, BR IF ENABLED
	MOVL	R2,R9			; SAVE I/O AST ADDRESS
	MOVL	I_UNSOLAST(R10),R2	; ADDRESS CURRENT AST BLOCK
	BNEQ	20$			; BRANCH IF AST BLOCK ALLOCATED
	BSBW	RSX$SETUPAST		; ALLOCATE AN AST CONTROL BLOCK
	MOVL	R8,ACB_LUT(R2)		; SET LUT ADDRESS
	MOVW	#<1@ACBV_PERM>+<ACBC_UNSOLAST@ACBV_TYPE>,ACB_FLAGS(R2)
	BSBW	RSX$UNSOLCREATE		; CREATE UNSOLICITED MAILBOX
	BLBS	R0,19$			; BRANCH IF SUCCESS
	INSQUE	(R2),I_ASTPOOL(R10)	; DEALLOCATE AST CONTROL BLOCK
	BRB	34$			; DO MORE CLEANUP

19$:	MOVL	R2,I_UNSOLAST(R10)	; SAVE AST BLOCK ADDRESS
	BBSS	#LUTV_UNSOL,LUT_FLAGS(R8),30$ ; TT ATTACHED FOR UNSOLICITED ASTS
	BRB	30$
20$:	BBS	#ACBV_INPROG,ACB_FLAGS(R2),40$ ; IN PROGRESS, ENABLE ON ASTX
30$:	MOVW	R4,ACB_UPC(R2)		; SET AST ROUTINE ADDRESS
	BSBW	RSX$UNSOLASTEN		; ENABLE UNSOLICITED CHAR. ASTS
	BLBS	R0,40$			; BRANCH IF SUCCESS
	PUSHL	R9			; SAVE R9
	MOVL	R2,R9			; COPY AST CONTROL BLOCK ADDRESS
	BSBW	RSX$UNSOLDELETE		; CLEAN UP UNSOLICITED MAILBOX
	MOVL	(SP)+,R9		; RESTORE I/O AST ADDRESS
	CLRL	I_UNSOLAST(R10)		; CLR UNSOL ACB POINTER
34$:	BICW2	#<1@LUTV_UNSOL>!<1@LUTV_ATTACHED>,LUT_FLAGS(R8)
	BBCC	#SV_UNSOLAST,I_STATE(R10),90$ ; CLEAR UNSOL AST FLAG
	BRB	90$			; EXIT DIRECTIVE

40$:	MOVL	R9,R2			; RESTORE I/O AST ADDRESS
50$:	TSTW	4(R5)			; BOTH P1 AND P3 SPECIFIED?
	BEQL	60$			; IF NOT, SEND CTRL/C'S TO P1 AST
	MOVZWL	4(R5),R4		; ELSE, SEND CTRL/C'S ONLY TO P3 AST
;
; ASK FOR AST ON CONTROL C. THE AST ADDRESS IS NOT VALIDATED HERE TO
; BE CONSISTENT WITH RSX-11'S TERMINAL DRIVER. IF THE AST IS INVALID,
; THE USER WILL FIND OUT WHEN A CONTROL C IS TYPED. THIS BEHAVIOR EXISTS
; ON RSX SYSTEMS.
;
60$:	MOVZBL	#SS$_NORMAL,R0		; SET SUCCESS STATUS
	BBSS	#LUTV_CTRLC,LUT_FLAGS(R8),110$ ; ENABLE, BR IF ENABLED
	MOVL	R2,R9			; SAVE ADDRESS OF THE I/O CONTEXT
	MOVL	LUT_CTRLC(R8),R2	; ADDRESS CURRENT BLOCK
	BEQL	70$			; IF EQL THEN NONE IN USE YET
	BBS	#ACBV_INPROG,ACB_FLAGS(R2),90$; BR IF IN PROGRESS - ENABLE AFTER ASTX
	BRB	80$			; CONTINUE IN COMMON
70$:	BSBW	RSX$SETUPAST		; ALLOCATE A CONTROL BLOCK
80$:	MOVL	R2,LUT_CTRLC(R8)	; SAVE ADDRESS OF THE CONTEXT
	MOVZBW	#CTRLC,ACB_UPRM(R2)	; PARAM = CONTROL/C CHARACTER
	MOVW	R4,ACB_UPC(R2)		; SAVE AST SERVICE ADDRESS
	MOVW	#<1@ACBV_PERM>+<ACBC_CTLRCAST@ACBV_TYPE>,ACB_FLAGS(R2); SET TYPE
	MOVL	R8,ACB_LUT(R2)		; SAVE LUT ADDRESS
	BSBW	RSX$CTRLCASTEN		; ENABLE AST
90$:	MOVL	R9,R2			; RESET QIO CONTEXT
;
; FINISH OPERATION
;
110$:	CLRL	R1			;
	BRW	RSX$DLVRQIOAST		; POST STATUS

	.SBTTL	TTY_DET DETACH TERMINAL FUNCTION
;
; TTY_DET - DETACH TERMINAL FUNCTION
;
TTY_DET:				; DETACH TERMINAL
	BISB	#1@LUTV_CTRLO,LUT_FLAGS(R8); SET THE CANCEL CONDITION
	MOVL	R8,R1			; COPY ADDRESS OF DEVICE LUT
	MOVZWL	#SS$_DEVNOTALLOC,R0	; ASSUME NOT DEVICE NOT ATTACHED
	CMPW	#^A/TI/,LUT_RSXNAME(R8)	; BR IF NOT TI
	BNEQ	30$			; IF NEQ THEN NOT TI
	BISB	#1@LUTV_CTRLO,W^LUT_FLAGS+RSX$A_TIIDEV; SET CANCEL
	BISB	#1@LUTV_CTRLO,W^LUT_FLAGS+RSX$A_TIODEV; SET CANCEL
	MOVAB	W^RSX$A_TIIDEV,R1	; USE TI (INPUT) FOR DEVICE FLAGS
30$:	BBCC	#LUTV_ATTACHED,LUT_FLAGS(R1),45$ ; INDICATE NO LONGER ATTACHED
	MOVZBL	#SS$_NORMAL,R0		; ASSUME SUCCESS
	BSBB	RSX$DSABL_TTY		; DISABLE TERMINAL ASTS
;
; FINISH OPERATION BY FLUSHING THE TYPEAHEAD BUFFER
;
40$: ;	$QIOW_S	CHAN=LUT_CHAN(R8),-	; FLUSH TYPEAHEAD BUFFER
;		FUNC=#IO$_READVBLK!IO$M_PURGE,-
;		P1=I_CHARACTER(R10),-
;		P2=#0
45$:	CLRL	R1			; SECONDARY STATUS VALUE
	BRW	RSX$DLVRQIOAST		; POST THE STATUS
	.PAGE
	.SBTTL	RSX$DSABL_TTY - DISABLE TT ASTS
;++
; RSX$DSABL_TTY - DISABLE ASTS FOR TERMINAL
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE DISABLES UNSOLICITED INPUT ASTS AND CONTROL/C ASTS FOR
; A LUT ASSIGNED TO A TERMINAL.
;
; INPUTS:
;
;	R8 = ADDRESS OF LUT
;	R10 = ADDRESS OF IMAGE IMPURE AREA
;
; OUTPUTS:
;
;	R0 = STATUS OF THE OPERATION
;	ALL OTHER REGISTERS ARE PRESERVED.
;--
RSX$DSABL_TTY::				; ENTRY POINT
	PUSHL	R9			; SAVE R9
;
; DISABLE UNSOLICITED CHARACTER AST
;
34$:	BBCC	#LUTV_UNSOL,LUT_FLAGS(R8),35$ ; TT ATTACHED FOR UNSOLICITED ASTS?
	BBCC	#SV_UNSOLAST,I_STATE(R10),35$ ; YES, CLR IMAGE FLAG TOO
	MOVL	I_UNSOLAST(R10),R9	; ADDRESS AST CONTROL BLOCK
	CLRL	I_UNSOLAST(R10)		; CLEAR UNSOLICITED ACB POINTER
	BISW2	#1@ACBV_OLD_ACB,ACB_FLAGS(R9) ; STOP AUTOMATIC REQUEUING
	BBS	#ACBV_INPROG,ACB_FLAGS(R9),35$ ; IF IN PROGRESS, SKIP DISABLE
	BSBW	RSX$UNSOLDSABL		; DISABLE UNSOLICITED FUNCTION
	BSBW	RSX$UNSOLDELETE		; DELETE UNSOLICITED AST MAILBOX
;
; DISABLE CONTROL C AST
;
35$:	BBCC	#LUTV_CTRLC,LUT_FLAGS(R8),40$; BR IF CONTROL C NOT ENABLED
	MOVL	LUT_CTRLC(R8),R9	; ADDRESS CONTEXT OF AST
	CLRL	LUT_CTRLC(R8)		; CLEAR CONTROL-C ACB POINTER
	BISW2	#1@ACBV_OLD_ACB,ACB_FLAGS(R9) ; STOP AUTOMATIC REQUEUING
	BBS	#ACBV_INPROG,ACB_FLAGS(R9),40$ ; IF IN PROGRESS, SKIP DISABLE
	BSBW	RSX$CTRLCDSABL		; DISABLE FUNCTION

40$:	MOVL	(SP)+,R9		; RESTORE R9
	RSB				; DONE

	.SBTTL	TTY_SET FUNCTIONS
;
; SET MODE FUNCTIONS FOR TERMINALS
;
	.ENABL	LSB
TTY_SET:				; TERMINAL SET MODE 
	MOVZWL	(R5)+,R4		; ADDRESS BUFFER
	MOVL	R4,R9			; COPY START OF BUFFER FOR POSSIBLE ERROR
	MOVZWL	(R5),R5			; GET REQUEST SIZE
	TSTB	R7			; IO.GTS?
	BNEQ	20$			; IF NEQ THEN NO
;
; GET TERMINAL SUPPORT
;
	MOVZWL	#SS$_ACCVIO,R0		; ASSUME ERROR
	IFNOWRT R5,(R4),10$		; BR IF NOT WRITTABLE
	CMPW	#4,R5			; ENOUGH?
	BGTRU	10$			; IF GTRU THEN NO
	MOVL	#<F1.ACR!-		;
		F1.UIA!-
		F1.CCO!-
		F1.ESQ!-
		F1.LWC!-
		F1.RNE!-
		F1.RPR!-
		F1.RST!-
		F1.RUB!-
		F1.SYN!-
		F1.TRW!-
		<<F2.SCH+F2.GCH>@16>>,(R4); INSERT ANSWER
	MOVZBL	#SS$_NORMAL,R0		; SET SUCCESS
10$:	BRW	RSX$DLVRQIOAST		; COMPLETE THE I/O
;
; GET OR SET MULTIPLE CHARACTERISTICS FUNCTIONS
;
20$:	$QIOW_S	CHAN=LUT_CHAN(R8),-	; OBTAIN TERM. CHARACTERISTICS
		FUNC=#IO$_SENSEMODE,-
		P1=I_CHARACTER(R10),-
		P2=#12
	BLBS	R0,205$			; ABORT FUNCTION ON ERROR
204$:	BRW	57$			; QIO FAILED
205$:	CMPB	R7,#<SF.GMC>&^X0FF	; SET MULTIPLE CHARACTERISTICS?
	BEQL	22$			; IF EQL NO
	BRW	45$			; SET CHARACTERISTICS
21$:	BRW	90$			; POST FAILURE
;
; GET CHARACTERISTIC
;
22$:	IFNOWRT	R5,(R4),21$		; IF NO ACCESS THEN ERROR
	DECL	R5			;
	BGEQ	23$			; IF GEQ, WORK MUST BE DONE
	BRW	70$			; FINISHED
23$:	ADDL	R4,R5			; POINT TO END -1
25$:	CMPB	(R4),#TC.TTP		; TERMINAL TYPE?
	BNEQ	30$			; IF NEQ THEN SOME OTHER
	MOVB	#T.UNK0,1(R4)		; ASSUME UNKNOWN TYPE
	MOVAB	W^TYPETAB-17,R0		; TYPE TRANSLATION TABLE
	MOVZBL	I_CHARACTER+1(R10),R1	; GET TERMINAL TYPE CODE
27$:	ADDL2	#17,R0			; SKIP TO NEXT ENTRY
	TSTB	(R0)			; END OF TABLE?
	BEQL	35$			; IF EQL YES, UNKNOWN TYPE
	CMPB	(R0),R1			; CHECK IF CORRECT TYPE
	BNEQ	27$			; IF NEQ, INCORRECT TYPE
	MOVB	1(R0),1(R4)		; INSERT RSX TERMINAL TYPE
	BRB	35$			; AND CONTINUE
30$:	CMPB	(R4),#TC.TBF		; TYPEAHEAD BUFFER?
	BNEQ	32$			; BRANCH IF NOT
	CLRQ	-(SP)			; SET UP BUFFER SPACE
	MOVL	SP,R1			; POINT TO BUFFER
	$QIOW_S	CHAN=LUT_CHAN(R8),-	; OBTAIN NUMBER OF TYPAHD CHARS
		FUNC=#IO$_SENSEMODE!IO$M_TYPEAHDCNT,-
		P1=(R1)
	MOVZBL	(R1),R1			; GET #CHARS
	CLRQ	(SP)+			; CLEAN STACK
	BLBC	R0,204$			; SKIP IF ANY ERROR
	MOVB	R1,1(R4)		; RETURN # CHARS IN TYPAHD BUFFER
	BRB	35$			; AND CONTINUE
32$:	BSBW	PICKCHAR		; GET NEXT CHARACTERISTIC
	BLBS	R0,325$			; IF LBS THEN OK
	BRW	80$			; ILLEGAL REQUEST
325$:	CLRB	1(R4)			; ASSUME CHARACTERISTIC NOT SET
	BBS	#1,R0,33$		; BR IF EXTENDED CHARACTERISTIC
	BBC	R1,I_CHARACTER+4(R10),35$ ; BR IF NOT PRESENT
	BRB	34$			; INDICATE CHARACTERISTIC SET
33$:	BBC	R1,I_CHARACTER+8(R10),35$ ; BR IF NOT PRESENT
34$:	INCB	1(R4)			; SET CHARACTERISTIC PRESENT
35$:	ACBL	R5,#2,R4,25$		; LOOP UNTIL DONE
38$:	BRW	70$			; POST SUCCESS
40$:	BRW	90$			; POST FAILURE
;
; SET CHARACTERISTIC
;
45$:	IFNORD	R5,(R4),40$		; BR IF NOT READABLE
	MOVZWL	#IO$_SETMODE,I_SCRATCH+QIO$_FUNC(R10); ASSUME SETMODE
	MOVAB	I_CHARACTER(R10),I_SCRATCH+QIO$_P1(R10)
	MOVZBL	#12,I_SCRATCH+QIO$_P2(R10) ; SET LENGTH OF BUFFER
	CLRQ	I_SCRATCH+QIO$_P3(R10)	; CLEAR P3 AND P4
	DECL	R5			;
	BLSS	38$			;
	ADDL	R4,R5			; POINT TO END OF LIST -1
50$:	CMPB	(R4),#TC.TTP		; TERMINAL TYPE?
	BNEQ	52$			; IF NEQ NO
	MOVAB	W^TYPETAB-17,R0		; TYPE TRANSLATION TABLE
	MOVZBL	1(R4),R1		; GET DESIRED TERMINAL TYPE
51$:	ADDL2	#17,R0			; SKIP TO NEXT ENTRY
	TSTB	(R0)			; END OF TABLE?
	BEQL	58$			; IF EQL YES, FAILURE TO SET
	CMPB	1(R0),R1		; MATCH DESIRED TYPE?
	BNEQ	51$			; IF NEQ NO, TRY AGAIN
	MOVL	2(R0),I_CHARACTER(R10)	; SET 1ST CHARACTERISTICS WORD
	BICL2	6(R0),I_CHARACTER+4(R10) ; TURN OFF CERTAIN FEATURES
	BISL2	10(R0),I_CHARACTER+4(R10) ; TURN ON CERTAIN FEATURES
	MOVB	14(R0),I_CHARACTER+7(R10) ; SET PAGE LENGTH FIELD
	MOVZWL	15(R0),I_SCRATCH+QIO$_P4(R10) ; SET FILL INFORMATION
	BRB	55$			; SKIP TO NEXT CHARACTERISTIC
52$:	CMPB	(R4),#TC.TBF		; PURGE TYPE-AHEAD BUFFER?
	BNEQ	54$			; BRANCH IF NOT
	$QIOW_S	CHAN=LUT_CHAN(R8),-	; FLUSH TYPEAHEAD BUFFER
		FUNC=#IO$_READVBLK!IO$M_PURGE,-
		P1=I_CHARACTER+12(R10),-
		P2=#0
	BLBC	R0,57$			; ABORT FUNCTION ON FAILURE
	BRB	55$			; SKIP TO NEXT CHARACTERISTIC
54$:	BSBW	PICKCHAR		; GET THE NEXT CHARACTERISTIC
	BLBC	R0,80$			; BR IF ERROR
	CMPB	#1,1(R4)		; LEGAL VALUE?
	BLSSU	60$			;
	BBS	#1,R0,545$		; BR IF EXT. CHARACTERISTIC
	INSV	1(R4),R1,#1,I_CHARACTER+4(R10) ; INSERT NEW VALUE
	BRB	55$			; SKIP TO NEXT
545$:	INSV	1(R4),R1,#1,I_CHARACTER+8(R10) ; INSERT NEW VALUE
55$:	ACBL	R5,#2,R4,50$		; LOOP UNTIL DONE
	BRW	RSX$ISSUQIO		; ISSUE THE I/O
;
; QIOS FAILED. ASSUME IT WAS DUE TO INSUFFICIENT DYNAMIC MEMORY
;
57$:	MOVZWL	#SS$_INSFMEM,R0		; NOT ENUFF DYNAMIC MEMORY
	BRB	95$			;
;
; ATTEMPT TO SET TO UNKNOWN TERMINAL TYPE
;
58$:	MOVZBL	#SE.TER,R1		; ILLEGAL TERMINAL TYPE
	BRB	85$			;
;
; SET ERROR IN NEW VALUE
;
60$:	MOVZBL	#SE.BIN,R1		; ILLEGAL BINARY SPECIFICATION
	BRB	85$			;
;
; SET SUCCESS IN GET OR SET MULTIPLE
;
70$:	MOVZBL	#SS$_NORMAL,R0		; SET SUCCESS
	BRB	95$			;
;
; ERROR IN CHARACTERISTIC
;
80$:	MOVZBL	#SE.NIH,R1		; UNSUPPORTED CHARACTERISTIC
85$:	MOVW	#SS$_ABORT,R0		; SET PROPER STATUS
	BRB	95$			;
;
; BUFFER ACCESS VIOLATION
;
90$:	MOVZWL	#SS$_ACCVIO,R0		;
95$:	SUBL	R9,R4			; RETURN SECOND STATUS AS BUFFER SIZE
	ASHL	#16,R4,R4		; SHIFT TO UPPER
	BISL	R4,R0			; INSERT OVER OTHER STATUS
	BRW	RSX$DLVRQIOAST		; POST THE STATUS
	.DSABL	LSB
;
; SUBROUTINE TO PROCESS CHARACTERISTIC ARGUMENTS
;
PICKCHAR:
	CLRL	R0			; ASSUME ERROR
	MOVAB	W^SETGETTAB-1,R3	; ADDRESS TABLE OF CHARACTERISTICS
	BSBB	5$			; SCAN 1ST SET OF CHARACTERIST.
	BLBS	R0,15$			; IF LBS, FOUND IT
	MOVL	#2,R0			; ASSUME ERROR, SECOND SCAN
5$:	INCL	R3			;
	TSTB	(R3)			; DONE?
	BEQL	15$			; IF EQL THEN NOT FOUND
	CMPB	(R4),(R3)+		; MATCH?
	BNEQ	5$			; IF NEQ THEN NO
	MOVZBL	(R3),R1			; GET BIT VALUE OF CHARACTERISTIC
	INCL	R0			; SET SUCCESS
15$:	RSB				; RETURN

	.SBTTL	TTY_HANG FUNCTION
;
; HANG UP TERMINAL FUNCTION
;
TTY_HANG:				; HANG UP TERMINAL
	CLRL	I_SCRATCH+28(R10)	; SET NO PARAMETER
	MOVZWL	#IO$_SETMODE!IO$M_HANGUP,I_SCRATCH+12(R10); SET FUNCTION CODE
	BRW	RSX$ISSUQIO		; PERFORM FUNCTION

	.SBTTL	RSX$UNSOLCREATE - CREATE UNSOLICITED MAILBOX
;---
;
;	CREATE THE UNSOLICITED MAILBOX FOR UNSOLICITED CHARACTER
;	ASTS AND ASSOCIATE THE MAILBOX WITH THE TERMINAL CHANNEL.
;
; INPUTS:
;
;	R8 = LUT ADDRESS
;
; OUTPUTS:
;
;	R0 = STATUS CODE
;	R3 IS DESTROYED
;---
RSX$UNSOLCREATE::
	PUSHR	#^M<R2,R3,R4,R5>	; SAVE REGISTERS
	SUBL	#80,SP			; ALLOCATE 80 BYTE BUFFER
	MOVQ	#^A'RSX$MBX_',(SP)	; PUT PREFIX INTO BUFFER
	MOVAB	LUT_REALNAME(R8),R1	; ADDRESS OF TERMINAL DEVICE NAME
	MOVZBL	(R1)+,R0		; GET LENGTH OF NAME
	MOVQ	R0,-(SP)		; SAVE TERMINAL DEVICE NAME
	PUSHAB	8(SP)			; CREATE DESCRIPTOR OF MAILBOX NAME
	ADDL3	#8,R0,-(SP)
	MOVC	R0,(R1),24(SP)		; STORE MAILBOX NAME STRING
	MOVL	SP,R3			; ADDRESS OF DESCRIPTOR
	$CREMBX_S CHAN=I_UNSOLMBX(R10),- ; CREATE AND ASSIGN TO MAILBOX, AND
		LOGNAM=(R3)		; ASSOCIATE A LOGICAL NAME TO IT
	BLBC	R0,50$			; BRANCH IF ERROR
	$DASSGN_S CHAN=LUT_CHAN(R8)	; DEASSIGN EXISTING CHANNEL
	BLBC	R0,50$			; BRANCH IF ERROR
	$ASSIGN_S DEVNAM=8(R3),- 	; AND ASSIGN ANOTHER CHANNEL
		CHAN=LUT_CHAN(R8),-
		MBXNAM=(R3)		; WITH ASSOCIATED MAILBOX
50$:	ADDL	#80+16,SP		; DEALLOCATE BUFFER, DESCRIPTORS
	POPR	#^M<R2,R3,R4,R5>	; RESTORE REGISTERS
	RSB				; REPORT ERROR IN R0

	.SBTTL RSX$UNSOLASTEN - ENABLE UNSOLICITED CHARACTER AST
;++
; RSX$UNSOLASTEN - ENABLE UNSOLICITED CHARACTER AST
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED DURING THE PROCESSING OF AN IO.ATA I/O FUNCTION
; AND AFTER THE AST EXIT OF THE ASSOCIATED AST.
;
; THE ACTION IS TO ENABLE THE AST FUNCTION.
;
; INPUTS:
;
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	R0 = STATUS OF THE I/O
;	ALL OTHER REGISTERS ARE PRESERVED.
;--
RSX$UNSOLASTEN::
	PUSHR	#^M<R1,R2,R8>		; SAVE REGISTERS
	MOVL	I_UNSOLAST(R10),R2	; ADDRESS THE UNSOLICITED ACB
	MOVL	ACB_LUT(R2),R8		; ADDRESS LUT ENTRY
	$QIOW_S	CHAN=LUT_CHAN(R8),-	; ENABLE USE OF UNSOL. MAILBOX
		FUNC=#IO$_WRITEVBLK!IO$M_ENABLMBX,-
		IOSB=I_CHARACTER(R10)
	BLBC	R0,80$			; BRANCH IF ERROR
	MOVL	I_CHARACTER(R10),R0	; GET I/O STATUS
	BLBC	R0,80$			; BRANCH IF ERROR
	$QIOW_S	CHAN=I_UNSOLMBX(R10),-	; SET ATTENTION AST ON MAILBOX
		FUNC=#IO$_SETMODE!IO$M_WRTATTN,-
		IOSB=I_CHARACTER(R10),-
		P1=W^RSX$UNSOLAST,-	; ADDRESS OF AST ROUTINE
		P2=R2			; ASTPRM = ADDRESS OF ACB
	BLBC	R0,70$			; BRANCH IF ERROR
	MOVL	I_CHARACTER(R10),R0	; GET I/O STATUS
	BLBS	R0,90$			; BRANCH ON SUCCESS
70$:	$QIOW_S	CHAN=LUT_CHAN(R8),-	; DISABLE MAILBOX ON ERROR
		FUNC=#IO$_READVBLK!IO$M_DSABLMBX
80$:	BBCC	#SV_UNSOLAST,I_STATE(R10),90$ ; SET NOT ENABLED
90$:	POPR	#^M<R1,R2,R8>		; RESTORE REGISTERS
	RSB				; RETURN

	.SBTTL RSX$UNSOLDSABL - DISABLE UNSOLICITED DATA AST
;++
; RSX$UNSOLDSABL - DISABLE UNSOLICITED DATA AST
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED BY THE IO.DET I/O PROCESSING LOGIC.
;
; THE ACTION IS TO DISABLE THE UNSOLICITED AST FUNCTION.
;
; INPUTS:
;
;	R9 = AST CONTROL BLOCK ADDRESS
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	R0 = STATUS OF THE QIO OPERATION
;	ALL OTHER REGISTERS ARE PRESERVED.
;--
RSX$UNSOLDSABL::
	PUSHL	R8			; SAVE R8
	MOVL	ACB_LUT(R9),R8		; GET LUT ADDRESS
	$QIOW_S	CHAN=LUT_CHAN(R8),-	; DISABLE UNSOLICITED MAILBOX
		FUNC=#IO$_READVBLK!IO$M_DSABLMBX
	$QIOW_S	CHAN=I_UNSOLMBX(R10),-	; CLEAN OUT PENDING WRTATTN REQUEST
		FUNC=#IO$_SETMODE!IO$M_WRTATTN	; P1=0 MEANS CLEAN OUT ASTQ
	MOVL	(SP)+,R8		; RESTORE R8
	RSB				; RETURN
	.PAGE
	.SBTTL	RSX$UNSOLDELETE - DELETE UNSOLICITED AST
;++
; RSX$UNSOLDELETE - DELETE UNSOLICITED AST MECHANISM FOR TERMINAL
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE WILL DISASSOCIATE A TERMINAL FROM AN UNSOLICITED AST
; MAILBOX BY REASSIGNING THE CHANNEL WITHOUT THE MAILBOX OPTION.
;
; INPUTS:
;
;	R9 = AST CONTROL BLOCK ADDRESS
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;
; OUTPUTS:
;
;	R0 IS DESTROYED
;	ALL OTHER REGISTERS ARE PRESERVED
;--
RSX$UNSOLDELETE::
	PUSHR	#^M<R1,R8>		; SAVE REGISTERS
	MOVL	ACB_LUT(R9),R8		; GET LUT ADDRESS
RSX$UNSOL2::				; ALTERNATE ENTRY
	MOVAB	LUT_REALNAME(R8),R1	; POINT TO VMS TERMINAL NAME
	MOVZBL	(R1)+,R0		; CREATE STRING DESCRIPTOR
	MOVQ	R0,I_CHARACTER(R10)	; STORE DESCRIPTOR
	$DASSGN_S CHAN=LUT_CHAN(R8)	; DEASSIGN TERMINAL
	$ASSIGN_S DEVNAM=I_CHARACTER(R10),- ; REASSIGN WITHOUT MAILBOX
		  CHAN=LUT_CHAN(R8)
	INSQUE	(R9),I_ASTPOOL(R10)	; DEALLOCATE AST CONTROL BLOCK
	$DASSGN_S CHAN=I_UNSOLMBX(R10)	; DEASSIGN AND DELETE MAILBOX
	POPR	#^M<R1,R8>		; RESTORE REGISTERS
	RSB				; DONE

	.SBTTL RSX$CTRLCASTEN - ENABLE CONTROL C AST
;++
; RSX$CTRLCASTEN - ENABLE CONTROL C AST
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED DURING THE PROCESSING OF AN IO.ATA I/O FUNCTION
; AND AFTER THE AST EXIT OF THE ASSOCIATED AST.
;
; THE ACTION IS TO ENABLE THE AST FUNCTION.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE AST CONTROL BLOCK
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	R0 = STATUS OF THE I/O
;	R8 = ADDRESS OF LUT ENTRY
;	R10,R11 ARE PRESERVED.
;--
RSX$CTRLCASTEN::
	BBS	#ACBV_OLD_ACB,ACB_FLAGS(R2),15$ ; BR IF TERMINAL DETACHED
	MOVL	ACB_LUT(R2),R8		; GET LUT ADDRESS
	$QIOW_S	#8,LUT_CHAN(R8),#IO$_SETMODE!IO$M_CTRLCAST,I_SCRATCH+8(R10),,,-
		W^RSX$CTRLCAST,LUT_CTRLC(R8)
	BLBC	R0,10$			; BR IF NOT SUCCESS
	MOVL	I_SCRATCH+8(R10),R0	; GET I/O STATUS
	BLBS	R0,20$			; BRANCH ON SUCCESS
10$:	BICB	#1@LUTV_CTRLC,LUT_FLAGS(R8); SET NOT ENABLED
15$:	INSQUE	(R2),I_ASTPOOL(R10)	; RETURN ACB FOR LATER USE
20$:	RSB				; RETURN

	.SBTTL RSX$CTRLCDSABL - DISABLE CONTROL C AST
;++
; RSX$CTRLCDSABL - DISABLE CONTROL C AST
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED BY THE IO.DET I/O PROCESSING, THE ALUN DEASSIGN
; LOGIC.
;
; THE ACTION IS TO DISABLE THE AST FUNCTION.
;
; INPUTS:
;
;	R8 = ADDRESS OF THE LUT ENTRY FOR THE CHANNEL
;	R9 = AST CONTROL BLOCK ADDRESS
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	R0 = STATUS OF THE QIO OPERATION
;	R8,R10,R11 ARE PRESERVED.
;--
RSX$CTRLCDSABL::			; DISABLE CONTROL C AST
	$QIOW_S	#9,LUT_CHAN(R8),#IO$_SETMODE!IO$M_CTRLCAST
	BICB	#1@LUTV_CTRLC,LUT_FLAGS(R8) ; DISABLE CONTROL-C AST
	INSQUE	(R9),I_ASTPOOL(R10)	; RETURN ACB FOR LATER USE
	RSB				; RETURN

	.END

