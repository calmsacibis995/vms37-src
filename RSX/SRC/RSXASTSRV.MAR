	.TITLE RSXASTSRV - AST SERVICE ROUTINES FOR THE RSX11M/AME
	.IDENT	'V03-002'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;++
; FACILITY:
;
;	VAX/VMS RSX11M/AME.
;
; ABSTRACT:
;
;	VAX/VMS RSX11M/AME AST SERVICE ROUTINES AND AST SUPPORT.
;
; AUTHOR:
;
;	R.HEINEN 5-NOV-76
;
; PREVIOUSLY MODIFIED BY:
;
;	Tim Halvorsen
;	Michael S. Harvey
;
; MODIFIED BY:
;
;	V001	MSH025		Michael S. Harvey	16-Mar-82
;		Use correct AST control block in case user changed
;		ASTs by issuing a DET/ATT sequence while an
;		unsolicited AST was still waiting to be finished.
;
;	V002	MSH026		Michael S. Harvey	22-Mar-82
;		Eliminate dependencies on VMS Executive symbols.
;
;--
;
; EXTERNAL SYMBOLS
;
	$RSXDEF			; DEFINE RSX SYMBOLS
	$DEVDEF			; DEFINE DEVICE CHARACTERISTICS
	$ACCDEF			; TERMINATION MAILBOX DEFINITIONS
	DRERR$			; RSX DIRECTIVE ERROR CODES
 

	.PSECT	RSXCODE,NOWRT,SHR,PIC
	.SBTTL VAX/VMS RSX11M/AME UTILITY AST SERVICE ROUITNES
;++
; RSX$POWERAST - POWERFAIL AST SERVICE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS THE AST SERVICE FOR POWERFAIL AST'S.
; IT IS ENTERED AS A RESULT OF THE IMAGE DOING A SPRA$ DIRECTIVE AND THE
; POWER RECOVERY OCCURING.
; THE AST IS DELIVERED TO THE IMAGE IF THE IMAGE IS STILL ENABLED TO HEAR IT.
; THE IMAGE IS ENABLED IF SV_PWRAST IS SET IN THE CURRENT IMAGE STATUS VECTOR.
;
; INPUTS:
;
;	AP = ADDRESS OF THE AST ARGUMENT LIST ( IGNORED )
;
; OUTPUTS:
;
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;
;	THE ADDRESS OF THE POWER FAIL AST CONTEXT BLOCK IS PLACED
;	ON TOP OF THE AP AST ARGUMNET LIST PARAMETER POINTER.
;--
RSX$POWERAST::				; POWERFAIL AST SERIVCE
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVL	G^SYS$GL_CMCNTX,R10	; ADDRESS IMPURE DATA AREA
	BBC	#SV_PWRAST,I_STATE(R10),90$	; BRANCH IF NOT ENABLED
	MOVL	I_PWRAST(R10),AST_PARAM(AP)	; ADDRESS CONTEXT BLOCK
	BRW	POSTAST			; POST THE AST
90$:	RET				; IGNORE AST

;++
; RSX$RCVAST - DATA IN RCVD$ MAILBOX AST SERVICE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS THE AST SERVICE FOR THE RCVA$ DIRECTIVE.
; IT IS ENTERED WHEN AN AST OCCURS BECAUSE A MESSAGE HAS BEEN PLACED IN
; THE IMAGE'S RCVD$ MAILBOX.
; THE AST IS DELIVERED TO THE IMAGE IF IT IS STILL ENABLED TO HEAR IT.
; THE IMAGE IS ENABLED IF SV_RCVAST IS SET IN THE CURRENT IMAGE STATE VECTOR.
;
; INPUTS:
;
;	AP = ADDRESS OF THE AST ARGUMENT LIST 
;
; OUTPUTS:
;
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;--
RSX$RCVAST::				;
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVL	G^SYS$GL_CMCNTX,R10	; ADDRESS IMPURE DATA AREA
	BBS	#SV_RCVAST,I_STATE(R10),POSTAST ; BR IF NOT ENABLED
	RET

;++
; RSX$MARKAST - AST SERVICE ROUTINE FOR MARK TIME DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS THE AST SERVICE FOR MARK TIME DIRECTIVES THAT
; REQUESTED AN AST WHEN THE TIMER EXPIRED.
; AN AST IS DELIVERED TO THE IMAGE.
;
; INPUTS:
;
;	AST STACK WITH AST_PARAM = THE AST CONTEXT BLOCK
;
; OUTPUTS:
;
;	SEE BELOW.
;--
RSX$MARKAST::				; MARK TIME AST SERVICE
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVL	G^SYS$GL_CMCNTX,R10	; ADDRESS IMPURE DATA AREA
	REMQUE	@AST_PARAM(AP),R2	; REMOVE FROM OUTSTANDING REQUEST QUEUE
	TSTW	ACB_UPC(R2)		; USER AST REQUESTED?
	BNEQ	POSTAST			; IF SO, DELIVER IT
	RET				; ELSE, DISMISS WITH EVENT FLAG SET

	.SBTTL POST AST TO IMAGE
;++
; POSTAST - POST AN AST TO THE CURRENT IMAGE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED TO POST AN AST TO THE CURRENT IMAGE.
;
; THIS ROUTINE PUTS THE AST CONTEXT BLOCK ON AN AST QUEUE (I_ASTQUEUE)
; AND THEN CHECKS THE STATE OF THE IMAGE WHEN THE AST OCCURED.
;
; IF THE AST OCCURED IN CM ---
;
;	IF THE IMAGE IS NOT AT AST LEVEL AND AST'S ARE ENABLED,
;	THE AST SHOULD BE DELIVERED HERE AND NOW.
;	THIS IS DONE BY OVERWRITING THE AST PC/PSL AND R6
;	AND DOING A RETURN. THE AST IS THUS DELIVERED.
;
; IF THE AST OCCURED IN NATIVE MODE ---
;
;	THE AST SHOULD BE QUEUED UNTIL THE NEXT IMAGE RESTORE IS
;	DONE BY RSX$RESTORE.
;	SPECIAL ATTENTION IS GIVEN TO THE FOLLOWING POSSIBLE AME STATES.
;
;	A. THE AME IS IN RSX$RESTORE.
;		THE PC IS RESET TO CAUSE THE RESTORE TO BE DONE AGAIN.
;		THIS TEST IS BY INTERLOCK BIT AND PC VALUE.
;
;	B. THE AME IS IN A WAIT STATE BECAUSE OF A WTSE$ OR WTLO$ DIRECTIVE.
;		THE WAIT CONTEXT IS SAVED AND THE WAIT IS FLUSHED BY CLEARING
;		THE WAIT FOR CONTEXT IN THE IMPURE DATA BASE. THIS OPERATION
;		NEEDS TO BE INTERLOCKED AND A BIT IS USED TO SIGNAL RSX$WAIT
;		TO AVOID THE WAIT IF THIS OCCURS JUST BEFORE THE SETTING
;		OF THE INTERLOCK BIT SV_WAIT.
;
;	C. THE AME IS HIBERNATING.
;		THE HIBERNATE IS ABORTED VIA $WAKE AND A FLAG IS SET TO
;		INDICATE THAT A HIBERNATE WAS IN PROGRESS.  THE HIBERNATE
;		WILL BE RESTARTED WHEN THE LAST AST IS DELIVERED.
;
; INPUTS:
;
;	R10 = ADDRESS OF THE IMAGE IMPURE AREA
;	AST_PARAM(AP) = ADDRESS OF THE AST CONTEXT BLOCK AS FOLLOWS:
;
;		2 LONG WORDS OF SPACE FOR AST QUEUE
;		1 WORD OF OPTIONAL AST DATA TO BE PLACED ON THE
;			IMAGE STACK AT ACTUAL DELIVERY
;			-1 SIGNALS NO DATA
;		1 WORD OF IMAGE AST PC
;		1 WORD OF TYPE CODE FOR AST POST PROCESSING
;
; IMPLICIT INPUTS:
;
; IT IS ASSUMED THAT THE CURRENT STACK FRAME IS THAT OF AN AST.
;
; OUTPUTS:
;
; 	SEE CODE FOR TRANSFER TARGET.
;
;--
POSTAST:				; POST AST
;
; QUEUE AST ON LIST
;
	MOVL	AST_PARAM(AP),R2	; ADDRESS AST CONTEXT BLOCK
	MOVAB	ACB_UPRM(R2),R1		; SET ADDRESS OF LOGGING DATA
	BSBW	RSX$LOG			; LOG EVENT FOR DEBUGGING PURPOSES
	BBSS	#ACBV_INPROG,ACB_FLAGS(R2),50$; SET AST IN PROGRESS
	INSQUE	(R2),@I_ASTQUEUE+4(R10)	; QUEUE AST AT TAIL
;
; IF THIS AST IS THE FIRST IN THE LIST THEN CHECK TO SEE IF IT CAN BE DELIVERED
;
	BNEQ	50$			; IF NEQ THEN NOT FIRST IN LIST
;
; TEST TO SEE IF AST POSSIBLE NOW
;
	BITL	#<1@SV_ASTLVL>!<1@SV_NOAST>,I_STATE(R10); AST LEVEL OR IN PROGRESS?
	BNEQ	50$			; IF NEQ THEN YES - NO AST'S
;
; CHECK WHETHER THE AST OCCURRED IN NATIVE OR COMPATIBILITY MODE
;
	BBS	#PSL_CM,AST_PSL(AP),20$	; BR IF IN CM
;
; AST OCCURED IN NATIVE MODE
;
; SET FLAGS TO INDICATE THAT ANY WAITS OR HIBERNATES SHOULD BE
; SKIPPED IN ORDER TO DELIVER THE AST.
;
	BISW	#<1@SV_PENDWAIT>!<1@SV_PENDHIBER>,I_STATE(R10)
;
; IF THE AME WAS HIBERNATING, ABORT THE HIBERNATE WITH $WAKE AND SET
; A FLAG THAT THE HIBERNATE SHOULD BE RESTARTED WHEN THE LAST
; AST IS DELIVERED.
;
	BBC	#SV_HIBER,I_STATE(R10),5$ ; BRANCH IF NOT HIBERNATING
	BISW	#1@SV_RESTARTHIBER,I_STATE(R10) ; MARK HIBER SHOULD BE RESTARTED
	$WAKE_S				; ABORT THE HIBERNATE
	RET				; EXIT AST
;
; IF THE AME WAS WAITING FOR EVENT FLAG, ABORT THE WAIT BY SETTING AN ILLEGAL
; EVENT FLAG NUMBER IN THE WAIT LIST.  THE ORIGINAL WAIT PARAMETERS
; ARE STORED IN WAITSAVE TO INDICATE THAT THE WAIT SHOULD BE RESTARTED
; WHEN THE LAST AST IS DELIVERED.
;
5$:	BBC	#SV_WAIT,I_STATE(R10),10$; BR IF NOT IN WAIT STATE
	MOVQ	I_WAIT(R10),I_WAITSAVE(R10); SAVE CURRENT CONTEXT
	MOVZBL	#128,I_WAIT(R10)	; SET AN ILLEGAL EVENT FLAG NUMBER
	RET				; EXIT AST
;
; IF THE AME WAS IN THE RESTORE ROUTINE, BACKUP TO THE START OF THE RESTORE
;
10$:	BBS	#SV_RESTORE,I_STATE(R10),15$; BR IF IN NORMAL RESTORE
	MOVAB	W^RSX$REI,R1		; AT THE NORMAL REI?
	CMPL	AST_PC(AP),R1		; 
	BNEQ	50$			; IF NEQ THEN NOT IN RANGE
15$:	MOVAB	W^RSX$RESTORE_CON,AST_PC(AP); RESET PC FOR RESTORE
	BRB	40$			; EXIT THE AST
;
; AST OCCURED IN CM - LEAVE QUEUED IF AST LEVEL ALREADY OR IF AST'S DISABLED
;
20$:	MOVQ	AST_PC(AP),R7		; GET PC AND PSL
	MOVL	FP_REGISTERS+16(FP),R6	; GET IMAGE STACK POINTER
	BSBB	RSX$RETURNAST		; IF POSSIBLE, GET AST
	MOVL	R6,FP_REGISTERS+16(FP)	; RESET R6 FOR RETURN
;
; R7,R8 HAVE BEEN UPDATED IF AN AST IS TO BE DONE. OTHERWISE THEY ARE
; UNCHANGED.
;
	MOVQ	R7,AST_PC(AP)		; SET POSSIBLE NEW PC/PSL
40$:	BBCC	#PSL_FPD,AST_PSL(AP),50$; CLEAR FIRST PART DONE
;
; RETURN FROM AST
;
50$:	RET				;

	.SBTTL RSX$RETURNAST - RETURN NEXT AST CONTEXT
;++
; RSX$RETURNAST - RETURN NEXT AST CONTEXT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS CALLED TO RETURN THE CONTEXT OF THE NEXT AST, IF ANY,
; TO BE GIVEN TO THE IMAGE. IT IS CALLED BY "POSTAST" ABOVE AND
; DURING THE DIRECTIVE PROCESSING RESTORE LOGIC.
; IF AN AST IS TO BE GIVEN, THE PROPER STATE IS SET UP.
; 
; INPUTS:
;
;	R6 = CURRENT IMAGE STACK POINTER
;	R7 = CURRENT IMAGE PC
;	R8 = CURRENT PSL
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	R0 = STATUS OF OPERATION
;	R6 = NEW STACK POINTER
;	R7 = NEW PC
;	R8 = NEW PSL
;	R10,R11 ARE PRESERVED.
;--
RSX$RETURNAST::				; GET NEXT AST CONTEXT
;
; IF THE QUEUE IS NON-EMPTY, SET ASTLVL BEFORE DEQUEUING THE AST SO THAT
; AST DELIVERY DOESN'T DELIVER ANOTHER AST IMMEDIATELY.
;
	MOVAB	I_ASTQUEUE(R10),R0	; ADDRESS OF QUEUE HEADER
	CMPL	I_ASTQUEUE(R10),R0	; IS THE QUEUE EMPTY?
	BEQL	50$			; BRANCH IF EMPTY
	BBS	#SV_NOAST,I_STATE(R10),50$	; EXIT IF ASTS DISABLED
;
; PREVENT AST DELIVERY FROM DELIVERING ANY NEW ASTS
;
	BBSS	#SV_ASTLVL,I_STATE(R10),50$	; SET AST LEVEL
;
; DE-QUEUE THE NEXT AST
;
	REMQUE	@I_ASTQUEUE(R10),R2	; GET THE NEXT AST CONTROL BLOCK
	BVS	40$			; BRANCH IF DISAPPEARED
;
; SET UP STACK FOR AST
;
	IFNOWRT	#14,-14(R6),60$		; BR IF STACK NOT WRITABLE
	BBCC	#ACBV_INPROG,ACB_FLAGS(R2),20$; SET NO LONGER IN PROGRESS
20$:	CLRQ	-(R6)			; SET UP WAIT FOR FAKE WORDS
	MOVW	R8,-(R6)		; PUT AST PS ON STACK
	MOVW	R7,-(R6)		; PUT AST PC ON STACK
	MOVW	H.DSW(R11),-(R6)	; PUT AST DSW ON STACK
	CMPB	#ACBC_FLOATAST,ACB_FLAGS+1(R2); FLOATING AST?
	BNEQ	23$			; IF NEQ THEN NO
	IFNOWRT	#4,-4(R6),60$		; BR IF BAD STACK
	MOVW	I_FLOATERR(R10),-(R6)	; SAVE ERROR SUMMRY
	MOVW	I_FLOATADR(R10),-(R6)	; SAVE CURRENT PC AS ADDRESS
	BRB	25$			; CONTINUE
23$:	CMPW	ACB_UPRM(R2),#-1	; AND AST DATA?
	BEQL	25$			; IF EQL THEN NO
	IFNOWRT	#2,-2(R6),60$		; WRITABLE STACK?
	MOVW	ACB_UPRM(R2),-(R6)	; PUT IT ON THE STACK
25$:	MOVL	#C_CANONPS,R8		; SET UP NEW PSL
	MOVZWL	ACB_UPC(R2),R7		; SET UP NEW PC
	MOVL	R6,R1			; SET ADDRESS OF LOGGING DATA
	BSBW	RSX$LOG			; LOG EVENT FOR DEBUGGING PURPOSES
	MOVZBL	#SS$_NORMAL,R0		; SET NORMAL STATUS
	MOVL	R2,I_CURAST(R10)	; SAVE CURRENT AST CONTEXT
	RSB				; RETURN
;
; SIGNAL NO AST FOUND
;
40$:	BBCC	#SV_ASTLVL,I_STATE(R10),50$	; NO AST IN PROGRESS
50$:	CLRL	R0			; SIGNAL NO AST FOUND
	RSB
;
; STACK NOT WRITABLE
;
60$:	$IMAGEABORT	#RSX$_BADSTACK

	.SBTTL GETNEXTAST - GET THE NEXT AST CONTROL BLOCK
;++
; GETNEXTAST - GET NEXT AVAILABLE AST CONTROL BLOCK
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED BY RSX$RETURNAST AND RSX$ASTX TO DEQUEUE THE
; NEXT AST CONTROL BLOCK OR RETURN FAILURE. 
;
; INPUTS:
;
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	R0 = STATUS OF THE OPERATION
;	R2 = THE ADDRESS OF THE AST CONTROL BLOCK IF ANY
;	R10,R11 ARE PRESERVED.
;--
GETNEXTAST:
	CLRL	R0			; SET NO AST FOUND STATUS
	BITL	#<1@SV_ASTLVL>!<1@SV_NOAST>,I_STATE(R10); AST'S ALLOWED?
	BNEQ	20$			; IF NEQ THEN NO
5$:	REMQUE	@I_ASTQUEUE(R10),R2	; GET THE NEXT AST CONTROL BLOCK
	BVS	20$			; IF V-SET THEN NONE
	INCL	R0			; SET SUCCESS
20$:	RSB				; RETURN

	.SBTTL	RSX-11M ASTX$ DIRECTIVE
;++
; RSX$ASTX - RSX-11M AST EXIT DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS A RSX DIRECTIVE HANDLER WHICH IMPLEMENTS AN RSX-11M
; "ASTX$" DIRECTIVE.
;
; THE ACTION IS TO VERIFY THAT THE DIRECTIVE IS LEGAL AND THEN
; DISMANTLE THE RSX-11M AST STACK (R6).
;
; RETURN TO THE DIRECTIVE RESTORE LOGIC WILL DELIVER ANY PENDING AST'S.
;
; CALLING SEQUENCE:
;
;	CALLED VIA CASE FROM "RSX$EXCEPTION".
;
; INPUT PARAMETERS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = CM IMAGE STACK ADDRESS
;	R10 = ADDRESS OF CM IMAGE DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
; IMPLICIT INPUTS:
;
;	THE DPB IS ALREADY VALIDATED FOR READ ACCESS.
;	THE DPB SIZE AND TYPE ARE CORRECT.
;
; OUTPUT PARAMETERS:
;
;	R10,R11 ARE PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	THE PROPER DIRECTIVE STATUS IS PLACED IN THE IMAGE DSW
;	ALONG WITH THE PROPER SETTING OF THE C-BIT.
;
; COMPLETION CODES:
;
;	IS.SUC	SUCCESSFUL
;	IE.AST	NOT ISSUED FROM AST SERIVCE
;--
RSX$ASTX::				; AST SERVICE EXIT DIRECTIVE
;
; THIS BIT IS SET BY THE AST DELIVERY LOGIC ABOVE.
;
	BBSC	#SV_ASTLVL,I_STATE(R10),10$; AST LEVEL?
;
; NOT AT AST LEVEL
;
	$DSW	#IE.AST			; SET STATUS AND RETURN
;
; IF PRESENT AST IS A PERMANENT AST THEN RE-ENABLE IT'S FUNCTION
;
10$:	MOVL	I_CURAST(R10),R2	; GET ADDRESS OF THE CURRENT AST CONTEXT
	MOVAB	ACB_UPRM(R2),R1		; SET ADDRESS OF LOGGING DATA
	BSBW	RSX$LOG			; LOG EVENT FOR DEBUGGING PURPOSES
	BBC	#ACBV_PERM,ACB_FLAGS(R2),40$; BR IF NOT PERMANENT AST
;
; IF UNSOLICITED CHARACTER AST, THEN CHECK IF ANY MORE CHARACTERS
; AVAILABLE AND REQUEUE ANOTHER AST IF SO.
;
	CMPB	ACB_FLAGS+1(R2),#ACBC_UNSOLAST ; UNSOLICITED AST?
	BNEQ	15$			; BRANCH IF NOT
	MOVL	ACB_LUT(R2),R8		; GET LUT ADDRESS FOR GET_CHAR
	BBC	#SV_UNSOLAST,I_STATE(R10),12$ ; BR IF UNSOL ASTS DISABLED
	BBC	#ACBV_OLD_ACB,ACB_FLAGS(R2),11$ ; BR IF USING SAME ACB
;
; IF USER DETACHED TERMINAL WHILE THIS ACB WAS IN PROGRESS, THEN THIS
; ACB IS NO LONGER REALLY PERMANENT AND MUST BE ELIMINATED. IF USER
; REATTACHED THIS TERMINAL, THIS IS THE ONLY ACTION NECESSARY. IF THE
; USER ATTACHED ANOTHER TERMINAL FOR UNSOLICITED ASTS, THEN THE TERMINAL
; ASSOCIATED WITH THIS ACB MUST BE DISASSOCIATED FROM ITS MAILBOX.
;
	BBS	#LUTV_UNSOL,LUT_FLAGS(R8),105$ ; BR IF TERMINAL REATTACHED
	PUSHL	R9			; SAVE R9
	MOVL	R2,R9			; COPY ACB ADDRESS
	PUSHAB	104$			; CREATE RETURN CONTEXT ON STACK
	PUSHR	#^M<R1,R8>
	BRW	RSX$UNSOL2		; DISASSOCIATE MAILBOX FOR TT
104$:	MOVL	(SP)+,R9		; RESTORE R9
	BRB	45$			; THIS AST IS GONE NOW
105$:	INSQUE	(R2),I_ASTPOOL(R10)	; RETURN ACB FOR LATER USE
	BRB	45$			; AST GONE NOW

11$:	BSBW	RSX$GET_CHAR		; GET NEXT CHARACTER (IF ANY)
	BLBC	R0,15$			; BRANCH IF NONE
	INSQUE	(R2),@I_ASTQUEUE+4(R10)	; QUEUE AST AT TAIL
	BRB	45$			; BUT DO NOT RE-ENABLE MAILBOX AST'S

12$:	PUSHL	R9			; SAVE R9
	MOVL	R2,R9			; COPY ACB ADDRESS
	BSBW	RSX$UNSOLDELETE		; DISASSOCIATE TT FROM MAILBOX
	MOVL	(SP)+,R9		; RESTORE R9
	BRB	45$			; DONE, ACB KILLED
;
; PERMANENT AST - SEPARATE ON TYPE
;
15$:	PUSHAB	B^45$			; SET ADDRESS TO CONTINUE AT
	CASE	ACB_FLAGS+1(R2),TYPE=B,<-;
		RSX$POWEREN,-		; POWER AST
		RSX$RCVASTEN,-		; RECEIVE AST
		RSX$CTRLCASTEN,-	; CONTROL/C AST
		20$,-			; FLOATING POINT AST
		RSX$UNSOLASTEN,-	; UNSOLICITED AST
		>
20$:	RSB				;
;
; NON PERMANENT AST
;
40$:	INSQUE	(R2),I_ASTPOOL(R10)	; DEALLOCATE THE CONTEXT BLOCK
;
; TEST ACCESS TO STACK
;
45$:	IFNORD	#14,(R6),70$		; IF STACK CANNOT BE READ THEN ERROR
;
; REMOVE DSW FROM STACK
;
	MOVW	(R6)+,H.DSW(R11)	; TAKE DSW OFF
	MOVZWL	(R6)+,I_PC(R10)		; SET PC TO RETURN TO ON EXIT
	BICW3	#^X0FFE0,(R6)+,I_PS(R10); GET NEW IMAGE PSW
	ADDL	#8,R6			; REMOVE REMAINDER OF AST FROM STACK
;
; ANOTHER AST TO DELIVER?
;
50$:	MOVAB	I_ASTQUEUE(R10),R1	; ADDRESS OF QUEUE HEADER
	CMPL	I_ASTQUEUE(R10),R1	; IS AST QUEUE EMPTY?
	BNEQ	55$			; BRANCH IF NOT
;
; PRESENT AST IS THE LAST.
;
; RESTORE THE IMAGE TO ITS PRE-AST STATE.
;
	BICW2	#<1@SV_PENDHIBER>,I_STATE(R10) ; ALLOW HIBERS (SUSPEND)
	MOVQ	I_WAITSAVE(R10),R1	; WAITFOR STATE INTERRUPTED?
	BEQL	52$			; IF EQL THEN NO WAIT NEEDED
	CLRQ	I_WAITSAVE(R10)		; MARK WAITFOR RESTARTED
	BRW	RSX$WAIT		; RESTART WAITFOR STATE
;
; IF THE AST INTERRUPTED A HIBERNATE IN PROGRESS, RESTART THE HIBERNATE
;
52$:	BBCC	#SV_RESTARTHIBER,I_STATE(R10),60$ ; BRANCH IF NOT INTERRUPTED
					; MARK HIBERNATE RESTARTED (CLEAR BIT)
	BRW	RSX$SPND		; RESTART THE HIBERNATE
;
; AST FOUND TO DELIVER - REQUEUE IT AT FRONT OF AST LIST
;
55$:	BBSS	#SV_PENDWAIT,I_STATE(R10),60$; SET AST IN QUEUE
;
; COMMON AST EXIT
;
60$:	RSB				; AND RETURN
;
; BAD STACK
;
70$:	$IMAGEABORT	#RSX$_BADSTACK

	.SBTTL	RSX$SETUPAST - ALLOCATE AN AST CONTROL BLOCK
;++
; RSX$SETUPAST - ALLOCATE AND SET UP AST CONTEXT BLOCK
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE ALLOCATES AN AST CONTEXT BLOCK.
;
; THIS ROUTINE IS NEVER CALLED AT AST LEVEL.
;
;
; INPUT:
;
;	R10 = ADDRESS OF THE IMAGE DATA BASE
;	R11 = ADDRESS OF THE IMAGE HEADER
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE BLOCK ALLOCATED
;	R10,R11 ARE PRESERVED.
;--
RSX$SETUPAST::				;
	REMQUE	@I_ASTPOOL(R10),R2	; GET A BLOCK
	BVC	30$			; IF VSET THEN NONE
	MOVZBL	#QIO_SIZE,R1		; SET SIZE TO ALLOCATE
	BSBW	RSX$ALLOCATE		; ALLOCATE THE BLOCK
	MOVL	R0,R2			; COPY ADDRESS OF ALLOCATED BLOCK
30$:	RSB				; RETURN

	.SBTTL	I/O DONE AST SERVICE
;++
; RSX$IODONEAST - I/O DONE AST SERVICE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED ON I/O DONE FOR ALL RSX-11M I/O OPERATIONS.
; THE ACTION IS TO POST THE CORRECT RSX-11M STATUS IN THE IOSB OF THE
; QIO REQUEST. THEN IF NECESSARY, THE ASSOCIATED IMAGE AST IS POSTED.
;
; INPUTS:
;
;	THE ADDRESS OF THE AST CONTEXT BLOCK IS AT AST_PARAM(AP).
;
; OUTPUTS:
;
;	NONE.
;
;--
RSX$IODONEAST::				; I/O DONE AST SERVICE
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVL	G^SYS$GL_CMCNTX,R10	; ADDRESS IMPURE DATA AREA
	CLRL	R11			; ADDRESS IMAGE
;
; GET THE AST CONTEXT BLOCK
;
	MOVL	AST_PARAM(AP),R2	; ADDRESS THE CONTEXT BLOCK
	MOVAB	ACB_UPRM(R2),R1		; SET ADDRESS OF LOGGING DATA
	BSBW	RSX$LOG			; LOG EVENT FOR DEBUGGING PURPOSES
;
; SET UP HIS IOSB
;
	MOVZWL	ACB_UPRM(R2),R8		; GET ADDRESS OF IOSB
	BEQL	10$			; IF EQL THEN NONE
	IFNOWRT	#4,(R8),10$		; IF NO WRITE THEN GO ON ALSO
	CLRL	(R8)			; ZERO IT
;
; IF THIS IS A FILE I/O OPERATION THEN INTERPRET THE FCB
;
10$:	BBC	#QIOV_FILES,QIO_FLAGS(R2),50$; BR IF NOT FILES ORIENTED
;
; FILE I/O OPERATION
;
	MOVL	QIO_SECONDBLK(R2),R3	; ADDRESS FCB FOR OPERATION
	BLBC	QIO_IOSB(R2),20$	; IF NOT SUCCESSFUL OPERATION BR
;
; ENTER FUNCTION SPECIFIC I/O DONE ROUTINE
;
	MOVL	FCB_PC(R3),R0		; ADDRESS THE ROUTINE
	BEQL	20$			; IF EQL THEN NONE
	JSB	(R0)			; GO TO IT
;
; I/O DONE PROCESSING DONE OR UNSUCCESSFUL FUNCTION
;
20$:	INSQUE	(R3),I_FCBPOOL(R10)	; DEALLOCATE THE BLOCK
	MOVL	AST_PARAM(AP),R2	; ADDRESS CONTEXT BLOCK AGAIN
;
; POST THE STATUS IN THE IOSB
;
; MAP THE VAX/VMS STATUS CODE TO AN RSX CODE
;
50$:	MOVZWL	ACB_UPRM(R2),R8		; ADDRESS IOSB
	BEQL	100$			; IF EQL THEN NONE
	MOVZWL	QIO_IOSB(R2),R0		; GET THE STATUS
	BSBW	RSX$RSXQIOERR		; MAP THE STATUS
	MOVW	QIO_IOSB+2(R2),2(R8)	; INSERT APPARENT TRANSFER SIZE
	MOVB	R1,(R8)			; INSERT STATUS IN HIS IOSB
	CLRB	1(R8)			; PRESET TERMINATOR TO ZERO
;
; FOR READ FUNCTIONS, RETURN TERMINATOR AND SET EOF STATUS (IF ANY)
;
	BBC	#QIOV_READ,QIO_FLAGS(R2),100$ ; BRANCH IF NOT READ FUNCTION
	MOVL	QIO_LUT(R2),R3		; ADDRESS THE LUT
	CASE	LUT_TYPE(R3),TYPE=B,-
		<-
		80$,-			; RMS
		70$,-			; TERMINALS
		>
	BRB	100$			;
;
; MAP TERMINAL STATUS RETURNS
;
70$:	MOVZWL	QIO_IOSB+6(R2),R0	; GET TERMINATOR SIZE
	BEQL	90$			; IF EQL THEN NO TERMINATOR
	MOVB	QIO_IOSB+4(R2),1(R8)	; INSERT TERMINATOR
	CMPB	#26,QIO_IOSB+4(R2)	; CONTROL Z?
	BNEQ	75$			; IF NEQ THEN NO
	MOVZBW	#IE.EOF,(R8)		; SET IE.EOF
	BRB	100$			; CONTINUE
75$:	CMPB	R0,#1			; ONE TERMINATOR?
	BEQL	100$			; IF EQL THEN YES
	BISW	#^X08000,(R8)		; SET ESCAPE SEQUENCE
	BRB	100$
;
; RMS TERMINAL-LIKE STATUS POST
;
80$:
	MOVB	QIO_IOSB+4(R2),1(R8)	; INSERT TERMINATOR
	CMPB	#26,QIO_IOSB+4(R2)	; CONTROL Z?
	BNEQ	100$			; IF NEQ THEN NO
	MOVZBW	#IE.EOF,(R8)		; SET IE.EOF
	BRB	100$			;
;
; LOOK FOR CONTROL Y/C SPECIAL CASE
;
90$:	BLBC	QIO_IOSB(R2),100$	; ERROR?
	CMPW	#SS$_CONTROLY,QIO_IOSB(R2);
	BEQL	95$			; IF EQL THEN YES
	CMPW	#SS$_CONTROLC,QIO_IOSB(R2);
	BNEQ	100$			;
95$:	MOVB	#13,1(R8)		; SET CR TERMINATOR
;
; DELIVER AST IF NEEDED
;
100$:	TSTW	ACB_UPC(R2)		; AST TO DELIVER?
	BNEQ	110$			; IF NEQ THEN YES
	INSQUE	(R2),I_ASTPOOL(R10)	; DEALLOCATE THE AST BLOCK
105$:	RET				; RETURN
110$:	BRW	POSTAST			; POST THE AST FOR THE USER

	.SBTTL	RSX$UNSOLAST - TERMINAL UNSOLICITED DATA AST
;---
;
; THIS ROUTINE SUPPORTS THE IO.ATA FUNCTION ON TERMINALS.
; WHEN AN UNSOLICITED CHARACTER IS RECEIVED FROM THE TERMINAL DRIVER,
; WE INTERRUPT HERE TO PASS THE AST TO THE COMPATIBILITY MODE IMAGE.
; THE AST IS DELIVERED TO THE IMAGE IF IT IS STILL ENABLED TO HEAR IT.
; THE IMAGE IS ENABLED IF LUTV_UNSOL IS SET IN THE LUT ASSOCIATED WITH
; THE TERMINAL.
;
; INPUTS:
;
;	AST_PARAM(AP) = ADDRESS OF THE AST CONTEXT BLOCK
;
; OUTPUTS:
;
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;
;--
RSX$UNSOLAST::
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVL	G^SYS$GL_CMCNTX,R10	; ADDRESS IMPURE DATA AREA
	BBC	#SV_UNSOLAST,I_STATE(R10),90$ ; BRANCH IF NOT ENABLED
	MOVL	AST_PARAM(AP),R2	; ADDRESS THE AST CONTROL BLOCK
	SUBL	#80,SP
10$:	MOVL	SP,R0
	$QIOW_S	CHAN=I_UNSOLMBX(R10),-	; READ THE MAILBOX TO CLEAR MESSAGE
		FUNC=#IO$_READVBLK!IO$M_NOW,-
		IOSB=ACB_IOSB(R2),-
		P1=(R0),P2=#80
	BLBC	R0,20$			; BRANCH IF NO MESSAGE
	MOVZWL	ACB_IOSB(R2),R0		; GET IOSB STATUS
	BLBS	R0,10$			; CLEAN OUT MAILBOX
20$:	ADDL	#80,SP			; DEALLOCATE MAILBOX BUFFER
	MOVL	ACB_LUT(R2),R8		; ADDRESS THE LUT
	BSBB	RSX$GET_CHAR		; GET THE NEXT CHARACTER
	BLBC	R0,50$			; BRANCH IF NO CHARACTER THERE
	BRW	POSTAST			; POST THE AST
50$:	BSBW	RSX$UNSOLASTEN		; RE-ENABLE MAILBOX AST
90$:	RET				; AND DISMISS AST

	.SBTTL	RSX$GET_CHAR, GET NEXT CHARACTER FROM TYPEAHD BUFFER
;---
;
;	GET THE NEXT CHARACTER FROM THE TYPEAHEAD BUFFER.
;
; INPUTS:
;
;	R2 = ADDRESS OF AST CONTROL BLOCK
;	R8 = ADDRESS OF LUT
;
; OUTPUTS:
;
;	ACB_UPRM(R2) = CHARACTER
;	R0 = TRUE IF CHARACTER READ, FALSE IF NO CHARACTER AVAILABLE.
;---
RSX$GET_CHAR::
	$QIOW_S	CHAN=LUT_CHAN(R8),-	; OBTAIN THE CHARACTER
		FUNC=#IO$_READVBLK!IO$M_NOFILTR!IO$M_NOECHO!IO$M_TIMED,-
		IOSB=ACB_IOSB(R2),-
		P1=ACB_UPRM(R2),-
		P2=#1,-
		P3=#0			; 0 TIMEOUT; NO WAIT IF NOTHING
	BLBC	R0,80$			; BRANCH IF ANY ERROR
	MOVZWL	ACB_IOSB(R2),R0		; GET STATUS FROM IOSB
80$:	RSB

;++
; RSX$CTRLCAST - TERMINAL CONTROL/C AST
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE SUPPORTS THE IO.ATA FUNCTION ON TERMINALS.
; WHEN A CONTROL/C CHARACTER IS RECEIVED FROM THE TERMINAL DRIVER,
; WE INTERRUPT HERE TO PASS THE AST TO THE COMPATIBILITY MODE IMAGE.
; THE AST IS DELIVERED TO THE IMAGE IF IT IS STILL ENABLED TO HEAR IT.
; THE IMAGE IS ENABLED IF LUTV_CTRLC IS SET IN THE LUT ASSOCIATED WITH
; THE TERMINAL.
;
; INPUTS:
;
;	AST_PARAM(AP) = ADDRESS OF THE AST CONTEXT BLOCK
;
; OUTPUTS:
;
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;
;--
RSX$CTRLCAST::				; CONTROL C AST
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVL	G^SYS$GL_CMCNTX,R10	; ADDRESS IMPURE DATA AREA
	MOVL	AST_PARAM(AP),R2	; ADDRESS BLOCK FOR AST
	MOVL	ACB_LUT(R2),R3		; ADDRESS LUT OF CHANNEL
	BBC	#LUTV_CTRLC,LUT_FLAGS(R3),90$	; SKIP IF NOT ENABLED
	BRW	POSTAST			; POST THE AST
90$:	RET

;---
; RSX$TERMINAST - AST ROUTINE FOR SUBPROCESS TERMINATION
;
; THIS ROUTINE IS THE AST SERVICE ROUTINE FOR TERMINATION OF
; SUBPROCESSES CREATED BY THE SPAWN DIRECTIVE.  IF SPECIFIED,
; THE USER SPAWN PARAMETERS (EVENT FLAG, EXIT STATUS BLOCK AND
; AST ROUTINE) ARE HANDLED.
;
; INPUTS:
;
;	AST_PARAM(AP) = ADDRESS OF THE OFFSPRING CONTROL BLOCK
;---
RSX$TERMINAST::
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	MOVL	G^SYS$GL_CMCNTX,R10	; ADDRESS IMPURE DATA AREA
	MOVL	AST_PARAM(AP),R9	; ADDRESS THE CONTROL BLOCK
	MOVZWL	OCB_EFN(R9),R1		; ANY EVENT FLAG SPECIFIED?
	BEQL	10$			; BRANCH IF NONE
	ADDL	#31,R1			; MAP TO RSX EVENT FLAGS
	$SETEF_S R1			; SET THE EVENT FLAG
10$:	SUBL	#ACC$C_TERMLEN,SP	; ALLOCATE BUFFER SPACE
	MOVL	SP,R0			; ADDRESS OF RECORD BUFFER
	$QIOW_S	CHAN=OCB_CHAN(R9),-	; READ THE TERMINATION MAILBOX
		FUNC=#IO$_READVBLK,-
		P1=(R0),P2=#ACC$C_TERMLEN
	MOVZWL	OCB_ESB(R9),R6		; ANY EXIT STATUS BLOCK?
	BEQL	20$			; BRANCH IF NONE
	IFNOWRT	#8*2,(R6),20$		; SKIP IF NO WRITE ACCESS
	MOVC5	#0,(R6),#0,#16,(R6)	; PREZERO THE STATUS BLOCK
	BICW3	#^XFFF8,ACC$L_FINALSTS(SP),(R6)	; MOVE ONLY SEVERITY
20$:	ADDL	#ACC$C_TERMLEN,SP	; DEALLOCATE THE BUFFER
	$DASSGN_S OCB_CHAN(R9)		; DEASSIGN THE MAILBOX CHANNEL
	MOVZWL	OCB_AST(R9),R6		; SAVE USER AST ADDRESS
	MOVZWL	OCB_ESB(R9),R7		; SAVE EXIT STATUS BLOCK ADDRESS
	MOVL	R9,R0			; ADDRESS OF BLOCK TO DEALLOCATE
	MOVL	#OCB_LENGTH,R1		; LENGTH OF BLOCK
	BSBW	RSX$DEALLOCATE		; DEALLOCATE THE BLOCK
	TSTW	R6			; ANY USER AST ROUTINE?
	BEQL	30$			; BRANCH IF NONE
	BSBW	RSX$SETUPAST		; ALLOCATE AN AST BLOCK
	MOVW	R6,ACB_UPC(R2)		; SET USER AST ADDRESS
	MOVW	R7,ACB_UPRM(R2)		; EXIT STATUS BLOCK ADDRESS
	CLRW	ACB_FLAGS(R2)		; CLEAR ALL FLAGS
	BRW	POSTAST			; POST THE AST
30$:	RET


	.END
