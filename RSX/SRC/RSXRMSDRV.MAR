	.TITLE	RSXRMSDRV - VAX/VMS RSX11M AME RMS DRIVER 
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:
;
;	VAX/VMS RSX11M AME
;
; ABSTRACT:
;
; 	RMS I/O DRIVER
;
; AUTHOR: R.HEINEN 4-NOV-76
;
; MODIFIED BY:
;
;	V001	TMH0001		Tim Halvorsen	10-Dec-1980
;		Mark read I/O functions so that EOF's are not detected
;		in the AST routine.
;--
;
; EXTERNAL SYMBOLS
;
	$RSXDEF			; DEFINE RSX SYMBOLS
	$RABDEF			; DEFINE RAB

	.SBTTL	RSX$RMS_DRV - RMS DRIVER
;++
	.PSECT	RSXCODE,NOWRT,SHR,PIC
; RSX$RMS_DRV - RMS I/O DRIVER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE PROCESSES ALL RMS DIRECTED I/O OPERATIONS.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE QIO CONTEXT
;	R3 = MAJOR FUNCTION CODE
;	R5 = QIO DPB AREA
;	R6 = STACK
;	R7 = ENTIRE FUNCTION CODE
;	R8 = LUT ENTRY
;	R10 = ADDRESS OF THE IMAGE IMPURE AREA
;	R11 = HEADER ADDRESS
;
; OUTPUTS:
;
;	R10,R11 ARE SAVED.
;--
RSX$RMS_DRV::				; RMS I/O DRIVER
	CASE	R3,<-			;
		RSX$DLVRQIOAST,-	; I/O KILL
		RMS_PUT,-		; WRITE LOGICAL BLOCK
		RMS_GET,-		; READ LOGICAL BLOCK
		RSX$DLVRQIOAST,-	; ATTACH DEVICE
		RSX$DLVRQIOAST,-	; DETACH DEVICE
		RMS_SET,-		; FUNCTION CODE 5
		RSX$DLVRQIOAST,-	; FUNCTION CODE 6
		RSX$IEIFC,-		; ILLEGAL
		RSX$IEIFC,-		; ILLEGAL
		RMS_GET,-		; FUNCTION CODE 9
		RSX$IEIFC,-		; ILLEGAL
		RSX$DLVRQIOAST,-	; ACP FUNCTIONS
		RSX$DLVRQIOAST,-	; ACP FUNCTIONS
		RSX$DLVRQIOAST,-	; ACP FUNCTIONS
		RSX$DLVRQIOAST,-	; ACP FUNCTIONS
		RSX$DLVRQIOAST,-	; ACP FUNCTIONS
		RSX$DLVRQIOAST,-	; ACP FUNCTIONS
		RMS_GET,-		; READ VIRTUAL BLOCK
		RMS_PUT,-		; WRITE VIRTUAL BLOCK
		RSX$DLVRQIOAST,-	; ACP FUNCTIONS
		RSX$DLVRQIOAST,-	; ACP FUNCTIONS
		RSX$DLVRQIOAST,-	; ACP FUNCTIONS
		RSX$DLVRQIOAST,-	; ACP FUNCTIONS
		RSX$DLVRQIOAST,-	; ACP FUNCTIONS
		RSX$DLVRQIOAST,-	; ACP FUNCTIONS
		>
	BRW	RSX$IEIFC		; ERROR EXIT
;
; RMS GET FOR A READ VIRTUAL OR LOGICAL 
;
RMS_GET:				;
	BSBW	RSX$CHK_TI_INP		; CHECK FOR TI
	MOVAB	W^RSX$G_RAB,R4		; ADDRESS RAB
	MOVW	LUT_CHAN+2(R8),RAB$W_ISI(R4); INSERT CONNECTION DATA
	CLRL	RAB$L_RHB(R4)		; ZERO CONTROL BYTE
	MOVZWL	(R5),RAB$L_UBF(R4)	; SET UP BUFFER ADDRESS
	MOVW	2(R5),RAB$W_USZ(R4)	; SET UP SIZE
	$GET	RAB=(R4)		; DO THE GET
	MOVZWL	#^X0100D,QIO_IOSB+4(R2)	; SET TERMINAL TYPE SECOND STATUS
	BBCS	#QIOV_READ,QIO_FLAGS(R2),RMSIOERROR ; MARK READ I/O FUNCTION
	BRB	RMSIOERROR		; HANDLE THE ERRORS IN COMMON WITH WRITES
;
; RMS PUT
;
RMS_PUT:				;
	BSBW	RSX$CHK_TI_OUT		; CHECK FOR TI OUTPUT
	MOVAB	W^RSX$G_RAB,R4		; ADDRESS RAB
	MOVW	LUT_CHAN+2(R8),RAB$W_ISI(R4); INSERT CONNECTION DATA
	MOVAB	W^RSX$GL_CARRIAGE,R0	; ADDRESS CARRAGE CONTROL CONVERTION TABLE
	MOVZBL	4(R5),RAB$L_RHB(R4)	; GET CONTROL BYTE
	BEQL	20$			; IF EQL THEN NONE
10$:	MOVAW	(R0)+,RAB$L_RHB(R4)	; ASSUME THIS ONE
	TSTB	(R0)			; DONE?
	BEQL	20$			; IF EQL THEN YES
	CMPB	4(R5),(R0)+		; MATCH
	BNEQ	10$			; IF EQL THEN NO
20$:	MOVZWL	(R5),RAB$L_RBF(R4)	; SET UP BUFFER ADDRESS
	MOVW	2(R5),RAB$W_RSZ(R4)	; SET UP SIZE
	$PUT	RAB=(R4)		; PUT THE RECORD
	CLRL	QIO_IOSB+4(R2)		; SET NO SECOND STATUS
RMSIOERROR:				;
	MOVZBW	#SS$_NORMAL,QIO_IOSB(R2); ASSUME NORMAL COMPLETION
	BLBS	R0,10$			; IF LOW SET THEN SUCCESS
	CMPL	R0,#RMS$_EOF		; EOF?
	BNEQ	5$			; IF YES THEN SET ERROR
	MOVB	#26,QIO_IOSB+4(R2)	; SET TERMINATED BY CTRLZ
	BRB	10$			; CONTINUE
5$:	MOVZWL	#SS$_CTRLERR,QIO_IOSB(R2); SET DEFAULT ERROR
	CLRL	QIO_IOSB+4(R2)		; SET NO SECOND STATUS
10$:	MOVW	RAB$W_RSZ(R4),QIO_IOSB+2(R2); SET SIZE OF RECORD
	MOVQ	QIO_IOSB(R2),R0		; PICK STATUS UP AS A WHOLE
	BRW	RSX$DLVRQIOAST		; POST STATUS IN AST
;
; RMS SET TERMINAL CHARACTERISTICS
;
RMS_SET:				;
	MOVZWL	#SS$_ILLIOFUNC,R0	; ASSUME ILLEGAL FUNCTION
	TSTB	R7			; ONLY IO.GTS
	BNEQ	10$			; IF NEQ THEN ILLEGAL
	MOVZWL	(R5)+,R4		; ADDRESS BUFFER
	MOVZWL	(R5),R5			; GET SIZE
	MOVZWL	#SS$_ACCVIO,R0		; ASSUME BAD BUFFER
	CMPW	#4,R5			; ENOUGH?
	BGTRU	10$			; IF GTRU THEN NO
	IFNOWRT	R5,(R4),10$
	CLRL	(R4)			; SET NO SUPPORT
	MOVW	#SS$_NORMAL,R0		; ASSUME SUCCESS
10$:	CLRL	R1
	BRW	RSX$DLVRQIOAST		;
	.END
