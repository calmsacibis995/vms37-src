	.TITLE	RSXEXCEPTION - RSX-11M AME EXCEPTION HANDLER
	.IDENT	'V03-001'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:
;
;	VAX/VMS RSX-11M AME
;
; ABSTRACT:
;
;	EXCEPTION HANDLER FOR ALL EXCEPTIONS DURING RSX/CM IMAGE EXECUTION.
;
; AUTHOR R.HEINEN 29-SEPT-76 
;
; PREVIOUSLY MODIFIED BY:
;
;	Tim Halvorsen
;
; MODIFIED BY:
;
;	V001	MSH026		Michael S. Harvey	23-Mar-82
;		Eliminate dependencies on VMS Executive symbols.
;
;--
;
; EXTERNAL SYMBOLS
;
	$RSXDEF			; DEFINE RSX SYMBOLS
	DRERR$			; DEFINE DIRECTIVE ERROR CODES
;
; LOCAL MACRO
;
	.MACRO DIC ROUT,SIZE
	.PSECT	RSXCODE,NOWRT,SHR,PIC
	.IF NB ROUT
	.WORD	RSX$'ROUT-DICBASE
	.IFF
	.WORD	DICEND-DICBASE
	.ENDC
	.PSECT	RSXPURE,NOWRT,EXE,LONG,SHR,PIC
	.BYTE	SIZE
	.ENDM
	.MACRO SST ROUT,SIZE
	.PSECT	RSXCODE,NOWRT,SHR,PIC
	.WORD	'ROUT-SSTBASE
	.PSECT	RSXPURE,NOWRT,EXE,LONG,PIC,SHR
	.BYTE	SIZE
	.ENDM
 
	.PSECT	RSXCODE,NOWRT,PIC,SHR

	.SBTTL	RSX$EXCEPTION -- IMAGE EXCEPTION HANDLER
;++
; RSX$EXCEPTION - EXCEPTION HANDLER FOR RSX
;
; FUNCTIONAL DESCRIPTION:
;
; THIS EXCEPTION HANDLER RECEIVES CONTROL ON EXCEPTIONS THAT ARE NOT
; CAUSED BY CM INSTRUCTION TRAPS OR EXCEPTIONS.
;
; IF THE EXCEPTION OCCURED IN CM THEN IT WILL RESULT IN A MEMORY PROTECTION
; VIOLATION DELIVERED VIA HIS SST VECTOR AS IF IT WERE A CM TRAP TYPE.
;
; IF THE EXCEPTION OCCURED IN NATIVE MODE AND IT IS AN ACCESS VIOLATION
; AND THE VIRTUAL ADDRESS REFERENCED IS LESS THAN 65K, THEN THE EXCEPTION
; OCCURED DURRING DIRECTIVE PROCESSING AND THE DSW/PSL ARE SET TO REFLECT
; THIS (IE.ADP) OTHERWISE THE RSX IS ABORTED.
;
; INPUTS:
;
;	AP = ADDRESS OF EXCEPTION ARGUMENTS
;
; OUTPUTS:
;	NONE
;--
	.ENTRY	RSX$EXCEPTION,0		; SAVE NO REGISTERS
	MOVL	4(AP),R0		; ADDRESS PC/PSL ARG LIST
	MOVL	(R0),R1			; GET THE NUMBER OF ARGUMENTS
	MOVAL	(R0)[R1],R1		; GET THE EXCEPTION PSL
;
; SPECIAL CASE POSSIBLE FLOATING EMULATION EXCEPTION
;
	PUSHAB	W^RSX$FLOAT		; ADDRESS START OF RANGE
	CMPL	(SP)+,-4(R1)		; IN RANGE?
	BGTRU	5$			; IF RANGE GEQU THEN NO
	PUSHAB	W^RSX$FLOAT_END		; ADDRESS UPPER LIMIT
	CMPL	(SP)+,-4(R1)		; IN RANGE?
	BLEQU	5$			; IF LEQU THEN NO
	BRW	RSX$FLOAT_EXC		; ENTER FLOATING EXCEPTION CODE
;
; CHECK FOR SPECIAL "DEB" COMMAND EXCEPTION
;
5$:	CMPW	#SS$_DEBUG,AP_NAME(R0)	; DEBUG COMMAND?
	BEQL	20$			; IF EQL THEN YES
;
; RSX FAULT IF IN NATIVE MODE
;
	BBCC	#PSL_CM,(R1),10$	; IF NOT FROM CM THEN BRANCH
	MOVAB	B^ACCVIO,R0		; SET CONTINUE ADDRESS
	BRB	12$			; CONTINUE
;
; NATIVE MODE EXCEPTION
;
; IF THE EXCEPTION IS ACCESS VIOLATION AND THE REFERENCED ADDRESS
; WAS UNDER 65K THEN THIS VIOLATION IS DUE TO A DIRECTIVE PROCEEDURE.
;
; THE DSW IS SET UP AND THE RETURN PC IS JAMMED TO REENTER THE IMAGE
;
10$:	CMPW	AP_NAME(R0),#SS$_ACCVIO	; ACCESS VIOLATION?
	BNEQ	50$			; IF NEQ THEN ABORT THE RSX
	TSTW	14(R0)			; WITHIN 65K?
	BNEQ	50$			; IF NEQ THEN ABORT RSX
	MOVAB	B^60$,R0		; SET ADDRESS TO CONTINUE
;
; THIS EXCEPTION IS FOR A CONDITION NOT ASSOCIATED WITH CM BUT OCCURING
; WHEN THE PROCESSOR WAS IN CM.
;
12$:	BBCC	#PSL_FPD,(R1),15$	; CLEAR FIRST PART DONE
15$:	BICB	#1@PSL_TBIT,(R1)	; CLEAR TBIT PENDING
	MOVL	R0,-(R1)		; CHANGE CONTINUE ADDRESS
	BRB	27$			; CONTINUE
;
; DEBUG EXCEPTION
;
20$:	BBS	#PSL_CM,(R1),25$	; BR IF IN CM
	MOVL	G^SYS$GL_CMCNTX,R0	; ADDRESS IMAGE IMPURE AREA
	BBC	#SV_WAIT,I_STATE(R0),23$ ; BR IF NOT IN WAITFOR STATE
	MOVZWL	#128,I_WAIT(R0)		; SET ILLEGAL MASK TO FLUSH WAIT
;
; NOTE THAT THE WAIT IN PROGRESS IS COMPLETE. THE CONTEXT PRIOR TO THE
; WAIT HAS BEEN LOST.
;
23$:	BISB	#1@PSL_TBIT,I_PS(R0)	; SET TBIT ON RETURN
	BRB	27$			; 
25$:	BISB	#1@PSL_TBIT,(R1)	; SET TBIT IN RETURN PSL
27$:	MOVZWL	#SS$_CONTINUE,R0	; CONTINUE
	RET				;
;
; ABORT THE RSX - FATAL ERROR
;
50$:	MOVZWL	#SS$_RESIGNAL,R0	; SET UP TO FIND WAY BACK TO ENTRY
	MOVAB	W^RSX$RETEXIT,W^RSX$A_EXITBLOCK+4; RESET FOR NO EXIT HANDLER
	RET	
;
; CONTINUE IF DIRECTIVE ACCESS VIOLATION
;
60$:	MOVL	G^SYS$GL_CMCNTX,R10	; ADDRESS IMAGE IMPURE AREA
	CLRL	R11
	CVTBW	#IE.ADP,H.DSW(R11)	; SET ERROR CODE
	BISB	#1@PSL_CC,I_PS(R10)	; SET C BIT
	BRW	RSX$RESTORE		; CONTINUE
;
; COMPATIBILITY MODE ACCESS VIOLATION
;
ACCVIO:	MOVL	#8,R0			; SET VIOLATION TYPE
	CLRL	R11			;
	MOVL	G^SYS$GL_CMCNTX,R10	; ADDRESS IMAGE IMPURE AREA
	BRW	RSX$TRAP		; CONTINUE

	.SBTTL	COMPATIBILITY MODE TRAP HANDLER
 
	.ENABL	LSB
;++
; RSX$CMTRAP - COMPATIBILITY MODE TRAP HANDLER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED WHEN A CM FAULT OCCURS. THE ENTRY WAS SPECIFIED
; DURING THE RSX INITIALIZATION BY THE $DCLCMH SYSTEM SERVICE.
; ENTRY HERE IS A VERY SPECIAL CASE OF EXCEPTION HANDLING. 
;
; REGISTERS R0-R6 ARE SAVED IN THE IMAGE IMPURE AREA AT CTL$AL_CMCNTX,
; POINTED TO BY SYS$GL_CMCNTX.
;
; THE TYPE OF CM EXCEPTION IS IN CTL$AL_CMCNTX+28.
;
; THE PC/PSL ARE SAVED AT CTL$AL_CMCNTX+32.
;
; THE ACTION IS TO INTERPRET THE CONDITION AND TO RESPOND IN AN RSX11M
; COMPATIBLE FORM.
;
; ENTRY HERE (SST) IS ALSO FROM RSX$EXCEPTION WHEN AN EXCEPTION
; OCCURS IN CM THAT IS NOT CM DEPENDENT. THE CONTROL AREA IS HOWEVER,
; THE SAME.
;
; INPUTS:
;
;	R0 = ADDRESS IN THE CONTROL REGION OF THE PC/PSL PAIR
;
;	 STACK IS EMPTY.
;
; OUTPUTS:
;
;	AN REI IS DONE TO THE IMAGE.
;	OR THE EXECUTION OF THE IMAGE IS TERMINATED.
;--
RSX$CMTRAP::				;
	MOVL	G^SYS$GL_CMCNTX,R10	; ADDRESS IMAGE IMPURE AREA
	IFNORD	#2,@(R0),ACCVIO		; ERROR IF CANNOT READ
	MOVZWL	@(R0),R8		; GET INSTRUCTION 
	MOVZBL	-4(R0),R0		; RESERVED INSTRUCTION?
	BNEQ	15$			; IF NEQ THEN NO
	CMPW	#^O0170000,R8		; IN FLOATING INSTRUCTION RANGE?
	BLEQU	50$			; IF LEQU THEN FLOATING INSTRUCTION
;
; CONTINUE NORMAL EXCEPTION PATH
;
15$:	CLRL	R11			; POINT TO IMAGE
	ADDL	#2,I_PC(R10)		; ADJUST PC
;
; ENTER THE ROUTINE BASED ON THE TRAP TYPE
;
20$:	CASEB	R0,#0,#<<SSTEND-SSTBASE>/2>-1 ; ENTER PROPER ROUTINE
SSTBASE:
	.PSECT	RSXPURE,EXE,NOWRT,PIC,SHR,LONG
RSX$B_SST:
	SST	RSX$RESERVED,4		; RESERVED INSTRUCTION
	SST	RSX$TRAP,2		; BPT
	SST	RSX$TRAP,3		; IOT
	SST	EMT,5			; EMT
	SST	RSX$TRAP,6		; TRAP
	SST	ILLEGAL,4		; ILLEGAL INSTRUCTION
	SST	ILLEGAL,0		; ODD ADDRESS
	SST	ILLEGAL,2		; TBIT
	SST	ILLEGAL,1		; MEMORY VIOLATION
 
	.PSECT	RSXCODE,NOWRT,SHR,PIC
 
SSTEND:					;
	BRW	RSX$RESTORE		; IGNORE IF ILLEGAL
50$:	BRW	RSX$FLOAT		; ENTER FLOATING EMULATION
 
	.DSABL	LSB

	.SBTTL	EMT PROCESSOR
;++
; EMT - PROCESS POSSIBLE EMT 377
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED WHEN THE CM EXCEPTION INDICATES AN EMT INSTRUCTION
; WAS DONE. IF THE EMT IS EMT377 THEN THE REQUEST IS FOR AN RSX11M SYSTEM SERVICE.
; OTHERWISE THE EMT IS TREATED AS ANY OTHER TRAPPING INSTRUCTION.
;
; INPUTS:
;
;	R0 = CM TRAP TYPE
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA AREA
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	IF NOT EMT 377, CONTROL IS PASSED IMMEDIATELY TO "TRAP"
;
;	THE DIRECTIVE ROUTINE IS ENTERED WITH THE FOLLOWING SET:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = CM IMAGE STACK ADDRESS
;	R10 = ADDRESS OF CM IMAGE DATA AREA
;	R11 = ADDRESS OF IMAGE HEADER
;--
EMT:
	CMPB	R8,#^O0377		; EMT 377?
	BEQL	10$			; IF EQL THEN RSX DIRECTIVE
	BRW	RSX$TRAP		; VECTOR FOR NOT EMT377
;
; DIRECTIVE DISPATCHER FOR RSX11M DIRECTIVES
;
10$:	MOVZBL	#2,R7			; ASSUME INITIAL STACK ADJUSTMENT
	MOVZWL	(R6),R5			; GET DPB ADDRESS FLAG
	BLBC	R5,25$			; IF LOW CLEAR THEN STACK POINTS TO DPB
	MOVL	R6,R5			; IF LOW SET THEN DPB ON STACK
	MULB3	#2,1(R5),R7		; SET NUMBER TO REMOVE FROM STACK
25$:	ADDL	R7,R6			; CLEAN STACK
	EXTZV	#1,#7,(R5)+,R4		; GET DIC CODE/2
	MOVZBL	W^RSX$B_DIC[R4],R3	; GET DPB SIZE
	BNEQ	30$			; BRANCH IF FIXED LENGTH DPB
	INCL	R5			; ALWAYS LEAVE R5 SET TO DPB+2
	BRB	40$			; SKIP DPB SIZE CHECK
30$:	CMPB	(R5)+,R3		; CHECK FOR BAD DIC AND SIZE
	BEQL	40$			; IF EQL THEN OK
	CVTBW	#IE.SDP,H.DSW(R11)	; SET DSW TO ERROR STATUS
	BISW	#1@PSL_CC,I_PS(R10)	; SET THE C-BIT
	BRW	RSX$RESTORE		; REENTER IMAGE
40$:	MOVW	#1,H.DSW(R11)		; ASSUME SUCCESS
	BICW	#^C<1@PSL_TBIT>,I_PS(R10); RESET CONDITION CODES
	MOVAB	-2(R5),R1		; ADDRESS OF DPB
	BSBW	RSX$LOG			; MAKE A LOG ENTRY
	PUSHAB	W^RSX$RESTORE		; REENTER IMAGE AFTER DIRECTIVE

;
; DISPATCH ON DIRECTIVE NUMBER
;
RSX$DISPATCH::
	CASEB	R4,#0,#<<DICEND-DICBASE>/2>-1	; ENTER DIRECTIVE PROCESSING
DICBASE:
	.PSECT	RSXPURE,EXE,NOWRT,PIC,SHR,LONG
RSX$B_DIC:
	DIC	QIO,12		; 1	QIO
	DIC	QIOW,12		; 3	QIO AND WAIT
	DIC	GLUN,3		; 5	GET LUN INFORMATION
	DIC	ALUN,4		; 7	ASSIGN LUN
	DIC	ALTP,4		; 9	ALTER TASK PRIORITY
	DIC	RQST,0		; 11	REQUEST OR SPAWN (VAR DPB)
	DIC			; 13	-- UNUSED
	DIC			; 15	-- UNUSED
	DIC	RUN,11		; 17	RUN TASK
	DIC			; 19	-- UNUSED
	DIC			; 21	SET RECEIVE BY REF AST
	DIC	MRKT,5		; 23	MARK TIME
	DIC	CSRQ,3		; 25	CANCEL SCHEDULE REQUESTS
	DIC	CMKT,0		; 27	CANCEL MARK TIME (1 OR 3 WORD FORM)
	DIC	EXST,2		; 29	EXIT WITH STATUS
	DIC	CLEF,2		; 31	CLEAR EVENT FLAG
	DIC	SETF,2		; 33	SET EVENT FLAG
	DIC	DECL,1		; 35	DECLARE SIGNIFICANT EVENT
	DIC			; 37	-- UNUSED
	DIC	RDAF,0		; 39	READ ALL EVENT FLAGS (VAR DPB)
	DIC	WTSE,2		; 41	WAIT FOR SINGLE EVENT FLAGS
	DIC	WTLO,3		; 43	WAIT FOR LOGICAL OR OF FLAGS
	DIC	SPND,1		; 45	SUSPEND TASK
	DIC	RSUM,3		; 47	RESUME TASK
	DIC	WSIG,1		; 49	WAIT FOR SIGNIFICANT EVENT
	DIC	EXIT,1		; 51	TASK EXIT
	DIC	EXIF,2		; 53	EXIT IF
	DIC			; 55	CREATE REGION
	DIC			; 57	ATTACH REGION
	DIC			; 59	DETACH REGION
	DIC	GTIM,2		; 61	GET TIME
	DIC	GTSK,2		; 63	GET TASK PARAMETERS
	DIC	GPRT,4		; 65	GET PARTITION PARAMETERS
	DIC			; 67	-- UNUSED
	DIC			; 69	SEND BY REFERENCE
	DIC	SDAT,5		; 71	SEND DATA
	DIC			; 73	-- UNUSED
	DIC	RCVD,4		; 75	RECEIVE DATA
	DIC	RCVX,4		; 77	RECEIVE DATA OR EXIT
	DIC			; 79	-- UNUSED
	DIC			; 81	RECEIVE BY REFERENCE
	DIC	ABRT,3		; 83	ABORT TASK
	DIC			; 85	-- UNUSED
	DIC			; 87	-- UNUSED
	DIC	EXTK,3		; 89	EXTEND TASK
	DIC	CRGF,2		; 91	CREATE GROUP EVENT FLAGS
	DIC	ELGF,2		; 93	ELIMINATE GROUP EVENT FLAGS
	DIC	DSCP,1		; 95	DISABLE CHECK POINTING
	DIC	ENCP,1		; 97	ENABLE CHECK POINTING
	DIC	DSAR,1		; 99	DISABLE AST'S
	DIC	ENAR,1		; 101	ENABLE AST'S
	DIC	SVDB,3		; 103	SPECIFY DEBUG VECTOR
	DIC	SVTK,3		; 105	SPECIFY TASK VECTOR
	DIC	SRDA,2		; 107	SPECIFY RECEIVE AST'S
	DIC	SPRA,2		; 109	SPECIFY POWER FAIL AST
	DIC	SFPA,2		; 111	SPECIFY FLOATING AST
	DIC			; 113	GET MAPPING CONTEXT
	DIC	ASTX,1		; 115	AST SERVICE EXIT
	DIC			; 117	CREATE ADDRESS WINDOW
	DIC			; 119	ELIMINATE ADDRESS WINDOW
	DIC			; 121	MAP ADDRESS WINDOW
	DIC			; 123	UNMAP ADDRESS WINDOW
	DIC			; 125	GET SENSE SWITCHES
	DIC	GMCR,41		; 127	GET MCR LINE
	DIC			; 129	CONNECT TO INTERRUPT
	DIC	STOP,1		; 131	STOP TASK
	DIC	USTP,3		; 133	UNSTOP TASK
	DIC	STSE,2		; 135	STOP FOR SINGLE EVENT FLAG
	DIC	STLO,3		; 137	STOP FOR LOGICAL OR
	DIC	RCST,4		; 139	RECEIVE DATA OR STOP
	DIC			; 141	SEND DATA, REQUEST, CONNECT (M+)
	DIC			; 143	CONNECT
	DIC	ELEP,0		; 145	VMS ELEPHANT DIRECTIVE (VAR DPB)
	DIC			; 147	EMIT STATUS (M+)
	DIC			; 149	CREATE VIRTUAL TERMINAL (M+)
	DIC			; 151	ELIMINATE VIRTUAL TERMINAL (M+)
	DIC			; 153	-- UNUSED
	DIC			; 155	SUPERVISOR MODE CALL (M+)
	DIC	CRGF,2		; 157	CREATE GROUP EVENT FLAGS
	DIC	ELGF,2		; 159	ELIMINATE GROUP EVENT FLAGS
	DIC			; 161	SPECIFY AFFINITY (M+)
	DIC			; 163	REMOVE AFFINITY (M+)
	DIC			; 165	PARITY ERROR AST (M+)
	DIC			; 167	SET REQUESTED EXIT AST (M+)
	DIC			; 169	GET/PUT SYSTEM INFO (M+)

	.PSECT	RSXCODE,NOWRT,SHR,PIC
	.REPT	128-<<.-DICBASE>/2>
	DIC
	.ENDR

	.PSECT	RSXCODE,NOWRT,SHR,PIC
DICEND:	BRB	HOOK		; LET USER HOOK DISPATCH IT

;
;	DISPATCH VMS ELEPHANT DIRECTIVE (A SINGLE RSX11-M DIRECTIVE
;	USED ONLY ON VMS).
;
RSX$ELEP::
	CASE	(R5),<-		; DISPATCH ON MODE WORD
		RSX$PARS,-	; 0 = NORMAL MODE PARSE
		RSX$PARS,-	; 1 = DEVICE MODE PARSE
		RSX$PARS,-	; 2 = FNB MODE PARSE
		RSX$PARS,-	; 3 = RMS-11 MODE PARSE
		RSX$NATV,-	; 4 = NATIVE MODE EXECUTION DIRECTIVE
		RSX$GEOM,-	; 5 = RETURN DISK GEOMETRY DIRECTIVE
		RSX$CHAN>	; 6 = BASIC CHAIN DIRECTIVE
;
;	EXECUTE USER HOOK TO EXECUTE UNKNOWN DIRECTIVE CODE
;
HOOK:
	JMP	RSX$UNKNOWN	; SEE IF USER HOOK CAN HANDLE IT
;	$DSW	#IE.SDP		; ILLEGAL DIRECTIVE TYPE

	.SBTTL	RESERVED INSTRUCTIONS
;++
; RSX$RESERVED - PROCESS COMPATIBILITY MODE RESERVED INSTRUCTIONS
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED FROM THE FLOATING POINT EMULATION ROUTINE
; WHEN A NON-FLOATING INSTRUCTION CAUSED THE TRAP.
;
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	CONTROL IS PASSED TO THE COMMON TRAP ROUTINES
;
;	R4 = 0
;	R10 = ADDRESS OF THE INAGE IMPURE DATA AREA
;	R11 = ADDRESS OF THE IMAGE
;--
RSX$RESERVED::
	MOVL	G^SYS$GL_CMCNTX,R10	; ADDRESS IMAGE IMPURE AREA
	CLRL	R11			; ADDRESS IMAGE
	CLRL	R0			; SET TRAP TYPE

	.SBTTL	ILLEGAL AND TRAP INSTRUCTIONS
;++
; ILLEGAL/RSX$TRAP - ILLEGAL AND TRAP INSTRUCTION HANDLER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE PROCESSES NON EMT-377 TRAPS. IF THE IMAGE HAS ENABLED
; THE APPROPRIATE SST VECTOR SERVICE THEN THE TRAP IS REFLECTED TO HIM.
; OTHERWISE THE IMAGE EXECUTION IS ABORTED WITH A PRINT OUT.
;
; INPUTS:
;
;	R0 = TRAP TYPE
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA AREA
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	THE IMAGE IS ABORTED VIA RSX$ABORT
;	
;	R0 = ABORT REASON
;
;	THE IMAGE IS ENTERED IN A SST
;
;	THE NEW PC/PSL AREA SET UP IN I_PC/I_PS AND THE IMAGE STACK
;	IS CHENGED TO REFLECT THE CONDITION.
;--
ILLEGAL:				; ENTRY FOR ILLEGAL INSTRUCTIONS
	SUBL	#2,I_PC(R10)		; ADJUST PC FOR REI
RSX$TRAP::				; ENTRY FOR TRAPPING INSTRUCTIONS
;
; GET OFFSET INTO SST VECTOR BASED ON EXCEPTION TYPE CODE
;
	MOVZBL	W^RSX$B_SST[R0],R1	; GET OFFSET INTO SST VECTOR
;
; FIND SST VECTOR
;
	MOVZWL	I_DEBVECL(R10),R3	; GET SIZE OF VECTOR
	BEQL	30$			; IF EQL THEN NONE
	MOVZWL	I_DEBVEC(R10),R2	; GET VECTOR ADDRESS
	BEQL	30$			; IF EQL THEN TRY TASK
	CMPB	R1,R3			; VECTOR LONG ENOUGH?
	BGTRU	30$			; IF GTR THEN NO
	MOVZWL	(R2)[R1],R2		; GET ADDRESS OF HIS ROUTINE
	BNEQ	50$			; IF NEQ THEN TRY IT
30$:	MOVZWL	I_SSTVECL(R10),R3	; GET SIZE OF SECONDARY VECTOR
	BEQL	40$			; IF EQL THEN NONE
	MOVZWL	I_SSTVEC(R10),R2	; TRY TASK VECTOR
	BEQL	40$			; IF EQL THEN NONE - ABORT
	CMPB	R1,R3			; VECTOR LONG ENOUGH?
	BGTRU	40$			; IF GTR THEN NO
	MOVZWL	(R2)[R1],R2		; GET ADDRESS OF HIS ROUTINE
	BNEQ	50$			; IF NEQ THEN TRY IT
;
; ABORT IMAGE BECAUSE OF UNFIELDED SST
;
40$:	ASHL	#3,R0,R0		; BUILD RSX STYLE ERROR CODE
	BISW	#^X08004,R0		; INSERT AND MERGE BITS
	INSV	#RSX$C_SUBSYSTEM,#16,#16,R0;
	BRW	RSX$ABORT		; ABORT EXECUTION
;
; PUT IMAGE IN SST ROUTINE
;
;
; PUSH SST PARAMETERS ON HIS STACK
;
50$:	IFNOWRT	#8,-8(R6),40$		; IF NO WRITE THEN NO SST
	CMPB	R0,#<<RSX$_ACCVIO&^X0F8>@-3>; MEMORY PROBLEM?
	BNEQ	60$			; IF NEQ THEN NO
;
; MEMORY PROTECT PROBLEM
;
	BICW3	#^X0FFE0,I_PS(R10),-(R6); PUT PSW ON STACK
	MOVW	I_PC(R10),-(R6)		; PUT PC ON STACK AND ZERO WORD
	CLRL	-(R6)			; ZERO TWO MORE WORDS
	CLRW	-(R6)			; AND A THIRD
	BRB	80$			; CONTINUE IN COMMON
;
; NON MEMORY VIOLATION SST
;
60$:	CMPB	R0,#<<RSX$_NONRSXEMT&^X0F8>@-3>; EMT?
	BEQL	70$			; IF EQL THEN YES
	CMPB	R0,#<<RSX$_TRAP&^X0F8>@-3>; TRAP?
	BNEQ	75$			; IF NEQ THEN NO
70$:	BICW3	#^X0FFE0,I_PS(R10),-(R6); INSERT PSW
	MOVL	I_PC(R10),R7		; GET THE PC
	MOVW	R7,-(R6)		; INSERT IT ON STACK
	MOVZBW	-2(R7),-(R6)		; PUT LOW BYTE OF TRAP ON STACK
	MULW	#2,(R6)			; LOW ORDER TIMES TWO
	BRB	80$			; CONTINUE IN COMMON
75$:	BICW3	#^X0FFE0,I_PS(R10),-(R6); INSERT PSW
	MOVW	I_PC(R10),-(R6)		; INSERT PC
80$:	MOVL	R2,I_PC(R10)		; SET SECOND RETURN ADDRESS
	CLRW	I_PS(R10)		; SET CONDITIONS AND T-BIT FOR SST

	.SBTTL	RSX$RESTORE -- RESTORE IMAGE CONTEXT AND ENTER IMAGE
;++
; RSX$RESTORE - RESTORE IMAGE REGISTERS AND ENTER IMAGE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED AFTER A TRAP OR DIRECTIVE. ANY PENDING AST'S
; ARE DETECTED AND THE IMAGE EXECUTION IS DIVERTED TO THE AST IF POSSIBLE.
; THIS ROUTINE CAN BE INTERRUPTED BY AN AST. IT IS NECESSARY TO SET AN 
; INTERLOCK TO SIGNAL THE AST LOGIC TO ALWAYS RETURN AT RSX$RESTORE IF
; AN AST OCCURED DURING THE RESTORE.
;
; INPUTS:
;
;	R6 = ADDRESS OF THE IMAGE STACK
;	R10 = ADDRESS OF THE IMAGE DATA BASE
;	R11 = ADDRESS OF THE IMAGE HEADER
;
; OUTPUTS:
;
;	NONE
;--
RSX$RESTORE::				; RESTORE REGISTERS
	SUBL	#8,SP			; ALLOCATE DATA SPACE ON STACK
RSX$RESTORE_CON::			; CONTINUE RESTORE
	MOVL	G^SYS$GL_CMCNTX,R10	; ADDRESS IMAGE IMPURE AREA
	BISW	#1@SV_RESTORE,I_STATE(R10); SET INTERLOCK
	MOVQ	I_PC(R10),(SP)		; SET PC/PSL FOR REI
;
; CHECK TO SEE IF AN AST WAS QUEUED WHILE THE PROCESSOR WAS IN NATIVE MODE
;
	BBCC	#SV_PENDWAIT,I_STATE(R10),15$; BR IF AST NOT POSTED WHILE IN NATIVE
	MOVQ	(SP),R7			; SET UP FOR SUBROUTINE CALL
	BSBW	RSX$RETURNAST		; GET AST CONTEXT IF ANY
	MOVQ	R7,(SP)			; RESTORE PC/PSL
;
; MAKE A LOG ENTRY
;
15$:	MOVL	SP,R1			; ADDRESS OF PC/PSL
	BSBW	RSX$LOG			; MAKE A LOG ENTRY
;
; RESTORE REGISTERS
;
	MOVQ	(R10)+,R0		; RESTORE R0,R1
	MOVQ	(R10)+,R2		; RESTORE R2,R3
	MOVQ	(R10),R4		; RESTORE R4,R5
	BBC	#PSL_TBIT,4(SP),20$	; IF TBIT SET THEN SET TPENDING
	BISB	#<1@30>@-24,7(SP)	; SET TPENDING
;
; CLEAR RESTORE IN PROGRESS FLAG
;
; NOTE THAT A WINDOW EXISTS BETWEEN THIS INSTRUCTION AND THE REI SO
; THE AST LOGIC THAT CHECKS FOR RESTORE IN PROGRESS, CHECKS BOTH THE
; SV_RESTORE BIT AND PC = RSX$REI.
;
20$:	BICW	#1@SV_RESTORE,I_STATE-I_R4(R10); CLEAR INTERLOCK
RSX$REI::				; PC OF REI INSTRUCTION
	REI				;

	.SBTTL	RSX$START_LOG - ENABLE ACTION LOGGING
;---
;
;	THIS ROUTINE ENABLES ACTION LOGGING FOR DEBUGGING
;	OF REAL TIME EVENTS.  IT ALLOCATES DYNAMIC STORAGE
;	FOR THE LOG BUFFER.  EACH LOG ENTRY IS EXACTLY 16
;	BYTES (4 LONGWORDS) IN VARIABLE FORMAT DEPENDING ON
;	THE TYPE (LONGWORD 0).  THE BUFFER IS OF THE FOLLOWING
;	FORMAT:
;		WORD 0: LENGTH OF ENTIRE BUFFER
;		WORD 1: OFFSET TO NEXT AVAILABLE ENTRY
;		WORDS 2-7: UNUSED
;		<BUFFER SPACE FOLLOWS>
;
; INPUTS:
;
;	R1 = # BYTES TO BE USED FOR LOG ENTRIES
;
; OUTPUTS:
;
;	NONE
;---

RSX$START_LOG::
	CMPL	R1,#16			; MUST BE AT LEAST 1 ENTRY WORTH
	BLSS	90$			; BRANCH IF NOT
	ADDL	#16,R1			; ADD BUFFER OVERHEAD
	BSBW	RSX$ALLOCATE		; ALLOCATE LOG BUFFER
	MOVL	R0,I_LOGBUF(R10)	; SAVE ADDRESS OF BUFFER
	MOVW	R1,(R0)			; SET LENGTH IN BUFFER
	MOVW	#16,2(R0)		; SET STARTING OFFSET
	BBSS	#SV_LOG,I_STATE(R10),90$ ; ENABLE ACTION LOGGING
90$:	RSB

	.SBTTL	RSX$LOG - MAKE AN ACTION LOG ENTRY
;---
;
;	THIS ROUTINE ADDS A LOG ENTRY INTO THE CURRENT ACTION
;	LOG IF ACTION LOGGING IS ENABLED.
;
; INPUTS:
;
;	R10 = ADDRESS OF CONTEXT AREA
;	R1 = ADDRESS OF 12 BYTE LOG ENTRY
;
; OUTPUTS:
;
;	NONE
;---

RSX$LOG::
	BBC	#SV_LOG,I_STATE(R10),90$ ; SKIP IF LOGGING DISABLED
	PUSHR	#^M<R0,R1,R2,R3>	; SAVE REGISTERS
	MOVL	I_LOGBUF(R10),R2	; ADDRESS THE LOGGING BUFFER
	MOVZWL	2(R2),R3		; SET NEXT AVAILABLE POSITION
	SUBW3	R3,(R2),R0		; SPACE REMAINING IN BUFFER
	CMPW	R0,#16			; ENOUGH FOR AN ENTRY?
	BGEQ	10$			; BRANCH IF SO
	MOVL	#16,R3			; WRAP TO BEGINNING OF BUFFER
10$:	ADDW3	#16,R3,2(R2)		; SET NEXT AVAILABLE POSITION
	MOVAB	(R2)[R3],R0		; PUT THE ENTRY HERE
	MOVL	16(SP),(R0)+		; SAVE ADDRESS OF CALLER
	MOVL	(R1)+,(R0)+		; STORE LOG ENTRY
	MOVQ	(R1)+,(R0)+
	POPR	#^M<R0,R1,R2,R3>	; RESTORE REGISTERS
90$:	RSB

	.SBTTL	RSX$STOP_LOG - DISABLE ACTION LOGGING
;---
;
;	DISABLE ACTION LOGGING
;
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	NONE
;---

RSX$STOP_LOG::
	BBCC	#SV_LOG,I_STATE(R10),90$ ; DISABLE ACTION LOGGING
90$:	RSB

	.END
