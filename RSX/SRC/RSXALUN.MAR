	.TITLE RSXALUN - RSX11M/AME ASSIGN LUN DIRECTIVE
	.IDENT	'V03-001'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:
;
; 	VAX/VMS RSX11M/AME.
;
; ABSTRACT:
;
;	RSX11M ASSIGN LUN DIRECTIVE.
;
; AUTHOR:
;
;	R.HEINEN 4-NOV-76
;
; PREVIOUSLY MODIFIED BY:
;
;	Tim Halvorsen
;	Peter H. Lipman
;
;
; MODIFIED BY:
;
;	V001	MSH025		Michael S. Harvey	16-Mar-82
;		Don't allow reassignment of a LUN assigned to an
;		attached device unless there is another LUN assigned
;		to that same device. Return IE.LNL if the reassign
;		cannot be made for this reason.
;
;--
;
; EXTERNAL SYMBOLS
;
	$RSXDEF			; DEFINE RSX SYMBOLS
	DRERR$			; DEFINE DIRECTIVE ERRORS
	$DEVDEF			; DEFINE DEVICE CHARACTERISTICS BITS
	$FABDEF			; DEFINE FAB
	$NAMDEF			; DEFINE NAM
	$RABDEF			; DEFINE RAB
	$DIBDEF			; Device info block ($GETDEV)

	.PSECT	RSXCODE,NOWRT,SHR,PIC

	.SBTTL RSX11M ALUN$ DIRECTIVE
;++
; RSX$ALUN - RSX ASSIGN LUN DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE HANDLES RSX11M "ALUN$" DIRECTIVES.
;
; THE FIRST ACTION IS TO VALIDATE THE DEVICE NAME, UNIT AND LUN.
; NEXT, THE PREVIOUS LUN ASSIGNMENT IS DEASSIGNED AND THE CURRENT I/O CANCELED.
;
; THE NEXT STEP IS TO BUILD AN ASCII DEVICE NAME IN THE RSX11M STYLE
; FROM THE DEVICE NAME AND UNIT PASSED IN. THIS STRING IS TRANSLATED AND
; IF NO TRANSLATION RESULTS, THE DEVICE AND UNIT ARE MADE INTO A VAX/VMS
; PHYSICAL DEVICE NAME AS FOLLOWS:
;
;	THE FIRST TWO CHARACTERS OF DEVICE NAME MAP DIRECTLY.
;
;	THE RSX UNIT IS DIVIDED BY 16 - THE QUOTIENT IS ADDED TO THE
;	CHARACTER "A" AND THE RESULTANT CHARACTER IS CONSIDERED AS
;	A CONTROLLER. THE REMAINDER IS CONSIDERED TO BE THE UNIT.
;
; IF A TRANSLATION RESLUTS, THE TRANSLATION IS DONE THREE TIMES AND THE
; EFFECTIVE RESULT IS USED AS THE SOURCE FOR AN ASSIGN CHANNEL. 
; AFTER EACH TRANSLATION, THE KNOWN AME LOGICAL DEVICE LIST IS SEARCHED TO
; DETECT ASSIGNMENTS TO TI/CL/CO.
;
; INPUTS:
;
;	R5 = ADDRESS OF THE DPB+2
;	R6 = ADDRESS OF THE IMAGE STACK
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	R6,R10,R11 ARE PRESERVED.
;
; DSW RETURN CODES:
;
;	IS.SUC	SUCCESSFUL
;	IE.ILU	ILLEGAL LUN NUMBER
;	IE.IDU	UNKNOWN DEVICE
;	IE.NOD	I/O CHANNEL QUOTA EXCEEDED -- SS$_NOIOCHAN
;	IE.RSU	DEVICE IS ALLOCATED TO ANOTHER PROCESS -- SS$_DEVALLOC
;	IE.DUN  DEVICE UNAVAILABLE
;	IE.LNL	ATTEMPT WAS MADE TO REASSIGN A LUN AWAY FROM AN
;		ATTACHED DEVICE WHILE THERE WERE NO OTHER LUNS
;		ASSIGNED TO THAT DEVICE
;--
RSX$ALUN::				; ASSIGN LUN DIRECTIVE
	MOVZBL	(R5)+,R1		; GET SPECIFIED LUN NUMBER
	BEQL	5$			; IF EQL THEN ILLEGAL
	INCL	R5			; POINT TO DEVICENAME
	CMPB	R1,I_NLUN(R10)		; IN RANGE WITH HEADER DATA?
	BLEQU	10$			; IF GTRU THEN NO
;
; ILLEGAL LUN NUMBER
;
5$:	$DSW	#IE.ILU			; SET STATUS AND RETURN
;
; VALID DEVICE UNIT PAIR?
;
10$:	TSTW	(R5)			; NO ZERO DEVICE NAMES
	BEQL	12$			; IF NEQ THEN TRY IT
	CMPW	#-1,(R5)		; SPECIAL TEST FOR MINUS ONE
	BEQL	12$			; IF EQL THEN ILLEGAL HERE
	TSTB	3(R5)			; UNIT NUMBER FIT IN A BYTE?
	BEQL	15$			; IF EQL THEN YES
;
; INVALID DEVICE/UNIT SPECIFIED
;
12$:	$DSW	#IE.IDU			; SET UNKNOWN DEVICE
;
; LUN PREVIOUSLY ASSIGNED?
;
15$:	MOVL	@I_LUT(R10)[R1],R8	; GET LUT ENTRY ADDRESS
	BEQL	50$			; IF EQL THEN NOT ASSIGNED YET
	CMPW	(R5),LUT_INFONAME(R8)	; SAME NAME?
	BNEQ	20$			; IF NEQ THEN NO
	CMPW	2(R5),LUT_INFOUNIT(R8)	; SAME UNIT?
	BNEQ	25$			; IF NEQ THEN NO
;
; THE NEW DEVICE NAME AND UNIT MATCH THOSE IN THE LUT CURRENTLY ASSIGNED
; TO THIS LUN.  THE NEW DEVICE NAME AND UNIT ARE THUS PHYSICAL AND
; THEREFORE THE NEW DEVICE IS NOT A ROOTED DEVICE.  IF THIS LUN IS
; CURRENTLY ASSIGNED TO A ROOTED DEVICE, TREAT IT AS A DIFFERENT DEVICE.
;
	TSTW	LUT_ROOT_DEVNAM(R8)	; ROOTED DEVICE ASSIGNED?
	BNEQ	25$			; BRANCH IF YES, TREAT AS DIFFERENT DEV
	RSB
20$:	TSTW	2(R5)			; NO UNIT?
	BNEQ	25$			; IF NEQ THEN NO
	CMPW	(R5),LUT_RSXNAME(R8)	; SAME NAME
	BNEQ	25$			; IF NEQ THEN NO
	RSB
;
; IF DEVICE IS ATTACHED, DON'T REASSIGN UNLESS ANOTHER LUN IS ASSIGNED
; TO THE SAME DEVICE.
;
25$:	BBC	#LUTV_ATTACHED,LUT_FLAGS(R8),30$ ; LUN ATTACHED BY TASK?
	MOVZBL	I_NLUN(R10),R0		; YES, POINT TO LAST LUT
26$:	CMPL	R0,R1			; SAME LUN?
	BEQL	27$			; IF EQL YES, SKIP IT
	CMPL	@I_LUT(R10)[R0],R8	; ASSIGNED TO SAME DEVICE?
	BEQL	30$			; IF EQL YES, REASSIGN OK
27$:	SOBGTR	R0,26$			; CHECK NEXT LUN
	$DSW	#IE.LNL			; LUN LOCKED BY ATTACH
;
; EXISTING ENTRY - DEASSIGN
;
30$:	CLRL	@I_LUT(R10)[R1]		; DEASSIGN LUN
	DECW	LUT_REF(R8)		; ADJUST REFERENCE COUNT
	BNEQ	50$			; IF NEQ THEN STILL IN USE
	REMQUE	(R8),R0			; REMOVE FROM LIST
;
; DEASSIGN PREVIOUS CHANNEL
;
	TSTB	LUT_TYPE(R8)		; IF RMS TYPE THEN DO NOT DEASSIGN
	BEQL	35$			; IF EQL THEN RMS CONTROLLED
	$DASSGN_S LUT_CHAN(R8)		; DEASSIGN THE CHANNEL
	BRB	55$			; CONTINUE
;
; CLOSE PREVIOUS FILE
;
35$:	MOVW	LUT_CHAN(R8),W^RSX$G_FAB+FAB$W_IFI
	$CLOSE	FAB=W^RSX$G_FAB
	BRB	55$			; CONTINUE
;
; ALLOCATE NEW LUT ENTRY BLOCK
;
50$:	MOVZBL	#LUT_SIZE,R1		; GET SIZE OF LUT ENTRY
	BSBW	RSX$ALLOCATE		; ALLOCATE TABLE ENTRY
	MOVL	R0,R8			; ADDRESS IT
55$:	PUSHR	#^M<R5>			; SAVE REGISTERS
	MOVC5	#0,(R8),#0,#LUT_SIZE,(R8); ZERO BLOCK
	POPR	#^M<R5>			; RESTORE REGISTERS
	MNEGW	#1,LUT_RSXNAME(R8)	; SET NO NAME FOR RSX MATCH
;
;	LOOKUP SPECIFIED DEVICE NAME AND UNIT
;
	.ENABL	LSB

	PUSHL	R6			; SAVE R6
	MOVZWL	(R5),R0			; GET DEVICE NAME
	MOVZBL	2(R5),R1		; GET UNIT
	BSBW	RSX$SRCHDEV_BIN		; LOOK FOR BINARY KNOWN DEVICE
	BEQL	100$			; IE EQL THEN FOUND
;
; THE SPECIFIED DEVICE IS UNKNOWN 
;
	MOVAB	I_SCRATCH+16(R10),R3	; ADDRESS PLACE FOR TARGET
	MOVL	R3,I_SCRATCH(R10)	; SET UP DESC
	MOVL	R3,I_SCRATCH+4(R10)	;
	BSBW	RSX$BLDASCDEV		; BUILD ASCII DEVICE NAME
	SUBL3	I_SCRATCH(R10),R3,I_SCRATCH(R10); CALC SIZE
	BSBW	400$			; TRANSLATE THE NAME ONCE - SAVE OLD
	BEQL	140$			; IF EQL THEN PPF FOUND
	BLBC	R0,65$			; IF LOW CLEAR THEN MAKE PHYSICAL
	CMPW	R0,#SS$_NOTRAN		; ANY TRANSLATION?
	BNEQ	70$			; IF YES THEN TRANSLATE AGAIN
;
; MAP DEVICE TO PHYSICAL DEVICE NAME DDCU:
;
65$:	MOVZWL	(R5),R0			; GET NAME
	MOVZBL	2(R5),R1		; GET UNIT
	MOVL	I_SCRATCH+4(R10),R3	; ADDRESS TARGET
	MOVL	R3,I_SCRATCH(R10)	; SET UP DESC
	BSBW	RSX$BLDPHYDEV		; BUILD PHYSICAL DEVICE
	SUBL3	I_SCRATCH(R10),R3,I_SCRATCH(R10);
70$:	MOVZBL	#4,R9			; SET TRANSLATE LOOP COUNT
75$:	BSBW	RSX$SRCHDEV_ASC		; SEARCH THE ASCII LIST
	BEQL	100$			; IF EQL THE FOUND
80$:	BSBW	400$			; TRANSLATE  AGAIN
	BEQL	140$			; IF EQL THEN PPF FOUND
	BLBC	R0,85$			; IF LOW CLEAR THEN DONE
	CMPW	R0,#SS$_NOTRAN		; NO TRANSLATION?
	BEQL	85$			; IF EQL THEN DONE
	SOBGTR	R9,75$			; CONTINUE UNTIL DONE
85$:	BRW	ASSIGN			; ASSIGN THE DEVICE
90$:	MOVL	#4,R9			; CONTINUE TRANSLATION
	BRB	80$			;
;
; PPF FOUND - R0 = STATUS FROM $TRNLOG
;
140$:	MOVL	R8,R6			; SET UP NEW LUT
	BRB	160$			; CONTINUE
;
; KNOWN DEVICE
;
100$:	MOVQ	LUT_REALNAME(R6),LUT_REALNAME(R8); COPY NAME
	MOVQ	LUT_REALNAME+8(R6),LUT_REALNAME+8(R8); TO NEW LUT
	MOVAB	LUT_REALNAME+1(R6),I_SCRATCH+4(R10); SET UP NAME DESC
	MOVZBL	LUT_REALNAME(R6),I_SCRATCH(R10);
	BBC	#LUTV_PRM,LUT_FLAGS(R6),90$; BR IF NOT PROCESS PERM
	MOVL	R8,R0			; DEALLOCATE NEW LUT
	MOVZBL	#LUT_SIZE,R1		;
	BSBW	RSX$DEALLOCATE		;
110$:	TSTW	LUT_CHAN(R6)		; ALREADY ASSIGNED?
	BEQL	150$			; IF EQL THEN NO
	BRW	MERGE			; CONTINUE WITH KNOWN DEVICE

	.SBTTL	RSX$SYS_DEVS - ASSIGN SYSTEM DEVICE
;++
; RSX$SYS_DEVS - ASSIGN SYSTEM DEVICE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS THE ENTRY POINT TO THE ASSIGN LOGIC USED TO ASSIGN THE SYS$XXX
; DEVICES AT STARTUP TIME.
;
; INPUTS:
;
;	R6 = ADDRESS OF THE SYSTEM DEVICE LUT
;
; OUTPUTS:
;
;	THE LUT IS ASSIGNED AND INSERTED INTO THE LUT TABLE
;--
RSX$SYS_DEVS::				; ENTRY
	MOVAB	LUT_REALNAME+1(R6),I_SCRATCH+4(R10); SET UP NAME DESC
	MOVZBL	LUT_REALNAME(R6),I_SCRATCH(R10);
;
;	TRANSLATE THE STRING AS MANY TIMES AS NECESSARY
;
150$:	BSBW	500$			; LOOK FOR ESCAPE STRING -- MAKE SURE
	BNEQ	170$			; BRANCH IF NOT PPF
;
;	REMOVE PPF ESCAPE SEQUENCE FROM STRING
;
160$:	ADDL	#4,I_SCRATCH+4(R10)	; SET UP DESC TO NAME
	SUBL	#4,I_SCRATCH(R10)	; 
	BGEQ	170$			; BRANCH IF NOT GARBAGE LOGICAL NAME
	CLRL	I_SCRATCH(R10)		; CONTINUE WITH EMPTY STRING
170$:	BLBC	R0,180$			; IF LOW CLEAR THEN DONE
	CMPW	#SS$_NOTRAN,R0		; NO TRANSLATION?
	BNEQ	150$			; IF NO THEN CONTINUE
;
; ISOLATE DEVICE NAME IN STRING, ALL LEADING UNDERSCORES ARE GONE
;
180$:	LOCC	#^A/:/,I_SCRATCH(R10),@I_SCRATCH+4(R10); DELIMIT STRING
	SUBL	R0,I_SCRATCH(R10)	;
;
;	GET DEVICE CHARACTERISTICS
;
	MOVZBL	#50,I_SCRATCH+8(R10)	; GET CHARACTERISTICS AND UNIT
	SUBL	#50,SP			; ALLOCATE AREA ON STACK
	MOVL	SP,R4			; COPY ADDRESS
	MOVL	R4,I_SCRATCH+12(R10)
	$GETDEV_S I_SCRATCH(R10),,I_SCRATCH+8(R10)
	BLBC	R0,190$			; BR IF NOT FOUND
	MOVQ	(R4),LUT_CHAR(R6)	; COPY CHARACTERISTICS
	MOVL	8(R4),LUT_CHAR+8(R6)	;
	MOVW	12(R4),LUT_INFOUNIT(R6)	; COPY BASE UNIT
	MOVZWL	14(R4),R1		; ADDRESS NAME STRING
	MOVAB	(R4)[R1],R1		; 
	MOVZBL	(R1),R4			; GET SIZE
	SUBB3	#^A/A/,(R1)[R4],R4	; GET CONTROLLER INDEX
	MULL	#16,R4			;
	ADDW	R4,LUT_INFOUNIT(R6)	;
190$:	ADDL	#50,SP			;
	BLBC	R0,200$			; IF GETCHN ERROR, THEN USE RMS
;
;	IF TERMINAL DEVICE, ASSIGN THE CHANNEL.  OTHERWISE, USE RMS.
;
	BBC	#DEV$V_TRM,LUT_CHAR(R6),200$; IF NOT TERMINAL THEN RMS
	$ASSIGN_S	I_SCRATCH(R10),LUT_CHAN(R6); ASSIGN CHANNEL
	BLBC	R0,195$			; IF LOW CLEAR THEN ERROR
	MOVQ	I_SCRATCH(R10),R0	; GET DEVICE NAME DESCRIPTOR
	MOVB	R0,LUT_REALNAME(R6)	; SET LENGTH OF STRING
	PUSHL	R5			; SAVE DPB ADDRESS
	MOVC	R0,(R1),LUT_REALNAME+1(R6) ; UPDATE ACTUAL DEVICE NAME
	MOVB	#^A':',(R3)		; RSX$PARS ASSUMES ':' AFTER IT
					; BUT NOT REFLECTED IN LENGTH
	POPL	R5			; RESTORE DPB ADDRESS
	MOVB	#LUTC_TRM,LUT_TYPE(R6)	; SET TERMINAL TYPE
	BRW	210$			; MERGE WITH OTHER ASSIGN LOGIC
195$:	BRW	300$			; ASSIGN ERROR
;
;	RMS MUST BE USED FOR ACCESS TO THIS DEVICE
;
200$:	MOVAB	W^RSX$G_FAB,R8		; ADDRESS RSX GENERAL FAB
	PUSHL	R5			; SAVE DPB ADDRESS
	MOVC5	#0,(R8),#0,#FAB$C_BLN,(R8); INITIALIZE THE FAB
	MOVC5	#0,(SP),#0,#RAB$C_BLN,W^RSX$G_RAB ; AND THE RAB TOO
	POPL	R5			; RESTORE DPB ADDRESS
	MOVB	#FAB$C_BLN,FAB$B_BLN(R8);
	MOVB	#FAB$C_BID,FAB$B_BID(R8);
	MOVAB	LUT_REALNAME+1(R6),FAB$L_FNA(R8);
	MOVB	LUT_REALNAME(R6),FAB$B_FNS(R8);
	MOVB	#FAB$M_GET!FAB$M_PUT,FAB$B_FAC(R8) ; ALLOW GET'S OR PUT'S
	MOVB	#FAB$M_PRN,FAB$B_RAT(R8)
	MOVB	#FAB$C_VFC,FAB$B_RFM(R8); INSERT RECORD FORMAT
	$CREATE	FAB=R8			; OPEN FILE
	CMPL	R0,#RMS$_RAT		; CHECK IF PRN NOT ALLOWED
	BNEQ	205$			; BRANCH IF NOT A PROBLEM
	MOVB	#FAB$M_CR,FAB$B_RAT(R8)	; SET CR INSTEAD
	MOVB	#FAB$C_VAR,FAB$B_RFM(R8)
	$CREATE	FAB=(R8)		; TRY AGAIN USING RAT=CR
205$:
	BLBC	R0,300$			; IF LOW CLEAR THEN DONE
	MOVW	FAB$W_IFI(R8),LUT_CHAN(R6); SAVE IFI VALUE AS CHANNEL
	MOVL	#DEV$M_REC!DEV$M_TRM!DEV$M_CCL,LUT_CHAR(R6)
	MOVL	#132@16,LUT_CHAR+4(R6)	;
	CLRL	LUT_CHAR+8(R6)		;
	MOVAB	W^RSX$G_RAB,R8		; ADDRESS RSX GENERAL RAB
	MOVB	#RAB$C_BLN,RAB$B_BLN(R8)  ; INITIALIZE THE RAB
	MOVB	#RAB$C_BID,RAB$B_BID(R8)
	MOVAB	W^RSX$G_FAB,RAB$L_FAB(R8)
	$CONNECT RAB=(R8)		; CONNECT RECORD STREAM
	BLBC	R0,300$			; BRANCH IF ERROR
	MOVW	RAB$W_ISI(R8),LUT_CHAN+2(R6) ; SAVE ISI FOR RECORD I/O
210$:	BISB	#1@LUTV_PRM,LUT_FLAGS(R6); SET PERMANENT FILE
	TSTW	LUT_INFONAME(R6)	; INFO NAME SET UP?
	BNEQ	220$			; IF NEQ THEN YES
	MOVW	#^A/$P/,LUT_INFONAME(R6); INSERT PROPER NAME
	MOVB	-2(R5),LUT_INFOUNIT(R6)	; USE LUN AS UNIT
	INSQUE	(R6),@I_LOGNAME+4(R10)	; INSERT ON LIST
220$:	BRW	MERGE			; CONTINUE IN COMMON
300$:	MOVL	R6,R8			; COPY FAULTY LUT ADDR
	BRW	ERROR			; CONTINUE IN ERROR PROCESSING

;
; TRANSLATE ASCII STRING SUBROUTINE
;
; INPUTS:
;	I_SCRATCH(R10) = STRING DESCRIPTOR
;	R5 = ADDRESS OF DEVNAM FIELD IN DPB
;	R8 = LUT ADDRESS
; OUTPUTS:
;	R0 = STATUS FROM $TRNLOG_S
;	Z SET IF PROCESS PERMANENT FILE
;	Z CLEAR IF NOT
;	R1-R4 DESTROYED, OTHERS PRESERVED
;
400$:	PUSHL	R5			; SAVE DPB ADDRESS
	MOVZBL	I_SCRATCH(R10),R0	; GET SIZE OF NAME
	MOVC5	R0,@I_SCRATCH+4(R10),#0,#15,LUT_REALNAME+1(R8); SAVE IT
	SUBB3	R0,I_SCRATCH(R10),LUT_REALNAME(R8); SAVE SIZE
	MOVC3	I_SCRATCH(R10),@I_SCRATCH+4(R10),I_SCRATCH+16(R10)
	MOVAB	I_SCRATCH+16(R10),I_SCRATCH+4(R10);
	BSBW	RSX$TRANS_LOGIC		; 
	POPR	#^M<R5>			; RECOVER DPB ADDRESS
	BLBC	R0,430$			; BRANCH IF ERROR FROM $TRNLOG
	ADDL3	I_SCRATCH(R10),I_SCRATCH+4(R10),R2; POINT TO END OF EQUIV STRING
	CMPW	#^A/.]/,-(R2)		; ROOTED DIRECTORY?
	BEQL	410$			; BRANCH IF YES
	CMPW	#^A/.>/,(R2)		; ALTERNATE BRACKET FORM?
	BNEQ	520$			; BRANCH IF NOT ROOTED
410$:
	ASSUME	LUT_ROOT_UNIT EQ LUT_ROOT_DEVNAM+2
	MOVL	(R5),LUT_ROOT_DEVNAM(R8); SAVE ROOT DEVICE AND UNIT
	MOVB	1(R2),(R2)		; OVERWRITE "." WITH CLOSE BRACKET
	PUSHR	#^M<R0,R2,R5>		;
	MOVAB	-<FAB$C_BLN+NAM$C_BLN>(SP),SP; ALLOCATE FAB AND NAM BLOCKS
	MOVC5	#0,(SP),#0,#FAB$C_BLN+NAM$C_BLN,(SP); ZERO FAB AND NAM BLOCKS
	MOVL	SP,R4			; ADDRESS OF FAB
	MOVAB	FAB$C_BLN(R4),R3	; ADDRESS OF NAM BLOCK

	ASSUME	FAB$B_BLN EQ FAB$B_BID+1
	ASSUME	NAM$B_BLN EQ NAM$B_BID+1
	MOVW	#<<FAB$C_BLN>*256+FAB$C_BID>,FAB$B_BID(R4); FAB ID AND LENGTH
	MOVW	#<<NAM$C_BLN>*256+NAM$C_BID>,NAM$B_BID(R3); NAM ID AND LENGTH
	MOVL	I_SCRATCH+4(R10),FAB$L_FNA(R4); ADDRESS OF STRING TO PARSE
	SUBB3	#1,I_SCRATCH(R10),FAB$B_FNS(R4); SIZE OF STRING
	MOVL	R3,FAB$L_NAM(R4)	; ADDRESS OF NAM BLOCK
	$PARSE	FAB=(R4)		; PARSE THE DEVICE AND ROOT DIRECTORY
	BLBC	R0,420$			; BRANCH IF PARSE ERROR
	MOVL	NAM$W_DID(R3),LUT_ROOT_DID(R8); RECORD ROOT DIRECTORY ID
	MOVW	NAM$W_DID+4(R3),LUT_ROOT_DID+4(R8); 
420$:	MOVAB	<FAB$C_BLN+NAM$C_BLN>(SP),SP; CLEAN OFF FAB AND NAM BLOCKS
	POPR	#^M<R0,R2,R5>		;
	MOVB	#^A/./,(R2)		; FIX UP DEVICE AND ROOT NAME
430$:	BRB	520$
;
; TRANSLATE ASCII STRING SUBROUTINE
;
; INPUTS:
;	I_SCRATCH(R10) = STRING DESCRIPTOR
; OUTPUTS:
;	R0 = STATUS FROM $TRNLOG_S
;	Z SET IF PROCESS PERMANENT FILE
;	Z CLEAR IF NOT
;	R1-R4 DESTROYED, OTHERS PRESERVED
;
500$:	PUSHR	#^M<R5>			; SAVE DPB ADDRESS
	MOVC3	I_SCRATCH(R10),@I_SCRATCH+4(R10),I_SCRATCH+16(R10)
	MOVAB	I_SCRATCH+16(R10),I_SCRATCH+4(R10);
	BSBW	RSX$TRANS_LOGIC		; 
	POPR	#^M<R5>			; RESTORE DPB ADDRESS
520$:	CMPB	#^X01B,@I_SCRATCH+4(R10); ESCAPE?
	RSB
 
	.DSABL	LSB

;
; ASSIGN LUN STEP FOUR *************************************************
;
; ASSIGN CHANNEL TO WHATEVER IS NOW IN SCRATCH AREA
;
ASSIGN:
	$ASSIGN_S	I_SCRATCH(R10),LUT_CHAN(R8); ASSIGN CHANNEL
	BLBC	R0,ERROR		; BR IF ERROR
	INSQUE	(R8),@I_LOGNAME+4(R10)	; INSERT ON END OF LIST
	MOVL	R8,R6			; COPY ADDRESS OF LUT
	BSBW	RSX$BUILDLUT		; FILL IN LUT
;
; ASSOCIATE EXISTING LUT ENTRY WITH NEW ASSIGNMENT
;
MERGE:					;
	MOVZBL	-2(R5),R1		; GET LUN INDEX
	BEQL	10$			; IF EQL THEN NO SET
	MOVL	R6,@I_LUT(R10)[R1]	; INSERT POINTER AS ASSIGNMENT
10$:	INCW	LUT_REF(R6)		; ADJUST REFERENCE COUNT
	POPL	R6			; RESTORE REGISTERS
	RSB				; RETURN
;
; MAP RETURN STATUS
;
ERROR:					;
	POPL	R6			; RESTORE REGISTERS
	MOVL	R0,R4			; SAVE STATUS VALUE
;
; DEALLOCATE THE BLOCK HELD FOR THE ASSIGN
;
	MOVL	R8,R0			; ADDRESS BLOCK
	BBS	#LUTV_PRM,LUT_FLAGS(R0),117$; NO DEALLOCATE IF PERMANENT
115$:	MOVZBL	#LUT_SIZE,R1		; SET UP SIZE
	BSBW	RSX$DEALLOCATE		; DEALLOCATE IT
;
; COMPLETE THE STATUS MAP
;
117$:	TSTW	-2(R5)			; ANY LUN?
	BEQL	150$			; IF EQL THEN NO ERROR
	BLBS	R4,150$			; BR IS SUCCESS
	CMPW	R4,#SS$_DEVALLOC	; DEVICE ALLOCATED TO OTHER USER?
	BNEQ	120$			; IF NEQ THEN YES
	$DSW	#IE.RSU			; SET RESOURCE NOT AVAILABLE
120$:	CMPW	R4,#SS$_DEVNOTMOUNT	; DEVICE NOT MOUNTED?
	BNEQ	130$			; IF NEQ THEN NO
	$DSWIO	#IE.DUN			; RETURN AS I/O TYPE ERROR
130$:	CMPW	R4,#SS$_NOIOCHAN	; NO CHANNEL AVAILBLE?
	BNEQ	140$			; IF NEQ THEN NO
	$DSWIO	#IE.NOD			; SET NO QUOTA FOR REQUEST
140$:	$DSW	#IE.IDU			; UNKNOWN ERROR IS UNKNOWN DEVICE
150$:	RSB				; RETURN

	.SBTTL	RSX$BUILDLUT - BUILD LUT ENTRY
;++
; RSX$BUILDLUT - BUILD LUT ENTRY
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED TO FILL IN THE REALNAME, INFONAME AND CHARACTERISTICS
; FIELDS OF THE LUT.
;
; INPUTS:
;
;	R8 = ADDRESS OF THE LUT
;
; OUTPUTS:
;
;	R8 = ADDRESS OF THE LUT
;
;	REGS R2-R9 ARE PRESERVED.
;--
RSX$BUILDLUT::				; BUILD THE LUT
	PUSHR	#^M<R2,R3,R4,R5,R6,R7,R8,R9>
	MOVAB	I_SCRATCH+8(R10),R9
	MOVL	R9,I_SCRATCH+4(R10)	; SET UP AREA FOR GET CHANNEL
	MOVZBL	#DIB$C_LENGTH,I_SCRATCH(R10)
	$GETCHN_S CHAN=LUT_CHAN(R8),PRIBUF=I_SCRATCH(R10)
	MOVQ	DIB$L_DEVCHAR(R9),LUT_CHAR(R8) ; INSERT CHARACTERISTICS
	MOVL	DIB$L_DEVDEPEND(R9),LUT_CHAR+8(R8)
	MOVL	DIB$L_MAXBLOCK(R9),LUT_MAXBLOCK(R8) ; MAXBLOCKS (DISKS ONLY)
	MOVZWL	DIB$W_DEVNAMOFF(R9),R0	; GET OFFSET TO NAME
	MOVAB	(R9)[R0],R5	; ADDRESS NAME
;
; BUILD INFORMATION NAME FIRST
;
	MOVW	1(R5),LUT_INFONAME(R8)	; INSERT FIRST 2 CHARS. OF REAL NAME
	MOVZBL	(R5),R3			; GET SIZE OF NAME
	CLRL	R0			; 
	CMPW	#2,R3			; NAME GREATER THAN 2 CHARS?
	BGEQU	10$			; IF LEQU THEN YES
	SUBB3	#^A/A/,(R5)[R3],R0	; GET CONTROLLER RELITIVE TO "A"
	MULL	#16,R0			; CONVERT TO CONTROLLER MAP
10$:	ADDW3	I_SCRATCH+8+12(R10),R0,LUT_INFOUNIT(R8); ADD IN UNIT AND STORE
;
; CONVERT REAL NAME TO ASCII STRING
;
	MOVAB	I_SCRATCH+100(R10),R9	; ADDRESS TEMP STORAGE AREA
	PUSHL	R9			;
	MOVZWL	I_SCRATCH+8+12(R10),R0	; GET REAL UNIT NUMBER
	CLRL	R1			; SET UP FOR QUAD WORD DIVIDE
20$:	EDIV	#10,R0,R0,R2		; GET REMAINDER FROM 8
	ADDB3	#48,R2,-(R9)		; INSERT IN STRING BACKWARDS
	TSTL	R0			; DONE?
	BNEQ	20$			; IF NEQ THEN NO
	MOVL	R9,R7			; COPY ADDRESS UNIT STRING START
	SUBL3	R9,(SP)+,R9		; CALC SIZE OF UNIT STRING
	INCL	R3			; ADJUST NAME SIZE TO INCLUDE COUNT
	MOVC3	R3,(R5),LUT_REALNAME(R8); COPY NAME AND SIZE
	ADDB	R9,LUT_REALNAME(R8)	; ADJUST NAME SIZE BY UNIT SIZE
	MOVC3	R9,(R7),(R3)		; COPY UNIT STRING
	MOVB	#^A/:/,(R3)		; INSERT COLON AT END
	MOVAB	W^RSX$A_DEVTYPE,R1	; ADDRESS LIST
	PUSHL	R1			; SAVE START OF LIST
30$:	CMPB	(R1),LUT_TYPE(R8)	; MATCH?
	BEQL	45$			; IF EQL THEN YES
	TSTB	(R1)+			; END OF LIST?
	BNEQ	30$			; IF NEQ THEN NO
;
; NOT FOUND GETS NON SPECIFIC TYPE
;
45$:	SUBL	(SP)+,R1		; FIND OFFSET
	ADDB3	#1,R1,LUT_TYPE(R8)	; PUT TYPE BACK
	POPR	#^M<R2,R3,R4,R5,R6,R7,R8,R9>
	RSB

	.SBTTL RSX$SRCHDEV - SEARCH LOGICAL NAME LIST FOR MATCH
;++
; RSX$SRCHDEV - SEARCH LOGICAL NAME LIST FOR MATCH
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED DURING ASSIGN AND PARSE TO FIND A DEVICE NAME
; IN THE LOGICAL ASSIGNMENT TABLE. A MATCH IS ATTEMPTED FOR EACH SAVED NAME.
;
; INPUTS:
;
;	R0 = NAME
;	R1 = UNIT
;	I_SCRATCH/I_SCRATCH+4 ARE THE STRING DESC FOR A STRING MATCH
;
; OUTPUTS:
;
;	CONDITION CODES REFLECT EQUALITY 
;
;	R6 = LUT ENTRY IF EQUALITY FOUND
;--
RSX$SRCHDEV_BIN::			; SEARCH FOR BINARY DEVICE
	MOVL	#1,I_SCRATCH(R10)	;
	MOVAB	I_SCRATCH(R10),I_SCRATCH+4(R10);
	BRB	RSX$SRCHDEV		; CONTINUE IN COMMON
RSX$SRCHDEV_ASC::			; SEARCH FOR ASCII DEVICE
	CLRQ	R0			; SET NO ARGS FOR BINARY SEARCH
RSX$SRCHDEV::				; SEARCH LOGICAL NAME LIST FOR MATCH
	PUSHR	#^M<R0,R1,R2,R3>	; SAVE CMPC REGISTERS
10$:	MOVAB	I_LOGNAME(R10),R6	; START AT LIST HEAD
15$:	MOVL	(R6),R6			; GET NEXT ENTRY
	CMPL	(R6),I_LOGNAME(R10)	; TEST DONE
	BEQL	45$			; IF EQL THEN DONE
	TSTW	4(SP)			; UNIT 0?
	BNEQ	20$			; IF NEQ THEN NO RSX NAME
	CMPW	(SP),LUT_RSXNAME(R6)	; RSX NAME MATCH?
	BEQL	50$			; IF EQL THEN MATCH
20$:	CMPW	#2,I_SCRATCH(R10)	; TWO CHARACTER NAME?
	BNEQ	25$			; IF NEQ THEN NO
	CMPW	@I_SCRATCH+4(R10),LUT_RSXNAME(R6); MATCH?
	BEQL	50$			; IF EQL THEN YES
	TSTW	LUT_INFOUNIT(R6)	; INFO UNIT 0?
	BNEQ	25$			; IF NEQ THEN NO
	CMPW	@I_SCRATCH+4(R10),LUT_INFONAME(R6); TWO CHARACTER MATCH?
	BEQL	50$			; IF EQL THEN YES
25$:	CMPW	4(SP),LUT_INFOUNIT(R6)	; INFO UNIT MATCH?
	BNEQ	30$			; IF EQL THEN DONE
	CMPW	(SP),LUT_INFONAME(R6)	; INFO NAME MATCH?
	BEQL	50$			; IF NEQ THEN NO
30$:	MOVZBL	LUT_REALNAME(R6),R0	; PICK UP SIZE OF STRING
	CMPL	I_SCRATCH(R10),R0	; CHECK SIZES
	BNEQ	15$			; IF NEQ THEN ERROR
	CMPC3	R0,@I_SCRATCH+4(R10),LUT_REALNAME+1(R6); STRING MATCH?
	BNEQ	15$			; IF NEQ THEN NOT DONE
	BRB	50$			; CONTINUE
45$:	TSTB	#2			; SET NEQ CONDITION
50$:	POPR	#^M<R0,R1,R2,R3>	; RESTORE CMPC REGISTERS
	RSB				; RETURN

	.SBTTL	RSX$TRANS_LOGIC - TRANSLATE LOGICAL NAME
;++
; RSX$TRANS_LOGIC - TRANSLATE LOGICAL NAME
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE TRANSLATES A LOGICAL NAME.  IF THE EQUIVALENCE STRING
;	RETURNED BY $TRNLOG BEGINS WITH "__" (HIDDEN DEVICE NAME) THEN
;	ONE "_" IS STRIPPED.
;
; INPUTS:
;
;	I_SCRATCH(R10) = INPUT NAME DESC
;
; OUTPUTS:
;
;	I_SCRATCH(R10) = OUTPUT DESC
;
; THE NAME IS PLACED IN I_SCRATCH+50
;--
RSX$TRANS_LOGIC::			; TRANSLATE LOGICAL NAME
	LOCC	#^A/:/,I_SCRATCH(R10),@I_SCRATCH+4(R10)
	SUBL	R0,I_SCRATCH(R10)	; ADJUST SIZE FOR :
	MOVQ	I_SCRATCH(R10),I_SCRATCH+8(R10)
	MOVAB	I_SCRATCH+160-64(R10),I_SCRATCH+4(R10)
	MOVZBL	#64,I_SCRATCH(R10)
	$TRNLOG_S	I_SCRATCH+8(R10),-
		I_SCRATCH(R10),I_SCRATCH(R10)
	BLBC	R0,20$			; BRANCH IF ERROR
	CMPL	I_SCRATCH(R10),#2	; POSSIBLY BEGIN WITH "__"?
	BLEQ	20$			; BRANCH IF TOO SMALL
	CMPW	#^A/__/,@I_SCRATCH+4(R10) ; "__" ON THE FRONT?
	BNEQ	20$			; BRANCH IF NOT
	INCL	I_SCRATCH+4(R10)	; YES, DROP THE FIRST ONE
	DECL	I_SCRATCH(R10)		; ADJUST THE COUNT
20$:	RSB
;
	.END
