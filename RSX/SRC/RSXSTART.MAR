	.TITLE	RSXSTART - RSX INITIALIZATION, LOAD AND GO ROUTINE
	.IDENT	'V03-001'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:
;
;	VAX/VMS RSX-11M AME
;
; ABSTRACT:
;
;	RSX INITIALIZATION, LOADER AND IMAGE INITAILIZATION.
;
; AUTHOR:
;
; 	 R. HEINEN 2-NOV-76 
;
; PREVIOUSLY MODIFIED BY:
;
;	Tim Halvorsen
;	Peter C. George
;	Michael S. Harvey
;
; MODIFIED BY:
;
;	V001	MSH026		Michael S. Harvey	23-Mar-82
;		Eliminate dependencies on VMS Executive symbols.
;
;--

;
; DEFINITIONS
;
	$RSXDEF				; DEFINE RSX SYMBOLS
	LBLDF$				; DEFINE RSX LABEL
	$FABDEF				; FAB BLOCK DEFINITIONS
	$RABDEF				; RAB BLOCK DEFINITIONS
	$NAMDEF				; NAM BLOCK DEFINITIONS
	$IFDDEF				; IMAGE FILE DESCRIPTOR
	$ISDDEF				; IMAGE SECTION DESCRIPTOR
	$JPIDEF				; DEFINE JOP/PROCESS SYMBOLS
	$SECDEF				; DEFINE SECTION VALUES
	$STSDEF				; DEFINE FIELDS OF MESSAGE CODE
;
; LOCAL SYMBOLS
;
; OFFSETS ON AP FOR CALL ARGS
;
	IMAGECHAN=4			; CHANNEL ON WHICH IMAGE FILE IS OPEN
	CMDROUT=8			; CALL BACK FOR COMMAND LISE
	CMDFLG=12			; COMMAND INTERPRETER FLAGS
	CONTEXT=16			; FAB$L_CTX FROM FILE OPEN
;
; LOCAL STORAGE
;
	.PSECT	RSXPURE,LONG,EXE,NOWRT,SHR,PIC

COMMONEFN:
		.ASCIC	/RSXCOMEFN/
BINARY_HEX_TAB:	.ASCII	/0123456789ABCDEF/
	.WORD	0
ALUN_LUN:				; REFERS TO PRECEEDING WORD

	.SBTTL RSX-11M EMULATOR TRANSFER VECTORS

	.PSECT	$RSXVECTOR,NOEXE,NOWRT,SHR,NOPIC,LONG
;
; TRANSFER VECTORS FOR ENTRY POINTS INTO THE SHARED IMAGE
;
VEC_START:

	.TRANSFER RSX$RUNIMAGE		; RUN IMAGE GIVEN CHANNEL
	.MASK	RSX$RUNIMAGE
	JMP	RSX$RUNIMAGE+2

	.TRANSFER RSX$ACTIVATE		; RUN IMAGE GIVEN FILE NAME
	.MASK	RSX$ACTIVATE
	JMP	RSX$ACTIVATE+2

	.TRANSFER RSX$ALLOCATE		; ALLOCATE DYNAMIC MEMORY
	JMP	RSX$ALLOCATE

	.TRANSFER RSX$DEALLOCATE	; DEALLOCATE DYNAMIC MEMORY
	JMP	RSX$DEALLOCATE

	.TRANSFER RSX$PARSEDEV		; PARSE DEVICE INTO NAME AND UNIT
	JMP	RSX$PARSEDEV

	.TRANSFER RSX$BLDPHYDEV		; BUILD PHYSICAL DEVICE NAME
	JMP	RSX$BLDPHYDEV

;
; RESERVED VECTOR SPACE
;
	.=VEC_START+128

	.PSECT	RSXCODE,NOWRT,SHR,PIC

	.SBTTL	RSX$ACTIVATE - ACTIVATE IMAGE BY IMAGE NAME
;---
;
;	THIS ROUTINE IS CALLED TO BEGIN EXECUTION OF A COMPATABILTY
;	MODE IMAGE GIVEN THE SPECIFIED IMAGE FILE NAME.
;
; INPUTS:
;
;	0(AP)  = NUMBER OF ARGUMENTS (5)
;	4(AP)  = LENGTH OF IMAGE FILE NAME
;	8(AP)  = ADDRESS OF IMAGE FILE NAME
;	12(AP) = ADDRESS OF CLI CALL-BACK ROUTINE
;	16(AP) = TYPE OF CLI (1=DCL, 0=MCR)
;	20(AP) = AP FROM CLI
;
; OUTPUTS:
;
;	IMAGE HAS BEEN EXECUTED.
;
;---
	.ENTRY	RSX$ACTIVATE,-
		^M<R6,R7,R8,R9>
	
	MOVAB	W^RSX$G_FAB,R6		; ADDRESS THE FAB BLOCK
	MOVAB	W^RSX$G_NAM,R7		; ADDRESS THE NAM BLOCK
	MOVQ	4(AP),R8		; GET DESCRIPTOR OF FILE NAME
	MOVB	R8,FAB$B_FNS(R6)	; SET LENGTH OF FILE NAME
	MOVL	R9,FAB$L_FNA(R6)	; SET ADDRESS OF FILE NAME
	MOVAB	W^RSX$T_SYSDEF,R0	; ADDRESS DEFAULT NAME
	MOVB	(R0)+,FAB$B_DNS(R6)	; SET DEFAULT NAME STRING
	MOVL	R0,FAB$L_DNA(R6)
	LOCC	#^A'[',R8,(R9)		; DIRECTORY?
	BNEQ	10$			; BRANCH IF DIRECTORY SPECIFIED
	LOCC	#^A'<',R8,(R9)		; ALTERNATE SYNTAX
	BEQL	20$
10$:	MOVAB	W^RSX$T_USERDEF,R0	; ADDRESS USER DEFAULT NAME
	MOVB	(R0)+,FAB$B_DNS(R6)	; CHANGE DEFAULT NAME STRING
	MOVL	R0,FAB$L_DNA(R6)
20$:	MOVL	#FAB$M_KFO!FAB$M_UFO,FAB$L_FOP(R6)
	MOVL	#FAB$M_SHRGET,FAB$B_SHR(R6)
	MOVL	R7,FAB$L_NAM(R6)	; SET ADDRESS OF NAM BLOCK
	CLRL	FAB$L_CTX(R6)		; ZERO CONTEXT FIELD
	CLRB	NAM$B_ESL(R7)		; SET NO EXPANDED NAME
	$OPEN	FAB=(R6)		; OPEN THE FILE
	BLBS	R0,30$			; IF LBS THEN SUCCESS
	PUSHL	R0			; SAVE ERROR STATUS
;
; PRINT MESSAGES INDICATING HOW RMS FAILED TO OPEN FILE
;
	PUSHL	NAM$L_ESA(R7)		; CREATE FILENAME DESCRIPTOR
	MOVZBL	NAM$B_ESL(R7),-(SP)	;
	PUSHL	FAB$L_STV(R6)		; PUSH FILE OPEN STATUS VALUE
	PUSHL	R0			; PUSH COMPLETION STATUS
	MOVAL	8(SP),-(SP)		; PUSH FILENAME DESC. ADDRESS
	PUSHL	#1			; PUSH NUMBER OF FAO ARGS.
	PUSHL	#SHR$_OPENIN!<RSX$_FACILITY@STS$V_FAC_NO>!STS$K_ERROR
	PUSHL	#5			; PUSH ARGUMENT COUNT
	MOVL	SP,R1			; POINT TO MESSAGE VECTOR
	$PUTMSG_S MSGVEC=(R1)		; OUTPUT MESSAGES
	ADDL	#8*4,SP			; POP MESSAGE VECTOR
	BRB	100$			; GO FINISH UP

;
; RUN THE IMAGE WE JUST OPENED
;
30$:	MOVL	G^SYS$GL_CMCNTX,R10	; ADDRESS IMAGE IMPURE AREA
	MOVZBL	NAM$B_ESL(R7),R0	; LENGTH OF EXPANDED FILE NAME
	MOVB	R0,(R10)		; SET LENGTH OF COUNTED STRING
	MOVC	R0,@NAM$L_ESA(R7),1(R10); MOVE EXPANDED FILE NAME STRING
	PUSHL	20(AP)			; STACK CLI AP
	PUSHL	FAB$L_CTX(R6)		; CONTEXT LONGWORD
	MOVQ	12(AP),-(SP)		; CLI CALLBACK/TYPE OF CLI
	PUSHL	FAB$L_STV(R6)		; PASS CHANNEL NUMBER
	CALLS	#5,B^RSX$RUNIMAGE	; RUN THE IMAGE
	PUSHL	R0			; COPY STATUS VALUE
	$CLOSE	FAB=(R6)		; CLOSE THE RSX IMAGE FILE
100$:	BISL3	#STS$M_INHIB_MSG,(SP)+,R0 ;RESTORE COMPLETION STATUS
	RET				; ALL DONE!

	.SBTTL	RSX$RUNIMAGE - RUN RSX-11M IMAGE
;++
; RSX$RUNIMAGE - RUN RSX-11M IMAGE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS THE ENTRY INTO THE RSX-11M AME. THE ACTION IS TO LOAD THE REQUESTED
; RSX-11M IMAGE, SET UP THE IMAGE DATA SPACE AND ENTER THE IMAGE.
;
; CALLING SEQUENCE:
;
;	0(AP)  = NUMBER OF ARGUMENTS (5)
;	4(AP)  = IMAGE FILE CHANNEL (USER MODE)
;	8(AP)  = COMMAND LINE CALLBACK ROUTINE ADDRESS
;	12(AP) = TYPE OF CLI  (1=DCL, 0=MCR)
;	14(AP) = FAB$L_CTX FROM FILE OPEN
;	20(AP) = AP FROM CLI
;
; OUTPUTS:
;
;	R0 = STATUS OF THE RUN.
;--
	.ENTRY	RSX$RUNIMAGE,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
;
; INIT AND ADDRESS THIS IMAGE'S IMPURE DATA BASE.
;
	MOVL	G^SYS$GL_CMCNTX,R10	; ADDRESS IMAGE IMPURE AREA
;
; ON ENTRY TO THE EMULATOR, THE IMAGE ACTIVATOR HAS PLACED THE COUNTED
; STRING OF THE FILE NAME IN THE CONTEXT AREA.  SAVE THE FILE NAME
; STRING ON THE STACK AND SET THE IMAGE FILE NAME DESCRIPTOR IN THE
; CONTROL REGION TO THIS STRING RATHER THAN TO THE AME IMAGE NAME.
; THIS IS SO THAT $GETJPI RETURNS A REASONABLE RESULT WHEN ASKING FOR
; THE NAME OF THE IMAGE CURRENTLY BEING EXECUTED.
;
	MOVZBL	(R10),R0		; GET LENGTH OF FILE NAME STRING
	BEQL	5$			; BRANCH IF NONE
	CMPL	R0,#NAM$C_MAXRSS	; CHECK IF IN RANGE
	BGTR	5$			; IF SO, IGNORE IT
	SUBL	#NAM$C_MAXRSS,SP	; ALLOCATE IMAGE NAME BUFFER
	MOVL	20(AP),R1		; POINT TO CLI AP
	BNEQ	4$			; IF NEQ THEN SPECIFIED
	MOVL	W^RSX$G_CLIAP,R1	; GET OLD CLI AP IF THERE
	BEQL	5$			; IF EQL NOT THERE
4$:	MOVL	R1,W^RSX$G_CLIAP	; STORE FOR POSSIBLE FUTURE USE
	MOVL	B^CLI$A_IMGFILED(R1),R1	; GET ADDRESS OF IFD BUFFER
	BEQL	5$			; SKIP IF NONE (NORMALLY THERE)
	MOVL	R0,IFD$Q_CURPROG(R1)	; SET NEW LENGTH OF IMAGE NAME
	MOVL	SP,IFD$Q_CURPROG+4(R1)	; SET ADDRESS OF IMAGE NAME
	MOVC	R0,1(R10),(SP)		; SAVE NAME OF IMAGE FILENAME
;
; ALLOCATE DYNAMIC MEMORY
;
5$:	MOVC5	#0,(R10),#0,#512,(R10)	; ZERO IMPURE AREA
	MOVL	FP,I_BAILOUTFP(R10)	; SAVE BAILOUT FP
	MOVL	W^RSX$G_LOWP0ADDR,R0	; FIND LOWEST P0 ADDRESS
	BEQL	10$			; IF EQL THEN NOT DISCOVERED YET
	ASHL	#30,#1,-(SP)		; CALC HIGH P0 LIMIT
	DECL	(SP)			;
	PUSHL	R0			; CALC LOW LIMIT
	MOVAB	(SP),R2			; LOAD ADDR OF ARGS
	$DELTVA_S (R2)			; DELETE THE SPACE
	BRB	15$			; CONTINUE
10$:	ASHL	#31,#1,-(SP)
	CLRL	-(SP)
	MOVL	SP,R0
	$PURGWS_S	(R0)
15$:	ADDL	#8,SP
	$EXPREG_S	#3,W^RSX$G_LOWP0ADDR; ALLOCATE SPACE FOR LABEL BLOCK READ
;
; SET UP POOL AND OTHER LIST HEADS
;
	CLRQ	W^RSX$A_POOL		; SET EMPTY POOL
;
; SET UP AST QUEUE
;
	MOVAB	I_ASTQUEUE(R10),I_ASTQUEUE(R10);
	MOVAB	I_ASTQUEUE(R10),I_ASTQUEUE+4(R10);
;
; SET UP AST CONTEXT BLOCK POOL
;
	MOVAB	I_ASTPOOL(R10),I_ASTPOOL(R10);
	MOVAB	I_ASTPOOL(R10),I_ASTPOOL+4(R10)
;
; SET UP FCB POOL
;
	MOVAB	I_FCBPOOL(R10),I_FCBPOOL(R10);
	MOVAB	I_FCBPOOL(R10),I_FCBPOOL+4(R10);
;
; INITIALIZE TIMER REQUEST QUEUE
;
	MOVAB	I_MRKTQUEUE(R10),I_MRKTQUEUE(R10)
	MOVAB	I_MRKTQUEUE(R10),I_MRKTQUEUE+4(R10)
;
; SET UP LOGICAL NAME LIST
;
	MOVAB	I_LOGNAME(R10),I_LOGNAME(R10);
	MOVAB	I_LOGNAME(R10),I_LOGNAME+4(R10);
	INSQUE	W^RSX$A_TIIDEV,@I_LOGNAME(R10)
	CLRW	W^LUT_INFOUNIT+RSX$A_TIIDEV
	INSQUE	W^RSX$A_TIODEV,@I_LOGNAME(R10)
	CLRW	W^LUT_INFOUNIT+RSX$A_TIODEV
	INSQUE	W^RSX$A_CLDEV,@I_LOGNAME(R10)
	CLRW	W^LUT_INFOUNIT+RSX$A_CLDEV
	INSQUE	W^RSX$A_CODEV,@I_LOGNAME(R10)
	CLRW	W^LUT_INFOUNIT+RSX$A_CODEV
	INSQUE	W^RSX$A_SYDEV,@I_LOGNAME(R10)
	CLRW	W^LUT_INFOUNIT+RSX$A_SYDEV
;
; SAVE COMMAND LINE CALL BACK ADDRESS
;
	MOVL	CMDROUT(AP),I_CMDROUT(R10); SAVE CMD CALL BACK
	BNEQ	20$			; IF NEQ THEN ASSUME OK
	MOVAB	W^RSX$RETEXIT,I_CMDROUT(R10); SET NULL ROUTINE
20$:	INSV	CMDFLG(AP),#SV_DCL,#1,I_STATE(R10); SET COMMAND INTERPRETER FLAGS
;
; ASSIGN SYS$INPUT
;
	MOVAB	W^RSX$A_TIIDEV,R6	; ADDRESS NAME LUT
	MOVAB	W^ALUN_LUN,R5		; ADDRESS LUT
	PUSHAB	B^25$			; SET UP CALL
	BSBW	RSX$SYS_DEVS		; OPEN SYS$INPUT DEVICE
;
; ASSIGN SYS$OUTPUT
;
25$:	MOVAB	W^RSX$A_TIODEV,R6	; ADDRESS SYS$OUTPUT LUT
	PUSHAB	B^30$
	BSBW	RSX$SYS_DEVS		; OPEN SYS$OUTPUT
;
; SET UP OV DEVICE
;
30$:	MOVAB	W^RSX$A_OVDEV,R8	; ADDRESS OV DEVICE DATA
	INSQUE	(R8),@I_LOGNAME+4(R10)	; INSERT ON LOGICAL LIST
	MOVL	IMAGECHAN(AP),LUT_CHAN(R8); INSERT CHANNEL PASSED BY CALLER
	BSBW	RSX$BUILDLUT		; BUILD INFO NAME AND REAL NAME

;
; READ THE LABEL BLOCKS
;
	CLRQ	I_SCRATCH(R10)		; DELETE THE TASK VIRTUAL ADDRESS
	MNEGW	#1,I_SCRATCH+4(R10)	;
	$DELTVA_S	I_SCRATCH(R10)	; 
	MOVL	W^RSX$G_LOWP0ADDR,R9	; ADDRESS LABEL BUFFER
	$QIOW_S	EFN=#0,-
		CHAN=W^RSX$A_OVDEV+LUT_CHAN,-
		FUNC=#IO$_READVBLK,-
		IOSB=I_SCRATCH(R10),-
		P1=(R9),-
		P2=#3*512,-
		P3=#1
	BLBC	R0,100$			; IF LOW CLEAR THEN ERROR
	BLBC	I_SCRATCH(R10),100$	; IF IOSB LOW CLEAR THEN ERROR
	MOVW	L$BFLG(R9),I_STATE+2(R10); SAVE TASK STATUS
	BITW	#TS$NHD!TS$ACP!TS$SUP!TS$RES,L$BFLG(R9) ; PROPER FLAGS?
	BNEQ	90$			; IF NEQ THEN ERROR
	TSTW	L$BOFF(R9)		; OFFSET IN PARTITION=0?
	BNEQ	90$			; IF NEQ THEN ERROR
	MOVZWL	L$BSA(R9),R11		; GET STARTING VA
	BEQL	LOAD_READ_WRITE		; IF LEGAL THEN LOAD READ WRITE AREA
90$:	$ABORT	#RSX$_NOTSKIMG		; SIGNAL ILLEGAL FORMAT
100$:	$ABORT	#RSX$_LOADERROR		; SIGNAL LOAD ERROR

;
; LOAD THE TASK READ/WRITE AREA
;
LOAD_READ_WRITE:			;
	CLRL	I_L$BXLN(R10)		; ASSUME ITS A RSX-11M TASK IMAGE
	CMPB	L$BSYS(R9),#4		; IS IT REALLY FOR 11M-PLUS?
	BNEQ	3$			; IF NEQ NO, STANDARD LIBR BLKS
	MOVZBL	#<8*<L$BLIB-L$BPAR>>/2,I_L$BXLN(R10) ; SPAN XTRA LIBRARY BLOCKS
3$:	CLRL	I_ADR0+ADR_LOWLIM(R10)	; SET ADR0 LOW LIM AS 0
	ASHL	#16,#1,I_HIGHSIZE(R10)	; SET IMAGE HIGH LIMIT
	CVTWL	L$BMXZ(R9),I_ADR0+ADR_HIGHLIM(R10); SET UP ADR0 HIGH LIMIT
	BLEQ	5$			; IF LEQ THEN ILLEGAL IMAGE FORMAT
	MOVL	I_L$BXLN(R10),R4	; OFFSET TO END OF LABEL BLOCK
	CVTWL	L$BEXT(R9)[R4],R3	; PICK UP INITIAL IMAGE EXTENSION
	BLSS	5$			; IF LSS THEN ILLEGAL
	ADDL	R3,I_ADR0+ADR_HIGHLIM(R10); CALC HIGH LIMIT FOR READ/WRITE
	ASHL	#6,I_ADR0+ADR_HIGHLIM(R10),I_ADR0+ADR_HIGHLIM(R10); IN BYTES
	MOVL	I_ADR0+ADR_HIGHLIM(R10),I_INISIZE(R10); SAVE AS CURRENT SIZE
	CMPL	I_INISIZE(R10),#^X10000	; TOO BIG?
	BLEQU	11$			; IF EQL THEN OK
5$:	$ABORT	#RSX$_NOTSKIMG		; SIGNAL NOT TASK IMAGE
11$:	$CRETVA_S	I_ADR0+ADR_LOWLIM(R10); CREATE THE READ/WRITE SPACE
;
; READ THE HEADER AND TASK IMAGE
;
	MOVZWL	L$BLDZ(R9),R3		; CALC ROOT SEG LOAD SIZE
	ASHL	#6,R3,R3		; IN BYTES
	MOVZWL	L$BHRB(R9)[R4],I_IMAGEVBN(R10) ; GET RELATIVE BLOCK TO HEADER
	INCL	I_IMAGEVBN(R10)		; SAVE IT FOR OVERLAYING
	CLRQ	R4			; START FROM IMAGE VBN AT VA=0
	CLRL	I_SCRATCH+4(R10)	; SET UP EFN
	BSBW	RSX$OVERLAY		; TREAT AS OVERLAY
	BLBC	R0,100$			; IF LOW CLEAR THEN ERROR
;
; VERIFY GUARD WORD AND LUN/WINDOW BLOCKS
;
	MOVW	H.GARD(R4),I_GARD(R10)	; ADDRESS GUARD WORD
	BLBS	I_GARD(R10),5$		; IF LOW SET THEN ERROR
	MOVZBL	H.NLUN(R4),R1		; GET THE NUMBER OF ALLOWED LUNS
	MOVAL	H.LUN(R11)[R1],R1	; ADDRESS TABLE END
	MOVZWL	H.WND(R11),R3		; GET WINDOW ADDRESS
	CMPW	R1,R3			; ADDRESS OF WINDOWS EQL TO END OF LUNS?
	BNEQ	5$			; IF NEQ THEN ERROR
	MOVZWL	(R3),R5			; GET NUMBER OF WINDOWS
	MULL	#W.BLGH,R5		; CALC SIZE OF ALLOCATION
	MOVAB	18(R3)[R5],R5		; ADDRESS END OF WINDOWS
	CMPW	R5,I_GARD(R10)		; END OF NEEDED SPACE THE GUARD WORD?
	BEQL	LOAD_READ_ONLY		; IF EQL THEN PROPER HEADER
;
; BAD HEADER FORMAT
;
	$ABORT	#RSX$_NOTSKIMG		; SIGNAL NOT TASK IMAGE
100$:	$ABORT	#RSX$_LOADERROR		; SIGNAL LOAD ERROR

;
; LOAD READ ONLY IMAGE SECTION
;
LOAD_READ_ONLY:				;
	MOVAB	L$BLIB(R9),R8		; ADDRESS IMAGE LIBRARY DESCRIPTERS
	MOVAB	I_ADR0+ADR_SIZE(R10),R6	; ADDRESS IMAGE WINDOW DESCS
	MOVL	I_L$BXLN(R10),R5	; OFFSET TO END OF LABEL BLOCK
	MOVZWL	L$BROL(R9)[R5],R5	; GET EXTENT OF READ ONLY IMAGE
	BNEQ	10$			; IF NEQ THEN READ ONLY IMAGE
	BRW	LOAD_LIBRARIES
;
; LOAD READ-ONLY IMAGE SECTION (CODE SEGMENT)
;
10$:	MOVZWL	R$LSA(R8),ADR_LOWLIM(R6); GET LIBRARY LOW LIMIT
	MOVZWL	R$LHGV(R8),ADR_HIGHLIM(R6); GET LIBRARY HIGH LIMIT
;
; SECTION NAME IS TASKNAME_001
;
	MOVAB	I_SCRATCH+8(R10),R7	; BUILD SECTION NAME
	MOVAB	L$BTSK(R9),R4		;
	MOVL	R7,R2			; SAVE START ADDRESS
	BSBW	RSX$R50CVT2		; CONVERT
	MOVL	#^A/_001/,(R7)+		; BUILD SUFFIX
	SUBL	R2,R7			; SIZE STRING
	SKPC	#^A/./,R7,I_SCRATCH+8(R10); SKIP LEADING .'S
	MOVQ	R0,I_SCRATCH(R10)	; BUILD DESC
;
;	ATTEMPT TO MAP THE SECTION AS A GROUP GLOBAL SECTION (TEMPORARY)
;
	$MGBLSC_S	INADR=ADR_LOWLIM(R6),-
			GSDNAM=I_SCRATCH(R10)
	BLBC	R0,20$			; CONTINUE IF UNABLE TO MAP
	BRW	100$			; BRANCH IF MAPPED OK
;
;	IF NOT A GROUP SECTION, TRY AS A SYSTEM-WIDE GLOBAL SECTION.
;	ASSUME THE GLOBAL SECTION IS IN LOCAL MEMORY, AND USE THE
;	KNOWN FILE ENTRY ADDRESS AS THE IDENT.
;
20$:	MOVL	#ISD$K_MATEQU,I_SCRATCH+20(R10); SET UP MATCH IDENT
	MOVL	CONTEXT(AP),I_SCRATCH+24(R10) ; ASSUME LOCAL IDENT (KFI)
;
;	ATTEMPT TO MAP THE SECTION AS LOCAL PROCESSOR SYSTEM GLOBAL SECTION
;
	$MGBLSC_S	INADR=ADR_LOWLIM(R6),-
			IDENT=I_SCRATCH+20(R10),-
			FLAGS=#SEC$M_SYSGBL,-
			GSDNAM=I_SCRATCH(R10)
	BLBS	R0,100$			; IF LOW SET THEN MAPPED
;
;	IF THE GLOBAL SECTION IS IN MULTI-PORT MEMORY,
;	THEN THE MIDDLE 32 BITS OF THE TKB DATE/TIME IS USED
;	AS THE IDENT SINCE THERE IS NO KNOWN FILE ENTRY FOR
;	MULTI-PORT GLOBAL SECTIONS.
;
	MOVL	L$BDAT+2(R9),I_SCRATCH+24(R10)	; USE MIDDLE 32 BITS AS IDENT
;
;	ATTEMPT TO MAP THE SECTION AS MULTI-PORT MEMORY GLOBAL SECTION
;
	$MGBLSC_S	INADR=ADR_LOWLIM(R6),-
			IDENT=I_SCRATCH+20(R10),-
			FLAGS=#SEC$M_SYSGBL,-
			GSDNAM=I_SCRATCH(R10)
	BLBS	R0,100$			; IF LOW SET THEN MAPPED
;
;	IF THE LIBRARY DOES NOT EXIST AS A GLOBAL SECTION, THEN MAP
;	IT AS A PRIVATE SECTION.
;
	ADDL	#7,R5			; ROUND UP
	DIVL	#8,R5			;
	MOVL	I_L$BXLN(R10),R1	; OFFSET TO END OF LABEL BLOCK
	MOVZWL	L$BROB(R9)[R1],R1	; GET OFFSET IN IMAGE
	$CRMPSC_S	INADR=ADR_LOWLIM(R6),-
			CHAN=W^LUT_CHAN+RSX$A_OVDEV,-
			PAGCNT=R5,-
			VBN=R1		
	BLBS	R0,100$			; IF LOW SET THEN SUCCESS
50$:	MOVQ	I_SCRATCH(R10),-(SP)	; SIGNAL ERROR
	PUSHL	#2
	PUSHL	#RSX$_BADLIBREF
	PUSHL	#4
	CLRQ	-(SP)
	PUSHAB	8(SP)	
	CALLS	#3+5,@#SYS$PUTMSG	; OUTPUT MESSAGE
	$ABORT	#RSX$_LOADERROR		; ABORT IMAGE
;
; SET UP READ/ONLY ADR DATA
;
100$:	MOVL	ADR_LOWLIM(R6),I_HIGHSIZE(R10)
;
; LOAD COMMON BLOCKS AND LIBRARIES
;
LOAD_LIBRARIES:
	SUBL	#512,SP			; ALLOCATE SPACE FOR POSSIBLE READ BUFFER
10$:	TSTL	R$LNAM(R8)		; DONE WITH LIBRARY LOADS?
	BEQL	20$			; IF NEQ THEN NO
	BSBW	MAP_LIBRARY		; MAP THE LIBRARY
	ADDL	#ADR_SIZE,R6		; ADDRESS NEXT ADDRESS WINDOW
	ADDL	#R$LDAT+6,R8		; ADDRESS NEXT LIB DESC
	BRB	10$			; CONTINUE
20$:	ADDL	#512,SP			; DEALLOCATE THE BUFFER

;
; GET PROCESS INFORMATION
;
GET_PROC_INFO:				;
	MOVL	#17,R1			; 17 BYTES FOR ASCIC PROCESS NAME
	BSBW	RSX$ALLOCATE		; ALLOCATE THE SPACE
	MOVL	R0,I_PROCNAME(R10)	; STORE ADDRESS OF BUFFER
	MOVL	#16+<JPI$_PRCNAM@16>,I_SCRATCH(R10); GET PROCESS NAME
	MOVAB	1(R0),I_SCRATCH+4(R10)
	MOVAB	I_SCRATCH(R10),I_SCRATCH+8(R10); 
	MOVL	#2+<JPI$_MEM@16>,I_SCRATCH+12(R10); GET UIC
	MOVAB	I_UIC(R10),I_SCRATCH+16(R10);
	CLRL	I_SCRATCH+20(R10)	; SET NO SIZE RETURN
	MOVL	#2+<JPI$_GRP@16>,I_SCRATCH+24(R10); 
	MOVAB	I_UIC+2(R10),I_SCRATCH+28(R10); INSERT ADDRESS
	CLRL	I_SCRATCH+32(R10)	; NO RETURN 
	MOVL	#4+<JPI$_PRIB@16>,I_SCRATCH+36(R10); GET PRIORITY
	MOVAB	I_SCRATCH+40(R10),I_SCRATCH+40(R10);
	CLRQ	I_SCRATCH+44(R10)	; NO RETURN AND END LIST
	$GETJPI_S	ITMLST=I_SCRATCH(R10)
	MOVB	I_SCRATCH(R10),@I_PROCNAME(R10); SET SIZE OF ASCIC PROCESS NAME
	MOVW	I_SCRATCH+40(R10),H.SPRI(R11); SAVE PRIORITY
	MOVB	I_UIC(R10),H.DUIC(R11)	; INSERT UIC
	MOVB	I_UIC+2(R10),H.DUIC+1(R11);
	MOVW	H.DUIC(R11),H.CUIC(R11)	; COPY UIC
;
; SETUP PROPER NAME - EITHER PROCESSNAME OR LABEL NAME
;
	MOVZWL	#63,I_HIGHEFN(R10)	; SET KNOWN HIGHEST EFN
	MOVAB	I_ASCIINAME(R10),R7	; ADDRESS TARGET OF FINAL NAME
	MOVB	I_SCRATCH(R10),(R7)+	; ASSUME LESS THAN 6 CHARACTERS
	MOVC5	I_SCRATCH(R10),@I_SCRATCH+4(R10),#0,#6,(R7); COPY PROCNAME
	BLEQ	55$			; IF LEQ THEN CORRECT SIZE
	MOVB	#6,-1(R7)		; SET MAX SIZE
55$:	MOVL	R7,I_SCRATCH+4(R10)	;
;
; SEE IF THIS IMAGE IS A NON-MULTI USER IMAGE
;
	MOVAB	L$BTSK(R9),R4		; GET LABEL NAME
	TSTW	(R4)			; NAME PRESENT IN LABEL
	BEQL	60$			; MULTI-USER IF EQL
	CMPW	#^O0131574,(R4)		; ...XXX?
	BNEQ	70$			; IF NEQ THEN SINGLE USER
60$:	BRW	100$			; CONTINUE
;
; CONVERT LABEL NAME TO ASCII
;
70$:	PUSHL	R7			; SAVE TARGET ADDRESS
	BSBW	RSX$R50CVT2		; CONVERT THE NAME
	SUBL3	(SP)+,R7,I_SCRATCH(R10)	; CALC NAME SIZE
	MOVB	I_SCRATCH(R10),I_ASCIINAME(R10)
	$SETPRN_S	I_SCRATCH(R10)	; DECLARE LOGICAL NAME
	BLBS	R0,72$			; BR IF SUCCESSFUL
	BRW	90$
;
; CREATE RECEIVE DATA MAILBOX
;
72$:	MOVAB	I_SCRATCH(R10),R0	; ADDRESS SCRATCH AREA
	ADDL	#4,(R0)+		; ADJUST FOR "RCVD" PREFIX
	MOVAB	I_SCRATCH+8(R10),(R0)+	; SET UP STRING DESC.
	MOVL	#C_RCVDSTR,(R0)+	; INSERT PREFIX
	MOVQ	I_ASCIINAME+1(R10),(R0)	; INSERT NAME
	CMPL	L$BTSK(R9),#^XB37C1596	; CRF...?
	BNEQ	75$			; BRANCH IF NOT
	$ASSIGN_S CHAN=I_RCVMAIL(R10),- ; ASSIGN TO PREVIOUS CREATED MAILBOX
		DEVNAM=I_SCRATCH(R10)
	BRB	79$
75$:	$CREMBX_S CHAN=I_RCVMAIL(R10),-	; CREATE RECEIVE MAILBOX
		MAXMSG=#30,-
		BUFQUO=#RSX$_RCVMBXSIZ,-
		PROMSK=#^X0F00F,-
		LOGNAM=I_SCRATCH(R10)
79$:	BLBC	R0,90$			; BR IF ERROR
;
; ASSOCIATE THE COMMON EVENT FLAGS
;
	MOVAB	W^COMMONEFN,R0		;
	MOVZBL	(R0)+,I_SCRATCH(R10)	;
	MOVL	R0,I_SCRATCH+4(R10)
	$ASCEFC_S	#64,I_SCRATCH(R10)
	MOVZWL	#95,I_HIGHEFN(R10)	; INSERT NEW HIGH EFN
	BLBS	R0,100$			; BR IF SUCCESS
;
; ERROR IN COMMON EFN, MAILBOX OR SETPRN SERVICE
;
90$:					;
	PUSHL	#0			; OUTPUT MESSAGE
	PUSHL	#RSX$_NOCOMM
	PUSHL	#2
	CLRQ	-(SP)
	PUSHAB	8(SP)
	CALLS	#3+3,@#SYS$PUTMSG
	$ABORT	#RSX$_LOADERROR		; AND ABORT THE IMAGE
;
; SET UP TASK NAME IN RAD50
;
100$:	
	MOVAB	I_ASCIINAME+1(R10),R1	; ADDRESS ASCII NAME
	MOVAB	I_RAD50NAME(R10),R4	; ADDRESS TARGET
	MOVL	#1,R0			; SET "." LEGAL IN NAME
	BSBW	RSX$ASCR502		; CONVERT NAME
	MOVZWL	H.GARD(R11),R0		; ADDRESS GARD WORD
	MOVW	I_RAD50NAME(R10),-4(R0)	;
	MOVW	I_RAD50NAME+2(R10),-6(R0);
;
; CLEAR ALL PRIVATE EFNS
;
	CLRQ	I_SCRATCH(R10)		; INSURE CLEAR EVENT FLAGS
	$READEF_S	#32,I_SCRATCH(R10)
	CLRL	R2
110$:	FFS	R2,#31,I_SCRATCH(R10),R2; FIND A SET EFN
	BEQL	120$			; IF EQL THEN NONE FOUND
	ADDL3	#32,R2,R3		; CLEAR IT
	INCL	R2			; START AT NEXT
	$CLREF_S	R3
	BRB	110$
120$:	

;
; ASSIGN TASK IMAGE PRE-ASSIGNED DEVICES
;
ASSIGN_DEVS:				;
	MOVZWL	H.NLUN(R11),R1		; GET NUMBER OF LUNS IN IMAGE
	MOVW	R1,I_NLUN(R10)		; SAVE NUMBER IN SAFE PLACE
	BNEQ	10$			; IF NEQ THEN OK
	BRW	100$			; DONE
10$:	MULL	#4,R1			; CALC LUT BLOCK SIZE
	SUBL	R1,SP			; ALLOCATE IT
	MOVAL	-(SP),I_LUT(R10)	; SAVE ADDRESS
	MOVC5	#0,(SP),#0,R1,4(SP)	; CLEAR AREA
	MOVAB	L$BASG-2(R9),R5		; ADDRESS LUT AREA AS IF DPB
	MOVW	#1,(R5)			; START WITH LUN 1
20$:	TSTW	2(R5)			; ANY NAME?
	BEQL	30$			; IF EQL THEN NO
	MOVB	#1,H.DSW(R11)		; ASSUME SUCCESS
	PUSHR	#^M<R5,R9>		; SAVE DPB ADDRESS AND LABEL ADDR
	BSBW	RSX$ALUN		;
	POPR	#^M<R5,R9>
	TSTB	H.DSW(R11)		; ERROR?
	BGTR	30$			; IF GTR THEN NO
	MOVZWL	(R5),-(SP)		; OUTPUT ERROR MESSAGE
	MOVZWL	4(R5),-(SP)
	PUSHAB	2(R5)
	PUSHL	#2
	PUSHL	#4
	PUSHL	#RSX$_NOSUCHDEV
	PUSHL	#5
	CLRQ	-(SP)
	PUSHAB	8(SP)
	CALLS	#3+6,@#SYS$PUTMSG
30$:	INCL	(R5)+			; ADJUST LUN NUMBER
	MOVW	-4(R5),(R5)		; INSERT AS NEW NUMBER
	CMPW	(R5),I_NLUN(R10)	; DONE?
	BLEQU	20$			; IF NEQ THEN NO
;
; TAKE CARE OF ACTUAL OVERLAY LUN
;
	MOVZWL	H.OVLY(R11),R0		; ADDRESS OVERLAY IMPURE VECTOR
	BEQL	100$			; IF EQL THEN NONE
	MOVZBL	(R0),R7			; GET THE LUN NUMBER
	BEQL	100$			;
	MOVAB	W^RSX$A_OVDEV,R8	; ADDRESS OVERLAY ENTRY
	MOVL	@I_LUT(R10)[R7],R2	; GET THE OVERLAY LUT ENTRY
	BEQL	100$			; IF EQL THEN NONE
	CMPL	R8,R2			; SAME AS REAL?
	BEQL	100$			; IF EQL THEN LEAVE ALONE
	$DASSGN_S	LUT_CHAN(R2)	; DEASSIGN CHANNEL
	REMQUE	(R2),R0			; REMOVE IT FROM CURRENT LIST
	MOVZBL	#LUT_SIZE,R1		; DEALLOCATE THE ENTRY
	BSBW	RSX$DEALLOCATE		; DEALLOCATE IT
	MOVL	R8,@I_LUT(R10)[R7]	; ASSIGN TO REAL OVERLAY LUT
;
; ASSIGNMENTS COMPLETED
;
100$:	MOVL	R9,R0			; DEALLOCATE LABEL BLOCK STORAGE
	MOVZWL	#<3*512>,R1		;
	BSBW	RSX$DEALLOCATE		;

;
; SET UP FOR COMPATIBILITY MODE EXCEPTIONS
;
	MOVW	H.ODVA(R11),I_DEBVEC(R10); SAVE VECTORS
	MOVW	H.ODVL(R11),I_DEBVECL(R10);
	MOVW	H.TKVA(R11),I_SSTVEC(R10);
	MOVW	H.TKVL(R11),I_SSTVECL(R10);
	MOVAB	W^RSX$EXCEPTION,(FP)	; REPLACE FRAME HANDLER
	$DCLCMH_S	RSX$CMTRAP,,#1
	MOVAB	W^RSX$FORCEEXIT,W^RSX$A_EXITBLOCK
	$DCLEXH_S	W^RSX$A_EXITBLOCK
;
; SET UP 11M REGISTERS FOR ENTRY
;
	MOVZWL	H.GARD(R11),R7		; ADDRESS CONTEXT AREA
	MOVZWL	-(R7),R0		; LOAD REGISTERS
	MOVZWL	-(R7),R1		;
	MOVZWL	-(R7),R2		;
	MOVZWL	-(R7),R3		;
	MOVZWL	-(R7),R4		;
	MOVZWL	-(R7),R5		;
	MOVZWL	H.ISP(R11),R6		; SET UP STACK
	EXTZV	#0,#5,H.IPS(R11),-(SP)	; SET UP CONDITION CODES
	BISL	#C_CANONPS,(SP)		;
	MOVZWL	H.IPC(R11),-(SP)	;
	REI				; ENTER IMAGE

	.SBTTL MAP_LIBRARY - MAP RESIDENT LIBRARY
 
	.ENABL	LSB
;++
; MAP_LIBRARY - MAP A RESIDENT LIBRARY
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE PROCESSES A IMAGE LABEL BLOCK LIBRARY REQUEST.
; THE LIBRARY IS MAPPED AND IF THE MAP FAILS THEN A CREATE OF A PROCESS
; SECTION IS DONE.
;
; INPUTS:
;
;	R6 = ADDRESS OF THE ADDRESS WINDOW TO USE
;	R8 = ADDRESS OF THE LIBRARY DESC
;	R9 = ADDRESS OF THE IMAGE LABEL
;	R10 = ADDRESS OF THE IMAGE IMPURE AREA
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	R6,R8,R9,R10,R11 ARE PRESERVED
;
;--
10$:	$ABORT	#RSX$_NOTSKIMG
MAP_LIBRARY:				; MAP LIBRARY REFERENCE
	TSTW	R$LOFF(R8)		; PARTITION OFFSET 0?
	BNEQ	10$			; IF NEQ THEN ERROR
	MOVZWL	R$LSA(R8),ADR_LOWLIM(R6); SET UP LIBRARY LIMITS
	MOVZWL	R$LMXV(R8),ADR_HIGHLIM(R6);
	MOVZWL	R$LLDZ(R8),I_SCRATCH+28(R10); CALC PAGE NUMBERS
	ADDL	#7,I_SCRATCH+28(R10)	;
	DIVL	#8,I_SCRATCH+28(R10)	;
	MOVL	R8,R4			; ADDRESS REQUEST NAME IN RAD50
	MOVAB	I_SCRATCH+8(R10),R7	; ADDRESS NAME TARGET
	MOVL	R7,R2			; COPY ADDRESS
	BSBW	RSX$R50CVT2		; CONVERT NAME TO ASCII
	MOVL	#^A/_001/,(R7)+		; INSERT SUFFIX
	SUBL	R2,R7			; CALC SIZE
	SKPC	#^A/./,R7,I_SCRATCH+8(R10); PASS LEADING .'S
	MOVQ	R0,I_SCRATCH(R10)	; SET UP DESC
;
; FIRST, TRY TO MAP THE SECTION AS A GROUP GLOBAL SECTION
;
	MOVZBL	#SEC$M_GBL,I_SCRATCH+32(R10) ; START WITH GROUP GLOBAL SECTION
	BITW	#LD$ACC,R$LFLG(R8)	; READ ONLY?
	BEQL	15$			; IF EQL THEN READ ONLY
	BISW	#SEC$M_WRT,I_SCRATCH+32(R10); SET READ WRITE REQUEST
15$:	$MGBLSC_S	INADR=ADR_LOWLIM(R6),-
			FLAGS=I_SCRATCH+32(R10),-
			GSDNAM=I_SCRATCH(R10)
	BLBS	R0,19$			; BRANCH IF MAPPED OK
;
; IF THAT FAILS, TRY TO MAP IT AS A SYSTEM GLOBAL SECTION
;
	BISW	#SEC$M_SYSGBL,I_SCRATCH+32(R10); TRY AS SYSTEM GLOBAL SECTION
	$MGBLSC_S	INADR=ADR_LOWLIM(R6),-
			FLAGS=I_SCRATCH+32(R10),-
			GSDNAM=I_SCRATCH(R10)
	BICW	#SEC$M_SYSGBL,I_SCRATCH+32(R10) ; CLEAR SYSTEM GLOBAL FLAG
	BLBC	R0,20$			; BRANCH IF STILL UNABLE TO MAP
19$:	BRW	90$			; CONTINUE
;
; IF THAT FAILS, CREATE A PROCESS PRIVATE SECTION TO THE IMAGE
;
; ALLOCATE THE FAB AND BUFFER 
;
20$:	MOVAB	W^RSX$G_FAB,R7		; ADDRESS GENERAL FAB
	MOVC5	#0,(R7),#0,#FAB$C_BLN,(R7); ZERO IT
	MOVB	#FAB$C_BLN,FAB$B_BLN(R7); SET UP FAB
	MOVB	#FAB$C_BID,FAB$B_BID(R7);
	MOVB	W^RSX$T_LIBDEF,FAB$B_DNS(R7); INSERT SIZE OF DEFUALT NAME
	MOVAB	W^RSX$T_LIBDEF+1,FAB$L_DNA(R7)	; INSERT ADDRESS
	SUBB3	#4,I_SCRATCH(R10),FAB$B_FNS(R7); INSERT SIZE LESS "_001"
	MOVAB	I_SCRATCH+8(R10),FAB$L_FNA(R7); INSERT ADDRESS
	MOVB	#FAB$M_GET,FAB$B_FAC(R7);
	MOVB	#FAB$M_GET!FAB$M_PUT!FAB$M_UPI,FAB$B_SHR(R7)
	BBC	#SEC$V_WRT,I_SCRATCH+32(R10),35$; WRITE REQUEST?
	BISB	#FAB$M_PUT,FAB$B_FAC(R7);
35$:	MOVL	#FAB$M_UFO!FAB$M_KFO,FAB$L_FOP(R7); USER AND KNOWN FILE OPEN
	$OPEN	FAB=R7			; OPEN LIBRARY FILE
	BLBS	R0,40$			; IF IF SUCCESS
	MOVQ	I_SCRATCH(R10),-(SP)	; SIGNAL ERROR
	PUSHL	#2
	PUSHL	#RSX$_LIBNOTFND
	PUSHL	#4
	CLRQ	-(SP)
	PUSHAB	8(SP)	
	CALLS	#3+5,@#SYS$PUTMSG	; OUTPUT MESSAGE
	$ABORT	#RSX$_LOADERROR		;
;
; READ THE FILE
;
40$:	MOVAB	4(SP),R5		; ADDRESS ALLOCATED BUFFER
	$QIOW_S	EFN=#0,-
		CHAN=FAB$L_STV(R7),-
		FUNC=#IO$_READVBLK,-
		IOSB=I_SCRATCH+40(R10),-
		P1=(R5),-
		P2=#512,-
		P3=#1
	BLBC	R0,100$			; BR IF ERROR
	BLBC	I_SCRATCH+40(R10),100$	; BR IF IOSB ERROR
	BITW	#TS$NHD,L$BFLG(R5)	; NO HEADER?
	BEQL	100$			; IF EQL THEN ERROR
	BITW	#TS$ACP!TS$PMD!TS$SLV!TS$NSD!TS$SUP!TS$PRV!TS$RES,-
		L$BFLG(R5)		; ANYTHING ILLEGAL?
	BNEQ	100$			; IF NEQ THEN YES
	BITB	#LD$REL,R$LFLG(R8)	; REQUEST FOR A PIC LIB?
	BEQL	60$			; IF EQL THEN NO
	BITW	#TS$PIC,L$BFLG(R5)	; LIBRARY PIC?
	BEQL	100$			; IF EQL THEN ERROR
	BRB	70$
60$:	CMPW	L$BSA(R5),R$LSA(R8)	; REQUEST AND ACTUAL BASE ADDRESS MATCH?
	BNEQ	100$			; IF NEQ THEN ERROR
70$:	CMPW	L$BMXZ(R5),R$LMXZ(R8)	; REQUEST AND ACTUAL LENGTH THE SAME?
	BNEQ	100$			; IF NEQ THEN ERROR
	MOVL	I_L$BXLN(R10),R3	; OFFSET TO END OF LABEL BLOCK
	MOVZWL	L$BHRB(R5)[R3],R3	; GET RELATIVE BLOCK
	INCL	R3			; ADJUST FOR VIRTUAL COUNT
;
; CREATE A GROUP GLOBAL SECTION, IF POSSIBLE
;
	MOVZWL	#^X0FF0F,R2		; SET PROTECTION TO ALLOW GROUP AND OWNER ACCESS
	BSBB	200$			; TRY TO CREATE THE SECTION
	BLBS	R0,80$			; BRANCH IF OK
;
; IF THAT FAILS (DUE TO PRIVILEGE OR WHATEVER), CREATE A PRIVATE SECTION
;
	MOVZWL	#^X0F00F,R2		; SET PROTECTION TO ALLOW ONLY OWNER ACCESS
	BICW	#SEC$M_GBL,I_SCRATCH+32(R10) ; CREATE PRIVATE SECTION
	BSBB	200$			; TRY TO CREATE THE SECTION
	BLBC	R0,100$			; REPORT ANY ERRORS
80$:	$DASSGN_S	FAB$L_STV(R7)	; DEASSIGN CHANNEL TO RELEASE FILE
90$:	CMPL	ADR_LOWLIM(R6),I_HIGHSIZE(R10); SET UP HIGH ADDRESS OF ADR0
	BGTRU	95$			; 
	MOVL	(R6),I_HIGHSIZE(R10)
95$:	RSB				; PROCESS NEXT ENTRY
;
; ILLEGAL LIBRARY REFERENCE
;
100$:	MOVQ	I_SCRATCH(R10),-(SP)
	PUSHL	#2
	PUSHL	#RSX$_BADLIBREF
	PUSHL	#4
	CLRQ	-(SP)
	PUSHAB	8(SP)	
	CALLS	#3+5,@#SYS$PUTMSG	; OUTPUT MESSAGE
	$ABORT	#RSX$_LOADERROR
;
; CREATE A SECTION
;
200$:	$CRMPSC_S INADR=ADR_LOWLIM(R6),-
		FLAGS=I_SCRATCH+32(R10),-
		GSDNAM=I_SCRATCH(R10),-
		CHAN=FAB$L_STV(R7),-
		PAGCNT=I_SCRATCH+28(R10),-
		VBN=R3,-
		PROT=R2
	RSB
 
	.DSABL	LSB

	.END
