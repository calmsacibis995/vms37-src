	.TITLE	RSXPARSE - PARSE DIRECTIVE
	.IDENT	'V03-002'

;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;++
; FACILITY:
;
;	VAX/VMS RSX AME.
;
; ABSTRACT:
;
;	RSX11M PARSE DIRECTIVE.
;
; AUTHOR:
;
;	R.HEINEN 29-JUL-77
;
; PREVIOUSLY MODIFIED BY:
;
;	Tim Halvorsen
;	Michael S. Harvey
;	Peter H. Lipman
;
; MODIFIED BY:
;
;	V001	MSH020		Michael S. Harvey	17-Feb-82
;		Add support for 'funny' file names. Also, clean up
;		the documentation a bit so someone else can wade
;		through this module more easily than I did.
;
;	V002	MSH022		Michael S. Harvey	20-Feb-82
;		Handle negative versions correctly.
;
;--
;
; EXTERNAL SYMBOLS
;
	$RSXDEF				; DEFINE AME'S SYMBOLS
	FCSBT$				; DEFINE FCS BITS
	NBOFF$	DEF$L			; DEFINE NAME BLOCK
	$FABDEF				; DEFINE FAB
	$NAMDEF				; DEFINE NAME BLOCK RMS-32
	IOERR$				; DEFINE I/O ERRORS
;
; LOCAL MACRO
;
	.MACRO	RMSERR	A,B
	.BYTE	A
	.WORD	<B>&^X0FFFF
	.ENDM
;
; LOCAL DEFINITIONS:
;
	.PSECT	RSXDEF,ABS
.=0
P_FAB:	 .BLKB	FAB$C_BLN
P_FNAME: .BLKB	128			; EXPANDED STRING AREA (ESA)
P_NAMBLK:.BLKB	NAM$C_BLN
P_SIZE:	 
;
; OFFSETS INTO DPB
;
.=0
DPB_MODE:	.BLKW	1
DPB_LUN:	.BLKW	1
DPB_DSPT:	
DPB_PRIM:	.BLKW	1
DPB_DFNB:
DPB_DEFA:	.BLKW	1
DPB_DD:		.BLKW	1
DPB_FNB:	.BLKW	1
DPB_RETDIR:	.BLKW	1
	
	.PSECT	RSXPURE,LONG,EXE,NOWRT,SHR,PIC
PARSERRORS:				; RMS TO DSW ERROR TRANSLATE
	RMSERR	IE.BDV,RMS$_DEV		; BAD DEVICE
	RMSERR	IE.DNR,RMS$_DNR
	RMSERR	IE.DUN,RMS$_CHN		; CAN'T ASSIGN CHANNEL
	RMSERR	IE.BDI,RMS$_DIR
	RMSERR	IE.NSF,RMS$_DNF
	RMSERR	IE.NSF,RMS$_FNF
	RMSERR	IE.BNM,RMS$_SYN
	RMSERR	IE.BNM,RMS$_FNM
	RMSERR	IE.BNM,RMS$_LNE
	RMSERR	IE.BNM,RMS$_TYP
	RMSERR	IE.BNM,RMS$_VER
	.BYTE	0
 

	.PSECT	RSXCODE,NOWRT,SHR,PIC
	.SBTTL	RSX$PARS - RSX11M PARSE DIRECTIVE
;++
; RSX$PARS - RSX11M PARSE DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS DIRECTIVE IS INCLUDED IN THE VAX/VMS RSX AME TO GIVE THE RSX
; IMAGE WHO USES THE VAX/VMS VERSION OF FCS-11 OR RMS-11 THE ABILITY
; TO TRANSLATE LOGICAL NAME FILE SPECIFIERS.
; THIS ROUTINE IMPLEMENTS THIS DIRECTIVE.
;
; THE DPB FOR MODE 1,2,3 IS AS FOLLOWS:
;
;	.WORD	MODE
;	.WORD	LUN
;	.WORD	ADDR OF DSPT
;	.WORD	ADDR OF DFNB
;	.WORD	ADDR OF DEFAULT DIRECTORY
;	.WORD	ADDR OF FNB
;	.WORD	ADDR OF RETURN DIRECTORY DESC.
;
; THE DPB FOR MODE 4 (RMS-11) IS:
;
;	.WORD	3
;	.WORD	LUN
;	.WORD	ADDR OF PRIMARY DESC
;	.WORD	ADDR OF DEFAULT DESC
;	.WORD	MBZ
;	.WORD	ADDR OF FNB
;	.WORD	ADDR OF RETURNED DIRECTORY DESC
;
; INPUTS:
;
;	R5 = ADDRESS OF THE DPB
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA STORAGE
;	R11 = ADDRESS OF THE IMAGE HEADER
;
; OUTPUTS:
;
;	R10,R11 ARE PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	THE DSW AND PROPER SETTING OF THE C-BIT ARE CONSISTENT
;	WITH THE STATUS OF THE DIRECITVE.
;
; DSW RETURN CODES:
;
;--
RSX$PARS::				; RSX11M PARSE DIRECTIVE
	PUSHL	R6			; SAVE STACK
	MOVL	R5,R9			; COPY ADDRESS OF DPB
	MOVZWL	#P_SIZE,R1		; ALLOCATE THE BLOCK
	BSBW	RSX$ALLOCATE		;
	MOVL	R0,R8			; COPY ADDRESS OF THE BLOCK
;
; SET UP THE BLOCK
;
	MOVC5	#0,(R8),#0,#P_SIZE,(R8)	; ZERO BLOCK
	MOVAB	P_FNAME(R8),FAB$L_FNA(R8);
	MOVAB	P_NAMBLK(R8),FAB$L_NAM(R8);
	MOVAB	P_FNAME(R8),NAM$L_ESA+P_NAMBLK(R8);
	MOVB	#127,NAM$B_ESS+P_NAMBLK(R8)
	MOVAB	I_SCRATCH+8(R10),FAB$L_DNA(R8) ; DEF. FILESPEC STRING
	MOVB	#FAB$C_BID,FAB$B_BID(R8)
	MOVB	#FAB$C_BLN,FAB$B_BLN(R8)
	MOVB	#NAM$C_BID,NAM$B_BID+P_NAMBLK(R8)
	MOVB	#NAM$C_BLN,NAM$B_BLN+P_NAMBLK(R8)
;
; PROCESS REQUEST TYPE
;
	IFNORD	#14,(R9),BADPARAM	; BR IF ACCESS VIOLATION
	CASE	(R9),<NORMAL,DEVICE,FNB,RMS>
BADPARAM:
	PUSHAB	W^DONE			; EXIT TO DEALLOCATE THE BLOCK
	$DSWIO	#IE.BAD			; ERROR EXIT FOR BAD MODE

;
; RMS MODE - PRIMARY AND SECONDARY STRINGS ARE INPUT
;
RMS:	MOVZWL	DPB_PRIM(R9),R7		; GET PRIMARY STRING
	BEQL	50$			; IF EQL THEN NONE
;
; TRANSLATE DEVICE FROM PRIMARY STRING AND MOVE INTO ESA
;
	IFNORD	#4,(R7),BADPARAM	; BR IF ACCESS VIOLATION
	CVTBL	(R7),R6			; GET SIZE AS A BYTE
	BEQL	50$			; IF EQL THEN NONE
	BLSS	BADPARAM		; IF LSS THEN ERROR
	MOVZWL	2(R7),R7		; GET ADDRESS
	BSBW	REPLACE_DEVICE		; REPLACE DEVICE NAME ON STRING
	MOVL	I_SCRATCH(R10),R0	; GET SIZE OF THE STRING
	MOVB	R0,FAB$B_FNS(R8)	; INSERT SIZE
	MOVC3	R0,@I_SCRATCH+4(R10),P_FNAME(R8); MOVE STRING 
;
; TRANSLATE DEVICE FROM SECONDARY STRING AND MOVE TO DEFAULT FILESPEC
; STRING
;
50$:	CLRL	I_SCRATCH(R10)		; SET UP NULL DESC
	MOVAB	I_SCRATCH+8(R10),I_SCRATCH+4(R10);
	MOVZWL	DPB_DEFA(R9),R7		; INSERT DEFAULT DATA
	BEQL	60$			; IF EQL THEN NONE
	IFNORD	#4,(R7),BADPARAM	; BR IF ACCESS VIOLATION
	CVTBL	(R7),R6			; GET SIZE AS BYTE
	BEQL	60$			; IF EQL THEN NONE
	BLSS	BADPARAM		;
	MOVZWL	2(R7),R7		; GET ADDRESS
	BSBW	REPLACE_DEVICE		; REPLACE DEVICE PART OF STRING
	MOVB	I_SCRATCH(R10),FAB$B_DNS(R8); INSERT STRING SIZE
	BBS	#1,R3,80$		; BR IF DEVICE PRESENT ON STRING
;
; DEFAULT DEVICE NOT SPECIFIED, GET DEFAULT DEVICE FROM LUN IF POSSIBLE
;
60$:	MOVZBL	DPB_LUN(R9),R6		; GET LUN NUMBR
	BEQL	80$			; IF EQL THEN NONE
	CMPB	R6,I_NLUN(R10)		; IN RANGE?
	BGTRU	80$			; IF GTRU THEN NO
	MOVL	@I_LUT(R10)[R6],R6	; GET ADDRESS OF THE REAL NAME LUT
	BEQL	80$			; IF EQL THEN NOT ASSIGNED
	MOVL	I_SCRATCH(R10),R5	; SAVE SIZE OF DEFAULT STRING
	MOVZWL	LUT_ROOT_DEVNAM(R6),R0	; USE ROOT DEVICE NAME IF SET
	BEQL	70$			; BRANCH IF NOT, USE REAL NAME
	MOVZWL	LUT_ROOT_UNIT(R6),R1	; GET UNIT AS WELL
	BSBW	RSX$SRCHDEV_BIN		; LOOK FOR LOGICAL NAME MATCH
	BEQL	70$			; BRANCH IF FOUND, USE ITS REAL NAME
;
; PUT ASCII DEVICE NAME AT END OF NAME STRING,  LEAVE ROOM TO SLIDE NAME
; STRING DOWN AND THEN INSERT DEVICE STRING ON THE FRONT.
;
	MOVAB	I_SCRATCH+8+9(R10)[R5],R3; ADR OF END OF NAME STRING
					; + 9 TO LEAVE ROOM FOR LARGEST
					; DEVICE NAME FROM RSX$BLDASCDEV
	MOVL	R3,R7			; SAVE ADR OF BEGINNING OF DEVICE NAME
	BSBW	RSX$BLDASCDEV		; BUILD THE DEVICE NAME
	MOVB	#^A/:/,(R3)+		; INSERT COLON
	SUBL3	R7,R3,R6		; FORM SIZE OF DEVICE STRING
					; THIS IS KNOWN TO BE LEQ 9
	BRB	75$			;
70$:	MOVAB	LUT_REALNAME(R6),R7	; GET ADDRESS OF REAL NAME
	MOVZBL	(R7)+,R6		; GET THE SIZE
	INCL	R6			; PASS COLON TOO
75$:	ADDB	R6,FAB$B_DNS(R8)	; ADJUST SIZE
	BLSS	BADPARAM2		; IF LSS THEN ERROR
	MOVC3	R5,I_SCRATCH+8(R10),I_SCRATCH+8(R10)[R6]
	MOVC3	R6,(R7),I_SCRATCH+8(R10); INSERT DEVICE PART
80$:	BRW	PARSE			; PARSE

;
; FNB MODE - USE DFNB FILE NAME FOR PRIMARY STRING
;
; MOVE FILE NAME FROM THE DEFAULT FNB TO THE EXPANDED STRING AREA,
; CONVERTING IT FROM RAD50 TO ASCII IF NECESSARY, OR IF ALREADY
; AN ASCII STRING, ENCASING IT IN QUOTES.
;
FNB:	MOVAB	P_FNAME(R8),R7		; ADDRESS TARGET
	MOVZWL	DPB_DFNB(R9),R4		; ADDRESS FILE OF DFNB
	BEQL	10$			; IF EQL THEN NONE
	IFNOWRT	#N.UNIT+2,(R4),BADPARAM2; BR IF ACCESS VIOLATION
	PUSHL	R7			; SAVE START ADDRESS
	BITW	#NB.ANS,N.STAT(R4)	; ASCII "A" FORMAT?
	BNEQ	5$			; IF NEQ YES
	MOVAB	N.FNAM(R4),R4		;
	BSBW	RSX$R50CVT3		; CONVERT
	BRB	7$			; JOIN COMMON CODE
5$:	BSBW	RSX$ANSIRD		; EXTRACT AND ENCASE IN QUOTES
7$:	SUBL	(SP)+,R7		; CALCULATE STRING SIZE
	MOVB	R7,FAB$B_FNS(R8)	;
10$:	BRW	COMMONFCS		; CONTINUE IN COMMON

;
; NORMAL MODE PARSE FOR FCS-11
;
; DSPT PARAMETER CONSISTS OF 3 DESCRIPTORS OF ASCII STRINGS. THE
;	FIRST IS THE DEVICE STRING DESCRIPTOR, THE SECOND IS THE
;	DIRECTORY STRING DESCRIPTOR, AND THE THIRD IS THE FILENAME
;	STRING DESCRIPTOR.
; DFNB PARAMETER IS A STANDARD FCS FILE NAME BLOCK (FNB).
;
; RETURNS FNB AND DEFAULT DIRECTORY STRING
;
BADPARAM2:				;
	BRW	BADPARAM
COMMON2:BRW	COMMONFCS		;
DEVICE:					; ALSO DEVICE
NORMAL:					; NORMAL MODE
	MOVAB	P_FNAME(R8),R3		;
	MOVZWL	DPB_DSPT(R9),R7		; GET DSPT ADDRESS
	BEQL	COMMON2			; IF EQL THEN NONE SPECIFIED
	IFNORD	#12,(R7),BADPARAM2	; BR IF ACCESS VIOLATION
	CVTBL	(R7),R6			; GET SIGNED SIZE
	BEQL	5$			; IF EQL THEN NONE
	BLSS	BADPARAM2		; IF LSS THEN ERROR
	MOVZWL	2(R7),R7		; ADDRESS STRING
	IFNORD	R6,(R7),BADPARAM2	; IF NO READ THEN PADPARAM
;
; A COLON IS OPTIONAL IN FCS-11 DEVICE STRINGS -- APPEND IF NOT GIVEN.
;
	MOVC	R6,(R7),I_SCRATCH+40(R10) ; MOVE STRING TO WORK AREA
	CMPB	-1(R3),#^A':'		; TRAILING COLON?
	BEQL	1$			; BRANCH IF OK
	MOVB	#^A':',(R3)+		; APPEND COLON TO END OF STRING
1$:	MOVAB	I_SCRATCH+40(R10),R7	; STARTING ADDRESS OF STRING
	SUBL3	R7,R3,R6		; LENGTH OF DEVICE STRING
;
; REPLACE DSPT DEVICE STRING WITH RSX LOGICAL NAME. MOVE IT INTO THE
; EXPANDED STRING AREA.
;
	BSBW	REPLACE_DEVICE		; MAP TO RSX LOGICAL NAMES
	MOVB	I_SCRATCH(R10),FAB$B_FNS(R8); MOVE SIZE TO FAB
	BLSS	BADPARAM2		; IF SIGNED THEN ERROR
	MOVC3	I_SCRATCH(R10),@I_SCRATCH+4(R10),P_FNAME(R8); MOVE DEVICE NAME
	CMPB	#^A/:/,-1(R3)		; MOVED A COLON?
	BEQL	5$			; IF EQL THEN YES
	INCB	FAB$B_FNS(R8)		; ADJUST SIZE
	BLSS	BADPARAM2		;
	MOVB	#^A/:/,(R3)+		; INSERT COLON
;
; FOLLOW THE DEVICE STRING WITH THE DIRECTORY STRING AND SET UP TO
; FOLLOW THAT WITH THE FILENAME STRING.
;
5$:	MOVZBL	#2,R6			; SET UP LOOP COUNT
	MOVZWL	DPB_DSPT(R9),R7		; ADDRESS DATA
10$:	TSTL	(R7)+			; SKIP TO NEXT DSPT DESCRIPTOR
	CVTBL	(R7),R1			; GET STRING SIZE
	BEQL	15$			; IF EQL THEN NONE
	BLSS	BADPARAM2		; IF LSS THEN ERROR
	ADDB	R1,FAB$B_FNS(R8)	; ADJUST SIZE
	BLSS	BADPARAM2		; IF SIGNED THEN ERROR
	MOVZWL	2(R7),R2		; GET ADDRESS
	IFNORD	R1,(R2),BADPARAM2	; BR IF ACCESS VIOLATION
	BLBS	R6,15$			; COPY ONLY DIRECTORY STRING
	MOVC3	R1,(R2),(R3)		;   AND SKIP COPY OF FILENAME
15$:	SOBGTR	R6,10$			; CHECK NEXT DESCRIPTOR
;
; IF THE FILE NAME IS 'QUOTED', IT IS CONSIDERED TO BE AN ANSI "A"
; FILE NAME. IT IS ILLEGAL FOR A FILE NAME OF THIS FORM TO HAVE A
; TYPE FIELD, ALTHOUGH A VERSION NUMBER IS LEGAL. IF A VERSION NUMBER
; IS SPECIFIED, THE FILENAME MUST BE ENTIRELY ENCASED IN QOUTES (").
; IF THERE IS NO VERSION NUMBER, FCS-11 ALLOWS THE FINAL QUOTE TO
; BE OPTIONAL. IN PREPARATION FOR THE CALL TO $PARSE, THAT FINAL
; QUOTE MUST EXIST, SO THIS CODE WILL PUT ONE THERE IF NECESSARY.
; COMPLICATING MATTERS IS THE FACT THAT THE QUOTE CHARACTER ITSELF
; IS A LEGAL FILE NAME CHARACTER. THE CONVENTION IS THAT QUOTE
; CHARACTERS IN THE FILE NAME MUST BE REPRESENTED IN THE STRING AS
; DOUBLE QUOTES ("").
;
	TSTL	R1			; FILE NAME SPECIFIED?
	BEQL	COMMONFCS		; IF EQL NO
	CMPB	(R2),#^A/"/		; IS FILE NAME QUOTED?
	BNEQ	25$			; IF NEQ NO, STANDARD FILENAME
20$:	MOVB	(R2)+,(R3)+		; MOV FILENAME STRING CHARACTER
	DECL	R1			; MOVED WITHOUT CLOSING QUOTE?
	BEQL	30$			; IF EQL YES
	CMPB	(R2),#^A/"/		; IS NEXT CHARACTER A QUOTE
	BNEQ	20$			; IF NEQ NO, MOVE IT
	MOVB	(R2)+,(R3)+		; MIGHT BE CLOSING OR DOUBLE QUOTE
	DECL	R1			; CLOSING QUOTE?
	BEQL	COMMONFCS		; IF EQL YES, MOVED AND ENCASED
	CMPB	(R2),#^A/"/		; IS IT A FILENAME CHARACTER?
	BEQL	20$			; IF EQL MATCHED, YES IT IS
;
; COME HERE ON STANDARD FILE NAME, OR A SINGLE QUOTE WAS ENCOUNTERED
; AFTER THE FIRST ONE, INDICATING THE END OF THE QUOTED STRING.
; COPY THE REMAINDER OF THE UNSCANNED CHARACTERS WHOSE SYNTAX WILL
; BE VERIFIED BY $PARSE.
;
25$:	MOVC3	R1,(R2),(R3)		; MOVE REST OF STRING
	BRB	COMMONFCS		; PRIMARY STRING PREPARED
;
; COME HERE IF ENTIRE FILENAME WAS SCANNED WITHOUT EVER FINDING AN
; UNMATCHED QUOTE CHARACTER SIGNIFYING THE END OF THE FILENAME PART
; OF THE STRING. THIS IS THE OPTIONAL FCS-11 SYNTAX THAT MUST BE
; CORRECTED FOR $PARSE'S BENEFIT.
;
30$:	MOVB	#^A/"/,(R3)+		; ADD CLOSING QUOTE ON STRING
	INCB	FAB$B_FNS(R8)		; COUNT IT

;
; COMMON ENTRY FOR FCS-11 MODES
;
COMMONFCS:
	MOVAB	I_SCRATCH+8(R10),R3	; ADDRESS DEF. FILESPEC STRING
;
; CREATE AND MOVE DEFAULT DEVICE STRING TO DEFAULT FILESPEC STRING
;
	MOVZWL	DPB_DFNB(R9),R7		; ADDRESS DFNB
	BEQL	10$			; IF EQL THEN NONE
	IFNORD	#N.UNIT+2,(R7),28$	; BR IF ACCESS VIOLATION
	MOVZBL	N.UNIT(R7),R1		; GET UNIT FROM DNFB
	MOVW	N.DVNM(R7),R0		; GET NAME OF DEVICE
	BNEQ	20$			; IF NEQ THEN SPECIFIED
;
; GET DEFAULT DEVICE NAME FROM LUN IF NECESSARY (WAS NOT SPECIFIED
; IN DEFAULT FNB).
;
10$:	MOVZBL	DPB_LUN(R9),R6		; GET SPECIFIED LUN NUMBER
	BEQL	35$			; IF EQL THEN NONE
	CMPW	R6,I_NLUN(R10)		; IN RANGE?
	BGTRU	35$			; IF GTRU THEN NO
	MOVL	@I_LUT(R10)[R6],R6	; GET LUT ENTRY FOR LUN
	BEQL	35$			; IF EQL THEN NOT ASSIGNED
;
; IF THIS LUT ASSIGNMENT ORIGINALLY CAME FROM A ROOTED DEVICE, WE MUST
; GET THE LOGICAL NAME THAT TRANSLATES TO THE ROOTED DEVICE FOR $PARSE.
; THIS CATCHES LUNS ASSIGNED VIA AME-LOCAL LOGICAL NAMES (LIKE SY:)
; THAT ARE UNAVAILABLE TO RMS (SINCE THEY ARE NOT VMS LOGICAL NAMES).
; FOR EXAMPLE, IF A LUN IS ASSIGNED TO SY: AND SY: HAD BEEN ROOTED, THIS
; LUN'S LUT WILL HAVE A REALNAME EQUAL TO A DEVICE STRING WITHOUT THE
; ROOT DIRECTORY STRING. WE WANT THE REALNAME CONTAINING THE ROOT
; DIRECTORY, SO WE GO BACK TO THE ORIGINAL SY: LUT WHOSE REALNAME
; WILL TRANSLATE TO A DEVICE STRING WITH THE ROOT DIRECTORY STRING
; (IF SY: WAS ROOTED).
;
	MOVZWL	LUT_ROOT_DEVNAM(R6),R0	; USE ROOT DEVICE NAME IF SET
	BEQL	25$			; BRANCH IF NONE, USE REAL NAME
	MOVZWL	LUT_ROOT_UNIT(R6),R1	; GET UNIT NUMBER AS WELL
20$:	BSBW	RSX$SRCHDEV_BIN		; LOOK FOR LOGICAL NAME MATCH
	BNEQ	30$			; IF NEQ THEN NOT FOUND
25$:	MOVZBL	LUT_REALNAME(R6),R0	; GET REAL NAME TO INSERT
	INCL	R0			; MOVE COLON ALSO
	MOVC3	R0,LUT_REALNAME+1(R6),(R3); INSERT IT IN STRING
	BRB	35$			; CONTINUE

28$:	BRW	BADPARAM		;

30$:	BSBW	RSX$BLDASCDEV		; BUILD THE DEVICE NAME
	MOVB	#^A/:/,(R3)+		; INSERT COLON
35$:	SUBL3	FAB$L_DNA(R8),R3,R0	; GET SIZE OF STRING SO FAR
	MOVB	R0,FAB$B_DNS(R8)	; INSERT IT IN FAB
	BLSS	28$			; IF LSS THEN ERROR
;
; COPY DEFAULT DIRECTORY IF SPECIFIED TO DEFAULT FILESPEC STRING
;
	MOVZWL	DPB_DD(R9),R0		; ADDRESS DESC
	BEQL	38$			; IF EQL THEN NONE
	IFNORD	#4,(R0),28$		; BR IF ACCESS VIOLATION
	CVTBL	(R0),R1			; GET SIZE
	BEQL	40$			; IF EQL THEN NONE
	BLSS	28$			; IF LSS THEN ERROR
	MOVZWL	2(R0),R0		;
	IFNORD	R1,(R0),28$		; BR IF ACCESS VIOLATION
	ADDB	R1,FAB$B_DNS(R8)	; ADJUST SIZE
	BLSS	28$			; IF RESULT SIGNED THEN ERROR
	MOVC3	R1,(R0),(R3)		; INSERT IN STRING
	BRB	40$
;
;	IF NO DEFAULT DIRECTORY SPECIFIED, USE DID FROM NAM BLOCK
;
38$:
;	INSERT CODE HERE TO OBTAIN DIRECTORY NAME GIVEN FID
;	AND INSERT IT INTO THE FILE NAME STRING ENCLOSED IN
;	BRACKETS.  THIS IS BECAUSE $PARSE DOESN'T KNOW ABOUT
;	FID'S, ONLY STRINGS.
;
;	MOVL	N.DID(R7),NAM$W_DID+P_NAMBLK(R8) ; COPY DID
;	MOVW	N.DID+4(R7),NAM$W_DID+4+P_NAMBLK(R8)
;
;	INSERT FILE NAME AND VERSION
;
40$:	MOVL	R7,R4			; ADDRESS FNB
	BEQL	PARSE			; IF EQL THEN NONE
	MOVL	R3,R7			; ADDRESS TARGET OF MOVE
	BSBW	RSX$BLDFNAME		; CONSTRUCT FILENAME
	SUBL	R3,R7			; FIND ACTUAL SIZE
	ADDB	R7,FAB$B_DNS(R8)	; ADJUST TOTAL
	BLSS	28$			; IF LSS THEN ERROR

	.ENABL	LSB
;
; PARSE THE STRING
;
; AT THIS POINT, ALL ELP$ INPUT PATHS JOIN FOR RMS-32 TO PARSE THE
; VARIOUS FILESPEC PARTS. IMPORTANT INPUTS ARE:
;
;	R8 = FAB
;	FAB$L_FNA(R8) => P_FNAME(R8): EXPANDED PRIMARY STRING
;	FAB$L_DNA(R8) => I_SCRATCH+8(R10): DEFAULT FILESPEC STRING
;
PARSE:	ROTL	#31,#1,R2		; FIRST PARSE, LEAVE FNB ALONE
10$:	CLRQ	-(SP)			; SET UP ARGS
	PUSHL	R8			;
	CALLS	#3,G^SYS$PARSE		;
	TSTL	R2			; IF FIRST PARSE
	BLSS	15$			; THEN NO SAVED FNB BITS
	MOVB	R2,P_NAMBLK+NAM$L_FNB(R8) ; RESTORE "EXPLICIT" BITS FROM PREV PARSE
15$:	MOVAB	P_FNAME(R8),R7		; GET ADDRESS AND SIZE
	MOVZBL	P_NAMBLK+NAM$B_ESL(R8),R6 ; OF EXPANDED NAME STRING
	BLBC	R0,20$			; BRANCH IF ERROR FROM PARSE

	ASSUME	NAM$V_NODE GE 16
	BITW	#<NAM$M_NODE>@-16,P_NAMBLK+NAM$L_FNB+2(R8) ; IF SET,
	BEQL	30$
	MOVW	#<RMS$_SYN & ^XFFFF>,FAB$L_STS(R8) ; THEN TREAT LIKE A SYNTAX ERROR
	BRB	30$			; BUT DONOT TRY ANOTHER PARSE
;
; AN ERROR FROM PARSE WILL RESULT FROM A LOGICAL DEVICE NAME THAT
; TRANSLATES TO AN RSX DEVICE NAME LIKE "SY" OR "TI" SINCE PARSE DOES
; NOT HAVE ACCESS TO THE AME-LOCAL LOGICAL NAME TRANSLATIONS. TRY
; TRANSLATING THE DEVICE NAME USING THE AME-LOCAL LOGICAL NAME TABLE
; AND IF SUCCESSFUL, TRY ANOTHER PARSE. IF THE CONCEALED DEVICE BIT
; IS SET, THIS INDICATES THAT THE PARSE WAS PARTIALLY SUCCESSFUL (AT
; LEAST AS FAR AS THE DEVICE PARSE IS CONCERNED) AND THAT IT WON'T DO
; ANY GOOD TO TRY A SECOND PARSE.
;
20$:	BBS	#NAM$V_CNCL_DEV,P_NAMBLK+NAM$L_FNB(R8),30$ ; DON'T PARSE
	MOVQ	R6,-(SP)		; SAVE SIZE AND ADDRESS OF EXPANDED STRING
	BSBW	REPLACE_DEVICE		; REPLACE THE DEVICE NAME
					; NEW DESCRIPTOR IN I_SCRATCH(R10)
	MOVQ	(SP)+,R6		; RECOVER ORIGINAL STRING DESCRIIPTOR
;
; IF AME-LOCAL LOGICAL NAME TRANSLATION FAILED, THEN THE LOGICAL NAME
; IS TOTALLY UNKNOWN AND WE MUST LET THE PARSE FAIL.
;
	BBC	#1,R3,30$		; BR IF NO DEVICE FOUND
	BBC	#0,R3,30$		; BR IF NO CHANGE
;
; THE FIRST 8 BITS OF NAM$L_FNB CONTAIN THE "EXPLICIT" BITS WHICH
; SAY WHETHER CERTAIN FIELDS CAME FROM THE NAME STRING OR WERE
; DEFAULTED.  THESE BITS MUST BE PRESERVED.  ALL THE OTHERS WILL
; BE CORRECT FROM THE NEW PARSE.
;
	MOVZBL	P_NAMBLK+NAM$L_FNB(R8),R2 ; SAVE STATUS BITS
	CLRB	FAB$B_DNS(R8)		; SET NO DEFAULT
	MOVB	I_SCRATCH(R10),FAB$B_FNS(R8) ; SET SIZE AND ADDRESS
	MOVL	I_SCRATCH+4(R10),FAB$L_FNA(R8) ; OF STRING TO PARSE
	BRB	10$			; DO THE PARSE AGAIN
;
; THE STRING HAS BEEN PARSED
;
; FAB$L_STS = STATUS OF PARSE
; R6 = SIZE OF EXPANDED NAME STRING
; R7 = ADDRESS OF EXPANDED NAME STRING
;
30$:	BLBS	FAB$L_STS(R8),80$	; IF LOW SET THEN NO ERROR
	MOVZBW	#IE.BAD,H.DSW(R11)	; SET DEFAULT ERROR
	BISW	#1,I_PS(R10)		; SET CARRY BIT FOR USER
	MOVAB	W^PARSERRORS,R1		; TRANSLATE ERROR TO DSW FORM
40$:	CVTBL	(R1)+,R0
	BEQL	80$			; IF EQL THEN DEFAULT ERROR
	CMPW	FAB$L_STS(R8),(R1)+	; ERROR MATCH?
	BNEQ	40$			; IF NEQ THEN CONTINUE
	MOVZBW	R0,H.DSW(R11)		; INSERT ERROR
;
; NORMAL SUCCESSFUL CODE PATH COMES HERE
;
80$:	CLRL	(R8)			; SET NO DEVICE OR UNIT
	BLBC	FAB$L_STS(R8),100$	; IF PARSE ERROR,
					; DON'T WORRY ABOUT CONCEALED DEVICES
	MOVZBL	P_NAMBLK+NAM$B_DEV(R8),R0 ; GET SIZE OF DEVICE NAME STRING
	BEQL	110$			; BRANCH IF NO DEVICE PRESENT
;
; IF CONCEALED DEVICE OR ROOT DIRECTORY CONSTRUCT THE FULLY QUALIFIED NAME
;
	BBC	#NAM$V_CNCL_DEV,P_NAMBLK+NAM$L_FNB(R8),100$
	MOVL	R7,R1			; ADDRESS OF DEVICE NAME STRING
	SUBL	R0,R6			; STRIP OFF DEVICE NAME
	ADDL	R0,R7			; FROM THE RESULT STRING
	MOVQ	R0,I_SCRATCH(R10)	; DESCRIPTOR FOR DEVICE NAME TO TRANSLATE
	BSBW	RSX$TRANS_LOGIC		; TRANSLATE THE LOGICAL NAME
	MOVQ	I_SCRATCH(R10),R0	; GET DESCRIPTOR FOR EQUIVALENCE STRING
	MOVC3	R0,(R1),I_SCRATCH+8(R10) ; MOVE DEVICE AND POSSIBLE ROOT
	BBC	#NAM$V_ROOT_DIR,P_NAMBLK+NAM$L_FNB(R8),90$ ; BRANCH IF NO ROOT DIR
	MOVZBL	P_NAMBLK+NAM$B_DIR(R8),R2 ; SIZE OF DIRECTORY STRING
					; IN THE PARSE EXPANDED STRING
	MOVB	-(R3),-(R2)[R7]		; MOVE "]" OR ">" FROM END OF ROOT
					; TO END OF DIR STRING IN EXPANDED STRING
					; AND TAKE CLOSE BRACKET OUT OF NEW STRING
	INCL	R7			; DROP LEADING "[" OR "<"
	DECL	R6
	BBC	#NAM$V_GRP_MBR,P_NAMBLK+NAM$L_FNB(R8),90$ ; BR IF NOT "[G,M]" FORMAT
	MOVW	#^A/00/,-2(R7)		; LEAD 0'S ON TOP OF "[" AND PRECEEDING CHAR
	LOCC	#^A/,/,R2,(R7)		; POINT TO ","
	MOVL	-3(R1),(R3)+		; TAKE 3 PRECEEDING CHARS AND ","
	DECL	R3			; BACK OVER THE ","
	MOVW	#^A/00/,-1(R1)		; PUT LEAD 0'S OVER THE "," AND PRECEEDING CHAR
	ADDL	R0,R1			; POINT BEYOND CLOSE BRACKET
	MOVL	-(R1),(R3)+		; MOVE 3 DIGITS AND CLOSE BRACKET
	SUBL	R2,R6			; TAKE DIR STRING OFF THE
	ADDL	R2,R7			; EXPANDED STRING
90$:	MOVC3	R6,(R7),(R3)		; APPEND REST OF FILE SPEC
	MOVAL	P_FNAME(R8),R7		; ADDRESS TO PUT NEW EXPANDED STRING
	MOVAL	I_SCRATCH+8(R10),R1	; LOCATION TO MOVE IT FROM
	SUBL3	R1,R3,R6		; SIZE OF NEW RESULT STRING
	MOVC3	R6,(R1),(R7)		; PUT NEW RESULT STRING IN
					; THEN EXPANDED NAME BUFFER
;
; R6 = SIZE, R7 = ADDRESS OF EXPANDED NAME STRING.  PHYSICAL DEVICE NAME
; HAS REPLACED A CONCEALED DEVICE NAME AND ROOT DIRECTORY HAS BEEN 
; CONCATENATED WITH THE DIRECTORY SPEC.
;
100$:	CMPB	#^A/_/,(R7)		; STRIP OFF ANY LEADING UNDERSCORES
	BNEQ	120$			; BRANCH IF NO MORE
	DECL	R6			; ADJUST SIZE AND ADDRESS
	INCL	R7
	BRB	100$
110$:	BRW	210$
120$:	LOCC	#^A/:/,R6,(R7)		; FIND DEVICE NAME PORTION
	BEQL	110$			; BRANCH IF NO DEVICE NAME
	MOVQ	R6,-(SP)		; SAVE EXPANDED NAME DESCRIPTOR
	SUBL	R0,R6			; SIZE OF DEVICE NAME
	MOVQ	R6,I_SCRATCH(R10)	; SET DESCRIPTOR FOR DEVICE NAME
;
; SEE IF WE'VE ALREADY ENCOUNTERED THIS DEVICE BEFORE.  IF SO, USE THE
; DEVICE NAME AND UNIT NUMBER ALREADY DETERMINED FROM THE LAST TIME WE
; PARSED THIS DEVICE (AS AN OPTIMIZATION).
;
	BSBW	RSX$SRCHDEV_ASC		; SEARCH FOR DEVICE
	BNEQ	140$			; IF NEQ THEN NOT FOUND
	MOVZWL	LUT_INFONAME(R6),R0	; GET NAME AND UNIT
	MOVZBL	LUT_INFOUNIT(R6),R1	;
	BRB	200$			; CONTINUE
;
; WE'VE NEVER ENCOUNTERED THIS DEVICE BEFORE.  ALLOCATE A NEW ENTRY FOR
; THIS DEVICE AND BREAK IT DOWN INTO A 2-BYTE DEVICE NAME AND A 15 BIT
; UNIT NUMBER AND STORE THEM AWAY FOR NEXT TIME.  IF ITS A PROCESS PERMANENT
; FILE, THEN MAKE THE DEVICE NAME "$L" AND THE UNIT = THE IFI.
;
140$:	BBC	#NAM$V_PPF,P_NAMBLK+NAM$L_FNB(R8),170$; BR IF TRAN NOT PPF
	MOVZBL	#LUT_SIZE,R1		; ALLOCATE A LUT
	BSBW	RSX$ALLOCATE		;
	MOVL	R0,R6			; COPY BLOCK ADDRESS
	MOVC5	#0,(R6),#0,#LUT_SIZE,(R6);
	MOVC5	I_SCRATCH(R10),@I_SCRATCH+4(R10),#0,#15,LUT_REALNAME+1(R6)
	MOVB	I_SCRATCH(R10),LUT_REALNAME(R6);
	MOVW	#^A/$L/,LUT_INFONAME(R6);
	MNEGW	#1,LUT_RSXNAME(R6)	; SET NO RSX NAME
	ACBW	#255,#1,I_PPFINDEX(R10),150$; BR IF OK
	$ABORT	#RSX$_INSFDYNMEM	; ABORT IF OVERFLOW
150$:	MOVW	I_PPFINDEX(R10),LUT_INFOUNIT(R6)
	MOVB	#1@LUTV_PRM,LUT_FLAGS(R6);
	INSQUE	(R6),@I_LOGNAME+4(R10) ;
	MOVZWL	LUT_INFONAME(R6),R0	; SET UP NAME AND UNIT FOR FNB
	MOVZWL	LUT_INFOUNIT(R6),R1	;
	BRB	200$			; CONTINUE
170$:	MOVQ	I_SCRATCH(R10),R5	; GET SIZE AND ADDRESS OF DEVICE NAME
	BSBW	RSX$PARSEDEV		; FIND THE NAME/UNIT
200$:	MOVQ	(SP)+,R6 		; RESTORE REMAINDER SIZE AND ADDRESS
	MOVQ	R6,I_SCRATCH(R10)	; RESTORE ORIG DESCRIPTOR
	MOVQ	R0,(R8)			; SAVE IN USED FAB
210$:	CMPW	DPB_MODE(R9),#3		; RMS OR FCS MODE
	BEQL	240$			; IF EQL, RMS MODE
;
; MOVE ONLY DIRECTORY IN FCS MODES. OTHERWISE, DPB_RETDIR GETS
; AS MUCH OF THE ENTIRE EXPANDED STRING THAT WILL FIT INTO THE
; SPECIFIED BUFFER.
;
220$:	LOCC	#^A/[/,R6,(R7)		; LOOK FOR DIRECTORY
	BNEQ	230$			; IF NEQ THEN FOUND
	LOCC	#^A/</,R6,(R7)		; TRY OTHER DELIM
	BNEQ	230$			; IF EQL THEN FOUND
	CLRL	R6			; RETURN NO DIRECTORY
	BRB	240$			; CONTINUE
230$:	MOVQ	R0,R6			; SET UP REMAINDER AS RESULT
	ADDB3	#2,(R1),R0		; LOOK FOR MATCH
	LOCC	R0,R6,(R1)		; 
	BEQL	290$			; IF EQL THEN SYNTAX ERROR OF SOME KIND
	SUBL	R0,R6			; RETURN REMAINDER
	INCL	R6			; AND END DELIM
240$:	MOVZWL	DPB_RETDIR(R9),R5	; ADDRESS RETURN DIRECOTRY
	BEQL	290$			; IF EQL THEN NONE
	IFNOWRT	#4,(R5),250$		; BR IF ACCESS VIOLATION
	MOVZWL	(R5),R4			; GET SIZE
	MOVZWL	2(R5),R3		; GET ADDRESS
	IFNOWRT	R4,(R3),250$		; BR IF ACCESS VIOLATION
	BRB	260$			;
250$:	BRW	RETERROR		; RETURN
260$:	CMPW	R4,R6			; BUFFER LARGE ENOUGH FOR STRING?
	BLSS	270$			; IF LSS NO, TRUNCATE STRING
	MOVW	R6,(R5)			; STORE STRING LENGTH
270$:	LOCC	#^A/</,R6,(R7)		; RESET <> PAIR
	BEQL	280$			; IF EQL THEN NONE
	MOVB	#^A/[/,(R1)		;
	LOCC	#^A/>/,R6,(R7)		;
	BEQL	280$			;
	MOVB	#^A/]/,(R1)		;
280$:	MOVC5	R6,(R7),#0,R4,(R3)	; RETURN RESULT
;
; RETURN FNB
;
290$:	MOVZWL	DPB_FNB(R9),R9		; ADDRESS RETURN FNB
	BEQL	DONE			; IF EQL THEN NO RETURN
	IFNOWRT	#N.UNIT+2,(R9),RETERROR	; BR IF FAILURE
	MOVC5	#0,(R9),#0,#N.UNIT+2,(R9)
	MOVC3	#6,P_NAMBLK+NAM$W_DID(R8),N.DID(R9); RETURN DID
	MOVB	P_NAMBLK+NAM$L_FNB(R8),N.STAT(R9); RETURN DESC BITS
	BITL	#<NAM$M_WILD_UFD!NAM$M_WILD_SFD1!NAM$M_WILD_SFD2>,-
		P_NAMBLK+NAM$L_FNB(R8)	
	BEQL	300$			; IF EQL THEN NO ERROR
	MOVZBW	#IE.BDI,H.DSW(R11)	; SET ERROR CODE
	BISW	#1,I_PS(R10)		; SET C-BIT
300$:	
;
; MOVE FILE NAME TO FNB
;
	LOCC	#^A/]/,I_SCRATCH(R10),@I_SCRATCH+4(R10); LOOK FOR FILENAME START
	BNEQ	310$			; IF NEQ THEN FOUND
	LOCC	#^A/>/,I_SCRATCH(R10),@I_SCRATCH+4(R10)	;
	BNEQ	310$			; IF NEQ THEN FOUND
	LOCC	#^A/:/,I_SCRATCH(R10),@I_SCRATCH+4(R10)
	BNEQ	310$
	MOVQ	I_SCRATCH(R10),R0	; ASSUME ENTIRE STRING
	BRB	320$
310$:	INCL	R1
	DECL	R0
320$:	
	CLRB	(R1)[R0]		; SET END BYTE
	MOVL	R9,R4			; ADDRESS TARGET FNB
	MOVL	R1,R7			; COPY START ADDRESS
	CMPB	#^A/"/,(R1)		; ANSI "A" FILE NAME STRING?
	BNEQ	325$			; IF NEQ NO
	BISW2	#NB.ANS,N.STAT(R4)	; FORCE ANSI "A" RECOGNITION
325$:	BSBW	RSX$RETFNAME		; RETURN FILE NAME
330$:	MOVW	(R8),N.DVNM(R9)
	MOVW	4(R8),N.UNIT(R9)
DONE:	MOVZWL	#P_SIZE,R1		; RETURN FAB/NAME BLOCK
	MOVL	R8,R0			;
	POPR	#^M<R6>			; RESTORE STACK
	BRW	RSX$DEALLOCATE		;
RETERROR:				; ERROR IN RETURNING ARGS
	BRW	BADPARAM		; CONTINUE IN COMMON
	.DSABL	LSB

	.SBTTL	REPLACE_DEVICE - REPLACE DEVICE NAME ON STRING
;++
; REPLACE_DEVICE - REPLACE DEVICE NAME ON STRING
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE, GIVEN A FILE SPEC WILL REPLACE THE DEVICE PART WITH THE
; INFORMATION CONTAINED IN THE RSX LOGICAL NAME TABLE. IN ANY CASE THE 
; RESULTANT STRING IS BUILT IN THE SCRATCH AREA.
;
; INPUTS:
;
;	R6 = SIZE OF THE STRING
;	R7 = ADDRESS OF THE STRING
;
; OUTPUTS:
;
;	R0 = STATUS OF OPERATION (SYNTAX ERROR)
;
;	I_SCRATCH(R10) IS THE DESC OF THE RESULT
;
;	R3 = IF BIT 0 SET THEN CHANGE OCCURED
;	     IF BIT 1 SET THEN DEVICE NAME IS PRESENT
;
;	R4-R9 ARE PRESERVED.
;--
REPLACE_DEVICE:				; REPLACE DEVICE NAME
	PUSHR	#^M<R4,R5,R6,R7,R8,R9>
	CLRL	-(SP)			; SET FLAGS
	CLRL	I_SCRATCH(R10)		; SET NO STRING
	MOVAB	I_SCRATCH+8(R10),I_SCRATCH+4(R10); DESC
	LOCC	#^A/:/,R6,(R7)		; LOOK FOR DEVICE NAME
	BEQL	20$			; BRANCH IF NO DEVICE STRING
	CMPL	R0,#1			; LAST CHARACTER COLON?
	BLEQ	50$			; BRANCH IF NOT
	CMPB	#^A/:/,1(R1)		; NODE NAME?
	BNEQ	50$			; IF NEQ THEN NO
;
; NO DEVICE NAME FOUND OR NODE NAME WAS PRESENT
;
20$:	MOVL	R6,I_SCRATCH(R10)	; SET SIZE OF STRING
	MOVC3	R6,(R7),I_SCRATCH+8(R10) ; MOVE THE STRING OVER
	BRB	210$			; EXIT
;
; DEVICE NAME FOUND
;
50$:	MOVQ	R0,-(SP)		; SAVE REMAINDER OF STRING
	SUBL3	R0,R6,I_SCRATCH(R10)	; CALC DEVICE NAME SIZE
	MOVL	R7,I_SCRATCH+4(R10)	; INSERT ADDRESS
	CMPB	(R7),#^A/_/		; START WITH UNDERSCORE?
	BEQL	100$			; IF EQL THEN YES
	BSBW	RSX$SRCHDEV_ASC		; LOOK FOR MATCH
	BEQL	73$			; IF EQL THEN FOUND
	MOVQ	I_SCRATCH(R10),R5	; PARSE THE DEVICE NAME
	BSBW	RSX$PARSEDEV		;
	BSBW	RSX$SRCHDEV		;
	BNEQ	100$			; IF NEQ THEN NOT FOUND
73$:	MOVZBL	LUT_REALNAME(R6),R0	; GET REAL SIZE
	CMPL	R0,I_SCRATCH(R10)	; SIZES MATCH?
	BNEQ	75$			; IF EQL THEN NO
	CMPC	R0,(R7),LUT_REALNAME+1(R6) ; NAME MATCH?
	BEQL	80$			; IF EQL THEN NO NAME CHANGE
75$:	INCL	8(SP)			; SET NAME CHANGED FLAG
80$:	MOVZBL	LUT_REALNAME(R6),I_SCRATCH(R10)
	MOVAB	LUT_REALNAME+1(R6),R7
	TSTL	(SP)			; IF OTHER STRING THEN NO COLON
	BNEQ	100$			;
	INCB	I_SCRATCH(R10)		; MOVE COLON ALSO
	BLSS	300$			; IF LSS THEN ERROR - RETURN NOTHING
100$:	MOVC3	I_SCRATCH(R10),(R7),I_SCRATCH+8(R10);
	MOVAB	I_SCRATCH+8(R10),I_SCRATCH+4(R10)
	MOVQ	(SP)+,R0		; GET REMAINDER OF STRING
	ADDB	R0,I_SCRATCH(R10)	; ADJUST TOTAL SIZE
	BLSS	300$			; IF EQL THEN RETURN NOTHING
	MOVC3	R0,(R1),(R3)
	LOCC	#^A/:/,I_SCRATCH(R10),@I_SCRATCH+4(R10); ANY DEVICE NAME NOW?
	BEQL	210$			; IF EQL THEN NO
	BISB	#2,(SP)			; SET DEVICE NAME FOUND
210$:	POPR	#^M<R3,R4,R5,R6,R7,R8,R9> ;RESTORE REGS AND SET NAME CONTROL
	RSB
300$:	CLRL	I_SCRATCH(R10)		; SET NO RESULT
	CLRL	(SP)			;
	BRB	210$			; RETURN

	.SBTTL	RSX$BLDFNAME - BUILD FILENAME STRING FROM FNB
;++
; RSX$BLDFNAME - BUILD FILENAME STRING FROM FNB
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE BUILDS A FILE NAME STRING FROM A FNB. IF IT IS A
; NON-ANSI FILENAME, IT IS CONVERTED FROM RAD50 INTO AN ASCII
; STRING. OTHERWISE, IT IS COPIED FROM THE FNB WITH EMBEDDED QUOTES
; DOUBLED (TO INDICATE QUOTES THAT ARE FILE NAME CHARACTERS) AND
; ENCASED IN QUOTES. NOTE THAT THERE IS NO 'TYPE' FIELD FOR
; THIS TYPE, ALTHOUGH THE DOT MUST BE PRESENT. VERSION FIELDS ARE
; LEGAL FOR BOTH TYPES OF FNBS.
;
; INPUTS:
;
;	R4 = FNB
;	R7 = TARGET STRING
;
; OUTPUTS:
;
;	R0 = SIZE OF TARGET STRING
;	R7 = ADDRESS OF THE NEXT TARGET STRING BYTE
;
;	R2-R11 ARE PRESERVED
;--
RSX$BLDFNAME::				; BUILD FILENAME FROM FNB
	PUSHR	#^M<R2,R3,R4,R5,R6>	;
	MOVL	R7,R6			; COPY START ADDRESS
	BITW	#NB.ANS,N.STAT(R4)	; ANSI FILE NAME?
	BNEQ	5$			; IF NEQ YES
	MOVAB	N.FNAM(R4),R4		; ADDRESS FNB NAME
	BSBW	RSX$R50CVT3		; CONVERT FILE NAME
	MOVB	#^A/./,(R7)+		; INSERT .
	BSBW	RSX$R50CVT1		; CONVERT TYPE
	BRB	RSX$BLDVER		; PRODUCE VERSION STRING
5$:	PUSHAB	N.FVER(R4)		; SAVE ADDRESS OF VERSION FIELD
	BSBB	RSX$ANSIRD		; PROCESS AND EXTRACT FILE NAME
	POPR	#^M<R4>			; RECOVER VERSION FIELD ADDRESS

RSX$BLDVER::				; MOVE VERSION TO STRING
	MOVB	#^A/;/,(R7)+		; INSERT SEMICOLON
	CVTWL	(R4),R1			; GET VERSION NUMBER
	BGEQ	10$			; IF GEQ THEN PLUS
	MOVB	#^A/-/,(R7)+		; INSERT MINUS SIGN
	MNEGL	R1,R1			; CONVERT TO POSITIVE
	CMPW	R1,(R4)			; DID VALUE CHANGE?
	BNEQ	10$			; IF NEQ YES, NOT SPECIAL CASE
	CLRL	R1			; PROCESS ;-0 CORRECTLY
10$:	CLRL	R2			; RESET ACCUM
	MOVAB	5(R7),R3		; ADDRESS STRING END
	MOVL	R3,R0			; COPY END ADDRESS
15$:	EDIV	#10,R1,R1,R4		;
	ADDB3	#^A/0/,R4,-(R3)		; INSERT CHARACTER
	CMPL	R3,R7			; CONVERTED ENOUGH?
	BNEQ	15$			; IF NEQ THEN NO
	MOVL	R0,R7			; SET UP END ADDRESS
	SUBL3	R6,R7,R0		; CALC SIZE
	POPR	#^M<R2,R3,R4,R5,R6>	; RESTORE REGISTERS
	RSB				; RETURN
	.PAGE
	.SBTTL	COPY ANSI "A" FILENAME FROM FNB
;++
; RSX$ANSIRD - COPY ANSI "A" FILENAME FROM FILE NAME BLOCK
;
; FUNCTIONAL DESCRIPTION:
;
; THIS SUBROUTINE WILL EXTRACT AN ANSI "A" FILE NAME FROM AN FCS-11
; FILE NAME BLOCK (FNB). THE STRING WILL BE ENCASED IN QUOTES (") ON
; OUTPUT AND ALL QUOTES THAT ARE PART OF THE FILE NAME ITSELF WILL
; BE DOUBLED ON OUTPUT. A DOT IS INSERTED AFTER THE CLOSING QUOTE.
;
; INPUTS:
;
;	R4 = ADDRESS OF FILE NAME BLOCK
;	R7 = ADDRESS OF TARGET FILE NAME STRING
;
; OUTPUTS:
;
;	R7 = ADDRESS OF NEXT TARGET STRING BYTE
;
;	R3,R4 ARE DESTROYED, R7 IS MODIFIED
;	ALL OTHER REGISTERS PRESERVED
;--
RSX$ANSIRD::
	MOVB	#^A/"/,(R7)+		; INSERT OPENING QUOTE
	PUSHAB	N.ANM2(R4)		; SECOND PART OF FILE NAME
	MOVAB	N.ANM1(R4),R4		; POINT TO FIRST PART
	MOVZBL	#12,R3			; FIRST PART HAS 12 CHARACTERS
	BSBB	20$			; EXTRACT FIRST FILENAME PART
	POPR	#^M<R4>			; POINT TO SECOND PART OF FILENAME
	MOVZBL	#5,R3			; SECOND PART HAS 5 CHARACTERS
	BSBB	20$			; EXTRACT SECOND PART
	MOVW	#^A/"./,(R7)+		; INSERT CLOSING QUOTE AND DOT
	RSB				; FILE NAME EXTRACTION DONE

20$:	MOVB	(R4)+,(R7)		; MOVE A CHARACTER TO STRING
	CMPB	#^A/"/,(R7)+		; WAS IT A QUOTE CHARACTER?
	BNEQ	25$			; IF NEQ NO, GO TO NEXT
	MOVB	#^A/"/,(R7)+		; DOUBLE IT
25$:	SOBGTR	R3,20$			; CONTINUE UNTIL DONE
	RSB				; THIS PART DONE
	.PAGE
	.SBTTL	RSX$RETFNAME - RETURN FILENAME FROM ASCII TO FNB
;++
; RSX$RETFNAME - RETURN FILENAME FROM ASCII TO FNB
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE INSERTS AN ASCII FILENAME INTO A FILE NAME BLOCK. IF
; THE FNB IS NOT EXPECTING AN ANSI "A" FILE NAME, THEN THE FILE
; NAME STRING IS CONVERTED TO RAD50 AND STUFFED INTO THE FNB. IF
; THE FNB IS EXPECTING AN ANSI "A" FILE NAME, THEN THE STRING IS
; CONVERTED TO ONE, IF NECESSARY, AND STUFFED INTO THE FNB.
;
; INPUTS:
;
;	R0 = LENGTH OF FILENAME STRING
;	R4 = ADDRESS OF THE FNB
;	R7 = ADDRESS OF THE FILENAME STRING
;
; OUTPUTS:
;
;	R2-R11 ARE PRESERVED.
;--
RSX$RETFNAME::				;
	PUSHR	#^M<R2,R3,R4,R5,R6,R7,R8>
	PUSHL	R4			; SAVE FNB ADDRESS
	MOVL	R7,R1			; ADDRESS NAME STRING
	BITW	#NB.ANS,N.STAT(R4)	; FNB EXPECTING ANSI "A" FILENAME?
	BNEQ	10$			; IF NEQ YES
	CMPB	(R1),#^A/"/		; IS CONVERSION FROM ANSI "A" REQUIRED?
	BNEQ	20$			; IF NEQ NO, STANDARD CONVERSION
	BRW	70$			; CONVERT ANSI "A" TO RAD50

10$:	CMPB	(R1),#^A/"/		; ALREADY ANSI "A" FORMAT?
	BEQL	15$			; IF EQL YES, SIMPLY MOVE IT
	PUSHAB	N.ANM2(R4)		; SAVE ADDRESS OF SECOND PART
	MOVAB	N.ANM1(R4),R4		; POINT TO FIRST PART
	MOVZBL	#12,R3			; FIRST PART IS 12 CHARACTERS
	MNEGL	#1,R2			; SET NO PAD, NO DOT FLAGS
	BSBW	100$			; MOVE FIRST PART INTO FNB
	POPR	#^M<R4>			; POINT TO SECOND PART IN FNB
	MOVZBL	#5,R3			; SECOND PART IS 5 CHARACTERS
	BSBW	100$			; MOVE SECOND PART INTO FNB
	BRB	40$			; GO PROCESS VERSION NUMBER

15$:	INCL	R1			; SKIP OPENING QUOTE
	PUSHAB	N.ANM2(R4)		; SAVE ADDRESS OF SECOND PART
	MOVAB	N.ANM1(R4),R4		; POINT TO FIRST PART
	MOVZBL	#12,R3			; FIRST PART IS 12 CHARACTERS
	MNEGL	#1,R2			; SET BLANK FILL INHIBIT FLAG
	BSBW	90$			; MOVE FIRST PART TO FNB
	POPR	#^M<R4>			; POINT TO SECOND PART IN FNB
	MOVZBL	#5,R3			; SECOND PART IS 5 CHARACTERS
	BSBW	90$			; MOVE SECOND PART TO FNB
	TSTL	R2			; CLOSING QUOTE SKIPPED?
	BGEQ	40$			; IF GEQ YES, GO DO VERSION
	ADDL2	#2,R1			; SKIP CLOSING QUOTE AND TYPE DOT
	BRB	40$			; GO PROCESS VERSION NUMBER

20$:	MOVAB	N.FNAM(R4),R4		; ADDRESS TARGET FOR CONVERSION
	CLRL	R0			; SET DOT IS ILLEGAL
	BSBW	RSX$ASCR503		; CONVERT THREE WORDS
	CMPB	(R1),#^A/*/		; WILD CARD?
	BNEQ	30$			; IF NEQ THEN NO
	INCL	R1			; POINT TO NEXT FIELD
30$:	CMPB	(R1),#^A/./		; TYPE PRESENT?
	BNEQ	40$			; IF NEQ THEN TRY VERSION
	INCL	R1			; POINT TO TYPE
	CLRL	R0			;
	BSBW	RSX$ASCR501		; CONVERT TYPE FIELD
	CMPB	(R1),#^A/*/		; WILD CARD?
	BNEQ	40$			; IF NEQ THEN NO
	INCL	R1			; POINT TO NEXT FIELD
40$:	POPR	#^M<R4>			; RETREIVE FNB ADDRESS
42$:	CMPB	(R1),#^A/./		; DOT?
	BEQL	45$			; IF EQL THEN YES
	CMPB	(R1),#^A/;/		; SEMI COLON
	BNEQ	60$			; IF NEQ THEN DONE
45$:	CLRL	R0			; SET UP ACCUM
	INCL	R1			; SKIP DOT OR SEMICOLON
	CLRW	N.FVER(R4)		; SET UP VERSION ACCUM
	CLRL	-(SP)			; ASSUME POSITIVE VERSION NUMBER
	CMPB	(R1),#^A/-/		; NEGATIVE VERSION NUMBER?
	BNEQ	50$			; IF NEQ NO, STACKED SIGN IS +
	INCL	R1			; SKIP PAST MINUS SIGN
	ROTL	#15,#1,(SP)		; SET SIGN BIT FOR WORD
50$:	CMPB	(R1),#^A/0/		; LESS THAN ASCII 0
	BLSSU	55$			; IF LSSU THEN DONE
	CMPB	(R1),#^A/9/		; GTR THAN ASCII 9?
	BGTRU	55$			; IF GTRU THEN ALSO DONE
	MULW	#10,N.FVER(R4)		;
	SUBB3	#^A/0/,(R1)+,R0		;
	ADDW	R0,N.FVER(R4)		; ACCUM RESULT
	BRB	50$			;
55$:	MOVL	(SP)+,R3		; NEGATIVE VERSION VALUE?
	BEQL	60$			; IF EQL NO
	MNEGW	N.FVER(R4),N.FVER(R4)	; NEGATE IT
	BISW	R3,N.FVER(R4)		; HANDLE -0 CORRECTLY
60$:	POPR	#^M<R2,R3,R4,R5,R6,R7,R8>	;
	RSB				;

;
; COME HERE IF WE HAVE AN ANSI "A" FILE NAME STRING, BUT THE FILE
; NAME BLOCK IS NOT EXPECTING ONE. IN THIS CASE, THE STRING MUST
; BE CONVERTED INTO A RAD50 FILESPEC ACCORDING TO THE FOLLOWING
; ALGORITHM:
;
;	1) SKIP OPENING QUOTE
;
;	2) CREATE FILE NAME BY CONVERTING UP TO NINE ASCII
;		CHARACTERS OR UP TO THE FIRST ILLEGAL RAD50
;		CHARACTER, WHICHEVER COMES FIRST. A DOT IS
;		CONSIDERED TO BE ILLEGAL. IN THE LATTER CASE,
;		THE RAD50 FILE NAME IS PADDED OUT TO NINE CHARACTERS
;		WITH RAD50 SPACES.
;
;	3) IF THE NEXT CHARACTER IS A DOT, THEN SKIP IT AND BEGIN FILE
;		TYPE CONVERSION. IF NOT, THEN BEGIN FILE TYPE CONVERSION
;		FROM THE CURRENT POSITION. IF THE NEXT CHARACTER IS
;		ILLEGAL, THIS AUTOMATICALLY RESULTS IN A DEFAULT FILE
;		TYPE OF NULL VALUE.
;
;		FILE TYPE CONVERSION OCCURS BY CONVERTING UP TO THREE
;		MORE ASCII CHARACTERS OR UP TO THE NEXT ILLEGAL RAD50
;		CHARACTER, WHICHEVER COMES FIRST. AGAIN, A DOT IS
;		CONSIDERED TO BE ILLEGAL. AGAIN, IN THE LATTER CASE,
;		THE RAD50 TYPE FIELD IS PADDED OUT TO THREE CHARACTERS
;		WITH RAD50 SPACES.
;
;	4) SPAN TO THE END OF THE STRING, OR 1 CHARACTER PAST THE
;		CLOSING QUOTE, WHICHEVER COMES FIRST. IF THE QUOTE
;		WAS FOUND AND THE END OF THE STRING HAS NOT BEEN
;		REACHED, JOIN THE COMMON CODE ABOVE FOR HANDLING
;		THE VERSION NUMBER. IN ORDER FOR AN ANSI "A" FILESPEC
;		TO HAVE A VERSION NUMBER, IT MUST EXIST OUTSIDE THE
;		QUOTED PART OF THE STRING. ALSO, THE DOT FOLLOWING
;		THE CLOSING QUOTE AND PRECEDING THE SEMICOLON (OR
;		DOT) IS OPTIONAL AND MUST BE SKIPPED IF PRESENT.
;
70$:	INCL	R1			; SKIP OPENING QUOTE
	DECL	R0			; DON'T COUNT IT
	MOVAB	N.FNAM(R4),R4		; ADDRESS TARGET FOR CONVERSION
	PUSHR	#^M<R0,R7>		; SAVE FILENAME STRING DESCRIPTOR
	CLRL	R0			; SET DOT IS ILLEGAL
	BSBW	RSX$ASCR503		; CONVERT THREE WORDS
	CMPB	(R1),#^A/./		; TYPE FIELD PRESENT?
	BNEQ	74$			; IF NEQ MAYBE
	INCL	R1			; SKIP THE DOT
74$:	CLRL	R0			; DOT IS STILL ILLEGAL
	BSBW	RSX$ASCR501		; CONVERT TYPE FIELD
	POPR	#^M<R0,R7>		; RECOVER STRING DESCRIPTOR
	PUSHL	R1			; SAVE CURRENT STRING POSITION
	SUBL2	R1,R0			; NORMALIZE TO START OF STRING
	ADDL2	R7,R0			; CALC. REMAINING STRING LENGTH
	BLEQ	82$			; IF LEQ, NO VERSION POSSIBLE
78$:	CMPB	#^A/"/,(R1)		; CURRENTLY AT QUOTE CHARACTER?
	BEQL	80$			; IF EQL YES, SKIP IT
	LOCC	#^A/"/,R0,(R1)		; LOOK FOR MORE QUOTES
	BEQL	85$			; IF EQL, NO MORE QUOTES
80$:	INCL	R1			; SKIP PAST QUOTE CHARACTER
	MOVL	R1,(SP)			; STORE NEW STRING POSITION
	SOBGTR	R0,78$			; IF EQL, NO VERSION IN STRING
82$:	POPR	#^M<R1,R4>		; CLEAN UP STACK
	BRB	60$			; DONE

85$:	POPR	#^M<R1,R4>		; PREPARE FOR VERSION PROCESSING
	CMPW	(R1),#^A/../		; TYPE DOT PRESENT BEFORE VERSION?
	BEQL	87$			; IF EQL YES
	CMPW	(R1),#^A/.;/		; TYPE DOT PRESENT BEFORE VESRION?
	BNEQ	88$			; IF NEQ NO
87$:	INCL	R1			; SKIP TYPE DOT
88$:	BRW	42$			; PROCESS VERSION

;
; THIS SUBROUTINE MOVES PARTS OF AN ANSI "A" FILE NAME INTO A FNB
; THAT IS PREPARED FOR IT. IF NECESSARY, THIS ROUTINE WILL PAD THE
; FNB FIELD WITH ASCII SPACES AND COLLAPSE DOUBLE QUOTES IN THE
; FILE NAME STRING.
;
90$:	TSTL	R2			; PADDING REQUIRED?
	BGEQ	96$			; IF GEQ YES
92$:	MOVB	(R1)+,R2		; GET NEXT FILE NAME CHARACTER
	CMPB	#^A/"/,R2		; IS IT A QUOTE?
	BNEQ	93$			; IF NEQ NO, COPY IT TO FNB
	CMPB	#^A/"/,(R1)		; IS QUOTE PART OF FILE NAME?
	BNEQ	95$			; IF NEQ NO, FILE NAME COPIED
	MOVB	(R1)+,R2		; LOAD FILE NAME CHARACTER
93$:	MOVB	R2,(R4)+		; COPY FILE NAME CHARACTER
	SOBGTR	R3,92$			; GO GET NEXT CHARACTER
	RSB				; THIS SEGMENT DONE

95$:	MOVZBL	#^A/ /,R2		; SET UP FOR BLANK FILLING
	INCL	R1			; POINT PAST TYPE DOT
96$:	MOVB	R2,(R4)+		; COPY PADDING CHARACTER
	SOBGTR	R3,96$			; PAD TO END OF SEGMENT
	RSB				; THIS SEGMENT DONE
;
; THIS SUBROUTINE MOVES PARTS OF A STANDARD FILESPEC INTO A FNB
; THAT IS EXPECTING AN ANSI "A" FILESPEC. THE ROUTINE WILL PAD THE
; FNB FIELDS WITH ASCII SPACES AFTER MOVING THE FILENAME, TYPE
; DELIMITER, AND FILE TYPE.
;
100$:	TSTL	R2			; PADDING REQUIRED YET?
	BGEQ	106$			; IF GEQ YES
102$:	CMPB	(R1),#^A/;/		; ARE WE AT THE VERSION YET?
	BEQL	105$			; IF EQL YES, START PADDING
	CMPB	(R1),#^A/./		; TYPE OR VERSION DELIMITER?
	BNEQ	103$			; IF NEQ NO, MOVE CHARACTER
	TSTW	R2			; TYPE DELIMITER FOUND YET?
	BGEQ	105$			; IF GEQ YES, THIS MUST BE VERSION
	CLRW	R2			; SET TYPE DOT FOUND
103$:	MOVB	(R1)+,(R4)+		; MOVE THE CHARACTER
	SOBGTR	R3,102$			; CONTINUE UNTIL DONE
	RSB				; THIS PART DONE

105$:	MOVZBL	#^A/ /,R2		; START PADDING WITH SPACES
106$:	MOVB	R2,(R4)+		; MOVE SPACE INTO FNB
	SOBGTR	R3,106$			; CONTINUE UNTIL DONE
	RSB				; THIS PART DONE

	.SBTTL	RSX$BLDASCDEV - BUILD ASCII DEVICE NAME
;++
; RSX$BLDASCDEV - BUILD ASCII DEVICE NAME
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE GIVEN A DEVICENAME AND UNIT, BUILDS AN ASCII STRING
; CORRESPONDING TO THE DEVICENAME AND UNIT.
;
; THIS IS AN OCTAL CONVERTION.
;
; INPUTS:
;
;	R0 = TWO CHARACTERS OF ASCII NAME
;	R1 = UNIT NUMBER
;	R3 = TARGET OF THE CONVERT
;
; OUTPUTS:
;
;	R3 = ADDRESS OF THE NEXT DESTINATION BYTE
;
;	R2,R4,R5,R6,R7 ARE PRESERVED.
;--
RSX$BLDASCDEV::				; BUILD DEVICE NAME
	PUSHR	#^M<R2,R4,R5>		;
	MOVAB	8(R3),R4		; ADDRESS END OF STRING
	CLRB	(R4)			; SET ASCIZ
	CLRL	R2			; SET UP ACCUM
10$:	EDIV	#10,R1,R1,R5		; GET REMAINDER
	ADDB3	#^A/0/,R5,-(R4)		; INSERT
	TSTL	R1			; DONE?
	BNEQ	10$			; CONTINUE
	MOVW	R0,-(R4)		; INSERT NAME
	SUBL3	R3,R4,R5		; CALC MOVE SIZE
	SUBL3	R5,#8,R5		;
	MOVC3	R5,(R4),(R3)		; MOVE NAME BACK
	POPR	#^M<R2,R4,R5>		;
	RSB				;

	.SBTTL	RSX$BLDPHYDEV - BUILD PHYSICAL DEVICE NAME
;++
; RSX$BLDPHYDEV - BUILD PHYSICAL DEVICE NAME
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE GIVEN A DEVICENAME AND UNIT, BUILDS AN PHYSICAL DEVICENAME
; CORRESPONDING TO THE INPUT DEVICENAME AND UNIT.
; THE DEVICE NAME IS BUILT USING 2 ASCII CHARACTERS, A CONTROLLER AND
; A UNIT ON THAT CONTROLLER. THE CONTROLLER IS THE RESULT OF AN INTEGER
; DIVIDE OF THE UNIT BY 16.
;
; INPUTS:
;
;	R0 = TWO CHARACTERS OF ASCII NAME
;	R1 = UNIT NUMBER
;	R3 = TARGET OF THE CONVERT
;
; OUTPUTS:
;
;	R3 = ADDRESS OF THE NEXT DESTINATION BYTE
;
;	R2,R4,R5,R6,R7 ARE PRESERVED.
;--
RSX$BLDPHYDEV::				; BUILD DEVICE NAME
	PUSHR	#^M<R2,R4,R5,R6>	;
	MOVAB	7(R3),R4		; ADDRESS END OF STRING
	MOVZBL	R1,R1			; ASSURE OF ONLY BYTE
	CLRB	(R4)			; SET ASCIZ
	CLRL	R2			; SET UP ACCUM
	CLRL	R6			; PRESET CONTROLLER TO 'A'
	CMPW	R0,#^A'MB'		; MAILBOX DEVICE?
	BEQL	10$			; IF SO, FORCE CONTROLLER TO 'A'
	CMPW	R0,#^A'NV'		; PASS UNIT NUMBERS THROUGH?
	BEQL	10$			; IF EQL YES
	CMPW	R0,#^A'RT'		;
	BEQL	10$			; IF EQL YES
	EDIV	#16,R1,R6,R1		; GET THE CONTROLLER INDEX
10$:	EDIV	#10,R1,R1,R5		; GET REMAINDER
	ADDB3	#^A/0/,R5,-(R4)		; INSERT
	TSTL	R1			; DONE?
	BNEQ	10$			; CONTINUE
	ADDB3	#^A/A/,R6,-(R4)		; INSERT CONTROLLER
	MOVW	R0,-(R4)		; INSERT NAME
	SUBL3	R3,R4,R5		; CALC NAME SIZE
	SUBL3	R5,#7,R5		;
	MOVC3	R5,(R4),(R3)		; MOVE NAME BACK
	POPR	#^M<R2,R4,R5,R6>	;
	RSB				;

	.SBTTL	RSX$PARSEDEV - PARSE DEVICE NAME
;++
; RSX$PARSEDEV - PARSE DEVICE NAME STRING INTO NAME/UNIT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE, GIVEN AN ASCII DEVICE NAME STRING, RETURNS A
; TWO CHARACTER NAME AND A UNIT NUMBER THAT CONTAINS A CONTROLLER
; INDEX.
;
; INPUTS:
;
;	R5 = SIZE OF THE DEVICE NAME STRING
;	R6 = ADDRESS OF THE DEVICE NAME STRING
;
; OUTPUTS:
;
;	R0 = DEVICE NAME
;	R1 = UNIT
;
;	R2-R11 ARE PRESERVED.
;
;--
RSX$PARSEDEV::				; PARSE DEVICE NAME
	PUSHR	#^M<R2,R3>		;
	CLRL	R1			; ASSUME UNIT 0
	MOVL	#1,R3			; INITIALIZE MULTIPLIER
	MOVAB	(R6)[R5],R2		; ADDRESS END OF STRING
	CMPB	R5,#2			; 2 OR LESS CHARACTERS?
	BLEQU	30$			; IF YES THEN DONE
10$:	SUBB3	#^A/0/,-(R2),R0		; GET FIRST BYTE
	BLSS	20$			; IF LSS THEN END
	MOVZBL	R0,R0			; CLEAR MISC. JUNK IN UPPER BYTES
	CMPB	#9,R0			; NUMERIC?
	BLSSU	20$			; IF LSSU THEN NO
	MULL	R3,R0			; MULTIPLY
	ADDL	R0,R1			; ACCUM RESULT
	MULL	#10,R3			; CHANGE MULTIPLIER
	BRB	10$			; CONTINUE
20$:	SUBL3	R6,R2,R0		; GET REMAINING SIZE
	CMPL	R0,#3-1			; 3 CHARACTERS EXACTLY?
	BGTRU	40$			; IF MORE, NOT A VALID DEVICE
	BLSSU	30$			; IF LESS, NO CONTROLLER GIVEN
	SUBB3	#^A/A/,(R2),R0		; GET CONTROLLER INDEX
	BLSS	40$			; BRANCH IF NOT VALID DEVICE
	ASHL	#4,R0,R0		; MULTIPLY BY 16
	ADDL	R0,R1			; INSERT IN UNIT NUMBER
30$:	MOVZWL	(R6),R0			; GET DEVICE NAME
	BRB	50$			; EXIT
40$:	CLRQ	R0			; NOT A VALID DEVICE NAME
50$:	POPR	#^M<R2,R3>
	RSB

	.END
