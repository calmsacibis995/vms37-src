	.TITLE	RSXQIO -- RSX11M QIO DIRECTIVE
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:
;
;	VAX/VMS RSX11M AME
;
; ABSTRACT:
;
;	RSX11M QIO DIRECTIVE
;
; AUTHOR: R.HEINEN 4-NOV-76
;
; MODIFIED BY:
;
;	V002	TMH0002		Tim Halvorsen	20-Apr-1981
;		When faking AST in "deliver QIO", pass in a PC/PSL
;		of zero rather than random garbage on the stack in
;		order to ensure that the AST dispatcher doesn't think
;		we were in compatibility mode when the AST hit and
;		deliver the AST immediately (causing native exception).
;
;	V001	TMH0001		Tim Halvorsen	23-Mar-1981
;		Do not preset the IOSB to zero if its unspecified
;		(address = 0).  Fix references to QIO_FLAGS field
;		to be a word, not longword.
;--
;
; EXTERNAL SYMBOLS
;
	$RSXDEF			; DEFINE RSX SYMBOLS
	DRERR$			; DEFINE RSX11M DIRECTIVE STATUS CODES

	.SBTTL	RSX$QIO/RSX$QIOW - QIO DIRECTIVE DISPATCHER
 
	.PSECT	RSXCODE,NOWRT,SHR,PIC
	.ENABL	LSB
 
;++
; RSX$QIO - RSX11M QIO DIRECTIVE
; RSX$QIOW - RSX11M QIO AND WAIT DIRECTIVE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS A RSX DIRECTIVE HANDLER WHICH IMPLEMENTS AN RSX11M
; "QIO$" OR "QIOW$" DIRECTIVE.
;
; THE FIRST OPERATION IS TO CHECK FOR ALL THE ERROR CONDITIONS THAT
; CAUSE DSW ERRORS. THESE INCLUDE ILLEGAL LUNS, ILLEGAL EVENT FLAGS,
; AND IOSB ACCESS VIOLATIONS. 
;
; AFTER THE DSW ERROR CHECKS ALL ERRORS ARE RETURNED VIA THE I/O DONE
; STATUS POSTING LOGIC OF THE ROUTINES "RSX$DLVRQIOAST" AND 
; "RSX$IODONEAST". THESE ROUTINES FORM THE BASIS FOR THE I/O STATUS
; POST AND SUBSEQUENT AST DELIVERY TO THE IMAGE.
;
; CALLING SEQUENCE:
;
;	CALLED VIA JSB FROM "RSX$EXCEPTION".
;
; INPUT PARAMETERS:
;
;	R5 = ADDRESS OF DPB+2
;	R6 = CM IMAGE STACK ADDRESS
;	R10 = ADDRESS OF CM IMAGE DATA BASE
;	R11 = ADDRESS OF IMAGE HEADER
;
; IMPLICIT INPUTS:
;
;	THE DPB IS ALREADY VALIDATED FOR READ ACCESS.
;	THE DPB SIZE AND TYPE ARE CORRECT.
;
; OUTPUT PARAMETERS:
;
;	R6,R10,R11 ARE PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	THE PROPER DIRECTIVE STATUS IS PLACED IN THE IMAGE DSW
;	ALONG WITH THE PROPER SETTING OF THE C-BIT.
;
; COMPLETION CODES:
;
;	IS.SUC	SUCCESSFUL
;	IE.UPN	NO MEMORY FOR REQUEST
;	IE.ILU	ILLEGAL LUN NUMBER
;	IE.ULN	UNASSIGNED LUN
;	IE.IEF	ILLEGAL EFN
;	IE.ADP	IOSB ACCESS VIOLATION
;--
;
; QIO AND WAIT DIRECTIVE
;
RSX$QIOW::				; QIO AND WIAT DIRECTIVE
	PUSHAB	4(R5)			; SAVE EFN ADDRESS
	BSBB	RSX$QIO			; DO THE I/O
	POPL	R5			; GET THE EFN
	TSTB	H.DSW(R11)		; SUCCESS?
	BLSS	10$			; IF LSS THEN NOT SUCCESSFUL
	TSTW	(R5)			; ANY EFN?
	BEQL	10$			; IF EQL THEN NO
	BRW	RSX$WTSE		; DO WAIT FOR
10$:	RSB				; RETURN
;
; IEILU - ILLEGAL LUN NUMBER
;
IEILU:	$DSW	#IE.ILU			; SET STATUS AND RETURN
;
; IEULN - ILLEGAL LUN NUMBER
;
IEULN:	$DSW	#IE.ULN			; SET STATUS AND RETURN
;
; IOSB ODD ADDRESS
;
IEADP:	$DSW	#IE.ADP			;
;
; DPB ACCESS VIOLATION
;
IESDP:	$DSW	#IE.SDP			;
;
; QIO (NO WAIT) DIRECTIVE
;
RSX$QIO::				; QIO DIRECTIVE
	MOVZWL	(R5)+,R7		; GET FUNCTION CODE FOR LATER
	MOVZWL	(R5)+,R0		; GET LUN NUMBER
	BEQL	IEILU			; IF EQL THEN ERROR
	CMPW	R0,I_NLUN(R10)		; LUN NUMBER IN RANGE?
	BGTRU	IEILU			; INVALID LUN - POST ERROR
	MOVL	@I_LUT(R10)[R0],R8	; ADDRESS LUT ENTRY
	BEQL	IEULN			; IF EQL THEN UNASSIGNED
	MOVZBL	(R5)+,I_SCRATCH+4(R10)	; GET EFN SPECIFIED
	BEQL	5$			; IF EQL THEN NO ADJUSTMENT NEEDED
	ACBL	I_HIGHEFN(R10),#31,I_SCRATCH+4(R10),5$; ADJUST TO MAP EFN AND CHECK IT
	$DSW	#IE.IEF			; ILLEGAL EVENT FLAG
5$:	INCL	R5			; BYPASS PRIORITY BYTE
	MOVZWL	(R5),R0			; ADDRESS IOSB
	BLBS	R0,IEADP		; CHECK FOR ODD ADDRESS
	BEQL	8$			; SKIP ZERO IF IOSB UNSPECIFIED
	CLRL	(R0)			; ZERO IOSB 
8$:	TSTW	12(R5)			; CHECK DPB BEFORE ACCESS
	MOVAB	W^RSX$IODONEAST,I_SCRATCH+20(R10); SET UP AST SERVICE
	BSBW	RSX$SETUPAST		; SET UP AN AST CONTROL BLOCK
	CLRW	QIO_FLAGS(R2)		; CLEAR FLAGS 
	MOVL	R2,I_SCRATCH+24(R10)	; ADDRESS AST PARAMETER
	MOVAQ	QIO_IOSB(R2),I_SCRATCH+16(R10); SAVE AREA IN BLOCK AS IOSB
	MOVL	(R5)+,ACB_UPRM(R2)	; SAVE HIS IOSB AND AST ADDRESS
	CLRW	ACB_FLAGS(R2)		; SET NO SPECIAL TYPE
	MOVL	R8,QIO_LUT(R2)		; SAVE LUT ADDRESS
	ASHL	#-8,R7,R3		; GET THE MAJOR FUNCTION CODE
	MOVZWL	(R5),I_SCRATCH+28(R10)	; P1=RSX P1
	MOVZWL	2(R5),I_SCRATCH+32(R10)	; P2=RSX P2
	MOVW	8(R5),I_SCRATCH+36(R10)	; INSERT RSX#5 AND #6 TO VAX/VMS#3
	MOVW	6(R5),I_SCRATCH+38(R10)	;
	MOVZWL	4(R5),I_SCRATCH+40(R10)	; P4= RSX P3
	CLRQ	I_SCRATCH+44(R10)	; NO VAX/VMS#5 OR 6
;
; ENTER DRIVER MODULE
;
	MOVZBL	#SS$_NORMAL,R0		; ASSUME NORMAL COMPLETION
	CLRL	R1			; NO STATUS
DRV_DISPATCH:				; DISPATCH TO DRIVER
	CASE	TYPE=B,LUT_TYPE(R8),<-	;
		RSX$RMS_DRV,-		; 0= RMS
		RSX$TTY_DRV,-		; 1= TTY
		RSX$DSK_DRV,-		; 2= DISKS
		RSX$MT_DRV,-		; 3= TAPES
		RSX$LP_DRV,-		; 4= LP
		RSX$CR_DRV,-		; 5= CR
		>
	BRW	RSX$UKN_DRV		; UNKNOWN DEVICE

	.SBTTL	RSX$CHK_TI - CHECK FOR TI INPUT OR OUTPUT
 
	.ENABL	LSB
;++
; RSX$CHK_TI_INP - CHECK FOR TI INPUT
; RSX$CHK_TI_OUT - CHECK FOR TI OUTPUT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE DIRECTS TI I/O TO THE PROPER DEVICE BASED ON THE DIRECTION
; OF THE I/O.
;
; INPUTS:
;
;	R8 = ADDRESS OF THE CURRENT LUT
;
; OUTPUTS:
;
;	R8 = CORRECT LUT FOR THE I/O
;
; CONTROL IS RETURNED TO THE CALLER IF THE I/O IS PROPER
; OTHERWISE, THE PROPER DRIVER IS ENTERED.
;--
RSX$CHK_TI_INP::			; CHECK FOT TI INPUT
	MOVAB	W^RSX$A_TIIDEV,R0	; ADDRESS THE PROPER LUT FOR TI INPUT
	BRB	10$			; CONTINUE IN COMMON
RSX$CHK_TI_OUT::			; CHECK FOR TI OUTPUT
	MOVAB	W^RSX$A_TIODEV,R0	; ADDRESS THE PROPER LUT FOR TI OUTPUT
10$:	CMPW	#^A/TI/,LUT_RSXNAME(R8)	; TI?
	BNEQ	20$			; IF NEQ THEN OK
	CMPL	R0,R8			; SAME?
	BEQL	20$			; IF EQL THEN OK
	TSTL	(SP)+			; REMOVE THE RETURN ADDRESS
	MOVL	R0,R8			; RESET LUT ADDRESS
	BRB	DRV_DISPATCH		; DISPATCH AGAIN
20$:	RSB
 
	.DSABL	LSB

	.SBTTL	RSX$IEIFC - ILLEGAL I/O FUNCTION
;++
; RSX$IEIFC - ILLEGAL I/O FUNCTION
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE COMPLETES I/O OPERATIONS WITH ILLEGAL FUNCTION CODES.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE QIO CONTEXT
;	R6 = ADDRESS OF THE IMAGE STACK
;	R8 = ADDRESS OF THE LUT
;	R10 = ADDRESS OF THE IMAGE IMPURE AREA
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	R6,R10,R11 ARE PRESERVED.
;--
RSX$IEIFC::				; ILLEGAL I/O FUNCTION
	MOVZWL	#SS$_ILLIOFUNC,R0	; SET STATUS
	CLRL	R1
	BRB	RSX$DLVRQIOAST		;

	.SBTTL	RSX$IOKILL - DEVICE INDEPENDENT IO.KIL FUNCTION
;++
; RSX$IOKILL - KILL I/O ON DEVICE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED TO PERFORM KILL I/O FUNCTIONS ON DEVICES
; THAT DO NOT REQUIRE SPECIAL ATTENTION.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE QIO CONTEXT BLOCK
;	R5 = ADDRESS OF QIO DPB
;	R6 = INAGE STACK POINTER
;	R8 = ADDRESS OF THE LUT
;	R10 = ADDRESS OF THE IMAGE IMPURE POINTER
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	R2,R6,R8,R10,R11 ARE PRESERVED.
;--
RSX$IOKILL::				; KILL I/O
	$CANCEL_S	LUT_CHAN(R8)	; KILL THE I/O
	MOVZBL	#SS$_NORMAL,R0		; SET SUCCESS STATUS

	.SBTTL RSX$DLVRQIOAST - DELIVER AST TO COMPLETE I/O
;++
; RSX$DLVRQIOAST - DELIVER AST TO COMPLETE I/O
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE DECLARES AN AST FOR I/O POST PROCESSING IN ORDER TO
; TRANSLATE THE STATUS.
; IT IS USED ONLY AS A BAILOUT IN THE CASE THAT THE REQUEST FAILED.
; AND THE FAILURE WAS NOT AN RSX11M DIRECTIVE ERROR.
; THE I/O SPECIFIED EVENT FLAG MUST BE SET IF THE ENTRY IS TO RSX$DLVRQIOASTS.
;
; INPUTS:
;
;	R0 = ERROR CODE TO DELIVER 
;	R1 = SECOND STATUS TO DELIVER
;	R2 = AST PARAMETER BLOCK FOR QIO
;	R6 = IMAGE STACK POINTER
;	R8 = LUT ENTRY ADDRESS
;	R10 = ADDRESS OF THE IMAGE DATA BASE
;	R11 = ADDRRESS OF THE IMAGE HEADER
;
;	I_SCRATCH+4 CONTAINS THE EFN TO SET
;
; OUTPUTS:
;
;	R6,R10,R11 ARE PRESERVED.
;
; IF NO SPACE IS AVAILABLE FOR THE DECLARE THEN IE.UPN IS RETURNED
; AS A DSW ERROR.
;--
RSX$DLVRQIOAST::			; DELIVER AST TO IMAGE
	MOVQ	R0,QIO_IOSB(R2)		; SAVE STATUS
	$SETEF_S	I_SCRATCH+4(R10); SET THE EVENT FLAG
	CLRQ	-(SP)			; FAKE A NATIVE MODE AST (CM BIT = 0)
	CLRQ	-(SP)			; AND PASS R0/R1 = ZERO
	PUSHL	R2			; SET UP CONTEXT BLOCK ADDRESS
	CALLS	#5,W^RSX$IODONEAST	; FAKE AST
	RSB				; RETURN

	.SBTTL	RSX$ISSUQIO - ISSUE QIO
;++
; RSX$ISSUQIO - ISSUE QIO BASED ON SET UP PARAMETERS
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE COMPLETES AN I/O OPERATION THAT HAS BEEN SET UP BY
; OTHER QIO SUBROUTINES. THE QIO DATA IS IN I_SCRATCH 
;
; INPUT:
;
;	R2 = ADDRESS OF THE QIO CONTEXT BLOCK
;	R6 = IMAGE STACK ADDRESS
;	R8 = LUT ENTRY ADDRESS
;	R10 = ADDRESS OF THE IMAGE DATA BASE
;	R11 = ADDRESS OF THE IMAGE HEADER
;
; IMPLICIT INPUTS:
;
; THE QIO ARGUMENT LIST LESS LIST HEADER IS SET UP IN THE IMAGE DATA
; BASE.
; THE ADDRESS OF THE ACTUAL SYSTEM QIO ROUTINE ( WAIT OR NOT ) IS IN I_SCRATCH+50
;
; OUTPUTS:
;
;	R6,R10,R11 ARE PRESERVED.
;--
RSX$ISSUQIO::				; ISSUE QIO 
	MOVL	LUT_CHAN(R8),I_SCRATCH+8(R10); SET THE CHANNEL NUMBER
	MOVZBL	#12,I_SCRATCH(R10)	; SET NUMBER OF PARAMS
	CALLG	I_SCRATCH(R10),@#SYS$QIO; DO FUNCTION
	BLBC	R0,RSX$DLVRQIOAST	; IF ERROR THEN POST
	RSB				; OTHERWISE RETURN
;
	.END
