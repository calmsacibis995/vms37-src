	.TITLE	RSXFLOAT PDP-11 FLOATING POINT UNIT EMULATION
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:
;
;	VAX/VMS RSX11M AME.
;
; ABSTRACT:
;
;	PDP-11 FLOATING POINT UNIT INSTRUCTION EMULATION ROUTINES.
;
; AUTHOR:	D.P. RODGERS 17-JAN-1977
;
; MODIFIED BY:
;
;	V002	MSH016	Michael S. Harvey	8-Feb-1982
;		Always return carry bit set on conversion errors,
;		regardless of the polarity of the trap on
;		conversion status bit.
;
;	V001	TMH0001		Tim Halvorsen	29-Sep-1980
;		Accept faults for COMET (780 generates traps, not faults)
;		in floating point emulation and process the faults
;		(overflow, divzero and underflow) in the same manner
;		as floating traps.
;--
;
; EXTERNAL SYMBOLS
;
 
	$PSLDEF				; DEFINE PROCESSOR STATUS FIELDS
	$RSXDEF				; DEFINE RSX SYMBOLS
	$SSDEF				; DEFINE SYSTEM STATUS VALUES
 
;
; LOCAL SYMBOLS
;
; DEFINE SYMBOLS FOR SIMULATED FLOATING POINT STATUS REGISTERS
;
; ERROR CODES
;
 
FEC_OPCODE=2
FEC_DIVBYZERO=4
FEC_INTCONV=6
FEC_OVERFLOW=8
FEC_UNDERFLOW=10
FEC_UNDEFINED=12
FEC_MAINTTRAP=14
 
;
; STATUS BITS
;
 
FSRV_FER=15				; FLOATING ERROR SUMMARY
FSRM_FER=1@FSRV_FER
FSRV_FID=14				; FLOATING INTERRUPT DISABLE
FSRM_FID=1@FSRV_FID
FSRV_FIUV=11				; FLOATING INTERRUPT ON UNDEFINED VARIABLE
FSRM_FIUV=1@FSRV_FIUV
FSRV_FIU=10				; FLOATING INTERRUPT ON UNDERFLOW
FSRM_FIU=1@FSRV_FIU
FSRV_FIV=9				; FLOATING INTERRUPT ON OVERFLOW
FSRM_FIV=1@FSRV_FIV
FSRV_FIC=8				; FLOATING INTERRUPT ON INTEGER CONVERSION
FSRM_FIC=1@FSRV_FIC
FSRV_FD=7				; FLOATING DOUBLE MODE
FSRM_FD=1@FSRV_FD
FSRV_FL=6				; FLOATING LONG INTEGER MODE
FSRM_FL=1@FSRV_FL
FSRV_FT=5				; FLOATING TRUNCATE MODE
FSRM_FT=1@FSRV_FT
FSRV_FMM=4				; FLOATING MAINTENANCE MODE
FSRM_FMM=1@FSRV_FMM
 
;
; SOURCE DESTINATION FLAG (0=SOURCE, 1 =DESTINATION)
;
 
V_OPRND=31				; 
	.PAGE
	.SBTTL	RSX$FLOAT - FLOATING POINT INSTRUCTIONS
;++
; RSX$FLOAT - FLOATING POINT EMULATION FOR COMPATIBILITY MODE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED AFTER A RESERVED INSTRUCTION TRAP OCCURS
; AND THE PC POINTS AT AN INSTRUCTION WHOSE VALUE IS GEQU THAN OCTAL 170000.
;
; THE IMAGE IMPURE DATA BASE CONTAINS THE CONTEXT FOR THE PSEUDO FLOATING
; PROCESSOR. 
;
;	I_FLOATCSR	-- FLOATING CSR
;	I_FLOATERR	-- ERROR SUMMARY
;	I_FLOATADR	-- FLOATING POINT INSTRUCTION PC
;	I_FLOATA0/I_FLOATA5  -- 64 BIT REGISTERS
;
; INPUTS:
;
;	R8 = FLOATING POINT INSTRUCTION
;	R10 = ADDRESS OF THE AME CONTEXT PAGE
;
; OUTPUTS:
;
;	R0 = 0, ERROR
;		I_FLOATERR CONTAINS THE FLOATING ERROR TYPE
;
;	R0 # 0, COMPATIBILITY MODE ERROR VALUE SUCH AS "RSX$_ACCVIO"
;		FOR ACCESS VIOLATION.
;--
 
	.PSECT	RSXCODE,NOWRT,SHR,PIC,LONG
RSX$FLOAT::				; FLOATING POINT UNIT EMULATION
	MOVW	I_PC(R10),I_FLOATADR(R10); SAVE INSTRUCTION ADDRESS
	ADDL	#2,I_PC(R10)		; UPDATE PC
;
; PRIMARY FLOATING OPCODE DISPATCH
;
 
	ROTL	#32-8,R8,R0		; SWAP OPCODE BYTES
	BICL3	#^C7,R8,R9		; EXTRACT REGISTER NUMBER
	EXTZV	#3,#3,R8,R2		; EXTRACT ADDRESS MODE
	EXTZV	#6,#2,R8,R1		; EXTRACT FAC NUMBER
	BISPSW	I_FLOATCSR+2(R10)	; ESTABLISH CORRECT UNDERFLOW ENABLE
	BBS	#FSRV_FD,I_FLOATCSR(R10),10$ ; IF SET, FLOATING DOUBLE MODE
	CASE	R0,LIMIT=#-16,TYPE=B,<-
	STATUS_OP,-
	UNARY_OPF,-			; CLRF,TSTF,ABSF,NEGF
	MULF,-
	MODF,-
	ADDF,-
	LDF,-
	SUBF,-
	CMPF,-
	STF,-
	DIVF,-
	STEXP,-
	STCFX,-				; STCFI OR STCFL
	STCFD,-
	LDEXP,-
	LDCXF,-				; LDCIF, OR LDCLF
	LDCDF>
10$:	CASE	R0,LIMIT=#-16,TYPE=B,<-
	STATUS_OP,-
	UNARY_OPD,-			; CLRD,TSTD,ABSD,NEGD
	MULD,-
	MODD,-
	ADDD,-
	LDD,-
	SUBD,-
	CMPD,-
	STD,-
	DIVD,-
	STEXP,-
	STCDX,-				; STCDI OR STCDL
	STCDF,-
	LDEXP,-
	LDCXD,-				; LDCID OR LDCLD
	LDCFD>
	BRW	ILLEGAL_OP		; IMPOSSIBLE
 
;
; SECONDARY DISPATCH FOR STATUS OPCODES
;
 
STATUS_OP:				;
	CASE	R8,TYPE=B,<-
	CFCC,-				; 170000
	SETF,-				; 170001
	SETI,-				; 170002
	ILLEGAL_OP,-			; 170003
	ILLEGAL_OP,-			; 170004
	ILLEGAL_OP,-			; 170005
	ILLEGAL_OP,-			; 170006
	ILLEGAL_OP,-			; 170007
	ILLEGAL_OP,-			; 170010
	SETD,-				; 170011
	SETL>				; 170012
	BICL3	#^C7,R8,R9		; EXTRACT REGISTER NUMBER
	EXTZV	#3,#3,R8,R2		; EXTRACT ADDRESS MODE
	CMPB	#^O300,R8
	BLEQU	STST			; 1703DD
	CMPB	#^O200,R8
	BLEQU	STFPS			; 1702DD
	CMPB	#^O100,R8
	BLEQU	LDFPS			; 1701SS
	BRW	ILLEGAL_OP
 
;
; DISPATCH SINGLE PRECISION UNARY OPCODES
;
 
UNARY_OPF:
	CASE	R1,TYPE=B,<-
	CLRF,-
	TSTF,-
	ABSF,-
	NEGF>
	BRW	ILLEGAL_OP		; IMPOSSIBLE
 
;
; DISPATCH DOUBLE PRECISION UNARY OPCODES
;
 
UNARY_OPD:
	CASE	R1,TYPE=B,<-
	CLRD,-
	TSTD,-
	ABSD,-
	NEGD>
	BRW	ILLEGAL_OP		; IMPOSSIBLE
 
;
; EXECUTION FOR ZERO OPERAND STATUS OPCODES
;
 
CFCC:					; COPY FLOATING CONDITION CODES
	INSV	I_FCC(R10),#0,#4,I_PS(R10) ; INSERT CONDITION CODES
	BRB	NORMAL			;
SETF:					; SET FLOATING MODE
	BICW	#FSRM_FD,I_FLOATCSR(R10) ;
	BRB	NORMAL			;
SETI:					; SET INTEGER MODE
	BICW	#FSRM_FL,I_FLOATCSR(R10) ;
	BRB	NORMAL			;
SETD:					; SET DOUBLE MODE
	BISW	#FSRM_FD,I_FLOATCSR(R10) ;
	BRB	NORMAL			;
SETL:					; SET LONG MODE
	BISW	#FSRM_FL,I_FLOATCSR(R10) ;
	BRB	NORMAL			;
 
;
; EXECUTION FOR SINGLE OPERAND STATUS OPCODES
;
 
STST:					; STORE STATUS (FEC,FEA)
	BSBW	DST4			;
	MOVW	I_FLOATERR(R10),(R0) ;
	MOVW	I_FLOATADR(R10),2(R0) ;
	BRW	STORE			;
STFPS:					; STORE FLOATING POINT STATUS (FSR)
	BSBW	DST2			;
	BICW3	#^C<^X1F>,I_FCC(R10),(R0) ; ISOLATE CONDITION CODES
	BISW	I_FLOATCSR(R10),(R0) 	; MERGE FLOATING ENABLES
	BRB	NORMAL			;
LDFPS:					; LOAD FLOATING POINT STATUS (FSR)
	BSBW	SRC2			;
	BICW3	#^C<^X1F>,(R0),I_FCC(R10) ; SET FLOATING CONDITION CODES
	BICW3	#^X301F,(R0),I_FLOATCSR(R10) ; SET FLOATING ENABLES
	CLRW	I_FLOATCSR+2(R10)	; ASSUME UNDERFLOW INTS OFF
	BBC	#FSRV_FIU,I_FLOATCSR(R10),NORMAL ; IF UNDERFLOW INT. ENABLED
	BBS	#FSRV_FID,I_FLOATCSR(R10),NORMAL ; AND INTS NOT DISABLED
	MOVW	#1@PSL_FU,I_FLOATCSR+2(R10) ; SET UNDERFLOW TRAPS ON
 
;
; TEST NEXT INSTRUCTION FOR FLOATING OPCODE
;
 
NORMAL:					; NORMAL EXIT
	CMPW	#^O170000,@I_PC(R10) 	; NEXT INST. FLOATING?
	BGTRU	10$			; IF GTRU NO
	BBS	#PSL$V_TBIT,I_PS(R10),10$ ; IF SET, TBIT PENDING
	MOVZWL	@I_PC(R10),R8		; GET THE INSTRUCTION
	BRW	RSX$FLOAT		; CONTINUE EMULATION
;
; FLOATING POINT SEQUENCE DONE - RESTORE IMAGE EXECUTION
;
10$:	MOVL	I_R6(R10),R6		; RELOAD THE STACK POINTER
	BRW	RSX$RESTORE		; RESTORE STATE
;
; EXECUTION FOR UNARY AND BINARY OPCODES
;
 
CLRF:					; CLEAR FLOATING
	BSBW	FDST4			;
	CLRF	(R0)			;
	BRB	STORECC			;
TSTF:					; TEST FLOATING
	BSBW	FSRC4			;
	TSTF	(R0)			;
	BRW	SETCC			;
ABSF:					; ABSOLUTE FLOATING
	BSBW	FDST4			;
	MOVF	(R0),(R0)		;
	BICW	#^X8000,(R0)		;
	BRB	STORECC			;
NEGF:					; NEGATE FLOATING
	BSBW	FDST4			;
	MNEGF	(R0),(R0)		;
 
;
; STORE AND SET CONDITION CODES
;
 
STORECC:				;
	MOVPSL	I_FCC(R10)		; SAVE CONDITION CODES
	BRW	STORE			;
 
MULF:					; MULTIPLY FLOATING
	BSBW	FSRC4			;
	BBS	#FSRV_FT,I_FLOATCSR(R10),10$ ; IF SET, TRUNCATE RESULT
	MULF	(R0),(R1)		;
	MOVPSL	I_FCC(R10)		; SAVE CONDITION CODES
	BRW	NORMAL			;
10$:	CVTFD	(R0),R4			;
	CVTFD	(R1),R2			;
	MULD	R4,R2			;
	MOVF	R2,(R1)			;
	BRB	SETCC			;
MODF:
	BSBW	FSRC4
	EMODF	(R0),#0,(R1),R4,R5	; INT=R4, FRAC=R5
	BVS	30$			; BRANCH IF LONGWORD OVERFLOW
	MOVL	R5,(R1)			; PUT FRAC INTO EVEN FAC
	BBS	#6,R8,20$		; ONE RESULT IF ODD FAC
	CVTLF	R4,8(R1)		; PUT INTEGER INTO ODD FAC
20$:	TSTF	(R1)			; CC SET ON FRACTIONAL PART
	BRW	SETCC
30$:
	BBS	#6,R8,40$		; BRANCH IF NO INTEGER TO BE RETURNED
	MULF3	(R0),(R1),8(R1)		; MULTIPLY THEM WITHOUT EMOD
40$:	CLRL	(R1)			; RETURN ZERO FRACTIONAL PART
	BRW	SETCC
ADDF:
	BSBW	FSRC4
	BBS	#FSRV_FT,I_FLOATCSR(R10),1$	; TRUNCATE?
	ADDF	(R0),(R1)
	MOVPSL	I_FCC(R10)		; SAVE CONDITION CODES
	BRW	NORMAL			;
1$:	CVTFD	(R0),R4
	CVTFD	(R1),R2
	ADDD	R4,R2
	MOVF	R2,(R1)
	BRB	SETCC
LDF:
	BSBW	FSRC4
	MOVL	(R0),(R1)		; LDF NOT DATA SENSITIVE
	TSTW	(R1)
 
;
; SET CONDITION CODES
;
 
SETCC:					;
	MOVPSL	I_FCC(R10)		; SAVE CONDITION CODES
	BRW	NORMAL			;
SUBF:
	BSBW	FSRC4
	BBS	#FSRV_FT,I_FLOATCSR(R10),1$	; TRUNCATE?
	SUBF	(R0),(R1)
	MOVPSL	I_FCC(R10)		; SAVE CONDITION CODES
	BRW	NORMAL			;
1$:	CVTFD	(R0),R4
	CVTFD	(R1),R2
	SUBD	R4,R2
	MOVF	R2,(R1)
	BRB	SETCC
CMPF:
	BSBW	FSRC4
	CMPF	(R0),(R1)
	BRB	SETCC
STF:
	BSBW	FDST4
	MOVL	(R1),(R0)		; STF NOT DATA SENSITIVE
 
;
; STORE VALUE
;
 
STORE:					;
	CMPL	#7,R2			; RESULT IN TEMPORARY?
	BGEQU	10$			; IF GEQU NO
	MOVW	(R0),(R2)		; MOVE RESULT TO WORD DESTINATION
10$:	BRW	NORMAL			;
 
DIVF:
	BSBW	FSRC4
	BBS	#FSRV_FT,I_FLOATCSR(R10),1$; TRUNCATE?
	DIVF	(R0),(R1)
	MOVPSL	I_FCC(R10)		; SAVE CONDITION CODES
	BRW	NORMAL			;
1$:	CVTFD	(R0),R4
	CVTFD	(R1),R2
	DIVD	R4,R2
	MOVF	R2,(R1)
	BRB	SETCC
STEXP:
	BSBW	DST2
	EXTZV	#7,#8,(R1),R4
	SUBW3	#^O200,R4,(R0)
	MOVPSL	I_FCC(R10)		; SAVE CONDITION CODES
	BRW	CFCC			; COPY TO CM CC
STCFX:
	BBS	#FSRV_FL,I_FLOATCSR(R10),STCFL	; LONG MODE?
STCFI:
	BSBW	DST2
	CVTFW	(R1),(R0)
	BVS	1$			; CONVERSION ERROR?
2$:	MOVPSL	I_FCC(R10)		; SAVE CONDITION CODES
	BRW	CFCC			; COPY TO CM CC
1$:	CLRW	(R0)			; CLEAR DEST. AND SET CC'S
	BISPSW	#PSL$M_C		; FINISH SETTING CC'S
	BBC	#FSRV_FIC,I_FLOATCSR(R10),2$	; IF CONVERT INT ENABLED
	BBS	#FSRV_FID,I_FLOATCSR(R10),2$	; AND INTS NOT DISABLED
	BRW	CONVERT_ERR			; SIGNAL ERROR
STCFL:
	BSBW	DST4
	CVTFL	(R1),R4
	BVS	1$			; CONVERSION ERROR?
	ROTL	#16,R4,(R0)		; SWAP WORDS
	TSTL	R4
2$:	MOVPSL	I_FCC(R10)		; SAVE CONDITION CODES
	INSV	I_FCC(R10),#0,#4,I_PS(R10)	; AND CM CC
	BRW	STORE
1$:	CLRL	(R0)			; CLEAR DEST. AND SET CC'S
	BISPSW	#PSL$M_C		; FINISH SETTING CC'S
	BBC	#FSRV_FIC,I_FLOATCSR(R10),2$	; IF CONVERT INT ENABLED
	BBS	#FSRV_FID,I_FLOATCSR(R10),2$	; AND INTS NOT DISABLED
	BRW	CONVERT_ERR			; SIGNAL ERROR
STCFD:
	BSBW	FDST8
	CVTFD	(R1),(R0)
	BRW	STORECC
LDEXP:
	BSBW	SRC2
	ADDW3	#^O200,(R0),R4
	INSV	R4,#7,#8,(R1)
	TSTF	(R1)
	BRW	SETCC
LDCXF:
	BBS	#FSRV_FL,I_FLOATCSR(R10),LDCLF
LDCIF:
	BSBW	SRC2
	CVTWF	(R0),(R1)
	BRW	SETCC
LDCLF:
	BSBW	SRC4
	ROTL	#16,(R0),R4		; SWAP WORDS
	CVTLF	R4,(R1)
	BRW	SETCC
LDCDF:
	BSBW	FSRC8
	BBS	#FSRV_FT,I_FLOATCSR(R10),1$	; TRUNCATE?
	CVTDF	(R0),(R1)
	BRW	SETCC
1$:	MOVF	(R0),(R1)
	BRW	SETCC
CLRD:
	BSBW	FDST8
	CLRD	(R0)
	BRW	STORECC
TSTD:
	BSBW	FSRC8
	TSTD	(R0)
	BRW	SETCC
ABSD:
	BSBW	FDST8
	MOVD	(R0),(R0)
	BICW	#^X8000,(R0)
	BRW	STORECC
NEGD:
	BSBW	FDST8
	MNEGD	(R0),(R0)
	BRW	STORECC
MULD:
	BSBW	FSRC8
	MULD	(R0),(R1)
	BRW	SETCC
MODD:
	BSBW	FSRC8
	EMODD	(R0),#0,(R1),R4,R5	; INT=R4, FRAC=R5/R6
	BVS	30$			; BRANCH IF LONGWORD OVERFLOW
	MOVQ	R5,(R1)			; PUT FRAC INTO EVEN FAC
	BBS	#6,R8,20$		; ONE RESULT IF ODD FAC
	CVTLD	R4,8(R1)		; PUT INTEGER INTO ODD FAC
20$:	TSTD	(R1)			; CC SET ON FRACTIONAL PART
	BRW	SETCC
30$:
	BBS	#6,R8,40$		; BRANCH IF NO INTEGER TO BE RETURNED
	MULD3	(R0),(R1),8(R1)		; MULTIPLY THEM WITHOUT EMOD
	SUBD	R5,8(R1)		; GENERATE INTEGER PORTION
40$:	MOVD	R5,(R1)			; RETURN FRACTIONAL PART
	BRW	SETCC
ADDD:
	BSBW	FSRC8
	ADDD	(R0),(R1)
	BRW	SETCC
LDD:
	BSBW	FSRC8
	MOVQ	(R0),(R1)		; LDD NOT DATA SENSITIVE
	TSTW	(R1)
	BRW	SETCC
SUBD:
	BSBW	FSRC8
	SUBD	(R0),(R1)
	BRW	SETCC
CMPD:
	BSBW	FSRC8
	CMPD	(R0),(R1)
	BRW	SETCC
STD:
	BSBW	FDST8
	MOVQ	(R1),(R0)		; STD NOT DATA SENSITIVE
	BRW	STORE
DIVD:
	BSBW	FSRC8
	DIVD	(R0),(R1)
	BRW	SETCC
STCDX:
	BBS	#FSRV_FL,I_FLOATCSR(R10),STCDL
STCDI:
	BSBW	DST2
	CVTDW	(R1),(R0)
	BVS	1$			; CONVERSION ERROR?
2$:	MOVPSL	I_FCC(R10)		; SAVE CONDITION CODES
	BRW	CFCC			; COPY TO CMCC
1$:	CLRW	(R0)			; CLEAR DEST. AND SET CC'S
	BISPSW	#PSL$M_C		; FINISH SETTING CC'S
	BBC	#FSRV_FIC,I_FLOATCSR(R10),2$	; IF CONVERT INT ENABLED
	BBS	#FSRV_FID,I_FLOATCSR(R10),2$	; AND INTS NOT DISABLED
	BRW	CONVERT_ERR			; SIGNAL ERROR
STCDL:
	BSBW	DST4
	CVTDL	(R1),R4
	BVS	1$			; CONVERSION ERROR?
	ROTL	#16,R4,(R0)		; SWAP WORDS
	TSTL	R4
2$:	MOVPSL	I_FCC(R10)		; SAVE CONDITION CODES
	INSV	I_FCC(R10),#0,#4,I_PS(R10) ; INSERT IN REAL PSL
	BRW	STORE
1$:	CLRL	(R0)			; CLEAR DEST. AND SET CC'S
	BISPSW	#PSL$M_C		; FINISH SETTING CC'S
	BBC	#FSRV_FIC,I_FLOATCSR(R10),2$	; IF CONVERT INT ENABLED
	BBS	#FSRV_FID,I_FLOATCSR(R10),2$	; AND INTS NOT DISABLED
	BRW	CONVERT_ERR			; SIGNAL ERROR
;
STCDF:
	BSBW	FDST4
	BBS	#FSRV_FT,I_FLOATCSR(R10),1$	; TRUNCATE?
	CVTDF	(R1),(R0)
	BRW	STORECC
1$:	MOVF	(R1),(R0)
	BRW	STORECC
LDCXD:
	BBS	#FSRV_FL,I_FLOATCSR(R10),LDCLD
LDCID:
	BSBW	SRC2
	CVTWD	(R0),(R1)
	BRW	SETCC
LDCLD:
	BSBW	SRC4
	ROTL	#16,(R0),R4		; SWAP WORDS
	CVTLD	R4,(R1)
	BRW	SETCC
LDCFD:
	BSBW	FSRC4
	CVTFD	(R0),(R1)
	BRW	SETCC

	.SBTTL	ERROR EXITS
	.ENABL	LSB
;
; ILLEGAL FLOATING POINT OPCODE
;
ILLEGAL_OP:
	MOVL	#FEC_OPCODE,I_FLOATERR(R10)	; SET ERROR STATUS
	BRB	10$			; CONTINUE
;
; CONVERSION ERROR
;
CONVERT_ERR:
	MOVPSL	I_FCC(R10)		; GET CONVERT ERROR CC'S
	INSV	I_FCC(R10),#0,#4,I_PS(R10) ; INSERT IN REAL PSL
	BISW	#FSRM_FER,I_FLOATCSR(R10)	; SET ERROR SUMMARY BIT
	MOVL	#FEC_INTCONV,I_FLOATERR(R10)
10$:	CLRL	R0			; SET FLOATING ERROR 
;
; ABNORMAL RETURN
;
BAIL_OUT:				; RETURN TO AME EXCEPTION ROUTINE ON ERROR
	MOVL	I_R6(R10),R6		; LOAD IMAGE STACK POINTER
	EXTZV	#3,#4,R0,I_TYPE(R10)	; GET ERROR TYPE
	BNEQ	50$			; IF NEQ THEN ACCESS VIOLATION
	BBC	#SV_FLOATAST,I_STATE(R10),40$; BR IF NO FLOATING AST ENABLED
	MOVL	I_FLOATAST(R10),R0	; ADDRESS AST CONTROL BLOCK
	INSQUE	(R0),@I_ASTQUEUE+4(R10)	; INSERT ON LIST
	BISB	#1@SV_PENDWAIT,I_STATE(R10); SET AST QUEUED
40$:	BRW	RSX$RESTORE		; REENTER IMAGE
50$:	CLRL	R11			; SET UP PARAMS
	MOVZBL	#8,R0			; SET MEMORY VIOLATION CODE
	BRW	RSX$TRAP		; TREAT AS TRAP
	.DSABL	LSB

;
; EVALUATION ROUTINES FOR SRC,DST,FSRC,FDST
;
; CALL:	BSBX	ENTRY POINT INDICATES TYPE AND CONTEXT
;
; INPUTS:	R1 - FLOATING ACCUMULATOR NUMBER
;		R2 - MODE
;		R9 - REGISTER NUMBER
;
; OUTPUTS:	R0 - SOURCE OR DESTINATION ADDRESS
;		R1 - FLOATING ACCUMULATOR ADDRESS
;		R2 - ADDRESS OF 16-BIT DESTINATION
;		R3 - CLOBBERED
;		R4 - CLOBBERED
;
 
	.ENABL	LSB
SRC2:					;
	MOVL	#2,R4			;
	BRB	DISPSRC			;
DST2:					;
	MOVL	#2,R4			;
	BBCS	#V_OPRND,R9,DISPSRC	; SET DESTINATION FLAG
DST4:					;
	BBSS	#V_OPRND,R9,10$		; SET DESTINATION FLAG
SRC4:					;
10$:	MOVL	#4,R4			;
DISPSRC:				;
	MOVAQ	I_FLOATA0(R10)[R1],R1 ; FAC ADDRESS
	CMPB	#7,R9			; REGISTER IS PC?
	BEQL	20$			; IF EQL YES
	CASE	R2,TYPE=B,<-
	MODE0X,-
	MODE1X,-
	MODE2X,-
	MODE3X,-
	MODE4X,-
	MODE5X,-
	MODE6X,-
	MODE7X>
	BRB	ILLEGAL			;
20$:	CASE	R2,TYPE=B,<-		;
	MODE07,-
	MODE17,-
	MODE27,-
	MODE37,-
	MODE47,-
	MODE57,-
	MODE67,-
	MODE77>
	BRB	ILLEGAL			;
	.DSABL	LSB
 
	.ENABL	LSB
FSRC8:					;
	MOVL	#8,R4			;
	BRB	DISPFSRC		;
FDST8:					;
	MOVL	#8,R4			;
	BBCS	#V_OPRND,R9,DISPFSRC	; SET DESTINATION FLAG
FDST4:					;
	BBSS	#V_OPRND,R9,10$		; SET DESTINATION FLAG
FSRC4:					;
10$:	MOVL	#4,R4			;
DISPFSRC:				;
	MOVAQ	I_FLOATA0(R10)[R1],R1 ; FAC ADDRESS
	CMPB	#7,R9			; REGISTER IS PC?
	BEQL	20$			; IF EQL YES
	CASE	R2,TYPE=B,<-
	FMODE0X,-
	MODE1X,-
	MODE2X,-
	MODE3X,-
	MODE4X,-
	MODE5X,-
	MODE6X,-
	MODE7X>
	BRB	ILLEGAL
20$:	CASE	R2,TYPE=B,<-		;
	ILLEGAL_OP,-
	MODE17,-
	MODE27,-
	MODE37,-
	MODE47,-
	MODE57,-
	MODE67,-
	MODE77>
ILLEGAL:				;
	BRW	ILLEGAL_OP		; IMPOSSIBLE
	.DSABL	LSB
 
;
; REGISTER
;
 
MODE0X:					;
MODE07:					;
	MOVAL	I_R0(R10)[R9],R0	; ADDRESS REGISTER
SHORT:	BBS	#1,R4,10$		; IF SET, WORD CONTEXT
	MOVL	R0,R2			; SAVE 16-BIT SRC/DST
	MOVAQ	I_FLOATTMP(R10),R0	; USE TEMPORARY
	MOVZWL	(R2),(R0)		; COPY OPERAND
	CLRL	4(R0)			; ZERO EXTEND
10$:	RSB				;
 
;
; FLOATING REGISTER
;
 
FMODE0X:				;
	CMPB	#6,R9			; RESERVED REGISTER?
	BEQL	ILLEGAL			; IF EQL YES
	MOVAQ	I_FLOATA0(R10)[R9],R0 ; ADDRESS REGISTER
	RSB				;
 
;
; REGISTER DEFERRED
;
 
MODE1X:					;
	MOVL	I_R0(R10)[R9],R0	; GET REGISTER
	BLBS	R0,ODD			; TRAP ODD ADDRESS
	RSB				;
 
;
; REGISTER DEFERRED (PC)
;
 
MODE17:					;
	MOVL	I_PC(R10),R0		; GET SAVED PC
	BRB	SHORT			;
 
;
; AUTO-INCREMENT
;
 
MODE2X:					;
	MOVAL	I_R0(R10)[R9],R3	; GET REGISTER ADDRESS
	MOVL	(R3),R0			; GET REGISTER CONTENTS
	ADDW	R4,(R3)			; UPDATE REGISTER
	BLBS	R0,ODD			; TRAP ODD ADDRESS
	RSB				;
 
;
; IMMEDIATE (AUTO-INCREMENT PC)
;
 
MODE27:					;
	MOVL	I_PC(R10),R0		; GET SAVED PC
	ADDW	#2,I_PC(R10)		; UPDATE PC
	BRB	SHORT			;
 
;
; AUTO-INCREMENT DEFERRED
;
 
MODE3X:					;
	MOVAL	I_R0(R10)[R9],R3	; GET REGISTER ADDRESS
	MOVL	(R3),R0			; GET REGISTER CONTENTS
	ADDW	#2,(R3)			; UPDATE REGISTER
	BLBC	R0,INDIRECT		; IF LBC NOT ODD ADDRESS
	BRB	ODD			;
 
;
; ABSOLUTE (AUTO-INCREMENT DEFERRED PC)
;
 
MODE37:					;
	MOVL	I_PC(R10),R0		; GET SAVED PC
	ADDW	#2,I_PC(R10)		; UPDATE PC
INDIRECT:				;
	MOVZWL	(R0),R0			; GET INDIRECT ADDRESS
	BLBS	R0,ODD			; TRAP ODD ADDRESS
	RSB				;
 
;
; AUTO-DECREMENT
;
 
MODE4X:					;
	MOVAL	I_R0(R10)[R9],R3	; GET REGISTER ADDRESS
	SUBW	R4,(R3)			; UPDATE REGISTER
	MOVL	(R3),R0			; GET REGISTER CONTENTS
	BLBS	R0,ODD_ADDR		; TRAP ODD ADDRESS
	RSB				;
 
;
; AUTO-DECREMENT (PC)
;
 
MODE47:					;
	SUBW	#2,I_PC(R10)		; UPDATE PC
	MOVL	I_PC(R10),R0		; GET UPDATED PC
	BRB	SHORT			;
 
;
; AUTO-DECREMENT DEFERRED
;
 
MODE5X:					;
	MOVAL	I_R0(R10)[R9],R3	; GET REGISTER ADDRESS
	SUBW	#2,(R3)			; UPDATE REGISTER
	MOVL	(R3),R0			; GET REGISTER CONTENTS
	BLBC	R0,INDIRECT		; IF LBC NOT ODD ADDRESS
ODD:	BRB	ODD_ADDR		;
 
;
; AUTO-DECREMENT DEFERRED (PC)
;
 
MODE57:					;
	SUBW	#2,I_PC(R10)		; UPDATE PC
	MOVL	I_PC(R10),R0		; GET UPDATED PC
	BRB	INDIRECT		;
 
;
; INDEX
;
 
MODE6X:					;
	MOVL	I_R0(R10)[R9],R0	; GET REGISTER
	ADDW	@I_PC(R10),R0		; ADD DISPLACEMENT
	ADDW	#2,I_PC(R10)		; UPDATE PC
	BLBS	R0,ODD_ADDR		; TRAP ODD ADDRESS
	RSB				;
 
;
; RELATIVE
;
 
MODE67:					;
	MOVZWL	@I_PC(R10),R0		; GET DISPLACEMENT
	ADDW	#2,I_PC(R10)		; UPDATE PC
	ADDW	I_PC(R10),R0		; ADD REGISTER
	BLBS	R0,ODD_ADDR		; TRAP ODD ADDRESS
	RSB				;
 
;
; INDEX DEFERRED
;
 
MODE7X:					;
	MOVL	I_R0(R10)[R9],R0	; GET REGISTER
	ADDW	@I_PC(R10),R0		; ADD DISPLACEMENT
	ADDW	#2,I_PC(R10)		; UPDATE PC
	BLBC	R0,INDIRECT		; IF LBC NOT ODD ADDRESS
	BRB	ODD_ADDR		;
 
;
; RELATIVE DEFERRED
;
 
MODE77:					;
	MOVZWL	@I_PC(R10),R0		; GET DISPLACEMENT
	ADDW	#2,I_PC(R10)		; UPDATE PC
	ADDW	I_PC(R10),R0		; ADD REGISTER
	BLBC	R0,INDIRECT		; IF LBC NOT ODD ADDRESS
 
;
; ODD ADDRESS ERROR
;
 
ODD_ADDR:				; RETURN ODD ADDRESS ERROR
	MOVL	#RSX$_ODDADDR,R0	; SET STATUS
	BRW	BAIL_OUT		; EXIT
RSX$FLOAT_END::				;
	.PAGE
	.SBTTL	RSX$FLOAT_EXC - FPU EXCEPTION HANDLER
;++
; RSX$FLOAT_EXC - EXCEPTION HANDLER FOR PDP-11 FLOATING POINT EMULATION
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED ON EXCEPTIONS DURING FLOATING POINT EMULATION.
; THE APPROPRIATE ERROR VALUE IS SET IN I_FLOATERR AND THE EXCEPTION
; STACK FRAME IS MODIFIED TO RETURN VIA THE BAIL_OUT EXIT ABOVE.
;
; INPUTS:
;
;	R11 = CURRENT IMAGE PC
;	AP = ADDRESS OF THE EXCEPTION ARGUMENT LIST
;
;
; OUTPUTS:
;
;	R0 = 0 IF FLOATING EXCEPTION, ELSE CONTAINS ERROR CODE
;	RETURN IS EITHER TO "BAIL_OUT" OR RET W/R0=SS$_CONTINUE/RESIGNAL
;--
 
RSX$FLOAT_EXC::
	CLRL	R0			; ASSUME FLOATING EXCEPTION
	MOVL	4(AP),R1		; GET EXCEPTION ARGUMENT LIST
	CMPW	#SS$_ACCVIO,AP_NAME(R1)	; ACCESS VIOLATION?
	BEQL	80$			; IF EQL YES
	CMPW	#SS$_ROPRAND,AP_NAME(R1); RESERVED OPERAND?
	BEQL	RSVD_OPERAND		; IF EQL YES
;
; PROCESS FLOATING EXCEPTION
;
	ASHL	#-3,AP_NAME(R1),-(SP)	; GET MESSAGE NUMBER
	CASE	(SP)+,LIMIT=#SS$_FLTOVF/8,<-
	FLOAT_OFLO,-			; FLOATING TRAPS FOR 11/780
	FLOAT_DIV_ZERO,-
	FLOAT_UFLO,-
	70$,70$,-
	FLOAT_OFLO,-			; FLOATING FAULTS FOR 11/750
	FLOAT_DIV_ZERO,-
	FLOAT_UFLO>
;
; AME ERROR IN FLOATING EMULATION
;
70$:	MOVZWL	#SS$_RESIGNAL,R0	; RESIGNAL EXCEPTION
	RET				; RETURN
;
; ACCESS VIOLATION
;
80$:	TSTW	14(R1)			; WAS THE ACCESSED ADDRESS IN 0 TO 65K?
	BNEQ	70$			; IF NEQ THEN REAL ERROR
	MOVL	#RSX$_ACCVIO,R0		; SET ERROR CODE
;
; EXIT EXCEPTION
;
EXIT_EXCEPTION:
	MOVAB	W^BAIL_OUT,FP_PC(FP)	; CHANGE RETURN ADDRESS
	BBCC	#PSL_FPD,FP_PSL(FP),100$; CLEAR FPD
100$:	RET				;
;
; PROCESS FLOATING OVERFLOW
;
FLOAT_OFLO:
	BBC	#FSRV_FIV,I_FLOATCSR(R10),CONTINUE	; IF OFLO INT ON
	BBS	#FSRV_FID,I_FLOATCSR(R10),CONTINUE	; AND INTS NOT OFF
	BISW	#FSRM_FER,I_FLOATCSR(R10)	; SET ERROR SUMMARY BIT
	MOVL	#FEC_OVERFLOW,I_FLOATERR(R10)
	BRB	EXIT_EXCEPTION
CONTINUE:
	MOVZWL	#SS$_CONTINUE,R0
	RET
;
; PROCESS FLOATING DIVIDE BY ZERO
;
FLOAT_DIV_ZERO:
	MOVL	#FEC_DIVBYZERO,I_FLOATERR(R10)
	BRB	EXIT_EXCEPTION
;
; PROCESS FLOATING UNDERFLOW
;
FLOAT_UFLO:
	BISW	#FSRM_FER,I_FLOATCSR(R10)	; SET ERROR SUMMARY BIT
	MOVL	#FEC_UNDERFLOW,I_FLOATERR(R10)
	BRB	EXIT_EXCEPTION
;
; PROCESS RESERVED OPERAND
;
RSVD_OPERAND:
	BBC	#FSRV_FIUV,I_FLOATCSR(R10),10$	; IF UNDEFINED INT ON
	BBS	#FSRV_FID,I_FLOATCSR(R10),10$	; AND INTS NOT OFF
	BISW	#FSRM_FER,I_FLOATCSR(R10)	; SET ERROR SUMMARY BIT
	MOVL	#FEC_UNDEFINED,I_FLOATERR(R10)
	BRB	EXIT_EXCEPTION
;
; FIXUP RESERVED OPERAND
;
10$:
	MOVL	2*4(R1),R1		; GET EXCEPTION PC
	MOVL	8(AP),R0		; ADDRESS MECHANISM ARGLIST
	CMPB	#^X60,1(R1)		; IS FIRST OPERAND (R0)?
	BNEQ	40$			; NO, MUST BE (R1)
;
; CHECK FOR RESERVED OPERAND IN MEMORY
;
20$:
	CMPZV	#7,#9,@12(R0),#^X100	; IS (R0) RESERVED OPERAND?
	BNEQ	40$			; NO, TRY (R1)
	BBS	#V_OPRND,R9,30$		; IF SET, DESTINATION ADDRESS
	MOVAL	B^ZERO,12(R0)		; REPLACE R0 WITH POINTER TO ZERO
	BRB	CONTINUE		; AND RE-EXECUTE INSTRUCTION
30$:	CLRW	@12(R0)			; IF (R0) IS A DESTINATION
	BRB	CONTINUE		; ZERO IT AND RE-EXECUTE
;
; CHECK FOR RESERVED OPERAND IN FAC
;
40$:
	CMPZV	#7,#9,@16(R0),#^X100	; IS (R1) RESERVED OPERAND?
	BNEQ	20$			; NO, TRY (R0)
	BBS	#V_OPRND,R9,50$		; IF SET, DESTINATION ADDRESS
	CLRW	@16(R0)			; ZERO FAC
	BRB	CONTINUE		; AND RE-EXECUTE
50$:	MOVAL	B^ZERO,16(R0)		; IF MEMORY OPERAND IS A DESTINATION
	BRB	CONTINUE		; REPLACE (R1) WITH POINTER TO ZERO
	.ALIGN	LONG,0
ZERO:	.QUAD	0
 
	.END
