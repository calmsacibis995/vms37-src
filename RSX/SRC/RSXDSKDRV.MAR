	.TITLE	RSXDSKDRV - RSX11M AME DISK DRIVER
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:
;
;	VAX/VMS RSX11M AME
;
; ABSTRACT:
;
;	DISK I/O DRIVER
;
; AUTHOR: R.HEINEN 4-NOV-76
;
; MODIFIED BY:
;
;	V005	MSH015		Michael S. Harvey	28-Jan-82
;		Implement IO.WDD function for both RX01 and RX02
;		devices.
;
;	V004	MSH010		Michael S. Harvey	5-Jan-81
;		Implement IO.SEC function for RX02 devices.
;
;	V003	PCG0002		Peter George	10-Aug-1981
;		Fix error exiting from RSX$PHY_IO.
;
;	V002	PCG0001		Peter George	23-Mar-1981
;		Add support for IO.RPB and IO.WPB.
;
;	V001	TMH0001		Tim Halvorsen	02-Feb-1981
;		Add overlay caching to improve performance of heavily
;		overlaid programs.  Remove special case code for
;		insufficient working set error during the QIO, since
;		enhancements to QIO for V2.0 remove the need for it.
;--
;
; EXTERNAL SYMBOLS
;
	$RSXDEF			; DEFINE RSX SYMBOLS
	$DIBDEF			; DEFINE DEVICE INFORMATION BLOCK
	$DCDEF			; DEFINE DEVICE CHARACTERISTICS
	SPCIO$			; DEFINE RSX11M SPECIAL I/O CODES
	FILIO$			; DEFINE RSX11M FILE I/O FUNCTION CODES
;
; LOCAL SYMBOLS
;
LODENS=		0			; LOW DENSITY CHARACTERISTIC
HIDENS=		^O4000			; HIGH DENSITY CHARACTERISTIC
LO_BLKSIZ=	494			; BLOCK SIZE FOR LOW DENSITY DY
HI_BLKSIZ=	988			; BLOCK SIZE FOR HI DENSITY DY

SEC$Q_GETCHN=	I_SCRATCH+I_QIOSCRATCH	; GETCHN PRIMARY BUFFER DESC.
SEC$A_GETCHN=	SEC$Q_GETCHN+8		; GETCHN PRIMARY BUFFER

WDD$B_FLOPPY=	I_SCRATCH+I_QIOSCRATCH	; IF NONZERO, DISK IS RX01/02

	.PSECT	RSXCODE,NOWRT,SHR,PIC
RSX$DSK_DRV::				; DISK I/O DRIVER
	CASE	R3,<-			; DISK DRIVER
		RSX$IOKILL,-		; KILL I/O
		DSK_WLB,-		; WRITE LOGICAL BLOCK
		DSK_RLB,-		; READ LOGICAL BLOCK
		RSX$DLVRQIOAST,-	; ATTACH IS NOOP
		RSX$DLVRQIOAST,-	; DETACH DEVICE
		DSK_SET,-		; FUNCTION CODE 5
		RSX$IEIFC,-		; FUNCTION CODE 6
		RSX$IEIFC,-		; ILLEGAL
		RSX$IEIFC,-		; ILLEGAL
		RSX$FILEIO,-		; FUNCTION CODE 9
		RSX$IEIFC,-		; ILLEGAL
		RSX$FILEIO,-		; REMOVE FILE NAME
		RSX$FILEIO,-		; ENTER FILE NAME
		RSX$FILEIO,-		; ACCESS FOR READ
		RSX$FILEIO,-		; ACCESS FOR WRITE
		RSX$FILEIO,-		; ACCESS FOR EXTEND
		RSX$FILEIO,-		; DEACCESS
		DSK_RVB,-		; READ VIRTUAL BLOCK
		DSK_WVB,-		; WRITE VIRTUAL BLOCK
		RSX$FILEIO,-		; EXTEND FILE
		RSX$FILEIO,-		; CREATE FILE
		RSX$FILEIO,-		; DELETE FILE
		RSX$FILEIO,-		; READ ATTRIBUTES
		RSX$FILEIO,-		; WRITE ATTRIBUTES
		RSX$FILEIO,-		; ACP CONTROL
		>
	BRW	RSX$IEIFC		; ERROR EXIT

	.SBTTL	DSK_RVB AND DSK_RLB FUNCTIONS
 
	.ENABL	LSB
;
; READ VIRTUAL BLOCK FUNCTION
;
DSK_RVB:				; READ VIRTUAL BLOCK
	MOVZWL	#IO$_READVBLK,I_SCRATCH+12(R10); SET UP FUNCTION CODE
	BRW	20$			; CONTINUE IN COMMON
;
; READ LOGICAL OR PHYSICAL BLOCK 
;
DSK_RLB:				; READ LOGICAL BLOCK
	BITW	#<IO.RPB&^X0FF>,R7	; IO.RPB?
	BEQL	10$			; NO, THEN SKIP TO LOGICAL
	BSBW	RSX$PHY_IO		; YES, THEN PREPARE FOR PHYSICAL I/O
	BLBS	R0,5$			; IF SUCCESSFUL, THEN SKIP
	CLRL	R1			; CLEAR SECOND STATUS REGISTER
	BRW	RSX$DLVRQIOAST		; DELIVER AST TO COMPLETE I/O
5$:	MOVZWL	#IO$_READPBLK,I_SCRATCH+12(R10)	; SET UP FUNCTION CODE
	BRW	15$			; CONTINUE IN COMMON
10$:	MOVZWL	#IO$_READLBLK,I_SCRATCH+12(R10); SET UP FUNCTION CODE
	CMPB	R7,#<IO.LOV&^X0FF>	; LOAD OVERLAY
	BNEQ	15$			; IF NEQ THEN NO
	PUSHAB	W^RSX$A_OVDEV		; GET ADDRESS OF OVERLAY LUT
	CMPL	(SP)+,R8		; CORRECT LUT?
	BNEQ	15$			; IF NO TREAT NORMALLY
	MOVZWL	(R5),R4			; SET ADDRESS OF TARGET
	MOVZWL	2(R5),R3		; GET SIZE TO READ
	MOVL	8(R5),R5		; GET VBN OF IMAGE
	BSBW	RSX$OVERLAY		; LOAD THE OVERLAY
	BRW	RSX$DLVRQIOAST		; POST THE STATUS
;
; TEST FOR INHIBIT RETRY FLAG
;
15$:	BITW	#IQ.X,R7		; INHIBIT ERROR RETRY?
	BEQL	20$			; IF EQL THEN NO
	BISW	#IO$M_INHRETRY,I_SCRATCH+12(R10); INHIBIT RETRY
;
; ISSUE QIO
;
20$:	BRW	RSX$ISSUQIO		; DO FUNCTION

	.SBTTL	DSK_WVB AND DSK_WLB FUNCTIONS
	.ENABL	LSB
;
; WRITE VIRTUAL BLOCK
;
DSK_WVB:				; WRITE VIRTUAL BLOCK
	MOVZWL	#IO$_WRITEVBLK,I_SCRATCH+12(R10); SET FUNCTION CODE
	BRB	25$			; CONTINUE IN COMMON
;
; WRITE LOGICAL OR PHYSICAL BLOCK
;
DSK_WLB:				; WRITE LOGICAL BLOCK
	MOVZWL	#IO$_WRITELBLK,I_SCRATCH+12(R10); SET FUNCTION CODE
	CMPB	R7,#<IO.WPB&^X0FF>	; WRITE PHYSICAL?
	BEQL	5$			; IF EQL YES
	CMPB	R7,#<IO.WDD&^X0FF>	; WPB WITH DELETED DATA MARK?
	BNEQ	20$			; NO, THEN SKIP
5$:	BSBW	RSX$PHY_IO		; PREPARE FOR PHYSICAL I/O
	BLBS	R0,10$			; IF SUCCESSFUL, THEN SKIP
	CLRL	R1			; CLEAR SECOND STATUS REGISTER
	BRW	RSX$DLVRQIOAST		; DELIVER AST TO COMPLETE I/O
10$:	MOVZWL	#IO$_WRITEPBLK,I_SCRATCH+12(R10); SET UP FUNCTION CODE
	CMPB	R7,#<IO.WDD&^X0FF>	; WPB WITH DELETED DATA MARK?
	BNEQ	20$			; IF NEQ NO, CONTINUE
	TSTB	WDD$B_FLOPPY(R10)	; LEGAL FUNCTION FOR THIS DISK?
	BNEQ	15$			; IF NEQ YES
	BRW	RSX$IEIFC		; ILLEGAL FUNCTION FOR DEVICE
15$:	BISW	#IO$M_DELDATA,I_SCRATCH+12(R10) ; CONVERT FUNCTION
;
; TEST FOR INHIBIT RETRY FLAG
;
20$:	BITW	#IQ.X,R7		; INHIBIT RETRY?
	BEQL	25$			; IF EQL THEN NO
	BISW	#IO$M_INHRETRY,I_SCRATCH+12(R10); SET TO INHIBIT RETRY
25$:	BRW	RSX$ISSUQIO

	.DSABL	LSB
	.PAGE
	.SBTTL	RSX$PHY_IO - SETUP BLOCK ADDRESS FOR PHYSICAL I/O

	.ENABL	LSB
;++
; RSX$PHY_IO - SETUP BLOCK ADDRESS FOR PHYSICAL I/O
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS SUBROUTINE CALCULATES A LONGWORD PHYSICAL ADDRESS OF THE FORM:
;	CYLINDER# (WORD), TRACK# (BYTE), SECTOR# (BYTE), FROM A PHYSICAL
;	BLOCK NUMBER.  THE EQUATIONS USED ARE
;
;		SECTOR#   = PBN MOD (SECTORS/TRACK)
;
;		TRACK#    = ( (PBN - SECTOR#) / (SECTORS/TRACK) ) 
;				MOD (TRACKS/CYLINDER)
;
;		CYLINDER# = (PBN - SECTOR# - TRACK# * (SECTORS/TRACK) )
;				/ (SECTORS/CYLINDER)
;
; INPUTS:
;
;	R10 = ADDRESS OF QIO PARAMTER BLOCK
;
; OUTPUTS:
;
;	R0  = SS$_ILLBLKNUM 	IF PBN IS OUT OF BOUNDS
;	    = SS$_NORMAL	IF PBN IS WITHIN BOUNDS
;
;--
RSX$PHY_IO:
	PUSHR	#^M<R2,R3,R4,R5>	; SAVE REGISTERS
	SUBL2	#DIB$C_LENGTH,SP	; ALLOC SPACE FOR DEVICE INFO BLOCK 
	PUSHL	SP			; PUSH ADDRESS OF BUFFER
	PUSHL	#DIB$C_LENGTH		; PUSH LENGTH OF BUFFER
	PUSHL	#0			; PUSH NULL ARGUMENT
	PUSHL	#0			; PUSH NULL ARGUMENT
	PUSHAL	8(SP)			; PUSH ADDR OF DESCRIPTOR
	PUSHL	#0			; PUSH NULL ARGUMENT
	PUSHL	LUT_CHAN(R8)		; PUSH CHANNEL NUMBER
	CALLS	#5,@#SYS$GETCHN		; GET DEVICE INFO
	ADDL2	#8,SP			; POP DESCRIPTOR OFF STACK
	BLBC	R0,60$			; IF UNSUCCESSFUL, THEN RETURN
	MOVZBL	DIB$B_SECTORS(SP),R2	; GET SECTORS/TRACK
	MOVZBL	DIB$B_TRACKS(SP),R3	; GET TRACKS/CYLINDER
	MOVZWL	DIB$W_CYLINDERS(SP),R4	; GET CYLINDERS/DISK
	MULL2	R2,R4			; COMPUTE MAX SECTOR NUMBER
	MULL2	R3,R4			; R4 = SECTORS/DISK
	MOVAB	I_SCRATCH+36(R10),R5	; GET PBN ADDRESS
	MOVL	(R5),R0			; GET PBN
	CLRL	R1			; CLEAR UPPER HALF OF PBN QUADWORD
;
; CHECK BOUNDS ON PBN
;
	CMPL	R4,R0			; PBN TOO LARGE?
	BLSS	10$			; YES, THEN RETURN WITH ERROR STATUS
	TSTL	R0			; PBN TOO SMALL?
	BGEQ	20$			; NO, THEN CONTINUE WITH CALCULATION
10$:	MOVL	#SS$_ILLBLKNUM,R0	; SET STATUS
	BRB	60$			; CLEAN-UP AND RETURN
;
; CALCULATE SECTOR NUMBER
;
20$:	EDIV	R2,R0,(SP),R4		; SECTOR# = PBN MOD (SECTORS/TRACK)
;
; SPECIAL RXO1/RXO2 PROCESSING
;
	CLRB	WDD$B_FLOPPY(R10)	; ASSUME NOT RX01/02
	CMPB	DIB$B_DEVTYPE(SP),#DT$_RX01	; RX01?
	BEQL	30$				; YES, THEN SKIP NEXT TEST
	CMPB	DIB$B_DEVTYPE(SP),#DT$_RX02	; RX02?
	BNEQ	40$				; NO, THEN SKIP
30$:	INCB	WDD$B_FLOPPY(R10)	; MARK THAT THIS IS A FLOPPY
	INCB	R4			; INCREMENT SECTOR#
	MOVB	R4,(R5)			; PUT SECTOR#
	DECB	R4			; DECREMENT SECTOR#
	BRB	50$			; SKIP DUPLICATE PUT
40$:	MOVB	R4,(R5)			; PUT SECTOR#
;
; CALCULATE TRACK NUMBER
;
50$:	SUBL2	R4,R0			; TRACK# = PBN - SECTOR#
	MOVL	R0,R4			; PBN = PBN - SECTOR#
	DIVL2	R2,R0			; TRACK# = TRACK# / (SECTORS/TRACK)
	EDIV	R3,R0,(SP),R0		; TRACK# = TRACK# MOD (TRACKS/CYLINDER)
	MOVB	R0,1(R5)		; PUT TRACK#
;
; CALCULATE CYLINDER NUMBER
;
	MULL2	R2,R0			; TRACK# = TRACK# * (SECTORS/TRACK)
	SUBL2	R0,R4			; CYLINDER# = PBN - TRACK#
	MULL2	R2,R3			; SECTORS/CYLINDER = (SECTORS/TRACK) * (TRACKS/CYLINDER)
	DIVL2	R3,R4			; CYLINDER# = CYLINDER# / (SECTORS/CYLINDER)
	MOVW	R4,2(R5)		; PUT CYLINDER#
;
; CLEAN UP AND RETURN
;
	MOVL	#SS$_NORMAL,R0		; SET STATUS
60$:	ADDL2	#DIB$C_LENGTH,SP	; RESTORE SP
	POPR	#^M<R2,R3,R4,R5>	; RESTORE REGISTERS
	RSB				; RETURN

	.DSABL	LSB

	.SBTTL	DSK_SET FUNCTIONS
;
; DISK SPECIAL FUNCTIONS
;
DSK_SET:				; PACKACK IS THE ONLY LEGAL FUNCTION
	CMPW	#IO.STC,R7		; PACKACK?
	BNEQ	30$			; IF NEQ THEN NO
	MOVZWL	#IO$_PACKACK,I_SCRATCH+12(R10); SET THE FUNCTION
	BRW	RSX$ISSUQIO		; 

30$:	CMPW	#IO.SEC,R7		; RX02 SENSE CHARACTERISTICS?
	BNEQ	50$			; IF NEQ NO
;
; RX02 SENSE CHARACTERISTICS FUNCTION
;
	MOVAB	SEC$A_GETCHN(R10),R4	; GET BUFFER ADDRESS
	MOVZBL	#DIB$K_LENGTH,SEC$Q_GETCHN(R10) ; SET LENGTH OF BUFFER
	MOVL	R4,SEC$Q_GETCHN+4(R10)	; SET ADDR IN DESCRIPTOR
	$GETCHN_S CHAN=LUT_CHAN(R8),-	; GET CHANNEL CHARACTERISTICS
		PRIBUF=SEC$Q_GETCHN(R10)
	BLBC	R0,50$			; IF LBC ERROR
	MOVZBL	#SS$_NORMAL,R0		; ASSUME SUCCESS AND LO DENSITY
	CMPB	DIB$B_DEVCLASS(R4),#DC$_DISK ; IS DEVICE AN RX02?
	BNEQ	50$			; IF EQL MAYBE
	CMPB	DIB$B_DEVTYPE(R4),#DT$_RX02 ; IS IT REALLY AN RX02?
	BNEQ	50$			; IF NEQ NO
	BITL	#DEV$M_FOR!DEV$M_MNT,DIB$L_DEVCHAR(R4) ; VOLUME VALID?
	BEQL	55$			; IF EQ NO, REJECT FUNCTION
	CMPW	DIB$L_MAXBLOCK(R4),#LO_BLKSIZ ; LOW DENSITY DISK?
	BEQL	40$			; IF EQL YES
	BISL	#<HIDENS@16>,R0		; ELSE, MUST BE HIGH DENSITY
40$:	CLRL	R1			; CLEAR SECOND STATUS LONGWORD
	BRW	RSX$DLVRQIOAST		; DONE, RETURN STATUS TO USER

50$:	BRW	RSX$IEIFC		; ILLEGAL FUNCTION

55$:	MOVZWL	#SS$_VOLINV,R0		; VOLUME IS NOT VALID
	BRB	40$			; RETURN STATUS TO USER
	.PAGE
	.SBTTL	RSX$OVERLAY - LOAD OVERLAY
;++
; RSX$OVERLAY - LOAD OVERLAY
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED FOR IO.LOV AND INITIAL HEADER/ROOT SEGMENT LOADS.
;
; INPUTS:
;
;	R3 = NUMBER OF BYTES TO LOAD
;	R4 = VIRTUAL ADDRESS OF LOAD
;	R5 = VIRTUAL BLOCK NUMBER
;	R10 = ADDRESS OF THE IMAGE IMPURE DATA BASE
;	R11 = ADDRESS OF THE IMAGE
;
; OUTPUTS:
;
;	R0 = STATUS OF THE OPERATION
;
;	ALL OTHER REGISTERS ARE PRESERVED.
;
;--
RSX$OVERLAY::
	PUSHR	#^M<R2,R3,R4,R5>	; SAVE USED REGISTERS
	ADDL	I_IMAGEVBN(R10),R5	; POINT TO HEADER RELATIVE BLOCK
;
; IF THE OVERLAY CACHE DOES NOT EXIST YET, CREATE IT BY SIMPLY MAPPING
; TO THE ENTIRE IMAGE FILE (READ ONLY) IN HIGH VIRTUAL ADDRESS SPACE.
;
	MOVL	I_OVERLAYS(R10),R0	; GET ADDRESS OF SAVED IMAGE FILE
	BNEQ	10$			; BRANCH IF EXISTS
	ASSUME	I_OVERLEN EQ I_OVERLAYS+4
	$CRMPSC_S INADR=I_OVERLAYS(R10),- ; MAP TO THE IMAGE FILE
		RETADR=I_OVERLAYS(R10),-
		CHAN=W^RSX$A_OVDEV+LUT_CHAN,-
		FLAGS=#SEC$M_EXPREG
	BLBC	R0,20$			; BRANCH IF UNSUCCESSFUL
	SUBL	I_OVERLAYS(R10),I_OVERLEN(R10) ; COMPUTE LENGTH-1 OF SECTION
	INCL	I_OVERLEN(R10)		; COMPUTE LENGTH OF SECTION
;
; IF THE OVERLAY IS WITHIN THE BOUNDS OF THE OVERLAY SECTION, SIMPLY
; COPY THE OVERLAY FROM THE READ-ONLY SECTION TO THE COMPATIBILITY
; MODE ADDRESS SPACE.
;
10$:	SUBL3	#1,R5,R0		; COMPUTE VPN (BASE 0)
	ASHL	#9,R0,R0		; STARTING OFFSET INTO IMAGE FILE
	ADDL3	R3,R0,R1		; ENDING OFFSET INTO IMAGE FILE
	CMPW	R1,I_OVERLEN(R10)	; CHECK IF REQUEST IN RANGE
	BGTR	50$			; BRANCH IF CANNOT USE OVERLAY CACHE
	MOVC	R3,@I_OVERLAYS(R10)[R0],(R4) ; COPY OVERLAY INTO CM SPACE
	INCL	R0			; SET SUCCESSFUL
	CLRL	R1
	BRB	90$			; AND EXIT

20$:	$DELTVA_S INADR=I_OVERLAYS(R10)	; DELETE PARTIALLY MAPPED SECTION
	CLRL	I_OVERLEN(R10)		; MARK SECTION EMPTY, TO AVOID
					; TRYING TO CREATE IT AGAIN
;
; THE OVERLAY CACHE DOES NOT CONTAIN THE OVERLAY.  READ THE OVERLAY
; FROM THE IMAGE FILE.
;
50$:	$QIOW_S	EFN=I_SCRATCH+4(R10),-	; READ OVERLAY INTO MEMORY
		CHAN=W^RSX$A_OVDEV+LUT_CHAN,-
		FUNC=#IO$_READVBLK,-
		IOSB=I_SCRATCH+8(R10),-
		P1=(R4),-		; STARTING ADDRESS OF BUFFER
		P2=R3,-			; NUMBER OF BYTES TO TRANSFER
		P3=R5			; STARTING VBN IN FILE
	BLBC	R0,90$			; BRANCH IF ANY ERROR DURING TRANSFER
	MOVQ	I_SCRATCH+8(R10),R0	; LOAD IOSB FOR RETURN
90$:	POPR	#^M<R2,R3,R4,R5>	; RESTORE REGISTERS
	INSV	R3,#16,#16,R0		; LOAD UPPER HALF FOR TRANSFER SIZE
	RSB
;
; I/O ERROR READING OVERLAY INTO MEMORY.  DEALLOCATE BLOCK AND EXIT WITH STATUS
;
30$:	PUSHR	#^M<R0,R1>		; SAVE I/O STATUS BLOCK
	MOVL	R6,R0			; SET ADDRESS OF BUFFER
	MOVL	R3,R1			; SET LENGTH OF BUFFER
	BSBW	RSX$DEALLOCATE		; DEALLOCATE STORAGE IN HAND
	POPR	#^M<R0,R1>		; RESTORE I/O STATUS BLOCK
	BRB	90$			; AND EXIT
	.END
