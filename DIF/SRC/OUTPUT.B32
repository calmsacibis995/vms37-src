MODULE DIF_OUTPUT (			! Differences output routines
		LANGUAGE (BLISS32),
		ADDRESSING_MODE (EXTERNAL=GENERAL,
				 NONEXTERNAL=LONG_RELATIVE),
		IDENT = 'V03-000'
		) =
BEGIN
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:	DCL Differences command
!
! ABSTRACT:	
!		The DCL DIFFERENCES command compares the contents of
!		two files.
!
! ENVIRONMENT:	
!		VAX native, user mode
!
!--
!
! AUTHOR:	Peter George, Benn Schreiber	CREATION DATE:	1-August-1981
!
! MODIFIED BY:
!
!	V03-004	PCG0003		Peter George		07-Jan-1982
!		Handle special SLP operators in first column of text.
!
!	V03-003	DWT0011		David Thiel		28-Dec-1981
!		Reconstruct command line on output listing.
!		Fix problems with very small values of dif$gl_width.
!		Print all of last byte in octal format.
!		Support pretty mode of output -- /IGNORE=PRETTY.
!
!	V03-002	PCG0002		Peter George		14-Oct-1981
!		Change output for when files are identical.
!
!	V03-001	PCG0001		Peter George		08-Sep-1981
!		Do not always put change bar on first record after difference.
!		Always use 8 columns for line numbers/spaces/change bars.
!--


LIBRARY
    'SYS$LIBRARY:STARLET.L32';

REQUIRE
	'DIFPRE';				! DIF prefix file
REQUIRE
	'DIFDEF';				! DIF data structures

!
! Difference global data
!
EXTERNAL
    dif$gl_commdesc : BBLOCK,			! Desc for buffer of comment delimiters
    dif$gl_cmdesc : BBLOCK,			! Descriptor for command line
    dif$gl_ignore : BBLOCK,			! Flags of characters to ignore
    dif$gl_header,				! No. of lines to skip as header
    dif$gl_match,				! No. of records that constitute a match
    dif$gl_maxdif,				! Maximum number of unmatched records
    dif$gl_merged,				! No. of matched lines to follow each list of differences
    dif$gl_parallel,				! Same as above for parallel
    dif$gl_wndwsiz,				! No. of records to search before
						! declaring a mismatch
    dif$gl_flags : BBLOCK,			! Flags
    dif$gl_difrec, 				! No. of difference records found
    dif$gl_difsec,				! No. of difference sections detected
    dif$gl_dumpwidth,				! Width of hex/octal data part of line
    dif$gl_entsperline,				! No. of entries on a hex/octal line
    dif$gl_width,				! Width of lines in output listing
    dif$gl_parwidth,				! Width of lines in parallel listing
    dif$gl_inbuf,				! Address of the input record buffer
    dif$gl_outbuf : REF VECTOR [, BYTE],	! Address of the output record buffer
    dif$gl_faofullbuf : BBLOCK,			! Hex/octal fao full line buffer
    dif$gl_faopartbuf : BBLOCK,			! Hex/octal fao partial line buffer
    dif$gl_faofulldesc : BBLOCK,		! String desc for hex/octal full output line
    dif$gl_faopartdesc : BBLOCK,		! String desc for hex/octal partial output line
!
! Input and output file data structures
!
    dif$gl_masdesc : BBLOCK,			! String desc for input file
    dif$gl_masfdb : BBLOCK,			! Master file fdb
    dif$gl_masrab : BBLOCK,			! RAB for master file
    dif$gl_revdesc : BBLOCK,			! String desc for revision file
    dif$gl_revfdb : BBLOCK,			! Revision file fdb
    dif$gl_revrab : BBLOCK,			! RAB for revision file
    dif$gl_outdesc : BBLOCK,			! String desc for output file
    dif$gl_outrab : BBLOCK;			! RAB for output file

EXTERNAL ROUTINE
    dif$format_hex_octal,			! Format a record in either hex or octal
    ots$cvt_l_ti,				! Convert longword to text
    sys$fao;					! FAO conversion routine

FORWARD ROUTINE
    additional_output,				! Output 2nd, 3rd, ... listings
    get_rfa_text,				! Get record text using RFA
    init_hex_octal,				! Prepare for hex or octal output
    insert_linenum,				! Insert a line # in output line
    output_changebar,				! Output in change bar format
    output_listing_trailer,			! Output listing trailer
    output_cmdfile,				! Output file line of trailer
    output_cmdfao,				! Output command using $FAO
    output_cmdcounted,				! Output counted entity
    output_cmdentity,				! Output command line entity
    output_merged,				! Output in merged format
    output_parallel,				! Output in parallel format
    output_separated,				! Output in separated format
    output_slp,					! Output in SLP format
    put_blank,					! Output a blank line
    put_desc,					! Output a descriptor
    put_hex_octal_header,			! Output hex/octal record header
    put_idline,					! Output a file id line
    put_parallel_idline,			! Output a parallel file id line
    put_record,					! Output a record in appropriate radix
    put_record_ascii,				! Output an ascii record
    put_record_hex_octal,			! Output a hex or octal record
    put_record_parallel,			! Output a parallel format record
    translate_tabs,				! Convert tabs to blanks
    write_mismatch;				! Output records in a mismatch

OWN
    cmd_bufpos,					! Position for command output
    cr :	COUNTEDSTRING ('<CR>'),
    ff :	COUNTEDSTRING ('<FF>'),
    lf :	COUNTEDSTRING ('<LF>'),
    vt :	COUNTEDSTRING ('<VT>'),
    blanks :	COUNTEDSTRING ('        '),
    period :	COUNTEDSTRING ('.'),
    change :	COUNTEDSTRING (' ***CHANGE***'),
    difrec : 	COUNTEDSTRING ('Number of difference records found: !ZL'),
    difsec : 	COUNTEDSTRING ('Number of difference sections found: !ZL'),
    file : 	COUNTEDSTRING ('File '),
    hexfull : 	COUNTEDSTRING ('!!!ZL(9XL) !!!ZLAF !!6XL'),
    hexheader : COUNTEDSTRING ('RECORD NUMBER !ZL (!8XL) LENGTH !ZL (!8XL) !AS'),
    hexpart :	COUNTEDSTRING ('!!!!!!ZL(9XL) !!!!!ZLAF !!!!6XL'),
    octfull : 	COUNTEDSTRING ('!!!ZL(12OL) !!!ZLAF !!6OL'),
    octheader : COUNTEDSTRING ('RECORD NUMBER !ZL (!8OL) LENGTH !ZL (!8OL) !AS'),
    octpart :	COUNTEDSTRING ('!!!!!!ZL(12OL) !!!!!ZLAF !!!!6OL'),
    slpoprs :	COUNTEDSTRING ('-\%@/<'),
    stars : 	COUNTEDSTRING ('************');

LITERAL
    ffeed = 12;				! form feed character

EXTERNAL LITERAL
    dif$_readerr,
    dif$_writeerr;


GLOBAL ROUTINE write_mismatch =
BEGIN

!++
! 
! FUNCTIONAL DESCRIPTION:
!
!	When the end of a mismatch is detected, this routine is used t
!	call the output routine for the appropriate user-specified output 
!	format.  The order of the IF - THEN - ELSE statements is significant
!	because this control structure is imbedded in several other places
!	in the Diff code.
!
! INPUTS:
!
!	None
!
! OUTPUTS:
!
!	dif$gl_difsec is incremented
!
! ROUTINE VALUES:
!
!	Always true
!
!--
dif$gl_difsec = .dif$gl_difsec + 1;		! Incr count of diff sections

IF .dif$gl_flags [dif$v_parallel]		! Call appropriate routine
   THEN output_parallel ()

ELSE IF .dif$gl_flags [dif$v_merged]
   THEN output_merged ()

ELSE IF .dif$gl_masfdb [fdb$v_separated]
   THEN output_separated (dif$gl_masfdb)

ELSE IF .dif$gl_revfdb [fdb$v_separated]
   THEN output_separated (dif$gl_revfdb)

ELSE IF .dif$gl_masfdb [fdb$v_changebar]
   THEN output_changebar (dif$gl_masfdb)

ELSE IF .dif$gl_revfdb [fdb$v_changebar]
   THEN output_changebar (dif$gl_revfdb)

ELSE IF .dif$gl_flags [dif$v_slp]
   THEN output_slp ();

RETURN true;
END;

GLOBAL ROUTINE additional_output =
BEGIN

!++
! 
! FUNCTIONAL DESCRIPTION:
!
!	Output any additional listings, i.e. additional formats or radices,
!	that have been requested.
!
! INPUTS:
!
!	None
!
! OUTPUTS:
!
!	None
!
! ROUTINE VALUES:
!
!	Always true
!
!--

LOCAL
   first,					! Flag set if finishing first listing
   save_flags : BBLOCK [4],			! save dif$gl_flags
   dashdesc : BBLOCK [dsc$c_s_bln],		! Descriptor for dashes
   stardesc : BBLOCK [dsc$c_s_bln];		! Descriptor for stars

!
! If SLP output, then cannot have any more output forms, so return.
!
IF .dif$gl_flags [dif$v_slp]
   THEN RETURN true;

!
! Set up descriptor for stars.
!
stardesc [dsc$w_length] = .stars [0];
stardesc [dsc$a_pointer] = stars [1];

!
! If init flag is still set, then no differences were found.
! So, cleanup current listing, but don't output any additional listings.
!
IF .dif$gl_flags [dif$v_init]
   THEN BEGIN
	IF NOT .dif$gl_flags [dif$v_parallel]
	   AND NOT .dif$gl_flags [dif$v_merged]
	   AND NOT .dif$gl_masfdb [fdb$v_separated]
	   AND NOT .dif$gl_revfdb [fdb$v_separated]
	   THEN BEGIN
		put_desc (stardesc);
		put_blank ();
		END;
	RETURN true;
	END;

!
! If parallel output, then do special processing.
!
IF .dif$gl_flags [dif$v_parallel]
   THEN BEGIN
	first = false;					! Note that first listing is now done
	dashdesc [dsc$w_length] = .dif$gl_parwidth;	! Build and output line of dashes
	dashdesc [dsc$a_pointer] = .dif$gl_outbuf;
	CH$FILL (%ASCII '-', .dif$gl_parwidth, .dif$gl_outbuf);
	put_desc (dashdesc);
	put_blank ();					! Output a blank line
	IF (NOT .dif$gl_masfdb [fdb$v_move] AND NOT .dif$gl_revfdb [fdb$v_move])
	   THEN RETURN true;				! No more listings? - then return
	END
   ELSE first = true;					! Note that first listing is not yet finished


!
! If no more output, then use common (non-PARALLEL, non-SLP) ending, 
! and return.
!
IF (NOT .dif$gl_masfdb [fdb$v_move] AND NOT .dif$gl_revfdb [fdb$v_move])
   THEN BEGIN
	IF NOT .dif$gl_flags [dif$v_merged]	! Output stars for all but MERGED
	   THEN put_desc (stardesc);
	put_blank ();				! Output a blank line
	RETURN true;				! All done
	END;

!
! Save flags so they can be restored later
!
save_flags = .dif$gl_flags;

!
! Loop for all possible output formats.
!
INCR i FROM 1 TO 3 				! For each radix
DO BEGIN

IF ((.i EQL 1) AND .dif$gl_flags [dif$v_ascii]) OR	! If radix specified
   ((.i EQL 2) AND .dif$gl_flags [dif$v_hex]) OR
   ((.i EQL 3) AND .dif$gl_flags [dif$v_octal])
THEN BEGIN					! Then generate requested listings

     IF (.i NEQ 1) AND (NOT .first)		! If hex or octal, and not already inited
	THEN init_hex_octal ();			! Then init

!
! For each listing format,
!
!	1. If first listing, then 
!		reset flag,
!		output terminating lines.
!
!	2. If not first listing, then
!		set init flag so that header will be output
!		output listing,
!		output terminating lines.
!

     IF .dif$gl_flags [dif$v_merged]		! Generate MERGED output
	THEN BEGIN
	     IF .first
		THEN first = false
		ELSE BEGIN
		     dif$gl_flags [dif$v_init] = true;
		     output_merged ();
		     END;
	     put_blank ();
	     END;

     IF .dif$gl_masfdb [fdb$v_separated]	! Generate SEPARATED output for master file
	THEN BEGIN
	     IF .first
		THEN first = false
		ELSE BEGIN
		     dif$gl_flags [dif$v_init] = true;
		     output_separated (dif$gl_masfdb);
		     END;
	     put_desc (stardesc);
	     put_blank ();
	     END;

     IF .dif$gl_revfdb [fdb$v_separated]	! Generate SEPARATED output for revision file
	THEN BEGIN
	     IF .first
		THEN first = false
		ELSE BEGIN
		     dif$gl_flags [dif$v_init] = true;
		     output_separated (dif$gl_revfdb);
		     END;
	     put_desc (stardesc);
	     put_blank ();
	     END;

     IF .dif$gl_masfdb [fdb$v_changebar]	! Generate CHANGE_BAR output for master file
	THEN BEGIN
	     IF .first
		THEN first = false
		ELSE BEGIN
		     dif$gl_flags [dif$v_init] = true;
		     output_changebar (dif$gl_masfdb);
		     END;
	     put_desc (stardesc);
	     put_blank ();
	     END;

     IF .dif$gl_revfdb [fdb$v_changebar]	! Generate CHANGE_BAR output for revision file
	THEN BEGIN
	     IF .first
		THEN first = false
		ELSE BEGIN
		     dif$gl_flags [dif$v_init] = true;
		     output_changebar (dif$gl_revfdb);
		     END;
	     put_desc (stardesc);
	     put_blank ();
	     END;

     END;

!
! If done outputing a radix, then clear that bit.
!
IF .i EQL 1
   THEN dif$gl_flags [dif$v_ascii] = false
   ELSE IF .i EQL 2
	   THEN dif$gl_flags [dif$v_hex] = false
	   ELSE dif$gl_flags [dif$v_octal] = false;

END;

!
! restore flags
!
dif$gl_flags [dif$v_ascii] = .save_flags [dif$v_ascii];
dif$gl_flags [dif$v_hex] = .save_flags [dif$v_hex];
dif$gl_flags [dif$v_octal] = .save_flags [dif$v_octal];

RETURN true;
END;

GLOBAL ROUTINE output_listing_trailer =
BEGIN

!++
! 
! FUNCTIONAL DESCRIPTION:
!
!	Output the trailer for the listing.
!
! INPUTS:
!
!	None.
!
! OUTPUTS:
!
!	The trailer is output.
!
! ROUTINE VALUES:
!
!	Always true
!
!--
LOCAL
    linedesc : BBLOCK [dsc$c_s_bln],		! Local string descs
    flag,
    mask,					! mask
    outdesc : BBLOCK [dsc$c_s_bln];

cmd_bufpos = 0;			! initialize output routine

IF .dif$gl_flags [dif$v_slp]			! If SLP
   THEN BEGIN					! Then just output slash
	linedesc [dsc$w_length] = 1;
	linedesc [dsc$a_pointer] = UPLIT('/');
	put_desc (linedesc);
	RETURN true;
	END;

!
! Output the number of difference sections.
!
output_cmdfao (difsec, .dif$gl_difsec);
output_cmdentity (0);

!
! Output the number of difference records.
!
output_cmdfao (difrec, .dif$gl_difrec);
output_cmdentity (0);

!
! Skip a line and then output the command line.
!

put_blank ();

output_cmdcounted (cstring ('DIFFERENCES '));

IF .dif$gl_flags [dif$v_ignore]		! /IGNORE
THEN
    BEGIN
    BIND
	list = PLIT (
	    UPLIT (ign$m_blnklin,	%ASCIC 'BLANK_LINES'),
	    UPLIT (ign$m_comments,	%ASCIC 'COMMENTS'),
	    UPLIT (ign$m_exact,		%ASCIC 'EXACT'),
	    UPLIT (ign$m_formfeed,	%ASCIC 'FORM_FEEDS'),
	    UPLIT (ign$m_header,	%ASCIC 'HEADER'),
	    UPLIT (ign$m_pretty,	%ASCIC 'PRETTY'),
	    UPLIT (ign$m_traiblnk,	%ASCIC 'TRAILING_SPACES'),
	    UPLIT (ign$m_spacing,	%ASCIC 'SPACING')) : VECTOR [, LONG];
    mask = 0;
    DECR i FROM .list [-1] - 1 TO 0
    DO
	mask = .mask OR (..list [.i] AND .dif$gl_ignore);
    output_cmdcounted (cstring ('/IGNORE=('));
    DECR i FROM .list [-1] - 1 TO 0
    DO
	IF (..list [.i] AND .mask) NEQ 0
	THEN
	    BEGIN
	    mask = .mask AND NOT ..list [.i];
	    output_cmdcounted (.list [.i]+4);
	    IF (..list [.i] AND ign$m_header) NEQ 0	! special case HEADER
	    THEN
		output_cmdfao (cstring ('=!UL'), .dif$gl_header);
	    IF .mask NEQ 0
	    THEN
		output_cmdcounted (cstring (','));
	    END;
    output_cmdcounted (cstring (')'));
    END;

IF .dif$gl_flags [dif$v_comdel]		! /COMMENT_DELIMITERS
THEN
    BEGIN
    output_cmdcounted (cstring ('/COMMENT_DELIMITERS'));
    IF .dif$gl_commdesc [dsc$w_length] NEQ 0
    THEN
	BEGIN
	output_cmdcounted (cstring ('=('));
	INCR i FROM 0 to .dif$gl_commdesc [dsc$w_length]-1
	DO
	    BEGIN
	    SELECTONE CH$RCHAR (.dif$gl_commdesc [dsc$a_pointer]+.i) OF
	    SET
	    [%C':'] : output_cmdcounted (cstring ('COLON'));
	    [%C','] : output_cmdcounted (cstring ('COMMA'));
	    [%C'!'] : output_cmdcounted (cstring ('EXCLAMATION'));
	    [ffeed] : output_cmdcounted (cstring ('FORM_FEED'));
	    [%C'['] : output_cmdcounted (cstring ('LEFT'));
	    [%C']'] : output_cmdcounted (cstring ('RIGHT'));
	    [%C':'] : output_cmdcounted (cstring ('SEMI_COLON'));
	    [%C'/'] : output_cmdcounted (cstring ('SLASH'));
	    [%C' '] : output_cmdcounted (cstring ('SPACE'));
	    [%C'	'] : output_cmdcounted (cstring ('TAB'));
	    [OTHERWISE] :
		BEGIN
		outdesc [dsc$w_length] = 1;
		outdesc [dsc$a_pointer] = .dif$gl_commdesc [dsc$a_pointer]+.i;
		output_cmdfao (cstring ('"!AS"'), outdesc);
		END;
	    TES;
	    IF .i NEQ .dif$gl_commdesc [dsc$w_length]-1
	    THEN
		output_cmdcounted (cstring (','));
	    END;
	output_cmdcounted (cstring (')'));
	END;
    END;

IF .dif$gl_flags [dif$v_width]			! /WIDTH or /LINE_WIDTH
THEN
    output_cmdfao (cstring ('/WIDTH=!UL'), .dif$gl_width);

IF .dif$gl_flags [dif$v_match]			! /MATCH
THEN
    output_cmdfao (cstring ('/MATCH=!UL'), .dif$gl_match);

IF .dif$gl_flags [dif$v_maxdif]			! /MAXIMUM_DIFFERENCES
THEN
    output_cmdfao (cstring ('/MAXIMUM_DIFFERENCES=!UL'), .dif$gl_maxdif);

IF .dif$gl_flags [dif$v_merged]			! /MERGED
THEN
    output_cmdfao (cstring ('/MERGED=!UL'), .dif$gl_merged);

IF NOT .dif$gl_flags [dif$v_ascii]		! /MODE
    OR .dif$gl_flags [dif$v_hex]
    OR .dif$gl_flags [dif$v_octal]
THEN
    BEGIN
    BIND
	list = PLIT (
	    UPLIT (dif$m_ascii,		%ASCIC 'ASCII'),
	    UPLIT (dif$m_hex,		%ASCIC 'HEXADECIMAL'),
	    UPLIT (dif$m_octal,		%ASCIC 'OCTAL')) : VECTOR [, LONG];
    mask = 0;
    DECR i FROM .list [-1] - 1 TO 0
    DO
	mask = .mask OR (..list [.i] AND .dif$gl_flags);
    output_cmdcounted (cstring ('/MODE=('));
    DECR i FROM .list [-1] - 1 TO 0
    DO
	IF (..list [.i] AND .mask) NEQ 0
	THEN
	    BEGIN
	    mask = .mask AND NOT ..list [.i];
	    output_cmdcounted (.list [.i]+4);
	    IF .mask NEQ 0
	    THEN
		output_cmdcounted (cstring (','));
	    END;
    output_cmdcounted (cstring (')'));
    END;

IF .dif$gl_flags [dif$v_output]			! /OUTPUT
THEN
    BEGIN
    output_cmdcounted (cstring ('/OUTPUT='));
    output_cmdentity (dif$gl_outdesc);
    END;

IF .dif$gl_flags [dif$v_parallel]		! /PARALLEL
THEN
    output_cmdcounted (cstring ('/PARALLEL'));

IF .dif$gl_masfdb [fdb$v_separated] AND .dif$gl_revfdb [fdb$v_separated]
THEN
    output_cmdcounted (cstring ('/SEPARATED'))
ELSE IF .dif$gl_masfdb [fdb$v_separated]
THEN
    output_cmdcounted (cstring ('/SEPARATED=MASTER'))
ELSE IF .dif$gl_revfdb [fdb$v_separated]
THEN
    output_cmdcounted (cstring ('/SEPARATED=REVISION'));

IF .dif$gl_flags [dif$v_slp]			! /SLP
THEN
    output_cmdcounted (cstring ('/SLP'));

IF .dif$gl_flags [dif$v_window]			! /WINDOW
THEN
    output_cmdfao (cstring ('/WINDOW=!UL'), .dif$gl_wndwsiz);

IF NOT .dif$gl_flags [dif$v_linenum]		! /NUMBER
THEN
    output_cmdcounted (cstring ('/NONUMBER'));

output_cmdcounted (cstring (''));		! terminate line

output_cmdfile (dif$gl_masfdb);			! output master file line
output_cmdcounted (cstring (''));		! terminate line

output_cmdfile (dif$gl_revfdb);			! output revision file line
output_cmdentity (0);				! finish the output

! put_desc (dif$gl_cmdesc);			! original command line

RETURN true;
END;

ROUTINE output_cmdfile (fdb) =
BEGIN

!++
! 
! FUNCTIONAL DESCRIPTION:
!
!	Output a file line in the trailer of the listing.
!
! INPUTS:
!
!	fdb =	address of file descriptor block for file
!
! OUTPUTS:
!
!	A file line of the trailer is output.
!
! ROUTINE VALUES:
!
!	Always true
!
!--
MAP
    fdb : REF BBLOCK;				! file descriptor block

LOCAL
    outdesc : BBLOCK [dsc$c_s_bln];

output_cmdentity (.fdb [fdb$l_fildesc]);
IF .fdb [fdb$v_changebar]
THEN
    BEGIN
    output_cmdcounted (cstring ('/CHANGE_BAR'));
    IF (.fdb [fdb$v_linenum] XOR .dif$gl_flags [dif$v_linenum])
	OR .fdb [fdb$b_cbarchr] NEQ %C'!'
    THEN
	output_cmdcounted (cstring ('=('));
    IF .fdb [fdb$b_cbarchr] NEQ %C'!'
    THEN
	BEGIN
	outdesc [dsc$w_length] = 1;
	outdesc [dsc$a_pointer] = fdb [fdb$b_cbarchr];
	output_cmdfao (cstring ('"!AS"'), outdesc);
	END;
    IF (.fdb [fdb$v_linenum] XOR .dif$gl_flags [dif$v_linenum])
	AND .fdb [fdb$b_cbarchr] NEQ %C'!'
    THEN
	output_cmdcounted (cstring (','));
    IF .fdb [fdb$v_linenum] AND NOT .dif$gl_flags [dif$v_linenum]
    THEN
	output_cmdcounted (cstring ('NUMBER'))
    ELSE IF NOT .fdb [fdb$v_linenum] AND .dif$gl_flags [dif$v_linenum]
    THEN
	output_cmdcounted (cstring ('NONUMBER'));
    IF (.fdb [fdb$v_linenum] XOR .dif$gl_flags [dif$v_linenum])
	OR .fdb [fdb$b_cbarchr] NEQ %C'!'
    THEN
	output_cmdcounted (cstring (')'));
    END;

RETURN true;
END;

ROUTINE output_cmdfao (control, data1) =
BEGIN

!++
! 
! FUNCTIONAL DESCRIPTION:
!
!	Output part of trail using $FAO with one argument.
!
! INPUTS:
!
!	control =	$FAO control string (counted string)
!	data1	=	$FAO data item number 1
!
! OUTPUTS:
!
!	Part of the trailer is output.
!
! ROUTINE VALUES:
!
!	Always true
!
!--
MAP
    control : REF VECTOR [, BYTE];

LOCAL
    ctrdesc : BBLOCK [dsc$c_s_bln],		! control string descriptor
    outdesc : BBLOCK [dsc$c_s_bln],
    tmpbuf : VECTOR [nam$c_maxrss+dif$c_maxlisiz, BYTE];	! formatting buffer

ctrdesc [dsc$w_length] = .control [0];
ctrdesc [dsc$a_pointer] = control [1];
outdesc [dsc$w_length] = %ALLOCATION (tmpbuf);
outdesc [dsc$a_pointer] = tmpbuf;
SYS$FAO (ctrdesc, outdesc [dsc$w_length], outdesc, .data1);
output_cmdentity (outdesc);

RETURN true;
END;

ROUTINE output_cmdcounted (str) =
BEGIN

!++
! 
! FUNCTIONAL DESCRIPTION:
!
!	Output a command line entity.  Insert new
!	lines as necessary.
!
! INPUTS:
!
!	str =		Counted string to output
!
! OUTPUTS:
!
!	The entity is inserted in the output buffer.  Output buffers
!	are written as required.
!
! IMPLICIT INPUTS/OUTPUTS:
!
!	cmd_bufpos =	current position in output buffer
!
! ROUTINE VALUES:
!
!	Always true.
!
!--
MAP
    str : REF VECTOR [, BYTE];			! counted string

LOCAL
    outdesc : BBLOCK [dsc$c_s_bln];		! string descriptor

outdesc [dsc$w_length] = .str [0];
outdesc [dsc$a_pointer] = str [1];
output_cmdentity (outdesc);

RETURN true; 
END;

ROUTINE output_cmdentity (descr) =
BEGIN

!++
! 
! FUNCTIONAL DESCRIPTION:
!
!	Output a command line entity.  Insert new
!	lines as necessary.
!
! INPUTS:
!
!	descr =		descriptor of entity to output
!			If descr = 0, output buffer
!			If length = 0, output buffer with continuation mark
!			Otherwise, buffer and output data
!
! OUTPUTS:
!
!	The entity is inserted in the output buffer.  Output buffers
!	are written as required.
!
! IMPLICIT INPUTS/OUTPUTS:
!
!	cmd_bufpos =	current position in output buffer
!
! ROUTINE VALUES:
!
!	Always true.
!
!--
MAP
    descr : REF BBLOCK;				! string descriptor

LOCAL
    outdesc : BBLOCK [dsc$c_s_bln];		! string descriptor

LITERAL
    indent = MINU (4, dif$c_minlisiz-1);	! indentation of continuation line

IF .descr EQL 0
THEN
    BEGIN					! flush output buffer
    outdesc [dsc$w_length] = .cmd_bufpos;
    outdesc [dsc$a_pointer] = .dif$gl_outbuf;
    put_desc (outdesc);
    cmd_bufpos = 0;
    END
ELSE IF .descr [dsc$w_length] EQL 0
THEN
    BEGIN				! output line with continuation
    dif$gl_outbuf [.cmd_bufpos] = %C'-';
    cmd_bufpos = .cmd_bufpos+1;
    output_cmdentity (0);		! output line
    CH$FILL (%C' ', indent, .dif$gl_outbuf);
    cmd_bufpos = indent;
    END
ELSE IF .descr [dsc$w_length] LEQU .dif$gl_width-.cmd_bufpos-1
THEN
    BEGIN				! fits on current line
    CH$MOVE (.descr [dsc$w_length], .descr [dsc$a_pointer], dif$gl_outbuf [.cmd_bufpos]);
    cmd_bufpos = .cmd_bufpos+.descr [dsc$w_length];
    END
ELSE IF .descr [dsc$w_length] LEQU .dif$gl_width-indent-1
THEN
    BEGIN				! output line and put on new line
    outdesc [dsc$w_length] = 0;
    output_cmdentity (outdesc);		! output line with continuation
    output_cmdentity (.descr);		! put entity on new line
    END
ELSE					! item too big for one line
    BEGIN
    IF .dif$gl_width-.cmd_bufpos-1 EQL 0
    THEN
	BEGIN
	outdesc [dsc$w_length] = 0;
	output_cmdentity (outdesc);
	END;
    outdesc [dsc$a_pointer] = .descr [dsc$a_pointer];
    WHILE true
    DO
	BEGIN
	outdesc [dsc$w_length] = MINU (
	    .dif$gl_width-.cmd_bufpos-1,
	    .descr [dsc$a_pointer]+.descr [dsc$w_length]-.outdesc [dsc$a_pointer]);
	output_cmdentity (outdesc);
	outdesc [dsc$a_pointer] = .outdesc [dsc$a_pointer]+.outdesc [dsc$w_length];
	IF .outdesc [dsc$a_pointer] EQLA .descr [dsc$a_pointer]+.descr [dsc$w_length]
	THEN
	    EXITLOOP;
	outdesc [dsc$w_length] = 0;
	output_cmdentity (outdesc);	! output line with continuation
	cmd_bufpos = 0;			! no indentation
	END;
    END;

RETURN true; 
END;

ROUTINE output_changebar (fdb)  =
BEGIN

!++
! 
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called to output the most recent set of records,
!	read from a particular input file, in CHANGEBAR format.
!
! INPUTS:
!
!	fdb =	The address of the FDB of the desired input file.
!
! OUTPUTS:
!
!	The differences are written in changebar format to the output file.
!
! ROUTINE VALUES:
!
!	Always true
!
!--

MAP
    fdb : REF BBLOCK;

LOCAL
    cbarflag,				! Flag to output a change bar
    prevmatch,				! Flag is true if last record was a match
    rdb : REF BBLOCK;			! Address of the RDB of the current record

rdb = .fdb [fdb$l_firstdif];				! Get first difference record
prevmatch = true;					! Assume last record was a match

WHILE (.rdb NEQ .fdb [fdb$l_compnrec])			! Output all unmatched records
DO BEGIN
   IF .prevmatch AND .rdb [rdb$v_matchone]		! Ouput change bar if difference or if
      THEN cbarflag = 1					! first match after a deletion
      ELSE cbarflag = (IF .rdb [rdb$v_match] THEN 2 ELSE 1);
   fdb [fdb$l_currec] = .rdb;				! Specify RDB of output record
   put_record (.fdb, .cbarflag);			! Output the record
   prevmatch = .rdb [rdb$v_match];			! Update previous match flag
   rdb = .rdb [rdb$l_flink];				! Get next record
   END;

IF .prevmatch AND .rdb [rdb$v_matchone]			! Output change bar if first match
   THEN cbarflag = 1					! after a deletion
   ELSE cbarflag = (IF .rdb [rdb$v_match] THEN 2 ELSE 1);
fdb [fdb$l_currec] = .rdb;				! Specify RDB of output record
put_record (.fdb, .cbarflag);				! Output the record

RETURN true;
END;

ROUTINE output_merged =
BEGIN

!++
! 
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called to output the most recent set of detected
!	differences in MERGED format.
!
! IMPLICIT INPUTS:
!
!	The FDB's of the master and revision files.
!
! OUTPUTS:
!
!	The differences are written to the output file in merged format.
!
! ROUTINE VALUES:
!
!	Always true
!
!--

LOCAL
    done,					! Flag is set when all differences have been output
    fdb : REF BBLOCK,				! Address of FDB of current output source
    rdb : REF BBLOCK,				! Address of RDB of current record
    stardesc : BBLOCK [dsc$c_s_bln];		! Descriptor for line of stars

IF .dif$gl_flags [dif$v_init]				! If init flag is set
   THEN dif$gl_flags [dif$v_init] = false;		! Then reset flag

done = false;							! Init until flag
stardesc [dsc$a_pointer] = stars [1];				! Init star desc address field
stardesc [dsc$w_length] = .stars [0];				! Init star desc length field
dif$gl_masfdb [fdb$l_comp1rec] = .dif$gl_masfdb [fdb$l_firstdif]; ! Get first unmatched record
dif$gl_revfdb [fdb$l_comp1rec] = .dif$gl_revfdb [fdb$l_firstdif]; ! from each input file

DO BEGIN							! Loop until all differences output

fdb = dif$gl_masfdb;						! Output master file differences first
	
INCR i FROM 1 TO 2						! For both input files
DO BEGIN							! Output differences

   put_desc (stardesc);						! Output line of stars
   put_idline (.fdb);						! Output file id line
   rdb = .fdb [fdb$l_comp1rec];

   WHILE ((NOT .rdb [rdb$v_matchone]) AND 			! Output all unmatched records
	(NOT .rdb [rdb$v_eof]))	
   DO BEGIN
      IF NOT .rdb [rdb$v_match]					! If not a match record
	 THEN BEGIN						! Then output it
	      fdb [fdb$l_currec] = .rdb;			! Specify record to output
	      put_record (.fdb, 0);				! Output record
	      END;
      rdb = .rdb [rdb$l_flink];					! Get next record
      END;

   INCR j FROM 1 TO .dif$gl_merged				! Output specified number of trailing
   DO BEGIN							! matched records

      IF .rdb EQL .fdb [fdb$l_compnrec]				! Check to see if no more differences
         THEN done = true;					! No more, then set flag

      IF .rdb [rdb$v_ignored]					! If ignore, then can't be a match
	 THEN BEGIN
	      j = j-1;						! Look again for a matched record
	      IF .dif$gl_ignore [ign$v_exact]			! If exact output
		 THEN BEGIN					! then, first output this one
		      fdb [fdb$l_currec] = .rdb;		! Specify record to output
		      put_record (.fdb, 0);			! Output record
		      END;
	      END
	 ELSE BEGIN						! Match, so output record
	      fdb [fdb$l_currec] = .rdb;			! Specify record to output
	      put_record (.fdb, 0);				! Output record
	      END;

      rdb = .rdb [rdb$l_flink];					! Get next record
      END;

   IF .rdb EQL .fdb [fdb$l_compnrec]				! Check to see if no more differences
      THEN done = true;						! No more, then set flag

   fdb [fdb$l_comp1rec] = .rdb;					! Respecify first record of next potential
								! difference section
   fdb = dif$gl_revfdb;						! Get revision file fdb
   stardesc [dsc$w_length] = .stars [0] / 2;			! Use fewer stars
   END;								! Of increment

stardesc [dsc$w_length] = .stars [0];				! Init star desc length field
put_desc (stardesc);						! Output stars

END								! Of Until
UNTIL (.done);

RETURN true;
END;								! Of output_merged

ROUTINE output_parallel =
BEGIN

!++
! 
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called to output the most recent set of detected
!	differences in PARALLEL format.  Note that unlike all the other output
!	routines, except SLP, this routine assumes it is being called on the
!	fly as difference sections are being discovered.
!
! IMPLICIT INPUTS:
!
!	The FDB's of the master and revision files.
!
! OUTPUTS:
!
!	The differences are written to the output file in parallel format.
!
! ROUTINE VALUES:
!
!	Always true
!
!--

LOCAL
    linedesc : BBLOCK [dsc$c_s_bln],		! Descriptor for output line
    match,					! Number of match records output to date
    masrdb : REF BBLOCK,			! Address of RDB of current record from master file
    revrdb : REF BBLOCK;			! Address of RDB of current record from revision file

IF .dif$gl_flags [dif$v_init]				! If init flag is set
   THEN BEGIN						! Then output listing header
	dif$gl_flags [dif$v_init] = false;		! And reset flag
	put_parallel_idline ();
	END;	

masrdb = .dif$gl_masfdb [fdb$l_firstdif];		! Get first difference record from each file
revrdb = .dif$gl_revfdb [fdb$l_firstdif];

!
! Initialize the output descriptor and fill it with dashes.
!
linedesc [dsc$w_length] = .dif$gl_parwidth;
linedesc [dsc$a_pointer] = .dif$gl_outbuf;
CH$FILL (%ASCII '-', .linedesc [dsc$w_length], .linedesc [dsc$a_pointer]);

!
! If line numbers are requested, then insert them amidst the dashes.
! Either way, output the line of dashes.
!
IF .dif$gl_flags [dif$v_linenum]
   THEN BEGIN
	linedesc [dsc$w_length] = .dif$gl_parwidth/ 4;
	insert_linenum (.masrdb, linedesc, 1);
	linedesc [dsc$w_length] = 3 * .dif$gl_parwidth/ 4;
	insert_linenum (.revrdb, linedesc, 1);
	linedesc [dsc$w_length] = .dif$gl_parwidth;
	END;
put_desc (linedesc);

!
! While the difference sections are of equal length, output the difference 
! records with text from both files.
!
WHILE (NOT .masrdb [rdb$v_matchone] AND NOT .revrdb [rdb$v_matchone]
	AND NOT .masrdb [rdb$v_eof] AND NOT .revrdb [rdb$v_eof])
DO IF .masrdb [rdb$v_ignored] AND NOT .dif$gl_ignore [ign$v_exact]
      THEN masrdb = .masrdb [rdb$l_flink]
      ELSE IF .revrdb [rdb$v_ignored] AND NOT .dif$gl_ignore [ign$v_exact]
	      THEN revrdb = .revrdb [rdb$l_flink]
	      ELSE BEGIN
	   	   put_record_parallel (.masrdb, .revrdb);
		   masrdb = .masrdb [rdb$l_flink];
		   revrdb = .revrdb [rdb$l_flink];
		   END;

!
! While the master file difference section is longer than the revision
! file difference section, output the difference records with text from 
! only the master file.
!
WHILE (NOT .masrdb [rdb$v_matchone] AND NOT .masrdb [rdb$v_eof])
DO BEGIN
   IF (NOT .masrdb [rdb$v_ignored]) OR .dif$gl_ignore [ign$v_exact]
      THEN put_record_parallel (.masrdb, 0);
   masrdb = .masrdb [rdb$l_flink];
   END;

!
! While the revision file difference section is longer than the master
! file difference section, output the difference records with text from 
! only the revision file.
!
WHILE (NOT .revrdb [rdb$v_matchone] AND NOT .revrdb [rdb$v_eof])
DO BEGIN
   IF (NOT .revrdb [rdb$v_ignored]) OR .dif$gl_ignore [ign$v_exact]
      THEN put_record_parallel (0, .revrdb);
   revrdb = .revrdb [rdb$l_flink];
   END;

!
! Output matches from both files, until we are either done, or one of the 
! files runs out of records.
!
match = 0;
WHILE (.match NEQU .dif$gl_parallel) AND (NOT .masrdb [rdb$v_eof]) 
      AND (NOT .revrdb [rdb$v_eof])
DO IF .masrdb [rdb$v_ignored] AND NOT .dif$gl_ignore [ign$v_exact]
      THEN masrdb = .masrdb [rdb$l_flink]
      ELSE IF .revrdb [rdb$v_ignored] AND NOT .dif$gl_ignore [ign$v_exact]
	      THEN revrdb = .revrdb [rdb$l_flink]
	      ELSE BEGIN
	   	   put_record_parallel (.masrdb, .revrdb);
		   masrdb = .masrdb [rdb$l_flink];
		   revrdb = .revrdb [rdb$l_flink];
		   match = .match + 1;
		   END;

RETURN true;
END;								! Of output_parallel

ROUTINE output_separated (fdb)  =
BEGIN

!++
! 
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called to output the most recent set of detected
!	differences from a particular input file in SEPARATED format.
!
! INPUTS:
!
!	fdb = The address of the FDB of the desired input file.
!
! OUTPUTS:
!
!	The differences are written to the separated output file.
!
! ROUTINE VALUES:
!
!	Always true
!
!--

MAP
    fdb : REF BBLOCK;

LOCAL
    rdb : REF BBLOCK,			! Address of the RDB of the current record
    stardesc : BBLOCK [dsc$c_s_bln];	! Descriptor for stars

IF .dif$gl_flags [dif$v_init]				! If init flag is set
   THEN BEGIN						! Then output listing header
	dif$gl_flags [dif$v_init] = false;		! And reset flag
	stardesc [dsc$w_length] = .stars [0];
	stardesc [dsc$a_pointer] = stars [1];
	put_desc (stardesc);
	put_idline (.fdb);
	END;	

rdb = .fdb [fdb$l_firstdif];				! Get first difference record

WHILE (.rdb NEQ .fdb [fdb$l_compnrec])			! Output all unmatched records
DO BEGIN	
   IF NOT .rdb [rdb$v_match]				! If difference
      THEN BEGIN					! Then, output it
	   fdb [fdb$l_currec] = .rdb;			! Specify output record
	   put_record (.fdb, 0);			! Output the record
	   END;
   rdb = .rdb [rdb$l_flink];				! Get the next record
   END;

RETURN true;
END;

ROUTINE output_slp =
BEGIN

!++
! 
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called to output the most recent edit to the
!	SLP output file.  Unlike all the other output routine, except
!	PARALLEL, this routine assumes that it is being called on the
!	fly, as each new difference section is detected.
!
! IMPLICIT INPUTS:
!
!	The FDB's of the two input files.
!
! OUTPUTS:
!
!	The edits are written to the output file in SLP format.
!
! ROUTINE VALUES:
!
!	Always true
!
!--

LOCAL
    charptr,					! Pointer into output buffer
    linedesc : BBLOCK [dsc$c_s_bln],		! Descriptor of output line
    number,					! Record number
    rdb : REF BBLOCK;				! Address of the RDB of the current record

BIND
    firstrdb = .dif$gl_masfdb [fdb$l_firstdif] : BBLOCK,	! RDB of first record in difference section
    compnrdb = .dif$gl_masfdb [fdb$l_compnrec] : BBLOCK;	! RDB of first match after difference section


IF .dif$gl_flags [dif$v_init]				! If init flag is set
   THEN dif$gl_flags [dif$v_init] = false;		! Then reset flag

charptr = .dif$gl_outbuf;				! Init ptr to output buffer
CH$WCHAR_A (%C'-', charptr);				! Insert "-" in output buffer
linedesc [dsc$b_class] = dsc$k_class_s;			! Set desc class for RTL routine

IF firstrdb EQL compnrdb				! Are we deleting any lines?
   THEN number = .firstrdb [rdb$l_number]		! No, then get starting point of insertion
   ELSE BEGIN						! Yes, then we must be replacing lines
	linedesc [dsc$w_length] = dif$c_linenum - 1;	! Put number of first line to replace into
	linedesc [dsc$a_pointer] = .charptr;		! the output buffer
	OTS$CVT_L_TI (firstrdb [rdb$l_number], linedesc);
	charptr = .charptr + dif$c_linenum - 1;
	number = .compnrdb [rdb$l_number];		! Get number of line after last line to replace
	END;

IF (number = .number - 1) NEQ 0				! Calculate number of last line to replace
							! or point of insertion
   THEN BEGIN						! If not at beginning of file
	IF firstrdb NEQ compnrdb			! Then if replacing,
	   THEN CH$WCHAR_A (%C',', charptr);		! Then insert a comma in the output buffer
	linedesc [dsc$w_length] = dif$c_linenum - 1;	! Insert the number in the output buffer
	linedesc [dsc$a_pointer] = .charptr;
	OTS$CVT_L_TI (number, linedesc);
	charptr = .charptr + dif$c_linenum - 1;
	END;
	
linedesc [dsc$a_pointer] = .dif$gl_outbuf;		! Initialize the output buffer
linedesc [dsc$w_length] = .charptr - .dif$gl_outbuf;	! Set length to amount of buffer already used
put_desc (linedesc);					! Output the edit command

rdb = .dif$gl_revfdb [fdb$l_firstdif];			! Get first record of insertion

WHILE (.rdb NEQ .dif$gl_revfdb [fdb$l_compnrec])	! Output each record of the insertion
DO BEGIN
   dif$gl_revfdb [fdb$l_currec] = .rdb;			! Specify the output record
   put_record (dif$gl_revfdb, 0);			! Output the record
   rdb = .rdb [rdb$l_flink];				! Get the next record
   END;

RETURN true;
END;

GLOBAL ROUTINE put_record (fdb, cbarflag) =
BEGIN

!++
! 
! FUNCTIONAL DESCRIPTION:
!
!	Call the appropriate radix output routine to format and put a 
!	record to the output file.
!
! INPUTS:
!
!	fdb =	    The address of the FDB pointing to the CURREC that is
!		    to be output.
!
!	cbarflag =  A flag that is 0 if not changebar format
!		    		   1 if changebar format and bar should be output
!				   2 if changebar format and bar should not be ouput
!
! OUTPUTS:
!
!	The CURREC is output.
!
! ROUTINE VALUES:
!
!	Always true
!
!--
MAP
    fdb : REF BBLOCK;

LOCAL
    rdb : REF BBLOCK,
    stardesc : BBLOCK [dsc$c_s_bln];

!
! If init flag is set, then this must be a change bar listing.  Output header
! here, instead of in OUTPUT_CHANGEBAR, because we can never tell if the first
! record output will be a match or a difference.
!
IF .dif$gl_flags [dif$v_init]				! If init flag is set
   THEN BEGIN						! Then output listing header
	dif$gl_flags [dif$v_init] = false;		! And reset flag
	stardesc [dsc$w_length] = .stars [0];
	stardesc [dsc$a_pointer] = stars [1];
	put_desc (stardesc);
	put_idline (.fdb);
	END;	

rdb = .fdb [fdb$l_currec];					! Get address of RDB of record to output

IF .rdb [rdb$v_eof] OR 						! If EOF or,
   (.rdb [rdb$v_ignored] AND NOT .dif$gl_ignore [ign$v_exact])	! ignore and not exact
   THEN RETURN true;						! Then don't output, simply return

IF .dif$gl_flags [dif$v_ascii]					! Call appropriate mode record output routine
   THEN put_record_ascii (.fdb, .cbarflag)
   ELSE put_record_hex_octal (.fdb, .cbarflag);

RETURN true;
END;

ROUTINE put_record_ascii (fdb, cbarflag) =
BEGIN

!++
! 
! FUNCTIONAL DESCRIPTION:
!
!	Format and put a record to the output file in ascii mode.
!
! INPUTS:
!
!	fdb =	    The address of the FDB pointing to the CURREC that is
!		    to be output.
!
!	cbarflag =  A flag that is 0 if not changebar format
!		    		   1 if changebar format and bar should be output
!				   2 if changebar format and bar should not be ouput
!
! OUTPUTS:
!
!	The CURREC is output.
!
! ROUTINE VALUES:
!
!	Always true
!
!--

MAP
    fdb : REF BBLOCK;

LOCAL
    charptr,					! Pointer into the output buffer
    linedesc : BBLOCK [dsc$c_s_bln],		! Descriptor of output line
    rdb : REF BBLOCK,				! Address of the RDB of the record to be output
    text_length,				! Space in record for text
    status;

rdb = .fdb [fdb$l_currec];					! Get address of RDB of record to output

linedesc [dsc$w_length] = 0;					! Init the output descriptor
linedesc [dsc$a_pointer] = .dif$gl_outbuf;
charptr = .dif$gl_outbuf;					! Init the pointer into the output buffer

IF .cbarflag NEQ 0						! If change bar format output

!
! Change bar format.  If line number is requested, then insert number 
! into the output buffer.  Then insert change bar or blanks, as
! appropriate.
!
   THEN BEGIN
	IF .fdb [fdb$v_linenum]					! If line number should be included
	   THEN BEGIN						! Then do so
		insert_linenum (.rdb, linedesc, 0);		! Insert line number in the buffer
		charptr = .charptr + dif$c_linenum;		! Incr the char ptr
		END;

	IF .cbarflag EQL 1					! If this record requires change bar
	   THEN CH$WCHAR_A (.fdb [fdb$b_cbarchr], charptr)	! Then insert one
	   ELSE CH$WCHAR_A (%C' ', charptr);			! Else leave a space instead

	CH$WCHAR_A (%C' ', charptr);				! Pad with a blank

	END

!
! If not changebar, then if line numbers requested then insert the line number.
!
   ELSE IF .dif$gl_flags [dif$v_linenum]			! If line number should be incuded
	   THEN BEGIN						! Then do so
		insert_linenum (.rdb, linedesc, 0);		! Insert line number in the buffer
		charptr = .charptr + dif$c_linenum;		! Incr char ptr
		CH$WCHAR_A (%C' ', charptr);			! Pad with two blanks
		CH$WCHAR_A (%C' ', charptr);
		END;

!
! If SLP output, then handle special operators in first column.
!
IF .dif$gl_flags [dif$v_slp]					! If SLP output
   THEN IF (.rdb [rdb$w_length] GTR 0) AND			! and non-null record
	   (CH$FIND_CH (.slpoprs [0],				! and leading operator
			slpoprs [1],
			CH$RCHAR (rdb [rdb$t_text])) NEQ 0)
	   THEN CH$WCHAR_A (%C'<', charptr);			! then insert escape operator

linedesc [dsc$w_length] = .charptr - .dif$gl_outbuf;		! Set length to amount of buffer already used
IF .dif$gl_width GTRU .linedesc [dsc$w_length]			! Proceed only if room remains on line
THEN
    BEGIN
    IF .dif$gl_ignore [ign$v_exact] AND .rdb [rdb$v_edited]	! If outputing exact, and if record has been edited
    THEN
	get_rfa_text (.fdb, linedesc, .dif$gl_width)		! Then get original record using RFA 
    ELSE BEGIN							! Else use edited string
	text_length = MINU (.dif$gl_width - .linedesc [dsc$w_length],	! Calculate amount of space left for text
		.rdb [rdb$w_length]);
	CH$MOVE (.text_length, rdb [rdb$t_text], .charptr);	! Move text into buffer
	linedesc [dsc$w_length] = .linedesc [dsc$w_length] + .text_length;	! Update string length
	END;
    END;

IF .dif$gl_ignore [ign$v_pretty]				! If PRETTY mode, edit output line
THEN
    linedesc [dsc$w_length] =
	translate_tabs (.linedesc [dsc$a_pointer], .charptr, .linedesc [dsc$w_length], .dif$gl_width);

put_desc (linedesc);						! Output the line

RETURN true;
END;

ROUTINE put_record_hex_octal (fdb, cbarflag) =
BEGIN

!++
! 
! FUNCTIONAL DESCRIPTION:
!
!	Format and put a record to the output file in either hex or octal.
!
! INPUTS:
!
!	fdb =	    The address of the FDB pointing to the CURREC that is
!		    to be output.
!
!	cbarflag =  A flag that is 0 if not changebar format
!		    		   1 if changebar format and bar should be output
!				   2 if changebar format and bar should not be ouput
!
! OUTPUTS:
!
!	The CURREC is output.
!
! ROUTINE VALUES:
!
!	Always true
!
!--

MAP
    fdb : REF BBLOCK;

LITERAL
    byte_bits = 8,		! number of bits in a byte
    hex_bits = 4,		! number of bits in a hexadecimal digit
    oct_bits = 3;		! number of bits in an octal digit

LOCAL
    additional,
    bufferpointer,
    bytenumber,
    bytesperline,
    entsinrec,
    faopointer,
    linedesc : BBLOCK [dsc$c_s_bln],
    outputdesc : BBLOCK [dsc$c_s_bln],
    padbytes,
    tempfaobuf : BBLOCK [dif$c_maxfaosiz],
    tempfaodesc : BBLOCK [dsc$c_s_bln],
    rdb : REF BBLOCK;

rdb = .fdb [fdb$l_currec];					! Get address of RDB of output record

!
! Get exact or edited text, as appropriate.
!
IF .dif$gl_ignore [ign$v_exact] AND .rdb [rdb$v_edited]	
   THEN BEGIN
	linedesc [dsc$w_length] = 0;
	linedesc [dsc$a_pointer] = .dif$gl_inbuf;
	get_rfa_text (.fdb, linedesc, 
		MAXU (.dif$gl_masrab [rab$w_usz], .dif$gl_revrab [rab$w_usz]));
	END
   ELSE BEGIN
	linedesc [dsc$w_length] = .rdb [rdb$w_length];
	linedesc [dsc$a_pointer] = rdb [rdb$t_text];
	END;

!
! Output the record header.
!
put_blank ();
put_hex_octal_header (.rdb [rdb$l_number], .linedesc [dsc$w_length], .cbarflag);
put_blank ();

!
! Initialize output format parameters.
!
bytenumber = 0;
bytesperline = .dif$gl_entsperline * dif$c_entrysize;
entsinrec = (.linedesc [dsc$w_length] + dif$c_entrysize - 1) / dif$c_entrysize;
faopointer = dif$gl_faofulldesc;

!
! Initialize output descriptor.
!
outputdesc [dsc$a_pointer] = .dif$gl_outbuf;	   
outputdesc [dsc$w_length] = .dif$gl_dumpwidth;

!
! Output all the data in the record.
!
WHILE .entsinrec GTR 0
DO BEGIN
   
!
! If less than a full line of data left, then prepare to output a partial line.
!
   IF .linedesc [dsc$w_length] LSSU .bytesperline
      THEN BEGIN
	   CH$COPY (.linedesc [dsc$w_length], .linedesc [dsc$a_pointer],	! Copy partial line, zero fill to end
		    0, .bytesperline, .dif$gl_inbuf);
	   tempfaodesc [dsc$w_length] = dif$c_maxfaosiz;			! Set up temporary work area
	   tempfaodesc [dsc$a_pointer] = tempfaobuf;
	   SYS$FAO (dif$gl_faopartdesc, tempfaodesc, tempfaodesc, .entsinrec);	! Use FAO to build a fao control string
	   faopointer = tempfaodesc;						! Use this fao string up ahead
	   bufferpointer = .dif$gl_inbuf;					! Use this data
	   END
      ELSE bufferpointer = .linedesc [dsc$a_pointer];				! If full line, use this data

!
! Format the output line.
!
   dif$format_hex_octal (.bufferpointer, .dif$gl_entsperline, dif$c_entrysize,
			 .bytenumber, .entsinrec, 0, .faopointer, outputdesc);


!
! If partial line, then remove leading zeros and replace with blanks.
!
   IF .linedesc [dsc$w_length] LSSU .bytesperline
      THEN BEGIN
	   padbytes = .dif$gl_dumpwidth - .outputdesc [dsc$w_length];
	   !
	   ! Calculate number of blanks to proceed last few bytes
	   ! The value is :
	   !   1 plus length of formatted longword less length of formatted bytes
	   !
	   IF (additional = .linedesc [dsc$w_length] MOD dif$c_entrysize) GTR 0
	      THEN
		 IF .dif$gl_flags [dif$v_hex]
		 THEN
		    additional = 1
			+ (dif$c_entrysize*byte_bits+(hex_bits-1))/hex_bits
			- (.additional*byte_bits+(hex_bits-1))/hex_bits
		 ELSE
		    additional = 1
			+ (dif$c_entrysize*byte_bits+(oct_bits-1))/oct_bits
			- (.additional*byte_bits+(oct_bits-1))/oct_bits;
	   padbytes = .padbytes + .additional;
	   CH$MOVE (.outputdesc [dsc$w_length] - .additional,
		    .outputdesc [dsc$a_pointer] + .additional,
		    .outputdesc [dsc$a_pointer] + .padbytes);	   
	   CH$FILL (%ASCII ' ', .padbytes, .outputdesc [dsc$a_pointer]);
	   outputdesc [dsc$w_length] = .dif$gl_dumpwidth;
	   END;

!
! Output the fully formatted line.
!
   put_desc (outputdesc);

!
! Update parameters that mark our place in the data.
!
   entsinrec = .entsinrec - .dif$gl_entsperline;
   bytenumber = .bytenumber + .bytesperline;
   linedesc [dsc$w_length] = .linedesc [dsc$w_length] - .bytesperline;
   linedesc [dsc$a_pointer] = .linedesc [dsc$a_pointer] + .bytesperline;
   END;
	   

RETURN true;
END;

ROUTINE put_record_parallel (masrdb, revrdb) =
BEGIN

!++
! 
! FUNCTIONAL DESCRIPTION:
!
!	Format and put a record to the output file in parallel mode.
!
! INPUTS:
!
!	masrdb = The address of the RDB for the master file record.
!
!	revrdb = The address of the RDB for the revision file record.
!
! OUTPUTS:
!
!	The specified records are output in parallel mode.
!
! ROUTINE VALUES:
!
!	Always true
!
!--

MAP
    masrdb : REF BBLOCK,
    revrdb : REF BBLOCK;

LOCAL
    halfline,				! Amount of space for each file
    linedesc : BBLOCK [dsc$c_s_bln],	! Descriptor for output string
    text_length;			! Amount of space left for record text

halfline = (.dif$gl_parwidth - 5)/ 2;		! Calculate amount of space for each file

linedesc [dsc$a_pointer] = .dif$gl_outbuf;	! Clear the output descriptor/buffer
CH$FILL (%ASCII ' ', .dif$gl_parwidth, .linedesc [dsc$a_pointer]);

!
! If masrdb is not zero, then insert text for master file.
! Use exact or edited text, as appropriate.
!
IF .masrdb NEQ 0
   THEN IF .dif$gl_ignore [ign$v_exact] AND .masrdb [rdb$v_edited]
	   THEN BEGIN
		linedesc [dsc$w_length] = 0;
		dif$gl_masfdb [fdb$l_currec] = .masrdb;
		get_rfa_text (dif$gl_masfdb, linedesc, .halfline);
		END
	   ELSE BEGIN		
		text_length = MINU (.halfline, .masrdb [rdb$w_length]);
		CH$MOVE (.text_length, masrdb [rdb$t_text],
			 .linedesc [dsc$a_pointer]);
		END;
!
! Remove tabs from text and insert mid-line bar.
!
translate_tabs (.dif$gl_outbuf, .dif$gl_outbuf, .halfline, .halfline);
CH$WCHAR (%ASCII '|', .dif$gl_outbuf + .halfline + 2);

!
! If revrdb is not zero, then insert text for master file.
! Use exact or edited text, as appropriate.
!
IF .revrdb NEQ 0
   THEN IF .dif$gl_ignore [ign$v_exact] AND .revrdb [rdb$v_edited]
	   THEN BEGIN
		linedesc [dsc$w_length] = .halfline + 5;
		dif$gl_revfdb [fdb$l_currec] = .revrdb;
		get_rfa_text (dif$gl_revfdb, linedesc, .dif$gl_parwidth);
		END
	   ELSE BEGIN
		text_length = MINU (.halfline, .revrdb [rdb$w_length]);
		CH$MOVE (.text_length, revrdb [rdb$t_text], 
			 .linedesc [dsc$a_pointer] + .halfline + 5);
		END;

!
! Remove tabs from remainder of text and output the line.
!
linedesc [dsc$w_length] =
   translate_tabs (.dif$gl_outbuf, .dif$gl_outbuf + .halfline + 5, .dif$gl_parwidth, .dif$gl_parwidth);
put_desc (linedesc);

RETURN true;
END;

ROUTINE translate_tabs (bufaddr, start, buflen, maxlen) =
BEGIN

!++
! 
! FUNCTIONAL DESCRIPTION:
!
!	Convert the tabs in the buffer, starting at start, to spaces.
!	Also replace line feeds, form feeds, and carriage returns with
!	appropriate text.
!
! INPUTS:
!
!	bufaddr =	Address of the input buffer.
!
!	start =		Address of first char to examine.
!
!	buflen =	Length of the input text.
!
!	maxlen =	Length of buffer
!
! OUTPUTS:
!
!	All tabs are converted to spaces.
!
! ROUTINE VALUES:
!
!	Length of translated text
!
!--
LOCAL
    charptr,				! Address of character to translate
    endptr,				! Address of last byte to translate+1
    maxptr,				! Address of last byte of buffer+1
    fill,				! Number of characters to insert
    textaddr : REF VECTOR [, BYTE];	! Address of text to insert

charptr = .start;					! Starting character
endptr = .bufaddr + .buflen;				! Last character to translate+1
maxptr = .bufaddr + .maxlen;				! End of buffer+1

WHILE (.charptr LSSA .endptr)				! Examine all characters
DO BEGIN
   IF CH$RCHAR (.charptr) GEQU %X'20'
	AND CH$RCHAR (.charptr) LEQU %X'7E'
   THEN							! Printing character
	charptr = .charptr + 1
   ELSE
	BEGIN
	SELECTONE CH$RCHAR (.charptr) OF
	SET
	[%X'09']:					! Tab
	   BEGIN
	   fill = 8 - ((.charptr - .start) MOD 8);	! Calculate number of spaces to use
	   textaddr = blanks [1];			! Insert blanks
	   END;

	[%X'0A']:					! Line feed
	   BEGIN
 	   textaddr = lf;				! Insert <LF>
	   fill = .textaddr [0];			! Length of string
	   textaddr = textaddr [1];			! Text address
	   END;

	[%X'0B']:					! Vertical tab
	   BEGIN
	   textaddr = vt;				! Insert <CR>
	   fill = .textaddr [0];			! Length of string
	   textaddr = textaddr [1];			! Text address
	   END;

	[%X'0C']:					! Form feed
	   BEGIN
	   textaddr = ff;				! Insert <FF>
	   fill = .textaddr [0];			! Length of string
	   textaddr = textaddr [1];			! Text address
	   END;

	[%X'0D']:					! Carriage return
	   BEGIN
	   textaddr = cr;				! Insert <CR>
	   fill = .textaddr [0];			! Length of string
	   textaddr = textaddr [1];			! Text address
	   END;

	[OTHERWISE]:					! All other characters
	   BEGIN
	   textaddr = period;				! Insert period
	   fill = .textaddr [0];			! Length of string
	   textaddr = textaddr [1];			! Text address
	   END;

	TES;

	IF .fill GTR .maxptr - .charptr			! Shorten it if it goes past end of buffer
	   THEN fill = .maxptr - .charptr;
	endptr = CH$MOVE (				! Shift the unexamined text over
		MIN (					! and update endptr
			.maxptr - .charptr - .fill,	! Target space available
			.endptr - .charptr - 1),	! Number of source characters remaining
		.charptr+1,
		.charptr + .fill);
	charptr = CH$MOVE (.fill, .textaddr, .charptr);	! Insert the text and update charptr
	END;
   END;

RETURN .charptr-.bufaddr;
END;

ROUTINE put_hex_octal_header (number, length, cbarflag) =
BEGIN

!++
! 
! FUNCTIONAL DESCRIPTION:
!
!	Put a hex or octal record header to the output file.
!
! INPUTS:
!
!	number =   The number of the record.
!
!	length =   The length of the record in bytes.
!
!	cbarflag =  A flag that is 0 if not changebar format
!		    		   1 if changebar format and bar should be output
!				   2 if changebar format and bar should not be ouput
!
!
! OUTPUTS:
!
!	None
!
! ROUTINE VALUES:
!
!	Always true
!
!--
LOCAL
    changedesc : BBLOCK [dsc$c_s_bln],			! Desc for change text
    faodesc : BBLOCK [dsc$c_s_bln],			! Desc for fao control string
    linedesc : BBLOCK [dsc$c_s_bln];			! Desc for output string

linedesc [dsc$w_length] = .dif$gl_dumpwidth;		! Init output desc 
linedesc [dsc$a_pointer] = .dif$gl_outbuf;	

IF .dif$gl_flags [dif$v_hex] 					! Init fao desc
   THEN BEGIN
	faodesc [dsc$w_length] = .hexheader [0];
	faodesc [dsc$a_pointer] = hexheader [1];
	END
   ELSE BEGIN
	faodesc [dsc$w_length] = .octheader [0];
	faodesc [dsc$a_pointer] = octheader [1];
	END;

changedesc [dsc$a_pointer] = change [1];			! Init change desc
IF .cbarflag
   THEN changedesc [dsc$w_length] = .change [0]
   ELSE changedesc [dsc$w_length] = 0;

!
! Generate output string and write it to the file.
!
SYS$FAO (faodesc, linedesc, linedesc, .number, .number, .length, .length, changedesc);
put_desc (linedesc);

RETURN true;
END;

ROUTINE put_idline (fdb) =
BEGIN

!++
! 
! FUNCTIONAL DESCRIPTION:
!
!	Put a record containing file id line to the output file.
!
! INPUTS:
!
!	fdb = 	The address of the FDB of the file to be described.
!
! OUTPUTS:
!
!	None
!
! ROUTINE VALUES:
!
!	Always true
!
!--

MAP
    fdb : REF BBLOCK;

LOCAL
    linedesc : BBLOCK [dsc$c_s_bln];		! Descriptor for the output string

BIND
    filedesc = fdb [fdb$l_fildesc] : REF BBLOCK [dsc$c_s_bln];	! resultant file name string descriptor

linedesc [dsc$a_pointer] = .dif$gl_outbuf;			! Init output desc pointer to buffer
linedesc [dsc$w_length] = MINU (				! Set output desc size
    .file [0] + .filedesc [dsc$w_length],
    .dif$gl_width);

CH$COPY (
    .file [0], file [1],					! 'FILE' string
    .filedesc [dsc$w_length], .filedesc [dsc$a_pointer],	! resultant file name
    0,								! fill never used
    .linedesc [dsc$w_length], .linedesc [dsc$a_pointer]);	! line buffer

put_desc (linedesc);						! Output id line

RETURN true;
END;

ROUTINE put_parallel_idline =
BEGIN

!++
! 
! FUNCTIONAL DESCRIPTION:
!
!	Put a record containing both file ids to the output file,
!	in parallel format.
!
! INPUTS:
!
!	None
!
! OUTPUTS:
!
!	None
!
! ROUTINE VALUES:
!
!	Always true
!
!--

LOCAL
    charptr,					! Pointer into the output descriptor
    linedesc : BBLOCK [dsc$c_s_bln],		! Descriptor for the output string
    namesize;					! Space left for each file name

dif$gl_parwidth = 2 * ((.dif$gl_width - 1)/ 2) + 1;		! Calculate width of parallel listing
linedesc [dsc$w_length] = .dif$gl_parwidth;			! Init output descriptor
linedesc [dsc$a_pointer] = .dif$gl_outbuf;
namesize = (.dif$gl_parwidth - 5)/ 2;				! Calculate space left for each file name

!
! Output a line of dashes.
!
CH$FILL (%ASCII '-', .linedesc [dsc$w_length], .linedesc [dsc$a_pointer]);
put_desc (linedesc);

!
! Build line with both file names.
!
charptr = CH$COPY (
    .file [0],					! Insert 'FILE'
    file [1],
    .dif$gl_masdesc [dsc$w_length],		! Insert master file name
    .dif$gl_masdesc [dsc$a_pointer],
    %ASCII ' ',					! blank fill
    .namesize,					! buffer length
    .linedesc [dsc$a_pointer]);			! buffer address
CH$WCHAR_A (%ASCII ' ', charptr);
CH$WCHAR_A (%ASCII ' ', charptr);
CH$WCHAR_A (%ASCII '|', charptr);		! insert mid-line bar
CH$WCHAR_A (%ASCII ' ', charptr);
CH$WCHAR_A (%ASCII ' ', charptr);
CH$COPY (
    .file [0],					! Insert 'FILE'
    file [1],
    .dif$gl_revdesc [dsc$w_length],		! Insert revision file name
    .dif$gl_revdesc [dsc$a_pointer],
    %ASCII ' ',					! blank fill
    .namesize,					! buffer length
    .charptr);					! buffer address

put_desc (linedesc);				! Output the line

RETURN true;
END;

ROUTINE put_blank =
BEGIN

!++
! 
! FUNCTIONAL DESCRIPTION:
!
!	Put a blank line to the output file.
!
! INPUTS:
!
!	None
!
! OUTPUTS:
!
!	None
!
! ROUTINE VALUES:
!
!	Always true
!
!--

LOCAL
    linedesc : BBLOCK [dsc$c_s_bln],
    tempbuf;

linedesc [dsc$w_length] = 0;
linedesc [dsc$a_pointer] = tempbuf;

put_desc (linedesc);

RETURN true;
END;

ROUTINE put_desc (linedesc) =
BEGIN

!++
! 
! FUNCTIONAL DESCRIPTION:
!
!	Put a descriptor to the output file.
!
! INPUTS:
!
!	linedesc = 	The address of the string descriptor for the text
!			that is to be output.
!
! OUTPUTS:
!
!	None
!
! ROUTINE VALUES:
!
!	Always true
!
!--

MAP
    linedesc : REF BBLOCK;

LOCAL
    status;

dif$gl_outrab [rab$w_rsz] = .linedesc [dsc$w_length];
dif$gl_outrab [rab$l_rbf] = .linedesc [dsc$a_pointer];

IF NOT (status = $PUT (RAB = dif$gl_outrab))
   THEN SIGNAL (dif$_writeerr, 1, dif$gl_outdesc, .status,
		.dif$gl_outrab [rab$l_stv]);

RETURN true;
END;

ROUTINE insert_linenum (rdb, linedesc, condense) =
BEGIN

!++
! 
! FUNCTIONAL DESCRIPTION:
!
!	Insert the line number of the specified record in the output buffer.
!
! INPUTS:
!
!	rdb =	    The address of the RDB of the record whose
!		    line number is to be inserted.
!
!	linedesc =  The address of a string descriptor for the string that
!		    the number is to be inserted at the end of.
!
!	condense =  A flag that is true if the inserted number should not
!		    be padded with more than one blank one each side.
!		    The default is to pad the number out to DIF$C_LINENUM
!		    spaces.
!
! OUTPUTS:
!
!	The line number is inserted in the output buffer, at the specified
!	position.
!
! ROUTINE VALUES:
!
!	Always true
!
!--

MAP
    rdb : REF BBLOCK,
    linedesc : REF BBLOCK;

LOCAL 
    numdesc : BBLOCK [dsc$c_s_bln],				! Descriptor for string to contain numeric text
    numbuf : BBLOCK [dif$c_linenum];				! Buffer to contain numeric text

numdesc [dsc$b_class] = dsc$k_class_s;				! Init RTL output descriptor
numdesc [dsc$w_length] = dif$c_linenum - 1;
numdesc [dsc$a_pointer] = numbuf;

OTS$CVT_L_TI (rdb [rdb$l_number], numdesc);			! Insert line number in buffer

IF .condense							! If inserting in parallel line
   THEN BEGIN							! Then put one blank on each side of number

	WHILE (CH$RCHAR (.numdesc [dsc$a_pointer]) EQL %X '20')
	DO BEGIN 
	   numdesc [dsc$a_pointer] = .numdesc [dsc$a_pointer] + 1;
	   numdesc [dsc$w_length] = .numdesc [dsc$w_length] - 1;
	   END;

	CH$WCHAR (%ASCII ' ', .linedesc [dsc$a_pointer] 
				+ .linedesc [dsc$w_length]);
	linedesc [dsc$w_length] = .linedesc [dsc$w_length] + 1;
	END;

CH$MOVE (.numdesc [dsc$w_length], .numdesc [dsc$a_pointer],
	 .linedesc [dsc$w_length] + .linedesc [dsc$a_pointer]);
CH$WCHAR (%C' ', .linedesc [dsc$a_pointer] + .linedesc [dsc$w_length] 
		+ .numdesc [dsc$w_length]);
linedesc [dsc$w_length] = .linedesc [dsc$w_length] 
				+ .numdesc [dsc$w_length] + 1;

RETURN true;
END;

GLOBAL ROUTINE init_hex_octal =
BEGIN

!++
! 
! FUNCTIONAL DESCRIPTION:
!
!	Prepare for hex or octal output by building the required FAO
!	descriptors and initializing some global variables.
!
! INPUTS:
!
!	None
!
! OUTPUTS:
!
!	None
!
! ROUTINE VALUES:
!
!	Always true
!
!--

LOCAL
    fulldesc : BBLOCK [dsc$c_s_bln],
    offsetsize,
    partdesc : BBLOCK [dsc$c_s_bln];

!
! Calculate the size of each entry in a line.
!
IF .dif$gl_flags [dif$v_hex]
   THEN offsetsize = 9
   ELSE offsetsize = 12;

!
! Calculate the number of longwords to output per line.
! Force it to be a power of two.
!
dif$gl_entsperline = MAXU (
    (.dif$gl_width - dif$c_linenum - 1) / (.offsetsize + dif$c_entrysize),
    1);
IF (.dif$gl_entsperline AND (.dif$gl_entsperline-1)) NEQ 0
THEN
    dif$gl_entsperline = .dif$gl_entsperline AND (.dif$gl_entsperline-1);
   
!
! Calculate the line width.
!
dif$gl_dumpwidth = .dif$gl_entsperline * (.offsetsize + dif$c_entrysize) + 8;

!
! Pick the appropriate FAO descriptors to use.
!
dif$gl_faofulldesc [dsc$w_length] = dif$c_maxfaosiz;
dif$gl_faofulldesc [dsc$a_pointer] = dif$gl_faofullbuf;
dif$gl_faopartdesc [dsc$w_length] = dif$c_maxfaosiz;
dif$gl_faopartdesc [dsc$a_pointer] = dif$gl_faopartbuf;

IF .dif$gl_flags [dif$v_hex]
   THEN BEGIN
	fulldesc [dsc$w_length] = .hexfull [0];
	fulldesc [dsc$a_pointer] = hexfull [1];
	partdesc [dsc$w_length] = .hexpart [0];
	partdesc [dsc$a_pointer] = hexpart [1];
	END
   ELSE BEGIN
	fulldesc [dsc$w_length] = .octfull [0];
	fulldesc [dsc$a_pointer] = octfull [1];
	partdesc [dsc$w_length] = .octpart [0];
	partdesc [dsc$a_pointer] = octpart [1];
	END;

SYS$FAO (fulldesc, dif$gl_faofulldesc, dif$gl_faofulldesc,
	 .dif$gl_entsperline, .dif$gl_entsperline * dif$c_entrysize);
SYS$FAO (partdesc, dif$gl_faopartdesc, dif$gl_faopartdesc,
	 .dif$gl_entsperline * dif$c_entrysize);

RETURN true;
END;

ROUTINE get_rfa_text (fdb, linedesc, width) =
BEGIN

!++
! 
! FUNCTIONAL DESCRIPTION:
!
!	Get a record from an input file using its RFA, and insert it in
!	the output line.
!
! INPUTS:
!
!	fdb =	    The address of the FDB for the input file.
!		    CURREC specifies the record to be read.
!
!	linedesc =  The address of a character string descriptor for the
!		    output line.
!
!	width =	    The size of the input buffer specified by linedesc.
!
! OUTPUTS:
!
!	The read record is appended to linedesc.
!
! ROUTINE VALUES:
!
!	Always true
!
!--

MAP
    fdb : REF BBLOCK,
    linedesc : REF BBLOCK;

LOCAL
    prefix_len,
    rab : REF BBLOCK,
    rdb : REF BBLOCK,
    status;

rab = .fdb [fdb$l_rabptr];
rdb = .fdb [fdb$l_currec];

rab [rab$b_rac] = rab$c_rfa;					! Init RAB for RFA read
CH$MOVE (rfa$c_size, rdb [rdb$w_rfa], rab [rab$w_rfa]);	

IF NOT (status = $GET (RAB = .rab))				! Get the record
   THEN SIGNAL_STOP (dif$_readerr, 1, .fdb [fdb$l_fildesc],	! If error, then signal
		     .status, .rab [rab$l_stv]);

IF .rab [rab$w_rsz] GTR 0					! If record size greater than zero
   THEN BEGIN
	prefix_len = .linedesc [dsc$w_length];			! Set amount of buffer already used
	linedesc [dsc$w_length] = MINU (.width,			! Calculate size of output string
		.linedesc [dsc$w_length] + .rab [rab$w_rsz]);
	CH$MOVE (.linedesc [dsc$w_length] - .prefix_len,	! Move record into buffer
		 .rab [rab$l_rbf], .linedesc [dsc$a_pointer] + .prefix_len);
	END;

!
! After getting a record by RFA, we must reset the RMS pointers for 
! subsequent sequential reads to work.
!
rdb = .fdb [fdb$l_lastrec];
IF .rdb [rdb$v_eof]
   THEN rdb = .fdb [fdb$l_lastrfa];
IF .rdb NEQ 0
   THEN BEGIN
	CH$MOVE (rfa$c_size, rdb [rdb$w_rfa], rab [rab$w_rfa]);	
	IF NOT (status = $FIND (RAB = .rab))
	   THEN SIGNAL_STOP (dif$_readerr, 1, .fdb [fdb$l_fildesc],	! If error, then signal
		     .status, .rab [rab$l_stv]);
	rab [rab$b_rac] = rab$c_seq;					! Reset RAB
	IF NOT (status = $GET (RAB = .rab))
	   THEN SIGNAL_STOP (dif$_readerr, 1, .fdb [fdb$l_fildesc],	! If error, then signal
		     .status, .rab [rab$l_stv]);
	END;

RETURN true;
END;

END								! Of module
ELUDOM
