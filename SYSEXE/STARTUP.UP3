$ SET NOVER
$ !
$ !	This command procedure may be entered in one of two ways:
$ !
$ !		1) Invoked from STARTUP.UP2
$ !		2) As the startup procedure during reboot
$ !
$ !	In order to eliminate error messages incurred by re-executing
$ !	the initialization parts of the startup procedure, STARTUP.UP2
$ !	specifies an input parameter, while the reboot does not.
$ !
$ !		P1 - "CONTINUE", a label in this command procedure
$ !		     where the upgrade should continue if coming
$ !		     directly from STARTUP.UP2 without a reboot
$ !
$ SET NOON
$	WRITE SYS$OUTPUT ""
$	WRITE SYS$OUTPUT "Continuing with VAX/VMS V3.0 Upgrade Procedure"
$	WRITE SYS$OUTPUT ""
$	WRITE SYS$OUTPUT "	Upgrade Phase 3"
$	WRITE SYS$OUTPUT ""
$ P1:="''P1'"	! Make sure P1 is defined
$ IF P1 .NES. "" THEN GOTO 'P1
$ @SYS$SYSTEM:STARTUP.COM UPGRADE
$ !
$ ! Install only those protected shareable images that will be used.
$ !
$ RUN SYS$SYSTEM:INSTALL
SYS$SHARE:DISMNTSHR	/OPEN /SHARED /PROTECT /HEADER
SYS$SHARE:MOUNTSHR	/OPEN /SHARED /PROTECT /HEADER
$	SET DEFAULT SYS$SYSTEM
$	SET UIC [1,4]
$	SET /PROTECTION=(S:RWED,G:RWED,O:RWED,W:RE) /DEFAULT
$	DEFDIR := "SYSUPD.VMS300"
$	FILEOPEN:=""
$	SET ON
$	SET MESSAGE /FACILITY/SEVERITY/TEXT/IDENTIFICATION
$	ON ERROR THEN GOTO 7000
$	ON CONTROL_Y THEN GOTO 7000
$	ON CONTROL_C THEN GOTO 7000
$	SET PROCESS /PRIV=(CMK,SYSP,LOG,VOLPRO,BYPASS)
$	SET PROTECTION=(S:RWED,G:RWED,O:RWED,W:RE)/DEFAULT
$	COPY :== COPY
$	DELETE /SYMBOL /GLOBAL COPY
$ !
$ ! Determine old and new top-level system directories.
$ !
$	NEW_ROOT := "SYSF"
$	OLD_ROOT := "SYS0"
$	OLD_ROOT_DOT := "SYS0."
$	DOT_OLD_ROOT := ".SYS0"
$	IF F$SEARCH("SYS$SYSDEVICE:[0,0]SYS0.DIR;1") .EQS. "" THEN OLD_ROOT := ""
$	IF OLD_ROOT .EQS. "" THEN OLD_ROOT_DOT := ""
$	IF OLD_ROOT .EQS. "" THEN DOT_OLD_ROOT := ""
$
$	SYSDEV := 'F$LOGICAL("SYS$SYSROOT")
$	SYSDEV = SYSDEV - "_"
$25:
$	L = 'F$LOCATE(":",SYSDEV) + 1
$	TARGET := 'F$EXT(0,L,SYSDEV)
$	L = 'F$LOCATE("[",SYSDEV)
$	M = 'F$LOCATE(".",SYSDEV)
$	IF M .EQ. 'F$LENGTH(SYSDEV) THEN GOTO NO_TOPSYS
$	N = M - L + 1
$	TARGET_TOPSYS_DOT := 'F$EXT(L,N,SYSDEV)
$	GOTO 30
$NO_TOPSYS:
$	TARGET_TOPSYS_DOT := ""
$ !
$ ! Determine type of cpu
$ !
$30:
$	CPUTYPE = F$GETSYI("CPU")
$	IF (CPUTYPE .EQ. 1).OR. (CPUTYPE .EQ. 2) THEN GOTO GOT_CPUTYPE
$	IF (CPUTYPE .EQ. 3) THEN -
	WRITE SYS$OUTPUT "Upgrade procedure not supported for cpu type "'cputype'"."
$	GOTO 7000
$GOT_CPUTYPE:
$	SET DEFAULT 'TARGET'['OLD_ROOT_DOT''DEFDIR']
$	ON ERROR THEN GOTO 7000
$	WRITE SYS$OUTPUT ""
$	SYSVER:="V3.0"
$	@DIRCLENUP.COM 'TARGET' 'SYSVER'
$	STOP JOB_CONTROL
$	STOP OPCOM
$	SET UIC [1,6]
$	STOP ERRFMT
$	SET UIC [1,4]
$	SET DEFAULT 'TARGET'['OLD_ROOT_DOT''DEFDIR']
$CONTINUE:
$	SET ON
$	ON ERROR THEN GOTO 7000
$	ON CONTROL_Y THEN GOTO 7000
$	ON CONTROL_C THEN GOTO 7000
$	SET PROCESS /PRIV=(CMK,SYSP,LOG,VOLPRO,BYPASS)
$	VALID_SAVESETS := REQ,LIB,OPT,ALL,EDTCAI
$	VALID_UPGRADES:=IGNORE,KEEP,OVER,UNDER
$	SET DEFAULT SYS$SYSTEM
$	SET UIC [1,4]
$	SET /PROTECTION=(S:RWED,G:RWED,O:RWED,W:RE) /DEFAULT
$	SET DEFAULT SYS$SYSTEM
$	FILENAME:='TARGET'['OLD_ROOT_DOT''DEFDIR']VMSKITBLD.V25
$60:
$	OPEN/READ DATAF 'FILENAME
$	IF $STATUS THEN GOTO 65
$	WRITE SYS$OUTPUT "Unable to open data parameter file",'FILENAME',"."
$	GOTO 7000
$65:
$	FILEOPEN:="YES"
$	CONDIT = 1+2+4+8+64+256	! Use UETP, HELP, DECnet, and Coding Examples
$	ON ERROR THEN GOTO 7000
$	WRITE SYS$OUTPUT ""
$	SET PROC/PRIV=BYPASS
$	SET DEFAULT 'TARGET'['OLD_ROOT_DOT''DEFDIR']
$ !
$ ! Now make another pass through the VMSKITBLD data file,
$ ! to merge in those VMS files not deleted by the upgrade.
$ !
$	WRITE SYS$OUTPUT ""
$	WRITE SYS$OUTPUT "Now merging VMS-distributed files that are commonly"
$	WRITE SYS$OUTPUT "editted by system managers with new VMS files."
$	WRITE SYS$OUTPUT "(Please ignore any undefined symbol and file not"
$	WRITE SYS$OUTPUT "found messages.)"
$	WRITE SYS$OUTPUT ""
$	OPEN/READ DATAF 'FILENAME
$	IF $STATUS THEN GOTO 1065
$	WRITE SYS$OUTPUT "Unable to open data parameter file",'FILENAME',"."
$	GOTO 7000
$1065:
$	FILEOPEN:="YES"
$ !
$ ! This loop is executed to move all V2 files that may have been
$ ! editted by the customer into the SYSF tree.  Some files must be
$ ! placed UNDER the existing versions in the SYSF tree, while others
$ ! must be placed OVER the existing versions.
$ !
$ SET NOVER
$RECORD_LOOP2:
$	READ/END_OF_FILE=4000 DATAF RECORD
$	IF "''F$EXTRACT(0,1,RECORD)'" .EQS. "$" THEN GOTO RECORD_LOOP2
$	IF "''F$EXTRACT(0,1,RECORD)'" .EQS. "!" THEN GOTO RECORD_LOOP2
$ !
$ ! Get the upgrade field from the current record.  (This time only
$ ! the files labelled UPGRADE=UNDER and UPGRADE=OVER are of interest.)
$ !
$GET_UPGRADE2:
$	L = 'F$LOCATE("UPG=",RECORD) + 4
$	UPGRADE := 'F$EXTRACT(L,132,RECORD)
$	L = 'F$LOCATE(",",UPGRADE)
$	UPGRADE := 'F$EXTRACT(0,L,UPGRADE)
$	IF 'F$LOCATE(UPGRADE,VALID_UPGRADES) .NE. 'F$LENGTH(VALID_UPGRADES) -
	THEN GOTO 1240
$	WRITE SYS$OUTPUT "Bad upgrade field specified in record *''RECORD'*"
$	GOTO 7000
$1240:
$ !
$ ! Get the saveset field from the current record.
$ !
$GET_SAVESET2:
$	L = 'F$LOCATE("SET=",RECORD) + 4
$	SAVESET := 'F$EXTRACT(L,132,RECORD)
$	L = 'F$LOCATE(",",SAVESET)
$	SAVESET := 'F$EXTRACT(0,L,SAVESET)
$	IF SAVESET .EQS. "" THEN SAVESET := LIB
$	IF 'F$LOCATE(SAVESET,VALID_SAVESETS) .NE. 'F$LENGTH(VALID_SAVESETS) -
	THEN GOTO 1250
$	WRITE SYS$OUTPUT "Bad saveset field specified in record *''RECORD'*"
$	GOTO 7000
$1250:
$ !
$ ! Get the CONDITIONAL field from the current record.
$ !
$GET_CONDITIONAL2:
$	CONDITIONAL := ""
$	L = 'F$LOCATE("COND=",RECORD) + 5
$	IF L .GE. 'F$LENGTH(RECORD) THEN GOTO GET_NAME2
$	CONDITIONAL := 'F$EXTRACT(L,132,RECORD)
$	IF CONDITIONAL .EQS. "" THEN GOTO GET_NAME2
$	L = 'F$LOCATE(",",CONDITIONAL)
$	CONDITIONAL := 'F$EXTRACT(0,L,CONDITIONAL)
$	IF (CONDITIONAL .AND. CONDIT) .EQ. 0 THEN GOTO RECORD_LOOP2
$ !
$ ! Get the name from the current record.  (The name is always the first field
$ ! in the record, and doesn't have a keyword associated with it.)
$ !
$GET_NAME2:
$	L = 'F$LOCATE(",",RECORD)
$	NAME := 'F$EXTRACT(0,L,RECORD)
$ !
$ ! Get the operation specified by the current record.
$ !
$GET_OPERATION2:
$	L = 'F$LOCATE("OP=",RECORD) + 3
$	OPERATION := 'F$EXTRACT(L,132,RECORD)
$	IF OPERATION .EQS. "" THEN GOTO NORMAL2
$	L = 'F$LOCATE(",",OPERATION)
$	OPERATION := 'F$EXTRACT(0,L,OPERATION)
$	IF (OPERATION .EQS. "BUILD") .OR. (OPERATION .EQS. "COPY") .OR. -
	(OPERATION .EQS. "CONTIG") -
	THEN GOTO NORMAL2
$	IF (OPERATION .EQS. "SET") THEN GOTO SET2
$	GOTO RECORD_LOOP2
$
$NORMAL2:
$	IF (UPGRADE .NES. "UNDER") .AND. (UPGRADE .NES. "OVER") -
	THEN GOTO RECORD_LOOP2
$	ON ERROR THEN CONTINUE
$	@'TARGET'['OLD_ROOT_DOT''DEFDIR']MOVE	'TARGET'['OLD_ROOT_DOT''SETDIR']'NAME';* -
			'TARGET'['NEW_ROOT'.'SETDIR'] -
			MOVE -
			'UPGRADE'
$	ON ERROR THEN GOTO 7000
$	GOTO RECORD_LOOP2
$
$SET2:
$	SET DEFAULT 'TARGET'['OLD_ROOT_DOT''NAME']
$	SETDIR := 'NAME'
$	WRITE SYS$OUTPUT "Now working on files in ["'OLD_ROOT_DOT''NAME'"]."
$	GOTO RECORD_LOOP2
$
$4000:
$	CLOSE DATAF
$	FILEOPEN:=""
$
$	ON ERROR THEN CONTINUE
$	SET PROC/PRIV=BYPASS
$	SET FILE /REMOVE 'TARGET'['OLD_ROOT_DOT'SYSEXE]PAGEFILE.SYS;0
$	SET FILE /REMOVE 'TARGET'['OLD_ROOT_DOT'SYSEXE]SWAPFILE.SYS;0
$	SET FILE /REMOVE 'TARGET'['OLD_ROOT_DOT'SYSEXE]SYSUAF.DAT;0
$	SET FILE /REMOVE 'TARGET'['OLD_ROOT_DOT'SYSEXE]SYSDUMP.DMP;0
$	DELETE 'TARGET'['OLD_ROOT_DOT'SYSMGR]ACCOUNTNG.DAT;*,OPERATOR.LOG;*
$	DELETE 'TARGET'['OLD_ROOT_DOT'SYSERR]*.*;*
$	ON ERROR THEN CONTINUE
$	SET DEFAULT SYS$SYSTEM:
$	@'TARGET'['OLD_ROOT_DOT''DEFDIR']MOVE	'TARGET'['OLD_ROOT_DOT'SYSUPD]*.*;* -
			'TARGET'['NEW_ROOT'.SYSUPD] -
			MOVE -
			NULL
$	@'TARGET'['NEW_ROOT'.'DEFDIR']MOVE	'TARGET'['OLD_ROOT_DOT'SYSEXE]*.*;* -
			'TARGET'['NEW_ROOT'.SYSEXE] -
			MOVE -
			NULL
$	ON ERROR THEN CONTINUE
$	@'TARGET'['NEW_ROOT'.'DEFDIR']MOVE	'TARGET'['OLD_ROOT_DOT'SYSLIB]*.*;* -
			'TARGET'['NEW_ROOT'.SYSLIB] -
			MOVE -
			NULL
$	ON ERROR THEN CONTINUE
$	@'TARGET'['NEW_ROOT'.'DEFDIR']MOVE	'TARGET'['OLD_ROOT_DOT'SYSMGR]*.*;* -
			'TARGET'['NEW_ROOT'.SYSMGR] -
			MOVE -
			NULL
$	ON ERROR THEN CONTINUE
$	@'TARGET'['NEW_ROOT'.'DEFDIR']MOVE	'TARGET'['OLD_ROOT_DOT'SYSMSG]*.*;* -
			'TARGET'['NEW_ROOT'.SYSMSG] -
			MOVE -
			NULL
$	ON ERROR THEN CONTINUE
$	ON ERROR THEN CONTINUE
$	@'TARGET'['NEW_ROOT'.'DEFDIR']MOVE	'TARGET'['OLD_ROOT_DOT'SYSTEST]*.*;* -
			'TARGET'['NEW_ROOT'.SYSTEST] -
			MOVE -
			NULL
$	ON ERROR THEN CONTINUE
$	@'TARGET'['NEW_ROOT'.'DEFDIR']MOVE	'TARGET'['OLD_ROOT_DOT'SYSMAINT]*.*;* -
			'TARGET'['NEW_ROOT'.SYSMAINT] -
			MOVE -
			NULL
$	ON ERROR THEN CONTINUE
$	@'TARGET'['NEW_ROOT'.'DEFDIR']MOVE	'TARGET'['OLD_ROOT_DOT'SYSHLP.EXAMPLES]*.*;* -
			'TARGET'['NEW_ROOT'.SYSHLP.EXAMPLES] -
			MOVE -
			NULL
$	ON ERROR THEN CONTINUE
$	SET FILE /NODIRECTORY 'TARGET'['OLD_ROOT_DOT'SYSHLP]EXAMPLES.DIR;1
$	DELETE 'TARGET'['OLD_ROOT_DOT'SYSHLP]EXAMPLES.DIR;1
$	ON ERROR THEN CONTINUE
$	@'TARGET'['NEW_ROOT'.'DEFDIR']MOVE	'TARGET'['OLD_ROOT_DOT'SYSHLP]*.*;* -
			'TARGET'['NEW_ROOT'.SYSHLP] -
			MOVE -
			NULL
$	ON ERROR THEN CONTINUE
$	TEMP = TARGET + "[000000" + DOT_OLD_ROOT + "]SYSCBI.DIR;1"
$	IF F$SEARCH(TEMP) .EQS. "" THEN -
		GOTO NO_SYSCBI
$	@'TARGET'['NEW_ROOT'.'DEFDIR']MOVE	'TARGET'['OLD_ROOT_DOT'SYSCBI]*.*;* -
			'TARGET'['NEW_ROOT'.SYSCBI] -
			MOVE -
			NULL
$	ON ERROR THEN CONTINUE
$	SET FILE /NODIRECTORY 'TARGET'[000000'DOT_OLD_ROOT']SYSCBI.DIR;1
$	DELETE 'TARGET'[000000'DOT_OLD_ROOT']SYSCBI.DIR;1
$NO_SYSCBI:
$	ON ERROR THEN CONTINUE
$	SET FILE /REMOVE 'TARGET'[000000'DOT_OLD_ROOT']001001.DIR;1
$	ON ERROR THEN CONTINUE
$	SET FILE /REMOVE 'TARGET'[000000'DOT_OLD_ROOT']001002.DIR;1
$	ON ERROR THEN CONTINUE
$	SET FILE /REMOVE 'TARGET'[000000'DOT_OLD_ROOT']001006.DIR;1
$	ON ERROR THEN CONTINUE
$	SET FILE /REMOVE 'TARGET'[000000'DOT_OLD_ROOT']010040.DIR;1
$	ON ERROR THEN CONTINUE
$	SET FILE /NODIRECTORY 'TARGET'[000000'DOT_OLD_ROOT']SYSEXE.DIR;1
$	DELETE 'TARGET'[000000'DOT_OLD_ROOT']SYSEXE.DIR;1
$	ON ERROR THEN CONTINUE
$	SET FILE /NODIRECTORY 'TARGET'[000000'DOT_OLD_ROOT']SYSLIB.DIR;1
$	DELETE 'TARGET'[000000'DOT_OLD_ROOT']SYSLIB.DIR;1
$	ON ERROR THEN CONTINUE
$	SET FILE /NODIRECTORY 'TARGET'[000000'DOT_OLD_ROOT']SYSTEST.DIR;1
$	DELETE 'TARGET'[000000'DOT_OLD_ROOT']SYSTEST.DIR;1
$	ON ERROR THEN CONTINUE
$	SET FILE /NODIRECTORY 'TARGET'[000000'DOT_OLD_ROOT']SYSMAINT.DIR;1
$	DELETE 'TARGET'[000000'DOT_OLD_ROOT']SYSMAINT.DIR;1
$	ON ERROR THEN CONTINUE
$	SET FILE /NODIRECTORY 'TARGET'[000000'DOT_OLD_ROOT']SYSMGR.DIR;1
$	DELETE 'TARGET'[000000'DOT_OLD_ROOT']SYSMGR.DIR;1
$	ON ERROR THEN CONTINUE
$	SET FILE /NODIRECTORY 'TARGET'[000000'DOT_OLD_ROOT']SYSHLP.DIR;1
$	DELETE 'TARGET'[000000'DOT_OLD_ROOT']SYSHLP.DIR;1
$	ON ERROR THEN CONTINUE
$	SET FILE /NODIRECTORY 'TARGET'[000000'DOT_OLD_ROOT']SYSUPD.DIR;1
$	DELETE 'TARGET'[000000'DOT_OLD_ROOT']SYSUPD.DIR;1
$	ON ERROR THEN CONTINUE
$	SET FILE /NODIRECTORY 'TARGET'[000000'DOT_OLD_ROOT']SYSMSG.DIR;1
$	DELETE 'TARGET'[000000'DOT_OLD_ROOT']SYSMSG.DIR;1
$	ON ERROR THEN CONTINUE
$	SET FILE /NODIRECTORY 'TARGET'[000000'DOT_OLD_ROOT']SYSERR.DIR;1
$	DELETE 'TARGET'[000000'DOT_OLD_ROOT']SYSERR.DIR;1
$ !
$ ! Set the desired default EDITOR.
$ !
$	TEMP = TARGET + "[" + NEW_ROOT + "." + DEFDIR + "]EDITSOS.CLD"
$	IF F$SEARCH(TEMP) .EQS. "" THEN -
$		GOTO EDT_DEFAULT
$	WRITE SYS$OUTPUT ""
$	WRITE SYS$OUTPUT "Setting default editor invoked by EDIT command to SOS."
$	WRITE SYS$OUTPUT ""
$	SET COMMAND /TABLES=SYS$LIBRARY:DCLTABLES -
		/OUTPUT=SYS$LIBRARY:DCLTABLES -
		'TARGET'['NEW_ROOT'.'DEFDIR']EDITSOS.CLD
$	DELETE 'TARGET'['NEW_ROOT'.'DEFDIR']EDITSOS.CLD;*
$EDT_DEFAULT:
$ !
$ ! Re-set the sysgen parameter that causes the time/date to be requested
$ ! at boot-time.
$ !
$	RUN SYSGEN
USE CURRENT
SET /STARTUP SYS$SYSTEM:STARTUP.UP4
SET SETTIME 0
WRITE CURRENT
$ @SYS$SYSTEM:STARTUP.UP4 CONTINUE
$
$
$
$	!
$	! On error, exit from the upgrade procedure here.
$	!
$7000:
$	WRITE SYS$OUTPUT ""
$	WRITE SYS$OUTPUT "Upgrade to VAX/VMS Version 3.0 incomplete."
$	WRITE SYS$OUTPUT ""
$	WRITE SYS$OUTPUT "Error exit from upgrade procedure."
$	WRITE SYS$OUTPUT "Restart upgrade from last boot of system."
$	WRITE SYS$OUTPUT ""
$	IF (FILEOPEN .NES. "") THEN CLOSE DATAF
$	EXIT
