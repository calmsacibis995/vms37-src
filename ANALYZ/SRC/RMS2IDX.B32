%title 'RMS2IDX - Analyze Things for Prolog 2 Indexed Files'
	module rms2idx	(
			ident='V03-002') = begin

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! Facility:	VAX/VMS Analyze Facility, Analyze Things for Prolog 2
!
! Abstract:	This module is responsible for analyzing various structures
!		in prolog 2 indexed files.  It also includes those routines
!		that are common to prolog 2 and 3.  
!
!
! Environment:
!
! Author: Paul C. Anagnostopoulos, Creation Date: 11 March 1981
!
! Modified By:
!
!	V03-001	PCA0002		Paul Anagnostopoulos	16-Mar-1982
!		Don't display root and data bucket VBNs if the index
!		is not initialized.
!
!	V03-002	PCA0001		Paul Anagnostopoulos	16-Mar-1982
!		Remove logic for prologue 3 data type array in key
!		descriptor.  It's been decommitted for V3A.
!--

%sbttl 'Module Declarations'
!
! Libraries and Requires:
!

library 'lib';
require 'rmsreq';

!
! Table of Contents:
!

forward routine
	anl$idx_prolog: novalue,
	anl$area_descriptor: novalue,
	anl$key_descriptor,
	anl$2bucket_header,
	anl$2index_record,
	anl$2primary_data_record,
	anl$2format_primary_key: novalue,
	anl$2sidr_record,
	anl$2sidr_pointer;

!
! External References:
!

external routine
	anl$bucket,
	anl$bucket_callback,
	anl$check_flags,
	anl$data_callback,
	anl$format_error,
	anl$format_flags,
	anl$format_hex,
	anl$format_line,
	anl$format_skip,
	anl$index_callback;

external
	anl$gb_mode: byte,
	anl$gl_fat: ref block[,byte],
	anl$gw_prolog: word;

!
! Own Variables:
!

%sbttl 'ANL$IDX_PROLOG - Format and Check an Indexed File Prolog'
!++
! Functional Description:
!	This routine is reponsible for formatting a report and checking
!	the prolog of an indexed file.
!
! Formal Parameters:
!	prolog_bsd	A BSD describing the prolog.
!	report		A boolean, true if we are to print a report.
!	indent_level	The indentation level of the report.
!
! Implicit Inputs:
!	global data
!
! Implicit Outputs:
!	global data
!
! Returned Value:
!	none
!
! Side Effects:
!
!--


global routine anl$idx_prolog(prolog_bsd,report,indent_level): novalue = begin

bind
	p = .prolog_bsd: bsd;

local
	sp: ref block[,byte];


! We can start right off and format the prolog if requested.  Begin with
! a nice heading

sp = .p[bsd$l_bufptr];
if .report then (
	anl$format_line(3,.indent_level,anl$_idxprolog);
	anl$format_skip(0);

	! Format the first area VBN and number of areas.

	anl$format_line(0,.indent_level+1,anl$_idxproareas,.sp[plg$b_amax],.sp[plg$b_avbn]);

	! Format the prolog version number.

	anl$format_line(0,.indent_level+1,anl$_prologver,.sp[plg$w_ver_no]);
);

! Now we can check the prolog.  Make sure the area information is reasonable.

if .sp[plg$b_avbn] lssu 2 or
   .sp[plg$b_amax] eqlu 0	then
	anl$format_error(anl$_badarearoot,.p[bsd$l_vbn]);

return;

end;

%sbttl 'ANL$AREA_DESCRIPTOR: Check and Format an Area Descriptor'
!++
! Functional Description:
!	This routine is responsible for checking the content of an area
!	descriptor and optionally printing a formatted report of it.
!
! Formal Parameters:
!	the_bsd		The address of a BSD describing the area descriptor.
!			We update the BSD to describe the next one.
!	area_id		Alleged ID of this area.
!	report		A boolean, true if we are to print a report.
!	indent_level	The indentation level of the report.
!
! Implicit Inputs:
!	global data
!
! Implicit Outputs:
!	global data
!
! Returned Value:
!	none
!
! Side Effects:
!
!--


global routine anl$area_descriptor(the_bsd,area_id,report,indent_level): novalue = begin

bind
	b = .the_bsd: bsd;


own
	alignment_flags_def: vector[9,long] initial(
				7,
				uplit byte (%ascic 'AREA$V_HARD'),
				uplit byte (%ascic 'AREA$V_ONC'),
				0,
				0,
				0,
				uplit byte (%ascic 'AREA$V_CBT'),
				0,
				uplit byte (%ascic 'AREA$V_CTG')
				),

	alignments: vector[5,long] initial(
				uplit byte (%ascic 'AREA$C_NONE'),
				uplit byte (%ascic 'AREA$C_CYL'),
				uplit byte (%ascic 'AREA$C_LBN'),
				uplit byte (%ascic 'AREA$C_VBN'),
				uplit byte (%ascic 'AREA$C_RFI')
				);

local
	sp: ref block[,byte],
	next_id: long;


! Since we know we have 64 bytes in the block, we don't have to check that
! things actually fit in the block.
! So we can start right off and format the report if requested. Begin with
! a nice header containing the area id.

sp = .b[bsd$l_bufptr] + .b[bsd$l_offset];
if .report then (
	anl$format_line(4,.indent_level,anl$_idxarea,.sp[area$b_areaid],
			.b[bsd$l_vbn],.b[bsd$l_offset]);
	anl$format_skip(0);

	! Format the area bucket size.

	anl$format_line(0,.indent_level+1,anl$_idxareabktsz,.sp[area$b_arbktsz]);

	! Format the allocation alignment.

	anl$format_line(0,.indent_level+1,anl$_idxareaalign,.alignments[.sp[area$b_aln]]);

	! Format the alignment option flags.

	anl$format_flags(.indent_level+1,anl$_idxareaflags,.sp[area$b_aop],alignment_flags_def);

	! Format the reclaimed bucket pointer.  It's only used for prolog 3.

	if .anl$gw_prolog eqlu plg$c_ver_3 then
		anl$format_line(0,.indent_level+1,anl$_idxarearecl,.sp[area$l_avail]);

	! Format the info describing how much of the current extent has been
	! used up.

	anl$format_line(0,.indent_level+1,anl$_idxareaused,.sp[area$l_cvbn],
			.sp[area$l_cnblk],.sp[area$l_used],.sp[area$l_nxtvbn]);

	! Format the info describing the next extent, if present.

	if .sp[area$l_nxt] nequ 0 or .sp[area$l_nxblk] nequ 0 then
		anl$format_line(0,.indent_level+1,anl$_idxareanext,
				.sp[area$l_nxt],.sp[area$l_nxblk]);

	! Format the default extend quantity.

	anl$format_line(0,.indent_level+1,anl$_idxareaqty,.sp[area$w_deq]);

	! Format the related file id, if present.

	if .sp[area$b_aln] eqlu area$c_rfi then
		anl$format_line(0,.indent_level+1,anl$_idxarearelid,
				.sp[44,0,16,0],.sp[44,16,16,0],.sp[44,32,16,0]);
);

! Now we are going to check the contents of the area descriptor.  This is
! a fairly rigorous test, but doesn't check anything that requires looking
! at other structures.

! Start be ensuring that the first two bytes area unused.

if .sp[0,0,16,0] nequ 0 then
	anl$format_error(anl$_badarea1st2,.b[bsd$l_vbn],.area_id);

! Make sure the area ID is correct

if .sp[area$b_areaid] nequ .area_id then
	anl$format_error(anl$_badareaid,.b[bsd$l_vbn],.sp[area$b_areaid],.area_id);

! Check the area bucket size.

if .sp[area$b_arbktsz] lssu 1 or .sp[area$b_arbktsz] gtru 32 then
	anl$format_error(anl$_badareabktsize,.b[bsd$l_vbn],.sp[area$b_arbktsz],.area_id);

! Check the allocation alignment.

if .sp[area$b_aln] gtru 4 then
	anl$format_error(anl$_badareaalign,.b[bsd$l_vbn],.sp[area$b_aln],.area_id);

! Check the alignment option flags.

anl$check_flags(.b[bsd$l_vbn],.sp[area$b_aop],alignment_flags_def);

! We ought to check the current extent information at this point, but no
! one can tell me how it is used.  So the code is commented out for now,
! and a !!!TEMP!!! flag marks the situation.

!if .sp[area$l_used] gtru .sp[area$l_cnblk] or
!   .sp[area$l_cvbn]+.sp[area$l_used] nequ .sp[area$l_nxtvbn] then
!	anl$format_error(anl$_badareaused,.b[bsd$l_vbn]);

! The two items describing the next extent must both be absent or both present.

if .sp[area$l_nxt] eqlu 0 xor .sp[area$l_nxblk] eqlu 0 then
	anl$format_error(anl$_badareanext,.b[bsd$l_vbn],.area_id);

! A related file ID should be present if and only if the allocation
! alignment is by RFI.

if .sp[area$b_aln] eqlu area$c_rfi xor
   ch$neq(area$s_rfi,sp[area$w_rfi], %x'00',0,0) then
	anl$format_error(anl$_badarearfi,.b[bsd$l_vbn],.area_id);

! Now we want to advance on to the next area descriptor, if there is one.
! Begin by reading in the first prolog block.

b[bsd$l_vbn] = 1;
anl$bucket(b,0);

! Determine the id of the next area, or this area again if it's the last one.

sp = .b[bsd$l_bufptr];
next_id = minu(.area_id+1,.sp[plg$b_amax]-1);

! Now read in the appropriate block and set the offset.

b[bsd$l_vbn] = .sp[plg$b_avbn] + .next_id / (512/area$c_bln);
b[bsd$l_offset] = .next_id mod (512/area$c_bln) * area$c_bln;
anl$bucket(b,0);

return;
   
end;

%sbttl 'ANL$KEY_DESCRIPTOR - Print and Check a Key Descriptor'
!++
! Functional Description:
!	This routine is responsible for printing and checking the contents
!	of an indexed file key descriptor.
!
! Formal Parameters:
!	the_bsd		The address of a BSD describing the key descriptor.
!			We update it to describe the next one.
!	key_id		The alleged ID of this key.
!	areas		Address of a vector of 256 bytes, one per area.
!			Contains the bucket size of each area.  Optional.
!	report		A boolean, true if we are to print a report.
!	indent_level	The indentation level of the report.
!
! Implicit Inputs:
!	global data
!
! Implicit Outputs:
!	global data
!
! Returned Value:
!	True if there is another key descriptor, false if not.
!
! Side Effects:
!
!--


global routine anl$key_descriptor(the_bsd,key_id,areas,report,indent_level) = begin

bind
	b = .the_bsd: bsd,
	areas_vector = .areas: vector[256,byte];

own
	key2_primary_def: vector[6,long] initial(
				4,
				uplit byte (%ascic 'KEY$V_DUPKEYS'),
				0,
				0,
				0,
				uplit byte (%ascic 'KEY$V_INITIDX')
				),

	key2_secondary_def: vector[6,long] initial(
				4,
				uplit byte (%ascic 'KEY$V_DUPKEYS'),
				uplit byte (%ascic 'KEY$V_CHGKEYS'),
				uplit byte (%ascic 'KEY$V_NULKEYS'),
				0,
				uplit byte (%ascic 'KEY$V_INITIDX')
				),

	key3_primary_def: vector[9,long] initial(
				7,
				uplit byte (%ascic 'KEY$V_DUPKEYS'),
				0,
				0,
				uplit byte (%ascic 'KEY$V_IDX_COMPR'),
				uplit byte (%ascic 'KEY$V_INITIDX'),
				0,
				uplit byte (%ascic 'KEY$V_KEY_COMPR'),
				uplit byte (%ascic 'KEY$V_REC_COMPR')
				),

	key3_secondary_def: vector[6,long] initial(
				4,
				uplit byte (%ascic 'KEY$V_DUPKEYS'),
				uplit byte (%ascic 'KEY$V_CHGKEYS'),
				uplit byte (%ascic 'KEY$V_NULKEYS'),
				uplit byte (%ascic 'KEY$V_IDX_COMPR'),
				uplit byte (%ascic 'KEY$V_INITIDX')
				);

local
	sp: ref block[,byte],
	i: long,
	position: word, size: byte,
	total_size: long, required_record: long;

builtin
	nullparameter;


! This little internal subroutine receives a data type code and returns
! the address of an ASCIC string naming the data type.

routine data_type_name(code) = begin

own
	data_types: vector[6,long] initial(
				uplit byte (%ascic 'STRING'),
				uplit byte (%ascic 'SGNWORD'),
				uplit byte (%ascic 'UNSGNWORD'),
				uplit byte (%ascic 'SGNLONG'),
				uplit byte (%ascic 'UNSGNLONG'),
				uplit byte (%ascic 'PACKED')
				);

return	(if .code gtru key$c_max_data then uplit byte (%ascic '???')
				      else .data_types[.code]);
end;

! First thing we need to do is ensure that the key descriptor fits in the
! block.  If not, we complain and signal a drastic error.

sp = .b[bsd$l_bufptr] + .b[bsd$l_offset];
if .sp+key$c_bln geqa .b[bsd$l_endptr] then (
	anl$format_error(anl$_badkeyfit,.b[bsd$l_vbn],.key_id);
	signal (anl$_unwind);
);

! Now we can format the key descriptor, if requested.

if .report then (

	! Begin with a heading, containing the key of reference number.

	anl$format_line(3,.indent_level,anl$_idxkey,.sp[key$b_keyref],
			.b[bsd$l_vbn],.b[bsd$l_offset]);
	anl$format_skip(0);

	! Now the next key VBN and offset, if present.

	if .sp[key$l_idxfl] nequ 0 then
		anl$format_line(0,.indent_level+1,anl$_idxkeynext,
				.sp[key$l_idxfl],.sp[key$w_noff]);

	! Now the area IDs.

	anl$format_line(0,.indent_level+1,anl$_idxkeyareas,.sp[key$b_ianum],.sp[key$b_lanum],.sp[key$b_danum]);

	! Now the index root level number.

	anl$format_line(0,.indent_level+1,anl$_idxkeyrootlvl,.sp[key$b_rootlev]);

	! Now the bucket sizes.

	anl$format_line(0,.indent_level+1,anl$_idxkeybktsz,.sp[key$b_idxbktsz],.sp[key$b_datbktsz]);

	! Now the root bucket VBN, if present.

	if not .sp[key$v_initidx] then
		anl$format_line(0,.indent_level+1,anl$_idxkeyrootvbn,.sp[key$l_rootvbn]);

	! Now the flags.

	anl$format_flags(.indent_level+1,anl$_idxkeyflags,.sp[key$b_flags],
		(if .anl$gw_prolog eqlu plg$c_ver_3 then
			if .sp[key$b_keyref] eqlu 0 then key3_primary_def
						    else key3_secondary_def
		else
			if .sp[key$b_keyref] eqlu 0 then key2_primary_def
						    else key2_secondary_def
		));

	! Now the number of key segments.

	anl$format_line(0,.indent_level+1,anl$_idxkeysegs,.sp[key$b_segments]);

	! Now the null character, if enabled.

	if .sp[key$v_nulkeys] then
		anl$format_line(0,.indent_level+1,anl$_idxkeynull,.sp[key$b_nullchar]);

	! Now the total key size.

	anl$format_line(0,.indent_level+1,anl$_idxkeykeysz,.sp[key$b_keysz]);

	! Now the minimum record length.

	anl$format_line(0,.indent_level+1,anl$_idxkeyminrec,.sp[key$w_minrecsz]);

	! Now the fill quantities.

	anl$format_line(0,.indent_level+1,anl$_idxkeyfill,.sp[key$w_idxfill],.sp[key$w_datfill]);

	! Now the segment positions and sizes.

	anl$format_line(0,.indent_level+1,anl$_idxkeyposs,.sp[key$b_segments],
		.sp[key$w_position0],	.sp[key$w_position1],
		.sp[key$w_position2],	.sp[key$w_position3],
		.sp[key$w_position4],	.sp[key$w_position5],
		.sp[key$w_position6],	.sp[key$w_position7]);
	anl$format_line(0,.indent_level+1,anl$_idxkeysizes,.sp[key$b_segments],
		.sp[key$b_size0],	.sp[key$b_size1],
		.sp[key$b_size2],	.sp[key$b_size3],
		.sp[key$b_size4],	.sp[key$b_size5],
		.sp[key$b_size6],	.sp[key$b_size7]);

	! Now we need to format the data type of the key segment(s).

	anl$format_line(0,.indent_level+1,anl$_idxkey1type,data_type_name(.sp[key$b_datatype]));

	! Now the key name.

	anl$format_line(0,.indent_level+1,anl$_idxkeyname,key$s_keynam,sp[key$t_keynam]);

	! And finally, the first data bucket VBN, if present.

	if not .sp[key$v_initidx] then
		anl$format_line(0,.indent_level+1,anl$_idxkeydatavbn,.sp[key$l_ldvbn]);
);

! Now we are going to check the contents of the key descriptor.  This is
! a fairly rigorous test, but doesn't check anything that requires looking
! at other structures (except as passed in the areas vector).

! Start by ensuring that the three area IDs represent defined areas.
! This check can only be made if the areas vector was passed.

if not nullparameter(3) then
	if .areas_vector[.sp[key$b_ianum]] eqlu 0 or
	   .areas_vector[.sp[key$b_lanum]] eqlu 0 or
	   .areas_vector[.sp[key$b_danum]] eqlu 0 	then
		anl$format_error(anl$_badkeyareaid,.b[bsd$l_vbn],.key_id);

! Make sure the root level is at least 1.  This check cannot be made
! if the index is uninitialized.

if not .sp[key$v_initidx] and .sp[key$b_rootlev] eqlu 0 then
	anl$format_error(anl$_badkeyrootlevel,.b[bsd$l_vbn],.key_id);

! The following two checks can only be made if the areas vector was passed.

if not nullparameter(3) then (

	! The index bucket size must be correct, and the two index area IDs
	! must have the same bucket size.

	if .sp[key$b_idxbktsz] nequ .areas_vector[.sp[key$b_ianum]] or
	   .sp[key$b_idxbktsz] nequ .areas_vector[.sp[key$b_lanum]]	then
		anl$format_error(anl$_badkeyidxbkt,.b[bsd$l_vbn],.key_id);

	! The data bucket size must be correct.

	if .sp[key$b_datbktsz] nequ .areas_vector[.sp[key$b_danum]] then
		anl$format_error(anl$_badkeydatabkt,.b[bsd$l_vbn],.key_id);
);

! Check the key flags.

anl$check_flags(.b[bsd$l_vbn],.sp[key$b_flags],
		(if .anl$gw_prolog eqlu plg$c_ver_3 then
			if .sp[key$b_keyref] eqlu 0 then key3_primary_def
						    else key3_secondary_def
		else
			if .sp[key$b_keyref] eqlu 0 then key2_primary_def
						    else key2_secondary_def
		));

! Check the data type of the key.

if .sp[key$b_datatype] gtru key$c_max_data then
	anl$format_error(anl$_badkeydatatype,.b[bsd$l_vbn],.sp[key$b_datatype],.key_id);

! Check the number of key segments.

if .sp[key$b_segments] eqlu 0 or
   .sp[key$b_segments] gtru (if .sp[key$b_datatype] eqlu key$c_string then 8 else 1) then
	anl$format_error(anl$_badkeysegcount,.b[bsd$l_vbn],.sp[key$b_segments],.key_id);

! Now we are going to check the key segment information.  We sit in a loop
! and calculate the total key length and the length of a record required
! to hold the key.

begin
bind
	position_vector = sp[key$w_position0]: vector[8,word],
	size_vector = sp[key$b_size0]: vector[8,byte];
	
total_size = required_record = 0;
incru i from 0 to 7 do (

	if .i lssu .sp[key$b_segments] then (
		total_size = .total_size + .size_vector[.i];
		required_record = maxu(.required_record,.position_vector[.i]+.size_vector[.i]);

	) else
		if .position_vector[.i] nequ 0 or .size_vector[.i] nequ 0 then
			anl$format_error(anl$_badkeysegvec,.b[bsd$l_vbn],.key_id);
);
end;

! Now make sure that the calculated information agrees with the information
! in the descriptor.

if .sp[key$b_keysz] nequ .total_size or
   .sp[key$w_minrecsz] nequ .required_record then
	anl$format_error(anl$_badkeysummary,.b[bsd$l_vbn],.key_id);

! Check the key of reference ID.

if .sp[key$b_keyref] nequ .key_id then
	anl$format_error(anl$_badkeyrefid,.b[bsd$l_vbn],.key_id);

! Check the index and data fill quantities.

if .sp[key$w_idxfill] gtru .sp[key$b_idxbktsz]*512 or
   .sp[key$w_datfill] gtru .sp[key$b_datbktsz]*512	then
	anl$format_error(anl$_badkeyfill,.b[bsd$l_vbn],.key_id);

! Now we are going to move along to the next key descriptor, if there is
! one.  If not, let's just quit.

if .sp[key$l_idxfl] eqlu 0 then
	return false;

!  Update the BSD and get the next key descriptor.

b[bsd$l_vbn] = .sp[key$l_idxfl];
b[bsd$l_offset] = .sp[key$w_noff];
anl$bucket(b,0);

return true;

end;

%sbttl 'ANL$2BUCKET_HEADER - Print and Check a Bucket Header'
!++
! Functional Description:
!	This routine is responsible for printing and checking the contents
!	of the bucket header in prolog 2 indexed file buckets.
!
! Formal Parameters:
!	the_bsd		The address of a BSD describing the complete bucket.
!			We update it to the next bucket.
!	area_id		The alleged ID of the area containing this bucket.
!	level		The alleged level of this bucket.
!	report		A boolean, true if we are to print a report.
!	indent_level	The indentation level of the report.
!
! Implicit Inputs:
!	global data
!
! Implicit Outputs:
!	global data
!
! Returned Value:
!	True if there is another bucket in this chain, false otherwise.
!
! Side Effects:
!
!--


global routine anl$2bucket_header(the_bsd,area_id,level,report,indent_level) = begin

bind
	b = .the_bsd: bsd;

own
	control_flags_def: block[3,long] initial(
				1,
				uplit byte (%ascic 'BKT$V_LASTBKT'),
				uplit byte (%ascic 'BKT$V_ROOTBKT')
				);

local
	sp: ref block[,byte];


! We know the bucket header fits in the bucket.

! Now we can format the header if requested.

sp = .b[bsd$l_bufptr] + .b[bsd$l_offset];
if .report then (

	! Start with a nice header, containing the VBN.

	anl$format_line(3,.indent_level,anl$_bkt,.b[bsd$l_vbn]);
	anl$format_skip(0);

	! Format the check character.

	anl$format_line(0,.indent_level+1,anl$_bktcheck,.sp[bkt$b_checkchar]);

	! Format the area number.

	anl$format_line(0,.indent_level+1,anl$_bktarea,.sp[bkt$b_areano]);

	! Now the VBN address sample.

	anl$format_line(0,.indent_level+1,anl$_bktsample,.sp[bkt$w_adrsample]);

	! Now the free space offset.

	anl$format_line(0,.indent_level+1,anl$_bktfree,.sp[bkt$w_freespace]);

	! Now the available record ID range.

	anl$format_line(0,.indent_level+1,anl$_bktrecid,.sp[bkt$b_nxtrecid],.sp[bkt$b_lstrecid]);

	! Now the next bucket VBN.

	anl$format_line(0,.indent_level+1,anl$_bktnext,.sp[bkt$l_nxtbkt]);

	! Now the level number.

	anl$format_line(0,.indent_level+1,anl$_bktlevel,.sp[bkt$b_level]);

	! And finally, the flags.

	anl$format_flags(.indent_level+1,anl$_bktflags,.sp[bkt$b_bktcb],control_flags_def);
);

! Now we are going the check the contents of the bucket header.  This is a
! fairly rigorous test, but doesn't check anything that requires looking
! at other structures.

! Make sure the check byte is present in the last byte of the bucket.

if .sp[bkt$b_checkchar] nequ ch$rchar(.b[bsd$l_endptr]-1) then
	anl$format_error(anl$_badbktcheck,.b[bsd$l_vbn]);

! Check the area ID.

if .sp[bkt$b_areano] nequ .area_id then
	anl$format_error(anl$_badbktareaid,.b[bsd$l_vbn]);

! Check the bucket address sample.

if .sp[bkt$w_adrsample] nequ (.b[bsd$l_vbn] and %x'0000ffff') then
	anl$format_error(anl$_badbktsample,.b[bsd$l_vbn]);

! Check that the next available byte is within reasonable limits.

if .sp[bkt$w_freespace] lssu bkt$c_overhdsz or
   .sp[bkt$w_freespace] gtru .b[bsd$w_size]*512-1 then
	anl$format_error(anl$_badbktfree,.b[bsd$l_vbn]);

! Check the level number.

if .sp[bkt$b_level] nequ .level then
	anl$format_error(anl$_badbktlevel,.b[bsd$l_vbn]);

! Check the byte of control flags.

anl$check_flags(.b[bsd$l_vbn],.sp[bkt$b_bktcb],control_flags_def);

statistics_callback(

	! If we are accumulating statistics, then we have to call the
	! bucket callback routine, telling it the level, bucket size,
	! and fill amount.

	anl$bucket_callback(.sp[bkt$b_level],
			    .b[bsd$w_size],
			    .sp[bkt$w_freespace] + 1);
);

! If this is not the last bucket in this chain, then let's update the
! BSD to describe the next one.  Otherwise forget it.

if not .sp[bkt$v_lastbkt] then (
	b[bsd$l_vbn] = .sp[bkt$l_nxtbkt];
	anl$bucket(b,0);
	return true;
) else
	return false;

end;

%sbttl 'ANL$2INDEX_RECORD - Print & Check an Index Record'
!++
! Functional Description:
!	This routine is responsible for printing and checking the contents
!	of a prolog 2 index record.  An index record is the structure present
!	in the indices of an indexed file.
!
! Formal Parameters:
!	rec_bsd		Address of BSD describing the index record.
!	key_bsd		Address of BSD describing key descriptor for index.
!	report		A boolean, true if we are to print the record.
!	indent_level	Indentation level for the report.
!
! Implicit Inputs:
!	global data
!
! Implicit Outputs:
!	global data
!
! Returned Value:
!	True if there is another index record in this bucket, false otherwise.
!
! Side Effects:
!
!--


global routine anl$2index_record(rec_bsd,key_bsd,report,indent_level) = begin

bind
	b = .rec_bsd: bsd,
	k = .key_bsd: bsd,
	kp = .k[bsd$l_bufptr] + .k[bsd$l_offset]: block[,byte];

local
	hp: ref block[,byte],
	sp: ref block[,byte],
	length: long;


! First we have to ensure that this index record really fits in the used
! space of the bucket.  If not, we have a drastic structure error.
! Begin by ensuring that the first byte fits.

hp = .b[bsd$l_bufptr];

if .b[bsd$l_offset] gequ .hp[bkt$w_freespace] then (
	anl$format_error(anl$_badidxrecfit,.b[bsd$l_vbn]);
	signal (anl$_unwind);
);

! Now calculate the total length of the index record.

sp = .b[bsd$l_bufptr] + .b[bsd$l_offset];
length = 1 +
	 (case .sp[irc$v_ptrsz] from 0 to 3 of set
	  [0]:	2;
	  [1]:	3;
	  [2]:	4;
	  [3]:	(anl$format_error(anl$_badidxrecps,.b[bsd$l_vbn]);
		signal (anl$_unwind););
	 tes) +
	 .kp[key$b_keysz];

! Now make sure the entire index record can fit into the used space.

if .b[bsd$l_offset]+.length gtru .hp[bkt$w_freespace] then (
	anl$format_error(anl$_badidxrecfit,.b[bsd$l_vbn]);
	signal (anl$_unwind);
);

! Now we can format the index record if requested by the caller.

if .report then (

	! Begin with a header.

	anl$format_line(3,.indent_level,anl$_idxrec,.b[bsd$l_vbn],.b[bsd$l_offset]);
	anl$format_skip(0);

	! Now the bucket pointer and its length.

	anl$format_line(0,.indent_level+1,anl$_idxrecptr,.sp[irc$v_ptrsz]+2,
				(case .sp[irc$v_ptrsz] from 0 to 2 of set
				[0]:	.sp[1,0,16,0];
				[1]:	.sp[1,0,24,0];
				[2]:	.sp[1,0,32,0];
				tes));

	! Now the key value.  Dump it in hex with a heading.

	anl$format_line(0,.indent_level+1,anl$_idxkeybytes);
	begin
	local
		key_dsc: descriptor;

	build_descriptor(key_dsc,.kp[key$b_keysz],.sp + 1 + .sp[irc$v_ptrsz]+2);
	anl$format_hex(.indent_level+2,key_dsc);
	end;
);

! Now we can actually check the integrity of the index record.  Most of the
! work involves checking its fit in the bucket, which has already been done.
! We have a few things left, however.

! Check the index record control bits.  There aren't any.

if .sp[irc$v_recordcb] nequ 0 then
	anl$format_error(anl$_badidxrecbits,.b[bsd$l_vbn]);

statistics_callback(

	! If we are accumulating statistics, then we have to call the
	! index record callback routine, telling it the level, overall
	! record length, and compressed key length.

	anl$index_callback(.hp[bkt$b_level],
			   .length,
			   0);
);

! Now we can advance to the next index record.  If there isn't another
! one, then just return without modifying the BSD. Otherwise update
! the BSD.

if .b[bsd$l_offset]+.length lssu .hp[bkt$w_freespace] then (
	b[bsd$l_offset] = .b[bsd$l_offset] + .length;
	return true;
) else
	return false;

end;

%sbttl 'ANL$2PRIMARY_DATA_RECORD - Print & Check A Primary Data Record'
!++
! Functional Description:
!	This routine is responsible for printing and checking the contents
!	of a prolog 2 primary data record.  Primary data records exist in
!	the data buckets of the primary index.  They can contain actual data
!	records	or RRVs.
!
! Formal Parameters:
!	rec_bsd		Address of BSD describing the data record.
!	key_bsd		Address of BSD describing key for this index.
!	report		A boolean, true if we are to print the record.
!	indent_level	Indentation level for the report.
!
! Implicit Inputs:
!	global data
!
! Implicit Outputs:
!	global data
!
! Returned Value:
!	True if there is another data record in this bucket, false otherwise.
!
! Side Effects:
!
!--


global routine anl$2primary_data_record(rec_bsd,key_bsd,report,indent_level) = begin

bind
	b = .rec_bsd: bsd;

own
	data_flags_def: vector[6,long] initial(
				4,
				0,
				0,
				uplit byte (%ascic 'IRC$V_DELETED'),
				uplit byte (%ascic 'IRC$V_RRV'),
				uplit byte (%ascic 'IRC$V_NOPTRSZ')
				);
local
	hp: ref block[,byte],
	sp: ref block[,byte],
	rp: ref block[,byte],
	data_length: long, length: long;


! First we have to ensure that this data record fits in the used space
! of the bucket.  If not, we have a drastic structure error.  Begin by
! ensuring that the first byte fits.

hp = .b[bsd$l_bufptr];

if .b[bsd$l_offset] gequ .hp[bkt$w_freespace] then (
	anl$format_error(anl$_baddatarecfit,.b[bsd$l_vbn]);
	signal (anl$_unwind);
);

! Now calculate the length of the record not including the actual data.
! Set up a pointer RP to the data record.

sp = .b[bsd$l_bufptr] + .b[bsd$l_offset];
length = 1 +
	 1 +
	 (if .sp[irc$v_noptrsz] then 0 else
		(case .sp[irc$v_ptrsz] from 0 to 3 of set
		 [0]:	3;
		 [1]:	4;
		 [2]:	5;
		 [3]:	(anl$format_error(anl$_baddatarecps,.b[bsd$l_vbn]);
			signal (anl$_unwind););
		tes)
	 );
rp = .sp + .length;
if not .sp[irc$v_rrv] and .anl$gl_fat[fat$v_rtype] nequ fat$c_fixed then
	length = .length + 2;

! Now make sure that all those bytes fit into the used portion of the bucket.

if .b[bsd$l_offset]+.length gtru .hp[bkt$w_freespace] then (
	anl$format_error(anl$_baddatarecfit,.b[bsd$l_vbn]);
	signal (anl$_unwind);
);

! Now determine and save the length of the data record.  Add it to the
! overall length.

if not .sp[irc$v_rrv] then (
	data_length =	(selectoneu .anl$gl_fat[fat$v_rtype] of set
			[fat$c_fixed]:		.anl$gl_fat[fat$w_maxrec];

			[fat$c_variable,
			fat$c_vfc]:		.rp[0,0,16,0];
			tes);
	length = .length + .data_length;
);

! Finally, make sure the entire thing fits.

if .b[bsd$l_offset]+.length gtru .hp[bkt$w_freespace] then (
	anl$format_error(anl$_baddatarecfit,.b[bsd$l_vbn]);
	signal (anl$_unwind);
);

! Now we can actually format the structure, if requested.

if .report then (

	! We begin with a nice heading.

	anl$format_line(3,.indent_level,anl$_idxprimrec,.b[bsd$l_vbn],.b[bsd$l_offset]);
	anl$format_skip(0);

	! Now the control flags.

	anl$format_flags(.indent_level+1,anl$_idxprimrecflags,.sp[irc$b_control],data_flags_def);

	! Now the record ID.

	anl$format_line(0,.indent_level+1,anl$_idxprimrecid,.sp[irc$b_id]);

	! Now the RRV, both record ID and bucket pointer, if present.

	if not .sp[irc$v_noptrsz] then
		anl$format_line(0,.indent_level+1,anl$_idxprimrecrrv,
				.sp[irc$b_rrv_id],.sp[irc$v_ptrsz]+2,
				(case .sp[irc$v_ptrsz] from 0 to 2 of set
				[0]:	.sp[3,0,16,0];
				[1]:	.sp[3,0,24,0];
				[2]:	.sp[3,0,32,0];
				tes));

	! Call a routine to format the primary key, if present.

	if not .sp[irc$v_rrv] then (
		anl$format_line(0,.indent_level+1,anl$_idxkeybytes);
		anl$2format_primary_key(
			(if .anl$gl_fat[fat$v_rtype] nequ fat$c_fixed then .rp+2 else .rp),
			.key_bsd,.indent_level+2);
	);
);

! Now we can actually check the integrity of this data record.  Most of
! the checking has been done, since it involved the fit of the record
! in the bucket.  However, we have a few things to do.

! Check the control bits, ignoring the pointer size.

anl$check_flags(.b[bsd$l_vbn],.sp[irc$b_control] and %x'fc',data_flags_def);

! Now we can check the record length for VFC records to make sure they are
! long enough to contain the header.

if not .sp[irc$v_rrv] then
	if .anl$gl_fat[fat$v_rtype] eqlu fat$c_vfc and
	   .data_length lssu .anl$gl_fat[fat$b_vfcsize] then
		anl$format_error(anl$_vfctooshort,.b[bsd$l_vbn]);

if not .sp[irc$v_rrv] and not .sp[irc$v_deleted] then statistics_callback(

	! If we are accumulating statistics, we need to call the data
	! record callback routine, telling it the overall record length.

	anl$data_callback(.data_length,
			  0,
			  0,
			  0);
);

! Now we want to advance on to the next data record.  If there is room in
! the bucket for another, then update the BSD.  Otherwise don't touch it.

if .b[bsd$l_offset]+.length lssu .hp[bkt$w_freespace] then (
	b[bsd$l_offset] = .b[bsd$l_offset] + .length;
	return true;
) else
	return false;

end;

%sbttl 'ANL$2FORMAT_PRIMARY_KEY - Format Primary Key from Data'
!++
! Functional Description:
!	This routine is called to dump the primary key from a data
!	record in a prolog 2 indexed file.  This is more difficult than
!	prolog 3, because the primary key is not already extracted.
!
! Formal Parameters:
!	rec_ptr		Pointer to data record.
!	key_bsd		Address of BSD describing key for this index.
!	indent_level	Indentation level for the report.
!
! Implicit Inputs:
!	global data
!
! Implicit Outputs:
!	global data
!
! Returned Value:
!	none
!
! Side Effects:
!
!--


global routine anl$2format_primary_key(rec_ptr,key_bsd,indent_level): novalue = begin

bind
	k = .key_bsd: bsd;

local
	kp: ref block[,byte],
	segment: long,
	buffer_i: long,
	local_described_buffer(buffer,256);


! Begin by setting up a pointer to the key descriptor.  Then define
! a couple of arrays, one for the sizes and one for the positions.

kp = .k[bsd$l_bufptr] + .k[bsd$l_offset];

begin
bind
	size_vector = kp[key$b_size0]: vector[,byte],
	pos_vector = kp[key$w_position0]: vector[,word];

! It's really pretty simple.  We loop through each of the key segments
! and extract the data from the record.  The data is concatenated into
! the key buffer.

buffer[len] = 0;

incru segment from 0 to .kp[key$b_segments]-1 do (

	ch$move(.size_vector[.segment],.rec_ptr+.pos_vector[.segment],
				       .buffer[ptr]+.buffer[len]);
	buffer[len] = .buffer[len] + .size_vector[.segment];
);
end;

! Now we can dump the key in hex.	

anl$format_hex(.indent_level,buffer);

return;

end;

%sbttl 'ANL$2SIDR_RECORD - Print & Check A Secondary Data Record'
!++
! Functional Description:
!	This routine is responsible for printing and checking the contents
!	of a prolog 2 secondary data record.  Secondary data records exist
!	in the data buckets of secondary indices.  They contain SIDR records.
!
! Formal Parameters:
!	rec_bsd		Address of BSD describing the data record.
!			BSD is updated to point at next record.
!	key_bsd		Address of BSD describing the key for this index.
!	report		A boolean, true if we are to print the record.
!	indent_level	Indentation level for the report.
!
! Implicit Inputs:
!	global data
!
! Implicit Outputs:
!	global data
!
! Returned Value:
!	True if there is another SIDR in this bucket, false otherwise.
!
! Side Effects:
!
!--


global routine anl$2sidr_record(rec_bsd,key_bsd,report,indent_level) = begin

bind
	b = .rec_bsd: bsd,
	k = .key_bsd: bsd;

own
	sidr_flags_def: vector[6,long] initial(
				4,
				0,
				0,
				0,
				0,
				uplit byte (%ascic 'IRC$V_NOPTRSZ')
				);
				
local
	hp: ref block[,byte],
	sp: ref block[,byte],
	kp: ref block[,byte],
	length: long,
	p: bsd,
	sidr_pointers;


! First we have to ensure that the fixed portion of this SIDR record fits
! in the used space of the bucket.  If not, we have a drastic structure error.
! Begin by ensuring that the first byte fits.

hp = .b[bsd$l_bufptr];

if .b[bsd$l_offset] gequ .hp[bkt$w_freespace] then (
	anl$format_error(anl$_baddatarecfit,.b[bsd$l_vbn]);
	signal (anl$_unwind);
);

! Now we calculate the length of the entire SIDR record.

sp = .b[bsd$l_bufptr] + .b[bsd$l_offset];
length = 1 +
	 1 +
	 (if .sp[irc$v_noptrsz] then 0 else 4) +
	 2 +
	 (if .sp[irc$v_noptrsz] then .sp[2,0,16,0] else .sp[6,0,16,0]);

! Make sure the record fits in the used portion of the bucket.

if .b[bsd$l_offset]+.length gtru .hp[bkt$w_freespace] then (
	anl$format_error(anl$_baddatarecfit,.b[bsd$l_vbn]);
	signal (anl$_unwind);
);

! Now we can format the SIDR record fixed portion, if requested.

kp = .k[bsd$l_bufptr] + .k[bsd$l_offset];
if .report then (

	! Start with a nice header.

	anl$format_line(3,0,anl$_idxsidr,.b[bsd$l_vbn],.b[bsd$l_offset]);
	anl$format_skip(0);

	! Now format the flags.

	anl$format_flags(1,anl$_idxsidrflags,.sp[irc$b_control],sidr_flags_def);

	! Now format the record ID.

	anl$format_line(0,1,anl$_idxsidrrecid,.sp[irc$b_id]);

	! Now the key.  We dump it in hex.

	anl$format_line(0,1,anl$_idxkeybytes);
	begin
	local
		key_dsc: descriptor;

	build_descriptor(key_dsc,.kp[key$b_keysz],
			.sp +
			1 +
			1 +
			(if .sp[irc$v_noptrsz] then 0 else 4) +
			2);
	anl$format_hex(2,key_dsc);
	end;
);

! Now we can actually check the integrity of the SIDR record.  We begin
! by ensuring that the pointer size is 1, and that the main control
! flags are OK.  Don't confuse the two.

if not .sp[irc$v_noptrsz] and .sp[irc$v_ptrsz] nequ 1 then
	anl$format_error(anl$_badsidrptrsz,.b[bsd$l_vbn]);
anl$check_flags(.b[bsd$l_vbn],.sp[irc$b_control] and %x'fc',sidr_flags_def);

! At this point, if we are formatting a report, we're done.  If we aren't
! (e.g., we are checking the file), then we want to check all of the
! SIDR pointers.

sidr_pointers = 0;
if not .report then (

	! Set up a BSD to describe the first SIDR pointer.  This includes
	! setting the work longword to the number of bytes worth of pointers
	! existing in the record.

	init_bsd(p);
	copy_bucket(b,p);
	p[bsd$l_offset] =	.b[bsd$l_offset] +
				1 +
				1 +
				(if .sp[irc$v_noptrsz] then 0 else 4) +
				2 +
				.kp[key$b_keysz];
	p[bsd$l_work] =	(if .sp[irc$v_noptrsz] then .sp[2,0,16,0] else .sp[6,0,16,0]) -
			.kp[key$b_keysz];

	! Now we can loop through each pointer, checking its integrity.
	! We'll count them as we go.

	do increment(sidr_pointers) while anl$2sidr_pointer(p,false);

	anl$bucket(p,-1);
);

statistics_callback(

	! If we are accumulating statistics, we want to call the data
	! record callback routine and tell it the overall record length,
	! compressed key length, and compressed data length.  The latter
	! two make no sense for prolog 2.  We also need to tell it the
	! number of SIDR pointers in this record.

	anl$data_callback(.length,
			  0,
			  0,
			  .sidr_pointers);
);

! Now we want to advance on to the next SIDR in this bucket.  If there isn't
! room for one, then we're done.  Otherwise update the BSD.

if .b[bsd$l_offset]+.length lssu .hp[bkt$w_freespace] then (
	b[bsd$l_offset] = .b[bsd$l_offset] + .length;
	return true;
) else
	return false;

end;

%sbttl 'ANL$2SIDR_POINTER - Format & Analyze SIDR Pointer'
!++
! Functional Description:
!	This routine is responsible for formatting and analyzing one of the
!	pointers in a SIDR record for prolog 2 files.
!
! Formal Parameters:
!	pointer_bsd	Address of BSD describing the pointer.  The work
!			longword in the BSD is assumed to contain a count
!			of remaining bytes in the SIDR record.
!	report		Boolean, true if we are to format the pointer.
!	indent_level	Indentation level for the report.
!
! Implicit Inputs:
!	global data
!
! Implicit Outputs:
!	global data
!
! Returned Value:
!	True if there is another SIDR pointer, false otherwise.
!
! Side Effects:
!
!--


global routine anl$2sidr_pointer(pointer_bsd,report,indent_level) = begin

bind
	p = .pointer_bsd: bsd;

own
	pointer_flags_def: vector[7,long] initial(
				5,
				0,
				0,
				uplit byte (%ascic 'IRC$V_DELETED'),
				0,
				0,
				uplit byte (%ascic 'IRC$V_KEYDELETE')
				);

local
	pp: ref block[,byte],
	length: long;


! We know the SIDR record fits in the used space of the bucket, because
! that was checked in ANL$2SIDR_RECORD.

! So we can calculate the overall length of the pointer.

pp = .p[bsd$l_bufptr] + .p[bsd$l_offset];
length =	1 +
		(case .pp[irc$v_ptrsz] from 0 to 3 of set
	 	[0]:	3;
		[1]:	4;
		[2]:	5;
		[3]:	(anl$format_error(anl$_baddatarecps,.p[bsd$l_vbn]);
			signal (anl$_unwind););
		tes);

! Make sure the entire pointer fits in the SIDR record.  If not, that's a
! drastic structure error.

if .length gtru .p[bsd$l_work] then (
	anl$format_error(anl$_badsidrptrfit,.p[bsd$l_vbn]);
	signal (anl$_unwind);
);

! Now we can format the SIDR pointer if requested.

if .report then (

	! Format the flags.

	anl$format_flags(2,anl$_idxsidrptrflags,.pp[irc$b_control],pointer_flags_def);

	! And the record ID and bucket VBN.

	anl$format_line(0,2,anl$_idxsidrptrref,.pp[1,0,8,0],.pp[irc$v_ptrsz]+2,
			(case .pp[irc$v_ptrsz] from 0 to 2 of set
			[0]:	.pp[2,0,16,0];
			[1]:	.pp[2,0,24,0];
			[2]:	.pp[2,0,32,0];
			tes));
);

! Now we have to check the record pointer.  The only thing to check is
! the control flags.  Don't get confused by the pointer size.

anl$check_flags(.p[bsd$l_vbn],.pp[irc$b_control] and %x'fc',pointer_flags_def);

! Now we want to advance on to the next pointer.  Reduce the count of
! remaining bytes.  If it goes to zero, there are no more pointers.
! If it doesn't, then update the BSD.

p[bsd$l_work] = .p[bsd$l_work] - .length;
if .p[bsd$l_work] gtru 0 then (
	p[bsd$l_offset] = .p[bsd$l_offset] + .length;
	return true;
) else
	return false;

end;

end eludom
