%title 'RMSINTER - Interactive Analysis Mode'
	module rmsinter	(
			ident='V03-001') = begin

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! Facility:	VAX/VMS Analyze Facility, Interactive Analysis Mode
!
! Abstract:	This module handles the interactive mode of analysis
!		requested via the /INTERACTIVE qualifier.  This mode
!		allows the user to interactively peruse the structure
!		of any RMS file.
!
!
! Environment:
!
! Author: Paul C. Anagnostopoulos, Creation Date:  20 May 1981
!
! Modified By:
!
!	V03-001	PCA0010		Paul Anagnostopoulos	16-Mar-1982
!		Fix the code that goes down into the buckets of a
!		relative file.  There may not be any.
!--

%sbttl 'Module Declarations'
!
! Libraries and Requires:
!

library 'lib';
library 'tpamac';
require 'rmsreq';

!
! Table of Contents:
!

forward routine
	anl$interactive_mode: novalue,
	anl$interactive_driver: novalue,
	anl$interactive_command: novalue,
	anl$interactive_display: novalue,
	anl$interactive_down,
	anl$interactive_dump: novalue,
	anl$interactive_help: novalue;

!
! External References:
!

external routine
	anl$area_descriptor,
	anl$bucket,
	anl$2bucket_header,
	anl$3bucket_header,
	anl$condition_handler,
	anl$3format_data_bytes,
	anl$format_file_attributes,
	anl$format_file_header,
	anl$format_hex,
	anl$format_line,
	anl$format_skip,
	anl$idx_prolog,
	anl$2index_record,
	anl$3index_record,
	anl$internalize_number,
	anl$key_descriptor,
	anl$open_next_rms_file,
	anl$prepare_report_file,
	anl$2primary_data_record,
	anl$3primary_data_record,
	anl$3reclaimed_bucket_header,
	anl$rel_cell,
	anl$rel_prolog,
	anl$seq_data_record,
	anl$2sidr_pointer,
	anl$2sidr_record,
	anl$3sidr_record,
	cli$get_value: addressing_mode(general),
	lbr$output_help: addressing_mode(general),
	lib$establish: addressing_mode(general),
	lib$get_input: addressing_mode(general),
	lib$put_output: addressing_mode(general),
	lib$tparse: addressing_mode(general),
	str$upcase: addressing_mode(general);

external literal
	lib$_syntaxerr;

external
	anl$gl_fat: ref block[,byte],
	anl$gw_prolog: word;

!
! Macro Definitions:
!
! The following macro is simply a shorthand:

macro text[] = uplit byte (%ascic %remaining) %;

!
! Own Variables:
!
! The following two tables control the interactive perusal of a file by
! describing the hierarchical structure of the three RMS file types.
!
! The first table describes each of the structures in an RMS file.
! For our purposes, a structure is basically defined as any context in
! which we are able to discretely display an identifiable piece of a file.
! Examples are the RMS file attribute area or a indexed file key descriptor.
! THE INDICES OF ENTRIES IN THIS TABLE ARE USED IN THE BSD AS THE 
! STRUCTURE TYPE INDICATOR.

! There is a vector of four items for each table entry, as follows:
!	0)	The number of a routine that can effect the display
!		of this structure (routines reside in ANL$INTERACTIVE_DISPLAY).
!	1-3)	A list of 0-3 indices into the PATH_TABLE.  This list
!		defines the ways in which you can go down from this structure.

structure matrix[i,j; n] =
		[n*4]
		(matrix+(i*4+j))<0,8,0>;

own
	structure_table: matrix[35] initial(byte (
		0,0,0,0,			!  0 - unused
		 1,	1,0,0,			!  1 - File header
		 2,	2,0,0,			!  2 - RMS attributes
		 3,	0,0,0,			!  3 - Seq rec
		 4,	3,0,0,			!  4 _ Rel prolog
		 5,	4,0,0,			!  5 - Rel bkts
		 6,	0,0,0,			!  6 - Rel cells
		 7,	5,6,0,			!  7 - Idx prolog
		 8,	23,0,0,			!  8 - Idx area descriptor
		 9,	7,8,0,			!  9 - Idx key descriptor
		10,	9,0,0,			! 10 - 2Idx primary index bkt
		11,	9,0,0,			! 11 - 2Idx secondary index bkt
		12,	11,0,0,			! 12 - 2Idx primary data bkt
		13,	14,0,0,			! 13 - 2Idx SIDR bkt
		14,	10,0,0,			! 14 - 2Idx primary index rec
		15,	10,0,0,			! 15 - 2Idx secondary index rec
		16,	12,13,0,		! 16 - 2Idx primary data rec
		17,	0,0,0,			! 17 - 2Idx actual data bytes
		18,	15,0,0,			! 18 - 2Idx SIDR rec
		19,	0,0,0,			! 19 - 2Idx SIDR pointer
		20,	16,0,0,			! 20 - 3Idx primary index bkt
		21,	16,0,0,			! 21 - 3Idx secondary index bkt
		22,	18,0,0,			! 22 - 3Idx primary data bkt
		23,	0,0,0,			! 23 - 3Idx SIDR bkt
		24,	17,0,0,			! 24 - 3Idx primary index rec
		25,	17,0,0,			! 25 - 3Idx secondary index rec
		26,	19,20,0,		! 26 - 3Idx primary data rec
		27,	0,0,0,			! 27 - 3Idx actual data bytes
		0,	0,0,0,			! 28 - RESERVED FOR 3Idx SIDR rec
		0,	0,0,0,			! 29 - RESERVED FOR 3Idx SIDR pointer
		30,	0,0,0			! 30 - Idx reclaimed bkt
		));


! This second table contains an entry for each downward path in the file
! structure.  A downward path is a method for descending from a given
! structure in the file down deeper to a new structure in the file.
! An example is the pointer from an index entry to its associated data
! bucket.
!
! Each entry in the table contains four items, as follows:
!	0)	The symbolic name of the path.
!	1)	A short description of the path.
!	2)	The number of the routine that can effect the downward
!		movement (routines are in ANL$INTERACTIVE_DOWN).
!	3)	The number of the entry in the STRUCTURE_TABLE that
!		describes where you end up when you go down.
!		If zero, the value is computed in ANL$INTERACTIVE_DOWN.

field path_fields = set
	path_name	= [0,0,32,0],
	path_text	= [4,0,32,0],
	path_routine	= [8,0, 8,0],
	path_result	= [9,0, 8,0]
tes;

own
	path_table: blockvector[25,10,byte] field(path_fields) initial(
0, 0,							byte(0,0),	!unused
text('ATTRIBUTES'), text('RMS file attribute area'),	byte(1,2),	!  1
text('BLOCKS'), text('Depends on file organization'),	byte(2,0),	!  2
text('BUCKETS'), text('Data buckets'),			byte(3,5),	!  3
text('CELLS'), text('Record cells'),			byte(4,6),	!  4
text('AREAS'), text('Area descriptors'),		byte(5,8),	!  5
text('KEYS'), text('Key descriptors'),			byte(6,9),	!  6
text('INDEX'), text('Root index bucket'),		byte(7,0),	!  7
text('DATA'), text('Data buckets'),			byte(8,0),	!  8
text('RECORDS'), text('Index records'),			byte(9,0),	!  9
text('DEEPER'), text('Index or data buckets'),		byte(10,0),	! 10
text('RECORDS'), text('Primary data records'),		byte(11,16),	! 11
text('BYTES'), text('Actual data record bytes'),	byte(12,17),	! 12
text('RRV'), text('RRV data bucket'),			byte(13,12),	! 13
text('SIDR'), text('SIDR record'),			byte(14,18),	! 14
text('POINTER'), text('Record pointer'),		byte(15,19),	! 15
text('RECORDS'), text('Index records'),			byte(16,0),	! 16
text('DEEPER'), text('Index or data buckets'),		byte(17,0),	! 17
text('RECORDS'), text('Primary data records'),		byte(11,26),	! 18
text('BYTES'), text('Actual data record bytes'),	byte(18,27),	! 19
text('RRV'), text('RRV data bucket'),			byte(19,22),	! 20
0,0,							byte(0,0),	! 21 RESERVED FOR SIDR
0,0,							byte(0,0),	! 22 RESERVED FOR SIDR
text('RECLAIMED'), text('Reclaimed buckets'),		byte(22,30)	! 23
);

! The hierarchical perusal of the file will be controlled by three stacks
! of BSDs.  FIRST_STACK contains BSDs that describe the first structure
! that we encountered on a given level when we went down to it.
! CURRENT_STACK describes the current structure on a given level.
! NEXT_STACK describes the next structure that we will encounter on a
! given level.

literal
	stack_size = 32;
own
	top: signed long initial(0),
	first_stack: blockvector[stack_size,bsd$c_size,byte] field(bsd_fields),
	current_stack: blockvector[stack_size,bsd$c_size,byte] field(bsd_fields),
	next_stack: blockvector[stack_size,bsd$c_size,byte] field(bsd_fields),
	key_level: long;

%sbttl 'ANL$INTERACTIVE_MODE - Control Interactive Mode Analysis'
!++
! Functional Description:
!	This routine is the controlling routine for /INTERACTIVE mode
!	analysis.  We allow the user to analyze the file specified
!	on the command line.
!
! Formal Parameters:
!	none
!
! Implicit Inputs:
!	global data
!
! Implicit Outputs:
!	global data
!
! Returned Value:
!	none
!
! Side Effects:
!
!--


global routine anl$interactive_mode: novalue = begin

local
	status;


! Begin by opening the file to be analyzed.  If the user blew it, just quit.

begin
local
	local_described_buffer(resultant_file_spec,nam$c_maxrss);

if not anl$open_next_rms_file(resultant_file_spec) then
	return;

! Now we can prepare the report file to receive a transcript of the session.

anl$prepare_report_file(anl$_interhdg,resultant_file_spec);
end;

! Interactively analyze the file.

anl$interactive_driver();

return;

end;

%sbttl 'ANL$INTERACTIVE_DRIVER - Drive Interactive Analysis of a File'
!++
! Functional Description:
!	This routine drives the iteractive analysis of a single RMS file.
!	It accepts commands from the user and displays file information
!	accordingly.
!
! Formal Parameters:
!	none
!
! Implicit Inputs:
!	global data
!
! Implicit Outputs:
!	global data
!
! Returned Value:
!	none
!
! Side Effects:
!
!--


global routine anl$interactive_driver: novalue = begin


local
	status: long,
	command_number: long,
	display: byte;


! Initialization is not very difficult.  We have to set up the zeroth
! entry on the stack as if we just went "down" into the file header of
! the file.  This means we need a BSD describing the file header, and
! it must be present on the FIRST and CURRENT stacks.

init_bsd(first_stack[.top,0,0,0,0]);
first_stack[.top,bsd$w_type] = 1;
init_bsd(current_stack[.top,0,0,0,0]);
current_stack[.top,bsd$w_type] = 1;
init_bsd(next_stack[.top,0,0,0,0]);

! OK, now we can actually begin the analysis.  The main loop is traversed
! once for each user command.  We quit when we get an EXIT command or
! CTRL/Z.

display = true;
loop (
	local
		local_described_buffer(command_arguments,80);


	! Usually we have to display the current structure.  The display
	! routine will format the contents of the structure, and then
	! update the BSD to describe the next structure on the current
	! level.  This is why we pass it the BSD on the NEXT stack.
	! The display routine also needs the BSD for the parent of the
	! current structure.

	if .display then (
		anl$format_skip(0);
		copy_bucket(current_stack[.top,0,0,0,0],next_stack[.top,0,0,0,0]);
		anl$interactive_display(next_stack[.top,0,0,0,0],current_stack[.top-1,0,0,0,0]);
		anl$format_skip(0);
	) else
		display = true;

	! Now we can actually get a command from the user.  The command
	! routine returns the command number and a descriptor of any
	! command arguments.

	anl$interactive_command(command_number,command_arguments);

	! Now we can case on the command.

	case .command_number from 1 to 11 of set

	[1]:	! The AGAIN command is trivial.  In fact, we don't have to
		! do a thing.

		;


	[2]:	! This command number is reserved for the BUCKET command.

		;


	[3]:	! The DOWN command is very complicated.

		(if .top eqlu stack_size then (

			! No more room on the stack.  Sorry user.

			signal (anl$_stackfull);
			display = false;
		) else (

			! The following routine will build a new BSD on the
			! FIRST stack describing the lower structure.

			status = anl$interactive_down(command_arguments,
					current_stack[.top,0,0,0,0],first_stack[.top+1,0,0,0,0],.top+1);
			if .status then (

				! We could go down.  Initialize the CURRENT
				! and NEXT stacks, and set the CURRENT stack
				! to the first structure on the new level.

				increment (top);
				init_bsd(current_stack[.top,0,0,0,0]);
				copy_bucket(first_stack[.top,0,0,0,0],current_stack[.top,0,0,0,0]);
				init_bsd(next_stack[.top,0,0,0,0]);
			) else

				! Something prevented us from going down.

				display = false;
		););


	[4]:	! The DUMP command is easy here, because we just call
		! a routine to do it, passing the user's argument.

		(anl$interactive_dump(command_arguments);
		display = false;);


	[5]:	! The EXIT command is real easy.  Just return.

		return;


	[6]:	! The FIRST command is easy.  Just copy the FIRST stack
		! into the CURRENT stack.

		copy_bucket(first_stack[.top,0,0,0,0],current_stack[.top,0,0,0,0]);


	[7]:	! The HELP command is easy here, because we just call a 
		! routine to do it, passing the user's arguments.

		(anl$interactive_help(command_arguments);
		display = false;);


	[8]:	! The NEXT command is easy.  If there is no next structure,
		! tell the user.  If there is, simply copy the NEXT stack
		! into the CURRENT stack.

		if .next_stack[.top,bsd$l_vbn] eqlu .current_stack[.top,bsd$l_vbn] and
		   .next_stack[.top,bsd$l_offset] eqlu .current_stack[.top,bsd$l_offset] then (
			signal (anl$_nonext);
			display = false;
		) else
			copy_bucket(next_stack[.top,0,0,0,0],current_stack[.top,0,0,0,0]);


	[9]:	! The REST command is a little harder.  We sit in a loop,
		! displaying structures and moving on to the next one, 
		! until there is no next one.

		(until .next_stack[.top,bsd$l_vbn] eqlu .current_stack[.top,bsd$l_vbn] and
		       .next_stack[.top,bsd$l_offset] eqlu .current_stack[.top,bsd$l_offset] do (
			copy_bucket(next_stack[.top,0,0,0,0],current_stack[.top,0,0,0,0]);
			anl$format_skip(0);
			anl$interactive_display(next_stack[.top,0,0,0,0],current_stack[.top-1,0,0,0,0]);
		);
		signal (anl$_restdone);
		display = false;);


	[10]:	! The TOP command requires a loop to pop each stack entry
		! down to the original one.

		while .top gtru 0 do (
			anl$bucket(first_stack[.top,0,0,0,0],-1);
			anl$bucket(current_stack[.top,0,0,0,0],-1);
			anl$bucket(next_stack[.top,0,0,0,0],-1);
			decrement (top);
		);		


	[11]:	! The UP command is easy.  Just pop the stacks, unless we
		! already are at the top.

		if .top eqlu 0 then (
			signal (anl$_attop);
			display = false;
		) else (
			anl$bucket(first_stack[.top,0,0,0,0],-1);
			anl$bucket(current_stack[.top,0,0,0,0],-1);
			anl$bucket(next_stack[.top,0,0,0,0],-1);
			decrement (top);
		);

	tes;

);

return;

end;

%sbttl 'ANL$INTERACTIVE_COMMAND - Get a Command From the User'
!++
! Functional Description:
!	This routine is responsible for obtaining a command from the user,
!	parsing it, checking it, and returning information about it.
!
! Formal Parameters:
!	number		Address of a longword in which to return the command
!			identification number.
!	arguments	Address of a descriptor of a buffer in which to 
!			return any command arguments.
!
! Implicit Inputs:
!	global data
!
! Implicit Outputs:
!	global data
!
! Returned Value:
!	none
!
! Side Effects:
!
!--


global routine anl$interactive_command(number,arguments): novalue = begin

bind
	arguments_dsc = .arguments: descriptor;

own
	tparse_block: block[tpa$k_length0,byte] initial(
				tpa$k_count0,
				tpa$m_blanks + tpa$m_abbrev),
	command_number: long;

local
	status: long;

! The following data structure is the parsing table used to analyze a
! command from the user.  The command numbers cannot be changed.

$init_state(command_state,command_key);

$state	(,
		(tpa$_blank),
		(tpa$_lambda)
	);

$state	(,
		(tpa$_eos,	noargs,,	 8,command_number),
		('AGAIN',	noargs,,	 1,command_number),
! Command number 2 is reserved for BUCKET.
		('DOWN',	  args,,	 3,command_number),
		('DUMP',	  args,,	 4,command_number),
		('EXIT',	noargs,,	 5,command_number),
		('FIRST',	noargs,,	 6,command_number),
		('HELP',	  args,,	 7,command_number),
		('NEXT',	noargs,,	 8,command_number),
		('REST',	noargs,,	 9,command_number),
		('TOP',		noargs,,	10,command_number),
		('UP',		noargs,,	11,command_number)
	);

$state	(noargs,
		(tpa$_blank),
		(tpa$_lambda)
	);
$state	(,
		(tpa$_eos,tpa$_exit)
	);

$state	(args,
		(tpa$_blank,tpa$_exit),
		(tpa$_lambda,tpa$_exit)
	);

! Sit in a loop until we get a valid command.

begin
local
	local_described_buffer(command_buffer,80);

loop (

	! Get the command string.

	command_buffer[len] = 80;
	status = lib$get_input(command_buffer,describe('ANALYZE> '),command_buffer);

	! If we got an end-of-file, then just tell the caller we got an EXIT
	! command.

	if .status eqlu rms$_eof then (
		.number = 5;
		return;
	);
	check (.status, .status);

	! Set up for parsing the command.  Don't forget to uppercase it.

	tparse_block[tpa$l_stringcnt] = .command_buffer[len];
	tparse_block[tpa$l_stringptr] = .command_buffer[ptr];
	str$upcase(tparse_block[tpa$l_stringcnt],tparse_block[tpa$l_stringcnt]);
	command_number = 0;
	status = lib$tparse(tparse_block,command_state,command_key);

	! If we didn't get a syntax error, then we're all set.
	! Otherwise try again.

exitif (.status eqlu ss$_normal);
	signal (anl$_badcmd);
);

! We have a command, so let's echo it into the transcript file, if present.
! The -1 widow control prevents the line from appearing on screen.

anl$format_line(-1,0,anl$_intercommand,command_buffer);
end;

! OK, return the command number.  Also place any command arguments into
! the caller's buffer.

.number = .command_number;
arguments_dsc[len] = .tparse_block[tpa$l_stringcnt];
ch$move(.tparse_block[tpa$l_stringcnt],.tparse_block[tpa$l_stringptr], .arguments_dsc[ptr]);

return;

end;

%sbttl 'ANL$INTERACTIVE_DISPLAY - Display a File Structure'
!++
! Functional Description:
!	This routine is responsible for displaying the various structures
!	that exist in an RMS file.  It is also responsible for determining
!	the location of the structure following the one it displays.
!
! Formal Parameters:
!	structure_bsd	Address of BSD describing the structure to display.
!			It is updated to describe the following structure.
!	parent_bsd	Address of BSD describing the parent of the structure.
!
! Implicit Inputs:
!	global data
!
! Implicit Outputs:
!	global data
!
! Returned Value:
!	none
!
! Side Effects:
!
!--


global routine anl$interactive_display(structure_bsd,parent_bsd): novalue = begin

bind
	s = .structure_bsd: bsd,
	p = .parent_bsd: bsd;

local
	sp: ref block[,byte],
	i: long;


! Set up the condition handler for drastic structure errors.

lib$establish(anl$condition_handler);

! Set up a pointer to the structure to be displayed.

sp = .s[bsd$l_bufptr] + .s[bsd$l_offset];

! Because it requires a different routine to display each of the structures,
! this process is table-driven.  The structure type code in the BSD is
! an index into the STRUCTURE_TABLE, which contains a routine number for
! displaying the structure.  We simply case on that number.

case .structure_table[.s[bsd$w_type],0] from 1 to 30 of set

[1]:	! Routine number 1 is for displaying the file header.  No updating
	! of the BSD is necessary, since there is no "next" structure.

	anl$format_file_header();


[2]:	! Routine number 2 is for displaying the RMS file attributes.
	! No updating of the BSD is necessary.

	anl$format_file_attributes();


[3]:	! Routine number 3 is for displaying a record from a sequential
	! file.  The following routine will do so and update the BSD.

	anl$seq_data_record(s,true,1);


[4]:	! Routine number 4 is for displaying the prolog of a relative file.
	! The following routine will do it.

	anl$rel_prolog(s,true,0);


[5]:	! Routine number 5 is for displaying the buckets of a relative file.
	! This consists of nothing more than a heading.

	(local
		pp: ref block[,byte];

	anl$format_line(3,0,anl$_relbucket,.s[bsd$l_vbn]);

	! Now we move on to the next bucket if there is one.  We can tell
	! by looking at the end-of-file VBN in the prolog.

	pp = .p[bsd$l_bufptr] + .p[bsd$l_offset];
	if .s[bsd$l_vbn]+2*.s[bsd$w_size] lequ .pp[plg$l_eof] then (
		s[bsd$l_vbn] = .s[bsd$l_vbn] + .s[bsd$w_size];
		s[bsd$l_offset] = 0;
		anl$bucket(s,0);
	););


[6]:	! Routine number 6 is for displaying the cells of a relative file.
	! The following routine will do the work and update the BSD.

	anl$rel_cell(s,true,1);


[7]:	! Routine number 7 is for displaying the prolog of an indexed file.
	! The following routine will do it.

	anl$idx_prolog(s,true,0);


[8]:	! Routine number 8 is for displaying an area descriptor in an indexed
	! file.  The following routine will do it and update the BSD.

	anl$area_descriptor(s,.sp[area$b_areaid],true,0);


[9]:	! Routine number 9 is for displaying a key descriptor in an indexed
	! file.  The following routine will do it and update the BSD.

	anl$key_descriptor(s,.sp[key$b_keyref],0,true,0);


[10,
 11,
 12,
 13]:	! Routine numbers 10 thru 13 are for displaying the bucket
	! headers for primary index, secondary index, primary data, and
	! secondary data buckets, respectively.  The following routine
	! will do it and update the BSD.  This is for prolog 2.

	anl$2bucket_header(s,.sp[bkt$b_areano],.sp[bkt$b_level],true,0);


[14,
 15]:	! Routine numbers 14 and 15 are for displaying the index records in
	! primary and secondary indexes, respectively.  The following
	! routine will do it and update the BSD.  The routine needs the key
	! descriptor.  This is for prolog 2.

	anl$2index_record(s,current_stack[.key_level,0,0,0,0],true,1);


[16]:	! Routine number 16 is for displaying the primary data records in a
	! primary data bucket.  The following routine will do it and update
	! the BSD.  This is for prolog 2.

	anl$2primary_data_record(s,current_stack[.key_level,0,0,0,0],true,1);


[17]:	! Routine number 17 is for displaying the actual data record bytes
	! in a primary data record.  The BSD points at the data record,
	! which we will format in hex.  This is for prolog 2.

	(local
		rec_dsc: descriptor;

	selectoneu .anl$gl_fat[fat$v_rtype] of set
	[fat$c_fixed]:		build_descriptor(rec_dsc,.anl$gl_fat[fat$w_maxrec],.sp);

	[fat$c_variable,
	 fat$c_vfc]:		build_descriptor(rec_dsc,2+.sp[0,0,16,0],.sp);
	tes;
	anl$format_hex(1,rec_dsc););


[18]:	! Routine number 18 is for displaying a SIDR record fixed portion.
	! The following routine will do it, and update the BSD.
	! It needs the key descriptor for this index.  This is for prolog 2.

	anl$2sidr_record(s,current_stack[.key_level,0,0,0,0],true,1);


[19]:	! Routine number 19 is for displaying a SIDR pointer.  The following
	! routine will do it and update the BSD.  This is for prolog 2.

	anl$2sidr_pointer(s,true,2);


[20,
 21,
 22,
 23]:	! Routines number 20 through 23 are for displaying primary and
	! secondary index buckets, and primary and secondary data buckets.
	! The following routine will do it and update the BSD.  This is
	! for prolog 3.

	(bind
		k = current_stack[.key_level,0,0,0,0]: bsd,
		kp = .k[bsd$l_bufptr] + .k[bsd$l_offset]: block[,byte];

	anl$3bucket_header(s,.sp[bkt$b_indexno],.kp[key$v_dupkeys],.sp[bkt$b_level],true,0););


[24,
 25]:	! Routines number 24 and 25 are for displaying the index records
	! in primary and secondary indexes, respectively.  The following
	! routine will do it and update the BSD.  It needs the key
	! descriptor.  This is for prolog 3.

	anl$3index_record(s,current_stack[.key_level,0,0,0,0],true,1);


[26]:	! Routine number 26 is for displaying the primary data records in a
	! primary data bucket.  The following routine will do it and update
	! the BSD.  It needs the key descriptor.  This is for prolog 3.

	anl$3primary_data_record(s,current_stack[.key_level,0,0,0,0],true,1);


[27]:	! Routine number 27 is for displaying the actual data record bytes
	! in a primary data record.  We call a routine to do it.  This is
	! for prolog 3.

	anl$3format_data_bytes(1,s,current_stack[.key_level,0,0,0,0]);


[28]:	! Routine number 28 is for displaying a SIDR record fixed portion
	! for prolog 3.  The routine is a stub, because secondary keys
	! are not supported for prolog 3 in VMS V3.0.

	anl$3sidr_record();


[29]:	! Routine number 29 is for displaying a SIDR pointer.  Secondary
	! keys are not supported for prolog 3 in VMS V3.0.

	;


[30]:	! Routine number 30 is for displaying the header of a reclaimed
	! bucket on the available chain off an area descriptor.  This
	! routine works for all prologs.

	anl$3reclaimed_bucket_header(s,true,0);
tes;

return;

end;

%sbttl 'ANL$INTERACTIVE_DOWN - Handle DOWN Command'
!++
! Functional Description:
!	This routine handles the interactive DOWN command.  It is responsible
!	for determining the path that the user wants to take, and constructing
!	a BSD that describes the resulting structure.
!
! Formal Parameters:
!	path		Address of descriptor of desired path name.
!	current_bsd	Address of BSD describing current structure.
!	down_bsd	Address of BSD to fill in with the down structure.
!	new_level	The stack level of the BSD to fill.
!
! Implicit Inputs:
!	global data
!
! Implicit Outputs:
!	global data
!
! Returned Value:
!	True if there is a down structure, false if not.
!
! Side Effects:
!
!--


global routine anl$interactive_down(path,current_bsd,down_bsd,new_level) = begin

bind
	path_dsc = .path: descriptor,
	c = .current_bsd: bsd,
	d = .down_bsd: bsd;

local
	i: long, j: long,
	path_index: long,
	cp: ref block[,byte],
	hp: ref block[,byte],
	sp: ref block[,byte];


! Establish the condition handler for drastic structure errors.

lib$establish(anl$condition_handler);

! The first thing we need to check is whether there are any possible
! paths down from the current structure.  If not, that's an error.

if .structure_table[.c[bsd$w_type],1] eqlu 0 then (
	signal (anl$_nodown);
	return false;
);

! Now, if the user has entered the command DOWN ?, or has not entered
! any path name at all and there is more than one way down, we need to
! display a list of possible paths.

if (.path_dsc[len] gequ 1 and ch$rchar(.path_dsc[ptr]) eqlu '?') or
   (.path_dsc[len] eqlu 0 and .structure_table[.c[bsd$w_type],2] nequ 0) then (
	signal (anl$_downhelp);
	incru i from 1 to 3 do
		if (j = .structure_table[.c[bsd$w_type],.i]) nequ 0 then
			signal (anl$_downpath,2,.path_table[.j,path_name],.path_table[.j,path_text]);
	return false;
);

! Now, if the user has entered a path name, we need to figure which path
! they have specified.  If they didn't enter one, we know at this point
! that there is only one way down.

if .path_dsc[len] gtru 0 then (
	local
		length: long;

	! Now loop through the down paths specified by this structure entry.
	! We are looking for a path name that matches what the user entered.

	path_index = 0;
	incru i from 1 to 3 do
		if (j = .structure_table[.c[bsd$w_type],.i]) nequ 0 then (
			bind
				a_path_name = .path_table[.j,path_name];
			length = minu(ch$rchar(a_path_name),.path_dsc[len]);
			if ch$eql(.length,.path_dsc[ptr], .length,a_path_name+1,' ') then (
				path_index = .j;
	exitloop;
			);
		);

) else
	path_index = .structure_table[.c[bsd$w_type],1];

! Let's set up a pointer to the current structure.  Also we sometimes need
! one to the bucket header.

cp = .c[bsd$l_bufptr] + .c[bsd$l_offset];
hp = .c[bsd$l_bufptr];

! OK, now we can case on the path routine number and actually effect
! the downward movement.  We are to fill in the down_bsd with a description
! of the resulting structure.  The BSD type is specified in the path table.

init_bsd(d);
d[bsd$w_type] = .path_table[.path_index,path_result];

case .path_table[.path_index,path_routine] from 0 to 22 of set

[0]:	! If the path_index wasn't set to a valid path number, then the
	! user must have entered a bad path name.

	(signal (anl$_badpath);
	return false;);


[1]:	! Downward path 1 is from the file header to the RMS attribute
	! area.  All we need to fill in is the type, which was done above.

	;


[2]:	! Downward path 2 is from the RMS attribute area to the actual
	! blocks of the file.  The structure type depends on file organization.
	! If it's a sequential file, we have to check that there are
	! any records at all.

	(d[bsd$w_type] =
		(selectoneu .anl$gl_fat[fat$v_fileorg] of set

	 	 [fat$c_sequential]:	(if .anl$gl_fat[fat$l_efblk] eqlu 1 and
					    .anl$gl_fat[fat$w_ffbyte] eqlu 0 then (
						signal (anl$_norecs);
						return false;
					);
					3);

	 	 [fat$c_relative]:	4;

	 	 [fat$c_indexed]:	7;
	 	 tes);
	d[bsd$w_size] = 1;
	d[bsd$l_vbn] = 1;);

[3]:	! Downward path 3 is from a relative file prolog to its first
	! data bucket.  There may not be any.

	if .anl$gl_fat[fat$l_hiblk]-1 lssu .anl$gl_fat[fat$b_bktsize] then (
		signal (anl$_norecs);
		return false;
	) else (
		d[bsd$w_size] = .anl$gl_fat[fat$b_bktsize];
		d[bsd$l_vbn] = .cp[plg$w_dvbn];
	);


[4]:	! Downward path 4 is from a relative file bucket to the first
	! first cell in the bucket.

	(d[bsd$w_size] = .c[bsd$w_size];
	d[bsd$l_vbn] = .c[bsd$l_vbn];);


[5]:	! Downward path 5 is from an indexed file prolog to the first
	! area descriptor.

	(d[bsd$w_size] = 1;
	d[bsd$l_vbn] = .cp[plg$b_avbn];);


[6]:	! Downward path 6 is from an indexed file prolog to the first
	! key descriptor.  We need to remember the stack level of the
	! BSD we are creating, because lots of other folks need to get
	! at the key descriptor.

	(d[bsd$w_size] = 1;
	d[bsd$l_vbn] = 1;
	key_level = .new_level);


[7]:	! Downward path 7 is from an indexed file key descriptor to either
	! the primary or secondary index buckets.  We must distinguish 
	! between prolog 2 and 3 files and worry about uninitialized indexes.

	if .cp[key$v_initidx] then (
		signal (anl$_uninitindex);
		return false;
	) else (
		d[bsd$w_type] = (if .anl$gw_prolog eqlu plg$c_ver_3 then
					if .cp[key$b_keyref] eqlu 0 then 20 else 21
				 else
					if .cp[key$b_keyref] eqlu 0 then 10 else 11);
		d[bsd$w_size] = .cp[key$b_idxbktsz];
		d[bsd$l_vbn] = .cp[key$l_rootvbn];
	);


[8]:	! Downward path 8 is from an indexed file key descriptor to either
	! the primary or secondary data buckets.  We must distinguish 
	! between prolog 2 and 3 files and worry about uninitialized indexes.

	if .cp[key$v_initidx] then (
		signal (anl$_uninitindex);
		return false;
	) else (
		d[bsd$w_type] = (if .anl$gw_prolog eqlu plg$c_ver_3 then
					if .cp[key$b_keyref] eqlu 0 then 22 else 23
				 else
					if .cp[key$b_keyref] eqlu 0 then 12 else 13);
		d[bsd$w_size] = .cp[key$b_datbktsz];
		d[bsd$l_vbn] = .cp[key$l_ldvbn];
	);


[9]:	! Downward path 9 is from an index file index bucket to the first
	! index entry in the bucket.  This is for prolog 2.

	(d[bsd$w_type] = (if .c[bsd$w_type] eqlu 10 then 14 else 15);
	d[bsd$w_size] = .c[bsd$w_size];
	d[bsd$l_vbn] = .c[bsd$l_vbn];
	d[bsd$l_offset] = bkt$c_overhdsz;);


[10]:	! Downward path 10 is from a primary or secondary index record to
	! the index or data bucket pointed to by it.  This is for prolog 2.

	(if .hp[bkt$b_level] gequ 2 then (

		! The next lower level is another index bucket.  Set the
		! type according to whether it's primary or secondary.
		! Set the size the same as the current index bucket.

		d[bsd$w_type] = (if .c[bsd$w_type] eqlu 14 then 10 else 11);
		d[bsd$w_size] = .c[bsd$w_size];
	) else (

		! The next lower level is the data buckets.  Set the type
		! according to whether it's a primary or secondary bucket.
		! The size has to be found from the key descriptor.

		d[bsd$w_type] = (if .c[bsd$w_type] eqlu 14 then 12 else 13);
		begin
		bind
			k = current_stack[.key_level,0,0,0,0]: bsd,
			kp = .k[bsd$l_bufptr] + .k[bsd$l_offset]: block[,byte];

		d[bsd$w_size] = .kp[key$b_datbktsz];
		end;
	);

	! Now we set up the VBN of the downward structure by looking in the
	! index record.

	d[bsd$l_vbn] =	(case .cp[irc$v_ptrsz] from 0 to 2 of set
			[0]:	.cp[1,0,16,0];
			[1]:	.cp[1,0,24,0];
			[2]:	.cp[1,0,32,0];
			tes);
	d[bsd$l_offset] = 0;);


[11]:	! Downward path 11 is from a primary data bucket to the first record
	! in the bucket.

	(d[bsd$w_size] = .c[bsd$w_size];
	d[bsd$l_vbn] = .c[bsd$l_vbn];
	d[bsd$l_offset] = bkt$c_overhdsz;);


[12]:	! Downward path 12 is from a primary data record to the actual
	! record bytes.  They may not exist.  This is for prolog 2.

	if .cp[irc$v_deleted] or .cp[irc$v_rrv] then (
		signal (anl$_nodata);
		return false;
	) else (
		d[bsd$w_size] = .c[bsd$w_size];
		d[bsd$l_vbn] = .c[bsd$l_vbn];
		d[bsd$l_offset] = .c[bsd$l_offset] +
				  1 +
				  1 +
				  (if .cp[irc$v_noptrsz] then 0 else .cp[irc$v_ptrsz]+3);
	);


[13]:	! Downward path 13 is from a primary data record to the data bucket
	! pointed at by the RRV.  The pointer may not exist.  This is for 
	! prolog 2.

	if .cp[irc$v_noptrsz] then (
		signal (anl$_norrv);
		return false;
	) else (
		d[bsd$w_size] = .c[bsd$w_size];
		d[bsd$l_vbn] =	(case .cp[irc$v_ptrsz] from 0 to 2 of set
				[0]:	.cp[3,0,16,0];
				[1]:	.cp[3,0,24,0];
				[2]:	.cp[3,0,32,0];
				tes);
	);


[14]:	! Downward path 14 is from a secondary data bucket to the first record
	! in the bucket.  This is for prolog 2.  The data bucket can be empty.

	if .hp[bkt$w_freespace] eqlu bkt$c_overhdsz then (
		signal (anl$_emptybkt);
		return false;
	) else (
		d[bsd$w_size] = .c[bsd$w_size];
		d[bsd$l_vbn] = .c[bsd$l_vbn];
		d[bsd$l_offset] = bkt$c_overhdsz;
	);


[15]:	! Downward path 15 is from a SIDR record to the first pointer in the
	! pointer array.  We have to get the key length to figure out where
	! the first pointer is.  The work longword in the BSD must be
	! initialized to the number of pointer bytes so people can tell
	! where they end.  This is for prolog 2.

	(d[bsd$w_size] = .c[bsd$w_size];
	d[bsd$l_vbn] = .c[bsd$l_vbn];

	begin
	bind
		k = current_stack[.key_level,0,0,0,0]: bsd,
		kp = .k[bsd$l_bufptr] + .k[bsd$l_offset]: block[,byte];

	d[bsd$l_offset] =	.c[bsd$l_offset] +
				1 +
				1 +
				(if .cp[irc$v_noptrsz] then 0 else 4) +
				2 +
				.kp[key$b_keysz];
	d[bsd$l_work] =	(if .cp[irc$v_noptrsz] then .cp[2,0,16,0] else .cp[6,0,16,0]) -
			.kp[key$b_keysz];
	end;);


[16]:	! Downward path 16 is from an index bucket to the first index
	! entry in the bucket.  We must set the work longword to zero to
	! indicate we are on the zeroth record.  This is for prolog 3.

	(d[bsd$w_type] = (if .c[bsd$w_type] eqlu 20 then 24 else 25);
	d[bsd$w_size] = .c[bsd$w_size];
	d[bsd$l_vbn] = .c[bsd$l_vbn];
	d[bsd$l_offset] = bkt$c_overhdsz;
	d[bsd$l_work] = 0;);


[17]:	! Downward path 17 is from a primary or secondary index record to
	! the index or data bucket pointed to by it.  This is for prolog 3.

	(if .hp[bkt$b_level] gequ 2 then (

		! The next lower level is another index bucket.  Set the
		! type according to whether it's primary or secondary.
		! Set the size the same as the current index bucket.

		d[bsd$w_type] = (if .c[bsd$w_type] eqlu 24 then 20 else 21);
		d[bsd$w_size] = .c[bsd$w_size];
	) else (

		! The next lower level is the data buckets.  Set the type
		! according to whether it's a primary or secondary bucket.
		! The size has to be found from the key descriptor.

		d[bsd$w_type] = (if .c[bsd$w_type] eqlu 24 then 22 else 23);

		begin
		bind
			k = current_stack[.key_level,0,0,0,0]: bsd,
			kp = .k[bsd$l_bufptr] + .k[bsd$l_offset]: block[,byte];

		d[bsd$w_size] = .kp[key$b_datbktsz];
		end;
	);

	! Now we set up the VBN of the downward structure by looking in the
	! VBN list and extracting the appropriate VBN.  The work longword
	! in the BSD tells us which key we are on.

	sp = (.c[bsd$l_endptr]-4) - (.c[bsd$l_work]+1) * (.hp[bkt$v_ptr_sz]+2);
	d[bsd$l_vbn] =	(case .hp[bkt$v_ptr_sz] from 0 to 2 of set
			[0]:	.sp[0,0,16,0];
			[1]:	.sp[0,0,24,0];
			[2]:	.sp[0,0,32,0];
			tes);
	d[bsd$l_offset] = 0;);


[18]:	! Downward path 18 is from a primary data record to the actual
	! data bytes.  They may not exist.  This is for prolog 3.

	if .cp[irc$v_deleted] or .cp[irc$v_rrv] then (
		signal (anl$_nodata);
		return false;
	) else (

		! The BSD for the data bytes is identical to that for the
		! complete record, because we need all the record information
		! to display the bytes.

		d[bsd$w_size] = .c[bsd$w_size];
		d[bsd$l_vbn] = .c[bsd$l_vbn];
		d[bsd$l_offset] = .c[bsd$l_offset];
	);


[19]:	! Downward path 19 is from a primary data record to the data bucket
	! pointed at by the RRV.  The pointer may not exist.  This is for
	! prolog 3.

	if .cp[irc$v_noptrsz] then (
		signal (anl$_norrv);
		return false;
	) else (
		d[bsd$w_size] = .c[bsd$w_size];
		d[bsd$l_vbn] =	(case .cp[irc$v_ptrsz] from 0 to 2 of set
				[0]:	.cp[5,0,16,0];
				[1]:	.cp[5,0,24,0];
				[2]:	.cp[5,0,32,0];
				tes);
	);


[20]:	! Downward path 20 is from a prolog 3 secondary data bucket to the
	! first SIDR in the bucket.  Secondary keys are not supported for
	! prolog 3 in VMS V3.0.

	;


[21]:	! Downward path 21 is from a prolog 3 SIDR record to the first
	! pointer in the pointer array.  Secondary keys are not supported for
	! prolog 3 in VMS V3.0.

	;


[22]:	! Downward path 22 is from an area descriptor to the first reclaimed
	! bucket on the available list (if any).  This works for both prologs.

	if .cp[area$l_avail] eqlu 0 then (
		signal (anl$_noreclaimed);
		return false;
	) else (
		d[bsd$w_size] = .cp[area$b_arbktsz];
		d[bsd$l_vbn] = .cp[area$l_avail];
	);
tes;

! Now we can read in the bucket which was set up.

anl$bucket(d,.c[bsd$l_vbn]);

return true;

end;

%sbttl 'ANL$INTERACTIVE_DUMP - Dump a Block in Hex'
!++
! Functional Description:
!	This routine handles the interactive DUMP command, which allows the
!	user to dump a single virtual block in hex.
!
! Formal Parameters:
!	argument	A descriptor of the argument supplied by the user.
!			It should be the VBN of the block to be dumped.
!
! Implicit Inputs:
!	global data
!
! Implicit Outputs:
!	global data
!
! Returned Value:
!	none
!
! Side Effects:
!
!--


global routine anl$interactive_dump(argument): novalue = begin

bind
	argument_dsc = .argument: descriptor;

local
	status: long,
	vbn: long,
	b: bsd;


! Begin by converting the user's argument to a longword.  If it won't convert,
! tell the user and quit.

status = anl$internalize_number(argument_dsc,vbn);
if not .status then (
	signal (anl$_badvbn);
	return;
);

! Now let's constrain the VBN to within the limits of the file.  Because of
! a stupidity in RMS block I/O, we have to contrain sequential files to
! the end-of-file block, while the others only to the end of the allocation.

vbn = minu( maxu(1,.vbn),
		(if .anl$gl_fat[fat$v_fileorg] eqlu fat$c_sequential then
			.anl$gl_fat[fat$l_efblk]
		else
			.anl$gl_fat[fat$l_hiblk]));

! Build a BSD describing the desired block and read it in.

init_bsd(b);
b[bsd$w_size] = 1;
b[bsd$l_vbn] = .vbn;
anl$bucket(b,0);

! We can format the block in hex, and then free it up.  We'll include a nice
! heading also.

anl$format_line(3,0,anl$_dumpheading,.vbn);

begin
local
	block_dsc: descriptor;

build_descriptor(block_dsc,512,.b[bsd$l_bufptr]);
anl$format_hex(1,block_dsc);
end;

anl$bucket(b,-1);

return;

end;

%sbttl 'ANL$INTERACTIVE_HELP - Handle the HELP Command'
!++
! Functional Description:
!	This routine is responsible for handling the interactive HELP command.
!	All the work is done by LBR$OUTPUT_HELP.
!
! Formal Parameters:
!	arguments	A descriptor of the help keywords as entered by user.
!
! Implicit Inputs:
!	global data
!
! Implicit Outputs:
!	global data
!
! Returned Value:
!	none
!
! Side Effects:
!
!--


global routine anl$interactive_help(arguments): novalue = begin

bind
	arguments_dsc = .arguments: descriptor;

local
	status: long;


! Simply call the wonderful librarian to do the work.

status = lbr$output_help(lib$put_output,0,arguments_dsc,describe('ANLRMSHLP'),
			 0,lib$get_input);
check (.status, .status);

return;

end;

end eludom
	
