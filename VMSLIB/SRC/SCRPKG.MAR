	.title	lib$scrpkg	Screen package for DEC terminals
	.ident	'V03-001'
	.sbttl	copyright notice
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
	.page
	.sbttl	Program description
;
;   Facility
;
;	Graphics Package for DEC terminal functions
;
;   Abstract
;
;	This module contains routines to perform terminal
;	graphics functions on the logical device SYS$OUTPUT.
;	The terminal type is interrogated and saved on the
;	first routine call and determines the escape sequences
;	to be sent to the terminal.  For unknown terminals
;	and terminals without any graphics functions (LA36),
;	an appropriate sequence is sent when necessary (carriage
;	return instead of SET_CURSOR).
;
;   Environment
;
;	Native mode, User mode, Shared library routines
;
;   Author
;
;	Tim Halvorsen, September 1978
;
;   Modified by
;
;	V03-001	SBL3001		Steven B. Lionel	13-April-1982
;		Correct default number-of-lines parameter for
;		LIB$PUT_LINE to 1.
;
;	020	MIR0062		Michael I Rosenblum  23-Dec-1981
;		Have screen_info return EDIT and DECCRT reflect change
;		in functionality by changing the bit definition from
;		ANSI to ANSICRT.
;
;	019	BLS0122		Benn Schreiber	15-Dec-1981
;		Change all $GETDVI args to 4 bytes
;
;	018	MIR0057		Michael I Rosenblum  9-Dec-81
;		Change ANSI to reflect the change in the terminal
;		philosophy.
;
;	017	SBL0017		Steve Lionel	19-Nov-1981
;		Add missing "omitted-by-reference" argument check in
;	 	LIB$PUT_BUFFER.  Use LIB$ANALYZE_SDESC_R2 instead of _R3.
;
;	016	JLV0122		Jake VanNoy	16-Nov-1981
;		Change $GETCHN call to $GETDVI.
;
;	015	SBL0015		Steve Lionel	10-Nov-1981
;		Fix bug in SET_BUFFER path to cancel buffering.
;
;	014	SBL0014		Steve Lionel	26-Oct-1981
;		Add missing LIB$PUT_LINE.  Allocate event flag
;		numbers with LIB$GET_EF.  Fix compares of (AP)
;		to only look at one byte.  Call LIB$ANALYZE_SDESC
;		for SCR$SET_BUFFER.
;
;	013	SBL0013		Steve Lionel	26-Oct-1981
;		Change attributes of _SCR$CODE and _SCR$STRINGS
;		from NOSHR to SHR.
;
;	012	JLV0083		Jake VanNoy	8-Sep-1981
;		Check for VT100 or ANSI for terminal to qualify
;		for ANSI escape sequences.
;
;	011	TMH0011		Tim Halvorsen	05-Sep-1981
;		Accept PL/I strings as input to SCR$PUT_SCREEN
;		and SCR$SET_OUTPUT by using new RTL routine to
;		get the length and address given a descriptor address.
;
;	010	JLV0077		Jake VanNoy	28-Aug-1981
;		Change checking for VT100 to checking for ANSI
;		bit in DIB$L_DEVDEPND2. Fix bug in using longword
;		access to length in descriptor. Add new bits
;		to SCR$L_FLAGS (ANSI, REGIS, BLOCK, AVO).
;
;	009	GRR0012		Greg Robert	08-May-1981
;		Fix STOP_OUTPUT to only reset scrolling region
;		if it is active
;
;	008	GRR0011		Greg Robert	01-May-1981
;		Fixed GET_SCREEN to suppress calling foreign
;		terminal code.  Improved FILL_MAP fix in rev 7.
;
;	007	GRR0010		Greg Robert	05-Feb-1981
;		Fixed ERASE_LINE to store new cursor position
;		if supplied.  Fixed FILL_MAP to check input
;		parameters against buffer size.
;
;		Revised SET_OUTPUT to accept an input file
;		specification instead of a channel.  Changed PUT_MAP
;		and OUTPUT to use RMS when file spec supplied.
;		Enhanced STOP_OUTPUT to free up VM for maps and
;		to close RMS file.
;
;		Rewrote PUT_MAP breaking it into 3 subroutines
;		Placed user routine address/parameter in screen
;		control block instead of own storage.
;
;		Fixed SET_OUTPUT to allow return the previous stream
;		and to leave user routine/parameter arguements unchanged
;		unless explicity changed.  Added an exit handler and
;		reset scrolling on VT100's on exit.
;
;	006	GRR0009		Greg Robert	20-Jan-1981
;		Fixed SCR$PUT_BUFFER to only call PUT_MAP
;		when called with a zero or null arguement
;		and to turn off buffering at the same time.
;		Fixed SCR$PUT_SCREEN to access descriptor length
;		as a word instead of a long in mapping mode.
;		Removed useless implied put_maps in scrolling
;		routines.
;
;	005	GRR0008		Greg Robert	16-Jan-1981
;		Added a SCR$UP_SCROLL routine. Changed SCR$W_WIDTH
;		useage to SCR$W_DEVPAGSIZE. Added a SCR$PUT_LINE routine.
;		Fixed PUT_BUFFER to turn buffering off when called
;		with no arguements or an arguement of zero.  Allow PUT_BUFFER
;		to be called when no buffering was active.  Fixed mapping
;		to allow wraparound and to compute ending column correctly.
;
;	004	GRR0007		Greg Robert	14-Jan-1981
;		Change R3 to R1 in FILL_MAP so it isn't
;		clobbered by consequtive MOVC5's.  Remove
;		temporary bypass of LIB$ASSIGN errors.
;		Handle errors properly in PUT_MAP. Remove
;		implied PUT_MAP logic, only output maps
;		on explicit PUT_BUFFER calls.
;
;	003	GRR0006		Greg Robert	17-Nov-1980
;		Added simulated VDT support for hardcopy devices
;		including cursor movement, bold, underline and
;		scrolling regions.  This is work-in-progress.
;
;	002	HRJ0005		Herb Jacobs	20-Oct-1980
;		Added support for multi-terminal output and
;		user output with screen package buffering.
;		Bugs fixed dealing with returning invalid status
;		and/or ignoring it internally, longword access to
;		word quantities, and incorrect register usage in
;		foreign terminal code.
;
;	001	TMH0001		Tim Halvorsen	22-Jul-1980
;		Add bold,reverse,blink, routines.
;		Remove foreign terminals 605x, 6502.
;--

	.sbttl	Symbol Definitions

;
;	Symbol Defintions
;
	$dcdef				; Device type definitions
	$dvidef				; $GETDVI definitions
	$scrdef GLOBAL			; Screen package definitions
	$fabdef				; RMS FAB definitions
	$rabdef				; RMS RAB definitions
	$tt2def				; Terminal definitions


regs	=	^m<r2,r3,r4,r5,r6,r7>	; Standard save registers

bufsiz	=	512			; Buffer size for single I/O

bs	=	^x08			; Backspace
lf	=	^x0a			; Line feed
cr	=	^x0d			; Carriage return
esc	=	^x1b			; Escape character
cb	=	^x1f			; Line/column bias in message
lb	=	^a'['			; Left bracket (vt100)
semi	=	^x3b			; Semi-colon (vt100)

;
;	Terminal type definitions
;

unknown	=	0		; Non-graphics or unknown type
vt05	=	1		; vt05 series terminal
vt52	=	2		; VT5x series terminal
vt100	=	3		; VT100 series terminal
vtforeign =	4		; Foreign terminal (FT1-8)

vt05_sc   = ^X0E		; set cursor position
vt05_home = ^X1D		; set cursor to home
vt05_cup  = ^X1A		; cursor up
vt05_eol  = ^X1E		; erase to end of line
vt05_eos  = ^X1F		; erase to end of screen

vt52_sc   = ^X59		; set cursor position
vt52_home = ^X48		; set cursor to home
vt52_dwn  = ^X49		; down scroll
vt52_eos  = ^X4A		; erase to end of screen
vt52_eol  = ^X4B		; erase to end of line

vt100_sc = ^A'f'		; set cursor position
vt100_dwn = ^A'M'		; down scroll
vt100_eos = ^A'J'		; erase to end of screen
vt100_eol = ^A'K'		; erase to end of line
vt100_sgr = ^A'm'		; Select graphic rendition
vt100_sm  = ^A'r'		; Set scrolling region


;	Terminal control block definitions

	scr$l_flink	= 0		; Link pointer to next terminal block
	scr$l_buffer	= 4		; Address of buffer for buffer mode
	scr$w_chan	= 8		; Channel number for this terminal
	scr$b_type	= 10		; Terminal type
	scr$b_devtyp	= 11		; Device type ($dcdef)
	scr$w_devwidth	= 12		; Line width in characters
	scr$w_devpagsiz	= 14		; Lines on screen
	scr$l_devchar	= 16		; Supported device characteristics
	scr$l_area	= 20		; Size of screen maps
	scr$l_charmap	= 24		; Address of character array
	scr$l_attrmap	= 28		; Address of attribute array
	scr$l_modfmap	= 32		; Address of modified bit map
	scr$l_line	= 36		; Current line
	scr$l_column	= 40		; Current column
	scr$l_attrmask	= 44		; OR'd attributes for attrmap
	scr$l_stream	= 48		; User assigned stream number
	scr$w_ifi	= 52		; Context for RMS file calls
	scr$w_isi	= 54		; Context for RMS record calls
	scr$q_rtninfo	= 56		; Quadword describing next 2 locations
	scr$l_rtnaddr	= 56		; Routine call back address for output
	scr$l_rtnarg	= 60		; Argument to pass to routine
	scr$l_control	= 64		; Screen control flags
	 scr$v_scroll	= 0		;  bit 0, on = scrolling region active
	scr$l_devdepnd2 = 68		; Devdepnd2 as returned by GETDVI
	scr$l_efn	= 72		; Event flag number to use for QIOs
	scr$c_size	= 76		; Size of block per terminal	
;
; Following fields are accessed as quadwords
;
	assume	scr$l_column,eq,scr$l_line+4

;
;	Macro definitions
;

	.macro	string	text,?l1,?l2
	.save
	.psect	_scr$strings,exe,nowrt,pic,shr
l1:	.ascii	text
l2:
	.restore
	.long	l2-l1
	.long	l1-<.-4>
	.endm	string

	.sbttl	Writable data definitions

;
;	Writable data definitions
;

	.psect	_lib$data,noexe,wrt,pic
scr$l_flinkhead:
	.long	0			; initial state is empty
scr$l_curoutput:
	.long	0			; pointer to current output unit
scr$l_workmask:
	.long	0			; used to reset attribute mask
scr$exitblock:
	.long	0			;
	.long	0			; exit handler
	.long	1			;
	.long	0			; exit status
scr$l_exitsts:				; filled in before exit handler called
	.blkl	1

;
; $GETDVI Storage
;

scr$ab_devclass:	.blkl	1
scr$ab_devtype:		.blkl	1
scr$aw_devbufsiz:	.blkl	1
scr$al_devdepend:	.blkl	1
scr$al_devdepnd2:	.blkl	1

scr$a_itmlst:
		.word		4
		.word		DVI$_DEVCLASS
scr$_infoclass:	.long		0
		.long		0

		.word		4
		.word		DVI$_DEVTYPE
scr$_infotype:	.long		0
		.long		0

		.word		4
		.word		DVI$_DEVBUFSIZ
scr$_infosiz:	.long		0
		.long		0

		.word		4
		.word		DVI$_DEVDEPEND
scr$_infodep:	.long		0
		.long		0
	
		.word		4
		.word		DVI$_DEVDEPEND2
scr$_infodep2:	.long		0
		.long		0

		.long		0			; End of list

	.sbttl	Read-only data definitions

;
;	Read-only data definitions
;

	.psect	_scr$code,exe,nowrt,pic,shr

vt52_mode:
	.ascic	<cr><esc><lb>'?2l'<esc>'\'<cr>'   '<cr> ; Get into VT52 mode
vt100_mode:
	.ascic	<esc>'<'		; Get into VT100 mode

	.sbttl	Lib$_ entry points
;++
; Functional Description:
;
;	RTL entry points for calls to SCR$ (screen formating package)
;	routines. Tests for valid VAX-11 procedure calling standard
;	defaults and reformats (where necessary) the argument list to
;	conform to the requirements of the routine.
;
; Calling Sequence:
;
;	status.wlc.v	= lib$erase_page ([line_no.rw.r,column_no.rw.r])
;
;	status.wlc.v	= lib$erase_line ([line_no.rw.r,column_no.rw.r])
;
;	status.wlc.v	= lib$set_cursor (line_no.rw.r,column_no.rw.r)
;
;	status.wlc.v	= lib$put_screen (text.rt.dx[,line_no.rw.r,column_no.rw.r,
;						attributes.rl.r])
;
;	status.wlc.v	= lib$put_line (text.rt.dx [, nlines.rl.r [, attributes.wl.r]])
;
;	status.wlc.v	= lib$get_screen (input_text.wt.dx[,prompt.rt.dx])
;
;	status.wlc.v	= lib$down_scroll ()
;
;	status.wlc.v	= lib$up_scroll ()
;
;	status.wlc.v	= lib$set_scroll(start_line.rw.r,end_line.rw.r)
;
;	status.wlc.v	= lib$set_buffer ([buffer.mt.ds])
;
;	status.wlc.v	= lib$screen_info (flags.ww.r[,dev_type.ww.r[,line_width.ww.r[,lines_per_page.ww.r]]])
;
;	status.wlc.v	= lib$set_output (channel.rw.r[,output_callback.al.r[,user_arg.rl.r]])
;
;	status.wlc.v	= lib$stop_output (channel.rw.r)
;
; Input parameters:
;
;	See SCR$ routine descriptions
;
; Implicit inputs:
;
;	See Writable data definitions
;
;
; Completion codes:
;
;	ss$_normal	- normal successful completion
;	lib$_scrbufovf	- screen buffer overflow
;	lib$_invscrpos	- invalid screen position parameters
;	lib$_invarg	- invalid arguments
;	lib$_invcha	- invalid channel
;
;++

	.entry	lib$erase_page,0
	movab	w^scr$erase_page,r1
	brb	line_col

	.entry	lib$erase_line,0
	movab	w^scr$erase_line,r1
	brb	line_col

	.entry	lib$set_scroll,0
	movab	w^scr$set_scroll,r1

line_col:
	movzbl	(ap),r0			; Check number of arguments
	beql	20$			; branch if no arguments
	cmpl	r0,#2			; Check against maximum
	bgtru	invarg			; >2 arguments is illegal
	beql	10$			; branch if both specified
	tstl	4(ap)			; null argument?
	bneq	invarg			; if not, error - 1 arg specified
	clrl	r0			; if 1 null argument, set to 0 args
	brb	20$
10$:	pushl	8(ap)			; push address of column
	beql	invarg
	movzwl	@(sp)+,-(sp)		; Get actual column value
	beql	invscrpos
	pushl	4(ap)			; push address of line
	beql	invarg
	movzwl	@(sp)+,-(sp)		; Get actual line value
	beql	invscrpos
20$:	pushl	r0
	callg	(sp),(r1)		; Call by value
	ret

invarg:	movl	#lib$_invarg,r0		; invalid arguments
	ret				; quit
invscrpos:
	movl	#lib$_invscrpos,r0	; invalid screen position
	ret				; quit

	.entry	lib$set_cursor,0
	cmpb	(ap),#2			; 2 args? 
	bneq	invarg			; no, illegal # args
	movzwl	@8(ap),-(sp)		; Get column number
	beql	invarg
	movzwl	@4(ap),-(sp)		; Get line number
	beql	invarg
	pushl	#2
	callg	(sp),w^scr$set_cursor	; Call by value
	ret

	.entry	lib$put_screen,0
	cmpb	(ap),#1			; test number of arguments
	blssu	invarg			; error if no arguments
	beql	30$			; branch if only 1 argument
	cmpb	(ap),#3			; test if both line/column given
	blssu	invarg			; error if not both
	beql	10$
	cmpb	(ap),#4			; test if too many arguments
	bgtru	invarg			; error if so
	pushl	16(ap)			; push address of attribute flags
	beql	10$			; if missing, default to zero
	pushl	@(sp)+			; Get actual attribute flags
10$:	pushl	12(ap)			; push address of column number
	beql	20$			; if missing, default to zero
	movzwl	@(sp)+,-(sp)		; Get actual column value
	beql	invscrpos		; branch if col num equals zero
20$:	pushl	8(ap)			; push address of line number
	beql	30$			; if missing, default to zero
	movzwl	@(sp)+,-(sp)		; Get actual line value
	beql	invscrpos		; branch if line num equals zero
30$:	movq	(ap),-(sp)		; push #args, string desc address
	callg	(sp),w^scr$put_screen	; Call by value
	ret

	.sbttl	GET_TYPE	Get terminal type
;---
;
;	GET_TYPE
;
;	This routine returns the terminal type using the
;	GETDVI system service.  It is only done once per terminal for
;	the life of the process -- all later calls simply
;	return the saved terminal type.
;
; Calling sequence:
;
;	BSB
;
; Inputs:
;
;	R0 = Request number (used only for foreign terminals)
;
; Outputs:
;
;	R0 = Error return code
;	R1 = Terminal type (as follows)
;		0 = Non-graphics or unknown terminal
;		1 = DEC VT05 series terminal
;		2 = DEC VT5X series terminal
;		3 = DEC VT100 series terminal
;		4 = Foreign terminal
;
;	All other registers remain unchanged.
;
;---

sysoutput:
	.ascic	"SYS$OUTPUT"		; Logical name of terminal

get_type:
	movl	scr$l_curoutput,r6	; get current output control block
	beql	20$			; branch if no output device active
	movzbl	scr$b_type(r6),r1	; Get terminal type
	cmpb	r1,#vtforeign		; Foreign terminal?	
	bneq	10$			; branch if not
	movzbl	scr$b_devtyp(r6),r1	; Set r1 = device type
	tstl	r0			; Should call really be made?
	blss	10$			; Branch if not
	brw	foreign			; Call foreign terminal handler
10$:	rsb

20$:	pushl	r0			; Save function code
	movl	#lib$_invcha,r0		; assume error
	tstl	scr$l_flinkhead		; is this first call to package?
	beql	40$			; branch if yes
30$:	ret				; return error status

40$:	clrl	-(sp)			; use stream #0
	calls	#1,w^scr$set_output	; set up the device for output
	blbc	r0,30$			; branch if failure
	popl	r0			; Restore r0
	brb	get_type		; try again

;
;	Read terminal characteristics and save them
;
get_char:
	calls	#0,g^lib$lp_lines;		; get standard page length
	subl3	#6,r0,scr$w_devpagsiz(r6) 	; preset page length
	movw	#132,scr$w_devwidth(r6)		; Preset to 132 chars/line

	movab	scr$ab_devclass,scr$_infoclass	; Set up PIC references
	movab	scr$ab_devtype,scr$_infotype
	movab	scr$aw_devbufsiz,scr$_infosiz
	movab	scr$al_devdepend,scr$_infodep
	movab	scr$al_devdepnd2,scr$_infodep2

	$GETDVI_S Chan = scr$w_chan(r6), Itmlst = scr$a_itmlst
	blbs	r0,5$				; branch if getdvi failed
	brw	20$

5$:	movb	scr$ab_devtype,scr$b_devtyp(r6) ; Save device type
	mcoml	#9,scr$l_devchar(r6)		; assume BOLD and UNDERLINE supported
	cmpb	#dc$_term,scr$ab_devclass	; Check if terminal
	bneq	20$				; Branch if not

	movw	scr$aw_devbufsiz,scr$w_devwidth(r6) 	; Save device width
	movzbw	scr$al_devdepend+3,scr$w_devpagsiz(r6) 	; Save lines/page
	movl	scr$al_devdepnd2,scr$l_devdepnd2(r6) 	; Save devdepend 2
	movl	#vtforeign,r1		; Preset to foregin type
	cmpb	scr$ab_devtype,#dt$_ft1 ; check if foreign terminal
	blssu	10$			; branch if not
	cmpb	scr$ab_devtype,#dt$_ft8 ; check upper bounds
	blequ	30$			; branch if foreign
10$:	movl	#vt52,r1		; Assume VT5x
	cmpb	#dt$_vt52,scr$ab_devtype; Check if VT52
	beql	30$			; Branch if so
	cmpb	#dt$_vt55,scr$ab_devtype; Check if VT55
	beql	30$			; Branch if so
;
; Check for VT100 or VT100 compatible (ANSI)
;
	movl	#vt100,r1		  ; Assume vt100
	cmpb	#dt$_vt100,scr$ab_devtype ; Check if VT100
	beql	30$			  ; Branch if so
	bbs	#tt2$v_deccrt,-
		scr$al_devdepnd2,30$	; Branch if VT100 compatible terminal
	movl	#vt05,r1		; Assume vt05
	cmpb	#dt$_vt05,scr$ab_devtype ; Check if vt05
	beql	30$			; branch if so
	mcoml	#0,scr$l_devchar(r6)	; Support NO attributes
20$:	clrl	r1			; Indicate unknown
30$:	movb	r1,scr$b_type(r6)	; Save type for later calls
;
;	If VT52 or VT100, the terminal might be a VT100.  In any
;	case, issue the proper escape sequence to ensure that the
;	VT100 is in the correct mode, ANSI or VT52 mode.
;
	cmpl	r1,#vt52		; VT52?
	bneq	40$			; Branch if not
	movab	vt52_mode,r1		; Get into VT52 mode
	brb	50$			; output the sequence
40$:
	cmpl	r1,#vt100		; VT100?
	bneq	60$			; Branch if not
	movab	vt100_mode,r1		; Get into VT100 mode
50$:
	movzbl	(r1)+,r0		; Make descriptor of string
	movq	r0,-(sp)
	pushl	sp
	calls	#1,w^scr$put_screen	; Output the sequence
	blbc	r0,70$			; Branch if error found
	addl	#8,sp			; remove descriptor from stack
60$:
	movl	#1,r0			; Success
	movzbl	scr$b_type(r6),r1	; Return type to caller
	rsb
70$:
	ret				; Return with error

	.sbttl	FOREIGN		Call foreign terminal handler
;---
;
;	This routine attempts to map the foreign terminal
;	handler image into P0 region and call it.
;
;	r0 = Type of screen package request
;	r1 = Device type
;
;---
defstr:	.ascic	'SYS$LIBRARY:.EXE'	; Default name string
scrft:	.ascic	'SCRFT'			; File name string

foreign:
	movab	-bufsiz(sp),sp		; Allocate buffer for SCRFT output
	pushl	sp			; make descriptor of it
	pushl	#bufsiz
	pushl	#0			; Longword to recieve length
	pushl	sp			; Address of retlen word
	pushab	8(sp)			; Address of retbuf descriptor
	subl3	#dt$_ft1-1,r1,-(sp)	; Foreign terminal number
	pushl	r0			; Screen package request number
	pushl	ap			; Address of SCR argument list
	pushl	#5			; Number of arguments
	movab	defstr,r1		; Address of ASCIC default string
	movzbl	(r1)+,r0		; Generate descriptor
	movq	r0,-(sp)		; Put descriptor on stack
	movab	scrft,r1		; Address of ASCIC file name string
	movzbl	(r1)+,r0		; Generate descriptor
	movq	r0,-(sp)		; Put descriptor on stack
	pushab	16(sp)			; Address of user argument list
	pushab	12(sp)			; Address of default name string
	pushab	8(sp)			; Address of file name string
	calls	#13,g^lib$call_image	; Call foreign terminal handler
	blbc	r0,10$			; branch if error
	popl	r0			; Get length of stuff in retbuf
	movzwl	r0,(sp)			; Overwrite length in descriptor
	movl	sp,r4			; Address of string descriptor
	subl	r4,4(r4)		; Make self-relative
	brw	output			; Output the string
10$:	ret				; return with error status

	.sbttl	INIT_BUFFER	Initialize string buffer
;---
;
;	INIT_BUFFER
;
;	Create a intermediate string buffer and self-relative
;	descriptor on the top of the stack.
;
; Inputs:
;
;	None
;
; Outputs:
;
;	r5 = Address of:
;		0) # bytes currently in buffer (0)
;		1) Offset to buffer (8)
;		2) Buffer (bufsiz bytes)
;
;	r0 destroyed.
;---

init_buffer:
	popl	r0			; Get return address
	subl	#bufsiz,sp		; Allocate buffer
	pushl	#8			; Push self-relative address
	pushl	#0			; Set current length to zero
	movl	sp,r5			; Set address of descriptor
	jmp	(r0)			; return

	.sbttl	APPEND		Append string to output buffer
;---
;
;	APPEND
;
;	Append a string to the current output buffer
;
; Inputs:
;
;	r4 = Address of self-relative descriptor which
;		describes string to append.
;	r5 = Address of:
;		0) # bytes currently in buffer
;		1) Offset to buffer (8)
;		2) Buffer (bufsiz bytes)
;
; Outputs:
;
;	no registers destroyed.
;---

append:	pushr	#^m<r0,r1,r2,r3,r4,r5>	; Save registers 
	subw3	(r5),#bufsiz,r1		; Buffer space still available
	cmpw	(r4),r1			; Enough space for string?
	blequ	10$			; branch if ok
	movw	r1,(r4)			; If short, truncate to limit
10$:	movzwl	(r5),r1			; Get offset to next free byte
	addw	(r4),(r5)		; Increase current buffer size
	movc	(r4),@4(r4)[r4],8(r5)[r1] ; Copy string into buffer
	popr	#^m<r0,r1,r2,r3,r4,r5>	; Restore registers
	rsb

	.sbttl	SET_CURSOR	Create set cursor sequence
;---
;
;	SET_CURSOR
;
;	This routine generates the escape sequence for a
;	set cursor position and appends the string to a
;	given output buffer.  No buffer overflow checking
;	is done as it is assumed that the cursor will be
;	the first thing in the buffer.
;
; Inputs:
;
;	r5 = Address of:
;		0) # bytes currently in buffer
;		1) Offset to buffer (8)
;		2) Buffer (bufsiz bytes)
;	r0 = Line number
;	r1 = Column number
;
; Outputs:
;
;	r0-r3 destroyed.
;---

vt100ctl:
	.ascic	<esc><lb>'!UL;!UL'<vt100_sc> ; Convert to VT100 sequence

set_cursor:
	movzwl	(r5),r2			; Get current buffer size
	movab	8(r5)[r2],r3		; Address of next free byte
	case	scr$b_type(r6),type=b,-	; Case on terminal type
		<10$,-			; unknown
		20$,-			; VT05 needs 4 nulls
		30$,-			; VT52 needs bias
		40$>			; vt100 requires ; in middle

10$:	rsb				; Unknown type -- do nothing
;
; VT05 set cursor position
;
20$:	addw	#7,(r5)			; Length of string
	movb	#vt05_sc,(r3)+		; Set cursor function
	addb3	#cb,r0,(r3)+		; Line number
	clrl	(r3)+			; 4 nulls in between
	addb3	#cb,r1,(r3)+		; Column number
	rsb
;
; VT52 set cursor position
;
30$:	addw	#4,(r5)			; Length of string
	movw	#esc!<vt52_sc@8>,(r3)+	; Set cursor function
	addb3	#cb,r0,(r3)+		; Line number
	addb3	#cb,r1,(r3)+		; Column number
	rsb
;
; VT100 set cursor position
;
40$:	pushl	r3			; Push result buffer descriptor
	subl3	(r5),#bufsiz,-(sp)
	movab	vt100ctl,r3		; Address of FAO control string
	movzbl	(r3)+,r2
	movq	r2,-(sp)		; Push descriptor of control string
	movq	r0,-(sp)		; Push line and column numbers
	pushab	16(sp)			; Return result length here
	pushl	(sp)			; Address of result descriptor
	pushab	16(sp)			; Address of control string
	calls	#7,g^sys$fao		; Convert to ASCII characters
	addw	(sp),(r5)		; Length of appended string
	addl	#8,sp			; Pop result descriptor
	rsb

	.sbttl	OUTPUT		Write string to terminal
;---
;
;	OUTPUT
;
;	This routine writes the specified string to the
;	terminal without carriage control.
;
; Calling sequence:
;
;	Branch from CALLed routine
;
; Inputs:
;
;	r4 = Address of self-relative string descriptor
;
;---

output:
	tstw	(r4)			; Check if 0 length string
	bneq	10$			; branch if not
	movzwl	#1,r0			; success
	brb	30$
10$:	movq	(r4),-(sp)		; Move descriptor to stack
	addl	r4,4(sp)		; Relocate self-relative address
	movl	sp,r4			; Address of relocated descriptor
	movl	scr$l_buffer(r6),r3	; Are we buffering output?
	bneq	60$			; Branch if so
	tstl	scr$l_rtnaddr(r6)	; does user want to do output?
	bneq	40$			; branch if so

	movzwl	scr$w_chan(r6),r2	; set up channel for output
	tstb	scr$b_type(r6)		; Check terminal type
	beql	40$			; If unknown, use RMS
	movzwl	(r4),r0			; Get length of string
	$qiow_s	chan=r2,-		; Output to terminal
		efn=scr$l_efn(r6),-
		func=#io$_writevblk!io$m_noformat,-
		p1=@4(r4),P2=R0
30$:	ret
40$:	pushl	r4			; setup descriptor for call
	calls	#1,rms_output		; call for RMS output
50$:	ret				; give status to user
;
;	Buffer the data into the user output buffer
;
60$:	movq	(r3),r0			; Get descriptor of space in use
	subw3	r0,8(r3),r2		; Buffer space still available
	cmpw	(r4),r2			; Enough space for string?
	bgtru	70$			; Branch if out of room
	addw	(r4),(r3)		; Increment buffer space used
	movc	(r4),@4(r4),(r1)[r0]	; Move data into buffer
	incl	r0			; success
	ret
70$:	cmpw	(r4),8(r3)		; Enough space even if we flush?
	bgtru	80$			; branch if not
	pushl	#0			; flush current buffer contents
	calls	#1,w^scr$put_buffer	; write current buffer to screen
					; returns with buffer initialized
	movl	r3,scr$l_buffer(r6)	; reset back to initialized buffer
	brb	60$			; put new string in emptied buffer

80$:	movl	#lib$_scrbufovf,r0	; if not, signal buffer overflow
	ret

	.sbttl	RMS_OUTPUT		Write string via RMS
;---
;
;	RMS_OUTPUT
;
;	This routine writes the specified string to the
;	terminal using RMS.  If an RMS file is open for the
;	stream it will be used, else LIB$PUT_OUTPUT will be called.
;
; Calling sequence:
;
;	Call
;
; Inputs:
;
;	4(ap) = address of descriptor to output
;
; Outputs:
;
;	r0 = completion status
;	r1 = destroyed
;	String is output
;
;---

rms_output:
	.word	^m<r2,r3,r4,r5>		; save registers
	movl	scr$l_rtnaddr(r6),r0	; does user want to do output?
	beql	10$			; branch if not, we do it
	movzwl	scr$w_chan(r6),-(sp)	; push the channel
	pushl	scr$l_rtnarg(r6)	; user arguement
	pushal	4(sp)			; address of channel
	pushl	4(ap)			; address of descriptor
	pushal	scr$l_stream(r6)	; address of stream number
	calls	#4,(r0)			; Call user routine
	brb	40$

10$:	subl	#rab$c_bln,sp		; allocate room for rab
	movc5	#0,(r1),#0,#rab$c_bln,(sp); zero the rab
	movw	scr$w_isi(r6),rab$w_isi(sp); set internal RMS context
	bneq	20$			; branch if context present

	pushl	4(ap)			; push address of descriptor
	calls	#1,g^lib$put_output	; use common routine instead of RMS
	brb	40$			; now exit

20$:	movq	@4(ap),r0		; get the descriptor
	movb	#rab$c_bid,rab$b_bid(sp); set block id to rab
	movb	#rab$c_bln,rab$b_bln(sp); set length of rab
	movw	r0,rab$w_rsz(sp)	; set byte count
	movl	r1,rab$l_rbf(sp)	; set buffer address
	$put	rab=<(sp)>		; output the line

40$:	ret				; cleans up stack

	.sbttl	SCR$ERASE_PAGE	Erase to end of screen
;---
;
;	SCR$ERASE_PAGE
;
;	This routine causes the screen to be erased
;	from the specified position to the end of the
;	screen.  If the position is not specified, the
;	current screen position is assumed.
;
; Calling sequence:
;
;	CALL
;
; Inputs:
;
;	 (AP)	= Number of arguments
;	4(AP)	= Line number (optional)
;	8(AP)	= Column number (optional)
;
;	If no arguments are specified, the current cursor
;	position is assumed.
;
;---
scr$erase::
	.entry	scr$erase_page,regs

	movl	#scr$c_erase_page,r0	; Set function type
	bsbw	get_type		; Get terminal type
	tstl	scr$l_charmap(r6)	; Mapping active?
	beql	20$			; Branch if no mapping
	tstb	(ap)			; Any arguements?
	beql	10$			; Branch if not	
	movq	4(ap),scr$l_line(r6)	; Store new cursor position
10$:	movq	scr$l_line(r6),r0	; Fetch cursor position
	movzwl	scr$w_devpagsiz(r6),r2	; Erase to end of page
	movzwl	scr$w_devwidth(r6),r3	; ... and to last column
	movzbl	#^a/ /,r4		; Fill with spaces
	bsbw	fill_map		; Erase maps
	clrl	scr$l_attrmask(r6)	; Clear OR'd attribute mask
	movzbl	#1,r0			; Set success
	ret

20$:	movaq	b^erase_table[r1],r4	; Address of output string
	tstb	(ap)			; Any arguments specified?
	beql	30$			; Branch if not
	bsbw	init_buffer		; Initialize intermediate buffer
	movq	4(ap),r0		; Get coordinates
	bsbw	set_cursor		; Append set cursor sequence
	bsbw	append			; and append the function sequence
	movl	r5,r4			; Address of buffered string descriptor
30$:	brw	output			; Output the sequence

erase_table:				; erase to end of screen
	string	<"">				; Unknown
	string	<<vt05_eos><0><0><0><0>>	; vt05 (w/fill)
	string	<<esc><vt52_eos>>		; vt52
	string	<<esc><lb><vt100_eos>>		; vt100

	.sbttl	SCR$ERASE_LINE	Erase to end of line
;---
;
;	SCR$ERASE_LINE
;
;	This routine causes the screen to be erased
;	from the specified position to the end of the
;	line.  If the position is not specified, the
;	current screen position is assumed.
;
; Calling sequence:
;
;	CALL
;
; Inputs:
;
;	 (AP)	= Number of arguments
;	4(AP)	= Line number (optional)
;	8(AP)	= Column number (optional)
;
;	If no arguments are specified, the current cursor
;	position is assumed.
;
;---
	.entry	scr$erase_line,regs

	movl	#scr$c_erase_line,r0	; Set function type
	bsbw	get_type		; Get terminal type
	tstl	scr$l_charmap(r6)	; Mapping active?
	beql	20$			; Branch if no mapping
	tstb	(ap)			; Any arguements?
	beql	10$			; Branch if not	
	movq	4(ap),scr$l_line(r6)	; Store new cursor position
10$:	movq	scr$l_line(r6),r0	; Fetch cursor position
	movl	r0,r2			; Erase this line
	movzwl	scr$w_devwidth(r6),r3	; ... to last column
	movzbl	#^a/ /,r4		; Fill with spaces
	bsbw	fill_map		; Erase maps
	movzbl	#1,r0			; Set success
	ret

20$:	movaq	b^line_table[r1],r4	; Address of output string
	tstb	(ap)			; Any arguments specified?
	beql	30$			; Branch if not
	bsbw	init_buffer		; Initialize intermediate buffer
	movq	4(ap),r0		; Get coordinates
	bsbw	set_cursor		; Append set cursor sequence
	bsbw	append			; and append the function sequence
	movl	r5,r4			; Address of buffered string descriptor
30$:	brw	output			; Output the sequence

line_table:				; erase to end of line
	string	<"">				; Unknown - do nothing
	string	<<vt05_eol><0><0>>		; vt05 (w/fill)
	string	<<esc><vt52_eol>>		; vt52
	string	<<esc><lb><vt100_eol>>		; vt100

	.sbttl	SCR$SET_CURSOR	Set cursor position
;---
;
;	SCR$SET_CURSOR
;
;	This routine causes the cursor to be moved to
;	to the specified position.
;
; Calling sequence:
;
;	CALL
;
; Inputs:
;
;	0(AP)	= Number of arguements
;	4(AP)	= Line number
;	8(AP)	= Column number
;
;---
	.entry	scr$set_cursor,regs

	movl	#scr$c_set_cursor,r0	; Set function type
	bsbw	get_type		; Get terminal type
	tstl	scr$l_charmap(r6)	; Mapping active?
	beql	10$			; Branch if no mapping
	movq	4(ap),scr$l_line(r6)	; Store new cursor position
	movzbl	#1,r0			; Set success
	ret

10$:	bsbw	init_buffer		; Initialize intermediate buffer
	movq	4(ap),r0		; Get coordinates
	movq	r0,scr$l_line(r6)	; Store new cursor position
	bsbw	set_cursor		; Append set cursor sequence
	movl	r5,r4			; Address of buffered string descriptor
	brw	output			; Output the sequence

	.sbttl	SCR$MOVE_CURSOR		Move cursor to relative location
;---
;
;	SCR$MOVE_CURSOR
;
;	This routine causes the cursor to be moved to
;	a location relative to present location
;
; Calling sequence:
;
;	CALL
;
; Inputs:
;
;	0(AP)	= Number of arguements
;	4(AP)	= Signed line displacement
;	8(AP)	= Signed column displacement
;
;---
;	.entry	scr$move_cursor,regs
;
;	movl	#scr$c_move_cursor,r0	; Set function type
;	bsbw	get_type		; Get terminal type
;	tstl	scr$l_charmap(r6)	; Mapping active?
;	beql	10$			; Branch if no mapping
;	addl	4(ap),scr$l_line(r6)	; Update current line
;	addl	8(ap),scr$l_column(r6)	; Update current column
;	movzbl	#1,r0			; Set success
;	ret
;
;10$:	bsbw	init_buffer		; Initialize intermediate buffer
;	movq	4(ap),r0		; Get coordinates
;	addl	scr$l_line(r6),r0	; Convert relative line to absolute
;	addl	scr$l_column(r6),r1	; Convert relative column to absolute
;	movq	r0,scr$l_line(r6)	; Store new cursor position
;	bsbw	set_cursor		; Append set cursor sequence
;	movl	r5,r4			; Address of buffered string descriptor
;	brw	output			; Output the sequence

	.sbttl	SCR$SET_SCROLL	Establish a scrolling region
;---
;
;	SCR$SET_SCROLL
;
;	Establish a scrolling region by setting the internal
;	scrolling region parameters.  Issue the escape sequence
;	that establishes the region and preserves the cursor position
;
; Calling sequence:
;
;	CALL
;
; Inputs:
;
;	0(AP)	= Number of arguements
;	4(AP)	= First line of scrolling region
;	8(AP)	= Last line of scrolling region
;
;---
set_margins:
;
; VT100 sequence to <SAVE CURSOR><ESTABLISH SCROLLING REGION><RESTORE CURSOR>
	.ascic	<esc>'7'<esc><lb>'!UL;!UL'<vt100_sm><esc>'8'

	.entry	scr$set_scroll,regs

	movl	#scr$c_set_scroll,r0	; Set function type
	bsbw	get_type		; Get terminal type
	bbcc	#scr$v_scroll,scr$l_control(r6), 5$; clear scrolling region active
5$:	clrq	r0			; Assume terminal defaults
	cmpb	(ap),#2			; Any parameters?
	blss	10$			; Branch if not
	bbss	#scr$v_scroll,scr$l_control(r6),7$ ; set scrolling region active
7$:	movq	4(ap),r0		; Get new region limits
10$:	tstl	scr$l_charmap(r6)	; Mapping active?
	beql	30$			; Branch if no mapping
20$:	movzbl	#1,r0			; Set success
	ret

30$:	cmpb	scr$b_type(r6),#vt100	; Allow only if VT100 terminal
	bneq	20$			; Exit without action if not
	movq	r0,r1			; Save region limits
	bsbw	init_buffer		; Initialize intermediate buffer
	movq	r1,r0			; Restore region limits
	movzwl	(r5),r2			; Get current buffer size
	movab	8(r5)[r2],r3		; Address of next free byte
	pushl	r3			; Push result buffer descriptor
	subl3	(r5),#bufsiz,-(sp)
	movab	set_margins,r3		; Address of FAO control string
	movzbl	(r3)+,r2
	movq	r2,-(sp)		; Push descriptor of control string
	movq	r0,-(sp)		; Push top and bottom line numbers
	pushab	16(sp)			; Return result length here
	pushl	(sp)			; Address of result descriptor
	pushab	16(sp)			; Address of control string
	calls	#7,g^sys$fao		; Convert to ASCII characters
	addw	(sp),(r5)		; Length of appended string
	addl	#8,sp			; Pop result descriptor
	movl	r5,r4			; Address of buffered string descriptor
	tstl	scr$l_rtnaddr(r6)	; Check for user routine
	beql	40$			; branch if supplied
	movzwl	scr$w_chan(r6),r1	; Current channel
	$qiow_s	chan = r1, func = io$_writevblk!io$m_canctrlo, -
		efn=scr$l_efn(R6), -
		p1 = (sp) ,p2 = #0	; Cancel ^O
40$:	brw	output			; Output the sequence

	.sbttl	SCR$UP_SCROLL	Move cursor down, scrolling upward
;---
;
;	SCR$UP_SCROLL
;
;	This routine causes the cursor to be moved down
;	1 line to same column of the following line.
;	If the cursor was on the bottom line to begin with,
;	it stays where it was, but all the information
;	on the screen appears to move up one line.
;	The information that was on the top line of
;	the screen is lost and a blank line appears at
;	the bottom.
;
;	If a scrolling region is active (on a VT100 or in mapping)
;	then the logic above applies to the top and bottom lines
;	of the scrolling region rather than the top and bottom of
;	the screen.  If an UP_SCROLL is performed on the bottom
;	line of the screen, or a DOWN_SCROLL is performed on the
;	top line of the screen, while a scrolling region is active
;	then no screen movement takes place unless the top or bottom
;	line of the screen corresponds to the top or bottom line
;	of the scrolling region.
;
; Calling sequence:
;
;	CALL
;
; Inputs:
;
;	None
;
;---
lib$up_scroll::
	.entry	scr$up_scroll,regs

	movl	#scr$c_up_scroll,r0	; Set function type
	bsbw	get_type		; Get terminal type
	incl	scr$l_line(r6)		; Update cursor with down movement
	cmpw	scr$l_line(r6),	-	; Did cursor pass the ...
		scr$w_devpagsiz(r6)	;     ... the end of the page?
	blequ	10$			; Branch if not
	movzwl	scr$w_devpagsiz(r6), -	; Overflow, limit cursor to page
		scr$l_line(r6)
10$:	tstl	scr$l_charmap(r6)	; Mapping active?
	beql	30$			; Branch if no mapping
	tstl	scr$l_buffer(r6)	; Buffering enabled?
	beql	30$			; Branch if no buffering
20$:	movzbl	#1,r0			; Set success
	ret

30$:	movaq	b^upscroll_table[r1],r4	; Output string with 2 args
	brw	output

upscroll_table:				; down scroll
	string	<"">			; Unknown - do nothing
	string	<<lf><0><0><0>>		; VT05 - linefeed plus timing
	string	<<lf>>			; vt52 - linefeed
	string	<<lf>>			; vt100 - linefeed

	.sbttl	SCR$DOWN_SCROLL	Move cursor up, scrolling downward
;---
;
;	SCR$DOWN_SCROLL
;
;	This routine causes the cursor to be moved up
;	1 line to same column of the previous line.
;	If the cursor was on the top line to begin with,
;	it stays where it was, but all the information
;	on the screen appears to move down one line.
;	The information that was on the bottom line of
;	the screen is lost and a blank line appears at
;	the top.
;
;	If a scrolling region is active (on a VT100 or in mapping)
;	then the logic above applies to the top and bottom lines
;	of the scrolling region rather than the top and bottom of
;	the screen.  If an UP_SCROLL is performed on the bottom
;	line of the screen, or a DOWN_SCROLL is performed on the
;	top line of the screen, while a scrolling region is active
;	then no screen movement takes place unless the top or bottom
;	line of the screen corresponds to the top or bottom line
;	of the scrolling region.
;
; Calling sequence:
;
;	CALL
;
; Inputs:
;
;	None
;
;---
lib$down_scroll::
	.entry	scr$down_scroll,regs

	movl	#scr$c_down_scroll,r0	; Set function type
	bsbw	get_type		; Get terminal type
	decl	scr$l_line(r6)		; Update cursor with upcursor movement
	bgtr	10$			; Branch if ok
	movzbl	#1,scr$l_line(r6)	; Underflow -- limit cursor to line #1
10$:	tstl	scr$l_charmap(r6)	; Mapping active?
	beql	30$			; Branch if no mapping
	tstl	scr$l_buffer(r6)	; Buffering enabled?
	beql	30$			; Branch if no buffering
20$:	movzbl	#1,r0			; Set success
	ret

30$:	movaq	b^dscroll_table[r1],r4	; Output string with 2 args
	brw	output

dscroll_table:				; down scroll
	string	<"">				; Unknown - do nothing
	string	<<vt05_cup><0><0><0><0>>	; VT05 - do cursor up only
	string	<<esc><vt52_dwn>>		; vt52
	string	<<esc><vt100_dwn>>		; vt100

	.sbttl	SCR$PUT_SCREEN	Write message to terminal
;---
;
;	SCR$PUT_SCREEN
;
;	This routine is used to write messages to the
;	terminal.
;
; Calling sequence:
;
;	CALL
;
; Inputs:
;
;	4(AP) = Address of descriptor of output string
;	8(ap) = (Optional) Line number to start output (0 if current)
;	12(ap) = (Optional) Column number to start output (0 if current)
;	16(AP) = (Optional) attribute bitvector of 32 bits (longword)
;		If not specified, string is output using normal attributes.
;
;		The bits in the bitvector are:
;
;			0) Make string bold
;			1) Make string in reverse image
;			2) Make string blink
;			3) Make string underlined
;			4-31) Unused (must be zero)
;---
attrtable:
	.ascii	'1754'			; bold,reverse,blink,underscore

	.entry	scr$put_screen,regs

	movl	#scr$c_put_screen,r0	; Set function type
	bsbw	get_type		; Get terminal type
	tstl	scr$l_charmap(r6)	; Mapping active?
	beql	50$			; Branch if no mapping
	tstl	scr$l_buffer(r6)	; Buffering enabled?
	beql	50$			; Branch if no buffering

	movq	scr$l_line(r6),r0	; Assume current cursor
	cmpb	#1,(ap)			; Only one arguement?
	beql	10$			; Branch if yes -- use current cursor
	tstl	8(ap)			; Coordinates supplied?
	beql	10$			; Branch if not	 -- use current cursor
	movq	8(ap),r0		; Get new cursor position
	movq	r0,scr$l_line(r6)	; Replace stored cursor position
10$:	cmpw	r0,scr$w_devpagsiz(r6)	; Past bottom of screen?
	bgtr	40$			; Branch if so

	decl	r0			; Convert line to zero based
	mulw2	scr$w_devwidth(r6),r0	; Compute lines * width
	decl	r1			; Convert column to zero based
	addl3	r0,r1,r7		; Index = (line * width) + column
	movl	4(ap),r0		; Pass descriptor address
	jsb	g^lib$analyze_sdesc_r2	; Get length/address from descriptor
	blbc	r0,49$			; Branch if error detected
	addl3	r1,r7,r0		; compute ending index
	cmpl	r0,scr$l_area(r6)	; Compare to screen size
	bleq	20$			; Branch if OK
	movl	#lib$_scrbufovf,r0	; Signal buffer overflow
	ret

20$:	addl	r1,scr$l_column(r6)	; Column = column + transfer size
	movc3	r1,(r2), -		; Copy string to buffer
		@scr$l_charmap(r6)[r7]  ; Note -- R0 now equals zero
	cmpb	#4,(ap)			; Attributes specified?
	bneq	30$			; Branch if not
	bicl3	scr$l_devchar(r6),16(ap),r0 ; Extract supported attributes
30$:	bisl2	r0,scr$l_attrmask(r6)	; Remember all attributes encountered
	beql	40$			; Branch if no attributes ever seen
	movc5	#0,(r1),r0,@4(ap), -	; Set the attributes
		@scr$l_attrmap(r6)[r7]
40$:	movzbl	#1,r0			; Set success
49$:	ret

50$:	cmpb	(ap),#1			; Check if only one argument
	bgtru	60$			; Branch if not
	movl	4(ap),r0		; Pass descriptor address
	jsb	g^lib$analyze_sdesc_r2	; Get length/address from descriptor
	blbc	r0,49$			; Branch if error detected
	movq	r1,-(sp)		; Copy descriptor to stack
	subl	sp,4(sp)		; and make self-relative
	movl	sp,r4			; Address of self-relative desc.
	brw	output

60$:	bsbw	init_buffer		; Initialize intermediate buffer
	clrl	-(sp)			; Preset flag to "no attributes set"
	cmpb	(ap),#4			; Attribute vector given?
	blssu	90$			; branch if not
	cmpl	r1,#vt100		; VT100?
	bneq	90$			; if not, ignore attributes
	movl	16(ap),r1		; Get bitvector
	bitl	r1,#^c<15>		; Test MBZ bits
	bneq	120$			; branch if undefined bits set
	bitl	r1,#15			; Check if any attributes on
	beql	90$			; If none, treat as normal output
	movl	#1,(sp)			; Indicate "attributes set"
	subl	#16,sp			; Allocate buffer (4 attrs max)
	movl	sp,r3			; Address of buffer
	movw	#esc!<lb@8>,(r3)+	; Escape, left bracket
	clrl	r0			; Init index
70$:	bbc	r0,r1,80$		; Branch if bit not set
	movb	attrtable[r0],(r3)+	; Move VT100 attribute code in
	movb	#^a';',(r3)+		; and semi-colon following
80$:	aoblss	#4,r0,70$		; Loop until 4 bits are tested
	movb	#vt100_sgr,-1(r3)	; Select graphic rendition
	subl	sp,r3			; Calculate length of string
	pushl	#8			; Offset to string
	pushl	r3			; Length of string
	movl	sp,r4			; Address of sequence descriptor
	bsbw	append			; Insert into buffer
	addl	#16+8,sp		; Pop scratch area

90$:	tstl	8(ap)			; Coordinates given?
	beql	100$			; branch if not
	movq	8(ap),r0		; Get coordinates
	bsbw	set_cursor		; Insert set cursor function

100$:	movl	4(ap),r0		; Pass descriptor address
	jsb	g^lib$analyze_sdesc_r2	; Get length/address from descriptor
	blbc	r0,99$			; Branch if error detected
	movq	r1,-(sp)		; Copy descriptor to stack
	subl	sp,4(sp)		; and make self-relative
	movl	sp,r4			; Address of self-relative desc.
	bsbw	append			; Append user string

	blbc	8(sp),110$		; Branch if no attributes set
	movab	b^vt100_off,r4		; String to turn attributes off
	bsbw	append			; Append final string

110$:	movl	r5,r4			; Address of intermediate buffer
	brw	output			; Output the string

99$:	ret				; Return with error status

120$:	brw	invarg			; Invalid argument

vt100_off:
	string	<<esc><lb>'0m'>		; Turn off graphic rendition for VT100

	.sbttl	SCR$PUT_LINE	Output to screen in line mode
;---
;
;	SCR$PUT_LINE
;
;	This routine is used to write messages to the
;	terminal followed by cursor movement sequences
;
; Calling sequence:
;
;	CALL
;
; Inputs:
;
;	4(AP) = Address of descriptor of output string
;	8(ap) = (Optional) Signed number of lines to advance after output
;	12(AP) = (Optional) of attribute bitvector of 32 bits (longword)
;		If not specified, string is output using normal attributes.
;
;		The bits in the bitvector are:
;
;			Same as SCR$PUT_SCREEN
;---

	.entry	lib$put_line,^M<>
	movq	#1, -(sp)		; Set up default arguments
	cmpb	(AP),#2			; Test for optional args
	blequ	10$			; 0, 1 or 2 args
	movl	12(AP),r0		; 3rd arg omitted?
	beql	20$			; yes
	movl	(r0),4(sp)		; no, get attributes
	brb	20$
10$:	blssu	30$			; 0 or 1 args?
20$:	movl	8(ap),r0		; 2nd arg omitted?
	beql	30$			; yes
	movl	(r0),(sp)		; no, get lines to advance
30$:	tstb	(AP)			; 0 args?
	beql	40$			; yes, error
	pushl	4(AP)			; Get output string descriptor
	calls	#3,b^scr$put_line	; Call routine
	ret
40$:	brw	invarg			; error

	.entry	scr$put_line,regs

	movl	#scr$c_put_line,r0	; Set function type
	bsbw	get_type		; Get terminal type
	movl	r1,r4			; Hang on to terminal type

	tstb	(ap)			; Any arguements?
	beql	70$			; Branch if none

	pushl	#0			; Make room for attribute vector
	cmpb	(ap),#3			; Too many arguements?
	bgtru	70$			; Branch if so
	blssu	10$			; Branch if no attributes
	movl	12(ap),(sp)		; Stack the attribute bitvector

10$:	clrq	-(sp)			; Stack column,line = 0,0
	pushl	4(ap)			; Push the descriptor address
	calls	#4,scr$put_screen	; Call regular routine
	blbc	r0,60$			; Branch if failed

	movl	#1,r5			; Assume no line count
	cmpb	(ap),#1			; No line count supplied?
	beql	20$			; Branch if not
	movl	8(ap),r5		; Fetch line count

20$:	moval	scr$up_scroll,r2	; Assume up scroll routine
	tstl	r5			; Any scrolling to do?
	beql	40$			; Branch if not
	bgeq	30$			; Branch if positive
	mnegl	r5,r5			; Neg. scrolling -- make it positive
	moval	scr$down_scroll,r2	; ... and set to down scroll routine

30$:	calls	#0,(r2)			; Call the scrolling routine
	blbc	r0,60$			; Exit if error
	sobgtr	r5,20$			; Loop till done

	movl	#1,scr$l_column(r6)	; Reset cursor to column 1
	tstl	r4			; Known terminal type?
	bnequ	40$			; Branch yes -- <cr> required
	tstl	scr$l_buffer(r6)	; Buffering enabled?
	bnequ	50$			; Branch yes -- no <cr> required

40$:	movaq	b^cr_table[r4],r4	; Output string with 2 args
	brw	output

50$:	movl	#1,r0			; Indicate success
60$:	ret

70$:	brw	invarg

cr_table:					; Carriage returns
	string	<"">				; Unknown
	string	<<cr>>				; VT05
	string	<<cr>>				; vt52
	string	<<cr>>				; vt100

	.sbttl	SCR$GET_SCREEN	Read input string from terminal
;---
;
;	SCR$GET_SCREEN
;
;	This routine accepts input from the terminal into
;	a user specified buffer.  An optional prompt string
;	may be given.
;
; Calling sequence:
;
;	CALL
;
; Inputs:
;
;	4(AP) = Address of buffer descriptor
;	8(AP) = Address of prompt descriptor (optional)
;
;---
lib$get_screen::
	.entry	scr$get_screen,regs

	movl	#scr$c_get_screen,r0	; Set function type
	bsbw	get_type		; Get terminal type

	callg	(ap),g^lib$get_input	; Read terminal input
	ret

	.sbttl	SCR$SET_BUFFER, Setup display buffering
;---
;
;	SCR$SET_BUFFER
;
;	This routine is called to establish a buffer to be
;	used to hold terminal output rather than immediately
;	writing the output to SYS$OUTPUT.  It is also called
;	to turn off the buffering mode.
;
; Calling sequence:
;
;	CALL
;
; Inputs:
;
;	4(AP) = Address of descriptor of buffer,
;		0 to turn off buffering mode.
;
;
; Outputs:
;
;	The buffer address is established such that all screen
;	output will be appended to the end of the buffer.  The
;	first 8 bytes of the buffer will be used to hold the
;	descriptor of the actual buffer space currently in use.
;
;	8(AP) = Address of location containing address of current
;		buffer descriptor. (Optional)
;
;---
lib$set_buffer::
	.entry	scr$set_buffer,regs

	mnegl	#1,r0			; suppress calling foreign terminal code
	bsbw	get_type		; make sure there is a current output
	movzbl	(ap),r0			; get argument number
	beql	40$			; branch if zero arguments
	cmpb	r0,#1			; one argument?
	beql	10$			; yes
;
;	If requested, give caller address of previous buffer
;
	cmpb	r0,#2			; two arguments?
	bneq	40$			; branch if not two arguments
	tstl	8(ap)			; save current buffer addr?
	beql	10$			; no (0 address)
	movl	scr$l_buffer(r6),@8(ap)	; Save current descriptor addr
;
;	Setup specified buffer
;
10$:	clrl	r2			; Initially no buffer address
	movl	4(ap),r0		; Get buffer descriptor address
	beql	20$			; Branch if canceling
	jsb	g^lib$analyze_sdesc_r2	; Get length in R1, pointer in R2
	blbc	r0,35$			; Return if error
	cmpw	r1,#12			; Enough room for descriptor?
	blequ	50$			; Branch if not enough room
	clrl	(r2)			; Initialize length used to zero
	movab	12(r2),4(r2)		; Set address of buffer space
	movzwl	r1,8(r2)		; Set length of total buffer-overhead
	subl	#12,8(r2)
;
;	Remember address of current buffer
;
20$:	movl	r2,scr$l_buffer(r6)	; Save address of buffer

30$:	movl	#1,r0			; Success
35$:	ret
40$:	brw	invarg			; return invalid arguements error
50$:	movl	#lib$_scrbufovf,r0	; Buffer overflow
	ret

	.sbttl	SCR$PUT_BUFFER	Output current buffer to previous buffer
;---
;
;	This routine is the converse of scr$set_buffer.
;	It puts the contents of the current buffer to
;	another buffer or the screen if no buffer is given.
;
; Inputs:
;
;	4(ap) = Address of the previous buffer to put current
;		buffer into; if not specified or zero, put the
;		current buffer to the screen.
;
; Outputs:
;
;	The current buffer is output and reinitialized to empty.
;	if 4(ap) is nonzero, it is set to the new current buffer.
;---
	.entry	lib$put_buffer,0
	cmpb	(ap),#1			; How many arguments?
	blssu	10$			; None
	bgtru	20$			; 2 or more, error
	tstl	4(ap)			; Omitted by reference?
	bneq	30$
10$:	calls	#0,b^scr$put_buffer	; Put the buffer w/o arguments
	ret
20$:	brw	invarg			; Give invalid arguments error

30$:	pushl	@4(ap)			; get actual address of buffer
	calls	#1,b^scr$put_buffer	; put the buffer
	ret

	.entry	scr$put_buffer,regs

	mnegl	#1,r0			; suppress calling foreign terminal code
	bsbw	get_type		; make sure there is a current output

	movl	#1,r0			; Assume success
	clrl	r2			; Preset to null argument
	tstb	(ap)			; Test number of arguments
	beql	20$			; Branch if none specified
	movl	4(ap),r2		; Get value of first argument
20$:	movl	scr$l_buffer(r6),r3	; Get address of current buffer
	movl	r2,scr$l_buffer(r6)	; set argument to new buffer
	tstl	r3			; Was a buffer active?
	beql	50$			; Branch if no buffering active

	tstl	scr$l_charmap(r6)	; Mapping active?
	beql	40$			; Branch if not
	tstl	r2			; Was a new buffer supplied?
	bnequ	30$			; Bypass output if still buffering
	bsbw	put_map			; Do implied output
30$:	ret

40$:	movq	(r3),-(sp)		; Make descriptor of buffer contents
	clrl	(r3)			; and initialize it to empty again
	pushl	sp
	calls	#1,w^scr$put_screen	; output to prev. buffer or screen (0)
50$:	ret

	.sbttl	SCR$SCREEN_INFO	Obtain screen information
;---
;
;	SCR$SCREEN_INFO
;
;	Obtain information about the current output screen.
;	This returns the information in a user-specified buffer.
;
; Calling sequence:
;
;	CALL
;
; Inputs:
;
;	4(AP) = Address of return buffer.
;
; Implicit inputs:
;
;	devtype		- Device type ($DCDEF)
;	devwidth	- Line width in characters
;	devpagsiz	- Lines on screen
;
; Outputs:
;
;	The return buffer is filled with information about
;	the current screen (see $scrdef).
;
;---
	.entry	lib$screen_info,0

	subl2	#scr$k_length,sp		;allocate buf on stack
	pushl	sp				;push buffer address
	calls	#1,w^scr$screen_info
	blbc	r0,eret				; return failure status
	tstb	(ap)				; arg num equal 0?
	beql	success				; branch if yes (default)
	movl	#1,r0
test:	tstl	(ap)[r0]			; parameter given?
	beql	next				; branch if not given
	case	r0,type=l,-
		<success,flgs,dtype,wdth,pgsz>

next:	aobleq	(ap),r0,test			; increment offset
						; and branch if not done
success:
	movl	#1,r0
eret:	ret

flgs:	movl	scr$l_flags(sp),@4(ap)		; return value
	brb	next
dtype:	movb	scr$b_devtype(sp),@8(ap)	; return value
	brb	next
wdth:	movw	scr$w_width(sp),@12(ap)		; return value
	brb	next
pgsz:	movw	scr$w_pagesize(sp),@16(ap)	; return value
	brb	next

	.entry	scr$screen_info,regs

	mnegl	#1,r0			; suppress calling foreign terminal code
	bsbw	get_type		; Get terminal type
	movl	4(ap),r0		; Get address of buffer
	clrl	scr$l_flags(r0)		; Pre-zero flags longword
	tstl	r1			; Check if type 0 (unknown)
	beql	10$			; Branch if so
	cmpl	r1,#vtforeign		; Is this a foreign terminal?
	beql	10$			; Branch if so
	bisl	#scr$m_screen,scr$l_flags(r0)	; Indicate non-scrolling
10$:	movb	scr$b_devtyp(r6),scr$b_devtype(r0)	; Return device type
	movw	scr$w_devwidth(r6),scr$w_width(r0)	; Return line width
	movw	scr$w_devpagsiz(r6),scr$w_pagesize(r0)	; Return lines/page
	extzv	#tt2$v_ansicrt,#6,scr$l_devdepnd2(r6),r2; Get devdepnd2 bits
	insv	r2,#scr$v_ansicrt,#6,scr$l_flags(r0)	; Return bits
	brb	success			; return unconditional success

; Assumes for above EXTZV

assume	tt2$v_ansicrt  EQ 24
assume	tt2$v_regis EQ 25
assume	tt2$v_block EQ 26
assume	tt2$v_avo   EQ 27
assume  tt2$v_edit  EQ 28
assume  tt2$v_deccrt   EQ 29

assume	scr$v_ansicrt  EQ 1
assume	scr$v_regis EQ 2
assume	scr$v_block EQ 3
assume	scr$v_avo   EQ 4
assume	scr$v_edit  EQ 5
assume  scr$v_deccrt EQ 6

	.sbttl	SCR$SET_OUTPUT	Establish a terminal/buffer for output
;---
;
;	SCR$SET_OUTPUT
;
;	Set up for a device to recieve output, and if the first time
;	obtain device characteristics.
;
; Calling sequence:
;
;	CALL
;
; Inputs:
;
;	04(AP) = stream number
;	08(AP) = optional address of descriptor of file specification
;	12(AP) = optional output routine to call for output
;	16(AP) = optional argument to pass to output routine
;	20(AP) = optional address of longword to receive previous stream
;
; Outputs:
;
;	If this is the first call for the stream then a screen
;	control block is allocated, a channel is assigned, device
;	characteristics are obtained. If it is an unknown device 
;	then the channel is deassigned (no QIO output).  If a file
;	specification is present and no user output routine is declared
;	then the file is opened via RMS.
;
;	At output time the user supplied routine, if present, will be
;	called with the following parameters:
;
;		AP ->	4
;			address of stream number
;			address of descriptor to output
;			address of channel number (channel = zero if none)
;			optional user supplied argument
;
;---
	.entry	-
lib$set_output,	0
	movzbl	(ap),r0			; get number of arguments in call
10$:	pushl	(ap)[r0]		; move the argument over
	sobgtr	r0,10$			; loop thru all args, including number
	movl	@(sp)+,-(sp)		; make stream by value
	calls	(ap),b^scr$set_output	; now use by value routine
	ret

	.entry	-
scr$set_output,	regs

	movl	scr$l_curoutput,r6	; Get pointer to current output stream
	beql	20$			; branch if none
	cmpl	4(ap),scr$l_stream(r6)	; is requested stream the current one?
	bneq	20$			; branch if no -- search for it
10$:	brw	100$			; stream found -- branch to exit
20$:	movl	scr$l_flinkhead,r6	; get known terminals list to search
	beql	40$			; branch if this is first call
30$:	cmpl	4(ap),scr$l_stream(r6)	; is this the stream?
	beql	10$			; branch if yes
	movl	scr$l_flink(r6),r6	; link to next unit block
	bneq	30$			; branch to continue the search
;
; Come here if first time call for stream
;
40$:	tstl	scr$exitblock+4		; Has handler been declared?
	bneq	45$			; branch if so
	movab	exit_handler,scr$exitblock+4 ; load routine address
	movab	scr$l_exitsts,scr$exitblock+12; addr of longword to rcv status
	$DCLEXH_S desblk = scr$exitblock ; establish handler
	blbc	r0,50$			; exit if error

45$:	pushl	#scr$c_size		; set up size of request for GET_VM
	moval	-(sp),-(sp)		; set up cell to receive addr of memory
	pushal	8(sp)			; set up pointer to size to allocate
	calls	#2,g^lib$get_vm		; get the memory
	blbs	r0,60$			; branch if successful
50$:	brw	120$			; exit with error

60$:	popl	r6			; get address of terminal control block
	movc5	#0,(sp),#0,(sp),(r6)	; zero the block
	movl	scr$l_flinkhead,scr$l_flink(r6) ;set forward pointer
	movl	r6,scr$l_flinkhead	; set new link pointer
	movl	4(ap),scr$l_stream(r6)	; set block to represent this channel
	bsbw	130$			; set up optional arguments
;
;assign a channel -- use SYS$OUTPUT if no filespec provided
;
	movab	sysoutput,r2		; get address of default file spec
	movzbl	(r2)+,r1		; get size of default file spec
	cmpb	(ap),#2			; file name parameter present?
	blssu	70$			; branch if not
	tstl	8(ap)			; null parameter?
	beql	70$			; branch if null
	movl	8(ap),r0		; Pass descriptor address
	jsb	g^lib$analyze_sdesc_r2	; Get length/address from descriptor
	blbc	r0,50$			; Branch if error detected
70$:	movq	r1,-(sp)		; push the descriptor
	pushaw	scr$w_chan(r6)		; address to receive channel
	pushab	4(sp)			; set up pointer to descriptor
	calls	#2,g^lib$assign		; assign a channel to sys$output
	blbc	r0,50$			; branch if channel assignment failure

	bsbw	get_char		; set up necessary characteristics
	tstl	r1			; unknown terminal type?
	beql	80$			; branch if unknown
	pushal	scr$l_efn(r6)		; Allocate event flag number to use
	calls	#1,g^lib$get_ef		;  during QIOs.
	blbc	r0,50$			; Return if failure
	brw	110$			; exit sucessfully
;
; Here if unknown terminal or not a terminal -- deassign QIO channel
;
80$:	$dassgn_s chan=<scr$w_chan(r6)>	; deassign the channel
	blbc	r0,120$			; return if error
	clrw	scr$w_chan(r6)		; clear channel number
	tstl	scr$l_rtnaddr(r6)	; user routine supplied?
	bneq	90$			; branch if so -- don't open file
	cmpb	(ap),#2			; file name parameter present?
	blssu	90$			; branch if not (use LIB$PUT_OUTPUT)
	tstl	8(ap)			; null parameter?
	beql	90$			; branch if null

	movl	8(ap),r0		; Pass descriptor address
	jsb	g^lib$analyze_sdesc_r2	; Get length/address from descriptor
	blbc	r0,120$			; branch if error
	bsbw	create			; create the file
	blbc	r0,120$			; branch if create error
;
; Calculate memory required for the map buffers necessary to emulate
; advanced VDT features when outputing to hardcopy, disk, or, limited VDT's
;
90$:	clrl	r7			; prepare to recieve word value
	mulw3	scr$w_devpagsiz(r6), -	; length * width = area
		scr$w_devwidth(r6),r7
	ashl	#-3,r7,r2		; divide by 8, bit map size in bytes
	pushaw	1(r2)[r7]		; push (bitmapsize  + 1) + (area * 2)
;
; Allocate and initialize required memory
;
	moval	-(sp),-(sp)		; set up cell to receive addr of memory
	pushal	8(sp)			; set up pointer to size to allocate
	calls	#2,g^lib$get_vm		; get the memory
	blbc	r0,120$			; return if error
	assume	scr$l_charmap eq scr$l_area+4
	assume	scr$l_attrmap eq scr$l_charmap+4
	assume	scr$l_modfmap eq scr$l_attrmap+4
	assume	scr$l_line eq scr$l_modfmap+4
	assume	scr$l_column eq scr$l_line+4
; Following MOVC5's preserve R1 !
	moval	scr$l_area(r6),r1	; get address of control area
	movl	r7,(r1)+		; store map area size
	movl	(sp),(r1)+		; store address of character map
	movc5	#0,(r1),#^a/ /,r7,@(sp)+; space fill char map and fix stack
	movl	r3,(r1)+		; store address of attribute map
	movab	(r3)[r7],(r1)+		; store address of modified map
	subl2	r7,(sp)			; compute remainder 
	movc5	#0,(r1),#0,(sp)+,(r3)	; zero attrmap, modfmap, and fix stack
	incl	(r1)+			; set line = 1
	incl	(r1)+			; set column = 1
	brb	110$			; return success

100$:	bsbb	130$			; set up optional arguments
110$:	movl	#1,r0			; set success
120$:	ret				; return  (this cleans up stack)
130$:	cmpb	(ap),#5			; was previous stream requested?
	blss	135$			; branch if not
	tstl	20(ap)			; null parameter?
	beql	135$			; branch if so
	clrl	@20(ap)			; assume no previous
	movl	scr$l_curoutput,r0	; get current output
	beql	135$			; branch if none
	movl	scr$l_stream(r0),@20(ap); set previous output stream
135$:	movl	r6,scr$l_curoutput	; establish this channel as current
	clrq	r0			; clear work regs
	cmpb	#3,(ap)			; is an output routine specified?
	bgtru	140$			; branch if no output routine or arg
	movl	12(ap),r0		; get address of output routine
	cmpb	#4,(ap)			; is an output arg specified?
	bgtru	139$			; branch if no output arg
	movl	16(ap),r1		; get output argument
139$:	movq	r0,scr$q_rtninfo(r6)	; save for later calls
140$:	rsb

	.sbttl	CREATE		Create an output file via RMS
;---
;
;	CREATE
;
;	Create an output file via RMS.  If no filespec is supplied
;	the SYS$OUTPUT is used.
;
; Calling sequence:
;
;	BSB
;
; Inputs:
;
;	R1 = length of file specification
;	R2 = address of file specification
;	R6 = address of screen control block
;
; Outputs:
;
;	The file is created and connected to.
;	The ISI and IFI are stored in the control block
;
;---

create:	
	subl	#fab$c_bln+rab$c_bln,sp		; allocate room for fab and rab
	pushr	#^m<r1,r2>			; save registers
	movc5	#0,(sp),#0,#fab$c_bln+rab$c_bln,8(sp); zero the fab and rab
	popr	#^m<r1,r2>			; restore registers
	movb	#fab$c_bid,fab$b_bid(sp)	; set block id to fab
	movb	#fab$c_bln,fab$b_bln(sp)	; set length of fab
	movb	r1,fab$b_fns(sp)		; set size of filespec
	movl	r2,fab$l_fna(sp)		; set address of filespec
	bbss	#fab$v_sqo,fab$l_fop(sp),10$	; sequential access only
10$:	movb	#fab$c_var,fab$b_rfm(sp)	; variable length records
	bbss	#fab$v_cr,fab$b_rat(sp),20$	; automatic carriage control
20$:	$create	fab=<(sp)>			; create the file
	blbc	r0,30$				; exit if error
;
; Connect to file via RMS and hang onto ISI for later calls
;
	movb	#rab$c_bid,fab$c_bln+rab$b_bid(sp); set block id to rab
	movb	#rab$c_bln,fab$c_bln+rab$b_bln(sp); set length of rab
	movl	sp,fab$c_bln+rab$l_fab(sp)	; set address of fab
	$connect rab=<fab$c_bln(sp)>		; connect to the file
	movw	fab$w_ifi(sp),scr$w_ifi(r6)	; store IFI
	movw	fab$c_bln+rab$w_isi(sp),scr$w_isi(r6); store ISI
30$:	addl2	#fab$c_bln+rab$c_bln,sp		; deallocate fab and rab
	rsb



	.sbttl	SCR$STOP_OUTPUT		Deaccess a terminal established for output
;---
;
;	SCR$STOP_OUTPUT
;
;	Deaccess a stream established for output.
;
; Calling sequence:
;
;	CALL
;
; Inputs:
;
;	None
;
; Outputs:
;
;	The channel or isi is deassigned.
;
;---

lib$stop_output::

	.entry	-
scr$stop_output,regs

	movl	#1,r0			; assume channel not assigned
	assume	scr$l_flink eq 0
	movab	scr$l_flinkhead,r6	; get known terminals list to search
10$:	movl	r6,r5			; update pointer to next one
	movl	scr$l_flink(r5),r6	; get pointer to next in list
	bneq	20$			; branch if found
15$:	brw	80$			; end of list -- exit
20$:	cmpl	scr$l_curoutput,r6	; is this the stream?
	bneq	10$			; branch if not
;
; found the stream
;
	movl	scr$l_flink(r6),scr$l_flink(r5) ; remove block from queue
	tstw	scr$w_chan(r6)		; is there a channel?
	beql	30$			; branch if none
	clrl	scr$l_buffer(r6)	; turn off buffering if active
	bbcc	#scr$v_scroll,scr$l_control(r6),25$ ; if scrolling active
	calls	#0,scr$set_scroll	; ...then turn it off
25$:	$dassgn_s chan=<scr$w_chan(r6)>	; deassign the channel
	pushal	scr$l_efn(R6)		; Deallocate the EFN
	calls	#1,g^lib$free_ef	; Ignore any errors

30$:	movzwl	scr$w_ifi(r6),r1	; get the file IFI
	beql	40$			; branch if no open file
	subl	#fab$c_bln,sp		; allocate room for fab (cleanup @ret)
	movc5	#0,(r1),#0,#fab$c_bln,(sp); zero the fab (r1 preserved)
	movw	r1,fab$w_ifi(sp)	; set internal RMS context
	movb	#fab$c_bid,fab$b_bid(sp); set block id to fab
	movb	#fab$c_bln,fab$b_bln(sp); set length of fab
	$close	fab=<(sp)>		; close the file

40$:	pushl	r0			; save status of DEASSIGN or CLOSE
	tstl	scr$l_charmap(r6)	; was a charmap allocated?
	beql	50$			; branch if not
	pushal	scr$l_charmap(r6)	; address of cell containing base
	pushal	scr$l_area(r6)		; address of cell containing size
	calls	#2,g^lib$free_vm	; free the memory
	blbc	r0,70$			; branch if error

50$:	tstl	scr$l_attrmap(r6)	; was an attrmap allocated?
	beql	60$			; branch if not
	pushal	scr$l_attrmap(r6)	; address of cell containing base
	pushal	scr$l_area(r6)		; address of cell containing size
	calls	#2,g^lib$free_vm	; free the memory
	blbc	r0,70$			; branch if error

60$:	pushl	#scr$c_size		; set up size of request for FREE_VM
	pushl	r6			; set up address of area to free
	pushl	sp			; set address of base_address
	pushal	8(sp)			; set up pointer to size to free
	calls	#2,g^lib$free_vm	; free the memory
	addl	#8,sp			; cleanup stack

70$:	blbs	(sp),80$		; branch if $CLOSE succeeded
	movl	(sp)+,r0		; use status from $CLOSE
80$:	clrl	scr$l_curoutput		; indicate no current output stream
	ret				; return  (this cleans up stack)

	.sbttl	PUT_MAP		Output virtual screen map
;---
;
;	PUT_MAP
;
;	This routine processes the internal screen, attribute, and
;	modified maps and calls other screen package routines to
;	output the results.
;
; Inputs:
;
;	r6 = Screen control block address
;
; Outputs:
;
;	r0-r1 destroyed.
;
; Errors:
;
;	If any errors are encountered a RET to the caller is executed.
;---

put_map:
	pushr	#^m<r2,r3,r4,r5,r7,r8,r9,r10,r11>
	
	clrl	scr$l_workmask		; initialize working attribute mask
	movzwl	scr$w_devwidth(r6),r7	; fetch device width
	movl	r7,r11			; copy same
	movl	scr$l_charmap(r6),r8	; get address of character map
	movl	scr$l_area(r6),r9	; get size of map
	movab	(r8)[r9],r10		; store end of data
	clrq	-(sp)			; create descriptor
;
; find first displayable character
;
10$:	subl3	r8,r10,r4		; compute bytes remaining
	blss	120$			; exit successfully
	skpc	#^a/ /,r4,(r8)		; find first non-space character
	movl	r1,r3			; save address of character

20$:	subl3	r8,r3,r2		; compute bytes to be skipped
	divl2	r11,r2			; compute number of blank lines
	beql	70$			; branch if no blank lines

30$:	cmpl	r3,r10			; is remainder of page blank?
	blssu	50$			; branch no
	cmpl	#1,r2			; exactly one blank line?
	beql	50$			; branch yes
	
	tstl	scr$l_attrmask(r6)	; attributes active?
	beql	40$			; branch if not
	clrl	r7			; set line length to 0
	skpc	#0,r4,(r8)[r9]		; any attributes in rest of map?
	bneq	50$			; branch yes

40$:	movl	#1,(sp)			; set string length
	moval	#12,4(sp)		; address of string (<FF>)
	clrl	r10			; force exit on next pass
	brb	100$			; branch to output routine
	
50$:	clrq	(sp)			; initialize descriptor
	tstl	scr$l_attrmask(r6)	; attributes active?
	beql	60$			; branch if not
	skpc	#0,r11,(r8)[r9]		; scan this line
	bneq	80$			; this line cannot be skipped

60$:	pushl	sp			; push address of descriptor
	calls	#1,rms_output		; output blank line
	blbc	r0,120$			; exit if error
	addl	r11,r8			; update address of data
	sobgtr	r2,60$			; loop as necessary

70$:	bsbw	trim			; trim trailing blanks
	tstl	scr$l_attrmask(r6)	; do we need to scan for attributes?
	beql	90$			; branch if not
	skpc	#0,r11,(r8)[r9]		; scan this line
	beql	90$			; branch if no attributes in line

80$:	bsbw	do_attr			; handle the attributes
	brb	110$			; output already done

90$:	movq	r7,(sp)			; load descriptor
100$:	pushl	sp			; push descriptor address
	calls	#1,rms_output		; call output routine
110$:	addl	r11,r8			; update address of data
	movl	r11,r7			; reset length of data
	brw	10$			; loop till done

120$:	movl	scr$l_workmask,scr$l_attrmask(r6) ; reset attribute mask
	clrq	(sp)+			; remove descriptor
	popr	#^m<r2,r3,r4,r5,r7,r8,r9,r10,r11>
	rsb

	.sbttl	TRIM		Trim trailing blanks
;---
;
;	TRIM
;
;	Trim trailing blanks from a line
;
; Inputs:
;
;	r6 = Screen control block address
;	r7,r8 = descriptor of line
;
; Outputs:
;
;	r0-r2 destroyed.
;
;---

trim:
	movq	r7,r0			; copy length and address of line
10$:	locc	#^a/ /,r0,(r1)		; find first space
	movl	r1,r2			; save address of remainder
	skpc	#^a/ /,r0,(r1)		; find first non-space
	bneq	10$			; branch if found
	subl3	r8,r2,r7		; compute size of truncated line
	rsb


	.sbttl	DO_ATTR		Handle bold and underlining
;---
;
;	DO_ATTR
;
;	This handles lines containing underlining or bolding.
;	A larger line is built containing concatenated copies of
;	the original line with imbedded <CR>'s.  Bold characters
;	are overprinted, underlined characters are converted to
;	"_" then overprinted.
;
; Inputs:
;
;	r0	= bytes remaining in attribute line
;	r1	= address of first non-zero attribute byte
;	r6	= screen control block address
;	r7,r8	= descriptor of data line
;	r9	= size of map
;	r11	= device width
;
; Outputs:
;
;	r0-r5 destroyed.
;
;---

do_attr:
	moval	4(r11)[r11],r2		; compute (4 + (5 * devwidth))
	subl2	r2,sp			; make a stack buffer
	movq	r0,-(sp)		; save r0,r1
	movc5	#0,(r1),#^a/ /,r2,8(sp)	; space fill the buffer
	movc3	r7,(r8),8(sp)		; copy trimmed data line
	movq	(sp)+,r0		; restore r0,r1
	movb	#13,(r3)+		; store a <CR>
	movab	1(r3)[r11],r4		; compute address of bold buffer
	mnegl	#1,-(sp)		; set bold index
	mnegl	#1,-(sp)		; set underline index
	brb	20$			; first scan already done

5$:	decl	r0			; decrement bytes remaining
	incl	r1			; advance scan pointer
10$:	skpc	#0,r0,(r1)		; find next non-zero attribute
	beql	50$			; branch if done scanning
20$:	subl3	r0,r11,r2		; compute index into buffers
	bbc	#scr$v_underline,(r1),30$ ; branch if not an underline
	movl	r2,(sp)			; save rightmost underline
	movb	#^a/_/,(r3)[r2]		; store an underline
30$:	bbc	#scr$v_bold,(r1),5$	; branch if not a bold
	movb	(r8)[r2],(r4)[r2]	; copy the byte
	movl	r2,4(sp)		; save rightmost bold
	brb	5$			; continue scanning

50$:	incl	(sp)			; convert index to # of bytes
	incl	4(sp)			; convert index to # of bytes
	addl	(sp)+,r3		; compute end of underline
	movb	#13,(r3)+		; store a <CR>
	pushl	r3			; save r3
	movc3	4(sp),(r4),(r3)		; slide over the bolded data
	movb	#13,(r3)+		; store another <CR>
	movc3	4(sp),@(sp),(r3)	; make another copy of bolded data
	movb	#13,(r3)+		; store another <CR>
	movc3	4(sp),@(sp)+,(r3)	; make another copy of bolded data
	moval	4(sp),(sp)		; set address of line
	subl3	(sp),r3,-(sp)		; set byte count
	pushl	sp			; push descriptor address
	calls	#1,rms_output		; output the line
	moval	<8+4>(r11)[r11],r1	; compute 8 + 4 + (5 * devwidth))
	addl	r1,sp			; remove descriptor plus buffer
	rsb

	.sbttl	FILL_MAP	Fill map with specified character
;---
;
;	FILL_MAP
;
;	This routine fills the character map with a specified
;	character, zeros the attribute map, and set the
;	modified map to ON.
;
; Inputs:
;
;	r0 = Starting line number 
;	r1 = Starting column number
;	r2 = Ending line number
;	r3 = Ending column number
;	r4 = Fill character
;
; Outputs:
;
;	r0-r5,r7 destroyed.
;---

fill_map:
	decl	r0			; convert line to zero based
	decl	r1			; convert column to zero based
	decl	r2			; convert line to zero based
	mulw2	scr$w_devwidth(r6),r0	; compute start line * screen width
	addl3	r0,r1,r7		; compute starting index
	cmpl	r7,scr$l_area(r6)	; index within area?
	bgequ	90$			; exit if not
	mulw2	scr$w_devwidth(r6),r2	; compute end line * screen width
	addl2	r2,r3			; compute ending index + 1
	cmpl	r3,scr$l_area(r6)	; index within area + 1?
	bgtru	90$			; exit if not
	subl3	r7,r3,r1		; compute length
	blequ	90$			; exit if negative or zero length
; Following MOVC5's preserve R1 !
	movc5	#0,(r1),r4,r1,@scr$l_charmap(r6)[r7]	; fill character map
	movc5	#0,(r1),#0,r1,@scr$l_attrmap(r6)[r7]	; fill attribute map
90$:	rsb

	.sbttl	EXIT_HANDLER	Tie off output streams and reset terminal
;---
;
;	EXIT_HANDLER
;
;	This routine invoked on image exit.  It searches the list
;	of active streams doing a STOP_OUTPUT on each one.
;
;	Any errors are ignored
;
; Inputs:
;
;	SCR$L_FLINKHEAD = head of list of active streams
;
; Outputs:
;
;	SCR$STOP_OUTPUT called for each active stream
;	R0 = status
;	R1 = destroyed
;---

exit_handler: .word 0			; save nothing
	movl	#1,r0			; assume success
10$:	movl	scr$l_flinkhead,r1	; get link head
	beql	50$			; exit if no more streams
	pushl	scr$l_stream(r1)	; stack the stream
	calls	#1,scr$set_output	; establish the stream
	calls	#0,scr$stop_output	; stop the stream
	brb	10$			; loop till done

50$:	ret	
	.end
