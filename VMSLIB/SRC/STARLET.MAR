	.TITLE	STARLET - VAX-11 MACRO SYSTEM SERVICE MACROS
	.IDENT	'V03-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY: System Service Macros
;
; ABSTRACT:
;
;	This module contains the VAX-11 MACRO macros for calling system
;	services.   These macros allow the user to specify arguments with
;	keywords,  and to omit arguments which have default values.
;	There are four macros for each system service.  The $name form
;	simply builds an argument list in place.   The $name_S form generates
;	the code to push the arguments on the stack, and a CALLS instruction
;	to call the service.  The $name_G form generates a CALLG instruction
;	using the supplied argument list address.  A $nameDEF macro is supplied
;	to define the symbolic names for the argument list offsets.  The
;	$nameDEF macro is automatically issued by the $name macro,  so that
;	the user need not specify $nameDEF where $name has already been used.
;
; ENVIRONMENT:
;
; AUTHOR: H. M. Levy	, CREATION DATE: 1-May-1977
;
; MODIFIED BY:
;
;	V03-001	JLV0210		Jake VanNoy		12-APR-1982
;		Change default for CARCON in $BRDCST.
;
;	V02-030	KTA0081		Kerbey T. Altmann	22-Feb-1982
;		Add $MOVEADR macro
;
;	V02-029	JLV0178		Jake VanNoy		2-Feb-1982
;		Add overlay of BRDCST$V_SCREEN with BRDCST$V_ANSI
;		so screen can be documented and anything using ansi
;		doesn't get broken.
;
;	V02-028	JLV0163		Jake VanNoy		19-Jan-1981
;		Include $DEFINI in $BRDCSTDEF.
;
;	V02-027	STJ0183		Steven T. Jeffreys	13-Jan-1981
;		Changed $MOUNT macros to use an item list.
;
;	V02-026	MLJ0064		Martin L. Jack,	13-Dec-1981  16:02
;		Add ACTPRM parameter to $PUTMSG.
;
;	V02-025	SRB0041		Steve Beckhardt		30-Nov-1981
;		Added 4th argument (FLAGS) to $DEQ system service.
;
;	V02-024	PHL0024		Peter H. Lipman		10-Nov-1981
;		$GETDVI now has one null argument for wild card context
;		and it is at the end of the parameter list.
;
;	V02-023	PHL0020		Peter H. Lipman		29-Oct-1981
;		Add two null arguments to $GETDVI for future wild
;		card context.
;
;		Fix $GETSYI macro to do a CLRQ for its two null arguments
;
;	V02-022	PHL0020		Peter H. Lipman		23-Oct-1981
;		Added macros for $GETDVI (get device/volume information)
;		system service.
;
;	V02-021	LJK0073		Lawrence J. Kenah	5-Oct-1981
;		Change all .LONG directives to .ADDRESS to insure that
;		static argument lists are position independent.
;
;	V02-020 JAY0004		John A. Ywoskus		05-Oct-1981
;		Add null arguments to $GETSYI for compatability
;		with $GETJPI.
;
;	V02-019	PCG0001		Peter George		23-Sep-1981	
;		Use G^ in CALLG to $SETRWM.
;		Remove ARGPTR from .ENDM $SNDERR_G.
;
;	V02-018	JLV0080		Jake VanNoy		1-Sep-1981
;		Change to $BRDCST_S for new parameters.
;
;	V02-017	JLV0079		Jake VanNoy		29-Aug-1981
;		More brd changes.
;
;	V02-016	JLV0078		Jake VanNoy		29-Aug-1981
;		Update $BRD* definitions.
;
;	V02-015	LJK0056		Lawrence J. Kenah	27-Aug-1981
;		Add macros for $IMGFIX service that performs run time address 
;		relocation fixups after an image has been activated.
;
;	V02-014	LJK0055		Lawrence J. Kenah	27-Aug-1981
;		Add access mode argument to the $IMGACT call.
;
;	V02-013	KTA0030		Kerbey T. Altmann	26-Aug-1981
;		Added macros for $SETSTK (set stack limits) and
;		$SETSSF (set system service filter)
;
;	V02-012 JAY0001		John A. Ywoskus		25-Aug-1981
;		Added macros for $GETSYI (gets system information)
;		system service
;
;	V02-011	STJ0011		Steven T. Jeffreys	14-Aug-1981
;		Added macros for $MOUNT (mount) system service.
;
;	V02-010	STJ0067		Steven T. Jeffreys	20-Jul-1981
;		Added macros for $DISMOU (dismount) system services.
;
;	V02-009	RPG38314	Bob Grosso		5-Jun-1981
;		Correct spelling of SYS$SETRWN to SYS$SETRWM
;
;	V02-008	SRB0017		Steve Beckhardt		22-Apr-1981
;		Added $ENQ, $ENQW and $DEQ macros.
;
;	V02-007	KTA0015		Kerbey T. Altmann	15-Apr-1981
;		Add the GLOBAL directive to _S form of SETPRV & SETIME.
;
;--


;
;	The following macros are used with system service macro definitions
;	to generate the correct addressing, or to optimize adjacent
;	parameters which are often defaulted.
;

;
; PUSH ADDRESS MACRO
;
; This macro generates a push address instruction with the correct
; context.  If the address argument was defaulted, a zero is pushed
; on the stack.
;
	.MACRO	$PUSHADR,ADDR,CONTEXT=L
		.IF	IDN,0,ADDR
		PUSHL	#0
		.IFF
		PUSHA'CONTEXT	ADDR
		.ENDC
	.ENDM	$PUSHADR


;
; MOVE ADDRESS MACRO
;
; This macro generates a move address instruction with the correct
; context.  If the address argument was defaulted, the destination
; is cleared.
;
	.MACRO	$MOVEADR,ADDR,DST,CONTEXT=L
		.IF	IDN,0,ADDR
		CLR'CONTEXT	DST
		.IFF
		MOVA'CONTEXT	ADDR,DST
		.ENDC
	.ENDM	$MOVEADR





;
; MACRO TO PUSH QUADWORD FOR TWO DEFAULTED VALUE ARGUMENTS
;

	.MACRO	$PUSHTWO A,B
		$$T1 = 0
		.IF	IDN,<#0>,<A>
		.IF	IDN,<#0>,<B>
		$$T1 = 1
		.ENDC
		.ENDC
		.IF	NE	$$T1
		CLRQ	-(SP)
		.IFF
		PUSHL	A
		PUSHL	B
		.ENDC
	.ENDM	$PUSHTWO


; MACRO TO CHECK QIO ARGUMENTS FOR POSSIBLE QUAD PUSH.
; THE FIRST ARG IS A VALUE AND THE SECOND IS AN ADDRESS.

	.MACRO	$QIOPUSH VAL,ADR
		$$T1 = 0
		.IF	IDN,<#0>,<VAL>
		.IF	IDN,<0>,<ADR>
		$$T1 = 1
		.ENDC
		.ENDC
		.IF	NE $$T1
		CLRQ	-(SP)
		.IFF
		PUSHL	VAL
		$PUSHADR ADR
		.ENDC
	.ENDM $QIOPUSH

;
; MACRO TO CHECK FOR QUAD CLEAR IN $ASSIGN.  FIRST ARGUMENT IS
; A QUADWORD ADDRESS, SECOND IS A VALUE.
;

	.MACRO	$ASNPUSH ADRQ,VAL
		$$T1 = 0
		.IF IDN,<0>,<ADRQ>
		.IF IDN,<#0>,<VAL>
		$$T1 = 1
		.ENDC
		.ENDC
		.IF NE $$T1
		CLRQ	-(SP)
		.IFF
		$PUSHADR ADRQ,CONTEXT=Q
		PUSHL	VAL
		.ENDC
	.ENDM	$ASNPUSH

;
; MACRO TO GENERATE GENERAL ARGUMENT LIST.
; THE FIRST PARAMETER IS THE TOTAL NUMBER OF ARGUMENTS TO GENERATE.
; ANY DEFAULTED ARGUMENTS GENERATE A LONGWORD OF ZERO.
;

	.MACRO	$ARGLST LEN,P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,-
			PE,PF
		$$T1=0
		.ADDRESS	LEN
		.IRP $$T2,<P1,P2,P3,P4,P5,P6,P7,P8,P9,PA,PB,PC,PD,PE,PF>
		.IF EQ LEN-$$T1
		.MEXIT
		.ENDC
		.IF NB $$T2
		.ADDRESS	$$T2
		.IFF
		.ADDRESS	0
		.ENDC
		$$T1=$$T1+1
		.ENDM
	.ENDM	$ARGLST

;
; MACRO TO GENERATE OFFSET DEFINITION NAMES.  THE OFFSETS ARE DEFINED
; WITHIN THE $NAME FORM OF THE MACRO.
;

	.MACRO	$OFFDEF,MNAME,LIST
		.NLIST
		$$T1 = 4
		$$ARGS=0
		.IRP	$$T2,<LIST>
		MNAME'$_'$$T2 = $$T1
		$$T1 = $$T1 + 4
		$$ARGS=$$ARGS+1
		.ENDM
		MNAME'$_NARGS = $$ARGS
		.LIST
	.ENDM $OFFDEF


;****** ( Stars mark the beginning of system service macro definitions
;		for the BLISS translator which generates BLISS keyword
;		macros from the $name_S macros in this file.
;
; SYSTEM SERVICE MACRO DEFINITIONS
;

;
; ADJUST WORKING SET LIMIT
;
;	PAGCNT	- NUMBER OF PAGES TO ADD TO WORKING SET IF POSITIVE
;		  NUMBER OF PAGES TO SUBTRACT FROM WORKING SET IF NEGATIVE
;	WSETLM	- ADDRESS OF A LONGWORD TO RETURN NEW WORKING SET LIMIT
;
	.MACRO	$ADJWSL_G ARGPTR
		.GLOBL	SYS$ADJWSL
		CALLG	ARGPTR,G^SYS$ADJWSL
	.ENDM	$ADJWSL_G

	.MACRO	$ADJWSLDEF
		$OFFDEF ADJWSL, <PAGCNT,WSETLM>
	.ENDM	$ADJWSLDEF

	.MACRO	$ADJWSL PAGCNT=0,WSETLM=0
		$ADJWSLDEF
		.ADDRESS	2
		.ADDRESS	PAGCNT
		.ADDRESS	WSETLM
	.ENDM	$ADJWSL

	.MACRO	$ADJWSL_S PAGCNT=#0,WSETLM=0
		.GLOBL	SYS$ADJWSL
		$PUSHADR WSETLM
		PUSHL	PAGCNT
		CALLS	#2,G^SYS$ADJWSL
	.ENDM	$ADJWSL_S
;
; ADJUST OUTER MODE STACK POINTER SERVICE
;
;	ACMODE	- ACCESS MODE TO ADJUST STACK POINTER FOR
;	ADJUST	- 16-BIT SIGNED ADJUSTMENT VALUE
;	NEWADR	- ADDRESS OF LONGWORD TO STORE UPDATED VALUE
;

	.MACRO	$ADJSTK_G ARGPTR
		.GLOBL	SYS$ADJSTK
		CALLG	ARGPTR,G^SYS$ADJSTK
	.ENDM	$ADJSTK_G

	.MACRO	$ADJSTKDEF
		$OFFDEF	ADJSTK,<ACMODE,ADJUST,NEWADR>
	.ENDM	$ADJSTKDEF

	.MACRO	$ADJSTK ACMODE=0,ADJUST=0,NEWADR=0
		$ADJSTKDEF
		.ADDRESS 	3
		.ADDRESS	ACMODE
		.ADDRESS	ADJUST
		.ADDRESS	NEWADR
	.ENDM	$ADJSTK

	.MACRO	$ADJSTK_S ACMODE=#0,ADJUST=#0,NEWADR
		.GLOBL	SYS$ADJSTK
		$PUSHADR NEWADR
		CVTWL	ADJUST,-(SP)
		PUSHL	ACMODE
		CALLS	#3,G^SYS$ADJSTK
	.ENDM	$ADJSTK_S

;
; ALLOCATE DEVICE
;
;	DEVNAM	- ADDRESS OF DEVICE NAME STRING DESCRIPTOR
;	PHYLEN	- ADDRESS OF WORD TO RECEIVE LENGTH OF PHYSICAL NAME
;	PHYBUF	- ADDRESS OF PHYSICAL NAME BUFFER DESCRIPTOR
;	ACMODE	- ACCESS MODE FOR UCB OF ALLOCATED DEVICE
;

	.MACRO	$ALLOC_G ARGPTR
		.GLOBL	SYS$ALLOC
		CALLG	ARGPTR,G^SYS$ALLOC
	.ENDM	$ALLOC_G

	.MACRO	$ALLOCDEF
		$OFFDEF ALLOC, <DEVNAM,PHYLEN,PHYBUF,ACMODE>
	.ENDM	$ALLOCDEF

	.MACRO	$ALLOC DEVNAM=0,PHYLEN=0,PHYBUF=0,ACMODE=0
		$ALLOCDEF
		.ADDRESS	4
		.ADDRESS	DEVNAM
		.ADDRESS	PHYLEN
		.ADDRESS	PHYBUF
		.ADDRESS	ACMODE
	.ENDM	$ALLOC
 
	.MACRO	$ALLOC_S DEVNAM,PHYLEN=0,PHYBUF=0,ACMODE=#0
		.GLOBL	SYS$ALLOC
		PUSHL	ACMODE
		$PUSHADR PHYBUF,CONTEXT=Q
		$PUSHADR PHYLEN,CONTEXT=W
		$PUSHADR DEVNAM,CONTEXT=Q
		CALLS	#4,G^SYS$ALLOC
	.ENDM	$ALLOC_S
 
;
; ASSOCIATE COMMON EVENT FLAG CLUSTER
;
;	EFN	- NUMBER OF AN EVENT FLAG IN THE CLUSTER WITH WHICH TO ASSOCIATE
;	NAME	- ADDRESS OF THE TEXT NAME STRING DESCRIPTOR
;	PROT	- PROTECTION INDICATOR FOR THE CLUSTER
;		0 -> DEFAULT, ANY PROCESS IN GROUP
;		1 -> ONLY OWNER'S UIC
;	PERM	- PERMANENT INDICATOR
;		0 -> TEMPORARY
;		1 -> PERMANENT
;

	.MACRO	$ASCEFC_G ARGPTR
		.GLOBL	SYS$ASCEFC
		CALLG	ARGPTR,G^SYS$ASCEFC
	.ENDM	$ASCEFC_G

	.MACRO	$ASCEFCDEF
		$OFFDEF ASCEFC, <EFN,NAME,PROT,PERM>
	.ENDM	$ASCEFCDEF

	.MACRO	$ASCEFC	EFN=0,NAME=0,PROT=0,PERM=0
		$ASCEFCDEF
		.ADDRESS	4
		.ADDRESS	EFN
		.ADDRESS	NAME
		.ADDRESS	PROT
		.ADDRESS	PERM
	.ENDM	$ASCEFC

	.MACRO	$ASCEFC_S EFN,NAME,PROT=#0,PERM=#0
		.GLOBL	SYS$ASCEFC
		PUSHL	PERM
		PUSHL	PROT
		$PUSHADR NAME,CONTEXT=Q
		PUSHL	EFN
		CALLS	#4,G^SYS$ASCEFC
	.ENDM	$ASCEFC_S

;
; CONVERT BINARY TIME TO ASCII STRING
;
;	TIMLEN  - ADDRESS OF A WORD TO RECEIVE THE NUMBER OF CHARACTERS
;		  INSERTED INTO THE OUTPUT BUFFER
;	TIMBUF	- ADDRESS OF A QUADWORD DESCRIPTOR DESCRIBING THE BUFFER
;		  TO RECEIVE THE CONVERTED TIME
;	TIMADR	- ADDRESS OF THE QUADWORD CONTAINING THE 64-BIT TIME TO BE
;		  CONVERTED TO ASCII
;	CVTFLG	- 0 -> RETURN FULL DATE AND TIME
;		  1 -> RETURN CONVERTED TIME ONLY
;

	.MACRO	$ASCTIM_G ARGPTR
		.GLOBL	SYS$ASCTIM
		CALLG	ARGPTR,G^SYS$ASCTIM
	.ENDM	$ASCTIM_G

	.MACRO	$ASCTIMDEF
		$OFFDEF	ASCTIM,<TIMLEN,TIMBUF,TIMADR,CVTFLG>
	.ENDM	$ASCTIMDEF

	.MACRO	$ASCTIM TIMLEN=0,TIMBUF=0,TIMADR=0,CVTFLG=0
		$ASCTIMDEF
		.ADDRESS	4
		.ADDRESS	TIMLEN
		.ADDRESS	TIMBUF
		.ADDRESS	TIMADR
		.ADDRESS	CVTFLG
	.ENDM	$ASCTIM

	.MACRO	$ASCTIM_S TIMLEN=0,TIMBUF,TIMADR=0,CVTFLG=#0
		.GLOBL	SYS$ASCTIM
		PUSHL	CVTFLG
		$PUSHADR TIMADR,CONTEXT=Q
		$PUSHADR TIMBUF,CONTEXT=Q
		$PUSHADR TIMLEN,CONTEXT=W
		CALLS	#4,G^SYS$ASCTIM
	.ENDM	$ASCTIM_S

;
; ASSIGN I/O CHANNEL
;
;	DEVNAM	- ADDRESS OF DEVICE NAME STRING DESCRIPTOR
;	CHAN	- ADDRESS OF WORD TO RECEIVE CHANNEL NUMBER ASSIGNED
;	ACMODE	- ACCESS MODE FOR CHANNEL'S CCB
;	MBXNAM	- ADDRESS OF OPTIONAL MAILBOX NAME STRING DESCRIPTOR
;

	.MACRO	$ASSIGN_G ARGPTR
		.GLOBL	SYS$ASSIGN
		CALLG	ARGPTR,G^SYS$ASSIGN
	.ENDM	$ASSIGN_G

	.MACRO	$ASSIGNDEF
		$OFFDEF ASSIGN, <DEVNAM,CHAN,ACMODE,MBXNAM>
	.ENDM	$ASSIGNDEF

	.MACRO	$ASSIGN DEVNAM=0,CHAN=0,ACMODE=0,MBXNAM=0
		$ASSIGNDEF
		.ADDRESS	4
		.ADDRESS	DEVNAM
		.ADDRESS	CHAN
		.ADDRESS	ACMODE
		.ADDRESS	MBXNAM
	.ENDM	$ASSIGN
 
	.MACRO	$ASSIGN_S DEVNAM,CHAN,ACMODE=#0,MBXNAM=0
		.GLOBL	SYS$ASSIGN
		$ASNPUSH MBXNAM,ACMODE
		$PUSHADR CHAN,CONTEXT=W
		$PUSHADR DEVNAM,CONTEXT=Q
		CALLS	#4,G^SYS$ASSIGN
	.ENDM	$ASSIGN_S

;
; BINTIM - CONVERT ASCII STRING TO BINARY TIME
;
;	TIMBUF	- ADDRESS OF ASCII STRING DESCRIPTOR FOR ASCII TIME STRING
;	TIMADR 	- ADDRESS OF QUADWORD TO RECEIVE 64 BIT BINARY TIME
;

	.MACRO	$BINTIM_G ARGPTR
		.GLOBL	SYS$BINTIM
		CALLG	ARGPTR,G^SYS$BINTIM
	.ENDM	$BINTIM_G

	.MACRO	$BINTIMDEF
		$OFFDEF BINTIM,<TIMBUF,TIMADR>
	.ENDM	$BINTIMDEF

	.MACRO	$BINTIM TIMBUF=0,TIMADR=0
		$BINTIMDEF
		.ADDRESS	2
		.ADDRESS	TIMBUF
		.ADDRESS	TIMADR
	.ENDM	$BINTIM

	.MACRO	$BINTIM_S TIMBUF,TIMADR
		.GLOBL	SYS$BINTIM
		$PUSHADR TIMADR,CONTEXT=Q
		$PUSHADR TIMBUF,CONTEXT=Q
		CALLS	#2,G^SYS$BINTIM
	.ENDM	$BINTIM_S

;
; BROADCAST MESSAGE
;
; 	MSGBUF	- ADDRESS OF MESSAGE BUFFER DESCRIPTOR
;	DEVNAM	- ADDRESS OF TARGET TERMINAL STRING DESCRIPTOR. ZERO
;		  IMPLIES SEND TO ALL TERMINALS. IF DESCRIPTOR HAS ZERO
;		  LENGTH, THEN SEND TO ALL ALLOCATED TERMINALS.
;	FLAGS	- FIRST BYTE IS NUMBER OF LINES TO CLEAR FOR ANSI
;	CARCON	- CARRIAGE CONTROL 

	.MACRO	$BRDCST_G ARGPTR
		.GLOBL	SYS$BRDCST
		CALLG	ARGPTR,G^SYS$BRDCST
	.ENDM	$BRDCST_G

	.MACRO	$BRDCSTDEF,$GBL
		$OFFDEF	BRDCST,<MSGBUF,DEVNAM,FLAGS,CARCON>
	
		$DEFINI	BRDCST,$GBL

		$VIELD	BRDCST,8,<-
			<SCREEN    ,,M>,-
			<BOTTOM    ,,M>,-
			<REFRSH    ,,M>>
		$VIELD	BRDCST,8,<-
			<ANSI      ,,M>>

		$DEFEND	BRDCST,$GBL,DEF

	.ENDM	$BRDCSTDEF

	.MACRO	$BRDCST MSGBUF=0,DEVNAM=0,FLAGS=0,CARCON=32
		$BRDCSTDEF
		.ADDRESS	4
		.ADDRESS	MSGBUF
		.ADDRESS	DEVNAM
		.ADDRESS	FLAGS
		.ADDRESS	CARCON
	.ENDM	$BRDCST

	.MACRO	$BRDCST_S MSGBUF,DEVNAM=0,FLAGS=#0,CARCON=#32
		.GLOBL	SYS$BRDCST
		PUSHL	CARCON
		PUSHL	FLAGS
		$PUSHADR DEVNAM,CONTEXT=Q
		$PUSHADR MSGBUF,CONTEXT=Q
		CALLS	#4,G^SYS$BRDCST
	.ENDM	$BRDCST_S
;++
; MACRO TO GENERATE SYSTEM BUGCHECK
;--
	.MACRO	$BUG_CHECK ERROR,TYPE=CONT
		.WORD	^XFFFF
		.IIF IDN <TYPE>,<FATAL> , .ADDRESS <'ERROR'&^X0FFFFFFF8>!4
		.IIF DIF <TYPE>,<FATAL> , .ADDRESS	'ERROR'
	.ENDM	$BUG_CHECK

;
; CANCEL I/O ON CHANNEL
;
;	CHAN - CHANNEL ON WHICH ALL I/O WILL BE CANCELED
;

	.MACRO	$CANCEL_G ARGPTR
		.GLOBL	SYS$CANCEL
		CALLG	ARGPTR,G^SYS$CANCEL
	.ENDM	$CANCEL_G

	.MACRO	$CANCELDEF
		$OFFDEF	CANCEL,<CHAN>
	.ENDM	$CANCELDEF

	.MACRO	$CANCEL CHAN=0
		$CANCELDEF
		.ADDRESS	1
		.ADDRESS	CHAN
	.ENDM	$CANCEL

	.MACRO	$CANCEL_S CHAN
		.GLOBL	SYS$CANCEL
		MOVZWL	CHAN,-(SP)
		CALLS	#1,G^SYS$CANCEL
	.ENDM	$CANCEL_S

;
; CANCEL EXIT HANDLER
;
;	DESBLK - ADDRESS OF PREVIOUSLY DECLARED EXIT HANDLER CONTROL BLOCK
;
;

	.MACRO	$CANEXH_G ARGPTR
		.GLOBL	SYS$CANEXH
		CALLG	ARGPTR,G^SYS$CANEXH
	.ENDM	$CANEXH_G

	.MACRO	$CANEXHDEF
		$OFFDEF	CANEXH,<DESBLK>
	.ENDM	$CANEXHDEF

	.MACRO	$CANEXH DESBLK=0
		$CANEXHDEF
		.ADDRESS	1
		.ADDRESS	DESBLK
	.ENDM	$CANEXH

	.MACRO	$CANEXH_S DESBLK=0
		.GLOBL	SYS$CANEXH
		$PUSHADR DESBLK
		CALLS	#1,G^SYS$CANEXH
	.ENDM	$CANEXH_S

;
; CANCEL TIMER REQUEST
;
;	REQIDT	- REQUEST IDENTIFICATION FOR REQUEST TO BE CANCELED
;	ACMODE	- ACCESS MODE OF REQUESTS TO BE CANCELED
;

	.MACRO	$CANTIM_G ARGPTR
		.GLOBL	SYS$CANTIM
		CALLG	ARGPTR,G^SYS$CANTIM
	.ENDM	$CANTIM_G

	.MACRO	$CANTIMDEF
		$OFFDEF CANTIM, <REQIDT,ACMODE>
	.ENDM	$CANTIMDEF

	.MACRO	$CANTIM REQIDT=0,ACMODE=0
		$CANTIMDEF
		.ADDRESS	2
		.ADDRESS	REQIDT
		.ADDRESS	ACMODE
	.ENDM	$CANTIM

	.MACRO	$CANTIM_S REQIDT=#0,ACMODE=#0
		.GLOBL	SYS$CANTIM
		PUSHL	ACMODE
		PUSHL	REQIDT
		CALLS	#2,G^SYS$CANTIM
	.ENDM	$CANTIM_S

;
; CANCEL WAKEUP
;
;	PIDADR	- ADDRESS OF PROCESS ID OF PROCESS TO AWAKE
;	PRCNAM	- ADDRESS OF PROCESS NAME STRING DESCRIPTOR
;

	.MACRO	$CANWAK_G ARGPTR
		.GLOBL	SYS$CANWAK
		CALLG	ARGPTR,G^SYS$CANWAK
	.ENDM	$CANWAK_G

	.MACRO	$CANWAKDEF
		$OFFDEF CANWAK, <PIDADR,PRCNAM>
	.ENDM	$CANWAKDEF

	.MACRO	$CANWAK PIDADR=0,PRCNAM=0
		$CANWAKDEF
		.ADDRESS	2
		.ADDRESS	PIDADR
		.ADDRESS	PRCNAM
	.ENDM	$CANWAK

	.MACRO	$CANWAK_S PIDADR=0,PRCNAM=0
		.GLOBL	SYS$CANWAK
		$PUSHADR PRCNAM,CONTEXT=Q
		$PUSHADR PIDADR
		CALLS	#2,G^SYS$CANWAK
	.ENDM	$CANWAK_S
 
;
; CLEAR EVENT FLAG
;
;	EFN	- EVENT FLAG NUMBER TO BE CLEARED
;

	.MACRO	$CLREF_G ARGPTR
		.GLOBL	SYS$CLREF
		CALLG	ARGPTR,G^SYS$CLREF
	.ENDM	$CLREF_G

	.MACRO	$CLREFDEF
		$OFFDEF CLREF, <EFN>
	.ENDM	$CLREFDEF

	.MACRO	$CLREF EFN=0
		$CLREFDEF
		.ADDRESS	1
		.ADDRESS	EFN
	.ENDM	$CLREF

	.MACRO	$CLREF_S EFN
		.GLOBL	SYS$CLREF
		PUSHL	EFN
		CALLS	#1,G^SYS$CLREF
	.ENDM	$CLREF_S

;
; CHANGE TO EXECUTIVE MODE
;
;	ROUTIN	- ADDRESS OF ROUTINE TO BE EXECUTED IN EXECUTIVE MODE
;	ARGLST	- ADDRESS OF ARGUMENT LIST TO BE SUPPLIED TO THE ROUTINE
;

	.MACRO	$CMEXEC_G ARGPTR
		.GLOBL	SYS$CMEXEC
		CALLG	ARGPTR,G^SYS$CMEXEC
	.ENDM	$CMEXEC_G

	.MACRO	$CMEXECDEF
		$OFFDEF CMEXEC, <ROUTIN,ARGLST>
	.ENDM	$CMEXECDEF

	.MACRO	$CMEXEC ROUTIN=0,ARGLST=0
		$CMEXECDEF
		.ADDRESS	2
		.ADDRESS	ROUTIN
		.ADDRESS	ARGLST
	.ENDM	$CMEXEC

	.MACRO	$CMEXEC_S ROUTIN,ARGLST=0
		.GLOBL	SYS$CMEXEC
		$PUSHADR ARGLST
		$PUSHADR ROUTIN
		CALLS	#2,G^SYS$CMEXEC
	.ENDM	$CMEXEC_S

;
; CHANGE TO KERNEL MODE
;
;	ROUTIN	- ADDRESS OF ROUTINE TO EXECUTE IN KERNEL MODE
;	ARGLST	- ADDRESS OF ARGUMENT LIST TO BE SUPPLIED TO ROUTINE
;

	.MACRO	$CMKRNL_G ARGPTR
		.GLOBL	SYS$CMKRNL
		CALLG	ARGPTR,G^SYS$CMKRNL
	.ENDM	$CMKRNL_G

	.MACRO	$CMKRNLDEF
		$OFFDEF CMKRNL, <ROUTIN,ARGLST>
	.ENDM	$CMKRNLDEF

	.MACRO	$CMKRNL ROUTIN=0,ARGLST=0
		$CMKRNLDEF
		.ADDRESS	2
		.ADDRESS	ROUTIN
		.ADDRESS	ARGLST
	.ENDM	$CMKRNL

	.MACRO	$CMKRNL_S ROUTIN,ARGLST=0
		.GLOBL	SYS$CMKRNL
		$PUSHADR ARGLST
		$PUSHADR ROUTIN
		CALLS	#2,G^SYS$CMKRNL
	.ENDM	$CMKRNL_S

;
; CONTRACT PROGRAM/CONTROL REGION
;
;	PAGCNT	- NUMBER OF PAGES TO BE DELETED FROM END OF REGION
;	RETADR	- ADDRESS OF TWO LONGWORD ARRAY TO RECEIVE VIRTUAL ADDRESSES
;		  OF STARTING AND ENDING PAGE OF DELETED AREA
;	ACMODE	- ACCESS MODE FOR WHICH SERVICE IS PERFORMED
;	REGION	- REGION INDICATOR
;		  0 -> PROGRAM (P0) REGION
;		  1 -> CONTROL (P1) REGION
;

	.MACRO	$CNTREG_G ARGPTR
		.GLOBL	SYS$ARGPTR
		CALLG	ARGPTR,G^SYS$CNTREG
	.ENDM	$CNTREG_G

	.MACRO	$CNTREGDEF
		$OFFDEF CNTREG, <PAGCNT,RETADR,ACMODE,REGION>
	.ENDM	$CNTREGDEF

	.MACRO	$CNTREG PAGCNT=0,RETADR=0,ACMODE=0,REGION=0
		$CNTREGDEF
		.ADDRESS	4
		.ADDRESS	PAGCNT
		.ADDRESS	RETADR
		.ADDRESS	ACMODE
		.ADDRESS	REGION
	.ENDM	$CNTREG

	.MACRO	$CNTREG_S PAGCNT,RETADR=0,ACMODE=#0,REGION=#0
		.GLOBL	SYS$CNTREG
		PUSHL	REGION
		PUSHL	ACMODE
		$PUSHADR RETADR,CONTEXT=Q
		PUSHL	PAGCNT
		CALLS	#4,G^SYS$CNTREG
	.ENDM	$CNTREG_S

;
; CREATE LOGICAL NAME
;
;	TBLFLG	- LOGICAL NAME TABLE NUMBER
;		 0 -> SYSTEM TABLE
;		 1 -> GROUP TABLE
;		 2 -> PROCESS TABLE
;	LOGNAM	- ADDRESS OF LOGICAL NAME STRING DESCRIPTOR
;	EQLNAM	- ADDRESS OF EQUIVALENCE NAME STRING DESCRIPTOR
;	ACMODE	- ACCESS MODE FOR LOGICAL NAME
;

	.MACRO	$CRELOG_G ARGPTR
		.GLOBL	SYS$CRELOG
		CALLG	ARGPTR,G^SYS$CRELOG
	.ENDM	$CRELOG_G

	.MACRO	$CRELOGDEF
		$OFFDEF CRELOG, <TBLFLG,LOGNAM,EQLNAM,ACMODE>
	.ENDM	$CRELOGDEF

	.MACRO	$CRELOG TBLFLG=0,LOGNAM=0,EQLNAM=0,ACMODE=0
		$CRELOGDEF
		.ADDRESS	4
		.ADDRESS	TBLFLG
		.ADDRESS	LOGNAM
		.ADDRESS	EQLNAM
		.ADDRESS	ACMODE
	.ENDM	$CRELOG

	.MACRO	$CRELOG_S TBLFLG=#0,LOGNAM,EQLNAM,ACMODE=#0
		.GLOBL	SYS$CRELOG
		PUSHL	ACMODE
		$PUSHADR EQLNAM,CONTEXT=Q
		$PUSHADR LOGNAM,CONTEXT=Q
		PUSHL	TBLFLG
		CALLS	#4,G^SYS$CRELOG
	.ENDM	$CRELOG_S

;
; CREATE MAILBOX AND ASSIGN CHANNEL
;
;	PRMFLG	- PERMANENT FLAG
;		  1 -> CREATE PERMANENT MAILBOX
;		  0 -> CREATE TEMPORARY MAILBOX (DEFAULT)
;	CHAN	- ADDRESS OF WORD TO RECEIVE CHANNEL ASSIGNED
;	MAXMSG	- MAXIMUM MESSAGE SIZE THAT MAY BE RECEIVED BY MAILBOX
;	BUFQUO	- BYTES OF DYNAMIC MEMORY THAT MAY BE USED TO BUFFER
;		  MAILBOX MESSAGES
;	PROMSK	- PROTECTION MASK FOR MAILBOX
;	ACMODE	- ACCESS MODE OF CREATED MAILBOX
;	LOGNAM	- ADDRESS OF LOGICAL NAME STRING DESCRIPTOR FOR MAILBOX
;

	.MACRO	$CREMBX_G ARGPTR
		.GLOBL	SYS$CREMBX
		CALLG	ARGPTR,G^SYS$CREMBX
	.ENDM	$CREMBX_G

	.MACRO	$CREMBXDEF
		$OFFDEF CREMBX,<PRMFLG,CHAN,MAXMSG,BUFQUO,PROMSK,ACMODE,LOGNAM>
	.ENDM	$CREMBXDEF

	.MACRO	$CREMBX PRMFLG=0,CHAN=0,MAXMSG=0,BUFQUO=0,PROMSK=0,-
			  ACMODE=0,LOGNAM=0
		$CREMBXDEF
		.ADDRESS	7
		.ADDRESS	PRMFLG
		.ADDRESS	CHAN
		.ADDRESS	MAXMSG
		.ADDRESS	BUFQUO
		.ADDRESS	PROMSK
		.ADDRESS	ACMODE
		.ADDRESS	LOGNAM
	.ENDM	$CREMBX

	.MACRO	$CREMBX_S PRMFLG=#0,CHAN,MAXMSG=#0,BUFQUO=#0,PROMSK=#0,-
			  ACMODE=#0,LOGNAM=0
		.GLOBL	SYS$CREMBX
		$PUSHADR LOGNAM,CONTEXT=Q
		$PUSHTWO ACMODE,PROMSK
		$PUSHTWO BUFQUO,MAXMSG
		$PUSHADR CHAN,CONTEXT=W
		PUSHL	PRMFLG
		CALLS	#7,G^SYS$CREMBX
	.ENDM	$CREMBX_S

;
; CREATE PROCESS
;
;	PIDADR	- ADDRESS OF LONGWORD IN WHICH TO RETURN PID OF CREATED
;		  PROCESS.
;	IMAGE	- ADDRESS OF STRING DESCRIPTOR FOR IMAGE NAME.
;	INPUT	- ADDRESS OF STRING DESCRIPTOR FOR INPUT LOGICAL NAME.
;	OUTPUT	- ADDRESS OF STRING DESCRIPTOR FOR OUTPUT LOGICAL NAME.
;	ERROR	- ADDRESS OF STRING DESCRIPTOR FOR ERROR LOGICAL NAME.
;	PRVADR	- ADDRESS OF PRIVILEGE MASK (QUAD WORD).
;	QUOTA	- ADDRESS OF QUOTA LIST.
;	PRCNAM	- ADDRESS OF STRING DESCRIPTOR FOR PROCESS NAME.
;	BASPRI	- BASE PRIORITY (0,31) TO SET FOR NEW PROCESS.
;	UIC	- USER IDENTIFICATION CODE, 0=>SUBPROCESS.
;	MBXUNT	- MAILBOX UNIT FOR TERMINATION MESSAGE.
;	STSFLG	- STATUS AND MODE FLAG BITS.
;		  BIT       MEANING
;		  ---       -------
;		   0	    RESOURCE WAIT DISABLE
;		   1	    SYSTEM SERVICE FAILURE EXCEPTION ENABLE
;		   2        SWAP MODE (1=>DONT SWAP)
;		   3	    ACCOUNTING MESSAGE DISABLE
;		   4	    BATCH PROCESS
;		   5	    MAKE PROCESS HIBERNATE
;		   6	    ALLOW LOGIN WITH AUTHORIZATION FILE CHECK
;		   7        PROCESS IS NETWORK CONNECT OBJECT
;

	.MACRO	$CREPRC_G ARGPTR
		.GLOBL	SYS$CREPRC
		CALLG	ARGPTR,G^SYS$CREPRC
	.ENDM	$CREPRC_G

	.MACRO	$CREPRCDEF
	$OFFDEF	CREPRC,<PIDADR,IMAGE,INPUT,OUTPUT,ERROR,PRVADR,-;
			QUOTA,PRCNAM,BASPRI,UIC,MBXUNT,STSFLG>
	.ENDM	$CREPRCDEF

	.MACRO	$CREPRC PIDADR=0,IMAGE=0,INPUT=0,OUTPUT=0,-;
			  ERROR=0,PRVADR=0,QUOTA=0,PRCNAM=0,BASPRI=2,-;
			  UIC=0,MBXUNT=0,STSFLG=0
		$CREPRCDEF
		.ADDRESS	12
		.ADDRESS	PIDADR
		.ADDRESS	IMAGE
		.ADDRESS	INPUT
		.ADDRESS	OUTPUT
		.ADDRESS	ERROR
		.ADDRESS	PRVADR
		.ADDRESS	QUOTA
		.ADDRESS	PRCNAM
		.ADDRESS	BASPRI
		.ADDRESS	UIC
		.ADDRESS	MBXUNT
		.ADDRESS	STSFLG
	.ENDM	$CREPRC

	.MACRO	$CREPRC_S	PIDADR=0,IMAGE=0,INPUT=0,OUTPUT=0,-;
				ERROR=0,PRVADR=0,QUOTA=0,PRCNAM=0,-;
				BASPRI=#2,-;
				UIC=#0,MBXUNT=#0,STSFLG=#0
		.GLOBL	SYS$CREPRC
		PUSHL	STSFLG
		MOVZWL	MBXUNT,-(SP)
		$PUSHTWO UIC,BASPRI
		$PUSHADR PRCNAM,CONTEXT=Q
		$PUSHADR QUOTA
		$PUSHADR PRVADR,CONTEXT=Q
		$PUSHADR ERROR,CONTEXT=Q
		$PUSHADR OUTPUT,CONTEXT=Q
		$PUSHADR INPUT,CONTEXT=Q
		$PUSHADR IMAGE,CONTEXT=Q
		$PUSHADR PIDADR
		CALLS	#12,G^SYS$CREPRC
	.ENDM	$CREPRC_S

;
; CREATE VIRTUAL ADDRESS SPACE
;
;	INADR	- ADDRESS OF 2-LONGWORD ARRAY CONTAINING STARTING AND
;		  ENDING VIRTUAL ADDRESS OF PAGES TO BE CREATED
;	RETADR	- ADDRESS OF A 2-LONGWORD ARRAY TO RECEIVE STARTING
;		  AND ENDING VIRTUAL ADDRESS OF PAGES ACTUALLY CREATED
;	ACMODE	- ACCESS MODE FOR THE NEW PAGES. (PROT IS R/W FOR ACMODE
;		  AND MORE PRIVILEGED MODES).
;

	.MACRO	$CRETVA_G ARGPTR
		.GLOBL	SYS$CRETVA
		CALLG	ARGPTR,G^SYS$CRETVA
	.ENDM	$CRETVA_G

	.MACRO	$CRETVADEF
		$OFFDEF CRETVA, <INADR,RETADR,ACMODE>
	.ENDM	$CRETVADEF

	.MACRO	$CRETVA INADR=0,RETADR=0,ACMODE=0
		$CRETVADEF
		.ADDRESS	3
		.ADDRESS	INADR
		.ADDRESS	RETADR
		.ADDRESS	ACMODE
	.ENDM	$CRETVA

	.MACRO	$CRETVA_S INADR,RETADR=0,ACMODE=#0
		.GLOBL	SYS$CRETVA
		PUSHL	ACMODE
		$PUSHADR RETADR,CONTEXT=Q
		$PUSHADR INADR,CONTEXT=Q
		CALLS	#3,G^SYS$CRETVA
	.ENDM	$CRETVA_S

;
; CREATE AND MAP PROCESS OR GLOBAL SECTION
;
;	INADR	- ADDRESS OF 2-LONGWORD ARRAY CONTAINING STARTING AND
;		  ENDING ADDRESS INTO WHICH THE SECTION WILL BE MAPPED
;	RETADR	- ADDRESS OF 2-LONGWORD ARRAY INTO WHICH THE ADDRESSES
;		  ACTUALLY MAPPED ARE RETURNED
;	ACMODE	- ACCESS MODE OWNING THE PAGES CREATED
;	FLAGS	- MASK DEFINING SECTION TYPE AND CHARACTERISTICS
;	GSDNAM	- ADDRESS OF DESCRIPTOR FOR THE SECTION NAME
;	IDENT	- ADDRESS OF QUADWORD VERSION IDENTIFICATION
;	RELPAG	- RELATIVE PAGE NUMBER WITHIN THE SECTION OF THE
;		  FIRST PAGE TO BE MAPPED
;	CHAN	- CHANNEL NUMBER ON WHICH FILE HAS BEEN ACCESSED
;	PAGCNT	- NUMBER OF PAGES IN SECTION
;	VBN	- VIRTUAL BLOCK NUMBER OF THE BEGINNING OF THE SECTION
;	PROT	- PROTECTION MASK TO BE APPLIED TO THE SECTION
;	PFC	- PAGE FAULT CLUSTER SIZE
;

	.MACRO	$CRMPSC_G ARGPTR
		.GLOBL	SYS$CRMPSC
		CALLG	ARGPTR,G^SYS$CRMPSC
	.ENDM	$CRMPSC_G

	.MACRO	$CRMPSCDEF
		$OFFDEF	CRMPSC,<INADR,RETADR,ACMODE,FLAGS,GSDNAM,-
			IDENT,RELPAG,CHAN,PAGCNT,VBN,PROT,PFC>
	.ENDM	$CRMPSCDEF

	.MACRO	$CRMPSC	INADR=0,RETADR=0,ACMODE=0,FLAGS=0,GSDNAM=0,-
			IDENT=0,RELPAG=0,CHAN=0,PAGCNT=0,VBN=0,PROT=0,-
			PFC=0
		$CRMPSCDEF
		.ADDRESS	12
		.ADDRESS	INADR
		.ADDRESS	RETADR
		.ADDRESS	ACMODE
		.ADDRESS	FLAGS
		.ADDRESS	GSDNAM
		.ADDRESS	IDENT
		.ADDRESS	RELPAG
		.ADDRESS	CHAN
		.ADDRESS	PAGCNT
		.ADDRESS	VBN
		.ADDRESS	PROT
		.ADDRESS	PFC
	.ENDM	$CRMPSC

	.MACRO	$CRMPSC_S INADR=0,RETADR=0,ACMODE=#0,FLAGS=#0,-
			  GSDNAM=0,IDENT=0,RELPAG=#0,CHAN=#0,-
			  PAGCNT=#0,VBN=#0,PROT=#0,PFC=#0
		.GLOBL	SYS$CRMPSC
		$PUSHTWO PFC,PROT
		$PUSHTWO VBN,PAGCNT
		MOVZWL	CHAN,-(SP)
		PUSHL	RELPAG
		$PUSHADR IDENT,CONTEXT=Q
		$PUSHADR GSDNAM,CONTEXT=Q
		PUSHL	FLAGS
		PUSHL	ACMODE
		$PUSHADR RETADR,CONTEXT=Q
		$PUSHADR INADR,CONTEXT=Q
		CALLS	#12,G^SYS$CRMPSC
	.ENDM	$CRMPSC_S

;
; DISASSOCIATE COMMON EVENT FLAG CLUSTER
;
;	EFN	- NUMBER OF AN EVENT FLAG IN THE CLUSTER TO BE DISASSOCIATED
;

	.MACRO	$DACEFC_G ARGPTR
		.GLOBL	SYS$DACEFC
		CALLG	ARGPTR,G^SYS$DACEFC
	.ENDM	$DACEFC_G

	.MACRO	$DACEFCDEF
		$OFFDEF DACEFC, <EFN>
	.ENDM	$DACEFCDEF

	.MACRO	$DACEFC EFN=0
		$DACEFCDEF
		.ADDRESS	1
		.ADDRESS	EFN
	.ENDM	$DACEFC

	.MACRO	$DACEFC_S EFN
		.GLOBL	SYS$DACEFC
		PUSHL	EFN
		CALLS	#1,G^SYS$DACEFC
	.ENDM	$DACEFC_S

;
; DEALLOCATE DEVICE
;
;	DEVNAM	- ADDRESS OF DEVICE NAME STRING DESCRIPTOR. ZERO IMPLIES
;		ALL.
;	ACMODE	- ACCESS MODE.
;

	.MACRO	$DALLOC_G ARGPTR
		.GLOBL	SYS$DALLOC
		CALLG	ARGPTR,G^SYS$DALLOC
	.ENDM	$DALLOC_G

	.MACRO	$DALLOCDEF
		$OFFDEF DALLOC, <DEVNAM,ACMODE>
	.ENDM	$DALLOCDEF

	.MACRO	$DALLOC DEVNAM=0,ACMODE=0
		$DALLOCDEF
		.ADDRESS	2
		.ADDRESS	DEVNAM
		.ADDRESS	ACMODE
	.ENDM	$DALLOC
 
	.MACRO	$DALLOC_S DEVNAM=0,ACMODE=#0
		.GLOBL	SYS$DALLOC
		PUSHL	ACMODE
		$PUSHADR DEVNAM,CONTEXT=Q
		CALLS	#2,G^SYS$DALLOC
	.ENDM	$DALLOC_S
 
;
; DEASSIGN I/O CHANNEL
;
;	CHAN	- NUMBER OF CHANNEL TO BE DEASSIGNED
;

	.MACRO	$DASSGN_G ARGPTR
		.GLOBL	SYS$DASSGN
		CALLG	ARGPTR,G^SYS$DASSGN
	.ENDM	$DASSGN_G

	.MACRO	$DASSGNDEF
		$OFFDEF DASSGN, <CHAN>
	.ENDM	$DASSGNDEF

	.MACRO	$DASSGN CHAN=0
		$DASSGNDEF
		.ADDRESS	1
		.ADDRESS	CHAN
	.ENDM	$DASSGN
 
	.MACRO	$DASSGN_S CHAN
		.GLOBL	SYS$DASSGN
		MOVZWL	CHAN,-(SP)
		CALLS	#1,G^SYS$DASSGN
	.ENDM	$DASSGN_S
 
;
; DECLARE AST
;
;	ASTADR	- ENTRY ADDRESS OF AST ROUTINE
;	ASTPRM	- VALUE TO BE PASSED TO AST ROUTINE AS AN ARGUMENT
;	ACMODE	- ACCESS MODE FOR WHICH THE AST IS TO BE DECLARED
;

	.MACRO	$DCLAST_G ARGPTR
		.GLOBL	SYS$DCLAST
		CALLG	ARGPTR,G^SYS$DCLAST
	.ENDM	$DCLAST_G

	.MACRO	$DCLASTDEF
		$OFFDEF DCLAST, <ASTADR,ASTPRM,ACMODE>
	.ENDM	$DCLASTDEF

	.MACRO	$DCLAST ASTADR=0,ASTPRM=0,ACMODE=0
		$DCLASTDEF
		.ADDRESS	3
		.ADDRESS	ASTADR
		.ADDRESS	ASTPRM
		.ADDRESS	ACMODE
	.ENDM	$DCLAST

	.MACRO	$DCLAST_S ASTADR,ASTPRM=#0,ACMODE=#0
		.GLOBL	SYS$DCLAST
		PUSHL	ACMODE
		PUSHL	ASTPRM
		$PUSHADR ASTADR
		CALLS	#3,G^SYS$DCLAST
	.ENDM	$DCLAST_S

;
; DECLARE CHANGE MODE OR COMPATIBILITY MODE HANDLER
;
; 	ADDRES	- ADDRESS OF THE HANDLER TO BE DECLARED
;	PRVHND	- ADDRESS OF A LONGWORD TO RECEIVE THE PREVIOUS HANDLER ADDRESS
;	TYPE    - HANDLER TYPE INDICATOR
;		0 = DECLARE CHANGE MODE HANDLER FOR CURRENT MODE
;		1 = DECLARE COMPATIBILITY MODE HANDLER
;

	.MACRO	$DCLCMH_G ARGPTR
		.GLOBL	SYS$DCLCMH
		CALLG	ARGPTR,G^SYS$DCLCMH
	.ENDM	$DCLCMH_G

	.MACRO	$DCLCMHDEF
		$OFFDEF	DCLCMH,<ADDRES,PRVHND,TYPE>
	.ENDM	$DCLCMHDEF

	.MACRO	$DCLCMH ADDRES=0,PRVHND=0,TYPE=0
		$DCLCMHDEF
		.ADDRESS	3
		.ADDRESS	ADDRES
		.ADDRESS	PRVHND
		.ADDRESS	TYPE
	.ENDM	$DCLCMH

	.MACRO	$DCLCMH_S ADDRES,PRVHND=0,TYPE=#0
		.GLOBL	SYS$DCLCMH
		PUSHL	TYPE
		$PUSHADR PRVHND
		$PUSHADR ADDRES
		CALLS	#3,G^SYS$DCLCMH
	.ENDM	$DCLCMH_S

;
; DECLARE EXIT HANDLER
;
;	DESBLK	- ADDRESS OF EXIT CONTROL BLOCK CONTAINING
;		
;		+-------------------------------------------+
;		!              FORWARD LINK                 !
;		+-------------------------------------------+
;		!                  EXIT HANDL. ADDRESS      !
;		+-------------------------------------------+
;		!		0                   !  N    !
;		+-------------------------------------------+
;		!   ADDRESS TO STORE REASON FOR EXIT        !
;		+-------------------------------------------+
;		!  ADDITIONAL			            !
;		!      ARGUMENTS		            !
;		!	   IF			            !
;		!	      ANY			    !
;		+-------------------------------------------+
;

	.MACRO	$DCLEXH_G ARGPTR
		.GLOBL	SYS$DCLEXH
		CALLG	ARGPTR,G^SYS$DCLEXH
	.ENDM	$DCLEXH_G

	.MACRO	$DCLEXHDEF
		$OFFDEF DCLEXH, <DESBLK>
	.ENDM	$DCLEXHDEF

	.MACRO	$DCLEXH DESBLK=0
		$DCLEXHDEF
		.ADDRESS	1
		.ADDRESS	DESBLK
	.ENDM	$DCLEXH

	.MACRO	$DCLEXH_S DESBLK
		.GLOBL	SYS$DCLEXH
		$PUSHADR DESBLK
		CALLS	#1,G^SYS$DCLEXH
	.ENDM	$DCLEXH_S

;
; DELETE LOGICAL NAME
;
;	TBLFLG	- LOGICAL NAME TABLE NUMBER
;		  0 -> SYSTEM, 1 -> GROUP, 2 -> LOCAL
;	LOGNAM	- ADDRESS OF LOGICAL NAME STRING DESCRIPTOR.
;		ZERO IMPLIES ALL.
;	ACMODE	- ACCESS MODE OF LOGICAL NAME
;

	.MACRO	$DELLOG_G ARGPTR
		.GLOBL	SYS$DELLOG
		CALLG	ARGPTR,G^SYS$DELLOG
	.ENDM	$DELLOG_G

	.MACRO	$DELLOGDEF
		$OFFDEF DELLOG, <TBLFLG,LOGNAM,ACMODE>
	.ENDM	$DELLOGDEF

	.MACRO	$DELLOG TBLFLG=0,LOGNAM=0,ACMODE=0
		$DELLOGDEF
		.ADDRESS	3
		.ADDRESS	TBLFLG
		.ADDRESS	LOGNAM
		.ADDRESS	ACMODE
	.ENDM	$DELLOG

	.MACRO	$DELLOG_S TBLFLG=#0,LOGNAM=0,ACMODE=#0
		.GLOBL	SYS$DELLOG
		PUSHL	ACMODE
		$PUSHADR LOGNAM,CONTEXT=Q
		PUSHL	TBLFLG
		CALLS	#3,G^SYS$DELLOG
	.ENDM	$DELLOG_S

;
; DELETE MAILBOX
;
;	CHAN - CHANNEL ON WHICH MAILBOX IS ASSIGNED
;

	.MACRO	$DELMBX_G ARGPTR
		.GLOBL	SYS$DELMBX
		CALLG	ARGPTR,G^SYS$DELMBX
	.ENDM	$DELMBX_G

	.MACRO	$DELMBXDEF
		$OFFDEF DELMBX, <CHAN>
	.ENDM	$DELMBXDEF

	.MACRO	$DELMBX CHAN
		$DELMBXDEF
		.ADDRESS	1
		.ADDRESS	CHAN
	.ENDM	$DELMBX

	.MACRO	$DELMBX_S CHAN
		.GLOBL	SYS$DELMBX
		MOVZWL	CHAN,-(SP)
		CALLS	#1,G^SYS$DELMBX
	.ENDM	$DELMBX_S

;
; DELETE PROCESS
;
;	PIDADR   - ADDRESS OF LONGWORD CONTAINING PID OF PROCESS TO
;		 - BE DELETED.
;	PRCNAM   - ADDRESS OF STRING DESCRIPTOR FOR PROCESS NAME OF
;		   PROCESS TO BE DELETED.
;

	.MACRO	$DELPRC_G ARGPTR
		.GLOBL	SYS$DELPRC
		CALLG	ARGPTR,G^SYS$DELPRC
	.ENDM	$DELPRC_G

	.MACRO	$DELPRCDEF
		$OFFDEF	DELPRC,<PIDADR,PRCNAM>
	.ENDM	$DELPRCDEF

	.MACRO	$DELPRC	PIDADR=0,PRCNAM=0
		$DELPRCDEF
		.ADDRESS	2
		.ADDRESS	PIDADR
		.ADDRESS	PRCNAM
	.ENDM	$DELPRC

	.MACRO	$DELPRC_S	PIDADR=0,PRCNAM=0
		.GLOBL	SYS$DELPRC
		$PUSHADR PRCNAM,CONTEXT=Q
		$PUSHADR PIDADR
		CALLS	#2,G^SYS$DELPRC
	.ENDM	$DELPRC_S

;
; DELETE VIRTUAL ADDRESS SPACE
;
;	INADR	- ADDRESS OF 2 LONGWORD ARRAY CONTAINING STARTING AND
;		  ENDING VIRTUAL ADDRESSES OF PAGES TO DELETE
;	RETADR	- ADDRESS OF 2 LONGWORD ARRAY TO RECEIVE STARTING AND
;		  ENDING ADDRESSES OF PAGES ACTUALLY DELETED
;	ACMODE	- ACCESS MODE FOR WHICH SERVICE IS PERFORMED
;

	.MACRO	$DELTVA_G ARGPTR
		.GLOBL	SYS$DELTVA
		CALLG	ARGPTR,G^SYS$DELTVA
	.ENDM	$DELTVA_G

	.MACRO	$DELTVADEF
		$OFFDEF DELTVA, <INADR,RETADR,ACMODE>
	.ENDM	$DELTVADEF

	.MACRO	$DELTVA INADR=0,RETADR=0,ACMODE=0
		$DELTVADEF
		.ADDRESS	3
		.ADDRESS	INADR
		.ADDRESS	RETADR
		.ADDRESS	ACMODE
	.ENDM	$DELTVA

	.MACRO	$DELTVA_S INADR,RETADR=0,ACMODE=#0
		.GLOBL	SYS$DELTVA
		PUSHL	ACMODE
		$PUSHADR RETADR,CONTEXT=Q
		$PUSHADR INADR,CONTEXT=Q
		CALLS	#3,G^SYS$DELTVA
	.ENDM	$DELTVA_S

;
; DEQ - DEQUEUE LOCK SYSTEM SERVICE
;
;	LKID	- LOCK ID OF LOCK TO DEQUEUE.  0 MEANS DEQUEUE ALL LOCKS
;		  AT THE SPECIFIED ACCESS MODE
;	VALBLK	- ADDRESS OF VALUE BLOCK
;	ACMODE	- ACCESS MODE OF ALL LOCKS TO DEQUEUE
;	FLAGS	- MASK DEFINING OPTIONAL FLAGS

	.MACRO	$DEQ_G	ARGPTR
		.GLOBL	SYS$DEQ
		CALLG	ARGPTR,G^SYS$DEQ
	.ENDM	$DEQ_G

	.MACRO	$DEQDEF
		$OFFDEF	DEQ,<LKID,VALBLK,ACMODE,FLAGS>
	.ENDM	$DEQDEF

	.MACRO	$DEQ	LKID=0,VALBLK=0,ACMODE=0,FLAGS=0
		$DEQDEF
		.ADDRESS	4
		.ADDRESS	LKID
		.ADDRESS	VALBLK
		.ADDRESS	ACMODE
		.ADDRESS	FLAGS
	.ENDM	$DEQ

	.MACRO	$DEQ_S	LKID=#0,VALBLK=0,ACMODE=#0,FLAGS=#0
		.GLOBL	SYS$DEQ
		$PUSHTWO	FLAGS,ACMODE
		$PUSHADR	VALBLK
		PUSHL	LKID
		CALLS	#4,G^SYS$DEQ
	.ENDM	$DEQ_S

;
; DELETE GLOBAL SECTION
;
;	FLAGS	- MASK INDICATING GLOBAL SECTION CHARACTERISTICS
;	GSDNAM	- ADDRESS OF STRING DESCRIPTOR FOR SECTION NAME STRING
;	IDENT - ADDRESS OF QUADWORD IDENTIFICATION
;

	.MACRO	$DGBLSC_G ARGPTR
		.GLOBL	SYS$DGBLSC
		CALLG	ARGPTR,G^SYS$DGBLSC
	.ENDM	$DGBLSC_G

	.MACRO	$DGBLSCDEF
		$OFFDEF	DGBLSC,<FLAGS,GSDNAM,IDENT>
	.ENDM	$DGBLSCDEF

	.MACRO	$DGBLSC FLAGS=0,GSDNAM=0,IDENT=0
		$DGBLSCDEF
		.ADDRESS	3
		.ADDRESS	FLAGS
		.ADDRESS	GSDNAM
		.ADDRESS	IDENT
	.ENDM	$DGBLSC

	.MACRO	$DGBLSC_S FLAGS=#0,GSDNAM,IDENT=0
		.GLOBL	SYS$DGBLSC
		$PUSHADR IDENT,CONTEXT=Q
		$PUSHADR GSDNAM,CONTEXT=Q
		PUSHL	FLAGS
		CALLS	#3,G^SYS$DGBLSC
	.ENDM	$DGBLSC_S

;
; DISMOUNT A VOLUME (OR VOLUME SET)
;
;	DEVNAM	- ADDRESS OF A DEVICE NAME DESCRIPTOR
;	FLAGS	- A LONGWORD BIT MASK
;

	.MACRO	$DISMOU_G ARGPTR
		.GLOBL	SYS$DISMOU
		CALLG	ARGPTR,G^SYS$DISMOU
	.ENDM	$DISMOU_G

	.MACRO	$DISMOUDEF
		$OFFDEF	DISMOU,<DEVNAM,FLAGS>
	.ENDM	$DISMOUDEF

	.MACRO	$DISMOU	DEVNAM=0,FLAGS=0
		$DISMOUDEF
		.ADDRESS	2
		.ADDRESS	DEVNAM
		.ADDRESS	FLAGS
	.ENDM	$DISMOU

	.MACRO	$DISMOU_S DEVNAM=0,FLAGS=#0
		.GLOBL	SYS$DISMOU
		PUSHL	FLAGS
		$PUSHADR DEVNAM,CONTEXT=Q
		CALLS	#2,G^SYS$DISMOU
	.ENDM	$DISMOU_S

;
; DELETE COMMON EVENT FLAG CLUSTER
;
;	NAME	- ADDRESS OF TEXT NAME STRING DESCRIPTOR OF PERMANENT CLUSTER
;

	.MACRO	$DLCEFC_G ARGPTR
		.GLOBL	SYS$DLCEFC
		CALLG	ARGPTR,G^SYS$DLCEFC
	.ENDM	$DLCEFC_G

	.MACRO	$DLCEFCDEF
		$OFFDEF DLCEFC, <NAME>
	.ENDM	$DLCEFCDEF

	.MACRO	$DLCEFC NAME=0
		$DLCEFCDEF
		.ADDRESS	1
		.ADDRESS	NAME
	.ENDM	$DLCEFC

	.MACRO	$DLCEFC_S,NAME		
		.GLOBL	SYS$DLCEFC
		$PUSHADR NAME,CONTEXT=Q
		CALLS	#1,G^SYS$DLCEFC		
	.ENDM	$DLCEFC_S		

;
; ENQ - ENQUEUE LOCK SYSTEM SERVICE
;
;	EFN	- NUMBER OF EVENT FLAG TO BE SET ON COMPLETION
;	LKMODE	- LOCK MODE REQUESTED
;	LKSB	- ADDRESS OF LOCK STATUS BLOCK TO RECEIVE COMPLETION
;		  STATUS.  OPTIONAL VALUE BLOCK FOLLOWS LOCK STATUS BLOCK
;	FLAGS	- MASK DEFINING OPTIONAL FLAGS
;	RESNAM	- ADDRESS OF DESCRIPTOR FOR RESOURCE NAME
;	PARID	- LOCK ID OF PARENT LOCK
;	ASTADR	- ENTRY POINT ADDRESS OF COMPLETION AST ROUTINE
;	ASTPRM	- AST PARAMETER TO BE PASSED TO AST ROUTINE
;	BLKAST	- ENTRY POINT ADDRESS OF BLOCKING AST ROUTINE
;	ACMODE	- ACCESS MODE FOR LOCK
;	PROT	- RESERVED FOR FUTURE USE
;

	.MACRO	$ENQ_G	ARGPTR
		.GLOBL	SYS$ENQ
		CALLG	ARGPTR,G^SYS$ENQ
	.ENDM	$ENQ_G

	.MACRO	$ENQDEF
		$OFFDEF	ENQ,<EFN,LKMODE,LKSB,FLAGS,RESNAM,PARID,ASTADR,-
				ASTPRM,BLKAST,ACMODE,PROT>
	.ENDM	$ENQDEF

	.MACRO	$ENQ	EFN=0,LKMODE=0,LKSB=0,FLAGS=0,RESNAM=0,PARID=0,-
			ASTADR=0,ASTPRM=0,BLKAST=0,ACMODE=0,PROT=0
		$ENQDEF
		.ADDRESS	11
		.ADDRESS	EFN
		.ADDRESS	LKMODE
		.ADDRESS	LKSB
		.ADDRESS	FLAGS
		.ADDRESS	RESNAM
		.ADDRESS	PARID
		.ADDRESS	ASTADR
		.ADDRESS	ASTPRM
		.ADDRESS	BLKAST
		.ADDRESS	ACMODE
		.ADDRESS	PROT
	.ENDM	$ENQ

	.MACRO	$ENQ_S	EFN=#0,LKMODE,LKSB,FLAGS=#0,RESNAM=0,PARID=#0,-
			ASTADR=0,ASTPRM=#0,BLKAST=0,ACMODE=#0,PROT=#0
		.GLOBL	SYS$ENQ
		$PUSHTWO PROT,ACMODE
		$PUSHADR BLKAST
		$QIOPUSH ASTPRM,ASTADR
		$QIOPUSH PARID,RESNAM
		PUSHL	FLAGS
		$PUSHADR LKSB,CONTEXT=Q
		PUSHL	LKMODE
		PUSHL	EFN
		CALLS	#11,G^SYS$ENQ
	.ENDM	$ENQ_S

;
; ENQW SYSTEM SERVICE
;
;	SEE ENQ FOR PARAMETER DESCRIPTION
;

	.MACRO	$ENQW_G	ARGPTR
		.GLOBL	SYS$ENQW
		CALLG	ARGPTR,G^SYS$ENQW
	.ENDM	$ENQW_G

	.MACRO	$ENQWDEF
		$OFFDEF	ENQW,<EFN,LKMODE,LKSB,FLAGS,RESNAM,PARID,ASTADR,-
				ASTPRM,BLKAST,ACMODE,PROT>
	.ENDM	$ENQWDEF

	.MACRO	$ENQW	EFN=0,LKMODE=0,LKSB=0,FLAGS=0,RESNAM=0,PARID=0,-
			ASTADR=0,ASTPRM=0,BLKAST=0,ACMODE=0,PROT=0
		$ENQWDEF
		.ADDRESS	11
		.ADDRESS	EFN
		.ADDRESS	LKMODE
		.ADDRESS	LKSB
		.ADDRESS	FLAGS
		.ADDRESS	RESNAM
		.ADDRESS	PARID
		.ADDRESS	ASTADR
		.ADDRESS	ASTPRM
		.ADDRESS	BLKAST
		.ADDRESS	ACMODE
		.ADDRESS	PROT
	.ENDM	$ENQW

	.MACRO	$ENQW_S	EFN=#0,LKMODE,LKSB,FLAGS=#0,RESNAM=0,PARID=#0,-
			ASTADR=0,ASTPRM=#0,BLKAST=0,ACMODE=#0,PROT=#0
		.GLOBL	SYS$ENQW
		$PUSHTWO PROT,ACMODE
		$PUSHADR BLKAST
		$QIOPUSH ASTPRM,ASTADR
		$QIOPUSH PARID,RESNAM
		PUSHL	FLAGS
		$PUSHADR LKSB,CONTEXT=Q
		PUSHL	LKMODE
		PUSHL	EFN
		CALLS	#11,G^SYS$ENQW
	.ENDM	$ENQW_S

;
; EXIT SYSTEM SERVICE - EXIT CURRENT IMAGE
;
;	CODE	- LONGWORD TO BE SAVED IN PROCESS HEADER AS COMPLETION STATUS
;		  OF CURRENT IMAGE ( DEFAULT IS SS$_NORMAL )
;

	.MACRO	$EXIT_G ARGPTR
		.GLOBL	SYS$EXIT
		CALLG	ARGPTR,G^SYS$EXIT
	.ENDM	$EXIT_G

	.MACRO	$EXITDEF
		$OFFDEF EXIT, <CODE>
	.ENDM	$EXITDEF

	.MACRO	$EXIT CODE=1
		$EXITDEF
		.ADDRESS	1
		.ADDRESS	CODE
	.ENDM	$EXIT

	.MACRO	$EXIT_S	CODE=#1
		.GLOBL	SYS$EXIT
		PUSHL	CODE
		CALLS	#1,G^SYS$EXIT
	.ENDM	$EXIT_S

;
; EXPAND PROGRAM/CONTROL REGION
;
;	PAGCNT	- NUMBER OF PAGES TO ADD TO END OF SPECIFIED REGION
;	RETADR	- ADDRESS OF 2-LONGWORD ARRAY TO RECEIVE VIRTUAL ADDRESSES
;		  OF STARTING AND ENDING PAGES OF EXPANDED REGION
;	ACMODE	- ACCESS MODE OF THE NEW PAGES
;	REGION	- REGION INDICATOR
;		  0 -> EXPAND PROGRAM (P0) REGION
;		  1 -> EXPAND CONTROL (P1) REGION
;

	.MACRO	$EXPREG_G ARGPTR
		.GLOBL	SYS$EXPREG
		CALLG	ARGPTR,G^SYS$EXPREG
	.ENDM	$EXPREG_G

	.MACRO	$EXPREGDEF
		$OFFDEF EXPREG, <PAGCNT,RETADR,ACMODE,REGION>
	.ENDM	$EXPREGDEF

	.MACRO	$EXPREG PAGCNT=0,RETADR=0,ACMODE=0,REGION=0
		$EXPREGDEF
		.ADDRESS	4
		.ADDRESS	PAGCNT
		.ADDRESS	RETADR
		.ADDRESS	ACMODE
		.ADDRESS	REGION
	.ENDM	$EXPREG

	.MACRO	$EXPREG_S PAGCNT,RETADR=0,ACMODE=#0,REGION=#0
		.GLOBL	SYS$EXPREG
		PUSHL	REGION
		PUSHL	ACMODE
		$PUSHADR RETADR,CONTEXT=Q
		PUSHL	PAGCNT
		CALLS	#4,G^SYS$EXPREG
	.ENDM	$EXPREG_S

;
; FORMATTED ASCII OUTPUT (FAO)
;
;	CTRSTR	- ADDRESS OF STRING DESCRIPTOR FOR ASCII CONTROL STRING
;	OUTLEN	- ADDRESS OF WORD IN WHICH TO STORE OUTPUT STRING LENGTH
;	OUTBUF	- ADDRESS OF OUTPUT BUFFER STRING DESCRIPTOR
;	P1 ... 	- VARIABLE NUMBER OF ARGUMENTS TO FAO
;
;	NOTE ***** THE LAST ARGUMENT IN THE $FAO_S ARGUMENT LIST
;	(END_VARNUM_ARGS) IS THERE ONLY FOR THE "MARBLI" PROGRAM WHICH CONVERTS
;	THIS FILE INTO BLISS MACROS.  IT INDICATES THE END OF A SERVICE
;	WITH A VARIABLE LENGTH ARGUMENT LIST.
;

	.MACRO	$FAO_G ARGPTR
		.GLOBL	SYS$FAO
		CALLG	ARGPTR,G^SYS$FAO
	.ENDM	$FAO_G

	.MACRO	$FAODEF
		$OFFDEF FAO, <CTRSTR,OUTLEN,OUTBUF,P1,P2,P3,P4,P5,P6,P7,P8,-
			      P9,P10,P11,P12,P13,P14,P15,P16>
	.ENDM	$FAODEF

	.MACRO	$FAO CTRSTR,OUTLEN=0,OUTBUF,P1,P2,P3,P4,P5,P6,P7,P8,P9,-
			P10,P11,P12,P13,P14,P15,P16
		$FAODEF
		$$T1 = 3
		.IRP	$$T2,<P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,-
			P14,P15,P16>
		.IF NB $$T2
		$$T1=$$T1+1
		.ENDC
		.ENDM
		.ADDRESS	$$T1
		.ADDRESS	CTRSTR
		.ADDRESS	OUTLEN
		.ADDRESS	OUTBUF
		.IRP	$$T1,<P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,-
			P14,P15,P16>
		.IF NB $$T1
		.ADDRESS	$$T1
		.ENDC
		.ENDM
	.ENDM	$FAO

	.MACRO	$FAO_S CTRSTR,OUTLEN=0,OUTBUF,P1,P2,P3,P4,P5,P6,P7,P8,P9,-
			P10,P11,P12,P13,P14,P15,P16,END_VARNUM_ARGS
		.GLOBL	SYS$FAO
		$$T2 = 3
		.IRP $$T1,<P16,P15,P14,P13,P12,P11,P10,P9,P8,P7,P6,P5,-
			P4,P3,P2,P1>
		.IF NB $$T1
		PUSHL	$$T1
		$$T2=$$T2+1
		.ENDC
		.ENDM
		$PUSHADR OUTBUF,CONTEXT=Q
		$PUSHADR OUTLEN,CONTEXT=W
		$PUSHADR CTRSTR,CONTEXT=Q
		CALLS	#$$T2,G^SYS$FAO
	.ENDM	$FAO_S

;
; FORMATTED ASCII OUTPUT WITH LIST PARAMETER (FAOL)
;
;	CTRSTR	- ADDRESS OF STRING DESCRIPTOR FOR CONTROL STRING
;	OUTLEN	- ADDRESS OF WORD TO RECEIVE OUTPUT STRING LENGTH
;	OUTBUF	- ADDRESS OF OUTPUT BUFFER STRING DESCRIPTOR
;	PRMLST	- ADDRESS OF A LIST OF LONGWORD PARAMETERS 
;

	.MACRO	$FAOL_G ARGPTR
		.GLOBL	SYS$FAOL
		CALLG	ARGPTR,G^SYS$FAOL
	.ENDM	$FAOL_G

	.MACRO	$FAOLDEF
		$OFFDEF FAOL, <CTRSTR,OUTLEN,OUTBUF,PRMLST>
	.ENDM	$FAOLDEF

	.MACRO	$FAOL CTRSTR=0,OUTLEN=0,OUTBUF=0,PRMLST=0
		$FAOLDEF
		.ADDRESS	4
		.ADDRESS	CTRSTR
		.ADDRESS	OUTLEN
		.ADDRESS	OUTBUF
		.ADDRESS	PRMLST
	.ENDM	$FAOL

	.MACRO	$FAOL_S CTRSTR,OUTLEN=0,OUTBUF,PRMLST
		.GLOBL	SYS$FAOL
		$PUSHADR PRMLST
		$PUSHADR OUTBUF,CONTEXT=Q
		$PUSHADR OUTLEN,CONTEXT=W
		$PUSHADR CTRSTR,CONTEXT=Q
		CALLS	#4,G^SYS$FAOL
	.ENDM	$FAOL_S

;
; FORCE EXIT
;
;	PIDADR	- ADDRESS OF THE PID OF PROCESS TO BE FORCED
;	PRCNAM	- ADDRESS OF PROCESS NAME STRING DESCRIPTOR FOR FORCED PROCESS
;	CODE	- LONGWORD COMPLETION STATUS FOR EXIT SERVICE
;

	.MACRO	$FORCEX_G ARGPTR
		.GLOBL	SYS$FORCEX
		CALLG	ARGPTR,G^SYS$FORCEX
	.ENDM	$FORCEX_G

	.MACRO	$FORCEXDEF
		$OFFDEF FORCEX, <PIDADR,PRCNAM,CODE>
	.ENDM	$FORCEXDEF

	.MACRO	$FORCEX PIDADR=0,PRCNAM=0,CODE=0
		$FORCEXDEF
		.ADDRESS	3
		.ADDRESS	PIDADR
		.ADDRESS	PRCNAM
		.ADDRESS	CODE
	.ENDM	$FORCEX

	.MACRO	$FORCEX_S PIDADR=0,PRCNAM=0,CODE=#0
		.GLOBL	SYS$FORCEX
		PUSHL	CODE
		$PUSHADR PRCNAM,CONTEXT=Q
		$PUSHADR PIDADR
		CALLS	#3,G^SYS$FORCEX
	.ENDM	$FORCEX_S

;
; GET CHANNEL INFORMATION
;
;	CHAN - CHANNEL NUMBER 
;	PRILEN - ADDRESS TO STORE LENGTH OF PRIMARY DEVICE INFORMATION RETURNED
;	PRIBUF - ADDRESS OF BUFFER DESCRIPTOR FOR PRIMARY DEVICE BUFFER
;	SCDLEN - ADDRESS TO STORE LENGTH OF SECONDARY DEVICE INFORMATION
;	SCDBUF - ADDRESS OF SECONDARY BUFFER DESCRIPTOR
;

	.MACRO	$GETCHN_G ARGPTR
		.GLOBL	SYS$GETCHN
		CALLG	ARGPTR,G^SYS$GETCHN
	.ENDM	$GETCHN_G

	.MACRO	$GETCHNDEF
		$OFFDEF GETCHN,<CHAN,PRILEN,PRIBUF,SCDLEN,SCDBUF>
	.ENDM	$GETCHNDEF

	.MACRO	$GETCHN CHAN=0,PRILEN=0,PRIBUF=0,SCDLEN=0,SCDBUF=0
		$GETCHNDEF
		.ADDRESS	5
		.ADDRESS	CHAN
		.ADDRESS	PRILEN
		.ADDRESS	PRIBUF
		.ADDRESS	SCDLEN
		.ADDRESS	SCDBUF
	.ENDM	$GETCHN

	.MACRO	$GETCHN_S CHAN,PRILEN=0,PRIBUF=0,SCDLEN=0,SCDBUF=0
		.GLOBL	SYS$GETCHN
		$PUSHADR SCDBUF,CONTEXT=Q
		$PUSHADR SCDLEN,CONTEXT=W
		$PUSHADR PRIBUF,CONTEXT=Q
		$PUSHADR PRILEN,CONTEXT=W
		MOVZWL	CHAN,-(SP)
		CALLS	#5,G^SYS$GETCHN
	.ENDM	$GETCHN_S

;
; GET DEVICE INFORMATION
;
;	DEVNAM - ADDRESS OF DEVICE NAME DESCRIPTOR
;	PRILEN - ADDRESS OF WORD TO RECEIVE LENGTH OF RETURNED INFORMATION
;	PRIBUF - ADDRESS OF DESCRIPTOR FOR PRIMARY DEVICE INFORMATION BUFFER
;	SCDLEN - ADDRESS OF WORD TO RECEIVE LENGTH OF SECONDARY INFORMATION
;	SCDBUF - ADDRESS OF DESCRIPTOR FOR SECONDARY DEVICE INFORMATION BUFFER
;

	.MACRO	$GETDEV_G ARGPTR
		.GLOBL	SYS$GETDEV
		CALLG	ARGPTR,G^SYS$GETDEV
	.ENDM	$GETDEV_G

	.MACRO	$GETDEVDEF
		$OFFDEF GETDEV,<DEVNAM,PRILEN,PRIBUF,SCDLEN,SCDBUF>
	.ENDM	$GETDEVDEF

	.MACRO	$GETDEV DEVNAM=0,PRILEN=0,PRIBUF=0,SCDLEN=0,SCDBUF=0
		$GETDEVDEF
		.ADDRESS	5
		.ADDRESS	DEVNAM
		.ADDRESS	PRILEN
		.ADDRESS	PRIBUF
		.ADDRESS	SCDLEN
		.ADDRESS	SCDBUF
	.ENDM	$GETDEV

	.MACRO	$GETDEV_S DEVNAM,PRILEN=0,PRIBUF=0,SCDLEN=0,SCDBUF=0
		.GLOBL	SYS$GETDEV
		$PUSHADR SCDBUF,CONTEXT=Q
		$PUSHADR SCDLEN,CONTEXT=W
		$PUSHADR PRIBUF,CONTEXT=Q
		$PUSHADR PRILEN,CONTEXT=W
		$PUSHADR DEVNAM,CONTEXT=Q
		CALLS	#5,G^SYS$GETDEV
	.ENDM	$GETDEV_S

;
; GET DEVICE AND VOLUME INFORMATION
;
;	EFN - EVENT FLAG TO BE SET WHEN INFORMATION IS RETURNED
;	CHAN - CHANNEL TO WHICH DEVICE IS ASSIGNED
;	       OR 0 IF DEVNAM PARAMETER IS SPECIFIED
;	DEVNAM - ADDRESS OF DEVICE NAME OR LOGICAL DEVICE NAME
;		 STRING DESCRIPTOR, USED ONLY IF CHAN PARAMETER IS 0.
;	ITMLST - ADDRESS OF A LIST OF ITEM DESCRIPTORS FOR THE INFORMATION
;		REQUESTED
;	IOSB - ADDRESS OF A QUADWORD I/O STATUS BLOCK TO RECEIVE
;		THE FINAL STATUS
;	ASTADR - ADDRESS OF AN AST ROUTINE TO BE CALLED WHEN INFORMATION IS
;		RETURNED
;	ASTPRM - ADDRESS OF A 32 BIT AST PARAMETER
;	NULLARG - RESERVED ARGUMENT FOR WILD DEVICE CONTEXT
;

	.MACRO	$GETDVI_G ARGPTR
		.GLOBL	SYS$GETDVI
		CALLG	ARGPTR,G^SYS$GETDVI
	.ENDM	$GETDVI_G

	.MACRO	$GETDVIDEF
		$OFFDEF	GETDVI,<EFN,CHAN,DEVNAM,ITMLST,IOSB,-;
				ASTADR,ASTPRM,NULLARG>
	.ENDM	$GETDVIDEF

	.MACRO	$GETDVI	EFN=0,CHAN=0,DEVNAM=0,ITMLST=0,IOSB=0,-
			ASTADR=0,ASTPRM=0,NULLARG=0
		$GETDVIDEF
		.ADDRESS	8
		.ADDRESS	EFN
		.ADDRESS	CHAN
		.ADDRESS	DEVNAM
		.ADDRESS	ITMLST
		.ADDRESS	IOSB
		.ADDRESS	ASTADR
		.ADDRESS	ASTPRM
		.ADDRESS	NULLARG
	.ENDM	$GETDVI

	.MACRO	$GETDVI_S EFN=#0,CHAN=#0,DEVNAM=0,ITMLST,IOSB=0,-
			ASTADR=0,ASTPRM=#0,NULLARG=0
		.GLOBL	SYS$GETDVI
		$PUSHADR NULLARG,CONTEXT=Q
		$QIOPUSH ASTPRM,ASTADR
		$PUSHADR IOSB,CONTEXT=Q
		$PUSHADR ITMLST,CONTEXT=L
		$PUSHADR DEVNAM,CONTEXT=Q
		MOVZWL	CHAN,-(SP)
		PUSHL	EFN
		CALLS	#8,G^SYS$GETDVI
	.ENDM	$GETDVI_S
;
; GET JOB PROCESS INFORMATION
;
;	EFN - EVENT FLAG TO BE SET WHEN INFORMATION IS RETURNED (NOT USED NOW)
;	PIDADR - ADDRESS OF A LONGWORD CONTAINING THE PROCESS ID OF THE PROCESS
;		FOR WHICH INFORMATION IS REQUESTED
;	PRCNAM - ADDRESS OF A STRING DESCRIPTOR FOR THE PROCESS NAME OF THE
;		PROCESS FOR WHICH INFORMATION IS REQUESTED
;	ITMLST - ADDRESS OF A LIST OF ITEM DESCRIPTORS FOR THE INFORMATION
;		REQUESTED
;	IOSB - ADDRESS OF A QUADWORD I/O STATUS BLOCK TO RECEIVE
;		THE FINAL STATUS (NOT USED NOW)
;	ASTADR - ADDRESS OF AN AST ROUTINE TO BE CALLED WHEN INFORMATION IS
;		RETURNED (NOT USED NOW)
;	ASTPRM - ADDRESS OF A 32 BIT AST PARAMETER (NOT USED NOW)
;

	.MACRO	$GETJPI_G ARGPTR
		.GLOBL	SYS$GETJPI
		CALLG	ARGPTR,G^SYS$GETJPI
	.ENDM	$GETJPI_G

	.MACRO	$GETJPIDEF
		$OFFDEF	GETJPI,<EFN,PIDADR,PRCNAM,ITMLST,IOSB,ASTADR,ASTPRM>
	.ENDM	$GETJPIDEF

	.MACRO	$GETJPI	EFN=0,PIDADR=0,PRCNAM=0,ITMLST=0,IOSB=0,ASTADR=0,ASTPRM=0
		$GETJPIDEF
		.ADDRESS	7
		.ADDRESS	EFN
		.ADDRESS	PIDADR
		.ADDRESS	PRCNAM
		.ADDRESS	ITMLST
		.ADDRESS	IOSB
		.ADDRESS	ASTADR
		.ADDRESS	ASTPRM
	.ENDM	$GETJPI

	.MACRO	$GETJPI_S EFN=#0,PIDADR=0,PRCNAM=0,ITMLST,IOSB=0,ASTADR=0,-
			ASTPRM=#0
		.GLOBL	SYS$GETJPI
		$QIOPUSH ASTPRM,ASTADR
		$PUSHADR IOSB,CONTEXT=Q
		$PUSHADR ITMLST,CONTEXT=L
		$PUSHADR PRCNAM,CONTEXT=Q
		$PUSHADR PIDADR,CONTEXT=L
		PUSHL	EFN
		CALLS	#7,G^SYS$GETJPI
	.ENDM	$GETJPI_S

;
; GET MESSAGE
;
;	MSGID	- IDENTIFICATION OF MESSAGE TO BE RETRIEVED
;	MSGLEN	- ADDRESS OF A WORD TO RECEIVE NUMBER OF BYTES TRANSFERRED
;	BUFADR	- ADDRESS OF BUFFER DESCRIPTOR
;	FLAGS	- FLAG INDICATORS FOR SELECTING TEXT, ID, SEVERITY
;	OUTADR	- ADDRESS OF 4 BYTE OUTPUT ARRAY FOR RETURN INFORMATION
;

	.MACRO	$GETMSG_G ARGPTR
		.GLOBL	SYS$GETMSG
		CALLG	ARGPTR,G^SYS$GETMSG
	.ENDM	$GETMSG_G

	.MACRO	$GETMSGDEF
		$OFFDEF GETMSG, <MSGID,MSGLEN,BUFADR,FLAGS,OUTADR>
	.ENDM	$GETMSGDEF

	.MACRO	$GETMSG MSGID=0,MSGLEN=0,BUFADR=0,FLAGS=15,OUTADR=0
		$GETMSGDEF
		.ADDRESS	5
		.ADDRESS	MSGID
		.ADDRESS	MSGLEN
		.ADDRESS	BUFADR
		.ADDRESS	FLAGS
		.ADDRESS	OUTADR
	.ENDM	$GETMSG

	.MACRO	$GETMSG_S MSGID,MSGLEN,BUFADR,FLAGS=#15,OUTADR=0
		.GLOBL	SYS$GETMSG
		$PUSHADR OUTADR
		PUSHL	FLAGS
		$PUSHADR BUFADR,CONTEXT=Q
		$PUSHADR MSGLEN,CONTEXT=W
		PUSHL	MSGID
		CALLS	#5,G^SYS$GETMSG
	.ENDM	$GETMSG_S

;
; GET PAGE TABLE INFORMATION
;
;	INADR - ADDRESS 2 LONGWORDS CONTAINING STARTING AND ENDING VIRTUAL
;		ADDRESS TO OPERATE ON
;	RETADR - ADDRESS OF 2 LONGWORDS INTO WHICH STARTING AND ENDING ADDRESS
;		OF PAGES OPERATED ON IS RETURNED
;	ACMODE - ACCESS MODE AGAINST WHICH OWNERSHIP IS CHECKED
;	MASK - MASK OF PAGE TABLE INFORMATION CONTROL BITS
;	PAGCNT - MINIMUM PAGE COUNT
;

	.MACRO	$GETPTI_G ARGPTR
		.GLOBL	SYS$GETPTI
		CALLG	ARGPTR,G^SYS$GETPTI
	.ENDM	$GETPTI_G

	.MACRO	$GETPTIDEF
		$OFFDEF GETPTI,<INADR,RETADR,ACMODE,MASK,PAGCNT>
	.ENDM	$GETPTIDEF

	.MACRO	$GETPTI INADR=0,RETADR=0,ACMODE=0,MASK=0,PAGCNT=0
		$GETPTIDEF
		.ADDRESS	5
		.ADDRESS	INADR
		.ADDRESS	RETADR
		.ADDRESS	ACMODE
		.ADDRESS	MASK
		.ADDRESS	PAGCNT
	.ENDM	$GETPTI

	.MACRO	$GETPTI_S INADR,RETADR=0,ACMODE=#0,MASK=#0,PAGCNT=#0
		.GLOBL	SYS$GETPTI
		PUSHL	PAGCNT
		PUSHL	MASK
		PUSHL	ACMODE
		$PUSHADR RETADR,CONTEXT=Q
		$PUSHADR INADR,CONTEXT=Q
		CALLS	#5,G^SYS$GETPTI
	.ENDM	$GETPTI_S

;
; GET SYSTEM INFORMATION
;
;	EFN - EVENT FLAG TO BE SET WHEN INFORMATION IS RETURNED
;	NULLARG1 - ADDRESS OF A NULL ARGUMENT. RESERVED FOR FUTURE USE.
;	NULLARG2 - ADDRESS OF A NULL ARGUMENT. RESERVED FOR FUTURE USE.
;	ITMLST - ADDRESS OF A LIST OF ITEM DESCRIPTORS FOR THE INFORMATION
;		REQUESTED
;	IOSB - ADDRESS OF A QUADWORD I/O STATUS BLOCK TO RECEIVE
;		THE FINAL STATUS
;	ASTADR - ADDRESS OF AN AST ROUTINE TO BE CALLED WHEN INFORMATION IS
;		RETURNED
;	ASTPRM - ADDRESS OF A 32 BIT AST PARAMETER
;

	.MACRO	$GETSYI_G ARGPTR
		.GLOBL	SYS$GETSYI
		CALLG	ARGPTR,G^SYS$GETSYI
	.ENDM	$GETSYI_G

	.MACRO	$GETSYIDEF
		$OFFDEF	GETSYI,<EFN,NULLARG1,NULLARG2,ITMLST,IOSB,ASTADR,ASTPRM>
	.ENDM	$GETSYIDEF

	.MACRO	$GETSYI	EFN=0,NULLARG1=0,NULLARG2=0,ITMLST=0, -
			IOSB=0,ASTADR=0,ASTPRM=0
		$GETSYIDEF
		.ADDRESS	7
		.ADDRESS	EFN
		.ADDRESS	NULLARG1
		.ADDRESS	NULLARG2
		.ADDRESS	ITMLST
		.ADDRESS	IOSB
		.ADDRESS	ASTADR
		.ADDRESS	ASTPRM
	.ENDM	$GETSYI

	.MACRO	$GETSYI_S EFN=#0,NULLARG1=0,NULLARG2=0,ITMLST, -
			  IOSB=0,ASTADR=0,ASTPRM=#0
		.GLOBL	SYS$GETSYI
		$QIOPUSH ASTPRM,ASTADR
		$PUSHADR IOSB,CONTEXT=Q
		$PUSHADR ITMLST,CONTEXT=L
		CLRQ	-(SP)
		PUSHL	EFN
		CALLS	#7,G^SYS$GETSYI
	.ENDM	$GETSYI_S

;
; GET TIME
;
;	TIMADR	- ADDRESS OF A QUADWORD TO RECEIVE 64 BIT TIME
;

	.MACRO	$GETTIM_G ARGPTR
		.GLOBL	SYS$GETTIM
		CALLG	ARGPTR,G^SYS$GETTIM
	.ENDM	$GETTIM_G

	.MACRO	$GETTIMDEF
		$OFFDEF GETTIM, <TIMADR>
	.ENDM	$GETTIMDEF

	.MACRO	$GETTIM TIMADR=0
		$GETTIMDEF
		.ADDRESS	1
		.ADDRESS	TIMADR
	.ENDM	$GETTIM

	.MACRO	$GETTIM_S TIMADR
		.GLOBL	SYS$GETTIM
		$PUSHADR TIMADR,CONTEXT=Q
		CALLS	#1,G^SYS$GETTIM
	.ENDM	$GETTIM_S

;
; HIBERNATE
;
;	NOTE **** ONLY THE _S FORM IS SUPPLIED
;

	.MACRO	$HIBER_S	
		.GLOBL	SYS$HIBER
		CALLS	#0,G^SYS$HIBER	
	.ENDM	$HIBER_S

;
; IMGACT SYSTEM SERVICE - IMAGE ACTIVATOR
;
;	NAME - ADDRESS OF DESCRIPTOR FOR FILE NAME STRING
;	DFLNAM  - DESCRIPTOR FOR DEFAULT FILE NAME STRING
;	HDRBUF - ADDRESS OF 512 BYTE BUFFER TO WRITE IN
;	IMGCTL - IMAGE ACTIVATION CONTROL FLAGS
;	INADR - ADR OF QUADWORD SPECIFYING VIRTUAL ADDRESS RANGE TO BE MAPPED
;	RETADR - ADR OF QUADWORD TO HOLD VIRTUAL ADDRESS RANGE ACTUALLY MAPPED
;	IDENT - ADR OF QUADWORD HOLDING IMAGE SECTION MATCH CONTROL AND IDENT
;	ACMODE - ACCESS MODE TO BE THE OWNER OF THE CREATED PAGES
;

	.MACRO	$IMGACT_G ARGPTR
		.GLOBL	SYS$IMGACT
		CALLG	ARGPTR,G^SYS$IMGACT
	.ENDM	$IMGACT_G

	.MACRO	$IMGACTDEF
		$OFFDEF IMGACT,<NAME,DFLNAM,HDRBUF,IMGCTL,INADR,RETADR,IDENT,ACMODE>
	.ENDM	$IMGACTDEF

	.MACRO	$IMGACT NAME=0,DFLNAM=0,HDRBUF=0,IMGCTL=0,INADR=0,RETADR=0,-
			IDENT=0,ACMODE=0
		$IMGACTDEF
		.ADDRESS	8
		.ADDRESS	NAME
		.ADDRESS	DFLNAM
		.ADDRESS 	HDRBUF
		.ADDRESS	IMGCTL
		.ADDRESS	INADR
		.ADDRESS	RETADR
		.ADDRESS	IDENT
		.ADDRESS	ACMODE
	.ENDM	$IMGACT

	.MACRO	$IMGACT_S NAME,DFLNAM,HDRBUF,IMGCTL=#0,INADR=0,RETADR=0,-
			IDENT=0,ACMODE=#0
		.GLOBL	SYS$IMGACT
		PUSHL	ACMODE
		$PUSHADR IDENT,CONTEXT=Q
		$PUSHADR RETADR,CONTEXT=Q
		$PUSHADR INADR,CONTEXT=Q
		PUSHL	IMGCTL
		$PUSHADR HDRBUF
		$PUSHADR DFLNAM,CONTEXT=Q
		$PUSHADR NAME,CONTEXT=Q
		CALLS	#8,G^SYS$IMGACT
	.ENDM	$IMGACT_S

;
; IMGFIX - IMAGE ADDRESS FIXUP SERVICE
;
;	NOTE **** ONLY THE _S FORM IS SUPPLIED
;

	.MACRO	$IMGFIX_S	
		.GLOBL	SYS$IMGFIX
		CALLS	#0,G^SYS$IMGFIX	
	.ENDM	$IMGFIX_S

;
; $INPUT - SHORT FORM FOR QIO AND WAIT WITH READ LOGICAL BLOCK FUNCTION
;
;	CHAN	- CHANNEL ON WHICH I/O IS TO BE PERFORMED
;	LENGTH	- LENGTH OF THE INPUT BUFFER
;	BUFFER	- ADDRESS OF THE INPUT BUFFER
;	IOSB	- ADDRESS OF QUADWORD I/O STATUS BLOCK
;	EFN	- (OPTIONAL) EVENT FLAG TO WAIT ON (DEFAULT IS ZERO)
;

	.MACRO	$INPUT CHAN,LENGTH,BUFFER,IOSB=0,EFN=#0
		$IODEF
		.GLOBL	SYS$QIOW
		CLRQ	-(SP)
		CLRQ	-(SP)
		PUSHL	LENGTH
		$PUSHADR BUFFER
		CLRQ	-(SP)
		$PUSHADR IOSB,CONTEXT=Q
		MOVZWL	#IO$_READVBLK,-(SP)
		MOVZWL	CHAN,-(SP)
		PUSHL	EFN
		CALLS	#12,G^SYS$QIOW
	.ENDM	$INPUT

;
; LOCK PAGES IN MEMORY
;
;	INADR - ADDRESS OF 2-LONGWORD ARRAY CONTAINING STARTING AND
;		ENDING VIRTUAL ADDRESSES OF PAGES TO BE LOCKED
;	RETADR - ADDRESS OF A 2-LONGWORD ARRAY TO RECEIVE STARTING AND
;		ENDING VIRTUAL ADDRESSES OF PAGES ACTUALLY LOCKED
;	ACMODE - ACCESS MODE TO BE CHECKED AGAINST THE PAGE OWNER
;

	.MACRO	$LCKPAG_G ARGPTR
		.GLOBL	SYS$LCKPAG
		CALLG	ARGPTR,G^SYS$LCKPAG
	.ENDM	$LCKPAG_G

	.MACRO	$LCKPAGDEF
		$OFFDEF LCKPAG,<INADR,RETADR,ACMODE>
	.ENDM	$LCKPAGDEF

	.MACRO	$LCKPAG INADR=0,RETADR=0,ACMODE=0
		$LCKPAGDEF
		.ADDRESS	3
		.ADDRESS	INADR
		.ADDRESS	RETADR
		.ADDRESS	ACMODE
	.ENDM	$LCKPAG

	.MACRO	$LCKPAG_S INADR,RETADR=0,ACMODE=#0
		.GLOBL	SYS$LCKPAG
		PUSHL	ACMODE
		$PUSHADR RETADR,CONTEXT=Q
		$PUSHADR INADR,CONTEXT=Q
		CALLS	#3,G^SYS$LCKPAG
	.ENDM	$LCKPAG_S

;
; LOCK PAGES IN WORKING SET
;
;	INADR	- ADDRESS OF 2-LONGWORD ARRAY CONTAINING STARTING AND
;		  ENDING VIRTUAL ADDRESSES OF PAGES TO BE LOCKED
;	RETADR	- ADDRESS OF A 2-LONGWORD ARRAY TO RECEIVE STARTING
;		  AND ENDING VIRTUAL ADDRESSES OF PAGES ACTUALLY LOCKED
;	ACMODE  - ACCESS MODE TO BE CHECKED AGAINST THE PAGE OWNER
;
	.MACRO	$LKWSET_G ARGPTR
		.GLOBL	SYS$LKWSET
		CALLG	ARGPTR,G^SYS$LKWSET
	.ENDM	$LKWSET_G

	.MACRO	$LKWSETDEF
		$OFFDEF LKWSET, <INADR,RETADR,ACMODE>
	.ENDM	$LKWSETDEF

	.MACRO	$LKWSET INADR=0,RETADR=0,ACMODE=0
		$LKWSETDEF
		.ADDRESS	3
		.ADDRESS	INADR
		.ADDRESS	RETADR
		.ADDRESS	ACMODE
	.ENDM	$LKWSET

	.MACRO	$LKWSET_S INADR,RETADR=0,ACMODE=#0
		.GLOBL	SYS$LKWSET
		PUSHL	ACMODE
		$PUSHADR RETADR,CONTEXT=Q
		$PUSHADR INADR,CONTEXT=Q
		CALLS	#3,G^SYS$LKWSET
	.ENDM	$LKWSET_S

;
; MAP GLOBAL SECTION
;
;	INADR - ADDRESS OF 2-LONGWORD ARRAY CONTAINING STARTING AND 
;		ENDING VIRTUAL ADDRESSES INTO WHICH THE SECTION WILL BE
;		MAPPED
;	RETADR - ADDRESS OF OPTIONAL 2-LONGWORD ARRAY TO RECEIVE THE
;		 STARTING AND ENDING VAs ACTUALLY MAPPED
;	ACMODE - ACCESS MODE TO BE THE OWNER OF THE CREATED PAGES
;	FLAGS  - MASK DEFINING THE SECTION TYPE AND CHARACTERISTICS
;	GSDNAM - ADDRESS OF THE SECTION NAME DESCRIPTOR
;	IDENT  - ADDRESS OF QUADWORD VERSION IDENTIFICATION
;	RELPAG - RELATIVE PAGE WITHIN SECTION
;

	.MACRO	$MGBLSC_G ARGPTR
		.GLOBL	SYS$MGBLSC
		CALLG	ARGPTR,G^SYS$MGBLSC
	.ENDM	$MGBLSC_G

	.MACRO	$MGBLSCDEF 
		$OFFDEF MGBLSC,<INADR,RETADR,ACMODE,FLAGS,GSDNAM,IDENT,RELPAG>
	.ENDM	$MGBLSCDEF

	.MACRO	$MGBLSC INADR=0,RETADR=0,ACMODE=0,FLAGS=0,GSDNAM=0,IDENT=0,-
		RELPAG=0
		$MGBLSCDEF
		.ADDRESS	7
		.ADDRESS	INADR
		.ADDRESS	RETADR
		.ADDRESS	ACMODE
		.ADDRESS	FLAGS
		.ADDRESS	GSDNAM
		.ADDRESS	IDENT
		.ADDRESS	RELPAG
	.ENDM	$MGBLSC

	.MACRO	$MGBLSC_S INADR,RETADR=0,ACMODE=#0,FLAGS=#0,GSDNAM,IDENT=0,-
		RELPAG=#0
		.GLOBL	SYS$MGBLSC
		PUSHL	RELPAG
		$PUSHADR IDENT,CONTEXT=Q
		$PUSHADR GSDNAM,CONTEXT=Q
		PUSHL	FLAGS
		PUSHL	ACMODE
		$PUSHADR RETADR,CONTEXT=Q
		$PUSHADR INADR,CONTEXT=Q
		CALLS	#7,G^SYS$MGBLSC
	.ENDM	$MGBLSC_S


;
; MOUNT A VOLUME OR VOLUME SET
;
;	ITMLST	- Address of a $GETJPI-like item list


	.MACRO	$MOUNT_G ARGPTR
		.GLOBL	SYS$MOUNT
		CALLG	ARGPTR,G^SYS$MOUNT
	.ENDM	$MOUNT_G

	.MACRO	$MOUNTDEF
		$OFFDEF MOUNT,<ITMLST>
	.ENDM	$MOUNTDEF

	.MACRO	$MOUNT	ITMLST=0
		$MOUNTDEF
		.ADDRESS	1
		.ADDRESS	ITMLST
	.ENDM	$MOUNT

	.MACRO	$MOUNT_S ITMLST=0
		.GLOBL	 SYS$MOUNT
		$PUSHADR ITMLST,CONTEXT=L
		CALLS	#1,G^SYS$MOUNT
	.ENDM	$MOUNT_S
;
; CONVERT TIME TO NUMERIC
;
; 	TIMBUF	- ADDRESS OF A 7-WORD BUFFER TO RECEIVE NUMERIC TIME
;		  INFORMATION.
;	TIMADR	- ADDRESS OF A QUADWORD CONTAINING THE 64-BIT TIME
;		  (DEFAULT IS CURRENT TIME)
;

	.MACRO	$NUMTIM_G ARGPTR
		.GLOBL	SYS$NUMTIM
		CALLG	ARGPTR,G^SYS$NUMTIM
	.ENDM	$NUMTIM_G

	.MACRO	$NUMTIMDEF
		$OFFDEF NUMTIM,<TIMBUF,TIMADR>
	.ENDM	$NUMTIMDEF

	.MACRO	$NUMTIM TIMBUF=0,TIMADR=0
		$NUMTIMDEF
		.ADDRESS	2
		.ADDRESS	TIMBUF
		.ADDRESS	TIMADR
	.ENDM	$NUMTIM

	.MACRO	$NUMTIM_S TIMBUF,TIMADR=0
		.GLOBL	SYS$NUMTIM
		$PUSHADR TIMADR,CONTEXT=Q
		$PUSHADR TIMBUF
		CALLS	#2,G^SYS$NUMTIM
	.ENDM	$NUMTIM_S

;
; $OUTPUT - SHORT FORM FOR QIO AND WAIT WITH WRITE VIRTUAL BLOCK
;
;	CHAN	- CHANNEL ON WHICH I/O IS DIRECTED
;	LENGTH	- LENGTH OF THE OUTPUT BUFFER
;	BUFFER	- ADDRESS OF THE OUTPUT BUFFER
;	IOSB	- (OPTIONAL) I/O STATUS BLOCK ADDRESS
;	EFN	- (OPTIONAL) EVENT FLAG NUMBER TO WAIT (DEFAULT IS 0)

;

	.MACRO	$OUTPUT CHAN,LENGTH,BUFFER,IOSB=0,EFN=#0
		$IODEF
		.GLOBL	SYS$QIOW
		CLRQ	-(SP)
		PUSHL	#32
		PUSHL	#0
		PUSHL	LENGTH
		$PUSHADR BUFFER
		CLRQ	-(SP)
		$PUSHADR IOSB,CONTEXT=Q
		MOVZWL	#IO$_WRITEVBLK,-(SP)
		MOVZWL	CHAN,-(SP)
		PUSHL	EFN
		CALLS	#12,G^SYS$QIOW
	.ENDM	$OUTPUT

;
; PURGE WORKING SET
;
;	INADR - ADDRESS OF TWO LONGWORD ARRAY OF STARTING AND ENDING ADDRESS
;

	.MACRO	$PURGWS_G ARGPTR
		.GLOBL	SYS$PURGWS
		CALLG	ARGPTR,G^SYS$PURGWS
	.ENDM	$PURGWS_G

	.MACRO	$PURGWSDEF
		$OFFDEF PURGWS,<INADR>
	.ENDM	$PURGWSDEF

	.MACRO	$PURGWS INADR=0
		$PURGWSDEF
		.ADDRESS	1
		.ADDRESS	INADR
	.ENDM	$PURGWS

	.MACRO	$PURGWS_S INADR
		.GLOBL	SYS$PURGWS
		$PUSHADR INADR,CONTEXT=Q
		CALLS	#1,G^SYS$PURGWS
	.ENDM	$PURGWS_S

;
; PUT MESSAGE SYSTEM SERVICE
;
;	MSGVEC - ADDRESS OF MESSAGE ARGUMENT VECTOR
;	ACTRTN - ADDRESS OF USER-SUPPLIED ACTION ROUTINE
;	FACNAM - ADDRESS OF FACILITY NAME STRING DESCRIPTOR
;

	.MACRO	$PUTMSG_G ARGPTR
		.GLOBL	SYS$PUTMSG
		CALLG	ARGPTR,G^SYS$PUTMSG
	.ENDM	$PUTMSG_G

	.MACRO	$PUTMSGDEF
		$OFFDEF PUTMSG,<MSGVEC,ACTRTN,FACNAM,ACTPRM>
	.ENDM	$PUTMSGDEF

	.MACRO	$PUTMSG MSGVEC=0,ACTRTN=0,FACNAM=0,ACTPRM=0
		$PUTMSGDEF
		.ADDRESS	4
		.ADDRESS	MSGVEC
		.ADDRESS	ACTRTN
		.ADDRESS	FACNAM
		.ADDRESS	ACTPRM
	.ENDM	$PUTMSG

	.MACRO	$PUTMSG_S MSGVEC,ACTRTN=0,FACNAM=0,ACTPRM=#0
		.GLOBL	SYS$PUTMSG
		PUSHL	ACTPRM
		$PUSHADR FACNAM,CONTEXT=Q
		$PUSHADR ACTRTN
		$PUSHADR MSGVEC
		CALLS	#4,G^SYS$PUTMSG
	.ENDM	$PUTMSG_S

;
; QIO SYSTEM SERVICE
;
;	EFN	- NUMBER OF EVENT FLAG TO SET ON COMPLETION
;	CHAN	- NUMBER OF CHANNEL ON WHICH I/O IS DIRECTED
;	FUNC	- FUNCTION CODE SPECIFYING ACTION TO BE PERFORMED
;	IOSB	- ADDRESS OF QUADWORD I/O STATUS BLOCK TO RECEIVE FINAL
;		  COMPLETION STATUS INFORMATION
;	ASTADR	- ENTRY POINT ADDRESS OF AST ROUTINE
;	ASTPRM	- AST PARAMETER TO BE PASSED TO AST ROUTINE
;	P1 TO P6 - OPTIONAL DEVICE AND FUNCTION SPECIFIC PARAMETERS
;

	.MACRO	$QIO_G ARGPTR
		.GLOBL	SYS$QIO
		CALLG	ARGPTR,G^SYS$QIO
	.ENDM	$QIO_G

	.MACRO	$QIODEF
		$OFFDEF QIO, <EFN,CHAN,FUNC,IOSB,ASTADR,ASTPRM,P1,P2,P3,-
				P4,P5,P6>
	.ENDM	$QIODEF

	.MACRO	$QIO EFN=0,CHAN=0,FUNC=0,IOSB=0,ASTADR=0,ASTPRM=0,-
		       P1=0,P2=0,P3=0,P4=0,P5=0,P6=0
		$QIODEF
		.ADDRESS 12
		.ADDRESS	EFN
		.ADDRESS	CHAN
		.ADDRESS	FUNC
		.ADDRESS	IOSB
		.ADDRESS	ASTADR
		.ADDRESS	ASTPRM
		.ADDRESS	P1
		.ADDRESS	P2
		.ADDRESS	P3
		.ADDRESS	P4
		.ADDRESS	P5
		.ADDRESS	P6
	.ENDM	$QIO

	.MACRO	$QIO_S	EFN=#0,CHAN,FUNC,IOSB=0,ASTADR=0,-	
			ASTPRM=#0,P1=0,P2=#0,P3=#0,P4=#0,P5=#0,P6=#0 
		.GLOBL	SYS$QIO
		$PUSHTWO P6,P5
		$PUSHTWO P4,P3
		PUSHL	P2
		$PUSHADR P1
		$QIOPUSH ASTPRM,ASTADR
		$PUSHADR IOSB,CONTEXT=Q
		MOVZWL	FUNC,-(SP)
		MOVZWL	CHAN,-(SP)
		PUSHL	EFN
		CALLS	#12,G^SYS$QIO
	.ENDM	$QIO_S

;
; QIOW SYSTEM SERVICE
;
;	SEE QIO FOR PARAMETER DESCRIPTION
;

	.MACRO	$QIOW_G ARGPTR
		.GLOBL	SYS$QIOW
		CALLG	ARGPTR,G^SYS$QIOW
	.ENDM	$QIOW_G

	.MACRO	$QIOWDEF
		$OFFDEF QIOW, <EFN,CHAN,FUNC,IOSB,ASTADR,ASTPRM,P1,P2,P3,-
			P4,P5,P6>
	.ENDM	$QIOWDEF

	.MACRO	$QIOW EFN=0,CHAN=0,FUNC=0,IOSB=0,ASTADR=0,ASTPRM=0,-
			P1=0,P2=0,P3=0,P4=0,P5=0,P6=0
		$QIOWDEF
		.ADDRESS	12
		.ADDRESS	EFN
		.ADDRESS	CHAN
		.ADDRESS	FUNC
		.ADDRESS	IOSB
		.ADDRESS	ASTADR
		.ADDRESS	ASTPRM
		.ADDRESS	P1
		.ADDRESS	P2
		.ADDRESS	P3
		.ADDRESS	P4
		.ADDRESS	P5
		.ADDRESS	P6
	.ENDM	$QIOW

	.MACRO	$QIOW_S	EFN=#0,CHAN,FUNC,IOSB=0,ASTADR=0,-	
			ASTPRM=#0,P1=0,P2=#0,P3=#0,P4=#0,P5=#0,P6=#0 
		.GLOBL	SYS$QIOW
		$PUSHTWO P6,P5
		$PUSHTWO P4,P3
		PUSHL	P2
		$PUSHADR P1
		$QIOPUSH ASTPRM,ASTADR
		$PUSHADR IOSB,CONTEXT=Q
		MOVZWL	FUNC,-(SP)
		MOVZWL	CHAN,-(SP)
		PUSHL	EFN
		CALLS	#12,G^SYS$QIOW
	.ENDM	$QIOW_S

;
; READ EVENT FLAGS
;
;	EFN	- EVENT FLAG NUMBER OF A FLAG IN THE CLUSTER TO BE READ
;	STATE	- ADDRESS OF A LONGWORD IN WHICH CURRENT STATE OF ALL FLAGS
;		  IN THE CLUSTER WILL BE RETURNED
;

	.MACRO	$READEF_G ARGPTR
		.GLOBL	SYS$READEF
		CALLG	ARGPTR,G^SYS$READEF
	.ENDM	$READEF_G

	.MACRO	$READEFDEF
		$OFFDEF READEF, <EFN,STATE>
	.ENDM	$READEFDEF

	.MACRO	$READEF EFN=0,STATE=0
		$READEFDEF
		.ADDRESS	2
		.ADDRESS	EFN
		.ADDRESS	STATE
	.ENDM	$READEF

	.MACRO	$READEF_S EFN,STATE
		.GLOBL	SYS$READEF
		$PUSHADR STATE	
		PUSHL	EFN	
		CALLS	#2,G^SYS$READEF	
	.ENDM	$READEF_S

;
; RESUME PROCESS
;
;	PIDADR	- ADDRESS OF PROCESS ID OF PROCESS TO BE RESUMED
;	PRCNAM	- ADDRESS OF PROCESS NAME STRING DESCRIPTOR 
;

	.MACRO	$RESUME_G ARGPTR
		.GLOBL	SYS$RESUME
		CALLG	ARGPTR,G^SYS$RESUME
	.ENDM	$RESUME_G

	.MACRO	$RESUMEDEF
		$OFFDEF RESUME, <PIDADR,PRCNAM>
	.ENDM	$RESUMEDEF

	.MACRO	$RESUME PIDADR=0,PRCNAM=0
		$RESUMEDEF
		.ADDRESS	2
		.ADDRESS	PIDADR
		.ADDRESS	PRCNAM
	.ENDM	$RESUME

	.MACRO	$RESUME_S,PIDADR=0,PRCNAM=0
		.GLOBL	SYS$RESUME
		$PUSHADR PRCNAM,CONTEXT=Q
		$PUSHADR PIDADR
		CALLS	#2,G^SYS$RESUME
	.ENDM	$RESUME_S
;
; RUNDOWN PROCESS
;
;	ACMODE - ACCESS MODE TO RUNDOWN.  THIS AND ALL LESS PRIVILEGED
;		 ACCESS MODES ARE RUNDOWN.
;

	.MACRO	$RUNDWN_G ARGPTR
		.GLOBL	SYS$RUNDWN
		CALLG	ARGPTR,G^SYS$RUNDWN
	.ENDM	$RUNDWN_G

	.MACRO	$RUNDWNDEF
		$OFFDEF RUNDWN,<ACMODE>
	.ENDM	$RUNDWNDEF

	.MACRO	$RUNDWN ACMODE=0
		$RUNDWNDEF
		.ADDRESS	1
		.ADDRESS	ACMODE
	.ENDM	$RUNDWN

	.MACRO	$RUNDWN_S ACMODE=0
		.GLOBL	SYS$RUNDWN
		PUSHL	ACMODE
		CALLS	#1,G^SYS$RUNDWN
	.ENDM	$RUNDWN_S

;
; SCHEDULE WAKEUP
;
;	PIDADR	- ADDRESS OF PROCESS ID OF PROCESS TO BE AWAKENED
;	PRCNAM	- ADDRESS OF PROCESS NAME STRING DESCRIPTOR
;	DAYTIM	- ADDRESS OF QUADWORD CONTAINING TIME TO WAKE
;	REPTIM	- ADDRESS OF QUADWORD CONTAINING RESCHEDULE INTERVAL
;

	.MACRO	$SCHDWK_G ARGPTR
		.GLOBL	SYS$SCHDWK
		CALLG	ARGPTR,G^SYS$SCHDWK
	.ENDM	$SCHDWK_G

	.MACRO	$SCHDWKDEF
		$OFFDEF SCHDWK, <PIDADR,PRCNAM,DAYTIM,REPTIM>
	.ENDM	$SCHDWKDEF

	.MACRO	$SCHDWK PIDADR=0,PRCNAM=0,DAYTIM=0,REPTIM=0
		$SCHDWKDEF
		.ADDRESS	4
		.ADDRESS	PIDADR
		.ADDRESS	PRCNAM
		.ADDRESS	DAYTIM
		.ADDRESS	REPTIM
	.ENDM	$SCHDWK

	.MACRO	$SCHDWK_S PIDADR=0,PRCNAM=0,DAYTIM,REPTIM=0
		.GLOBL	SYS$SCHDWK
		$PUSHADR REPTIM,CONTEXT=Q
		$PUSHADR DAYTIM,CONTEXT=Q
		$PUSHADR PRCNAM,CONTEXT=Q
		$PUSHADR PIDADR
		CALLS	#4,G^SYS$SCHDWK
	.ENDM	$SCHDWK_S

;
; SET AST ENABLE
;
;	ENBFLG	- AST ENABLE INDICATOR
;		  1 -> ENABLE AST'S FOR CALLER AT CURRENT ACCESS MODE
;		  0 -> DISABLE AST'S FOR CALLER AT CURRENT ACCESS MODE
;

	.MACRO	$SETAST_G ARGPTR
		.GLOBL	SYS$SETAST
		CALLG	ARGPTR,G^SYS$SETAST
	.ENDM	$SETAST_G

	.MACRO	$SETASTDEF
		$OFFDEF SETAST, <ENBFLG>
	.ENDM	$SETASTDEF

	.MACRO	$SETAST ENBFLG=0
		$SETASTDEF
		.ADDRESS	1
		.ADDRESS	ENBFLG
	.ENDM	$SETAST

	.MACRO	$SETAST_S ENBFLG
		.GLOBL	SYS$SETAST
		PUSHL	ENBFLG
		CALLS	#1,G^SYS$SETAST
	.ENDM	$SETAST_S

;
; SET TIMER
;
;	EFN	- EVENT FLAG TO SET WHEN TIMER EXPIRES
;	DAYTIM	- TIME AT WHICH TIMER WILL EXPIRE
;	ASTADR	- ENTRY POINT OF AST TO CALL WHEN TIMER EXPIRES
;	REQIDT	- REQUEST IDENTIFICATION AND AST ID PARAM
;

	.MACRO	$SETIMR_G ARGPTR
		.GLOBL	SYS$SETIMR
		CALLG	ARGPTR,G^SYS$SETIMR
	.ENDM	$SETIMR_G

	.MACRO	$SETIMRDEF
		$OFFDEF SETIMR, <EFN,DAYTIM,ASTADR,REQIDT>
	.ENDM	$SETIMRDEF

	.MACRO	$SETIMR EFN=0,DAYTIM=0,ASTADR=0,REQIDT=0
		$SETIMRDEF
		.ADDRESS	4
		.ADDRESS	EFN
		.ADDRESS	DAYTIM
		.ADDRESS	ASTADR
		.ADDRESS	REQIDT
	.ENDM	$SETIMR

	.MACRO	$SETIMR_S EFN=#0,DAYTIM,ASTADR=0,REQIDT=#0
		.GLOBL	SYS$SETIMR
		PUSHL	REQIDT
		$PUSHADR ASTADR
		$PUSHADR DAYTIM
		PUSHL	EFN
		CALLS	#4,G^SYS$SETIMR
	.ENDM	$SETIMR_S

;
; SET EVENT FLAG
;
;	EFN	- EVENT FLAG NUMBER OF FLAG TO SET
;

	.MACRO	$SETEF_G ARGPTR
		.GLOBL	SYS$SETEF
		CALLG	ARGPTR,G^SYS$SETEF
	.ENDM	$SETEF_G

	.MACRO	$SETEFDEF
		$OFFDEF SETEF, <EFN>
	.ENDM	$SETEFDEF

	.MACRO	$SETEF EFN=0
		$SETEFDEF
		.ADDRESS	1
		.ADDRESS	EFN
	.ENDM	$SETEF

	.MACRO	$SETEF_S,EFN
		.GLOBL	SYS$SETEF
		PUSHL	EFN	
		CALLS	#1,G^SYS$SETEF
	.ENDM	$SETEF_S
 
;
; SET EXCEPTION VECTOR
;
;	VECTOR	- VECTOR NUMBER
;		  0 -> MODIFY PRIMARY VECTOR
;		  1 -> MODIFY SECONDARY VECTOR
;		  2 -> MODIFY LAST CHANCE HANDLER
;	ADDRES	- EXCEPTION HANDLER ADDRESS ( 0 INDICATES DEASSIGN VECTOR)
;	ACMODE	- ACCESS MODE FOR WHICH VECTOR IS SET
;	PRVHND	- ADDRESS OF LONGWORD TO RECEIVE PREVIOUS HANDLER ADDRESS

;

	.MACRO	$SETEXV_G ARGPTR
		.GLOBL	SYS$SETEXV
		CALLG	ARGPTR,G^SYS$SETEXV
	.ENDM	$SETEXV_G

	.MACRO	$SETEXVDEF
		$OFFDEF SETEXV, <VECTOR,ADDRES,ACMODE,PRVHND>
	.ENDM	$SETEXVDEF

	.MACRO	$SETEXV VECTOR=0,ADDRES=0,ACMODE=0,PRVHND=0
		$SETEXVDEF
		.ADDRESS	4
		.ADDRESS	VECTOR
		.ADDRESS	ADDRES
		.ADDRESS	ACMODE
		.ADDRESS	PRVHND
	.ENDM	$SETEXV

	.MACRO	$SETEXV_S VECTOR=#0,ADDRES=0,ACMODE=#0,PRVHND=0
		.GLOBL	SYS$SETEXV
		$PUSHADR PRVHND
		PUSHL	ACMODE
		$PUSHADR ADDRES
		PUSHL	VECTOR
		CALLS	#4,G^SYS$SETEXV
	.ENDM	$SETEXV_S
 
;
; SET PAGE FAULT MONITORING
;
;	PFMFLG - 1 -> turn on monitoring
;		 0 -> turn off monitoring
;

	.MACRO	$SETPFM_G ARGPTR
		.GLOBL	SYS$SETPFM
		CALLG	ARGPTR,G^SYS$SETPFM
	.ENDM	$SETPFM_G

	.MACRO	$SETPFMDEF
		$OFFDEF	SETPFM,<PFMFLG>
	.ENDM	$SETPFMDEF

	.MACRO	$SETPFM PFMFLG=0
		$SETPFMDEF
		.ADDRESS	1
		.ADDRESS	PFMFLG
	.ENDM	$SETPFM

	.MACRO	$SETPFM_S PFMFLG=#1
		.GLOBL	SYS$SETPFM
		PUSHL	PFMFLG
		CALLS	#1,G^SYS$SETPFM
	.ENDM	$SETPFM_S

;
; SET POWER RECOVERY AST
;
;	ASTADR = ADDRESS OF AST SERVICE ROUTINE
;	ACMODE = ACCESS MODE OF AST
;

	.MACRO	$SETPRA_G ARGPTR
		.GLOBL	SYS$SETPRA
		CALLG	ARGPTR,G^SYS$SETPRA
	.ENDM	$SETPRA_G

	.MACRO	$SETPRADEF
		$OFFDEF	SETPRA,<ASTADR,ACMODE>
	.ENDM	$SETPRADEF

	.MACRO	$SETPRA ASTADR=0,ACMODE=0
		$SETPRADEF
		.ADDRESS	2
		.ADDRESS	ASTADR
		.ADDRESS	ACMODE
	.ENDM	$SETPRA

	.MACRO	$SETPRA_S ASTADR,ACMODE=#0
		.GLOBL	SYS$SETPRA
		PUSHL	ACMODE
		$PUSHADR ASTADR
		CALLS	#2,G^SYS$SETPRA
	.ENDM	$SETPRA_S

;
; SET PROCESS NAME
;
;	PRCNAM	- ADDRESS OF THE PROCESS NAME STRING DESCRIPTOR
;

	.MACRO	$SETPRN_G ARGPTR
		.GLOBL	SYS$SETPRN
		CALLG	ARGPTR,G^SYS$SETPRN
	.ENDM	$SETPRN_G

	.MACRO	$SETPRNDEF
		$OFFDEF SETPRN, <PRCNAM>
	.ENDM	$SETPRNDEF

	.MACRO	$SETPRN PRCNAM=0
		$SETPRNDEF
		.ADDRESS	1
		.ADDRESS	PRCNAM
	.ENDM	$SETPRN

	.MACRO	$SETPRN_S,PRCNAM=0
		.GLOBL	SYS$SETPRN
		$PUSHADR PRCNAM,CONTEXT=Q
		CALLS	#1,G^SYS$SETPRN
	.ENDM	$SETPRN_S

;
; SET PRIORITY
;
;	PIDADR	- ADDRESS OF THE PROCESS ID
;	PRCNAM	- ADDRESS OF PROCESS NAME STRING DESCRIPTOR
;	PRI	- NEW BASE PRIORITY FOR THE PROCESS
;		  0 - 15 ARE BACKGROUND, 16 - 31 ARE REAL-TIME
;	PRVPRI	- ADDRESS OF LONGWORD TO RECEIVE PREVIOUS BASE PRIORITY
;

	.MACRO	$SETPRI_G ARGPTR
		.GLOBL	SYS$SETPRI
		CALLG	ARGPTR,G^SYS$SETPRI
	.ENDM	$SETPRI_G

	.MACRO	$SETPRIDEF
		$OFFDEF SETPRI, <PIDADR,PRCNAM,PRI,PRVPRI>
	.ENDM	$SETPRIDEF

	.MACRO	$SETPRI PIDADR=0,PRCNAM=0,PRI=0,PRVPRI=0
		$SETPRIDEF
		.ADDRESS	4
		.ADDRESS	PIDADR
		.ADDRESS	PRCNAM
		.ADDRESS	PRI
		.ADDRESS	PRVPRI
	.ENDM	$SETPRI

	.MACRO	$SETPRI_S PIDADR=0,PRCNAM=0,PRI,PRVPRI=0
		.GLOBL	SYS$SETPRI
		$PUSHADR PRVPRI
		PUSHL	PRI
		$PUSHADR PRCNAM,CONTEXT=Q
		$PUSHADR PIDADR
		CALLS	#4,G^SYS$SETPRI
	.ENDM	$SETPRI_S

;
; SET PROTECTION ON PAGES
;
;	INADR	- ADDRESS OF 2-LONGWORD ARRAY CONTAINING STARTING AND
;		  ENDING VIRTUAL ADDRESSES OF PAGES
;	RETADR	- ADDRESS OF 2-LONGWORD ARRAY IN WHICH STARTING AND ENDING
;		  ADDRESSES OF PAGES WHICH HAD THEIR PROTECTION CHANGED
;		  IS RETURNED
;	ACMODE	- ACCESS MODE OF REQUEST
;	PROT	- NEW PROTECTION
;
;	PRVPRT	- ADDRESS OF A BYTE TO RETURN THE PREVIOUS PROTECTION
;		OF THE LAST PAGE CHANGED.

	.MACRO	$SETPRT_G ARGPTR
		.GLOBL	SYS$SETPRT
		CALLG	ARGPTR,G^SYS$SETPRT
	.ENDM	$SETPRT_G

	.MACRO	$SETPRTDEF
		$OFFDEF SETPRT, <INADR,RETADR,ACMODE,PROT,PRVPRT>
	.ENDM	$SETPRTDEF

	.MACRO	$SETPRT INADR=0,RETADR=0,ACMODE=0,PROT=0,PRVPRT=0
		$SETPRTDEF
		.ADDRESS	5
		.ADDRESS	INADR
		.ADDRESS	RETADR
		.ADDRESS	ACMODE
		.ADDRESS	PROT
		.ADDRESS	PRVPRT
	.ENDM	$SETPRT

	.MACRO	$SETPRT_S INADR,RETADR=0,ACMODE=#0,PROT,PRVPRT=0
		.GLOBL	SYS$SETPRT
		$PUSHADR PRVPRT
		PUSHL	PROT
		PUSHL	ACMODE
		$PUSHADR RETADR,CONTEXT=Q
		$PUSHADR INADR,CONTEXT=Q
		CALLS	#5,G^SYS$SETPRT
	.ENDM	$SETPRT_S

;
; SETPRV - SET PROCESS PRIVILEGES
;
;	ENBFLG	- ENABLE/DISABLE INDICATOR
;		0 -> DISABLE
;		1 -> ENABLE
;	PRVADR	- ADDRESS OF QUADWORD MASK OF PRIVILEGES TO BE ENABLED/DISABLED
;	PRMFLG	- PERMANENT/TEMPORARY INDICATOR
;		0 -> TEMPORARY
;		1 -> PERMANENT
;	PRVPRV	- ADDRESS OF A QUADWORD BUFFER TO RETURN PREVIOUS PRIVILEGES
;

	.MACRO	$SETPRV_G ARGPTR
	.GLOBL	SYS$SETPRV
		CALLG	ARGPTR,G^SYS$SETPRV
	.ENDM	$SETPRV_G

	.MACRO	$SETPRVDEF
		$OFFDEF	SETPRV,<ENBFLG,PRVADR,PRMFLG,PRVPRV>
	.ENDM	$SETPRVDEF

	.MACRO	$SETPRV ENBFLG=0,PRVADR=0,PRMFLG=0,PRVPRV=0
		$SETPRVDEF
		.ADDRESS	4
		.ADDRESS	ENBFLG
		.ADDRESS	PRVADR
		.ADDRESS	PRMFLG
		.ADDRESS	PRVPRV
	.ENDM	$SETPRV

	.MACRO	$SETPRV_S ENBFLG=#0,PRVADR=0,PRMFLG=#0,PRVPRV=0
	.GLOBL	SYS$SETPRV
		$PUSHADR PRVPRV,CONTEXT=Q
		PUSHL	PRMFLG
		$PUSHADR PRVADR,CONTEXT=Q
		PUSHL	ENBFLG
		CALLS	#4,G^SYS$SETPRV
	.ENDM	$SETPRV_S

;
; SETSSF - SET SYSTEM SERVICE FILTER MASK
;
;	MASK -	A BYTE OF BIT FLAGS THAT SPECIFY THE CLASS OF SYSTEM
;		SERVICES TO INHIBIT.
;

	.MACRO	$SETSSF_G ARGPTR
		.GLOBL	SYS$SETSSF
		CALLG	ARGPTR,G^SYS$SETSSF
	.ENDM	$SETSSF_G

	.MACRO	$SETSSFDEF
		$OFFDEF SETSSF, <MASK>
	.ENDM	$SETSSFDEF

	.MACRO	$SETSSF MASK=0
		$SETSSFDEF
		.ADDRESS	1
		.ADDRESS	MASK
	.ENDM	$SETSSF

	.MACRO	$SETSSF_S MASK=#0
		.GLOBL	SYS$SETSSF
		PUSHL	MASK
		CALLS	#1,G^SYS$SETSSF
	.ENDM	$SETSSF_S

;
; SETSTK - SET STACK LIMITS
;
;	INADR	- ADDRESS OF 2-LONGWORD ARRAY CONTAINING STARTING AND
;		  ENDING VIRTUAL ADDRESS OF STACK LIMITS TO SET
;	RETADR	- ADDRESS OF A 2-LONGWORD ARRAY TO RECEIVE STARTING
;		  AND ENDING VIRTUAL ADDRESS OF PREVIOUS STACK LIMITS
;	ACMODE	- ACCESS MODE FOR THE STACK TO CHANGE.
;

	.MACRO	$SETSTK_G ARGPTR
		.GLOBL	SYS$SETSTK
		CALLG	ARGPTR,G^SYS$SETSTK
	.ENDM	$SETSTK_G

	.MACRO	$SETSTKDEF
		$OFFDEF SETSTK, <INADR,RETADR,ACMODE>
	.ENDM	$SETSTKDEF

	.MACRO	$SETSTK INADR=0,RETADR=0,ACMODE=0
		$SETSTKDEF
		.ADDRESS	3
		.ADDRESS	INADR
		.ADDRESS	RETADR
		.ADDRESS	ACMODE
	.ENDM	$SETSTK

	.MACRO	$SETSTK_S INADR,RETADR=0,ACMODE=#0
		.GLOBL	SYS$SETSTK
		PUSHL	ACMODE
		$PUSHADR RETADR,CONTEXT=Q
		$PUSHADR INADR,CONTEXT=Q
		CALLS	#3,G^SYS$SETSTK
	.ENDM	$SETSTK_S

;
; SETIME - SET SYSTEM TIME
;
;	TIMADR 	- ADDRESS OF QUADWORD CONTAINING 64 BIT BINARY TIME
;

	.MACRO	$SETIME_G ARGPTR
	.GLOBL	SYS$SETIME
		CALLG	ARGPTR,G^SYS$SETIME
	.ENDM	$SETIME_G

	.MACRO	$SETIMEDEF
		$OFFDEF SETIME,<TIMADR>
	.ENDM	$SETIMEDEF

	.MACRO	$SETIME TIMADR=0
		$SETIMEDEF
		.ADDRESS	1
		.ADDRESS	TIMADR
	.ENDM	$SETIME

	.MACRO	$SETIME_S TIMADR=0
	.GLOBL	SYS$SETIME
		$PUSHADR TIMADR,CONTEXT=Q
		CALLS	#1,G^SYS$SETIME
	.ENDM	$SETIME_S

;
; SET RESOURCE WAIT MODE
;
;	WATFLG	- WAIT INDICATOR
;		  0 -> WAIT FOR RESOURCES TO BECOME AVAILABLE
;		  1 -> RETURN FAILURE STATUS IMMEDIATELY
;

	.MACRO	$SETRWM_G ARGPTR
		.GLOBL	SYS$SETRWM
		CALLG	ARGPTR,G^SYS$SETRWM
	.ENDM	$SETRWM_G

	.MACRO	$SETRWMDEF
		$OFFDEF SETRWM, <WATFLG>
	.ENDM	$SETRWMDEF

	.MACRO	$SETRWM WATFLG=0
		$SETRWMDEF
		.ADDRESS	1
		.ADDRESS	WATFLG
	.ENDM	$SETRWM

	.MACRO	$SETRWM_S WATFLG=#0
		.GLOBL	SYS$SETRWM
		PUSHL	WATFLG
		CALLS	#1,G^SYS$SETRWM
	.ENDM	$SETRWM_S

;
; SET SYSTEM SERVICE FAILURE MODE
;
;	ENBFLG	- ENABLE INDICATOR
;		  1 -> GENERATE EXCEPTIONS ON SYSTEM SERVICE FAILURES
;		  0 -> DISABLE EXCEPTIONS ON SYSTEM SERVICE FAILURES
;

	.MACRO	$SETSFM_G ARGPTR
		.GLOBL	SYS$SETSFM
		CALLG	ARGPTR,G^SYS$SETSFM
	.ENDM	$SETSFM_G

	.MACRO	$SETSFMDEF
		$OFFDEF SETSFM,<ENBFLG>
	.ENDM	$SETSFMDEF

	.MACRO	$SETSFM ENBFLG=0
		$SETSFMDEF
		.ADDRESS	1
		.ADDRESS	ENBFLG
	.ENDM	$SETSFM

	.MACRO	$SETSFM_S ENBFLG=#0
		.GLOBL	SYS$SETSFM
		PUSHL	ENBFLG
		CALLS	#1,G^SYS$SETSFM
	.ENDM	$SETSFM_S

;
; SET SWAP MODE
;
;	SWPFLG	- SWAP INDICATOR
;		0 -> ALLOW SWAPPING
;		1 -> DO NOT SWAP PROCESS
;

	.MACRO	$SETSWM_G ARGPTR
		.GLOBL	SYS$SETSWM
		CALLG	ARGPTR,G^SYS$SETSWM
	.ENDM	$SETSWM_G

	.MACRO	$SETSWMDEF
		$OFFDEF SETSWM,<SWPFLG>
	.ENDM	$SETSWMDEF

	.MACRO	$SETSWM SWPFLG=0
		$SETSWMDEF
		.ADDRESS	1
		.ADDRESS	SWPFLG
	.ENDM	$SETSWM

	.MACRO	$SETSWM_S SWPFLG=#0
		.GLOBL	SYS$SETSWM
		PUSHL	SWPFLG
		CALLS	#1,G^SYS$SETSWM
	.ENDM	$SETSWM_S
 
;
; SEND MESSAGE TO ACCOUNTING MANAGER
;
;	MSGBUF - ADDRESS OF MESSAGE BUFFER STRING DESCRIPTOR
;	CHAN - CHANNEL NUMBER FOR MAILBOX TO RECEIVE REPLY
;

	.MACRO	$SNDACC_G ARGPTR
		.GLOBL	SYS$SNDACC
		CALLG	ARGPTR,G^SYS$SNDACC
	.ENDM	$SNDACC_G

	.MACRO	$SNDACCDEF
		$OFFDEF SNDACC,<MSGBUF,CHAN>
	.ENDM	$SNDACCDEF

	.MACRO	$SNDACC	MSGBUF=0,CHAN=0
		$SNDACCDEF
		.ADDRESS	2
		.ADDRESS	MSGBUF
		.ADDRESS	CHAN
	.ENDM	$SNDACC

	.MACRO	$SNDACC_S MSGBUF,CHAN=#0
		.GLOBL	SYS$SNDACC
		MOVZWL	CHAN,-(SP)
		$PUSHADR MSGBUF,CONTEXT=Q
		CALLS	#2,G^SYS$SNDACC
	.ENDM	$SNDACC_S

;
; SEND MESSAGE TO ERROR LOGGER
;
;	MSGBUG - ADDRESS OF MESSAGE BUFFER STRING DESCRIPTOR
;

	.MACRO	$SNDERR_G ARGPTR
		.GLOBL	SYS$SNDERR
		CALLG	ARGPTR,G^SYS$SNDERR
	.ENDM	$SNDERR_G 

	.MACRO	$SNDERRDEF
		$OFFDEF	SNDERR,<MSGBUF>
	.ENDM	$SNDERRDEF

	.MACRO	$SNDERR	MSGBUF=0
		$SNDERRDEF
		.ADDRESS	1
		.ADDRESS	MSGBUF
	.ENDM	$SNDERR

	.MACRO	$SNDERR_S MSGBUF
		.GLOBL	SYS$SNDERR
		$PUSHADR MSGBUF,CONTEXT=Q
		CALLS	#1,G^SYS$SNDERR
	.ENDM	$SNDERR_S

;
; SEND MESSAGE TO OPERATOR
;
;	MSGBUF - ADDRESS OF MESSAGE BUFFER STRING DESCRIPTOR
;	CHAN - CHANNEL NUMBER FOR MAILBOX TO RECEIVE REPLY
;

	.MACRO	$SNDOPR_G ARGPTR
		.GLOBL	SYS$SNDOPR
		CALLG	ARGPTR,G^SYS$SNDOPR
	.ENDM	$SNDOPR_G

	.MACRO	$SNDOPRDEF
		$OFFDEF	SNDOPR,<MSGBUF,CHAN>
	.ENDM	$SNDOPRDEF

	.MACRO	$SNDOPR	MSGBUF=0,CHAN=0
		$SNDOPRDEF
		.ADDRESS	2
		.ADDRESS	MSGBUF
		.ADDRESS	CHAN
	.ENDM	$SNDOPR

	.MACRO	$SNDOPR_S MSGBUF,CHAN=#0
		.GLOBL	SYS$SNDOPR
		MOVZWL	CHAN,-(SP)
		$PUSHADR MSGBUF,CONTEXT=Q
		CALLS	#2,G^SYS$SNDOPR
	.ENDM	$SNDOPR_S

;
; SEND MESSAGE TO SYMBIONT MANAGER
;
;	MSGBUF - ADDRESS OF MESSAGE BUFFER STRING DESCRIPTOR
;	CHAN - CHANNEL NUMBER OF MAILBOX TO RECEIVE THE REPLY
;

	.MACRO	$SNDSMB_G ARGPTR
		.GLOBL	SYS$SNDSMB
		CALLG	ARGPTR,G^SYS$SNDSMB
	.ENDM	$SNDSMB_G

	.MACRO	$SNDSMBDEF
		$OFFDEF	SNDSMB,<MSGBUF,CHAN>
	.ENDM	$SNDSMBDEF

	.MACRO	$SNDSMB	MSGBUF=0,CHAN=0
		$SNDSMBDEF
		.ADDRESS	2
		.ADDRESS	MSGBUF
		.ADDRESS	CHAN
	.ENDM	$SNDSMB

	.MACRO	$SNDSMB_S MSGBUF,CHAN=#0
		.GLOBL	SYS$SNDSMB
		MOVZWL	CHAN,-(SP)
		$PUSHADR MSGBUF,CONTEXT=Q
		CALLS	#2,G^SYS$SNDSMB
	.ENDM	$SNDSMB_S

;
; SUSPEND PROCESS
;
;	PIDADR	- ADDRESS OF THE PROCESS ID OF PROCESS TO SUSPEND
;	PRCNAM	- ADDRESS OF NAME STRING DESCRIPTOR OF PROCESS TO SUSPEND
;

	.MACRO	$SUSPND_G ARGPTR
		.GLOBL	SYS$SUSPND
		CALLG	ARGPTR,G^SYS$SUSPND
	.ENDM	$SUSPND_G

	.MACRO	$SUSPNDDEF
		$OFFDEF SUSPND, <PIDADR,PRCNAM>
	.ENDM	$SUSPNDDEF

	.MACRO	$SUSPND PIDADR=0,PRCNAM=0
		$SUSPNDDEF
		.ADDRESS	2
		.ADDRESS	PIDADR
		.ADDRESS	PRCNAM
	.ENDM	$SUSPND

	.MACRO	$SUSPND_S PIDADR=0,PRCNAM=0
		.GLOBL	SYS$SUSPND
		$PUSHADR PRCNAM,CONTEXT=Q
		$PUSHADR PIDADR
		CALLS	#2,G^SYS$SUSPND
	.ENDM	$SUSPND_S
;
; TRANSLATE LOGICAL NAME
;
;	LOGNAM	- ADDRESS OF LOGICAL NAME STRING DESCRIPTOR
;	RSLLEN	- ADDRESS OF WORD TO RECEIVE LENGTH OF RESULTANT
;		  NAME STRING
;	RSLBUF	- ADDRESS OF RESULT STRING BUFFER DESCRIPTOR
;	TABLE	- ADDRESS OF BYTE TO STORE TRANSLATION TABLE NUMBER
;	ACMODE	- ADDRESS OF BYTE TO STORE ASSIGNMENT ACCESS MODE
;	DSBMSK  - TABLE SEARCH DISABLE MASK
;

	.MACRO	$TRNLOG_G ARGPTR
		.GLOBL	SYS$TRNLOG
		CALLG	ARGPTR,G^SYS$TRNLOG
	.ENDM	$TRNLOG_G

	.MACRO	$TRNLOGDEF
		$OFFDEF TRNLOG, <LOGNAM,RSLLEN,RSLBUF,TABLE,ACMODE,DSBMSK>
	.ENDM	$TRNLOGDEF

	.MACRO	$TRNLOG LOGNAM=0,RSLLEN=0,RSLBUF=0,TABLE=0,ACMODE=0,DSBMSK=0
		$TRNLOGDEF
		.ADDRESS	6
		.ADDRESS	LOGNAM
		.ADDRESS	RSLLEN
		.ADDRESS	RSLBUF
		.ADDRESS	TABLE
		.ADDRESS	ACMODE
		.ADDRESS	DSBMSK
	.ENDM	$TRNLOG

	.MACRO	$TRNLOG_S LOGNAM,RSLLEN=0,RSLBUF,TABLE=0,ACMODE=0,DSBMSK=#0
		.GLOBL	SYS$TRNLOG
		PUSHL	DSBMSK
		$PUSHADR ACMODE,CONTEXT=B
		$PUSHADR TABLE,CONTEXT=B
		$PUSHADR RSLBUF,CONTEXT=Q
		$PUSHADR RSLLEN,CONTEXT=W
		$PUSHADR LOGNAM,CONTEXT=Q
		CALLS	#6,G^SYS$TRNLOG
	.ENDM	$TRNLOG_S

;
; UNLOCK PAGES FROM MEMORY
;
;	INADR - ADDRESS OF 2-LONGWORD ARRAY CONTAINING STARTING AND
;		ENDING VIRTUAL ADDRESSES OF PAGES TO BE LOCKED
;	RETADR - ADDRESS OF A 2-LONGWORD ARRAY TO RECEIVE STARTING AND
;		ENDING VIRTUAL ADDRESSES OF PAGES ACTUALLY LOCKED
;	ACMODE - ACCESS MODE TO BE CHECKED AGAINST THE PAGE OWNER
;

	.MACRO	$ULKPAG_G ARGPTR
		.GLOBL	SYS$ULKPAG
		CALLG	ARGPTR,G^SYS$ULKPAG
	.ENDM	$ULKPAG_G

	.MACRO	$ULKPAGDEF
		$OFFDEF ULKPAG,<INADR,RETADR,ACMODE>
	.ENDM	$ULKPAGDEF

	.MACRO	$ULKPAG INADR=0,RETADR=0,ACMODE=0
		$ULKPAGDEF
		.ADDRESS	3
		.ADDRESS	INADR
		.ADDRESS	RETADR
		.ADDRESS	ACMODE
	.ENDM	$ULKPAG

	.MACRO	$ULKPAG_S INADR,RETADR=0,ACMODE=#0
		.GLOBL	SYS$ULKPAG
		PUSHL	ACMODE
		$PUSHADR RETADR,CONTEXT=Q
		$PUSHADR INADR,CONTEXT=Q
		CALLS	#3,G^SYS$ULKPAG
	.ENDM	$ULKPAG_S

;
; UNLOCK PAGES FROM WORKING SET
;
;	INADR	- ADDRESS OF 2-LONGWORD ARRAY CONTAINING STARTING AND
;		  ENDING VIRTUAL ADDRESS OF PAGES TO BE UNLOCKED
;	RETADR	- ADDRESSES OF A 2-LONGWORD ARRAY TO RECEIVE STARTING
;		  AND ENDING VIRTUAL ADDRESS OF PAGES ACTUALLY UNLOCKED
;	ACMODE	- ACCESS MODE TO CHECK AGAINST THE PAGE OWNER
;
	.MACRO	$ULWSET_G ARGPTR
		.GLOBL	SYS$ULWSET
		CALLG	ARGPTR,G^SYS$ULWSET
	.ENDM	$ULWSET_G

	.MACRO	$ULWSETDEF
		$OFFDEF ULWSET, <INADR,RETADR,ACMODE>
	.ENDM	$ULWSETDEF

	.MACRO	$ULWSET INADR=0,RETADR=0,ACMODE=0
		$ULWSETDEF
		.ADDRESS	3
		.ADDRESS	INADR
		.ADDRESS	RETADR
		.ADDRESS	ACMODE
	.ENDM	$ULWSET

	.MACRO	$ULWSET_S INADR,RETADR=0,ACMODE=#0
		.GLOBL	SYS$ULWSET
		PUSHL	ACMODE
		$PUSHADR RETADR,CONTEXT=Q
		$PUSHADR INADR,CONTEXT=Q
		CALLS	#3,G^SYS$ULWSET
	.ENDM	$ULWSET_S
;
; UNWIND CALL STACK
;
;	DEPADR	- ADDRESS OF NUMBER OF LOGICAL FRAMES TO UNWIND CALL STACK
;	NEWPC	- CHANGE OF FLOW PC
;

	.MACRO	$UNWIND_G ARGPTR
		.GLOBL	SYS$UNWIND
		CALLG	ARGPTR,G^SYS$UNWIND
	.ENDM	$UNWIND_G

	.MACRO	$UNWINDDEF
		$OFFDEF	UNWIND, <DEPADR,NEWPC>
	.ENDM	$UNWINDDEF

	.MACRO	$UNWIND DEPADR=0,NEWPC=0
		$UNWINDDEF
		.ADDRESS	2
		.ADDRESS	DEPADR
		.ADDRESS	NEWPC
	.ENDM	$UNWIND

	.MACRO	$UNWIND_S DEPADR=0,NEWPC=0
		.GLOBL	SYS$UNWIND
		$PUSHADR NEWPC,CONTEXT=B
		$PUSHADR DEPADR
		CALLS	#2,G^SYS$UNWIND
	.ENDM	$UNWIND_S
 
;
; UPDATE SECTION FILE ON DISK
;
;	INADR - ADDRESS OF 2 LONGWORD ARRAY CONTAINING STARTING AND ENDING
;		VIRTUAL ADDRESS OF PAGES TO BE WRITTEN BACK TO SECTION FILE.
;	RETADR - ADDRESS OF 2 LONGWORD ARRAY TO RECEIVE STARTING AND ENDING
;		VIRTUAL ADDRESS OF PAGES ACTUALLY WRITTEN
;	ACMODE - ACCESS MODE ON BEHALF OF WHICH SERVICE IS PERFORMED.
;	UPDFLG - MASK QUALIFYING THE UPDATE REQUEST
;	EFN - NUMBER OF AN EVENT FLAG TO SET WHEN THE SECTION FILE IS UPDATED
;	IOSB - ADDRESS OF A QUADWORD I/O STATUS BLOCK THAT IS TO RECEIVE
;		THE COMPLETION STATUS WHEN THE FILE HAS BEEN UPDATED
;	ASTADR - ADDRESS OF AN AST SERVICE ROUTINE 
;	ASTPRM - AST PARAMETER
;

	.MACRO	$UPDSEC_G ARGPTR
		.GLOBL	SYS$UPDSEC
		CALLG	ARGPTR,G^SYS$UPDSEC
	.ENDM	$UPDSEC_G

	.MACRO	$UPDSECDEF
		$OFFDEF UPDSEC,<INADR,RETADR,ACMODE,UPDFLG,EFN,IOSB,ASTADR,-
				ASTPRM>
	.ENDM	$UPDSECDEF

	.MACRO	$UPDSEC INADR=0,RETADR=0,ACMODE=0,UPDFLG=0,EFN=0,IOSB=0,-
			ASTADR=0,ASTPRM=0
		$UPDSECDEF
		.ADDRESS	8
		.ADDRESS	INADR
		.ADDRESS	RETADR
		.ADDRESS	ACMODE
		.ADDRESS	UPDFLG
		.ADDRESS	EFN
		.ADDRESS	IOSB
		.ADDRESS	ASTADR
		.ADDRESS	ASTPRM
	.ENDM	$UPDSEC

	.MACRO	$UPDSEC_S INADR,RETADR=0,ACMODE=#0,UPDFLG=#0,EFN=#0,-
			IOSB=0,ASTADR=0,ASTPRM=#0
		.GLOBL	SYS$UPDSEC
		PUSHL	ASTPRM
		$PUSHADR ASTADR
		$PUSHADR IOSB,CONTEXT=Q
		PUSHL	EFN
		PUSHL	UPDFLG
		PUSHL	ACMODE
		$PUSHADR RETADR,CONTEXT=Q
		$PUSHADR INADR,CONTEXT=Q
		CALLS	#8,G^SYS$UPDSEC
	.ENDM	$UPDSEC_S

;
; WAIT FOR SINGLE EVENT
;
;	EFN	- EVENT FLAG NUMBER OF EVENT TO WAIT FOR
;

	.MACRO	$WAITFR_G ARGPTR
		.GLOBL	SYS$WAITFR
		CALLG	ARGPTR,G^SYS$WAITFR
	.ENDM	$WAITFR_G

	.MACRO	$WAITFRDEF
		$OFFDEF WAITFR, <EFN>
	.ENDM	$WAITFRDEF

	.MACRO	$WAITFR EFN=0
		$WAITFRDEF
		.ADDRESS	1
		.ADDRESS	EFN
	.ENDM	$WAITFR

	.MACRO	$WAITFR_S EFN
		.GLOBL	SYS$WAITFR
		PUSHL	EFN
		CALLS	#1,G^SYS$WAITFR
	.ENDM	$WAITFR_S

;
; WAKE 
;
;	PIDADR	- ADDRESS OF PROCESS ID OF PROCESS TO BE AWAKENED
;	PRCNAM	- ADDRESS OF PROCESS NAME DESCRIPTOR 
;

	.MACRO	$WAKE_G ARGPTR
		.GLOBL	SYS$WAKE
		CALLG	ARGPTR,G^SYS$WAKE
	.ENDM	$WAKE_G

	.MACRO	$WAKEDEF
		$OFFDEF WAKE, <PIDADR,PRCNAM>
	.ENDM	$WAKEDEF

	.MACRO	$WAKE PIDADR=0,PRCNAM=0
		$WAKEDEF
		.ADDRESS	2
		.ADDRESS	PIDADR
		.ADDRESS	PRCNAM
	.ENDM	$WAKE

	.MACRO	$WAKE_S,PIDADR=0,PRCNAM=0
		.GLOBL	SYS$WAKE
		$PUSHADR PRCNAM	,CONTEXT=Q
		$PUSHADR PIDADR	
		CALLS	#2,G^SYS$WAKE	
	.ENDM	$WAKE_S	

;
; WAIT FOR LOGICAL AND OF EVENT FLAGS
;
;	EFN	- EVENT FLAG NUMBER OF ANY FLAG WITHIN THE CLUSTER
;	MASK	- 32-BIT MASK IN WHICH BITS SET TO 1 SELECT THE EVENTS
;		  OF INTEREST
;

	.MACRO	$WFLAND_G ARGPTR
		.GLOBL	SYS$WFLAND
		CALLG	ARGPTR,G^SYS$WFLAND
	.ENDM	$WFLAND_G

	.MACRO	$WFLANDDEF
		$OFFDEF WFLAND, <EFN,MASK>
	.ENDM	$WFLANDDEF

	.MACRO	$WFLAND EFN=0,MASK=0
		$WFLANDDEF
		.ADDRESS	2
		.ADDRESS	EFN
		.ADDRESS	MASK
	.ENDM	$WFLAND

	.MACRO	$WFLAND_S EFN,MASK
		.GLOBL	SYS$WFLAND
		PUSHL	MASK
		PUSHL	EFN
		CALLS	#2,G^SYS$WFLAND
	.ENDM	$WFLAND_S

;
; WAIT FOR LOGICAL OR OF EVENT FLAGS
;
;	EFN	- EVENT FLAG NUMBER OF ANY FLAG WITHIN THE CLUSTER
;	MASK	- 32-BIT MASK IN WHICH BITS SET TO ONE SELECT EVENTS
;		  OF INTEREST
;

	.MACRO	$WFLOR_G ARGPTR
		.GLOBL	SYS$WFLOR
		CALLG	ARGPTR,G^SYS$WFLOR
	.ENDM	$WFLOR_G

	.MACRO	$WFLORDEF
		$OFFDEF WFLOR, <EFN,MASK>
	.ENDM	$WFLORDEF

	.MACRO	$WFLOR EFN=0,MASK=0
		$WFLORDEF
		.ADDRESS	2
		.ADDRESS	EFN
		.ADDRESS	MASK
	.ENDM	$WFLOR

	.MACRO	$WFLOR_S EFN,MASK
		.GLOBL	SYS$WFLOR
		PUSHL	MASK
		PUSHL	EFN
		CALLS	#2,G^SYS$WFLOR
	.ENDM	$WFLOR_S

	.LIST
