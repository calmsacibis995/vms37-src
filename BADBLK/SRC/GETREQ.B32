MODULE GETREQ (MAIN=MAIN_BAD,
		LANGUAGE (BLISS32),
		IDENT = 'V03-000'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:  DYNAMIC BADBLOCK UTILITY
!
! ABSTRACT:
!
!	THESE ROUTINES PERFORM THE ITERACTIONS WITH THE FILE SYSTEM
!	ACP FOR THE BAD BLOCK SCAN UTILITY.SPECIFIC FUNCTIONS ARE
!
!		1. READ THE MAILBOX INTERFACING THE UTILITY AND THE ACP
!		2. ACCESS THE SUSPECT FILE BY PATCHING ITS UCB INTO
!			A PREVIOUSLY OPENED CCB
!
! ENVIRONMENT:
!
!	VAX/VMS OPERATING SYSTEM, VERSION 1.0
!
!--
!
!
! AUTHOR:  THOMAS G. DOPIRAK,	 CREATION DATE:  7-JUNE-1978
!
! REVISION HISTORY:
!
!**


LIBRARY 'SYS$LIBRARY:LIB.L32';


FORWARD ROUTINE
	MAIN_BAD,			!MAIN PROGRAM
	RESTORE_CHANNEL:NOVALUE,	!PLACE SYS$DISK UCB BACK INTO CCB
 	SET_UCB:NOVALUE,		!SET UCB ADDRESS IN TO CCB
	OPEN_CHANNEL,			!OPEN CHANNELS TO F11ACP AND SYS$DISK
	GET_BBSMSG,			!READ MAIL FROM F11ACP
	GET_CCB;			! get address of CCB of channel
EXTERNAL ROUTINE
    DATA_INIT:NOVALUE,
    SCAN;

!
!OWN STORAGE
!

GLOBAL
    CHANNEL:WORD,			!CHANNEL NUMBER OF SYS$DISK
    MBX_CHANNEL:WORD,			!CHANNEL NUMBER OF F11ACP MAILBOX
    CCBUCB,				!ADDRESS OF UCB ENTRY IN CCB
    OLD_UCB,				!UCB ADDRESS FOR OPEN CHANNEL
    SYS$DISK_UCB,			!SAVED ADDRESS OF UCB FOR SYS$DISK
    ACP_MAIL:BLOCK[BBS$C_LENGTH,BYTE];	!MESSAGE FROM F11ACP
!
!READ ONLY STORAGE
!

BIND

    DISK_DESC=UPLIT(%CHARCOUNT('SYS$DISK'),
			UPLIT BYTE('SYS$DISK'));

LITERAL
    TRUE=1;

ROUTINE MAIN_BAD=

!++
! FUNCTIONAL DESCRIPTION:
!
!	MAIN PROGRAM ON BADBLOCK_SCAN UTILITY. THIS ROUTINE RECEIVES
!	MAIL FROM THE F11ACP INDICATING FILES THAT HAVE BEEN DELETED
!	AND THAT HAVE ENCOUNTERED HARD DEVICE ERRORS DURING IO.
!	MAIN_BAD USES THE UCB ADDRESS(INDICATING WHICH DISK) AND
!	FILE-ID(INDICATING THE FILE) TO SEPARATE THE SUSPECT FILE
!	INTO ITS "BAD" AND GOOD PORTIONS. THE BAD PORTIONS ARE 
!	ADDED ONTO BADBLK.SYS(SYSTEM BADBLOCK FILE) AND THE GOOD
!	PORTIONS ARE RECYCLED FOR GENERAL USE.
!	SINCE THE DISK INVOLVED MAY BE ALLOCATED, BADBLOCK_SCAN
!	SLIDES AROUND SYSTEM PROTECTION BY OPENING A CHANNEL TO
!	SYS$DISK AND THEN REPLACING THE UCB ADDRESS IN THAT CCB
!	BY THAT OF THE SUSPECT DISK.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

BEGIN

!+
!OPEN CHANNELS TO SYS$DISK AND THE F11ACP MAILBOX

    IF
	NOT OPEN_CHANNEL()
    THEN
	RETURN;

!++
!INITIALIZE TEST DATA
!--

    DATA_INIT();

!+
!GET THE ADDRESS OF THE  CCB FOR OPEN CHANNEL

    IF NOT $CMKRNL(ROUTIN=GET_CCB)
    THEN
	RETURN;


!+
!CYCLE THROUGH UNTIL NOTHING IN MAILBOX TO DO

    WHILE TRUE DO
	BEGIN
	IF
	   NOT GET_BBSMSG()
	THEN
	    BEGIN
	    RESTORE_CHANNEL();
	    RETURN
	    END;

        !+
        !SET UCB FOR SUSPECT FILE INTO OPEN CCB
    
            $CMKRNL(ROUTIN=SET_UCB);
    
        !*
        !PROCESS THE FILE

            SCAN();
	END;
END;

GLOBAL ROUTINE GET_CCB  =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE LOCATES THE CCB ASSOCIATED WITH A SPECIFIED
!	CHANNEL NUMBER. THE ADDRESS OF THE UCB LONGWORD IN THE CCB
!	IS SAVED IN CCBUCB AND THE UCB ADDRESS ITSELF IS SAVED IN
!	OLD_UCB
!
!
! INPUT PARAMETERS:

!	NONE

!
! IMPLICIT INPUTS:
!
!	CHANNEL: THE CHANNEL NUMBER WHOSE CCB IS BEING LOCATED
!
! OUTPUT PARAMETERS:
!
!	OLD_UCB: THE ADDRESS OF THE SYS$DISK UCB
!	CCBUCB: ADDRESS OF THE UCB LONGWORD IN THE SYS$DISK CCB
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!
!	IF CCB CAN BE FOUND THE SUCCESS

!
! SIDE EFFECTS:
!	NONE
!
!--


BEGIN

LINKAGE
	L_VERIFYCHAN	= JSB (REGISTER = 0) :
			  GLOBAL (CCB = 1)
			  NOPRESERVE (2, 3, 4, 5);

GLOBAL REGISTER
	CCB		= 1 ; ! CCB address returned

LOCAL
	STATUS;				! status of system call

EXTERNAL ROUTINE
	IOC$VERIFYCHAN	: L_VERIFYCHAN ADDRESSING_MODE (ABSOLUTE);
					! exec routine to find CCB

!*
!CALL EXEC ROUTINE TO FIND CCB ADDRESS GIVEN CHANNEL NUMBER

    STATUS = IOC$VERIFYCHAN (.CHANNEL);

!*
!SAVE OLD UCB ADDRESS AND ADDRESS OF UCB ADDRESS IN CCB

    BEGIN
    MAP CCB:REF BLOCK;
    CCBUCB=CCB[CCB$L_UCB];
    OLD_UCB=.CCB[CCB$L_UCB];
    END;

RETURN .STATUS
END;					! end of routine GET_CCB



GLOBAL ROUTINE SET_UCB:NOVALUE=

!++
! FUNCTIONAL DESCRIPTION:
!
!	ROUTINE PLACES THE UCB ADDRESS FOUND IN ITS MAIL FROM
!	F11ACP INTO THE CCB OF THE OPEN CHANNEL, THEREBY
!	HAVING ACCESS TO THE SUSPECT DISK
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	ACP_MAIL: BUFFER CONTAINING MAIL FROM LAST READ OF F11ACP
!			MAILBOX
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

BEGIN


!*
!REPLACE THE UCB ADDRESS

    .CCBUCB=.ACP_MAIL[BBS$L_UCB];
END;


ROUTINE OPEN_CHANNEL=

!++
! FUNCTIONAL DESCRIPTION:
!
!	THE ROUTINE OPENS CHANNEL TO THE SYS$DISK AND
!	ACP$BADBLOCK_MBX. THE SYS$DISK CHANNEL IS USED TO
!	OBTAIN ACCESS TO WHAT MIGHT BE AN ALLOCTATED DISK.
!	THE MBX CHANNEL IS USED TO RECEIVE MAIL FROM THE
!	F11ACP, THAT IS THE WORK ORDERS FOR FILES TO PROCESS
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	CHANNEL: CHANNEL TO SYS$DISK
!	MBX_CHANNEL: CHANNEL TO F11ACP MAILBOX
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	SHOULD EITHER $ASSIGN FAIL THEN THE FAILURE CODE IS RETURNED
!	OTHERWISE SUCCESS IS RETURNED
!
! SIDE EFFECTS:
!
!	NONE
!
!--

BEGIN
LOCAL 
    STATUS;
BIND
    MBX_DESC=UPLIT (%CHARCOUNT('ACP$BADBLOCK_MBX'),
			UPLIT BYTE('ACP$BADBLOCK_MBX'));

!+
!OPEN A CHANNEL THE THE CURRENT DISK

    IF
	NOT (STATUS=$ASSIGN(CHAN=CHANNEL,DEVNAM=DISK_DESC))
    THEN
	RETURN .STATUS;

!+
!OPEN A CHANNEL TO THE MAILBOX FROM F11ACP

    IF
	NOT(STATUS=$ASSIGN(CHAN=MBX_CHANNEL,DEVNAM=MBX_DESC))
    THEN
	BEGIN
	$DASSGN(CHAN=.CHANNEL);
	RETURN .STATUS
	END;

RETURN TRUE
END;

ROUTINE GET_BBSMSG=

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE ATTEMPTS TO READ MAIL FROM THE
!	MAILBOX LINKING THE F11ACP  TO TH BADBLOCK UTILITY
!	IF THE READ IS SUCCESSFUL THE MESSAGE TYPE AND LENGTH
!	OF THE MAIL IS CHECKED, IF EITHER IS WRONG THE MESSAGE
!	IS DISGARDED AND ANOTHER IS READ. IF A READ FAILS,
!	THE FAILURE STATUS IS RETURNED BY THE ROUTINE.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	ACP_MAIL: MAIL IS READ INTO THIS BLOCK
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	IF  THE MAILBOX READ FAILS THE FAILURE IS RETURNED
!	OTHERWISE TRUE.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

BEGIN
LOCAL 
    STATUS;

OWN
    MBX_IOSB:VECTOR[4,WORD];

!+
!LOOP UNTIL AN ERROR OF EOF

    WHILE TRUE DO


        BEGIN
	!++
	!READ FROM THE MAILBOX AND CHECK THE SYS SERV STATUS
	!__
	IF NOT (STATUS=$QIOW(CHAN=.MBX_CHANNEL,
			FUNC=IO$_READVBLK+IO$M_NOW,
			IOSB=MBX_IOSB,
			P1=ACP_MAIL,
			P2=BBS$C_LENGTH))
	
	THEN
	    RETURN .STATUS;

	!++
	!CHECK IO STATUS
	!__
	IF
	    NOT .MBX_IOSB[0]
	THEN
	    RETURN .MBX_IOSB[0];

	!+
	!CHECK FOR PROPER MESSAGE TYPE AND LENGTH

	IF
            (.ACP_MAIL[BBS$B_MSGTYPE] EQL MSG$_SCANBAD)
	    AND
	    (.MBX_IOSB[1] EQL BBS$C_LENGTH)
	THEN
	    RETURN TRUE;

	END
END;

GLOBAL ROUTINE RESTORE_CHANNEL:NOVALUE=

!++
! FUNCTIONAL DESCRIPTION:
!
!	ROUTINE RESTORES THE UCB ADDRESS FO THE SYS$DISK INTO
!	THE ACCESSED CCB AND $DASSGN'S BOTH OPEN CHANNELS
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	CHANNEL: SYS$DISK CHANNEL
!	MBX_CHANNEL: CHANNEL NUMBER TO F11ACP
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

BEGIN
!++
!PUT OLD UCB ADDRESS BACK INTO CCB
!--

    ACP_MAIL[BBS$L_UCB]=.OLD_UCB;
    $CMKRNL(ROUTIN=SET_UCB);

!++
!DE-ASSIGN BOTH ACTIVE CHANNELS
!__
    $DASSGN(CHAN=.CHANNEL);
    $DASSGN(CHAN=.MBX_CHANNEL);		!CLEAR MAILBOX CHANNEL
END;


END
ELUDOM
