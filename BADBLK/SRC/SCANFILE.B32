MODULE SCANFILE (	
		IDENT = 'V03-000'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY:
!	DYNAMIC BAD BLOCK UTILITY
! ABSTRACT:
!	THIS PROCESS EXAMINES FILES SUSPECTED OF CONTAINING BAD
!	DISK BLOCKS. THOSE DISK BLOCKS VERIFIED TO BE BAD ARE ADDED
!	TO THE BAD BLOCK FILE. THE OTHERS ARE RETURNED TO THE VOLUME
!	FOR REUSE.
! ENVIRONMENT:
!	VAX/VMS OPERATING SYSTEM, VERSION 1.0
! AUTHOR:THOMAS G. DOPIRAK	, CREATION DATE:5/16/78
!
! MODIFIED BY:
!
!	 V0002	ACG0059		Andrew C. Goldstein,	21-Aug-1979  20:45
!		Fix repeated write/read test so it really repeats
!
!--

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    SCAN:NOVALUE,		!MAIN PROGRAM OF FILE PROCESSING LOGIC
    GROUP_BLOCKTEST,		!ROUTINE TESTS 'GROUPS' OF BLOCKS
    GROUP_RETURN,		!EXAMINES A GROUP OF BLOCKS WHEN ERROR DETECTED
    CHECK_BADSTATUS,		!DETERMINES WHETHER A STATUS INDICATES A BAD BLOCK
    NORMAL_COMPLETE:NOVALUE,	!CALLED AFTER NORMAL PROCESSING OF A FILE
   ERROR_COMPLETE:NOVALUE,	!CALLED AFTER ABNORMAL PROCESSING OF A FILE
    TRUNCATE,			!TRUNCATES A FILE CONTAINING NO BAD BLOCKS
    TRUNCATE_BAD,		!TRUNCATES  A FILE CONTAINING A BAD BLOCK
    BLOCKTEST,			!TESTS AN INDIVIDUAL BLOCK
    POSITION_TO_EOF,		!ACCESSES A FILE AND DISCOVERS ITS SIZE
    DO_QIOW			!DOES QIOW'S ANS CHECKS STATUS
	;		!

!
! INCLUDE FILES:
!

    LIBRARY 'SYS$LIBRARY:LIB.L32';
!
! MACROS:
!

MACRO
    DIRECTORY_ID=FIB[FIB$W_DID]%,		!START OF DIRECTORY ID
        CSTRING[] = (UPLIT BYTE(%CHARCOUNT(%STRING(%REMAINING)),
		%STRING(%REMAINING)) )%
		;
!
!VARIOUS DEFINITIONS
!

LITERAL
    BLOCK_TEST_SIZE=15,				!NUMBER OF BLOCKS IN A GROUP
    GROUP_SIZE=BLOCK_TEST_SIZE*512,		!NUMBER OF BYTES IN A FROUP
    TRIALS_TO_SUC=3;				!NUMBER OF TIMES A BLOCK MUST BE SUCCESSFULLY BE WRITTEN
						!BEFORE ITS DECLARED NO BAD
!
! OWN STORAGE:
!

OWN

    !BLOCKS OF TEST DATA
    !
    DISK_TEXT:VECTOR[GROUP_SIZE,BYTE],
    GROUP_TEST_DATA:VECTOR[GROUP_SIZE,BYTE],

    READ_FAIL,				!LOGICAL INDICATING IF GROUP FAILED ON READ
    TRUNC_BLOCK,			!FIRST VBN ACTUALLY REMOVED IN TRUNCATE
    BAD_COUNT:INITIAL(0),		!COUNT OF BAD BLOCKS FOUND
    STARTING_BLOCK,			!FIRST VBN IN GROUP
    LAST_BLOCK,				!LAST BLOCK IN A GROUP
    IOSB:VECTOR[4,WORD] INITIAL(0,0),	!IOSB FOR DISK OPERATIONS
    FIB:BLOCK[FIB$C_LENGTH,BYTE]	!FILE IDENTIFICATION BLOCK 
    ;
!
! EQUATED SYMBOLS:
!

BIND

    !
    !SYMBOLS FOR TYPES OF BLOCK TEST RESULTS
    !
	NORMAL_STS=0,		!TEST COMPLETED NORMALLY
	ERROR_STS=1,		!NON-RECOVERABLE ERROR
        BAD_STS=2,		!BAD BLOCK INDICATED
    TRUE=1,
    FALSE=0,
    FIB_DESC=UPLIT(FIB$C_LENGTH,FIB)
    ;
!
! EXTERNAL REFERENCES:
!

EXTERNAL
    CHANNEL:WORD,
    MBX_CHANNEL:WORD,			!CHANNEL TO F11ACP MAILBOX
    ACP_MAIL:BLOCK[,BYTE],		!BUFFER FROM F11ACP
    OLD_UCB
    ;

EXTERNAL ROUTINE
    SET_UCB;

GLOBAL ROUTINE SCAN:NOVALUE=

!++
! FUNCTIONAL DESCRIPTION:
!
!	MAIN ROUTINE FOR FILE PROCESSING. CONTROLS THE 
!	EXAMINATION OF THE FILE IN GROUPS AND THE RETURN
!	OF THE FILES BLOCKS.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	CHANNEL: CHANNEL TO SUSPECT DEVICE
!	ACP_MAIL: MAIL FROM F11ACP
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	THE SUSPECT FILE IS RETURNED TO THE SYSTEM, BLOCKWISE.
!
!--

BEGIN

!++
!CLEAR THE FIB
!__

    CH$FILL(0,FIB$C_LENGTH,FIB);

!*
!INITIALIZE ACCESS TO A FILE AND INITIALIZE LAST_BLOCK

    IF
        NOT POSITION_TO_EOF()
    THEN
	RETURN;

!*
!LOOP THROUGH ALL GROUPS IN THE FILE

    WHILE TRUE DO
	BEGIN
	
	!*
	!FIND START OF GROUP TO TEST

	IF
	    .LAST_BLOCK LSSU BLOCK_TEST_SIZE
        THEN
	    STARTING_BLOCK=1
	ELSE
	    STARTING_BLOCK=.LAST_BLOCK-BLOCK_TEST_SIZE+1;

	!*
	!TEST GROUP OF BLOCKS
	!ACTION DEPENDS UPON WHETHER ANY 'BAD' BLOCKS FOUND

	    CASE CHECK_BADSTATUS(GROUP_BLOCKTEST()) FROM NORMAL_STS TO BAD_STS OF
		SET
		[NORMAL_STS]:			!SUCCESSFUL TEST
		    !++
		    !CHECK TO SEE IF FINISHED
		    !__
		   IF
			.STARTING_BLOCK EQLU 1
		    THEN
			BEGIN
			NORMAL_COMPLETE();
			RETURN
			END
		    ELSE
			LAST_BLOCK=.STARTING_BLOCK-1;
		[ERROR_STS]:			!ERROR BUT NOT BADBLOCK ERROR
		    BEGIN
		    ERROR_COMPLETE();
		    RETURN
		    END;
	
		[BAD_STS]:		!BADBLOCK FOUND,SCAN INDIVIDUAL BLOCKS
		    BEGIN
		    IF
			NOT GROUP_RETURN()
		    THEN
			BEGIN
			ERROR_COMPLETE();
			RETURN
			END;
		    IF
			(.STARTING_BLOCK EQLU 1) OR
			(.TRUNC_BLOCK LEQ 1)
		    THEN
			BEGIN
			NORMAL_COMPLETE();
			RETURN
			END
		    ELSE
			LAST_BLOCK=.TRUNC_BLOCK-1
		    END;
		TES;
	END
END;


ROUTINE POSITION_TO_EOF=

!++
! FUNCTIONAL DESCRIPTION:
!
!	ROUTINE INITIALIZES THE FIB, ACCESSES THE FILE WHOSE
!	FID IS THE ACP_MAIL, AND DETERMINES THE FILES LENGTH
!	IN BLOCKS
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	ACP_MAIL[BBS$W_FID]: FILE ID OF SUSPECT FILE
!
! IMPLICIT OUTPUTS:
!
!	LAST_BLOCK: TOTAL NUMBER OF BLOCKS IN FILE
!	FIB: ASSORTED FIELDS SET BY IO$_ACCESS
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	IF IO$_ACCESS FAILS THEN THAT CODE IS RETURNED
!
! SIDE EFFECTS:
!
!	NONE
!
!--

BEGIN


OWN
    STAT_BLOCK:VECTOR[5,WORD],		!SPACE FOR FILE STATISTICS BLOCK
					!RETURNED BY IO$_ACCESS
    ATTRIBUTES:VECTOR[3]
		    INITIAL(ATR$C_STATBLK^16+10,STAT_BLOCK,0)
    ;

!*
!SET FILE ACCESS ATTRIBUTES

    FIB[FIB$V_WRITE]=1;
    FIB[FIB$V_TRUNC]=1;
!*
!PUSH FILE ID INTO FIB

    CH$MOVE(6,ACP_MAIL[BBS$W_FID],FIB[FIB$W_FID]);

!*
!OPEN THE SPECIFIED FILE AND GET ITS SIZE IN BLOCKS

    DO_QIOW(IO$_ACCESS+IO$M_ACCESS,FIB_DESC,0,0,0,ATTRIBUTES);

!*
!MOVE THE WORD SWAPPED VIRTUAL BLOCK NUMBER 

    LAST_BLOCK<0,16>=.STAT_BLOCK[3];
    LAST_BLOCK<16,16>=.STAT_BLOCK[2];

    RETURN TRUE
END;

ROUTINE TRUNCATE(VBN)=

!++
! FUNCTIONAL DESCRIPTION:
!
!	ROUTINE TRUNCATES OF THE END OF THE CURRENT FILE
!	STARTING AT THE INDICATED BLOCK NUMBER. BECAUSE OF
!	CLUSTERING NOT ALL BLOCKS REQUESTED MAY BE TRUNCATED
!	,LAST BLOCK TRUNCATED IS PLACED INTO TRUNC_BLOCK.
!
! FORMAL PARAMETERS:
!
!	VBN: VIRTUAL BLOCK AT WHICH TO START TRUNCATE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	STATUS OF IO$_MODIFY OPERATION IS RETURNED
!
! SIDE EFFECTS:
!
!	NONE
!
!--

BEGIN
LOCAL
   STATUS;

!*
!SET BLOCK TO TRUNCATE AT

    FIB[FIB$L_EXVBN]=.VBN;

!*
!TRUNCATE A PIECE OFF OF FILE

    STATUS=DO_QIOW(IO$_MODIFY,FIB_DESC,0,0,0,0);
!*
!CLEAR SIZE FIELD 

    FIB[FIB$L_EXSZ]=0;

!*
!CHECK FOR ROUNDING FROM CLUSTERING

    IF
	.VBN NEQ .FIB[FIB$L_EXVBN]
    THEN
	TRUNC_BLOCK=.FIB[FIB$L_EXVBN]
    ELSE
	TRUNC_BLOCK=.VBN;

    RETURN .STATUS

END;

ROUTINE TRUNCATE_BAD(VBN)=

!++
! FUNCTIONAL DESCRIPTION:
!
!	TRUNCATE_BAD PERFORMS 2 TRUNCATIO OPERATIONS.
!	ALL BLOCKS AFTER(HIGHER VBN'S) ARE RETURNED TO
!	THE SYSTEM VIA A CALL TO TRUNCATE. THE CURRENT
!	VBN KNOWN AS 'BAD' IS TRUNCATED OFF THE CURRENT FILE
!	AND ONTO THE BAD BLOCK FILE. DUE TO CLUSTERING, MORE BLOCKS
!	THAN REQUESTED MAY BE ADDED TO THE BAD BLOCK FILE AND
!	TRUNC_BLOCK IS SET TO THE LAST BLOCK ADDED.
!
! FORMAL PARAMETERS:
!
!	VBN: VIRTUAL BLOCK NUMBER OF BLOCK TO MARK BAD
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	TRUNC_BLOCK: LAST BLOCK(LOWEST VBN) ADDED TO BAD BLOCK FILE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	IF EITHER TRUNCATE OPERATION FAILS THEN THAT STATUS IF RETURNED
!
! SIDE EFFECTS:
!
!	NONE
!
!--

BEGIN
LOCAL
   STATUS;

    BAD_COUNT=.BAD_COUNT+1;
!*
!TRUNCATE OFF GOOD PORTIONS OF FILE

    STATUS=TRUNCATE(.VBN+1);
    IF
	(.STATUS NEQ SS$_NORMAL) AND
	(.STATUS NEQ SS$_ENDOFFILE)
    THEN
	RETURN .STATUS;
!*
!SET BLOCK TO TRUNCATE AT

    FIB[FIB$L_EXVBN]=.VBN;

!*
!NOTE RETURN IS TO BAD BLOCK FILE

    FIB[FIB$V_MARKBAD]=1;

!*
!TRUNCATE A PIECE OFF OF FILL

    STATUS=DO_QIOW(IO$_MODIFY,FIB_DESC,0,0,0,0);
!*
!CLEAR SIZE FIELD 

    FIB[FIB$L_EXSZ]=0;

!*
!CHECK FOR ROUNDING FROM CLUSTERING

    IF
	.VBN NEQ .FIB[FIB$L_EXVBN]
    THEN
	TRUNC_BLOCK=.FIB[FIB$L_EXVBN]
    ELSE
	TRUNC_BLOCK=.VBN;


!*
!CLEAR MARK BAD INDICATOR

    FIB[FIB$V_MARKBAD]=0;
    RETURN .STATUS

END;

ROUTINE BLOCKTEST(VBN)=

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE TESTS A SINGLE VIRTUAL BLOCK
!	FOR 'BADNESS' . THE ROUTINE READS THE BLOCK A NUMBER
!	OF TIMES, CHECKING FOR A DATA SENSITIVE CONDITION, AND THEN
!	WRITES AND READS BACK THE WORST CASE PATTERN. UPON ANY 
!	ABNORMAL CONDITION THE ROUTINE EXITS WITH THAT STATUS.
!
! FORMAL PARAMETERS:
!
!	VBN: VIRTUAL BLOCK TO BE TESTED
!
! IMPLICIT INPUTS:
!
!	READ_FAIL: A LOGICAL VARIABLE, WHEN TRUE INDICATES  THAT
!	    GROUP_BLOCKTEST ENCOUNTERED AN ERROR WHILE READING THE
!	    USER DATA ON THE CURRENT GROUP. THIS DIRECTS BLOCKTEST
!	    TO READ THE INDIVIDUAL BLOCKS BEFORE OVERWRITING THEM
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	IF ANY QIOW FAILS THEN ITS STATUS IS RETURNED
!
! SIDE EFFECTS:
!
!	NONE
!
!--

BEGIN

LOCAL
    STATUS;

!*
!IF GROUP TEST FAILED IN DATA DEPENDENT MANNER
!READ THE BLOCK BEFORE OVER WRITING IT

    IF
	.READ_FAIL
    THEN
	INCR TEST_INDEX FROM 1 TO TRIALS_TO_SUC DO
	    IF
		NOT (STATUS=DO_QIOW(IO$_READVBLK+IO$M_INHRETRY,DISK_TEXT,512,.VBN,0,0))
	    THEN
		RETURN .STATUS;

!*
!BLOCK MUST PASS READ/WRITE TEST MULTIPLE BEFORE BEING MARKED GOOD

    INCR TEST_INDEX FROM 1 TO TRIALS_TO_SUC DO
	BEGIN
	!*
	!WRITE TO THE INDICATED  DISK BLOCK

    	IF
	    NOT(STATUS=DO_QIOW(IO$_WRITEVBLK+IO$M_INHRETRY,GROUP_TEST_DATA,512,.VBN,0,0))
        THEN
	    RETURN .STATUS;

	!*
	!TRY AND READ IT BACK

	    IF
	        NOT(STATUS=DO_QIOW(IO$_READVBLK+IO$M_INHRETRY,DISK_TEXT,512,.VBN,0,0))
	    THEN
	        RETURN .STATUS;


	!*
	!MAKE SURE ITS THE SAME

	    IF
		CH$NEQ(512,GROUP_TEST_DATA,512,DISK_TEXT)
	    THEN
		RETURN SS$_PARITY
	END;

    RETURN TRUE

END;

ROUTINE GROUP_BLOCKTEST=

!++
! FUNCTIONAL DESCRIPTION:
!
!	ROUTINE TESTS GROUPS OF VIRTUALLY CONTIGUOUS BLOCKS FOR
!	"BADNESS". SHOULD ANY OF THE IO OPERATIONS FAIL
!	THE STATUS IS IMMEDIATELY RETURNED. GROUPS ARE READ
!	SEVERAL TIMES FOR ERROR.
!	A WORST CASE IS WRITTEN TO THE GROUP AND THEN READ BACK.
!	THE READ DATA IS COMPARED WITH THAT WRITTEN
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	STARTING_BLOCK: FIRST VIRTUAL BLOCK IN GROUP
!	LAST_BLOCK: LAST VIRTUAL BLOCK IN GROUP
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

BEGIN

LOCAL
    CURRENT_SIZE,
    STATUS;


!*
!FOR SHORT FILES OR FOR THE START OF A FILE, GROUP SIZE MAY BE SHORTER
!THAN THE DEFAULT

    IF
	.STARTING_BLOCK EQL 1
    THEN
	CURRENT_SIZE=.LAST_BLOCK*512
    ELSE
	CURRENT_SIZE=GROUP_SIZE;
!*
!DEFAULT THAT FAILURES WILL NOT BE DATA SENSITIVE

    READ_FAIL=FALSE;

!*
!GROUP FAILURE MAY BE DATA SENSITIVE
!READ SEVERAL TIMES BEFORE PASSING TO WRITE/READ TESTING

    INCR TEST_INDEX FROM 1 TO TRIALS_TO_SUC DO
	IF
	    NOT (STATUS=DO_QIOW(IO$_READVBLK+IO$M_INHRETRY,DISK_TEXT,.CURRENT_SIZE,.STARTING_BLOCK,0,0))
	THEN
	    BEGIN
	    READ_FAIL=TRUE;
	    RETURN .STATUS
	    END;
!*
!GROUP MUST PASS WRITE/READ TEST MULTIPLE TIMES BEFORE 
!BEING CONSIDERED GOOD

    INCR TEST_INDEX FROM 1 TO TRIALS_TO_SUC DO
	BEGIN
	!*
	!WRITE TO THE INDICATED  DISK BLOCK

	    IF
		NOT(STATUS=DO_QIOW(IO$_WRITEVBLK+IO$M_INHRETRY,GROUP_TEST_DATA,.CURRENT_SIZE,.STARTING_BLOCK,0,0))
	    THEN
		RETURN .STATUS;

	!*
	!TRY AND READ IT BACK

	    IF
	        NOT(STATUS=DO_QIOW(IO$_READVBLK+IO$M_INHRETRY,DISK_TEXT,.CURRENT_SIZE,.STARTING_BLOCK,0,0))
	    THEN
	        RETURN .STATUS;


	!*
	!MAKE SURE ITS THE SAME

	    IF
		CH$NEQ(.CURRENT_SIZE,GROUP_TEST_DATA,.CURRENT_SIZE,DISK_TEXT)
	    THEN
		RETURN SS$_PARITY
        END;

    RETURN TRUE

END;

ROUTINE DO_QIOW(FUNCTION,P1,P2,P3,P4,P5)=

!++
! FUNCTIONAL DESCRIPTION:
!
!	COMMON ROUTINE FOR PERFORMING $QIOW SYSTEM SERVICE
!
! FORMAL PARAMETERS:
!
!	FUNCTION:THE QIOW FUNCTION CODE
!	P1:	THE ADDRESS OF THE P1 PARAMETER
!	P2:	THE ADDRESS OF THE P2 PARAMETER
!	P3:	THE ADDRESS OF THE P3 PARAMETER
!	P4:	THE ADDRESS OF THE P4 PARAMETER
!
! IMPLICIT INPUTS:
!
!	CHANNEL:	THE CHANNEL NUMBER TO THE FILES ACP
!	IOSB:		THE IO STATUS BLOCK
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	RETURNS THE SYSTEM SERVICE CODE FOR THE $QIOW

!
! SIDE EFFECTS:
!
!	NONE
!
!--

BEGIN
LOCAL
    STATUS;
!*
!DO QIOW AND CHECK IO SERVICE RETURN

    IF
	NOT (STATUS=$QIOW(CHAN=.CHANNEL,IOSB=IOSB,
		FUNC=.FUNCTION,
		P1=.P1,
		P2=.P2,
		P3=.P3,
		P4=.P4,
		P5=.P5))
    THEN
	RETURN .STATUS;

!*
!CHECK IO COMPLETION RETURN

    IF
	NOT .IOSB[0]
    THEN
	RETURN .IOSB[0]
    ELSE
        RETURN TRUE

END;

GLOBAL ROUTINE DATA_INIT:NOVALUE=

!++
! FUNCTIONAL DESCRIPTION:
!
!	INITIALIZES TEST BLOCKS WITH THE WORST CASE PATTERN
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	GROUP_TEST_DATA: BUFFER USED TO WRITE GROUPS OF BLOCKS
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

BEGIN
REGISTER
    POINTER,
    END_POINTER;
LITERAL
    WORST_CASE_PAT=%O'165555'^16+%O'133333';

!*
!INIT POINTERS TO BUFFER

    POINTER=GROUP_TEST_DATA[0];
    END_POINTER=(GROUP_SIZE^-4)+.POINTER;

!*
!FILL BUFFER WITH WORST CASE PATTERN

    WHILE .POINTER NEQU .END_POINTER DO
	BEGIN
	.POINTER=WORST_CASE_PAT;
	POINTER=.POINTER+4
	END;

    RETURN

    
    END;

ROUTINE CHECK_BADSTATUS(STATUS)=

!++
! FUNCTIONAL DESCRIPTION:
!
!	ROUTINE CLASSIFYS THE SYSTEM SERVICE CODES THAT IT RECEIVES
!	AS INPUT INTO 3 CATAGORIES
!		NORMAL_STS:  SS$_NORMAL
!		BAD_STS: DEVICE ERROR INDICATING A BAD BLOCK
!		ERROR_STS: UNRECOVERABLE DEVICE ERROR
!
! FORMAL PARAMETERS:
!
!	STATUS: A SYSTEM SERVICE CODE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!	RETURNS AS A VALUE ON OF THE 3 ABOVE MENTIONED CODES
!		NORMAL_STS,ERROR_STS,BAD_STS
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

BEGIN

!*
!POSSIBLE IO CODES ARE DIVIDED INTO THREE CASES
!GOOD BLOCKS,BAD BLOCKS AND SEVERE DEVICE ERRORS

SELECTONE .STATUS OF
    SET
    [SS$_NORMAL]:RETURN NORMAL_STS;
    [SS$_PARITY,
	SS$_CTRLERR,
	SS$_DRVERR]: RETURN BAD_STS;
    [OTHERWISE]:RETURN ERROR_STS
    TES;
END;

ROUTINE NORMAL_COMPLETE:NOVALUE=

!++
! FUNCTIONAL DESCRIPTION:
!
!	CALLED AFTER ENTIRE FILE HAS BEEN SCANNED FOR BAD BLOCKS
!	ANY OF THE FILE REMAINING IS GOOD AND SHOULD BE
!	RETURNED TO THE VOLUME. FILE IS DELETED AND DEACCESSED
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	FIB: FILE IDENTIFICATION OF CURRENT FILE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

BEGIN
LOCAL
    STATUS;

!*
!TRUNCATE ANY OF THE FILE THAT REMAINS

    STATUS=TRUNCATE(1);
    IF
	(.STATUS NEQ SS$_NORMAL) AND
	(.STATUS NEQ SS$_ENDOFFILE)
    THEN
	BEGIN
	ERROR_COMPLETE();
	RETURN
	END;

!*
!DELETE THE FILE

    IF
        NOT DO_QIOW(IO$_DELETE+IO$M_DELETE,FIB_DESC,0,0,0,0)
    THEN
	BEGIN
	ERROR_COMPLETE();
	RETURN
	END;

!*
!DEACCESS THE FILE

    DO_QIOW(IO$_DEACCESS,FIB_DESC,0,0,0,0);

RETURN 
END;

ROUTINE ERROR_COMPLETE:NOVALUE=

!++
! FUNCTIONAL DESCRIPTION:
!
!	CALLED WHEN A FATAL DEVICE ERROR OR SYSTEM SERVICE ERROR
!	IS ENCOUNTERED DURING PROCESSING. THE CURRENT FILE IS DEACCESSED
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

BEGIN

!*
!DEACCESS THE FILE

   DO_QIOW(IO$_DEACCESS,FIB_DESC,0,0,0,0);


RETURN
END;

ROUTINE GROUP_RETURN=
!++
! FUNCTIONAL DESCRIPTION:
!
!
!	CALLED WHEN A BAD BLOCK ERROR IS ENCOUNTERED  BY
!	GROUP BLOCK TESTING. THE INDIVIDUAL BLOCKS IN A GROUP
!	ARE TESTED FOR "BADNESS" AND TRUNCATED OFF THE CURRENT
!	FILE AND INTO THE BAD BLOCK FILE WHEN FOUND
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	STARTING_BLOCK: FIRST BLOCK IN GROUP
!	LAST_BLOCK: LAST BLOCK IN GROUP
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

BEGIN
LOCAL
    VBN;

!*
!INDIVIDUALLY CONSIDER ALL BLOCKS IN THE GROUP
!RETURN EACH TO THE BADBLOCK FILE OR FREE SPACE

VBN=.LAST_BLOCK;
WHILE TRUE DO
    BEGIN

    CASE CHECK_BADSTATUS(BLOCKTEST(.VBN)) 
	FROM NORMAL_STS TO BAD_STS OF
	SET

	[NORMAL_STS]:TRUNC_BLOCK=.VBN;

        [ERROR_STS]:RETURN FALSE;

        [BAD_STS]:TRUNCATE_BAD(.VBN);

	TES;
	VBN=.TRUNC_BLOCK-1;
	IF
	    .VBN LSS .STARTING_BLOCK
	THEN
	    RETURN TRUE
    END

END;



END				!End of module
ELUDOM
