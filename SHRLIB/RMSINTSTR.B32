 !	$begin	rmsintstr,V03-003 
 ! 
 !**************************************************************************** 
 !*									    * 
 !*  COPYRIGHT (c) 1978, 1980, 1982 BY					    * 
 !*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    * 
 !*  ALL RIGHTS RESERVED.						    * 
 !* 									    * 
 !*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   * 
 !*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   * 
 !*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   * 
 !*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   * 
 !*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   * 
 !*  TRANSFERRED.							    * 
 !* 									    * 
 !*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   * 
 !*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   * 
 !*  CORPORATION.							    * 
 !* 									    * 
 !*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   * 
 !*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    * 
 !* 									    * 
 !*									    * 
 !**************************************************************************** 
 ! 
 !	internal rms structure definitions 
 ! 
 !	Modified By: 
 ! 
 !	V03-003 MCN0008		Maria del C. Nasr	25-Mar-1982 
 !		Change KBUFSZ to a word instead of a byte. 
 ! 
 !	V03-002	CDS0015		C Saether		22-Mar-1982 
 !		Add GBH$L_HI_VBN field. 
 !		Add IFB$B_DRT_REHIT, IFB$B_GBL_REHIT, 
 !		GBH$L_CROSS_HIT, GBD$W_LAST_ID, GBD$W_LST_LK_ID, 
 !		GBD$B_REHIT_RD, and GBD$B_REHIT_LK fields. 
 ! 
 !	V03-001	CDS0014		C Saether		18-Feb-1982 
 !		Add GBPB$L_VBNSEQNO and GBD$V_VAL fields. 
 ! 
 !	V02-084	KBT0005		K B Thompson		15-Feb-1982 
 !		Add IRB$W_NID_RIGHT, IRB$W_NID_MID and IRB$W_RFA_NID 
 ! 
 !	V02-083	KEK0018		K. E. Kinnear		9-Feb-1982 
 !		Add FWA$C_MTMAXNAM and FWA$C_MTLNONTAP symbols for ANSI-"a" 
 !		filespec parsing.  Remove padding at end of first page. 
 !		Lengthen FWA$T_NAMEBUF from 19 to 36 bytes long. 
 ! 
 !	V02-082	CDS0013		C Saether		 4-Feb-1982 
 !		Move IFB$W_GBC to be part of the record attributes. 
 !		Add IRB$L_RBF and IRB$W_RSZ fields. 
 ! 
 !	V02-081	KPL0014		Peter Lieberwirth	20-Jan-1982 
 !		Shorten some names in RLB. 
 ! 
 !	V02-080	CDS0012		C Saether		17-Jan-1982 
 !		Add IFB$W_GBC field to ifab.  Add GBH$L_GS_SIZE field. 
 !		Change GBH$L_TRACE_FLNK and BLNK to GBH$L_TRC_FLNK and BLNK, 
 !		and GBPB$B_CACHE_VAL to GBPB$B_CACHE_VL so names don't 
 !		exceed 15 characters.  Also shorten some TRC names. 
 ! 
 !	V02-079	CDS0011		C Saether		 8-Jan-1982 
 !		Add GBD_START, GBD_END, GBD_NEXT, SCAN_NUM to GBH struct. 
 !		Add NUMB, remove IOSB, delete FLAGS defs, and shuffle 
 !		fields in GBD structure. 
 !		Delete FLGS defs in GBPB structure. 
 !		Add FWA$T_XLTBUFF3. 
 ! 
 !	V02-078	CDS0010		C Saether		30-Dec-1981 
 !		Add NEXT_DOWN alias for VBN_MID irab field. 
 !		Move KEYSZ in irab to align longwords at end. 
 ! 
 !	V02-077	CDS0009		C Saether		28-Dec-1981 
 !		Changes to TRC fields. 
 ! 
 !	V02-076	CDS0008		C Saether		 9-Dec-1981 
 !		Add BADBLB and BADOWNER fatal bugcheck codes. 
 !		Add BLB$V_WRITEBACK flag. 
 !		Further modify TRC and GBH definitions. 
 ! 
 !	V02-075	CDS0007		C Saether		 8-Dec-1981 
 !		Eliminate the READAHEAD CSH and BLB flag. 
 ! 
 !	V02-074 JWH0001		Jeffrey W. Horn		03-Dec-1981 
 !		Move Directory BDB equivalences from RM0DIRSCN into BDB 
 !		MDL definition. 
 ! 
 !	V02-073	KPL0013		Peter Lieberwirth	23-Nov-1981 
 !		Clean up some RLB commentary. 
 ! 
 !	V02-072	TMK0015		Todd M. Katz		12-Nov-1981 
 !		Add bits IFB$V_RMS_STALL and IRB$V_RMS_STALL to the IFAB 
 !		and IRAB respectively. These bits are set within RM0STALL 
 !		and cleared after delivery of RMS's AST at RM$THREADGO either 
 !		because RMS must wait for an I/O operation to complete 
 !		before it can resume its thread, or because RMS must wait for 
 !		a file/record lock before it can continue. NOTE: if the user 
 !		requested an asynchronous operation, it is RMS which is stalled 
 !		and must wait before completing the operation, and not the user 
 !		who will be able to continue. 
 ! 
 !	V02-071	RAS0045		Ron Schaefer		11-Nov-1981 
 !		Increase the FWA internal device buffer size to 63 chars 
 !		in order to handle concealed device names and add 
 !		FWA$T_SHRFILDEV field, making the FWA over 1 page. 
 ! 
 !	V02-070	RAS0040		Ron Schaefer		26-Oct-1981 
 !		Implement rooted directories for concealed devices. 
 !		Add FWA$T_MFD_FID for the root directory's FID. 
 !		Add FWA$V_DFLT_MFD and FWA$V_ROOT_DIR flags. 
 !		Add 10-byte FWA$T_ROOT_DIR buffer for root directory string. 
 ! 
 !	V02-069	CDS0006		C Saether		14-Oct-1981 
 !		Eliminate overlap of assigned device char and blb header. 
 ! 
 !	V02-068	CDS0005		C Saether		 8-Oct-1981 
 !		Add all cache flags to BLB flags (specifically NOBUFFER). 
 ! 
 !	V02-067	CDS0004		C Saether		 9-Sep-1981 
 !		Add IFB$L_GBH_PTR field.  Pad out GBH to quad align length. 
 !		Define trace block arguments. 
 ! 
 !	V02-066	CDS0003		C Saether		31-Aug-1981 
 !		Make IFB$W_AVLCL and IFB$W_AVGBPB part of all ifabs. 
 ! 
 !	V02-065	CDS0002		C Saether		19-Aug-1981 
 !		Extend length of FIB 4 bytes. 
 ! 
 !	V02-064	CDS0001		C Saether		14-Aug-1981 
 !		Modifications to BDB structure: 
 !		1) Remove USECNT field 
 !		2) Add CACHE_VAL field 
 !		3) Add USERS field 
 !		4) Add BUFF_ID field 
 !		5) Rename OWN to BLB_PTR field 
 !		6) Remove LKDINWS flag. 
 ! 
 !		Add GBPB structure. 
 !		Add RLS$V_DEQ flag to RLS flags. 
 !		Add IFB$L_BLBFLNK, IFB$L_BLBBLNK to IFAB. 
 !		Add IFB$W_AVGBPB, IFB$W_AVLCL to IFAB. 
 !		Add IRB$V_GBLBUFF to IRAB book keeping bits. 
 !		Add a series of new bugcheck codes for cache. 
 !		Add GBH, TRC, GBD, and BLB structures. 
 ! 
 !		Remove RLS$V_KEEP_ACC flag. 
 ! 
 !	V02-063	TMK0003		T M Katz		10-Aug-1981 
 !		Add FWA$T_WILD, a 16 byte scratch field for RM0WILD 
 ! 
 !	V02-062	TMK0002		T M Katz		10-Aug-1981 
 !		Change MAXDIRLEN to 81 from 60. 
 ! 
 !	V02-061	PSK0010		Paulina S. Knibbe	 8-Aug-1981 
 !		Remove all support for truncated index keys. 
 !		UKEY_ONLY, CTX block. Add IRB$L_SPL_COUNT to keep 
 !		track of the number of the record we are moving into 
 !		the next bucket on an INDEX or SIDR split. 
 ! 
 !	V02-060	KPL0012		Peter Lieberwirth	 3-Aug-1981 
 !		Move list of RLBs to IRAB from IFAB.  This makes the 
 !		multistreaming code much easier. 
 ! 
 !	V02-059	PSK0009		Paulina S. Knibbe	08-Jun-1981 
 !		1) Add UKEY_ONLY bit to say to update only the key in an 
 !		   index record. 
 !		2) Add DIFF_CHAR to IRAB to keep track of 
 !		   which character distinguishes between two key values 
 !		3) Add CTX block to hold split context for 
 !		   prologue three files 
 ! 
 !		PSK0008		Paulina S. Knibbe	05-May-1981 
 !		Add LST_NCMP to IRAB to keep track of addr of last key with 
 !		no front compression. 
 ! 
 !		MCN0007		Maria del C. Nasr	23-Apr-1981 
 !		Add record buffer in IRAB for prologue 3 files. 
 ! 
 !		PSK0007		Paulina S. Knibbe	21-Apr-1981 
 !		Make sure IRAB is an even multiple of longwords 
 ! 
 !		PSK0006		Paulina S. Knibbe	17-Apr-1981 
 !		Add bits to IDX to tell if data level record is 
 !		compressed (REC_COMPR) or if the primary key 
 !		is compressed (KEY_COMPR). Remove constant for 
 !		largest non-compressed key (this will be in FILSTR 
 !		and having it in two places asks for trouble). 
 !		Rework the bucket types. 
 ! 
 !		PSK0005		Paulina S. Knibbe	06-Apr-1981 
 !		Add fields to IDX to tell which flavor of bucket is 
 !		used for the index and primary data buckets for this 
 !		key. 
 ! 
 !		PSK0004		Paulina S. Knibbe	30-Mar-1981 
 !		Add flag to IDX to indicate that the key portion of 
 !		the index  and SIDR records are fixed or variable. 
 !		(For prologue 3 files). 
 ! 
 !		PSK0003		Paulina Knibbe		19-Mar-1981 
 !		Add REC_COUNT to IRAB so we can maintain it while 
 !		searching keys and use it while fetching VBN's 
 ! 
 !		PSK0002		Paulina Knibbe		17-Mar-1981 
 !		Add constant for longest key not compressed 
 ! 
 !		PSK0001		Paulina Knibbe		16-Mar-1981 
 !		Change the segment size to a byte length and 
 !		add segment datatype to IDX structure 
 ! 
 !		MCN0006		Maria del C. Nasr	13-Mar-1981 
 !		Increase size of record identifier to a word in the 
 !		IRB, NRP, and RLB internal structures. 
 ! 
 !	V02-058	KPL0011		Peter Lieberwirth	2-Jun-1981 
 !		Change RLB to add fields for lock manager interface. 
 ! 
 !	V02-057	JAK0059		J A Krycka		15-Jun-1981 
 !		Remove symbols from the FWA that are no longer in use, namely: 
 !		FWA$B_FTYPSIZ, FWA$B_FVERSIZ, FWA$B_DMYPWDSIZ, FWA$C_DMYPWDSIZ. 
 ! 
 !	V02-056	KRM0017		K R Malik		27-May-1981 
 !		Add FWA$B_FTYPSZ and FWA$B_FVERSIZ. 
 ! 
 !	V02-055	KPL0007		Peter Lieberwirth	27-Apr-1981 
 !		Add a pointer to the SFSB (Shared File Synchronization 
 !		Block) in the IFAB 
 ! 
 !	V02-054	kpl0002		Peter Lieberwirth	12-Jan-1981 
 !		add FTL codes ENQDEQFAIL and NOCURBDB to support new 
 !		record locking code 
 ! 
 !	V02-053 ras0053		Ron Schaefer	24-Nov-1980	14:43 
 !		merge RMSINT and RMSIDXSTR internal structures into 
 !		one file containing all 
 !		in-memory structures and no on-disk structures. 
 ! 
 !	V02-052	REFORMAT	Keith B. Thompson	29-JUL-1980 
 ! 
 !	V051	jak0045		J A Krycka	21-MAR-1980	15:00 
 !		remove IFB$V_DAP_FMODE. 
 ! 
 !	V050	cds0075		C D Saether	21-JAN-1980	11:25 
 !		remove IFB$L_FWA_BDB, IFB$W_BKS_BYTES, IFB$W_BKS_RECS. 
 ! 
 !	V049	ras0010		R A Schaefer	07-JAN-1980	16:45 
 !		re-arrange drc fields for valid did check. 
 ! 
 !	V048	ras0009		R A Schaefer	20-DEC-1979	15:30 
 !		add FWA$T_RNM_FID to hold the saved fid from a rename 
 !		for checking bad rename directory operation. 
 ! 
 !	V047	jak0029		J A Krycka	18-NOV-1979	11:00 
 !		add FWA$V_REMRESULT to denote that fal has returned resultant 
 !		string. 
 ! 
 !	v046	tmh0003		Tim Halvorsen	02-NOV-1979 
 !		add FWA$L_DIRBDB to hold address of directory buffer bdb 
 !		add FWA$V_FILEFOUND bit to indicate that at least one file 
 !		has been found - used to return FNF vs. NMF. 
 ! 
 !	V045	jak0025		J A Krycka	28-SEP-1979	17:00 
 !		add FWA$V_DEV_UNDER in conjunction with effort to 
 !		modify expanded and resultant name string processing to prefix 
 !		an underscore to node and device names that have been subject 
 !		to logical name translation. 
 ! 
 !	V044			Tim Halvorsen	12-SEP-1979 
 !		add IFB$V_SEARCH bit to mark ifabs left during searches. 
 ! 
 !	V043			Tim Halvorsen	11-SEP-1979 
 !		overlay the fib buffer with the node descriptors to reduce 
 !		the total space used by fwa.  increase the size of the file 
 !		name and type buffers due to the new maximum sizes which can 
 !		occur as a result of wild characters (i.e. *a*b*c*d*e etc). 
 ! 
 !	V042	jak0023		J A Krycka	27-AUG-1979	18:00 
 !		move FWA$T_NODEBUF to NWA$T_NODEBUF and add FWA$Q_DIR1 thru 
 !		FWA$Q_DIR8 in conjunction with effort in RM0XPFN to allow 
 !		multiple node specs in a file specification. 
 ! 
 !	v041	cds0022		C Saether	26-july-79	22:45 
 !		add IFB$V_SEQFIL to bookkeeping bits. 
 ! 
 !	V040	cds0000		C Saether	16-JAN-1979	14:00 
 !		remove definition of lockabove from srchflags in irab 
 !		and add abovelckd to bookeeping bits 
 ! 
 !	V039	wsk0000		W S Koenig	10-JAN-1979	1:25 
 !		fix problem w/ IDX_PTR overlapping w/ AS_DEV longwords 
 ! 
 !	V038	jak0017		J A Krycka	28-DEC-1978	14:30 
 !		make IFB$L_NWA_PTR and IFB$L_FRB_PTR separate locations so that 
 !		networking and file sharing do not interfere with each other. 
 ! 
 !	V037	ran0003		R A Newell	20-DEC-1978	17:35 
 !		file sharing and isam changes. 
 ! 
 !	V036	jak0007		J A Krycka	17-DEC-1978	19:00 
 !		change values of FWA$C_MAXNODE and FWA$C_NODBUFSIZ. 
 ! 
 !	V035	jak0006		J A Krycka	21-NOV-1978	16:40 
 !		add FWA$V_ACCSTR definition. 
 ! 
 !	V034	ran0002		R A Newell	1-NOV-1978	09:49 
 !		RMS32 isam modifications.  additions of isam fields, take out 
 !		NWA, add PLG_VER, change ASB size, define PTR_VBN, update, 
 !		UPD_NRP, RFA_VBN, and RFA_ID fields. 
 ! 
 !++ 
  
 ! 
 !	ifab field definitions 
 ! 
 !  there is one ifab (internal file access block) per open file 
 ! 
 !...$IFBDEF	
  
 !+++++***** 
 !  the fields thru last_fab inclusive are common between the ifab and irab 
 ! 
 			 
 						! bookkeeping bits start in longword 2 
 			! (but have definitions that allow them to 
 			!  be referenced from the start of the ifab) 
 			!++ 
 			!  the following bits are defined in 
 			!  common with the irab 
 			! 
 MACRO		IFB$V_BUSY	= 0,32,1,0%; 		! stream busy 
 MACRO		IFB$V_EOF	= 0,33,1,0%; 		! file positioned at eof 
 MACRO		IFB$V_PPF_IMAGE	= 0,34,1,0%; 	! flag for indirect processing of process- 
 			! permanent files (restricts allowable operations) 
 MACRO		IFB$V_ASYNC	= 0,35,1,0%; 		! async i/o flag (must be zero for ifab) 
 MACRO		IFB$V_ASYNCWAIT	= 0,36,1,0%; 	! wait on async i/o (must be zero for ifab) 
 			!-- 
 			! 
 			!  ifab specific bits 
 			! 
 MACRO		IFB$V_ACCESSED	= 0,37,1,0%; 	! file is accessed 
 MACRO		IFB$V_ANSI_D	= 0,38,1,0%; 	! ansi d variable records 
 MACRO		IFB$V_RWC	= 0,39,1,0%; 		! copy of fop bit from open 
 MACRO		IFB$V_DMO	= 0,40,1,0%; 		! copy of fop bit from open 
 MACRO		IFB$V_SPL	= 0,41,1,0%; 		! copy of fop bit from open 
 MACRO		IFB$V_SCF	= 0,42,1,0%; 		! copy of fop bit from open 
 MACRO		IFB$V_DLT	= 0,43,1,0%; 		! copy of fop bit from open 
 MACRO		IFB$V_DFW	= 0,44,1,0%; 		! deferred write (copy of fop bit from $open) 
 MACRO		IFB$V_SQO	= 0,45,1,0%; 		! sequential operations only 
 MACRO		IFB$V_PPF_INPUT	= 0,46,1,0%; 	! this is command 'input' stream 
 MACRO		IFB$V_NFS	= 0,47,1,0%; 		! non-file structured flag 
 MACRO		IFB$V_WRTACC	= 0,48,1,0%; 	! logical or of fac bits: 
 			!   put, upd, del, trn 
 MACRO		IFB$V_MSE	= 0,49,1,0%; 		! multi-streams enabled 
 MACRO		IFB$V_CREATE	= 0,50,1,0%; 	! set if doing create (may be "create if") 
 MACRO		IFB$V_NORECLK	= 0,51,1,0%; 	! record locking not required 
 			! (i.e., no shared access or multi-stream) 
 MACRO		IFB$V_RW_ATTR	= 0,52,1,0%; 	! set if file attributes must be re-written 
 MACRO		IFB$V_TMP	= 0,53,1,0%; 		! temporary file (i.e., no directory entry) 
 MACRO		IFB$V_TEF	= 0,54,1,0%; 		! truncate at eof due to large auto extend 
 MACRO		IFB$V_SIFB_OWND	= 0,55,1,0%; 	! sifab owned by internal frb 
 MACRO		IFB$V_SEQFIL	= 0,56,1,0%; 	! this is really a sequential file being shared 
 MACRO		IFB$V_SEARCH	= 0,57,1,0%; 	! search ifab - left during wildcard operations 
 MACRO		IFB$V_RMS_STALL	= 0,58,1,0%; 	! RMS is stalled on this file operation 
 						! spare 
 MACRO		IFB$V_NWA	= 0,60,1,0%; 		! network work area control block present 
 MACRO		IFB$V_DAP_OPEN	= 0,61,1,0%; 	! open/create function was performed via dap 
 MACRO		IFB$V_DAP	= 0,62,1,0%; 		! data access protocol transmission 
 MACRO		IFB$V_NSP	= 0,63,1,0%; 		! network services protocol transmission 
 			
 MACRO		IFB$L_PRIM_DEV	= 0,0,32,0%; 	! device characteristics bits 
 			! (for primary device - bit encoding same as for fab) 
 MACRO		IFB$L_BKPBITS	= 4,0,32,0%; 	! bookkeeping bits 
 ! 
 MACRO		IFB$B_BID	= 8,0,8,0%; 		! block id 
 LITERAL	IFB$C_BID	= 11; 		! ifab id code 
 MACRO		IFB$B_BLN	= 9,0,8,0%; 		! block length in longwords 
 MACRO		IFB$B_MODE	= 10,0,8,0%; 	! caller's mode 
 MACRO		IFB$B_EFN	= 11,0,8,0%; 		! event flag used for synchronous qio 
 MACRO		IFB$L_IOS	= 12,0,32,0%; 		! internal i/o status block 
 MACRO		IFB$L_BWB	= 12,0,32,0%; 	! bucket wait block for inter stream waiting 
 MACRO		IFB$W_IOS2	= 14,0,16,0%; 	! high word of io status block 
 MACRO		IFB$L_IOS4	= 16,0,32,0%; 	! 2nd longword of io status block 
 MACRO		IFB$L_ASBADDR	= 20,0,32,0%; 	! address of asynchronous context block 
 MACRO		IFB$L_ARGLST	= 24,0,32,0%; 	! user call parameters addr 
 MACRO		IFB$L_IRAB_LNK	= 28,0,32,0%; 	! pointer to irab(s) 
 MACRO		IFB$W_CHNL	= 32,0,16,0%; 	! i/o channel number 
 MACRO		IFB$B_FAC	= 34,0,8,0%; 		! file access 
 			 
 MACRO		IFB$V_PUT	= 34,0,1,0%; 		! (same as in fab's fac field) 
 LITERAL	IFB$M_PUT	= 1^1 - 1^0; 
 MACRO		IFB$V_GET	= 34,1,1,0%;  
 LITERAL	IFB$M_GET	= 1^2 - 1^1; 
 MACRO		IFB$V_DEL	= 34,2,1,0%;  
 LITERAL	IFB$M_DEL	= 1^3 - 1^2; 
 MACRO		IFB$V_UPD	= 34,3,1,0%;  
 LITERAL	IFB$M_UPD	= 1^4 - 1^3; 
 MACRO		IFB$V_TRN	= 34,4,1,0%;  
 LITERAL	IFB$M_TRN	= 1^5 - 1^4; 
 MACRO		IFB$V_BIO	= 34,5,1,0%;  
 LITERAL	IFB$M_BIO	= 1^6 - 1^5; 
 MACRO		IFB$V_BRO	= 34,6,1,0%;  
 LITERAL	IFB$M_BRO	= 1^7 - 1^6; 
 MACRO		IFB$V_EXE	= 34,7,1,0%;  
 LITERAL	IFB$M_EXE	= 1^8 - 1^7; 
 			
 			! note: if both bio and bro set, implies block i/o 
 			!	access only allowed for this connect, resets 
 			!	to bro on disconnect (seq. file org. only). 
 			! 
 MACRO		IFB$B_ORGCASE	= 35,0,8,0%; 	! copy of org for case dispatching 
 MACRO		IFB$L_LAST_FAB	= 36,0,32,0%; 	! address of fab for last operation 
 !-----***** 
 MACRO		IFB$L_NWA_PTR	= 40,0,32,0%; 	! pointer to network work area control block 
 MACRO		IFB$L_FRB_PTR	= 44,0,32,0%; 	! pointer to "shared" file resource block 
 MACRO		IFB$L_BDB_FLNK	= 48,0,32,0%; 	! pointer to bdb(s) 
 MACRO		IFB$L_BDB_BLNK	= 52,0,32,0%; 	! bdb backward link 
 MACRO		IFB$W_DEVBUFSIZ	= 56,0,16,0%; 	! device default (or bls if mt) buff size 
 MACRO		IFB$W_RTDEQ	= 58,0,16,0%; 	! run-time default extend quantity 
 ! 
 !+++++***** 
 ! 
 !  the following fields must remain as is since 
 !  they correspond to the rms attributes stored 
 !  in the file header 
 ! 
 MACRO		IFB$B_RFMORG	= 60,0,8,0%; 	! organization and record format 
 			 
 MACRO		IFB$V_RFM	= 60,0,4,0%; 		! record format 
 			! (n.b. constant values defined 
 			!  in rfm field of fab) 
 MACRO		IFB$V_ORG	= 60,4,4,0%; 		! file organization 
 			
 LITERAL	IFB$C_SEQ	= 0; 		! sequential 
 LITERAL	IFB$C_REL	= 1; 		! relative 
 LITERAL	IFB$C_IDX	= 2; 		! indexed 
 LITERAL	IFB$C_DIR	= 3; 		! direct 
 LITERAL	IFB$C_MAXORG	= 2; 		! release 1.5 maximum 
 MACRO		IFB$B_RAT	= 61,0,8,0%; 		! record attributes 
 			! (n.b. bit offsets defined in 
 			!  rat field of fab) 
 MACRO		IFB$W_LRL	= 62,0,16,0%; 		! longest record's length 
 			! (or fixed record length) 
 MACRO		IFB$L_HBK	= 64,0,32,0%; 		! hi vbn allocated 
 			! (note: reversed on disk!) 
 MACRO		IFB$L_EBK	= 68,0,32,0%; 		! eof vbn 
 			! (note: reversed on disk!) 
 MACRO		IFB$W_EBK0	= 68,0,16,0%;  
 MACRO		IFB$W_EBK2	= 70,0,16,0%;  
 MACRO		IFB$W_FFB	= 72,0,16,0%; 		! first free byte in eof block 
 MACRO		IFB$B_BKS	= 74,0,8,0%; 		! bucket size (# vbns) 
 MACRO		IFB$B_FSZ	= 75,0,8,0%; 		! record header size for vfc 
 MACRO		IFB$W_MRS	= 76,0,16,0%; 		! max record size allowable 
 MACRO		IFB$W_DEQ	= 78,0,16,0%; 		! default extend quantity 
 MACRO		IFB$W_GBC	= 80,0,16,0%; 		! global buffer count 
 LITERAL	IFB$C_FHAEND	= 82; 
 LITERAL	IFB$K_FHAEND	= 82; 		! end of file header attributes 
 MACRO		IFB$B_DRT_REHIT	= 82,0,8,0%; 	! hit count for local dirty buffers. 
 MACRO		IFB$B_GBL_REHIT	= 83,0,8,0%; 	! rehit count for gbl buffers. 
 !-----***** 
 !++ 
 ! 
 MACRO		IFB$L_NRP_LIST	= 84,0,32,0%; 	! ptr to nrp list for idx files, temp for other orgs 
 MACRO		IFB$L_RNS_LEN	= 84,0,32,0%; 	! resultant name string length 
 			! (used by $search) 
 MACRO		IFB$L_LOCK_BDB	= 84,0,32,0%; 	! lock bdb address (used by $extend for rel. file) 
 MACRO		IFB$L_SFSB_PTR	= 88,0,32,0%; 	! pointer to shared file synchronization block 
 MACRO		IFB$W_AVLCL	= 92,0,16,0%; 	! Local buffers available. 
 MACRO		IFB$W_AVGBPB	= 94,0,16,0%; 	! Gbl ptr blocks available. 
 MACRO		IFB$L_GBH_PTR	= 96,0,32,0%; 	! Pointer to global header. 
 MACRO		IFB$L_AS_DEV	= 100,0,32,0%; 	! assigned device characteristics 
 MACRO		IFB$W_ASDEVBSIZ	= 106,0,16,0%; 	! assigned device buffer size 
 MACRO		IFB$L_BLBFLNK	= 108,0,32,0%; 	! Forward link to BLB chain. 
 MACRO		IFB$L_BLBBLNK	= 112,0,32,0%; 	! Back link to BLB chain. 
 LITERAL	IFB$C_BLN_SEQ	= 116; 
 LITERAL	IFB$K_BLN_SEQ	= 116; 	 
 			 
 !-- 
 ! 
 !  organization-dependent fields 
 ! 
 !  the following fields are used differently 
 !  depending upon the file's organization 
 ! 
 !++ 
 ! 
 !  relative org specific fields 
 ! 
 			 
 MACRO		IFB$L_MRN	= 116,0,32,0%; 		! (rel) max record number 
 MACRO		IFB$L_DVBN	= 120,0,32,0%; 	! (rel) first data bucket vbn 
 LITERAL	IFB$C_BLN_REL	= 124; 
 LITERAL	IFB$K_BLN_REL	= 124; 	 
 !-- 
  
 !++ 
 ! 
 !  indexed org specific fields 
 ! 
 			 
 MACRO		IFB$L_IDX_PTR	= 116,0,32,0%; 	! (idx) pointer to primary key index descriptor 
 MACRO		IFB$B_AVBN	= 120,0,8,0%; 	! (idx) vbn of 1st area descriptor 
 MACRO		IFB$B_AMAX	= 121,0,8,0%; 	! (idx) total number of area descriptors 
 MACRO		IFB$B_NUM_KEYS	= 122,0,8,0%; 	! (idx) # of keys in file 
 MACRO		IFB$B_UBUFSZ	= 123,0,8,0%; 	! (idx) update buffer size for keys 
 MACRO		IFB$W_KBUFSZ	= 124,0,16,0%; 	! (idx) key buffer size 
 MACRO		IFB$B_EXTRABUF	= 126,0,8,0%; 	! (idx) number of extra buffers for 'cache'ing 
 MACRO		IFB$B_PLG_VER	= 127,0,8,0%; 	! (idx) prologue version number 
 LITERAL	IFB$C_BLN_IDX	= 128; 
 LITERAL	IFB$K_BLN_IDX	= 128; 	 
 !-- 
 LITERAL	IFB$C_BLN	= 128; 
 LITERAL	IFB$K_BLN	= 128; 			! ifab length 

  
 ! 
 !	 irab field definitions 
 ! 
 !  there is 1 irab per connected record access stream 
 ! 
 !...$IRBDEF		! internal rab 
  
 !+++++***** 
 ! 
 !  the fields thru last_rab inclusive are common between the irab and ifab 
 ! 
 			! to apply from start of irab 
 			 
 						! bookkeeping bits start in longword 2 
 			!++ 
 			! 
 			!  the following bits are defined in common 
 			!  with the ifab 
 			! 
 MACRO		IRB$V_BUSY	= 0,32,1,0%; 		! file busy 
 MACRO		IRB$V_EOF	= 0,33,1,0%; 		! stream positioned at eof 
 MACRO		IRB$V_PPF_IMAGE	= 0,34,1,0%; 	! flag for indirect processing of process- 
 			! permanent file 
 MACRO		IRB$V_ASYNC	= 0,35,1,0%; 		! asynchronous i/o request 
 MACRO		IRB$V_ASYNCWAIT	= 0,36,1,0%; 	! $wait issued for asynchronous i/o request 
 			!-- 
 			! 
 			!   irab specific bits 
 			! 
 MACRO		IRB$V_FIND_LAST	= 0,37,1,0%; 	! last operation was a find 
 MACRO		IRB$V_PUTS_LAST	= 0,38,1,0%; 	! last operation was a put sequential 
 MACRO		IRB$V_BIO_LAST	= 0,39,1,0%; 	! this/last operation is/was a block i/o operation 
 			! note: this bit is set only if mixed block and record 
 			!       operations (bro access).  after call to rm$rset 
 			!	refers to the current operation and bro_sw gives 
 			!	type of last operation. 
 MACRO		IRB$V_BRO_SW	= 0,40,1,0%; 	! switched from record operation to block i/o operation 
 MACRO		IRB$V_FIND	= 0,41,1,0%; 		! operation is a find 
 MACRO		IRB$V_RAHWBH	= 0,42,1,0%; 	! read ahead or write behind processing 
 MACRO		IRB$V_SKIP_NEXT	= 0,43,1,0%; 	! skip to next record flag for index fo 
 MACRO		IRB$V_DUP	= 0,44,1,0%; 		! duplicate records seen 
 MACRO		IRB$V_UNLOCK_RP	= 0,45,1,0%; 	! release lock on current (rp) record 
 MACRO		IRB$V_PPF_EOF	= 0,46,1,0%; 	! give one-shot rms$_eof error on sys$input 
 MACRO		IRB$V_PPF_SKIP	= 0,47,1,0%; 	! skip sys$input record ($deck), redoing $get 
 			! or $find on next record 
 MACRO		IRB$V_PPF_FNDSV	= 0,48,1,0%; 	! save value for find bit when ppf_skip set 
 MACRO		IRB$V_IDX_ERR	= 0,49,1,0%; 	! index update error occurred 
 MACRO		IRB$V_RRV_ERR	= 0,50,1,0%; 	! rrv update error occurred 
 MACRO		IRB$V_UPDATE	= 0,51,1,0%; 	! operation is an update (indexed) 
 MACRO		IRB$V_UPD_NRP	= 0,52,1,0%; 	! an nrp update is necessary (indexed) 
 MACRO		IRB$V_ABOVELCKD	= 0,53,1,0%; 	! level above was locked by search_tree 
 MACRO		IRB$V_GBLBUFF	= 0,54,1,0%; 	! global buffers are in use. 
 						! spare bits 
 MACRO		IRB$V_RMS_STALL	= 0,58,1,0%; 	! RMS is stalled on this record operation 
 						! spare bits 
 MACRO		IRB$V_DAP_CONN	= 0,62,1,0%; 	! connect function was performed via dap 
 						! spare bit 
 			
 ! 
 !  the following are alternate definitions for alternate 
 !  (non-conflicting) use of the above bits 
 ! 
 			 
 						! start re-use with find 
 MACRO		IRB$V_WRITE	= 0,41,1,0%; 		! operation is a write 
 			
 MACRO		IRB$L_IFAB_LNK	= 0,0,32,0%; 	! pointer to ifab 
 MACRO		IRB$L_BKPBITS	= 4,0,32,0%; 	! bookkeeping status bits 
 ! 
 MACRO		IRB$B_BID	= 8,0,8,0%; 		! block id 
 LITERAL	IRB$C_BID	= 10; 		! irab code 
 MACRO		IRB$B_BLN	= 9,0,8,0%; 		! block length in longwords 
 MACRO		IRB$B_MODE	= 10,0,8,0%; 	! caller's mode 
 MACRO		IRB$B_EFN	= 11,0,8,0%; 		! event flag for synchronous io 
 MACRO		IRB$L_IOS	= 12,0,32,0%; 		! internal i/o status block 
 MACRO		IRB$L_BWB	= 12,0,32,0%; 	! bucket wait block for inter stream locking 
 MACRO		IRB$W_IOS2	= 14,0,16,0%; 	! high word of io status block 
 MACRO		IRB$L_IOS4	= 16,0,32,0%; 	! io status block (2nd longword) 
 MACRO		IRB$L_ASBADDR	= 20,0,32,0%; 	! address of permanent asynchronous context block 
 MACRO		IRB$L_ARGLST	= 24,0,32,0%; 	! user arg list address 
 			! if async, points to copy at head 
 			! of async context block 
 MACRO		IRB$L_IRAB_LNK	= 28,0,32,0%; 	! pointer to next irab 
 MACRO		IRB$L_CURBDB	= 32,0,32,0%; 	! current bdb address 
 MACRO		IRB$L_LAST_RAB	= 36,0,32,0%; 	! address of rab for last operation 
 !-----***** 
 MACRO		IRB$L_RLB_LNK	= 40,0,32,0%; 	! pointer to RLBs 
 MACRO		IRB$L_NXTBDB	= 44,0,32,0%; 	! next bdb address 
 MACRO		IRB$L_NRP_PTR	= 48,0,32,0%; 	! pointer to cell in nrp list  (indexed) 
 MACRO		IRB$L_NRP_VBN	= 48,0,32,0%; 	! next record pointer  (relative) 
 MACRO		IRB$L_NRP	= 48,0,32,0%; 	! next record pointer (relative record #) 
 MACRO		IRB$L_NRP_OFF	= 52,0,32,0%; 	! next record pointer offset (relative) 
 MACRO		IRB$W_NRP_OFF	= 52,0,16,0%; 	!     " 
 MACRO		IRB$L_CURVBN	= 52,0,32,0%; 	! vbn of current record (relative) 
 MACRO		IRB$B_CACHEFLGS	= 52,0,8,0%;  ! cacheflags for calls to getbkt,cache, etc. (indexed) 
 MACRO		IRB$B_NRP_KREF	= 53,0,8,0%; 	! key of reference  (indexed) 
 MACRO		IRB$B_RP_KREF	= 54,0,8,0%; 	! key of reference for rp  (indexed) 
 MACRO		IRB$B_SPL_BITS	= 55,0,8,0%; 	! bits for splitting  (indexed) 
 			 
 MACRO		IRB$V_BKT_NO_LO	= 55,0,1,0%; 	! low bit of bucket number processing 
 LITERAL	IRB$M_BKT_NO_LO	= 1^1 - 1^0; 
 MACRO		IRB$V_NEW_BKTS	= 55,1,2,0%; 	! number of new buckets (0-3) 
 LITERAL	IRB$M_NEW_BKTS	= 1^3 - 1^1; 
 MACRO		IRB$V_REC_W_LO	= 55,3,1,0%; 	! if splitting at pos_insert than rec goes w/ lo 
 LITERAL	IRB$M_REC_W_LO	= 1^4 - 1^3; 
 MACRO		IRB$V_CONT_BKT	= 55,4,1,0%; 	! middle bucket is a continuation bkt 
 LITERAL	IRB$M_CONT_BKT	= 1^5 - 1^4; 
 MACRO		IRB$V_CONT_R	= 55,5,1,0%; 	! right bucket is a continuation bkt 
 LITERAL	IRB$M_CONT_R	= 1^6 - 1^5; 
 MACRO		IRB$V_EMPTY_BKT	= 55,6,1,0%; 	! bucket contains no data records 
 LITERAL	IRB$M_EMPTY_BKT	= 1^7 - 1^6; 
 MACRO		IRB$V_DUPS_SEEN	= 55,7,1,0%; 	! dups seen on scan of bucket, any key 
 LITERAL	IRB$M_DUPS_SEEN	= 1^8 - 1^7; 
 			
 			 
 MACRO		IRB$V_BKT_NO	= 55,0,2,0%;  
 LITERAL	IRB$M_BKT_NO	= 1^2 - 1^0; 
 MACRO		IRB$V_BIG_SPLIT	= 55,2,1,0%;  
 LITERAL	IRB$M_BIG_SPLIT	= 1^3 - 1^2; 
 			
 			 
 MACRO		IRB$V_SPL_IDX	= 55,0,1,0%; 	! split up new index record and swing pointer 
 LITERAL	IRB$M_SPL_IDX	= 1^1 - 1^0; 
 MACRO		IRB$V_EMPT_SEEN	= 55,1,1,0%; 	! empty bucket passed over on posinsert 
 LITERAL	IRB$M_EMPT_SEEN	= 1^2 - 1^1; 
 			
 MACRO		IRB$L_RP	= 56,0,32,0%; 		! record pointer  (relative record #) 
 MACRO		IRB$L_RP_VBN	= 56,0,32,0%; 	! record pointer  (relative) 
 MACRO		IRB$W_POS_INS	= 56,0,16,0%; 	! offset for position for insert for put  (indexed) 
 MACRO		IRB$W_SPLIT	= 58,0,16,0%; 	! first split point  (indexed) 
 MACRO		IRB$L_RP_OFF	= 60,0,32,0%; 	! record pointer offset 
 MACRO		IRB$L_LST_REC	= 60,0,32,0%; 	! last record address  (indexed) 
 MACRO		IRB$L_PTR_VBN	= 60,0,32,0%; 	! pointer vbn used by find_by_rrv (indexed) 
 MACRO		IRB$W_RP_OFF	= 60,0,16,0%; 	! record pointer offset 
 MACRO		IRB$W_SPLIT_1	= 60,0,16,0%; 	! second split point -- 3-bkt split  (indexed) 
 MACRO		IRB$W_SPLIT_2	= 62,0,16,0%; 	! third split point -- 4-bkt split  (indexed) 
 MACRO		IRB$L_OWNER_ID	= 64,0,32,0%; 	! owner id used for record locks 
 MACRO		IRB$W_OWN_ID	= 64,0,16,0%; 	! index part of process id (pid) 
 MACRO		IRB$W_OWN_ISI	= 66,0,16,0%; 	! isi value for this irab 
 MACRO		IRB$B_PPF_ISI	= 66,0,8,0%; 	! isi value for this process-permanent irab 
 MACRO		IRB$B_BCNT	= 68,0,8,0%; 	! i/o buffer count 
 MACRO		IRB$B_MBC	= 69,0,8,0%; 		! multi-block count 
 MACRO		IRB$W_RSZ	= 70,0,16,0%; 		! record size from user 
 MACRO		IRB$L_RBF	= 72,0,32,0%; 		! user record buffer address 
 !++ 
 ! 
 !  start of organization dependent fields 
 ! 
 			 
 !++ 
 ! 
 ! used by sequential and relative files 
 ! 
 MACRO		IRB$W_CSIZ	= 78,0,16,0%; 	! current record size (seq) 
  
 			 
 !++ 
 ! 
 !  sequential org specific fields 
 ! 
 MACRO		IRB$L_TEMP0	= 80,0,32,0%;  
 MACRO		IRB$W_ROVHDSZ	= 80,0,16,0%; 	! overhead size for record 
 MACRO		IRB$B_PRE_CCTL	= 80,0,8,0%; 	! 'pre' carriage control 
 MACRO		IRB$B_POST_CCTL	= 81,0,8,0%;  ! 'post' carriage control 
 MACRO		IRB$W_RTOTLSZ	= 82,0,16,0%; 	! total size for record 
 MACRO		IRB$L_TEMP1	= 84,0,32,0%;  
 MACRO		IRB$B_NVBNS	= 84,0,8,0%; 	! number of vbns transferred (nxtblk1) 
 LITERAL	IRB$C_BLN_SEQ	= 88; 
 LITERAL	IRB$K_BLN_SEQ	= 88; 	 
 !++ 
 ! 
 !  relative org specific fields 
 ! 
 			 
  
 LITERAL	IRB$C_BLN_REL	= 80; 
 LITERAL	IRB$K_BLN_REL	= 80; 	 
 ! 
 ! indexed org specific fields 
 ! 
 			 
 MACRO		IRB$L_KEYBUF	= 76,0,32,0%; 	! address of internal key buffer & update buffer 
 MACRO		IRB$L_UPDBUF	= 80,0,32,0%; 	! address of internal update buffer 
 MACRO		IRB$L_RECBUF	= 84,0,32,0%; 	! address of internal record buffer (plg 3) 
 MACRO		IRB$L_RFA_VBN	= 88,0,32,0%; 	! rfa vbn for search nrp data 
 MACRO		IRB$L_UPD_BDB	= 88,0,32,0%; 	! save current bdb during insert operation 
 MACRO		IRB$L_LAST_VBN	= 88,0,32,0%; 	! last vbn at data level for update 
 MACRO		IRB$W_RFA_ID	= 92,0,16,0%; 	! save id for search nrp data (plg 3) 
 MACRO		IRB$W_LAST_ID	= 92,0,16,0%; 	! id for udr during update (plg 3) 
 MACRO		IRB$W_SAVE_POS	= 94,0,16,0%; 	! saved duplicate position for search nrp data 
 MACRO		IRB$L_LOCK_BDB	= 96,0,32,0%; 	! lock bdb addr of level below on splits 
 MACRO		IRB$L_VBN_LEFT	= 100,0,32,0%; 	! left vbn of split 
 MACRO		IRB$L_MIDX_TMP1	= 100,0,32,0%; 	! temporary one for make index 
 MACRO		IRB$L_VBN_RIGHT	= 104,0,32,0%; 	! right vbn of split 
 MACRO		IRB$L_MIDX_TMP2	= 104,0,32,0%; 	! temporary two for make index 
 MACRO		IRB$L_VBN_MID	= 108,0,32,0%; 	! middle vbn of split 
 MACRO		IRB$L_MIDX_TMP3	= 108,0,32,0%; 	! temporary three for make index 
 MACRO		IRB$L_NEXT_DOWN	= 108,0,32,0%;  ! used by search_tree 
 MACRO		IRB$B_STOPLEVEL	= 112,0,8,0%; 	! level to stop at on tree search 
 MACRO		IRB$B_SRCHFLAGS	= 113,0,8,0%; 	! search flags 
 			 
 MACRO		IRB$V_POSINSERT	= 113,0,1,0%; 	! position for insert 
 LITERAL	IRB$M_POSINSERT	= 1^1 - 1^0; 
 MACRO		IRB$V_SRCHGT	= 113,1,1,0%; 		! approximate search gt 
 LITERAL	IRB$M_SRCHGT	= 1^2 - 1^1; 
 MACRO		IRB$V_POSDELETE	= 113,2,1,0%; 	! position for delete 
 LITERAL	IRB$M_POSDELETE	= 1^3 - 1^2; 
 MACRO		IRB$V_NEW_IDX	= 113,3,1,0%; 	! need to read in new idx dsc from file 
 LITERAL	IRB$M_NEW_IDX	= 1^4 - 1^3; 
 MACRO		IRB$V_SRCHGE	= 113,4,1,0%; 		! approximate search ge 
 LITERAL	IRB$M_SRCHGE	= 1^5 - 1^4; 
 MACRO		IRB$V_NORLS_RNF	= 113,5,1,0%; 	! don't release bkt on rnf error, if set 
 LITERAL	IRB$M_NORLS_RNF	= 1^6 - 1^5; 
 MACRO		IRB$V_FIRST_TIM	= 113,6,1,0%; 	! flag to indicate 1st time for seq. processing 
 LITERAL	IRB$M_FIRST_TIM	= 1^7 - 1^6; 
 MACRO		IRB$V_PRM	= 113,7,1,0%; 		! flag to indicate that the permanence bit in the bdb 
 LITERAL	IRB$M_PRM	= 1^8 - 1^7; 
 			!  should be set 
 			
 MACRO		IRB$B_KEYSZ	= 114,0,8,0%; 	! size of key in keybuffer #2 
 MACRO		IRB$B_DIFF_CHAR	= 115,0,8,0%; 	! number of the character in the search key which 
 			!  differs from the record it is compared against(plg3) 
 MACRO		IRB$L_REC_COUNT	= 116,0,32,0%; 	! number of current record in this bucket (plg 3) 
 MACRO		IRB$L_LST_NCMP	= 120,0,32,0%; 	! address of last key with zero front compression (plg 3) 
 MACRO		IRB$L_SPL_COUNT	= 124,0,32,0%; 	! number of the first record to be moved into new bucket 
 			!  when splitting indexes and SIDRs 
 MACRO		IRB$W_NID_RIGHT	= 128,0,16,0%; 	! Next record ID of the right bucket 
 MACRO		IRB$W_NID_MID	= 130,0,16,0%; 	! Next record ID of the middle bucket 
 MACRO		IRB$W_RFA_NID	= 132,0,16,0%; 	! Next record ID of the RFA bucket 
 LITERAL	IRB$C_BLN_IDX	= 136; 
 LITERAL	IRB$K_BLN_IDX	= 136; 	 

  
 ! 
 !  asynchronous operations require that an irab have 
 !  an asynchronous context block (asb) 
 !  the asb is pointed to by the arglst field of the 
 !  irab if the async bookkeeping bit is set 
 ! 
 !  the first four longwords are used to save the 
 !  caller's argument list 
 ! 
 !...$ASBDEF	
  
 MACRO		ASB$B_ARGCNT	= 0,0,8,0%; 	! argument count 
 			! value will be 0, 1, 2, or 3 
 MACRO		ASB$B_BLN	= 1,0,8,0%; 		! block length in longwords 
 MACRO		ASB$B_STKSIZ	= 2,0,8,0%; 	! size of saved stack in bytes 
 MACRO		ASB$L_FABRAB	= 4,0,32,0%; 	! fab or rab address 
 MACRO		ASB$L_ERR	= 8,0,32,0%; 		! err routine addr 
 MACRO		ASB$L_SUC	= 12,0,32,0%; 		! suc routine addr 
 MACRO		ASB$L_REGS	= 16,0,0,0%; 	! work space for register and stack save 
 LITERAL	ASB$S_REGS	= 160; 
 			! (regs 6,7,8,10,11 - r4,r5 saved on stack) 
 LITERAL	ASB$C_BLN_FAB	= 176; 
 LITERAL	ASB$K_BLN_FAB	= 176; 		! block length for fab-related operations 
 LITERAL	ASB$C_BLN_SEQ	= 176; 
 LITERAL	ASB$K_BLN_SEQ	= 176; 		! block length for seq org irab operations 
 LITERAL	ASB$C_BLN_REL	= 180; 
 LITERAL	ASB$K_BLN_REL	= 180; 		! block length for rel org irab operations 
 LITERAL	ASB$C_BLN_IDX	= 260; 
 LITERAL	ASB$K_BLN_IDX	= 260; 	 

  
 ! 
 !	 file work area definitions 
 ! 
 !  the file work area is used for expanding the file 
 !  name string and setting up the various parameter 
 !  blocks for interfacing with f11acp 
 ! 
 !...$FWADEF	
  
 MACRO		FWA$Q_FLAGS	= 0,0,0,0%; 	! various parse status flags 
 LITERAL	FWA$S_FLAGS	= 8; 
 			 
 MACRO		FWA$V_DUPOK	= 0,0,1,0%; 	! discard duplicate element 
 LITERAL	FWA$M_DUPOK	= 1^1 - 1^0; 
 MACRO		FWA$V_NAMEFLG	= 0,1,1,0%; 	! name seen this parse 
 LITERAL	FWA$M_NAMEFLG	= 1^2 - 1^1; 
 MACRO		FWA$V_TYPEFLG	= 0,2,1,0%; 	! type seen this parse 
 LITERAL	FWA$M_TYPEFLG	= 1^3 - 1^2; 
 MACRO		FWA$V_RLF_PASS	= 0,3,1,0%; 	! set if applying related file defaults 
 LITERAL	FWA$M_RLF_PASS	= 1^4 - 1^3; 
 MACRO		FWA$V_FNA_PASS	= 0,4,1,0%; 	! set if primary name string parse pass 
 LITERAL	FWA$M_FNA_PASS	= 1^5 - 1^4; 
 MACRO		FWA$V_NAM_DVI	= 0,5,1,0%; 	! set if open by name block 
 LITERAL	FWA$M_NAM_DVI	= 1^6 - 1^5; 
 MACRO		FWA$V_CUR_VER	= 0,6,1,0%; 		! set if cur file has wc ver 
 						! spare 
 				! (end of passflgs byte) 
 			 
 						! start defs at byte 1 
 						! must be zero 
 MACRO		FWA$V_VERSION	= 0,11,1,0%; 	! set if version seen 
 LITERAL	FWA$M_VERSION	= 1^12 - 1^11; 
 MACRO		FWA$V_TYPE	= 0,12,1,0%; 	! set if type seen 
 LITERAL	FWA$M_TYPE	= 1^13 - 1^12; 
 MACRO		FWA$V_NAME	= 0,13,1,0%; 	! set if name seen 
 LITERAL	FWA$M_NAME	= 1^14 - 1^13; 
 MACRO		FWA$V_DIR	= 0,14,1,0%; 		! set if directory spec seen 
 LITERAL	FWA$M_DIR	= 1^15 - 1^14; 
 MACRO		FWA$V_DEVICE	= 0,15,1,0%; 	! set if device seen 
 LITERAL	FWA$M_DEVICE	= 1^16 - 1^15; 
 			! (end of fldflgs byte) 
 MACRO		FWA$V_EXP_VER	= 0,16,1,0%; 	! set if explicit version 
 LITERAL	FWA$M_EXP_VER	= 1^17 - 1^16; 
 MACRO		FWA$V_EXP_TYPE	= 0,17,1,0%; 	! set if explicit type 
 LITERAL	FWA$M_EXP_TYPE	= 1^18 - 1^17; 
 MACRO		FWA$V_EXP_NAME	= 0,18,1,0%; 	! set if explicit name 
 LITERAL	FWA$M_EXP_NAME	= 1^19 - 1^18; 
 MACRO		FWA$V_WC_VER	= 0,19,1,0%; 		! set if wildcard (*) version 
 MACRO		FWA$V_WC_TYPE	= 0,20,1,0%; 		!          "		type 
 MACRO		FWA$V_WC_NAME	= 0,21,1,0%; 		!	   "		name 
 MACRO		FWA$V_EXP_DIR	= 0,22,1,0%; 	! set if explicit directory 
 LITERAL	FWA$M_EXP_DIR	= 1^23 - 1^22; 
 MACRO		FWA$V_EXP_DEV	= 0,23,1,0%; 	! set if explicit device 
 LITERAL	FWA$M_EXP_DEV	= 1^24 - 1^23; 
 			! (end of wildflgs byte) 
 MACRO		FWA$V_WILDCARD	= 0,24,1,0%; 	! set if any wildcard seen 
 MACRO		FWA$V_NODE	= 0,25,1,0%; 		! set if node name seen 
 MACRO		FWA$V_QUOTED	= 0,26,1,0%; 		! set is quoted string seen 
 			! (valid only if node set and no fldflgs) 
 MACRO		FWA$V_GRPMBR	= 0,27,1,0%; 		! set if directory in [grp,mbr] format 
 MACRO		FWA$V_WILD_DIR	= 0,28,1,0%; 	! inclusive or of directory wild cards 
 MACRO		FWA$V_DIR_LVLS	= 0,29,3,0%; 	! # of directory sublevels (0 = ufd only) 
 			! (end of parseflgs byte) 
 			
 			 
 						! continue bit definitions of 2nd longword 
 MACRO		FWA$V_DIR1	= 0,32,1,0%; 		! ufd level directory or group seen 
 MACRO		FWA$V_DIR2	= 0,33,1,0%; 		! sfd level 1 directory or member seen 
 						! additional sub directory level flags 
 			! (end of dirflgs byte) 
 MACRO		FWA$V_WILD_UFD	= 0,40,1,0%; 	! the dir1 spec was a wild card 
 MACRO		FWA$V_WILD_SFD1	= 0,41,1,0%; 	! the dir2 spec was a wild card 
 						! additional sub directory wildcard flags 
 			! (end of dirwcflgs byte) 
 MACRO		FWA$V_LOGNAME	= 0,48,1,0%; 		! a logical name has been seen this pass 
 			! (note: this byte is saved as context 
 			! when processing [.dir-list] format) 
 MACRO		FWA$V_OBJTYPE	= 0,49,1,0%; 		! set if quoted string is of the 
 			! "objecttype=..." form 
 			! (valid only if quoted set) 
 MACRO		FWA$V_NETSTR	= 0,50,1,0%; 		! set if quoted string is of the 
 			! "objecttype=taskname/..." form 
 			! (valid only if quoted and objtype set) 
 MACRO		FWA$V_DEV_UNDER	= 0,51,1,0%; 	! device name was prefixed with an underscore 
 MACRO		FWA$V_FILEFOUND	= 0,52,1,0%; 	! true if at least one file found by parse/search 
 MACRO		FWA$V_REMRESULT	= 0,53,1,0%; 	! use resultant string returned by fal 
 MACRO		FWA$V_DFLT_MFD	= 0,54,1,0%; 	! default MFD string inserted, due to [-] 
 MACRO		FWA$V_ROOT_DIR	= 0,55,1,0%; 	! root directory present due to concealed device 
 			! (end of lnflg byte) 
 			
 			 
 						! alternate definition for dir1 and dir2 
 MACRO		FWA$V_WILD_GRP	= 0,40,1,0%; 	! the grp spec contained a wild card 
 MACRO		FWA$V_WILD_MBR	= 0,41,1,0%; 	! the mbr spec contained a wild card 
 			
 MACRO		FWA$B_PASSFLGS	= 0,0,8,0%; 	! flags for pass only 
 MACRO		FWA$B_FLDFLGS	= 1,0,8,0%; 	! flags for fields seen 
 MACRO		FWA$B_WILDFLGS	= 2,0,8,0%; 	! flags for wild cards 
 MACRO		FWA$B_PARSEFLGS	= 3,0,8,0%; 	! flags for parse results 
 MACRO		FWA$B_DIRFLGS	= 4,0,8,0%; 	! flags primarily for directory spec 
 MACRO		FWA$B_DIRWCFLGS	= 5,0,8,0%; 	! directory wild flags 
 MACRO		FWA$B_LNFLG	= 6,0,8,0%; 	! logical name flag byte 
 MACRO		FWA$B_DIRTERM	= 7,0,8,0%; 	! directory spec terminator (']' or '>') 
 			! (note: this byte must follow the lnflg byte) 
 LITERAL	FWA$C_ALL	= ((FWA$M_DEVICE OR FWA$M_DIR OR FWA$M_NAME OR FWA$M_TYPE OR FWA$M_VERSION)^-8); 		
 			! value for all filename elements except node 
 ! 
 MACRO		FWA$L_ESCSTRING	= 8,0,32,0%; 	! escape equivalence string 
 MACRO		FWA$B_ESCFLG	= 8,0,8,0%; 	! set to the char <esc> if an escape string 
 			! seen, zero otherwise 
 MACRO		FWA$B_ESCTYP	= 9,0,8,0%; 	! escape 'type' byte 
 			 
 MACRO		FWA$W_ESCIFI	= 10,0,16,0%; 	! escape ifi value 
 ! 
 			 
 			! temporary usage of the escifi field 
 			! for logical name translation 
 MACRO		FWA$B_XLTMODE	= 10,0,8,0%; 	! mode of equivalence string 
 MACRO		FWA$B_XLTTBL	= 11,0,8,0%; 	! table of equivalence string 
 MACRO		FWA$Q_XLTBUF1	= 12,0,0,0%; 	! primary translation buffer discriptor 
 LITERAL	FWA$S_XLTBUF1	= 8; 
 MACRO		FWA$Q_FIB	= 12,0,0,0%; 	! re-use for fib descriptor 
 LITERAL	FWA$S_FIB	= 8; 
 MACRO		FWA$L_BUFFLG	= 20,0,32,0%; 	! flag for which buffer in use 
 			! (0 = buf2 in use, -1 = buf1 in use) 
 MACRO		FWA$L_DIRBDB	= 20,0,32,0%; 	! re-use as address of directory file bdb 
 			! since bufflg never used in search-type fwa's 
 MACRO		FWA$L_XLTSIZ	= 24,0,32,0%; 	! length of equivalence string 
 MACRO		FWA$W_FNAMSIZ	= 24,0,16,0%; 	! file name size (without type and version) 
 			! after exit from xpfn 
 MACRO		FWA$Q_LOGNAME	= 28,0,0,0%; 	! logical name descriptor 
 LITERAL	FWA$S_LOGNAME	= 8; 
 MACRO		FWA$L_UIC	= 28,0,32,0%; 	! file owner uic 
 MACRO		FWA$L_LOOKUP	= 28,0,32,0%; 	! address of new directory cache node 
 MACRO		FWA$L_DEVNODADR	= 32,0,32,0%; 	! address of device directory cache node 
 MACRO		FWA$W_PRO	= 32,0,16,0%; 	! file protection word 
 MACRO		FWA$Q_XLTBUF2	= 36,0,0,0%; 	! secondary translation buffer descriptor 
 LITERAL	FWA$S_XLTBUF2	= 8; 
 MACRO		FWA$Q_DIR	= 36,0,0,0%; 	! directory name scratch buffer 
 LITERAL	FWA$S_DIR	= 8; 
 MACRO		FWA$L_XLTCNT	= 44,0,32,0%; 	! number of translations done 
 MACRO		FWA$W_UCHAR	= 44,0,16,0%; 	! reuse to receive user characteristics (long)word 
 MACRO		FWA$B_DIRLEN	= 48,0,8,0%; 	! overall directory spec length 
 MACRO		FWA$B_SUBNODCNT	= 49,0,8,0%; 	! number of secondary (sub) node specs found 
 MACRO		FWA$L_BUF_PTR	= 52,0,32,0%; 	! address of temporary buffer 
 ! 
 !  descriptors for parsed filename elements 
 ! 
 !******++++++ 
 !  the following descriptors must be contiguous. 
 MACRO		FWA$Q_NODE	= 56,0,0,0%; 		! node name (actually node spec list) descriptor 
 LITERAL	FWA$S_NODE	= 8; 
 				! (the associated buffer is nwa$t_nodebuf) 
 LITERAL	FWA$C_MAXNODNAM	= 6; 			! max node name size 
 LITERAL	FWA$C_MAXLNDNAM	= 15; 		! max logical node name size 
 LITERAL	FWA$C_MAXNODLST	= 127; 		! max node spec list size (concatenated node specs) 
 MACRO		FWA$Q_DEVICE	= 64,0,0,0%; 		! device name descriptor 
 LITERAL	FWA$S_DEVICE	= 8; 
 LITERAL	FWA$C_MAXDEVICE	= 63; 		! max device name size 
 MACRO		FWA$Q_DIR1	= 72,0,0,0%; 		! directory and subdirectory descriptors 
 LITERAL	FWA$S_DIR1	= 8; 
 MACRO		FWA$Q_DIR2	= 80,0,0,0%; 		! (note: only 1 and 2 explicitly named) 
 LITERAL	FWA$S_DIR2	= 8; 
 LITERAL	FWA$C_MAXSUBDIR	= 7; 			! max number of sub directories 
 LITERAL	FWA$C_MAXDIRLEN	= 81; 		! max size of total directory spec 
 MACRO		FWA$Q_NAME	= 136,0,0,0%; 		! file name descriptor 
 LITERAL	FWA$S_NAME	= 8; 
 LITERAL	FWA$C_MAXNAME	= 9; 			! max file name size 
 LITERAL	FWA$C_MTMAXNAME	= 36; 		! max file name size for ANSI-"a" name strings 
 LITERAL	FWA$C_MTLNONTAP	= 17; 		! length of file names on tape 
 MACRO		FWA$Q_TYPE	= 144,0,0,0%; 		! file type descriptor 
 LITERAL	FWA$S_TYPE	= 8; 
 MACRO		FWA$Q_RNS	= 144,0,0,0%; 		! re-use as resultant name string descriptor 
 LITERAL	FWA$S_RNS	= 8; 
 LITERAL	FWA$C_MAXTYPE	= 3; 			! max file type size 
 LITERAL	FWA$C_RNSBUFSIZ	= 20; 		! *unused in RMS* max resultant name string size 
 			 
 MACRO		FWA$Q_VERSION	= 152,0,0,0%; 		! file version descriptor 
 LITERAL	FWA$S_VERSION	= 8; 
 LITERAL	FWA$C_MAXVER	= 6; 			! maximum version 
 MACRO		FWA$Q_QUOTED	= 160,0,0,0%; 		! quoted string descriptor 
 LITERAL	FWA$S_QUOTED	= 8; 
 				! (the associated buffer is nwa$t_quotedbuf) 
 LITERAL	FWA$C_MAXQUOTED	= 127; 		! max quoted string size 
 			 
 			 
 MACRO		FWA$T_STATBLK	= 152,0,0,0%; 		! 
 LITERAL	FWA$S_STATBLK	= 10; 
 LITERAL	FWA$C_STATBLK	= 10; 			! define length of statistics block 
 MACRO		FWA$L_SBN	= 152,0,32,0%; 		! starting lbn if contiguous 
 MACRO		FWA$L_HBK	= 156,0,32,0%; 		! high vbn 
 !******------ 
 						! (note: this does not position properly 
 				! unless 'f ,b,6' spares are defined above) 
 !******++++++ 
 !  the following descriptors must be contiguous. 
 MACRO		FWA$Q_NODE1	= 168,0,0,0%; 		! primary node spec descriptor 
 LITERAL	FWA$S_NODE1	= 8; 
 				! (the associated buffer is nwa$t_nodebuf) 
 LITERAL	FWA$C_MAXSUBNOD	= 7; 			! max number of secondary (sub) node specs 
 			 
 !******------ 
 						! overlay with node descriptors 
 MACRO		FWA$T_FIBBUF	= 168,0,0,0%; 		! fib buffer 
 LITERAL	FWA$S_FIBBUF	= 48; 
 LITERAL	FWA$C_FIBLEN	= 48; 			! fib buffer size 
 MACRO		FWA$T_RNM_FID	= 216,0,0,0%; 		! saved fid for rename directory check 
 LITERAL	FWA$S_RNM_FID	= 6; 
 MACRO		FWA$T_MFD_FID	= 222,0,0,0%; 		! saved fid for root directory 
 LITERAL	FWA$S_MFD_FID	= 6; 
 						! end of overlay 
 ! 
 !  directory name buffers 
 ! 
 MACRO		FWA$T_DIR1BUF	= 232,0,0,0%; 		! ufd level (or group) 
 LITERAL	FWA$S_DIR1BUF	= 9; 
 MACRO		FWA$T_DIR2BUF	= 241,0,0,0%; 		! 1st sfd level (or member) 
 LITERAL	FWA$S_DIR2BUF	= 9; 
 LITERAL	FWA$C_DIRBUFSIZ	= 9; 			! size of each directory buffer 
 !******++++++ 
 !  the following buffers must be contiguous as eventually the 
 !  type and version are appended to the name string 
 MACRO		FWA$T_NAMEBUF	= 304,0,0,0%; 		! file name buffer (also used for resultant name) 
 LITERAL	FWA$S_NAMEBUF	= 36; 
 LITERAL	FWA$C_NAMBUFSIZ	= 36; 			! file name buffer size 
 MACRO		FWA$T_TYPEBUF	= 340,0,0,0%; 		! file type buffer 
 LITERAL	FWA$S_TYPEBUF	= 7; 
 LITERAL	FWA$C_TYPBUFSIZ	= 7; 			! file type buffer size 
 MACRO		FWA$T_VERBUF	= 347,0,0,0%; 		! file version buffer 
 LITERAL	FWA$S_VERBUF	= 6; 
 LITERAL	FWA$C_VERBUFSIZ	= 6; 			! file version buffer size 
 !******------ 
 MACRO		FWA$B_UNDERLINE	= 353,0,8,0%; 		! single character '_' stored here to prevent 
 				! additional logical name translation 
 MACRO		FWA$T_DEVICEBUF	= 354,0,0,0%; 	! device name buffer 
 LITERAL	FWA$S_DEVICEBUF	= 63; 
 LITERAL	FWA$C_DEVBUFSIZ	= 63; 		! device name buffer size 
 MACRO		FWA$T_WILD	= 417,0,0,0%; 		! scratch field used by RM0WILD 
 LITERAL	FWA$S_WILD	= 16; 
 LITERAL	FWA$C_WILDSIZ	= 16; 			! scratch field size	 
 MACRO		FWA$T_SHRFILDEV	= 433,0,0,0%; 	! shared file device id 
 LITERAL	FWA$S_SHRFILDEV	= 16; 
 MACRO		FWA$T_ROOT_DIR	= 449,0,0,0%; 		! ASCIC root directory string 
 LITERAL	FWA$S_ROOT_DIR	= 10; 
 MACRO		FWA$T_ATR_LIST	= 459,0,0,0%; 	! attribute list work area 
 LITERAL	FWA$S_ATR_LIST	= 128; 
 MACRO		FWA$T_XLTBUFF1	= 459,0,0,0%; 	! scratch translation buffer 
 LITERAL	FWA$S_XLTBUFF1	= 64; 
 				! (also used for attribute list area in rm$access) 
 MACRO		FWA$T_DIB	= 475,0,0,0%; 		! device information block 
 LITERAL	FWA$S_DIB	= 112; 
 MACRO		FWA$T_XLTBUFF2	= 523,0,0,0%; 	! scratch translation buffer 
 LITERAL	FWA$S_XLTBUFF2	= 64; 
 				! (also used for directory processing in rm$setdid 
 				!  and attribute list area in rm$access) 
 LITERAL	FWA$C_XLTBUFSIZ	= 63; 		! scratch translation buffer size 
 MACRO		FWA$T_XLTBUFF3	= 587,0,0,0%; 		! scratch translation buffer 3! 
 LITERAL	FWA$S_XLTBUFF3	= 64; 
 LITERAL	FWA$C_BLN	= 651; 
 LITERAL	FWA$K_BLN	= 651; 				! length of this control block 

  
 ! 
 !	 bdb field definitions 
 ! 
 !  buffer descriptor block (bdb) 
 ! 
 !  there is one bdb per i/o buffer 
 !  ( the i/o buffers exist in separate pages, page aligned) 
 ! 
 !...$BDBDEF	
  
 MACRO		BDB$L_FLINK	= 0,0,32,0%; 	! forward link 
 MACRO		BDB$L_BLINK	= 4,0,32,0%; 	! backward link 
 MACRO		BDB$B_BID	= 8,0,8,0%; 		! block id 
 LITERAL	BDB$C_BID	= 12; 		! bdb id code 
 MACRO		BDB$B_BLN	= 9,0,8,0%; 		! block length in longwords 
 MACRO		BDB$B_FLGS	= 10,0,8,0%; 	! bdb flags 
 			 
 MACRO		BDB$V_VAL	= 10,0,1,0%; 		! buffer contents valid 
 LITERAL	BDB$M_VAL	= 1^1 - 1^0; 
 MACRO		BDB$V_DRT	= 10,1,1,0%; 		! buffer content dirty 
 LITERAL	BDB$M_DRT	= 1^2 - 1^1; 
 MACRO		BDB$V_IOP	= 10,2,1,0%; 		! buffer has i/o in progress 
 LITERAL	BDB$M_IOP	= 1^3 - 1^2; 
 MACRO		BDB$V_PRM	= 10,3,1,0%; 		! buffer has permanence factor 
 LITERAL	BDB$M_PRM	= 1^4 - 1^3; 
 MACRO		BDB$V_NOLOCATE	= 10,4,1,0%; 	! buffer shared - no locate mode 
 LITERAL	BDB$M_NOLOCATE	= 1^5 - 1^4; 
 			! (set/cleared by rm$cache) 
 MACRO		BDB$V_WFO	= 10,5,1,0%; 		! other streams awaiting 
 LITERAL	BDB$M_WFO	= 1^6 - 1^5; 
 			! the releasing of this bdb 
 MACRO		BDB$V_AST_DCL	= 10,6,1,0%; 	! ast has been declared for 
 LITERAL	BDB$M_AST_DCL	= 1^7 - 1^6; 
 			! waiting stream 
 			
 MACRO		BDB$B_CACHE_VAL	= 11,0,8,0%; 	! relative value of buffer in cache 
 MACRO		BDB$B_VERTYP	= 11,0,8,0%; 	! version type (1 = wild) 
 MACRO		BDB$W_USERS	= 12,0,16,0%; 	! number of streams referencing this buffer 
 MACRO		BDB$W_BUFF_ID	= 14,0,16,0%; 	! buffer identification number 
 MACRO		BDB$L_BLB_PTR	= 16,0,32,0%; 	! pointer to BLB chain for this BDB 
 MACRO		BDB$W_NUMB	= 20,0,16,0%; 	! # of bytes of buffer in use 
 MACRO		BDB$W_DIRSEQ	= 20,0,16,0%; 	! UCB$W_DIRSEQ at directory read time 
 MACRO		BDB$W_SIZE	= 22,0,16,0%; 	! # bytes in buffer 
 MACRO		BDB$L_ADDR	= 24,0,32,0%; 	! address of buffer 
 MACRO		BDB$L_VBN	= 28,0,32,0%; 		! 1st vbn in buffer 
 MACRO		BDB$L_VBNSEQNO	= 32,0,32,0%; 	! vbn seq number of validity check vs. bcb copy 
 MACRO		BDB$L_LAST	= 32,0,32,0%; 	! address of last directory record 
 MACRO		BDB$L_WAIT	= 36,0,32,0%; 	! wait thread (irab addr) 
 			! (for inter-stream intra- 
 			!  process locking only) 
 MACRO		BDB$L_VERCOUNT	= 36,0,32,0%; 	! negative count of version entries scanned 
 			 
 MACRO		BDB$L_WK1	= 40,0,32,0%; 		! work area 
 MACRO		BDB$B_REL_VBN	= 40,0,8,0%; 	! current vbn rel to start of buffer 
 MACRO		BDB$B_VAL_VBNS	= 41,0,8,0%; 	! # of valid vbns in buffer 
 MACRO		BDB$B_PRE_CCTL	= 42,0,8,0%; 	! unit record carriage control byte ('pre') 
 MACRO		BDB$B_POST_CCTL	= 43,0,8,0%; 	! unit record carriage control byte ('post') 
 MACRO		BDB$L_CURBUFADR	= 44,0,32,0%; 	! current buffer addr 
 					! re-use for i/o status block 
 MACRO		BDB$L_IOSB	= 40,0,0,0%; 	! i/o status block for buffer 
 LITERAL	BDB$S_IOSB	= 8; 
 MACRO		BDB$L_VERSION	= 40,0,32,0%; 	! addr of current/next directory version entry 
 MACRO		BDB$L_RECORD	= 44,0,32,0%; 	! address of current/next directory record 
 LITERAL	BDB$C_BLN	= 48; 
 LITERAL	BDB$K_BLN	= 48; 			! length of bdb block 

  
 ! 
 !	GBPB field definitions 
 ! 
 ! Global Buffer Pointer Block (GBPB) 
 ! 
 ! The GBPB is the process local structure used in conjunction with 
 ! shared global i/o buffers.  In order to minimize the impact of 
 ! global buffers on existing code, the GBPB is identical to a BDB 
 ! in those fields which are referenced outside of the RM$CACHE and 
 ! RM$RELEASE routines. 
 ! 
 !...$GBPBDEF	
  
 MACRO		GBPB$L_FLINK	= 0,0,32,0%; 	! forward link 
 MACRO		GBPB$L_BLINK	= 4,0,32,0%; 	! backward link 
 MACRO		GBPB$B_BID	= 8,0,8,0%; 		! block id 
 LITERAL	GBPB$C_BID	= 21; 		! gbpb id code 
 MACRO		GBPB$B_BLN	= 9,0,8,0%; 		! block length in longwords 
 MACRO		GBPB$B_FLGS	= 10,0,8,0%; 	! gbpb flags (use BDB flgs definitions) 
 MACRO		GBPB$B_CACHE_VL	= 11,0,8,0%; 	! relative cache value of this buffer 
 MACRO		GBPB$W_USERS	= 12,0,16,0%; 	! number of streams referencing this buffer 
 MACRO		GBPB$W_BUFF_ID	= 14,0,16,0%; 	! buffer identification number 
 MACRO		GBPB$L_BLB_PTR	= 16,0,32,0%; 	! pointer to BLB chain for this GBPB 
 MACRO		GBPB$W_NUMB	= 20,0,16,0%; 	! # of bytes of buffer in use 
 MACRO		GBPB$W_SIZE	= 22,0,16,0%; 	! # bytes in buffer 
 MACRO		GBPB$L_ADDR	= 24,0,32,0%; 	! address of buffer 
 MACRO		GBPB$L_VBN	= 28,0,32,0%; 		! 1st vbn in buffer 
 MACRO		GBPB$L_VBNSEQNO	= 32,0,32,0%; 	! sequence number field. 
 MACRO		GBPB$L_GBD_PTR	= 36,0,32,0%; 	! Pointer to the GBD for this buffer. 
 LITERAL	GBPB$C_BLN	= 40; 
 LITERAL	GBPB$K_BLN	= 40; 			! Length of GBPB block 

  
  
 ! 
 !	rlb field definitions 
 ! 
 !  record lock block (rlb) 
 ! 
 !  the rlb describes one locked record for a particular 
 !  process-record stream (rab/irab). if the owner field 
 !  is 0 then the rlb is available for use. otherwise, it 
 !  describes a locked record. note: when owner is 0 the 
 !  record rfa fields are zeroed (0). 
 ! 
 ! 
 !                +---------------------------------------+ 
 !                |                                       | 
 !rlb:            |                link                   | 
 !                |                                       | 
 !                +------------------+--------------------+ 
 !                |                  |                    | 
 !                |       owner	    |        rfa4	 | 
 !                |                  !               id   | 
 !                +---------+--------+----------+---------+ 
 !                |         |        |          |         | 
 !                |  flags  |reserved|   bln    |   bid   | 
 !                |         |        |          |         | 
 !                +---------+--------+----------+---------+ 
 !                |                                       | 
 !                |                rfa0                   | 
 !		 |                                       | 
 !                +---------------------------------------+ 
 !                |                  |                    | 
 !lksb:           | Still to be def- |  VMS status code   | 
 !                | ined status bits |                    | 
 !                +---------------------------------------+ 
 !                |                                       | 
 !                |  Lock Id. (Returned for new locks,    | 
 !                |            input for conversions)     | 
 !                +---------------------------------------+ 
 ! 
 ! 
 !...$RLBDEF	
  
 MACRO		RLB$L_LNK	= 0,0,32,0%; 			! link to next rlb 
 MACRO		RLB$L_MISC	= 4,0,32,0%; 		! longword definition to optimize clearing field 
 MACRO		RLB$W_OWNER	= 4,0,16,0%; 		! owner id for locked record is 
 		  		!  isi for stream 
 				! note that owner field is now a word, not 
 				! a longword anymore 
 MACRO		RLB$W_RFA4	= 6,0,16,0%; 		! 3'rd word of records rfa 
 				! offset for seq f.o. (bits 0:14) 
 				! always 0 for rel f.o. (bits 0:14) 
 MACRO		RLB$W_ID	= 6,0,16,0%; 		! id for idx f.o. 
 MACRO		RLB$B_BID	= 8,0,8,0%; 			! block id 
 LITERAL	RLB$C_BID	= 14; 			! rlb code 
 MACRO		RLB$B_BLN	= 9,0,8,0%; 			! block length in longwords 
 MACRO		RLB$B_FLAGS	= 11,0,8,0%; 		! various locking flags 
 			 
 MACRO		RLB$V_WAIT	= 11,0,1,0%; 			! propagation of ROP WAT bit 
 LITERAL	RLB$M_WAIT	= 1^1 - 1^0; 
 MACRO		RLB$V_CR	= 11,1,1,0%; 			! defines lock manager mode "concurrent read" 
 LITERAL	RLB$M_CR	= 1^2 - 1^1; 
 				! used to query lock database for records 
 MACRO		RLB$V_PW	= 11,2,1,0%; 			! allow reader access to locked record flag 
 LITERAL	RLB$M_PW	= 1^3 - 1^2; 
 				! indicate "lock for write, allow readers" 
 MACRO		RLB$V_PR	= 11,3,1,0%; 			! used to query lock database 
 LITERAL	RLB$M_PR	= 1^4 - 1^3; 
 			
 MACRO		RLB$L_RFA0	= 12,0,32,0%; 		! 1'st and 2'nd words of record's rfa 
 				! seq f.o. vbn 
 				! rel f.o. relative record number 
 				! idx f.o. start vbn 
 MACRO		RLB$L_LKSB	= 16,0,32,0%; 		! first longword of lock status block 
 MACRO		RLB$W_STATUS	= 16,0,16,0%;  		! VMS status code 
 MACRO		RLB$W_S_BITS	= 18,0,16,0%; 		! various status bits 
 MACRO		RLB$L_LOCK_ID	= 20,0,32,0%; 		! second longword of lksb is lock_id 
 LITERAL	RLB$C_BLN	= 24; 
 LITERAL	RLB$K_BLN	= 24; 				! length of rlb 

  
 ! 
 !  directory cache node definitions 
 ! 
 !...$DRCDEF	
  
 MACRO		DRC$L_NXTFLNK	= 0,0,32,0%; 	! link to next entry, this level 
 MACRO		DRC$L_NXTBLNK	= 4,0,32,0%; 	! link to previous entry, this level 
 MACRO		DRC$L_LVLFLNK	= 8,0,32,0%; 	! link to first entry, next lower level 
 MACRO		DRC$L_LVLBLNK	= 12,0,32,0%; 	! link to last entry, next lower level 
 			! note: the links are maintained in lru order 
 MACRO		DRC$T_NAME	= 16,0,0,0%; 	! directory name or device and unit 
 LITERAL	DRC$S_NAME	= 10; 
 			! note: stored as counted string counting count itself 
 MACRO		DRC$W_DID	= 26,0,0,0%; 	! file id for directory 
 LITERAL	DRC$S_DID	= 6; 
 MACRO		DRC$W_DIRSEQ	= 28,0,16,0%; 	! directory sequence # for device node 
 LITERAL	DRC$C_BLN	= 32; 
 LITERAL	DRC$K_BLN	= 32; 			! length of directory cache node 

  
  
 ! 
 !		release option flag definitions 
 ! 
 !...$RLSDEF	
  
 			 
 MACRO		RLS$V_RETURN	= 0,0,1,0%; 		! return buffer and bdb to free space lists 
 LITERAL	RLS$M_RETURN	= 1^1 - 1^0; 
 MACRO		RLS$V_WRT_THRU	= 0,1,1,0%; 	! write buffer if dirty 
 LITERAL	RLS$M_WRT_THRU	= 1^2 - 1^1; 
 MACRO		RLS$V_KEEP_LOCK	= 0,2,1,0%; 	! keep bdb locked 
 LITERAL	RLS$M_KEEP_LOCK	= 1^3 - 1^2; 
 MACRO		RLS$V_DEQ	= 0,3,1,0%; 		! always release lock 
 LITERAL	RLS$M_DEQ	= 1^4 - 1^3; 
 			

  
 ! 
 !		cache option flag definitions 
 ! 
 !...$CSHDEF	
  
 			 
 MACRO		CSH$V_LOCK	= 0,0,1,0%; 		! obtain exclusive access to block 
 LITERAL	CSH$M_LOCK	= 1^1 - 1^0; 
 MACRO		CSH$V_NOWAIT	= 0,1,1,0%; 		! do not wait for block on access interlock 
 LITERAL	CSH$M_NOWAIT	= 1^2 - 1^1; 
 			! collision 
 MACRO		CSH$V_NOREAD	= 0,2,1,0%; 		! do not read in block 
 LITERAL	CSH$M_NOREAD	= 1^3 - 1^2; 
 MACRO		CSH$V_NOBUFFER	= 0,3,1,0%; 	! obtain access to block but don't allocate 
 LITERAL	CSH$M_NOBUFFER	= 1^4 - 1^3; 
 			! a buffer for it and don't read it 
 			

  
 ! 
 ! 
 !  rms overall status bit definitions 
 ! 
 !...$PIODEF	
  
 			 
 MACRO		PIO$V_INHAST	= 0,0,1,0%; 		! set if asts implicitly inhibited 
 			! if reset by disabled ast, ast must be re- 
 			! enabled 
 MACRO		PIO$V_EOD	= 0,1,1,0%; 		! set if searching for 'eod' string on 'input' 
 MACRO		PIO$V_SYNC1	= 0,2,1,0%; 		! sync stalled operation using efn 27 
 MACRO		PIO$V_SYNC2	= 0,3,1,0%; 		! sync stalled operation using efn 28 
 			

  
  
 ! 
 !	definitions for rms debug failure codes 
 ! 
 ! 
 !  the following codes are for temporary bug check tests, and are 
 !  internal to rms.  all of the codes are negative, implying that they 
 !  do not return to the caller, probably killing the process (if not 
 !  the entire system). 
 ! 
 !...$FTLDEF	
  
 LITERAL	
 $EQULST (FTL$_,GBL,0,1  
 	,(SETPRTFAIL,-1) 		! set protection system service failed (rm0bufmgr) 
 	,(STKTOOBIG,-2) 		! stack too big for asb (rm0stall) 
 	,(BADIFAB,-3) 		! invalid ifab (or irab) (rm0fset,rm0conn,rm0rset, 
 			! rm0prflnm) 
 	,(GTCHNFAIL,-4) 		! get channel system service failure (rm0prflnm) 
 	,(BADORGCASE,-5) 		! invalid orgcase value for dispatch (all rms$ 
 			! level routines execept open and create) 
 	,(BADBDB,-6) 		! block not a bdb (rm0bufmgr) 
 	,(ASBALLFAIL,-7) 		! couldn't allocate an asb (rm0stall) 
 	,(BADASTPRM,-8) 		! ast parameter not a valid ifab/irab addr (rm0stall) 
 	,(CANTDOAST,-9) 		! couldn't redeclare ast (insf. mem.) (rm0stall) 
 	,(NOSTRUCT,-10) 		! rab or fab not same on ast (rm0stall) 
 	,(NOASB,-11) 		! asb not allocated or stream not busy on ast (rm0stall) 
 	,(NONXTBDB,-12) 		! no next bdb available (rm1seqxfr) 
 	,(BADBUFSIZ,-13) 		! disk buffer size not = 512 (rm1conn) 
 	,(ENQDEQFAIL,-14) 		! enq or deq service failed (rm0reclck) 
 	,(NOCURBDB,-15) 		! no current bdb before calling rm$release (rm0reclck) 
 			!   (-16 no longer used) 
 	,(DEALLERR,-17) 		! ifab deallocation attempted with other block(s) 
 			! still allocated (rms0close) 
 	,(IORNDN,-18) 		! i/o rundown inconsistency (either ifab or irab 
 			! table entries not zeroed) (rms0rndwn) 
 	,(XFERSIZE,-19) 		! size of requested transfer not equal to 
 			! or less than the current number of bytes 
 			! in use for the bdb (rm0cache) 
 	,(NOTLOCKED,-20) 		! bdb not locked and a keep lock request 
 			! was made on a release request. 
 	,(NODIDORFID,-21) 		! neither a fid nor a did was set upon exit from 
 			! rm$setdid (rms0erase) 
 	,(RELEASFAIL,-22) 		! release of non-dirty bdb failed (rm0xtnd23,rms0extend) 
 	,(NOLOCKBDB,-23) 		! no lock bdb found (rm0xtnd23) 
 	,(NONETWORK,-24) 		! network routine entered but no network support in rms 
 	,(LOCKFAILED,-25) 		! failed to lock prolog (rm2create) 
 	,(BADLEVEL,-26) 		! to search by id, structure level must be 0 
 	,(ASTDECERR,-27) 		! ast declaration for file sharing failed 
 	,(BCBERR,-28) 		! no more bcb's to release even though more bdb's 
 	,(SFDSPCERR,-29) 		! all space was not returned before returning sifab pag 
 	,(ACCNTOVFLO,-30) 		! access count overflow (rm0share) 
 	,(QUEUEERR,-31) 		! take sifab queue error (rm0share) 
 	,(QUEUEERR2,-32) 		! release sifab queue error (rm0share) 
 	,(BDBAVAIL,-33) 		! BDB was available and shouldn't have been. 
 	,(GBLNOLK,-34) 		! Record locking was not set with global buffers. 
 	,(LCKFND,-35) 		! A lock was found and we don't know what to do. 
 	,(NOBLB,-36) 		! No BLB was found and there should have been one. 
 	,(NOGBPB,-37) 		! No GBPB was found and should have been. 
 	,(NOLCLBUF,-38) 		! Should have found a local buffer. 
 	,(NORDNOTSET,-39) 		! NOREAD not set when NOBUFFER was. 
 	,(NOTGBPB,-40) 		! Found an illegit BDB. 
 	,(NOSFSB,-41) 		! No SFSB when allocating BLB. 
 	,(LOCKHELD,-42) 		! Attempted to return a BLB with lock_id neq 0 
 	,(RLSDRT,-43) 		! Dirty buffer found in releasall. 
 	,(BADBLB,-44) 		! Bad BLB found in blocking AST routine. 
 	,(BADOWNER,-45) 		! Owner field in BLB is bad in blocking AST routine. 
 	); 
  

  
 ! 
 !  the following internal codes are for non-fatal bug check reporting. 
 !  these codes are positive byte values.  they trigger a reporting action 
 !  and return to the caller with r0 set to rms$_bug+<8*the bug code>, 
 !  which is an externally documented rms error code. 
 ! 
 !...$BUGDEF	
  
 LITERAL	
 $EQULST (BUG$_,GBL,0,1  
 	,(BADDFLTDIR,1) 		!DEFAULT DIRECTORY STRING INVALID (RM0XPFN) 
 	); 
  

  
 ! index descriptor definition 
 ! 
 ! an index descriptor block exists for each key of reference in use. 
 ! they are not necessarily contiguous in memory. 
 ! 
 !...$IDXDEF	
 	 
 MACRO		IDX$L_IDXFL	= 0,0,32,0%; 			! forward link to next index descriptor 
 MACRO		IDX$B_BID	= 8,0,8,0%; 			! block id 
 LITERAL	IDX$C_BID	= 15; 			! id for index descriptor block 
 MACRO		IDX$B_BLN	= 9,0,8,0%; 			! length of block 
 MACRO		IDX$B_IANUM	= 10,0,8,0%; 		! area number for index buckets 
 MACRO		IDX$B_LANUM	= 11,0,8,0%; 		! area number for lower index buckets 
 MACRO		IDX$B_DANUM	= 12,0,8,0%; 		! area number for data buckets 
 MACRO		IDX$B_ROOTLEV	= 13,0,8,0%; 		! level of root 
 MACRO		IDX$B_IDXBKTSZ	= 14,0,8,0%; 		! size of index bucket in vbn's 
 MACRO		IDX$B_DATBKTSZ	= 15,0,8,0%; 		! size of data bucket in vbn's 
 MACRO		IDX$L_ROOTVBN	= 16,0,32,0%; 		! start vbn of root bucket 
 MACRO		IDX$B_FLAGS	= 20,0,8,0%; 		! index/key flags 
 			 
 MACRO		IDX$V_DUPKEYS	= 20,0,1,0%; 		! duplicate keys allowed 
 LITERAL	IDX$M_DUPKEYS	= 1^1 - 1^0; 
 MACRO		IDX$V_CHGKEYS	= 20,1,1,0%; 		! keys can change values 
 LITERAL	IDX$M_CHGKEYS	= 1^2 - 1^1; 
 MACRO		IDX$V_NULKEYS	= 20,2,1,0%; 		! null key value allowed 
 LITERAL	IDX$M_NULKEYS	= 1^3 - 1^2; 
 MACRO		IDX$V_IDX_COMPR	= 20,3,1,0%; 		! index is compressed 
 LITERAL	IDX$M_IDX_COMPR	= 1^4 - 1^3; 
 MACRO		IDX$V_INITIDX	= 20,4,1,0%; 		! index is not initialized 
 LITERAL	IDX$M_INITIDX	= 1^5 - 1^4; 
 MACRO		IDX$V_COUNT_DUP	= 20,5,1,0%; 		! maintain duplicate count 
 LITERAL	IDX$M_COUNT_DUP	= 1^6 - 1^5; 
 			
  
 						! primary key flags only 
 							! space over dupkeys 
 MACRO		IDX$V_NORFA	= 20,1,1,0%; 			! no rfa fields in records (single key only) 
 LITERAL	IDX$M_NORFA	= 1^2 - 1^1; 
 MACRO		IDX$V_PRG_D_RFA	= 20,2,1,0%; 		! delete records and rrv's may be purged 
 LITERAL	IDX$M_PRG_D_RFA	= 1^3 - 1^2; 
 				! from file (disables fast delete) 
 				 
 				 
 				 
 MACRO		IDX$V_KEY_COMPR	= 20,6,1,0%; 		! key has been compressed at the data level 
 LITERAL	IDX$M_KEY_COMPR	= 1^7 - 1^6; 
 MACRO		IDX$V_REC_COMPR	= 20,7,1,0%; 		! data record is in compressed form 
 LITERAL	IDX$M_REC_COMPR	= 1^8 - 1^7; 
 			
  
 MACRO		IDX$B_DATATYPE	= 21,0,8,0%; 		! data type of key field 
 LITERAL	IDX$C_STRING	= 0; 			! string data type 
 LITERAL	IDX$C_SGNWORD	= 1; 			! signed binary word 
 LITERAL	IDX$C_UNSGNWORD	= 2; 			! unsigned binary word 
 LITERAL	IDX$C_SGNLONG	= 3; 			! signed binary long word 
 LITERAL	IDX$C_UNSGNLONG	= 4; 			! unsigned binary long word 
 LITERAL	IDX$C_PACKED	= 5; 			! packed decimal 
 MACRO		IDX$B_SEGMENTS	= 22,0,8,0%; 		! number of key field segments 
 MACRO		IDX$B_NULLCHAR	= 23,0,8,0%; 		! null character 
 MACRO		IDX$B_KEYSZ	= 24,0,8,0%; 		! total key size 
 MACRO		IDX$B_KEYREF	= 25,0,8,0%; 		! key of reference(0-primary) 
 MACRO		IDX$W_MINRECSZ	= 26,0,16,0%; 		! minimum record size 
 MACRO		IDX$W_IDXFILL	= 28,0,16,0%; 		! index fill 
 MACRO		IDX$W_DATFILL	= 30,0,16,0%; 		! data fill 
 MACRO		IDX$B_IDXBKTYP	= 32,0,8,0%; 		! PLG3 - type of index bucket and SIDR bucket 
 LITERAL	IDX$C_V2_BKT	= 0; 			! Prologue two bucket 
 LITERAL	IDX$C_CMPIDX	= 1; 			! Prologue 3, index (and SIDR) are compressed 
 LITERAL	IDX$C_NCMPIDX	= 2; 			! Prologue 3, index (and SIDR) are not compressed 
 MACRO		IDX$B_DATBKTYP	= 33,0,8,0%; 		! PLG3 - type of primary data bucket 
 LITERAL	IDX$C_CMPCMP	= 3; 			! Prologue 3, primary key is compressed, data 
 				!  is compressed 
 LITERAL	IDX$C_CMPNCMP	= 4; 			! Prologue 3, primary key is compressed, 
 				!  data is not compressed 
 LITERAL	IDX$C_NCMPCMP	= 5; 			! Prologue 3, primary key is not compressed 
 				!  data is compressed 
 LITERAL	IDX$C_NCMPNCMP	= 6; 			! Prologue 3, primary key is not compressed 
 				!  data is not compressed 
 ! 
 ! the following is the length of the fixed part of the index descriptor 
 ! 
 LITERAL	IDX$C_FIXED_BLN	= 36; 
 LITERAL	IDX$K_FIXED_BLN	= 36; 	 
  
 ! 
 ! the following is repeated for each key segment 
 ! 
 MACRO		IDX$W_POSITION	= 36,0,16,0%; 		! key segment position 
 MACRO		IDX$B_SIZE	= 38,0,8,0%; 		! key segment size (plg 3) 
 MACRO		IDX$B_TYPE	= 39,0,8,0%; 		! key segment datatype (plg 3) 

  
  
 ! 
 ! nrp list definitions 
 ! 
 !...$NRPDEF	
  
 MACRO		NRP$L_LINK	= 0,0,32,0%; 	! link to next " next record pointer" cell 
 MACRO		NRP$B_SPARE	= 4,0,8,0%; 	! needed to match the next section size 
  
 ! Beginning of first section (9 bytes long) 
  
 MACRO		NRP$L_VBN	= 5,0,32,0%; 		! vbn of "next record " 
 MACRO		NRP$W_ID	= 9,0,16,0%; 		! id of "next record " (plg 3) 
 MACRO		NRP$B_FLAGS	= 11,0,8,0%;  
 			 
 MACRO		NRP$V_DELETED	= 11,0,1,0%; 	! the "next record " has been deleted 
 LITERAL	NRP$M_DELETED	= 1^1 - 1^0; 
 MACRO		NRP$V_BEGINNING	= 11,1,1,0%; 	! we are pointed to the beg. of a bucket 
 LITERAL	NRP$M_BEGINNING	= 1^2 - 1^1; 
 MACRO		NRP$V_NEW_VBN	= 11,2,2,0%; 	! 0,1,2 indicating what the new vbn will be, 
 LITERAL	NRP$M_NEW_VBN	= 1^4 - 1^2; 
 			! used during split 
 MACRO		NRP$V_UPD_NRP	= 11,4,1,0%; 	! nrp is to be updated 
 LITERAL	NRP$M_UPD_NRP	= 1^5 - 1^4; 
 MACRO		NRP$V_NEW_DEL	= 11,5,1,0%; 	! the new delete flag(used in $delete) 
 LITERAL	NRP$M_NEW_DEL	= 1^6 - 1^5; 
 MACRO		NRP$V_NEW_BEG	= 11,6,1,0%; 	! the new beginning flag(used in $delete) 
 LITERAL	NRP$M_NEW_BEG	= 1^7 - 1^6; 
 			
 MACRO		NRP$W_DUP_POS	= 12,0,16,0%; 	! position count for sidr's 
  
 ! Beginning of second section 
  
 MACRO		NRP$L_RP_VBN	= 14,0,32,0%; 	! vbn of "record" 
 MACRO		NRP$W_RP_ID	= 18,0,16,0%; 	! rp of "record" (plg 3) 
 MACRO		NRP$W_NEW_POS	= 20,0,16,0%; 	! the new dup_pos (used in $delete and clean up deleted records) 
 MACRO		NRP$W_NEW_NRP	= 22,0,16,0%; 	! new id for nrp, used during split (plg 3) 
 LITERAL	NRP$C_BLN	= 24; 
 LITERAL	NRP$K_BLN	= 24; 	 
 LITERAL	NRP$C_CELL	= 9; 		! Determines the size of sections within the NRP cell, 
 			! such that corresponding values can be referenced by 
 			! the same address when the NRP pointer is changed. 

  
 ! 
 ! update buffer flags 
 ! 
 !...$UPDDEF	
  
 MACRO		UPD$B_FLAGS	= 0,0,8,0%;  
 			 
 MACRO		UPD$V_INS_NEW	= 0,0,1,0%; 	! alternate key to be inserted from record buffer 
 LITERAL	UPD$M_INS_NEW	= 1^1 - 1^0; 
 MACRO		UPD$V_OLD_DEL	= 0,1,1,0%; 	! delete this key value using old record 
 LITERAL	UPD$M_OLD_DEL	= 1^2 - 1^1; 
 			

  
 !	GBH field definitions 
 ! 
 ! Global Buffer Header (GBH) 
 ! 
 ! There is a Global Buffer Header for every file's global buffer section. 
 ! 
 !...$GBHDEF	
  
 MACRO		GBH$L_GBD_FLNK	= 0,0,32,0%; 	! Self relative queue header for GBD's 
 MACRO		GBH$L_GBD_BLNK	= 4,0,32,0%;  
 MACRO		GBH$B_BID	= 8,0,8,0%; 		! Block ID 
 LITERAL	GBH$C_BID	= 17; 		! Block ID code for GBH 
 MACRO		GBH$B_BLN	= 9,0,8,0%; 		! Length of GBH in longwords 
 MACRO		GBH$W_TRC_FLGS	= 10,0,16,0%; 	! Trace flags (set to trace given function) 
 			 
 MACRO		GBH$V_CACHE_IN	= 10,0,1,0%; 	! Cache inputs 
 LITERAL	GBH$M_CACHE_IN	= 1^1 - 1^0; 
 MACRO		GBH$V_CACHE_OUT	= 10,1,1,0%; 	! Cache outputs 
 LITERAL	GBH$M_CACHE_OUT	= 1^2 - 1^1; 
 MACRO		GBH$V_RLS_IN	= 10,2,1,0%; 	! Release inputs 
 LITERAL	GBH$M_RLS_IN	= 1^3 - 1^2; 
 MACRO		GBH$V_RLS_OUT	= 10,3,1,0%; 	! Release outputs 
 LITERAL	GBH$M_RLS_OUT	= 1^4 - 1^3; 
 MACRO		GBH$V_QIO_START	= 10,4,1,0%; 	! Qio inputs 
 LITERAL	GBH$M_QIO_START	= 1^5 - 1^4; 
 MACRO		GBH$V_QIO_DONE	= 10,5,1,0%; 	! Qio outputs 
 LITERAL	GBH$M_QIO_DONE	= 1^6 - 1^5; 
 MACRO		GBH$V_STALL	= 10,6,1,0%; 		! Stall inputs 
 LITERAL	GBH$M_STALL	= 1^7 - 1^6; 
 MACRO		GBH$V_THREADGO	= 10,7,1,0%; 	! Stall outputs 
 LITERAL	GBH$M_THREADGO	= 1^8 - 1^7; 
 MACRO		GBH$V_BLB_ENQ	= 10,8,1,0%; 	! Bucket lock ENQ inputs 
 LITERAL	GBH$M_BLB_ENQ	= 1^9 - 1^8; 
 MACRO		GBH$V_BLB_GRANT	= 10,9,1,0%; 	! Bucket lock grant status 
 LITERAL	GBH$M_BLB_GRANT	= 1^10 - 1^9; 
 MACRO		GBH$V_BLB_DEQ	= 10,10,1,0%; 	! Bucket lock DEQ request 
 LITERAL	GBH$M_BLB_DEQ	= 1^11 - 1^10; 
 MACRO		GBH$V_BLB_BLOCK	= 10,11,1,0%; 	! Blocking AST received 
 LITERAL	GBH$M_BLB_BLOCK	= 1^12 - 1^11; 
 MACRO		GBH$V_F1	= 10,12,1,0%;  
 LITERAL	GBH$M_F1	= 1^13 - 1^12; 
 MACRO		GBH$V_F2	= 10,13,1,0%;  
 LITERAL	GBH$M_F2	= 1^14 - 1^13; 
 MACRO		GBH$V_F3	= 10,14,1,0%;  
 LITERAL	GBH$M_F3	= 1^15 - 1^14; 
 MACRO		GBH$V_F4	= 10,15,1,0%;  
 LITERAL	GBH$M_F4	= 1^16 - 1^15; 
 			
  
 MACRO		GBH$L_HI_VBN	= 12,0,32,0%; 	! Highest possible VBN value (FFFFFFFF). 
 MACRO		GBH$L_GS_SIZE	= 16,0,32,0%; 	! Size of total section in bytes. 
 MACRO		GBH$L_TRC_FLNK	= 20,0,32,0%; 	! Trace blocks forward link 
 MACRO		GBH$L_TRC_BLNK	= 24,0,32,0%; 	! Trace blocks back link 
 MACRO		GBH$L_GBD_START	= 28,0,32,0%; 	! Offset to first GBD. 
 MACRO		GBH$L_GBD_END	= 32,0,32,0%; 	! Offset to last GBD. 
 MACRO		GBH$L_GBD_NEXT	= 36,0,32,0%; 	! Offset to next cache victim GBD. 
 MACRO		GBH$L_SCAN_NUM	= 40,0,32,0%; 	! Number of GBD's to scan for victim. 
 ! 
 ! Global buffer statistics section 
 ! 
 MACRO		GBH$L_HIT	= 44,0,32,0%; 		! Buffer found in global cache 
 MACRO		GBH$L_MISS	= 48,0,32,0%; 	! Buffer not found in global cache 
 MACRO		GBH$L_READ	= 52,0,32,0%; 	! Buffer read from disk into cache 
 MACRO		GBH$L_WRITE	= 56,0,32,0%; 	! Buffer written from cache to disk 
 MACRO		GBH$L_DFW_WRITE	= 60,0,32,0%; 	! Deferred writeback from cache to disk 
 MACRO		GBH$L_CROSS_HIT	= 64,0,32,0%; 	! Cross process hit count. 
 LITERAL	GBH$C_BLN	= 68; 
 LITERAL	GBH$K_BLN	= 68; 			! Length of global buffer header structure 

  
  
  
 !	TRC field definitions 
 ! 
 ! Trace block structure (TRC) 
 ! 
 ! Tracing saves at specific points in the RMS code for debugging and 
 ! algorithm analysis purposes. 
 ! 
 !...$TRCDEF	
  
 MACRO		TRC$L_FLNK	= 0,0,32,0%; 	! Trace block forward link 
 MACRO		TRC$L_BLNK	= 4,0,32,0%; 	! Trace block back link 
 MACRO		TRC$B_BID	= 8,0,8,0%; 		! Block ID 
 LITERAL	TRC$C_BID	= 18; 		! Trace block code 
 MACRO		TRC$B_BLN	= 9,0,8,0%; 		! Length of block in longwords 
 MACRO		TRC$W_FUNCTION	= 10,0,16,0%; 	! Function code (see GBH definitions) 
 MACRO		TRC$L_STRUCTURE	= 12,0,32,0%; 	! Ifab/irab address. 
 MACRO		TRC$W_PID	= 16,0,16,0%; 		! Process ID 
 MACRO		TRC$W_SEQNUM	= 18,0,16,0%; 	! Sequence number. 
 MACRO		TRC$L_VBN	= 20,0,32,0%; 		! VBN requested. 
 MACRO		TRC$L_RETURN1	= 24,0,32,0%; 	! Address of caller. 
 MACRO		TRC$L_RETURN2	= 28,0,32,0%; 	! Caller's caller. 
 MACRO		TRC$L_ARGS	= 32,0,0,0%; 	! Function specific arguments 
 LITERAL	TRC$S_ARGS	= 32; 
 MACRO		TRC$L_ARG_FLG	= 32,0,32,0%; 	! Argument flags (R3). 
 MACRO		TRC$L_BDB_ADDR	= 36,0,32,0%; 	! BDB address. 
 MACRO		TRC$W_BDB_USERS	= 40,0,16,0%; 	! Use count from BDB. 
 MACRO		TRC$W_BDB_BUFF	= 42,0,16,0%; 	! BDB buffer ID. 
 MACRO		TRC$B_BDB_CACHE	= 44,0,8,0%; 	! BDB cache value. 
 MACRO		TRC$B_BDB_FLAGS	= 45,0,8,0%; 	! Status flags from BDB. 
 MACRO		TRC$L_BDB_SEQ	= 46,0,32,0%; 	! Sequence number from BDB. 
 MACRO		TRC$B_BLB_MODE	= 50,0,8,0%; 	! Mode held in BLB. 
 MACRO		TRC$B_BLB_FLAGS	= 51,0,8,0%; 	! Flags from BLB. 
 MACRO		TRC$L_BLB_ADDR	= 52,0,32,0%; 	! Address of BLB. 
 MACRO		TRC$L_BLB_LOCK	= 56,0,32,0%; 	! Lock ID from BLB. 
 MACRO		TRC$L_BLB_SEQ	= 60,0,32,0%; 	! Sequence number from BLB. 
 LITERAL	TRC$C_BLN	= 64; 
 LITERAL	TRC$K_BLN	= 64; 			! NOTE: should be quadwords multiple to 
 			! maintain quad alignment on header 

  
  
  
  
 !	GBD structure definitions 
 ! 
 ! Global Buffer Descriptor (GBD) 
 ! 
 ! There is a single GBD for every buffer in a global buffer 
 ! section (used only with shared files).  The GBD's themselves 
 ! are in the section also and linked from a queue header in 
 ! the Global Buffer Header (GBH). 
 ! 
 !...$GBDDEF	
  
 MACRO		GBD$L_FLINK	= 0,0,32,0%; 	! Forward link - Note: This is a self relative queue 
 MACRO		GBD$L_BLINK	= 4,0,32,0%; 	! Back link 
 MACRO		GBD$B_BID	= 8,0,8,0%; 		! Block ID 
 LITERAL	GBD$C_BID	= 19; 		! Block ID code for GBD 
 MACRO		GBD$B_BLN	= 9,0,8,0%; 		! Block length of GBD 
 MACRO		GBD$B_FLAGS	= 10,0,8,0%; 	! Buffer status flags 
 			 
 MACRO		GBD$V_VALID	= 10,0,1,0%; 	! Buffer is valid. 
 LITERAL	GBD$M_VALID	= 1^1 - 1^0; 
 			
 MACRO		GBD$B_CACHE_VAL	= 11,0,8,0%; 	! Cache value of this bucket 
 MACRO		GBD$L_VBN	= 12,0,32,0%; 		! VBN of bucket the buffer describes 
 MACRO		GBD$W_NUMB	= 16,0,16,0%; 	! Number of bytes in use 
 MACRO		GBD$W_SIZE	= 18,0,16,0%; 	! Size of buffer in bytes 
 MACRO		GBD$L_REL_ADDR	= 20,0,32,0%; 	! Address of buffer relative to GBH 
 MACRO		GBD$L_BKTSEQNUM	= 24,0,32,0%; 	! Bkt sequence number validity check 
 MACRO		GBD$W_LAST_ID	= 24,0,16,0%; 	! Last PID to reference bucket. 
 MACRO		GBD$W_LST_LK_ID	= 26,0,16,0%; 	! PID of last locker to reference bucket. 
 MACRO		GBD$W_USECNT	= 28,0,16,0%; 	! Accessor count for bucket 
 MACRO		GBD$B_REHIT_RD	= 30,0,8,0%; 	! Rehit by same process count. 
 MACRO		GBD$B_REHIT_LK	= 31,0,8,0%; 	! Rehit by same locker process. 
 LITERAL	GBD$C_BLN	= 32; 
 LITERAL	GBD$K_BLN	= 32; 			! NOTE: should be quad multiple to maintain 
 			! quad alignment on header 

  
  
  
 !	BLB field definitions 
 ! 
 ! Bucket Lock Block (BLB) 
 ! 
 ! The BLB contains the argument list for the SYS$ENQ system service 
 ! as well a pointer to the BDB it relates to and other status. 
 ! 
 !...$BLBDEF	
  
 MACRO		BLB$L_FLNK	= 0,0,32,0%; 	! Link to next BLB 
 MACRO		BLB$L_BLNK	= 4,0,32,0%; 	! Back link 
 MACRO		BLB$B_BID	= 8,0,8,0%; 		! Block ID 
 LITERAL	BLB$C_BID	= 16; 		! BLB code 
 MACRO		BLB$B_BLN	= 9,0,8,0%; 		! Block length 
 MACRO		BLB$B_BLBFLGS	= 10,0,8,0%; 	! Control flags for BLB 
 			 
 MACRO		BLB$V_LOCK	= 10,0,1,0%; 		! Corresponds to CSH$V_LOCK 
 LITERAL	BLB$M_LOCK	= 1^1 - 1^0; 
 MACRO		BLB$V_NOWAIT	= 10,1,1,0%; 	! Same as CSH$V_NOWAIT 
 LITERAL	BLB$M_NOWAIT	= 1^2 - 1^1; 
 MACRO		BLB$V_NOREAD	= 10,2,1,0%; 	! Same as CSH$V_NOREAD 
 LITERAL	BLB$M_NOREAD	= 1^3 - 1^2; 
 MACRO		BLB$V_NOBUFFER	= 10,3,1,0%; 	! Same as CSH$V_NOBUFFER 
 LITERAL	BLB$M_NOBUFFER	= 1^4 - 1^3; 
 MACRO		BLB$V_IOLOCK	= 10,4,1,0%; 	! Lock mode for read/write 
 LITERAL	BLB$M_IOLOCK	= 1^5 - 1^4; 
 MACRO		BLB$V_DFW	= 10,5,1,0%; 		! This is lock for deferred write buffer 
 LITERAL	BLB$M_DFW	= 1^6 - 1^5; 
 MACRO		BLB$V_WRITEBACK	= 10,6,1,0%; 	! The associated buffer must be written back 
 LITERAL	BLB$M_WRITEBACK	= 1^7 - 1^6; 
 			
 MACRO		BLB$B_MODEHELD	= 11,0,8,0%; 	! Mode of current lock held. 
 MACRO		BLB$L_BDB_ADDR	= 12,0,32,0%; 	! BDB for which this lock is held 
 MACRO		BLB$L_OWNER	= 16,0,32,0%; 	! Address of stream owning this lock 
 MACRO		BLB$L_VBN	= 20,0,32,0%; 		! VBN of bucket lock (resource name) 
 MACRO		BLB$L_RESDSC	= 24,0,0,0%; 	! Resource name descriptor 
 LITERAL	BLB$S_RESDSC	= 8; 
 MACRO		BLB$W_LKSTS	= 32,0,16,0%; 	! Lock status word 
 MACRO		BLB$L_LOCK_ID	= 36,0,32,0%; 	! Lock ID 
 MACRO		BLB$L_VALBLK	= 40,0,0,0%; 	! Lock value block 
 LITERAL	BLB$S_VALBLK	= 16; 
 MACRO		BLB$L_VALSEQNO	= 40,0,32,0%; 	! Sequence number part of value block 
 LITERAL	BLB$C_BLN	= 56; 
 LITERAL	BLB$K_BLN	= 56; 			! Length of BLB 

