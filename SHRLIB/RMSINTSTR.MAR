 ;	$begin	rmsintstr,V03-003
 ;
 ;****************************************************************************
 ;*									    *
 ;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
 ;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
 ;*  ALL RIGHTS RESERVED.						    *
 ;* 									    *
 ;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
 ;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
 ;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
 ;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
 ;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
 ;*  TRANSFERRED.							    *
 ;* 									    *
 ;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
 ;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
 ;*  CORPORATION.							    *
 ;* 									    *
 ;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
 ;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
 ;* 									    *
 ;*									    *
 ;****************************************************************************
 ;
 ;	internal rms structure definitions
 ;
 ;	Modified By:
 ;
 ;	V03-003 MCN0008		Maria del C. Nasr	25-Mar-1982
 ;		Change KBUFSZ to a word instead of a byte.
 ;
 ;	V03-002	CDS0015		C Saether		22-Mar-1982
 ;		Add GBH$L_HI_VBN field.
 ;		Add IFB$B_DRT_REHIT, IFB$B_GBL_REHIT,
 ;		GBH$L_CROSS_HIT, GBD$W_LAST_ID, GBD$W_LST_LK_ID,
 ;		GBD$B_REHIT_RD, and GBD$B_REHIT_LK fields.
 ;
 ;	V03-001	CDS0014		C Saether		18-Feb-1982
 ;		Add GBPB$L_VBNSEQNO and GBD$V_VAL fields.
 ;
 ;	V02-084	KBT0005		K B Thompson		15-Feb-1982
 ;		Add IRB$W_NID_RIGHT, IRB$W_NID_MID and IRB$W_RFA_NID
 ;
 ;	V02-083	KEK0018		K. E. Kinnear		9-Feb-1982
 ;		Add FWA$C_MTMAXNAM and FWA$C_MTLNONTAP symbols for ANSI-"a"
 ;		filespec parsing.  Remove padding at end of first page.
 ;		Lengthen FWA$T_NAMEBUF from 19 to 36 bytes long.
 ;
 ;	V02-082	CDS0013		C Saether		 4-Feb-1982
 ;		Move IFB$W_GBC to be part of the record attributes.
 ;		Add IRB$L_RBF and IRB$W_RSZ fields.
 ;
 ;	V02-081	KPL0014		Peter Lieberwirth	20-Jan-1982
 ;		Shorten some names in RLB.
 ;
 ;	V02-080	CDS0012		C Saether		17-Jan-1982
 ;		Add IFB$W_GBC field to ifab.  Add GBH$L_GS_SIZE field.
 ;		Change GBH$L_TRACE_FLNK and BLNK to GBH$L_TRC_FLNK and BLNK,
 ;		and GBPB$B_CACHE_VAL to GBPB$B_CACHE_VL so names don't
 ;		exceed 15 characters.  Also shorten some TRC names.
 ;
 ;	V02-079	CDS0011		C Saether		 8-Jan-1982
 ;		Add GBD_START, GBD_END, GBD_NEXT, SCAN_NUM to GBH struct.
 ;		Add NUMB, remove IOSB, delete FLAGS defs, and shuffle
 ;		fields in GBD structure.
 ;		Delete FLGS defs in GBPB structure.
 ;		Add FWA$T_XLTBUFF3.
 ;
 ;	V02-078	CDS0010		C Saether		30-Dec-1981
 ;		Add NEXT_DOWN alias for VBN_MID irab field.
 ;		Move KEYSZ in irab to align longwords at end.
 ;
 ;	V02-077	CDS0009		C Saether		28-Dec-1981
 ;		Changes to TRC fields.
 ;
 ;	V02-076	CDS0008		C Saether		 9-Dec-1981
 ;		Add BADBLB and BADOWNER fatal bugcheck codes.
 ;		Add BLB$V_WRITEBACK flag.
 ;		Further modify TRC and GBH definitions.
 ;
 ;	V02-075	CDS0007		C Saether		 8-Dec-1981
 ;		Eliminate the READAHEAD CSH and BLB flag.
 ;
 ;	V02-074 JWH0001		Jeffrey W. Horn		03-Dec-1981
 ;		Move Directory BDB equivalences from RM0DIRSCN into BDB
 ;		MDL definition.
 ;
 ;	V02-073	KPL0013		Peter Lieberwirth	23-Nov-1981
 ;		Clean up some RLB commentary.
 ;
 ;	V02-072	TMK0015		Todd M. Katz		12-Nov-1981
 ;		Add bits IFB$V_RMS_STALL and IRB$V_RMS_STALL to the IFAB
 ;		and IRAB respectively. These bits are set within RM0STALL
 ;		and cleared after delivery of RMS's AST at RM$THREADGO either
 ;		because RMS must wait for an I/O operation to complete
 ;		before it can resume its thread, or because RMS must wait for
 ;		a file/record lock before it can continue. NOTE: if the user
 ;		requested an asynchronous operation, it is RMS which is stalled
 ;		and must wait before completing the operation, and not the user
 ;		who will be able to continue.
 ;
 ;	V02-071	RAS0045		Ron Schaefer		11-Nov-1981
 ;		Increase the FWA internal device buffer size to 63 chars
 ;		in order to handle concealed device names and add
 ;		FWA$T_SHRFILDEV field, making the FWA over 1 page.
 ;
 ;	V02-070	RAS0040		Ron Schaefer		26-Oct-1981
 ;		Implement rooted directories for concealed devices.
 ;		Add FWA$T_MFD_FID for the root directory's FID.
 ;		Add FWA$V_DFLT_MFD and FWA$V_ROOT_DIR flags.
 ;		Add 10-byte FWA$T_ROOT_DIR buffer for root directory string.
 ;
 ;	V02-069	CDS0006		C Saether		14-Oct-1981
 ;		Eliminate overlap of assigned device char and blb header.
 ;
 ;	V02-068	CDS0005		C Saether		 8-Oct-1981
 ;		Add all cache flags to BLB flags (specifically NOBUFFER).
 ;
 ;	V02-067	CDS0004		C Saether		 9-Sep-1981
 ;		Add IFB$L_GBH_PTR field.  Pad out GBH to quad align length.
 ;		Define trace block arguments.
 ;
 ;	V02-066	CDS0003		C Saether		31-Aug-1981
 ;		Make IFB$W_AVLCL and IFB$W_AVGBPB part of all ifabs.
 ;
 ;	V02-065	CDS0002		C Saether		19-Aug-1981
 ;		Extend length of FIB 4 bytes.
 ;
 ;	V02-064	CDS0001		C Saether		14-Aug-1981
 ;		Modifications to BDB structure:
 ;		1) Remove USECNT field
 ;		2) Add CACHE_VAL field
 ;		3) Add USERS field
 ;		4) Add BUFF_ID field
 ;		5) Rename OWN to BLB_PTR field
 ;		6) Remove LKDINWS flag.
 ;
 ;		Add GBPB structure.
 ;		Add RLS$V_DEQ flag to RLS flags.
 ;		Add IFB$L_BLBFLNK, IFB$L_BLBBLNK to IFAB.
 ;		Add IFB$W_AVGBPB, IFB$W_AVLCL to IFAB.
 ;		Add IRB$V_GBLBUFF to IRAB book keeping bits.
 ;		Add a series of new bugcheck codes for cache.
 ;		Add GBH, TRC, GBD, and BLB structures.
 ;
 ;		Remove RLS$V_KEEP_ACC flag.
 ;
 ;	V02-063	TMK0003		T M Katz		10-Aug-1981
 ;		Add FWA$T_WILD, a 16 byte scratch field for RM0WILD
 ;
 ;	V02-062	TMK0002		T M Katz		10-Aug-1981
 ;		Change MAXDIRLEN to 81 from 60.
 ;
 ;	V02-061	PSK0010		Paulina S. Knibbe	 8-Aug-1981
 ;		Remove all support for truncated index keys.
 ;		UKEY_ONLY, CTX block. Add IRB$L_SPL_COUNT to keep
 ;		track of the number of the record we are moving into
 ;		the next bucket on an INDEX or SIDR split.
 ;
 ;	V02-060	KPL0012		Peter Lieberwirth	 3-Aug-1981
 ;		Move list of RLBs to IRAB from IFAB.  This makes the
 ;		multistreaming code much easier.
 ;
 ;	V02-059	PSK0009		Paulina S. Knibbe	08-Jun-1981
 ;		1) Add UKEY_ONLY bit to say to update only the key in an
 ;		   index record.
 ;		2) Add DIFF_CHAR to IRAB to keep track of
 ;		   which character distinguishes between two key values
 ;		3) Add CTX block to hold split context for
 ;		   prologue three files
 ;
 ;		PSK0008		Paulina S. Knibbe	05-May-1981
 ;		Add LST_NCMP to IRAB to keep track of addr of last key with
 ;		no front compression.
 ;
 ;		MCN0007		Maria del C. Nasr	23-Apr-1981
 ;		Add record buffer in IRAB for prologue 3 files.
 ;
 ;		PSK0007		Paulina S. Knibbe	21-Apr-1981
 ;		Make sure IRAB is an even multiple of longwords
 ;
 ;		PSK0006		Paulina S. Knibbe	17-Apr-1981
 ;		Add bits to IDX to tell if data level record is
 ;		compressed (REC_COMPR) or if the primary key
 ;		is compressed (KEY_COMPR). Remove constant for
 ;		largest non-compressed key (this will be in FILSTR
 ;		and having it in two places asks for trouble).
 ;		Rework the bucket types.
 ;
 ;		PSK0005		Paulina S. Knibbe	06-Apr-1981
 ;		Add fields to IDX to tell which flavor of bucket is
 ;		used for the index and primary data buckets for this
 ;		key.
 ;
 ;		PSK0004		Paulina S. Knibbe	30-Mar-1981
 ;		Add flag to IDX to indicate that the key portion of
 ;		the index  and SIDR records are fixed or variable.
 ;		(For prologue 3 files).
 ;
 ;		PSK0003		Paulina Knibbe		19-Mar-1981
 ;		Add REC_COUNT to IRAB so we can maintain it while
 ;		searching keys and use it while fetching VBN's
 ;
 ;		PSK0002		Paulina Knibbe		17-Mar-1981
 ;		Add constant for longest key not compressed
 ;
 ;		PSK0001		Paulina Knibbe		16-Mar-1981
 ;		Change the segment size to a byte length and
 ;		add segment datatype to IDX structure
 ;
 ;		MCN0006		Maria del C. Nasr	13-Mar-1981
 ;		Increase size of record identifier to a word in the
 ;		IRB, NRP, and RLB internal structures.
 ;
 ;	V02-058	KPL0011		Peter Lieberwirth	2-Jun-1981
 ;		Change RLB to add fields for lock manager interface.
 ;
 ;	V02-057	JAK0059		J A Krycka		15-Jun-1981
 ;		Remove symbols from the FWA that are no longer in use, namely:
 ;		FWA$B_FTYPSIZ, FWA$B_FVERSIZ, FWA$B_DMYPWDSIZ, FWA$C_DMYPWDSIZ.
 ;
 ;	V02-056	KRM0017		K R Malik		27-May-1981
 ;		Add FWA$B_FTYPSZ and FWA$B_FVERSIZ.
 ;
 ;	V02-055	KPL0007		Peter Lieberwirth	27-Apr-1981
 ;		Add a pointer to the SFSB (Shared File Synchronization
 ;		Block) in the IFAB
 ;
 ;	V02-054	kpl0002		Peter Lieberwirth	12-Jan-1981
 ;		add FTL codes ENQDEQFAIL and NOCURBDB to support new
 ;		record locking code
 ;
 ;	V02-053 ras0053		Ron Schaefer	24-Nov-1980	14:43
 ;		merge RMSINT and RMSIDXSTR internal structures into
 ;		one file containing all
 ;		in-memory structures and no on-disk structures.
 ;
 ;	V02-052	REFORMAT	Keith B. Thompson	29-JUL-1980
 ;
 ;	V051	jak0045		J A Krycka	21-MAR-1980	15:00
 ;		remove IFB$V_DAP_FMODE.
 ;
 ;	V050	cds0075		C D Saether	21-JAN-1980	11:25
 ;		remove IFB$L_FWA_BDB, IFB$W_BKS_BYTES, IFB$W_BKS_RECS.
 ;
 ;	V049	ras0010		R A Schaefer	07-JAN-1980	16:45
 ;		re-arrange drc fields for valid did check.
 ;
 ;	V048	ras0009		R A Schaefer	20-DEC-1979	15:30
 ;		add FWA$T_RNM_FID to hold the saved fid from a rename
 ;		for checking bad rename directory operation.
 ;
 ;	V047	jak0029		J A Krycka	18-NOV-1979	11:00
 ;		add FWA$V_REMRESULT to denote that fal has returned resultant
 ;		string.
 ;
 ;	v046	tmh0003		Tim Halvorsen	02-NOV-1979
 ;		add FWA$L_DIRBDB to hold address of directory buffer bdb
 ;		add FWA$V_FILEFOUND bit to indicate that at least one file
 ;		has been found - used to return FNF vs. NMF.
 ;
 ;	V045	jak0025		J A Krycka	28-SEP-1979	17:00
 ;		add FWA$V_DEV_UNDER in conjunction with effort to
 ;		modify expanded and resultant name string processing to prefix
 ;		an underscore to node and device names that have been subject
 ;		to logical name translation.
 ;
 ;	V044			Tim Halvorsen	12-SEP-1979
 ;		add IFB$V_SEARCH bit to mark ifabs left during searches.
 ;
 ;	V043			Tim Halvorsen	11-SEP-1979
 ;		overlay the fib buffer with the node descriptors to reduce
 ;		the total space used by fwa.  increase the size of the file
 ;		name and type buffers due to the new maximum sizes which can
 ;		occur as a result of wild characters (i.e. *a*b*c*d*e etc).
 ;
 ;	V042	jak0023		J A Krycka	27-AUG-1979	18:00
 ;		move FWA$T_NODEBUF to NWA$T_NODEBUF and add FWA$Q_DIR1 thru
 ;		FWA$Q_DIR8 in conjunction with effort in RM0XPFN to allow
 ;		multiple node specs in a file specification.
 ;
 ;	v041	cds0022		C Saether	26-july-79	22:45
 ;		add IFB$V_SEQFIL to bookkeeping bits.
 ;
 ;	V040	cds0000		C Saether	16-JAN-1979	14:00
 ;		remove definition of lockabove from srchflags in irab
 ;		and add abovelckd to bookeeping bits
 ;
 ;	V039	wsk0000		W S Koenig	10-JAN-1979	1:25
 ;		fix problem w/ IDX_PTR overlapping w/ AS_DEV longwords
 ;
 ;	V038	jak0017		J A Krycka	28-DEC-1978	14:30
 ;		make IFB$L_NWA_PTR and IFB$L_FRB_PTR separate locations so that
 ;		networking and file sharing do not interfere with each other.
 ;
 ;	V037	ran0003		R A Newell	20-DEC-1978	17:35
 ;		file sharing and isam changes.
 ;
 ;	V036	jak0007		J A Krycka	17-DEC-1978	19:00
 ;		change values of FWA$C_MAXNODE and FWA$C_NODBUFSIZ.
 ;
 ;	V035	jak0006		J A Krycka	21-NOV-1978	16:40
 ;		add FWA$V_ACCSTR definition.
 ;
 ;	V034	ran0002		R A Newell	1-NOV-1978	09:49
 ;		RMS32 isam modifications.  additions of isam fields, take out
 ;		NWA, add PLG_VER, change ASB size, define PTR_VBN, update,
 ;		UPD_NRP, RFA_VBN, and RFA_ID fields.
 ;
 ;++
 
 ;
 ;	ifab field definitions
 ;
 ;  there is one ifab (internal file access block) per open file
 ;
 	.MACRO	$IFBDEF,$GBL

 	$DEFINI	IFB,$GBL


 ;+++++*****
 ;  the fields thru last_fab inclusive are common between the ifab and irab
 ;
 				 		; device characteristic and bookkeeping bit vectors
						; bookkeeping bits start in longword 2
					; (but have definitions that allow them to
					;  be referenced from the start of the ifab)
					;++
					;  the following bits are defined in
					;  common with the irab
					;
 $EQU	IFB$V_BUSY	32		; stream busy
 $EQU	IFB$V_EOF	33		; file positioned at eof
 $EQU	IFB$V_PPF_IMAGE	34		; flag for indirect processing of process-
					; permanent files (restricts allowable operations)
 $EQU	IFB$V_ASYNC	35		; async i/o flag (must be zero for ifab)
 $EQU	IFB$V_ASYNCWAIT	36		; wait on async i/o (must be zero for ifab)
					;--
					;
					;  ifab specific bits
					;
 $EQU	IFB$V_ACCESSED	37		; file is accessed
 $EQU	IFB$V_ANSI_D	38		; ansi d variable records
 $EQU	IFB$V_RWC	39		; copy of fop bit from open
 $EQU	IFB$V_DMO	40		; copy of fop bit from open
 $EQU	IFB$V_SPL	41		; copy of fop bit from open
 $EQU	IFB$V_SCF	42		; copy of fop bit from open
 $EQU	IFB$V_DLT	43		; copy of fop bit from open
 $EQU	IFB$V_DFW	44		; deferred write (copy of fop bit from $open)
 $EQU	IFB$V_SQO	45		; sequential operations only
 $EQU	IFB$V_PPF_INPUT	46		; this is command 'input' stream
 $EQU	IFB$V_NFS	47		; non-file structured flag
 $EQU	IFB$V_WRTACC	48		; logical or of fac bits:
					;   put, upd, del, trn
 $EQU	IFB$V_MSE	49		; multi-streams enabled
 $EQU	IFB$V_CREATE	50		; set if doing create (may be "create if")
 $EQU	IFB$V_NORECLK	51		; record locking not required
					; (i.e., no shared access or multi-stream)
 $EQU	IFB$V_RW_ATTR	52		; set if file attributes must be re-written
 $EQU	IFB$V_TMP	53		; temporary file (i.e., no directory entry)
 $EQU	IFB$V_TEF	54		; truncate at eof due to large auto extend
 $EQU	IFB$V_SIFB_OWND	55		; sifab owned by internal frb
 $EQU	IFB$V_SEQFIL	56		; this is really a sequential file being shared
 $EQU	IFB$V_SEARCH	57		; search ifab - left during wildcard operations
 $EQU	IFB$V_RMS_STALL	58		; RMS is stalled on this file operation
						; spare
 $EQU	IFB$V_NWA	60		; network work area control block present
 $EQU	IFB$V_DAP_OPEN	61		; open/create function was performed via dap
 $EQU	IFB$V_DAP	62		; data access protocol transmission
 $EQU	IFB$V_NSP	63		; network services protocol transmission
 			; (for primary device - bit encoding same as for fab)
 $DEF	IFB$L_PRIM_DEV	.BLKL		; device characteristics bits
 ;
 $DEF	IFB$L_BKPBITS	.BLKL		; bookkeeping bits
 $EQU	IFB$C_BID	11		; ifab id code
 $DEF	IFB$B_BID	.BLKB		; block id
 $DEF	IFB$B_BLN	.BLKB		; block length in longwords
 $DEF	IFB$B_MODE	.BLKB		; caller's mode
 $DEF	IFB$B_EFN	.BLKB		; event flag used for synchronous qio
 $DEF	IFB$L_IOS			; internal i/o status block
 $DEF	IFB$L_BWB	.BLKB	2	; bucket wait block for inter stream waiting
 $DEF	IFB$W_IOS2	.BLKW		; high word of io status block
 $DEF	IFB$L_IOS4	.BLKL		; 2nd longword of io status block
 $DEF	IFB$L_ASBADDR	.BLKL		; address of asynchronous context block
 $DEF	IFB$L_ARGLST	.BLKL		; user call parameters addr
 $DEF	IFB$L_IRAB_LNK	.BLKL		; pointer to irab(s)
 $DEF	IFB$W_CHNL	.BLKW		; i/o channel number
 $EQU	IFB$V_PUT	0		; (same as in fab's fac field)
 $EQU	IFB$M_PUT	1
 $EQU	IFB$V_GET	1
 $EQU	IFB$M_GET	2
 $EQU	IFB$V_DEL	2
 $EQU	IFB$M_DEL	4
 $EQU	IFB$V_UPD	3
 $EQU	IFB$M_UPD	8
 $EQU	IFB$V_TRN	4
 $EQU	IFB$M_TRN	16
 $EQU	IFB$V_BIO	5
 $EQU	IFB$M_BIO	32
 $EQU	IFB$V_BRO	6
 $EQU	IFB$M_BRO	64
 $EQU	IFB$V_EXE	7
 $EQU	IFB$M_EXE	128
 			; note: if both bio and bro set, implies block i/o
 			;	access only allowed for this connect, resets
 			;	to bro on disconnect (seq. file org. only).
 			;
 $DEF	IFB$B_FAC	.BLKB		; file access
 $DEF	IFB$B_ORGCASE	.BLKB		; copy of org for case dispatching
 ;-----*****
 $DEF	IFB$L_LAST_FAB	.BLKL		; address of fab for last operation
 $DEF	IFB$L_NWA_PTR	.BLKL		; pointer to network work area control block
 $DEF	IFB$L_FRB_PTR	.BLKL		; pointer to "shared" file resource block
 $DEF	IFB$L_BDB_FLNK	.BLKL		; pointer to bdb(s)
 $DEF	IFB$L_BDB_BLNK	.BLKL		; bdb backward link
 $DEF	IFB$W_DEVBUFSIZ	.BLKW		; device default (or bls if mt) buff size
 ;
 ;+++++*****
 ;
 ;  the following fields must remain as is since
 ;  they correspond to the rms attributes stored
 ;  in the file header
 ;
 $DEF	IFB$W_RTDEQ	.BLKW		; run-time default extend quantity
 $EQU	IFB$V_RFM	0		; record format
 $EQU	IFB$S_RFM	4
					; (n.b. constant values defined
					;  in rfm field of fab)
 $EQU	IFB$V_ORG	4		; file organization
 $EQU	IFB$S_ORG	4
 $EQU	IFB$C_SEQ	0		; sequential
 $EQU	IFB$C_REL	1		; relative
 $EQU	IFB$C_IDX	2		; indexed
 $EQU	IFB$C_DIR	3		; direct
 $EQU	IFB$C_MAXORG	2		; release 1.5 maximum
 $DEF	IFB$B_RFMORG	.BLKB		; organization and record format
 			; (n.b. bit offsets defined in
 			;  rat field of fab)
 $DEF	IFB$B_RAT	.BLKB		; record attributes
 			; (or fixed record length)
 $DEF	IFB$W_LRL	.BLKW		; longest record's length
 			; (note: reversed on disk!)
 $DEF	IFB$L_HBK	.BLKL		; hi vbn allocated
 			; (note: reversed on disk!)
 $DEF	IFB$L_EBK			; eof vbn
 $DEF	IFB$W_EBK0	.BLKW
 $DEF	IFB$W_EBK2	.BLKW
 $DEF	IFB$W_FFB	.BLKW		; first free byte in eof block
 $DEF	IFB$B_BKS	.BLKB		; bucket size (# vbns)
 $DEF	IFB$B_FSZ	.BLKB		; record header size for vfc
 $DEF	IFB$W_MRS	.BLKW		; max record size allowable
 $DEF	IFB$W_DEQ	.BLKW		; default extend quantity
 $DEF	IFB$W_GBC	.BLKW		; global buffer count
 $DEF	IFB$C_FHAEND
 $DEF	IFB$K_FHAEND			; end of file header attributes
 $DEF	IFB$B_DRT_REHIT	.BLKB		; hit count for local dirty buffers.
 ;-----*****
 ;++
 ;
 $DEF	IFB$B_GBL_REHIT	.BLKB		; rehit count for gbl buffers.
 $DEF	IFB$L_NRP_LIST			; ptr to nrp list for idx files, temp for other orgs
 			; (used by $search)
 $DEF	IFB$L_RNS_LEN			; resultant name string length
 $DEF	IFB$L_LOCK_BDB	.BLKL		; lock bdb address (used by $extend for rel. file)
 $DEF	IFB$L_SFSB_PTR	.BLKL		; pointer to shared file synchronization block
 $DEF	IFB$W_AVLCL	.BLKW		; Local buffers available.
 $DEF	IFB$W_AVGBPB	.BLKW		; Gbl ptr blocks available.
 $DEF	IFB$L_GBH_PTR	.BLKL		; Pointer to global header.
 $DEF	IFB$L_AS_DEV	.BLKL		; assigned device characteristics
 				 		; (spare)
 			.BLKW	1
 $DEF	IFB$W_ASDEVBSIZ	.BLKW		; assigned device buffer size
 $DEF	IFB$L_BLBFLNK	.BLKL		; Forward link to BLB chain.
 $DEF	IFB$L_BLBBLNK	.BLKL		; Back link to BLB chain.
 $DEF	IFB$C_BLN_SEQ
 			
 ;--
 ;
 ;  organization-dependent fields
 ;
 ;  the following fields are used differently
 ;  depending upon the file's organization
 ;
 ;++
 ;
 ;  relative org specific fields
 ;
 $DEF	IFB$K_BLN_SEQ
 	. = 116
 $DEF	IFB$L_MRN	.BLKL		; (rel) max record number
 $DEF	IFB$L_DVBN	.BLKL		; (rel) first data bucket vbn
 $DEF	IFB$C_BLN_REL
 ;--

 ;++
 ;
 ;  indexed org specific fields
 ;
 $DEF	IFB$K_BLN_REL
 	. = 116
 $DEF	IFB$L_IDX_PTR	.BLKL		; (idx) pointer to primary key index descriptor
 $DEF	IFB$B_AVBN	.BLKB		; (idx) vbn of 1st area descriptor
 $DEF	IFB$B_AMAX	.BLKB		; (idx) total number of area descriptors
 $DEF	IFB$B_NUM_KEYS	.BLKB		; (idx) # of keys in file
 $DEF	IFB$B_UBUFSZ	.BLKB		; (idx) update buffer size for keys
 $DEF	IFB$W_KBUFSZ	.BLKW		; (idx) key buffer size
 $DEF	IFB$B_EXTRABUF	.BLKB		; (idx) number of extra buffers for 'cache'ing
 $DEF	IFB$B_PLG_VER	.BLKB		; (idx) prologue version number
 $DEF	IFB$C_BLN_IDX
 ;--
 $DEF	IFB$K_BLN_IDX
 $DEF	IFB$C_BLN

 $DEF	IFB$K_BLN			; ifab length
 	$DEFEND	IFB,$GBL,DEF

 	.ENDM	$IFBDEF
 
 ;
 ;	 irab field definitions
 ;
 ;  there is 1 irab per connected record access stream
 ;
 	.MACRO	$IRBDEF,$GBL	; internal rab

 	$DEFINI	IRB,$GBL


 ;+++++*****
 ;
 ;  the fields thru last_rab inclusive are common between the irab and ifab
 ;
 				 		; used to get bookkeeping bit definitions
 			; to apply from start of irab
						; bookkeeping bits start in longword 2
					;++
					;
					;  the following bits are defined in common
					;  with the ifab
					;
 $EQU	IRB$V_BUSY	32		; file busy
 $EQU	IRB$V_EOF	33		; stream positioned at eof
 $EQU	IRB$V_PPF_IMAGE	34		; flag for indirect processing of process-
					; permanent file
 $EQU	IRB$V_ASYNC	35		; asynchronous i/o request
 $EQU	IRB$V_ASYNCWAIT	36		; $wait issued for asynchronous i/o request
					;--
					;
					;   irab specific bits
					;
 $EQU	IRB$V_FIND_LAST	37		; last operation was a find
 $EQU	IRB$V_PUTS_LAST	38		; last operation was a put sequential
 $EQU	IRB$V_BIO_LAST	39		; this/last operation is/was a block i/o operation
					; note: this bit is set only if mixed block and record
					;       operations (bro access).  after call to rm$rset
					;	refers to the current operation and bro_sw gives
					;	type of last operation.
 $EQU	IRB$V_BRO_SW	40		; switched from record operation to block i/o operation
 $EQU	IRB$V_FIND	41		; operation is a find
 $EQU	IRB$V_RAHWBH	42		; read ahead or write behind processing
 $EQU	IRB$V_SKIP_NEXT	43		; skip to next record flag for index fo
 $EQU	IRB$V_DUP	44		; duplicate records seen
 $EQU	IRB$V_UNLOCK_RP	45		; release lock on current (rp) record
 $EQU	IRB$V_PPF_EOF	46		; give one-shot rms$_eof error on sys$input
 $EQU	IRB$V_PPF_SKIP	47		; skip sys$input record ($deck), redoing $get
					; or $find on next record
 $EQU	IRB$V_PPF_FNDSV	48		; save value for find bit when ppf_skip set
 $EQU	IRB$V_IDX_ERR	49		; index update error occurred
 $EQU	IRB$V_RRV_ERR	50		; rrv update error occurred
 $EQU	IRB$V_UPDATE	51		; operation is an update (indexed)
 $EQU	IRB$V_UPD_NRP	52		; an nrp update is necessary (indexed)
 $EQU	IRB$V_ABOVELCKD	53		; level above was locked by search_tree
 $EQU	IRB$V_GBLBUFF	54		; global buffers are in use.
						; spare bits
 $EQU	IRB$V_RMS_STALL	58		; RMS is stalled on this record operation
						; spare bits
 $EQU	IRB$V_DAP_CONN	62		; connect function was performed via dap
						; spare bit
 ;
 ;  the following are alternate definitions for alternate
 ;  (non-conflicting) use of the above bits
 ;
						; start re-use with find
 $EQU	IRB$V_WRITE	41		; operation is a write
 $DEF	IRB$L_IFAB_LNK	.BLKL		; pointer to ifab
 ;
 $DEF	IRB$L_BKPBITS	.BLKL		; bookkeeping status bits
 $EQU	IRB$C_BID	10		; irab code
 $DEF	IRB$B_BID	.BLKB		; block id
 $DEF	IRB$B_BLN	.BLKB		; block length in longwords
 $DEF	IRB$B_MODE	.BLKB		; caller's mode
 $DEF	IRB$B_EFN	.BLKB		; event flag for synchronous io
 $DEF	IRB$L_IOS			; internal i/o status block
 $DEF	IRB$L_BWB	.BLKB	2	; bucket wait block for inter stream locking
 $DEF	IRB$W_IOS2	.BLKW		; high word of io status block
 $DEF	IRB$L_IOS4	.BLKL		; io status block (2nd longword)
 $DEF	IRB$L_ASBADDR	.BLKL		; address of permanent asynchronous context block
 			; if async, points to copy at head
 			; of async context block
 $DEF	IRB$L_ARGLST	.BLKL		; user arg list address
 $DEF	IRB$L_IRAB_LNK	.BLKL		; pointer to next irab
 $DEF	IRB$L_CURBDB	.BLKL		; current bdb address
 ;-----*****
 $DEF	IRB$L_LAST_RAB	.BLKL		; address of rab for last operation
 $DEF	IRB$L_RLB_LNK	.BLKL		; pointer to RLBs
 $DEF	IRB$L_NXTBDB	.BLKL		; next bdb address
 $DEF	IRB$L_NRP_PTR			; pointer to cell in nrp list  (indexed)
 $DEF	IRB$L_NRP_VBN			; next record pointer  (relative)
 $DEF	IRB$L_NRP	.BLKL		; next record pointer (relative record #)
 $DEF	IRB$L_NRP_OFF			; next record pointer offset (relative)
 $DEF	IRB$W_NRP_OFF			;     "
 $DEF	IRB$L_CURVBN			; vbn of current record (relative)
 $DEF	IRB$B_CACHEFLGS	.BLKB		; cacheflags for calls to getbkt,cache, etc. (indexed)
 $DEF	IRB$B_NRP_KREF	.BLKB		; key of reference  (indexed)
 $DEF	IRB$B_RP_KREF	.BLKB		; key of reference for rp  (indexed)
 $EQU	IRB$V_BKT_NO_LO	0		; low bit of bucket number processing
 $EQU	IRB$M_BKT_NO_LO	1
 $EQU	IRB$V_NEW_BKTS	1		; number of new buckets (0-3)
 $EQU	IRB$M_NEW_BKTS	6
 $EQU	IRB$S_NEW_BKTS	2
 $EQU	IRB$V_REC_W_LO	3		; if splitting at pos_insert than rec goes w/ lo
 $EQU	IRB$M_REC_W_LO	8
 $EQU	IRB$V_CONT_BKT	4		; middle bucket is a continuation bkt
 $EQU	IRB$M_CONT_BKT	16
 $EQU	IRB$V_CONT_R	5		; right bucket is a continuation bkt
 $EQU	IRB$M_CONT_R	32
 $EQU	IRB$V_EMPTY_BKT	6		; bucket contains no data records
 $EQU	IRB$M_EMPTY_BKT	64
 $EQU	IRB$V_DUPS_SEEN	7		; dups seen on scan of bucket, any key
 $EQU	IRB$M_DUPS_SEEN	128
 $EQU	IRB$V_BKT_NO	0
 $EQU	IRB$M_BKT_NO	3
 $EQU	IRB$S_BKT_NO	2
 $EQU	IRB$V_BIG_SPLIT	2
 $EQU	IRB$M_BIG_SPLIT	4
 $EQU	IRB$V_SPL_IDX	0		; split up new index record and swing pointer
 $EQU	IRB$M_SPL_IDX	1
 $EQU	IRB$V_EMPT_SEEN	1		; empty bucket passed over on posinsert
 $EQU	IRB$M_EMPT_SEEN	2
 $DEF	IRB$B_SPL_BITS	.BLKB		; bits for splitting  (indexed)
 $DEF	IRB$L_RP			; record pointer  (relative record #)
 $DEF	IRB$L_RP_VBN			; record pointer  (relative)
 $DEF	IRB$W_POS_INS	.BLKW		; offset for position for insert for put  (indexed)
 $DEF	IRB$W_SPLIT	.BLKW		; first split point  (indexed)
 $DEF	IRB$L_RP_OFF			; record pointer offset
 $DEF	IRB$L_LST_REC			; last record address  (indexed)
 $DEF	IRB$L_PTR_VBN			; pointer vbn used by find_by_rrv (indexed)
 $DEF	IRB$W_RP_OFF			; record pointer offset
 $DEF	IRB$W_SPLIT_1	.BLKW		; second split point -- 3-bkt split  (indexed)
 $DEF	IRB$W_SPLIT_2	.BLKW		; third split point -- 4-bkt split  (indexed)
 $DEF	IRB$L_OWNER_ID			; owner id used for record locks
 $DEF	IRB$W_OWN_ID	.BLKW		; index part of process id (pid)
 $DEF	IRB$W_OWN_ISI			; isi value for this irab
 $DEF	IRB$B_PPF_ISI	.BLKB		; isi value for this process-permanent irab
 			.BLKB	1
 $DEF	IRB$B_BCNT	.BLKB		; i/o buffer count
 $DEF	IRB$B_MBC	.BLKB		; multi-block count
 $DEF	IRB$W_RSZ	.BLKW		; record size from user
 ;++
 ;
 ;  start of organization dependent fields
 ;
 			
 ;++
 ;
 ; used by sequential and relative files
 ;
 $DEF	IRB$L_RBF	.BLKL		; user record buffer address
 				 		; pad so longwords align
 			.BLKW	1

 			
 ;++
 ;
 ;  sequential org specific fields
 ;
 $DEF	IRB$W_CSIZ	.BLKW		; current record size (seq)
 $DEF	IRB$L_TEMP0
 $DEF	IRB$W_ROVHDSZ			; overhead size for record
 $DEF	IRB$B_PRE_CCTL	.BLKB		; 'pre' carriage control
 $DEF	IRB$B_POST_CCTL	.BLKB		; 'post' carriage control
 $DEF	IRB$W_RTOTLSZ	.BLKW		; total size for record
 $DEF	IRB$L_TEMP1
 $DEF	IRB$B_NVBNS	.BLKB		; number of vbns transferred (nxtblk1)
 			.BLKB	3
 $DEF	IRB$C_BLN_SEQ
 ;++
 ;
 ;  relative org specific fields
 ;
 $DEF	IRB$K_BLN_SEQ
 	. = 78

 			.BLKB	2
 $DEF	IRB$C_BLN_REL
 ;
 ; indexed org specific fields
 ;
 $DEF	IRB$K_BLN_REL
 	. = 72
 			.BLKB	4
 $DEF	IRB$L_KEYBUF	.BLKL		; address of internal key buffer & update buffer
 $DEF	IRB$L_UPDBUF	.BLKL		; address of internal update buffer
 $DEF	IRB$L_RECBUF	.BLKL		; address of internal record buffer (plg 3)
 $DEF	IRB$L_RFA_VBN			; rfa vbn for search nrp data
 $DEF	IRB$L_UPD_BDB			; save current bdb during insert operation
 $DEF	IRB$L_LAST_VBN	.BLKL		; last vbn at data level for update
 $DEF	IRB$W_RFA_ID			; save id for search nrp data (plg 3)
 $DEF	IRB$W_LAST_ID	.BLKW		; id for udr during update (plg 3)
 $DEF	IRB$W_SAVE_POS	.BLKW		; saved duplicate position for search nrp data
 $DEF	IRB$L_LOCK_BDB	.BLKL		; lock bdb addr of level below on splits
 $DEF	IRB$L_VBN_LEFT			; left vbn of split
 $DEF	IRB$L_MIDX_TMP1	.BLKL		; temporary one for make index
 $DEF	IRB$L_VBN_RIGHT			; right vbn of split
 $DEF	IRB$L_MIDX_TMP2	.BLKL		; temporary two for make index
 $DEF	IRB$L_VBN_MID			; middle vbn of split
 $DEF	IRB$L_MIDX_TMP3			; temporary three for make index
 $DEF	IRB$L_NEXT_DOWN	.BLKL		; used by search_tree
 $DEF	IRB$B_STOPLEVEL	.BLKB		; level to stop at on tree search
 $EQU	IRB$V_POSINSERT	0		; position for insert
 $EQU	IRB$M_POSINSERT	1
 $EQU	IRB$V_SRCHGT	1		; approximate search gt
 $EQU	IRB$M_SRCHGT	2
 $EQU	IRB$V_POSDELETE	2		; position for delete
 $EQU	IRB$M_POSDELETE	4
 $EQU	IRB$V_NEW_IDX	3		; need to read in new idx dsc from file
 $EQU	IRB$M_NEW_IDX	8
 $EQU	IRB$V_SRCHGE	4		; approximate search ge
 $EQU	IRB$M_SRCHGE	16
 $EQU	IRB$V_NORLS_RNF	5		; don't release bkt on rnf error, if set
 $EQU	IRB$M_NORLS_RNF	32
 $EQU	IRB$V_FIRST_TIM	6		; flag to indicate 1st time for seq. processing
 $EQU	IRB$M_FIRST_TIM	64
 $EQU	IRB$V_PRM	7		; flag to indicate that the permanence bit in the bdb
 $EQU	IRB$M_PRM	128
					;  should be set
 $DEF	IRB$B_SRCHFLAGS	.BLKB		; search flags
 $DEF	IRB$B_KEYSZ	.BLKB		; size of key in keybuffer #2
 			;  differs from the record it is compared against(plg3)
 $DEF	IRB$B_DIFF_CHAR	.BLKB		; number of the character in the search key which
 $DEF	IRB$L_REC_COUNT	.BLKL		; number of current record in this bucket (plg 3)
 $DEF	IRB$L_LST_NCMP	.BLKL		; address of last key with zero front compression (plg 3)
 			;  when splitting indexes and SIDRs
 $DEF	IRB$L_SPL_COUNT	.BLKL		; number of the first record to be moved into new bucket
 $DEF	IRB$W_NID_RIGHT	.BLKW		; Next record ID of the right bucket
 $DEF	IRB$W_NID_MID	.BLKW		; Next record ID of the middle bucket
 $DEF	IRB$W_RFA_NID	.BLKW		; Next record ID of the RFA bucket
 				 		; Spare
 			.BLKW	1
 $DEF	IRB$C_BLN_IDX

 $DEF	IRB$K_BLN_IDX
 	$DEFEND	IRB,$GBL,DEF

 	.ENDM	$IRBDEF
 
 ;
 ;  asynchronous operations require that an irab have
 ;  an asynchronous context block (asb)
 ;  the asb is pointed to by the arglst field of the
 ;  irab if the async bookkeeping bit is set
 ;
 ;  the first four longwords are used to save the
 ;  caller's argument list
 ;
 	.MACRO	$ASBDEF,$GBL

 	$DEFINI	ASB,$GBL


 			; value will be 0, 1, 2, or 3
 $DEF	ASB$B_ARGCNT	.BLKB		; argument count
 $DEF	ASB$B_BLN	.BLKB		; block length in longwords
 $DEF	ASB$B_STKSIZ	.BLKB		; size of saved stack in bytes
 				 		; spare
 			.BLKB	1
 $DEF	ASB$L_FABRAB	.BLKL		; fab or rab address
 $DEF	ASB$L_ERR	.BLKL		; err routine addr
 $DEF	ASB$L_SUC	.BLKL		; suc routine addr
 $EQU	ASB$S_REGS	160
 			; (regs 6,7,8,10,11 - r4,r5 saved on stack)
 $DEF	ASB$L_REGS	.BLKL	40	; work space for register and stack save
 $DEF	ASB$C_BLN_FAB
 $DEF	ASB$K_BLN_FAB			; block length for fab-related operations
 $DEF	ASB$C_BLN_SEQ
 				 		; additional space for relative org
 $DEF	ASB$K_BLN_SEQ	.BLKL		; block length for seq org irab operations
 $DEF	ASB$C_BLN_REL
 				 		; additional space for indexed org
 $DEF	ASB$K_BLN_REL	.BLKL	20	; block length for rel org irab operations
 $DEF	ASB$C_BLN_IDX

 $DEF	ASB$K_BLN_IDX
 	$DEFEND	ASB,$GBL,DEF

 	.ENDM	$ASBDEF
 
 ;
 ;	 file work area definitions
 ;
 ;  the file work area is used for expanding the file
 ;  name string and setting up the various parameter
 ;  blocks for interfacing with f11acp
 ;
 	.MACRO	$FWADEF,$GBL

 	$DEFINI	FWA,$GBL


 $EQU	FWA$S_FLAGS	8
 $EQU	FWA$V_DUPOK	0		; discard duplicate element
 $EQU	FWA$M_DUPOK	1
 $EQU	FWA$V_NAMEFLG	1		; name seen this parse
 $EQU	FWA$M_NAMEFLG	2
 $EQU	FWA$V_TYPEFLG	2		; type seen this parse
 $EQU	FWA$M_TYPEFLG	4
 $EQU	FWA$V_RLF_PASS	3		; set if applying related file defaults
 $EQU	FWA$M_RLF_PASS	8
 $EQU	FWA$V_FNA_PASS	4		; set if primary name string parse pass
 $EQU	FWA$M_FNA_PASS	16
 $EQU	FWA$V_NAM_DVI	5		; set if open by name block
 $EQU	FWA$M_NAM_DVI	32
 $EQU	FWA$V_CUR_VER	6		; set if cur file has wc ver
						; spare
						; start defs at byte 1
						; must be zero
 $EQU	FWA$V_VERSION	11		; set if version seen
 $EQU	FWA$M_VERSION	<^X800>
 $EQU	FWA$V_TYPE	12		; set if type seen
 $EQU	FWA$M_TYPE	<^X1000>
 $EQU	FWA$V_NAME	13		; set if name seen
 $EQU	FWA$M_NAME	<^X2000>
 $EQU	FWA$V_DIR	14		; set if directory spec seen
 $EQU	FWA$M_DIR	<^X4000>
 $EQU	FWA$V_DEVICE	15		; set if device seen
 $EQU	FWA$M_DEVICE	<^X8000>
					; (end of fldflgs byte)
 $EQU	FWA$V_EXP_VER	16		; set if explicit version
 $EQU	FWA$M_EXP_VER	<^X10000>
 $EQU	FWA$V_EXP_TYPE	17		; set if explicit type
 $EQU	FWA$M_EXP_TYPE	<^X20000>
 $EQU	FWA$V_EXP_NAME	18		; set if explicit name
 $EQU	FWA$M_EXP_NAME	<^X40000>
 $EQU	FWA$V_WC_VER	19		; set if wildcard (*) version
 $EQU	FWA$V_WC_TYPE	20		;          "		type
 $EQU	FWA$V_WC_NAME	21		;	   "		name
 $EQU	FWA$V_EXP_DIR	22		; set if explicit directory
 $EQU	FWA$M_EXP_DIR	<^X400000>
 $EQU	FWA$V_EXP_DEV	23		; set if explicit device
 $EQU	FWA$M_EXP_DEV	<^X800000>
					; (end of wildflgs byte)
 $EQU	FWA$V_WILDCARD	24		; set if any wildcard seen
 $EQU	FWA$V_NODE	25		; set if node name seen
 $EQU	FWA$V_QUOTED	26		; set is quoted string seen
					; (valid only if node set and no fldflgs)
 $EQU	FWA$V_GRPMBR	27		; set if directory in [grp,mbr] format
 $EQU	FWA$V_WILD_DIR	28		; inclusive or of directory wild cards
 $EQU	FWA$V_DIR_LVLS	29		; # of directory sublevels (0 = ufd only)
 $EQU	FWA$S_DIR_LVLS	3
					; (end of parseflgs byte)
						; continue bit definitions of 2nd longword
 $EQU	FWA$V_DIR1	32		; ufd level directory or group seen
 $EQU	FWA$V_DIR2	33		; sfd level 1 directory or member seen
						; additional sub directory level flags
					; (end of dirflgs byte)
 $EQU	FWA$V_WILD_UFD	40		; the dir1 spec was a wild card
 $EQU	FWA$V_WILD_SFD1	41		; the dir2 spec was a wild card
						; additional sub directory wildcard flags
					; (end of dirwcflgs byte)
 $EQU	FWA$V_LOGNAME	48		; a logical name has been seen this pass
					; (note: this byte is saved as context
					; when processing [.dir-list] format)
 $EQU	FWA$V_OBJTYPE	49		; set if quoted string is of the
					; "objecttype=..." form
					; (valid only if quoted set)
 $EQU	FWA$V_NETSTR	50		; set if quoted string is of the
					; "objecttype=taskname/..." form
					; (valid only if quoted and objtype set)
 $EQU	FWA$V_DEV_UNDER	51		; device name was prefixed with an underscore
 $EQU	FWA$V_FILEFOUND	52		; true if at least one file found by parse/search
 $EQU	FWA$V_REMRESULT	53		; use resultant string returned by fal
 $EQU	FWA$V_DFLT_MFD	54		; default MFD string inserted, due to [-]
 $EQU	FWA$V_ROOT_DIR	55		; root directory present due to concealed device
					; (end of lnflg byte)
						; alternate definition for dir1 and dir2
 $EQU	FWA$V_WILD_GRP	40		; the grp spec contained a wild card
 $EQU	FWA$V_WILD_MBR	41		; the mbr spec contained a wild card
 $DEF	FWA$Q_FLAGS			; various parse status flags
 $DEF	FWA$B_PASSFLGS	.BLKB		; flags for pass only
 $DEF	FWA$B_FLDFLGS	.BLKB		; flags for fields seen
 $DEF	FWA$B_WILDFLGS	.BLKB		; flags for wild cards
 $DEF	FWA$B_PARSEFLGS	.BLKB		; flags for parse results
 $DEF	FWA$B_DIRFLGS	.BLKB		; flags primarily for directory spec
 $DEF	FWA$B_DIRWCFLGS	.BLKB		; directory wild flags
 $DEF	FWA$B_LNFLG	.BLKB		; logical name flag byte
 			; (note: this byte must follow the lnflg byte)
 $EQU	FWA$C_ALL	<<FWA$M_DEVICE!FWA$M_DIR!FWA$M_NAME!FWA$M_TYPE!FWA$M_VERSION>@-8>		
 			; value for all filename elements except node
 ;
 $DEF	FWA$B_DIRTERM	.BLKB		; directory spec terminator (']' or '>')
 $DEF	FWA$L_ESCSTRING			; escape equivalence string
 			; seen, zero otherwise
 $DEF	FWA$B_ESCFLG	.BLKB		; set to the char <esc> if an escape string
 			
 $DEF	FWA$B_ESCTYP	.BLKB		; escape 'type' byte
 ;
 $DEF	FWA$W_ESCIFI	.BLKW		; escape ifi value
 	. = 9
 			; temporary usage of the escifi field
 			; for logical name translation
 			.BLKB	1
 $DEF	FWA$B_XLTMODE	.BLKB		; mode of equivalence string
 $DEF	FWA$B_XLTTBL	.BLKB		; table of equivalence string
 $EQU	FWA$S_XLTBUF1	8
 $DEF	FWA$Q_XLTBUF1			; primary translation buffer discriptor
 $EQU	FWA$S_FIB	8
 $DEF	FWA$Q_FIB	.BLKQ		; re-use for fib descriptor
 			; (0 = buf2 in use, -1 = buf1 in use)
 $DEF	FWA$L_BUFFLG			; flag for which buffer in use
 			; since bufflg never used in search-type fwa's
 $DEF	FWA$L_DIRBDB	.BLKL		; re-use as address of directory file bdb
 $DEF	FWA$L_XLTSIZ			; length of equivalence string
 			; after exit from xpfn
 $DEF	FWA$W_FNAMSIZ	.BLKW		; file name size (without type and version)
 			.BLKW	1
 $EQU	FWA$S_LOGNAME	8
 $DEF	FWA$Q_LOGNAME			; logical name descriptor
 $DEF	FWA$L_UIC			; file owner uic
 $DEF	FWA$L_LOOKUP	.BLKL		; address of new directory cache node
 $DEF	FWA$L_DEVNODADR			; address of device directory cache node
 $DEF	FWA$W_PRO	.BLKW		; file protection word
 			.BLKW	1
 $EQU	FWA$S_XLTBUF2	8
 $DEF	FWA$Q_XLTBUF2			; secondary translation buffer descriptor
 $EQU	FWA$S_DIR	8
 $DEF	FWA$Q_DIR	.BLKQ		; directory name scratch buffer
 $DEF	FWA$L_XLTCNT			; number of translations done
 $DEF	FWA$W_UCHAR	.BLKW		; reuse to receive user characteristics (long)word
 			.BLKW	1
 $DEF	FWA$B_DIRLEN	.BLKB		; overall directory spec length
 $DEF	FWA$B_SUBNODCNT	.BLKB		; number of secondary (sub) node specs found
 				 		; spare
 			.BLKB	2
 ;
 ;  descriptors for parsed filename elements
 ;
 ;******++++++
 ;  the following descriptors must be contiguous.
 $DEF	FWA$L_BUF_PTR	.BLKL		; address of temporary buffer
 $EQU	FWA$S_NODE	8
 				; (the associated buffer is nwa$t_nodebuf)
 $EQU	FWA$C_MAXNODNAM	6			; max node name size
 $EQU	FWA$C_MAXLNDNAM	15		; max logical node name size
 $EQU	FWA$C_MAXNODLST	127		; max node spec list size (concatenated node specs)
 $DEF	FWA$Q_NODE	.BLKQ		; node name (actually node spec list) descriptor
 $EQU	FWA$S_DEVICE	8
 $EQU	FWA$C_MAXDEVICE	63		; max device name size
 $DEF	FWA$Q_DEVICE	.BLKQ		; device name descriptor
 $EQU	FWA$S_DIR1	8
 $DEF	FWA$Q_DIR1	.BLKQ		; directory and subdirectory descriptors
 $EQU	FWA$S_DIR2	8
 $DEF	FWA$Q_DIR2	.BLKQ		; (note: only 1 and 2 explicitly named)
 				 			;
 			.BLKQ	1
 				 			;
 			.BLKQ	1
 				 			;
 			.BLKQ	1
 				 			;
 			.BLKQ	1
 				 			;
 			.BLKQ	1
 				 			;
 $EQU	FWA$C_MAXSUBDIR	7			; max number of sub directories
 $EQU	FWA$C_MAXDIRLEN	81		; max size of total directory spec
 			.BLKQ	1
 $EQU	FWA$S_NAME	8
 $EQU	FWA$C_MAXNAME	9			; max file name size
 $EQU	FWA$C_MTMAXNAME	36		; max file name size for ANSI-"a" name strings
 $EQU	FWA$C_MTLNONTAP	17		; length of file names on tape
 $DEF	FWA$Q_NAME	.BLKQ		; file name descriptor
 $EQU	FWA$S_TYPE	8
 $DEF	FWA$Q_TYPE			; file type descriptor
 $EQU	FWA$S_RNS	8
 $EQU	FWA$C_MAXTYPE	3			; max file type size
 $EQU	FWA$C_RNSBUFSIZ	20		; *unused in RMS* max resultant name string size
 			
 $DEF	FWA$Q_RNS	.BLKQ		; re-use as resultant name string descriptor
 $EQU	FWA$S_VERSION	8
 $EQU	FWA$C_MAXVER	6			; maximum version
 $DEF	FWA$Q_VERSION	.BLKQ		; file version descriptor
 $EQU	FWA$S_QUOTED	8
 				; (the associated buffer is nwa$t_quotedbuf)
 $EQU	FWA$C_MAXQUOTED	127		; max quoted string size
 			
 $DEF	FWA$Q_QUOTED	.BLKQ		; quoted string descriptor
 	. = 144
 			.BLKQ	1
 $EQU	FWA$S_STATBLK	10
 $EQU	FWA$C_STATBLK	10			; define length of statistics block
 $DEF	FWA$T_STATBLK			;
 $DEF	FWA$L_SBN	.BLKL		; starting lbn if contiguous
 $DEF	FWA$L_HBK	.BLKL		; high vbn
 			.BLKB	2
 				 			; spares (mapping over quoted)
 ;******------
 			.BLKB	6
 	. = 160 			; (note: this does not position properly
 				; unless 'f ,b,6' spares are defined above)
 ;******++++++
 ;  the following descriptors must be contiguous.
 			.BLKB	8
 $EQU	FWA$S_NODE1	8
 				; (the associated buffer is nwa$t_nodebuf)
 $DEF	FWA$Q_NODE1	.BLKQ		; primary node spec descriptor
 				 			; secondary (sub) node spec descriptors (1-7)
 			.BLKQ	1
 				 			; note: bytes 2-3 of each of these descriptors
 			.BLKQ	1
 				 			;	contains the flags word that is output
 			.BLKQ	1
 				 			;	from nxtfld subroutine in rm0xpfn
 			.BLKQ	1
 				 			; note:	fwa$q_node1 thru 'fwa$q_node8'
 			.BLKQ	1
 				 			;	describe the same string as does
 			.BLKQ	1
 				 			;	fwa$q_node
 $EQU	FWA$C_MAXSUBNOD	7			; max number of secondary (sub) node specs
 			
 ;******------
 			.BLKQ	1
 	. = 160 			; overlay with node descriptors
 			.BLKQ	1
 $EQU	FWA$S_FIBBUF	48
 $EQU	FWA$C_FIBLEN	48			; fib buffer size
 $DEF	FWA$T_FIBBUF	.BLKB	48	; fib buffer
 $EQU	FWA$S_RNM_FID	6
 $DEF	FWA$T_RNM_FID	.BLKB	6	; saved fid for rename directory check
 $EQU	FWA$S_MFD_FID	6
 $DEF	FWA$T_MFD_FID	.BLKB	6	; saved fid for root directory
 				 			; pad to same length as node descriptors
 			.BLKB	4
 	. = 224 			; end of overlay
 ;
 ;  directory name buffers
 ;
 			.BLKB	8
 $EQU	FWA$S_DIR1BUF	9
 $DEF	FWA$T_DIR1BUF	.BLKB	9	; ufd level (or group)
 $EQU	FWA$S_DIR2BUF	9
 $DEF	FWA$T_DIR2BUF	.BLKB	9	; 1st sfd level (or member)
 				 			; additional subdirectory levels
 $EQU	FWA$C_DIRBUFSIZ	9			; size of each directory buffer
 ;******++++++
 ;  the following buffers must be contiguous as eventually the
 ;  type and version are appended to the name string
 			.BLKB	54
 $EQU	FWA$S_NAMEBUF	36
 $EQU	FWA$C_NAMBUFSIZ	36			; file name buffer size
 $DEF	FWA$T_NAMEBUF	.BLKB	36	; file name buffer (also used for resultant name)
 $EQU	FWA$S_TYPEBUF	7
 $EQU	FWA$C_TYPBUFSIZ	7			; file type buffer size
 $DEF	FWA$T_TYPEBUF	.BLKB	7	; file type buffer
 $EQU	FWA$S_VERBUF	6
 $EQU	FWA$C_VERBUFSIZ	6			; file version buffer size
 ;******------
 $DEF	FWA$T_VERBUF	.BLKB	6	; file version buffer
 				; additional logical name translation
 $DEF	FWA$B_UNDERLINE	.BLKB		; single character '_' stored here to prevent
 $EQU	FWA$S_DEVICEBUF	63
 $EQU	FWA$C_DEVBUFSIZ	63		; device name buffer size
 $DEF	FWA$T_DEVICEBUF	.BLKB	63	; device name buffer
 $EQU	FWA$S_WILD	16
 $EQU	FWA$C_WILDSIZ	16			; scratch field size	
 $DEF	FWA$T_WILD	.BLKB	16	; scratch field used by RM0WILD
 $EQU	FWA$S_SHRFILDEV	16
 $DEF	FWA$T_SHRFILDEV	.BLKB	16	; shared file device id
 $EQU	FWA$S_ROOT_DIR	10
 $DEF	FWA$T_ROOT_DIR	.BLKB	10	; ASCIC root directory string
 $EQU	FWA$S_ATR_LIST	128
 $DEF	FWA$T_ATR_LIST			; attribute list work area
 $EQU	FWA$S_XLTBUFF1	64
 				; (also used for attribute list area in rm$access)
 $DEF	FWA$T_XLTBUFF1	.BLKB	16	; scratch translation buffer
 $EQU	FWA$S_DIB	112
 $DEF	FWA$T_DIB	.BLKB	48	; device information block
 $EQU	FWA$S_XLTBUFF2	64
 				; (also used for directory processing in rm$setdid
 				;  and attribute list area in rm$access)
 $EQU	FWA$C_XLTBUFSIZ	63		; scratch translation buffer size
 $DEF	FWA$T_XLTBUFF2	.BLKB	64	; scratch translation buffer
 $EQU	FWA$S_XLTBUFF3	64
 $DEF	FWA$T_XLTBUFF3	.BLKB	64	; scratch translation buffer 3!
 $DEF	FWA$C_BLN

 $DEF	FWA$K_BLN			; length of this control block
 	$DEFEND	FWA,$GBL,DEF

 	.ENDM	$FWADEF
 
 ;
 ;	 bdb field definitions
 ;
 ;  buffer descriptor block (bdb)
 ;
 ;  there is one bdb per i/o buffer
 ;  ( the i/o buffers exist in separate pages, page aligned)
 ;
 	.MACRO	$BDBDEF,$GBL

 	$DEFINI	BDB,$GBL


 $DEF	BDB$L_FLINK	.BLKL		; forward link
 $DEF	BDB$L_BLINK	.BLKL		; backward link
 $EQU	BDB$C_BID	12		; bdb id code
 $DEF	BDB$B_BID	.BLKB		; block id
 $DEF	BDB$B_BLN	.BLKB		; block length in longwords
 $EQU	BDB$V_VAL	0		; buffer contents valid
 $EQU	BDB$M_VAL	1
 $EQU	BDB$V_DRT	1		; buffer content dirty
 $EQU	BDB$M_DRT	2
 $EQU	BDB$V_IOP	2		; buffer has i/o in progress
 $EQU	BDB$M_IOP	4
 $EQU	BDB$V_PRM	3		; buffer has permanence factor
 $EQU	BDB$M_PRM	8
 $EQU	BDB$V_NOLOCATE	4		; buffer shared - no locate mode
 $EQU	BDB$M_NOLOCATE	16
					; (set/cleared by rm$cache)
 $EQU	BDB$V_WFO	5		; other streams awaiting
 $EQU	BDB$M_WFO	32
					; the releasing of this bdb
 $EQU	BDB$V_AST_DCL	6		; ast has been declared for
 $EQU	BDB$M_AST_DCL	64
					; waiting stream
 $DEF	BDB$B_FLGS	.BLKB		; bdb flags
 $DEF	BDB$B_CACHE_VAL			; relative value of buffer in cache
 $DEF	BDB$B_VERTYP	.BLKB		; version type (1 = wild)
 $DEF	BDB$W_USERS	.BLKW		; number of streams referencing this buffer
 $DEF	BDB$W_BUFF_ID	.BLKW		; buffer identification number
 $DEF	BDB$L_BLB_PTR	.BLKL		; pointer to BLB chain for this BDB
 $DEF	BDB$W_NUMB			; # of bytes of buffer in use
 $DEF	BDB$W_DIRSEQ	.BLKW		; UCB$W_DIRSEQ at directory read time
 $DEF	BDB$W_SIZE	.BLKW		; # bytes in buffer
 $DEF	BDB$L_ADDR	.BLKL		; address of buffer
 $DEF	BDB$L_VBN	.BLKL		; 1st vbn in buffer
 $DEF	BDB$L_VBNSEQNO			; vbn seq number of validity check vs. bcb copy
 $DEF	BDB$L_LAST	.BLKL		; address of last directory record
 			; (for inter-stream intra-
 			;  process locking only)
 $DEF	BDB$L_WAIT			; wait thread (irab addr)
 			
 $DEF	BDB$L_VERCOUNT	.BLKL		; negative count of version entries scanned
 $DEF	BDB$L_WK1			; work area
 $DEF	BDB$B_REL_VBN	.BLKB		; current vbn rel to start of buffer
 $DEF	BDB$B_VAL_VBNS	.BLKB		; # of valid vbns in buffer
 $DEF	BDB$B_PRE_CCTL	.BLKB		; unit record carriage control byte ('pre')
 $DEF	BDB$B_POST_CCTL	.BLKB		; unit record carriage control byte ('post')
 $DEF	BDB$L_CURBUFADR	.BLKL		; current buffer addr
 	. = 36 		; re-use for i/o status block
 			.BLKL	1
 $EQU	BDB$S_IOSB	8
 $DEF	BDB$L_IOSB			; i/o status block for buffer
 $DEF	BDB$L_VERSION	.BLKL		; addr of current/next directory version entry
 $DEF	BDB$L_RECORD	.BLKL		; address of current/next directory record
 $DEF	BDB$C_BLN

 $DEF	BDB$K_BLN			; length of bdb block
 	$DEFEND	BDB,$GBL,DEF

 	.ENDM	$BDBDEF
 
 ;
 ;	GBPB field definitions
 ;
 ; Global Buffer Pointer Block (GBPB)
 ;
 ; The GBPB is the process local structure used in conjunction with
 ; shared global i/o buffers.  In order to minimize the impact of
 ; global buffers on existing code, the GBPB is identical to a BDB
 ; in those fields which are referenced outside of the RM$CACHE and
 ; RM$RELEASE routines.
 ;
 	.MACRO	$GBPBDEF,$GBL

 	$DEFINI	GBPB,$GBL


 $DEF	GBPB$L_FLINK	.BLKL		; forward link
 $DEF	GBPB$L_BLINK	.BLKL		; backward link
 $EQU	GBPB$C_BID	21		; gbpb id code
 $DEF	GBPB$B_BID	.BLKB		; block id
 $DEF	GBPB$B_BLN	.BLKB		; block length in longwords
 $DEF	GBPB$B_FLGS	.BLKB		; gbpb flags (use BDB flgs definitions)
 $DEF	GBPB$B_CACHE_VL	.BLKB		; relative cache value of this buffer
 $DEF	GBPB$W_USERS	.BLKW		; number of streams referencing this buffer
 $DEF	GBPB$W_BUFF_ID	.BLKW		; buffer identification number
 $DEF	GBPB$L_BLB_PTR	.BLKL		; pointer to BLB chain for this GBPB
 $DEF	GBPB$W_NUMB	.BLKW		; # of bytes of buffer in use
 $DEF	GBPB$W_SIZE	.BLKW		; # bytes in buffer
 $DEF	GBPB$L_ADDR	.BLKL		; address of buffer
 $DEF	GBPB$L_VBN	.BLKL		; 1st vbn in buffer
 $DEF	GBPB$L_VBNSEQNO	.BLKL		; sequence number field.
 $DEF	GBPB$L_GBD_PTR	.BLKL		; Pointer to the GBD for this buffer.
 $DEF	GBPB$C_BLN

 $DEF	GBPB$K_BLN			; Length of GBPB block
 	$DEFEND	GBPB,$GBL,DEF

 	.ENDM	$GBPBDEF

 
 ;
 ;	rlb field definitions
 ;
 ;  record lock block (rlb)
 ;
 ;  the rlb describes one locked record for a particular
 ;  process-record stream (rab/irab). if the owner field
 ;  is 0 then the rlb is available for use. otherwise, it
 ;  describes a locked record. note: when owner is 0 the
 ;  record rfa fields are zeroed (0).
 ;
 ;
 ;                +---------------------------------------+
 ;                |                                       |
 ;rlb:            |                link                   |
 ;                |                                       |
 ;                +------------------+--------------------+
 ;                |                  |                    |
 ;                |       owner	    |        rfa4	 |
 ;                |                  !               id   |
 ;                +---------+--------+----------+---------+
 ;                |         |        |          |         |
 ;                |  flags  |reserved|   bln    |   bid   |
 ;                |         |        |          |         |
 ;                +---------+--------+----------+---------+
 ;                |                                       |
 ;                |                rfa0                   |
 ;		 |                                       |
 ;                +---------------------------------------+
 ;                |                  |                    |
 ;lksb:           | Still to be def- |  VMS status code   |
 ;                | ined status bits |                    |
 ;                +---------------------------------------+
 ;                |                                       |
 ;                |  Lock Id. (Returned for new locks,    |
 ;                |            input for conversions)     |
 ;                +---------------------------------------+
 ;
 ;
 	.MACRO	$RLBDEF,$GBL

 	$DEFINI	RLB,$GBL


 $DEF	RLB$L_LNK	.BLKL		; link to next rlb
 $DEF	RLB$L_MISC			; longword definition to optimize clearing field
 		  		;  isi for stream
 				; note that owner field is now a word, not
 				; a longword anymore
 $DEF	RLB$W_OWNER	.BLKW		; owner id for locked record is
 				; offset for seq f.o. (bits 0:14)
 				; always 0 for rel f.o. (bits 0:14)
 $DEF	RLB$W_RFA4			; 3'rd word of records rfa
 $DEF	RLB$W_ID	.BLKW		; id for idx f.o.
 $EQU	RLB$C_BID	14			; rlb code
 $DEF	RLB$B_BID	.BLKB		; block id
 $DEF	RLB$B_BLN	.BLKB		; block length in longwords
 				 			; reserved
 			.BLKB	1
 $EQU	RLB$V_WAIT	0		; propagation of ROP WAT bit
 $EQU	RLB$M_WAIT	1
 $EQU	RLB$V_CR	1		; defines lock manager mode "concurrent read"
 $EQU	RLB$M_CR	2
					; used to query lock database for records
 $EQU	RLB$V_PW	2		; allow reader access to locked record flag
 $EQU	RLB$M_PW	4
					; indicate "lock for write, allow readers"
 $EQU	RLB$V_PR	3		; used to query lock database
 $EQU	RLB$M_PR	8
 $DEF	RLB$B_FLAGS	.BLKB		; various locking flags
 				; seq f.o. vbn
 				; rel f.o. relative record number
 				; idx f.o. start vbn
 $DEF	RLB$L_RFA0	.BLKL		; 1'st and 2'nd words of record's rfa
 $DEF	RLB$L_LKSB			; first longword of lock status block
 $DEF	RLB$W_STATUS	.BLKW		; VMS status code
 $DEF	RLB$W_S_BITS	.BLKW		; various status bits
 $DEF	RLB$L_LOCK_ID	.BLKL		; second longword of lksb is lock_id
 $DEF	RLB$C_BLN

 $DEF	RLB$K_BLN			; length of rlb
 	$DEFEND	RLB,$GBL,DEF

 	.ENDM	$RLBDEF
 
 ;
 ;  directory cache node definitions
 ;
 	.MACRO	$DRCDEF,$GBL

 	$DEFINI	DRC,$GBL


 $DEF	DRC$L_NXTFLNK	.BLKL		; link to next entry, this level
 $DEF	DRC$L_NXTBLNK	.BLKL		; link to previous entry, this level
 $DEF	DRC$L_LVLFLNK	.BLKL		; link to first entry, next lower level
 			; note: the links are maintained in lru order
 $DEF	DRC$L_LVLBLNK	.BLKL		; link to last entry, next lower level
 $EQU	DRC$S_NAME	10
 			; note: stored as counted string counting count itself
 $DEF	DRC$T_NAME	.BLKB	10	; directory name or device and unit
 $EQU	DRC$S_DID	6
 $DEF	DRC$W_DID	.BLKW		; file id for directory
 $DEF	DRC$W_DIRSEQ	.BLKW		; directory sequence # for device node
 			.BLKW	1
 $DEF	DRC$C_BLN

 $DEF	DRC$K_BLN			; length of directory cache node
 	$DEFEND	DRC,$GBL,DEF

 	.ENDM	$DRCDEF

 
 ;
 ;		release option flag definitions
 ;
 	.MACRO	$RLSDEF,$GBL

 	$DEFINI	RLS,$GBL


 $EQU	RLS$V_RETURN	0		; return buffer and bdb to free space lists
 $EQU	RLS$M_RETURN	1
 $EQU	RLS$V_WRT_THRU	1		; write buffer if dirty
 $EQU	RLS$M_WRT_THRU	2
 $EQU	RLS$V_KEEP_LOCK	2		; keep bdb locked
 $EQU	RLS$M_KEEP_LOCK	4
 $EQU	RLS$V_DEQ	3		; always release lock
 $EQU	RLS$M_DEQ	8

 	$DEFEND	RLS,$GBL,DEF

 	.ENDM	$RLSDEF
 
 ;
 ;		cache option flag definitions
 ;
 	.MACRO	$CSHDEF,$GBL

 	$DEFINI	CSH,$GBL


 $EQU	CSH$V_LOCK	0		; obtain exclusive access to block
 $EQU	CSH$M_LOCK	1
 $EQU	CSH$V_NOWAIT	1		; do not wait for block on access interlock
 $EQU	CSH$M_NOWAIT	2
					; collision
 $EQU	CSH$V_NOREAD	2		; do not read in block
 $EQU	CSH$M_NOREAD	4
 $EQU	CSH$V_NOBUFFER	3		; obtain access to block but don't allocate
 $EQU	CSH$M_NOBUFFER	8
					; a buffer for it and don't read it

 	$DEFEND	CSH,$GBL,DEF

 	.ENDM	$CSHDEF
 
 ;
 ;
 ;  rms overall status bit definitions
 ;
 	.MACRO	$PIODEF,$GBL

 	$DEFINI	PIO,$GBL


 $EQU	PIO$V_INHAST	0		; set if asts implicitly inhibited
					; if reset by disabled ast, ast must be re-
					; enabled
 $EQU	PIO$V_EOD	1		; set if searching for 'eod' string on 'input'
 $EQU	PIO$V_SYNC1	2		; sync stalled operation using efn 27
 $EQU	PIO$V_SYNC2	3		; sync stalled operation using efn 28

 	$DEFEND	PIO,$GBL,DEF

 	.ENDM	$PIODEF
 

 ;
 ;	definitions for rms debug failure codes
 ;
 ;
 ;  the following codes are for temporary bug check tests, and are
 ;  internal to rms.  all of the codes are negative, implying that they
 ;  do not return to the caller, probably killing the process (if not
 ;  the entire system).
 ;
 	.MACRO	$FTLDEF,$GBL

 	$DEFINI	FTL,$GBL


 $EQU	FTL$_SETPRTFAIL	<^XFFFFFFFF>		; set protection system service failed (rm0bufmgr)
 $EQU	FTL$_STKTOOBIG	<^XFFFFFFFE>		; stack too big for asb (rm0stall)
 $EQU	FTL$_BADIFAB	<^XFFFFFFFD>		; invalid ifab (or irab) (rm0fset,rm0conn,rm0rset,
					; rm0prflnm)
 $EQU	FTL$_GTCHNFAIL	<^XFFFFFFFC>		; get channel system service failure (rm0prflnm)
 $EQU	FTL$_BADORGCASE	<^XFFFFFFFB>		; invalid orgcase value for dispatch (all rms$
					; level routines execept open and create)
 $EQU	FTL$_BADBDB	<^XFFFFFFFA>		; block not a bdb (rm0bufmgr)
 $EQU	FTL$_ASBALLFAIL	<^XFFFFFFF9>		; couldn't allocate an asb (rm0stall)
 $EQU	FTL$_BADASTPRM	<^XFFFFFFF8>		; ast parameter not a valid ifab/irab addr (rm0stall)
 $EQU	FTL$_CANTDOAST	<^XFFFFFFF7>		; couldn't redeclare ast (insf. mem.) (rm0stall)
 $EQU	FTL$_NOSTRUCT	<^XFFFFFFF6>		; rab or fab not same on ast (rm0stall)
 $EQU	FTL$_NOASB	<^XFFFFFFF5>		; asb not allocated or stream not busy on ast (rm0stall)
 $EQU	FTL$_NONXTBDB	<^XFFFFFFF4>		; no next bdb available (rm1seqxfr)
 $EQU	FTL$_BADBUFSIZ	<^XFFFFFFF3>		; disk buffer size not = 512 (rm1conn)
 $EQU	FTL$_ENQDEQFAIL	<^XFFFFFFF2>		; enq or deq service failed (rm0reclck)
 $EQU	FTL$_NOCURBDB	<^XFFFFFFF1>		; no current bdb before calling rm$release (rm0reclck)
					;   (-16 no longer used)
 $EQU	FTL$_DEALLERR	<^XFFFFFFEF>		; ifab deallocation attempted with other block(s)
					; still allocated (rms0close)
 $EQU	FTL$_IORNDN	<^XFFFFFFEE>		; i/o rundown inconsistency (either ifab or irab
					; table entries not zeroed) (rms0rndwn)
 $EQU	FTL$_XFERSIZE	<^XFFFFFFED>		; size of requested transfer not equal to
					; or less than the current number of bytes
					; in use for the bdb (rm0cache)
 $EQU	FTL$_NOTLOCKED	<^XFFFFFFEC>		; bdb not locked and a keep lock request
					; was made on a release request.
 $EQU	FTL$_NODIDORFID	<^XFFFFFFEB>		; neither a fid nor a did was set upon exit from
					; rm$setdid (rms0erase)
 $EQU	FTL$_RELEASFAIL	<^XFFFFFFEA>		; release of non-dirty bdb failed (rm0xtnd23,rms0extend)
 $EQU	FTL$_NOLOCKBDB	<^XFFFFFFE9>		; no lock bdb found (rm0xtnd23)
 $EQU	FTL$_NONETWORK	<^XFFFFFFE8>		; network routine entered but no network support in rms
 $EQU	FTL$_LOCKFAILED	<^XFFFFFFE7>		; failed to lock prolog (rm2create)
 $EQU	FTL$_BADLEVEL	<^XFFFFFFE6>		; to search by id, structure level must be 0
 $EQU	FTL$_ASTDECERR	<^XFFFFFFE5>		; ast declaration for file sharing failed
 $EQU	FTL$_BCBERR	<^XFFFFFFE4>		; no more bcb's to release even though more bdb's
 $EQU	FTL$_SFDSPCERR	<^XFFFFFFE3>		; all space was not returned before returning sifab pag
 $EQU	FTL$_ACCNTOVFLO	<^XFFFFFFE2>		; access count overflow (rm0share)
 $EQU	FTL$_QUEUEERR	<^XFFFFFFE1>		; take sifab queue error (rm0share)
 $EQU	FTL$_QUEUEERR2	<^XFFFFFFE0>		; release sifab queue error (rm0share)
 $EQU	FTL$_BDBAVAIL	<^XFFFFFFDF>		; BDB was available and shouldn't have been.
 $EQU	FTL$_GBLNOLK	<^XFFFFFFDE>		; Record locking was not set with global buffers.
 $EQU	FTL$_LCKFND	<^XFFFFFFDD>		; A lock was found and we don't know what to do.
 $EQU	FTL$_NOBLB	<^XFFFFFFDC>		; No BLB was found and there should have been one.
 $EQU	FTL$_NOGBPB	<^XFFFFFFDB>		; No GBPB was found and should have been.
 $EQU	FTL$_NOLCLBUF	<^XFFFFFFDA>		; Should have found a local buffer.
 $EQU	FTL$_NORDNOTSET	<^XFFFFFFD9>		; NOREAD not set when NOBUFFER was.
 $EQU	FTL$_NOTGBPB	<^XFFFFFFD8>		; Found an illegit BDB.
 $EQU	FTL$_NOSFSB	<^XFFFFFFD7>		; No SFSB when allocating BLB.
 $EQU	FTL$_LOCKHELD	<^XFFFFFFD6>		; Attempted to return a BLB with lock_id neq 0
 $EQU	FTL$_RLSDRT	<^XFFFFFFD5>		; Dirty buffer found in releasall.
 $EQU	FTL$_BADBLB	<^XFFFFFFD4>		; Bad BLB found in blocking AST routine.
 $EQU	FTL$_BADOWNER	<^XFFFFFFD3>		; Owner field in BLB is bad in blocking AST routine.


 	$DEFEND	FTL,$GBL,DEF

 	.ENDM	$FTLDEF
 
 ;
 ;  the following internal codes are for non-fatal bug check reporting.
 ;  these codes are positive byte values.  they trigger a reporting action
 ;  and return to the caller with r0 set to rms$_bug+<8*the bug code>,
 ;  which is an externally documented rms error code.
 ;
 	.MACRO	$BUGDEF,$GBL

 	$DEFINI	BUG,$GBL


 $EQU	BUG$_BADDFLTDIR	1		;DEFAULT DIRECTORY STRING INVALID (RM0XPFN)


 	$DEFEND	BUG,$GBL,DEF

 	.ENDM	$BUGDEF
 
 ; index descriptor definition
 ;
 ; an index descriptor block exists for each key of reference in use.
 ; they are not necessarily contiguous in memory.
 ;
 	.MACRO	$IDXDEF,$GBL

 	$DEFINI	IDX,$GBL

 	
 $DEF	IDX$L_IDXFL	.BLKL		; forward link to next index descriptor
 				 			; spare
 			.BLKL	1
 $EQU	IDX$C_BID	15			; id for index descriptor block
 $DEF	IDX$B_BID	.BLKB		; block id
 $DEF	IDX$B_BLN	.BLKB		; length of block
 $DEF	IDX$B_IANUM	.BLKB		; area number for index buckets
 $DEF	IDX$B_LANUM	.BLKB		; area number for lower index buckets
 $DEF	IDX$B_DANUM	.BLKB		; area number for data buckets
 $DEF	IDX$B_ROOTLEV	.BLKB		; level of root
 $DEF	IDX$B_IDXBKTSZ	.BLKB		; size of index bucket in vbn's
 $DEF	IDX$B_DATBKTSZ	.BLKB		; size of data bucket in vbn's
 $DEF	IDX$L_ROOTVBN	.BLKL		; start vbn of root bucket
 $EQU	IDX$V_DUPKEYS	0		; duplicate keys allowed
 $EQU	IDX$M_DUPKEYS	1
 $EQU	IDX$V_CHGKEYS	1		; keys can change values
 $EQU	IDX$M_CHGKEYS	2
 $EQU	IDX$V_NULKEYS	2		; null key value allowed
 $EQU	IDX$M_NULKEYS	4
 $EQU	IDX$V_IDX_COMPR	3		; index is compressed
 $EQU	IDX$M_IDX_COMPR	8
 $EQU	IDX$V_INITIDX	4		; index is not initialized
 $EQU	IDX$M_INITIDX	16
 $EQU	IDX$V_COUNT_DUP	5		; maintain duplicate count
 $EQU	IDX$M_COUNT_DUP	32

						; space over dupkeys
 $EQU	IDX$V_NORFA	1		; no rfa fields in records (single key only)
 $EQU	IDX$M_NORFA	2
 $EQU	IDX$V_PRG_D_RFA	2		; delete records and rrv's may be purged
 $EQU	IDX$M_PRG_D_RFA	4
					; from file (disables fast delete)
				
				
				
 $EQU	IDX$V_KEY_COMPR	6		; key has been compressed at the data level
 $EQU	IDX$M_KEY_COMPR	64
 $EQU	IDX$V_REC_COMPR	7		; data record is in compressed form
 $EQU	IDX$M_REC_COMPR	128

 $DEF	IDX$B_FLAGS	.BLKB		; index/key flags
 $EQU	IDX$C_STRING	0			; string data type
 $EQU	IDX$C_SGNWORD	1			; signed binary word
 $EQU	IDX$C_UNSGNWORD	2			; unsigned binary word
 $EQU	IDX$C_SGNLONG	3			; signed binary long word
 $EQU	IDX$C_UNSGNLONG	4			; unsigned binary long word
 $EQU	IDX$C_PACKED	5			; packed decimal
 $DEF	IDX$B_DATATYPE	.BLKB		; data type of key field
 $DEF	IDX$B_SEGMENTS	.BLKB		; number of key field segments
 $DEF	IDX$B_NULLCHAR	.BLKB		; null character
 $DEF	IDX$B_KEYSZ	.BLKB		; total key size
 $DEF	IDX$B_KEYREF	.BLKB		; key of reference(0-primary)
 $DEF	IDX$W_MINRECSZ	.BLKW		; minimum record size
 $DEF	IDX$W_IDXFILL	.BLKW		; index fill
 $DEF	IDX$W_DATFILL	.BLKW		; data fill
 $EQU	IDX$C_V2_BKT	0			; Prologue two bucket
 $EQU	IDX$C_CMPIDX	1			; Prologue 3, index (and SIDR) are compressed
 $EQU	IDX$C_NCMPIDX	2			; Prologue 3, index (and SIDR) are not compressed
 $DEF	IDX$B_IDXBKTYP	.BLKB		; PLG3 - type of index bucket and SIDR bucket
 $EQU	IDX$C_CMPCMP	3			; Prologue 3, primary key is compressed, data
 				;  is compressed
 $EQU	IDX$C_CMPNCMP	4			; Prologue 3, primary key is compressed,
 				;  data is not compressed
 $EQU	IDX$C_NCMPCMP	5			; Prologue 3, primary key is not compressed
 				;  data is compressed
 $EQU	IDX$C_NCMPNCMP	6			; Prologue 3, primary key is not compressed
 				;  data is not compressed
 $DEF	IDX$B_DATBKTYP	.BLKB		; PLG3 - type of primary data bucket
 				 			; spare
 ;
 ; the following is the length of the fixed part of the index descriptor
 ;
 			.BLKW	1
 $DEF	IDX$C_FIXED_BLN

 ;
 ; the following is repeated for each key segment
 ;
 $DEF	IDX$K_FIXED_BLN
 $DEF	IDX$W_POSITION	.BLKW		; key segment position
 $DEF	IDX$B_SIZE	.BLKB		; key segment size (plg 3)
 $DEF	IDX$B_TYPE	.BLKB		; key segment datatype (plg 3)

 	$DEFEND	IDX,$GBL,DEF

 	.ENDM	$IDXDEF

 
 ;
 ; nrp list definitions
 ;
 	.MACRO	$NRPDEF,$GBL

 	$DEFINI	NRP,$GBL


 $DEF	NRP$L_LINK	.BLKL		; link to next " next record pointer" cell

 ; Beginning of first section (9 bytes long)

 $DEF	NRP$B_SPARE	.BLKB		; needed to match the next section size
 $DEF	NRP$L_VBN	.BLKL		; vbn of "next record "
 $DEF	NRP$W_ID	.BLKW		; id of "next record " (plg 3)
 $EQU	NRP$V_DELETED	0		; the "next record " has been deleted
 $EQU	NRP$M_DELETED	1
 $EQU	NRP$V_BEGINNING	1		; we are pointed to the beg. of a bucket
 $EQU	NRP$M_BEGINNING	2
 $EQU	NRP$V_NEW_VBN	2		; 0,1,2 indicating what the new vbn will be,
 $EQU	NRP$M_NEW_VBN	12
 $EQU	NRP$S_NEW_VBN	2
					; used during split
 $EQU	NRP$V_UPD_NRP	4		; nrp is to be updated
 $EQU	NRP$M_UPD_NRP	16
 $EQU	NRP$V_NEW_DEL	5		; the new delete flag(used in $delete)
 $EQU	NRP$M_NEW_DEL	32
 $EQU	NRP$V_NEW_BEG	6		; the new beginning flag(used in $delete)
 $EQU	NRP$M_NEW_BEG	64
 $DEF	NRP$B_FLAGS	.BLKB

 ; Beginning of second section

 $DEF	NRP$W_DUP_POS	.BLKW		; position count for sidr's
 $DEF	NRP$L_RP_VBN	.BLKL		; vbn of "record"
 $DEF	NRP$W_RP_ID	.BLKW		; rp of "record" (plg 3)
 $DEF	NRP$W_NEW_POS	.BLKW		; the new dup_pos (used in $delete and clean up deleted records)
 $DEF	NRP$W_NEW_NRP	.BLKW		; new id for nrp, used during split (plg 3)
 $DEF	NRP$C_BLN
 $EQU	NRP$C_CELL	9		; Determines the size of sections within the NRP cell,
 			; such that corresponding values can be referenced by
 			; the same address when the NRP pointer is changed.

 $DEF	NRP$K_BLN
 	$DEFEND	NRP,$GBL,DEF

 	.ENDM	$NRPDEF
 
 ;
 ; update buffer flags
 ;
 	.MACRO	$UPDDEF,$GBL

 	$DEFINI	UPD,$GBL


 $EQU	UPD$V_INS_NEW	0		; alternate key to be inserted from record buffer
 $EQU	UPD$M_INS_NEW	1
 $EQU	UPD$V_OLD_DEL	1		; delete this key value using old record
 $EQU	UPD$M_OLD_DEL	2
 $DEF	UPD$B_FLAGS	.BLKB

 	$DEFEND	UPD,$GBL,DEF

 	.ENDM	$UPDDEF
 
 ;	GBH field definitions
 ;
 ; Global Buffer Header (GBH)
 ;
 ; There is a Global Buffer Header for every file's global buffer section.
 ;
 	.MACRO	$GBHDEF,$GBL

 	$DEFINI	GBH,$GBL


 $DEF	GBH$L_GBD_FLNK	.BLKL		; Self relative queue header for GBD's
 $DEF	GBH$L_GBD_BLNK	.BLKL
 $EQU	GBH$C_BID	17		; Block ID code for GBH
 $DEF	GBH$B_BID	.BLKB		; Block ID
 $DEF	GBH$B_BLN	.BLKB		; Length of GBH in longwords
 $EQU	GBH$V_CACHE_IN	0		; Cache inputs
 $EQU	GBH$M_CACHE_IN	1
 $EQU	GBH$V_CACHE_OUT	1		; Cache outputs
 $EQU	GBH$M_CACHE_OUT	2
 $EQU	GBH$V_RLS_IN	2		; Release inputs
 $EQU	GBH$M_RLS_IN	4
 $EQU	GBH$V_RLS_OUT	3		; Release outputs
 $EQU	GBH$M_RLS_OUT	8
 $EQU	GBH$V_QIO_START	4		; Qio inputs
 $EQU	GBH$M_QIO_START	16
 $EQU	GBH$V_QIO_DONE	5		; Qio outputs
 $EQU	GBH$M_QIO_DONE	32
 $EQU	GBH$V_STALL	6		; Stall inputs
 $EQU	GBH$M_STALL	64
 $EQU	GBH$V_THREADGO	7		; Stall outputs
 $EQU	GBH$M_THREADGO	128
 $EQU	GBH$V_BLB_ENQ	8		; Bucket lock ENQ inputs
 $EQU	GBH$M_BLB_ENQ	256
 $EQU	GBH$V_BLB_GRANT	9		; Bucket lock grant status
 $EQU	GBH$M_BLB_GRANT	<^X200>
 $EQU	GBH$V_BLB_DEQ	10		; Bucket lock DEQ request
 $EQU	GBH$M_BLB_DEQ	<^X400>
 $EQU	GBH$V_BLB_BLOCK	11		; Blocking AST received
 $EQU	GBH$M_BLB_BLOCK	<^X800>
 $EQU	GBH$V_F1	12
 $EQU	GBH$M_F1	<^X1000>
 $EQU	GBH$V_F2	13
 $EQU	GBH$M_F2	<^X2000>
 $EQU	GBH$V_F3	14
 $EQU	GBH$M_F3	<^X4000>
 $EQU	GBH$V_F4	15
 $EQU	GBH$M_F4	<^X8000>

 $DEF	GBH$W_TRC_FLGS	.BLKW		; Trace flags (set to trace given function)
 $DEF	GBH$L_HI_VBN	.BLKL		; Highest possible VBN value (FFFFFFFF).
 $DEF	GBH$L_GS_SIZE	.BLKL		; Size of total section in bytes.
 $DEF	GBH$L_TRC_FLNK	.BLKL		; Trace blocks forward link
 $DEF	GBH$L_TRC_BLNK	.BLKL		; Trace blocks back link
 $DEF	GBH$L_GBD_START	.BLKL		; Offset to first GBD.
 $DEF	GBH$L_GBD_END	.BLKL		; Offset to last GBD.
 $DEF	GBH$L_GBD_NEXT	.BLKL		; Offset to next cache victim GBD.
 ;
 ; Global buffer statistics section
 ;
 $DEF	GBH$L_SCAN_NUM	.BLKL		; Number of GBD's to scan for victim.
 $DEF	GBH$L_HIT	.BLKL		; Buffer found in global cache
 $DEF	GBH$L_MISS	.BLKL		; Buffer not found in global cache
 $DEF	GBH$L_READ	.BLKL		; Buffer read from disk into cache
 $DEF	GBH$L_WRITE	.BLKL		; Buffer written from cache to disk
 $DEF	GBH$L_DFW_WRITE	.BLKL		; Deferred writeback from cache to disk
 $DEF	GBH$L_CROSS_HIT	.BLKL		; Cross process hit count.
 $DEF	GBH$C_BLN

 $DEF	GBH$K_BLN			; Length of global buffer header structure
 	$DEFEND	GBH,$GBL,DEF

 	.ENDM	$GBHDEF


 
 ;	TRC field definitions
 ;
 ; Trace block structure (TRC)
 ;
 ; Tracing saves at specific points in the RMS code for debugging and
 ; algorithm analysis purposes.
 ;
 	.MACRO	$TRCDEF,$GBL

 	$DEFINI	TRC,$GBL


 $DEF	TRC$L_FLNK	.BLKL		; Trace block forward link
 $DEF	TRC$L_BLNK	.BLKL		; Trace block back link
 $EQU	TRC$C_BID	18		; Trace block code
 $DEF	TRC$B_BID	.BLKB		; Block ID
 $DEF	TRC$B_BLN	.BLKB		; Length of block in longwords
 $DEF	TRC$W_FUNCTION	.BLKW		; Function code (see GBH definitions)
 $DEF	TRC$L_STRUCTURE	.BLKL		; Ifab/irab address.
 $DEF	TRC$W_PID	.BLKW		; Process ID
 $DEF	TRC$W_SEQNUM	.BLKW		; Sequence number.
 $DEF	TRC$L_VBN	.BLKL		; VBN requested.
 $DEF	TRC$L_RETURN1	.BLKL		; Address of caller.
 $DEF	TRC$L_RETURN2	.BLKL		; Caller's caller.
 $EQU	TRC$S_ARGS	32
 $DEF	TRC$L_ARGS			; Function specific arguments
 $DEF	TRC$L_ARG_FLG	.BLKL		; Argument flags (R3).
 $DEF	TRC$L_BDB_ADDR	.BLKL		; BDB address.
 $DEF	TRC$W_BDB_USERS	.BLKW		; Use count from BDB.
 $DEF	TRC$W_BDB_BUFF	.BLKW		; BDB buffer ID.
 $DEF	TRC$B_BDB_CACHE	.BLKB		; BDB cache value.
 $DEF	TRC$B_BDB_FLAGS	.BLKB		; Status flags from BDB.
 $DEF	TRC$L_BDB_SEQ	.BLKL		; Sequence number from BDB.
 $DEF	TRC$B_BLB_MODE	.BLKB		; Mode held in BLB.
 $DEF	TRC$B_BLB_FLAGS	.BLKB		; Flags from BLB.
 $DEF	TRC$L_BLB_ADDR	.BLKL		; Address of BLB.
 $DEF	TRC$L_BLB_LOCK	.BLKL		; Lock ID from BLB.
 $DEF	TRC$L_BLB_SEQ	.BLKL		; Sequence number from BLB.
 $DEF	TRC$C_BLN
 			; maintain quad alignment on header

 $DEF	TRC$K_BLN			; NOTE: should be quadwords multiple to
 	$DEFEND	TRC,$GBL,DEF

 	.ENDM	$TRCDEF



 
 ;	GBD structure definitions
 ;
 ; Global Buffer Descriptor (GBD)
 ;
 ; There is a single GBD for every buffer in a global buffer
 ; section (used only with shared files).  The GBD's themselves
 ; are in the section also and linked from a queue header in
 ; the Global Buffer Header (GBH).
 ;
 	.MACRO	$GBDDEF,$GBL

 	$DEFINI	GBD,$GBL


 $DEF	GBD$L_FLINK	.BLKL		; Forward link - Note: This is a self relative queue
 $DEF	GBD$L_BLINK	.BLKL		; Back link
 $EQU	GBD$C_BID	19		; Block ID code for GBD
 $DEF	GBD$B_BID	.BLKB		; Block ID
 $DEF	GBD$B_BLN	.BLKB		; Block length of GBD
 $EQU	GBD$V_VALID	0		; Buffer is valid.
 $EQU	GBD$M_VALID	1
 $DEF	GBD$B_FLAGS	.BLKB		; Buffer status flags
 $DEF	GBD$B_CACHE_VAL	.BLKB		; Cache value of this bucket
 $DEF	GBD$L_VBN	.BLKL		; VBN of bucket the buffer describes
 $DEF	GBD$W_NUMB	.BLKW		; Number of bytes in use
 $DEF	GBD$W_SIZE	.BLKW		; Size of buffer in bytes
 $DEF	GBD$L_REL_ADDR	.BLKL		; Address of buffer relative to GBH
 $DEF	GBD$L_BKTSEQNUM			; Bkt sequence number validity check
 $DEF	GBD$W_LAST_ID	.BLKW		; Last PID to reference bucket.
 $DEF	GBD$W_LST_LK_ID	.BLKW		; PID of last locker to reference bucket.
 $DEF	GBD$W_USECNT	.BLKW		; Accessor count for bucket
 $DEF	GBD$B_REHIT_RD	.BLKB		; Rehit by same process count.
 $DEF	GBD$B_REHIT_LK	.BLKB		; Rehit by same locker process.
 $DEF	GBD$C_BLN
 			; quad alignment on header

 $DEF	GBD$K_BLN			; NOTE: should be quad multiple to maintain
 	$DEFEND	GBD,$GBL,DEF

 	.ENDM	$GBDDEF


 
 ;	BLB field definitions
 ;
 ; Bucket Lock Block (BLB)
 ;
 ; The BLB contains the argument list for the SYS$ENQ system service
 ; as well a pointer to the BDB it relates to and other status.
 ;
 	.MACRO	$BLBDEF,$GBL

 	$DEFINI	BLB,$GBL


 $DEF	BLB$L_FLNK	.BLKL		; Link to next BLB
 $DEF	BLB$L_BLNK	.BLKL		; Back link
 $EQU	BLB$C_BID	16		; BLB code
 $DEF	BLB$B_BID	.BLKB		; Block ID
 $DEF	BLB$B_BLN	.BLKB		; Block length
 $EQU	BLB$V_LOCK	0		; Corresponds to CSH$V_LOCK
 $EQU	BLB$M_LOCK	1
 $EQU	BLB$V_NOWAIT	1		; Same as CSH$V_NOWAIT
 $EQU	BLB$M_NOWAIT	2
 $EQU	BLB$V_NOREAD	2		; Same as CSH$V_NOREAD
 $EQU	BLB$M_NOREAD	4
 $EQU	BLB$V_NOBUFFER	3		; Same as CSH$V_NOBUFFER
 $EQU	BLB$M_NOBUFFER	8
 $EQU	BLB$V_IOLOCK	4		; Lock mode for read/write
 $EQU	BLB$M_IOLOCK	16
 $EQU	BLB$V_DFW	5		; This is lock for deferred write buffer
 $EQU	BLB$M_DFW	32
 $EQU	BLB$V_WRITEBACK	6		; The associated buffer must be written back
 $EQU	BLB$M_WRITEBACK	64
 $DEF	BLB$B_BLBFLGS	.BLKB		; Control flags for BLB
 $DEF	BLB$B_MODEHELD	.BLKB		; Mode of current lock held.
 $DEF	BLB$L_BDB_ADDR	.BLKL		; BDB for which this lock is held
 $DEF	BLB$L_OWNER	.BLKL		; Address of stream owning this lock
 $DEF	BLB$L_VBN	.BLKL		; VBN of bucket lock (resource name)
 $EQU	BLB$S_RESDSC	8
 $DEF	BLB$L_RESDSC	.BLKL	2	; Resource name descriptor
 $DEF	BLB$W_LKSTS	.BLKW		; Lock status word
 				 		; reserved
 			.BLKW	1
 $DEF	BLB$L_LOCK_ID	.BLKL		; Lock ID
 $EQU	BLB$S_VALBLK	16
 $DEF	BLB$L_VALBLK			; Lock value block
 $DEF	BLB$L_VALSEQNO	.BLKL		; Sequence number part of value block
 			.BLKL	3
 $DEF	BLB$C_BLN

 $DEF	BLB$K_BLN			; Length of BLB
 	$DEFEND	BLB,$GBL,DEF

 	.ENDM	$BLBDEF
