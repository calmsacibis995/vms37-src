	.TITLE	NETCNFACT  - Configuration data base access action routines
	.IDENT	'V03-014'

;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

; FACILITY:	NETWORK ACP
;
; ABSTRACT:
;		This module provides support to the NETACP database management
;		including database entry insertion and action routines to
;		retrieve data for parameters which are not stored in any of 
;		the CNF control blocks.  
;
; ENVIRONMENT:
;		The module runs in kernel mode and at possibly elevated IPL.
;		It is therefore locked into the ACP's virtural address space
;		in order to prevent the need for paging.
;
;		Since the ACP is work-queue driven, and since it is the ACP
;		that modifies the structure of the non-paged pool data base
;		including the RCB (actually a VCB) and the private structures
;		hanging off of the RCB, there is no need to obtain the system
;		data base mutex -- no races can occur.   However, it is
;		necessary to raise IPL in order to stop any races with
;		NETDRIVER.
;		
;
; AUTHOR:	A.Eldridge	14-Feb-80
;
; MODIFIED BY:
;
;	V014	TMH0014		Tim Halvorsen	21-Apr-1982
;		Pre-allocate receive buffers before issuing a SETMODE
;		startup function to a datalink driver, so that pool
;		expansion can be done to accomodate the buffers.  It
;		is done here because pool expansion can't be done on
;		the interrupt stack in the datalink driver.
;
;	V013	TMH0013		Tim Halvorsen	27-Mar-1982
;		Fix code to translate an NMA parameter code returned by
;		a datalink driver validation error to a NFB code.
;
;	V02-12	ADE0052		A.Eldridge	25-Jan-82
;		Get the number of DMC receive buffers from the PLI database
;		instead of the CRI database.
;
;	V02-11	ADE0051		A.Eldridge	22-Jan-82
;		Disallow NFB$C_NDI_PRX values of "both" or "outbound" if
;		explicit outbound defaults exist.
;
;	V02-10	ADE0050		A.Eldridge	19-Jan-82
;		Added routine NET$APPLY_DFLT which applies default values
;		to selected CNF parameters.
;
;	V02-09	ADE0044		A.Eldridge	06-Jan-82
;		Removed the 'retransmit timer' (RTT) parameter from the
;		circuit database
;
;	V02-08	ADE0043		A.Eldridge	31-Dec-81
;		Rename the CI DECnet class driver mnemonic to "CN".
;
;	V02-07	ADE0042		A.Eldridge	22-Dec-81
;		Added support for the logical-link "RID" field
;
;	V02-06	ADE0041		A.Eldridge	14-Dec-81
;		Added support for line counters.
;
;	V02-05	ADE0040		A.Eldridge	11-Dec-81
;		Fix node counter bug that was returning the Executor node
;		counters for nodes which are unreachable.
;
;	V02-04	ADE0030		A.Eldridge	30-Nov-81
;		Added support for zero counter event.
;
;	V02-03	ADE0029		A.Eldridge	21-Jul-81
;		Replace datalink (DLI) database with circuit (CRI) and
;		phsyical line (PLI) databases.
;
;	V02-02	ADE0028		A.Eldridge	21-Jul-81
;		Updated to support modified CNF data base interface.
;
;

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
	;
	;  System wide defintions
	;
	$DCDEF		; Device classs definitions
	$DRDEF		; NSP disconnect reason codes
	$CCBDEF		; Channel Control Block
	$CXBDEF		; Complex-chained buffers
	$EVCDEF		; DECnet Event logging symbols
	$FABDEF		; File Access Block
	$JPIDEF		; $GETJPI definitions
	$NAMDEF		; File name block
	$UCBDEF		; Unit Control Block
	$XMDEF		; XMDRIVER (general communications device driver)
			; definitions
	$NFBDEF		; Network Function Block (ACP control QIO definitions)
	$NMADEF		; Network Management (NICE protocol) definitions
	;
	;
	;  Network Specific Definitions
	;
	$CNRDEF		; Configuration Root block
	$CNFDEF		; Configuration data block
	$DEVTRNDEF	; Device translation (VMS vs. Nice protocol) info
	$DLLQIODEF	; Data-Link Layer QIO definitions
	$ICBDEF		; Internal Connect Block
	$LNIDEF		; Local node information
	$LPDDEF		; Logical path descriptor
	$LTBDEF		; Logical-link table
	$NETSYMDEF	; Miscellaneous network symbols
	$NETUPDDEF	; Symbols used in private NETACP interface to NETDRIVER
	$NDCDEF		; Node counter block
	$NDIDEF		; Node information block
	$RCBDEF		; Routing Control Block (analogous to Volume Control
			; block)
	$WQEDEF		; Work Queue Element
	$XWBDEF		; Network Window Block -- logical-link context block


;
; EQUATED SYMBOLS:
;
STR_OFF	=     0				; String descriptor string 
					; self-relative offset
STR_LNG =     2				; String descriptor string size
TMP_LTH =  1100				; Length of temp buffer

NDI_ADD = CNF$C_LENGTH+NDI$W_ADD 	; Define symbol for convenience

;
; Define special CNF flags for each database
;
NDI_V_LOOP	= CNF$V_FLG_MRK1	; Set for "loop" nodes
NDI_V_LOCAL	= CNF$V_FLG_MRK2	; Set for the "local" node

CRI_V_X25	= CNF$V_FLG_MRK1	; X25 circuit

PLI_V_NEW	= CNF$V_FLG_MRK1	; New PLI being built for first time
PLI_V_LAP	= CNF$V_FLG_MRK2	; LAPB circuit

;
; OWN STORAGE
;

	.PSECT	NET_IMPURE,WRT,NOEXE,LONG

NDI_L_NACS:	.LONG	0		; Remember number of non-null access
NDI_Q_NAME:	.QUAD	0		; Descriptor of new nodename
NDI_Q_LNAME:	.QUAD	0		; Descriptor of new logical nodename
NDI_LNAMEBUF:	.BLKB	16		; Buffer for build logical node-name



	.PSECT	NET_PURE,NOWRT,NOEXE,LONG


SYSNODE_DESC:	.ASCID	'SYS$NODE'	; Descriptor for logical name

NDI_NLOGIN_VEC:				; Vector of NDI nonpriv login field id's
		.CNFFLD	ndi,s,nus	;  nonpriv user
		.CNFFLD	ndi,s,npw	;  nonpriv password
		.CNFFLD	ndi,s,nac	;  nonpriv account
		.LONG	0		; Terminate the vecvtor

NDI_PLOGIN_VEC:				; Vector of NDI priv login field id's
		.CNFFLD	ndi,s,pus	;  priv user
		.CNFFLD	ndi,s,ppw	;  priv password
		.CNFFLD	ndi,s,pac	;  priv account
		.LONG	0		; Terminate the vecvtor

OBI_LOGIN_VEC:				; Vector of OBI login field id's
		.CNFFLD	obi,s,usr	;  user
		.CNFFLD	obi,s,psw	;  password
		.CNFFLD	obi,s,acc	;  account
		.LONG	0		; Terminate the vecvtor



;
;  The following macroes build a conversion table for formatting counters
;  into NICE format.  Each counter i.d. contain is bit encoded to contain
;  formatting information as follows:
;
;   15   14    13  12   11	    0		Bit
;
;  < 1 >< width >< 0 >< counter i.d. >		Field
;
;
	$WIDTH_B = 1	; Counter width specifier for bytes
	$WIDTH_W = 2	; Counter width specifier for words
	$WIDTH_L = 3	; Counter width specifier for longwords

NET$C_NMACNT_SLZ = <1@15>!<<$WIDTH_W>@13>!0	; Seconds since last zeroed

.MACRO $COUNT_ENT  base,nice,pre,mod,count,width; Insert table entry
						;
	.WORD	<1@15>!<<$WIDTH_'width'>@13>!-	; Counter flag, Counter width
		<NMA$C_'nice'_'count'>		; Nice counter i.d.
	.WORD	'pre'$'width'_'mod''count' -	; Offset into internal structure
		- base				; minus internal structure base
.ENDM	$COUNT_ENT				;


.MACRO	$COUNT_TAB  base,nice,pre,mod,list	; Create counter formatting table
						;
	.IRP	A,<list>			;
		$COUNT_ENT  base,nice,pre,mod,A	; Insert table entry
	.ENDR					;
						;
	.LONG	0				; Terminate the table

.ENDM	$COUNT_TAB
	


CNT_FMT_BUFSIZ = 100		; Size required to accomodate largest formatted
				; counter buffer

NDC$L_MRC = NDC$L_PRC		;& Setup synonyms until NETNPAGED.MDL is fixed
NDC$L_MSN = NDC$L_PSN

NDC_CNT_TAB:			; Common node counter table

    $COUNT_TAB  NDC$L_ABS_TIM,CTNOD,NDC,,-
		<-
		<BRC,L>,-	; Bytes received
		<BSN,L>,-	; Bytes sent
		<MRC,L>,-	; Packets received
		<MSN,L>,-	; Packets sent
		<CRC,W>,-	; Connects received
		<CSN,W>,-	; Connects sent
		<RTO,W>,-	; Response timeouts
		<RSE,W>,-	; Transmitted connect rejects due to resource
		-		; errors
    >

RCB_CNT_TAB:			; Local node counters

    $COUNT_TAB	RCB$L_ABS_TIM,CTNOD,RCB,CNT_,-
		<-
		<MLL,W>,-	; Maximum logical links active
		<APL,B>,-	; Aged packet loss
		<NUL,W>,-	; Node unreachable packet loss
		<NOL,B>,-	; Node out-of-range packet loss
		<OPL,B>,-	; Oversized packet loss
		<PFE,B>,-	; Packet format error
		<RUL,B>,-	; Partial routing update loss
		<VER,B>,-	; Verification rejects
	-;	<XRE,W>,-	; Xmitted connect resource errors 
    >

LPD_CNT_TAB:			; Circuit counter formatting table

    $COUNT_TAB	LPD$L_ABS_TIM,CTCIR,LPD,CNT_,-
		<-
		<APR,L>,-	; Arriving packets received	
		<DPS,L>,-	; Departing packets sent
		<ACL,W>,-	; Arriving congestion loss
		<TPR,L>,-	; Transit packets received
		<TPS,L>,-	; Transit packets sent
		<TCL,W>,-	; Transit congestion loss
		<LDN,B>,-	; Line down events
		<IFL,B>,-	; Initialization failures
    >

PLI_CNT_TAB:			; Line counter formatting table

    $COUNT_TAB	,,,,		; Currently only "seconds since last zeroed"
				; is maintained outside the driver


;
;  Build a table to driver the translation between Network Management (NICE)
;  device names to VMS devices names and to supply miscellaneous information
;  about known devices
;
NMA$C_LINPR_ == -1			; Define protocol type for protocols
					; not defined by the NICE protocol

MAX_C_DEVNAM = 15			; Maximum device name string
					; (dev-c-u.t)

.MACRO	.devtrn	netman,vms,prot,char	; Create table entry

	$$devtrn = .			; Remember where we are
	.ascic	"NETMAN"		; Enter Net Man device mnemonic
	. = $$devtrn + devtrn$b_vms	; Advance to next field
	.ascic	"VMS"			; Enter VMS device mnemonic
	. = $$devtrn + devtrn$b_dev	; Advance to next field
	.if nb,NETMAN			; Enter code for device		
		.byte	devtrn$c_dev_'NETMAN'
	.iff
		.byte	devtrn$c_dev_unk
	.endc
	. = $$devtrn + devtrn$b_prot	; Advance to next field
	.byte	nma$c_linpr_'PROT'	; Enter default protocol type
	. = $$devtrn + devtrn$b_char	; Advance to device characteristics
	.if nb,char			; Enter device characteristics
		.byte	devtrn$m_'CHAR'
	.iff
		.byte	0
	.endc
	. = $$devtrn + devtrn$c_length	; Advance to next table entry

.ENDM	.devtrn

DEVTRN_TABLE:				; Device translation table

	.devtrn	<DMC>, <XM>, <DMC>, <>		; DMC-11
	.devtrn	<DMP>, <XD>, <CON>, <>		; DMP-11
	.devtrn	<PCL>, <XP>, <CON>, <>		; PCL-11
	.devtrn	<DUP>, <XW>, <LAP>, <>		; DUP-11
	.devtrn	<DMF>, <XG>, <POI>, <>		; DMF-11 (combo board)
	.devtrn <CI>,  <CN>, <>,    <>		; CI-780
	.devtrn	<>,    <>  , <>,    <MULTI>	; Terminate the table with
						; foreign device entry
	.ALIGN	LONG

;
;  The following tables contain a list of parameters which need to be cleared
;  in a given (PLI or CRI) CNF block before that block is process for a "show"
;  QIO.  The reason for this is that the parameters are maintained by the 
;  device driver and the copy of this information stored in the CNF is stale.
;
PLI_CLR_TAB:	.LONG	0		; Terminate the table

CRI_CLR_TAB:	.CNFFLD	cri,l,PLS	; Polling sub-state
		.LONG	0		; Terminate the table


;
;  Build the tables which drive QIO parameter buffer translation.  The QIO 
;  parameter buffers are stored in NICE protocol format.
;
$VIELD	CNVTAB,0,<-			; Define conversion table enter
		  <NMA,16,M>,-		; NICE protocol param i.d.
		  <INT,14,M>,-		; Internal parameter index
		  <FMT, 2,M>,-		; Parameter format (string,value,etc)
	>

.MACRO	.cnvtab	nma,db,param		; Insert parameter i.d. table entry

	.LONG   <<nma$c_'nma'_'param'>            @ <cnvtab$v_nma>> -
	      + <<nfb$c_'db'_'param' & nfb$m_inx> @ <cnvtab$v_int-nfb$v_inx>> -
	      + <<nfb$c_'db'_'param' & nfb$m_typ> @ <cnvtab$v_fmt-nfb$v_typ>> 
.ENDM

CRI_TRN_TAB:				; NICE-internal param i.d. translation
;& na		.cnvtab	pcci,cri,BLK	; Blocking allowed/disallowed switch
		.cnvtab	pcci,cri,MRC	; Max recalls
		.cnvtab	pcci,cri,RCT	; Recall timer
		.cnvtab	pcci,cri,POL	; Polling state
		.cnvtab	pcci,cri,PLS	; Polling sub-state
		.cnvtab	pcci,cri,TYP	; Protocol type
		.cnvtab	pcci,cri,USE	; X.25 usage
		.cnvtab	pcci,cri,CHN	; X.25 channel
		.cnvtab	pcci,cri,MBL	; Maximum block
		.cnvtab	pcci,cri,MWI	; Maximum window
		.cnvtab	pcci,cri,TRI	; Tributary station address
		.cnvtab	pcci,cri,BBT	; Babbel timer
		.cnvtab	pcci,cri,TRT	; Transmit timer
		.cnvtab	pcci,cri,MRB	; Maximum receive buffers
;&nyi		.cnvtab	pcci,cri,MTR	; Maximum retransmits
		.cnvtab	pcci,cri,ACB	; Active base
		.cnvtab	pcci,cri,ACI	; Active increment
		.cnvtab	pcci,cri,IAB	; Inactive base
		.cnvtab	pcci,cri,IAI	; Inactive increment
		.cnvtab	pcci,cri,IAT	; Inactive threshold
		.cnvtab	pcci,cri,DYB	; Dying base
		.cnvtab	pcci,cri,DYI	; Dying increment
		.cnvtab	pcci,cri,DYT	; Dying threshold
		.cnvtab	pcci,cri,DTH	; Dead treshold
		.cnvtab	pcci,cri,MST	; Maintenance mode state
		.LONG	0		; Terminate the table


PLI_TRN_TAB:				; NICE-internal param i.d. translation
		.cnvtab	pcli,pli,BUS	; Receive buffer size
		.cnvtab	pcli,pli,DUP	; Duplex mode
		.cnvtab	pcli,pli,CON	; Controller (loopback) mode
		.cnvtab	pcli,pli,CLO	; Clock mode
		.cnvtab	pcli,pli,PRO	; Protocol
		.cnvtab	pcli,pli,HTI	; LAPB holdback timer
		.cnvtab	pcli,pli,MBL	; LAPB maximum block
		.cnvtab	pcli,pli,MRT	; LAPB maximum retransmits
		.cnvtab	pcli,pli,MWI	; LAPB maximum window
		.cnvtab	pcli,pli,SLT	; Scheduling timer
		.cnvtab	pcli,pli,DDT	; Dead timer
		.cnvtab	pcli,pli,DLT	; Delay timer
		.cnvtab	pcli,pli,SRT	; Stream timer
		.cnvtab	pcli,pli,BFN	; Number of buffers in pool
		.cnvtab	pcli,pli,RTT	; Retransmit timer
		.LONG	0		; Terminate the table


	.PSECT	NET_LOCK_IMPURE,WRT,EXE,LONG	;! the EXE attribute is to
						;! keep the locked .psects
						;! contiguous


UNAMES:		.LONG	0		; Returns resultant user name length
UNAME:		.BLKB	12		; Returns user name
PNAMES:		.LONG	0		; Returns resultant process name length
PNAME:		.BLKB	16		; Returns process name
		.ALIGN	LONG

TMPBUF_DESC:	.LONG	TMP_LTH		; Descriptor of TMP_BUF for QIO calls
		.LONG	TMP_BUF		;

ITEM_LIST:				; $GETJPI item list for logical links
		.WORD	12		; Size of username buffer
		.WORD	JPI$_USERNAME	; I.d. of username parameter
		.LONG	UNAME		; Address of username buffer
		.LONG	UNAMES		; Address of buffer to return length

		.WORD	15		; Size of process name buffer
		.WORD	JPI$_PRCNAM	; I.d. of process name parameter
		.LONG	PNAME		; Address of process name buffer
		.LONG	PNAMES		; Address of buffer to return length

		.LONG	0		; Terminate the list


			ASSUME  TMP_LTH  GE 255
NET$T_PRSNAM:	$NAM	ESS =  255
NET$T_SYSFAB:	$FAB	DNM = <SYS$SYSROOT:[SYSEXE].COM>,-
			NAM =  NET$T_PRSNAM
NET$T_TSKFAB:	$FAB	DNM = <.COM>,-
			NAM =  NET$T_PRSNAM

		.ALIGN	LONG

PLI_B_STATE:	.LONG	0		; Device state
PLI_Q_DEVNAM:	.QUAD	0		; Device name descriptor

		DEVNAM_C_SIZ = 32	; Size of SEARCH and START key buffers
					; for line and circuit names

SRCH_BUF:	.BLKB	DEVNAM_C_SIZ	; Optional SEARCH KEY buffer
STRT_BUF:	.BLKB	DEVNAM_C_SIZ	; Optional START KEY buffer
		.ALIGN	LONG



QIOW_Q_IOSB:	.QUAD	0		; General QIOW IOSB
TMP_Q_DESC:	.QUAD	0		; Scratch descrirptor
TMP_B_FLAGS:	.LONG	0		; TMP_VAL, TMP_BUF in use flags:
TMP_V_VAL	= 0			;  TMP_VAL in use
TMP_V_BUF	= 1			;  TMP_BUF in use

TMP_VAL:	.LONG	0		; Tmp storage for returned value
					; and for "short" decriptor of TMP_BUF
					; when returning strings
TMP_BUF:	.BLKB	TMP_LTH		; Buffer for returning strings
TMP_BUF_END:				; Address of first byte past buffer
		.LONG	0		; Leave an extra longword



	.PSECT	NET_LOCK_CODE,NOWRT,EXE,LONG 
;
;  ***  These routines must be abortable via a RET  ***
;
;  ***  The CNF$_QUIT option must return 0 in R10   ***
;

NET$SCAN_LNI::				; Local node CNF scanner co-routine
NET$SCAN_OBI::				; Object CNF scanner co-routine
NET$SCAN_EFI::				; Event filter CNF scanner co-routine
NET$SCAN_ESI::				; Event sink CNF scanner co-routine
NET$SCAN_CRI::				; Circuit CNF scanner co-routine
NET$SCAN_PLI::				; Physical line CNF scanner co-routine
DEFAULT_SCAN::				; Default CNF scanner co-routine

	ASSUME	CNF$L_FLINK  EQ  0
	ASSUME	CNF$L_FLINK  EQ  CNR$L_FLINK
	ASSUME	CNF$B_FLG    EQ  CNR$B_FLG

	TSTL	R10			; Already pointing to a CNF ?
	BNEQ	10$			; If NEQ then yes
	MOVAB	CNR$L_FLINK(R11),R10	; Get address of ptr to 1st CNF
10$:	MOVL	#1,R0			; Indicate success
20$:	JSB	@(SP)+			; Call back our caller
	$DISPATCH  R0,<-

	    <CNF$_ADVANCE,   30$>	-; Advance to next CNF, continue dialogue
	    <CNF$_TAKE_PREV, 40$>	-; Return previous CNF, abort dialogue
	    <CNF$_QUIT,      50$>	-; CNF not found, abort dialogue
	    <CNF$_TAKE_CURR, 60$>	-; Take current CNF, abort dialogue
	>	
	BUG_CHECK	NETNOSTATE,FATAL

30$:	MOVL	CNF$L_FLINK(R10),R10	; Advance to next CNF
	BBC	#CNF$V_FLG_CNR,-	;
		    CNF$B_FLG(R10),10$	; If BC then R10 is not the CNR
	CLRL	R0			; Say "no more CNFs"
	BRB	20$			; Call back with the bad news
40$:	MOVL	CNF$L_BLINK(R10),R10	; Go back to previous CNF
	BRB	60$			; Continue
50$:	CLRL	R10			; Nullify CNF pointer
60$:	RSB				; Return to caller, terminate dialogue


;+
; NET$SCAN_NDI
;
;-
NET$SCAN_NDI::				; Find next NDI block
	
	ASSUME	CNF$L_FLINK  EQ  0
	ASSUME	CNF$L_FLINK  EQ  CNR$L_FLINK
	ASSUME	CNF$B_FLG    EQ  CNR$B_FLG

	BBS	#NET$V_INTRNL,-		    ; If BS then internal and not 
		W^NET$GL_FLAGS,DEFAULT_SCAN ; interested in "phantom" NDI CNFs
	;
	;
	;   Initialize "last CNF" pointer.  This is the pointer to the last
	;   CNF processed and may actually be the CNR.
	;
	TSTL	R10			; Is there a current NDI
	BNEQ	5$			; If NEQ then yes
	MOVL	R11,R10			; Else start at the head of the list
	;
	;
	;   Engage in a co-routine dialogue with the user.  The scanner half
	;   of the dialogue owns the stack until the calling routine calls
	;   back with any function code other than CNF$_ADVANCE;  the other
	;   function codes causes the scanner to return to the caller with a
	;   clean stack thus terminating the co-routine dialogue.
	;
5$:	PUSHL	R2			; Save reg to share code at 20$
10$:	MOVL	#1,R0			; Indicate success
20$:	POPL	R2			; Restore reg
	JSB	@(SP)+			; Call back the caller
	PUSHL	R2			; Save reg
	MOVL	W^NET$GL_PTR_VCB,R2	; Get RCB pointer
	$DISPATCH  R0,-			; Dispatch on function code returned by
	<-				; co-routine
	    <CNF$_ADVANCE,   100$>,-	; Advance to next CNF, continue dialogue
	    <CNF$_TAKE_PREV, 200$>,-	; Return previous CNF, abort dialogue
	    <CNF$_QUIT,      300$>,-	; CNF not found, abort dialogue
	    <CNF$_TAKE_CURR, 400$>,-	; Take current CNF, abort dialogue
	>	
	BUG_CHECK	NETNOSTATE,FATAL

100$:	;
	;
	;   Advance to the next CNF.
	;
	CLRL	R0			; Init the node address	
	BBS	#CNF$V_FLG_CNR,-	;
		     CNF$B_FLG(R10),120$; If BS then at head of list
	BBS	#NDI_V_LOOP,-		; If BS then last node was a loop node
		     CNF$B_FLG(R10),180$; -- use linked list scan
	MOVZWL	CNF$W_ID(R10),R0	; Get this node address
110$:	INCW	R0			; Get next node address
	CMPW	R0,RCB$W_ADDR(R2)	; Is this the local node?
	BEQL	110$			; If so skip (it's represented in this
					;  data base as node 0)
	CMPW	R0,RCB$W_MAX_ADDR(R2)	; Compare against maximum
	BGTRU	150$			; If GTRU then out of range
120$:	MOVL	W^NET$AL_NDI_VEC[R0],R10; Get the CNF address
	BBC	#CNF$V_FLG_ACP,-	;
		     CNF$B_FLG(R10),10$	; If BC then "real" CNF
	TSTB	@RCB$L_DSP_OL(R2)[R0]	; Is it reachable?
	BEQL	110$			; If EQL then unreachable
	MOVW	R0,NDI_ADD(R10)		; Stuff the address
	MOVW	R0,CNF$W_ID(R10)	; Here too
130$:	BRB	10$			; Call back caller with success
150$:	;
	;
	;   Make the transition from using the NDI vector to using the CNF
	;   linkage in order to scan the database.  This is done since we must
	;   now scan the "loop" node portion of the database -- "loop" nodes
	;   are not entered into the NDI vector.  Since "loop" nodes are 
	;   inserted at the end of the list, scan backwards until the first 
	;   non-"loop" node is found and fall thru to continue the search.
	;
	MOVL	R11,R10			; Point to head of list
160$:	MOVL	CNF$L_BLINK(R10),R10	; Scan backwards 
	BBS	#CNF$V_FLG_CNR,-	; If BS then at head of list, there are
		     CNF$B_FLG(R10),190$; no unscanned CNFs left in the database
	BBS	#NDI_V_LOOP,-		; If BS then loop node
		     CNF$B_FLG(R10),160$;
180$:	;
	;   Scan the "loop" node section of the database.  These CNFs are in
	;   the linked list but are not found in the NET$AL_NDI_VEC list.
	;
	MOVL	CNF$L_FLINK(R10),R10	; Advance to next CNF
	BBC	#CNF$V_FLG_CNR,-	; If BC then CNF is not the CNR,
		     CNF$B_FLG(R10),130$; return success
190$:	CLRL	R0			; Else say "no more CNFs"
	BRW	20$			; Tell caller the bad news

200$:	;
	;   The caller wants to take the previous CNF
	;
	MOVZWL	CNF$W_ID(R10),R0	; Get the node address
	BBC	#NDI_V_LOOP,-		; If BC this NDI is not a loop node
		    CNF$B_FLG(R10),270$	;
	MOVL	CNF$L_BLINK(R10),R10	; Go back to previous CNF
	BBS	#NDI_V_LOOP,-		; If BS then previous NDI was loop node
		    CNF$B_FLG(R10),400$	;
	MOVZWL	RCB$W_MAX_ADDR(R2),R0	; Get max address
260$:	MOVL	NET$AL_NDI_VEC[R0],R10	; Get the NDI with this i.d.
	BBC	#CNF$V_FLG_ACP,-	; If BC then "real" CNF
		    CNF$B_FLG(R10),400$	;
	MOVW	R0,NDI_ADD(R10)		; Stuff the address
	MOVW	R0,CNF$W_ID(R10)	; Here too
	TSTB	@RCB$L_DSP_OL(R2)[R0]	; Is the node reachable?
	BNEQ	400$			; If NEQ then yes, we've found the NDI
270$:	SOBGEQ	R0,260$			; Loop with previous node i.d.
	MOVL	R11,R10			; No more NDI's, return the CNR in R10
	BRB	400$			; Take common exit

300$:	CLRL	R10			; Nullify CNF pointer
400$:	;
	;   The caller is done with the scan and wants the stack back.
	;
	POPL	R2			; Restore the reg
	RSB				; Return to caller

NET$SCAN_LLI::				; Logical-link scanner co-routine
	TSTL	R10			; Already pointing to a CNF ?
	BEQL	5$			; If EQL no, point to common CNF
	CMPL	R11,R10			; At head of list ?
	BNEQ	10$			; If NEQ no, assume R10 is valid
5$:	MOVAB	NET$T_CNF_LLI,R10	; Get address of internal XWB storage
	CLRW	CNF$W_ID(R10)		; Init link index
	CLRW	LLICNF$W_LAST_ID(R10)	; Here too
10$:	MOVL	#1,R0			; Indicate success
20$:	JSB	@(SP)+			; Call back our caller
	$DISPATCH  R0,<-

	    <CNF$_ADVANCE,   30$>	-; Advance to next CNF, continue dialogue
	    <CNF$_TAKE_PREV, 40$>	-; Return previous CNF, abort dialogue
	    <CNF$_QUIT,      50$>	-; CNF not found, abort dialogue
	    <CNF$_TAKE_CURR, 60$>	-; Take current CNF, abort dialogue
	>	
	BUG_CHECK	NETNOSTATE,FATAL

30$:	PUSHL	R6			; Save reg
	MOVL	#1,R6			; Say "get next XWB"
	MOVZWL	CNF$W_ID(R10),R0	; Get link index
	MOVW	R0,LLICNF$W_LAST_ID(R10); Save it
	BSBB	GET_XWB			; Get/copy next XWB
	POPL	R6			; Restore reg
	BRB	20$			; Call back with status in R0

40$:	MOVZWL	LLICNF$W_LAST_ID(R10),R0; Go back to previous link index
	BNEQ	55$			; If EQL then no previous link exists
	MOVL	R11,R10			; Make CNF point to the root
	BRB	60$			; Done
55$:	PUSHL	R6			; Save reg
	CLRL	R6			; Say "don't advance"
	BSBB	GET_XWB			; Get/copy the XWB
	POPL	R6			; Restore reg
	BRB	60$			; Take common exit
50$:	CLRL	R10			; Nullify CNF pointer
60$:	RSB				; Return to caller, terminate dialogue


GET_XWB:				; Locate XWB via index in R0
	PUSHR	#^M<R1,R2,R3,R4,R5>	; Save regs
	MOVL	NET$GL_PTR_VCB,R1	; Get the RCB address
	MOVL	RCB$L_PTR_LTB(R1),R1	; Get the LTB address
	MOVAB	LTB$L_XWB-XWB$L_LINK(R1),R5 ; Assume link index 0
	BICL	#^C<NET$M_MAXLNKMSK>,R0	; Get link index bits
	BEQL	10$			; If EQL then just starting scan
	MOVL	LTB$L_SLOTS(R1)[R0],R5	; Get the XWB
	BLBC	R6,20$			; If LBC then don't advance to next XWB
10$:	MOVL	XWB$L_LINK(R5),R5	; Get next XWB
	BEQL	60$			; If EQL then none left
20$:	MOVW	XWB$W_LOCLNK(R5),-	;
		    CNF$W_ID(R10)	; Save link address
	MOVC3	#XWB$C_COMLNG,(R5),-	; Copy the pertinent part of the XWB
		    CNF$C_LENGTH(R10)	;
	MOVAB	LLICNF$AW_ACT_PRM,R0	; Point to active field index list
30$:	MOVZWL	(R0)+,R1		; Get next field index
	BEQL	50$			; If EQL then done
	BBSS	R1,CNF$T_MASK(R10),30$	; Mark field active
	BRB	30$			; Loop
50$:	MOVL	#1,R0			; Set 'success'
	BRB	70$			; Take common exit
60$:	CLRL	R0			; Indicate failure
70$:	POPR	#^M<R1,R2,R3,R4,R5>	; Restore regs
	RSB


NET$PRE_QIO_LNI::			;
NET$PRE_QIO_NDI::			;
NET$PRE_QIO_OBI::			;
NET$PRE_QIO_EFI::			;
NET$PRE_QIO_ESI::			;
NET$PRE_QIO_LLI::			;
	MOVL	S^#SS$_NORMAL,R0	; Indicate success
	RSB





NET$PRE_QIO_CRI::			;
	$CNFFLD	cri,s,nam,R9		; Get circuit name field i.d.
	BRB	PREQIO_PRI_CRI		; Continue in common


NET$PRE_QIO_PLI::			;
	$CNFFLD	pli,s,nam,R9		; Get line name field i.d.
					; Fall thru to common code
PREQIO_PRI_CRI:
	;
	;   Rebuild SEARCH key if needed
	;
	CMPL	R9,W^NET$GL_SRCH_ID	; Is the SEARCH key the name?
	BNEQ	100$			; If NEQ no
	MOVQ	W^NET$GQ_SRCH_KEY,R7	; Get the SEARCH KEY descriptor
	MOVAB	SRCH_BUF,R3		; Point to the SEARCH KEY buffer
	MNEGL	R3,W^NET$GQ_SRCH_KEY	; Prepare for size calculation
	MOVL	R3,W^NET$GQ_SRCH_KEY+4	; Point to new SEARCH KEY string
	BSBW	REBUILD_NAME		; Rebuild the circuit name
	BLBC	R0,210$			; If LBC then error in name
	ADDL	R3,W^NET$GQ_SRCH_KEY	; Calculate size of the string
100$:	;
	;   Rebuild START key if needed
	;
	CMPL	R9,W^NET$GL_STRT_ID	; Is the START key the name?
	BNEQ	200$			; If NEQ no
	MOVQ	W^NET$GQ_STRT_KEY,R7	; Get the START KEY descriptor
	MOVAB	STRT_BUF,R3		; Point to the START KEY buffer
	MNEGL	R3,W^NET$GQ_STRT_KEY	; Prepare for size calculation
	MOVL	R3,W^NET$GQ_STRT_KEY+4	; Point to new START KEY string
	BSBW	REBUILD_NAME		; Rebuild the circuit name
	BLBC	R0,210$			; If LBC then error in name
	ADDL	R3,W^NET$GQ_STRT_KEY	; Calculate string size
200$:	MOVL	S^#SS$_NORMAL,R0	; Indicate success
210$:	RSB				; Return status in R0


REBUILD_NAME:				; Rebuild the name to canonical form
	;
	;   Rebuild the device name so that it is of the form:
	;
	;    	'dev-c-u.t'  or  'dev-c-u'     for multiplexed device types
	;
	;	'dev-c.t'    or  'dev-c'       for non-multiplexed device types
	;
	;
	;
	CMPL	R7,#DEVNAM_C_SIZ	; Output name will be LEQ input name,
	BGTRU	40$			; If GTRU unsigned then may oveflow buf
	;
	;   Move the device mnemonic and locate the device table entry
	;
	BSBW	PRS_MNEMONIC		; Parse name, locate the table entry
	BLBC	R0,40$			; If LBC the error
	MOVC3	R5,(R4),(R3)		; Enter the Net. Man. device mnemonic
	;
	;   Move the controller i.d. -- suppress leading zeroes.  If the device
	;   is not a "MULTI-plexed" device then the units field may not be
	;   present and the name may be end with the controller specifier field
	;   or it may end with either the units field or the tributary field or
	;   both.  If the device is "MULTI-plexed" then the name must contain
	;   at least the units field following the controller specifier field.
	;
	MOVZBL	#^A"-",R4		; Setup the field delimiter
	MOVB	R4,(R3)+		; Enter it into the output buffer
	BBS	#DEVTRN$V_MULTI,-	; If BS then multi-unit device
		 DEVTRN$B_CHAR(R6),10$	;
	MOVQ	R7,R0			; Copy string descriptor
5$:	DECL	R0			; Any characters left
	BLSS	10$			; If LSS then no
	CMPB	#^A"-",(R1)		; Delimited by a "-" ?
	BEQL	10$			; If EQL yes
	CMPB	#^A".",(R1)+		; Delimited by a "." ?
	BNEQ	5$			; If NEQ then keep trying
	MOVZBL	#^A".",R4		; Reset delimiter for parse
10$:	BSBW	PRS_DECIMAL		; Get binary value of controller
	BLBC	R0,40$			; If LBC then error
	TSTL	R2			; Any decimal characters parsed?
	BEQL	40$			; If EQL no, error in name
	MOVL	R1,R0			; Setup binary value to be converted
	BSBW	NET$BIN2ASC		; Convert to ascii and insert
	;
	;   Move the unit number  -- suppress leading zeros.
	;
	BBS	#DEVTRN$V_MULTI,-	; If BS then multi-unit device
		 DEVTRN$B_CHAR(R6),50$	;
	;
	;   Single unit device -- verify unit number is zero but don't move it
	;
	CMPB	#^A".",R4		; Did we already rule out a unit field?
	BEQL	70$			; If EQL then yes
	MOVZBL	#^A".",R4		; Setup the field delimiter
	BSBW	PRS_DECIMAL		; Get binary unit number
	BLBC	R0,100$			; If LBC then error
	TSTL	R1			; Single unit device, is it unit 0?
	BEQL	70$			; If EQL yes, process tributary field
40$:	BRB	100$			; Else error in name
50$:	;				
	;   Device is a multi-unit device, move unit number field
	;
	MOVB	#^A"-",(R3)+		; Enter prefix to unit number field
	MOVZBL	#^A".",R4		; Setup the field delimiter
	BSBW	PRS_DECIMAL		; Get binary unit number
	BLBC	R0,100$			; If EQL then error
	TSTL	R2			; Any decimal characters parsed?
	BEQL	100$			; If EQL then error
	MOVL	R1,R0			; Get binary value for ascii conversion
	BSBW	NET$BIN2ASC		; Move as ascii @R3
70$:	;
	;   Process the tributary field.  If this is the CRI database then move
	;   the remainder of the name (unfortunately we cannot determine if a
	;   tributary specifier is valid for this device yet since we cannot 
	;   determine for sure if the device is to be run in the multi-drop or
	;   point-to-point mode until later on in the QIO cycle).
	;
	CMPB	#NFB$C_DB_CRI,-		; Circuit database ?
		    CNR$B_TYPE(R11)	; 
	BEQL	80$			; If EQL yes
	TSTL	R7			; Else there must be no characters left
	BNEQ	100$			; If NEQ then illegal name
80$:	TSTL	R7			; Any characters left?
	BEQL	90$			; If EQL no, return success
	MOVB	#^A".",(R3)+		; Enter delimiter
	MOVC3	R7,(R8),(R3)		; Enter remaining characters, update R3
90$:	MOVL	S^#SS$_NORMAL,R0	; Indicate success
	BRB	110$			; Take common exit

100$:	MOVZWL	#SS$_IVDEVNAM,R0	; Indicate invalid device name
110$:	RSB				; Return status in R0

NET$SHOW_LNI::				; "Show" QIO pre-processing for one CNF
NET$SHOW_NDI::				;
NET$SHOW_OBI::				;
NET$SHOW_EFI::				;
NET$SHOW_ESI::				;
NET$SHOW_LLI::				;
	MOVL	S^#SS$_NORMAL,R0	; Indicate success
	RSB

NET$SHOW_CRI::				; "Show" QIO pre-processing for one CNF
	CLRL	R3			; Assume no I/O channel
	BSBW	NET$LOCATE_LPD		; Get LPD associated with this CRI
	BLBC	R0,10$			; If EQL then none
	MOVZWL	LPD$W_CHAN(R6),R3	; Get I/O channel
10$:	MOVZWL	#IO$_SENSEMODE,R4	; Get I/O function code
	MOVAB	CRI_CLR_TAB,R5		; Get table of params to clear
	MOVAB	CRI_TRN_TAB,R6		; Get table for NICE param translation
	BRB	SHO_PLI_CRI		; Pre-process the CRI CNF block

NET$SHOW_PLI::				; "Show" QIO pre-processing for one CNF
	CLRL	R3			; Assume no I/O channel
	MOVZWL	CNF$W_ID(R10),R0	; Get PLVEC index
	BEQL	10$			; If EQL then none assigned
	MOVW	PLVEC$AW_CHAN[R0],R3	; Get I/O channel
10$:	MOVW	#IO$_SENSEMODE!IO$M_CTRL,R4 ; Get QIO function code
	MOVAB	PLI_CLR_TAB,R5		; Get table of params to clear
	MOVAB	PLI_TRN_TAB,R6		; Get table for NICE param translation
					; Fall thru to pre-process PLI CNF

SHO_PLI_CRI:				;
10$:	MOVL	(R5)+,R9		; Get next parameter i.d.
	BEQL	20$			; If EQL then none left
	BSBW	CNF$CLR_FIELD		; Clear param in CNF, ignore errors
	BRB	10$			; Loop
	;
	;   Get a list of parameters from the driver
	;
20$:	CLRQ	QIOW_Q_IOSB		; Init IOSB image
	$QIOW_S	-			; Issue QIO to get device info
		EFN  = #NET$C_EFN_WAIT,-
		CHAN = R3,-
		FUNC = R4,-
		IOSB = QIOW_Q_IOSB,-
		P2   = #TMPBUF_DESC	
					; Ignore errors
	BLBC	R0,100$			; If LBC assume unsupported by driver
	BLBC	QIOW_Q_IOSB,100$	; If LBC assume unsupported by driver
	MOVL	TMPBUF_DESC+4,R4	; Point to parameter list
	BSBB	JAM_CNF			; Stuff the params into the PLI block
	BRB	110$			; Take common exit
100$:	MOVL	#1,R0			; Report success
110$:	RSB				; Return status in R0

JAM_CNF:
	;
	;   Jam the values from the QIO buffer one at time into the CNF block.
	;
	MOVL	#1,R0			; Assume we're done
	TSTW	QIOW_Q_IOSB+2		; Any params left?
	BEQL	100$			; If EQL we're done
	CLRL	R0			; Assume error
	BSBB	TAKE_2_IOSB		; See if we have two bytes left
	MOVZWL	(R4)+,R2		; Get NICE protocol param i.d.
	MOVL	R6,R5			; Point to translation table
	BSBW	CVT_NMA_INT		; Convert NMA i.d. to internal i.d.
	BLBC	R0,100$			; If LBC then not found
	CMPZV	#NFB$V_TYP,#NFB$S_TYP,R9,#NFB$C_TYP_STR	; Is it a string ?
	BEQL	50$			; If EQL yes
	;
	;   It's a longword
	;
	MOVL	#4,R7			; We'll take 4 more bytes
	BSBB	TAKE_R7_IOSB		; Deplete IOSB count
	MOVL	(R4)+,R8		; Get the value
	BRB	60$			; Continue
	;
	;   It's a string
	;
50$:	BSBB	TAKE_2_IOSB		; Account for count field
	CVTWL	(R4)+,R7		; Get string size
	BLSS	100$			; If LSS then string is too long
	MOVL	R4,R8			; Point to string
	ADDL	R7,R4			; Skip over it
	BSBB	TAKE_R7_IOSB		; Deplete bytes for string
60$:	BSBW	CNF$PUT_FIELD		; Store it in the CNF
	BLBS	R0,JAM_CNF		; If LBS okay, loop
100$:	RSB				; Return status in R0

TAKE_2_IOSB:
	MOVZWL	#2,R7			; Setup bytes to take
TAKE_R7_IOSB:
	SUBW	R7,QIOW_Q_IOSB+2	; Deplete bytes
	BGEQ	10$			; If GEQ then okay
	CLRL	R0			; Indicate error
	TSTL	(SP)+			; Pop caller's return address
10$:	RSB



;+
; NET$APPLY_DFLT  -  Apply default values to selected CNF parameters.
;
; This routine is called by CNF$INSERT just prior to validating a CNF
; entry which is to be inserted into the database.  Its purpose is to
; supply default values to selected parameters.
;
; INPUTS:	R11	CNR pointer
;		R10	CNF pointer
;
; OUTPUTS:	R11	CNR pointer
;		R10	CNF pointer
;		R0	SS$_NORMAL -- this routine always succeeds.
;
;		All other registers contain garbage.
;-
NET$APPLY_DFLT::			; Apply default CNF parameter values
	MOVZBL	CNR$B_TYPE(R11),R0	; Get database i.d.
	MOVL	NET$AL_CNF_DFLT[R0],R6	; Get parameter id,value table
	;
	;
	;   Dispatch on database type.  This dispatching is not really needed
	;   yet, but it will be if special processing becomes necessary -- for
	;   instance, different circuit types may require different defaults.
	;
	;
	$DISPATCH  R0,-			; Dispatch on database type
	<-				;
	    <NFB$C_DB_CRI, 10$>,-	; Circuit database
	>				;
					; All others fall thru
10$:	MOVL	(R6)+,R9		; Get parameter i.d., advance R6
	BEQL	50$			; Done if EQL
	BSBW	CNF$GET_FIELD		; See if field is already setup
	MOVL	(R6)+,R8		; Get parameter value, advance R6
	BLBS	R0,10$			; If LBS the no need for default
	BSBW	CNF$PUT_FIELD		; Store it in the CNF
	BRB	10$			; Ignore errors
50$:	MOVL	S^#SS$_NORMAL,R0	; Always successful
	RSB				; Done



NET$INSERT_LNI::
	;
	;   Make sure that there are no NDI entries with the new LNI node
	;   address.  Refer to NET$INSERT_NDI for more information.
	;
	$GETFLD	lni,l,add		; Get the node address 
	BLBC	R0,40$			; If LBC then report bad node address
	CMPL	R8,#NET$C_MAX_NODES	; Does the NDI vector support this node
	BGTRU	40$			; If GTRU report bad address parameter
	TSTL	R8			; Has the address been set yet?
	BEQL	30$			; If EQL then no, skip the next check
	MOVZWL	#SS$_DEVACTIVE,R0	; Assume address is used elsewhere
	CMPL	W^NET$AL_NDI_VEC[R8],-	; Is there a node entry with this 
		W^NET$GL_DUM_NDI	; address ?
	BNEQ	50$			; If NEQ report address already in use
	;
	;
	;   Update the ACP control layer
	;
	;	Inputs:	 R11	LNI CNR pointer
	;		 R10	New LNI CNF pointer
	;
	;	Outputs: R9	I.D. of faulty parameter if LBC in R0
	;		 R0	Status
	;
	;		 All other regs may be clobbered.
	;
	;
30$:	BSBW	W^NET$UPD_LOCAL		; Make ACP transistion
	BRB	50$			; Return status in R0
40$:	MOVZWL	S^#SS$_BADPARAM,R0	; Indicate error
50$:	RSB

			.ENABL	LSB
NET$INSERT_NDI::
	;
	;   Use this opportunity to keep the NDI and LNI databases consistent
	;   by using the following rules.  These rules are needed because the
	;   the local node address exists in both data bases.  By forcing the
	;   address of the local node NDI and all loop nodes to be zero and by
	;   using a zero NDI node address to implicitly refer to the RCB$W_ADDR
	;   value, changing the local node address in the LNI data base will
	;   automatically update the addresses of the peritinent NDI entries.
	;   The fact that the local node's address is stored as zero throughout
	;   the NDI data base is used throughout the ACP -- it will be very 
	;   difficult to modify the design.
	;
	;	Upon new NDI insertion:
	;
	;		1. if   new NDI node address = RCB$W_ADDR
	;		   then zero the NDI node address
	;
	;		2. if   old NDI node address = 0
	;		   then
	;			if   new NDI node address NEQ 0
	;			then error
	;
	;	Upon new LNI insertion:  (see UPD_LOCAL above)
	;
	;		1. if   new LNI node address exists anywhere in the
	;		        NDI data base
	;		   then error
	;
	MOVL	R10,R5			; Save the new NDI
	BICB	#<1@NDI_V_LOCAL>!-	; Init special flags
		 <1@NDI_V_LOOP>,-	;
		CNF$B_FLG(R5)		;
	BSBW	CHK_LOGIN_NDI		; Check default login strings for
					; combined length
	BLBC	R0,5$			; If LBC then too long
	MOVL	R4,W^NDI_L_NACS		; Remember number of non-null access
					; control strings
	$GETFLD	ndi,s,nna   		; Get the node name descriptor
	MOVQ	R7,W^NDI_Q_NAME		; Save it
	$GETFLD	ndi,l,add		; Get new node address
	BLBC	R0,35$			; If LBC then field is missing
	MOVL	W^NET$GL_PTR_VCB,R2	; Get the RCB pointer
	CMPW	R8,RCB$W_MAX_ADDR(R2)	; Check against max allowed address
	BGTRU	30$			; If GTRU then out of range
	CMPW	R8,RCB$W_ADDR(R2)	; Is it the local node?
	BNEQ	10$			; If NEQ no
	CLRL	R8			; Local node is stored in the NDI data
	BSBW	CNF$PUT_FIELD		; base as zero
	BLBS	R0,10$			; If LBS, continue
	MOVZWL	#SS$_INSFMEM,R0		; Report "insufficient memory"
5$:	BRW	220$			; Take common exit
10$:	MOVW	R8,CNF$W_ID(R5)		; Save the new NDI node address
	;
	;   A "loop" node is an NDI for which an output line has been permanently
	;   assigned in the database.  Such an NDI must have a name field 
	;   (ndi,s,nna) specified and, for now, must have the node address of 
	;   the local node.  By creating a logical link to this nodename, the 
	;   link is made to the local node but all traffic is transmitted over
	;   the specified line.  The intent of "loop" nodes is to allow loopback
	;   testing of a line or the testing of the transport layer on the node
	;   at the other end of the line.
	;
	;   A "loop" node NDI cannot be converted to a normal NDI or vice-versa
	;   The rules governing NDI updates with respect to the associated 
	;   loopback linename are as follows:
	;
	;	   If  there's a loopback line associated with the new NDI
	;	   then
	;		 if the old NDI is a "loop" node
	;		 then
	;		       if  new NDI node address = 0
	;		       then  okay
	;		       else  node address is invalid
	;		 else
	;		       loopback line is an invalid parameter
	;
	;	   else
	;		 if the old NDI was a "loop" node
	;		 then 
	;		      mark the new NDI for delete and return success
	;		 else 
	;		      neither old nor new NDI are "loop" nodes, continue
	;
	;
	$GETFLD	ndi,s,nli		; Get loopback linename field
	BLBC	R0,NOT_LOOPNODE		; If LBC, new NDI not a "loop"
	BISB	#1@NDI_V_LOOP,-		; Mark it as being a "loop" node
		    CNF$B_FLG(R10)	;
	TSTL	R6			; Is there an old NDI ?
	BEQL	20$			; If EQL no
	BBC	#NDI_V_LOOP,-		; If BC, old was not a loop node
		    CNF$B_FLG(R6),30$	; - therefore cannot set linename
20$:	$CNFFLD	ndi,s,nna,R9		; Assume no name was specified
	TSTL	W^NDI_Q_NAME		; Is the name null?
	BEQL	35$			; If EQL report 'insufficient args'
	$CNFFLD	ndi,l,add,R9		; Assume improper node address
	TSTW	CNF$W_ID(R5)		; Local node address specified?
	BEQL	50$			; If EQL then report 'success'
30$:	MOVZWL	S^#SS$_BADPARAM,R0	; Indicate error
	BRW	220$			; Take common exit
35$:	MOVZWL	#SS$_INSFARG,R0		; Set error code
	BRW	220$			; Take common exit
50$:	BRW	210$			; Report success

NOT_LOOPNODE:
	TSTL	R6			; Is there an old NDI ?
	BEQL	110$			; If EQL no
	BBC	#NDI_V_LOOP,-		; If BC old was not a loop node
		    CNF$B_FLG(R6),110$	;
	BISB	#CNF$M_FLG_DELETE!-	; Mark new NDI for delete
		    <1@NDI_V_LOOP>,-	; ...it's still a "loop node"
		    CNF$B_FLG(R10)	;
	BRW	210$			; Report success
110$:	;
	;   Neither the old or new NDIs are loop nodes
	;
	TSTW	CNF$W_ID(R5)		; Is this the local node?
	BNEQ	120$			; If NEQ then no
	BISB	#1@NDI_V_LOCAL,-	; Mark it as "local"
		    CNF$B_FLG(R5)
120$:	TSTL	R6			; Is there an old NDI
	BEQL	130$			; If EQL then no
	CMPW	CNF$W_ID(R5),CNF$W_ID(R6) ; Are old and new address the same?
	BEQL	130$			; If so, branch
	;
	;  The old and new address are different.  If either has address "zero"
	;  then report that the local NDI is being falsely modified.
	;
	BBS	#NDI_V_LOCAL,-		; If BS then old NDI is local
		     CNF$B_FLG(R6),140$	; -- report error
	BBS	#NDI_V_LOCAL,-		; If BS then new NDI is local
		     CNF$B_FLG(R5),140$	; -- report error
	MOVL	W^NET$GL_DUM_NDI,-	; Setup ptr to default NDI block
		W^NET$AL_NDI_VEC[R8]	; to replace old NDI
	BRW	200$			; Insert new NDI into vector
130$:	;
	;   There has been no NDI node address change.
	;
	;   If  the current local NDI CNF address = NET$GL_DUM_NDI
	;	(which means the ACP is undergoing its initialzation cycle)
	;
	;	OR
	;
	;	the new NDI node address not= 0	(0 implies NDI for local node)
	;   then
	;	we're done, return success
	;
	;   else
	;	if "old" NDI CNF address = current local NDI CNF address
	;	then
	;	    the local node NDI is undergoing a valid update.
	;	else
	;	    the local node NDI is being falsely modified, i.e., the
	;	    NDI specified via the QIO P2 key was not the local node
	;	    NDI but the node address parameter specified in the QIO P4
	;	    equals the local node address.  Report the error.
	;	    
	BBC	#NDI_V_LOCAL,-		; If BC then new NDI is not for the
		     CNF$B_FLG(R5),200$	; local node -- we're done
	CMPL	W^NET$AL_NDI_VEC,-	; Has the local node NDI been init'd
		W^NET$GL_DUM_NDI	; yet ?
	BEQL	200$			; If EQL no, we're done
	CMPL	W^NET$AL_NDI_VEC,R6	; Is the "old" CNF really the current
					; local node CNF
	BEQL	150$			; If EQL yes, br to continue
140$:	$CNFFLD	ndi,l,add,r9		; Specify field i.d. as node address
	MOVZWL	#SS$_DEVACTIVE,R0	; Specify it as already in use 
					; elsewhere in the database
	BRW	220$			; Report error
	;
	;   Update the logical name for the local node only if the RCB contains
	;   a non-zero node address.  The RCB contains node address 0 while the
	;   ACP is initializing.
	;
150$:	MOVL	W^NET$GL_PTR_VCB,R2	; Get the RCB address
	TSTW	RCB$W_ADDR(R2)		; Has the local node address been
					; established yet?
	BEQL	200$			; If EQL no, we're done
	MOVQ	W^NDI_Q_NAME,R7		; Get NDI name descriptor
	MOVAB	W^NDI_LNAMEBUF,R1	; Get buffer for building logical name
	MOVL	R1,W^NDI_Q_LNAME+4	; Setup pointer in descriptor
	MNEGL	R1,W^NDI_Q_LNAME	; Bias the count field
	MOVB	#^A'_',(R1)+		; Build logical nodename
	BRB	180$			; Continue
170$:	MOVB	(R8)+,(R1)+		; Enter the name text
180$:	SOBGEQ	R7,170$			; Loop
	MOVW	#^A'::',(R1)+		; Enter nodename delimiter
	ADDL	R1,W^NDI_Q_LNAME	; Setup the count field
	$CRELOG_S	-		; Create a system logical name
		LOGNAM = W^SYSNODE_DESC - ; Logical name
		EQLNAM = W^NDI_Q_LNAME	  ; Equivalence name
	BLBC	R0,220$			; If LBC then error
	;
	;   New NDI will be inserted into the data base, update the NDI vector
	;
200$:	BSBB	CHK_ACCESS		; Check for access control conflict
	BLBC	R0,220$			; If LBC then conflict exists
	MOVZWL	CNF$W_ID(R5),R0		; Get the new NDI node-address
	MOVL	R5,W^NET$AL_NDI_VEC[R0]	; Setup ptr to the NDI block
210$:	MOVL	R5,R10			; Fill R10 with new NDI block address
	BSBW	NET$LOG_COUNTERS	; Update counter timer
	MOVL	#1,R0			; Success if not changing local node
220$:	RSB				; Done

			.DSABL	LSB

CHK_ACCESS:				; Check for access control conflict
	BITB	#<1@NDI_V_LOCAL>!-	; Ignore if Local or loop node since
		 <1@NDI_V_LOOP>,-	; the access strings are used for
		CNF$B_FLG(R5)		; default inbound access and are
	BNEQ	100$			; special cased at connect time
	TSTL	W^NDI_L_NACS		; Any access control strings specified?
	BEQL	100$			; If EQL then no, no conflict
	$GETFLD	ndi,l,prx		; Get proxy access value
	BLBC	R0,100$			; If LBC then none, no conflict
	$DISPATCH	R8,-		; Dispatch on proxy access state
	<-
	  <NMA$C_ACES_NONE, 100$>,-	; No conflict if "none"
	  <NMA$C_ACES_INCO, 100$>,-	; No conflict if "incoming"
	>
	MOVL	S^#SS$_BADPARAM,R0	; Setup error status
	BRB	200$			; Exit with "ndi,l,prx" i.d. in R9
100$:	MOVL	S^#SS$_NORMAL,R0	; Say "success"
200$:	RSB				; Done





NET$INSERT_OBI::			; New CNF OBI special processing
	BSBW	CHK_LOGIN_OBI		; Check default login strings for
					; combined length
	BLBC	R0,20$			; If LBC then too long
	;
	;   If an OBI is merely the result of a "declare name/object" QIO then
	;   when the channel over which the object is declared is broken it is
	;   appropriate to delete the OBI entry from the data base.  However,
	;   in order to prevent a defined (via NCP) object from being removed
	;   if it is subsequently declared and then "undeclared" (by having its
	;   associated channel broken) it is necessary to mark each OBI if it
	;   at any time exists without being in a "declared" state.
	;
	;   Note that it is sufficient to mark the OBI whenever it is being
	;   (re)inserted into the database and it is not currently declared.
	;
	$GETFLD	obi,l,ucb		; Is the OBI currently "declared"
	BLBS	R0,10$			; If LBS yes, don't mark it
	MOVL	#1,R8			; Set next bit value to "true"
	$PUTFLD	obi,v,set		; Mark the OBI as having existed
					; without being declared
10$:	MOVL	#1,R0			; Set success
20$:	RSB

NET$INSERT_CRI::
	CLRL	-(SP)			; Scratch space on stack for STATE
	$GETFLD	cri,v,ser		; See if service functions are enabled
	MOVL	R8,R6			; Save parameter value
	$GETFLD cri,l,sta		; Get the operator state
	BLBS	R0,5$			; If LBS then state is set
	MOVZBL	#NMA$C_STATE_OFF,R8	; Default to the OFF state
	BSBW	CNF$PUT_FIELD		; Store it in the CNF
	BRB	10$			; Continue
5$:	BLBC	R6,10$			; If LBC then "service" state is legal
	MOVL	#SS$_BADPARAM,R0	; Assume state is "service"
	CMPL	R8,#NMA$C_STATE_SER	; Is it?
	BEQL	200$			; If so then conflicts with <cri,v,ser>
10$:	MOVL	R8,(SP)			; Save STATE value
	$GETFLD	cri,s,nam		; Get the circuit name
	BLBC	R0,200$			; If LBC then error
					;
90$:	MOVL	(SP),R8			; Get STATE value
	BSBW	NET$DLL_OPR_SET		; Signal operator event
	BLBC	R0,200$			; If LBC then error
	BSBW	NET$LOG_COUNTERS	; Update counter timer
	MOVL	#1,R0			; Indicate success
200$:	TSTL	(SP)+			; Cleanup the stack
	RSB				; Return status in R0

NET$INSERT_PLI::
	;
	;
	;   Setup default values for STATE and BFN if necessary
	;
	;
	$GETFLD pli,l,sta		; Get the operator state
	BLBS	R0,10$			; If not set then okay
	MOVL	#NMA$C_STATE_OFF,R8	; Default state value is "off"
	BSBW	CNF$PUT_FIELD		; Store it in the CNF block
10$:	MOVB	R8,PLI_B_STATE		; Save state value
	$GETFLD	pli,l,bfn		; Get number of buffers
	BLBS	R0,20$			; If LBS then already set
	MOVL	#4,R8			; Else use 4 by default
	BSBW	CNF$PUT_FIELD		; Store it in the CNF blcok
20$:	;
	;
	;   Locate the PLVEC index for this PLI.  If there is none then
	;   assign and initialize a PLVEC entry for this PLI.
	;
	;
	MOVZWL	CNF$W_ID(R10),R4	; Get i.d. (PLVEC index) of this entry
	BNEQ	30$			; If NEQ then its valid
	BSBW	NEW_PLI			; This is a new PLI, set it up
	BLBC	R0,100$			; If error then simply exit
	BISB	#1@PLI_V_NEW,-		; Indicate PLVEC has been newly
		    CNF$B_FLG(R10)	; assigned
	MOVB	#NMA$C_STATE_OFF,-	; Init to "off" state
		    PLVEC$AB_STATE[R4]	; Setup an undefined state value
30$:	;
	;
	;   Issue the line control QIO to setup the driver with the control
	;   information.  The IO$_STARTUP and IO$_SHUTDOWN modifiers are
	;   illegal unless there is a state change.
	;
	;
	MOVZBL	PLVEC$AB_STATE[R4],-(SP); Save old state value
	CLRL	R1			; Clear illegal I/O modifier mask
	CMPB	PLI_B_STATE,-		; Are old and new state value the same?
		    PLVEC$AB_STATE[R4]	;
	BNEQ	40$			; If NEQ then state change
	MOVW	#IO$M_STARTUP!-		; Specify unwanted I/O modifiers
		 IO$M_SHUTDOWN,R1	;
40$:	MOVB	PLI_B_STATE,-		; Setup new state value
		    PLVEC$AB_STATE[R4]	;
	BSBW	PLI_SETQIO		; Issue set characteristics QIO
	CVTLB	(SP)+,PLVEC$AB_STATE[R4]; Restore original state
	BLBC	R0,100$			; If LBC then error
	MOVB	PLI_B_STATE,-		; Setup the new state value
		    PLVEC$AB_STATE[R4]	;
100$:	;
	;
	;   If the PLI is not new then simply return the status in R0.  If
	;   the PLI is new then the newly allocated PLVEC slot must be
	;   deallocated if R0 indicates an error.
	;
	;
	BBCC	#PLI_V_NEW,-		; Br unless PLVEC has been newly
		    CNF$B_FLG(R10),110$	; assigned
	BLBS	R0,110$			; If BS then no clean-up needed
	PUSHL	R0			; Save error code
	BSBW	DEAL_PLVEC		; Free the PLVEC cell
	POPL	R0			; Restore status
110$:	RSB				; Return status in R0


NEW_PLI:				; Setup a new PLI
	MOVZWL	#SS$_INSFMEM,R0		; Assume no resources for this entry
	MOVZBL	L^PLVEC$GB_MAX,R4	; Else no i.d. yet, get max PLX index
10$:	TSTB	L^PLVEC$AB_REFC[R4]	; Is this cell free?
	BEQL	20$			; If EQL then yes
	SOBGTR	R4,10$			; Loop -- index 0 is not used
19$:	BRW	100$			; Report "resource error"
20$:	MOVW	R4,CNF$W_ID(R10)	; Use PLVEC index as PLI i.d.
	INCB	L^PLVEC$AB_REFC[R4]	; Claim the PLVEC cell
	CLRW	L^PLVEC$AW_CHAN[R4]	; No channel assigned yet
	MOVZWL	#SS$_NOSUCHDEV,R0	; Assume error
	$GETFLD	pli,l,nam		; Else get the line name
	BLBC	R0,19$			; Br to 100$ if cannot translate it
	;
	;
	;   Get the VMS name of the device and the device code.  Assign an
	;   I/O channel to the device and squirrel away the device code
	;
	;
	SUBL	#MAX_C_DEVNAM+8,SP	; Create scatch space on stack
	MOVAB	8(SP),R3		; Point to scratch space for name text
	MNEGL	R3,(SP)			; Bias count field of name descriptor
	MOVL	R3,4(SP)		; Enter ptr field of name descriptor
	BSBW	TRAN_DEVNAM		; Translate device name to VMS format
					; - advances R3, table entry -> R6
	MOVZWL	CNF$W_ID(R10),R4	; Recover R4
	BLBC	R0,40$			; If LBC then error
	MOVZWL	#SS$_IVDEVNAM,R0	; Assume error
	TSTL	R7			; Any unparsed characters?
	BNEQ	100$			; If NEQ yes, name format error
	MOVB	DEVTRN$B_DEV(R6),-	;
		    L^PLVEC$AB_DEV[R4]	; Enter device type code
	ADDL	R3,(SP)			; Complete device name descriptor
	MOVL	SP,R3			; Point to it ($ASSIGN_S modifies stack)
	$ASSIGN_S -			; Assign an I/O channel
		CHAN   = L^PLVEC$AW_CHAN[R4],-
		DEVNAM = (R3)
40$:	ADDL	#MAX_C_DEVNAM+8,SP	; Restore stack
	BLBC	R0,100$			; If LBC then error
	MOVZWL	L^PLVEC$AW_CHAN[R4],R0	; Get I/O channel
	JSB	G^IOC$VERIFYCHAN	; Return CCB in R1 regardless of error
	MOVL	S^#SS$_NORMAL,R0	; Ignore errors -- CCB is return anyway
	MOVL	CCB$L_UCB(R1),-		; Store device UCB
		    L^PLVEC$AL_UCB[R4]
;
; Pre-allocate (and deallocate) the receive buffers for the datalink
; driver from the system nonpaged pool.  This is done here before
; invoking the driver so that the pool expansion mechanism can be used
; in case there isn't enough pool.  It is done here because pool
; expansion can't be done on the interrupt stack in the datalink driver.
;
	$GETFLD	pli,l,bfn		; Get number of line receive buffers
	BLBC	R0,100$			; Error - wasn't defaulted properly
	MOVL	R8,R5			; Save number of receive buffers
	$GETFLD	pli,l,bus		; Get line receive buffer size
	BLBC	R0,100$			; Skip if error detected
	CLRL	-(SP)			; Terminate list of allocated blocks
50$:	MOVL	R8,R1			; Set size of block to allocate
	BSBW	NET$ALONPAGED		; Allocate from nonpaged pool
	BLBC	R0,60$			; If error, give up
	PUSHL	R2			; Save block address
	SOBGTR	R5,50$			; Loop until all allocated
60$:	POPL	R0			; Get next buffer address
	BEQL	70$			; Branch if all blocks deallocated
	BSBW	NET$DEALLOCATE		; Deallocate the block
	BRB	60$			; Loop until all blocks cleaned up
70$:	MOVL	#1,R0			; Success
100$:	RSB				; Return status in R0


PLI_SETQIO:				; Issue PLI set characterstics QIO
	$CNFFLD	pli,s,chr,R9		; Set field i.d.
	MOVZWL	L^PLVEC$AW_CHAN[R4],R2	; Get channel

NET$SET_QIOW::				; Is datalink SETMODE QIO
	MOVZWL	#SS$_NOSUCHDEV,R0	; Assume error
					;&need a better error code
	BSBW	CNF$GET_FIELD		; Get datalink characteristics
	BLBC	R0,100$			; If LBC then error
	BICL	R1,DLLQIO$L_FUNC(R8)	; Mask out illegal I/O modifier bits
	TSTL	DLLQIO$L_P1(R8)		; Any P1 buffer ?
	BEQL	5$			; If EQL no
	ADDL	R8,DLLQIO$L_P1(R8)	; Else turn offset into a pointer
5$:	TSTL	DLLQIO$L_P2(R8)		; Any P2 buffer ?
	BEQL	10$			; If EQL then none
	ADDL	R8,DLLQIO$L_P2(R8)	; Turn offset into a pointer
	MOVL	DLLQIO$L_P2(R8),R0	; Point to P2 buffer descriptor
	ADDL	R8,4(R0)		; Turn offset into a pointer
10$:	CLRQ	QIOW_Q_IOSB		; Init the IOSB image
	$QIOW_S	-			; Set the device charactersitics
		EFN  = #NET$C_EFN_WAIT,-
		IOSB = QIOW_Q_IOSB,-
		CHAN = R2,-
		FUNC = DLLQIO$L_FUNC(R8),-
		P1   = @DLLQIO$L_P1(R8),-	; This is a PUSHAL
		P2   = DLLQIO$L_P2(R8),-
		P3   = DLLQIO$L_P3(R8)
	BLBC	R0,100$			; If LBC then error
	MOVL	QIOW_Q_IOSB+4,R9	; Get remainder of IOSB
	BSBW	NET$CVT_NMA_INT		; Convert NMA parameter i.d. to an
					; internal parameter i.d.
	MOVZWL	QIOW_Q_IOSB,R0		; Get I/O status
100$:	RSB


NET$INSERT_ESI::			; New ESI CNF special processing
	BRW	NET$DBC_ESI		; Event logger Sink database change
NET$INSERT_EFI::			; New EFI CNF special processing
	BRW	NET$DBC_EFI		; Event logger Filter database change

NET$INSERT_LLI::			; Insert LLI special processing
	MOVZWL	#SS$_ILLCNTRFUNC,R0	; Illegal ACP control function
	MOVZBL	#NFB$C_DB_LLI,R9	; Qualify error -- not valid for this
					; data base
	RSB				; Done

			.ENABL	LSB
CHK_LOGIN_OBI:				; Check combined login string length
	CLRL	R4			; Count of number of non-null strings
	MOVAB	W^OBI_LOGIN_VEC,R3	; Setup field i.d. vector
	BRB	5$			; Continue in common
CHK_LOGIN_NDI:				; Check combined login string length
	CLRL	R4			; Count of number of non-null strings
	MOVAB	W^NDI_PLOGIN_VEC,R3	; Setup field i.d. vector
	BSBB	10$			; Check the combined length
	MOVAB	W^NDI_NLOGIN_VEC,R3	; Get the address of field i.d.'s
5$:	BSBB	10$			; Check the comined length
7$:	MOVL	S^#SS$_NORMAL,R0	; Inicate success
	RSB


10$:	MOVZWL	#ICB$C_ACCESS-4,R2	; Get max size of string text (the -4
					; is for 3 string count fields plus a 
					; count field for the combined strings)
20$:	MOVL	(R3)+,R9		; Get next field i.d.
	BEQL	30$			; If EQL then done
	BSBW	CNF$GET_FIELD		; Get the string
	BLBC	R0,20$			; If LBC then string is not defined
	INCL	R4			; Count number of non-null strings
	SUBL	R7,R2			; Subtract string size
	BGEQ	20$			; If GEQ then okay
	MOVZWL	#SS$_BADPARAM,R0	; Else indicate error
					;!a better error code is needed
	TSTL	(SP)+			; Pop stack to return to origin. caller
30$:	RSB				; Return
			.DSABL	LSB

;+
; NET$DELETE_xxx  -  Special processing before a CNF entry is marked for delete
;
; This routine is called to perform any special action that may need to be
; taken before marking a CNF for delete.
;
; INPUTS:	R11	CNR pointer
;		R10	CNF pointer
;
; OUTPUTS:	R11,R10	Preserved
;		R0	LBS if successful
;			LBC if CNF should not be marked for delete
;
;		All registers may be destroyed.
;
;-
NET$DELETE_LNI::			; Special processing before marking
	CLRL	R0			; ABSOLUTELY NOT
	RSB

NET$DELETE_NDI::			; CNF for delete
	CLRL	R0			; Assume not delete-able
	BBS	#CNF$V_FLG_ACP,-	; Not deleteable if the ACP owns
		    CNF$B_FLG(R10),10$	; this block
	BBS	#NDI_V_LOCAL,-		; If set then this is the "local" node
		    CNF$B_FLG(R10),10$	; and cannot be deleted
	INCL	R0			; Indicate "okay to delete"
10$:	RSB

NET$DELETE_OBI::
	$GETFLD	obi,l,pid		; See if declared name
	INCB	R0			; Invert status -- not delete-able if
	RSB				;  declared name

NET$DELETE_CRI::
	BSBW	NET$LOCATE_LPD		; Locate the LPD 
	INCB	R0			; Invert status -- not delete-able if
	RSB				;  LPD is present

NET$DELETE_PLI::
	$GETFLD	pli,l,sta		; Get the state value
	BLBC	R0,DEAL_PLVEC		; If LBC then no need to check state
	CMPL	#NMA$C_STATE_OFF,R8	; Is the line turned off?
	BEQL	DEAL_PLVEC		; If NEQ then cannot delete PLI
	CLRL	R0			; Say "cannot delete PLI"
	RSB				; Done

DEAL_PLVEC:				; Deallocate PLVEC cell
	MOVZWL	CNF$W_ID(R10),R4	; Get the PLVEC index
	BEQL	10$			; If EQL then done
	CLRB	L^PLVEC$AB_REFC[R4]	; No longer any references to this slot
	CLRL	L^PLVEC$AL_UCB[R4]	; No UCB
	$DASSGN_S -			; Deassign the I/O channed
		CHAN = PLVEC$AW_CHAN[R4];
					; Ignore errors
10$:	MOVL	S^#SS$_NORMAL,R0	; Indicate success
	RSB


NET$DELETE_ESI::
	$GETFLD	esi,v,lck		; See if its locked
	CLRL	R0			; Assume not not delete-able
	BLBS	R8,10$			; If locked then not delete-able
	INCB	R0			; Else its delete-able
10$:	RSB				; 

NET$DELETE_EFI::
	$GETFLD	efi,v,lck		; See if its locked
	CLRL	R0			; Assume not not delete-able
	BLBS	R8,10$			; If locked then not delete-able
	INCB	R0			; Else its delete-able
10$:	RSB				; 

NET$DELETE_LLI::			; Delete Logical-link action routine
	MOVL	W^NET$GL_NET_UCB,R5	; Provide a "NET" UCB address
	MOVZWL	CNF$C_LENGTH + -	; Get logical link number
		    XWB$W_LOCLNK(R10),R3;
	MOVZBL	#NET$C_DR_THIRD,R2	; Disconnect reason
	MOVZWL	CNF$C_LENGTH + -	; Get partner node address
		    XWB$W_REMNOD(R10),R1;
	MOVZBL	#NETUPD$_DSCLNK,R0	; Setup function code
	JSB	@W^NET$GL_PTR_ACR	; Call the driver
	MOVL	S^#SS$_NORMAL,R0	; Setup status
	RSB				; Done

;+
; NET$REMOVE_xxx
;
; This routine is called to perform special processing after a CNF block has 
; been removed from the database.  On return, the block is deallocated.
;
; INPUTS:	R11	CNR pointer
;		R0	CNF pointer
;
; OUTPUTS:	All registers are preserved.
;
;-
NET$REMOVE_LNI::			; Remove Local node CNF action routine
NET$REMOVE_OBI::			; Remove Object CNF action routine
NET$REMOVE_CRI::			; Remove Circuit CNF action routine
NET$REMOVE_PLI::			; Remove Line CNF action routine
NET$REMOVE_LLI::
	RSB

NET$REMOVE_EFI::			; Remove Event filter CNF action routine
NET$REMOVE_ESI::			; Remove Event sink CNF action routine
	PUSHL	R0			; Save block address
	BSBW	NET$DBC_EFI		; Inform EVL of database change
	POPL	R0			; Restore block address
	RSB

NET$REMOVE_NDI::			; Remove NDI from the list
	BBS	#NDI_V_LOOP,-		; If BS the "LOOP" node and there's no
		    CNF$B_FLG(R0),20$	; slot in the NDI vector for it
	PUSHL	R1			; Save reg
	MOVZWL	CNF$W_ID(R0),R1		; Get the node address
	MOVL	W^NET$GL_DUM_NDI,-	; Store the "phantom" CNF ptr
		W^NET$AL_NDI_VEC[R1]	;
10$:	POPL	R1			; Restore reg
20$:	RSB

;+
; SCAN_XWB - Scan XWB list to total active links and delay
;
; INPUTS:	R11 	NDI CNR address
;		R10 	NDI CNF address
;		R9	scratch
;		R8	Node address
;		R7 	RCB address
;		R1 - R0 scratch
;
; OUTPUTS:	R7	Average delay found
;		R8	Total number of active links
;-
SCAN_XWB:				; Scan XWB list
	PUSHR	#^M<R6>			; Save some reg(s)
	BSBW	NDI_L_TAD		; Translate address if needed
	DSBINT	#NET$C_IPL		; Synchronize with NETDRIVER
	MOVL	RCB$L_PTR_LTB(R7),R0	; Get LTB address
	MOVZWL	LTB$W_SLT_TOT(R0),R9	; Get no. of XWB's to check
	CLRQ	R7			; Init link count and delay
10$:	MOVL	LTB$L_SLOTS(R0)[R9],R6	; Get the next XWB
	BLBS	R6,20$			; If LBS slot not in use
	CMPW	XWB$W_REMNOD(R6),R1	; Remote node match?
	BNEQ	20$			; If NEQ no - skip it
	INCL	R8			; Increment total active links
	MOVZWL	XWB$W_DELAY(R6),-(SP)	; Get delay
	ADDL	(SP)+,R7		; Add to total
20$:	SOBGTR	R9,10$			; Increment slot number and loop
	ENBINT				; Restore IPL
	CLRL	R0			; Assume node links
	TSTL	R8			; Any links?
	BEQL	30$			; If EQL no
	DIVL	R8,R7			; Compute average delay
	MOVL	#1,R0			; Indicate success
30$:	POPR	#^M<R6>			; Restore bugfree register
	RSB				;


;+
; NET$LNI_V_NUL	-  Get null field value (always = 1)
; NET$LNI_V_LCK -  Get status of conditionally writeable fields
;
; NET$LNI_L_ACL -  Get number of currently active links
;
; NET$LNI_S_COL -  Get collating value
; NET$LNI_S_NAM -  Get local node name
; NET$LNI_S_CNT -  Get (optionally clear) local counters
;
; INPUTS:	R11	LNI CNR address
;		R10	LNI CNF address
;		R9	FLD i.d. of field being read
;		R1	Scratch
;		R0	Scratch
;
; OUTPUTS:	R1	Address of field value or longword string descriptor
;		R0	Low bit set if R1 is valid
;			Low bit clear otherwise
;
;		All other register values are preserved.
;
;-
NET$LNI_V_NUL::				; Return the value 1
	BSBW	GET_TMPVAL_CO		; Call co-routine for common setup
	MOVL	#1,R1			; Field value
	MOVL	#1,R0			; Success
	RSB				; Return

NET$LNI_V_LCK::				; Get status of cond. writeable fields
	BSBW	NET$GET_LOC_STA		; Return local state in R0
	CMPB	#LNI$C_STA_OFF,R0	; Is the ACP off?
	BEQL	5$			; If so okay to write fields
	CMPB	#LNI$C_STA_INIT,R0	; Is the ACP init'ing
	BEQL	5$			; If so okay to write fields	
	MOVB	#1,R0			; Indicate fields are locked
	BRB	10$			; Continue
5$:	CLRL	R0			; Fields are not locked
10$:	MOVAB	W^TMP_VAL,R1		; Point to temp storage
	MOVL	R0,(R1)			; Store field value 
	MOVL	S^#SS$_NORMAL,R0	; Success
	RSB

NET$LNI_L_ACL::				; Get number of currently active links
	MOVAB	W^TMP_VAL,R1		; Get output cell address
	MOVL	W^NET$GL_PTR_VCB,R0	; Get RCB pointer
	BEQL	10$			; Br on error
	MOVZWL	RCB$W_MCOUNT(R0),(R1)	; Get number of links + 1
	DECL	(R1)			; Subtract out the ACP reference
	MOVB	#1,R0			; Indicate success
10$:	RSB

NET$LNI_S_COL::				; Get collating value
	BSBW	GET_TMPBUF_CO		; Call co-routine to get temp buffer
	MOVB	#1,(R3)+		; Enter a static value
	MOVB	#SS$_NORMAL,R0		; Indicate success
	RSB

NET$LNI_S_NAM::				; Get local node name
	PUSHR	#^M<R9,R10,R11>		; Save regs
	MOVL	L^NET$GL_CNR_NDI,R11	; Get the NDI root block
	MOVL	L^NET$AL_NDI_VEC,R10	; Get the local NDI CNF
	$CNFFLD	ndi,s,nna,R9		; Identify node name field
	BSBW	CNF$GET_ADDR		; Point R1 to descriptor
10$:	POPR	#^M<R9,R10,R11>		; Restore regs
	RSB				; Return status in R0

NET$LNI_S_CNT::				; Get (optionally clear) local counters
	PUSHR	#^M<R9,R10,R11>		; Save regs
	MOVL	L^NET$GL_CNR_NDI,R11	; Get the NDI root block
	MOVL	L^NET$AL_NDI_VEC,R10	; Get the local NDI CNF
	BSBW	NET$NDI_S_CNT		; Get the counter block
	POPR	#^M<R9,R10,R11>		; Restore regs
	RSB				; Return status in R0

;+
; NET$NDI_V_NUL	-  Get null field value (always = 1)
; NET$NDI_V_REA -  Get node reachability status
; NET$NDI_V_LCK -  Get status of conditionally writeable fields
; NET$NDI_V_LOO	-  Get bit which is set if the CNF is for a "loopback" nodename
;
; NET$NDI_L_ACL -  Get number of active links to the node
; NET$NDI_L_DEL -  Get delay to node
; NET$NDI_L_DTY -  Get node type
; NET$NDI_L_DCO -  Get total cost to node
; NET$NDI_L_DHO -  Get total hops to node
; NET$NDI_L_TAD -  Get transformed node address
;
; NET$NDI_S_HAC -  Get merged node address/loopback linename value
; NET$NDI_S_COL	-  Get collating sequence value
; NET$NDI_S_DLI -  Get line for normal traffic to node
; NET$NDI_S_CNT -  Get (optionally clear) node counters
;
; INPUTS:	R11	NDI CNR address
;		R10	NDI CNF address
;		R9	FLD i.d. of field being read
;		R1	Scratch
;		R0	Scratch
;
; OUTPUTS:	R1	Address of field value or longword string descriptor
;		R0	Low bit set if R1 is valid
;			Low bit clear otherwise
;
;		All other register values are preserved.
;
;-
;	*								  *
;	**								 **
;	***   This set of routines assumes that the node address field	***
;	***   is not an action routine and that it is always set.	***
;	**								 **
;	*								  *
;
NET$NDI_V_NUL::				; Return the value 1
	BSBW	GET_TMPVAL_CO		; Call co-routine for common setup
	MOVL	#1,R1			; Field value
	MOVL	#1,R0			; Success
	RSB				; Return

NET$NDI_V_LOO::				; See if CNF is for a loopback node
	BSBW	NDI_CO			; Call common setup co-routine
	MOVL	#1,R1			; Assume loop node
	BBS	#NDI_V_LOOP,-		; If BS then loop node
		    CNF$B_FLG(R10),10$	;
	CLRL	R1			; Not a loop node
10$:	MOVL	S^#SS$_NORMAL,R0	; Success
	RSB				; Done

NET$NDI_V_LCK::				; Get status of cond. writeable fields
	BSBW	NDI_CO			; Call common co-routine
	CLRL	R1			; Say "not locked"
	MOVL	S^#SS$_NORMAL,R0	; Success
	RSB

NET$NDI_V_REA::				; Get node reachability status
	BSBW	NDI_CO			; Get address, save regs, (co-routine)
	BSBW	TEST_REACH		; Return reachability bit in R0
	MOVZBL	R0,R1			; Return as param value
	MOVL	S^#SS$_NORMAL,R0	; Success
	RSB

NET$NDI_L_DCO::				; Get total cost to node
	BSBW	NDI_CO			; Call co-routine
	MNEGL	#1,R1			; Preset value to infinity
	CMPW	R8,RCB$W_MAX_ADDR(R7)	; Is node within range?
	BGTRU	10$			; If GTRU then no
	MOVZWL	W^NET$AW_MIN_C_H[R8],R1	; Get cost/hops to node
	EXTZV	#0,#10,R1,R1		; Get cost		  (!use sybmol)
	MOVL	S^#SS$_NORMAL,R0	; Success
10$:	RSB

NET$NDI_L_DHO::				; Get total hops to node
	BSBW	NDI_CO			; Call co-routine
NDI_L_DHO:
	CLRL	R0			; Assume error
	MOVL	#-1,R1			; Preset value to infinity
	CMPW	R8,RCB$W_MAX_ADDR(R7)	; Is node within range?
	BGTRU	10$			; If GTRU then no
	MOVZWL	W^NET$AW_MIN_C_H[R8],R1	; Get cost/hops to node
	EXTZV	#10,#5,R1,R1		; Get hops		  (!use sybmol)
	MOVL	#1,R0			; Indicate success
10$:	RSB

NET$NDI_L_ACL::				; Get number of active links
	BSBW	NDI_CO			; Call common setup co-routine
	BSBW	SCAN_XWB		; Scan XWB list and total up links
	MOVL	R8,R1			; Store number of links
	RSB

NET$NDI_L_DEL::				; Get delay to node
	BSBW	NDI_CO			; Call co-routine
	BSBW	SCAN_XWB		; Scan XWB list and get average delay
	MOVL	R7,R1			; Store average delay
	RSB

NET$NDI_L_DTY::				; Get node type
	BSBW	NDI_CO			; Call common co-routine
	BSBW	TEST_REACH		; See if node is reachable
	BLBC	R0,30$			; If LBC then no
	MOVL	R1,W^TMP_VAL		; Store, path and node type
	MOVZWL	W^TMP_VAL+2,R1		; We only want the type
	CMPW	#NDI$C_DTY_UNK,R1	; Is the type "unknown" ?
	BNEQ	30$			; If not return LBS in R0
	CLRL	R0			; Else indicate failure
30$:	RSB

NET$NDI_L_TAD::				; Get node transformed address
	BSBW	NDI_CO			; Call common co-routine
NDI_L_TAD:				; Get node transformed address
	MOVL	R8,R1			; Copy the address for returned value
	BNEQ	10$			; If NEQ then not local
	MOVZWL	RCB$W_ADDR(R7),R1	; Copy the local address
10$:	MOVB	#1,R0			; Indicate success
	RSB

NET$NDI_S_CNT::				; Get node counters
	MOVZWL	#SS$_BADPARAM,R0	; Assume loop-node
	BSBW	GET_TMPBUF_CO		; Call get temp buffer co-routine
	BBS	#NDI_V_LOOP,-		; If BS then loop node
		    CNF$B_FLG(R10),30$	; ...no counters for loop nodes
	MOVL	W^NET$GL_PTR_VCB,R4	; Get RCB address
					;
	PUSHL	R3			; Save original output pointer
	PUSHAB	B^20$			; Setup return address
	MOVZWL	CNF$W_ID(R10),R8	; Get node address
	BEQL	LOCAL_NODE_CNT		; If EQL then local node
	BRW	NODE_CNT		; Else remote node
20$:	POPL	R2			; Recover orginal counter block ptr
					;
	BLBC	R0,30$			; Br on error
	MOVL	S^#EVC$C_SRC_NOD,R0	; Setup event database i.d.
	BSBW	LOG_COUNTERS		; Log the counter block if needed
	MOVL	#1,R0			; Success
30$:	RSB				; Done

LOCAL_NODE_CNT:
	;
	;   Get local node counters.  First get the common node counters, the
	;   first block of which is the 'seconds since last zeroed' counter.
	;   Append the local-node-only counters, the first block of which is
	;   also the 'seconds since last zeroed' counter.  Shift the counters
	;   to squeeze out this redundant counter.
	;
	MOVZWL	RCB$W_ADDR(R4),R8	; Get local node address
	BSBB	NODE_CNT		; Get common node counters
	MOVAB	RCB$L_ABS_TIM(R4),R1	; Point to start of block local node
					; counters
	MOVZWL	#RCB$C_CNT_SIZE+4,R2	; Total size of block 
					;  +4 for "seconds since last zeroed"
	MOVAB	RCB_CNT_TAB,R5		; Point to counter formatting table
	MOVL	R3,R7			; Save output buffer pointer
	BSBW	MOVE_FMT_CNT		; Move and format the counters
	SUBL3	R7,R3,R2		; Get number of bytes just moved
	SUBL	#4,R2			; Account for superfulous 'seconds
					; since last zeroed'
	BLSS	10$			; If LSS then no NDI counts were moved
	MOVC3	R2,4(R7),(R7)		; Shift the counters, update R3
10$:	MOVB	#1,R0			; Indicate success
	RSB				; Return status to co-routine

NODE_CNT:				; Move common node counters
	MULL3	#NDC$C_LENGTH,R8,R0	; Get offset to NDC
	MOVL	RCB$L_PTR_NDC(R4),R1	; Point to the NDC vector
	MOVAB	12(R1)[R0],R1		; Get NDC address
	MOVZWL	#NDC$C_LENGTH,R2	; Get NDC cell size
	MOVAB	NDC_CNT_TAB,R5		; Set counter formatting table
	BSBW	MOVE_FMT_CNT		; Move and format counters
	RSB				; Done, return status in R0


NET$NDI_S_DLI::				; Get line for normal traffic to node
	PUSHR	#^M<R2,R6,R7,R8,R9,R10,R11>
	$CNFFLD	ndi,s,nli,R9		; Identify loopback linename
	BBS	#NDI_V_LOOP,-		; If BS then loopback node
		    CNF$B_FLG(R10),5$	;
	MOVZWL	NDI_ADD(R10),R8		; Get the address
	BSBW	TEST_REACH		; Get its path
	BLBC	R0,10$			; Br if unreachable
	MOVZBL	R1,R8			; Setup path index for subroutine call
					; - don't know its sequence number yet
	BSBW	NET$GET_LPD_CRI		; Get the LPD and CRI for this path
	BLBC	R0,10$			; If LBC then LPD is invalid
	CLRL	R0			; Assume no CRI
	TSTL	R10			; Is there an associate CRI ?
	BEQL	10$			; If EQL no (could be "local" LPD)
	$CNFFLD	cri,s,nam,R9		; Identify the line name field
5$:	BSBW	CNF$GET_ADDR		; Get it
10$:	POPR	#^M<R2,R6,R7,R8,R9,R10,R11>
	RSB				; Return status in R0

	;
	;    Return the collating sequence string used to determine where
	;    in the CNF list this particular NDI should be inserted.  The
	;    expected order here is: 
	;
	;	- NDI's are sorted first according to the collating value of
	;	  their associated "loopback" line -- the collating value of
	;	  the null "loopback" line is zero and therefore NDI's without
	;	  a "loopback" line will appear first in the list.
	;
	;	- NDI's with the same "loopback" line are sorted in ascending
	;	  order of their node address -- since the node address 
	;	  associated with the local node's NDI is zero by convention
	;	  it will appear first.
	;
NET$NDI_S_COL::				; Get collating sequence string
	BSBW	GET_TMPBUF_CO		; Do common setup
	CLRB	(R3)+			; Begin with lowest possible value
	BBC	#NDI_V_LOOP,-		; If BC then not loop node
		    CNF$B_FLG(R10),10$	;
	MNEGB	#1,-1(R3)		; Start string with huge value
10$:	MOVB	NDI_ADD+1(R10),(R3)+	; Enter high order node address byte
	MOVB	NDI_ADD+0(R10),(R3)+	; Enter low  order node address byte
	BSBB	HAC1			; Append loopback linename, if any
	RSB
	
NET$NDI_S_HAC::				; Get hashed node addr/loopback
					; linename value
	;
	;    This value is used in a uniqueness check to enforce the rule
	;    that "no two NDI entries will have the same address node address
	;    will be associated with the same loopback line name".  
	;
	BSBW	GET_TMPBUF_CO		; Call co-routine to get temp buffer
	MOVW	NDI_ADD(R10),(R3)+	; Store the node address
HAC1:	$CNFFLD	ndi,s,nli,R9		; Identify loopback linename field
	BSBW	MOVSTR			; Append it to address
	MOVB	#1,R0			; Indicate success if we got this far
	RSB				; Retrun to co-routine

NDI_CO:	POPL	R1			; Get return address
	PUSHR	#^M<R7,R8,R9>		; Save regs
	MOVZWL	NDI_ADD(R10),R8		; Get the address
	MOVL	W^NET$GL_PTR_VCB,R7	; Get the RCB address
	MOVZWL	#SS$_NOSUCHNODE,R0	; Assume failure
	JSB	(R1)			; Call action routine
	MOVL	R1,W^TMP_VAL		; Store parameter value
	MOVAB	W^TMP_VAL,R1		; Point to it
	POPR	#^M<R7,R8,R9>		; Restore regs
	RSB

TEST_REACH:
	PUSHL	R2			; Save reg
	MOVL	R8,R2			; Copy address
	BSBW	NET$TEST_REACH		; Make test
	POPL	R2
	RSB

NET$TEST_REACH::			; Test for node reachablity
	;
	;  This routine tests the reachability of a node independent of the
	;  presents of a NDI data block.  Note that a Phase III non-adjacent
	;  node can be reached even though there is no NDI block for that node
	;  since the output line is mapped by address -- no other information
	;  is required.
	;
	;  Inputs:  R2  Node address
	;	    R1	Scratch
	;	    R0	Scratch
	;
	;  Outputs: R2	Node address
	;	    R1	Index of path used to reach the node (w/o sequence no.)
	;		High word has node type
	;	    R0  Status
	;
	PUSHL	#0			; Init storage on stack
	MOVZWL	#SS$_NOSUCHNODE,R0	; Assume node is out of range
	MOVL	W^NET$GL_PTR_VCB,R1	; Get the RCB
	CMPW	R2,RCB$W_MAX_ADDR(R1)	; Within range ?
	BGTRU	100$			; If GTRU then out of range
	MOVZWL	#SS$_UNREACHABLE,R0	    ; Node is known, assume unreachable
	CVTBL	@RCB$L_DSP_OL(R1)[R2],(SP)  ; Get path index to the node
	BEQL	100$			    ; If EQL not reachable
	BLSS	10$			    ; If LSS then local 
	MULL3	#LPD$C_LENGTH,(SP),R0	    ; Get vector offset
	SUBL2	#LPD$C_LENGTH-12,R0	    ; Subtract out the bias
	ADDL2	 RCB$L_PTR_LPD(R1),R0	    ; Get the LPD ptr
	MOVW	#NDI$C_DTY_PH2,2(SP)	    ; Assume PhaseII node
	BBS	#LPD$V_PH2,LPD$W_STS(R0),50$; Br if PhaseII
	MOVW	#NDI$C_DTY_UNK,2(SP)	    ; Type is unknown if non-adjacent
	CMPW	 LPD$W_PNA(R0),R2	    ; Is the node adjacent?
	BNEQ	50$			    ; If NEQ then not adjacent
	MOVW	#NDI$C_DTY_PH3N,2(SP)	    ; Assume non-routing node
	BBS	#LPD$V_PH3N,LPD$W_STS(R0),50$; If BC we were right
10$:	MOVW	#NDI$C_DTY_PH3,2(SP)	    ; Mark it as a full routing node
50$:	MOVL	S^#SS$_NORMAL,R0	    ; Indicate reachable
100$:	POPL	R1			    ; Recover path and type
	RSB

;+
; NET$OBI_V_NUL	-  Get null field value (always = 1)
; NET$OBI_V_LCK -  Get status of conditionally writeable fields
;
; NET$OBI_S_COL -  Get collating value
; NET$OBI_S_ZNA -  Get combined number,name
; NET$OBI_S_IAC -  Get default inbound access
; NET$OBI_S_SFI -  Startup file id string
;
; INPUTS:	R11	NDI CNR address
;		R10	NDI CNF address
;		R9	FLD i.d. of field being read
;		R1	Scratch
;		R0	Scratch
;
; OUTPUTS:	R1	Address of field value or longword string descriptor
;		R0	Low bit set if R1 is valid
;			Low bit clear otherwise
;
;		All other register values are preserved.
;
;-
NET$OBI_V_NUL::				; Return the value 1
	BSBW	GET_TMPVAL_CO		; Call co-routine for common setup
	MOVL	#1,R1			; Field value
	MOVL	#1,R0			; Success
	RSB				; Return

NET$OBI_V_LCK::				; Get status of cond. writeable fields
	;
	;   If the UCB field is active then the object is a "declared" object
	;   or name and the conditionally writeable fields are locked.
	;
	BSBW	GET_TMPVAL_CO		; Call get temp storage co-routine
	$GETFLD	obi,l,ucb		; Fetch UCB field
	MOVL	R0,R1			; If UCB field is active then CNF is
					; locked
	MOVL	S^#SS$_NORMAL,R0	; Success
	RSB				; Return to co-routine

NET$OBI_S_COL::				; Get collating value
NET$OBI_S_ZNA::				; Get combined number,name
	;
	;   This string is used for collating and uniqueness checking.  The
	;   blocks are to be collated by number and all non-zero numbers must
	;   be unique (not two CNFs may share a object number) unless that
	;   number is zero -- since declared names will all have the object
	;   type zero.   Thus the value of this field is the object number
	;   alone if the number is non-zero, or the object number followed
	;   by the name if the number is zero.
	;
	;   Note: If the name itself is required to be unique then that
	;	  check must be made elsewhere.
	;
	BSBW	GET_TMPBUF_CO		; Call co-routine to get temp buffer
	$GETFLD	obi,l,num		; Get the object number
	BLBC	R0,20$			; Br on error
	MOVB	R8,(R3)+		; Move the number
	BNEQ	20$			; If NEQ then we're done
	$CNFFLD	obi,s,nam,R9		; Identify the object name
	BSBW	MOVSTR			; Append it to buffer
	BLBC	R0,20$			; Br on error
	TSTW	R7			; Is the length zero ?
	BNEQ	20$			; If NEQ then okay
	CLRL	R0			; Else illegal ZNA value
20$:	RSB				; Return status to co-routine


NET$OBI_S_IAC::				; Get default inbound access
	BSBW	GET_TMPBUF_CO		; Get temp buffer co-routine
	PUSHAB	3(R3)			; Null access strings are 3 null bytes
	$CNFFLD	obi,s,usr,R9		; Setup field id
	BSBW	MOVCSTR			; Move the username
	$CNFFLD	obi,s,psw,R9		; Setup password field id
	BSBW	MOVCSTR			; Move it
	$CNFFLD	obi,s,acc,R9		; Setup account id
	BSBW	MOVCSTR			; Move it
	CMPL	(SP)+,R3		; Is the access control null?
	BNEQ	10$			; If NEQ no - proceed
	MOVQ	R10,-(SP)		; Save OBI CNF,CNR
	MOVL	L^NET$GL_CNR_NDI,R11	; Get the NDI root block
	MOVL	L^NET$AL_NDI_VEC,R10	; Get the local NDI CNF
	SUBL	#3,R3			; Reset R3
	$CNFFLD	ndi,s,nus,R9		; Setup field id
	BSBW	MOVCSTR			; Move the username
	$CNFFLD	ndi,s,npw,R9		; Setup password field id
	BSBW	MOVCSTR			; Move it
	$CNFFLD	ndi,s,nac,R9		; Setup account id
	BSBW	MOVCSTR			; Move it
5$:	MOVQ	(SP)+,R10		; Restore OBI CNF,CNR
10$:	MOVL	#1,R0			; Always successful
	RSB				; Return to co-routine to return desc.

NET$OBI_S_SFI::				; Startup file id string
	;
	;  Build .COM filename spec for image activation.
	;
	;   filename =  SYS$SYSROOT[SYSEXE]:file.COM if the object number NEQ 0
	;		file			     if the object number EQL 0
	;
	;		where "file" comes from OBI,S,FID if its defined
	;		or OBI,S,NAM otherwise.
	;
	BSBW	GET_TMPBUF_CO		; Co-routine to setup buffer pointer
	$GETFLD	obi,l,num		; Get the object number
	MOVL	R8,R1			; Is the object number zero?
	$GETFLD	obi,s,fid		; Setup field id
	BLBS	R0,10$			; If LBS then field is non-null
	$GETFLD	obi,s,nam		; Else use the object's name
	BLBC	R0,30$			; If LBC then null, filename is illegal
10$:	TSTL	R1			; Is this for object typ 0?
	BNEQ	20$			; If NEQ no, use system defaults
	MOVC3	R7,(R8),(R3)		; Else allow LOGIN to use user's defaults
	MOVB	#1,R0			; Indicate success
	BRB	30$			; Continue
20$:	MOVAB	W^NET$T_SYSFAB,R0	; Setup for "non-zero object" defaults
	MOVB	R7,FAB$B_FNS(R0)	; Set the current filename size
	MOVL	R8,FAB$L_FNA(R0)	; Set the current filename ptr
	MOVAB	W^NET$T_PRSNAM,R2	; Get output descriptor address
	MOVAB	(R3),NAM$L_ESA(R2)	; Set the buf ptr to rcv parse
	$PARSE	FAB = R0		; Get the filename
	MOVZBL	NAM$B_ESL(R2),R2	; Get the size of the filename
	ADDL	R2,R3			; Advance buffer pointer
30$:	RSB				; Return status in R0

;+
; NET$CRI_V_NUL	-  Get null field value (always = 1)
; NET$CRI_V_LCK	-  Get status of conditionally writeable fields
;
; NET$CRI_L_SUB -  Get circuit's substate
; NET$CRI_L_PNA	-  Get partner's node address
; NET$CRI_L_BLO -  Get partner's receive block size
;
; NET$CRI_S_COL -  Get circuit's collating value
; NET$CRI_S_PNN -  Get partner's node name
; NET$CRI_S_LOO -  Get line's loopback name
; NET$CRI_S_CNT -  Get (optionally clear) circuit counters
; NET$CRI_S_VMSNAM Get VMS name of associated device
; NET$CRI_S_CHR -  Get circuit's characteristics buffer
;
; INPUTS:	R11	CRI CNR address
;		R10	CRI CNF address
;		R9	FLD i.d. of field being read
;		R1	Scratch
;		R0	Scratch
;
; OUTPUTS:	R1	Address of string descriptor or address of field value
;		R0	Low bit set if R1 is valid
;			Low bit clear otherwise
;
;		All other register values are preserved.
;
;-
NET$CRI_V_NUL::				; Return the value 1
	BSBW	GET_TMPVAL_CO		; Call co-routine for common setup
	MOVL	#1,R1			; Field value
	MOVL	#1,R0			; Success
	RSB				; Return

NET$CRI_V_LCK::				; Get status of cond. writeable fields
	BSBW	GET_TMPVAL_CO		; Call co-routine to setup buffer
	BSBW	NET$LOCATE_LPD		; Locate the LPD
	BLBC	R0,10$			; If LBC no LPD, not locked
	TSTB	LPD$B_ASTCNT(R6)	; Any I/O outstanding?
	BNEQ	10$			; If NEQ yes, locked
	CLRL	R0			; Else not locked
10$:	MOVL	R0,R1			; Return as field value
	MOVL	S^#SS$_NORMAL,R0	; Success
	RSB


NET$CRI_L_SUB::				; Get circuit's substate	
	BSBW	GET_TMPVAL_CO		; Call co-routine to setup buffer
	BSBW	NET$LOCATE_LPD		; Locate the LPD
	BLBC	R0,10$			; If LBC, no LPD or substate
	CLRL	R0			; Assume in "run" state
	BBS	#LPD$V_RUN,-		; If BS then no sub-state
		    LPD$W_STS(R6),10$	;
	BBS	#LPD$V_DLE,-		; If BS then is used for "service" fcts
		    LPD$W_STS(R6),5$	;
	TSTB	LPD$B_STI(R6)		; Is the circuit in use at all?
	BEQL	10$			; If EQL then no
5$:	MOVZBL	LPD$B_SUB_STA(R6),R1	; Get sub-state
	MOVL	S^#SS$_NORMAL,R0	; Set status
10$:	RSB				; Return to co-routine

NET$CRI_L_BLO::				; Get partner's receive block size
	BSBW	GET_TMPVAL_CO		; Call co-routine to setup buffer
	BSBW	NET$LOCATE_LPD		; Locate the LPD
	BLBC	R0,10$			; If LBC, no LPD or partner node
	CLRL	R0			; Assume not in "run" state
	BBC	#LPD$V_RUN,-		; If BS then no block size
		    LPD$W_STS(R6),10$	;
	MOVZWL	LPD$W_XMTBUFSIZ(R6),R1	; Get partner's node address
	MOVL	S^#SS$_NORMAL,R0	; Set status
10$:	RSB				; Return to co-routine

NET$CRI_L_PNA::				; Get partner's node address
	BSBW	GET_TMPVAL_CO		; Call co-routine to setup buffer
	BSBW	NET$LOCATE_LPD		; Locate the LPD
	BLBC	R0,10$			; If LBC, no LPD or partner node
	CLRL	R0			; Assume not in "run" state
	BBC	#LPD$V_RUN,-		; If BC then no partner node
		    LPD$W_STS(R6),10$	;
	MOVZWL	LPD$W_PNA(R6),R1	; Get partner's node address
	MOVL	S^#SS$_NORMAL,R0	; Set status
10$:	RSB				; Return to co-routine

NET$CRI_L_MST::				; Get maintenance mode state
	BSBW	GET_TMPVAL_CO		; Call co-routine to setup buffer
	BSBW	NET$LOCATE_LPD		; Locate the LPD
	BLBC	R0,20$			; If LBC, no LPD or partner node
	MOVZWL	#NMA$C_STATE_ON,R1	; Assume state is "ON"
	BBS	#LPD$V_DLE,-		; If BS then maintenance state is "ON"
		    LPD$W_STS(R6),10$	;
	MOVZWL	#NMA$C_STATE_OFF,R1	; Else state is "OFF"
10$:	MOVL	S^#SS$_NORMAL,R0	; Set status
20$:	RSB				; Return to co-routine


NET$CRI_S_COL::				; Get circuit's collating value
	PUSHR	#^M<R9>			; Save regs
	$CNFFLD	cri,s,nam,R9		; Identify circuit's name field
	BSBW	CNF$GET_ADDR		; Point R1 to descriptor
10$:	POPR	#^M<R9>			; Restore regs
	RSB				; Return status in R0

NET$CRI_S_PNN::				; Get partner's node name
	BSBW	GET_TMPBUF_CO		; Call co-routine to setup buffer
	BSBW	NET$LOCATE_LPD		; Locate the LPD
	BLBC	R0,30$			; If LBC, no LPD or partner node
	CLRL	R0			; Assume not in "run" state
	BBC	#LPD$V_RUN,-		; If BC then no partner node
		    LPD$W_STS(R6),30$	;
	MOVZWL	LPD$W_PNA(R6),R8	; Get partner's node address
	PUSHR	#^M<R10,R11>		; Save regs
	MOVL	L^NET$GL_CNR_NDI,R11	; Get NDI root block
	BSBW	NET$NDI_BY_ADD		; Get the associated NDI CNF
	BLBC	R0,20$			; If LBC then none
	$GETFLD	ndi,s,nna		; Get node name 
	BLBC	R0,20$			; If LBC then not set
	MOVC3	R7,(R8),(R3)		; Move the name
	MOVZWL	#SS$_NORMAL,R0		; Indicate success
20$:	POPR	#^M<R10,R11>		; Restore regs
30$:	RSB				; Return status in R0

NET$CRI_S_LOO::				; Get line's loopback nodename
	BSBW	GET_TMPBUF_CO		; Call co-routine to setup buffer
	$GETFLD	cri,s,nam		; Get line name
	BLBC	R0,30$			; If LBC then error
	PUSHR	#^M<R10,R11>		; Save regs
	MOVL	L^NET$GL_CNR_NDI,R11	; Get NDI root block
	CLRL	R10			; Indicate no current NDI CNF
	$SEARCH	eql,ndi,s,nli		; Get find NDI with this loopback line
	BLBC	R0,20$			; If LBC then not found
	$GETFLD	ndi,s,nna		; Get the node name
	BLBC	R0,20$			; If LBC then not set
	MOVC3	R7,(R8),(R3)		; Move the name
	MOVZWL	#SS$_NORMAL,R0		; Indicate success
20$:	POPR	#^M<R10,R11>		; Restore regs
30$:	RSB				; Return status in R0

NET$CRI_S_VMSNAM::			; Get VMS name of device
	BSBW	GET_TMPBUF_CO		; Call co-routine to setup buffer
					; - buffer address is in R3
	$GETFLD	cri,s,nam		; Get network management circuit name
	BLBC	R0,100$			; If LBC then error
	BSBW	TRAN_DEVNAM		; Get VMS device name
	BLBC	R0,100$			; If LBC then error
	TSTL	R7			; Copy number of characters unparsed
	BEQL	100$			; If EQL none left unparsed
	;!
	;!   Could test for legality of remaining characters based on protocol 
	;!   type.
	;!
100$:	RSB				; Return status in R0

NET$CRI_S_CNT::				; Get line counters (maybe clear them)
	BSBW	GET_TMPBUF_CO		; Call common setup co-routine
	BSBW	NET$LOCATE_LPD		; Get associated LPD
	BLBC	R0,40$			; Error if LBC
					;
	PUSHL	R3			; Save starting address of counter block
	BSBB	50$			; Get the counters
	POPL	R2			; Recover original counter block ptr
					;
	BLBC	R0,40$			; If LBC then error
	MOVL	S^#EVC$C_SRC_CIR,R0	; Setup database event i.d.
	BSBW	LOG_COUNTERS		; Log the counters if they were zeroed
	MOVL	S^#SS$_NORMAL,R0	; Success
40$:	RSB				; Done

50$:	;
	;   Subroutine to build the counter block
	;
	MOVAB	LPD$L_ABS_TIM(R6),R1	; Point to counters
	MOVZWL	#4+LPD$C_CNT_SIZE,R2	; Number of bytes in block
					; +4 for ABS_TIME
	MOVAB	LPD_CNT_TAB,R5		; Point to counter formatting table
	BSBW	MOVE_FMT_CNT		; Move and format the counters
	;
	;   Get the counters from the driver and append to current counters
	;   minus the 'seconds since last zeroed' counter.
	;
	MOVZWL	LPD$W_CHAN(R6),R2	; Is there an I/O channel
	BEQL	90$			; If EQL no, skip this phase
	MOVZWL	#IO$_SENSEMODE!-	; Setup function code
		 IO$M_RD_COUNT,R0	;
	BSBW	DEV_CNT_QIO		; Issue circuit QIO for counters
90$:	MOVZWL	S^#SS$_NORMAL,R0	; Indicate success
100$:	RSB				; Done

NET$CRI_S_CHR::				; Get line's startup characteristics
	BSBW	GET_TMPBUF_CO		; Call co-routine to get temp buffer
	BSBW	NET$LOCATE_LPD		; Get associated LPD
	BLBC	R0,100$			; Error if LBC
	PUSHL	R3			; Save buffer pointer
	MOVC5	#0,(SP),#0,-		; Zero buffer header
		#DLLQIO$C_LENGTH,(R3)	; ...advance R3
	POPL	R5			; Point to DLLQIO block
	CLRL	R0			;& (better code) Assume no PLVEC index
	MOVZBL	LPD$B_PLVEC(R6),R4	; Get PLVEC index
	BEQL	100$			; Report error
	MOVL	LPD$L_UCB(R6),R0	; Get device UCB
	BEQL	100$			; If EQL then none
	MOVZWL	#IO$_SETMODE,-		; Setup I/O function code
		   DLLQIO$L_FUNC(R5)	;
	MOVAB	CRI_TRN_TAB,R2		; Setup parameter translation table
	PUSHAB	B^10$			; Setup return address
	$DISPATCH TYPE=B,L^PLVEC$AB_DEV[R4],- ; Dispatch on device type
	    <-
	    <DEVTRN$C_DEV_DMC,	   CRI_DMC>,-
	    <DEVTRN$C_DEV_PCL,     CRI_PCL>,-
	    <DEVTRN$C_DEV_DMP,	   CRI_DMP>,-
	    <DEVTRN$C_DEV_CI,	   CRI_CI>,-
	>
	BRB	CRI_FOREIGN		; Br if device is unknowm
10$:
100$:	RSB

CRI_DMP:
CRI_PCL:
CRI_CI:
CRI_FOREIGN:
	BSBW	BUILD_DEVBUF		; Build the device parameter buffer
	RSB				;

CRI_DMC:
	SUBL3	R5,R3,DLLQIO$L_P1(R5)	; Setup offset to characteristics buffer
	;
	;
	;   Get the characteristics buffer form the UCB.  This buffer was setup
	;   properly (with the exception of the MOP bit) from the PLI database
	;   when the corresponding DMC "line" was turned on.
	;
	;
	ASSUME	UCB$L_DEVDEPEND  EQ  2+UCB$W_DEVBUFSIZ
	ASSUME	UCB$W_DEVBUFSIZ  EQ  1+UCB$B_DEVTYPE
	ASSUME	UCB$B_DEVTYPE    EQ  1+UCB$B_DEVCLASS

	MOVQ	UCB$B_DEVCLASS(R0),(R3)+; Enter device characteristics
	BICB	S^#XM$M_CHR_MOP,-4(R3)	; Assume MOP mode not needed
	BBC	#LPD$V_DLE,-		; If BC not in use for direct-access
		    LPD$W_STS(R6),10$	; functions
	BISB	S^#XM$M_CHR_MOP,-4(R3)	; Put line in MOP mode
10$:	;
	;
	;   Get number of receive buffers from the PLI database
	;
	;
	PUSHR	#^M<R1,R10,R11>		; Save regs
	MOVL	W^NET$GL_CNR_PLI,R11	; Get PLI root block
	CLRL	R10			; Search from begining of list
	MOVL	R4,R8			; Search key is the PLVEC index
	$SEARCH	eql,pli,l,plvec		; Find PLI's CNF block
	BLBC	R0,15$			; If LBC then not found
	$GETFLD	pli,l,bfn		; Get # of receive buffers
	BLBS	R0,20$			; If LBS then field was active
15$:	MOVL	#4,R8			; Setup default
20$:	MOVL	R8,DLLQIO$L_P3(R5)	; Setup # of receive buffers
	POPR	#^M<R1,R10,R11>		; Restore regs
					;
	MOVB	#1,R0			; Indicate success
100$:	RSB				; Return status in R0

;+
; NET$PLI_V_NUL	-  Get null field value (always = 1)
; NET$PLI_V_LCK	-  Get status of conditionally writeable fields
;
; NET$PLI_L_SUB -  Get line's substate
; NET$PLI_L_BUS	-  Get line's receive buffer size
; NET$PLI_L_PLVEC  Get line's PLVEC index
;
; NET$PLI_S_COL -  Get line's collating value
; NET$PLI_S_VMSNAM Get VMS name of associated device
; NET$PLI_S_CNT -  Get (optionally clear) line counters
; NET$PLI_S_CHR -  Get line's characteristics buffer
;
; INPUTS:	R11	PLI CNR address
;		R10	PLI CNF address
;		R9	FLD i.d. of field being read
;		R1	Scratch
;		R0	Scratch
;
; OUTPUTS:	R1	Address of string descriptor or address of field value
;		R0	Low bit set if R1 is valid
;			Low bit clear otherwise
;
;		All other register values are preserved.
;
;-
NET$PLI_V_NUL::				; Return the value 1
	BSBW	GET_TMPVAL_CO		; Call co-routine for common setup
	MOVL	#1,R1			; Field value
	MOVL	#1,R0			; Success
	RSB				; Return

NET$PLI_V_LCK::				; Get status of cond. writeable fields
	BSBW	GET_TMPVAL_CO		; Call setup co-routine
	$GETFLD	pli,l,sta		; Get the state value
	BLBC	R0,10$			; If LBC then not locked
	CMPL	#NMA$C_STATE_OFF,R8	; Is the line turned off?
	BNEQ	10$			; If NEQ then locked
	CLRL	R0			; Say "not locked"
10$:	MOVL	R0,R1			; Return as field value
	MOVL	S^#SS$_NORMAL,R0	; Success
	RSB

NET$PLI_L_SUB::				; Get line's substate	
	BSBW	GET_TMPVAL_CO		; Call setup co-routine
	CLRL	R0			; No substate is defined for lines
					; at this time
	RSB				; Return status in R0

NET$PLI_L_PLVEC::			; Get line's PLVEC index
	BSBW	GET_TMPVAL_CO		; Call setup co-routine
	MOVZBL	CNF$W_ID(R10),R1	; Get the PLVEC index
	MOVL	S^#SS$_NORMAL,R0	; Success
	RSB				; Return

NET$PLI_L_BUS::				; Get line's receive buffer size
	BSBW	GET_TMPVAL_CO		; Call setup co-routine
	MOVL	W^NET$GL_PTR_VCB,R1	; Get RCB address
	MOVZWL	RCB$W_TOTBUFSIZ(R1),R1	; Store the local block size
	SUBW	#CXB$C_OVERHEAD,R1	; Subtract out overhead
	MOVZWL	#SS$_NORMAL,R0		; Success
	RSB				; Return status in R0

NET$PLI_S_COL::				; Get line's collating value
	PUSHR	#^M<R9>			; Save regs
	$CNFFLD	pli,s,nam,R9		; Identify line's name field
	BSBW	CNF$GET_ADDR		; Point R1 to descriptor
10$:	POPR	#^M<R9>			; Restore regs
	RSB				; Return status in R0

NET$PLI_S_VMSNAM::			; Get VMS name of device
	BSBW	GET_TMPBUF_CO		; Call co-routine to setup buffer
					; - buffer address is in R3
	$GETFLD	pli,s,nam		; Get network management line name 
	BLBC	R0,10$			; If LBC then error
	BSBW	TRAN_DEVNAM		; Translate the device name
	BLBC	R0,10$			; If LBC then error
	TSTL	R7			; Any characters left?
	BEQL	10$			; If EQL then none, name is okay
	CLRL	R0			; Error in <pli,s,nam> field
10$:	RSB				; Return status in R0

NET$PLI_S_CNT::				; Get line counters (maybe clear them)
	BSBW	GET_TMPBUF_CO		; Call common setup co-routine
	MOVZWL	CNF$W_ID(R10),R6	; Get PLVEC index
	CMPB	L^PLVEC$AB_DEV[R6],-	; No counters for DMC "lines" (special
		#DEVTRN$C_DEV_DMC	; case this since XMDRIVER does not
	BEQL	30$			; support the standard datalink driver
					; interface).
					;
	PUSHL	R3			; Save starting address of counter block
	BSBB	50$			; Get the counters
	POPL	R2			; Recover original counter block ptr
					;
	BLBC	R0,40$			; If LBC then error
	MOVL	S^#EVC$C_SRC_LIN,R0	; Setup database event i.d.
	BSBW	LOG_COUNTERS		; Log the counters if they were zeroed
30$:	MOVL	S^#SS$_NORMAL,R0	; Success
40$:	RSB				; Done

50$:	;
	;   Subroutine to build the counter block
	;
	MOVAL	PLVEC$AL_ABS_TIM[R6],R1	; Point to seconds since last zeroed
					; counters
	MOVL	#4,R2			; Number of bytes in block
	MOVAB	PLI_CNT_TAB,R5		; Point to counter formatting table
	BSBW	MOVE_FMT_CNT		; Move and format the counters
	;
	;   Get the counters from the driver and append to counter block
	;   being constructed.
	;
	MOVZWL	PLVEC$AW_CHAN[R6],R2	; Is there an I/O channel
	BEQL	90$			; If EQL no, skip this phase
	MOVZWL	#IO$_SENSEMODE!-	; Setup function code
		 IO$M_CTRL!-		; 
		 IO$M_RD_COUNT,R0	;
	BSBW	DEV_CNT_QIO		; Issue circuit QIO for counters
90$:	MOVZWL	S^#SS$_NORMAL,R0	; Indicate success
100$:	RSB				; Done


NET$PLI_S_CHR::				; Get line's startup characteristics
	BSBW	GET_TMPBUF_CO		; Call co-routine to get temp buffer
	PUSHL	R3			; Save pointer to buffer
	MOVC5	#0,(SP),#0,-		; Zero buffer header
		#DLLQIO$C_LENGTH,(R3)	; ...advance R3
	POPL	R5			; Point to top of buffer
	CLRL	R0			; Assume no PLVEC index assigned
	MOVZWL	CNF$W_ID(R10),R4	; Get PLVEC index
	BEQL	100$			; If EQL then return error
	;
	;   Setup default function value
	;
	$DISPATCH TYPE=B,L^PLVEC$AB_STATE[R4],-	; Dispatch by state value
	    <-
	    <NMA$C_STATE_OFF,	10$>,-
	    <NMA$C_STATE_ON,	20$>,-
	>
	MOVW	#IO$_SETMODE!IO$M_CTRL,R0 ; Use this for all other states
	BRB	30$			; Continue
10$:	MOVW	#IO$_SETMODE!IO$M_CTRL!-; State is "off"
		IO$M_SHUTDOWN,R0	;
	BRB	30$			; Continue
20$:	MOVW	#IO$_SETMODE!IO$M_CTRL!-; State is "on"
		IO$M_STARTUP,R0		;
30$:	MOVZWL	R0,DLLQIO$L_FUNC(R5)	; Setup I/O function code
	MOVAB	PLI_TRN_TAB,R2		; Point to param translation table
	PUSHAB	B^40$			; Setup return address

	$DISPATCH TYPE=B,L^PLVEC$AB_DEV[R4],- ; Dispatch on device type
	    <-
	    <DEVTRN$C_DEV_DMC,	   PLI_DMC>,-
	    <DEVTRN$C_DEV_PCL,     PLI_PCL>,-
	    <DEVTRN$C_DEV_DMP,	   PLI_DMP>,-
	    <DEVTRN$C_DEV_CI,	   PLI_CI>,-
	>
	BRB	PLI_FOREIGN		; Br if device is unknown
40$:
100$:	RSB

PLI_DMP:
PLI_PCL:
PLI_CI:
PLI_FOREIGN:
	BSBW	BUILD_DEVBUF		; Build the parameter buffer
	RSB

PLI_DMC:
	CLRL	R1			; Say "start with LPD index 0"
	BSBW	NET$GET_PLVECLPD	; Find next LPD actively using this line
	BLBS	R0,10$			; If LBS then found one
	BICW	#IO$M_SHUTDOWN,-	; Can't issue "SHUTDOWN" if device is
		DLLQIO$L_FUNC(R5)	; not active
10$:	BICW	#IO$M_STARTUP!-		; Special case -- DMC does not support
		 IO$M_CTRL,-		; these modifiers in for its "line"
		DLLQIO$L_FUNC(R5)	; aspect
	SUBL3	R5,R3,DLLQIO$L_P1(R5)	; Setup offset to characteristics buffer
	MOVB	#DC$_SCOM,(R3)+		; Enter device class
	MOVB	#DT$_DMC11,(R3)+	; Enter device type
	;
	;   For now, all lines use the same buffer size.
	;
	MOVL	W^NET$GL_PTR_VCB,R1	; Get RCB address
	MOVZWL	RCB$W_TOTBUFSIZ(R1),R1	; Store the local block size
	SUBW3	#CXB$C_OVERHEAD,R1,(R3)+; Subtract out overhead
	CLRL	(R3)			; Zero the characteristis
	$GETFLD	pli,v,con		; Get loopback field value
	BLBC	R8,20$			; If LBC not in controller loopback
	BISB	S^#XM$M_CHR_LOOPB,(R3)  ; Else set loopback bit
	BRB	30$			; Don't bother with HDPLX
20$:	$GETFLD	pli,v,dup		; Get duplex selector
	BLBC	R8,30$			; LBS in R0 if half-duplex
	BISB	S^#XM$M_CHR_HDPLX,(R3)	; Put line in half-duplex
30$:	TSTL	(R3)+			; Advance past characteristics
	MOVB	#1,R0			; Indicate success
	RSB				; Return status in R0


BUILD_DEVBUF:				; Build device param buffer
	MOVL	R3,DLLQIO$L_P2(R5)	; Setup pointer to device parameter
					; buffer descriptor
	ADDL	#8,R3			; Allow 8 bytes for the descriptor
	MNEGL	R3,@DLLQIO$L_P2(R5)	; Prepare for size calculation
	SUBL3	R5,R3,-4(R3)		; Setup offset to param buffer
	PUSHR	#^M<R4,R5,R6>		; Save regs
	MOVL	R2,R6			; Point to translation table

10$:	ASSUME	CNVTAB$V_NMA  EQ   0
	ASSUME	CNVTAB$S_NMA  EQ  16

	TSTW	(R6)			; At end of table ?
	BEQL	40$			; If EQL then yes
	MOVB	CNR$B_TYPE(R11),-(SP)	; Enter database i.d.
	EXTZV	#CNVTAB$V_FMT,-		; Get param format type
		#CNVTAB$S_FMT,(R6),R1	;
	MOVB	R1,-(SP)		; Append to param database i.d.
	EXTZV	#CNVTAB$V_INT,-		; Get internal param i.d. index
		#CNVTAB$S_INT,(R6),R1	;
	MOVW	R1,-(SP)		; Append param i.d.
	POPL	R9			; Get compelete param i.d., fix stack
	BSBW	CNF$GET_FIELD		; Get the field value
	BLBC	R0,30$			; If LBC then param is not set
	MOVW	(R6),(R3)+		; Enter the NICE param i.d.
	CMPL	R1,#NFB$C_TYP_STR	; String ?
	BEQL	20$			; If EQL yes
	MOVL	R8,(R3)+		; Enter the parameter value
	BRB	30$			; Continue
20$:	MOVW	R7,(R3)+		; Enter the string length
	MOVC3	R7,(R8),(R3)		; Enter the string text, update R3
30$:	TSTL	(R6)+			; Advance to next table entry
	BRB	10$			; Loop
40$:	POPR	#^M<R4,R5,R6>		; Restore regs
	ADDL	R3,@DLLQIO$L_P2(R5)	; Complete size calculation
	SUBL	R5,DLLQIO$L_P2(R5)	; Convert pointer to offset
	MOVL	#SS$_NORMAL,R0		; Setup status
	RSB


;+
; NET$ESI_V_NUL	-  Get null field value (always = 1)
; NET$ESI_V_LCK -  Get status of conditionally writeable fields
; NET$ESI_S_COL -  Get collating value
;
; INPUTS:	R11	NDI CNR address
;		R10	NDI CNF address
;		R9	FLD i.d. of field being read
;		R1	Scratch
;		R0	Scratch
;
; OUTPUTS:	R1	Address of field value or longword string descriptor
;		R0	Low bit set if R1 is valid
;			Low bit clear otherwise
;
;		All other register values are preserved.
;
;-
NET$ESI_V_NUL::				; Return the value 1
	BSBW	GET_TMPVAL_CO		; Call co-routine for common setup
	MOVL	#1,R1			; Field value
	MOVL	#1,R0			; Success
	RSB				; Return

NET$ESI_V_LCK::				; Get status of cond. writeable fields
	;
	;   If the state is not "OFF" then the CNF is writelocked
	;
	BSBW	GET_TMPVAL_CO		; Call get temp storage co-routine
	$GETFLD	esi,l,sta		; Fetch UCB field
	BLBC	R0,10$			; If field isn't set then CNF not locked
	CMPL	S^#NMA$C_STATE_OFF,R8	; Is the state "OFF"
	BNEQ	10$			; If not with R0=1
	CLRL	R0			; Otherwize, CNF is not locked	
10$:	MOVL	R0,R1			; Setup field value
	MOVL	S^#SS$_NORMAL,R0	; Success
	RSB				; Return to co-routine

NET$ESI_S_COL::				; Get collating value
	BSBW	GET_TMPBUF_CO		; Call co-routine to get temp buffer
	$CNFFLD	esi,l,snk,R9		; Specify sink type
	BRB	CONVERT			; Store it as a string


;+
; NET$EFI_V_NUL	-  Get null field value (always = 1)
; NET$EFI_V_LCK -  Get status of conditionally writeable fields
; NET$EFI_S_COL -  Get collating value
;
; INPUTS:	R11	NDI CNR address
;		R10	NDI CNF address
;		R9	FLD i.d. of field being read
;		R1	Scratch
;		R0	Scratch
;
; OUTPUTS:	R1	Address of field value or longword string descriptor
;		R0	Low bit set if R1 is valid
;			Low bit clear otherwise
;
;		All other register values are preserved.
;
;-
NET$EFI_V_NUL::				; Return the value 1
	BSBW	GET_TMPVAL_CO		; Call co-routine for common setup
	MOVL	#1,R1			; Field value
	MOVL	#1,R0			; Success
	RSB				; Return

NET$EFI_V_LCK::				; Get status of cond. writeable fields
	CLRL	R0			; CNF is never locked	
10$:	MOVAB	W^TMP_VAL,R1		; Store address of value
	MOVL	R0,(R1)			; Return as field value
	MOVL	S^#SS$_NORMAL,R0	; Success
	RSB				; Return R0,R1

NET$EFI_S_COL::				; Get collating value
	BSBW	GET_TMPBUF_CO		; Call co-routine to get temp buffer
	$CNFFLD	efi,l,sin,R9		; Specify sink node address
CONVERT:BSBW	CNF$GET_FIELD		; Get its value
	BLBC	R0,10$			; If LBC then not active
	PUSHL	R8			; Push it onto the stack
	MOVB	(SP)+,(R3)+		; Move all 4 bytes to buffer, high
	MOVB	(SP)+,(R3)+		; order byte first
	MOVB	(SP)+,(R3)+
	MOVB	(SP)+,(R3)+
10$:	RSB				; Retrun to co-routine

;+
; NET$LLI_V_NUL	- Get Null field (always returns value=1)
; NET$LLI_V_LCK	- See if CNF is write-locked
;
; NET$LLI_S_PNN	- Get Partner node name
; NET$LLI_S_COL	- Get collating value
; NET$LLI_S_PRC	- Get owner process name
; NET$LLI_S_USR	- Get owner user name
; NET$LLI_S_RID	- Get remote user i.d.
;
;-
NET$LLI_V_NUL::				; Return the value 1
	BSBW	GET_TMPVAL_CO		; Call co-routine for common setup
	MOVL	#1,R1			; Field value
	MOVL	#1,R0			; Success
	RSB				; Return

NET$LLI_V_LCK::				; Set if CNF is write-locked
	BSBW	GET_TMPVAL_CO		; Call co-routine for common setup
	MOVL	#1,R1			; Field value
	MOVL	#1,R0			; Success
	RSB				; Return


NET$LLI_S_RID::				; Get remote user i.d.
	BSBW	GET_TMPBUF_CO		; Call co-routine for common setup
	MOVZBL	CNF$C_LENGTH -		;
		+XWB$B_RID(R10),R0	; Get remote user i.d. string length
	BEQL	10$			; If EQL return with LBC in R0
	MOVC3	R0,CNF$C_LENGTH -	;
		   +XWB$T_RID(R10),(R3)	; Move the name
	MOVL	#SS$_NORMAL,R0		; Indicate sucess
10$:	RSB				; Return


NET$LLI_S_PRC::				; Get owner process name
	BSBW	GET_TMPBUF_CO		; Call co-routine for common setup
	BSBB	GET_JPI			; Get Job/process info
	BLBC	R0,10$			; If LBC then info not found
	MOVZBL	PNAMES,R0		; Get string size
	BEQL	10$			; If EQL return with LBC in R0
	MOVC3	R0,PNAME,(R3)		; Move the process name
	MOVL	#SS$_NORMAL,R0		; Indicate sucess
10$:	RSB				; Return

NET$LLI_S_USR::				; Get owner user name
	BSBW	GET_TMPBUF_CO		; Call co-routine for common setup
	BSBB	GET_JPI			; Get Job/process info
	BLBC	R0,10$			; If LBC then info not found
	MOVZBL	UNAMES,R0		; Get string size
	BEQL	10$			; If EQL return with LBC in R0
	MOVC3	R0,UNAME,(R3)		; Move the username
	MOVL	#SS$_NORMAL,R0		; Indicate sucess
10$:	RSB				; Return

GET_JPI:				; Get Job/process info
	MOVL	CNF$C_LENGTH -		;
		+XWB$L_PID(R10),R0	; Any PID yet ?
	BEQL	10$			; If EQL no, return LBC in R0
	$GETJPI_S -			;
	    PIDADR = CNF$C_LENGTH+XWB$L_PID(R10),- ; PID of process of interest
	    EFN    = #NET$C_EFN_WAIT,-	; Event flag
	    IOSB   = QIOW_Q_IOSB,-	; IOSB
	    ITMLST = ITEM_LIST		; Item list for return
	BLBC	R0,10$			; Br on error
	$WAITFR_S  EFN = #NET$C_EFN_WAIT; Wait for $GETJPI to finish
	MOVZWL	QIOW_Q_IOSB,R0		; Setup status
10$:	RSB				; Return status in R0

NET$LLI_S_COL::				; Collating value
	BSBW	GET_TMPBUF_CO		; Call co-routine to setup buffer
	MOVB	CNF$C_LENGTH -		; Insert remode node address
		+XWB$W_REMNOD+1(R10),(R3)+ ; ... high order first
	MOVB	CNF$C_LENGTH -		; 
		+XWB$W_REMNOD(R10),(R3)+; 
	MOVB	CNF$C_LENGTH -		; 
		+XWB$W_LOCLNK(R10),R0	;
	BICW	#NET$M_MAXLNKMSK,-(SP)	; Use index bits only
	TSTB	(SP)+			; Waste the low order bits
	MOVB	(SP)+,(R3)+		; Insert high order
	MOVB	R0,(R3)+		; Insert high order
	MOVB	#SS$_NORMAL,R0		; Indicate success
	RSB

NET$LLI_S_PNN::				; Partner node name
	PUSHR	#^M<R8,R9,R10,R11>	; Save regs
	MOVZWL	CNF$C_LENGTH -		; Get node address
		+XWB$W_REMNOD(R10),R8	;
	MOVL	L^NET$GL_CNR_NDI,R11	; Get the NDI root block
	BSBW	NET$NDI_BY_ADD		; Get associated NDI CNF address
	BLBC	R0,10$			; If LBC then no NDI
	$CNFFLD	ndi,s,nna,R9		; Identify node name field
	BSBW	CNF$GET_ADDR		; Point R1 to descriptor
10$:	POPR	#^M<R8,R9,R10,R11>	; Restore regs
	RSB				; Return status in R0

;++
;
; NET$GET_LOC_STA - Get the state of the local node
;
; INPUTS:	None
;
; OUTPUTS:	R0	State value
;
;		All other registers are preserved
;
;--
NET$GET_LOC_STA::			; Return local state in R0
	PUSHR	#^M<R7,R8,R9,R10,R11>	; Save regs
	MOVL	L^NET$GL_CNR_LNI,R11	; Setup the Root block ptr
	MOVL	CNR$L_FLINK(R11),R10	; Get the first CNF block
	BBS	#CNF$V_FLG_CNR,-	; If its the root then the CNF list
		    CNF$B_FLG(R10),10$	; is empty
	$GETFLD	lni,l,sta		; Get the local state
	BLBS	R0,20$			; Br if valid
10$:	MOVW	#LNI$C_STA_OFF,R8	; Assume the "off" state
20$:	MOVL	R8,R0			; Get the state value
	POPR	#^M<R7,R8,R9,R10,R11>	; Restore regs
	RSB

	.SBTTL	NET$NDI_BY_ADD  - Find NDI CNF by node address
;+
;
; NET$NDI_BY_ADD	- Find NDI CNF by node address
;
; FUNCTIONAL DESCRIPTION:
;
; The node address is used as an index into the NDI vector in order to locate
; corresponding CNF block.  Only "real" NDI CNF blocks are considered valid,
; the so called "phantom" and "loop" node CNFs are not returned.
;
; This routine is merely an optimization.  It could be replaced with a call
; to  $SEARCH  eql,ndi,l,add.   The optimization is desireable since this
; is done so often.
;
; INPUTS:	R10	Scratch
;		R8	Node address
;		R0	Scratch
;
; OUTPUTS:	R10	NDI address if found, else 0
;		R0	LBS if found
;			LBC otherwise
;
;		All other registers are unchanged
;-
NET$NDI_BY_ADD::			; Get NDI by node address
	MOVL	W^NET$GL_PTR_VCB,R0	; Get the RCB pointer
	CMPL	R8,#NET$C_MAX_NODES	; Is R8 within ACP limits
	BGTRU	10$			; If GTRU then out of range
	CMPW	R8,RCB$W_MAX_ADDR(R0)	; Is the node address within 
					; network management range?
	BGTRU	10$			; If GTRU then out of range
	MOVL	W^NET$AL_NDI_VEC[R8],R10; Get the NDI pointer
	BBC	#CNF$V_FLG_ACP,-	; If BS then "real" CNF
		     CNF$B_FLG(R10),15$	;
	MOVL	W^NET$AL_NDI_VEC,R10	; Assume local node
	CMPW	R8,RCB$W_ADDR(R0)	; Is this the local node?
	BEQL	15$			; If EQL then yes
10$:	CLRL	R0			; Indicate failure
	CLRL	R10			; Invalidate the NDI pointer
	BRB	20$			; Take common exit
15$:	MOVL	#1,R0			; Assume success
20$:	RSB

	.SBTTL	NET$CVT_NMA_INT - Convert NMA to NFB code
;+
; NET$CVT_NMA_INT - Convert an NMA code returned by a datalink driver
; to a internal NFB parameter code.
;
; Inputs:	R11 = CNR address
;		R9 = NMA code
;
; Outputs:	R9 = NFB code corresponding to NMA code
;			(or original, if could not map the code)
;-
NET$CVT_NMA_INT::			; Convert NMA i.d. to internal i.d.
	PUSHR	#^M<R1,R2,R5>		; Save regs
	MOVAB	CRI_TRN_TAB,R5		; Assume CRI database
	CMPB	#NFB$C_DB_CRI,-		; Circuit database ?
		    CNR$B_TYPE(R11)	; 
	BEQL	10$			; If EQL then yes
	MOVAB	PLI_TRN_TAB,R5		; Else PLI database
10$:	MOVL	R9,R2			; Copy NMA code to be converted
	BSBB	CVT_NMA_INT		; Convert the i.d.
	POPR	#^M<R1,R2,R5>		; Restore regs
	RSB

;
; Do the actual conversion of NMA to NFB parameter codes.
;

CVT_NMA_INT:				; Convert NMA i.d. to internal i.d.
	CLRL	R0			; Assume conversion error
40$:	MOVL	(R5)+,R1		; Get next table entry
	BEQL	100$			; If EQL table is exhausted, report
					; that the driver is not supported
	ASSUME	NFB$V_INX	EQ   0
	ASSUME	NFB$V_TYP	EQ  16
	ASSUME	NFB$V_DB 	EQ  24
	ASSUME	CNVTAB$V_NMA	EQ   0
	ASSUME	CNVTAB$S_NMA	EQ  16

	CMPW	R1,R2			; Is this it?
	BNEQ	40$			; If NEQ then keep trying
	EXTZV	#CNVTAB$V_INT,-		;
		#CNVTAB$S_INT,R1,-(SP)	; Put internal code on stack longword
	EXTZV	#CNVTAB$V_FMT,-		; Get field format type
		#CNVTAB$S_FMT,R1,R2	; 
	MOVB	R2,2(SP)		; Insert format into TYP field
	MOVB	CNR$B_TYPE(R11),3(SP)	; Insert database id into DB field
	POPL	R9			; Get full field i.d., cleanup stack
	MOVL	#1,R0			; Indicate successful conversion
100$:	RSB

;+
; TRAN_DEVNAM	Translate Network Managment name to VMS device name
;
; This routine translates a network management line/circuit name to a VMS
; device name.  Network management line names have the format "dev-c-u" and
; circuit names have the format "dev-c-u.t"  where c,u,t are ascii-decimal 
; strings and "dev" is a network managment device numeric.
;
; INPUTS:	R8	Pointer to network management name
;		R7	Number of characters in name
;		R3	Output buffer pointer
;
; OUPUTS:	R8	Pointer to first unparsed character
;		R7	Number of unparsed characters
;		R6	Pointer to device table entry
;		R5,R4	Garbage
;		R3	Advanced by characters in translated name
;		R2,R1	Garbage
;		R0	Status
;
;		All other regs are perserved
;-
TRAN_DEVNAM:
	;
	;   Parse the device mnemonic, locate translation table entry
	;
	BSBB	PRS_MNEMONIC		; Parse name, locate entry in table
	BLBC	R0,100$			; If LBC then error
	MOVC3	R2,(R1),(R3)		; Move the VMS device mnemonic
	;
	;			 dev-c-u.t
	;   We've parsed up to here  ^	   Translate the controller specifier.
	;
	MOVZBL	#^A".",R4		; Setup field delimiter for single-unit
					; device (i.e., no unit field)
	BBC	#DEVTRN$V_MULTI,-	; If BC then not multi-unit device
		 DEVTRN$B_CHAR(R6),20$	; and there's no unit field
	MOVZBL	#^A"-",R4		; Setup field delimiter
20$:	BSBB	PRS_DECIMAL		; Convert the controller to binary
	BLBC	R0,100$			; If LBC then error
	TSTL	R2			; Any decimal characters parsed ?
	BEQL	100$			; If EQL no, illegal name
	CMPB	R1,#25			; Within range (0=A, 25=Z)
	BGTRU	100$			; If GTRU then out of range
	ADDB3	#^A"A",R1,(R3)+		; Store as VMS controller designator
	;
	;				dev-c-u.t
	;   We have parsed up to here         ^      Parse the unit number.  
	;
	CLRL	R0			; Assume single-unit device
	BBC	#DEVTRN$V_MULTI,-	; If BC then single-unit device and
		 DEVTRN$B_CHAR(R6),30$	; there's no unit field
	MOVZBL	#^A".",R4		; Setup field delimiter
	BSBB	PRS_DECIMAL		; Convert the Ascii unit to binary
	BLBC	R0,100$			; If LBC then illegal name
	MOVL	R1,R0			; Get the binary value
30$:	BSBW	NET$BIN2ASC		; Move to @R3 as Ascii
	MOVL	#SS$_NORMAL,R0		; Indicate success
	BRB	110$			; Take common exit

100$:	MOVZWL	#SS$_IVDEVNAM,R0	; Error in translated name
110$:	RSB				; Return status in R0

;+
; PRS_MNEMONIC	- Parse device mnemonic
;
; INPUTS:	R8	Pointer to device name
;		R7	Characters left in device name string
;
; OUTPUTS:	R8	Advanced by characters parsed
;		R7	Reduced by characters parsed
;		R6	Pointer to device table entry
;		R5	Size of VMS device mnemonic
;		R4	Pointer to VMS device mnemonic
;		R2	Size of network management device mnemonic
;		R1	Pointer to network management device mnemonic
;		R0	SS$_NORMAL    if successful
;			SS$_IVDEVNAM  otherwise
;	
;		All other regs are unchanged
;-
PRS_MNEMONIC:
	PUSHL	R3		        ; Save reg
	MOVZWL	#SS$_NOSUCHDEV,R0	; Assume error in name format
	MOVL	R8,R4			; Make a copy of the name pointer
	MNEGL	#1,R5			; Init the character count
	MOVAB	DEVTRN_TABLE-DEVTRN$C_LENGTH,R6 ; Prepare to scan device table
	;
	;   Parse the device mnemonic
	;
10$:	INCL	R5			; Update the character count
	SOBGTR	R7,20$			; If GTR then more characters are left
	BRW	100$			; Take common exit to report the error
20$:	CMPB	(R8)+,#^A"-"		; Mnemonic delimiter ?
	BNEQ	10$			; If NEQ then keep trying
	;
	;   Locate the table entry
	;
30$:	ADDL	#DEVTRN$C_LENGTH,R6	; Advance to next entry
	MOVZBL	DEVTRN$B_NETMAN(R6),R1	; Get length of network management name
	BEQL	40$			; If EQL then at end of table
	CMPL	R1,R5			; Same size ?
	BNEQ	30$			; If NEQ no, advance to next entry
	CMPC	R5,(R4),-		; Is this it ?
		    DEVTRN$T_NETMAN(R6)	;
	BNEQ	30$			; If NEQ then loop
	MOVZBL	DEVTRN$B_VMS(R6),R2	; Setup length of VMS mnemonic
	MOVAB	DEVTRN$T_VMS(R6),R1	; Setup pointer to mnemonic 
	BRB	50$			; Take common exit
40$:	MOVQ	R4,R1			; Make a copy of the Net Man. mnemonic
50$:	MOVL	S^#SS$_NORMAL,R0	; Indicate success
100$:	POPL	R3			; Restore R3
	RSB				; Return status in R0

;+
; PRS_DECIMAL	- Convert Ascii decimal number to a binary value
;
; INPUTS:	R7	Count of characters remaining in the string
;		R8	Address of string
;		R4	Field delimiter
;
; OUTPUTS:	R8	Advanced by characters parsed
;		R7	Reduced by characters parsed
;		R2	Number of numeric characters parsed
;		R1	Binary value
;		R0	SS$_NORMAL     if successful
;			SS$_INVDEVNAM  otherwise
;-
PRS_DECIMAL:				; Parse/convert ascii decimal to binary
	CLRQ	R1			; Init binary value, character count
10$:	DECL	R7			; Account for next character
	BLSS	15$			; If LSS then done
	MOVZBL	(R8)+,R0		; Get next character
	CMPB	R4,R0			; Is it the delimiter?
	BEQL	20$			; If EQL then done
	SUBB	#^A"0",R0		; Convert to binary
	BLSS	30$			; If LSS then not decimal
	CMPB	R0,#9			; Decimal ?
	BGTRU	30$			; If GTRU not decimal
	INCL	R2			; Bump number of digits
	MULL	#10,R1			; Shift total one digit
	BVS	30$			; If VS then R1 has overflowed
	ADDL	R0,R1			; Complete the sum
	BRB	10$			; Loop
15$:	CLRL	R7			; Repair R7
20$:	MOVZWL	S^#SS$_NORMAL,R0	; Indicate success
	BRB	40$			; Take common exit
30$:	MOVZWL	#SS$_IVDEVNAM,R0	; Indicate invalid device name
40$:	RSB				; Return status in R0


;
; Subroutine to move CNF string field
;
MOVCSTR:
	BSBW	CNF$GET_FIELD		; Set field descriptor
	PUSHL	R0			; Save status
	MOVB	R7,(R3)+		; Enter count (could be zero)
	BRB	MOVIT			; Move the string
MOVSTR:
	BSBW	CNF$GET_FIELD		; Set field descriptor
	PUSHL	R0			; Save status
MOVIT:	MOVC3	R7,(R8),(R3)		; Move the string
	POPL	R0			; Restore status
	RSB

;+
; GET_TMPBUF_CO	- Coroutine used by action routines for string parameters
;
; INPUTS:	R0,R1	Scratch
;
; ON CALLBACK:	R4-R9	Scratch
;		R3	Pointer to output buffer which will to hold string
;		R2-R0	Scratch
;
;-
GET_TMPBUF_CO:				; Get temp buffer co-routine
	BBSS	#TMP_V_BUF,-		;
		TMP_B_FLAGS,10$		; Mark buffer in use
	POPL	R0			; Get caller's address
	PUSHR	#^M<R2,R3,R4,R5,R6,R7,R8,R9> ; Save clobbered regs
	MOVAB	W^TMP_BUF,R3		; Setup buffer pointer
	JSB	(R0)			; Call back for data
	MOVAB	W^TMP_VAL,R1		; Point to descriptor storage
	MOVAB	W^TMP_BUF,R2		; Get original pointer
	SUBW3	R2,R3,STR_LNG(R1)	; Setup string size
	MOVW	#TMP_BUF-TMP_VAL,-	; Setup string offset
		STR_OFF(R1)
	POPR	#^M<R2,R3,R4,R5,R6,R7,R8,R9> ; Restore clobbered regs
	BBCC	#TMP_V_BUF,-		; Mark buffer available
		TMP_B_FLAGS,10$		;
	RSB				; Return status in R0

10$:	BUG_CHECK	NETNOSTATE,FATAL


;+
; GET_TMPVAL_CO	- Coroutine used by action routines for non-string parameters
;
; INPUTS:	R0,R1	Scratch
;
; ON CALLBACK:	R6-R9	Scratch
;		R1-R0	Scratch
;
;-
GET_TMPVAL_CO:				; Common co-routine to get temp storage
	BBSS	#TMP_V_VAL,-		;
		TMP_B_FLAGS,20$		; Mark TMP_VAL in use
	POPL	R1			; Get caller's address
	PUSHR	#^M<R6,R7,R8,R9>	; Save regs
	JSB	(R1)			; Call back caller
	MOVL	R1,W^TMP_VAL		; Save R1
	MOVAB	W^TMP_VAL,R1		; Point to it
10$:	POPR	#^M<R6,R7,R8,R9>	; Restore regs
	BBCC	#TMP_V_VAL,-		; Mark TMP_VAL available
		TMP_B_FLAGS,20$		;
	RSB				; Return status in R0

20$:	BUG_CHECK	NETNOSTATE,FATAL


;+
; MOVE_FMT_CNT	- Move and format counters
;
; INPUTS:	R5	Address of table to driver counter formatting
;		R3	Address of next byte in output buffer
;		R2	Number of bytes in source counter block
;		R1	Pointer to source counter block
;		R0	Scratch
;
; OUTPUTS:	R3	Updated to next free byte in output buffer
;		R2,R1	Garbage
;		R0	SS$_NORMAL
;
;		All other registers are preserved
;-
MOVE_FMT_CNT:				; Move and format counters
	PUSHL	R6			; Save R6
	SUBL	#CNT_FMT_BUFSIZ,SP	; Create work area on stack
	MOVL	SP,R6			; Point to it with R6
	;
	;   Lock out NETDRIVER and take a snapshot of the counters.  While
	;   NETDRIVER is locked out, clear the counters if its called for.
	;
	DSBINT	#NET$C_IPL		; Lock out Netdriver
	PUSHR	#^M<R1,R2,R3,R4,R5>	; Save regs
	MOVC3	R2,(R1),(R6)		; Move counters
	SUBL3	(R6),G^EXE$GL_ABSTIM,(R6) ; Get seconds since last zeroed
	MOVQ	(SP),R1			; Get R1,R2 (counter descriptor)
	BBC	#NET$V_CLRCNT,-		; If BC, don't clear the counters
		    W^NET$GL_FLAGS,20$	;
	MOVL	G^EXE$GL_ABSTIM,(R1)+	; Reset Abs-time since last zeroed
	SUBL	#4,R2			; Adjust bytes left in counter block
	MOVC5	#0,(SP),#0,R2,(R1)	; Zero remaining counters
20$:	POPR	#^M<R1,R2,R3,R4,R5>	; Restore regs
	ENBINT				; Restore IPL
	;
	;   Move 'seconds since last zeroed' in NICE format to output buffer
	;
	CMPL	(R6),#^X<FFFF>		; Has counter overflowed?
	BLEQU	30$			; If LEQU no
	MNEGW	#1,(R6)			; Latch counter at max value
30$:	MOVW	#NET$C_NMACNT_SLZ,(R3)+	; Enter i.d. of counter
	CVTLW	(R6),(R3)+		; Enter 'seconds since last zeroed'
	;
	;   Move each counter one at a time in NICE format to the output buffer
	;
40$:	MOVW	(R5)+,R2		; Get the next NICE counter i.d.
	BEQL	100$			; If EQL then done
	MOVZWL	(R5)+,R1		; Get offset to counter value
	ADDL	R6,R1			; Get pointer to counter value
	MOVW	R2,(R3)+		; Enter NICE counter i.d.
	EXTZV	#13,#2,R2,R2		; Get width of counter
	$DISPATCH  R2,-			; Dispatch on width
	<-				;
		<1, 70$>,-		; Byte
		<2, 60$>,-		; Word
		<3, 50$>,-		; Longword
	>				;
	BUG_CHECK	NETNOSTATE,FATAL

50$:	MOVW	(R1)+,(R3)+		; Counter is a longword
60$:	MOVB	(R1)+,(R3)+		; Counter is a word
70$:	MOVB	(R1)+,(R3)+		; Counter is a byte
	BRB	40$			; Loop
100$:	;
	;   Done, restore the stack and return
	;
	ADDL	#CNT_FMT_BUFSIZ,SP	; Restore the stack
	POPL	R6			; Restore R6
	MOVZWL	#SS$_NORMAL,R0		; Always successful
	RSB				; Return


;+
; DEV_CNT_QIO   - Get counters from device driver
;
; INPUTS:	R5,R4	Scratch	
;		R3	Address of next byte in output buffer
;		R2,R1	Scratch	
;		R0	$QIO function code
;
; OUTPUTS:	R5,R4	Garbage
;		R3	Updated to next free byte in output buffer
;		R2,R1	Garbage
;		R0	SS$_NORMAL
;
;		All other registers are preserved
;-
DEV_CNT_QIO:
	MOVL	R3,R4			; Save output buffer pointer
	BBC	#NET$V_CLRCNT,-		; If BC, don't clear the counters
		    W^NET$GL_FLAGS,20$	;
	BISW	#IO$M_CLR_COUNT,R0	; Else clear the counters
20$:	CLRQ	QIOW_Q_IOSB		; Init IOSB image
	SUBL3	R3,#TMP_BUF_END,-	; Setup bytes left in buffer
		    TMP_Q_DESC		;
	MOVL	R3,TMP_Q_DESC+4		; Point to it
	$QIOW_S	FUNC = R0,-
		CHAN = R2,-
		EFN  = #NET$C_EFN_WAIT,-
		IOSB = QIOW_Q_IOSB,-
		P2   = #TMP_Q_DESC	
	MOVZWL	QIOW_Q_IOSB+2,R0	; Get number of bytes returned
	BEQL	90$			; If EQL then none
	ADDL	R0,R3			; Advance R3
	CMPL	#4,R0			; At least 4 bytes ?
	BGTR	90$			; If GTR no, return all bytes
	CMPL	(R4),#NET$C_NMACNT_SLZ 	; Seconds since last zeroed ?
	BNEQ	90$			; If NEQ no, return whats left
	SUBL	#4,R0			; Reduce by size of counter field
	MOVC3	R0,4(R4),(R4)		; Shift remaning counters, setup R3
90$:	MOVZWL	S^#SS$_NORMAL,R0	; Indicate success
	RSB				; Done

;+
; LOG_COUNTERS	-	Conditionally log zero counter event
;
; INPUTS:	R11	CNR pointer
;		R10	CNF pointer
;		R5	Scratch
;		R3	Address of first byte past counter  block
;		R2	Address of counter block
;		R0	EVC database i.d.
;
; OUTPUT:	R5,R0	Garbage
;
;		All other registers are preserved.
;-
LOG_COUNTERS:				; Conditionally log zero counter event
	BBC	#NET$V_CLRCNT,-		; If BC then counters weren't zeroed
		W^NET$GL_FLAGS,20$	;
	MOVAB	W^NET$AB_EVT_WQE,R5	; Point to the common WQE
	MOVW	CNF$W_ID(R10),-		;
		WQE$W_REQIDT(R5)	; Setup the CNF i.d.
	MOVL	R2,WQE$L_EVL_PKT(R5)	; Setup pointer to counter block
	SUBB3	R2,R3,WQE$B_EVL_DT2(R5)	; Setup size of counter block
	MOVB	R0,WQE$B_EVL_DT1(R5)	; Setup database i.d.
	MOVW	#EVC$C_NMA_ZER,-	; Assume zero counters event
		WQE$W_EVL_CODE(R5)	;
	BBC	#NET$V_TIMER,-		; If BC then zero counters event
		W^NET$GL_FLAGS,10$	;
	MOVW	#EVC$C_NMA_CTR,-	; Else counter timer event
		WQE$W_EVL_CODE(R5)	;
10$:	BSBW	NET$EVT_INTRAW		; Log it
20$:	RSB				; Done


.END
