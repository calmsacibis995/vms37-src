	.TITLE	NSP - DECnet NSP module for NETDRIVER
	.IDENT	'V03-002'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:	EXECUTIVE
;
; ABSTRACT:
;
;	THIS MODULE PROCESSES NETWORK USER I/O REQUESTS.
;
; ENVIRONMENT:
;	MODE = KERNEL
;--


	.SBTTL	HISTORY
;
; AUTHOR:	Al Eldridge,  CREATION DATE: 11-JUN-79
;
; MODIFIED BY:
;
;	V03-02	ADE0023		A.Eldridge		15-Mar-1982
;		Convert from a 1-bit to a 2-bit field width for the NSP
;		version numbers.  The high bit had previously been noise.
;
;	V03-01	ADE0022		A.Eldridge		15-Mar-1982
;		Pass new sub-state value in R1 on call to TR$DLE_SETSTA during
;		IO$_SETMODE processing.
;
;	V02-14	ADE0021		A.Eldridge		02-Mar-1982
;		Get logical link number from proper CXB field in end-action
;		routine after xmitting a Connect Confirm message to a phase
;		II node.
;
;	V02-13	ADE0020		A.Eldridge		17-Feb-1982
;		Set timer after sending DI so that DI will be retransmitted
;		and added DI_CXB so that a prematurely received DI can be
;		saved without needing to be rexmitted.
;
;		Fix flow control by request a segment when the link enters the
;		run state and ignoring any incoming disconnect messages until
;		the received segments are consumed by the QIO user.  Since
;		messages from Phase II nodes cannot be ignored, the initial
;		request count must be set to zero when the link enters the run 
;		state.
;
;		Retransmit an ACK if a sequence numbered message is received
;		after it has already been ACKed since the original ACK could
;		have gotten lost.
;
;	V02-12	ADE0019		A.Eldridge		10-Feb-1982
;		Hand off ownership of logical-link timer to next appropriate
;		segment upon receiving an ACK of the segment currently
;		owning the timer.
;
;	V02-11	ADE0018		A.Eldridge		6-Feb-1982
;		Fix disconnect link bug at DISC_ONE.  The status checking
;		after the call to NET$XWB_LOCLNK was wrong.
;
;	V02-10	ADE0017		A.Eldridge		13-Jan-1982
;		Added support for not taking a receive buffer if the
;		associated datalink's receive queue is non-full
;
;	V02-09	ADE0016		A.Eldridge		28-Dec-1981
;		Rewrote NET$ACP_COMM -- the routine called by NETACP
;		for notification of various events.
;
;	V02-08	ADE0015		A.Eldridge		22-Dec-1981
;		Fixed processing of IO$_ACCESS!IO$M_ABORT.
;
;	V02-07	ADE0014		A.Eldridge		21-Dec-1981
;		Fixed processing of maximum lengthed process descriptors.
;
;	V02-06	ADE0013		A.Eldridge		19-Dec-1981
;		Setup the XWB$x_RID fields.
;
;	V02-05	ADE0012		A.Eldridge		 9-Dec-1981
;		Don't setup XWB$W_PATH on received Connect Initiate message.
;		This cell should only be setup during the processing of the
;		IO$_ACCESS.
;
;	V02-04	ADE0011		A.Eldridge		 9-Dec-1981
;		Setup CXB$L_ENDACTION to receive I/O completion after transmit
;		operation (this was formerly setup by the Transport layer).
;
;	V02-03	ADE0010		A.Eldridge		 9-Dec-1981
;		Fixed a bug in the timeout routine which could allow a link
;		in the RUN state to fail to detect that a retransmission is
;		necessary.
;
;	V02-02	ADE0009		A.Eldridge		 1-Oct-1981
;		General cleanup.
;

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
	$AQBDEF
	$CCBDEF
	$CRBDEF
	$CXBDEF
	$DDBDEF
	$DRDEF
	$FKBDEF
	$IODEF
	$IPLDEF
	$IRPDEF
	$JIBDEF
	$MSGDEF
	$PCBDEF
	$PHDDEF
	$PRDEF
	$TQEDEF
	$UCBDEF
	$VECDEF

	$ICBDEF
	$IDBDEF
	$LTBDEF
	$LSBDEF
	$NDCDEF
	$NETSYMDEF
	$NETUPDDEF
	$RCBDEF
	$XWBDEF

;
; MACROS:
;
;
;  Bit definition macro
;
.MACRO	BITDEF	BLK,SYM,BITVAL

	'BLK'$V_'SYM' = BITVAL
	'BLK'$M_'SYM' = 1@<BITVAL>
.ENDM
;
;  Macro to build a mask of XWB$M_FLG_xxx bits
;
.MACRO	BLDMSK	A
	_$MSK	= _$MSK + XWB$M_FLG_'A'
.ENDM
;
;  Macro to fill the 'set' and 'clear' XWB$W_FLG tables
;
.MACRO	STATEMASK	STA,SETM,CLRM

	;
	;  Build and enter the 'set FLG' bit mask
	;
	_$MSK = 0
	.IRP	A,<SETM>
		BLDMSK	A
	.ENDR
	. = NSP$AW_FLG_SETM + <2*XWB$C_STA_'STA'>
	.WORD	_$MSK
	;
	;  Build and enter the 'clear FLG' bit mask
	;
	_$MSK = 0
	.IRP	A,<CLRM>
		BLDMSK	A
	.ENDR
	. = NSP$AW_FLG_CLRM + <2*XWB$C_STA_'STA'>
	.WORD	_$MSK
.ENDM

;
;  Define events and message symbols
;
.MACRO	NSPEVDEF   EV,INFO,MINSIZ,FIXFLG

    .IF	B,'EV'
	_$PHASE		= _$PHASE + 1
    .IFF
	_$EVCOD		= _$EVCOD+1
	NSP$C_EV_'EV'	= _$EVCOD 

	.IF EQ,_$PHASE
		NSP$C_MSG_'EV' = INFO

		.IF NB,FIXFLG
			NSP$M_MSG_FIX = NSP$M_MSG_FIX!<1@_$EVCOD>
		.ENDC

		.=NSP$AB_MINSIZ + _$EVCOD
		.BYTE	MINSIZ
	.ENDC

	.IF LE,_$PHASE-1

		.=NSP$AB_MAPINF + _$EVCOD
		.BYTE	INFO
	.ENDC
    .ENDC
.ENDM
;
;  Calculate table sizes
;
.MACRO	CALC	EV,INFO,MINSIX,FIXFLG

    .IF	NB,'EV'
			   NSP$C_MAX_EV  = NSP$C_MAX_EV + 1
	.IIF EQ,_$PHASE,   NSP$C_MAX_MSG = NSP$C_MAX_MSG + 1
	.IIF LE,_$PHASE-1, NSP$C_MAX_INF = NSP$C_MAX_INF + 1
    .IFF
	_$PHASE = _$PHASE + 1
    .ENDC
.ENDM

;
;  Macro to build NSP tables
;
.MACRO	NSPTABLES	VECTOR,?SS

	NSP$C_MAX_MSG	= -1		; Number of message types, zero based
	NSP$C_MAX_EV	= -1		; Total number of events, zero based
	NSP$C_MAX_INF	= -1		; Size of NSP$AB_MAPINF
	_$EVCOD		= -1		; dummy variable
	_$PHASE		=  0

	.IRP	A,<VECTOR>		; Determine the table sizes
		CALC A
	.ENDR

	_$PHASE		=  0

NSP$AB_MAPINF:: .BLKB	NSP$C_MAX_INF + 1  ; Maps 'INFO' to event index
NSP$AB_MINSIZ:: .BLKB	NSP$C_MAX_MSG + 1  ; Minimum message size
SS:
	.IRP	A,<VECTOR>	; Fill the tables
		NSPEVDEF  A
	.ENDR
.=SS
.ENDM

;
;  Macro to initialize NSP state tables
;
.MACRO	STTAB,  DFLT_STA,DFLT_ACT	; Init state transition table

	NSP$C_NUMEVT = NSP$C_MAX_EV + 1

	_$ACT_NDX   = 0			; Init action routine index

	.IF NDF,  ACT$_'DFLT_ACT'
		  ACT$_'DFLT_ACT'	= _$ACT_NDX
		  _$ACT_NDX	= _$ACT_NDX + 1
	.ENDC

NSP$AB_STTAB:	.REPT	XWB$C_NUMSTA * NSP$C_NUMEVT
		.BYTE	<XWB$C_STA_'DFLT_STA'@5> + ACT$_'DFLT_ACT'
		.ENDR

NSP$AW_FLG_SETM: .BLKW XWB$C_NUMSTA	; Bits to be set upon entering 
					; state and upon timeout
NSP$AW_FLG_CLRM: .BLKW XWB$C_NUMSTA	; Bits to be cleared upon 
					; entering state
NSP$ENDTABLES = .

.ENDM
;
;  Macro to move the current position just past the table area
;
.MACRO	ENDSTTAB
	.=NSP$ENDTABLES
.ENDM
;
;  Macro to move the current position to the proper event area
;
.MACRO	EVENT, EV				; Move PC to proper event
	.=NSP$AB_STTAB + <EV * XWB$C_NUMSTA>
.ENDM
;
;  Macro to fill the build and enter the state transition table element
;
.MACRO	STATE	CURSTA,NXTSTA,ACTION,?LL 	; Make table entry
LL:
	.=.+XWB$C_STA_'CURSTA'

	.IF NDF,ACT$_'ACTION'
		ACT$_'ACTION'	= _$ACT_NDX
		_$ACT_NDX	= _$ACT_NDX + 1
	.ENDC

	.BYTE	<XWB$C_STA_'NXTSTA' @NSP$C_ACTBITS> + ACT$_'ACTION'

.=LL
.ENDM	STATE

;
; Macro to set up connect reject reason codes
;
.MACRO	REJ_REASON	REASON,CONCODE,DATACODE,MSGCODE

	.BYTE	NET$C_DR_'REASON
	.WORD	SS$_'CONCODE
	.WORD	SS$_'DATACODE
	.WORD	MSG$_'MSGCODE

.ENDM	REJ_REASON


;
; Macro to set up mailbox message filtering table
;
.MACRO	MBX_FILTER	MESSAGE,BIT

	.LONG	MBX$M_'BIT
	.WORD	MSG$_'MESSAGE

.ENDM	MBX_FILTER

;
; EQUATED SYMBOLS:
;

;
; ARGUMENT LIST OFFSETS FOR QIO 
;
P1	= 0				; BUFFER ADDRESS
P2	= 4				; BUFFER LENGTH
P3	= 8				; Miscellaneous

;
;  Renamed fields in some common control blocks
;
CXB$W_SEG	= CXB$L_SSB		; SSB is unused.  SEG holds the
					; segment number of the NSP msg
					; contained in the CXB
;
;  The following fields are renamed for all IRPs but are used meaningful
;  for READs and WRITEs only.
;
IRP$B_NET	= IRP$L_SEGVBN		; Status bits 
IRP$B_REFCNT	= IRP$L_SEGVBN+1	; Reference count 
;
;  The following fields are renamed for WRITE operations
;
IRP$W_X_FNSIZ	= IRP$L_SEGVBN+2	; Size of final segment
IRP$W_X_INX	= IRP$L_DIAGBUF		; Number of initial segment
IRP$W_X_FNX	= IRP$L_DIAGBUF+2	; Number of final segment
IRP$W_X_MNRES	= IRP$L_EXTEND		; Min resident segment value
IRP$W_X_MXRES	= IRP$L_EXTEND+2	; Max resident segment value

;
;  The following fields are renamed for READ data operations
;
IRP$L_R_UVA	= IRP$L_DIAGBUF		; User's buffer virtual address

;
;  The following fields are renamed for connect (ACCESS) operations
;
IRP$L_C_ICB	= IRP$L_DIAGBUF		; Address of ICB (used to hold

;
; Definitions for mailbox message filtering
;
	$VIELD	MBX,0,<-
		<NETSTATE,,M>,-		; Network state change
		<EVTAVL,,M>,-		; Events available for logging
		<EVTRCVCHG,,M>,-	; Event receiver database change
		<EVTXMTCHG,,M>,-	; Event xmitter database change
>

;
; Direct-line access sub-event codes
;
	DLE_EV_ACCESS	= 1
	DLE_EV_WRITE	= 2
	DLE_EV_READ	= 3



;
;  Define UCB$W_DEVSTS flags - since the EXEC looks at some DEVSTS
;  bits, re-use bits defined for the Release 1 NETDRIVER which no
;  longer have meaning for this driver.
;
BITDEF	UCB,DEV_PNDAC,UCB$V_NT_NAME	; Set if access pending on UCB
BITDEF  UCB,DEV_CMPIO,UCB$V_NT_BFROVF	; Say "I/O completion in progress"
BITDEF	UCB,DEV_REQIO,UCB$V_NT_BREAK	; Set if driver must start next
					; IRP if one is on the UCB queue
;
;  Define miscellaneous message flags
;
	BITDEF	IRP,NET_INUSE,0		; Set while IRP still either
					; contains unxmitted data, or
					; has not rcv'd its final segment
	BITDEF	IRP,NET_CHN,1		; Set if IRP either uses chained
					; buffers, or the only segment
					; associated with the IRP has
					; its EOM flag set
	;
	;   The following are subfields of a connect message's INFO and
	;   SERVICE fields.  INFO and SERVICE are treated here as one
	;   contiguous field -- the extensible feature of either must not
	;   have been used.
	;
	BITDEF		NSP,SEGFL,2	; Segment flow control
	BITDEF		NSP,MSGFL,3	; Message flow control
	BITDEF		NSP,V31,8	; NSP version field
	BITDEF		NSP,VXX,9	; NSP version field extension
	;
	;   ACK field qualifiers
	;
	BITDEF		NSP,NAK,12	; This is a NAK
	BITDEF		NSP,ACKVALID,15	; Set to distinguish the ACK
					; field from the SEG field
	;
	;   Interrupt/Link Service (LI) and DATA message header modifiers
	;
	BITDEF		NSP,EOM,6	; End of message  (DATA only)
	BITDEF		NSP,BOM,5	; Begining of msg (DATA only)
	BITDEF		NSP,LICH,4	; Set if LI rather than DATA msg
	BITDEF		NSP,INTMSG,5	; Set in in LI msg if Interrupt
					; than a Link Service message

;
;  Define a mask containing all bits indicating work needs to be done
;
XWB$M_FLG_WMSK =	XWB$M_FLG_SCD ! XWB$M_FLG_SDLE!-
			XWB$M_FLG_SDT ! XWB$M_FLG_SDACK!-
			XWB$M_FLG_SLI ! XWB$M_FLG_SIACK!-
			XWB$M_FLG_CLO ! XWB$M_FLG_BREAK
;
;  Miscellaneous
;
XWB$M_STS_VER = XWB$M_STS_V31 ! XWB$M_STS_VXX	; Version field

NSP$C_VER_V31 = 1 @ XWB$V_STS_V31	; Value for V3.1
NSP$C_VER_V32 = 0			; Value for V3.2
NSP$C_VER_V40 = 2 @ XWB$V_STS_V31	; Value for V4.0

NSP$M_SERVICE = 3			; Size of useable NSP "service field"
NSP$C_SERVICE = 1			; 2 bit NSP "service field" value

;
; DRIVER PROLOGUE TABLE
;
 
		.PSECT	$$$105_PROLOGUE
	DPTAB	-				; Define driver prologue table
		END	= NET$END,-		; End of driver
		ADAPTER	= NULL,-		; Adapter type
		UCBSIZE	= UCB$C_LENGTH,-	; UCB size
		NAME	= NETDRIVER		; Driver name

	DPT_STORE INIT				; CONTROL BLOCK INIT VALUES

	DPT_STORE CRB,CRB$L_INTD+VEC$L_ADP,L,0	; No ADP pointer 
	DPT_STORE UCB,UCB$W_MB_SEED,W,0		; Init. unit value for cloning
	DPT_STORE UCB,UCB$B_FIPL,B,NET$C_IPL	; Fork IPL
	DPT_STORE UCB,UCB$B_DIPL,B,NET$C_IPL	; Device IPL
	DPT_STORE UCB,UCB$L_OWNUIC,L,-
				<^X010001>	; Owner UIC
	DPT_STORE UCB,UCB$L_DEVCHAR,L,-		; Device characteristics
				<DEV$M_NET!-
				 DEV$M_AVL!-
				 DEV$M_MBX!-
				 DEV$M_IDV!-
			 	 DEV$M_ODV- 
				>
	DPT_STORE UCB,UCB$W_DEVBUFSIZ,W,256
	DPT_STORE UCB,UCB$L_DEVDEPEND,L,MBX$M_NETSTATE ; Always enable NETSHUT
	DPT_STORE UCB,UCB$W_STS,W,-
				<UCB$M_ONLINE!-
				 UCB$M_TEMPLATE-
				>
	DPT_STORE REINIT			; CONTROL BLOCK RE-INIT VALUES

	DPT_STORE DDB,DDB$L_DDT,D,NET$DDT 

	DPT_STORE CRB,CRB$L_INTD+VEC$L_INITIAL,	D,NET$CTLR_INIT
	DPT_STORE CRB,CRB$L_INTD+VEC$L_UNITINIT,D,NET$UNIT_INIT
	DPT_STORE CRB,CRB$L_INTD+VEC$L_START,	D,NET$ACP_COMM
	DPT_STORE CRB,CRB$L_INTD+4,		D,NET$INTERRUPT

	DPT_STORE END			;

 
;
; DRIVER DISPATCH TABLE
;
	.PSECT	$$$115_DRIVER,LONG

	DDTAB	DEVNAM =NET,-		; DRIVER DISPATCH TABLE
		START  =NET$STARTIO,-	; START I/O OPERATION
		UNSOLIC=NET$UNSOL_INTR,-; UNSOLICITED INTERRUPT
		FUNCTB =FUNCTABLE,-	; FUNCTION DECISION TABLE ADDRESS
		CANCEL =NET$CANCEL,-	; CANCEL I/O ENTRY POINT
		ALTSTART=NET$ALTENTRY	; ALTERNATE ENTRY POINT


	.SBTTL	FUNCTION DECISION TABLE
 
FUNCTABLE:				; FUNCTION DECISION TABLE
	FUNCTAB	,-			; LEGAL FUNCTIONS
		<READVBLK,-		; READ VIRTUAL BLOCK
		 WRITEVBLK,-		; WRITE VIRTUAL BLOCK
		 SETMODE,-		; Set mailbox message filters
		 ACCESS,-		; LOGICAL LINK CONNECT/REJECT
		 ACPCONTROL,-		; ACP CONTROL FUNCTION
		 DEACCESS,-		; LOGICAL LINK DISCONNECT
	>
	FUNCTAB	,-			; BUFFERED I/O FUNCTIONS
		<ACCESS,-		; LOGICAL LINK CONNECT/REJECT
		 READVBLK,-		; READ VIRTUAL
		 WRITEVBLK,-		; WRITE VIRTUAL
		 READLBLK,-		; Read Logical
		 WRITELBLK,-		; Write Logical
		 SETMODE,-		; Set mailbox message filters
		 ACPCONTROL,-		; ACP CONTROL FUNCTION
		 DEACCESS,-		; LOGICAL LINK DISCONNECT
	>
	FUNCTAB	NET$FDT_READ,<READLBLK>	; READ FUNCTION 
	FUNCTAB	NET$FDT_WRITE,<WRITELBLK> ; WRITE FUNCTION 
	FUNCTAB	NET$FDT_ACCESS,<ACCESS> ; CONNECT LOGICAL LINK
	FUNCTAB	+ACP$DEACCESS,<DEACCESS>; DEACCESS LINK
	FUNCTAB NET$FDT_SETMODE,-	; Set mailbox message filters
			      <SETMODE>	; and direct-accessed line sub-state
	FUNCTAB	NET$FDT_CONTROL,<ACPCONTROL> ; ACP CONTROL FUNCTIONS

;
; OWN STORAGE:
;
; The following table lists the minimum message lengths for each
; message type.  These message lengths do not include any counted
; string fields or, in the case of the CI message, the process name
; fields.  They also do not include optional 'piggy-backed' ACKs.  The
; index into this table is the event code mapped from the message type.
;
; In addition to message lengths, a table is also built to provide
; a cross reference to an event for those events which need them.
;
NSP$M_MSG_FIX = 0			; Initialize fixed message mask

NSPTABLES -				; Received messages - ordered 
     <-					; to make the NET$UNSOL_INTR
	-				; scan as fast as possible
	<CI,	<^X18>, 10,  >,-	; Connect Initiate
	<CA,	<^X24>,  3, F>,-	; Connect Ack
	<CC,	<^X28>,  9,  >,-	; Connect Confirm
	<DI,	<^X38>,  7,  >,-	; Disconnect Initiate
	<DC,	<^X48>,  7, F>,-	; Disconnect Confirm
	<INT,	<^X30>,  7,  >,-	; Interrupt message
	<LS,	<^X10>,  9,  >,-	; Link service message
	<LIACK,	<^X14>,  7, F>,-	; Link service/Interrupt Ack
	<DTACK,	<^X04>,  7, F>,-	; Data Ack
	<DATA,	<^X00>,	 7,  >,-	; Data message
	<,,,>,-				; Marks the end of the "Message" events
	-				; 
	<READ,	IO$_READLBLK,,>,-	; QIO read
	<WRITE,	IO$_WRITELBLK,,>,-	; QIO write
	<CTLQIO,IO$_ACPCONTROL,,>,-	; QIO for control functions
	<ACC,	IO$_ACCESS,,>,-		; Connect Requests
	<DEA,	IO$_DEACCESS,,>,-	; Disconnect Requests
	<DLE,   IO$_REWIND,,>,-		; Remapped I/O func code for direct-
	-				; circuit access
	<,,,>,-				; Marks the end of the user QIO events
	-				; 
	<CIA,,,>,-			; Connect initiate
	<CCA,,,>,-			; Connect confirm
	<CRA,,,>,-			; Connect reject

	<PROERR,,,>,-			; Protocol error
	<CANLNK,,,>,-			; Cancel link
	<DSCLNK,,,>,-			; Disconnect link
	<MBXERR,,,>,-			; Mailbox error
	<PH2CCS,,,>,-			; CC xmt'd to phaseII partner
	<DXCONT,,,>,-			; Continue processing Dx message
     >

;
; Define NSP protocol states
;
	ASSUME  XWB$C_NUMSTA  EQ  8	; This value allows a quadword entry
					; per event in the state tables.  
					; Changing it may be difficult.

	NSP$C_ACTBITS	= 5		; Number of action bits per entry
	NSP$C_STABITS	= 3		; Number of state bits per entry
	NSP$M_STAMSK	= <7>@5		; State bit mask

;
; The following definitions must be contiguous to the NSPTABLES definition
;
STTAB	CLO,BUG				; Init state transition table

EVENT	   NSP$C_EV_CI			; CI message received
    STATE  CIS,	CIS,	BUG		; something wrong in the driver
    STATE  CAR,	CAR,	LOG		; unexpected event
    STATE  CIR,	CIR,	LOG		; unexpected event
    STATE  CCS,	CCS,	LOG		; unexpected event
    STATE  RUN,	RUN,	LOG		; unexpected event
    STATE  DIS,	DIS,	LOG		; unexpected event
    STATE  DIR,	DIR,	LOG		; unexpected event
    STATE  CLO,	CIR,	RCV_CI		; inbound connect sequence

EVENT	   NSP$C_EV_CA			; Connect Ack received
    STATE  CIS,	CAR,	RCV_CA		; measure intial round-trip time
    STATE  CAR,	CAR,	NOP		; assume retransmission
    STATE  CIR,	CIR,	LOG		; unexpected event
    STATE  CCS,	CCS,	LOG		; unexpected event
    STATE  RUN,	RUN,	NOP		; assume late arrival
    STATE  DIS,	DIS,	NOP		; assume late arrival
    STATE  DIR,	DIR,	NOP		; assume late arrival
    STATE  CLO,	CLO,	NOP		; assume late arrival

EVENT	   NSP$C_EV_CC			; Connect Confirm received
    STATE  CIS,	RUN,	RCV_CC		; normal handshaking sequence
    STATE  CAR,	RUN,	RCV_CC		; normal handshaking sequence
    STATE  CIR,	CIR,	LOG		; unexpected event
    STATE  CCS,	CCS,	LOG		; unexpected event
    STATE  RUN,	RUN,	NOP		; assume retransmission
    STATE  DIS,	DIS,	NOP		; we enter DIS for many reasons
    STATE  DIR,	DIS,	NOP		; assume late arrival
    STATE  CLO,	CLO,	RTS_NLT		; assume late arrival

EVENT	   NSP$C_EV_PH2CCS		; Phase II connect confirm xmt-complete
    STATE  CIS,	CIS,	NOP		; 
    STATE  CAR,	CAR,	NOP		; 
    STATE  CIR,	CIR,	NOP		; 
    STATE  CCS,	RUN,	ENT_RUN		; Normal Phase II handshaking sequence
    STATE  RUN,	RUN,	NOP		; 
    STATE  DIS,	DIS,	NOP		; 
    STATE  DIR,	DIR,	NOP		; 
    STATE  CLO,	CLO,	NOP		; 

EVENT	   NSP$C_EV_DATA		; Data message received
    STATE  CIS,	CIS,	LOG		; unexpected event
    STATE  CAR,	CAR,	LOG		; unexpected event
    STATE  CIR,	CIR,	LOG		; unexpected event
    STATE  CCS,	RUN,	ENT_RUN		; a normal handshaking sequence
    STATE  RUN,	RUN,	RCV_DATA	; this is what NSP is for
    STATE  DIS,	DIS,	NOP		; unavoidable race in sending DI
    STATE  DIR,	DIR,	NOP		; assume late arrival
    STATE  CLO,	CLO,	RTS_NLT		; assume late arrival

EVENT	   NSP$C_EV_DTACK		; Data Ack received
    STATE  CIS,	CIS,	LOG		; unexpected event
    STATE  CAR,	CAR,	LOG		; unexpected event
    STATE  CIR,	CIR,	LOG		; unexpected event
    STATE  CCS,	RUN,	ENT_RUN		; a normal handshaking sequence
    STATE  RUN,	RUN,	RCV_DTACK	; drive the link
    STATE  DIS,	DIS,	NOP		; assume late arrival or race
    STATE  DIR,	DIR,	NOP		; assume late arrival or race
    STATE  CLO,	CLO,	RTS_NLT		; assume late arrival or race

EVENT	   NSP$C_EV_LS			; Link Service msg received
    STATE  CIS,	CIS,	LOG		; unexpected event
    STATE  CAR,	CAR,	LOG		; unexpected event
    STATE  CIR,	CIR,	LOG		; unexpected event
    STATE  CCS,	RUN,	ENT_RUN		; a normal handshaking sequence
    STATE  RUN,	RUN,	RCV_LI		; drive the link
    STATE  DIS,	DIS,	NOP		; assume late arrival or race
    STATE  DIR,	DIR,	NOP		; assume late arrival or race
    STATE  CLO,	CLO,	RTS_NLT		; assume late arrival or race

EVENT	   NSP$C_EV_INT			; Interrupt msg received
    STATE  CIS,	CIS,	LOG		; unexpected event
    STATE  CAR,	CAR,	LOG		; unexpected event
    STATE  CIR,	CIR,	LOG		; unexpected event
    STATE  CCS,	RUN,	ENT_RUN		; a normal handshaking sequence
    STATE  RUN,	RUN,	RCV_LI		; drive the link
    STATE  DIS,	DIS,	NOP		; assume late arrival or race
    STATE  DIR,	DIR,	NOP		; assume late arrival or race
    STATE  CLO,	CLO,	RTS_NLT		; assume late arrival or race

EVENT	   NSP$C_EV_LIACK		; INT/LS Ack received
    STATE  CIS,	CIS,	LOG		; unexpected event
    STATE  CAR,	CAR,	LOG		; unexpected event
    STATE  CIR,	CIR,	LOG		; unexpected event
    STATE  CCS,	RUN,	ENT_RUN		; a normal handshaking sequence
    STATE  RUN,	RUN,	RCV_LIACK	; drive the link
    STATE  DIS,	DIS,	NOP		; assume late arrival or race
    STATE  DIR,	DIR,	NOP		; assume late arrival or race
    STATE  CLO,	CLO,	RTS_NLT		; assume late arrival or race

EVENT	   NSP$C_EV_DI			; Disconnect Initiate msg rcv'd
    STATE  CIS,	DIR,	RCV_Dx_Cxx	; link rejected
    STATE  CAR,	DIR,	RCV_Dx_Cxx	; link rejected
    STATE  CIR,	DIR,	ABORT		; abort the link, no local owner
    STATE  CCS,	DIR,	RCV_Dx_Cxx	; abort the link 
    STATE  RUN,	DIR,	RCV_Dx_RUN	; abort the link
    STATE  DIS,	DIR,	ABORT		; change state and send DC
    STATE  DIR,	DIR,	NOP		; send DC
    STATE  CLO,	CLO,	RTS_NLT		; assume race or late arrival

EVENT	   NSP$C_EV_DC			; Disconnect Confirm msg rcv'd
    STATE  CIS,	CLO,	RCV_Dx_Cxx	; link rejected
    STATE  CAR,	CLO,	RCV_Dx_Cxx	; link rejected
    STATE  CIR,	CLO,	ABORT		; link aborted, no local owner
    STATE  CCS,	CLO,	RCV_Dx_Cxx	; link aborted
    STATE  RUN,	CLO,	RCV_Dx_RUN	; link aborted
    STATE  DIS,	CLO,	NOP		; normal handshaking sequence
    STATE  DIR,	CLO,	NOP		; assume DC is a 'no link terminate'
    STATE  CLO,	CLO,	NOP		; assume late arrival

EVENT	   NSP$C_EV_DXCONT		; Continue processing DX message
    STATE  CIS,	DIR,	BUG		; Only expected in RUN state
    STATE  CAR,	DIR,	BUG		; 
    STATE  CIR,	DIR,	BUG		; 
    STATE  CCS,	DIR,	BUG		; 
    STATE  RUN,	DIR,	DX_CONT		; Continue processing DX
    STATE  DIS,	DIR,	BUG		; 
    STATE  DIR,	DIR,	BUG		; 
    STATE  CLO,	DIR,	BUG		; 


;EVENT	   NSP$C_EV_NOCNF		; Link failed confidence test
;   STATE  CIS,	CLO,	TIMOUT_CN	; connect timed out
;   STATE  CAR,	DIR,	TIMOUT_CN	; connect timed out
;   STATE  CIR,	DIR,	ABORT		; local system is slow
;   STATE  CCS,	DIR,	TIMOUT_CN	; connect timed out
;   STATE  RUN,	DIR,	ABORT		; problem talking with remote node
;   STATE  DIS,	CLO,	NOP		; abort the link
;   STATE  DIR,	CLO,	NOP		; abort the link
;   STATE  CLO,	CLO,	NOP		; Try to deallocate XWB
;
;EVENT	   NSP$C_EV_DSCLNK		; Local disconnect of link
;   STATE  CIS,	CLO,	ABORT		; abort from a Connect state
;   STATE  CAR,	CLO,	ABORT		; abort from a Connect state
;   STATE  CIR,	DIS,	ABORT		; abort link, no local owner
;   STATE  CCS,	DIS,	ABORT		; abort from a Connect state
;   STATE  RUN,	DIS,	ABORT		; orderly shuttdown
;   STATE  DIS,	DIS,	NOP		; link is already disconnecting
;   STATE  DIR,	DIR,	NOP		; link is already disconnecting
;   STATE  CLO,	CLO,	NOP		; link is already disconnecting

EVENT	   NSP$C_EV_DSCLNK		; Link failed confidence test
    STATE  CIS,	CLO,	TIMOUT_CN	; connect timed out
    STATE  CAR,	DIR,	TIMOUT_CN	; connect timed out
    STATE  CIR,	DIR,	ABORT		; local system is slow
    STATE  CCS,	DIR,	TIMOUT_CN	; connect timed out
    STATE  RUN,	DIR,	ABORT		; problem talking with remote node
    STATE  DIS,	CLO,	NOP		; abort the link
    STATE  DIR,	CLO,	NOP		; abort the link
    STATE  CLO,	CLO,	NOP		; Try to deallocate XWB
 

EVENT	   NSP$C_EV_CANLNK		; Local cancel of link
    STATE  CIS,	CLO,	CANLNK		; abort from a Connect state
    STATE  CAR,	CLO,	CANLNK		; abort from a Connect state
    STATE  CIR,	DIS,	CANLNK		; abort link, no local owner
    STATE  CCS,	DIS,	CANLNK		; abort from a Connect state
    STATE  RUN,	DIS,	CANLNK		; orderly shuttdown
    STATE  DIS,	DIS,	NOP		; link is already disconnecting
    STATE  DIR,	DIR,	NOP		; link is already disconnecting
    STATE  CLO,	CLO,	NOP		; link is already disconnecting

EVENT	   NSP$C_EV_CTLQIO		; QIO IO$_ACPCONTROL function
    STATE  CIS,	CIS,	CONTROL		; This event is not state
    STATE  CAR,	CAR,	CONTROL		; dependent and will cause no
    STATE  CIR,	CIR,	CONTROL		; state changes
    STATE  CCS,	CCS,	CONTROL		;
    STATE  RUN,	RUN,	CONTROL		;
    STATE  DIS,	DIS,	CONTROL		;
    STATE  DIR,	DIR,	CONTROL		;
    STATE  CLO,	CLO,	CONTROL		;


EVENT	   NSP$C_EV_ACC			; QIO IO$_ACCESS function
    STATE  CIS,	CIS,	BUG		; Since 'events' require XWB
    STATE  CAR,	CAR,	BUG		; context, if there is a window
    STATE  CIR,	CIR,	BUG		; already associated with this
    STATE  CCS,	CCS,	BUG		; channel then the EXEC allowed
    STATE  RUN,	RUN,	BUG		; the access when it shouldn't
    STATE  DIS,	DIS,	BUG		; have.
    STATE  DIR,	DIR,	BUG		;
    STATE  CLO,	CLO,	BUG		;

EVENT	   NSP$C_EV_CIA			; Connect Initiate IO$_ACCESS
    STATE  CIS,	CIS,	BUG		; IO$_ACCESS
    STATE  CAR,	CAR,	BUG		; UCB is interlocked
    STATE  CIR,	CAR,	BUG		;  "   "      "
    STATE  CCS,	CCS,	BUG		;  "   "      "
    STATE  RUN,	RUN,	BUG		; EXEC should have caught this
    STATE  DIS,	DIS,	BUG		; 
    STATE  DIR,	DIR,	BUG		;
    STATE  CLO,	CIS	INITIATE	; Normal connect initiate seq.

EVENT	   NSP$C_EV_CCA			; Connect Confirm IO$_ACCESS
    STATE  CIS,	CIS,	BUG		; UCB should be interlocked
    STATE  CAR,	CAR,	BUG		; UCB should be interlocked
    STATE  CIR,	CCS,	CONFIRM		; Normal connect confirm seq.
    STATE  CCS,	CCS,	BUG		; UCB should be interlocked
    STATE  RUN,	RUN,	SHRLNK		; Second accessor to link
    STATE  DIS,	DIS,	NOLINK		; Confirm no longer possible
    STATE  DIR,	DIR,	NOLINK		; Confirm no longer possible
    STATE  CLO,	CLO,	NOLINK		; Confirm no longer possible

EVENT	   NSP$C_EV_CRA			; Connect Reject IO$_ACCESS
    STATE  CIS,	CIS,	BUG		; UCB should be interlocked
    STATE  CAR,	CAR,	BUG		; UCB should be interlocked
    STATE  CIR,	DIS,	CONFIRM		; Normal connect reject seq.
    STATE  CCS,	CCS,	BUG		; UCB should be interlocked
    STATE  RUN,	RUN,	NOLINK		; User error
    STATE  DIS,	DIS,	NOLINK		; User error
    STATE  DIR,	DIR,	NOLINK		; User error
    STATE  CLO,	CLO,	NOLINK		; User error

EVENT	   NSP$C_EV_DEA			; QIO IO$_DEACCESS
    STATE  CIS,	CIS,	BUG		; UCB should be interlocked
    STATE  CAR,	CAR,	BUG		; UCB should be interlocked
    STATE  CIR,	CIR,	BUG		; Channel should not have window
    STATE  CCS,	CCS,	BUG		; UCB should be interlocked
    STATE  RUN,	DIS,	DEACCESS	; But change to DIS state only 
					;  if this is the last accessor
    STATE  DIS,	DIS,	DEACCESS	; Link was aborted externally
    STATE  DIR,	DIR,	DEACCESS	; Link was aborted externally
    STATE  CLO,	CLO,	DEACCESS	;  or remotely

EVENT	   NSP$C_EV_READ		; QIO IO$_READLBLK
    STATE  CIS,	CIS,	NOLINK		; User error
    STATE  CAR,	CAR,	NOLINK		; User error
    STATE  CIR,	CIR,	NOLINK		; User error
    STATE  CCS,	CCS,	NOLINK		; User error
    STATE  RUN,	RUN,	READ		; Normal read path
    STATE  DIS,	DIS,	SSABORT		; User error
    STATE  DIR,	DIR,	SSABORT		; User error
    STATE  CLO,	CLO,	SSABORT		; User error

EVENT	   NSP$C_EV_WRITE		; QIO IO$_WRITELBLK
    STATE  CIS,	CIS,	NOLINK		; User error
    STATE  CAR,	CAR,	NOLINK		; User error
    STATE  CIR,	CIR,	NOLINK		; User error
    STATE  CCS,	CCS,	NOLINK		; User error
    STATE  RUN,	RUN,	WRITE		; Normal write path
    STATE  DIS,	DIS,	SSABORT		; User error
    STATE  DIR,	DIR,	SSABORT		; User error
    STATE  CLO,	CLO,	SSABORT		; User error

EVENT	    NSP$C_EV_MBXERR		; Fatal error writing to mailbox
    STATE  CIS,	CLO,	ABORT		; abort from a Connect state
    STATE  CAR,	CLO,	ABORT		; abort from a Connect state
    STATE  CIR,	DIS,	ABORT		; abort link, no local owner
    STATE  CCS,	DIS,	ABORT		; abort from a Connect state
    STATE  RUN,	DIS,	ABORT		; abort from the RUN state
    STATE  DIS,	DIS,	NOP		; link is already disconnecting
    STATE  DIR,	DIR,	NOP		; link is already disconnecting
    STATE  CLO,	CLO,	NOP		; link is already disconnecting

EVENT	   NSP$C_EV_PROERR		; Protocol error     ;& later log/ignore
    STATE  CIS,	CLO,	ABORT		; abort from a Connect state
    STATE  CAR,	CLO,	ABORT		; abort from a Connect state
    STATE  CIR,	DIS,	ABORT		; abort link, no local owner
    STATE  CCS,	DIS,	ABORT		; abort from a Connect state
;&  STATE  RUN,	DIS,	ABORT		; orderly shuttdown
    STATE  RUN, RUN,	NOP		;&nop for now
    STATE  DIS,	DIS,	NOP		; link is already disconnecting
    STATE  DIR,	DIR,	NOP		; link is already disconnecting
    STATE  CLO,	CLO,	NOP		; link is already disconnecting

EVENT	   NSP$C_EV_DLE			; Direct-line access QIO processing 
    STATE  CIS,	CIS,	BUG		; 
    STATE  CAR,	CAR,	BUG		; 
    STATE  CIR,	CIR,	BUG		; 
    STATE  CCS,	CCS,	BUG		; 
    STATE  RUN,	RUN,	DLE		; 
    STATE  DIS,	DIS,	BUG		; 
    STATE  DIR,	DIR,	BUG		;
    STATE  CLO,	CLO,	DLE		;



;
;  Setup tables which specify which XWB$W_FLG bits to set and clear upon
;  a transition into a new state.
;
STATEMASK CIS,	<SCD>	<SDT,SLI,SDACK,SIACK,WBP,WHGL>
STATEMASK CAR,	<CLO>	<>
STATEMASK CIR,	<SCD>	<SDT,SLI,SDACK,SIACK,WBP,WHGL>
STATEMASK CCS,	<SCD>	<SDT,SLI,SDACK,SIACK,WBP,WHGL>
STATEMASK RUN,	<SDACK>	<SCD>
STATEMASK DIR,	<SCD>	<SDT,SLI,SDACK,SIACK,WBP,WHGL>
STATEMASK DIS,	<SCD>	<SDT,SLI,SDACK,SIACK,WBP,WHGL>
STATEMASK CLO,	<CLO>	<SCD,SDT,SLI,SDACK,SIACK,WBP,WHGL>

ENDSTTAB


;
; The following mask has a bit set for each message with a fixed
; message size.  The bit positions correspond to the 'events' which
; are mapped via the NSP message type code.
;
NSP$L_MSG_FIX:	.LONG NSP$M_MSG_FIX


;
; The following mask is used to identify the subset of flags used
; to signal work to be done
;
NET$L_WORKBITS:	.LONG	XWB$M_FLG_WMSK

NET$C_DR_TIMOUT = 100			; Fake value for code conversion

DR_TABLE:				; Table for mapping reject reasons
;
;			discon	connect		data		mailbox
;			reason	status		status		message
;			------	-----------	---------	--------
	REJ_REASON	EXIT,	LINKEXIT,	LINKEXIT,	EXIT
	REJ_REASON	NOPATH,	UNREACHABLE,	PATHLOST,	PATHLOST
	REJ_REASON	SHUT,	SHUT,		SHUT,		NETSHUT
	REJ_REASON	NOBJ,	NOSUCHOBJ,	NOSUCHOBJ,	REJECT
	REJ_REASON	ABORT,	LINKABORT,	LINKABORT,	ABORT
	REJ_REASON	THIRD,	THIRDPARTY,	THIRDPARTY,	THIRDPARTY
	REJ_REASON	ACCESS,	INVLOGIN,	INVLOGIN,	REJECT
	REJ_REASON	RSU,	REMRSRC,	REMRSRC,	REJECT
	REJ_REASON	BUSY,	REMRSRC,	REMRSRC,	REJECT
	REJ_REASON	FMT,	PROTOCOL,	PROTOCOL,	REJECT
	REJ_REASON	NONODE,	NOSUCHNODE,	NOSUCHNODE,	REJECT
	REJ_REASON	TIMOUT,	CONNECFAIL,	PATHLOST,	TIMEOUT
	REJ_REASON	IVNODE,	NOSUCHNODE,	NOSUCHNODE,	REJECT

	.BYTE	0			    ; End of list - no DR_NORMAL

MBX_TABLE:				    ; Table for mapping mbx msg codes 
					    ; to filter bits
	MBX_FILTER	NETSHUT,NETSTATE    ; Network state change
	MBX_FILTER	EVTAVL,EVTAVL	    ; Events available for logging
	MBX_FILTER	EVTRCVCHG,EVTRCVCHG ; Event receiver database change
	MBX_FILTER	EVTXMTCHG,EVTXMTCHG ; Event xmitter database change
	.LONG	0	  		    ; End of table

NET$INTERRUPT:
NET$CTLR_INIT:
	RSB
NET$UNIT_INIT:
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	RSB

;+
; NET$END_EVENT	- Abort current event without changing state
; NET$CMPLX_EV	- Change state and process new event
; NET$PRE_EMPT	- Process new event without changing state
;
; FUNCTIONAL DESCRIPTION
;
; These routines are called by the dispatched event action routines in
; order to complete current event processing in a non-standard way.
; They should be considered substitutes to the RSB instruction which 
; is normally used to return control -- consequently the stack is
; checked for the return address of the event dispatcher.
;
; CALLING SEQUENCE
;
;	JMP	NET$xxx
;
; INPUTS:
;	  R9  =	The value originally stored by the event dispatcher
;	  R8  = Preserved for call to action routine
;	  R7  = Code of new event to be processed (scratch if 
;		NET$END_EVENT)
;	  R6  = The value originally stored by the event dispatcher
;	  R5  =	XWB address
;	  R4  = Scratch
;	  R3  = Scratch
;	  R2  = Scratch
;	  R1  = Scratch
;	  R0  = If NET$END_EVENT the status to be returned to the
;		   caller of the event dispatcher,
;		Else scratch
;
; OUTPUTS:
;
;	  N/A
;-
NET$END_EVENT:	BSBB	CHKRETADDR	; Return without changing state
		BSBW	SCH_XLI		; Xmit messages, etc.
		RSB
NET$CMPLX_EV:				; Change state, process new event
		EXTZV	#NSP$C_ACTBITS,-
			#NSP$C_STABITS,R9,R4	; Get next state
		CMPB	R4,XWB$B_STA(R5)	; New state ?
		BEQL	10$			; If not, branch
		BICW	NSP$AW_FLG_CLRM[R4],-	; Clear appropriate bits
			XWB$W_FLG(R5)		;
		BISW	NSP$AW_FLG_SETM[R4],-	; Set appropriate bits
			XWB$W_FLG(R5)		;
		MOVB	R4,XWB$B_STA(R5)	; Change state
10$:
NET$PRE_EMPT:				; Pre-empt the current event
		BSBB	CHKRETADDR	; Validate state of stack
		BRB	NET$EVENT	; Process new event
CHKRETADDR:				; Checks return address to trap
					; bugs
		PUSHAB	B^CHANGE_STA	; Prepare for next instruction
		CMPL	(SP)+,4(SP)	; Is state of stack correct?
		BNEQ	5$		; If NEQ then no
		MOVL	(SP)+,(SP)	; Overlay return address
		RSB			; Return

	5$:	BUG_CHECK NETNOSTATE,FATAL

;+
; NET$EVENT	- Common event dispatcher
;
; FUNCTIONAL DESCRIPTION
;
; This is the common state table event dispatcher used to determine 
; what is to be done and what state the XWB is to enter next.  An
; event only has meaning within the context of a XWB.
;
; INPUTS:
;	  R9 =	Available for the event dispatcher's exclusive use
;	  R8 =	Preserved for call to action routine
;	  R7 =	Code of the event to be processed
;	  R6 =  If received message event then Tranport's IRP address
;		If "startio" event then UCB address
;	  R5 =	Address of XWB
;	  R4 =	Scratch
;	  R3 =	If received message event then scratch
;		If "startio" event then QIO IRP address
;	  R2 =  If received message event then message bytes not yet
;		accounted for
;		If "startio" event then scratch
;	  R1 =	If received message event then pointer to first
;		unprocessed byte in message
;		If "startio" event then scratch
;	  R0 =	Scratch
;
; OUTPUTS:
;	  R0 =	Status code from the action routine to be returned to
;		the caller of the event dispatcher
;
;	  Only R6 and R5 are preserved.
;-
NET$FORK:				; Fork the XWB
	BBSS	#XWB$V_STS_SOL,-	; Br if already on fork queue
		    XWB$W_STS(R5),20$ 	; or already soliciting
	PUSHR  #^M<R1,R2,R3,R4,R5>	; Save regs
	BSBB	30$			; Schedule fork and return
10$:	POPR   #^M<R1,R2,R3,R4,R5>	;
20$:	MOVL   #1,R0			; Always return success
	RSB

30$:	MOVAB	XWB$Q_FORK(R5),R5	; Switch to fork block context
	JSB	G^EXE$FORK		; Fork
	MOVAB	-XWB$Q_FORK(R5),R5	; Restore XWB context
	BICW	#XWB$M_STS_SOL,-	; No longer forking/soliciting
		     XWB$W_STS(R5)	;
	BSBW	SCH_XLI			; Continue
	RSB

	ASSUME	XWB$C_NUMSTA EQ 8	; Assume quadword per event
NET$EVENT:				; Process new event
	MOVZBL	XWB$B_STA(R5),R9	; Get current state
	MOVAQ	NSP$AB_STTAB[R7],R4	; Get event block address
	MOVB	(R4)[R9],R9		; Get table entry
	BICB3	#NSP$M_STAMSK,R9,R4	; Get action routine index
	;
	; Dispatch according to the event code.  The action routines 
	; can assume the following :
	;
	;  Input:
	;	R8	Parameter from caller to action routine
	;	R7	Event code
	;	R6	Varies with event
	;	R5	XWB address
	;	R4	Scratch
	;	R3	Varies with event
	;	R2	Varies with event
	;	R1	Varies with event
	;	R0	Scratch
	;      (SP)	Return address
	;
	;
	; Returned values
	;
	;	R8	Garbage
	;	R7	Garbage 
	;	R6	Preserved
	;	R5	Preserved
	;	R4	Garbage
	;	R3	Garbage
	;	R2	Garbage
	;	R1	Garbage
	;	R0	Status to be returned to caller of dispatcher
	;
	;
	;
	ASSUME	XWB$V_FLG_LOCK EQ 0
	BLBC	XWB$W_FLG(R5),10$	; Br unless XWB is locked in RUN
					; format
	BSBW	NET$PURG_RUN		; Attempt to free XWB
10$:	BSBW	DISPATCH

CHANGE_STA:				; Change logical link state
	EXTZV	#NSP$C_ACTBITS,-	;
		#NSP$C_STABITS,R9,R4	; Get next state
	CMPB	R4,XWB$B_STA(R5)	; New state ?
	BEQL	SCH_XLI			; If not, branch
	BICW	NSP$AW_FLG_CLRM[R4],-	; Clear appropriate bits
		XWB$W_FLG(R5)		;
	BISW	NSP$AW_FLG_SETM[R4],-	; Set appropriate bits
		XWB$W_FLG(R5)		;
	MOVB	R4,XWB$B_STA(R5)	; Change state

SCH_XLI:				; Allocate INT/LS xmit slot
	;
	;
	; If XWB$W_STS indicates that any INT/LS messages need scheduling, and
	; a slot in XWB$T_LI_XVEC is available, the next available slot in the 
	; vector is filled and marked as in use.  The corresponding 
	; LSB$W_LI_HXS(R5) value is updated and the new message is scheduled for
	; transmission by setting XWB$V_FLG_SLI in XWB$W_FLG.  The bit in
	; XWB$W_STS which triggered this is cleared.  This process is repeated
	; until no more messages need scheduling or no more slots are available.
	;
	; The slot vector represents a circular queue.  A full queue condition
	; is signalled by attempting to advance HXS and dectecting that it 
	; would be associated with an already occupied slot.
	;
	;
	;   XWB$V_STS_SDFL - set whenever a new receive IRP makes it to the 
	;		     head of the XWB queue.  Cleared by this routine
	;		     when its flow control is scheduled.
	;   XWB$V_STS_SIFL - Set whenever the XWB resident data buffer is
	;		     freed (i.e., when an INT message is sent to the
	;		     user mailbox).  Cleared by this routine when its
	;		     flow control is scheduled.
	;   XWB$V_STS_IAVL - Set whenever a new xmit interrupt IRP makes it to
	;		     the head of the XWB queue.  Cleared by this 
	;		     routine when it is scheduled for xmission.
	;
	;
	BITW   #XWB$M_STS_SDFL!-	; Need to build DATA flow control
		XWB$M_STS_SIFL!-	; Need to build INT flow control
		XWB$M_STS_IAVL,-	; Need to build INT message
		XWB$W_STS(R5)		; Any messages to schedule ?
	BEQL	50$			; If not, we're done
					; Else get next available slot

	MOVW	XWB$T_LI+LSB$W_HXS(R5),R3	; Get num of highest seq xmt'd
	CMPW	R3,XWB$T_LI+LSB$W_HAR(R5)	; ACK'd yet?
	BNEQ	50$				; If NEQ no
	INCW	R3				; Get next seq number
	EXTV	#0,#12,R3,R0			; Sign extend low 12 bits
;&	BICL	#^C<7>,R3			; Get associated index
	BICL	#^C<1>,R3			; Get associated index
	BBSS	R3,XWB$B_LI_XMSK(R5),50$	; Br if already occupied
	MOVW	R0,XWB$T_LI+LSB$W_HXS(R5)	; Set 'high xmit sendable'
	BISW   #XWB$M_FLG_SLI,XWB$W_FLG(R5)	; set 'send INT/LS msg'
	MOVAW	XWB$T_LI_XVEC(R5)[R3],R3	; Get slot address
	;
	;
	;  The following skip chain is organized according to the most urgent,
	;  not the most expected event.  This scheme allows interrupt message 
	;  activity to permanently block sending data flow control messages.
	;  This is the desired behavior.  The code is optimized according to 
	;  the expected event that only a data flow control message needs 
	;  scheduling.
	;
	BITW   #XWB$M_STS_SIFL!XWB$M_STS_IAVL,XWB$W_STS(R5)

	BEQL	40$			; Br if only data flow control
	BBCC   #XWB$V_STS_SIFL,-	; Flow controlling INT messages
		XWB$W_STS(R5),30$	; has top priority
	MOVW   #^X<0104>,(R3)		; Setup FLOW field
	BRB	SCH_XLI			; Loop
30$:	MNEGW  #1,(R3)			; Setup INT message flag
	BICW   #XWB$M_STS_IAVL,-	; Clear need to schedule INT msg
		XWB$W_STS(R5)
	BRB	SCH_XLI			; Loop 

	;
	;  Flow control some more DATA segments
	;
40$:	CLRB	(R3)+			; Indicate 1) no change in back-
					; pressure; 2) DATA subchannel
	MOVB	XWB$B_DT_RFLW(R5),(R3)+	; Enter new segs requested
	ADDB	XWB$B_DT_RFLW(R5),-	; Update total outstanding
		XWB$T_DT+LSB$B_RREQ(R5)
	CLRB	XWB$B_DT_RFLW(R5)	; These segs are now requested
	BICW   #XWB$M_STS_SDFL,-
		XWB$W_STS(R5)		; Clear need to schedule
50$:
	;
	;  Unless there are any wait conditions pending, solicit permission
	;  from Transport to transmit a message.
	;
	FFS    #0,#XWB$V_FLG_CLO+1,-	; Get work bit
		   XWB$W_FLG(R5),R0	;
	BBC	R0,NET$L_WORKBITS,60$	; Br if no work to be done
	BBSS   #XWB$V_STS_SOL,-		; Br if already on fork queue
		    XWB$W_STS(R5),60$ 	; or already soliciting
	PUSHL	R5			; Save XWB address
	BSBB	SOLICIT			; Solicit permission from Transport
					; to xmit
	POPL	R5			; Restore XWB address
60$:	RSB

SOLICIT:				; Solicit xmit permission from Trasnport
	;
	;  Solicit permission from Transport to transmit a message.  On 
	;  return Transport will have supplied an IRP and a buffer. Note
	;  that the request could suspend us indefinitely.  The call is 
	;  made with:
	;
	;	R5 = fork block address
	;	R4 = remote node address in low word,
	;	     local  node address in high word
	;	R3 = path to be used to xmit the message or zero
	;	R2 = RCB address
	;
	;
20$:	MOVZWL	XWB$W_PATH(R5),R3	; Indicate line to be used
	MOVL	XWB$L_VCB(R5),R2	; Get RCB address
	MOVW	XWB$W_REMNOD(R5),-	; Setup remote node address
		    XWB$L_FR4(R5)	;
	MOVW	RCB$W_ADDR(R2),-	; Setup local node address
		    XWB$L_FR4+2(R5)	;
	MOVL	XWB$L_FR4(R5),R4	; Setup R4
	MOVAB	XWB$Q_FORK(R5),R5	; Switch to fork block context
	BSBW	TR$SOLICIT		; Call Transport to solicit

QUICK_SOL:
	;
	; Return from Transport with
	;
	;	R5 = fork block address
	;	R4 = scratch
	;	R3 = scratch
	;	R2 = scratch
	;	R1 = IRP address only if R0 has lbs 
	;	R0 = low bit set if permission granted
	;	   = low bit clear otherwise
	;
	;	IRP$L_SVAPTE	= address of NSP buffer area
	;	IRP$L_IOSB	= address of CXB containing message
	;
	;	CXB$L_ENDACTION	= to be filled with I/O completion routine ptr
	;	CXB$L_IRP	= to be filled with end-action routine date
	;
	;
	MOVAB  -XWB$Q_FORK(R5),R5	; Switch to XWB context
	BICW	#XWB$M_STS_SOL,-	; Mark fork block idle
		    XWB$W_STS(R5)	;
	BLBS	R0,GRANTED		; Br if permission granted
					;
	;
	;   Permission to Xmit has been denied
	;
	PUSHR	#^M<R1,R6,R7,R8,R9,R10>	; Save regs
	MOVZWL	XWB$W_REMNOD(R5),R10	; Get remote node address
	BSBW	GET_NDC_BLK		; Address its counter block
	FFS	#0,#16,XWB$W_FLG(R5),R0	; Find something to do
	BSBB	100$			; ...and go do it
	POPR	#^M<R1,R6,R7,R8,R9,R10>	; Restore regs
	RSB				; Done
					;
100$:	$DISPATCH	R0,-		; Case on work bit
	<-
	   <XWB$V_FLG_CLO,  NET$RET_SLOT>,-
	   <XWB$V_FLG_SDLE, DLE$XMT_DENIED>,-
	>
	ASSUME	XWB$V_STS_TID EQ 0	; For all other bits, come here
					;
	BSBW	DEC_PROGRESS		; Decrement the progress count
	BLBS	XWB$W_STS(R5),140$	; Br if timer is owned
	MOVW	#5,XWB$W_TIMER(R5)	; Try again in 5 seconds
140$:	BBC	#XWB$V_FLG_BREAK,-	; If BS then link is to be broken
		    XWB$W_FLG(R5),150$	;
	BSBW	BREAK			; Generate event to break link
150$:	RSB				;

;
; We have been given permission to transmit. 
;
GRANTED:
	PUSHR	#^M<R1,R6,R7,R8,R9,R10>	; Save regs
	MOVZWL	XWB$W_REMNOD(R5),R10	; Get remote node address
	BSBW	GET_NDC_BLK		; Address its counter block
	MOVL	R1,R6			; Copy command IRP to safe reg
	MOVL	IRP$L_SVAPTE(R6),R3	; Get address of next byte in message
	MOVL	IRP$L_IOSB(R6),R4	; Get address of CXB containing the
					; message
	;
	; Dispatch with:
	;
	;	R10	NDC counter block
	;	R8,R7	Scratch
	;	R6	Address of Transport IRP
	;	R5	XWB address
	;	R4	Address of CXB containing the message
	;	R3	Address of next byte in message
	;	R2-R0	Scratch
	;
	; On return:
	;
	;	R3   Address of first byte beyond the constructed message
	;	R1   User bytes entered into message
	;	R0   1 if message is to be xmitted,
	;	     0 otherwise
	;
	;	R9-R7,R4,R2 are clobbered, all others are unmodified.
	;
	;
	FFS	#0,#16,XWB$W_FLG(R5),R0	; Find something to do
	MOVZWL	XWB$W_LOCLNK(R5),-	; Setup end-action routine data
		CXB$L_IRP(R4)		;
	MOVAB	W^NET$STATUS,-		; Enter I/O completion routine address
		CXB$L_ENDACTION(R4)	;
	PUSHAL	W^110$			; Setup return address
	$DISPATCH  R0,-			; Case on work bit
	<-
	    <XWB$V_FLG_CLO,	NET$RET_SLOT>,-
	    <XWB$V_FLG_SDLE,	DLE$XMT_MSG>,-
	    <XWB$V_FLG_SIACK,	NET$BLD_LIACK>,-
	    <XWB$V_FLG_SDACK,	NET$BLD_DTACK>,-
	    <XWB$V_FLG_SLI,	NET$BLD_LI>,-
	    <XWB$V_FLG_SDT,	NET$BLD_DAT>,-
	    <XWB$V_FLG_SCD,	BLD_CD>,-
	    <XWB$V_FLG_BREAK,	BREAK>,-
	>
	BRW	NONE			; Continue
110$:	BLBC	R0,120$			; If LBC then no msg was built
	BUMP	L,NDC$L_PSN(R10)	; Update "packets sent"
	UPDATE	L,R1,NDC$L_BSN(R10)	; Update "user bytes sent"
120$:	POPR	#^M<R1,R6,R7,R8,R9,R10>	; Restore status and saved regs
	;
	; Return to Transport with:
	;
	;	R5 = value to be returned to NET$STATUS for context
	;	R4 = garbage
	;	R3 = address of 1 byte past NSP message if R0 has lbs
	;	R2 = address of "quick solicit" routine 
	;	     0 if "quick solicit" not requested
	;	R1 = IRP address
	;	R0 = 1 if message is to be xmitted
	;	   = 0 if message no longer needs xmitting
	;
	;	IRP$L_SVAPTE	unmodified
	;	CXB$L_IRP	End-action routine data
	;	CXB$L_ENDACTION of I/O buffer contains address of routine to
	;			which I/O completion status will be delivered
	;
	BLBC	R0,320$			; Br if we had nothing to xmit
	FFS	#0,#XWB$V_FLG_CLO,-	; Anything else to xmit?
		    XWB$W_FLG(R5),R2	;
	BBC	R2,NET$L_WORKBITS,300$	; If BC then no xmit needed
	BBSS	#XWB$V_STS_SOL,-	; If BS then fork block already inuse
		    XWB$W_STS(R5),300$	;
	MOVAB	W^QUICK_SOL,XWB$L_FPC(R5) ; Setup "quick solicit" return
	MOVAB	XWB$Q_FORK(R5),R2	; Say "quick solicit requested"
	BRB	310$			;
300$:	CLRL	R2			; Say "quick solicit not wanted"
310$:	MOVZWL	XWB$W_LOCLNK(R5),R5	; Enter local link address for
		    			; identification on I/O completion
	RSB				; Return to Transport

320$:	CLRL	R2			; No "quick solicit wanted"
	CLRL	R5			; No I/O completion context
	RSB				; Return to Transport

BLD_CD:					; Build Connect or Disconnect message
	BICW	#XWB$M_FLG_SCD,-	; Clear the bit which brought us here
		 XWB$W_FLG(R5)		;
	$DISPATCH XWB$B_STA(R5),TYPE=B,-; Dispatch according to state
	<-
	    <XWB$C_STA_CIS,	  NET$BLD_CI>,-
	    <XWB$C_STA_CIR,	  NET$BLD_CA>,-
	    <XWB$C_STA_CCS,	      BLD_CC>,-
	    <XWB$C_STA_DIS,	  NET$BLD_DI>,-
	    <XWB$C_STA_DIR,	  NET$BLD_DC>,-
	>
	CLRL	R0			; Indicate nothing to send
	RSB


BLD_CC:					; Build a Connect Confirm message
	BICW3	#^C<XWB$M_STS_VER>,-	; Get the NSP version
		XWB$W_STS(R5),R0	;
	CMPW	R0,#NSP$C_VER_V31	; Is it V3.1?
	BNEQ	10$			; If NEQ no, not Phase II
	MOVAB	W^NET$PH2_CCS,-		; Enter I/O completion routine address
		CXB$L_ENDACTION(R4)	;
10$:	BRW	NET$BLD_CC		; Build the Connect Confirm message



BREAK:	BICW	#XWB$M_FLG_BREAK,XWB$W_FLG(R5)	; Prevent infinite looping
	PUSHR	#^M<R1,R5,R6,R7,R8,R9,R10>	; Save regs
	MOVZBL	#NSP$C_EV_DSCLNK,R7		; Setup event code
	BSBW	NET$EVENT			; Process event
	POPR	#^M<R1,R5,R6,R7,R8,R9,R10>	; Restore regs
NONE:	CLRQ	R0				; Say "nothing to send" and
						;     "no user bytes in msg"
	RSB				   	; Done


DISPATCH:					; Dispatch action routine
	$DISPATCH R4,TYPE=B,-

	<- 
	<ACT$_BUG	 NET$BUG>	-; State transition bug
	<ACT$_LOG	 NET$LOG>	-; Log event
	<ACT$_NOP 	 NET$NOP>	-; No special processing
	<ACT$_SSABORT	 NET$SSABORT>	-; Link going down
	<ACT$_NOLINK	 NET$NOLINK>	-; Link not ready

	<ACT$_SHRLNK	 NET$NOLINK>	-; Sharing is NOT YET IMPLEMENTED
	<ACT$_CONTROL	 NET$CONTROL>	-; IO$_ACPCONTROL
	<ACT$_DEACCESS	 NET$DEACCESS>	-; IO$_DEACCESS
	<ACT$_INITIATE	 NET$INITIATE>	-; Connect Init. access
	<ACT$_CONFIRM	 NET$CONFIRM>	-; Connect Confirm/Reject

	<ACT$_TIMOUT_CN	 NET$TIMOUT_CN> -; Timeout connect
	<ACT$_ENT_RUN	 NET$ENT_RUN>	-; Enter RUN state
	<ACT$_DLE,	 DLE$STARTIO>	-; I/O for line service
	<ACT$_READ	 NET$READ>	-; IO$_READLBLK
	<ACT$_WRITE	 NET$WRITE>	-; IO$_WRITELBLK

	<ACT$_RCV_CI	 NET$RCV_CI>	-; Process CI msg
	<ACT$_RCV_CA	 NET$RCV_CA>	-; Process Connect Ack msg
	<ACT$_RCV_CC	 NET$RCV_CC>	-; Process CC msg
	<ACT$_RCV_Dx_Cxx NET$RCV_Dx_Cxx>-; Process a Disc. msg in a Connect state
	<ACT$_RCV_Dx_RUN NET$RCV_DX_RUN>-; Process a Disc. msg in the RUN state

	<ACT$_RCV_DATA	 NET$RCV_DATA>	-; Process DATA msg
	<ACT$_RCV_DTACK	 NET$RCV_DTACK>	-; Process DATA ACK msg
	<ACT$_RCV_LIACK  NET$RCV_LIACK> -; Process LI ACK msg
	<ACT$_RCV_LI	 NET$RCV_LI>	-; Process Link Serv msg
	<ACT$_RTS_NLT	 NET$RTS_NLT>	-; Return 'no link terminate'

	<ACT$_DX_CONT	 CONT_PROC_DX>	-; Continue processing DX message
	<ACT$_CANLNK	 NET$CANLNK>	-; User cancelled link
	<ACT$_ABORT	 NET$ABORT>	-; Abort link
	>
	BUG_CHECK NETNOSTATE,FATAL	; Invalid action routine

NET$NOP:	RSB
NET$BUG:	BUG_CHECK NETNOSTATE,FATAL
NET$LOG:	NOP
		NOP

		NOP
		NOP
		NOP
		NOP	
		RSB

NET$NOLINK:	MOVZWL	#SS$_FILNOTACC,IRP$L_IOST1(R3)
		RSB

NET$SSABORT:	MOVZWL	XWB$W_DIS_STAT(R5),IRP$L_IOST1(R3)
		RSB

;+
; NET$STARTIO - START I/O OPERATION
;
; This routine is entered when the associated unit is idle and a packet
; is available for processing.  The function code is converted into
; an event and, where pertinent, the event dispatcher is called.  The
; IRP$L_WIND field is used to locate the associated XWB.
;
; INPUTS:
;
;	R3 = address of IRP
;	R4 = address of PCB
;	R5 = address of UCB
;
; OUTPUTS:
;
; *** TBS ***
;
; SIDE EFFECTS:
;
; For reads and writes, the IRP may be requeued to the XWB.  If this
; occurs the UCB$V_BSY bit is no longer valid since the UCB is not
; busy - the XWB is.  Therefore, it is necessary to
; try and activate the next IRP in the UCB queue; if the queue is empty
; the UCB$V_BSY bit is cleared.
;
;-
NET$STARTIO:				; Process next IRP
	BICW   #UCB$M_DEV_PNDAC!-	; Clear 'access pending'
		UCB$M_DEV_REQIO,-	; and 'request new io' bits
		UCB$W_DEVSTS(R5)
	PUSHR	#^M<R3,R5,R6,R7,R8,R9>	; Setup "event" context
	MOVL	R5,R6				; Copy UCB to safe register
	MOVZWL	S^#SS$_NORMAL,IRP$L_IOST1(R3)	; Assume success
	ASSUME	<IRP$B_REFCNT-IRP$B_NET> EQ 1 
	MOVW	#IRP$M_NET_INUSE,IRP$B_NET(R3)	; Setup for Xmt/Rcv IRP
	BICL3	#^C<IO$M_FCODE>,-		; Get function code without
		IRP$W_FUNC(R3),R0		; modifier bits
	MOVAB	NSP$AB_MAPINF,R2		; Get event mapping table
	LOCC	R0,-				; Character to find
		#NSP$C_MAX_INF-NSP$C_MAX_MSG,-	; Size of QIO region
		NSP$C_MAX_MSG+1(R2)		; Address of QIO region
	BNEQ	5$				; Found if NEQ
	MOVZWL	#SS$_ILLIOFUNC,IRP$L_IOST1(R3)	; Set error code
	BRB	40$				; Continue
5$:	SUBL3	R2,R1,R7			; Calculate store event code
	MOVL	IRP$L_WIND(R3),R5		; Get XWB, if any
	BLBS	R5,7$				; Br if window is interlocked
	BLSS	30$				; Br if XWB is valid
	INCB	R5				; Invalidate window pointer
7$:	PUSHAB	B^20$				; Push return address
	$DISPATCH  R7,TYPE=B,-			; Process I/O w/o XWB context
	    <-
	    <NSP$C_EV_CTLQIO, NET$CONTROL>,	-; No XWB needed
	    <NSP$C_EV_ACC,    NET$ACCESS>,	-; XWB cond. required
	    <NSP$C_EV_DEA,    NET$BUG>		-; Executive error
	>					 ;
	TSTL	(SP)+				 ; Cleanup stack
	MOVZWL	#SS$_FILNOTACC,IRP$L_IOST1(R3)	 ; Set error status
	BRB	40$				 ; Take common exit

20$:	BLBS	R5,40$			; If LBS window is invalid
	MOVL	(SP),R3			; Recover IRP address
30$:	BSBW	NET$EVENT		; Process the event
40$:	POPR	#^M<R3,R5,R6,R7,R8,R9>	; Return to UCB 'fork' context
	BBSC	#UCB$V_DEV_REQIO,-	; Br to start next i/o if the 
		UCB$W_DEVSTS(R5),REQIO	; current packet has been 
					; requeued internally
	BITW	#UCB$M_DEV_PNDAC!-	; Set if access function is pending
		 UCB$M_DEV_CMPIO,-	; Set if "I/O completion in progress"
		 UCB$W_DEVSTS(R5)	; 
	BNEQ	50$			; Br if either bit is set
	MOVL	IRP$L_IOST1(R3),R0	; First  IOSB longword
	MOVL	UCB$L_DEVDEPEND(R5),R1	; Second IOSB longword
	REQCOM				; Complete I/O
50$:	RSB				; Return to Exec

;
; Start next I/O packet if possible.  This routine in needed for the
; correct handling of the UCB$V_BSY bit when operating the driver in
; a simultaneous I/O mode.  It can be replaced by inserting a new
; entry point in the appropriate spot in IOC$REQCOM.
;
REQIO:	REMQUE	@UCB$L_IOQFL(R5),R3	; Get next IRP
	BVS	10$			; If VS then none
	JMP	G^IOC$INITIATE		; Go through the Exec to give
					; the packet to the driver
10$:	BICW	#UCB$M_BSY,UCB$W_STS(R5); UCB I/O queue not busy
	RSB				; Return to Exec

;+
; NET$FDT_SETMODE	Process IO$_SETMODE QIO
;
; *** tbs ***
;
;-
NET$FDT_SETMODE:			; Process IO$_SETMODE function
	MOVL	P1(AP),R1		; Get characteristics buffer
	BEQL	10$			; If EQL then none
	IFNORD	#8,(R1),50$		; Br on access violation
	MOVL	4(R1),UCB$L_DEVDEPEND(R5) ; Set mailbox mask
10$:	BICL3	#1,IRP$L_WIND(R3),R0	; Get XWB address
	BGEQ	40$			; If GEQ then none
	BBC	#XWB$V_STS_DLE,-	; If BS then not direct-line access
		 XWB$W_STS(R0),40$	;
	MOVZWL	XWB$W_PATH(R0),R0	; Get Path i.d.
	MOVL	P3(AP),R1		; Get the new sub-state
	MOVL	UCB$L_VCB(R5),R2	; Get RCB address
	BSBW	TR$DLE_SETSTA		; Set its sub-state
40$:	MOVL	UCB$L_DEVDEPEND(R5),R1	; Get device dependent characteristics
	MOVZWL	S^#SS$_NORMAL,R0	; Setup I/O status
	JMP	G^EXE$FINISHIO		; Return success

50$:	MOVZWL	#SS$_ACCVIO,R0		; Setup I/O status
	JMP	G^EXE$ABORTIO		; Abort I/O


;+
; NET$FDT_CONTROL	- IO$_ACPCONTROL FDT processing
; NET$CONTROL		- IO$_ACPCONTROL "startio" processing
;
; FUNCTIONAL DESCRIPTION
;
; The FDT routine simply routes the IRP through the Exec to the ACP.
; The Exec builds an ABD describing the control function.  The ACP
; will reque any IRP to the driver if it does not recognize the control
; function.  The driver has been designed to handle some of its own
; control functions since many are protocol or control block format
; specific.
;
; INPUTS:	R5	UCB ADDRESS (NET$FDT_CONTROL)
;			XWB ADDRESS (NET$CONTROL)
;		R4	PCB ADDRESS
;		R3	IRP ADDRESS
;	
;
; OUTPUTS:	R5	UNCHANGED
;		R0	I/O status
;-
NET$FDT_CONTROL:
	BICL	#1,IRP$L_WIND(R3)	; Always clear interlock flag
	ASSUME	PHD$Q_PRIVMSK EQ 0
	MOVQ	@PCB$L_PHD(R4),IRP$Q_NT_PRVMSK(R3) ; STORE IT
	JMP	G^ACP$MODIFY			   ; CONTINUE IN EXEC

NET$CONTROL:
	BBC	#IRP$V_COMPLX,-		; Br unless real control fct
		IRP$W_STS(R3),10$	;
	MOVL	@IRP$L_SVAPTE(R3),R0	; Get ptr to window descriptor
	CLRL	(R0)			; This operation should not
					; effect the window, clear desc
	MOVZWL	#SS$_ILLIOFUNC,R0	;
	RSB

10$:	BLBC	R5,20$			; If LBC then XWB is valid and this is
					; part of Cancel I/O
	MOVZWL	S^#SS$_NORMAL,R0	; Set I/O status
	RSB				; REQCOM

20$:	BBS	#XWB$V_STS_DLE,-	; If BS then cancel I/O without going
		 XWB$W_STS(R5),30$	; thru state table
	MOVL	#NSP$C_EV_CANLNK,R7	; Set new event code
	BRW	NET$PRE_EMPT		; Pre-empt with new event
30$:	BSBW	DLE$ACPCAN		; Cancel I/O
	BRW	NET$END_EVENT		; Avoid normal state change processing

		.ENABL	LSB
GET_WNDSC:				; Get window descriptor
	CLRL	R8			; Get descriptor offset
	BRB	10$			; Continue
GET_P1DSC:				; Get P1 descriptor
	MOVL	#8,R8			; Get descriptor offset
	BRB	10$			; Continue
GET_P2DSC:				; Get P2 descriptor
	MOVL	#8*2,R8			; Get descriptor offset
	BRB	10$			; Continue in common
GET_P3DSC:				; Get P3 descriptor
	MOVL	#8*3,R8			; Get descriptor offset
	BRB	10$			; Continue in common
GET_P4DSC:				; Get P4 descriptor
	MOVL	#8*4,R8			; Get desciptor offset
10$:	ADDL	@IRP$L_SVAPTE(R3),R8	; Get descriptor address
	MOVZWL	(R8)+,R7		; Get offset to data
	MOVAB	-1(R8)[R7],R7		; Get ptr to data after skipping
					; over access mode byte
	MOVZWL	(R8),R8			; Get length of data
	RSB
		.DSABL	LSB

	.SBTTL	Process I/O "receive"  requests
;++
; NET$FDT_READ	- QIO "receive" preprocessor
; NET$READ	- I/O "receive" processor
;
; FUNCTIONAL DESCRIPTION:
;
; The routines prepare a IRP used to receive a message.  The "FDT"
; routine is not used if the IRP is constructed by a requestor other
; than QIO.  NET$READ requeues the IRP to the XWB and causes a DATA
; Flow Control message to eventually be sent.
;
; The inputs and outputs shown are for NET$READ.  For NET$FDT_READ 
; refer to &&&&&
;
; INPUTS:   R8	Scratch
;	    R7	Event code
;	    R6	UCB address
;	    R5	XWB address
;	    R4	Scratch
;	    R3	IRP address
;	    R2	Scratch
;	    R1	Scratch
;	    R0	Scratch
;
; OUTPUTS:  R8	Garbage
;	    R7	Garbage
;	    R6	Preserved
;	    R5	Preserved
;	    R4	Garbage
;	    R3	Garbage
;	    R2	Garbage
;	    R1	Garbage
;	    R0	SS$_NORMAL
;--
NET$FDT_READ:				; Virtual Read FDT routine
	MOVAL	G^EXE$READCHK,R2	; Store dipatch routine
	MOVL	P1(AP),IRP$L_R_UVA(R3)	; Save user buffer virt. address
	BISW	#IRP$M_CHAINED!-	;
		 IRP$M_COMPLX,IRP$W_STS(R3) ; Set receive buffer type
	CLRW	IRP$L_MEDIA(R3)		; Say "no buffer to allocate"
	MOVL	P1(AP),IRP$L_R_UVA(R3)	; Save user buffer virt. address
	BRW	NET$FDT_RW		; Complete request

NET$READ:				; Read "startio" routine
	BISW   #UCB$M_DEV_REQIO,-	; Indicate need to start next
		UCB$W_DEVSTS(R6)	; IRP from within driver
	MOVAB	XWB$T_DT(R5),R8		; Get subchannel block
	INSQUE	(R3),@XWB$Q_DT_RCV+4(R5); Enter IRP onto queue
	INCB	LSB$B_RCVS(R8)		; Account for it
	BSBW	NET$PROC_CXB		; Process rcv'd CXBs if possible
	MOVL	XWB$L_DI_CXB(R5),R0	; Is there a disconnect CXB ?
	BEQL	20$			; If EQL then no
	TSTL	XWB$L_RCVCXB(R5)	; Any CXB's left?
	BEQL	30$			; If EQL then no
20$:	BSBB	INC_DT_RFLW		; Flow control more segs if needed
	MOVL	S^#SS$_NORMAL,R0	;
	RSB

30$:	MOVL	#NSP$C_EV_DXCONT,R7	; Setup new event
	BRW	NET$CMPLX_EV		; Chain to new event


INC_DT_RFLW:				; See if Data flow control is needed
	;
	;
	;  INPUTS:	R8	DATA LSB address
	;		R5	XWB address
	;		R0	Scratch
	;
	;  OUTPUTS:	R0	Garbage
	;		All regs are preserved
	;
	;
	TSTB	XWB$B_INC_RFLW(R5)	; Pipelining in use?
	BEQL	20$			; If EQL then no
	CMPB	#1,LSB$B_RREQ(R8)	; Enough credits already outstanding?
	BLSSU	40$			; If LSSU then yes
	SUBW3	XWB$W_DT_HRM(R5),-	; Get number of CXBs not attached to
		LSB$W_HAX(R8),R0	; any rcv IRP
					; Should fit in a byte
	EXTV	#0,#12,R0,R0		; Sign extend
	SUBB3	R0,XWB$B_INC_RFLW(R5),R0; Get number of segments to request
	SUBB	LSB$B_RREQ(R8),R0	; Adjust for segs already requested
	BLEQ	40$			; If LEQ then no more to request
	ADDB	R0,XWB$B_DT_RFLW(R5)	; Increase the request count level
	BRB	30$			; Continue
20$:	INCB	XWB$B_DT_RFLW(R5)	; Ask for another segment
30$:	BISW	#XWB$M_STS_SDFL,-	; Request that flow control msg
		XWB$W_STS(R5)		; be built
40$:	RSB


	.SBTTL	Process QIO  "transmit"  requests
;++
; NET$FDT_WRITE	- QIO "transmit" request preprocessing
; NET$WRITE	- I/O "transmit" startio processing
;
; FUNCTIONAL DESCRIPTION:
;
; The routines prepare a IRP used to transmit a message.  The "FDT"
; routine is not used if the IRP is constructed by a requestor other
; than QIO.  NET$WRITE requeues the IRP to the XWB.
;
; The inputs and outputs shown are for NET$READ.  For NET$FDT_READ 
; refer to &&&&&
;
; INPUTS:   R8	Scratch
;	    R7	Event code
;	    R6	UCB address
;	    R5	XWB address
;	    R4	Scratch
;	    R3	IRP address
;	    R2	Scratch
;	    R1	Scratch
;	    R0	Scratch
;
; OUTPUTS:  R8	Garbage
;	    R7	Garbage
;	    R6	Preserved
;	    R5	Preserved
;	    R4	Garbage
;	    R3	Garbage
;	    R2	Garbage
;	    R1	Garbage
;	    R0	SS$_NORMAL
;--
NET$FDT_WRITE:
	MOVW	P2(AP),IRP$L_MEDIA(R3)	; Size of buffer to allocate
	MOVAL	G^EXE$WRITECHK,R2	; Store dispatch routine
	BRW	NET$FDT_RW		; Complete checking request

		.ENABL	LSB
NET$WRITE:				; IO$_WRITELBLK "startio" routine
	BBS	#IO$V_INTERRUPT,-	; Br if Interrupt request
		IRP$W_FUNC(R3),XMT_INT
	;
	;   Calculate the number of segs and the size of the final seg
	;
	MOVZWL	XWB$W_REMSIZ(R5),R8	; Get xmit segment size
	MOVZWL	IRP$W_OBCNT(R3),R1	; Get requested byte count
	DIVW3	R8,IRP$W_BCNT(R3),-	; Calculate and store number of
		   IRP$W_X_MXRES(R3)	; segments now in system buffer
	CLRL	R2			; Set for quadword divide
	EDIV	R8,R1,R0,R1		; R0 gets full segments
					; R1 gets size of last segment
	BEQL	5$			; If EQL then less than 1 full seg
	MOVW	R1,IRP$W_X_FNSIZ(R3)	; Store final segment size
	BNEQ	10$			; If NEQ then not integral segmentation
	DECL	R0			; Make it look like one segment fewer
	MOVW	R8,R1			; Use segment size for final size
5$:
	MOVW	R1,IRP$W_X_FNSIZ(R3)	; Store final segment size
	;
	;   Calculate the messages initial and final segment numbers and
	;   the numbers of the segments resident in the system buffer.
	;
10$:	MOVAB	XWB$T_DT(R5),R2		; Get LSB for DATA subchannel
	ADDW3	#1,LSB$W_LUX(R2),R1	; Get next unused seg #
	EXTV	#0,#12,R1,R1		; Sign extend low 12 bits
	MOVW	R1,IRP$W_X_INX(R3)	; Store initial segment number
	MOVW	R1,IRP$W_X_MNRES(R3)	; Store initial resident seg #
	ADDW3	R1,IRP$W_X_MXRES(R3),R8	; Calculate final resident seg #
	EXTV	#0,#12,R8,R8		; Sign extend low 12 bits
	MOVW	R8,IRP$W_X_MXRES(R3)	; Store it
	ADDW	R0,R1			; Get final segment number
	EXTV	#0,#12,R1,R1		; Sign extend low 12 bits
	MOVW	R1,IRP$W_X_FNX(R3)	; Store final seg number in IRP
	MOVW	R1,LSB$W_LUX(R2)	; Store for next pass
	;
	;   Insert packet into queue
	;
	BSBB	30$			; Insert packet onto queue
	BSBW	NET$GET_DT_HXS		; Get new LSB$W_HXS value
	MOVL	LSB$Q_XMT(R2),R3	; Get first IRP in queue
	SUBW3	IRP$W_X_INX(R3),-	; Get distance between first
		LSB$W_LUX(R2),R7	; and last segments
	BBC	#11,R7,20$		; If BS then > 2048, which
					; breaks our algorithms
	MOVL	#NSP$C_EV_DSCLNK,R7	; Set new event
	BRW	NET$CMPLX_EV		; Change state and process new
					; event.
	;
	;   Interrupt subchannel I/O
	;
XMT_INT:				; Interrupt message write request
	MOVAB	XWB$T_LI(R5),R2		; Get INT/LI LSB ptr
	BSBB	30$			; Insert packet onto queue
	SUBB3	#1,LSB$B_XMTS(R2),R3	; Get former queue length
	BSBW	NET$CHK_INTFLOW		; See if INT message can be sent
20$:	MOVL	S^#SS$_NORMAL,R0	; Set status
	RSB

30$:	BISW   #UCB$M_DEV_REQIO,-	; Indicate need to start next
		UCB$W_DEVSTS(R6)	; IRP from within driver
	INSQUE	(R3),@LSB$Q_XMT+4(R2)	; Insert packet on queue
	INCB	LSB$B_XMTS(R2)		; Update to new value
	RSB
		.DSABL	LSB

;+
; NET$ALTENTRY - Driver alternate entry point
;
; This routine is called by the Executive to pass an "internal" IRP
; to the driver.  "Internal" IRP's are those not built via QIO.
; These IRPs are used by higher level software used to request I/O and
; should not be confused with the IRPs built and passed by the
; Transport layer to NSP.  The action here is to setup the IRP fields
; as if the packet had been processed by the FDT routines.
;
; INPUTS:
;	  R5 = UCB address
;	  R3 = IRP address
;	  R0 = Scratch
;
;	  All pertinent fields of the IRP are assumed to be valid.  If
;	  the IRP$L_PID field is not negative then this is considered
;	  to be an illegally formed "internal" IRP.
;
; OUTPUTS:
;	  
;	  IRP$W_OBCNT	filled with IRP$W_BCNT value
;	  IRP$W_ABCNT	cleared
;	  IRP$L_R_UVA	cleared to indicate no user buffer is known
;			(only if IRP$V_FUNC is set)
;
;	  The packet is passed to EXE$INSQIO which returns to our caller
;-
NET$ALTENTRY:				; Accept an "internal" IRP
	MOVW	IRP$W_BCNT(R3),-	; Resident data size is the 
		IRP$W_OBCNT(R3)		; same as requested xfer size
	CLRW	IRP$W_ABCNT(R3)		; No bytes accumulated yet
	BBC	#IRP$V_FUNC,-		; If set then read function
		IRP$W_STS(R3),10$	;
	CLRL	IRP$L_R_UVA(R3)		; Indicate no user buffer
10$:	JMP	G^EXE$INSIOQ		; Put the IRP on the I/O queue


;+
; NET$FDT_RW	- Complete FDT Read/Write buffered I/O
;
; FUNCTIONAL DESCRIPTION
;
; These routines are used for common buffered I/O preprocessing. The
; user buffers are validated and, for write operations, data is moved
; into the allocated buffer.
;
; INPUTS:
;
;	P1(AP)	= Address of user buffer
;	P2(AP)	= Length of user buffer
;	   R2	= Address of buffer access check routine
;	   R3	= IRP address
;	   R4	= PCB address
;	   R5	= UCB address
;
;	IRP$L_MEDIA(R3)	= Minimum size of buffer to allocate
;
; OUTPUTS:
;
;	IRP$L_SVAPTE	address of allocated buffer (zero if none)
;	IRP$W_OBCNT	P2(AP) 
;	IRP$W_ABCNT	Zero
;	IRP$W_BCNT	if IO$_WRITE then size of data area in buffer
;			if IO$_READ  then P2(AP)
;	IRP$W_BOFF	P2(AP) or zero under some error conditions
;	JIB$L_BYTCNT	Decremented by IRP$W_BOFF
;
;-
DLE:	BRW	DLE$FDT_RW		; Direct line access
RW_ERR:	MOVZWL	#SS$_FILNOTACC,R0	; Say "file not accessed"
	BRB	NET$ABORTIO		; Abort I/O request

NET$FDT_RW:				; Read/Write FDT
	MOVL	IRP$L_WIND(R3),R1	; Get XWB address
	BEQL	RW_ERR			; If EQL none
	BBS	#XWB$V_STS_DLE,-	; If BS then not in use for direct line
		 XWB$W_STS(R1),DLE	; access

	PUSHL	R3			; Save IRP address
	MOVL	P1(AP),R0		; Get buffer address
	MOVZWL	P2(AP),R1		; Get buffer size
	CLRW	IRP$W_BOFF(R3)		; No buffer allocated yet
	MOVW	R1,IRP$W_OBCNT(R3)	; Save original request size
	CLRW	IRP$W_ABCNT(R3)		; Clear accumulated byte count
	JSB	(R2)			; Check buffer 
					; - no return on error
	MOVL	(SP),R3			; Recover R3
	JSB	G^EXE$BUFQUOPRC		; Within quota ?
	MOVL	(SP),R3			; Recover R3
	BLBC	R0,40$			; Br if not
	MOVL	PCB$L_JIB(R4),R0	; Get JIB ptr
	SUBL	R1,JIB$L_BYTCNT(R0)	; Account for bytes
	MOVW	R1,IRP$W_BOFF(R3)	; Save for update on completion
	MOVZWL	IRP$L_MEDIA(R3),R1	; Get size of buffer to allocate
	BEQL	30$			; Br if no buffer
	ADDW	#12,R1			; Add in buffer header size
	BSBW	NET$ALONONPAGED		; Else allocate the buffer
	BLBC	R0,40$			; Br if none
	POPR	#^M<R3>			; Retrieve IRP
	MOVL	R2,IRP$L_SVAPTE(R3)	; Store buffer address
	MOVAB	12(R2),(R2)+		; Store data area ptr in buffer
	MOVL	P1(AP),(R2)			; Store user buffer addr
	BBS	#IRP$V_FUNC,IRP$W_STS(R3),20$	; If set, read fct
	PUSHR	#^M<R3,R5>			; Save MOVC regs
	MOVC3	IRP$W_BCNT(R3),@(R2),8(R2)	; Move user data
	POPR	#^M<R3,R5>			; Restore regs
20$:	JMP	G^EXE$QIODRVPKT			; Give IRP to driver
30$:	CLRL	IRP$L_SVAPTE(R3)	; Indicate 'no buffer'
	BRB	20$

40$:	POPR	#^M<R3>			; Restore IRP
					; and fall thru
NET$ABORTIO:				; Abort I/O request
	JMP	G^EXE$ABORTIO		; Complete with error

	.SBTTL	Process QIO  "access"  requests
;++
;
; NET$FDT_ACCESS - IO$_ACCESS FDT processing
; NET$ACCESS	 - Common connect "startio" processing
;
; FUNCTIONAL DESCRIPTION
;
; NET$FDT_ACCESS passes the IRP through the EXEC, where the user parameters are
; packaged into an ABD, to the ACP. The ACP reads the user connect info to 
; build an Internal Connect Block (ICB) which it attaches to the IRP$L_DIAGBUF
; field of the IRP and requeues the IRP to the driver.  The role of the ACP is 
; to lookup default access control (username, password, account) information 
; in its data base and to translate node and object names to numbers.
;
; NET$ACCESS reads the ICB and determines the type of connect.  It builds an 
; XWB for connect initiate events and locates an already existing XWB for all 
; others.  NET$ACCESS stores the appropriate event code in R7 and returns 
; expecting the caller to call the event dispatcher.
;
; It should be noted that the size of the XWB is not charged against the user 
; byte count or byte limit quotas.  It is assumed that these quotas are at 
; least partly used to limit a run away process and that the file quota of a 
; process, against which logical links are charged, is a sufficient mechanism.
;
; The inputs and outputs shown are for NET$ACCESS.  For NET$FDT_ACCESS
; inputs and outputs refer to &&&&&
;
; INPUTS:   R8,R7 Scratch
;	    R6    UCB address
;	    R5    Filled with XWB address by NET$ACCESS
;	    R4    Scratch
;	    R3    IRP address
;	    R2-R0 scratch
;
; OUTPUT:   R8    Garbage
;	    R7    Event code to be processed if R5 has LBC
;	    R6    Preserved
;	    R5    XWB address if LBC, no XWB if LBS
;	    R4-R0 Garbage
;
;	    IRP$L_MEDIA I/O status if R5 has LBS
;
;	    NOTE:  R5 is used to return success/failure indication
;-
NET$FDT_ACCESS:				; Process IO$_ACCESS function

	ASSUME	IRP$L_C_ICB   EQ IRP$L_DIAGBUF
	ASSUME	PHD$Q_PRIVMSK EQ 0

	MOVQ	@PCB$L_PHD(R4),-	; Store priv mask in IRP
		IRP$Q_NT_PRVMSK(R3)	;
	CLRL	IRP$L_C_ICB(R3)		; Indicate no ICB
	JMP	G^ACP$ACCESSNET		; Continue in EXEC

NET$ACCESS:				; Complete IO$_ACCESS processing
	BSBW	GET_WNDSC		; Get descriptor of window
	MOVL	R7,IRP$L_MEDIA(R3)	; Save window pointer
	CLRL	(R7)			; Clear window image in ABD
	BISW	#IRP$M_FUNC,IRP$W_STS(R3) ; Mark for writeback
	MOVL	R6,R5			; Copy UCB addr for subroutines
	MOVL	R3,R8			; Copy IRP address to safe reg
	MOVL	IRP$L_C_ICB(R8),R4	; Get ICB pointer
	BGEQ	70$			; If not system address then
					; branch -- its an error code
	;
	;   For now, the buffer type field is used to distinquish between
	;   IO$_ACCESS for logical-links and for line service functions.
	;
	CMPB	#DYN$C_NDB,ICB$B_TYPE(R4) ; Is it an XWB ?
	BNEQ	10$			; If not continue
	MOVL	R4,R5			; Setup XWB context
	MOVL	R5,@IRP$L_MEDIA(R8)	; Setup CCB window image
	INCW	XWB$W_REFCNT(R5)	; Account for new accessor
	MOVL	R6,XWB$L_ORGUCB(R5)	; Setup UCB pointer
	MOVB	#XWB$C_STA_RUN,-	; Init the state field
		 XWB$B_STA(R5)		;
	MOVZBL	#NSP$C_EV_DLE,R7	; Set 'direct line access' event
	MOVW	#IO$_REWIND!-		; I/O code used for direct-access
		 <DLE_EV_ACCESS@8>,-	; Qualify the event for DLE-startio 
		IRP$W_FUNC(R8)		; dispatching
	BRB	50$			; Finish in common
	;
	;   Logical-link IO$_ACCESS
	;
10$:	MOVZWL	ICB$W_LOCLNK(R4),R3	; Get local link address
	BNEQ	30$			; Connect Confirm if NEQ
	;
	;   Connect Initiate
	;
	MOVZWL	ICB$W_REMNOD(R4),R3	; Get remote node address
	BSBW	NET$CREATE_XWB		; Else Connect Initiate
	BLBS	R5,60$			; Br if couldn't create XWB
	MOVZBL	#NSP$C_EV_CIA,R7	; Set 'connect initiate access'
	BRB	50$			; Finish in common
30$:	;
	;   Connect Confirm
	;
	BSBW	NET$XWB_LOCLNK		; Find associated XWB
	BLBS	R5,60$			; Br if XWB was not found
	MOVZBL	#NSP$C_EV_CCA,R7	; Set 'connect confirm access'
	;&
	;& This must be updated to allow subprocess IO$_ACCESS
	;&
	CMPL	XWB$L_PID(R5),-
		UCB$L_PID(R6)		; PIDs match ?
	BNEQ	55$			; Br if they don't
40$:	BBC	#IO$V_ABORT,-		; Br unless connect reject
		IRP$W_FUNC(R8),50$	;
	MOVZBL	#NSP$C_EV_CRA,R7	; Set 'connect reject access'
50$:	RSB

;
;  Unsuccessful access
;
55$:	MOVL	IRP$L_C_ICB(R8),R0		; Get ICB address
	MOVZWL	#SS$_DEVALLOC,IRP$L_C_ICB(R8)	; Setup return states
	BRB	65$				; Continue
60$:	MOVL	IRP$L_C_ICB(R8),R0		; Get ICB address
	MOVW	#SS$_NOLINKS,IRP$L_C_ICB(R8)	; Store error code
65$:	BSBW	KILLICB				; Deallocate ICB
70$:	MOVL	R8,R3				; Setup IRP pointer
	BSBW	CLEANUP_ACC1			; Restore quota
	MOVZWL	IRP$L_C_ICB(R8),IRP$L_IOST1(R8)	; Store the error
	MOVB	#1,R5				; Invalidate window ptr
	RSB					; REQCOM

;+
; NET$INITIATE	- Connect Initiate action routine
; NET$CONFIRM	- Connect Confirm  action routine
;
; FUNCTIONAL DESCRIPTION
;
; These action routines resume processing the event setup by NET$ACCESS.
; NET$INITIATE assumes that a Connect Initiate message will be built
; and sent.  NET$CONFIRM is used when received connect is being either
; accepted or rejected and assumes that eihter a Connect Confirm or a
; Disconnect Initiate message will be built and sent.  In each case,
; the message is not contructed here.  Instead the XWB is filled with
; the appropriate information and the message will be built depending
; upon the link state.
;
; INPUTS:  R8	 Scratch
;	   R7	 Event code
;	   R6	 UCB address
;	   R5	 XWB address
;	   R4-R0 Scratch
;
; OUTPUTS: R1-R4,R7,R8 are garbage
;
;	   R6,R5 are preserved
;
;	   R0 returns status *** tbs ***
;
; SIDE EFFECTS
;
; The ICB attached to the IRP is deallocated.
;
;-
		.ENABL	LSB
NET$INITIATE:
	MOVL	UCB$L_PID(R6),XWB$L_PID(R5)	; Copy Process ID
	BSBB	50$				; Setup common XWB fields
	CLRW	XWB$W_REMLNK(R5)		; No remote link yet
	MOVW	#1,XWB$W_PROGRESS(R5)		; Only send message once
	ADDW3	#1,ICB$W_TIM_OCON(R4),-		; Outbound connect timer (the 1
		XWB$W_TIMER(R5)			; is for possible clock skew)
	BRB	20$				;

NET$CONFIRM:
	BSBB	50$				; Setup XWB
	;
	;   Startup the XWB fork process, deallocate ICB
	;
20$:	BSBW	KILLICB_1			; Deallocate ICB
	INCW	XWB$W_REFCNT(R5)		; Account for accessor
	MOVL	R6,XWB$L_ORGUCB(R5)		; Setup associated UCB address
	BISW	#XWB$M_FLG_SCD,XWB$W_FLG(R5)	; Set the send message flag
	BBS	#IO$V_ABORT,IRP$W_FUNC(R3),30$	; If BS then connect reject
	BISW	#UCB$M_DEV_PNDAC,UCB$W_DEVSTS(R6) ; Mark access pending
	MOVL	R5,@IRP$L_MEDIA(R3)		; Setup the XWB as the window
	RSB					; Return 

30$:	MOVL	S^#SS$_NORMAL,IRP$L_IOST1(R3)	; Return success on connect rej
	BSBW	CLEANUP_ACCESS			; Clean up access function
	RSB
;
;  Common setup for XWB
;
50$:	MOVL	UCB$L_IRP(R6),R4		; Get IRP
	MOVL	IRP$L_C_ICB(R4),R4		; Get ICB
	PUSHR	#^M<R4,R5>			; Save MOVC regs
	;
	;   Verify data structure format compatibility for MOV efficiency
	;
	ASSUME	ICB$B_LPRNAM LT ICB$B_RPRNAM
	ASSUME	ICB$B_RPRNAM LT ICB$B_ACCESS

	ASSUME	< ICB$B_RPRNAM - ICB$B_LPRNAM > EQ, -
		< XWB$B_RPRNAM - XWB$B_LPRNAM >
	ASSUME	< ICB$B_ACCESS - ICB$B_RPRNAM > EQ, -
		< XWB$B_LOGIN  - XWB$B_RPRNAM >
	ASSUME	< ICB$C_LPRNAM + ICB$C_RPRNAM + ICB$C_ACCESS > EQ 104
	ASSUME	< XWB$C_LPRNAM + XWB$C_RPRNAM + ICB$C_ACCESS > GE 104

	MOVC3	#104,ICB$B_LPRNAM(R4),-		    ; Move process names and
		    XWB$B_LPRNAM(R5)		    ; accounting info
	MOVQ	(SP),R4				    ; Recover ICB,XWB pointers
	;
	;   Setup common connect fields in XWB
	;
	MOVC3	#17,ICB$B_DATA(R4), XWB$B_DATA(R5)  ; Move optional data
	MOVQ	(SP),R4				    ; Recover ICB,XWB pointers

	ASSUME	ICB$C_RID  LE XWB$C_RID

	MOVB	ICB$B_RID(R4),XWB$B_RID(R5)	    ; Setup remote i.d. length
	MOVC5	#ICB$C_RID,ICB$T_RID(R4),#^A" ",-   ; Move the remote i.d. text
		#XWB$C_RID,XWB$T_RID(R5)	    ;
						    ;
	POPR	#^M<R4,R5>			    ; Restore regs
						    ;
	MOVW	ICB$W_PATH(R4),     XWB$W_PATH(R5)  ; Establish path to use
	MOVW	ICB$W_SEGSIZ(R4),   XWB$W_LOCSIZ(R5); Set rcv buffer size
	MOVW	ICB$W_RETRAN(R4),   XWB$W_RETRAN(R5)
	MOVW	ICB$W_RETRAN(R4),   XWB$W_PROGRESS(R5)
	MOVW	ICB$W_DLY_FACT(R4), XWB$W_DLY_FACT(R5)
	MOVW	ICB$W_DLY_WGHT(R4), XWB$W_DLY_WGHT(R5)
	MOVW	ICB$W_TIM_INACT(R4),XWB$W_TIM_INACT(R5)
	RSB

KILLICB_1:
	MOVL	UCB$L_IRP(R6),R3		; Get IRP
	MOVL	IRP$L_C_ICB(R3),R0		; Get ICB
						; And fall thru
KILLICB:
	JSB	G^COM$DRVDEALMEM		; Deallocate ICB, preserves R5
	RSB

		.DSABL	LSB

;++
; NET$DEACCESS	- User QIO request to disassociate XWB with the I/O channel
;
; INPUTS:	R3 - IRP address
;		R5 - XWB address
;
;--
NET$DEACCESS:				; User QIO to break link
	BBC	#XWB$V_STS_DLE,-	; If BC then logical-link XWB
		 XWB$W_STS(R5),10$	;
	BSBW	DLE$DEACCESS		; Call direct-line service 
	BSBW	CLEANUP_ACCESS		; Do common cleanup
	BRW	NET$END_EVENT		; Avoid common state machine machinism
	;
	;   XWB is a logical-link XWB
	;
10$:	BBS	S^#IO$V_SYNCH,-		; If synch disconnect, leave reason
		    IRP$W_FUNC(R3),20$	;
	MOVW	#NET$C_DR_ABORT,-	; Set in new reason code
		    XWB$W_REASON(R5)	;
20$:	BSBW	CLEANUP_ACCESS		; Clean up from access I/O fct
	MOVZWL	#SS$_ABORT,-		;
		    XWB$W_DIS_STAT(R5)	; Set I/O abort status
	BSBW	NET$PURG_RUN		; Attempt to leave RUN state

	ASSUME  XWB$C_STA_CLO  EQ  0
	TSTB	XWB$B_STA(R5)		; Done with XWB if in 'closed' state
	BEQL	90$			; If EQL done with XWB
	;
	;   Move optional disconnect data to XWB
	;
	CLRB	XWB$B_DATA(R5)		; Assume no optional data
	BSBW	GET_P2DSC		; Get data descriptor
	DECL	R8			; Reduce length by count field
	BLEQ	90$			; If LEQ then no data
	MOVZBL	(R7)+,R0		; Get count value, advance R8
	CMPL	R8,R0			; Minimize what he said and what is
	BLSS	60$
	MOVL	R0,R8
60$:	CMPL	R8,#16			; Minimize max lth and what there is
	BLSS	70$
	MOVL	#16,R8
70$:	PUSHL	R5			; Save event context
	MOVB	R8,XWB$B_DATA(R5)	; Save data size
	MOVC3	R8,(R7),XWB$T_DATA(R5)	; Move data
	POPL	R5			; Restore R5
90$:	RSB


;++
; NET$CMPL_ACC		- Complete access, fill in window
;
; FUNCTIONAL DESCRIPTION
;
; The access function currently being processed on the UCB is completed.
; If the I/O completion status is not successful then the window of the
; channel associated with the IRP is cleared.
;
; INPUTS:  R5	XWB address
;	   R1	Second longword of the IOSB
;	   R0	First  longword of the IOSB
;
; OUTPUTS: R0	SS$_NORMAL
;
;	   All other registers are preserved.
;
; SIDE EFFECTS
;
; If the channel window is cleared then XWB$W_REFCNT is decremented.
;
;-
NET$CMPL_ACC:				; Complete access, fill window
	PUSHR  #^M<R1,R2,R3,R4,R5>	; Save regs
	MOVL	XWB$L_ORGUCB(R5),R4	; Get UCB
	BEQL	20$			; If EQL link is on the way out
	BBCC   #UCB$V_DEV_PNDAC,-	; Br unless access is pending
		UCB$W_DEVSTS(R4),20$	;
	MOVL	UCB$L_IRP(R4),R3	; Get IRP
	BLBS	R0,10$			; Br if successful access
	;
	;   Map the disconnect reason code to a system service code
	;
	PUSHR	#^M<R2,R3>		; Save regs
	MOVAB	W^DR_TABLE-6,R2		; Get address of mapping table
	MOVZWL	#SS$_REJECT,R0		; Assume rejected
	TSTB	R1			; Is it reject?
	BEQL	9$			; If EQL yes
	MOVZWL	#SS$_CONNECFAIL,R0	; Else set catch-all status
7$:	ADDL	#6,R2			; Increment to next entry
	MOVB	(R2)+,R3		; Get the reason code
	BEQL	9$			; If EQL at end of list
	CMPB	R3,R1			; Match?
	BNEQ	7$			; If NEQ no - loop
	MOVW	(R2),R0			; Replace the SS$ code
9$:	POPR	#^M<R2,R3>		; Restore regs
	BSBB	CLEANUP_ACCESS		; Clean up from access I/O fct
	;
	;   A fork proces must be created to perform the actual I/O 
	;   completion since a side effect may be the feeding of a new IRP
	;   to the driver.  We do not want to lose the processor since 
	;   driver synchronization is base primarily on serial execution 
	;   at fork IPL.  Calling IOC$REQCOM directly would violate this.
	;
10$:	PUSHAB	B^20$			; Setup return address
	MOVL	R4,R5			; Switch to UCB context
	MOVQ	R0,R3			; Use IOSB image as fork info
	BISW	#UCB$M_DEV_CMPIO,-	; Say "I/O completion in progress"
		 UCB$W_DEVSTS(R5)	;
	JSB	G^EXE$FORK		; Create Fork process to complete
	BICW	#UCB$M_DEV_CMPIO,-	; Clear "I/O completion in progress"
		 UCB$W_DEVSTS(R5)	;
	MOVQ	R3,R0			; We're back, get IOSB info
	;
	;   Repair the listhead (forking screwed it up) since the UCB will 
	;   eventually be deallocated as if it were a mailbox and the code 
	;   (IOC$DELMBX) which deallocates it thinks this listhead contains
	;   packets which should also be deallocated.
	;
	MOVL	R5,(R5)			; Make listhead appear empty
	MOVL	R5,4(R5)		;
	JMP	G^IOC$REQCOM		; Complete this IRP and startup
					; the next one if possible
20$:	POPR	#^M<R1,R2,R3,R4,R5>	; Restore regs
	MOVB	#1,R0			; Success
	RSB

;+
;
; CLEANUP_ACCESS - This routine cleans up things for a terminated access
; CLEANUP_ACC1	 - This cleans up when no XWB exists
;
; INPUTS:
;		R5 - XWB address  for CLEANUP_ACCESS only
;		R3 - IRP address
;
; OUTPUTS:
;		R7,R8 - Clobbered for CLEANUP_ACCESS only
;		R3,R5 - unchanged
;		R0,R1 - preserved
;
;-
	.ENABL	LSB

CLEANUP_ACCESS:
	BSBW	GET_WNDSC		; Get window descriptor
	DECW	XWB$W_REFCNT(R5)	; Account for loss of accessor
	BNEQ	30$			; Br if not last accessor
	CLRL	XWB$L_ORGUCB(R5)	; XWB is unowned
	CLRL	XWB$L_PID(R5)		; XWB is unowned
	CLRL	(R7)			; Zero window's image in ABD
CLEANUP_ACC1:				; Alternate entry point if no XWB
	PUSHR	#^M<R0,R1>		; Save regs
	BISW	#IRP$M_FUNC,IRP$W_STS(R3) ; Mark for write back
	MOVW	#1,IRP$W_BCNT(R3)	; Write back one descriptor
	MOVZWL	IRP$L_PID(R3),R0	; Get PID index
	MOVL	G^SCH$GL_PCBVEC,R1	; Get PCB vector address
	MOVL	(R1)[R0],R1		; Get PCB address
	CMPL	PCB$L_PID(R1),IRP$L_PID(R3) ; Still there ?
	BNEQ	5$			; If not branch
	MOVL	PCB$L_JIB(R1),R0	; Get JIB
	INCW	JIB$W_FILCNT(R0)	; Else update quota taken for link
5$:	POPR	#^M<R0,R1>		; Restore regs
	RSB				; Done

30$:	BUG_CHECK NETNOSTATE,FATAL	; Invalid reference count

	.DSABL	LSB

NET$RCV_POST:
	TSTB	LSB$B_RCVS(R8)		; Any IRPs ?
	BEQL	30$			; If not, branch
5$:	MOVL	XWB$Q_DT_RCV(R5),R3	; Get IRP
	ASSUME	IRP$V_NET_INUSE EQ 0	;
	BLBS	IRP$B_NET(R3),30$	; Br if still in use
	TSTB	IRP$B_REFCNT(R3)	; Asynchronous activity?
	BNEQ	40$			; If so, can't complete yet
	MOVW	IRP$W_ABCNT(R3),IRP$L_IOST1+2(R3) ; Store xfer size
	MOVW	IRP$W_ABCNT(R3),IRP$W_BCNT(R3)	  ; Here too
	;
	;   The IRP and buffer(s) are already setup as if complex chained
	;   buffers are being used.  By storing the address of the data
	;   area in the first longword of the first buffer, we are also
	;   consistent with the non-chained buffer structure.
	;
	MOVL	IRP$L_SVAPTE(R3),R0	; Get (first) buffer
	BEQL	20$			; Br if none
	MOVZWL	CXB$W_OFFSET(R0),R1	; Get offset to data
	ADDL3	R0,R1,(R0)+		; Store pointer to data
					; (needed for non-chained)
	MOVL	IRP$L_R_UVA(R3),(R0)	; Set user buffer address
					; (needed for both cases)
20$:	BSBB	NET$POST		; Complete the IRP
	BICB   #XWB$M_STS_LKRCV,-	; Unlock the receive queue
		XWB$W_STS(R5)		;
	DECB	LSB$B_RCVS(R8)		; Account for loss of IRP
	BNEQ	5$			; Keep trying if more IRPs
30$:	RSB
40$:	BISB   #XWB$M_STS_LKRCV,-	; Lock the receive queue
		XWB$W_STS(R5)
	RSB

;+
; NET$XMT_POST	- Post for completion an IO$_WRITEBLK IRP
;
; FUNCTIONAL DESCRIPTION
;
; The specified transmit queue is scanned and all IRPs with a zero
; reference count are posted for completion.  The first IRP with a
; non-zero reference count stops the scan in order to guarentee
; sequentiality.
;
; INPUTS:  R8	LSB address
;	   R5	XWB address
;	   R3	Scratch
;	   R0	1 if message flow control (or INT channel)
;		0 otherwize
; OUTPUTS: R3	Garbage
;	   R0	Garbage
;
;	   All other registers are preserved.
;-
	ASSUME	IRP$V_NET_INUSE EQ 0
NET$XMT_POST:				; Post xmit IRP for completion
	TSTB	LSB$B_XMTS(R8)		; Anything on the queue ?
	BEQL	30$
	PUSHL	R0			; Save flow control flag
5$:	MOVL	LSB$Q_XMT(R8),R3	; Get IRP
	BLBS	IRP$B_NET(R3),20$	; Br if still in use by NSP
	TSTB	IRP$B_REFCNT(R3)	; Any references left ?
	BNEQ	20$			; If so, exit
	MOVW	IRP$W_OBCNT(R3),-	; Store bytes xmitted
		IRP$L_IOST1+2(R3)
	BSBB	NET$POST		; Else post it for completion
	BLBC	(SP),10$		; Br unless msg flow control
	DECB	LSB$B_XREQ(R8)		; Else done with request
10$:	DECB	LSB$B_XMTS(R8)		; Account for IRP
	BNEQ	5$			; Loop
20$:	TSTL	(SP)+			; Cleanup stack
30$:	RSB

;+
; NET$POST	- Post IRP for completion
;
; FUNCTIONAL DESCRIPTION
;
; An IRP is removed from its queue and posted for completion.
;
; IMPLICIT INPUTS:	IRP$L_MEDIA,IRP$L_MEDIA+4 is the IOSB quadword.
;
; INPUTS:   R5	XWB pointer
;	    R3	IRP pointer
;	    R0	Scratch
;
; OUTPUTS:  R5	XWB pointer
;	    R3	Garbage
;	    R0	SS$_NORMAL
;--
NET$POST:				; Complete IRP w/o touching UCB$V_BSY
	PUSHR	#^M<R5,R1>		; Save R1,R5 
	REMQUE	(R3),R3			; Deque the IRP
	MOVL	IRP$L_UCB(R3),R5	; Get the UCB
	JSB	G^COM$POST		; Another packet for the heap
	POPR	#^M<R5,R1>		; Recover regs
	MOVB	#1,R0			; Set success
	RSB

	.SBTTL	Cancel I/O routines
;+
; NET$CANCEL	- Cancel I/O entry point
;
; FUNCTIONAL DESCRIPTION
;
; If there is an IRP currently being processed on the UCB then it is
; an IO$_ACCESS function since all other IRPs are either moved to the
; XWB or are processed to completion without interruption during the
; 'startio' phase.  If such an IRP exists, the link is aborted.
;
; The remainder of the Cancel-I/O sequence will occur when the special
; IO$_ACPCONTROL QIO is issued by the $CANCEL system service.  Refer to
; routine NET$_ACPCAN.
;
; In all cases, the ACP is informed via a mailbox message since special
; cleanup may be needed in the ACP (e.g. declared name cleanup).  Note
; that the special Cancel IRP is only sent to the ACP if there is a logical
; link active.
;
; INPUTS:
;
;	R5	UCB address
;	R4	PCB address
;	R3	IRP address if UCB is busy
;	R2	Channel number
;	R1	Scratch
;	R0	Scratch
;
;	IPL	UCB$B_FIPL
;
; OUTPUTS:
;
;	R0,R1,R2,R3  are garbage
;
;	All other registers are preserved
;-
NET$CANCEL:				; Cancel I/O entry point
	;
	;   Tell the ACP
	;
	MOVL	UCB$L_VCB(R5),R0	; Get VCB address
	BEQL	7$			; If EQL then none
	PUSHR	#^M<R2,R3,R4,R5,R7,R8>	; Save regs
	MOVL	R2,R7			; Save channel number
	MOVL	RCB$L_ACP_UCB(R0),R5	; Get the ACP's UCB
	MOVZWL	#MSG$_PATHLOST,R8	; Setup mailbox message code
	MOVL	#6,R2			; Bytes to be entered into message
	BSBW	NET$SEND_MBX		; Setup the message
	BLBC	R0,5$			; Br on error -- ignore it
	MOVL	PCB$L_PID(R4),(R3)+	; Enter the PID
	MOVW	R7,(R3)+		; Enter channel
	JSB	@(SP)+			; Send the message
5$:	POPR	#^M<R2,R3,R4,R5,R7,R8>	; Restore regs
7$:	BBC	#UCB$V_BSY,-		; Done if UCB is not busy
		    UCB$W_STS(R5),20$	;
	BICW3	#^C<IO$M_FCODE>,-	; Get fct code w/o modifiers
		    IRP$W_FUNC(R3),R0	;
	CMPW	S^#IO$_ACCESS,R0	; ACCESS function ?
	BEQL	10$			; If so continue
	BUG_CHECK NETNOSTATE,FATAL	; Our assumptions are wrong
10$:	CMPL	PCB$L_PID(R4),-		; IRP belong to this process ?
		    IRP$L_PID(R3)	;
	BNEQ	20$			; If not we're done
	CMPW	R2,IRP$W_CHAN(R3)	; Is channel correct ?
	BNEQ	20$			; Br if not
	PUSHR	#^M<R4,R5,R6,R7,R8,R9>	; Save regs
	MOVL	R5,R6			; Setup UCB address
	MOVL	@IRP$L_MEDIA(R3),R5	; Get XWB address
	BEQL	15$			; Br if none
	MOVL	#NSP$C_EV_CANLNK,R7	; Set event code
	BSBW	NET$EVENT		; Process event
15$:	POPR	#^M<R4,R5,R6,R7,R8,R9>	; Restore regs
20$:	RSB

;+
; NET$ACPCAN	- Process IO$_ACPCONTROL issued by $CANCEL
;
; FUNCTIONAL DESCRIPTION
;
; This I/O request is issued by the $CANCEL system service.  It is used here to
; locate the XWB.  If there are any IRPs on the XWB which match the PID and 
; channel of the requestor then they must be  cancelled.  This is done by 
; breaking the link.
; 
; INPUTS:
;
;	R8	Scratch
;	R7	Scratch
;	R6	UCB address
;	R5	XWB address; low bit set if no XWB
;	R4	Scratch
;	R3	IRP address
;	R2	Scratch
;	R1	Scratch
;	R0	Scratch
;
; OUTPUTS:
;
;	R8,R7,R4,R2,R1,R0 are garbage
;
;	All other registers are preserved
;-
	ASSUME	LSB$Q_XMT EQ 0		; Assume listhead offset is zero

DLE_ACPCAN:
	BUG_CHECK  NETNOSTATE,FATAL	;Should never get here
	BRW	DLE$ACPCAN		; Tell direct-line service

NET$ACPCAN:				; Cancel I/O
	BLBS	R5,10$			; Br if no XWB
	BBS    #XWB$V_STS_DLE,-		; If BS then direct-line XWB
		XWB$W_STS(R5),DLE_ACPCAN;
	BBS    #XWB$V_STS_RUN,-		; Br if XWB fields are
		XWB$W_STS(R5),15$	; are defined for run mode
10$:	RSB				;


15$:	BSBW	SC_CO			; Get first IRP queue
20$:	MOVL	(R8),R8			; Get next IRP (or listhead)
	SOBGEQ	R0,40$			; Br unless no IRPs left
	JSB	@(SP)+			; Note R8 = listhead
	BRB	20$			; Continue

40$:	CMPL	IRP$L_PID(R3),IRP$L_PID(R8)	; Match ?
	BNEQ	20$				; If not try next IRP
	CMPW	IRP$W_CHAN(R3),IRP$W_CHAN(R8)	; Match ?
	BNEQ	20$				; If not try next IRP
	TSTL	(SP)+			; Pop co-routine address
					; Fall thru to cancel all
NET$PURG_RUN:				; Leave the RUN state
	PUSHR  #^M<R1,R2,R3,R4>		; Save regs
	PUSHL  S^#SS$_NORMAL		; Assume success
	BBC    #XWB$V_STS_RUN,-		; Nothing to do if not using
		XWB$W_STS(R5),20$	; RUN format
	BBCC   #XWB$V_STS_LKDB,-	; Free the resident data buffer
		XWB$W_STS(R5),5$	; Br if not in use
	MOVZWL #MSG$_INTMSG,R8		; Set mbx message code
	MOVAL	XWB$B_DATA(R5),R1	; Get address of INT msg data
	MOVZBL	(R1),R2			; Get data size
	INCL	R2			; Adjust for count field
	BSBW	NET$SEND_CS_MBX		; Build and send msg to mailbox
	MOVL	R0,(SP)			; Save status
5$:	BICW   #XWB$M_STS_SIFL!-	; Cancel all requests which
		XWB$M_STS_SDFL!-	; have meaning only for the
		XWB$M_STS_IAVL,-	; RUN state
		XWB$W_STS(R5)
	BSBB	INAC			; Deactivate all IRPs
	EXTV	#XWB$V_STS_MSGFL,#1,-	; Get current 'msg flw ctl' flag
		XWB$W_STS(R5),R0
	MOVAB	XWB$T_DT(R5),R8		; Get DATA LSB
	BSBW	NET$XMT_POST		; Attempt to post DATA xmt IRPs
	MOVW	LSB$W_HXS(R8),-		; Pretend we've sent all messages
		LSB$W_LNX(R8) 		;& will this cause us to hang?
	MOVW	LSB$W_HXS(R8),-		; Pretend we've sent all messages
		LSB$W_HNX(R8) 		;& will this cause us to hang?
	BISW   #XWB$M_FLG_WHGL,-	; Prevent sending any further data segs
		XWB$W_FLG(R5)		;
	BSBW	NET$RCV_POST		; Attempt to post DATA rcv IRPs
	ADDB3	LSB$B_RCVS(R8),-	; Get total DATA IRPs left
		LSB$B_XMTS(R8),R2
	MOVAB	XWB$T_LI(R5),R8		; Get LI LSB
	MOVB	#1,R0			; Indicate 'msg flw ctl'
	BSBW	NET$XMT_POST		; Attempt to post INT xmt IRPs
	ADDB	LSB$B_XMTS(R8),R2	; Update total IRPs left
	BEQL	15$			; Br if all IRPs were completed
	BISW   #XWB$M_FLG_LOCK,-	; Prevent any msgs form being
		XWB$W_FLG(R5)		; xmitted until queues are empty
	BRB	20$			; Continue
15$:	MOVW	XWB$W_RETRAN(R5),-	; Init PROGRESS
		XWB$W_PROGRESS(R5)	;
	BICW   #XWB$M_STS_RUN,-		; XWB "run" fields no longer in use
		XWB$W_STS(R5)		;
	BICW   #XWB$M_FLG_LOCK!-	; Unlock the msg scheduler
		XWB$M_FLG_SLI,-		; Don't send anymore INT/LS msg's
		XWB$W_FLG(R5)
20$:	POPR	#^M<R0,R1,R2,R3,R4>	; Restore regs
	RSB

INAC:	MOVL	XWB$L_RCVCXB(R5),R0	; Get next CXB
	BEQL	3$			; If EQL then none
	MOVL	CXB$L_LINK(R0),-
		XWB$L_RCVCXB(R5)	; Remove CXB from list
	JSB	G^COM$DRVDEALMEM	; Deallocate XWB
	BRB	INAC			; Loop
3$:	BSBB	SC_CO			; Call co-routine for listhead
5$:	MOVL	(R8),R8			; Advance to next IRP
	SOBGEQ	R0,10$			; Br if unless none left
	JSB	@(SP)+			; Note that R8 = listhead
					; Get next listhead or exit
	BRB	5$			; Continue
10$:	BBCC	#IRP$V_NET_INUSE,-	; Deactivate IRP
		 IRP$B_NET(R8),5$
	MOVW	XWB$W_DIS_STAT(R5),-
		IRP$L_IOST1(R8)		; Enter I/O status
	BRB	5$

SC_CO:	MOVAB	XWB$T_LI(R5),R8		; Get LI LSB
	MOVZBL	LSB$B_XMTS(R8),R0	; Get IRP count
	JSB	@(SP)+			; Process the list
	MOVAB	XWB$T_DT(R5),R8		; Advance to DATA LSB
	MOVZBL	LSB$B_XMTS(R8),R0	; Get IRP count
	JSB	@(SP)+			; Process the list
	MOVZBL	LSB$B_RCVS(R8),R0	; Get receive IRP count
	MOVAB	XWB$Q_DT_RCV(R5),R8 	; Advance to DATA rcv listhead
	JSB	@(SP)+			; Process the list 
	TSTL	(SP)+			; Pop return address
	RSB


;++
;
; NET$STATUS		- Receive xmit status from Transport layer
;
; *** TBS ***
;
; This routine is called by Transport to return transmit status to NSP.  There
; is currently no use for it except to perhaps enhance the timer mechanism or 
; to be smarter about PHASE II line failures. May be needed in the furture to 
; reduce a reference count on a user buffer for ICCS type devices.  
;
;	R5		Scratch
;	R4		CXB adress
;	R2		RCB pointer
;	R1		Address of IRP
;
;	IRP$L_IOST1(R1)	First IOSB longword
;	IRP$L_IOST2(R1)	Second IOSB longword
;
;	CXB$L_IRP(R4)	End-action data (contains logical-link address)
;
;--
NET$STATUS:				; Receive xmit status
	RSB


NET$PH2_CCS:				; Receive status after send CC to
					; a Phase II partner
	BLBC	IRP$L_IOST1(R1),30$	; If error then timer will catch it

	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9> ; Save all regs
	MOVZWL	CXB$L_IRP(R4),R3		   ; Get local link number
	MOVL	R2,R4				   ; Copy RCB ptr
	BSBW	NET$XWB_LOCLNK1			   ; Find the XWB
	BLBS	R5,20$				   ; If LBS not found
	MOVZBL	#NSP$C_EV_PH2CCS,R7		   ; Setup event
	BSBW	NET$EVENT			   ; Report the event
20$:	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9>
30$:	RSB


	.SBTTL	NET$ACP_COMM	- Entry for ACP communication
;++
; NET$ACP_COMM	- NETACP's update entry point
;
; FUNCTIONAL DESCRIPTION:
;
; This routine is called by the ACP for change of status notification including
; process exit, logical link "ownership" changes, and datalink transitions.
;
;
; CALLING SEQUENCE:
;
;	  JSB	@CRB$L_INTD+VEC$L_START  at IPL 0
;
; INPUTS: R5	NET UCB address.   
;	  R4-R1	Function specific -- see individual action routine preambles
;	  R0	Function code as follows:
;
;		  NETUPD$_CONNECT   - Pass NCB to Declared Name mailbox
;		  NETUPD$_PROCRE    - Process created to received connect
;		  NETUPD$_ABORT	    - Process couldn't start
;		  NETUPD$_EXIT	    - Started process is exiting
;
;		  NETUPD$_DLL_ON    - Datalink has come online - post a receive
;		  NETUPD$_DLL_DLE   - Datalink online for service fcts
;		  NETUPD$_REACT_RCV - Reactivate Datalink receiver
;
;		  NETUPD$_DSCLNK    - Graceful disconnect of single link
;		  NETUPD$_ABOLNK    - Force immediate disconnect of all links
;
;		  NETUPD$_BRDCST    - Broadcast mailbox message
;		  NETUPD$_REPLY     - Reply to associated mailbox
;
; OUTPUTS:  R0	Status
;
;	    All other registers are preserved.
;
;--
	R3_OFF = 4*3
	R4_OFF = 4*4
	R5_OFF = 4*5

		.ENABL	LSB

NET$ACP_COMM:				; ACP entry point
	SETIPL	UCB$B_FIPL(R5)		; Raise IPL to synch access to structures

	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10>	; Save regs

	MOVL	SP,R10			; Save ptr to saved R0
	BSBB	20$			; Dispatch on fct code
	MOVL	R0,(SP)			; Overlay return code

	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10>	; Restore regs

	SETIPL	#0			; Restore IPL
	RSB

20$:	$DISPATCH  R0,TYPE=B,-		; Case on function code
	<-
	    <NETUPD$_CONNECT,	DECLARE>,-  ; Pass NCB to Declared Name mailbox
	    <NETUPD$_PROCRE,	PROCRE>,-   ; Process created to rcv connect
	    <NETUPD$_ABORT,	ABORT>,-    ; Process couldn't start
	    <NETUPD$_EXIT,	EXIT>,-	    ; Started process is exiting
	    -				    ;
	    <NETUPD$_DSCLNK,    DISC_ONE>,- ; Disconnect single link
	    <NETUPD$_ABOLNK,   	ABORT_ALL>,-; Abort all links
	    -				    ;
	    <NETUPD$_BRDCST,    BRDCST>,-   ; Broadcast mailbox message
	    <NETUPD$_REPLY,     REPLY>,-    ; Send general mailbox message
	    -				    ;
	    <NETUPD$_DLL_ON,    DLLTRN>,-   ; Datalink has come online
	    <NETUPD$_REACT_RCV, DLLTRN>,-   ; Reactivate datalink receiver
	    <NETUPD$_DLL_DLE,   DLLTRN>,-   ; Datalink online for direct-line 
	    -				    ; access
	>
	BUG_CHECK	NETNOSTATE,FATAL    ; Fct code unknown

;+
;  PROCRE   - Process started due to CI received
;
;  INPUTS:  R5	NET UCB address.
;	    R4	Scratch
;	    R3	Local link number.
;	    R2	Scatch
;	    R1  PID of process
;
;-
PROCRE:	CLRL	R0			; Setup for "no PID" match
	BSBW	200$			; Get XWB
	BNEQ	40$			; Done if NEQ
	MOVL	R1,XWB$L_PID(R5)	; Set PID of process allowed
					; to complete the connect
	BRB	40$			; Done

;+
;  ABORT    - Process not started
;
;  INPUTS:  R5	NET UCB address.
;	    R4	Scratch
;	    R3	Local link number.
;	    R2	Disconnect reason code 
;	    R1  PID of process
;
;-
ABORT:	CLRL	R0			; Setup for "no PID" match
	BSBW	200$			; Get XWB
	BNEQ	40$			; Done if NEQ
	BSBW	180$			; Enter DIS state
40$:	MOVL	S^#SS$_NORMAL,R0	; Report success
	RSB				; Done

;+
;  EXIT	    - A formerly started process has exited
;
;  INPUTS:  R5	NET UCB address
;	    R4	Scratch
;	    R3	Local link number.
;	    R2	Disconnect reason code 
;	    R1  PID of process
;
;-
EXIT:	MOVL	R1,R0			; Copy process PID
	MOVL	UCB$L_VCB(R5),R5        ; Get RCB
	BEQL	80$			; Br if not mounted
	MOVL	RCB$L_PTR_LTB(R5),R5    ; Get LTB
	BEQL	80$			; Br if its not there
	MOVAL	-XWB$L_LINK -		;
		+LTB$L_XWB(R5),R5	; Setup for scan
60$:	MOVL	XWB$L_LINK(R5),R5	; Get next XWB
	BEQL	80$			; If EQL then end of list
	BSBB	210$			; Check process access to XWB via PID
	BNEQ	60$			; If NEQ then something wrong
	BSBB	180$			; Disconnect the link
	BRB	60$			; Continue
80$:	MOVL	S^#SS$_NORMAL,R0	; Success
	RSB				; Done

	
;+
;  DISC_ONE -   Disconnect a single logical-link
;
;  INPUTS:  R5	NET UCB address.
;	    R4	Scratch
;	    R3	Local link number.
;	    R2	Disconnect reason code
;	    R1  Logical link's remote node address 
;-
DISC_ONE:				; Disconnect single logical-link
	BSBW	NET$XWB_LOCLNK		; Find the logical link XWB
	MOVZWL	S^#SS$_BADPARAM,R0	; Assume no such link exists
	BLBS	R5,120$			; If LBS then XWB was not found
	TSTW	XWB$W_REMNOD(R5)	; Remote node 0?
	BEQL	100$			; If so, ignore node check
	CMPW	R1,XWB$W_REMNOD(R5)	; Same remote node ?
	BNEQ	120$			; If not, return error
100$:	BSBW	180$			; Disconnect the link
	MOVL	S^#SS$_NORMAL,R0	; Success
120$:	RSB

;+
;  ABORT_ALL -  Abort all logical-links
;
;  INPUTS:  R5	NET UCB address
;	    R4	Scratch
;	    R3	Scratch
;	    R2	Scratch
;	    R1  Ptr to LTB
;
;-
ABORT_ALL:				; Abort all logical-links
	MOVAL	-XWB$L_LINK -		;
		+LTB$L_XWB(R1),R5	; Prepare for scan
140$:	MOVL	XWB$L_LINK(R5),R5	; Get next XWB
	BEQL	160$			; If NEQ then got one
	MOVW	#NET$C_DR_THIRD,R2	; Reason is "third party abort"
	BSBW	180$			; Mark link to be broken
	BRB	140$			; Loop
160$:	MOVL	S^#SS$_NORMAL,R0	; Success
	RSB


;
;  Disconnect the link
;
180$:	MOVW	R2,XWB$W_REASON(R5)	; Enter disconnect reason
	BSBW	NET$MARK_LINK		; Mark the link to be broken
	MOVQ	(R10),R0		; Restore R0,R1,R2
	MOVL	8(R10),R2
	RSB

;
;  Find XWB, verify access rights by PID
;
200$:	BSBW	NET$XWB_LOCLNK		; Find XWB via local link number
	TSTB	#1			; Clear Z-bit, assuming error
	BLBS	R5,220$			; If LBS then no XWB
210$:	CMPL	R0,XWB$L_PID(R5)	; Is the process the owner ? 
	BNEQ	220$			; If NEQ then no
	CMPB	#XWB$C_STA_CIR,-	;
		XWB$B_STA(R5) 		; Verify state
220$:	RSB


;+
;  BRDCST   -   Broadcast a mailbox message
;
;  INPUTS:  R5	NET UCB address
;	    R4	Ptr to mailbox msg text
;	    R3	Associated mailbox mask (0 if broadcast to all mailboxes)
;	    R2	Mailbox msg code
;	    R1  Scratch
;
;-
BRDCST:					; Broadcast mailbox message
	;
	; & Code to set up R3 here will move to NETACP, eventually
	;
	MOVAB	MBX_TABLE,R8		; Point to filter mapping table
300$:	MOVL	(R8)+,R3		; Get next mask
	BEQL	320$			; If EQL at end of table - take the msg
	CMPW	(R8)+,R2		; Is this the msg being sent?
	BNEQ	300$			; If NEQ no - loop; else, R3 has bit
320$:	MOVL	R2,R8			; Transfer msg type code
	PUSHL	#0			; Assume no message text
	MOVL	SP,R7			; Point to it
	TSTL	R4			; Any message text?
	BEQL	400$			; If EQL no, goto end of loop
	MOVZBL	(R4),R2			; Get count field value
	INCL	R2			; Inc to get total string size
	MOVL	R4,R7			; Setup stable string pointer
	BRB	400$			; Jump to end of loop
	
340$:	TSTL	R3			; Will everyone take this message?
	BEQL	360$			; If EQL yes
	BITL	R3,UCB$L_DEVDEPEND(R5)	; Can this UCB take this message?
	BEQL	400$			; If EQL no - don't even try to send
360$:	PUSHR	#^M<R2,R3,R5>		; Save regs
	BSBW	NET$SEND_MBX		; Call co-routine to setup the message
	BLBC	R0,380$			; If LBC then error
	MOVL	R7,R1			; Get message pointer
	BSBW	NET$MOV_CS_MSG		; Move the string
	JSB	@(SP)+			; Complete the message
380$:	POPR	#^M<R2,R3,R5>		; Recover regs
400$:	MOVL	UCB$L_LINK(R5),R5	; Get next UCB
	BNEQ	340$			; If NEQ then got one
	TSTL	(SP)+			; Fix the stack
	MOVL	S^#SS$_NORMAL,R0	; Exit with success
	RSB


;+
;  REPLY    -   Send general message to assocaited mailbox
;
;  INPUTS:  R5	NET UCB address
;	    R4	Ptr to mailbox msg text  
;	    R3	& Associated mailbox mask if NETUPD$_BRDCST (0 if broadcast all)
;	    R2	Mailbox msg code
;	    R1  Scratch
;
;-
REPLY:	MOVL	R2,R8			; Get mailbox message code
	BRB 	500$			; Continue in common

;+
;  DECLARE  -   Pass NCB to Declared-name mailbox
;
;  INPUTS:  R5	NET UCB address
;	    R4	Ptr to NCB counted string
;	    R3	Scratch
;	    R2	Scratch
;	    R1  Scracth
;
;-
DECLARE:				; Pass NCB to declare-object mailbox
	BSBW	NET$XWB_LOCLNK		; Find link's XWB
	BLBS	R5,560$			; Br if no XWB 
	CMPB	#XWB$C_STA_CIR,-	; Must be in CIR state
		XWB$B_STA(R5)		;
	BNEQ	560$			; If not then cannot redirect connect
	MOVL	R1,XWB$L_PID(R5)	; Set PID of process
	MOVZWL	#MSG$_CONNECT,R8	; Setup mailbox message type 
500$:	MOVQ	R4_OFF(R10),R4		; Get mbx message and UCB addresses
	MOVL	R4,R2			; Copy msg pointer
	BEQL	520$			; If EQL then no text
	MOVZBL	(R2),R2			; Set count of bytes to be sent
520$:	BSBW	NET$SEND_MBX		; Prepare to send mailbox message
	BLBC	R0,580$			; Br on error
	MOVL	R4,R1			; Copy NCB pointer
	BEQL	540$			; Skip if null
	BSBW	NET$MOV_CS_MSG		; Move counted string into buffer
540$:	JSB	@(SP)+			; Complete writing mailbox
560$:	MOVL	S^#SS$_NORMAL,R0	; Success
580$:	RSB				; Done


;+
;  DLLTRN   -   Datalink state transition
;
;  INPUTS:  R5	NET UCB address
;	    R4	Scratch
;	    R3	Scratch
;	    R2	Scratch
;	    R1  Ptr to datalink's LPD
;
;-
DLLTRN:	MOVL	UCB$L_VCB(R5),R2	; Get RCB
	CMPL	R1,RCB$L_LOC_LPD(R2)	; Is this the local LPD
	BNEQ	610$			; If not, branch
					;
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save regs
	MOVL	R5,R3			; Copy UCB address
	MOVL	RCB$L_PTR_TQE(R2),R5	; Get TQE
	BBS	#TQE$V_REPEAT,-		; Br if timer is in use
		TQE$B_RQTYPE(R5),600$	;
	MOVB	#TQE$C_SSREPT,-		; Set for system subroutine repeat
		TQE$B_RQTYPE(R5)	;
	MOVAB	W^NET$TIMER,-		; Set timer handler address
		TQE$L_FPC(R5)		;
	MOVL	R3,TQE$L_FR4(R5)	; Save UCB address
	MOVQ	#10*1000*1000,-		; 1 tick = 1 sec
		TQE$Q_DELTA(R5)		;
	MOVQ	G^EXE$GQ_SYSTIME,R0	; Set time of first tick
	DSBINT	#IPL$_TIMER		; Lower IPL to that of timer service
	JSB 	G^EXE$INSTIMQ		; Insert into queue
	ENBINT				; Restore IPL
600$:	POPR    #^M<R0,R1,R2,R3,R4,R5>	;
					;
610$:	BSBW	TR$UPDATE		; Fct code is in R0
	RSB				; Exit with status in R0

		.DSABL	LSB


;+
; NET$SEND_CS_MBX	- Send counted string to mailbox
;
; FUNCTIONAL DESCRIPTION
;
; A mailbox message is built and sent to the mailbox associated with 
; the UCB associated with the XWB.  The counted string pointed to by R1
; is appended to the end of the mailbox message.  R2 contains the
; assumed total count of the string and may be zero.  If there is
; no mailbox then the routine is assumed implicitly successful.
;
; INPUTS:   R8	Mailbox message type code
;	    R5	XWB address
;	    R2	Assumed total length of string (low byte only)
;	    R1	Address of count field of string
;
; OUTPUTS:  R2	Zero 
;	    R1	Garbage
;	    R0	SS$_NORMAL	if mailbox successfully written
;		SS$_NOMBX!1	if no associated mailbox or no UCB
;		Zero		if (R1)+1 NEQ R2  or  R2 GTRU 17
;
;	also see NET$SEND_MBX for R0 error codes
;
;	All other registers are preserved
;-
NET$SEND_CS_MBX:
	PUSHR	#^M<R1,R2,R3,R4,R5>	; Save regs
	MOVZBL	R2,R2			; Zero garbage bytes
	BNEQ	10$			; Br unless no string
	MOVAB	B^50$,(SP)		; Indicate 'no counted string'
	BRB	20$			; Continue
10$:	CLRL	R0			; Assume string error
	SUBB3	(R1),R2,R1		; Check count field consistency
	DECB	R1			; Account for count field itself
	BNEQ	40$			; Inconsistent if NEQ
	CMPL	R2,#17			; Is count within range
	BGTRU	40$			; If not, branch
20$:	MOVZWL	#SS$_NOMBX!1,R0		; Assume no UCB or mailbox
	MOVL	XWB$L_ORGUCB(R5),R5	; Get UCB
	BEQL	40$			; If none, done
	TSTL	UCB$L_AMB(R5)		; Is there a mailbox ?
	BEQL	40$			; If not, branch
	BSBW	NET$SEND_MBX		; Build header (co-routine)
	BLBC	R0,40$			; Br on error
	MOVL	4(SP),R1		; Get string address (note stack)
	BSBW	NET$MOV_CS_MSG		; Move string to message
	JSB	@(SP)+			; Close and send mbx message
40$:	POPR	#^M<R1,R2,R3,R4,R5>	; Recover regs
	CLRL	R2			; String has been consumed
	RSB

50$:	.BYTE	0			; Phony counted string for mailbox

;+
; NET$SEND_MBX	- Co-routine to send mailbox message
;
; FUNCTIONAL DESCRIPTION
;
; The first time the routine is entered the associated mailbox is
; found, a buffer is allocated for the message, and the mailbox header
; is built.  When the routine is re-entered, after a call to the
; co-routine, the message is closed and sent to the mailbox.
;
; The original entry parameters are given below, the re-entry
; parameters are given within the body of the code.
;
; INPUTS:   R8	Mailbox message type code
;	    R5	UCB address
;	    R3	Scratch
;	    R2	Count of bytes co-routine will enter into message
;	    R1	Scratch
;	    R0	Scratch
;
; OUTPUTS:  R3	Pointer to next byte in mailbox message to be filled
;	    R2	Address of allocated buffer if R0=SS$_NORMAL
;	    R1	Garbage
;	    R0	SS$_NORMAL  if successful
;		SS$_NOMBX   if there's no associated mailbox
;
;		see NET$ALONONPAGED for additional error status
;
;	    All other registers are preserved
;-
NET$SEND_MBX:
	MOVL	UCB$L_DDB(R5),R0	; DDB pointer
	MOVAB	DDB$T_NAME(R0),R1	; Get device name string ptr
	PUSHL	R1			; Save it 
	MOVZBL	(R1),R1			; Get string size
	ADDL	#24,R1			; Make sure buffer is large
					; enough for COM$DRVDEALMEM to
					; deallocate -- also creates
					; space for:
					; 12 byte standard buffer header
					;  2 byte msg type code
					;  2 byte unit number
					;  1 byte count field for
					;    device name
	ADDL	R2,R1			; Add in bytes caller will enter
	BSBW	NET$ALONONPAGED		; Get the buffer
	BLBS	R0,10$			; Br on error
	TSTL	(SP)+			; Cleanup stack
	RSB

10$:	ADDL3	#12,R2,R3		; Get pointer to start of msg
	MOVW	R8,(R3)+		; Enter message type code
	MOVW	UCB$W_UNIT(R5),(R3)+	; Enter unit I.D.
	POPL	R1			; Get device name string ptr
	BSBW	NET$MOV_CS_MSG		; Move in device name
	MOVL	S^#SS$_NORMAL,R0	; Indicate success
	JSB	@(SP)+			; Call co-routine for more bytes
					; Note that R4 is unmodified
	;
	; On coroutine return:	R5 = UCB address
	;			R3 = address of 1st byte past mbx msg
	;			R2 = buffer address
	;
	; On return to caller:	R0 = EXE$WRITEMBX status
	;			R1-R5 are garbage
	;
	ADDL3	#12,R2,R4		; Get start of mbx message
	SUBL	R4,R3			; Get length of mbx message
	MOVZWL	#SS$_NOMBX,R0		; Assume no mailbox
	MOVL	UCB$L_AMB(R5),R5	; Get mailbox
	BEQL	20$			; If EQL then no mailbox
	JSB	G^EXE$WRTMAILBOX	; Send message to mailbox
20$:	PUSHL	R0			; Save return status
	SUBL3	#12,R4,R0		; Get buffer address
	JSB	G^COM$DRVDEALMEM	; Deallocate buffer
	POPR	#^M<R0>			; Restore regs
	RSB

	.SBTTL	NET$CREATE_XWB	- Create XWB for logical link

;++
; NET$CREATE_XWB	- Build a new Extended Connect Block
;
; FUNCTION DESCRIPTION
;
; An XWB, which is a logical link port control structure which will 
; eventually be attached to a UCB, is allocated, initialized, and
; associated with an available link slot.  If no link slots are
; available the routine; aborts without allocating the XWB.
;
; INPUTS:
;
;	R5	Address of the ACP's NET UCB
;	R3	Remote node address
;
; OUTPUTS:
;
;	R5	Address of XWB if successful, otherwise LBS
;	R3	Garbage
;
;	All other registers are preserved
;
; SIDE EFFECTS:
;
;	The link sequence number for the slot is updated
;
;	The RCB mount count is incremented.
;--

;
;	The slot vector terminates with a -1 (longword) followed by
;	a 0 (longword).
;
SCAN_SLOTS:				; Scan for available slot
	BLBC	(R4)+,SCAN_SLOTS	; LBC means unavailable
	CMPL	-(R4),#-1		; Backup and test for end of
	RSB				;  slot vector marker

NET$CREATE_XWB:				; Get idle XWB
	PUSHR	#^M<R1,R2,R3,R4>	; Save regs to be used
	MOVZWL	#SS$_NOLINKS,R0		; Assume failure
	MOVL	UCB$L_VCB(R5),R5	; Get VCB address
	BEQL	12$			; Br if no VCB
	MOVL	RCB$L_PTR_LTB(R5),R3	; Get LTB
	BEQL	12$			; No links if no LTB
	CMPW	RCB$W_MCOUNT(R5),-	; Is new link allowed ?
		RCB$W_MAX_LNK(R5)	; (MCOUNT = current links + 1)
	BGTRU	12$			; If not, branch 
	MOVL	LTB$L_SLT_NXT(R3),R4	; Get first slot candidate ptr
	BSBB	SCAN_SLOTS		; Search for available slot
	BNEQ	10$			; NEQ means slot found
	MOVAL	LTB$L_SLOTS(R3),R4	; Start from top of vector
	BSBB	SCAN_SLOTS		; Continue search
	BEQL	12$			; EQL means slot not found

	ASSUME	XWB$C_RUNLNG LE XWB$C_CONLNG

10$:	MOVZWL	#XWB$C_CONLNG,R1	; Get size of XWB
	BSBW	NET$ALONPG_Z		; Allocate/zero system non-paged buffer
	BLBS	R0,15$			; Br if successful
12$:	BUMP	W,RCB$W_CNT_XRE(R5)	; Account for resource error
	BISB	#1,R5			; Invalidate ptr
	BRW	40$			; Done

15$:	MOVB	S^#DYN$C_NDB,XWB$B_TYPE(R2) ;& Setup structure type
	MOVW	RCB$W_ECLSEGSIZ(R5),-
		    XWB$W_REMSIZ(R2)	; Setup temporary 'seg' size
	;
	;    Initialize XWB as if it were allocated in response to a 
	;    received Connect Initiate message
	;
	ASSUME	XWB$C_STA_CLO	EQ 0	; Zeroing the block setup initial state
	ASSUME	NET$C_DR_NORMAL EQ 0	; And XWB$W_REASON
					;
	ADDW3	#1,RCB$W_TIM_CNI(R5),-	; Setup inbound connect interval timer
		    XWB$W_TIMER(R2)	; (the #1 is for possible clock skew)
	MOVW	#XWB$M_FLG_CLO,-	; Init FLG bits
		    XWB$W_FLG(R2)	;
	ADDW3	#NET$C_MAXLNK+1,2(R4),-	; Update the local link sequence
		    XWB$W_LOCLNK(R2)	; number
	MOVB	#NET$C_IPL,XWB$B_FIPL(R2) ; Setup fork IPL
	MOVL	R5,XWB$L_VCB(R2)	; Setup RCB pointer
	INCW	RCB$W_MCOUNT(R5)	; Account for used link slot
	CMPW	RCB$W_MCOUNT(R5),-	; New max active links value?
		    RCB$W_CNT_MLL(R5)	;
	BLEQU	30$			; If LEQU then no
	INCW	RCB$W_CNT_MLL(R5)	; Bump max active link count
30$:	MOVL	R2,(R4)+		; Store XWB ptr in this slot
	MOVL	R4,LTB$L_SLT_NXT(R3)	; Store scan's next starting pt.
	;
	;   Insert XWB into linked list based in the order of the remote node
	;   address (high order word) followed by the link index.
	;
	MOVL	R2,R5			; Switch to XWB context
	MOVAB	LTB$L_XWB-XWB$L_LINK(R3),R0 ; Prepare for scan
	POPR	#^M<R1,R2,R3,R4>	; Restore regs

	PUSHL	R2			; Save a reg
	MOVW	R3,XWB$W_REMNOD(R5)	; Store remote node address
	MOVW	R3,-(SP)		; Remote node address into high word
	BICW3	#^C<NET$M_MAXLNKMSK>,-	; Store link index in low order word
		XWB$W_LOCLNK(R5),-(SP)	;
	MOVL	(SP)+,R2		; Get collating value
35$:	MOVL	R0,R3			; Advance R3
	MOVL	XWB$L_LINK(R3),R0	; Get next XWB
	BEQL	37$			; If EQL then none left
	MOVW	XWB$W_REMNOD(R0),-(SP)	; Store remote node address in low order
	BICW3	#^C<NET$M_MAXLNKMSK>,-	; Store link index in low order word
		XWB$W_LOCLNK(R0),-(SP)	;
	CMPL	R2,(SP)+		; Compare 
	BGEQU	35$			; If GEQU try next XWB
37$:	MOVL	R0,XWB$L_LINK(R5)	; Link tail of list ot current XWB
	MOVL	R5,XWB$L_LINK(R3)	; Link XWB to head of list
	POPL	R2			; Restore reg
	MOVB	#1,R0			; Set success status
	RSB				; Done

40$:	POPR	#^M<R1,R2,R3,R4>	; Restore regs
	RSB


	.SBTTL	NET$XWB_LOCLNK	- Get XWB via local link number
;++
; NET$XWB_LOCLNK	- Get XWB associated with link number
;
; FUNCTIONAL DESCRIPTION
;
; The Link Table is located and the slot associated with the specified
; link number is found.  If this slot contains an XWB then the link
; sequence number is checked.  If there is a sequence number mismatch,
; or if there is no active XWB, then the low bit of R5 is set.  Else,
; the XWB address is stored in R5.
;
; INPUTS:
;
;	R5	Any NET UCB address
;	R4	Scratch
;	R3	Local link number - high order word is clear
;
; OUTPUTS:
;
;	R5	Address of associated XWB, or low bit set if none
;	R4	LTB (link table) address
;
;	All other registers are preserved.
;--
			.ENABL	LSB
NET$XWB_LOCLNK:				; Get XWB context
	MOVL	UCB$L_VCB(R5),R4	; Get RCB address
	BEQL	10$			; If EQL then not mounted
NET$XWB_LOCLNK1:
	MOVL	RCB$L_PTR_LTB(R4),R4	; Get Link Table pointer
	BEQL	10$			; Return error if not there
	BICL3	#^C<NET$C_MAXLNK>,R3,R5	; Get link 'index'
	BEQL	10$			; Index '0' isn't used
	CMPW	R5,LTB$W_SLT_TOT(R4)	; Index within range ?
	BGTRU	10$			; If not, branch
	MOVL	LTB$L_SLOTS(R4)[R5],R5	; Get XWB address
	BLBS	R5,20$			; If LBS then none
	CMPW	R3,XWB$W_LOCLNK(R5)	; Sequence number match ?
	BEQL	20$			; If so, branch
10$:	BISB	#1,R5			; Flag no associated XWB
20$:	RSB
			.DSABL	LSB

	.SBTTL	NET$RET_SLOT	- Return logical link XWB slot
;++
; NET$RET_SLOT	- Return logical link slot
;
; FUNCTIONAL DESCRIPTION
;
; The local link address stored in the XWB is used to locate the logical link
; slot to be freed.  The slot is freed by setting its low order bit.  The local
; link address associated with the slot is stored in its high order word.
;
; If the XWB is busy then the deallocation attempt is aborted.  If the XWB is 
; not busy then it is forked to IPL$_QUEUEAST and the XWB$V_STS_SOL bit is set 
; to prevent any further XWB use.
;
; INPUTS:   	R5	XWB pointer
;
; OUTPUTS:  	R0,R1	Zero
;
;		All other registers are preserved.
;
; SIDE EFFECTS:
;		The RCB mount count is decremented.
;
;--
NET$RET_SLOT:				; Return logical link slot
	TSTW	XWB$W_REFCNT(R5)	; Any references ?
	BNEQ	40$			; If so, branch
	MOVL	XWB$L_DI_CXB(R5),R0	; Is there a disconnect CXB?
	BEQL	10$			; If EQL then no
	CLRL	XWB$L_DI_CXB(R5)	; Remove it
	JSB	G^COM$DRVDEALMEM	; Deallocate it

10$:	ASSUME	XWB$C_STA_CLO	EQ 0

	TSTB	XWB$B_STA(R5)		; In 'closed' state?
	BEQL	20$			; If EQL yes
	CMPB	#XWB$C_STA_DIR,-	; In 'DI received' state?
		    XWB$B_STA(R5)	;
	BNEQ	40$			; If not, exit

20$:	ASSUME	XWB$V_FLG_LOCK EQ 0

	BLBS	XWB$W_FLG(R5),40$	; Exit if XWB is locked
	BBSS	#XWB$V_STS_SOL,-	; Br if soliciting or forking
		    XWB$W_STS(R5),40$	;  - set the STS_SOL bit
	;
	;    The XWB may be deallocated
	;
	PUSHR	#^M<R2,R3,R4,R5>	; Save regs
	BSBB	RET			; Fork to avoid race on XWB 
	POPR	#^M<R2,R3,R4,R5>	; Restore regs
40$:	CLRQ	R0			; Say "nothing to xmit"
	RSB				; done

RET:	ASSUME	IPL$_QUEUEAST  LE  NET$C_IPL
	MOVAQ	XWB$Q_FORK(R5),R5	; Switch to fork context
	MOVB	#IPL$_QUEUEAST,11(R5)	; Setup fork IPL
	JSB	G^EXE$FORK		; Fork
	MOVAQ	-XWB$Q_FORK(R5),R5	; We're back, address XWB
	DSBINT	#IPL$_SYNCH		; Raise to SCH$WAKE's IPL
	MOVL	XWB$L_VCB(R5),R2	; Get RCB
	INCW	RCB$W_TRANS(R2)		; Account for ACP transaction
	MOVL	RCB$L_AQB(R2),R4	; Get AQB
	INSQUE	(R5),@4(R4)		; Queue XWB to AQB
	BNEQ	10$			; If NEQ then not first
	MOVL	AQB$L_ACPPID(R4),R1	; Get ACP's PID
	JSB	G^SCH$WAKE		; Wake the ACP
10$:	ENBINT				; Restore IPL
	RSB				; Done

	.SBTTL	NET$ALONONPAGED	- Allocate from system pool
;++
; NET$ALONPG_Z		- Allocate and zero system non-paged buffer
; NET$ALONONPAGED	- Allocate buffer from system non-paged pool
;
; FUNCTIONAL DESCRIPTION
;
; A buffer is allocated from non-paged pool and its size field is setup.
;
; INPUTS:   R2 = Scratch
;	    R1 = Size, in bytes, of block to be allocated
;	    R0 = Scratch
;
; OUTPUTS:  R2 = Address of block if successful
;		 Zero if unsuccessful
;	    R0 = Standard VMS status code
;
;	    All other registers are preserved.
;--
		.ENABL	LSB
NET$ALONPG_Z::				; Allocate and zero non-paged buffer
	BSBB	NET$ALONONPAGED		; Allocate the buffer
	BLBC	R0,10$			; If LBC then error
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save regs
	MOVC5	#0,(SP),#0,R1,(R2)	; Zero the entire buffer
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore regs
	BRB	5$			; Setup the type and size fields (again)

NET$ALONONPAGED:			; Allocate non-paged memory
	PUSHR	#^M<R1,R3>		; Save regs
	JSB	G^EXE$ALONONPAGED	; Allocate memory
	POPR	#^M<R1,R3>		; Restore regs
	BLBS	R0,5$			; If LBS then success
	CLRL	R2			; Zero the buffer pointer
	BRB	10$			; Take common exit
5$:	MOVW	R1,UCB$W_SIZE(R2)	; Set size for deallocation
	MOVB	S^#DYN$C_CXB,-		;
		     UCB$B_TYPE(R2)	; Set tentative buffer type
10$:	RSB				; Return with status in R0

		.DSABL	LSB


;++
;
; <0eb0 0000><4b_LINK>{2b_ACK}<2b_SEG><DATA>			DATA MSG
; <0011 0000><4b_LINK>{2b_ACK}<2b_SEG><u16_DATA>		INT. MSG
; <0001 0000><4b_LINK>{2b_ACK}<2b_SEG><2b_FLOW>			L.S. MSG
;
; <0000 0100><4b_LINK><2b_ACK>					DATA ACK
; <0001 0100><4b_LINK><2b_ACK>					OTH. ACK
; <0010 0100><2b_DST>						CA
;
; <0001 1000><2k_0><2b_SRC><1b_SRV><1b_INFO><2b_SEGSIZ><CTL>	CI
; <0010 1000><4b_LINK><1b_SRV><1b_INFO><2b_SEGSIZ><i16_DATA>	CC
; <0011 1000><4b_LINK><2b_REA><i16_DATA>			DI
; <0100 1000><4b_LINK><2b_REA>					DC
; <0100 1000><2b_DST><2k_0><2k_1>				CT
; <0100 1000><4b_LINK><2k_42>					DT
; <0100 1000><4b_LINK><2k_41>					NLT
;
; <0101 1000>------						START
;
; <4b_LINK>   ::=  <2b_DST><2b_SRC>  		link address, not = 0
; <2b_ACK>    ::=  <1001><12 bit seg number>	if NAK
;		   <1000><12 bit seg number>	if ACK
; <2b_SEG>    ::=  <0000><12 bit seg number>
; <2b_FLOW>   ::=  <00000><1 bit subchannel><2 bit mode><1 byte count>
;			   0 => data	     00 => no change
;			   1 => interrupt    01 => stop
;					     10 => start
;
; <1b_SRV>    ::=  <00000001>			if no flow control
;		   <00000101> 			if segment flow control
;		   <00001001>			if message flow control
; <1b_INFO>   ::=  <00000001>			if NSP V3.1
;		   <00000000>			if NSP V3.2
;
;
; <CTL>	      ::=  <DNAME><SNAME><000000da><ACCOUNT><i16_DATA>
;					     if a      if d 
;		    <DNAME> ::= <NAME>
;		    <SNAME> ::= <NAME>
;		    <NAME>  ::= <1k_0><1b_objtyp>  objtyp not= 0
;				<1k_1><1k_0><i16_desc>
;				<1k_2><1k_0><2b_gcod><2b_ucod><i12_desc>
;		    <ACCT>  ::= <i39_id><i39_psw><i39_acc>
;
;
;--

;
; The DATA subchannel transmitter is either message, segment, or null
; flowed controlled by the remote receiver.  For details consult the
; NSP Functional Spec.  Briefly, the rules are as follows:
;
; - Null Flow Control
;
;   There is no flow control.  Backpressure is the only way that the
;   receiver can force the transmitter to stop transmitting.
;
; - Message Flow Control
;
;   The receive increments the flow control variable once for each
;   message which it may receive.   It may never decrement it.  This
;   value must never exceed 127.
;
; - Segment Flow Control
;
;   The adds the flow control value to the current flow control 
;   variable, this may increment it (not past 127) or decrement it (not
;   below zero).
;
;
; Managing DATA Transmission Control Variables
;
; To control the xmitter, the following parameters are defined.  Each
; is a signed 12 bit number referring to an NSP message sequence number.
; Since NSP may not "pipeline" more than 2098 messages on any given
; subchannel, sequence number A is less than sequence number B if 
; B-A < 2098 (mod 4096).  The logic of the routines which manipulate
; them is outlined below.
;
;   LSB$W_HAR		Number of highest ack received.
;
;   LSB$W_HXS		Number of highest segment available and allowed
;			to be sent.  This value is computed differently
;			according to the type of flow control used.
;
;   LSB$W_HNX		Number of highest segment sent.
;
;   LSB$W_LNX		Number of last segment sent.
;
;   LSB$W_LUX		Number of last segment assigned.  It is equal
;			to the final segment number of the message of 
;			the last IRP in the LSB$Q_XMT queue.
;
;   LSB$B_XMTS		The number of IRPs on the LSB$Q_XMT queue.
;
;   LSB$B_XREQ		The number of outstanding messages or segments 
;			requested by the remote receiver.  These may or
;			may not have been transmitted.  The manner in 
;			which this variable is modified is dependent 
;			upon the type of flow control used.

;+
; NET$ENT_RUN	- Enter the RUN state
;
; FUNCTIONAL DESCRIPTION:
;
; This routine is entered to setup the XWB for entering the RUN state.
;
; INPUTS:   R7	Event code  - it will be reprocessed via the complex event
;			      mechanism.  Note that the state should have
;			      been updated by then.
;	    R5	XWB address
;	    R0	Scratch
;
; OUTPUTS:  R0 garbage
;
;	    All other registers are preserved.
;-
	ASSUME	  LSB$C_LENGTH		 	EQ 24
	ASSUME	  LSB$Q_XMT			EQ  0

	ASSUME	< XWB$T_DT - XWB$Q_DT_RCV >	EQ 20
	ASSUME	< XWB$T_LI - XWB$T_DT >		EQ 24

	;& need more assumes for those values following _DT_RCV

NET$ENT_RUN:				; Enter RUN state
	PUSHL	R1			; Save reg
	MOVL	S^#SS$_NORMAL,R0	; Set status
	BSBW	NET$CMPL_ACC		; Complete the access QIO
	POPL	R1			; Restore reg
	BISW   #XWB$M_FLG_SDT!-		; Always set while in RUN state
		XWB$M_FLG_WHGL!-	; nothing to send yet
		XWB$M_FLG_SDACK,-	; cause remote to enter RUN
		XWB$W_FLG(R5)
	BISW   #XWB$M_STS_SDFL!-	;  schedule DATA flw ctl msg
-;		XWB$M_STS_SIFL!-	;  INT  flow control msg
-;					;  is implicit upon connect
		XWB$M_STS_RUN,-		; Indicate XWB fields are used
-;					; in the RUN format
		XWB$W_STS(R5)		; Set pertinent STS bits
	MOVW	XWB$W_RETRAN(R5),-	; Init PROGRESS
		XWB$W_PROGRESS(R5)	;
	BSBW	SET_TIMER		; Setup the timer
30$:	MOVAL	XWB$Q_DT_RCV(R5),R0	; Get base reg
	BSBB	50$			; Setup queue header and zero
					; misc. variables
	MOVAB	XWB$T_DT(R5),R0		; Setup DT LSB ptr
	BSBB	50$			; Init the DATA LSB
	MOVAB	XWB$T_LI(R5),R0		; Setup LI LSB ptr
	BSBB	50$			; Init the LI LSB
	CLRB	XWB$B_INC_RFLW(R5)	; Init request count assuming Phase II
	;
	;
	;   If NSP version is V3.1 then partner is Phase II and
	;   pipelining is disabled.
	;
	;
	BICW3	#^C<XWB$M_STS_VER>,-	; Get the NSP version
		XWB$W_STS(R5),R0	;
	CMPW	R0,#NSP$C_VER_V31	; Is it V3.1?
	BEQL	40$			; If EQL yes, Phase II
	MOVL	XWB$L_VCB(R5),R0	; Get RCB
	MOVB	RCB$B_ECL_RFLW(R0),R0	; Initialize the receive pipeline value
	BLEQ	40$			; If LEQ then illegal
	MOVB	R0,XWB$B_INC_RFLW(R5)	;
40$:	MOVB	XWB$B_INC_RFLW(R5),-	; Setup intial request count
		XWB$B_DT_RFLW(R5)	; 
	INCB	XWB$T_LI+LSB$B_XREQ(R5)	; 1 INT msg is implicitly flow
					; controlled upon entering RUN
	BRW	NET$CMPLX_EV		; Change state and process event


50$:	;
	;
	;    Init LSB
	;
	;
	ASSUME	LSB$C_LENGTH  EQ  24
	MOVL	R0,(R0)+		; Init xmt IRP listhead
	MOVL	-4(R0),(R0)+		;
	CLRQ	(R0)+			; Zero the remainder of the LSB
	CLRQ	(R0)+			;
	RSB				; Done

;+
; NET$RCV_DTACK	- DATA ACK message processing
; NET$RCV_LIACK - INT/LI ACK message processing
; NET$PIG_ACK	- Common piggy-backed ACK processing
;
; FUNCTIONAL DESCRIPTION
;
; If the ACK value is within range, the subchannel block is updated. For
; valid NAK's, the value of the 'last segment xmitted' is always updated
; since the remote node is requesting retransmissions.  The value of
; 'LNX' can be advanced, if possible, on ACKs since this would mean we
; are retransmitting unnecessarily.
;
; The ACK is completely processed.  A user IRP for DATA or INT message
; transmission may be completed as a result.  Note that 'piggy-backed'
; ACKs are considered completely independent from the remainder of
; the message in which they are carried.  Any errors encountered are
; logged if necessary, but the error is not reported to the calling
; routine.
;
; The current implementation always sends 'piggy-backed' ACKS when 
; sending DATA or INT/LS messages in the hope of minimizing the impact
; of the lost message environment offered by Transport.  The following
; code is optimized to exit with minimal processing in the expected 
; case that the ACK value has already been seen.  Optimization also
; considers NAKs to be rare events.
;
; INPUTS    R8 = Ptr to subchannel control block &wrong if DTACK
;	    R7 = Scratch
;	    R4 = Scatch
;	    R3 = ACK field value
;	    R2 = Number of bytes in message not yet accounted for
;	    R1 = If NET$RCV_ACK then ptr to ACK field in message
;		 Else pointer to SEG field following the ACK
;	    R0 = Scratch
;
; OUTPUTS   R8 = Preserved, block is updated
;	    R7 = Garbage
;	    R4 = Garbage
;	    R3 = If NET$RCV_ACK then garbage
;		 Else the value of SEG field following the ACK
;	    R2 = Decremented by 2 since piggy-backed ACK field is 
;	 	 optional and therefore had not yet been accounted for
;	    R1 = Advance by two bytes
;	    R0 = Garbage
;--
		.ENABL	LSB

NET$PIG_ACK:				; Common ACK processing
	SUBL	#2,R2			; Account for ACK field
	BLSS	20$			; If LSS then error
	BSBB	PROC_ACK		; Process the ACK
	MOVW	(R1)+,R3		; Get SEGNUM field
	RSB

20$:	;& log it
	TSTL	(SP)+			; Pop caller's address
	MOVZBL	#NSP$C_EV_PROERR,R7	; Setup new event
	MOVW	#NET$C_DR_PROTCL,-	; Setup disconnect reason
		XWB$W_REASON(R5)
	BRW	NET$PRE_EMPT		; Pre-empt with new event
	RSB

NET$RCV_DTACK:				; DATA ACK message processing
	MOVAB	XWB$T_DT(R5),R8		; Get LSB
	BRB	ACKK			; Continue
NET$RCV_LIACK:				; INT/LI ACK message processing
	MOVAB	XWB$T_LI(R5),R8		; Get LSB
ACKK:	MOVW	(R1)+,R3		; Get ACK field
PROC_ACK:				; Process ACK value
	EXTV	#0,#12,R3,R7		; Sign extend low order 12 bits
	SUBW3	LSB$W_HAR(R8),R7,R4	; Get distance to high ACK rcv'd
	EXTV	#0,#12,R4,R4		; MUST SIGN EXTEND
	BGTR	30$			; If GTR then its new
	BLSS	50$			; If LSS we saw this before
	BBC	#NSP$V_NAK,R3,50$	; If BC then not a NAK
30$:	;
	;
	;    If we've never sent the ACKed seg or if we're currently
	;    not allowed to have sent it then ignore the ACK.  Either case
	;    could occur if a very old message is finally arriving.  The
	;    latter case could occur due to a race in receiving flow
	;    control and ACK messages -- processing the ACK could lead to
	;    the condition HXS lss LNX and this could confuse NSP.
	;
	;
	SUBW3	R7,LSB$W_HXS(R8),R0	; Get distance to highest seg
					; we were allowed to send.
	BBS	#11,R0,40$		; Br if out of range
	SUBW3	R7,LSB$W_HNX(R8),R0	; Get distance to high seg sent
	BBC	#11,R0,60$		; If LSS we never sent it
40$:	;& eventually log it
50$:	RSB


60$:	;
	;
	;   The ACK value is 'legal', i.e, it can be processed. 
	;
	;
	MOVW	R7,LSB$W_HAR(R8)	; Move ACK into HAR
	SUBW3	R7,LSB$W_LNX(R8),R0	; Get distance from last seg sent
	BBS	#11,R0,70$		; If LSS we can advance it
	BBC	#NSP$V_NAK,R3,80$	; Always update LNX if legal NAK
70$:	MOVW	R7,LSB$W_LNX(R8)	; Store number of last seg rcv'd
80$:	;
	;
	;    See if timed segment has been ACK'd
	;
	;
	ASSUME	XWB$V_STS_TID  EQ 0
	BLBC	XWB$W_STS(R5),110$	; Br if timer is unowned by any segment
	SUBW3	XWB$W_TIM_ID(R5),R7,R0	; Get distance to segment owning timer
	BBS	#11,R0,110$		; If BS then owner seg # is larger
	BITW   #XWB$M_STS_TLI,-		; Set condition codes
		XWB$W_STS(R5)		;
	BBS    #NSP$V_LICH,-		; Br if msg is for INT/LS 
		XWB$B_MSGTYP(R5),90$	; channel
	BNEQ	110$			; If NEQ then LI channel
	BRB	100$			; This is the timed segment
90$:	BEQL	110$			; If EQL then not LI channel
100$:	BSBW	TIMED_SEG_ACKED		; Timed segment has been ACK'd, cleanup
					; and handoff timer if possible
110$:	;
	;
	;    If we've made it this far then either we've seen an NAK, or 
	;    some segments (number contained in R4) have been ACK'd, or both.
	;
	;
	MOVZBL	R4,R4			; Maximum value is 127
	BBS	#NSP$V_LICH,-		; Br if for LI subchannel
		 XWB$B_MSGTYP(R5),PROC_LIACK 

		.DSABL	LSB

;++
; PROC_DTACK	- Complete processing of DATA ACK
;
; FUNCTIONAL DESCRIPTION
;
; The DATA subchannel block is updated according to the ACK value
; received.  The DATA transmit IRP queue is scanned to update any
; IRPs affected by the ACK.  Any IRPs which have been completely
; ACK'd are posted for completion.
;
; INPUTS:   R8 = DATA subchannel (LSB) pointer
;	    R7 = New HAR value
;	    R5 = XWB pointer
;	    R4 = Number of 'new' ACKs received
;	    R3 = ACK field from message
;	    R0 = Scratch
;
; OUTPUTS:  R4 = Garbage
;	    R3 = Garbage
;	    R0 = Garbage
;
;	    All other preserved
;--
PROC_DTACK:				; DATA subchannel ACK processing
	BICW   #XWB$M_FLG_WHGL,-	; Assume something left to send
		XWB$W_FLG(R5)		;
	CMPW	LSB$W_LNX(R8),-		; Is there anything to send ?
		LSB$W_HXS(R8) 
	BNEQ	20$			; If so, branch
	BISW   #XWB$M_FLG_WHGL,-	; Else set wait condition
		XWB$W_FLG(R5)
20$:	BBC    #XWB$V_STS_SEGFL,-	; Br unless segment flow control
		XWB$W_STS(R5),30$
	SUBB	R4,LSB$B_XREQ(R8)	; Account for segments
	;
	; Determine if any new IRPs have been completely ACK'd.
	;
30$:	MOVL	LSB$Q_XMT(R8),R3	; Get first (if any) IRP
	MOVZBL	LSB$B_XMTS(R8),R4	; Get number of IRPs
	BEQL	60$			; Done if none
40$:	ASSUME	IRP$V_NET_INUSE EQ 0
	BLBC	IRP$B_NET(R3),50$	; Br if already done with IRP
	SUBW3	R7,IRP$W_X_FNX(R3),R0	; Does this ACK finish it ?
	EXTV	#0,#12,R0,R0		; MUST SIGN EXTEND
	BGTR	55$			; If not (FNX gtr ACK) exit loop
	BICB   #IRP$M_NET_INUSE,-	; NSP is done with IRP
		IRP$B_NET(R3)
50$:	MOVL	(R3),R3			; Get next IRP
	SOBGTR	R4,40$			; Loop
55$:	EXTV   #XWB$V_STS_MSGFL,#1,-	; Get flow control flag
		XWB$W_STS(R5),R0
	BSBW	NET$XMT_POST		; Post as many IRPs as possible
60$:	RSB

;++
; PROC_LIACK	- Return slots in the INT/LS xmit vector
;
; FUNCTIONAL DESCRIPTION
;
; The INT/LS subchannel state is updated according to the ACK value.
; As a result, slots in the INT/LS xmit vector may be freed.  Any
; Interrupt message which has been ACK'd is posted for completion
; and a new one is flow controlled if available.
;
; INPUTS:   R8 = INT/LS subchannel (LSB) pointer
;	    R7 = New HAR value
;	    R5 = XWB pointer
;	    R4 = Number of 'new' ACKs received
;	    R3 = ACK field from message
;	    R0 = Scratch
;
; OUTPUTS:  R4 = Garbage
;	    R3 = Garbage
;	    R0 = Garbage
;
;	    All other preserved
;--
PROC_LIACK:				    ; Process INT/LS ACKs
	BICW   #XWB$M_FLG_SLI,XWB$W_FLG(R5) ; Assume nothing to send
	CMPW	LSB$W_HXS(R8),LSB$W_LNX(R8) ; Anything to send ?
	BEQL	10$			    ; If not, branch
	BISW   #XWB$M_FLG_SLI,XWB$W_FLG(R5) ; Else flag 'send LI msg'
10$:	TSTB	R4			    ; Any new messages ACK'd ?
	BEQL	40$			; If not, branch
	SUBW	R4,R7			; Get old HAR value
20$:	INCB	R7			; Update to get next index
;&	BICL   #^C<7>,R7		; Get 'index' into xmit vector
	BICL   #^C<1>,R7		; Get 'index' into xmit vector
	BBSC	R7,XWB$B_LI_XMSK(R5),25$; Idle the slot
	BUG_CHECK NETNOSTATE,FATAL	; INT/LS slot flag already cleared
25$:	TSTW	XWB$T_LI_XVEC-1(R5)[R7]	; Was it an INTERRUPT message
					; - NOTE we are testing low byte
	BGEQ	30$			; If not loop
	MOVL	LSB$Q_XMT(R8),R3	; Get the IRP
	MOVL   #1,R0			; Flag flow control type
	BICB   #IRP$M_NET_INUSE,-	; Signal that we're done with
		IRP$B_NET(R3)		; IRP
	BSBW	NET$XMT_POST		; Post it
	TSTB	LSB$B_XMTS(R8)		; Any IRPs left ?
	BEQL	30$			; If not branch
	TSTB	LSB$B_XREQ(R8)		; Any INT msgs requested ?
	BEQL	30$			; If not branch
	BISW   #XWB$M_STS_IAVL,-	; Indicate INT msg needs to be
		XWB$W_STS(R5)		; built and sent
30$:	SOBGTR	R4,20$			; Loop for each ACK
40$:	RSB

	.SBTTL	NET$BLD_xx	- Routines to build NSP messages
;++
; NET$BLD_CI	- Build a CI msg from XWB contents
; NET$BLD_CA	- Build a CA msg from XWB contents
; NET$BLD_CC	_ Build a CC msg from XWB contents
; NET$BLD_DI	- Build a DI msg from XWB contents
; NET$BLD_DC	- Build A DC msg from XWB contents
;
; FUNCTIONAL DESCRIPTION
;
; The appropriate control message is contructed from the information
; in the XWB.
;
; INPUTS:   R10 NDC counter block address
;	    R8	Scratch
;	    R7	Scratch
;	    R6	Address of IRP to be used to send the message
;	    R5	XWB address
;	    R4	Scratch
;	    R3	Pointer to message being built
;	    R2	Scratch
;	    R1	Scratch
;	    R0	Scratch
;
; OUTPUTS:  R10 NDC counter block address
;	    R8	Garbage
;	    R7	Garbage
;	    R6	Preserved
;	    R5	Preserved
;	    R4	Garbage
;	    R3	Pointer to first byte beyond the message
;	    R2	Garbage
;	    R1	Number of user bytes entered into message
;	    R0	LBS if a message was constucted
;		LBC otherwise
;
;-
	.ENABL	LSB

	ASSUME	< XWB$W_LOCLNK - XWB$W_REMLNK > EQ 2

NET$BLD_CI:				; Build CI from XWB/ICB
	MOVB	#NSP$C_MSG_CI,(R3)+	; Enter msg type
	BSBB	COM_BLD_CON		; Execute common code
	MOVAB	XWB$B_RPRNAM(R5),R1	; Get dst process name address
	BSBW	NET$MOV_US_MSG		; Move uncounted string to msg
	MOVAB	XWB$B_LPRNAM(R5),R1	; Get src process name address
	BSBW	NET$MOV_US_MSG		; Move it to msg
	PUSHL	R3			; Save current output ptr
	CLRB	(R3)+			; Assume no data or access info
	MOVAB	XWB$B_LOGIN(R5),R1	; Point to access info strings
	TSTB	(R1)			; Are access strings null ?
	BEQL	10$			; If EQL then null
	MOVB	#1,@(SP)		; Flag 'access info present'
	BSBW	NET$MOV_US_MSG		; Move it as an uncounted string
10$:	BISB	#2,@(SP)+		; Flag 'data present' - it may be null
	BUMP	W,NDC$W_CSN(R10)	; Update "connects sent"
	BRB	30$			; Continue in common

NET$BLD_CC:				; Build CC from XWB
	MOVB	#NSP$C_MSG_CC,(R3)+	; Setup message type
	BSBB	COM_BLD_CON		; Build common connect header
	BRB	30$			; Move user data

COM_BLD_CON:				; Common build connect header
	MOVL	XWB$W_REMLNK(R5),(R3)+	; Enter dst,src link addresses
					;
	MOVW	#<NSP$C_SERVICE!-	; Enter SERVICE field bit,
		  NSP$C_VER_V32!-	;   indicate Version 3.2
		  NSP$M_SEGFL>,(R3)+	;   "segment flow control" 
	MOVW	XWB$W_LOCSIZ(R5),(R3)+	; Enter rcv segment size
	RSB
	
NET$BLD_CA:				; Build CA from XWB contents
	MOVB	#NSP$C_MSG_CA,(R3)+	; Enter msg typ
	MOVW	XWB$W_REMLNK(R5),(R3)+	; Enter dst link address
	BRB	25$			; Take "no data" exit

NET$BLD_DC:				; Build DC msg
	MOVB	#NSP$C_MSG_DC,(R3)+	; Enter msg type
	MOVL	XWB$W_REMLNK(R5),(R3)+	; Enter dst,src link addresses
	MOVW	XWB$W_REASON(R5),(R3)+	; Enter disconnect reason
25$:	CLRL	R1			; No user data
	BRB	50$			; Exit in common

NET$BLD_DI:				; Build DI from XWB
	MOVB	#NSP$C_MSG_DI,(R3)+	; Enter msg type
	MOVL	XWB$W_REMLNK(R5),(R3)+	; Enter dst,src link addresses
	MOVW	XWB$W_REASON(R5),(R3)+	; Enter disconnect reason
	BSBW	SET_TIMER		; Set timer 
30$:	MOVAB	XWB$B_DATA(R5),R1	; Setup user data address
	BSBW	NET$MOV_CS_MSG		; Move data as a counted string
	MOVZBL	XWB$B_DATA(R5),R1	; Get number of user bytes
50$:	MOVL	#1,R0			; Indicate that msg was built
	RSB

	.DSABL	LSB

;+
; NET$BLD_LIACK	- Build a INT/LS ACK message
; NET$BLD_DTACK	- Build a DATA ACK message
; NET$BLD_LI	- Build INT/LS message
; NET$BLD_DAT	- Build DATA message
;
; FUNCTIONAL DESCRIPTION
;
; The appropriate message is built.  If the message to be built is an
; ACK and XWB$W_STS indicates that there is a message which may be 
; sent on the subchannel then the ACK is sent 'piggy-backed' within 
; that message -- otherwise, an ACK message is built and sent.  Messages
; sent on either subchannel will always 'piggy-back' and ACK to help
; reduce retransmissions by the remote node in the lost message
; environment offered by Transport.
;
; INPUTS:   R8	Scratch
;	    R7	Scratch
;	    R6	Address of IRP to be used to send the message
;	    R5	XWB address
;	    R4	Scratch
;	    R3	Pointer to message being built
;	    R2	Scratch
;	    R1	Scratch
;	    R0	Bit number in XWB$W_STS identifying which message to
;		send.
;
; OUTPUTS:  R8	Garbage
;	    R7	Garbage
;	    R6	Preserved
;	    R5	Preserved
;	    R4	Garbage
;	    R3	Pointer to first byte beyond the message
;	    R2	Garbage
;	    R1	Number of user bytes of data entered into message
;	    R0	LBS if a message was constucted
;		LBC otherwise
; SIDE EFFECTS:
;
; 	    Appropriate 'send message' flags in XWB$W_STS may be cleared.
;
;-
		.ENABL	LSB
NET$BLD_LIACK:				; Build INT/LS ACK
	BBCC	R0,XWB$W_FLG(R5),10$	; Clear the work bit
10$:	BBS    #XWB$V_FLG_SLI,-		; Piggy-back ACK if possible
		XWB$W_FLG(R5),NET$BLD_LI
	MOVAB	XWB$T_LI(R5),R4		; Get subchannel block
	MOVB   #NSP$C_MSG_LIACK,(R3)+	; Set message type
	BRB	30$			; Common ACK building

NET$BLD_DTACK:				; Build DATA ACK
	BBCC	R0,XWB$W_FLG(R5),20$	; Clear the work bit
20$:	BITW   #XWB$M_FLG_WAST!-	; Any wait conditions preventing
		XWB$M_FLG_WHGL!-
		XWB$M_FLG_WBP,-
		XWB$W_FLG(R5)		; DATA message xmission ?
	BEQL	NET$BLD_DAT		; If not, piggy-back this ACK
	MOVAB	XWB$T_DT(R5),R4		; Get subchannel block
	MOVB   #NSP$C_MSG_DTACK,(R3)+	; Enter message type
	
30$:	ASSUME	<XWB$W_LOCLNK - XWB$W_REMLNK> EQ 2

	MOVL	XWB$W_REMLNK(R5),(R3)+	; Enter link addresses
	BICW3	#^X<F000>,-		;
		LSB$W_HAX(R4),(R3)	; Enter ACK value
	BBC    #XWB$V_STS_NAK,-		; Br unless NAK is to be sent
		XWB$W_STS(R5),33$	;
	BISW   #NSP$M_NAK,(R3)		; Set the NAK flag
	MOVAB	XWB$T_DT(R5),R0		; Get DATA LSB address
	CMPL	R0,R4			; Are we using the DATA subchannel?
	BNEQ	33$			; If not, branch
	BICW   #XWB$M_STS_NAK,-		; Clear the NAK request flag
		XWB$W_STS(R5)		;
33$:	BISW	#NSP$M_ACKVALID,(R3)+	; Mark it valid
	CLRL	R1			; Indicate no user bytes in message
	BRW	EX			; Exit with success

		.DSABL	LSB
NET$BLD_LI:				; Build INT or LS message
	MOVAB	XWB$T_LI(R5),R4		; Get subchannel block
	BSBW	BLDHDR_CO		; Call build-header co-routine
	CMPW	R7,LSB$W_HXS(R4)	; Last message ?
	BNEQ	10$			; Br if not final LI message
	BICW   #XWB$M_FLG_SLI,-		; Else clear flag to avoid 
		XWB$W_FLG(R5)		; subsequent INT/LS xmit attempts
	ASSUME	XWB$V_STS_TID EQ 0
10$:	BLBS	XWB$W_STS(R5),15$	; Br unless we will start timer
	BISW   #XWB$M_STS_TLI,-		; Indicate INT/LI subchannel
		XWB$W_STS(R5)		; owns the timer
;&15$:	BICL3  #^C<7>,R7,R1		; Get index for this seg number
15$:	BICL3  #^C<1>,R7,R1		; Get index for this seg number
	MOVW	XWB$T_LI_XVEC(R5)[R1],R2; Get flow control information
	BLSS	20$			; Br if INT message
	MOVB   #NSP$C_MSG_LS,(R3)+	; Enter message type
	JSB	@(SP)+			; Complete building header
	MOVW	R2,(R3)+		; Enter flow control info
	CLRL	R1			; Indicate no user bytes in message
	BRB	EX			; Exit with success
20$:	MOVB	#NSP$C_MSG_INT,(R3)+	; Enter message type
	MOVZWL	IRP$W_BCNT(R8),R2	; Setup size
	BEQL	COM_DAT			; If EQL then no buffer
	MOVL   @IRP$L_SVAPTE(R8),R1	; Get data pointer
	BRB	COM_DAT			; Finish in common

NET$BLD_DAT:				; Build a DATA message
	ASSUME	NSP$C_MSG_DATA EQ 0

	MOVAB	XWB$T_DT(R5),R4		; Get subchannel pointer
	BSBB	BLDHDR_CO		; Call co-routine to build msg
	;!
	;! This is where FLG_WAST should be conditionally set, an AST
	;! queued, and the bld_dat aborted if the seg isn't resident
	;!
	CMPW	R7,LSB$W_HXS(R4)	; Last sendable segment ?
	BNEQ	5$			; Br unless last data segment
	BISW   #XWB$M_FLG_WHGL,-	; Set wait condition to inhibit
		XWB$W_FLG(R5)		; subsequent xmissions
5$:	SUBW3	R7,IRP$W_X_FNX(R8),R0	; Is this FNX ?
	BEQL	7$			; If EQL then yes
	BBC	#11,R0,10$		; If BC the R7 is LSS  IRP$W_X_FNX
	MOVL	(R8),R8			; Advance to next IRP
	BRB	5$			; Loop
7$:	MOVB	#NSP$M_EOM,R0		; Set 'end of msg' flag
	MOVZWL	IRP$W_X_FNSIZ(R8),R2	; Get segment size
	BNEQ	20$			; If NEQ then there's a buffer
	MOVB	#NSP$M_EOM!NSP$M_BOM,-	; This is first and last segment
		(R3)+			; with zero length - there's no buffer
	BRB	COM_DAT			; Continue
10$:	CLRB	R0			; Set msg type code
	MOVZWL	XWB$W_REMSIZ(R5),R2	; Set segment size
20$:	SUBW3	IRP$W_X_INX(R8),R7,R1	; Get distance from initial seg
	EXTV	#0,#12,R1,R1		; MUST SIGN EXTEND
	BNEQ	30$			; Br if not first
	BISB	#NSP$M_BOM,R0		; Set 'begining of msg' flag
30$:	MULW	XWB$W_REMSIZ(R5),R1	; Get offset to segment data
	ADDL	@IRP$L_SVAPTE(R8),R1	; Get source data pointer
	MOVB	R0,(R3)+		; Enter message type
	ASSUME	XWB$V_STS_TID EQ 0
	BLBS	XWB$W_STS(R5),COM_DAT	; Br unless we'll set timer
	BICW   #XWB$M_STS_TLI,-		; Indicate DATA channel
		XWB$W_STS(R5)		; owns timer
COM_DAT:				; Common data message building
	JSB	@(SP)+			; Complete building header
	PUSHR	#^M<R2,R5>		; Save XWB address
	MOVC3	R2,(R1),(R3)		; Move data
	POPR	#^M<R1,R5>		; Recover XWB, # of user bytes -> R1
EX:	MOVL	#1,R0			; Indicate message successfully
	RSB				; built and return

;+
; BLDHDR_CO	- Co-routine to build numbered message headers
;
; FUNCTIONAL DESCRIPTION
;
; The routine is first entered to obtain the new LNX value on the 
; subchannel.  It returns to the caller to for housekeeping (such as
; setting wait flags in XWB$W_FLG) and to setup the message type.  It is
; then re-entered to complete building the message header and to update
; the LSB.  An ACK is always 'piggy-backed' in the hope that this may 
; reduce the number of retransmissions due to lost ACKs in the lost 
; message environment offered by Transport.
;
; The timer is set if possible.
;
; REGISTER USAGE
;		entry	   return	re-entry 	return
;
;	R8	subchannel's IRP address
;	R7	scratch	   new LNX 	unmodified	unmodified
;	R5	XWB ptr	   		(unmodified throughout)
;	R4	subchannel pointer	(unmodified throughout)
;	R3	output message pointer	(updated as header is built)
;	R1	scratch
;	R0	scratch	   
;
;-
BLDHDR_CO:				; Co-routine to build header
	MOVL	LSB$Q_XMT(R4),R8	; Get associated xmt IRP
	ADDW3	#1,LSB$W_LNX(R4),R7	; Get next sequence number
	EXTV	#0,#12,R7,R7		; Sign extend low order 12 bits
	JSB	@(SP)+			; Call co-routine for message
					; specific processing
	BBSS	#XWB$V_STS_TID,-	; Br if timer already owned
		XWB$W_STS(R5),5$
	MOVW	R7,XWB$W_TIM_ID(R5)	; Save number of timed message
	MOVW	XWB$W_RETRAN(R5),-	; Init PROGRESS
		XWB$W_PROGRESS(R5)	;
	BSBW	SET_TIMER		; Setup the timer
5$:	MOVW	R7,LSB$W_LNX(R4)	; This will be 'last number sent'
	SUBW3	LSB$W_HNX(R4),R7,R0	; Get distance from highest sent
	EXTV	#0,#12,R0,R0		; MUST SIGN EXTEND
	BLSS	10$			; If LSS then HNX > LNX
	MOVW	LSB$W_LNX(R4),-
		LSB$W_HNX(R4)		; Update HNX

	ASSUME	< XWB$W_LOCLNK - XWB$W_REMLNK > EQ 2

10$:	MOVL	XWB$W_REMLNK(R5),(R3)+	; Enter link addresses
	BICW3	#^X<F000>,-		; Always piggy-back ACKs in a
		LSB$W_HAX(R4),(R3)	; lost message environment
	BBC    #XWB$V_STS_NAK,-		; Br unless NAK is to be sent
		XWB$W_STS(R5),33$	;
	BISW   #NSP$M_NAK,(R3)		; Set the NAK flag
	MOVAB	XWB$T_DT(R5),R0		; Get DATA LSB address
	CMPL	R0,R4			; Are we using the DATA subchannel?
	BNEQ	33$			; If not, branch
	BICW   #XWB$M_STS_NAK,-		; Clear the NAK request flag
		XWB$W_STS(R5)		;
33$:	BISW	#NSP$M_ACKVALID,(R3)+	; Mark it valid
	BICW3	#^X<F000>,R7,(R3)+	; Enter segment number
	RSB

;+
; NET$MOV_CS_MSG - Move counted string to message with count field
; NET$MOV_US_MSG - Move uncounted string to message without count field
;
; FUNCTIONAL DESCRIPTION
;
; The source string is moved to its destination.  Both the source
; and destination pointers are updated.
;
; INPUTS:
;
;	R3  Pointer to destination field
;	R1  Pointer to count field of source string
;
; OUTPUTS:
;
;	R3  Pointer to first byte beyond end of destination
;	R1  Pointer to first byte beyond source string
;-
	.ENABL	LSB

NET$MOV_CS_MSG:				; Move counted string to msg
	PUSHR	#^M<R0,R2,R4,R5>	; Save important regs
	MOVZBW	(R1),R0			; Get string length
	INCW	R0			; Include count itself
	BRB	10$			; Continue in common

NET$MOV_US_MSG:				; Mov counted str w/o count
	PUSHR	#^M<R0,R2,R4,R5>	; Save important regs
	MOVZBW	(R1)+,R0		; Get count value, advance ptr
10$:	MOVC3	R0,(R1),(R3)		; Move the string
	POPR	#^M<R0,R2,R4,R5>	; Restore regs
	RSB

	.DSABL LSB

	.SBTTL	Transport Layer entry point
;++
; NET$UNSOL_INTR	- Unsolicited interrupt service routine
;
; FUNCTIONAL DESCRIPTION
;
; Since Transport and NSP may someday be implemented as separate drivers
; which communicate with each other, it is convenient to implement their
; interface as if that were currently the case.  The intended 
; arrangement of the NSP-Transport driver interface is expected to be
; roughly analogous to the Tape Controller-Mass bus "driver" relationship,
; i.e., Transport can be considered to be NSP's secondary contoller.
;
; The following "unsolicited interrupt" routine is called by Transport
; whenever it has received a message addressed to NSP.  NSP must process
; the message completely and return to Transport without forking.  The
; message can be found in a single buffer of "complex chained" format
; attached to an IRP.  If NSP wishes to keep the message it decouples
; the buffer (pointed to by IRP$L_IOSB) and zeroes IRP$L_IOSB.
;
; NSP may need to return the message to its sender.  For instance, the
; message may be addressed to a link which no longer exists.  If this
; is the case, the message buffer is detached from the IRP and used as
; the context block for soliciting permission to transmit.
;
; INPUTS:	R5	Scratch
;		R4	Scratch
;		R3	Scratch
;		R2	NET RCB pointer
;		R1	Transport's IRP pointer
;		R0	Scratch
;
;		IRP$L_ASTPRM	Pointer to the NET RCB 
;		IRP$L_UCB	Pointer to the ACP's NET UCB
;		IRP$B_EFN	If LBS then can't take CXB since the datalink's
;				receiver queue is non-full
;		IRP$L_IOSB	Pointer to CXB containing NSP message
;		IRP$L_SVAPTE	Pointer to first NSP byte in message 
;		IRP$W_BCNT	Length of message w/o route header 
;		IRP$L_IOST1	Path number over which message was received
;		IRP$L_IOST2	Source node address in low byte
;				Local node address in high byte
;
; OUTPUTS: (upon return to Transport)
;
;		R5-R2	Garbage
;		R1	IRP address
;		R0	Garbage
;
;		IRP$L_IOSB	Zero if CXB was decoupled, else unmodified
;--
NET$UNSOL_INTR::			; Receiver interrupt service
	PUSHR	#^M<R6,R7,R8,R9,R10>	; Extend to 'event' context -
					;  also, save R10
	MOVL	R1,R6			; Save copy of IRP
	MOVZWL	IRP$L_IOST2(R6),R10	; Get remote node address
	BSBW	GET_NDC_BLK		; Address the counter block with R10
	BUMP	L,NDC$L_PRC(R10)	; Inc 'packets rcvd' counter
	MOVL	RCB$L_ACP_UCB(R2),R5	; Get the NET UCB address
	MOVL	IRP$L_SVAPTE(R6),R1	; Get buffer pointer
	MOVZWL	IRP$W_BCNT(R6),R2	; Get message size
	;
	;    Assume the first two bytes of the message exist.  If the 
	;    message is too short it will be caught later.
	;
	MOVB	(R1)+,R9		; Get message type code
	CMPB	R9,S^#NSP$C_MSG_CI	; Is message Connect Initiate ?
	BNEQ	10$			; If not, branch
	BUMP	W,NDC$W_CRC(R10)	; Increment "connects received"
	MOVZWL	IRP$L_IOST2(R6),R3	; Get remote node address
	BSBW	NET$CREATE_XWB		; Get a new XWB and link slot
	BLBS	R5,200$			; Br if no resources
	TSTW	(R1)+			; Skip over local link field
	BNEQ	70$			; Error if non-zero
	MOVW	(R1)+,XWB$W_REMLNK(R5)	; Store remote link address
	BRB	30$			; Continue in common
10$:	MOVZWL	(R1)+,R3		; Get 'destination' link address
	BSBW	NET$XWB_LOCLNK		; Switch to XWB context
	BLBS	R5,200$			; No associated XWB if LBS
					; is harmless if not a data msg
	CMPW	IRP$L_IOST2(R6),-	; Is msg from proper remote node ?
		XWB$W_REMNOD(R5)	; 
	BEQL	15$			; If so, continue
	TSTW	XWB$W_REMNOD(R5)	; Was the remote address zero?
	BNEQ	200$			; If not, branch
	MOVW	IRP$L_IOST2(R6),-	; Else udpate to use new address
		XWB$W_REMNOD(R5)	; (this is the local node starting
					;  and changing its address)
	ASSUME	XWB$C_STA_CLO EQ 0
	ASSUME	XWB$C_STA_CIS EQ 1
	ASSUME	XWB$C_STA_CAR EQ 2

15$:	CMPB	XWB$B_STA(R5),#2	; Have remote link address yet ?
	BGTRU	20$			; If so, branch
	MOVW	(R1),XWB$W_REMLNK(R5)	; Store remote link address
20$:	CMPW	(R1)+,XWB$W_REMLNK(R5)	; Is the remote link correct ?
	BNEQ	200$			; If not, branch
	;
	;    Map the message into an event code and check for message size
	;    violations 
	;
	ASSUME	NSP$C_MSG_DATA EQ 0
	ASSUME	NSP$C_EV_DATA  EQ NSP$C_MAX_MSG

30$:	MOVB	R9,XWB$B_MSGTYP(R5)	; Store message type
	MOVZBL	#NSP$C_EV_DATA,R7	; Assume DATA message
	BITB	#^C<NSP$M_EOM!NSP$M_BOM>,R9 ; Test all but BOM,EOM bits
	BEQL	60$			; Br if DATA message
	DECL	R7			; Else start with next event
40$:	CMPB	NSP$AB_MAPINF[R7],R9	; Is this it ?
	BEQL	60$			; If so, branch
	SOBGEQ	R7,40$			; Update index and try again
	BRB	70$			; Message type unrecognized
60$:	MOVZBL	NSP$AB_MINSIZ[R7],R0	; Get min size by message type
	SUBL	R0,R2			; Dec. msg length by minimum
	BLSSU	70$			; Br if too short
	BBC	R7,NSP$L_MSG_FIX,75$	; Br if variable msg length ok
	BEQL	75$			; Br unless msg was too large
70$:	MOVZBL	#NSP$C_EV_PROERR,R7	; Remap to protocol error event
	MOVW	#NET$C_DR_PROTCL,-	; Setup disconnect reason to send
		XWB$W_REASON(R5)	; to partner
75$:	BSBW	NET$EVENT		; Process event
100$:	MOVL	R6,R1			; Restore INTERNAL IRP address
	POPR	#^M<R6,R7,R8,R9,R10>	; Revert to 'fork' context
	RSB				; Return to Transport

200$:	PUSHAB	B^100$			; Setup return address

NET$RTS_NLT:				; Return to sender as no link terminate
	PUSHL	R5			; Save current context block
	BLBS	IRP$B_EFN(R6),85$	; If LBS then can't take buffer
	MOVL	IRP$L_IOSB(R6),R5	; Get message buffer
	MOVL	IRP$L_SVAPTE(R6),R1	; Get rcv'd msg pointer
	CMPB	#NSP$C_MSG_DC,(R1)+	; Is this a DC message
	BEQL	85$			; If so, ignore it
	BSBB	80$			; Solicit and xmit message
85$:	POPL	R5			; Restore reg
	RSB				;

80$:	CLRL	IRP$L_IOSB(R6)		; Mark buffer as gone
	MOVL	(R1),24(R5)		;&Save link addresses after fork block
					; area.
	MOVL	IRP$L_IOST2(R6),R4	; Get dst,local node addresses
	CLRL	R3			; Indicate no predetermined line
	MOVL	IRP$L_ASTPRM(R6),R2	; Setup RCB address
	BSBW	TR$SOLICIT		; Request permission to xmit
					; (may suspend process)
	BLBC	R0,95$			; Br if request denied
	CLRL	R2			; No "quick solicit" wanted
	MOVL	IRP$L_SVAPTE(R1),R3	; Get output pointer
	MOVB	#NSP$C_MSG_DC,(R3)+	; Enter msg typ
	ROTL	#16,24(R5),(R3)+	;&Swap src,dst link addresses
	MOVW	#NET$C_DR_NOLINK,(R3)+	; Assume "no link terminate"
	TSTW	-4(R3)			; If "local" link address was
	BNEQ	90$			;  zero then terminate is for
	MOVW	#NET$C_DR_RSU,-2(R3)	;  "no resources"
90$:	MOVL	IRP$L_IOSB(R1),R4	; Get CXB address
	MOVAB	B^100$,CXB$L_ENDACTION(R4) ; Setup null status routine address
95$:	MOVL	R5,R0			; Get block address
	JSB	G^COM$DRVDEALMEM	; Deallocate the block
	MOVL	#1,R0			; Indicate success
100$:	RSB

	.SBTTL	NET$RCV_xx		- Process received messages
;++
; NET$RCV_CC	- Respond to a received Connect Confirm message
; NET$RCV_CA	- Respond to Connect Acknowledge
; NET$RCV_CI	- Process received Connect Initiate message
;
; FUNCTIONAL DESCRIPTION
;
; These routines process received connect messages
;
; INPUTS:   R10 NDC block pointer
;	    R8	Scratch
;	    R7	Scratch
;	    R6	Transport IRP address
;	    R5	XWB address
;	    R4	Scratch
;	    R3	Scratch
;	    R2	Number of as yet unaccounted bytes in message
;	    R1	Pointer to first unparsed byte in message
;	    R0	Scratch
;
; OUTPUTS:  R8,R7,R4,R3,R2,R1 are garbage
;
;	    R6	Transport IRP address
;	    R5	XWB address
;	    R0	Standard VMS status code
;--
		.ENABL	LSB
NET$RCV_CC:				; Repond to rcv'd CC msg
	MOVZWL #NET$C_DR_ZERO*2,R0	; Assume error
	TSTW	XWB$W_REMLNK(R5)	; Test new remote link address
	BEQL	100$			; Protocol error if EQL
	BSBW	PRS_CHR			; Parse link characteristics
	BLBC	R0,100$			; Br if unsuccessful
	CMPB	XWB$B_STA(R5),-		; Establish timer estimate
	       #XWB$C_STA_CAR		; unless its been done already
	BEQL	10$
	BSBB	NET$RCV_CA		; Set estimated timer value
10$:	UPDATE	L,R2,NDC$L_BRC(R10)	; Bump "bytes received"
	MOVZWL #MSG$_CONFIRM,R8		; Set mbx message code
	BSBW	NET$SEND_CS_MBX		; Notify user
	BLBC	R0,50$			; Br if error
	MOVZWL #NSP$C_EV_CC,R7		; Set original event code
	BRW	NET$ENT_RUN		; Enter the RUN state

NET$RCV_CA:				; Respond to rcv'd CA msg
	MOVW	XWB$W_ELAPSE(R5),-	; Establish estimated round
		XWB$W_DELAY(R5)		; delay time
	BNEQ	15$			; If NEQ the okay
	INCW	XWB$W_DELAY(R5)		; Prevent a zero value
15$:	RSB				; May change state on return

NET$RCV_CI:				; Process CI message
	BSBW	PRS_CHR			; Parse the link characteristics
	BLBC	R0,100$			; Br on error
	BSBW	GETCTL			; Parse remainder of message
	BLBC	R0,100$			; Br on error
	PUSHL	R5			; Save XWB address
	MOVL	R5,R4			; Copy XWB address
	MOVL	XWB$L_VCB(R4),R5	; Get RCB address
	MOVL	RCB$L_ACP_UCB(R5),R5	; Get NETACP's UCB
	MOVL	#8,R2			; Indicate mbx data size
	MOVL	#MSG$_CONNECT,R8	; Specify message type
	BSBW	NET$SEND_MBX		; Prepare to build message
	BLBC	R0,20$			; Br on error
	MOVAB	W^NET$ACP_COMM,(R3)+	; Enter update routine address
	MOVL	R4,(R3)+		; Enter XWB address
	JSB	@(SP)+			; Send the message
20$:	POPL	R5			; Restore XWB address
	BLBC	R0,200$			; Br if error
30$:
	RSB
				; Change state on return
;
;  Catch errors here.  In each case the return is with the low bit clear
;  to flag a new event to be processed.
;
50$:	TSTL	R0			; 0=> counted str format error
	BNEQ	200$			; If eql then protocol error
100$:	MOVZBL	#NSP$C_EV_PROERR,R7	; Setup new event
	DIVW3	#2,R0,XWB$W_REASON(R5)	; Set disconnect reason
	BRB	300$
200$:	MOVW	#NET$C_DR_RSU,-		; Setup disconnect reason as
		XWB$W_REASON(R5)	; "no resources"
	MOVZBL	#NSP$C_EV_MBXERR,R7	; Setup new event
300$:	BRW	NET$PRE_EMPT		; Pre-empt with new event


		.DSABL	LSB
PRS_CHR:				; Get link characteristics
	MOVW	(R1)+,R0		; Get link info. bits
	;
	;   All 'service' and 'information' bits which are unrecognized 
	;   are ignored.  The bits positions used in the protocol have the
	;   same positions and semantics in XWB$W_STS.
	;
	ASSUME	NSP$V_MSGFL EQ XWB$V_STS_MSGFL
	ASSUME	NSP$V_SEGFL EQ XWB$V_STS_SEGFL
	ASSUME	NSP$V_V31   EQ XWB$V_STS_V31
	ASSUME	NSP$V_V31   EQ 8
	ASSUME	NSP$V_VXX   EQ 9
	ASSUME	NSP$V_VXX   EQ XWB$V_STS_VXX


	BICB3	#^C<NSP$M_SERVICE>,R0,-(SP) ; Get "services" field
	CMPB	#NSP$C_SERVICE,(SP)+	; Is "services" field correct
	BNEQ	30$			; If NEQ then msg format error
	BBC	#NSP$V_MSGFL,R0,10$	; At most one of bits 2,3
	BBS	#NSP$V_SEGFL,R0,30$	;  may be set
10$:	BICW	#^C<XWB$M_STS_MSGFL!-	; Clear all but flow control
		    XWB$M_STS_SEGFL!-	; type and
		    XWB$M_STS_VER>,R0	; NSP version bits
	BISW	 R0,XWB$W_STS(R5)	; Store link characteristics
	MOVZWL	#<NET$C_DR_SEGSIZ>@1,R0	; Assume error
	MOVL	XWB$L_VCB(R5),R0	; Get the RCB pointer
	CMPW	(R1),RCB$W_ECLSEGSIZ(R0); ECLSEGSIZ bounds both xmt and
					; rcv buffer sizes
	BLEQU	20$			; If LEQU then use it
	MOVW	RCB$W_ECLSEGSIZ(R0),(R1); Use the minimum of the two sizes
20$:	MOVW	(R1)+,XWB$W_REMSIZ(R5) 	; Get remote's rcv seg size
	MOVB	#1,R0			; Indicate success
	RSB

30$:	MOVL	#NET$C_DR_PROTCL@1,R0	; Indicate error
40$:	RSB				; Return with error

		.ENABL	LSB
;
; Supporting parse CI routines
;
GETCTL:	MOVAB	XWB$B_LPRNAM(R5),R3	; Setup destination pointer
	BSBW	MOVPRNAM		; Move the dest. process name
					;  - no return if error
	MOVAB	XWB$B_RPRNAM(R5),R3	; Setup destination pointer
	BSBW	MOVPRNAM		; Move the src. process name
	MOVB	(R1)+,R4		; Save flags
	MOVAB	(R3)+,R8		; Save current output ptr
					; and advance past count field
	BLBC	R4,70$			; Br if no accounting info
	MOVB	#XWB$C_LOGIN-3,(R8)	; Setup total space available
	BSBB	MOVCS_39		; Move User field
					;  - no return if error
	BSBB	MOVCS_39		; Move Password field
	BSBB	MOVCS_39		; Move Account field
	SUBL	R8,R3			; Get count of bytes moved -
	DECL	R3			;  adjusting for count field
	MOVB	R3,(R8)			; Store count
	SUBL	R3,R2			; Account for "optional" bytes
	BRB	90$			; Continue
70$:	MOVL	#3,(R8)			; A null access string is a 3
					; (string count) followed by
					; 3 zero's (substring counts)
90$:	MOVAW	XWB$B_DATA(R5),R3	; Get next XWB field address
	CLRL	(R3)			; Assume no optional data
	MOVL	#1,R0			; Assume success
	BBC	#1,R4,100$		; Br if no optional data
	UPDATE	L,R2,NDC$L_BRC(R10)	; Bump "bytes received"
	BSBW	MOVCSFX_17		; Move optional data field
					;  NO return if error
100$:	TSTL	R2			; Any bytes left in message ?
	BNEQ	130$			; Illegal message if NEQ
	;
	;   Move remote user i.d. to non-muliplexed portion of the XWB.
	;
	;   The RPRNAM field, as stored, is one of:
	;
	; <1 byte count><1 byte = 0><1 byte object type  not = 0>
	; <1 byte count><1 byte = 1><1 byte = 0><I-16 process name>
	; <1 byte count><1 byte = 2><1 byte = 0><4 byte UIC><I-12 process name>
	;
	PUSHR	#^M<R1,R2,R4,R5>	; Save regs
	MOVAB	XWB$B_RPRNAM(R5),R1	; Point to remote process name
	MOVAB	XWB$B_RID(R5),R3	; Point to permanent storage
	SUBB3	#2,(R1)+,R2		; Get total number of bytes minus those
					; used for format type and object number
	BLEQ	110$			; If LEQ then no username text
	MOVZBL	(R1)+,R0		; Get format type
	BEQL	110$			; If EQL then no name text
	DECL	R0			; Format type 1?
	BEQL	105$			; If EQL then yes
	DECL	R0			; Format type 2?
	BNEQ	110$			; If NEQ then no, unknown format type
	ADDL	#4,R1			; Account for UIC bytes
105$:	INCL	R1			; Skip over object number
	MOVZBL	(R1)+,R2		; Get count field
	CMPB	#XWB$C_RID,R2		; Too large?
	BLSSU	110$			; If LSSU then use
	MOVB	R2,(R3)+		; Enter count field
	MOVC3	R2,(R1),(R3)		; Enter remainder of text
110$:	POPR	#^M<R1,R2,R4,R5>	; Restore regs
	MOVL	S^#SS$_NORMAL,R0	; Indicate success
	RSB				; Done

MOVCS_39:
	CMPB	#39,(R1)		; Test max string count value
	BLSSU	120$			; Br if too large
	SUBB	(R1),(R8)		; Account for space to be used
	BLSS	120$			; Br if not enough space left
	BSBW	NET$MOV_CS_MSG		; Else move it
	RSB				; Done

120$:	TSTL	(SP)+			; Pop return address
130$:	MOVZWL	#<NET$C_DR_ACCESS>*2,R0	; Setup failure code
	RSB
		
		.DSABL	LSB

;++
; MOVCSFX	Move counted string to fixed length field
; MOVCSFX_17	Move counted string to field 17 bytes long
; MOVPRNAM	Move process name
;
; FUNCTIONAL DESCRIPTION:
;
;  The field pointed to by R1 is moved to the fixed length field pointed to by
;  R3.  The resultant field is always stored as a counted string.  If an error
;  is encountered, the caller's  return address is poped off the stack and the
;  return is to the caller's caller.
;
;  The process name field, as stored, is one of:
;
;  <1 byte count><1 byte = 0><1 byte object type  not = 0>
;  <1 byte count><1 byte = 1><1 byte = 0><I-16 process name>
;  <1 byte count><1 byte = 2><1 byte = 0><4 byte UIC><I-12 process name>
;
;  The process name source field is the same but without the count field
;
;
; INPUTS:	R3	Pointer to the desination field
;		R2	Number of message bytes not yet accounted for
;		R1	Pointer to first byte of message
;		R0	Size of destination field (MOVCXFX only)
;
;		 (SP)	Return address of caller
;		4(SP)	Return address of caller's caller
;
;
; OUTPUTS:	R3	Pointer to first byte beyond fixed length dest. field
;		R2	Reduced by number of source field bytes moved
;		R1	Pointer to first unmoved byte in message
;		R0	1 if successfull, 0 otherwise
;--

;+
;   NOTE: These routines assume that the count in R2 of the remaining
;	  bytes left is a longword and that the total bytes to be moved
;	  is less than 255.
;-

	.ENABL	LSB

MOVPRNAM:				; Move process name
	PUSHR	#^M<R2,R4,R5>		; Save R4,R5; COPY R2
	PUSHL	#<NET$C_DR_FMT>*2	; Assume error
	MOVL	#2,R2			; Establish min. src field size
	$DISPATCH  TYPE=B,(R1),-	; Dispatch on format type
	<-
	    <0,  5$>,-			;  non-zero object number only
	    <1, 10$>,-			;  object #0, I-16  taskname
	    <2, 20$>,-			;  object #0, 4 byte UIC, I-12 taskname
	>
	BRB	100$			; Error if unrecognized format type
5$:	TSTB	1(R1)			; Test object number
	BEQL	100$			; If EQL then format error
	BRB	30$			; Continue in common 
10$:	INCB	R2			; Inc for string count subfield
	ADDB	2(R1),R2		; Inc for string text subfield
	BRB	25$			; Continue in common
20$:	ADDB	#4+1,R2			; Inc for UIC, string count subfields
	ADDB	6(R1),R2		; Inc for string text subfield
25$:	TSTB	1(R1)			; Object number zero ?
	BNEQ	100$			; If NEQ then format error
30$:	MOVB	R2,(R3)+		; Insert length of process name
	MOVL	#XWB$C_LPRNAM-1,R0	; Establish fixed dst field size
					;  (not including the XWB$B_xPRNAM
					;   field which was just moved)
	BRB	40$			; Continue

MOVCSFX_17:
	MOVL	#17,R0			; Setup size of fixed field
MOVCSFX:
	PUSHR	#^M<R2,R4,R5>		; Save R4,R5; COPY R2
	CLRL	-(SP)			; Push error flag
	MOVZBL	(R1),R2			; Get length of source string
	INCL	R2			; Update for count field
40$:	SUBL	R2,4(SP)		; Update remaining byte count
	BLSS	100$			; Error if LSS
	CMPW	R2,R0			; Is source larger then destination
	BGTRU	100$			; If GTRU then source was too long
	MOVC5	R2,(R1),#0,R0,(R3)	; Move the string, update R1,R3
	POPR	#^M<R0,R2,R4,R5>	; Restore R4,R2, UPDATE R2
	INCB	R0			; Flag success 
	RSB
;
; Catch the errors here
;
100$:	POPR	#^M<R0,R2,R4,R5>	; Restore R4,R2, UPDATE R2
					; error code in R0
	TSTL	(SP)+			; Pop caller's return address
	RSB				; Return to its caller

	.DSABL	LSB


;+
; NET$RCV_Dx_RUN  	- Receive DI/DC message while in the run state
; NET$RCV_Dx_Cxx	- Recieve DI/DC message while in one of the
;			  "connect" states
; NET$ABORT		- Disconnect or abort a link 
; NET$TIMOUT_CN		- Abort a timed out link in the connect state
;
; The user is notified of the disconnect via the mailbox associated 
; with the link's UCB.  All pending IRPs are completed.
;
; INPUTS:   R10 NDC block pointer
;	    R8	Scratch
;	    R7	Scratch
;	    R6	Transport IRP address 
;	    R5	XWB address
;	    R4	Scratch
;	    R3	Scratch
;	    R2	Number of as yet unaccounted bytes in message
;	    R1	Pointer to first unparsed byte in message
;	    R0	Scratch
;
;	Note:	R1,R2,R6 are listed above for NET$RCV_Dx_xxx only.
;		They carry no useful information for the other routines.
;
; OUTPUTS:  R8,R7,R4,R3,R2,R1,R0 are garbage
;
;	    R6	Preserved
;	    R5	Preserved
;--

NET$RCV_Dx_RUN:				; Receive Dx while in RUN state 
	TSTL	XWB$L_DI_CXB(R5)	; Already holding onto a Dx message?
	BNEQ	10$			; If EQL then yes, ignore this one
	;
	;
	;   If NSP version is V3.1 then partner is Phase II and the message
	;   cannot be ignored since it will not be retransmitted.
	;
	;
	BICW3	#^C<XWB$M_STS_VER>,-	; Get the NSP version
		XWB$W_STS(R5),R0	;
	CMPW	R0,#NSP$C_VER_V31	; Is it V3.1?
	BEQL	PROC_DX			; If EQL yes, Phase II
	;
	;
	;   If there are any receives not yet processed then the Disconnect
	;   cannot be processed yet.  In this case attach the Disconnect 
	;   message to the XWB so that it will be processed as soon as the last
	;   CXB is passed to the user, but if the flag is set saying that the
	;   buffer cannot be removed from the IRP ignore this message.
	;
	;
	TSTL	XWB$L_RCVCXB(R5)	; Any received segs still waiting
					; to be picked up?
	BEQL	PROC_DX			; If EQL then no
	BLBS	IRP$B_EFN(R6),10$	; If LBS then can't take CXB
	MOVL	IRP$L_IOSB(R6),R0	; Get CXB
	CLRL	IRP$L_IOSB(R6)		; Remove it from IRP
	MOVL	R0,XWB$L_DI_CXB(R5)	; Save it on the XWB

	ASSUME	CXB$C_LENGTH  GE 16	; Make sure scratch area is there

	MOVAB	CXB$C_LENGTH-16(R0),R0	; Goto end of CXB

	MOVQ	R1,(R0)+		; Save remainder of msg descriptor
	MOVL	R6,(R0)+		; Save "ecl" IRP pointer
	MOVL	R10,(R0)+		; Save NDC pointer
10$:	BRW	NET$END_EVENT		; Abort remainder of event processing

CONT_PROC_DX:				; Continue processing Dx message
	PUSHL	R0			; Save CXB pointer
	CLRL	XWB$L_DI_CXB(R5)	; Remove it from XWB
	MOVAB	CXB$C_LENGTH-16(R0),R0	; Goto end of CXB
	MOVQ	(R0)+,R1		; Get message descriptor
	MOVL	(R0)+,R6		; Get "ecl" IRP pointer
	MOVL	(R0)+,R10		; Get NDC pointer
	BSBB	PROC_DX			; Continue processing Dx message
	POPL	R0			; Restore CXB pointer
	JSB	G^COM$DRVDEALMEM	; Deallocate it
	RSB				; Done


PROC_DX:
	;
	;   Okay to proceed with Dx message processing
	;
	;
	MOVZWL	#SS$_LINKDISCON,R0	; Assume synchronous disconnect
	MOVL	#MSG$_DISCON,R8		; ...
	BRB	RCV_Dx			;

NET$RCV_Dx_Cxx:				; Rcv Dx msg in Connect state
	MOVZWL	#SS$_REJECT,R0		; Assume connect reject
	MOVL	#MSG$_REJECT,R8		; ...
RCV_Dx:
	MOVZWL	(R1)+,R7		; Get actual disconnect reason
	MOVW	#NET$C_DR_CONF,-	; Confirm DI message for remote
		XWB$W_REASON(R5)	;
	BRB	CMPL_DISCON		; 

NET$TIMOUT_CN:				; Timeout a connect
	BBC	#XWB$V_STS_TMO,-	; If BC then not timeout
		XWB$W_STS(R5),NET$ABORT	;
	MOVZWL	#NET$C_DR_TIMOUT,R7	; Set disconnect reason
	MOVW	#NET$C_DR_EXIT,-	; Disconnect reason for remote
		XWB$W_REASON(R5)	;
	CLRL	R2			; No disconnect data
	BRB	CMPL_DISCON		;

NET$ABORT:				; Abort a logical link
	MOVZWL	XWB$W_REASON(R5),R7	; Reason already set?
	BNEQ	10$			; If NEQ yes
	MOVZWL	#NET$C_DR_THIRD,R7	; Else, use thirdpart disconnect
	MOVW	R7,XWB$W_REASON(R5)	; Set disconnect reason for remote
10$:	CLRL	R2			; No disconnect data
	BRB	CMPL_DISCON		;

NET$CANLNK:				; Cancel I/O request
	MOVZWL	XWB$W_REASON(R5),R7	; Reason already set?
	BNEQ	10$			; If NEQ yes 
	MOVZWL	#NET$C_DR_ABORT,R7	; Else, use abort disconnect
	MOVW	R7,XWB$W_REASON(R5)	; Set disconnect reason for remote
10$:	MNEGL	#1,R2			; No disconnect mailbox message

CMPL_DISCON:				; Complete disconnect
;
; Map disconnect reason code to SS$_XXX and MSG$_XXX 
;
	PUSHR	#^M<R2,R3>		; Save regs
	MOVAB	W^DR_TABLE-6,R2		; Get address of mapping table
	TSTB	R7			; Is reason synchronous disconnect 
					; or reject?
	BEQL	20$			; If EQL yes
	MOVZWL	#SS$_LINKABORT,R0	; Else set catch-all status
	MOVL	#MSG$_ABORT,R8		; ...
10$:	ADDL	#6,R2			; Increment to next entry
	MOVB	(R2)+,R3		; Get the reason code
	BEQL	20$			; If EQL at end of list
	CMPB	R3,R7			; Match?
	BNEQ	10$			; If NEQ no - loop
	MOVW	2(R2),R0		; Get the SS$_XXX code
	MOVW	4(R2),R8		; Get the MSG$_XXX code
20$:	POPR	#^M<R2,R3>		; Restore regs
	MOVW	R0,XWB$W_DIS_STAT(R5)	; Save SS$_XXX code
;
; Notify user of disconnect via mailbox, if any
;
	TSTW	R2			; Any user data ?
	BEQL	30$			; If EQL then R10 may not be valid
	BLSS	40$			; If LSS then don't send a message
	UPDATE	L,R2,NDC$L_BRC(R10)	; Bump "bytes received"
30$:	BSBW	NET$SEND_CS_MBX		; Notify user
40$:	PUSHR	#^M<R1,R2,R7,R8>	; Save regs
	BSBW	NET$PURG_RUN		; Cleanup if exiting RUN state
	POPR	#^M<R1,R2,R7,R8>	; Restore regs
	CLRB	XWB$B_DATA(R5)		; Clear any pending interrupt data

	CLRL	R0			; Tell CMPL_ACCESS to look at reason
	MOVL	R7,R1			; Get disconnect reason
	BRW	NET$CMPL_ACC		; Complete any pending IO$_ACCESS
					; and return to change state


;++
; NET$RCV_LI	- Receive INT/LS messages
;
; Process a received Interrupt or Link Service message. If the message
; is acceptable then it is "stored" in the receive slot vector.  
; Storing a Link Service message means moving the one word of link
; service information into the slot.  Storing an Interrupt message
; means moving a flag to the slot and moving the interrupt data to the
; XWB resident buffer.
;
; The format of each slot entry is given below.  The low order 3 bits
; of the message sequence number are used as an index into the vector
; to locate the slot.  Note that this means the maximum number of 
; unprocessed messages which can be stored at any one time is eight.
;
;	15	       8|7		0
;	+---------------+---------------+
;	| flw ctl value	|    flags	|
;	+---------------+---------------+
;
;			 flags
;				bit 0	set to turn on DATA backpressure
;				bit 1	set to turn off DATA    "
;				bit 3	set if 'flw ctl value' for INT/LS
;					clear if      "		for DATA
;				bit 7	clear if slot contains flow ctl
;					set if slot is INTERRUPT flag
;
; INPUTS:
;
;	R10	NDC counter block pointer
;	R8	LI subchannel LSB pointer
;	R7	Scratch
;	R6	Transport IRP address 
;	R5	XWB address
;	R4	Scratch
;	R3	Scratch
;	R2	Number of as yet unaccounted bytes in message
;	R1	Pointer to first unparsed byte in message
;	R0	Scratch
;
;	Note:	R1,R2,R6 are listed above for NET$RCV_Dx_Cxx only.
;		They carry no useful information for the other routines.
;
; OUTPUTS:
;
;	R8,R7,R4,R3,R2,R1 are garbage
;
;	R6	Preserved
;	R5	Preserved
;	R0	Standard VMS status code
;
;--

		.ENABL	LSB
NET$RCV_LI:				; Receive LINK SERVICE messages
	BISW	#XWB$M_FLG_SIACK,-	; Indicate need to send ACK
		 XWB$W_FLG(R5)		; on this subchannel
	MOVAB	XWB$T_LI(R5),R8		; Get INT/LS LSB
	MOVW	(R1)+,R3		; Get SEG field
	BGEQ	10$			; If LSS then really ACK field
	BSBW	NET$PIG_ACK		; Process the ACK field
10$:	PUSHL	R6			; Save reg
	MOVZBL	XWB$B_LI_RMSK(R5),R7	; Get rcv vector usage mask
	EXTV	#0,#12,R3,R4		; Sign extend low 12 bits
	SUBW3	LSB$W_HAX(R8),R4,R0	; Get distance from highest
					; ACK already sent
	EXTV	#0,#12,R0,R0		; MUST SIGN EXTEND
	BLEQ	40$			; Ignore if we've seen it before
	CMPW	R0,#7			; Recieve vector can only hold
					; 8 messages (use 7 for now)&
	BGTR	25$			; NAK it if too advanced
	BICL	#^X<FFFFFFF8>,R3	; Get low 3 bits used as index
	BBSS	R3,R7,40$		; Account for vector slot 
					; - assume rexmission if in use
	BICW3	#^X<F8>,(R1),-		; Set FLOW control fields, clear
		 XWB$T_LI_RVEC(R5)[R3]	; 'must be zero' bits
	BBC	#NSP$V_INTMSG,-		; Br unless INTERRUPT message
		 XWB$B_MSGTYP(R5),40$
	;
	;   Validate INTERRUPT data, move it into the XWB buffer, and
	;   store flag in LS receive vector
	;
	CMPL	 R2,#16			; Check size of interrupt data
	BGTRU	 30$			; If GTR then illegal
	BBSS	#XWB$V_STS_LKDB,-	; If the XWB 'data' buffer is 
		 XWB$W_STS(R5),30$	; locked then the message has
					; been illegally sent since only
					; one interrupt message is flow
					; controlled at a time
	MNEGW	#1,XWB$T_LI_RVEC(R5)[R3]; Enter 'interrupt' flag
	PUSHL	R5			; Save critical regs
	UPDATE	L,R2,NDC$L_BRC(R10)	; Bump "bytes received"
	MOVB	R2,XWB$B_DATA(R5)	; Move count field
	MOVC3	R2,(R1),XWB$T_DATA(R5)	; Move interrupt to data buffer
	POPR	#^M<R5>
	BRB	40$
	;
	;   No room for flow control message.   Send a NAK
	;
25$:	BISW	#XWB$M_STS_NAK,-	; Schedule the NAK message
		    XWB$W_STS(R5)	;
	BRB	40$			; Continue
	;
	;   Process the INT/LS receive vector  --  this code is also entered to
	;   try to process the vector even if the current message was not
	;   acceptable.  This is done primarily to retry passing interrupt data
	;   to the user, an operation which can fail indefinitely.
	;
30$:	MOVZBL	XWB$B_LI_RMSK(R5),R7	; Get receive vector usage mask -- R7
					; had an invalid bit set
40$:	MOVZWL	LSB$W_HAX(R8),R4	; Get highest ACK xmitted 
	BRB	55$			; Continue
50$:	EXTV	#0,#12,R4,R4		; Sign extend low order 12 bits
	MOVW	R4,XWB$T_LI+LSB$W_HAX(R5) ; Reset highest ACK sent
55$:	INCW	R4			; Process next logical message
	BICL3	#^X<FFFFFFF8>,R4,R6	; Get vector index
	BBCC	R6,R7,57$		; Invalidate entry, br if invalid
	MOVW	XWB$T_LI_RVEC(R5)[R6],R1  ; Get flow control info
	BBS	#7,R1,110$		; If BS then actually interrupt
					; info for this slot in vector
	;
	;  Process flow control information
	;
	EXTV	#8,#8,R1,R0		; Get flow value
	BBS	#2,R1,60$		; For LS subchannel if bit set
	MOVAB	W^DAT_FLOW,R3		; Setup action routine address
	MOVAB	XWB$T_DT(R5),R2	  	 	   ; Get subchannel ptr
	BBS	#XWB$V_STS_MSGFL,XWB$W_STS(R5),70$ ; Br if msg flow ctl
	BBC	#XWB$V_STS_SEGFL,XWB$W_STS(R5),90$ ; Br if no flow ctl
	BRB	80$				   ; Neg values are ok
57$:	BRB	130$			; 
60$:	MOVAB	XWB$T_LI(R5),R2		; Use INT/LS subchannel
	MOVAB	W^INT_FLOW,R3		; Setup action routine address
70$:	TSTB	R0			; Check flow control value
	BLSS	120$			; Negative values are illegal
80$:	ADDB	LSB$B_XREQ(R2),R0	; Check effect of adding to
					; current count 
	BVS	120$			; Br if overflow
90$:	BLBC	R1,100$			; Br if 'stop' bit clear
	BISW	#XWB$M_FLG_WBP,-	; Turn on backpressure
		 XWB$W_FLG(R5)		;
100$:	BBC	#1,R1,105$		; Br if 'start' bit clear
	BICW	#XWB$M_FLG_WBP,-	; Turn off backpressure
		 XWB$W_FLG(R5)		;
	;
	;   Call action routine with R5 = XWB, R2 = LSB, R0 = new XREQ.
	;   On return, all but R0,R1,R2,R3 must be preserved.
	;
105$:	JSB	(R3)			; Update request count
	BRB	50$			; Loop until done
	;
	;   Process interrupt data.  If the mailbox if full then wait and
	;   try again later.  If no mailbox then also wait and try again
	;   later.  Note that the link will permanently hang in this case
	;   -- this is okay since a user error has caused the local and
	;   remote processes not to cooperate !
	;
110$:	MOVAB	XWB$B_DATA(R5),R1	; Get interrupt data string
	MOVZBL	(R1),R2			; Get data size
	INCL	R2			; Account for count field
	MOVL	#MSG$_INTMSG,R8		; Setup mbx msg type
	BSBW	NET$SEND_CS_MBX		; Build and send message to mbx
	BLBC	R0,120$			; Br on failure
	CMPW	R0,#SS$_NOMBX!1		; Was the 'success' implicit due
					; to no mailbox ?
	BEQL	120$			; If so then treat as error
	BISW	#XWB$M_STS_SIFL,-	; Cause interrupt flow control
		 XWB$W_STS(R5)		; to be sent
	BICW	#XWB$M_STS_LKDB,-	; Free the XWB resident data
		 XWB$W_STS(R5)		; buffer 
	BRW	50$			; Loop
	;
	;   120$ is called to restore a bit in the mask because a message
	;   in the receive vector could not be processed for some reason.
	;   There is no guarentee that further progress on the link will
	;   ever be possible, but a stalled link will be detected by an
	;   eventual zero value in XWB$W_PROGRESS.
	;
120$:	BBCS	R6,R7,130$		; restore bit
130$:	MOVB	R7,XWB$B_LI_RMSK(R5)	; Update INT/LS receive vector
					; mask
	MOVB	#1,R0			; Set success
	POPL	R6			; Restore reg
	RSB
		.DSABL	LSB

DAT_FLOW:				; Process DATA flow control
	MOVB	R0,LSB$B_XREQ(R2)	; Store new flow control value

;-
; NET$GET_DT_HXS  -  Upate value of 'highest xmit segment sendable'
;
; FUNCTIONAL DESCRIPTION
;
; The DATA channels Link Subchannel Block (LSB) is processed in 
; conjunction with the transmitter's flow control type and the
; transmitter's IRP queue to determine the value of the highest
; transmittable segment.  This value is replaces LSB$W_HXS.
;
; INPUTS:   R5	XWB address
;	    R3	Scratch
;	    R2	DATA channel LSB address
;	    R1	Scratch
;	    R0	Scratch
;
; OUTPUTS:  R5	Preserved
;	    R3	Garbage
;	    R2	Preserved
;	    R1	Garbage
;	    R0	Garbage
;
; SIDE EFFECTS:
;
; If updating LSB$W_HXS means that we may now send a data segment,
; an XWB fork process is scheduled.
;
;-
NET$GET_DT_HXS:
	MOVW	LSB$W_LUX(R2),R1		   ; Get number of high
						   ; segment queued
	MOVW	R1,LSB$W_HXS(R2)		   ; Assume no flow ctl
	BBS	#XWB$V_STS_MSGFL,XWB$W_STS(R5),10$ ; Br if msg flow ctl
	BBC	#XWB$V_STS_SEGFL,XWB$W_STS(R5),30$ ; Br if no  flow ctl
	;
	; Segment flow control
	;
	MOVZBL	LSB$B_XREQ(R2),R0	; Get number of segs requested
	ADDW	LSB$W_HAR(R2),R0	; Calc. highest seg requested
	EXTV	#0,#12,R0,R0		; Sign extend low 12 bits
	SUBW3	R0,R1,R3		; Get distance from XWB$W_LUX
	EXTV	#0,#12,R3,R3		; MUST SIGN EXTEND
	BLEQ	30$			; Br if high seg requested is
					; LEQ high seg available
	MOVW	R0,LSB$W_HXS(R2)	; Else it's highest we can send
	BRB	30$
	;
	; Message flow control
	;
10$:	MOVAB	LSB$Q_XMT(R2),R3	; Get IRP listhead
	MOVZBL	LSB$B_XMTS(R2),R0	; Get number of IRPs
	CMPB	LSB$B_XREQ(R2),R0	; Is XREQ < XMTS
	BGEQ	15$			; If so use it instead
	MOVZBL	LSB$B_XREQ(R2),R0
15$:	TSTB	R0				  ; Anything to send ?
	BEQL	50$				  ; Br if not
20$:	MOVL	(R3),R3				  ; Get next IRP
	SOBGTR	R0,20$				  ; Scan down IRP list
	MOVW	IRP$W_X_FNX(R3),LSB$W_HXS(R2) 	  ; Update HXS
	;
	;   set XWB$V_FLG_WHGL = (LSB$W_HXS > LSB$W_LNX)
	;
30$:	SUBW3	LSB$W_HXS(R2),LSB$W_LNX(R2),R0	  ; Compare seg numbers
	EXTV	#0,#12,R0,R0			  ; MUST SIGN EXTEND
	BGEQ	50$				  ; Br if LNX leq HXS
	BBCC	#XWB$V_FLG_WHGL,XWB$W_FLG(R5),40$ ; Clear wait flag
40$:	RSB
50$:	BISW	#XWB$M_FLG_WHGL,XWB$W_FLG(R5)	  ; Set wait flag
	RSB



INT_FLOW:				; Process INT flow control
	MOVB	LSB$B_XREQ(R2),R3	; Get old flow control value
	MOVB	R0,LSB$B_XREQ(R2)	; Store new value
					; and fall through
;+
; NET$CHK_INTFLOW	- Update transmitter's INT/LS flow control
;
; FUNCTIONAL DESCRIPTION
;
; The routine is called after the number of Interrupt message IRPs
; increases or after the transmitters Interrupt message flow control
; increases.  The action is to check the former value of the LSB field.
; If it had been zero before the change, and if an Interrupt message
; may now be sent, then the need to send an Interrupt message is
; signalled by setting XWB$W_STS_IAVL.
;
; INPUTS:   R5	XWB address
;	    R3	Former value of updated LSB field (NET$UPD_INTFLOW only)
;	    R2	INT/LS subchannel LSB address
;
; OUTPUTS:  All registers are preserved.
;-
NET$CHK_INTFLOW:			; Check to see if INT msg is to
					; be built and sent
	TSTB	R3			; Is old value zero ?
	BNEQ	10$			; If not no real change in state
	TSTB	LSB$B_XMTS(R2)		; Any IRPs ?
	BEQL	10$			; If not, branch
	TSTB	LSB$B_XREQ(R2)		; Any requested ?
	BEQL	10$			; If not, branch
	BISW	#XWB$M_STS_IAVL,-	; Schedule INT message
		 XWB$W_STS(R5)
10$:	RSB

;++
; NET$RCV_DATA	- Process received DATA message
;
; FUNCTIONAL DESCRIPTION
;
; A received data message is processed.  If it is acceptable then the
; IRP's message buffer (CXB) is moved from the Transport IRP to the XWB.
; The routine then falls thru to NET$PROC_CXB.
;
;
; INPUTS:
;
;	R10	NDC counter block
;	R8	DATA LSB pointer
;	R7	Scratch
;	R6	Transport IRP address
;	R5	XWB address
;	R4	Scratch
;	R3	Scratch
;	R2	Number of as yet unaccounted bytes in message
;	R1	Pointer to first unparsed byte in message
;	R0	Scratch
;
; OUTPUTS:
;
;	R6	Transport IRP address
;	R5	XWB address
;	R0	Standard VMS status code
;
;	R8,R7,R4,R3,R2,R1 are garbage, all others are unmodified
;
;--
NET$RCV_DATA:				; Process rcv'd DATA msg
	BISW   #XWB$M_FLG_SDACK,XWB$W_FLG(R5)	; Cause ACK to be sent	
	MOVAB	XWB$T_DT(R5),R8		; Get DATA LSB
	MOVW	(R1)+,R3		; Get SEG field
	BGEQ	10$			; If LSS then really ACK field
	BSBW	NET$PIG_ACK		; Parse and process the ACK
10$:	EXTV	#0,#12,R3,R3		; Sign extend low 12 bits
	SUBW3	LSB$W_HAX(R8),R3,R4	; Get distance from highest ACK
	EXTV	#0,#12,R4,R4		; MUST SIGN EXTEND
	BLEQ	12$			; If LEQ then we saw this before
	CMPW	R4,#8		;&tmp	; Max rcv pipeline = 8 ** tmp **
	BLEQ	15$			; Br if within range
12$:	BRW	NET$PROC_CXB		; Ignore if out of range
	;
	;   Link the CXB into the list
	;
15$:	BLBS	IRP$B_EFN(R6),12$	; If LBS then can't take buffer
	MOVAB	XWB$L_RCVCXB -		;
		-CXB$L_LINK(R5),R4	; Get CXB listhead
	BRB	30$			; Continue
20$:	MOVL	R0,R4			; Chain down linked list
30$:	MOVL	CXB$L_LINK(R4),R0	; Get next CXB
	BEQL	40$			; If EQL then end of list
	SUBW3	CXB$W_SEG(R0),R3,R7	; CXBs are chained in ascending
	EXTV	#0,#12,R7,R7		; order of their SEG numbers
	BGTR	20$			; If GTR then position not found yet
	BEQL	NET$PROC_CXB		; Br if already on list
40$:	MOVL	IRP$L_IOSB(R6),R7	; Get CXB address
	CLRL	IRP$L_IOSB(R6)		; Signal that CXB is gone
	MOVL	R0,CXB$L_LINK(R7)	; Chain tail of list to CXB
	MOVL	R7,CXB$L_LINK(R4)	; Chain CXB to head of list
	MOVW	R3,CXB$W_SEG(R7)	; Enter SEG value
	MOVL	R1,(R7)			; Enter pointer to data
	MOVW	R2,CXB$W_LENGTH(R7)	; Enter length of data
	UPDATE	L,R2,NDC$L_BRC(R10)	; Add to total for this remote node
	SUBW3	R7,R1,CXB$W_OFFSET(R7)	; Enter offset to data
	DECB	LSB$B_RREQ(R8)		; Account for rcv'd segment
	MOVB	XWB$B_MSGTYP(R5),-	;
		CXB$B_CODE(R7)		; Store EOM,BOM flags
	TSTB	XWB$B_INC_RFLW(R5)	; Piplelining in use?
	BNEQ	45$			; If NEQ then yes, check flow control
	BBS    #NSP$V_EOM,-		; If not 'end of msg' then we 
		CXB$B_CODE(R7),50$	; must flow control another seg
45$:	BSBW	INC_DT_RFLW		; See if flow control message is needed
50$:	;
	;
	;   ACK as many segments as possible 
	;
	;
	SUBW3	LSB$W_HAX(R8),-		; Get distance from highest
		CXB$W_SEG(R7),R3	; ACK to be transmitted
	EXTV	#0,#12,R3,R3		; MUST SIGN EXTEND
	DECW	R3			; Did distance = 1 ?
	BNEQ	NET$PROC_CXB		; Br if not -- no more to ACK
	MOVW	CXB$W_SEG(R7),-		; Else update ACK to send
		LSB$W_HAX(R8)		;
	MOVL	CXB$L_LINK(R7),R7	; Get next CXB
	BNEQ	50$			; Br unless none left
					; Else fall thru

;+
; NET$PROC_CXB	- Move received CXBs to user IRPs
;
; FUNCTIONAL DESCRIPTION
;
; Move as many CXBs as possible to the associate IRP.  Return as many 
; IRPs as possible to the user.
;
; INPUTS:
;
;	R8	DATA LSB address
;	R5	XWB address
;
;	R0-R4,R7 are scratch
;
; OUTPUTS:
;
;	R8	Preserved
;	R5	Preserved
;	R0	SS$_NORMAL
;
;	R1,R2,R3,R4,R7 are garbage
;
;-
NET$PROC_CXB:
	TSTB	LSB$B_RCVS(R8)		; Any receive IRPs ?
	BEQL	20$			; If not, branch
	BBS    #XWB$V_STS_LKRCV,-	; Br if rcv queue interlocked
		    XWB$W_STS(R5),20$	;
	MOVL	XWB$Q_DT_RCV(R5),R3	; Get next IRP
	MOVL	XWB$L_RCVCXB(R5),R7	; Get first CXB
	BEQL	20$			; If EQL then no CXBs left
	SUBW3	XWB$W_DT_HRM(R5),-	; Get distance from 'highest
		CXB$W_SEG(R7),R0	; rcv segment moved'
	EXTV	#0,#12,R0,R0		; MUST SIGN EXTEND
	DECW	R0			; Was it one away ?
	BEQL	30$			; If so, branch
20$:	MOVL	S^#SS$_NORMAL,R0	; Set status
	RSB

30$:	MOVB	CXB$B_CODE(R7),R4	; Get message flags (EOM flag)
	MOVL	IRP$L_SVAPTE(R3),R2	; Get buffer attached to IRP
	BNEQ	40$			; Br if buffer attached
	BBS    #NSP$V_EOM,R4,37$	; Br if last (i.e., only) seg
	BBS    #IRP$V_CHAINED,-		; Br if requestor wants chained
		IRP$W_STS(R3),37$
	;
	;   The user wants only one buffer and the message spans more
	;   than one segment.  This will occur if the "user" is a higher
	;   level driver and not the QIO service.  In order to share
	;   code, the buffer is setup to be a hybrid of both complex
	;   chained and buffered I/O.
	;
	MOVZWL	IRP$W_OBCNT(R3),R1	; Get size of buffer data area
	ADDL   #CXB$C_LENGTH,R1		; Add in header size
	BSBW	NET$ALONONPAGED		; Attempt to allocate buffer
	BLBC	R0,20$			; Retry later if failure
	MOVW   #CXB$C_LENGTH,-		; Set offset to data area
		CXB$W_OFFSET(R2)
	MOVAL	CXB$C_LENGTH(R2),(R2)	; Set pointer to data area
	CLRW	CXB$W_LENGTH(R2)	; Initialize data length
	MOVL	XWB$Q_DT_RCV(R5),R3	; Recover IRP pointer
	MOVL	R2,IRP$L_SVAPTE(R3)	; Store buffer address
	BRB	40$
	;
	;   The user either wants chained buffers (e.g., QIO) or the
	;   message is contained in one segment.  In the latter case,
	;   single buffer chain and a non-chained buffer are the same.
	;
37$:	BISB   #IRP$M_NET_CHN,IRP$B_NET(R3)	; Set for chained buffers
	MOVAB	-CXB$L_LINK+IRP$L_SVAPTE(R3),R2	; Setup for linkage
40$:	MOVL	CXB$L_LINK(R7),XWB$L_RCVCXB(R5)	; Remove CXB form list
	MOVW	CXB$W_SEG(R7),XWB$W_DT_HRM(R5)	; Set 'high rcv moved'
	BLBC	IRP$L_IOST1(R3),60$		; Br if error encountered
	ADDW	CXB$W_LENGTH(R7),IRP$W_ABCNT(R3); Update total length
	SUBW3	IRP$W_ABCNT(R3),IRP$W_OBCNT(R3),R0 ; Overrun ?
	BGEQ	50$				; If not, branch
	ADDW	R0,CXB$W_LENGTH(R7)		; Else adjust data size
	MOVW	IRP$W_OBCNT(R3),IRP$W_ABCNT(R3)	; Set ABCNT to max
	MOVW	#SS$_DATAOVERUN,IRP$L_IOST1(R3)	; Set I/O status
	;
	;   Either move the CXB data or append the CXB to the chain
	;
50$:	BBS    #IRP$V_NET_CHN,IRP$B_NET(R3),80$	; Br if chained buffers
	PUSHR  #^M<R2,R3,R4,R5>			; Save important regs
	ADDW	CXB$W_LENGTH(R7),-		; Update buffer's data 
		CXB$W_LENGTH(R2)		; length
	MOVC	CXB$W_LENGTH(R7),@(R7),@(R2)	; Move the data
	MOVL	R3,@(SP)			; Update data area ptr
	POPR   #^M<R2,R3,R4,R5>			; Restore regs
60$:	MOVL	R7,R0				; Copy address for JSB
	JSB	G^COM$DRVDEALMEM		; Deallocate buffer
	BRB	90$				; Continue
70$:	MOVL	R0,R2				; Travel CXB list
80$:	MOVL	CXB$L_LINK(R2),R0		; Is this the end ?
	BNEQ	70$				; If not, branch
	MOVL	R7,CXB$L_LINK(R2)		; Link CXB into list
	CLRL	CXB$L_LINK(R7)			; Mark it as last entry
	;
	;   If this is not the last segment then process the next CXB.
	;   Else setup the I/O completion status.  If buffer overrun
	;   occured then the xfer size is the size of the user request,
	;   else its the number of accumulated bytes.
	;
90$:	BBC    #NSP$V_EOM,R4,120$		; Br unless last seg
	BICB   #IRP$M_NET_INUSE,IRP$B_NET(R3)	; Done with IRP
	MOVZWL	IRP$W_ABCNT(R3),R0		; Get bytes to be given to user
	BSBW	NET$RCV_POST			; Try to post the IRP
120$:	BRW	NET$PROC_CXB			; Loop until done

;+
; NET$TIMER	- Netdriver clock
;
; *** t.b.s.***
;
;
;
;-
NET$TIMER:					; ...tick...
	PUSHR	#^M<R4,R5,R10>			; Save regs
	DSBINT	UCB$B_FIPL(R4)			; Raise to driver IPL
	MOVL	UCB$L_VCB(R4),R2		; Get RCB
	;
	;   If mount count = 0 then we're shutting down the network -- stop
	;   the clock and signal NETACP by deactivating the local LPD.
	;
	TSTW	RCB$W_MCOUNT(R2)		; Still active
	BNEQ	5$				; If NEQ then yes
	BSBW	TR$KILL_LOC_LPD			; Kill the local LPD
	BLBC	R0,20$				; Br on error
	BICB	#TQE$M_REPEAT,TQE$B_RQTYPE(R5)	; Stop the clock
	BRB	20$
	;
	;
	;   Call the Transport layer and DLE timer service routines
	;
5$:	BSBW	TR$TIMER			; Call Transport layer timer
	BSBW	DLE$TIMER			; Call DLE timer
	;
	;
	;   Process all NSP level clocks
	;
	MOVL	RCB$L_PTR_LTB(R2),R4		; Get LTB 
	BEQL	20$				; If EQL then none
	MOVAB	-XWB$L_LINK+LTB$L_XWB(R4),R5	; Prepare for scan
10$:	MOVL	XWB$L_LINK(R5),R5		; Get next XWB
	BEQL	20$				; If EQL then none left
	INCW	XWB$W_ELAPSE(R5)		; Track elapsed time
	DECW	XWB$W_TIMER(R5)			; Update time left
	BGTRU	10$				; Br unless timeout
	MOVZWL	XWB$W_REMNOD(R5),R10		; Get remote node address
	BSBW	GET_NDC_BLK			; Point to its counter block
	BSBB	TIMEOUT				; Process timeout
	BRB	10$				; Loop
	;
	;
	;   Return to the Exec
	;
20$:	ENBINT					; Restore IPL
	POPR	#^M<R4,R5,R10>			; Restore context
	RSB


			.ENABL	LSB

TIMEOUT:
	$DISPATCH TYPE=B,XWB$B_STA(R5),-	; Dispatch on link state
		<-
		<XWB$C_STA_RUN, T_O_RUN>,-	; RUN state
		<XWB$C_STA_CCS, T_O_CC>,-	; Connect Confirm Sending state
		<XWB$C_STA_DIS, T_O_DI>,-	; Disconnect Init Sending state
		>				; else,  fall thru
	BRB	70$				; 

T_O_CC:						; Timeout xmting CC msg
T_O_DI:						; Timeout xmting DI msg
	BISW   #XWB$M_FLG_SCD,XWB$W_FLG(R5)	; Set 'send Connect/disconnect
	BRB	70$				; Process timeout
T_O_RUN:
	;
	;
	;   Force a retransmission of all unACKed messages.  If there are no
	;   unACKed messages then nothing has timed-out and its time to set
	;   the inactivity timer.
	;
	;
	BICW3	#^C<XWB$M_STS_VER>,XWB$W_STS(R5),R0 ; Get the NSP version
	CMPW	R0,#NSP$C_VER_V31		; Is it V3.1?
	BEQL	100$				; If EQL yes, Phase II
	CLRL	R1				; Clear retransmit flag
	MOVAB	XWB$T_DT(R5),R0			; Get DATA LSB
	BSBB	RESET				; Reset the subchannel
	BLBC	R0,50$				; If LBC no rexmission needed
	BICW   #XWB$M_FLG_WHGL,XWB$W_FLG(R5)	; Clear wait condition
50$:	MOVAB	XWB$T_LI(R5),R0			; Get LI LSB
	BSBB	RESET				; Reset the subchannel
	BLBC	R0,60$				; If LBC no retransmit needed
	BISW   #XWB$M_FLG_SLI,XWB$W_FLG(R5)	; Set 'send LI' flag
60$:	BLBS	R1,70$				; If LBS then retransmit needed
	MOVW	XWB$W_TIM_INACT(R5),-		;
		XWB$W_TIMER(R5)			; Reset timer
	;
	;   Cause (possibly null) flow control message to be sent in order to 
	;   cause the partner node to send an ACK.   This is done to make sure
	;   that the partner node is still there.  
	;
	BISW  #XWB$M_STS_SDFL,XWB$W_STS(R5)	; Cause flow ctl msg to be built 
	BRB	80$				; Continue 
70$:	;
	;    Common timeout processing
	;
	BUMP	W,NDC$W_RTO(R10)		; Account for response timeout
	BSBB	DEC_PROGRESS			; Decrement progress count
80$:	BSBW	NET$FORK			; Fork to do new work
100$:	RSB

			.DSABL	LSB



RESET:	CMPW	LSB$W_HAR(R0),LSB$W_LNX(R0)	; Anything to rexmt ?
	BEQL	10$				; If EQL, no rexmt needed
	MOVW	LSB$W_HAR(R0),LSB$W_LNX(R0)	; Rexmt all unACKed segs
	CMPW	LSB$W_LNX(R0),LSB$W_HXS(R0)	; Anything to send ?
	BEQL	10$				; If EQL, no
	INCB	R0				; Indicate this LSB was reset
	MOVL	#1,R1				; Set retransmit flag
10$:	RSB

DEC_PROGRESS:					; Decrement progress count
	DECW	XWB$W_PROGRESS(R5)		; Account for lack of progress
	BGTR	10$				; If GTR then okay
	BSBB	NET$MARK_LINK			; Mark link for break
	BISW   #XWB$M_STS_TMO,XWB$W_STS(R5)	; Indicate timeout
	TSTW	XWB$W_REASON(R5)		; Reason code set yet?
	BNEQ	10$				; If NEQ then yes
	MOVW   #NET$C_DR_NOPATH,XWB$W_REASON(R5); Setup reason code
10$:	BRW	SET_TIMER			; Set NSP timer


NET$MARK_LINK:					; Mark the link for break
	BISW	#XWB$M_FLG_BREAK,XWB$W_FLG(R5)	; Mark link for abort
	MOVW	#2,XWB$W_TIMER(R5)		; Wait 2 seconds
	MOVW	#1,XWB$W_PROGRESS(R5)		; Force an event
	RSB					; Done


TIMED_SEG_ACKED:			; Timed segment has been ACK'd
	;
	;    INPUTS:	R5  XWB pointer
	;		R0  Scratch
	;
	;    OUTPUTS:	R0  Garbage
	;
	;		All other regs are unchanged
	;
	;
	;    Update delay estimate as a function of the former delay, the new 
	;    round trip time (delta) and the 'weight' parameter (this value is 
	;    store after being incremented by one).  The following shows the 
	;    derivation of the formula used to compute 'delay'.
	;
	;     delay = ((delay*weight)+delta)/(weight+1)
	;     delay = delay + ((delta-delay)/(weight+1))
	;
	;     elapse = delta - delay	('elapse' is biased to minus 'delay' 
	;				(when the msg was first sent and 
	;				(incremented each clock tick - it may 
	;				(be negative
	;
	;     delay = delay + elapse/(weight+1)
	;
	;
	MOVW	XWB$W_ELAPSE(R5),R0	; Get elapsed time
	BGEQ	5$			; If GEQ then arrived late
	MNEGW	R0,R0			; Convert to positive number
	DIVW	XWB$W_DLY_WGHT(R5),R0	; Get weighted adjustment
	SUBW	R0,XWB$W_DELAY(R5)	; Get new delay value
	BRB	25$			; 
5$:	DIVW	XWB$W_DLY_WGHT(R5),R0	; Get weighted adjustment
	ADDW	XWB$W_DELAY(R5),R0	; Get new delay value
	CMPW	R0,#NSP$C_MAXDELAY	; Compare  against max delay allowed
	BLEQU	20$			; If LEQ (unsigned) then okay
	MOVZWL	#NSP$C_MAXDELAY,R0	; Else use the max delay allowed
20$:	SUBW3	#1,R0,XWB$W_DELAY(R5)	; Update the delay
25$:	BGTR	30$			; If GTR (signed) then okay
	MOVW	#1,XWB$W_DELAY(R5)	; Use 1 sec as minimum delay
30$:	MOVW	XWB$W_RETRAN(R5),-	; Init PROGRESS
		XWB$W_PROGRESS(R5)	;
	BICW   #XWB$M_STS_TID!-		; Timer is unowned and
		XWB$M_STS_TLI,-		; init subchannel indicator to known
		XWB$W_STS(R5)		; value
	;
	;
	;    See if an already xmitted segment is waiting to be ACK'd.  
	;
	;    On the LI sub-channel, since neither negative flow control or
	;    backpressure are allowed, this is merely a matter of checking 
	;    for HAR < LNX.
	;
	;    On the DATA sub-channel, since negative flow control and back-
	;    pressure are allowed, it is necessary to check for  HAR < LNX,
	;    HAR < HXS, and that the link is not backpressured off.
	;
	;
	;	NOTE:	Since HXS can never grow less than HAR, if HXS is not
	;		equal to HAR then HAR must be less than HXS.  This
	;		fact is used to avoid the messy comparisons otherwise
	;		needed since sequence numbers are stored as sign
	;		extended 12 bit numbers.
	;
	MOVAB	XWB$T_LI(R5),R0			; Get LI sub-channel LSB
	CMPW	LSB$W_HAR(R0),LSB$W_LNX(R0)	; Anything sent but unACK'd
	BNEQ	50$				; If NEQ then yes
	MOVAB	XWB$T_DT(R5),R0			; Get DATA sub-channel LSB
	CMPW	LSB$W_HXS(R0),LSB$W_HAR(R0)	; Is HAR < HXS
	BEQL	40$				; If NEQ then HAR < HXS
	CMPW	LSB$W_HAR(R0),LSB$W_LNX(R0)	; Anything sent but unACK'd
	BEQL	40$				; If NEQ then HAR < LNX
	BBC	#XWB$V_FLG_WBP,XWB$W_FLG(R5),60$; If BC then no backpressure
40$:	MOVW	XWB$W_TIM_INACT(R5),-		; Setup inactivity timer
		XWB$W_TIMER(R5)			;
	RSB

	;
	;
	;   Hand off the timer to the next un-ACKed segment
	;
	;
50$:	BISW	#XWB$M_STS_TLI,XWB$W_STS(R5)	; Timer owner is LI subchannel
60$:	BISW	#XWB$M_STS_TID,XWB$W_STS(R5)	; Timer is owned
	ADDW3	#1,LSB$W_HAR(R0),R0	; Get next unACKed segment number
	EXTV	#0,#12,R0,R0		; Sign extend
	MOVW	R0,XWB$W_TIM_ID(R5)	; Setup timed segment number
					; Fall thru to set timer
					;
SET_TIMER:				; Setup segment timer
	MNEGW	XWB$W_DELAY(R5),-	; Bias the elapsed time timer
		XWB$W_ELAPSE(R5)	;
	MULW3	XWB$W_DLY_FACT(R5),-	;
		XWB$W_DELAY(R5),R0	; Get timer value
	BVC	50$			; If BC then no overflow

	ASSUME	NSP$C_MAXDELAY  LT  <^X7FFF>

40$:	MOVW	#NSP$C_MAXDELAY,R0	; Use max delay
50$:	ADDW3	#1,R0,XWB$W_TIMER(R5)	; Set timer (+1 for clock skew)
	BLEQ	40$			; If LEQ (signed) then overflow
	RSB				; Done


;+
; GET_NDC_BLK	- Get the NDC counter block address
;
;
; INPUTS:	R10	Remote node address - the high order word is clear
;		R2	RCB address
;
; OUTPUTS:	R10	Address of the NDC counter block 
;
;		All other registers are preserved
;-
GET_NDC_BLK:				; Address the NDC counter block
	CMPW	R10,RCB$W_MAX_ADDR(R2)	; Within range?
	BLEQU	10$			; If LEQU then yes
	CLRL	R10			; Use the node 0 counter block
					; (thus the pointer will always be
					;  valid -- the node 0 countes have no
					;  meaning)
10$:	MULL	#NDC$C_LENGTH,R10	; Multiply by size of each cell
	ADDL	#12,R10			; NDC vector starts 12 bytes in 
	ADDL	RCB$L_PTR_NDC(R2),R10	; Add in the base address
	RSB				; Return with low bit clear in R0


;+
; DLE$FDT_RW	- Complete FDT Read/Write buffered I/O
;
; FUNCTIONAL DESCRIPTION
;
; These routines are used for common buffered I/O preprocessing. The
; user buffers are validated and, for write operations, data is moved
; into the allocated buffer.
;
; INPUTS:
;
;	P1(AP)	= Address of user buffer
;	P2(AP)	= Length of user buffer
;	   R1	= XWB address
;	   R2	= Address of buffer access check routine
;	   R3	= IRP address
;	   R4	= PCB address
;	   R5	= UCB address
;
;
; OUTPUTS:
;
;	*** tbs ***
;
;-
DLE$FDT_RW:				; Read/Write FDT
	PUSHL	R3			; Save IRP address
	BICW	#IRP$M_CHAINED!-	; Don't use complex-chained buffers
		 IRP$M_COMPLX,-		;
		 IRP$W_STS(R3) 		;
	MOVL	P1(AP),R0		; Get buffer address
	MOVZWL	P2(AP),R1		; Get buffer size
	CLRW	IRP$W_BOFF(R3)		; No buffer allocated yet
	JSB	(R2)			; Check buffer 
					; - no return on error
	MOVL	(SP),R3			; Recover R3
	JSB	G^EXE$BUFQUOPRC		; Within quota ?
	MOVL	(SP),R3			; Recover R3
	BLBC	R0,40$			; Br if not
	MOVL	PCB$L_JIB(R4),R0	; Get JIB ptr
	SUBL	R1,JIB$L_BYTCNT(R0)	; Account for bytes
	MOVW	R1,IRP$W_BOFF(R3)	; Save for update on completion
	MOVZWL	IRP$W_BCNT(R3),R1	; Get size of buffer to allocate
	ADDW	#12,R1			; Add in buffer header size
	BSBW	NET$ALONONPAGED		; Else allocate the buffer
	BLBC	R0,40$			; Br if none
	POPL	R3			; Retrieve IRP
	MOVL	R2,IRP$L_SVAPTE(R3)	; Store buffer address
	MOVAB	12(R2),(R2)+		; Store data area ptr in buffer
	MOVL	P1(AP),(R2)			; Store user buffer addr
	MOVW	#IO$_REWIND!-			;
		<DLE_EV_READ@8>,IRP$W_FUNC(R3)	; Re-map function code
	BBS	#IRP$V_FUNC,IRP$W_STS(R3),20$	; If set, read fct

	PUSHR	#^M<R3,R5>			; Save MOVC regs
	MOVW	#IO$_REWIND!-			;
		<DLE_EV_WRITE@8>,IRP$W_FUNC(R3)	; Re-map function code
	MOVC3	IRP$W_BCNT(R3),@(R2),8(R2)	; Move user data
	POPR	#^M<R3,R5>			; Restore regs

20$:	JMP	G^EXE$QIODRVPKT			; Give IRP to driver

40$:	POPR	#^M<R3>			; Restore IRP
	JMP	G^EXE$ABORTIO		; Complete with error

;+
; DLE$STARTIO -  Start I/O for line service
;
;	  R8,R7 Scratch
;	  R6 	If "startio" event then UCB address
;	  R5 	Address of XWB
;	  R4 	Scratch
;	  R3 	IRP address
;	  R2,R1	Scratch
;	  R0 =	Scratch
;
; OUTPUTS:
;	  R8,R7	Garbage
;	  R6	Preserved
;	  R5	Preserved
;	  R3-R1	Garbage
;	  R0 	Status code from the action routine to be returned to
;		the caller of the event dispatcher
;-
DLE$STARTIO:				; Line service start I/O
	$DISPATCH  TYPE=B,IRP$W_FUNC+1(R3),- ; Function code has been mapped
	    <-
	    <DLE_EV_ACCESS, DLE_ACCESS>,-
	    <DLE_EV_WRITE,  DLE_WRITE>,-
	    <DLE_EV_READ,   DLE_READ>,-
	>
	BUG_CHECK  NETNOSTATE,FATAL	; Unrecognized event code

DLE_ACCESS:				; Finish IO$_ACCESS processing
	MOVL	S^#SS$_NORMAL,R0	; Setup status
	MOVL	R0,IRP$L_IOST1(R3)	; Here too
	RSB				; Done

DLE_WRITE:				; Finish IO$_WRITE processing
	BSBW	DLE_RW_CHKSTA		; See if okay to read or write
					; -- no return on error
	INSQUE	(R3),@XWB$Q_DLE_XMT+4(R5) ; Insert IRP onto queue
	BISW	#XWB$M_FLG_SDLE,-	; Set 'send direct-line message' flag
		 XWB$W_FLG(R5)		;
	BRW	DLE_RW_WAIT		; Finish in common

DLE_READ:				; Finish IO$_READ processing
	BSBW	DLE_RW_CHKSTA		; See if okay to read or write
					; -- no return on error
	REMQUE	@XWB$Q_DLE_RIRP(R5),R1	; Get waiting Transport rcv IRP
	BVS	50$			; If VS then none
	BSBW	RCV_DONE		; Complete I/O and return Transport IRP
	BRB	DLE_RW_WAIT		; Take common exit

50$:	;
	;   RCV IRP must wait for incoming data
	;
	INSQUE	(R3),@XWB$Q_DLE_RCV+4(R5) ; Insert on wait queue

DLE_RW_WAIT:				; Must wait for I/O to complete
	BISW	#UCB$M_DEV_REQIO,-	; Cause next IRP to be processed
		 UCB$W_DEVSTS(R6)	;
	MOVL	S^#SS$_NORMAL,R0	; Setup status
	RSB				; Done

DLE_RW_CHKSTA:				; See if okay to read or write
	CMPB	#XWB$C_STA_RUN,-	; In the RUN state ?
		 XWB$B_STA(R5)		; 
	BEQL	10$			; If EQL okay
	TSTL	(SP)+			; Pop caller's address
	MOVZWL	#SS$_ABORT,IRP$L_IOST1(R3) ; Setup error status
10$:	RSB				; Done


;+
; DLE$TIMER	- Timer service
;
; The DLE XWB list is scanned and all entries which are found to be no longer
; active are run down.
;
; INPUTS:	R2	RCB address
;
; OUTPUTS:	R0,R1	Destroyed
;
;		All other registers are unchanged.
;
;-
DLE$TIMER::					; Entered every clock tick
	PUSHR	#^M<R2,R3,R4,R5,R6,R7,R8>	; Save regs
	MOVAB	-XWB$L_LINK -			; Prepare for scan
		+RCB$L_DLE_XWB(R2),R5		;
10$:	MOVL	XWB$L_LINK(R5),R5		; Get next XWB
	BEQL	30$				; If EQL then done
	CMPB	XWB$B_STA(R5),#XWB$C_STA_RUN	; In the RUN state ?
	BNEQ	20$				; If so try to run it down
	TSTW	XWB$W_PATH(R5)			; Circuit still associated?
	BNEQ	10$				; If NEQ yes, loop
20$:	BSBB	DLE_RUN_DOWN			; Try to run it down
	BSBW	NET$RET_SLOT			; Try to deallocate it
	BRB	10$				; Loop
30$:	POPR	#^M<R2,R3,R4,R5,R6,R7,R8>	; Restore regs
	RSB

;+
; DLE$ACPCAN	- IO$_ACPCONTROL Cancel I/O request
; DLE$DEACCESS	- IO$_DEACCESS I/O request
;
; INPUTS:	R8	Scratch
;		R7	Scratch
;		R6	UCB address
;		R5	XWB address; low bit set if no XWB
;		R4	Scratch
;		R3	IRP address
;		R2	Scratch
;		R1	Scratch
;		R0	Scratch
;
; OUTPUTS:	R6,R5,R3 Preserved
;
;-
DLE$DEACCESS::				; IO$_DEACCESS I/O request
	BSBB	DLE$ACPCAN		; Run down I/O
	MOVB	#XWB$C_STA_CLO,-	; Change state
		 XWB$B_STA(R5)		;
	BISW	#XWB$M_FLG_CLO,-	; Cause XWB to be deallocated when 
		 XWB$W_FLG(R5)		; reference count goes to zero
	RSB

DLE$ACPCAN::				; IO$_ACPCONTROL Cancel I/O request
DLE_RUN_DOWN:				; Run down I/O (expect IO$_ACCESS)
	PUSHR	#^M<R3,R5,R6>		; Save regs
	MOVL	R5,R6			; Copy XWB address to stable reg
	MOVAB	XWB$Q_DLE_RCV(R6),R8	; Get rcv IRP listhead
	BSBB	50$			; Drain it
	MOVAB	XWB$Q_DLE_XMT(R6),R8	; Get xmt IRP listhead
	BSBB	50$			; Drain it
30$:	REMQUE	@XWB$Q_DLE_RIRP(R6),R1	; Get Transport IRP
	BVS	40$			; If VS then none
	BSBW	TR$RCV_DLE_DONE		; Return it
	BRB	30$			; Loop
40$:	POPR	#^M<R3,R5,R6>		; Restore regs
	BICW	#XWB$M_FLG_SDLE,-	; Clear 'send dle' flag
		 XWB$W_FLG(R5)		;
	MOVL	#1,R0			; Indicate success
	RSB

50$:	REMQUE	@(R8),R3		; Get IRP
	BVS	60$			; If VS then none
	MOVL	IRP$L_UCB(R3),R5	; Setup UCB address
	MOVZWL	#SS$_CANCEL,-		; Setup I/O status and zero xfer size
		IRP$L_IOST1(R3)		;
	JSB	G^COM$POST		; Complete the I/O
	BRB	50$			; Loop
60$:	RSB				; Done


;+
; DLE$RCV_MSG	- Receive a message from the Transport layer
;
; INPUTS:	R8	Circuit "path" i.d.
;		R7,R6	Scratch
;		R5	IRP address
;		R4,R3	Scratch
;		R2	RCB address
;		R1,R0	Scratch
;		
; OUTPUTS:	R5	IRP address if LBC in R0
;		R0	LBS if IRP has been queued
;			LBC if IRP is being returned
;
;-
DLE$RCV_MSG::				; Receive message from Transport
	MOVAB	-XWB$L_LINK -		; Prepare for scan
		+RCB$L_DLE_XWB(R2),R0	;
10$:	MOVL	XWB$L_LINK(R0),R0	; Get next XWB
	BEQL	40$			; If EQL then none, return with LBC in
					; R0 to say "IRP being returned"
	CMPW	R8,XWB$W_PATH(R0)	; This it?
	BNEQ	10$			; If NEQ no, continue scan
	CMPB	#XWB$C_STA_RUN,-	; Is it in the RUN state ?
		 XWB$B_STA(R0)		;
	BNEQ	10$			; If NEQ no, can't receive the msg
	MOVL	R5,R1			; Copy IRP address
	MOVL	R0,R5			; Switch to XWB context
	REMQUE	@XWB$Q_DLE_RCV(R5),R3	; Get waiting user rcv IRP
	BVC	50$			; If VC then got one
	INSQUE	(R1),@XWB$Q_DLE_RIRP+4(R5) ; Queue the Transport IRP
	MOVL	#1,R0			; Indicate "IRP not being returned"
40$:	RSB				; Return to Transport

50$:	;
	;   Complete user IRP and return Transport IRP to Transport
	;
	BSBB	RCV_DONE		; Complete user IRP
	MOVL	#1,R0			; Say "IRP not being returned"
	RSB				; Return to Transport

;+
; RCV_DONE	- Complete User and Transport rcv IRPs
;
; INPUTS:	R4	Scratch
;		R3	User IRP
;		R2	Scratch
;		R1	Transport IRP
;		R0	Scratch
;
; OUTPUTS:	R4-R0 may be garbaged
;
;-
RCV_DONE:				; Complete User and Transport rcv IRPs
	PUSHL	R5			; Save reg
	;
	;   Always return success in the IOSB to avoid the possibility that the
	;   user will deaccess the circuit.  The normal error/recovery
	;   mechanisms in the user process should be sufficient to overcome any
	;   real problems.   The only exception is if the SS$_DATAOVERUN return
	;   if the user's buffer is too small.
	;
	MOVW	#SS$_NORMAL,-		; Assume success
		IRP$L_IOST1(R1)		;
	MOVZWL	IRP$L_IOST1+2(R1),R0	; Get bytes received
	CMPW	R0,IRP$W_BCNT(R3)	; Bigger than user buffer?
	BLEQU	10$			; If LEQU no
	MOVW	IRP$W_BCNT(R3),R0	; Use user buffer size
	MOVW	#SS$_DATAOVERUN,-	; Setup error code 
		IRP$L_IOST1(R1)		; 
10$:	MOVW	IRP$L_IOST1(R1),-	; Setup I/O status
		IRP$L_IOST1(R3)		;
	MOVW	R0,IRP$W_BCNT(R3)	; Setup bytes to xfer
	MOVW	R0,IRP$L_IOST1+2(R3)	; ...and in IOSB image as well
	BEQL	20$			; If EQL then no data to move
					;
	PUSHR	#^M<R1,R2,R3,R4,R5>	; Save regs
	MOVL	@IRP$L_SVAPTE(R1),R1	; Get Transport data pointer
	MOVL	@IRP$L_SVAPTE(R3),R3	; Point to user IRP buffer's data area
	MOVC3	R0,(R1),(R3)		; Move data
	POPR	#^M<R1,R2,R3,R4,R5>	; Restore regs
					;
20$:	BSBW	TR$RCV_DLE_DONE		; Return IRP (in R1)  to Transport
	MOVL	IRP$L_UCB(R3),R5	; Setup UCB address
	JSB	G^COM$POST		; Post user's I/O
	POPL	R5			; Restore reg
	RSB				; Done

;+
; DLE$XMT_DENIED - Circuit unavailable for trasnmission
;
; Permission to xmit has been denied by the Transport layer.  This is most
; likely because the line has gone done.   The ACP will eventually try to bring
; up the circuit again but in the meantime we don't want the user to deaccess
; the circuit.  Therefore, report that the I/O has completed successfully and
; let the user's error/recovery logic detect that the remote node has node 
; responded to the trasnmission.
; 
;
; INPUTS:	R5		XWB address
;		R8-R6, R4-R0	Scratch
;
; OUTPUTS:	R5		Preserved
;		R8-R6, R4-R0	Garbage
;
;		All other registers are preserved
;
;-
DLE$XMT_DENIED::			; Circuit unavailable for trasnmission
	REMQUE	@XWB$Q_DLE_XMT(R5),R1	; Get user IRP
	BVS	100$			; If VS then none
	BSBW	DLE_CMPL_XMT		; Report success
100$:	RSB
;+
; DLE$XMT_MSG	- Send message over direct-accessed circuit
;
; INPUTS:	R8,R7	Scratch
;		R5	XWB address
;		R4	Scratch
;		R3	Address of next byte in output message
;		R2-R0	Scratch
;
; OUTPUTS:	R3	Address of first byte beyond the constructed message
;		R1	User bytes entered into message to be recorded as
;			bytes to user
;		R0	1 if message is to be xmitted,
;			0 otherwise
;	
;		R8,R7,R2  may be clobbered, all others are unmodified.
;
;-
		.ENABL	LSB
DLE$XMT_MSG::				; Send msg over direct-accessed circuit
	REMQUE	@XWB$Q_DLE_XMT(R5),R1	; Get user IRP
	BVS	100$			; If VS then none
	MOVZWL	#SS$_ABORT,-		;
		IRP$L_IOST1(R1)		; Assume circuit has been dis-associtated
	TSTW	XWB$W_PATH(R5)		; Is circuit still associated?
	BEQL	5$			; If EQL then no
	MOVL	XWB$L_VCB(R5),R2	; Get RCB
	CMPW	IRP$W_BCNT(R1),-	; Is user message too big?
		RCB$W_ECLSEGSIZ(R2)	;
	BLEQU	10$			; If LEQU then okay
	MOVZWL	#SS$_TOOMUCHDATA,-	; Indicate error
		IRP$L_IOST1(R1)		;
5$:	CLRL	R0			; Say "no message to xmit"
	BRB	50$			; Complete user I/O and return
10$:	;
	;   Move data to Transport's buffer
	;	
	PUSHR	#^M<R1,R2,R4,R5>	; Save regs
	MOVL	@IRP$L_SVAPTE(R1),R0	; Point to data area in buffer
	MOVC3	IRP$W_BCNT(R1),(R0),(R3); Move data to Transport buffer
					; ...update R3
	POPR	#^M<R1,R2,R4,R5>	; Restore regs	

DLE_CMPL_XMT:
	;
	;   Complete user I/O with success.  This is a little premature since
	;   the I/O is not done yet, but there are other means for detecting
	;   a failed line.
	;
	MOVW	#SS$_NORMAL,-		; Report success 
		IRP$L_IOST1(R1)		;
	MOVW	IRP$W_BCNT(R1),-	; Setup bytes xferred
		IRP$L_IOST1+2(R1)	;
	MOVL	#SS$_NORMAL,R0		; Tell Transport "okay to xmt message"
					;
50$:	PUSHR	#^M<R0,R3,R5>		; Save regs
	MOVL	R1,R3			; Move IRP to expect reg
	MOVL	IRP$L_UCB(R3),R5	; Get UCB
	JSB	G^COM$POST		; Post user I/o
	POPR	#^M<R0,R3,R5>		; Restore regs
					;
100$:	RSB				; Done

		.DSABL	LSB

.END

