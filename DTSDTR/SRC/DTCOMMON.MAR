	.TITLE	TST$DTCOMMON - COMMON ROUTINES FOR DTS/DTR
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY: DTS/DTR DECNET TEST PACKAGE
;
; ABSTRACT: MISCELLANEOUS ROUTINES COMMON TO DTS/DTR.
;
; ENVIRONMENT: DTS/DTR RUN IN USER MODE AND REQUIRE NETWORK PRIVILEGE.
;
; AUTHOR: JAMES A. KRYCKA,	CREATION DATE: 11-AUG-77
;
; MODIFICATIONS:
;
;	V02-003	SGD2003		Scott G. Davis	17-Nov-1980
;		Add check for new code - SS$_LINKABORT
;	V02-002	SGD2002		Scott G. Davis	29-Sep-1980
;		Get around problem with multiple outstanding I/O
;--

	.SBTTL	DECLARATIONS

;
; INCLUDE FILES:
;
	EFNDEF				; DEFINE EFN'S AND FUNCTION CODES
	$QIODEF				; DEFINE QIO OFFSETS
	$RABDEF				; DEFINE RAB OFFSETS
	$RMSDEF				; DEFINE RMS COMPLETION CODES
	$SSDEF				; DEFINE SYSTEM SERVICE STATUS CODES
	.IIF NE	K_LIST_MEB, .LIST MEB	; DEFINED IN DTPREFIX.MAR
;
; MACROS:
;
;	NONE
;
; EQUATED SYMBOLS:
;
;	NONE
;
; OWN STORAGE:
;
;	NONE

	.SBTTL	TST$CHECK_SS - CHECK SYSTEM SERVICE STATUS CODE
	.PSECT	TST$CODE	NOWRT
C::					; SYMBOL FOR DEBUGGING PURPOSES

;++
; FUNCTIONAL DESCRIPTION:
;
;	TST$CHECK_SS CHECKS THE STATUS CODE IN R0 FOLLOWING A CALL TO A
;	SYSTEM SERVICE. IF FAILURE (EXCEPT AS NOTED BELOW) IS INDICATED
;	THE IMAGE IS TERMINATED WITH R0 AS THE EXIT COMPLETION CODE.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	TST$CHECK_SS
;
; INPUT PARAMETERS:
;
;	R0	SYSTEM SERVICE STATUS CODE
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R1	TST$CHECK_SS COMPLETION CODE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	R1	0 = STATUS CODE IS ABORT (SS$_ABORT) OR
;		    STATUS CODE IS CANCEL (SS$_CANCEL) OR
;		    STATUS CODE IS REJECT (SS$_REJECT) OR
;		    STATUS CODE IS FILE NOT ACCESSED (SS$_FILNOTACC)
;		1 = SUCCESS
;
; SIDE EFFECTS:
;
;	IF THE STATUS CODE INDICATES FAILURE (EXCEPT AS NOTED ABOVE),
;	THE IMAGE IS TERMINATED WITH THE STATUS CODE AS THE EXIT
;	COMPLETION CODE.
;
;--

TST$CHECK_SS::				; CONTROL POINT
	MOVL	#1,R1			; SET RETURN CODE TO SUCCESS
	CMPW	R0,#<SS$_LINKABORT&^XFFFF> ; No, Check for aborted I/O
	BEQLU	10$			; If EQL nonfatal
	CMPW	R0,#<SS$_ABORT&^XFFFF>	; NO, CHECK FOR ABORTED I/O
	BEQLU	10$			; NON-FATAL IF ABORTED
	CMPW	R0,#<SS$_CANCEL&^XFFFF> ; NO, CHECK FOR CANCELLED I/O
	BEQLU	10$			; NON-FATAL IF CANCELLED
	CMPW	R0,#<SS$_REJECT&^XFFFF> ; NO, CHECK FOR CONNECT REJECTED
	BEQLU	10$			; NON-FATAL IF CONNECT REJECTED
	CMPW	R0,#<SS$_FILNOTACC&^XFFFF> ; NO, CHECK FOR FILE NOT ACCESSED
	BEQLU	10$			; OCCURS IF DTR HAS EXITED
	MOVL	S^#SS$_NORMAL,R0	; Treat as success
	BRB	20$			; Take a common exit
10$:	CLRL	R1			; SET RETURN CODE TO FAILURE
20$:	RSB				; EXIT

	.SBTTL	TST$CHECK_RMS - CHECK RMS COMPLETION CODE
	.PSECT	TST$CODE	NOWRT

;++
; FUNCTIONAL DESCRIPTION:
;
;	TST$CHECK_RMS CHECKS THE COMPLETION CODE IN R0 FOLLOWING A CALL
;	TO RMS. IF FAILURE (EXCEPT AS NOTED BELOW) IS INDICATED
;	THE IMAGE IS TERMINATED WITH R0 AS THE EXIT COMPLETION CODE.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	TST$CHECK_RMS
;
; INPUT PARAMETERS:
;
;	R0	RMS COMPLETION CODE
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R1	TST$CHECK_RMS COMPLETION CODE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	R1	0 = RMS COMPLETION CODE IS END-OF-FILE (RMS$_EOF) OR
;		    RMS COMPLETION CODE IS TIME-OUT (RMS$_TMO)
;		1 = SUCCESS
;
; SIDE EFFECTS:
;
;	IF THE RMS COMPLETION CODE INDICATES FAILURE (EXCPET AS NOTED
;	ABOVE) THE IMAGE IS TERMINATED WITH R0 AS THE EXIT COMPLETION CODE.
;
;--

TST$CHECK_RMS::				; CONTROL POINT
	MOVL	#1,R1			; SET RETURN CODE TO SUCCESS
	BLBS	R0,20$			; WAS RMS FUNCTION SUCCESSFUL?
	CMPW	R0,#<RMS$_EOF&^XFFFF>	; NO, CHECK FOR END-OF-FILE
	BEQLU	10$			; NON-FATAL IF END-OF-FILE
	CMPW	R0,#<RMS$_TMO&^XFFFF>	; NO, CHECK FOR TIME-OUT
	BEQLU	10$			; NON-FATAL IF TIME-OUT
	$EXIT_S	R0			; TERMINATE THE IMAGE!!
10$:	CLRL	R1			; SET RETURN CODE TO FAILURE
20$:	RSB				; EXIT

	.SBTTL	TST$CHECK_IOSB - CHECK I/O STATUS BLOCK CODE
	.PSECT	TST$CODE	NOWRT

;++
; FUNCTIONAL DESCRIPTION:
;
;	TST$CHECK_IOSB CHECKS THE STATUS CODE IN THE SPECIFIED I/O STATUS
;	BLOCK FOLLOWING A CALL TO THE QIO SYSTEM SERVICE. IF FAILURE
;	(EXCPET AS NOTED BELOW) IS INDICATED, THE IMAGE IS TERMINATED
;	WITH THE I/O STATUS CODE AS THE EXIT COMPLETION CODE.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	TST$CHECK_IOSB
;
; INPUT PARAMETERS:
;
;	R0	ADDRESS OF IOSB TO EXAMINE
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0	I/O STATUS CODE FROM IOSB
;	R1	TST$CHECK_IOSB COMPLETION CODE
;	R2	# BYTES TRANSFERRED FROM IOSB
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	R1	0 = I/O STATUS CODE IS ABORT (SS$_ABORT) OR
;		    STATUS CODE IS CANCEL (SS$_CANCEL) OR
;		    STATUS CODE IS REJECT (SS$_REJECT) OR
;		    STATUS CODE IS FILE NOT ACCESSED (SS$_FILNOTACC)
;		1 = SUCCESS
;
; SIDE EFFECTS:
;
;	IF THE I/O STATUS CODE INDICATES FAILURE (EXCEPT AS NOTED ABOVE),
;	THE IMAGE IS TERMINATED WITH THE STATUS CODE AS THE EXIT
;	COMPLETION CODE.
;
;--

TST$CHECK_IOSB::			; CONTROL POINT
	MOVZWL	2(R0),R2		; EXTRACT BYTE COUNT
	MOVZWL	(R0),R0			; EXTRACT I/O STATUS CODE
	BRB	TST$CHECK_SS		; CHECK I/O STATUS CODE

	.SBTTL	TST$QIOW -  NETWORK QIO ROUTINES
	.PSECT	TST$CODE	NOWRT

;++
; FUNCTIONAL DESCRIPTION:
;
;	BOTH TST$QIOW AND TST$QIOAST COMPLETE BUILDING A QIO PARAMETER
;	BLOCK AND ISSUE A QIO REQUEST FOR THE ESTABLISHED COMMUNICATIONS
;	LINK OR FOR THE ASSOCIATED MAILBOX. THE FUNCTION CODE PARAMETER
;	DETERMINES WHICH OF SEVERAL QIO PARAMETER BLOCKS IS USED.
;	TST$QIOW ISSUES A $QIOW_G REQUEST AND TST$QIOAST ISSUES A
;	$QIO_G WITH AST REQUEST.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	TST$QIOW
;	BSB/JSB	TST$QIOAST
;
; INPUT PARAMETERS:
;
;	R2	INTERNAL FUNCTION CODE; ALSO SPECIFIES EFN TO USE
;	R3	P1 PARAMETER; NOTE: NOT IMPLEMENTED AT PRESENT
;	R4	P2 PARAMETER
;	R5	ADDRESS OF AST ROUTITNE (FOR TST$QIOAST ONLY)
;
; IMPLICIT INPUTS:
;
;	SEVERAL CONTIGUOUS QIO PARAMETER BLOCKS BEGINNING AT TST$PARAMETER.
;
; OUTPUT PARAMETERS:
;
;	R0-R1	DESTROYED
;
; IMPLICIT OUTPUTS:
;
;	REFERENCED QIO PARAMETER BLOCK (OFFSET FROM TST$PARAMETER) IS
;	MODIFIED.
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	ON COMPLETION OF THE QIO ISSUED BY TST$QIOAST, AN AST ROUTINE
;	WILL BE EXECUTED.
;
;--

;
; QIO AND WAIT ROUTINE
;

TST$QIOW::				; CONTROL POINT
	BSBB	QIO_COMMON		; EXECUTE COMMON SET-UP CODE
	CLRQ	QIO$_ASTADR(R0)		; ZERO BOTH AST ADDRESS AND
					;  AST PARAMETER LONGWORDS
	$QIOW_G	(R0)			; ISSUE THE QIO AND WAIT REQUEST
	CHECK_SS			; CHECK STATUS CODE
	RSB				; EXIT

;
; QIO WITH AST ROUTINE
;


TST$QIOAST::				; CONTROL POINT
	BSBB	QIO_COMMON		; EXECUTE COMMON SET-UP CODE
	MOVL	R5,QIO$_ASTADR(R0)	; UPDATE AST ADDRESS
	MOVL	R0,QIO$_ASTPRM(R0)	; UPDATE AST PARAMETER WITH
					;  ADDRESS OF THIS PARAMETER BLOCK
	$QIO_G	(R0)			; ISSUE QIO WITH AST REQUEST
	CHECK_SS			; CHECK STATUS CODE
	RSB				; EXIT

;
; SUBROUTINE THAT PERFORMS COMMON SET-UP FUNCTIONS
;

QIO_COMMON:				; CONTROL POINT
	MULL3	#<QIO$_NARGS+1>,R2,R1	; CALCULATE LONGWORD OFFSET OF
					;  DESIRED QIO PARAMETER BLOCK
					;  FROM THE FIRST PARAMETER BLOCK
	MOVAL	W^TST$PARAMETER[R1],R0	; GET ADDRESS OF PARAMATER BLOCK
	MOVZWL	W^TST$GW_LINKCHAN,QIO$_CHAN(R0) ; UPDATE CHANNEL #
	TSTL	R2			; IS DEVICE THE ASSOCIATED MAILBOX?
	BNEQU	10$			; NO
	MOVZWL	W^TST$GW_MAILCHAN,QIO$_CHAN(R0) ; YES
;10$:	MOVL	R3,QIO$_P1(R0)		; UPDATE BUFFER ADDRESS
10$:	MOVL	R4,QIO$_P2(R0)		; UPDATE P2 PARAMETER (EITHER DESC
					;  BLOCK ADDRESS OR BUFFER SIZE)
	RSB				; EXIT

	.SBTTL	TST$EXAM_MAIL - EXAMINE MAILBOX MESSAGE
	.PSECT	TST$CODE	NOWRT

;++
; FUNCTIONAL DESCRIPTION:
;
;	TST$EXAM_MAIL DISECTS A MAILBOX MESSAGE INTO ITS VARIOUS
;	FIELDS.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	TST$EXAM_MAIL
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	TST$GB_MAILBUF
;	TST$GQ_MAILIOSB
;
; OUTPUT PARAMETERS:
;
;	R0-R1	DESTROYED
;	R6	MAILBOX MESSAGE CODE
;	R7	ADDRESS OF RECEIVED MAILBOX DATA LESS HEADER STORED AS A
;		COUNTED ASCII STRING
;
; IMPLICIT OUTPUTS:
;
;	TST$GW_MAILCODE
;	TST$GW_DEV_UNIT
;	TST$GT_DEV_NAME
;	TST$GT_MAILDATA
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

TST$EXAM_MAIL::				; CONTROL POINT
	PUSHR	#^M<R2,R3,R4,R5>	; SAVE REGISTERS
	MOVAB	W^TST$GB_MAILBUF,R1	; GET ADDRESS OF MAILBOX BUFFER
	MOVZWL	(R1)+,R6		; SAVE MAILBOX MESSAGE CODE
	MOVW	R6,W^TST$GW_MAILCODE	; "
	MOVW	(R1)+,W^TST$GW_DEV_UNIT	; STORE DEVICE DEV_UNIT NUMBER
	MOVZBL	(R1),R0			; GET LENGTH OF DEVICE NAME
					;  COUNTED ASCII STRING
	INCL	R0			;
	MOVC3	R0,(R1),W^TST$GT_DEV_NAME ; STORE DEVICE NAME STRING
	MOVZBL	(R1),R0			; GET LENGTH OF DATA PORTION OF
					;  MESSAGE STORED AS A COUNTED STRING
	INCL	R0			;
	MOVAB	W^TST$GT_MAILDATA,R7	; GET ADDRESS OF COUNTED STRING
					;  TO STORE MESSAGE LESS HEADER
	MOVC3	R0,(R1),(R7)		; STORE MAILBOX MESSAGE LESS HEADER
	POPR	#^M<R2,R3,R4,R5>	; RESTORE REGISTERS
	RSB				; EXIT

	.SBTTL	TST$FLUSH_MAIL - FLUSH MAILBOX
	.PSECT	TST$CODE	NOWRT

;++
; FUNCTIONAL DESCRIPTION:
;
;	TST$FLUSH_MAIL READS THE MAILBOX UNTIL THERE ARE NO MORE MESSAGES
;	QUEUED FOR IT.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	TST$FLUSH_MAIL
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	TST$GB_MAILBUF
;	TST$GQ_MAILIOSB
;
; OUTPUT PARAMETERS:
;
;	R0-R1	DESTROYED
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

TST$FLUSH_MAIL::			; CONTROL POINT
	$QIOW_S	EFN=#EFN_K_READ_MAIL-	; ISSUE READ (NOW) TO MAILBOX
		CHAN=W^TST$GW_MAILCHAN-	;
		FUNC=#IO$_READVBLK!IO$M_NOW- ;
		IOSB=W^TST$GQ_MAILIOSB-	;
		P1=W^TST$GB_MAILBUF-	;
		P2=#TST$K_MAILBUF	;
	CMPW	R0,#<SS$_ENDOFFILE&^XFFFF> ; IS IT AN END-OF-FILE?
	BEQLU	10$			; YES
	CHECK_SS			; CHECK STATUS CODE
	TSTW	W^TST$GQ_MAILIOSB+2	; DID WE RECEIVE ANYTHING?
	BNEQU	TST$FLUSH_MAIL		; YES, READ AGAIN
10$:	RSB				; EXIT

	.SBTTL	TST$PPRINT_FAO - PRINT OUTPUT FROM FAO
	.PSECT	TST$CODE	NOWRT

;++
; FUNCTIONAL DESCRIPTION:
;
;	TST$PRINT_FAO OUTPUTS THE BUFFER FORMATTED BY FAO TO THE PRINT
;	DEVICE.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	TST$PRINT_FAO
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	TST$GB_PRTBUF
;	TST$GW_PRTLEN
;
; OUTPUT PARAMETERS:
;
;	R0-R1	DESTROYED
;
; IMPLICIT OUTPUTS:
;
;	PRTRAB IS UPDATED
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

TST$PRINT_FAO::				; CONTROL POINT
	MOVW	W^TST$GW_PRTLEN,-	; UPDATE BUFFER SIZE IN PRINT RAB
		W^TST$PRTRAB+RAB$W_RSZ	;
	$PUT	RAB=W^TST$PRTRAB	; OUTPUT THE RECORD
	CHECK_RMS			; CHECK COMPLETION CODE
	RSB				; EXIT
TST$FAOOUT::
	.WORD 	0			;FORMAT COUNTED FAO STRING
	MOVAL	-8(SP),SP		;ALLOCATE SPACE FOR DESCRIPTOR
	MOVZBL	@4(AP),(SP)		;CONTROL STRING LENGTH
	ADDL3	#1,4(AP),4(SP)		;ADDRESS CONTROL STRING PORTION
	$FAOL_S	CTRSTR=(SP)-
		OUTLEN=W^TST$GW_PRTLEN-
		OUTBUF=W^TST$GQ_PRTBUF-
		PRMLST=8(AP)
	BSBW	W^TST$PRINT_FAO		;PRINT FAO STRING
	RET

	.SBTTL	TST$DISPLAY_MSG - DISPLAY MESSAGE
	.PSECT	TST$CODE	NOWRT

;++
; FUNCTIONAL DESCRIPTION:
;
;	TST$DISPLAY_MSG DISPLAYS THE MESSAGE LENGTH (IN BYTES) AND UP TO
;	THE SPECIFIED NUMBER OF BYTES OF THE MESSAGE BUFFER IN HEXADECIMAL.
;
; CALLING SEQUENCE:
;
;	CALL	#4,TST$DISPLAY_MSG
;
; INPUT PARAMETERS:
;
;	4(AP)	MAXIMUM NUMBER OF BYTES TO DISPLAY
;	8(AP)	TRANSMIT/RECEIVE INDICATOR (0/1)
;	12(AP)	ADDRESS OF THE MESSAGE
;	16(AP)	SIZE OF THE MESSAGE IN BYTES
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0-R1	DESTROYED
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

	.ENTRY	TST$DISPLAY_MSG,^M<R2>	; ENTRY POINT

;
; DETERMINE NUMBER OF BYTES TO DISPLAY
;

	MOVL	4(AP),R0		; GET MAX #BYTES TO DISPLAY
	BEQL	50$			; IF NONE, WE'RE FINISHED
	CMPL	16(AP),R0		; IS MESSAGE SIZE GEQ MAX COUNT?
	BGEQ	10$			; YES
	MOVL	16(AP),R0		; NO, USE ACTUAL MESSAGE SIZE
10$:	MOVL	R0,R1			; SAVE COUNT

;
; CONSTRUCT PARAMETER LIST FOR FAO ON THE STACK
;

	MOVL	12(AP),R2		; GET MESSAGE ADDRESS
20$:	MOVZBL	(R2)+,-(SP)		; PUT EACH CHARACTER IN LIST
	SOBGTR	R0,20$			; CONTINUE UNTIL DONE
	PUSHL	R1			; PUT #BYTES TO CONVERT IN LIST
	PUSHL	16(AP)			; PUT MESSAGE SIZE IN LIST
	BLBS	8(AP),30$		; IS THIS A XMIT OR RECV?
	PUSHAB	W^TST$GT_XMIT		; PUT ADDRESS OF TEXT IN LIST
	BRB	40$			;
30$:	PUSHAB	W^TST$GT_RECV		; PUT ADDRESS OF TEXT IN LIST
40$:	MOVL	SP,R1			; GET ADDRESS OF FAO PARAMETER LIST

;
; FORMAT AND PRINT THE MESSAGE
;

	$FAOL_S	CTRSTR=W^TST$GQ_DISPLAY- ; FORMAT MESSAGE
		OUTLEN=W^TST$GW_PRTLEN-	;
		OUTBUF=W^TST$GQ_PRTBUF- ;
		PRMLST=(R1)		;
	CHECK_SS			; CHECK STATUS CODE
	BSBW	TST$PRINT_FAO		; PRINT MESSAGE

;
; "RET" INSTRUCTION WILL ADJUST SP TO THAT FAO PARAMETER LIST
; THAT WAS CONSTRUCTED ON THE STACK IS ELIMINATED.
;

50$:	RET				; EXIT

	.SBTTL	TST$STANDARD - MOVE STANDARD DATA PATTERN
	.PSECT	TST$CODE	NOWRT

;++
; FUNCTIONAL DESCRIPTION:
;
;	TST$STANDARD FILLS THE DESIGNATED BUFFER WITH REPETITIONS OF
;	THE "STANDARD" DATA PATTERN.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	TST$STANDARD
;
; INPUT PARAMETERS:
;
;	R3	ADDRESS OF THE BUFFER
;	R4	SIZE OF THE BUFFER IN BYTES
;
; IMPLICIT INPUTS:
;
;	TST$GT_STANDARD = COUNTED ASCII STRING OF STANDARD DATA PATTERN
;
; OUTPUT PARAMETERS:
;
;	R0-R1	DESTROYED
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

TST$STANDARD::				; CONTROL POINT
	PUSHR	#^M<R2,R3,R4,R5,R6,R7,R8,R9> ; SAVE REGISTERS
	MOVAL	W^TST$GT_STANDARD,R6	; GET ADDRESS OF COUNTED
					;  STANDARD DATA STRING
	MOVZBL	(R6)+,R7		; GET SIZE OF STANDARD DATA STRING
	CLRL	R5			; DOUBLE PRECISION DIVISION FOLLOWS
					;  I.E., {R4,R5} / R7 = R8 R R9
	EDIV	R7,R4,R8,R9		; PUT LOOP COUNT IN R8
	BEQLU	20$			; IS BUFFER SMALLER THAN STD PATTERN?
10$:	MOVC3	R7,(R6),(R3)		; NO, COPY STANDARD DATA PATTERN
	SOBGTR	R8,10$			; WILL PATTERN FIT?
20$:	MOVC3	R9,(R6),(R3)		; NO, FILL REMAINDER OF BUFFER
	POPR	#^M<R2,R3,R4,R5,R6,R7,R8,R9> ; RESTORE REGISTERS
	RSB				; EXIT
	.END
