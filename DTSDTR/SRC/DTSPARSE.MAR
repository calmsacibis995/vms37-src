	.TITLE	TST$DTSPARSE - PARSE DTS COMMAND LINE
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY: DTS/DTR DECNET TEST PACKAGE
;
; ABSTRACT: THIS MODULE PARSES A COMMAND LINE INPUT BY DTS.
;
; ENVIRONMENT: DTS/DTR RUN IN USER MODE AND REQUIRE NETWORK PRIVILEGE.
;
; AUTHOR: JAMES A. KRYCKA,	CREATION DATE: 11-AUG-77
;
; MODIFICATIONS:
;
;--

	.SBTTL	DECLARATIONS

;
; INCLUDE FILES:
;
	FLGDEF				; DEFINE COMMAND PARSE FLAGS
	CMDDEF				; DEFINE COMMAND LANGUAGE SYMBOLS
	VLDDEF				; DEFINE VALID QUALIFIER FLAGS
	.IIF NE	K_LIST_MEB, .LIST MEB	; DEFINED IN DTPREFIX.MAR
;
; EQUATED SYMBOLS:
;
;	NONE
;
; OWN STORAGE:
;
;	NONE

	.SBTTL	TST$PARSE - COMMAND PARSE ROUTINE
	.PSECT	TST$CODE	NOWRT
P::					; SYMBOL FOR DEBUGGING PURPOSES

;++
; FUNCTIONAL DESCRIPTION:
;
;	NONE
;
; CALLING SEQUENCE:
;
;	CALL	#0,TST$PARSE
;
; INPUT PARAMETERS:
;
;	R8	THE ADDRESS OF THE NEXT CHARACTER IN THE BUFFER
;	R9	THE ADDRESS OF THE END OF THE BUFFER + 1
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0-R9	DESTROYED
;	R10	COMMAND PARAMETER VALUE (TESTTYPE)
;	R11	UPDATED PARSE FLAGS
;
; IMPLICIT OUTPUTS:
;
;	TST$GB_BACK
;	TST$GB_DISPLAY
;	TST$GB_FLOW
;	TST$GB_NAK
;	TST$GT_NODENAME
;	TST$GB_PRINT
;	TST$GB_RETURN
;	TST$GB_RQUEUE
;	TST$GL_SECONDS
;	TST$GW_SIZE
;	TST$GL_SPEED
;	TST$GB_SQUEUE
;	TST$GB_TEST
;	TST$GB_TYPE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

	.ENTRY	TST$PARSE,^M<> 		; ENTRY POINT

;
; DETERMINE IF THE NEXT SYNTACTICAL ELEMENT OF THE COMMAND LINE IS A
; PARAMETER OR QUALIFIER, OR IF THE END OF THE INPUT LINE HAS BEEN
; REACHED.
;

NEXT_ELEMENT:				;
	BSBW	TST$NEXTCHAR		; GET CHARACTER
REEXAMINE_CHAR:				;
	$CASEB	SELECTOR=R0,DISPL=<-	; CHARACTER:
			END_OF_LINE-	;  END-OF-LINE
			QUAL-		;  SLASH
			PARSE_ERROR-	;  EQUAL_SIGN OR COLON
			SPACE_OR_TAB-	;  SPACE OR TAB
			PARAM-		;  NONE OF THE ABOVE
	>				;

;
; A SPACE OR TAB HAS BEEN ENCOUNTERED. THIS IMPLIES THAT A QUALIFIER (/)
; CAN NOT IMMEDIATELY FOLLOW. ANOTHER SPACE OR TAB, A PARAMETER, OR A
; QUALIFIER MAY FOLLOW.
;

SPACE_OR_TAB:				;
	BISB2	#FLG_M_DELIMITER,R11	; SET DELIMITER FLAG
	BRB	NEXT_ELEMENT		; CONTINUE

;
; A QUALIFIER FOLLOWS. DISCARD THE SLASH DELIMITER AND PROCEED.
;

QUAL:					;
	BBS	#FLG_V_DELIMITER,R11,-	; SLASH CANNOT FOLLOW
		PARSE_ERROR		;  SPACE OR TAB
	BSBW	QUALIFIER		; PROCESS QUALIFIER
	BRB	REEXAMINE_CHAR		; PROCESS QUALIFIER DELIMITER

;
; A PARAMETER FOLLOWS. THE COMMAND CAN HAVE ONLY ONE PARAMETER.
;

PARAM:					;
	BBSS	#FLG_V_PARAMETER,R11,-	; ERROR IF NOT FIRST PARAMETER
		PARSE_ERROR		;
	BICB2	#FLG_M_DELIMITER,R11	; CLEAR DELIMITER FLAG
	BSBB	PARAMETER		; PROCESS PARAMETER
	BRB	REEXAMINE_CHAR		; PROCESS PARAMETER DELIMITER

;
; THE END OF THE LINE HAS BEEN REACHED. SET FLAG IF THE COMMAND LINE
; REQUIRES ANOTHER LINE OF INPUT; OTHERWISE, DETERMINE WHETHER THE
; REQUIRED PARAMETER HAS BEEN RECEIVED.
;

END_OF_LINE:				;
	CMPB	R1,#^A/-/		; IS COMMAND LINE CONTINUED?
	BEQLU	10$			; YES
	BBCC	#FLG_V_PARAMETER,R11,-	; IT IS AN ERROR IF NO
		PARSE_ERROR		;  PARAMETER HAS BEEN PROCESSED
	RET				; EXIT TO DTSMAIN
10$:	BISB2	#FLG_M_MULTILINE,R11	; SET CONTINUATION FLAG
	RET				; EXIT TO DTSMAIN

;
; AN ERROR HAS BEEN ENCOUNTERED DURING COMMAND LINE PARSING.
;

PARSE_ERROR:				; CONTROL POINT
	BISB2	#FLG_M_PARSERROR,R11	; SET PARSE ERROR FLAG
	RET				; EXIT TO DTSMAIN

	.SBTTL	PARSE ROUTINE--PARAMETER EVALUATION AND DEFAULTING

;+
; PARAMETER IS A SPECIAL PURPOSE SUBROUTINE TO PARSE THE COMMAND PARAMETER
; AND TO APPLY PARAMETER QUALIFIER DEFUALTS. THE PARAMETER STRING IS
; STORED IN TST$GT_KEYWORD.
;-

PARAMETER:				; CONTROL POINT
	MOVAL	W^TST$GT_KEYWORD,R2	; GET ADDRESS OF BUFFER
	MOVL	#^A/    /,(R2)		; FILL KEYWORD STRING WITH SPACES
	CLRL	R3			; ZERO CHARACTER COUNT
	BRB	PARAM_CHAR		; STORE FIRST CHARACTER
PARAM_LOOP:				;
	BSBW	TST$NEXTCHAR		; GET NEXT CHARACTER
	$CASEB	SELECTOR=R0,DISPL=<-	; CHARACTER:
			PARAM_DELIMITER- ; END-OF-LINE
			PARAM_DELIMITER- ; SLASH
			PARSE_ERROR-	;  EQUAL_SIGN OR COLON
			PARAM_DELIMITER- ; SPACE OR TAB
			PARAM_CHAR-	;  NONE OF THE ABOVE
	>				;
PARAM_CHAR:				;
	CMPL	R3,#4			; STORE ONLY FIRST 4 CHARACTERS
	BEQLU	PARAM_LOOP		; IGNORE THIS CHARACTER
	MOVB	R1,(R2)+		; STORE CHARACTER
	INCL	R3			; INCREMENT CHARACTER COUNT
	BRB	PARAM_LOOP		; CONTINUE
PARAM_DELIMITER:			;
	MOVAL	W^TST$AZ_PARAM,R4	; GET ADDRESS OF KEYWORD TABLE
	MOVAL	W^TST$GT_KEYWORD,R6	; GET ADDRESS OF STRING TO MATCH
	BSBW	TST$MATCH		; FIND TABLE INDEX OF KEYWORD
	CVTLB	R5,W^TST$GB_TEST	; UPDATE TESTTYPE
	MOVL	R5,R10			; SAVE IN R10 AS RETURN VALUE!!!

;
; APPLY PARAMETER QUALIFIER DEFAULTS (NOT COMMAND QUALIFIER DEFAULTS)
; AND DENOTE VALID (PERMITTED) QUALIFIIERS FOR THE COMMAND.
;

	$CASEB	SELECTOR=R10,DISPL=<-	; TEST:
			CONNTEST-	;  CONNECT TEST
			DATATEST-	;  DATA TEST
			DISCTEST-	;  DISCONNECT TEST
			INTETEST-	;  INTERRUPT TEST
			MISCTEST-	;  MISCELLANEOUS TEST
	>				;
CONNTEST:					; DEFAULTS FOR:
	MOVB	#DFT_K_RETURN_CO,W^TST$GB_RETURN ; RETURN QUALIFIER
	MOVB	#DFT_K_TYPE_CO,W^TST$GB_TYPE	; TYPE QUALIFIER
	BISL2	#VLD_M_NORETURN-	; DENOTE VALID QUALIFIERS:
		!VLD_M_RETURN-		;
		!VLD_M_TYPE,-		;
		W^TST$GL_VALID		;
	RSB				; EXIT
DATATEST:					; DEFAULTS FOR:
	MOVB	#DFT_K_BACK,W^TST$GB_BACK	; BACK PRESSURE CONTROL
	MOVB	#DFT_K_FLOW,W^TST$GB_FLOW	; FLOW CONTROL
	MOVB	#DFT_K_NAK,W^TST$GB_NAK		; NAK CONTROL
	MOVB	#DFT_K_RQUEUE_DA,W^TST$GB_RQUEUE ; DTR QUEUE COUNT
	MOVW	#DFT_K_SIZE_DA,W^TST$GW_SIZE	; MESSAGE SIZE
	MOVB	#DFT_K_SQUEUE_DA,W^TST$GB_SQUEUE ; DTS QUEUE COUNT
	MOVL	#DFT_K_TIME_DA,W^TST$GL_SECONDS	; DATA TEST DURATION
	MOVB	#DFT_K_TYPE_DA,W^TST$GB_TYPE	; TYPE QUALIFIER
	BISL2	#VLD_M_BACK-		; DENOTE VALID QUALIFIERS:
		!VLD_M_FLOW-		;
		!VLD_M_HOURS-		;
		!VLD_M_MINUTES-		;
		!VLD_M_NAK-		;
		!VLD_M_NOBACK-		;
		!VLD_M_NOFLOW-		;
		!VLD_M_NONAK-		;
		!VLD_M_RQUEUE-		;
		!VLD_M_SECONDS-		;
		!VLD_M_SIZE-		;
		!VLD_M_SQUEUE-		;
		!VLD_M_TYPE,-		;
		W^TST$GL_VALID		;
		RSB			; EXIT
DISCTEST:					; DEFAULTS FOR:
	MOVB	#DFT_K_RETURN_DI,W^TST$GB_RETURN ; RETURN QUALIFIER
	MOVB	#DFT_K_TYPE_DI,W^TST$GB_TYPE	; TYPE QUALIFIER
	BISL2	#VLD_M_NORETURN-	; DENOTE VALID QUALIFIERS:
		!VLD_M_RETURN-		;
		!VLD_M_TYPE,-		;
		W^TST$GL_VALID		;
		RSB			; EXIT
INTETEST:					; DEFAULTS FOR:
	MOVB	#DFT_K_RQUEUE_IN,W^TST$GB_RQUEUE ; DTR QUEUE COUNT
	MOVW	#DFT_K_SIZE_IN,W^TST$GW_SIZE	; MESSAGE SIZE
	MOVB	#DFT_K_SQUEUE_IN,W^TST$GB_SQUEUE ; DTS QUEUE COUNT
	MOVL	#DFT_K_TIME_IN,W^TST$GL_SECONDS	; INTERRUPT TEST DURATION
	MOVB	#DFT_K_TYPE_IN,W^TST$GB_TYPE	; TYPE QUALIFIER
	BISL2	#VLD_M_HOURS-		; DENOTE VALID QUALIFIERS:
		!VLD_M_MINUTES-		;
		!VLD_M_RQUEUE-		;
		!VLD_M_SECONDS-		;
		!VLD_M_SIZE-		;
		!VLD_M_SQUEUE-		;
		!VLD_M_TYPE,-		;
		W^TST$GL_VALID		;
		RSB			; EXIT
MISCTEST:					; DEFAULTS FOR:
	MOVB	#DFT_K_TYPE_MI,W^TST$GB_TYPE	; TYPE QUALIFIER
	BISL2	#VLD_M_TYPE,-		; DENOTE VALID QUALIFIERS:
		W^TST$GL_VALID		;
	RSB				; EXIT

	.SBTTL	PARSE ROUTINE--QUALIFIER EVALUATION
;+
; QUALIFIER IS A SPECIAL PURPOSE SUBROUTINE TO PARSE A COMMAND QUALIFIER OR
; A PARAMETER QUALIFIER. THE QUALIFIER STRING IS STORED IN TST$GT_KEYWORD
; AND THE ASSOCIATED QUALIFIER VALUE (IF ANY) IS STORED IN TST$GT_VALUE.
;-

QUALIFIER:				; CONTROL POINT
	FILLBUF	DST=W^TST$GT_KEYWORD-	; FILL KEYWORD AND QUALIFIER
		SIZE=#12-		;  VALUE STRINGS WITH SPACES
		CHAR=<#^A/ />		;  NOTE R0-R5 ARE DESTROYED!
	MOVAL	W^TST$GT_KEYWORD,R2	; GET ADDRESS OF BUFFER
	CLRL	R3			; ZERO CHARACTER COUNT
QUAL_LOOP:				;
	BSBW	TST$NEXTCHAR		; GET NEXT CHARACTER
QUAL_REEXAMINE:				;
	$CASEB	SELECTOR=R0,DISPL=<-	; CHARACTER:
			QUAL_DELIMITER-	;  END-OF-LINE
			QUAL_DELIMITER-	;  SLASH
			QUAL_VALUE-	;  EQUAL_SIGN OR COLON
			QUAL_DELIMITER-	;  SPACE OR TAB
			QUAL_CHAR-	;  NONE OF THE ABOVE
	>				;
QUAL_VALUE:				; DISCARD THE EQUAL_SIGN OR COLON
	MOVAL	W^TST$GT_VALUE,R2	; GET ADDRESS OF QUALIFIER VALUE
	CLRL	R3			; ZERO CHARACTER COUNT
VALUE_LOOP:				;
	BSBW	TST$NEXTCHAR		; GET NEXT CHARACTER
	$CASEB	SELECTOR=R0,DISPL=<-	; CHARACTER:
			QUAL_REEXAMINE-	;  END-OF-LINE
			QUAL_REEXAMINE-	;  SLASH
			VALUE_CHAR-	;  EQUAL_SIGN OR COLON
			QUAL_REEXAMINE-	;  SPACE OR TAB
			VALUE_CHAR-	;  NONE OF THE ABOVE
	>				;
VALUE_CHAR:				;
	CMPL	R3,#8			; STORE ONLY FIRST 8 CHARACTERS
	BEQLU	VALUE_LOOP		; IGNORE THIS CHARACTER
	MOVB	R1,(R2)+		; STORE CHARACTER
	INCL	R3			; INCREMENT CHARACTER COUNT
	BRB	VALUE_LOOP		; CONTINUE
QUAL_CHAR:				;
	CMPL	R3,#4			; STORE ONLY FIRST 4 CHARACTERS
	BEQLU	QUAL_LOOP		; IGNORE THIS CHARACTER
	MOVB	R1,(R2)+		; STORE CHARACTER
	INCL	R3			; INCREMENT CHARACTER COUNT
	BRB	QUAL_LOOP		; CONTINUE
QUAL_DELIMITER:				;
	MOVAL	W^TST$AZ_QUAL,R4	; GET ADDRESS OF KEYWORD TABLE
	MOVAL	W^TST$GT_KEYWORD,R6	; GET ADDRESS OF STRING TO MATCH
	BSBW	TST$MATCH		; FIND TABLE INDEX OF KEYWORD
	BBS	R5,W^TST$GL_VALID,10$	; IS THIS A VALID QUALIFIER?
	BRW	PARSE_ERROR		; NO, NOT IN THIS CONTEXT
10$:	BSBB	QUAL_DISPATCH		; GO TO QUALIFIER SPECIFIC CODE
	RSB				; EXIT

	.SBTTL	PARSE ROUTINE--QUALIFIER VALUE EVALUATION

;+
; QUAL_DISPATCH IS A SPECIAL PURPOSE SUBROUTINE THAT CONTAINS QUALIFIER
; SPECIFIC CODE. IT EXISTS AS A SUBROUTINE TO UTILIZE "RSB" TO RETURN
; FROM A "CASE" INSTRUCTION INSTEAD OF USING "BRW".
;-

QUAL_DISPATCH:				; CONTROL POINT
	MOVAL	W^TST$GT_VALUE,R6	; GET ADDRESS OF QUALIFIER VALUE
					;  STRING FOR POSSIBLE USE BY TST$MATCH
	$CASEB	SELECTOR=R5,DISPL=<-	; DISPATCH TO APPROPRIATE CODE
			BACK-		;  BACK PRESSURE CONTROL
			DISPLAY-	;  DISPLAY EACH MESSAGE
			FLOW-		;  FLOW CONTROL
			HOURS-		;  TIME OF TEST IN HOURS
			MINUTES-	;  TIME OF TEST IN MINUTES
			NAK-		;  NAK CONTROL
			NOBACK-		;  NO BACK PRESSURE CONTROL
			NODENAME-	;  NODENAME
			NODISPLAY-	;  DO NOT DISPLAY EACH MESSAGE
			NOFLOW-		;  NO FLOW CONTROL
			NONAK-		;  NO NAK CONTROL
			NOPRINT-	;  NO PRINT OPTION FOR DTR
			NORETURN-	;  NO USERDATA TO RETURN
			NOSTATISTICS-	;  NO STATISTICS DESIRED
			PRINT-		;  PRINT OPTION FOR DTR
			RETURN-		;  RETURN USERDATA
			RQUEUE-		;  DTR QUEUE
			SECONDS-	;  TIME OF TEST IN SECONDS
			SIZE-		;  MESSAGE SIZE
			SPEED-		;  SPEED OF COMMUNICATIONS LINE
			SQUEUE-		;  DTS QUEUE
			STATISTICS-	;  STATISTICS DESIRED
			TYPE-		;  TEST TYPE (SUBFUNCTION)
	>				;
BACK:					; PROCESS BACK QUALIFIER
	MOVZBL	#MAX_K_BACK,R7		; DEFINE MAXIMUM VALUE
	BSBW	TST$CVTU_DTB		; CONVERT DIGITS TO BINARY VALUE
	CVTLB	R6,W^TST$GB_BACK	; UPDATE BACK PRESSURE CONTROL
	RSB				; EXIT

DISPLAY:				; PROCESS DISPLAY QUALIFIER
	MOVL	#MAX_K_DISPLAY,R7	; DEFINE MAXIMUM VALUE
	BSBW	TST$CVTU_DTB		; CONVERT DIGITS TO BINARY VALUE
	CVTLB	R6,W^TST$GB_DISPLAY	; UPDATE DISPLAY VALUE
	RSB				; EXIT

FLOW:					; PROCESS FLOW QUALIFIER VALUE
	MOVAL	W^TST$AZ_FLOW,R4	; GET ADDRESS OF KEYWORD TABLE
	BSBW	TST$MATCH		; FIND TABLE INDEX OF KEYWORD
	INCL	R5			;
	CVTLB	R5,W^TST$GB_FLOW	; UPDATE FLOW CONTROL FIELD
	RSB				; EXIT

HOURS:					; PROCESS HOURS QUALIFIER VALUE
	MOVZWL	#3600,-(SP)		; # SECONDS IN 1 HOUR
	MOVZBL	#<MAX_K_TIME_DA/3600>,R7 ; DEFINE MAXIMUM HOUR VALUE
	BRW	TIME			; BRANCH TO COMMON CODE

MINUTES:				; PROCESS MINUTES QUALIFIER VALUE
	MOVZBL	#60,-(SP)		; # SECONDS IN 1 MINUTE
	MOVZWL	#<MAX_K_TIME_DA/60>,R7	; DEFINE MAXIMUM MINUTE VALUE
	BRW	TIME			; BRANCH TO COMMON CODE

NAK:					; PROCESS NAK QUALIFIER
	MOVZBL	#MAX_K_NAK,R7		; DEFINE MAXIMUM VALUE
	BSBW	TST$CVTU_DTB		; CONVERT DIGITS TO BINARY VALUE
	CVTLB	R6,W^TST$GB_NAK		; UPDATE NAK CONTROL
	RSB				; EXIT

NOBACK:					; PROCESS NOBACK QUALIFIER
	ASSUME	VAL_K_BACK_NO,EQ,0	;
	CLRB	W^TST$GB_BACK		; UPDATE BACK PRESSURE CONTROL VALUE
	RSB				; EXIT

NODENAME:				; PROCESS NODENAME QUALIFIER VALUE
					; A NODENAME OF 0-6 CHARACTERS
					;  IS ALLOWED
	CMPL	R3,#6			; IS STRING TOO LONG?
	BLEQU	10$			; NO, USE ENTERED VALUE
	BRW	PARSE_ERROR		; YES
10$:	PUSHR	#^M<R0,R1>		; SAVE R0 AND R1
					; NODENAME IS STORED AS A
					; COUNTED ASCII STRING
	MOVB	R3,W^TST$GT_NODENAME	; STORE LENGTH OF STRING
	MOVC3	R3,W^TST$GT_VALUE,-	; STORE STRING
		W^TST$GT_NODENAME+1	; NOTE R0 - R5 ARE DESTROYED!
	POPR	#^M<R0,R1>		; RESTORE R0 AND R1
	RSB				; EXIT

NODISPLAY:				; PROCESS NODISPLAY QUALIFIER
	ASSUME	VAL_K_DISP_NO,EQ,0	;
	CLRB	W^TST$GB_DISPLAY	; UPDATE DISPLAY VALUE
	RSB				; EXIT

NOFLOW:					; PROCESS NOFLOW QUALIFIER
	ASSUME	VAL_K_FLOW_NO,EQ,0	;
	CLRB	W^TST$GB_FLOW		; UPDATE FLOW CONTROL VALUE
	RSB				; EXIT

NONAK:					; PROCESS NONAK QUALIFIER
	ASSUME	VAL_K_NAK_NO,EQ,0	;
	CLRB	W^TST$GB_NAK		; UPDATE NAK CONTROL VALUE
	RSB				; EXIT

NOPRINT:				; PROCESS NOPRINT QUALIFIER
	ASSUME	VAL_K_PRIN_NO,EQ,0	;
	CLRB	W^TST$GB_PRINT		; UDPATE PRINT VALUE
	RSB				; EXIT

NORETURN:				; PROCESS NORETURN QUALIFIER
	ASSUME	VAL_K_RETU_NO,EQ,0	;
	CLRB	W^TST$GB_RETURN		; UPDATE RETURN VALUE
	RSB				; EXIT

NOSTATISTICS:				; PROCESS NOSTATISTICS QUALIFIER
	ASSUME	VAL_K_STAT_NO,EQ,0	;
	CLRB	W^TST$GB_STAT		; UPDATE STATISTICS VALUE
	RSB				; EXIT

PRINT:					; PROCESS PRINT QUALIFIER
	MOVB	#VAL_K_PRIN_YES,W^TST$GB_PRINT ; UPDATE PRINT VALUE
	RSB				; EXIT

RETURN:					; PROCESS RETURN QUALIFIER VALUE
	MOVAL	W^TST$AZ_RETURN,R4	; GET ADDRESS OF KEYWORD TABLE
	BSBW	TST$MATCH		; FIND TABLE INDEX OF KEYWORD
	INCL	R5			;
	CVTLB	R5,W^TST$GB_RETURN	; UPDATE RETURN USERDATA VALUE
	RSB				; EXIT

RQUEUE:					; PROCESS RQUEUE QUALIFIER VALUE
	MOVL	#MAX_K_RQUEUE_DA,R7	; DEFINE MAXIMUM VALUE FOR DATA TEST
	CMPB	R10,#VAL_K_TEST_DATA	; IS IT A DATA TEST?
	BEQLU	10$			; BRANCH IF YES
	MOVL	#MAX_K_RQUEUE_IN,R7	; NO, DEFINE MAX VALUE FOR INT TEST
10$:	BSBW	TST$CVTU_DTB		; CONVERT DIGITS TO BINARY VALUE
	CVTLB	R6,W^TST$GB_RQUEUE	; UPDATE FLOW CONTROL VALUE
	RSB				; EXIT

SECONDS:				; PROCESS SECONDS QUALIFIER VALUE
	MOVL	#1,-(SP)		; # SECONDS IN 1 SECOND
	MOVL	#MAX_K_TIME_DA,R7	; DEFINE MAXIMUM SECOND VALUE
TIME:					; COMMON CODE
	BSBW	TST$CVTU_DTB		; CONVERT DIGITS TO BINARY VALUE
	MULL3	R6,(SP)+,W^TST$GL_SECONDS ; CALCULATE NUMBER OF SECONDS
	RSB				; EXIT

SIZE:					; PROCESS SIZE QUALIFIER VALUE
	MOVZWL	#MAX_K_SIZE_DA,R7	; DEFINE MAXIMUM VALUE FOR DATA TEST
	CMPB	R10,#VAL_K_TEST_DATA	; IS IT A DATA TEST?
	BEQLU	10$			; BRANCH IF YES
	MOVL	#MAX_K_SIZE_IN,R7	; NO, DEFINE MAX VALUE FOR INT TEST
10$:	BSBW	TST$CVTU_DTB		; CONVERT DIGITS TO BINARY VALUE
	CVTLW	R6,W^TST$GW_SIZE	; UPDATE MESSAGE SIZE
	RSB				; EXIT

SPEED:					; PROCESS SPEED QUALIFIER VALUE
	MOVL	#MAX_K_SPEED,R7		; DEFINE MAXIMUM VALUE
	BSBW	TST$CVTU_DTB		; CONVERT DIGITS TO BINARY VALUE
	MOVL	R6,W^TST$GL_SPEED	; UPDATE BAUD RATE
	RSB				; EXIT

SQUEUE:					; PROCESS SQUEUE QUALIFIER
	MOVL	#MAX_K_SQUEUE_DA,R7	; DEFINE MAXIMUM VALUE FOR DATA TEST
	CMPB	R10,#VAL_K_TEST_DATA	; IS IT A DATA TEST?
	BEQLU	10$			; BRANCH IF YES
	MOVL	#MAX_K_SQUEUE_IN,R7	; NO, DEFINE MAX VALUE FOR INT TEST
10$:	BSBW	TST$CVTU_DTB		; CONVERT DIGITS TO BINARY VALUE
	CVTLB	R6,W^TST$GB_SQUEUE	; UPDATE DTS QUEUE COUNT
	RSB				; EXIT

STATISTICS:				; PROCESS STATISTICS QUALIFIER
	MOVB	#VAL_K_STAT_YES,W^TST$GB_STAT	; UPDATE STATISTICS VALUE
	RSB				; EXIT

TYPE:					; PROCESS TYPE QUALIFIER VALUE
	$CASEB	SELECTOR=R10,DISPL=<-	; TEST:
			10$-		;  CONNECT TEST
			20$-		;  DATA TEST
			30$-		;  DISCONNECT TEST
			40$-		;  INTERRUPT TEST
	>				;  MISCELLANEOUS TEST BELOW
	MOVAL	W^TST$AZ_TYPE_MI,R4	; GET ADDRESS OF KEYWORD TABLE
	BRB	50$			; BRANCH TO COMMON CODE
10$:	MOVAL	W^TST$AZ_TYPE_CO,R4	; GET ADDRESS OF KEYWORD TABLE
	BRB	50$			; BRANCH TO COMMON CODE
20$:	MOVAL	W^TST$AZ_TYPE_DA,R4	; GET ADDRESS OF KEYWORD TABLE
	BRB	50$			; BRANCH TO COMMON CODE
30$:	MOVAL	W^TST$AZ_TYPE_DI,R4	; GET ADDRESS OF KEYWORD TABLE
	BRB	50$			; BRANCH TO COMMON CODE
40$:	MOVAL	W^TST$AZ_TYPE_IN,R4	; GET ADDRESS OF KEYWORD TABLE
50$:	BSBW	TST$MATCH		; FIND TABLE INDEX OF KEYWORD
	CVTLB	R5,W^TST$GB_TYPE	; UPDATE MESSAGE TYPE
	RSB				; EXIT

	.SBTTL	TST$NEXTCHAR - EXAMINE NEXT CHARACTER
	.PSECT	TST$CODE	NOWRT

;++
; FUNCTIONAL DESCRIPTION:
;
;	TST$NEXTCHAR ATTEMPTS TO EXAMINE THE NEXT CHARACTER IN THE
;	BUFFER. IF THE END OF THE BUFFER HAS BEEN REACHED, TST$NEXTCHAR
;	SIGNALS END OF LINE CONDITION; OTHERWISE THE NEXT CHARACTER
;	FOUND IS RETURNED ALONG WITH A VALUE INDICATING WHAT TYPE OF
;	CHARACTER IT IS.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	TST$NEXTCHAR
;
; INPUT PARAMETERS:
;
;	R8	THE ADDRESS OF THE NEXT CHARACTER IN THE BUFFER
;	R9	THE ADDRESS OF THE END OF THE BUFFER + 1
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0	RESULT WHERE:
;		0 = END OF LINE OR CHARACTER IS AN EXCLAMATION OR DASH
;		1 = CHARACTER IS A SLASH
;		2 = CHARACTER IS AN EQUAL_SIGN OR COLON
;		3 = CHARACTER IS A SPACE OR TAB
;		4 = CHARACTER IS NONE OF THE ABOVE
;	R1	THE CHARACTER EXAMINED (0 OR "NULL" IF END OF LINE)
;	R8	UPDATED NEXT CHARACTER POINTER
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

TST$NEXTCHAR::				; CONTROL POINT
	CLRL	R0			; INITIALIZE RETURN VALUE
	CLRL	R1			; SET R1 TO "NULL"
; ***** R0 = 0
	CMPL	R8,R9			; END OF COMMAND LINE?
	BEQLU	10$			; YES
	MOVZBL	(R8)+,R1		; GET NEXT CHARACTER
	CMPB	R1,#^A\!\		; IS IT AN EXCLAMATION POINT?
	BEQLU	10$			; YES, IGNORE REST OF LINE
	CMPB	R1,#^A\-\		; IS IT A DASH?
	BEQLU	10$			; YES, IGNORE REST OF LINE
; ***** R0 = 1
	INCL	R0			; INCREMENT RETURN VALUE
	CMPB	R1,#^A\/\		; IS IT A SLASH?
	BEQLU	10$			; YES
; ***** R0 = 2
	INCL	R0			; INCREMENT RETURN VALUE
	CMPB	R1,#^A\=\		; IS IT AN EQUALS_SIGN?
	BEQLU	10$			; YES
	CMPB	R1,#^A\:\		; IS IT A COLON?
	BEQLU	10$			; YES
; ***** R0 = 3
	INCL	R0			; INCREMENT RETURN VALUE
	CMPB	R1,#^A\ \		; IS IT A SPACE?
	BEQLU	10$			; YES
	CMPB	R1,#^X09		; IS IT A TAB?
	BEQLU	10$			; YES
; ***** R0 = 4
	INCL	R0			; IT'S NONE OF THE ABOVE
10$:	RSB				; EXIT

	.SBTTL	TST$MATCH - KEYWORD MATCH ROUTINE
	.PSECT	TST$CODE	NOWRT

;++
; FUNCTIONAL DESCRIPTION:
;
;	TST$MATCH SEARCHES THE SPECIFIED KEYWORD TABLE FOR A MATCH WITH
;	THE SPECIFIED KEYWORD STRING. IF A MATCH IS FOUND, THE INDEX
;	OF THE MATCHING TABLE ENTRY IS RETURNED; OTHERWISE CONTROL IS
;	TRANSFERRED TO AN ERROR ROUTINE. THE END OF THE TABLE IS MARKED
;	BY A NULL KEYWORD ENTRY, I.E., A NULL COUNTED ASCII STRING.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	TST$MATCH
;
; INPUT PARAMETERS:
;
;	R4	ADDRESS OF THE KEYWORD TABLE TO SEARCH
;	R6	ADDRESS OF THE KEYWORD STRING TO MATCH AGAINST THE TABLE
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R5	THE INDEX OF THE MATCHING TABLE ENTRY IF A MATCH IS FOUND;
;		OTHERWISE UNDEFINED.
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	CONTROL IS TRANSFERRED TO PARSE_ERROR IF AN ERROR IS DETECTED.
;
;--

TST$MATCH::				; CONTROL POINT
	PUSHR	#^M<R0,R1,R2,R3,R4>	; SAVE REGISTERS
	CLRL	R5			; INITIALIZE RETURN VALUE
10$:	MOVB	(R4)+,R0		; GET # OF SIGNIFICANT CHARACTERS
	BEQLU	30$			; END OF TABLE IF ZERO
	CMPC3	R0,(R4),(R6)		; DO STRINGS MATCH?
	BEQLU	20$			; YES
	ADDL3	R0,R1,R4		; SET POINTER TO NEXT ENTRY
	INCL	R5			; INCREMENT TABLE INDEX
	BRB	10$			; TRY AGAIN
20$:	POPR	#^M<R0,R1,R2,R3,R4>	; RESTORE REGISTERS
	RSB				; EXIT
30$:	BRW	PARSE_ERROR		; BRANCH TO ERROR ROUTINE

	.SBTTL	TST$CVTU_DTB - CONVERT UNSIGNED DECIMAL TO BINARY
	.PSECT	TST$CODE	NOWRT

;++
; FUNCTIONAL DESCRIPTION:
;
;	TST$CVTU_DTB CONVERTS AN UNSIGNED ASCII STRING OF 1 TO 8 DECIMAL
;	DIGITS TO A 32-BIT BINARY VALUE. IF THE RESULTANT VALUE EXCEEDS
;	THE GIVEN LIMIT, CONTROL IS TRANSFERRED TO AN ERROR ROUTINE.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	TST$CVTU_DTB
;
; INPUT PARAMETERS:
;
;	R3	LENGTH OF ASCII STRING
;	R7	MAXIMUM VALUE
;
; IMPLICIT INPUTS:
;
;	TST$GT_VALUE = ASCII STRING TO CONVERT
;
; OUTPUT PARAMETERS:
;
;	R2-R5	DESTROYED
;	R6	BINARY VALUE OF STRING
;	R7	UNCHANGED
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	CONTROL IS TRANSFERRED TO PARSE_ERROR IF AN ERROR IS DETECTED.
;
;--

TST$CVTU_DTB::				; CONTROL POINT
	MOVAL	W^TST$GT_VALUE,R2	; GET ADDRESS OF ASCII STRING

;
; THE ASCII STRING IS STORED IN REVERSE ORDER, SO THE POINTER IS PLACED
; ONE PAST THE END OF THE STRING. THEREFORE, THE STRING IS SCANNED IN
; REVERSE ORDER TO OBTAIN THE LEAST-SIGNIFICANT TO MOST-SIGNIFICANT
; CHARACTERS.
;

	ADDL2	R3,R2			; ADD STRING LENGTH TO POINTER
	CMPB	R3,#8			; IS STRING TOO LONG?
	BGTRU	20$			; YES
	MOVZBL	#1,R4			; SET-UP DIGIT PLACE VALUE
	CLRL	R6			; ZERO RETURN VALUE
10$:	MOVZBL	-(R2),R5		; GET NEXT ASCII CHARACTER
	SUBB2	#^X30,R5		; CONVERT ASCII DIGIT TO BINARY
	CMPB	R5,#9			; IS IT NON-NUMERIC?
	BGTRU	20$			; YES
	MULL2	R4,R5			; MULTIPLY DIGIT BY ITS PLACE VALUE
	ADDL2	R5,R6			; ADD THIS TO THE TOTAL
	MULL2	#10,R4			; MULTIPLY PLACE VALUE BY 10
	SOBGTR	R3,10$			; ANOTHER DIGIT TO CONVERT?
	CMPL	R6,R7			; IS CONVERTED VALUE TOO LARGE?
	BGTRU	20$			; YES
	RSB				; NO, EXIT
20$:	BRW	PARSE_ERROR		; BRANCH TO ERROR ROUTINE
	.END
