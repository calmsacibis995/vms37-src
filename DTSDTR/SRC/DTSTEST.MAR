	.TITLE	TST$DTSTEST - DTS TEST ROUTINES
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY: DTS/DTR DECNET TEST PACKAGE
;
; ABSTRACT:
;	THIS MODULE IMPLEMENTS THE CONNECT, DATA, DISCONNECT,
;	INTERRUPT, AND MISCELLANEOUS TEST SEQUENCES FOR DTS.
;
; ENVIRONMENT: DTS RUNS IN USER MODE AND REQUIRES NETWORK PRIVILEGE.
;
; AUTHOR: JAMES A. KRYCKA,	CREATION DATE: 11-AUG-77
;
; MODIFICATIONS:
;
;--

	.SBTTL	DECLARATIONS

;
; INCLUDE FILES:
;
	$DTSDEF				;DTS ERROR MESSAGE MACROS
	CMDDEF				; DEFINE COMMAND LANGUAGE SYMBOLS
	EFNDEF				; DEFINE EFN'S AND FUNCTION CODES
	$MSGDEF				; DEFINE MAILBOX MESSAGE ID CODES
	.IIF NE	K_LIST_MEB, .LIST MEB	; DEFINED IN DTPREFIX.MAR
;
; MACROS:
;
;	NONE
;
; EQUATED SYMBOLS:
;
;	NONE
;
; OWN STORAGE:
;
;	NONE

	.SBTTL	TST$CONN_DTS - CONNECT TEST
	.PSECT	TST$CODE	NOWRT
ST::					; SYMBOL FOR DEBUGGING PURPOSES

;++
; FUNCTIONAL DESCRIPTION:
;
;	NONE
;
; CALLING SEQUENCE:
;
;	BSB/JSB	TST$CONN_DTS
;
; INPUT PARAMETERS:
;
;	R10	TEST TYPE
;	R11	ADDRESS OF USERDATA COUNTED ASCII STRING
;
; IMPLICIT INPUTS:
;
;	TST$GT_USERDATA
;
; OUTPUT PARAMETERS:
;
;	R0	COMPLETION CODE
;	R1	ADDRESS OF TEST ID STRING
;	R2-R9	DESTROYED
;
; IMPLICIT OUTPUTS:
;
;	TST$GT_USERDATA UPDATED
;
; COMPLETION CODES:
;
;	R0	1 = SUCCESS; 0 = FAILURE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

TST$CONN_DTS::				; CONTROL POINT

;
; FINISH BUILDING THE CONNECT TEST REQUEST IN THE USERDATA STRING.
;
; THE DTS/R CONTYPE FIELD VALUE IS DERIVED FROM BOTH THE /TYPE AND THE
; /[NO]USERDATA QUALIFIER VALUES.
;

	MOVZBL	W^TST$GB_TYPE,R8	; GET TYPE QUALIFIER VALUE
	MOVZBL	W^TST$GB_RETURN,R9	; GET RETURN QUALIFIER VALUE
	ROTL	#1,R9,R0		; CONTYPE = RETURN * 2 + TYPE
	ADDB3	R0,R8,2(R11)		; UPDATE CONTYPE FIELD
	MOVB	#2,(R11)		; UPDATE USERDATA STRING LENGTH
	$CASEB	SELECTOR=R9,DISPL=<-	; CHECK RETURN OPTION:
		CONN_TEST-		;  /NORETURN
		CONN_TEST-		;  /RETURN=STANDARD
	>				;  /RETURN=RECEIVED
	MOVZBL	W^TST$GT_CONN,R0	; ADD TEXT TO USERDATA STRING
	ADDB2	R0,(R11)		; UPDATE USERDATA STRING LENGTH
	MOVC3	R0,W^TST$GT_CONN+1,3(R11) ; APPEND THE STRING

;
; ENTER INTO NSP CONNECT SEQUENCE WITH DTR.
;

CONN_TEST:				; START THE CONNECT TEST
	BSBW	TST$STARTUP_DTR		; INITIATE NSP CONNECT SEQUENCE
	BLBC	R0,CONN_EXPECTED	; WAS LINK ESTABLISHED?
	MOVL	#EFN_K_DISC_ABRT,R2	; YES, GET FUNCTION/INDEX CODE
	CLRL	R4			; P2 = 0
	BSBW	TST$QIOW		; DISCONNECT ABORT THE LINK
	CHECK_IOSB TST$GQ_LINKIOSB	;MAKE SURE ABORT  COMPLETES

;
; STORE THE EXPECTED CONNECT ACCEPT/REJECT CODE ON THE STACK AND BUILD
; THE EXPECTED RESPONSE COUNTED ASCII STRING IN TST$GT_USERDATA TO COMPARE
; AGAINST THE ACTUAL RESPONSE RECEIVED FROM DTR.
;

CONN_EXPECTED:				;
5$:	$CASEB	SELECTOR=R9,DISPL=<-	; CHECK USERDATA OPTION:
		10$-			;  /NOUSERDATA
		20$-			;  /USERDATA=STANDARD
		CONN_RESPONSE-		;  /USERDATA=RECEIVED
	>				;
10$:	CLRB	(R11)			; ZERO USERDATA STRING LENGTH
	BRB	CONN_RESPONSE		; CONTINUE
20$:	MOVB	#16,(R11)		; UPDATE USERDATA STRING LENGTH
	MOVC3	#16,W^TST$GT_STANDARD+1,1(R11) ; COPY STANDARD DATA PATTERN

;
; CHECK ACTUAL RESPONSE FROM DTR AGAINST EXPECTED RESPONSE.
;

CONN_RESPONSE:				; INTERROGATE RESPONSE
	BLBS	R8,3$			;BR IF CONN ACCEPT EXPECTED
	CMPW	R6,#MSG$_REJECT		;WAS IT REJECTED?
	BEQLU	1$			;BR IF YES
	MOVL	#DTS$_CINBAD,R0		;NOTE UNEXPECT ACCEPT
	BRB	CONN_FAILURE		;FAIL TEST
1$:
	TSTL	W^TST$GQ_LINKIOSB+4	;CHECK FOR DTR REJECT
	BEQLU	10$			;YES,CHECK USER LENGTH
	CMPL	#9,W^TST$GQ_LINKIOSB+4	;ALSO DTR REJECT
	BEQLU	10$			;CHECK USER DATA
2$:
	MOVL	#DTS$_CINREJ,R0		;SYSTEM REJECTED CONNECT
	MOVL	W^TST$GQ_LINKIOSB+4,-
		W^TST$GL_FAOARG		;SAVE NCP REASON
	BRB	CONN_FAILURE		;FAIL TEST
3$:
	CMPL	R6,#MSG$_CONFIRM	;CHECK IF CONN ACCEPTED
	BNEQU	2$			;UNEXPECT REJECT
10$:	CMPB	(R11),(R7)		; COMPARE EXPECTED VS ACTUAL
					;  USERDATA STRING LENGTH
	BEQLU	20$			; IS IS OK?
	MOVL	#DTS$_BADUSRLEN,R0	;NOTE BAD LEN USER DATA
	BRB	CONN_FAILURE		;
20$:	MOVZBL	(R11),R0		; COMPARE EXPECTED VS ACTUAL
	CMPC3	R0,1(R11),1(R7)		;  USERDATA STRING VALUE
	BEQLU	CONN_SUCCESS		; IS IT OK?
	MOVL	#DTS$_BADUSRDAT,R0	;NOTE BAD DATA
	BRB	CONN_FAILURE		; 
CONN_SUCCESS:				; TEST WAS SUCCESSFUL
	MOVL	#1,R0			; SET COMPLETION CODE TO SUCCESS
CONN_FAILURE:				; ENTER HERE IF TEST FAILED
	MOVAB	W^TST$GT_CONN,R1	; RETURN ADDRESS OF TEST ID STRING
	RSB				; EXIT

	.SBTTL	TST$DATA_DTS - DATA TEST
	.PSECT	TST$CODE	NOWRT

;++
; FUNCTIONAL DESCRIPTION:
;
;	NONE
;
; CALLING SEQUENCE:
;
;	BSB/JSB	TST$DATA_DTS
;
; INPUT PARAMETERS:
;
;	R10	TEST TYPE
;	R11	ADDRESS OF USERDATA COUNTED ASCII STRING
;
; IMPLICIT INPUTS:
;
;	TST$GT_USERDATA
;
; OUTPUT PARAMETERS:
;
;	R0	COMPLETION CODE
;	R1	ADDRESS OF TEST ID STRING
;	R2-R9	DESTROYED
;
; IMPLICIT OUTPUTS:
;
;	TST$GT_USERDATA UPDATED
;
; COMPLETION CODES:
;
;	R0	1 = SUCCESS; 0 = FAILURE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

TST$DATA_DTS::				; CONTROL POINT

;
;VERIFY MESSAGE SIZE FIELD
;

	MOVZWL	W^TST$GW_SIZE,R4	;[TGD]VALUE OF SIZE FIELD
	$CASEB SELECTOR=TST$GB_TYPE,DISPL=<-
	    40$-			;SINK TEST
	    10$-			;SEQUENCE TEST
	    20$-			;PATTERN TEST
	    40$-			;ECHO TEST
		>
10$:					;MIN SIZE OF SEQUENCE TEST IS 4

	MOVL	#4,R0			
	BRB	30$			;GO TO COMMON CODE

20$:					;MIN SIZE OF PATT CHECK IS 5
	MOVL	#5,R0
30$:					;IF SIZE TOO SMALL THEN ERROR
	CMPW	R0,R4
	BLEQ	40$			;IF /SIZE EXCEEDS MIN THEN OKAY
	MOVL	#2,R0			;ERROR CODE
	BRW	DATA_FAILURE		;GO TO COMMON ERROR CODE
40$:
;
; FINISH BUILDING THE DATA TEST REQUEST IN THE USERDATA STRING.
;

	MOVAL	2(R11),R9		; GET ADDRESS OF DTS/R DATATYPE FIELD
	MOVB	W^TST$GB_TYPE,(R9)+	; UPDATE DATATYPE FIELD
	MOVB	W^TST$GB_FLOW,(R9)+	; UPDATE FCOPT FIELD
	MOVB	W^TST$GB_RQUEUE,(R9)+	; UPDATE DTS/R FCVAL FIELD
	MOVB	W^TST$GB_NAK,(R9)+	; UPDATE NAKVAL FIELD
	MOVB	W^TST$GB_BACK,(R9)+	; UPDATE BPVAL FIELD
	MOVW	W^TST$GW_SIZE,(R9)+	; UPDATE MSGLEN FIELD
	MOVB	#8,(R11)		; UPDATE USERDATA STRING LENGTH

;
; ENTER INTO NSP CONNECT SEQUENCE WITH DTR.
;

DATA_TEST:				; START THE DATA TEST
	BSBW	TST$STARTUP_DTR		; INITIATE NSP CONNECT SEQUENCE
	BLBS	R0,DATA_INIT		; WAS LINK ESTABLISHED?
	MOVL	#DTS$_CINREJ,R0
	MOVL	W^TST$GQ_LINKIOSB+4,-
		W^TST$GL_FAOARG
	BRW	DATA_FAILURE		;

;
; DATA TEST INITIALIZATION
;

DATA_INIT:				; CONTINUE
	CLRQ	W^TST$GL_XMITDATA	; ZERO TRANSMIT AND RECEIVE
					;  MESSAGE COUNTERS
	CLRQ	W^TST$GL_XMITINTE	; ZERO TRANSMIT AND RECEIVE
					;  INTERRUPT MESSAGE COUNTERS
	MOVL	#1,W^TST$GL_STATUS	; SET AST STATUS CODE TO SUCCESS
	CLRB	W^TST$GB_ASTFLAGS	;NOTE TIMER RUNNING
	MOVAL	TST$QB_QHEAD,TST$QB_QHEAD;INIT QUEUE HEAD
	MOVAL	TST$QB_QHEAD,TST$QB_QHEAD+4

;
; PUT REPETITIONS OF THE STANDARD DATA PATTERN IN THE MESSAGE BUFFER
; BEGINNING AT BUFFER+4.
;

	MOVAB	W^TST$GB_XMITBUF,R3	; GET ADDRESS OF MESSAGE
	MOVL	#1,(R3)+		; INITIALIZE MESSAGE SEQUENCE NUMBER
	MOVZWL	W^TST$GW_SIZE,R4	; GET MESSAGE SIZE
	CMPW	R4,#4			;ANY DATA IN MESSAGE?
	BLEQ	5$			;NO, JUST SEQUENCE
	SUBL2	#4,R4			; REDUCE SIZE ACCORDINGLY
	BSBW	TST$STANDARD		; PUT STD DATA PATTERN IN BUFFER

5$:
;
; SET TIMER 
;

	MOVL	W^TST$GL_SECONDS,W^TST$GL_CLOCK	;SETUP COUNTDOWN LOCATION
	$SETIMR_S EFN=#EFN_K_TIMER-	;
		DAYTIM=W^TST$GQ_NANOSEC- ;
		ASTADR=W^TST$TIMER_DTS	;
	CHECK_SS			; CHECK STATUS CODE

;
; TRANSMIT [AND RECEIVE] DATA MESSAGES UNTIL TIMER EXPIRES
;

	CMPB	2(R11),#VAL_K_TYPE_ECHO	; SHOULD DTR ECHO MESSAGE?
	BNEQU	10$			; NO, CONTINUE
	MOVL	#EFN_K_RECV_DATA,R2	; GET FUNCTION/INDEX CODE
	MOVZWL	W^TST$GW_SIZE,R4	;SIZE OF DATA BUFFER
	MOVAB	W^TST$RECVAST_DTS,R5	; GET ADDRESS OF AST ROUTINE
	BSBW	TST$QIOAST		; START UP RECEIVE MESSAGE STREAM
10$:	MOVL	#EFN_K_READ_MAIL,R2	; GET FUNCTION/INDEX CODE
	MOVZBL	#TST$K_MAILBUF,R4	; GET MAILBOX BUFFER SIZE
	MOVAB	W^TST$MAILAST_DTS,R5	; GET ADDRESS OF AST ROUTINE
	BSBW	TST$QIOAST		; ISSUE READ TO MAILBOX
	MOVL	#EFN_K_XMIT_DATA,R2	; GET FUNCTION/INDEX CODE
	MOVZWL	W^TST$GW_SIZE,R4	; GET MESSAGE SIZE
	MOVAB	W^TST$XMITAST_DTS,R5	; GET ADDRESS OF AST ROUTINE
	BSBW	TST$QIOAST		; START UP TRANSMIT MESSAGE STREAM

;
; WAIT EITHER FOR TIMER TO EXPIRE OR FOR LINK DISCONNECT
;

	BRB	30$			;CHECK FOR ASTS 
20$:
	$HIBER_S			;GO TO SLEEP TILL AN AST
30$:
	BLBS	W^TST$GB_ASTFLAGS,40$	;JUMP IF TIMER EXPIRED
	REMQUE	@TST$QB_QHEAD,R0	;DEQUEUE AN AST
	BVS	20$			;NOTHING THERE ,SLEEP
	MOVL	TST$QB_CODE(R0),R2		;QIO FUNCTION/CODE
	MOVZWL	TST$GW_SIZE,R4		;SIZE FOR DATA MSG
	CMPL	#EFN_K_READ_MAIL,R2	;HAS A MAIL READ EXPIRED?
	BNEQU	35$			;NOPE A DATA AST
	MOVZBL	#TST$K_MAILBUF,R4	;USE MAIL BUFFER SIZE
35$:
	MOVL	TST$QB_ASTADR(R0),R5	;AST ADDRESS FOR QIO
	BSBW	TST$QIOAST		;DO QIO WITH AST
	CHECK_SS			;MAKE SERVICE OKAY
	BRB	30$			;DEQUEUE ANOTHER
40$:
	MOVL	#EFN_K_DISC_SYNC,R2	; GET FUNCTION/INDEX CODE
	CLRL	R4			; P2 = 0
	BSBW	TST$QIOW		; DESTROY LINK WITH SYNC DISCONNECT
	CHECK_IOSB TST$GQ_LINKIOSB	;MAKE SURE DISCONNECT COMPLETES

;
; DATA TEST IS FINISHED
;

	MOVL	W^TST$GL_STATUS,R0	; POST STATUS
DATA_FAILURE:				; ENTER HERE IF TEST FAILED
	MOVAB	W^TST$GT_DATA,R1	; RETURN ADDRESS OF TEST ID STRING
	RSB				; EXIT

	.SBTTL	TST$DISC_DTS - DISCONNECT TEST
	.PSECT	TST$CODE	NOWRT

;++
; FUNCTIONAL DESCRIPTION:
;
;	NONE
;
; CALLING SEQUENCE:
;
;	BSB/JSB	TST$DISC_DTS
;
; INPUT PARAMETERS:
;
;	R10	TEST TYPE
;	R11	ADDRESS OF USERDATA COUNTED ASCII STRING
;
; IMPLICIT INPUTS:
;
;	TST$GT_USERDATA
;
; OUTPUT PARAMETERS:
;
;	R0	COMPLETION CODE
;	R1	ADDRESS OF TEST ID STRING
;	R2-R9	DESTROYED
;
; IMPLICIT OUTPUTS:
;
;	TST$GT_USERDATA UPDATED
;
; COMPLETION CODES:
;
;	R0	1 = SUCCESS; 0 = FAILURE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

TST$DISC_DTS::				; CONTROL POINT

;
; FINISH BUILDING THE DISCONNECT TEST REQUEST IN THE USERDATA STRING.
;
; THE DTS/R DISTYPE FIELD VALUE IS DERIVED FROM BOTH THE /TYPE AND THE
; /[NO]USERDATA QUALIFIER VALUES.
;

	MOVZBL	W^TST$GB_TYPE,R8	; GET TYPE QUALIFIER VALUE
	MOVZBL	W^TST$GB_RETURN,R9	; GET RETURN QUALIFIER VALUE
	ROTL	#1,R9,R0		; CONTYPE = RETURN * 2 + TYPE
	ADDB3	R0,R8,2(R11)		; UPDATE DISTYPE FIELD
	MOVB	#2,(R11)		; UPDATE USERDATA STRING LENGTH
	$CASEB	SELECTOR=R9,DISPL=<-	; CHECK RETURN OPTION:
		DISC_TEST-		;  /NORETURN
		DISC_TEST-		;  /RETURN=STANDARD
	>				;  /RETURN=RECEIVED
	MOVZBL	W^TST$GT_DISC,R0	; ADD TEXT TO USERDATA STRING
	ADDB2	R0,(R11)		; UPDATE USERDATA STRING LENGTH
	MOVC3	R0,W^TST$GT_DISC+1,3(R11) ; APPEND THE STRING

;
; ENTER INTO NSP CONNECT SEQUENCE WITH DTR.
;

DISC_TEST:				; START THE DISCONNECT TEST
	BSBW	TST$STARTUP_DTR		; INITIATE NSP CONNECT SEQUENCE
	BLBS	R0,10$			; WAS LINK ESTABLISHED?
	MOVL	#DTS$_CINREJ,R0		;NOTE REJECTION
	MOVL	W^TST$GQ_LINKIOSB+4,-
		W^TST$GL_FAOARG		;NOTE ABORT REASON
	BRB	DISC_FAILURE		; NO, SOMETHING WENT WRONG

;
; WAIT FOR DTR TO DISCONNECT THE LINK
;

10$:	MOVL	#EFN_K_READ_MAIL,R2	; GET FUNCTION/INDEX CODE
	MOVZBL	#TST$K_MAILBUF,R4	; GET MAILBOX BUFFER SIZE
	BSBW	TST$QIOW		; WAIT FOR RESPONSE
	BSBW	TST$EXAM_MAIL		; PARSE MAILBOX MESSAGE
	MOVL	#EFN_K_DISC_ABRT,R2	; GET FUNCTION/INDEX CODE
	CLRL	R4			; P2 = 0
	BSBW	TST$QIOW		; DISCONNECT ABORT THE LINK
	CHECK_IOSB TST$GQ_LINKIOSB	;MAKE SURE ABORT COMPLETES

;
; STORE THE EXPECTED DISCONNECT SYNCHRONOUS/ABORT CODE ON THE STACK AND BUILD
; THE EXPECTED RESPONSE COUNTED ASCII STRING IN TST$GT_USERDATA TO COMPARE
; AGAINST THE ACTUAL RESPONSE RECEIVED FROM DTR.
;

DISC_EXPECTED:				;
	MOVW	#MSG$_DISCON,-(SP)	; ASSUME SYNCHRONOUS DISCONNECT
	BLBC	R8,5$			; BRANCH IF SYNC DISC SPECIFIED
	MOVW	#MSG$_ABORT,(SP)	; NO, DISC ABORT IS SPECIFIED
5$:	$CASEB	SELECTOR=R9,DISPL=<-	; CHECK USERDATA OPTION:
		10$-			;  /NOUSERDATA
		20$-			;  /USERDATA=STANDARD
		DISC_RESPONSE-		;  /USERDATA=RECEIVED
	>				;
10$:	CLRB	(R11)			; ZERO USERDATA STRING LENGTH
	BRB	DISC_RESPONSE		; CONTINUE
20$:	MOVB	#16,(R11)		; UPDATE USERDATA STRING LENGTH
	MOVC3	#16,W^TST$GT_STANDARD+1,1(R11) ; COPY STANDARD DATA PATTERN

;
; CHECK ACTUAL RESPONSE FROM DTR AGAINST EXPECTED RESPONSE
;

DISC_RESPONSE:				; INTERROGATE RESPONSE
	CMPW	(SP)+,R6		; COMPARE EXPECTED VS ACTUAL
					;  RESPONSE FROM DTR
	BEQLU	10$			; IS IT OK?
	MOVL	#DTS$_DISBAD,R0		;NOTE WRONG KIND OF DISCONNECT
	BRB	DISC_FAILURE		;
10$:	CMPB	(R11),(R7)		; COMPARE EXPECTED VS ACTUAL
					;  USERDATA STRING LENGTH
	BEQLU	20$			; IS IS OK?
	MOVL	#DTS$_BADUSRLEN,R0	;INVALID USERDATA LENGTH
	BRB	DISC_FAILURE		;
20$:	MOVZBL	(R11),R0		; COMPARE EXPECTED VS ACTUAL
	CMPC3	R0,1(R11),1(R7)		;  USERDATA STRING VALUE
	BEQLU	DISC_SUCCESS		; IS IT OK?
	MOVL	#DTS$_BADUSRDAT,R0	;INVALID USER DATA
	BRB	DISC_FAILURE		; 
DISC_SUCCESS:				; TEST WAS SUCCESSFUL
	MOVL	#1,R0			; SET COMPLETION CODE TO SUCCESS
DISC_FAILURE:				; ENTER HERE IF TEST FAILED
	MOVAB	W^TST$GT_DISC,R1	; RETURN ADDRESS OF TEST ID STRING
	RSB				; EXIT

	.SBTTL	TST$INTE_DTS - INTERRUPT TEST
	.PSECT	TST$CODE	NOWRT

;++
; FUNCTIONAL DESCRIPTION:
;
;	NONE
;
; CALLING SEQUENCE:
;
;	BSB/JSB	TST$INTE_DTS
;
; INPUT PARAMETERS:
;
;	R10	TEST TYPE
;	R11	ADDRESS OF USERDATA COUNTED ASCII STRING
;
; IMPLICIT INPUTS:
;
;	TST$GT_USERDATA
;
; OUTPUT PARAMETERS:
;
;	R0	COMPLETION CODE
;	R1	ADDRESS OF TEST ID STRING
;	R2-R9	DESTROYED
;
; IMPLICIT OUTPUTS:
;
;	TST$GT_USERDATA UPDATED
;
; COMPLETION CODES:
;
;	R0	1 = SUCCESS; 0 = FAILURE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

TST$INTE_DTS::				; CONTROL POINT

;
;VERIFY MESSAGE SIZE FIELD
;

	MOVZWL	W^TST$GW_SIZE,R4	;[TGD]VALUE OF SIZE FIELD
	$CASEB SELECTOR=TST$GB_TYPE,DISPL=<-
	    40$-			;SINK TEST
	    10$-			;SEQUENCE TEST
	    20$-			;PATTERN TEST
	    40$-			;ECHO TEST
		>
10$:					;MIN SIZE OF SEQUENCE TEST IS 1

	MOVL	#4,R0			
	BRB	30$			;GO TO COMMON CODE

20$:					;MIN SIZE OF PATT CHECK IS 5
	MOVL	#5,R0
30$:					;IF SIZE TOO SMALL THEN ERROR
	CMPW	R0,R4
	BLEQ	40$			;IF /SIZE EXCEEDS MIN THEN OKAY
	MOVL	#2,R0			;ERROR CODE
	BRW	INTE_FAILURE		;GO TO COMMON ERROR CODE
40$:
;
; FINISH BUILDING THE INTERRUPT TEST REQUEST IN THE USERDATA STRING.
;

	MOVB	W^TST$GB_TYPE,2(R11)	; UPDATE INTTYPE FIELD
	MOVB	W^TST$GB_RQUEUE,3(R11)	; UPDATE INTFC FIELD
	MOVB	#3,(R11)		; UPDATE USERDATA STRING LENGTH

;
; ENTER INTO NSP CONNECT SEQUENCE WITH DTR.
;

INTE_TEST:				; START THE INTE TEST
	BSBW	TST$STARTUP_DTR		; INITIATE NSP CONNECT SEQUENCE
	BLBS	R0,INTE_INIT		; WAS LINK ESTABLISHED?
	MOVL	#DTS$_CINREJ,R0		;NOTE ABORTED CONNECT
	MOVL	W^TST$GQ_LINKIOSB+4,-
		W^TST$GL_FAOARG	;NOTE REASON
	BRW	INTE_FAILURE

;
; INTERRUPT TEST INITIALIZATION
;

INTE_INIT:				; CONTINUE
	CLRQ	W^TST$GL_XMITDATA	; ZERO TRANSMIT AND RECEIVE
					;  MESSAGE COUNTERS
	CLRQ	W^TST$GL_XMITINTE	; ZERO TRANSMIT AND RECEIVE
					;  INTERRUPT MESSAGE COUNTERS
	MOVL	#1,W^TST$GL_STATUS	; SET AST STATUS CODE TO SUCCESS
	CLRB	W^TST$GB_ASTFLAGS	;NOTE TIMER RUNNING
	MOVAL	TST$QB_QHEAD,TST$QB_QHEAD;INIT QUEUE HEAD
	MOVAL	TST$QB_QHEAD,TST$QB_QHEAD+4

;
; PUT REPETITIONS OF THE STANDARD DATA PATTERN IN THE MESSAGE BUFFER
; BEGINNING AT BUFFER+4.
;

	MOVAB	W^TST$GB_INTEBUF,R3	; GET ADDRESS OF MESSAGE
	MOVL	#1,(R3)+		; INITIALIZE MESSAGE SEQUENCE NUMBER
	MOVZWL	W^TST$GW_SIZE,R4	; GET MESSAGE SIZE
	CMPW	R4,#4			;[TGD]ANY DAT IN MESSAGE
	BLEQ	10$			;NOPE DONT FILL BUFFER
	SUBL2	#4,R4			; REDUCE SIZE ACCORDINGLY
	BSBW	TST$STANDARD		; PUT STD DATA PATTERN IN BUFFER

10$:
;
; SET TIMER 
;

	MOVL	W^TST$GL_SECONDS,W^TST$GL_CLOCK	;SETUP COUNTDOWN LOCATION
	$SETIMR_S EFN=#EFN_K_TIMER-	;
		DAYTIM=W^TST$GQ_NANOSEC- ;
		ASTADR=W^TST$TIMER_DTS	;
	CHECK_SS			; CHECK STATUS CODE

;
; TRANSMIT [AND RECEIVE] INTERRUPT MESSAGES UNTIL TIMER EXPIRES
;

	MOVL	#EFN_K_READ_MAIL,R2	; GET FUNCTION/INDEX CODE
	MOVZBL	#TST$K_MAILBUF,R4	; GET MAILBOX BUFFER SIZE
	MOVAB	W^TST$MAILAST_DTS,R5	; GET ADDRESS OF AST ROUTINE
	BSBW	TST$QIOAST		; ISSUE READ TO MAILBOX
	MOVL	#EFN_K_XMIT_INTE,R2	; GET FUNCTION/INDEX CODE
	MOVZWL	W^TST$GW_SIZE,R4	; GET MESSAGE SIZE
	MOVAB	W^TST$INTEAST_DTS,R5	; GET ADDRESS OF AST ROUTINE
	BSBW	TST$QIOAST		; START UP TRANSMIT MESSAGE STREAM

;
; WAIT EITHER FOR TIMER TO EXPIRE OR FOR LINK DISCONNECT
;


	BRB	30$			;CHECK FOR ASTS 
20$:
	$HIBER_S			;GO TO SLEEP TILL AN AST
30$:
	BLBS	W^TST$GB_ASTFLAGS,40$	;JUMP IF TIMER EXPIRED
	REMQUE	@TST$QB_QHEAD,R0	;DEQUEUE AN AST
	BVS	20$			;NOTHING THERE ,SLEEP
	MOVL	TST$QB_CODE(R0),R2		;QIO FUNCTION/CODE
	MOVZWL	TST$GW_SIZE,R4		;SIZE FOR DATA MSG
	CMPL	#EFN_K_READ_MAIL,R2	;HAS A MAIL READ EXPIRED?
	BNEQU	35$			;NOPE A DATA AST
	MOVZBL	#TST$K_MAILBUF,R4	;USE MAIL BUFFER SIZE
35$:
	MOVL	TST$QB_ASTADR(R0),R5	;AST ADDRESS FOR QIO
	BSBW	TST$QIOAST		;DO QIO WITH AST
	CHECK_SS			;MAKE SERVICE OKAY
	BRB	30$			;DEQUEUE ANOTHER
40$:
	MOVL	#EFN_K_DISC_SYNC,R2	; GET FUNCTION/INDEX CODE
	CLRL	R4			; P2 = 0
	BSBW	TST$QIOW		; DESTROY LINK WITH SYNC DISCONNECT
	CHECK_IOSB TST$GQ_LINKIOSB	;MAKE SURE DISCONNECT SUCCEEDS

;
; INTERRUPT TEST IS FINISHED
;

	MOVL	W^TST$GL_STATUS,R0	; POST STATUS
INTE_FAILURE:				; ENTER HERE IF TEST FAILED
	MOVAB	W^TST$GT_INTE,R1	; RETURN ADDRESS OF TEST ID STRING
	RSB				; EXIT

	.SBTTL	TST$MISC_DTS - MISCELLANEOUS TEST
	.PSECT	TST$CODE	NOWRT

;++
; FUNCTIONAL DESCRIPTION:
;
;	NONE
;
; CALLING SEQUENCE:
;
;	BSB/JSB	TST$MISC_DTS
;
; INPUT PARAMETERS:
;
;	R10	TEST TYPE
;	R11	ADDRESS OF USERDATA COUNTED ASCII STRING
;
; IMPLICIT INPUTS:
;
;	TST$GT_USERDATA
;
; OUTPUT PARAMETERS:
;
;	R0	COMPLETION CODE
;	R1	ADDRESS OF TEST ID STRING
;	R2-R9	DESTROYED
;
; IMPLICIT OUTPUTS:
;
;	TST$GT_USERDATA UPDATED
;
; COMPLETION CODES:
;
; SIDE EFFECTS:
;
; SIDE EFFECTS:
;
;	NONE
;
;--

TST$MISC_DTS::				; CONTROL POINT
	BRW	MISC_SUCCESS		;

;
; FINISH BUILDING THE MISCELLANEOUS TEST REQUEST IN THE USERDATA STRING.
;

	MOVB	W^TST$GB_TYPE,2(R11)	; UPDATE MISCTYPE FIELD
	MOVL	#2,(R11)		; UPDATE USERDATA STRING LENGTH

;
; ENTER INTO NSP CONNECT SEQUENCE WITH DTR.
;

MISC_TEST:				; START THE DATA TEST
	BSBW	TST$STARTUP_DTR		; INITIATE NSP CONNECT SEQUENCE
	BLBS	R0,5$			; WAS LINK ESTABLISHED?
	BRW	MISC_FAILURE		; NO, SOMETHING WENT WRONG

5$:	$CASEB	SELECTOR=R10,DISPL=<-	; START THE MISCELLANEOUS TEST
		10$-			;  ILLEGAL NODE NAME
		20$-			;  NON-EXISTANT OBJECTTYPE
		30$-			;  LOGICAL LINK ADDRESS
	>				;
10$:	MOVQ	W^TST$GT_NODENAME,-(SP)	; SAVE NODENAME
	MOVQ	#^A/ILLEGAL:/,W^TST$GT_NODENAME ; ONLY ONE COLON
	BSBB	MISC_COMMON		; COMMON CODE
	MOVQ	(SP)+,W^TST$GT_NODENAME	; RESTORE NODENAME
	BRB	MISC_SUCCESS		; FINISHED
20$:	MOVW	W^TST$GT_OBJTYPE,-(SP)	; SAVE OBJECTTYPE
	MOVW	#^A/59/,W^TST$GT_OBJTYPE ; UNKNOWN OBJECTTYPE
	BSBB	MISC_COMMON		; COMMON CODE
	MOVW	(SP)+,W^TST$GT_OBJTYPE	; RESTORE OBJECTTYPE
	BRB	MISC_SUCCESS		; FINISHED
30$:	BSBB	MISC_COMMON		; COMMON GODE
	BRB	MISC_SUCCESS		; FINISHED
MISC_COMMON:				;
	RSB				; EXIT
MISC_SUCCESS:				; TEST WAS SUCCESSFUL
	MOVL	#1,R0			; SET COMPLETION CODE TO SUCCESS
MISC_FAILURE:				; ENTER HERE IF TEST FAILED
	MOVAB	W^TST$GT_MISC,R1	; RETURN ADDRESS OF TEST ID STRING
	RSB				; EXIT

	.SBTTL	TST$STARTUP_DTR - DTS/DTR INITIALIZATION
	.PSECT	TST$CODE	NOWRT

;++
; FUNCTIONAL DESCRIPTION:
;
;	NONE
;
; CALLING SEQUENCE:
;
;	BSB/JSB	TST$STARTUP_DTR
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	TST$GT_NODENAME	- COUNTED ASCII STRING OF NODENAME
;	TST$GT_OBJTYPE	- COUNTED ASCII STRING OF NSP OBJECT TYPE
;	TST$GT_USERDATA	- COUNTED ASCII STRING OF NSP USERDATA
;			  CONTAINING TEST REQUEST PARAMETERS FOR DTR
;
; OUTPUT PARAMETERS:
;
;	R0	COMPLETION CODE
;	R6	MAILBOX MESSAGE CODE
;	R7	ADDRESS OF RECEIVED MAILBOX DATA LESS HEADER STORED AS A
;		COUNTED ASCII STRING
;
; IMPLICIT OUTPUTS:
;
;	TST$GQ_ACCESS	- QIO ACCESS DESCRIPTOR BLOCK
;	TST$GB_NCB	- CONSTRUCTED NETWORK CONNECT BLOCK
;	TST$GW_MAILCODE	- MAILBOX MESSAGE CODE
;	TST$GW_DEV_UNIT	- DEVICE UNIT NUMBER
;	TST$GT_DEV_NAME	- DEVICE NAME STORED AS A COUNTED STRING
;	TST$GT_MAILDATA	- DATA FIELD OF MAILBOX MESSAGE STORED AS A
;			  COUNTED STRING
;
; COMPLETION CODES:
;
;	R0	1 = LINK WAS ESTABLISHED; 0 = LINK WAS NOT ESTABLISHED
;
; SIDE EFFECTS:
;
;	NONE
;
;--

TST$STARTUP_DTR::			; CONTROL POINT
	PUSHR	#^M<R2,R3,R4,R5>	; SAVE REGISTERS
	MOVAL	W^TST$GQ_ACCESS,R6	; GET ADDRESS OF QIO ACCESS
					; DESCRIPTOR BLOCK
	MOVAL	W^TST$GB_NCB,R3		; GET ADDRESS OF NCB BUFFER
	MOVL	R3,4(R6)		; UPDATE ACCESS DESCRIPTOR BLOCK
	MOVZBL	W^TST$GT_NODENAME,R0	; COPY NODENAME INTO NCB
	MOVC3	R0,W^TST$GT_NODENAME+1,(R3) ; SOURCE IS COUNTED ASCII STRING
	MOVW	#^A\::\,(R3)+		; APPEND DELIMITER
	MOVB	#^A\"\,(R3)+		; APPEND LEADING QUOTE
	MOVZBL	W^TST$GT_OBJTYPE,R0	; COPY OBJECTTYPE INTO NCB
	MOVC3	R0,W^TST$GT_OBJTYPE+1,(R3) ; SOURCE IS COUNTED ASCII STRING
	MOVB	#^A\/\,(R3)+		; APPEND DELIMITER
	CLRW	(R3)+			; ZERO NETACP LINK INDEX
	MOVZBL	W^TST$GT_USERDATA,R0	; COPY USERDATA STRING TO NCB
	INCL	R0			;  (INCLUDING THE COUNT)
	MOVC3	R0,W^TST$GT_USERDATA,(R3) ; SOURCE IS COUNTED ASCII STRING
	MOVB	#^A\"\,(R3)+		; APPEND TRAILING QUOTE
	SUBL3	4(R6),R3,(R6)		; CALCULATE AND STORE LENGTH OF NCB

;
; ISSUE THE NSP CONNECT INITIATE REQUEST TO ACTIVATE DTR
;

	$CANCEL_S CHAN=W^TST$GW_MAILCHAN	;CANCEL ANY MAILBOX READS
	CHECK_SS
	BSBW	TST$FLUSH_MAIL		;CLEAN OUT ANYTHING IN MAILBOX
	MOVL	#EFN_K_CONN_INIT,R2	; GET FUNCTION/INDEX CODE
	MOVL	R6,R4			; P2 = ADDRESS OF ACCESS DESC BLOCK
	BSBW	TST$QIOW		; ISSUE CONNECT INITIATE
	CHECK_IOSB TST$GQ_LINKIOSB	;MAKE SURE CONNECT SENT OKAY

;
; DETERMINE WHETHER LINK HAS BEEN ESTABLISHED OR NOT.
;

	MOVL	#EFN_K_READ_MAIL,R2	; GET FUNCTION/INDEX CODE
	MOVZBL	#TST$K_MAILBUF,R4	; GET MAILBOX BUFFER SIZE
	BSBW	TST$QIOW		; WAIT FOR RESPONSE
	BSBW	TST$EXAM_MAIL		; PARSE MAILBOX MESSAGE
	CLRL	R0			; SET COMPLETION CODE TO FAILURE
	CMPW	R6,#MSG$_CONFIRM	; IS LINK ESTABLISHED?
	BNEQU	10$			; NO
	INCL	R0			; YES, SET COMP CODE TO SUCCESS
10$:	POPR	#^M<R2,R3,R4,R5>	; RESTORE REGISTERS
	RSB				; EXIT
	.END
