MODULE LIB_GETCMD (			! Get LIBRARIAN command line
		LANGUAGE (BLISS32),
		IDENT = 'V03-000'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:  Library command processor
!
! ABSTRACT:
!
!	The VAX/VMS librarian is invoked by DCL to process the LIBRARY
!	command.  It utilizes the librarian procedure set to perform
!	the actual modifications to the library.
!
! ENVIRONMENT:
!
!	VAX native, user mode.
!
!--
!
!
! AUTHOR:  Benn Schreiber,	 CREATION DATE:  11-June-1979
!
! MODIFIED BY:
!
!	V02-020		RPG0020		Bob Grosso	02-Mar-1982
!		Disable redundant error message.
!
!	V02-019		RPG0019		Bob Grosso	05-Feb-1982
!		Enable /EXTR/RSX to work by fixing message for
!		for /EXTR which is not currently allowed.
!
!	V02-018		RPG0018		Bob Grosso	04-Feb-1982
!		Use lib$file_scan.
!
!	V02-017		RPG0017		Bob Grosso	06-Jan-1982
!		Remove unused symbol.
!
!	V02-016		RPG0016		Bob Grosso	18-Dec-1981
!		Correct addressing mode of lib$tparse.
!
!	V02-015		RPG0015		Bob Grosso	2-Oct-1981
!		Enable stickiness on input2 files.
!
!	V02-014		RPG0014		Bob Grosso	7-Aug-1981
!		lib$gl_ctlmsk now a quadword
!		Support /BEFORE and /SINCE
!
!	V02-013		RPG0043		Bob Grosso	22-Jul-1981
!		Use TPARSE for CREATE and COMPRESS values.
!
!	V02-012		RPG0040		Bob Grosso	8-May-1981
!		Enable library history creation and listing.
!
!	V02-011		RPG0037		Bob Grosso	1-May-1981
!		Change nam$c_bln_dirwc to nam$c_bln
!
!	V02-010		RPG0035		Bob Grosso	20-Apr-1981
!		Initialize listhead for modified modules' names.
!
!	V02-009		BLS0029		Benn Schreiber	23-Dec-1980
!		Convert messages to message compiler.  Add shareable
!		image symbol table library
!
!	V02-008		RPG0005		Bob Grosso	23-Oct-1980
!		Clear buffer so that "LIB/CREATE lib *.ext,file.ext"
!		will work.
!		Change CREATELIB to return value true.
!
!	V02-007		RPG31920	Bob Grosso	28-Aug-1980
!		Check for '>' in resultant filename string also to prevent
!		access violation if directory name is <dir>.
!
!	V02-006		BLS0005		Benn Schreiber	28-Aug-1980
!		/NAME does not imply /LIST
!--



LIBRARY
	'SYS$LIBRARY:STARLET.L32';		!System data structure definitions
LIBRARY
	'SYS$LIBRARY:CLIMAC.L32';		!Command language data structure defs.
LIBRARY
	'SYS$LIBRARY:TPAMAC.L32';		!Table driven finite state parser macros
REQUIRE
	'PREFIX';				!Macro defs, etc.
REQUIRE
	'LIBDEF';				!Librarian command interface definitions

LITERAL
    fdbsize = fdb$c_size + nam$c_bln		!Define total size of an FDB
		+ (2 * nam$c_maxrss);

EXTERNAL ROUTINE
    getfilnamdesc,				!Return string descriptor for filename
    lib_get_mem,				!Allocate virtual memory
    lib$cvt_time : ADDRESSING_MODE (GENERAL),	!convert ascii time to binary
    lib$file_scan : ADDRESSING_MODE (GENERAL),	!Find wild-card files
    lib$tparse : ADDRESSING_MODE (GENERAL),	!Table driven parser
    lib_free_mem;				!Deallocate virtual memory

FORWARD ROUTINE
    clearsqueeze,				!Clear local squeeze bit
    setsqueeze,					!Set local squeeze bit
    selectcrosref,				!Select cross reference options
    scan_options,				!Scan create/compress options
    call_tparse,				!call lib$tparse
    syntaxerr,					!report tparse syntaxerr
    value_req,					!Set flag that a value is required on create/compress option.
    lookup_keyword,				!Lookup option with abbreviations
    set_macro_type,				!/MACRO
    set_object_type,				!/OBJECT
    set_help_type,				!/HELP
    set_text_type,				!/TEXT
    set_shr_type,				!/SHARE
    set_lib_type,				!Does the work for set_xx_type
    listonlymods,				!/ONLY
    setmodulename,				!/MODULE
    compressfile,				!/COMPRESS
    createlib,					!/CREATE
    extractfile,				!/EXTRACT
    deletemodules,				!/DELETE
    setlistfile,				!/LIST
    setlistwidth,				!/WIDTH
    removesymbols,				!/REMOVE
    outputfile,					!/OUTPUT processor
    input1file,					!Primary input file processor
    input2file,					!Secondary input file processor
    get_name_list,				!Extract args from qualifier
    filescantruact,				!Action routine for successful file scan
    filescanflsact,				!Action routine for unsuccessful scan
    initialize_fdb,				!Initialize an FDB
    date_parse,					!Parse date for /BEFORE and /SINCE
    allocate_fdb,				!Allocate file descriptor block
    clierror;					!Process CLI errors

EXTERNAL
    lib$before_date : BBLOCK,			!Date from /BEFORE
    lib$since_date : BBLOCK,			!Date from /SINCE
    lib$al_creopts : VECTOR [,LONG],		!Array of create option values
    lib$gl_cre8flags : BITVECTOR,		!Bit flags for specified create/compress options
    lib$gl_listwid,				!width of library list line
    lib$gl_type,				!Library type
    lib$gl_modlisl : VECTOR [2],		!Listhead for "list only" name list
    lib$gl_modxtrl : VECTOR [2],		!Listhead for module extraction
    lib$gl_modupdl : VECTOR [2],		!Listhead for library updates
    lib$gl_objsyrml : VECTOR [2],		!Listhead for object module symbol removal
    lib$gl_delmodl : VECTOR [2],		!Listhead for deleted module list
    lib$gl_ctlmsk : BLOCK [2],			!Control mask for Librarian
    lib$gl_libfdb : REF BBLOCK,			!FDB for library file
    lib$gl_outfdb : REF BBLOCK,			!FDB for output file
    lib$gl_lisfdb : REF BBLOCK,			!FDB for listing file
    lib$gl_tmpfdb : REF BBLOCK,			!FDB for temporary use
    lib$gl_inplist : REF BBLOCK,		!Listhead for input files list
    lib_mac_defext : BBLOCK,			!Default extension for macro source files
    lib_obj_defext : BBLOCK,			!...for object files
    lib_hlp_defext : BBLOCK,			!...for help files
    lib_txt_defext : BBLOCK,			!...for text files
    lib_shr_defext : BBLOCK;			!...for shr img stb libraries

GLOBAL
    lib$gl_tpindex,
    lib$gl_valreq,
    lib$gl_creflags : BLOCK [1];		!Cross reference flags
!
! Declare the qualifier codes
!
$CLIQUALCODES (LIBR,				!For the LIBRARIAN
	COMPRESS,				!Compress the library
	CREATE,					!Create the library
	DELETE,					!Delete modules from the library
	EXTRACT,				!Extract modules from the library
	INSERT,					!Insert modules into the library
	LIST,					!List the contents of the library
	HISTORY,				!List the library's history
	BEFORE,					!List entities dated before 
	SINCE,					!List entities dated since
	REMOVE,					!Remove symbols from the library index
	REPLACE,				!Replace a module in the library
	MACRO,					!Library type is MACRO
	OBJECT,					!Library type is OBJECT
	MODU,					!Name module for text libraries
	ONLY,					!List only selected modules
	TEXT,					!Library type is TEXT
	SHARE,					!Library type is shr img stb
	HELP,					!Library type is HELP
	WIDT,					!Set listing width
	NAME,					!List symbol names also on /LIST
	FULL,					!Full listing of library
	GLOBALS,				!Include global symbols with inserted modules
	SELECTIVE,				!Define input modules as selectively searched
	LOG,					!Log operations
	CROSS,					!Cross reference of object libraries
	SQUEEZE);				!Compress macros before insertion
!
! CLI callback structures
!
OWN

input2_quals:							!Qualifiers for input2
	$cliqualdesc (QDCODE=sele,
		TSTLST = (lib$s_extract),
		SETLST = (lib$s_selective)),
module_qual:
	$cliqualdesc (QDCODE=modu,
		TSTLST= (lib$s_extract),
		SETLST= (lib$s_module),
		TRUACT= (setmodulename-module_qual)),

input2_qual_end:
	$cliqualend,

compress_qual:
	$cliqualdesc (QDCODE=comp,				!compress
		TSTLST= (lib$s_create,lib$s_extract),
		TRUACT= (compressfile-compress_qual),
		SETLST= (lib$s_compress)),
create_qual:
	$cliqualdesc (QDCODE=crea,				!Create
		TSTLST= (lib$s_compress,lib$s_extract),
		TRUACT= (createlib-create_qual),
		SETLST= (lib$s_create)),
cross_qual:
	$cliqualdesc (QDCODE = cros,				!Cross reference
		TSTLST = (lib$s_extract, lib$s_list,
			lib$s_macro, lib$s_help,
			lib$s_text),
		SETLST = lib$s_cross,
		TRUACT = (selectcrosref - cross_qual)),
delete_qual:
	$cliqualdesc (QDCODE=dele,				!Delete
		TSTLST= (lib$s_extract),
		SETLST= (lib$s_delete),
		TRUACT= (deletemodules-delete_qual)),
extract_qual:
	$cliqualdesc (QDCODE=extr,				!Extract
		TSTLST= (lib$s_compress,lib$s_create,
			lib$s_delete,lib$s_insert,
			lib$s_list,lib$s_remove,
			lib$s_replace,lib$s_names,
			lib$s_full,lib$s_globals,
			lib$s_selective,lib$s_squeeze,
			lib$s_cross),
		TRUACT= (extractfile-extract_qual),
		SETLST= (lib$s_extract)),
insert_qual:
	$cliqualdesc (QDCODE=inse,				!Insert
		TSTLST= (lib$s_extract),
		CLRLST= (lib$s_replace),
		SETLST= (lib$s_insert)),
list_qual:
	$cliqualdesc (QDCODE=list,				!List
		TSTLST= (lib$s_extract,lib$s_cross),
		SETLST= (lib$s_list),
		TRUACT= (setlistfile-list_qual)),
history_qual:
	$cliqualdesc (QDCODE=hist,				!History
		TSTLST= (lib$s_extract,lib$s_cross),
		SETLST= (lib$s_history)),
before_qual:
	$cliqualdesc (QDCODE=befo,				!Before
		TSTLST= (lib$s_extract,lib$s_cross),
		SETLST= (lib$s_before),
		TRUACT= (date_parse-before_qual)),
since_qual:
	$cliqualdesc (QDCODE=sinc,				!Since
		TSTLST= (lib$s_extract,lib$s_cross),
		SETLST= (lib$s_since),
		TRUACT= (date_parse-since_qual)),
remove_qual:
	$cliqualdesc (QDCODE=remo,				!Remove global symbols
		TSTLST= (lib$s_extract, lib$s_text,
			lib$s_help, lib$s_macro,
			lib$s_object),
		SETLST= (lib$s_remove),
		TRUACT= (removesymbols-remove_qual)),
replace_qual:
	$cliqualdesc (QDCODE=repl,				!Replace
		TSTLST= (lib$s_extract),
		SETLST= (lib$s_replace,lib$s_insert)),
macro_qual:
	$cliqualdesc (QDCODE=macr,				!Macro library
		TSTLST= (lib$s_object,lib$s_text,
			lib$s_shrstb,lib$s_help),
		SETLST= (lib$s_macro),
		TRUACT= (set_macro_type-macro_qual)),
object_qual:
	$cliqualdesc (QDCODE=obje,				!Object library
		TSTLST= (lib$s_macro,lib$s_text,
			lib$s_shrstb,lib$s_help),
		SETLST= (lib$s_object),
		TRUACT= (set_object_type-object_qual)),
!address_qual:
!	$cliqualdesc (QDCODE=addr,
!	TSTLST= (lib$s_extract),
!		SETLST= (lib$s_address)),
only_qual:
	$cliqualdesc (QDCODE=only,
		TSTLST= (lib$s_extract),
		SETLST= (lib$s_only),
		TRUACT= (listonlymods-only_qual)),
text_qual:
	$cliqualdesc (QDCODE=text,
		TSTLST= (lib$s_macro,lib$s_object,
			lib$s_shrstb,lib$s_help),
		SETLST= (lib$s_text),
		TRUACT= (set_text_type-text_qual)),
help_qual:
	$cliqualdesc (QDCODE=help,
		TSTLST= (lib$s_macro,lib$s_object,
			lib$s_shrstb,lib$s_text),
		SETLST= (lib$s_help),
		TRUACT= (set_help_type-help_qual)),
share_qual:
	$cliqualdesc (QDCODE=share,
		TSTLST= (lib$s_macro,lib$s_object,
			lib$s_text,lib$s_help),
		SETLST= (lib$s_shrstb),
		TRUACT=	(set_shr_type-share_qual)),
width_qual:
	$cliqualdesc (QDCODE=widt,				!Set list width
		TSTLST= (lib$s_extract),
		TRUACT= (setlistwidth-width_qual)),
log_qual:
	$cliqualdesc (QDCODE=log,				!Log operations
		SETLST= (lib$s_log)),
names_qual:
	$cliqualdesc (QDCODE=name,				!Names
		TSTLST= (lib$s_extract,lib$s_macro,
			lib$s_text,lib$s_help),
		SETLST= (lib$s_names)),
full_qual:
	$cliqualdesc (QDCODE=full,				!Full listing
		TSTLST= (lib$s_extract),
		SETLST= (lib$s_full)),
globals_qual:
	$cliqualdesc (QDCODE=glob,				!Globals
		TSTLST= (lib$s_extract,lib$s_macro,
			lib$s_help,lib$s_text),
		SETLST= (lib$s_globals)),
squeeze_qual:
	$cliqualdesc (QDCODE=sque,				!Squeeze macros
		TSTLST= (lib$s_extract,lib$s_help,
			lib$s_text),
		SETLST= (lib$s_squeeze),
		QDFLGS= (qdexpa),				!Only call action routines if explicit
		TRUACT= (setsqueeze-squeeze_qual),
		FLSACT= (clearsqueeze-squeeze_qual)),
qual_qual_end:
	$cliqualend,
init_parse_desc:						!Descriptor for initial parse request
	$clireqdesc (RQTYPE=initprs,
		ERRACT=clierror-init_parse_desc),		!Error routine

end_parse_desc:							!Descriptor for end parse request
	$clireqdesc (RQTYPE=endprm1,
		ERRACT=clierror-end_parse_desc),

input1_desc:							!Descriptor for primary input file
	$clireqdesc (RQTYPE=input1,
		ERRACT=clierror-input1_desc,
		PRSACT=input1file-input1_desc,
		RQFLGS=parmreq),				!Requires a parameter

input2_desc:							!Descriptor for secondary inputs
	$clireqdesc (RQTYPE=input2,
		ERRACT=clierror-input2_desc,
		PRSACT=input2file-input2_desc,
		QUALST=input2_quals-input2_desc),

output_desc:							!Descriptor for outputs
	$clireqdesc (RQTYPE=output1,
		prsact=outputfile-output_desc,
		ERRACT=clierror-output_desc),

qual_desc:							!Descriptor to get qualifiers
	$clireqdesc (RQTYPE=getqual,
		ERRACT=clierror-qual_desc,
		QUALST=compress_qual-qual_desc),
!
! Other OWN storage
!
    squeeze_flag : INITIAL (1),				!Cleared if /NOSQUEEZE.
    def_lib_extn : BBLOCK [dsc$c_s_bln],		!Default extension for libraries
    def_fil_extn : BBLOCK [dsc$c_s_bln],		!Default extension for other files
    lastfdb : REF BBLOCK,				!Pointer to last FDB allocated
    prevfdb : REF BBLOCK,				!Pointer to previous of last
    sysoutputdesc : descriptor ('SYS$OUTPUT:'),		!String descriptor for SYS$OUTPUT
    modulenamedesc : BBLOCK [dsc$c_s_bln],		!String descriptor for /MODULE=
    relnamblk : REF BBLOCK,				!Related name block pointer
    cliworkptr,						!Pointer to cli work area
    filesnotfound,					!Count of not found files
    crf_bysymbol : descriptor ('SYMBOL'),		!Cross reference by symbol
    crf_byvalue  : descriptor ('VALUE'),		!Cross reference by value
    crf_bymodule : descriptor ('MODULE'),		!Cross reference by module
    crf_bynone : LONG INITIAL (0),			!End of crf options
    all_options : descriptor ('ALL'),			!All of the options
    no_options : descriptor ('NONE'),			!None of the options
    end_options : LONG INITIAL (0),			!End of all/none

    tpa_block : BBLOCK [tpa$k_length0],			!tparse block
    tpa_desc : REF BBLOCK;				!pointer to current string descriptor


!
!   TPARSE tables to parse /CREATE=() qualifier values.
!
$INIT_STATE (create_states, create_keys);

$STATE (,
	('BLOCKS',tpa$_exit,value_req,lib$c_opt_blks, lib$gl_tpindex,true),
	('GLOBALS',tpa$_exit,value_req,lib$c_opt_gbls, lib$gl_tpindex,true),
	('MODULES',tpa$_exit,value_req,lib$c_opt_mods, lib$gl_tpindex,true),
	('KEYSIZE',tpa$_exit,value_req,lib$c_opt_ksz, lib$gl_tpindex,true),
	('HISTORY',tpa$_exit,value_req,lib$c_opt_luhs, lib$gl_tpindex,true),
	('VERSION',tpa$_exit,value_req,lib$c_opt_ver, lib$gl_tpindex,true),
	(tpa$_lambda,tpa$_exit,syntaxerr, , ,lib$_badkey),
	);


$INIT_STATE (compress_states, compress_keys);

$STATE (,
	('BLOCKS',tpa$_exit,value_req,lib$c_opt_blks, lib$gl_tpindex,true),
	('GLOBALS',tpa$_exit,value_req,lib$c_opt_gbls, lib$gl_tpindex,true),
	('MODULES',tpa$_exit,value_req,lib$c_opt_mods, lib$gl_tpindex,true),
	('KEYSIZE',tpa$_exit,value_req,lib$c_opt_ksz, lib$gl_tpindex,true),
	('HISTORY',tpa$_exit,value_req,lib$c_opt_luhs, lib$gl_tpindex,true),
	('VERSION',tpa$_exit,value_req,lib$c_opt_ver, lib$gl_tpindex,true),
	('KEEP', tpa$_exit,value_req,1^lib$c_opt_keep, lib$gl_cre8flags,false),
	(tpa$_lambda,tpa$_exit,syntaxerr,,, lib$_badkey),
	);

GLOBAL ROUTINE lib_get_command  (arglist) =
BEGIN

!++
! This routine initializes the CLI result parser and then re-calls it for the
! processing of each command.
!
! Inputs:
!
!	arglist		pointer to the argument list that invoked the image
!
! Outputs:
!
!	the command is parsed, data structures filled in.
!
!--

MAP
	arglist : REF BBLOCK;

LOCAL
	cliworkarea : BBLOCK [cli$c_workarea],
	status;

BIND ROUTINE
	recallcli = .arglist [cli$a_utilserv];

CH$FILL (0, cli$c_workarea, cliworkarea);		!Zero cli work area
cliworkptr = cliworkarea;				!Point to it for lower routines
lastfdb = lib$gl_inplist;				!Init the last FDB pointer
prevfdb = lib$gl_inplist;				! and the prev. fdb pointer
lib$gl_inplist = 0;					!Init input FDB listhead
relnamblk = 0;
set_lib_type (lib$s_object, lib_obj_defext);		!Set object as default library type
!
! Initialize the name list queue headers
!
lib$gl_modlisl [0] = lib$gl_modlisl;
lib$gl_modlisl [1] = lib$gl_modlisl;
lib$gl_modxtrl [0] = lib$gl_modxtrl;
lib$gl_modxtrl [1] = lib$gl_modxtrl;
lib$gl_modupdl [0] = lib$gl_modupdl;
lib$gl_modupdl [1] = lib$gl_modupdl;
lib$gl_objsyrml [0] = lib$gl_objsyrml;
lib$gl_objsyrml [1] = lib$gl_objsyrml;
lib$gl_delmodl [0] = lib$gl_delmodl;
lib$gl_delmodl [1] = lib$gl_delmodl;
!
! Initiate result parsing
!
recallcli (init_parse_desc, cliworkarea);
recallcli (qual_desc, cliworkarea, lib$gl_ctlmsk);		!Process command qualifier options
lib$gl_ctlmsk [lib$v_squeeze] = .squeeze_flag;			!Propogate the squeeze flag
recallcli (input1_desc, cliworkarea, lib$gl_ctlmsk);		!Process primary input (library name)
recallcli (output_desc, cliworkarea, lib$gl_ctlmsk);		!Process output
filesnotfound = 0;

IF NOT (.lib$gl_ctlmsk [lib$v_compress]
	OR .lib$gl_ctlmsk [lib$v_extract]) 			!Unless compress or extract
THEN DO BEGIN
    lib$gl_ctlmsk [lib$v_selective] = false;			!Clear selective bit
    CH$FILL (0, dsc$c_s_bln, modulenamedesc);			!Clear /module descriptor
    recallcli (input2_desc, cliworkarea, lib$gl_ctlmsk);	!Process secondary input file
    IF .lib$gl_ctlmsk [lib$v_selective]				!If selective search was seen
    THEN lastfdb [fdb$v_setsel] = true;
    END
    UNTIL NOT .input2_desc [cli$v_concatinp];			!As long as there are more files

IF .lib$gl_inplist EQL 0					!If all files specified
    AND .filesnotfound NEQ 0					! were not found
    THEN IF .lib$gl_ctlmsk [lib$v_create]			!If creating
	    THEN RETURN false					! then nothing to do
	    ELSE IF NOT .lib$gl_ctlmsk [lib$v_delete]		! otherwise, if no other function selected
				AND NOT .lib$gl_ctlmsk [lib$v_extract]
				AND NOT .lib$gl_ctlmsk [lib$v_list]
				AND NOT .lib$gl_ctlmsk [lib$v_remove] 
				AND NOT .lib$gl_ctlmsk [lib$v_compress]
				AND NOT .lib$gl_ctlmsk [lib$v_cross]
		THEN RETURN false;				!  then nothing to do

IF .lib$gl_inplist NEQ 0					!If input files are present
    AND NOT .lib$gl_ctlmsk [lib$v_insert]			! and did not say insert or replace
THEN lib$gl_ctlmsk [lib$v_replace] = lib$gl_ctlmsk [lib$v_insert] = true;	! then make sure this is a replace
!
! Terminate parse
!
recallcli (end_parse_desc, cliworkarea);
CH$MOVE (dsc$c_s_bln, def_lib_extn, lib$gl_libfdb [fdb$l_defext]);
IF .lib$gl_ctlmsk [lib$v_insert] OR .lib$gl_ctlmsk [lib$v_delete] !If insert, remove
OR .lib$gl_ctlmsk [lib$v_remove]				!or delete
THEN allocate_fdb (lib$gl_tmpfdb);				!Allocate FDB in case
								!old format library
IF .lib$gl_creflags EQL 0					!If /CROSS=NONE
THEN lib$gl_ctlmsk [lib$v_cross] = false;			! then disable it
RETURN true
END;

ROUTINE input1file (requestdesc) =
BEGIN
!++
! This routine is called by CLI when the library filename
! is processed.
!
! Inputs:
!
!	requestdesc	Address of the request descriptor
!
! Outputs:
!
!	An fdb is allocated for the library file and the information is filled
!	in.  If not creating the library, open the file to ensure it exists,
!	and determine the library type expected if an explicit extension was
!	specified.
!
!--

MAP
	requestdesc : REF BBLOCK;

LOCAL
    status,
    openstatus,
    lfab : BBLOCK [fab$c_bln];

allocate_fdb (lib$gl_libfdb);				!Allocate a new FDB for library
CH$MOVE (dsc$c_s_bln, requestdesc [cli$w_rqsize], lib$gl_libfdb [fdb$l_namdesc]);
CH$MOVE (dsc$c_s_bln, def_lib_extn, lib$gl_libfdb [fdb$l_defext]);
IF NOT .lib$gl_ctlmsk [lib$v_create]			!Unless creating the library
THEN BEGIN
    BIND
	filenamedesc = lib$gl_libfdb [fdb$l_namdesc] : BBLOCK,
	namblk = lib$gl_libfdb [fdb$t_nam] : BBLOCK;

    $FAB_INIT (FAB = lfab,
		FNS = .requestdesc [cli$w_rqsize],
		FNA = .requestdesc [cli$a_rqaddr],
		NAM = namblk,
		DNS = .def_lib_extn [dsc$w_length],
		DNA = .def_lib_extn [dsc$a_pointer]);
    IF NOT (openstatus = $OPEN (FAB = lfab))
	AND .openstatus NEQ rms$_flk			!LBR will wait if locked
	THEN BEGIN
	    getfilnamdesc (lfab, filenamedesc);		!Get string descriptor for filename
	    SIGNAL_STOP (lib$_openin, 1, filenamedesc, .openstatus, .lfab [fab$l_stv]);
	    END;
    getfilnamdesc (lfab, filenamedesc);
    IF NOT (IF NOT .openstatus THEN true
		ELSE (status = $CLOSE (FAB = lfab)))
	THEN SIGNAL (lib$_closein, 1, lib$gl_libfdb [fdb$l_namdesc], .status,
			.lfab [fab$l_stv]);
    IF .namblk [nam$v_exp_type]				!If explicit extension given
	AND .namblk [nam$b_rsl] NEQ 0			! and resultant string exists
    THEN BEGIN
!
! Lookup the extension in the table. If its a known extension, change
! the library type to match the extension.
!
	LOCAL
	    ext_start,
	    ext_end;

	IF CH$FAIL(ext_start = CH$FIND_CH (.namblk [nam$b_rsl],	!Find end of directory
				.namblk [nam$l_rsa],
				%ASCII ']'))
	    THEN IF CH$FAIL(ext_start = CH$FIND_CH (.namblk [nam$b_rsl], !Find end of directory
				.namblk [nam$l_rsa],
				%ASCII '>'))
		    THEN ext_start = .namblk[nam$l_rsa];
	ext_start = CH$FIND_CH (.namblk [nam$b_rsl] - (.ext_start - .namblk [nam$l_rsa]),
				.ext_start, %ASCII '.'); !Find start of extension
	ext_end = CH$FIND_CH (.namblk [nam$b_rsl] - (.ext_start - .namblk [nam$l_rsa]),
				.ext_start, %ASCII ';');
	INCRU i FROM 0 TO lbr$c_typ_decmx - 1		!Look at all the extensions
	DO BEGIN
	    BIND
		curdesc = lib_obj_defext + .i*(2 * dsc$c_s_bln) : BBLOCK; !Name descriptor

	    IF CH$EQL (.ext_end - .ext_start, .ext_start,
			.curdesc [dsc$w_length], .curdesc [dsc$a_pointer])
		THEN BEGIN
		    set_lib_type (.i + 1, curdesc);	!Set the library type
		    EXITLOOP;				!and we are done
		    END;
	    END;    
	END;
    END;
RETURN true
END;							!Of INPUT1FILE

ROUTINE input2file (requestdesc) =
BEGIN
!++
! This routine processes the secondary input file specifiers.
!
!
! Inputs:
!
!	requestdesc	Address of the request descriptor
!
! Outputs:
!
!	lib$file_scan is called for the file specifier to parse/search and
!	hence get all files included by the specification.  All files searched
!	successfully will be added to the input list.
!
!--

MAP
    requestdesc : REF BBLOCK;
LOCAL
    lfab : BBLOCK [fab$c_bln],
    lnam : BBLOCK [nam$c_bln],
    lnamesa : BBLOCK [nam$c_maxrss],
    lnamrsa : BBLOCK [nam$c_maxrss],
    status;

!
! Blank out the buffers
!
CH$FILL(0, nam$c_maxrss, lnamesa);
CH$FILL(0, nam$c_maxrss, lnamrsa);

!
! Initialize the FAB and NAM blocks
!
$FAB_INIT (FAB = lfab,
		FNS = .requestdesc [cli$w_rqsize],
		FNA = .requestdesc [cli$a_rqaddr],
		NAM = lnam,
		DNS = .def_fil_extn [dsc$w_length],
		DNA = .def_fil_extn [dsc$a_pointer]);
!
!   If we have already processed an input2 file then use it's NAM block
!   as the related NAM block for the next input2 file so we can have stickiness.
!
IF .relnamblk NEQ 0
THEN
    BEGIN
    lfab [fab$b_dns] = 0;
    lfab [fab$l_dna] = 0;
    END;

$NAM_INIT (NAM = lnam,
		ESS = nam$c_maxrss,
		ESA = lnamesa,
		RSS = nam$c_maxrss,
		RSA = lnamrsa,
		RLF = .relnamblk);
status = lib$file_scan (lfab, filescantruact,		!Find all the files
				filescanflsact);
!
!   lib$file_scan signals any errors, and if no input files are opened, then
!   LIBRARIAN terminates, so no need to retain status.
RETURN true
END;							!Of input2file

ROUTINE filescantruact (fab) =
BEGIN
!++
! This routine is called by lib$file_scan when a successful $search has
! been done.
!
!
! Inputs:
!
!	fab	Address of the fab
!
! Outputs:
!
!	a file descriptor block is allocated and the information is copied
!	into it so the file can be opened later.
!
!--

MAP
    fab : REF BBLOCK;

LOCAL
    saversa,
    namblk : REF BBLOCK,
    newnamdesc : REF BBLOCK,
    newfdb : REF BBLOCK;

BIND
    scaname = .fab [fab$l_nam] : BBLOCK;	!NAM block of winner

allocate_fdb (newfdb);				!Get a new fdb
newnamdesc = newfdb [fdb$l_namdesc];		!Point to filename descriptor
lastfdb [fdb$l_nxtfdb] = .newfdb;		!Link into the list
prevfdb = .lastfdb;
lastfdb = .newfdb;				!Set new last
namblk = newfdb [fdb$t_nam];			!Point to new nam block
saversa = .namblk [nam$l_rsa];			!Save over CH$MOVE
CH$MOVE (nam$c_bln, scaname, .namblk);	!Copy NAM
namblk [nam$l_esa] = namblk [nam$l_rsa] = .saversa; !Set ESA to RSA
namblk [nam$b_rsl] = .scaname [nam$b_rsl];
namblk [nam$b_esl] = .scaname [nam$b_rsl];
getfilnamdesc (.fab, .newnamdesc);		!Get string descriptor for file spec.
CH$MOVE (.namblk [nam$b_rsl], .scaname [nam$l_rsa], .namblk [nam$l_rsa]);
relnamblk = .namblk;				!Save last NAM block for next spec
CH$MOVE (dsc$c_s_bln, modulenamedesc, newfdb [fdb$l_modnam]);
CH$FILL (0, dsc$c_s_bln, modulenamedesc);	!Clear /module descriptor

RETURN true
END;							!Of filescantruact

ROUTINE filescanflsact (fab) =
BEGIN
!++
! This routine is called by lib$file_scan when an unsuccessful $search has
! been done. Ignore it after issuing an error message
!
! Inputs:
!
!	fab	Address of the fab
!
! Outputs:
!
!	an fdb is allocated so the NAM block is avaialable for related NAM
!	block processing, and an error message is issued.
!
!--

MAP
    fab : REF BBLOCK;

LOCAL
    saversa,
    newfdb : REF BBLOCK,
    newnam : REF BBLOCK,
    filedesc : BBLOCK [dsc$c_s_bln];			!String desc. for filename

BIND
    nam = .fab [fab$l_nam] : BBLOCK;			!NAM block for file to report

!
! Get the filename string descriptor set up
!
getfilnamdesc (.fab, filedesc);
SIGNAL (lib$_openin, 1, filedesc, .fab [fab$l_sts], .fab [fab$l_stv]);
!
! Allocate an FDB so that we can use the NAM block for related NAM
! processing
!
allocate_fdb (newfdb);
newnam = newfdb [fdb$t_nam];
saversa = .newnam [nam$l_rsa];				!Save over CH$MOVE
CH$MOVE (nam$c_bln, nam, .newnam);		!Copy the nam
newnam [nam$l_esa] = newnam [nam$l_rsa] = .saversa;
newnam [nam$b_rsl] = .filedesc [dsc$w_length];
newnam [nam$b_esl] = .newnam [nam$b_rsl];
CH$MOVE (.filedesc [dsc$w_length], .filedesc [dsc$a_pointer],
		.newnam [nam$l_rsa]);
relnamblk = .newnam;					!Set new related nam block
filesnotfound = .filesnotfound + 1;

RETURN true
END;							!Of filescanflsact

ROUTINE outputfile (requestdesc) =
BEGIN
!
! This routine processes output files.
!
MAP
	requestdesc : REF BBLOCK;

allocate_fdb (lib$gl_outfdb);				!Allocate FDB for output
CH$MOVE (dsc$c_s_bln, requestdesc [cli$w_rqsize], lib$gl_outfdb [fdb$l_namdesc]);
CH$MOVE (dsc$c_s_bln, def_fil_extn, lib$gl_outfdb [fdb$l_defext]); !set default extension
RETURN true						!That's all
END;
ROUTINE setlistfile (requestdesc, cliaddr) =
BEGIN
!
! This routine is called when the /LIST qualifier is parsed
!
BIND ROUTINE
	recallcli = .cliaddr;			!CLI callback address

allocate_fdb (lib$gl_lisfdb);			!Allocate FDB for list file
if .list_qual [cli$w_qdvalsiz] NEQ 0		!If /LIST=string
THEN BEGIN
    LOCAL
	getasc_desc : BBLOCK [cli$c_reqdesc]; !Allocate a request descriptor

    CH$FILL (0, cli$c_reqdesc, getasc_desc);	!Zero the request descriptor
    getasc_desc [cli$b_rqtype] = cli$k_asciival;	!Want to get ASCII value
    getasc_desc [cli$a_erract] = clierror-getasc_desc; !Set error routine address
    recallcli (getasc_desc, .cliworkptr, .requestdesc); !Request the string
    CH$MOVE (dsc$c_s_bln, getasc_desc [cli$w_rqsize], lib$gl_lisfdb [fdb$l_namdesc]);
    END
ELSE CH$MOVE (dsc$c_s_bln, sysoutputdesc, lib$gl_lisfdb [fdb$l_namdesc]);
RETURN true
END;

ROUTINE setlistwidth (requestdesc, cliaddr) =
BEGIN
!
! set list for /list
!
BIND ROUTINE
    recallcli = .cliaddr;

LOCAL
    getval_desc : BBLOCK [cli$c_reqdesc];

CH$FILL (0, cli$c_reqdesc, getval_desc);
getval_desc [cli$b_rqtype] = cli$k_numerval;
getval_desc [cli$a_erract] = clierror-getval_desc;
recallcli (getval_desc, .cliworkptr, .requestdesc);
lib$gl_listwid = .getval_desc [cli$l_rqvalu];
RETURN true
END;
ROUTINE extractfile (requestdesc, cliaddr) =
BEGIN
!
! This routine is called when the /EXTRACT qualifier is parsed
!
get_name_list (lib$gl_modxtrl, .requestdesc, .cliaddr, $descriptor ('/EXTRACT'));	!Get the list of modules to extract
RETURN true
END;
ROUTINE createlib (requestdesc, cliaddr) =
BEGIN
!
! Called by CLI when the /CREATE qualifier is seen. Scan the create options
!
scan_options (.requestdesc, .cliaddr, create_states, create_keys, lib$al_creopts, lib$gl_cre8flags);
RETURN true
END;
ROUTINE compressfile (requestdesc, cliaddr) =
BEGIN
!
! This routine is called when the /COMPRESS qualifier is parsed
!
scan_options (.requestdesc, .cliaddr, compress_states, compress_keys, lib$al_creopts, lib$gl_cre8flags);
IF .lib$gl_cre8flags [lib$c_opt_keep] THEN lib$gl_ctlmsk [lib$v_keep] = true;
RETURN true
END;
ROUTINE removesymbols (requestdesc, cliaddr) =
BEGIN
!
! This routine is called when the /REMOVE qualifier is parsed
!
get_name_list (lib$gl_objsyrml,.requestdesc,.cliaddr);	!Get the list of symbols to remove
set_lib_type (lib$s_object, lib_obj_defext);		!Set object type
RETURN true
END;
ROUTINE deletemodules (requestdesc, cliaddr) =
BEGIN
!
! This routine is called when the /DELETE qualifier is parsed
!
get_name_list (lib$gl_delmodl,.requestdesc,.cliaddr);	!Get module names to delete
RETURN true
END;
ROUTINE listonlymods (requestdesc, cliaddr) =
BEGIN
!
! This routine is called when the /ONLY qualifier is parsed
!
get_name_list (lib$gl_modlisl, .requestdesc, .cliaddr);
RETURN true
END;

ROUTINE setmodulename (requestdesc, cliaddr) =
BEGIN
!
! This routine processes the /MODULE qualifier.  It is an input-file specific
! qualifier.
!
MAP
    requestdesc : REF BBLOCK;

BIND ROUTINE
    recallcli = .cliaddr;

LOCAL
    getasc_desc : BBLOCK [cli$c_reqdesc];

IF .requestdesc [cli$w_qdvalsiz] EQL 0
THEN SIGNAL_STOP (
	lib$_novalue);
CH$FILL (0, cli$c_reqdesc, getasc_desc);
getasc_desc [cli$b_rqtype] = cli$k_asciival;
getasc_desc [cli$a_erract] = clierror - getasc_desc;
recallcli (getasc_desc, .cliworkptr, .requestdesc);
CH$MOVE (dsc$c_s_bln, getasc_desc [cli$w_rqsize], modulenamedesc);	!Copy descriptor
RETURN true
END;

ROUTINE scan_options (requestdesc, cliaddr, tp_states, tp_keys, resultvector, resultflags) =
BEGIN
!
! This routine recalls CLI to get the options for 
! /CREATE=(BLOCKS=123,GLOBALS=456,MODULES=321,HISTORY=654,VERSION:2) and
! /COMPRESS = (BLO=123, GLOB=456, MOD=321, HIST=654, VERSION:2, KEEP)
!
MAP
    requestdesc : REF BBLOCK,
    resultvector : REF VECTOR,
    resultflags : REF BITVECTOR;

BIND ROUTINE
    recallcli = .cliaddr;

LOCAL
    getasc_desc : BBLOCK [cli$c_reqdesc],
    getval_desc : BBLOCK [cli$c_reqdesc],
    status;

IF .requestdesc [cli$w_qdvalsiz] EQL 0			!If no options specified
THEN RETURN true;
CH$FILL (0, cli$c_reqdesc, getasc_desc);		!Init the descriptor
getasc_desc [cli$b_rqtype] = cli$k_asciival;		!get ascii value
getasc_desc [cli$a_erract] = clierror - getasc_desc;	!error routine
CH$FILL (0, cli$c_reqdesc, getval_desc);		!Init the descriptor
getval_desc [cli$b_rqtype] = cli$k_numerval;		!get numeric value
getval_desc [cli$a_erract] = clierror - getval_desc;	!error routine
!
! Recall CLI for the option name. then recall it again to get the string
! containing the value. convert the decimal value to binary.
!
WHILE .requestdesc [cli$w_qdvalsiz] NEQ 0		!While more to do
DO BEGIN
    recallcli (getasc_desc, .cliworkptr, .requestdesc);	!Get a string
    !
    !   call tparse
    !
    lib$gl_tpindex = 0;
    lib$gl_valreq = 0;
    status = call_tparse (getasc_desc [cli$w_rqsize], .tp_states, .tp_keys);
    IF .lib$gl_valreq
    THEN 
	BEGIN
        IF .requestdesc [cli$w_qdvalsiz] EQL 0
	THEN SIGNAL_STOP ( lib$_novalue, 1, getasc_desc [cli$w_rqsize])
	ELSE 
	    IF NOT recallcli (getval_desc, .cliworkptr, .requestdesc)
	    THEN SIGNAL_STOP (lib$_badkey, 1, getval_desc [cli$w_rqsize]);
	resultvector [.lib$gl_tpindex] = .getval_desc [cli$l_rqvalu];
	lib$gl_cre8flags = .lib$gl_cre8flags OR 1^.lib$gl_tpindex;
	END;
    END;
RETURN .status;
END;					!OF scan_options

ROUTINE call_tparse (str_desc, states, keys )=
BEGIN
MAP 
    str_desc : REF BBLOCK;
LOCAL
    status;

CH$FILL(0,tpa$k_length0,tpa_block);
tpa_block [tpa$l_count] = tpa$k_count0;    
tpa_block [tpa$l_options] = tpa$m_abbrev;
tpa_block [tpa$l_stringcnt] = .str_desc [dsc$w_length];
tpa_block [tpa$l_stringptr] = .str_desc [dsc$a_pointer];
tpa_desc = .str_desc;

status = lib$tparse (tpa_block, .states, .keys);
RETURN .status;
END;					!OF call_tparse

ROUTINE value_req =
BEGIN
lib$gl_valreq = .tpa_block [tpa$l_param];
RETURN true;
END;					! of value_req

ROUTINE syntaxerr =
BEGIN
!
!   This routine is called when TPARSE encounters an error
!
SIGNAL_STOP (.tpa_block [tpa$l_param], 1, .tpa_desc);
RETURN true;
END;

ROUTINE selectcrosref (requestdesc, cliaddr) =
BEGIN
!
! This routine processes the /CROSS qualifier.
!
MAP
    requestdesc : REF BBLOCK;

BIND ROUTINE
    recallcli = .cliaddr;

LOCAL
    optionindex,
    getasc_desc : BBLOCK [cli$c_reqdesc];

BIND
    crefbits = lib$gl_creflags : BITVECTOR;

CH$FILL (0, cli$c_reqdesc, getasc_desc);
getasc_desc [cli$b_rqtype] = cli$k_asciival;
getasc_desc [cli$a_erract] = clierror - getasc_desc;
IF .requestdesc [cli$w_qdvalsiz] EQL 0
THEN BEGIN
    lib$gl_creflags [lib$v_crfbysym] = true;		!/cross only, so give cref by symbol
    lib$gl_creflags [lib$v_crfbyval] = true;		! and cref by value
    RETURN true;
    END
!
! There were some values, so get and check them
!
ELSE WHILE .requestdesc [cli$w_qdvalsiz] NEQ 0
DO BEGIN
    recallcli (getasc_desc, .cliworkptr, .requestdesc);	!Get the string
    IF NOT lookup_keyword (getasc_desc [cli$w_rqsize], crf_bysymbol, !And look it up
				optionindex)
    THEN BEGIN
	IF NOT lookup_keyword (getasc_desc [cli$w_rqsize], all_options, !See if all or none
				optionindex)
	    THEN SIGNAL_STOP (					!and error if none of these
			lib$_badkey,
			1, getasc_desc [cli$w_rqsize])
	    ELSE IF .optionindex EQL 0				!If /CROSS=ALL
		THEN lib$gl_creflags = -1			!then set all flags
		ELSE lib$gl_creflags = 0;
	END
    ELSE crefbits [.optionindex] = true;			!Set the flag bit
    END;
RETURN true
END;							!of selectcrosref

ROUTINE lookup_keyword (desc, namedesctable, keyindex) =
BEGIN
!
! Lookup the string given by desc in the table of descriptors, allowing for
! abbreviations.
!
MAP
    desc : REF BBLOCK,
    namedesctable : REF BBLOCK;

LOCAL
    index;

index = 0;
!
! Loop through the name descriptor table looking for a match.
!
WHILE .namedesctable [.index * dsc$c_s_bln, 0, 16, 0] NEQ 0
DO BEGIN
    BIND
	cdesc = namedesctable [.index * dsc$c_s_bln, 0, 0, 0] : BBLOCK;

    IF CH$EQL (.desc [dsc$w_length], .cdesc [dsc$a_pointer],
			.desc [dsc$w_length], .desc [dsc$a_pointer])
	THEN BEGIN
	    .keyindex = .index;			!Return index
	    RETURN true;
	    END
	ELSE index = .index + 1;
    END;
RETURN false					!Not in table at all
END;					!Of lookup_keyword

ROUTINE get_name_list (list_head, requestdesc, cliaddr, qualifier_dsc) =
BEGIN
!
! This routine recalls CLI to get the names of all the keys associated with
! a qualifier (i.e. /DELETE=module1:module2:...:moduleN).  If there are no
! keys, the image is stopped with an error.
!
! If the keys are there, they are extracted and put on a list.
!
MAP
	list_head : REF VECTOR [2],
	requestdesc : REF BBLOCK;
BIND ROUTINE
	recallcli = .cliaddr;
BUILTIN
	INSQUE,
	NULLPARAMETER;
LOCAL
	getasc_desc : BBLOCK [cli$c_reqdesc];	!Request descriptor for ASCII strings

CH$FILL (0, cli$c_reqdesc, getasc_desc);	!Zero the request descriptor
getasc_desc [cli$b_rqtype] = cli$k_asciival;	!Get ASCII value
getasc_desc [cli$a_erract] = clierror-getasc_desc;
IF .requestdesc [cli$w_qdvalsiz] EQL 0		!If there are no values
THEN 
    BEGIN
    IF NULLPARAMETER (4)
    THEN SIGNAL_STOP (lib$_novalue)
    ELSE SIGNAL_STOP (lib$_novalue,1, .qualifier_dsc);
    END
ELSE WHILE .requestdesc [cli$w_qdvalsiz] NEQ 0	!While there are more values
DO BEGIN
    recallcli (getasc_desc, .cliworkptr, .requestdesc); !Get next value
    IF .getasc_desc [cli$w_rqsize] NEQ 0		!If value is non-null
    THEN BEGIN
	LOCAL
	    status,
	    namblk : REF BBLOCK;
	IF NOT (status = lib_get_mem (lnb$c_fixedsize + .getasc_desc [cli$w_rqsize],
					 namblk))	!Allocate memory
	THEN SIGNAL_STOP (.status);
	INSQUE (.namblk, .list_head [1]);		!Insert in queue
	namblk [lnb$b_namlng] = .getasc_desc [cli$w_rqsize];	!Set size of name
	CH$MOVE (.namblk [lnb$b_namlng], .getasc_desc [cli$a_rqaddr],
			namblk [lnb$t_name]);		!Copy the name
	END;
    END;
RETURN true
END;

ROUTINE clearsqueeze =
BEGIN
!
! Clear the local squeeze bit
!
squeeze_flag = 0;
RETURN true
END;
ROUTINE setsqueeze =
BEGIN
!
! Set local squeeze bit
!
squeeze_flag = 1;
RETURN true
END;

ROUTINE date_parse ( request_desc, cli_addr ) =
!----
!
! Functional description
!
!	This routine parses the value on the /SINCE and /BEFORE
!	qualifiers.  It converts the ASCII value of the qualifier
!	into 64-bit system date format.  The value can be a date
!	string (such as dd-mmm-yyyy hh:mm:ss.s) or the keywords
!	YESTERDAY or TODAY.
!
! Output parameters
!
!	lib$since_date = Date if /SINCE specified.
!	lib$before_date = Date if /BEFORE specified.
!
!----
BEGIN

MAP
    request_desc : REF BBLOCK;	! Define block format

BIND ROUTINE
    recallcli = .cli_addr;

LOCAL
    getasc_desc : BBLOCK [cli$c_reqdesc], ! Request ASCII value
    status;				! Status return value

CH$FILL (0, cli$c_reqdesc, getasc_desc);
getasc_desc [cli$b_rqtype] = cli$k_asciival;
getasc_desc [cli$a_erract] = clierror - getasc_desc;

recallcli (getasc_desc,		! Get value of descriptor
	 .cliworkptr,
	 .request_desc);		! using same request block

!
!	Convert the ASCII string into 64-bit system time format.
!

status = lib$cvt_time(getasc_desc[cli$q_rqdesc],
	IF .request_desc [cli$b_qdcode] EQL cli$k_libr_sinc
	THEN
	    lib$since_date		! Store here if /SINCE
	ELSE
	    lib$before_date);		! Else here if /BEFORE

IF NOT .status				! If error in conversion,
THEN
    SIGNAL_STOP(.status);		! then output error message

RETURN true;
END;

ROUTINE allocate_fdb (fdbadr) =
BEGIN
!
! This routine allocates a file descriptor block and initializes it.
!
LOCAL
	status;

IF NOT (status = lib_get_mem (fdbsize, .fdbadr)) 	!Allocate the FDB
THEN SIGNAL_STOP (.status);
initialize_fdb (..fdbadr);				!and initialize it
RETURN true
END;
ROUTINE initialize_fdb (fdbadr) =
BEGIN
!
! This routine initializes a pre-allocated FDB
!
MAP
    fdbadr : REF BBLOCK;
LOCAL
	namblk : REF BBLOCK,				!Pointer to NAM block
	rsblk  : REF BBLOCK;				!Pointer to resultant name string area
namblk = fdbadr [fdb$t_nam];				!Point to NAM block part
rsblk = .namblk + nam$c_bln;				!Point to resultant string area
CH$FILL (0, fdbsize, .fdbadr);				!Zero the FDB
namblk [nam$l_rsa] = .rsblk;				!Store RSA address
namblk [nam$b_rss] = nam$c_maxrss;			!And its length
namblk [nam$l_esa] = .rsblk+nam$c_maxrss;		!Expanded name string goes
namblk [nam$b_ess] = nam$c_maxrss;			! in same place so errors
							! messages are correct.
namblk [nam$b_bid] = nam$c_bid;				!Identify it as a NAM
namblk [nam$b_bln] = nam$c_bln;				!...
RETURN true
END;

ROUTINE set_lib_type (type, defext) =
BEGIN
!
! This routine sets the default library type and default extension
!
MAP
    defext : REF VECTOR [4];
lib$gl_type = .type;			!Set library type
CH$MOVE (dsc$c_s_bln, defext [0], def_lib_extn);
CH$MOVE (dsc$c_s_bln, defext [2], def_fil_extn);
RETURN true
END;
ROUTINE set_text_type (requestdesc) =
!
! This routine is called when the /text qualifier is processed.
!
RETURN set_lib_type (lib$s_text, lib_txt_defext);
ROUTINE set_help_type (requestdesc) =
!
! This routine is called when the /HELP qualifier is processed.
!
RETURN set_lib_type (lib$s_help, lib_hlp_defext);
ROUTINE set_macro_type (requestdesc) =
!
! This routine is called when the /MACRO qualifier is processed.
!
RETURN set_lib_type (lib$s_macro, lib_mac_defext);
ROUTINE set_object_type (requestdesc) =
!
! This routine is called when the /OBJECT qualifier is processed.
!
RETURN set_lib_type (lib$s_object, lib_obj_defext);
ROUTINE set_shr_type (requestdesc) =
!
! This routine is called when the /SHARE qualifier is processed.
!
RETURN set_lib_type (lib$s_shrstb, lib_shr_defext);


ROUTINE clierror (requestdesc,errorcode) =
BEGIN
!
!	This routine is called by the result parser if it detects any
!	error in the command.  REQUESTDESC is the address of the current
!	parameter descriptor and ERRORCODE is the encoded reason for
!	the error.
!
MAP
	requestdesc : REF BBLOCK;			!Pointer to a block

SIGNAL_STOP (.errorcode);				!Print error message and quit
RETURN true
END;
END					! Of module
ELUDOM
