MODULE lbr_gethelp (			! Routine to extract help from library
		LANGUAGE (BLISS32),
		IDENT = 'V03-006'
		) =
BEGIN
%TITLE	'Extract help text from library';
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:  Library access procedures
!
! ABSTRACT:
!
!	The VAX/VMS librarian procedures implement a standard access method
!	to libraries through a shared, common procedure set.
!
! ENVIRONMENT:
!
!	VAX native, user mode.
!
!--
!
!
! AUTHOR:  Benn Schreiber,	 CREATION DATE:  17-Sep-1979
!
! MODIFIED BY:
!
!	V03-006		RPG0006		Bob Grosso	14-Apr-1982
!		When searching for help on TOPIC SUBTOPIC where keyword
!		TOPIC does not have a subtopic, an invalid rfa error
!		is returned to HELP.  Check to avoid storing a zero rfa.
!
!	V03-005		RPG0005		Bob Grosso	09-Apr-1982
!		Print all the keywords when help not found so that
!		it works properly for wildcarding and doesn't accvio
!		for some utilities when non-wildcarding is used.
!
!	V03-004		RPG0004		Bob Grosso	05-Apr-1982
!		Check the size of the keywords in MOVE_KEY and split
!		the keyword if it is larger than the buffer.
!
!	V03-023		RPG0003		Bob Grosso	31-Mar-1982
!		Fix problem where gethelp won't print a blank line
!		preceding a line of 33 characters.
!
!	V02-031		RPG0031		Bob Grosso	29-Mar-1982
!		Check status for INVKEY so that a key too long won't
!		hang.
!
!	V02-021		RPG0021		Bob Grosso	05-Mar-1982
!		Re-correct the number of keys printed in print_nohelp
!		so that the keyword for which help is not found is 
!		printed.
!		And, "that wasn't all folks"; stuff saverfa into
!		key2rfa so help won't hang on just '/' for subtopic.
!
!	V02-020		PCG0005		Peter George	07-Jan-1982
!		Inspect CONTEXT [CTX$V_OUTPUTHLP] flag and behave 
!		appropriately.
!
!	V02-019		RPG0019		Bob Grosso	6-Oct-1981
!		Correct two bugs.  Wildcard match no longer upcases
!		library cache, unmatched wildcard will no longer loop.
!
!	V02-018		RPG0018		Bob Grosso	08-Sep-1981
!		YAB in lower case keyword support
!
!	V02-017		RPG0017		Bob Grosso	04-Sep-1981
!		More work on lower case support
!
!	V02-016		RPG0016		Bob Grosso	31-Aug-1981
!		Lower case keyword support
!
!	V02-015	PCG0004		Peter George		04-Jun-1981
!		Allow use of blank key to terminate list of keys.
!		Do not special case user-supplied 'HELP' key.
!
!	V02-014	PCG0003		Peter George		19-May-1981
!		Allow search for subtopics for 'HELP'.
!
!	V02-013	PCG0002		Peter George		08-May-1981
!		Move literal definitions into LBR.MDL.
!
!	V02-012	PCG0001		Peter George		13-Apr-1981
!		Correct deallocation of memory so that help_help key 
!		(which is allocated from the stack) is not deallocated.
!
!	V02-011		Benn Schreiber		28-May-1980
!		Correct number of keys printed in print_nohelp.
!--



%SBTTL	'Declarations';
LIBRARY
    'SYS$LIBRARY:STARLET';
REQUIRE
    'PREFIX';
REQUIRE
    'LBRDEF';

LINKAGE
    fmg_match = JSB (REGISTER=2, REGISTER=3,
			REGISTER=4, REGISTER=5) : NOTUSED (10, 11); !Linkage for fmg$match_name

EXTERNAL ROUTINE
    traverse_keys,				!Traverse index
    lookup_key,					!Lookup key in index
    validate_ctl : JSB_1,			!Validate control index
    get_mem : JSB_2,				!allocate memory
    dealloc_mem : JSB_2,
    read_record : JSB_2,			!Read a text record from library
    lib$cvt_dtb    : ADDRESSING_MODE(GENERAL),	!Convert decimal to binary
    lib$put_output : ADDRESSING_MODE(GENERAL),	!Write line to SYS$OUTPUT
    fmg$match_name : fmg_match;			!Match name with wild chars.

EXTERNAL
    lbr$gl_control : REF BBLOCK;		!Pointer to current library control block

EXTERNAL LITERAL
    lbr$_invkey,
    lbr$_invnam,
    lbr$_normal,
    lbr$_nothlplib;

FORWARD ROUTINE
    move_key,					!Copy key name to buffer
    call_output,				!Send line to user routine or lib$put_output
    print_blankline,				!Print a blank line
    print_nohelp,				!Tell that no help was found as specified
    print_options,				!Print help available under current topic
    print_helptext,				!Print help text found in library
    print_line,					!print line
    print_keys,					!Print keys found
    is_key_on_line,				!Check for key line
    skip_blanks,				!Skip blanks on line
    scan_word,					!Scan off a word
    make_upper_case,				!Upcase a name
    help_check_mtch,				!Check entries for matches if wild cards
    help_check_prtl,				!Check entries for partial matches
    help_do_key1;				!Process a key1

PSECT OWN = $CODE$;				!Put own data in code psect since its shareable

OWN
    nodocmsg : countedstring ('Sorry, no documentation on '),
    otherinfo : countedstring ('Additional information available:');

%SBTTL	'Routine get_help';
ROUTINE get_help (helpdata) =
BEGIN

!++
!	This routine does the actual looking up of the first level key for lbr$get_help
!
! Inputs:
!
!	helpdata	address of help data vector set up by lbr$get_help
!
! Outputs:
!
!	The help request is processed.
!
!--

MAP
    helpdata : REF VECTOR [,LONG];

LOCAL
    pmatch,
     key1rfa : BBLOCK [rfa$c_length];

BIND
    helpinfo = .helpdata [hlp$k_info] : BBLOCK,		!Help info
    wildflag = helpinfo [hlp$t_wildflags] : BITVECTOR,	!Bit flag true if key is wild
    key1desc = .helpdata [hlp$k_key1desc] : BBLOCK;	!Key 1 descriptor

pmatch = false;
!
! See if any wild characters present in key name
!
IF NOT CH$FAIL (CH$FIND_CH (.key1desc [dsc$w_length], .key1desc [dsc$a_pointer], %ASCII '*'))
    OR NOT CH$FAIL (CH$FIND_CH (.key1desc [dsc$w_length], .key1desc [dsc$a_pointer], %ASCII '%'))

	THEN BEGIN
	    wildflag [0] = true;
	    perform (traverse_keys (1, help_check_mtch, 0, .helpdata))
	    END

	ELSE
	    BEGIN
	    LOCAL
		status;
	    status = lookup_key (1, key1desc, key1rfa);			!If key is in library
	    IF (.status EQL lbr$_invkey) THEN return .status;
	    IF .status
	    THEN
		perform (help_do_key1 (key1desc, key1rfa, .helpdata))	! then process it
	    ELSE
		BEGIN
		wildflag [0] = true;					!Partial match counts as wild.
		pmatch = true;
		perform (traverse_keys (1, help_check_prtl, 0, .helpdata)); ! otherwise see if partial matches
		wildflag [0] = false;
		END;
	    END;
!
! Check to make sure we found some help text
!

IF NOT .helpinfo [hlp$v_anyhelp]
    THEN BEGIN
	IF .pmatch
	THEN BEGIN
	    IF .helpinfo [hlp$l_pmatch] EQL 1			!If there was exactly 1 partial match
	    THEN BEGIN
		wildflag [0] = false;
		help_do_key1 (helpinfo [hlp$b_pmtdesc],		!Find the spot to print options from
				helpinfo [hlp$b_pmtrfa], .helpdata);
		END
	    ELSE helpinfo [hlp$l_lastlevel] = 0;
	    END

	ELSE  
	    IF ( .helpinfo [hlp$l_lastlevel] GTR 0 )		!Back up to last found key
	    THEN helpinfo [hlp$l_lastlevel] = .helpinfo [hlp$l_lastlevel] - 1;

	IF NOT .helpinfo [hlp$v_anyhelp]		!If help still not printed
	    THEN perform (print_nohelp (.helpdata));	!Print no help info
	END;

RETURN true

END;					! Of get_help

%SBTTL	'Routine lbr$get_help';
GLOBAL ROUTINE lbr$get_help (control_index, line_width, user_routine, user_data, key1desc) =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine extracts help text from a help library, optionally
!	indents the output, and then prints the line or calls a supplied
!	routine with a string descriptor.
!
!
! CALLING SEQUENCE:
!
!	status = LBR$GET_HELP (control_index, [line_width, user_routine,
!				user_data], key1desc [,key2desc, ...])
!
! INPUT PARAMETERS:
!
!	control_index	is the control_index obtained from LBR$INI_CONTROL
!	line_width	is address of longword containing linewidth. (D=80)
!	user_routine	address of user typeout routine
!	user_data	address of user data to pass to user typeout routine
!	key1desc,...	addresses of string descriptors for keys
!
!
! IMPLICIT INPUTS:
!
!	The HELP library must be open.
!
! OUTPUT PARAMETERS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	If no user_routine is specified, the help text is printed on SYS$OUTPUT
!	using LIB$PUT_OUTPUT.  If there is a user_routine, it is called for
!	each line of help text found or generated.
!
! ROUTINE VALUE:
!
!	status	lbr$_normal
!		lbr$_nothlplib	Not help library
!		lbr$_invnam	Too many arguments
!
! SIDE EFFECTS:
!	NONE
!
!--

MAP
    key1desc : REF BBLOCK;

LOCAL    
    helpdata : BBLOCK [lbr$c_pagesize],				!A place to copy arg list into
    foundkeys : BBLOCK [hlp$c_maxkeys * dsc$c_s_bln], 		!string descriptors for found keys
    keydescriptors : BBLOCK [hlp$c_maxkeys * dsc$c_s_bln],	!String descriptors for keys uppercased
    ptr,				!Temp pointer
    curkeydesc : REF BBLOCK,
    status,
    helpinfo : BBLOCK [hlp$c_size + hlp$c_maxliswid],
    desc : BBLOCK [dsc$c_s_bln],
    help_help,
    dots;				!A string of dots

BUILTIN
    ACTUALCOUNT,
    NULLPARAMETER;

perform (validate_ctl (..control_index));	!Validate control index
BEGIN
    BIND
	helpvector = helpdata : VECTOR [,LONG],
	wildflag = helpinfo [hlp$t_wildflags] : BITVECTOR,	!Bit flags
	mykey1desc = keydescriptors : BBLOCK,			!Key 1 descriptor to be filled in
	context = .lbr$gl_control [lbr$l_ctxptr] : BBLOCK,	!Context block
	header  = .lbr$gl_control [lbr$l_hdrptr] : BBLOCK;	!Library header
!
! Check that library is indeed a help library and that there were
! not too many arguments supplied.
!
    IF .header [lhd$b_type] NEQ lbr$c_typ_hlp		!If library is not help library
	THEN RETURN lbr$_nothlplib;

    IF ACTUALCOUNT() GTR hlp$c_maxkeys + 4		!If too many args
	THEN RETURN lbr$_invnam;			! then return error
!
! Set up the data list that is passed to all the lower level routines.
!
    CH$MOVE( ((ACTUALCOUNT () + 1) * 4), control_index - 4, helpdata); !Copy argument list
    CH$FILL (0, hlp$c_maxkeys * dsc$c_s_bln, keydescriptors);
    help_help = %ASCII 'HELP';				!Set up string of 'HELP'
!
! Zero helpinfo
!
    helpvector [hlp$k_info] = helpinfo;			!Point to the info buffer
    CH$FILL (0, hlp$c_size, helpinfo);			!Zero control information
!
! If no KEY1 was specified, or it was null, use "HELP", otherwise, convert keyname
! given to upper case.
!
    IF NULLPARAMETER (hlp$k_key1desc)			!If its not present
	OR .key1desc [dsc$w_length] EQL 0		! or present and null
	OR .key1desc [dsc$a_pointer] EQL 0
    THEN BEGIN
	helpinfo [hlp$v_helphlp] = true;		!Indicate inserting help key
	mykey1desc [dsc$w_length] = 4;
	mykey1desc [dsc$a_pointer] = help_help;
	END
    ELSE BEGIN
	helpinfo [hlp$v_helphlp] = false;			!Indicate not inserting help key
	perform (get_mem (.key1desc [dsc$w_length],		!Allocate storage for key name
			mykey1desc [dsc$a_pointer]));
	make_upper_case (.key1desc, mykey1desc); 		!Convert to upper case
	END;

    helpvector [hlp$k_key1desc] = mykey1desc;		!Change arg list
    CH$FILL (0, 8, helpinfo [hlp$t_wildflags]);		!Zero wild key flags
    IF NOT NULLPARAMETER (hlp$k_linewidth)
	THEN helpinfo [hlp$l_width] = MIN (..line_width, hlp$c_maxliswid)
	ELSE helpinfo [hlp$l_width] = hlp$c_liswidth;	!Use default if none supplied
    helpinfo [hlp$l_curptr] = helpinfo + hlp$c_size;
    helpinfo [hlp$l_bufdesc] + 4 = .helpinfo [hlp$l_curptr];
    helpinfo [hlp$l_bufdesc] = .helpinfo [hlp$l_width];
    CH$FILL (0, hlp$c_maxkeys * dsc$c_s_bln, foundkeys); !Zero descriptor array
    helpinfo [hlp$l_keylist] = foundkeys;		!Set pointer for lower routines

!
! See if key1 string contains '...' . If so, flag it and modify the string
! descriptor to delete it.
!
    dots = %ASCII'....';
    ptr = CH$FIND_SUB (.mykey1desc [dsc$w_length], .mykey1desc [dsc$a_pointer],
	3, dots);
    IF NOT CH$FAIL (.ptr)
	AND (.ptr EQL (.mykey1desc [dsc$a_pointer] + .mykey1desc[ dsc$w_length] - 3))
    THEN BEGIN
	helpinfo [hlp$v_allhelp] = true;			!Flag ... seen
	BEGIN
	    BIND
		wildbits = helpinfo [hlp$t_wildflags] : VECTOR [,LONG];

	    wildbits [0] = %X 'FFFFFFFE';			!Set all lower keys as wild
	    wildbits [1] = -1;
	    END;

	mykey1desc [dsc$w_length] = .mykey1desc [dsc$w_length] - 3; ! and adjust key length
	END;
!
! Look at the key descriptors to make sure that no extra, null key descriptors
! were passed.
!
helpinfo [hlp$l_realkeys] = ACTUALCOUNT () - 4;		!Initially, this is # of keys

IF .helpinfo [hlp$v_allhelp]				!If printing all help
    OR .helpinfo [hlp$v_helphlp]			! or have inserted 'HELP' key
    THEN helpinfo [hlp$l_realkeys] = 1;			! then only look at first key

IF .helpinfo [hlp$l_realkeys] GEQ 2			!If 2 or more keys
THEN INCRU i FROM 2 TO .helpinfo [hlp$l_realkeys]	! then look at key2-keyN
DO BEGIN
    BIND
	keydesc = keydescriptors + dsc$c_s_bln*.i : BBLOCK;

    curkeydesc = .helpvector [.i+hlp$k_key1desc-1];	!Point to next descriptor

    IF .curkeydesc EQL 0				!If 0 descriptor
	OR .curkeydesc [dsc$w_length] EQL 0		! or 0 length
	OR .curkeydesc [dsc$a_pointer] EQL 0		! or 0 pointer
	OR CH$FAIL (CH$FIND_NOT_CH 			! or all blanks
	    (.curkeydesc [dsc$w_length], .curkeydesc [dsc$a_pointer], %C' '))
	THEN BEGIN
	    helpinfo [hlp$l_realkeys] = .i - 1;		! Set real number of keys
	    EXITLOOP;
	    END
	ELSE BEGIN
	    IF NOT CH$FAIL (CH$FIND_CH (.curkeydesc [dsc$w_length], !Determine if key has wild chars in it
			.curkeydesc [dsc$a_pointer], %ASCII '*'))
		OR NOT CH$FAIL (CH$FIND_CH (.curkeydesc [dsc$w_length],
			.curkeydesc [dsc$a_pointer], %ASCII '%'))
		THEN wildflag [.i-1] = true;
	    perform (get_mem (.curkeydesc [dsc$w_length],	!Allocate memory to hold string
			keydesc [dsc$a_pointer]));
	    make_upper_case (.curkeydesc, keydesc); 		!Convert to upper case
	    helpvector [.i+hlp$k_key1desc-1] = keydesc;		!Correct pointer to descriptor in help vector
	    END;
    END;
!
! Get the help 
!
    status = get_help (helpdata);				!do the help thing
!
! Deallocate any key strings that were allocated
!
    IF NOT .helpinfo [hlp$v_helphlp] THEN			!If keys were present
    INCRU i FROM 0 TO hlp$c_maxkeys-1
    DO BEGIN
	BIND
	    keydesc = keydescriptors + dsc$c_s_bln*.i : BBLOCK,
	    curdesc = foundkeys + dsc$c_s_bln*.i : BBLOCK;

	IF .curdesc [dsc$w_length] NEQ 0
	    THEN IF .curdesc [dsc$a_pointer] NEQ 0
		THEN dealloc_mem (.curdesc [dsc$w_length],
				.curdesc [dsc$a_pointer]);
	IF .keydesc [dsc$w_length] NEQ 0
	    THEN IF .keydesc [dsc$a_pointer] NEQ 0
		THEN dealloc_mem (.keydesc [dsc$w_length],
				.keydesc [dsc$a_pointer]);
	END;
    END;
RETURN .status
END;

%SBTTL	'Routine help_check_mtch';
ROUTINE help_check_mtch (entry, user_routine, index_desc, helpdata) =
BEGIN
!++
!
! This routine is called for every entry in the library to see if
! the entry matches the wild card key descriptor passed to LBR$GET_HELP.
!
! INPUTS:
!
!	entry		Address of entry descriptor in index
!	user_routine	Not used
!	index_desc	Not used
!	helpdata	Address of data vector created by lbr$get_help
!
! If the current entry matches the key1 in the help data vector, call
! help_do_key1 to process it.
!
!--

MAP
    entry : REF BBLOCK,
    helpdata : REF VECTOR [,LONG],
    index_desc : REF BBLOCK;

BIND
    helpinfo = .helpdata [hlp$k_info] : BBLOCK,		!Pointer to information structure
    key1desc = helpdata [hlp$k_key1desc] : REF BBLOCK;	!Start of key descriptor addresses

LOCAL
    match_desc : BBLOCK [dsc$c_s_bln],
    match_buf : BBLOCK [lbr$c_maxkeylen],
    entrydesc : BBLOCK [dsc$c_s_bln];

!
! Check for wild card match with fmg$match_name
!
entrydesc [dsc$w_length] = .entry [idx$b_keylen];
entrydesc [dsc$a_pointer] = entry [idx$t_keyname];

match_desc [dsc$w_length] = 0;
match_desc [dsc$a_pointer] = match_buf;

make_upper_case ( entrydesc, match_desc );

IF fmg$match_name (.match_desc [dsc$w_length], .match_desc [dsc$a_pointer],
			.key1desc [dsc$w_length], .key1desc [dsc$a_pointer])
THEN perform (help_do_key1 (entrydesc, entry [idx$b_rfa], .helpdata));
RETURN true
END;					! Of help_check_mtch

%SBTTL	'Routine help_check_prtl';
ROUTINE help_check_prtl (entry, user_routine, index_desc, helpdata) =
BEGIN
!++
!
! This routine is called for every entry in the index to determine if the
! entry satisfies a partial match.
!
! INPUTS:
!
!	entry		address of current entry in the index
!	user_routine	not used
!	index_desc	not used
!	helpdata	address of help data vector set up by lbr$get_help
!
! The entry is checked for a partial match and help_do_key1 is called
! if there is a match
!
!--

MAP
    entry : REF BBLOCK,
    helpdata : REF VECTOR [,LONG];

BIND
    helpinfo = .helpdata [hlp$k_info] : BBLOCK,		!Pointer to information structure
    key1desc = helpdata [hlp$k_key1desc] : REF BBLOCK;	!Start of key descriptor addresses

LOCAL
    entrybuf : BBLOCK [lbr$c_maxkeylen],
    entrydesc : BBLOCK [dsc$c_s_bln];

entrydesc [dsc$w_length] = .entry [idx$b_keylen];
entrydesc [dsc$a_pointer] = entrybuf;			! Temporary store to raise case
CH$MOVE (.entry [idx$b_keylen], entry [idx$t_keyname], entrybuf);
make_upper_case (entrydesc, entrydesc);

IF CH$EQL (.key1desc [dsc$w_length], entrybuf,		!See if it is a partial match
		.key1desc [dsc$w_length], .key1desc [dsc$a_pointer])
THEN
    BEGIN
    entrydesc [dsc$a_pointer] = entry [idx$t_keyname];
    IF (helpinfo [hlp$l_pmatch] = .helpinfo [hlp$l_pmatch] + 1) EQL 1	!If this is first partial match
	THEN BEGIN
	    CH$MOVE (dsc$c_s_bln, entrydesc, helpinfo [hlp$b_pmtdesc]);! then remember descriptor for it
	    CH$MOVE (rfa$c_length, entry [idx$b_rfa], helpinfo [hlp$b_pmtrfa]);
	    END;
    perform (help_do_key1 (entrydesc, entry [idx$b_rfa], .helpdata));
    END;

RETURN true
END;					! Of help_check_partl

%SBTTL	'Routine move_key';
ROUTINE move_key (helpdata, keydesc, spaces) =
BEGIN
!++
!
! Copy the key into the buffer
!
! Inputs:
!
!	helpdata	address of help data vector set up by lbr$get_help
!	keydesc		address of string descriptor for key
!	spaces		number of spaces to leave after key
!
! Outputs:
!
!	Key is copied into buffer.  New line issued if not enough room.
!
!--

MAP
    helpdata : REF VECTOR [,LONG],
    keydesc : REF BBLOCK;

LOCAL
    newlen;

BIND
    helpinfo  = .helpdata [hlp$k_info] : BBLOCK;

newlen = .helpinfo [hlp$l_nchars] + .keydesc [dsc$w_length] + .spaces;
IF .newlen GTRU .helpinfo [hlp$l_width]
THEN
    BEGIN
    IF .keydesc [dsc$w_length] GTRU .helpinfo [hlp$l_width]
    THEN
	BEGIN
	!
	!   The key is too large to fit on a line by itself so wrap it
	!   by printing as much as will fit in current buffer, and print
	!   rest on the following line.
	!
	LOCAL
	    excessdesc : BBLOCK [dsc$c_s_bln],
	    leftover_len;

	leftover_len = .helpinfo [hlp$l_width] - .helpinfo [hlp$l_nchars] - 2;
	excessdesc [dsc$w_length] = .keydesc [dsc$w_length] - .leftover_len;
	excessdesc [dsc$a_pointer] = .keydesc [dsc$a_pointer] + .leftover_len;
	helpinfo [hlp$l_curptr] = CH$MOVE (.leftover_len, .keydesc [dsc$a_pointer],
				.helpinfo [hlp$l_curptr]);
	helpinfo [hlp$l_nchars] = .helpinfo [hlp$l_width];
	perform (print_line (.helpdata));
	move_key (.helpdata, excessdesc, .spaces);
	END
    ELSE
	BEGIN
	perform (print_line (.helpdata));		! Print what we got
	move_key (.helpdata, .keydesc, .spaces);	! print what didn't fit on it's own line
	END;
    END
ELSE
    BEGIN
    helpinfo [hlp$l_nchars] = .newlen;
    helpinfo [hlp$l_curptr] = CH$MOVE (.keydesc [dsc$w_length], .keydesc [dsc$a_pointer],
				.helpinfo [hlp$l_curptr]) + .spaces;
    END;
RETURN true
END;					! Of move_key

%SBTTL	'Routine help_do_key1';
ROUTINE help_do_key1 (entrydesc, entryrfa, helpdata) =
BEGIN
!++
! This routine fully processes help text given the key1 has been looked
! up successfully.
!
! Inputs:
!
!	entrydesc	Address of string descriptor for key1
!	entryrfa	Address of rfa for key1
!	helpdata	Address of help data vector set up by lbr$get_help
!
! Outputs:
!
!	Help information (if any, is output)
!
!--

ROUTINE copy_key (helpdata, desc) =
BEGIN
!++
! This routine allocates dynamic memory, copies the key name into it,
! and fills in the appropriate descriptor in the array of descriptors
! pointed to by helpinfo [hlp$l_keylist].
!
! Inputs:
!
!	helpdata	Address of help data vector set up by lbr$get_help
!	desc		Address of string descriptor for key
!
! Outputs:
!
!	memory is allocated and correct descriptor is filled in.
!
!--


MAP
    helpdata : REF VECTOR [,LONG],
    desc : REF BBLOCK;

BIND
    helpinfo = .helpdata [hlp$k_info] : BBLOCK,
    keydesc = .helpinfo [hlp$l_keylist]
		+ (.helpinfo [hlp$l_curlevel] - 1) * dsc$c_s_bln : BBLOCK;

LOCAL
    ptr,
    nchars;

nchars = 0;
IF .helpdata [hlp$k_userout] EQL 0
    THEN nchars = .helpinfo [hlp$l_curlevel] * hlp$c_keylogtab;

IF .keydesc [dsc$a_pointer] NEQ 0
    THEN dealloc_mem (.keydesc [dsc$w_length],			!Deallocate old string
			.keydesc [dsc$a_pointer]);
perform (get_mem (.desc [dsc$w_length] + .nchars, ptr));	!Allocate memory for string
keydesc [dsc$w_length] = .desc [dsc$w_length] + .nchars;
keydesc [dsc$a_pointer] = .ptr;
IF .nchars NEQ 0						!Pad with spaces if needed
    THEN ptr = CH$FILL (%ASCII ' ', .nchars, .ptr);
CH$MOVE (.desc [dsc$w_length], .desc [dsc$a_pointer], .ptr);	!Copy string in
RETURN true
END;					!Of copy_key

%SBTTL	'Routine find_help_key';
ROUTINE find_help_key (helpdata, helplevel) =
BEGIN
!++
! This recursive routine does all the work of finding and printing help text.
!
! Inputs:
!
!	helpdata	Address of help data vector set up by lbr$get_help
!
!--

MAP
    helpdata : REF VECTOR [,LONG];

BIND
    helpinfo = .helpdata [hlp$k_info] : BBLOCK,
    key2rfa = helpinfo [hlp$b_key2rfa],
    wildflag = helpinfo [hlp$t_wildflags] : BITVECTOR;

LOCAL
    curkeydesc : REF BBLOCK,
    saverfa : BBLOCK [rfa$c_length],
    level,
    curchar,
    helpkey,
    qualseen,
    is_key,
    ch_result,
    keylength,
    wild_path,
    savelastrfa : BBLOCK [rfa$c_length],
    lastqualrfa : BBLOCK [rfa$c_length],
    token2desc : BBLOCK [dsc$c_s_bln],
    tokendesc : BBLOCK [dsc$c_s_bln],
    recdesc : BBLOCK [dsc$c_s_bln],
    keystring : BBLOCK [hlp$c_maxrecsiz];


IF NOT .helpinfo [hlp$l_readsts] 			!If already at end of file
    THEN RETURN true;

!
! Read records until end of module or exit by finishing
!

qualseen = false;
level = .helplevel;				!Preset level
helpinfo [hlp$l_lastlevel] = .helplevel;	!Set last level looked at
CH$MOVE (rfa$c_length, helpinfo [hlp$b_lstkeyrfa], !Save last key rfa
			savelastrfa);
token2desc [dsc$a_pointer] = keystring;		!preset address part of descriptor

WHILE (
	CH$MOVE (rfa$c_length, helpinfo [hlp$b_readrfa], saverfa);
	(helpinfo [hlp$l_readsts] = read_record (helpinfo [hlp$b_readrfa], recdesc))
	)
    DO BEGIN

	curchar = 0;				!Preset character
	curkeydesc = .helpdata [.helplevel - 1 + hlp$k_key1desc];
	IF .helplevel GTR .helpinfo [hlp$l_realkeys] 		!If key not really present
	    THEN curkeydesc = 0;
	IF .curkeydesc NEQ 0
	THEN BEGIN
	    curchar = CH$RCHAR (.curkeydesc [dsc$a_pointer]); 	!Get 1st char of key
	    IF .curchar EQL %ASCII '/'				! and if its a slash (qualifier)
	    THEN
		IF .curkeydesc [dsc$w_length] EQL 1		!  and if only one char in name (slash)
		THEN
		    BEGIN
		    IF .key2rfa EQL 0					! and its the first key this module
		    THEN CH$MOVE (rfa$c_length, saverfa, key2rfa);	! then save it away for printing options
		    EXITLOOP;						!   then that's all folks
		    END
		ELSE helpinfo [hlp$v_qualhelp] = true;			!   otherwise flag qualifier help
	    END;

	IF (is_key = is_key_on_line  (helpinfo, recdesc, level, tokendesc)) !If line has a key on it
	    AND .helpinfo [hlp$v_qualhelp]			! and its qualifier help
	    AND .helpinfo [hlp$v_qualine]			! and we found a qualifier line
	    AND NOT .qualseen					! and we haven't seen a qualifier lately
	    THEN BEGIN
		CH$MOVE (rfa$c_length, saverfa, lastqualrfa);	!Save RFA of last qualifier
		qualseen = true;				! and flag we have seen a qualifier
		END;

	IF .is_key
	    AND .curkeydesc NEQ 0
	    THEN BEGIN
		keylength = .curkeydesc [dsc$w_length];		!Set length of key
		IF ((.keylength GTR .tokendesc [dsc$w_length])	! but if key greater than key in text
		    AND NOT .wildflag [.helplevel - 1])		! and this key is not wild
		    THEN keylength = 0;				! then no match
		END
	    ELSE keylength = 0;

	IF .is_key						!If key found on line
	    AND  .key2rfa EQL 0					! and its the first key this module
	    THEN CH$MOVE (rfa$c_length, saverfa, key2rfa);	! then save it away for printing options
	ch_result = 1;						!Preset for no match
	IF .helpinfo [hlp$v_keyline]				!If we found it on a key line
	    THEN helpinfo [hlp$v_qualhelp] = false;		! then make sure we treat as one
	IF .is_key						!If there is a key on the line
	    AND (.helpinfo [hlp$v_allhelp]			! and we're doing all help
	    OR (.level EQL .helplevel				! and its the right level
	    AND make_upper_case (tokendesc, token2desc)		! (make it upper case)
	    AND ((((IF .keylength EQL 0
			THEN false
			ELSE (ch_result = CH$COMPARE (.keylength, keystring,
					.keylength, .curkeydesc [dsc$a_pointer])) EQL 0))
	    OR (IF (.curchar EQL %ASCII '*'
		    AND .helpinfo [hlp$v_qualine])
		    OR .keylength EQL 0
		    THEN false
		    ELSE fmg$match_name (.token2desc [dsc$w_length], keystring,
			.keylength, .curkeydesc [dsc$a_pointer]))))))
!
! We have a winner, process it
!
	THEN BEGIN
	    recdesc [dsc$w_length] = .recdesc [dsc$w_length] -	!Adjust descriptor
					(.tokendesc [dsc$a_pointer] - !in case
					.recdesc [dsc$a_pointer]); !we copy_key it
	    recdesc [dsc$a_pointer] = .tokendesc [dsc$a_pointer];
	    IF .ch_result EQL 0					!If we got here due to a match
		THEN ch_result = CH$COMPARE (.token2desc [dsc$w_length], keystring, !then check for real match
					.keylength, .curkeydesc [dsc$a_pointer]);
	    CH$MOVE (rfa$c_length, helpinfo [hlp$b_readrfa],	!Save RFA of last found key
				helpinfo [hlp$b_lstkeyrfa]);
	    IF NOT .helpinfo [hlp$v_qualhelp]			!Unless qualifier help
		THEN helpinfo [hlp$l_curlevel] = .level;	! set help level
	    wild_path = (.ch_result NEQ 0) OR .helpinfo [hlp$v_allhelp] !Determine if wild key
				OR .wildflag [.helplevel - 1];
!
! If this key is on last level, then print the help text
!
	    IF .level EQL .helpinfo [hlp$l_realkeys]		!If found last key
		OR .helpinfo [hlp$v_allhelp]			! or we are printing all help
	    THEN BEGIN
		IF .helpinfo [hlp$v_qualhelp]			!If qualifier help
		THEN CH$MOVE (rfa$c_length, lastqualrfa,	! then set to reread line
					helpinfo [hlp$b_readrfa])
		ELSE perform (copy_key (.helpdata, recdesc)); 	!Otherwise put on keyname line
		IF .helpinfo [hlp$v_allhelp]			!If printing all help
		    THEN helpinfo [hlp$l_lastlevel] = .level;	! then set last level correctly
		perform (print_helptext (.helpdata));
		helpinfo [hlp$v_hlpfound] = true;		!Flag help found this call to help_do_key1
		qualseen = false;				!Flag no qualifer seen
			IF NOT .helpinfo [hlp$v_qualhelp]	!Unless qualifier help
			    THEN helpinfo [hlp$l_curlevel] = .helpinfo [hlp$l_curlevel]
								- 1;
			IF .helpinfo [hlp$l_readsts]		!If last read was not end of file
			    THEN BEGIN
				perform (find_help_key (.helpdata,	!  then recurse for next
					.helplevel));
				IF NOT .helpinfo [hlp$l_readsts]
				    THEN EXITLOOP;
				END
			    ELSE EXITLOOP			!Quit if eom
		END
	    ELSE BEGIN
		perform (copy_key (.helpdata, recdesc)); 	!Put key in buffer
		perform (find_help_key (.helpdata, (IF .helpinfo [hlp$v_qualhelp]
							THEN .helplevel
							ELSE .helplevel + 1)));

		IF .helpinfo [hlp$l_readsts]			!If still more module to go
		THEN BEGIN
		    perform (find_help_key (.helpdata, .helplevel)); ! then recurse for more keys
		    IF NOT .helpinfo [hlp$l_readsts]		!If we are now at end of module
			THEN EXITLOOP;				! then all done
		    END
		ELSE EXITLOOP;					! exit if at end of module
		END;
	    END
!
! Line was not special
!
	ELSE BEGIN						!
	    IF NOT .is_key					!If no key on line
		    OR (.helpinfo [hlp$v_qualhelp]		! or this is qualifier help
		    AND NOT .helpinfo [hlp$v_qualine])		! and this line not a qualifier line
		    THEN qualseen = false;
	    IF .is_key						!If key on line
		AND .level LSSU .helplevel			! and its less than level we are looking for
		THEN BEGIN
		    CH$MOVE (rfa$c_length, saverfa, helpinfo [hlp$b_readrfa]); !restore rfa of last record
		    EXITLOOP;					!Terminate now
		    END;
	    END;
    END;							!End of WHILE loop

!
! Make sure some help was found.  If no help was found, and the request is not "..."
! and no keys above this level were wild, then issue the "no help" message.
!

BEGIN
    BUILTIN
	FFS;

    LOCAL
	posadr,
	sizadr,
	dstadr;

    posadr = 0;							!Start at first bit
    sizadr = .helplevel - 1;					!Look at this many bits
    wild_path = NOT FFS (posadr, sizadr, wildflag, dstadr);	!Look for a wild key
    END;

IF NOT .helpinfo [hlp$v_hlpfound]				!If no help found
    AND NOT (.helpinfo [hlp$v_allhelp]				! and not "..."
		OR .wild_path)					! and not wild path to key
    THEN BEGIN
	helpinfo [hlp$v_hlpfound] = true;			!Flag help found this call to do_key1
	helpinfo [hlp$v_anyhelp] = true;			!Flag help found this call to lbr$get_help
	CH$MOVE (rfa$c_length, savelastrfa,			!Restore last rfa
					helpinfo [hlp$b_lstkeyrfa]);
	perform (print_nohelp (.helpdata));			!   then print no help available
	END;

RETURN true
END;								!Of find_help_key

%SBTTL	'Routine help_do_key1';
!
! Main body of help_do_key1
!

MAP
    helpdata : REF VECTOR [,LONG];

LOCAL
    helpkey,
    recdesc : BBLOCK [dsc$c_s_bln];

BIND
    context = .lbr$gl_control [lbr$l_ctxptr] : BBLOCK,	!Context block
    helpinfo = .helpdata [hlp$k_info] : BBLOCK,		!Pointer to information structure
    key1desc = helpdata [hlp$k_key1desc] : REF BBLOCK;	!Start of key descriptor addresses

helpinfo [hlp$v_uothinfo] = false;			!Not doing other info text now
helpinfo [hlp$v_unohlp] = false;			!Haven't determined if help or not yet
helpinfo [hlp$v_ukeylin] = false;			!Not a key line
helpinfo [hlp$l_curlevel] = 1;				!Now at level 1
helpinfo [hlp$l_lastlevel] = 1;				!Last looked at level 1
helpkey = %ASCII 'HELP';
CH$FILL (0, rfa$c_length, helpinfo [hlp$b_key2rfa]);	!Zero key2 rfa
CH$MOVE (rfa$c_length, .entryrfa, helpinfo [hlp$b_readrfa]); !Copy the RFA
CH$FILL (%ASCII ' ', hlp$c_maxrecsiz, .(helpinfo [hlp$l_bufdesc] + 4));

perform (copy_key (.helpdata, .entrydesc));			!Copy key1 into buffer

!
! Read and skip module header and first record ("1 KEY1")
!

IF NOT (helpinfo [hlp$l_readsts] = read_record (helpinfo [hlp$b_readrfa], recdesc))	!Read and skip module header
    THEN RETURN .helpinfo [hlp$l_readsts];
IF NOT (helpinfo [hlp$l_readsts] = read_record (helpinfo [hlp$b_readrfa], recdesc))	!Read first record to skip it
    THEN RETURN .helpinfo [hlp$l_readsts];
CH$MOVE (rfa$c_length, helpinfo [hlp$b_readrfa], helpinfo [hlp$b_lstkeyrfa]);	!Remember RFA of first good text

!
! If there was only one key on the line then handle that.
!

IF .helpinfo [hlp$l_realkeys] EQL 1			!If only one key
   AND NOT .helpinfo [hlp$v_allhelp]			! and not '...'
   THEN BEGIN
	IF NOT .context [ctx$v_outputhlp]		!If not for LBR$OUTPUT_HELP
	   AND CH$EQL (.key1desc [dsc$w_length],	! and 'HELP' keyword
			.key1desc [dsc$a_pointer],
			.key1desc [dsc$w_length],
			helpkey)
	   THEN helpinfo [hlp$v_helphlp] = true;	! then print additional info
	RETURN print_helptext (.helpdata);		! then print text and return
	END

!
! There is more than 1 key.  Search the help text for the text to print
!

ELSE
    BEGIN
	IF .helpinfo [hlp$v_allhelp]			!If "..." then print help for key1 also
	    THEN perform (print_helptext (.helpdata));
	helpinfo [hlp$v_hlpfound] = false;		!Flag no help found this call to do_key1
	find_help_key (.helpdata, 2);			!Find the help text and print it
	END;

RETURN true
END;					! Of help_do_key1

%SBTTL	'Routine print_helptext';
ROUTINE print_helptext (helpdata) =
BEGIN
!++
! Print some help text
!
! Inputs:
!
!	helpdata	Address of help data vector set up by lbr$get_help
!
! Outputs:
!
!	localrfa	updated
!	help text is output
!
!--

MAP
    helpdata : REF VECTOR [,LONG];

LOCAL
    dataseen,
    recdesc : BBLOCK [dsc$c_s_bln],
    saverfa : BBLOCK [rfa$c_length],
    level,
    keydesc : BBLOCK [dsc$c_s_bln];

BIND
    helpinfo = .helpdata [hlp$k_info] : BBLOCK,
    reclen = recdesc [dsc$w_length] : WORD,
    recaddr = recdesc [dsc$a_pointer] : REF VECTOR [,BYTE];

perform (print_keys (.helpdata));
perform (print_blankline (.helpdata));
CH$MOVE (rfa$c_length, helpinfo [hlp$b_readrfa], saverfa);
dataseen = false;
IF .helpinfo [hlp$l_readsts]
THEN 
!
! Read records until end of module or key/qualifier stop
!
WHILE  (
	CH$MOVE (rfa$c_length, helpinfo [hlp$b_readrfa], saverfa);
	(helpinfo [hlp$l_readsts] = read_record (helpinfo [hlp$b_readrfa], recdesc))
	)
DO BEGIN
    IF (.reclen EQL 0) OR (.recaddr [0] NEQ %ASCII '!')	! We really just want to check if its a comment line,
		! but we must first check if its a zero length line, because if it is, recaddr [0] 
		! will be the line length of the next line instead of the first character of the current line
    THEN
	BEGIN
	IF  is_key_on_line (helpinfo, recdesc, level, keydesc)
	THEN BEGIN
	    IF .helpinfo [hlp$v_qualhelp]		!If qualifier help
		THEN BEGIN
		    IF (.helpinfo [hlp$v_qualine]		! and its a qualifier line
			AND .dataseen)			! and we have seen other than
			OR .helpinfo [hlp$v_keyline]	!  a qualifier, or this
							!   is a keyword line
			THEN EXITLOOP;			!     then get out of the loop
		    END;
	    IF NOT .helpinfo [hlp$v_qualhelp]		!If keyword help
	        AND .helpinfo [hlp$v_keyline]		! and its a keyword line
		THEN EXITLOOP;				!  then all done
	    END;					!Is a key line
    perform (call_output (.helpdata, recdesc));
    helpinfo [hlp$v_anyhelp] = true;			!Flag help was found
    IF NOT .helpinfo [hlp$v_qualine]			!Unless a qualifier line
	THEN dataseen = true;
	END;						! Not a comment line
    END;						! of while loop

CH$MOVE (rfa$c_length, saverfa, helpinfo [hlp$b_readrfa]); !Restore RFA of last record
perform (print_options (.helpdata));			!Print additional options available

RETURN true;
END;					! Of print_helptext

%SBTTL	'Routine print_nohelp';
ROUTINE print_nohelp (helpdata) =
BEGIN
!++
! Tell that no help was found as requested
!
! Inputs:
!
!	helpdata	Address of help data vector set up by lbr$get_help
!
! Outputs:
!
!	A string telling that no help was found is output.
!
!--

MAP
    helpdata : REF VECTOR [,LONG];

BIND
    helpinfo = .helpdata [hlp$k_info] : BBLOCK,
    wildflag = helpinfo [hlp$t_wildflags] : BITVECTOR;


LOCAL
    lastlevel,
    desc : BBLOCK [dsc$c_s_bln];

helpinfo [hlp$v_unohlp] = true;
perform (print_keys (.helpdata));
helpinfo [hlp$v_qualhelp] = false;
CH$FILL (%ASCII' ', hlp$c_maxrecsiz, .(helpinfo [hlp$l_bufdesc] + 4));
desc [dsc$w_length] = .nodocmsg [0];
desc [dsc$a_pointer] = nodocmsg [1];
perform (move_key (.helpdata, desc, 1));
lastlevel = .helpinfo [hlp$l_lastlevel];
IF .lastlevel EQL 0
    THEN lastlevel = 1;
!
! Copy as many of the keys into the buffer as we can
!
INCRU i FROM hlp$k_key1desc TO hlp$k_key1desc + .helpinfo [hlp$l_realkeys]-1	! Print all the keys
DO BEGIN
    BIND
	curkeydesc = .helpdata [.i] : BBLOCK;

    perform (move_key (.helpdata, curkeydesc, 1));
    END;

perform (print_blankline (.helpdata));
perform (print_line (.helpdata));
perform (print_options (.helpdata));
helpinfo [hlp$v_unohlp] = false;

RETURN true
END;						!Of print_nohelp

%SBTTL	'Routine print_options';
ROUTINE print_options (helpdata) =
BEGIN
!++
! Print help options available
!
! Inputs:
!
!	helpdata	Address of help data vector set up by lbr$get_help
!
! Outputs:
!
!	Help that is available is output.
!
!--

%SBTTL	'Routine print_otherinfo';
ROUTINE print_otherinfo (helpdata) =
BEGIN
!++
! Print the text "other information available" surrounded by
! blank lines.
!
! Inputs:
!
!	helpdata	data vector set up by lbr$get_help
!
!--
MAP
    helpdata : REF VECTOR [,LONG];

LOCAL
    desc : BBLOCK [dsc$c_s_bln];

desc [dsc$w_length] = .otherinfo [0];		!Set up descriptor for text
desc [dsc$a_pointer] = otherinfo [1];
perform (print_blankline (.helpdata));		!Print a blank line
perform (call_output (.helpdata, desc));	!Tell other info available
perform (print_blankline (.helpdata));		!and a blank line

RETURN true
END;						!Of print_otherinfo

%SBTTL	'Routine move_watch_tabs';
ROUTINE move_watch_tabs (helpdata, desc) =
BEGIN
!++
!
! Move a key into the buffer with logical tab control
!
! Inputs:
!
!	helpdata	Address of help data vector set up by lbr$get_help
!	desc		Address of string descriptor for key
!
! Outputs:
!
!	Key is copied into the buffer, watching logical tab stops
!
!--

MAP
    helpdata : REF VECTOR [,LONG],
    desc : REF BBLOCK;

BIND
    helpinfo = .helpdata [hlp$k_info] : BBLOCK;

LOCAL
    endpos,
    startpos,
    keytabs;

startpos = .helpinfo  [hlp$l_tabindex] * hlp$c_logtab;
endpos = .helpinfo [hlp$l_width] - ((.helpinfo [hlp$l_curlevel] + 1) * hlp$c_indent);
IF .startpos GEQU .endpos
    OR (.startpos + .desc [dsc$w_length] + 1) GTRU .endpos
THEN  perform (print_line (.helpdata));		!Make room for line
keytabs = (.desc [dsc$w_length] + hlp$c_logtab) / hlp$c_logtab;
helpinfo [hlp$l_tabindex] = .helpinfo [hlp$l_tabindex] + .keytabs;
helpinfo [hlp$l_curptr] = CH$COPY (.desc [dsc$w_length],
			.desc [dsc$a_pointer], %ASCII ' ',
			.keytabs*hlp$c_logtab, .helpinfo [hlp$l_curptr]);
helpinfo [hlp$l_nchars] = .helpinfo [hlp$l_nchars] + .keytabs*hlp$c_logtab;
RETURN true;
END;					!Of move_watch_tabs

%SBTTL	'Routine add_key';
ROUTINE add_key  (entry, user_routine, index_desc, helpdata) =
BEGIN
!
! Move a key into the buffer
!
MAP
    entry : REF BBLOCK,
    helpdata : REF VECTOR [,LONG];

LOCAL
    entrydesc : BBLOCK [dsc$c_s_bln];

entrydesc [dsc$w_length] = .entry [idx$b_keylen];
entrydesc [dsc$a_pointer] = entry [idx$t_keyname];
perform (move_watch_tabs (.helpdata, entrydesc));
RETURN true
END;					!Of add_key

%SBTTL	'Main body of print_options';

!
! Main body of print_options
!
MAP
    helpdata : REF VECTOR [,LONG];

LOCAL
    lastflags,
    level,
    lastlevel,
    tokendesc : BBLOCK [dsc$c_s_bln],
    recdesc : BBLOCK [dsc$c_s_bln],
    desc : BBLOCK [dsc$c_s_bln],
    saverfa : BBLOCK [rfa$c_length],
    first_time;

BIND
    helpinfo = .helpdata [hlp$k_info] : BBLOCK,
    curflags = helpinfo [hlp$l_hlpflags] + 2 : WORD,
    key2rfa = helpinfo [hlp$b_key2rfa],
    wildflag = helpinfo [hlp$t_wildflags] : BITVECTOR,
    reclen = recdesc [dsc$w_length] : WORD,
    recaddr = recdesc [dsc$a_pointer];

IF .helpinfo [hlp$v_qualhelp] OR .helpinfo [hlp$v_allhelp]
    THEN RETURN true;

lastlevel = .helpinfo [hlp$l_lastlevel];
IF .helpinfo [hlp$v_unohlp]
    AND .lastlevel NEQ 0
	THEN DO lastlevel = .lastlevel - 1
		UNTIL ((.lastlevel EQL 0)
			    OR NOT .wildflag [.lastlevel - 1]);

helpinfo [hlp$v_uothinfo] = true;
IF .lastlevel EQL 1
    AND .helpinfo [hlp$v_unohlp]
    AND .key2rfa NEQ 0			! avoid storing an rfa which has never been set
    THEN CH$MOVE (rfa$c_length, helpinfo [hlp$b_key2rfa], helpinfo [hlp$b_readrfa])
    ELSE CH$MOVE (rfa$c_length, helpinfo [hlp$b_lstkeyrfa], helpinfo [hlp$b_readrfa]);
first_time = true;
lastflags = 0;
level = 0;

IF (.helpinfo [hlp$v_unohlp]				!If first no help found
    AND .lastlevel EQL 0)				! at first level
    OR .helpinfo [hlp$v_helphlp]			! or inserted 'HELP' key
THEN BEGIN
    helpinfo [hlp$v_anyhelp] = true;
    perform (print_otherinfo (.helpdata));		!Print "other info available"
    perform (traverse_keys (1, add_key, 0, .helpdata)); !Format and print index
    IF .helpinfo [hlp$l_nchars] NEQ 0
	THEN perform (print_line (.helpdata));
    END

ELSE
WHILE  (
	CH$MOVE (rfa$c_length, helpinfo [hlp$b_readrfa], saverfa);
	(helpinfo [hlp$l_readsts] = read_record (helpinfo [hlp$b_readrfa], recdesc))
	)
DO IF is_key_on_line (helpinfo, recdesc, level, tokendesc)	!If key on line
    AND (IF .helpinfo [hlp$v_qualhelp]				! (if qualifier help 
		THEN .helpinfo [hlp$v_qualine]			!   and its a qualifier
		ELSE (
			IF .first_time AND .helpinfo [hlp$v_qualine]
			    THEN false
			    ELSE true
		     )
		     )
    AND .level LEQ .lastlevel + 1					!And we might want to look at key
THEN BEGIN
    IF .level LEQ .lastlevel						!If found start of next level
    THEN BEGIN
	CH$MOVE (rfa$c_length, saverfa, helpinfo [hlp$b_readrfa]);	!Restore RFA of last record
	IF .helpinfo [hlp$l_nchars] NEQ 0
	THEN perform (print_line (.helpdata));
	RETURN true;
	END;
    IF .first_time
    THEN BEGIN
	perform (print_otherinfo (.helpdata));	!Print "other info available"
	helpinfo [hlp$v_anyhelp] = true;	!Flag help was found
	first_time = false;
	END;
    IF ((.lastflags NEQ .curflags)		!If different line type
	AND (.lastflags NEQ 0))			! (and not first line)
	THEN perform (print_line (.helpdata));	! then force out previous line
    tokendesc [dsc$w_length] = .reclen - 	!Figure length of line
			(.tokendesc [dsc$a_pointer] - .recaddr);
    perform (move_watch_tabs (.helpdata, tokendesc));
    lastflags = .curflags;			!Set new flags
    END;

CH$MOVE (rfa$c_length, saverfa, helpinfo [hlp$b_readrfa]);
IF .helpinfo [hlp$l_nchars] NEQ 0
    THEN perform (print_line (.helpdata));

RETURN true
END;						!Of print_options

%SBTTL	'Routine print_keys';
ROUTINE print_keys (helpdata) =
BEGIN
!++
! Print the keys found
!
! Inputs:
!
!	helpdata	Address of help data vector set up by lbr$get_help
!
! Implicit inputs:
!
!	The keylist array is set up.
!
! Outputs:
!
!	The key names are displayed on the terminal
!
!--

MAP
    helpdata : REF VECTOR [,LONG];

LOCAL
    lastlevel;

BIND
    helpinfo = .helpdata [hlp$k_info] : BBLOCK,
    wildflag = helpinfo [hlp$t_wildflags] : BITVECTOR,
    keylist = .helpinfo [hlp$l_keylist] : BBLOCK;

IF (lastlevel = .helpinfo [hlp$l_lastlevel]) EQL 0	!If no keys found
    THEN RETURN true;					! then don't print any
helpinfo [hlp$v_ukeylin] = true;			!Flag on keyname line

IF .helpinfo [hlp$v_unohlp]				!If no help found
    THEN DO lastlevel = .lastlevel - 1
	UNTIL ((.lastlevel EQL 0)
	    OR NOT .wildflag [.lastlevel - 1]);

lastlevel = .lastlevel - 1;				!Adjust for 0 base
IF .lastlevel GEQ 0
THEN INCR i FROM 0 TO .lastlevel			!Loop through all descriptors
DO BEGIN
    BIND
	curkeydesc = keylist + .i*dsc$c_s_bln : BBLOCK;	!Point to the descriptor

    IF .curkeydesc [dsc$a_pointer] NEQ 0		!If valid descriptor
    THEN BEGIN
	helpinfo [hlp$l_curlevel] = .i + 1;		!Set correct help level
	perform (print_blankline (.helpdata));		!Print blank line
	perform (call_output (.helpdata, curkeydesc));	!Print the key line
	END;
    END;

helpinfo [hlp$v_ukeylin] = false;			!No longer a key line
RETURN true

END;					!of print_keys

%SBTTL	'Routine print_line';
ROUTINE print_line (helpdata) =
BEGIN
!++
! Print the line
!
! Inputs:
!
!	helpdata	Address of help data vector set up by lbr$get_help
!
! Implicit inputs:
!
!	the buffer descriptor in the helpinfo vector has a valid string descriptor
!
! Outputs:
!
!	String is output
!
!--

MAP
    helpdata : REF VECTOR [,LONG];

BIND
    helpinfo = .helpdata [hlp$k_info] : BBLOCK;

LOCAL
    desc : BBLOCK [dsc$c_s_bln];

desc [dsc$a_pointer] = .(helpinfo [hlp$l_bufdesc] + 4);
desc [dsc$w_length] = .helpinfo [hlp$l_curptr] - .desc [dsc$a_pointer];
perform (call_output (.helpdata, desc));
helpinfo [hlp$l_nchars] = 0;				!Reset the counter
helpinfo [hlp$l_curptr] = .(helpinfo [hlp$l_bufdesc] + 4);!and pointer
CH$FILL (%ASCII ' ', .desc [dsc$w_length], .desc [dsc$a_pointer]);
RETURN true
END;							!Of print_line

%SBTTL	'Routine print_blankline';
ROUTINE print_blankline (helpdata) =
BEGIN
!++
! Print a blank line
!
! Inputs:
!
!	helpdata	Address of help data vector set up by lbr$get_help
!
! Outputs:
!
!	A blank line is output.
!
!--

MAP
    helpdata : REF VECTOR [,LONG];

LOCAL
    desc : BBLOCK [dsc$c_s_bln];

CH$FILL (0, dsc$c_s_bln, desc);
RETURN call_output (.helpdata, desc)
END;						!of print_blankline

%SBTTL	'Routine call_output';
ROUTINE call_output (helpdata, desc) =
BEGIN
!++
! Call user routine or LIB$PUT_OUTPUT to print line of help text.
!
! Inputs:
!
!	helpdata	Address of help data vector set up by lbr$get_help
!	desc		Address of string descriptor of line to output
!
! Outputs:
!
!	line is output via lib$put_output or user routine
!
!--

MAP
    helpdata : REF VECTOR [,LONG],
    desc : REF BBLOCK;

LOCAL
    flags,
    ptr,
    spaces,
    localdesc : BBLOCK [dsc$c_s_bln],
    a_zero,
    linebuffer : BBLOCK [hlp$c_maxrecsiz*2];

BIND
    helpinfo = .helpdata [hlp$k_info] : BBLOCK,
    linedesc = helpinfo [hlp$l_bufdesc] : BBLOCK,
    user_data = (
		IF .helpdata [hlp$k_userdata] NEQ 0
			THEN .helpdata [hlp$k_userdata]
			ELSE a_zero
		);

BIND ROUTINE
    typeout_routine = helpdata [hlp$k_userout];

a_zero = 0;
CH$FILL (0, dsc$c_s_bln, localdesc);
IF .desc [dsc$w_length] NEQ 0
    AND .desc [dsc$a_pointer] NEQ 0
THEN BEGIN
    IF .helpinfo [hlp$v_ukeylin] OR (.typeout_routine NEQ 0)
	THEN spaces = 0
	ELSE spaces = (.helpinfo [hlp$l_curlevel] + 1) * hlp$c_indent;
    ptr = CH$FILL (%ASCII ' ', .spaces, linebuffer);
    CH$MOVE (.desc [dsc$w_length], .desc [dsc$a_pointer], .ptr);
    localdesc [dsc$w_length] = .desc [dsc$w_length] + .spaces;
    localdesc [dsc$a_pointer] = linebuffer;
!
! Delete trailing spaces
!
    ptr = linebuffer + .localdesc [dsc$w_length];
    WHILE (
	ptr = .ptr - 1;
	CH$RCHAR (.ptr) EQL %ASCII ' '
	)
	DO localdesc [dsc$w_length] = .localdesc [dsc$w_length] - 1;
END;
!
! Call caller's routine or LIB$PUT_OUTPUT if caller didn't specify one
!
helpinfo [hlp$l_tabindex] = 0;
IF .typeout_routine NEQ 0
    THEN BEGIN
	flags = .helpinfo [hlp$l_hlpflags] AND %X'FFFF';		!Trim flags to user-only flags
	RETURN (.typeout_routine) (localdesc, flags, user_data, helpinfo [hlp$l_curlevel]);
	END
    ELSE RETURN lib$put_output (localdesc)

END;					! Of call_output

%SBTTL	'Routine is_key_on_line';
ROUTINE is_key_on_line (helpinfo, linedesc, level, keydesc) =
BEGIN
!++
! This routine scans the line described by linedesc to see if
! it is a keyword line or a qualifier line.
!
! Inputs:
!
!	helpinfo	Address of help info vector (pointed to by help data vector)
!	linedesc	Address of string descriptor for the line
!
! Outputs:
!
!	level		level found is returned
!	keydesc		filled in with string descriptor for found key/qualifier
!
! Return values:
!
!	true		key/qualifier found, level and keydesc filled in
!	false		not a key/qualifier line
!
!--

MAP
    helpinfo : REF BBLOCK,
    linedesc : REF BBLOCK,
    keydesc  : REF BBLOCK;

LOCAL
    lineptr,
    curchar;

helpinfo [hlp$v_qualine] = false;		!Not a qualifier line
helpinfo [hlp$v_keyline] = false;		! or a key line
IF .linedesc [dsc$w_length] EQL 0		!If 0-length line
    THEN RETURN false;				! there can be no key on line
lineptr = .linedesc [dsc$a_pointer];
curchar = CH$RCHAR (.lineptr);
IF (.curchar LSSU %ASCII'0'			!If not numeric
    OR .curchar GEQU %ASCII'9')
    AND .curchar NEQ %ASCII'/'			!And not a qualifier line
THEN RETURN false				! then its not a keyword line
ELSE BEGIN
    IF .curchar NEQ %ASCII '/'			!Unless a keyword
	THEN BEGIN
	lineptr = .lineptr - 1;			!Back up the pointer
	IF NOT skip_blanks (.linedesc, lineptr)	! and skip blanks
	    THEN RETURN false;			!  and if went to end of line, not special line
	keydesc [dsc$a_pointer] = .lineptr;	!Set pointer to start of key
	keydesc [dsc$w_length] = scan_word (.linedesc, lineptr);
	IF NOT lib$cvt_dtb (.keydesc [dsc$w_length],
				.keydesc [dsc$a_pointer], .level)
		THEN RETURN false;
	IF NOT skip_blanks (.linedesc, lineptr)	!Skip blanks following key level
		THEN RETURN false;		!and give up if end of line
	helpinfo [hlp$v_keyline] = true;	!Flag a key line
	END
	ELSE BEGIN
	    helpinfo [hlp$v_qualine] = true;	!'/' -- flag qualifier line
	    END;
    keydesc [dsc$a_pointer] = .lineptr;		!Set pointer to keyword or qualifier
    keydesc [dsc$w_length] =  scan_word (.linedesc, lineptr);
    RETURN true;
    END;
END;					! Of is_key_on_line

%SBTTL	'Routine make_upper_case';
ROUTINE make_upper_case (idesc, odesc) =
BEGIN
!++
! Upper case the name described by string descriptor idesc
! Put the name at location oname
!
! Inputs:
!
!	idesc		Address of string descriptor for input string
!
! Outputs:
!
!	odesc		String descriptor size filled in with right size
!			buffer pointed to by address is uppercased input string
!
!--

MAP
    idesc : REF BBLOCK,
    odesc : REF BBLOCK;
BIND
    oname = .odesc [dsc$a_pointer] : VECTOR [,BYTE],
    namlen = idesc[dsc$w_length] : WORD,
    iname = .idesc[dsc$a_pointer] : VECTOR[,BYTE];

IF .namlen GTRU 0
THEN INCRU i FROM 0 TO .namlen-1
DO IF .iname[.i] GEQU %ASCII'a'			!copy name and convert to upper case
   AND .iname[.i] LEQU %ASCII'z'
   THEN oname[.i] = .iname[.i] - (%ASCII'a' - %ASCII'A')
   ELSE IF .iname [.i] EQL %ASCII ' '		!If character is space or tab
		OR .iname [.i] EQL %ASCII '	'
		OR .iname [.i] EQL 0
	THEN BEGIN
	    odesc [dsc$w_length] = .i;
	    RETURN true
	    END
    ELSE oname[.i] = .iname[.i];

odesc [dsc$w_length] = .namlen;
RETURN true

END;						!Of make_upper_case

%SBTTL	'Routine scan_word';
ROUTINE scan_word (linedesc, lineptr) =
BEGIN
!++
! This routine returns the length of the word which is pointed to
! by lineptr in the line linedesc describes.  It also advances
! lineptr to the character past the end of the word.
!
! Inputs:
!
!	linedesc	Address of string descriptor for line
!	lineptr		Points to beginning of word
!
! Outputs:
!
!	lineptr		updated
!
! Return value:
!
!	Length of word found
!
!--

MAP
    linedesc : REF BBLOCK;

LOCAL
    firstchar,
    ownptr,
    endptr,
    startptr,
    curchar : BYTE;

IF .linedesc [dsc$w_length] EQL 0	!If 0-length line
    THEN RETURN 0;			! then no word to return
ownptr = ..lineptr;			!Get pointer to start of word
startptr = .ownptr;			!Remember where it starts
endptr = .linedesc [dsc$w_length] + .linedesc [dsc$a_pointer]; !Figure end of word
firstchar = true;			!Doing first character
WHILE CH$DIFF (.endptr, .ownptr) GTR 0	!While there is line left
DO BEGIN
    curchar = CH$A_RCHAR (ownptr);	!Get the character
    IF NOT ((.curchar GEQU %ASCII 'A'	!If its upper case letter
		AND .curchar LEQU %ASCII 'Z')
	OR (.curchar GEQU %ASCII 'a'	! or lower case letter
		AND .curchar LEQU %ASCII 'z')
	OR (.curchar GEQU %ASCII '0'	! or a digit
		AND .curchar LEQU %ASCII '9')
	OR (.curchar EQL %ASCII '$')	! or a dollar sign
	OR (.curchar EQL %ASCII '_')	! or an underscore
	OR (.curchar EQL %ASCII '-')	! or a hyphen
	OR (.firstchar AND (.curchar EQL %ASCII '/'))) !Or first character and its a slash
	THEN EXITLOOP;			!   then its ok, otherwise we found end of word
    firstchar = false;			!Not first character any more
    END;
.lineptr = .ownptr;			! Return updated pointer
RETURN .ownptr - .startptr;		! 
END;					! Of scan_word

%SBTTL	'Routine skip_blanks';
ROUTINE skip_blanks (linedesc, lineptr) =
BEGIN
!++
! This routine skips blanks and tabs in the line.
! Returns true if skipped to non-blank, non-tab character
! Returns false if skipped to exclamation pointer or end of line.
!
! Inputs:
!
!	linedesc	Address of string descriptor for current line
!	lineptr		Address of pointer to current spot in line
!
! Outputs:
!
!	lineptr		updated
!
! Return values:
!
!	true		more to come
!	false		no non-blank, non-tab, non-comment found
!
!--

MAP
    linedesc : REF BBLOCK;

LOCAL
    retval,
    ownptr,
    endptr,
    curchar;

IF .linedesc [dsc$w_length] EQL 0	!If 0-length line
    THEN RETURN false;			! then end of line
ownptr = ..lineptr;			!Make a copy of the pointer
endptr = .linedesc [dsc$w_length] + .linedesc [dsc$a_pointer] - 1;
WHILE CH$DIFF (.endptr, .ownptr) GTR 0
DO BEGIN
    curchar = CH$A_RCHAR (ownptr);
    IF .curchar EQL %ASCII '!'
	THEN BEGIN
	    .lineptr = .ownptr;
	    RETURN false;
	    END;
    IF .curchar NEQ %ASCII ' '
	AND .curchar NEQ %ASCII '	'
	THEN BEGIN
	    .lineptr = .ownptr;
	    RETURN true;
	    END;
    END;
.lineptr = .ownptr;
RETURN false;				!Went to end of line
END;					!Of skip_blanks
END					! Of module
ELUDOM
