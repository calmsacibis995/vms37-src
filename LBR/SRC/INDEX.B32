MODULE LBR_INDEX 
		(IDENT = 'V03-000') =	! Index manipulation routines
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:  Library access procedures
!
! ABSTRACT:
!
!	The VAX/VMS librarian procedures implement a standard access method
!	to libraries through a shared, common procedure set.
!
! ENVIRONMENT:
!
!	VAX native, user mode.
!
!--
!
!
! AUTHOR: Tim Halvorsen, Benn Schreiber		11-Jun-1979
!
! MODIFIED BY:
!
!	V02-011		RPG0011		Bob Grosso	22-Dec-1981
!		Use new keyword copy routine.
!
!	V02-010		RPG0010		Bob Grosso	08-Sep-1981
!		Add wildcard lower case key support.
!
!	V02-009		LMK0001		Len Kawell	02-Sep-1981
!		Remove unused LBR$_INSVIRMEM.
!
!	V02-008		RPG00048	Bob Grosso	31-Aug-1981
!		Remove LBRMSG
!
!	V02-007		RPG00047	Bob Grosso	12-Aug-1981
!		Lower case keyword support
!
!	V02-006		RPG00037	Bob Grosso	6-Jul-1981
!		Adjust index splitting.  Substitute lbr$c_maxkeylen
!		for sym$c_maxlng.
!
!	V02-005		RPG00036	Bob Grosso	1-May-1981
!		Enable error checking on call to reset_highest2.
!
!	V02-004		RPG00029	Bob Grosso	6-Apr-1981
!		Consolidate code, enable large keywords and correct
!		comments.
!
!	V02-003		RPG00014	Bob Grosso	10-Feb-1981
!		Enable variable length keywords in indices.
!
!	V02-002		RPG0019		Bob Grosso	26-Feb-1981
!		Make check_lock a global routine for PUTCACHE
!
!	V02-001		RPG00008	Bob Grosso	5-Jan-1981
!		Correct BUILTIN declarations
!--

%SBTTL 'Declarations';
LIBRARY 'SYS$LIBRARY:STARLET.L32';	! VAX/VMS common definitions

REQUIRE 'PREFIX';		! Librarian general definitions

REQUIRE 'LBRDEF';		! Librarian structure definitions

REQUIRE	'OLDFMTDEF';		! Old library format definitions

LINKAGE
    fmg_match = JSB (REGISTER = 2, REGISTER = 3,
			REGISTER = 4, REGISTER = 5) : NOTUSED (10, 11); ! Linkage for FMG$MATCH_NAME

FORWARD ROUTINE
    lbr$set_index,		! Set current index number
    lbr$lookup_key,		! Lookup a key and return RFA
    lbr$insert_key,		! Insert a key
    lbr$replace_key,		! Replace rfa for key and modify module header ref. counts
    lbr$delete_key,		! Delete a key
    lbr$get_index,		! Return all entries of an index
    lbr$search,			! Search for all keys assoc. with RFA
    check_wild,			! Check wildcard name against entry
    call_user,			! Call user action routine
    add_key,			! Add a key to a specified index
    delete_key,			! Delete key from current primary index
    remove_key,			! Remove a key from a specified index
    lookup_key,			! Lookup a key and return an RFA
    traverse_keys,		! Traverse an index one key at a time
    create_index,		! Create an index block
    delete_index,		! Deallocate an index block
    find_key,			! Find key in index structure
    key_search,			! Binary key search
    key_search2,		! Variable length keyword search
    find_index : JSB_2,		! Locate index block
    add_index,			! Add index pointer to parent block
    add_index2,			! Add index pointer to parent block of variable index
    reset_highest,		! Reset highest keys in parent blocks
    reset_highest2,		! Reset highest keys in variable len index 
				!   parent blocks 
    check_lock : JSB_0,		! Check if index is locked from modification
    mark_dirty : JSB_1;		! Mark index block modified

EXTERNAL ROUTINE
    fmg$match_name : fmg_match,	! Perform embedded wild-card matching
    make_upper_case : JSB_3,	! Convert name to upper case, check length
    moveto_upper_case : JSB_3,	! Convert
    incr_refcnt,		! Increment module reference count
    decr_refcnt,		! Decrement module reference count
    lbr_old_lkp_key,		! Lookup key in old library
    lbr_old_get_idx,		! Return contents of old library index
    lbr_old_src_idx,		! Search old library index for RFA
    read_old_record : JSB_2,	! Read record from old format library
    get_mem : JSB_2,		! Allocate dynamic memory
    get_zmem : JSB_2,		! Allocate zeroed dynamic memory
    dealloc_mem : JSB_2,	! Deallocate dynamic memory
    alloc_block : JSB_2,	! Allocate disk block
    dealloc_block : JSB_1,	! Deallocate disk block
    read_block : JSB_2,		! Read disk block
    read_n_block : JSB_2,	! Read and cache multiple disk blocks
    find_block : JSB_3,		! Locate disk block and cache it
    read_record : JSB_2,	! Read data record
    write_record,		! Write data record
    add_cache : JSB_2,		! Add cache entry
    lookup_cache : JSB_2,	! Lookup cache entry
    empty_cache,		! Empty cache - write all dirty blocks
    set_module,			! Read module header
    incr_rfa : JSB_2,		! Increment an RFA
    validate_ctl : JSB_1;	! Validate control table index

EXTERNAL
    lbr$gl_maxread,		! Max number of blocks to read at once
    lbr$gl_maxidxrd,		! Max number of blocks in one index read
    lbr$gl_control: REF BBLOCK;	! Address of control block

EXTERNAL LITERAL
    lbr$_dupkey,
    lbr$_illctl,
    lbr$_illidxnum,
    lbr$_illop,
    lbr$_intrnlerr,
    lbr$_invkey,
    lbr$_invrfa,
    lbr$_keynotfnd,
    lbr$_libnotopn,
    lbr$_nomtchfou,
    lbr$_nulidx,
    lbr$_updurtrav;



%SBTTL  'LBR$SET_INDEX';
GLOBAL ROUTINE lbr$set_index (ctl_index, index) =

!---
!
!	Set the current primary index for later operations.
!
! Inputs:
!
!	ctl_index = Address of longword containing control table index.
!	index = Primary index number
!
! Outputs:
!
!	lbr$_illidxnum - illegal index number
!	lbr$_libnotopn - library file not open
!	lbr$_insvirmem - insufficent virtual memory
!	lbr$_illctl - illegal control table index
!---

BEGIN

BUILTIN
    NULLPARAMETER;		! True if argument unspecified


perform (validate_ctl (..ctl_index));	! Validate control table index

BEGIN
    BIND
	header = .lbr$gl_control [lbr$l_hdrptr]: BBLOCK; ! Get address of library header

    IF NULLPARAMETER(2)				! If index number not supplied
    OR ..index GTRU .header [lhd$b_nindex]	! If greater than maximum,
    OR ..index EQL 0
    THEN
	RETURN lbr$_illidxnum;		! return with error

    lbr$gl_control [lbr$l_curidx] = ..index; ! Save current index number
    END;

RETURN true;

END;

%SBTTL  'LBR$LOOKUP_KEY';
GLOBAL ROUTINE lbr$lookup_key (ctl_index, key_name, retrfa) =

!---
!
!	Lookup a specified key and return the RFA associated
!	with the key.
!
! Inputs:
!
!	ctl_index = Address of a longword containing control table index.
!	key_name = Address of descriptor if ASCII keys,
!			or actual binary key.
!	retrfa = Address of 6-byte buffer to receive RFA.
!
! Outputs:
!
!	retrfa = RFA associated with key, if found.
!
!	lbr$_libnotopn - library not open
!	lbr$_keynotfnd - key not found
!	lbr$_illctl - illegal control table index
!
!---

BEGIN

MAP
    key_name : REF BBLOCK,		! Pointer to string descriptor
    retrfa: REF BBLOCK;			! Pointer to RFA

LOCAL
    keydesc : BBLOCK [dsc$c_s_bln],
    keynambuf : BBLOCK [lbr$c_maxkeylen],
    recdesc : BBLOCK [dsc$c_s_bln];

BIND
    length = recdesc [dsc$w_length] : WORD,
    addr = recdesc [dsc$a_pointer] : REF BBLOCK;

perform (validate_ctl (..ctl_index));	! Validate control table index
keydesc [dsc$w_length] = .key_name [dsc$w_length];! Set length of name
keydesc [dsc$a_pointer] = keynambuf;
CH$MOVE (.key_name [dsc$w_length], 
	.key_name [dsc$a_pointer], .keydesc [dsc$a_pointer]);

BEGIN
    BIND
	header = .lbr$gl_control[lbr$l_hdrptr] : BBLOCK, ! Pointer to header
	context = .lbr$gl_control[lbr$l_ctxptr] : BBLOCK, ! Pointer to context block
	eomodrfa = context[ctx$b_eomodrfa] : BBLOCK,	! End of module RFA
	readrfa = context[ctx$b_readrfa] : BBLOCK;	! Next RFA for read

    IF .context[ctx$v_oldlib]				! If old format library
    THEN
	BEGIN
	    perform(lbr_old_lkp_key (keydesc, .retrfa));! Then process elsewhere
	    CH$MOVE(rfa$c_length, .retrfa, readrfa);	! Set RFA for reading
	    CH$FILL(0, rfa$c_length, eomodrfa);		! Disable end of module
	    perform(read_old_record(readrfa, recdesc)); ! Read and skip header
	    IF .length NEQ omh$c_size
		THEN RETURN lbr$_invrfa
		ELSE
		    BEGIN
			BIND
			    modsizwords = addr[omh$l_modsiz] : VECTOR[,WORD];

			CH$MOVE(rfa$c_length, .retrfa, eomodrfa);
			incr_rfa(.modsizwords[1] + .modsizwords[0]*%X'10000', eomodrfa);
			END
	    END
    ELSE
	BEGIN
	    perform (lookup_key (.lbr$gl_control [lbr$l_curidx],
			keydesc, .retrfa));

	    CH$MOVE(rfa$c_length, .retrfa, readrfa);	! Set for lbr$get_record
	    perform(read_record(readrfa, recdesc)); 	! Read module header to skip it
	    IF .length NEQ mhd$c_mhdlen+.header[lhd$b_mhdusz] ! If module header not correct length
	    OR .addr[mhd$l_refcnt] EQL 0			  !  or ref count is 0
	    THEN RETURN lbr$_invrfa;			  !  then RFA is bad
	    END;
    context[ctx$v_lkpdon] = true;		! Indicate lookup_key done
    END;

RETURN true;

END;

%SBTTL  'LBR$INSERT_KEY';
GLOBAL ROUTINE lbr$insert_key (ctl_index, key_name, rfa) =

!---
!
!	Insert a key into the current primary index.
!
! Inputs:
!
!	ctl_index = Address of control table index.
!	key_name = Address of descriptor if ASCII keys,
!			actual key if binary key.
!	rfa = Address of RFA to be associated with the key.
!
! Outputs:
!
!	lbr$_libnotopn - library not open
!	lbr$_illctl - illegal control table index
!	lbr$_dupkey - duplicate key
!	lbr$_invrfa - rfa does not point at valid data
!---

BEGIN

MAP
    key_name : REF BBLOCK[dsc$c_s_bln],
    rfa : REF BBLOCK[rfa$c_length];

LOCAL
    keydesc : BBLOCK [dsc$c_s_bln],
    keynambuf : BBLOCK [lbr$c_maxkeylen],
    cachentry : REF BBLOCK;

perform (validate_ctl (..ctl_index));	! Validate control table index
perform (check_lock ());		! Verify ability to modify index
keydesc [dsc$w_length] = .key_name [dsc$w_length];
keydesc [dsc$a_pointer] = keynambuf;
CH$MOVE (.key_name [dsc$w_length], 
	.key_name [dsc$a_pointer], .keydesc [dsc$a_pointer]);

BEGIN
    BIND
	index_desc = .lbr$gl_control[lbr$l_hdrptr] + lhd$c_idxdesc
		+ (.lbr$gl_control[lbr$l_curidx]-1)*idd$c_length : BBLOCK,
	context = .lbr$gl_control[lbr$l_ctxptr] : BBLOCK; ! Context block

    IF .context[ctx$v_oldlib]				! Cannot insert into old library
	OR .context [ctx$v_ronly]			!  or one that is read only
    THEN
	RETURN lbr$_illop;

    perform (add_key (.lbr$gl_control [lbr$l_curidx], keydesc, .rfa));
    perform(incr_refcnt(.rfa));						! Increment module refernce count
									!  updated reference count
    context[ctx$v_hdrdirty] = true;					! Flag header is dirty
    END;

RETURN true;

END;

%SBTTL  'LBR$REPLACE_KEY';
GLOBAL ROUTINE lbr$replace_key (ctl_index, key_name, oldrfa, newrfa) =

!---
!
!	Replace the RFA associated with a key with a new rfa.  Update
!	the reference counts in both the old and new module headers
!
! Inputs:
!
!	ctl_index = Address of control table index
!	key_name = Address of descriptor if ASCII, key if binary
!	oldrfa = Address of old rfa
!	newrfa = Address of new rfa
!
! Outputs:
!
!	lbr$_libnotopn - library not open
!	lbr$_illctl - illegal control table index
!	lbr$_invrfa - invalid rfa
!
!---

BEGIN

MAP
    key_name : REF BBLOCK,
    oldrfa : REF BBLOCK,
    newrfa : REF BBLOCK;

LOCAL
    keydesc : BBLOCK [dsc$c_s_bln],
    keynambuf : BBLOCK [lbr$c_maxkeylen];

perform (validate_ctl (..ctl_index));		! Validate control table index
keydesc [dsc$w_length] = .key_name [dsc$w_length];
keydesc [dsc$a_pointer] = keynambuf;
CH$MOVE (.key_name [dsc$w_length], 
	.key_name [dsc$a_pointer], .keydesc [dsc$a_pointer]);

BEGIN
    LOCAL
	vbn,
	index_block,
	offset,
	addpos,
	entry : REF BBLOCK;

    BIND
	context = .lbr$gl_control [lbr$l_ctxptr] : BBLOCK;

    IF .context [ctx$v_oldlib]
	OR .context [ctx$v_ronly]
	THEN RETURN lbr$_illop;
!
! First make sure its a real key.  If not found, treat as an insert
!
    IF NOT find_key (.lbr$gl_control [lbr$l_curidx], keydesc, 0,
			vbn, index_block, offset, addpos)
	THEN RETURN lbr$insert_key (.ctl_index, .key_name, .newrfa);
    entry = .index_block + index$c_entries + .offset;	! Point to entry
    IF NOT CH$EQL (rfa$c_length, entry [idx$b_rfa], rfa$c_length, .oldrfa)
	THEN RETURN lbr$_invrfa;
!
! Decrement ref. count in old module header
!
    perform (decr_refcnt (.oldrfa));
!
! Increment ref. count in new module header
!
    perform (incr_refcnt (.newrfa));
!
! Update index entry
!
    CH$MOVE (rfa$c_length, .newrfa, entry [idx$b_rfa]);
    mark_dirty (.vbn);				! Mark index block dirty
    END;
RETURN true
END;						! Of lbr$replace_key

%SBTTL  'LBR$DELETE_KEY';
GLOBAL ROUTINE lbr$delete_key (ctl_index, key_name) =

!---
!
!	Delete a specified key from the current primary index.
!
! Inputs:
!
!	ctl_index = Address of control table index.
!	key_name = Address of string desciptor or binary key.
!
! Outputs:
!
!	lbr$_libnotopn - library not open
!	lbr$_illctl - illegal control table index
!	lbr$_keynotfnd - key not found
!---

BEGIN

MAP
    key_name : REF BBLOCK;

LOCAL
    keydesc : BBLOCK [dsc$c_s_bln],
    keynambuf : BBLOCK [lbr$c_maxkeylen];

perform (validate_ctl (..ctl_index));	! Validate control table index
perform (check_lock ());		! Verify ability to modify index
keydesc [dsc$w_length] = .key_name [dsc$w_length];
keydesc [dsc$a_pointer] = keynambuf;
CH$MOVE (.key_name [dsc$w_length], 
	.key_name [dsc$a_pointer], .keydesc [dsc$a_pointer]);


perform (delete_key (keydesc));		! Delete the key
RETURN true
END;

%SBTTL  'delete_key';
GLOBAL ROUTINE delete_key (key_name) =

!---
!
!		Delete a key from the current primary index
!
! Inputs:
!
!	key_name = Address of string descriptor or binary key
!
! Outputs:
!
!---

BEGIN

LOCAL
    localrfa : BBLOCK[rfa$c_length];

BIND
    context = .lbr$gl_control[lbr$l_ctxptr] : BBLOCK;

IF .context[ctx$v_oldlib]			! Cannot modify old libraries
    OR .context [ctx$v_ronly]			!  or read only libraries
THEN
    RETURN lbr$_illop;

perform(lookup_key(.lbr$gl_control[lbr$l_curidx],
		.key_name, localrfa));

perform (remove_key (.lbr$gl_control [lbr$l_curidx], .key_name));

perform(decr_refcnt(localrfa));				!Decrement reference count

context[ctx$v_hdrdirty] = true;				!Flag header is dirty

RETURN true;

END;

%SBTTL  'LBR$GET_INDEX';
GLOBAL ROUTINE lbr$get_index (ctl_index, index, user_routine, match_desc) =

!---
!
!	Call a user-supplied routine for each key in the specified
!	primary index.
!
! Inputs:
!
!	ctl_index = Address of the control table index
!	index = Address of the primary index number
!	user_routine = Address of user action routine
!	match_desc = Address (optional) of string descriptor for matching
!
! Outputs:
!
!	The action routine is called once for each key in the index.
!
!	lbr$_libnotopn - library not open
!	lbr$_illctl - illegal control table index
!	lbr$_illidxnum - illegal index number
!---

BEGIN

MAP
    match_desc : REF BBLOCK;

LOCAL
    keydesc : BBLOCK [dsc$c_s_bln],
    keynambuf : BBLOCK [lbr$c_maxkeylen],
    wildcard;

BUILTIN
    NULLPARAMETER;		! True if argument unspecified

perform (validate_ctl (..ctl_index));	! Validate control table index

BEGIN
    BIND
	header = .lbr$gl_control [lbr$l_hdrptr] : BBLOCK, ! Address the library header
	context = .lbr$gl_control[lbr$l_ctxptr] : BBLOCK,
	index_desc = .lbr$gl_control[lbr$l_hdrptr] + lhd$c_idxdesc
		+ (.lbr$gl_control[lbr$l_curidx]-1)*idd$c_length : BBLOCK;

    IF ..index GTRU .header [lhd$b_nindex]	! If illegal index number,
    OR ..index EQL 0
    THEN
	RETURN lbr$_illidxnum;		! return with error

    wildcard = false;				! Assume no wildcards
    IF NOT NULLPARAMETER(4)			! If argument is present
	AND .match_desc [dsc$w_length] NEQ 0	!  and non-null
	AND .match_desc [dsc$a_pointer] NEQ 0	!   ...
	THEN BEGIN				! Then do wild card matching
	    wildcard = true;			! then there is a match descriptor
	    keydesc [dsc$w_length] = .match_desc [dsc$w_length];
	    keydesc [dsc$a_pointer] = keynambuf;
	    IF .index_desc [idd$v_nocasecmp] 
	    THEN
		CH$MOVE (.match_desc [dsc$w_length], 
			.match_desc [dsc$a_pointer], .keydesc [dsc$a_pointer])
	    ELSE
		perform (make_upper_case (.match_desc, keydesc, true));
	    END;

    context [ctx$v_found1] = false;		!Flag no matches found
    IF .context[ctx$v_oldlib]			! If old format library
    THEN perform (lbr_old_get_idx (..index, .user_routine, (IF .wildcard
								THEN .match_desc
								ELSE 0)))

    ELSE perform (traverse_keys (..index, (IF .wildcard		! Traverse the index
					THEN check_wild		! looking for matches
					ELSE call_user), .user_routine, ! or just calling user
				     (IF .wildcard
					THEN .match_desc
					ELSE 0)));
    IF NOT .context [ctx$v_found1]				!If no matches found
	THEN RETURN (IF .wildcard
			THEN lbr$_nomtchfou
			ELSE lbr$_nulidx
			)
	ELSE RETURN true;

    END;

END;								!Of lbr$get_index

%SBTTL  'LBR$SEARCH';
GLOBAL ROUTINE lbr$search (ctl_index, index, rfa, user_routine) =

!---
!
!	Search a specified primary index for all keys associated
!	with a given RFA.  The user supplied action routine will
!	be called for each key associated with the RFA.
!
! Inputs:
!
!	ctl_index = Address of the control table index
!	index = Address of the primary index number
!	rfa = Address of the RFA to be searched for
!	user_routine = Address of user supplied action routine.
!
! Outputs:
!
!	The action routine will be called for each key found.
!
!---

BEGIN

MAP
    rfa: REF BBLOCK;		! Access as RFA structure

ROUTINE check_rfa (entry, user_routine, index_desc, test_rfa) =
BEGIN
MAP
    test_rfa : REF BBLOCK[rfa$c_length],
    index_desc: REF BBLOCK,
    entry: REF BBLOCK;
IF .entry [idx$l_vbn] EQL .test_rfa [rfa$l_vbn]
    AND .entry [idx$w_offset] EQL .test_rfa [rfa$w_offset]
THEN
    perform (call_user (.entry, .user_routine, .index_desc));
RETURN true;
END;


perform (validate_ctl (..ctl_index));	! Validate control table index

BEGIN
    BIND
	context = .lbr$gl_control [lbr$l_ctxptr] : BBLOCK, ! Address the context block
	header = .lbr$gl_control [lbr$l_hdrptr] : BBLOCK; ! Address the library header

    IF ..index GTRU .header [lhd$b_nindex]	! If illegal index number,
    OR ..index EQL 0
    THEN
	RETURN lbr$_illidxnum;		! return with error

    IF .context[ctx$v_oldlib]		! If old format library
    THEN RETURN lbr_old_src_idx (..index, .rfa, .user_routine);

    perform (traverse_keys (..index, check_rfa, .user_routine, .rfa));
    END;

RETURN true;

END;

%SBTTL  'check_wild';
ROUTINE check_wild (entry, user_routine, index_desc, match_desc) =
BEGIN
!---
!	Called by traverse for each entry in the index.  Check to
!	see if current entry matches the match_desc.  Call user if so.
!
! Inputs:
!
!	entry = Address of key entry
!	user_routine = Address of user action routine
!	index_desc = Address of index descriptor for index
!	match_desc = string descriptor for match string
!
!---
MAP
    entry : REF BBLOCK,
    index_desc : REF BBLOCK,
    match_desc : REF BBLOCK;
LOCAL
    entrykey : BBLOCK [lbr$c_maxkeylen];

IF .index_desc [idd$v_upcasntry]
THEN
    BEGIN
    moveto_upper_case (.entry [idx$b_keylen], entry [idx$t_keyname], entrykey)
    END
ELSE
    CH$MOVE (.entry [idx$b_keylen], entry [idx$t_keyname], entrykey);

IF (NOT .index_desc [idd$v_ascii]		! If not ASCII keys
 OR (fmg$match_name (.entry [idx$b_keylen], entrykey,
			.match_desc [dsc$w_length],
			.match_desc [dsc$a_pointer])
	OR CH$EQL (.match_desc [dsc$w_length], entrykey,
			.match_desc [dsc$w_length],
			.match_desc [dsc$a_pointer])))
    THEN perform (call_user (.entry, .user_routine, .index_desc, .match_desc));
RETURN true
END;						!Of check_wild

%SBTTL  'call_user';
ROUTINE call_user (entry, user_routine, index_desc, rfa) =

!---
!
!	This routine is used as an action routine by GET_INDEX
!	and SEARCH to call the user with a standard argument
!	list for a given key entry.
!
! Inputs:
!
!	entry = Address of key entry
!	user_routine = Address of user action routine
!	index = Primary index number
!
! Outputs:
!
!	The user routine is called with the following arguments:
!		1) If ascii keys, address of key descriptor
!		   If binary keys, address of longword key
!		2) Address of RFA associated with the key
!---

BEGIN

MAP
    index_desc: REF BBLOCK,		! Address of index descriptor
    entry: REF BBLOCK;			! Address of key entry

BIND
    context = .lbr$gl_control [lbr$l_ctxptr] : BBLOCK;

context [ctx$v_found1] = true;		! Flag match found
IF .index_desc [idd$v_ascii]		! If ASCII keys,
THEN
    BEGIN
    LOCAL desc: BBLOCK [dsc$c_s_bln];	! String descriptor
    desc [dsc$w_length] = .entry [idx$b_keylen];
    desc [dsc$a_pointer] = entry [idx$t_keyname];
    perform ((.user_routine) (desc, entry [idx$l_vbn])); ! Call user back
    END
ELSE
    perform ((.user_routine) (entry [idx$l_keyid], entry [idx$l_vbn]));

RETURN true;

END;

%SBTTL  'add_key';
GLOBAL ROUTINE add_key (index, key_desc, key_rfa, stop_vbn) =
!---
!
!	This routine adds a key to a specified index.  If the index
!	block is full, the block is split and a parent index block
!	is created and is made to point to the 2 split index blocks.
!
! Inputs:
!
!	index = Primary index number in which key is to be added.
!	key_desc = Descriptor of key (ascii or binary) to be added.
!	key_rfa = RFA to be associated with key.
!	stop_vbn = (Optional) The VBN of an index block in the
!			index tree into which the key should be added.
!			If not specified, key added at bottom of tree.
!
! Outputs:
!
!	Routine value = Success/failure status code
!
!---
BEGIN

MAP
    key_desc: REF BBLOCK,		! Access as string descriptor
    key_rfa: REF BBLOCK;		! Access as RFA structure

LOCAL
    status,
    index_desc: REF BBLOCK,		! Index descriptor
    entry_size,				! Size of each index entry
    index_block1: REF BBLOCK,		! Address of index block
    vbn1,				! VBN of current index block
    genpos,				! Offset to closest entry
    addpos;				! Offset where to add key

BUILTIN
    NULLPARAMETER;		! True if argument unspecified

MACRO
    entry (address,b) =
	(address+index$c_entries+b)
	%IF %LENGTH GTR 2 %THEN <%REMAINING> %ELSE <0,0,0> %FI%;

index_desc = .lbr$gl_control [lbr$l_hdrptr] + lhd$c_idxdesc
		+ (.index-1)*idd$c_length;
!
!   Use false option to check keyword and remove trailing blanks
!
perform (make_upper_case (.key_desc, .key_desc, false));
!
!	Check for illegal key length if ASCII keys
!
IF .index_desc [idd$v_ascii]
THEN
    IF ((.key_desc [dsc$w_length] GTR .index_desc [idd$w_keylen]) ! If name too long
	OR (.key_desc [dsc$w_length] EQL 0))			 !  or zero length name
    THEN
	RETURN lbr$_invkey;					 ! Then return with an error
!
!	If no primary index block exists yet, create the block.
!
IF .index_desc [idd$l_vbn] EQL 0	! If no primary index block yet,
THEN
    BEGIN
    perform(create_index(vbn1, index_block1));	! Create index block
    index_desc [idd$l_vbn] = .vbn1;	! Set as root of tree
    index_block1 [index$l_parent] = 0;	! Set backward link
    END;
!
!	Find the key in the index tree.
!
status = find_key(.index, .key_desc,
	(IF NOT NULLPARAMETER(4) THEN .stop_vbn ELSE 0),
	vbn1, index_block1, genpos, addpos);
!
!	If key found, return duplicate key
!
IF .status				! If found,
THEN
    RETURN lbr$_dupkey;			! Return duplicate key
!
!	If the current block is full, split the index block into
!	2 blocks and create a parent index block if necessary.
!
IF .index_desc [idd$v_varlenidx]
THEN
    entry_size = idx$c_rfaplsbyt + .key_desc[dsc$w_length]
ELSE
    entry_size = idx$c_length + .index_desc [idd$w_keylen];

IF .index_block1 [index$w_used] + .entry_size GTRU index$c_blksiz
THEN
    BEGIN
    LOCAL
        cur_entry : REF BBLOCK,		! step through index entry at a time
	last_entry,
	last_used,			! location of last used byte in index block
        move_length,			! Length of half the block
	ptr,
        index_block2: REF BBLOCK,	! Address of second block
        vbn2,				! VBN of second block
	rfa2: BBLOCK[rfa$c_length];	! RFA used by add_key

    !
    ! Create second index and copy about a quarter of the entries into it.
    !

    perform(create_index(vbn2, index_block2)); ! Allocate index block

    IF .index_desc [idd$v_varlenidx]
    THEN		! variable length keyword storage
        BEGIN
        cur_entry = .index_block1 + index$c_entries;
        last_used = .index_block1 + index$c_entries + .index_block1 [index$w_used]; 
	DO
            BEGIN
            LOCAL
                entry_len;		! length of variable index entry in index block
            last_entry = .cur_entry;
            entry_len = idx$c_rfaplsbyt + .cur_entry[idx$b_keylen];
	    cur_entry = .cur_entry + .entry_len;
	    END
        UNTIL (.cur_entry + lbr$c_maxkeylen )
		 GTR (.index_block1 + index$c_blksiz );
        move_length = .last_used - .last_entry;


        index_block1 [index$w_used] =
	    .index_block1 [index$w_used] - .move_length;
        index_block2 [index$w_used] = .move_length;
        CH$MOVE(.move_length,		! Copy half the block
	    entry(.index_block1+.index_block1 [index$w_used],0),
	    entry(.index_block2,0));

        reset_highest2(.index,.index_desc,.vbn1,.index_block1); ! Reset highest key
        END
    ELSE		! fixed length keyword storage
        BEGIN
	!
	!    Move the last fourth of the entries
	!
        move_length = (.index_block1 [index$w_used] / .entry_size / 4)	! ***
			* .entry_size;
	!
	!    If the keyword size is so large that fewer than four keywords fit
	!    in an index block, then only move out 1 entry.
	!
	IF .move_length EQL 0 THEN move_length = .entry_size;
        index_block1 [index$w_used] =
            .index_block1 [index$w_used] - .move_length;
        index_block2 [index$w_used] = .move_length;
        CH$MOVE(.move_length,		! Copy 3/4 of the block
            entry(.index_block1+.index_block1 [index$w_used],0),
            entry(.index_block2,0));

        reset_highest(.index_desc,.vbn1,.index_block1); ! Reset highest key
        END;

    IF .index_block1 [index$l_parent] EQL 0 ! If at top of tree already,
    THEN
        BEGIN
	!
	! Create a parent block for the 2 index blocks.
	!
        LOCAL
            index_block0: REF BBLOCK,	! Address of parent block
            vbn0;			! VBN of parent block

        perform(create_index(vbn0, index_block0)); ! Create parent

        index_block0 [index$l_parent] = .index_block1 [index$l_parent];
        index_block1 [index$l_parent] = .vbn0;
	IF .index_block0 [index$l_parent] EQL 0	! If root of tree
	THEN
	    index_desc [idd$l_vbn] = .vbn0;	! Reset root pointer

        IF .index_desc [idd$v_varlenidx]
        THEN
	    perform( add_index2(.index, .vbn1, .index_block1) )
        ELSE
	    perform( add_index(.index, .vbn1, .index_block1) );
					! Add highest key to parent
	END;

    index_block2 [index$l_parent] = .index_block1 [index$l_parent];

    IF .index_desc [idd$v_varlenidx]
    THEN
	BEGIN
        perform( add_index2(.index, .vbn2, .index_block2) );! Add key to parent
	!
	!	If any of the entries which were moved into the second
	!	block pointed to sub-indices, reset the parent backpointer
	!	in that sub-index to point to the second block (vbn2).
	!
        ptr = .index_block2 + index$c_entries;
	last_used = .index_block2+ index$c_entries +.index_block2[index$w_used];
        WHILE .ptr LSS .last_used DO
	    BEGIN
	    MAP
	        ptr: REF BBLOCK;		! Address index entry
	    IF .ptr [idx$w_offset] EQL rfa$c_index ! If points to index,
	    THEN
	        BEGIN
	        LOCAL block: REF BBLOCK;
	        perform(find_index(.ptr [idx$l_vbn], block));
	        block [index$l_parent] = .vbn2;	! Reset parent block
	        mark_dirty(.ptr [idx$l_vbn]);	! Mark block dirty
	        END;
	    ptr = .ptr + idx$c_rfaplsbyt + .ptr[idx$b_keylen];
	    END;
        END
    ELSE
        BEGIN
        perform( add_index(.index, .vbn2, .index_block2) );! Add key to parent
	!
	!	If any of the entries which were moved into the second
	!	block pointed to sub-indices, reset the parent backpointer
	!	in that sub-index to point to the second block (vbn2).
	!
        INCRU ptr FROM .index_block2+index$c_entries
	    TO .index_block2+index$c_entries+.index_block2 [index$w_used]-1
	    BY .entry_size
        DO
	    BEGIN
	    MAP
	        ptr: REF BBLOCK;		! Address index entry
	    IF .ptr [idx$w_offset] EQL rfa$c_index ! If points to index,
	    THEN
	        BEGIN
	        LOCAL block: REF BBLOCK;
	        perform(find_index(.ptr [idx$l_vbn], block));
	        block [index$l_parent] = .vbn2;	! Reset parent block
	        mark_dirty(.ptr [idx$l_vbn]);	! Mark block dirty
	        END;
	    END;
        END;
!
!	If the add position was in the second half of the
!	split block, then reset index_block1 and vbn1 so
!	that the following code adds the key to the second
!	block.  In addition, if we are adding a subindex key,
!	then adjust the parent block of that subindex to point
!	to this newly split second block rather than the original
!	first block.  Adjust the add offset for the second block.
!
    IF .addpos GTRU .index_block1 [index$w_used] ! If in 2nd half,
    THEN
	BEGIN
	IF .key_rfa [rfa$w_offset] EQL rfa$c_index ! If index pointer,
	THEN
	    BEGIN
	    LOCAL block: REF BBLOCK;
	    perform(find_index(.key_rfa [rfa$l_vbn], block));
	    block [index$l_parent] = .vbn2;	! Reset parent block
	    mark_dirty(.key_rfa [rfa$l_vbn]);	! Mark block modified
	    END;

	mark_dirty(.vbn1);		! Mark block 1 modified now
					! since 2 will be marked below
        addpos = .addpos - .index_block1 [index$w_used]; ! Adjust offset
	index_block1 = .index_block2;	! Add key to second block
	vbn1 = .vbn2;
	END;

    END;
!
!	Make room for new entry by pushing all
!	the following entries in use down one.
!
CH$MOVE(.index_block1 [index$w_used] - .addpos,
    entry(.index_block1+.addpos,0),
    entry(.index_block1+.addpos+.entry_size,0));
index_block1 [index$w_used] = .index_block1 [index$w_used]+.entry_size;
!
!	Add the key to the index
!
entry(.index_block1+.addpos,idx$l_vbn) = .key_rfa [rfa$l_vbn];
entry(.index_block1+.addpos,idx$w_offset) = .key_rfa [rfa$w_offset];

IF .index_desc [idd$v_ascii]		! If ASCII keys,
THEN
    BEGIN
    !
    !   If keywords in this index are to be upper cased for 
    !   entry then upcase.
    !
    IF NOT .index_desc [idd$v_nocasentr] 
    THEN perform (make_upper_case (.key_desc, .key_desc, true));

    CH$MOVE(.key_desc [dsc$w_length],	! Copy ASCII key
	.key_desc [dsc$a_pointer],
	entry(.index_block1+.addpos,idx$t_keyname));
    entry(.index_block1+.addpos,idx$b_keylen) =
	.key_desc [dsc$w_length];
    END
ELSE					! If binary keys,
    entry(.index_block1+.addpos,idx$l_keyid) =
	..key_desc;
!
!	Mark index block modified to be written back later.
!
mark_dirty(.vbn1);		! Mark index block modified
!
!	Reset highest keys in parent index blocks.
!
IF .addpos+.entry_size EQL .index_block1 [index$w_used]
THEN
    IF .index_desc[idd$v_varlenidx] !	If index block has variable length keys
    THEN
        perform( reset_highest2 (.index, .index_desc, .vbn1, .index_block1))
    ELSE
        perform( reset_highest (.index_desc, .vbn1, .index_block1) );

!
! Unless the entry points to an index, update the index entry total
!
BEGIN
    BIND
	header = .lbr$gl_control[lbr$l_hdrptr] : BBLOCK;

    IF .key_rfa[rfa$w_offset] NEQ rfa$c_index
    THEN BEGIN
	header[lhd$l_idxcnt] = .header[lhd$l_idxcnt] + 1;

	IF .index EQL 1				! If index 1
	    THEN header[lhd$l_modcnt] = .header[lhd$l_modcnt] + 1;
	END
       ELSE header [lhd$l_idxovh] = .header [lhd$l_idxovh] + 1;	! Count overhead block
END;

RETURN true;
END;

%SBTTL  'remove_key';
GLOBAL ROUTINE remove_key (index, key_desc, stop_vbn) =

!---
!
!	Delete a key from a specified primary index.
!
! Inputs:
!
!	index = Primary index number
!	key_desc = Descriptor of key if ASCII, else binary key.
!	stop_vbn (optional) = VBN of index block containing key.
!
! Outputs:
!
!	The key is deleted from the index if it exists.
!
!	true		key was found and deleted.
!	lbr$_keynotfnd	key was not found
!---

BEGIN

MAP
    key_desc: REF BBLOCK;

LOCAL
    index_desc: REF BBLOCK,		! Index descriptor
    vbn,				! VBN of index block
    index_block: REF BBLOCK,		! Address of index block
    entry: REF BBLOCK,			! Address key entry
    offset,				! Offset to key entry
    addpos,				! Offset to add position
    index_ptr,				! True if deleteing index pointer entry
    entry_size;				! Size of each entry

BUILTIN
    NULLPARAMETER;		! True if argument unspecified

!
!	Find the entry describing the key.
!
perform (find_key (.index, .key_desc,
	(IF NOT NULLPARAMETER(3) THEN .stop_vbn ELSE 0),
		vbn, index_block, offset, addpos));
!
!	Push down all following entries in the block.
!
index_desc = .lbr$gl_control [lbr$l_hdrptr] + lhd$c_idxdesc
		+ (.index-1)*idd$c_length; 

IF .index_desc[idd$v_varlenidx] !	If index block has variable length keys
THEN
    entry_size = idx$c_rfaplsbyt + .key_desc [dsc$w_length]
ELSE
    entry_size = idx$c_length + .index_desc [idd$w_keylen];

entry = .index_block + index$c_entries + .offset;
index_ptr = (.entry[rfa$w_offset] EQL rfa$c_index);

index_block [index$w_used] = .index_block [index$w_used] - .entry_size;
CH$MOVE(.index_block [index$w_used] - .offset,
	.entry+.entry_size,
	.entry);
!
!	If the block becomes empty, remove it from the tree.
!
IF .index_block [index$w_used] EQL 0
THEN
    BEGIN
    IF .index_block [index$l_parent] EQL 0	! If root of tree,
    THEN
	index_desc [idd$l_vbn] = 0	! Reset tree header
    ELSE
        remove_key(.index,		! Else, remove parent pointer
	    .key_desc, .index_block [index$l_parent]);
    delete_index(.vbn);		! Deallocate index block
    END
ELSE
    BEGIN
    mark_dirty(.vbn);		! Mark block modified
    IF .index_desc[idd$v_varlenidx] !	If index block has variable length keys
    THEN
        reset_highest2(.index, .index_desc, .vbn, .index_block)
    ELSE
        reset_highest(.index_desc, .vbn, .index_block);
    END;
!
! Unless we just removed an index pointer, update index totals in header
!
BEGIN
    BIND
	header = .lbr$gl_control[lbr$l_hdrptr] : BBLOCK;

    IF NOT .index_ptr
    THEN BEGIN
	IF .index EQL 1
	    THEN header[lhd$l_modcnt] = .header[lhd$l_modcnt] -1;
	header[lhd$l_idxcnt] = .header[lhd$l_idxcnt] -1;
	END
    ELSE header [lhd$l_idxovh] = .header [lhd$l_idxovh] - 1;
END;

RETURN true;

END;

%SBTTL  'lookup_key';
GLOBAL ROUTINE lookup_key (index, key_desc, retrfa) =

!---
!
!	Look up a given key and return the RFA associated with
!	the key, if found.
!
! Inputs:
!
!	index = Primary index number
!	key_desc = Descriptor of key if ASCII, else binary key.
!	retadr = Longword to receive key entry address.
!	retvbn (optional) = Longword to receive VBN of index block.
!
! Outputs:
!
!	retadr = Address of key entry if found.
!
!	true		if key found
!	lbr$_keynotfnd	if key not found
!
!---

BEGIN

MAP
    retrfa: REF BBLOCK;		! Address as RFA structure

LOCAL
    vbn,			! VBN of index block
    index_block: REF BBLOCK,	! Address of index block
    offset,			! Offset to key entry
    addpos,			! Offset to add position
    entry: REF BBLOCK;		! Address of key entry

BUILTIN
    NULLPARAMETER;		! True if argument unspecified

perform (find_key (.index, .key_desc, 0,
		 vbn, index_block, offset, addpos));

entry = .index_block + index$c_entries + .offset;

IF NOT NULLPARAMETER(3)
THEN BEGIN
    retrfa [rfa$l_vbn] = .entry [idx$l_vbn];
    retrfa [rfa$w_offset] = .entry [idx$w_offset];
    END;

RETURN true;

END;

%SBTTL  'traverse_keys';
GLOBAL ROUTINE traverse_keys (index, action_routine, user_routine, rfa) =

!---
!
!	Traverse a specified primary index in key order
!	calling a user action routine for each key.
!
! Inputs:
!
!	index = Primary index numebr
!	action_routine = Address of internal action routine
!	user_routine = Address of user action routine
!	rfa = RFA to pass to action routine
!
! Outputs:
!
!	The user routine is called with the following arguments:
!		1) Address of key entry
!
!---

BEGIN

ROUTINE traverse (index_desc, vbn, action_routine, user_routine, txtrfa) =
BEGIN
!
!	Scan all entries in the given index block.
!
MAP
    index_desc: REF BBLOCK;	! Index descriptor

LOCAL
    index_block: REF BBLOCK;	! Index block address

perform (find_index (.vbn, index_block));

INCRU entry FROM .index_block+index$c_entries
	TO .index_block+index$c_entries+.index_block[index$w_used]-1
	BY idx$c_length + .index_desc [idd$w_keylen]
DO
    BEGIN
    MAP entry: REF BBLOCK;
    IF .entry [idx$w_offset] EQL rfa$c_index	! If subindex,
    THEN
	perform (traverse (.index_desc, .entry [idx$l_vbn],
		.action_routine, .user_routine, .txtrfa))
    ELSE
	perform((.action_routine)(.entry, .user_routine, .index_desc, .txtrfa));
    END;

RETURN true;
END;

ROUTINE traverse2 (index_desc, vbn, action_routine, user_routine, txtrfa) =
BEGIN
!
!	Traverse2 handles indices with variable length keywords.
!	Scan all entries in the given index block.
!
MAP
    index_desc: REF BBLOCK;	! Index descriptor

LOCAL
    entry,			! Traverse each entry in index block
    index_block: REF BBLOCK;	! Index block address

perform (find_index (.vbn, index_block));

entry = .index_block+index$c_entries;
WHILE .entry LSS .index_block+index$c_entries+.index_block[index$w_used]-1 DO
    BEGIN
    MAP entry: REF BBLOCK;
    IF .entry [idx$w_offset] EQL rfa$c_index	! If subindex,
    THEN
	perform (traverse2 (.index_desc, .entry [idx$l_vbn],
		.action_routine, .user_routine, .txtrfa))
    ELSE
	perform((.action_routine)(.entry, .user_routine, .index_desc, .txtrfa));
    entry = .entry + idx$c_rfaplsbyt + .entry [idx$b_keylen];
    END;

RETURN true;
END;
!
!	Main body of traverse_keys procedure
!
LOCAL
    index_desc: REF BBLOCK;		! Index descriptor

index_desc = .lbr$gl_control [lbr$l_hdrptr] + lhd$c_idxdesc
		+ (.index-1)*idd$c_length;

IF .index_desc [idd$l_vbn] EQL 0	! If empty index,
THEN
    RETURN true;			! return immediately

!
! Set the lock for the index
!
index_desc [idd$v_locked] = true;

IF .index_desc[idd$v_varlenidx] !	If index block has variable length keys
THEN
    traverse2(.index_desc, .index_desc [idd$l_vbn],
		.action_routine,.user_routine, .rfa)
ELSE
    traverse(.index_desc, .index_desc [idd$l_vbn],
		.action_routine,.user_routine, .rfa);
!
! Clear the lock
!
index_desc [idd$v_locked] = false;

RETURN true;

END;

%SBTTL  'find_key';
GLOBAL ROUTINE find_key (index, key_desc, stop_vbn,
		retvbn, retblkadr, retgenpos, retaddpos) =
!---
!
!	Find a given key and return all information concerning
!	its position within the index tree.  This routine is
!	used solely by routines such as add_key, remove_key,
!	etc. for the common key search processing.
!
! Inputs:
!
!	index = Primary index number
!	key_desc = Descriptor of key if ASCII, else binary key.
!	stop_vbn = VBN of specific index block, 0 if bottom of tree.
!	retvbn = Longword to receive VBN of index block.
!	retblkadr = Longword to receive address of index block.
!	retgenpos = Longword to receive offset to generic entry.
!	retaddpos = Longword to receive offset to add position.
!
! Outputs:
!
!	retvbn = VBN of index block.
!	retblkadr = Address of index block.
!	retgenpos = Offset to generically closest key entry.
!	retaddpos = Offset to position to add key.
!
!	true		if key found
!	false		if key not found
!---

BEGIN

MAP
    key_desc: REF BBLOCK;		! Access as string descriptor

LOCAL
    status,
    keydesc : BBLOCK [dsc$c_s_bln],
    keynambuf : BBLOCK [lbr$c_maxkeylen],
    index_desc: REF BBLOCK,		! Index descriptor
    index_block: REF BBLOCK,		! Address of index block
    vbn,				! VBN of current index block
    offset,				! Offset to closest entry
    addpos;				! Offset to add position

MACRO
    entry (address,b) =
	(address+index$c_entries+b)
	%IF %LENGTH GTR 2 %THEN <%REMAINING> %ELSE <0,0,0> %FI%;

index_desc = .lbr$gl_control [lbr$l_hdrptr] + lhd$c_idxdesc
		+ (.index-1)*idd$c_length;
!
!	Get address of primary index block
!
vbn = .index_desc [idd$l_vbn];			! Top of tree
!
!	If no primary index block exists yet, key not found.
!
IF .vbn EQL 0			! If no primary index block yet,
THEN
    RETURN lbr$_keynotfnd;	! Return key not found

keydesc = 0;
keydesc [dsc$w_length] = .key_desc [dsc$w_length];
keydesc [dsc$a_pointer] = keynambuf;
!
!   If keywords in this index are to be upper cased for comparison then upcase
!
IF NOT .index_desc [idd$v_nocasecmp] 
THEN perform (make_upper_case (.key_desc, keydesc, true))
ELSE
    BEGIN
    CH$MOVE (.key_desc [dsc$w_length], .key_desc [dsc$a_pointer],
		.keydesc [dsc$a_pointer]);
    END;

!
!	If a specific index VBN was specified, start there
!
IF .stop_vbn NEQ 0		! If specified,
THEN
    vbn = .stop_vbn;		! then use it
!
!	Search down the subtree until either the bottom is
!	reached or an error is detected.
!
DO BEGIN
    !
    !	Locate the index block to be searched.  It will either
    !	find the block in the index cache or it will be read
    !	from disk and cached.
    !
    perform(find_index(.vbn, index_block));
    !
    !	Search for position of key within index block.
    !
    IF .index_desc[idd$v_varlenidx] !	If index block has variable length keys
    THEN
        status = key_search2(.index_desc,.index_block,keydesc,
			offset, addpos)
    ELSE
        status = key_search(.index_desc,.index_block,keydesc,
			offset, addpos);
    !
    !	If a specific index block was specified, then stop the search.
    !
    IF .stop_vbn EQL .vbn		! If at specified block,
    THEN
	EXITLOOP;			! then stop search
    !
    !	If the entry found by the binary search points to another
    !	index, then continue searching using that index.  If it
    !	points to an actual data record, then we have reached the
    !	bottom of the tree and the search is stopped.
    !
    IF .offset LSS 0			! If no closest entry,
        OR .entry(.index_block+.offset,idx$w_offset) NEQ rfa$c_index
    THEN
	EXITLOOP;			! Then stop search

    vbn = .entry(.index_block+.offset,idx$l_vbn); ! Next index
    END

    UNTIL false;			! Loop until EXITLOOP

!
!	Return index block VBN, address and entry offsets.
!
.retvbn = .vbn;
.retblkadr = .index_block;		! Return block address
.retgenpos = .offset;			! Return offset to entry
.retaddpos = .addpos;			! Return offset to add position

IF NOT .status				! If key not found,
THEN
    RETURN lbr$_keynotfnd;		! Return key not found

RETURN true;				! Return successful

END;

%SBTTL  'key_search';
ROUTINE key_search (index_desc, index_block, key_desc, genpos, addpos) =

!---
!
!	This routine searches a specified index block using a binary
!	search and returns the position (offset) within the block
!	where the key should be added (if not found) or its exact
!	position (if found).
!
!	It is also used to run down the index tree to find a given
!	key by searching each index block and using the key found
!	generically using this routine to get to the next index block
!	to be searched (the child).
!
! Inputs:
!
!	index_desc = Primary index descriptor
!	index_block = Address of the index block
!	key_desc = String descriptor of the key
!	genpos = Longword to receieve offset to the entry which is
!			most generically close to the key.
!	addpos (optional) = Longword to receieve offset to position
!			where the key should be added in the block.
!
! Outputs:
!
!	genpos = Offset to generically closest entry.
!	addpos (if specified) = Offset to position to add key.
!
!	Routine value = true if key found, else false.
!---

BEGIN

MAP
    index_desc: REF BBLOCK,		! Index descriptor
    index_block:	REF BBLOCK,	! Address of index block
    key_desc:		REF BBLOCK;	! String descriptor

LOCAL
    entry_size,				! Size of each index entry
    test,				! -1 (LSS), 0 (EQL), 1 (GTR)
    min,				! Lower search limit
    max,				! Upper search limit
    i;					! Current entry being searched

BUILTIN
    NULLPARAMETER;		! True if argument unspecified

MACRO
    entry (i,b,p,s,e) =
	index_block [index$c_entries+(i-1)*.entry_size+b,p,s,e]%;

entry_size = idx$c_length + .index_desc [idd$w_keylen];
min = 1;				! Set min and max limits
max = .index_block [index$w_used]/.entry_size;

IF .max EQL 0				! If null index block,
THEN
    BEGIN
    i = 1;				! Add at 1st slot
    test = -1;				! No adjustment, key not found
    END
ELSE
DO
    BEGIN
    i = (.min+.max) / 2;		! Calculate middle entry
    IF .index_desc [idd$v_ascii]	! If ASCII keys,
    THEN
	BEGIN
	IF .index_desc [idd$v_upcasntry]
	THEN
	    BEGIN
	    LOCAL
		entrynambuf : BBLOCK [lbr$c_maxkeylen];

	    moveto_upper_case ( .entry [.i,idx$b_keylen], 
			entry [.i,idx$t_keyname], entrynambuf);
            test = CH$COMPARE(.key_desc [dsc$w_length], ! Compare ASCII keys
		.key_desc [dsc$a_pointer],
		.entry [.i,idx$b_keylen], 
		entrynambuf, 0);
	    END
	ELSE
            test = CH$COMPARE(.key_desc [dsc$w_length], ! Compare ASCII keys
		.key_desc [dsc$a_pointer],
		.entry [.i,idx$b_keylen],
		entry [.i,idx$t_keyname],0);
	END
    ELSE
	test = ..key_desc - .entry [.i, idx$l_keyid];
    IF .test GTR 0
    THEN
	min = .i+1			! Set to upper half
    ELSE
	max = .i-1;			! Set to lower half
    END

    UNTIL (.test EQL 0) OR (.min GTR .max);

IF .test GTR 0				! If greater than last key
THEN
    i = .i+1;				! then point after last key

IF NOT NULLPARAMETER(5)			! If add position specified,
THEN
    .addpos = (.i-1) * .entry_size;	! Return offset where to add key
!
!	If the add position points past the end of the block,
!	then adjust the closest entry to point to the last entry
!	in the block so that add_key has a block to insert the
!	key into.  Note that if the block is empty, return -1.
!
.genpos = (.i-1) * .entry_size;		! Return offset to closest entry
IF ..genpos GEQU .index_block [index$w_used] ! If over block,
THEN
    .genpos = ..genpos - .entry_size;	! Set to last entry in block

RETURN .test EQL 0;			! True if key found

END;

%SBTTL  'key_search2';
ROUTINE key_search2 (index_desc, index_block, key_desc, genpos, addpos) =

!---
!
!	Key_search2 is a modified key_search to handle indices with 
!	variable length keywords.
!	This routine searches a specified index block using a sequential
!	search and returns the position (offset) within the block
!	where the key should be added (if not found) or its exact
!	position (if found).
!
!	It is also used to run down the index tree to find a given
!	key by searching each index block and using the key found
!	generically using this routine to get to the next index block
!	to be searched (the child).
!
! Inputs:
!
!	index_desc = Primary index descriptor
!	index_block = Address of the index block
!	key_desc = String descriptor of the key
!	genpos = Longword to receieve offset to the entry which is
!			most generically close to the key.
!	addpos (optional) = Longword to receieve offset to position
!			where the key should be added in the block.
!
! Outputs:
!
!	genpos = Offset to generically closest entry.
!	addpos (if specified) = Offset to position to add key.
!
!	Routine value = true if key found, else false.
!---

BEGIN

MAP
    index_desc: REF BBLOCK,		! Index descriptor
    index_block:	REF BBLOCK,	! Address of index block
    key_desc:		REF BBLOCK;	! String descriptor

LOCAL
    entry_size,				! Size of each index entry
    test,				! -1 (LSS), 0 (EQL), 1 (GTR)
    max,				! offset to end of used index
    last_entry,				! offset to last entry examined
    cur_entry;				! offset to current entry examined

BUILTIN
    NULLPARAMETER;		! True if argument unspecified

MACRO
    entry (i,b,p,s,e) =
	index_block [index$c_entries+i+b,p,s,e]%;

IF NOT .index_desc [idd$v_ascii]	! If not ASCII keys,
THEN 
    RETURN lbr$_intrnlerr;		! key_search2 only for ASCII keys

max = .index_block [index$w_used];
test = 1;				! Pre set to key not found
last_entry = 0;				! pre_set to first entry
cur_entry = 0;				! pre_set to first entry

IF .max EQL 0				! If null index block,
THEN
    BEGIN
    test = -1;
    END
ELSE
    BEGIN
    WHILE (.test GTR 0) AND (.cur_entry LSS .max) DO
	BEGIN
	IF .index_desc [idd$v_upcasntry]
	THEN
	    BEGIN
	    LOCAL
		entrynambuf : BBLOCK [lbr$c_maxkeylen];

	    moveto_upper_case (.entry [.cur_entry,idx$b_keylen],
			 entry [.cur_entry,idx$t_keyname], entrynambuf);

            test = CH$COMPARE(.key_desc [dsc$w_length], ! Compare ASCII keys
		.key_desc [dsc$a_pointer],
		.entry [.cur_entry,idx$b_keylen],
		entrynambuf, 0)
	    END
	ELSE
            test = CH$COMPARE(.key_desc [dsc$w_length], ! Compare ASCII keys
		.key_desc [dsc$a_pointer],
		.entry [.cur_entry,idx$b_keylen],
		entry [.cur_entry,idx$t_keyname],0);
        IF (.test GTR  0)
	THEN
	    BEGIN
	    last_entry = .cur_entry;
            cur_entry = .cur_entry + idx$c_rfaplsbyt + .entry[.cur_entry,idx$b_keylen];
            END;
        END;		! While
    END;

IF NOT NULLPARAMETER(5)			! If add position specified,
THEN
    .addpos = .cur_entry;	! Return offset where to add key
!
!	If the add position points past the end of the block,
!	then adjust the closest entry to point to the last entry
!	in the block so that add_key has a block to insert the
!	key into.  Note that if the block is empty, return -1.
!
.genpos = .cur_entry;		! Return offset to closest entry
IF ..genpos GEQU .index_block [index$w_used] ! If over block,
THEN
    .genpos = .last_entry;	! Set to last entry in block

RETURN .test EQL 0;			! True if key found

END;

%SBTTL  'find_index';
GLOBAL ROUTINE find_index (vbn, address) : JSB_2 =

!---
!	This routine locates a specific block in the library
!	file and returns the address of the block in memory
!	If the block is not currently cached in memory, it
!	will be automatically read from disk and added to the
!	cache.
!
! Inputs:
!
!	vbn = requested block number in file
!	address = Longword to receive address of block
!
! Outputs:
!
!	address = Address of block in memory
!---

BEGIN

BIND
    header = .lbr$gl_control[lbr$l_hdrptr] : BBLOCK;

LOCAL
    status,
    cache_entry: REF BBLOCK;		! Current cache entry address

status = lookup_cache(.vbn, cache_entry); ! Lookup block in cache

IF .status				! If found,
THEN
    BEGIN
    .address = .cache_entry [cache$l_address];	! Return address
    RETURN true;
    END;

!
! Attempt to read in multiple blocks if vbn is in the pre-allocated index
!
IF .vbn LEQU .header[lhd$l_hiprusd]
THEN BEGIN
    perform (read_n_block (.vbn, MIN (.lbr$gl_maxidxrd, !Read in some index blocks
			(.header [lhd$l_hiprusd] - .vbn + 1))));
    perform(find_index(.vbn, .address));	!Recurse to lookup in cache
    END
ELSE BEGIN
    perform(read_block(.vbn,.address));	! Read from disk

    perform (add_cache (.vbn, cache_entry));! Add cache list entry
    cache_entry [cache$l_address] = ..address;

    END;

RETURN true;

END;

%SBTTL  'create_index';
ROUTINE create_index (vbn, address) =
!---
!
!	This routine allocates a new index block in the file,
!	initializes it, and returns the rfa and address.
!
! Inputs:
!
!	None
!
! Outputs:
!
!	vbn = VBN of newly allocated index block
!	address = Address of index block in memory
!---

BEGIN

BIND
    context = .lbr$gl_control[lbr$l_ctxptr] : BBLOCK,
    header = .lbr$gl_control[lbr$l_hdrptr] : BBLOCK;

LOCAL
    cache_entry: REF BBLOCK;	! New cache entry address

!
! Allocate block from index cache if possible
!
IF .header[lhd$l_freeidx] NEQ 0
THEN BEGIN
    LOCAL
	buffer : REF VECTOR[,LONG];

    perform(find_block(.header[lhd$l_freeidx], .address, cache_entry));
    buffer = ..address;
    .vbn = .header[lhd$l_freeidx];
    header[lhd$l_freeidx] = .buffer[0];
    CH$FILL(0, idx$c_length, .buffer);
    header[lhd$l_freidxblk] = .header[lhd$l_freidxblk] - 1;
    IF ..vbn GTRU .header[lhd$l_hiprusd]
	THEN header[lhd$l_hiprusd] = ..vbn;
    END
ELSE BEGIN
    perform(alloc_block(.vbn, .address));	! Allocate a disk block
!
!	Add the allocated block to the index cache
!
    perform (add_cache (..vbn, cache_entry));! Add block to cache list
    cache_entry [cache$l_address] = ..address;
!
!	Initialize the index block
!
    BEGIN
	BIND
	    index_block = ..address: BBLOCK;	! Address index block

	index_block [index$w_used] = 0;		! No space used initially
    END;
END;
mark_dirty(..vbn);			! Mark index block modified

header[lhd$l_idxblks] = .header[lhd$l_idxblks] + 1;	! Count another index block

context [ctx$v_hdrdirty] = true;		! Mark header dirty

RETURN true;

END;

%SBTTL  'delete_index';
ROUTINE delete_index (vbn) =

!---
!
!	Deallocate the memory used by an index block and
!	remove the cache entry.
!
! Inputs:
!
!	vbn = VBN of index block to delete.
!
! Outputs:
!
!	None
!---

BEGIN

BIND
    context = .lbr$gl_control[lbr$l_ctxptr] : BBLOCK,
    header = .lbr$gl_control[lbr$l_hdrptr] : BBLOCK;

LOCAL
    blockaddr : REF VECTOR[,LONG],
    status,
    cache_entry : REF BBLOCK;

perform(find_block(.vbn, blockaddr, cache_entry));	!Get block in memory
IF .vbn LEQU .header[lhd$l_hipreal]
THEN BEGIN
    blockaddr[0] = .header[lhd$l_freeidx];
    header[lhd$l_freeidx] = .vbn;
    header[lhd$l_freidxblk] = .header[lhd$l_freidxblk] + 1;
    cache_entry[cache$v_dirty] = true;
    END
ELSE perform (dealloc_block (.vbn));		! Just deallocate block

header[lhd$l_idxblks] = .header[lhd$l_idxblks] - 1;

context [ctx$v_hdrdirty] = true;		! Mark header dirty
RETURN true;

END;

%SBTTL  'add_index';
ROUTINE add_index (index, vbn, index_block) =

!---
!
!	Create a key which points to the specified index block
!	in the parent index block.  The highest key in the
!	current block is used as the key value.
!
! Inputs:
!
!	vbn = VBN of the index block
!	index = Primary index number
!
! Outputs:
!
!	None
!---

BEGIN

MAP
    index_block: REF BBLOCK;		! Address of index block

LOCAL
    entry_size,				! Size of each entry
    last_entry: REF BBLOCK,		! Last index entry in block
    index_desc: REF BBLOCK,		! Address of index descriptor
    rfa: BBLOCK [rfa$c_length];		! RFA to be associated with key


index_desc = .lbr$gl_control [lbr$l_hdrptr] + lhd$c_idxdesc
		+ (.index-1)*idd$c_length;
!
!	Find the last entry in the index block.
!
entry_size = idx$c_length + .index_desc [idd$w_keylen];
last_entry = .index_block + index$c_entries
	+ .index_block [index$w_used] - .entry_size;
!
!	Setup special RFA which points to this index block.
!
rfa [rfa$l_vbn] = .vbn;			! Point to this block
rfa [rfa$w_offset] = rfa$c_index;	! Mark as index pointer
!
!	Add the key to the parent index.
!
IF .index_desc [idd$v_ascii]		! If ASCII string keys,
THEN
    BEGIN
    LOCAL
	desc: BBLOCK [dsc$c_s_bln];	! String descriptor

    desc [dsc$w_length] = .last_entry [idx$b_keylen];
    desc [dsc$a_pointer] = last_entry [idx$t_keyname];
    perform( add_key (.index, desc, rfa,
		.index_block [index$l_parent]) );
    END
ELSE
    perform( add_key (.index,last_entry[idx$l_keyid],rfa,
		.index_block [index$l_parent]) );

RETURN true;

END;

%SBTTL  'add_index2';
ROUTINE add_index2 (index, vbn, index_block) =

!---
!
!	Add_index2 is a modified add_index to handle indices
!	with variable length keywords.
!	Create a key which points to the specified index block
!	in the parent index block.  The highest key in the
!	current block is used as the key value.
!
! Inputs:
!
!	vbn = VBN of the index block
!	index = Primary index number
!
! Outputs:
!
!	None
!---

BEGIN

MAP
    index_block: REF BBLOCK;		! Address of index block

LOCAL
    entry_size,				! Size of each entry
    last_entry: REF BBLOCK,		! Last index entry in block
    next_entry : REF BBLOCK,		! search for last index entry in block.
    index_desc: REF BBLOCK,		! Address of index descriptor
    rfa: BBLOCK [rfa$c_length];		! RFA to be associated with key


index_desc = .lbr$gl_control [lbr$l_hdrptr] + lhd$c_idxdesc
		+ (.index-1)*idd$c_length;
!
!	Find the last entry in the index block.
!
last_entry = .index_block + index$c_entries;
next_entry = .last_entry;
WHILE .next_entry LSS .index_block+index$c_entries+.index_block[index$w_used] DO
    BEGIN
    last_entry = .next_entry;
    next_entry = .next_entry + idx$c_rfaplsbyt + .next_entry[idx$b_keylen];
    END;
!
!	Setup special RFA which points to this index block.
!
rfa [rfa$l_vbn] = .vbn;			! Point to this block
rfa [rfa$w_offset] = rfa$c_index;	! Mark as index pointer
!
!	Add the key to the parent index.
!
IF .index_desc [idd$v_ascii]		! If ASCII string keys,
THEN
    BEGIN
    LOCAL
	desc: BBLOCK [dsc$c_s_bln];	! String descriptor

    desc [dsc$w_length] = .last_entry [idx$b_keylen];
    desc [dsc$a_pointer] = last_entry [idx$t_keyname];
    perform( add_key (.index, desc, rfa,
		.index_block [index$l_parent]) );
    END
ELSE
    RETURN lbr$_intrnlerr;		! add_index2 only for ASCII keys

RETURN true;

END;

%SBTTL  'reset_highest';
ROUTINE reset_highest (index_desc, vbn, index_block) =

!---
!
!	Reset the index pointers in the parent blocks
!	pointing to the specified index block.  Each
!	index pointer in a parent block contains the
!	highest key in the subindex block in order for
!	binary searches to work.  This routine is called
!	when the index block has changed in order to
!	reset the parents highest keys to the proper value.
!
! Inputs:
!
!	index_desc = Address of primary index descriptor
!	vbn = VBN of index block
!	index_block = Address of index block
!
! Outputs:
!
!	The highest keys in the parents are reset.
!
!---

BEGIN

MAP
    index_desc: REF BBLOCK,		! Address of index descriptor
    index_block: REF BBLOCK;		! Address of index block

LOCAL
    entry_size,				! Size of each entry
    last_entry: REF BBLOCK,		! Last index entry in block
    parent_block: REF BBLOCK,		! Address of parent block
    parent_entry: REF BBLOCK;		! Address of parent entry


IF .index_block [index$l_parent] EQL 0	! If no parent
THEN
    RETURN true;			! then return done
!
!	Find the last entry in the index block.
!
entry_size = idx$c_length + .index_desc [idd$w_keylen];
last_entry = .index_block + index$c_entries
	+ .index_block [index$w_used] - .entry_size;
!
!	Find the parent index block.
!
perform (find_index (.index_block [index$l_parent], parent_block));
!
!	Locate the pointer to the subindex block.
!
INCRU entry FROM .parent_block+index$c_entries BY .entry_size
DO
    BEGIN
    MAP
	entry: REF BBLOCK;		! Address index entry

    IF .entry [idx$l_vbn] EQL .vbn	! If points to subindex,
    THEN
	BEGIN
	parent_entry = .entry;		! Set address of parent entry
	EXITLOOP;			! then exit the scan
	END;
    END;
!
!	Update the key in the parent index.
!
IF .index_desc [idd$v_ascii]		! If ASCII string keys,
THEN
    BEGIN
    parent_entry [idx$b_keylen] = .last_entry [idx$b_keylen];
    CH$MOVE(.last_entry [idx$b_keylen],	! Copy ASCII key
		last_entry [idx$t_keyname],
		parent_entry [idx$t_keyname]);
    END
ELSE
    parent_entry [idx$l_keyid] = .last_entry [idx$l_keyid];
!
!	Mark the parent index block modified.
!
mark_dirty(.index_block [index$l_parent]);
!
!	Reset the highest key in the parents parent.
!
reset_highest(.index_desc,.index_block [index$l_parent],.parent_block);

RETURN true;

END;

%SBTTL  'reset_highest2';
ROUTINE reset_highest2 (index, index_desc, vbn, index_block) =

!---
!
!	Reset_highest2 is a modified reset_highest
!	to handle variable length keyword indices.
!	Reset the index pointers in the parent blocks
!	pointing to the specified index block.  Each
!	index pointer in a parent block contains the
!	highest key in the subindex block in order for
!	binary searches to work.  This routine is called
!	when the index block has changed in order to
!	reset the parents highest keys to the proper value.
!
! Inputs:
!
!	index_desc = Address of primary index descriptor
!	vbn = VBN of index block
!	index_block = Address of index block
!
! Outputs:
!
!	The highest keys in the parents are reset.
!
!---

BEGIN

MAP
    index_desc: REF BBLOCK,		! Address of index descriptor
    index_block: REF BBLOCK;		! Address of index block

LOCAL
    entry,				! index block entry
    entry_size,				! Size of each entry
    last_entry: REF BBLOCK,		! Last index entry in block
    next_entry : REF BBLOCK,		! search for last index entry in block.
    parent_block: REF BBLOCK,		! Address of parent block
    parent_entry: REF BBLOCK;		! Address of parent entry


IF .index_block [index$l_parent] EQL 0	! If no parent
THEN
    RETURN true;			! then return done
!
!	Find the last entry in the index block.
!
next_entry = .index_block + index$c_entries;
WHILE .next_entry LSS .index_block+index$c_entries+.index_block[index$w_used] DO
    BEGIN
    last_entry = .next_entry;
    next_entry = .next_entry + idx$c_rfaplsbyt + .next_entry[idx$b_keylen];
    END;
!
!	Find the parent index block.
!
perform (find_index (.index_block [index$l_parent], parent_block));
!
!	Locate the pointer to the subindex block.
!
entry = .parent_block+index$c_entries;
WHILE true DO
    BEGIN
    MAP
	entry: REF BBLOCK;		! Address index entry

    IF .entry [idx$l_vbn] EQL .vbn	! If points to subindex,
    THEN
	BEGIN
	parent_entry = .entry;		! Set address of parent entry
	EXITLOOP;			! then exit the scan
	END
    ELSE
	entry = .entry + idx$c_rfaplsbyt + .entry [idx$b_keylen];
	IF .entry GTR .parent_block + lbr$c_pagesize	! Don't loop forever if not found
	THEN RETURN lbr$_intrnlerr;
    END;
!
!	Update the key in the parent index.
!
IF .index_desc [idd$v_ascii]		! If ASCII string keys,
THEN
    BEGIN
    IF .parent_entry [idx$b_keylen] EQL .last_entry [idx$b_keylen]
    THEN 	! We're in luck, they are the same size
        BEGIN
        parent_entry [idx$b_keylen] = .last_entry [idx$b_keylen];
        CH$MOVE(.last_entry [idx$b_keylen],	! Copy ASCII key
		last_entry [idx$t_keyname],
		parent_entry [idx$t_keyname]);
        END
    ELSE	! Remove old entry, compress, and enter new one.
        BEGIN
	LOCAL
	    parent_entry_siz;

	parent_entry_siz = idx$c_rfaplsbyt + .parent_entry [ idx$b_keylen];
        CH$MOVE( .parent_block + index$c_entries + .parent_block[index$w_used]
		- (.parent_entry + .parent_entry_siz),
		.parent_entry + .parent_entry_siz,
		.parent_entry );		!compress to cover old entry
	parent_block[index$w_used] = .parent_block[index$w_used] - .parent_entry_siz;
	perform (add_index2 (.index, .vbn, .index_block) );
        END;
    END
ELSE
    RETURN lbr$_intrnlerr;		! reset_highest2 only for ASCII keys
!
!	Mark the parent index block modified.
!
mark_dirty(.index_block [index$l_parent]);
!
!	Reset the highest key in the parent's parent.
!	Must check that .parent_block is the address of block .index_block [index$l_parent]
!	since the last call to add_index2 may have resulted in a new parent.
!	If there is a new parent then it has already been reset.
!
BEGIN
LOCAL
    blk_adr,
    status;

perform ( find_index ( .index_block [index$l_parent], blk_adr) );
IF .blk_adr EQL .parent_block
THEN
    BEGIN 
    status = reset_highest2(.index,.index_desc, .index_block [index$l_parent],.parent_block);
    IF NOT .status THEN RETURN lbr$_intrnlerr;
    END;
END;

RETURN true;

END;

%SBTTL  'check_lock';
GLOBAL ROUTINE check_lock : JSB_0 =
BEGIN

!---
!
!	Check if the index is locked from modification.
!
! Inputs:
!
!	None
!
! Outputs:
!
!	None
!
! Routine value:
!
!	true		Ok to modify index
!	lbr$_updurtrav	Index is locked
!
!---

BIND
    index_desc = .lbr$gl_control [lbr$l_hdrptr] + lhd$c_idxdesc		! Name index descriptor for current index
			+ (.lbr$gl_control [lbr$l_curidx] - 1) * idd$c_length
					: BBLOCK;

IF .index_desc [idd$v_locked]
    THEN RETURN lbr$_updurtrav
    ELSE RETURN true

END;							! Of check_lock

%SBTTL  'mark_dirty';
GLOBAL ROUTINE mark_dirty (vbn) : JSB_1 =

!---
!
!	Mark an index block modified in memory so that
!	it gets written back to disk when the file is closed.
!
! Inputs:
!
!	vbn = disk block number
!
! Outputs:
!
!	None
!---

BEGIN

LOCAL
    cache_entry: REF BBLOCK;

perform (lookup_cache (.vbn, cache_entry)); ! Lookup entry in cache

cache_entry [cache$v_dirty] = true;	! Mark modified

RETURN true;

END;

END
ELUDOM
