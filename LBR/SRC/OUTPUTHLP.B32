MODULE lbr_outputhelp (
		LANGUAGE (BLISS32),
		IDENT = 'V03-015'
		) =
BEGIN
%TITLE 'Prompting and library searching help function';
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:  Library access procedures.
!
! ABSTRACT:
!
!	LBR$OUTPUT_HELP outputs help text to a user specified output
!	routine.  This information is drawn from an explicitly named
!	help library, or optionally, from user specified default help
!	libraries.  In addition, an optional prompting mode is available
!	so that LBR$OUTPUT_HELP can interact with a user and continue to
!	provide help information to a user after it has satisfied his
!	initial help request.
!
! ENVIRONMENT:
!
!	VAX native, user mode.
!
!--
!
!
! AUTHOR:  Peter George,	 CREATION DATE:  01-May-1981
!
! MODIFIED BY:
!
!	V02-015	PCG0012		Peter George		15-Apr-1982
!		Check for LBR$_ENDTOPIC.
!
!	V02-014	PCG0011		Peter George		05-Apr-1982
!		Pay attention to errors reported by LBR$GET_HELP.
!
!	V02-013 RPG0013		Bob Grosso		04-Mar-1982
!		Avoid printing keywords twice, when a keyword is in
!		the help library without any help text for it.
!
!	V02-012	PCG0010		Peter George		15-Jan-1982
!		Remove temporary symbols.
!
!	V02-011	PCG0009		Peter George		06-Jan-1982
!		Set CTX$V_OUTPUTHLP bit before calling LBR$GET_HELP.
!		Allow user to specify whether or not help on help
!		should be printed at topic level.
!
!	V02-010	PCG0008		Peter George		18-Dec-1981
!		Or in old help flags when defaulting that parameter.
!
!	V02-009	PCG0007		Peter George		10-Dec-1981
!		Correctly remove keywords from the prompt when 
!		backing up.  Allow null library_desc argument.
!		Insert default library name in prompt.
!		Make use of LIBLIST flag.  Generate list 
!		of "Libraries available:" at topic level.
!
!	V02-008	PCG0006		Peter George		12-Oct-1981
!		Zero upper word of prompt string descriptors.
!
!	V02-007	PCG0005		Peter George		14-Sep-1981
!		Clean up call to user output routine.
!
!	V02-006	PCG0004		Peter George		09-Sep-1981
!		Clean up calls to user input routines.
!
!	V02-005	RPG0005		Bob Grosso		02-Sep-1981
!		Remove LBRMSG
!
!	V02-004	TMH0004		Tim Halvorsen		25-Jun-1981
!		Change SIGNAL_STOP's to SIGNAL's, to allow the caller
!		to change the severity level at will.
!
!	V02-003	PCG0003		Peter George		16-Jun-1981
!		Correct bugs in parameter defaulting.
!
!	V02-002	PCG0002		Peter George		04-Jun-1981
!		Use '?' to repeat current help available.
!		Remove special casing for HELP key.
!
!	V02-001	PCG0001		Peter George		18-May-1981
!		Change main topic prompt.
!		Use default line width.
!		Return status to LBR$GET_HELP.
!--

LIBRARY 'SYS$LIBRARY:STARLET';
REQUIRE 'PREFIX';
REQUIRE 'LBRDEF';

EXTERNAL ROUTINE
    lbr$close :		ADDRESSING_MODE(GENERAL),	! Close library
    lbr$ini_control :	ADDRESSING_MODE(GENERAL),	! Initialize librarian
    lbr$get_help :	ADDRESSING_MODE(GENERAL),	! Get help text
    lbr$open :		ADDRESSING_MODE(GENERAL);	! Open library

FORWARD ROUTINE
    prompt_help,		! Main prompting loop
    search_libs,		! Search default libraries till help is found
    change_lib,			! Change current help lib context to specified library
    switch_libname,		! Update the library name descriptor
    tran_next_lib,		! Get next user specified default help library
    open_library,		! Open a help library
    close_library,		! Close a help library
    setup_keys,			! Set up help keys for lbr$get_help
    call_lbrhelp,		! Call lbr$get_help to get help from a library
    output_driver,		! Driver for the user supplied output routine
    libs_available,		! Output list of default libraries available
    file_present,		! Determine if file exists
    nohelp_log,			! Log unrecognized help requests
    remove_last_key,		! Remove the last help key in a list of keys
    remove_terminator,		! Remove the termination character at the end of a command
    make_upper_case;		! Make a string all upper case

EXTERNAL LITERAL
    lbr$_endtopic,
    lbr$_illoutrou,
    lbr$_illinrou,
    lbr$_nohlplibs,
    lbr$_nothlplib,
    lbr$_toomnyarg,
    lbr$_usrinperr;

LITERAL
    main_libnumber = -2,				! Library number of /LIBRARY specified library
    external_libnumber = -1;				! Library number of non-default, non-/LIB library

OWN
    syshelp : COUNTEDSTRING ('SYS$HELP:.HLB'),		! Default library spec
    topic : COUNTEDSTRING ('Topic? '),			! Topic prompt string
    subtopic : COUNTEDSTRING ('Subtopic? '),		! Subtopic prompt string
    prompt_prefix : VECTOR [5, BYTE] 			! Prompt control characters
		    INITIAL (BYTE (4, 13, 10, 13, 10)),
    control_flags : BBLOCK [hcf$c_length];		! Global control flags 

BIND
    help_flags = control_flags [hcf$l_userlib],		! User default library flags
    prompt_flags = control_flags [hcf$l_prompt];	! Prompt control flags

MAP
    help_flags : BBLOCK;

%SBTTL 'Routine lbr$output_help';
GLOBAL ROUTINE lbr$output_help (output_rout, output_size, keys_desc, 
				library_desc, flags, input_rout) =
BEGIN

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is the entry point for this module.  It performs
!	some initial processing on the input parameters, opens the main
!	help library, and then calls prompt_help to do all the real work.
!
! CALLING SEQUENCE:
!
!	status = LBR$OUTPUT_HELP (output_routine, output_width [, [keys_desc] 
!				  [, [library_desc]  [, [flags] [, [input_routine] ]]]] )
!
! INPUTS:
!
!	output_rout =	address of user output routine
!	output_size =	width of the output line to be passed to the user
!			output routine
!	keys_desc = 	address of string desc for keys
!	library_desc =	address of string desc for help library name
!	flags = 	address of longword of option flags
!	input_rout = 	address of user input routine
!
! OUTPUTS:
!
!	The requested help text is passed to the output routine.
!
! ROUTINE VALUE:
!
!	status	lbr$_normal
!		lbr$_illoutrou	 Output routine improperly specified or missing
!		lbr$_illinrou	 Input routine improperly specified or missing
!		lbr$_toomnyarg	 Too many arguments
!--

MAP
    keys_desc : REF BBLOCK,
    library_desc : REF BBLOCK;

BUILTIN
    ACTUALCOUNT,
    NULLPARAMETER;

LOCAL
    getcmd_line : BBLOCK [hlp$c_pagesize],		! Command line buffer
    getcmd_desc : BBLOCK [dsc$c_s_bln],			! Command desc
    indices : BBLOCK [hli$c_length],			! Help library indices
    input_routine,					! Address of user input routine
    librarystring : BBLOCK [nam$c_maxrss],		! Default library name string
    libraryname : BBLOCK [dsc$c_s_bln],			! String descriptor for library name
    nomsg,						! Open_library message flag
    output_routine,					! Address of user output routine
    output_width, 					! Width of output line
    status;

BIND
    main_libindex = indices [hli$l_mainindex],		! Index of /LIB library
    last_libindex = indices [hli$l_lastindex],		! Index of last library examined
    last_libnumber = indices [hli$l_lastnumb];		! No. of last lib examined, relative to all default libs

help_flags = 0;						! Clear help control flags

IF ACTUALCOUNT() GTR hlp$c_params			! If too many arguments
   THEN RETURN lbr$_toomnyarg;				!    then return error

IF NULLPARAMETER (hlp$c_outrout)			! If output_routine missing
   OR .output_rout EQL 0				!    or zero
   THEN RETURN lbr$_illoutrou				!    then return error
   ELSE output_routine = .output_rout;			!    else store data

IF NULLPARAMETER (hlp$c_outwidth)			! If output_width missing
   OR ..output_size EQL 0				!    or zero
   THEN output_width = hlp$c_liswidth			!    then use default
   ELSE output_width = ..output_size;			!    else store data

getcmd_desc = 0;
getcmd_desc [dsc$a_pointer] = getcmd_line;
IF NOT NULLPARAMETER (hlp$c_linedesc)			! If keys_desc present
   THEN BEGIN						!    then pick up passed descriptor
	getcmd_desc [dsc$w_length] = .keys_desc [dsc$w_length];
	CH$MOVE (.getcmd_desc [dsc$w_length],		!    fill buffer
		 .keys_desc [dsc$a_pointer],
		 .getcmd_desc [dsc$a_pointer] );
	END;

libraryname = 0;
libraryname [dsc$a_pointer] = librarystring;		! Init pointer to library name buffer
IF NOT NULLPARAMETER (hlp$c_libname)			! If library_name specified
   THEN BEGIN						!    then override default
	help_flags [hlp$v_library] = true;
	libraryname [dsc$w_length] = .library_desc [dsc$w_length];
	CH$MOVE (.libraryname [dsc$w_length],
		 .library_desc [dsc$a_pointer],
		 .libraryname [dsc$a_pointer]);
	END
   ELSE help_flags [hlp$v_library] = false;

IF NOT NULLPARAMETER (hlp$c_flags)			! If flags present
   THEN help_flags = .help_flags			!    then get relevent bits
		OR (hlp$m_prompt AND ..flags)
		OR (hlp$m_process AND ..flags)
		OR (hlp$m_group AND ..flags)
		OR (hlp$m_system AND ..flags)
		OR (hlp$m_liblist AND ..flags)
		OR (hlp$m_help AND ..flags)
   ELSE help_flags = .help_flags OR hlp$m_prompt 	!    else set defaults
		OR hlp$m_process OR hlp$m_group 
		OR hlp$m_system AND NOT hlp$m_liblist
		AND NOT hlp$m_help;

IF .help_flags [hlp$v_prompt]				! If prompting enabled
THEN BEGIN
     IF ( NULLPARAMETER (hlp$c_inrout)			! And output_routine missing
          OR .input_rout EQL 0 )			! or zero 
	THEN RETURN lbr$_illinrou			!    then return error
	ELSE input_routine = .input_rout;		!    else store data
     prompt_flags = hcf$m_cont;				! Turn on prompting
     END
ELSE prompt_flags = hcf$m_noprompt;			! else turn off prompting

IF .help_flags [hlp$v_process] OR 			! If default lib searching enabled
   .help_flags [hlp$v_group] OR .help_flags [hlp$v_system]
   THEN help_flags = .help_flags OR hlp$m_all		!    then set all flag
   ELSE help_flags = .help_flags AND NOT hlp$m_all;	!    else clear all flag

IF .help_flags [hlp$v_library]				! If library specified
   THEN BEGIN						! Then open it
	nomsg = false;					! Signal error if library can't be opened
	open_library (main_libindex, libraryname, .nomsg);  ! Open main library
	last_libindex = .main_libindex;			! Set last library used to main library
	last_libnumber = main_libnumber;
	END

   ELSE BEGIN						! Else use a default library
	
	LOCAL
	    libno,
	    acmode;

	IF NOT .help_flags [hlp$v_all]			! Are we allowed to?
	   THEN RETURN lbr$_nohlplibs;			! If not then signal error
	libno = -1;					! Initialize search
	status = false;					! Init while condition
	nomsg = true;					! Do not signal open errors
	WHILE NOT .status				! While more libraries
	DO BEGIN					! Get and try to open one
	   IF NOT tran_next_lib (libraryname, acmode, libno)
	      THEN RETURN lbr$_nohlplibs;
	   status = open_library (last_libindex, libraryname, .nomsg);
	   END;
	last_libnumber = 0;				! Set lib number
	END;

!
! Call prompt_help to do the real help work.
!
status = prompt_help(getcmd_desc, output_width, .input_routine, .output_routine, 
			indices, libraryname);

IF .help_flags [hlp$v_library]				! If library specified
   THEN close_library (main_libindex);			! Close the main library

RETURN .status

END;							! Of lbr$output_help

%SBTTL 'Routine prompt_help';
ROUTINE prompt_help (getcmd_desc, output_width, input_routine, 
			output_routine, indices, libraryname) =
BEGIN

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine contains the interactive code loop that is repeatedly 
!	executed when help is being run in prompting mode.  This same loop
!	is executed exactly once when noprompt is specified.
!
! INPUTS:
!
!	getcmd_desc =	address of the descriptor for the set of keys 
!			to be processed
!
!	output_width =  address of longword containing width of output line
!	
!	input_routine = address of user supplied input routine
!
!	output_routine = addresss of user supplied output routine
!
!	indices = 	address of data structure containing indices of
!			libraries currently in use
!
!	libraryname =	address of string desc for default help library name
!
! OUTPUTS:
!
!	None.
!
! ROUTINE VALUE:
!
!	Always true.
!
!--
MAP
    getcmd_desc : REF BBLOCK,
    indices : REF BBLOCK,
    libraryname : REF BBLOCK;

LOCAL
    char_pos,						! Position of first non-blank character in input string
    key_descs : VECTOR [dsc$c_s_bln * hlp$c_maxkeys, BYTE],	!String descriptors for keys
    key_length_array : VECTOR [hlp$c_maxkeys],		! Array of key lengths
    lib_name : BBLOCK [dsc$c_s_bln],			! Library name descriptor
    lib_name_buf : BBLOCK [9],				! Library name buffer
    print_data : BBLOCK [hpd$c_length],			! Data structure for output driver
    topic_prompt : BBLOCK [dsc$c_s_bln],		! Topic prompt descriptor
    topic_prompt_buf : BBLOCK [hlp$c_prompt],		! Topic prompt buffer
    sub_prompt : BBLOCK [dsc$c_s_bln],			! Sub-prompt descriptor
    sub_prompt_level,					! Current key depth
    sub_prompt_line : BBLOCK [hlp$c_pagesize],		! Sub-prompt line
    sub_prompt_buf : BBLOCK [hlp$c_pagesize],		! Sub-prompt buffer
    status;

BIND
    main_libindex = indices [hli$l_mainindex],		! Index of /LIB library
    last_libindex = indices [hli$l_lastindex],		! Index of last library examined
    last_libnumber = indices [hli$l_lastnumb],		! No. of last lib examined, relative to all default libs
    getcmd_line = .getcmd_desc [dsc$a_pointer],		! Command buffer
    true_keys = print_data [hpd$b_truekeys] : SIGNED BYTE,  ! Number of help keys
    help_level = print_data [hpd$b_helplevel] : BYTE,	! Current key depth
    print_flags = print_data [hpd$b_printflag] : BBLOCK,! Flags for output driver
    add_info_level = print_data [hpd$l_subpmtlev],	! Level of additional info
    sub_prompt_ptr = print_data [hpd$l_subpmtptr],	! Ptr used for filling sub-prompt buffer
    length_array = print_data [hpd$l_lenarray] : REF VECTOR,  ! Address of key length array
    outputroutine = print_data [hpd$l_outputrou];	! User specified output routine	

length_array = key_length_array;					! Init print_data array
outputroutine = .output_routine;

lib_name = 0;								! Initialize library name
lib_name [dsc$a_pointer] = lib_name_buf;
IF NOT .help_flags [hlp$v_library]					! If no main library
   THEN switch_libname (.libraryname, lib_name);			! Then use passed library name in prompt

topic_prompt = 0;							! Initialize topic prompt
topic_prompt [dsc$a_pointer] = topic_prompt_buf;
CH$MOVE (.prompt_prefix [0], prompt_prefix [1], topic_prompt_buf);

sub_prompt = 0;								! Initialize sub-prompt
sub_prompt [dsc$a_pointer] = sub_prompt_line;
CH$MOVE (.prompt_prefix [0], prompt_prefix [1], sub_prompt_line);

WHILE (.getcmd_desc [dsc$w_length] GTR 0)				! Remove any preceeding blanks from command string
      AND (CH$RCHAR (.getcmd_desc [dsc$a_pointer]) EQL %C' ')
DO BEGIN
   getcmd_desc [dsc$w_length] = .getcmd_desc [dsc$w_length] - 1;
   getcmd_desc [dsc$a_pointer] = .getcmd_desc [dsc$a_pointer] + 1;
   END;

IF (.getcmd_desc [dsc$w_length] GTR 0)					! If non-empty help keys
   AND (CH$RCHAR (.getcmd_desc [dsc$a_pointer]) EQL %C'@') 		! And initial key starts with "@"
   THEN (change_lib (.getcmd_desc, .getcmd_desc [dsc$a_pointer], 
			.indices, lib_name));				! Then change to specified library

WHILE (.prompt_flags AND hcf$m_cont) NEQ 0				! WHILE we can still continue...
DO BEGIN

IF .prompt_flags EQL hcf$m_noprompt					! If one shot command
   THEN prompt_flags = NOT hcf$m_noprompt;				! Execute while exactly once 

IF .prompt_flags GTR hcf$m_stay						! If prompting enabled
   THEN BEGIN								! Prompt for keywords

!
! If moving down a prompt level then update the subtopic prompt.
!

IF (.prompt_flags AND (hcf$m_more OR hcf$m_stay)) EQL hcf$m_more
   THEN BEGIN

	LOCAL
	    sub_length;

	IF .lib_name [dsc$w_length] NEQ 0				! If not main library
	   THEN BEGIN							! Then insert library name in prompt
		CH$WCHAR (%C'@', sub_prompt_line + 4);
		CH$MOVE (.lib_name [dsc$w_length],
			 .lib_name [dsc$a_pointer],
			 sub_prompt_line + 4 + 1);
		CH$WCHAR (%X'20', sub_prompt_line + 4 + 1 + .lib_name [dsc$w_length]);
		sub_prompt [dsc$w_length] = 4 + 1 + .lib_name [dsc$w_length] + 1;
		END
	   ELSE	sub_prompt [dsc$w_length] = 4;				! Otherwise skip to keys

	sub_length = .sub_prompt_ptr - sub_prompt_buf;			! Calculate length of keys
	CH$MOVE (.sub_length, sub_prompt_buf, 				! Move keys into prompt line
		 sub_prompt_line + .sub_prompt [dsc$w_length]);	
	CH$MOVE (.subtopic [0], subtopic [1], 				!Move "subtopic?" into prompt line
		 sub_prompt_line + .sub_prompt [dsc$w_length] + .sub_length);
	sub_prompt [dsc$w_length] = .sub_prompt [dsc$w_length] 		! Update prompt length
				    + .sub_length + .subtopic [0];
	sub_prompt_level = .help_level;					! Update prompt level
	END;

!
! If subprompt length greater than zero, then do subtopic prompting.
!

IF .sub_prompt [dsc$w_length] NEQ 0
   THEN BEGIN

	LOCAL
	    prefix_length,
	    sub_length;

	IF .lib_name [dsc$w_length] NEQ 0				! If not main library
	   THEN prefix_length = 4 + 1 + .lib_name [dsc$w_length] + 1	! Then prefix includes lib name
	   ELSE prefix_length = 4;					! Else it doesn't

	sub_length = .sub_prompt [dsc$w_length] - .prefix_length	! Calculate length of keys
			- .subtopic [0];
	CH$MOVE (.sub_length, sub_prompt_line + .prefix_length, 	! Move keys into command line
			getcmd_line);
	getcmd_desc [dsc$w_length] = hlp$c_pagesize - .sub_length;	! Calculate space left in command line
	getcmd_desc [dsc$a_pointer] = getcmd_line + .sub_length;	! Set pointer to end of keys

	IF (status = (.input_routine) (getcmd_desc [dsc$w_length], 	! Get input
	     sub_prompt, getcmd_desc [dsc$w_length])) EQL RMS$_EOF	! If CNTL-Z
	   THEN EXITLOOP						! Then get out of help
	   ELSE IF NOT .status						! Else if other error
		   THEN RETURN lbr$_usrinperr;				! Then signal user input error

	IF ((char_pos = CH$FIND_NOT_CH (.getcmd_desc [dsc$w_length],	! If blank line
		.getcmd_desc [dsc$a_pointer], %ASCII ' ')) EQL 0)	! Or CR
	   OR (CH$RCHAR (.char_pos) EQL %X'0D')				! Then back up a prompt level

	   THEN IF (sub_prompt_level = .sub_prompt_level - 1) EQL 0	! If now at topic level
		   THEN sub_prompt [dsc$w_length] = 0			! then clear subtopic prompt
		   ELSE BEGIN		
			remove_last_key (sub_prompt, 			! else remove last key
				.key_length_array [.sub_prompt_level+1]);  
			prompt_flags = hcf$m_backup OR hcf$m_cont;	! Set backup flag
			END

	   ELSE	SELECTONE (CH$RCHAR (.getcmd_desc [dsc$w_length] + 	! Test termination character
			.getcmd_desc [dsc$a_pointer] - 1)) OF SET

		[%C'?']:						! If ?
		BEGIN							! then repeat help for old help keys
		getcmd_desc [dsc$w_length] = .sub_length;	
		getcmd_desc [dsc$a_pointer] = getcmd_line;	
		END;

		[%X'1A']:						! If CNTL-Z
		EXITLOOP;						! then get out of help

		[OTHERWISE]:						! If help keys
		BEGIN							! then append command to old keys
		getcmd_desc [dsc$w_length] = .getcmd_desc [dsc$w_length] + .sub_length;
		getcmd_desc [dsc$a_pointer] = getcmd_line;
		END;
		TES;

	remove_terminator (.getcmd_desc);				! Remove termination character from command string

	END;

!
! If subtopic length equals zero, then do topic prompting
!

IF .sub_prompt [dsc$w_length] EQL 0
   THEN BEGIN

	getcmd_desc [dsc$w_length] = hlp$c_pagesize;			! Init rest of descriptor
	getcmd_desc [dsc$a_pointer] = getcmd_line;

	IF .last_libnumber GEQ external_libnumber			! If not main library
	   THEN BEGIN							! Then insert library name in prompt
		CH$WCHAR (%C'@', topic_prompt_buf + 4);
		CH$MOVE (.lib_name [dsc$w_length],
			.lib_name [dsc$a_pointer],
			topic_prompt_buf + 4 + 1);
		CH$WCHAR (%X'20', topic_prompt_buf + 4 + 1 + 
			.lib_name [dsc$w_length]);
		CH$MOVE (.topic [0], topic [1],
			topic_prompt_buf + 4 + 1 + .lib_name [dsc$w_length] + 1);
		topic_prompt [dsc$w_length] = 4 + 1 + 
			.lib_name [dsc$w_length] + 1 + .topic [0];
		END
	   ELSE	BEGIN							! Otherwise, do not include library name
		topic_prompt [dsc$w_length] = 4 + .topic [0];
		CH$MOVE (.topic [0], topic [1],
			topic_prompt_buf + 4);
		END;

	IF (status = (.input_routine) (getcmd_desc [dsc$w_length], 	! Get input
	     topic_prompt, getcmd_desc [dsc$w_length])) EQL RMS$_EOF	! If CNTL-Z
	   THEN EXITLOOP						! Then get out of help
	   ELSE IF NOT .status						! Else if other error
		   THEN RETURN lbr$_usrinperr;				! Then signal user input error

	IF ((char_pos = CH$FIND_NOT_CH (.getcmd_desc [dsc$w_length],	! If blank line
		.getcmd_desc [dsc$a_pointer], %ASCII ' ')) EQL 0)	! Or CR
	   OR (CH$RCHAR (.char_pos) EQL %X'0D')				! Then back up a library
	   THEN (IF (.last_libnumber LSS external_libnumber		! If already at main library
		     OR NOT .help_flags [hlp$v_library])	        ! or if there is no main library
		    THEN EXITLOOP					! Then get out of help
		    ELSE BEGIN 						! Else back up to main library
			 close_library (last_libindex);			! Close old user library
			 last_libnumber = main_libnumber;		! Set main library number
			 last_libindex = .main_libindex;		! And index
			 lib_name [dsc$w_length] = 0;			! Reset library name
			 getcmd_desc [dsc$w_length] = 0;		! Clear command descriptor
			 getcmd_desc [dsc$a_pointer] = getcmd_line;
			 prompt_flags = hcf$m_backup OR hcf$m_cont;	! Set back up flag
			 END;)

	   ELSE	SELECTONE (CH$RCHAR (.getcmd_desc [dsc$w_length] + 	! Test termination character
			.getcmd_desc [dsc$a_pointer] - 1)) OF SET

		[%C'?']:						! If ?
		BEGIN							! Then repeat help for old library
		getcmd_desc [dsc$w_length] = 0;
		getcmd_desc [dsc$a_pointer] = getcmd_line;	
		END;

		[%X'1A']:						! If CNTL-Z
		EXITLOOP;						! Then get out of help

		[OTHERWISE]:						! If help keys
		IF (CH$RCHAR (.char_pos) EQL %C'@') 			! And start with "@"
		   THEN (change_lib (.getcmd_desc, .char_pos, 
					.indices, lib_name));		! Then change to specified library
		TES;

	remove_terminator (.getcmd_desc);				! Remove termination character from command string

	END;

END;									! Of prompt for keywords

IF (.prompt_flags AND hcf$m_backup) EQL 0				! If not backing up a level
THEN BEGIN								! then get help text
     IF .prompt_flags NEQ (NOT hcf$m_noprompt)				! If not prompting
	THEN prompt_flags = hcf$m_cont;					! Say to continue prompting
     sub_prompt_ptr = sub_prompt_buf;					! Init subtopic buffer pointer
     help_level = 0;							! Set current key depth to zero
     add_info_level = 0;
     setup_keys (.getcmd_desc, key_descs, true_keys);			! Set up individual help key descs
     print_flags [hpd$v_init] = 0;					! Set print not initialized flag
     IF NOT (status = search_libs (key_descs, .output_width, print_data,! Search the libraries for help
		 .indices, lib_name, .sub_prompt [dsc$w_length]))
	THEN RETURN .status;
     IF .print_flags [hpd$v_init]					! If no help found
	THEN nohelp_log (.getcmd_desc);					! Then log help request
     IF .help_flags [hlp$v_liblist] AND ((.true_keys LEQ 0)		! Output list of libraries if conditions
	OR ((.add_info_level EQL 0) AND .print_flags [hpd$v_init]))	! are right
	THEN libs_available (.output_routine, .output_width);
     END
ELSE prompt_flags = hcf$m_cont OR hcf$m_stay;				! Say to continue prompting at current level

END;									!Of while

RETURN true
	
END;									!Of prompt_help

ROUTINE search_libs (keydescs, outputwidth, printdata, 
		indices, libname, subpromptlen) =
BEGIN

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine searches the default help libraries and calls the 
!	librarian function to extract help from each help library as
!	required.
!
! INPUTS:
!	
!	keydescs =	address of vector of key descriptors
!
!	outputwidth =	address of longword containing width of output line
!
!	printdata =	address of data structure containing info for 
!			the output driver
!
!	indices =	address of data structure containing indices of
!			libraries currently in use
!
!	libname =	address of descriptor for the user default library name
!
!	subpromptlen =	total length of help keys, zero => at topic prompt level
!
! OUTPUTS:
!
!	printdata =	flags are manipulated by this routine and other
!			values are altered by the output driver
!
!	indices = 	updated to reflect library that help information
!			was eventually extracted from
!
!	libname =	if help found in default user library, updated to
!			the file name of that library
!
! ROUTINE VALUE:
!
!	Always true.
!
!--
MAP
    indices : REF BBLOCK,
    keydescs : REF BBLOCK,
    libname : REF BBLOCK,
    printdata : REF BBLOCK;	

BIND
    main_libindex = indices [hli$l_mainindex],		! Index of /LIB library
    last_libindex = indices [hli$l_lastindex],		! Index of last library examined
    last_libnumber = indices [hli$l_lastnumb],		! No. of last library examined, relative to all default libraries
    print_flags = printdata [hpd$b_printflag] : BBLOCK;	! Flags for output driver

LOCAL
    current_libindex,					! Index of library currently being searched
    current_libnumber,					! Number of library currently being searched
    deflib_acmode : BYTE,				! Logical name table number
    librarystring : BBLOCK [nam$c_maxrss],		! Default library name string
    libraryname : BBLOCK [dsc$c_s_bln],			! String descriptor for library name
    nomsg,						! Open_library message flag
    user_libno,						! HLP$LIBRARY number
    status;

nomsg = true;						! Do not signal error if library can't be opened
print_flags [hpd$v_found] = false;			! Initialize help found flag
libraryname [dsc$a_pointer] = librarystring;		! Initialize descriptor

IF (NOT .subpromptlen)					! If at TOPIC level
   AND ((.help_flags AND hlp$m_all) NEQ 0)		! and default searching enabled
   AND (.keydescs [dsc$w_length] NEQ 0)			! and keys are non-empty
   THEN print_flags [hpd$v_all] = false			! then print help only if found
   ELSE print_flags [hpd$v_all] = true;			! else print help always

IF NOT (status = call_lbrhelp (last_libindex, 
		.outputwidth, .printdata, .keydescs))
   THEN RETURN (.status);

IF .print_flags [hpd$v_found]				! If help was found
   THEN BEGIN						! then done
	print_flags [hpd$v_found] = false;		! Reset flag
	RETURN true;					! Exit
	END;

print_flags [hpd$v_all] = false;			! Print help if found

IF .help_flags [hlp$v_library]				! Check /LIB library 
   AND (.last_libnumber GEQ 0)				! if it exists and
   THEN BEGIN						! if haven't already
	current_libindex = .main_libindex;		! Init libindex
	IF NOT (status = call_lbrhelp (last_libindex, 
		.outputwidth, .printdata, .keydescs))
	   THEN RETURN (.status);
	END;

IF .print_flags [hpd$v_found]				! If help found
   THEN current_libnumber = main_libnumber		! Then set libnumber to main library
   ELSE current_libnumber = -1;				! Else prepare to search default libraries

user_libno = -1;					! Init library translation
WHILE (NOT .print_flags [hpd$v_found]) AND 		! Search libraries
	(tran_next_lib (libraryname, deflib_acmode, user_libno) NEQ 0)
DO BEGIN
   current_libnumber = .current_libnumber + 1;		! Increment current libnumber
   IF .current_libnumber NEQ .last_libnumber 		! If lib not already open and searched
      THEN IF (open_library (current_libindex, libraryname, .nomsg))	! If library successfully opened
	      THEN BEGIN
		   status = call_lbrhelp (last_libindex, 
			   .outputwidth, .printdata, .keydescs);
		   IF NOT .print_flags [hpd$v_found]			! If help not found
		      THEN close_library (current_libindex);		! Then close library
		   IF NOT .status THEN RETURN (.status);		! If error then return
		   END;
    END;

IF NOT .print_flags [hpd$v_found]			! If help still not found
   THEN BEGIN						! Then go back to last library
	current_libindex = .last_libindex;		! Set libindex
	current_libnumber = .last_libnumber;		! Set libnumber
	print_flags [hpd$v_all] = true;			! Print help not available message
	IF NOT (status = call_lbrhelp (last_libindex, 
		.outputwidth, .printdata, .keydescs))
	   THEN RETURN (.status);
	END;

IF (.current_libnumber NEQ .last_libnumber)		! If help found in new library
   THEN BEGIN						! Then clean up
	IF (.last_libnumber GTR external_libnumber)	! If last library not main library
	   THEN close_library (last_libindex);		! Then close that library
	IF (.current_libnumber GTR external_libnumber)	! If new library not main library
	   THEN switch_libname (libraryname, .libname)	! Then change library name
	   ELSE libname [dsc$w_length] = 0;		! Otherwise, simply reset it
	last_libindex = .current_libindex;		! Reset last libindex
	last_libnumber = .current_libnumber;		! Reset last libnumber
	END;

RETURN true;
END;							! Of search_libs

%SBTTL 'Routine change_lib';
ROUTINE change_lib (getcmddesc, charpos, indices, libname) =
BEGIN

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine changes the library context currently in effect to
!	the library specified by the command descriptor.  It also removes
!	the library specification from the command string.
!
! INPUTS:
!	
!	getcmddesc = 	address of descriptor containing the new library name
!
!	charpos =	pointer to "@" preceeding library name
!
!	indices =	address of data structure containing indices of
!			libraries currently in use
!
!	libname =	address of descriptor for the user default library name
!
! OUTPUTS:
!
!	getcmddesc =	library specification is removed from string
!
!	indices = 	if new library successfully found, updated to 
!			reflect library that was specified by the
!			command string
!
!	libprompt =	if new library successfully found, updated to
!			the file name of that library
!
! ROUTINE VALUE:
!
!	True, if new library found.
!	False, if library unchanged.
!--
MAP
    indices : REF BBLOCK,
    getcmddesc : REF BBLOCK;

BIND
    last_libindex = indices [hli$l_lastindex],		! Index of last library examined
    last_libnumber = indices [hli$l_lastnumb];		! No. of last library examined, relative to all default libraries

LOCAL
    current_libindex,					! Index of library currently being searched
    current_libnumber,					! Number of library currently being searched
    deflib_acmode : BYTE,				! Logical name table number
    librarystring : BBLOCK [nam$c_maxrss],		! Default library name string
    libraryname : BBLOCK [dsc$c_s_bln],			! String descriptor for library name
    name_end,						! End of @ string
    name_len,						! Length of @ string
    nomsg,						! Open_library message flag
    temp_end,						! Location of first '/' in command string
    user_libno;						! HLP$LIBRARY number

remove_terminator (.getcmddesc);					! Remove command terminator

IF (.charpos + 1) EQL 							! If no file name
   (.getcmddesc [dsc$w_length] + .getcmddesc [dsc$a_pointer])
   THEN RETURN false;							! Then return false

nomsg = true;								! Do not signal error if library can't be opened
libraryname [dsc$a_pointer] = librarystring;				! Initialize local descriptor
make_upper_case (.getcmddesc, .getcmddesc [dsc$a_pointer]);		! Upper case command

name_len = .getcmddesc [dsc$w_length] + 				! Calculate length of @ to end of line
	   .getcmddesc [dsc$a_pointer] - .charpos;
IF (name_end = CH$FIND_CH (.name_len, .charpos, %C' '))	EQL 0		! If no blank in command string
   THEN name_end = .getcmddesc [dsc$w_length] 				! Then end is end of command
		 + .getcmddesc [dsc$a_pointer];
IF (temp_end = CH$FIND_CH (.name_len, .charpos, %C'/')) NEQ 0 		! If '/' position is before blank pos
   THEN IF .temp_end LSS .name_end	
	   THEN name_end = .temp_end;					! Then end  is position of '/'
name_len = .name_end - .charpos;					! Calculate length of @ string

current_libnumber = -1;							! Init library number
user_libno = -1;							! Init default library searching
WHILE (tran_next_lib (libraryname, deflib_acmode, user_libno)
	EQL true) 
DO BEGIN			

   current_libnumber = .current_libnumber + 1;				! Incr libnumber

   IF (CH$FIND_SUB (.libraryname [dsc$w_length],			! Is command a substring of the library name
	.libraryname [dsc$a_pointer],
	.name_len - 1,
	.charpos + 1)) NEQ 0

      THEN IF (open_library (current_libindex, libraryname, .nomsg))	! If library successfully opened
	      THEN BEGIN
		   IF .last_libnumber GEQ external_libnumber		! If last library not main library
		      THEN close_library (last_libindex);		! Then close it
		   switch_libname (libraryname, .libname);		! Change library name
		   last_libindex = .current_libindex;			! Set libindex
		   last_libnumber = .current_libnumber;			! Set libnumber
		   getcmddesc [dsc$w_length] = 				! Remove @ string from command
			.getcmddesc [dsc$w_length] - .name_len;
		   getcmddesc [dsc$a_pointer] =	
			.getcmddesc [dsc$a_pointer] + .name_len;
		   RETURN true;						! Return success
		   END;

   END;									! Library not found

!
! If library file name was not found in logical name tables,
! then assume that the file name is actually a full file spec
! for a library that exists but is not a user-defined default
! library.  Try to open that library.
!

libraryname [dsc$w_length] = .name_len - 1;				! Initialize library name				
libraryname [dsc$a_pointer] = .charpos + 1;

IF NOT (open_library (current_libindex, libraryname, .nomsg))		! Try opening library
   THEN RETURN false;							! If unsuccessful then give up and signal failure

IF .last_libnumber GEQ external_libnumber				! If last library not main library
   THEN close_library (last_libindex);					! Then close it
switch_libname (libraryname, .libname);					! Change libary name
last_libindex = .current_libindex;					! Set libindex
last_libnumber = -1;							! Set libnumber
getcmddesc [dsc$w_length] = .getcmddesc [dsc$w_length] - .name_len;	! Remove @ string from command
getcmddesc [dsc$a_pointer] = .getcmddesc [dsc$a_pointer] + .name_len;

RETURN true;								! Return success
END;									! Of change_lib

%SBTTL 'Routine switch_libname';
ROUTINE switch_libname (newname, oldname) =
BEGIN

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine inserts a new libname into the old descriptor.
!
! INPUTS:
!	
!	newname = 	address of a descriptor for the new library file name
!
!	oldname = 	address of a descriptor for the old library file name
!
! OUTPUTS:
!
!	oldname = 	updated to specify the name of the new library
!
! ROUTINE VALUE:
!
!	Always true.
!
!--
MAP
    newname : REF BBLOCK,
    oldname : REF BBLOCK;

LOCAL
    colon_pos,		! Pointer to first colon in libname
    start_pos,		! Pointer to start of help file name
    end_pos, 		! Pointer to end of help file name
    liblength;		! Length of help file name

colon_pos = .newname [dsc$a_pointer] - 1;			! Assume newname is preceeded by a colon

WHILE (start_pos = CH$FIND_CH (.newname [dsc$w_length] + 	! Find the next colon
	.newname [dsc$a_pointer] - .colon_pos - 1, 
	.colon_pos + 1, %ASCII ':')) NEQ 0
DO colon_pos = .start_pos;					! Update the pointer if found

start_pos = CH$FIND_CH (.newname [dsc$w_length], 		! Find first close bracket
	.newname [dsc$a_pointer], %ASCII ']');

IF .colon_pos GTR .start_pos					! Set start pointer to greater of
   THEN start_pos = .colon_pos;					! colon ptr and close bracket ptr

start_pos = .start_pos + 1;					! Move start ptr past puctuation mark
liblength = .newname [dsc$w_length] + .newname [dsc$a_pointer] - .start_pos;	! Calculate file name length
end_pos = CH$FIND_CH (.liblength, .start_pos, %ASCII '.');	! Find "." between file name and file type

IF .end_pos NEQ 0						! If "." present
   THEN liblength = .end_pos - .start_pos;			! Calculate new file name length

oldname [dsc$w_length] = .liblength;				! Update old length
CH$MOVE (.liblength, .start_pos, .oldname [dsc$a_pointer]);	! Move file name into old descriptor

RETURN true;
END;								! Of switch_libname

%SBTTL 'Routine tran_next_lib';
ROUTINE tran_next_lib (libname, deflibacmode, userlibno) =
BEGIN

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine returns the value true if a default
!	library if found and false if not.  If a library is found,
!	the library file name is returned in the descriptor libname.
!
! INPUTS:
!	
!	libname =	address of a descriptor to return the library name in
!
!	deflibacmode =	address of a longword containing the access mode of the
!			last logical name table searched
!
!	userlibno =	address of a longword containg the number of the last
!			library found in the last logical name table.  If the
!			number is -1, then start searching the logical name
!			tables all over again.
!
! OUTPUTS:
!
!	libname, deflibacmode, userlibno : as described above
!
! ROUTINE VALUE:
!
!	True, if user default library is found.
!	False, if no more user default libraries left, i.e., at end of tables.
!
!--

MAP
    help_flags : BITVECTOR,
    libname : REF BBLOCK;

BIND
    maxliblen = %CHARCOUNT('HLP$LIBRARY_999');		! Max lib logical name length

OWN
    hlplibnam : COUNTEDSTRING ('HLP$LIBRARY'),		! Initial library logical name
    libnamefao : COUNTEDSTRING ('HLP$LIBRARY_!UW');	! FAO descriptor for general library logical name

LOCAL
    deflibdsbmsk : VECTOR [4,BYTE],			! Logical name table access modes
    deflibnam : VECTOR [maxliblen,BYTE],		! Library logical name buffer
    deflibdesc : BBLOCK [dsc$c_s_bln],			! Library logical name descriptor
    status;						! Status of logical name translation

IF ..userlibno LSS 0							! If starting search at beginning
   THEN BEGIN								! Then initialize access mode and lib no.
	.deflibacmode = 0;
	.userlibno = 0;
	END;

deflibdesc [dsc$w_length] = maxliblen;					! Initialize logical name descriptor
deflibdesc [dsc$a_pointer] = deflibnam;

IF ..userlibno EQL 0							! If first logical name in table
   THEN BEGIN								! Then special case, do not use FAO
	deflibdesc [dsc$w_length] = .hlplibnam [0];
	CH$MOVE (.deflibdesc [dsc$w_length], hlplibnam + 1, deflibnam);
	END

   ELSE BEGIN								! Else use FAO to combine logical name string and no.
	deflibdesc [dsc$w_length] = .libnamefao [0];
	CH$MOVE (.deflibdesc [dsc$w_length], libnamefao + 1, deflibnam);
	IF NOT $FAO (deflibdesc, deflibdesc, deflibdesc, ..userlibno)
	   THEN RETURN false;
	END;

IF .help_flags [..deflibacmode + 1] NEQ 0				! If searching of current logical name table is enabled
   THEN BEGIN								! Then translate logical name for this table
	deflibdsbmsk = %X'00060503';
	libname [dsc$w_length] = nam$c_maxrss;
	status = $TRNLOG (LOGNAM = deflibdesc,
			DSBMSK = .deflibdsbmsk [..deflibacmode],
			RSLLEN = .libname,
			RSLBUF = .libname);
	IF .status AND (.status NEQ SS$_NOTRAN)				! If logical name is successfully translated
	   THEN BEGIN
		.userlibno = ..userlibno + 1;				! Then increment lib no. for next search
		RETURN true;						! And return true
		END;
	END;

!
! If current logical name table not enabled or logical name unsuccessfully
! translated, then recursively call this routine to search next table.
!

IF (.deflibacmode = ..deflibacmode + 1) GTR 2				! Increment access mode
   THEN RETURN false;							! If out of tables, then return false
.userlibno = 0;								! Reset lib no. to start of table
RETURN tran_next_lib (.libname, .deflibacmode, .userlibno);		! Make recursive call

END;									! Of tran_next_lib

%SBTTL 'Routine open_library';
ROUTINE open_library (libindex, libname, nomsgflag) =
BEGIN

!++
! FUNCTIONAL DESCRIPTION:
!
! 	Open the library with the specified name and return its index.
!
! INPUTS:
!
!	libindex =	address of longword to contain index of opened library
!
!	libname =	address of descriptor for library name
!
!	nomsgflag =	flag that is true if open errors should not be signalled
!
! OUTPUTS:
!
!	libindex : as described above
!
! ROUTINE VALUE:
!
!	True, if library successfully opened.
!	False, if unsuccessful.
!
!--

MAP
    libname : REF BBLOCK;

EXTERNAL
    lbr$gl_rmsstv : ADDRESSING_MODE (GENERAL);		! RMS STV from librarian

LOCAL
    filnamdesc : BBLOCK [dsc$c_s_bln],			! Library name descriptor
    help_defname : BBLOCK [dsc$c_s_bln], 		! Default filename descriptor
    helpfilename : BBLOCK [nam$c_maxrss],		! Resultant file name
    help_func,						! Library access type
    help_type,						! Type of library
    namblk : BBLOCK [nam$c_bln],			! Library name block
    status;

$NAM_INIT (NAM = namblk,				! Initialize the NAM block
	   RSS = nam$c_maxrss,
	   RSA = helpfilename,
	   ESS = nam$c_maxrss,
	   ESA = helpfilename);

help_func = lbr$c_read;					! Will be reading the library
help_type = lbr$c_typ_hlp;				! Library is of help type

!
! Call librarian to initialize control.  Stop if error.
!

IF NOT (status = lbr$ini_control (.libindex, help_func, help_type, namblk))
THEN
    BEGIN
    SIGNAL (.status);
    RETURN .status;
    END;

!
! Call librarian to open library.  Stop if error should be flagged.
!

help_defname [dsc$w_length] = .syshelp [0];		! Initialize default library directory and type
help_defname [dsc$a_pointer] = syshelp [1];

IF NOT (status = lbr$open (.libindex, .libname, 0, help_defname))
   AND NOT .nomsgflag
   THEN BEGIN
	IF (filnamdesc [dsc$w_length] = .namblk [nam$b_esl]) NEQ 0
	   THEN filnamdesc [dsc$a_pointer] = .namblk [nam$l_esa]
	   ELSE BEGIN
		filnamdesc [dsc$w_length] = .libname [dsc$w_length];
		filnamdesc [dsc$a_pointer] = .libname [dsc$a_pointer];
		END;
	SIGNAL (shr$_openin OR hlp$c_facility OR sts$k_severe,
			1, filnamdesc, .status, .lbr$gl_rmsstv);
	END;

RETURN .status;

END;							!Of open_library

%SBTTL 'Routine close_library';
ROUTINE close_library (libindex) =
BEGIN

!++
! FUNCTIONAL DESCRIPTION:
!
! 	Close the open help library.
!
! INPUTS:
!
!	libindex =	address of longword containing index of library to close.
!
! OUTPUTS:
!
!	None.
!
! ROUTINE VALUE:
!
!	Always true.
!
!--

LOCAL
    status;

IF NOT (status = lbr$close (.libindex))
   THEN SIGNAL (.status);

RETURN true

END;						!Of close_library

%SBTTL 'Routine setup_keys';
ROUTINE setup_keys (getcmddesc, keydescs, truekeys) =
BEGIN

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine divides the descriptor for the line of keys into 
!	individual descriptors for the individual keys.
!
! INPUTS:
!
!	getcmddesc =	address of descriptor for the set of keys currently being
!			processed
!
!	keydescs =	address of vector of key descriptors to be returned
!
!	truekeys =	address of longword to contain the number of keys found
!
! OUTPUTS:
!
!	keydescs, turekeys : as described above	
!
! ROUTINE VALUE:
!
!--

MAP
    truekeys : REF VECTOR [,BYTE],
    getcmddesc : REF BBLOCK,
    keydescs : REF VECTOR [,BYTE];

LOCAL
    paren,		! Pointer to a left parenthesis
    parm_begin,		! Pointer to beginning of current key
    parm_end,		! Pointer to end of current key
    next_qual,		! Pointer to next qualifier
    line_end;		! Pointer to end of keys

paren = %ASCII '(';							! Init paren ptr
CH$FILL (0, dsc$c_s_bln * hlp$c_maxkeys, .keydescs);			! Clear key descriptors

!
! Convert command line to upper case.  Then find the start of the help
! keys, and fill in descriptors for them.
!

make_upper_case (.getcmddesc, .getcmddesc [dsc$a_pointer]);		! Convert command line to upper case
parm_end = .getcmddesc [dsc$a_pointer];					! Initialize pointers
line_end = .getcmddesc [dsc$a_pointer] + .getcmddesc [dsc$w_length];
next_qual = CH$FIND_CH (.getcmddesc [dsc$w_length],
			.getcmddesc [dsc$a_pointer], %ASCII '/');

INCRU level FROM 0 TO hlp$c_maxkeys - 1					! Loop to search for keys
DO BEGIN

   DO BEGIN								! Find first key that doesn't start with '('
   IF (parm_begin = CH$FIND_NOT_CH (.line_end - .parm_end,		! Find start of key
				.parm_end, %ASCII ' ')) EQL 0
      THEN parm_begin = .line_end;					! Set right if none found

   IF .next_qual NEQ 0							! If there is a qualifier
      AND .parm_begin GEQU .next_qual					! and qualifier is closer
      THEN BEGIN
	   parm_begin = .next_qual;					! then pick up the qualifier
	   next_qual = CH$FIND_CH (.line_end - .parm_begin - 1, 	! and find the next one
			.parm_begin + 1, %ASCII '/');
	   END;

   IF (parm_end = CH$FIND_CH (.line_end - .parm_begin,			! Find end of key
			      .parm_begin, %ASCII ' ')) EQL 0
      THEN parm_end = .line_end;

   IF .next_qual NEQ 0							! If a qualifier on line
      AND .parm_end GTRU .next_qual					! and qualifier is closer
      THEN parm_end = .next_qual;					! then it marks end of current parameter

   END									! Of until loop

   UNTIL (.parm_end - .parm_begin EQL 0 				! No more keys
         OR CH$NEQ (1, .parm_begin, 1, paren));				! or, key that starts with non-(

!
! Fill in string descriptor
!

    BEGIN

	BIND
	    curkeydesc = keydescs [dsc$c_s_bln * .level] : BBLOCK;	! Descriptro for current key

	IF (curkeydesc [dsc$w_length] = .parm_end - .parm_begin) EQL 0	! If key length is zero
	   THEN BEGIN
		IF .level EQL 0						! And level agrees that really no more keys
		   THEN prompt_flags = .prompt_flags OR hcf$m_stay;	! Then set prompt flag
		truekeys [0] = .level;					! Set number of keys
		EXITLOOP;						! And exit	
		END;
	curkeydesc [dsc$a_pointer] = .parm_begin;	 		!Set pointer to start of key
	END;
    END;								!Of INCRU loop

RETURN true

END;									!Of setup_keys

%SBTTL 'Routine call_lbrhelp';
ROUTINE call_lbrhelp (helplibindex, outputwidth, printdata, keydescs) =
BEGIN

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine calls the librarian function to extract help from 
!	a particular help library.
!
! INPUTS:
!	
!	helplibindex =	address of longword containing help library index
!
!	outputwidth =	address of longword containing width of output line
!	
!	printdata =	address of data structure containg information for
!			the output driver
!
!	keydescs =	address of vector of individual descriptors for each keyword
!
! OUTPUTS:
!
!	None.
!
! ROUTINE VALUE:
!
! 	Status of call for help.
!
!--

MAP
    keydescs : REF VECTOR [,BYTE];

LOCAL
    status:	BBLOCK [LONG];

EXTERNAL
    lbr$gl_control : REF BBLOCK;		! Pointer to current library control block

BIND 
    context = .lbr$gl_control [lbr$l_ctxptr] : BBLOCK;

!
! Set this bit to make LBR$GET_HELP handle the help on help case correctly.
! This bit is not universally set for V2.0 compatibility reasons.
!
context [ctx$v_outputhlp] = true;
status = lbr$get_help (.helplibindex, .outputwidth,
		output_driver, .printdata,
		keydescs [dsc$c_s_bln * 0], keydescs [dsc$c_s_bln * 1],
		keydescs [dsc$c_s_bln * 2], keydescs [dsc$c_s_bln * 3],
		keydescs [dsc$c_s_bln * 4], keydescs [dsc$c_s_bln * 5],
		keydescs [dsc$c_s_bln * 6], keydescs [dsc$c_s_bln * 7],
		keydescs [dsc$c_s_bln * 8], keydescs [dsc$c_s_bln * 9]);
context [ctx$v_outputhlp] = false;

IF .status EQL lbr$_endtopic			! Abort help on this topic?
   THEN status = true;				! Yes, then change error to true

RETURN .status
END;						! Of call_lbrhelp

%SBTTL 'Routine output_driver';
ROUTINE output_driver (linedesc, helpflags, printdata, helplevel) =
BEGIN

!++
! FUNCTIONAL DESCRIPTION:
!
! 	Call user supplied output routine to print a line of help text
!	Also set various prompt flags and set initialize pointer user for
!	putting keys into subprompt buffer.
!
! INPUTS:
!
!	linedesc =	address of descriptor for line to be output
!
!	helpflags = 	address of flag longword describing contents of
!			text that is passed
!
!	printdata =	address of data structure containing flags, levels,
!			and other data for the output driver
!
!	helplevel =	address of longword containing the current key level
!
! OUTPUTS:
!
!	The various data items in printdata are updated and the user supplied
!	output routine is called to output the linedesc.
!
! ROUTINE VALUE:
!
!	False, if call to user supplied routine returns false.
!	True, otherwise.
!--

MAP
    linedesc : REF BBLOCK,
    printdata : REF BBLOCK;

BIND
    true_keys = printdata [hpd$b_truekeys] : SIGNED BYTE,	! Number of help keys
    help_level = printdata [hpd$b_helplevel] : BYTE,		! Current key depth
    print_flags = printdata [hpd$b_printflag] : BBLOCK,		! Flags for output driver
    add_info_level = printdata [hpd$l_subpmtlev],		! Current prompt level
    sub_prompt_ptr = printdata [hpd$l_subpmtptr],		! Ptr used for filling sub-prompt buffer
    length_array = printdata [hpd$l_lenarray] : REF VECTOR,	! Address of key length array
    output_routine = printdata [hpd$l_outputrou];		! User specified output routine	

OWN
    topics_available : COUNTEDSTRING ('Information available:');

LOCAL
    keylevel,							! Local equivalent of parameter helplevel
    flags,							! Local equivelent of parameter helpflags
    output_buf : BBLOCK [hlp$c_pagesize],			! Local buffer to store line to be output
    output_desc : BBLOCK [dsc$c_s_bln],				! Local output descriptor
    ptr,							! Pointer into output buffer
    spaces : WORD,						! Number of spaces to indent output line
    status;

status = true;							! Status if user output routine never called
flags = ..helpflags;						! Copy helpflags locally

IF NOT .print_flags [hpd$v_all] AND				! If not printing all help text
   ((.flags AND hlp$m_nohlptxt) NEQ 0)				! and no help text found
   THEN BEGIN							
	print_flags [hpd$v_found] = false;			! Then set no help found flag
	RETURN true;						! And return
	END;

print_flags [hpd$v_found] = true;				! Else say help was found
print_flags [hpd$v_all] = true;					! Keyword was found, so this will ensure that more libraries
								!  will not be search, even if no text follows keyword
keylevel = ..helplevel;						! Copy key level locally
output_desc = 0;						! Init local descriptor for output line
output_desc [dsc$w_length] = .linedesc [dsc$w_length];	
output_desc [dsc$a_pointer] = output_buf;

IF .flags EQL 0							! If help info found
   THEN prompt_flags = .prompt_flags OR hcf$m_info; 		! Then say so

! 
! If processing key name and moving down a prompt level,
! then build subtopic prompt
!

IF ((.flags AND hlp$m_keynamlin) NEQ 0) AND
   ((.prompt_flags AND hcf$m_stay) EQL 0)
   THEN BEGIN				
	IF (.prompt_flags AND hcf$m_info) NEQ 0
	   THEN prompt_flags = .prompt_flags OR hcf$m_stay 
	   ELSE BEGIN
		IF (.keylevel NEQ .help_level) AND (.output_desc [dsc$w_length] NEQ 0)
		   THEN BEGIN				
			help_level = .keylevel;
			CH$MOVE (.output_desc [dsc$w_length], .linedesc [dsc$a_pointer],
				 .sub_prompt_ptr);	
			length_array [.help_level] = .output_desc [dsc$w_length];
			sub_prompt_ptr = .sub_prompt_ptr + .output_desc [dsc$w_length];
			(.sub_prompt_ptr)<0,8> = 32;
			sub_prompt_ptr = .sub_prompt_ptr + 1;
			END;
	        END;
	add_info_level = .keylevel;
	END;

!
! If no help text found, then stay at current level and signal that
! help was not found.
! 

IF (.flags AND hlp$m_nohlptxt) NEQ 0
	THEN BEGIN
             prompt_flags = .prompt_flags OR hcf$m_stay; 
	     IF (.print_flags [hpd$v_init] EQL 0)
		THEN print_flags [hpd$v_init] = 1;	
	     END;

!
! If additional info to be found, say so
!

IF (.flags AND hlp$m_otherinfo) NEQ 0
   THEN prompt_flags = .prompt_flags OR hcf$m_more; 	

!
! Format output line and then call user supplied output routine.
!

IF ((.true_keys NEQ 0) OR 			! Not at first topic level
   .help_flags [hlp$v_help] OR			! Want help on help with topic list
   ((.flags AND hlp$m_otherinfo) NEQ 0))	! List of additional info
   THEN IF (.keylevel GTR 0) OR
	   ((.flags AND hlp$m_keynamlin) EQL 0)
	   THEN BEGIN
		IF .linedesc [dsc$w_length] NEQ 0
		   THEN BEGIN

			IF ((.flags AND hlp$m_keynamlin) NEQ 0)
			   THEN spaces = (.keylevel - 1) * hlp$c_indent
			   ELSE IF ((.flags AND hlp$m_nohlptxt) NEQ 0)
				   AND (.keylevel EQL 0)
				   THEN spaces = hlp$c_indent
				   ELSE spaces = .keylevel * hlp$c_indent;

			ptr = CH$FILL (%ASCII ' ' , .spaces, output_buf);
			IF ((.true_keys EQL 0) AND NOT .help_flags [hlp$v_help])
			   THEN BEGIN
				true_keys = -1;
				output_desc [dsc$w_length] = .topics_available [0];
				CH$MOVE (.output_desc [dsc$w_length], topics_available + 1, .ptr);
				END 
			   ELSE BEGIN
				CH$MOVE (.output_desc [dsc$w_length], .linedesc [dsc$a_pointer], .ptr);
				END;
			output_desc [dsc$w_length] = .spaces + .output_desc [dsc$w_length];
			END;

		status = (.output_routine) (output_desc);

		END;

RETURN .status;
END;						!Of output_driver

%SBTTL 'Routine libs_available';
ROUTINE libs_available (outputroutine, outputwidth) =
BEGIN

!++
! FUNCTIONAL DESCRIPTION
!
!	Output a list of the define default libraries.
!
! INPUTS:
!
!	outputroutine = address of the user supplied output routine
!
!	outputwidth = 	address of a longword containing the output line width
!
! OUTPUTS: 
!
!	The list is output by using the user supplied routine.
!
! ROUTINE VALUE:
!
!	Always true.
!--

LOCAL
    acmode,
    blank_line : BBLOCK [dsc$c_s_bln],
    filespec : BBLOCK [dsc$c_s_bln],
    filespec_buf : BBLOCK [nam$c_maxrss],
    filename : BBLOCK [dsc$c_s_bln],
    filename_buf : BBLOCK [9],
    libno,
    output_desc : BBLOCK [dsc$c_s_bln],
    output_buf : BBLOCK [hlp$c_pagesize],
    status;

OWN
    header : COUNTEDSTRING ('  Additional help libraries available (type @name for topics):');

filespec = 0;						! Init file spec desc
filespec [dsc$a_pointer] = filespec_buf;

libno = -1;						! Init search
status = false;						! Init status

WHILE NOT .status					! Loop searching for a library
DO BEGIN
   IF NOT tran_next_lib (filespec, acmode, libno)	! Get first lib spec
      THEN RETURN true;					! If none, then return
   status = file_present (filespec);			! Is file present?
   END;

filename = 0;						! Init file name desc
filename [dsc$a_pointer] = filename_buf;

blank_line = 1;						! Init blank line desc
blank_line [dsc$a_pointer] = output_buf;

output_desc = .header [0];				! Init header desc
output_desc [dsc$a_pointer] = header [1];

(.outputroutine) (blank_line);				! Output header
(.outputroutine) (output_desc);
(.outputroutine) (blank_line);

output_desc = 0;					! Reuser output desc for
output_desc [dsc$a_pointer] = output_buf;		! lib name lists
CH$FILL (%X'20', ..outputwidth, output_buf);

switch_libname (filespec, filename);			! Get first lib name
output_desc [dsc$w_length] = 13;			! Move it into the list
CH$MOVE (.filename [dsc$w_length], filename_buf, output_buf + 2);

WHILE tran_next_lib (filespec, acmode, libno)		! While more libs
DO IF file_present (filespec)				! Build list and output
      THEN BEGIN
	   IF ((.output_desc [dsc$w_length] + 11) GEQ ..outputwidth)
	      THEN BEGIN
		   (.outputroutine) (output_desc);
		   output_desc [dsc$w_length] = 2;
		   CH$FILL (%X'20', ..outputwidth, output_buf);
		   END;
	   switch_libname (filespec, filename);
	   CH$MOVE (.filename [dsc$w_length], filename_buf,
		   output_buf + .output_desc [dsc$w_length]);
	   output_desc [dsc$w_length] = .output_desc [dsc$w_length] + 11;
	   END;

(.outputroutine) (output_desc);				! Output last line built
RETURN true;
END;

%SBTTL 'Routine file_present';
ROUTINE file_present (filename) =
BEGIN

!++
! FUNCTIONAL DESCRIPTION:
!
!	Return success if the file exists.
!
! INPUTS:
!
!	filename = address of desc of file name
!
! OUTPUTS:
!
!	None.
!
! ROUTINE VALUE:
!
!	True, if file exists
!	False, if it doesn't
!
!--

MAP
    filename : REF BBLOCK;

LOCAL
    fab : BBLOCK [fab$c_bln],
    nam : BBLOCK [nam$c_bln],
    string : BBLOCK [nam$c_maxrss],
    status;

$NAM_INIT ( NAM = nam,
	    ESS = nam$c_maxrss,
	    ESA = string);

$FAB_INIT ( FAB = fab,
	    FNS = .filename [dsc$w_length],
	    FNA = .filename [dsc$a_pointer],
	    DNS = .syshelp [0],
	    DNA = syshelp [1],
	    NAM = nam);

IF (status = $PARSE (FAB = fab))
   THEN (status = $SEARCH (FAB = fab));

RETURN .status;
END;

%SBTTL 'Routine nohelp_log';
ROUTINE nohelp_log (logdesc) =
BEGIN

!++
! FUNCTIONAL DESCRIPTION:
!
! 	If the logical name for a log file is defined, then put a record 
!	into the specified log file.  If that file does not already exist,
!	then create it.
!
! INPUTS:
!
!	logdesc = address of string descriptor for record to be output
!
! OUTPUTS:
!
!	None.
!
! ROUTINE VALUE:
!
!	Always true.
!
!--

MAP
     logdesc : REF BBLOCK;				!Descriptor of log record

LOCAL
     logresult	: VECTOR [nam$c_maxrss, BYTE],		!Space for HELP$LOG resultant filename
     logrsdesc	: BBLOCK [dsc$c_s_bln],			!Descriptor for result name
     lognam	: BBLOCK [nam$c_bln],			!NAM block for HELP$LOG
     logfab	: BBLOCK [fab$c_bln],			!FAB for output to HELP$LOG
     lograb	: BBLOCK [rab$c_bln],			!RAB for output to HELP$LOG
     logfile	: BBLOCK [dsc$c_s_bln],
     logfiletrn : BBLOCK [dsc$c_s_bln],			!Descriptor for HELP$LOG translation
     status;

OWN
     logstring : COUNTEDSTRING ('HELP$LOG');

logfile [dsc$w_length] = .logstring [0];		! Initialize logical name
logfile [dsc$a_pointer] = logstring [1];

logfiletrn [dsc$w_length] = nam$c_maxrss;		! Initialize descriptor for logical
logfiletrn [dsc$a_pointer] = logresult;			! name translation

$NAM_INIT ( NAM = lognam,				! Initialize name block
	    ESS = nam$c_maxrss,
	    ESA = logresult,
	    RSS = nam$c_maxrss,
	    RSA = logresult);

$FAB_INIT ( FAB = logfab,				! Initialize fab
	    FNS = .logfile [dsc$w_length],
	    FNA = .logfile [dsc$a_pointer],
	    FAC = PUT,
	    FOP = CIF,
	    RAT = CR,
	    NAM = lognam);

$RAB_INIT ( RAB = lograb,				! Initialize rab
	    FAB = logfab, 
	    ROP = EOF);

!
! If HELP$LOG can be successfully translated,
! 	1.  Create the file if it doesn't already exist.
!	2.  Connect to that file.
!	3.  Write the record to that file.
!	4.  Clean up afterwards.
!

IF ((status = $TRNLOG (LOGNAM = logfile, RSLBUF = logfiletrn))
   AND (.status NEQ SS$_NOTRAN))   THEN IF (status = $CREATE (FAB = logfab))
	THEN BEGIN
	     IF (status = $CONNECT (RAB = lograb))
		THEN BEGIN
		     lograb [rab$w_rsz] = .logdesc [dsc$w_length];
		     lograb [rab$l_rbf] = .logdesc [dsc$a_pointer];
		     logrsdesc [dsc$w_length] = .lognam [nam$b_rsl];
		     logrsdesc [dsc$a_pointer] = .lognam [nam$l_rsa];
		     $PUT (RAB = lograb);
		     IF NOT (status = $DISCONNECT (RAB = lograb))
			THEN SIGNAL ((shr$_closeout OR hlp$c_facility OR sts$k_warning),
				     1, logrsdesc, .status, .lograb [rab$l_stv]);
		     END;
	    IF NOT (status = $CLOSE (FAB= logfab))
	       THEN SIGNAL ((shr$_closeout OR hlp$c_facility OR sts$k_warning),
			    1, logrsdesc, .status, .lograb [rab$l_stv]);
	    END;
RETURN true
END;							!Of nohelp_log

%SBTTL 'Routine remove_last_key';
ROUTINE remove_last_key (stringdescr, last_key_length) =
BEGIN

!++
! FUNCTIONAL DESCRIPTION:
!
! 	Remove the last keyword in the supplied string descriptor.
!
! INPUTS:
!
!	stringdescr = 	address of string descriptor for input text string
!
!	last_key_length = the length of the key that is to be removed
!
! OUTPUTS:
!
!	stringdescr =	input descriptor with last key removed
!
! ROUTINE VALUE:
!
!	Always true.
!
!--

MAP
    stringdescr : REF BBLOCK;

LOCAL
    last_char;						! Pointer to last character of the last key

last_char = .stringdescr [dsc$w_length] 		! Find last char before " subtopic? "
	  + .stringdescr [dsc$a_pointer] - 12
	  - .last_key_length;

CH$MOVE (.subtopic [0], subtopic [1], .last_char + 1);	! Replace "subtopic? " string
stringdescr [dsc$w_length] = .last_char + 11		! Calculate new length
			  - .stringdescr [dsc$a_pointer];

RETURN true;
END;							! Of remove_last_key

%SBTTL 'Routine remove_terminator';
ROUTINE remove_terminator (stringdescr) =
BEGIN

!++
! FUNCTIONAL DESCRIPTION:
!
! 	Remove the termination characters at the end of the string descriptor.
!
! INPUTS:
!
!	stringdescr = 	address of string descriptor for input text string
!
! OUTPUTS:
!
!	stringdescr = 	input descriptor with termination characters removed
!
! ROUTINE VALUE:
!
!	Always true.
!
!--

MAP
    stringdescr : REF BBLOCK;

WHILE (CH$RCHAR (.stringdescr [dsc$a_pointer] 			! While termination character present
		+ .stringdescr [dsc$w_length] - 1) LSS %X'20')
      AND (.stringdescr [dsc$w_length] GTR 0)
DO stringdescr [dsc$w_length] = .stringdescr [dsc$w_length] - 1;! Remove terminator

RETURN true;
END;								! Of remove_terminator

%SBTTL 'Routine make_upper_case';
ROUTINE make_upper_case (idesc, oname) =
BEGIN

!++
! FUNCTIONAL DESCRIPTION:
!
! 	Upper case the name described by string descriptor idesc and
! 	put the name at location oname.
!
! INPUTS:
!
!	idesc = 	address of string descriptor for input text string
!
!	oname = 	address of buffer to contain uppercase output string
!
! OUTPUTS:
!
!	oname : as described above
!
! ROUTINE VALUE:
!
!	Always true.
!
!--

MAP
    idesc : REF BBLOCK,
    oname : REF VECTOR[,BYTE];

BIND
    namlen = idesc[dsc$w_length] : WORD,
    iname = idesc[dsc$a_pointer] : REF VECTOR[,BYTE];

IF .namlen GTRU 0						! If non-empty string
   THEN INCRU i FROM 0 TO .namlen-1				! Then for each character

DO IF .iname[.i] GEQU %ASCII'a'					! Convert character to uppercase and copy
      AND .iname[.i] LEQU %ASCII'z'
      THEN oname[.i] = .iname[.i] - (%ASCII'a' - %ASCII'A')
      ELSE IF .iname[.i] EQL 9
	      THEN oname[.i] = 32
	      ELSE oname[.i] = .iname[.i];

RETURN true

END;								!Of make_upper_case

END								!Of module
ELUDOM
