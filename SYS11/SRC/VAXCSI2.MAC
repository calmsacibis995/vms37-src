	.TITLE	.CSI2	 VAX/VMS CSI2
	.IDENT	/V03000/

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++ 
; FACILITY:
;
;	VAX/VMS RSX11M SUPPORT ROUTINES
;
; ABSTRACT:
;
;	THIS MODULE REPLACES THE TRADITIONAL CSI1 FOR RSX11M TASKS
;	RUNNING UNDER VAX/VMS. THIS MODULE PARSES VAX/VMS FILE SPECS.
;
; AUTHOR:
;
;	R.HEINEN FOR VAX/VMS FROM A MAROTTO'S AND C. D'ELIA'S RSX11M CSI
;--
;
; LOCAL STORAGE
;
 
	.PSECT	.CSID
	.MCALL	GTSK$S
;
; LOCAL DEFINITIONS
;
ASVAL=1					;SWITCH VALUE TABLE ASCII CVT CODE
DECVAL=3				;SWITCH TABLE VALUE FOR DECIMAL CONVERT
;
; DEVICE AND DIRECTORY PARSE CONTROL STRINGS
;
DVVECT:	.BYTE	C.IDVL,COLON,0,0,CS.DVF,C.DVLN,0,COLON
DIVECT:	.BYTE	C.IDIL,RBRAC,1,0,CS.DIF,C.DILN,1,RBRAC
;
; TABLE OF DELIMETERS
;
	.ASCII	/=/
DELSTR:	.ASCII	.=:[]<>/,.

	.SBTTL	.CSI2 - RETURN NEXT COMMAND FILE SPECIFICATION
 
	.PSECT	.CSII
 
;++
; .CSI2 - RETURN NEXT COMMAND FILE SPECIFICATION
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE FILLS A DATA BASE AS REQUESTED TO REFLECT THE NEXT
; FILE SPECIFICATION IN A COMMAND STRING. THE STRING AND DATABASE
; HAVE ALREADY BEEN PROCESSED BY ".CSI1".
;
; INPUTS:
;
;	R0 = ADDRESS OF THE CSI REQUEST CONTROL BLOCK
;
; OUTPUTS:
;
;	C-BIT SET ON ERROR, CLEAR ON SUCCESS
;
;	R0 = ADDRESS OF THE CONTROL BLOCK
;--
.CSI2::					;
	JSR	R5,.SAVR1		; SAVE REGISTERS
	BICB	#^C<CS.EQU>,C.STAT(R0); CLEAR MOST STATUS BITS
	CLR	C.MKW1(R0)		;CLEAR SWITCHES MASK
	CLR	C.MKW2(R0)
	CLR	R1			;SET INPUT SWITCHES
	MOV	C.ISTR(R0),R2		;GET INPUT STRING ADDR
	CMPB	#CS.INP,(R0)		;BRANCH IF INPUT REQUEST
	BEQ	20$
	CMPB	#CS.OUT,(R0)		;BRANCH IF OUTPUT REQUEST
	BEQ	10$
	SEC				;SET ERROR
	RTS	PC			;EXIT
10$:	INC	R1			;SET OUTPUT SWITCH
	MOV	C.OSTR(R0),R2		;GET OUTPUT STRING ADDR
;
; PICK UP COMMAND PARSE STYLE FLAG
;
	SUB	#32.,SP			;
	MOV	SP,R3			; SET ADDRESS
	GTSK$S	R3			;
	CMP	8.(R3),#^RVMS		; VMS?
	BNE	15$			; IF NEQ THEN NO
	CMP	10.(R3),#^RMCR		; MCR?
	BEQ	15$			; IF NE THEN NO
	CLR	C.ODVL(R0)		; SET NO EXPLICIT DEVICE
	CLR	C.ODIL(R0)		; AND NO DIRECTORY
15$:	ADD	#32.,SP			; REMOVE FORM STACK
20$:	JSR	PC,DELSCN		;SCAN TO A DELIM
	MOV	#DVVECT,R3		;ADDR DEV INFO CTL VECT
	JSR	PC,DIDVSN		;DO DEV PROCESSING
	MOV	#DIVECT,R3		;ADDR DIR INFO CTL VECT
	JSR	PC,DIDVSN		;DO DIR PROCESSING
	MOV	R2,C.FNAD(R0)		;SET FILE NAME ADDR
	MOV	R4,R3
	SUB	R2,R3			;CALC FILE NAME LEN
	MOV	R3,C.FNLN(R0)		;SET FILE NAME LENGTH
	BEQ	30$			;BRANCH IF NONE
	BISB	#CS.NMF,C.STAT(R0)	;SET FILE NAME FOUND STATUS
	JSR	PC,WILDCK		; CHECK FOR WILD CARDS
30$:	MOV	R4,R2			;POINT TO LAST FOUND DELIM
	CLR	R4			;CLEAR ERROR SWITCH
	CMPB	#SLASH,R5
	BNE	40$			;BRANCH IF NO SWITCHES
	JSR	PC,SWITCH		;GO PROCESS SWITCHES
40$:	CMPB	#EQUAL,R5		;BRANCH IF AT END OF STRING
	BEQ	50$
	BISB	#CS.MOR,C.STAT(R0)	;ELSE SET MORE STRINGS FOLLOW
	INC	R2			;STEP OVER LAST DELIMITER
50$:	TST	R1
	BNE	60$			;BRANCH IF OUTPUT
	MOV	R2,C.ISTR(R0)		;SAVE INPUT STRING PTR
	BR	100$
60$:	MOV	R2,C.OSTR(R0)		;SAVE OUTPUT STRING PTR
100$:	ROR	R4			;SET ERROR VALUE(C-BIT ON IF ERROR)
	RTS	PC			;EXIT

	.SBTTL	SWITCH - PROCESS SWITCHES
;++
; SWITCH - PROCESS SWITCHES
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE PROCESSES ALL SWITCHES PRESENT IN THE PRESENT FILE SPEC.
;
; INPUTS:
;
;	R0 = ADDRESS OF THE CONTROL BLOCK
;	R2 = ADDRESS OF THE CURRENT DELIMETER "/"
;	R5 = ADDRESS OF THIS SPEC END
;
; OUTPUTS:
;
;	R0 = ADDRESS OF THE CONTROL BLOCK
;	R4 = ERROR INDICATION ( 1 IF ERROR )
;	R5 = ADDRESS OF THIS SPEC END
;--
SWITCH:	INC	R2			;STEP OVER THE CURRENT DELIMITER
	CALL	DELSCN			;AND SCAN TO THE NEXT ONE
	MOV	R4,-(SP)		;SAVE THE DELIMITER POINTER
	MOV	R5,-(SP)		;AND THE CHARACTER ITSELF
	CLR	-(SP)			;INIT NEGATED FLAG TO NOT NEGATED
;
; CHECK FOR NEGATED SWITCH
;
	MOV	R4,R3	
	SUB	R2,R3			;R3=SIZE OF SWITCH STRING
	BLE	130$			;IF NO CHARACTER, THEN ERROR
	CMPB	#MINUS,(R2)		;NEGATED WITH "-"?
	BEQ	10$			;BRANCH IF YES
	CMP	R3,#2			;IF 2 OR LESS CHAACTERS
	BLE	40$			;THEN CAN'T BE "NO..."
	CMPB	#'N,(R2)		;SEE IF "NO" ON FRONT
	BNE	40$
	CMPB	#'O,1(R2)
	BNE	40$
;
; STRIP OFF THE "NO" AND ASSUME THE SWITCH IS NEGATED
; BUT IT THE LOOKUP FAILS, TRY AGAIN WITH THE ENTIRE SWITCH NAME
;
	INC	R2			;SKIP OVER THE "N"
10$:	INC	R2			;SKIP OVER THE "O" OR "-"
	INC	(SP)			;INDICATE THAT SWITCH IS NEGATED
	MOV	R4,R3
	SUB	R2,R3			;R3=SIZE OF SWITCH TO SCAN FOR
	MOV	R2,-(SP)		;SAVE ADDRESS OF START OF SWITCH
	CALL	SWMAT			;SEE IF THIS SWITCH IS IN SWITCH TABLE
	MOV	(SP)+,R2		;RESTORE POINTER TO SWITCH
	BCS	30$			;BRANCH IF SWITCH NOT FOUND
	BIT	#1,4(R4)		;IS SWITCH NEGATABLE?
	BNE	50$			;BRANCH IF YES, COMPLETE THE PORCESSING
30$:	CMPB	#MINUS,-(R2)		;WAS THE NEGATION WITH "-"
	BEQ	130$			;BRANCH IF YES, SWITCH NOT FOUND
	CLR	(SP)			;SAY NOT NEGATED
	DEC	R2			;BACK OVER THE "N"
	MOV	4(SP),R3		;RECOVER THE NEXT DELIMITER POINTER
	SUB	R2,R3			;R3=SIZE OF SWITCH TO LOOK FOR
40$:	CALL	SWMAT			;MATCH THE SWITCH
	BCS	130$			;BRANCH IF NOT FOUND
50$:	BIS	(R4),C.MKW1(R0)		; SET 'OR' OF MASK WORDS
	TST	(SP)			;BRANCH IF NEG SWITCH
	BNE	60$
	BIS	(R4),C.MKW2(R0)		; SET SWITCH ON
	BR	70$
60$:	BIT	#1,4(R4)		; IS NEGATIVE SWITCH ALLOWED?
	BEQ	130$			;ERROR IF NOT
	BIC	(R4),C.MKW2(R0)		; SET SWITCH OFF
70$:	MOV	2(R4),R5		; ADDR OF LOCN TO BE MASKED
	CLC
	ROR	R5
	BEQ	110$			;BRANCH IF NO MASK ADDR
	BCS	90$			;BRANCH IF TO CLEAR LOCN WITH MASK
	ROL	R5
	TST	(SP)			;BRANCH IF NEG SW TO CLEAR
	BNE	100$
80$:	BIS	(R4),(R5)		; CLEAR MASK IN LOCN
	BR	110$
90$:	CLC
	ROL	R5
	TST	(SP)			;BRANCH IF NEG SW TO SET
	BNE	80$
100$:	BIC	(R4),(R5)		; CLEAR MASK IN LOCN
110$:	TST	(SP)+
	MOV	(SP)+,R5		;LAST DELIMITER SCANNED
	MOV	(SP)+,R2		;ADDR OF IT
	MOV	4(R4),R4		; ADDR OF VALUE TABLE (IF ANY)
	BIC	#1,R4			;DEL NEG SW ALLOWED BIT
120$:	CMPB	R5,#SLASH		;DOES ANOTHER SWITCH FOLLOW
	BEQ	SWITCH			;BRANCH IF SO
	CMPB	R5,#COLON		;DOES A SWITCH VALUE FOLLOW
	BEQ	200$			;GO PROCESS
	CLR	R4			;SET NO ERROR
	RTS	PC			;EXIT
;
; ERROR IN SWITCH PROCESSING
;
130$:	TST	(SP)+
	MOV	(SP)+,R5		;GET LAST DELIM FOUND
	MOV	(SP)+,R2		;GET ITS ADDR
140$:	CMPB	R5,#EQUAL		;IS IT END OF CURRENT SECTION
	BEQ	150$
	CMPB	R5,#COMMA
	BEQ	150$			;BRANCH IF SO
	INC	R2			;ELSE STEP OVER IT
	JSR	PC,DELSCN		;GET NEXT DELIM
	BR	140$			;LOOP UNTIL END OF CURRENT SECTION
150$:	MOV	#1,R4			;SET ERROR
	RTS	PC			;EXIT
;
; PROCESS SWITCH VALUE
;
200$:	MOV	R4,R3
	BEQ	140$			;ERROR IF NO VALUE TABLE
	TST	(R3)
	BEQ	140$			;ERROR IF NO MORE ENTRIES
	INC	R2			;STEP OVER LAST DELIM
	JSR	PC,DELSCN		;SCAN TO NEXT
	MOV	R4,-(SP)		;SAVE PTR TO DELIM
	MOV	R5,-(SP)		;AND DELIM CHAR
	MOV	2(R3),R5		; GET RESULT ADDR
	CMPB	(R3)+,#ASVAL		; SHOULD SW-VALUE BE ASCII?
	BNE	300$			;BRANCH IF NUMBERIC CVT REQUIRED
	SUB	R2,R4			;GET VALUE LEN
	CMPB	(R3),R4			; CMPR WITH ALLOWED LENGTH
	BHIS	210$			;BRANCH IF SAME OR SMALLER THAN ALLOWED
	MOVB	(R3),R4			; SET LENGTH ALLOWED
210$:	MOV	R4,-(SP)		;SAVE LEN
	BEQ	230$			;BRANCH IF NONE TO MOVE
220$:	MOVB	(R2)+,(R5)+		;MOVE CHARS
	DEC	R4			;UNTIL COUNT EXHAUSTED
	BNE	220$
230$:	MOVB	(R3),R4			; GET ALLOWED LENGTH
	SUB	(SP)+,R4		;CALC SPACE LEFT TO PAD
	BEQ	250$			;BRANCH IF NONE
240$:	CLRB	(R5)+			;PAD WITH NULLS
	DEC 	R4
	BNE	240$
250$:	ADD	#3,R3			; ADDR OF NEXT VAL TABLE ENTRY
	MOV	(SP)+,R5		;GET LAST DELIM CHAR
	MOV	(SP)+,R2		;GET ADDR OF DELIM CHAR
	MOV	R3,R4
	BR	120$			;GO DECIDE WHAT TO DO
300$:	MOV	R3,-(SP)
	MOV	#.ODCVT,-(SP)		; ASSUME NUMERIC CONVERT (OCTAL DFLT)
	CMPB	#DECVAL,-(R3)		; IS DECIMAL DEFAULT DESIRED?
	BNE	310$			; BRANCH IF NOT
	MOV	#.DCCVT,(SP)		; ELSE, SPECIFY DECIMAL DEFAULT
310$:					;
	MOV	R5,R3			; SET RESULT ADDR
	CLR	(R3)
	SUB	R2,R4			;LENGTH OF DIGIT STRING
	BEQ	320$			;SKIP NULL STRING
	MOV	R2,R5			;SET STRING ADDR
	JSR	PC,@(SP)+		; CALL NUMERIC CONVERT
	BCS	130$			;BRANCH IF ERROR
	BR	330$			; BRANCH TO LEAVE
320$:	TST	(SP)+			; PURGE CONVERT ADDR FROM STACK
330$:	MOV	(SP)+,R3		; RESTORE R3
	BR	250$

	.SBTTL	DELSCN - SCAN STRING FOR DELIMETER MATCH
;++
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE SCANS A STRING FOR A DELIMETER MATCH.
;
; CHARACTERS INSIDE "[","]" ARE IGNORED.
;
; INPUTS:
;
;	R0 = ADDRESS OF THE CSI CONTROL BLOCK
;	R2 = ADDRESS TO START THE SCAN
;
; OUTPUTS:
;
;	R0 = ADDRESS OF THE CSI CONTROL BLOCK
;	R2 = ADDRESS TO START THE SCAN
;	R4 = ADDRESS  OF FOUND DELIMETER
;	R5 = DELIMETER, EOL IS "="
;--
DELSCN:	MOV	C.BFAD(R0),-(SP)	;ADDRESS END OF STRING
	ADD	C.BFLN(R0),(SP)
	MOV	R2,R4			;ADDR FOR SCAN START
10$:	MOV	#DELSTR,R5		; ADDRESS LIST
	CMP	R4,(SP)			; END OF STRING?
	BEQ	50$			; IF EQ THEN YES
	CMPB	(R5)+,(R4)		; "="?
	BEQ	50$			; IF EQL THEN YES
	CMPB	(R4),(R5)+		; COLON?
 
	.IF	NDF	.NODES.
 
	BEQ	50$
 
	.IFF
 
	BNE	15$			; IF NEQ THEN NO
	CMP	C.BFAD(R0),R2		; FIRST PART OF STRING?
	BNE	50$			; IF NEQ THEN FOUND
	INC	R4			; POINT TO NEXT CHAR
	CMP	R4,(SP)			; PART OF STRING?
	BEQ	45$			; IF EQL THEN NO
	CMPB	-1(R5),(R4)+		; DOUBLE COLON?
	BNE	45$			; IF NEQ THEN COLON IS DELIM
	CMP	R4,(SP)			; IS END OF STRING REACHED?
	BEQ	45$			; IF YES THEN RETURN COLON DELIM
	BR	10$
 
	.IFTF
 
15$:	CMPB	(R4),(R5)+		; LOOK FOR DIRECTORY
	BEQ	20$			;  IF FOUND THEN SKIP DIRECTORY
	INC	R5
	CMPB	(R4),(R5)+		;
	BNE	30$			;
20$:	INC	R4			; PASS DIRECTORY STRING
	CMPB	(R4),(R5)		;
	BNE	20$			; IF NE THEN NOT FOUND
	MOVB	#'],R5			; SET TERMINATOR AS BRACKET
	BR	55$			; AND DONE
30$:	INC	R5			; POINT TO "/"
	CMPB	(R5)+,(R4)		; FOUND?
	BEQ	50$			;
	CMPB	(R4),(R5)+		; FOUND?
	BEQ	50$			; 
40$:	INC	R4			; POINT TO NEXT CHAR
	BR	10$			; AND CONTINUE SEARCH
 
	.IFT
 
45$:
	SUB	#2,R4
 
	.ENDC
 
50$:	MOVB	-1(R5),R5		; PICK UP TERMINATOR
55$:	TST	(SP)+			; CLEAN STACK
	RTS	PC			; EXIT

	.SBTTL WILDCK - CHECK FOR FILE NAME WILDCARD SYNTAX
;++
; WILDCK - CHECK FOR FILE NAME WILDCARD SYNTAX
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE PROCESSES FILE NAME WILDCARDS.
;
; INPUTS:
;
;	R0 = ADDRESS OF THE CONTROL BLOCK
;	R2 = ADDRESS TO BEGIN CHECK
;
; OUTPUTS:
;
;	R0,R2 ARE PRESERVED
;--
WILDCK:	CMPB	#STAR,(R2)+
	BEQ	10$			;BRANCH IF WILD CARD FOUND
	CMP	R2,R4
	BNE	WILDCK			;BRANCH IF NOT AT END OF NAME
	RTS	PC			;EXIT
10$:	BISB	#CS.WLD,C.STAT(R0)	;SET WILD CARD STATUS
	RTS	PC			;EXIT

	.SBTTL SWMAT - MATCH STRING NAME TO TABLE DATA
;++
; SWMAT - MATCH STRING NAME TO TABLE DATA
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE, GIVEN A STRING NAME DOES A TWO CHARACTER NAME MATCH WITH
; THE SWITCH TABLE DATA GIVEN IN THE CSI CONTROL BLOCK
;
; INPUTS:
;
;	R0 = ADDRESS OF THE CSI CONTROL BLOCK
;	R2 = ADDRESS OF STRING
;	R3 = SIZE OF STRING
;
; OUTPUTS:
;	C-BIT SET ON ERROR, CLEAR ON SUCCESS
;
;	R0 = ADDRESS OF THE CSI CONTROL BLOCK
;	R4 = ADDRESS OF 3 WORDS OF SWITCH DATA
;--
SWMAT:	MOV	R2,-(SP)		;SAVE ADDRESS
	MOV	R3,-(SP)		;AND SIZE OF SWITCH STRING
	MOV	C.SWAD(R0),R4		;GET SWITCH TABLE ADDRESS
	BEQ	60$			;NO MATCH IF NO SWITCH TABLE
	BR	50$			;START AT BOTTOM OF LOOP
;
; START HERE FOR 2ND AND SUBSEQUENT WORDS OF ASCII SWITCH IN THE
; SWITCH TABLE.  SIGN BIT IN WORD INDICATES ANOTHER WORD IS PRESENT
;
10$:	MOV	(R4)+,R5		;IF NEGATIVE, THEN MORE TO CHECK
	BMI	20$
	TSTB	R5			;IS AN EXACT MATCH REQUIRED?
	BPL	80$			;BRANCH IF NO, THIS IS A MATCH
	TST	R3			;MUST BE NO CHARS LEFT TO MATCH
	BLE	80$			;BRANCH IF EXACT MATCH
	BR	45$			;GO LOOK AT NEXT SWITCH TABLE ENTRY
;
; HERE FOR THE FIRST WORD OF EACH SWITCH TABLE ENTRY
;
20$:	MOV	(R4),R5			;FIRST/NEXT WORD OF ASCII
	BEQ	60$			;WORD OF 0 MEANS END OF TABLE
	BIC	#100200,R5		;SHUT OFF "MORE CHARS COMING" BITS
	DEC	R3
	BMI	40$			;BRANCH IF SWITCH TOO SHORT
	CLR	-(SP)
	MOVB	(R2)+,(SP)		;FORM WORD WITH NEXT 2 CHARACTERS
	DEC	R3			;IF NO MORE CHARACTERS
	BMI	30$			;LEAVE A NULL IN THE HIGH BYTE
	BIT	#177400+200,(R4) 	;IF HIGH BYTE IS NULL
					;AND IF EXACT MATCH BIT IS 0
	BEQ	30$			;THEN LEAVE A NULL
	MOVB	(R2)+,1(SP)		;OTHERWISE GET A 2ND CHARACTER
30$:	CMP	(SP)+,R5		;COMPARE THE WORD
	BEQ	10$			;IF EQUAL, SEE IF MORE TO BE MATCHED
;
; SKIP OVER THE REST OF THIS SWITCH TABLE ENTRY
;
40$:	TST	(R4)+			;LAST ASCII WORD WILL BE POSITIVE
	BMI	40$			;SKIP OVER THE NEGATIVE ONES
45$:	ADD	#6,R4			;SKIP THE FIXED LENGTH PART
50$:	MOV	(SP),R3			;RESTORE THE STRING SIZE
	MOV	2(SP),R2		;AND ADDRESS OF THE SWITCH
	BR	20$			;AND TRY THE NEXT SWITCH TABLE ENTRY
60$:	SEC				;SWITCH NOT FOUND
;
; COMMON EXIT, C=0 IF SUCCESSFUL, C=1 IF ERROR
;
80$:	BIT	(SP)+,(SP)+		;CLEAN 2 WORDS OFF STACK
	RETURN

	.SBTTL - DIDVSN - SCAN DEVICE AND DIRECTORY NAME
;++
; DIDVSN - SCAN DEVICE AND DIRECTORY NAME STRING
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE SCANS THE DEVICE AND DIRECTORY STRING PART OF THE FILE SPEC.
; THE SCAN IS BASED ON A CONTROL STRING.
;
; INPUTS
;
;	R0 = ADDRESS OF THE CSI CONTROL BLOCK
;	R1 = INPUT IF 0, OUTPUT IF 1
;	R2 = ADDRESS TO START SCAN
;	R3 = CONTROL STRING ADDRESS
;	R4 = STRING END ADDRESS
;	R5 = DELIMETER
;
; OUTPUTS:
;
;	R0,R1,R2,R4,R5 ARE PRESERVED
;--
DIDVSN:	MOV	R4,-(SP)		;SAVE STRING SEG END
	MOV	R2,-(SP)		;AND START PTRS
	MOV	R5,-(SP)		;SAVE DELIM
	MOVB	(R3)+,R5		;DISP TO 4WD I/O SAVE PTRS
	ADD	R0,R5			;ADDR OF INPUT SAVE PTRS
	TST	R1			;BRANCH IF INPUT
	BEQ	10$
	CMP	(R5)+,(R5)+		; INCR R5 TO PNT TO OUTPUT
10$:	CMPB	(R3)+,(SP)		;BRANCH IF NOT DEV/DIR INFO
	BNE	20$
	ADD	(R3)+,R4		;ADJUSTMENT FOR DIR INFO
	SUB	R2,R4			;CALC LEN OF SEG
	BISB	(R3)+,C.STAT(R0)	;SET FOUND THIS SEG
	BR	30$
20$:	ADD	#3,R3			;STEP OVER CTL VECT BYTES
	MOV	(R5),R4			;GET PREVIOUS LEN
	MOV	2(R5),R2		;AND ADDR
30$:	MOV	R4,(R5)+		; SAVE LENGTH/ADDR INFO IN ...
	MOV	R2,(R5)			; ... LAST FOUND WORDS
	MOVB	(R3)+,R5		;CALC ADDR OF
	ADD	R0,R5			;RETURN LEN AND ADDR
	MOV	R4,(R5)+		;RETURN LENGTH AND ADDR
	MOV	R2,(R5)
	TSTB	(R3)+			;FALL THRU FOR DIR INFO
	BEQ	40$			;ONLY
	TST	R4
	BEQ	40$			;BRANCH IF NO DIR INFO
	ADD	R2,R4
	JSR	PC,WILDCK		;WILD CARD SCAN
40$:	MOV	(SP)+,R5		;RESTORE DELIM
	MOV	(SP)+,R2		;SEG LEN AND ADDR
	MOV	(SP)+,R4
	CMPB	(R3),R5			;BRANCH IF WAS NOT
	BNE	50$			;DEV(OR DIR) INFO
	MOV	R4,R2			;ELSE SET NEW PTRS
	INC	R2
	JSR	PC,DELSCN		;SCAN TO DELIM
50$:	RTS	PC
	.END
