	.TITLE	.CSI1 - VAX/VMS CSI1 ROUTINES
	.IDENT	/V03000/

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
;
; FACILITY:
;
;	VAX/VMS RSX11M SUPPORT ROUTINES
;
; ABSTRACT:
;
;	THIS MODULE REPLACES THE RSX11M CSI1 MODULE FOR RSX11M TASKS
;	RUNNING UNDER VAX/VMS. THIS ROUTINE PARSES VAX/VMS FILE SPECS.
;
; AUTHOR:
;
;	R.HEINEN FROM A.MOROTTO'S AND C. D'ELIA'S RSX11M CSI1
;--
;
; LOCAL MACROS
;
	.MACRO	GENDSP	LIST
	.IRP	X,<LIST>
	.BYTE	X'DSP
	.ENDM
	.ENDM	GENDSP
;
; LOCAL STORAGE
;
	.PSECT	.CSID
 
;
; GENERATE THE OFFSET SYMBOLS TO USE THE DISPATCH TABLE
;
XTMPX=0
	.IRP	X,<FN,DV,PP,ER,SW>
X'DSP=XTMPX
XTMPX=XTMPX+2
	.ENDM
;
; TABLE OF ROUTINE ADDRESSES FOR SYNTAX CHECK
;
DSPTBL:					;
	.WORD	FNSCAN			; SCAN FILE NAME
	.WORD	DEVSCN			; SCAN DEVICE NAME (AND NUMBER)
	.WORD	DIRSCN			; SCAN UIC SPECIFICATION
	.WORD	ERROR			; DECLARE SYNTAX ERROR
	.WORD	SWSCAN			; SCAN SWITCHES
;
;	STATE TABLES FOR SYNTAX SCAN
;
	GENDSP	<FN>
STAT0:	GENDSP	<FN,DV,PP,FN,ER>
	GENDSP	<FN>
	GENDSP	<FN,ER,PP,FN,ER>
	GENDSP	<FN>
	GENDSP	<FN,ER,ER,FN,ER>
	GENDSP	<SW>
	GENDSP	<SW,SW,ER,SW,ER> 
;
; DELIMETER CLASS TABLE
;
	.EVEN
DELTAB:					;
	.BYTE	EQUAL,-1		;
	.BYTE	RBRAC,4			;
	.BYTE	RPBRAC,4		; RIGHT POINTY BRACKET
	.BYTE	SLASH,3			;
	.BYTE	LBRAC,2			;
	.BYTE	LPBRAC,2		; LEFT POINTY BRACKET
	.BYTE	COLON,1			;
	.BYTE	COMMA,0			;
;
; CHARACTER TYPE BREAKDOWN TABLE
;
NUMER=0					; RAD50
ALPHA=1					; RAD50
DLR=2					; RAD50
PERIOD=3				; RAD50
ASTER=4					; NON-RAD50
OTHER=5					; NON-RAD50
;
;
;
CHRTAB:	.BYTE	CHAR0,CHAR9,NUMER	; NUMBERS
	.BYTE	CHARA,CHARZ,ALPHA	; UPPER CASE
	.BYTE	CHARA+40,CHARZ+40,ALPHA	; LOWER CASE
	.BYTE	DOLLAR,DOLLAR,DLR	; DOLLAR SIGN
	.BYTE	DOT,DOT,PERIOD		; PERIOD
	.BYTE	STAR,STAR,ASTER		; STAR
	.BYTE	0,255.,OTHER		; ALL OTHERS

	.SBTTL	.CSI1 - SYNTAX CHECK ENTIRE COMMAND LINE
 
	.PSECT	.CSII
 
	.ENABL	LSB
;++
; .CSI1 - SYNTAX ENTIRE COMMAND LINE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE INITIALIZES THE CSI DATA BASE AND CHECKS THE ENTIRE
; INPUT COMMAND LINE FOR SYNTAX.
;
; THE SYNTAX CHECK IS LIBERAL.
;
;	DEVICE:
;	DEVICE:[DIRECTORY]
;	[DIRECTORY]
;
;	NAME
;	NAME.
;	NAME.TYP
;	NAME.TYP;VER
;	NAME.TYP.VER
;
;	SWITCHES ARE /SWITCH
;
; INPUTS:
;
;	R0 = ADDRESS OF THE CSI CONTROL BLOCK
;
; OUTPUTS:
;
;	R0 = ADDRESS OF THE CSI CONTROL BLOCK
;
;	R1,R2,R3,R4,R5 ARE SAVED.
;--
.CSI1::					;
	JSR	R5,.SAVR1		; SAVE REGISTERS
	MOV	R0,R3			; GET COMMAND BLOCK ADDR
	MOV	C.BFAD(R0),R1		;GET BUFF ADDR
	MOV	C.BFLN(R0),R2		;AND BUFF LENGTH
	MOV	#<C.SIZE/2>,R4		; SET SIZE OF CSI BLOCK (WDS)
10$:	CLR	(R3)+			;CLEAR BLOCK
	DEC	R4
	BNE	10$
	MOV	R1,C.BFAD(R0)		;RESTORE BUFF ADDR
	MOV	R1,C.OSTR(R0)		;SET OUTPUT SIDE STRING PTR
;
;	COMPRESS COMMAND STRING(ELIMINATE NULLS, TABS, RUBOUTS AND BLANKS)
;	ALSO ESTABLISH THAT THERE IS AT MOST 1 EQUALS AND SAVE ITS LOCN+1
;
	MOV	R1,R3			;SET PTRS FOR COMPRESS
	MOV	R0,R4			; SET R4 TO THE ...
	ADD	#C.ISTR,R4		; ... INPUT STRING POINTER
	TST	R2
	BNE	20$			;BRANCH IF NOT NULL LINE
	MOV	R1,(R4)			; ELSE, SET INPUT STRING POINTER
	RTS	PC			; RETURN -- CC-C ALREADY CLEAR
20$:	TSTB	(R3)			; BRANCH IF NULL, RUBOUT ...
	BEQ	40$			;TAB OR BLANK
	CMPB	#TAB,(R3)
	BEQ	40$
	CMPB	#RUBOUT,(R3)
	BEQ	40$
	CMPB	#BLANK,(R3)
	BEQ	40$
	MOVB	(R3),(R1)+		;ELSE MOVE CHAR TO COMPRESSED STRING
	CMPB	#EQUAL,(R3)		;BRANCH IF NOT EQUALS
	BNE	40$
	TST	(R4)			; ERROR IF ALREADY FOUND EQUAL SIGN
	BEQ	30$			;ELSE BRANCH
	MOV	R3,C.FNAD(R0)		;SET LOCN OF BAD SYNTAX
	MOV	R2,C.FNLN(R0)		;SET LENGTH
	SEC				;SET ERROR
	RTS	PC			;EXIT
30$:	MOV	R1,(R4)			; SET INPUT STRING POINTER
	BISB	#CS.EQU,C.STAT(R0)  	; INDICATE EQUAL SIGN SEEN
40$:	INC	R3			;NEXT UNCOMPRESSED CHARS ADDR
	DEC	R2			;BRANCH IF MORE TO CHECK
	BNE	20$
	TST	(R4)			; BRANCH IF EQUAL SIGN ALREADY FOUND
	BNE	50$
	MOV	R1,(R4)			; ELSE, SET INPUT STRING POINTER
50$:	MOV	C.BFAD(R0),R4		; GET STRING ADDRESS
	SUB	R4,R1			; SET COMPRESSED STRING LENGTH
	MOV	R1,C.BFLN(R0)
;
;	COMMAND BLOCK IS SET UP AND STRING IS COMPRESSED
;	PREPARE FOR SYNTAX SCAN OF COMPRESSED STRING
;
	MOV	R0,-(SP)		;SAVE CMMD BLOCK ADDR
	CLR	R5			;SET SCAN STATE
	ADD	R4,R1			;END OF STRING ADDR
	DEC	R4
60$:	CMP	R4,R1			;BRANCH IF AT END OF LINE
	BEQ	100$
	INC	R4			; PASS DELIM
	MOV	R4,R2			; START AT CURRENT DELIMETER
	MOV	R5,R0			; SET SCAN STATE
	BPL	65$			; IF PLUS THEN OK
	CLR	R0			; RESET SCAN ON EQUAL
65$:	JSR	PC,GETDEL		;SCAN TO A DELIMITER
;
;	GO TO PROPER ROUTINE VIA STATE TABLE
;
	ASL	R0
	MOV	R0,R3
	ASL	R0
	ADD	R0,R3
	ADD	R5,R3
	MOVB	STAT0(R3),R3		; LOAD OFFSET INTO DISP TBL
	MOV	(SP),R0			; GET BLOCK ADDRESS
	MOV	R2,C.FNAD(R0)		; SAVE ADDRESS AND SIZE OF AREA
	MOV	R4,C.FNLN(R0)		;
	SUB	R2,C.FNLN(R0)		;
	JSR	PC,@DSPTBL(R3)		; JUMP TO PROPER ROUTINE
	BCC	60$			; BR IF NO ERROR DETECTED
	BR	110$
100$:	CLC
110$:	MOV	(SP)+,R0		; RESTORE BLOCK ADDRESS
	RTS	PC
	.DSABL	LSB

;++
; GETDEL - SCAN INPUT FOR NEXT DELIMETER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE SCANS THE INPUT AND RETURNS THE CLASS OF THE NEXT DELIMETER.
;	SINGLE COLON, COMMA, SLASH, EQUALS(OR END OF STRING), SEMICOLON, RIGHT BRACKET,
;
;	LEFT BRACKET,POINTY BRACKETS
;
; INPUTS:
;
;	R0 = CSI CONTROL BLOCK ADDRESS
;	R1 = ADDRESS OF THE END OF LINE
;	R2 = ADDRESS TO BEGIN SCAN
;
; OUTPUTS:
;
;	R2 = ADDRESS OF SCAN BEGIN
;	R4 = ADDRESS OF THE DELIMETER
;	R5 = DELIMETER CLASS
;
;	R0,R1,R2 ARE PRESERVED.
;--
GETDEL:	MOV	R2,R4			;ADDR DELIM
10$:	MOV	#DELTAB,R5		;ADDR DELIMITER TABLE
	CMP	R4,R1			;BRANCH IF NOT AT END OF STRING
	BEQ	30$
20$:	CMPB	(R4),(R5)		;IS THIS CHAR THIS DELIM
	BEQ	30$			; IF EQL THEN FOUND
	BIT	#177400,(R5)+		; END OF LIST?
	BNE	20$			; IF NE THEN NO
	INC	R4			;ADVANCE TO NEXT CHAR
	BR	10$			;GO CHECK
30$:	MOVB	1(R5),R5		; GET DELIMITER VALUE
	RTS	PC			;EXIT

;++
; CHRTYP - GET TYPE OF CHARACTER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE RETURNS THE TYPE OF A GIVEN CHARACTER AND AN INDICATION
; OF ITS INCLUSION IN THE RAD50 SET.
;
; INPUTS:
;
;	R0 = ADDRESS OF THE CHARACTER TO TYPE
;	R4 = ADDRESS OF THE END OF LINE
;
; OUTPUTS:
;
;	R0 = ADDRESS OF THE NEXT INPUT STREAM CHARACTER
;	R3 = TYPE OF THE CHARACTER
;
;	R1,R2,R4,R5 ARE PRESERVED.
;--
CHRTYP:	MOV	#CHRTAB,R3		; ADDRESS TABLE
5$:	CMP	R0,R4			; END OF SECTION?
	BEQ	15$			; THEN SET OTHER
	CMPB	(R0),(R3)+		; CHARACTER IN RANGE?
	BLO	10$			; IF LO THEN NO
	CMPB	(R0),(R3)		;
	BLOS	20$			; IF LOW FOUND
10$:	ADD	#2,R3			; PASS ENTRY
	BR	5$			;
15$:	MOV	#OTHER,R3		; SET OTHER FOR EOL
	BR	25$
20$:	MOVB	1(R3),R3		; SET TYPE AND RETURN
25$:	INC	R0
	CMPB	R3,#ALPHA		; IF ALPHA THEN CONVERT TO UPPER
	BNE	30$			; IF NEQ THEN NO
	BICB	#40,-1(R0)		; RESET IT
30$:	RTS	PC

;++
; DEVSCN - SCAN DEVICE NAME 
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE SCANS DEVICE NAMES. THE REQUIREMENT IS THAT THE STRING
; BEGIN WITH AN ALPHABETIC.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE CURRENT AREA START
;	R4 = ADDRESS OF THE CURRENT AREA END
;
; OUTPUT:
;
;	C-BIT IS SET ON ERROR, CLEAR ON SUCCESS
;
;	R2,R4,R5 ARE PRESERVED
;--
DEVSCN:	MOV	R2,R0			;SET START CHAR
	CMPB	(R0),#137		; SKIP OVER UNDER SCORE
	BNE	15$			; IF NEQ THEN GO
	INC	R0			;
	BR	15$			;
10$:	CMP	R0,R4			; END OF AREA?
	BEQ	30$			; IF EQL THEN DONE
15$:	JSR	PC,CHRTYP		; GET TYPE OF NEXT CHARACTER
	SUB	#PERIOD,R3		; CHECK FOR $,ALPHA OR NUMBER
	BMI	10$			; IF MINUS THEN OK
	SEC				; EXIT WITH ERROR
	RTS	PC
30$:	CLC				; EXIT WITH SUCCESS
	RTS	PC

;++
; DIRSCN - SCAN DIRECTORY SPECIFIER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE SCANS DIRECTORY SPECIFIERS.
; THE REQUIREMENT IS THAT THE BRACKETS MATCH AND THAT IF A COMMA
; IS PRESENT IT IS THE ONLY DELIMETER.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE CURRENT AREA START
;	R4 = ADDRESS OF THE CURRENT AREA END
;
; OUTPUTS:
;
;	C-BIT IS SET ON ERROR, CLEAR ON SUCCESS
;
;	R2,R4 ARE PRESERVED.
;
;	R5 IS SET TO 2 TO FORCE FILE NAME CHECK ON SUCCESS
;--
DIRSCN:	CMP	R2,R4			;IF CHARS PRECEED [ OR <
	BNE	ERROR			;ERROR
	MOVB	(R2)+,-(SP)		; SAVE START DELIM AND STEP OVER
	JSR	PC,GETDEL		;GET NEXT DELIM
	TST	R5			; COMMA?
	BNE	10$			; IF YES THEN GET THE NEXT DELIM
	INC	R4
	MOV	R4,R2			; COPY DELIM ADDR
	JSR	PC,GETDEL		; GET NEXT DELIMETER
10$:	MOV	(SP)+,R0		; GET START SYMBOL
	CMP	R5,#4			; ] OR >?
	BNE	35$			; ERROR IF NO
	CMPB	R0,#'[			; ENTER WITH "["?
	BNE	15$			; IF NEQ THEN MUST HAVE BEEN "<"
	CMPB	(R4),#']		; MUST MATCH
	BR	20$			; CKECK IN COMMON
15$:	CMPB	(R4),#'>		;
20$:	BNE	35$			; IF NEQ THEN ERROR
	MOV	#2,R5			; SET UP NEXT STATE
	CLC	
	RTS	PC
35$:	MOV	2(SP),R0		; GET BLOCK ADDRESS
	MOV	R4,C.FNLN(R0)		; SET DELIM SIZE
	SUB	C.FNAD(R0),C.FNLN(R0)	;
ERROR:	SEC	
	RTS	PC

;++
; SWSCAN - SCAN SWITCHES
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE SCANS SWITCHES.
; THE REQUIREMENT IS THAT THE SWITCH START WITH A ALPHA AND
; BE RAD50 CHARACTERS UNTIL THE END OF THE AREA OR A COLON.
; IF A COLON IS FOUND, THE NEXT DELIM MAY NOT BE ],[ OR ;.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE CURRENT AREA START
;	R4 = ADDRESS OF THE CURRENT AREA END
;
; OUTPUTS:
;
;	C-BIT SET IF ERROR, CLEAR IF SUCCESS.
;
; R2,R4,R5 ARE PRESERVED.
;--
SWSCAN:	MOV	R2,R0
	CMPB	(R0),#MINUS		;STEP OVER LEADING MINUS
	BNE	5$
	INC	R0
5$:	CMP	R0,R4			;BRANCH IF AT END OF NAME
	BEQ	20$
	JSR	PC,CHRTYP		;GET NEXT CHARS TYPE
	CMP	R3,#PERIOD		;IF NOT RAD50 CHAR
	BLOS	5$
7$:	SEC	
	RTS	PC
10$:	MOV	R4,R2			; SET POINTER
	INC	R2			;
	JSR	PC,GETDEL		; SKIP THE SWITCH VALUE
	MOV	R5,R3			; COPY DELIMITER VALUE INTO R3
	SUB	#2,R3			; IF DELIMITER IS '[' THEN ...
	BEQ	7$			; ... DECLARE SYNTAX ERROR
	DEC	R3			; IF DELIMITER IS ']' THEN ...
	BGT	7$			; ... DECLARE SYNTAX ERROR
20$:	CMP	#1,R5			; DELIM COLON?
	BEQ	10$			; IF EQL THEN CONTINUE
	CLC	
	RTS	PC

;++
; FNSCAN - SCAN FILE NAME, TYPE AND VERSION
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE SCANS FILE NAMES.
; INPUTS:
;
;	R2 = ADDRESS OF THE CURRENT AREA START
;	R4 = ADDRESS OF THE CURRENT AREA END
;
; OUPTUTS:
;
;	C-BIT IS SET ON ERROR, CLEAR ON SUCCESS
;
;	R2,R4,R5 ARE PRESERVED.
;--
FNSCAN:					; SCAN FILE NAME
	MOV	R2,R0			; COPY SCAN START ADDRESS
	JSR	PC,100$			; SCAN STRING
	BCS	50$			; IF C-SET THEN REAL ERROR
	BVS	15$			; IF V-SET THEN SEMI TERMINATED
	BEQ	40$			; IF EQL THEN END OF STRING
	JSR	PC,100$			; SCAN TYPE FIELD
	BCS	50$			; IF C-SET THEN ERROR
	BEQ	40$			; IF EQL THEN END OF LINE
15$:	CMPB	(R0),#STAR		; VERSION STAR?
	BEQ	40$			; IF EQ THEN YES AND DONE
20$:	CMP	R0,R4			; AT END OF AREA?
	BEQ	40$			; IF NE THEN ERROR
	JSR	PC,CHRTYP		; SCAN VERSION
	CMP	R3,#NUMER		; NUMBERS ONLY
	BEQ	20$			; CONTINUE UNTIL DONE
	SEC
	BR	50$			; CONTINUE
40$:	CLC	
50$:	MOV	R5,R5
	BPL	60$
	MOV	#0,R5
60$:	RTS	PC
;
; SCAN SUBROUTINE
;
100$:	CMPB	(R0),#STAR		; STAR?
	BNE	110$			; IF NEQ THEN GO ON
	INC	R0			; POINT TO DELIM
110$:	CMP	R4,R0			; END OF LINE?
	CLV				; INSURE V-CLEAR
	BEQ	130$			; IF EQL THEN YES AND OK
	JSR	PC,CHRTYP		; GET CHR TYPE
	SUB	#PERIOD,R3		; RAD 50?
	BMI	110$			; IF MI THEN YES
	CLV				; ASSUME PERIOD
	BEQ	120$			; IF EQL THEN PERIOD
	CMPB	-1(R0),#SEMIC		; SEMI COLON?
	SEV				; ASSUME YES
	BEQ	120$			; IF EQL THEN SET V
	SEC
	RTS	PC
120$:	CLZ				; SET NOT EQUAL
130$:	CLC	
	RTS	PC
	.END
