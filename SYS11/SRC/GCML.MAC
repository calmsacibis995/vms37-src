
	.IF NDF	R$$11M


	.TITLE	.GCML  RSX-11D GET COMMAND LINE
	.IDENT	/V03000/
	.IFF

	.TITLE	.GCML  RSX-11M GET COMMAND LINE
	.IDENT	/M21.01/

	.ENDC



;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; VERSION 21.01
;
; WRITTEN BY:
;	R. GROVE
;	P. KNEUVEN
;
; MODIFIED BY:
;	C.A. D'ELIA	26-NOV-73	001
;	C.A. D'ELIA	12-JAN-74	002
;	C.A. D'ELIA	12-MAR-74	003
;	C.A. D'ELIA	19-MAR-74	004
;	C.A. D'ELIA	31-MAR-74	005
;	C.A. D'ELIA	05-APR-74	006
;	C.A. D'ELIA	04-JUN-74	007
;	C.A. D'ELIA	01-JUL-74	008
;	C.A. D'ELIA	01-AUG-74	009
;	C.A. D'ELIA	20-JAN-75	010
;	C.A. D'ELIA	21-MAR-75	011
;	C.A. D'ELIA	30-JUL-75	012
;	C.A. D'ELIA	21-JAN-76	013
;	A.C. GOLDSTEIN	12-APR-76	014
;	JOHN HARPER	22-SEP-76	015	CONDITIONALISE TERMINATION ON '/'
;	I.S. / J.H.	04-JAN-77	016	CONTINUATION LINES
;	C.A. D'ELIA	18-JAN-77	017	FIX BUG IF INDIRECT FAILURE
;						AT MCR LEVEL
;	B.L. SCHREIBER	27-APR-77	018 (BLS002) FIX BUG IF INDIRECT
;					FAILURE AT MCR LEVEL (AGAIN)
;					RE-INSERT LOST EDIT 015 (THIS
;					BRINGS IAS AND RSX VERSIONS
;					BACK TOGETHER.
;	B.L SCHREIBER	6-JUN-77	019 CONTINUATION LINES IN 1ST LEVEL
;					INDIRECT FILE
;	P.H. LIPMAN	6-JUN-77	020 ENTRY POINT TO AVOID RECEIVING
;					EOF AFTER MCR LINE, 11M DETACH FOR
;					INDIRECT FILE REQUIRED IF TTY ATTACHED
;					ON ENTRY TO GCML.
;
;	R.B. GROVE	16-DEC-77	021 DO MULTIPLE GMCR$ AT TOP
;					LEVEL FOR VAX/VMS AME
;
;
;	Darrell Duffy	18-March-1980	DJD001 Carry some changes forward to
;					VMS version
;
; LOCAL OFFSET AND SYMBOL DEFINITIONS

	.MCALL	CSI$		;++009
	CSI$	DEF$L
	.MCALL	GCMLD$		;++009
	GCMLD$	DEF$L
	.MCALL	NBOFF$		;++009
	NBOFF$	DEF$L		;++009 DEFINE NAME BLOCK OFFSETS


	.MCALL	CALL,RETURN,DIR$,CSI$1,CSI$2,CLOSE$  ;++003


	.IF NDF	R$$11M		;++003

	.MCALL	OPEN$R,GET$	;++003

	.IFF			;++003

	.MCALL	OFNB$R,GET$S,FINIT$,ENCP$S,DSCP$S  ;++010

	.ENDC			;++003


; INTERNAL GCML$ BLOCK OFFSET DEFINITIONS
G.CDEP	=G.ERR+10.	;CURRENT PUSH DOWN DEPTH
G.MDEP	=G.CDEP+1	;MAXIMUM PUSH DOWN DEPTH
G.PPTR	=G.MDEP+1	;PUSH DOWN STORAGE POINTER
G.RBUF	=G.PPTR+2	;RECORD BUFFER POINTER
G.DPRM	=G.RBUF+2	;DEFAULT PROMPT STRING TEXT
G.DFNB	=G.DPRM+6	;DEFAULT FILE NAME BLOCK
G.SIZE	=G.DFNB+S.FNB	;+++016 BUFFER SIZE
G.PDSL = <3*2>+<5*2>	;++001 PUSH DOWN FRAME SIZE (8 WORDS)

; G.MODE BIT DEFINITIONS
GE.MCR	=200		;G.MODE BIT, SET IF TOP LEVEL IS MCR LINE

; ASCII CHARACTER DEFINITIONS
CR	=15
TAB	=11
BLANK	=40
ALTMOD	=33

	.MACRO	.SAVR1
	JSR	R5,.SAVR1
	.ENDM	.SAVR1


	.IF DF	R$$11M

	.MACRO	SOB	REG,ADDR
	DEC	REG
	BNE	ADDR
	.ENDM	SOB

	.ENDC
	.PAGE
; GCML$ - ENTRY TO GET NEXT COMMAND LINE

.GCML1::.SAVR1
	MOV	R0,R5		;BLOCK POINTER ALWAYS IN R5
NXTLIN:	CLR	G.CMLD(R5)	;++016 CLEAR LENGTH OF LINE
	MOV	G.RBUF(R5),G.CMLD+2(R5) ;++016 SET BUFFER BASE ADDRESS
LVLTST:	TSTB	G.CDEP(R5)	;++012 TEST CURRENT DEPTH
	BEQ	LVL0		;++001 SPECIAL TEST IF AT LEVEL ZERO
	BGT	PROMPT		;++001 IF .GT. ZERO, THEN PROMPT FOR CMD
	CALL	GETMCR		;TRY TO GET AN MCR LINE
	BCS	NOTMCR		;+++016 IF CS NOT MCR COMMAND
A:				; ++021 REF TAG
	MOV	R1,G.CMLD+2(R5)	;+++016 ELSE SET UP START OF CMD
	BR	CMLSCN		;+++016 AND GO PROCESS
NOTMCR:


	.IF NDF	R$$11M		;++002


	OPEN$R	R5		;TOP-LEVEL OPEN

	.IFF	;R$$11M		;++002

	MOV	F.DSPT(R5),R2	;++002 GET DESCRIPTOR IN R2
	CALL	GOPEN		;++002 OPEN THE FILE

	.IFTF	;R$$11M		;++010

	BCC	LVL0		;++008 SKIP ON SUCCESS
	JMP	OPRERR		;INITIAL COMMAND FILE OPEN FAILED		;BLS002
LVL0:	BITB	#GE.MCR,G.MODE(R5) ;++001 DID WE HAVE MCR INPUT?		;**-1
	BEQ	PROMPT		;+++016 SKIP IF NOT
	CALL	GETMCR		; ++021 TRY MCR AGAIN (VAX/VMS)
	BCC	A		; ++021 SUCCESS GO BACK AND CONTINUE
	JMP	TOPEOF		;+++016 ELSE GET OUT - LEVEL 0 IS THE END

PROMPT:	TST	F.BDB(R5)	;++001 IS FILE ALREADY OPEN?
	BNE	1$		;++001 YES, SKIP THE OPEN
	CALL	POPOP1		;++001 NO, POP IT UP AND OPEN IT
1$:	CMPB	#IE.EOF,@F.BDB(R5)  ;++011 DELAYED FCS EOF PENDING?
	BNE	10$		;+++016 NO
	JMP	IOEOF		;+++016 YES
10$:				;+++016
	.IF	NDF,IAS		;+++016
	CLR	-(SP)		;++013 RESERVE WORD FOR ATTACH STATUS
	.ENDC	;IAS		;+++016
	BITB	#FD.TTY,F.RCTL(R5) ;++011 NO, IS FILE A TTY?
	BEQ	4$		;NO - DON'T PROMPT

	.IF	NDF,IAS		;+++016
	MOV	#IO.ATT,R1	;++001 SPECIFY ATTACH
	CLR	R2		;++001 NO EXTRA QIO PARMS NEEDED
	CALL	.XQIO		;++001 USE FCS TO ATTACH THE TTY
	MOVB	F.ERR(R0),(SP)	;++013 SAVE ATTACH STATUS
	.ENDC	;IAS		;+++016

	MOV	G.PSDS+2(R5),R1	;USER PROMPT STRING ADDRESS
	MOV	G.PSDS(R5),R2	;USER PROMPT STRING LENGTH
	BNE	2$		;USE USER'S STRING
	MOV	R5,R1		;USE DEFAULT PROMPT FROM BLOCK
	ADD	#G.DPRM,R1	;
	MOV	#6,R2		;EXACTLY 6 BYTE'S WORTH
2$:				;++001
	.IF	DF,IAS		;+++016 USE IO.RPR FOR IAS
	MOV	R2,-(SP)	;+++016 MAKE PARAMS, STARTING WITH PROMPT SIZE
	MOV	R1,-(SP)	;+++016 AND LENGTH
	CLR	-(SP)		;+++016 NO TIMEOUT
	MOV	#80.,-(SP)	;+++016 SET DEFAULT BUFFER SIZE
	BITB	#GE.SIZ,G.MODE(R5)	;+++016 SIZE SPECIFIED?
	BEQ	20$		;+++016 NO  -  LEAVE DEFAULT
	MOV	G.SIZE(R5),(SP)	;+++016 YES  -  SET SIZE
20$:	SUB	G.CMLD(R5),(SP)	;+++016 LESS CHARS ALREADY READ
	MOV	G.RBUF(R5),-(SP) ;+++016 NOW THE BUF ADR
	MOV	SP,R3		;+++016 FIVE PARAMS
	MOV	#5,R2		;+++016 ...
	MOV	#IO.RPR,R1	;+++016 GET FUNCTION CODE
	CALL	.XQIO		;+++016 DO THE REQUEST
	MOV	(SP)+,(SP)+	;+++016 CLEAN FIVE WORDS FROM THE STACK
	MOV	(SP)+,(SP)+	;+++016 ...
	INC	(SP)+		;+++016 ... LEAVING CC-C
	MOV	G.RBUF(R5),R1	;+++016 PICK UP BUF ADR AGAIN
	MOVB	F.ERR(R5),R3	;+++016 GET ERROR CODE
	BCS	IOERR0		;+++016 IF CS ERROR FROM HANDLER
	MOV	F.BDB(R5),R2	;+++016 GET IOSB ADR
	CMP	(R2),#IS.SUC	;+++016 LINE TOO LONG FOR BUFFER?
	BNE	3$		;+++016 SKIP IF NOT
	MOVB	#IE.RBG,R3	;+++016 ELSE CALL IT 'RECORD TOO BIG'
	BR	IOERR0		;+++016 AND GO HANDLE ERROR
3$:	MOV	2(R2),R2	;+++016 GET LENGTH OF LINE
	BR	CMLSCN		;+++016 ELSE GO SCAN THE LINE

	.IFF	;IAS		;+++016
	CLR	-(SP)		;+++016 CLEAR CARRIAGE CONTROL
	MOV	R2,-(SP)	;+++016 PUSH PROMPT LENGTH
	MOV	R1,-(SP)	;+++016 AND ADDRESS
	MOV	SP,R3		;+++016 AND SET UP PARAM BLOCK ADR
	MOV	#3,R2		;++002 SET PARAMETER COUNT
	MOV	#IO.WVB,R1	;++002 SPECIFY WRITE VIRTUAL BLOCK
	CALL	.XQIO		;++002 SEND PROMPT STRING
	INC	(SP)+		;+++016 CLEAN STACK...
	MOV	(SP)+,(SP)+	;+++016 LEAVING CC-C
	BCS	6$		;DETACH AND I/O ERROR HANDLING
	.ENDC	;IAS		;+++016
4$:				;++002
	MOV	#80.,R1		;+++016 SET DEFAULT BUFFER SIZE
	BITB	#GE.SIZ,G.MODE(R5)	;+++016 SIZE SPECIFIED?
	BEQ	40$		;+++016 NO
	MOV	G.SIZE(R5),R1	;+++016 YES  -  SET IT
40$:	SUB	G.CMLD(R5),R1	;+++016  LESS CHARS ALREADY READ

	.IFT	;R$$11M		;++010

	GET$	R5,G.RBUF(R5),R1  ;++002/016 READ A COMMAND LINE

	.IFF	;R$$11M		;++002

	GET$S	R5,G.RBUF(R5),R1  ;++002/016 READ A COMMAND LINE

	.ENDC			;++011 (R$$11M)


6$:
	.IF	DF,IAS		;+++016
	MOVB	F.ERR(R5),R3	;+++016 JUST PICK UP ERROR CODE
	.IFF	;IAS		;+++016
	MOV	F.ERR(R5),R3	;++013/016 SAVE FCS RETURN STATUS
	MOV	@F.BDB(R0),R4	;++011 AND THE FCS I/O STATUS WORD
	TSTB	(SP)+		;++013 ATTACHED? (O=> NOT TTY, -VE=> ATT. FAILED)
	BLE	8$		;++013 IF LE NOT ATTACHED

	.IF	DF,R$$11M	;++020 FOR 11M
	CALL	TTDET1		;++020 USE THE COMMON DETACH ROUTINE

	.IFF	;R$$11M		;++020 FOR 11D USE IN LINE DETACH
	MOV	#IO.DET,R1	;++001 SPECIFY DETACH
	CLR	R2		;++001 NO EXTRA QIO PARMS NEEDED
	CALL	.XQIO		;++001 USE FCS TO DETACH THE TTY
	.ENDC	;R$$11M		;++020

8$:	MOV	R4,@F.BDB(R0)	;++011 RESTORE FCS I/O STATUS WORD
	MOV	R3,F.ERR(R0)	;++013 RESTORE FCS STATUS FOR USER
	TSTB	R3		;++013 AND SEE IF IT WAS OK
	.ENDC	;IAS

	BMI	IOERR0		;++013 IF MI ERROR IN GET$
	MOV	F.NRBD+2(R5),R1	;GET COMMAND LINE ADDRESS
	MOV	F.NRBD(R5),R2	;GET COMMAND LINE LENGTH

; PROCESS COMMAND LINE OBTAINED
;    R1 IS COMMAND LINE ADDRESS
;    R2 IS COMMAND LINE LENGTH
CMLSCN:	ADD	R2,G.CMLD(R5)	;+++016 SET LENGTH
	TST	R2		;+++016 NULL LINE?
	BEQ	OKOUT		;RETURN NULL LINE TO USER
	BITB	#GE.LC,G.MODE(R5)  ;++010 DOES CALLER WANT LOWER CASE?
	BNE	30$		;++010 IF NE YES
	MOV	R2,-(SP)	;++010 SAVE CHARACTER COUNT
	ADD	R2,R1		;++010 POINT TO END OF COMMAND LINE
10$:	CMPB	-(R1),#141	;++010 LESS THAN LOWER CASE "A"?
	BLT	20$		;++010 SKIP IF TRUE
	CMPB	(R1),#172	;++010 GREATER THAN LOWER CASE "Z"?
	BGT	20$		;++010 SKIP IF TRUE
	BICB	#40,(R1)	;++010 CONVERT TO UPPER CASE
20$:	SOB	R2,10$		;++010 REPEAT FOR ENTIRE COMMAND LINE
	MOV	(SP)+,R2	;++010 RESTORE CHARACTER COUNT
30$:	BITB	#GE.MCR,G.MODE(R5)	;+++016 MCR LINE?
	BEQ	35$		;+++016 NO
	TSTB	G.CDEP(R5)	;+++016 YES  -  AT MCR LEVEL?
	BEQ	INDIR		;+++016	YES  -  NO CONTINUATION OR COMMENT
35$:	CMP	G.RBUF(R5),G.CMLD+2(R5) ;+++016 ON A CONTINUATION?
	BEQ	40$		;+++016 IF EQ NOT ON CONTINUATION
	JMP	CHKCON		;+++016 ELSE DON'T LOOK AT ';' OR '@'
40$:	CMPB	#';,(R1)	;++010 CHECK FOR ; IN COLUMN 1
	BNE	INDIR		;NO - CHECK FOR INDIRECT FILE
	BITB	#GE.COM,G.MODE(R5); COMMENTS PERMITTED ?
	BEQ	OKOUT		;+++016 N0 - RETURN TO USER
	JMP	NXTLIN		;+++016 YES - GET ANOTHER LINE
	.PAGE
; I/O ERROR AND END-OF-FILE PROCESSING
IOERR0:	CMPB	R3,#IE.RBG	;+++016 RECORD TOO BIG FOR BUFFER?
	BNE	10$		;+++016 IF NE NOT TOO BIG
	MOV	#GE.RBG,-(SP)	;+++016 ELSE ERROR CODE IS 'BUFFER SIZE'
	BR	OUT		;+++016 AND GO AWAY
10$:	CMPB	#IE.EOF,R3	;++001 END OF FILE ERROR?
	BNE	IOERR		;NO - I/O ERROR
IOEOF:	MOVB	G.CDEP(R5),R0	;++011 ARE WE AT TOP LEVEL ALREADY ?
	BEQ	TOPEOF		;YES - RETURN EOF TO CALLER
	DEC	R0		;IF NOT AT LEVEL 1
	BNE	2$		;POP UP AND CARRY ON
	BITB	#GE.MCR,G.MODE(R5);IF RETURNING TO LEVEL 0
	BNE	TOPEOF		;++001 AND TOP WAS MCR, RETURN EOF TO CALLER
2$:
	.IF	DF,R$$11M	;++020 FOR 11M MUST DETACH
	CALL	TTDET		;++020 IF LUN IS ASSIGNED TO TERMINAL
	.ENDC	;R$$11M		;++020 ELSE FOLLOWING OPEN WILL FAIL

	CALL	POPOPN		;POP UP A LEVEL
	JMP	PROMPT		;+++016 TRY FOR ANOTHER COMMAND

; EXITS FROM .GCML1 AND .GCML2

TOPEOF:	CLOSE$	R5		;CLOSE TOP LEVEL CMI
	BICB	#GE.MCR, G.MODE (R5) ; CLEAR TOP LEVEL MCR BIT		DJD001
	DECB	G.CDEP(R5)	; SET CURRENT DEPTH TO -1		DJD001
	MOV	#"TI, N.DVNM+G.DFNB(R5) ; RESET TO DEFAULT DEVICE 	DJD001
	MOVB	#FD.TTY!FD.REC!FD.CCL, F.RCTL(R5) ; RESET ATTRIBUTES	DJD001
TOPOUT:
	MOV	#GE.EOF,-(SP)	;++005 INDICATE END-OF-FILE			;**-2
	BR	OUT		;++005

OKOUT:	CLR	-(SP)		;++005 INDICATE GCML SUCCESS

OUT:	BITB	#GE.CLO,G.MODE(R5) ;++005 CLOSE FILE AFTER THIS GET?
	BEQ	1$		;++001 NO, SET RETURN INFORMATION
	MOV	F.ERR(R5),-(SP) ;++013 SAVE FCS ERROR STATUS
	CALL	CLOCRT		;++001 YES, CLOSE CURRENT LEVEL
	MOV	(SP)+,F.ERR(R5) ;++013 RESTORE ERROR STATUS FOR USER TO LOOK AT
1$:	MOVB	(SP),G.ERR(R5)	;++005 PUT RETURN CODE IN G.ERR
	ROL	(SP)+		;++005 SET C-BIT RETURN STATUS
	MOV	R5,R0		;RESTORE R0
	RETURN

IOERR:	MOV	#GE.IOR,-(SP)	;++005 INDICATE I/O ERROR
	BR	OUT		;++005
OPRERR:	MOV	#GE.OPR,-(SP)	;++005 INDICATE INDIRECT OPEN ERROR
	BR	OUT		;++005
BIFERR:	ADD	#C.SIZE,SP	;POP LINGERING CSI BLOCK FROM STACK
	MOV	#GE.BIF,-(SP)	;++005 INDICATE BAD INDIRECT FILE NAME
	BR	OUT		;++005
MDEERR:	MOV	#GE.MDE,-(SP)	;++005 INDICATE MAX INDIRECT DEPTH EXCEEDED
	BR	OUT

; RCML$ - ENTRY TO POP WORLD TO TOP LEVEL

.GCML2::.SAVR1
	MOV	R0,R5		;SET UP BLOCK POINTER
	TSTB	G.CDEP(R5)	;AT TOP ALREADY ?
	BLE	OKOUT		;++007 YES -- EXIT
10$:	DECB	G.CDEP(R5)	;++004 DECREMENT CURRENT DEPTH COUNT
	BEQ	20$		;++004 SKIP BEFORE TOP LEVEL (0) PROCESSED
	SUB	#G.PDSL,G.PPTR(R5)  ;++004 BACK UP THE PUSH-DOWN LIST PTR
	BR	10$		;++004 ITERATE
20$:	INCB	G.CDEP(R5)	;++004 INDICATE LEVEL ONE
	CALL	POPOPN		;POP THINGS UP TO LEVEL 0
	BR	OKOUT		;RETURN BLISSFULLY
	.PAGE
; SET UP TO PROCESS AN INDIRECT FILE
; LOOK FOR @ IN COLUMN 1
;    R1 IS COMMAND LINE ADDRESS
;    R2 IS COMMAND LINE LENGTH
;
INDIR:	CMPB	#'@,(R1)	;CHECK FOR @
	BNE	CHKCON		;+++016 NO - CHECK FOR CONCATENATION CHAR
	BITB	#GE.IND,G.MODE(R5); INDIRECT PERMITTED ?
	BEQ	OKOUT		;NO  - RETURN IT TO USER
; PROCESS INDIRECT FILE
	CMPB	G.CDEP(R5),G.MDEP(R5)	;CHECK DEPTH
	BGE	MDEERR		;TOO DEEP
	SUB	#C.SIZE,SP	;ALLOCATE A CSI BLOCK ON STACK
	CMPB	(R1)+,-(R2)	;SKIP OVER "@" AND DECR CHAR COUNT		;BLS002
; CALL CSI1 AND CSI2								;**-2
	CSI$1	SP,R1,R2	;CHECK SYNTAX ON FILE SPEC
	MOV	C.CMLD(R0),G.CMLD(R5)	;SET COMPRESSED LENGTH
	INC	G.CMLD(R5)	;ADJUST LENGTH FOR @ IN COLUMN 1
	BCS	BIFERR		;BAD SYNTAX
	BITB	#CS.EQU,C.STAT(R0)  ;++009 WAS EQUAL SIGN (=) FOUND?
	BNE	BIFERR		;++009 ANY INDICATION OF INPUT SPEC IS ERROR
	CSI$2	R0,OUTPUT	;GET THE OUTPUT FILE
	BCS	BIFERR		;
	BITB	#CS.WLD!CS.MOR,C.STAT(R0); NO * WILD CARDS, AND ONLY ONE FILE
	BNE	BIFERR;
	BITB	#CS.DVF!CS.NMF,C.STAT(R0);
	BEQ	BIFERR		;ERROR - NO DEVICE OR FILE NAME
; SAVE FILE ID AND POINTERS
	CALL	PSHCLS		;PUSH AND CLOSE FILE

	.IF DF	R$$11M		;++020 FOR 11M MUST ISSUE DETACH
	CALL	TTDET		;++020 IF LUN IS ASSIGNED TO TERMINAL
	.ENDC	;R$$11M		;++020 OTHERWISE THE FOLLOWING OPEN WILL FAIL

	MOV	SP,R2		;++002 POINT R2 TO THE CSI DATA ...
	ADD	#C.DSDS,R2	;++002 ... SET DESCRIPTOR
	MOV	#"SY,N.DVNM+G.DFNB(R5);DEFAULT DEVICE IS SY FOR LOWER OPEN'S


	.IF NDF	R$$11M		;++002


	OPEN$R	R5,,R2		;++002 OPEN THE FILE

	.IFF			;++002

	CALL	GOPEN		;++002 OPEN THE FILE


	.ENDC			;++002


	BCS	4$		;ERROR - CLEANUP AND REPORT ERROR
	ADD	#C.SIZE,SP	;POP CSI BLOCK FROM STACK
	CLR	G.CMLD(R5)	;+++016 CLEAR COMMAND LENGTH
	MOV	G.RBUF(R5),G.CMLD+2(R5)	;+++016  AND RESET BUFFER ADDRESS
	JMP	PROMPT		;ALL OK - GET A COMMAND LINE
4$:	ADD	#C.SIZE,SP	;POP CSI BLOCK FROM STACK
OPRBR:	BR	OPRERR		;REPORT ERROR ON @ FILE OPEN			;**-1

; CHKCON - LOOK FOR CONCATENATION CHAR ('-') AT END OF LINE
CHKCON:	BITB	#GE.CON,G.MODE(R5) ;+++016 CONTINUATION WANTED?
	BEQ	10$		;+++016 IF EQ NO
	TSTB	G.CDEP(R5)	;++019 ALWAYS ALLOWED FOR INDIRECT FILES
	BNE	2$		;++019 BRANCH IF INDIRECT FILE
	BITB	#GE.MCR,G.MODE(R5)	;+++016 MCR COMMAND LINE?
	BNE	10$		;+++016 YES  -  CONTINUATION IGNORED
2$:	ADD	R2,R1		;++019, +++016 POINT PAST END OF LINE
	CMPB	-(R1),#'-	;+++016 GOT A '-'?
	BNE	5$		;++016 FINISHED IF NOT
	DEC	R2		;+++016 REMOVE CHARACTER
	DEC	G.CMLD(R5)	;+++016 AND ADJUST USER'S COUNT
	ADD	R2,G.RBUF(R5)	;+++016 BUMP THE BUFFER POINTER
	JMP	LVLTST		;+++016 AND GO AGAIN
5$:	MOV	G.CMLD+2(R5),G.RBUF(R5)	;+++016 RESTORE BUFFER POINTER
10$:	JMP	OKOUT		;+++016 BRANCH AID TO GET OUT
	.PAGE
;
; POPOPN - SUBROUTINE TO CLOSE, POP UP, AND RE-OPEN
;
POPOPN:	CLOSE$	R5		;CLOSE CURRENT FILE
POPOP1:				;++001
	MOV	G.PPTR(R5),R4	;UPDATE PUSHDOWN POINTER
	SUB	#G.PDSL,G.PPTR(R5) ;++001 RESET PUSHDOWN PTR IN GCML BLK
	DECB	G.CDEP(R5)	;DECREASE PUSHDOWN LEVEL
	BNE	1$		; IF POPPING TO LEVEL 0
	BITB	#GE.MCR,G.MODE(R5) ;++001 AND TOP WAS AN MCR LINE,
	BNE	10$		;++017 DON'T RE-OPEN LEVEL 0
1$:	MOV	R5,R3		;++001 POINT R3 JUST PAST THE FILE ID ...
	ADD	#F.FNB+N.FID+6,R3  ;++001 ...IN THE FDB
	MOV	-(R4),-(R3)	;++001 TRANSFER ...
	MOV	-(R4),-(R3)	;++001 ... THE ...
	MOV	-(R4),-(R3)	;++001 ... FILE ID, ...
	MOV	-(R4),N.DVNM-N.FID(R3)  ;++001 ... THE DEVICE NAME, AND ...
	MOVB	-(R4),N.UNIT-N.FID(R3)  ;++011 ... UNIT NUMBER INTO THE FDB


	.IF NDF	R$$11M		;++002


	OPEN$R	R5		;RE-OPEN THE LEVEL ABOVE

	.IFF			;++002

	OFNB$R	R5		;++003 OPEN FILE BY FILENAME BLOCK


	.ENDC	;R$$11M		;++002


	BCS	4$		;ERROR ON RE-OPEN, VERY BAD
; RESTORE POINTERS INTO THE FILE
	MOVB	-(R4),-(SP)	;++011 SAVE THE OLD FCS I/O STATUS BYTE
	MOV	-(R4),R3	;BYTE-IN-BLOCK
	MOV	-(R4),R2	;
	MOV	-(R4),R1	;VIRTUAL BLOCK NUMBER
	CALL	.POINT		;FDB IS IN R0, NOW .POINT
	MOVB	(SP)+,@F.BDB(R5)  ;++011 RESTORE OLD FCS I/O STATUS
	BCC	20$		;++017 IF CC JUST RETURN -- NO ERRORS
	CMPB	#IE.EOF,F.ERR(R5);
	BEQ	20$		;++017 ANYTHING EXCEPT EOF IS AN I/O ERROR
4$:	MOV	#OPRERR,(SP)	;++017 ELSE, RETURN VIA OPEN ERROR CODE
	BR	20$		;++017
10$:	MOV	#TOPOUT,(SP)	;RETURN EOF IF POPPING TO MCR LEVEL 0		;BLS002
20$:	RETURN			;ALL IS NOW READY FOR NEXT GET$			;**-1
	.PAGE
;++001
;
; CLOSE CURRENT COMMAND LEVEL
;
;--001
.GCML3::.SAVR1			;++001 SAVE REGISTERS
	MOV	R0,R5		;++001 SET FDB POINTER
CLOCRT:	TST	F.BDB(R5)	;++001 IS FILE OPEN?
	BEQ	PSHRTN		;++001 NO, JUST RETURN

;
; PSHCLS - SUBROUTINE TO PUSH DOWN AND CLOSE
;
PSHCLS:	INCB	G.CDEP(R5)	;++001 INCREASE PUSHDOWN LEVEL
	MOV	G.PPTR(R5),R4	;NEXT PUSHDOWN FRAME
	MOV	R5,R0		;GET FDB FOR .MARK
	CALL	.MARK		;MARK CURRENT PLACE IN FILE FOR .POINT
	MOV	R1,(R4)+	;VIRTUAL BLOCK NUMBER
	MOV	R2,(R4)+	;
	MOV	R3,(R4)+	;BYTE-IN-BLOCK
	ADD	#F.FNB+N.FID,R0	;++001 POINT R0 TO FILE ID IN FDB
	MOVB	@F.BDB(R5),(R4)+  ;++011 SAVE FCS I/O STATUS BYTE
	MOVB	N.UNIT-N.FID(R0),(R4)+  ;++011 SAVE THE UNIT NUMBER, ...
	MOV	N.DVNM-N.FID(R0),(R4)+  ;++001 ...THE DEVICE NAME, AND ...
	MOV	(R0)+,(R4)+	;++001 ... THE ...
	MOV	(R0)+,(R4)+	;++001 ... FILE ID ...
	MOV	(R0)+,(R4)+	;++001 ... FROM FDB IN THE PUSH DOWN LIST
	MOV	R4,G.PPTR(R5)	;RESET PUSHDOWN FRAME
	CLOSE$	R5		;++001 CLOSE CURRENT LEVEL
PSHRTN:				;++001
	RETURN
	.PAGE
	.IF DF	R$$11M		;++002

;++002
;
; *-GOPEN-* OPEN FILE BY PERFORMING A PARSE, AND AN OPEN BY
; 	    FILE NAME BLOCK.
;
; INPUTS:
;	R2=DATA SET DESCRIPTOR ADDRESS
;	R5=FDB/GCMLB ADDRESS
;
; OUTPUTS:
;	R0,R1, AND R3 ARE LOST
;	C-BIT CLEAR INDICATES SUCCESS OF ALL THREE STEPS
;	C-BIT SET INDICATES FAILURE
;
;--002
GOPEN:	MOV	R5,R0		;++002 PUT FDB ADDR IN R0
	MOV	@#.FSRPT,R1	;++002 MUST DETERMINE IF A '.FINIT' ...
	TST	A.DFUI(R1)	;++016 ...HAS BEEN PERFORMED
	BNE	1$		;++002 IF SO, THEN SKIP
	FINIT$			;++002 INITIALIZE
1$:	MOV	R0,R1		;++002 POINT R1 TO THE ...
	ADD	#F.FNB,R1	;++002 ... FILE NAME BLOCK
	MOV	F.DFNB(R0),R3	;++002 PNT R3 TO DEFAULT FILE NAME BLOCK
	CALL	.PARSE		;++002 PARSE THE FILE NAME
	BCS	10$		;++002 SKIP ON ERROR
	OFNB$R			;++003 OPEN FILE FOR READ (VIA FNB)
10$:	RETURN			;++002


;
; DETACH THE LUN IF ASSIGNED TO TERMINAL
; R0, R1, R2 ALTERED, OTHERS PRESERVED
;

	.ENABL	LSB
TTDET:	BITB	#FD.TTY,F.RCTL(R5) ;++020 CURRENTLY ASSIGNED TO TERMINAL?
	BEQ	20$		;++020 BRANCH IF NOT
	MOV	R5,R0		;++020 FDB ADDRESS WHERE FCS EXPECTS IT
TTDET1:	MOV	#IO.DET,R1	;++020 DETACH FUNCTION CODE
	CLR	R2		;++020 NO ADDITIONAL PARAMETERS
	CALL	.XQIO		;++020 DETACH IS REQUIRED SO THAT AN
20$:	RETURN			;++020 ASSIGN LUN WILL WORK IN THE NEXT FCS CALL
	.DSABL	LSB		;++020

	.ENDC			;++002
	.PAGE
; GETMCR - SUBROUTINE CONDITIONALLY GETS AN MCR LINE
;    RETURNS
;    C=1 IF NO MCR LINE, C=0 OTHERWISE
;    R1=STRING ADDRESS
;    R2=STRING LENGTH
;    REGISTERS CHANGED R0-R4
GETMCR:	MOV	G.RBUF(R5),R1	;GET RECORD BUFFER ADDRESS
	CLRB	G.CDEP(R5)	;++001 SET CMD LEVEL TO ZERO
	MOV	(PC)+,(R1)	;SET UP "GET MCR LINE" DPB
	.BYTE	127.,41.
	DIR$	R1		;TRY TO GET AN MCR LINE
	BCS	10$		;TASK NOT INVOKED AS MCR FUNCTION
	TST	(R1)+		;POINT TO MCR LINE IN BUFFER
	MOV	@#$DSW,R2	;++006 GET MCR LINE BYTE COUNT

2$:	CALL	NXTBYT		;SCAN TO A TAB OR BLANK
	BCS	10$		;NO COMMAND LINE FOLLOWING MCR FUNCTION
	.IF	DF	R$$11M	;++015
	CMPB	R0,#'/		;++013 ALSO TERMINATE SCAN AT SLASH
	BEQ	6$		;++013 IF MATCH THEN WE'RE DONE
	.ENDC			;++015
	CMPB	R0,#TAB
	BEQ	4$
	CMPB	R0,#BLANK
	BNE	2$
4$:	CALL	NXTBYT		;SKIP TABS AND BLANKS
	BCS	10$
	CMPB	R0,#TAB
	BEQ	4$
	CMPB	R0,#BLANK
	BEQ	4$

6$:				;++013
	CMPB	-(R1),(R2)+	;++001 DECR POINTER AND INCR COUNT
	BISB	#GE.MCR,G.MODE(R5);SET TOP-LEVEL MCR FLAG
	CLC			;AND INDICATE MCR LINE GOTTEN
10$:	RETURN

; NXTBYT - GET NEXT BYTE FROM MCR LINE
;    INPUT - R1 IS STRING POINTER, R2 IS REMAINING BYTE COUNT
;    OUTPUT- R1,R2 UPDATED, R0 IS THE BYTE
;    SETS C=1 ON END OF LINE
NXTBYT:	SUB	#1,R2		;++001 DECR R2 AND SET CC-C WHEN REACH -1
	MOVB	(R1)+,R0	;GET NEXT BYTE
	RETURN

;
; CALL THE FOLLOWING ROUTINE ONCE ONLY AFTER THE FIRST GCML$ CALL TO
; CAUSE SUBSEQUENT GCML$ CALLS TO GET COMMANDS FROM THE TERMINAL AFTER GETTING
; A COMMAND FROM THE MCR COMMAND LINE.  THIS PROVIDES THE MECHANISM WHERBY
; A PROGRAM CAN RECEIVE ITS FIRST COMMAND FROM THE MCR COMMAND LINE AND
; ITS SUBSEQUENT COMMANDS FROM THE TERMINAL.  IF AN INDIRECT FILE
; WAS SPECIFIED IN THE MCR COMMAND LINE, THE PROGRAM WILL STILL GET AN EOF
; WHEN THE INDIRECT FILE IS EXHAUSTED.
;
; INPUTS:
;
;	R0 = GCML CONTROL BLOCK ADDRESS
;
; OUTPUTS:
;
;	NONE, ALL REGISTERS PRESERVED
;
.GCML4::TSTB	G.CDEP(R0)	;++020 IF AT LEVEL 0
	BNE	10$		;++020 BRANCH IF NOT
	BITB	#GE.MCR,G.MODE(R0) ;++020 AND LAST LINE WAS MCR LINE
	BEQ	10$		;++020 BRANCH IF NOT
	BICB	#GE.MCR,G.MODE(R0) ;++020 FORGET THAT MCR LINE WAS READ
	DECB	G.CDEP(R0)	;++020 AND SET UP TO GET ANOTHER MCR LINE
				;++020 WHICH WILL FAIL AND START
				;++020 GETTING LINES FROM TERMINAL
10$:	RETURN			;++020


	.END
