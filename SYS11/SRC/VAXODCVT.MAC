	.TITLE	.ODCVT
	.IDENT	/V03000/

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
;
; FACILITY:
;
;	VAX/VMS RSX11 SUPPORT ROUTINES
;
; ABSTRACT:
;
;	CONVERT ASCII DATA TO OCTAL OR DECIMAL.
;
; AUTHOR:
;
;	R.HEINEN 23-APR-1978
;--
;
; CONDITIONALIZE DECIMAL OR OCTAL VERSION NUMBERS
;
	.IIF	NDF,R$$DVN,R$$DVN=0	; 0 = OCTAL VERSION #
					; 1 = DECIMAL VERSION #
	.PSECT	$$RESL

;++
; .ODCVT -- CONVERT WITH OCTAL DEFAULT
; .VRCVT -- CONVERT VERSION NUMBER TO BINARY
; .DCCVT -- CONVERT WITH DECIMAL DEFAULT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE CONVERTS ASCII DATA TO OCTAL OR DECIMAL BASED ON
; THE ENTRY POINT AND THE STRING ITSELF.
;
; UNARY MINUS AT THE STRING START CAUSES THE CONVERSION RESULT TO BE NEGATED
; AFTER THE CONVERSION.
;
; A "#" FORCES OCTAL, A TRAILING "." FORCES DECIMAL IN THAT ORDER.
;
; INPUTS:
;
;	R3 = ADDRESS TO STORE THE RESULT
;	R4 = SIZE OF THE STRING
;	R5 = ADDRESS OF THE STRING
;
; OUTPUTS:
;
;	C-SET IF THE CONVERSION IS IN ERROR
;
;	R1,R2,R3,R4,R5 ARE SAVED.
;--
	.ENABL	LSB
 
	.IF	EQ,R$$DVN
 
.VRCVT::
 
	.ENDC
 
.ODCVT::CLR	(R3)			; SET OCTAL DEFUALT
	BR	10$			;
 
	.IF	EQ,R$$DVN-1
 
.VRCVT::
 
	.ENDC
 
.DCCVT::MOV	#2,(R3)			; SET DECIMAL DEFUALT
;
; PERFORM THE CONVERSION
;
10$:	JSR	R5,.SAVR1		; SAVE THE REGISTERS
	MOV	R0,-(SP)		; SAVE R0
	MOV	#80$,-(SP)		; SET UP CO-ROUTINE ADDRESS
	CLR	R1			; ZERO ACCUM
	MOV	R5,R2			; COPY THE STARTING ADDRESS
	ADD	R4,R2			; ADDRESS FINISH OF THE STRING
	CMPB	(R5)+,#'+		; PLUS SIGN?
	BEQ	30$			; IF EQL THEN CONTINUE
	CMPB	-(R5),#'-		; MINUS?
	BNE	30$			; IF NE THEN NO
	BIS	#100000,(R3)		; SET NEGATION FLAG - EXPLICIT MINUS
25$:	INC	R5			; PASS CHARACTER
30$:	CMP	R5,R2			; DONE?
	BHIS	200$			; IF HIS THEN DONE
	CMPB	(R5),#'#		; EXPLICIT OCTAL?
	BNE	40$			; IF NE THEN NO
	CLRB	(R3)			; SET OCTAL
	BR	25$			; CONTINUE
40$:	CMPB	#'.,-1(R2)		; EXPLICT DECIMAL?
	BNE	50$			; IF NE THEN NO
	DEC	R2			; PASS DECIMAL POINT
	BISB	#2,(R3)			; SET DECIMAL
50$:	ADD	#8.,(R3)		; CALC RANGE TEST VALUE FOR OCTAL OR DECMAL
	CLR	R4			; ZERO TEMP
60$:	CMP	R5,R2			; DONE?
	BHIS	200$			; IF HIS THEN YES
	MOVB	(R5)+,R4		; GET A DIGIT
	SUB	#'0,R4			; CONVERT FROM ASCII
	BMI	100$			; ERROR IF MINUS
	CMPB	R4,(R3)			; IN RANGE?
	BHIS	100$			; IF HIS THEN NOT IN RANGE
	MOV	R1,R0			; MULTIPLY BY 8 OR 10
	ASL	R0			;
	JSR	PC,@(SP)		; CHECK ARITHMETIC
	ASL	R0			;
	JSR	PC,@(SP)		;
	ASL	R0			;
	JSR	PC,@(SP)		;
	CMPB	#8.,(R3)		; DECIMAL?
	BEQ	70$			; IF EQL THEN NO
	ADD	R1,R0			;
	JSR	PC,@(SP)		;
	ADD	R1,R0			;
	JSR	PC,@(SP)		;
70$:	MOV	R0,R1			; ACCUM RESULT
	ADD	R4,R1			; 
	JSR	PC,@(SP)		; CHECK ARITHMETIC
	BR	60$			; AND CONTINUE
;
; ARITHMETIC TEST ROUTINE
;
80$:	BCS	90$			; IF C-SET THEN ERROR
	BVS	85$			; IF VSET THEN OTHER CHECK
	BPL	230$			; IF PLUS THEN OK
85$:	TST	(R3)			; IF RESULT IS MINUS AND EXP MINUS THEN ERROR
	BPL	230$			; IF PLUS THEN FALSE
90$:	TST	(SP)+			; POP RETURN ADDRESS 
100$:	SEC
	BR	220$			; RETURN ERROR
;
; DONE - NO ERROR
;
200$:	TST	(R3)			; EXPLICIT MINUS?
	BPL	210$			; IF PLUS THEN NO
	NEG	R1			; CONVERT 
210$:	CLC				; SET SUCCESS
220$:	MOV	R1,(R3)			; RETURN ACCUM RESLUT
	MOV	(SP)+,R0		; POP TEMP
	MOV	(SP)+,R0		; RESTORE R0
230$:	RTS	PC			; RETURN
	.END	
