	.TITLE	FCSMAC-FILE CONTROL SERVICES MACRO DEFINITIONS
	.IDENT	/V03000/
; 
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; PETER H LIPMAN		5-DEC-72
;
; ALTERED:
;
; 	S. RUZICH	02-JUL-79
;
;		SR027 -	IMPROVE DOCUMENTATION OF ANSI TAPE BIT SYMBOL CH.AND
;
; 	S. RUZICH	24-OCT-79
;
;		SR046 -	DEFINE .FCTYP BITS DESCRIBING FCS ASSEMBLY OPTIONS
;
; 	S. RUZICH	14-NOV-79
;
;		SR052 - MAKE NEW SOURCE FILE FCSMACVAX.MAC - IT IS FCSMAC.MAC 
;			WITH VAX-SPECIFIC MACROS REPLACING NON-VAX MACROS.
;			VAX ONLY - DEFINE FSR2 OFFSET A.EXDS FOR EXTENDED
;			DIRECTORY STRING BUFFER (A. GOLDSTEIN);  AFFECTS S.FSR2.
;
; 	S. RUZICH	15-APR-80
;
;		SR073 -	CSTRG$, CGET$B, AND CGET$W.
;
;	S. RUZICH	19-JAN-81
;
;		SR101 -	ANSI MAG TAPE ASCII FNB OFFSETS, NEW N.STAT BITS,
;			ACCESS CONTROL BITS FOR BLOCK LOCKING
;
;	LONI BROWN	29-APR-81
;
; 	       LEB001 - ADDED RSTS/E SPECIFIC CODE
;
;	S. RUZICH	24-AUG-81
;
;		SR165 -	REMOVE NAMED DIRECTORY DEFINITIONS, INTEGRATE LEB001.
;
;	S. RUZICH	18-NOV-81
;
;		SR198 -	MAKE OFID$W THE SAME AS OFID$U


; MCALL ALL THE FCS MACROS USED AT TOP LEVEL.
	.MACRO	FCSMC$
	.MCALL	OPEN$R,OPEN$W,OPEN$M,OPEN$U,OPEN$A,CLOSE$
	.MCALL	OPNS$R,OPNS$W,OPNS$M,OPNS$U,OPNS$A
	.MCALL	READ$,WRITE$,WAIT$,GET$,PUT$,DELET$,FINIT$
	.MCALL	FSRSZ$,FDBDF$,FDAT$A,FDRC$A,FDOP$A,FDBF$A,FDBK$A
	.MCALL	FDAT$R,FDRC$R,FDOP$R,FDBF$R,FDBK$R,NMBLK$
	.MACRO	FCSMC$
	.ENDM	FCSMC$
	.ENDM	FCSMC$
;

;  OPEN FILE FOR READING

	.MACRO	OPEN$R FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OPEN$
	OPEN$	FDB,#FO.RD,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OPEN$R

; OPEN FILE FOR WRITING
	.MACRO	OPEN$W FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OPEN$
	OPEN$	FDB,#FO.WRT,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OPEN$W

; OPEN FILE FOR MODIFY
	.MACRO	OPEN$M FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OPEN$
	OPEN$	FDB,#FO.MFY,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OPEN$M

; OPEN FILE FOR UPDATE
	.MACRO	OPEN$U FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OPEN$
	OPEN$	FDB,#FO.UPD,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OPEN$U

; OPEN FILE FOR APPEND
	.MACRO	OPEN$A FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OPEN$
	OPEN$	FDB,#FO.APD,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OPEN$A


;  OPEN FILE FOR READING - SHARED

	.MACRO	OPNS$R FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OPEN$
	OPEN$	FDB,#FA.SHR!FO.RD,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OPNS$R

; OPEN FILE FOR WRITING - SHARED
	.MACRO	OPNS$W FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OPEN$
	OPEN$	FDB,#FA.SHR!FO.WRT,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OPNS$W

; OPEN FILE FOR MODIFY - SHARED
	.MACRO	OPNS$M FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OPEN$
	OPEN$	FDB,#FA.SHR!FO.MFY,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OPNS$M

; OPEN FILE FOR UPDATE - SHARED
	.MACRO	OPNS$U FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OPEN$
	OPEN$	FDB,#FA.SHR!FO.UPD,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OPNS$U

; OPEN FILE FOR APPEND - SHARED
	.MACRO	OPNS$A FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OPEN$
	OPEN$	FDB,#FA.SHR!FO.APD,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OPNS$A

; OPEN A TEMP FILE AND MARK IT FOR DELETE
; CREATE, ACCESS, AND MARK FOR DELETE A NEW FILE
; NOT ENTERED IN A DIRECTORY
; WILL BE DELETED WHEN CLOSED (DEACCESSED)
; WILL EVEN BE PROPERLY DELETED IF PROGRAM SHOULD TERMINATE ABNORMALLY
	.MACRO	OPNT$D	FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OPNT$W
	OPNT$W	FDB,LUN,FNPT,RACC,URBA,URBS
	BCS	.+6
	JSR	PC,.MRKDL
	ERR$	ERR
	.ENDM	OPNT$D
;
; OPEN A TEMP FILE
; CREATE AND ACCESS A NEW FILE, DON'T ENTER IT IN A DIRECTORY
; FILE MAY BE CLOSED AND REOPENED BY FILE ID
; FILE SHOULD BE DELETED BEFORE THE PROGRAM EXITS OTHERWISE IT
; WILL REMAIN IN THE INDEX FILE WITH NO DIRECTORY ENTRY
	.MACRO	OPNT$W FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OPEN$
	OPEN$	FDB,#FA.TMP!FO.WRT,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OPNT$W

; OPEN FILE
	.MACRO	OPEN$ FDB,FACC,LUN,FNPT,DFNB,RACC,URBA,URBS,ERR
	.MCALL	FDOP$R,FDRC$R,ERR$,CMOV$B
	FDOP$R	FDB,LUN,FNPT,DFNB,FACC
	FDRC$R	,RACC,URBA,URBS
	.GLOBL	.OPEN
	JSR	PC,.OPEN
	ERR$	ERR
	.ENDM	OPEN$

; OPEN FILE FOR READING - BY FILE ID
	.MACRO	OFID$R FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OFID$
	OFID$	FDB,#FO.RD,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OFID$R

; OPEN FILE FOR WRITING - BY FILE ID
	.MACRO	OFID$W FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OFID$
	OFID$	FDB,#FO.UPD,LUN,FNPT,,RACC,URBA,URBS,ERR			; SR173
	.ENDM	OFID$W								;**-1

; OPEN FILE FOR MODIFY - BY FILE ID
	.MACRO	OFID$M FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OFID$
	OFID$	FDB,#FO.MFY,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OFID$M

; OPEN FILE FOR UPDATE - BY FILE ID
	.MACRO	OFID$U FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OFID$
	OFID$	FDB,#FO.UPD,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OFID$U

; OPEN FILE FOR APPEND - BY FILE ID
	.MACRO	OFID$A FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OFID$
	OFID$	FDB,#FO.APD,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OFID$A

; OPEN FILE - BY FILE ID
	.MACRO	OFID$ FDB,FACC,LUN,FNPT,DFNB,RACC,URBA,URBS,ERR
	.MCALL	FDOP$R,FDRC$R,ERR$,CMOV$B
	FDOP$R	FDB,LUN,FNPT,DFNB,FACC
	FDRC$R	,RACC,URBA,URBS
	.GLOBL	.OPFID
	JSR	PC,.OPFID
	ERR$	ERR
	.ENDM	OFID$

; OPEN FILE FOR READING - BY FILE NAME BLOCK
	.MACRO	OFNB$R FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OFNB$
	OFNB$	FDB,#FO.RD,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OFNB$R

; OPEN FILE FOR WRITING - BY FILE NAME BLOCK
	.MACRO	OFNB$W FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OFNB$
	OFNB$	FDB,#FO.WRT,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OFNB$W

; OPEN FILE FOR MODIFY - BY FILE NAME BLOCK
	.MACRO	OFNB$M FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OFNB$
	OFNB$	FDB,#FO.MFY,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OFNB$M

; OPEN FILE FOR UPDATE - BY FILE NAME BLOCK
	.MACRO	OFNB$U FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OFNB$
	OFNB$	FDB,#FO.UPD,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OFNB$U

; OPEN FILE FOR APPEND - BY FILE NAME BLOCK
	.MACRO	OFNB$A FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OFNB$
	OFNB$	FDB,#FO.APD,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OFNB$A

; OPEN FILE - BY FILE NAME BLOCK
	.MACRO	OFNB$ FDB,FACC,LUN,FNPT,DFNB,RACC,URBA,URBS,ERR
	.MCALL	FDOP$R,FDRC$R,ERR$,CMOV$B
	FDOP$R	FDB,LUN,FNPT,DFNB,FACC
	FDRC$R	,RACC,URBA,URBS
	.GLOBL	.OPFNB
	JSR	PC,.OPFNB
	ERR$	ERR
	.ENDM	OFNB$

; CLOSE THE FILE

	.MACRO	CLOSE$ FDB,ERR
	.MCALL	LDFDB$,ERR$
	LDFDB$	FDB
	.GLOBL	.CLOSE
	JSR	PC,.CLOSE
	ERR$	ERR
	.ENDM	CLOSE$

; READ A VIRTUAL BLOCK

	.MACRO	READ$ FDB,BKAD,BKSZ,BKVB,BKEF,BKST,BKDN,ERR
	.MCALL	FDBK$R,ERR$
	FDBK$R	FDB,BKAD,BKSZ,BKVB,BKEF,BKST,BKDN
	.GLOBL	.READ
	JSR	PC,.READ
	ERR$	ERR
	.ENDM	READ$
; WRITE VIRTUAL BLOCK

	.MACRO	WRITE$ FDB,BKAD,BKSZ,BKVB,BKEF,BKST,BKDN,ERR
	.MCALL	FDBK$R,ERR$
	FDBK$R	FDB,BKAD,BKSZ,BKVB,BKEF,BKST,BKDN
	.GLOBL	.WRITE
	JSR	PC,.WRITE
	ERR$	ERR
	.ENDM	WRITE$
;
; WAIT FOR I/O COMPLETION AFTER READ$ OR WRITE$
;
	.MACRO	WAIT$	FDB,EFN,BKST,ERR
	.MCALL	LDFDB$,CMOV$W,CMOV$B,ERR$
	LDFDB$	FDB
	CMOV$B	EFN,F.EFN
	CMOV$W	BKST,F.BKST
	.GLOBL	.WAIT
	JSR	PC,.WAIT
	ERR$	ERR
	.ENDM	WAIT$

; GET A RECORD

	.MACRO	GET$ FDB,INADR,MAXCNT,ERR
	.MCALL	LDFDB$,CMOV$W,ERR$
	LDFDB$	FDB
	CMOV$W	INADR,F.URBD+2	;USER RECORD BUFFER ADDRESS
	CMOV$W	MAXCNT,F.URBD	;USER RECORD BUFFER SIZE
	.GLOBL	.GET
	JSR	PC,.GET
	ERR$	ERR
	.ENDM	GET$
; GET A RECORD - IN RANDOM MODE

	.MACRO	GET$R FDB,INADR,MAXCNT,LRCNM,HRCNM,ERR
	.MCALL	LDFDB$,CMOV$W,ERR$
	LDFDB$	FDB
	CMOV$W	INADR,F.URBD+2	;USER RECORD BUFFER ADDRESS
	CMOV$W	MAXCNT,F.URBD	;USER RECORD BUFFER SIZE
	CMOV$W	LRCNM,F.RCNM+2	;LOW ORDER RECORD NUMBER
	CMOV$W	HRCNM,F.RCNM	;HIGH ORDER RECORD NUMBER
	.GLOBL	.GET
	JSR	PC,.GET
	ERR$	ERR
	.ENDM	GET$R
; GET A RECORD  - SEQUENTIAL MODE STRICTLY

	.MACRO	GET$S FDB,INADR,MAXCNT,ERR
	.MCALL	LDFDB$,CMOV$W,ERR$
	LDFDB$	FDB
	CMOV$W	INADR,F.URBD+2	;USER RECORD BUFFER ADDRESS
	CMOV$W	MAXCNT,F.URBD	;USER RECORD BUFFER SIZE
	.GLOBL	.GETSQ
	JSR	PC,.GETSQ
	ERR$	ERR
	.ENDM	GET$S

; PUT A RECORD - RANDOM OR SEQUENTIAL

	.MACRO	PUT$ FDB,OUTADR,OUTCNT,ERR
	.MCALL	LDFDB$,CMOV$W,ERR$
	LDFDB$	FDB
	CMOV$W	OUTADR,F.NRBD+2	;NEXT RECORD BUFFER ADDRESS
	CMOV$W	OUTCNT,F.NRBD	;NEXT RECORD BUFFER SIZE
	.GLOBL	.PUT
	JSR	PC,.PUT
	ERR$	ERR
	.ENDM	PUT$

; PUT A RECORD - RANDOM MODE

	.MACRO	PUT$R FDB,OUTADR,OUTCNT,LRCNM,HRCNM,ERR
	.MCALL	LDFDB$,CMOV$W,ERR$
	LDFDB$	FDB
	CMOV$W	OUTADR,F.NRBD+2	;NEXT RECORD BUFFER ADDRESS
	CMOV$W	OUTCNT,F.NRBD	;NEXT RECORD BUFFER SIZE
	CMOV$W	LRCNM,F.RCNM+2	;LOW ORDER RECORD NUMBER
	CMOV$W	HRCNM,F.RCNM	;HIGH ORDER RECORD NUMBER
	.GLOBL	.PUT
	JSR	PC,.PUT
	ERR$	ERR
	.ENDM	PUT$R

; PUT A RECORD - SEQUENTIAL MODE STRICTLY

	.MACRO	PUT$S FDB,OUTADR,OUTCNT,ERR
	.MCALL	LDFDB$,CMOV$W,ERR$
	LDFDB$	FDB
	CMOV$W	OUTADR,F.NRBD+2	;NEXT RECORD BUFFER ADDRESS
	CMOV$W	OUTCNT,F.NRBD	;NEXT RECORD BUFFER SIZE
	.GLOBL	.PUTSQ
	JSR	PC,.PUTSQ
	ERR$	ERR
	.ENDM	PUT$S

; DELETE A FILE
	.MACRO	DELET$	FDB,ERR
	.MCALL	LDFDB$,ERR$
	LDFDB$	FDB
	.GLOBL	.DELET
	JSR	PC,.DELET
	ERR$	ERR
	.ENDM	DELET$

; TRUNCATE A FILE
	.MACRO	TRUNC$	FDB,ERR
	.MCALL	LDFDB$,ERR$
	LDFDB$	FDB
	.GLOBL	.TRUNC
	JSR	PC,.TRUNC
	ERR$	ERR
	.ENDM	TRUNC$
;
; INITIALIZE THE FILE CONTROL SERVICES
	.MACRO	FINIT$
	.GLOBL	.FINIT
	JSR	PC,.FINIT
	.ENDM	FINIT$

;
;
	.MACRO	FSRSZ$ NFILES,BFSPAC,PSECT
	.MCALL	BDOFF$,DEF$L
	.IF	NDF,S.BFHD
	BDOFF$	DEF$N
	DEF$L	S.BFHD
	.ENDC
	.GLOBL	.FSRCB
	.PSECT	$$FSR1,GBL,OVR,D
	.IF	NB,<BFSPAC>
	.BLKB	NFILES*S.BFHD+<BFSPAC>
	.IFF
	.BLKB	NFILES*<S.BFHD+512.>
	.ENDC

	.PSECT	PSECT
	.ENDM	FSRSZ$

; FILE DESCRIPTOR BLOCK - ALLOCATION OF SPACE AT ASSEMBLY TIME

	.MACRO	FDBDF$
	.MCALL	FDBSZ$
	FDBSZ$
	...PC1=.
	.BLKB	S.FDB
	.ENDM	FDBDF$

; FILE ATTRIBUTE SECTION OF FDB-ASSEMBLY TIME INITIALIATION

	.MACRO	FDAT$A RTYP,RATT,RSIZ,CNTG,ALOC
	.MCALL	FDOFF$,CBYTE$,CWORD$
	FDOFF$	DEF$L
	CBYTE$	<RTYP>,F.RTYP
	CBYTE$	<RATT>,F.RATT
	CWORD$	<RSIZ>,F.RSIZ
	CWORD$	<CNTG>,F.CNTG
	CWORD$	<ALOC>,F.ALOC
	.ENDM	FDAT$A

; RECORD ACCESS SECTION OF FDB-ASSEMBLY TIME INITIALIZATION

	.MACRO	FDRC$A RACC,URBA,URBS
	.MCALL	FDOFF$,CBYTE$,CWORD$
	FDOFF$	DEF$L
	CBYTE$	<RACC>,F.RACC
	CWORD$	<URBA>,F.URBD+2
	CWORD$	<URBS>,F.URBD
	.ENDM	FDRC$A

; FILE OPEN SECTION OF FDB-ASSEMBLY TIME INITIALIZATION
	.MACRO	FDOP$A LUN,FNPT,DFNB,FACC,FACTRL
	.MCALL	FDOFF$,CBYTE$,CWORD$
	FDOFF$	DEF$L
	CBYTE$	<LUN>,F.LUN
	CWORD$	<FNPT>,F.DSPT
	CWORD$	<DFNB>,F.DFNB
	CBYTE$	<FACC>,F.FACC
	CWORD$	<FACTRL>,F.ACTL
	.ENDM	FDOP$A

; BUFFER DECRIPTOR SECTION OF FDB-ASSEMBLY TIME INITIALIZATION

	.MACRO	FDBF$A EFN,OVBS,MBCT,MBFG
	.MCALL	FDOFF$,CBYTE$,CWORD$
	FDOFF$	DEF$L
	CBYTE$	<EFN>,F.EFN
	CWORD$	<OVBS>,F.OVBS
	CBYTE$	<MBCT>,F.MBCT
	CBYTE$	<MBFG>,F.MBFG
	.ENDM	FDBF$A

; BLOCK ACCESS SECTION OF FDB ASSEMBLY TIME INITIALIZATION
	.MACRO	FDBK$A BKAD,BKSZ,BKVB,BKEF,BKST,BKDN
	.MCALL	FDOFF$,CBYTE$,CWORD$
	FDOFF$	DEF$L
	CWORD$	<BKAD>,F.BKDS+2
	CWORD$	<BKSZ>,F.BKDS
	CWORD$	<BKVB>,F.BKVB+2	;STORE LOW ORDER ONLY
	CBYTE$	<BKEF>,F.BKEF
	CWORD$	<BKST>,F.BKST
	CWORD$	<BKDN>,F.BKDN
	.ENDM	FDBK$A

; FILE ATTRIBUTE SECTION OF FDB-RUNTIME INITIALIZATION

	.MACRO	FDAT$R FDB,RTYP,RATT,RSIZ,CNTG,ALOC
	.MCALL	LDFDB$,CMOV$W,CMOV$B

	LDFDB$	FDB		;SAVE R0 AND LOAD FDB
	CMOV$B	RTYP,F.RTYP
	CMOV$B	RATT,F.RATT
	CMOV$W	RSIZ,F.RSIZ
	CMOV$W	CNTG,F.CNTG
	CMOV$W	ALOC,F.ALOC
	.ENDM	FDAT$R

; RECORD ACCESS SECTION OF FDB-RUNTIME INITIALIZATION

	.MACRO	FDRC$R FDB,RACC,URBA,URBS
	.MCALL	LDFDB$,CMOV$W,CMOV$B
	LDFDB$	FDB
	CMOV$B	RACC,F.RACC
	CMOV$W	URBA,F.URBD+2
	CMOV$W	URBS,F.URBD
	.ENDM	FDRC$R

; FILE OPEN SECTION OF FDB-RUNTIME INITIALIZATION

	.MACRO	FDOP$R FDB,LUN,FNPT,DFNB,FACC,FACTRL
	.MCALL	LDFDB$,CMOV$W,CMOV$B
	LDFDB$	FDB
	CMOV$B	LUN,F.LUN
	CMOV$W	FNPT,F.DSPT
	CMOV$W	DFNB,F.DFNB
	CMOV$B	FACC,F.FACC
	CMOV$W	FACTRL,F.ACTL
	.ENDM	FDOP$R

; BLOCK BUFFER SECTION OF FDB-RUNTIME INITIALIZATION.

	.MACRO	FDBF$R FDB,EFN,OVBS,MBCT,MBFG
	.MCALL	LDFDB$,CMOV$W,CMOV$B
	LDFDB$	FDB
	CMOV$B	EFN,F.EFN	;EVENT FLAG TO USE
	CMOV$W	OVBS,F.OVBS	;SIZE OF BLOCK BUFFER
	CMOV$B	MBCT,F.MBCT	;NO. OF BUFFERS
	CMOV$B	MBFG,F.MBFG	;READ AHEAD OR WRITE BEHIND
	.ENDM	FDBF$R

; BLOCK ACCESS SECTION OF FDB-RUNTIME INITIALIZATION

	.MACRO	FDBK$R FDB,BKAD,BKSZ,BKVB,BKEF,BKST,BKDN
	.MCALL	LDFDB$,CMOV$B,CMOV$W,CMOV$2
	LDFDB$	FDB
	CMOV$W	BKAD,F.BKDS+2	;BLOCK ADDRESS-MEMORY BUFFER
	CMOV$W	BKSZ,F.BKDS	;SIZE OF TRANSFER IN BYTES
	CMOV$2	BKVB,F.BKVB	;ADDRESS OF 2 WORD VIRTUAL
				;BLOCK NUMBER, MOVE BOTH WORDS
	CMOV$B	BKEF,F.BKEF	;EVENT FLAG
	CMOV$W	BKST,F.BKST	;ADR OF I/O STATUS BLOCK
	CMOV$W	BKDN,F.BKDN	;ADR OF I/O DONE AST
	.ENDM	FDBK$R

; DEFINE THE SIZE OF THE FDB AS A LOCAL SYMBOL (S.FDB)
	.MACRO	FDBSZ$		;DEFINE S.FDB AS SIZE OF FDB
	.IIF	DF,S.FDB,.MEXIT
	.MCALL	FDOFF$,DEF$L
	FDOFF$	DEF$N		;INVOKE OFFSET DEFINITIONS BUT DON'T
				;ACTUALLY DEFINE THE OFFSET NAMES
	DEF$L	S.FDB		;NOW DEFINE S.FDB
	.ENDM	FDBSZ$

; INVOKE FDOFF$ TO DEFINE OFFSETS AS LOCAL - DO IT ONCE ONLY
	.MACRO	FDOF$L
	.MCALL	FDOFF$
	FDOFF$	DEF$L
	.ENDM	FDOF$L
;
; DEFINE FILE NAME BLOCK AT ASEMBLY TIME
	.MACRO	NMBLK$	FNAME,FTYPE,VERS,DEVNAM,UNIT
	.MCALL	RAD50$,CWORD$,NBOFF$
	NBOFF$	DEF$L		;DEFINE NAME BLOCK OFFSETS LOCALLY
	.IIF	NDF,...PC1,...PC1=0
	...PC3=...PC1		;PRESERVE ...PC1
	...PC1=.
	.=...PC1+N.FNAM
	RAD50$	<FNAME>,S.FNAM/2
	.=...PC1+N.FTYP
	RAD50$	<FTYPE>,S.FTYP/2
	CWORD$	<VERS>,N.FVER
	.IF	NB,DEVNAM
	.=...PC1+N.DVNM
	.WORD	"DEVNAM
	.ENDC
	CWORD$	<UNIT>,N.UNIT
	.=...PC1+S.FNB
	...PC1=...PC3		;RESTORE ...PC1
	.ENDM	NMBLK$
;
; INVOKE NBOFF$ TO DEFINE OFFSETS AS LOCAL - DO IT ONCE ONLY
	.MACRO	NBOF$L
	.MCALL	NBOFF$
	NBOFF$	DEF$L
	.ENDM	NBOF$L


; IF THE FDB PARAM IS NULL OR R0, THEN DON'T
; GENERATE A MOVE OF FDB TO R0.  OTHERWISE
; GENERATE THE MOVE

	.MACRO	LDFDB$ FDB
	.IIF	B,FDB,.MEXIT	;IF NULL THEN EXIT
	.NTYPE	PAR$$$,FDB
	.IIF	EQ,PAR$$$,.MEXIT ;IF R0 THEN EXIT
	MOV	FDB,R0		;ELSE GENERATE THE MOVE
	.ENDM	LDFDB$

; CONDITIONALLY MOVE A WORD TO THE SPECIFIED OFFSET OF R0

	.MACRO	CMOV$W VAR,OFFSET
	.IF	IDN,<#0>,<VAR>
	CLR	OFFSET(R0)
	.MEXIT
	.ENDC
	.IIF	NB,VAR,	MOV	VAR,OFFSET(R0)
	.ENDM	CMOV$W

; CONDITIONALLY GENERATE A MOVE BYTE TO THE SPECIFIED OFFSET OF R0

	.MACRO	CMOV$B VAR,OFFSET
	.IF	IDN,<#0>,<VAR>
	CLRB	OFFSET(R0)
	.MEXIT
	.ENDC
	.IIF	NB,VAR,	MOVB VAR,OFFSET(R0)
	.ENDM	CMOV$B

; CONDITIONALLY MOVE 2 WORDS FROM VAR TO THE SPECIFIED OFFSET OF R0
	.MACRO	CMOV$2 VAR,OFFSET
	.IIF	B,VAR,.MEXIT
	MOV	VAR,-(SP)	;ADDRESS OF 2 WORDS TO STATE
	MOV	@(SP),OFFSET(R0) ;FIRST WORD TO FDB
	ADD	#2,(SP)		;CALCULATE ADR OF 2ND WORD
	MOV	@(SP)+,OFFSET+2(R0) ;2ND WORD TO FDB
	.ENDM	CMOV$2

; CONDITIONALLY ASSEMBLE .BYTE DIRECTIVE FOR VAR
; AT THE SPECIFIED OFFSET FROM THE BEGINNING OF THE FDB

	.MACRO	CBYTE$ VAR,OFFSET
	.IF	NB,VAR		;IF NON NULL
	...PC2=.		;SAVE PC
	.=...PC1+OFFSET		;SET PC TO SPECIFIED OFFSET
	.BYTE	VAR		;ASSEMBLE THE BYTE
	.=...PC2		;RESTORE PC
	.ENDC
	.ENDM	CBYTE$


; CONDITIONALLY ASSEMBLE WORD DIRECTIVE FOR VAR
; AT THE SPECIFIED OFFSET FROM THE BEGINNING OF THE FDB

	.MACRO	CWORD$ VAR,OFFSET
	.IF NB,VAR		;IF VAR IS NOT NULL
	...PC2=.		;SAVE THE PC
	.=...PC1+OFFSET		;SET THE PC TO THE SPECIFIED OFFSET
	.WORD	VAR		;ASSEMBLE THE WORD
	.=...PC2		;RESTORE THE PC
	.ENDC
	.ENDM	CWORD$
										; SR073
;										; SR073
; MACRO TO INSERT AN ASCII STRING AT SPECIFIED OFFSET				; SR073
;										; SR073
	.MACRO CSTRG$ VAR,OFFSET,MAXLG,FILL=0					; SR073
	.IF NB,<VAR>		; IF THE STRING TO INSERT IS NON NULL		; SR073
	 .NCHR ...PC3,<VAR>	; PICK UP STRING LENGTH				; SR073
	 .IF GE MAXLG-...PC3	; VERIFY IT IS NOT TOO LONG			; SR073
	  ...PC2=.		; SAVE CURRENT PC				; SR073
	  .=...PC1+OFFSET	; ADDRESS DESIRED OFFSET			; SR073
	  .ASCII ^VAR^		; INSERT VALUE AT OFFSET			; SR073
	  .REPT MAXLG-...PC3	; PAD TO MAXIMUM LENGTH				; SR073
	  .BYTE FILL								; SR073
	  .ENDR									; SR073
	  .=...PC2		; RETURN TO PREVIOUS PC				; SR073
	 .IFF									; SR073
	  .ERROR 		; ARGUMENT TOO LONG				; SR073
	 .ENDC									; SR073
	.ENDC									; SR073
	.ENDM	CSTRG$								; SR073
;										; SR073
; MACROS TO ACCESS FIELDS IN THE STRUCTURE CURRENTLY POINTED TO			; SR073
; BY R0.									; SR073
;										; SR073
	.MACRO	CGET$B	OFFSET,VAR						; SR073
	.IIF NB <VAR>	MOVB	OFFSET(R0),VAR					; SR073
	.ENDM									; SR073
										; SR073
	.MACRO	CGET$W	OFFSET,VAR						; SR073
	.IIF NB <VAR>	MOV	OFFSET(R0),VAR					; SR073
	.ENDM									; SR073
										; SR073

; DEFINE FCS BITS AND VALUES LOCALLY OR GLOBALLY
; CALL WITH DEF$G FOR GLOBAL DEFINITIONS, CONVENTIONALLY
; CALLED WITH DEF$L FOR LOCAL, BUT ANYTHING NOT EQUAL TO DEF$G
; WILL DO
	.MACRO	FCSBT$	GLOBL
	.MCALL	DEFIN$
	...GBL=0
	.IIF	IDN,<GLOBL>,<DEF$G>,...GBL=1
;
;
; F.RATT BITS - RECORD ATTRIBUTE BYTE
	DEFIN$	FD.FTN,1	;FORTRAN CARRIAGE CONTROL BIT
	DEFIN$	FD.CR,2		;INSERT CARRIAGE RETURNS BETWEEN RECORDS
	DEFIN$	FD.PRN,4	; R.SEQ/VFC PRINT FILE
	DEFIN$	FD.BLK,10	;1 IF RECORDS CANNOT CROSS BLOCK BOUNDARIES
; F.RACC BITS - RECORD ACCESS BYTE
	DEFIN$	FD.RWM,1	;ON IF READ/WRITE,OFF IF GET/PUT
	DEFIN$	FD.RAN,2	;ON IF RANDOM,OFF IF SEQUENTIAL
	DEFIN$	FD.PLC,4	;ON IF PARTIAL LOCATE,OFF IF SEQUENTIAL
	DEFIN$	FD.INS,10	;ON IF PUT SEQUENTIAL INSERT MODE
				;OFF IF TRUNCATE MODE
; F.RCTL BITS - RECORD CONTROL BYTE - DEVICE CHARACTERISTICS
	DEFIN$	FD.REC,1	;ON IF RECORD ORIENTED DEV, OFF IF BLK ORIENTED
	DEFIN$	FD.CCL,2	;ON IF CARRIAGE CONTROL OUTPUT DEVICE
				;OFF IF NOT
	DEFIN$	FD.TTY,4	;ON IF THIS DEVICE IS A TTY
	DEFIN$	FD.DIR,10	;ON IF DIRECTORY DEVICE, OFF IF NOT
	DEFIN$	FD.SDI,20	;ON IF SINGLE DIRECTORY DEVICE
	DEFIN$	FD.SQD,40	;ON IF SEQUENTIAL DEVICE
	DEFIN$	FD.ISP,2000	;INPUT SPOOLING
	DEFIN$	FD.OSP,4000	;OUTPUT SPOOLING
	DEFIN$	FD.PSE,10000
	DEFIN$	FD.COM,20000
	DEFIN$	FD.F11,40000
	DEFIN$	FD.MNT,100000
;
; N.STAT BITS - FILE NAME BLOCK STATUS WORD - SET BY PARSE
	DEFIN$	NB.VER,1	;SET IF FILE VERSION WAS EXPLICIT
	DEFIN$	NB.TYP,2	;SET IF FILE TYPE WAS EXPLICIT
	DEFIN$	NB.NAM,4	;SET IF FILE NAME WAS EXPLICIT
	DEFIN$	NB.SVR,10	;SET IF * IN VERSION FIELD
	DEFIN$	NB.STP,20	;SET IF * IN TYPE FIELD
	DEFIN$	NB.SNM,40	;SET IF * IN NAME FILED
	DEFIN$	NB.DIR,100	;SET IF EXPLICIT DIRECTORY SPECIFIED
	DEFIN$	NB.DEV,200	;SET IF DEVICE NAME WAS EXPLICIT
	DEFIN$	NB.SD1,400	;SET IF * IN PROJECT NUMBER OF PPN
	DEFIN$	NB.SD2,1000	;SET IF * IN PROGRAMMER NUMBER OF PPN
	DEFIN$	NB.ANS,2000	;SET IF QUOTED NAME FOUND			; SR101
	DEFIN$	NB.WCH,4000	;WILD CHARACTER PROCESSING REQUIRED		; SR101
; ***** BEWARE MORE BITS IN N.STAT USED BY FCS AND PIP LOCALLY			; SR101
; CHECK DEFINITION SECTION IN FCSPRE						; SR101
;										;**-2
; F.RTYP VALUES - RECORD TYPE BYTE - ***** NOTE THESE ARE VALUES, NOT BITS
	DEFIN$	R.FIX,1		;FIXED LENGTH RECORDS
	DEFIN$	R.VAR,2		;VARIABLE LENGTH RECORDS
	DEFIN$	R.SEQ,3		;SEQUENCED RECORDS
	DEFIN$	R.STM,4		;STREAM ASCII RECORDS				;LEB001
;
; F.FACC BITS - FILE ACCESS BYTE
	DEFIN$	FA.RD,1		;SET IF READ ONLY
	DEFIN$	FA.WRT,2	;SET IF ACCESSED FOR WRITE
	DEFIN$	FA.EXT,4	;SET IF ACCESS FOR EXTEND
	DEFIN$	FA.CRE,10	;SET IF CREATING NEW FILE
	DEFIN$	FA.TMP,20	;SET IF CREATING TEMP FILE
	DEFIN$	FA.SHR,40	;SET IF SHARED ACCESS
;
; THE FOLLOWING TWO NAMES APPLY TO THE SAME CONTROL BIT IN F.FACC
; FA.APD IS ONLY USED IF THE FILE IS AN EXISTING FILE (FA.CRE=0)
; FA.NSP IS ONLY USED IF THE FILE IS BEING CREATED (FA.CRE=1)
;
; BIT VALUE 200 IN F.FACC IS RESERVED FOR USE BY RSTS/E, FOR THEIR FO.TSK	; SR165
; TASK IMAGE FILE ACCESS.							; SR165
;										; SR165
	DEFIN$	FA.APD,100	;SET IF APPENDING (POSIT TO EOF)
	DEFIN$	FA.NSP,100	;SET IF INHIBITING SUPERSEDE ON FILE CREATION
;										;**-1
	DEFIN$	FO.RD,FA.RD	;OPEN FOR READ
	DEFIN$	FO.WRT,FA.WRT!FA.EXT!FA.CRE ;OPEN FOR WRITE (CREATE)
	DEFIN$	FO.APD,FA.WRT!FA.EXT!FA.APD ;OPEN FOR APPEND
	DEFIN$	FO.MFY,FA.WRT	;OPEN FOR MODIFY
	DEFIN$	FO.UPD,FA.WRT!FA.EXT ;OPEN FOR UPDATE
;
; DEFINE THE NEW BITS IN F.ACTL IN THE FDB
; SEVERAL OF THESE BITS ALSO HAVE LOCAL
; DEFINITIONS IN FCSPRE.MAC. HOWEVER ALL
; DEFINITONS ARE MUTUALLY EXCLUSIVE.
;
	DEFIN$	FA.ENB,100000	; ENABLE USE OF F.ACTL WORD
	DEFIN$	FA.SEQ,40000	;ENABLE SEQUENTIAL PROCESSING ONLY (NON-RSX)	; SR101
	DEFIN$	FA.WCK,20000	;ENABLE WRITE CHECK				; SR101
	DEFIN$	FA.POS,10000	; FILE CREATION POS. CTRL FOR MAGTAPE		; SR101
	DEFIN$	FA.RWD,4000	; ENABLE REWIND CONTROL FOR MAGTAPE		; SR101
	DEFIN$	FA.EXL,4000	;ENABLE MANUAL BLOCK LOCKING			; SR101
	DEFIN$	FA.LKL,2000	;ENABLE BLOCK BLOCKING				; SR101
	DEFIN$	FA.EXC,2000	;EXCLUSIVE USE BIT				; SR101
	DEFIN$	FA.DLK,1000	; ENABLE NO LOCK ON ABNORMAL CLOSE		; SR101
	DEFIN$	CH.AND,1	;ANSI FORMAT MAG TAPE: 'D' (VARIABLE LENGTH),	; SR027
				;OR 'F' (FIXED LENGTH, INCLUDING BLOCK I/O)	; SR027
;										;**-9
; F.MBFG BITS - MULTIPLE BUFFERING FLAG WORD - USER CONTROLLED AND SET BY OPEN
	DEFIN$	FD.RAH,1	;READ AHEAD IF SET - THIS OR WRITE BEHIND
	DEFIN$	FD.WBH,2	;WRITE BEHIND IF SET - NOT BOTH
; ***** BEWARE MORE BITS IN F.MBFG USED IN FCS LOCALLY
;
; DEFINE THE .CTRL FUNCTION CODES
;
	DEFIN$	FF.RWD,1	; REWIND
	DEFIN$	FF.POE,2	; POSITION TO END OF VOLUME (SET)
	DEFIN$	FF.NV,3		; NEXT VOLUME
	DEFIN$	FF.SPC,4	; SPACE
	DEFIN$	FF.CHR,5	; GET APC CHARACTERISTICS
	DEFIN$	FF.RWF,6	;ERS REWIND FILE
;
; DEFINE BITS USED IN .FCTYP TO DESCRIBE FCS CONDITIONAL ASSEMBLY OPTIONS	; SR046
;										; SR046
;										; SR046
	DEFIN$	FT.ANI,1	; ANSI MAG TAPE FCS (CONDITIONAL R$$ANI > 1)	; SR046
	DEFIN$	FT.BBF,2	; BIG BUFFERED FCS (R$$BBF > 1)			; SR046
	DEFIN$	FT.MBF,4	; MULTI BUFFERED FCS (R$$MBF > 1)		; SR046
;										; SR046
;
	.MACRO	FCSBT$	ARG
	.ENDM	FCSBT$
	.ENDM	FCSBT$
;
; EQUATE THE SYMBOL WITH ITS SPECIFIED VALUE
; DEFINE IT GLOBALLY IF ...GBL=1, OTHERWISE LOCALLY
	.MACRO	DEFIN$	SYM,VAL
	.IIF	EQ,...GBL-1,.GLOBL SYM
	SYM=^O<VAL>
	.ENDM	DEFIN$

; FILE DESCRIPTOR BLOCK OFFSETS DEFINITION MACRO
; CALL WITH ONE OF THE FOLLOWING MACRO NAMES DEF$L,DEF$G,DEF$N
; TO DEFINE LOCAL OFFSETS, DEFINE TOTAL OFFSETS,
; OR DEFINE NO OFFSETS.  THE LATTER SETS THINGS UP
; SO THAT ONLY THE SIZE OF THE FDB CAN BE
; DEFINED

	.MACRO	FDOFF$ OFFSET
	.MCALL	OFFSET,DEF$I,NBOFF$
	NBOFF$	OFFSET
	DEF$I	0		;INIT THE DEFINITION MACRO
; FILE ATTRIBUTE SECTION
	OFFSET	F.RTYP,1	;RECORD TYPE
	OFFSET	F.RATT,1	;RECORD ATTRIBUTES
	OFFSET	F.RSIZ,2	;RECORD SIZE
	OFFSET	F.HIBK,4	;HIGHEST VIRTUAL BLOCK NO. ALLOCATED
	OFFSET	F.EFBK,4	;END OF FILE BLOCK NUMBER
	OFFSET	F.FFBY,2	;FIRST FREE BYTE IN LAST BLOCK
	OFFSET	S.FATT		;SIZE OF FILE ATTRIBUTE SECTION

; RECORD ACCESS SECTION

	OFFSET	F.RACC,1	;RECORD ACCESS
	OFFSET	F.RCTL,1	;RECORD CONTROL
	OFFSET	F.BKDS		;BLOCK I/O - BUFFER DESCRIPTOR
	OFFSET	F.URBD,4	;USER'S RECORD BUFFER DESCRIPTOR
	OFFSET	F.BKST		;BLOCK I/O - I/O STATUS BLOCK ADDRESS
	OFFSET	F.NRBD,2	;NEXT RECORD BUFFER DESCRIPTOR
	OFFSET	F.BKDN		;BLOCK I/O - I/O DONE AST ADDRESS
	OFFSET	,2		;2ND WORD OF NRBD
	OFFSET	F.OVBS		;OVERRIDE BLOCK BUFFER SIZE
	OFFSET	F.NREC,2	;NEXT RECORD ADDRESS IN BLOCK BUFFER
	OFFSET	F.EOBB,2	;END OF BLOCK BUFFER
	OFFSET	F.CNTG		;SIZE IN BLOCKS OF CONTIGUOUS FILE
	OFFSET	F.RCNM,2	;RECORD NUMBER FOR RANDOM RECORDS
	OFFSET	F.STBK		;ADDRESS TO READ IN STATISTICS BLOCK
	OFFSET	,2		;2ND WORD OF RCNM
	OFFSET	F.ALOC,2	;ALLOCATE THIS MUCH SPACE WHEN NEED
				;TO EXTEND, + = CONTIG, - = NOT

; FILE OPEN SECTION
	OFFSET	F.LUN,1		;LOGICAL UNIT NUMBER
	OFFSET	F.FACC,1	;FILE ACCESS
	OFFSET	F.DSPT,2	;FILE DESCRIPTOR POINTER
	OFFSET	F.DFNB,2	;DEFAULT FILE NAME BLOCK ADDRESS

; BLOCK BUFFER SECTION
	OFFSET	F.BKEF		;BLOCK I/O - EVENT FLAG NUMBER
	OFFSET	F.EFN,1		;EVENT FLAG USED IN QIO
	OFFSET	F.BKP1,1	;BOOKKEEPING BITS
	OFFSET	F.ERR,2		;1ST BYTE ERROR RETURN CODE
				;2ND BYTE FOR QI/O ERROR INDICATOR
	OFFSET	F.MBCT,1	;NUMBER OF BUFFERS TO USE (DESIRED)
	OFFSET	F.MBC1,1	;NO. OF BUFFERS IN USE
	OFFSET	F.MBFG,1	;MULTIPLE BUFFERING CONTROL FLAGS
	OFFSET	F.BGBC,1	;BIG BUFFER BLOCK COUNT (SIZE IN BLOCKS)
				;ALSO USED FOR ANSI TAPE INPUT BUFFER OFFSET	; SR101
	OFFSET	F.VBSZ,2	;VIRTUAL BLOCK SIZE IN BYTES
	OFFSET	F.BBFS,2	;BLOCK BUFFER SIZE
	OFFSET	F.BKVB		;BLOCK I/O - VIRTUAL BLOCK NUMBER
	OFFSET	F.VBN,4		;VIRTUAL BLOCK NUMBER
	OFFSET	F.BDB,2		;BLOCK BUFFER DESCRIPTOR BLOCK
	OFFSET	F.SPDV,2	;SPOOL DEVICE INDICATOR
	OFFSET	F.SPUN,1	;SPOOL UNIT DESIGNATOR
	OFFSET	F.CHR,1		;ACP VOLUME CHARACTERISTICS SUMMARY BYTE
	OFFSET	F.ACTL,2	;ACCESS CONTROL WORD
	OFFSET	F.SEQN,2	;SEQUENCE NUMBER FOR SEQUENCED FILES

; FILE NAME BLOCK SECTION
	OFFSET	F.FNB,S.FNB	;BEGINNING OF FILE NAME BLOCK
	.IIF	IDN,<OFFSET>,<DEF$N>,.MEXIT
	.IF	IDN,<OFFSET>,<DEF$G>
	.GLOBL	F.FNAM,F.FTYP,F.FVER,F.DVNM,F.UNIT
	.ENDC
	F.FNAM=N.FNAM+F.FNB
	F.FTYP=N.FTYP+F.FNB
	F.FVER=N.FVER+F.FNB
	F.DVNM=N.DVNM+F.FNB
	F.UNIT=N.UNIT+F.FNB
	OFFSET	S.FDB		;SIZE OF FDB
	.MACRO	FDOFF$	ARG
	.ENDM	FDOFF$
	.ENDM	FDOFF$

; BUFFER DESCRIPTOR OFFSETS-SAME TYPE OF CALL AS FOR FILE DESCRIPTOR OFFSETS
	.MACRO	BDOFF$ OFFSET
	.MCALL	OFFSET,DEF$I
	DEF$I	0
	OFFSET	,4
	OFFSET	B.VBN,4		;VIRTUAL BLOCK NUMBER FOR THIS BUFFER
	OFFSET	B.BBFS,2	;NUMBER OF BYTES READ OR WRITTEN
	OFFSET	B.NXBD,2	;POINTER TO NEXT BUFFER DESCRIPTOR
	OFFSET	,1		;SPARE BYTE
	OFFSET	B.BFST,1	;BUFFER STATUS BYTE
	OFFSET	,2
	OFFSET	S.BFHD
	.IIF	IDN,<DEF$N>,<OFFSET>,.MEXIT
	.MACRO	BDOFF$	ARG
	.ENDM	BDOFF$
	.ENDM	BDOFF$

; NAME BLOCK OFFSET - LIKE FDOFF
	.MACRO	NBOFF$	OFFSET
	.MCALL	OFFSET,DEF$I,DEF$L
	DEF$I	0
	OFFSET	S.FNAM		;DEFINE AS GLOBAL IF PARAMETER
	OFFSET	S.FTYP		;IS DEF$G
	OFFSET	S.FNTY
	OFFSET	S.FNBW
	OFFSET	S.ANM1								; SR101
	OFFSET	S.ANM2								; SR101
	S.FNAM=6		;SIZE OF FILENAME IN BYTES			; SR101
	S.FTYP=2		;SIZE OF FILE TYPE IN BYTES			; SR101
	S.ANM1=12.		;SIZE OF ANSI NAME FIELD 1			; SR101
	S.ANM2=5.		;SIZE OF ANSI NAME FIELD 2			; SR101
	S.FNTY=<S.FNAM+S.FTYP>/2  ;SIZE OF FILENAME + TYPE IN WORDS		; SR101
	OFFSET	N.FID,2		;FILE ID (REALLY 6 BYTES, FOR DISK)		; SR101
	OFFSET	N.ANM1,4	;ANM1 OVERLAYS FID WORDS 2 AND 3, FNAM, FTYP	; SR101
	OFFSET	N.FNAM,S.FNAM	;FILENAME					;**-4
	OFFSET	N.FTYP,S.FTYP	;TYPE
	OFFSET	N.FVER,2	;VERSION
	OFFSET	S.NFEN		;SIZE OF NAME FILE ENTRY IN BYTES
	DEF$L	S.NFEN		;FORCE AT LEAST A LOCAL DEFINITION
	OFFSET	N.STAT,2	;STATUS
	OFFSET	N.NEXT,2	;TEMP CELL FOR FIND NEXT
	OFFSET	N.ANM2		;ANSI NAME 2 OVERLAYS DID			; SR101
	OFFSET	N.DID,6		;DIRECTORY ID
	OFFSET	N.DVNM,2	;DEVICE NAME IN ASCII
	OFFSET	N.UNIT,2	;UNIT NUMBER
	OFFSET	S.FNB		;SIZE OF FNB IN BYTES
	DEF$L	S.FNB		;FORCE LOCAL DEFINITION AT LEAST
	S.FNBW=S.FNB/2		;SIZE OF FNB IN WORDS
	.IIF	IDN,<DEF$N>,<OFFSET>,.MEXIT ;DON'T REDEFINE THE MACRO
	.MACRO	NBOFF$	ARG
	.ENDM	NBOFF$
	.ENDM	NBOFF$

;
; FILE STORAGE REGION OFFSETS - LIKE FDOFF
	.MACRO	FSROF$	OFFSET
	.MCALL	OFFSET,DEF$I,DEF$L
;
; DEFINE THE OFFSETS FOR $$FSR2
	DEF$I	0

	OFFSET	,4		;LIST HEAD FOR ALLOCATION
	OFFSET	A.BFSR,2	;FIRST ADDRESS IN FSR1
	OFFSET	A.EFSR,2	;LAST ADDRESS IN FSR1
;
; ***** DO NOT SEPARATE THE FOLLOWING 2 DEFINITIONS
;
	OFFSET	A.OWUI,2	;UIC OF OWNER (FROM TASK HEADER)
	OFFSET	A.FIPR,2	;DEFAULT FILE PROTECTION WORD
;
; DO NOT SEPARATE THE PRECEEDING 2 DEFINITIONS
;
; ***** DO NOT SEPARATE THE FOLLOWING 3 DEFINTIONS
;
	OFFSET	A.DPB,24.	;QI/O DPB AND SCRATCH AREA
	OFFSET	A.IOST,4	;SCRATCH I/O STATUS BLOCK
	OFFSET	A.DFDR,26.	;DEFAULT DIRECTORY INFORMATION			;BJL003
;
; DO NOT SEPARATE THE PRECEEDING 3 DEFINITIONS
;
	OFFSET	A.DFBC,2	;DEFAULT BUFFER CNT (MULTIPLE BUFFERING)
	OFFSET	A.DFUI,2	;DEFAULT UIC (TASK UIC)
	OFFSET	A.EXDS,80.	;VAX EXTENDED DIRECTORY STRING BUFFER		; SR052
	OFFSET	S.FSR2		;SIZE OF FILE STORAGE REGION 2
	DEF$L	S.FSR2
;
; DEFINE OFFSETS RELATIVE TO BEGINNING OF THE DEFAULT DIRECTORY INFO

	DEF$I	0

	OFFSET	,16.								;BJL003
	OFFSET	D.DFID,6	;DEFAULT DIRECTORY ID
	OFFSET	D.DFDV,2	;DEV NAME FOR DFLT DIR ID
	OFFSET	D.DFUN,2	;UNIT NUMBER FOR DFLT DIR ID
;
	.IIF	IDN,<DEF$N>,<OFFSET>,.MEXIT
	.MACRO	FSROF$	ARG
	.ENDM	FSROF$
	.ENDM	FSROF$
;
; DEFINE OFFSETS RELATIVE TO THE FILE DESCRIPTOR POINTER, F.DSPT
	.MACRO	FDSOF$	OFFSET
	.MCALL	OFFSET,DEF$I,DEF$L
	DEF$I	0
;
	OFFSET	N.DEVD,4	;DEVICE STRING DESCRIPTOR
	OFFSET	N.DIRD,4	;DIRECTORY STRING DESCRIPTOR
	OFFSET	N.FNMD,4	;FILE NAME STRING DESCRIPTOR
	OFFSET	S.FIDS
	.IF	IDN,<DEF$N>,<OFFSET>
	DEF$L	S.FIDS
	.MEXIT
	.ENDC
	.MACRO	FDSOF$	ARG
	.ENDM	FDSOF$
	.ENDM	FDSOF$

	.MACRO	DEF$G VAR,SIZ	;DEFINE GLOBAL OFFSET
	.MCALL	DEF$L
	.IIF	NB,VAR,.GLOBL VAR
	DEF$L	VAR,SIZ
	.ENDM	DEF$G

	.MACRO	DEF$N VAR,SIZ	;DEFINE NO OFFSET-CALCULATE THE SIZE
	.MCALL	DEF$L
	DEF$L	,SIZ
	.ENDM	DEF$N

	.MACRO	DEF$I IVAL	;INITIALIZE DEFINITION
	...TPC=^O<IVAL>		;MACROS PROGRAM COUNTER
	.ENDM	DEF$I

	.MACRO	DEF$L SYM,SIZ
	.IF NB,SYM
	SYM=^O<...TPC>
	.ENDC
	.IF NB,SIZ
	...TPC=^O<...TPC+SIZ>
	.ENDC
	.ENDM	DEF$L
;
	.MACRO	RAD50$	STRING,MAXWRD
	...PC2=.
	.RAD50	/STRING/
	.IF	GT,<.-...PC2>-^O<2*MAXWRD>
	.ERROR	;STRING		RAD50 - STRING TOO LONG, TRUNCATED;
	.=^O<...PC2+<2*MAXWRD>>
	.MEXIT
	.ENDC
	.REPT	^O<MAXWRD-<<.-...PC2>/2>>
	.WORD	0
	.ENDR
	.ENDM	RAD50$
