	.TITLE	EDTMG
	.IDENT	/V03000/
                                                                                ;**-1
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; VERSION 11
; VERSION 12
;                                                                               ;**-1
; D. N. CUTLER/C. MONIA 10-MAY-74
;
; MODIFICATIONS:                                                                ;**NEW**
;                                                                               ;**NEW**
; NO.		DATE		PROGRAMMER                                      ;**NEW**
; ---		----		----------                                      ;**NEW**
;                                                                               ;**NEW**
; 030		02-JAN-75	C. MONIA                                        ;**NEW**
; 043		28-OCT-75	C. MONIA
; 055		13-APR-76	J.A.KASSON
; 060		15-DEC-78	E.H. MARISON
; EP001		26-DEC-78	J.E.POLLACK -- %I
;
; GENERALIZED FORMATTING ROUTINE
;
;
	.PSECT	LNC$D,D,GBL
$LNCNT::.BLKW	1		;LINE COUNT

	.PSECT

; EQUATED SYMBOLS
;

NP=1				; NO-PARAMETER FLAG

;
; LOCAL DATA
;

OPRAND:	.BYTE	'A		;%A-ASCII
	.BYTE	'B		;++030 %B-BINARY BYTE TO OCTAL
	.BYTE	'D		;%D-SIGNED BINARY TO DECIMAL CONVERSION
	.BYTE	'E		;++030 %E-EXTENDED ASCII CONVERSION
	.BYTE	'F		;%F-FORM FEED
	.BYTE	'I		;%I-INCLUDE ASCIZ STRING			; EP001
	.BYTE	'M		; %M-MAGNITUDE DECIMAL CONVERSION, SURPRESSED
	.BYTE	'N		;%N-NEW LINE (CR-LF)
	.BYTE	'O		;%O-SIGNED BINARY TO OCTAL CONVERSION
	.BYTE	'P		;%P-MAGNITUDE BINARY TO OCTAL CONVERSION
	.BYTE	'R		;%R-BINARY TO RAD50 CONVERSION
	.BYTE	'S		;++030 %S-SPACE GENERATOR
	.BYTE	'T		; %T-DOUBLE PRECISION DECIMAL
	.BYTE	'U		; %U-MAGNITUDE DECIMAL CONVERSION, NO SURPRESS
	.BYTE	'X		;%X-FILE NAME CONVERSION
	.BYTE	'Y		;%Y-DATE CONVERSION
	.BYTE	'Z		;%Z-TIME CONVERSION
	.BYTE	'<		; %<-DEFINE FIELD
	.BYTE	'>		; %>-SEARCH FOR FIELD DELIMITER
OPRNDX=.-OPRAND			;NUMBER OF DIRECTIVES

	.EVEN

;
; DIRECTIVE DISPATCH TABLE:
;
; THE LOW ORDER BIT IS SET FOR THOSE DIRECTIVES NOT REQUIRING
; AN ARGUMENT BLOCK ENTRY
;


VECTOR:	.WORD	ILLDIR!NP	; ILLEGAL DIRECTIVE
	.WORD	ASCII		;%A->ASCII STRING
	.WORD	BYTE		;++030 %B->BINARY BYTE TO OCTAL
	.WORD	BINDEC		;%D->SIGNED DECIMAL
	.WORD	EASCI		;++030 %E->EXTENDED ASCII
	.WORD	FORM!NP		; %F->FORM CONTROL
	.WORD	INCLUD		;%I-INCLUDE ASCIZ STRING			; EP001
	.WORD	DECSUP		; %M->ZERO SUPRESSED DECIMAL MAGNITUDE
	.WORD	NEWLIN!NP	; %N->NEWLINE
	.WORD	OCTAL		;%0->SIGNED OCTAL
	.WORD	POINT		;%P->ABSOLUTE OCTAL
	.WORD	RAD50		;%R->RAD50 STRING
	.WORD	SPACE!NP	;++030 %S->SPACE GENERATOR
	.WORD	DOUBLE		; %T->DOUBLE PRECISION DECIMAL
	.WORD	DECUNS		; %U->DECIMAL MAGNITUDE, NO SURPRESS
	.WORD	XFNAM		;%X->FILE NAME STRING
	.WORD	EDATE		;%Y->DATE CONVERSION
	.WORD	ETIME		;%Z->TIME CONVERSION
	.WORD	DFLD!NP		; %<->DEFINE FIXED LENGTH FIELD
	.WORD	LCTFLD!NP	; %>->LOCATE FIELD MARK

;+
; **-$EDMSG-EDIT MESSAGE
;
; THIS ROUTINE IS CALLED TO PROCESS AN ASCIZ FORMAT STRING TO PRODUCE
; AN EDITED OUTPUT STRING. THE INPUTS TO THE ROUTINE ARE A FORMAT STRING
; AND THE ADDRESS OF AN ARGUMENT BLOCK. THE FORMAT STRING IS SCANNED
; LOOKING FOR FORMAT DIRECTIVES. AS EACH NON-FORMAT CHARACTER IS EN-
; COUNTERED, IT IS SIMPLY COPIED INTO THE OUTPUT STRING. A"%" SIGN IS
; USED TO DELIMIT A FORMAT DIRECTIVE. IF A "%" SIGN IS FOLLOWED BY A "V"
; (VALUE), THEN THE REPEAT COUNT IS TAKEN FROM THE NEXT WORD IN THE ARG-
; UMENT BLOCK. ELSE THE NEXT "N" CHARACTERS (BY CONTEXT) ARE CONVERTED
; TO BINARY AND THIS VALUE IS TAKEN AS THE REPEAT COUNT. A REPEAT COUNT
; OF ZERO IS DEFAULTED TO A REPEAT COUNT OF ONE IN EITHER CASE. THE NEXT
; CHARACTER IN THE FORMAT STRING MUST BE A FORMAT DIRECTIVE. THE FOLLOW-
; ING FORMAT DIRECTIVES ARE IMPLEMENTED.
;
;	%A-ASCII STRING
;++030	%B-BINARY BYTE TO OCTAL
;	%D=SIGNED BINARY TO DECIMAL CONVERSION
;++030	%E-EXTENDED ASCII
;	%F-FORM CONTROL
;	%M-DECIMAL MAGNITUDE,  ZERO SURPRESS
;	%N-NEW LINE (CR-LF)
;	%O-SIGNED BINARY TO OCTAL CONVERSION
;	%P-MAGNITUDE BINARY TO OCTAL CONVERSION
;	%R-BINARY TO RAD50 CONVERSION
;++030	%S-SPACE GENERATOR
;	%T-DOUBLE PRECISION BINARY TO DECIMAL CONVERSION
;	%U-DECIMAL MAGNITUDE, NO ZERO SURPRESS
;	%X-FILE NAME CONVERSION
;	%Y-DATE CONVERSION
;	%Z-TIME CONVERSION
;	%<-DEFINE N BYTE, BLANK FILLED FIELD
;	%>-LOCATE FIELD MARK
;
; INPUTS:
;
;	R0=ADDRESS OF OUTPUT STRING.
;	R1=ADDRESS OF INPUT STRING
;	R2=ADDRESS OF ARGUMENT BLOCK.
;
; OUTPUTS:
;
;	R0=ADDRESS OF LAST BYTE IN OUTPUT STRING.
;	R1=LENGTH OF OUTPUT STRING IN BYTES.
;	R2=ADDRESS OF NEXT PARAMETER IN ARGUMENT BLOCK
;-

$EDMSG::SAVRG			;SAVE NONVOLITILE REGISTERS
	MOV	R0,-(SP)	;SAVE STARTING ADDRESS OF OUTPUT BUFFER
	CLR	-(SP)		; INSERT INCLUDE STRING STOPPER			; EP001
	MOV	R0,R3		;MOVE PARAMETERS TO NONVOLITILE REGISTER
	MOV	R1,R4		;
	MOV	R2,R5		;
10$:	MOVB	(R4)+,R2	;GET NEXT CHARACTER IN INPUT STRING
	BEQ	20$		;IF EQ ALL DONE
	CMPB	#'%,R2		;FORMATTING CHARACTER?
	BEQ	30$		;IF EQ YES
	MOVB	R2,(R3)+	;STORE CHARACTER IN OUTPUT STRING
	BR	10$		;GO AGAIN
20$:										; EP001
	MOV	(SP)+,R4	; GET PREVIOUS FORMAT STRING ADDRESS		; EP001
	BNE	10$		; BR IF THERE WAS A STRING('%I' ENCOUNTERED)	; EP001
	CLRB	(R3)		; CLEAR LAST BYTE FOR ASCIZ			; EP001
	MOV	R3,R0		;SET LAST BYTE ADDRESS				;**-1
	MOV	R0,R1		;COPY ADDRESS OF NEXT BYTE IN OUTPUT BUF
	SUB	(SP)+,R1	;CALCULATE LENGTH OF LINE IN BYTES
	MOV	R5,R2		; SET ADDRESS OF NEXT PARAMETER
	RETURN			;
30$:	MOV	R4,-(SP)	;SAVE R4 IN CASE OF ILLEGAL DIRECTIVE
	MOV	R4,R0		;SET ADDRESS OF NEXT BYTE
	CMPB	#'V,(R0)+	;NEXT CHARACTER "V"?
	BNE	35$		; IF NE NO
	MOV	(R5)+,R1	; GET ARGUMENT
	BR	40$		; PROCESS DIRECTIVE
35$:				;
	MOV	R4,R0		;SET ADDRESS OF NEXT BYTE
	CALL	$CDTB		;CONVERT LEADING NUMBER
	DEC	R0		;BACKUP TO TERMINAL BYTE
40$:	MOV	R0,R4		;RESTORE ADDRESS OF NEXT CHARACTER
	MOV	R3,R0		;SET ADDRESS OF NEXT IN OUTPUT STRING
	MOV	R1,R3		;SET REPEAT COUNT
	BNE	45$		;IF NE OKAY
	INC	R3		;MAKE COUNT 1
45$:	MOV	#OPRNDX,R2	;GET NUMBER OF DIRECTIVES
50$:	CMPB	(R4),OPRAND-1(R2);MATCH?
	BEQ	60$		;IF EQ YES
	SOB	R2,50$		;REPEAT
60$:	INC	R4		;INCREMENT PAST DIRECTIVE
	ASL	R2		;MAKE WORD INDEX
	MOV	VECTOR(R2),-(SP) ; GET ADDRESS OF DIRECTIVE ROUTINE
	ASR	(SP)		; ISOLATE NO-PARAMETERS FLAG
	BCS	70$		; IF C/S NO PARAMETERS REQUIRED
	MOV	(R5)+,R1	; ELSE FETCH FIRST PARAMETER
70$:				;
	ASL	(SP)		; CONVERT TO ADDRESS
	CALL	@(SP)+		; CALL PROCESSING ROUTINE
	MOV	R0,R3		;RESTORE ADDRESS OF NEXT IN OUTPUT STRIN
	TST	(SP)+		;CLEAN STACK
	BR	10$		;GO AGAIN

;
; ILLEGAL DIRECTIVE (%"UNKNOWN)
;

ILLDIR:	MOVB	#'%,(R0)+	;STORE PERCENT SIGN IN OUTPUT STRING
	MOV	2(SP),R4	;RESTORE INPUT STRING ADDRESS
	CMPB	#'V,(R4)	;"V" DIRECTIVE?
	BNE	10$		;IF NE NO
	TST	-(R5)		;BACKUP ARGUMENT POINTER
10$:	RETURN			;

;
; ASCII DIRECTIVE (%NA)
;
; MOVE "N" CHARACTERS FROM STRING POINTER TO BY R1 TO OUTPUT STRING.
;

ASCII:	MOVB	(R1)+,(R0)+	;MOVE A BYTE
	SOB	R3,ASCII	;REPEAT
	RETURN			;

;++030
;++030 BINARY BYTE TO OCTAL CONVERSION (%NB)
;++030
;++030 CONVERT N CONSECUTIVE BYTES POINTED TO BY R1
;++030

BYTE1:				;++030
	MOVB	#SPA,(R0)+	;++030 INSERT A SPACE
BYTE:				;++030
	MOVB	(R1)+,R2	;++030 GET NEXT BYTE
	MOV	R1,-(SP)	;++030 SAVE R1
	MOV	R2,R1		;++030 SET VALUE TO CONVERT
	MOV	SP,R2		;++030 DO NOT SUPPRESS ZEROS
	CALL	$CBTMG		;++030 CONVERT BYTE TO MAGNITUDE OCTAL
	MOV	(SP)+,R1	;++030 RESTORE R1
	SOB	R3,BYTE1	;++030 GO AGAIN
	RETURN			;++030

;
; SIGNED BINARY TO DECIMAL CONVERSION (%ND)
;
; CONVERT "N" CONSECUTIVE ARGUMENT WORDS. IF MORE THAN ONE WORD IS
; CONVERTED, THEN INSERT A TAB BETWEEN WORDS.
;

BINDEC:				;
	MOV	#<$CBDSG/2>&77777,-(SP) ; PUSH ADDRESS OF CONVERSION ROUTINE
	BR	CVNUM		; CONVERT SINGLE PRECISION NUMBER

;
; BINARY TO DECIMAL MAGNITUDE CONVERSION - ZERO SUPRESS (%NM)
;

DECSUP:				;
	MOV	#<$CBDMG/2>&77777,-(SP) ; PUSH ADDRESS OF CONVERSION ROUTINE
	BR	CVNUM		;

;
; BINARY TO DECIMAL MAGNITUDE CONVERSION - NO SURPRESS (%NU)
;

DECUNS:				;
	MOV	#<$CBDMG/2>!100000,-(SP) ; PUSH CONVERSION ROUTINE ADDRESS
	BR	CVNUM		;


;
; DOUBLE PRECISION BINARY TO DECIMAL CONVERSION (%NT)
;
; CONVERT N CONSECUTIVE DOUBLE-PRECISION VALUES POINTED TO BY R1
;

DOUBLE:				;
	MOV	#<$CDDMG/2>&77777,-(SP) ; PUSH CONVERSION ROUTINE ADDRESS
	BR	CVNUM		; CONVERT DOUBLE PRECISION NUMBER

;++030
;++030 EXTENDED ASCII CONVERSION (%NE)
;++030
;++030 CONVERT N BYTES POINTED TO BY R1 TO EXTENDED ASCII REPRESENTATION
;++030

EASCI:				;++030
	MOVB	(R1)+,(R0)	;++030 MOVE NEXT BYTE
	BICB	#200,(R0)	;++030 CLEAR PARITY BIT
	CMPB	(R0),#SPA	;++030 PRINTING CHARACTER?
	BLT	10$		;++030 IF LT NO
	CMPB	(R0),#177	;++030 RUBOUT?
	BNE	20$		;++030 IF NE NO
10$:				;++030
	MOVB	#SPA,(R0)	;++030 REPLACE NON-PRINTING CHAR. WITH SPACE
20$:				;++030
	INC	R0		;++030 STEP TO NEXT OUTPUT BYTE
	SOB	R3,EASCI	;++030 GO AGAIN
	RETURN			;++030

;
; DEFINE N BYTE FIXED LENGTH FIELD (%N<)
;
; N SPACES ARE INSERTED IN THE OUTPUT STREAM FOLLOWED BY A NULL.
; UPON COMPLETION, THE BYTE POINTER (R0) IS RESET TO ITS INITIAL VALUE.
;

DFLD:				;
	MOV	R0,R2		; MARK CURRENT POSITION
	CALL	SPACE		; INSERT N SPACES
	CLRB	(R0)		; MARK END OF FIELD
	MOV	R2,R0		; RESET BYTE POINTER
	RETURN			;


;
; FORM CONTROL DIRECTIVE (%NF)
;
; INSERT "N" FORM FEEDS INTO OUTPUT STRING.
;

FORM:	MOVB	#FF,(R0)+	;INSERT A FORM FEED
	SOB	R3,FORM		;REPEAT
	CLR	$LNCNT			;CLEAR LINE COUNT ON FORM FEED
	RETURN			;

;
; LOCATE FIELD MARK (%N>)
;
; THE OUTPUT STREAM POINTER (R0) IS ADVANCED UNTIL A FIELD DELIMI-
; TER IS LOCATED OR THE REPEAT COUNT IS EXCEEDED (WHICHEVER OCCURS
;  FIRST). THE FIELD MARK IS A NULL.
;

LCTFLD:				;
	TSTB	(R0)+		; FIND NULL?
	BEQ	10$		; IF EQ YES
	SOB	R3,LCTFLD	; REPEAT
10$:				;
	DEC	R0		; BACKUP BYTE POINTER
	RETURN			;

;
; NEW LINE DIRECTIVE (%NN)
;
; INSERT "N" CR-LF PAIRS INTO OUTPUT STRING.
;

NEWLIN:	MOVB	#CR,(R0)+	;INSERT A CR
	MOVB	#LF,(R0)+	;INSERT A LF
	INC	$LNCNT		;INCREMENT LINE COUNT FOR EVERY CR/LF
	SOB	R3,NEWLIN	;REPEAT
	RETURN			;

;
; SIGNED BINARY TO OCTAL CONVERSION DIRECTIVE (%NO)
;
; CONVERT "N" CONSECUTIVE ARGUMENT WORDS. IF MORE THAN ONE WORD IS
; CONVERTED, THEN INSERT A TAB BETWEEN WORDS.
;

OCTAL:				;
	MOV	#<$CBOSG/2>&77777,-(SP) ; PUSH ADDRESS OF CONVERSION ROUTINE
	BR	CVNUM		; CONVERT SINGLE PRECISION NUMBER

;
; MAGNITUDE BINARY TO OCTAL CONVERSION DIRECTIVE (%NP)
;
; CONVERT "N" CONSECUTIVE ARGUMENT WORDS. IF MORE THAN ONE WORD IS
; CONVERTED, THEN INSERT A TAB BETWEEN WORDS.
;

POINT:				;
	MOV	#<$CBOMG/2>!100000,-(SP) ; PUSH ADDRESS PLUS  NO ZERO SURPRESS
	BR	CVNUM		; CONVERT NUMBER

;
; **-CVNUM-CONVERT NUMBER TO ASCII
;
; "N" CONSECUTIVE ARGUMENT WORDS ARE CONVERTED TO ASCII. IF MORE
; THAN ONE WORD IS CONVERTED A TAB IS INSERTED BETWEEN FIELDS. WHEN
; A DOUBLE PRECISION VALUE IS PROCESSED THE ARGUMENT LIST CONTAINS
; THE ADDRESS OF THE QUANTITY TO BE CONVERTED
;
; INPUTS:
;
;	R0=STRING POINTER
;	R1=FIRST ARGUMENT
;	R3=REPEAT COUNT
;	R5=PARAMETER LIST POINTER
;
;	(SP)=ZERO SURPRESS FLAG(MSB)!CONVERSION ROUTINE ADDRESS/2
;
; OUTPUTS:
;
;	R0=UPDATED STRING POINTER
;	R5=UPDATED ARGUMENT LIST POINTER
;

CVNUM1:				;
	MOVB	#HT,(R0)+	; INSERT A TAB
	MOV	(R5)+,R1	; GET NEXT ARGUMENT WORD
CVNUM:				;
	MOV	(SP),-(SP)	; DUPLICATE SUBROUTINE ADDRESS
	CLR	R2		; ASSUME ZERO SURPRESS ENABLED
	ROL	(SP)		; CONVERT ADDRESS TO FULL WORD
	ROR	R2		; GET ZERO-SURPRESS FLAG
	CALL	@(SP)+		; CALL CONVERSION ROUTINE
	SOB	R3,CVNUM1	; REPEAT
	INC	(SP)+		; CLEAN STACK
	RETURN			;

;
; MAGNITUDE BINARY TO DECIMAL CONVERSION
;

DECMAG:				;
	MOV	#<$CBDMG/2>&77777,-(SP) ; PUSH CONVERSION ROUTINE ADDRESS
	BR	CVNUM		; CONVERT BINARY TO ASCII


;
; BINARY TO RAD50 CONVERSION DIRECTIVE
;
; CONVERT "N" CONSECUTIVE RAD50 WORDS.
;

RAD501:	MOV	(R5)+,R1	;GET NEXT ARGUMENT WORD
RAD50:	CALL	$C5TA		;CONVERT TO RAD50
	SOB	R3,RAD501	;REPEAT
	RETURN			;

;++030
;++030 SPACE GENERATOR (%NS)
;++030
;++030 GENERATE N SPACES IN BUFFER
;++030

SPACE:				;++030
	MOVB	#SPA,(R0)+	;++030 PUT IN A SPACE
	SOB	R3,SPACE	;++030 LOOP UNTIL DONE
	RETURN			;++030

;
; FILE NAME STRING CONVERSION
;
; CONVERT "N" FILE NAME STRINGS. IF MORE THAN ONE FILE NAME STRING IS
; CONVERTED, THEN INSERT A TAB BETWEEN STRINGS.
;

XFNAM1:	MOVB	#HT,(R0)+	;INSERT A TAB
	MOV	(R5)+,R1	;GET NEXT INPUT PARAMETER
XFNAM:	MOV	#3,-(SP)	;SET LOOP COUNT
10$:	CALL	$C5TA		;CONVERT TO RAD50
	MOV	(R5)+,R1	;GET NEXT INPUT PARAMETER
	DEC	(SP)		;DECREMENT LOOP COUNT
	BGT	10$		;IF GT GO AGAIN
	TST	(SP)+		;CLEAN STACK
	MOV	#9.,R2		;SET SUPRESS COUNT
	CALL	30$		;SUPRESS TRAILING BLANKS
	MOVB	#'.,(R0)+	;INSERT PERIOD SEPARATOR
	CALL	$C5TA		;CONVERT FILE TYPE TO RAD50
	MOV	#3,R2		;SET SUPRESS COUNT
	CALL	30$		;SUPRESS TRAILING BLANKS
	MOV	(R5)+,R1	;GET VERSION NUMBER
	BEQ	15$		;IF EQ SKIP VERSION
	MOVB	#';,(R0)+	;INSERT A SEMICOLON SEPARATOR
	CLR	R2		;ENABLE ZERO SUPRESSION
	CALL	$CBVER		; ++60 CONVERT VERSION
15$:	SOB	R3,XFNAM1	;REPEAT
20$:	RETURN			;
30$:	DEC	R2		;SUPRESS ANY MORE?
	BLT	20$		;IF LT NO
	CMPB	#' ,-1(R0)	;TRAILING BLANK?
	BNE	20$		;IF NE NO
	DEC	R0		;BACK UP A BYTE
	BR	30$		;

;
; DATE CONVERSION
;
; NOTE: REPEAT COUNT IS IGNORED.
;

EDATE:	MOV	R5,R1		;COPY ADDRESS OF NEXT PARAMETER
	TST	-(R1)		;BACK UP TO FIRST PARAMETER
	CALL	$DAT		;CONVERT DATE
	MOV	R1,R5		;SET ADDRESS OF NEXT ARGUMENT
	RETURN			;

;
; TIME CONVERSION
;
; REPEAT COUNT IS USED TO SPECIFY THE TIME FORMAT.
;

ETIME:	MOV	R5,R1		;COPY ADDRESS OF NEXT ARGUMENT
	TST	-(R1)		;BACK UP TO FIRST ARGUMENT
	MOV	R3,R2		;SET CONVERSION TYPE
	CALL	$TIM		;CONVERT TIME
	MOV	R1,R5		;SET ADDRESS OF NEXT ARGUMENT
	RETURN			;

										; EP001
;										; EP001
; INCLUDE FORMAT STRING SEGMENT							; EP001
;										; EP001
; PARAMETER IS THE ADDRESS OF ANOTHER ASCIZ STRING TO BE LOGCALLY		; EP001
; INCLUDED AT THIS POINT IN THE FORMATTING PROCESS				; EP001
;										; EP001
										; EP001
INCLUD:										; EP001
	TST	R1		; CHECK IF NEW STRING IS NON-NULL		; EP001
	BEQ	10$		; AND SKIP IF IT IS				; EP001
	MOV	(SP),-(SP)	; SHUFFLE STACK (RETURN ADDRESS TO DISPATCH)	; EP001
	MOV	4(SP),2(SP)	; SAVED FORMAT STRING PTR IN CASE OF ERROR	; EP001
	MOV	R4,4(SP)	; SAVE CURRENT FORMAT STRING POINTER		; EP001
	MOV	R1,R4		; AND SUBSTITUTE NEW FORMAT POINTER		; EP001
10$:	RETURN			; CONTINUE PROCESSING WITH NEW FORMAT STRING	; EP001
										; EP001
	.END
