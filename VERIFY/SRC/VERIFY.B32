MODULE VERIFY	(%TITLE	'Main module'
		MAIN = VERIFY,
		IDENT = 'V03-003'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:
!	Files-11 structure verification utility.
!
! ABSTRACT:
!	This is the main module.
!
! ENVIRONMENT:
!	VAX/VMS user mode.
!--
!
! AUTHOR: M. Jack, CREATION DATE: 11-Oct-1980
!
! MODIFIED BY:
!
!	V03-003	MLJ0087		Martin L. Jack,	7-Apr-1982  15:00
!		Fix access violation in traversing work list.  Support ODS-1
!		revision 2 disks.
!
!	V03-002	MLJ0084		Martin L. Jack,	25-Mar-1982  21:32
!		Use a random sequence number rather than the next sequential
!		sequence number when rewriting a bad header with a deleted
!		header.  This tracks a policy change in the ACP.
!
!	V03-001	MLJ0083		Martin L. Jack,	22-Mar-1982  9:35
!		Add check for zero-length ODS-2 directory and return "directory
!		file has invalid format" error.
!
!	V02-006	MLJ0075		Martin L. Jack,	29-Jan-1982  12:39
!		Use FIB$V_NORECORD.
!
!	V02-005	MLJ0074		Martin L. Jack,	23-Jan-1982  23:24
!		Rename [001003] to [SYSLOST] to remove VMS dependence on
!		numbered directories.
!
!	V02-004	MLJ0061		Martin L. Jack,	30-Nov-1981  10:31
!		Account for $GETDVI interface change.
!
!	V02-003	MLJ0055		Martin L. Jack,	15-Oct-1981  20:28
!		Issue message if lost files not entered.  Add /USAGE qualifier
!		to generate disk-accounting data file.  Issue message if
!		directory file not named '.DIR;1'.  Implement complete storage
!		control block validation and reconstruction.  Use $GETDVI.  Add
!		checks for quota file attributes.
!
!	V02-002	MLJ0035		Martin L. Jack,	27-Aug-1981  21:29
!		Allow extension file ID to point to CONTIN.SYS.
!
!	V02-001	MLJ0030		Martin L. Jack,	30-Jul-1981  23:23
!		Consider alternate index file header invalid only if it fails
!		basic validation or if the map areas or EFBLK differ.  Change
!		listing default name string so that /LIST=LP: has a reasonable
!		file name.  Write-access the quota file to flush the ACP cache.
!
!**


LIBRARY 'SYS$LIBRARY:LIB';

LITERAL
	TRUE=		1,
	FALSE=		0;


STRUCTURE
	BBLOCK[O,P,S,E;N]=
	    [N]
	    (BBLOCK + O)<P,S,E>;


MACRO
	FAO_(A)=
	    FAO(
		UPLIT BYTE (%ASCIC A)
		%IF NOT %NULL(%REMAINING) %THEN , %FI %REMAINING) %;


LITERAL
	LIST_SIZE=	132;		! Size of listing buffer


SWITCHES
	ADDRESSING_MODE(
	    EXTERNAL=LONG_RELATIVE,
	    NONEXTERNAL=WORD_RELATIVE);


PSECT
	CODE=		CODE,
	PLIT=		CODE,
	OWN=		DATA(ADDRESSING_MODE(LONG_RELATIVE)),
	GLOBAL=		DATA;


MACRO

	! Field definitions for QUAL area, general qualifiers.
	!
	QUAL_CONF=	0,0,1,0 %,	! /CONFIRM
	QUAL_LIST=	0,1,1,0 %,	! /LIST
	QUAL_READ=	0,2,1,0 %,	! /READ_CHECK
	QUAL_REPA=	0,3,1,0 %,	! /REPAIR
	QUAL_USAG=	0,4,1,0 %;	! /USAGE

FORWARD ROUTINE
	VERIFY,				! Main routine
	INIT_VOL_DATA:	NOVALUE,	! Initialize per-volume data
	READ_HOMEBLOCK:	NOVALUE,	! Read and check home block
	SCAN_INDEX:	NOVALUE,	! Scan index files
	VERIFY_HEADER,			! Check a file header
	MAP_PROCESS:	NOVALUE,	! Process map area
	CREATE_WINDOW,			! Create window for file
	DELETE_WINDOW:	NOVALUE,	! Delete window for file
	MAP_VIRTUAL,			! Map virtual to logical for file
	ACCESS_INDEX_2:	NOVALUE,	! Access index file on second channel
	COUNT_QUOTA:	NOVALUE,	! Maintain quota data base
	READ_HEADER,			! Read a file header
	WRITE_HEADER,			! Write a file header
	DELETE_HEADER:	NOVALUE,	! Write a deleted file header
	CLEAR_EXT_FID:	NOVALUE,	! Clear extension linkage
	READ_CHECK:	NOVALUE,	! Do read checking
	FILE_ERROR:	NOVALUE,	! Signal a file-related error
	HEADER_ERROR:	NOVALUE,	! Signal a header-related error
	PROCESS_FILE,			! Process one file
	PROCESS_SUBDIR:	NOVALUE,	! Process one subdirectory
	SCAN_DIRECT_1,			! Scan a directory (ODS-1)
	SCAN_DIRECT_2,			! Scan a directory (ODS-2)
	DIR_SCAN:	NOVALUE,	! Scan all directories
	FAO:		NOVALUE,	! Format information to listing
	EOL:		NOVALUE,	! Write listing buffer to file
	ENTER_WORK:	NOVALUE,	! Enter an item on work list
	PROCESS_WORK:	NOVALUE,	! Process work list
	DO_REPAIR,			! Evaluate repair control qualifiers
	EXIT_HANDLER:	NOVALUE,	! Exit handler
	CHECK_DATE:	NOVALUE;	! Check date field


EXTERNAL ROUTINE
	CHECKSUM,			! Compute file header checksum
	CHECKSUM2,			! Compute home block checksum
	LEFT_ONE,			! Find leftmost one bit in a longword
	MAKE_STRING,			! Convert ODS-1 filename to ASCII
	CLI$END_PARSE:	ADDRESSING_MODE(GENERAL),
					! Declare end of parsing
	CLI$GET_VALUE:	ADDRESSING_MODE(GENERAL),
					! Get a parameter or qualifier value
	CLI$PRESENT:	ADDRESSING_MODE(GENERAL),
					! Determine if entity is present
	LIB$FREE_VM:	ADDRESSING_MODE(GENERAL),
					! Free virtual memory
	LIB$GET_COMMAND:ADDRESSING_MODE(GENERAL),
					! Get line from SYS$COMMAND
	LIB$GET_VM:	ADDRESSING_MODE(GENERAL),
					! Get virtual memory
	LIB$SCOPY_R_DX:	ADDRESSING_MODE(GENERAL),
					! Copy a string
	LIB$SIGNAL:	ADDRESSING_MODE(GENERAL);
					! Signal a condition


EXTERNAL LITERAL
	VERIFY$_FACILITY,
	VERIFY$_ADDQUOTA,
	VERIFY$_ALLOCCLR,
	VERIFY$_ALLOCEXT,
	VERIFY$_ALLOCMEM,
	VERIFY$_ALLOCSET,
	VERIFY$_ALTIHDBAD,
	VERIFY$_ASSIGN,
	VERIFY$_BACKLINK,
	VERIFY$_BADBITMAP,
	VERIFY$_BADDIR,
	VERIFY$_BADDIRENT,
	VERIFY$_BADEFBLK,
	VERIFY$_BADHEADER,
	VERIFY$_BADHIBLK,
	VERIFY$_BBLHEADER,
	VERIFY$_CHKALTHOME,
	VERIFY$_CHKPRIHOME,
	VERIFY$_CHKSCB,
	VERIFY$_CREATELOST,
	VERIFY$_DELETE,
	VERIFY$_DELHEADER,
	VERIFY$_DIRNAME,
	VERIFY$_DSAQUOTA,
	VERIFY$_ENAQUOTA,
	VERIFY$_ENTERLOST,
	VERIFY$_FINDHOME,
	VERIFY$_FINDIHD,
	VERIFY$_FREEMEM,
	VERIFY$_FUTBAKDAT,
	VERIFY$_FUTCREDAT,
	VERIFY$_FUTREVDAT,
	VERIFY$_GETDVI,
	VERIFY$_INCQUOTA,
	VERIFY$_INVDEVICE,
	VERIFY$_INVEXTBACK,
	VERIFY$_INVEXTFID,
	VERIFY$_INVEXTHDR,
	VERIFY$_LOCKHEADER,
	VERIFY$_LOCKVOL,
	VERIFY$_LOSTEXTHDR,
	VERIFY$_LOSTHEADER,
	VERIFY$_LOSTSCAN,
	VERIFY$_MAPAREA,
	VERIFY$_MAXVOLS,
	VERIFY$_MODQUOTA,
	VERIFY$_MULTALLOC,
	VERIFY$_MULTEXTHDR,
	VERIFY$_NOREPAIR,
	VERIFY$_OPENBITMAP,
	VERIFY$_OPENDIR,
	VERIFY$_OPENFILE,
	VERIFY$_OPENINDEX,
	VERIFY$_OPENQUOTA,
	VERIFY$_PRIIHDBAD,
	VERIFY$_READBOOT,
	VERIFY$_READDIR,
	VERIFY$_READFILE,
	VERIFY$_READHEADER,
	VERIFY$_READHOME,
	VERIFY$_READIBMAP,
	VERIFY$_READQUOTA,
	VERIFY$_READSBMAP,
	VERIFY$_READSCB,
	VERIFY$_REMOVE,
	VERIFY$_UNLKVOL,
	VERIFY$_WRITEHEADER,
	VERIFY$_WRITEHOME,
	VERIFY$_WRITEIBMAP,
	VERIFY$_WRITESBMAP,
	VERIFY$_WRITESCB,
	VERIFY$_WRONGOWNER;


LITERAL
	MAX_VOLUMES=	255,		! Largest volume set
	DIR_BUF_COUNT=	16,		! Size of directory buffer
	INDEX_BUF_COUNT=64,		! Size of index file buffer
	FILE_BUF_COUNT=	64;		! Size of file data buffer


MACRO
	DVI_MAXBLOCK=	0,0,32,0 %,	! DVI$_MAXBLOCK
	DVI_SECTORS=	4,0,32,0 %,	! DVI$_SECTORS
	DVI_TRACKS=	8,0,32,0 %,	! DVI$_TRACKS
	DVI_CYLINDERS=	12,0,32,0 %;	! DVI$_CYLINDERS

LITERAL
	DVI_LENGTH=	16;		! Length of DEVICE_CHAR area


OWN
	QUAL:		BBLOCK[4],			! Qualifier bits
	QUAL_DEV_DESC:	BBLOCK[8],			! Value of device parameter
	QUAL_LIST_DESC:	BBLOCK[8],			! Value of /LIST qualifier
	QUAL_USAG_DESC:	BBLOCK[8],			! Value of /USAGE qualifier
	LIST_FAB:	BBLOCK[FAB$C_BLN],		! FAB for listing file
	LIST_RAB:	BBLOCK[RAB$C_BLN],		! RAB for listing file
	LIST_NAM:	BBLOCK[NAM$C_BLN],		! NAM block for listing file
	LIST_RSA:	VECTOR[NAM$C_MAXRSS,BYTE],	! Resultant string for listing file
	LIST_DESC:	VECTOR[2],			! Descriptor for listing buffer
	LIST_BUFFER:	VECTOR[LIST_SIZE,BYTE],		! Listing line buffer
	USAGE_FAB:	BBLOCK[FAB$C_BLN],		! FAB for usage file
	USAGE_RAB:	BBLOCK[RAB$C_BLN],		! RAB for usage file
	USAGE_NAM:	BBLOCK[NAM$C_BLN],		! NAM block for usage file
	USAGE_RSA:	VECTOR[NAM$C_MAXRSS,BYTE],	! Resultant string for usage file
	USAGE_BUFFER:	BBLOCK[MAXU(USG$C_IDENT_LEN,USG$C_FILE_LEN)],
							! Buffer for usage file
	CHANNEL,					! Channel to device
	CHANNEL_2,					! Second channel to device
	CHAN2_RVN,					! If nonzero, index file on this RVN is accessed on second channel
	TOTAL_SIZE,					! Total space mapped by headers for current file
	DUAL_ALLOC_FOUND,				! True if multiply allocated blocks exist
	DUAL_ALLOC_PASS,				! True if second pass to find multiply allocated blocks in progress
	DIRECTORY_ERROR,				! True if error occurred during directory scan
	EXIT_HAND_DESC:	VECTOR[5],			! Exit handler descriptor
	QT:		BBLOCK[8],			! Head of quota table list
	QUOTA_ACTIVE,					! True if quota file on volume set
	QUOTA_DISABLE,					! True if quota processing must be disabled
	DEFAULT_QUOTA,					! Default quota value
	DEFAULT_OVERDRAFT,				! Default overdraft value
	LAST_UIC,					! Last existing UIC in quota file
	DQF:		BBLOCK[DQF$C_LENGTH],		! Quota record buffer
	BUFFER:		BBLOCK[512*INDEX_BUF_COUNT],	! Index file buffer
	BUFFER_2:	BBLOCK[512],			! Second buffer
	FIB:		BBLOCK[FIB$C_LENGTH],		! General FIB used for all QIO's
	RECATTR:	BBLOCK[FAT$C_LENGTH],		! Record attributes area
	UCHAR:		BBLOCK[4],			! File characteristics area
	DIR:		VECTOR[80,BYTE],		! Current directory string
	DIR_DESC:	VECTOR[2],			! Descriptor for current directory string
	DIR_FID:	BBLOCK[FID$C_LENGTH],		! File ID of current directory
	LOST_DIR_FID:	BBLOCK[FID$C_LENGTH],		! File ID of lost file directory
	IOSB:		VECTOR[4,WORD],			! General I/O status block used for all QIO's
	VOLUME_COUNT,					! Number of volumes in volume set
	STRUCTURE_LEVEL,				! Structure level of volume set
	HOMEVBN,					! VBN of primary home block
	WORK_LIST:	VECTOR[2],			! Work list header
	CURRENT_TIME:	VECTOR[2],			! Current time in 64-bit format
	CURRENT_TIME_1:	BBLOCK[13],			! Current time in ODS-1 format
	DEVICE_DESC:	VECTOR[2],			! Descriptor for DEVICE_NAME
	DEVICE_NAME:	VECTOR[16,BYTE],		! Device name for specific RVN
	DEVICE_CHAR:	BBLOCK[DVI_LENGTH],		! Device characteristics buffer


	PER_VOLUME_BEG:	VECTOR[0],			! Beginning of per-volume information
	ACCTL:		REF VECTOR,			! FIB$M_WRITE if write-accessing files
	IMAP_SIZE:	REF VECTOR,			! Number of blocks in index file bitmap
	MAXFILIDX:	REF VECTOR,			! Highest valid file number minus one
	IMAP:		REF VECTOR,			! Bitmap of valid file numbers = new index file bitmap
	DIRMAP:		REF VECTOR,			! Bitmap of directory files
	SEQMAP:		REF VECTOR,			! Word vector of file sequence number
	BACKMAP:	REF VECTOR,			! Three-word vector of file back link FID
	LOSTMAP:	REF VECTOR,			! Bitmap of valid file numbers not yet found in directory
	EXTMAP:		REF VECTOR,			! Bitmap of file numbers referenced by extension linkages
	OWNER:		REF VECTOR,			! Longword vector of file owner UIC
	ALLOCATION:	REF VECTOR,			! Longword vector of file allocated blocks
	USAGE:		REF VECTOR,			! Longword vector of file used blocks

	SMAP_SIZE:	REF VECTOR,			! Number of blocks in storage bitmap
	VSMAP:		REF VECTOR,			! Bitmap of allocated clusters
	NSMAP:		REF VECTOR,			! VSMAP less lost extension headers = new storage bitmap
	MULTSMAP:	REF VECTOR,			! Bitmap of multiply allocated clusters

	CLUSTER_FACTOR:	REF VECTOR,			! Cluster factor
	HEADER_OFFSET:	REF VECTOR,			! VBN offset to file header
	BITMAP_OFFSET:	REF VECTOR,			! VBN offset to index file bitmap
	EOF:		REF VECTOR,			! VBN of index file EOF
	PER_VOLUME_END:	VECTOR[0];			! End of per-volume information


LITERAL

	! Values of the parameter to DO_REPAIR.
	!
	NO_CONFIRM=	%B'00',		! /CONFIRM prompting inhibited
	ALLOW_DELETE=	%B'11';		! DELETE is a /CONFIRM option


MACRO

	! Field definitions for work list.
	!
	WRK_LINK=	0,0,32,0 %,	! Link to next block
	WRK_TYPE=	4,0,8,0 %,	! Type of entry
	WRK_FID=	6,0,16,0 %,	! File ID of entry	(ENT, REM, DEL)
	WRK_DID=	12,0,16,0 %,	! Directory ID of entry	(REM)
	WRK_UIC=	8,0,32,0 %,	! UIC of entry		(ADD)
	WRK_USAGE=	12,0,32,0 %;	! Usage of entry	(ADD)


LITERAL
	WRK_S_ENTER=	12,		! Size of ENTER entry
	WRK_S_REMOVE=	18,		! Size of REMOVE entry
	WRK_S_ADDQUO=	16,		! Size of ADDQUO entry
	WRK_S_DELETE=	12,		! Size of DELETE entry
	WRK_K_ENTER=	0,		! Enter file in [SYSLOST]
	WRK_K_REMOVE=	1,		! Remove file from directory
	WRK_K_ADDQUO=	2,		! Add quota entry
	WRK_K_DELETE=	3;		! Delete file


MACRO

	! Field definitions for quota table.
	!
	QT_LINK=	0,0,32,0 %,	! Link to next block
	QT_COUNT=	4,0,32,0 %,	! Count of used entries in this block

	QT_UIC=		0,0,32,0 %,	! Entry UIC
	QT_QUO_USED=	4,0,32,0 %,	! Entry usage per quota file
	QT_IDX_USED=	8,0,32,0 %;	! Entry usage per index file


LITERAL
	QT_S_HDR=	8,		! Size of quota table block header
	QT_S_ENT=	12,		! Size of quota table entry
	QT_MAXCOUNT=	256;		! Maximum entries per block


MACRO

	! Field definitions for window block.
	!
	WDW_LINK=	0,0,32,0 %,	! Link to next block
	WDW_SIZE=	4,0,32,0 %,	! Number of entries
	WDW_ENTRY=	8,0,0,0 %,	! Beginning of first entry

	WDW_COUNT=	0,0,32,0 %,	! Count of blocks
	WDW_LBN=	4,0,32,0 %;	! LBN of blocks


LITERAL
	WDW_S_HEADER=	8,		! Size of window block header
	WDW_S_ENTRY=	8,		! Size of window block entry
	WDW_K_MAXENTRY=	16;		! Maximum number of entries in each block


OWN
	LOST_NAME:	VECTOR[13,BYTE] INITIAL (BYTE('SYSLOST.DIR;1')),
	QFI_NAME:	VECTOR[11,BYTE] INITIAL (BYTE('QUOTA.SYS;1'));


BIND
	HDR_BUFFER=	BUFFER + 512: BBLOCK,
	HDR_BUFFER_2=	BUFFER + 1024: BBLOCK,
	MFD_DESC=	$DESCRIPTOR('000000'),
	FAT_ATR_DESC=	UPLIT(
			    WORD(ATR$S_RECATTR, ATR$C_RECATTR), RECATTR,
			    WORD(ATR$S_UCHAR, ATR$C_UCHAR), UCHAR,
			    0),
	HDR_ATR_DESC=	UPLIT(
			    WORD(ATR$S_HEADER, ATR$C_HEADER), HDR_BUFFER,
			    0),
	FIB_DESC=	UPLIT(FIB$C_LENGTH, FIB),
	DQF_DESC=	UPLIT(DQF$C_LENGTH, DQF),
	LOST_DESC=	UPLIT(13, LOST_NAME),
	QFI_DESC=	UPLIT(11, QFI_NAME);


BUILTIN
	CALLG,
	EDIV,
	ROT,
	TESTBITSS,
	TESTBITSC,
	TESTBITCS,
	TESTBITCC;

ROUTINE VERIFY=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine is the main entry point to the VERIFY utility.
!
! INPUT PARAMETERS:
!	Standard VMS activation parameters (not used).
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	SS$_NORMAL.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	ACCTL_0,			! ACCTL[0] before ACCTL is allocated
	NO_WRITE,			! True if any volume is write locked
	STATUS;				! General status variable


! Get the parameter, the device to be verified.
!
QUAL_DEV_DESC[DSC$B_CLASS] = DSC$K_CLASS_D;
CLI$GET_VALUE($DESCRIPTOR('DEVICE'), QUAL_DEV_DESC);


! Execute a $PARSE to check the specification.  It must have a valid device,
! but must not have any other file specification components.  The listing FAB
! is used as a temporary for this operation.
!
$FAB_INIT(FAB=LIST_FAB,
    FNA=.QUAL_DEV_DESC[DSC$A_POINTER],
    FNS=.QUAL_DEV_DESC[DSC$W_LENGTH],
    NAM=LIST_NAM);
$NAM_INIT(NAM=LIST_NAM,
    ESA=LIST_RSA,
    ESS=NAM$C_MAXRSS);
$PARSE(FAB=LIST_FAB);
IF
    .LIST_NAM[NAM$B_ESL] EQL 0 OR
    (.LIST_NAM[NAM$L_FNB] AND 
	(NAM$M_EXP_DIR OR
	 NAM$M_EXP_NAME OR
	 NAM$M_EXP_TYPE OR
	 NAM$M_EXP_VER OR
	 NAM$M_NODE OR
	 NAM$M_QUOTED)) NEQ 0
THEN
    SIGNAL(VERIFY$_INVDEVICE, 1, QUAL_DEV_DESC);
    

! Store the device name back into the device descriptor.
!
LIB$SCOPY_R_DX(
    %REF(.LIST_NAM[NAM$B_DEV]),
    LIST_RSA,
    QUAL_DEV_DESC);


! Initialize the device name descriptor with the device name of RVN 1.
! Ensure that the device is valid.
!
DEVICE_DESC[0] = 0;
DEVICE_DESC[1] = DEVICE_NAME;
STATUS = $GETDVI(
    DEVNAM=QUAL_DEV_DESC,
    ITMLST=UPLIT(
	WORD(4, DVI$_DEVCHAR OR DVI$C_SECONDARY),
	LONG(DEVICE_CHAR, 0),
	WORD(16, DVI$_ROOTDEVNAM),
	LONG(DEVICE_NAME, DEVICE_DESC),
	LONG(0)));
IF NOT .STATUS
THEN
    SIGNAL(VERIFY$_GETDVI, 1, 1, .STATUS);


IF NOT .DEVICE_CHAR[DEV$V_RND]
THEN
    SIGNAL(VERIFY$_INVDEVICE, 1, QUAL_DEV_DESC);


! Get value of /LIST.
!
QUAL_LIST_DESC[DSC$B_CLASS] = DSC$K_CLASS_D;
IF CLI$PRESENT($DESCRIPTOR('LIST'))
THEN
    BEGIN
    QUAL[QUAL_LIST] = TRUE;
    CLI$GET_VALUE($DESCRIPTOR('LIST'), QUAL_LIST_DESC);
    END;


! Get value of /USAGE.
!
QUAL_USAG_DESC[DSC$B_CLASS] = DSC$K_CLASS_D;
IF CLI$PRESENT($DESCRIPTOR('USAGE'))
THEN
    BEGIN
    QUAL[QUAL_USAG] = TRUE;
    CLI$GET_VALUE($DESCRIPTOR('USAGE'), QUAL_USAG_DESC);
    END;


! Get value of Boolean qualifiers.
!
QUAL[QUAL_CONF] = CLI$PRESENT($DESCRIPTOR('CONFIRM'));
QUAL[QUAL_READ] = CLI$PRESENT($DESCRIPTOR('READ_CHECK'));
QUAL[QUAL_REPA] = CLI$PRESENT($DESCRIPTOR('REPAIR'));


! Confirm end of parsing.
!
CLI$END_PARSE();


! Open the listing file.
!
IF .QUAL[QUAL_LIST]
THEN
    BEGIN
    $FAB_INIT(FAB=LIST_FAB,
	DNA=UPLIT BYTE('VERIFY.LIS'),
	DNS=%CHARCOUNT('VERIFY.LIS'),
	FAC=PUT,
	FNA=.QUAL_LIST_DESC[DSC$A_POINTER],
	FNS=.QUAL_LIST_DESC[DSC$W_LENGTH],
	FOP=SQO,
	NAM=LIST_NAM,
	ORG=SEQ,
	RAT=CR,
	RFM=VAR);
    $RAB_INIT(RAB=LIST_RAB,
	FAB=LIST_FAB,
	RBF=LIST_BUFFER,
	ROP=WBH);
    $NAM_INIT(NAM=LIST_NAM,
	ESA=LIST_RSA,
	ESS=NAM$C_MAXRSS,
	RSA=LIST_RSA,
	RSS=NAM$C_MAXRSS);
    IF .LIST_FAB[FAB$B_FNS] EQL 0
    THEN
	BEGIN
	LIST_FAB[FAB$B_FNS] = %CHARCOUNT('SYS$OUTPUT:');
	LIST_FAB[FAB$L_FNA] = UPLIT BYTE('SYS$OUTPUT:');
	END;
    LIST_DESC[0] = LIST_SIZE;
    LIST_DESC[1] = LIST_BUFFER;
    IF NOT $CREATE(FAB=LIST_FAB)
    THEN
	FILE_ERROR(
	    VERIFY$_FACILITY^16 + SHR$_OPENOUT + STS$K_SEVERE,
	    LIST_FAB,
	    .LIST_FAB[FAB$L_STS], .LIST_FAB[FAB$L_STV]);
    IF NOT $CONNECT(RAB=LIST_RAB)
    THEN
	FILE_ERROR(
	    VERIFY$_FACILITY^16 + SHR$_OPENOUT + STS$K_SEVERE,
	    LIST_FAB,
	    .LIST_RAB[RAB$L_STS], .LIST_RAB[RAB$L_STV]);


    ! Put a header line on the listing.
    !
    FAO_('Listing of index file on !AS!/!%D', QUAL_DEV_DESC, 0);
    EOL();
    EOL();
    END;


! Open the usage file.
!
IF .QUAL[QUAL_USAG]
THEN
    BEGIN
    $FAB_INIT(FAB=USAGE_FAB,
	DNA=UPLIT BYTE('USAGE.DAT'),
	DNS=%CHARCOUNT('USAGE.DAT'),
	FAC=PUT,
	FNA=.QUAL_USAG_DESC[DSC$A_POINTER],
	FNS=.QUAL_USAG_DESC[DSC$W_LENGTH],
	FOP=SQO,
	NAM=USAGE_NAM,
	ORG=SEQ,
	RAT=CR,
	RFM=VAR);
    $RAB_INIT(RAB=USAGE_RAB,
	FAB=USAGE_FAB,
	RBF=USAGE_BUFFER,
	ROP=WBH);
    $NAM_INIT(NAM=USAGE_NAM,
	ESA=USAGE_RSA,
	ESS=NAM$C_MAXRSS,
	RSA=USAGE_RSA,
	RSS=NAM$C_MAXRSS);
    IF NOT $CREATE(FAB=USAGE_FAB)
    THEN
	FILE_ERROR(
	    VERIFY$_FACILITY^16 + SHR$_OPENOUT + STS$K_SEVERE,
	    USAGE_FAB,
	    .USAGE_FAB[FAB$L_STS], .USAGE_FAB[FAB$L_STV]);
    IF NOT $CONNECT(RAB=USAGE_RAB)
    THEN
	FILE_ERROR(
	    VERIFY$_FACILITY^16 + SHR$_OPENOUT + STS$K_SEVERE,
	    USAGE_FAB,
	    .USAGE_RAB[RAB$L_STS], .USAGE_RAB[RAB$L_STV]);
    END;


! Assign two channels to the device.
!
STATUS = $ASSIGN(DEVNAM=QUAL_DEV_DESC, CHAN=CHANNEL);
IF NOT .STATUS THEN SIGNAL(VERIFY$_ASSIGN, 1, QUAL_DEV_DESC, .STATUS);
STATUS = $ASSIGN(DEVNAM=QUAL_DEV_DESC, CHAN=CHANNEL_2);
IF NOT .STATUS THEN SIGNAL(VERIFY$_ASSIGN, 1, QUAL_DEV_DESC, .STATUS);


IF .QUAL[QUAL_REPA]
THEN
    BEGIN

    ! Declare the exit handler.
    !
    EXIT_HAND_DESC[1] = EXIT_HANDLER;		! Handler address
    EXIT_HAND_DESC[2] = 1;			! Argument count
    EXIT_HAND_DESC[3] = EXIT_HAND_DESC[4];	! Pointer to status longword
    $DCLEXH(DESBLK=EXIT_HAND_DESC);


    ! Lock the volume set.
    !
    CH$FILL(0, FIB$C_LENGTH, FIB);
    FIB[FIB$W_CNTRLFUNC] = FIB$C_LOCK_VOL;
    STATUS = $QIOW(
	FUNC=IO$_ACPCONTROL,
	CHAN=.CHANNEL,
	IOSB=IOSB,
	P1=FIB_DESC);
    IF .STATUS THEN STATUS = .IOSB[0];
    IF NOT .STATUS
    THEN
	BEGIN
	SIGNAL(VERIFY$_LOCKVOL, 0, .STATUS);
	QUAL[QUAL_REPA] = FALSE;
	END;
    END;


! Access the index file on RVN 1.  Read the file header into HDR_BUFFER.
!
CH$FILL(0, FIB$C_LENGTH, FIB);
NO_WRITE = FALSE;
FIB[FIB$L_ACCTL] = ACCTL_0 = FIB$M_WRITE OR FIB$M_NORECORD;
FIB[FIB$W_FID_NUM] = FID$C_INDEXF;
FIB[FIB$W_FID_SEQ] = FID$C_INDEXF;
FIB[FIB$W_FID_RVN] = 1;
STATUS = $QIOW(
    FUNC=IO$_ACCESS OR IO$M_ACCESS,
    CHAN=.CHANNEL,
    IOSB=IOSB,
    P1=FIB_DESC,
    P5=HDR_ATR_DESC);
IF .STATUS THEN STATUS = .IOSB[0];
IF .STATUS EQL SS$_WRITLCK
THEN
    BEGIN
    CH$FILL(0, FIB$C_LENGTH, FIB);
    NO_WRITE = TRUE;
    FIB[FIB$L_ACCTL] = ACCTL_0 = FIB$M_NORECORD;
    FIB[FIB$W_FID_NUM] = FID$C_INDEXF;
    FIB[FIB$W_FID_SEQ] = FID$C_INDEXF;
    FIB[FIB$W_FID_RVN] = 1;
    STATUS = $QIOW(
	FUNC=IO$_ACCESS OR IO$M_ACCESS,
	CHAN=.CHANNEL,
	IOSB=IOSB,
	P1=FIB_DESC,
	P5=HDR_ATR_DESC);
    IF .STATUS THEN STATUS = .IOSB[0];
    END;
IF NOT .STATUS THEN SIGNAL(VERIFY$_OPENINDEX, 1, 1, .STATUS);


! Read the home block on RVN 1.  Establish the size of the volume set and
! the structure level.
!
READ_HOMEBLOCK(1);


! Generate the usage file identification entry if required.
!
IF .QUAL[QUAL_USAG]
THEN
    BEGIN
    USAGE_BUFFER[USG$B_TYPE] = USG$K_IDENT;
    CH$MOVE(
	$BYTEOFFSET(USG$Q_TIME) - $BYTEOFFSET(USG$L_SERIALNUM),
	BUFFER[HM2$L_SERIALNUM],
	USAGE_BUFFER[USG$L_SERIALNUM]);
    $GETTIM(TIMADR=USAGE_BUFFER[USG$Q_TIME]);
    USAGE_RAB[RAB$W_RSZ] = USG$K_IDENT_LEN;
    IF NOT $PUT(RAB=USAGE_RAB)
    THEN
	FILE_ERROR(
	    VERIFY$_FACILITY + SHR$_WRITEERR + STS$K_SEVERE,
	    USAGE_FAB,
	    .USAGE_RAB[RAB$L_STS], .USAGE_RAB[RAB$L_STV]);
    END;


! Allocate the per-volume data.  Each variable between PER_VOLUME_BEG and
! PER_VOLUME_END is a pointer to a vector that varies with the number of
! volumes in the volume set.
!
INCRA A FROM PER_VOLUME_BEG TO PER_VOLUME_END-%UPVAL BY %UPVAL DO
    BEGIN
    STATUS = LIB$GET_VM(%REF(.VOLUME_COUNT*%UPVAL), .A);
    IF NOT .STATUS THEN SIGNAL(VERIFY$_ALLOCMEM, 0, .STATUS);
    CH$FILL(0, .VOLUME_COUNT*%UPVAL, ..A);
    END;


! Initialize the per-volume data for RVN 1.
!
INIT_VOL_DATA(1, .ACCTL_0);
ACCTL[0] = .ACCTL_0;


! If this is a volume set, access the index file of each volume in the set
! and get the per-volume data.  Do this beforehand to check accessibility
! of all volumes in the set.  Read the file header into HDR_BUFFER.
!
INCR RVN FROM 2 TO .VOLUME_COUNT DO
    BEGIN
    CH$FILL(0, FIB$C_LENGTH, FIB);
    FIB[FIB$L_ACCTL] = ACCTL[.RVN-1] = FIB$M_WRITE OR FIB$M_NORECORD;
    FIB[FIB$W_FID_NUM] = FID$C_INDEXF;
    FIB[FIB$W_FID_SEQ] = FID$C_INDEXF;
    FIB[FIB$W_FID_RVN] = .RVN;
    STATUS = $QIOW(
	FUNC=IO$_ACCESS OR IO$M_ACCESS,
	CHAN=.CHANNEL,
	IOSB=IOSB,
	P1=FIB_DESC,
	P5=HDR_ATR_DESC);
    IF .STATUS THEN STATUS = .IOSB[0];
    IF .STATUS EQL SS$_WRITLCK
    THEN
	BEGIN
	CH$FILL(0, FIB$C_LENGTH, FIB);
	NO_WRITE = TRUE;
	FIB[FIB$L_ACCTL] = ACCTL[.RVN-1] = FIB$M_NORECORD;
	FIB[FIB$W_FID_NUM] = FID$C_INDEXF;
	FIB[FIB$W_FID_SEQ] = FID$C_INDEXF;
	FIB[FIB$W_FID_RVN] = .RVN;
	STATUS = $QIOW(
	    FUNC=IO$_ACCESS OR IO$M_ACCESS,
	    CHAN=.CHANNEL,
	    IOSB=IOSB,
	    P1=FIB_DESC,
	    P5=HDR_ATR_DESC);
	IF .STATUS THEN STATUS = .IOSB[0];
	END;
    IF NOT .STATUS THEN SIGNAL(VERIFY$_OPENINDEX, 1, .RVN, .STATUS);
    READ_HOMEBLOCK(.RVN);
    INIT_VOL_DATA(.RVN, .ACCTL[.RVN-1]);
    END;


! If one or more volumes are write locked, cancel /REPAIR.
!
IF .NO_WRITE
THEN
    IF TESTBITSC(QUAL[QUAL_REPA])
    THEN
	SIGNAL(VERIFY$_NOREPAIR);


! Initialize for quota processing.
!
QT[QT_LINK] = 0;
QT[QT_COUNT] = QT_MAXCOUNT;


IF .STRUCTURE_LEVEL EQL 2
THEN
    BEGIN

    ! Access the quota file.  If this fails, skip quota
    ! computation.
    !
    CH$FILL(0, FIB$C_LENGTH, FIB);
    FIB[FIB$L_ACCTL] = .ACCTL[0];
    FIB[FIB$W_DID_NUM] = FID$C_MFD;
    FIB[FIB$W_DID_SEQ] = FID$C_MFD;
    FIB[FIB$W_DID_RVN] = 1;
    STATUS = $QIOW(
	FUNC=IO$_ACCESS OR IO$M_ACCESS,
	CHAN=.CHANNEL,
	IOSB=IOSB,
	P1=FIB_DESC,
	P2=QFI_DESC,
	P5=FAT_ATR_DESC);
    IF .STATUS THEN STATUS = .IOSB[0];

    IF .STATUS
    THEN
	IF
	    NOT .UCHAR[FCH$V_CONTIG] OR
	    .RECATTR[FAT$B_RTYPE] NEQ FAT$C_FIXED OR
	    .RECATTR[FAT$B_RATTRIB] NEQ 0 OR
	    .RECATTR[FAT$W_RSIZE] NEQ DQF$C_LENGTH
	THEN
	    BEGIN
	    $QIOW(
		FUNC=IO$_DEACCESS,
		CHAN=.CHANNEL);
	    STATUS = SS$_BADQFILE;
	    END;

    IF NOT .STATUS
    THEN
	SIGNAL(VERIFY$_OPENQUOTA, 0, .STATUS)
    ELSE
	BEGIN

	! Mark quota processing enabled.
	!
	QUOTA_ACTIVE = TRUE;


	! Loop to read the quota file.
	!
	INCR VBN FROM 1 TO ROT(.RECATTR[FAT$L_EFBLK], 16) - 1 BY INDEX_BUF_COUNT DO
	    BEGIN
	    LOCAL
		THIS_BLOCKS;	! Count of blocks to read on current iteration


	    ! Compute number of blocks to read this time.
	    !
	    THIS_BLOCKS = MINU(
		INDEX_BUF_COUNT,
		ROT(.RECATTR[FAT$L_EFBLK], 16) - .VBN);


	    ! Read the blocks.  If this fails, re-execute the read one block at
	    ! a time noting the blocks that fail.  The buffer for each failed
	    ! block is set to zero to effectively ignore that block.
	    !
	    STATUS = $QIOW(
		FUNC=IO$_READVBLK,
		CHAN=.CHANNEL,
		IOSB=IOSB,
		P1=BUFFER,
		P2=.THIS_BLOCKS * 512,
		P3=.VBN);
	    IF .STATUS THEN STATUS = .IOSB[0];
	    IF NOT .STATUS
	    THEN
		BEGIN
		INCR XVBN FROM 0 TO .THIS_BLOCKS-1 DO
		    BEGIN
		    STATUS = $QIOW(
			FUNC=IO$_READVBLK,
			CHAN=.CHANNEL,
			IOSB=IOSB,
			P1=BUFFER + .XVBN * 512,
			P2=512,
			P3=.VBN + .XVBN);
		    IF .STATUS THEN STATUS = .IOSB[0];
		    IF NOT .STATUS
		    THEN
			BEGIN
			SIGNAL(VERIFY$_READQUOTA, 1, .VBN + .XVBN, .STATUS);
			CH$FILL(0, 512, BUFFER + .XVBN * 512);
			END;
		    END;
		END;


	    ! Loop to process each quota entry.
	    !
	    INCRA ENTRY FROM BUFFER TO BUFFER + .THIS_BLOCKS*512 - DQF$C_LENGTH BY DQF$C_LENGTH DO
		BEGIN
		MAP
		    ENTRY:	REF BBLOCK;

		IF .ENTRY[DQF$V_ACTIVE]
		THEN
		    BEGIN
		    IF .ENTRY[DQF$L_UIC] EQL 0	! Default record
		    THEN
			BEGIN
			DEFAULT_QUOTA = .ENTRY[DQF$L_PERMQUOTA];
			DEFAULT_OVERDRAFT = .ENTRY[DQF$L_OVERDRAFT];
			END
		    ELSE
			BEGIN
			LAST_UIC = .ENTRY[DQF$L_UIC];
			COUNT_QUOTA(.ENTRY[DQF$L_UIC], .ENTRY[DQF$L_USAGE], 0);
			END;
		    END;
		END;
	    END;


	! Deaccess the quota file.
	!
	$QIOW(
	    FUNC=IO$_DEACCESS,
	    CHAN=.CHANNEL);
	END;
    END;


! Get the current time.  Also, convert it to ODS-1 format.
!
$GETTIM(TIMADR=CURRENT_TIME);
$ASCTIM(TIMBUF=UPLIT(23, BUFFER), TIMADR=CURRENT_TIME);
CURRENT_TIME_1[0,0,16,0] = .BUFFER[0,0,16,0];	! Output DD
CURRENT_TIME_1[2,0,24,0] = .BUFFER[3,0,24,0];	! Output MMM
CURRENT_TIME_1[5,0,16,0] = .BUFFER[9,0,16,0];	! Output YY
CURRENT_TIME_1[7,0,16,0] = .BUFFER[12,0,16,0];	! Output HH
CURRENT_TIME_1[9,0,16,0] = .BUFFER[15,0,16,0];	! Output MM
CURRENT_TIME_1[11,0,16,0] = .BUFFER[18,0,16,0];	! Output SS


! Scan the index files.
!
SCAN_INDEX();


! Check for allocation errors.
!
INCR RVN FROM 1 TO .VOLUME_COUNT DO
    BEGIN
    LOCAL
	SMAP:		REF BITVECTOR;		! Pointer to old storage bitmap


    ! Access bitmap file.
    !
    CH$FILL(0, FIB$C_LENGTH, FIB);
    FIB[FIB$L_ACCTL] = .ACCTL[.RVN-1];
    FIB[FIB$W_FID_NUM] = FID$C_BITMAP;
    FIB[FIB$W_FID_SEQ] = FID$C_BITMAP;
    FIB[FIB$W_FID_RVN] = .RVN;
    STATUS = $QIOW(
	FUNC=IO$_ACCESS OR IO$M_ACCESS,
	CHAN=.CHANNEL,
	IOSB=IOSB,
	P1=FIB_DESC);
    IF .STATUS THEN STATUS = .IOSB[0];
    IF NOT .STATUS
    THEN
	SIGNAL(VERIFY$_OPENBITMAP, 1, .RVN, .STATUS);


    ! Allocate space for copy of old storage bitmap.
    !
    STATUS = LIB$GET_VM(%REF(.SMAP_SIZE[.RVN-1] * 512), SMAP);
    IF NOT .STATUS THEN SIGNAL(VERIFY$_ALLOCMEM, 0, .STATUS);


    ! Read old storage bitmap.
    !
    INCR VBN FROM 0 TO .SMAP_SIZE[.RVN-1] - 1 BY 127 DO
	BEGIN
	LOCAL
	    THIS_BLOCKS;	! Count of blocks to read on current iteration


	! Compute number of blocks to read this time.
	!
	THIS_BLOCKS = MINU(
	    127,
	    .SMAP_SIZE[.RVN-1] - .VBN);


	! Read the blocks.  If this fails, re-execute the read one block
	! at a time noting the blocks that fail.
	!
	STATUS = $QIOW(
	    FUNC=IO$_READVBLK,
	    CHAN=.CHANNEL,
	    IOSB=IOSB,
	    P1=.SMAP + .VBN * 512,
	    P2=.THIS_BLOCKS * 512,
	    P3=2 + .VBN);
	IF .STATUS THEN STATUS = .IOSB[0];
	IF NOT .STATUS
	THEN
	    BEGIN
	    INCR XVBN FROM 0 TO .THIS_BLOCKS-1 DO
		BEGIN
		STATUS = $QIOW(
		    FUNC=IO$_READVBLK,
		    CHAN=.CHANNEL,
		    IOSB=IOSB,
		    P1=.SMAP + .VBN * 512 + .XVBN * 512,
		    P2=512,
		    P3=2 + .VBN + .XVBN);
		IF .STATUS THEN STATUS = .IOSB[0];
		IF NOT .STATUS
		THEN
		    SIGNAL(
			VERIFY$_READSBMAP,
			2,
			2 + .VBN + .XVBN,
			.RVN,
			.STATUS);
		END;
	    END;
	END;


    ! Match "valid" storage bitmap against old, reporting discrepancies.
    !
    INCR J FROM 0 TO .SMAP_SIZE[.RVN-1]*512*8-1 DO
	BEGIN
	IF .SMAP[.J] NEQ .BITVECTOR[.VSMAP[.RVN-1], .J]
	THEN
	    BEGIN
	    LOCAL
		KK;

	    INCR K FROM .J TO .SMAP_SIZE[.RVN-1]*512*8-1 DO
		BEGIN
		IF
		    .SMAP[.K] EQL .BITVECTOR[.VSMAP[.RVN-1], .K] OR
		    .BITVECTOR[.VSMAP[.RVN-1], .K] NEQ .BITVECTOR[.VSMAP[.RVN-1], .J]
		THEN
		    EXITLOOP;
		KK = .K;
		END;

	    SIGNAL(
		(IF .SMAP[.J]
		    THEN VERIFY$_ALLOCSET
		    ELSE VERIFY$_ALLOCCLR),
		3,
		.J * .CLUSTER_FACTOR[.RVN-1],
		(.KK + 1) * .CLUSTER_FACTOR[.RVN-1] - 1,
		.RVN);

	    J = .KK;
	    END;
	END;


    ! Match "valid" storage bitmap against new, reporting discrepancies.  These
    ! arise from lost extension headers.
    !
    INCR J FROM 0 TO .SMAP_SIZE[.RVN-1]*512*8-1 DO
	BEGIN
	IF .BITVECTOR[.NSMAP[.RVN-1], .J] NEQ .BITVECTOR[.VSMAP[.RVN-1], .J]
	THEN
	    BEGIN
	    LOCAL
		KK;

	    INCR K FROM .J TO .SMAP_SIZE[.RVN-1]*512*8-1 DO
		BEGIN
		IF
		    .BITVECTOR[.NSMAP[.RVN-1], .K] EQL .BITVECTOR[.VSMAP[.RVN-1], .K] OR
		    .BITVECTOR[.VSMAP[.RVN-1], .K] NEQ .BITVECTOR[.VSMAP[.RVN-1], .J]
		THEN
		    EXITLOOP;
		KK = .K;
		END;

	    SIGNAL(
		VERIFY$_ALLOCEXT,
		3,
		.J * .CLUSTER_FACTOR[.RVN-1],
		(.KK + 1) * .CLUSTER_FACTOR[.RVN-1] - 1,
		.RVN);

	    J = .KK;
	    END;
	END;


    ! Free space for copy of old storage bitmap.
    !
    STATUS = LIB$FREE_VM(%REF(.SMAP_SIZE[.RVN-1] * 512), SMAP);
    IF NOT .STATUS THEN SIGNAL(VERIFY$_FREEMEM, 0, .STATUS);


    ! Write new storage bitmap.
    !
    IF DO_REPAIR(NO_CONFIRM)
    THEN
	BEGIN
	INCR VBN FROM 0 TO .SMAP_SIZE[.RVN-1] - 1 BY 127 DO
	    BEGIN
	    LOCAL
		THIS_BLOCKS;	! Count of blocks to write on current iteration


	    ! Compute number of blocks to write this time.
	    !
	    THIS_BLOCKS = MINU(
		127,
		.SMAP_SIZE[.RVN-1] - .VBN);


	    ! Write the blocks.  If this fails, re-execute the write one block
	    ! at a time noting the blocks that fail.
	    !
	    STATUS = $QIOW(
		FUNC=IO$_WRITEVBLK,
		CHAN=.CHANNEL,
		IOSB=IOSB,
		P1=.NSMAP[.RVN-1] + .VBN * 512,
		P2=.THIS_BLOCKS * 512,
		P3=2 + .VBN);
	    IF .STATUS THEN STATUS = .IOSB[0];
	    IF NOT .STATUS
	    THEN
		BEGIN
		INCR XVBN FROM 0 TO .THIS_BLOCKS-1 DO
		    BEGIN
		    STATUS = $QIOW(
			FUNC=IO$_WRITEVBLK,
			CHAN=.CHANNEL,
			IOSB=IOSB,
			P1=.NSMAP[.RVN-1] + .VBN * 512 + .XVBN * 512,
			P2=512,
			P3=2 + .VBN + .XVBN);
		    IF .STATUS THEN STATUS = .IOSB[0];
		    IF NOT .STATUS
		    THEN
			SIGNAL(
			    VERIFY$_WRITESBMAP,
			    2,
			    2 + .VBN + .XVBN,
			    .RVN,
			    .STATUS);
		    END;
		END;
	    END;
	END;


    ! Deaccess bitmap file.
    !
    $QIOW(
	FUNC=IO$_DEACCESS,
	CHAN=.CHANNEL);
    END;


! If required, rescan the index files to locate multiple allocation.
!
IF .DUAL_ALLOC_FOUND
THEN
    BEGIN
    DUAL_ALLOC_PASS = TRUE;
    SCAN_INDEX();
    END;


! Scan the extension header bitmap looking for lost extension headers.
!
INCR RVN FROM 1 TO .VOLUME_COUNT DO
    BEGIN
    INCR NUM FROM 1 TO .MAXFILIDX[.RVN-1]+1 DO
	BEGIN
	IF
	    .BITVECTOR[.IMAP[.RVN-1], .NUM-1] AND
	    NOT .BITVECTOR[.LOSTMAP[.RVN-1], .NUM-1] AND
	    NOT .BITVECTOR[.EXTMAP[.RVN-1], .NUM-1]
	THEN
	    BEGIN
	    LOCAL
		FILE_ID:	BBLOCK[FID$C_LENGTH];	! Local copy of file ID

	    FILE_ID[FID$W_NUM] = .NUM;
	    FILE_ID[FID$B_NMX] = .NUM<16,8>;
	    FILE_ID[FID$W_SEQ] = .VECTOR[.SEQMAP[.RVN-1], .NUM-1 ;,WORD];
	    FILE_ID[FID$B_RVN] = .RVN;
	    HEADER_ERROR(VERIFY$_LOSTEXTHDR, FILE_ID, 0);
	    IF DO_REPAIR(NO_CONFIRM)
	    THEN
		IF READ_HEADER(FILE_ID, BUFFER_2)
		THEN
		    DELETE_HEADER(FILE_ID, BUFFER_2);
	    END;
	END;
    END;


! Rewrite the index file bitmaps.
!
IF DO_REPAIR(NO_CONFIRM)
THEN
    INCR RVN FROM 1 TO .VOLUME_COUNT DO
	BEGIN

	! Access the index file.
	!
	CH$FILL(0, FIB$C_LENGTH, FIB);
	FIB[FIB$L_ACCTL] = FIB$M_WRITE OR FIB$M_NORECORD;
	FIB[FIB$W_FID_NUM] = FID$C_INDEXF;
	FIB[FIB$W_FID_SEQ] = FID$C_INDEXF;
	FIB[FIB$W_FID_RVN] = .RVN;
	STATUS = $QIOW(
	    FUNC=IO$_ACCESS OR IO$M_ACCESS,
	    CHAN=.CHANNEL,
	    IOSB=IOSB,
	    P1=FIB_DESC);
	IF .STATUS THEN STATUS = .IOSB[0];
	IF NOT .STATUS THEN SIGNAL(VERIFY$_OPENINDEX, 1, .RVN, .STATUS);


	! Write new index file bitmap.
	!
	INCR VBN FROM 0 TO .IMAP_SIZE[.RVN-1] - 1 BY 127 DO
	    BEGIN
	    LOCAL
		THIS_BLOCKS;	! Count of blocks to read on current iteration


	    ! Compute number of blocks to write this time.
	    !
	    THIS_BLOCKS = MINU(
		127,
		.IMAP_SIZE[.RVN-1] - .VBN);


	    ! Write the blocks.  If this fails, re-execute the write one block
	    ! at a time noting the blocks that fail.
	    !
	    STATUS = $QIOW(
		FUNC=IO$_WRITEVBLK,
		CHAN=.CHANNEL,
		IOSB=IOSB,
		P1=.IMAP[.RVN-1] + .VBN * 512,
		P2=.THIS_BLOCKS * 512,
		P3=.BITMAP_OFFSET[.RVN-1] + .VBN);
	    IF .STATUS THEN STATUS = .IOSB[0];
	    IF NOT .STATUS
	    THEN
		BEGIN
		INCR XVBN FROM 0 TO .THIS_BLOCKS-1 DO
		    BEGIN
		    STATUS = $QIOW(
			FUNC=IO$_WRITEVBLK,
			CHAN=.CHANNEL,
			IOSB=IOSB,
			P1=.IMAP[.RVN-1] + .VBN * 512 + .XVBN * 512,
			P2=512,
			P3=.BITMAP_OFFSET[.RVN-1] + .VBN + .XVBN);
		    IF .STATUS THEN STATUS = .IOSB[0];
		    IF NOT .STATUS
		    THEN
			SIGNAL(
			    VERIFY$_WRITEIBMAP,
			    2,
			    .BITMAP_OFFSET[.RVN-1] + .VBN + .XVBN,
			    .RVN,
			    .STATUS);
		    END;
		END;
	    END;


	! Deaccess the index file.
	!
	$QIOW(
	    FUNC=IO$_DEACCESS,
	    CHAN=.CHANNEL);
	END;


! Scan all directories on all volumes.
!
INCR RVN FROM 1 TO .VOLUME_COUNT DO
    BEGIN
    DIR_SCAN(.RVN);
    END;


! Scan the lost file bitmap looking for lost files.
!
IF .DIRECTORY_ERROR THEN SIGNAL(VERIFY$_LOSTSCAN);


INCR RVN FROM 1 TO .VOLUME_COUNT DO
    BEGIN
    INCR NUM FROM 1 TO .MAXFILIDX[.RVN-1]+1 DO
	BEGIN
	IF .BITVECTOR[.LOSTMAP[.RVN-1], .NUM-1]
	THEN
	    BEGIN
	    LOCAL
		FILE_ID:	BBLOCK[FID$C_LENGTH];	! Local copy of file ID


	    ! Get the file ID.
	    !
	    FILE_ID[FID$W_NUM] = .NUM;
	    FILE_ID[FID$B_NMX] = .NUM<16,8>;
	    FILE_ID[FID$W_SEQ] = .VECTOR[.SEQMAP[.RVN-1], .NUM-1 ;,WORD];
	    FILE_ID[FID$B_RVN] = .RVN;


	    ! Generate usage file entry for the lost file if requested.
	    !
	    IF .QUAL[QUAL_USAG] THEN IF READ_HEADER(FILE_ID, BUFFER_2)
	    THEN
		BEGIN
		LOCAL
		    FILENAME:		VECTOR[FI2$S_FILENAME+1,BYTE],
		    IDENT_AREA:		REF BBLOCK;	! Pointer to ident area


		IDENT_AREA = BUFFER_2 + .BUFFER_2[FH2$B_IDOFFSET]*2;
		IF .STRUCTURE_LEVEL EQL 2
		THEN
		    BEGIN LOCAL P;
		    FILENAME[0] = FI2$S_FILENAME;
		    CH$MOVE(FI2$S_FILENAME, IDENT_AREA[FI2$T_FILENAME], FILENAME[1]);
		    P = CH$FIND_CH(FI2$S_FILENAME, FILENAME[1], %C' ');
		    IF .P NEQ 0 THEN FILENAME[0] = .P - FILENAME[1];
		    END
		ELSE
		    BEGIN
		    FILENAME[0] = MAKE_STRING(
			IDENT_AREA[FI1$W_FILENAME] - $BYTEOFFSET(NMB$W_NAME),
			FILENAME[1]);
		    END;


		USAGE_BUFFER[USG$B_TYPE] = USG$K_FILE;
		USAGE_BUFFER[USG$L_FILEOWNER] = .VECTOR[.OWNER[.RVN-1], .NUM-1];
		USAGE_BUFFER[USG$L_ALLOCATED] = .VECTOR[.ALLOCATION[.RVN-1], .NUM-1];
		USAGE_BUFFER[USG$L_USED] = .VECTOR[.USAGE[.RVN-1], .NUM-1];
		USAGE_BUFFER[USG$W_DIR_LEN] = 2;
		$FAO(
		    $DESCRIPTOR('[]!AC'),
		    USAGE_BUFFER[USG$W_SPEC_LEN],
		    UPLIT(NAM$C_MAXRSS, USAGE_BUFFER[USG$T_FILESPEC]),
		    FILENAME);
		USAGE_RAB[RAB$W_RSZ] = $BYTEOFFSET(USG$T_FILESPEC) + .USAGE_BUFFER[USG$W_SPEC_LEN];
		IF NOT $PUT(RAB=USAGE_RAB)
		THEN
		    FILE_ERROR(
			VERIFY$_FACILITY + SHR$_WRITEERR + STS$K_SEVERE,
			USAGE_FAB,
			.USAGE_RAB[RAB$L_STS], .USAGE_RAB[RAB$L_STV]);
		END;


	    ! Report the lost file if no errors occurred in the directory scan.
	    !
	    IF NOT .DIRECTORY_ERROR
	    THEN
		BEGIN
		HEADER_ERROR(VERIFY$_LOSTHEADER, FILE_ID, 0);
	        IF (STATUS = DO_REPAIR(ALLOW_DELETE))
		THEN
		    ENTER_WORK(
			(IF .STATUS<1,1>
			    THEN WRK_K_DELETE
			    ELSE WRK_K_ENTER),
			FILE_ID);
		END;
	    END;
	END;
    END;


! Scan the quota table looking for quota errors.
!
IF .QUOTA_ACTIVE
THEN
    BEGIN
    LOCAL
	M,			! True if modify quota, false if add quota
	T:	REF BBLOCK,	! Pointer to table segment
	E:	REF BBLOCK;	! Pointer to table entry


    IF DO_REPAIR(NO_CONFIRM)
    THEN
	BEGIN

	! Enable the quota file.  This is required to execute the
	! modify-quota function.
	!
	CH$FILL(0, FIB$C_LENGTH, FIB);
	FIB[FIB$W_DID_NUM] = FID$C_MFD;
	FIB[FIB$W_DID_SEQ] = FID$C_MFD;
	FIB[FIB$W_DID_RVN] = 1;
	FIB[FIB$W_CNTRLFUNC] = FIB$C_ENA_QUOTA;
	STATUS = $QIOW(
	    FUNC=IO$_ACPCONTROL,
	    CHAN=.CHANNEL,
	    IOSB=IOSB,
	    P1=FIB_DESC,
	    P2=QFI_DESC);
	IF .STATUS THEN STATUS = .IOSB[0];
	IF .STATUS NEQ SS$_QFACTIVE
	THEN
	    BEGIN
	    IF NOT .STATUS THEN SIGNAL(VERIFY$_ENAQUOTA, 0, .STATUS);
	    QUOTA_DISABLE = TRUE;
	    END;
	END;


    M = TRUE;
    IF .LAST_UIC EQL 0 THEN M = FALSE;
    T = .QT[QT_LINK];


    WHILE .T NEQ 0 DO
	BEGIN
	E = .T + QT_S_HDR;
	INCR J FROM 0 TO .T[QT_COUNT]-1 DO
	    BEGIN
	    IF .E[QT_QUO_USED] NEQ .E[QT_IDX_USED]
	    THEN
		BEGIN

		! Quota file and computed value disagree.
		!
		SIGNAL(
		    VERIFY$_INCQUOTA,
		    4,
		    .E[QT_QUO_USED],
		    .E[QT_IDX_USED],
		    .(E[QT_UIC])<16,16>,
		    .(E[QT_UIC])<0,16>);
		IF DO_REPAIR()
		THEN
		    IF .M
		    THEN
			BEGIN

			! Modify existing quota file entry.
			!
			CH$FILL(0, FIB$C_LENGTH, FIB);
			FIB[FIB$W_CNTRLFUNC] = FIB$C_MOD_QUOTA;
			FIB[FIB$L_CNTRLVAL] = FIB$M_MOD_USE;
			DQF[DQF$L_UIC] = .E[QT_UIC];
			DQF[DQF$L_USAGE] = .E[QT_IDX_USED];
			STATUS = $QIOW(
			    FUNC=IO$_ACPCONTROL,
			    CHAN=.CHANNEL,
			    IOSB=IOSB,
			    P1=FIB_DESC,
			    P2=DQF_DESC);
			IF .STATUS THEN STATUS = .IOSB[0];
			IF NOT .STATUS
			THEN
			    SIGNAL(
				VERIFY$_MODQUOTA,
				2,
				.(E[QT_UIC])<16,16>,
				.(E[QT_UIC])<0,16>,
				.STATUS);
			END
		    ELSE
			BEGIN

			! Add new quota file entry, after volume is unlocked.
			!
			ENTER_WORK(WRK_K_ADDQUO, .E[QT_UIC], .E[QT_IDX_USED]);
			END;
		END;


	    IF .E[QT_UIC] EQL .LAST_UIC THEN M = FALSE;
	    E = .E + QT_S_ENT;
	    END;
	T = .T[QT_LINK];
	END;
    END;


! Unlock the volume set.
!
IF .QUAL[QUAL_REPA]
THEN
    BEGIN
    CH$FILL(0, FIB$C_LENGTH, FIB);
    FIB[FIB$W_CNTRLFUNC] = FIB$C_UNLK_VOL;
    STATUS = $QIOW(
	FUNC=IO$_ACPCONTROL,
	CHAN=.CHANNEL,
	IOSB=IOSB,
	P1=FIB_DESC);
    IF .STATUS THEN STATUS = .IOSB[0];
    IF NOT .STATUS THEN SIGNAL(VERIFY$_UNLKVOL, 0, .STATUS);
    QUAL[QUAL_REPA] = FALSE;
    END;


! Do delayed repairs.
!
PROCESS_WORK();


! Disable the quota file, if it was disabled before we began processing.
!
IF .QUOTA_DISABLE
THEN
    BEGIN
    CH$FILL(0, FIB$C_LENGTH, FIB);
    FIB[FIB$W_CNTRLFUNC] = FIB$C_DSA_QUOTA;
    STATUS = $QIOW(
	FUNC=IO$_ACPCONTROL,
	CHAN=.CHANNEL,
	IOSB=IOSB,
	P1=FIB_DESC);
    IF .STATUS THEN STATUS = .IOSB[0];
    IF NOT .STATUS
    THEN
	SIGNAL(VERIFY$_DSAQUOTA, 0, .STATUS);
    QUOTA_DISABLE = FALSE;
    END;


! If necessary, deaccess a file that is accessed on the alternate channel.
! Then, deassign the channels to the device.
!
ACCESS_INDEX_2(0);
$DASSGN(CHAN=.CHANNEL);
$DASSGN(CHAN=.CHANNEL_2);


! Close the output listing file.
!
IF .QUAL[QUAL_LIST]
THEN
    IF NOT $CLOSE(FAB=LIST_FAB)
    THEN
	FILE_ERROR(
	    VERIFY$_FACILITY^16 + SHR$_CLOSEOUT + STS$K_SEVERE,
	    LIST_FAB,
	    .LIST_FAB[FAB$L_STS], .LIST_FAB[FAB$L_STV]);


! Close the output usage file.
!
IF .QUAL[QUAL_USAG]
THEN
    IF NOT $CLOSE(FAB=USAGE_FAB)
    THEN
	FILE_ERROR(
	    VERIFY$_FACILITY^16 + SHR$_CLOSEOUT + STS$K_SEVERE,
	    USAGE_FAB,
	    .USAGE_FAB[FAB$L_STS], .USAGE_FAB[FAB$L_STV]);


! Return to operating system.
!
SS$_NORMAL
END;

ROUTINE INIT_VOL_DATA(RVN,ACCTL_VALUE): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine initializes all the per-volume data during the initial
!	pass over the volumes and does validation of the basic file structure.
!	It finishes by deaccessing the channel.
!
! INPUT PARAMETERS:
!	RVN		- Relative volume number.
!	ACCTL_VALUE	- Value for FIB$L_ACCTL.
!
! IMPLICIT INPUTS:
!	BUFFER		- Contains the home block.
!	HDR_BUFFER	- Contains the index file header.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	Variables between PER_VOLUME_BEG and PER_VOLUME_END initialized.
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	Channel deaccessed.
!
!--

BEGIN
LOCAL
	INDEX_FILE_ID:	BBLOCK[FID$C_LENGTH],	! File ID of index file
	BITMAP_FILE_ID:	BBLOCK[FID$C_LENGTH],	! File ID of bitmap file
	CLUSTER,			! Cluster factor
	WINDOW:		REF BBLOCK,	! Pointer to window block
	STATUS;				! Status variable

MACRO
	CHECK_LBN(LBN,VBN)=
	    BEGIN
	    LOCAL
		TESTLBN;

	    IF NOT MAP_VIRTUAL(.WINDOW, (VBN), TESTLBN)
		THEN TRUE
		ELSE .TESTLBN NEQ (LBN)
	    END %,

	INITIALIZE(VALUE,LENGTH,DST)=
	    BEGIN
	    LOCAL
		P;

	    P = (DST);
	    DECR N FROM (LENGTH)-1 TO 0 DO
		BEGIN
		.P = (VALUE);
		P = .P + 4;
		END;
	    END %,

	MOVE(LENGTH,SRC,DST)=
	    BEGIN
	    LOCAL
		P, Q;

	    P = (SRC);  Q = (DST);
	    DECR N FROM (LENGTH)-1 TO 0 DO
		BEGIN
		.Q = ..P;
		P = .P + 4;  Q = .Q + 4;
		END;
	    END %;


! Initialize index file ID and bitmap file ID.
!
INDEX_FILE_ID[FID$W_NUM] = FID$C_INDEXF;
INDEX_FILE_ID[FID$W_SEQ] = FID$C_INDEXF;
INDEX_FILE_ID[FID$W_RVN] = .RVN;
BITMAP_FILE_ID[FID$W_NUM] = FID$C_BITMAP;
BITMAP_FILE_ID[FID$W_SEQ] = FID$C_BITMAP;
BITMAP_FILE_ID[FID$W_RVN] = .RVN;


! Get device characteristics for this volume.
!
CH$FILL(0, DVI_LENGTH, DEVICE_CHAR);
STATUS = $GETDVI(
    DEVNAM=DEVICE_DESC,
    ITMLST=UPLIT(
	WORD(4, DVI$_MAXBLOCK),
	LONG(DEVICE_CHAR[DVI_MAXBLOCK], 0),
	WORD(4, DVI$_SECTORS),
	LONG(DEVICE_CHAR[DVI_SECTORS], 0),
	WORD(4, DVI$_TRACKS),
	LONG(DEVICE_CHAR[DVI_TRACKS], 0),
	WORD(4, DVI$_CYLINDERS),
	LONG(DEVICE_CHAR[DVI_CYLINDERS], 0),
	WORD(16, DVI$_NEXTDEVNAM),
	LONG(DEVICE_NAME, DEVICE_DESC),
	LONG(0)));
IF NOT .STATUS
THEN
    SIGNAL(VERIFY$_GETDVI, 1, .RVN, .STATUS);


! Initialize information from the home block.
!
IF .STRUCTURE_LEVEL EQL 2
THEN
    BEGIN
    CLUSTER = .BUFFER[HM2$W_CLUSTER];
    IMAP_SIZE[.RVN-1] = .BUFFER[HM2$W_IBMAPSIZE];
    MAXFILIDX[.RVN-1] = .BUFFER[HM2$W_IBMAPSIZE] * 4096 - 1;
    CLUSTER_FACTOR[.RVN-1] = .CLUSTER;
    BITMAP_OFFSET[.RVN-1] = .CLUSTER*4 + 1;
    HEADER_OFFSET[.RVN-1] = .CLUSTER*4 + .BUFFER[HM2$W_IBMAPSIZE];
    END
ELSE
    BEGIN
    CLUSTER = 1;
    IMAP_SIZE[.RVN-1] = .BUFFER[HM1$W_IBMAPSIZE];
    MAXFILIDX[.RVN-1] = .BUFFER[HM1$W_IBMAPSIZE] * 4096 - 1;
    CLUSTER_FACTOR[.RVN-1] = 1;
    BITMAP_OFFSET[.RVN-1] = 3;
    HEADER_OFFSET[.RVN-1] = 2 + .BUFFER[HM1$W_IBMAPSIZE];
    END;
SMAP_SIZE[.RVN-1] =
    ((.DEVICE_CHAR[DVI_MAXBLOCK] + .CLUSTER_FACTOR[.RVN-1] - 1) /
    .CLUSTER_FACTOR[.RVN-1] + 4095) / 4096;


! Get a window block for the index file.
!
WINDOW = CREATE_WINDOW(HDR_BUFFER, .RVN);


%if false %then ! Following removed until we understand how to recover


! Validate the primary home block.  Tests that have already been passed in
! READ_HOMEBLOCK need not be repeated.
!
IF
    BEGIN
    IF .STRUCTURE_LEVEL EQL 2
    THEN
	BEGIN
	!
	! The following fields have already been verified:
	!	HM2$B_STRUCLEV, HM2$W_CLUSTER,
	!	HM2$W_CHECKSUM1, HM2$W_CHECKSUM2.
	!
	! The following fields are considered entirely free values:
	!	HM2$W_DEVTYPE, HM2$W_VOLCHAR, HM2$L_VOLOWNER, HM2$L_SEC_MASK,
	!	HM2$W_PROTECT, HM2$W_FILEPROT, HM2$W_RECPROT, HM2$B_WINDOW,
	!	HM2$B_LRU_LIM, HM2$W_EXTEND, HM2$L_SERIALNUM.
	!
	CHECK_LBN(.BUFFER[HM2$L_HOMELBN], .HOMEVBN) OR
	CHECK_LBN(.BUFFER[HM2$L_ALHOMELBN], .BUFFER[HM2$W_ALHOMEVBN]) OR
	CHECK_LBN(.BUFFER[HM2$L_ALTIDXLBN], .CLUSTER*3+1) OR
	.BUFFER[HM2$B_STRUCVER] EQL 0 OR
	.BUFFER[HM2$W_HOMEVBN] NEQ .HOMEVBN OR
	.BUFFER[HM2$W_ALHOMEVBN] LEQU .CLUSTER*2 OR
	.BUFFER[HM2$W_ALHOMEVBN] GTRU .CLUSTER*3 OR
	.BUFFER[HM2$W_ALTIDXVBN] NEQ .CLUSTER*3+1 OR
	.BUFFER[HM2$W_IBMAPVBN] NEQ .CLUSTER*4+1 OR
	CHECK_LBN(.BUFFER[HM2$L_IBMAPLBN], .CLUSTER*4+1) OR
	.BUFFER[HM2$L_MAXFILES] LEQU .BUFFER[HM2$W_RESFILES] OR
	.BUFFER[HM2$W_IBMAPSIZE] NEQ (.BUFFER[HM2$L_MAXFILES] + 4095) / 4096 OR
	.BUFFER[HM2$W_RESFILES] LSSU 5 OR
	(IF .VOLUME_COUNT GTR 1
	THEN
	    .BUFFER[HM2$W_RVN] NEQ .RVN
	    ! strucname
	ELSE
	    .BUFFER[HM2$W_RVN] NEQ 0 OR
	    CH$FIND_NOT_CH(HM2$S_STRUCNAME, BUFFER[HM2$T_STRUCNAME], %C' ')
		NEQ 0) OR
	(IF .BUFFER[HM2$W_RVN] EQL 1
	THEN
	    .BUFFER[HM2$W_SETCOUNT] LEQU 1
	ELSE
	    .BUFFER[HM2$W_SETCOUNT] NEQ 0) OR
	! credate
	! volname
	! ownername
	CH$NEQ(
	    HM2$S_FORMAT, BUFFER[HM2$T_FORMAT],
	    HM2$S_FORMAT, UPLIT BYTE ('DECFILE11B  '))
	END
    ELSE
	BEGIN
	!
	! The following fields have already been verified:
	!	HM1$W_MAXFILES, HM1$W_STRUCLEV,
	!	HM1$W_CHECKSUM1, HM1$W_CHECKSUM2.
	!
	! The following fields are considered entirely free values:
	!	HM1$W_DEVTYPE, HM1$W_VOLOWNER, HM1$W_PROTECT, HM1$W_VOLCHAR,
	!	HM1$W_FILEPROT, HM1$B_WINDOW, HM1$B_EXTEND, HM1$B_LRU_LIM,
	!	HM1$L_SERIALNUM.
	!
	.BUFFER[HM1$W_IBMAPSIZE] NEQ (.BUFFER[HM1$W_MAXFILES] + 4095) / 4096 OR
	CHECK_LBN(ROT(.BUFFER[HM1$L_IBMAPLBN], 16), 3) OR
	.BUFFER[HM1$W_CLUSTER] NEQ 1 OR
	! volname
	! credate
	! volname2
	! ownername
	CH$NEQ(
	    HM1$S_FORMAT, BUFFER[HM1$T_FORMAT],
	    HM1$S_FORMAT, UPLIT BYTE ('DECFILE11A  '))
	END
    END
THEN
    BEGIN
    SIGNAL(VERIFY$_CHKPRIHOME, 2, .HOMEVBN, .RVN);
    END;


%fi


! Read the boot block to find out if it is good.
!
STATUS = $QIOW(
    FUNC=IO$_READVBLK,
    CHAN=.CHANNEL,
    IOSB=IOSB,
    P1=HDR_BUFFER_2,
    P2=512,
    P3=1);
IF .STATUS THEN STATUS = .IOSB[0];
IF NOT .STATUS
THEN
    SIGNAL(VERIFY$_READBOOT, 1, .RVN, .STATUS);


! Check all of the home blocks.
!
INCR VBN FROM 2 TO (IF .STRUCTURE_LEVEL EQL 2 THEN 3*.CLUSTER ELSE 2) DO
    BEGIN
    IF .VBN NEQ .HOMEVBN
    THEN
	BEGIN

	! Read the block.
	!
	STATUS = $QIOW(
	    FUNC=IO$_READVBLK,
	    CHAN=.CHANNEL,
	    IOSB=IOSB,
	    P1=HDR_BUFFER_2,
	    P2=512,
	    P3=.VBN);
	IF .STATUS THEN STATUS = .IOSB[0];


	! Check the validity of the block.  If it reads with an error, always
	! consider it invalid so that it will be rewritten.  Otherwise, compare
	! for equality to the primary home block, verifying the expected
	! differences.
	!
	IF
	    BEGIN
	    IF NOT .STATUS
	    THEN
		TRUE
	    ELSE IF .STRUCTURE_LEVEL EQL 2
	    THEN
		BEGIN
		IF
		    BEGIN
		    NOT CHECKSUM2(HDR_BUFFER_2, $BYTEOFFSET(HM2$W_CHECKSUM1)) OR
		    NOT CHECKSUM2(HDR_BUFFER_2, $BYTEOFFSET(HM2$W_CHECKSUM2)) OR
		    CHECK_LBN(.HDR_BUFFER_2[HM2$L_HOMELBN], .VBN) OR
		    .HDR_BUFFER_2[HM2$W_HOMEVBN] NEQ .VBN
		    END
		THEN
		    TRUE
		ELSE
		    BEGIN
		    BUFFER[HM2$L_HOMELBN] = 0;
		    BUFFER[HM2$W_HOMEVBN] = 0;
		    BUFFER[HM2$W_CHECKSUM1] = 0;
		    BUFFER[HM2$W_CHECKSUM2] = 0;
		    HDR_BUFFER_2[HM2$L_HOMELBN] = 0;
		    HDR_BUFFER_2[HM2$W_HOMEVBN] = 0;
		    HDR_BUFFER_2[HM2$W_CHECKSUM1] = 0;
		    HDR_BUFFER_2[HM2$W_CHECKSUM2] = 0;
		    CH$NEQ(512, HDR_BUFFER_2, 512, BUFFER)
		    END
		END
	    ELSE
		CH$NEQ(512, HDR_BUFFER_2, 512, BUFFER)
	    END
	THEN
	    BEGIN

	    ! Report an appropriate error.
	    !
	    IF .STATUS
		THEN SIGNAL(VERIFY$_CHKALTHOME, 2, .VBN, .RVN)
		ELSE SIGNAL(VERIFY$_READHOME, 2, .VBN, .RVN, .STATUS);


	    ! Reconstruct and rewrite the block.
	    !
	    IF DO_REPAIR()
	    THEN
		BEGIN
		CH$MOVE(512, BUFFER, HDR_BUFFER_2);
		IF .STRUCTURE_LEVEL EQL 2
		THEN
		    BEGIN
		    HDR_BUFFER_2[HM2$W_HOMEVBN] = .VBN;
		    MAP_VIRTUAL(.WINDOW, .VBN, HDR_BUFFER_2[HM2$L_HOMELBN]);
		    CHECKSUM2(HDR_BUFFER_2, $BYTEOFFSET(HM2$W_CHECKSUM1));
		    CHECKSUM2(HDR_BUFFER_2, $BYTEOFFSET(HM2$W_CHECKSUM2));
		    END;
		STATUS = $QIOW(
		    FUNC=IO$_WRITEVBLK,
		    CHAN=.CHANNEL,
		    IOSB=IOSB,
		    P1=HDR_BUFFER_2,
		    P2=512,
		    P3=.VBN);
		IF .STATUS THEN STATUS = .IOSB[0];
		IF NOT .STATUS
		THEN
		    SIGNAL(VERIFY$_WRITEHOME, 2, .VBN, .RVN, .STATUS)
		END;
	    END;
	END;
    END;


! Allocate memory for and read index file bitmap.
!
STATUS = LIB$GET_VM(%REF(.IMAP_SIZE[.RVN-1] * 512), IMAP[.RVN-1]);
IF NOT .STATUS THEN SIGNAL(VERIFY$_ALLOCMEM, 0, .STATUS);
INCR VBN FROM 0 TO .IMAP_SIZE[.RVN-1] - 1 BY 127 DO
    BEGIN
    LOCAL
	THIS_BLOCKS;	! Count of blocks to read on current iteration


    ! Compute number of blocks to read this time.
    !
    THIS_BLOCKS = MINU(
	127,
	.IMAP_SIZE[.RVN-1] - .VBN);


    ! Read the blocks.  If this fails, re-execute the read one block
    ! at a time noting the blocks that fail.
    !
    STATUS = $QIOW(
	FUNC=IO$_READVBLK,
	CHAN=.CHANNEL,
	IOSB=IOSB,
	P1=.IMAP[.RVN-1] + .VBN * 512,
	P2=.THIS_BLOCKS * 512,
	P3=.BITMAP_OFFSET[.RVN-1] + .VBN);
    IF .STATUS THEN STATUS = .IOSB[0];
    IF NOT .STATUS
    THEN
	BEGIN
	INCR XVBN FROM 0 TO .THIS_BLOCKS-1 DO
	    BEGIN
	    STATUS = $QIOW(
		FUNC=IO$_READVBLK,
		CHAN=.CHANNEL,
		IOSB=IOSB,
		P1=.IMAP[.RVN-1] + .VBN * 512 + .XVBN * 512,
		P2=512,
		P3=.BITMAP_OFFSET[.RVN-1] + .VBN + .XVBN);
	    IF .STATUS THEN STATUS = .IOSB[0];
	    IF NOT .STATUS
	    THEN
		SIGNAL(
		    VERIFY$_READIBMAP,
		    2,
		    .BITMAP_OFFSET[.RVN-1] + .VBN + .XVBN,
		    .RVN,
		    .STATUS);
	    END;
	END;
    END;


! Get the EOF from the index file header.
!
EOF[.RVN-1] = 0;
IF .STRUCTURE_LEVEL EQL 2
THEN
    EOF[.RVN-1] = ROT(.BBLOCK[HDR_BUFFER[FH2$W_RECATTR], FAT$L_EFBLK], 16) - 1;


! Now scan the volume's index file bitmap backwards, looking for the highest
! bit set.  The maximum of the EOF mark and the highest set bit is taken to
! be the true index file EOF.
!
DECR J FROM .IMAP_SIZE[.RVN-1] * 128 - 1 TO 0 DO
    BEGIN
    IF .VECTOR[.IMAP[.RVN-1], .J] NEQ 0
    THEN
	BEGIN
	EOF[.RVN-1] = MAXU(
		.J*32 +
		LEFT_ONE(.VECTOR[.IMAP[.RVN-1], .J]) +
		.HEADER_OFFSET[.RVN-1],
	    .EOF[.RVN-1]);
	EXITLOOP;
	END;
    END;


! Allocate memory for and initialize directory bitmap.
!
STATUS = LIB$GET_VM(%REF(.IMAP_SIZE[.RVN-1] * 512), DIRMAP[.RVN-1]);
IF NOT .STATUS THEN SIGNAL(VERIFY$_ALLOCMEM, 0, .STATUS);
INITIALIZE(0, .IMAP_SIZE[.RVN-1] * 128, .DIRMAP[.RVN-1]);


! Allocate memory for and initialize lost file bitmap.
!
STATUS = LIB$GET_VM(%REF(.IMAP_SIZE[.RVN-1] * 512), LOSTMAP[.RVN-1]);
IF NOT .STATUS THEN SIGNAL(VERIFY$_ALLOCMEM, 0, .STATUS);
INITIALIZE(0, .IMAP_SIZE[.RVN-1] * 128, .LOSTMAP[.RVN-1]);


! Allocate memory for and initialize extension header bitmap.
!
STATUS = LIB$GET_VM(%REF(.IMAP_SIZE[.RVN-1] * 512), EXTMAP[.RVN-1]);
IF NOT .STATUS THEN SIGNAL(VERIFY$_ALLOCMEM, 0, .STATUS);
INITIALIZE(0, .IMAP_SIZE[.RVN-1] * 128, .EXTMAP[.RVN-1]);


! Allocate memory for file sequence number vector.  It need not be
! initialized -- an entry is valid only if the corresponding IMAP
! bit is set.
!
STATUS = LIB$GET_VM(%REF(.IMAP_SIZE[.RVN-1] * 512 * 16), SEQMAP[.RVN-1]);
IF NOT .STATUS THEN SIGNAL(VERIFY$_ALLOCMEM, 0, .STATUS);


IF .QUAL[QUAL_USAG]
THEN
    BEGIN

    ! Allocate memory for file owner UIC vector.  It need not be
    ! initialized -- an entry is valid only if the corresponding IMAP
    ! bit is set.
    !
    STATUS = LIB$GET_VM(%REF(.IMAP_SIZE[.RVN-1] * 512 * 32), OWNER[.RVN-1]);
    IF NOT .STATUS THEN SIGNAL(VERIFY$_ALLOCMEM, 0, .STATUS);


    ! Allocate memory for file allocated blocks vector.  It need not be
    ! initialized -- an entry is valid only if the corresponding IMAP
    ! bit is set.
    !
    STATUS = LIB$GET_VM(%REF(.IMAP_SIZE[.RVN-1] * 512 * 32), ALLOCATION[.RVN-1]);
    IF NOT .STATUS THEN SIGNAL(VERIFY$_ALLOCMEM, 0, .STATUS);


    ! Allocate memory for file used blocks vector.  It need not be
    ! initialized -- an entry is valid only if the corresponding IMAP
    ! bit is set.
    !
    STATUS = LIB$GET_VM(%REF(.IMAP_SIZE[.RVN-1] * 512 * 32), USAGE[.RVN-1]);
    IF NOT .STATUS THEN SIGNAL(VERIFY$_ALLOCMEM, 0, .STATUS);
    END;


IF .STRUCTURE_LEVEL EQL 2
THEN
    BEGIN

    ! Allocate memory for file back link FID vector.  It need not be
    ! initialized -- an entry is valid only if the corresponding IMAP
    ! bit is set.
    !
    STATUS = LIB$GET_VM(%REF(.IMAP_SIZE[.RVN-1] * 512 * 48), BACKMAP[.RVN-1]);
    IF NOT .STATUS THEN SIGNAL(VERIFY$_ALLOCMEM, 0, .STATUS);


    ! Read the primary index file header into HDR_BUFFER.  If the read fails,
    ! force the header invalid so that it will be rewritten.
    !
    STATUS = $QIOW(
	FUNC=IO$_READVBLK,
	CHAN=.CHANNEL,
	IOSB=IOSB,
	P1=HDR_BUFFER,
	P2=512,
	P3=.HEADER_OFFSET[.RVN-1] + FID$C_INDEXF);
    IF .STATUS THEN STATUS = .IOSB[0];
    IF NOT .STATUS
    THEN
	BEGIN
	HEADER_ERROR(VERIFY$_READHEADER, INDEX_FILE_ID, HDR_BUFFER, .STATUS);
	HDR_BUFFER[FH2$B_STRUCLEV] = 0;
	END;


    ! Read the alternate index file header into HDR_BUFFER_2.  If the read
    ! fails, force the header invalid so that it will be rewritten.
    !
    STATUS = $QIOW(
	FUNC=IO$_READVBLK,
	CHAN=.CHANNEL,
	IOSB=IOSB,
	P1=HDR_BUFFER_2,
	P2=512,
	P3=.CLUSTER*3 + 1);
    IF .STATUS THEN STATUS = .IOSB[0];
    IF NOT .STATUS
    THEN
	BEGIN
	HEADER_ERROR(VERIFY$_READHEADER, INDEX_FILE_ID, HDR_BUFFER_2, .STATUS);
	HDR_BUFFER_2[FH2$B_STRUCLEV] = 0;
	END;


    ! Check condition of primary and alternate index file headers.
    !
    IF VERIFY_HEADER(HDR_BUFFER, INDEX_FILE_ID)
    THEN
	BEGIN
	IF
	    BEGIN
	    IF NOT VERIFY_HEADER(HDR_BUFFER_2, INDEX_FILE_ID)
	    THEN
		TRUE
	    ELSE
		.HDR_BUFFER[FH2$B_MAP_INUSE] NEQ .HDR_BUFFER_2[FH2$B_MAP_INUSE] OR
	        CH$NEQ(
		    .HDR_BUFFER[FH2$B_ACOFFSET] - .HDR_BUFFER[FH2$B_MPOFFSET],
		    HDR_BUFFER + .HDR_BUFFER[FH2$B_MPOFFSET] * 2,
		    .HDR_BUFFER_2[FH2$B_ACOFFSET] - .HDR_BUFFER_2[FH2$B_MPOFFSET],
		    HDR_BUFFER_2 + .HDR_BUFFER_2[FH2$B_MPOFFSET] * 2) OR
		.BBLOCK[HDR_BUFFER[FH2$W_RECATTR], FAT$L_EFBLK] NEQ .BBLOCK[HDR_BUFFER_2[FH2$W_RECATTR], FAT$L_EFBLK]
	    END
	THEN
	    BEGIN
	    !
	    ! Primary header good.  Alternate header fails basic validity or
	    ! has a different EFBLK or map area.  Alternate header will be
	    ! restored from primary.
	    !
	    SIGNAL(VERIFY$_ALTIHDBAD, 1, .RVN);
	    IF DO_REPAIR()
	    THEN
		BEGIN
		STATUS = $QIOW(
		    FUNC=IO$_WRITEVBLK,
		    CHAN=.CHANNEL,
		    IOSB=IOSB,
		    P1=HDR_BUFFER,
		    P2=512,
		    P3=.CLUSTER*3 + 1);
		IF .STATUS THEN STATUS = .IOSB[0];
		IF NOT .STATUS
		THEN
		    HEADER_ERROR(
			VERIFY$_WRITEHEADER, INDEX_FILE_ID, HDR_BUFFER,
			.STATUS);
		END;
	    END
	END
    ELSE
	BEGIN
	IF VERIFY_HEADER(HDR_BUFFER_2, INDEX_FILE_ID)
	THEN
	    BEGIN
	    !
	    ! Primary header is bad, alternate header good.
	    ! Primary header will be restored from alternate.
	    !
	    SIGNAL(VERIFY$_PRIIHDBAD, 1, .RVN);
	    IF DO_REPAIR()
	    THEN
		BEGIN
		STATUS = $QIOW(
		    FUNC=IO$_WRITEVBLK,
		    CHAN=.CHANNEL,
		    IOSB=IOSB,
		    P1=HDR_BUFFER_2,
		    P2=512,
		    P3=.HEADER_OFFSET[.RVN-1] + FID$C_INDEXF);
		IF .STATUS THEN STATUS = .IOSB[0];
		IF NOT .STATUS
		THEN
		    HEADER_ERROR(
			VERIFY$_WRITEHEADER, INDEX_FILE_ID, HDR_BUFFER_2,
			.STATUS);
		END;
	    END
	ELSE
	    SIGNAL(VERIFY$_FINDIHD, 1, .RVN);
	END;
    END;


! Delete the index file window.
!
DELETE_WINDOW(.WINDOW);


! Deaccess the index file.
!
$QIOW(
    FUNC=IO$_DEACCESS,
    CHAN=.CHANNEL);


! Access the storage bitmap file.  Read the file header into HDR_BUFFER.
!
CH$FILL(0, FIB$C_LENGTH, FIB);
FIB[FIB$L_ACCTL] = .ACCTL_VALUE;
FIB[FIB$W_FID_NUM] = FID$C_BITMAP;
FIB[FIB$W_FID_SEQ] = FID$C_BITMAP;
FIB[FIB$W_FID_RVN] = .RVN;
STATUS = $QIOW(
    FUNC=IO$_ACCESS OR IO$M_ACCESS,
    CHAN=.CHANNEL,
    IOSB=IOSB,
    P1=FIB_DESC,
    P5=HDR_ATR_DESC);
IF .STATUS THEN STATUS = .IOSB[0];
IF NOT .STATUS
THEN
    SIGNAL(VERIFY$_OPENBITMAP, 1, .RVN, .STATUS);


! Get a window block for the bitmap file.
!
WINDOW = CREATE_WINDOW(HDR_BUFFER, .RVN);


! Read the storage control block.
!
STATUS = $QIOW(
    FUNC=IO$_READVBLK,
    CHAN=.CHANNEL,
    IOSB=IOSB,
    P1=BUFFER,
    P2=512,
    P3=1);
IF .STATUS THEN STATUS = .IOSB[0];
IF NOT .STATUS
THEN
    SIGNAL(VERIFY$_READSCB, 1, .RVN, .STATUS);


! Validate the storage control block.
!
IF
    BEGIN
    IF NOT .STATUS
    THEN
	TRUE
    ELSE IF .STRUCTURE_LEVEL EQL 2
    THEN
	BEGIN
	NOT CHECKSUM(BUFFER) OR
	.BUFFER[SCB$W_STRUCLEV] NEQ SCB$C_LEVEL2+1 OR
	.BUFFER[SCB$W_CLUSTER] NEQ .CLUSTER OR
	.BUFFER[SCB$L_VOLSIZE] NEQ .DEVICE_CHAR[DVI_MAXBLOCK] OR
	.BUFFER[SCB$L_BLKSIZE] NEQ 
	    (.DEVICE_CHAR[DVI_SECTORS] * .DEVICE_CHAR[DVI_TRACKS] *
	    .DEVICE_CHAR[DVI_CYLINDERS]) / .DEVICE_CHAR[DVI_MAXBLOCK] OR
	.BUFFER[SCB$L_SECTORS] NEQ .DEVICE_CHAR[DVI_SECTORS] OR
	.BUFFER[SCB$L_TRACKS] NEQ .DEVICE_CHAR[DVI_TRACKS] OR
	.BUFFER[SCB$L_CYLINDER] NEQ .DEVICE_CHAR[DVI_CYLINDERS]
	END
    ELSE
	BEGIN
	MAP
	    BUFFER:		VECTOR;
	LOCAL
	    BLOCK_COUNT;

	BLOCK_COUNT = .SMAP_SIZE[.RVN-1];
	IF .BLOCK_COUNT GTRU 126 THEN BLOCK_COUNT = 0;
	.(BUFFER+3)<0,8> NEQ .BLOCK_COUNT OR
	.BUFFER[.BLOCK_COUNT+1] NEQ ROT(.DEVICE_CHAR[DVI_MAXBLOCK], 16)
	END
    END
THEN
    BEGIN
    IF .STATUS THEN SIGNAL(VERIFY$_CHKSCB, 1, .RVN);
    IF DO_REPAIR()
    THEN
	BEGIN

	! Reconstruct the storage control block.
	!
	CH$FILL(0, 512, BUFFER);
	IF .STRUCTURE_LEVEL EQL 2
	THEN
	    BEGIN
	    BUFFER[SCB$W_STRUCLEV] = SCB$C_LEVEL2+1;
	    BUFFER[SCB$W_CLUSTER] = .CLUSTER;
	    BUFFER[SCB$L_VOLSIZE] = .DEVICE_CHAR[DVI_MAXBLOCK];
	    BUFFER[SCB$L_BLKSIZE] =
		(.DEVICE_CHAR[DVI_SECTORS] * .DEVICE_CHAR[DVI_TRACKS] *
		.DEVICE_CHAR[DVI_CYLINDERS]) / .DEVICE_CHAR[DVI_MAXBLOCK];
	    BUFFER[SCB$L_SECTORS] = .DEVICE_CHAR[DVI_SECTORS];
	    BUFFER[SCB$L_TRACKS] = .DEVICE_CHAR[DVI_TRACKS];
	    BUFFER[SCB$L_CYLINDER] = .DEVICE_CHAR[DVI_CYLINDERS];
	    BUFFER[SCB$L_STATUS] =
		SCB$M_MAPALLOC OR SCB$M_FILALLOC OR SCB$M_HDRWRITE;
	    CHECKSUM(BUFFER);
	    END
	ELSE
	    BEGIN
	    MAP
		BUFFER:		VECTOR;
	    LOCAL
		BLOCK_COUNT;

	    BLOCK_COUNT = .SMAP_SIZE[.RVN-1];
	    IF .BLOCK_COUNT GTRU 126 THEN BLOCK_COUNT = 0;
	    (BUFFER+3)<0,8> = .BLOCK_COUNT;
	    INCR J FROM 0 TO .BLOCK_COUNT-1 DO BUFFER[.J+1] = 4096;
	    BUFFER[.BLOCK_COUNT+1] = ROT(.DEVICE_CHAR[DVI_MAXBLOCK], 16);
	    END;


	! Rewrite the storage control block.
	!
	STATUS = $QIOW(
	    FUNC=IO$_WRITEVBLK,
	    CHAN=.CHANNEL,
	    IOSB=IOSB,
	    P1=BUFFER,
	    P2=512,
	    P3=1);
	IF .STATUS THEN STATUS = .IOSB[0];
	IF NOT .STATUS
	THEN
	    SIGNAL(VERIFY$_WRITESCB, 1, .RVN, .STATUS);
	END;
    END;


! Check bitmap file for contiguity and correct size.
!
IF
    BEGIN
    IF .WINDOW EQL 0
    THEN
	TRUE
    ELSE
	.WINDOW[WDW_SIZE] NEQ 1 OR
	.BBLOCK[WINDOW[WDW_ENTRY], WDW_COUNT] LSSU .SMAP_SIZE[.RVN-1] + 1
    END
THEN
    SIGNAL(VERIFY$_BADBITMAP, 1, .RVN);


! Allocate memory for recomputed storage bitmap and initialize it.
! (Set bits mean free clusters.)  Mark clusters above the true size of
! the volume allocated.
!
STATUS = LIB$GET_VM(%REF(.SMAP_SIZE[.RVN-1] * 512), NSMAP[.RVN-1]);
IF NOT .STATUS THEN SIGNAL(VERIFY$_ALLOCMEM, 0, .STATUS);
INITIALIZE(-1, .SMAP_SIZE[.RVN-1] * 128, .NSMAP[.RVN-1]);
INCR N
    FROM ((.DEVICE_CHAR[DVI_MAXBLOCK] + .CLUSTER_FACTOR[.RVN-1] - 1) /
	 .CLUSTER_FACTOR[.RVN-1]) 
    TO .SMAP_SIZE[.RVN-1] * 512 * 8 - 1
DO
    BITVECTOR[.NSMAP[.RVN-1], .N] = FALSE;


! Allocate memory for and initialize allocated cluster bitmap.
!
STATUS = LIB$GET_VM(%REF(.SMAP_SIZE[.RVN-1] * 512), VSMAP[.RVN-1]);
IF NOT .STATUS THEN SIGNAL(VERIFY$_ALLOCMEM, 0, .STATUS);
MOVE(.SMAP_SIZE[.RVN-1] * 128, .NSMAP[.RVN-1], .VSMAP[.RVN-1]);


! Allocate memory for and initialize multiply allocated cluster bitmap.
!
STATUS = LIB$GET_VM(%REF(.SMAP_SIZE[.RVN-1] * 512), MULTSMAP[.RVN-1]);
IF NOT .STATUS THEN SIGNAL(VERIFY$_ALLOCMEM, 0, .STATUS);
INITIALIZE(0, .SMAP_SIZE[.RVN-1] * 128, .MULTSMAP[.RVN-1]);


! Delete the bitmap file window.
!
DELETE_WINDOW(.WINDOW);


! Deaccess the storage bitmap file.
!
$QIOW(
    FUNC=IO$_DEACCESS,
    CHAN=.CHANNEL);
END;

ROUTINE READ_HOMEBLOCK(RVN): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine reads the first good home block of the currently open
!	index file into the general buffer.  The code in this routine should
!	track the code in MOUNT.
!
! INPUT PARAMETERS:
!	RVN		- Relative volume number.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	BUFFER		- Contains a valid home block.
!	VOLUME_COUNT	- Count of volumes in volume set.
!	STRUCTURE_LEVEL	- Structure level (1 or 2) of the volume set.
!	HOMEVBN		- VBN of the valid home block.
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	STATUS,				! General status value
	OLD_STATUS;			! Save status for error message


! We keep reading until we get a block that reads without errors and looks
! like a home block.  Track any error status for the eventual error message.
!
OLD_STATUS = SS$_ABORT;
INCR VBN FROM 2 TO 100 DO
    BEGIN
    STATUS = $QIOW(
	FUNC=IO$_READVBLK,
	CHAN=.CHANNEL,
	IOSB=IOSB,
	P1=BUFFER,
	P2=512,
	P3=.VBN);
    IF .STATUS THEN STATUS = .IOSB[0];

    IF NOT .STATUS
    THEN
	OLD_STATUS = .STATUS
    ELSE
	IF 
	    .BUFFER[HM2$B_STRUCLEV] EQL 2 AND
	    .BUFFER[HM2$L_ALTIDXLBN] NEQ 0 AND
	    .BUFFER[HM2$W_CLUSTER] NEQ 0 AND
	    .BUFFER[HM2$W_HOMEVBN] NEQ 0 AND
	    .BUFFER[HM2$W_ALHOMEVBN] NEQ 0 AND
	    .BUFFER[HM2$W_ALTIDXVBN] NEQ 0 AND
	    .BUFFER[HM2$W_IBMAPVBN] NEQ 0 AND
	    .BUFFER[HM2$L_IBMAPLBN] NEQ 0 AND
	    .BUFFER[HM2$L_MAXFILES] NEQ 0 AND
	    .BUFFER[HM2$W_IBMAPSIZE] NEQ 0 AND
	    .BUFFER[HM2$W_RESFILES] NEQ 0 AND
	    CHECKSUM2(BUFFER, $BYTEOFFSET(HM2$W_CHECKSUM1)) AND
	    CHECKSUM2(BUFFER, $BYTEOFFSET(HM2$W_CHECKSUM2))
	THEN
	    BEGIN

	    ! Block is a valid ODS-2 home block.
	    !
	    IF .RVN EQL 1
	    THEN
		BEGIN
		STRUCTURE_LEVEL = 2;
		VOLUME_COUNT = .BUFFER[HM2$W_SETCOUNT];
		IF .VOLUME_COUNT EQL 0 THEN VOLUME_COUNT = 1;
		IF .VOLUME_COUNT GTRU MAX_VOLUMES THEN SIGNAL(VERIFY$_MAXVOLS);
		END;
	    HOMEVBN = .VBN;
	    RETURN;
	    END
	ELSE IF 
	    .RVN EQL 1 AND
	    (.BUFFER[HM1$W_STRUCLEV] EQL HM1$C_LEVEL1 OR .BUFFER[HM1$W_STRUCLEV] EQL HM1$C_LEVEL2) AND
	    .BUFFER[HM1$W_CLUSTER] NEQ 0 AND
	    .BUFFER[HM1$L_IBMAPLBN] NEQ 0 AND
	    .BUFFER[HM1$W_MAXFILES] NEQ 0 AND
	    .BUFFER[HM1$W_IBMAPSIZE] NEQ 0 AND
	    CHECKSUM2(BUFFER, $BYTEOFFSET(HM1$W_CHECKSUM1)) AND
	    CHECKSUM2(BUFFER, $BYTEOFFSET(HM1$W_CHECKSUM2))
	THEN
	    BEGIN

	    ! Block is a valid ODS-1 home block.
	    !
	    STRUCTURE_LEVEL = 1;
	    VOLUME_COUNT = 1;
	    HOMEVBN = .VBN;
	    RETURN;
	    END;
    END;


! No good home block found.  Report failure.
!
SIGNAL(VERIFY$_FINDHOME, 1, .RVN, .OLD_STATUS);
END;

ROUTINE SCAN_INDEX: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine scans the index files on all volumes of a volume set.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
INCR RVN FROM 1 TO .VOLUME_COUNT DO
    BEGIN
    LOCAL
	STATUS,				! Status variable
	VBN;				! Current index file VBN


    ! Access the index file.
    !
    CH$FILL(0, FIB$C_LENGTH, FIB);
    FIB[FIB$L_ACCTL] = .ACCTL[.RVN-1];
    FIB[FIB$W_FID_NUM] = FID$C_INDEXF;
    FIB[FIB$W_FID_SEQ] = FID$C_INDEXF;
    FIB[FIB$W_FID_RVN] = .RVN;
    STATUS = $QIOW(
	FUNC=IO$_ACCESS OR IO$M_ACCESS,
	CHAN=.CHANNEL,
	IOSB=IOSB,
	P1=FIB_DESC);
    IF .STATUS THEN STATUS = .IOSB[0];
    IF NOT .STATUS THEN SIGNAL(VERIFY$_OPENINDEX, 1, .RVN, .STATUS);


    ! Loop for all headers in the index file.  Read multiple blocks into a
    ! buffer and process them one at a time.
    !
    VBN = .HEADER_OFFSET[.RVN-1] + 1;
    UNTIL .VBN GTRU .EOF[.RVN-1] DO
	BEGIN
	LOCAL
	    HEADER:	REF BBLOCK,	! Pointer to current header
	    READ_COUNT;			! Count of blocks to read


	! Establish the count of blocks to read and execute the read.
	!
	READ_COUNT = MINU(INDEX_BUF_COUNT, .EOF[.RVN-1] + 1 - .VBN);
	STATUS = $QIOW(
	    FUNC=IO$_READVBLK,
	    CHAN=.CHANNEL,
	    IOSB=IOSB,
	    P1=BUFFER,
	    P2=512 * .READ_COUNT,
	    P3=.VBN);
	IF .STATUS THEN STATUS = .IOSB[0];


	! If an error occurred, read each block separately, reporting any
	! errors.  Each header that reads with an error is deleted, since
	! it cannot be trusted.
	!
	IF NOT .STATUS
	THEN
	    BEGIN
	    INCR XVBN FROM 0 TO .READ_COUNT-1 DO
		BEGIN
		LOCAL
		    HEADER:	REF BBLOCK,		! Pointer to header
		    FILE_NUMBER,			! Current file number
		    FILE_ID:	BBLOCK[FID$C_LENGTH];	! Current file ID


		! Execute the read.
		!
		HEADER = BUFFER + .XVBN * 512;
		STATUS = $QIOW(
		    FUNC=IO$_READVBLK,
		    CHAN=.CHANNEL,
		    IOSB=IOSB,
		    P1=.HEADER,
		    P2=512,
		    P3=.VBN + .XVBN);
		IF .STATUS THEN STATUS = .IOSB[0];
		IF NOT .STATUS
		THEN
		    BEGIN

		    ! Get a clean file ID.
		    !
		    FILE_NUMBER = .VBN + .XVBN - .HEADER_OFFSET[.RVN-1];
		    FILE_ID[FID$W_NUM] = .FILE_NUMBER;
		    FILE_ID[FID$B_NMX] = .FILE_NUMBER<16,8>;
		    IF .STRUCTURE_LEVEL EQL 2
			THEN FILE_ID[FID$W_SEQ] = .HEADER[FH2$W_FID_SEQ]
			ELSE FILE_ID[FID$W_SEQ] = .HEADER[FH1$W_FID_SEQ];
		    FILE_ID[FID$B_RVN] = .RVN;


		    ! Issue the error.
		    !
		    HEADER_ERROR(
			VERIFY$_READHEADER, FILE_ID, .HEADER,
			.STATUS);


		    ! If we are repairing damage, rewrite the header with a
		    ! deleted header.  In either case, ensure that the header
		    ! is invalidated so that we will not process it.
		    !
		    HEADER[FH2$B_STRUCLEV] = 0;
		    IF DO_REPAIR(NO_CONFIRM)
		    THEN
			DELETE_HEADER(FILE_ID, .HEADER)
		    ELSE
		    	BITVECTOR[.IMAP[.RVN-1], .FILE_NUMBER-1] = FALSE;
		    END;
		END;
	    END;


	! For each header, verify that it is a valid file header.
	! If it is, process it.
	!
	HEADER = BUFFER;
	INCR XVBN FROM 0 TO .READ_COUNT-1 DO
	    BEGIN
	    LOCAL
		IDENT_AREA:	REF BBLOCK,	! Pointer to ident area
		MAP_AREA:	REF BBLOCK,	! Pointer to map area
		EXT_SEQ,			! Current extension sequence
		FILE_NUMBER,			! Current file number
		FILE_ID:	BBLOCK[FID$C_LENGTH];	! Current file ID


	    ! Get a clean file ID.
	    !
	    FILE_NUMBER = .VBN + .XVBN - .HEADER_OFFSET[.RVN-1];
	    FILE_ID[FID$W_NUM] = .FILE_NUMBER;
	    FILE_ID[FID$B_NMX] = .FILE_NUMBER<16,8>;
	    IF .STRUCTURE_LEVEL EQL 2
		THEN FILE_ID[FID$W_SEQ] = .HEADER[FH2$W_FID_SEQ]
		ELSE FILE_ID[FID$W_SEQ] = .HEADER[FH1$W_FID_SEQ];
	    FILE_ID[FID$B_RVN] = .RVN;


	    ! Validate the header.  In ODS-2, a valid header is to be taken as
	    ! valid even if the index file bitmap shows it as available.  In
	    ! ODS-1, a header corresponding to a clear index file bitmap bit
	    ! is not to be examined.
	    !
	    STATUS = VERIFY_HEADER(.HEADER, FILE_ID);
	    IF
		.STRUCTURE_LEVEL EQL 1 AND
		NOT .BITVECTOR[.IMAP[.RVN-1], .FILE_NUMBER-1]
	    THEN
		STATUS = FALSE;


	    IF .STATUS
	    THEN
		BEGIN

		! Header is valid.
		!
		IDENT_AREA = .HEADER + .HEADER[FH1$B_IDOFFSET]*2;
		MAP_AREA = .HEADER + .HEADER[FH1$B_MPOFFSET]*2;


		IF NOT .DUAL_ALLOC_PASS
		THEN
		    BEGIN
		    IF .QUAL[QUAL_LIST]
		    THEN
			BEGIN
			IF .STRUCTURE_LEVEL EQL 2
			THEN
			    BEGIN
			    FAO_(
				'(!8ZL,!5ZL,!3ZL)  !20AF  [!OB,!OB]',
				.FILE_NUMBER,
				.FILE_ID[FID$W_SEQ],
				.FILE_ID[FID$B_RVN],
				FI2$S_FILENAME,
				IDENT_AREA[FI2$T_FILENAME],
				.HEADER[FH2$W_UICGROUP],
				.HEADER[FH2$W_UICMEMBER]);

			    IF .HEADER[FH2$W_SEG_NUM] NEQ 0
			    THEN
				FAO_('  extension !UL', .HEADER[FH2$W_SEG_NUM]);
			    END
			ELSE
			    BEGIN
			    LOCAL
				FILENAME:	VECTOR[FI2$S_FILENAME,BYTE],
				LENGTH;

			    LENGTH = MAKE_STRING(
				IDENT_AREA[FI1$W_FILENAME] - $BYTEOFFSET(NMB$W_NAME),
				FILENAME);
			    FAO_(
				'(!8ZL,!5ZL,!3ZL)  !20AF  [!OB,!OB]',
				.FILE_NUMBER,
				.FILE_ID[FID$W_SEQ],
				.FILE_ID[FID$B_RVN],
				.LENGTH,
				FILENAME,
				.HEADER[FH1$B_UICGROUP],
				.HEADER[FH1$B_UICMEMBER]);

			    IF .MAP_AREA[FM1$B_EX_SEGNUM] NEQ 0
			    THEN
				FAO_('  extension !UL', .MAP_AREA[FM1$B_EX_SEGNUM]);
			    END;

			EOL();
			END;


		    ! Make sure the index file bitmap indicates that the header
		    ! is valid.  Remember the file sequence number and the
		    ! back link FID.
		    !
		    BITVECTOR[.IMAP[.RVN-1], .FILE_NUMBER-1] = TRUE;
		    VECTOR[.SEQMAP[.RVN-1], .FILE_NUMBER-1 ;,WORD] = .FILE_ID[FID$W_SEQ];
		    IF .STRUCTURE_LEVEL EQL 2
		    THEN
			BEGIN
			LOCAL
			    BACK_ID:	REF BBLOCK;

			BACK_ID = VECTOR[.BACKMAP[.RVN-1], (.FILE_NUMBER-1)*3 ;,WORD];
			BACK_ID[FID$W_NUM] = .HEADER[FH2$W_BK_FIDNUM];
			BACK_ID[FID$W_SEQ] = .HEADER[FH2$W_BK_FIDSEQ];
			BACK_ID[FID$W_RVN] = .HEADER[FH2$W_BK_FIDRVN];
			IF .BACK_ID[FID$B_RVN] EQL 0 THEN BACK_ID[FID$B_RVN] = .RVN;
			END;
		    END;


		! Other processing executed only if not an extension header.
		!
		IF
		    BEGIN
		    IF .STRUCTURE_LEVEL EQL 2
			THEN .HEADER[FH2$W_SEG_NUM] EQL 0
			ELSE .MAP_AREA[FM1$B_EX_SEGNUM] EQL 0
		    END
		THEN
		    BEGIN
		    LOCAL
			FAT:	REF BBLOCK,
			FCH:	REF BBLOCK;


		    IF NOT .DUAL_ALLOC_PASS
		    THEN
			BEGIN

			! Directory entry should point to this file.
			!
			BITVECTOR[.LOSTMAP[.RVN-1], .FILE_NUMBER-1] = TRUE;


			! Get file characteristics and attributes pointer.
			!
			IF .STRUCTURE_LEVEL EQL 2
			THEN
			    BEGIN
			    FCH = HEADER[FH2$L_FILECHAR];
			    FAT = HEADER[FH2$W_RECATTR];
			    END
			ELSE
			    BEGIN
			    FCH = HEADER[FH1$W_FILECHAR];
			    FAT = HEADER[FH1$W_RECATTR];
			    END;


			! Report file marked for delete.
			!
			IF .FCH[FCH$V_MARKDEL]
			THEN
			    BEGIN
			    HEADER_ERROR(VERIFY$_DELHEADER, FILE_ID, .HEADER);
			    IF DO_REPAIR()
			    THEN
				BEGIN
				ENTER_WORK(WRK_K_DELETE, FILE_ID);
		    		VECTOR[.SEQMAP[.RVN-1], .FILE_NUMBER-1 ;,WORD] = -1;
				END;
			    END;


			! Report file deaccess locked.
			!
			IF .FCH[FCH$V_LOCKED]
			THEN
			    BEGIN
			    HEADER_ERROR(VERIFY$_LOCKHEADER, FILE_ID, .HEADER);
			    IF (STATUS = DO_REPAIR(ALLOW_DELETE))
			    THEN
				BEGIN
				IF .STATUS<1,1>
				THEN
				    BEGIN
				    ENTER_WORK(WRK_K_DELETE, FILE_ID);
		    		    VECTOR[.SEQMAP[.RVN-1], .FILE_NUMBER-1 ;,WORD] = -1;
				    END
				ELSE
				    BEGIN
				    FCH[FCH$V_LOCKED] = FALSE;
				    WRITE_HEADER(FILE_ID, .HEADER);
				    END;
				END;
			    END;


			! Report file containing suspected bad blocks.
			!
			IF .FCH[FCH$V_BADBLOCK]
			THEN
			    HEADER_ERROR(VERIFY$_BBLHEADER, FILE_ID, .HEADER);


			! Remember directory bit.
			!
			IF
			    .FILE_NUMBER NEQ FID$C_MFD
			AND
			    BEGIN
			    IF .STRUCTURE_LEVEL EQL 2
			    THEN
				.HEADER[FH2$V_DIRECTORY]
			    ELSE
				.FAT[FAT$B_RTYPE] EQL FAT$C_FIXED AND
				.FAT[FAT$W_RSIZE] EQL NMB$C_DIRENTRY AND
				.IDENT_AREA[FI1$W_FILETYPE] EQL %RAD50_11 'DIR'
			    END
			THEN
			    BITVECTOR[.DIRMAP[.RVN-1], .FILE_NUMBER-1] = TRUE;


			! Check creation date.
			!
			CHECK_DATE(
			    IDENT_AREA[FI2$Q_CREDATE],
			    IDENT_AREA[FI1$T_CREDATE],
			    VERIFY$_FUTCREDAT,
			    FILE_ID,
			    .HEADER);


			! Check revision date.
			!
			CHECK_DATE(
			    IDENT_AREA[FI2$Q_REVDATE],
			    IDENT_AREA[FI1$T_REVDATE],
			    VERIFY$_FUTREVDAT,
			    FILE_ID,
			    .HEADER);


			! Check backup date.
			!
			IF .STRUCTURE_LEVEL EQL 2
			THEN
			    CHECK_DATE(
				IDENT_AREA[FI2$Q_BAKDATE],
				0,
			        VERIFY$_FUTBAKDAT,
				FILE_ID,
				.HEADER);
			END;


		    ! Process map area.
		    !
		    TOTAL_SIZE = 0;
		    MAP_PROCESS(.HEADER, .RVN, .HEADER, FILE_ID, +1);


		    ! If file has extension headers, run down the chain
		    ! checking them.
		    !
		    EXT_SEQ = 0;
		    IF
			BEGIN
			IF .STRUCTURE_LEVEL EQL 2
			    THEN .HEADER[FH2$W_EX_FIDNUM] NEQ 0
			    ELSE .MAP_AREA[FM1$W_EX_FILNUM] NEQ 0
			END
		    THEN
			BEGIN
			LOCAL
			    EXT_HDR:		REF BBLOCK,
			    EXT_MAP_AREA:	REF BBLOCK,
			    EXT_RVN,
			    PREV_FILE_ID:	BBLOCK[FID$C_LENGTH];


			EXT_HDR = .HEADER;
			EXT_MAP_AREA = .MAP_AREA;
			EXT_RVN = .RVN;
			PREV_FILE_ID[FID$W_NUM] = .FILE_ID[FID$W_NUM];
			PREV_FILE_ID[FID$W_SEQ] = .FILE_ID[FID$W_SEQ];
			PREV_FILE_ID[FID$W_RVN] = .FILE_ID[FID$W_RVN];
			WHILE
			    BEGIN
			    IF .STRUCTURE_LEVEL EQL 2
				THEN .EXT_HDR[FH2$W_EX_FIDNUM] NEQ 0
				ELSE .EXT_MAP_AREA[FM1$W_EX_FILNUM] NEQ 0
			    END
			DO
			    BEGIN
			    LOCAL
				EXT_FILE_NUMBER,
				EXT_FILE_ID:	BBLOCK[FID$C_LENGTH];


			    ! Get clean file number and RVN.
			    !
			    IF .STRUCTURE_LEVEL EQL 2
			    THEN
				BEGIN
				EXT_FILE_NUMBER = .EXT_HDR[FH2$W_EX_FIDNUM];
				EXT_FILE_NUMBER<16,8> = .EXT_HDR[FH2$B_EX_FIDNMX];
				EXT_FILE_ID[FID$W_NUM] = .EXT_HDR[FH2$W_EX_FIDNUM];
				EXT_FILE_ID[FID$W_SEQ] = .EXT_HDR[FH2$W_EX_FIDSEQ];
				EXT_FILE_ID[FID$W_RVN] = .EXT_HDR[FH2$W_EX_FIDRVN];
				END
			    ELSE
				BEGIN
				EXT_FILE_NUMBER = .EXT_MAP_AREA[FM1$W_EX_FILNUM];
				EXT_FILE_ID[FID$W_NUM] = .EXT_MAP_AREA[FM1$W_EX_FILNUM];
				EXT_FILE_ID[FID$W_SEQ] = .EXT_MAP_AREA[FM1$W_EX_FILSEQ];
				EXT_FILE_ID[FID$W_RVN] = 1;
				END;
			    IF .EXT_FILE_ID[FID$B_RVN] EQL 0 THEN EXT_FILE_ID[FID$B_RVN] = .EXT_RVN;
			    EXT_RVN = .EXT_FILE_ID[FID$B_RVN];


			    ! If extension linkage points to CONTIN.SYS, exit
			    ! the loop, since following segments of the file
			    ! exist as part of a loosely coupled volume set.
			    !
			    IF
				.STRUCTURE_LEVEL EQL 2 AND
				.EXT_FILE_NUMBER EQL FID$C_CONTIN AND
				.EXT_FILE_ID[FID$W_SEQ] EQL FID$C_CONTIN
			    THEN
				EXITLOOP;


			    ! Validity check extension file ID.  If this fails,
			    ! clear the extension linkage and exit the loop.
			    !
			    IF
				BEGIN
				IF .EXT_RVN GTRU .VOLUME_COUNT
				THEN
				    TRUE
				ELSE
				    .EXT_FILE_NUMBER-1 GTRU .MAXFILIDX[.EXT_RVN-1]
				END
			    THEN
				BEGIN
				IF NOT .DUAL_ALLOC_PASS
				THEN
				    BEGIN
				    HEADER_ERROR(VERIFY$_INVEXTFID, FILE_ID, .HEADER);
				    IF DO_REPAIR()
				    THEN
					CLEAR_EXT_FID(FILE_ID, .HEADER);
				    END;
				EXITLOOP;
				END;


			    ! Read extension file header.  If this fails,
			    ! exit the loop.
			    !
			    IF NOT READ_HEADER(EXT_FILE_ID, BUFFER_2)
			    THEN
				BEGIN
				IF NOT .DUAL_ALLOC_PASS
				THEN
				    BEGIN
				    IF DO_REPAIR()
				    THEN
					IF READ_HEADER(PREV_FILE_ID, BUFFER_2)
					THEN
					    CLEAR_EXT_FID(PREV_FILE_ID, BUFFER_2);
				    END;
				EXITLOOP;
				END;


			    ! Adjust pointers to new header.
			    !
			    EXT_HDR = BUFFER_2;
			    EXT_MAP_AREA = .EXT_HDR + .EXT_HDR[FH1$B_MPOFFSET]*2;
			    EXT_SEQ = .EXT_SEQ + 1;


			    ! Check segment number.  If this check fails,
			    ! clear the forward link that points to the bad
			    ! header and exit the loop.
			    !
			    IF
				BEGIN
				IF .STRUCTURE_LEVEL EQL 2
				    THEN .EXT_HDR[FH2$W_SEG_NUM] NEQ .EXT_SEQ
				    ELSE .EXT_MAP_AREA[FM1$B_EX_SEGNUM] NEQ .EXT_SEQ
				END
			    THEN
				BEGIN
				IF NOT .DUAL_ALLOC_PASS
				THEN
				    BEGIN
				    HEADER_ERROR(VERIFY$_INVEXTHDR, EXT_FILE_ID, .EXT_HDR);
				    IF DO_REPAIR()
				    THEN
					BEGIN
					IF READ_HEADER(PREV_FILE_ID, BUFFER_2)
					THEN
					    CLEAR_EXT_FID(PREV_FILE_ID, BUFFER_2);
					END;
				    END;
				EXITLOOP;
				END;


			    ! Remember previous file ID in case we need to
			    ! clear the forward link.
			    !
			    PREV_FILE_ID[FID$W_NUM] = .EXT_FILE_ID[FID$W_NUM];
			    PREV_FILE_ID[FID$W_SEQ] = .EXT_FILE_ID[FID$W_SEQ];
			    PREV_FILE_ID[FID$W_RVN] = .EXT_FILE_ID[FID$W_RVN];


			    ! Do map area processing.
			    !
			    MAP_PROCESS(.EXT_HDR, .EXT_RVN, .HEADER, FILE_ID, 0);


			    IF NOT .DUAL_ALLOC_PASS
			    THEN
				BEGIN

				! Check extension header back link.  It should
				! point to primary header.
				!
				IF .STRUCTURE_LEVEL EQL 2
				THEN
				    BEGIN
				    LOCAL
					BCK_RVN;

				    BCK_RVN = .EXT_HDR[FH2$B_BK_FIDRVN];
				    IF .BCK_RVN EQL 0 THEN BCK_RVN = .EXT_FILE_ID[FID$B_RVN];
				    IF
					.EXT_HDR[FH2$W_BK_FIDNUM] NEQ .FILE_ID[FID$W_NUM] OR
					.EXT_HDR[FH2$W_BK_FIDSEQ] NEQ .FILE_ID[FID$W_SEQ] OR
					.EXT_HDR[FH2$B_BK_FIDNMX] NEQ .FILE_ID[FID$B_NMX] OR
					.BCK_RVN NEQ .FILE_ID[FID$B_RVN]
				    THEN
					BEGIN
					HEADER_ERROR(
					    VERIFY$_INVEXTBACK, EXT_FILE_ID, .EXT_HDR);
					IF DO_REPAIR()
					THEN
					    BEGIN
					    EXT_HDR[FH2$W_BK_FIDNUM] = .FILE_ID[FID$W_NUM];
					    EXT_HDR[FH2$W_BK_FIDSEQ] = .FILE_ID[FID$W_SEQ];
					    EXT_HDR[FH2$W_BK_FIDRVN] = .FILE_ID[FID$W_RVN];
					    IF .EXT_HDR[FH2$B_BK_FIDRVN] EQL .EXT_FILE_ID[FID$B_RVN]
						THEN EXT_HDR[FH2$B_BK_FIDRVN] = 0;
					    WRITE_HEADER(EXT_FILE_ID, .EXT_HDR);
					    END;
					END;
				    END;


				! Mark as a referenced extension header.  If
				! already marked, report multiple references.
				!
				IF TESTBITSS(BITVECTOR[.EXTMAP[.EXT_RVN-1], .EXT_FILE_NUMBER-1])
				THEN
				    HEADER_ERROR(
					VERIFY$_MULTEXTHDR, EXT_FILE_ID, .EXT_HDR);


				! Check file owner.  If not equal, should be
				! corrected to charge space to rightful user.
				!
				IF
				    BEGIN
				    IF .STRUCTURE_LEVEL EQL 2
					THEN .EXT_HDR[FH2$L_FILEOWNER] NEQ .HEADER[FH2$L_FILEOWNER]
					ELSE .EXT_HDR[FH1$W_FILEOWNER] NEQ .HEADER[FH1$W_FILEOWNER]
				    END
				THEN
				    BEGIN
				    HEADER_ERROR(VERIFY$_WRONGOWNER, EXT_FILE_ID, .EXT_HDR);
				    IF DO_REPAIR()
				    THEN
					BEGIN
					IF .STRUCTURE_LEVEL EQL 2
					    THEN EXT_HDR[FH2$L_FILEOWNER] = .HEADER[FH2$L_FILEOWNER]
					    ELSE EXT_HDR[FH1$W_FILEOWNER] = .HEADER[FH1$W_FILEOWNER];
					WRITE_HEADER(EXT_FILE_ID, .EXT_HDR);
					END;
				    END;
				END;
			    END;
			END;


		    IF NOT .DUAL_ALLOC_PASS
		    THEN
			BEGIN

			! Check HIBLK and EFBLK in record attributes against
			! total size computed from map area.  Allow the error
			! for INDEXF.SYS, BITMAP.SYS, and BADBLK.SYS in ODS-1,
			! since HIBLK is not maintained for these files.
			!
			IF
			    .TOTAL_SIZE NEQ ROT(.FAT[FAT$L_HIBLK], 16) AND
			    (.STRUCTURE_LEVEL NEQ 1 OR .FILE_NUMBER GTRU FID$C_BADBLK)
			THEN
			    BEGIN
			    HEADER_ERROR(VERIFY$_BADHIBLK, FILE_ID, .HEADER);
			    IF DO_REPAIR()
			    THEN
				BEGIN
				FAT[FAT$L_HIBLK] = ROT(.TOTAL_SIZE, 16);
				WRITE_HEADER(FILE_ID, .HEADER);
				END;
			    END;


			IF
			    .FAT[FAT$L_EFBLK] NEQ 0 AND
			    ROT(.FAT[FAT$L_EFBLK], 16) - (.FAT[FAT$W_FFBYTE] EQL 0)
			    GTRU .TOTAL_SIZE
			THEN
			    BEGIN
			    HEADER_ERROR(VERIFY$_BADEFBLK, FILE_ID, .HEADER);
			    IF DO_REPAIR()
			    THEN
				BEGIN
				FAT[FAT$L_EFBLK] = ROT(.TOTAL_SIZE + 1, 16);
				FAT[FAT$W_FFBYTE] = 0;
				WRITE_HEADER(FILE_ID, .HEADER);
				END;
			    END;


			! Read-check the file if requested.
			!
			IF .QUAL[QUAL_READ]
			THEN
			    IF .FILE_NUMBER GEQU FID$C_MFD
			    THEN
				READ_CHECK(FILE_ID, .HEADER);


			! Update usage info.
			!
			IF .QUAL[QUAL_USAG]
			THEN
			    BEGIN
			    IF .STRUCTURE_LEVEL EQL 2
				THEN VECTOR[.OWNER[.RVN-1], .FILE_NUMBER-1] = .HEADER[FH2$L_FILEOWNER]
				ELSE VECTOR[.OWNER[.RVN-1], .FILE_NUMBER-1] = .HEADER[FH1$B_UICGROUP]^16 + .HEADER[FH1$B_UICMEMBER];
			    VECTOR[.ALLOCATION[.RVN-1], .FILE_NUMBER-1] = .TOTAL_SIZE + .EXT_SEQ + 1;
			    VECTOR[.USAGE[.RVN-1], .FILE_NUMBER-1] = ROT(.FAT[FAT$L_EFBLK], 16);
			    IF
				.FAT[FAT$L_EFBLK] NEQ 0 AND
				.FAT[FAT$W_FFBYTE] EQL 0
			    THEN
				VECTOR[.USAGE[.RVN-1], .FILE_NUMBER-1] =
				    .VECTOR[.USAGE[.RVN-1], .FILE_NUMBER-1] - 1;
			    END;


			! Update quota info.
			!
			IF .QUOTA_ACTIVE AND .FILE_NUMBER GEQU FID$C_MFD
			THEN
			    COUNT_QUOTA(
				.HEADER[FH2$L_FILEOWNER],
				0,
				.TOTAL_SIZE + .EXT_SEQ + 1);
			END;
		    END
		ELSE
		    BEGIN

		    ! Extension header.  Just process the map area.
		    !
		    MAP_PROCESS(.HEADER, .RVN, .HEADER, FILE_ID, -1);
		    END;
		END
	    ELSE
		BEGIN
		!
		! Invalid or deleted file header.  If it is marked busy in the
		! bitmap, complain and rewrite a valid deleted header.
		!
		IF NOT .DUAL_ALLOC_PASS
		THEN
		    BEGIN
		    IF .BITVECTOR[.IMAP[.RVN-1], .FILE_NUMBER-1]
		    THEN
			BEGIN
			HEADER_ERROR(VERIFY$_BADHEADER, FILE_ID, .HEADER);
			IF DO_REPAIR()
			THEN
			    DELETE_HEADER(FILE_ID, .HEADER);
			END;
		    END;
		END;


	    HEADER = .HEADER + 512;
	    END;


	VBN = .VBN + INDEX_BUF_COUNT;
	END;


    ! Deaccess the index file.
    !
    $QIOW(
	FUNC=IO$_DEACCESS,
	CHAN=.CHANNEL);
    END;
END;

ROUTINE VERIFY_HEADER(HEADER,FILE_ID)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine determines if the block given it is a valid file header.
!
! INPUT PARAMETERS:
!	HEADER		- Pointer to header.
!	FILE_ID		- Purported file ID.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	0 if invalid file header
!	1 if valid file header
!	2 if deleted file header
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	HEADER:		REF BBLOCK,	! Pointer to file header
	FILE_ID:	REF BBLOCK;	! Pointer to file ID


! First check the structure level.
!
IF .HEADER[FH2$B_STRUCLEV] NEQ .STRUCTURE_LEVEL
THEN
    RETURN 0;


IF .STRUCTURE_LEVEL EQL 2
THEN
    BEGIN

    ! Check the area offsets and the retrieval pointer use counts for
    ! consistency.
    !
    IF
	.HEADER[FH2$B_IDOFFSET] LSSU FH2$C_LENGTH/2 OR
	.HEADER[FH2$B_MPOFFSET] LSSU .HEADER[FH2$B_IDOFFSET] OR
	.HEADER[FH2$B_ACOFFSET] LSSU .HEADER[FH2$B_MPOFFSET] OR
	.HEADER[FH2$B_RSOFFSET] LSSU .HEADER[FH2$B_ACOFFSET] OR
	.HEADER[FH2$B_MAP_INUSE] GTRU .HEADER[FH2$B_ACOFFSET] - .HEADER[FH2$B_MPOFFSET]
    THEN
	RETURN 0;


    ! At this point, we have verified that the block at least once was a
    ! valid file header.
    !
    ! Look at the file number in the header. If zero, this is a 
    ! deleted header.
    !
    IF
	.HEADER[FH2$W_FID_NUM] EQL 0 AND
	.HEADER[FH2$B_FID_NMX] EQL 0
    THEN
	RETURN 2;


    ! Now compute the header checksum.
    !
    IF NOT CHECKSUM(.HEADER)
    THEN
	RETURN 2;


    ! Check file number and file sequence number.
    !
    IF
	.HEADER[FH2$W_FID_NUM] NEQ .FILE_ID[FID$W_NUM] OR
	.HEADER[FH2$B_FID_NMX] NEQ .FILE_ID[FID$B_NMX] OR
	.HEADER[FH2$W_FID_SEQ] NEQ .FILE_ID[FID$W_SEQ]
    THEN
	RETURN 2;
    END
ELSE
    BEGIN
    LOCAL
	MAP_AREA:	REF BBLOCK;


    ! Check the area offsets, the extension RVN, and the retrieval pointer
    ! data for consistency.
    !
    IF
	.HEADER[FH1$B_IDOFFSET] NEQ FH1$C_LENGTH / 2 OR
	.HEADER[FH1$B_MPOFFSET] NEQ (FH1$C_LENGTH + FI1$C_LENGTH) / 2
    THEN
	RETURN 0;


    MAP_AREA = .HEADER + .HEADER[FH1$B_MPOFFSET]*2;
    IF
	.MAP_AREA[FM1$B_EX_RVN] NEQ 0 OR
	.MAP_AREA[FM1$B_COUNTSIZE] NEQ 1 OR
	.MAP_AREA[FM1$B_LBNSIZE] NEQ 3 OR
	.MAP_AREA[FM1$B_INUSE] GTRU .MAP_AREA[FM1$B_AVAIL] OR
	.MAP_AREA[FM1$B_AVAIL] GTRU 255 - (.MAP_AREA + FM1$C_POINTERS - .HEADER) / 2
    THEN
	RETURN 0;


    ! At this point, we have verified that the block at least once was a
    ! valid file header.
    !
    ! Look at the file number in the header. If zero, this is a 
    ! deleted header.
    !
    IF .HEADER[FH1$W_FID_NUM] EQL 0
    THEN
	RETURN 2;


    ! Now compute the header checksum.
    !
    IF NOT CHECKSUM(.HEADER)
    THEN
	RETURN 2;


    ! Check file number and file sequence number.
    !
    IF
	.HEADER[FH1$W_FID_NUM] NEQ .FILE_ID[FID$W_NUM] OR
	.HEADER[FH1$W_FID_SEQ] NEQ .FILE_ID[FID$W_SEQ]
    THEN
	RETURN 2;
    END;


! Header is OK.
!
RETURN 1;
END;

ROUTINE MAP_PROCESS(HEADER,RVN,MAIN_HEADER,FILE_ID,SCAN_TYPE): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine computes the number of blocks mapped by the specified
!	file header, and marks them busy in the "new" storage bitmap.
!
! INPUT PARAMETERS:
!	HEADER		- Pointer to file header to be processed.
!	RVN		- Relative volume number of header.
!	MAIN_HEADER	- Pointer to file header for segment 0.
!	FILE_ID		- Pointer to file ID of main header.
!	SCAN_TYPE	- +1:  Primary header in file number order
!			   0:  Extension header in extension linkage order
!			  -1:  Extension header in file number order
!
! IMPLICIT INPUTS:
!	TOTAL_SIZE	- Blocks mapped thus far.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	Clusters marked busy in "new" storage bitmap.
!	TOTAL_SIZE	- Updated.
!
! ROUTINE VALUE:
!	Number of blocks in header.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	HEADER:		REF BBLOCK;	! File header
LINKAGE
	L_MAP_POINTER=	JSB:
			GLOBAL(COUNT=6, LBN=7, MAP_POINTER=8);
GLOBAL REGISTER
	COUNT=		6,		! Retrieval pointer count
	LBN=		7,		! Retrieval pointer LBN
	MAP_POINTER=	8: REF BBLOCK;	! Pointer to scan map area
EXTERNAL ROUTINE
	GET_MAP_POINTER: L_MAP_POINTER; ! Get value of ODS-2 file map pointer
LOCAL
	END_MAP_USED,			! Pointer to end of used map area
	END_MAP_ALLOC;			! Pointer to end of allocated map area


! Get pointers to the map area, the end of the used portion of the map area,
! and the end of the allocated portion of the map area.
!
IF .STRUCTURE_LEVEL EQL 2
THEN
    BEGIN
    MAP_POINTER = .HEADER + .HEADER[FH2$B_MPOFFSET]*2;
    END_MAP_ALLOC = .HEADER + .HEADER[FH2$B_ACOFFSET]*2;
    END_MAP_USED = .MAP_POINTER + .HEADER[FH2$B_MAP_INUSE]*2;
    END
ELSE
    BEGIN
    MAP_POINTER = .HEADER + .HEADER[FH1$B_MPOFFSET]*2;
    END_MAP_ALLOC = .HEADER + $BYTEOFFSET(FH1$W_CHECKSUM);
    END_MAP_USED = .MAP_POINTER + FM1$C_POINTERS + .MAP_POINTER[FM1$B_INUSE]*2;
    MAP_POINTER = .MAP_POINTER + FM1$C_POINTERS;
    END;


! Loop until entire map processed.
!
UNTIL .MAP_POINTER GEQA .END_MAP_USED DO
    BEGIN
    LOCAL
	DIVIDEND:	VECTOR[2],	! Quadword for EDIV dividend
	REMAINDER,			! EDIV remainder
	CLUSTER_NUMBER,			! Cluster bit number
	CLUSTER_COUNT;			! Count of clusters to mark allocated


    ! Get count and LBN.
    !
    IF .STRUCTURE_LEVEL EQL 2
    THEN
	GET_MAP_POINTER()
    ELSE
	BEGIN
	LBN = .MAP_POINTER[FM1$W_LOWLBN];
	LBN<16,8> = .MAP_POINTER[FM1$B_HIGHLBN];
	COUNT = .MAP_POINTER[FM1$B_COUNT] + 1;
	MAP_POINTER = .MAP_POINTER + 4;
	END;


    ! Convert count and LBN by cluster factor.  Make sure that the values are
    ! even multiples of the cluster factor.
    !
    DIVIDEND[1] = 0;
    DIVIDEND[0] = .COUNT;
    EDIV(CLUSTER_FACTOR[.RVN-1], DIVIDEND, CLUSTER_COUNT, REMAINDER);
    IF .REMAINDER NEQ 0
    THEN
	HEADER_ERROR(
	    VERIFY$_MAPAREA,
	    .FILE_ID,
	    .MAIN_HEADER);
    DIVIDEND[0] = .LBN;
    EDIV(CLUSTER_FACTOR[.RVN-1], DIVIDEND, CLUSTER_NUMBER, REMAINDER);
    IF .REMAINDER NEQ 0
    THEN
	HEADER_ERROR(
	    VERIFY$_MAPAREA,
	    .FILE_ID,
	    .MAIN_HEADER);


    ! Loop for each bit of the bitmap that is affected.  If we are doing the
    ! multiple allocation scan, report any bits that are multiply allocated.
    ! Otherwise, mark the bits allocated, and if they are already marked,
    ! mark them in the multiple allocation map and set the multiple
    ! allocation summary flag.
    !
    IF .DUAL_ALLOC_PASS
    THEN
	INCR J FROM 0 TO .CLUSTER_COUNT-1 DO
	    BEGIN
	    IF .CLUSTER_NUMBER + .J GTRU .SMAP_SIZE[.RVN-1]*512*8-1 
	    THEN
		EXITLOOP;


	    IF
		.BITVECTOR[.MULTSMAP[.RVN-1], .CLUSTER_NUMBER + .J] AND
		.SCAN_TYPE
	    THEN
		BEGIN
		HEADER_ERROR(
		    VERIFY$_MULTALLOC,
		    .FILE_ID,
		    .MAIN_HEADER,
		    1 + .TOTAL_SIZE + .J * .CLUSTER_FACTOR[.RVN-1],
		    .TOTAL_SIZE + (.J + 1) * .CLUSTER_FACTOR[.RVN-1],
		    .LBN + .J * .CLUSTER_FACTOR[.RVN-1],
		    .LBN + (.J + 1) * .CLUSTER_FACTOR[.RVN-1] - 1,
		    .RVN);
		END;
	    END
    ELSE
	INCR J FROM .CLUSTER_NUMBER TO .CLUSTER_NUMBER + .CLUSTER_COUNT - 1 DO
	    BEGIN
	    IF .J GTRU .SMAP_SIZE[.RVN-1]*512*8-1
	    THEN
		BEGIN
		HEADER_ERROR(
		    VERIFY$_MAPAREA,
		    .FILE_ID,
		    .MAIN_HEADER);
		EXITLOOP;
		END;


	    IF .SCAN_TYPE GEQ 0
	    THEN
		BITVECTOR[.NSMAP[.RVN-1], .J] = FALSE;


	    IF .SCAN_TYPE
	    THEN
		IF TESTBITCC(BITVECTOR[.VSMAP[.RVN-1], .J])
		THEN
		    BEGIN
		    BITVECTOR[.MULTSMAP[.RVN-1], .J] = TRUE;
		    DUAL_ALLOC_FOUND = TRUE;
		    END;
	    END;


    ! Finally, add the count into the total file size.
    !
    TOTAL_SIZE = .TOTAL_SIZE + .COUNT;
    END;



! Make sure that the last map pointer ended at the location identified by
! MAP_INUSE.
!
IF .MAP_POINTER NEQA .END_MAP_USED
THEN
    HEADER_ERROR(
	VERIFY$_MAPAREA,
	.FILE_ID,
	.MAIN_HEADER);
    

! Make sure that the unused portion of the map area is zero.
!
IF .END_MAP_ALLOC GTRA .END_MAP_USED
THEN
    IF CH$FIND_NOT_CH(.END_MAP_ALLOC-.END_MAP_USED, .END_MAP_USED, 0) NEQ 0
    THEN
	HEADER_ERROR(
	    VERIFY$_MAPAREA,
	    .FILE_ID,
	    .MAIN_HEADER);
END;

ROUTINE CREATE_WINDOW(P_HEADER,P_RVN)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine generates a window block (or blocks) from a file
!	header, reading the extension headers as necessary.
!
! INPUT PARAMETERS:
!	P_HEADER	- Pointer to file header to be processed.
!	P_RVN		- Relative volume number of file header.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Pointer to window block.  If the header maps no space, 0.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LINKAGE
	L_MAP_POINTER=	JSB:
			GLOBAL(COUNT=6, LBN=7, MAP_POINTER=8);
EXTERNAL ROUTINE
	GET_MAP_POINTER: L_MAP_POINTER; ! Get value of ODS-2 file map pointer
LOCAL
	HEADER:		REF BBLOCK,	! Pointer to current file header
	RVN,				! RVN of current file header
	EXT_FILE_ID:	BBLOCK[FID$C_LENGTH],	! Extension file ID
	LOCAL_HEADER:	BBLOCK[512],	! Local area for file header
	WINDOW_LIST:	VECTOR[2],	! List head of window list
	WINDOW:		BBLOCK[WDW_S_HEADER + WDW_K_MAXENTRY * WDW_S_ENTRY],
	P:		REF BBLOCK;	! Pointer to current window entry

	
! Initialize.
!
HEADER = .P_HEADER;
RVN = .P_RVN;
WINDOW_LIST[0] = WINDOW_LIST[1] = 0;
WINDOW[WDW_LINK] = 0;
WINDOW[WDW_SIZE] = 0;
P = WINDOW + WDW_S_HEADER - WDW_S_ENTRY;


! Loop over this header and all of its extension headers.
!
WHILE TRUE DO
    BEGIN
    GLOBAL REGISTER
	COUNT=		6,		! Retrieval pointer count
	LBN=		7,		! Retrieval pointer LBN
	MAP_POINTER=	8: REF BBLOCK;	! Pointer to scan map area
    LOCAL
	END_MAP;			! Pointer to end of used map area


    ! Get pointers to the map area and the end of the used portion
    ! of the map area.
    !
    IF .STRUCTURE_LEVEL EQL 2
    THEN
	BEGIN
	MAP_POINTER = .HEADER + .HEADER[FH2$B_MPOFFSET]*2;
	END_MAP = .MAP_POINTER + .HEADER[FH2$B_MAP_INUSE]*2;
	END
    ELSE
	BEGIN
	MAP_POINTER = .HEADER + .HEADER[FH1$B_MPOFFSET]*2;
	END_MAP = .MAP_POINTER + FM1$C_POINTERS + .MAP_POINTER[FM1$B_INUSE]*2;
	MAP_POINTER = .MAP_POINTER + FM1$C_POINTERS;
	END;


    ! Loop until entire map processed.
    !
    UNTIL .MAP_POINTER GEQA .END_MAP DO
	BEGIN

	! Get count and LBN.
	!
	IF .STRUCTURE_LEVEL EQL 2
	THEN
	    GET_MAP_POINTER()
	ELSE
	    BEGIN
	    LBN = .MAP_POINTER[FM1$W_LOWLBN];
	    LBN<16,8> = .MAP_POINTER[FM1$B_HIGHLBN];
	    COUNT = .MAP_POINTER[FM1$B_COUNT] + 1;
	    MAP_POINTER = .MAP_POINTER + 4;
	    END;


	! Collapse with previous map pointer if contiguous with it --
	! otherwise, generate new map pointer.
	!
	IF
	    BEGIN
	    IF .WINDOW[WDW_SIZE] NEQ 0
	    THEN
		.P[WDW_COUNT] + .P[WDW_LBN] EQL .LBN
	    ELSE
		FALSE
	    END
	THEN
	    P[WDW_COUNT] = .P[WDW_COUNT] + .COUNT
	ELSE
	    BEGIN
	    IF .WINDOW[WDW_SIZE] GEQU WDW_K_MAXENTRY
	    THEN
		BEGIN
		LOCAL
		    STATUS,		! Status return
		    DYNWDW;		! Dynamic window pointer


		! Window block has overflowed.  Move local window block to
		! dynamic space and initialize for new block.
		!
		STATUS = LIB$GET_VM(
		    UPLIT(WDW_S_HEADER + WDW_K_MAXENTRY * WDW_S_ENTRY),
		    DYNWDW);
		IF NOT .STATUS THEN SIGNAL(VERIFY$_ALLOCMEM, 0, .STATUS);
		CH$MOVE(
		    WDW_S_HEADER + WDW_K_MAXENTRY * WDW_S_ENTRY,
		    WINDOW,
		    .DYNWDW);
		IF .WINDOW_LIST[1] NEQ 0
		    THEN BBLOCK[.WINDOW_LIST[1], WDW_LINK] = .DYNWDW;
		IF .WINDOW_LIST[0] EQL 0 THEN WINDOW_LIST[0] = .DYNWDW;
		WINDOW_LIST[1] = .DYNWDW;
		WINDOW[WDW_LINK] = 0;
		WINDOW[WDW_SIZE] = 0;
		P = WINDOW + WDW_S_HEADER - WDW_S_ENTRY;
		END;


	    ! Generate new pointer.
	    !
	    WINDOW[WDW_SIZE] = .WINDOW[WDW_SIZE] + 1;
	    P = .P + WDW_S_ENTRY;
	    P[WDW_COUNT] = .COUNT;
	    P[WDW_LBN] = .LBN;
	    END;
	END;


    ! If no extension header exists, finish up.
    !
    IF
	BEGIN
	IF .STRUCTURE_LEVEL EQL 2
	THEN
	    .HEADER[FH2$W_EX_FIDNUM] EQL 0
	ELSE
	    BEGIN
	    MAP_POINTER = .HEADER + .HEADER[FH2$B_MPOFFSET]*2;
	    .MAP_POINTER[FM1$W_EX_FILNUM] EQL 0
	    END
	END
    THEN
	EXITLOOP;


    ! Get clean file number and RVN.
    !
    IF .STRUCTURE_LEVEL EQL 2
    THEN
	BEGIN
	EXT_FILE_ID[FID$W_NUM] = .HEADER[FH2$W_EX_FIDNUM];
	EXT_FILE_ID[FID$W_SEQ] = .HEADER[FH2$W_EX_FIDSEQ];
	EXT_FILE_ID[FID$W_RVN] = .HEADER[FH2$W_EX_FIDRVN];
	END
    ELSE
	BEGIN
	EXT_FILE_ID[FID$W_NUM] = .MAP_POINTER[FM1$W_EX_FILNUM];
	EXT_FILE_ID[FID$W_SEQ] = .MAP_POINTER[FM1$W_EX_FILSEQ];
	EXT_FILE_ID[FID$W_RVN] = 1;
	END;
    IF .EXT_FILE_ID[FID$B_RVN] EQL 0 THEN EXT_FILE_ID[FID$B_RVN] = .RVN;


    ! Set up header and RVN for next trip through loop.
    !
    HEADER = LOCAL_HEADER;
    RVN = .EXT_FILE_ID[FID$B_RVN];


    ! Read extension file header.  If this fails,
    ! exit the loop.
    !
    IF NOT READ_HEADER(EXT_FILE_ID, .HEADER)
    THEN
	EXITLOOP;
    END;


! Get dynamic window block for current window.
!
IF .WINDOW[WDW_SIZE] NEQ 0
THEN
    BEGIN
    LOCAL
	STATUS,		! Status return
	DYNWDW;		! Dynamic window pointer


    STATUS = LIB$GET_VM(
	%REF(WDW_S_HEADER + .WINDOW[WDW_SIZE] * WDW_S_ENTRY),
	DYNWDW);
    IF NOT .STATUS THEN SIGNAL(VERIFY$_ALLOCMEM, 0, .STATUS);
    CH$MOVE(
	WDW_S_HEADER + .WINDOW[WDW_SIZE] * WDW_S_ENTRY,
	WINDOW,
	.DYNWDW);
    IF .WINDOW_LIST[1] NEQ 0
	THEN BBLOCK[.WINDOW_LIST[1], WDW_LINK] = .DYNWDW;
    IF .WINDOW_LIST[0] EQL 0 THEN WINDOW_LIST[0] = .DYNWDW;
    END;


! Return a pointer to the first window block (if any).
!
.WINDOW_LIST[0]
END;

ROUTINE DELETE_WINDOW(WINDOW): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine deletes a window block (or blocks).
!
! INPUT PARAMETERS:
!	WINDOW		- Pointer to window block.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	Window blocks released.
!
!--

BEGIN
MAP
	WINDOW:		REF BBLOCK;	! Pointer to window block
LOCAL
	W:		REF BBLOCK;	! Pointer to window block


W = .WINDOW;
WHILE .W NEQ 0 DO
    BEGIN
    LOCAL
	NEXT:		REF BBLOCK,	! Pointer to next window block
	STATUS;				! Status return


    NEXT = .W[WDW_LINK];		! Point to next block
    STATUS = LIB$FREE_VM(		! Free current block
	%REF(WDW_S_HEADER + .W[WDW_SIZE] * WDW_S_ENTRY),
	W);
    IF NOT .STATUS THEN SIGNAL(VERIFY$_FREEMEM, 0, .STATUS);
    W = .NEXT;				! Advance to next block
    END;
END;

ROUTINE MAP_VIRTUAL(WINDOW,VBN,LBN)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine maps a virtual block number to a logical block number
!	using the specified window.
!
! INPUT PARAMETERS:
!	WINDOW		- Pointer to a window block.
!	VBN		- Virtual block number.
!	LBN		- Pointer to where logical block number is returned.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	SS$_NORMAL if translation is successful or SS$_ENDOFFILE if the
!	specified virtual block is not within the file.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	W:		REF BBLOCK,	! Pointer to window block
	P:		REF BBLOCK,	! Pointer to window block entry
	N;				! VBN mapped so far


! The virtual block number must not be 0.
!
IF .VBN EQL 0
THEN
    RETURN SS$_ENDOFFILE;


! Loop over the window blocks.
!
W = .WINDOW;
N = 1;
WHILE .W NEQ 0 DO
    BEGIN
    P = .W + WDW_S_HEADER;


    ! Loop over the entries within the window block.
    !
    DECR I FROM .W[WDW_SIZE] TO 1 DO
	BEGIN

	! If this entry maps the specified VBN, compute the LBN and return.
	!
	IF .VBN GEQU .N AND .VBN LSSU .N + .P[WDW_COUNT]
	THEN
	    BEGIN
	    .LBN = .P[WDW_LBN] + .VBN - .N;
	    RETURN SS$_NORMAL;
	    END;


	! Advance to next entry.
	!
	N = .N + .P[WDW_COUNT];
	P = .P + WDW_S_ENTRY;
	END;


    ! Advance to next window block.
    !
    W = .W[WDW_LINK];
    END;


! There were not enough mapping pointers to advance to the specified virtual
! block number.  Therefore, return SS$_ENDOFFILE.
!
SS$_ENDOFFILE
END;

ROUTINE ACCESS_INDEX_2(RVN): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine accesses an index file on the second channel.  If the
!	second channel had an index file accessed, it is first deaccessed.
!
! INPUT PARAMETERS:
!	RVN		- Relative volume number.  If zero, no new index file
!			  is accessed, but a previous one is deaccessed.
!
! IMPLICIT INPUTS:
!	CHAN2_RVN	- RVN on which index file is currently accessed on
!			  the second channel.  If zero, none is currently
!			  accessed.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	CHAN2_RVN	- Updated to equal RVN.
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	If RVN is nonzero, index file on specified RVN accessed on second
!	channel.
!
!--

BEGIN
LOCAL
	STATUS;			! Status variable


IF .RVN NEQ .CHAN2_RVN
THEN
    BEGIN

    ! If an index file is currently accessed on the second channel,
    ! deaccess it.
    !
    IF .CHAN2_RVN NEQ 0
    THEN
	$QIOW(
	    FUNC=IO$_DEACCESS,
	    CHAN=.CHANNEL_2);


    ! If a new index file is to be accessed, access it.
    !
    IF .RVN NEQ 0
    THEN
	BEGIN
	CH$FILL(0, FIB$C_LENGTH, FIB);
	FIB[FIB$L_ACCTL] = .ACCTL[.RVN-1];
	FIB[FIB$W_FID_NUM] = FID$C_INDEXF;
	FIB[FIB$W_FID_SEQ] = FID$C_INDEXF;
	FIB[FIB$W_FID_RVN] = .RVN;
	STATUS = $QIOW(
	    FUNC=IO$_ACCESS OR IO$M_ACCESS,
	    CHAN=.CHANNEL_2,
	    IOSB=IOSB,
	    P1=FIB_DESC);
	IF .STATUS THEN STATUS = .IOSB[0];
	IF NOT .STATUS THEN SIGNAL(VERIFY$_OPENINDEX, 1, .RVN, .STATUS);
	END;


    ! Update the status variable.
    !
    CHAN2_RVN = .RVN;
    END;
END;

ROUTINE COUNT_QUOTA(UIC,QBLOCKS,IBLOCKS): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine maintains the quota data base.
!
! INPUT PARAMETERS:
!	UIC		- UIC to be updated.
!	QBLOCKS		- Blocks to be added to amount used (per quota file)
!	IBLOCKS		- Blocks to be added to amount used (per index file)
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	STATUS,				! Status variable
	T:		REF BBLOCK,	! Pointer to table segment
	E:		REF BBLOCK,	! Pointer to table entry
	J;				! Index of table entry


T = QT;
J = -1;
CASE
    BEGIN
    WHILE 1 DO
	BEGIN
	IF .J GTRU .T[QT_COUNT]			! More entries?
	THEN					! No more entries
	    IF .T[QT_LINK] EQL 0		! More blocks?
	    THEN				! No more blocks
		IF .T[QT_COUNT] EQL QT_MAXCOUNT	! More space?
		THEN				! No more space
		    EXITLOOP 1			! Add new block
		ELSE				! More space
		    EXITLOOP -1			! Use existing space
	    ELSE				! More blocks
		BEGIN
		T = .T[QT_LINK];		! Point to next block
		E = .T + QT_S_HDR;		! Point to first entry
		J = 1;				! Count first entry
		END
	ELSE					! More entries
	    IF .E[QT_UIC] EQL .UIC		! Correct entry?
	    THEN
		EXITLOOP 0			! Update existing entry
	    ELSE
		BEGIN
		E = .E + QT_S_ENT;		! Point to next entry
		J = .J + 1;			! Count next entry
		END
	END
    END
FROM -1 TO 1 OF
    SET

    [-1]:
	BEGIN
	!
	! Add new entry.  E points to space where it can be added, T points
	! to table segment.
	!
	T[QT_COUNT] = .T[QT_COUNT] + 1;
	E[QT_UIC] = .UIC;
	E[QT_QUO_USED] = .QBLOCKS;
	E[QT_IDX_USED] = .IBLOCKS;
	END;

    [0]:
	BEGIN
	!
	! Update existing entry.  E points to the entry.
	!
	E[QT_QUO_USED] = .E[QT_QUO_USED] + .QBLOCKS;
	E[QT_IDX_USED] = .E[QT_IDX_USED] + .IBLOCKS;
	END;

    [1]:
	BEGIN
	!
	! Add new table segment.  T points to existing table segment.
	!
	STATUS = LIB$GET_VM(
	    UPLIT(QT_S_HDR + QT_MAXCOUNT*QT_S_ENT),
	    T[QT_LINK]);
	IF NOT .STATUS THEN SIGNAL(VERIFY$_ALLOCMEM, 0, .STATUS);
	T = .T[QT_LINK];
	T[QT_LINK] = 0;
	T[QT_COUNT] = 1;
	E = .T + QT_S_HDR;
	E[QT_UIC] = .UIC;
	E[QT_QUO_USED] = .QBLOCKS;
	E[QT_IDX_USED] = .IBLOCKS;
	END;

    TES;
END;

ROUTINE READ_HEADER(FILE_ID,BUFFER)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine reads one file header into the specified buffer.
!
! INPUT PARAMETERS:
!	FILE_ID		- File ID of header to be read.
!	BUFFER		- Pointer to buffer.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	True if header successfully read, false otherwise.
!
! SIDE EFFECTS:
!	Header read into buffer.
!
!--

BEGIN
MAP
	FILE_ID:	REF BBLOCK,	! Pointer to file ID
	BUFFER:		REF BBLOCK;	! Pointer to header
LOCAL
	STATUS,				! Status variable
	FILE_NUMBER,			! Clean file number
	RVN;				! Clean RVN


! Get a clean file number and RVN and validity check.  If failure,
! return failure.
!
FILE_NUMBER = .FILE_ID[FID$W_NUM];
FILE_NUMBER<16,8> = .FILE_ID[FID$B_NMX];
RVN = .FILE_ID[FID$B_RVN];
IF .RVN GTRU .VOLUME_COUNT THEN RETURN FALSE;
IF .FILE_NUMBER-1 GTRU .MAXFILIDX[.RVN-1] THEN RETURN FALSE;


! Access index file on appropriate volume.
!
ACCESS_INDEX_2(.RVN);


! Read the header.
!
STATUS = $QIOW(
    FUNC=IO$_READVBLK,
    CHAN=.CHANNEL_2,
    IOSB=IOSB,
    P1=.BUFFER,
    P2=512,
    P3=.FILE_NUMBER + .HEADER_OFFSET[.RVN-1]);
IF .STATUS THEN STATUS = .IOSB[0];


! If failure, report it and return failure.
!
IF NOT .STATUS
THEN
    BEGIN
    HEADER_ERROR(VERIFY$_READHEADER, .FILE_ID, .BUFFER, .STATUS);
    RETURN FALSE;
    END;


! Verify the header that was read.
!
STATUS = VERIFY_HEADER(.BUFFER, .FILE_ID);
IF NOT .STATUS
THEN
    HEADER_ERROR(VERIFY$_BADHEADER, .FILE_ID, .BUFFER);


! Return status of header.
!
.STATUS
END;

ROUTINE WRITE_HEADER(FILE_ID,BUFFER)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine writes one file header from the specified buffer.
!
! INPUT PARAMETERS:
!	FILE_ID		- File ID of header to be written.
!	BUFFER		- Pointer to buffer.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status.
!
! SIDE EFFECTS:
!	Header written from buffer.
!
!--

BEGIN
MAP
	FILE_ID:	REF BBLOCK,	! Pointer to file ID
	BUFFER:		REF BBLOCK;	! Pointer to header
LOCAL
	STATUS,				! Status variable
	FILE_NUMBER,			! Clean file number
	RVN;				! Clean RVN


! Get a clean file number and RVN and validity check.  If failure,
! do nothing.
!
FILE_NUMBER = .FILE_ID[FID$W_NUM];
FILE_NUMBER<16,8> = .FILE_ID[FID$B_NMX];
RVN = .FILE_ID[FID$B_RVN];
IF .RVN GTRU .VOLUME_COUNT THEN RETURN 0;
IF .FILE_NUMBER-1 GTRU .MAXFILIDX[.RVN-1] THEN RETURN 0;


! Recompute the checksum.
!
CHECKSUM(.BUFFER);


! Access the index file on the appropriate volume.
!
ACCESS_INDEX_2(.RVN);


! Write the block.
!
STATUS = $QIOW(
    FUNC=IO$_WRITEVBLK,
    CHAN=.CHANNEL_2,
    IOSB=IOSB,
    P1=.BUFFER,
    P2=512,
    P3=.FILE_NUMBER + .HEADER_OFFSET[.RVN-1]);
IF .STATUS THEN STATUS = .IOSB[0];


! If failure, report it.
!
IF NOT .STATUS
THEN
    HEADER_ERROR(VERIFY$_WRITEHEADER, .FILE_ID, .BUFFER, .STATUS);


! Return the completion status.
!
.STATUS
END;

ROUTINE DELETE_HEADER(FILE_ID,HEADER): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine writes a deleted file header.
!
! INPUT PARAMETERS:
!	FILE_ID		- File ID of the header.
!	HEADER		- Pointer to file header.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	File header written.
!
!--

BEGIN
MAP
	FILE_ID:	REF BBLOCK,	! Pointer to file ID
	HEADER:		REF BBLOCK;	! Pointer to file header
LOCAL
	FILE_NUMBER,			! File number from file ID
	RVN;				! RVN from file ID


! Completely reinitialize the header if it is invalid.  Otherwise, use the
! old copy to preserve the file sequence numbering.
!
IF VERIFY_HEADER(.HEADER, .FILE_ID) EQL 0
THEN
    BEGIN
    CH$FILL(0, 512, .HEADER);
    HEADER[FH2$B_STRUCVER] = 1;
    HEADER[FH2$B_STRUCLEV] = .STRUCTURE_LEVEL;
    IF .STRUCTURE_LEVEL EQL 2
	THEN HEADER[FH2$W_FID_SEQ] = .CURRENT_TIME<16,16>
	ELSE HEADER[FH1$W_FID_SEQ] = .CURRENT_TIME<16,16>;
    END;


! Initialize the header as a valid deleted header.
!
IF .STRUCTURE_LEVEL EQL 2
THEN
    BEGIN
    HEADER[FH2$B_IDOFFSET] = FH2$C_LENGTH / 2;
    HEADER[FH2$B_MPOFFSET] = (FH2$C_LENGTH + FI2$C_LENGTH) / 2;
    HEADER[FH2$B_ACOFFSET] = $BYTEOFFSET (FH2$W_CHECKSUM) / 2;
    HEADER[FH2$B_RSOFFSET] = $BYTEOFFSET (FH2$W_CHECKSUM) / 2;
    HEADER[FH2$W_FID_SEQ] = .HEADER[FH2$W_FID_SEQ] + 1;
    HEADER[FH2$W_FID_NUM] = 0;
    HEADER[FH2$W_FID_RVN] = 0;
    HEADER[FH2$W_CHECKSUM] = 0;
    END
ELSE
    BEGIN
    HEADER[FH1$B_IDOFFSET] = FH1$C_LENGTH / 2;
    HEADER[FH1$B_MPOFFSET] = (FH1$C_LENGTH + FI1$C_LENGTH) / 2;
    HEADER[FH1$W_FID_SEQ] = .HEADER[FH1$W_FID_SEQ] + 1;
    HEADER[FH1$W_FID_NUM] = 0;
    HEADER[FH1$W_CHECKSUM] = 0;
    END;


! Write the new header, and clear the corresponding index file bitmap bit if
! the write is successful.
!
IF WRITE_HEADER(.FILE_ID, .HEADER)
THEN
    BEGIN
    FILE_NUMBER = .FILE_ID[FID$W_NUM];
    FILE_NUMBER<16,8> = .FILE_ID[FID$B_NMX];
    RVN = .FILE_ID[FID$B_RVN];
    BITVECTOR[.IMAP[.RVN-1], .FILE_NUMBER-1] = FALSE;
    END;
END;

ROUTINE CLEAR_EXT_FID(FILE_ID,HEADER): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine clears the extension linkage in the specified header.
!
! INPUT PARAMETERS:
!	FILE_ID		- File ID of the header.
!	HEADER		- Pointer to file header.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	File header written.
!
!--

BEGIN
MAP
	FILE_ID:	REF BBLOCK,	! Pointer to file ID
	HEADER:		REF BBLOCK;	! Pointer to file header
LOCAL
	MAP_AREA:	REF BBLOCK;	! Pointer to map area


! Clear the extension linkage.
!
IF .STRUCTURE_LEVEL EQL 2
THEN
    BEGIN
    HEADER[FH2$W_EX_FIDNUM] = 0;
    HEADER[FH2$W_EX_FIDSEQ] = 0;
    HEADER[FH2$W_EX_FIDRVN] = 0;
    END
ELSE
    BEGIN
    MAP_AREA = .HEADER + .HEADER[FH1$B_MPOFFSET]*2;
    MAP_AREA[FM1$W_EX_FILNUM] = 0;
    MAP_AREA[FM1$W_EX_FILSEQ] = 0;
    END;


! Rewrite the header.
!
WRITE_HEADER(.FILE_ID, .HEADER);
END;

ROUTINE READ_CHECK(FILE_ID,HEADER): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine read-checks the indicated file.
!
! INPUT PARAMETERS:
!	FILE_ID		- File ID of the file.
!	HEADER		- Header for the file.
!
! IMPLICIT INPUTS:
!	TOTAL_SIZE	- Size of the file, determined from map area.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	All allocated blocks of the file read and errors reported.
!
!--

BEGIN
MAP
	FILE_ID:	REF BBLOCK,	! Pointer to file ID
	HEADER:		REF BBLOCK;	! Pointer to file header
LOCAL
	BUFFER_SIZE,			! Size of file buffer
	BUFFER_ADDRESS,			! Address of file buffer
	VBN,				! Current VBN
	STATUS;				! Status variable


! If file size is zero, there is nothing to do.
!
IF .TOTAL_SIZE EQL 0 THEN RETURN;


! Access the file being read-checked.  Call ACCESS_INDEX_2 to deaccess the
! second channel in case it is being used.  If the access fails, report it
! and quit.
!
ACCESS_INDEX_2(0);
CH$FILL(0, FIB$C_LENGTH, FIB);
FIB[FIB$L_ACCTL] = FIB$M_NORECORD;
FIB[FIB$W_FID_NUM] = .FILE_ID[FID$W_NUM];
FIB[FIB$W_FID_SEQ] = .FILE_ID[FID$W_SEQ];
FIB[FIB$W_FID_RVN] = .FILE_ID[FID$W_RVN];
STATUS = $QIOW(
    FUNC=IO$_ACCESS OR IO$M_ACCESS,
    CHAN=.CHANNEL_2,
    IOSB=IOSB,
    P1=FIB_DESC);
IF .STATUS THEN STATUS = .IOSB[0];
IF NOT .STATUS
THEN
    BEGIN
    HEADER_ERROR(VERIFY$_OPENFILE, .FILE_ID, .HEADER, .STATUS);
    RETURN;
    END;


! Allocate the buffer.  Use the size of the file, thresholded by
! FILE_BUF_COUNT.
!
BUFFER_SIZE = MINU(FILE_BUF_COUNT, .TOTAL_SIZE);
STATUS = LIB$GET_VM(%REF(.BUFFER_SIZE * 512), BUFFER_ADDRESS);
IF NOT .STATUS THEN SIGNAL(VERIFY$_ALLOCMEM, 0, .STATUS);


! Loop over all blocks of the file.
!
VBN = 1;
WHILE .VBN LEQU .TOTAL_SIZE DO
    BEGIN
    LOCAL
	THIS_BLOCKS;	! Count of blocks to read on current iteration


    ! Compute how many blocks to read on this iteration and read them.
    !
    THIS_BLOCKS = MINU(.BUFFER_SIZE, .TOTAL_SIZE + 1 - .VBN);
    STATUS = $QIOW(
	FUNC=IO$_READVBLK,
	CHAN=.CHANNEL_2,
	IOSB=IOSB,
	P1=.BUFFER_ADDRESS,
	P2=.THIS_BLOCKS * 512,
	P3=.VBN);
    IF .STATUS THEN STATUS = .IOSB[0];


    ! If an error occurred, read each block individually, reporting errors
    ! as we go.
    !
    IF NOT .STATUS
    THEN
	BEGIN
	INCR XVBN FROM 0 TO .THIS_BLOCKS-1 DO
	    BEGIN
	    STATUS = $QIOW(
		FUNC=IO$_READVBLK,
		CHAN=.CHANNEL_2,
		IOSB=IOSB,
		P1=.BUFFER_ADDRESS,
		P2=512,
		P3=.VBN + .XVBN);
	    IF .STATUS THEN STATUS = .IOSB[0];
	    IF NOT .STATUS
	    THEN
		HEADER_ERROR(
		    VERIFY$_READFILE,
		    .FILE_ID, .HEADER,
		    .VBN + .XVBN, .STATUS);
	    END;
	END;
    VBN = .VBN + .THIS_BLOCKS;
    END;


! Free the buffer.
!
STATUS = LIB$FREE_VM(%REF(.BUFFER_SIZE * 512), BUFFER_ADDRESS);
IF NOT .STATUS THEN SIGNAL(VERIFY$_FREEMEM, 0, .STATUS);


! Deaccess the file being read-checked.
!
$QIOW(
    FUNC=IO$_DEACCESS,
    CHAN=.CHANNEL_2);
END;

ROUTINE FILE_ERROR(MESSAGE,FAB,EXTRA1,EXTRA2): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine signals a file-related message.
!
! INPUT PARAMETERS:
!	MESSAGE		- Message code for first message
!	FAB		- Pointer to FAB, from which file name
!			  will be obtained
!	Up to two additional input parameters are additional messages --
!	except if the message is one of the special cases, they are
!	additional FAO arguments.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	The messages are signalled.
!
!--

BEGIN
MAP
	FAB:		REF BBLOCK;	! Pointer to FAB
LOCAL
	NAM:		REF BBLOCK,	! Pointer to NAM block
	DESC:		BBLOCK[8],	! Descriptor for signal
	PARAM:		VECTOR[6];	! Signal parameter list
BUILTIN
	ACTUALCOUNT;


NAM = .FAB[FAB$L_NAM];
DESC[DSC$B_DTYPE] = 0;
DESC[DSC$B_CLASS] = 0;
IF .NAM[NAM$B_RSL] NEQ 0
THEN
    BEGIN
    DESC[DSC$W_LENGTH] = .NAM[NAM$B_RSL];
    DESC[DSC$A_POINTER] = .NAM[NAM$L_RSA];
    END
ELSE IF .NAM[NAM$B_ESL] NEQ 0
THEN
    BEGIN
    DESC[DSC$W_LENGTH] = .NAM[NAM$B_ESL];
    DESC[DSC$A_POINTER] = .NAM[NAM$L_ESA];
    END
ELSE
    BEGIN
    DESC[DSC$W_LENGTH] = .FAB[FAB$B_FNS];
    DESC[DSC$A_POINTER] = .FAB[FAB$L_FNA];
    END;


PARAM[0] = 3;
PARAM[1] = .MESSAGE;
PARAM[2] = 1;
PARAM[3] = DESC;
IF ACTUALCOUNT() GEQ 3
THEN
    BEGIN
    PARAM[0] = .PARAM[0] + 1;
    PARAM[4] = .EXTRA1;
    END;
IF ACTUALCOUNT() GEQ 4
THEN
    BEGIN
    PARAM[0] = .PARAM[0] + 1;
    PARAM[5] = .EXTRA2;
    END;


CALLG(PARAM, LIB$SIGNAL);
END;

ROUTINE HEADER_ERROR(MESSAGE,FILE_ID,HEADER,EXTRA1,EXTRA2,EXTRA3,EXTRA4,EXTRA5): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine signals a header-related message.
!
! INPUT PARAMETERS:
!	MESSAGE		- Message code for first message
!	FILE_ID		- Pointer to file ID
!	HEADER		- Pointer to header in memory or zero if not
!	EXTRA...	- Extra parameters, depending on message
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	The message is signalled.
!
!--

BEGIN
MAP
	FILE_ID:	REF BBLOCK;		! Pointer to file ID
LOCAL
	FILENAME:	VECTOR[FI2$S_FILENAME,BYTE],	! Buffer for ASCII filename
	PARAM:		VECTOR[13],		! Signal parameters
	BUFFER:		BBLOCK[512],		! Header buffer
	HDR:		REF BBLOCK;		! Pointer to good header


! Initialize the beginning of the signal vector.
!
PARAM[0] = 7;
PARAM[1] = .MESSAGE;
PARAM[2] = 5;
PARAM[3] = .FILE_ID[FID$W_NUM] + .FILE_ID[FID$B_NMX] ^ 16;
PARAM[4] = .FILE_ID[FID$W_SEQ];
PARAM[5] = .FILE_ID[FID$B_RVN];


! Get the file name.  If no header was passed, read the header.
! If reading the header fails, use a null string.
!
IF
    BEGIN
    HDR = .HEADER;
    IF .HDR EQL 0
    THEN
	BEGIN
	HDR = BUFFER;
	READ_HEADER(.FILE_ID, .HDR)
	END
    ELSE
	TRUE
    END
THEN
    BEGIN
    LOCAL
	IDENT_AREA:	REF BBLOCK;	! Pointer to ident area

    IDENT_AREA = .HDR + .HDR[FH2$B_IDOFFSET]*2;
    IF .STRUCTURE_LEVEL EQL 2
    THEN
	BEGIN
	PARAM[6] = FI2$S_FILENAME;
	PARAM[7] = IDENT_AREA[FI2$T_FILENAME];
	END
    ELSE
	BEGIN
	PARAM[6] = MAKE_STRING(
	    IDENT_AREA[FI1$W_FILENAME] - $BYTEOFFSET(NMB$W_NAME),
	    FILENAME);
	PARAM[7] = FILENAME;
	END;
    END
ELSE
    BEGIN
    PARAM[6] = 0;
    PARAM[7] = .HDR;
    END;


! Handle a variety of special cases for the message code.
!
IF
    .MESSAGE EQL VERIFY$_READHEADER OR
    .MESSAGE EQL VERIFY$_WRITEHEADER OR
    .MESSAGE EQL VERIFY$_OPENFILE OR
    .MESSAGE EQL VERIFY$_ENTERLOST OR
    .MESSAGE EQL VERIFY$_DELETE
THEN
    BEGIN
    PARAM[0] = 8;
    PARAM[8] = .EXTRA1;
    END
ELSE IF
    .MESSAGE EQL VERIFY$_READFILE
THEN
    BEGIN
    PARAM[0] = 9;
    PARAM[2] = 6;
    PARAM[8] = .EXTRA1;
    PARAM[9] = .EXTRA2;
    END
ELSE IF
    .MESSAGE EQL VERIFY$_MULTALLOC
THEN
    BEGIN
    PARAM[0] = 12;
    PARAM[2] = 10;
    PARAM[8] = .EXTRA1;
    PARAM[9] = .EXTRA2;
    PARAM[10] = .EXTRA3;
    PARAM[11] = .EXTRA4;
    PARAM[12] = .EXTRA5;
    END;


! Finally, signal the message.
!
CALLG(PARAM, LIB$SIGNAL);
END;

ROUTINE PROCESS_FILE(NAME,VERSION)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes one selected file.
!
! INPUT PARAMETERS:
!	NAME		- Pointer to ASCIC name string from directory entry.
!	VERSION		- Pointer to version entry.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	True if the directory entry points to a valid file, otherwise false.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	NAME:		REF VECTOR[,BYTE],	! Pointer to ASCIC name string
	VERSION:	REF BBLOCK;		! Pointer to version entry
LOCAL
	FILE_ID:	BBLOCK[FID$C_LENGTH],	! Clean file ID
	FILE_NUMBER,				! Clean file number
	RVN;					! Clean RVN


! Get clean file ID.
!
FILE_NUMBER = .VERSION[DIR$W_FID_NUM];
FILE_NUMBER<16,8> = .VERSION[DIR$B_FID_NMX];
RVN = .VERSION[DIR$B_FID_RVN];
IF .RVN EQL 0 THEN RVN = .DIR_FID[FID$B_RVN];
FILE_ID[FID$W_NUM] = .FILE_NUMBER;
FILE_ID[FID$B_NMX] = .FILE_NUMBER<16,8>;
FILE_ID[FID$W_SEQ] = .VERSION[DIR$W_FID_SEQ];
FILE_ID[FID$B_RVN] = .RVN;


! Check file ID.  First, make sure the RVN is in range.  Then, make sure the
! file number is in range.  Then, make sure the file number corresponds to a
! valid header.  Then, make sure the file sequence number matches that in the
! file header.
!
IF
    BEGIN
    IF .RVN GTRU .VOLUME_COUNT
    THEN
	TRUE
    ELSE IF .FILE_NUMBER-1 GTRU .MAXFILIDX[.RVN-1]
    THEN
	TRUE
    ELSE IF NOT .BITVECTOR[.IMAP[.RVN-1], .FILE_NUMBER-1]
    THEN
	TRUE
    ELSE
	.VECTOR[.SEQMAP[.RVN-1], .FILE_NUMBER-1 ;,WORD] NEQ .VERSION[DIR$W_FID_SEQ]
    END
THEN
    BEGIN

    ! Invalid file ID.  Report it, and return failure.
    !
    SIGNAL(
	VERIFY$_BADDIRENT,
	3,
	(IF .DIR_DESC[0] EQL 0 THEN MFD_DESC ELSE DIR_DESC),
	.NAME,
	.VERSION[DIR$W_VERSION]);
    IF DO_REPAIR()
    THEN
	ENTER_WORK(WRK_K_REMOVE, FILE_ID, DIR_FID);
    FALSE
    END
ELSE
    BEGIN

    ! Check the back link.
    !
    IF .STRUCTURE_LEVEL EQL 2
    THEN
	BEGIN
	LOCAL
	    BACK_ID:	REF BBLOCK;


	BACK_ID = VECTOR[.BACKMAP[.RVN-1], (.FILE_NUMBER-1)*3 ;,WORD];


	! Compare the back link recorded in the file header to the current
	! directory file ID.  Note that BACKMAP has clean RVNs.
	!
	IF
	    .BACK_ID[FID$W_NUM] NEQ .DIR_FID[FID$W_NUM] OR
	    .BACK_ID[FID$W_SEQ] NEQ .DIR_FID[FID$W_SEQ] OR
	    .BACK_ID[FID$W_RVN] NEQ .DIR_FID[FID$W_RVN]
	THEN
	    BEGIN

	    ! Report incorrect back link.
	    !
	    SIGNAL(
		VERIFY$_BACKLINK,
		3,
		(IF .DIR_DESC[0] EQL 0 THEN MFD_DESC ELSE DIR_DESC),
		.NAME,
		.VERSION[DIR$W_VERSION]);


	    ! Fix the incorrect back link.
	    !
	    IF DO_REPAIR() THEN IF READ_HEADER(FILE_ID, BUFFER_2)
	    THEN
		BEGIN
		BUFFER_2[FH2$W_BK_FIDNUM] = .DIR_FID[FID$W_NUM];
		BUFFER_2[FH2$W_BK_FIDSEQ] = .DIR_FID[FID$W_SEQ];
		BUFFER_2[FH2$W_BK_FIDRVN] = .DIR_FID[FID$W_RVN];
		IF .DIR_FID[FID$B_RVN] EQL .RVN THEN BUFFER_2[FH2$B_BK_FIDRVN] = 0;
		WRITE_HEADER(FILE_ID, BUFFER_2);
		END;
	    END;
	END;


    ! Generate usage file entry if requested and if this is the first time
    ! this file has been encountered in the directory scan.
    !
    IF .QUAL[QUAL_USAG] AND .BITVECTOR[.LOSTMAP[.RVN-1], .FILE_NUMBER-1]
    THEN
	BEGIN
	USAGE_BUFFER[USG$B_TYPE] = USG$K_FILE;
	USAGE_BUFFER[USG$L_FILEOWNER] = .VECTOR[.OWNER[.RVN-1], .FILE_NUMBER-1];
	USAGE_BUFFER[USG$L_ALLOCATED] = .VECTOR[.ALLOCATION[.RVN-1], .FILE_NUMBER-1];
	USAGE_BUFFER[USG$L_USED] = .VECTOR[.USAGE[.RVN-1], .FILE_NUMBER-1];
	USAGE_BUFFER[USG$W_DIR_LEN] =
	    (IF .DIR_DESC[0] EQL 0 THEN 8 ELSE .DIR_DESC[0] + 2);
	$FAO(
	    $DESCRIPTOR('[!AS]!AC;!UW'),
	    USAGE_BUFFER[USG$W_SPEC_LEN],
	    UPLIT(NAM$C_MAXRSS, USAGE_BUFFER[USG$T_FILESPEC]),
	    (IF .DIR_DESC[0] EQL 0 THEN MFD_DESC ELSE DIR_DESC),
	    .NAME,
	    .VERSION[DIR$W_VERSION]);
	USAGE_RAB[RAB$W_RSZ] = $BYTEOFFSET(USG$T_FILESPEC) + .USAGE_BUFFER[USG$W_SPEC_LEN];
	IF NOT $PUT(RAB=USAGE_RAB)
	THEN
	    FILE_ERROR(
		VERIFY$_FACILITY + SHR$_WRITEERR + STS$K_SEVERE,
		USAGE_FAB,
		.USAGE_RAB[RAB$L_STS], .USAGE_RAB[RAB$L_STV]);
	END;


    ! Mark the file as found in a directory.
    !
    BITVECTOR[.LOSTMAP[.RVN-1], .FILE_NUMBER-1] = FALSE;
    TRUE
    END
END;

ROUTINE PROCESS_SUBDIR(NAME,VERSION): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes one subdirectory entry.
!
! INPUT PARAMETERS:
!	NAME		- Pointer to ASCIC name string from directory entry.
!	VERSION		- Pointer to version entry.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	NAME:		REF VECTOR[,BYTE],	! Pointer to ASCIC name string
	VERSION:	REF BBLOCK;		! Pointer to version entry
LOCAL
	SAVE_DIR_DESC,				! Recursive save for directory string length
	SAVE_DIR_FID:	BBLOCK[FID$C_LENGTH],	! Recursive save area for directory file ID
	STATUS,					! Status variable
	DIR_LENGTH,				! Length of directory
	BUF_LENGTH,				! Length of buffer for directory
	BUF_ADDRESS;				! Address of buffer for directory


! Save recursive variables.
!
SAVE_DIR_DESC = .DIR_DESC[0];
SAVE_DIR_FID[FID$W_NUM] = .DIR_FID[FID$W_NUM];
SAVE_DIR_FID[FID$W_SEQ] = .DIR_FID[FID$W_SEQ];
SAVE_DIR_FID[FID$W_RVN] = .DIR_FID[FID$W_RVN];


! Update the directory descriptor, unless NAME is zero, which indicates MFD.
! If this is not the top level, append a dot, and then append the directory
! name, up to but not including the dot.
!
IF .NAME NEQ 0
THEN
    BEGIN
    IF .DIR_DESC[0] NEQ 0
    THEN
	BEGIN
	DIR[.DIR_DESC[0]] = %C'.';
	DIR_DESC[0] = .DIR_DESC[0] + 1;
	END;
    DIR_DESC[0] = CH$MOVE(
	CH$FIND_CH(
	    .NAME[0], NAME[1], %C'.') - NAME[1],
	    NAME[1],
	    DIR[.DIR_DESC[0]])
	- .DIR_DESC[1];
    END;


! Access the file.
!
CH$FILL(0, FIB$C_LENGTH, FIB);
FIB[FIB$L_ACCTL] = FIB$M_NORECORD;
FIB[FIB$W_FID_NUM] = .VERSION[DIR$W_FID_NUM];
FIB[FIB$W_FID_SEQ] = .VERSION[DIR$W_FID_SEQ];
FIB[FIB$W_FID_RVN] = .VERSION[DIR$W_FID_RVN];
IF .FIB[FIB$B_FID_RVN] EQL 0 THEN FIB[FIB$B_FID_RVN] = .DIR_FID[FID$B_RVN];
DIR_FID[FID$W_NUM] = .FIB[FIB$W_FID_NUM];
DIR_FID[FID$W_SEQ] = .FIB[FIB$W_FID_SEQ];
DIR_FID[FID$W_RVN] = .FIB[FIB$W_FID_RVN];
STATUS = $QIOW(
    FUNC=IO$_ACCESS OR IO$M_ACCESS,
    CHAN=.CHANNEL,
    IOSB=IOSB,
    P1=FIB_DESC,
    P5=HDR_ATR_DESC);
IF .STATUS THEN STATUS = .IOSB[0];
IF NOT .STATUS
THEN
    BEGIN

    ! Report failure to access the directory, and set the error flag to
    ! abort lost file processing.
    !
    DIRECTORY_ERROR = TRUE;
    SIGNAL(
	VERIFY$_OPENDIR,
	1,
	(IF .DIR_DESC[0] EQL 0 THEN MFD_DESC ELSE DIR_DESC),
	.STATUS);
    END
ELSE
    BEGIN

    ! Ensure that the file is, in fact, a directory.  At this point we know
    ! only that the filename is ".DIR;1".  Use the file header that was
    ! obtained during the access.  Compute the file length if valid.
    ! If invalid, leave the file length zero to avoid processing the file.
    !
    DIR_LENGTH = 0;
    IF .HDR_BUFFER[FH2$B_STRUCLEV] EQL 2
    THEN
	BEGIN
	BIND
	    RECATTR=	HDR_BUFFER[FH2$W_RECATTR]: BBLOCK;

	IF .HDR_BUFFER[FH2$V_DIRECTORY]
	THEN
	    BEGIN
	    DIR_LENGTH = ROT(.RECATTR[FAT$L_EFBLK], 16) * 512;
	    IF .RECATTR[FAT$W_FFBYTE] EQL 0 THEN DIR_LENGTH = .DIR_LENGTH - 512;
	    END;
	END
    ELSE
	BEGIN
	BIND
	    RECATTR=	HDR_BUFFER[FH1$W_RECATTR]: BBLOCK;

	IF
	    .RECATTR[FAT$B_RTYPE] EQL FAT$C_FIXED AND
	    .RECATTR[FAT$W_RSIZE] EQL NMB$C_DIRENTRY
	THEN
	    BEGIN
	    DIR_LENGTH = ROT(.RECATTR[FAT$L_EFBLK], 16) * 512;
	    IF .RECATTR[FAT$W_FFBYTE] EQL 0 THEN DIR_LENGTH = .DIR_LENGTH - 512;
	    END;
	END;


    ! Check for proper end of file pointer.
    !
    IF
	.DIR_LENGTH LSS 0 OR
	(.DIR_LENGTH EQL 0 AND .HDR_BUFFER[FH2$B_STRUCLEV] EQL 2)
    THEN
	BEGIN
	DIRECTORY_ERROR = TRUE;
	SIGNAL(
	    VERIFY$_BADDIR,
	    1,
	    (IF .DIR_DESC[0] EQL 0 THEN MFD_DESC ELSE DIR_DESC));
	DIR_LENGTH = 0;
	END;


    IF .DIR_LENGTH NEQ 0
    THEN
	BEGIN
	LOCAL
	    READ_VBN;


	! Compute buffer length.  Try to read the entire directory at 
	! one time, but no more than DIR_BUF_COUNT blocks.
	!
	BUF_LENGTH = MINU(DIR_BUF_COUNT*512, .DIR_LENGTH);


	! Allocate memory for buffer.
	!
	STATUS = LIB$GET_VM(BUF_LENGTH, BUF_ADDRESS);
	IF NOT .STATUS THEN SIGNAL(VERIFY$_ALLOCMEM, 0, .STATUS);


	! Loop to process all blocks.
	!
	READ_VBN = 1;
	WHILE 1 DO
	    BEGIN
	    LOCAL
		PROC_LENGTH;


	    ! Compute transfer size.
	    !
	    PROC_LENGTH = MINU(.BUF_LENGTH, (.DIR_LENGTH/512 - .READ_VBN + 1)*512);


	    ! Read the blocks.
	    !
	    STATUS = $QIOW(
		FUNC=IO$_READVBLK,
		CHAN=.CHANNEL,
		IOSB=IOSB,
		P1=.BUF_ADDRESS,
		P2=.PROC_LENGTH,
		P3=.READ_VBN);
	    IF .STATUS THEN STATUS = .IOSB[0];
	    IF NOT .STATUS
	    THEN
		SIGNAL(
		    VERIFY$_READDIR,
		    1,
		    (IF .DIR_DESC[0] EQL 0 THEN MFD_DESC ELSE DIR_DESC),
		    .STATUS);


	    ! Deaccess the file.
	    !
	    $QIOW(
		FUNC=IO$_DEACCESS,
		CHAN=.CHANNEL);


	    ! Scan directory, if there was no error in the read.
	    !
	    IF .STATUS
	    THEN
		BEGIN
		(IF .STRUCTURE_LEVEL EQL 2
		    THEN SCAN_DIRECT_2
		    ELSE SCAN_DIRECT_1)
		(.PROC_LENGTH, .BUF_ADDRESS)
		END
	    ELSE
		BEGIN
		DIRECTORY_ERROR = TRUE;
		EXITLOOP;
		END;


	    ! Update to next chunk.
	    !
	    READ_VBN = .READ_VBN + .PROC_LENGTH/512;
	    IF .READ_VBN GTRU .DIR_LENGTH/512 THEN EXITLOOP;


	    ! Re-access the file for another trip.
	    !
	    CH$FILL(0, FIB$C_LENGTH, FIB);
	    FIB[FIB$L_ACCTL] = FIB$M_NORECORD;
	    FIB[FIB$W_FID_NUM] = .DIR_FID[FID$W_NUM];
	    FIB[FIB$W_FID_SEQ] = .DIR_FID[FID$W_SEQ];
	    FIB[FIB$W_FID_RVN] = .DIR_FID[FID$W_RVN];
	    STATUS = $QIOW(
		FUNC=IO$_ACCESS OR IO$M_ACCESS,
		CHAN=.CHANNEL,
		IOSB=IOSB,
		P1=FIB_DESC);
	    IF .STATUS THEN STATUS = .IOSB[0];
	    IF NOT .STATUS
	    THEN
		BEGIN

		! Report failure to access the directory, and set the error flag to
		! abort lost file processing.
		!
		DIRECTORY_ERROR = TRUE;
		SIGNAL(
		    VERIFY$_OPENDIR,
		    1,
		    (IF .DIR_DESC[0] EQL 0 THEN MFD_DESC ELSE DIR_DESC),
		    .STATUS);
		EXITLOOP;
		END;
	    END;


	! Deallocate memory for working copy of directory.
	!
	STATUS = LIB$FREE_VM(BUF_LENGTH, BUF_ADDRESS);
	IF NOT .STATUS THEN SIGNAL(VERIFY$_FREEMEM, 0, .STATUS);
	END
    ELSE
	BEGIN

	! Deaccess the file.
	!
	$QIOW(
	    FUNC=IO$_DEACCESS,
	    CHAN=.CHANNEL);
	END;
    END;


! Restore recursive variables.
!
DIR_DESC[0] = .SAVE_DIR_DESC;
DIR_FID[FID$W_NUM] = .SAVE_DIR_FID[FID$W_NUM];
DIR_FID[FID$W_SEQ] = .SAVE_DIR_FID[FID$W_SEQ];
DIR_FID[FID$W_RVN] = .SAVE_DIR_FID[FID$W_RVN];
END;

ROUTINE SCAN_DIRECT_1(LENGTH,ADDRESS)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine scans an ODS-1 directory.
!
! INPUT PARAMETERS:
!	LENGTH		- Descriptor for memory into which the directory
!	ADDRESS		-     has been read.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	True, indicating success.  There can be no directory format errors
!	in an ODS-1 directory.
!
! SIDE EFFECTS:
!	Directory scan completed.
!
!--

BEGIN

! Loop over all directory entries.
!
INCRA REC FROM .ADDRESS TO .ADDRESS + .LENGTH - NMB$C_DIRENTRY BY NMB$C_DIRENTRY DO
    BEGIN
    MAP
	REC:		REF BBLOCK;	! Pointer to directory record


    ! Zero file number indicates an empty entry.  If nonzero, process the entry.
    !
    IF .REC[NMB$W_FID_NUM] NEQ 0
    THEN
	BEGIN
	LOCAL
	    P,					! Temporary
	    FILE_NAME:	VECTOR[FI2$S_FILENAME,BYTE],	! Buffer for converted filename
	    VERSION:	BBLOCK[DIR$C_VERSION];	! Dummy ODS-2 version entry


	! Convert the ODS-1 format entry to suitable parameters for
	! PROCESS_FILE and PROCESS_SUBDIR -- an ASCIC name string and
	! an ODS-2-format version entry.
	!
	FILE_NAME[0] = MAKE_STRING(.REC, FILE_NAME[1]);
	P = CH$FIND_CH(.FILE_NAME[0], FILE_NAME[1], %C';');
	IF .P NEQ 0 THEN FILE_NAME[0] = .P - FILE_NAME[1];
	VERSION[DIR$W_VERSION] = .REC[NMB$W_VERSION];
	VERSION[DIR$W_FID_NUM] = .REC[NMB$W_FID_NUM];
	VERSION[DIR$W_FID_SEQ] = .REC[NMB$W_FID_SEQ];
	VERSION[DIR$W_FID_RVN] = 1;


	! Process the entry.  If PROCESS_FILE determines that the entry is
	! valid, and it is a directory, recursively scan the directory.
	! Clear the directory bit so that each directory is only done once.
	!
	IF PROCESS_FILE(FILE_NAME, VERSION)
	THEN
	    IF TESTBITSC(BITVECTOR[.DIRMAP[0], .REC[NMB$W_FID_NUM]-1])
	    THEN
		PROCESS_SUBDIR(FILE_NAME, VERSION);
	END;
    END;


! All done, return success.
!
TRUE
END;

ROUTINE SCAN_DIRECT_2(LENGTH,ADDRESS)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine scans an ODS-2 directory.
!
! INPUT PARAMETERS:
!	LENGTH		- Descriptor for memory into which the directory
!	ADDRESS		-     has been read.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	True if the directory was successfully scanned, false if an error
!	in its format is detected.
!
! SIDE EFFECTS:
!	Directory scan completed.
!
!--

BEGIN
LOCAL
	REC:		REF BBLOCK,	! Pointer to directory record
	NEXT_BLOCK;			! Pointer to next directory block


! Initialize for the first block.
!
REC = .ADDRESS;
NEXT_BLOCK = .REC + 512;


! Loop over all blocks.
!
WHILE .REC LSSA .ADDRESS + .LENGTH DO
    BEGIN
    IF .REC[DIR$W_SIZE] EQL 65535
    THEN
	BEGIN
	!
	! End of this block.  Advance to next and resume.
	!
	REC = .NEXT_BLOCK;
	NEXT_BLOCK = .REC + 512;
	END
    ELSE
	BEGIN
	LOCAL
	    NEXT_RECORD,		! Pointer to next record
	    VER:	REF BBLOCK;	! Pointer to version entry


	! Point to where next record should start.  Make some validity tests
	! on the entry we are looking at.
	!
	NEXT_RECORD = .REC[DIR$W_SIZE] + .REC + 2;
	IF
	    BEGIN
	    IF
		.NEXT_RECORD GEQA .NEXT_BLOCK OR			! Entry within block?
		.REC[DIR$W_SIZE] OR					! Length even?
		.REC[DIR$W_SIZE] LSSU DIR$C_LENGTH + DIR$C_VERSION	! Long enough?
	    THEN
		TRUE
	    ELSE
		BEGIN
		VER = (.REC + DIR$C_LENGTH + .REC[DIR$B_NAMECOUNT] + 1) AND NOT 1;
		.REC[DIR$V_TYPE] NEQ DIR$C_FID OR			! Proper type code?
		.VER GEQA .NEXT_BLOCK - DIR$C_VERSION			! Version entry within block?
		END
	    END
	THEN
	    BEGIN
	    !
	    ! Directory format error.  Report it and quit.
	    !
	    DIRECTORY_ERROR = TRUE;
	    SIGNAL(
		VERIFY$_BADDIR,
		1,
		(IF .DIR_DESC[0] EQL 0 THEN MFD_DESC ELSE DIR_DESC));
	    RETURN FALSE;
	    END;


	! Loop over all version entries.
	!
	WHILE .VER LSSA .NEXT_RECORD DO
	    BEGIN
	    LOCAL
		FILE_NUMBER,	! File number of entry
		RVN;		! RVN of entry


	    ! Get a clean file number and RVN.
	    !
	    FILE_NUMBER = .VER[DIR$W_FID_NUM];
	    FILE_NUMBER<16,8> = .VER[DIR$B_FID_NMX];
	    RVN = .VER[DIR$B_FID_RVN];
	    IF .RVN EQL 0 THEN RVN = .DIR_FID[FID$B_RVN];


	    ! Process the entry.  If PROCESS_FILE determines that the entry is
	    ! valid, and it is a directory, recursively scan the directory.
	    ! Clear the directory bit so that each directory is only done once.
	    !
	    IF PROCESS_FILE(REC[DIR$B_NAMECOUNT], VER[DIR$W_VERSION])
	    THEN
		IF TESTBITSC(BITVECTOR[.DIRMAP[.RVN-1], .FILE_NUMBER-1])
		THEN
		    BEGIN
		    IF
			CH$FIND_SUB(
			    .REC[DIR$B_NAMECOUNT], REC[DIR$T_NAME],
			    4, UPLIT BYTE ('.DIR')) EQL 0 OR
			.VER[DIR$W_VERSION] NEQ 1
		    THEN
			SIGNAL(
			    VERIFY$_DIRNAME,
			    3,
			    (IF .DIR_DESC[0] EQL 0 THEN MFD_DESC ELSE DIR_DESC),
			    REC[DIR$B_NAMECOUNT],
			    .VER[DIR$W_VERSION]);
		    PROCESS_SUBDIR(REC[DIR$B_NAMECOUNT], VER[DIR$W_VERSION]);
		    END;


	    ! Advance to next version entry.
	    !
	    VER = .VER + DIR$C_VERSION;
	    END;


	! Advance to next directory record.
	!
	REC = .NEXT_RECORD;
	END;
    END;


! All done, return success.
!
TRUE
END;

ROUTINE DIR_SCAN(RVN): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine scans all directories on a volume.
!
! INPUT PARAMETERS:
!	RVN		- Relative volume number.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	Directory scan completed.
!
!--

BEGIN
LOCAL
	VERSION:	BBLOCK[DIR$C_VERSION];	! Dummy version entry


! Initialize descriptor for current directory string.
!
DIR_DESC[0] = 0;
DIR_DESC[1] = DIR;


! Initialize current directory ID.
!
DIR_FID[FID$W_NUM] = FID$C_MFD;
DIR_FID[FID$W_SEQ] = FID$C_MFD;
DIR_FID[FID$W_RVN] = .RVN;


! Initialize dummy version entry pointing to MFD.
!
VERSION[DIR$W_VERSION] = 1;
VERSION[DIR$W_FID_NUM] = FID$C_MFD;
VERSION[DIR$W_FID_SEQ] = FID$C_MFD;
VERSION[DIR$W_FID_RVN] = .RVN;


! Process the MFD.
!
PROCESS_SUBDIR(0, VERSION);
END;

ROUTINE FAO(CTRL,PARAM): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine interfaces to FAO to format information into the line.
!
! INPUT PARAMETERS:
!	CTRL		- ASCIC control string
!	PARAM...	- Parameters required by the control string (if any)
!
! IMPLICIT INPUTS:
!	LIST_DESC	- Describes the remainder of the output line.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	LIST_DESC	- Updated.
!	Information formatted into the line buffer.
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	CTRL:		REF VECTOR[,BYTE];	! ASCIC control string
LOCAL
	OUTLEN:		WORD,			! Length returned by $FAOL
	DESC:		VECTOR[2];		! Descriptor for control string


! Make a descriptor for the control string.
!
DESC[0] = .CTRL[0];
DESC[1] = CTRL[1];


! Use $FAOL to do the editing.
!
$FAOL(CTRSTR=DESC, OUTLEN=OUTLEN, OUTBUF=LIST_DESC, PRMLST=PARAM);


! Update the listing buffer descriptor.
!
LIST_DESC[0] = .LIST_DESC[0] - .OUTLEN;
LIST_DESC[1] = .LIST_DESC[1] + .OUTLEN;
END;

ROUTINE EOL: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine writes the listing buffer to the listing file.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	LIST_DESC	- Describes the remainder of the listing line.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	LIST_DESC	- Reinitialized to describe the entire line.
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	The listing is produced.
!
!--

BEGIN

! Compute line length.
!
LIST_RAB[RAB$W_RSZ] = LIST_SIZE - .LIST_DESC[0];


! Do the write.  If failure, report it.
!
IF NOT $PUT(RAB=LIST_RAB)
THEN
    FILE_ERROR(
	VERIFY$_FACILITY^16 + SHR$_WRITEERR + STS$K_SEVERE,
	LIST_FAB,
	.LIST_RAB[RAB$L_STS], .LIST_RAB[RAB$L_STV]);


! Reinitialize descriptor.
!
LIST_DESC[0] = LIST_SIZE;
LIST_DESC[1] = LIST_BUFFER;
END;

ROUTINE ENTER_WORK(TYPE,P1,P2): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine makes an entry in the work list that is executed after
!	the volume is unlocked.
!
! INPUT PARAMETERS:
!	TYPE		- Type of repair.
!	P1		- Type-specific parameters.
!	P2		-
!
! IMPLICIT INPUTS:
!	WORK_LIST	- List header for work items.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	WORK_LIST	- List header for work items updated.
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	P1:		REF BBLOCK,	! Type-specific parameters
	P2:		REF BBLOCK;	!
LOCAL
	P:		REF BBLOCK,	! Pointer to work list entry
	STATUS;				! Status variable
BIND
	SIZES = UPLIT BYTE (		! Table of entry sizes
	    WRK_S_ENTER,
	    WRK_S_REMOVE,
	    WRK_S_ADDQUO,
	    WRK_S_DELETE)
	: VECTOR[,BYTE];


! Allocate a new block.
!
STATUS = LIB$GET_VM(%REF(.SIZES[.TYPE]), P);
IF NOT .STATUS THEN SIGNAL(VERIFY$_ALLOCMEM, 0, .STATUS);


! Link the block to the work list.  Offset 0 points to the first entry and
! offset 1 points to the most recent entry.
!
IF .WORK_LIST[0] EQL 0
    THEN WORK_LIST[0] = .P
    ELSE BBLOCK[.WORK_LIST[1], WRK_LINK] = .P;
WORK_LIST[1] = .P;


! Initialize the remainder.
!
P[WRK_LINK] = 0;
P[WRK_TYPE] = .TYPE;
CASE .TYPE FROM WRK_K_ENTER TO WRK_K_DELETE OF
    SET

    [WRK_K_ENTER, WRK_K_DELETE]:
	BEGIN
	BBLOCK[P[WRK_FID], FID$W_NUM] = .P1[FID$W_NUM];
	BBLOCK[P[WRK_FID], FID$W_SEQ] = .P1[FID$W_SEQ];
	BBLOCK[P[WRK_FID], FID$W_RVN] = .P1[FID$W_RVN];
	END;

    [WRK_K_REMOVE]:
	BEGIN
	BBLOCK[P[WRK_DID], FID$W_NUM] = .P2[FID$W_NUM];
	BBLOCK[P[WRK_DID], FID$W_SEQ] = .P2[FID$W_SEQ];
	BBLOCK[P[WRK_DID], FID$W_RVN] = .P2[FID$W_RVN];
	BBLOCK[P[WRK_FID], FID$W_NUM] = .P1[FID$W_NUM];
	BBLOCK[P[WRK_FID], FID$W_SEQ] = .P1[FID$W_SEQ];
	BBLOCK[P[WRK_FID], FID$W_RVN] = .P1[FID$W_RVN];
	END;

    [WRK_K_ADDQUO]:
	BEGIN
	P[WRK_UIC] = .P1;
	P[WRK_USAGE] = .P2;
	END;

    TES;
END;

ROUTINE PROCESS_WORK: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the work list to execute delayed repairs.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	WORK_LIST	- List header for work items.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	STATUS,				! Status variable
	P:		REF BBLOCK;	! Pointer to work list entry
LABEL
	ENTER_LOST;


P = .WORK_LIST[0];
WHILE .P NEQ 0 DO
    BEGIN
    CASE .P[WRK_TYPE] FROM WRK_K_ENTER TO WRK_K_DELETE OF
	SET


	[WRK_K_ENTER]:
ENTER_LOST:
	    BEGIN
	    LOCAL
		IDENT_AREA:	REF BBLOCK,	! Pointer to ident area
		FILENAME:	VECTOR[FI2$S_FILENAME,BYTE],
						! Buffer for file name
		FNA_DESC:	VECTOR[2];	! Descriptor for file name


	    ! Reread the file header to get a file name.
	    !
	    IF READ_HEADER(P[WRK_FID], BUFFER_2)
	    THEN
		BEGIN

		! If this is the first pass through, locate the lost file
		! directory, creating it if necessary.
		!
		IF .LOST_DIR_FID[FID$W_NUM] EQL 0
		THEN
		    BEGIN
		    OWN
			ATR_UIC:	BBLOCK[4],
			ATR_FPRO:	BBLOCK[2],
			ATR_UCHAR:	BBLOCK[4],
			ATR_RECATTR:	BBLOCK[FAT$C_LENGTH];
		    BIND
			ATR_DESC = UPLIT(
			    WORD(4, ATR$C_UIC), LONG(ATR_UIC),
			    WORD(2, ATR$C_FPRO), LONG(ATR_FPRO),
			    WORD(4, ATR$C_UCHAR), LONG(ATR_UCHAR),
			    WORD(FAT$C_LENGTH, ATR$C_RECATTR), LONG(ATR_RECATTR),
			    LONG(0));


		    ! Access the MFD on RVN 1 to get attributes.  The lost file
		    ! directory will be created with the same attributes.
		    !
		    CH$FILL(0, FIB$C_LENGTH, FIB);
		    FIB[FIB$W_FID_NUM] = FID$C_MFD;
		    FIB[FIB$W_FID_SEQ] = FID$C_MFD;
		    FIB[FIB$W_FID_RVN] = 1;
		    STATUS = $QIOW(
			FUNC=IO$_ACCESS,
			CHAN=.CHANNEL,
			IOSB=IOSB,
			P1=FIB_DESC,
			P5=ATR_DESC);
		    IF .STATUS THEN STATUS = .IOSB[0];
		    IF NOT .STATUS
		    THEN
			BEGIN
			SIGNAL(VERIFY$_CREATELOST, 0, .STATUS);
			LEAVE ENTER_LOST;
			END;


		    ! Adjust EFBLK and HIBLK.
		    !
		    ATR_RECATTR[FAT$L_EFBLK] = 0;
		    ATR_RECATTR[FAT$L_HIBLK] = 0;
		    IF .STRUCTURE_LEVEL EQL 2 THEN ATR_RECATTR[FAT$L_EFBLK] = 2 ^ 16;


		    ! Access the directory file, creating it if necessary.
		    !
		    CH$FILL(0, FIB$C_LENGTH, FIB);
		    FIB[FIB$L_ACCTL] = FIB$M_WRITE OR FIB$M_NOWRITE;
		    FIB[FIB$W_DID_NUM] = FID$C_MFD;
		    FIB[FIB$W_DID_SEQ] = FID$C_MFD;
		    FIB[FIB$W_DID_RVN] = 1;
		    IF .STRUCTURE_LEVEL EQL 2
		    THEN
			BEGIN
			FIB[FIB$W_EXCTL] = FIB$M_EXTEND OR FIB$M_ALCON OR FIB$M_FILCON;
			FIB[FIB$L_EXSZ] = 1;
			END;
		    STATUS = $QIOW(
			FUNC=IO$_ACCESS OR IO$M_CREATE OR IO$M_ACCESS,
			CHAN=.CHANNEL,
			IOSB=IOSB,
			P1=FIB_DESC,
			P2=LOST_DESC,
			P5=ATR_DESC);
		    IF .STATUS THEN STATUS = .IOSB[0];
		    IF NOT .STATUS
		    THEN
			BEGIN
			SIGNAL(VERIFY$_CREATELOST, 0, .STATUS);
			LEAVE ENTER_LOST;
			END;


		    ! If the directory file was created and it is ODS-2, the
		    ! first block must be initialized.
		    !
		    IF .STATUS EQL SS$_CREATED THEN IF .STRUCTURE_LEVEL EQL 2
		    THEN
			BEGIN
			STATUS = $QIOW(
			    FUNC=IO$_WRITEVBLK,
			    CHAN=.CHANNEL,
			    IOSB=IOSB,
			    P1=UPLIT WORD(-1, REP 255 OF (0)),
			    P2=512,
			    P3=1);
			IF .STATUS THEN STATUS = .IOSB[0];
			IF NOT .STATUS
			THEN
			    BEGIN
			    SIGNAL(VERIFY$_CREATELOST, 0, .STATUS);
			    LEAVE ENTER_LOST;
			    END;
			END;


		    ! Save the file ID for later use.
		    !
		    LOST_DIR_FID[FID$W_NUM] = .FIB[FIB$W_FID_NUM];
		    LOST_DIR_FID[FID$W_SEQ] = .FIB[FIB$W_FID_SEQ];
		    LOST_DIR_FID[FID$W_RVN] = .FIB[FIB$W_FID_RVN];


		    ! Deaccess the lost file directory.
		    !
		    $QIOW(
			FUNC=IO$_DEACCESS,
			CHAN=.CHANNEL);
		    END;

	    
		! Get a descriptor for the file name.
		!
		IDENT_AREA = BUFFER_2 + .BUFFER_2[FH2$B_IDOFFSET]*2;
		IF .STRUCTURE_LEVEL EQL 2
		THEN
		    BEGIN
		    LOCAL
			P;

		    FNA_DESC[0] = FI2$S_FILENAME;
		    FNA_DESC[1] = IDENT_AREA[FI2$T_FILENAME];
		    IF (P = CH$FIND_CH(FI2$S_FILENAME, .FNA_DESC[1], %C' ')) NEQ 0
			THEN FNA_DESC[0] = .P - .FNA_DESC[1];
		    END
		ELSE
		    BEGIN
		    FNA_DESC[0] = MAKE_STRING(
			IDENT_AREA[FI1$W_FILENAME] - $BYTEOFFSET(NMB$W_NAME),
			FILENAME);
		    FNA_DESC[1] = FILENAME;
		    END;


		! Create the directory entry.
		!
		CH$FILL(0, FIB$C_LENGTH, FIB);
		FIB[FIB$W_FID_NUM] = .BBLOCK[P[WRK_FID], FID$W_NUM];
		FIB[FIB$W_FID_SEQ] = .BBLOCK[P[WRK_FID], FID$W_SEQ];
		FIB[FIB$W_FID_RVN] = .BBLOCK[P[WRK_FID], FID$W_RVN];
		FIB[FIB$W_DID_NUM] = .LOST_DIR_FID[FID$W_NUM];
		FIB[FIB$W_DID_SEQ] = .LOST_DIR_FID[FID$W_SEQ];
		FIB[FIB$W_DID_RVN] = .LOST_DIR_FID[FID$W_RVN];
		FIB[FIB$W_NMCTL] = FIB$M_NEWVER;
		STATUS = $QIOW(
		    FUNC=IO$_CREATE,
		    CHAN=.CHANNEL,
		    IOSB=IOSB,
		    P1=FIB_DESC,
		    P2=FNA_DESC);
		IF .STATUS THEN STATUS = .IOSB[0];
		IF NOT .STATUS
		THEN
		    HEADER_ERROR(VERIFY$_ENTERLOST, P[WRK_FID], 0, .STATUS);
		END;
	    END;


	[WRK_K_REMOVE]:
	    BEGIN

	    ! Remove directory entry.
	    !
	    CH$FILL(0, FIB$C_LENGTH, FIB);
	    FIB[FIB$W_FID_NUM] = .BBLOCK[P[WRK_FID], FID$W_NUM];
	    FIB[FIB$W_FID_SEQ] = .BBLOCK[P[WRK_FID], FID$W_SEQ];
	    FIB[FIB$W_FID_RVN] = .BBLOCK[P[WRK_FID], FID$W_RVN];
	    FIB[FIB$W_DID_NUM] = .BBLOCK[P[WRK_DID], FID$W_NUM];
	    FIB[FIB$W_DID_SEQ] = .BBLOCK[P[WRK_DID], FID$W_SEQ];
	    FIB[FIB$W_DID_RVN] = .BBLOCK[P[WRK_DID], FID$W_RVN];
	    FIB[FIB$W_NMCTL] = FIB$M_FINDFID;
	    STATUS = $QIOW(
		FUNC=IO$_DELETE,
		CHAN=.CHANNEL,
		IOSB=IOSB,
		P1=FIB_DESC);
	    IF .STATUS THEN STATUS = .IOSB[0];
	    IF NOT .STATUS
	    THEN
		SIGNAL(
		    VERIFY$_REMOVE,
		    3,
		    .BBLOCK[P[WRK_FID], FID$W_NUM] +
		    .BBLOCK[P[WRK_FID], FID$B_NMX] ^ 16,
		    .BBLOCK[P[WRK_FID], FID$W_SEQ],
		    .BBLOCK[P[WRK_FID], FID$B_RVN],
		    .STATUS);
	    END;


	[WRK_K_ADDQUO]:
	    BEGIN

	    ! Add quota file entry.
	    !
	    CH$FILL(0, FIB$C_LENGTH, FIB);
	    FIB[FIB$W_CNTRLFUNC] = FIB$C_ADD_QUOTA;
	    DQF[DQF$L_UIC] = .P[WRK_UIC];
	    DQF[DQF$L_USAGE] = .P[WRK_USAGE];
	    DQF[DQF$L_PERMQUOTA] = .DEFAULT_QUOTA;
	    DQF[DQF$L_OVERDRAFT] = .DEFAULT_OVERDRAFT;
	    STATUS = $QIOW(
		FUNC=IO$_ACPCONTROL,
		CHAN=.CHANNEL,
		IOSB=IOSB,
		P1=FIB_DESC,
		P2=DQF_DESC);
	    IF .STATUS THEN STATUS = .IOSB[0];
	    IF NOT .STATUS
	    THEN
		SIGNAL(
		    VERIFY$_ADDQUOTA,
		    2,
		    .(P[WRK_UIC])<16,16>,
		    .(P[WRK_UIC])<0,16>,
		    .STATUS);
	    END;


	[WRK_K_DELETE]:
	    BEGIN

	    ! Delete file.
	    !
	    CH$FILL(0, FIB$C_LENGTH, FIB);
	    FIB[FIB$W_FID_NUM] = .BBLOCK[P[WRK_FID], FID$W_NUM];
	    FIB[FIB$W_FID_SEQ] = .BBLOCK[P[WRK_FID], FID$W_SEQ];
	    FIB[FIB$W_FID_RVN] = .BBLOCK[P[WRK_FID], FID$W_RVN];
	    STATUS = $QIOW(
		FUNC=IO$_DELETE OR IO$M_DELETE,
		CHAN=.CHANNEL,
		IOSB=IOSB,
		P1=FIB_DESC);
	    IF .STATUS THEN STATUS = .IOSB[0];
	    IF NOT .STATUS
	    THEN
		HEADER_ERROR(VERIFY$_DELETE, P[WRK_FID], 0, .STATUS);
	    END;


	TES;


    ! Advance to next work list entry.
    !
    P = .P[WRK_LINK];
    END;
END;

ROUTINE DO_REPAIR(P_PROMPT)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine evaluates the qualifiers that specify whether a repair
!	should be executed.
!
! INPUT PARAMETERS:
!	P_PROMPT	- Prompt type flags:
!				Bit 0:  Prompting is enabled.
!				Bit 1:  Delete is an option.
!			  Default is %B'01'.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Bit 0 set if the repair is selected, clear otherwise.
!	Bit 1 set if delete is selected.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	PROMPT;				! Value of prompt bits
BUILTIN
	ACTUALCOUNT;


! If /REPAIR is not in effect, return no repair.
!
IF NOT .QUAL[QUAL_REPA]
THEN
    RETURN 0;


! Get PROMPT value.
!
PROMPT = %B'01';
IF ACTUALCOUNT() NEQ 0 THEN PROMPT = .P_PROMPT;


! If /CONFIRM has been requested, do it.
!
IF .QUAL[QUAL_CONF] AND .PROMPT
THEN
    BEGIN
    LOCAL
	ANS_BUFFER:	VECTOR[8,BYTE],		! Buffer for response
	ANS_DESC:	BBLOCK[8];		! Descriptor for buffer


    ! Set up a descriptor for the result area.
    !
    ANS_DESC[DSC$W_LENGTH] = 8;
    ANS_DESC[DSC$B_DTYPE] = DSC$K_DTYPE_T;
    ANS_DESC[DSC$B_CLASS] = DSC$K_CLASS_S;
    ANS_DESC[DSC$A_POINTER] = ANS_BUFFER;


    IF .PROMPT<1,1>
    THEN
	BEGIN

	! Prompt with delete option.
	!
	LIB$GET_COMMAND(
	    ANS_DESC,
	    $DESCRIPTOR('Repair this error (D to delete)? (D, Y or N): '));
	ANS_BUFFER[0] = .ANS_BUFFER[0] AND NOT %O'040';	! Upcase
	IF .ANS_BUFFER[0] EQL %C'D' THEN RETURN %B'11';
	END
    ELSE
	BEGIN

	! Prompt without delete option.
	!
	LIB$GET_COMMAND(
	    ANS_DESC,
	    $DESCRIPTOR('Repair this error? (Y or N): '));
	END;
    ANS_BUFFER[0] = .ANS_BUFFER[0] AND NOT %O'040';	! Upcase
    IF .ANS_BUFFER[0] NEQ %C'Y' THEN RETURN 0;
    END;


! Ordinary repair has been requested.
!
%B'01'
END;

ROUTINE EXIT_HANDLER: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine is the exit handler.  It receives control when the image
!	is exited.  Its purpose is to unlock the volume set if necessary, and
!	to disable quota processing if necessary.
!
! INPUT PARAMETERS:
!	Exit handler parameter list (not used).
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	Volume set unlocked, if possible.  Quota processing disabled if it was
!	disabled on entry, if possible.
!
!--

BEGIN
IF .QUAL[QUAL_REPA]
THEN
    BEGIN
    CH$FILL(0, FIB$C_LENGTH, FIB);
    FIB[FIB$W_CNTRLFUNC] = FIB$C_UNLK_VOL;
    $QIOW(
	FUNC=IO$_ACPCONTROL,
	CHAN=.CHANNEL,
	P1=FIB_DESC);
    END;


IF .QUOTA_DISABLE
THEN
    BEGIN
    CH$FILL(0, FIB$C_LENGTH, FIB);
    FIB[FIB$W_CNTRLFUNC] = FIB$C_DSA_QUOTA;
    $QIOW(
	FUNC=IO$_ACPCONTROL,
	CHAN=.CHANNEL,
	P1=FIB_DESC);
    END;
END;

ROUTINE CHECK_DATE(ODS2_DATE,ODS1_DATE,MESSAGE,FILE_ID,HEADER): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine checks and corrects a date field.
!
! INPUT PARAMETERS:
!	ODS2_DATE	- Pointer to ODS-2 date within header.
!	ODS1_DATE	- Pointer to ODS-1 date within header.
!	MESSAGE		- Message to be issued.
!	FILE_ID		- File identification.
!	HEADER		- Pointer to header.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	ODS2_DATE:	REF VECTOR,		! Pointer to quadword date
	ODS1_DATE:	REF BBLOCK,		! Pointer to ODS-1 date
	FILE_ID:	REF BBLOCK;		! Pointer to file ID
LITERAL
	DATE_LENGTH=	23;
LOCAL
	DATE_BUFFER:	BBLOCK[DATE_LENGTH],	! Buffer for $BINTIM
	DATE_TEMP:	VECTOR[2],		! Binary date value
	DATE:		REF VECTOR,		! Pointer to comparison date
	DESC:		VECTOR[2];		! Descriptor for buffer


! Assume that the comparison date is the ODS-2 date.
!
DATE = .ODS2_DATE;


! For ODS-1, convert the date to 64-bit format.
!
IF .STRUCTURE_LEVEL EQL 1
THEN
    BEGIN

    ! The comparison date is the temporary buffer.
    !
    DATE = DATE_TEMP;


    IF .ODS1_DATE[0,0,8,0] EQL 0
    THEN
	BEGIN
	!
	! Null date.  If the date is all nulls, set it to zeros so that it
	! will surely pass the comparison.  If it is not, set it to ones so
	! that it will surely fail.
	!
	DATE_TEMP[0] = DATE_TEMP[1] = 0;
	IF CH$FIND_NOT_CH(13, .ODS1_DATE, 0) NEQ 0
	    THEN DATE_TEMP[0] = DATE_TEMP[1] = -1;
	END
    ELSE
	BEGIN
	!
	! Convert the date to a format acceptable to $BINTIM.
	!
	DATE_BUFFER[0,0,16,0] = .ODS1_DATE[0,0,16,0];
	DATE_BUFFER[2,0,8,0] = '-';
	DATE_BUFFER[3,0,24,0] = .ODS1_DATE[2,0,24,0];
	DATE_BUFFER[6,0,24,0] = '-19';
	DATE_BUFFER[9,0,16,0] = .ODS1_DATE[5,0,16,0];
	DATE_BUFFER[11,0,8,0] = ' ';
	DATE_BUFFER[12,0,16,0] = .ODS1_DATE[7,0,16,0];
	DATE_BUFFER[14,0,8,0] = ':';
	DATE_BUFFER[15,0,16,0] = .ODS1_DATE[9,0,16,0];
	DATE_BUFFER[17,0,8,0] = ':';
	DATE_BUFFER[18,0,16,0] = .ODS1_DATE[11,0,16,0];
	DATE_BUFFER[20,0,24,0] = '.00';


	! Try to convert the date using $BINTIM.  If this fails, set the date
	! to all ones so that it will surely fail the comparison.
	!
	DESC[0] = DATE_LENGTH;
	DESC[1] = DATE_BUFFER;
	IF NOT $BINTIM(TIMBUF=DESC, TIMADR=DATE_TEMP)
	THEN
	    DATE_TEMP[0] = DATE_TEMP[1] = -1;
	END;
    END;


! Compare date in quadword format.  If the comparison fails, issue the message,
! reconstruct the date as appropriate, and rewrite the header.  Avoid this for
! the revision date of the index file.  Because we are accessing and
! deaccessing index files on the second channel, the revision date may properly
! become later than the value we have for the current time.
!
IF
    .DATE[1] GTRU .CURRENT_TIME[1] OR
    .DATE[1] EQL .CURRENT_TIME[1] AND .DATE[0] GTRU .CURRENT_TIME[0]
THEN
    BEGIN
    IF
	.FILE_ID[FID$W_NUM] NEQ FID$C_INDEXF OR .FILE_ID[FID$B_NMX] NEQ 0 OR
	.MESSAGE NEQ VERIFY$_FUTREVDAT
    THEN
	BEGIN
	HEADER_ERROR(.MESSAGE, .FILE_ID, .HEADER);
	IF DO_REPAIR()
	THEN
	    BEGIN
	    IF .STRUCTURE_LEVEL EQL 2
	    THEN
		BEGIN
		ODS2_DATE[0] = .CURRENT_TIME[0];
		ODS2_DATE[1] = .CURRENT_TIME[1];
		END
	    ELSE
		CH$MOVE(13, CURRENT_TIME_1, .ODS1_DATE);
	    WRITE_HEADER(.FILE_ID, .HEADER);
	    END;
	END;
    END;
END;

END
ELUDOM
