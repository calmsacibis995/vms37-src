MODULE LNK_OBJFIL (IDENT='V03-012',
		ADDRESSING_MODE(EXTERNAL=GENERAL)
			) =

BEGIN
!
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
!
!
!
!++
!
! MODULE:	LNK_OBJFIL
!
! FACILITY:	LINKER
!
! ABSTRACT:	ROUTINES TO OPEN AND READ ALL RECORDS OF OBJECT FILES
!
! HISTORY:
!
!	VERSION:	X01.00
!
!	AUTHOR: T.J. PORTER 03-MAY-77
!
! MODIFIED BY:
!
!	V03-012	BLS0167		Benn Schreiber		30-Mar-1982
!		Don't set SQO for shareable images
!
!	V03-011	BLS0166		Benn Schreiber		29-Mar-1982
!		Set SQO for sequential input files
!
!	V03-010	BLS0154		Benn Schreiber		27-Feb-1982
!		Don't set INTFIL if uesr default library
!
!	V03-009	BLS0117		Benn Schreiber		 6-Dec-1981
!		Open shareable image UPI, SHRGET, and SHRPUT in case
!		it is installed /writeable
!
!	V03-008	BLS0087		Benn Schreiber		 7-Oct-1981
!		Return false from lnk$nxtrec if read error
!
!	V03-007	BLS0086		Benn Schreiber		30-Sep-1981
!		Check nxtfdb field in defclu before linking it
!		into cluster list (again).
!
!	V03-006	BLS0079		Benn Schreiber		14-Sep-1981
!		Clear cluster info if internal cluster and image
!		file not found
!
!	V03-005	BLS0074		Benn Schreiber		29-Aug-1981
!		Pass descriptor to lnk$nxtrec to reduce args to 1.
!
!	V03-004	BLS0050		Benn Schreiber		26-Mar-1981
!		Remove special code for vmsrtl as part of independent
!		shareable image enhancements
!
!	V03-003	BLS0029		Benn Schreiber		18-Dec-1980
!		Implement library of shareable image symbol tables
!
!	V03-002	BLS0017		Benn Schreiber,		1-Sep-1980
!		If lbr$find fails in pass 2, try lbr$lookup_key
!		before complaining (someone moved module).
!
!	V03-001	BLS0007		Benn Schreiber,		3-Jun-1980
!		Convert to MDL data structures.
!--

!
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	THIS MODULE CONTAINS A ROUTINE TO OPEN THE NEXT
!	OBJECT MODULE FILE AND ANOTHER TO READ THE NEXT
!	RECORD FROM THE CURRENTLY OPEN FILE. IT ALSO CONTAINS THE
!	ROUTINE TO CLOSE THE CURRENTLY OPEN FILE.
!
!		LNK$NXTFIL
!		LNK$NXTREC(RECADRS,RECLNG)
!		LNK$CLOSCURFIL()
!
!	IF THERE ARE NO MORE FILES OR RECORDS, ROUTINES HAVE THE VALUE FALSE.
!	IF FILE IS SUCCESSFULLY OPENED (BY FILE ID USING LINKED LIST OF FDB'S)
!	LNK$NXTFIL HAS THE VALUE TRUE AND THE ADDRESS OF THE
!	FILE DESCRIPTOR BLOCK IS PLACED IN LNK$GL_CURFIL.
!
!	THERE IS NO RETURN ON THE FOLLOWING ERROR CONDITIONS:
!		OPEN FAILURE
!		CONNECT FAILURE
!
!	CALLING SEQUENCE:
!		LNK$NXTFIL()
!		LNK$NXTREC(RECADRS,RECLNG)
!		LNK$CLOSCURFIL()
!	WHERE:
!		RECADRS = ADDRESS OF LONGWORD TO RECEIVE THE
!		          ADDRESS OF NEXT RECORD.
!		RECLNG  = ADDRESS OF A WORD TO RECEIVE LENGTH
!			  OF THE RECORD (IN BYTES).
!	THE ROUTINE RETURNS THE VALUE TRUE, UNLESS END OF FILE
!	IS DETECTED, WHEN IT RETURNS THE VALUE FALSE.
!--
!
LIBRARY
	'SYS$LIBRARY:STARLET.L32';	! SYSTEM STRUCTURE DEFINITIONS
REQUIRE
	'PREFIX';
LIBRARY
	'DATBAS';			! INTERNAL DATA BASE DEFINITIONS
!
FORWARD ROUTINE
	TRAN_NEXT_LIB,				! RETURN NEXT DEFAULT LIBRARY NAME
	LNK$OPENLIB,				! OPEN LIBRARY
	LNK$CLOSCURFIL : NOVALUE;		! CLOSE CURRENT FILE
!
EXTERNAL ROUTINE
	LNK$ALLOBLK : NOVALUE, 			! DYNAMIC MEMORY ALLOCATOR
	LNK$DEALBLK : NOVALUE, 			! AND DEALLOCATOR
	LNK$ALLOCLUSTER : NOVALUE,		! ALLOCATE CLUSTER DESCRIPTORS
	LNK$ALLOFDB : NOVALUE,			! ALLOCATE FILE DESCRIPTOR BLOCKS
	LNK$FILNAMDSC,				! RETURN STRING DESCRIPTOR FOR FILENAME
	SYS$FAO,				! FORMATTED ASCII OUTPUT
	LBR$LOOKUP_KEY, 			! LOOKUP KEY IN MODULE
	LBR$SET_MODULE, 			! READ MODULE HEADER
	LBR$FIND,				! POSITION TO READ MODULE
	LBR$INI_CONTROL,			! INITIALIZE TO READ LIBRARY
	LBR$GET_RECORD,				! READ RECORD FROM LIBRARY
	LBR$OPEN,				! OPEN LIBRARY
	LBR$CLOSE;				! CLOSE LIBRARY
!
EXTERNAL LITERAL
	LIN$_CLOSEIN,				! CLOSE ERROR MESSAGE
	LIN$_FORMAT,				! FORMAT ERROR ON A FILE
	LIN$_LIBFIND,				! FAILED TO GET (BY RFA) THE CORRECT RECORD OF A LIBRARY
	LIN$_NOTOBJLIB,				! FILE NOT OBJECT LIBRARY
	LIN$_NOTIMGLIB,				! FILE NOT SHAREABLE IMAGE STB LIBRARY
	LIN$_OPENIN,				! FAILED TO OPEN INPUT FILE
	LIN$_READERR;				! READ ERROR
!
EXTERNAL
	LBR$GL_CONTROL : REF BLOCK[,BYTE], 	! CURRENT LIBRARY CONTROL ADDRESS
	LBR$GL_RMSSTV, 				! RMS STV FROM LIBRARY OPERATIONS
	LNK$GL_ULIBMASK : BITVECTOR[],		! ENABLE BITS FOR USER LIBRARIES
	LNK$GL_CTLMSK : BLOCK[,BYTE],		! CONTROL FLAGS
	LNK$GL_CLULST : VECTOR[2],		! CLUSTER DESCRIPTOR LISTHEAD
	LNK$GL_LASTCLU : REF BLOCK[,BYTE],	! LAST CLUSTER IN LIST DESCR.
	LNK$GL_CURCLU : REF BLOCK[,BYTE],	! CURRENT CLUSTER POINTER
	LNK$GL_DEFCLU : BLOCK[,BYTE],		! DEFAULT CLUSTER
	LNK$GW_NUDFSYMS : WORD,			! NUMBER OF UNDEFINED SYMBOLS
	LNK$GB_PASS : BYTE;			! THE PASS CURRENTLY EXECUTING
!
GLOBAL LITERAL
	LNK$C_OBJMBC = 5;			! MULTI BLOCK COUNT FOR OBJ FILES
!
GLOBAL
	LNK$GL_OBJRECS,				! ACCUMULATED OBJECT RECORDS READ
	LNK$GL_RECORD,				! RECORD NUMBER THIS FILE
	LNK$AL_RAB : $RAB(RAC = SEQ,ROP = LOC,	! RECORD ACCESS BLOCK SPECIFYING
						! SEQUENTIAL,LOCATE MODE
			MBC = LNK$C_OBJMBC),	! WITH MULTIPLE BLOCKS
	LNK$GL_CUROMD : REF BLOCK[,BYTE],	! POINTER TO CURRENT OBJ MOD. DESCRIPTOR
	LNK$GL_CURFIL : REF BLOCK[,BYTE];	! POINTER TO CURRENT FDB
!
OWN
	INTFILTBL : QUADVECTOR[2] INITIAL(			! TABLE OF INTERNAL FILES
			STRINGDESC('STARLET'),			! SYSTEM DEFAULT OBJECT LIBRARY
			STRINGDESC('IMAGELIB')),		! LIBRARY OF SHAREABLE IMAGE SYMBOL TABLES
	SYSLIBDEFEXT : DESCRIPTOR('SYS$LIBRARY:.OLB'),		! DEFAULT FILENAME FOR STARLET AND IMAGELIB
	CURDEFEXT : BLOCK[DSC$C_S_BLN,BYTE],			! STRING DESCRIPTOR FOR CURRENT DEFAULT STRING
	LIBDEFEXT : DESCRIPTOR('SYS$DISK:.OLB'),		! DEFAULT FILENAME FOR USER LIBRARY
	SHRDEFEXT : DESCRIPTOR('SYS$LIBRARY:.EXE'),		! DEFAULT FILENAME FOR SHAREABLE IMAGES
	LIBNAMEFAO : DESCRIPTOR('LNK$LIBRARY_!UW'),		! FAO CONTROL STRING TO CREATE USER LIBRARY NAMES
	PREVIOUS_FDB : REF BLOCK[,BYTE],			! POINTER TO PREVIOUS FDB.
	LASTUSERCLU : REF BLOCK[,BYTE],				! POINTER TO LAST USER CLUSTER (OR DEFAULT)
	NEXTINTFIL : BYTE INITIAL (3),				! FOUR INTERNAL FILES
	USERLIBNO,						! NUMBER OF NEXT DEFAULT USER LIBRARY
	FIRST_TIME : BYTE INITIAL (TRUE),			! INITIALLY FIRST TIME THROUGH
	DEFAULT_LIB : BYTE INITIAL (FALSE),			! AND NOT PROCESSING DEFAULT LIBRARIES
	DEFLIBACMODE : BYTE INITIAL (0),			! ACCESS MODE INDEX
	DEFLIBDSBMSK : VECTOR[4,BYTE] INITIAL (%x'060503'),	! DISABLE TABLE SEARCH BIT MASK
	RESULTSTRING : VECTOR[NAM$C_MAXRSS,BYTE],		! RESULT OF TRANSLATING LOGICAL NAME
	LIBNAMDESCR : VECTOR[2] INITIAL (NAM$C_MAXRSS,		! DESCRIPTOR OF RESULTANT NAME BUFFER
					RESULTSTRING),
	INPUT_IFI;						! SAVED IFI OR (LIBRARY INDEX NUMBER)+1
!
GLOBAL BIND
	LNK$GL_INPUTIFI = INPUT_IFI;				! MAKE IT AVAILABLE TO EVERYONE
!

GLOBAL ROUTINE LNK$NXTFIL =
BEGIN
!
!	CLOSE THE PREVIOUSLY OPEN FILE AND THEN
!	IF THERE ARE ANY MORE FILES IN THE TABLE GO OPEN THE
!	NEXT AND PUT ADDRESS OF ITS DESCRIPTOR IN CURRENT SLOT. IF
!	NONE, RETURN FALSE.
!
LOCAL
	AUXFNB : REF BLOCK[,BYTE],		! POINTER TO AUXILIARY FILE NAME BLOCK
	INPUT_FAB : BLOCK[FAB$C_BLN,BYTE],	! FILE ACCESS BLOCK TO DO OPEN
	RMSSTV,					! STV RETURNED ON RMS OPERATION
	ERRORCODE : BLOCK[4,BYTE],		! 
	OPENERROR;				! ERROR CODE ON OPEN
!
IF .LNK$GL_CURFIL EQL 0					! IF NO CURRENT FILE
THEN BEGIN						! START AT TOP OF LIST
    LNK$GL_CURCLU = .LNK$GL_CLULST[0];			! OF CLUSTERS
    PREVIOUS_FDB = LNK$GL_CURCLU[CLU$L_FSTFDB];		! SETTING PREVIOUS TO ITS LISTHEAD
    END
ELSE BEGIN
    LNK$CLOSCURFIL();					! OTHERWISE CLOSE THE PREVIOUS FILE
    IF .LNK$GB_PASS EQL 1				! IF THIS IS PASS 1
	THEN LNK$GL_CURFIL[FDB$V_P1] = TRUE;		!  THEN FLAG FILE PROCESSED IN PASS 1
    IF .LNK$GL_CURFIL[FDB$V_LIBR] 			! IF THAT LAST FILE WAS A LIBRARY
	AND .LNK$GL_CURFIL[FDB$L_OMDLST] EQL 0		! AND NO MODULES WERE LOADED
    THEN BEGIN								! WE DO NOT NEED IT ANYMORE
	IF (PREVIOUS_FDB[FDB$L_NXTFDB] = .LNK$GL_CURFIL[FDB$L_NXTFDB])	! SO REMOVE FROM THE LIST
			EQL 0						! AND IF LAST ON THIS
	    THEN LNK$GL_CURCLU[CLU$L_LSTFDB] = .PREVIOUS_FDB;		! CLUSTER LIST, FIX EOL POINTER
!**THIS IS A PROBLEM...THE BLOCK CAN'T BE DEALLOCATED!!!
!***	LNK$DEALBLK(FDB$C_SIZE+NAM$C_BLN,.LNK$GL_CURFIL);		! AND DISPOSE OF ITS DESCRIPTOR
	END
    ELSE PREVIOUS_FDB = .LNK$GL_CURFIL;				! IF NOT EMPTY LIB, IT BECOMES THE PREVIOUS
    END;
WHILE (LNK$GL_CURFIL = .PREVIOUS_FDB[FDB$L_NXTFDB]) EQL 0	! GET NEXT FILE ON THIS CLUSTER LIST
	OR (.LNK$GL_CURFIL[FDB$V_P1] AND .LNK$GB_PASS EQL 1)
DO IF .LNK$GL_CURCLU[CLU$L_NXTCLU] EQL 0			! BUT IF THE END AND LAST CLUSTER
    AND ( .LNK$GB_PASS EQL 1					! OR THE DEFAULT CLUSTER ON
    AND .NEXTINTFIL NEQ 0)					! AND WE HAVE NOT PROCESSED DEFAULT LIBRARIES YET
	AND .LNK$GW_NUDFSYMS NEQ 0				! AND THERE ARE STILL UNDEFINED SYMBOLS
	AND (((.NEXTINTFIL EQL 3) AND .LNK$GL_CTLMSK[LNK$V_USRLIB])
	OR ((.NEXTINTFIL GTR 0) AND .LNK$GL_CTLMSK[LNK$V_SYSLIB]))
    THEN BEGIN
	LOCAL
	    FILEFLAGS;

	FILEFLAGS = FDB$M_LIBR OR FDB$M_LIBSRCH;	! SET DEFAULT FILE FLAGS
	IF .FIRST_TIME					! IF THIS IS THE FIRST TIME
	    OR .DEFAULT_LIB				! OR IF PROCESSING USER LIBRARIES
	THEN BEGIN
	    FIRST_TIME = FALSE;				! NO LONGER FIRST TIME
	    IF NOT .LNK$GL_CTLMSK[LNK$V_USRLIB] 	! IF USER LIBRARIES ARE DISABLED
		OR NOT TRAN_NEXT_LIB()			! OR NO MORE DEFAULT LIBRARIES
	    THEN BEGIN
		NEXTINTFIL = 2;				! JUST SKIP IT
		DEFAULT_LIB = FALSE;			! DISABLE USER LIBRARIES
		LNK$GL_CTLMSK[LNK$V_USRLIB] = FALSE;
		IF NOT .LNK$GL_CTLMSK[LNK$V_SYSLIB] 	! IF SYSLIB DISABLED
		THEN BEGIN
		    LNK$GL_CURFIL = 0;			! RETURN NO MORE FILES
		    RETURN FALSE;
		    END;
		END
	    ELSE BEGIN
		DEFAULT_LIB = TRUE;			! FLAG PROCESSING DEFAULT LIBRARIES
		USERLIBNO = .USERLIBNO + 1;		! SET FOR NEXT LIBRARY
		NEXTINTFIL = 3;				! ENSURE INDEX IS CORRECT
		END;
	    END;
	IF .NEXTINTFIL EQL 2				! IF READY TO PROCESS IMAGELIB
	    THEN IF NOT .LNK$GL_CTLMSK[LNK$V_SYSSHR]	! IF /NOSYSSHR WAS SPECIFIED
		THEN NEXTINTFIL = 1;			!  THEN SKIP SEARCH OF IMAGELIB
	IF (.DEFAULT_LIB OR .NEXTINTFIL EQL 1)		! IF DOING A DEFAULT OBJECT LIBRARY
	THEN BEGIN					! THEN WE NEED A DIFFERENT CLUSTER
	    LNK$GL_CURCLU = LNK$GL_DEFCLU;		! SET SEARCH TO KNOWN USER CLUSTER
	    IF .LNK$GL_DEFCLU[CLU$L_FSTFDB] EQL 0	! IF NO FILES IN THE CLUSTER
		AND .LNK$GL_DEFCLU[CLU$L_NXTCLU] EQL 0	!  AND IT HAS NO CLUSTER FOLLOWING IT
		AND .LNK$GL_LASTCLU NEQ LNK$GL_DEFCLU	!  AND IT ISN'T THE LAST CLUSTER
	    THEN BEGIN					! THEN WE MUST LINK INTO CLUSTER LIST
		LNK$GL_LASTCLU[CLU$L_NXTCLU] = LNK$GL_DEFCLU;
		LNK$GL_LASTCLU = LNK$GL_DEFCLU;
		END;
	    END;
	PREVIOUS_FDB = .LNK$GL_CURCLU[CLU$L_LSTFDB];	! PREVIOUS FILE IS LAST
	LNK$ALLOFDB(PREVIOUS_FDB[FDB$L_NXTFDB]);	! ALLOCATE A FILE DESCRIPTOR
	LNK$GL_CURFIL = .PREVIOUS_FDB[FDB$L_NXTFDB];	! AND MAKE IT CURRENT
	LNK$GL_CURCLU[CLU$L_LSTFDB] = .LNK$GL_CURFIL;	! AND SET NEW LAST FDB
	LNK$GL_CURFIL[FDB$B_FILFLGS] = .FILEFLAGS;	! SET APPROPRIATE FLAGS
	IF .DEFAULT_LIB					! IF THIS IS THE DEFAULT USER LIBRARY
	    THEN BEGIN
		CH$MOVE(DSC$C_S_BLN,LIBNAMDESCR,LNK$GL_CURFIL[FDB$W_USRNAMLEN]);
		CH$MOVE(DSC$C_S_BLN,LIBDEFEXT,LNK$GL_CURFIL[FDB$W_DEFNAMLEN]);
		END
	    ELSE BEGIN
		CH$MOVE(DSC$C_S_BLN,INTFILTBL[.NEXTINTFIL-1],LNK$GL_CURFIL[FDB$W_USRNAMLEN]);
		CH$MOVE(DSC$C_S_BLN,SYSLIBDEFEXT,LNK$GL_CURFIL[FDB$W_DEFNAMLEN]);
		END;
	IF NOT .DEFAULT_LIB
	    THEN LNK$GL_CTLMSK[LNK$V_INTFIL] = TRUE;	! RECORD WE ARE DOING THIS
	NEXTINTFIL = .NEXTINTFIL - 1;			! REDUCE FILE NUMBER
	EXITLOOP;
	END
ELSE BEGIN						! IF NOT LAST CLUSTER
    LNK$GL_CURCLU = .LNK$GL_CURCLU[CLU$L_NXTCLU];	! MOVE TO NEXT
    IF .LNK$GL_CURCLU EQL 0
    THEN BEGIN
	LNK$GL_CTLMSK[LNK$V_INTFIL] = FALSE;		! TURN OFF INTERNAL FLAG
	LNK$GL_CURFIL = 0;
	RETURN FALSE;					! AND RETURN NO MORE FILES
	END;
    PREVIOUS_FDB = LNK$GL_CURCLU[CLU$L_FSTFDB];		! RESET TO TOP OF FILE LIST
    END;

AUXFNB = LNK$GL_CURFIL[FDB$T_AUXFNB];				! POINT TO AUXILIARY FILENMAME BLOCK
$FAB_INIT(FAB=INPUT_FAB,
	FAC=GET,
	FOP=SQO,
	MRS=OBJ$C_MAXRECSIZ,
	NAM=.AUXFNB);
IF .AUXFNB[NAM$W_FID_NUM] EQL 0				! FILE APPENDED TO THE LIST OR FILE HAS NEVER BEEN OPENED
THEN BEGIN							
	INPUT_FAB[FAB$B_FNS] = .LNK$GL_CURFIL[FDB$W_USRNAMLEN];	! IT HAS NEVER BEEN OPENED, SO SET
	INPUT_FAB[FAB$L_FNA] = .LNK$GL_CURFIL[FDB$L_USRNAMADR]; ! THE FILE NAME LENGTH AND ADDRESS
	INPUT_FAB[FAB$B_DNS] = .LNK$GL_CURFIL[FDB$W_DEFNAMLEN];	! SET DEFAULT NAME STRING SIZE
	INPUT_FAB[FAB$L_DNA] = .LNK$GL_CURFIL[FDB$L_DEFNAMADR];	! AND ADDRESS
     END							! AND WITHOUT NAME BLOCK OPEN MECHANISM
ELSE INPUT_FAB[FAB$V_NAM] = TRUE;				! OTHERWISE SET OPEN BY FILE ID FLAG
IF .LNK$GL_CURFIL[FDB$V_LIBR]					! IF FILE IS A LIBRARY
THEN BEGIN
    IF (OPENERROR = LNK$OPENLIB(.AUXFNB))			! THEN OPEN DIFFERENTLY
	THEN BEGIN
	    IF .LNK$GL_CTLMSK[LNK$V_INTFIL]			! IF THIS IS THE INTERNAL SHAREABLE IMAGE STB LIBRARY
		AND .NEXTINTFIL EQL 1				!  (REMEMBER NEXTINTFIL HAS BEEN DECREMENTED)
		THEN IF NOT .LNK$GL_CURFIL[FDB$V_IMGLIB]	!  BUT DID NOT TURN OUT TO BE SHAREABLE IMAGE STB LIBRARY
		    THEN BEGIN
			SIGNAL(LIN$_NOTIMGLIB,1,		! ISSUE THE MESSAGE
				LNK$GL_CURFIL[FDB$Q_FILENAME]);
			LNK$CLOSCURFIL();			! CLOSE THE FILE
			LNK$GL_CURFIL[FDB$V_LIBR] = TRUE;	! FORCE DESCRIPTOR TO EVAPORATE
			RETURN LNK$NXTFIL();			! RECURSE TO DISPOSE OF DESCRIPTOR AND RETURN NEXT FILE
			END;
	    LNK$GL_RECORD = 0;					! INIT RECORD COUNTER
	    RETURN TRUE;
	    END;
    RMSSTV = .LBR$GL_RMSSTV;					! THERE WAS AN ERROR. SET STV
    END
ELSE BEGIN
IF .LNK$GL_CURFIL[FDB$V_SHR]				! IF A SHAREABLE IMAGE FILE SET TO OPEN FOR BOTH
THEN BEGIN
    INPUT_FAB[FAB$V_SQO] = FALSE;			! NOT SEQUENTIAL ONLY
    INPUT_FAB[FAB$V_BRO] = TRUE;			! RECORD AND BLOCK OPERATIONS
    INPUT_FAB[FAB$V_UPI] = TRUE;			! SHARED ACCESS
    INPUT_FAB[FAB$V_SHRGET] = TRUE;			! SET FOR SHARED GETS
    INPUT_FAB[FAB$V_SHRPUT] = TRUE;			! AND PUTS (LINKER DOESN'T, BUT MUST SET SO WE
							!  CAN READ IT IN CASE INSTALLED /WRITE)
    END;
IF (
	OPENERROR = $OPEN(FAB = INPUT_FAB);		! ATTEMPT TO OPEN IT
	IF NOT .OPENERROR				! IF IT FAILED
	    AND .LNK$GL_CURCLU[CLU$V_INTCLU]		!  AND THIS IS INTERNALLY MATERIALIZED CLUSTER
	THEN BEGIN
	    INPUT_FAB[FAB$B_DNS] = .SHRDEFEXT[0];	! TRY SYS$LIBRARY:
	    INPUT_FAB[FAB$L_DNA] = .SHRDEFEXT[1];
	    OPENERROR = $OPEN(FAB = INPUT_FAB);		!
	    END;
	RMSSTV = .INPUT_FAB[FAB$L_STV];
	.OPENERROR)
THEN BEGIN						! AND IF SUCCESSFUL
	INPUT_IFI = .INPUT_FAB[FAB$W_IFI];		! SAVE IFI FOR LATER CLOSE
	CH$MOVE(DSC$C_S_BLN,LNK$FILNAMDSC(INPUT_FAB),	! SAVE THE RESULTANT FILE NAME
			LNK$GL_CURFIL[FDB$Q_FILENAME]);	!  IN CASE OF ERROR LATER
	IF .LNK$AL_RAB[RAB$L_UBF] EQL 0			! ALLOCATE A USER BUFFER (IF NECESSARY)
	THEN BEGIN						! WITH A SIZE WHICH IS
		LNK$AL_RAB[RAB$W_USZ] = OBJ$C_MAXRECSIZ; 	!  MAX ALLOWABLE OBJECT RECORD
		LNK$ALLOBLK(.LNK$AL_RAB[RAB$W_USZ],	! FOR RMS TO USE ON RECORDS THAT
			LNK$AL_RAB[RAB$L_UBF]);		! CROSS BLOCK BOUNDARIES
	     END;					! AND FOR READING LIBRARY HEADERS
	LNK$AL_RAB[RAB$L_FAB] = INPUT_FAB;		! SET FAB POINTER
	LNK$AL_RAB[RAB$W_ISI] = 0;			! ENSURE IT IS RE-USABLE RAB
	IF (
		OPENERROR = $CONNECT(RAB=LNK$AL_RAB);	! AND ATTEMPT TO CONNECT IT
		RMSSTV = .LNK$AL_RAB[RAB$L_STV];
		.OPENERROR)
	THEN BEGIN					! AND IF SUCCESSFUL
		IF .LNK$GL_CURFIL[FDB$V_SHR]			! FINALLY IF THIS IS A SHAREABLE IMAGE
								! TELL RMS WHAT I KNOW ABOUT THE
		THEN BEGIN					! THE RECORDS OF THE FILE I.E.
			INPUT_FAB[FAB$V_ESC] = TRUE;		! RMS $MODIFY FUNCTION WHICH WILL TELL
			INPUT_FAB[FAB$L_CTX] = RME$C_SETRFM;	! RMS THAT THIS IS A VARIABLE
			INPUT_FAB[FAB$B_RFM] = FAB$C_VAR;	! LENGTH RECORD FILE, EVEN THOUGH THE
			IF (
			OPENERROR = $MODIFY(FAB=INPUT_FAB);	! THE RECORDS OF THE FILE ARE FIXED
			RMSSTV = .INPUT_FAB[FAB$L_STV];
			.OPENERROR)
			THEN (LNK$GL_RECORD = 0; RETURN TRUE)	! AND THAT IS ALL IF IT SUCCEEDS
		     END
		ELSE (LNK$GL_RECORD = 0; RETURN TRUE);
	     END;
     END;				! IF ANY OF THE ABOVE FAILS
END;								! FILE WAS NOT A LIBRARY
LNK$CLOSCURFIL();					! ATTEMPT CLOSE 
							! ISSUE MESSAGES
ERRORCODE = LIN$_OPENIN;				! SET ERROR CODE
IF .LNK$GL_CTLMSK[LNK$V_INTFIL]				! IF AN INTERNAL FILE
    OR .DEFAULT_LIB
    THEN ERRORCODE[STS$V_SEVERITY] = STS$K_INFO		! THEN NOT FATAL
    ELSE ERRORCODE[STS$V_SEVERITY] = STS$K_SEVERE;	! OTHERWISE IT IS
SIGNAL(.ERRORCODE,1,					! FIRST THE LINK PASS NUMBER
		LNK$FILNAMDSC(INPUT_FAB),
				.OPENERROR,.RMSSTV);
IF .LNK$GL_CURCLU[CLU$V_INTCLU]				! IF THIS IS INTERNALLY CREATED CLUSTER
THEN BEGIN
    LNK$GL_CURCLU[CLU$L_SHRLST] = 0;			! CLEAR INFO LEFT AROUND FOR CONSISTENCY CHECKS
    LNK$GL_CURCLU[CLU$L_ADRCNT] = 0;
    LNK$GL_CURCLU[CLU$L_ADRLEFT] = 0;
    END;
LNK$GL_CURFIL[FDB$V_LIBR] = TRUE;			! UNCONDITIONALLY MAKE IT A LIBRARY SO THAT
							!  IT'S DESCRIPTOR WILL BE EVAPORATED
RETURN LNK$NXTFIL();				! RECURSING TO DISPOSE OF ITS DESCRIPTOR
END;			! OF LNK$NXTFIL ROUTINE

GLOBAL ROUTINE LNK$NXTREC (RECDESC) =
BEGIN
!
!	READ NEXT RECORD FROM CURRENTLY OPEN FILE.
!	THIS ROUTINE ACQUIRES RECORDS SEQUENTIALLY
!	UNTIL END OF FILE IS DETECTED, IN WHICH
!	CASE IT HAS THE VALUE FALSE. SUCCESSFUL READS RETURN
!	THE ADDRESS AND LENGTH OF NEXT RECORD AND THE ROUTINE
!	HAS THE VALUE TRUE
!
MAP
    RECDESC : REF BLOCK[,BYTE];

LOCAL
    STVCODE,
    READERROR,							! READ ERROR CODE
    BUFDESC : BLOCK[DSC$C_S_BLN,BYTE];				! DESCRIPTOR FOR BUFFER
!
BIND AUXFNB = LNK$GL_CURFIL[FDB$T_AUXFNB]		! REFERENCE THE AUXILIARY FILE NAME BLOCK PART
			: BLOCK[NAM$C_BLN,BYTE];
!
IF .LNK$GL_CURFIL[FDB$V_LIBR]					! IF READING A LIBRARY FILE
THEN BEGIN
    BUFDESC[DSC$W_LENGTH] = .LNK$AL_RAB[RAB$W_USZ];		! SET UP DESCRIPTOR FOR BUFFER
    BUFDESC[DSC$A_POINTER] = .LNK$AL_RAB[RAB$L_UBF];
    READERROR = LBR$GET_RECORD(INPUT_IFI, BUFDESC, BUFDESC);	! READ A RECORD
    LNK$AL_RAB[RAB$L_STV] = .LBR$GL_RMSSTV;
    LNK$AL_RAB[RAB$W_RSZ] = .BUFDESC[DSC$W_LENGTH];		! SET INFO INTO RAB
    LNK$AL_RAB[RAB$L_RBF] = .BUFDESC[DSC$A_POINTER];		! ...
    END
ELSE READERROR = $GET(RAB=LNK$AL_RAB);				! NOT LIBRARY, JUST DO A GET
IF NOT .READERROR						! IF THERE WAS AN ERROR OTHER THAN
THEN IF .READERROR NEQ RMS$_EOF				! AND IF AN ERROR OTHER THAN
	THEN BEGIN					! END OF FILE
		STVCODE = .LNK$AL_RAB[RAB$L_STV];	! SAVE STV OVER CLOSE
		LNK$CLOSCURFIL();			! ATTEMPT TO CLOSE IT
		SIGNAL(LIN$_READERR,1,			! ISSUE READ ERROR MESSAGE
			LNK$GL_CURFIL[FDB$Q_FILENAME],
			.READERROR,.STVCODE);
		RETURN FALSE;
	     END
	ELSE RETURN FALSE;				! ALL DONE IF END OF FILE
!
LNK$GL_OBJRECS = .LNK$GL_OBJRECS + 1;			! 
LNK$GL_RECORD = .LNK$GL_RECORD + 1;
RECDESC[DSC$W_LENGTH] = .LNK$AL_RAB[RAB$W_RSZ];		! RETURN LENGTH AND ADDRESS OF THIS
RECDESC[DSC$A_POINTER] = .LNK$AL_RAB[RAB$L_RBF];	! SUCCESSFULLY OBTAINED RECORD
RETURN TRUE						! AND ALL IS DONE
END;					! OF LNK$NXTREC ROUTINE

GLOBAL ROUTINE LNK$POINTOBJ(MODRFA) : NOVALUE =
BEGIN
!
!++
!
!	THIS ROUTINE IS CALLED DURING LIBRARY OR SHAREABLE IMAGE FILE READING TO POINT TO
!	THE REQUIRED PARTITION IN THE FILE GIVEN BY ITS RFA.
!	FOR A LIBRARY THE NEXT GET WILL READ THE LIBRARY MODULE'S HEADER RECORD.
!	FOR A SHAREABLE IMAGE FILE MERELY DO A FIND BY RFA SO THAT NO RECORD IS
!	SKIPPED. I.E. NEXT GET GETS RECORD POINTED TO.
!
MAP MODRFA : REF BLOCK[,BYTE];				! POINTER TO RFA BLOCK
!
LOCAL
	STATUS,
	HDRDESC : BLOCK[DSC$C_S_BLN,BYTE],		! STRING DESCRIPTOR FOR MODULE HEADER
	LIBMODHDR : REF BLOCK[,BYTE],			! POINTER TO LIBRARY MODULE HEADER
	RECLNG;						! LENGTH OF RECORD
!
BIND AUXFNB = LNK$GL_CURFIL[FDB$T_AUXFNB]		! REFERENCE THE AUXILIARY FILE NAME BLOCK PART
			: BLOCK[NAM$C_BLN,BYTE];	!
!
IF .LNK$GL_CURFIL[FDB$V_LIBR]				! IF THIS IS A LIBRARY FILE
THEN BEGIN
	LOCAL
		MODNAMDESC : BLOCK[DSC$C_S_BLN,BYTE],
		HEADER : BLOCK[LBR$C_MAXHDRSIZ,BYTE];

	IF .LNK$GB_PASS EQL 1					! ONLY READ HEADER ON PASS 1
	THEN BEGIN
	    HDRDESC[DSC$W_LENGTH] = LBR$C_MAXHDRSIZ;		! SET UP DESCRIPTOR FOR HEADER BUFFER
	    HDRDESC[DSC$A_POINTER] = HEADER;
	    IF NOT (STATUS = LBR$SET_MODULE(LNK$GL_INPUTIFI, .MODRFA, HDRDESC))
		THEN BEGIN
		    LNK$AL_RAB[RAB$L_STS] = .STATUS;		! ERROR - SET CODES INTO RAB
		    LNK$AL_RAB[RAB$L_STV] = .LBR$GL_RMSSTV;
		    END
		ELSE BEGIN
		    IF .HEADER[MHD$V_SELSRC]			! IF MODULE IS SELECTIVELY SEARCHED
			THEN LNK$GL_CURFIL[FDB$V_SELSER] = TRUE
			ELSE LNK$GL_CURFIL[FDB$V_SELSER] = FALSE;
		    RETURN TRUE;
		    END;
	    END
	    ELSE BEGIN							! PASS 2 -- NEED TO FIND MODULE
		IF (STATUS = LBR$FIND(LNK$GL_INPUTIFI, .MODRFA))	! POSITION TO READ MODULE
		    THEN RETURN TRUE;					! ALL DONE IF SUCCESSFUL
		MODNAMDESC[DSC$W_LENGTH] = .LNK$GL_CUROMD[OMD$B_NAMLNG];! IT APPEARS TO HAVE DISAPPEARED.  TRY A LOOKUP IN CASE
		MODNAMDESC[DSC$A_POINTER] = LNK$GL_CUROMD[OMD$T_NAME];	!  IT WAS MERELY REPLACED
		IF (STATUS = LBR$LOOKUP_KEY(LNK$GL_INPUTIFI,MODNAMDESC,	! ASK LIBRARIAN TO LOOKUP KEY
						.MODRFA))
		    THEN RETURN TRUE;
		LNK$AL_RAB[RAB$L_STS] = .STATUS;			! ERROR--SET CODES IN RAB
		LNK$AL_RAB[RAB$L_STV] = .LBR$GL_RMSSTV;
		END;
	END
ELSE BEGIN							! FILE IS NOT A LIBRARY
	LNK$AL_RAB[RAB$B_RAC] = RAB$C_RFA;			! SET TO ACCESS BY RFA
	LNK$AL_RAB[RAB$L_RFA0] = .MODRFA[RFA$L_VBN];		! SET UP RFA
	LNK$AL_RAB[RAB$W_RFA4] = .MODRFA[RFA$W_OFFSET];
	STATUS = $FIND(RAB=LNK$AL_RAB);				! PERFORM THE FIND
	LNK$AL_RAB[RAB$B_RAC] = RAB$C_SEQ;			! RESET TO SEQUENTIAL ACCESS
	IF .STATUS
	    THEN RETURN TRUE;					! ALL DONE IF GOOD FIND
	END;
SIGNAL(LIN$_LIBFIND, 4, .MODRFA[RFA$L_VBN],			! REPORT ERROR IF FALL THROUGH
		.MODRFA[RFA$W_OFFSET],
		LNK$GL_CUROMD[OMD$B_NAMLNG],
		LNK$GL_CURFIL[FDB$Q_FILENAME],
		LIN$_FORMAT,0,
		.STATUS,.LNK$AL_RAB[RAB$L_STV]);
RETURN;						! AND ALL SET
END;

GLOBAL ROUTINE LNK$CLOSCURFIL : NOVALUE =
BEGIN
!
!	THIS ROUTINE IS CALLED TO CLOSE THE CURRENTLY OPEN
!	OBJECT MODULE FILE IF ANY.
!
!	INPUT_IFI IS USED AS THE DETERMINANT OF WHETHER A FILE IS
!	CURRENTLY OPEN AND IS CLEARED WHEN DONE.
!
LOCAL
	INPUT_FAB : BLOCK[FAB$C_BLN,BYTE],	! FAB FOR THE CLOSE
	CLOSERROR;				! RMS ERROR CODE
!
BIND AUXFNB = LNK$GL_CURFIL[FDB$T_AUXFNB]	! REFERENCE THE AUXILIARY FILE NAME BLOCK PART
			: BLOCK[NAM$C_BLN,BYTE];!
!
IF .INPUT_IFI NEQ 0				! IF THERE IS A FILE OPEN
THEN BEGIN
	IF NOT .LNK$GL_CURFIL[FDB$V_LIBR]	! IF FILE IS NOT A LIBRARY
	THEN BEGIN
	$FAB_INIT(FAB=INPUT_FAB);		! INITIALIZE THE FAB
	INPUT_FAB[FAB$W_IFI] = .INPUT_IFI;	! SET THE FILE ID
	AUXFNB[NAM$B_RSS] = 0;			! ENSURE RMS DOES NOT ZERO
	AUXFNB[NAM$B_ESS] = 0;			! THE RESULTANT AND EXPANDED NAMES
	CLOSERROR = $CLOSE(FAB=INPUT_FAB);	! CLOSE THE FILE
	END
	ELSE BEGIN 
	    CLOSERROR = LBR$CLOSE(INPUT_IFI);			! CLOSE THE LIBRARY
	    INPUT_FAB[FAB$L_STV] = .LBR$GL_RMSSTV;
	    END;
	IF NOT .CLOSERROR
	THEN BEGIN
		SIGNAL(LIN$_CLOSEIN,1,			! ISSUING AN ERROR MESSAGE
		LNK$GL_CURFIL[FDB$Q_FILENAME],
		.CLOSERROR,.INPUT_FAB[FAB$L_STV]);	!
	     END;
	INPUT_IFI = 0;				! CLEAR THE IDENTIFIER
     END;
RETURN;
END;

ROUTINE TRAN_NEXT_LIB =
BEGIN
!
!	THIS ROUTINE RETURNS THE VALUE TRUE IF THERE IS ANOTHER DEFAULT LIBRARY
!	TO PROCESS AND FALSE IF NOT.  IF THERE IS ANOTHER LIBRARY, THE FILENAME
!	IS SET UP IN THE VECTOR RESULTSTRING WITH ITS DESCRIPTOR IN LIBNAMDESCR.
!
BIND
	MAXLIBLNG = %CHARCOUNT('LNK$LIBRARY_999');		! MAX LIBRARY LOGICAL NAME LENGTH
OWN
	LNKLIBNAM : VECTOR[%CHARCOUNT('LNK$LIBRARY')+1,BYTE]	! THE INITIAL DEFAULT LIBRARY NAME
			INITIAL (%ASCII'LNK$LIBRARY');
LOCAL
	TRANCODE,
	DEFLIBNAM : VECTOR[MAXLIBLNG,BYTE],			! TO RECEIVE THE FORMATTED LOGICAL NAME
	NAMPTR : VECTOR[2];					! DESCRIPTOR OF DEFLIBNAM
!
IF .LNK$GL_ULIBMASK [2 - .DEFLIBACMODE] NEQ 0			! IF THIS LOGICAL NAME TABLE ENABLED
THEN BEGIN
NAMPTR[0] = MAXLIBLNG;						! INIT THE DESCRIPTOR
NAMPTR[1] = DEFLIBNAM;
IF .USERLIBNO EQL 0						! IF THIS IS FIRST IN THIS TABLE
THEN BEGIN
    NAMPTR[0] = %CHARCOUNT('LNK$LIBRARY');			! SET THE COPY LENGTH
    CH$MOVE(.NAMPTR[0],LNKLIBNAM[0],DEFLIBNAM);			! COPY THE NAME
    END
ELSE IF NOT SYS$FAO(LIBNAMEFAO,NAMPTR,NAMPTR,.USERLIBNO)	! OTHERWISE MUST FAO IT
	THEN RETURN FALSE;					! AND GIVE UP IF IT FAILS
!
! NOW TRANSLATE THE LOGICAL NAME
!
LIBNAMDESCR[0] = NAM$C_MAXRSS;					! RESET STRING DESCRIPTOR
TRANCODE=$TRNLOG(LOGNAM=NAMPTR,DSBMSK=.DEFLIBDSBMSK[.DEFLIBACMODE],
		RSLLEN=LIBNAMDESCR,RSLBUF=LIBNAMDESCR);		! TRANSLATE THE NAME
IF (.TRANCODE AND (.TRANCODE NEQ SS$_NOTRAN)) THEN RETURN TRUE;	! IF GOT A GOOD NAME RETURN WITH IT
END;
!
! FAILED. MOVE ON TO NEXT GROUP
!
IF (DEFLIBACMODE = .DEFLIBACMODE+1) GTR 2			! BUT IF WE ARE ALL DONE
THEN RETURN FALSE;						! THEN RETURN NO MORE
USERLIBNO = 0;							! OTHERWISE RESET LIBRARY NUMBER
RETURN TRAN_NEXT_LIB();						! AND RECURSE TO RETURN NEXT LIBRARY
END;

ROUTINE LNK$OPENLIB (NAMEBLOCK) =
BEGIN
!
! THIS ROUTINE OPENS A LIBRARY FILE USING THE LIBRARY ACCESS PROCEDURES.
!
MAP
    NAMEBLOCK : REF BLOCK[,BYTE];

LOCAL
    LIBRARYFUNC,
    STATUS,
    FILNAMDESC : BLOCK[DSC$C_S_BLN,BYTE],
    INDEX;

BIND
    FDBFILENAME = LNK$GL_CURFIL[FDB$Q_FILENAME] : BLOCK[,BYTE];

LIBRARYFUNC = LBR$C_READ;					! SET TO READ 
IF NOT (STATUS = LBR$INI_CONTROL(INDEX, LIBRARYFUNC, 0, 	! INITIALIZE INDEX
				.NAMEBLOCK))
    THEN RETURN .STATUS;					! AND RETURN IF ERROR
IF .LNK$GB_PASS EQL 1
THEN BEGIN
    STATUS = LBR$OPEN(INDEX, LNK$GL_CURFIL[FDB$Q_USRNAMDSC],0,	! OPEN LIBRARY FOR READING
					LNK$GL_CURFIL[FDB$W_DEFNAMLEN]);
    FDBFILENAME[DSC$W_LENGTH] = .NAMEBLOCK[NAM$B_RSL];		! SET NAME DESCRIPTOR
    FDBFILENAME[DSC$A_POINTER] = .NAMEBLOCK[NAM$L_RSA];
    END
ELSE STATUS = LBR$OPEN(INDEX);					! IN PASS 2 CAN OPEN BY NAM BLOCK
IF .STATUS 
THEN BEGIN
    INPUT_IFI = .INDEX;						! IF SUCCESSFUL OPEN, SET INDEX FOR CLOSE
    LBR$GL_CONTROL[LBR$V_LOCATE] = TRUE;			! SET LOCATE MODE
    IF .LBR$GL_RMSSTV EQL LBR$C_TYP_SHSTB			! IF SHAREABLE IMAGE SYMBOL TABLE LIBRARY
	THEN LNK$GL_CURFIL[FDB$V_IMGLIB] = TRUE			!  THEN MARK IT AS SUCH
	ELSE IF .LBR$GL_RMSSTV NEQ LBR$C_TYP_OBJ		!  OTHERWISE IF NOT AN OBJECT LIBRARY
	    THEN SIGNAL_STOP(LIN$_NOTOBJLIB,1,FDBFILENAME);	!  THEN SIGNAL ERROR AND GIVE UP
    IF .LNK$AL_RAB[RAB$W_USZ] EQL 0
    THEN BEGIN
	LNK$AL_RAB[RAB$W_USZ] = OBJ$C_MAXRECSIZ;
	LNK$ALLOBLK(.LNK$AL_RAB[RAB$W_USZ], LNK$AL_RAB[RAB$L_UBF]);
	END;
    END;
RETURN .STATUS
END;							! OF LNK$OPENLIB
END ELUDOM
