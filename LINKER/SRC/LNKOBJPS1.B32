MODULE LNK_OBJPASS1 (
			ADDRESSING_MODE(EXTERNAL=GENERAL,
					NONEXTERNAL=LONG_RELATIVE),
			IDENT='V03-024') =

BEGIN
!
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
!
!
!
!++
!
! MODULE: LNK_OBJPASS1
!
! FACILITY: LINKER
!
! ABSTRACT:
!
! PASS ONE OF ALL OBJECT MODULES OF THIS LINK.
!
! HISTORY:
!
!	VERSION: X01.00
!
!	AUTHOR: T.J. PORTER 30-DEC-76
!
! MODIFIED BY:
!
!	V03-024	BLS0161		Benn Schreiber		19-Mar-1982
!		Correct V03-021 handling of selective search procedures
!
!	V03-023	BLS0159		Benn Schreiber		17-Mar-1982
!		Correct handling of link options record.  Reset currectyp
!		if end of module record not found.
!
!	V03-022	BLS0155		Benn Schreiber		 1-Mar-1982
!		Call proeom if no end of module record seen (housekeeping)
!
!	V03-021 BLS0149		Benn Schreiber		13-Feb-1982
!		Don't store procedure info if selective search symbol that
!		was not referenced.  It used to end up storing procedure info 
!		for previous symbol found.
!
!	V03-020	BLS0131		Benn Schreiber		 4-Jan-1982
!		Do not clear lnk$gl_curomd until end of pass 1.
!
!	V03-019	BLS0120		Benn Schreiber		13-Dec-1981
!		Disable check for psect multiply defined in an object module
!		until C issue is resolved.
!	V03-018	BLS0114		Benn Schreiber		 2-Dec-1981
!		Check for eomw in seqchk
!
!	V03-017	BLS0111		Benn Schreiber		22-Nov-1981
!		Complete shareable image psect handling
!
!	V03-016	BLS0105		Benn Schreiber		13-Nov-1981
!		Add shareable image psect type
!
!	V03-015	BLS0090		Benn Schreiber		31-Oct-1981
!		Environments and module-local symbols
!
!	V03-014	BLS0081		Benn Schreiber		16-Sep-1981
!		Add entity ident consistency check
!
!	V03-013	BLS0077		Benn Schreiber		 3-Sep-1981
!		Only check psect attribute bits for conflicting attributes
!
!	V03-012	BLS0074		Benn Schreiber		29-Aug-1981
!		Call to lnk$nxtrec only has 1 arg now, other random
!		corrections.
!
!	V03-011	BLS0051		Benn Schreiber		20-Apr-1981
!		Make undefs absolute rather than relative 0
!
!	V03-010	BLS0050		Benn Schreiber		23-Mar-1981
!		Independent shareable images
!
!	V03-009	BLS0042		Benn Schreiber		25-Feb-1981
!		Remove deferred relocation code
!
!	V03-008	BLS0035		Benn Schreiber		 8-Jan-1981
!		Support 65K psects
!
!	V03-007	BLS0034		Benn Schreiber		 7-Jan-1981
!		Correct error in weak transfer address handling
!
!	V03-006	BLS0029		Benn Schreiber		29-Dec-1980
!		Check creation date/time if shr image from shr image
!		stb library
!
!	V03-005	BLS0030		Benn Schreiber		21-Dec-1980
!		Move check for symbol name length into crefilter
!
!	V03-004	BLS0026		Benn Schreiber		22-Nov-1980
!		UNIVERSAL='ALL'
!
!	V03-003	BLS0019		Benn Schreiber		4-Sep-1980
!		Minor corrections to structure accesses due to MDL changes.
!
!	V03-002	BLS0009		Benn Schreiber		8-Jul-1980
!		Check for shareable image before checking for too many COMMONS.
!
!	V03-001	BLS0007		Benn Schreiber,		3-Jun-1980
!		Convert to MDL data structures.
!
!--

!
!++
!
! FUNCTIONAL DESCRIPTION:
!
! THIS ROUTINE IS CALLED TO PROCESS ALL OBJECT MODULES
! DURING PASS ONE OF THE LINK. IT VALIDATES OBJECT MODULE 
! FORMAT, READS THE MODULE HEADER, ALL GSD AND THE
! END OF MODULE RECORDS AND BUILDS SYMBOL AND P-SECTION
! TABLES. IT IS IN THIS ROUTINE ALONE THAT THE LINKER
! DETERMINES WHETHER THE MODULE IS CONCATENATED. IT IS
! ALSO HERE THAT ANY USER DEFINED TRANSFER ADDRESS IS
! EXTRACTED.
!
! THIS ROUTINE IGNORES THE CONTENT OF TIR, DBG AND LNK RECORDS.
!
!--

REQUIRE
	'PREFIX';

FORWARD ROUTINE
	PROLNKREC,			! PROCESS LINKER OPTIONS RECORD
	CHECKPDDENTRY,			! CHECK PSECT DEF. ENTRY AND DEFINE IT
	LNK$INSUDFSYM : NOVALUE,	! INSERT SYMBOL IN UNDEFINED SYMBOL LIST
	SEQCHK,				! CHECK RECORD SEQUENCE
	PROHDR,				! PROCESS MODULE HEADER RECORDS
	DELETE_PSECT,			! DELETE SHAREABLE IMAGE PSECT FROM OTHER CLUSTERS
	FNDPSCMAPENT,			! FIND PSECT MAPPING TABLE ENTRY
	ALLOC_OMDNODE,			! ALLOCATE OMD NODE BLOCK
	LNK$COMPARE_OMD,		! COMPARE OMD NODE BLOCKS
	PROPSECTDEF,			! PROCESS PSECT DEFINITIONS
	CREFILTER,			! CROSS REFERENCE FILTER FOR SYMBOLS
	PROSYMBOL,			! PROCESS SYMBOLS
	SYMBOLS,			! FRONT END FOR SYMBOL DEFS/REFS
	ENTPNTS,			! FRONT END FOR ENTRY POINTS
	PROCEDEF,			! FRONT END FOR PROCEDURE DEFINITIONS
	PROEOM,				! PROCESS END OF MODULE RECORDS
	COUNTDBG,			! COUNT DEBUG AND TRACEBACK RECORDS
	COMPARE_IDC,			! COMPARE RANDOM IDENT BLOCKS
	ALLOC_IDC,			! ALLOCATE RANDOM IDENT BLOCK
	RANDENTITY,			! PROCESS RANDOM IDENTS
	COMPARE_ENV,			! COMPARE ENVIRONMENT BLOCKS
	ALLOC_ENV,			! ALLOCATE ENVIRONMENT BLOCK
	INSUDFENV : NOVALUE,		! INSERT UNDEFINED ENVIRONMENT
	LNK$FNDENVMAP,			! FIND ENVIRONMENT MAPPING TABLE ENTRY
	PROENV,				! PROCESS ENVIRONMENT
	LOCALSYMBOLS,			! FRONT END FOR LOCAL SYMBOLS
	LOCALENTPNT,			! FRONT END FOR LOCAL ENTRY POINTS
	LOCALPROCEDEF,			! FRONT END FOR LOCAL PROCEDURE DEFS
	PROGSD,				! PROCESS GSD RECORDS
	LNK$PROCSOBJ,			! PROCESS AN OBJECT MODULE
	LNK$OBJPASS1;			! DO PASS 1
!
LIBRARY
	'LIBL32';			! SYSTEM DATA STRUCTURES
LIBRARY
	'DATBAS';			! INTERNAL DATA BASE DEFINITIONS
REQUIRE
	'ISGENC';			! IMAGE SECTION DEFINITIONS AND OBJECT LANG. DEFS.
!
!
! ENSURE THAT SYM$ SYMBOLS CORRESPOND TO GSY$ SYMBOLS
!  AND THE PSC$ SYMBOLS CORRESPOND TO GPS$ SYMBOLS
!
%IF (SYM$M_WEAK AND GSY$M_WEAK) EQL 0
    %THEN %WARN('SYM$M_WEAK NEQ GSY$M_WEAK')
    %FI;
%IF (SYM$M_DEF AND GSY$M_DEF) EQL 0
    %THEN %WARN('SYM$M_DEF NEQ GSY$M_DEF')
    %FI;
%IF (SYM$M_UNI AND GSY$M_UNI) EQL 0
    %THEN %WARN('SYM$M_UNI NEQ GSY$M_UNI')
    %FI;
%IF (SYM$M_REL AND GSY$M_REL) EQL 0
    %THEN %WARN('SYM$M_REL NEQ GSY$M_REL')
    %FI;
%IF (PSC$M_PIC AND GPS$M_PIC) EQL 0
    %THEN %WARN('PSC$M_PIC NEQ GPS$M_PIC')
    %FI;
%IF (PSC$M_LIB AND GPS$M_LIB) EQL 0
    %THEN %WARN('PSC$M_LIB NEQ GPS$M_LIB')
    %FI;
%IF (PSC$M_OVR AND GPS$M_OVR) EQL 0
    %THEN %WARN('PSC$M_OVR NEQ GPS$M_OVR')
    %FI;
%IF (PSC$M_REL AND GPS$M_REL) EQL 0
    %THEN %WARN('PSC$M_REL NEQ GPS$M_REL')
    %FI;
%IF (PSC$M_GBL AND GPS$M_GBL) EQL 0
    %THEN %WARN('PSC$M_GBL NEQ GPS$M_GBL')
    %FI;
%IF (PSC$M_SHR AND GPS$M_SHR) EQL 0
    %THEN %WARN('PSC$M_SHR NEQ GPS$M_SHR')
    %FI;
%IF (PSC$M_EXE AND GPS$M_EXE) EQL 0
    %THEN %WARN('PSC$M_EXE NEQ GPS$M_EXE')
    %FI;
%IF (PSC$M_RD AND GPS$M_RD) EQL 0
    %THEN %WARN('PSC$M_RD NEQ GPS$M_RD')
    %FI;
%IF (PSC$M_WRT AND GPS$M_WRT) EQL 0
    %THEN %WARN('PSC$M_WRT NEQ GPS$M_WRT')
    %FI;
%IF (PSC$M_VEC AND GPS$M_VEC) EQL 0
    %THEN %WARN('PSC$M_VEC NEQ GPS$M_VEC')
    %FI;

GLOBAL LITERAL
    PSC$M_PSCBITS = PSC$M_PIC OR PSC$M_LIB OR PSC$M_OVR		! PSECT ATTRIBUTES ALL TOGETHER
		OR PSC$M_REL OR PSC$M_GBL OR PSC$M_SHR
		OR PSC$M_EXE OR PSC$M_RD OR PSC$M_WRT
		OR PSC$M_VEC,
    PSC$M_SHRBITS = PSC$M_GBL OR PSC$M_SHR OR PSC$M_OVR;	! PSECTS CONSIDERED FOR SHAREABLE IMAGE
EXTERNAL ROUTINE
	CRF$INSRTKEY,			! INSERT KEY IN CREF TABLE
	CRF$INSRTREF,			! INSERT REF TO KEY IN CREF TABLE
	LIB$INSERT_TREE,		! INSERT INTO BINARY TREE
	LIB$LOOKUP_TREE,		! LOOKUP IN BINARY TREE
	LIB$TRAVERSE_TREE,		! TRAVERSE BINARY TREE
	LNK$COMPARE_PSCNOD,		! COMPARE PSECT NAME WITH GPSLST NODE
	LNK$SRCPSCDEF,			! FIND PSECT DEFINED IN OPTION FILE
	LNK$BINTIM,			! CONVERT DATE/TIME TO BINARY
	LNK$ALLOBLK : NOVALUE, 		! DYNAMIC MEMORY ALLOCATION
	LNK$DEALBLK : NOVALUE,		! AND DEALLOCATION
	LNK$EXIT : NOVALUE,		! EXIT ROUTINE
	LNK$FNDPSCNAM,			! SEARCH FOR A P-SECTION ENTRY BY NAME
	LNK$INSERT,			! SYMBOL TABLE INSERTION
	LNK$LIBBUFDEAL : NOVALUE,	! DEALLOCATE LIBRARY BUFFER AND CLI WORK AREA
	LNK$NXTFIL,			! GET NEXT INPUT FILE
	LNK$NXTREC,			! OBTAIN NEXT RECORD OF OBJECT MODULE
	LNK$PROCSHRIM,			! PROCESS SHAREABLE IMAGES
	LNK$PROCSLIB,			! PROCESS AN OBJECT LIBRARY FILE
	LNK$SEARCH,			! SYMBOL TABLE SEARCH
	LNK$SEARCHLOCAL;		! MODULE-LOCAL SYMBOL TABLE SEARCH
!
EXTERNAL LITERAL
	LIB$_KEYALRINS,			! KEY ALREADY INSERTED IN TREE
	LIN$_BADCCC,			! BAD COMPILER COMPLETION CODE
	LIN$_BADPSC,			! ILLEGAL P-SECTION REFERENCED
	LIN$_DATMISMCH,			! CREATION DATE/TIME MISMATCH
	LIN$_EOMFTL,			! EOM RECORD SPECIFIES ABORT
	LIN$_ERRORS,			! COMPILATION HAD FATAL ERRORS
	LIN$_EXCPSC,			! TOO MANY PSECTS DEFINED
	LIN$_FATALERROR,		! FATAL ERROR MESSAGE ISSUED
	LIN$_FORMAT,			! OBJECT MODULE FORMAT ERROR
	LIN$_GSDTYP,			! ILLEGAL GSD TYPE
	LIN$_ENTIDMTCH,			! ASCIC IDENT MISMATCH
	LIN$_ENTIDMTCHB,		! BINARY IDENT MISMATCH
	LIN$_ENTIDMTCHO,		! IDENT OBJECT TYPE MISMATCH
	LIN$_ENTIDMTCHT,		! IDENT TYPE MISMATCH 
	LIN$_ILLFMLCNT,			! ILLEGAL FORMAL ARGUMENT COUNTS
	LIN$_ILLNAMELEN,		! ILLEGAL NAME LENGTH
	LIN$_ILLRECTYP,			! ILLEGAL RECORD TYPE
	LIN$_ILLRECLEN,			! ILLEGAL RECORD LENGTH
	LIN$_MODNAM,			! ILLEGAL MODULE NAME
	LIN$_MULDEF,			! MULTIPLE SYMBOL DEFINITION
	LIN$_MULDEFPSC,			! MULT. DEF OF PSECT IN SAME MODULE
	LIN$_MULPSC,			! MULTIPLE PSECT ATTRIBUTES DEF.
	LIN$_MULTFR,			! MULTIPLE TRANSFER ADDRESSES
	LIN$_MULSHRPSC,			! MULTIPLY DEFINED SHAREABLE IMAGE PSECT
	LIN$_NOEOM,			! MISSING END OF MODULE ERROR
	LIN$_NOIMGFIL,			! IMAGE FILE NOT CREATED
	LIN$_NOMODS,			! NO MODULES FOUND (IN THE LIBRARIES)
	LIN$_NOPSCTS,			! NO PROGRAM SECTIONS FOUND
	LIN$_NUDFENVS,			! NUMBER OF UNDEFINED ENVIRONMENTS
	LIN$_NUDFSYMS,			! NUMBER OF UNDEFINED SYMBOLS
	LIN$_NUDFLSYMS,			! NUMBER OF UNDEFINED LOCAL SYMBOLS
	LIN$_OVRALI,			! OVERLAYED P-SECTION WITH DIFFERERENT ALIGNMENT
	LIN$_PSCALI,			! ILLEGAL P-SECTION ALIGNMENT
	LIN$_PSCNXR,			! P-SECTION CONTAINING TRANSFER ADDRESS IS NOT EXE/REL
	LIN$_RECLNG,			! ILLEGAL RECORD LENGTH
	LIN$_RECTYP,			! ILLEGAL RECORD TYPE
	LIN$_SEQNCE,			! RECORDS IN ILLEGAL SEQUENCE
	LIN$_SHRPSCLNG,			! PSECT IN OBJ MOD BIGGER THAN ONE IN SHR IMAGE
	LIN$_STRLVL,			! ILLEGAL STRUCTURE LEVEL IN MODULE
	LIN$_UDFENV,			! LIST AN UNDEFINED ENVIRONMENT
	LIN$_UDFSYM,			! EACH UNDEFINED SYMBOL
	LIN$_WRNERS;			! COMPILER ISSUED WARNINGS
!
EXTERNAL
	LNK$AL_RAB : BLOCK[RAB$C_BLN,BYTE],		! RAB USED TO OPEN THE FILE
	LNK$AL_SYTBLFMT,				! ADDRESS OF SYMBOL LISTING FORMAT DESCRIPTION TABLE
	LNK$AL_VALCTLTB,				! ADDRESS OF CREF BY VALUE CONTROL TABLE
	LNK$AW_VERSION : BLOCK [LID$C_SIZE,BYTE],	! VERSION ARRAY
	LNK$GL_CTLMSK : BLOCK[,BYTE],			! LINK CONTROL MASK
	LNK$GL_PSHRNUM,					! NUMBER OF PSECT TO BE OUTPUT TO SHAREABLE IMAGE
	LNK$GT_IMGSTA  : BLOCK[,BYTE],			! NAME OF "SYS$IMGSTA"
	LNK$GL_CLULST : VECTOR[2],			! CLUSTER DESCRIPTOR LISTHEAD
	LNK$GL_DEFCLU : BLOCK[,BYTE],
	LNK$GL_RECORD,					! RECORD NUMBER IN THE FILE
	LNK$GL_SHRSYMS,					! NUMBER OF SHAREABLE IMAGE SYMBOLS REFERENCED
	LNK$GL_SHRIMGS,					! NUMBER OF SHAREABLE IMAGES REFERENCED
	LNK$GL_PSCDFLST,				! PSECTS DEFINED BY OPTION LIST
	LNK$GL_MAXSYMSZ,				! MAXIMUM SYMBOL LENGTH SEEN
	LNK$GL_MAXMODSZ,				! MAXIMUM MODULE LENGTH SEEN
	LNK$GL_CURCLU : REF BLOCK[,BYTE],		! CURRENT CLUSTER POINTER
	LNK$GL_CURFIL : REF BLOCK[,BYTE],		! CURRENT FDB POINTER
	LNK$GL_CUROMD : REF BLOCK[,BYTE],		! CURRENT OMD POINTER
	LNK$GL_LIBSYM : REF BLOCK[,BYTE],		! POINTS TO SYMBOL CAUSING LOAD OF LIBRARY MODULE
	LNK$GT_IMGID : VECTOR[,BYTE];			! STORAGE OF IMAGE IDENT
	!
GLOBAL
	LNK$GL_UDFLST : VECTOR[2] INITIAL(		! UNDEFINED SYMBOL LISTHEAD
				LNK$GL_UDFLST,		! INITIALLY POINTS TO
				LNK$GL_UDFLST),		! ITSELF, SINCE EMPTY
	LNK$GL_ENVTREE,					! TREE HEAD FOR ENVIRONMENTS
	LNK$GL_UDFENV : VECTOR[2] INITIAL(		! UNDEFINED ENVIRONMENT LISTHEAD
				LNK$GL_UDFENV,
				LNK$GL_UDFENV),
	LNK$GL_UDFLSY : VECTOR[2] INITIAL(		! LIST HEAD FOR UNDEFINED LOCAL SYMBOLS
				LNK$GL_UDFLSY,
				LNK$GL_UDFLSY),
	LNK$GL_ENTITREE,				! TREE HEAD FOR ENTITIES IDENT CHECK
	LNK$GL_DBGTFR,					! DEBUGGER TRANSFER ADDRESS
	LNK$GL_DBGTFPS : REF BLOCK[,BYTE],		! POINTER TO PSECT CONTAINING IT
	LNK$GL_TFRADR,					! TRANSFER ADDRESS
	LNK$GL_TFRPSC : REF BLOCK[,BYTE],		! POINTER TO PSECT CONTAINING IT
	LNK$GL_DBGESTIM,				! ESTIMATE OF NUMBER OF BYTES FOR DST
	LNK$GL_OMDTREE,					! TREE HEAD FOR OBJ MODULE DESCRIPTORS
	LNK$GW_DBGRECS : WORD,				! NUMBER OF DEBUG RECORDS
	LNK$GW_NFILES : WORD,				! NUMBER OF FILES OPENED
	LNK$GW_NMODULES : WORD,				! NUMBER OF MODULES FOUND
	LNK$GW_NPSECTS : WORD,				! NUMBER OF PSECTS IN TABLE
	LNK$GW_NSYMBOLS : WORD,				! NUMBER OF SYMBOLS IN TABLE
	LNK$GW_LSYMBOLS : WORD,				! NUMBER OF SYMBOLS IN THIS IMAGE
	LNK$GW_NCROSRFS : WORD,				! NUMBER OF CROSS REFERENCES ENTERED
	LNK$GW_NUDFSYMS : WORD,				! NUMBER OF UNDEFINED SYMBOLS
	LNK$GW_NLSYMS : WORD,				! NUMBER OF MODULE-LOCAL SYMBOLS
	LNK$GW_NUDFLSYMS : WORD,			! NUMBER OF UNDEFINED MODULE-LOCAL SYMBOLS
	LNK$GW_NUDFENVS : WORD;				! NUMBER OF UNDEFINED ENVIRONMENTS
!
OWN
	LASTOBJMOD	: REF BLOCK[,BYTE],			! POINTER TO LAST OBJ MODULE DESCRIPTOR
	WEAKTFRADR : BYTE,					! TRUE IF CURRENT XFR ADDR IS WEAK
	LCLSYMGSD : BYTE,					! TRUE IF GSD SUBTYPE IS LOCAL SYMBOL
	WORDPSECTGSD : BYTE,					! TRUE IF GSD SUBTYPE HAS WORD OF PSECT NUMBER
	MHDSEEN : BYTE,						! FLAG MHD SUB-HEADER AS YET NOT SEEN
	LNMSEEN : BYTE,						! FLAG THAT COMPILER NAME SUB-HEADER IS SEEN
	LASTRECTYP	: BYTE,					! TYPE OF THE PREVIOUS RECORD
	CURRECTYP	: BYTE INITIAL(OBJ$C_EOM),		! TYPE OF THE CURRENT RECORD
	GSDOFFSET	: WORD,					! OFFSET INTO CONCATENATED GSD RECORD
	ENTRYMASK	: WORD,					! ENTRY POINT MASK OF CURRENT SYMBOL
	MAXRECLNG	: WORD INITIAL(OBJ$C_MAXRECSIZ),	! MAXIMUM LENGTH PERMISSIBLE IN THIS MODULE
	OBJRECDESC : BLOCK[DSC$C_S_BLN,BYTE],			! STRING DESCRIPTOR FOR OBJECT RECORD
	SYMBOLSTRING	: REF VECTOR[,BYTE], 			! POINTER TO CURRENT SYMBOL
	SYMTABENT 	: REF BLOCK[,BYTE],			! POINTER TO SYMBOL TABLE ENTRY
	SYMENTNAM	: REF BLOCK[,BYTE],			! POINTER TO SYMBOL NAME BLOCK
								! PART OF SYMBOL
	IMAGEIDSTRING	: VECTOR[SYM$C_MAXLNG+1,BYTE],		! DEFAULT IMAGE IDENT STORAGE
	OBMODESC	: BLOCK[OMD$C_SIZE,BYTE];		! STATIC COPY OF OBJECT MODULE DESCRIPTOR
!
BIND
	RECLNG = OBJRECDESC[DSC$W_LENGTH] : WORD,		! SIZE OF RECORD READ
	OBJREC = OBJRECDESC[DSC$A_POINTER] : REF BLOCK[,BYTE],	! NAME POINTER PART OF DESCRIPTOR
	OBJVEC = OBJRECDESC[DSC$A_POINTER] : REF VECTOR[,BYTE],	! MUST ALSO ACCESS RECORD AS BYTE VECTOR
	RECDISPATCH = PLIT(					! SET UP MAXIMUM ALLOWED RECORD TYPE
			PROHDR,					! 0 - MODULE HEADER
			PROGSD,					! 1 - GSD RECORDS
			SEQCHK,					! 2 - TIR - JUST CHECK CORRECT SEQUENCE
			PROEOM,					! 3 - END OF MODULE
			COUNTDBG,				! 4 - DBG - CHECK SEQUENCE AND COUNT RECORDS AND BYTES
			COUNTDBG,				! 5 - TBT - COUNT AND CHECK SEQUENCE O.K.
			PROLNKREC) : VECTOR;			! 6 - OPTIONS RECORD
GLOBAL BIND
	LNK$GT_ENVSTRING = CSTRING('Environment'),
	LNK$GT_MODSTRING = CSTRING('Module'),			! FOR THE ERROR MESSAGE
	LNK$GT_SYMSTRING = CSTRING('Symbol'),
	LNK$GT_PSCSTRING = CSTRING('Psect'),
	LNK$GT_CLUSTRING = CSTRING('Cluster'),
	LNK$GT_ENTITY = CSTRING('Entity'),
	LNK$GT_IDENT = CSTRING('Ident'),
	LNK$GT_OBJNAM = CSTRING('Entity type'),
	LNK$GT_SYSVER = CSTRING('SYS$K_VERSION');		! SYSTEM VERSION SYMBOL
!

ROUTINE PROLNKREC =
BEGIN
!
! PROCESS LINKER OPTIONS RECORD
!
RETURN TRUE
END;

ROUTINE CHECKPDDENTRY (PDD) =
BEGIN
!
! ROUTINE CALLED BY LIB$TRAVERSE_TREE FOR EACH PSECT DEFINED BY OPTION
!
MAP
    PDD : REF BLOCK[,BYTE];

LOCAL
    PSCTDESC : REF BLOCK[,BYTE];

IF (.PDD[PDD$B_NAMLNG] AND %X'80') EQL 0				! IF NOT DEFINED YET
THEN BEGIN
    LNK$FNDPSCNAM(PDD[PDD$B_NAMLNG],.PDD[PDD$W_FLAGS],			! THEN DO SO NOW
			((.PDD[PDD$W_FLAGS] AND GPS$M_GBL) NEQ 0),
			PSCTDESC);
    PSCTDESC[PSC$W_FLAGS] = .PDD[PDD$W_FLAGS];				! SET THE FLAGS
    IF (PSCTDESC[PSC$B_ALIGN] = .PDD[PDD$B_ALIGN]) EQL %X'FF'		! AND THE ALIGNMENT
	THEN PSCTDESC[PSC$B_ALIGN] = 0;
    END;

RETURN TRUE
END;

GLOBAL ROUTINE LNK$INSUDFSYM (SYMBOLADDR) : NOVALUE =
BEGIN
!
!	THIS ROUTINE INSERTS AN UNDEFINED SYMBOL INTO THE LINKED LIST
!	OF UNDEFINED SYMBOLS.
!
MAP
	SYMBOLADDR : REF BLOCK[,BYTE];	! REALLY A POINTER
BUILTIN
	INSQUE;
LOCAL
	CH_RESULT,
	LISTHEAD : REF VECTOR[,LONG],
	NXTSYMENT : REF BLOCK[,BYTE];	! POINTER TO SYMBOL VALUE BLOCK
BIND
	SYMBOLNAME = .SYMBOLADDR - .SYMBOLADDR[SYM$B_NAMLNG]
		 - SNB$C_FXDLEN : BLOCK[,BYTE]; ! POINT TO NAME PART
!
!	FIND THE SPOT TO INSERT THE NEW SYMBOL IN THE UNDEFINED LIST
!
LISTHEAD = LNK$GL_UDFLST;
IF .LCLSYMGSD
    THEN LISTHEAD = LNK$GL_UDFLSY;

NXTSYMENT = .LISTHEAD;			! SCAN THE UNDEFINED LIST
WHILE (NXTSYMENT = .NXTSYMENT[SYM$L_UDFLINK]) NEQ .LISTHEAD
    DO BEGIN
	BIND
		NXTSYMNAM = .NXTSYMENT-.NXTSYMENT[SYM$B_NAMLNG]
			- SNB$C_FXDLEN : BLOCK[,BYTE];	! POINT TO NAME PART
	IF (CH_RESULT = CH$COMPARE(.NXTSYMNAM[SNB$B_NAMLNG],	! IF GREATER 
		NXTSYMNAM[SNB$T_NAME],.SYMBOLNAME[SNB$B_NAMLNG],
		SYMBOLNAME[SNB$T_NAME])) GTR 0
	THEN EXITLOOP					! THEN WE ARE ALL DONE
	ELSE IF .CH_RESULT EQL 0			! IF EQUAL
			THEN RETURN;			! THEN ALREADY IN LIST, SO RETURN
	END;
INSQUE(SYMBOLADDR[SYM$L_UDFLINK],			! INSERT IN UNDEFINED LIST
	.NXTSYMENT[SYM$L_UDFBLINK]);
IF NOT .SYMBOLADDR[SYM$V_WEAK]				! IF NOT A WEAK REFERENCE
    THEN IF .LCLSYMGSD
	    THEN LNK$GW_NUDFLSYMS = .LNK$GW_NUDFLSYMS + 1 ! THEN COUNT AS UNDEFINED
	    ELSE LNK$GW_NUDFSYMS = .LNK$GW_NUDFSYMS + 1;
RETURN;
END;

ROUTINE SEQCHK =
!
!	ROUTINE WHICH VALIDATES THAT RECORDS ARE IN CORRECT SEQUENCE.
!	RETURNS VALUE FALSE IF NOT, TRUE OTHERWISE. ALSO TURNS OFF THE NO
!	BINARY FLAG WHEN A TIR RECORD IS SEEN.
!
BEGIN
BIND
	HDRSUBTYP = OBJREC[OBJ$B_SUBTYP] : BYTE;
!
IF .CURRECTYP EQL OBJ$C_HDR
THEN							! IF THIS RECORD IS A HEADER
    IF .HDRSUBTYP EQL OBJ$C_HDR_MHD			! AND IT IS THE MAIN MODULE HEADER
    THEN						! THEN WE HAVE VALID SEQUENCE
	IF ((.LASTRECTYP EQL OBJ$C_EOM)			! IF AND ONLY IF THE PREVIOUS WAS END OF MODULE
	    OR (.LASTRECTYP EQL OBJ$C_EOMW))
	    THEN (MHDSEEN = TRUE;
		LNMSEEN = FALSE;
		RETURN TRUE)				! IS THE CASE SET MHD RECORD SEEN AND RETURN
	    ELSE BEGIN
		SIGNAL(LIN$_SEQNCE,2,			! ELSE REPORT ERROR
			OBMODESC[OMD$B_NAMLNG],LNK$GL_CURFIL[FDB$Q_FILENAME]);
		RETURN FALSE;
		END
    ELSE
	IF .MHDSEEN					! IF SOME OTHER KIND OF HEADER
	    THEN (IF .HDRSUBTYP EQL OBJ$C_HDR_LNM	! WE MUST HAVE SEEN A MAIN HEADER
			THEN LNMSEEN = TRUE;
		RETURN TRUE)
	    ELSE BEGIN
		SIGNAL(LIN$_SEQNCE,2,			! ELSE REPORT ERROR
			OBMODESC[OMD$B_NAMLNG],LNK$GL_CURFIL[FDB$Q_FILENAME]);
		RETURN FALSE;
		END
ELSE
    IF .MHDSEEN
	AND .LNMSEEN
    THEN BEGIN						! IF WE HAVE SEEN A MAIN HEADER
	IF ((.CURRECTYP EQL OBJ$C_EOM)			! THEN TURN OFF FLAG ON END OF MODULE.
	    OR (.CURRECTYP EQL OBJ$C_EOMW))
	    THEN MHDSEEN = FALSE			! SEQUENCE ERROR IF HAVE NOT SEEN
	    ELSE IF .CURRECTYP EQL OBJ$C_TIR
		THEN OBMODESC[OMD$V_NOBIN] = FALSE;
	RETURN TRUE;					! MAIN HEADER AND THIS IS NOT ONE.
	END
    ELSE BEGIN
	SIGNAL(LIN$_SEQNCE,2,				! ELSE REPORT ERROR
		OBMODESC[OMD$B_NAMLNG],LNK$GL_CURFIL[FDB$Q_FILENAME]);
	RETURN FALSE;
	END;

END;

ROUTINE PROHDR=
BEGIN
!
!++
!	PROCESS MODULE HEADER RECORDS AS FOLLOWS:
!		(1) VALIDATE SEQUENCE
!		(2) IGNORE ALL BUT MAIN MODULE HEADERS
!		(3) VERIFY STRUCTURE LEVEL IS LESS THAN
!		    OR EQUAL TO OBJ$C_STRLVL
!		(4) VERIFY MAXIMUM RECORD LENGTH 
!		    PARAMETER IS LESS THAN OR EQUAL TO
!		    OBJ$C_MAXRECSIZ
!		(5) RECORD MAXIMUM RECORD LENGTH PARAMETER
!                   FOR CHECKING SUBSEQUENT RECORDS
!		(6) CHECK MODULE TITLE > 0 AND LESS THAN OR
!		    EQUAL TO SYM$C_MAXLNG CHARACTERS
!		(7) ALLOCATE AN OBJECT MODULE DESCRIPTOR
!		    AND PUT ON END OF THE LIST (WHOSE
!		    HEAD IS FILE DESCRIPTOR BLOCK).
!		(8) COPY IN THE MODULE TITLE
!		(9) INITIALIZE FLAGS AND P-SECTION COUNT IN
!			THE OBJECT MODULE DESCRIPTOR
!--
!
BIND
	MHDREC = .OBJREC : BLOCK[,BYTE];
!
IF NOT SEQCHK() THEN RETURN FALSE;				! VALIDATE CORRECT SEQUENCE OF RECORD
IF .OBJREC[OBJ$B_SUBTYP] NEQ OBJ$C_HDR_MHD THEN RETURN TRUE;	! IGNORE ALL HEADERS EXCEPT MAIN ONES
LNK$GW_NMODULES = .LNK$GW_NMODULES + 1;				! COUNT THIS MODULE
IF .MHDREC[MHD$B_STRLVL] GTRU OBJ$C_STRLVL			! COMPARE ITS OBJ FORMAT
THEN BEGIN							! LEVEL AND IF BEYOND THIS
	SIGNAL(LIN$_STRLVL,4,
			.MHDREC[MHD$B_STRLVL],OBJ$C_STRLVL,	! AND GIVE UP
			MHDREC[MHD$B_NAMLNG],LNK$GL_CURFIL[FDB$Q_FILENAME]);
	RETURN FALSE;
	END;
IF (MAXRECLNG = .MHDREC[MHD$W_RECSIZ]) GTRU OBJ$C_MAXRECSIZ	! COMPARE MAX WITH MAX ALLOWED
THEN BEGIN							! AND IF GREATER
	SIGNAL(LIN$_ILLRECLEN,3,				! ISSUE ERROR MESSAGE
			.MAXRECLNG,MHDREC[MHD$B_NAMLNG],
			LNK$GL_CURFIL[FDB$Q_FILENAME]);
	RETURN FALSE;
	END;
IF .MHDREC[MHD$B_NAMLNG] GTRU SYM$C_MAXLNG			! CHECK MODULE NAME IS WITHIN LEGAL
OR .MHDREC[MHD$B_NAMLNG] EQL 0					! LENGTH RANGE
THEN BEGIN							! AND IF NOT ISSUE ERROR
	SIGNAL(LIN$_ILLNAMELEN,6,LNK$GT_MODSTRING,		! MESSAGE AND QUIT
		MHDREC[MHD$B_NAMLNG],.MHDREC[MHD$B_NAMLNG],
		SYM$C_MAXLNG,
		MHDREC[MHD$B_NAMLNG],LNK$GL_CURFIL[FDB$Q_FILENAME]);
	RETURN FALSE;
	END;

OBMODESC[OMD$L_OWNFDB] = .LNK$GL_CURFIL;			! SET POINTER TO OWNING FDB
OBMODESC[OMD$L_MODVBN] = .LNK$AL_RAB[RAB$L_RFA0];		! THIS IS NOW THE LAST. CAPTURE THE
OBMODESC[OMD$W_BYTOFF] = .LNK$AL_RAB[RAB$W_RFA4];		! MODULE'S RFA FOR LATER
OBMODESC[OMD$B_NAMLNG] = .MHDREC[MHD$B_NAMLNG];			! COPY THE STRING LENGTH
CH$COPY(.MHDREC[MHD$B_NAMLNG],MHDREC[MHD$T_NAME],0,		! AND THE STRING ZERO FILLED
		SYM$C_MAXLNG,OBMODESC[OMD$T_NAME]);		! INTO THE DESCRIPTOR
OBMODESC[OMD$W_HIPSCT] = -1;					! SET HIGHEST POSSIBLE P-SECTION NUMBER
OBMODESC[OMD$W_HIENV] = -1;					! SET HIGHEST POSSIBLE ENVIRONMENT NUMBER
OBMODESC[OMD$B_FLAGS] = OMD$M_NOPSCT OR OMD$M_NOBIN		! FLAG NO P-SECTS AND NO BINARY YET
				OR OMD$M_NOENV;			!  AND NO ENVIRONMENTS DEFINED
OBMODESC[OMD$V_SHRIMG] = .LNK$GL_CURFIL[FDB$V_SHR];		!  EXTRACT THE SHAREABLE IMAGE ATTRIB FROM FILE DESCRIPTOR
OBMODESC[OMD$V_SELSER] = .LNK$GL_CURFIL[FDB$V_SELSER];		!  AS WELL AS THE SELECTIVE SEARCH ATTRIBUTE
OBMODESC[OMD$V_DEBUGER] = .LNK$GL_CURFIL[FDB$V_DEBUGER];	! COPY DEBUGGER MODULE FLAG
IF NOT .LNK$GL_CTLMSK[LNK$V_INTFIL]				! IF THIS IS NOT STARLET
    THEN OBMODESC[OMD$V_MAPMOD] = TRUE;				! SET TO MAP THE MODULE ON PASS 2
OBMODESC[OMD$L_OMDNUM] = .LNK$GW_NMODULES;			! SET MODULE NUMBER INTO DESCRIPTOR
BEGIN
	BIND 
	    MODIDSTRING = MHDREC[MHD$T_NAME] +			! POINT TO THE MODULE ID IN HEADER
			.MHDREC[MHD$B_NAMLNG] : VECTOR[,BYTE],	! RECORD (COUNTED STRING)
	    MODCREDAT = MODIDSTRING[0] + .MODIDSTRING[0]	!  POINT TO THE MODULE CREATION DATE/TIME
				+ 1 : VECTOR[,BYTE];

	LOCAL
	    BINCREDAT : VECTOR[2,LONG];

	IF .LNK$GL_CURCLU[CLU$V_SHRIMG]				! IF THIS IS A SHAREABLE IMAGE
		AND .(LNK$GL_CURCLU[CLU$Q_CREDAT])<0,32,0> NEQ 0!  THAT WAS PICKED UP FROM A SHAREABLE IMAGE LIBRARY
	THEN BEGIN						!  (CREDAT WILL BE 0 IF NOT)
	    LNK$BINTIM(MODCREDAT,BINCREDAT);			! CONVERT TIME TO BINARY
	    IF NOT CH$EQL(8,BINCREDAT,8,LNK$GL_CURCLU[CLU$Q_CREDAT]) ! AND IF THE DATES ARE DIFFERENT
		THEN SIGNAL(LIN$_DATMISMCH,4,BINCREDAT,		!   THEN WARN THE USER, BUT CONTINUE
				LNK$GL_CURFIL[FDB$Q_FILENAME],
				LNK$GL_CURCLU[CLU$Q_CREDAT],
				LNK$GL_CURFIL[FDB$Q_LIBNAMDSC]);
	    CH$FILL(0,8,LNK$GL_CURCLU[CLU$Q_CREDAT]);		! ZERO THE QUADWORD DATE/TIME, SINCE IT GETS REUSED
	    END;
	IF NOT .OBMODESC[OMD$V_DEBUGER]				! IF THIS IS NOT A DEBUGGER MODULE
	    AND (.LNK$GT_IMGID[0] EQL 0				! IF THERE IS NO IMAGE IDENT SET UP
		OR .LNK$GL_TFRPSC EQL 0)
	THEN BEGIN
	IF (IMAGEIDSTRING[0] = MINU(.MODIDSTRING[0],		! EXTRACT THE LENGTH MINIMIZED WITH
				SYM$C_MAXLNG)) NEQ 0		! MAXIMUM ALLOWED STRING LENGTH
	THEN CH$MOVE(.IMAGEIDSTRING[0],MODIDSTRING[1],		! AND IF NOT NULL SAVE
			IMAGEIDSTRING[1]);			! SAVE IT TILL END OF MODULE SO THAT
	END;							! WE MAY USE IT IF THIS HAS A TRANSFER ADDRESS
     END;
RETURN TRUE;
END;			! OF MODULE HEADER PROCESSING

ROUTINE DELETE_PSECT(PSECTNAME,RETDESCADR) =
BEGIN
!
! THIS ROUTINE SEARCHES ALL CLUSTERS FOR ANOTHER DEFINITION OF THE
! NAMED GLOBAL PSECT.  IF ONE IS FOUND, IT IS DELETED (BY SETTING
! A FLAG IN THE DESCRIPTOR).  IF THE CLUSTER IT IS FOUND IN IS
! A SHAREABLE IMAGE, THEN AN ERROR MESSAGE IS ISSUED, SINCE A
! PSECT CANNOT BE CONTAINED IN TWO SHAREABLE IMAGES AT THE SAME
! TIME.
!
MAP
    PSECTNAME : REF VECTOR[,BYTE],
    RETDESCADR : REF VECTOR[,LONG];

LOCAL
    CLUDESC : REF BLOCK[,BYTE],
    FDB : REF BLOCK[,BYTE],
    PDESC : REF BLOCK[,BYTE];

CLUDESC = LNK$GL_CLULST;
!
! LOOP OVER ALL CLUSTERS, SEARCHING THE GLOBAL PSECT LIST FOR
! A MATCH
!
WHILE (CLUDESC = .CLUDESC[CLU$L_NXTCLU]) NEQ 0
DO IF LIB$LOOKUP_TREE(CLUDESC[CLU$L_GPSLST],.PSECTNAME,
			LNK$COMPARE_PSCNOD,PDESC)
    AND NOT (PDESC = .PDESC[NODE$L_PTR];		! GET PSECT DESCRIPTOR ADDRESS
		.PDESC[PSC$V_DELETED])			! TEST IF PSECT HAS BEEN DELETED
THEN BEGIN
    PDESC[PSC$V_DELETED] = TRUE;			! FLAG PSECT DELETED FROM THIS CLUSTER
    IF .CLUDESC[CLU$V_SHRIMG]				! IF CLUSTER IS A SHAREABLE IMAGE
    THEN BEGIN
	FDB = .CLUDESC[CLU$L_FSTFDB];			! GET FDB ADDRESS FOR SHAREABLE IMAGE
	SIGNAL(LIN$_MULSHRPSC,3,.PSECTNAME,		! ISSUE ERROR MESSAGE
		FDB[FDB$Q_FILENAME],LNK$GL_CURFIL[FDB$Q_FILENAME],
		LIN$_NOIMGFIL);
	LNK$GL_CTLMSK[LNK$V_IMAGE] = FALSE;		! IMAGE WOULD ONLY BE INVALID
	END;
    RETDESCADR[0] = .PDESC;				! RETURN ADDRESS TO CALLER
    RETURN TRUE;
    END;

RETURN FALSE
END;

ROUTINE FNDPSCMAPENT(PSCTNUM,OMDPTR) =
BEGIN
!
!	THIS ROUTINE RETURNS THE ADDRESS OF THE MAPPING
!	TABLE ENTRY FOR P-SECTION NUMBER "PSCTNUM" IN
!	THE CURRENT MODULE.
!	THE P-SECT MAPPING TABLE IS AN ARRAY APPENDED
!	TO THE MODULE DESCRIPTOR BLOCK. IT IS INITIALLY
!	ALLOCATED WITH SPACE SUFFICIENT FOR 256
!	ENTRIES.  IF MORE THAN 256 PSECTS ARE ENCOUNTERED DURING
!	THE PROCESSING OF THE OBJECT MODULE, THE INITIAL TABLE IS
!	COPIED OUT TO ANOTHER BLOCK, AND THE MAP TABLE APPENDED TO
!	THE OBJECT MODULE DESCRIPTOR BLOCK IS A TABLE OF TABLE ADDRESSES.
!
!	THE SECOND ARGUMENT IS OPTIONAL.  IF NOT SUPPLIED, THE OWN OBJ MODULE
!	DESCRIPTOR (OBMODESC) WILL BE USED.
LITERAL
    TABLESIZE = 256*PMT$C_SIZE;						! SIZE IN BYTES OF A BLOCK

LOCAL
    BLOCKOFF,								! OFFSET OF ENTRY IN EXTENDED BLOCK
    OMDESC : REF BLOCK[,BYTE],						! POINTER TO OBJ MODULE DESCRIPTOR
    MAPENT : REF BLOCK[,BYTE],						! ADDRESS IN PSECT MAPPING TABLE
    MAPOFF : REF BLOCK[,BYTE];						! ADDRESS OF EXTENDED MAPPING BLOCK

BUILTIN
    NULLPARAMETER;

IF NULLPARAMETER(2)					! SETUP POINTER TO OBJ MODULE DESCRIPTOR
    THEN OMDESC = OBMODESC
    ELSE OMDESC = .OMDPTR;

MAPENT = OMDESC[OMD$T_PSCMAP] + .PSCTNUM*PMT$C_SIZE;			! GET ENTRY ADDRESS IN BASE MAPPING TABLE
IF NOT .OMDESC[OMD$V_P256]						! IF NOT INTO EXTENDED MAP TABLE
    AND .PSCTNUM LEQU 255						!  AND LEQU 255 PSECTS
THEN RETURN .MAPENT
!
! EXTENDED PSECT ENTRY
!
ELSE BEGIN
    BLOCKOFF = (.PSCTNUM MOD 256)*PMT$C_SIZE;				! OFFSET OF ENTRY WITHIN EXTENDED TABLE
    MAPENT = OMDESC[OMD$T_PSCMAP] + ((.PSCTNUM-1)/256)*PMT$C_SIZE;	! GET ADDRESS OF EXTENDED TABLE ADDRESS
    IF ..MAPENT NEQ 0							! IF EXTENDED TABLE PRESENT
	AND .OMDESC[OMD$V_P256]						!  AND THERE REALLY IS AN EXTENDED TABLE
    THEN RETURN ..MAPENT + .BLOCKOFF					!  THEN RETURN ENTRY ADDRESS
    ELSE BEGIN
        LNK$ALLOBLK(TABLESIZE, MAPOFF);					! ALLOCATE EXTENDED TABLE BLOCK
	IF NOT .OMDESC[OMD$V_P256]					! IF THIS IS THE FIRST ONE
	THEN BEGIN
	    CH$MOVE(TABLESIZE,OMDESC[OMD$T_PSCMAP],.MAPOFF);		! AND COPY BASE TABLE OUT
	    CH$FILL(0,TABLESIZE,OMDESC[OMD$T_PSCMAP]);			! ZERO BASE TABLE
	    OMDESC[OMD$V_P256] = TRUE;					! FLAG INTO EXTENDED TABLE
	    END
	ELSE CH$FILL(0,TABLESIZE,.MAPOFF);				! NOT FIRST EXTENSION...JUST ZERO NEW BLOCK
	!
	! POINT ENTRY IN BASE TABLE TO NEW BLOCK
	!
	MAPENT[PMT$L_SECPMT] = .MAPOFF;
	RETURN .MAPOFF + .BLOCKOFF
	END;
    END;
END;

ROUTINE ALLOC_OMDNODE (OMDNUM, RETNODEADR, OMDESC) =
BEGIN
!
! THIS ROUTINE IS CALLED BY LIB$INSERT_TREE TO ALLOCATE
! STORAGE FOR A NODE
!
MAP
    RETNODEADR : REF VECTOR[,LONG],
    OMDESC : REF BLOCK[,BYTE];

LOCAL
    NODE : REF BLOCK[,BYTE];

LNK$ALLOBLK(NODE$C_LONG,NODE);			! ALLOCATE A NODE
NODE[NODE$L_PTR] = .OMDESC;			! POINT TO OBJ MODULE DESCRIPTOR
RETNODEADR[0] = .NODE;				! RETURN ADDRESS TO CALLER
RETURN TRUE
END;

GLOBAL ROUTINE LNK$COMPARE_OMD (OMDNUM,CURNODE,OMDESC) =
BEGIN
!
! THIS ROUTINE IS CALLED BY LIB$INSERT_TREE AND LIB$LOOKUP_TREE
! TO COMPARE CURRENT NODE WITH THE NUMBER WE ARE LOOKING FOR
!
MAP
    CURNODE : REF BLOCK[,BYTE];

BIND
    CUROMD = .CURNODE[NODE$L_PTR] : BLOCK[,BYTE];

IF .OMDNUM LSS .CUROMD[OMD$L_OMDNUM]			! COMPARE THIS WITH CURRENT NODE
    THEN RETURN -1					! RETURN -1 IF LSS
    ELSE IF .OMDNUM EQL .CUROMD[OMD$L_OMDNUM]		! IF EQUAL
	THEN RETURN 0					!  THEN RETURN 0
	ELSE RETURN 1					!  ELSE IT'S GTR, RETURN 1

END;

ROUTINE PROPSECTDEF =
BEGIN
!
!++
!	PROCESS P-SECTION DEFINITIONS AS FOLLOWS:
!		(0) CHECK LEGAL P-SECTION NAME AND ALIGNMENT PARAMETER
!		(1) SEARCH FOR P-SECTION DEFINED
!		(2) IF DEFINED:
!			1. CHECK COMPATIBLE ATTRIBUTES
!			2. IF OVERLAYED, CHECK EQUAL ALIGNMENT
!			3. MAXIMIZE P-SECTIONS'S BASE ALIGNMENT
!			4. GO TO (3)
!		    IF NOT DEFINED:
!			1. INSERT IN P-SECTION LIST
!			2. COPY FLAGS AND ALIGNMENT
!		(3) ALLOCATE A MODULE CONTRIBUTION ENTRY AND INSERT
!			IT LEXICALLY IN THE LIST BY MODULE NAME
!		(4) UPDATE CURRENT BASE BY THIS ALIGNMENT THEN COPY
!			CURRENT BASE INTO MAPPING TABLE ENTRY
!		(5) ADD THAT ROUND UP TO PSECTIONS ACCUMULATED LENGTH
!		(6) ADD P-SECTIONS LENGTH CONTRIBUTION TO THE ACCUMULATION
!			IF CONCATENATED. IF OVERLAYED, MAXIMIZE LENGTH.
!		(7) COPY CONTRIBUTION LENGTH INTO MAPPING TABLE ENTRY
!		(8) COPY ALIGNMENT INTO MAPPING TABLE
!		(9) COPY MODULE DESCRIPTOR ADDRESS INTO MAPPING TABLE
!		(10) COUNT THIS P-SECTION AND CLEAR NO P-SECTIONS FLAG
!		(11) IF NECESSARY EXTEND MODULE DESCRIPTOR FOR ANOTHER
!			P-SECTION AND INSERT ADDRESS OF P-SECTION
!			IN TABLE.
!		(12) IF ANY PREMATURE SYMBOL DEFINITIONS, REMOVE EACH FROM
!			LIST, ADDING P-SECTION BASE TO RELOCATABLE VALUES
!			AND LINKING THEM ON THE P-SECION'S LIST OF SYMBOLS
!--
!
LOCAL
	PSCTDESC : REF BLOCK[,BYTE],				! CURRENT P-SECT DESCRIPTOR
	MODPSCONTRIBLK : REF BLOCK[,BYTE],			! MODULE CONTRIBUTION DATA BLOCK
	LASTMODPSCONTRIBLK : REF BLOCK[,BYTE],
	PSECTNAME : REF VECTOR[,BYTE],				! POINTER TO PSECT NAME
	NEWPSECT,						! TRUE IF NEW PSECT
	SGPSTYPE,						! TRUE IF GSD$C_SGPS
	PSCOPE,							! P-SECTION SEARCH SCOPE
	PSFLAGS,
	PREVDFOUND,						! TRUE IF PREV. DEF. OF COMMON FROM SHR IMAGE
	DELPSCDESC : REF BLOCK[,BYTE],				! POINTER TO DELETED PSECT DESCRIPTOR
	PSCTMAPENT : REF BLOCK[,BYTE],				! P-SECTION MAPPING TABLE ENTRY
	AROUND,							! ROUND UP FOR ALIGNMENT
	PDDPTR : REF BLOCK[,BYTE],
	LOCALPDD : BLOCK[PDD$C_SIZE,BYTE],
	PREMSYMLST,						! SAVE PREMATURE SYMBOL LIST
	PREMSYM : REF BLOCK[,BYTE];				! PREMATURELY DEFINED SYMBOL
BIND
	LENGTH = AROUND,
	PSCTDEF = OBJVEC[.GSDOFFSET] : BLOCK[,BYTE];

!
! DETERMINE WHICH PSECT SUBRECORD TYPE THIS IS
!
SGPSTYPE = FALSE;
IF .PSCTDEF[GPS$B_GSDTYP] EQL GSD$C_PSC
THEN PSECTNAME = PSCTDEF[GPS$B_NAMLNG]
ELSE BEGIN
    PSECTNAME = PSCTDEF[SGPS$B_NAMLNG];				! SHAREABLE IMAGE PSECT
    SGPSTYPE = TRUE;
    END;
!
!	FIRST CHECK FOR LEGAL P-SECTION NAME
!
IF .PSECTNAME[0] GTRU SYM$C_MAXLNG				! CHECK NAME WITHIN THE LEGAL
OR .PSECTNAME[0] EQL 0						! RANGE FOR SYMBOL AND P-SECTION
THEN BEGIN
    SIGNAL(LIN$_ILLNAMELEN,6,					! NAMES AND IF NOT
		LNK$GT_PSCSTRING,.PSECTNAME,
		.PSECTNAME[0],SYM$C_MAXLNG,			! ISSUE AN ERROR MESSAGE
		OBMODESC[OMD$B_NAMLNG],
		LNK$GL_CURFIL[FDB$Q_FILENAME]);
    RETURN FALSE;
    END;
!
! SEE IF PSECT DEFINED BY OPTION
!
CH$FILL(0, PDD$C_SIZE, LOCALPDD);				! ZERO ALL FIELDS IN LOCAL PDD
LOCALPDD[PDD$B_ALIGN] = %X'FF';					! SET ITS ALIGNMENT TO ALL ONES
PDDPTR = LOCALPDD;						! PRESET IN CASE NOT FOUND
PSFLAGS = .PSCTDEF[GPS$W_FLAGS];				! ASSUME NOT DEFINED BY OPTION
IF LNK$SRCPSCDEF(.PSECTNAME, PDDPTR)				! SEE IF DEFINED BY OPTION
THEN BEGIN
    PDDPTR[PDD$B_NAMLNG] = .PDDPTR[PDD$B_NAMLNG] OR %X'80';	! AND IF SO, MARK AS DEFINED
    PSFLAGS = .PDDPTR[PDD$W_FLAGS] OR 				! SET THE FLAGS
		(.PSFLAGS AND NOT .PDDPTR[PDD$W_FLGMSK]); 	! QUALIFIED BY THE MASK
    END;
!
! IF THIS IS A SHAREABLE IMAGE CLUSTER AND THIS IS A GLOBAL PSECT
! (COMMON), THEN SEE IF DEFINED SOMEWHERE ELSE
!
IF .LNK$GL_CURCLU[CLU$V_SHRIMG]
    AND (.PSCTDEF[GPS$W_FLAGS] AND PSC$M_SHRBITS) EQL PSC$M_SHRBITS
    THEN PREVDFOUND = DELETE_PSECT(.PSECTNAME,DELPSCDESC)
    ELSE PREVDFOUND = FALSE;
!
! CHECK ALIGNMENT
!
IF .PSCTDEF[GPS$B_ALIGN] GTRU OBJ$C_PSCALILIM			! IF THE ALIGNMENT IS GREATER
THEN BEGIN
    SIGNAL(LIN$_PSCALI,4,.PSECTNAME,.PSCTDEF[GPS$B_ALIGN], 	! THAN THE MAXIMUM, ISSUE
		OBMODESC[OMD$B_NAMLNG],LNK$GL_CURFIL[FDB$Q_FILENAME]);  ! ERROR AND QUIT
    PSCTDEF[GPS$B_ALIGN] = OBJ$C_PSCALILIM;				! USE OBJ LANG MAX
    END;
!
!	SEARCH FOR P-SECTION DEFINED, CREATING DESCRIPTOR IF NOT.
!
IF  .OBMODESC[OMD$V_SHRIMG]					! IF THIS IS A SHAREABLE IMAGE
THEN PSCOPE = 0							! THEN P-SECTION SEARCH IS ONLY IN THIS CLUSTER
ELSE IF (PSCOPE = .PSCTDEF[GPS$V_GBL]) EQL 0			! ELSE DEPENDS ON PSECT SCOPE
THEN PSCOPE = .PDDPTR[PDD$W_FLAGS] AND GPS$M_GBL;		! OR OPTION DEFINITION SCOPE
IF LNK$FNDPSCNAM(.PSECTNAME,.PSFLAGS,.PSCOPE,PSCTDESC) 		! GET DESCRIPTOR ADDRESS
AND .PSCTDESC[PSC$V_USRPSC]					! AND PSECT WAS SEEN IN SOURCE
THEN BEGIN							! AND IF FOUND
	NEWPSECT = FALSE;
! ** THIS CHECK DISABLED UNTIL C ISSUE RESOLVED
!
!	IF .PSCTDESC[PSC$L_OMDNUM] EQL .LNK$GW_NMODULES		! IF PSECT ALREADY DEFINED IN THIS MODULE
!	    THEN SIGNAL(LIN$_MULDEFPSC,3,PSCTDESC[PSC$B_NAMLNG],!  THEN ISSUE A WARNING MESSAGE
!			OBMODESC[OMD$B_NAMLNG],LNK$GL_CURFIL[FDB$Q_FILENAME]);
!
! ** END OF DISABLED CODE
	PSCTDESC[PSC$L_OMDNUM] = .LNK$GW_NMODULES;		! SET DEFINED IN CURRENT MODULE
	IF NOT .PSCTDESC[PSC$V_OPTPSC]				! IF PSECT NOT MODIFIED BY OPTION
	THEN BEGIN
	    IF .PSCTDEF[GPS$W_FLAGS] NEQ ((.PSCTDESC[PSC$W_FLAGS]	! CHECK COMPATIBLE
				AND NOT (PSC$M_SUPRES OR PSC$M_USRPSC))
					AND PSC$M_PSCBITS)
		THEN SIGNAL(LIN$_MULPSC,3,				! ATTRIBUTES, ISSUING ERROR
			.PSECTNAME,OBMODESC[OMD$B_NAMLNG],		! IF NOT
			LNK$GL_CURFIL[FDB$Q_FILENAME]);
	    IF .PSCTDESC[PSC$V_OVR]					! IF OVERLAYED
		THEN IF .PSCTDEF[GPS$B_ALIGN] NEQ .PSCTDESC[PSC$B_ALIGN]! CHECK EQUAL
			THEN SIGNAL(LIN$_OVRALI,3,			! ALIGNMENT
				.PSECTNAME,OBMODESC[OMD$B_NAMLNG],
				LNK$GL_CURFIL[FDB$Q_FILENAME]);
	    IF .PSCTDEF[GPS$B_ALIGN] GTRU .PSCTDESC[PSC$B_ALIGN]	! MAXIMIZE
		THEN PSCTDESC[PSC$B_ALIGN] = .PSCTDEF[GPS$B_ALIGN];	! THE ALIGNMENT
	    END							! PSECT NOT MODIFIED BY OPTION
     END
!
!	P-SECTION IS NOT YET DEFINED - SO DO THAT
!
ELSE BEGIN							! AND INSERT P-SECTION
	LNK$GW_NPSECTS = .LNK$GW_NPSECTS + 1;			! AFTER COUNTING IT
	NEWPSECT = TRUE;
	PSCTDESC[PSC$B_ALIGN] = .PDDPTR[PDD$B_ALIGN];		! SET THE ALIGNMENT FROM PDD
	IF .PSCTDESC[PSC$B_ALIGN] EQL %X'FF'			! BUT IF NONE SPECIFIED
	    THEN PSCTDESC[PSC$B_ALIGN] = .PSCTDEF[GPS$B_ALIGN];	! THEN USE INPUT FILE
	PSCTDESC[PSC$W_FLAGS] = .PSFLAGS;			! SET THE FLAGS
	PSCTDESC[PSC$V_USRPSC] = TRUE;				! FLAG DEFINED BY USER SOURCE
	PSCTDESC[PSC$V_SHRIMG] = .LNK$GL_CURCLU[CLU$V_SHRIMG];	! PROPOGATE SHR IMG FLAG INTO PSECT DESCRIPTOR
	PSCTDESC[PSC$V_NEWDEF] = .SGPSTYPE;			! REMEMBER IF SGPS DEFINITION
	IF .LNK$GL_CTLMSK[LNK$V_SHR]				! IF CREATING A SHAREABLE IMAGE
		AND NOT .OBMODESC[OMD$V_SHRIMG]			!  AND THIS IS NOT A SHAREABLE IMAGE INPUT MODULE
		AND (.PSCTDESC[PSC$W_FLAGS] AND PSC$M_SHRBITS)	!  AND IF PSECT WILL BE OUTPUT TO SHAREABLE IMAGE
			EQL PSC$M_SHRBITS				! (MUST BE RELOCATABLE, GLOBAL AND OVERLAID
		THEN BEGIN
		    LNK$GL_PSHRNUM = .LNK$GL_PSHRNUM + 1; 	! THEN COUNT IT FOR LNKSYMOUT
		    IF .LNK$GL_PSHRNUM EQL LNK$C_MAXPSECTS+1	! IF THERE ARE TOO MANY
			THEN SIGNAL_STOP(LIN$_EXCPSC, 2,
						OBMODESC[OMD$B_NAMLNG],
						LNK$GL_CURFIL[FDB$Q_FILENAME],
						LIN$_FORMAT);
		    END;
	IF .LNK$GL_CTLMSK[LNK$V_INTFIL]				! IF THIS IS THE INTERNAL (SYSLIB) FILE
	AND .LNK$GL_CTLMSK[LNK$V_SUPSYS]			! AND SYSLIB SUPPRESSION IS ON
	THEN PSCTDESC[PSC$V_SUPRES] = TRUE;			! THEN SUPPRESS THIS P-SECTION
	IF .OBMODESC[OMD$V_SHRIMG]				! IF A SHAREABLE IMAGE P-SECTION
	THEN IF .SGPSTYPE
	    THEN PSCTDESC[PSC$L_BASE] = .PSCTDEF[SGPS$L_BASE]
	    ELSE PSCTDESC[PSC$L_BASE] = .PSCTDEF[GPS$L_ALLOC];	! ITS BASE IS GIVEN BY SIZE FIELD IF NORMAL PSECT DEF
     END;
!
! IF THIS IS A SHAREABLE IMAGE PSECT THAT WAS FOUND ELSEWHERE,
! WE HAVE TO RUN AROUND AND FIX UP THE POINTERS IN THE PSECT
! MAPPING TABLES FOR THE PREVIOUS DEF. TO POINT TO THIS NEW
! DEFINITION.  ALSO, PUT THE OLD PSECT MAPPING LIST ONTO THE
! NEW DESCRIPTOR
!
IF .PREVDFOUND
THEN BEGIN
    MODPSCONTRIBLK = .DELPSCDESC[PSC$L_MPCLST];		! GET MPC LIST POINTER
    PSCTDESC[PSC$L_MPCLST] = .MODPSCONTRIBLK;		! SET INTO NEW DESCRIPTOR
    PSCTDESC[PSC$L_LSTMPC] = .DELPSCDESC[PSC$L_LSTMPC];	! COPY END OF LIST POINTER
    WHILE .MODPSCONTRIBLK NEQ 0
    DO BEGIN
	PSCTMAPENT = FNDPSCMAPENT(.MODPSCONTRIBLK[MPC$W_PSCNUM], ! FIND PSECT MAPPING ENTRY
				.MODPSCONTRIBLK[MPC$L_OWNOMD]);
	PSCTMAPENT[PMT$L_PSCDES] = .PSCTDESC;		! SET POINTER TO NEW DESCRIPTOR
	MODPSCONTRIBLK = .MODPSCONTRIBLK[MPC$L_NXTMPC];
	END;
    END;
!
!	NOW TO CREATE A BLOCK OF DATA DESCRIBING THIS
!	MODULE'S CONTRIBUTION TO THE P-SECTION, LINK THE
!	BLOCK TO END OF THE P-SECTION MODULAR CONTRIBUTION LIST
!	AND POINT MODULE DESCRIPTOR
!	MAPPING TABLE ENTRY AT THIS BLOCK.
!
LNK$ALLOBLK(MPC$C_SIZE,MODPSCONTRIBLK);				! ALLOCATE THE BLOCK
MODPSCONTRIBLK[MPC$L_NXTMPC] = 0;				! CLEAR POINTER TO NEXT CONTRIB DESCRIPTOR
MODPSCONTRIBLK[MPC$L_OWNOMD] = .OBMODESC[OMD$L_NXTOMD];		! LINK INTO TEMP LIST
OBMODESC[OMD$L_NXTOMD] = .MODPSCONTRIBLK;			! TO BE FIXED UP AT PROEOM TIME
LASTMODPSCONTRIBLK = .PSCTDESC[PSC$L_LSTMPC];			! GET POINTER TO LAST CONTRIB. BLOCK FOR PSECT
IF .LASTMODPSCONTRIBLK NEQ 0					! IF THERE IS A LAST
    THEN LASTMODPSCONTRIBLK[MPC$L_NXTMPC] = .MODPSCONTRIBLK;	! THEN LINK NEW BLOCK INTO LIST
PSCTDESC[PSC$L_LSTMPC] = .MODPSCONTRIBLK;			! AND MAKE IT THE NEW LAST.
!
IF .OBMODESC[OMD$W_HIPSCT] EQL LNK$C_MAXPSECTS			! IF TOO MANY PSECTS ALREADY
AND NOT .OBMODESC[OMD$V_NOPSCT]
THEN 								! BEEN SEEN FOR THIS MODULE
	SIGNAL_STOP(LIN$_EXCPSC,2,				! ISSUE AN ERROR MESSAGE AND GIVE UP
		OBMODESC[OMD$B_NAMLNG],LNK$GL_CURFIL[FDB$Q_FILENAME],
		LIN$_FORMAT);
!
OBMODESC[OMD$V_NOPSCT] = FALSE;						! CLEAR NO PSECTS FLAG
OBMODESC[OMD$W_HIPSCT] = .OBMODESC[OMD$W_HIPSCT]+1;			! COUNT NEW P-SECTION
MODPSCONTRIBLK[MPC$W_PSCNUM] = .OBMODESC[OMD$W_HIPSCT];			! SAVE PSECT NUMBER IN MPC
PSCTMAPENT = FNDPSCMAPENT(.OBMODESC[OMD$W_HIPSCT]);			! GET MAP TABLE ENTRY
PREMSYMLST = .PSCTMAPENT[PMT$L_SYMLST];					! SAVE PREMATURE SYMBOL LIST
PSCTMAPENT[PMT$L_PSCDES] = .PSCTDESC;					! POINT IT TO PSECTION DESCRIPTOR
PSCTMAPENT[PMT$L_MODCON] = .MODPSCONTRIBLK;				! AND TO THE NEW CONTRIBUTION BLOCK.
MODPSCONTRIBLK[MPC$B_ALIGN] = .PSCTDEF[GPS$B_ALIGN];			! COPY ITS ALIGNMENT
MODPSCONTRIBLK[MPC$L_OFFSET] = 0;					! ASSUME ABSOLUTE AND/OR OVERLAYED
									! AND THUS 0 OFFSET CONTRIBUTION
IF .PSCTDESC[PSC$V_REL]							! THAT IS ALL FOR ABSOLUTE
THEN BEGIN								! P-SECTIONS
    IF NOT .PSCTDESC[PSC$V_OVR]						! IF A CONCATENATED PSECT NOT FROM SHR IMAGE
	AND NOT .OBMODESC[OMD$V_SHRIMG]
    THEN BEGIN
	AROUND = (1 ^.PSCTDEF[GPS$B_ALIGN]) - 1;
	MODPSCONTRIBLK[MPC$L_OFFSET]=(.PSCTDESC[PSC$L_BASE]+.AROUND)	! ADD IN THE ROUNDING AND TRUNCATE
						AND NOT .AROUND;
	AROUND = .MODPSCONTRIBLK[MPC$L_OFFSET]-.PSCTDESC[PSC$L_BASE];	! THEN COMPUTE AMOUNT ADDED
	PSCTDESC[PSC$L_BASE] = .PSCTDESC[PSC$L_BASE]+.AROUND+		! UPDATE THE BASE FOR NEXT
					.PSCTDEF[GPS$L_ALLOC];		! CONTRIBUTOR.
	PSCTDESC[PSC$L_LENGTH] = .PSCTDESC[PSC$L_BASE];			! WHICH IS ALSO TOTAL LENGTH
     END
    ELSE BEGIN								! FOR OVERLAYED
	LOCAL
	    OMD : REF BLOCK[,BYTE],
	    FDB : REF BLOCK[,BYTE];

	IF (.SGPSTYPE							! IF SHAREABLE IMAGE PSECT TYPE
		AND .PSCTDESC[PSC$V_OVR]
		AND .PREVDFOUND						!  AND IT WAS DEFINED BEFORE IN OBJ MODULE
		AND (.DELPSCDESC[PSC$L_LENGTH] GTRU .PSCTDEF[SGPS$L_ALLOC])) ! TO BE LARGER THAN ONE IN SHR IMG
	    THEN BEGIN
		LIB$LOOKUP_TREE(LNK$GL_OMDTREE,.DELPSCDESC[PSC$L_OMDNUM],! FIND DEFINING MODULE OMD
				LNK$COMPARE_OMD,OMD);
		OMD = .OMD[NODE$L_PTR];					! POINT TO OMD FROM NODE
		FDB = .OMD[OMD$L_OWNFDB];				! GET POINTER TO FDB FOR MODULE
		SIGNAL(LIN$_SHRPSCLNG,6,.PSECTNAME,.DELPSCDESC[PSC$L_LENGTH],
			OMD[OMD$B_NAMLNG],FDB[FDB$Q_FILENAME],
			.PSCTDEF[SGPS$L_ALLOC],LNK$GL_CURFIL[FDB$Q_FILENAME],
			LIN$_NOIMGFIL);
		LNK$GL_CTLMSK[LNK$V_IMAGE] = FALSE;			! DISABLE IMAGE PRODUCTION
		END;
	IF (.PSCTDESC[PSC$V_SHRIMG] AND .PSCTDESC[PSC$V_NEWDEF]		! IF PSECT DEFINED IN SHAREABLE IMAGE
		AND .PSCTDESC[PSC$V_OVR]
		AND NOT .NEWPSECT					! AND THIS IS NOT FIRST DEFINITION
		AND (.PSCTDEF[GPS$L_ALLOC] GTRU .PSCTDESC[PSC$L_LENGTH])) ! AND THIS DEFINITION IS BIGGER THAN SHR IMAGE ONE
	    THEN BEGIN							! THAT IS AN ERROR
		FDB = .PSCTDESC[PSC$L_CLUDSC];				! GET CLUSTER DESCRIPTOR POINTER
		FDB = .FDB[CLU$L_FSTFDB];				! GET POINTER TO FDB FOR SHAREABLE IMAGE
		SIGNAL(LIN$_SHRPSCLNG,6,.PSECTNAME,.PSCTDEF[GPS$L_ALLOC],! SIGNAL THE PROBLEM
			OBMODESC[OMD$B_NAMLNG],LNK$GL_CURFIL[FDB$Q_FILENAME],
			.PSCTDESC[PSC$L_LENGTH],FDB[FDB$Q_FILENAME],
			LIN$_NOIMGFIL);
		LNK$GL_CTLMSK[LNK$V_IMAGE] = FALSE;			! TURN OFF THE IMAGE
		END;
	IF NOT .OBMODESC[OMD$V_SHRIMG]					! IF NOT A SHAREABLE IMAGE
	THEN BEGIN
	    IF .PSCTDEF[GPS$L_ALLOC] GTRU .PSCTDESC[PSC$L_LENGTH]	! P-SECTION MAXIMIZE
		THEN PSCTDESC[PSC$L_LENGTH] = .PSCTDEF[GPS$L_ALLOC];	! THE ALLOCATION
	    END
	ELSE BEGIN
	    IF .SGPSTYPE						! IF SPECIAL SHAREABLE IMAGE PSECT
		THEN PSCTDESC[PSC$L_LENGTH] = .PSCTDEF[SGPS$L_ALLOC];	!  THEN SET LENGTH OF PSECT
	    END;
	 END;
    IF NOT .OBMODESC[OMD$V_SHRIMG]
    THEN BEGIN
	MODPSCONTRIBLK[MPC$L_LENGTH] = .PSCTDEF[GPS$L_ALLOC];		! SET MODULE'S CONTRIBUTION
	OBMODESC[OMD$L_ALLOC] = .OBMODESC[OMD$L_ALLOC] +		! FINALLY ACCUMULATE THE CONTRIBUTION
				.MODPSCONTRIBLK[MPC$L_LENGTH];
	END;
    END;
!
!	NOW GO DOWN THE LIST OF PREMATURE SYMBOLS
!		(THOSE AWAITING DEFINITION OF THIS PSECTION)
!		AND RELOCATE THEM (IF THEY ARE RELOCATABLE)
!		AND THEN LINK THEM ON TO THE P-SECTON LIST
!
WHILE (PREMSYM=.PREMSYMLST) NEQ 0 DO				! RELOCATABLE AND THERE
BEGIN								! ARE SOME PREMATURE
	IF .PREMSYM[SYM$V_REL]					! FOR EACH THAT IS RELOCATABLE
	THEN PREMSYM[SYM$L_VALUE]=.PREMSYM[SYM$L_VALUE]+	! ADD IN THE BASE OFFSET
				.MODPSCONTRIBLK[MPC$L_OFFSET];	! OF THE MODULE'S
	PREMSYMLST = .PREMSYM[SYM$L_PSCLST];			! TAKE IT OFF LIST
	PREMSYM[SYM$L_PSCLST] = .PSCTDESC[PSC$L_SYMLST];	! AND PUT ON THE
	PSCTDESC[PSC$L_SYMLST] = .PREMSYM;			! P-SECTION SYMBOL LIST
END;
!
! COMPUTE LENGTH OF THIS GSD SUBRECORD
!
IF .SGPSTYPE
    THEN LENGTH = PSCTDEF[SGPS$T_NAME] - PSCTDEF[SGPS$T_START]
			+ .PSECTNAME[0]
    ELSE LENGTH = PSCTDEF [GPS$T_NAME] - PSCTDEF [GPS$T_START] +
		.PSECTNAME[0];

GSDOFFSET = .GSDOFFSET + .LENGTH;				! UPDATE GSD OFFSET INTO RECORD

RETURN TRUE;
END;		! OF P-SECTION PROCESSOR

ROUTINE CREFILTER (DEFINITION, WEAKFLAG, ALTOMD) =
BEGIN
!
!	THIS ROUTINE FILTERS FROM THE CROSS REFERENCE THE SYMBOLS
!	OF THE DEBUGGER AND ALSO MASKS THEM FROM APPEARING IN ANY
!	OTHER SYMBOL TABLE OUTPUT. (STB FILE OR GST OF IMAGE)
!
!	IT ALSO DECIDES IF ANY CROSS REFERENCE IS TO BE DONE
!	AT ALL.
!
!	THE ARGUMENT "DEFINITION" HAS VALUE TRUE OR FALSE.
!
MAP
    ALTOMD : REF BLOCK[,BYTE];

BUILTIN
    NULLPARAMETER;

BIND
    OBJMODESC = (IF NULLPARAMETER(3)
			THEN OBMODESC				! IF NOT SPECIFIED, THEN USE THE LOCAL ONE
			ELSE .ALTOMD) : BLOCK[,BYTE];		! IF SPECIFIED, USE IT

IF .SYMTABENT[SYM$V_LCLSYM]					! NO CROSS REF OF MODULE LOCAL SYMBOLS
   THEN RETURN TRUE;

IF .LNK$GL_CURFIL[FDB$V_DEBUGER]				! IF THIS FILE CONTAINS THE DEBUGGER
THEN BEGIN
    IF .DEFINITION						! AND IF THIS IS A DEFINITION
	THEN SYMTABENT[SYM$V_SUPRES] = TRUE;			! SUPPRESS IT FROM STB OUTPUT
    IF .LNK$GL_CTLMSK[LNK$V_SUPDBG]				! IF ALSO SUPRESSING
	THEN RETURN TRUE;					! DEBUGGER SYMBOLS FROM MAP
    END;							! THAT IS ALL

IF .LNK$GL_CTLMSK[LNK$V_BRIEF]					! IF A BRIEF MAP THEN
    THEN RETURN TRUE;						! ALSO ALL DONE

IF .LNK$GL_CTLMSK[LNK$V_INTFIL]					! IF THIS IS THE INTERNAL (SYSLIB) FILE
    AND .LNK$GL_CTLMSK[LNK$V_SUPSYS]				! AND ITS CONTENTS ARE SUPPRESSED
    THEN IF NOT .LNK$GL_CTLMSK[LNK$V_CROS]			! IF NO CROSS REFERENCE
	OR NOT .DEFINITION					! OR THIS IS A REFERENCE
	OR .SYMTABENT[SYM$V_SUPRES]				! OR THE SYMBOL HAS BEEN SUPPRESSED
	    THEN RETURN TRUE					! THEN ALL DONE
	    ELSE OBJMODESC[OMD$V_MAPMOD] = TRUE;		! BUT IF SYMBOL IS ENTERED MAKE SURE MODULE GETS MAPPED

IF (.DEFINITION OR .LNK$GL_CTLMSK[LNK$V_CROS])			! IF WE ARE GOING TO CREF THIS SYMBOL
THEN BEGIN
    IF .SYMENTNAM[SNB$B_NAMLNG] GTR .LNK$GL_MAXSYMSZ		! IF THIS SYMBOL NAME IS BIGGER THAN BIGGEST SEEN
	THEN LNK$GL_MAXSYMSZ = .SYMENTNAM[SNB$B_NAMLNG];	!  THEN MAKE THIS THE BIGGEST
    IF .OBJMODESC[OMD$B_NAMLNG] GTR .LNK$GL_MAXMODSZ		! ALSO CHECK THE MODULE NAME LENGTH
	THEN LNK$GL_MAXMODSZ = .OBJMODESC[OMD$B_NAMLNG];
    END;

IF .DEFINITION							! IF THIS IS A DEFINITION MUST
THEN BEGIN
    CRF$INSRTKEY(LNK$AL_SYTBLFMT,SYMENTNAM[SNB$B_NAMLNG],	! AT LEAST ENTER THE VALUE
			SYMTABENT[SYM$L_VALUE],.SYMTABENT[SYM$W_FLAGS]); ! BY ADDRESS AND PASSING THE FLAGS AS VALUE FLAGS
    SYMTABENT[SYM$V_CROSREF] = TRUE;				! FLAG SYMBOL HAS BEEN CROSS REFERENCED IF DEFINITION
    END;

IF .LNK$GL_CTLMSK[LNK$V_CROS]					! IF A CROSS REFERENCE IS BEING PRODUCED
THEN BEGIN
    CRF$INSRTREF(LNK$AL_SYTBLFMT,SYMENTNAM[SNB$B_NAMLNG],	! THEN INSERT THIS REFERENCE
				OBJMODESC[OMD$B_NAMLNG],.WEAKFLAG,.DEFINITION);
    LNK$GW_NCROSRFS = .LNK$GW_NCROSRFS + 1;			! AND COUNT IT
    END;

RETURN TRUE
END;

ROUTINE PROSYMBOL (ENTMSKFLG) =
BEGIN
!
!++
!	THIS ROUTINE DOES ALL THE WORK OF PROCESSING SYMBOLS ON
!	PASS 1, INCLUDING ENTRY POINTS, SIMPLE SYMBOL DEFINITIONS
!	AND REFERENCES AND PROCEDURE NAMES. THE FOLLOWING OPERATIONS
!	ARE PERFORMED.
!		(1) IF THE CURRENT OBJECT MODULE IS A SELECTIVE
!		    SEARCH MODULE, THEN ONLY DEFINITIONS ARE
!		    CONSIDERED. THESE ARE IGNORED UNLESS THERE
!		    IS A CURRENT OUTSTANDING REFERENCE TO THAT SYMBOL.
!		(2) IF A DEFINITION ALREADY EXISTS IN THE TABLE AND THIS
!		    INCOMING SYMBOL IS A DEFINITION, PRODUCE AN ERROR UNLESS
!		    THEY ARE EQUAL, ABSOLUTE SYMBOLS OR UNLESS THIS
!		    IS A SELECTIVE SEARCH MODULE
!		(3) IF THERE IS NO SYMBOL IN THE TABLE, INSERT THIS
!		    ONE.
!		(4) IF THE ENTRY FOUND IS A REFERENCE AND THE IN
!		    COMING SYMBOL IS A DEFINITION, THE FLAGS, DATA TYPE
!		    AND VALUE ARE COPIED INTO THE ENTRY AFTER REMOVING IT
!		    FROM THE UNDEFINED LIST.
!		(5) IF THE P-SECTION SPECIFICATION HAS BEEN SEEN,
!		    THE BASE OF THIS MODULE'S CONTRIBUTION TO THE P-SECTION IS
!		    ADDED, AND THE SYMBOL LINKED ON TO THE P-SECTION
!		    SYMBOL LIST.
!		(6) IF P-SECTION HAS NOT BEEN SEEN, FIND THE MAPPING
!		    TABLE ENTRY AND LINK THIS SYMBOL ON TO ITS
!		    LIST OF PREMATURELY DEFINED SYMBOLS. THE SYMBOL
!		    WILL BE RELOCATED WHEN P-SECTION IS DEFINED.
!		(7) UNDEFINED SYMBOLS ARE LINKED ON TO THE UNDEFINED
!		    SYMBOL LIST AND A COUNT OF THEM IS KEPT IF THE
!		    REFERENCES TO THEM ARE NOT WEAK.
!
!	ENTMSKFLG IS 1 IF THE SYMBOL CONTAINS AN ENTRY MASK, 0 OTHERWISE
!
!
!--
!
ROUTINE SHRIMGSYM =
BEGIN
!
! THIS ROUTINE LINKS A SYMBOL TABLE ENTRY INTO THE LIST OF REFERENCED SYMBOLS
! IN A SHAREABLE IMAGE.  THE SYMBOL IS COUNTED ALSO.
!
BIND
    SHRIMGCLU = .SYMTABENT[SYM$L_CLUDSC] : BLOCK[,BYTE];

IF .SHRIMGCLU[CLU$V_BASED]
    OR .LNK$GL_DEFCLU[CLU$V_BASED]
    OR NOT .SYMTABENT[SYM$V_REL]
    THEN RETURN TRUE;
IF .SHRIMGCLU[CLU$L_SHRSYMS] EQL 0				! IF NO SYMBOLS YET THIS CLUSTER
THEN LNK$GL_SHRIMGS = .LNK$GL_SHRIMGS + 1;			! THEN COUNT THIS SHAREABLE IMAGE

SHRIMGCLU[CLU$L_SHRSYMS] = .SHRIMGCLU[CLU$L_SHRSYMS] + 1; 	! COUNT THIS SYMBOL IN CLUSTER
LNK$GL_SHRSYMS = .LNK$GL_SHRSYMS + 1;				! COUNT IN TOTAL NUMBER OF SYMBOLS
SYMTABENT[SYM$L_SHRLNK] = .SHRIMGCLU[CLU$L_SHRLST];		! LINK SYMBOL INTO LIST OFF CLUSTER DESCRIPTOR
SYMTABENT[SYM$V_GREF] = TRUE;					! FLAG SYMBOL HAS BEEN ENTERED INTO SHR LST
SHRIMGCLU[CLU$L_SHRLST] = .SYMTABENT;
RETURN TRUE
END;

!
! MAIN BODY OF PROSYMBOL
!
LOCAL
	FOUND,							! TRUE IF FOUND IN TABLE
	SYMBOLVALUE,						! VALUE OF SYMBOL FROM OBJECT FILE
	SYMBOLCLUSTER : REF BLOCK[,BYTE],			! POINTER TO CLUSTER DESCRIPTOR
	NXTSYMENT : REF BLOCK[,BYTE],				! USED AS POINTER IN SCAN OF UNDEFINED LIST
	PSCTMAPENT : REF BLOCK[,BYTE],				! POINTER TO MAPPING TABLE ENTRY
	PSCTDESC : REF BLOCK[,BYTE],				! POINTER TO P-SECT DESCRIPTION
	MODPSCONTRIBLK : REF BLOCK[,BYTE];			! POINTER TO THIS MODULE'S 
								! CONTRIBUTION BLOCK
BIND
	SYMBOLREC = OBJVEC[.GSDOFFSET] : BLOCK[,BYTE];
!
BUILTIN
	INSQUE,							! INSERTS ENTRIES IN INDEFINED LIST
	REMQUE;							! REMOVES THEM

SYMTABENT = 0;
!
!	FIRST CHECK VALID SYMBOL NAME
!
IF .SYMBOLSTRING[0] GTRU SYM$C_MAXLNG				! IF THE SYMBOL LENGTH IS OUTSIDE
OR .SYMBOLSTRING[0] EQL 0					! LEGAL RANGE
THEN BEGIN
    SIGNAL(LIN$_ILLNAMELEN,6,					! ISSUE AN ERROR MESSAGE
		LNK$GT_SYMSTRING,
		SYMBOLSTRING[0],.SYMBOLSTRING[0],SYM$C_MAXLNG,
		OBMODESC[OMD$B_NAMLNG],LNK$GL_CURFIL[FDB$Q_FILENAME]);
    RETURN FALSE;
    END;

IF .SYMBOLREC[GSY$V_DEF]
    THEN SYMBOLVALUE = (IF NOT .LCLSYMGSD
			THEN (IF .WORDPSECTGSD			! EXTRACT THE SYMBOL VALUE FROM THE RECORD
				THEN .SYMBOLREC[SDFW$L_VALUE]
				ELSE .SYMBOLREC[SDF$L_VALUE])
			ELSE .SYMBOLREC[LSDF$L_VALUE])
    ELSE SYMBOLVALUE = 0;

IF .OBMODESC[OMD$V_SELSER]					! IF SELECTIVE SEARCH
    AND .SYMBOLREC[GSY$V_DEF]					! MODULE, AND THIS IS A
THEN BEGIN							! DEFINITION, IGNORE IT UNLESS
    IF NOT (FOUND = (IF .LCLSYMGSD
			THEN LNK$SEARCHLOCAL(SYMBOLSTRING[0],.SYMBOLREC[LSY$W_ENVINDX],
						SYMTABENT,SYMENTNAM)
			ELSE LNK$SEARCH(SYMBOLSTRING[0],SYMTABENT,SYMENTNAM))) ! IT HAS ALREADY
	THEN RETURN TRUE;
    END

!
! ELSE IF NOT A SELECTIVE SEARCH OR A REFERENCE
!
ELSE IF NOT (FOUND = (IF .LCLSYMGSD
			THEN LNK$SEARCHLOCAL(SYMBOLSTRING[0],.SYMBOLREC[LSY$W_ENVINDX],
						SYMTABENT,SYMENTNAM)
			ELSE LNK$SEARCH(SYMBOLSTRING[0],SYMTABENT,SYMENTNAM)))
	THEN BEGIN						! OR IT IS A REFERENCE
		LNK$INSERT(SYMBOLSTRING[0],SYMTABENT,SYMENTNAM);
		IF .LCLSYMGSD
		    THEN LNK$GW_NLSYMS = .LNK$GW_NLSYMS  + 1
		    ELSE LNK$GW_NSYMBOLS = .LNK$GW_NSYMBOLS + 1;	! INSERT IT AND COUNT IT
		SYMTABENT[SYM$V_WEAK] = .SYMBOLREC[GSY$V_WEAK];		! COPY THE WEAK, RELOCATABLE
		SYMTABENT[SYM$V_REL] = .SYMBOLREC[GSY$V_REL];		! (OMIT DEF FOR NOW)
		SYMTABENT[SYM$V_UNI] = .SYMBOLREC[GSY$V_UNI];		! AND UNIVERSAL FLAGS
		SYMTABENT[SYM$V_LCLSYM] = .LCLSYMGSD;			! SET FLAG IF LOCAL SYMBOL
		IF .LNK$GL_CTLMSK[LNK$V_INTFIL]				! IF THIS IS THE INTERNAL (SYSTEM
		    AND .LNK$GL_CTLMSK[LNK$V_SUPSYS]			! LIBARY FILE) AND THE DSUPPRESSION
		    OR .SYMTABENT[SYM$V_LCLSYM]				! OR IT'S A MODULE-LOCAL SYMBOL
		    THEN SYMTABENT[SYM$V_SUPRES] = TRUE;		! THEN SUPRESS THIS SYMBOL
		IF NOT .SYMBOLREC[GSY$V_DEF]				! AND IF IT WAS A REFERENCE
		THEN BEGIN						! JUST INSERTED IN TABLE
			LNK$INSUDFSYM(.SYMTABENT);			! INSERT IN UNDEFINED SYMBOL LIST
			IF NOT .SYMTABENT[SYM$V_WEAK]			! IF THE REFERENCE IS NOT WEAK REFERENCE
			    AND NOT .SYMTABENT[SYM$V_LCLSYM]		!   AND NOT A LOCAL SYMBOL
			THEN BEGIN
			IF .LNK$GL_LIBSYM NEQ 0 THEN
				BEGIN
				BIND LIBSYMNAM = .LNK$GL_LIBSYM - 
				    .LNK$GL_LIBSYM[SYM$B_NAMLNG] - SNB$C_FXDLEN : BLOCK[,BYTE];
				IF .LNK$GL_CURFIL[FDB$V_LIBSRCH]	! IF THE CURRENT FILE IS A SEARCH
									! LIBRARY AND THE MODULE IS PULLED
				AND (.LNK$GL_LIBSYM EQL LNK$GL_UDFLST	! AND THE LIST HAS EMPTIED DURING
				    OR					! THE PROCESSING OF THIS MODULE OR
				CH$LSS(.SYMENTNAM[SNB$B_NAMLNG],
					SYMENTNAM[SNB$T_NAME],
					.LIBSYMNAM[SNB$B_NAMLNG],
					LIBSYMNAM[SNB$T_NAME]))
				THEN LNK$GL_CURFIL[FDB$V_NEWUDF] = TRUE;! FOR THE FILE SO THAT THE LIBRARY
									! SEARCH WILL RETURN TO THE TOP OF
									! UNDEFINED LIST ONE MORE TIME
				END;
			     END;
			CREFILTER (FALSE, .SYMBOLREC[GSY$V_WEAK]);
		     	RETURN TRUE;				! AND WE ARE DONE WITH THIS
		     END;					! UNRESOLVED REFERENCE SO RETURN SUCCESS
	     END;
IF .SYMTABENT[SYM$V_DEF]					! IF THE ENTRY IN
THEN BEGIN							! THE SYMBOL TABLE IS
    IF .OBMODESC[OMD$V_SELSER]					! A DEFINITION AND
	THEN RETURN TRUE					! THIS IS SELECTIVE
	ELSE IF NOT .SYMBOLREC[GSY$V_DEF]			! SEARCH, IGNORE SYMBOL.
	THEN BEGIN						! IGNORE REFERENCE TO DEFINED SYMBOL EXCEPT FOR CREF
	    IF .SYMTABENT[SYM$V_SHRIMG]				! IF SYMBOL IS FROM SHAREABLE IMAGE
		AND NOT .SYMTABENT[SYM$V_CROSREF]		!  AND HAS NOT BEEN CROSS-REF'D YET
	    THEN BEGIN
		LOCAL
		    DEFOMDPTR : REF BLOCK[,BYTE];

		IF NOT .SYMTABENT[SYM$V_GREF]				! ENTER SYMBOL INTO SHR LIST IF NOT DONE YET
		    THEN SHRIMGSYM();
		LIB$LOOKUP_TREE(LNK$GL_OMDTREE,				! FIND OMD FOR MODULE THIS SYMBOL DEFINED IN
				.SYMTABENT[SYM$L_OMDNUM],
				LNK$COMPARE_OMD,DEFOMDPTR);
		CREFILTER(TRUE,.SYMTABENT[SYM$V_WEAK], 			! CROSS REF THE DEFINITION
					.DEFOMDPTR[NODE$L_PTR]);
		IF .LNK$GL_CTLMSK[LNK$V_LONG]				! IF A LONG FORM MAP IS REQUIRED
		    AND NOT .SYMTABENT[SYM$V_REL]			! AND THIS SYMBOL IS BASED
		    AND NOT .SYMTABENT[SYM$V_SUPRES]			!  AND NOT SUPRESSED
		    THEN CRF$INSRTREF(LNK$AL_VALCTLTB,			! INSERT THIS
				SYMTABENT[SYM$L_VALUE],			! SYMBOL AS A REFERENCE TO ITS
				SYMENTNAM[SNB$B_NAMLNG],		! VALUE
				.SYMTABENT[SYM$W_FLAGS],0);
	END;
	    CREFILTER (FALSE, .SYMBOLREC[GSY$V_WEAK]);
	    IF .SYMTABENT[SYM$V_SHRIMG]				! IF SYMBOL IS FROM SHAREABLE IMAGE
		AND NOT .SYMTABENT[SYM$V_GREF]			!  AND HAS NOT BEEN LINKED INTO SHR LIST
		THEN SHRIMGSYM();				! THEN DO SO NOW
	    RETURN TRUE;					! AND ALL DONE
	    END;
!
!	HERE WE HAVE A MULTIPLE DEFINITION FROM A NON SELECTIVE
!	SEARCH MODULE. IF BOTH DEFINITIONS ARE ABSOLUTE AND
!	THE VALUES ARE EQUAL ALL IS WELL. OTHERWISE WE
!	HAVE AN ERROR.
!
	IF .SYMBOLVALUE EQL .SYMTABENT[SYM$L_VALUE]
	    AND NOT .SYMBOLREC[GSY$V_REL]
	    AND NOT .SYMTABENT[SYM$V_REL]
	    THEN RETURN TRUE;
	IF .SYMTABENT[SYM$V_OPTSYM]					! IF DEFINED BY OPTION
	    AND NOT .SYMBOLREC[GSY$V_REL]				! AND 2ND DEF. IS ABSOLUTE
	    THEN RETURN TRUE;						! THEN RETURN QUIETLY
	IF .SYMTABENT[SYM$V_SHRIMG]					! IF SYMBOL FROM SHAREABLE IMAGE
	    AND (
		IF (SYMBOLCLUSTER = .SYMTABENT[SYM$L_CLUDSC]) EQL 0	!  AND THE IMAGE IS BASED
		    THEN FALSE
		    ELSE .SYMBOLCLUSTER[CLU$V_BASED]
		)
	    AND .LNK$GL_CURCLU[CLU$V_SHRIMG]				!  AND THIS IS SHR IMAGE ALSO
	    AND .LNK$GL_CURCLU[CLU$V_BASED]				!  WHICH IS BASED
	    AND (.SYMTABENT[SYM$L_VALUE] + .SYMBOLCLUSTER[CLU$L_BASE]	!  AND THE VALUES ARE THE SAME
				EQL .SYMBOLVALUE + .LNK$GL_CURCLU[CLU$L_BASE])
	    THEN RETURN TRUE;						! THEN IGNORE THIS DEFINITION COMPLETELY
	SIGNAL(LIN$_MULDEF,3,SYMBOLSTRING[0],
				OBMODESC[OMD$B_NAMLNG],
				LNK$GL_CURFIL[FDB$Q_FILENAME]);
	IF NOT .SYMBOLREC[GSY$V_REL]				! IF BOTH ARE ABSOLUTE
	    AND NOT .SYMTABENT[SYM$V_REL]			! THEN WE SIMPLY RE-DEFINE
	    THEN SYMTABENT[SYM$L_VALUE] = .SYMBOLVALUE;		! THE VALUE
	RETURN TRUE;
	END
!
!	THE ENTRY IN THE SYMBOL TABLE IS EITHER A NEW REFERENCE
!	JUST INSERTED OR A REFERENCE AWAITING DEFINITION.
!
!	IF THIS IS AN INCOMING DEFINITION WE PROCEED TO DEFINE THE
!	SYMBOL. THAT IS:
!			IF UDFLINK FIELD IS NON ZERO, THE TABLE ENTRY
!			IS ON THE UNDEFINED SYMBOL LIST, SO REMOVE IT
!			AND DECREMENT THE UNDEFINED COUNT (PROVIDED IT IS
!			NOT A WEAK REFERENCE).
!
!			THEN COPY INTO THE SYMBOL TABLE ENTRY THE FLAGS,
!			VALUE, ENTRY MASK, DATA TYPE AND FINALLY
!			LINK THE SYMBOL ON THE OWNING P-SECTION LIST
!
!	IF THIS IS (ANOTHER) INCOMING REFERENCE, AND IT IS
!	NOT A WEAK REFERENCE, ENSURE THAT THE SYMBOL TABLE ENTRY IS
!	ALSO NOT A WEAK REFERENCE AND THAT THIS STRONG REFERENCE
!	TO AN UNDEFINED SYMBOL IS COUNTED.
!
ELSE BEGIN
	IF NOT .SYMBOLREC[GSY$V_DEF]					! IF THIS IS
	THEN BEGIN							! ANOTHER REFERENCE
		CREFILTER (FALSE, .SYMBOLREC[GSY$V_WEAK]);		! CROSS REFERENCE IT THEN
									! IF WEAK, IGNORE IT
		IF .SYMBOLREC[GSY$V_WEAK]				! SINCE ONE WE HAVE IS AT LEAST WEAK
		THEN RETURN TRUE;					! AND NOTHING TO BE DONE
		IF .SYMTABENT[SYM$V_WEAK]				! IF A STRONG REFERENCE AND SYMBOL TABLE
		THEN BEGIN						! ENTRY IS WEAK
			SYMTABENT[SYM$V_WEAK] = FALSE;			! MAKE SURE IT IS STRONG
			IF .SYMTABENT[SYM$V_LCLSYM]
			    THEN LNK$GW_NUDFLSYMS = .LNK$GW_NUDFLSYMS + 1! AND COUNT THE STRONG REFERENCE
			    ELSE LNK$GW_NUDFSYMS = .LNK$GW_NUDFSYMS + 1;
		     END;
		RETURN TRUE;						! AND THAT'S IT FOR REFERENCES.
	     END;
!
! AND NOW FOR A DEFINITION
!
	IF .SYMTABENT[SYM$L_UDFLINK] NEQ 0			! IF THIS SYMBOL TABLE ENTRY IS ON
	THEN BEGIN						! UNDEFINED SYMBOL LIST,
		REMQUE(SYMTABENT[SYM$L_UDFLINK],NXTSYMENT);	! REMOVE FROM THE LIST
		IF .NXTSYMENT EQL .LNK$GL_LIBSYM		! IF THE ONE REMOVED IS THE ONE TO SEARCH
		THEN LNK$GL_LIBSYM = .NXTSYMENT[SYM$L_UDFLINK];	! FOR NEXT, MOVE TO ONE BEYOND
		IF NOT .SYMTABENT[SYM$V_WEAK]			! IF IT IS NOT A WEAK REFERENCE
		THEN IF .SYMTABENT[SYM$V_LCLSYM]
			THEN LNK$GW_NUDFLSYMS = .LNK$GW_NUDFLSYMS - 1
			ELSE LNK$GW_NUDFSYMS = .LNK$GW_NUDFSYMS - 1;	! DECREMENT NUMBER UNDEFINED
	     END;
	SYMTABENT[SYM$W_FLAGS] = (.SYMTABENT[SYM$W_FLAGS] AND 	! PRESERVE THE SUPRESSION AND UNIVERSAL FLAGS
					(SYM$M_SUPRES OR SYM$M_UNI))
				OR .SYMBOLREC[GSY$W_FLAGS];	! AND OR IN THE NEW FLAGS
	SYMTABENT[SYM$V_ENTMSK] = .ENTMSKFLG;			! COPY THE ENTRY MASK FLAG
	IF .LNK$GL_CTLMSK[LNK$V_ALLUNIV]			! IF ALL SYMBOLS ARE TO BE UNIVERSAL
	    THEN SYMTABENT[SYM$V_UNI] = TRUE;			! THEN SET UNI FLAG NOW
	SYMTABENT[SYM$B_DATYP] = .SYMBOLREC[GSY$B_DATYP];	! COPY DATA TYPE
	SYMTABENT[SYM$L_VALUE] = .SYMBOLVALUE;			! COPY THE VALUE
	SYMTABENT[SYM$W_ENTMSK] = .ENTRYMASK;			! COPY THE MASK
	SYMTABENT[SYM$V_SHRIMG] = .OBMODESC[OMD$V_SHRIMG];	! SET/CLEAR SHAREABLE IMAGE FLAG
	PSCTMAPENT = FNDPSCMAPENT ((IF NOT .LCLSYMGSD
					THEN (IF .WORDPSECTGSD	! FIND PSECT MAPPING TABLE ENTRY
					    THEN .SYMBOLREC[SDFW$W_PSINDX]
					    ELSE .SYMBOLREC[SDF$B_PSINDX])
					ELSE .SYMBOLREC[LSDF$W_PSINDX]));
	PSCTDESC = .PSCTMAPENT[PMT$L_PSCDES];			! GET ADDRESS OF PSECT DESCRIPTOR
	SYMTABENT[SYM$L_CLUDSC] = .LNK$GL_CURCLU;		! SET POINTER TO CLUSTER DESCRIPTOR
	SYMTABENT[SYM$L_OMDNUM] = .LNK$GW_NMODULES;		! SET INDEX OF DEFINING MODULE
	IF .SYMTABENT[SYM$V_SHRIMG]				! COPY SHR IMAGE FLAG
	THEN BEGIN
	    SYMTABENT[SYM$V_UNI] = FALSE;			!  CLEARING UNI IF SYMBOL FROM ANOTHER IMAGE
	    IF .FOUND
		AND NOT .SYMTABENT[SYM$V_GREF]			! AND HAS NOT BEEN LINKED INTO THE LIST YET
		THEN SHRIMGSYM();				! THEN DO IT NOW
								! DON'T CREF SHAREABLE IMAGE SYMBOLS ON DEF.  IT WILL
								! BE CREF'ED WHEN A REFERENCE TO IT IS ENCOUNTERED
	    END
	ELSE LNK$GW_LSYMBOLS = .LNK$GW_LSYMBOLS + 1;			! NOT FROM A SHR IMAGE, COUNT ANOTHER SYMBOL THIS IMAGE
	IF .FOUND							! IF SYMBOL ALREADY REFERENCED
	    OR NOT .SYMTABENT[SYM$V_SHRIMG]				!  OR NOT FROM A SHAREABLE IMAGE
	THEN BEGIN
	    CREFILTER(TRUE,.SYMBOLREC[GSY$V_WEAK]);			! SO CROSS-REFERENCE IT NOW
	    IF .LNK$GL_CTLMSK[LNK$V_LONG]				! IF A LONG FORM MAP IS REQUIRED
		AND NOT .SYMTABENT[SYM$V_REL]				!  AND SYMBOL IS ABSOLUTE
		AND NOT .SYMTABENT[SYM$V_SUPRES]			!  AND NOT SUPRESSED
		THEN CRF$INSRTREF(LNK$AL_VALCTLTB,			! INSERT THIS
				SYMTABENT[SYM$L_VALUE],			! SYMBOL AS A REFERENCE TO ITS
				SYMENTNAM[SNB$B_NAMLNG],		! VALUE
				.SYMTABENT[SYM$W_FLAGS],0);
	    END;
	IF .PSCTDESC NEQ 0						! IF P-SECTION IS
	THEN BEGIN							! DEFINED, GET THIS
		MODPSCONTRIBLK = .PSCTMAPENT[PMT$L_MODCON];		! MODULE'S CONTRIBUTION
		SYMTABENT[SYM$L_VALUE] = .SYMTABENT[SYM$L_VALUE]+	! BLOCK AND ADD
				 .MODPSCONTRIBLK[MPC$L_OFFSET];		! THE OFFSET FROM
		SYMTABENT[SYM$L_PSCLST] = .PSCTDESC[PSC$L_SYMLST];	! P-SECT BASE
		PSCTDESC[PSC$L_SYMLST] = .SYMTABENT;			! LINK SYMBOL
									! ON TO P-SECT
	     END							! LIST
	ELSE BEGIN							! P-SECTION NOT
		SYMTABENT[SYM$L_PSCLST] = .PSCTMAPENT[PMT$L_SYMLST];	! DEFINED YET, SO
		PSCTMAPENT[PMT$L_SYMLST] = .SYMTABENT;			! LINK SYMBOL
									! ON LIST OFF
	     END;							! MAPPING TABLE
	RETURN TRUE;
     END;			! END OF DEFINITION
END;			! END OF SYMBOL ROUTINE

ROUTINE SYMBOLS =
BEGIN
!
LOCAL
	LENGTH;
!
BIND
	SYMBOLREC = OBJVEC [.GSDOFFSET] : BLOCK [,BYTE];
!
ENTRYMASK = 0;			! ZERO THE ENTRY MASK SINCE NONE EXISTS
!
IF NOT .SYMBOLREC[GSY$V_DEF]			! IF NOT DEFINED
THEN BEGIN
	LENGTH = SYMBOLREC [SRF$T_NAME] - SYMBOLREC [SRF$T_START] +
			.SYMBOLREC[SRF$B_NAMLNG];
	SYMBOLSTRING = SYMBOLREC[SRF$B_NAMLNG];	! POINT TO THE SYMBOL STRING
     END
ELSE BEGIN
	IF .WORDPSECTGSD			! IF A WORD OF PSECT NUMBER
	THEN BEGIN
	    LENGTH = SYMBOLREC [SDFW$T_NAME] - SYMBOLREC [SDFW$T_START] +
					.SYMBOLREC[SDFW$B_NAMLNG];
	    SYMBOLSTRING = SYMBOLREC[SDFW$B_NAMLNG];	! POINT TO THE SYMBOL
	    END
	ELSE BEGIN
	    LENGTH = SYMBOLREC [SDF$T_NAME] - SYMBOLREC [SDF$T_START] +
					.SYMBOLREC[SDF$B_NAMLNG];
	    SYMBOLSTRING = SYMBOLREC[SDF$B_NAMLNG];	! POINT TO THE SYMBOL
	    END;
     END;
IF NOT PROSYMBOL(0)				! GO PROCESS THIS SYMBOL
THEN RETURN FALSE;				! AND EXIT IF FAILURE
GSDOFFSET = .GSDOFFSET + .LENGTH;	! UPDATE THE GSD OFFSET FOR NEXT
RETURN TRUE;
END;

ROUTINE ENTPNTS =
BEGIN
!
LOCAL
	LENGTH;
!
BIND
	SYMBOLREC = OBJVEC [.GSDOFFSET] : BLOCK [,BYTE];

IF .WORDPSECTGSD
THEN BEGIN
    ENTRYMASK = .SYMBOLREC[EPMW$W_MASK];			! EXTRACT THE ENTRY POINT MASK
    LENGTH = SYMBOLREC [EPMW$T_NAME] - SYMBOLREC [EPMW$T_START] +
			.SYMBOLREC[EPMW$B_NAMLNG];
    SYMBOLSTRING = SYMBOLREC[EPMW$B_NAMLNG];			! POINT TO THE SYMBOL
    END
ELSE BEGIN
    ENTRYMASK = .SYMBOLREC[EPM$W_MASK];				! EXTRACT THE ENTRY POINT MASK
    LENGTH = SYMBOLREC [EPM$T_NAME] - SYMBOLREC [EPM$T_START] +
			.SYMBOLREC[EPM$B_NAMLNG];
    SYMBOLSTRING = SYMBOLREC[EPM$B_NAMLNG];			! POINT TO THE SYMBOL
    END;
IF NOT PROSYMBOL(1)						! GO PROCESS THE SYMBOL
THEN RETURN FALSE;						! AND EXIT IF FAILURE
GSDOFFSET = .GSDOFFSET + .LENGTH;				! ELSE UPDATE THE OFFSET FOR NEXT
RETURN TRUE;
END;

ROUTINE PROCEDEF =
BEGIN
!
!	A PROCEDURE DEFINITION IS AN EXTENDED ENTRY POINT DEFINITION, CARRYING WITH
!	IT A DESCRIPTION OF THE PROCEDURE'S FORMAL ARGUMENTS. PROCESSING THESE CONSISTS
!	IN NORMAL SYMBOL DEFINITION PROCESSING FOLLOWED BY:-
!		(1) VALIDATION OF THE FORMAT OF FORMAL DESCRIPTION (I.E. JUST CHECK
!			THAT MINIMUM NUMBER OF ARGUMENTS SPECIFIED IS LESS THAN
!			OR EQUAL TO THE MAXIMUM.
!		(2) ALLOCATION OF AN ARGUMENT VALIDATION DATA ARRAY WHICH
!			HAS THE FOLLOWING FORMAT:
!				------------
!				!  N+2     ! LENGTH OF ARRAY WHERE N = MAXIMUM # ARGUMENTS
!				------------
!				!  MIN     ! MINIMUM NUMBER OF ARGS
!				------------
!				! PASS M 1 ! PASSING MECHANISM OF ARG 1
!				------------
!				! PASS M 2 !    "        "         "  2
!				------------
!				   ETC TO N ARGUMENTS
!
!	NOTE THAT ONLY THE VALIDATION CONTROL BYTE, ARGUMENT PASSING MECHANISM
!	IS EXTRACTED FROM THE FORMAL ARGUMENT DESCRIPTORS. THE REST OF SUCH
!	DESCRIPTORS IS IGNORED.
!
!	THE SYMBOL TABLE ENTRY POINTS TO THIS ARRAY. NOTE THAT MULTIPLE DEFINITION OF THE
!	SAME PROCEDURE WILL REPLACE THE VALIDATION DATA WITH NEW DATA.
LOCAL
	ENTFLAG,
	ARGVALDATA : REF VECTOR[,BYTE],
	ARGCOUNT;
!
IF NOT ENTPNTS() THEN RETURN FALSE;				! PROCESS THE ENTRY POINT SYMBOL PART
ENTFLAG = .SYMTABENT NEQ 0;					! SEE IF ENTERED
BEGIN
    BIND FORMALS = OBJVEC [.GSDOFFSET] : BLOCK[,BYTE];		! THE FORMAL DESCRIPTION
	IF .FORMALS[FML$B_MINARGS] GTRU .FORMALS[FML$B_MAXARGS]		! IF THERE IS AN INCONSISTENT
	THEN BEGIN							! DESCRIPTION OF FORMALS
		SIGNAL(LIN$_ILLFMLCNT,5,				! OUTPUT ERROR MESSAGE
			.FORMALS[FML$B_MINARGS],.FORMALS[FML$B_MAXARGS],
			(IF .WORDPSECTGSD
				THEN OBJREC[PROW$B_NAMLNG]
				ELSE OBJREC[PRO$B_NAMLNG]),
			OBMODESC[OMD$B_NAMLNG],
			LNK$GL_CURFIL[FDB$Q_FILENAME]);
		RETURN FALSE;
		END;
	GSDOFFSET = .GSDOFFSET + FML$C_SIZE;			! UPDATE RECORD POINTER
	IF .ENTFLAG
	    AND (ARGVALDATA = .SYMTABENT[SYM$L_VALDATA]) NEQ 0	! IF VALIDATION DATA ALREADY EXISTS
	THEN BEGIN						! MUST BE A NEW DEFINITION
		LNK$DEALBLK(.ARGVALDATA[0],ARGVALDATA[0]);	! SO DISPOSE OF OLD DATA
		SYMTABENT[SYM$L_VALDATA] = 0;			! AND FORGET IT
	     END;
	IF (ARGCOUNT = .FORMALS[FML$B_MAXARGS] ) EQL 0		! IF MAXIMUM NUMBER ARGUMENTS
	THEN RETURN TRUE;					! IS ZERO, ALL DONE
	IF .ENTFLAG
	THEN BEGIN
	    LNK$ALLOBLK(.ARGCOUNT+2,SYMTABENT[SYM$L_VALDATA]);	! ALLOCATE A VALIDATION DATA BLOCK
	    ARGVALDATA = .SYMTABENT[SYM$L_VALDATA];
	    ARGVALDATA[0] = .ARGCOUNT + 2;			! SET ITS SIZE
	    ARGVALDATA[1] = .FORMALS[FML$B_MINARGS];		! SAVE MINIMUM ARGUMENT SPECIFICATION
	    END;
	INCR I FROM 1 TO .ARGCOUNT				! BEGIN A LOOP THROUGH
	DO BEGIN						! ALL FORMAL ARGUMENT DESCRIPTORS
		BIND ARGDESC = OBJVEC[.GSDOFFSET] : BLOCK[,BYTE]; ! POINT TO NEXT DESCRIPTOR
		IF .ENTFLAG
		    THEN ARGVALDATA[.I+1] = .ARGDESC[ARG$V_PASSMECH];	  ! EXTRACT THE PASSING MECHANISM
		GSDOFFSET = .GSDOFFSET + .ARGDESC[ARG$B_BYTECNT]+ ! AND UPDATE RECORD POINTER
				ARG$C_SIZE;
		END;
	RETURN TRUE;
     END;
END;

ROUTINE PROEOM (SEQCHKFLG) =
BEGIN
!
!	PROCESS END OF MODULE RECORDS:
!		(1) VALIDATE SEQUENCE
!		(2) INTERPRET COMPILER COMPLETION CODE,
!		    ISSUING APPROPRIATE ERROR OR WARNING
!		    MESSAGE
!		(3) VALIDATE THE TRANSFER ADDRESS
!			(IF ANY) FOR:
!			(A) P-SECTION DEFINED
!			(B) P-SECTION EXECUTABLE AND RELOCATABLE
!			(C) ADDRESS IS WITHIN THAT P-SECTION
!			(D) NOT A MULTIPLE SPECIFICATION -( RETAIN THE FIRST)
!		(4) RECORD THE  TRANSFER ADDRESS, SEPARATING AN ADDRESS IN
!			THE DEBUGGER FROM THAT OF THE USER.
!		(5) TRUNCATE THE MODULE DESCRIPTOR (MAPPING TABLE PORTION) TO ITS
!			CORRECT SIZE FOR NUMBER OF P-SECTS CONTRIBUTED TO.
!
BIND
	EOMREC = .OBJVEC : BLOCK[,BYTE];
BUILTIN
	NULLPARAMETER;
LOCAL
	COMCODE,
	DEFERREDSYM : REF BLOCK[,BYTE],			! POINTER TO DEFERRED SYMBOL
	DEFERREDSNB : REF BLOCK[,BYTE],			! DEFERRED SYMBOL NAME BLOCK
	MODPSCONTRIBLK : REF BLOCK[,BYTE],		! THE MODULE'S CONTRIBUTION TO P-SECT
	WORDPSECTEOM,					! TRUE IF EOMW RATHER THAN EOM
	PSCTMAP : REF BLOCK[,BYTE],			! PSECT MAPPING TABLE POINTER
	PSCTNUM,					! P-SECTION NUMBER OF TRANSFER ADDRESS
	TFRWEAK,					! TRUE IF TRANSFER ADDRESS THIS EOM IS WEAK
	TFRADR,						! TEMP FOR TRANSFER ADDRESS
	TFRPSC : REF BLOCK[,BYTE],			! TEMP FOR P-SECT DESC. ADDR.
	OBJDESC : REF BLOCK[,BYTE],			! POINTER TO ALLOCATED OBJ MOD DESCRIPTOR
	OMDNODE,
	CURCONTRIBLK : REF BLOCK[,BYTE],
	NEXTCONTRIBLK : REF BLOCK[,BYTE],
	OBJDESCSIZE;					! SIZE OF OBJ MOD DESCRIPTOR TO ALLOCATE
!
IF NULLPARAMETER(1)
    THEN IF NOT SEQCHK()
	THEN RETURN FALSE;				! VALIDATE THE SEQUENCE OF EOM
WORDPSECTEOM = (.EOMREC[EOM$B_RECTYP] EQL OBJ$C_EOMW);		! DECIDE IF EOM OR EOMW
IF (IF .WORDPSECTEOM						! CHECK LENGTH OF RECORD
    THEN (.RECLNG NEQ EOMW$C_EOMMIN
	    AND ((.RECLNG LSS EOMW$C_EOMMX1) OR (.RECLNG GTR EOMW$C_EOMMAX)))
    ELSE (.RECLNG NEQ EOM$C_EOMMIN				! AND ITS LENGTH
	AND ((.RECLNG LSS EOM$C_EOMMX1) OR (.RECLNG GTR EOM$C_EOMMAX))))
THEN BEGIN
	SIGNAL(LIN$_ILLRECLEN,3,				! AND ISSUE ERROR
			.RECLNG,
			OBMODESC[OMD$B_NAMLNG],
			LNK$GL_CURFIL[FDB$Q_FILENAME]);
	RETURN FALSE;
	END;
IF (COMCODE = .EOMREC[EOM$B_COMCOD]) NEQ 0			! IF NON ZERO COMPILATION CPLETE CODE
THEN BEGIN							! CHECK
	IF .COMCODE GTRU 3
	THEN BEGIN
	    SIGNAL(LIN$_BADCCC,3,				! IF AN ILLEGAL COMPLETION
		.COMCODE,OBMODESC[OMD$B_NAMLNG],		!  THEN TELL THAT AND QUIT
		LNK$GL_CURFIL[FDB$Q_FILENAME]);
	    RETURN FALSE;
	    END;
	CASE .COMCODE FROM EOM$C_WARNING TO EOM$C_ABORT		! SIGNAL MESSAGE BASED ON ERROR CLASS
	OF SET
	    [EOM$C_WARNING] : SIGNAL(LIN$_WRNERS,2,OBMODESC[OMD$B_NAMLNG],
					LNK$GL_CURFIL[FDB$Q_FILENAME]);
	    [EOM$C_ERROR] : BEGIN
				SIGNAL(LIN$_ERRORS,2,OBMODESC[OMD$B_NAMLNG],
					LNK$GL_CURFIL[FDB$Q_FILENAME],LIN$_NOIMGFIL);
				LNK$GL_CTLMSK[LNK$V_IMAGE] = FALSE;	! DISABLE IMAGE IF ERROR
				END;
	    [EOM$C_ABORT] :
			    BEGIN
				SIGNAL(LIN$_EOMFTL,2,OBMODESC[OMD$B_NAMLNG],
					LNK$GL_CURFIL[FDB$Q_FILENAME]);
				LNK$EXIT(LIN$_FATALERROR);		! LINK ABORT
				END;
	TES;
     END;
IF .OBMODESC[OMD$W_HIPSCT] EQL LNK$C_MAXPSECTS			! IF HIGHEST NUMBERED P-SECT
AND .OBMODESC[OMD$V_NOPSCT]					! IS LNK$C_MAXPSECTS AND STILL NO DEFINITIONS
THEN 								! BEEN SEEN
	SIGNAL_STOP(LIN$_NOPSCTS,2,				! THERE IS A FORMAT ERROR
			OBMODESC[OMD$B_NAMLNG],			! ISSUE MESSAGE
			LNK$GL_CURFIL[FDB$Q_FILENAME],
			LIN$_FORMAT);
IF (IF .WORDPSECTEOM
	THEN (.RECLNG GEQ EOMW$C_EOMMX1)
	ELSE (.RECLNG GEQ EOM$C_EOMMX1))			! IF RECORD LENGTH IS (MX1)
								! OR (MAX)
THEN BEGIN							! A TRANSFER ADDRESS EXISTS, SO
	PSCTNUM = (IF .WORDPSECTEOM				! GET THE P-SECTION INDEX AND
			THEN .EOMREC[EOMW$W_PSINDX]
			ELSE .EOMREC[EOM$B_PSINDX]);
	IF .PSCTNUM GTRU .OBMODESC[OMD$W_HIPSCT]
	OR .OBMODESC[OMD$V_NOPSCT]
	THEN BEGIN
		SIGNAL(LIN$_BADPSC,3,				! IF P-SECTION NOT DEFINED 
			.PSCTNUM,OBMODESC[OMD$B_NAMLNG],	! THEN OUTPUT ERROR AND QUIT
			LNK$GL_CURFIL[FDB$Q_FILENAME]);
		RETURN FALSE;
		END
	ELSE BEGIN
		PSCTMAP = FNDPSCMAPENT(.PSCTNUM);			! GET MAPPING TABLE ENTRY
		IF (TFRPSC = .PSCTMAP[PMT$L_PSCDES]) EQL 0		! SET THE POINTER TO THAT P-SECTION
		THEN BEGIN
		    SIGNAL(LIN$_BADPSC,3,				!  BUT ISSUE AN ERROR IF UNDEFINED
			.PSCTNUM,OBMODESC[OMD$B_NAMLNG],
			LNK$GL_CURFIL[FDB$Q_FILENAME]);
		    RETURN FALSE;
		    END;
		IF NOT .TFRPSC[PSC$V_EXE]				! IF THE P-SECTION CONTAINING THE
		    OR NOT .TFRPSC[PSC$V_REL]				! TRANSFER ADDRESS IS NOT
		THEN SIGNAL(LIN$_PSCNXR,2,				! THEN ISSUE AN ERROR MESSAGE
			OBMODESC[OMD$B_NAMLNG],LNK$GL_CURFIL[FDB$Q_FILENAME]);
		MODPSCONTRIBLK = .PSCTMAP[PMT$L_MODCON];
		TFRADR = (IF .WORDPSECTEOM
				THEN .EOMREC[EOMW$L_TFRADR]
				ELSE .EOMREC[EOM$L_TFRADR]) +		! BUT IN ANY CASE COMPUTE THE
					.MODPSCONTRIBLK[MPC$L_OFFSET];	! ADDRESS RELATIVE TO THE WHOLE P-SECT
		TFRWEAK = (IF .WORDPSECTEOM
				THEN ((.RECLNG EQL EOMW$C_EOMMAX) AND	! SET FLAG FOR WEAKNESS OF TRANSFER ADDRESS
						.EOMREC[EOMW$V_WKTFR])
				ELSE ((.RECLNG EQL EOM$C_EOMMAX) AND
						.EOMREC[EOM$V_WKTFR]));
		IF NOT .LNK$GL_CURFIL[FDB$V_DEBUGER]			! IF THE CURRENT INPUT FILE
									! DOES NOT CONTAIN THE DEBUGGER
		AND (.LNK$GL_TFRPSC EQL 0				! AND NO PREVIOUS TRANSFER ADDRESS WAS SPECIFIED
		OR (.WEAKTFRADR AND NOT .TFRWEAK))			! OR IT WAS A WEAK TRANSFER ADDRESS AND THIS ONE IS NOT
		THEN BEGIN
			IF .LNK$GT_IMGID[0] EQL 0			! IF STILL NO IMAGE IDENT
			    OR .LNK$GL_TFRPSC EQL 0			!  OR IDENT WAS FROM MODULE W/O TRANSFER ADDRESS
			THEN CH$MOVE(.IMAGEIDSTRING[0]+1,IMAGEIDSTRING[0],! THEN MOVE IN THE ONE OF
				LNK$GT_IMGID[0]);			! THIS MODULE AS SAVED ON MHD RECORD
			LNK$GL_TFRPSC = .TFRPSC;			! THEN THIS IS THE USER'S
			LNK$GL_TFRADR = .TFRADR;			! TRANSFER ADDRESS
			WEAKTFRADR = .TFRWEAK;				! REMEMBER IF THIS WAS WEAK OR STRONG TRANSFER ADDRESS
		     END
		ELSE IF .LNK$GL_CURFIL[FDB$V_DEBUGER]			! OTHERWISE IF THIS IS THE DEBUGGER FILE AND THERE HAS NOT
			AND .LNK$GL_DBGTFPS EQL 0			! PREVIOUSLY BEEN A DEBUGGER TRANSFER
			THEN BEGIN					! ADDRESS, MAKE THIS THE
				LNK$GL_DBGTFPS = .TFRPSC;		! DEBUGGER TRANSFER ADDRESS
				LNK$GL_DBGTFR = .TFRADR;		!
			     END					! 
			ELSE IF NOT .TFRWEAK
!
! THERE WAS A MULTIPLE TRANSFER ADDRESS AND THE TRANSFER ADDRESS FLAG
! BYTE WAS NOT PRESENT, OR WAS PRESENT AND THE WEAK TRANSFER ADDRESS
! FLAG WAS NOT ON.
!
			     THEN SIGNAL(LIN$_MULTFR,2,
					OBMODESC[OMD$B_NAMLNG],
					LNK$GL_CURFIL[FDB$Q_FILENAME]);
	     END;
     END;				! END OF TRANSFER ADDRESS PROCESSING

IF .LNK$GT_IMGID[0] EQL 0				! IF NO IMAGE IDENT YET
    THEN CH$MOVE(.IMAGEIDSTRING[0]+1,IMAGEIDSTRING[0],	!  THEN SET THIS MODULE'S AS THE IDENT (WILL GET OVERWRITTEN IF XFR ADR
			LNK$GT_IMGID[0]);		!    LATER)
OBJDESCSIZE = OBMODESC[OMD$T_PSCMAP] - OBMODESC +	! COMPUTE SIZE OF OBJ MOD DESC TO ALLOCATE
		PMT$C_SIZE*((IF NOT .OBMODESC[OMD$V_P256]
				THEN .OBMODESC[OMD$W_HIPSCT]+1
				ELSE (.OBMODESC[OMD$W_HIPSCT]+255)/256));
LNK$ALLOBLK (.OBJDESCSIZE, OBJDESC);			! ALLOCATE THE DESCRIPTOR
LASTOBJMOD[OMD$L_NXTOMD] = .OBJDESC;			! LINK INTO THE LIST
LASTOBJMOD = .OBJDESC;					! AND NEW BECOMES THE LAST THEN
CH$MOVE (.OBJDESCSIZE, OBMODESC, .OBJDESC);		! COPY THE DESCRIPTOR OUT
LIB$INSERT_TREE(LNK$GL_OMDTREE,.OBJDESC[OMD$L_OMDNUM],	! INSERT OMD INTO OMD TREE
		%REF(0),LNK$COMPARE_OMD,ALLOC_OMDNODE,OMDNODE,.OBJDESC);
OBJDESC[OMD$L_NXTOMD] = 0;				! ZERO LINK IN THE DESCRIPTOR
IF .OBMODESC[OMD$L_LSTERR] EQL OBMODESC[OMD$L_ERRTXT]	! CHECK FOR NO ERRORS
    THEN OBJDESC[OMD$L_LSTERR] = OBJDESC[OMD$L_ERRTXT];
!
! FILL IN THE FIELD MPC$L_OWNOMD FOR ALL PSECTS DEFINED IN THIS MODULE
!
CURCONTRIBLK = .OBMODESC[OMD$L_NXTOMD];			! GET LIST POINTER OF PSECT CONTRIBUTION BLOCKS
WHILE .CURCONTRIBLK NEQ 0
DO BEGIN
	NEXTCONTRIBLK = .CURCONTRIBLK[MPC$L_OWNOMD];	! GET LINK TO NEXT
	CURCONTRIBLK[MPC$L_OWNOMD] = .OBJDESC;		! SET OWNER POINTER
	CURCONTRIBLK = .NEXTCONTRIBLK;
	END;	
CH$FILL (0, .OBJDESCSIZE, OBMODESC);			! ZERO THE PROTOTYPE DESCRIPTOR
OBMODESC[OMD$L_LSTERR] = OBMODESC[OMD$L_ERRTXT];
MAXRECLNG = OBJ$C_MAXRECSIZ;				! RESET TO MAX ALLOWED BY LANGUAGE

RETURN TRUE;
END;				! END OF EOM PROCESSING

ROUTINE COUNTDBG =
BEGIN
!
!	ROUTINE TO COUNT THE NUMBER OF DEBUG (TYPES 4 AND 5) RECORDS SEEN AND TO
!	TOTAL THE NUMBER OF BYTES CONTAINED FOR USE AS AN ESTIMATE OF THE
!	SIZE OF DEBUG SYMBOL TABLE TO BE WRITTEN AT END OF BINARY
!	IF THE DEBUGGER IS LINKED IN. ALSO IF AN EXECUTABLE IMAGE
!	WITH THE DEBUGGER IS BEING PRODUCED, TURN OFF THE NO BINARY FLAG FOR
!	THIS MODULE (PROVIDED IT IS NOT THE DEBUGGER ITSELF).
!
IF NOT SEQCHK() 					! CHECK LEGAL SEQUENCE
    THEN RETURN FALSE;
IF .OBMODESC[OMD$V_DEBUGER]				! IF THIS IS THE DEBUGER ITSELF
    THEN RETURN TRUE;					! IGNORE ANY DEBUG RECORDS
LNK$GL_DBGESTIM = .LNK$GL_DBGESTIM + .RECLNG;		! ADD IN THE LENGTH OF THIS RECORD
LNK$GW_DBGRECS = .LNK$GW_DBGRECS + 1;			! AND COUNT THE RECORD
IF .LNK$GL_CTLMSK[LNK$V_DBG]				! IF IT CONTAINS THE DEBUGGER IT NOW HAS
    OR .LNK$GL_CTLMSK[LNK$V_TRACE]			!
    THEN OBMODESC[OMD$V_NOBIN] = FALSE;			! BINARY WE CARE ABOUT
RETURN TRUE;						! AND THAT IS ALL
END;

ROUTINE COMPARE_IDC(ENTITYNAME,NODE,IDCREC) =
BEGIN
!
! COMPARE AN ENTITY NAME WITH THE CURRENT NODE
!
MAP
    ENTITYNAME : REF VECTOR[,BYTE],
    NODE : REF BLOCK[,BYTE],
    IDCREC : REF BLOCK[,BYTE];

RETURN CH$COMPARE(.ENTITYNAME[0],ENTITYNAME[1],
		.NODE[IDCD$B_NAMLNG],NODE[IDCD$T_NAME],0)


END;

ROUTINE ALLOC_IDC(ENTITYNAME,RETNODEADR,IDCREC) =
BEGIN
!
! ALLOCATE AND FILL IN A NEW IDCD BLOCK
!
MAP
    ENTITYNAME : REF VECTOR[,BYTE],		! POINTS TO ASCIC NAME
    RETNODEADR : REF VECTOR[,LONG],
    IDCREC : REF BLOCK[,BYTE];			! THE IDC GSD SUB-RECORD

BIND
    IDENTSTRING = IDCREC[IDC$B_NAMLNG] + 1 + .IDCREC[IDC$B_NAMLNG] : VECTOR[,BYTE],	! IDENT STRING IN RECORD
    BINARYIDENT = IDENTSTRING[1],					! ADDR OF BINARY IDENT
    OBJECTNAME = IDENTSTRING[1] + .IDENTSTRING[0] : VECTOR[,BYTE];	! ADDR OF OBJECT NAME STRING

LOCAL
    PTR,
    IDSIZE,
    NEWNODE : REF BLOCK[,BYTE];

!
! COMPUTE SIZE OF IDENT STRING
!
IDSIZE = 0;
IF NOT .IDCREC[IDC$V_BINIDENT]
    THEN IDSIZE = .IDENTSTRING[0] + 1;
!
! ALLOCATE A NEW IDCD BLOCK
!
LNK$ALLOBLK(IDCD$C_SIZE+.ENTITYNAME[0]+.IDSIZE+.OBJECTNAME[0]+1,NEWNODE);	!+1 FOR SIZE OF OBJECTNAME IN ASCIC STRING
NEWNODE[IDCD$W_FLAGS] = .IDCREC[IDC$W_FLAGS];		! COPY FLAGS FROM IDC SUBRECORD
NEWNODE[IDCD$L_DEFOMD] = .LNK$GW_NMODULES;		! SET DEFINING MODULE NUMBER
NEWNODE[IDCD$L_DEFFDB] = .LNK$GL_CURFIL;		!  DEFINING FILE FDB ADDRESS
NEWNODE[IDCD$B_IDLNG] = .IDENTSTRING[0];		! LENGTH OF IDENT STRING
NEWNODE[IDCD$B_OBJLNG] = .OBJECTNAME[0];		! LENGTH OF OBJECT NAME STRING
NEWNODE[IDCD$B_NAMLNG] = .IDCREC[IDC$B_NAMLNG];		! ENTITY NAME LENGTH
PTR = CH$MOVE(.IDCREC[IDC$B_NAMLNG],			! COPY IN THE ENTITY NAME
		IDCREC[IDC$B_NAMLNG]+1,NEWNODE[IDCD$T_NAME]);
NEWNODE[IDCD$L_OBJNAM] = .PTR;				! SET POINTER TO OBJECT NAME
PTR = CH$MOVE(.OBJECTNAME[0]+1,OBJECTNAME[0],.PTR);	! MOVE IN THE OBJECT NAME
IF .NEWNODE[IDCD$V_BINIDENT]				! IF BINARY IDENT, SET IN THE IDENT
    THEN NEWNODE[IDCD$L_IDENT] = .BINARYIDENT
    ELSE BEGIN
	NEWNODE[IDCD$L_IDENT] = .PTR;			! ASCIC IDENT, SET POINTER TO IDENT STRING
	CH$MOVE(.IDENTSTRING[0]+1,IDENTSTRING[0],.PTR);	!  AND COPY IN THE IDENT
	END;
!
! RETURN NODE ADDRESS TO CALLER
!
RETNODEADR[0] = .NEWNODE;
RETURN TRUE
END;

ROUTINE RANDENTITY =
BEGIN
!
! THIS ROUTINE PROCESSES THE IDC GSD RECORD. 
!
LOCAL
    STATUS,
    LENGTH,
    DEFOMD : REF BLOCK[,BYTE],			! DEFINING OMD ADDRESS
    DEFFDB : REF BLOCK[,BYTE],			! DEFINING FDB ADDRESS
    IDENTSTRING : REF VECTOR[,BYTE],		! POINTER TO IDENT STRING
    OBJECTNAME : REF VECTOR[,BYTE],		! POINTER TO OBJECT NAME STRING
    ENTRY : REF BLOCK[,BYTE];			! ADDRESS OF ENTRY

BIND
    IDCREC = OBJVEC[.GSDOFFSET] : BLOCK[,BYTE];	! POINT TO THE IDC SUBRECORD

!
! CHECK THE LENGTH OF ALL THE NAME STRINGS
!
!
! THE ENTITY NAME
!
IF .IDCREC[IDC$B_NAMLNG] EQL 0
    OR .IDCREC[IDC$B_NAMLNG] GTRU SYM$C_MAXLNG
THEN BEGIN
    SIGNAL(LIN$_ILLNAMELEN,6,
		LNK$GT_ENTITY,IDCREC[IDC$B_NAMLNG],
		.IDCREC[IDC$B_NAMLNG],SYM$C_MAXLNG,
		OBMODESC[OMD$B_NAMLNG],
		LNK$GL_CURFIL[FDB$Q_FILENAME]);
    RETURN FALSE
    END;
!
! THE IDENT STRING
!
IDENTSTRING = IDCREC[IDC$B_NAMLNG] + 1 + .IDCREC[IDC$B_NAMLNG];
IF .IDENTSTRING[0] EQL 0
    OR .IDENTSTRING[0] GTRU SYM$C_MAXLNG
THEN BEGIN
    SIGNAL(LIN$_ILLNAMELEN,6,
		LNK$GT_IDENT,IDENTSTRING[0],
		.IDENTSTRING[0],SYM$C_MAXLNG,
		OBMODESC[OMD$B_NAMLNG],
		LNK$GL_CURFIL[FDB$Q_FILENAME]);
    RETURN FALSE
    END;
!
! AND THE OBJECT NAME
!
OBJECTNAME = IDENTSTRING[1] + .IDENTSTRING[0];
IF .OBJECTNAME[0] EQL 0
    OR .OBJECTNAME[0] GTRU SYM$C_MAXLNG
THEN BEGIN
    SIGNAL(LIN$_ILLNAMELEN,6,
		LNK$GT_OBJNAM,OBJECTNAME[0],
		.OBJECTNAME[0],SYM$C_MAXLNG,
		OBMODESC[OMD$B_NAMLNG],
		LNK$GL_CURFIL[FDB$Q_FILENAME]);
    RETURN FALSE
    END;
!
! UPDATE GSD OFFSET INTO RECORD
!
LENGTH = OBJECTNAME[1] + .OBJECTNAME[0] - IDCREC;
GSDOFFSET = .GSDOFFSET + .LENGTH;
!
! ENTRY APPEARS GOOD.  LET'S ENTER IT
!
IF (STATUS = LIB$INSERT_TREE(LNK$GL_ENTITREE,IDCREC[IDC$B_NAMLNG],
			%REF(0),COMPARE_IDC,ALLOC_IDC,ENTRY,
			IDCREC)) EQL LIB$_KEYALRINS
THEN BEGIN
    LIB$LOOKUP_TREE(LNK$GL_OMDTREE,.ENTRY[IDCD$L_DEFOMD],	! FIND DEFINING MODULE OMD
		LNK$COMPARE_OMD,DEFOMD);
    DEFOMD = .DEFOMD[NODE$L_PTR];				! REALLY POINT TO THE OMD
    DEFFDB = .ENTRY[IDCD$L_DEFFDB];				! GET THE DEFINING FDB
        IF (.IDCREC[IDC$V_BINIDENT] NEQ .ENTRY[IDCD$V_BINIDENT])	! IF BOTH ARE NOT THE SAME (ASCIC OR BINARY)
	OR (.IDCREC[IDC$V_BINIDENT]				! OR BINARY IDENT WITH DIFFERENT MATCH CONTROL
	    AND (.IDCREC[IDC$V_IDMATCH] NEQ .ENTRY[IDCD$V_IDMATCH]))
	THEN SIGNAL((LIN$_ENTIDMTCHT AND NOT STS$M_SEVERITY) OR .IDCREC[IDC$V_ERRSEV],
		5,IDCREC[IDC$B_NAMLNG],				! ISSUE WARNING
		OBMODESC[OMD$B_NAMLNG],LNK$GL_CURFIL[FDB$Q_FILENAME],
		DEFOMD[OMD$B_NAMLNG],DEFFDB[FDB$Q_FILENAME]);
    IF NOT CH$EQL(.OBJECTNAME[0],OBJECTNAME[1],			! CHECK THAT OBJECT NAMES THE SAME
		.ENTRY[IDCD$B_OBJLNG],.ENTRY[IDCD$L_OBJNAM]+1)
	THEN SIGNAL((LIN$_ENTIDMTCHO AND NOT STS$M_SEVERITY) OR	.IDCREC[IDC$V_ERRSEV],
		7,OBJECTNAME[0],IDCREC[IDC$B_NAMLNG],
		OBMODESC[OMD$B_NAMLNG],LNK$GL_CURFIL[FDB$Q_FILENAME],
		.ENTRY[IDCD$L_OBJNAM],DEFOMD[OMD$B_NAMLNG],
		DEFFDB[FDB$Q_FILENAME]);
    IF NOT .ENTRY[IDCD$V_BINIDENT]				! NOW CHECK THE IDENT MATCH
    THEN BEGIN
	IF NOT CH$EQL(.IDENTSTRING[0],IDENTSTRING[1],		! CHECK ASCII IDENTS
			.ENTRY[IDCD$B_IDLNG],.ENTRY[IDCD$L_IDENT]+1,0)
	    THEN SIGNAL((LIN$_ENTIDMTCHT AND NOT STS$M_SEVERITY) OR .IDCREC[IDC$V_ERRSEV],
			8,OBJECTNAME[0],IDENTSTRING[0],
			IDCREC[IDC$B_NAMLNG],OBMODESC[OMD$B_NAMLNG],
			LNK$GL_CURFIL[FDB$Q_FILENAME],
			.ENTRY[IDCD$L_IDENT],DEFOMD[OMD$B_NAMLNG],
			DEFFDB[FDB$Q_FILENAME]);
	END
    ELSE BEGIN
!
! CHECK BINARY IDENTS
!
	BIND
	    IDENT1 = IDENTSTRING[1] : BLOCK[,BYTE],
	    IDENT2 = ENTRY[IDCD$L_IDENT] : BLOCK[,BYTE];

	LOCAL
	    IDENT1MAJID,
	    IDENT1MINID,
	    IDENT2MAJID,
	    IDENT2MINID;

	IDENT1MAJID = .IDENT1[GMT$B_MAJORID];			! BLISS GENERATES BETTER CODE THIS WAY
	IDENT1MINID = .IDENT1[GMT$B_MINORID];
	IDENT2MAJID = .IDENT2[GMT$B_MAJORID];
	IDENT2MINID = .IDENT2[GMT$B_MINORID];
	IF .IDENT1MAJID NEQ .IDENT2MAJID			! MAJOR IDS MUST BE EQUAL
	    OR (IF .ENTRY[IDCD$V_IDMATCH] EQL IDC$C_LEQ		! COMPARE MINOR IDS BASED ON MATCH CONTROL
			THEN .IDENT2MINID GTRU .IDENT1MINID
			ELSE .IDENT2MINID NEQ .IDENT1MINID)
	    THEN SIGNAL((LIN$_ENTIDMTCHB AND NOT STS$M_SEVERITY) OR .IDCREC[IDC$V_ERRSEV],
			10,OBJECTNAME[0],.IDENT1MAJID,.IDENT1MINID,
			IDCREC[IDC$B_NAMLNG],OBMODESC[OMD$B_NAMLNG],
			LNK$GL_CURFIL[FDB$Q_FILENAME],
			.IDENT2MAJID,.IDENT2MINID,
			DEFOMD[OMD$B_NAMLNG],DEFFDB[FDB$Q_FILENAME]);
	END;
    END;

RETURN TRUE
END;

ROUTINE COMPARE_ENV (ENVNAME,NODE,ENVREC) =
BEGIN
!
!	COMPARE AN ENVIRONMENT NAME WITH THE CURRENT NODE IN TREE
!
MAP
    ENVNAME : REF VECTOR[,BYTE],
    NODE : REF BLOCK[,BYTE];

BIND
    ENVDESC = .NODE + NODE$C_SHORT : BLOCK[,BYTE];

RETURN CH$COMPARE(.ENVNAME[0],ENVNAME[1],
		.ENVDESC[NVD$B_NAMLNG],ENVDESC[NVD$T_NAME],0)
END;

ROUTINE ALLOC_ENV (ENVNAME,RETNODEADR,ENVREC) =
BEGIN
!
!	ALLOCATE A NEW ENVIRONMENT DESCRIPTOR BLOCK
!
MAP
    ENVNAME : REF VECTOR[,BYTE],
    RETNODEADR : REF VECTOR[,LONG],
    ENVREC : REF BLOCK[,BYTE];

LOCAL
    NEWNODE : REF BLOCK[,BYTE],
    ENVDESC : REF BLOCK[,BYTE];

LNK$ALLOBLK(NODE$C_SHORT+NVD$C_SIZE+.ENVNAME[0],NEWNODE);
ENVDESC = .NEWNODE + NODE$C_SHORT;
CH$FILL(0,NVD$C_SIZE,.ENVDESC);
ENVDESC[NVD$L_OMDNUM] = .LNK$GW_NMODULES;
CH$MOVE(.ENVNAME[0]+1,ENVNAME[0],ENVDESC[NVD$B_NAMLNG]);

RETNODEADR[0] = .NEWNODE;
RETURN TRUE
END;

ROUTINE INSUDFENV (ENVNODE) : NOVALUE =
BEGIN
!
!	THIS ROUTINE ENTERS AN ENVIRONMENT INTO THE UNDEFINED
!	ENVIRONMENT LIST.
!
MAP
	ENVNODE : REF BLOCK[,BYTE];

BUILTIN
	INSQUE;

BIND
    ENVDESC = .ENVNODE + NODE$C_SHORT : BLOCK[,BYTE];

LOCAL
	CH_RESULT,
	NXTENV : REF BLOCK[,BYTE];	! POINTER TO SYMBOL VALUE BLOCK
!
!	FIND THE SPOT TO INSERT THE NEW ENVIRONMENT IN THE UNDEFINED LIST
!
NXTENV = LNK$GL_UDFENV;					! SCAN THE UNDEFINED LIST
WHILE (NXTENV = .NXTENV[NVD$L_UDFLINK]) NEQ LNK$GL_UDFENV
    DO BEGIN
	IF (CH_RESULT = CH$COMPARE(.NXTENV[NVD$B_NAMLNG],	! IF GREATER 
		NXTENV[NVD$T_NAME],.ENVDESC[NVD$B_NAMLNG],
		ENVDESC[NVD$T_NAME])) GTR 0
	THEN EXITLOOP					! THEN WE ARE ALL DONE
	ELSE IF .CH_RESULT EQL 0			! IF EQUAL
			THEN RETURN;			! THEN ALREADY IN LIST, SO RETURN
	END;
INSQUE(ENVDESC[NVD$L_UDFLINK],			! INSERT IN UNDEFINED LIST
	.NXTENV[NVD$L_UDBLINK]);

LNK$GW_NUDFENVS = .LNK$GW_NUDFENVS + 1;		! COUNT THE UNDEFINED ENVIRONMENT
RETURN;
END;

GLOBAL ROUTINE LNK$FNDENVMAP(ENVNUM) =
BEGIN
!
!	THIS ROUTINE RETURNS THE ADDRESS OF THE MAPPING
!	TABLE ENTRY FOR ENVIRONMENT NUMBER "ENVNUM" IN
!	THE CURRENT MODULE.
!	THE ENVIRONMENT MAPPING TABLE IS AN ARRAY POINTED TO BY
!	THE MODULE DESCRIPTOR BLOCK. IT IS INITIALLY
!	ALLOCATED WITH SPACE SUFFICIENT FOR 256
!	ENTRIES.  IF MORE THAN 256 ENVIRONMENTS ARE ENCOUNTERED DURING
!	THE PROCESSING OF THE OBJECT MODULE, THE INITIAL TABLE IS
!	COPIED OUT TO ANOTHER BLOCK, AND THE MAP TABLE ORIGINAL MAP TABLE
!	BECOMES A TABLE OF TABLE ADDRESSES.
!
LITERAL
    TABLESIZE = 256*PMT$C_SIZE;						! SIZE IN BYTES OF A BLOCK

LOCAL
    BLOCKOFF,								! OFFSET OF ENTRY IN EXTENDED BLOCK
    MAPENT : REF BLOCK[,BYTE],						! ADDRESS IN PSECT MAPPING TABLE
    MAPOFF : REF BLOCK[,BYTE];						! ADDRESS OF EXTENDED MAPPING BLOCK

IF .LNK$GL_CUROMD[OMD$L_ENVMAP] EQL 0					! IF NO TABLE ALLOCATED YET
THEN BEGIN
    LNK$ALLOBLK(TABLESIZE,LNK$GL_CUROMD[OMD$L_ENVMAP]);			! ALLOCATE IT NOW
    CH$FILL(0,TABLESIZE,.LNK$GL_CUROMD[OMD$L_ENVMAP]);
    END;
MAPENT = .LNK$GL_CUROMD[OMD$L_ENVMAP] + .ENVNUM*PMT$C_SIZE;		! GET ENTRY ADDRESS IN BASE MAPPING TABLE
IF NOT .LNK$GL_CUROMD[OMD$V_E256]					! IF NOT INTO EXTENDED MAP TABLE
    AND .ENVNUM LEQU 255						!  AND LEQU 255 ENVIRONMENTS
THEN RETURN .MAPENT
!
! EXTENDED ENVIRONMENT ENTRY
!
ELSE BEGIN
    BLOCKOFF = (.ENVNUM MOD 256)*PMT$C_SIZE;				! OFFSET OF ENTRY WITHIN EXTENDED TABLE
    MAPENT = .LNK$GL_CUROMD[OMD$L_ENVMAP] + ((.ENVNUM-1)/256)*PMT$C_SIZE;! GET ADDRESS OF EXTENDED TABLE ADDRESS
    IF ..MAPENT NEQ 0							! IF EXTENDED TABLE PRESENT
	AND .LNK$GL_CUROMD[OMD$V_E256]					!  AND THERE REALLY IS AN EXTENDED TABLE
    THEN RETURN ..MAPENT + .BLOCKOFF					!  THEN RETURN ENTRY ADDRESS
    ELSE BEGIN
        LNK$ALLOBLK(TABLESIZE, MAPOFF);					! ALLOCATE EXTENDED TABLE BLOCK
	IF NOT .LNK$GL_CUROMD[OMD$V_E256]				! IF THIS IS THE FIRST ONE
	THEN BEGIN
	    CH$MOVE(TABLESIZE,.LNK$GL_CUROMD[OMD$L_ENVMAP],.MAPOFF);	! AND COPY BASE TABLE OUT
	    CH$FILL(0,TABLESIZE,.LNK$GL_CUROMD[OMD$L_ENVMAP]);		! ZERO BASE TABLE
	    LNK$GL_CUROMD[OMD$V_E256] = TRUE;				! FLAG INTO EXTENDED TABLE
	    END
	ELSE CH$FILL(0,TABLESIZE,.MAPOFF);				! NOT FIRST EXTENSION...JUST ZERO NEW BLOCK
	!
	! POINT ENTRY IN BASE TABLE TO NEW BLOCK
	!
	MAPENT[PMT$L_SECPMT] = .MAPOFF;
	RETURN .MAPOFF + .BLOCKOFF
	END;
    END;
END;

ROUTINE PROENV =
!
!	THIS ROUTINE PROCESSES ENVIRONMENT DEFINITION/REFERENCE
!	SUBRECORDS.
!
BEGIN
BIND
    ENVREC = OBJVEC[.GSDOFFSET] : BLOCK[,BYTE];

BUILTIN
    REMQUE;

LOCAL
    PTR,
    ENVMAP : REF BLOCK[,BYTE],
    ENVNODE : REF BLOCK[,BYTE],
    ENVDESC : REF BLOCK[,BYTE];

IF .ENVREC[ENV$B_NAMLNG] EQL 0
    OR .ENVREC[ENV$B_NAMLNG] GTRU SYM$C_MAXLNG
THEN (SIGNAL(LIN$_ILLNAMELEN,6,LNK$GT_ENVSTRING,
		ENVREC[ENV$B_NAMLNG],.ENVREC[ENV$B_NAMLNG],
		SYM$C_MAXLNG,OBMODESC[OMD$B_NAMLNG],
		LNK$GL_CURFIL[FDB$Q_FILENAME]);
	RETURN FALSE);
!
! INSERT ENVIRONMENT RECORD INTO ENVIRONMENT TREE
!
LIB$INSERT_TREE(LNK$GL_ENVTREE,ENVREC[ENV$B_NAMLNG],
		%REF(0),COMPARE_ENV,ALLOC_ENV,ENVNODE,ENVREC);

ENVDESC = .ENVNODE + NODE$C_SHORT;
!
! PUT ENVIRONMENT INTO THE ENVIRONMENT MAP TABLE
!
OBMODESC[OMD$V_NOENV] = FALSE;
OBMODESC[OMD$W_HIENV] = .OBMODESC[OMD$W_HIENV] + 1;
ENVMAP = LNK$FNDENVMAP(.OBMODESC[OMD$W_HIENV]);
ENVMAP[PMT$L_PSCDES] = .ENVNODE;
!IF .ENVMAP[PMT$L_SYMLST] NEQ 0			! SYMBOLS DEFINED BEFORE THE ENVIRONMENT?
!THEN BEGIN				!**ONLY NEED TO ASSOCIATE SYMBOLS WITH ENVIRONMENT FOR CROSS REF
!    TRUE
!    END;
!
! IF THIS IS A DEFINITION, REMOVE FROM UNDEFINED LIST IF IT'S
! ON IT.  IF IT'S THE FIRST REFERENCE TO THIS ENVIRONMENT,
! THEN PUT IT ON THE UNDEFINED LIST.
!
IF .ENVREC[ENV$V_DEF]
THEN BEGIN
    IF .ENVDESC[NVD$L_UDFLINK] NEQ 0
	THEN (REMQUE(ENVDESC[NVD$L_UDFLINK],PTR);
		LNK$GW_NUDFENVS = .LNK$GW_NUDFENVS - 1);
    ENVDESC[NVD$V_DEF] = TRUE;
    END
ELSE IF NOT .ENVDESC[NVD$V_DEF]
    AND .ENVDESC[NVD$L_UDFLINK] EQL 0
    THEN INSUDFENV(.ENVNODE);

GSDOFFSET = .GSDOFFSET + ENVREC[ENV$T_NAME] - ENVREC[ENV$B_GSDTYP]
			+ .ENVREC[ENV$B_NAMLNG];

RETURN TRUE
END;

ROUTINE LOCALSYMBOLS =
BEGIN
!
LOCAL
	LENGTH;
!
BIND
	SYMBOLREC = OBJVEC [.GSDOFFSET] : BLOCK [,BYTE];
!
ENTRYMASK = 0;			! ZERO THE ENTRY MASK SINCE NONE EXISTS
!
IF NOT .SYMBOLREC[LSY$V_DEF]			! IF NOT DEFINED
THEN BEGIN
	LENGTH = SYMBOLREC [LSRF$T_NAME] - SYMBOLREC [LSRF$T_START] +
			.SYMBOLREC[LSRF$B_NAMLNG];
	SYMBOLSTRING = SYMBOLREC[LSRF$B_NAMLNG];	! POINT TO THE SYMBOL STRING
     END
ELSE BEGIN
    LENGTH = SYMBOLREC [LSDF$T_NAME] - SYMBOLREC [LSDF$T_START] +
					.SYMBOLREC[LSDF$B_NAMLNG];
    SYMBOLSTRING = SYMBOLREC[LSDF$B_NAMLNG];	! POINT TO THE SYMBOL
     END;

IF NOT PROSYMBOL(0)					! GO PROCESS THIS SYMBOL
    THEN RETURN FALSE;				! AND EXIT IF FAILURE

GSDOFFSET = .GSDOFFSET + .LENGTH;	! UPDATE THE GSD OFFSET FOR NEXT

RETURN TRUE
END;

ROUTINE LOCALENTPNT =
BEGIN
!
LOCAL
	LENGTH;
!
BIND
	SYMBOLREC = OBJVEC [.GSDOFFSET] : BLOCK [,BYTE];

ENTRYMASK = .SYMBOLREC[LEPM$W_MASK];				! EXTRACT THE ENTRY POINT MASK
LENGTH = SYMBOLREC [LEPM$T_NAME] - SYMBOLREC [LEPM$T_START] +
			.SYMBOLREC[LEPM$B_NAMLNG];
SYMBOLSTRING = SYMBOLREC[LEPM$B_NAMLNG];			! POINT TO THE SYMBOL

IF NOT PROSYMBOL(1)						! GO PROCESS THE SYMBOL
    THEN RETURN FALSE;						! AND EXIT IF FAILURE

GSDOFFSET = .GSDOFFSET + .LENGTH;				! ELSE UPDATE THE OFFSET FOR NEXT

RETURN TRUE
END;

ROUTINE LOCALPROCEDEF =
BEGIN
!
!	PROCESS PROCEDURE DEFINTION OF MODULE LOCAL SYMBOL
!	SEE PROCEDEF FOR AN EXPLANATION OF WHAT A PROCEDURE
!	DEFINITION LOOKS LIKE.
!
LOCAL
	ENTFLAG,
	ARGVALDATA : REF VECTOR[,BYTE],
	ARGCOUNT;
!
IF NOT LOCALENTPNT() THEN RETURN FALSE;				! PROCESS THE ENTRY POINT SYMBOL PART
ENTFLAG = .SYMTABENT NEQ 0;					! SEE IF ENTERED
BEGIN
	BIND FORMALS = OBJVEC [.GSDOFFSET] : BLOCK[,BYTE];	! THE FORMAL DESCRIPTION
	IF .FORMALS[FML$B_MINARGS] GTRU .FORMALS[FML$B_MAXARGS]		! IF THERE IS AN INCONSISTENT
	THEN BEGIN							! DESCRIPTION OF FORMALS
		SIGNAL(LIN$_ILLFMLCNT,5,				! OUTPUT ERROR MESSAGE
			.FORMALS[FML$B_MINARGS],.FORMALS[FML$B_MAXARGS],
			SYMENTNAM[SNB$B_NAMLNG],OBMODESC[OMD$B_NAMLNG],
			LNK$GL_CURFIL[FDB$Q_FILENAME]);
		RETURN FALSE;
		END;
	GSDOFFSET = .GSDOFFSET + FML$C_SIZE;			! UPDATE RECORD POINTER
	IF .ENTFLAG						! DELETE OLD VALIDATAION DATA
	    AND (ARGVALDATA = .SYMTABENT[SYM$L_VALDATA]) NEQ 0
	THEN BEGIN						! MUST BE A NEW DEFINITION
		LNK$DEALBLK(.ARGVALDATA[0],ARGVALDATA[0]);	! SO DISPOSE OF OLD DATA
		SYMTABENT[SYM$L_VALDATA] = 0;			! AND FORGET IT
	     END;
	IF (ARGCOUNT = .FORMALS[FML$B_MAXARGS] ) EQL 0		! IF MAXIMUM NUMBER ARGUMENTS
	THEN RETURN TRUE;					! IS ZERO, ALL DONE
	IF .ENTFLAG
	THEN BEGIN
	    LNK$ALLOBLK(.ARGCOUNT+2,SYMTABENT[SYM$L_VALDATA]);	! ALLOCATE A VALIDATION DATA BLOCK
	    ARGVALDATA[0] = .ARGCOUNT + 2;			! SET ITS SIZE
	    ARGVALDATA[1] = .FORMALS[FML$B_MINARGS];		! SAVE MINIMUM ARGUMENT SPECIFICATION
	    END;
	INCR I FROM 1 TO .ARGCOUNT				! BEGIN A LOOP THROUGH
	DO BEGIN						! ALL FORMAL ARGUMENT DESCRIPTORS
		BIND ARGDESC = OBJVEC[.GSDOFFSET] : BLOCK[,BYTE]; ! POINT TO NEXT DESCRIPTOR
		IF .ENTFLAG
		    THEN ARGVALDATA[.I+1] = .ARGDESC[ARG$V_PASSMECH];	  ! EXTRACT THE PASSING MECHANISM
		GSDOFFSET = .GSDOFFSET + .ARGDESC[ARG$B_BYTECNT]+ ! AND UPDATE RECORD POINTER
				ARG$C_SIZE;
	   END;
	RETURN TRUE;
     END;
END;

ROUTINE PROGSD =
BEGIN
!
!++
!	VERIFY GSD RECORDS AND DISPATCH ON THE FOUR SUB-TYPES:
!		(0) P-SECTION DEFINITION
!		(1) SYMBOL DEFINITION/REFERENCE
!		(2) ENTRY POINT DEFINITION
!		(3) PROCEDURE DECLARATION
!--
!
BIND
	GSDDISPATCH = PLIT (
			PROPSECTDEF,
			SYMBOLS,
			ENTPNTS,
			PROCEDEF,
			SYMBOLS,
			ENTPNTS,
			PROCEDEF,
			RANDENTITY,
			PROENV,
			LOCALSYMBOLS,
			LOCALENTPNT,
			LOCALPROCEDEF,
			PROPSECTDEF) : VECTOR;
!
LOCAL
	GSDTYPE;
!
IF NOT SEQCHK()
THEN RETURN FALSE;
GSDOFFSET = OBJ$C_SUBTYP;
!
WHILE .GSDOFFSET LSSU .RECLNG DO
BEGIN
IF (GSDTYPE = .OBJVEC[.GSDOFFSET]) GEQU .GSDDISPATCH[-1]
THEN BEGIN
	SIGNAL(LIN$_GSDTYP,3,.GSDTYPE,
		OBMODESC[OMD$B_NAMLNG],LNK$GL_CURFIL[FDB$Q_FILENAME]);
	RETURN FALSE;
	END
ELSE BEGIN
	WORDPSECTGSD = ((.GSDTYPE GEQU GSD$C_SYMW)				! TEST FOR WORD OF PSECT NUMBER
				AND (.GSDTYPE LEQU GSD$C_PROW));
	LCLSYMGSD = ((.GSDTYPE GEQU GSD$C_LSY)					! TEST FOR LOCAL SYMBOL
				AND (.GSDTYPE LEQU GSD$C_LPRO));
	IF NOT ( .GSDDISPATCH[.GSDTYPE])()
	THEN RETURN FALSE;
	END;

END;							! OF LOOP ON A CONCATENATED GSD RECORD

RETURN TRUE						! ALL DONE

END;							! OF PROGSD

GLOBAL ROUTINE LNK$PROCSOBJ (MODRFA) =
BEGIN
!
! READ AND PROCESS ALL REQUIRED OBJECT MODULE RECORDS OF THE FILE JUST OPENED
! THAT IS, KEEP READING RECORDS TO END OF FILE EXCEPT IF THIS
! FILE IS A LIBRARY, STOP AT THE FIRST END OF MODULE RECORD.
!	MODRFA EXISTS IN THE CASE OF A LIBRARY MODULE OR SHAREABLE IMAGE AND
!	IS A POINTER TO THE RECORD FILE ADDRESS OF THE MODULE.
!
MAP MODRFA : REF BLOCK[,BYTE];				! REALLY A POINTER
!
BIND AUXFNB = LNK$GL_CURFIL[FDB$T_AUXFNB] : BLOCK[,BYTE];	! AUXILIRIARY FILENAME BLOCK
!
WHILE LNK$NXTREC(OBJRECDESC)				! IF THERE IS ANOTHER RECORD
DO BEGIN
    IF .RECLNG GTRU .MAXRECLNG				! AND ITS LENGTH IS ILLEGAL
	THEN
	    (IF .MHDSEEN
		THEN SIGNAL(LIN$_ILLRECLEN,3,		! TELL MODULE NAME IF IT IS KNOWN
				.RECLNG,OBMODESC[OMD$B_NAMLNG],
				LNK$GL_CURFIL[FDB$Q_FILENAME])
	        ELSE SIGNAL(LIN$_RECLNG,2,		! OUTPUT AN ERROR AND QUIT ON SEVERE ERROR
				LNK$GL_CURFIL[FDB$Q_FILENAME],.RECLNG);
		)
	ELSE
		BEGIN					! LENGTH OF RECORD OR SO
		IF (LASTRECTYP = .CURRECTYP;		! COPY OLD CURRENT TO LAST TYPE
		    CURRECTYP = .OBJREC[OBJ$B_RECTYP]) 	! AND GET NEW TYPE
		LSSU .RECDISPATCH[-1]			! CHECK IT IS LEGAL AND IF
		THEN
		    (.RECDISPATCH[.CURRECTYP])() 	! SO DISPATCH TO RECORD SPECIFIC ROUTINE
		ELSE
		    (IF .MHDSEEN
			THEN SIGNAL(LIN$_ILLRECTYP,4, 	! TELL MODULE NAME IF KNOWN
						.CURRECTYP,
						OBMODESC[OMD$B_NAMLNG],
						.LNK$GL_RECORD,LNK$GL_CURFIL[FDB$Q_FILENAME])
		        ELSE SIGNAL(LIN$_RECTYP,3, 	! ELSE OUTPUT ERROR
			LNK$GL_CURFIL[FDB$Q_FILENAME],.LNK$GL_RECORD,.CURRECTYP)
			);
		END;

IF ((.CURRECTYP EQL OBJ$C_EOM)				! IF THAT RECORD WAS AN EOM
    OR (.CURRECTYP EQL OBJ$C_EOMW))
AND (.LNK$GL_CURFIL[FDB$V_LIBR]				! AND THE FILE IS A LIBRARY
     OR .LASTOBJMOD[OMD$V_SHRIMG])			! OR CONTAINS A SHAREABLE IMAGE
THEN BEGIN							! THEN THE FILE IS DONE
	LASTOBJMOD[OMD$L_MODVBN] = .MODRFA[RFA$L_VBN];		! AS SOON AS WE EXTRACT THE RFA
	LASTOBJMOD[OMD$W_BYTOFF] = .MODRFA[RFA$W_OFFSET];	! OF THE MODULE
	RETURN TRUE;
     END;
END;							! OF RECORDS LOOP
!
IF ((.CURRECTYP NEQ OBJ$C_EOM)				! ALL RECORDS ARE READ AND PROCESSED -
    AND (.CURRECTYP NEQ OBJ$C_EOMW))
THEN BEGIN
    LOCAL
	EOMREC : BLOCK[EOM$C_EOMMIN,BYTE];

    SIGNAL(LIN$_NOEOM,2,OBMODESC[OMD$B_NAMLNG],		! IF DID NOT END WITH EOM, THEN WARNING
		LNK$GL_CURFIL[FDB$Q_FILENAME]);
    EOMREC[EOM$B_RECTYP] = OBJ$C_EOM;			! CREATE FAKE EOM RECORD
    EOMREC[EOM$B_COMCOD] = EOM$C_ERROR;
    RECLNG = 2;						! SET LENGTH OF RECORD
    OBJREC = EOMREC;					! AND IT'S ADDRESS
    CURRECTYP = OBJ$C_EOM;				! SET RECORD TYPE
    PROEOM(1);						! FINISH EOM PROCESSING
    MHDSEEN = FALSE;					! RESET MHD FLAGS
    LNMSEEN = FALSE;
    END;

RETURN TRUE;						! FINALLY RETURN AFTER NO MORE
END;							! OF PASS 1 OBJ READING ROUTINE

GLOBAL ROUTINE LNK$OBJPASS1(ARGLIST) =
BEGIN
!
!	THIS IS THE MAIN DRIVING ROUTINE OF PASS ONE. IT OPENS
!	EACH FILE AND IF A LIBRARY, CALLS THE LIBRARY PROCESSING ROUTINE
!	OR IF NOT A LIBRARY ASSUMES IT IS A CONCATENATED OBJ FILE
!	AND CALLS THE OBJ MODULE PROCESSOR.
!	WHEN NO MORE FILES REMAIN, IF THERE ARE STILL UNDEFINED SYMBOLS
!	THE SYSTEM LIBRARY IS MATERAILIZED AS AN INPUT FILE AND
!	PROCESSED.
!
!	ARGLIST CONTAINS THE ADDRESS OF THE ARGUMENT LIST WITH WHICH THE LINKER
!	WAS ORIGINALLY CALLED. IT IS MERELY PASSED ON TO THE OBJECT
!	LIBRARY PROCESSOR SO IT CAN RE-CALL CLI TO OBTAIN THE NAMES (IF ANY)
!	OF MODULES TO BE EXPLICITLY EXTRACTED FROM THE LIBRARY.
!
BUILTIN
	INSQUE,					! QUE INSERTION AND
	REMQUE;					! QUE REMOVING INSTRUCTIONS
LOCAL
	SUFFIX,					! UNDEFINED SYMBOL LIST SUFFIX POINTER
	NXTSYMNAM : REF BLOCK[,BYTE],		! NEXT SYMBOL NAME BLOCK POINTER
	NXTSYMENT : REF BLOCK[,BYTE];		! FOR SCANNING LIST OF UNDEFINED SYMBOLS
!
! IF NOT MAKING A SHAREABLE IMAGE, THEN DISABLE UNIVERSAL='ALL'
!
IF NOT .LNK$GL_CTLMSK[LNK$V_SHR]
    THEN LNK$GL_CTLMSK[LNK$V_ALLUNIV] = FALSE;
!
! INSERT THE SYMBOL "SYS$K_VERSION" INTO THE SYMBOL TABLE AS AN UNDEFINED
! WEAK ABSOLUTE REFERENCE WITH THE SPECIAL INTERNALLY CREATED SYMBOL
! FLAG.
!
LNK$SEARCH(LNK$GT_SYSVER,SYMTABENT,SYMENTNAM);	! FIND WHERE IT GOES
LNK$INSERT(LNK$GT_SYSVER,SYMTABENT,SYMENTNAM);	! AND INSERT IT
SYMTABENT[SYM$V_WEAK] = TRUE;			! FLAG WEAK
SYMTABENT[SYM$V_INTSYM] = TRUE;			! AND INTERNALLY CREATED
LNK$INSUDFSYM(.SYMTABENT);			! INSERT IN UDEFINED SYMBOL LIST
OBMODESC[OMD$L_LSTERR] = OBMODESC[OMD$L_ERRTXT];
LNK$GL_CUROMD = OBMODESC;			! POINT TO THE DESCRIPTOR
!
! BEGIN THE LOOP WHICH OPENS EACH INPUT FILE
!
WHILE LNK$NXTFIL() DO						! WHILE THERE REMAIN
BEGIN								! MORE OBJ FILES
	LNK$GW_NFILES = .LNK$GW_NFILES + 1;			! COUNT THE FILE
	LASTOBJMOD = LNK$GL_CURFIL[FDB$L_OMDLST];		! INITIALIZE LAST DESCRIPTOR TO LISTHEAD
	IF .LNK$GL_CURFIL[FDB$V_LIBR]				! IF THIS INPUT FILE IS A LIBRARY
	THEN (IF NOT LNK$PROCSLIB(.ARGLIST)			! GO PROCESS IT
		THEN RETURN FALSE;)				! AND GIVE UP ON FAILURE
	ELSE IF .LNK$GL_CURFIL[FDB$V_SHR]			! IF A SHAREABLE IMAGE
		THEN (IF NOT LNK$PROCSHRIM()			! GO PROCESS IT
			THEN RETURN FALSE;)			! AND GIVE UP ON ERRORS
		ELSE IF NOT LNK$PROCSOBJ()			! OTHERWISE ASSUME CONCATENATED OBJECT
			THEN RETURN FALSE;			! EXITING NOW ON FAILURE
	LASTOBJMOD[OMD$L_NXTOMD] = 0;				! END OF USER INPUT FILES
END;								! END OF USER INPUT FILES
!
! NOW CHECK THAT WE DID GET SOME MODULES AND IF SO
! CHECK FOR UNDEFINED SYMBOLS.
!
LNK$GL_CUROMD = 0;						! NO OBJECT MODULE NOW
IF .LNK$GW_NMODULES EQL 0
THEN SIGNAL_STOP(LIN$_NOMODS);
IF .LNK$GW_NUDFSYMS NEQ 0					! IF THERE ARE STILL SOME UNDEFINED (STRONG REFS)
THEN SIGNAL(LIN$_NUDFSYMS,1,.LNK$GW_NUDFSYMS);			! THEN REPORT THE NUMBER
WHILE NOT REMQUE(.LNK$GL_UDFLST,NXTSYMENT)			! AND REMOVE EACH FROM TOP
DO BEGIN							! OF THE LIST, OUTPUTTING
	BIND NXTSYMNAM =
		.NXTSYMENT - .NXTSYMENT[SYM$B_NAMLNG]
			- SNB$C_FXDLEN : BLOCK[,BYTE]; ! POINT TO SYMBOL NAME BLOCK
	IF NOT .NXTSYMENT[SYM$V_INTSYM]
	THEN BEGIN
	IF NOT .NXTSYMENT[SYM$V_WEAK]				! THE SYMBOL NAME
	THEN SUFFIX = CSTRING(' ')				! WITH NULL OR 'WEAK'
	ELSE BEGIN
		SUFFIX = CSTRING(' (Weak Reference)');		! SUFFIX DEPENDING ON THE REFERENCE
		NXTSYMENT[SYM$V_DEF] = TRUE;			! BEING WEAK OR STRONG AND
								! ENSURE WEAKS ARE NOW DEFINED
	     END;
	IF .LNK$GW_NUDFSYMS NEQ 0				! NOW LIST THE SYMBOL PROVIDED
	THEN SIGNAL(LIN$_UDFSYM,2,				! NOT ALL WERE WEAK
		NXTSYMNAM[SNB$B_NAMLNG],.SUFFIX);
	NXTSYMENT[SYM$L_VALUE] = 0;				! SET ITS VALUE TO 0
	NXTSYMENT[SYM$V_REL] = FALSE;				!  AND MAKE IT ABSOLUTE
	IF NOT .LNK$GL_CTLMSK[LNK$V_BRIEF]			! PROVIDED THIS IS NOT A
	AND .LNK$GL_CTLMSK[LNK$V_MAP]				! BRIEF MAP
	THEN CRF$INSRTKEY(LNK$AL_SYTBLFMT,			! INSERT THE KEY (SYMBOL) IN
			NXTSYMNAM[SNB$B_NAMLNG],		! CREF'S TABLE SO THAT WE MAY
			NXTSYMENT[SYM$L_VALUE],			! MAP UNDEFINED SYMBOLS
			.NXTSYMENT[SYM$W_FLAGS]);		! AND IGNORE ERROR FROM CREF
	END				! NOT INTERNALLY CREATED SYMBOL
	ELSE BEGIN
	    NXTSYMENT[SYM$L_VALUE] = 0; 			! INTERNALLY CREATED--ZERO VALUE
	    NXTSYMENT[SYM$V_REL] = FALSE;			!  AND MAKE IT ABSOLUTE
	    END;
   END;
!
! LIST ANY UNDEFINED ENVIRONMENTS
!
IF .LNK$GW_NUDFENVS NEQ 0
THEN BEGIN
    LOCAL
	ENVDESC : REF BLOCK[,BYTE];

    SIGNAL(LIN$_NUDFENVS,1,.LNK$GW_NUDFENVS);
    ENVDESC = .LNK$GL_UDFENV[0];
    WHILE .ENVDESC NEQ LNK$GL_UDFENV
    DO BEGIN
	SIGNAL(LIN$_UDFENV,1,ENVDESC[NVD$B_NAMLNG]);
	ENVDESC = .ENVDESC[NVD$L_UDFLINK];
	END;
    END;
!
! LIST ANY UNDEFINED MODULE-LOCAL SYMBOLS
!
IF .LNK$GW_NUDFLSYMS NEQ 0
THEN BEGIN
    SIGNAL(LIN$_NUDFLSYMS,1,.LNK$GW_NUDFLSYMS);			! TELL THAT THERE ARE UNDEF. LOCAL SYMBOLS
    WHILE NOT REMQUE(.LNK$GL_UDFLSY,NXTSYMENT)			! FOR EACH ONE OF THEM
    DO BEGIN
	BIND
	    NXTSYMNAM = .NXTSYMENT - .NXTSYMENT[SYM$B_NAMLNG]
				- SNB$C_FXDLEN : BLOCK[,BYTE];

	IF NOT .NXTSYMENT[SYM$V_WEAK]				! SET SUFFIX TO SYMBOL MESSAGE
	    THEN SUFFIX = CSTRING(' ')
	ELSE BEGIN
	    SUFFIX = CSTRING(' (Weak Reference)');		! IF IT'S WEAK, THEN SAY SO
	    NXTSYMENT[SYM$V_DEF] = TRUE;
	    END;
	SIGNAL(LIN$_UDFSYM,2,NXTSYMNAM[SNB$B_NAMLNG],.SUFFIX);	! TELL USER OF UNDEFINED LOCAL SYMBOL
	NXTSYMENT[SYM$L_VALUE] = 0;				! DEFINE IT AS ABSOLUTE 0
	NXTSYMENT[SYM$V_REL] = FALSE;
	END;
    END;

IF .LNK$GL_DBGTFPS EQL 0					! IF NO DEBUGGER TRANSFER ADDRESS SEEN
    THEN  IF LNK$SEARCH(LNK$GT_IMGSTA,SYMTABENT,SYMENTNAM)	! THEN LOOK UP SYS$IMGSTA
	THEN IF .SYMTABENT[SYM$V_DEF]				! AND IF DEFINED
	    THEN BEGIN
		LNK$GL_DBGTFR = .SYMTABENT[SYM$L_VALUE];		! SET ITS ADDRESS
		LNK$GL_DBGTFPS = 1;					! FLAG THERE IS A DEBUG XFR ADDRESS
		END;
!
! DEFINE ANY PSECTS SPECIFIED IN A PSECT= OPTION THAT WERE NOT
! SPECIFIED IN A COLLECT PSECT OPTION
!
LNK$GL_CURCLU = LNK$GL_DEFCLU;					! SET TO DEFAULT CLUSTER
LIB$TRAVERSE_TREE(LNK$GL_PSCDFLST,CHECKPDDENTRY);		! TRAVERSE THE TREE
LNK$LIBBUFDEAL();						! SO DEALLOCATE CLI WORK AREA AND LIBRARY BUFFERS (IF ANY)
RETURN TRUE;
END;
END
ELUDOM
