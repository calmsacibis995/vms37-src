MODULE LNK_STATSOUT (	! LINKER STATISTICS ROUTINE
		IDENT = 'V03-000',
		ADDRESSING_MODE(EXTERNAL=GENERAL,
				NONEXTERNAL=LONG_RELATIVE)
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	LINKER
!
! ABSTRACT:	ROUTINE DOES ALL THE WORK OF GATHERING AND OUTPUTTING STATISTICS OF THE LINK
!
!
! ENVIRONMENT:	STARLET NATIVE MODE
!
! AUTHOR:	T.J. PORTER, CREATION DATE: 27-JUN-77
!
! MODIFIED BY:
!
!	V03-003	BLS0038		Benn Schreiber		31-Jan-1981
!		Print options file text
!
!	V03-002	BLS0038		Benn Schreiber		30-Jan-1981
!		Clean up map output
!
!	V03-001	BLS0007		Benn Schreiber,		3-Jun-1980
!		Convert to MDL data structures.
!--

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
	LNK$STATSOUT : NOVALUE;			! OUTPUT THE STATISTICS

!
! INCLUDE FILES:
!
LIBRARY
	'LIBL32';				! GET PROCESS HEADER DEFINITIONS
REQUIRE
	'PREFIX';				! USEFUL MACROS AND VARIABLES
LIBRARY
	'DATBAS';				! LINKER DATA STRUCTURES
!
! MACROS:
!
MACRO
	TEXTADR = 0,0,32,0%,
	FLTSADR = 1,0,32,0%,
	CPUTADR = 2,0,32,0%,
	STIMADR = 3,0,32,0%;
!
! EQUATED SYMBOLS:
!
LITERAL
	BUFFERLENG = 132;			! OUTPUT LINE BUFFER
!
! EXTERNAL REFERENCES:
!
EXTERNAL
	LNK$GL_OPTEXTP : REF BLOCK[,BYTE],	! POINTER TO OPTIONS TEXT
	LNK$GL_CTLMSK : BLOCK[,BYTE],		! LINK CONTROL FLAGS
	LNK$GL_MINADDR,				! LOWEST ADDRESS ALLOCATED
	LNK$GL_MEMLHD,				! FREE MEMORY LISTHEAD
	LNK$GL_CPUSTIM,				! CPU TIME AT START
	LNK$GL_FUTLSRCH,			! NUMBER OF SYMBOLS SEARCHED FOR IN THE WRONG LIBRARY
	LNK$GL_LIBRECS,				! NUMBER OF OBJ RECORDS READ FROM LIBRARIES
	LNK$AL_CMDDESC : BLOCK[,BYTE],					! REQUEST DESCRIPTOR TO GET COMMAND LINE
	LNK$GL_NMODSEXP,			! NUMBER MODULES EXTRACTED EXPLICITLY
	LNK$GL_NMODSRCH,			! NUMBER OF MODULES EXTRACTED TO RESOLVE SYMBOLS
	LNK$GL_OBJRECS,				! TWO PASS COUNT OF OBJECT RECORDS READ
	LNK$GW_DBGRECS : WORD,			! NUMBER OF DEBUG DATA RECORDS
	LNK$GL_DBGESTIM,			! NUMBER OF BYTES IN DEBUG RECORDS
	LNK$GW_DSTVBN : WORD,			! VBN OF DEBUG SYMBOL TABLE
	LNK$GW_DSTBLKS : WORD,			! NUMBER OF BLOCKS ALLOCATED
	LNK$GL_DSTEND,				! END ADDRESS IN THE DST
	LNK$GW_SYMRECS : WORD,			! NUMBER OF GLOBAL SYMBOL TABLE RECORDS WRITTEN TO SEPARATE FILE
	LNK$GW_GSTRECS : WORD,			! NUMBER WRITTEN TO IMAGE FILE
	LNK$GQ_STARTIM,				! START TIME QUADWORD
	LNK$GQ_ENDTIM,				! END TIME QUADWORD
	LNK$GQ_PS1STIM,				! PASS 1 START TIME
	LNK$GQ_ALOSTIM,				! ALLOCATION/RELOCATION START TIME
	LNK$GQ_PS2STIM,				! PASS 2 START TIME
	LNK$GQ_MAPSTIM,				! BULK OF MAP START TIME
	LNK$GQ_STBSTIM,				! SYMBOL TABLE OUTPUT START TIME
	LNK$GL_PS1CPUT,				! CPU TIME AT START OF PASS 1
	LNK$GL_ALOCPUT,				! CPU TIME AT START OF ALLOCATION PHASE
	LNK$GL_PS2CPUT,				! CPU TIME AT START OF PASS 2
	LNK$GL_MAPCPUT,				! CPU TIME AT START OF MAP OUTPUT
	LNK$GL_STBCPUT,				! CPU TIME AT START OF SYMBOL TABLE OUTPUT
	LNK$GL_PS1FLTS,				! PAGE FAULT COUNT AT START OF PASS 1
	LNK$GL_ALOFLTS,				! PAGE FAULT COUNT AT START OF ALLOCATION PHASE
	LNK$GL_PS2FLTS,				! PAGE FAULT COUNT AT START OF PASS 2
	LNK$GL_MAPFLTS,				! PAGE FAULT COUNT AT START OF MAP OUTPUT
	LNK$GL_STBFLTS,				! PAGE FAULT COUNT AT START OF SYMBOL TABLE OUTPUT
	LNK$GL_SPAGFLTS,			! PAGE FAULT COUNT AT START OF THE LINK
	LNK$GL_ENDFLTS,				! PAGE FAULT COUNT AT END
	LNK$GL_ENDCPUT;				! CPU TIME AT END
EXTERNAL ROUTINE
	LNK$CALCELAPS,				! ROUTINE TO DO THE QUADWORD ARITHMETIC
						! RETURNING ADDRESS OF THE NEGATIVE ("DELTA") ELAPSED TIME
	LNK$MAPOUT;				! OUPUTS LINE TO MAP
EXTERNAL LITERAL
	LEN$C_MAPLINE : WORDLIT,		! LENGTH OF MAP LINE
	LNK$K_LIBBLOCKS : SHORT;		! NUMBER OF BLOCKS IN WINDOW OF A LIBRARY
LITERAL PHASES = 9;				! NUMBER OF PHASES FOR WHICH THERE ARE STATISTICS
!
! MODULE OWN STORAGE:
!
	PSECT OWN = $PLIT$ (NOPIC,CONCATENATE,LOCAL,NOSHARE,NOEXECUTE,NOWRITE);
OWN
	PHASTAHD1 : DESCRIPTOR('!50<Performance Indicators!>Page Faults	CPU Time	Elapsed Time'),
	PHASTAHD2 : DESCRIPTOR('!50<!22*-!>!11*-	!8*-	!12*-'),
	PHASTAFMT : DESCRIPTOR('!50<!AS!>!11UL	!2ZL:!2ZL:!2ZL.!2ZL	!%T'),
	TOTALTIM : DESCRIPTOR('Total run values:'),
	COMANDTIM : DESCRIPTOR('    Command processing:'),
	PASS1TIM : DESCRIPTOR('    Pass 1:'),
	ALLOCTIM : DESCRIPTOR('    Allocation/Relocation:'),
	PASS2TIM : DESCRIPTOR('    Pass 2:'),
	MAPTIM : DESCRIPTOR('    Map data after object module synopsis:'),
	STBTIM : DESCRIPTOR('    Symbol table output:'),
	WORKSET : DESCRIPTOR('Using a working set limited to !UL pages and !UL pages of data storage (excluding image)'),
	OBJRECS : DESCRIPTOR('!50<Total number object records read (both passes):!>!UL'),
	LIBRECS : DESCRIPTOR('    of which !UL were in libraries and !UL were DEBUG data records containing !UL bytes'),
	DBGDATA : DESCRIPTOR('!UL bytes of DEBUG data were written,starting at VBN !UW with !UW blocks allocated'),
	EXTRMODS : DESCRIPTOR('!50<Number of modules extracted explicitly!> = !UL'),
	SRCHMODS : DESCRIPTOR('    with !UL extracted to resolve undefined symbols'),
	FUTLSRCH : DESCRIPTOR('!UL library searches were for symbols not in the library searched'),
	SYMRECS : DESCRIPTOR('A total of !UL global symbol table records was written'),
	PHASTATBL : BLOCKVECTOR[PHASES,4] INITIAL(
			0	,LNK$GL_SPAGFLTS,LNK$GL_CPUSTIM,LNK$GQ_STARTIM,
			COMANDTIM,LNK$GL_PS1FLTS,LNK$GL_PS1CPUT,LNK$GQ_PS1STIM,
			PASS1TIM,LNK$GL_ALOFLTS,LNK$GL_ALOCPUT,LNK$GQ_ALOSTIM,
			ALLOCTIM,LNK$GL_PS2FLTS,LNK$GL_PS2CPUT,LNK$GQ_PS2STIM,
			PASS2TIM,LNK$GL_MAPFLTS,LNK$GL_MAPCPUT,LNK$GQ_MAPSTIM,
			MAPTIM,LNK$GL_STBFLTS,LNK$GL_STBCPUT,LNK$GQ_STBSTIM,
			STBTIM,LNK$GL_ENDFLTS,LNK$GL_ENDCPUT,LNK$GQ_ENDTIM,
			0	,LNK$GL_SPAGFLTS,LNK$GL_CPUSTIM,LNK$GQ_STARTIM,
			TOTALTIM,LNK$GL_ENDFLTS,LNK$GL_ENDCPUT,LNK$GQ_ENDTIM),
	CVT2SECS :  INITIAL(100),
	CVTSECSMINS :  INITIAL(60);

GLOBAL ROUTINE LNK$STATSOUT : NOVALUE =		! OUTPUT STATISTICS
BEGIN
!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS MODULE COMPUTES AND OUTPUTS TO THE MAP A GAGGLE OF THE STATISTICS
!	ACCUMULATED BY THE LINKER AND THE SYSTEM DURING THE RUN
!
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
!
BUILTIN	EDIV;
!
LOCAL
	BUFFER : CH$SEQUENCE(BUFFERLENG),		! OUTPUT LINE BUFFER
	OUTBUFDESC : VECTOR[2],				! ITS DESCRIPTOR
	PAGEFAULTS,
	CPUTIME : VECTOR[2],
	SECFRAC,
	CPUSECS : VECTOR[2],
	CPUMINS : VECTOR[2],
	CPUHOURS,
	WORKSETLIM,
	MEMUSED : REF VECTOR,
	DBGBYTES,
	OUTLINELENG : WORD;				! LENGTH OF FORMATTED LINE RETURNED BY FAO
!
OUTBUFDESC[0] = BUFFERLENG;				! INITIALIZE FAO'S BUFFER
OUTBUFDESC[1] = BUFFER;					! DESCRIPTOR
!
CPUTIME[1] = 0;
CPUSECS[1] = 0;
CPUMINS[1] = 0;
LNK$MAPOUT(BUFFER,0);
$FAO(PHASTAHD1,OUTLINELENG,OUTBUFDESC);
LNK$MAPOUT(BUFFER,.OUTLINELENG);
$FAO(PHASTAHD2,OUTLINELENG,OUTBUFDESC);
LNK$MAPOUT(BUFFER,.OUTLINELENG);
INCR I FROM 1 TO PHASES-1 DO
IF .PHASTATBL[.I,TEXTADR] NEQ 0
THEN BEGIN
	PAGEFAULTS = ..PHASTATBL[.I,FLTSADR] - ..PHASTATBL[.I-1,FLTSADR];
	CPUTIME[0] = ..PHASTATBL[.I,CPUTADR] - ..PHASTATBL[.I-1,CPUTADR];
	EDIV(CVT2SECS,CPUTIME[0],CPUSECS[0],SECFRAC);
	EDIV(CVTSECSMINS,CPUSECS[0],CPUMINS[0],CPUSECS[0]);
	EDIV(CVTSECSMINS,CPUMINS[0],CPUHOURS,CPUMINS[0]);
	$FAO(PHASTAFMT,OUTLINELENG,OUTBUFDESC,.PHASTATBL[.I,TEXTADR],
		.PAGEFAULTS,.CPUHOURS,.CPUMINS[0],.CPUSECS[0],.SECFRAC,
		LNK$CALCELAPS(.PHASTATBL[.I-1,STIMADR],.PHASTATBL[.I,STIMADR]));
	LNK$MAPOUT(BUFFER,.OUTLINELENG);
     END;
!
$ADJWSL(PAGCNT=0,WSETLM=WORKSETLIM);
MEMUSED = LNK$GL_MEMLHD;
WHILE .MEMUSED[0] NEQ 0
DO MEMUSED = .MEMUSED[0];
MEMUSED = (MEMUSED[0] - .LNK$GL_MINADDR + 511)/512;
LNK$MAPOUT(BUFFER,0);
$FAO(WORKSET,OUTLINELENG,OUTBUFDESC,.WORKSETLIM,.MEMUSED);
LNK$MAPOUT(BUFFER,.OUTLINELENG);
!
LNK$MAPOUT(BUFFER,0);
$FAO(OBJRECS,OUTLINELENG,OUTBUFDESC,.LNK$GL_OBJRECS);
LNK$MAPOUT(BUFFER,.OUTLINELENG);
$FAO(LIBRECS,OUTLINELENG,OUTBUFDESC,.LNK$GL_LIBRECS,.LNK$GW_DBGRECS,.LNK$GL_DBGESTIM);
LNK$MAPOUT(BUFFER,.OUTLINELENG);
IF (DBGBYTES = .LNK$GL_DSTEND) NEQ 0
AND (.LNK$GL_CTLMSK[LNK$V_DBG]
     OR .LNK$GL_CTLMSK[LNK$V_TRACE])
THEN BEGIN
	$FAO(DBGDATA,OUTLINELENG,OUTBUFDESC,.DBGBYTES,.LNK$GW_DSTVBN,.LNK$GW_DSTBLKS);
	LNK$MAPOUT(BUFFER,.OUTLINELENG);
    END;
LNK$MAPOUT(BUFFER,0);
$FAO(EXTRMODS,OUTLINELENG,OUTBUFDESC,.LNK$GL_NMODSEXP);
LNK$MAPOUT(BUFFER,.OUTLINELENG);
$FAO(SRCHMODS,OUTLINELENG,OUTBUFDESC,.LNK$GL_NMODSRCH);
LNK$MAPOUT(BUFFER,.OUTLINELENG);
LNK$MAPOUT(BUFFER,0);
$FAO(FUTLSRCH,OUTLINELENG,OUTBUFDESC,.LNK$GL_FUTLSRCH);
LNK$MAPOUT(BUFFER,.OUTLINELENG);
LNK$MAPOUT(BUFFER,0);
$FAO(SYMRECS,OUTLINELENG,OUTBUFDESC,(.LNK$GW_SYMRECS+.LNK$GW_GSTRECS));
LNK$MAPOUT(BUFFER,.OUTLINELENG);
LNK$MAPOUT(BUFFER,0);				! SKIP A LINE
!
! PRINT THE COMMAND LINE
!
BEGIN
    LOCAL
	PCHARS,
	NCHARS,
	CHARS;

PCHARS = 0;
CHARS = .LNK$AL_CMDDESC[CLI$W_RQSIZE];
WHILE (.CHARS GTR 0)
DO BEGIN
    NCHARS = MIN (.CHARS, LEN$C_MAPLINE);
    LNK$MAPOUT(.LNK$AL_CMDDESC[CLI$A_RQADDR] + .PCHARS, .NCHARS);
    CHARS = .CHARS - .NCHARS;
    PCHARS = .PCHARS + .NCHARS;
    END;
!
! PRINT THE OPTION FILE (IF PRESENT)
!
WHILE .LNK$GL_OPTEXTP NEQ 0
DO BEGIN
    LNK$MAPOUT(LNK$GL_OPTEXTP[OEB$T_TEXT],		!PRINT THE LINE
		.LNK$GL_OPTEXTP[OEB$W_BYTCNT]);
    LNK$GL_OPTEXTP = .LNK$GL_OPTEXTP[OEB$L_NXTOEB];	!LINK TO NEXT LINE
    END;
END;
RETURN;
END;					! End of LNK$STATSOUT
END ELUDOM				!End of module
