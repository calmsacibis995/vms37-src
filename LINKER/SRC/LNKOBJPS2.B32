MODULE LNK_OBJPASS2 (
		ADDRESSING_MODE (NONEXTERNAL=LONG_RELATIVE,
				EXTERNAL=GENERAL),
		IDENT='V03-000') =

BEGIN
!
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
!
!
!
!++
!
! MODULE: LNK_OBJPASS2
!
! FACILITY: LINKER
!
! ABSTRACT: PASS 2 OF OBJECT MODULES
!
! HISTORY:
!
!	VERSION: X01.00
!
!	AUTHOR: T.J. PORTER 11-APR-77
!
! MODIFIED BY:
!
!	V03-020	BLS0155		Benn Schreiber		28-Feb-1982
!		Correct args to signal of ILLRECTYP
!
!	V03-019	BLS0151		Benn Schreiber		21-Feb-1982
!		Set isl$v_memalo in fixup section in baseallimages
!
!	V03-018	BLS0138		Benn Schreiber		26-Jan-1982
!		Correct over-eager edit 017.
!
!	V03-017	BLS0134		Benn Schreiber		12-Jan-1982
!		Do not allow reference to a shareable image with store
!		position independent relative reference.  imgact does not
!		understand arithmetic.
!
!	V03-016	BLS0111		Benn Schreiber		22-Nov-1981
!		Clear OMD$L_DLILST at start of module
!
!	V03-015	BLS0110		Benn Schreiber		19-Nov-1981
!		Don't do address fixups if world was based due
!		to illegal reference
!
!	V03-014	BLS0107		Benn Schreiber		16-Nov-1981
!		Correct bug in v03-012
!
!	V03-013	BLS0103		Benn Schreiber		10-Nov-1981
!		Report no GSD ref to shareable image symbol if
!		such a beast is found.  This is generally a
!		compiler bug
!
!	V03-012	BLS0101		Benn Schreiber		 7-Nov-1981
!		Remove NONPICDAT message and just count in OMD
!
!	V03-011	BLS0090		Benn Schreiber		31-Oct-1981
!		Stack module local symbol
!
!	V03-010	BLS0074		Benn Schreiber		29-Aug-1981
!		Rework protirdbg into smaller, more manageable routines
!
!	V03-009	BLS0050		Benn Schreiber		23-Mar-1981
!		Independent shareable images
!
!	V03-008	BLS0048		Benn Schreiber		13-Mar-1981
!		Issue message if .addr in shr image and user has
!		not explicitly based it.
!
!	V03-007	BLS0042		Benn Schreiber		25-Feb-1981
!		Remove deferred relocation code
!
!	V03-006	BLS0035		Benn Schreiber		19-Jan-1981
!		65K psects
!
!	V03-005	BLS0028		Benn Schreiber		3-Dec-1980
!		Correct argument in useundef signal.
!
!	V03-004	BLS0011		Benn Schreiber,		1-Sep-1980
!		Implement TIR$C_CTL_STKDL
!
!	V03-003	BLS0012		Benn Schreiber,		1-Sep-1980
!		Disable deferred relocation.
!
!	V03-002	BLS0007		Benn Schreiber,		3-Jun-1980
!		Convert to MDL data structures.
!
!	V03-001	BLS0006		Benn Schreiber,		3-Jun-1980
!		Set match control to -1 rather than zeroing match id.
!
!--

!
!++
!
! FUNCTIONAL DESCRIPTION:
!
!
!	THIS MODULE CONTAINS THE ROUTINES WHICH IMPLEMENT THE SECOND OBJECT
!	MODULE PASS OF THE LINK. SINCE THE DATA STRUCTURES RELATING
!	OBJECT MODULES AND FILES WERE BUILT DURING PASS 1, IT IS NOW ONLY
!	NECESSARY TO FOLLOW THE LINKED LISTS TO ACQUIRE EACH OBJECT
!	MODULE.
!	PASS 2 IS CONCERNED WITH WRITING THE BINARY TO THE
!	OUTPUT IMAGE AND PRODUCTION OF THE MODULE SYNOPSIS OF THE
!	OUTPUT MAP LISTING. THEREFORE, THIS PASS IGNORES GSD
!	RECORDS COMPLETELY.
!--
!
LIBRARY
	'LIBL32';			! SYSTEM DATA STRUCTURES
REQUIRE
	'PREFIX';			! MACROS ETC.
LIBRARY
	'DATBAS';			! INTERNAL DATA BASE
REQUIRE
	'ISGENC';			! ISECT GENERATION CONTROL TABLES
REQUIRE
	'TIRAUX';			! AUXILIARY MACROS FOR TIR DATA
!
STRUCTURE
	DOUBLEVECTOR [I,J;N,UNIT=4,EXT=1]=
			[2*UNIT*N]
			(DOUBLEVECTOR + 2*UNIT*I + UNIT*J);
!
LINKAGE
	TIR_PROC = JSB : GLOBAL (COMMANDTYPE = 11,
				COMMANDATA = 10,
				DATALNG = 9) PRESERVE (2,3,4) NOPRESERVE (5,6,7,8),
	TIR_PROC2 = CALL : GLOBAL (COMMANDTYPE = 11,
				COMMANDATA = 10,
				DATALNG = 9);
FORWARD ROUTINE
	REPORT_ILLNAMLNG,				! ILLEGAL SYMBOL NAME LENGTH
	REPORT_TIRLNG : TIR_PROC2,			! REPORT RECORD TOO SHORT FOR DATA REQUIRED
	REPORT_UDEFPSC,					! REPORT REFERENCE TO UNDEFINED PSECT
	REPORT_USEUNDEF,				! REPORT USING UNDEFINED SYMBOL
	REPORT_USEUDFENV,				! REPORT USING UNDEFINED ENVIRONMENT
	REPORT_USEUDFLSY,				! REPORT USING UNDEFINED MODULE LOCAL SYMBOL
	PROHDRS,					! PASS 2 PROCESSING OF HEADER RECORDS
	ALLOC_SPCR,					! ALLOCATE SPCR BLOCK
	COMPARE_SPCR,					! COMPARE VALUE AND SPCR BLOCK
	COMPARE_LIT,					! COMPARE VALUE AND LIT BLOCK
	ALLOC_LIT,					! ALLOCATE LIT BLOCK
	PROTIRDBG,					! PASS 2 ON TIR AND DBG RECORDS
	STACKCOMMAND : TIR_PROC,			! PROCESS TIR STACK COMMANDS
	STORECOMMAND : TIR_PROC,			! PROCESS TIR STORE COMMANDS
	OPERATECOMMAND : TIR_PROC,			! PROCESS TIR OPERATE COMMANDS
	CONTROLCOMMAND : TIR_PROC,			! PROCESS TIR CONTROL COMMANDS
	REPORT_ILLTIR : TIR_PROC,			! PROCESS ILLEGAL TIR COMMANDS
	REPORT_ILLTIR2 : TIR_PROC2,			! PROCESS ILLEGAL TIR COMMANDS
	FNDPSCMAPENT,					! RETURNS MAPPING TABLE ADDRESS
	BASEALLIMAGES,					! BASE ALL PIC,NON-BASED SHAREABLE IMAGES
	CHECKSHRSYM,					! VERIFY CORRECTNESS OF SHR IMG SYMBOL REF
	SETADDRESSREF,					! STORE INFO FOR .ADDR
	PUSH,						! PUSHES VALUES ONTO INTERNAL STACKS
	POP;						! REMOVES THEM
!
EXTERNAL ROUTINE
	CRF$INSRTKEY,					! INSERT A KEY DESCRIPTION IN CREF TABLES
	CRF$INSRTREF,					! INSERT A REFERENCE IN CREF TABLES
	LIB$INSERT_TREE,				! INSERT INTO BINARY TREE
	LIB$LOOKUP_TREE,				! LOOKUP IN BINARY TREE
	LNK$NXTOBJMOD,					! ACQUIRE NEXT OBJECT MODULE
	LNK$NXTREC,					! GET NEXT RECORD OF OBJECT MODULE
	LNK$MAPMHD,					! MAP MODULE HEADER INFORMATION
	LNK$MAPLNG,					! MAP THE COMPILER NAME
	LNK$SEARCH,					! SYMBOL TABLE SEARCH
	LNK$SEARCHLOCAL,				! LOCAL SYMBOL TABLE SEARCH
	LNK$FNDPSCNAM,					! FIND/ENTER P-SECTION
	LNK$ALLOBLK, 					! MEMORY ALLOCATION ROUTINE
	LNK$GETFIXSIZE,					! COMPUTE SIZE OF FIXUP VECTOR
	LNK$CREFIXISD,					! CREATE FIXUP SECTION
	LNK$ALLOVIRMEM,					! ALLOCATE MEMORY AT A SPECIFIC ADDRESS
	LNK$CLUVIRMEM,					! ALLOCATE MEMORY FOR A CLUSTER
	LNK$WRTIMGBYTS;					! WRITE BYTE STREAM TO IMAGE
!
EXTERNAL LITERAL
	LIB$_NORMAL,					! NORMAL RTL RETURN
	LIN$_ADRWRTDAT,					! .ADDRESS IN SHR, WRT SECTION
	LIN$_ALREDEF,					! MULTIPLE .TRANSFER FOR A SYMBOL
	LIN$_BASDUERRS,					! BASING IMAGE DUE TO REFERENCE ERRORS
	LIN$_EOMSTK,					! STACK NOT COLLAPSED AT EOM
	LIN$_FORMAT,					! ILLEGAL FORMAT
	LIN$_ILLNAMELEN,				! ILLEGAL NAME LENGTH (SYMBOL OR PSECT)
	LIN$_ILLRECTYP,					! ILLEGAL RECORD TYPE
	LIN$_ILLSHROPR,					! ILLEGAL OPERATOR ON SHR IMG SYM
	LIN$_ILLSHRXPR,					! TWO SHR SYMS IN EXPRESSION
	LIN$_ILLTIR,					! ILLEGAL TIR COMMAND
	LIN$_INTSTKOV,					! INTERNAL STACK OVERFLOW
	LIN$_INTSTKUN,					! INTERNAL STACK UNDERFLOW
	LIN$_INSVIRMEM,					! INSUFFICIENT VIRTUAL MEMORY
	LIN$_NOEPM,					! ATTEMPT TO STACK ENTRYPOINT MASK
	LIN$_NOGSDREF,					! NO GSD REF TO SHAREABLE IMAGE SYMBOL FOUND
	LIN$_NOIMGFIL,					! NO IMAGE FILE CREATED
	LIN$_NONPICREF,					! USE OF .LONG, ETC TO RELOCATABLE IN SHAREABLE IMAGE
	LIN$_NOTPSECT,					! SET RELOC. BASE TO OTHER THAN PSECT CONTEXT
	LIN$_RECTYP,					! ILLEGAL RECORD
	LIN$_SHRPSCREF,					! INCORRECT REFERENCE TO SHAREABLE IMAGE PSECT
	LIN$_SHRSYMREF,					! INCORRECT REFERENCE TO SHAREABLE IMAGE SYMBOL
	LIN$_SHRSYMTRA,					! ATTEMPTED .TRANSFER FOR SHR IMG SYM
	LIN$_STALITUDF,					! STACK OF UNDEFINED LITERAL
	LIN$_TIRLNG,					! TIR COMMAND DATA O'FLOWS RECORD
	LIN$_TIRNYI,					! UNIMPLEMEMTED TIR COMMAND
	LIN$_TRUNC,					! TRUNCATION ERRORS
	LIN$_TRUNCDAT,					! WITH DATA OUTPUT
	LIN$_UDEFPSC,					! REFERENCE TO UNDEFINED P-SECTION
	LIN$_USEUDFENV,					! REFERENCE TO UNDEFINED ENVIRONMENT
	LIN$_USEUDFEN2,					!  ...
	LIN$_USEUDFLSY,					! REFERENCE TO UNDEFINED MODULE-LOCAL SYMBOL
	LIN$_USEUNDEF,					! USING AN UNDEFINED SYMBOL
	LIN$_USEUNDEF2,					!  ... IN A DEBUG / TRACEBACK RECORD
	LIN$_ILLVPS,					! ILLEGAL ARGUMENTS TO STORE VARIABLE POSITION/SIZE
	LIN$_EXCPSC;					! TOO MANY PSECTS DEFINED (IN A SHAREABLE IMAGE BEING CREATED)
!
EXTERNAL
	LNK$GW_SHRISCTS : WORD,				! NUMBER OF ISECTS FROM PIC SHAREABLE IMAGES
	LNK$GB_MATCHCTL : BYTE,				! GLOBAL SECTION MATCH CONTROL FOR SHAREABLE IMAGE BEING CREATED
	LNK$AL_VALCTLTB,				! CREF BY VALUE CONTROL TABLE
	LNK$AL_SYTBLFMT,				! SYMBOL TABLE FORMAT DESCRIPTION BLOCK
	LNK$GL_CTLMSK : BLOCK[,BYTE],			! LINK CONTROL MASK
	LNK$GL_CURISD : REF BLOCK[,BYTE], 		! ADDRESS OF ISD OWNING CURRENT P-SECT
	LNK$GL_LOCN,					! CURRENT LOCATION COUNTER
	LNK$GL_DSTLOCN,					! CURRENT LOCATION IN DEBUG SYMBOL TABLE
	LNK$GL_CURCLU : REF BLOCK[,BYTE],		! POINTER TO CURRENT CLUSTER DESCRIPTOR
	LNK$GL_CLULST,					! LIST HEAD OF CLUSTER LIST
	LNK$GL_FIXISD : REF BLOCK[,BYTE],		! POINTER TO FIXUP ISECT DESCRIPTOR
	LNK$GL_LASTGADR,				! LAST SPECIAL G^ ADDR ASSIGNED
	LNK$GL_RECORD,					! RECORD NUMBER
	LNK$GL_RPROTISD,				! NUMBER OF ISECTS TO REPROTECT
	LNK$GL_IMGFIL : REF BLOCK[,BYTE],		! IMAGE FILE FDB
	LNK$GT_IMGNAM : VECTOR[,BYTE], 			! IMAGE FILE NAME
	LNK$GT_SYMSTRING,				! ASCIC STRING OF 'SYMBOL'
	LNK$GT_PSCSTRING,				! ASCIC STRING OF 'PSECT'
	LNK$GL_CUROMD : REF BLOCK[,BYTE],		! POINTER TO CURRENT OBJ MOD. DESCRIPTOR
	LNK$GL_CURFIL : REF BLOCK[,BYTE];		! POINTER TO CURRENT FILE DESCRIPTOR
!
GLOBAL
	LNK$GL_OMDADRLST,				! LISTHEAD OF LIST OF OMD'S CONTAINING .ADDRESS
	LNK$GL_OMDADREND,				! POINTER TO END OF OMDADRLST
	LNK$GL_NADROMD,					! NUMBER OF MODULES CONTAINING .ADDRESS DATA
	LNK$GL_PSHRNUM : INITIAL (0),			! COUNT THE NUMBER OF PSECTS
							! BOUND FOR A (POSSIBLE)
							! SHAREABLE IMAGE
	LNK$GL_SPCGFIX,					! NUMBER OF SPECIAL G^ FIXUPS
	LNK$GL_SPCGIMGS,				! NUMBER OF SHR IMGS REFERENCED WITH SPECIAL G^ FIXUPS
	LNK$GL_ADREFS,					! NUMBER OF .ADDRESS FIXUPS IN LINK
	LNK$GL_SHRADR,					! NUMBER OF SHAREABLE IMAGES REF'D BY .ADDRESS
	LNK$GL_LITBL,					! POINTER TO LITERAL TABLE
	LNK$GL_LITFLGS : BITVECTOR[LNK$C_NLITS],	! DEF FLAGS FOR LITERALS
	LNK$GL_CURPSC : REF BLOCK[,BYTE];		! POINTER TO CURRENT PSECT DESCRIPTOR
!
GLOBAL LITERAL
	STK$C_SIZE = 25;				! INTERNAL STACK SIZE
!
OWN
	SHRIMGSYM : REF BLOCK[,BYTE],			! POINTER TO STACKED SYMBOL DESCRIPTOR IF FROM SHAREABLE IMAGE
	SHRSYMEXPR : REF BLOCK[,BYTE],			! POINTER TO STACKED SYMBOL DESCRIPTOR IF SHR IMG SYMBOL EXPRESSION
	OBMODESC : REF BLOCK[,BYTE],			! CURRENT OBJ DESCRIPTOR
	OBJRECDESC : BLOCK[DSC$C_S_BLN,BYTE],		! STRING DESCRIPTOR FOR OBJ RECORD
	CURPSECTBASE,					! BASE ADDRESS OF CURRENT CONTRIBUTION
	STAPX : BYTE,					! TRUE IF LAST COMMAND WAS STAPX
	STACKPOINTER : BYTE,				! INTERNAL STACK POINTER
	BASEDMSGOUT : BYTE,				! TRUE IF MSG ABOUT BASING HAS BEEN ISSUED
	ENDRECADDR,					! END OF CURRENT RECORD
	TIROFFSET,					! OFFSET OF CURRENT COMMAND
	PDL,						! POSITION DEPENDENCE LEVEL
	COMPUSTACK : VECTOR[STK$C_SIZE],		! COMPUTATION STACK
	PDLSTACK : VECTOR[STK$C_SIZE,BYTE],		! PDL STACK
	PSECTSTACK : DOUBLEVECTOR[STK$C_SIZE],		! STACK TO RECORD P-SECTION CONTEXT
	SHRSYMSTACK : VECTOR[STK$C_SIZE],		! STACK SHRIMGSYM
	STAPXSTACK : VECTOR[STK$C_SIZE,BYTE];		! STACK STAPX

BIND
	RECLNG = OBJRECDESC[DSC$W_LENGTH] : WORD,
	OBJREC = OBJRECDESC[DSC$A_POINTER] : REF BLOCK[,BYTE];

	PSECT OWN = $CODE$;
OWN
	STKDATLNGTBL : VECTOR[TIR$C_MAXSTACOD+1,BYTE] INITIAL(	! STACK COMMAND DATA LENGTH TABLE
				   BYTE(1,		! 0 - STACK GLOBAL - AT LEAST ONE BYTE FOLLOWS
					1,		! 1 - STACK SIGNED BYTE - ONE BYTE MUST FOLLOW
					2,		! 2 - STACK SIGNED WORD - TWO BYTES MUST FOLLOW
					4,		! 3 - STACK LONGWORD - FOUR BYTES MUST FOLLOW
					2,		! 4 - STACK P-SECTION BASE PLUS BYTE - TWO DATA BYTES
					3,		! 5 -   "       "       "   "   WORD - THREE DATA BYTES
					5,		! 6 -   "       "       "   "  LONGWORD - FIVE DATA BYTES
					1,		! 7 - STACK UNSIGNED BYTES - ONE BYTE MUST FOLLOW
					2,		! 8 - STACK UNSIGNED WORD - TWO BYTES MUST FOLLOW
					0,		! 9 - STACK BYTE FROM IMAGE - NO DATA BYTES
					0,		! 10 - STACK WORD FROM IMAGE - NO DATA BYTES
					0,		! 11 - STACK LONGWORD FROM IMAGE - NO DATA BYTES
					1,		! 12 - STACK ENTRY POINT MASK - AT LEAST ONE BYTE REQUIRED
					2+ARG$C_SIZE,	! 13 - STACK RESULT OF ARGUMENT CHECK.
					3,		! 14 - STACK PSECT BASE PLUS BYTE (WORD PSECT NUMBER) - THREE DATA BYTES
					4,		! 15 - STACK PSECT BASE PLUS WORD (WORD PSECT NUMBER) - FOUR DATA BYTES
					6,		! 16 - STACK PSECT BASE PLUS LONGWORD (WORD PSECT NUMBER) - 6 DATA BYTES
					3,		! 17 - STACK LOCAL SYMBOL
					1)),		! 18 - STACK LITERAL
!					3)),		! 19 - STACK LOCAL ENTRY POINT

	STORECTLTBL : BLOCKVECTOR[TIR$C_MAXSTOCOD-TIR$C_MINSTOCOD	! THIS IS THE
				+1 ,STOCTL$C_SIZE,BYTE]		! STORE COMMAND CONTROL TABLE
								! EACH ENTRY OF WHICH HAS TWO BYTES, BEING
								! THE FLAGS AND OUTPUT BYTE COUNT (RESPECTIVELY)
								! FOR THE CORRESPONDING STORE COMMAND.
								! SEE 'TIRAUX' FOR FURTHER DETAILS.
								! COMMAND TIR$C_MINSTOCOD + ...
		INITIAL ( BYTE (0,1,				! 0 - STORE SIGNED BYTE
				0,2,				! 1 - STORE SIGNED WORD
				0,4,				! 2 - STORE LONGWORD
				STOCTL$M_DISPL,1,		! 3 - STORE BYTE DISPLACED
				STOCTL$M_DISPL,2,		! 4 - STORE WORD DISPLACED
				STOCTL$M_DISPL,4,		! 5 - STORE LONGWORD DISPLACED
				6^STOCTL$C_MBZBIT,1,		! 6 - STORE SHORT LITERAL
				0,4,				! 7 - STORE POSITION INDEPENDENT LONGWORD DATA REF
				0,5,				! 8 - STORE POSITION INDEPENDENT CODE REFERENCE
								! WHICH IS ADDRESSING MODE FOLLOWED BY LONGWORD
				STOCTL$M_REP,1,			! 9 - REPEATED SIGNED BYTE
				STOCTL$M_REP,2,			! 10 - REPEATED SIGNED WORD
				STOCTL$M_REP,4,			! 11 - REPEATED LONGWORD
				0,4,				! 12 - ARBITRARY BIT FIELD (UP TO 1 BYTE, BUT DON'T CHECK TRUNC.)
				8^STOCTL$C_MBZBIT,1,		! 13 - UNSIGNED BYTE
				16^STOCTL$C_MBZBIT,2,		! 14 - UNSIGNED WORD
				STOCTL$M_REP OR (8^STOCTL$C_MBZBIT) ,1,	! 15 - REPEATED UNSIGNED BYTE
				STOCTL$M_REP OR (16^STOCTL$C_MBZBIT),2,	! 16 - REPEATED UNSIGNED WORD
				STOCTL$M_CONMBZ OR (8^STOCTL$C_MBZBIT) ,1,	! 17 - BYTE (-128 TO +255)
				STOCTL$M_CONMBZ OR (16^STOCTL$C_MBZBIT),2,	! 18 - WORD (-32K TO + 65K)
				STOCTL$M_REP OR STOCTL$M_CONMBZ OR	! 19 - REPEATED BYTE (-128 TO +255)
					(8^STOCTL$C_MBZBIT),1,
				STOCTL$M_REP OR STOCTL$M_CONMBZ OR	! 20 - REPEATED WORD (-32K TO +65K)
				(16^STOCTL$C_MBZBIT),2,		! 20 - REPEATED WORD (-32K TO +65K)
				STOCTL$M_REP,0,			! 21 - STORE REPEATED IMMEDIATE VARIABLE NO. BYTES
				0,4));				! 22 - STORE POSITION INDPENDENT RELATIVE REFERENCE

	PSECT OWN = $OWN$;
BIND
	FIXUP_SECTION = CSTRING('Fixup section'),	! NAME OF THE FIXUP SECTION
	OBJVEC = OBJREC : REF VECTOR[,BYTE],		! NAME RECORD AS BYTE VECTOR ALSO
	TIRREC = OBJREC : REF VECTOR[,BYTE];		! RENAME THE RECORD


ROUTINE REPORT_ILLNAMLNG (SYMBOLSTRING) =
BEGIN
!
! REPORT SYMBOL NAME LENGTH ILLEGAL
!
MAP
    SYMBOLSTRING : REF VECTOR[,BYTE];

SIGNAL(LIN$_ILLNAMELEN,6,LNK$GT_SYMSTRING,
	SYMBOLSTRING[0],.SYMBOLSTRING[0],
	SYM$C_MAXLNG,OBMODESC[OMD$B_NAMLNG],
	LNK$GL_CURFIL[FDB$Q_FILENAME]);

RETURN FALSE
END;

ROUTINE REPORT_TIRLNG : TIR_PROC2 =
BEGIN
!
! REPORT RECORD TOO SHORT TO HOLD REQUIRED DATA
!
EXTERNAL REGISTER
    DATALNG = 9;

SIGNAL(LIN$_TIRLNG,4,.DATALNG,OBMODESC[OMD$B_NAMLNG],	!SIGNAL RECORD TOO SHORT
	.LNK$GL_RECORD,LNK$GL_CURFIL[FDB$Q_FILENAME]);

RETURN FALSE
END;

ROUTINE REPORT_UDEFPSC (PSECTNUM) =
BEGIN
!
! REPORT REFERENCE TO AN UNDEFINED PSECT
!
SIGNAL(LIN$_UDEFPSC,3,.PSECTNUM,OBMODESC[OMD$B_NAMLNG],
	LNK$GL_CURFIL[FDB$Q_FILENAME]);

RETURN FALSE
END;

ROUTINE REPORT_USEUNDEF (SYMBOLNAME) =
BEGIN
!
! REPORT ATTEMPT TO USE AN UNDEFINED SYMBOL
!
IF .LNK$GL_CTLMSK[LNK$V_DBGREC]
    THEN SIGNAL(LIN$_USEUNDEF2,3,.SYMBOLNAME,
		OBMODESC[OMD$B_NAMLNG],LNK$GL_CURFIL[FDB$Q_FILENAME])
    ELSE SIGNAL(LIN$_USEUNDEF,5,.SYMBOLNAME,
		LNK$GL_CURPSC[PSC$B_NAMLNG],(.LNK$GL_LOCN-.CURPSECTBASE),
		OBMODESC[OMD$B_NAMLNG],LNK$GL_CURFIL[FDB$Q_FILENAME]);

RETURN FALSE
END;

ROUTINE REPORT_USEUDFENV (ENVDESC,ENVINDEX) =
BEGIN
!
! REPORT REFERENCE TO UNDEFINED ENVIRONMENT
!
MAP
    ENVDESC : REF BLOCK[,BYTE];

LOCAL
    ERRORCODE,
    ARG1;

IF .ENVDESC EQL 0
THEN BEGIN
    ERRORCODE = LIN$_USEUDFEN2;
    ARG1 = .ENVINDEX;
    END
ELSE BEGIN
    ERRORCODE = LIN$_USEUDFENV;
    ARG1 = ENVDESC[NVD$B_NAMLNG];
    END;
SIGNAL(.ERRORCODE,5,.ARG1,
	LNK$GL_CURPSC[PSC$B_NAMLNG],
	(.LNK$GL_LOCN-.CURPSECTBASE),
	OBMODESC[OMD$B_NAMLNG],
	LNK$GL_CURFIL[FDB$Q_FILENAME]);

RETURN FALSE
END;

ROUTINE REPORT_USEUDFLSY (SYMBOLNAME) =
BEGIN
!
! REPORT REFERENCE TO UNDEFINED LOCAL SYMBOL
!
SIGNAL(LIN$_USEUDFLSY,5,.SYMBOLNAME,
	LNK$GL_CURPSC[PSC$B_NAMLNG],(.LNK$GL_LOCN-.CURPSECTBASE),
		OBMODESC[OMD$B_NAMLNG],LNK$GL_CURFIL[FDB$Q_FILENAME]);

END;

ROUTINE REPORT_ILLTIR : TIR_PROC =
BEGIN

EXTERNAL REGISTER
    COMMANDTYPE = 11 : BYTE;

SIGNAL(LIN$_ILLTIR,4,
	.COMMANDTYPE,OBMODESC[OMD$B_NAMLNG],
	.LNK$GL_RECORD,LNK$GL_CURFIL[FDB$Q_FILENAME]);

RETURN FALSE
END;

ROUTINE REPORT_ILLTIR2 : TIR_PROC2 =
BEGIN

EXTERNAL REGISTER
    COMMANDTYPE = 11 : BYTE;

SIGNAL(LIN$_ILLTIR,4,
	.COMMANDTYPE,OBMODESC[OMD$B_NAMLNG],
	.LNK$GL_RECORD,LNK$GL_CURFIL[FDB$Q_FILENAME]);

RETURN FALSE
END;

ROUTINE FNDPSCMAPENT(PSCTNUM) =
BEGIN
!	THIS ROUTINE RETURNS THE ADDRESS OF THE MAPPING TABLE ENTRY
!	FOR THE GIVEN PSECT NUMBER.
!

IF .PSCTNUM GTRU .OBMODESC[OMD$W_HIPSCT]
    THEN RETURN 0;

IF NOT .OBMODESC[OMD$V_P256]
THEN RETURN OBMODESC[OMD$T_PSCMAP]+.PSCTNUM*PMT$C_SIZE
!
! MODULE HAS MORE THAN 256 PSECTS
!
ELSE BEGIN
    LOCAL
	MAPENT : REF BLOCK[,BYTE];

    MAPENT = .(OBMODESC[OMD$T_PSCMAP] + ((.PSCTNUM-1)/256)*PMT$C_SIZE);	! GET EXTENDED TABLE ADDRESS
    IF .MAPENT NEQ 0							! IF EXTENDED TABLE PRESENT
	THEN RETURN .MAPENT + (.PSCTNUM MOD 256)*PMT$C_SIZE		!  THEN RETURN ENTRY ADDRESS
	ELSE RETURN 0;
    END;
END;									! OF FNDPSCMAP

ROUTINE PUSH (VALUE, PSECTNUM, POSDEPLVL) =
BEGIN
!
!	THIS ROUTINE IMPLEMENTS THE PUSHING OF VALUES ON THE LINKERS
!	INTERNAL STACKS. INPUT PARAMETERS ARE:
!		VALUE	   =	VALUE TO BE PLACED ON STACK
!		PSECTNUM   =	THE MODULE RELATIVE P-SECTION INDEX TO
!				WHICH THE STACKED VALUE IS RELATIVE
!		POSDEPLVL  =	THE POSITION DEPENDENCE LEVEL OF THE VALUE
!				BEING STACKED.
!				NORMALLY = 1 FOR AN ADDRESS (E.G. A
!					     RELOCATED SYMBOL)
!					   0 FOR A SCALER.
!	IF PSECTNUM = -1 THEN THE VALUE IS NOT TO BE RELATIVE TO A 
!	P-SECTION BASE ADDRESS. IF, HOWEVER, PSECTNUM IS NOT -1, THEN
!	THE OBJECT MODULE DESCRIPTOR IS ACCESSED TO DETERMINE IF THIS
!	MODULE HAS SUCH A P-SECTION (FOUND ON PASS 1) AND TO COMPUTE
!	THE BASE ADDRESS OF THIS MODULE'S CONTRIBUTION TO THAT P-SECTION.
!	IF THIS SUCCEEDS, THE VALUE STACKED IS THE SUM OF THE MODULE
!	CONTRIBUTION BASE AND "VALUE"
!
!	IN ADDITION TO THE ABOVE CHECKS, THIS ROUTINE ALSO DETECTS STACK
!	OVERFLOW. ON ANY FAILURE CONDITION, AN ERROR MESSAGE IS ISSUED
!	AND THE VALUE "FALSE" IS RETURNED.
!
!	THERE ARE TWO PARALLEL STACKS - ONE FOR COMPUTATION AS DRIVEN
!	BY THE COMPILER GENERATED OBJECT LANGUAGE AND THE OTHER
!	CALLED THE PDL STACK, FOR LINKER COMPUTATION OF POSITION
!	DEPENDENCE AND COERCION OF PIC IMAGES. THE COMPUTATION 
!	STACK IS LONGWORD ALIGNED WHILE THE PDL STACK IS A BYTE STACK.
!
LOCAL
	PSCTMAP : REF BLOCK[,BYTE],		! POINTER TO PSECT MAPPING TABLE ENTRY
	MODCONTRIBASE,				! BASE OF THIS MODULES CONTRIBUTION TO P-SECTION
	PSECTDESC : REF BLOCK[,BYTE],		! P-SECTION DESCRIPTOR POINTER
	MODPSCONTRIBLK : REF BLOCK[,BYTE];	! POINTER TO DESCRIPTOR OF CONTRIBUTION
!
IF .PSECTNUM EQL -1						! MODULE BASE OF P-SECTION
THEN (MODCONTRIBASE = 0; PSECTDESC = 0)				! IS ZERO IF NOT P-SECT RELATIVE
ELSE BEGIN							! VALUE. IF IT IS PSECT
	IF .PSECTNUM GTRU .OBMODESC[OMD$W_HIPSCT]		! RELATIVE, CHECK P-SECTION
	    THEN RETURN REPORT_UDEFPSC(.PSECTNUM);
	PSCTMAP = FNDPSCMAPENT(.PSECTNUM);			! GET MAPPING TABLE ENTRY
	IF .PSCTMAP EQL 0
	    OR (PSECTDESC = .PSCTMAP[PMT$L_PSCDES]) EQL 0	! GET P-SECTION DESCRIPTOR
	    OR (MODPSCONTRIBLK = .PSCTMAP[PMT$L_MODCON]) EQL 0	! AND MODULE CONTRIBUTION BLOCK
	    THEN RETURN REPORT_UDEFPSC(.PSECTNUM);
	MODCONTRIBASE = .PSECTDESC[PSC$L_BASE] +		! THE MODULE'S BASE IS
				 .MODPSCONTRIBLK[MPC$L_OFFSET]; ! P-SECT BASE PLUS OFFSET.
     END;
IF .STACKPOINTER EQL 0							! NOW CHECK IF ALREADY
THEN BEGIN								! AT BOTTOM OF STACK AND
	SIGNAL(LIN$_INTSTKOV,3,STK$C_SIZE,				! IF SO ISSUE ERROR MESSAGE
			OBMODESC[OMD$B_NAMLNG],
			LNK$GL_CURFIL[FDB$Q_FILENAME]);
	RETURN FALSE;
	END;

STACKPOINTER = .STACKPOINTER -1;					! DECREMENT POINTER
COMPUSTACK[.STACKPOINTER] = .VALUE + .MODCONTRIBASE;			! PUSH VALUE ONTO COMPUTE STACK
PDLSTACK[.STACKPOINTER] = .POSDEPLVL;					! AND ON PDL STACK.
PSECTSTACK[.STACKPOINTER,0] = .PSECTDESC;				! SAVE PSECT DESCRIPTOR ADDRESS AND THE
PSECTSTACK[.STACKPOINTER,1] = .MODCONTRIBASE;				! MODULE'S BASE ON THE PSECT STACK
SHRSYMSTACK[.STACKPOINTER] = .SHRIMGSYM;				! SAVE AWAY SHR IMG SYMBOL INFO
STAPXSTACK[.STACKPOINTER] = .STAPX;
RETURN TRUE;								! AND RETURN SUCCESS.
END;

ROUTINE POP (VALUEADDR, PDLADDR) =
BEGIN
!
!	THIS ROUTINE REMOVES VALUES FROM THE INTERNAL STACKS
!	OF THE LINKER AS DESCRIBED WITH "PUSH" ABOVE.
!	STACK OVERFLOW CAUSES THE ISSUANCE OF AN ERROR
!	MESSAGE AND RETURN VALUE OF FALSE.
!
IF .STACKPOINTER GEQU STK$C_SIZE
THEN BEGIN
    SIGNAL(LIN$_INTSTKUN,3,STK$C_SIZE,				! IF STACK IS ALREADY
			OBMODESC[OMD$B_NAMLNG],			! EMPTY, ISSUE ERROR AND QUIT
			LNK$GL_CURFIL[FDB$Q_FILENAME]);
    RETURN FALSE;
    END;
.VALUEADDR = .COMPUSTACK[.STACKPOINTER];			! POP VALUE
.PDLADDR = .PDLSTACK[.STACKPOINTER];				! AND PDL TO WHERE CALLER WANTS THEM
SHRIMGSYM = .SHRSYMSTACK[.STACKPOINTER];			! RESTORE SHR IMG SYMBOL INFO
STAPX = .STAPXSTACK[.STACKPOINTER];
STACKPOINTER = .STACKPOINTER + 1;
RETURN TRUE;							! UPDATE POINTER AND
END;								! SUCCESS

ROUTINE COMPARE_LIT (VALUE, NODE) =
BEGIN
!
! COMPARE A VALUE WITH CURRENT NODE
!
MAP
    NODE : REF BLOCK[,BYTE];

RETURN (.VALUE - .NODE[LIT$B_INDEX])
END;

ROUTINE ALLOC_LIT (VALUE, RETADR) =
BEGIN
!
! ALLOCATE A NEW LIT BLOCK
!
MAP
    RETADR : REF VECTOR[,LONG];

LNK$ALLOBLK(LIT$C_SIZE, RETADR[0]);

RETURN TRUE
END;

ROUTINE STACKCOMMAND : TIR_PROC =
BEGIN
!
! PROCESS TIR STACK COMMANDS
!
EXTERNAL REGISTER
    COMMANDTYPE = 11 : BYTE,
    COMMANDATA = 10 : REF BLOCK[,BYTE],
    DATALNG = 9;

LOCAL
    ARGNUM,					! INDEX TO ARGUMENT TO BE CHECKED
    ARGDESC : REF BLOCK[,BYTE],			! POINTER TO ARGUMENT DESCRIPTOR
    PSECTNUM,					! P-SECTION NUMBER
    SYMDSCNAM : REF BLOCK[,BYTE],		! PTR TO NAME BLOCK PART
    SYMDESC : REF BLOCK[,BYTE],			! SYMBOL DESCRIPTOR POINTER
    ENVDESC : REF BLOCK[,BYTE],			! POINTER TO ENVIRONMENT DESCRIPTOR
    VALUE;					! TEMP VALUE HOLDER

DATALNG = .STKDATLNGTBL[.COMMANDTYPE];			! GET EXPECTED DATA LENGTH
IF (COMMANDATA[SIGNED_BYTE] + .DATALNG) GTRU .ENDRECADDR! AND CHECK THAT IT EXISTS
    THEN RETURN REPORT_TIRLNG();
PDL = 0;						! INITIALIZE AS PIC
VALUE = 0;						! DEFAULT VALUE
PSECTNUM = -1;						! NOT P-SECTION RELATIVE
SHRIMGSYM = STAPX = 0;					! AND NOT SHAREABLE IMAGE SYMBOL/PSECT
!
! DISPATCH ON THE COMMAND TYPE
!
CASE .COMMANDTYPE FROM 0 TO TIR$C_MAXSTACOD
OF SET
    [TIR$C_STA_GBL,					! STACK GLOBAL SYMBOL
    TIR$C_STA_EPM,					! ENTRY POINT MASK
    TIR$C_STA_CKARG] :					! CHECK ARGUMENT
	BEGIN					
	    DATALNG = .DATALNG+.COMMANDATA[SYMBOLENG];		! UPDATE THE ACTUAL LENGTH OF THE DATA
	    IF .COMMANDTYPE EQL TIR$C_STA_CKARG			! IF ARGUMENT CHECK COMMAND
	    THEN BEGIN
		ARGNUM = .(COMMANDATA[SYMBOLENG] + 1 + 		! FETCH THE ARGUMENT
				.COMMANDATA[SYMBOLENG])<0,8,0>;	! NUMBER AS AN UNSIGNED BYTE
		ARGDESC = 2 + COMMANDATA[SYMBOLENG] +		! AND COMPUTE ADDRESS
					.COMMANDATA[SYMBOLENG];	! WITHIN RECORD
		DATALNG = .DATALNG + .ARGDESC[ARG$B_BYTECNT];	! THEN UPDATE DATA COUNT
		END;
	    IF (COMMANDATA[SYMBOLENG] +.DATALNG) GTRU .ENDRECADDR ! CHECK IF DATA ALL PRESENT
		THEN RETURN REPORT_TIRLNG();
	    IF .COMMANDATA[SYMBOLENG] GTRU SYM$C_MAXLNG		! CHECK SYMBOL NAME LENGTH
		OR .COMMANDATA[SYMBOLENG] EQL 0
		THEN RETURN REPORT_ILLNAMLNG(COMMANDATA[SYMBOLENG]);
	    IF NOT LNK$SEARCH(COMMANDATA[SYMBOLENG],SYMDESC,SYMDSCNAM) ! GO LOOK UP SYMBOL
	    THEN BEGIN
		IF .COMMANDTYPE EQL TIR$C_STA_CKARG		! IF NOT FOUND
		    THEN VALUE = TRUE;				! DEFAULT IS 0 EXCEPT FOR CHECK ARG
		REPORT_USEUNDEF(COMMANDATA[SYMBOLENG]);		! REPORT REFERENCE TO UNDEFINDE SYMBOL
		END
	    ELSE BEGIN						! SYMBOL FOUND
		IF .SYMDESC[SYM$V_SHRIMG]			! IF SYMBOL IS FROM A SHAREABLE IMAGE
		    AND .SYMDESC[SYM$V_REL]			!  AND IS RELOCATABLE
		    AND NOT .SYMDESC[SYM$V_GREF]		!  BUT HAS NOT BEEN PUT IN SHR LST
		    THEN BEGIN
			SIGNAL(LIN$_NOGSDREF,3,COMMANDATA[SYMBOLENG], ! THEN TELL USER OF PROBLEM
				OBMODESC[OMD$B_NAMLNG],
				LNK$GL_CURFIL[FDB$Q_FILENAME],LIN$_NOIMGFIL);
			LNK$GL_CTLMSK[LNK$V_IMAGE] = FALSE;
			END;
		IF .COMMANDTYPE EQL TIR$C_STA_EPM		! IF THIS IS STACK ENTRY POINT MASK
		    THEN IF NOT .SYMDESC[SYM$V_ENTMSK]		!  THEN MAKE SURE SYMBOL HAS ONE
			THEN SIGNAL(LIN$_NOEPM,3,		!  ISSUE MESSAGE IF NOT.
				COMMANDATA[SYMBOLENG],OBMODESC[OMD$B_NAMLNG],
				LNK$GL_CURFIL[FDB$Q_FILENAME]);	!  MASK FIELD IN SYMBOL BLOCK WILL BE 0
		IF NOT .SYMDESC[SYM$V_DEF]			! NOW CHECK WHAT WE FOUND WAS A DEF.
		    THEN REPORT_USEUNDEF(COMMANDATA[SYMBOLENG]);! AND REPORT ERROR IF NOT
		IF .COMMANDTYPE EQL TIR$C_STA_GBL
		THEN BEGIN
		    VALUE = .SYMDESC[SYM$L_VALUE];		! GET SYMBOL VALUE IF COMMAND IS STACK GLOBAL
		    IF .SYMDESC[SYM$V_REL]			! AND IF RELOCATABLE SET PDL = 1
			THEN PDL = 1;
		    IF .SYMDESC[SYM$V_REL]			! IF SYMBOL IS RELOCATABLE
			OR .SYMDESC[SYM$V_GREF]			! OR FROM A SHARABLE IMAGE
			THEN SHRIMGSYM = .SYMDESC;		! REMEMBER ADDRESS OF SYMBOL BLOCK
		    END
		ELSE IF .COMMANDTYPE EQL TIR$C_STA_EPM		! FOR STACK ENTRY POINT MASK, MASK IS THE VALUE
		    THEN VALUE = .SYMDESC[SYM$W_ENTMSK];
		IF .COMMANDTYPE EQL TIR$C_STA_CKARG
		THEN BEGIN					! CHECK ARGUMENT ...
		    BIND
			ARGVALDATA = SYMDESC[SYM$L_VALDATA]	! POINT TO THE VALIDATION
						: REF VECTOR[,BYTE];	! DATA ARRAY
		    IF .ARGVALDATA EQL 0			! BUT IF NONE
			THEN VALUE = TRUE			! SET INDICATOR
			ELSE IF (.ARGVALDATA[0] - 3) LSSU .ARGNUM ! IF NOT ENOUGH ARGS
			    THEN VALUE = TRUE			! ALSO ASSUME MATCH
			    ELSE IF .ARGVALDATA[2+.ARGNUM]	! OTHERWISE COMPARE THE ARGUMENTS
						EQL .ARGDESC[ARG$V_PASSMECH]
				THEN VALUE = TRUE;		! AND SET VALUE
		     END;
	         END;
	    END;
    [TIR$C_STA_LSY,
     TIR$C_STA_LEPM] :
	BEGIN
	    DATALNG = .DATALNG + .COMMANDATA[LSYMBOLENG];		! COMPUTE SIZE OF DATA NEEDED
	    IF (COMMANDATA[LENVINDEX] + .DATALNG) GTRU .ENDRECADDR	! ENSURE ALL THERE
		THEN RETURN REPORT_TIRLNG();				!  AND RETURN WITH ERROR IF NOT
	    IF .COMMANDATA[LSYMBOLENG] GTRU SYM$C_MAXLNG		! CHECK LENGTH OF SYMBOL NAME
		OR .COMMANDATA[LSYMBOLENG] EQL 0
		THEN RETURN REPORT_ILLNAMLNG(COMMANDATA[LSYMBOLENG]);
	    IF NOT LNK$SEARCHLOCAL(COMMANDATA[LSYMBOLENG],		! LOOK UP THE SYMBOL
				.COMMANDATA[LENVINDEX],
				SYMDESC,SYMDSCNAM,ENVDESC)
	    THEN BEGIN
		IF .ENVDESC EQL 0					! SIGNAL UNDEFINED ENVIRONMENT IF THAT IS TRUE
			OR NOT .ENVDESC[NVD$V_DEF]
		    THEN REPORT_USEUDFENV(.ENVDESC,.COMMANDATA[LENVINDEX]);
		REPORT_USEUDFLSY(COMMANDATA[LSYMBOLENG]);
		END
	    ELSE BEGIN
		IF .ENVDESC EQL 0
		    OR NOT .ENVDESC[NVD$V_DEF]
		    THEN REPORT_USEUDFENV(.ENVDESC,.COMMANDATA[LENVINDEX]);
		IF NOT .SYMDESC[SYM$V_DEF]
		    THEN REPORT_USEUDFLSY(COMMANDATA[LSYMBOLENG]);
		IF .COMMANDTYPE EQL TIR$C_STA_LEPM			! CHECK ENTRY MASK PRESENT IF STA_LEPM
		THEN BEGIN
		    IF NOT .SYMDESC[SYM$V_ENTMSK]
			THEN SIGNAL(LIN$_NOEPM,3,COMMANDATA[LSYMBOLENG],
				OBMODESC[OMD$B_NAMLNG],LNK$GL_CURFIL[FDB$Q_FILENAME])
			ELSE VALUE = .SYMDESC[SYM$W_ENTMSK];
		    END
		ELSE IF .COMMANDTYPE EQL TIR$C_STA_LSY			! IF STACKING LOCAL SYMBOL, GET SYMBOL VALUE
		THEN BEGIN
		    VALUE = .SYMDESC[SYM$L_VALUE];
		    IF .SYMDESC[SYM$V_REL]
			THEN PDL = 1;
		    END;
		END;
	    END;
    [TIR$C_STA_SB] :
	    VALUE = .COMMANDATA[SIGNED_BYTE];			! GET A SIGN EXTENDED BYTE
    [TIR$C_STA_SW] :
	    VALUE = .COMMANDATA[SIGNED_WORD];			! GET SIGN EXTENDED WORD
    [TIR$C_STA_LW] :
	    VALUE = .COMMANDATA[LONGWORD];			! GET LONGWORD DATA
    [TIR$C_STA_PB,
    TIR$C_STA_PW,
    TIR$C_STA_PL] :
    	    BEGIN
    		LOCAL
    		    CLUDESC : REF BLOCK[,BYTE],
		    PSCTMAP : REF BLOCK[,BYTE],
		    PSCTDESC : REF BLOCK[,BYTE];

		PDL = 1;					! VALUE IS POSITION DEPENDENT
		PSECTNUM = .COMMANDATA[PSECT_INDEX];		! EXTRACT PSECT NUMBER
		PSCTMAP = FNDPSCMAPENT(.PSECTNUM);		! GET DESCRIPTOR ADDRESS
		IF .PSCTMAP NEQ 0
		THEN BEGIN
		    PSCTDESC = .PSCTMAP[PMT$L_PSCDES];		! GET PSECT DESCRIPTOR ADDRESS
		    SHRIMGSYM = .PSCTDESC;			! SAVE PSECT DESCRIPTOR ADDRESS
		    CLUDESC = .PSCTDESC[PSC$L_CLUDSC];		! POINT TO CLUSTER PSECT IS IN
		    IF .CLUDESC[CLU$V_SHRIMG]			! IF IT'S A SHAREABLE IMAGE CLUSTER
			OR .LNK$GL_CTLMSK[LNK$V_SHR]		!  OR CREATING SHR IMAGE
			THEN STAPX = TRUE			! REMEBER LAST COMMAND WAS STAPX
			ELSE SHRIMGSYM = 0;			! BUT IF NOT, JUST FORGET IT
		    IF .CLUDESC[CLU$V_SHRIMG]			! IF TARGET IS SHAREABLE IMAGE CLUSTER
			AND .CLUDESC[CLU$V_BASED]		!  WHICH IS BASED
			THEN PDL = 0;				! THEN IT'S NOT POSITION DEPENDENT
		    END
		ELSE RETURN REPORT_UDEFPSC(.PSECTNUM);		! REPORT ERROR REFERENCING UNDEFINED PSECT
		CASE .COMMANDTYPE FROM TIR$C_STA_PB TO TIR$C_STA_PL
		OF SET
		    [TIR$C_STA_PB] :
				VALUE = .COMMANDATA[PSECT_B_OFFSET];	! GET A BYTE OFFSET
		    [TIR$C_STA_PW] :
				VALUE = .COMMANDATA[PSECT_W_OFFSET];	! WORD OFFSET
		    [TIR$C_STA_PL] :
				VALUE = .COMMANDATA[PSECT_L_OFFSET];	! LONGWORD OFFSET
		    TES
		END;
    [TIR$C_STA_WPB,							! STACK PSECT BASE PLUS OFFSET COMMANDS
    TIR$C_STA_WPW,							! WHICH ALLOW A WORD OF PSECT NUMBER
    TIR$C_STA_WPL] :
		BEGIN
			LOCAL
			    CLUDESC : REF BLOCK[,BYTE],
			    PSCTMAP : REF BLOCK[,BYTE],
			    PSCTDESC : REF BLOCK[,BYTE];

			PDL = 1;					! VALUE IS POSITION DEPENDENT
			PSECTNUM = .COMMANDATA[WPSECT_INDEX];		! EXTRACT PSECT NUMBER
			PSCTMAP = FNDPSCMAPENT(.PSECTNUM);		! GET DESCRIPTOR ADDRESS
			IF .PSCTMAP NEQ 0
			THEN BEGIN
			    PSCTDESC = .PSCTMAP[PMT$L_PSCDES];		! GET PSECT DESCRIPTOR ADDRESS
			    SHRIMGSYM = .PSCTDESC;			! SAVE PSECT DESCRIPTOR ADDRESS
			    CLUDESC = .PSCTDESC[PSC$L_CLUDSC];		! SAVE CLUSTER ADDRESS
			    IF .CLUDESC[CLU$V_SHRIMG]			! IF IT'S A SHAREABLE IMAGE CLUSTER
				OR .LNK$GL_CTLMSK[LNK$V_SHR]		!  OR CREATING SHR IMAGE
				THEN STAPX = TRUE			! REMEBER LAST COMMAND WAS STAPX
				ELSE SHRIMGSYM = 0;			! BUT IF NOT, JUST FORGET IT
			    IF .CLUDESC[CLU$V_SHRIMG]			! IF TARGET IS SHAREABLE IMAGE CLUSTER
				AND .CLUDESC[CLU$V_BASED]		!  WHICH IS BASED
				THEN PDL = 0;				! THEN IT'S NOT POSITION DEPENDENT
			    END
			ELSE RETURN REPORT_UDEFPSC(.PSECTNUM);		! NOT DEFINED, REPORT ERROR AND RETURN
			CASE .COMMANDTYPE FROM TIR$C_STA_WPB TO	TIR$C_STA_WPL
			OF SET
			    [TIR$C_STA_WPB] :
					VALUE = .COMMANDATA[WPSECT_B_OFFSET];	! GET A BYTE OFFSET
			    [TIR$C_STA_WPW] :
					VALUE = .COMMANDATA[WPSECT_W_OFFSET];	! WORD OFFSET
			    [TIR$C_STA_WPL] :
					VALUE = .COMMANDATA[WPSECT_L_OFFSET];	! LONGWORD OFFSET
			    TES
			END;
    [TIR$C_STA_UB] :
		    VALUE = .COMMANDATA[UNSIGNED_BYTE];				! UNSIGNED BYTE
    [TIR$C_STA_UW] :
		    VALUE = .COMMANDATA[UNSIGNED_WORD];				! UNSIGNED WORD
    [TIR$C_STA_LIT] :
		    BEGIN
			LOCAL
			    LITINDEX;

			!
			! GET THE INDEX.  ENSURE THAT THE LITERAL
			! HAS BEEN DEFINED. USE 0 IF NOT, AND ISSUE
			! A WARNING MESSAGE
			!
			LITINDEX = .COMMANDATA[UNSIGNED_BYTE];
			IF NOT .LNK$GL_LITFLGS[.LITINDEX]
			    THEN SIGNAL(LIN$_STALITUDF,4,.LITINDEX,
				.LNK$GL_RECORD,OBMODESC[OMD$B_NAMLNG],
				LNK$GL_CURFIL[FDB$Q_FILENAME])
			ELSE BEGIN
			    LOCAL
				ENTRY : REF BLOCK[,BYTE];

			    IF LIB$LOOKUP_TREE(LNK$GL_LITBL,.LITINDEX,		! LOOKUP LITERAL IN TREE
						COMPARE_LIT,ENTRY)
			    THEN BEGIN
				PDL = .ENTRY[LIT$V_PDL];			! RETRIEVE VALUES NEEDED
				STAPX = .ENTRY[LIT$V_STAPX];
				SHRIMGSYM = .ENTRY[LIT$L_SHRSYM];
				SHRSYMEXPR = .ENTRY[LIT$L_SHREXPR];
				VALUE = .ENTRY[LIT$L_VALUE];
				END
			    ELSE SIGNAL(LIN$_STALITUDF,4,.LITINDEX,
					.LNK$GL_RECORD,OBMODESC[OMD$B_NAMLNG],
					LNK$GL_CURFIL[FDB$Q_FILENAME]);
			    END;
			END;
    [INRANGE] :
		RETURN REPORT_ILLTIR2();		! OTHERWISE IT'S ILLEGAL
    TES;

RETURN PUSH (.VALUE,.PSECTNUM,.PDL)			! NOW PUSH THE VALUES AND RETURN
END;

ROUTINE BASEALLIMAGES =
BEGIN
!
! THIS ROUTINE ALLOCATES VIRTUAL ADDRESS SPACE FOR FIXUP SECTION AND
! BASES ALL PIC, NON-BASED SHAREABLE IMAGES
!
LOCAL
    FIXHDR : REF BLOCK[,BYTE],
    FIXSIZE,
    CLUSTER : REF BLOCK[,BYTE],
    SYMSNB : REF BLOCK[,BYTE],
    SYMBOL : REF BLOCK[,BYTE];

IF NOT .LNK$GL_CTLMSK[LNK$V_LBASED]		! IF WE HAVEN'T DONE THIS YET
THEN BEGIN
    IF .LNK$GL_FIXISD EQL 0			! IF NO FIXUP SECTION YET CREATED
	THEN LNK$CREFIXISD();
    FIXHDR = LNK$GL_FIXISD[ISL$T_HDRISD];	! POINT TO PART BOUND FOR HEADER
    FIXHDR[ISD$W_PAGCNT] = LNK$GETFIXSIZE();	! COMPUTE SIZE OF SECTION
    IF NOT LNK$ALLOVIRMEM(.FIXHDR[ISD$V_VPN]^9,
				.FIXHDR[ISD$W_PAGCNT])
    THEN BEGIN
	SIGNAL(LIN$_INSVIRMEM,2,.FIXHDR[ISD$W_PAGCNT],
			FIXUP_SECTION,LIN$_NOIMGFIL);
	LNK$GL_CTLMSK[LNK$V_IMAGE] = FALSE;
	END;
    LNK$GL_FIXISD[ISL$V_MEMALO] = TRUE;		! FLAG FIXUP SECTION ALLOCATED
!
! NOW FIND AND BASE ALL PIC NON-BASED SHAREABLE IMAGES
!
    CLUSTER = LNK$GL_CLULST;
    WHILE (CLUSTER = .CLUSTER[CLU$L_NXTCLU]) NEQ 0
    DO IF .CLUSTER[CLU$V_SHRIMG]
	AND NOT .CLUSTER[CLU$V_BASED]
    THEN BEGIN
	LNK$CLUVIRMEM(.CLUSTER);		! ALLOCATE VIRT MEMORY FOR THIS CLUSTER
	LNK$GW_SHRISCTS = .LNK$GW_SHRISCTS -	! DECREMENT NUMBER OF PIC SHAREABLE IMAGE ISECTS
				.CLUSTER[CLU$L_NISECTS];
	END;
    IF NOT .BASEDMSGOUT
    THEN BEGIN
	BASEDMSGOUT = TRUE;
	SIGNAL(LIN$_BASDUERRS);				! TELL USER HIS IMAGE JUST GOT NAILED DOWN
	END;
    LNK$GL_CTLMSK[LNK$V_LBASED] = TRUE;			! FLAG WE HAVE BASED THE WORLD
    LNK$GL_CTLMSK[LNK$V_PICIMG] = FALSE;		! IMAGE IS NOT PIC ANY MORE
    END;
RETURN FALSE
END;							! OF BASEALLIMAGES

ROUTINE CHECKSHRSYM (SYMBOLBLOCK) =
BEGIN
!
! 	THIS ROUTINE CHECKS THAT THE SYMBOL POINTED TO BY SYMBOLBLOCK
!	IS NOT FROM A SHAREABLE IMAGE.  IF IT IS, AN ERROR MESSAGE IS
!	ISSUED, SINCE THE SYMBOL WAS NOT REFERENCED POSITION INDEPENDENTLY.
!	THEN, AN ATTEMPT IS MADE TO ALLOCATE MEMORY FOR THE CLUSTER, SO THAT
!	THIS REFERENCE CAN BE RESOLVED.
!
MAP
    SYMBOLBLOCK : REF BLOCK[,BYTE];

LOCAL
    SYMSNB : REF BLOCK[,BYTE];

IF .SYMBOLBLOCK NEQ 0
THEN BEGIN
    IF NOT .STAPX
	AND .SYMBOLBLOCK[SYM$V_GREF]
    THEN BEGIN
	SYMSNB = .SYMBOLBLOCK - .SYMBOLBLOCK[SYM$B_NAMLNG] - SNB$C_FXDLEN;
	BASEALLIMAGES();
	SIGNAL(LIN$_SHRSYMREF,5,SYMSNB[SNB$B_NAMLNG],
		LNK$GL_CURPSC[PSC$B_NAMLNG],(.LNK$GL_LOCN-.CURPSECTBASE),
		OBMODESC[OMD$B_NAMLNG],LNK$GL_CURFIL[FDB$Q_FILENAME]);
	RETURN FALSE
	END
    ELSE IF .STAPX
	AND .SYMBOLBLOCK[PSC$V_SHRIMG]
    THEN BEGIN
	BASEALLIMAGES();
	SIGNAL(LIN$_SHRPSCREF,5,SYMBOLBLOCK[PSC$B_NAMLNG],
		LNK$GL_CURPSC[PSC$B_NAMLNG],(.LNK$GL_LOCN-.CURPSECTBASE),
		OBMODESC[OMD$B_NAMLNG],LNK$GL_CURFIL[FDB$Q_FILENAME]);
	RETURN FALSE
	END
    END;

RETURN TRUE
END;

ROUTINE SETADDRESSREF (CLUDESC, ISDESC, LOCN) =
BEGIN
!
! THIS ROUTINE STORES INFO NECESSARY FOR .ADDRESS FIXUPS.  IT STORES THE
! LOCATION (GIVEN BY ARGUMENT LOCN) TO BE FIXED UP IN THE .ADDRESS FIXUP
! INFO FOR THE GIVEN CLUSTER.
!
! INPUTS:
!
!	CLUDESC		ADDRESS OF CLUSTER DESCRIPTOR FOR TARGET OF REFERENCE
!	ISDESC		ADDRESS OF ISECT DESCRIPTOR WHERE REF IS STORED
!	LOCN		LOCATION OF REF
!
MAP
    CLUDESC : REF BLOCK[,BYTE],
    ISDESC : REF BLOCK[,BYTE];

LOCAL
    ADRBLOCK : REF VECTOR[,LONG];

BIND
    LASTBLOCK = CLUDESC[CLU$L_LSTADRL] : REF VECTOR[,LONG];

ADRBLOCK = .LASTBLOCK;				! POINT AT CURRENT BLOCK
IF .CLUDESC[CLU$L_ADRLEFT] EQL 0		! IF BLOCK IS EMPTY
THEN BEGIN
    LNK$ALLOBLK(CLU$C_ADRBLOCK*4,ADRBLOCK);	! ALLOCATE ANOTHER BLOCK
    LASTBLOCK[0] = .ADRBLOCK;			! LINK INTO THE LIST
    CLUDESC[CLU$L_LSTADRL] = .ADRBLOCK;		! MAKE IT THE NEW LAST BLOCK
    ADRBLOCK[0] = 0;				! MAKE IT THE END OF THE LIST
    CLUDESC[CLU$L_ADRLEFT] = CLU$C_ADRBLOCK-1;	! SET COUNT OF SLOTS LEFT IN BLOCK
    END;
ADRBLOCK[CLU$C_ADRBLOCK - .CLUDESC[CLU$L_ADRLEFT]] ! SET LOCATION IN BLOCK
				= .LOCN;
CLUDESC[CLU$L_ADRLEFT] = .CLUDESC[CLU$L_ADRLEFT] -1; ! COUNT ONE LESS IN BLOCK
IF .CLUDESC[CLU$L_ADRCNT] EQL 0			! IF THIS IS FIRST REF TO THIS CLUSTER
    THEN LNK$GL_SHRADR = .LNK$GL_SHRADR + 1;	!  THEN COUNT ANOTHER CLUSTER
CLUDESC[CLU$L_ADRCNT] = .CLUDESC[CLU$L_ADRCNT] + 1; ! COUNT REF IN THIS CLUSTER
LNK$GL_ADREFS = .LNK$GL_ADREFS + 1;		! COUNT THE REFERENCE
IF .ISDESC NEQ 0				! ENSURE THERE IS AN ISECT
THEN BEGIN
    BIND
	CURHDRISD = ISDESC[ISL$T_HDRISD]	! PART FOR HEADER
				 : BLOCK[,BYTE];

    IF NOT .CURHDRISD[ISD$V_CRF]		! SECTION MUST BE CRF
    THEN BEGIN
	CURHDRISD[ISD$V_CRF] = TRUE;		! MAKE IT CRF
	IF NOT .CURHDRISD[ISD$V_WRT]
	THEN BEGIN
	    CURHDRISD[ISD$V_WRT] = TRUE;	! MAKE SECTION WRITEABLE
	    LNK$GL_CURISD[ISL$B_NEWPRT] = PRT$C_UR; ! TELL IACT TO MAKE IT RO LATER
	    LNK$GL_CURISD[ISL$V_REPROT] = TRUE;	! FLAG SECTION NEEDS REPROTECTING
	    LNK$GL_RPROTISD = .LNK$GL_RPROTISD + 1; ! COUNT THE REPROTECTION
	    END;
	END;
    END;

RETURN TRUE
END;

ROUTINE COMPARE_SPCR (VALUE,NODE) =
BEGIN
!
! COMPARE A VALUE WITH CURRENT NODE
!
MAP
    NODE : REF BLOCK[,BYTE];

RETURN (.VALUE - .NODE[SPCR$L_OFFSET])
END;

ROUTINE ALLOC_SPCR (VALUE,RETADR) =
BEGIN
!
! ALLOCATE A NEW SPCR BLOCK
!
MAP
    RETADR : REF VECTOR[,LONG];

LOCAL
    ENTRY : REF BLOCK[,BYTE];

LNK$ALLOBLK(SPCR$C_SIZE,ENTRY);			! ALLOCATE NEW BLOCK
ENTRY[SPCR$L_OFFSET] = .VALUE;			! SET OFFSET IN IMAGE
ENTRY[SPCR$L_FIXADR] = .LNK$GL_LASTGADR;	! SET FIXUP VECTOR VA
LNK$GL_LASTGADR = .LNK$GL_LASTGADR + 4;		! UPDATE VA FOR NEXT
LNK$GL_SPCGFIX = .LNK$GL_SPCGFIX + 1;		! COUNT ANOTHER SPECIAL FIXUP
RETADR[0] = .ENTRY;				! RETURN VALUE TO CALLER

RETURN TRUE
END;

ROUTINE STORECOMMAND : TIR_PROC =
BEGIN
!
EXTERNAL REGISTER
    COMMANDTYPE = 11 : BYTE,
    COMMANDATA = 10 : REF BLOCK[,BYTE],
    DATALNG = 9;

LOCAL
    STOCMDINDEX,					! INDEX INTO THE GROUP
    CORRECTVALUE,					! CORRECTED STORE VALUE
    OUTPUTADDR,						! ADDRESS OF OUTPUT STREAM
    MBZMASK,						! MASK COMPUTED TO CORRECT THE VALUE
    OUTBYTECOUNT,					! NUMBER OF BYTES TO WRITE OUT
    LOWESTMBZBIT,					! FOR COMPUTING MBZ FIELDS
    REPEATCOUNT,					! STORE REPEATED COUNTS
    OUTPUTARRAY : VECTOR[5,BYTE];			! OUTPUT DATA

BIND
    VALUE = OUTPUTARRAY[1];				! LEAVE ONE BYTE FOR ADDRESSING MODE

STOCMDINDEX = .COMMANDTYPE - TIR$C_MINSTOCOD;			! CREATE USEFUL INDEX
OUTBYTECOUNT = .STORECTLTBL[.STOCMDINDEX,STOCTL$B_BYTES];	! GET OUTPUT BYTE COUNT
IF (.STORECTLTBL[.STOCMDINDEX,STOCTL$B_FLAGS]			! IF THIS IS A
		AND STOCTL$M_REP) NEQ 0				! REPEATED STORE,
THEN BEGIN
    IF NOT POP (REPEATCOUNT,PDL)				! GET TOP OF STACK
	THEN RETURN FALSE;					! GIVING UP ON ERROR
    END
ELSE REPEATCOUNT = 1;						! NO REPEAT, SO SET TO 1.
IF .COMMANDTYPE EQL TIR$C_STO_RIVB				! IF THIS IS STOREPEATED IMMEDIATE VAR. NO. BYTES
THEN BEGIN							! PROCESS IT NOW
    BIND
	DATABYTES = TIRREC[.TIROFFSET+1] : VECTOR[,BYTE]; 	! NAME THE DATA PART

    OUTBYTECOUNT = .DATABYTES[0];				! GET THE OUTPUT BYTE COUNT
    DATALNG = .OUTBYTECOUNT + 1;				! FIGURE LENGTH OF RECORD NEEDED TO BE THERE
    SHRIMGSYM = STAPX = SHRSYMEXPR = 0;				! 
    IF (.OUTBYTECOUNT+DATABYTES[1]) GTRU .ENDRECADDR 		! IF RECORD IS TOO SHORT
    THEN RETURN REPORT_TIRLNG()
    ELSE RETURN LNK$WRTIMGBYTS(.OUTBYTECOUNT,DATABYTES[1],	! OTHERWISE, RETURN, WRITING THE BYTES TO THE IMAGE
				.REPEATCOUNT);			! THE NUMBER OF TIMES SPECIFIED
    END;
IF NOT POP (VALUE,PDL)						! ATTEMPT TO GET
    THEN RETURN FALSE;						! VALUE TO BE STORED
IF (.PDL NEQ 0							! IF POSITION-DEPENDENT
	OR (NOT .STAPX AND (.SHRIMGSYM NEQ 0)
		AND .SHRIMGSYM[SYM$V_GREF]))
    AND .COMMANDTYPE NEQ TIR$C_STO_PICR				!  AND COMMAND IS NOT STORE PIC CODE
    AND .COMMANDTYPE NEQ TIR$C_STO_PIDR				!  OR STORE PIC DATA REFERERNCE
    AND NOT .LNK$GL_CTLMSK[LNK$V_UBASED]			!  AND IMAGE NOT BASED BY USER
THEN BEGIN
    IF NOT CHECKSHRSYM(.SHRIMGSYM)				! THEN CHECK CORRECTNESS OF REFERENCE
	THEN VALUE = (IF NOT .STAPX
			    THEN .SHRIMGSYM[SYM$L_VALUE]
			    ELSE 0)				!**??**
	ELSE IF .PDL EQL 1					! IF POS DEP LEVEL IS 1
	    AND .LNK$GL_CTLMSK[LNK$V_SHR]			! AND CREATING SHR IMAGE
	    AND NOT .LNK$GL_CTLMSK[LNK$V_UBASED]
	    AND .COMMANDTYPE NEQ TIR$C_STO_PIRR
	    AND (.COMMANDTYPE LSSU TIR$C_STO_BD			! AND COMMAND IS NOT STORE DISPLACED
		OR .COMMANDTYPE GTRU TIR$C_STO_LD)		!  OF BYTE, WORD, OR LONGWORD
	THEN BEGIN
	    BASEALLIMAGES();					! THEN BASE EVERYTHING
	    SIGNAL(LIN$_NONPICREF,4,LNK$GL_CURPSC[PSC$B_NAMLNG], ! THEN THAT IS AN ERROR
		(.LNK$GL_LOCN-.CURPSECTBASE),OBMODESC[OMD$B_NAMLNG],
		LNK$GL_CURFIL[FDB$Q_FILENAME]);
	    END;
	STAPX = SHRIMGSYM = SHRSYMEXPR = 0;
	END;
IF (.STORECTLTBL[.STOCMDINDEX,STOCTL$B_FLAGS] AND STOCTL$M_DISPL) NEQ 0	! IF A DISPLACEMENT COMMAND
    THEN VALUE = .VALUE - .LNK$GL_LOCN - .OUTBYTECOUNT;		! SUBTRACT CURRENT LOCATION COUNTER AND
								! OUTPUT BYTE COUNT
LOWESTMBZBIT = .STORECTLTBL[.STOCMDINDEX,STOCTL$V_MBZBIT];	! GET NUMBER OF LOWEST
IF (.STORECTLTBL[.STOCMDINDEX,STOCTL$B_FLAGS] AND STOCTL$M_CONMBZ)! BIT WHICH MUST BE ZERO
				NEQ 0
   THEN IF .VALUE<.LOWESTMBZBIT,1,0> NEQ 0			! IF A CONDITIONALLY MBZ
		THEN LOWESTMBZBIT = 0;				! FIELD, SUPPRESS MBZ IF VALUE IS NEGATIVE
IF .LOWESTMBZBIT EQL 0						! IF THERE IS NOT AN MBZ FIELD
    THEN CORRECTVALUE = .VALUE < 0,MIN(32,8*.OUTBYTECOUNT),1>	! CORRECT VALUE IS SIGN EXTENSION
    ELSE BEGIN							! OF THE FIELD TO BE WRITTEN
	MBZMASK = (1^.LOWESTMBZBIT) -1;				! OTHERWISE, MASK VALUE TO GET CORRECT
	CORRECTVALUE = .VALUE AND .MBZMASK;			! ONE
	END;
IF .VALUE NEQ .CORRECTVALUE					! IF VALUE DOES NOT MATCH
THEN BEGIN
    SIGNAL(LIN$_TRUNC,4,					! NOT MATCH THE CORRECT VERSION
		LNK$GL_CURPSC[PSC$B_NAMLNG],(.LNK$GL_LOCN - .CURPSECTBASE), ! ISSUE TRUNCATION ERROR
		OBMODESC[OMD$B_NAMLNG],	LNK$GL_CURFIL[FDB$Q_FILENAME],
		LIN$_TRUNCDAT,3,				! GIVING MODULE, PSECTION,
		.VALUE,.CORRECTVALUE,				! OFFSET, THEN COMPUTED VALUE,
		.LNK$GL_LOCN);					! WRITTEN VALUE AND VIRTUAL ADDRESS
    VALUE = .CORRECTVALUE;					! GET THE CORRECT VALUE
    END;
IF .COMMANDTYPE EQL TIR$C_STO_VPS				! STORE VARIABLE POSITION AND SIZE
THEN BEGIN
    LOCAL
	VPSPOS,
	VPSSIZ;

    DATALNG = 2;
    IF TIRREC[.TIROFFSET+2] GTRU .ENDRECADDR			! MUST HAVE TWO MORE BYTES FOR COMMAND
	THEN RETURN REPORT_TIRLNG();
    VPSPOS = .TIRREC[.TIROFFSET+1];				! GET POSITION
    VPSSIZ = .TIRREC[.TIROFFSET+2];				! AND SIZE
    IF .VPSPOS+.VPSSIZ GEQU 32					! CHECK LEGAL
	OR .VPSPOS+.VPSSIZ GTRU ((.VPSPOS+8)/8*8)
    THEN BEGIN
	SIGNAL(LIN$_ILLVPS,4,
		.VPSPOS,.VPSSIZ,OBMODESC[OMD$B_NAMLNG],
			LNK$GL_CURFIL[FDB$Q_FILENAME]);
	RETURN FALSE
	END
    ELSE RETURN LNK$WRTIMGBYTS(1,.VALUE,0,.VPSPOS,.VPSSIZ);
    END;
IF .COMMANDTYPE EQL TIR$C_STO_PIRR				! STORE POSITION INDEPENDENT RELATIVE REFERENCE
THEN BEGIN
    LOCAL
	VALUE2,
	PDL2;

    IF NOT POP(VALUE2,PDL2)					! POP THE RELATIVE LOCATION
	THEN RETURN FALSE;					! BUT IF AN ERROR, GIVE UP
    IF (.PDL2 NEQ 0						! IF POS DEP VALUE
	    OR (NOT .STAPX AND (.SHRIMGSYM NEQ 0)
			AND .SHRIMGSYM[SYM$V_GREF]))
	AND NOT .LNK$GL_CTLMSK[LNK$V_UBASED]
    THEN BEGIN
	IF NOT CHECKSHRSYM(.SHRIMGSYM)
	    THEN VALUE2	= (IF NOT .STAPX
				THEN .SHRIMGSYM[SYM$L_VALUE]
				ELSE 0)
	    ELSE IF .PDL2 EQL 1
		AND .LNK$GL_CTLMSK[LNK$V_SHR]
		AND NOT .LNK$GL_CTLMSK[LNK$V_UBASED]
		THEN BEGIN
		    BASEALLIMAGES();				! BASE THE WORLD
		    SIGNAL(LIN$_NONPICREF,4,LNK$GL_CURPSC[PSC$B_NAMLNG],
			(.LNK$GL_LOCN-.CURPSECTBASE),OBMODESC[OMD$B_NAMLNG],
			LNK$GL_CURFIL[FDB$Q_FILENAME]);
		    END;
	END;
    IF .VALUE2 EQL -1 THEN VALUE2 = .LNK$GL_LOCN; 		! SUBSTITUTUE CURRENT LOC. FOR -1
    IF .PDL NEQ 0						! FINALLY, IF VALUE IS RELOCATABLE
	THEN VALUE = .VALUE - .VALUE2;				! THEN RELOCATE IT.
    END;
IF .COMMANDTYPE NEQ TIR$C_STO_PICR				! IF THIS IS NOT A STORE POS. IND. CODE OR DATA REF
    AND .COMMANDTYPE NEQ TIR$C_STO_PIDR
    THEN OUTPUTADDR = OUTPUTARRAY[1]				! THEN SET THE OUTPUT POINTER
ELSE IF .COMMANDTYPE EQL TIR$C_STO_PIDR				! IF A STORE PIC DATA REF
THEN BEGIN
    BIND
	SYMCLU = (IF .STAPX THEN SHRIMGSYM[PSC$L_CLUDSC]	! NAME THE CLUSTER THAT REF. IS IN
			ELSE SHRIMGSYM[SYM$L_CLUDSC]) : REF BLOCK[,BYTE];

    OUTPUTADDR = OUTPUTARRAY[1];				! FOUR BYTES GO
    IF .PDL NEQ 0						! IF NON-PIC DATA REFERENCE
	AND NOT .LNK$GL_CTLMSK[LNK$V_DBGREC]			!  AND NOT IN A DEBUG RECORD
    THEN BEGIN
	IF (IF .LNK$GL_CTLMSK[LNK$V_SHR]			! OTHERWISE IF CREATING A SHAREABLE IMAGE
	THEN BEGIN
	    IF .LNK$GL_CTLMSK[LNK$V_PICIMG]			!  AND IT'S A PIC IMAGE
	    THEN BEGIN
		IF .LNK$GL_CURISD EQL 0				! IF NO ISECT
		    THEN TRUE
		    ELSE BEGIN
			BIND
			    CURHDRISD =
					LNK$GL_CURISD[ISL$T_HDRISD] : BLOCK[,BYTE];

			IF .CURHDRISD[ISD$V_WRT]		! IF SECTION IS WRITEABLE
			    AND NOT .CURHDRISD[ISD$V_CRF]	!  BUT NOT COPY ON REF (IE SHAREABLE SECTION)
		        THEN BEGIN
			    BASEALLIMAGES();			! BASE THE WORLD
			    SIGNAL(LIN$_ADRWRTDAT,4,		! TELL USER IMAGE ABOUT .ADDRESS DATA IN COMMON
				LNK$GL_CURPSC[PSC$B_NAMLNG],(.LNK$GL_LOCN-.CURPSECTBASE),
					OBMODESC[OMD$B_NAMLNG],	LNK$GL_CURFIL[FDB$Q_FILENAME]);
			    FALSE
			    END
			ELSE TRUE
			END
		    END
		ELSE (NOT .LNK$GL_CTLMSK[LNK$V_LBASED]		! IF NON-PIC, DON'T DO FIXUP IF WORLD GOT BASED
			AND ((.SHRIMGSYM NEQ 0)			!  IF THAT ISN'T TRUE, ONLY DO FIXUP IF
		    AND NOT .SYMCLU[CLU$V_BASED]))		! TARGET CLUSTER IS NOT BASED
		END
	    ELSE (.SHRIMGSYM NEQ 0				! EXECUTABLE IMAGE...DO ONLY IF REFERENCE
	        AND ((.SYMCLU NEQ .LNK$GL_CURCLU)		! IS TO SYMBOL IN ANOTHER CLUSTER
			AND (.SYMCLU[CLU$V_SHRIMG]		!  THAT IS A SHAREABLE IMAGE
			AND NOT .SYMCLU[CLU$V_BASED]))))	!    AND IS NOT BASED
	THEN BEGIN
	    IF NOT .STAPX					! IF IT WAS NOT STA_PX
		AND (.SHRIMGSYM NEQ 0)				!  IE IT WAS STA_GBL
		AND (.SHRSYMEXPR EQL 0)				!  AND NOT AN EXPRESSION
		AND .SHRIMGSYM[SYM$V_REL]			! OF A RELOCATABLE SYMBOL
		AND .SHRIMGSYM[SYM$V_GREF]			! FROM A SHAREABLE IMAGE
		THEN VALUE = .SHRIMGSYM[SYM$L_OFFSET];		!   THEN GET VALUE OF SHR IMG SYMBOL OFFSET
	    SETADDRESSREF(.SYMCLU,.LNK$GL_CURISD,.LNK$GL_LOCN);	! STORE FIXUP INFORMATION
	    IF .LNK$GL_CTLMSK[LNK$V_LONG]			! IF GETTING A FULL MAP
	    THEN BEGIN						!  THEN COUNT THE .ADDRESSES
		IF .OBMODESC[OMD$L_ADRCNT] EQL 0		! IF THIS IS FIRST .ADDRESS IN THIS MODULE
		THEN BEGIN
		    LOCAL
			LASTOMD : REF BLOCK[,BYTE];

		    LNK$GL_NADROMD = .LNK$GL_NADROMD + 1;	! COUNT ANOTHER MODULE WITH .ADDRESS
		    LASTOMD = .LNK$GL_OMDADREND;		! GET POINTER TO LAST MODULE IN LIST
		    IF .LASTOMD EQL 0				! IF NONE, THEN INSERT AT FRONT OF LIST
			THEN LNK$GL_OMDADRLST = .OBMODESC
			ELSE LASTOMD[OMD$L_NXTADR] = .OBMODESC;	! OTHERWISE, INSERT AT END OF LIST
		    LNK$GL_OMDADREND = .OBMODESC;		! SET NEW END OF LIST
		    END;
		OBMODESC[OMD$L_ADRCNT] = .OBMODESC[OMD$L_ADRCNT] + 1; ! COUNT THE .ADDRESS IN THIS MODULE
		END
	    END;
	END
    END
!
! PROCESS TIR$C_STO_PICR (STORE POS. IND. CODE REF)
!
ELSE BEGIN
    BIND
	SYMCLU = (IF .STAPX THEN SHRIMGSYM[PSC$L_CLUDSC]	! NAME THE CLUSTER DESCRIPTOR
			ELSE SHRIMGSYM[SYM$L_CLUDSC]) : REF BLOCK[,BYTE];

    OUTPUTADDR = OUTPUTARRAY[0];				! WE WILL BE SENDING A MODE BYTE ALSO
    IF .PDL EQL 0						! IF ABS. ADDRESSING 
	THEN OUTPUTARRAY[0] = ABSADDRMODE			!  THEN SET THAT
	!
	! TARGET IS RELOCATABLE
	!
	ELSE BEGIN	
	    IF .SHRIMGSYM NEQ 0					! IF TARGET IS IN A SHR IMAGE
		AND .SYMCLU[CLU$V_SHRIMG]
	    THEN BEGIN
		OUTPUTARRAY[0] = INDPCRELADDR;			! USE "@L^" MODE
		IF .SHRSYMEXPR NEQ 0				! IF TARGET IS AN EXPRESSION
		    OR .STAPX					!  OR A PSECT BASE + OFFSET
		THEN BEGIN
		    LOCAL
			ENTRY : REF BLOCK[,BYTE];

		    IF .SYMCLU[CLU$L_SPCRLST] EQL 0		! IF THIS IS FIRST ONE FOR THIS CLUSTER
			THEN LNK$GL_SPCGIMGS = .LNK$GL_SPCGIMGS + 1; ! THEN COUNT ANOTHER SHR IMG
		    IF LIB$INSERT_TREE(SYMCLU[CLU$L_SPCRLST],	! INSERT INTO SPCR LIST FOR
				.VALUE, %REF(0),COMPARE_SPCR,	! TARGET CLUSTER
				ALLOC_SPCR,ENTRY) EQL LIB$_NORMAL ! AND IF IT WAS INSERTED (NOT ALREADY THERE)
		        THEN SETADDRESSREF(.SYMCLU,0,		! THEN SET A .ADDR FIXUP FOR THE LOC. IN FIXUP VEC
					.ENTRY[SPCR$L_FIXADR]);
		    VALUE = .ENTRY[SPCR$L_FIXADR];		! VALUE TO STORE IS VALUE IN FIXUP
		    END						! (TARGET IS EXPR OR STA_PX)
		END						! (TARGET IS IN SHR IMG)
	    ELSE OUTPUTARRAY[0] = PCRELADDRMODE;		! NOT SHR IMAGE USE PC RELATIVE
	    VALUE = .VALUE-.LNK$GL_LOCN - .OUTBYTECOUNT;	! PC RELATIVE (SO COMPUTE DISPLACEMENT
	    END							! (TARGET IS RELOCATABLE)
	END;
SHRIMGSYM = STAPX = SHRSYMEXPR = 0;				! CLEAR FLAGS
RETURN LNK$WRTIMGBYTS(.OUTBYTECOUNT,.OUTPUTADDR,.REPEATCOUNT);	! FINALLY OUTPUT BYTES

END;

ROUTINE OPERATECOMMAND : TIR_PROC =
BEGIN
!
! PROCESS OPERATE GROUP COMMANDS
!
EXTERNAL REGISTER
    COMMANDTYPE = 11 : BYTE,
    COMMANDATA = 10 : REF BLOCK[,BYTE],
    DATALNG = 9;

BUILTIN
    ROT;

LOCAL
    CLUDESC : REF BLOCK[,BYTE],
    SYMDESC : REF BLOCK[,BYTE],
    SYMDSCNAM : REF BLOCK[,BYTE],	! NAME PART OF BLOCK
    VALUE,
    VALUE2,
    PDL2;

IF .COMMANDTYPE EQL TIR$C_OPR_NOP
    THEN RETURN TRUE;
IF .COMMANDTYPE EQL TIR$C_OPR_REDEF			! IF THIS IS A RE-DEFINITION COMMAND
THEN BEGIN						! FIRST VALIDATE THE TIR STREAM
    DATALNG = 1 + .COMMANDATA[SYMBOLENG];		! SET LENGTH OF DATA
    IF (COMMANDATA[SYMBOLENG] +.DATALNG) GTRU .ENDRECADDR ! CHECK ALL THERE
	THEN RETURN REPORT_TIRLNG();
    IF .COMMANDATA[SYMBOLENG] GTRU SYM$C_MAXLNG		! CHECK LENGTH OF SYMBOL NAME
	OR .COMMANDATA[SYMBOLENG] EQL 0
	THEN RETURN REPORT_ILLNAMLNG(COMMANDATA[SYMBOLENG]);
    IF NOT .LNK$GL_CTLMSK[LNK$V_SHR]			! IF NOT PRODUCING A SHAREABLE IMAGE
	THEN RETURN TRUE;				! FORGET IT
    IF NOT LNK$SEARCH(COMMANDATA[SYMBOLENG],SYMDESC,SYMDSCNAM) ! LOOK IT UP
	OR NOT .SYMDESC[SYM$V_DEF]			! CHECK IT FOR A DEFINITION
    THEN BEGIN						! AND ISSUE ERROR MESSAGE IF NOT
	REPORT_USEUNDEF(COMMANDATA[SYMBOLENG]);
	RETURN TRUE					! AND FORGET IT
	END;
    IF .SYMDESC[SYM$V_REDEF]				! IF THE SYMBOL HAS A REDEF PENDING
    THEN BEGIN
	SIGNAL(LIN$_ALREDEF,5,COMMANDATA[SYMBOLENG],
		LNK$GL_CURPSC[PSC$B_NAMLNG],(.LNK$GL_LOCN-.CURPSECTBASE),
		OBMODESC[OMD$B_NAMLNG],LNK$GL_CURFIL[FDB$Q_FILENAME]);
	RETURN TRUE
	END;
    SYMDESC[SYM$L_NEWVAL] = .LNK$GL_LOCN;		! OTHERWISE SET ITS NEW VALUE
    SYMDESC[SYM$V_REDEF] = TRUE;			! SET REDEF PENDING
    SYMDESC[SYM$V_UNI] = TRUE;				! AND MAKE IT UNIVERSAL
    CLUDESC = .LNK$GL_CURPSC[PSC$L_CLUDSC];		! GET POINTER TO CLUSTER DESCRIPTOR
    IF .LNK$GL_CURPSC[PSC$V_REL]			! IF CURRENT PSECT IS RELOCATABLE
	AND NOT .CLUDESC[CLU$V_BASED]			!  IN A CLUSTER THAT IS NOT BASED
	THEN SYMDESC[SYM$V_REREL] = TRUE;		!  THEN MAKE SURE THAT SYMBOL IS RELOCATABLE (DONE IN LNK$SYMTBLOUT)
    IF .LNK$GL_CTLMSK[LNK$V_MAPOPN]			! IF THERE WAS A MAP OPENED
	AND NOT .LNK$GL_CTLMSK[LNK$V_BRIEF]		! AND IT WAS NOT A BRIEF
	THEN CRF$INSRTKEY(LNK$AL_SYTBLFMT,SYMDSCNAM[SNB$B_NAMLNG], ! TELL CREF ABOUT NEW FLAGS
			SYMDESC[SYM$L_VALUE],.SYMDESC[SYM$W_FLAGS]);
    RETURN TRUE
    END;						! THAT'S ALL FOR REDEF
IF NOT POP(VALUE,PDL)					! FOR ALL OTHERS, GET TOP VALUE FROM STACK
    THEN RETURN FALSE;
IF .SHRIMGSYM NEQ 0
    AND NOT .STAPX
    AND .SHRIMGSYM[SYM$V_GREF]
    AND .SHRIMGSYM[SYM$V_REL]
THEN BEGIN
    VALUE = .SHRIMGSYM[SYM$L_OFFSET];
    SHRSYMEXPR = .SHRIMGSYM;
    END;
IF .COMMANDTYPE NEQ TIR$C_OPR_NEG			! POP SECOND VALUE IF NOT NEGATE
    AND .COMMANDTYPE NEQ TIR$C_OPR_COM			!  COMPLEMENT
    AND .COMMANDTYPE NEQ TIR$C_OPR_DFLIT		!  OR DEFINE LITERAL
THEN BEGIN
    IF NOT POP(VALUE2,PDL2)				! GET SECOND VALUE IF A BINARY
	THEN RETURN FALSE;				!  OPERATOR - ERROR IF NONE
    IF .SHRIMGSYM NEQ 0					! IF FROM SHR IMG
    THEN BEGIN
	IF .SHRSYMEXPR NEQ 0				! AND OTHER OPERAND WAS TOO
	    THEN SIGNAL(LIN$_ILLSHRXPR,3,		!  THEN THAT IS AN ERROR
			OBMODESC[OMD$B_NAMLNG],.LNK$GL_RECORD,
			LNK$GL_CURFIL[FDB$Q_FILENAME]);
	IF NOT .STAPX					! IF STA_GBL
	    AND .SHRIMGSYM[SYM$V_GREF]			! OF SHR IMG SYMBOL
	    AND .SHRIMGSYM[SYM$V_REL]
	THEN BEGIN
	    VALUE2 = .SHRIMGSYM[SYM$L_OFFSET];		! THEN USE THE OFFSET
	    SHRSYMEXPR = .SHRIMGSYM;			! AND REMEMBER THAT IT WAS
	    END;
	END;
    END;

IF .SHRSYMEXPR NEQ 0					! IF ONE OPERAND IS FROM SHR IMG
    AND .COMMANDTYPE NEQ TIR$C_OPR_ADD			! ONLY ADD AND SUB ARE LEGAL
    AND .COMMANDTYPE NEQ TIR$C_OPR_SUB
    THEN SIGNAL(LIN$_ILLSHROPR,3,OBMODESC[OMD$B_NAMLNG], ! ANYTHING ELSE IS ERROR
		.LNK$GL_RECORD,LNK$GL_CURFIL[FDB$Q_FILENAME]);
!
! DISPATCH ON COMMAND
!
CASE .COMMANDTYPE FROM TIR$C_OPR_ADD TO TIR$C_MAXOPRCOD
OF SET
    [TIR$C_OPR_ADD] :
		BEGIN
		    VALUE = .VALUE + .VALUE2;	! ADD THE TWO VALUES
		    PDL = .PDL + .PDL2;		! AND THE TWO POS. DEP. LEVELS
		    TRUE
		    END;
    [TIR$C_OPR_SUB] :
		BEGIN
		    VALUE = .VALUE2 - .VALUE;	! SUBTRACT THE VALUES AND
		    PDL = .PDL2 - .PDL;		! AND POSITION DEPENDENCE LEVELS
		    TRUE
		    END;
    [TIR$C_OPR_NEG] :
		BEGIN
		    VALUE = -.VALUE;
		    TRUE
		    END;
    [TIR$C_OPR_COM] :
		BEGIN
		    VALUE = -1 - .VALUE;
		    TRUE
		    END;
    [TIR$C_OPR_MUL] :
		BEGIN
		    VALUE = .VALUE*.VALUE2;
		    TRUE
		    END;
    [TIR$C_OPR_DIV] :
		BEGIN
		    IF .VALUE NEQ 0			! CHECK FOR DIVIDE BY ZERO
			THEN VALUE = .VALUE2/.VALUE;
		    TRUE
		    END;
    [TIR$C_OPR_IOR] :
		BEGIN
		    VALUE = .VALUE OR .VALUE2;
		    TRUE
		    END;
    [TIR$C_OPR_EOR] :
		BEGIN
		    VALUE = (.VALUE OR .VALUE2) AND 
					NOT(.VALUE AND .VALUE2);
		    TRUE
		    END;
    [TIR$C_OPR_AND] :
		BEGIN
		    VALUE = .VALUE AND .VALUE2;
		    TRUE
		    END;
    [TIR$C_OPR_ROT] :
		BEGIN
		    VALUE = ROT(.VALUE2, .VALUE);
		    TRUE
		    END;
    [TIR$C_OPR_ASH] :
		BEGIN
		    VALUE = .VALUE2 ^ .VALUE;
		    TRUE
		    END;
    [TIR$C_OPR_SEL] :
		BEGIN
		    IF .VALUE EQL TRUE			! IF TOP LONGWORD IS
			THEN RETURN TRUE;		! IS TRUE, ALL DONE
		    VALUE = .VALUE2;			! OTHERWISE MOVE VALUE2
		    PDL = .PDL2;			! TO VALUE 3, DISCARDING
		    IF NOT POP(VALUE2,PDL2)		! WHAT EVER WAS THERE
			THEN RETURN FALSE;		! BUT CHECK SOMETHING WAS
		    END;
    [TIR$C_OPR_DFLIT] :
		BEGIN
		    LOCAL
			ENTRY : REF BLOCK[,BYTE],
			LITINDEX;

		    DATALNG = 1;
		    IF (.COMMANDATA + .DATALNG) GTRU .ENDRECADDR
			THEN RETURN REPORT_TIRLNG();
		    LITINDEX = .COMMANDATA[0,0,8,0];
		    LIB$INSERT_TREE(LNK$GL_LITBL,.LITINDEX,		!INSERT INTO TREE
				%REF(0),COMPARE_LIT,ALLOC_LIT,ENTRY);
		    ENTRY[LIT$V_PDL] = .PDL;
		    ENTRY[LIT$V_STAPX] = .STAPX;
		    ENTRY[LIT$B_INDEX] = .LITINDEX;
		    ENTRY[LIT$L_SHRSYM] = .SHRIMGSYM;
		    ENTRY[LIT$L_SHREXPR] = .SHRSYMEXPR;
		    ENTRY[LIT$L_VALUE] = .VALUE;
		    LNK$GL_LITFLGS[.LITINDEX] = TRUE;
		    RETURN TRUE
		    END;
    [INRANGE] :
		RETURN REPORT_ILLTIR2();
    TES;

RETURN PUSH(.VALUE,-1,.PDL)

END;

ROUTINE COMPARE_DLI (VALUE,NODE) =
BEGIN
!
! COMPARE A VALUE WITH CURRENT NODE
!
MAP
    NODE : REF BLOCK[,BYTE];

RETURN (.VALUE - .NODE[DLI$L_INDEX])
END;

ROUTINE ALLOC_DLI (VALUE,RETADR) =
BEGIN
!
! ALLOCATE A NEW DLI BLOCK
!
MAP
    RETADR : REF VECTOR[,LONG];

LNK$ALLOBLK(DLI$C_SIZE,RETADR[0]);
RETURN TRUE
END;

ROUTINE CONTROLCOMMAND : TIR_PROC =
BEGIN
!
! PROCESS CONTROL COMMANDS
!
EXTERNAL REGISTER
    COMMANDTYPE = 11 : BYTE,
    COMMANDATA = 10 : REF BLOCK[,BYTE],
    DATALNG = 9;

LOCAL
    VALUE;

CASE .COMMANDTYPE FROM TIR$C_CTL_SETRB TO TIR$C_MAXCTLCOD
OF SET
    [TIR$C_CTL_SETRB] :						! PROCESS SETTING OF RELOCATION BASE
	BEGIN
	    IF (LNK$GL_CURPSC = .PSECTSTACK[.STACKPOINTER,0]) EQL 0	! SET POINTER TO CURRENT P-SECTION
	    THEN BEGIN						! DESCRIPTOR AND IF ZERO
		SIGNAL(LIN$_NOTPSECT,2,				! REPORT AS FATAL ERROR
			OBMODESC[OMD$B_NAMLNG],LNK$GL_CURFIL[FDB$Q_FILENAME]);
		RETURN FALSE;
		END
	    ELSE LNK$GL_CURISD = .LNK$GL_CURPSC[PSC$L_ISECT];		! SET CURRENT ISD ADDRESS
	    CURPSECTBASE = .PSECTSTACK[.STACKPOINTER,1];		! SET BASE OF THIS MODULES CONTRIBUTION
	    IF NOT POP (VALUE,PDL)					! GIVE UP IF THAT FAILS
		THEN RETURN FALSE;
	    STAPX = SHRIMGSYM = SHRSYMEXPR = 0;
	    LNK$GL_LOCN = .VALUE;					! OTHERWISE SET IT
	    END;

    [TIR$C_CTL_AUGRB] :						! PROCESS AUGMENTS TO RELOCATION BASE
	BEGIN
	    DATALNG = 4;						! FOUR BYTES OF DATA
	    IF (COMMANDATA[LONGWORD] + .DATALNG) GTRU .ENDRECADDR	! CHECK THE INCREMENT EXISTS
		THEN RETURN REPORT_TIRLNG();
	    LNK$GL_LOCN = .LNK$GL_LOCN + .COMMANDATA[LONGWORD];	! IF AUGMENT, DO THAT
	    END;

    [TIR$C_CTL_DFLOC,
    TIR$C_CTL_STKDL,
    TIR$C_CTL_STLOC] :							! TBK/DBG LOCATION COUNTER CONTROL
	BEGIN
	    LOCAL
		ENTRY : REF BLOCK[,BYTE];

	    IF NOT .LNK$GL_CTLMSK[LNK$V_DBGREC]				! MUST BE IN DEBUG TYPE RECORD
	    THEN BEGIN
		SIGNAL_STOP(LIN$_ILLTIR,4,				! REPORT ILLEGAL TIR TYPE
			.COMMANDTYPE,OBMODESC[OMD$B_NAMLNG],
			.LNK$GL_RECORD,LNK$GL_CURFIL[FDB$Q_FILENAME]);
		RETURN FALSE;
		END
	    ELSE IF NOT POP(VALUE,PDL)						! OTHERWISE POP THE INDEX
		OR .PDL NEQ 0							! AND IF THAT FAILS OR INDEX NOT ABSOLUTE
		THEN RETURN FALSE
		ELSE BEGIN							!
		    IF .COMMANDTYPE EQL TIR$C_CTL_DFLOC				! IF THIS IS DEFINE LOCATION
		    THEN BEGIN
			LIB$INSERT_TREE(OBMODESC[OMD$L_DLILST],.VALUE,		! INSERT INTO TREE
					%REF(0),COMPARE_DLI,ALLOC_DLI,ENTRY);
			ENTRY[DLI$L_INDEX] = .VALUE;
			ENTRY[DLI$L_LOC] = .LNK$GL_LOCN;
			END
		    ELSE BEGIN							! STKDL OR STLOC
			IF NOT LIB$LOOKUP_TREE(OBMODESC[OMD$L_DLILST],
					.VALUE,COMPARE_DLI,ENTRY)
			THEN BEGIN
			    SIGNAL(LIN$_ILLTIR,4,.COMMANDTYPE,OBMODESC[OMD$B_NAMLNG],
				.LNK$GL_RECORD,LNK$GL_CURFIL[FDB$Q_FILENAME]);
			    RETURN FALSE
			    END;
			IF .COMMANDTYPE EQL TIR$C_CTL_STLOC
			    THEN LNK$GL_LOCN = .ENTRY[DLI$L_LOC]
			    ELSE RETURN PUSH(.ENTRY[DLI$L_LOC],-1,0);
			END;
		    END;
		END;
	  [INRANGE] : RETURN REPORT_ILLTIR2();
	TES;

RETURN TRUE
END;

ROUTINE PROTIRDBG =
BEGIN
!
!	PROCESS TIR, DBG AND TRACEBACK RECORDS
!
!
    PSECT PLIT = $CODE$;

BIND
    TIRDISPTABLE = UPLIT(				! TIR DISPATCH TABLE
			REP TIR$C_MAXSTACOD+1			! STACK   COMMANDS
					OF WORD(STACKCOMMAND-PROTIRDBG),
		%IF TIR$C_MINSTOCOD-TIR$C_MAXSTACOD-1 NEQ 0
		    %THEN
			REP TIR$C_MINSTOCOD-TIR$C_MAXSTACOD-1	! ILLEGAL COMMANDS
					OF WORD(REPORT_ILLTIR-PROTIRDBG),
		    %FI
			REP TIR$C_MAXSTOCOD-TIR$C_MINSTOCOD+1	! STORE COMMANDS
					OF WORD(STORECOMMAND-PROTIRDBG),
		%IF TIR$C_MINOPRCOD-TIR$C_MAXSTOCOD-1 NEQ 0
		    %THEN
			REP TIR$C_MINOPRCOD-TIR$C_MAXSTOCOD-1	! ILLEGAL COMMANDS
					OF WORD(REPORT_ILLTIR-PROTIRDBG),
		    %FI
			REP TIR$C_MAXOPRCOD-TIR$C_MINOPRCOD+1	! OPERATE COMMANDS
					OF WORD(OPERATECOMMAND-PROTIRDBG),
		%IF TIR$C_MINCTLCOD-TIR$C_MAXOPRCOD-1 NEQ 0
		    %THEN
			REP TIR$C_MINCTLCOD-TIR$C_MAXOPRCOD-1	! ILLEGAL COMMANDS
					OF WORD(REPORT_ILLTIR-PROTIRDBG),
		    %FI
			REP TIR$C_MAXCTLCOD-TIR$C_MINCTLCOD+1	! CONTROL COMMANDS
					OF WORD(CONTROLCOMMAND-PROTIRDBG)
			) : VECTOR[,WORD,SIGNED];

    PSECT PLIT = $PLIT$;

GLOBAL REGISTER
    COMMANDTYPE = 11 : BYTE,
    COMMANDATA = 10 : REF BLOCK[,BYTE],
    DATALNG = 9;

TIROFFSET = 1;						! START AT FIRST BYTE PAST RECORD TYPE CODE
ENDRECADDR = TIRREC[0] + .RECLNG;			! COMPUTE END ADDRESS + 1
WHILE .TIROFFSET LSSU .RECLNG
DO BEGIN
!
!	STEP THROUGH THE CONCATENATED SEQUENCE OF THE COMMANDS
!	IN THIS RECORD.
!
    IF (COMMANDTYPE = .TIRREC[.TIROFFSET]) GTRU 127
    THEN BEGIN
!
! COMMAND IS A STORE IMMEDIATE
!
	TIROFFSET = .TIROFFSET+1;					! POINT PAST THE BYTECOUNT
	DATALNG = 256 -.COMMANDTYPE;
	IF TIRREC[.TIROFFSET + .DATALNG] GTRU .ENDRECADDR		! CHECK THERE ARE ARE ENOUGH BYTES IN THE RECORD
	    THEN RETURN REPORT_TIRLNG();
	IF NOT LNK$WRTIMGBYTS(.DATALNG,TIRREC[.TIROFFSET],0)		! OTHERWISE WRITE THE STREAM
	    THEN RETURN FALSE;
	TIROFFSET = .TIROFFSET + .DATALNG;				! AND UPDATE THE OFFSET INTO THE RECORD
	END
    ELSE BEGIN
!
! COMMAND IS OTHER THAN STORE IMMEDIATE COMMAND
!
	COMMANDATA = TIRREC[.TIROFFSET+1];				! POINT TO DATA PART OF COMMAND
	DATALNG = 0;
	IF NOT (
	    IF .COMMANDTYPE GTRU TIR$C_MAXCTLCOD
		THEN REPORT_ILLTIR2()
		ELSE BEGIN
		    BIND ROUTINE
			RECORDPROCESSOR = .TIRDISPTABLE[.COMMANDTYPE] + PROTIRDBG : TIR_PROC;

		    RECORDPROCESSOR()
		    END
		)
		THEN RETURN FALSE
		ELSE TIROFFSET = .TIROFFSET + 1 + .DATALNG;
	END;
    END;

RETURN TRUE
END;

ROUTINE PROHDRS =
BEGIN
!
!	PROCESS HEADER RECORDS AS FOLLOWS:
!
!		IF HEADER TYPE 0 (MAIN MODULE HEADER) CALL THE MAP
!			ROUTINE THAT DESCRIBES A MODULE.
!
!		IF A LANGUAGE PROCESSOR HEADER TYPE, CALL THE MAP
!			ROUTINE THAT OUTPUTS THAT DATA.
!
!		IGNORE ALL OTHER SUB-TYPES.
!
IF NOT .OBMODESC[OMD$V_MAPMOD]				! IF MODULE NOT FLAGGED FOR MAP
    AND NOT .LNK$GL_CTLMSK[LNK$V_LONG]			! AND THIS IS NOT A FULL MAP
    THEN RETURN TRUE;					! FORGET IT
IF NOT .LNK$GL_CTLMSK[LNK$V_MAPOPN]			! ALSO FORGET IT IF
    THEN RETURN TRUE;					! MAP IS NOT OPEN
IF .OBJREC[OBJ$B_SUBTYP] EQL OBJ$C_HDR_MHD		! IF THIS IS MAIN HEADER
    THEN LNK$MAPMHD(.OBJREC,.OBMODESC)			! GO MAP SOME INFO
    ELSE IF .OBJREC[OBJ$B_SUBTYP] EQL OBJ$C_HDR_LNM	! OR IF THE COMPILER IDENTIFICATION
    THEN LNK$MAPLNG(OBJREC[OBJ$B_SUBTYP]+1,.RECLNG-2);	! HEADER GO MAP THAT DATA

RETURN TRUE						! RETURN SUCCESS
END;

GLOBAL ROUTINE LNK$OBJPASS2=
BEGIN
!
!	MAIN ROUTINE TO READ RECORDS SEQUENTIALLY FROM OBJECT
!	MODULE FILES AND DISPATCH ON RECORD TYPE
!
OWN
    TIRLOCN;								! SAVED LOCATION IN IMAGE BINARY
LOCAL
    AUXFNB : REF BLOCK[,BYTE];

STACKPOINTER = STK$C_SIZE;						! SET STACK POINTER
WHILE LNK$NXTOBJMOD()							! WHILE THERE IS ANOTHER OBJECT MODULE
DO BEGIN
    OBMODESC = .LNK$GL_CUROMD;
    LNK$GL_CUROMD[OMD$L_DLILST] = 0;					! CLEAR DEBUG LIST (USED DURING PASS 1)
    CH$FILL(0,LNK$C_NLITS/8,LNK$GL_LITFLGS);				! UNDEFINE ALL LITERALS
    STAPX = SHRIMGSYM = SHRSYMEXPR = 0;					! INITIALIZE DATA FOR SHR IMAGE CHECKING
    WHILE LNK$NXTREC(OBJRECDESC)					! READ THE NEXT RECORD
    DO BEGIN
	CASE .OBJREC[OBJ$B_RECTYP] FROM 0 TO OBJ$C_MAXRECTYP		! AND DISPATCH ON THE RECORD TYPE
	OF SET
!
! HEADER RECORDS
!
	    [OBJ$C_HDR] :
			BEGIN
			    PROHDRS();					!  PROCESS THE HEADERS
			    IF .OBJREC[OBJ$B_SUBTYP] EQL OBJ$C_HDR_LNM 	! IF THIS IS THE CREATOR IDENT RECORD
				AND .OBMODESC[OMD$V_NOBIN] 		!  OF A MODULE WITHOUT ANY BINARY
				THEN EXITLOOP;				!  THEN ALL DONE WITH MODULE
			    END;
!
! TIR RECORDS
!
	    [OBJ$C_TIR] :
			IF .LNK$GL_CTLMSK[LNK$V_IMAGE]			! IF THE IMAGE FILE IS STILL OPEN
			THEN BEGIN
			    LNK$GL_CTLMSK[LNK$V_DBGREC] = FALSE; 	! RESET POSSIBLE DBG
			    LNK$GL_LOCN = .TIRLOCN;			! RECORD FLAG AND LOCATION
			    PROTIRDBG();				! COUNTER AND PROCESS IT
			    TIRLOCN = .LNK$GL_LOCN;			! SAVE THE LOCATION COUNTER
			    END
			ELSE EXITLOOP;					! NO IMAGE FILE SO SKIP REST OF THIS MODULE
!
! DEBUG AND TRACEBACK RECORDS
!
	    [OBJ$C_DBG,OBJ$C_TBT] :
			BEGIN
			    IF NOT .LNK$GL_CTLMSK[LNK$V_IMAGE]		! IF NO IMAGE THEN QUIT NOW
				THEN EXITLOOP;
			    IF (.LNK$GL_CTLMSK[LNK$V_DBG]		! IF /DEBUG REQUESTED
				OR (.LNK$GL_CTLMSK[LNK$V_TRACE]		!  OR /TRACE REQUESTED
				AND (.OBJREC[OBJ$B_RECTYP] EQL OBJ$C_TBT))) ! AND THIS IS A TRACEBACK RECORD
				AND NOT .LNK$GL_CTLMSK[LNK$V_SYS]	! AND THIS IS NOT A SYSTEM IMAGE BEING MADE
!				AND NOT .LNK$GL_CTLMSK[LNK$V_SHR]	! AND THIS IS NOT A SHAREABLE IMAGE BEING MADE
				AND NOT .OBMODESC[OMD$V_DEBUGER]	! AND THIS IS NOT THE DEBUGGER MODULE
			    THEN BEGIN
				LNK$GL_CTLMSK[LNK$V_DBGREC] = TRUE;	! SET THE DEBUG CONTEXT FLAG
				LNK$GL_LOCN = .LNK$GL_DSTLOCN;		! AND LOCATION COUNTER
				PROTIRDBG();				! AND GO PROCESS IT
				LNK$GL_DSTLOCN = .LNK$GL_LOCN;		! SAVE UPDATED POINTER
				END;
			    END;
!
! END OF MODULE RECORDS
!
	    [OBJ$C_EOM,OBJ$C_EOMW] :
			    BEGIN
				IF .STACKPOINTER EQL STK$C_SIZE			! IF STACKS HAVE BEEN
				    THEN EXITLOOP;				! COLLAPSED ALL DONE
				SIGNAL(LIN$_EOMSTK,3,				! ELSE REPORT THAT STACK
					(STK$C_SIZE - .STACKPOINTER),		! STILL HAS ITEMS ON IT
					OBMODESC[OMD$B_NAMLNG],LNK$GL_CURFIL[FDB$Q_FILENAME]);
				STACKPOINTER = STK$C_SIZE;			! AND RESET IT
			      	END;
	    [INRANGE]   :
			TRUE;							! IGNORE OTHERS
	    [OUTRANGE]  :
			SIGNAL(LIN$_ILLRECTYP,4,				! ILLEGAL TYPES
				.OBJREC[OBJ$B_RECTYP],OBMODESC[OMD$B_NAMLNG],
				.LNK$GL_RECORD,LNK$GL_CURFIL[FDB$Q_FILENAME]);
	    TES
	END;								! END OF RECORD LOOP
    LNK$GL_CURISD = 0;
    END;									! END OF MODULES LOOP
LNK$GL_CURFIL = 0;
!
! LOOP THROUGH THE CLUSTERS AND CROSS REFERENCE ANY SYMBOLS THAT
! ARE ON THE SHR LST AND ARE RELOCATABLE (I.E. DID NOT GET BASED
! DURING PASS 2)
!
IF .LNK$GL_CTLMSK[LNK$V_MAPOPN]						! IF MAP FILE IS OPEN
    AND .LNK$GL_CTLMSK[LNK$V_LONG]
THEN BEGIN
    LOCAL
	CLUSTER : REF BLOCK[,BYTE],
	SYMBOL : REF BLOCK[,BYTE],
	SYMSNB : REF BLOCK[,BYTE];

    CLUSTER = LNK$GL_CLULST;						! POINT AT START OF LIST
    WHILE (CLUSTER = .CLUSTER[CLU$L_NXTCLU]) NEQ 0
    DO IF .CLUSTER[CLU$V_SHRIMG]					! IF CLUSTER IS NON-BASED SHR IMAGE
	AND NOT .CLUSTER[CLU$V_BASED]
    THEN BEGIN
	SYMBOL = .CLUSTER[CLU$L_SHRLST];
	WHILE .SYMBOL NEQ 0
	DO BEGIN
	    SYMSNB = .SYMBOL - .SYMBOL[SYM$B_NAMLNG] - SNB$C_FXDLEN;
	    IF .SYMBOL[SYM$V_CROSREF]					! IF SYMBOL WAS CROSS REFERENCED
		THEN CRF$INSRTREF(LNK$AL_VALCTLTB,SYMBOL[SYM$L_VALUE],	! THEN ENTER IN CREF BY VALUE TABLE
				SYMSNB[SNB$B_NAMLNG],.SYMBOL[SYM$W_FLAGS]);
	    SYMBOL = .SYMBOL[SYM$L_SHRLNK];				! LINK TO NEXT SYMBOL
	    END;
	END;
    END;
RETURN TRUE								! END OF PASS 2
END;
END ELUDOM
