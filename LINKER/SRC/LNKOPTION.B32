 MODULE LNK_PROCOPTIONS (
			IDENT='V03-019',
			ADDRESSING_MODE(EXTERNAL=GENERAL,
					NONEXTERNAL=LONG_RELATIVE)
			) =

BEGIN
%TITLE 'Linker options parser';
!
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
!
!
!
!++
!
! MODULE: LNK_PROCOPTIONS
!
! FACILITY: LINKER
!
! ABSTRACT: Options processing 
!
! HISTORY:
!
!	VERSION: V03-001
!
!	AUTHOR: B. Schreiber, 10-Jul-1980
!
! MODIFIED BY:
!
!	V03-019	BLS0162		Benn Schreiber		19-Mar-1982
!		SIGNAL_STOP if options read error. Warn if /SHARE=COPY
!		attempted.
!
!	V03-018	BLS0136		Benn Schreiber		18-Jan-1982
!		Insert cluster in cluster list if no files in cluster
!		option.
!
!	V03-017	BLS0119		Benn Schreiber		 8-Dec-1981
!		Allow periods in cluster names, symbol names, and
!		psect names also.
!
!	V03-016	BLS0113		Benn Schreiber		30-Nov-1981
!		Allow periods in included module names
!
!	V03-015	BLS0097		Benn Schreiber		 2-Nov-1981
!		Allow angle brackets in directory specs
!
!	V03-014	BLS0092		Benn Schreiber		29-Oct-1981
!		Treat blank lines as comment lines
!
!	V03-013	BLS0083		Benn Schreiber		20-Sep-1981
!		Ignore some options with a message if /SYSTEM
!
!	V03-012	BLS0082		Benn Schreiber		17-Sep-1981
!		Clean up descriptor passed to lib$put_output
!
!	V03-011	BLS0074		Benn Schreiber		29-Aug-1981
!		Modify cluster= option to set usrbased flag
!		rather than based flag
!
!	V03-010	BLS0068		Benn Schreiber		12-Aug-1981
!		Add shl_extra option
!
!	V03-009	BLS0049		Benn Schreiber		20-Mar-1981
!		Allow cluster=name,,,file/share and don't create new cluster
!		descriptor for shareable image.
!
!	V03-008	BLS0042		Benn Schreiber		14-Mar-1981
!		Bug fixes and flag if based by user option.
!
!	V03-007	BLS0040		Benn Schreiber		12-Feb-1981
!		Check max length of symbols, psects, etc.
!
!	V03-006	BLS0038		Benn Schreiber		31-Jan-1981
!		Store option file name and text in memory if /map/full
!
!	V03-005	BLS0023		Benn Schreiber		30-Oct-1980
!		Make /SHARE be /SHAREABLE.  Handle node name in file
!		name parsing.
!
!	V03-004	BLS0021		Benn Schreiber		 3-Oct-1980
!		Zero tpa$l_number in setclusterbase.
!
!	V03-003	BLS0002		Benn Schreiber		 1-Sep-1980
!		Set maximum symbol size when defining symbols.
!
!	V03-002	BLS0014		Benn Schreiber		29-Aug-1980
!		Don't call scanline for null lines, verify continuations.
!--

%SBTTL 'Declarations';
!
! Include files:
!
LIBRARY
    'LIBL32';					!System macros
LIBRARY
    'TPAMACL32';				!TPARSE macros
LIBRARY
    'DATBAS';					!Linker data structures
REQUIRE
    'PREFIX';					!Linker macros

FORWARD ROUTINE
    readoption,					!Read record from options file
    scanline,					!Collapse continuation lines
    set_base,					!Set image base
    set_channels,				!Set number of I/O channels
    insertcluster,				!Insert cluster in cluster list
    processfile,				!Process a file specification
    getfilename,				!Extract filename portion of file specification
    search_insert_symbol,			!Lookup/insert a symbol into symbol table
    crossref_symbol,				!Enter symbol into cross reference
    set_universal,				!Process universal symbols
    set_alluniv,				!Flag all globals to be universal
    definesymbolname,				!Process symbol name part of defining a symbol
    definesymbolval,				!Process value part of defining a symbol
    createpsect,				!Create a psect
    createcluster,				!Create a cluster
    setclusterbase,				!Set the base address of a cluster
    setclusterpfc,				!Set page fault factor for cluster
    clusterdone,				!Finish cluster option processing
    set_collect,				!Start collecting psects into clusters
    collect_psect,				!Collect a psect into a cluster
    set_gsmatch_ctl,				!Store match control part of GSMATCH option
    set_gsmatch_maj,				!Store major id of GSMATCH
    set_gsmatch_min,				!Store minor id of GSMATCH
    set_min_dzro,				!Store dzro_min option data
    set_isd_max,				!Store isd_max option data
    set_ioseg,					!Set size of I/O segment
    set_pscatrib,				!Set psect attributes
    set_p0bufs,					!Set/clear nop0bufs flag
    set_protect,				!Set protect flag
    set_shl,					!Set shl_extra option
    set_stack,					!Set stack option
    set_include,				!Set /include qualifier
    set_library,				!Set /library qualifier
    set_selective,				!Set /selective qualifier
    set_shareable,				!Set /shareable qualifier
    set_shrcopyflag,				!Set copy / nocopy flag for /shareable qualifier
    set_qual_flags,				!Set bits for qualifiers
    search_insert_list,				!Search linked list for name
    namelengthcheck,				!Check max length of name
    debug_stop,					!Stop to look at tparse tables
    missingargerr,				!Argument missing for option
    optionvaluerr,				!Value out of range error
    syntaxerr;					!Report syntax error
!
! External references
!
EXTERNAL ROUTINE
    crf$insrtref,				!Insert cross reference reference
    crf$insrtkey,				!Insert key into cross reference
    lib$insert_tree,				!Insert into balanced binary tree
    lib$lookup_tree,				!Lookup in balanced binary tree
    lnk$alloblk, 				!Allocate dynamic memory
    lnk$alloc_pdd,				!Allocate psect def. descriptor
    lnk$allocluster,				!Allocate a cluster descriptor
    lnk$compare_pdd,				!Compare names in psect def. descriptor
    lnk$clunamcmp,				!Compare cluster name routine
    lnk$insert_clu,				!Insert cluster into cluster tree
    lnk$dealblk, 				!Deallocate dynamic memory
    lnk$insudfsym,				!Insert a symbol into the undefined list
    lnk$insert,					!Insert a symbol into symbol table
    lnk$search,					!Search symbol table for symbol
    lnk$setlibrin,				!Set input file as a library
    lnk$setshrblin,				!Set input file as a shareable image
    lnk$upcase_d,				!Convert string to upper case
    lib$put_output,				!Write to SYS$OUTPUT
    lib$tparse,					!Table driver parser
    SYS$FAO;					!Formatted ASCII output

EXTERNAL
    lnk$gb_matchctl : BYTE,			!Global section match control
    lnk$gl_matchid : BBLOCK,			!Global section match
    lnk$gl_defclu : BBLOCK,			!Default cluster descriptor
    lnk$gl_curclu : REF BBLOCK,			!Pointer to current cluster descriptor
    lnk$gl_clutree,				!Tree head for cluster tree
    lnk$gl_ctlmsk : BBLOCK,			!Linker control flags
    lnk$gl_fvmlst : REF BBLOCK,			!Listhead of free VM
    lnk$gw_stack : WORD,			!Size of stack
    lnk$gt_pscstring,				!ASCIC string that says PSECT
    lnk$gt_clustring,				! or cluster
    lnk$gt_symstring,				! or string
    lnk$al_valctltb,				!Cref by value control table
    lnk$al_sytblfmt,				!Cref by symbol control table
    lnk$gl_maxsymsz,				!Maximum symbol name length
    lnk$gl_maxmodsz,				!Maximum module name length
    lnk$gw_ncrosrfs : WORD,			!Number of cross references
    lnk$gw_misects : WORD,			!Maximum number of isects
    lnk$gw_dzromin : WORD;			!Minimum demand zero number of pages

EXTERNAL LITERAL
    lin$_cmdtoolong,				!Command line too long
    lin$_confqual,				!Conflicting qualifiers
    lin$_crferr,				!Error from cross reference
    lin$_illnamelen,				!Illegal name length
    lin$_linerr,				!Command segment in error
    lin$_mulcluopt,				!Cluster multiply defined in options file
    lin$_optignshr,				!Option ignored in shareable image
    lin$_optignsys,				!Option ignored in system image
    lin$_optlin,				!Option line in error
    lin$_optsynerr,				!General syntax error
    lin$_optvalerr,				!Option value error
    lin$_optargmis,				!Argument missing for option
    lin$_premeof,				!Premature eof on options file
    lin$_readerr,				!Read error on file blah
    lin$_shrcpyign,				!/SHARE=COPY attempted
    lin$_shrinsys,				!Shareable image in system image
    lin$_shrsepclu;				!Shareable image requires seperate cluster
!
! Own storage
!
GLOBAL
    lnk$gl_defclunum,				!Default cluster number
    lnk$gl_optextp : REF BBLOCK,		!Listhead of option file text
    lnk$gl_optexte : REF BBLOCK INITIAL (lnk$gl_optextp), !Pointer to last text block
    lnk$gl_shlextra,				!Requested shl_extra
    lnk$gw_chans : WORD,			!Number of channels requested
    lnk$gw_ioseg : WORD,			!Size of i/o segment
    lnk$gq_privs : VECTOR [2] INITIAL (LONG (-1,-1)), !Requested privileges
    lnk$gl_cclulst : REF BBLOCK,		!List head for collect cluster list
    lnk$gl_pscdflst : REF BBLOCK;		!List head for psect definitions

GLOBAL LITERAL
    lnk$k_maxchans = 4095,			!Maximum number of channels
    lnk$k_maxstack = 65535,			!Maximum stack pages
    lnk$k_maxioseg = 65535,			!Maximum size of I/O segment
    lnk$k_maxisds = 65535,			!Maximum number of isects
    lnk$k_mindzro = 65535,			!Maximum min_dzro size
    lnk$k_maxmajid = 255,			!Maximum major ident
    lnk$k_maxminid = %X'FFFFFF',		!Maximum minor ident
    lnk$k_maxoptlin = 32767,			!Maximum size of option line
    lnk$k_maxpfc = 255;				!Maximum page fault cluster factor
OWN
    tparse_block : BBLOCK [tpa$k_length0]	!Tparse parameter block
			INITIAL (LONG (tpa$k_count0),
				LONG  (tpa$m_abbrfm)), !Abbreviate first match
    cmdbuffer,					!Address of command buffer
    optlinedesc : BBLOCK[dsc$c_s_bln],		!String descriptor of complete line
    fileflagsadr : REF BBLOCK,			!Address of caller's file flags
    clireqdesc : REF BBLOCK,			!Address of caller's cli request descriptor
    optrabadr : REF BBLOCK,			!Address of RAB for GET sequential
    curcollectdesc : REF BBLOCK,		!Address of current collect descriptor
    curpsectdesc : REF BBLOCK,			!Address of current psect descriptor
    cursymdesc : REF BBLOCK,			!Address of current symbol descriptor
    cursymsnb : REF BBLOCK,			!Address of current symbol name block
    filespec_desc : BBLOCK[dsc$c_s_bln],	!String descriptor for file specification
    include_desc : BBLOCK[dsc$c_s_bln],		!String descriptor for /include qualifier
    optionfilename : REF BBLOCK,		!Address of string descriptor for options file name
    quoteflag,					!True when inside double quotes
    cluoptflag,					!True if processing cluster option
    sharecopy,					!Set true if /share=copy
    protectflag;				!set true if clusters are to be protected

LITERAL
    sign_bit = %X'80000000',			!Mask for sign bit
    word_sign_bit = %X'8000',			!Sign bit of a word
    rh_mask = %X'FFFF';				!Mask for right half

BIND
    channels_name = CSTRING('Channel'),		!Name of option
    clusterpfc_name = CSTRING('Page fault cluster'),
    defined_by_option = CSTRING('<Linker option>'),
    optionfilestring = CSTRING('OPTION FILE'),
    dzromin_name = CSTRING('DZRO_MIN'),
    gsmatch_name = CSTRING('GSMATCH'),
    ioseg_name = CSTRING('IOSEG'),
    isdmax_name = CSTRING('ISD_MAX'),
    stack_name = CSTRING('Stack');


%SBTTL	'Options parser TPARSE table';
!
! Linker options command parsing table
!
$INIT_STATE (state_table, key_table);

!
! Parse Linker options
!
	$STATE(option,
		((parse_filelist),tpa$_exit),
		((base_option),tpa$_exit),
		((channels_option),tpa$_exit),
		((cluster_option),tpa$_exit),
		((collect_option),tpa$_exit),
		((dzro_min_option),tpa$_exit),
		((gsmatch_option),tpa$_exit),
		((iosegment_option),tpa$_exit),
		((isd_max_option),tpa$_exit),
		((protect_option),tpa$_exit),
		((psect_option),tpa$_exit),
		((shl_option),tpa$_exit),
		((stack_option),tpa$_exit),
		((symbol_option),tpa$_exit),
		((universal_option),tpa$_exit)
		);

!
! Parse BASE option
!
	$STATE	(base_option,
		('BASE'));
	$STATE	(,
		('=',baseop1));
	$STATE	(baseop1,
		((parse_number),baseop2,set_base),
		((errorparse_1)));
	$STATE	(baseop2,
		((endline_1),tpa$_exit));

!
! Parse CHANNELS option
!
	$STATE	(channels_option,
		('CHANNELS'));
	$STATE	(,
		('=',chanop1));
	$STATE	(chanop1,
		((parse_number),chanop2,set_channels),
		((errorparse_1)));
	$STATE	(chanop2,
		((endline_1),tpa$_exit));

!
! Parse CLUSTER option
!
	$STATE	(cluster_option,
		('CLUSTER'));
	$STATE	(,
		('='));
	$STATE	(,
		((get_symbol),cluop1,createcluster),	!Cluster name
		((errorparse_1)));
	$STATE	(cluop1,
		(tpa$_eos,cluop7a),			!If that's all, then that's ok
		(',',cluop2),
		((errorparse_1)));
	$STATE	(cluop2,
		(tpa$_eos,cluop7a),			!If that's all, then that's ok
		((parse_number_or_null),cluop3,setclusterbase),	!Cluster base address
		((errorparse_1)));
	$STATE	(cluop3,
		(tpa$_eos,cluop7a),			!If that's all, then that's ok
		(',',cluop4),
		((errorparse_1)));
	$STATE	(cluop4,
		(tpa$_eos,cluop7a),			!If that's all, then that's ok
		((parse_number_or_null),cluop5,setclusterpfc),	!Cluster page fault cluster factor
		((errorparse_1)));
	$STATE	(cluop5,
		(tpa$_eos,cluop7a),			!Allow null file list
		(',',cluop6),
		((errorparse_1)));
	$STATE	(cluop6,
		(tpa$_eos,cluop7a),			!Allow null file list
		((parse_filelist),cluop7),		!List of files in this cluster
		((errorparse_1)));
	$STATE	(cluop7,
		((endline_1),cluop8));
	$STATE	(cluop7a,				!No files in cluster option
		(tpa$_lambda,cluop8,insertcluster));
	$STATE	(cluop8,
		(tpa$_lambda,tpa$_exit,clusterdone));

!
! Parse COLLECT option
!
	$STATE	(collect_option,
		('COLLECT'));
	$STATE	(,
		('='));
	$STATE	(,
		((get_symbol),collop1,set_collect),	!Cluster name
		((errorparse_1)));
	$STATE	(collop1,
		(',',collop2),
		((errorparse_1)));
	$STATE	(collop2,
		((collect_psect_list),collop3),		! followed by a list of psects
		((errorparse_1)));
	$STATE	(collop3,
		((endline_1),tpa$_exit));
!
! Parse the psect list in the COLLECT option
!
	$STATE	(collect_psect_list,
		((get_symbol),colpsc1,collect_psect),	!Get a psect name
		((errorparse_1)));
	$STATE	(colpsc1,
		(',',collect_psect_list),
		(tpa$_eos,tpa$_exit),
		((errorparse_1)));

!
! Parse DZRO_MIN option
!
	$STATE	(dzro_min_option,
		('DZRO_MIN'));
	$STATE	(,
		('=',dzromin1));
	$STATE	(dzromin1,
		((parse_number),dzromin2,set_min_dzro),
		((errorparse_1)));
	$STATE	(dzromin2,
		((endline_1),tpa$_exit));

!
! Parse GSMATCH option
!
	$STATE	(gsmatch_option,
		('GSMATCH'));
	$STATE	(,
		('='));
	$STATE	(,
		((gsmatch_parse_control),gsmop1),	!GSMATCH control
		((errorparse_1)));
	$STATE	(gsmop1,
		(',',gsmop2),
		((errorparse_1)));
	$STATE	(gsmop2,
		((parse_number),gsmop3,set_gsmatch_maj),!Major id
		((errorparse_1)));
	$STATE	(gsmop3,
		(',',gsmop4),
		((errorparse_1)));
	$STATE	(gsmop4,
		((parse_number),gsmop5,set_gsmatch_min), !Minor id
		((errorparse_1)));
	$STATE	(gsmop5,
		((endline_1),tpa$_exit));

!
! Parse GSMATCH match control
!
	$STATE	(gsmatch_parse_control,
		('ALWAYS',tpa$_exit,set_gsmatch_ctl,,,isd$k_matall),
		('EQUAL',tpa$_exit,set_gsmatch_ctl,,,isd$k_matequ),
		('LEQUAL',tpa$_exit,set_gsmatch_ctl,,,isd$k_matleq),
		('NEVER',tpa$_exit,set_gsmatch_ctl,,,isd$k_matnev),
		((errorparse_1)));
!
! Parse IOSEGMENT option
!
	$STATE	(iosegment_option,
		('IOSEGMENT'));
	$STATE	(,
		('='));
	$STATE	(,
		((parse_number),iosegop1,set_ioseg),	!Number of buffers
		((errorparse_1)));
	$STATE	(iosegop1,
		(tpa$_eos,tpa$_exit),			!P0BUFS keyword is optional
		(',',iosegop2),
		((errorparse_1)));
	$STATE	(iosegop2,
		('P0BUFS',tpa$_exit,set_p0bufs,,,0),
		('NOP0BUFS',tpa$_exit,set_p0bufs,,,1),
		((errorparse_1)));

	

!
! Parse ISD_MAX option
!
	$STATE	(isd_max_option,
		('ISD_MAX'));
	$STATE	(,
		('='));
	$STATE	(,
		((parse_number),isdmaxop1,set_isd_max),
		((errorparse_1)));
	$STATE	(isdmaxop1,
		((endline_1),tpa$_exit));

!
! Parse PROTECT option
!
	$STATE	(protect_option,
		('PROTECT'));
	$STATE	(,
		('='));
	$STATE	(,
		('YES',protop1,set_protect,,,1),
		('NO',protop1,set_protect,,,0),
		((errorparse_1)));
	$STATE	(protop1,
		((endline_1),tpa$_exit));

!
! Parse PSECT option
!
	$STATE	(psect_option,
		('PSECT_ATTRIBUTES'));
	$STATE	(,
		('='));
	$STATE	(,
		((get_symbol),pscop1,createpsect),	!Psect name
		((errorparse_1)));
	$STATE	(pscop1,
		(',',pscop2),
		((errorparse_1)));
	$STATE	(pscop2,
		((psect_parse_attribute),pscop3));	!Followed by a list of attributes
	$STATE	(pscop3,
		(',',pscop2),				! separated by commas
		(tpa$_eos,tpa$_exit),			!Quit at end of line
		((errorparse_1)));

!
! Parse PSECT option attributes
!
	$STATE	(psect_parse_attribute,

		('ABS',tpa$_exit,set_pscatrib,,,((NOT gps$m_rel) AND rh_mask)),
		('REL,',tpa$_exit,set_pscatrib,,,gps$m_rel),

		('CON',tpa$_exit,set_pscatrib,,,((NOT gps$m_ovr) AND rh_mask)),
		('OVR',tpa$_exit,set_pscatrib,,,gps$m_ovr),

		('EXE',tpa$_exit,set_pscatrib,,,(gps$m_exe OR gps$m_rd)),
		('NOEXE',tpa$_exit,set_pscatrib,,,((NOT gps$m_exe) AND rh_mask)),

		('GBL',tpa$_exit,set_pscatrib,,,gps$m_gbl),
		('LCL',tpa$_exit,set_pscatrib,,,((NOT gps$m_gbl) AND rh_mask)),

		('LIB',tpa$_exit,set_pscatrib,,,gps$m_lib),
		('USR',tpa$_exit,set_pscatrib,,,((NOT gps$m_lib) AND rh_mask)),

		('PIC',tpa$_exit,set_pscatrib,,,gps$m_pic),
		('NOPIC',tpa$_exit,set_pscatrib,,,((NOT gps$m_pic) AND rh_mask)),

		('RD',tpa$_exit,set_pscatrib,,,gps$m_rd),
		('NORD',tpa$_exit,set_pscatrib,,,((NOT gps$m_rd) AND rh_mask)),

		('SHR',tpa$_exit,set_pscatrib,,,gps$m_shr),
		('NOSHR',tpa$_exit,set_pscatrib,,,((NOT gps$m_shr) AND rh_mask)),

		('WRT',tpa$_exit,set_pscatrib,,,(gps$m_rd OR gps$m_wrt)),
		('NOWRT',tpa$_exit,set_pscatrib,,,((NOT gps$m_wrt) AND rh_mask)),

		('VEC',tpa$_exit,set_pscatrib,,,gps$m_vec),
		('NOVEC',tpa$_exit,set_pscatrib,,,((NOT gps$m_vec) AND rh_mask)),

		('BYTE',tpa$_exit,set_pscatrib,,,(0 OR sign_bit)),
		('WORD',tpa$_exit,set_pscatrib,,,(1 OR sign_bit)),
		('LONG',tpa$_exit,set_pscatrib,,,(2 OR sign_bit)),
		('QUAD',tpa$_exit,set_pscatrib,,,(3 OR sign_bit)),
		('PAGE',tpa$_exit,set_pscatrib,,,(9 OR sign_bit)),
!
! Allow alignment to be specified numerically also
!
		('0',tpa$_exit,set_pscatrib,,,(0 OR sign_bit)),
		('1',tpa$_exit,set_pscatrib,,,(1 OR sign_bit)),
		('2',tpa$_exit,set_pscatrib,,,(2 OR sign_bit)),
		('3',tpa$_exit,set_pscatrib,,,(3 OR sign_bit)),
		('9',tpa$_exit,set_pscatrib,,,(9 OR sign_bit)),

		((errorparse_1)));
!
! Parse SHL_EXTRA option
!
	$STATE	(shl_option,
		('SHL_EXTRA'));
	$STATE	(,
		('='));
	$STATE	(,
		((parse_number),shl1,set_shl),
		((errorparse_1)));
	$STATE	(shl1,
		((endline_1),tpa$_exit));
!
! Parse STACK option
!
	$STATE	(stack_option,
		('STACK'));
	$STATE	(,
		('='));
	$STATE	(,
		((parse_number),stackop1,set_stack),
		((errorparse_1)));
	$STATE	(stackop1,
		((endline_1),tpa$_exit));

!
! Parse SYMBOL option
!
	$STATE	(symbol_option,
		('SYMBOL'));
	$STATE	(,
		('='));
	$STATE	(,
		((get_symbol),symbolop1,definesymbolname),!Symbol name
		((errorparse_1)));
	$STATE	(symbolop1,
		(',',symbolop2),
		((errorparse_1)));
	$STATE	(symbolop2,
		((parse_number),symbolop3,definesymbolval),! and symbol value
		((errorparse_1)));
	$STATE	(symbolop3,
		((endline_1),tpa$_exit));

!
! Parse UNIVERSAL option
!
	$STATE	(universal_option,
		('UNIVERSAL'));
	$STATE	(,
		('='));
	$STATE	(,
		((parse_univ_symbols),tpa$_exit));	!List of symbols to universalize
!
! Parse the symbols in the UNIVERSAL option
!
	$STATE	(parse_univ_symbols,
		('*',prsuniv2),				!Maybe want all symbols?
		((get_symbol),prsuniv1,set_universal),
		((errorparse_1)));
	$STATE	(prsuniv1,
		(',',parse_univ_symbols),
		(tpa$_eos,tpa$_exit),			!Quit at end of string
		((errorparse_1)));
	$STATE	(prsuniv2,
		(tpa$_eos,prsuniv3),
		((errorparse_1)));
	$STATE	(prsuniv3,
		(tpa$_lambda,tpa$_exit,set_alluniv));	!Flag all symbols as universal
!
! Parse a comma-separated file list
!
	$STATE	(parse_filelist,
		((filespec),parsefl1,,,filespec_desc));	!Do a file specification
	$STATE	(parsefl1,
		('_',tpa$_fail),			!Return failure if underscore, that is part of option
							!  syntax.
		('=',tpa$_fail),			!Return failure if it looks like an option
		(',',parse_filelist,processfile),	!Process comma-separated list
		('/',parsefl2),				!Process qualifiers
		(tpa$_eos,tpa$_exit,processfile),	!Quit at end
		((errorparse_1)));
	$STATE	(parsefl2,
		((include_qual),parsefl3,set_include,,,(fdb$m_shr OR fdb$m_option OR fdb$m_selser)),
		('LIBRARY',parsefl3,set_library,,,(fdb$m_shr OR fdb$m_option OR fdb$m_selser)),
		('SELECTIVE_SEARCH',parsefl3,set_selective,,,(fdb$m_option OR fdb$m_libr)),
		((share_qual),parsefl3,set_shareable,,,(fdb$m_libr)),
		((errorparse_1)));
	$STATE	(parsefl3,
		('/',parsefl2),				!Process all qualifiers
		(tpa$_lambda,parsefl4));
	$STATE	(parsefl4,
		(',',parse_filelist,processfile),	!Comma means more files
		(tpa$_eos,tpa$_exit,processfile),	!Exit at end of string
		((errorparse_1)));
!
! Detect and check general file specification
!
	$STATE	(filespec,				! General file spec check
		((nodespec),fil0),
		(tpa$_lambda,fil0));
	$STATE	(fil0,
		((devname),fil1),
		(tpa$_lambda,fil1));
	$STATE	(fil1,
		((direct),fil2),
		(tpa$_lambda,fil2));
	$STATE	(fil2,
		(tpa$_symbol));
	$STATE	(,					!
		((type),fil3),				! Check for type and version
		(tpa$_lambda,fil3));			!
	$STATE	(fil3,					!
		((version),tpa$_exit),			!
		(tpa$_lambda,tpa$_exit));

!
! Recognize node name (with optional access string)
!
	$STATE	(nodespec,
		((node1),node0));			! Get the first node spec
	$STATE	(node0,					! Then try to get more
		((node1),node0),			!  try for one
		(tpa$_lambda,tpa$_exit));		!  but if we don't get one, the exit successfully with the one
	$STATE	(node1,
		(tpa$_symbol));
	$STATE	(,
		(':',node3),
		('"'));					! Check for access control
	$STATE	(node2,
		('"',node4),				! Look for end of access control
		(tpa$_eos,tpa$_fail),
		(':',tpa$_fail),
		(tpa$_any,node2));
	$STATE	(node3,
		(':',tpa$_exit));			! Second colon delimiting node spec
	$STATE	(node4,
		(':',node3));				! Must terminate the node spec.
!
! Recognize device name
!
	$STATE	(devname,
		(tpa$_symbol));				!
	$STATE	(,					!
		(':',tpa$_exit));			!


!
! Recognize directory 
!
	$STATE	(direct,
		('<'),
		('['));
	$STATE	(,					!
		((ufd),dir2),				! Check for uic directory name
		((dirsub)));				!
	$STATE	(dir2,					!
		('>',tpa$_exit),
		(']',tpa$_exit));			!
!
! Recognize string directories and subdirectories
!
	$STATE	(dirsub,				!
		(tpa$_string,dirsub1),			!
		('-',dirsub1),				! Allow [-]
		(tpa$_lambda));				! Allow [.sub.sub]
	$STATE	(dirsub1,				!
		('.',dirsub),				! Loop for another directory name
		(tpa$_lambda,tpa$_exit));

!
! Recognize ufd directory format
!
	$STATE	(ufd,					!
		(tpa$_octal));				!
	$STATE	(,					!
		(','));
	$STATE	(,					!
		(tpa$_octal,tpa$_exit));		!

!
! Recognize file type
!
	$STATE	(type,					!
		('.'));					!
	$STATE	(,					!
		(tpa$_string,tpa$_exit),		!
		(tpa$_blank,tpa$_exit),			!
		(tpa$_lambda,tpa$_exit));

!
! Recognize file version
!
	$STATE	(version,				!
		(';'));					!
	$STATE	(,					!
		(tpa$_decimal,tpa$_exit),		!
		(tpa$_blank,tpa$_exit),			!
		(tpa$_lambda,tpa$_exit));

!
! Parse a number or a null field
!
	$STATE	(parse_number_or_null,
		((parse_number),tpa$_exit),		!All ok if number
		(tpa$_lambda,tpa$_exit));		! or else nothing
!
! Recognize number
!
	$STATE	(parse_number,				!
		(tpa$_decimal,tpa$_exit),		! Decimal number
		('%'));					! Base prefix
	$STATE	(,					!
		('D',decnum),				! Decimal base designator
		('X',hexnum),				! Hex base designator
		('O'));					! Octal number
	$STATE	(,					! 
		(tpa$_octal,tpa$_exit));		! Introduced octal number
	$STATE	(hexnum,				! Introduced hex number
		(tpa$_hex,tpa$_exit));			! Hex number
	$STATE	(decnum,				! Introduced decimal number
		(tpa$_decimal,tpa$_exit));

!
! Parse INCLUDE qualifier
!
	$STATE	(include_qual,
		('INCLUDE'));					!Include
	$STATE	(,
		((qualvalsep),incl1),				!Followed by '=' or ':'
		((errorparse_1)));				! or its an error
	$STATE	(incl1,
		('(',include_list),				!If a left parens
		((get_symbol),tpa$_exit,,,include_desc),	! or a symbol then ok
		((errorparse_1)));				! otherwise an error

!
!   Parse a list of symbols enclosed in parens
!
	$STATE	(include_list,
		((parse_include_list),incl2,,,include_desc));	!Call the routine and store the descriptor
	$STATE	(incl2,
		(')',tpa$_exit),				!Followed by a right parens
		((errorparse_1)));				! or a syntax error
	$STATE	(parse_include_list,
		((get_symbol),incl3),				!Get one symbol
		((errorparse_1)));				! or an error
	$STATE	(incl3,
		(',',parse_include_list),			!Go for more if a comma
		(tpa$_lambda,tpa$_exit));			!otherwise return
!
! Parse /SHARE qualifier
!
	$STATE	(share_qual,
		('SHAREABLE',,set_shrcopyflag,,,0));		!Zero flag
	$STATE	(,
		((qualvalsep),parseshareval),
		(tpa$_lambda,tpa$_exit));
	$STATE	(parseshareval,
		('COPY',tpa$_exit,set_shrcopyflag,,,1),
		('NOCOPY',tpa$_exit,set_shrcopyflag,,,0),
		((errorparse_1)));
!
! Parse a symbol, which may include periods (.MAIN.)
!
	$STATE	(get_symbol,
		('.',getsym1),				!Make sure we get at least one character
		(tpa$_symbol,getsym1),
		(tpa$_lambda,tpa$_fail));		!Fail if not at least one character

	$STATE	(getsym1,
		('.',getsym1),
		(tpa$_symbol,getsym1),
		(tpa$_lambda,tpa$_exit));
!
! Check qualifier and value separator
!
	$STATE	(qualvalsep,
		(':',tpa$_exit),
		('=',tpa$_exit));
!
! Try to parse something and then call the error routine
!
	$STATE	(errorparse_1,
		(tpa$_eos,,missingargerr),
		(tpa$_symbol,,syntaxerr),
		(tpa$_string,,syntaxerr),
		(tpa$_any,,syntaxerr),
		(tpa$_lambda,,syntaxerr));
!
! Check end of line conditions
!
	$STATE	(endline_1,
		(tpa$_eos,tpa$_exit),		!End of string is a good exit
		(tpa$_symbol,,syntaxerr),	!Else try to get a symbol
		(tpa$_string,,syntaxerr),	!Else try to get a string
		(tpa$_any,,syntaxerr));		! or anything to flag as error



%SBTTL	'readoption - Read record from options file';
ROUTINE readoption (linedesc, errorsignal) =
BEGIN
!
! This routine reads and returns to the caller in linedesc the
! next record of the options file.  If end of file is detected, then
! one of two things can happen.  If the errorsignal argument is
! supplied, then the error is signaled.  If it is not supplied,
! rms$_eof is returned to the caller.
!
MAP
    linedesc : REF BBLOCK;

BUILTIN
    NULLPARAMETER;

LOCAL
    status,
    blocksize,
    blockaddr : REF BBLOCK;

status = $GET(RAB=.optrabadr);					!Read the record
linedesc[dsc$w_length] = .optrabadr[rab$w_rsz];			!Return it to caller
linedesc[dsc$a_pointer] = .optrabadr[rab$l_rbf];
IF .status							!If a successful read
THEN BEGIN
    IF .lnk$gl_ctlmsk[lnk$v_verify]				!Echo line if SET VERIFY
	THEN lib$put_output(.linedesc);
    IF .lnk$gl_ctlmsk[lnk$v_long]				!If we are generating a full map
    THEN BEGIN							! then copy option line to va
	blocksize = oeb$c_size + .linedesc[dsc$w_length];	!Figure size of block to allocate
	lnk$alloblk(.blocksize,blockaddr);			!Allocate it
	blockaddr[oeb$l_nxtoeb] = 0;
	blockaddr[oeb$w_bytcnt] = .linedesc[dsc$w_length];	!Set size of line into descriptor
	CH$MOVE(.linedesc[dsc$w_length],.linedesc[dsc$a_pointer], ! and copy out the text
		blockaddr[oeb$t_text]);
	lnk$gl_optexte[oeb$l_nxtoeb] = .blockaddr;		!Link the block into the end of the list
	lnk$gl_optexte = .blockaddr;				! and make it the last one
	END;

    END
ELSE BEGIN
    !
    ! An error occurred on the read
    !
    IF .status EQL rms$_eof					!If this is end of file
    THEN BEGIN
	IF NOT NULLPARAMETER(2)					! and signal code supplied
	    THEN SIGNAL(.errorsignal,1,.optionfilename,		! then signal it (eof not expected)
				.status,.optrabadr[rab$l_stv]);
	END
    ELSE SIGNAL_STOP(lin$_readerr,1,.optionfilename,		!Not eof, signal the read error and give up
				.status,.optrabadr[rab$l_stv]);
    END;

RETURN .status

END;

%SBTTL	'LNK$PROCOPTNS -- Entry point to options parsing';
GLOBAL ROUTINE lnk$procoptns (requestdesc, optfilename, fileflags, optionrab) =
BEGIN
!
! This routine parses the options file
!
! Inputs:
!
!	requestdesc	The address of the cli request descriptor for primary input files
!	optfilename	The address of the string descriptor for the options file
!	fileflags	Address of file control flags
!	optionrab	Address of the RAB connected for GET sequential
!
! Outputs:
!
!	Linker data structures created according to inputs found in options file.
!--
MAP
    requestdesc : REF BBLOCK,
    optfilename : REF BBLOCK,
    fileflags : REF BBLOCK,
    optionrab : REF BBLOCK;

LOCAL
    blockaddr : REF BBLOCK,
    blocksize,
    linedesc : BBLOCK[dsc$c_s_bln],
    commentline,
    rmsstatus;

clireqdesc = .requestdesc;				!Put request descriptor address into own storage
fileflagsadr = .fileflags;				!Put file flags address into own storage
optrabadr = .optionrab;					!Put RAB address in own storage
optionfilename = .optfilename;				!Put string descriptor address into own storage
CH$FILL(0,dsc$c_s_bln,linedesc);			!Clear out the descriptor
!
! Copy option file name out to the option text list
!
IF .lnk$gl_ctlmsk[lnk$v_long]				!If creating a long map
THEN BEGIN
    blocksize = oeb$c_size + .optionfilename[dsc$w_length] + 2;!Figure size of block to allocate
    lnk$alloblk(.blocksize,blockaddr);			!Allocate it
    blockaddr[oeb$l_nxtoeb] = 0;
    blockaddr[oeb$w_bytcnt] = .optionfilename[dsc$w_length]+2;!Set size of line into descriptor
    BEGIN
	BIND
	    filenamestring = blockaddr[oeb$t_text] : VECTOR[,BYTE];

	filenamestring[0] = %ASCII '<';
	CH$MOVE(.optionfilename[dsc$w_length],		!Copy the filename out
		.optionfilename[dsc$a_pointer],filenamestring[1]);
	filenamestring[.optionfilename[dsc$w_length]+1] = %ASCII '>';
	END;
    lnk$gl_optexte[oeb$l_nxtoeb] = .blockaddr;		!Link the block into the end of the list
    lnk$gl_optexte = .blockaddr;				! and make it the last one
    END;
!
! Allocate a buffer.  This buffer will be used to pack continuation lines into one continuous line
!
lnk$alloblk(lnk$k_maxoptlin,cmdbuffer);
!
! Loop, reading and parsing commands until end of file
!
WHILE (rmsstatus = readoption(linedesc)) NEQ rms$_eof
DO BEGIN
    tparse_block[tpa$l_stringcnt] = 0;			!Zero line length
    tparse_block[tpa$l_stringptr] = .cmdbuffer;		!Point TPARSE to the buffer
    quoteflag = false;					!Not inside double quotes
    cluoptflag = false;					!Not processing cluster option
    IF .linedesc[dsc$w_length] NEQ 0			!If line is not null
        THEN scanline(linedesc,commentline);		! scan the line and store in the buffer
    IF .tparse_block[tpa$l_stringcnt] NEQ 0
    THEN BEGIN
	CH$MOVE(dsc$c_s_bln,tparse_block[tpa$l_stringcnt],!Make a copy of the options line descriptor
			optlinedesc);
	lnk$upcase_d(tparse_block[tpa$l_stringcnt]);	!Convert string to upper case
!
! Parse the command line
!
	IF NOT lib$tparse(tparse_block,state_table,key_table)
		THEN syntaxerr ();
!
! Reset current cluster to default cluster at end of each options line
!
	lnk$gl_curclu = lnk$gl_defclu;
	END;

    END;
!
! Deallocate the buffer
!
lnk$dealblk(lnk$k_maxoptlin,.cmdbuffer);

RETURN true
END;							!Of lnk$procoptns

%SBTTL	'Form complete options line, handling continuations';
ROUTINE scanline (indesc, commentline) =
BEGIN
!
! This routine scans a line and handles continuations.
!
! Inputs:
!
!	indesc	address of string descriptor for input line
!
! Outputs:
!
!	tparse_block[tpa$l_stringcnt] set to count of characters in .cmdbuffer
!	commentline	set true if line was a comment line (used in recursive
!			internal calls only)
!
!	Blanks and tabs are stripped from line, continuation lines processed.
!---

!
! Routine to store a character into the buffer
!
ROUTINE storecharacter (cchar) =
BEGIN

IF .tparse_block[tpa$l_stringcnt] EQL lnk$k_maxoptlin-1
    THEN SIGNAL_STOP(lin$_cmdtoolong,1,.optionfilename);

IF (.cchar NEQ %C' ' AND .cchar NEQ %C'	')		!If character is not space or tab
    OR .quoteflag					! or we are inside double quotes
THEN BEGIN
    BIND charvector = .tparse_block[tpa$l_stringptr]
			+ .tparse_block[tpa$l_stringcnt] : VECTOR[,BYTE];

    charvector[0] = .cchar;				!Store the character
    tparse_block[tpa$l_stringcnt] = .tparse_block[tpa$l_stringcnt] + 1;
    IF .cchar EQL %C'"'					!If double quote, then toggle the quote flag
	THEN quoteflag = NOT .quoteflag;
    END;

RETURN true
END;							!of storecharacter

!
! Main body of scanline
!

MAP
    indesc : REF BBLOCK;

LOCAL
    rmsstatus,
    stringstart,
    cchar : BYTE,
    tempdesc : BBLOCK[dsc$c_s_bln];

IF .indesc[dsc$w_length] EQL 0
    THEN RETURN (.commentline = true);

CH$FILL(0,dsc$c_s_bln,tempdesc);			! Clear descriptor
stringstart = .tparse_block[tpa$l_stringcnt];

!
! Copy the line into the command buffer a character at a time, watching for
! continuation lines and comments.
!

INCRU i FROM 0 TO .indesc[dsc$w_length]-1
DO BEGIN
    BIND
        linebuffer = .indesc[dsc$a_pointer] : VECTOR[,BYTE];

    IF (cchar = .linebuffer[.i]) EQL %ASCII '!'		!If character is comment character
	    THEN EXITLOOP (.commentline = true);	!  then done with line
    IF .cchar EQL %ASCII '-'				!If character is a possible continuation character
    THEN BEGIN						!  then check it out
	IF .i EQL .indesc[dsc$w_length]-1		!Are we on the last character?
	    OR BEGIN					!  or is everything following it blank or a comment?
		LOCAL
		    status;

		status = true;
		INCRU j FROM .i+1 TO .indesc[dsc$w_length]-1
			DO IF .linebuffer[.j] EQL %ASCII '!'	!It's a continuation if comment follows
			    THEN EXITLOOP (.commentline = status = true)
			    ELSE IF .linebuffer[.j] NEQ %ASCII ' '	! but not if it's not a space
				AND .linebuffer[.j] NEQ %ASCII '	' ! or tab
				THEN EXITLOOP (.commentline = status = false);
		.status
		END
	    !
	    ! It is a continuation line
	    !
	    THEN WHILE true
		DO BEGIN
		rmsstatus = readoption(tempdesc,lin$_premeof); !Read next line
		scanline(tempdesc,.commentline);	!Scan the line
		IF NOT ..commentline			!If we did not just
		    THEN RETURN true;			! scan a comment then done
		END
	    !
	    ! Not a continuation line
	    !
	    ELSE storecharacter(.cchar);
	    END
    ELSE storecharacter(.cchar);
    END;

IF ..commentline					!If we just scanned a comment line
    AND (.tparse_block[tpa$l_stringcnt] EQL .stringstart) ! with nothing else on it
    THEN RETURN (.commentline = true)
    ELSE BEGIN
	.commentline = false;
	RETURN true
	END;
END;

%SBTTL	'TPARSE action routines';
ROUTINE set_base =
BEGIN
!---
!
! This routine is called by TPARSE to process the BASE= option
!
! Inputs:
!
!	AP			Points to tparse_block
!	AP[tpa$l_number]	base as specified by user
!
! Outputs:
!
!	Base stored in clu$l_base of the default cluster
!
!---
BUILTIN
    AP;

MAP
    AP : REF BBLOCK;

IF .lnk$gl_ctlmsk[lnk$v_sys]
THEN BEGIN
    SIGNAL(lin$_optignsys);
    RETURN true
    END;
lnk$gl_defclu[clu$l_base] = (.AP[tpa$l_number]		!Get value and round up
				+ 511) AND NOT 511;	! to a page boundary
lnk$gl_defclu[clu$v_based] = true;			!Flag cluster is based
!lnk$gl_defclu[clu$v_usrbased] = true;			! by user (not currently need for object clusters)
lnk$gl_ctlmsk[lnk$v_ubased] = true;			!Flag image based by user

RETURN true
END;							!Of set_base

ROUTINE set_channels =
BEGIN
!---
!
! This routine is called by TPARSE to process the CHANNELS= option
!
! Inputs:
!
!	AP			Points to tparse_block
!	AP[tpa$l_number]	Number of channels as specified in options file
!
! Outputs:
!
!	lnk$gw_chans		set up
!
!---
BUILTIN
    AP;

MAP
    AP : REF BBLOCK;

IF (lnk$gw_chans = .AP[tpa$l_number]) GTRU lnk$k_maxchans
    OR .AP[tpa$l_number] EQL 0
    THEN optionvaluerr(channels_name,.AP,1,lnk$k_maxchans);

RETURN true
END;							!Of set_channels

ROUTINE createcluster =
BEGIN
!---
!
! This routine is called by TPARSE to create the cluster descriptor
! after the option has been parsed
!
! Inputs:
!
!	AP			Points to tparse_block
!	AP[tpa$l_tokencnt]	String descriptor for cluster name
!
! Outputs:
!
!	New cluster descriptor allocated, cluster name set into descriptor.
!
!	lnk$gl_curclu		Pointer to new cluster descriptor
!	AP[tpa$l_number]	Zeroed
!
!---
BUILTIN
    AP;

MAP
    AP : REF BBLOCK;

namelengthcheck(AP[tpa$l_tokencnt],lnk$gt_clustring);	!Check length of cluster name
lnk$allocluster(lnk$gl_curclu);				!Allocate cluster descriptor
cluoptflag = true;					!Flag processing a cluster option
!
! Move in the cluster name.  Don't call LNK$INSERT_CLU here because the file specified
! may contain the /SHARE qualifier.  The cluster will be inserted in processfile
!
CH$MOVE ((lnk$gl_curclu[clu$b_namlng] = .AP[tpa$l_tokencnt]),
		.AP[tpa$l_tokenptr],lnk$gl_curclu[clu$t_name]);
lnk$gl_curclu[clu$v_protect] = .protectflag;		!Set protect flag as requested
AP[tpa$l_number] = 0;					!Preset base to 0
RETURN true
END;							!Of createcluster
ROUTINE setclusterbase =
BEGIN
!---
!
! This routine is called by TPARSE when the base field of the cluster option is parsed
!
! Inputs:
!
!	AP			pointer to tparse_block
!	AP[tpa$l_number]	Base as specified in option
!	AP[tpa$l_tokencnt]	Size of token just parsed (i.e. non-zero if base specified)
!
! Outputs:
!
!	Cluster base and based flag set (iff base specified) for current cluster
!
!---
BUILTIN
    AP;

MAP
    AP : REF BBLOCK;

lnk$gl_curclu[clu$l_usrbase] = (.AP[tpa$l_number] + 511)!Set cluster base
				AND NOT 511;		! rounded up to page boundary
lnk$gl_curclu[clu$v_usrbased] = (.AP[tpa$l_tokencnt] NEQ 0); !If number present,then cluster is based
lnk$gl_ctlmsk[lnk$v_ubased] = .lnk$gl_ctlmsk[lnk$v_ubased] ! set if based by user
					OR .lnk$gl_curclu[clu$v_usrbased];
AP[tpa$l_number] = 0;					!Zero in case pfc defaulted

RETURN true
END;							!Of setclusterbase
ROUTINE setclusterpfc =
BEGIN
!---
!
! This routine is called by TPARSE to store the pfc in the cluster descriptor
!
! Inputs:
!
!	AP			Pointer to tparse_block
!	AP[tpa$l_number]	Cluster page fault cluster factor
!
! Outputs:
!
!	pfc field set in current cluster
!
!---
BUILTIN
    AP;

MAP
    AP : REF BBLOCK;

IF (lnk$gl_curclu[clu$b_pfc] = .AP[tpa$l_number]) GTRU lnk$k_maxpfc
    THEN optionvaluerr(clusterpfc_name,.AP,0,lnk$k_maxpfc);

RETURN true
END;							!Of set clusterpfc
ROUTINE clusterdone =
BEGIN
!
! This routine finishes cluster option processing
!
IF NOT .lnk$gl_curclu[clu$v_shrimg]			!If not a shareable image cluster
    AND .lnk$gl_curclu[clu$v_usrbased]			! and it was based by user
THEN BEGIN
    lnk$gl_curclu[clu$l_base] = .lnk$gl_curclu[clu$l_usrbase]; !Set cluster base
    lnk$gl_curclu[clu$l_usrbase] = 0;			!Clear usrbase
    lnk$gl_curclu[clu$v_based] = true;			!Flag cluster as based
    END;

RETURN true
END;

ROUTINE set_collect = 
BEGIN
!---
!
! This routine is called by TPARSE when the cluster name field of the COLLECT option is parsed
!
! Inputs:
!
!	AP			Pointer to tparse_block
!	AP[tpa$l_tokencnt]	string descriptor for cluster name
!
! Outputs:
!
!	currcollectdesc		Pointer to allocated collect descriptor
!
!---
BUILTIN
    AP;

MAP
    AP : REF BBLOCK;

namelengthcheck(AP[tpa$l_tokencnt],lnk$gt_clustring);			!Check cluster name length
search_insert_list(lnk$gl_cclulst,AP[tpa$l_tokencnt],			!Insert / lookup the cluster in the cluster collect list
				ccd$c_size,curcollectdesc);
curcollectdesc[ccd$b_protect] = .protectflag;				!Propogate the cluster protected flag

RETURN true
END;									!Of set_colect
ROUTINE collect_psect =
BEGIN
!---
!
! This routine is called by TPARSE for each psect in the COLLECT option
!
! Inputs:
!
!	AP			Pointer to tparse_block
!	AP[tpa$l_tokencnt]	String descriptor for psect name
!
! Outputs:
!
!	Psect name block hung off of currcollectdesc in name order.
!
!---
BUILTIN
    AP;

MAP
    AP : REF BBLOCK;

LOCAL
    scratchptr;

namelengthcheck(AP[tpa$l_tokencnt],lnk$gt_pscstring);			!Check psect name length
search_insert_list(curcollectdesc[ccd$l_psclst],AP[tpa$l_tokencnt],	!Lookup/insert psect into list for cluster
			cpd$c_size,scratchptr);

RETURN true
END;								!Of collect_psect

ROUTINE set_min_dzro =
BEGIN
!
! This routine is called by TPARSE to set the DZRO_MIN= option
!
BUILTIN
    AP;

MAP
    AP : REF BBLOCK;

IF (lnk$gw_dzromin = .AP[tpa$l_number]) GTRU lnk$k_mindzro
    THEN optionvaluerr(dzromin_name,.AP,0,lnk$k_mindzro);

IF .lnk$gl_ctlmsk[lnk$v_shr]
    THEN SIGNAL(lin$_optignshr);

IF .lnk$gl_ctlmsk[lnk$v_sys]
    THEN SIGNAL(lin$_optignsys);

RETURN true
END;							!Of set_min_dzro

ROUTINE set_gsmatch_ctl =
BEGIN
!
! This routine is called by TPARSE when the match control field of the GSMATCH option is processed
!
BUILTIN
    AP;

MAP
    AP : REF BBLOCK;

lnk$gb_matchctl = .AP[tpa$l_param];			!Match control is passed as a parameter
AP[tpa$l_number] = 0;					!Preset GSMATCH

RETURN true
END;							!Of set_gsmatch_ctl
ROUTINE set_gsmatch_maj =
BEGIN
!
! This routine is called by TPARSE to process the major id of the GSMATCH option
!
BUILTIN
    AP;

MAP
    AP : REF BBLOCK;

IF (lnk$gl_matchid[gmt$b_majorid] = .AP[tpa$l_number]) GTRU lnk$k_maxmajid
    THEN optionvaluerr(gsmatch_name,.AP,0,lnk$k_maxmajid);

AP[tpa$l_number] = 0;
RETURN true
END;							!Of set gsmatch_maj
ROUTINE set_gsmatch_min =
BEGIN
!
! This routine is called by TPARSE to process the minor id of the GSMATCH option
!
BUILTIN
    AP;

MAP
    AP : REF BBLOCK;

IF (lnk$gl_matchid[gmt$b_minorid] = .AP[tpa$l_number]) GTRU lnk$k_maxminid
    THEN optionvaluerr(gsmatch_name,.AP,0,lnk$k_maxminid);

RETURN true
END;							!Of set gsmatch_min

ROUTINE set_ioseg =
BEGIN
!
! This routine is called by TPARSE to set the IOSEG= option
!
BUILTIN
    AP;

MAP
    AP : REF BBLOCK;

IF (lnk$gw_ioseg = .AP[tpa$l_number]) GTRU lnk$k_maxioseg
    THEN optionvaluerr(ioseg_name,.AP,0,lnk$k_maxioseg);

RETURN true
END;						!Of set_ioseg
ROUTINE set_p0bufs =
BEGIN
!
! Clear the NOP0BUFS flag
!
BUILTIN
    AP;

MAP
    AP : REF BBLOCK;

lnk$gl_ctlmsk[lnk$v_nop0bufs] = .AP[tpa$l_param];

RETURN true
END;						!Of p0bufs_on

ROUTINE set_isd_max =
BEGIN
!
! This routine is called by TPARSE to set the ISD_MAX= option
!
BUILTIN
    AP;

MAP
    AP : REF BBLOCK;

IF (lnk$gw_misects = .AP[tpa$l_number]) GTRU lnk$k_maxisds
    OR .lnk$gw_misects EQL 0
    THEN optionvaluerr(isdmax_name,.AP,1,lnk$k_maxisds);

IF .lnk$gl_ctlmsk[lnk$v_shr]
    THEN SIGNAL(lin$_optignshr);

IF .lnk$gl_ctlmsk[lnk$v_sys]
    THEN SIGNAL(lin$_optignsys);

RETURN true
END;							!Of set_isd_max

ROUTINE set_protect =
BEGIN
!
! This action routine sets the protect flag
!
BUILTIN
    AP;

MAP
    AP : REF BBLOCK;

protectflag = .AP[tpa$l_param];

RETURN true
END;							!Of set_protect

ROUTINE createpsect =
BEGIN
!
! This routine is called by TPARSE when the PSECT= option is parsed.  It defines
! the psect.
!
BUILTIN
    AP;

MAP
    AP : REF BBLOCK;

LOCAL
    psectnamebuf : VECTOR[sym$c_maxlng+1,BYTE];

namelengthcheck(AP[tpa$l_tokencnt],lnk$gt_pscstring);	!Check length of name
psectnamebuf[0] = .AP[tpa$l_tokencnt];			!Create ASCIC name string
CH$MOVE(.AP[tpa$l_tokencnt],.AP[tpa$l_tokenptr],
				psectnamebuf[1]);
lib$insert_tree(lnk$gl_pscdflst,psectnamebuf,%REF(0),
		lnk$compare_pdd,lnk$alloc_pdd,curpsectdesc);						

RETURN true
END;							!Of createpsect
ROUTINE set_pscatrib =
BEGIN
!
! This routine is called by TPARSE for each attribute found in the PSECT= option
!
BUILTIN
    AP;

MAP
    AP : REF BBLOCK;

LOCAL
    maskflag,
    attribit;

attribit = .AP[tpa$l_param];
!
! Check if this is psect alignment and process
!
IF (.attribit AND sign_bit) NEQ 0
THEN BEGIN
    curpsectdesc[pdd$b_align] = .attribit<0,8>;	!Set psect aligment for later
    RETURN true;
    END
ELSE IF (.attribit AND word_sign_bit) NEQ 0	!If clearing the bit
	THEN BEGIN
	    curpsectdesc[pdd$w_flags] = .curpsectdesc[pdd$w_flags]
					AND NOT (NOT (.attribit AND %X'FFFF'));
	    curpsectdesc[pdd$w_flgmsk] = .curpsectdesc[pdd$w_flgmsk]
					OR (NOT (.attribit AND %X'FFFF'));
	    END
	ELSE BEGIN
	    curpsectdesc[pdd$w_flags]= .curpsectdesc[pdd$w_flags] OR .attribit;
	    curpsectdesc[pdd$w_flgmsk] = .curpsectdesc[pdd$w_flgmsk] OR .attribit;
	    END;
RETURN true
END;						!Of set_pscatrib

ROUTINE set_shl =
BEGIN
!
! This routine is called by TPARSE for the SHL_EXTRA option
!
BUILTIN
    AP;

MAP
    AP : REF BBLOCK;

lnk$gl_shlextra = .AP[tpa$l_number];
IF .lnk$gl_ctlmsk[lnk$v_sys]
    THEN SIGNAL(lin$_optignsys);

RETURN true
END;

ROUTINE set_stack =
BEGIN
!
! This routine is called by TPARSE to process the STACK= option
!
BUILTIN
    AP;

MAP
    AP : REF BBLOCK;

IF (lnk$gw_stack = .AP[tpa$l_number]) GTRU lnk$k_maxstack
    OR .lnk$gw_stack EQL 0
    THEN optionvaluerr(stack_name,.AP,1,lnk$k_maxstack);

IF .lnk$gl_ctlmsk[lnk$v_shr]
    THEN SIGNAL(lin$_optignshr);

IF .lnk$gl_ctlmsk[lnk$v_sys]
    THEN SIGNAL(lin$_optignsys);

RETURN true
END;							!Of set_stack

ROUTINE definesymbolname =
BEGIN
!
! This routine is called by TPARSE when the symbol name is parsed for the SYMBOL= option
!
BUILTIN
    AP;

MAP
    AP : REF BBLOCK;

LOCAL
    crfsts;

namelengthcheck(AP[tpa$l_tokencnt],lnk$gt_symstring);		!Check symbol name length
search_insert_symbol(AP[tpa$l_tokencnt],cursymdesc,		!Insert into symbol table
						cursymsnb);
cursymdesc[sym$w_flags] = (.cursymdesc[sym$w_flags] AND		!Clear all the flag bits
				(gsy$m_uni OR sym$m_supres))	! except uni and supres
				OR (gsy$m_def OR sym$m_optsym);	! and set def and optsym

IF .lnk$gl_ctlmsk[lnk$v_cros]					!If cross referencing
    THEN BEGIN
	crossref_symbol(.cursymdesc,.cursymsnb,			!Insert symbol definition
				.cursymdesc[sym$w_flags]);
	crfsts = crf$insrtref(lnk$al_sytblfmt,cursymsnb[snb$b_namlng],	!  then insert a reference
			defined_by_option,gsy$m_def,		!  saying defined by option
			crf$k_def);				!  and this is a defining reference
	IF NOT .crfsts						!Report error from cref if so
	    THEN SIGNAL(lin$_crferr,0,.crfsts);
	lnk$gl_maxsymsz = MAXU(.lnk$gl_maxsymsz,		!Set maximum symbol name length
				.cursymsnb[snb$b_namlng]);
	lnk$gl_maxmodsz = MAXU(.lnk$gl_maxmodsz,		! and maximum module name length
				%CHARCOUNT('<Linker option>'));
	lnk$gw_ncrosrfs = .lnk$gw_ncrosrfs + 1;			!Count the cross reference
	END;

RETURN true
END;								!Of definesymbolname

ROUTINE definesymbolval =
BEGIN
!
! This routine is called by TPARSE when the value is parsed in the SYMBOL= option
!
BUILTIN
    AP;

MAP
    AP : REF BBLOCK;

LOCAL
    crfsts;

cursymdesc[sym$l_value] = .AP[tpa$l_number];			!Set the symbol value

IF .lnk$gl_ctlmsk[lnk$v_long]					!If generating a long map
    THEN BEGIN
	crfsts = crf$insrtref(lnk$al_valctltb,cursymdesc[sym$l_value],	! then insert a reference to its value
			cursymsnb[snb$b_namlng],
			.cursymdesc[sym$w_flags],0);

	IF NOT .crfsts
	    THEN SIGNAL(lin$_crferr,0,.crfsts);
	END;

RETURN true
END;								!of definesymbolval

ROUTINE set_universal =
BEGIN
!
! This routine is called for each symbol in the UNIVERSAL option by TPARSE
!
BUILTIN
    AP;

MAP
    AP : REF BBLOCK;

namelengthcheck(AP[tpa$l_tokencnt],lnk$gt_symstring);			!Check length of symbol name
search_insert_symbol(AP[tpa$l_tokencnt],cursymdesc,cursymsnb);		!Lookup/insert symbol into symbol table
cursymdesc[sym$w_flags] = gsy$m_uni;					!Flag symbol as universal
lnk$insudfsym(.cursymdesc);						!Insert in undefined list
crossref_symbol(.cursymdesc,.cursymsnb);				!Cross reference the symbol

RETURN true
END;									!Of set_univ

ROUTINE set_alluniv =
BEGIN
!
! This routine sets the flag lnk$v_alluniv in lnk$gl_ctlmsk so that all
! globals are promoted to universals
!
lnk$gl_ctlmsk[lnk$v_alluniv] = true;					!Flag all symbols to be universal
RETURN true
END;									!Of set_alluniv

ROUTINE set_include =
BEGIN
!
! This routine processes the /include qualifier
!

BUILTIN
    AP;

MAP
    AP : REF BBLOCK;

set_qual_flags(.AP,fdb$m_libr);					!Set qualifier flag
lnk$alloblk((clireqdesc[cli$w_qdvalsiz] = .include_desc[dsc$w_length]),	!Allocate a block of memory for string
			clireqdesc[cli$a_qdvaladr]);

CH$MOVE(.include_desc[dsc$w_length],.include_desc[dsc$a_pointer], !Copy string to allocated block
			.clireqdesc[cli$a_qdvaladr]);

lnk$setlibrin(.clireqdesc);					!Set command options

RETURN true
END;								!Of set_include

ROUTINE set_library =
BEGIN
!
! This routine processes the /library qualifier
!

BUILTIN
    AP;

MAP
    AP : REF BBLOCK;

set_qual_flags(.AP,fdb$m_libr);
clireqdesc[cli$w_qdvalsiz] = 0;
clireqdesc[cli$a_qdvaladr] = 0;
lnk$setlibrin(.clireqdesc);

RETURN true
END;								!Of set_library

ROUTINE set_selective =
BEGIN
!
! This routine processes the /selective qualifier
!

BUILTIN
    AP;

MAP
    AP : REF BBLOCK;

set_qual_flags(.AP,fdb$m_selser);

RETURN true
END;								!Of set_selective

ROUTINE set_shareable =
BEGIN
!
! This routine processes the /shareable qualifier
!

BUILTIN
    AP;

MAP
    AP : REF BBLOCK;

LOCAL
    descr : BBLOCK[dsc$c_s_bln];

set_qual_flags(.AP,fdb$m_shr);

IF .lnk$gl_ctlmsk[lnk$v_sys]					!Don't allow /share with /sys
    THEN SIGNAL_STOP(lin$_shrinsys);

!
! If this is in a cluster= option and there are other
! files in the cluster, issue a warning and create a new
! cluster.
!
IF .cluoptflag
    AND .lnk$gl_curclu[clu$l_fstfdb] NEQ 0
THEN BEGIN
    descr[dsc$w_length] = .tparse_block[tpa$l_tokenptr] - .cmdbuffer;
    descr[dsc$a_pointer] = .cmdbuffer;
    SIGNAL(lin$_shrsepclu,0,
		lin$_optlin,3,descr,
		tparse_block[tpa$l_tokencnt],
		tparse_block[tpa$l_stringcnt]);
    lnk$allocluster(lnk$gl_curclu);				!Allocate a new cluster
    lnk$gl_curclu[clu$v_protect] = .protectflag;		!Set protect if on
    END;
IF NOT .cluoptflag						!If not processing cluster= option
THEN BEGIN
    lnk$allocluster(lnk$gl_curclu);				! then allocate a new cluster descriptor
    lnk$gl_curclu[clu$v_protect] = .protectflag;		!Set protect if on
    END;

lnk$gl_curclu[clu$v_shrimg] = true;
lnk$gl_curclu[clu$v_copy] = .sharecopy;

lnk$setshrblin();

RETURN true
END;								!Of set_shareable
ROUTINE set_shrcopyflag =
BEGIN
!
! This routine is called by TPARSE to set/clear the copyflag for /share
!
BUILTIN
    AP;

MAP
    AP : REF BBLOCK;

sharecopy = .AP[tpa$l_param];
IF .sharecopy NEQ 0
THEN BEGIN
    SIGNAL(lin$_shrcpyign);
    sharecopy = 0;
    END;

RETURN true
END;								!Of set_shrcopyflag

ROUTINE insertcluster =
BEGIN
!
! This routine inserts the current cluster in the cluster tree
!
LOCAL
    blockaddr;

IF lib$lookup_tree(lnk$gl_clutree,lnk$gl_curclu[clu$b_namlng],		!If cluster name already in tree
			lnk$clunamcmp,blockaddr)
    THEN SIGNAL(lin$_mulcluopt,2,lnk$gl_curclu[clu$b_namlng],		!  then tell user
						.optionfilename);
lnk$insert_clu(.lnk$gl_curclu);						!Insert the cluster in the tree
RETURN true
END;

ROUTINE processfile =
BEGIN
!
! This routine is called by TPARSE when a complete file specification
! has been scanned.
!
BUILTIN
    AP;

MAP
    AP : REF BBLOCK;

LOCAL
    descr : BBLOCK[dsc$c_s_bln];

BIND
    filebits = .fileflagsadr : BITVECTOR;

IF .cluoptflag								!If processing a cluster= option
THEN BEGIN
    IF .lnk$gl_curclu[clu$v_shrimg]					!If current cluster is shareable image
    AND ((.filebits AND fdb$m_shr) EQL 0)				! and this file is not a shareable image
    THEN BEGIN
	descr[dsc$w_length] = .tparse_block[tpa$l_tokenptr] - .cmdbuffer; !Create string descriptor for part of line
	descr[dsc$a_pointer] = .cmdbuffer;
	SIGNAL(lin$_shrsepclu,0,					!Tell user we are creating new cluster
		lin$_optlin,3,descr,
		tparse_block[tpa$l_tokencnt],
		tparse_block[tpa$l_stringcnt]);
	lnk$allocluster(lnk$gl_curclu);					!Allocate a new cluster
	descr[dsc$w_length] = sym$c_maxlng;				!Set length of buffer
	descr[dsc$a_pointer] = lnk$gl_curclu[clu$t_name];		!And starting address
	SYS$FAO(UPLIT(stringdesc('!AC_!UL')),descr,descr,		!Create cluster name of default_cluster_N
			lnk$gl_defclu[clu$b_namlng],.lnk$gl_defclunum);
	lnk$gl_curclu[clu$b_namlng] = .descr[dsc$w_length];		!Set resulting cluster name length
	lnk$gl_defclunum = .lnk$gl_defclunum + 1;
	lnk$gl_curclu[clu$v_protect] = .protectflag;
	END;
    END
ELSE IF .lnk$gl_curclu[clu$v_shrimg]					!Not cluster option, is current cluster shr image?
    AND .lnk$gl_curclu[clu$l_fstfdb] NEQ 0				! and there are files in the cluster
    THEN lnk$gl_curclu = lnk$gl_defclu;					!Put this file in the default cluster
!
! If this file is a shareable image, or the first file in a CLUSTER=
! option, then insert the cluster into the cluster list
!
IF .lnk$gl_curclu[clu$v_shrimg]
    OR (.cluoptflag
	AND (.lnk$gl_curclu[clu$l_fstfdb] EQL 0))
THEN BEGIN
    IF .lnk$gl_curclu[clu$v_shrimg]					!If cluster is shareable image
    THEN BEGIN								! then we must set the cluster name
	getfilename(filespec_desc, descr);				!Get filename portion of file spec
	lnk$gl_curclu[clu$b_namlng] = .descr[dsc$w_length];		!Set length into cluster descriptor
	CH$MOVE(.descr[dsc$w_length],.descr[dsc$a_pointer],		!Copy in cluster name
					lnk$gl_curclu[clu$t_name]);
	END;
	insertcluster();						!Insert cluster in cluster tree
    END;

lnk$alloblk((clireqdesc[cli$w_rqsize] = .filespec_desc[dsc$w_length]),	!Allocate memory
			clireqdesc[cli$a_rqaddr]);			! to hold the token
CH$MOVE(.filespec_desc[dsc$w_length],.filespec_desc[dsc$a_pointer],	! and copy it out
				.clireqdesc[cli$a_rqaddr]);
filebits[.clireqdesc[cli$b_bitnum]] = true;				!Set the bit
(.clireqdesc[cli$a_prsact] + .clireqdesc)(.clireqdesc);			! call the action routine

RETURN true
END;									!Of processfile

ROUTINE getfilename (filedesc, retdesc) =
BEGIN
!
! This routine returns the filename portion of a
! file specification
!
MAP
    filedesc : REF BBLOCK,
    retdesc : REF BBLOCK;

LOCAL
    addr,size,						! Temporary descriptor
    ptr;						! String pointer

size = .filedesc[dsc$w_length];				! Get result name string
addr = .filedesc[dsc$a_pointer];

ptr = CH$FIND_CH(.size, .addr, ']');			! Find start of file name on input side
IF .ptr EQL 0						! If not found,
THEN BEGIN
    ptr = CH$FIND_CH(.size, .addr, '>'); 		! Alternate syntax
    IF .ptr EQL 0					! If still not found
    THEN BEGIN
	LOCAL
	    size1,ptr1;

	ptr1 = .addr;					! Look for the end of the device or node specification
	size1 = .size;
	WHILE (
		ptr = CH$FIND_CH(.size1, .ptr1, ':');	! Find a colon
		IF .ptr EQL 0				! If none there
		THEN BEGIN
		    IF .ptr1 NEQ .addr			!  then if we found one
			THEN ptr = .ptr1 - 1;		!  then update ptr
		    false				! Exit the WHILE loop
		    END
		ELSE true				! Found one--continue
		)
	    DO BEGIN
		ptr1 = .ptr + 1;
		size1 = .size - (.ptr1 + 1 - .addr);
		END;
	IF .ptr EQL 0					! If still not found
	    THEN ptr = .addr - 1;			! then assume filename is preceded by nothing
	END;
    END;

size = .size - (.ptr + 1 - .addr);			! Figure descriptor of file name
addr = .ptr + 1;

ptr = CH$FIND_CH(.size, .addr, '.');			! Find where file name ends
IF .ptr EQL 0						! If not found,
THEN IF (ptr = CH$FIND_CH(.size, .addr, ';')) EQL 0	! See if a file version is there
	THEN ptr = .addr + .size;			! and if not, use rest of string

retdesc[dsc$w_length] = .ptr - .addr;
retdesc[dsc$a_pointer] = .addr;

RETURN true
END;

ROUTINE set_qual_flags (tpablock,qualbits) =
!
! This routine checks for conflicting qualifiers and then sets the proper bits
!
BEGIN

MAP
    tpablock : REF BBLOCK;

LOCAL
    descr : BBLOCK[dsc$c_s_bln];

IF (..fileflagsadr AND .tpablock[tpa$l_param]) NEQ 0			!Check for conflicting qualifiers
THEN BEGIN
    descr[dsc$w_length] = .tpablock[tpa$l_tokenptr] - .cmdbuffer;
    descr[dsc$a_pointer] = .cmdbuffer;
    SIGNAL_STOP(lin$_confqual,0,
			lin$_optlin,3,descr,tpablock[tpa$l_tokencnt],
			tpablock[tpa$l_stringcnt]);
    END
ELSE .fileflagsadr = ..fileflagsadr OR .qualbits;

RETURN true
END;									!Of set_qual_flags

%SBTTL	'Search / insert into linked, ordered list';
ROUTINE search_insert_list (listhead, namedesc, blocksize, blockaddr) =
BEGIN
!---
! This routine searches a linked list for a given name.  If the name is
! not found, a new node is created and the name is inserted.  The structure
! of the links in the list must be as follows:
!
!	ptr===>	link to next entry
!		size of name (byte)
!		name
!		(any other data)
!
! Inputs:
!
!	listhead	the address of the linked list head
!	blocksize	size of block to allocate if not found
!
! Outputs:
!
!	blockaddr	entry address
!
!---

MACRO
    nextblock = 0,0,32,0%,				!First longword is link
    namesize = 4,0,8,0%,				!Then a byte of name length
    nameaddr = 5,0,0,0%;				!Followed by name

MAP
    listhead : REF BBLOCK,
    namedesc : REF BBLOCK;

LOCAL
    lastblock : REF BBLOCK,
    thisblock : REF BBLOCK;

thisblock = .listhead;					!Start at top of list
lastblock = .thisblock;
!
! Loop looking for entry, or one less than desired entry
!
WHILE (thisblock = .thisblock[nextblock]) NEQ 0
DO IF CH$EQL(.thisblock[namesize],thisblock[nameaddr],
		.namedesc[dsc$w_length], .namedesc[dsc$a_pointer],0)
    THEN BEGIN
	.blockaddr = .thisblock;			!Return found entry to caller
	RETURN true;
	END
    ELSE lastblock = .thisblock;
!
! Name was not found...allocate a new one
!
lnk$alloblk(.blocksize,thisblock);
CH$FILL(0,.blocksize,.thisblock);			!Zero the block
thisblock[nextblock] = .lastblock[nextblock];		!Link into the list
lastblock[nextblock] = .thisblock;
thisblock[namesize] = .namedesc[dsc$w_length];
CH$MOVE(.namedesc[dsc$w_length],.namedesc[dsc$a_pointer],
		thisblock[nameaddr]);
.blockaddr = .thisblock;				!Return address to caller
RETURN true
END;							!Of search_insert_list

%SBTTL	'Search / insert a symbol';
ROUTINE search_insert_symbol (symboldesc, symblock, snblock) =
BEGIN
!---
! This routine looks up the symbol in the symbol table and returns
! the address of the symbol block.  If it is not found, it is inserted.
!
! Inputs:
!
!	symboldesc	Address of a string descriptor for symbol name
!	symblock	Address of location to return symbol block address
!	snblock		Address of location to return symbol name block address
!
!---
MAP
    symboldesc : REF BBLOCK;

LOCAL
    symptr : REF BBLOCK,
    symbolstring : VECTOR[sym$c_maxlng*2,BYTE];

CH$MOVE((symbolstring[0] = .symboldesc[dsc$w_length]),		!Create an ASCIC string
		.symboldesc[dsc$a_pointer],symbolstring[1]);
IF lnk$search (symbolstring,.symblock,.snblock)			!Look up the symbol
    THEN RETURN true;						! and if found then all done
!
! Not in table, so insert it
!
lnk$insert(symbolstring,symptr,.snblock);
symptr[sym$l_udflink] = 0;
symptr[sym$w_flags] = 0;
.symblock = .symptr;
RETURN true
END;								!Of search_insert_list

%SBTTL	'Cross reference a symbol';
ROUTINE crossref_symbol (symbolblock,snblock,flags) =
BEGIN
!---
!
! Enter symbol into cross reference if generating one.
!
! Inputs:
!
!	symbolblock		Pointer to symbol descriptor block
!	snblock			Pointer to name part of symbol block
!	flags			Flags to enter into cross reference
!
!---
MAP
    symbolblock : REF BBLOCK,
    snblock : REF BBLOCK;

LOCAL
    crfsts;

IF .lnk$gl_ctlmsk[lnk$v_map]				!If generating a map
    AND NOT .lnk$gl_ctlmsk[lnk$v_brief]			! that is not brief
    THEN BEGIN
	crfsts = crf$insrtkey(lnk$al_sytblfmt,		!  then insert the symbol
			snblock[snb$b_namlng],		!  passing the name
			symbolblock[sym$l_value],	!  the value address
			.flags);			!  and the flags

	IF NOT .crfsts
	    THEN SIGNAL(lin$_crferr,0,.crfsts);
	lnk$gl_maxsymsz = MAXU(.lnk$gl_maxsymsz,	!Set maximum symbol name length
				.snblock[snb$b_namlng]);
	END;

RETURN true
END;							!Of crossref_symbol

%SBTTL	'Debug routine to catch TPARSE in action';
ROUTINE debug_stop =
BEGIN

RETURN true
END;

%SBTTL	'Check length of name';
ROUTINE namelengthcheck (namedesc, nametype) =
BEGIN
!
! This routine checks that the symbol name is gtr 0
! and leq sym$c_maxlng and issues a SIGNAL_STOP if not
!
MAP
    namedesc : REF BBLOCK;

IF .namedesc[dsc$w_length] EQL 0
    OR .namedesc[dsc$w_length] GTRU sym$c_maxlng	!Check for illegal name length
THEN BEGIN
    LOCAL
	symbolbuf : VECTOR[512,BYTE];			!Local buffer to copy name

    symbolbuf[0] = .namedesc[dsc$w_length];		!Create ASCIC string
    CH$MOVE(MINU(.namedesc[dsc$w_length],512),		!Copy as much of name in as possible
		.namedesc[dsc$a_pointer],symbolbuf[1]);
    SIGNAL_STOP(lin$_illnamelen,6,.nametype,		!Report error and quit
		symbolbuf,.namedesc[dsc$w_length],
		sym$c_maxlng,optionfilestring,.optionfilename);
    END;

RETURN true
END;

%SBTTL	'Options parsing error routines';
ROUTINE syntaxerr =
BEGIN
!
! This routine is called by TPARSE to report a syntax error and quit
!
LOCAL
    descr : BBLOCK[dsc$c_s_bln];

descr[dsc$w_length] = .tparse_block[tpa$l_tokenptr] - .cmdbuffer;
descr[dsc$a_pointer] = .cmdbuffer;
SIGNAL_STOP(lin$_optsynerr,1,.optionfilename,
		lin$_optlin,3,descr,tparse_block[tpa$l_tokencnt],
		tparse_block[tpa$l_stringcnt]);

RETURN true						!SIGNAL_STOP doesn't return, but...
END;							!Of syntaxerr

ROUTINE optionvaluerr (option_name, tpablock, minval, maxval) =
BEGIN
!
! This routine signals an option value error and stops the image.
!

MAP
    tpablock : REF BBLOCK;

LOCAL
    descr : BBLOCK[dsc$c_s_bln];

descr[dsc$w_length] = .tpablock[tpa$l_tokenptr] - .cmdbuffer;
descr[dsc$a_pointer] = .cmdbuffer;

SIGNAL_STOP(lin$_optvalerr,5,.option_name,.tpablock[tpa$l_number],
		.minval,.maxval,.optionfilename,
		lin$_optlin,3,descr,tpablock[tpa$l_tokencnt],
		tpablock[tpa$l_stringcnt]);
RETURN true
END;								!Of optionvaluerr

ROUTINE missingargerr =
BEGIN
!
! This routine is called by TPARSE to report a missing argument for an option
!

LOCAL
    descr : BBLOCK[dsc$c_s_bln];

descr[dsc$w_length] = .tparse_block[tpa$l_tokenptr] - .cmdbuffer;
descr[dsc$a_pointer] = .cmdbuffer;
SIGNAL_STOP(lin$_optargmis,1,.optionfilename,
		lin$_optlin,3,descr,tparse_block[tpa$l_tokencnt],
		tparse_block[tpa$l_stringcnt]);

RETURN true
END;							!Of missingargerr

END
ELUDOM
