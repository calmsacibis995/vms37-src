MODULE LNK_MAPROUTINES 	(	! LINKER MAP ROUTINES
		IDENT = 'V03-000',
		ADDRESSING_MODE (EXTERNAL=GENERAL,
				NONEXTERNAL=LONG_RELATIVE)
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY:	LINKER
!
! ABSTRACT:	PRODUCES THE MAP
!
! ENVIRONMENT:
!
! AUTHOR: K.D. MORSE, CREATION DATE: 27-MAR-77
!
! MODIFIED BY:
!
!	V03-012	BLS0123		Benn Schreiber		17-Dec-1981
!		Change FAOBUG to FAOFAIL for consistency
!
!	V03-011	BLS0111		Benn Schreiber		22-Nov-1981
!		Change EXIT VECTORS to FIXUP VECTORS
!
!	V03-010	BLS0101		Benn Schreiber		 7-Nov-1981
!		Add object module address synopsis
!
!	V03-009	BLS0074		Benn Schreiber		29-Aug-1981
!		Improve image section synopsis
!
!	V03-008	BLS0050		Benn Schreiber		26-Mar-1981
!		Independent shareable images
!
!	V03-007	BLS0042		Benn Schreiber		25-Feb-1981
!		Delete COPYALWAYS
!
!	V03-006	BLS0040		Benn Schreiber		12-Feb-1981
!		Handle up to 31 character cluster names
!
!	V03-005	BLS0038		Benn Schreiber		30-Jan-1981
!		Watch map lines for carriage control and count them
!
!	V03-004	BLS0035		Benn Schreiber		19-Jan-1981
!		65K psects
!
!	V03-003	BLS0031		Benn Schreiber		19-Jan-1981
!		Pass 1 error messages printed in map in pass 2
!
!	V03-002	BLS0013		Benn Schreiber		29-Aug-1980
!		Correct error in psect listing
!
!	V03-001	BLS0007		Benn Schreiber,		3-Jun-1980
!		Convert to MDL data structures.
!--


!
!++
!
! MODULE DESCRIPTION:
!
! THIS MODULE CONTAINS ALL THE ROUTINES NEEDED TO CREATE A MAP FOR THE 
! LINKER.  THERE IS A GLOBAL ROUTINE TO PRODUCE EACH SECTION OF
! THE MAP AND SEVERAL LOCAL SUBROUTINES TO HANDLE THE ACTUAL OUTPUT.  
!
! THE CALLING SEQUENCES OF THE GLOBAL ROUTINES ARE:
!	LNK$MAPINIT()
!	LNK$MAPMHD(OBJREC,OBJMODDSC)
!	LNK$MAPLNG(LANGADDR,LANGLEN)
!	LNK$MAPADROMD()
!	LNK$MAPPSCTS()
!	LNK$MAPSYMS()
!	LNK$MAPISCTS()
!	LNK$MAPOUT(LINEADDR,COUNT)
!
! WHERE:
!
!	OBJREC IS THE ADDRESS OF A MODULE HEADER RECORD (SEE OBJFMT)
!	OBJMODDSC IS THE ADDRESS OF AN OBJECT MODULE DESCRIPTOR (SEE DATBAS)
!	LANGADDR IS THE ADDRESS OF THE LANGUAGE PROCESSOR SUB-HEADER RECORD
!	LANGLEN IS THE LENGTH OF THE LANGUAGE PROCESSOR NAME
!	LINEADDR IS THE ADDRESS OF A LINE TO BE OUTPUT TO THE MAP (E.G. ERROR MESSAGES)
!	COUNT IS THE NUMBER OF BYTES IN THE OUTPUT LINE
!
!--
!
! TABLE OF CONTENTS:
!
FORWARD ROUTINE
	CRFERROR : NOVALUE,					! CALLED BY CREF ON ERRORS
	FAOFAIL : NOVALUE,					! HANDLES FAILURES FROM FAO
	LNK$MAPINIT: NOVALUE,					! INITIALIZE MAP FILE
	LNK$CLOSMAPFIL : NOVALUE,				! CLOSE THE MAP FILE
	MAPFAIL: NOVALUE,					! MAP I/O FAILURE ROUTINE
	LNK$MAPMHD: NOVALUE,					! CREATE OBJECT MODULE LINE
	LNK$MAPLNG: NOVALUE,					! INSERT CREATOR IN MHD LINE
	LNK$MAPADROMD : NOVALUE,				! LIST MODULES CONTAINING ADDRESS DATA
	LNK$MAPPSCTS: NOVALUE,					! CREATE THE PSECT MAP SECTION
	LNK$MAPSYMS: NOVALUE,					! CREATE ALL MAP SECTIONS FOR SYMBOLS
	LNK$MAPISCTS: NOVALUE,					! CREATE THE IMAGE SECTION SYNOPSIS
	LNK$MAPSTATS: NOVALUE,					! OUTPUT LINKER'S RUN STATISTICS
	MAPBOX,							! OUTPUT A HEADER IN A BOX
	LNK$MAPOUT,						! OUTPUT ONE LINE ALREADY FORMATTED
	LNK$CRFOUT,						! OUTPUT CROSS REF LINE
	MAPSUBHDR,						! CREATE A NEW SUBHEADER LINE AND OUTPUT IT
	NEWPAGE,						! OUTPUT NEW PAGE, HEADER, AND SUB-HEADER
	NEWLINE;						! OUTPUT BLANK LINE

!
! INCLUDE FILES:
!
LIBRARY
	'LIBL32';				! SYSTEM STRUCTURE DEFINITIONS
REQUIRE
	'PREFIX';				! GET GENERAL DEFINITIONS
LIBRARY
	'DATBAS';				! GET BASIC DATA BASE DEFINITIONS
REQUIRE
	'ISGENC';				! GET OBJECT LANGUAGE RECORD FORMAT ANE ISD LAYOUT
!
REQUIRE
	'CRFMDL';				! CREF FIELD DEFINITIONS
!
! EQUATED SYMBOLS:
!
GLOBAL LITERAL
	LEN$C_MAPLINE = 132,					! LENGTH OF LINES ON THE MAP
	LEN$C_LNGNAM = 30;					! MAXIMUM LENGTH OF MODULE CREATOR NAME
LITERAL
	DATE_FLD_LNG = 17,					! LENGTH OF DATE FIELD IN OBJ MOD HDR REC
	MAJ_IDENT_LNG = 2,					! LENGTH OF MAJOR IDENT
	MIN_IDENT_LNG = 2,					! LENGTH OF MINOR IDENT
	MAX_K_RMSMBC = 8,					! MAXIMUM NUMBER FOR RMS BLOCKING
	BOXLINES = 3;						! NUMBER OF LINES IN BOX HEADINGS
!
! OWN STORAGE:
!
	PSECT OWN = $PLIT$ (NOPIC,CONCATENATE,LOCAL,NOSHARE,NOEXECUTE,NOWRITE);
OWN
!
! FAO CONTROL STRINGS
!
	CONTRBSTR : DESCRIPTOR('!16AC!15AC!3(9XL) (!11UL.) !5AC!1ZB'),			! PSECT CONTRIBUTION
	CONTRBST1 : DESCRIPTOR('!31AC!3(9XL) (!11UL.) !5AC!1ZB'),
	PSC_CNTRL_STR : DESCRIPTOR('!16AC!15AC!3(9XL) (!11UL.) !5AC!ZB !10(AC)'),	! PSECT DESCRIPTION
	PSC_CNTRL_ST1 : DESCRIPTOR('!31AC!3(9XL) (!11UL.) !5AC!ZB !10(AC)'),
	HDR_CNTRL_STR: DESCRIPTOR('!64AS!25<!17%D!>!33<VAX-11 Linker V!AD-!AD!>Page!5UL'),! MAP PAGE HEADING
	FF_CNTRL_STR: DESCRIPTOR('!^'),							! NEW PAGE
	OBJMD_CNTRL_STR: DESCRIPTOR('!16AC!15AC!10UL !37AD!19AD'),			! OBJ MOD SECTION
	OBJMD_CNTRL_ST1 : DESCRIPTOR('!31AC'),
	OBJMD_CNTRL_ST2 : DESCRIPTOR('!31AC!10UL !37AD!19AD'),
	CREAT_CNTRL_STR: DESCRIPTOR('!AD'),						! CREATOR OF MODULE
	OMDADRSTR : DESCRIPTOR('!33AC!8UL  '),						! MODULE .ADDRESS COUNT
	ISECT_CNTRL_STR: DESCRIPTOR('!16AC!4UB!6UW  !2AC!8XL!2AC!9UL!4UB !AC !AC !AC'),
	GBLIS_CNTRL_STR: DESCRIPTOR('!16AC!4UB!6UW  !2AC!8XL!2AC!9UL!4UB!28< !AC !AC !AC!>!16AC !12AC !6UB  !8UL'),
	ABBRVTBL1_STR: DESCRIPTOR('!_!_+!18*-+'),
	ABBRVTBL2_STR: DESCRIPTOR('!_!_!!!AC!!'),
!
! FAO CONTROL STRINGS FOR LINK-WIDE SYNOPSIS
!
	VIRMEMLINE: DESCRIPTOR('!49<Virtual memory allocated:!>!3(9XL) (!UL. byte!%S, !UL. page!%S)'),
	STACKLINE: DESCRIPTOR('!50<Stack size:!>!8UW. page!%S'),
	IMGHDRBLKLINE: DESCRIPTOR('!50<Image header virtual block limits:!>!8UL.!9UW. (!5UW. block!%S)'),
	IMGBINBLKLINE: DESCRIPTOR('!50<Image binary virtual block limits:!>!8UL.!9UL. (!5UW. block!%S)'),
	IDENTLINE: DESCRIPTOR('!50<Image name and identification:!>!AC !AC'),
	NFILLINE: DESCRIPTOR('!50<Number of files:!>!8UW.'),
	NMODLINE: DESCRIPTOR('!50<Number of modules:!>!8UW.'),
	NPSCLINE: DESCRIPTOR('!50<Number of program sections:!>!8UW.'),		! NUMBER OF P-SECTS IN LINK
	NSYMLINE: DESCRIPTOR('!50<Number of global symbols:!>!8UW.'),		! NUMBER OF GLOBAL SYMBOLS
	NUNDFLINE: DESCRIPTOR('!50<Including undefined count of:!>!8UW.'),	! COUNT OF UNDEFINED SYMBOLS
	NCROSREFS : DESCRIPTOR('!50<Number of cross references:!>!8UW.'),
	NISCLINE: DESCRIPTOR('!50<Number of image sections:!>!8UW.'),		! NUMBER OF IMAGE SECTIONS
	NADREFLINE : DESCRIPTOR('!50<Number of address fixups:!>!8UL.'),	! NUMBER OF .ADDRESSES FIXED UP
	NSHRSYMLINE : DESCRIPTOR('!50<Number of code references to shareable images:!>!8UL.'),
	DBGTFRLINE: DESCRIPTOR('!50<Debugger transfer address:!>!8XL'),		! DEBUGGER TRANSFER ADDRESS
	OTSTFRLINE : DESCRIPTOR('!50<OTS transfer address - !AC:!>!8XL'),	! OTS TRANSFER ADDRESS
	USRTFRLINE: DESCRIPTOR('!50<User transfer address:!>!8XL'),		! USER TRANSFER ADDRESS
	IMGATRLINE: DESCRIPTOR('!50<Image type:!>!AC.'),			! IMAGE ATTRIBUTES LINE
	IMGSHRLINE: DESCRIPTOR(
		'!50<Image type:!>!AC!AC. Global Section Match=!AC, Ident, Major=!UB, Minor=!UL'), ! IMAGE ATTRIBUTES LINE
	MAPFORMAT : DESCRIPTOR('!50<Map format:!>!AC!ACin file !AD'),
	MAPLENGTH : DESCRIPTOR('!50<Estimated map length:!>!UL. blocks');
BIND
	ALIGNBYTE = CSTRING('BYTE '),				! BYTE ALIGNMENT ASCIC STRING
	ALIGNWORD = CSTRING('WORD '),				! WORD ALIGNMENT ASCIC STRING
	ALIGNLONG = CSTRING('LONG '),				! LONGWORD ALIGNMENT ASCIC STRING
	ALIGNQUAD = CSTRING('QUAD '),				! QUADWORD ALIGNMENT ASCIC STRING
	ALIGN2 = CSTRING('2 ** '),				! OTHER ALIGNMENT ASCIC STRING
	ALIGNPAGE = CSTRING('PAGE '),				! PAGE ALIGNMENT ASCIC STRING
	BLANKS = CSTRING(' '),					! ASCIC STRING OF SPACE
	HYPHENS = CSTRING('-'),					! ASCIC STRING OF HYPHENS
	HYPHEN_R = CSTRING('-R'),				! ASCIC STRING OF HYPHEN AND "R"
	P_HYPHEN = CSTRING('P-'),				! TO INDICATE SECTION IS PROTECTED
	PIC = CSTRING('  PIC,'),				! PIC ATTRIBUTE ASCIC STRING
	LIB = CSTRING('LIB,'),					! LIB ATTRIBUTE ASCIC STRING
	OVR = CSTRING('OVR,'),					! OVR ATTRIBUTE ASCIC STRING
	REL = CSTRING('REL,'),					! REL ATTRIBUTE ASCIC STRING
	GBL = CSTRING('GBL,'),					! GBL ATTRIBUTE ASCIC STRING
	VEC = CSTRING('  VEC'),					! VECTOR PSECT
	SHR = CSTRING('  SHR,'),				! SHR ATTRIBUTE ASCIC STRING
	EXE = CSTRING('  EXE,'),				! EXE ATTRIBUTE ASCIC STRING
	RD  = CSTRING('  RD,'),					! RD ATTRIBUTE ASCIC STRING
	WRT = CSTRING('  WRT,'),				! WRITEABLE
	NOPIC = CSTRING('NOPIC,'),				! WRT ATTRIBUTE ASCIC STRING
	USR = CSTRING('USR,'),					! USR ATTRIBUTE ASCIC STRING
	CON = CSTRING('CON,'),					! CON ATTRIBUTE ASCIC STRING
	ABS = CSTRING('ABS,'),					! ABS ATTRIBUTE ASCIC STRING
	LCL = CSTRING('LCL,'),					! LCL ATTRIBUTE ASCIC STRING
	NOVEC = CSTRING('NOVEC'),				! NOT VECTOR PSECT 
	NOSHR = CSTRING('NOSHR,'),				! NOSHR ATTRIBUTE ASCIC STRING
	NOEXE = CSTRING('NOEXE,'),				! NOEXE ATTRIBUTE ASCIC STRING
	NORD  = CSTRING('NORD,'),				! NORD ATTRIBUTE ASCIC STRING
	NOWRT = CSTRING('NOWRT,'),				! NOT WRITEABLE
	EXEIMAGE = CSTRING('EXECUTABLE'),			! EXECUTABLE IMAGE
	SYSIMAGE = CSTRING('SYSTEM'),				! SYSTEM IMAGE
	SHRIMAGE = CSTRING(' SHAREABLE'),			! AND LINKABLE IMAGE
	BRIEFMAP = CSTRING('BRIEF'),				! BRIEF MAP FORMAT
	ALLTIME = CSTRING('ALWAYS'),				! GS MATCH = ALWAYS
	NEVER = CSTRING('NEVER'),				! GS MATCH = NEVER
	EQUAL = CSTRING('EQUAL'),				! GS MATCH = EQUAL
	LSSEQUAL = CSTRING('LESS/EQUAL'),			! GS MATCH = LESS/EQUAL
	DEFAULTMAP = CSTRING('DEFAULT'),			! DEFAULT FORMAT
	LONGMAP = CSTRING('FULL'),				! LONG FORMAT
	CREFMAP = CSTRING(' WITH CROSS REFERENCE '),		! WITH CROSS REFERENCES
	READWRITE = CSTRING('READ WRITE'),
	READONLY = CSTRING('READ ONLY'),
	DEMANDZERO = CSTRING('DEMAND ZERO'),
	COPYONREF = CSTRING('COPY ON REF'),
	ADDRDATA = CSTRING('NON-SHAREABLE ADDRESS DATA'),
	FIXUPSECTION = CSTRING('FIXUP VECTORS'),
	CHARDEF_STR = CSTRING('	  Key for special characters above:') : VECTOR[,BYTE],
	UNDEF_STR = CSTRING(' *  - Undefined   '),
	UNIV_STR = CSTRING(' U  - Universal   '),
	EXT_STR =  CSTRING(' X  - External    '),
	RELOC_STR = CSTRING(' R  - Relocatable '),
	WEAK_STR = CSTRING(' WK - Weak        '),
	PROTECT_STR = CSTRING(' P  - Protected   '),
	STR_POINTER = UPLIT(LONG(UNDEF_STR,
				UNIV_STR,
				RELOC_STR,
				EXT_STR,
				WEAK_STR)) : VECTOR[,LONG],
	ISTR_POINTER = UPLIT(LONG(RELOC_STR,
				PROTECT_STR)) : VECTOR[,LONG],
!
! BOXED HEADERS
!
	PSECTHDR = CSTRING('! Program Section Synopsis !'),	! PSECT SECTION HEADER
	OBJMODHDR = CSTRING('! Object Module Synopsis !'),	! OBJECT MODULE SECTION HEADER
	OMDADRHDR = CSTRING('! Module Relocatable Reference Synopsis !'), ! COUNT OF .ADDRESSES IN A MODULE
	IMAGESECTIONS = CSTRING('! Image Section Synopsis !'),	! IMAGE SECTION HEADER
	LINKWIDEHDR = CSTRING('! Image Synopsis !'),		! LINK-WIDE INFORMATION HEADER
	SYMBYNAME = CSTRING('! Symbols By Name !'),		! SYMBOL TABLE
	SYMBOLCREF = CSTRING('! Symbol Cross Reference !'),	! WITH CROSS REFERENCE
	SYMBYVALUE = CSTRING('! Symbols By Value !'),		! SYMBOL TABLE PRINTED BY VALUES
	LINKSTATS = CSTRING('! Link Run Statistics !');		! STATISTICS OF THE RUN
!
! SUB-HEADERS
!
OWN
    PSECTSUBHDR : VECTOR[4] INITIAL(STRINGDESC(
	'!16<Psect Name!>!18<Module Name!>!9<Base!>!14<End!>!18<Length!>!22<Align!>Attributes'),STRINGDESC(
	'!16<!10*-!>!18<!11*-!>!9<!4*-!>!14<!3*-!>!18<!6*-!>!22<!5*-!>!10*-')),
!
    OBJMODSUBHDR : VECTOR[4] INITIAL(STRINGDESC(
	'!16<Module Name!>!19<Ident!>!11<Bytes!>!36<File!>!19<Creation Date!>Creator'),STRINGDESC(
	'!16<!11*-!>!19<!5*-!>!11<!5*-!>!36<!5*-!>!19<!13*-!>!7*-')),

    OMDADRSUBHDR : VECTOR[4] INITIAL(STRINGDESC(
	'!33<Module Name!>!8<  Number!>  !33<Module Name!>!8<  Number!>  !33<Module Name!>!8<  Number!>'),STRINGDESC(
	'!33<!11*-!>!8<  !6*-!>  !33<!11*-!>!8<  !6*-!>  !33<!11*-!>!8<  !6*-!>')),
!
    CRFSUBHD1 : DESCRIPTOR ('<Symbol!>!16<Value!>!'),
    CRFSUBHD2 : DESCRIPTOR ('<Defined By!>Referenced By ...'),
    CRFSUBHD3 : DESCRIPTOR ('<!6*-!>!16<!5*-!>!'),
    CRFSUBHD4 : DESCRIPTOR ('<!10*-!>!17*-'),
    FAO_CREFSUBHD : DESCRIPTOR('!!!UL!AS!UL!AS'),			!FAO CONTROL STRING TO CREATE CRF SUB HEADER
    FAO_CRE1 : DESCRIPTOR ('!!!ULAC'),					!FAO CONTROL STRING TO CREATE FAO CONTROL STRING
!
    SYMSUBHDR : VECTOR[4] INITIAL(STRINGDESC(
	'!16<Symbol!>!19<Value!>!16<Symbol!>!19<Value!>!16<Symbol!>!19<Value!>!16<Symbol!>Value'),STRINGDESC(
	'!16<!6*-!>!19<!5*-!>!16<!6*-!>!19<!5*-!>!16<!6*-!>!19<!5*-!>!16<!6*-!>!5*-')),
!
! SYMBOL TABLE SUB-HEADER USED IF LONG SYMBOL NAME SEEN
!
    SYMLNGSUBHDR : VECTOR[4] INITIAL(STRINGDESC(
     '!32<Symbol!>!12<Value!>!32<Symbol!>!12<Value!>!32<Symbol!>!12<Value!>'),
     STRINGDESC('!32<!6*-!>!12<!5*-!>!32<!6*-!>!12<!5*-!>!32<!6*-!>!12<!5*-!>')),
!
    VALSUBHDR : VECTOR[4] INITIAL(STRINGDESC(
	'!40<Value!>Symbols...'),STRINGDESC('!40<!5*-!>!10*-')),
!
    ISDSUBHDR : VECTOR[4] INITIAL(STRINGDESC(
	'!16<   Cluster!>!5<Type!>!8<Pages!>!51<!AC!>!16<Global Sec. Name!>!12<   Match!> Majorid   Minorid'),
	STRINGDESC(
	'!16<   !7*-!>!5<!4*-!>!8<!5*-!>!9*-  !8*- !3*- !27<!21*-!>!16*-!12<   !5*-!> !7*-   !7*-'));

	PSECT OWN = $OWN$ (NOPIC,CONCATENATE,LOCAL,NOSHARE,NOEXECUTE,WRITE);
!
! READ/WRITE OWN STORAGE
!
OWN
!
! BUFFERS AND DESCRIPTORS
!
	ALIGNMENT,						! ADDRESS OF ALIGNMENT DESCRIPTION
	OUTLINE : CH$SEQUENCE[LEN$C_MAPLINE],			! OUTPUT LINE BUFFER
	OUTDES : VECTOR[2] INITIAL (LEN$C_MAPLINE,OUTLINE),	! OUTPUT LINE DESCRIPTOR
	OUTSIZE : WORD,						! SIZE OF OUTPUT STRING
	ARGS : VECTOR[10],					! FAO ARGUMENTS
	LINECNT,						! NUMBER OF LINES OUTPUT ON CURRENT PAGE
	PAGENUM,						! NEXT PAGE NUMBER
	SUBHDLINE,						! ADDR OF SUB-HEADER LINE DESCRIPTOR
	CRFSUBHDR : BLOCK[DSC$C_S_BLN*2,BYTE],
	FAO_SYM : BLOCK[8,BYTE],
	FAO_SYMDESC : BLOCK[DSC$C_S_BLN,BYTE] INITIAL (8, FAO_SYM),
	FAO_MOD : BLOCK[8,BYTE],
	FAO_MODESC : BLOCK[DSC$C_S_BLN,BYTE] INITIAL (8, FAO_MOD);
BIND
	ISDTXT = CSTRING('Base Addr  Disk VBN PFC Protection and Paging');

!
! EXTERNAL REFERENCES:
!

EXTERNAL ROUTINE
	CRF$OUT,						! CROSS REFERENCE AND SYMBOL TABLE OUTPUT
	SYS$FAO,						! FORMATTED ASCII OUTPUT
	LNK$FILNAMDSC,						! RETURN FILE NAME FROM FAB
	LIB$TRAVERSE_TREE,					! TRAVERSE BINARY TREE
	LIB$LP_LINES,						! DETERMINE NUMBER OF LINES PER PAGE
	SYS$GETTIM,						! GETS CURRENT TIME FROM SYSTEM
	LNK$STATSOUT;						! DOES ALL THE WORK

EXTERNAL LITERAL
	LIN$_CRFERR,						! CROSS REFERENCE ERROR
	LIN$_CLOSEOUT,						! CLOSE ERROR MESSAGE
	LIN$_FAOFAIL,						! FAILURE RETURN FROM FAO
	LIN$_OPENOUT,						! ERROR OPENING OUTPUT FILE
	LIN$_WRITEERR;						! ERROR MESSAGE CODE FOR PUT FAILURE

EXTERNAL
	LNK$GL_OMDADRLST,					! LIST HEAD OF OBJ MODULES WITH ADDRESS DATA
	LNK$GL_NADROMD,						! NUMBER OF OBJECT MODULES WITH ADDRESS DATA
	LNK$GL_MATCHID,						! PNTR TO GLOB SEC ID
	LNK$GB_MATCHCTL: BLOCK[,BYTE],				! GLOB SEC MATCH CTL FLG
	LNK$GL_INRELNAM,					! NAM BLOCK FOR FIRST INPUT FILE
	LNK$GL_CTLMSK : BLOCK[,BYTE],				! CONTROL BIT MASK LONGWORD
	LNK$GL_CURFIL: REF BLOCK[,BYTE],			! CURRENT FILE DESCRIPTOR
	LNK$GL_IMGFIL : REF BLOCK[,BYTE],			! IMAGE FILE DESCRIPTOR
	LNK$GL_MAPFIL : REF BLOCK[,BYTE],			! MAP FILE DESCRIPTOR
	LNK$GL_ERRLIST,						! LIST HEAD OF NON-MODULE ERRORS
	LNK$GQ_STARTIM,						! STARTING DATE AND TIME
	LNK$AW_VERSION: BLOCK[LID$C_SIZE,BYTE],			! VERSION OF LINKER
	LNK$GW_HDRBLKS: WORD,					! NUMBER OF IMAGE HEADER BLOCKS
	LNK$GW_IMGBLKS: WORD,					! NUMBER OF IMAGE BINARY BLOCKS
	LNK$GL_CURCLU : REF BLOCK[,BYTE],			! CURRENT CLUSTER DESCRIPTOR
	LNK$GL_FIXISD : REF BLOCK[,BYTE],			! ADDRESS OF FIXUP ISECT DESCRIPTOR
	LNK$GL_CLULST,						! CLUSTR LISTHEAD
	LNK$GL_MAPLST,						! LIST OF P-SECTIONS FOR MAP
	LNK$GL_MAXVA,						! MAXIMUM VIRTUAL ADDRESS ALLOCATED
	LNK$GL_MINVA,						! MINIMUM
	LNK$GL_ADREFS,						! NUMBER OF .ADDRESS FIXUPS
	LNK$GL_SHRSYMS,						! NUMBER REFERENCES TO SHAREABLE IMAGE SYMBOLS
	LNK$GW_STACK: WORD,					! SIZE OF STACK
	LNK$GW_NFILES: WORD,					! NUMBER OF FILES IN LINK
	LNK$GW_NMODULES: WORD,					! NUMBER OF MODULES IN LINK
	LNK$GW_NPSECTS: WORD,					! NUMBER OF P-SECTS IN LINK
	LNK$GW_NSYMBOLS: WORD,					! NUMBER OF SYMBOLS IN LINK
	LNK$GW_NCROSRFS : WORD,					! NUMBER OF SYMBOL CROSS REFERENCES
	LNK$GW_NUDFSYMS: WORD,					! NUMBER OF UNDEFINED SYMBOLS
	LNK$GL_TFRADR: LONG,					! USER TRANSFER ADDRESS
	LNK$GL_DBGTFR: LONG,					! DEBUGGER TRANSFER ADDRESS
	LNK$GL_OTSEPDSC : REF BLOCK[,BYTE],			! SYMBOL TABLE ENTRY FOR OTS RESERVED SYMBOL
	LNK$GW_NISECTS: WORD,					! NUMBER OF IMAGE SECTIONS
	LNK$GL_TFRPSC: LONG,					! PSECT DEFINING USER TRANSFER ADDRESS
	LNK$GL_DBGTFPS: LONG,					! PSECT DEFINING DEBUGGER TRANSFER ADDRESS
	LNK$GT_IMGNAM : VECTOR[,BYTE],				! IMAGE NAME STRING
	LNK$GT_IMGID : VECTOR[,BYTE];				! IMAGE ID STRING
!
OWN
	LASTOMD : REF BLOCK[,BYTE],				! POINTER TO LAST OBJ MODULE DESCRIPTOR
	MAPESTIM,						! ESTIMATE OF MAP LENGTH
	IMAGEFILENAME : DESCRIPTOR('No image file created'),	! STRING TO PRINT WHEN THERE
								! WAS NO IMAGE CREATED
	PSECTNAMELINE,						! 0 OR POINTER TO PSECT SYNOPSIS LINE
	AUXFNB : REF BLOCK[,BYTE],				! POINTER TO FILE'S AUXILIARY FILENAME BLOCK
	RMSERROR,						! ERROR CODE RETURNED BY RMS
	MAPRAB : $RAB(RAC = SEQ, ROP=WBH),			! SEQUENTIAL
	MAPIFI : WORD,						! SAVED INTERNAL IDENT FOR CLOSE
	SYMBOLFIELD : $CRFFIELD(FAO_STRING='!15AC',		! THE KEY 1 FIELD IS THE
				FIELD_WIDTH=15),		! SYMBOL
	SYMBOLEND : $CRFFIELDEND,
	SPACEFIELD : $CRFFIELD(FAO_STRING=' ',		! SPACES BETWEEN SYMBOL AND VALE
				FIELD_WIDTH=1),
	SPACEEND : $CRFFIELDEND,
	VALUEFIELD : $CRFFIELD(FAO_STRING='!XL',		! HEX LONGWORD VALUE
				FIELD_WIDTH=8),
	VALUEEND : $CRFFIELDEND,
	VALUEFLAGS : $CRFFIELD(FAO_STRING='!3* ',		! DEFAULT SUFFIX
				FIELD_WIDTH=3),			! WHEN NONE OF FOLLOWING APPLIES
		RELOC_SUF : $CRFFIELD(BIT_MASK=GSY$M_REL,	! RELOCATABLE ONLY
				FAO_STRING='-R ',		! SUFFIX
				FIELD_WIDTH=3),	
		UNIV_SUF : $CRFFIELD(BIT_MASK=GSY$M_UNI,	! SUFFIX ON UNIVERSAL
				FAO_STRING='-U ',
				FIELD_WIDTH=3),
		REL_UNI_SUF : $CRFFIELD(BIT_MASK=		! SUFFIX ON RELOCATABLE
				(GSY$M_UNI OR GSY$M_REL),	! AND UNIVERSAL
				FAO_STRING='-RU',
				FIELD_WIDTH=3),
		EXT_SUF :    $CRFFIELD(BIT_MASK=SYM$M_GREF,	! EXTERNAL SYMBOL, NOT RELOCATABLE
				FAO_STRING='-X ',
				FIELD_WIDTH=3),
		REL_EXT_SUF : $CRFFIELD(BIT_MASK=		! RELOCATABLE EXTERNAL SYMBOL
				(GSY$M_REL OR SYM$M_GREF),
				FAO_STRING='-RX',
				FIELD_WIDTH=3),
		UNDEF_SUF : $CRFFIELD(BIT_MASK=GSY$M_DEF,	! SUFFIX ON UNDEFINED
				SET_CLEAR=0,			! SYMBOL VALUES
				FAO_STRING='-* ',
				FIELD_WIDTH=3),
	VALFLGSEND : $CRFFIELDEND,
	REFNCEFLAGS : $CRFFIELD(FAO_STRING='!6* ',		! DEFAULT SPACES WHEN NONE OF
				FIELD_WIDTH=6),			! THE FOLLOWING REFERENCES
		WEAK_PRE : $CRFFIELD(BIT_MASK=GSY$M_WEAK,	! PREFIX FOR WEAK REFERENCE
				FAO_STRING='!3* WK-',
				FIELD_WIDTH=6),
	REFLAGSEND : $CRFFIELDEND,
	REFERENCER : $CRFFIELD(FAO_STRING='!16AC',		! NAME OF THE REFERENCING MODULE
				FIELD_WIDTH=16),
	REFERENCEND : $CRFFIELDEND,
!
	RELSYMVAL : $CRFFIELD(FAO_STRING='!4* ',
				FIELD_WIDTH=4),
		RELOC_PRE : $CRFFIELD(BIT_MASK=GSY$M_REL,
					FAO_STRING='  R-',
					FIELD_WIDTH=4),
		UNIV_PRE : $CRFFIELD(BIT_MASK=GSY$M_UNI,
					FAO_STRING='  U-',
					FIELD_WIDTH=4),
		REL_UNI_PRE : $CRFFIELD(BIT_MASK=(GSY$M_UNI OR GSY$M_REL),
					FAO_STRING=' RU-',
					FIELD_WIDTH=4),
		EXT_PRE :     $CRFFIELD(BIT_MASK=SYM$M_GREF,
					FAO_STRING='  X-',
					FIELD_WIDTH=4),
		REL_EXT_PRE : $CRFFIELD(BIT_MASK=(GSY$M_REL OR SYM$M_GREF),
					FAO_STRING=' RX-',
					FIELD_WIDTH=4),
	RELSYMVALEND : $CRFFIELDEND;
!
GLOBAL
	LNK$GQ_ENDTIM : VECTOR[2],				! END TIME IS THE TIME WE GET TO HERE
	LNK$GB_LINESPP : BYTE,					! NUMBER OF LINES PER PAGE
	LNK$GL_MAXSYMSZ : INITIAL (6),				! MAX LENGTH SYMBOL SEEN
	LNK$GL_MAXMODSZ : INITIAL (9),				! MAX LENGTH MODULE SEEN
	LNK$AL_SYTBLFMT : $CRFCTLTABLE(KEYTYPE=ASCIC,		! DEFINE THE TABLE THAT DRIVES
				ERROR=CRFERROR,
				OUTPUT = LNK$CRFOUT,
				KEY1TABLE = SYMBOLFIELD,
				KEY2TABLE = SPACEFIELD,		! THE CROSS REFERENCE TO PRODUCE
				VAL1TABLE = VALUEFIELD,		! THE FORMATED SYMBOL TABLE
				VAL2TABLE = VALUEFLAGS,		! LISTING LINES
				REF2TABLE = REFERENCER,		! EACH ENTRY HERE IS A
				REF1TABLE = REFNCEFLAGS),	! POINTER TO THE FORMATS
	LNK$AL_VALCTLTB : $CRFCTLTABLE(KEYTYPE=BIN_U32,		! DEFINE THE TABLE THAT DRIVES
				ERROR=CRFERROR,
				OUTPUT = LNK$CRFOUT,
				KEY1TABLE=VALUEFIELD,		! CREF TO PRODUCE THE CROSS
				KEY2TABLE=SPACEFIELD,		! REFERENCE OF SYMBOLS
				VAL1TABLE=SPACEFIELD,		! SORTED BY VALUE
				VAL2TABLE=SPACEFIELD,
				REF2TABLE=SYMBOLFIELD,
				REF1TABLE=RELSYMVAL);

GLOBAL ROUTINE LNK$MAPINIT: NOVALUE =				! ROUTINE TO INITIALIZE MAP FILE OUTPUT


!++
! FUNCTIONAL DESCRIPTION:
!
! THIS ROUTINE PERFORMS ALL INITIALIZATION NEEDED TO CREATE THE MAP FILE.
! IT OPENS THE MAP FILE, SETS UP THE PAGE COUNTER, LINE COUNTER, AND PERFORMS
! ANY NECESSARY TASKS DEPENDING ON THE MAP QUALIFIERS SPECIFIED BY THE USER.
! IT SETS UP THE MAP FILE PAGE HEADER AND OUTPUTS THE LINK-WIDE SUMMARY.
! AT THE PRESENT, IT IS USED TO DRIVE THE OTHER MAP ROUTINES, WHICH EVENTUALLY
! WILL BE CALLED BY THE LINKER ITSELF.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	THE TABLES CONTAINING THE LINKER DATA ARE ALREADY SET UP.
!
! IMPLICIT OUTPUTS:
!
!	THE MAP FILE IS OPENED FOR OUTPUT.
!	THE PAGE AND LINE NUMBERS ARE INTIALIZED.
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

BEGIN
	LOCAL
		EBLOCK : REF BLOCK[,BYTE],			! ERROR BLOCK POINTER
		SAVEBLOCK,
		SYMPSCADDER,					! BLOCKS ESTIMATED FOR SYMS + PSECTS
		RMSSTV,						! RMS STV CODE
		MAPFAB : BLOCK[FAB$C_BLN,BYTE];			! FILE ACCESS BLOCK - FOR OPEN AND CONNECT
!
	BIND IMGAUXFNB = LNK$GL_IMGFIL[FDB$T_AUXFNB]		! REFERENCE THE IMAGE FILE'S AUXILIARY
				: BLOCK[NAM$C_BLN,BYTE];	! FILENAME BLOCK
!
	AUXFNB = LNK$GL_MAPFIL[FDB$T_AUXFNB];			! SET ADDRESS OF AUXILIARY FILENAME BLOCK
	MAPESTIM = 7 + .LNK$GW_NMODULES/4;			! MINIMUM MAP ESTIMATE
	IF NOT .LNK$GL_CTLMSK[LNK$V_BRIEF]			! IF NOT A BRIEF MAP
	THEN BEGIN						! MUST DO SOME MORE
		IF .LNK$GL_CTLMSK[LNK$V_CROS]			! IF A CROSS REFERENCE
		THEN MAPESTIM = .MAPESTIM + .LNK$GW_NCROSRFS/20;! ADD IN AN ESTIMATE
		SYMPSCADDER = .LNK$GW_NPSECTS + .LNK$GW_NSYMBOLS/16; ! COMPUTE SYMBOL + PSECTS COMPONENT
		IF .LNK$GL_CTLMSK[LNK$V_LONG]			! IF A LONG MAP
		THEN MAPESTIM = .MAPESTIM + 2*.SYMPSCADDER	! ADD IN DOUBLE THAT
		ELSE MAPESTIM = .MAPESTIM + .SYMPSCADDER;	! ONE TIMES FOR DEFAULT FORM
	     END;
	$FAB_INIT(FAB=MAPFAB,					! INITIALIZE THE FAB
		FAC=PUT,
		RFM=VAR,
		RAT=CR,
		FNS=.LNK$GL_MAPFIL[FDB$W_USRNAMLEN],
		FNA=.LNK$GL_MAPFIL[FDB$L_USRNAMADR],
		DNS=%CHARCOUNT('.MAP'),
		DNA=UPLIT(BYTE('.MAP')),
		NAM=.AUXFNB,
		ALQ=.MAPESTIM,
		FOP=OFP);
	MAPRAB[RAB$L_FAB] = MAPFAB;				! THE RAB POINTS TO FAB FOR CONNECT
	MAPRAB[RAB$B_MBC] = MINU(.MAPESTIM,MAX_K_RMSMBC);	! SET THE MULTI-BLOCK COUNT
	AUXFNB[NAM$L_RLF] = .LNK$GL_INRELNAM;			! SET RELATED NAM BLOCK ADDRESS
	IF NOT (
		RMSERROR = $CREATE(FAB=MAPFAB);			! CREATE THE FILE
		RMSSTV = .MAPFAB[FAB$L_STV];
		.RMSERROR)
	OR NOT (
		RMSERROR = $CONNECT(RAB=MAPRAB);		! CONNECT THE RAB AND
		RMSSTV = .MAPRAB[RAB$L_STV];
		.RMSERROR)
	THEN BEGIN						! AND IF THERE IS AN ERROR
		SIGNAL(LIN$_OPENOUT,1,LNK$FILNAMDSC(MAPFAB),	! REPORT THE ERROR
				.RMSERROR,.RMSSTV);
		RETURN;						! THEN GIVE UP
	     END;
	MAPIFI = .MAPFAB[FAB$W_IFI];				! SAVE INTERNAL IDENT FOR CLOSE
	LNK$GL_CTLMSK[LNK$V_MAPOPN] = TRUE;			! SET BIT FOR MAP FILE OPEN
	CH$MOVE(DSC$C_S_BLN,LNK$FILNAMDSC(MAPFAB),		! SAVE AWAY REAL FILE NAME
			LNK$GL_MAPFIL[FDB$Q_FILENAME]);
!
! SET UP THE DESCRIPTOR OF THE IMAGE FILE (IF ANY)
!
	IF .LNK$GL_IMGFIL NEQ 0					! PROVIDED AN IMAGE WAS SPECIFIED
	THEN BEGIN
		IMAGEFILENAME[0] = .LNK$GL_IMGFIL[FDB$W_USRNAMLEN];	! SET LENGTH OF FILE NAME
		IMAGEFILENAME[1] = .LNK$GL_IMGFIL[FDB$L_USRNAMADR];	! AND POINTER TO IT
	     END;
!
! START MAP OUTPUT
!
	LNK$GB_LINESPP = LIB$LP_LINES() - 8;			! GET NUMBER OF LINES PER PAGE
	PSECTNAMELINE = 0;					! NO PSECTS YET
	SUBHDLINE = 0;						! INITIALIZE FOR NO SUB-HEADER GENERATION
	PAGENUM = 1;						! NEXT PAGE NUMBER
	IF NOT NEWPAGE() THEN RETURN;				! OUTPUT FIRST PAGE AND HEADERS
	IF NOT MAPBOX(OBJMODHDR) THEN RETURN;			! OUTPUT OBJECT MODULE SYNOPSIS HEADER
!
! IF THERE ARE ANY NON-MODULE ERRORS, DUMP THEM NOW
!
	EBLOCK = .LNK$GL_ERRLIST;				! GET LIST POINTER
	WHILE .EBLOCK  NEQ 0					! WHILE THERE ARE MORE TO DO
	DO BEGIN
	    LNK$MAPOUT(EBLOCK[OEB$T_TEXT],.EBLOCK[OEB$W_BYTCNT]); ! DUMP THE MESSAGE
	    SAVEBLOCK = .EBLOCK[OEB$L_NXTOEB];
	    EBLOCK = .SAVEBLOCK;
	    END;	
	MAPSUBHDR(OBJMODSUBHDR);				! OUTPUT OBJECT MODULE SUB-HEADER TITLE
	RETURN;
END;

ROUTINE FAOFAIL (FAO_ERRCODE) : NOVALUE =
BEGIN
!
!	THIS ROUTINE IS CALLED FOR ANY FAILURE RETURN FROM FAO
!
SIGNAL(LIN$_FAOFAIL,0,.FAO_ERRCODE);
RETURN;
END;

ROUTINE CRFERROR (ERRORCODE) : NOVALUE =
BEGIN
!
!	THIS ROUTINE IS CALLED BY THE CROSS REFERENCE PROGRAM WHENEVER
!	IT INCURRS AN ERROR. THE ROUTINE MERELY PRINTS A DIAGNOSTIC MESSAGE
!
SIGNAL(LIN$_CRFERR,0,.ERRORCODE);			! OUTPUT DIAGNOSTIC
RETURN;
END;

ROUTINE MAPFAIL: NOVALUE =				! ROUTINE TO REPORT MAP I/O FAILURE

!++
! FUNCTIONAL DESCRIPTION:
!
! THIS ROUTINE REPORTS A MAP I/O FAILURE, THEN CLOSES THE FILE CLEARING
! THE APPROPRIATE CONTROL BIT TO ENSURE NO MORE ATTEMPTS TO WRITE.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	THE MAP FILE IS CLOSED FOR OUTPUT.
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

BEGIN
	LNK$GL_CTLMSK[LNK$V_MAPOPN] = FALSE;			! TURN OFF MAP OPEN FLAG
	SIGNAL(LIN$_WRITEERR,1,					! REPORT MAP I/O FAILURE
			LNK$GL_MAPFIL[FDB$Q_FILENAME],
			.RMSERROR,.MAPRAB[RAB$L_STV]);
	LNK$CLOSMAPFIL();					! THEN CLOSE THE FILE, IF POSSIBLE
	RETURN;
END;

GLOBAL ROUTINE LNK$CLOSMAPFIL : NOVALUE =
!
!++
! FUNCTIONAL DESCRIPTION:
!
! THIS ROUTINE CLOSES THE MAP FILE
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	LNK$GL_MAPFIL = POINTER TO MAP FILE DESCRIPTOR BLOCK
!	AUXFNB        =   "      " AUXILIARY FILENAME BLOCK
!	MAPIFI        = INTERNAL FILE IDENTIFIER
!
! IMPLICIT OUTPUTS:
!
!	THE MAP FILE IS CLOSED FOR OUTPUT.
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

BEGIN
!
LOCAL
	MAPFAB : BLOCK[FAB$C_BLN,BYTE],				! FAB FOR THE CLOSE
	CLOSERROR;						! ERROR CODE RETURNED BY RMS ON CLOSE
!
IF .MAPIFI NEQ 0						! IF THE MAP FILE IS STILL OPEN,
THEN BEGIN
	$FAB_INIT(FAB=MAPFAB,
		FOP=TEF);
	MAPFAB[FAB$W_IFI] = .MAPIFI;				! INSERT THE SAVED FILE ID
	IF (CLOSERROR = $WAIT(RAB=MAPRAB))			! WAIT FOR POSSIBLE ASYNCHRONOUS OUTPUT
	THEN BEGIN						! AND IF OK
		LNK$GL_CTLMSK[LNK$V_MAPOPN] = FALSE;		! TURN OFF THE CONTROL BIT
		IF (CLOSERROR =$CLOSE(FAB=MAPFAB))		! ATTEMPT THE CLOSE AND IF IT
		THEN BEGIN					! SUCCEEDS
			MAPIFI = 0;				! WE ARE ALL DONE
			RETURN;
		     END;
	     END;						! BUT IF ANYTHING
	SIGNAL(LIN$_CLOSEOUT,1,					! FAILS, ISSUE THE ERROR MESSAGE BUT
		LNK$GL_MAPFIL[FDB$Q_FILENAME],
		.CLOSERROR,.MAPFAB[FAB$L_STV]);
	MAPIFI = 0;						! AND CLOSE IS COMPLETE
     END;
RETURN;
END;

GLOBAL ROUTINE LNK$MAPMHD(OBJREC,OBJMODDSC) : NOVALUE =	! ROUTINE TO COLLECT MHD INFORMATION

!++
! FUNCTIONAL DESCRIPTION:
!
! THIS ROUTINE EXTRACTS THE INFORMATION CONTAINED IN THE MODULE HEADER
! RECORD AND CREATES A PART OF AN OUTPUT LINE FOR THE OBJECT MODULE SYNOPSIS
! SECTION.  THE ROUTINE, LNK$MAPLNG, WILL INSERT THE LANGUAGE PROCESSOR
! INFORMATION AND ACTUALLY WRITE THE LINE.  THE INPUT PARAMETERS INCLUDE
! THE ADDRESSES OF THE MODULE HEADER RECORD AND THE OBJECT MODULE
! TABLE ENTRY.
!
! FORMAL PARAMETERS:
!
!	OBJREC -- THE ADDRESS OF THE OBJECT MODULE HEADER RECORD
!			(SUB-HEADER BYTE)
!	OBJMODDSC -- THE ADDRESS OF THE OBJECT MODULE DESCRIPTOR
!
! IMPLICIT INPUTS:
!
!	THE NECESSARY LINKER TABLES MUST BE ALREADY SET UP.
!
! IMPLICIT OUTPUTS:
!
!	THE OUTPUT LINE IS BUILT SAVE FOR THE CREATOR DATA.
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
!
BEGIN
	LOCAL
		FAO_ERRCODE,					! FAO ERROR CODE
		CRE8DATE,					! ADDRESS OF CREATION DATE
		MODIDENT: REF VECTOR[,BYTE];			! REFERENCE TO MODULE IDENT
	MAP
		OBJMODDSC: REF BLOCK[,BYTE],			! REFERENCE TO OBJ MOD DESCRIPTOR
		OBJREC: REF VECTOR[,BYTE];			! REFERENCE TO OBJECT MODULE HEADER RECORD
	BIND
		MHDREC = .OBJREC : BLOCK[,BYTE],		! NAME OBJECT RECORD AS MODULE HEADER RECORD
		OBJAUXFNB = LNK$GL_CURFIL[FDB$T_AUXFNB]		! THE AUXILIARY FILENAME BLOCK OF CURRENT OBJ
				: BLOCK[NAM$C_BLN,BYTE];
!
	LASTOMD = .OBJMODDSC;					! SAVE ADDRESS OF OBJ MODULE DESCRIPTOR
	OUTDES[0] = LEN$C_MAPLINE;				! RESET OUTPUT BUFFER DESCRIPTOR
	OUTDES[1] = OUTLINE;					! POINT TO FIRST CHARACTER OF OUTPUT LINE
	MODIDENT = MHDREC[MHD$B_NAMLNG] +  .MHDREC[MHD$B_NAMLNG] + 1;	! GET OFFSET TO VERSION
	CRE8DATE = MODIDENT[0] + .MODIDENT[0] + 1;			! GET OFFSET TO CREATION DATE
	IF .MHDREC[MHD$B_NAMLNG] LEQU SYM$C_SHORTNAME	! SHORT NAME?
	THEN IF NOT (FAO_ERRCODE = (
	    IF .MODIDENT[0] LEQU SYM$C_SHORTNAME
		THEN SYS$FAO(OBJMD_CNTRL_STR,OUTSIZE,OUTDES,
			MHDREC[MHD$B_NAMLNG],MODIDENT[0],
			.OBJMODDSC[OMD$L_ALLOC],.OBJAUXFNB[NAM$B_RSL],
			.OBJAUXFNB[NAM$L_RSA],DATE_FLD_LNG,.CRE8DATE)
		ELSE BEGIN
		    LOCAL SAVE_CODE;
		    IF NOT (SAVE_CODE = SYS$FAO(OBJMD_CNTRL_ST1,OUTSIZE,OUTDES,
			MHDREC[MHD$B_NAMLNG]))
			THEN .SAVE_CODE
			ELSE BEGIN
			    LNK$MAPOUT(OUTLINE,.OUTSIZE);
			    OUTDES[0] = LEN$C_MAPLINE;
			    OUTDES[1] = OUTLINE;
			    SYS$FAO(OBJMD_CNTRL_ST2,OUTSIZE,OUTDES,MODIDENT[0],
				.OBJMODDSC[OMD$L_ALLOC],.OBJAUXFNB[NAM$B_RSL],
				.OBJAUXFNB[NAM$L_RSA],DATE_FLD_LNG,
				.CRE8DATE)
			END
		END
				))
	    THEN FAOFAIL(.FAO_ERRCODE)
	    ELSE BEGIN
		OUTDES[1] = OUTLINE + .OUTSIZE;
		OUTDES[0] = .OUTDES[0] - .OUTSIZE;
		END
	!
	! MODULE HAS LONG NAME
	!
	ELSE IF NOT (FAO_ERRCODE=SYS$FAO(OBJMD_CNTRL_ST1,OUTSIZE,
		OUTDES,MHDREC[MHD$B_NAMLNG]))
		THEN FAOFAIL(.FAO_ERRCODE)
		ELSE BEGIN
		    LNK$MAPOUT(OUTLINE,.OUTSIZE);	! OUTPUT MODULE NAME
		    OUTDES[0] = LEN$C_MAPLINE;		! RESET
		    OUTDES[1] = OUTLINE;
		    IF NOT (FAO_ERRCODE = (
			IF .MODIDENT[0] LEQU SYM$C_SHORTNAME
			    THEN SYS$FAO(OBJMD_CNTRL_STR,
				OUTSIZE,OUTDES,BLANKS,MODIDENT[0],.OBJMODDSC[OMD$L_ALLOC],
				.OBJAUXFNB[NAM$B_RSL],.OBJAUXFNB[NAM$L_RSA],
				DATE_FLD_LNG,.CRE8DATE)
			    ELSE SYS$FAO(OBJMD_CNTRL_ST2,
				OUTSIZE,OUTDES,MODIDENT[0],.OBJMODDSC[OMD$L_ALLOC],
				.OBJAUXFNB[NAM$B_RSL],.OBJAUXFNB[NAM$L_RSA],
				DATE_FLD_LNG,.CRE8DATE)
				))
			THEN FAOFAIL(.FAO_ERRCODE)
			ELSE BEGIN
			    OUTDES[1] = OUTLINE + .OUTSIZE;	! POINT TO CREATOR FIELD
			    OUTDES[0] = .OUTDES[0] - .OUTSIZE;	
			END;
		END;
END;

GLOBAL ROUTINE LNK$MAPLNG(LANGADDR,LANGLEN) : NOVALUE =		! ROUTINE TO OUTPUT LANGUAGE PROCESSOR DATA

!++
! FUNCTIONAL DESCRIPTION:
!
! THIS ROUTINE TAKES INFORMATION FROM THE LANGUAGE PROCESSOR SUB-HEADER
! RECORD AND INSERTS IT INTO THE OBJECT MODULE OUTPUT LINE.  THIS OUTPUT
! LINE IS THEN WRITTEN TO THE MAP.
!
! FORMAL PARAMETERS:
!
!	LANGADDR -- ADDRESS OF THE LANGUAGE PROCESSOR NAME STRING
!	LANGLEN -- LENGTH OF THE LANGUAGE PROCESSOR NAME STRING
!
!
! IMPLICIT INPUTS:
!
!	THE MAIN BODY OF THE OBJECT MODULE OUTPUT LINE IS ALREADY BUILT.
!
! IMPLICIT OUTPUTS:
!
!	THE OBJECT MODULE OUTPUT LINE IS WRITTEN TO THE MAP FILE.
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	THE LANGUAGE NAME WILL BE TRUNCATED TO THE MAXIMUM ALLOWED LENGTH
!		AS DEFINED BY "LEN$C_LNGNAM"
!
!--
!
BEGIN
!
	LOCAL
		EBLOCK : REF BLOCK[,BYTE],			! POINTER TO ERROR TEXT BLOCK
		NEXTBLOCK : REF BLOCK[,BYTE],			! TEMPORARY POINTER
		FAO_ERRCODE;					! FAO ERROR CODE
!
	IF NOT (FAO_ERRCODE=SYS$FAO(CREAT_CNTRL_STR,OUTSIZE,OUTDES,		! FORMAT LINE
			MIN(LEN$C_LNGNAM,.LANGLEN),.LANGADDR))	! TRUNCATING TO MAXIMUM ALLOWED LENGTH
	THEN FAOFAIL(.FAO_ERRCODE);				! FAO FAILURE
	OUTSIZE = .OUTSIZE + .OUTDES[1] - OUTLINE;		! CALCULATE TOTAL LINE SIZE
	LNK$MAPOUT(OUTLINE,.OUTSIZE);				! OUTPUT LINE
	OUTDES[0] = LEN$C_MAPLINE;				! RESET THE OUTPUT BUFFER DESCRIPTOR
	OUTDES[1] = OUTLINE;					! FOR NEXT USAGE
!
! IF THERE IS ANY ERROR TEXT STASHED AWAY TO PRINT NOW, THEN DO IT
!
	IF (EBLOCK = .LASTOMD[OMD$L_ERRTXT]) NEQ 0		! IF THERE IS TEXT TO PRINT
	THEN WHILE .EBLOCK NEQ 0				! THEN PRINT IT ALL
	  DO BEGIN
	    LNK$MAPOUT(EBLOCK[OEB$T_TEXT],.EBLOCK[OEB$W_BYTCNT]); ! PRINT A MESSAGE
	    NEXTBLOCK = .EBLOCK[OEB$L_NXTOEB];			! GET ADDRESS OF NEXT TEXT BLOCK
	    EBLOCK = .NEXTBLOCK;				! AND GO AGAIN
	    END;
	LASTOMD[OMD$L_ERRTXT] = 0;				! CLEAR ERRTXT FIELD (USED AS NXTADR DURING PASS 2)
	LASTOMD[OMD$L_LSTERR] = 0;				! CLEAR LSTERR FIELD (WHICH IS ALSO ADRCNT DURING PASS 2)
	RETURN;							! NO MORE TO DO
END;
GLOBAL ROUTINE LNK$MAPADROMD: NOVALUE =
BEGIN
!++
! THIS ROUTINE PRINTS THE OBJECT MODULE ADDRESS DATA SYNOPSIS.
! IT IS ONLY PRINTED IF CREATING A SHAREABLE IMAGE AND A FULL
! MAP HAS BEEN GENERATED.
!
!--

LOCAL
    DESC : BLOCK[DSC$C_S_BLN,BYTE],
    STATUS,
    OUTLEN,
    OMDNUM,
    OMDPTR : REF BLOCK[,BYTE];
!
! IF NOTHING TO PRINT THEN RETURN
!
IF .LNK$GL_NADROMD EQL 0
    THEN RETURN;
!
! PRINT A BLANK LINE, FOLLOWED BY THE BOXED HEADER, AND
! THEN THE SUB-HEADER
!
IF .LINECNT + 10 GTR .LNK$GB_LINESPP		! ENSURE ROOM FOR HEADER, SUBHEADER AND FIRST LINE OF TEXT
THEN BEGIN
    LINECNT = .LNK$GB_LINESPP;
    IF NOT LNK$MAPOUT(OUTLINE,0)
	THEN RETURN;
    END;
IF NOT NEWLINE()
    OR NOT MAPBOX(OMDADRHDR)
    OR NOT MAPSUBHDR(OMDADRSUBHDR)
    THEN RETURN;
!
! OUTPUT THE INFO
!
OMDNUM = 0;
OUTLEN = 0;
CH$MOVE(DSC$C_S_BLN,OUTDES,DESC);
OMDPTR = .LNK$GL_OMDADRLST;

WHILE .OMDPTR NEQ 0
DO BEGIN
    IF NOT (STATUS = SYS$FAO(OMDADRSTR,OUTLEN,DESC,
			OMDPTR[OMD$B_NAMLNG],
			.OMDPTR[OMD$L_ADRCNT]))
		THEN FAOFAIL(.STATUS);
    DESC[DSC$W_LENGTH] = .DESC[DSC$W_LENGTH] - .OUTLEN;
    DESC[DSC$A_POINTER] = .DESC[DSC$A_POINTER] + .OUTLEN;
    OMDNUM = .OMDNUM + 1;
    IF .OMDNUM EQL 3			! IF 3 ON LINE, OUTPUT AND RESET
    THEN BEGIN
	IF NOT LNK$MAPOUT(OUTLINE,LEN$C_MAPLINE-.DESC[DSC$W_LENGTH])
	    THEN RETURN;
	OMDNUM = 0;
	CH$MOVE(DSC$C_S_BLN,OUTDES,DESC);
	END;
    OMDPTR = .OMDPTR[OMD$L_NXTADR];
    END;

IF .OMDNUM NEQ 0
    THEN LNK$MAPOUT(OUTLINE,LEN$C_MAPLINE-.DESC[DSC$W_LENGTH]);

RETURN;
END;

GLOBAL ROUTINE LNK$MAPPSCTS: NOVALUE =				! ROUTINE TO OUTPUT PSECT SYNOPSIS

!++
! FUNCTIONAL DESCRIPTION:
!
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	THE PSECT TABLES MUST HAVE ALREADY BEEN COMPLETED.
!	THE OBJECT MODULE TABLES AND THE CURRENT FILE DESCRIPTOR MUST
!	BE AVAILABLE.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
!
BEGIN
ROUTINE PRINT_PSECT(NODE) =
BEGIN
!
! ROUTINE CALLED TO PRINT ONE PSECT
!
MAP
    NODE : REF BLOCK[,BYTE];

BIND
	PSECTADDR = .NODE[NODE$L_PTR] : BLOCK[,BYTE];

LOCAL
	PSCTCONTR : REF BLOCK[,BYTE],
	PSCTOWNER : REF BLOCK[,BYTE],
	PSECTNAMEBUF : BLOCK[LEN$C_MAPLINE,BYTE],		! BUFFER FOR LAST PSECT SUMMARY LINE
	FAO_ERRCODE,						! FAO ERROR CODE
	PSECTOFFSET,						! MODULE CONTR BASE ADDR
	PSECTEND,						! END ADDRESS OF PSECT
	PSECTBASE;						! BASE ADDRESS OF PSECT
!
! OUTPUT PSECT SECTION LINES TO MAP.
!
IF (.PSECTADDR[PSC$W_FLAGS] AND GPS$M_REL) NEQ 0		! PROVIDED THAT IT IS RELOCATABLE
    AND (.PSECTADDR[PSC$W_FLAGS] AND (GPS$M_LIB OR PSC$M_SUPRES)) ! AND NOT FROM SHR LIB
			NEQ (GPS$M_LIB OR PSC$M_SUPRES) 	! SPECIALLY DEFINED PSECT
    AND (IF .LNK$GL_CTLMSK[LNK$V_LONG]				! PROVIDED IT IS LONG MAP
    THEN (IF NOT NEWLINE() THEN RETURN				! OUTPUT A NEW LINE
			ELSE TRUE)
    ELSE IF NOT .PSECTADDR[PSC$V_SUPRES]			! OR THE P-SECTION
			AND .PSECTADDR[PSC$L_LENGTH] NEQ 0 	! IS NOT EMPTY AND
			THEN TRUE				! IS NOT SUPPRESSD
			ELSE FALSE)
THEN BEGIN
		PSECTNAMELINE = 0;				! ZERO IN CASE OF NEW PAGE
		PSECTBASE = .PSECTADDR[PSC$L_BASE];		! REMEMBER BASE ADDR
		PSECTEND = .PSECTBASE + .PSECTADDR[PSC$L_LENGTH]; ! CALCULATE END ADDR
		IF (.PSECTADDR[PSC$L_LENGTH] NEQ 0) THEN PSECTEND = .PSECTEND - 1; ! CALCULATE END ADDR
		ALIGNMENT = (CASE .PSECTADDR[PSC$B_ALIGN] FROM 0 TO 9 OF ! FIND ALIGNMENT ASCIC STRING ADDRESS
			SET
			[0] : ALIGNBYTE;			! BYTE ALIGNED
			[1] : ALIGNWORD;			! WORD ALIGNED
			[2] : ALIGNLONG;			! LONGWORD ALIGNED
			[3] : ALIGNQUAD;			! QUAD WORD ALIGNED
			[4 TO 8] : ALIGN2;			! OTHER ALIGNED
			[9] : ALIGNPAGE;			! PAGE ALIGNED
			TES);					! GOT ALIGNMENT
		ARGS[0] = (IF (.PSECTADDR[PSC$W_FLAGS] AND GPS$M_PIC) EQL 0 ! DECIDE IF PSECT IS
 			THEN NOPIC				! NOT POSITION INDEPENDENT,
			ELSE PIC);				! OR IS POSITION INDEPENDENT
		ARGS[1] = (IF (.PSECTADDR[PSC$W_FLAGS] AND GPS$M_LIB) EQL 0 ! DECIDE IF PSECT IS
			THEN USR				! DEFINED BY THE USER
			ELSE LIB);				! OR FROM A LIBRARY
		ARGS[2] = (IF (.PSECTADDR[PSC$W_FLAGS] AND GPS$M_OVR) EQL 0 ! DECIDE IF PSECT IS
			THEN CON				! CONCATENATED
			ELSE OVR);				! OR OVERLAID
		ARGS[3] = (IF (.PSECTADDR[PSC$W_FLAGS] AND GPS$M_REL) EQL 0 ! DECIDE IF PSECT IS
			THEN ABS				! ABSOLUTE
			ELSE REL);				! OR RELOCATABLE
		ARGS[4] = (IF (.PSECTADDR[PSC$W_FLAGS] AND GPS$M_GBL) EQL 0 ! DECIDE IF PSECT IS
			THEN LCL				! LOCALLY DEFINED
			ELSE GBL);				! OR GLOBALLY DEFINED
		ARGS[5] = (IF (.PSECTADDR[PSC$W_FLAGS] AND GPS$M_SHR) EQL 0 ! DECIDE IF PSECT IS
			THEN NOSHR				! NOT SHAREABLE
			ELSE SHR);				! OR IS SHAREABLE
		ARGS[6] = (IF (.PSECTADDR[PSC$W_FLAGS] AND GPS$M_EXE) EQL 0 ! DECIDE IF PSECT IS
			THEN NOEXE				! NOT EXECUTABLE
			ELSE EXE);				! OR IS EXECUTABLE
		ARGS[7] = (IF (.PSECTADDR[PSC$W_FLAGS] AND GPS$M_RD) EQL 0 ! DECIDE IF PSECT IS
			THEN NORD				! NOT READABLE
			ELSE RD);				! OR IS READABLE
		ARGS[8] = (IF (.PSECTADDR[PSC$W_FLAGS] AND GPS$M_WRT) EQL 0 ! DECIDE IF PSECT IS
			THEN NOWRT				! NOT WRITEABLE
			ELSE WRT);				! OR IS WRITEABLE
		ARGS[9] = (IF (.PSECTADDR[PSC$W_FLAGS] AND GPS$M_VEC) EQL 0 ! 
					THEN NOVEC
					ELSE VEC);
		IF NOT (FAO_ERRCODE = (
		   IF .PSECTADDR[PSC$B_NAMLNG] LEQU SYM$C_SHORTNAME
			THEN SYS$FAO(PSC_CNTRL_STR,OUTSIZE,OUTDES,
			    PSECTADDR[PSC$B_NAMLNG],BLANKS, ! FORMAT THE PSECT SUMMARY ALLOCATION LINE
			    .PSECTADDR[PSC$L_BASE],.PSECTEND,.PSECTADDR[PSC$L_LENGTH],
			    .PSECTADDR[PSC$L_LENGTH],.ALIGNMENT,.PSECTADDR[PSC$B_ALIGN],
			    .ARGS[0],.ARGS[1],.ARGS[2],.ARGS[3],.ARGS[4],
			    .ARGS[5],.ARGS[6],.ARGS[7],.ARGS[8],.ARGS[9])
			ELSE SYS$FAO(PSC_CNTRL_ST1,OUTSIZE,OUTDES,
			    PSECTADDR[PSC$B_NAMLNG],
			    .PSECTADDR[PSC$L_BASE],.PSECTEND,.PSECTADDR[PSC$L_LENGTH],
			    .PSECTADDR[PSC$L_LENGTH],.ALIGNMENT,.PSECTADDR[PSC$B_ALIGN],
			    .ARGS[0],.ARGS[1],.ARGS[2],.ARGS[3],.ARGS[4],
			    .ARGS[5],.ARGS[6],.ARGS[7],.ARGS[8],.ARGS[9])
				))
		THEN FAOFAIL(.FAO_ERRCODE)
		ELSE IF NOT LNK$MAPOUT(OUTLINE,.OUTSIZE)	! OUTPUT THE PSECT ALLOCATION SUMMARY LINE
				THEN RETURN;			! NO MORE OUTPUT, I/O FAILURE
		CH$COPY (.OUTSIZE, OUTLINE, %ASCII ' ', LEN$C_MAPLINE, PSECTNAMEBUF);	! COPY PSECT SUMMARY LINE TO BUFFER
		PSECTNAMELINE = PSECTNAMEBUF;						! AND FLAG WE HAVE ONE
		PSCTCONTR = .PSECTADDR[PSC$L_MPCLST];		! GET THE FIRST CONTRIBUTING OBJECT MODULE
		WHILE (.PSCTCONTR NEQ 0) DO			! LOOP ONCE FOR EACH CONTRIBUTOR
			BEGIN
			PSECTOFFSET = .PSECTBASE + .PSCTCONTR[MPC$L_OFFSET]; ! CALCULATE BASE OF THIS CONTRIBUTION
			PSECTEND = .PSECTOFFSET + .PSCTCONTR[MPC$L_LENGTH]; ! CALCULATE END OF THIS CONTRIBUTION
			IF (.PSCTCONTR[MPC$L_LENGTH] NEQ 0) THEN PSECTEND = .PSECTEND - 1; ! CALCULATE END ADDRESS
			ALIGNMENT = (CASE .PSCTCONTR[MPC$B_ALIGN] FROM 0 TO 9 OF ! FIND ALIGNMENT OF THIS CONTRIBUTION
				SET
				[0] : ALIGNBYTE;		! BYTE ALIGNED
				[1] : ALIGNWORD;		! WORD ALIGNED
				[2] : ALIGNLONG;		! LONGWORD ALIGNED
				[3] : ALIGNQUAD;		! QUADWORD ALIGNED
				[4 TO 8] : ALIGN2;		! OTHER ALIGNED
				[9] : ALIGNPAGE;		! PAGE ALIGNED
				TES);				! GOT ALIGNMENT
			PSCTOWNER = .PSCTCONTR[MPC$L_OWNOMD];	! FIND OBJ MOD NAME
			IF .LNK$GL_CTLMSK[LNK$V_LONG]			! IF A FULL MAP
			OR	((.PSCTCONTR[MPC$L_LENGTH] NEQ 0)	! OR A NON ZERO CONTRIBUTION
				AND (.PSCTOWNER[OMD$B_FLAGS] AND	! FROM A MAPPED MODULE IN
						OMD$M_MAPMOD) NEQ 0)	! A DEFAULT MAP
			THEN BEGIN				! OUTPUT THE CONTRIBUTION LINE
		IF NOT (FAO_ERRCODE = (
		    IF .PSCTOWNER[OMD$B_NAMLNG] LEQU SYM$C_SHORTNAME
			THEN SYS$FAO(CONTRBSTR,OUTSIZE,OUTDES,BLANKS,
				PSCTOWNER[OMD$B_NAMLNG],
				.PSECTOFFSET,.PSECTEND,.PSCTCONTR[MPC$L_LENGTH],
				.PSCTCONTR[MPC$L_LENGTH],.ALIGNMENT,
				.PSCTCONTR[MPC$B_ALIGN])
			ELSE SYS$FAO(CONTRBST1,OUTSIZE,OUTDES,
				PSCTOWNER[OMD$B_NAMLNG],.PSECTOFFSET,
				.PSECTEND,.PSCTCONTR[MPC$L_LENGTH],
				.PSCTCONTR[MPC$L_LENGTH],.ALIGNMENT,
				.PSCTCONTR[MPC$B_ALIGN])
					))
			THEN FAOFAIL(.FAO_ERRCODE)
			ELSE IF NOT LNK$MAPOUT(OUTLINE,.OUTSIZE) ! OUTPUT CONTRIBUTING MODULE LINE
						THEN RETURN;	! NO MORE OUTPUT, I/O FAILURE
			END;
			PSCTCONTR = .PSCTCONTR[MPC$L_NXTMPC];	! GET NEXT CONTRIBUTING MODULE
			END;					! END THE CONTRIBUTOR LOOP
		PSECTNAMELINE = 0;			! ENSURE NO LINE PRINTED
		END;
    RETURN TRUE
END;
!
! MAIN BODY OF LNK$MAPPSCTS
!
!
! START ROUTINE OUTPUT.
!
IF .LNK$GL_CTLMSK[LNK$V_BRIEF]			! MORE THAN A BRIEF MAP?
    THEN RETURN;				! NO, RETURN
SUBHDLINE = 0;					! INITIALIZE SUBHEADER ADDR
IF .LNK$GL_CTLMSK[LNK$V_LONG]			! IF A FULL MAP
    THEN (IF NOT NEWPAGE() THEN RETURN)		! OUTPUT NEW PAGE AND HEADER
    ELSE (IF NOT NEWLINE() THEN RETURN);	! OTHERWISE JUST A NEW LINE
IF NOT MAPBOX(PSECTHDR) 			! OUTPUT PSECT HEADER
    THEN RETURN;
IF NOT MAPSUBHDR(PSECTSUBHDR)			! OUTPUT PSECT SUB-HEADER
     THEN RETURN;

LIB$TRAVERSE_TREE(LNK$GL_MAPLST,PRINT_PSECT);	! TRAVERSE TREE TO PRINT PSECTS
RETURN TRUE
END;						! OF LNK$MAPPSCTS

GLOBAL ROUTINE LNK$MAPSYMS: NOVALUE =				! ROUTINE TO OUTPUT SYMBOL INFORMATION

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE OUTPUTS ANY SYNOPSIS OF GLOBAL SYMBOLS REQUESTED BY
!	THE USER, INCLUDING THE CROSS REFERENCE SUMMARY.  IT THEN CLOSES
!	THE MAP FILE AND SPOOLS IT (IF SO REQUESTED).
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	ALL GLOBAL SYMBOLS MUST HAVE BEEN PREVIOUSLY RELOCATED AND SENT
!	TO THE CROSS REFERENCE PROGRAM FOR STORAGE.
!
! IMPLICIT OUTPUTS:
!
!	THIS ROUTINE OUTPUTS THE GLOBAL SYMBOL SYNOPSES, BASED ON THE USER
!	SPECIFIED MAP QUALIFIERS.  THESE INCLUDE THE GLOBAL SYNOPSIS ORDERED
!	BY NAME AND BY VALUE AND THE CROSS REFERENCE SUMMARY.
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
!
BEGIN
!
LOCAL
	CRFSUBHDR1 : BLOCK[LEN$C_MAPLINE,BYTE],
	CRFSUBHDR2 : BLOCK[LEN$C_MAPLINE,BYTE],
	DESC : REF BLOCK[,BYTE],
	ERRORCODE,				! LOCAL ERROR CODE
	LINESPAGE1,				! NUMBER OF LINES ON FIRST PAGE
	STRING_PTR,				! PTR TO SUBHDR FAO STRING
	CREFMODE;				! NUMBER OF SYMBOLS ACROSS PAGE IS DEFINED
						! BY THE MODE
!
PSECTNAMELINE = 0;				! ENSURE NO PSECT SUMMARY PRINTED
IF NOT .LNK$GL_CTLMSK[LNK$V_BRIEF]		! MORE THAN A BRIEF MAP?
THEN BEGIN					! YES, THEN PROCEED, ELSE SKIP
	SUBHDLINE = 0;				! NO SUB HEADER FOR NEW PAGE YET
	IF .LNK$GL_CTLMSK[LNK$V_LONG]		! IF A FULL MAP
	THEN (IF NOT NEWPAGE() THEN RETURN)	! GIVE UP IF FAIL TO GET NEW PAGE
	ELSE (IF NOT NEWLINE() THEN RETURN);	! OR NEW LINE IF NOT FULL MAP
	IF .LNK$GL_CTLMSK[LNK$V_CROS]		! PICK THE SYMBOL TABLE HEADING
	THEN BEGIN
		IF NOT MAPBOX(SYMBOLCREF) THEN RETURN;	! FOR CROSS REFERENCED OR NOT
!
! CREATE THE FAO CONTROL STRINGS FOR CREF SUB HEADER
!
		CRFSUBHDR[DSC$W_LENGTH] = LEN$C_MAPLINE;
		CRFSUBHDR[DSC$A_POINTER] = CRFSUBHDR1;
		SYS$FAO(FAO_CREFSUBHD, CRFSUBHDR, CRFSUBHDR,
			.LNK$GL_MAXSYMSZ+1, CRFSUBHD1, .LNK$GL_MAXMODSZ+6,
			CRFSUBHD2);
		DESC = CRFSUBHDR + DSC$C_S_BLN;
		DESC[DSC$W_LENGTH] = LEN$C_MAPLINE;
		DESC[DSC$A_POINTER] = CRFSUBHDR2;
		SYS$FAO(FAO_CREFSUBHD, .DESC, .DESC,
			.LNK$GL_MAXSYMSZ+1, CRFSUBHD3, .LNK$GL_MAXMODSZ+6,
			CRFSUBHD4);
		SYS$FAO(FAO_CRE1, FAO_SYMDESC, FAO_SYMDESC,
			.LNK$GL_MAXSYMSZ);
		SYS$FAO(FAO_CRE1, FAO_MODESC, FAO_MODESC,
			.LNK$GL_MAXMODSZ+1);
		SYMBOLFIELD[FLD$B_MAXLNG] = .LNK$GL_MAXSYMSZ;
		REFERENCER[FLD$B_MAXLNG] = .LNK$GL_MAXMODSZ + 1;
		CH$MOVE(DSC$C_S_BLN, FAO_SYMDESC, SYMBOLFIELD[FLD$B_FAODSC]);
		CH$MOVE(DSC$C_S_BLN, FAO_MODESC, REFERENCER[FLD$B_FAODSC]);
		IF NOT MAPSUBHDR(CRFSUBHDR) THEN RETURN;
		CREFMODE = CRF$K_DEFS_REFS;		! FULL CROSS REFERENCE
	     END
	ELSE BEGIN
		IF NOT MAPBOX(SYMBYNAME) THEN RETURN;	! GIVE UP IF FAIL TO OUTPUT THE BOXED HEADING
		STRING_PTR = SYMSUBHDR;		! ASSUME SHORT SYMBOLS
		DESC = SYM$C_SHORTNAME;
		IF .LNK$GL_MAXSYMSZ GTR SYM$C_SHORTNAME
		    THEN BEGIN
			STRING_PTR = SYMLNGSUBHDR;
			DESC = SYM$C_MAXLNG;
			END;
		SYS$FAO(FAO_CRE1, FAO_SYMDESC, FAO_SYMDESC,
			.DESC);
		CH$MOVE(DSC$C_S_BLN, FAO_SYMDESC, SYMBOLFIELD[FLD$B_FAODSC]);
		SYMBOLFIELD[FLD$B_MAXLNG] = .DESC;
		IF NOT MAPSUBHDR(.STRING_PTR) THEN RETURN;
		CREFMODE = CRF$K_VALUES;		! JUST WANT THE KEYS AND VALUES
	     END;
	LINESPAGE1 = .LNK$GB_LINESPP - .LINECNT;		! SET NUMBER OF LINES ON FIRST PAGE
	IF NOT (ERRORCODE=CRF$OUT(LNK$AL_SYTBLFMT,LEN$C_MAPLINE, ! CALL CRF TO DO THE WORK
		.LINESPAGE1,.LNK$GB_LINESPP-6,.CREFMODE,CRF$K_SAVE))
	THEN
		SIGNAL(LIN$_CRFERR,0,.ERRORCODE);
!
!	NOW FOR SYMBOLS BY VALUE IF REQUESTED
!
	IF .LNK$GL_CTLMSK[LNK$V_LONG]			! WANT A LONG MAP?
	THEN BEGIN					! YES, ADD THE VALUE CROSS REFERENCE
		SYS$FAO(FAO_CRE1, FAO_SYMDESC, FAO_SYMDESC,
			.LNK$GL_MAXSYMSZ);
		CH$MOVE(DSC$C_S_BLN, FAO_SYMDESC, SYMBOLFIELD[FLD$B_FAODSC]);
		SYMBOLFIELD[FLD$B_MAXLNG] = .LNK$GL_MAXSYMSZ;
		SUBHDLINE = 0;				! NO SUBHEADING YET
		IF NOT NEWPAGE() THEN RETURN;		! GIVE UP IF NO NEW PAGE
		IF NOT MAPBOX(SYMBYVALUE) THEN RETURN;	! GIVE UP ON FAILURE TO OUTPUT THE BOX HEADING
		IF NOT MAPSUBHDR(VALSUBHDR) THEN RETURN;! OR THE TABLE HEADING
		LINESPAGE1 = .LNK$GB_LINESPP - .LINECNT;	! SET NUMBER OF LINES ON FIRST PAGE
		IF NOT (ERRORCODE=CRF$OUT(LNK$AL_VALCTLTB,	! AND CALL CRF TO DO
			LEN$C_MAPLINE,.LINESPAGE1,	! ITS THING
			.LNK$GB_LINESPP-3,CRF$K_VALS_REFS,	! AND SAVE THE TABLE
			CRF$K_SAVE))
		THEN
			SIGNAL(LIN$_CRFERR,0,.ERRORCODE);
	     END;
     IF .LINECNT + 10 GTR .LNK$GB_LINESPP			! ENSURE ROOM FOR KEY TO SPECIAL CHARS LINE
     THEN BEGIN
	LINECNT = .LNK$GB_LINESPP;				! FORCE A NEW PAGE
	IF NOT LNK$MAPOUT(OUTLINE, 0)
	    THEN RETURN;
	END;
     INCRU I FROM 1 TO 3
	DO IF NOT LNK$MAPOUT(OUTLINE,0)				! SKIP 3 LINES
		THEN RETURN;
     IF NOT LNK$MAPOUT(CHARDEF_STR[1],.CHARDEF_STR[0])
	THEN RETURN;
     IF NOT (ERRORCODE=$FAO(ABBRVTBL1_STR,OUTSIZE,OUTDES))
	THEN FAOFAIL(.ERRORCODE)
	ELSE IF NOT LNK$MAPOUT(OUTLINE,.OUTSIZE)
	    THEN RETURN;
     INCRU I FROM 0 TO 3
     DO BEGIN
	IF NOT (ERRORCODE=$FAO(ABBRVTBL2_STR,OUTSIZE,OUTDES,.STR_POINTER[.I]))
	    THEN FAOFAIL(.ERRORCODE)
	    ELSE IF NOT LNK$MAPOUT(OUTLINE,.OUTSIZE)
		THEN RETURN;
	END;
     IF NOT (ERRORCODE=$FAO(ABBRVTBL1_STR,OUTSIZE,OUTDES))
	THEN FAOFAIL(.ERRORCODE)
	ELSE IF NOT LNK$MAPOUT(OUTLINE,.OUTSIZE)
	    THEN RETURN;
     END;
RETURN;
END;

GLOBAL ROUTINE LNK$MAPISCTS: NOVALUE =				! ROUTINE TO OUTPUT IMAGE SECTION INFORMATION
BEGIN
!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE OUTPUTS THE IMAGE SECTION SYNOPSIS.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	THE IMAGE SECTION DESCRIPTOR LIST - HEAD IS LNK$GL_ISDLST
!	AND THE IMAGE FILE DESCRIPTOR BLOCK.
!
! IMPLICIT OUTPUTS:
!
!	THIS ROUTINE OUTPUTS THE IMAGE SECTION SYNOPSIS.
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
!
LOCAL
	FAO_ERRCODE,						! FAO ERROR CODE
	MATCH_STR,						! POINTER TO MATCH CONTROL STRING
	FAO_CTL_STR,						! POINTER TO FAO CONTROL STRING
	NEXTISD : REF BLOCK[,BYTE],				! ISECT DESCRIPTOR BLOCK
	CLUSTER : REF VECTOR[,BYTE],				! ADDRESS OF CLUSTER NAME STRING
	PROPREFIX,						! ADDRESS OF "P-" OR BLANKS
	RELSFX,							! ADDRESS OF "-R" OR BLANKS
	DISKVBN,						! DISK VBN OF ISECTION
	PROTECT,						! ADDRESS OF PROTECTION STRING
	OTHERATRIBS1,						! FOR ADDITIONAL ATTRIBUTES
	OTHERATRIBS2,
	BASEVA;							! BASE VIRTUAL PAGE NUMBER
!
BIND
    IMGAUXFNB = LNK$GL_IMGFIL[FDB$T_AUXFNB]			! REFERENCE THE IMAGE FILE'S AUXILIARY
				: BLOCK[NAM$C_BLN,BYTE];	! FILENAME BLOCK
!
! RE-SET UP THE DESCRIPTOR OF THE IMAGE FILE (IF ANY), BECAUSE
!	IT IS PROBABLY CREATED NOW.
!
IF .LNK$GL_IMGFIL NEQ 0						! PROVIDED AN IMAGE WAS SPECIFIED
AND .LNK$GL_CTLMSK[LNK$V_IMAGE]					! AND SUCCESSFULLY CREATED
THEN BEGIN
	IMAGEFILENAME[0] = .IMGAUXFNB[NAM$B_RSL];		! SET LENGTH OF RESULTANT FILE NAME
	IMAGEFILENAME[1] = .IMGAUXFNB[NAM$L_RSA];		! AND POINTER TO IT
     END;
!
IF NOT .LNK$GL_CTLMSK[LNK$V_LONG]				! IF A LONG MAP
OR .LNK$GW_NISECTS EQL 0					! AND SOME IMAGE SECTIONS
    THEN RETURN;						! NO, RETURN
SUBHDLINE = 0;							! RESET HEADER LINE
IF NOT NEWPAGE() 						! GIVE UP IF FAIL TO GET NEW PAGE
    THEN RETURN;
IF NOT MAPBOX(IMAGESECTIONS) 					! AND IF THE BOX HEADING FAILS
     THEN RETURN;
IF NOT MAPSUBHDR(ISDSUBHDR,ISDTXT) 				! DITTO FOR ISECTIION SUBHEADER
    THEN RETURN;
LNK$GL_CURCLU = LNK$GL_CLULST;					! START AT TOP OF CLUSTER LIST
WHILE ( LNK$GL_CURCLU = .LNK$GL_CURCLU[CLU$L_NXTCLU]) NEQ 0 	! GET NEXT CLUSTER DESCRIPTOR
DO BEGIN
    IF NOT NEWLINE() 						! OUTPUT A BLANK LINE
	THEN RETURN;
    IF NOT .LNK$GL_CURCLU[CLU$V_BASED]				! IF CLUSTER IS NOT BASED
	AND (.LNK$GL_CURCLU[CLU$V_SHRIMG]			!  AND IS FROM A SHAREABLE IMAGE
		OR .LNK$GL_CTLMSK[LNK$V_SHR])			!  OR WE ARE CREATING A SHAREABLE IMAGE
	THEN RELSFX = HYPHEN_R					! THEN FLAG THAT IN MAP
	ELSE RELSFX = BLANKS;					! OTHERWISE USE BLANKS
    CLUSTER = LNK$GL_CURCLU[CLU$B_NAMLNG];			! SET ITS NAME POINTER
    NEXTISD = LNK$GL_CURCLU[CLU$L_FSTISD];			! GO DOWN LIST OF DESCRIPTORS
    WHILE (NEXTISD = .NEXTISD[ISL$L_NXTISD]) NEQ 0		! TILL ZERO TERMINATED END
    DO BEGIN
	BIND
	    ISECTDESC = NEXTISD[ISL$T_HDRISD] : BLOCK[,BYTE];	! POINT TO THE HEADER PART
	IF .ISECTDESC[ISD$W_PAGCNT] NEQ 0			! IF NON-NULL ISECT
	    OR .ISECTDESC[ISD$B_TYPE] EQL ISD$K_USRSTACK	!  OR THE STACK ISECT
	THEN BEGIN
	    FAO_CTL_STR = CH$PTR(ISECT_CNTRL_STR, 0);		! ASSUME ISECT IS NOT GLOBAL
	    BASEVA = .ISECTDESC[ISD$V_VPG] ^9;			! GET BASE VIRTUAL ADDRESS
	    PROPREFIX = BLANKS;					! ASSUME ISECT NOT PROTECTED
	    IF .ISECTDESC[ISD$V_PROTECT]			! IF IT IS PROTECTED
		THEN PROPREFIX = P_HYPHEN;			!  THEN TELL THAT
	    IF .ISECTDESC[ISD$V_DZRO]				! IF A DEMAND ZERO IMAGE SECTION
	    THEN BEGIN						! THERE IS NO DISK SPACE ALLOCATED
		DISKVBN = 0;					! SO ZERO THE VBN
		OTHERATRIBS1 = DEMANDZERO;			! AND SET THE DESCRIPTIONSTRING
		END
	    ELSE BEGIN
		DISKVBN = .ISECTDESC[ISD$L_VBN];		! GET BASE VBN ON DISK
		OTHERATRIBS1 = BLANKS;
		END;
	    IF .ISECTDESC[ISD$V_WRT]				! IF THE SECTION IS WRITABLE
		THEN PROTECT = READWRITE			! THEN SAY SO
		ELSE PROTECT = READONLY;			! OTHERWISE TELL THEM READ ONLY
		IF .NEXTISD EQL .LNK$GL_FIXISD			!  IF IT'S THE FIXUP SECTION
		    OR (.NEXTISD EQL .LNK$GL_CURCLU[CLU$L_FIXISD]) !  OR THE FIXUP SECTION IN ANOTHER IMAGE
		    THEN OTHERATRIBS2 = FIXUPSECTION
		    ELSE IF .ISECTDESC[ISD$V_CRF]		! IF COPY ON REFERENCE
			THEN OTHERATRIBS2 = (
					IF NOT .NEXTISD[ISL$V_REPROT]	! THEN SAY COPY ON REF
						THEN COPYONREF
						ELSE ADDRDATA)	! UNLESS IT HAS .ADDRESS DATA IN IT
			ELSE OTHERATRIBS2 = BLANKS;		! ELSE SAY NOTHING
	    IF .ISECTDESC[ISD$V_GBL]
	    THEN BEGIN
		FAO_CTL_STR = CH$PTR(GBLIS_CNTRL_STR, 0);	! USE GLOBAL ISECT FAO CONTROL STRING
		MATCH_STR =
			(SELECTONE .ISECTDESC[ISD$V_MATCHCTL] OF
				SET
				[ISD$K_MATALL]:		ALLTIME; ! SELECT MATCH = ALWAYS
				[ISD$K_MATNEV]:		NEVER;	! SELECT MATCH = NEVER
				[ISD$K_MATEQU]:		EQUAL;	! SELECT MATCH = EQUAL
				[ISD$K_MATLEQ]:		LSSEQUAL; ! SELECT MATCH = LESS/EQUAL
				[OTHERWISE]:		BLANKS;	! NO MATCH SET
				TES);
		END;
	    BEGIN
		BIND
		    GSMAJID = .(ISECTDESC[ISD$L_IDENT])<24,8,0>,	! GLOB SEC MAJOR ID
		    GSMINID = .(ISECTDESC[ISD$L_IDENT])<0,24,0>;	! GLOB SEC MINOR ID

		IF .CLUSTER[0] GTRU 16					! IF CLUSTER NAME IS LONG
		THEN BEGIN
		    IF NOT (FAO_ERRCODE=SYS$FAO(OBJMD_CNTRL_ST1,	! PUT CLUSTER NAME ON SEPARATE LINE
						OUTSIZE,OUTDES,	.CLUSTER))
			THEN FAOFAIL(.FAO_ERRCODE)
			ELSE IF NOT LNK$MAPOUT(OUTLINE,.OUTSIZE)
			    THEN RETURN;
		    CLUSTER = BLANKS;					! THEN SET CLUSTER NAME TO BLANKS
		    END;
		IF NOT (FAO_ERRCODE=SYS$FAO(.FAO_CTL_STR,OUTSIZE,OUTDES,.CLUSTER, ! GO FORMAT THE LINE
			.ISECTDESC[ISD$B_TYPE],.ISECTDESC[ISD$W_PAGCNT],
			.PROPREFIX,.BASEVA,.RELSFX,.DISKVBN,.ISECTDESC[ISD$B_PFC],
			.PROTECT,.OTHERATRIBS1,.OTHERATRIBS2,		
			ISECTDESC[ISD$T_GBLNAM],.MATCH_STR,GSMAJID,GSMINID))
		    THEN FAOFAIL(.FAO_ERRCODE)					! AND REPORT ANY ERROR
		    ELSE IF NOT LNK$MAPOUT(OUTLINE,.OUTSIZE)			! OUTPUT THE LINE
			THEN RETURN;						! AND GIVE UP ON FAILURE
		END;
	    CLUSTER = BLANKS;							! SET CLUSTER NAME TO BLANKS FOR REST OF ISECTS
	    END;							
	END;
    END;
!
! PRINT KEY TO SPECIAL CHARACTERS
!
     IF .LINECNT + 8 GTR .LNK$GB_LINESPP			! ENSURE ROOM FOR KEY TO SPECIAL CHARS LINE
     THEN BEGIN
	LINECNT = .LNK$GB_LINESPP;				! FORCE A NEW PAGE
	IF NOT LNK$MAPOUT(OUTLINE, 0)
	    THEN RETURN;
	END;
     INCRU I FROM 1 TO 3
	DO IF NOT LNK$MAPOUT(OUTLINE,0)				! SKIP 3 LINES
		THEN RETURN;
     IF NOT LNK$MAPOUT(CHARDEF_STR[1],.CHARDEF_STR[0])
	THEN RETURN;
     IF NOT (FAO_ERRCODE=$FAO(ABBRVTBL1_STR,OUTSIZE,OUTDES))
	THEN FAOFAIL(.FAO_ERRCODE)
	ELSE IF NOT LNK$MAPOUT(OUTLINE,.OUTSIZE)
	    THEN RETURN;
     INCRU I FROM 0 TO 1
     DO BEGIN
	IF NOT (FAO_ERRCODE=$FAO(ABBRVTBL2_STR,OUTSIZE,OUTDES,.ISTR_POINTER[.I]))
	    THEN FAOFAIL(.FAO_ERRCODE)
	    ELSE IF NOT LNK$MAPOUT(OUTLINE,.OUTSIZE)
		THEN RETURN;
	END;
     IF NOT (FAO_ERRCODE=$FAO(ABBRVTBL1_STR,OUTSIZE,OUTDES))
	THEN FAOFAIL(.FAO_ERRCODE)
	ELSE IF NOT LNK$MAPOUT(OUTLINE,.OUTSIZE)
	    THEN RETURN;

RETURN;								! AND ALL DONE
END;

GLOBAL ROUTINE LNK$MAPSTATS : NOVALUE =			! RUN TIME STATISTICS
BEGIN
!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE GATHERS SOME STATISTICS OF THE LINK RUN
!	AND OUTPUTS THEM TO THE MAP.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	THE MAP FILE MUST HAVE BEEN PREVIOUSLY OPENED.
!	DATA GATHERED DURING THE LINK
!
! IMPLICIT OUTPUTS:
!
!	EACH LINE IS OUTPUT TO THE MAP ON A NEW PAGE IF NEED BE.
!	THE LINE COUNTER IS INCREMENTED.
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
!
LOCAL
		FAO_ERRCODE,					! FAO ERROR CODE
		VALUE1: LONG,					! INTERMEDIATE DATA STORAGE
		VALUE2: LONG,					! INTERMEDIATE DATA STORAGE
		VALUE3: LONG,					! INTERMEDIATE DATA STORAGE
		FAO_CTL_PTR : REF BLOCK[,BYTE];			! POINTER TO FAO CONTROL STRING DESCRIPTOR
!
BIND	AUXFNB = LNK$GL_MAPFIL[FDB$T_AUXFNB]			! REFERENCE THE MAP FILE'S AUXILIARY
				: BLOCK[NAM$C_BLN,BYTE];	! FILENAME BLOCK
!
	SUBHDLINE = 0;						! RESET SUB HEADING
	IF NOT NEWPAGE() THEN RETURN;				! OUTPUT NEW PAGE FOR IMAGE SYNOPSIS
	IF NOT MAPBOX(LINKWIDEHDR) THEN RETURN;			! OUTPUT LINK-WIDE SYNOPSIS HEADER
!
! OUTPUT LINK-WIDE SYNOPSIS SECTION
!
!
! VIRTUAL MEMORY LIMITS
!
	VALUE2 = .LNK$GL_MAXVA - .LNK$GL_MINVA + 1;		! CALCULATE MEMORY SIZE IN BYTES
	VALUE1 = (.VALUE2 + 511) / 512;				! CALCULATE MEMORY SIZE IN PAGES
	IF NOT LNK$MAPOUT(OUTLINE,0)				! SKIP A LINE
	    THEN RETURN;
	IF NOT (FAO_ERRCODE=SYS$FAO(VIRMEMLINE,OUTSIZE,OUTDES,.LNK$GL_MINVA,
		.LNK$GL_MAXVA,.VALUE2,.VALUE2,.VALUE1))		! FORMAT LINE
	THEN FAOFAIL(.FAO_ERRCODE)				!
	ELSE IF NOT LNK$MAPOUT(OUTLINE,.OUTSIZE)		! OUTPUT LINE
			THEN RETURN;				! NO MORE OUTPUT, I/O FAILURE
!
! STACK SIZE
!
	IF NOT (FAO_ERRCODE=SYS$FAO(STACKLINE,OUTSIZE,OUTDES,.LNK$GW_STACK)) ! FORMAT LINE
	THEN FAOFAIL(.FAO_ERRCODE)
	ELSE IF NOT LNK$MAPOUT(OUTLINE,.OUTSIZE)		! OUTPUT LINE
			THEN RETURN;				! NO MORE OUTPUT, I/O FAILURE
!
! IMAGE HEADER VIRTUAL BLOCK UNITS
!
	IF .LNK$GW_HDRBLKS NEQ 0				! BASE BLOCK IS ALWAYS ONE (IF ANY HEADER)
	THEN IF NOT (FAO_ERRCODE=SYS$FAO(IMGHDRBLKLINE,OUTSIZE,OUTDES,1,.LNK$GW_HDRBLKS,.LNK$GW_HDRBLKS))
		THEN FAOFAIL(.FAO_ERRCODE)
		ELSE IF NOT LNK$MAPOUT(OUTLINE,.OUTSIZE)	! OUTPUT LINE
			THEN RETURN;				! NO MORE OUTPUT, I/O FAILURE
!
! IMAGE BINARY VIRTUAL BLOCK UNITS
!
	IF .LNK$GW_IMGBLKS EQL 0				! IF NO BLOCKS OF BINARY
	THEN (VALUE2 = 0; VALUE1 = 0)				! THAT IS WHAT WE PRINT
	ELSE (VALUE2 = .LNK$GW_HDRBLKS + 1;			! CALCULATE BASE BLOCK
	     VALUE1 = .VALUE2 + .LNK$GW_IMGBLKS - 1);		! CALCULATE TOP OF BINARY BLOCKS
	IF NOT (FAO_ERRCODE=SYS$FAO(IMGBINBLKLINE,OUTSIZE,OUTDES,.VALUE2,.VALUE1,.LNK$GW_IMGBLKS)) ! FORMAT LINE
		THEN FAOFAIL(.FAO_ERRCODE)
		ELSE IF NOT LNK$MAPOUT(OUTLINE,.OUTSIZE)	! OUTPUT LINE
			THEN RETURN;				! NO MORE OUTPUT, I/O FAILURE
!
! IDENTIFICATION
!
	IF NOT (FAO_ERRCODE=SYS$FAO(IDENTLINE,OUTSIZE,OUTDES,		! FORMAT LINE
			LNK$GT_IMGNAM,LNK$GT_IMGID))		! WITH THE STRINGS
	THEN FAOFAIL(.FAO_ERRCODE)
	ELSE IF NOT LNK$MAPOUT(OUTLINE,.OUTSIZE)		! OUTPUT LINE
			THEN RETURN;				! NO MORE OUTPUT, I/O FAILURE
!
! NUMBER OF FILES
!
	IF NOT (FAO_ERRCODE=SYS$FAO(NFILLINE,OUTSIZE,OUTDES,.LNK$GW_NFILES)) ! FORMAT LINE
	THEN FAOFAIL(.FAO_ERRCODE)
	ELSE IF NOT LNK$MAPOUT(OUTLINE,.OUTSIZE)		! OUTPUT LINE
			THEN RETURN;				! NO MORE OUTPUT, I/O FAILURE
!
! NUMBER OF MODULES
!
	IF NOT (FAO_ERRCODE=SYS$FAO(NMODLINE,OUTSIZE,OUTDES,.LNK$GW_NMODULES)) ! FORMAT LINE
	THEN FAOFAIL(.FAO_ERRCODE)
	ELSE IF NOT LNK$MAPOUT(OUTLINE,.OUTSIZE)		! OUTPUT LINE
			THEN RETURN;				! NO MORE OUTPUT, I/O FAILURE
!
! NUMBER OF P-SECTS
!
	IF NOT (FAO_ERRCODE=SYS$FAO(NPSCLINE,OUTSIZE,OUTDES,.LNK$GW_NPSECTS)) ! FORMAT LINE
	THEN FAOFAIL(.FAO_ERRCODE)
	ELSE IF NOT LNK$MAPOUT(OUTLINE,.OUTSIZE)		! OUTPUT LINE
			THEN RETURN;				! NO MORE OUTPUT, I/O FAILURE
!
! NUMBER OF GLOBAL SYMBOLS
!
	IF NOT (FAO_ERRCODE=SYS$FAO(NSYMLINE,OUTSIZE,OUTDES,.LNK$GW_NSYMBOLS)) ! FORMAT LINE
	THEN FAOFAIL(.FAO_ERRCODE)
	ELSE IF NOT LNK$MAPOUT(OUTLINE,.OUTSIZE)		! OUTPUT LINE
			THEN RETURN;				! NO MORE OUTPUT, I/O FAILURE
!
! INCLUDING UNDEFINED COUNT OF:
!
	IF (.LNK$GW_NUDFSYMS NEQ 0) THEN			!
		BEGIN						!
		IF NOT (FAO_ERRCODE=SYS$FAO(NUNDFLINE,OUTSIZE,OUTDES,.LNK$GW_NUDFSYMS)) ! FORMAT LINE
		THEN FAOFAIL(.FAO_ERRCODE)
		ELSE IF NOT LNK$MAPOUT(OUTLINE,.OUTSIZE)	! OUTPUT LINE
				THEN RETURN;			! NO MORE OUTPUT, I/O FAILURE
		END;
!
! NUMBER OF CROSS REFERENCES
!
	IF .LNK$GW_NCROSRFS NEQ 0
	THEN IF NOT (FAO_ERRCODE=SYS$FAO(NCROSREFS,OUTSIZE,OUTDES,.LNK$GW_NCROSRFS))
		THEN FAOFAIL(.FAO_ERRCODE)
		ELSE IF NOT LNK$MAPOUT(OUTLINE,.OUTSIZE)
			THEN RETURN;
!
! NUMBER OF IMAGE SECTIONS
!
	IF (.LNK$GW_NISECTS NEQ 0) THEN
		BEGIN
		IF NOT (FAO_ERRCODE=SYS$FAO(NISCLINE,OUTSIZE,OUTDES,.LNK$GW_NISECTS)) ! FORMAT LINE
		THEN FAOFAIL(.FAO_ERRCODE)
		ELSE IF NOT LNK$MAPOUT(OUTLINE,.OUTSIZE)	! OUTPUT LINE
				THEN RETURN;			! NO MORE OUTPUT, I/O FAILURE
		END;
IF NOT .LNK$GL_CTLMSK[LNK$V_SYS]
THEN BEGIN
!
! USER TRANSFER ADDRESS
!
	IF (.LNK$GL_TFRPSC NEQ 0) THEN
		BEGIN
		IF NOT (FAO_ERRCODE=SYS$FAO(USRTFRLINE,OUTSIZE,OUTDES,.LNK$GL_TFRADR)) ! FORMAT LINE
		THEN FAOFAIL(.FAO_ERRCODE)
		ELSE IF NOT LNK$MAPOUT(OUTLINE,.OUTSIZE)	! OUTPUT LINE
				THEN RETURN;			! NO MORE OUTPUT, I/O FAILURE
		END;						!
!
! DEBUGGER TRANSFER ADDRESS
!
	IF (.LNK$GL_DBGTFPS NEQ 0) THEN
		BEGIN
		IF NOT (FAO_ERRCODE=SYS$FAO(DBGTFRLINE,OUTSIZE,OUTDES,.LNK$GL_DBGTFR)) ! FORMAT LINE
		THEN FAOFAIL(.FAO_ERRCODE)
		ELSE IF NOT LNK$MAPOUT(OUTLINE,.OUTSIZE)	! OUTPUT LINE
				THEN RETURN;			! NO MORE OUTPUT, I/O FAILURE
		END;						!
!
! COUNT OF ADDRESS FIXUPS
!
	IF .LNK$GL_ADREFS NEQ 0
	THEN BEGIN
	    IF NOT (FAO_ERRCODE=SYS$FAO(NADREFLINE,OUTSIZE,OUTDES,.LNK$GL_ADREFS))
		THEN FAOFAIL(.FAO_ERRCODE)
		ELSE IF NOT LNK$MAPOUT(OUTLINE,.OUTSIZE)
			THEN RETURN;
	    END;
!
! COUNT OF SYMBOL REFERENCES IN SHAREABLE IMAGES
!
	IF .LNK$GL_SHRSYMS NEQ 0
	THEN BEGIN
	    IF NOT (FAO_ERRCODE=SYS$FAO(NSHRSYMLINE,OUTSIZE,OUTDES,.LNK$GL_SHRSYMS))
		THEN FAOFAIL(.FAO_ERRCODE)
		ELSE IF NOT LNK$MAPOUT(OUTLINE,.OUTSIZE)
			THEN RETURN;
	    END;
!
! OTS TRANSFER ADDRESS
!
	IF .LNK$GL_OTSEPDSC NEQ 0				! IF THE OTS TRANSFER ADDRESS WAS
	THEN BEGIN						! FOUND THEN OUTPUT IT TO
		BIND OTSEPSNB = .LNK$GL_OTSEPDSC - 
			.LNK$GL_OTSEPDSC[SYM$B_NAMLNG] - SNB$C_FXDLEN : BLOCK[,BYTE];
		IF NOT (FAO_ERRCODE=SYS$FAO(OTSTFRLINE,OUTSIZE,OUTDES,	! THE MAP ALSO. INCLUDE
			OTSEPSNB[SNB$B_NAMLNG],			! THE NAME OF THE RESERVED
			.LNK$GL_OTSEPDSC[SYM$L_VALUE]))		! ENTRY POINT AS WELL AS ADDRESS
		THEN FAOFAIL(.FAO_ERRCODE)			! REPORT ANY FORMATTING ERROR
		ELSE IF NOT LNK$MAPOUT(OUTLINE,.OUTSIZE)	! OUTPUT IT
			THEN RETURN;				! EXITING ON ERROR
	     END;
     END;
!
! IMAGE TYPE
!
	VALUE2 = BLANKS;
	FAO_CTL_PTR = CH$PTR(IMGATRLINE, 0);			! ASSUME IMAGE IS NOT SHARABLE
	IF .LNK$GL_CTLMSK[LNK$V_EXE]				! SELECT EXE IMAGE PRINT
	THEN VALUE1 = EXEIMAGE;					! LINE
	IF .LNK$GL_CTLMSK[LNK$V_SYS]				! SELECT SYS IMAGE PRINT
	THEN VALUE1 = SYSIMAGE;					! LINE
	IF .LNK$GL_CTLMSK[LNK$V_SHR]				! SELECT SHR IMAGE PRINT
	THEN BEGIN
		FAO_CTL_PTR = CH$PTR(IMGSHRLINE, 0);		! USE SHARABLE IMAGE FAO CONTROL STRING
		IF .LNK$GL_CTLMSK[LNK$V_PICIMG]
		THEN VALUE1 = PIC
		ELSE VALUE1 = NOPIC;
		VALUE2 = SHRIMAGE;
		VALUE3 =
			(SELECTONE .LNK$GB_MATCHCTL OF
				SET
				[ISD$K_MATALL]:		ALLTIME; ! SELECT MATCH = ALWAYS
				[ISD$K_MATNEV]:		NEVER; ! SELECT MATCH = NEVER
				[ISD$K_MATEQU]:		EQUAL; ! SELECT MATCH = EQUAL
				[ISD$K_MATLEQ]:		LSSEQUAL; ! SELECT MATCH = LESS/EQUAL
				[OTHERWISE]:		BLANKS; ! NO MATCH SET
				TES);
	     END;
	BEGIN
	BIND
		GSMAJID = .LNK$GL_MATCHID<24,8,0>,		! GLOB SEC MAJOR ID
		GSMINID = .LNK$GL_MATCHID<0,24,0>;		! GLOB SEC MINOR ID
	IF NOT (FAO_ERRCODE=SYS$FAO(.FAO_CTL_PTR,OUTSIZE,OUTDES,.VALUE1,.VALUE2,
			.VALUE3,GSMAJID,GSMINID))		! FORMAT LINE
	THEN FAOFAIL(.FAO_ERRCODE)
	ELSE IF NOT LNK$MAPOUT(OUTLINE,.OUTSIZE)		! OUTPUT LINE
			THEN RETURN;				! NO MORE OUTPUT, I/O FAILURE
	END;
!
!	MAP FORMAT LINE
!
	IF .LNK$GL_CTLMSK[LNK$V_BRIEF]			! SELECT BRIEF FIELD
	THEN VALUE1 = BRIEFMAP
	ELSE IF .LNK$GL_CTLMSK[LNK$V_LONG]		! SELECT LONG FIELD
	THEN VALUE1 = LONGMAP
	ELSE VALUE1 = DEFAULTMAP;
	IF .LNK$GL_CTLMSK[LNK$V_CROS]			! SELECT POSSIBLE CREF SUFFIX
	THEN VALUE2 = CREFMAP
	ELSE VALUE2 = BLANKS;
	IF NOT (FAO_ERRCODE=SYS$FAO(MAPFORMAT,OUTSIZE,OUTDES,.VALUE1,.VALUE2, ! FORMAT THE LINE
			.AUXFNB[NAM$B_RSL],.AUXFNB[NAM$L_RSA]))
	THEN FAOFAIL(.FAO_ERRCODE)					! REPORTING FAILURE
	ELSE IF NOT LNK$MAPOUT(OUTLINE,.OUTSIZE)			! OUTPUT THE LINE
		THEN RETURN;						! GIVING UP ON FAILURE
	IF NOT (FAO_ERRCODE=SYS$FAO(MAPLENGTH,OUTSIZE,OUTDES,.MAPESTIM)) ! FORMAT LENGTH ESTIMATE LINE
	THEN FAOFAIL(.FAO_ERRCODE)					! AND GIVE UP ON FAILURE
	ELSE IF NOT LNK$MAPOUT(OUTLINE,.OUTSIZE) THEN RETURN;		! OUTPUT THE LINE GIVING UP ON ERROR
!
! DONE WITH LINK-WIDE SYNOPSIS
!
	SYS$GETTIM(LNK$GQ_ENDTIM);				! GET THE TIME NOW
!
!	NOW GIVE THEM THE RUN STATISTICS
!
	IF NOT MAPBOX(LINKSTATS) THEN RETURN;		! GIVE UP ON FAILURE OF BOX HEADING
	LNK$STATSOUT();					! AND GO DO THE WORK
	RETURN;
END;

ROUTINE MAPBOX(ADDR) =				! OUTPUT HEADER IN A BOX

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE OUTPUTS A HEADER CONTAINED IN A BOX AND FOLLOWED BY 
!	A BLANK LINE.
!
! FORMAL PARAMETERS:
!
!	ADDR -- THE ADDRESS OF THE HEADER, AN ASCIC STRING CONTAINING THE
!		 SIDES OF THE BOX
!
! IMPLICIT INPUTS:
!
!	THE BOXED HEADER IS WRITTEN TO THE MAP AND FOLLOWED BY A BLANK LINE.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
!
BEGIN
	MAP
		ADDR: REF VECTOR[,BYTE];			! REFERENCE A COUNTED ASCII STRING
	LOCAL
		OUTSIZ: WORD,					! OUTPUT LINE SIZE
		CHPNTR: LONG,					! CHARACTER POINTER FOR OUTPUT LINE
		BOXPNTR: LONG,					! CHARACTER POINTER FOR OUTPUT LINE
		OUTBUFR: CH$SEQUENCE(LEN$C_MAPLINE);		! OUTPUT BUFFER
	IF NOT .LNK$GL_CTLMSK[LNK$V_MAPOPN]			! MAP FILE OPEN?
		THEN RETURN FALSE;				! NO, RETURN
	CHPNTR = CH$PTR(OUTBUFR);				! INITIALIZE CHARACTER POINTER
	OUTSIZ = (LEN$C_MAPLINE - .ADDR[0]) / 2 - 8;		! COMPUTE NUMBER OF SPACES BEFORE BOX
	CHPNTR = CH$FILL(%C' ',.OUTSIZ,.CHPNTR);		! MOVE IN SPACES
	BOXPNTR = .CHPNTR;					! REMEMBER WHERE BOX STARTS
	CHPNTR = CH$FILL(%C'+',1,.CHPNTR);			! MOVE IN BOX CORNER
	CHPNTR = CH$FILL(%C'-',.ADDR[0]-2,.CHPNTR);		! MOVE IN TOP OF BOX
	CHPNTR = CH$FILL(%C'+',1,.CHPNTR);			! MOVE IN BOX CORNER
	OUTSIZ = .OUTSIZ + .ADDR[0];				! COMPUTE LENGTH OF OUTPUT LINE
	IF NOT LNK$MAPOUT(OUTBUFR,.OUTSIZ)			! OUTPUT TOP OF BOX
		THEN RETURN FALSE;				! NO MORE OUTPUT, I/O FAILURE
	CH$MOVE(.ADDR[0],ADDR[1],.BOXPNTR);			! MOVE IN TITLE AND BOX SIDES
	IF NOT LNK$MAPOUT(OUTBUFR,.OUTSIZ)			! OUTPUT HEADER IN BOX
		THEN RETURN FALSE;				! NO MORE OUTPUT, I/O FAILURE
	CHPNTR = CH$FILL(%C'+',1,.BOXPNTR);			! MOVE IN BOX CORNER
	CHPNTR = CH$FILL(%C'-',.ADDR[0]-2,.CHPNTR);		! MOVE IN BOTTOM OF BOX
	CHPNTR = CH$FILL(%C'+',1,.CHPNTR);			! MOVE IN BOX CORNER
	IF NOT LNK$MAPOUT(OUTBUFR,.OUTSIZ)			! OUTPUT BOTTOM OF BOX
		THEN RETURN FALSE;				! NO MORE OUTPUT, I/O FAILURE
	RETURN TRUE;						! SUCCESSFUL RETURN
END;

ROUTINE LNK$CRFOUT (LINEDESC) =
BEGIN

!++
!	THIS ROUTINE IS CALLED BY CROSS REFERENCE TO OUTPUT
!	EACH LINE OF THE CROSS REFERENCE.
!
! INPUTS:
!
!	LINEDESC	ADDRESS OF A STRING DESCRIPTOR FOR THE LINE
!
!--

MAP
    LINEDESC : REF BLOCK [,BYTE];

RETURN LNK$MAPOUT (.LINEDESC [DSC$A_POINTER], .LINEDESC [DSC$W_LENGTH])
END;								! OF LNK$CRFOUT

GLOBAL ROUTINE LNK$MAPOUT(ADDR,LENGTH) =			! CONDITIONALLY OUTPUT A LINE OF THE MAP, CHECKING FOR NEW PAGE

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE OUTPUTS A LINE OF DATA TO THE MAP FILE.  IT ALSO
!	INSERTS A NEW PAGE AND THE APPROPRIATE HEADERS WHENEVER NEEDED.
!
! FORMAL PARAMETERS:
!
!	ADDR -- ADDRESS OF THE ASCII STRING TO BE OUTPUT
!	LENGTH -- LENGTH OF THE ASCII STRING TO BE OUTPUT
!
! IMPLICIT INPUTS:
!
!	THE MAP FILE MUST BE ALREADY OPEN.
!
! IMPLICIT OUTPUTS:
!
!	THE OUTPUT LINE IS WRITTEN TO THE MAP FILE.  THE PAGE COUNTER IS INCREMENTED.
!	IF THE CURRENT PAGE IS FULL, A NEW PAGE WITH HEADER LINES IS OUTPUT
!	BEFORE THE CURRENT OUTPUT LINE.
!
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
!
BEGIN
	MAP
		ADDR: REF VECTOR[,BYTE];			! REFERENCE AN OUTPUT BUFFER

	LITERAL
		LFCHAR = 10;					! LITERAL VALUE OF LINEFEED
	LOCAL
		BLENGTH,
		BPTR,
		EPTR,
		LPTR;
!
	IF NOT .LNK$GL_CTLMSK[LNK$V_MAPOPN]			! IF THE MAP FILE IS NO LONGER
	THEN RETURN TRUE;					! OPEN, RETURN IMMEDIATELY
	IF .LINECNT GEQ .LNK$GB_LINESPP				! CHECK IF A NEW PAGE IS NEEDED
	THEN IF NOT NEWPAGE() THEN RETURN FALSE;		! AND OUTPUT IT IF SO GIVING UP ON FAILURE
	IF NOT (RMSERROR = $WAIT(RAB=MAPRAB))			! WAIT FOR POSSIBLE PREVIOUS
	THEN BEGIN						! OUTPUT AND
		MAPFAIL();					! REPORT ANY ERROR
		RETURN FALSE;					! GIVING UP ON IT
	     END;
	BPTR = .ADDR;						! POINT TO START OF STRING
	EPTR = .BPTR + .LENGTH;					! COMPUTE END OF STRING
	BLENGTH = .LENGTH;
	WHILE NOT (CH$FAIL(LPTR=CH$FIND_CH(.BLENGTH,.BPTR,LFCHAR))) ! LOOK FOR MULTI-LINE OUTPUT
	DO BEGIN
	    IF NOT LNK$MAPOUT(.BPTR,.LPTR-.BPTR-1)		! WRITE OUT THE LINE
		THEN RETURN FALSE;
	    BLENGTH = .BLENGTH - (.LPTR-.BPTR+1);		! UPDATE LENGTH LEFT TO WRITE
	    BPTR = .LPTR + 1;
	    IF .BPTR GEQA .EPTR
		THEN RETURN TRUE;
	    END;
	MAPRAB[RAB$L_RBF] = .BPTR;				! SET THE RECORD ADDRESS IN RAB
	MAPRAB[RAB$W_RSZ] = .BLENGTH;				! AND THE RECORD LENGTH
	IF NOT (RMSERROR = $PUT(RAB=MAPRAB))			! AND OUTPUT IT
	THEN BEGIN						! BUT IF AN ERROR REPORT
		MAPFAIL();					! IT NOW AND
		RETURN .RMSERROR;				! AND GIVE UP
	     END;
	LINECNT = .LINECNT + 1;					! INCREMENT NUMBER OF LINES OUTPUT ON CURRENT PAGE
	RETURN TRUE;						! REPORT SUCCESS
END;

ROUTINE MAPSUBHDR(SUBHDRDSC,ARG1) =			! OUTPUT PAGE SUB HEADING
BEGIN
!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE BUILDS A SUB-HEADER TITLE AND OUTPUTS IT TO THE MAP
!	FILE.  IT INITIALIZES THE AUTOMATIC MAP SUB-HEADER GENERATION.
!
! FORMAL PARAMETERS:
!
!	SUBHDRDSC -- ADDRESS OF 2 FAO CONTROL STRING DESCRIPTORS FOR THE SUB-HEADER
!			WHICH IS ASSUMED TO BE TWO LINES LONG,
!			CONSISTING OF UNDERLINED COLUMN HEADERS
!	ARG1 -- FAO ARGUMENT FOR SUBHEADER WHICH WAS TOO LONG TO MAKE ONE
!			COUNTED ASCII STRING
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	THE SUBHEADER IS SET UP AND WRITTEN TO THE MAP FILE.  IT IS
!	STORED AS POSSIBLE OUTPUT ON FUTURE PAGES.  SUBHDLINE IS
!	INITIALIZED TO CAUSE AUTOMATIC SUB-HEADER GENERATION.  A BLANK
!	LINE IS OUTPUT FOLLOWING THE SUB-HEADER LINE.
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
!
OWN	EXTRA_FAO_ARG;						! REMEMBER PREVIOUS VALUE OF ARG1
!
BUILTIN	ACTUALCOUNT;
!
MAP	SUBHDRDSC : REF VECTOR;					! POINTER TO DESCRIPTOR VECTOR
LOCAL
		FAO_ERRCODE,					! FAO ERROR CODE
		SUBHEADLNG,					! LENGTH OF FORMATTED LINE (RETURNED BY FAO)
		SUBHEADBUF : CH$SEQUENCE(LEN$C_MAPLINE),	! BUFFER FILLED BY FAO
		SUBHEADBUFDSC : VECTOR[2];			! DESCRIPTOR OF ABOVE BUFFER
!
	IF .SUBHDRDSC EQL 0
	THEN RETURN TRUE;					! IF THERE IS NONE,RETURN
	IF ACTUALCOUNT() EQL 2					! IF A SECOND ARGUMENT PRESENT,
	THEN EXTRA_FAO_ARG = .ARG1;				! REMEMBER FOR NEXT TIME
	SUBHEADBUFDSC[0] = LEN$C_MAPLINE;			! INITIALIZE THE BUFFER DESCRIPTOR
	SUBHEADBUFDSC[1] = SUBHEADBUF;				! FOR CALL TO FAO
	IF NOT LNK$MAPOUT(SUBHEADBUF,0)				! SKIP A LINE
	    THEN RETURN FALSE;
	INCR I FROM 0 TO 2 BY 2					! LOOP TO DO BOTH LINES
	DO BEGIN
		IF NOT (FAO_ERRCODE=SYS$FAO(SUBHDRDSC[.I],SUBHEADLNG,SUBHEADBUFDSC,
				.EXTRA_FAO_ARG))		! FORMAT THE NEXT LINE
		THEN FAOFAIL(.FAO_ERRCODE);
		IF NOT LNK$MAPOUT(SUBHEADBUF,.SUBHEADLNG)	! OUTPUT IT
		THEN RETURN FALSE;				! EXITING IF FAILURE
	   END;							! END LOOP TO INSERT SUBHEADER
	SUBHDLINE = .SUBHDRDSC;					! SET A SUBHEADER ADDRESS
	RETURN TRUE;						! SUCCESSFUL RETURN
END;

ROUTINE NEWPAGE =					! OUTPUT NEW PAGE, ITS HEADING AND SUBHEADER

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE OUTPUTS A FORM FEED AND THE MAP HEADER LINE.  IT
!	CONDITIONALLY OUTPUTS A SUB-HEADER LINE.  BALNK LINES FOLLOW
!	THE HEADERS.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	A NEW PAGE WITH THE APPROPRIATE HEADERS IS WRITTEN TO THE MAP FILE.
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
!
BEGIN
!
LOCAL
	FAO_ERRCODE,						! FAO ERROR CODE
	HDRDSC : VECTOR[2],					! HEADER BUFFER DESCRIPTOR
	HDRBUF : CH$SEQUENCE[LEN$C_MAPLINE],			! HEADER BUFFER
	HDRSIZ;							! HEADER LINE LENGTH FROM FAO
!
	LINECNT = 0;						! RESET COUNT OF LINES ON CURRENT PAGE
	HDRDSC[0] = LEN$C_MAPLINE;				! INITIALIZE THE HEADER BUFFER
	HDRDSC[1] = HDRBUF;					! DESCRIPTOR FOR FAO
!
	IF NOT (FAO_ERRCODE=SYS$FAO(FF_CNTRL_STR,HDRSIZ,HDRDSC))
	THEN BEGIN
		FAOFAIL(.FAO_ERRCODE);
		RETURN FALSE;
		END;
	IF NOT LNK$MAPOUT(HDRBUF,.HDRSIZ)
	    THEN RETURN FALSE;
	IF NOT (FAO_ERRCODE=SYS$FAO(HDR_CNTRL_STR,HDRSIZ,HDRDSC,IMAGEFILENAME,
		LNK$GQ_STARTIM,MAJ_IDENT_LNG,LNK$AW_VERSION[LID$W_MAJOR],
		MIN_IDENT_LNG,LNK$AW_VERSION[LID$W_MINOR],.PAGENUM))	! FORMAT HEADER LINE
	THEN BEGIN
		FAOFAIL(.FAO_ERRCODE);
		RETURN FALSE;				! REPORT ERROR
	     END;					!
	PAGENUM = .PAGENUM + 1;				! COUNT NEW PAGE
	IF NOT LNK$MAPOUT(HDRBUF,.HDRSIZ)		! OUTPUT MAIN PAGE HEADING
	THEN RETURN FALSE;				! GIVING UP ON FAILURE
	IF NOT LNK$MAPOUT(HDRBUF,0)			! SKIP A LINE
	    THEN RETURN FALSE;
	MAPSUBHDR(.SUBHDLINE);				! OUTPUT SUB HEADING IF ANY
	IF .PSECTNAMELINE NEQ 0					! IF PRINTING PSECTS NOW
	THEN LNK$MAPOUT(.PSECTNAMELINE, LEN$C_MAPLINE);		!  THEN PRINT SUMMARY FOR CURRENT PSECT
	RETURN TRUE;						! RETURN SUCCESS STATUS
END;

ROUTINE NEWLINE =					! ROUTINE TO OUTPUT A BLANK LINE

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE OUTPUTS A BLANK LINE TO THE MAP FILE, UPDATING THE
!	LINE COUNTER.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	OUTPUTS A BLANK LINE TO THE MAP FILE.
!	INCREMENTS THE LINE COUNTER.
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
!
BEGIN
	IF NOT LNK$MAPOUT(OUTLINE,0)				! OUTPUT A BLANK LINE
	THEN RETURN FALSE;					! AND GIVE UP IF IT FAILS
	RETURN TRUE;						! REPORT SUCCESS
END;
END ELUDOM
