MODULE LNK_SYMTBLOUT (	! LINKER GLOBAL SYMBOL OUTPUT ROUTINES
		IDENT = 'V03-012',
		ADDRESSING_MODE(EXTERNAL=GENERAL,
				NONEXTERNAL=LONG_RELATIVE)
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	LINKER
!
! ABSTRACT:	THIS MODULE CONTAINS ALL LOGIC TO OUTPUT THE GLOBAL
!		SYMBOLS OF THE LINK TO SYMBOL TABLE FILE AND/OR IMAGE FILE
!
!
! ENVIRONMENT:	VMS NATIVE MODE
!
! AUTHOR:	T.J. PORTER, CREATION DATE: 14-JUL-77
!
! MODIFIED BY:
!
!	V03-012	BLS0164		Benn Schreiber		22-Mar-1982
!		Correct check for psect size in shareable image
!
!	V03-011	BLS0123		Benn Schreiber		17-Dec-1981
!		Change FAOBUG to FAOFAIL
!
!	V03-010	BLS0108		Benn Schreiber		17-Nov-1981
!		Add new shareable image psect type
!
!	V03-009	BLS0103		Benn Schreiber		13-Nov-1981
!		Minor fixes to file closing logic
!
!	V03-008	BLS0074		Benn Schreiber		29-Aug-1981
!		Move own storage into code psect, since readonly
!
!	V03-007	BLS0050		Benn Schreiber		26-Mar-1981
!		Independent shareable images
!
!	V03-006	BLS0044		Benn Schreiber		 3-Mar-1981
!		Remove errorcode argument from LNK$CLOSYMOUT, since
!		error has already been signalled.
!
!	V03-005	BLS0042		Benn Schreiber		25-Feb-1981
!		Remove deferred relocation
!
!	V03-004	BLS0035		Benn Schreiber		17-Jan-1981
!		65K psects
!
!	V03-003	BLS0025		Benn Schreiber		28-Nov-1980
!		New data structures for enhanced shareable images.
!
!	V03-002	BLS0015		Benn Schreiber		29-Aug-1980
!		Correct error code put into eom record.
!
!	V03-001	BLS0007		Benn Schreiber,		3-Jun-1980
!		Convert to MDL data structures.
!--

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
	EOMRECOUT,					! OUTPUT END OF MODULE
	HDRECSOUT,					! OUTPUT HEADER RECORDS
	OUTPUTPSECTS,					! TRAVERSE PSECT LIST TO OUTPUT PSECTS
	PSECTRECOUT,					! OUTPUT P-SECT RECORDS
	SYMRECOUT,					! OUTPUT SYMBOL RECORDS
	LNK$CLOSYMOUT : NOVALUE,			! CLOSE SYMBOL TABLES
	STBRECOUT,					! WRITE RECORD TO STB FILE
	IMGRECOUT,					! WRITE RECORD TO IMAGE FILE
	OUTPUTREC;					! WRITE THE RECORDS

!
! INCLUDE FILES:
!
LIBRARY
	'LIBL32';			! SYSTEM STRUCTURES
REQUIRE
	'PREFIX';			! USEFUL MACROS ETC.
LIBRARY
	'DATBAS';			! DATA BASE DEFINITIONS
!
! MACROS:
!

!
! EQUATED SYMBOLS:
!

LITERAL
	MAXSYMBOLREC = 512;				! MAX LENGTH OF SYMBOL RECORD
!
! EXTERNAL REFERENCES:
!
EXTERNAL LITERAL
	LIN$_CLOSEOUT,					! CLOSE FAILURE
	LIN$_FAOFAIL,					! FAO FAILURE
	LIN$_OPENOUT,					! ERROR OPENING OUTPUT FILE
	LIN$_WRITEERR,					! WRITE ERROR
	LNK$C_OBJMBC : SHORT;				! MULTI-BLOCK COUNT
!
EXTERNAL
	LNK$GT_IMGID : VECTOR[,BYTE],			! IMAGE IDENT
	LNK$GL_PSHRNUM,					! NUMBER OF HIGHEST PSECT CREATED
	LNK$GL_CLULST : VECTOR[2],			! CLUSTER DESCRIPTOR LISTHEAD
	LNK$GL_INRELNAM,				! POINTER TO FIRST INPUT FILE NAM BLOCK
	LNK$AL_IMGRAB : BLOCK[,BYTE],			! OPEN IMAGE FILE RAB
	LNK$AL_RAB : BLOCK[,BYTE],			! OBJECT RAB
	LNK$GB_MAXERCOD : BYTE,				! MAXIMUM ERROR CODE
	LNK$GB_PASS : BYTE,				! PASS NUMBER
	LNK$GL_CTLMSK : BLOCK[,BYTE],			! CONTROL MASK
	LNK$GL_IMGFIL : REF BLOCK[,BYTE],		! IMAGE FILE D.B.
	LNK$GL_SYMFIL : REF BLOCK[,BYTE],		! SYMBOL TABLE FILE
	LNK$GW_IMGIFI : WORD,				! IMAGE FILE IFI
	LNK$GL_MAPLST,					! LISTHEAD FOR USEFUL P-SECTIONS
	LNK$GL_MINVA,					! LOWEST VIRTUAL ADDRESS ALLOCATED
	LNK$GW_NSYMBOLS : WORD,				! NUMBER OF GLOBAL SYMBOLS
	LNK$GQ_STARTIM,					! START TIME/DATE
	LNK$AW_VERSION : BLOCK[,BYTE];			! LINKER VERSION

EXTERNAL ROUTINE
	LIB$TRAVERSE_TREE,				! TRAVERSE A BINARY TREE
	LNK$FILNAMDSC,					! GET FILE NAME FROM FAB
	LNK$CLOSIMGFIL;					! CLOSES IMAGE FILE
!
! MODULE OWN STORAGE:
!
GLOBAL
	LNK$GW_GSTRECS: WORD,				! COUNT OF RECORDS WRITTEN TO IMAGE GST
	LNK$GW_SYMRECS: WORD;				! COUNT OF RECORDS WRITTEN STB FILE
OWN
	EOMCODES : VECTOR[4,BYTE]			! TRANSLATE EXIT CODES
			INITIAL (BYTE(EOM$C_WARNING,	!  INTO EOM STATUS CODES
				EOM$C_SUCCESS,
				EOM$C_ERROR,
				EOM$C_ABORT)),
	STBAUXFNB : REF BLOCK [,BYTE],			! POINTER TO AUX. FNB. OF SYMBOL TABLE FILE
	STBRAB : $RAB(RAC=SEQ,MBC=LNK$C_OBJMBC),	! RECORD ACCESS BLOCK OF SYMBOL TABLE FILE
	SYMASK : WORD INITIAL(SYM$M_SUPRES),
	SYMATCH,
	STBFILEIFI,					! INTERNAL FILE ID OF SYMBOL TABLE FILE
	IMGAUXFNB : REF BLOCK[,BYTE],			! POINTER TO AUX, FNB, OF OPEN IMAGE FILE
	GSDRECLNG : WORD,				! LENGTH OF CURRENT GSD RECORD
	CURPSECTNUM : BYTE,				! NUMBER OF CURRENT P-SECTION
	OBJRECORD : REF BLOCK [,BYTE];			! POINTER TO OBJECT RECORD

BIND
	OBJRECVEC = OBJRECORD : REF VECTOR [,BYTE];	! POINT TO OBJECT RECORD AS BYTE VECTOR
!
PSECT OWN = $PLIT$;					! DEFINE READ ONLY STORAGE
OWN ABSPSECT : BLOCK[PSC$C_SIZE+9,BYTE]			! FOR THE GENERATED ABSOLUTE P-SECTION
		INITIAL (LONG(0,0),WORD(0),
			WORD ( GPS$M_PIC OR		! IT IS POSITION INDEPENDENT
				GPS$M_RD OR		! READABLE
				GPS$M_LIB),		! AND A "LIBRARY" P-SECTION
			LONG(0,0,0,0,0,0,0),
			LONG(0),
			BYTE (0),
			COUNTEDSTRING('.$$ABS$$.'));	! NAMED ".$$ABS$$."
!
PSECT	OWN = $OWN$;

GLOBAL ROUTINE LNK$SYMTBLOUT : NOVALUE =
BEGIN
!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE OUTPUTS THE GLOBAL SYMBOLS OF THE LINK.
!	THERE ARE THREE REASONS FOR GLOBAL SYMBOL OUTPUT:

!	1.  THE DEBUGGER HAS BEEN LINKED INTO AN EXECUTABLE 
!	    IMAGE.

!	2.  THE IMAGE IS A SHAREABLE IMAGE.

!	3.  A SEPARATE OUTPUT FILE OF GLOBAL SYMBOLS WAS
!	    REQUESTED BY THE LINK COMMAND.

!	1 AND 2 ARE MUTUALLY EXCLUSIVE, WHEREAS THE THIRD
!	MAY ACCOMPANY EITHER. IN CASES 1 AND 2 THE GLOBAL SYMBOLS
!	ARE OUTPUT TO THE END OF THE IMAGE FILE. IN ALL CASES,
!	THE SYMBOL TABLE OUTPUT CONFORMS TO THE OBJECT LANGUAGE
!	FORMAT. I.E. VARIABLE LENGTH RECORDS.
!	THERE IS SOME FILTERING OF SYMBOLS AND P-SECTIONS
!	ARE OUTPUT:

!	1.  NO WEAKLY DEFINED SYMBOLS 

!	2.  SYMBOLS FROM THE DEBUGGER ITSELF AND FROM SYSTEM
!	    LIBRARIES ARE SUPPRESSED IN ACCORDANCE WITH
!	    THE LINK COMMAND GIVEN.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	THE IMAGE FILE IS OPEN AND DESCRIPTORS OF IMAGE FILE
!	AND SYMBOL TABLE FILE ARE IN DYNAMIC MEMORY.
!
! IMPLICIT OUTPUTS:
!
!	SYMBOLS AND P-SECTIONS (AS REQUIRED) ARE WRITTEN TO
!	THE (APPROPRIATE) FILE(S) AND IF TO AN IMAGE,
!	THE IMAGE HEADER IS UPDATED WITH A POINTER TO
!	THE SYMBOL TABLE PATITION OF THE FILE.
!
! ROUTINE VALUE:
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
LOCAL
	FABLOCK : BLOCK[FAB$C_BLN,BYTE],			! FILE ACCESS BLOCK
	RMSERROR,						! RMS ERROR CODE RETURNED
	STVCODE,						! RMS STV CODE RETURNED
	PSECTDESC : REF BLOCK[,BYTE];				! POINTER TO P-SECT DESCRIPTOR
!
IF (.LNK$GL_CTLMSK AND (LNK$M_SHR OR LNK$M_DBG OR		! IF A SHAREABLE IMAGE
			LNK$M_SYMTBL))EQL 0			! OR DEBUGGER WITH EXECUTABLE IMAGE
THEN RETURN;							! OR A SYMBOL TABLE FILE WAS REQUESTED
OBJRECORD = .LNK$AL_RAB[RAB$L_UBF];				! INITIALIZE OUTPUT BUFFER TO BE THE
								! ONE USED FOR INPUT RECORDS CROSSING BLOCKS
$FAB_INIT(FAB=FABLOCK,						! INITIALIZE THE FAB
	FOP=PUT,
	RFM=VAR,
	MRS=MAXSYMBOLREC);

IF .LNK$GL_CTLMSK[LNK$V_SYMTBL]					! 
THEN BEGIN								! IF A SYMBOL TABLE, BUILD
	STBAUXFNB = LNK$GL_SYMFIL[FDB$T_AUXFNB];			! A FILE ACCESS BLOCK TO
	FABLOCK[FAB$L_FNA] = .LNK$GL_SYMFIL[FDB$L_USRNAMADR];		! WITH USER SPECIFIED OR
	FABLOCK[FAB$B_FNS] = .LNK$GL_SYMFIL[FDB$W_USRNAMLEN];		! COMMAND LANGUAGE DEFAULTED
	FABLOCK[FAB$B_DNS] = %CHARCOUNT('.STB');			! NAME AND DEFAULT FILE
	FABLOCK[FAB$L_DNA] = UPLIT (BYTE('.STB'));			! TYPE OF .STB
	FABLOCK[FAB$L_NAM] = .STBAUXFNB;				!
	FABLOCK[FAB$L_ALQ] = .LNK$GW_NSYMBOLS/20;			! SET INITIAL ALLOCATION
	STBRAB[RAB$L_FAB] = FABLOCK;					!
	FABLOCK[FAB$V_OFP] = TRUE;					! SET OUTPUT FILE PARSE
	STBAUXFNB[NAM$L_RLF] = .LNK$GL_INRELNAM;			! SET RELATED NAM BLOCK ADDRESS
	IF NOT (
		RMSERROR = $CREATE(FAB=FABLOCK);			! GO CREATE AND CONNECT
		CH$MOVE(DSC$C_S_BLN,LNK$FILNAMDSC(FABLOCK),		! SET RESULTANT NAME DESCRIPTOR
				LNK$GL_SYMFIL[FDB$Q_FILENAME]);
		STVCODE = .FABLOCK[FAB$L_STV];
		.RMSERROR)
	OR NOT (
		RMSERROR = $CONNECT(RAB=STBRAB);			! RECORD STREAM AND
		STVCODE = .STBRAB[RAB$L_STV];
		.RMSERROR)
	THEN BEGIN							! IF ANY FAILURE REPORT
		SIGNAL(LIN$_OPENOUT,1,LNK$GL_SYMFIL[FDB$Q_FILENAME],	! IT
			.RMSERROR,.STVCODE);
		IF (.LNK$GL_CTLMSK AND (LNK$M_SHR OR LNK$M_DBG OR	! THEN IF THERE IS
				LNK$M_IMAGE)) EQL 0			! NOTHING ELSE TO DO
		THEN RETURN;						! EXIT NOW.
	     END
	ELSE BEGIN
		STBFILEIFI = .FABLOCK[FAB$W_IFI];			! SAVE IFI IF CREATED OK
		STBRAB[RAB$L_RBF] = .OBJRECORD;				! SET RECORD BUFFER ADDRESS
	     END;
     END;
!
! IF A SHAREABLE IMAGE OR A DEBUGGER HAS BEEN LINKED IN, AND THE 
! IMAGE FILE EXISTS (I.E. IT IS STILL OPEN), CHANGE ITS ATTRIBUTES
! SO THAT VARIABLE LENGTH RECORDS MAY BE WRITTEN TO THE END OF
! IT.
!
IF (.LNK$GL_CTLMSK AND (LNK$M_SHR OR LNK$M_DBG)) NEQ 0			! SHAREABLE OR DEBUGGABLE
AND .LNK$GL_CTLMSK[LNK$V_IMAGE] NEQ 0					! IMAGE WHICH HAS BEEN
THEN BEGIN								! CREATED SUCCESSFULLY
	IMGAUXFNB = LNK$GL_IMGFIL[FDB$T_AUXFNB];			! (AND IS STILL OPEN). JAM
	FABLOCK[FAB$W_IFI] = .LNK$GW_IMGIFI;				! IFI, SET FOR BOTH BLOCK
	FABLOCK[FAB$V_BRO] = TRUE;					! AND RECORD I/O
	FABLOCK[FAB$V_ESC] = TRUE;					! AND FOR VARIABLE
	FABLOCK[FAB$L_CTX] = RME$C_SETRFM;				! LENGTH RECORDS
	LNK$AL_IMGRAB[RAB$L_FAB] = FABLOCK;				! SET FAB POINTER IN RAB
	LNK$AL_IMGRAB[RAB$V_EOF] = TRUE;				! AND END OF FILE OPTION
	IF NOT (
		RMSERROR = $MODIFY(FAB = FABLOCK);			! AND TELL RMS ABOUT IT
		STVCODE = .FABLOCK[FAB$L_STV];
		.RMSERROR)
	OR NOT (
		RMSERROR = $CONNECT(RAB=LNK$AL_IMGRAB);
		STVCODE = .LNK$AL_IMGRAB[RAB$L_STV];
		.RMSERROR)
	THEN BEGIN
		SIGNAL(LIN$_OPENOUT,1,LNK$GL_IMGFIL[FDB$Q_FILENAME],
				.RMSERROR,.STVCODE);
		LNK$CLOSYMOUT(.IMGAUXFNB);				! THEN CLOSE THE FILE
		IF .STBFILEIFI EQL 0					! IF NO OTHER SYMBOL
		THEN RETURN;						! TABLE FILE, EXIT
	     END							! HERE NOW
	ELSE BEGIN
		LNK$AL_IMGRAB[RAB$B_MBC] = LNK$C_OBJMBC;		! SET MULTI-BLOCK COUNT
		LNK$AL_IMGRAB[RAB$L_RBF] = .OBJRECORD;			! SET RECORD BUFFER ADDRESS
	     END;
     END
ELSE IF .STBFILEIFI EQL 0 THEN RETURN;					! GIVE UP IF NOTHING TO DO
!									! ADDRESS (USING OBJ INPUT BUFFER)
IF NOT HDRECSOUT()							! OUTPUT HEADER RECORDS
THEN RETURN;								! AND GIVE UP ON FAILURE
!
IF NOT PSECTRECOUT(ABSPSECT)						! OUTPUT THE ABSOLUTE P-SECTION
THEN RETURN;								! GIVING UP ON FAILURE
!
! OUTPUT THE PSECTS
!
OUTPUTPSECTS();
!
! ALL SYMBOLS AND P-SECTIONS ARE PROCESSED. WRITE AN
! END OF MODULE RECORD THEN CLOSE THE FILE(S).
!
IF NOT EOMRECOUT()							! GIVE UP ON EOM RECORD
THEN RETURN;								! OUTPUT ERROR
LNK$CLOSYMOUT(0);							! AND CLOSE FILE(S)
RETURN;
END;									! AND ALL DONE

ROUTINE HDRECSOUT =
BEGIN
!
! THIS ROUTINE OUTPUTS MODULE HEADER RECORDS TO THE
! SYMBOL TABLE FILE.
!
BIND	MHDREC = .OBJRECORD : BLOCK [,BYTE];
OWN	DATECNTRL : DESCRIPTOR('!17%D!17%D'),
	LINKNAMEVER : DESCRIPTOR ('VAX-11 Linker V!AD-!AD');
LITERAL	FILENAMELEN = 9,
	DATEFIELDLEN = 17,
	MAJ_IDENT_LNG = 2,
	MIN_IDENT_LNG = 2;
LOCAL
	FILENAME : REF BLOCK[,BYTE],
	MODHEADFIELD : REF VECTOR[,BYTE],
	DATEFIELD : VECTOR [2],
	RECLNG : WORD;
BIND	BUFFERDESC = DATEFIELD : VECTOR;
!
OBJRECORD[OBJ$B_RECTYP] = OBJ$C_HDR;					! SET RECORD TYPE
MHDREC[MHD$B_HDRTYP] = OBJ$C_HDR_MHD;					! AND HEADER SUB-TYPE
MHDREC[MHD$B_STRLVL] = OBJ$C_STRLVL;					! SET STRUCTURE LEVEL
MHDREC[MHD$W_RECSIZ] = MAXSYMBOLREC;					! SET MAX RECORD LENGTH
IF (FILENAME = .IMGAUXFNB) EQL 0					! USE IMAGE FILENAME AS MODULE
    THEN FILENAME = .STBAUXFNB;						! NAME. IF NONE USE STB FILENAME
MHDREC[MHD$B_NAMLNG]=.FILENAME[NAM$B_NAME];				! SET MODULE NAME LENGTH
MODHEADFIELD = CH$MOVE(.MHDREC[MHD$B_NAMLNG],.FILENAME[NAM$L_NAME],	! AND COPY THE NAME, SETTING
				MHDREC[MHD$T_NAME]);			! POINTER TO NEXT FIELD
MODHEADFIELD[0] = .LNK$GT_IMGID[0];					! SET LENGTH OF IDENT
DATEFIELD[1] = CH$MOVE(.MODHEADFIELD[0],LNK$GT_IMGID[1],MODHEADFIELD[1]); ! COPY IN THE IDENT
DATEFIELD[0] = 2 * DATEFIELDLEN;					! SET UP DESCRIPTOR FOR DATE
IF NOT $FAO (DATECNTRL,RECLNG,DATEFIELD,				! FIELDS AND CALL FAO TO
		LNK$GQ_STARTIM,LNK$GQ_STARTIM)				! CONVERT AND MOVE IN DATE AND TIME (TWICE)
THEN BEGIN
    SIGNAL(LIN$_FAOFAIL);						! GIVE UP WITH MESSAGE IF AN ERROR
    RETURN FALSE;
    END;
RECLNG = .RECLNG + .MODHEADFIELD[0] + .MHDREC[MHD$B_NAMLNG] + 2 +	! COMPUTE TOTAL RECORD
		MHDREC[MHD$B_NAMLNG] - OBJRECORD[OBJ$B_RECTYP];		! LENGTH
IF NOT OUTPUTREC (.RECLNG)						! AND OUTPUT THE
THEN RETURN FALSE;							! RECORD
!
! NOW BUILD THE RECORD WITH LINKER'S NAME AND VERSION.
!
OBJRECORD[OBJ$B_SUBTYP] = OBJ$C_HDR_LNM;				! CREATOR ID HEADER
BUFFERDESC[0] = MAXSYMBOLREC;						! SET LENGTH AND
BUFFERDESC[1] = OBJRECORD[OBJ$B_SUBTYP]+1;				! ADDRESS AND FAO
IF NOT $FAO (LINKNAMEVER,RECLNG,BUFFERDESC,MAJ_IDENT_LNG,		! FILLS IN THE RECORD.
		LNK$AW_VERSION[LID$W_MAJOR],MIN_IDENT_LNG,		! WITH MAJOR AND MINOR
		LNK$AW_VERSION[LID$W_MINOR])				! LINKER IDENT
THEN BEGIN								! REPORT FAO ERROR
    SIGNAL(LIN$_FAOFAIL);
    RETURN FALSE;							! AND GIVE UP
    END;
RECLNG = .RECLNG+.BUFFERDESC[1]-OBJRECORD[OBJ$B_RECTYP];		! COMPUTE RECORD LENGTH
RETURN OUTPUTREC(.RECLNG)						! OUTPUT THE RECORD AND RETURN STATUS CODE

END;

ROUTINE EOMRECOUT =
BEGIN
!
! THIS ROUTINE BUILDS AND OUTPUTS AN END OF MODULE RECORD
!
OBJRECORD[OBJ$B_RECTYP] = OBJ$C_EOM;					! SET RECORD TYPE
OBJRECORD [EOM$B_COMCOD] = .EOMCODES[MINU(EOM$C_ABORT,.LNK$GB_MAXERCOD)]; ! AND ERROR CODE
RETURN OUTPUTREC (EOM$C_EOMMIN);					! AND OUTPUT IT
END;

ROUTINE OUTPUTPSECTS =
BEGIN
!
! THIS ROUTINE OUTPUTS THE PSECTS TO THE SYMBOL TABLE
!
ROUTINE PSECT_OUT(NODE) =
BEGIN
!
! THIS ROUTINE IS CALLED BY LIB$TRAVERSE_TREE FOR EACH PSECT IN THE
! MAPPING LIST
!
!
! THE SYMBOLS IN THE SYMBOL TABLE ARE ALL LINKED ON A (SINGLY THREADED) LIST FROM
! THE PROGRAM SECTIONS WITHIN WHICH THE SYMBOLS WERE DEFINED. THEREFORE TO FIND
! ALL SYMBOLS, WE SCAN DOWN THE LINKED LIST OF P-SECTION DESCRIPTORS, THEN DOWN
! THE LIST OF SYMBOLS STRUNG OFF EACH P-SECTION DESCRIPTOR.
!
MAP
    NODE : REF BLOCK[,BYTE];

BIND
    PSECTDESC = NODE[NODE$L_PTR] : REF BLOCK[,BYTE],
    CLUDESC = PSECTDESC[PSC$L_CLUDSC] : REF BLOCK[,BYTE];

LOCAL
	SYMDESC : REF BLOCK[,BYTE],					! POINTER TO SYMBOL DESCRIPTOR
	PSCOUTFLG,							! FLAG IF PSECT WAS OUTPUT TO SYMBOL FILE
	SAVPSCNUM;							! SAVED PSECT NUMBER

IF .LNK$GL_CTLMSK[LNK$V_SHR]						! IF MAKING A SHAREABLE IMAGE
    AND .CLUDESC[CLU$V_SHRIMG]						!  AND THIS CLUSTER IS ANOTHER SHAREABLE IMAGE
    THEN RETURN TRUE;							!  THEN SKIP THIS CLUSTER
IF .LNK$GL_CTLMSK[LNK$V_SHR]						! IF SHAREABLE
    AND (.PSECTDESC[PSC$W_FLAGS] AND (GPS$M_REL OR GPS$M_GBL OR		! AND THIS P-SECTION IS RELOCATABLE,
		GPS$M_OVR)) EQL (GPS$M_REL OR GPS$M_GBL OR		! GLOBAL AND OVERLAYED
					GPS$M_OVR)
THEN BEGIN
    PSCOUTFLG = TRUE;					! PSECT WAS OUTPUT
    CURPSECTNUM = .CURPSECTNUM + 1;			! INCREMENT P-SECTION NUMBER
    IF NOT PSECTRECOUT(.PSECTDESC)			! OUTPUT THE P-SECTION
	THEN RETURN TRUE;				! RETURNING ON ERROR
    END
ELSE BEGIN
    PSCOUTFLG = FALSE;					! FLAG PSECT NOT OUTPUT
    SAVPSCNUM = .CURPSECTNUM;				! SAVE THE PSECT NUMBER
    CURPSECTNUM = 0;					! DEFINE THE SYMBOLS IN THE ABSOLUTE PSECT
    END;
IF (SYMDESC = .PSECTDESC[PSC$L_SYMLST]) NEQ 0			! IF THERE ARE SYMBOLS
    THEN DO IF (.SYMDESC[SYM$W_FLAGS] AND .SYMASK) EQL .SYMATCH	! THAT QUALIFY FOR OUTPUT
    THEN BEGIN
	IF .SYMDESC[SYM$V_REDEF]				! IF FLAGGED FOR RE-DEFINITION
	THEN BEGIN
	    SYMDESC[SYM$L_VALUE] = .SYMDESC[SYM$L_NEWVAL];	! THEN RE-DEFINE VALUE
	    IF .LNK$GL_CTLMSK[LNK$V_PICIMG]			! IF IMAGE IS STILL PIC
		AND .SYMDESC[SYM$V_REREL]			!  AND THIS SYMBOL SHOULD BE RELOCATABLE
		THEN SYMDESC[SYM$V_REL] = TRUE;			!  THEN MAKE IT SO
	    END;
	IF .LNK$GL_CTLMSK[LNK$V_PICIMG]				! IF A PIC IMAGE
	    AND .LNK$GL_CTLMSK[LNK$V_SHR]			! AND A SHAREABLE IMAGE
	    AND .SYMDESC[SYM$V_REL]				! AND SYMBOL IS RELOCATABLE
	    THEN SYMDESC[SYM$L_VALUE] = .SYMDESC[SYM$L_VALUE] -	! MAKE IT IMAGE RELATIVE
					.LNK$GL_MINVA
	    ELSE SYMDESC[SYM$V_REL] = FALSE;			! THEN SYMBOL IS ABSOLUTE
	IF .SYMDESC[SYM$V_INTSYM]				! IF INTERNAL SYMBOL
	    OR .SYMDESC[SYM$V_DEF]				! OR DEFINED
	    THEN IF NOT SYMRECOUT(.SYMDESC)			! THEN OUTPUT THE SYMBOL
		    THEN RETURN TRUE;				! GIVING UP ON AN ERROR
	END
	UNTIL (SYMDESC = .SYMDESC[SYM$L_PSCLST]) EQL 0;		! ON FAILURE
IF NOT .PSCOUTFLG
    THEN CURPSECTNUM = .SAVPSCNUM;				! RESTORE PSECT NUMBER IF NECESSARY

RETURN TRUE
END;
!
! MAIN BODY OF OUTPUTPSECTS
!
IF NOT .LNK$GL_CTLMSK[LNK$V_SHR]
THEN SYMASK = .SYMASK OR GSY$M_WEAK				! IF NOT SHAREABLE, EXCLUDE WEAK SYMBOLS
ELSE BEGIN
	SYMATCH = GSY$M_UNI;					! IF SHAREABLE, SYMBOLS MUST BE UNIVERSAL
	SYMASK = .SYMASK OR GSY$M_UNI;
    END;
!
! TRAVERSE THE TREE AND OUTPUT THE PSECTS
!
LIB$TRAVERSE_TREE(LNK$GL_MAPLST,PSECT_OUT);

RETURN OUTPUTREC(.GSDRECLNG)					! RETURN, OUTPUTTING ANY PARTIAL RECORD
END;								!OF OUTPUTPSECTS

ROUTINE STBPSCRECOUT(PSECTDESC) =
BEGIN
!
! THIS ROUTINE OUTPUTS A PSECT DEFINITION RECORD TO THE STB FILE.
!
MAP
    PSECTDESC : REF BLOCK[,BYTE];

LOCAL
    PSECTDEFREC : REF BLOCK[,BYTE];

IF .STBFILEIFI EQL 0						! IF NO STB FILE
    AND .PSECTDESC[PSC$V_REL]					!  AND PSECT IS RELOCATABLE
    THEN RETURN TRUE;						!  THEN JUST SKIP IT

IF (.GSDRECLNG+.PSECTDESC[PSC$B_NAMLNG]+GPS$C_NAME) GTRU 	! IF CURRENT RECORD DOES
					MAXSYMBOLREC		! NOT HAVE ENOUGH SPACE
THEN BEGIN
    IF NOT OUTPUTREC (.GSDRECLNG)				! WRITE IT OUT
	THEN RETURN;						! AND ZERO THE LENGTH
    GSDRECLNG = 0;
    END;
IF .GSDRECLNG EQL 0						! IF BEGINNING A NEW
THEN BEGIN							! GSD RECORD, SET
    OBJRECORD[OBJ$B_RECTYP]=OBJ$C_GSD;				! RECORD TYPE AND INITIALIZE
    GSDRECLNG = 1;						! THE LENGTH
    END;
PSECTDEFREC = OBJRECVEC [.GSDRECLNG];				! POINT TO P-SECTION PART OF RECORD
PSECTDEFREC[GPS$B_GSDTYP] = GSD$C_PSC;				! SET SUBRECORD TYPE
PSECTDEFREC[GPS$B_ALIGN] = .PSECTDESC[PSC$B_ALIGN];		! COPY ALIGNMENT
PSECTDEFREC[GPS$W_FLAGS] = .PSECTDESC[PSC$W_FLAGS]		! COPY FLAGS,
			AND NOT (PSC$M_OPTPSC OR PSC$M_USRPSC	 ! AND CLEAR UNINTERESTING BITS
				OR PSC$M_SUPRES OR PSC$M_SHRIMG);
PSECTDEFREC[GPS$L_ALLOC] = .PSECTDESC[PSC$L_BASE];		! SET ALLOCATION AS PSECT BASE
PSECTDEFREC[GPS$B_NAMLNG] = .PSECTDESC[PSC$B_NAMLNG];		! COPY LENGTH OF NAME
GSDRECLNG = .GSDRECLNG + CH$MOVE(.PSECTDESC[PSC$B_NAMLNG],	! AND THEN THE NAME
			PSECTDESC[PSC$T_NAME],
			PSECTDEFREC[GPS$T_NAME]) - .PSECTDEFREC; ! AND UPDATE LENGTH OF GSD RECORD
IF .IMGAUXFNB NEQ 0						! IF ALSO WRITING TO IMAGE FILE
    AND .PSECTDEFREC[GPS$V_REL]					!  AND THIS IS A RELOCATABLE PSECT
THEN BEGIN
    STBRECOUT(.GSDRECLNG);					! THEN OUTPUT THE RECORD TO THE STB FILE
    GSDRECLNG = 0;
    END;

RETURN TRUE
END;

ROUTINE IMGPSCRECOUT(PSECTDESC) =
BEGIN
!
! THIS ROUTINE OUTPUTS A PSECT DEFINITION RECORD TO THE IMAGE FILE
!
MAP
    PSECTDESC : REF BLOCK[,BYTE];

LOCAL
    PSECTDEFREC : REF BLOCK[,BYTE];

IF NOT .PSECTDESC[PSC$V_REL]					! IF PSECT IS ABSOLUTE
THEN BEGIN
    OUTPUTREC(.GSDRECLNG);					! OUTPUT THE RECORD, PSECT DEF ALREADY SET UP
    GSDRECLNG = 0;
    RETURN TRUE;
    END;

IF (.GSDRECLNG+.PSECTDESC[PSC$B_NAMLNG]+SGPS$C_NAME) GTRU 	! IF CURRENT RECORD DOES
					MAXSYMBOLREC		! NOT HAVE ENOUGH SPACE
THEN BEGIN
    IF NOT OUTPUTREC (.GSDRECLNG)				! WRITE IT OUT
	THEN RETURN;						! AND ZERO THE LENGTH
    GSDRECLNG = 0;
    END;
IF .GSDRECLNG EQL 0						! IF BEGINNING A NEW
THEN BEGIN							! GSD RECORD, SET
    OBJRECORD[OBJ$B_RECTYP]=OBJ$C_GSD;				! RECORD TYPE AND INITIALIZE
    GSDRECLNG = 1;						! THE LENGTH
    END;
PSECTDEFREC = OBJRECVEC [.GSDRECLNG];				! POINT TO P-SECTION PART OF RECORD
PSECTDEFREC[GPS$B_GSDTYP] = GSD$C_SPSC;				! SET SUBRECORD TYPE
PSECTDEFREC[GPS$B_ALIGN] = .PSECTDESC[PSC$B_ALIGN];		! COPY ALIGNMENT
PSECTDEFREC[GPS$W_FLAGS] = .PSECTDESC[PSC$W_FLAGS]		! COPY FLAGS,
			AND NOT (PSC$M_OPTPSC OR PSC$M_USRPSC	 ! AND CLEAR UNINTERESTING BITS
				OR PSC$M_SUPRES OR PSC$M_SHRIMG);
PSECTDEFREC[SGPS$L_ALLOC] = .PSECTDESC[PSC$L_LENGTH];		! SET PSECT ALLOCATION
IF .LNK$GL_CTLMSK[LNK$V_PICIMG]					! IF A PIC IMAGE
    THEN PSECTDEFREC[SGPS$L_BASE] = .PSECTDESC[PSC$L_BASE] - 	! THEN RECORD BASE AS IMAGE RELATIVE
					.LNK$GL_MINVA
    ELSE PSECTDEFREC[SGPS$L_BASE] = .PSECTDESC[PSC$L_BASE];	! OTHERWISE ACTUAL ADDRESS
PSECTDEFREC[SGPS$B_NAMLNG] = .PSECTDESC[PSC$B_NAMLNG];		! SET LENGTH OF NAME
GSDRECLNG = .GSDRECLNG+CH$MOVE(.PSECTDESC[PSC$B_NAMLNG],	! COPY THE P-SECTION NAME AND UPDATE RECORD LENGTH
			PSECTDESC[PSC$T_NAME],
			PSECTDEFREC[SGPS$T_NAME])-.PSECTDEFREC;

IF .STBFILEIFI NEQ 0						! IF ALSO WRITING STB FILE
THEN BEGIN
    IMGRECOUT(.GSDRECLNG);					! THEN OUTPUT THE RECORD
    GSDRECLNG = 0;
    END;

RETURN TRUE
END;

ROUTINE PSECTRECOUT(PSECTDESC) =
BEGIN
!
! THIS ROUTINE OUTPUTS A P-SECTION DEFINITION RECORD. IT ASSUMES THAT GSD
! RECORDS ARE BEING WRITTEN AND BLOCKED UP. IF ANOTHER P-SECTION DEFINITION
! RECORD WILL NOT FIT IN THE CURRENT GSD RECORD, THE RECORD IS WRITTEN
! AND ANOTHER BEGUN.
!
MAP
    PSECTDESC : REF BLOCK[,BYTE];				! BLOCK POINTER

STBPSCRECOUT(.PSECTDESC);					! OUTPUT TO STB FILE

IF .IMGAUXFNB NEQ 0						! IF WRITING TO IMAGE FILE
    THEN IMGPSCRECOUT(.PSECTDESC);				!  THEN OUTPUT TO IMAGE FILE

RETURN TRUE							! AND ALL DONE.
END;

ROUTINE SYMRECOUT (SYMDESC) =
BEGIN
!
! THIS ROUTINE BLOCKS SYMBOL DEFINITION RECORDS INTO GSD RECORDS
! AND OUTPUTS THEM TO THE SYMBOL TABLE.
!
MAP SYMDESC : REF BLOCK[,BYTE];
LOCAL	SYMDEFREC : REF BLOCK[,BYTE],
	SYMBOLSTRING : REF VECTOR[,BYTE],
	VALDATLNG,				! LENGTH OF ARG VALIDATION DATA
	MASKLENGTH;
BIND SYMDSCNAM = .SYMDESC - .SYMDESC[SYM$B_NAMLNG] - SNB$C_FXDLEN : BLOCK[,BYTE]; ! POINT TO NAME PART
IF (.SYMDESC[SYM$W_FLAGS] AND SYM$M_ENTMSK) NEQ 0			! IF THERE IS AN ENTRY
THEN MASKLENGTH = 2							! MASK, SET THE EXTRA
ELSE MASKLENGTH = 0;							! LENGTH
IF .SYMDESC[SYM$L_VALDATA] NEQ 0					! IF THERE IS VALIDATION DATA
THEN BEGIN
    BIND
	ARGVALDATA = SYMDESC[SYM$L_VALDATA] : REF VECTOR[,BYTE];	! NAME IT
    VALDATLNG = (.ARGVALDATA[0]-2)*2 + 2;				! GET LENGTH OF VALIDATION INFORMATION
    END
ELSE VALDATLNG = 0;							! OTHERWISE THERE IS NONE
IF (.GSDRECLNG+.MASKLENGTH+.SYMDESC[SYM$B_NAMLNG]+.VALDATLNG+		! IF THIS SYMBOL WOULD
			SDF$C_NAME) GTRU MAXSYMBOLREC			! OVERFLOW THE CURRENT
THEN BEGIN								! RECORD, THEN OUTPUT
	IF NOT OUTPUTREC(.GSDRECLNG)					! CURRENT RECORD AND
	THEN RETURN FALSE;						! EXIT ON ERROR
	GSDRECLNG = 0;							! RESET RECORD LENGTH
     END;
IF .GSDRECLNG EQL 0							! SET NEW RECORD AS A
THEN BEGIN
	OBJRECORD[OBJ$B_RECTYP] = OBJ$C_GSD;				! GSD RECORD
	GSDRECLNG = 1;
     END;
SYMDEFREC = OBJRECVEC [.GSDRECLNG];					! SET POINTER TO SYMBOL
IF .VALDATLNG NEQ 0							! IF THERE IS VALIDATION DATA
THEN BEGIN
    BIND
	ARGVALDATA = SYMDESC[SYM$L_VALDATA] : REF VECTOR[,BYTE], 	! POINT TO VALIDATION DATA
	FORMALDATA = SYMDEFREC[PRO$T_NAME]+
			.SYMDESC[SYM$B_NAMLNG] : BLOCK[,BYTE];		! POINTER TO THE FIXED PART OF FORMAL ARGS DESCRIPTION
    SYMDEFREC[PRO$W_MASK] = .SYMDESC[SYM$W_ENTMSK];			! SET THE ENTRY MASK
    SYMBOLSTRING = SYMDEFREC[PRO$B_NAMLNG];				! POINT TO THE NAME
    SYMDEFREC[PRO$B_GSDTYP] = OBJ$C_GSD_PRO;				! PROCEDURE DEFINITION
    FORMALDATA[FML$B_MINARGS] = .ARGVALDATA[1];				! SET MINIMUM ARG COUNT
    FORMALDATA[FML$B_MAXARGS] = .ARGVALDATA[0] - 2;			! AND MAXIMUM
    INCR I FROM 1 TO .FORMALDATA[FML$B_MAXARGS]				! LOOP THROUGH THE ARGUMENTS
    DO BEGIN
	BIND
	    ARGDESC =
		FORMALDATA[FML$B_MAXARGS]+1+((.I-1)*ARG$C_SIZE) : BLOCK[,BYTE];	! POINT TO CURRENT ARG DESCRIPTOR
	ARGDESC[ARG$B_VALCTL] = .(ARGVALDATA[1] + .I);			! GET NEXT DESCRIPTOR
	ARGDESC[ARG$B_BYTECNT] = 0;					! NO OTHER DESCRIPTOR BYTES
	END;
    END
ELSE IF .MASKLENGTH NEQ 0
THEN BEGIN								! TO SYMBOL NAME
	SYMDEFREC[EPM$W_MASK]=.SYMDESC[SYM$W_ENTMSK];			! STRING AND IF AN
	SYMBOLSTRING = SYMDEFREC[EPM$B_NAMLNG];				! ENTRY POINT DEFINITION
	SYMDEFREC[EPM$B_GSDTYP] = OBJ$C_GSD_EPM				! SET THE GSD TYPE
     END								! ALSO COPY THE ENTRY
ELSE BEGIN								! POINT MASK
	SYMBOLSTRING = SYMDEFREC[SDF$B_NAMLNG];				! DO LIKEWISE FOR
	SYMDEFREC[SDF$B_GSDTYP] = OBJ$C_GSD_SYM;			! ORDINARY SYMBOL
     END;								! DEFINITION
SYMDEFREC[SDF$B_DATYP] = .SYMDESC[SYM$B_DATYP];				! COPY DATA TYPE
SYMDEFREC[SDF$W_FLAGS] = .SYMDESC[SYM$W_FLAGS] AND (GSY$M_REL OR	! AND FLAGS
				GSY$M_WEAK OR GSY$M_UNI OR GSY$M_DEF);
IF NOT .SYMDESC[SYM$V_REL]						! IF ABSOLUTE P-SECTION
    THEN SYMDEFREC[SDF$B_PSINDX] = 0					! SET OWNING P-SECT NUMBER = 0
    ELSE SYMDEFREC[SDF$B_PSINDX] = .CURPSECTNUM;			! SET OWNING P-SECT
SYMDEFREC[SDF$L_VALUE] = .SYMDESC[SYM$L_VALUE];				! SYMBOL VALUE
GSDRECLNG = .GSDRECLNG+CH$MOVE(.SYMDSCNAM[SNB$B_NAMLNG]+1,		! COPY THE SYMBOL
			SYMDSCNAM[SNB$B_NAMLNG],SYMBOLSTRING[0])- 	! NAME (COUNTED STRING)
			.SYMDEFREC+.VALDATLNG;				! AND UPDATE LENGTH
RETURN TRUE;								! AND IT IS ALL
END;									! DONE.

ROUTINE STBRECOUT(RECLNG) =
BEGIN
!
!	THIS ROUTINE WRITES TO THE STB FILE IF ONE IS BEING CREATED
!
!	RECLNG		LENGTH OF RECORD TO WRITE
!
LOCAL
    RMSERROR;

IF .RECLNG NEQ 0				! IF NON-ZERO LENGTH RECORD
    AND .STBFILEIFI NEQ 0			! AND WE ARE WRITING TO THE STB FILE
THEN BEGIN
    STBRAB[RAB$W_RSZ] = .RECLNG;		! SET RECORD LENGTH
    IF NOT (RMSERROR = $PUT(RAB=STBRAB))	! WRITE THE RECORD
    THEN BEGIN
	SIGNAL(LIN$_WRITEERR,1,			! SIGNAL ANY ERRORS
		LNK$GL_SYMFIL[FDB$Q_FILENAME],
		.RMSERROR,.STBRAB[RAB$L_STV]);
	LNK$CLOSYMOUT(.STBAUXFNB);		! CLOSE THE FILE IF ERROR
	IF .IMGAUXFNB EQL 0			! IF NO IMAGE FILE BEING CREATED
	    THEN RETURN FALSE;			!  THEN ALL DONE NOW
	END
    ELSE LNK$GW_SYMRECS = .LNK$GW_SYMRECS + 1;	! COUNT GOOD RECORD WRITTEN TO THE FILE
    END;

RETURN TRUE
END;

ROUTINE IMGRECOUT(RECLNG) =
BEGIN
!
!	THIS ROUTINE WRITES TO THE IMAGE FILE
!
!	RECLNG		LENGTH OF RECORD
!
LOCAL
    RMSERROR;

IF .RECLNG NEQ 0				! IF NON-ZERO LENGTH
    AND .IMGAUXFNB NEQ 0			! AND IMAGE FILE IS OPEN
THEN BEGIN
    LNK$AL_IMGRAB[RAB$W_RSZ] = .RECLNG;		! SET RECORD LENGTH
    IF NOT (RMSERROR = $PUT(RAB = LNK$AL_IMGRAB)) ! WRITE THE RECORD
    THEN BEGIN
	SIGNAL(LIN$_WRITEERR,1,			! IF ERROR, REPORT AND CLOSE FILE
		LNK$GL_IMGFIL[FDB$Q_FILENAME],
		.RMSERROR,.LNK$AL_IMGRAB[RAB$L_STV]);
	LNK$CLOSYMOUT(.IMGAUXFNB);
	IF .STBFILEIFI EQL 0			! IF NO STB FILE BEING CREATED
	    THEN RETURN FALSE;			!  THEN ALL DONE NOW
	END
    ELSE LNK$GW_GSTRECS = .LNK$GW_GSTRECS + 1;	! COUNT GOOD RECORD WRITTEN
    END;

RETURN TRUE
END;

ROUTINE OUTPUTREC(RECLNG) =
BEGIN
!
!	THIS ROUTINE HANDLES THE ACTUAL RECORD OUTPUT TO THE
!	FILE(S) RECEIVING SYMBOL TABLE RECORDS. ERROR DETECTION 
!	OCCURS HERE BUT THE HANDLING IS DONE IN THE FILE CLOSING
!	ROUTINE.
!
IF NOT STBRECOUT(.RECLNG)
    THEN RETURN FALSE;

RETURN IMGRECOUT(.RECLNG)
END;

GLOBAL ROUTINE LNK$CLOSYMOUT(AUXFNB) : NOVALUE =
BEGIN
!
!	THIS ROUTINE HANDLES ERRORS WRITING THE SYMBOL TABLE RECORDS
!	AND/OR CLOSES THE DESIRED FILE(S).
!
!	IF "AUXFNB" IS ZERO - BOTH FILES (IF BOTH EXIST) ARE CLOSED
!	OTHERWISE "AUXFNB" IS THE ADDRESS OF THE AUXILIARY FILENAME BLOCK
!	OF THE FILE ON WHICH AN ERROR OCCURRED.  THE FILE IS CLOSED.
!
!	WHEN OUTPUTTING RECORDS TO THE GST OF AN IMAGE, THE IMAGE FILE
!	IS NOT ACTUALLY CLOSED (EXCEPT ON ERRORS). ITS ATTRIBUTES ARE MERELY
!	MODIFIED (BACK TO FIXED 512 BYTE RECORD) AND IT IS LEFT OPEN SINCE
!	THE IMAGE HEADER NEEDS TO BE WRITTEN AFTER THE GST IS DONE.
!
MAP	AUXFNB : REF BLOCK[,BYTE];

LOCAL	FABLOCK : BLOCK[FAB$C_BLN,BYTE],			! FAB FOR CLOSE AND MODIFY OPERATIONS
	CLOSERROR;						! ERROR CODE IF CLOSE FAILS

$FAB_INIT(FAB=FABLOCK,						! INITIALIZE THE FAB
	FOP=TEF);

IF .AUXFNB EQL 0						! IF WE ARE CLOSING BOTH FILES
OR .AUXFNB EQL .STBAUXFNB					! OR THE SYMBOL TABLE FILE ONLY
THEN IF (FABLOCK[FAB$W_IFI] = .STBFILEIFI) NEQ 0		! IF IT IS STILL OPEN
THEN BEGIN
    IF NOT (CLOSERROR = $CLOSE(FAB=FABLOCK))			! ATTEMPT TO CLOSE IT
    THEN BEGIN
	SIGNAL(LIN$_CLOSEOUT,1,					! AND OUTPUT AN ERROR IF THAT
		LNK$GL_SYMFIL[FDB$Q_FILENAME],
		.CLOSERROR,.FABLOCK[FAB$L_STV]);
	END;
    STBFILEIFI = 0;						! AND FORGET THE FILE IN ANY CASE
    IF .AUXFNB NEQ 0 THEN RETURN;				! RETURN IF THAT WAS ALL
    END;
IF .IMGAUXFNB NEQ 0						! IF SYMBOLS ARE ALSO GOING TO IMAGE
THEN BEGIN							! THEN SET UP TO MODIFY THE
    FABLOCK[FAB$W_IFI] = .LNK$GW_IMGIFI;			! THE ATTRIBUTES OF THIS FILE
    FABLOCK[FAB$B_RFM] = FAB$C_FIX;				! BACK TO FIXED LENGTH
    FABLOCK[FAB$W_MRS] = 512;					! 512 BYTE RECORDS IN THE
    FABLOCK[FAB$V_ESC] = TRUE;					! RMS DATA BASE
    FABLOCK[FAB$L_CTX] = RME$C_SETRFM;				! SO THAT IT WILL HAVE
    IF NOT (CLOSERROR = $MODIFY(FAB = FABLOCK))			! THE ATTRIBUTES OF AN IMAGE
    THEN BEGIN
	SIGNAL(LIN$_CLOSEOUT,1,					! ISSUE MESSAGE IF MODIFY FAILED
		LNK$GL_IMGFIL[FDB$Q_FILENAME],
		.CLOSERROR,.FABLOCK[FAB$L_STV]);
	END;
    IMGAUXFNB = 0;
    RETURN;
    END;
END;
END ELUDOM					! END OF MODULE
