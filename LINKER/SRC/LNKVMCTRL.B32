MODULE LNK_VMCTRL (	! CONTROL FOR ALLOCATION OF VIRTUAL MEMORY
		IDENT = 'V03-000',
		ADDRESSING_MODE(EXTERNAL=GENERAL,
				NONEXTERNAL=LONG_RELATIVE)
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!++
! FACILITY:	LINKER
!
! ABSTRACT:	THIS MODULE CONTAINS THE ROUTINES TO ALLOCATE VIRTUAL MEMORY
!			AT END OF PASS 1.
!
!
! ENVIRONMENT:	VMS NATIVE MODE
!
! AUTHOR:	T.J. PORTER, CREATION DATE: 15-JUN-78
!
! MODIFIED BY:
!
!	V03-001	BLS0007		Benn Schreiber,		3-Jun-1980
!		Convert to MDL data structures.
!--

!
!++
!	FUNCTIONAL DESCRIPTION
!
LIBRARY
	'STARLETL32';
REQUIRE
	'PREFIX';
LIBRARY
	'DATBAS';
!
EXTERNAL ROUTINE
	LNK$ALLOBLK : NOVALUE, 		! DYNAMIC MEMORY ALLOCATOR
	LNK$DEALBLK : NOVALUE; 		! AND DEALLOCATOR
!
EXTERNAL
	LNK$GL_FVMLST;				! LISTHEAD OF FREE VIR MEM DESCRIPTORS
!
GLOBAL
	LNK$GL_MINVA : INITIAL(MAX_ADDRESS),	! LOWEST ADDRESS ALLOCATED
	LNK$GL_MAXVA : INITIAL(0);		! HIGHEST ADDRESS ALLOCATED

GLOBAL ROUTINE LNK$ALLOVIRMEM(ADDRESS,PAGES) = 
BEGIN
!
!++
!	THIS ROUTINE IS CALLED TO ATTEMPT ALLOCATION OF A SPECIFIC
!	PIECE OF VIRTUAL MEMORY. THE ADDRESS AND PAGE COUNT REQUIRED
!	ARE THE INPUT ARGUMENTS. THE ROUTINE RETURNS TRUE OR FALSE
!	DEPENDING ON WHETHER THE SPECIFIED MEMORY IS AVAILABLE OR
!	ALREADY ALLOCATED.
!	
!	THE AVALIABLE VIRTUAL MEMORY IS CONTROLLED BY A SINGLY LINKED
!	LIST OF BLOCKS WITH FORMAT:
!			-------------------
!			! NEXT DESCRIPTOR !
!			-------------------
!			!  FREE  ADDRESS  !
!			------------------
!			!  # FREE  BYTES  !
!			-------------------
!--
!
LOCAL
	BYTES,						! BYTE COUNT REQUESTED
	FREBLK : REF BLOCK[,BYTE],			! FREE BLOCK POINTER
	PREVBLK : REF BLOCK[,BYTE];			! PREVIOUS FREE BLOCK IN LIST
!
IF (BYTES = .PAGES * 512) EQL 0				! IF ZERO SIZE
THEN RETURN TRUE;					! RETURN SUCCESS
!
PREVBLK = LNK$GL_FVMLST;				! SET AT LISTHEAD
WHILE (FREBLK = .PREVBLK[FVM$L_NXTFVM]) NEQ 0		! MOVE TO NEXT BLOCK DESCRIPTOR IN LIST
DO IF .ADDRESS LSSU .FREBLK[FVM$L_ADDRESS]		! LOOP TILL WE GET TO ONE FOR REQUESTED MEMORY
   OR .ADDRESS GEQU (.FREBLK[FVM$L_ADDRESS] + .FREBLK[FVM$L_BYTES])
   THEN PREVBLK = .FREBLK				! ...
   ELSE BEGIN
	IF (.ADDRESS + .BYTES) GTRU (.FREBLK[FVM$L_ADDRESS] +	! DOES DESIRED BLOCK FIT
				.FREBLK[FVM$L_BYTES])		! IN THE HOLE
	THEN EXITLOOP;						! QUIT IF NOT
	IF .ADDRESS EQL .FREBLK[FVM$L_ADDRESS]			! IF AT FRONT OF HOLE
	THEN IF (FREBLK[FVM$L_BYTES] = .FREBLK[FVM$L_BYTES] -	! REDUCE THE SIZE OF REMAINDER
			.BYTES) EQL 0				! AND IF GOING TO ZERO
		THEN BEGIN
			PREVBLK[FVM$L_NXTFVM] = .FREBLK[FVM$L_NXTFVM];	! TAKE DESCRIPTOR OFF LIST
			LNK$DEALBLK(FVM$C_SIZE,.FREBLK);		! AND DEALLOCATE IT
		     END
		ELSE FREBLK[FVM$L_ADDRESS] = .FREBLK[FVM$L_ADDRESS] + .BYTES	! SET ADDRESS OF REMAINDER
	ELSE BEGIN								! NOT AT THE FRONT
		IF (.FREBLK[FVM$L_ADDRESS] + .FREBLK[FVM$L_BYTES]) EQL	! CHECK IF IT IS ON END
			(.ADDRESS + .BYTES)				! OF THE BLOCK
		THEN FREBLK[FVM$L_BYTES] = .FREBLK[FVM$L_BYTES] - .BYTES! IF SO JUST REDUCE SIZE
		ELSE BEGIN
			LOCAL NXTBLK : REF BLOCK[,BYTE];		! OTHERWISE NEED TO SPLIT THE BLOCK
			LNK$ALLOBLK(FVM$C_SIZE,NXTBLK);			! ALLOCATE ANOTHER DESCRIPTOR
			NXTBLK[FVM$L_NXTFVM] = .FREBLK[FVM$L_NXTFVM];	! WHICH POINTS ONWARD
			FREBLK[FVM$L_NXTFVM] = .NXTBLK;			! AND PONTED TO BY CURRENT
			NXTBLK[FVM$L_ADDRESS] = .ADDRESS + .BYTES;	! DESCRIBES THE REMNANT AT END
			NXTBLK[FVM$L_BYTES] = .FREBLK[FVM$L_BYTES] -	! 
					(.NXTBLK[FVM$L_ADDRESS] -
					.FREBLK[FVM$L_ADDRESS]);
			FREBLK[FVM$L_BYTES] = .ADDRESS - .FREBLK[FVM$L_ADDRESS];	! AND SET CURRENT FREE SIZE
		     END;
	     END;
	IF (.ADDRESS + .BYTES -1) GTRU .LNK$GL_MAXVA		! MAXIMIZE THE ADDRESS
	THEN LNK$GL_MAXVA = .ADDRESS + .BYTES - 1;		! SPACE ALLOCATED
	IF .ADDRESS LSSU .LNK$GL_MINVA				! AND RESET MINIMUM IF NEXESSARY
	THEN LNK$GL_MINVA = .ADDRESS;
	RETURN TRUE;
	END;
RETURN FALSE;
END;			! OF LNK$ALLOVIRMEM

GLOBAL ROUTINE LNK$FINDVIRMEM(RETADR,PAGES,LOWESTVA) =
BEGIN
!
!++
!	THIS ROUTINE IS SIMILAR TO LNK$ALLOVIRMEM EXCEPT THAT ANY FREE
!	VIRTUAL MEMORY LARGE ENOUGH IS ALLOCATED, STARTING AT LOWEST
!	ADDRESS END.
!
!	IF LOWESTVA IS SUPPLIED IT SPECIFIES THAT THE VIRTUAL MEMORY
!	ALLOCATED MUST BE AT A HIGHER ADDRESS THAN LOWESTVA
!
!		RETADR = ADDRESS OF CELL TO RECEIVE THE ADDRESS OF
!				THE FIRST BYTE ALLOCATED.
!
!--
MAP
    RETADR : REF VECTOR[,LONG];

BUILTIN
    NULLPARAMETER;

LOCAL
    BYTES,
    FREBLK : REF BLOCK[,BYTE],
    PREVBLK : REF BLOCK[,BYTE],
    SPECIALADR;

IF (BYTES = .PAGES * 512) EQL 0
THEN BEGIN
    RETADR[0] = 0;					! IF REQUESTED SIZE IS ZERO
    RETURN TRUE						! SUCCESS
    END;

SPECIALADR = NOT NULLPARAMETER(3)			! SET FLAG IF TO ALLOCATE ABOVE SPECIFIC ADDRESS
		AND (.LOWESTVA NEQ 0);

PREVBLK = LNK$GL_FVMLST;				! SET TO START OF LIST
WHILE (FREBLK = .PREVBLK[FVM$L_NXTFVM]) NEQ 0		! GO DOWN LIST LOOKING FOR LARGE ENOUGH PIECE OF FREE MEMORY
DO IF (IF .SPECIALADR
	THEN ((.FREBLK[FVM$L_ADDRESS] LSSU .LOWESTVA)
		OR ((.FREBLK[FVM$L_ADDRESS]+.FREBLK[FVM$L_BYTES]
					LSSU .LOWESTVA)
		    OR (.FREBLK[FVM$L_ADDRESS]+.FREBLK[FVM$L_BYTES]
					LSSU .LOWESTVA+.BYTES)))
	ELSE (.BYTES GTRU .FREBLK[FVM$L_BYTES]))
   THEN PREVBLK = .FREBLK
   ELSE BEGIN
	RETADR[0] = .FREBLK[FVM$L_ADDRESS];			! RETURN ITS VIRTUAL ADDRESS
	IF (FREBLK[FVM$L_BYTES] = .FREBLK[FVM$L_BYTES] -	! REDUCE ITS SIZE
			.BYTES) EQL 0				! AND IF COMPLETELY CONSUMED
	THEN BEGIN
	    PREVBLK[FVM$L_NXTFVM] = .FREBLK[FVM$L_NXTFVM];	! REMOVE DESCRIPTOR FROM LIST
	    LNK$DEALBLK(FVM$C_SIZE,.FREBLK);			! AND DEALLOCATE THE DESCRIPTOR
	    END
	ELSE FREBLK[FVM$L_ADDRESS] = .FREBLK[FVM$L_ADDRESS] +	! OTHERWISE JUST ADJUST THE
				.BYTES;				! VIRTUAL ADDRESS REMAINING
	IF (.RETADR[0] + .BYTES - 1) GTRU .LNK$GL_MAXVA		! MAXIMIZE THE ADDRESS
	    THEN LNK$GL_MAXVA = ..RETADR + .BYTES - 1;		! SPACE ALLOCATED
	IF .RETADR[0] LSSU .LNK$GL_MINVA			! AND RESET MINIMUM IF NEXESSARY
	    THEN LNK$GL_MINVA = .RETADR[0];
	RETURN TRUE						! RETURN SUCCESS
	END;
RETURN FALSE							! NO MEMORY FOUND
END;								! END OF LNK$FINDVIRMEM
END ELUDOM
