MODULE LNK_SYMSERINS (IDENT='V03-000',
			ADDRESSING_MODE(EXTERNAL=GENERAL,
					NONEXTERNAL=LONG_RELATIVE)
			) =

BEGIN
!
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
!
!
!
!++
!
! MODULE: LNK_SYMSERINS
!
! FACILITY: LINKER
!
! ABSTRACT: SYMBOL TABLE SEARCH AND INSERT
!
! HISTORY:
!
!	VERSION: X01.00
!
!	AUTHOR: T.J. PORTER 18-FEB-77
!
! MODIFIED BY:
!
!	V03-003	BLS0090		Benn Schreiber		31-Oct-1981
!		Add LNK$SEARCHLOCAL routine
!
!	V03-002	BLS0025		Benn Schreiber		10-Nov-1980
!		Enhancements to shareable images.
!
!	V03-001	BLS0007		Benn Schreiber,		3-Jun-1980
!		Convert to MDL data structures.
!--

!
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	THIS MODULE CONTAINS THE SYMBOL TABLE SEARCH AND INSERT
!	ROUTINES. THE SYMBOL TABLE IS A HASH
!	TABLE USING A CHAIN OF ALTERNATES WHEN COLLOSIONS OCCUR.
!	THE TABLE CONSISTS OF SYM$C_TBLSIZ CONTIGUOUS DESCRIPTORS
!	EACH DESCRIPTOR CONTAINS A POINTER WHICH IS THE HEAD OF 
!	A SINGLY LINKED LIST, USED IF A COLLISION OCCURS ON
!	THAT ENTRY. MULTIPLE COLLISIONS ARE INSERTED IN THIS LIST,
!	THE LAST HAVING A ZERO POINTER.
!	THE COLLISION LIST ENTRIES ARE ALLOCATED (BY INSERT) FROM
!	DYNAMIC MEMORY.
!
!	THE CALLING SEQUENCES ARE:
!		LNK$SEARCH (TARGSYMBOL, DESCRADR, SNBADR)
!		LNK$INSERT (TARGSYMBOL, DESCRADR, SNBADR)
!		LNK$SEARCHLOCAL(TARGSYMBOL, ENVINDEX, DESCRADR, SNBADR, ENVDESCADR)
!	WHERE:	TARGSYMBOL IS THE ADDRESS OF AN ASCII STRING TO
!			BE FOUND OR INSERTED.
!
!		DESCRADR IS THE ADDRESS OF CELL TO STORE THE ADDRESS
!		OF A FOUND ENTRY OR ADDRESS OF AN INSERTED ENTRY.
!
!		SNBADR IS THE ADDRESS OF A CELL TO STORE THE ADDRESS
!		OF A FOUND ENTRY SYMBOL NAME BLOCK OR THE ADDRESS
!		OF THE SYMBOL NAME BLOCK IF THE ENTRY WAS INSERTED.
!
!	SEARCH HAS THE VALUE TRUE IF THE SYMBOL WAS FOUND,
!	FALSE IF NOT.
!
!	CALLS TO INSERT MUST BE PRECEDED BY AN UNSUCCESSFUL
!	SEARCH CALL, IN THIS CASE INFORMATION IS
!	RECORDED TO OBVIATE ANOTHER SEARCH AND 
!	DESCRADR IS RETURNED WITH THE ADDRESS OF THE DESCRIPTOR
!	WHICH HAS THE STRING COPIED INTO IT.
!
!	HASH VALUE H = SUM OF CHARACTERS, DIVIDED BY THE TABLE SIZE.
!
!--
!
LIBRARY
	'STARLETL32';
REQUIRE
	'PREFIX';				! GET GENERAL DEFINITIONS
LIBRARY
	'DATBAS';				! LINKER DATA STRUCTURES

EXTERNAL ROUTINE
	LNK$ALLOBLK,				! DYNAMIC MEMORY ALLOCATOR
	LNK$FNDENVMAP;				! FIND ENVIRONMENT MAPPING TABLE ENTRY

EXTERNAL LITERAL
	SYM$C_ALLOBLK : BYTLIT;			! NUMBER OF PAGES TO PREALLOCATE

OWN
	SYMENTRY : REF BLOCK[,BYTE];			! CURRENT SYMBOL ENTRY
GLOBAL
	LNK$GL_SYMALLOC : VECTOR[2,LONG],		! SIZE AND POINTER TO PREALLOCTED TABLE
	SYM$GL_HASHTBL : REF VECTOR[SYM$C_TBLSIZ,LONG]; ! THE HASH TABLE FOR SYMBOLS

GLOBAL ROUTINE LNK$SEARCH (TARGSYMBOL, DESCRADR, SNBADR) =
!
BEGIN
!
!	TARGSYMBOL IS ADDRESS OF AN ASCIC STRING 
!	DESCRADR IS ADDRESS OF CELL TO RECEIVE THE ENTRY
!	ADDRESS IF SYMBOL IS IN TABLE
!	SNBADR IS ADDRESS OF CELL TO RECEIVE THE SYMBOL NAME BLOCK
!	ADDRESS IF SYMBOL IS IN TABLE
!
MAP
	TARGSYMBOL : REF VECTOR[,BYTE];
!
LOCAL
	CH_RESULT,
	PREVENTRY,
	POINTER,
	HASHINDEX;
!
!	COMPUTE THE HASH INDEX AND GET ENTRY ADDRESS
!
HASHINDEX = 0;						! INITIALIZE THE HASH VALUE
POINTER = TARGSYMBOL[0];				! SET CHARACTER POINTER TO INCLUDE STRING LENGTH
INCR I TO .TARGSYMBOL[0]				! LOOP COUNT INCLUDES STRING LENGTH
DO HASHINDEX = .HASHINDEX + CH$RCHAR_A(POINTER);	! SUM THE CHARACTERS OF STRING
HASHINDEX = .HASHINDEX MOD SYM$C_TBLSIZ;		! THEN TAKE MODULO TABLE SIZE
SYMENTRY = (SYM$GL_HASHTBL[.HASHINDEX]);		! GET ADDRESS OF HASH TABLE ENTRY
IF .SYMENTRY[SNB$L_COLIST] EQL 0
	THEN RETURN FALSE
	ELSE BEGIN
	PREVENTRY = .SYMENTRY;				! REMEMBER PREVIOUS
	SYMENTRY = .SYMENTRY[SNB$L_COLIST];		! POINT TO THE FIRST ENTRY
!
!	NOW COMPARE THE SYMBOL IN THE
!	ENTRY FOR A MATCH. IF IT MATCHES RETURN ENTRY
!	ADDRESS AND SUCCESS CONDITION.
!	IF IT DOES NOT MATCH SEARCH DOWN THE COLLISION
!	LIST UNTIL:
!	1.	FIND A MATCH - RETURN THE ADDRESS OF MATCHED
!		ENTRY AND SUCCESS
!	2.	REACH END OF LIST. SAVE ADDRESS OF LAST
!		ENTRY IN LIST FOR POSSIBLE SUBSEQUENT
!		INSERT AND RETURN FAILURE.
!
DO IF (CH_RESULT = CH$COMPARE(.TARGSYMBOL[0], TARGSYMBOL[1], ! COMPARE SYMBOLS
			.SYMENTRY[SNB$B_NAMLNG], SYMENTRY[SNB$T_NAME])) EQL 0
	THEN BEGIN					! SYMBOL MATCHES
		.DESCRADR = .SYMENTRY + .SYMENTRY[SNB$B_NAMLNG] + SNB$C_FXDLEN;
		.SNBADR = .SYMENTRY;			! RETURN SYMBOL NAME BLOCK
							! AND VALUE BLOCK ADDRESSES
		RETURN TRUE;				! AND RETURN SUCCESS
	     END

UNTIL (IF .CH_RESULT LSS 0				! OTHERWISE, QUIT IF PAST THE SPOT
			THEN BEGIN
			    SYMENTRY = .PREVENTRY;	! RESET POINTER TO INSERT SPOT
			    TRUE
			    END
			ELSE BEGIN
			    PREVENTRY = .SYMENTRY;	! SAVE PREVIOUS
			    IF .SYMENTRY[SNB$L_COLIST] EQL 0 ! IF AT END OF LIST
				THEN TRUE
				ELSE BEGIN
				    SYMENTRY = .SYMENTRY [SNB$L_COLIST]; ! LINK TO NEXT
				    FALSE
				    END
			    END
		);
					! END OF THE COLLISION LIST.
RETURN FALSE;				! THE LAST ENTRY EXAMINED
					! IS PRESERVED IN SYMENTRY.
	END;						! END OF NON-0 HASH TABLE ENTRY
END;				! END OF SEARCH ROUTINE

GLOBAL ROUTINE LNK$INSERT(TARGSYMBOL, DESCRADR, SNBADR) : NOVALUE =
BEGIN
!
!	TARGSYMBOL IS ADDRESS OF AN ASCIC STRING, AN ENTRY
!	FOR WHICH IS TO BE INSERTED IN THE SYMBOL TABLE. THE
!	ADDRESS OF THIS ENTRY IS TO BE RETURNED IN THE CELL
!	DESCRADR.  THE ADDRESS OF THE SYMBOL NAME BLOCK IS RETURNED
!	IN THE CELL POINTED TO BY SNBADR.  THIS ROUTINE REQUIRES THAT
!	AN UNSUCCESSFULL CALL ON SEARCH PRECEDED IT AND SAVED THE
!	ADDRESS OF THE LAST ENTRY EXAMINED.
!
MAP
	TARGSYMBOL : REF VECTOR[, BYTE];
LOCAL
	BLOCKSIZE,
	NEWENTRY : REF BLOCK[,BYTE];
!
BLOCKSIZE = (SYM$C_SIZE+SNB$C_FXDLEN+.TARGSYMBOL[0] + 3) AND NOT 3;
IF .LNK$GL_SYMALLOC[0] LEQU .BLOCKSIZE
THEN BEGIN
    LNK$ALLOBLK(SYM$C_ALLOBLK*512,LNK$GL_SYMALLOC[1]);
    LNK$GL_SYMALLOC[0] = SYM$C_ALLOBLK*512;
    END;
NEWENTRY = .LNK$GL_SYMALLOC[1];
LNK$GL_SYMALLOC[0] = .LNK$GL_SYMALLOC[0] - .BLOCKSIZE;		! ALLOCATE A BLOCK
LNK$GL_SYMALLOC[1] = .LNK$GL_SYMALLOC[1] + .BLOCKSIZE;
								! WHICH CONSISTS OF
								! SYMBOL VALUE BLOCK +
								! SIZE OF NAME
								! + NAME BLOCK OVERHEAD
NEWENTRY[SNB$L_COLIST] = .SYMENTRY[SNB$L_COLIST];		! LINK INTO THE LIST
SYMENTRY[SNB$L_COLIST] = .NEWENTRY;				! LINK IT ON TO COLLISION LIST
SYMENTRY = .NEWENTRY;						! AND REPLACE OLD POINTER
!
!	HAVE AN EMPTY DESCRIPTOR - COPY IN THE SYMBOL
!	STRING
!
CH$MOVE(.TARGSYMBOL[0]+1,TARGSYMBOL[0],			! COPY NAME
		SYMENTRY[SNB$B_NAMLNG]);		! (NO EXTRA BYTES IN NAME)
.SNBADR = .SYMENTRY;					! RETURN SYMBOL NAME BLOCK ADDRESS
SYMENTRY = .SYMENTRY + .TARGSYMBOL[0] + SNB$C_FXDLEN;	! POINT TO SYMBOL VALUE BLOCK
CH$FILL(0,SYM$C_SIZE,.SYMENTRY);			! ZERO THE ENTRY
SYMENTRY[SYM$B_NAMLNG] = .TARGSYMBOL[0];		! SET LENGTH INTO VALUE BLOCK
.DESCRADR = .SYMENTRY;					! RETURN ITS ADDRESS
RETURN;							! AND THAT'S IT
END;							! OF INSERT ROUTINE.

GLOBAL ROUTINE LNK$SEARCHLOCAL (TARGSYMBOL, ENVINDEX, DESCRADR, SNBADR, ENVDESCADR) =
!
BEGIN
!
!	TARGSYMBOL IS ADDRESS OF AN ASCIC STRING 
!	ENVINDEX IS THE ENVIRONMENT THAT SYMBOL IS FROM
!	DESCRADR IS ADDRESS OF CELL TO RECEIVE THE ENTRY
!	ADDRESS IF SYMBOL IS IN TABLE
!	SNBADR IS ADDRESS OF CELL TO RECEIVE THE SYMBOL NAME BLOCK
!		ADDRESS IF SYMBOL IS IN TABLE
!	ENVDESCADR IS ADDRESS OF CELL TO RECEIVE THE ENVIRONMENT
!		DESCRIPTOR BLOCK ADDRESS OR 0 IF NOT DEFINED
!		OR REFERENCED (OPTIONAL PARAMETER)
!
MAP
	TARGSYMBOL : REF VECTOR[,BYTE];

BUILTIN
	NULLPARAMETER;

LOCAL
	MAPENT : REF BLOCK[,BYTE],
	ENVDESC : REF BLOCK[,BYTE],
	ENVNODE : REF BLOCK[,BYTE],
	HASHTABLE : REF VECTOR[,LONG],
	CH_RESULT,
	PREVENTRY,
	POINTER,
	HASHINDEX;
!
!	COMPUTE THE HASH INDEX 
!
HASHINDEX = 0;						! INITIALIZE THE HASH VALUE
POINTER = TARGSYMBOL[0];				! SET CHARACTER POINTER TO INCLUDE STRING LENGTH
INCR I TO .TARGSYMBOL[0]				! LOOP COUNT INCLUDES STRING LENGTH
DO HASHINDEX = .HASHINDEX + CH$RCHAR_A(POINTER);	! SUM THE CHARACTERS OF STRING
HASHINDEX = .HASHINDEX MOD SYM$C_TBLSIZ;		! THEN TAKE MODULO TABLE SIZE
!
! FIND ENVIRONMENT SYMBOL HASH TABLE
!
MAPENT = LNK$FNDENVMAP(.ENVINDEX);
IF (ENVNODE = .MAPENT[PMT$L_PSCDES]) NEQ 0
THEN BEGIN
    ENVDESC = .ENVNODE + NODE$C_SHORT;
    HASHTABLE = .ENVDESC[NVD$L_SYMTBL];
    END
ELSE BEGIN
    HASHTABLE = .MAPENT[PMT$L_SYMLST];
    ENVDESC = 0;
    END;
IF .HASHTABLE EQL 0
THEN BEGIN
    LNK$ALLOBLK(SYM$C_TBLSIZ*4,HASHTABLE);
    IF .ENVNODE NEQ 0
	THEN ENVDESC[NVD$L_SYMTBL] = .HASHTABLE
	ELSE MAPENT[PMT$L_SYMLST] = .HASHTABLE;
    END;
IF NOT NULLPARAMETER(5)
    THEN .ENVDESCADR = .ENVDESC;
SYMENTRY = (HASHTABLE[.HASHINDEX]);			! GET ADDRESS OF HASH TABLE ENTRY
IF .SYMENTRY[SNB$L_COLIST] EQL 0
	THEN RETURN FALSE
	ELSE BEGIN
	PREVENTRY = .SYMENTRY;				! REMEMBER PREVIOUS
	SYMENTRY = .SYMENTRY[SNB$L_COLIST];		! POINT TO THE FIRST ENTRY
!
!	NOW COMPARE THE SYMBOL IN THE
!	ENTRY FOR A MATCH. IF IT MATCHES RETURN ENTRY
!	ADDRESS AND SUCCESS CONDITION.
!	IF IT DOES NOT MATCH SEARCH DOWN THE COLLISION
!	LIST UNTIL:
!	1.	FIND A MATCH - RETURN THE ADDRESS OF MATCHED
!		ENTRY AND SUCCESS
!	2.	REACH END OF LIST. SAVE ADDRESS OF LAST
!		ENTRY IN LIST FOR POSSIBLE SUBSEQUENT
!		INSERT AND RETURN FAILURE.
!
DO IF (CH_RESULT = CH$COMPARE(.TARGSYMBOL[0], TARGSYMBOL[1], ! COMPARE SYMBOLS
			.SYMENTRY[SNB$B_NAMLNG], SYMENTRY[SNB$T_NAME])) EQL 0
	THEN BEGIN					! SYMBOL MATCHES
		.DESCRADR = .SYMENTRY + .SYMENTRY[SNB$B_NAMLNG] + SNB$C_FXDLEN;
		.SNBADR = .SYMENTRY;			! RETURN SYMBOL NAME BLOCK
							! AND VALUE BLOCK ADDRESSES
		RETURN TRUE;				! AND RETURN SUCCESS
	     END

UNTIL (IF .CH_RESULT LSS 0				! OTHERWISE, QUIT IF PAST THE SPOT
			THEN BEGIN
			    SYMENTRY = .PREVENTRY;	! RESET POINTER TO INSERT SPOT
			    TRUE
			    END
			ELSE BEGIN
			    PREVENTRY = .SYMENTRY;	! SAVE PREVIOUS
			    IF .SYMENTRY[SNB$L_COLIST] EQL 0 ! IF AT END OF LIST
				THEN TRUE
				ELSE BEGIN
				    SYMENTRY = .SYMENTRY [SNB$L_COLIST]; ! LINK TO NEXT
				    FALSE
				    END
			    END
		);
					! END OF THE COLLISION LIST.
RETURN FALSE;				! THE LAST ENTRY EXAMINED
					! IS PRESERVED IN SYMENTRY.
	END;						! END OF NON-0 HASH TABLE ENTRY
END;				! END OF SEARCH ROUTINE

GLOBAL ROUTINE LNK$UPCASE_D (DESCR) =
BEGIN
!
! THIS ROUTINE UPCASES THE STRING DESCRIBED BY DESCR.
!
MAP
    DESCR : REF BBLOCK;

BIND
    BYTESTRING = .DESCR[DSC$A_POINTER] : VECTOR[,BYTE];

LOCAL
    CCHAR : BYTE;

IF .DESCR[DSC$W_LENGTH] NEQ 0
THEN INCRU I FROM 0 TO .DESCR[DSC$W_LENGTH] - 1
    DO IF (CCHAR = .BYTESTRING[.I]) GEQU %ASCII 'a'
	AND .CCHAR LEQU %ASCII 'z'
    THEN BYTESTRING[.I] = .CCHAR - 32;

RETURN TRUE
END;
GLOBAL ROUTINE LNK$UPCASE_C (STRINGADR) =
BEGIN
!
! THIS ROUTINE UPCASES THE ASCIC STRING POINTED TO BY STRINGADR
!
MAP
    STRINGADR : REF VECTOR[,BYTE];

LOCAL
    CCHAR : BYTE;

IF .STRINGADR[0] NEQ 0
THEN INCRU I FROM 1 TO .STRINGADR[0]
    DO IF (CCHAR = .STRINGADR[.I]) GEQU %ASCII 'a'
	AND .CCHAR LEQU %ASCII 'z'
    THEN STRINGADR[.I] = .CCHAR - 32;

RETURN TRUE
END;
END ELUDOM
