MODULE LNK_GETCMDINP (IDENT='V03-009',
			ADDRESSING_MODE(EXTERNAL=GENERAL,
					NONEXTERNAL=LONG_RELATIVE)
			) =

BEGIN
!
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
!
!
!
!++
!
! MODULE: LNK_GETCMDINP
!
! FACILITY: LINKER
!
! ABSTRACT: COMMAND LANGUAGE INTERFACE FOR THE LINK COMMAND
!
! HISTORY:
!
!	VERSION: X01.00
!
!	AUTHOR: T.J. PORTER 03-MAY-77
!
! MODIFIED BY:
!
!	V03-009	BLS0166		Benn Schreiber		29-Mar-1982
!		Set SQO when opening input files
!
!	V03-008	BLS0117		Benn Schreiber		 7-Dec-1981
!		Open UPI, SHRGET, and SHRPUT in case installed /writeable
!
!	V03-007	BLS0075		Benn Schreiber		 1-Sep-1981
!		Use tparse to parse /userlib qualifier values
!
!	V03-006	BLS0074		Benn Schreiber		29-Aug-1981
!		Remove reference to LNK$GW_NUDFSYMS
!
!	V03-005	BLS0049		Benn Schreiber		22-Mar-1981
!		Allow pic clusters to be based via cluster= option
!
!	V03-004	BLS0035		Benn Schreiber		11-Jan-1981
!		65K psects
!
!	V03-003	BLS0029		Benn Schreiber		18-Dec-1980
!		Enhance lnk$allocluster to allow non-linking into cluster
!		list.
!
!	V03-002	BLS0024		Benn Schreiber		31-Oct-1980
!		Add clu$l_prevclu field to cluster descriptor
!
!	V03-001	BLS0007		Benn Schreiber,		3-Jun-1980
!		Convert to MDL data structures.
!--

!
!++
!
! FUNCTIONAL DESCRIPTION:
!
! THIS MODULE CONTAINS ALL THE ROUTINES AND DATA STRUCTURES TO
! PROCESS THE INPUT COMMAND PARAMETERS AND OPTIONS.
! THERE IS A GLOBAL ROUTINE:
!	LNK$GETCMD(ARGLIST)
! WHERE ARGLIST IS THE ADDRESS OF THE ORIGINAL ARGUMENT LIST
! WITH WHICH THE LINKER WAS CALLED. THIS ARGUMENT LIST IS
! USED TO PERFORM CALLS BACK TO CLI FOR RESULT PARSING.
!
! THIS MODULE ALSO CONTAINS PARAMETER REQUEST BLOCKS WHICH
! ARE PASSED WITH EACH CALL TO CLI, AS WELL AS PARAMETER
! QUALIFIER DESCRIPTION BLOCKS AND A SET OF ACTION ROUTINES
! WHICH ARE CALLED BY CLI ON THE APPROPRIATE CONDITIONS.
!
! A GLOBAL ROUTINE LNK$ALLOFDB IS ALSO INCLUDED IN THIS MODULE TO
! ALLOCATE AND INITIALIZE FILE DESCRIPTORS AND RESULTANT FILE NAME STRING AREAS.
! IT IS DESCRIBED IN DETAIL BELOW.
!--
!
FORWARD ROUTINE
	LNK$SRCPSCDEF,				! LOOK FOR PSECTNAME IN PSECT DEF BY OPT LIST
	LNK$COLLECTPSCT : NOVALUE,		! PERFORM PSECT COLLECTION/DEFINITION
	SETUSERLIB,				! SELECTIVELY SET LOG. NAME TABLES TO SEARCH
	CLIERROR : NOVALUE,			! CALLED FOR ALL CLI ERRORS
	CALL_TPARSE,				! CALL TPARSE TO PARSE A VALUE
	DEBUGFILE : NOVALUE,			! CALLED BY CLI IF A /DEBUG QUALIFIER
	LNK$ALLOCLUSTER : NOVALUE,		! ALLOCATE A CLUSTER DESCRIPTOR
	LNK$ALLOFDB : NOVALUE,			! ALLOCATE FILE DESCRIPTORS AND RESULTANT STRING AREAS
	OUTPUTFILE : NOVALUE,			! CALLED FOR ALL OUTPUT FILES
	INPUTFILE : NOVALUE,			! CALLED FOR EACH INPUT FILE
	SPECIALIMAGE : NOVALUE,			! CALLED FOR SYSTEM AND SHAREABLE IMAGES
	LNK$SETLIBRIN : NOVALUE,		! CALLED FOR LIBRARY FILES
	LNK$INSERT_CLU,				! INSERT CLUSTER INTO CLUSTER TREE
	OPTIONFILE : NOVALUE;
!
LIBRARY
	'STARLETL32';				! SYSTEM STRUCTURE DEFINITIONS
REQUIRE
	'PREFIX';				! UTILITY MACROS ETC.
LIBRARY
	'DATBAS';				! INTERNAL DATA BASE DEFINITIONS
LIBRARY
	'CLIMACL32';				! COMMAND LANGUAGE STRUCTURES
LIBRARY
	'TPAMACL32';				! TPARSE MACROS
!
!	DECLARE THE QUALIFIER CODES
!
$CLIQUALCODES(LINK,				! FOR THE LINKER
			SYSTEM,			! SYSTEM IMAGE
			CONTIGUOUS,		! PRODUCE A CONTIGOUS IMAGE
			SHAREABLE,		! SHAREABLE IMAGE
			DEBUG,			! IMAGE TO BE DEBUGGED
			TRACE,			! PRODUCE TRACE BACK DATABASE
			CROSSREF,		! PRODUCE A CROSS REFERENCE ON MAP
			FULL,			! A FULL MAP
			BRIEF,			! A SHORT MAP
			SYSLIB,			! INPUT FROM SYSTEM LIBRARY
			SYSSHR,			! ALSO FROM SYSTEM SHAREABLE IMAGE
			SELECTIVE,		! SELECTIVE SEARCH FILE
			INCLUDE,		! EXPLICIT MODULE INCLUSION FROM LIBRARIES
			LIBRARY,		! LIBRARY FILE INPUT
			USERLIBRARY,		! PROCESS DEFAULT USER LIBRARIES
			PROTECT,		! PROTECT THE IMAGE
			P0IMAGE,		! P0-ONLY IMAGE
			HEADER,			! HEADER ON SYSTEM IMAGE
			OPTIONS);		! OPTION FILE
!
EXTERNAL LITERAL
	LIN$_CLOSEIN,				! CLOSE ERROR
	LIN$_CMDSYNTAX,				! COMMAND SYNTAX ERROR
	LIN$_FIRSTMOD,				! FIRST MODULE REQUIRES EXTRACTION SINCE LIBRARY
	LIN$_ILLQUALVAL,			! ILLEGAL QUALIFIER VALUE
	LIN$_LINERR,				! DISPLAY SEGMENT IN ERROR
	LIN$_NOMODS,				! NO INPUT MODULES SPECIFIED
	LIN$_OPENIN,				! ERROR OPENING INPUT FILE
	LIN$_TRACIGN;				! TRACEBACK SUPRESSION OVERRIDDEN

EXTERNAL ROUTINE
	LIB$INSERT_TREE, 			! INSERT INTO BALANCED BINARY TREE
	LIB$LOOKUP_TREE, 			! LOOKUP ENTRY IN BALANCED BINARY TREE
	LIB$TPARSE,				! TABLE DRIVEN PARSER
	LNK$FNDPSCNAM,				! LOOKUP/ENTER PSECT NAMES
	LNK$ALLOBLK : NOVALUE, 			! ALLOCATE DYNAMIC MEMORY
	LNK$DEALBLK : NOVALUE, 			! DEALLOCATE DYNAMIC MEMORY
	LNK$PROCOPTNS,				! OPTION FILE PROCESSOR
	LNK$FILNAMDSC,				! RETURN STRING DESCRIPTOR FOR FILE NAME
	LNK$INSUDFSYM,				! INSERT SYMBOL DESCRIPTOR IN UNDEFINED SYMBOL LIST
	LNK$INSERT,				! SYMBOL TABLE INSERT ROUTINE
	LNK$SEARCH;				! SYMBOL TABLE SEARCH ROUTINE
!
EXTERNAL
	LNK$GL_CTLMSK : BLOCK[,BYTE],		! CONTROL FLAGS
	LNK$GL_LASTCLU : REF BLOCK[,BYTE],	! POINTER TO LAST CLUSTER IN LIST
	LNK$GL_CLULST : VECTOR[2],		! CLUSTER DESCRIPTOR LISTHEAD
	LNK$GL_DEFCLU : BLOCK[,BYTE],		! DEFAULT CLUSTER DESCRIPTOR
	LNK$GL_CURCLU : REF BLOCK[,BYTE],	! CURRENT CLUSTER DESCRIPTOR
	LNK$GL_CLUTREE : REF BLOCK[,BYTE],	! LISTHEAD FOR CLUSTER TREE
	LNK$GL_FVMLST : REF BLOCK[,BYTE],	! FREE VIRTUAL MEMORY LISTHEAD
	LNK$GL_IMGFIL : REF BLOCK[,BYTE],	! POINTER TO IMAGE FILE DESCRIPTOR SLOT
	LNK$GL_MAPFIL : REF BLOCK[,BYTE],	! POINTER TO THE MAP FILE DESCRIPTOR
	LNK$GW_NCLUSTERS : WORD,		! NUMBER OF CLUSTERS ALLOCATED
	LNK$GW_NSYMBOLS : WORD,			! NUMBER OF SYMBOLS	
	LNK$GL_SYMFIL : REF BLOCK[,BYTE],	! POINTER TO SYMBOL TABLE OUTPUT FILE
	LNK$GL_CCLULST,				! LIST HEAD (SINGLY LINKED)
						! FOR CLUSTERS IN COLLECT OPTION
	LNK$GL_PSCDFLST;			! SINGLY LINKED LISTHEAD
						! FOR PSECTS DEFINED WITH PSECT OPTION
!
BIND	FIRSTCLUSTER = LNK$GL_CLULST[0] : REF BLOCK[,BYTE];	! POINTER TO FIRST
!
GLOBAL
	LNK$GL_ULIBMASK,			! MASK OF ENABLED NAME TABLES TO SEARCH
	LNK$GL_INRELNAM,			! ADDRESS OF NAM BLOCK OF FIRST INPUT FILE
	LNK$GL_CLIWORK;				! POINTER TO WORK AREA FOR CLI
!
GLOBAL BIND
	LNK$GT_IMGSTA = CSTRING('SYS$IMGSTA');			! NAME OF DEBUGGER ACTIVATOR 
MAP
	LNK$GL_ULIBMASK : BITVECTOR[];				! PRETEND ITS A BITVECTOR
!
! OWN STORAGE
!
BIND	DEFILETYPE = UPLIT(BYTE('.OBJ'));			! DEFAULT FILE TYPE
!
LITERAL
	RSA_ALLOSIZE = NAM$C_MAXRSS*3/2,			! RSA ALLOCATION QUANTITY
	TYPELEN = 4;						! LENGTH OF FILE TYPE STRING
!
OWN
	GETCMD_DESC : $CLIREQDESC(RQTYPE = GETCMD,		! GET COMMAND LINE
				ERRACT = CLIERROR-GETCMD_DESC),
	INITPRS_DESC : $CLIREQDESC(RQTYPE = INITPRS,		! DESCRIPTOR FOR
				  ERRACT = CLIERROR-INITPRS_DESC),	! INITIATE PARSE REQUEST
	ENDPRS_DESC : $CLIREQDESC(RQTYPE = ENDPRM1,			! DESCRIPTOR FOR PARSE
				  ERRACT = CLIERROR-ENDPRS_DESC),	! COMPLETE CALL

	SYSQUAL_DESC : $CLIQUALDESC(				! SYSTEM IMAGE
				  QDCODE=SYSTEM,		! QUALIFIER
				  TRUACT=SPECIALIMAGE-SYSQUAL_DESC,
				  TSTLST=(LNK$S_SHR,LNK$S_DBG),	! CONFLICTS WITH SHAREABLE AND DEBUGGER
				  SETLST=LNK$S_SYS,		! 
				  CLRLST=(LNK$S_TRACE,LNK$S_EXE)), ! NOT EXECUTABLE AND NO TRACEBACK
	SYSLIB_DESC : $CLIQUALDESC(				! SYSTEM LIBRARY QUALIFIER
				QDCODE=SYSLIB,
				SETLST=LNK$S_SYSLIB),

	SYSSHR_DESC : $CLIQUALDESC(
				QDCODE=SYSSHR,
				SETLST=LNK$S_SYSSHR),

	SHRABL_DESC : $CLIQUALDESC(				! SHAREABLE IMAGE
				  QDCODE=SHAREABLE,		! QUALIFIER
				  TRUACT=SPECIALIMAGE-SHRABL_DESC,
				  TSTLST=(LNK$S_SYS,LNK$S_DBG),	! CONFLICTS WITH SYSTEM AND DEBUG
				  SETLST=LNK$S_SHR,		!
				  CLRLST=(LNK$S_EXE,LNK$S_TRACE)),

	DEBUG_DESC : $CLIQUALDESC(				! DEBUG QUALIFIER
				  QDCODE=DEBUG,
				  TRUACT=DEBUGFILE-DEBUG_DESC,	! ROUTINE TO GET THE FILENAME OF SPECIAL DEBUGGER
				  TSTLST=(LNK$S_SYS,LNK$S_SHR),	! CONFLICTS WITH SYSTEM AND SHAREABLE
				  SETLST=LNK$S_DBG),

	TRACE_DESC : $CLIQUALDESC(				! TRACEBACK QUALIFIER
				 QDCODE=TRACE,			!
				 SETLST=LNK$S_TRACE),		! JUST SETS A BIT
	CONTIG_DESC : $CLIQUALDESC(				! CONTIGUOUS QUALIFIER
				 QDCODE=CONTIG,			!
				 SETLST=LNK$S_CONTIG),		! JUST SETS A BIT
	USERLIB_DESC : $CLIQUALDESC(				! USER LIBRARIES
				QDCODE=USERLIBRAR,
				SETLST=LNK$S_USRLIB,
				TRUACT=(SETUSERLIB - USERLIB_DESC)),
	P0IMAGE_DESC : $CLIQUALDESC (				! P0-ONLY IMAGE
				QDCODE=P0IMAGE,
				TSTLST=(LNK$S_SHR,LNK$S_SYS),	! CONFLICTS WITH SHAREABLE AND SYSTEM IMAGES
				SETLST=LNK$S_P0IMAGE),
	PROTECT_DESC : $CLIQUALDESC (				! PROTECTED IMAGE
				QDCODE=PROTECT,
				TSTLST=(LNK$S_SYS,LNK$S_EXE),	! CONFLICTS WITH SYSTEM AND EXECUTABLE IMAGES
				SETLST=LNK$S_PROTECT),
	SYSHDR_DESC : $CLIQUALDESC (				! SYSTEM IMAGE WITH HEADER
				QDCODE=HEADER,
				TSTLST=(LNK$S_SHR,LNK$S_EXE),	! CONFLICTS WITH SHAREABLE AND EXECUTABLE IMAGES
				SETLST=LNK$S_SYSHEADR),
	IMAGQUALEND : $CLIQUALEND,				! END OF IMAGE QUALIFIER DESCRIPTOR LIST

	IMAGE_DESC : $CLIREQDESC(RQTYPE = OUTPUT1,		! IMAGE REQUEST
				  BITNUM = LNK$S_IMAGE, 	! DESCRIPTOR - PRIMARY
				  ERRACT = CLIERROR-IMAGE_DESC,	! OUTPUT.
				  PRSACT = OUTPUTFILE-IMAGE_DESC,
				  QUALST = SYSQUAL_DESC-IMAGE_DESC),
	CREFQUAL_DESC : $CLIQUALDESC(				! CROSS REFERENCE
				QDCODE=CROSSREF,		! QUALIFIER
				TSTLST=LNK$S_BRIEF,		! WHICH CONFLICTS WITH BRIEF
				SETLST=LNK$S_CROS),		! OF THESE WILL WIN

	FULLQUAL_DESC : $CLIQUALDESC(				! FULL FORM OF
				QDCODE=FULL,			! MAP QUALIFIER
				SETLST=LNK$S_LONG,
				CLRLST=LNK$S_SUPSYS,		! ALLOW SYSLIB SYSMBOLS
				TSTLST=LNK$S_BRIEF),		! CONFLICTS WITH BRIEF

	BRIEFQUAL_DESC : $CLIQUALDESC(				! BRIEF MAP
				QDCODE=BRIEF,			! QUALIFIER
				SETLST=LNK$S_BRIEF,
				TSTLST=(LNK$S_CROS,LNK$S_LONG)),! CONFLICTS WITH CROSS AND LONG

	MAPQUALEND : $CLIQUALEND,				! END OF MAP FILE QUALIFIERS

	MAP_DESC : $CLIREQDESC(RQTYPE = OUTPUT2,		! MAP FILE REQUEST
				  BITNUM = LNK$S_MAP,		! DESCRIPTOR - SECONDARY
				  ERRACT = CLIERROR-MAP_DESC,	! OUTPUT
				  PRSACT = OUTPUTFILE-MAP_DESC,
				  QUALST = CREFQUAL_DESC-MAP_DESC),

	SSERQUAL_DESC : $CLIQUALDESC(				! SELECTIVE SEARCH
				  QDCODE=SELECTIVE,		! QUALIFIER IS MUTUALLY
				  TSTLST=(FDB$S_OPTION,		! EXCLUSIVE OF OPTIONS.
					  FDB$S_LIBR),		! LIBRARY
				  SETLST=FDB$S_SELSER),

	INCLUDE_DESC : $CLIQUALDESC(				! INCLUDE QUALIFIER
				  QDCODE=INCLUDE,		! IS MUTUALLY EXCLUSIVE
				  TSTLST=(FDB$S_OPTION,FDB$S_SHR,! OF OPTIONS, SHAREABLE AND
					  FDB$S_SELSER),	! SELECTIVE SEARCH
				  SETLST=FDB$S_LIBR,
				  TRUACT=LNK$SETLIBRIN-INCLUDE_DESC),! GO GET THE MODULES

	LIBRQUAL_DESC : $CLIQUALDESC(				! LIBRARY QUALIFIER
				  QDCODE=LIBRARY,		! IS MUTUALLY EXCLUSIVE
				  TSTLST=(FDB$S_OPTION,FDB$S_SHR,! OF OPTIONS, SHAREABLE AND
					  FDB$S_SELSER),	! SELECTIVE SEARCH
				  SETLST=FDB$S_LIBR,
				  TRUACT=LNK$SETLIBRIN-LIBRQUAL_DESC),! GO GET THE MODULES

	OPTQUAL_DESC : $CLIQUALDESC(				! OPTION QUALIFIER
				  QDCODE=OPTIONS,		! IS MUTUALLY EXCLUSIVE
				  TSTLST=(FDB$S_SELSER,FDB$S_SHR,	! OF SELECTIVE SEARCH, SHAREABLE
					  FDB$S_LIBR),		! AND LIBRARY
				  SETLST=FDB$S_OPTION,
				  TRUACT=OPTIONFILE-OPTQUAL_DESC),

	INPUTQUALEND : $CLIQUALEND,				! END OF INPUT FILE QUALIFIERS

	INPUT_DESC : $CLIREQDESC(RQTYPE = INPUT1,		! INPUT FILES REQUEST
				  RQFLGS = PARMREQ,		! DESCRIPTOR - AT
				  ERRACT = CLIERROR-INPUT_DESC,	! LEAST ONE IS REQUIRED
				  PRSACT = INPUTFILE-INPUT_DESC,
				  QUALST = SSERQUAL_DESC-INPUT_DESC),
	SYMTBL_DESC : $CLIREQDESC(RQTYPE=OUTPUT3,		! THIRD OUTPUT PARAMETER IS SYMBOL TABLE
				  BITNUM=LNK$S_SYMTBL,		! FILE TO BE CREATED
				  ERRACT=CLIERROR-SYMTBL_DESC,
				  PRSACT=OUTPUTFILE-SYMTBL_DESC),

	DEBUGGER : VECTOR[2,LONG] INITIAL (0,0),		! STRING DESCRIPTOR FOR DEBUGGER IF /DEBUG=NAME
	SYSTEMBASE,						! BASE SPECIFIED IN /SYSTEM=number
	BASEDFLAG,						! SET TRUE IF /SYSTEM=number
	OUTFILE,						! POINTER TO THE POINTER FOR THE CURRENT OUTPUT FILE
	NEXTRSA,						! POINTER TO SLOT FOR NEXT RESULTANT STRING ON OPEN
	TYPEADR : INITIAL(CH$PTR(DEFILETYPE)),			! ADDRESS OF THE FILE TYPE STRING
	INFILFLGS,						! FLAGS OF EACH INPUT FILE
	TPDATA,							! DATA FROM TPARSE
	RSAREMSIZE : BYTE;					! SIZE REMAINING IN RSA
!
GLOBAL BIND
	LNK$AL_LBQLDSC = INCLUDE_DESC : BLOCK[,BYTE],		! MAKE NAME AVAIALABLE GLOBALLY
	LNK$AL_CMDDESC = GETCMD_DESC : BLOCK[,BYTE];		! GET COMMAND DESCRIPTOR
!
! TPARSE TABLES TO PARSE /USERLIB QUALIFIER VALUES
!
$INIT_STATE(USERLIB_STATES,USERLIB_KEYS);

$STATE(,
	('SYSTEM',TPA$_EXIT,,1,LNK$GL_ULIBMASK),
	('GROUP',TPA$_EXIT,,2,LNK$GL_ULIBMASK),
	('PROCESS',TPA$_EXIT,,4,LNK$GL_ULIBMASK),
	('ALL',TPA$_EXIT,,7,LNK$GL_ULIBMASK),
	('NONE',TPA$_EXIT,,%X'80000000',LNK$GL_ULIBMASK));

GLOBAL ROUTINE LNK$GETCMD(ARGLIST) : NOVALUE =
BEGIN
!
! THIS ROUTINE INITIALIZES THE CLI RESULT PARSER THEN RE-CALLS
! IT FOR PROCESSING OF EACH COMMAND PARAMETER. IT FIRST CALLS
! FOR THE PRIMARY OUTPUT PARAMETER (THE IMAGE), THEN THE SECONDARY
! OUTPUT PARAMETER (THE MAP), FOLLOWED BY THE THIRD OUTPUT PARAMETER (THE SYMBOL TABLE FILE).
! NEXT IT LOOPS, CALLING FOR INPUT
! PARAMETERS (PRIMARY ONLY) UNTIL THERE ARE NO MORE. THE ACTIONS
! TAKEN ON PRESENCE OR ABSENCE OF ANY PARAMETER AND ITS
! QUALIFIERS ARE TAKEN IN THE OTHER ROUTINES (BELOW) WHICH
! ARE CALLED BY CLI ON THE APPROPRIATE CONDITION.
!
! ARGLIST IS THE ADDRESS OF THE ARGUMENT LIST WITH WHICH
! THE LINKER WAS ORIGINALLY CALLED.
!
MAP
	ARGLIST : REF BLOCK[,BYTE];				! REALLY A VECTOR OF LONGWORDS

BIND ROUTINE
    RECALLCLI = .ARGLIST[CLI$A_UTILSERV];			! NAME CLI CALLBACK ROUTINE

LNK$ALLOBLK(CLI$C_WORKAREA,LNK$GL_CLIWORK);			! ALLOCATE A WORK AREA FOR CLI
LNK$GL_CTLMSK[LNK$V_VERIFY] = .ARGLIST[CLI$V_VERIFY];		! COPY VERIFY CONTEXT OF PROCESS

RECALLCLI(INITPRS_DESC,.LNK$GL_CLIWORK);			! INITIATE RESULT PARSING
RECALLCLI(GETCMD_DESC,.LNK$GL_CLIWORK,LNK$GL_CTLMSK);		! GET COMMAND LINE TO PRINT IN MAP

RSAREMSIZE = RSA_ALLOSIZE*3;					! SET UP THE RESULTANT STRING AREA
LNK$ALLOBLK(.RSAREMSIZE,NEXTRSA);				! FOR THE FILE OPENS (TRIPLE SIZE AT FIRST)
OUTFILE = LNK$GL_IMGFIL;					! POINT TO THE POINTER
RECALLCLI(IMAGE_DESC,.LNK$GL_CLIWORK,LNK$GL_CTLMSK);		! GO GET IMAGE FILE DESCRIP.

OUTFILE = LNK$GL_MAPFIL;					! POINT TO THE POINTER
RECALLCLI(MAP_DESC,.LNK$GL_CLIWORK,LNK$GL_CTLMSK);		! GO GET MAP FILE DESCRIP.
IF NOT .LNK$GL_CTLMSK[LNK$V_MAP]				! IF NO MAP SPECIFIED SET TO
THEN LNK$GL_CTLMSK[LNK$V_BRIEF] = TRUE;				! SUPPRESS INSERTION OF SYMBOLS IN CREF TABLES

OUTFILE = LNK$GL_SYMFIL;					! POINT TO THE POINTER
RECALLCLI(SYMTBL_DESC,.LNK$GL_CLIWORK,LNK$GL_CTLMSK);		! AND GO GET IT

DO BEGIN							! AND NOW LOOP, GETTING
	RECALLCLI(INPUT_DESC,.LNK$GL_CLIWORK,INFILFLGS);	! INPUT FILE DESCRIPTIONS
   END								! UNTIL THERE IS 
UNTIL .INPUT_DESC[CLI$V_CONCATINP] EQL 0;			! NO MORE

RECALLCLI(ENDPRS_DESC,.LNK$GL_CLIWORK);				! TERMINATE PARSING

!
! IF /SYSTEM=number, THEN SET THE BASE NOW
!
IF .BASEDFLAG
THEN BEGIN
    IF .LNK$GL_CTLMSK[LNK$V_SYSHEADR]
	THEN LNK$GL_DEFCLU[CLU$L_BASE] = (.SYSTEMBASE + 511)	! ONLY ROUND BASE IF /SYSTEM/HEADER
						AND NOT 511
	ELSE LNK$GL_DEFCLU[CLU$L_BASE] = .SYSTEMBASE;
    IF .LNK$GL_DEFCLU[CLU$L_BASE] GEQU CONTROL_REGION		! SET CORRECT ALLOCATION LIMITS
	THEN LNK$GL_FVMLST[FVM$L_ADDRESS] = CONTROL_REGION
	ELSE LNK$GL_FVMLST[FVM$L_ADDRESS] = 0;
    END;
!
! CHECK THAT THERE WAS AT LEAST ONE INPUT MODULE
!
IF .FIRSTCLUSTER EQL 0						! IF NO CLUSTERS ALLOCATED
AND .LNK$GL_DEFCLU[CLU$L_FSTFDB] EQL 0				! AND NO FILES IN DEFAULT CLUSTER
    THEN SIGNAL_STOP(LIN$_NOMODS);				! THERE WERE NO INPUT MODULES - FATAL ERROR
!
!	NOW LINK THE DEBUGGER INTO THE INPUT FILE LIST
!	IF DEBUG AND/OR TRACEBACK WAS REQUESTED.
!
!	HOWEVER SUPPRESS IT IF THIS IS A SYSTEM IMAGE
!
IF .LNK$GL_CTLMSK[LNK$V_SYS]
    OR .LNK$GL_CTLMSK[LNK$V_SHR]
    THEN LNK$GL_CTLMSK[LNK$V_TRACE] = FALSE;
IF .LNK$GL_CTLMSK[LNK$V_DBG]
    OR .LNK$GL_CTLMSK[LNK$V_TRACE]
THEN BEGIN
	IF NOT .LNK$GL_CTLMSK[LNK$V_TRACE]			! IF ONLY DBG THEN
	    THEN SIGNAL(LIN$_TRACIGN);				! REPORT CONFLICT AS INFO.
	INFILFLGS = FDB$M_DEBUGER;				! SET THE FILE FLAG
	INPUT_DESC[CLI$W_RQSIZE] = .DEBUGGER[0];		! LENGTH PART OF DESCRIPTOR
	IF (INPUT_DESC[CLI$A_RQADDR] = .DEBUGGER[1]) NEQ 0	! IF /DEBUG=FILENAME
	    THEN INPUTFILE(INPUT_DESC)				! THEN GO DO IT
	    ELSE BEGIN
		LOCAL
			SYMNAM : REF BLOCK[,BYTE],		! POINTER TO NAME PART OF SYMBOL BLOCK
			SYMVAL : REF BLOCK[,BYTE];		! POINTER TO VALUE PART OF SYMBOL BLOCK
		LNK$SEARCH(LNK$GT_IMGSTA,SYMVAL,SYMNAM);	! LOOK UP THE SYMBOL
		LNK$INSERT(LNK$GT_IMGSTA,SYMVAL,SYMNAM);	! AND INSERT IT
		LNK$INSUDFSYM(.SYMVAL);				! INSERT SYMBOL IN UNDEFINED LIST
		LNK$GW_NSYMBOLS = .LNK$GW_NSYMBOLS + 1;		! COUNT THE SYMBOL
		END;
     END;
LNK$GL_CTLMSK[LNK$V_VERIFY] = FALSE;				! TURN OFF VERIFY STATUS
LNK$COLLECTPSCT();						! PERFORM PSECT COLLECTION AND DEFINITION
IF .LNK$GL_DEFCLU[CLU$L_FSTFDB] NEQ 0				! IF DEFAULT CLUSTER HAS SOME FILES
THEN BEGIN
	LNK$GL_LASTCLU[CLU$L_NXTCLU] = LNK$GL_DEFCLU;		! LINK IT ON TO END OF
	IF (LNK$GL_DEFCLU[CLU$L_PREVCLU] = .LNK$GL_LASTCLU) EQL 0! CLUSTER LIST
	    THEN LNK$GL_DEFCLU[CLU$L_PREVCLU] = LNK$GL_CLULST;
	LNK$GL_LASTCLU = LNK$GL_DEFCLU;				! AND MAKE IT THE LAST CLUSTER THEN
     END;
RETURN;
END;

ROUTINE CLIERROR(REQESTDESC,ERRORCODE) : NOVALUE =
BEGIN
!
! THIS ROUTINE IS CALLED BY RESULT PARSER IF IT DETECTS ANY ERROR.
! IN THIS COMMAND. REQESTDESC IS THE ADDRESS OF THE CURRENT PARA-
! METER DESCRIPTOR AND ERRORCODE IS THE ENCODED REASON FOR THE 
! ERROR.
!
MAP
	REQESTDESC : REF BLOCK[,BYTE];				! POINTER TO A BLOCK
!

SIGNAL_STOP(LIN$_CMDSYNTAX,0,LIN$_LINERR,1,REQESTDESC[CLI$W_RQSIZE],! ISSUE THE ERROR
					.ERRORCODE);
END;

ROUTINE CALL_TPARSE(STRING,STATES,KEYS) =
BEGIN
!
! THIS ROUTINE CALLS TPARSE GIVEN THE STRING, STATES AND KEYS
!
! INPUTS:
!
!	STRING		ADDRESS OF STRING DESCRIPTOR FOR STRING TO PARSE
!	STATES		ADDRESS OF TPARSE STATES TABLE
!	KEYS		ADDRESS OF TPARSE KEYS TABLE
!
MAP
    STRING : REF BLOCK[,BYTE];

LOCAL
    STATUS,
    TPABLOCK : BLOCK[TPA$K_LENGTH0,BYTE];

!
! INITIALIZE THE TPARSE BLOCK
!
CH$FILL(0,TPA$K_LENGTH0,TPABLOCK);
TPABLOCK[TPA$L_COUNT] = TPA$K_COUNT0;
TPABLOCK[TPA$L_OPTIONS] = TPA$M_ABBREV;
TPABLOCK[TPA$L_STRINGCNT] = .STRING[DSC$W_LENGTH];
TPABLOCK[TPA$L_STRINGPTR] = .STRING[DSC$A_POINTER];
!
! INITIALIZE OWN STORAGE USED
!
TPDATA = 0;

RETURN LIB$TPARSE(TPABLOCK,.STATES,.KEYS)
END;

ROUTINE SPECIALIMAGE(REQESTDESC,CLIADDR) : NOVALUE =
BEGIN
!
! THIS ROUTINE IS CALLED BY CLI IF THE SYSTEM OR SHAREABLE IMAGE
! QUALIFIER IS SEEN ON THE PRIMARY OUTPUT PARAMETER.
!
!	IF A VALUE IS PRESENT ON THE QUALIFIER, CLI IS RE-CALLED
! THROUGH CLIADDR TO CONVERT THE VALUE WHICH THEN SETS THE BASE ADDRESS OF THE DEFAULT
! CLUSTER OF THE IMAGE BEING LINKED. IF NO VALUE IS PRESENT THE BASE ADDRESS IS
! SET TO THE LOWER END OF SYSTEM OR PROCESS SPACE. IN BOTH CASES THE STACK SIZE IS
! SET TO ZERO. A SYSTEM IMAGE WILL NOT BUT A SHAREABLE IMAGE WILL
! HAVE A HEADER.
!
EXTERNAL
	LNK$GW_STACK : WORD;			! STACK SIZE
!
BIND ROUTINE
    RECALLCLI = .CLIADDR;			! NAME CLI CALLBACK ROUTINE
						! CLI TO CONVERT THE VALUE OF QUALIFIER
!
MAP REQESTDESC : REF BLOCK[,BYTE];			! SET CORRECT ATTRIBUTES
!
LOCAL	BASEVALUE_DESC : BLOCK[CLI$C_REQDESC,BYTE],	! DESCRIPTOR FOR CALL BACK TO CLI
	SYMBOLSTRING : VECTOR[SYM$C_MAXLNG+1,BYTE],	! BASE ADDRESS SYMBOL STOREAGE
	NAMENT : REF BLOCK[,BYTE],			! POINTER TO SYMBOL NAME BLOCK
	SYMTABENT : REF BLOCK[,BYTE];			! POINTER TO TABLE ENTRY FOR IT
!
LNK$GW_STACK = 0;					! NO STACK
IF .LNK$GL_CTLMSK[LNK$V_SYS]				! IF A SYSTEM IMAGE
THEN LNK$GL_FVMLST[FVM$L_ADDRESS] = SYSTEM_SPACE;	! SET FIRST AVAILABLE VIRTUAL MEMORY
IF .REQESTDESC[CLI$W_QDVALSIZ] EQL 0			! IF THERE WAS NO QUALIFIER VALUE
THEN RETURN;						! THEN ALL DONE
IF .LNK$GL_CTLMSK[LNK$V_SHR]				! IF A SHAREABLE IMAGE
THEN BEGIN
	IMAGE_DESC[CLI$W_RQSIZE] = .REQESTDESC[CLI$W_QDVALSIZ];	! COPY THE FILENAME DESCRIPTOR
	IMAGE_DESC[CLI$A_RQADDR] = .REQESTDESC[CLI$A_QDVALADR];	! FROM QUALIFIER BLOCK TO THE
	RETURN;							! PARAMETER BLOCK
     END;
LNK$GL_DEFCLU[CLU$V_BASED] = TRUE;			! OTHERWISE SET THE BIT FOR FIXED IN ADDRESS SPACE
LNK$GL_CTLMSK[LNK$V_PICIMG] = FALSE;			! AND IMAGE IS NOT PIC
CH$FILL (0, CLI$C_REQDESC, BASEVALUE_DESC);		! ZERO REQUEST DESCRIPTOR
BASEVALUE_DESC[CLI$A_ERRACT] = 0;			! THEN SET UP THE DESCRIPTOR
BASEVALUE_DESC[CLI$B_RQTYPE] = CLI$K_NUMERVAL;		! FOR A RE-CALL OF CLI TO ATTEMPT A NUMERIC
IF RECALLCLI(BASEVALUE_DESC,.LNK$GL_CLIWORK,		! BASE ADDRESS SPECIFICATION
			.REQESTDESC)			! AND IF THERE WAS A SUCCESSFUL CONVERSION
THEN BEGIN
	SYSTEMBASE = .BASEVALUE_DESC[CLI$L_RQVALU];	! SAVE VALUE FOR AFTER COMMAND PROCESSING
	BASEDFLAG = TRUE;				! FLAG THAT BASE SPECIFIED NUMERICALLY FOR /SYSTEM
     END
ELSE BEGIN								! BUT IF NOT NUMERIC SET UP
	BASEVALUE_DESC[CLI$B_RQTYPE] = CLI$K_ASCIIVAL;			! TO ATTEMPT TO GET A SYMBOLIC
	BASEVALUE_DESC[CLI$A_ERRACT] = CLIERROR - 			! VALUE
				BASEVALUE_DESC;				! TO BINARY
	RECALLCLI(BASEVALUE_DESC,.LNK$GL_CLIWORK,.REQESTDESC);
	IF (SYMBOLSTRING[0] = MINU(.BASEVALUE_DESC[CLI$W_RQSIZE],	! MINIMIZE THE LENGTH
						SYM$C_MAXLNG)) EQL 0	! TO MAX ALLOWED AND IF
	THEN RETURN;							! NULL ASSUME NO SYMBOL
	CH$MOVE(.SYMBOLSTRING[0],.BASEVALUE_DESC[CLI$A_RQADDR],		! OTHERWISE BUILD A COUNTED
			SYMBOLSTRING[1]);				! ASCII STRING THAT LONG
	LNK$SEARCH(SYMBOLSTRING[0],SYMTABENT,NAMENT); 			! THEN SEARCH FOR PLACE
	LNK$INSERT(SYMBOLSTRING[0],SYMTABENT,NAMENT);			!TO INSERT AND DO IT
	LNK$INSUDFSYM(.SYMTABENT);				! INSERT UNDEFINED SYMBOL
	LNK$GW_NSYMBOLS = .LNK$GW_NSYMBOLS + 1;			! COUNT AS ONE MORE SYMBOL
	LNK$GL_DEFCLU[CLU$L_BASE] = .SYMTABENT;			! SAVE THE SYMBOL TABLE ADRESS
	LNK$GL_DEFCLU[CLU$V_SYMBAS] = TRUE;			! FLAG AS SYMBOLIC
     END;							! AND ALL DONE TILL IT IS DEFINED
RETURN TRUE
END;

ROUTINE DEBUGFILE (REQESTDESC,CLIADDR) : NOVALUE =
BEGIN
!
! CLI CALLS THIS ROUTINE WHEN THE DEBUG QUALIFIER IS SEEN
! IN THE OUTPUT IMAGE PARAMETER SPECIFICATIIN. IF THERE IS A VALUE
! PRESENT, CLI IS RE-CALLED (INDIRECTLY THROUGH CLIADDR) TO OBTAIN THE
! DESCRIPTOR OF THE FILENAME STRING OF A DEBUGGER TO BE USED IN PLACE
! OF THE SYSTEM DEFAULT DEBUGGER. IF THERE IS NO VALUE THIS ROUTINE
! SIMPLY RETURNS.
!
! NOTE THAT THE FILE WILL BECOME ONE OF THE INPUT FILES AFTER ALL
! OTHER USER INPUT HAS BEEN GATHERED AND PARSED.
!
BIND ROUTINE
    RECALLCLI = .CLIADDR;					! NAME CLI CALLBACK ROUTINE
LOCAL
    DBGFILE_DESC : BLOCK[CLI$C_REQDESC,BYTE];			! RE-CALL DESCRIPTOR BLOCK

IF .DEBUG_DESC[CLI$W_QDVALSIZ] NEQ 0				! IF THERE IS A VALUE
THEN BEGIN							! INITIALIZE THE
	CH$FILL(0,CLI$C_REQDESC,DBGFILE_DESC);			! ZERO THE DESCRIPTOR BLOCK
	DBGFILE_DESC[CLI$B_RQTYPE] = CLI$K_ASCIIVAL;		! RE-CALL DESCRIPTOR
	DBGFILE_DESC[CLI$A_ERRACT] = CLIERROR-DBGFILE_DESC;	! TO OBTAIN THE STRING DESCRIPTOR OF
	RECALLCLI(DBGFILE_DESC,.LNK$GL_CLIWORK,.REQESTDESC);	! THE DEBUGGER FILENAME STRING
	DEBUGGER[0] = .DBGFILE_DESC[CLI$W_RQSIZE];		! AND REPLACE THE DEFAULT DEBUGGER FILENAME
	DEBUGGER[1] = .DBGFILE_DESC[CLI$A_RQADDR];		! DESCRIPTOR WITH THE RESULT.
    END;
RETURN;			! AND THAT'S IT
END;

ROUTINE OUTPUTFILE (REQESTDESC) : NOVALUE =
BEGIN
!
! THIS ROUTINE IS CALLED BY CLI IF AN OUTPUT FILE IS TO
! BE CREATED. THE VARIABLE "OUTFILE" POINTS TO THE CELL WHICH IS
! TO RECEIVE THE ADDRESS OF THE FILE DESCRIPTOR BLOCK FOR THE PARTICULAR
! OUTPUT FILE.
!
MAP
	REQESTDESC : REF BLOCK[,BYTE];			! REALLY A POINTER
BIND
	FILDESC = .OUTFILE : REF BLOCK[,BYTE];		! POINT TO THE POINTER

LNK$ALLOFDB(FILDESC);					! ALLOCATE A FILE DESCRIPTOR
FILDESC[FDB$W_USRNAMLEN] = .REQESTDESC[CLI$W_RQSIZE];	! INSERT THE PARAMETER DESCRIPTOR
FILDESC[FDB$L_USRNAMADR] = .REQESTDESC[CLI$A_RQADDR];	! ... BOTH LONGWORDS OF IT
RETURN;								! AND WE ARE ALL DONE
END;

GLOBAL ROUTINE LNK$SETLIBRIN (REQESTDESC) : NOVALUE =
BEGIN
!
! THIS ROUTINE IS CALLED BY CLI IF THE LIBRARY INPUT FILE
! QUALIFIER IS SEEN ON AN INPUT PARAMETER.
!
MAP
	REQESTDESC : REF BLOCK[,BYTE];			! POINTER TO A BLOCK

BIND
	LIBFILTYPE = UPLIT(BYTE('.OLB'));		! LIBRARY FILE TYPE

IF .REQESTDESC[CLI$W_QDVALSIZ] NEQ 0			! IF THE QUALIFIER HAS A VALUE,
THEN BEGIN
	INFILFLGS = .INFILFLGS OR FDB$M_LIBEXTR;	! THIS IS AN EXPLICIT EXTRACT
	LNK$AL_LBQLDSC[CLI$W_QDVALSIZ] = .REQESTDESC[CLI$W_QDVALSIZ];	! SO COPY THE DESCRIPTOR OF THE INCLUSION
	LNK$AL_LBQLDSC[CLI$A_QDVALADR] = .REQESTDESC[CLI$A_QDVALADR];	! MODULE LIST SO LAST ONE WINS
     END
ELSE BEGIN						! IF NO VALUE, JUST A SEARCH TO RESOLVE SYMBOLS
	IF .LNK$GL_CLULST[0] EQL 0			! IF NO PRECEDING CLUSTERS
	AND .LNK$GL_CURCLU[CLU$L_FSTFDB] EQL 0		! AND NO FILES IN CURRENT CLUSTER
	AND (.INFILFLGS AND FDB$M_LIBEXTR) EQL 0	! AND NOT EXPLICIT INCLUSION FROM THE
	    THEN SIGNAL_STOP(LIN$_FIRSTMOD);		! FILE GIVE UP WITH AN ERROR
	INFILFLGS = .INFILFLGS OR FDB$M_LIBSRCH;	! SINCE MUST HAVE AT LEAST ONE MODULE
     END;
TYPEADR = CH$PTR(LIBFILTYPE);				! SET ADDRESS OF DEFAULT FILE TYPE
RETURN;
END;

ROUTINE OPTIONFILE (REQSTDESC) : NOVALUE =
BEGIN
!
! SET THE DEFAULT FILE TYPE FOR LINK TIME OPTIONS
!
BIND
	OPTFILTYPE = UPLIT(BYTE('.OPT'));

TYPEADR = CH$PTR(OPTFILTYPE);
RETURN;
END;

GLOBAL ROUTINE LNK$SETSHRBLIN  : NOVALUE =
BEGIN
!
! SET THE DEFAULT FILE TYPE FOR SHAREABLE IMAGES
!

BIND
	SHRFILTYPE = UPLIT(BYTE('.EXE'));

TYPEADR = CH$PTR(SHRFILTYPE);				! SET DEFAULT FILE TYPE POINTER

RETURN;
END;

ROUTINE SETUSERLIB (REQUESTDESC, CLIADDR) =
BEGIN
!
! THIS ROUTINE IS CALLED BY CLI FOR THE /USER[LIBRARY] QUALIFIER.
! THE DEFAULT IS /USERLIBRARY=(PROCESS, GROUP, SYSTEM).  IF THERE
! IS A LIST OF LOG. NAME TABLES, ONLY THOSE TABLES SPECIFIED WILL
! BE SEARCHED.
!
MAP
    REQUESTDESC : REF BLOCK[,BYTE];

BIND ROUTINE
    RECALLCLI = .CLIADDR;

LOCAL
    GETASC_DESC : BLOCK [CLI$C_REQDESC, BYTE];		! REQUEST DESCRIPTOR TO GET ASCII STRING

CH$FILL (0, CLI$C_REQDESC, GETASC_DESC);		! ZERO THE DESCRIPTOR
GETASC_DESC[CLI$B_RQTYPE] = CLI$K_ASCIIVAL;		! GET ASCII VALUE
GETASC_DESC[CLI$A_ERRACT] = CLIERROR - GETASC_DESC;
WHILE .REQUESTDESC[CLI$W_QDVALSIZ] NEQ 0		! LOOP FOR ALL SPECIFIED
DO BEGIN
    RECALLCLI (GETASC_DESC, .LNK$GL_CLIWORK, .REQUESTDESC); ! GET A STRING
    IF .GETASC_DESC[CLI$W_RQSIZE] NEQ 0			! IF A STRING WAS THERE
    THEN
	IF NOT CALL_TPARSE(GETASC_DESC[CLI$W_RQSIZE],
				USERLIB_STATES,USERLIB_KEYS)
	    THEN BEGIN
		CH$MOVE(DSC$C_S_BLN,GETASC_DESC[CLI$W_RQSIZE],	! PUT DESCRIPTOR IN RIGHT LOCATION FOR CLIERROR
				REQUESTDESC[CLI$W_RQSIZE]);
		CLIERROR(.REQUESTDESC,LIN$_ILLQUALVAL);	! NO RETURN FROM THIS
		END;
    END;
IF .LNK$GL_ULIBMASK EQL 0				! IF NOTHING FOUND
    THEN LNK$GL_ULIBMASK = 7				! THEN ENABLE ALL LOGICAL NAME TABLES
    ELSE IF .LNK$GL_ULIBMASK LSS 0			!  WILL BE LSS 0 IF /USERLIB=NONE
	THEN LNK$GL_ULIBMASK = 0;
RETURN TRUE;						!
END;							! OF SETUSERLIB

ROUTINE INPUTFILE (REQSTDESC) : NOVALUE =
BEGIN
!
! THIS ROUTINE IS CALLED BY CLI FOR EACH FILE IN THE COMMAND
! INPUT PARAMETER LIST.
!
!	THE ROUTINE ALLOCATES AN INTERNAL FILE DESCRIPTOR BLOCK
!	THEN, USING THE INPUT FILE FAB ALLOCATED IN THE 
!	COMMAND PROCESSING DRIVER ROUINE ATTEMPTS TO OPEN
!	THE SPECIFIED FILE.
!
!	IF THIS IS SUCCESSFUL, THE AUXILIARY FILENAME BLOCK PART
!	OF OUR FDB IS INITIALIZED BY RMS. OTHER USEFUL 
!	FIELDS OF THE FDB (SUCH AS THE FILE FLAGS) ARE INITIALIZED
!	THEN THE FDB IS ADDED TO THE FDB LIST. THE FILE IS
!	THEN CLOSED, SO THAT AN OPEN BY FILE ID MAY BE PERFORMED
!	ON THE FILE HEREAFTER.
!
!	FAILURE TO OPEN THE FILE AT THIS POINT IS FATAL AND
!	THE LINK ABORTS.
!
!	REQSTDESC IS THE ADDRESS OF THE INPUT PARAMETER
!	DESCRIPTOR BEING USED BY CLI.
!
!	INFILFLGS CONTAINS THE SETTINGS OF THE INPUT
!	FILE CONTROL FLAGS AS DETERMINED BY THE CLI AND
!	QUALIFIERS USED.
!
LITERAL
	MAXOPTRECLEN = 132;				! MAXIMUM LENGTH OF OPTION FILE RECORDS

MAP
	REQSTDESC : REF BLOCK[,BYTE];			! REALLY A POINTER

OWN
	RELNAMBLK;					! THE PREVIOUS FILE AT THIS OPTION
							! FILE LEVEL IS ALSO THE
							! RELATED FILE FOR STICKY DEVICE
							! AND DIRECTORY
LOCAL
	FILDESBLK : REF BLOCK[,BYTE],			! POINTER TO FDB
	AUXFNB : REF BLOCK[,BYTE],			! AUXILIARY FILE NAME BLOCK POINTER
	FILENAMEDESC : REF BLOCK[,BYTE],		! FILE NAME DESCRIPTOR IN FDB
	INPUT_FAB : BLOCK[FAB$C_BLN,BYTE],		! FAB FOR THE FILE OPENS.
	OPTIONRAB : BLOCK[RAB$C_BLN,BYTE],		! RAB FOR OPTION FILE INPUT STREAM
	STVCODE,					! STV VALUE FOR ERROR OUTPUT
	ERRORCODE;					! RMS ERROR CODE

LNK$ALLOFDB(FILDESBLK);					! GO ALLOCATE NEW FILE DESCRIPTOR
AUXFNB = FILDESBLK[FDB$T_AUXFNB];			! POINT TO FILENAME BLOCK PART
FILENAMEDESC = FILDESBLK[FDB$Q_FILENAME];		! POINT TO FILE NAME DESCRIPTOR
IF (.INFILFLGS AND FDB$M_DEBUGER) EQL 0			! AND IF THIS IS NOT THE DEBUGGER
THEN AUXFNB[NAM$L_RLF] = .RELNAMBLK;			! SET THE RELATED FILE TO PREVIOUS
FILDESBLK[FDB$B_FILFLGS] = .INFILFLGS AND NOT FDB$M_NEWUDF;	! COPY THE FLAGS TURNING OFF BIT 0
IF (.INFILFLGS AND FDB$M_LIBEXTR) NEQ 0				! IF EXPLICIT MODULE EXTRACTION
THEN BEGIN
	FILDESBLK[FDB$W_LIBLSTLNG] = .LNK$AL_LBQLDSC[CLI$W_QDVALSIZ];	! COPY THE PARAMETER DESCRIPTOR
	FILDESBLK[FDB$L_OMDLST] = .LNK$AL_LBQLDSC[CLI$A_QDVALADR];	! LENGTH AND ADDRESS FOR LATER
      END;
INFILFLGS = 0;							! AND THEN RESET THEM
$FAB_INIT(FAB=INPUT_FAB,					! INTIALIZE THE FAB
	FAC=GET,						! FOR INPUT
	FOP=SQO,
	SHR=(UPI,GET,PUT),
	FNS=.REQSTDESC[CLI$W_RQSIZE],
	FNA=.REQSTDESC[CLI$A_RQADDR],
	NAM=.AUXFNB,
	DNS=TYPELEN,
	DNA=.TYPEADR);
FILDESBLK[FDB$W_USRNAMLEN] = .REQSTDESC [CLI$W_RQSIZE];		! COPY THE USER'S FILENAME
FILDESBLK[FDB$L_USRNAMADR] = .REQSTDESC[CLI$A_RQADDR];		! INTO THE FDB ALSO
IF (IF 
    ((ERRORCODE = $OPEN(FAB = INPUT_FAB)) EQL RMS$_NORMAL) 	! NOW ATTEMPT THE OPEN
	THEN (CH$MOVE(DSC$C_S_BLN,LNK$FILNAMDSC(INPUT_FAB),.FILENAMEDESC);
		FALSE)
	ELSE (STVCODE = .INPUT_FAB[FAB$L_STV];
		CH$MOVE(DSC$C_S_BLN,LNK$FILNAMDSC(INPUT_FAB),.FILENAMEDESC);
		TRUE))
OR BEGIN							! AND THE CONNECT IF THIS
	IF NOT .FILDESBLK[FDB$V_OPTION]				! IS AN OPTION FILE
	THEN BEGIN						! BUT IF IT IS NOT
		LOCAL 
		    LASTFDB : REF BLOCK[,BYTE];

		LASTFDB = .LNK$GL_CURCLU[CLU$L_LSTFDB];		! OTHERWISE SET UP TO PUT ON
		LNK$GL_CURCLU[CLU$L_LSTFDB] = .FILDESBLK; 	! END OF CURRENT CLUSTER
		IF .LNK$GL_INRELNAM EQL 0			! IF NO INPUT FILE RELATED NAM BLOCK SET UP
		    THEN LNK$GL_INRELNAM = .AUXFNB; 		! THEN USE THIS ONE
		LASTFDB[FDB$L_NXTFDB] = .FILDESBLK;		! AND DO SO
		RELNAMBLK = .AUXFNB;				! AND THIS FILENAME BLOCK IS THE RELATED FOR NEXT
		FALSE
	     END
	ELSE BEGIN
		$RAB_INIT(RAB=OPTIONRAB,
			FAB=INPUT_FAB,
			USZ=MAXOPTRECLEN,
			RAC=SEQ,
			ROP=LOC);
		IF (ERRORCODE = $CONNECT(RAB=OPTIONRAB))	! CONNECT THE OPTIONS FILE FOR READING
		THEN BEGIN					! AND IF CONNECTED OK
			TYPEADR = CH$PTR(DEFILETYPE);		! RESET THE DEFAULT FILE TYPE
			RELNAMBLK = 0;				! BLOCK THEN RESET TO NONE
			LNK$ALLOBLK(MAXOPTRECLEN,OPTIONRAB[RAB$L_UBF]);	! ALLOCATE BUFFER FOR RECORDS CROSSING BLOCK BOUNDARIES
			LNK$PROCOPTNS(.REQSTDESC,.FILENAMEDESC,INFILFLGS,OPTIONRAB); ! AND GO PROCESS IT
			RELNAMBLK = .AUXFNB;					! RESTORE RELATED FILE
			LNK$DEALBLK(.OPTIONRAB[RAB$W_USZ],.OPTIONRAB[RAB$L_UBF]);	! AND DEALLOCATE
			LNK$GL_CURCLU = LNK$GL_DEFCLU;			! AND RESET DEFAULT AS CURRENT
			FALSE						! THE BUFFER
		     END
		ELSE (
			STVCODE = .OPTIONRAB[RAB$L_STV];		! IF ERROR STORE STV FOR ERROR OUTPUT
			TRUE)
	     END
       END
THEN 									! AND IF IT FAILS REPORT
	SIGNAL_STOP(LIN$_OPENIN,1,.FILENAMEDESC,.ERRORCODE,.STVCODE);

IF (ERRORCODE=$CLOSE (FAB=INPUT_FAB)) NEQ RMS$_NORMAL		! THEN CLOSE FILE, PRESERVING
THEN 								! THE AUXILLIARY FNB
	SIGNAL(LIN$_CLOSEIN,1,.FILENAMEDESC,
			.ERRORCODE,.INPUT_FAB[FAB$L_STV]);

TYPEADR = CH$PTR(DEFILETYPE);					! RESET THE DEFAULT FILE TYPE
RETURN;
END;

GLOBAL ROUTINE LNK$ALLOFDB(FDBPOINTER) : NOVALUE =
BEGIN
!
!	THIS ROUTINE ALLOCATES SOME MORE DYNMAIC MEMORY FOR
!	FILE DESCRIPTOR BLOCKS AND
!	RMS RESULTANT STRINGS AND INSERTS INTO
!	AN AUXILIARY FILE NAME BLOCK THE LENGTH AND
!	ADDRESS FOR RESULTANT AND EXPANDED STRINGS RETURNED ON OPENS
!	ON ANY CALL IF THERE IS NOT SUFFICIENT RESULTANT STRING
!	AREA FOR THE MAXIMUM, MORE IS ALLOCATED. ALSO ON EACH
!	CALL THE ROUTINE CHECKS RSL OF THE PREVIOUSLY ALLOCATED
!	AUXILIARY FILE NAME BLOCK AND IF NON ZERO, REDUCES THE REMAINING
!	STRING AREA BY THAT ACTUALLY USED. IF STILL ZERO THE AREA IS
!	REDUCED BY THE MAXIMUM SIZE BEFORE THE DECISION TO ALLOCATE
!	MORE IS MADE.
!
OWN
	PREVFNB : REF BLOCK[,BYTE];			! PREVIOUS AUXILIARY FILENAME BLOCK

LOCAL
	FDBLOCK : REF BLOCK[,BYTE],			! FILE DESCRIPTOR BLOCK ALLOCATED
	RSAREDUCTION,					!
	TEMPRSAPOINTER;					! FOR ALLOCATING RESULTANT
							! STRING BUFFERS
MAP
	FDBPOINTER : REF VECTOR;			! PASSED AN ADDRESS AT WICH TO STORE

IF .PREVFNB NEQ 0					! IF ONE HAS BEEN ALLOCATED
THEN BEGIN						! PREVIOUSLY, TRY TO USE THE ACTUAL
	IF (RSAREDUCTION = .PREVFNB[NAM$B_RSL]) EQL 0	! AMOUNT CONSUMED TO REDUCE
	THEN RSAREDUCTION = .PREVFNB[NAM$B_RSS];	! THE AVAILABLE AREA BUT IF NONE
	RSAREMSIZE = .RSAREMSIZE - .RSAREDUCTION;	! CONSUMED, REDUCE BY THE TOTAL
	NEXTRSA = .NEXTRSA + .RSAREDUCTION;		! AND UPDATE THE ADDRESS OF NEXT AVAILABLE
     END;
IF .RSAREMSIZE LSSU NAM$C_MAXRSS			! IF THERE IS NOT ENOUGH
THEN BEGIN						! SPACE IN RESULTANT
	LNK$ALLOBLK (RSA_ALLOSIZE,TEMPRSAPOINTER);	! STRING BUFFER FOR
							! THE MAXIMUM ONE,
	IF .TEMPRSAPOINTER EQL .NEXTRSA+.RSAREMSIZE	! GO ALLOCATE SOME
							! MORE
	THEN RSAREMSIZE = .RSAREMSIZE+RSA_ALLOSIZE	! IF IT WAS ALLOCATED
	ELSE BEGIN					! CONTIGUOUSLY WITH PREVIOUS
		RSAREMSIZE = RSA_ALLOSIZE;		! AREA UPDATE AVAILABLE
		NEXTRSA = .TEMPRSAPOINTER;		! LENGTH ELSE FORGET THE
		END;					! PREVIOUS AREA AND STAY
     END;						! WITH THE NEW
LNK$ALLOBLK(FDB$C_SIZE+NAM$C_BLN,FDBLOCK);		! ALLOCATE FILE DESCRIPTOR
FDBPOINTER[0] = .FDBLOCK;				! RETURN ITS ADDRESS
CH$FILL(0,FDB$C_SIZE+NAM$C_BLN,.FDBLOCK);		! ZERO THE FDB
PREVFNB = FDBLOCK[FDB$T_AUXFNB];			! GET ADDRESS OF THE FILE NAME BLOCK PART
$NAM_INIT(NAM=.PREVFNB,					! INITIALIZE THE NAM BLOCK
	RSA=.NEXTRSA,
	RSS=NAM$C_MAXRSS,
	ESA=.NEXTRSA,
	ESS=NAM$C_MAXRSS);

RETURN;							! AND THAT'S IT
END;

GLOBAL ROUTINE LNK$CLUNAMCMP (KEYNAME, NODE) =
BEGIN
!
! THIS ROUTINE COMPARES AN ASCIC KEYNAME WITH THE CURRENT
! ENTRY
!
MAP
    KEYNAME : REF VECTOR[,BYTE],
    NODE : REF BLOCK[,BYTE];

LOCAL
    CLU : REF BLOCK[,BYTE];

CLU = .NODE[NODE$L_PTR];				! POINT TO CLUSTER DESCRIPTOR
RETURN CH$COMPARE(.KEYNAME[0],KEYNAME[1],.CLU[CLU$B_NAMLNG],
			CLU[CLU$T_NAME])
END;

GLOBAL ROUTINE LNK$COMPARE_PDD (KEYNAME,PDD) =
BEGIN
!
! ROUTINE TO COMPARE ASCII PSECT NAME WITH CURRENT ENTRY
!
MAP
    KEYNAME : REF VECTOR[,BYTE],
    PDD : REF BLOCK[,BYTE];

RETURN CH$COMPARE(.KEYNAME[0],KEYNAME[1],(.PDD[PDD$B_NAMLNG] AND NOT %X'80'),
			PDD[PDD$T_NAME])
END;

GLOBAL ROUTINE LNK$ALLOC_PDD (KEYNAME,RETADR) =
BEGIN
!
! ALLOCATE A NEW PDD BLOCK
!
MAP
    KEYNAME : REF VECTOR[,BYTE],
    RETADR : REF VECTOR[,LONG];

LOCAL
    PDD : REF BLOCK[,BYTE];

LNK$ALLOBLK(PDD$C_SIZE+.KEYNAME[0],PDD);		! ALLOCATE THE PDD
CH$FILL(0,PDD$C_SIZE,.PDD);				! ZERO IT
PDD[PDD$W_FLAGS] = PSC$M_OPTPSC;			! SET DEFINED BY OPTION FLAG
PDD[PDD$B_ALIGN] = -1;					! SET NO ALIGNMENT SPECIFIED
CH$MOVE(.KEYNAME[0]+1,KEYNAME[0],PDD[PDD$B_NAMLNG]);	! INSERT THE NAME
RETADR[0] = .PDD;
RETURN TRUE
END;

GLOBAL ROUTINE LNK$COLLECTPSCT : NOVALUE =
BEGIN
!
!	THIS ROUTINE IS CALLED AT THE END OF COMMAND PROCESSING TO
!	PROCESS THE DATA BASE SET UP BY THE PSECT DEFINITION AND
!	COLLECTION OPTIONS.  A PASS IS MADE OVER THE LIST OF PSECTS
!	HANGING OFF EACH CLUSTER MENTIONED IN A COLLECT OPTION. FOR
!	EACH PSECT IN THAT LIST, DEFINE IT.  
!
LOCAL
	CURCLUSTER : REF BLOCK[,BYTE],				! POINTER TO CURRENT CLUSTER DESCRIPTOR
	LSTCLUSTER : REF BLOCK[,BYTE],				! POINTER TO LAST CLUSTER DESCRIPTOR
	CURPSCT : REF BLOCK[,BYTE],				! POINTER TO CURRENT PSECT NAME BLOCK
	CLUDESC : REF BLOCK[,BYTE],				! POINTER TO CLUSTER DESCRIPTOR
	PSCTDESC : REF BLOCK[,BYTE],				! POINTER TO PSECT DESCRIPTOR
	PSCTDEF : REF BLOCK[,BYTE];				! POINTER TO PSECT DEFINITION BLOCK

CURCLUSTER = .LNK$GL_CCLULST;					! POINT TO FIRST CLUSTER NAME BLOCK
!
! LOOP THROUGH ALL NAMED CLUSTERS
!
WHILE .CURCLUSTER NEQ 0
DO BEGIN
	IF NOT LIB$LOOKUP_TREE(LNK$GL_CLUTREE,CURCLUSTER[CCD$B_NAMLNG], ! LOOKUP UP CLUSTER
				LNK$CLUNAMCMP,CLUDESC)
	THEN BEGIN						! AND IF NOT DEFINED YET
		LNK$ALLOCLUSTER(CLUDESC);			! THEN DO IT NOW
		CH$MOVE(.CURCLUSTER[CCD$B_NAMLNG]+1,		! COPY IN THE NAME
			CURCLUSTER[CCD$B_NAMLNG],CLUDESC[CLU$B_NAMLNG]);
		LNK$INSERT_CLU(.CLUDESC);			! INSERT INTO CLUSTER TREE
		IF .CURCLUSTER[CCD$B_PROTECT]			! IF THE CLUSTER SHOULD BE PROTECTED
		    THEN CLUDESC[CLU$V_PROTECT] = TRUE; 	! THEN FLAG IT NOW
		LNK$GL_CURCLU = .CLUDESC;			! MAKE IT THE CURRENT CLUSTER
		END
	ELSE LNK$GL_CURCLU = .CLUDESC[NODE$L_PTR];		! FOUND--MAKE IT THE CURRENT CLUSTER
	CURPSCT = .CURCLUSTER[CCD$L_PSCLST];			! POINT TO FIRST PSECT BLOCK
	LSTCLUSTER = .CURCLUSTER;				! REMEMBER THIS ONE
	CURCLUSTER = .CURCLUSTER[CCD$L_NXTCLU];			! AND POINT TO NEXT ONE
	LNK$DEALBLK(CCD$C_SIZE,.LSTCLUSTER);			! DEALLOCATE IT
	!
	! NOW GET ALL THE PSECTS COLLECTED INTO THAT CLUSTER
	!
	WHILE .CURPSCT NEQ 0
	DO BEGIN
		LOCAL
		    DEFBYOPT,
		    OPTFLAGS;

		IF NOT (DEFBYOPT = LNK$SRCPSCDEF(CURPSCT[CPD$B_NAMLNG],PSCTDEF))
		    THEN
			LIB$INSERT_TREE(LNK$GL_PSCDFLST,CURPSCT[CPD$B_NAMLNG],	! INSERT INTO DEFINED BY OPTION LIST
					%REF(0),LNK$COMPARE_PDD,
					LNK$ALLOC_PDD,PSCTDEF);
		OPTFLAGS = PSCTDEF[PDD$W_FLAGS] = .PSCTDEF[PDD$W_FLAGS]	! MARK PSECT AS GLOBAL
							OR GPS$M_GBL;
		LNK$FNDPSCNAM(CURPSCT[CPD$B_NAMLNG],.OPTFLAGS,0,PSCTDESC); ! ENTER PSECT IN CURRENT CLUSTER
		IF .DEFBYOPT					! IF DEFINED BY OPTION
		THEN BEGIN
		    PSCTDESC[PSC$W_FLAGS] = .PSCTDEF[PDD$W_FLAGS]; ! THEN COPY THE DEFINED FLAGS
		    IF (PSCTDESC[PSC$B_ALIGN] = .PSCTDEF[PDD$B_ALIGN]) EQL %X'FF' ! AND THE ALIGNMENT
			THEN PSCTDESC[PSC$B_ALIGN] = 0;		! AND IF DEFAULTED USE BYTE ALIGNMENT
		    PSCTDEF[PDD$B_NAMLNG] = .PSCTDEF[PDD$B_NAMLNG] OR %X'80'; ! FLAG PSECT ALREADY DEFINED
		    END;
		CURPSCT = .CURPSCT[CPD$L_NXTPSC];		! POINT TO NEXT NAME BLOCK
		END						! CURPSCT NEQ 0
	END;							! CURCLUTER NEQ 0
RETURN;
END;

GLOBAL ROUTINE LNK$SRCPSCDEF(PSCNAM,PSCTDESC) =
BEGIN
!
! LOOK UP PSECT NAME IN THE PSECTS DEFINED BY OPTION
!
MAP
	PSCNAM : REF VECTOR[,BYTE],			! ASCIC NAME
	PSCTDESC : REF BLOCK[,BYTE];			! POINTER

RETURN LIB$LOOKUP_TREE(LNK$GL_PSCDFLST,.PSCNAM,LNK$COMPARE_PDD,
				.PSCTDESC)
END;

GLOBAL ROUTINE LNK$ALLOCLUSTER(CLUSTERDESC,DUMMYARG) : NOVALUE =
BEGIN
!
!	ALLOCATE A CLUSTER DESCRIPTOR AND LINK ON END OF THE LIST
!	ALSO INITIALIZE SOME FIELDS OF IT NOW
!
!	IF THE SECOND ARGUMENT IS PRESENT, THE CLUSTER DESCRIPTOR IS
!	NOT LINKED INTO THE LIST.
!
MAP
	CLUSTERDESC : REF VECTOR[,LONG];

LOCAL
	NEWCLUSTER : REF BLOCK[,BYTE];

BUILTIN
	NULLPARAMETER;

LNK$ALLOBLK(CLU$C_SIZE,CLUSTERDESC[0]);			! ALLOCATE THE BLOCK
NEWCLUSTER = .CLUSTERDESC[0];				! RETRIEVE ITS ADDRESS
CH$FILL(0,CLU$C_SIZE,.NEWCLUSTER);			! ZERO THE DESCRIPTOR
NEWCLUSTER[CLU$L_LSTFDB] = NEWCLUSTER[CLU$L_FSTFDB];	! SO EMPTY LIST
NEWCLUSTER[CLU$L_LSTISD] = NEWCLUSTER[CLU$L_FSTISD];	!
NEWCLUSTER[CLU$L_LSTADRL] = NEWCLUSTER[CLU$L_FSTADRL];
LNK$GW_NCLUSTERS = .LNK$GW_NCLUSTERS + 1;		! COUNT THE CLUSTER
IF NULLPARAMETER(2)					! IF SECOND ARGUMENT NOT SUPPLIED
THEN BEGIN						!  THEN LINK INTO END OF CLUSTER LIST
    LNK$GL_LASTCLU[CLU$L_NXTCLU] = .NEWCLUSTER;		! SET POINTER
    NEWCLUSTER[CLU$L_PREVCLU] = .LNK$GL_LASTCLU;
    LNK$GL_LASTCLU = .NEWCLUSTER;			! FOR LAST IN LIST
    END;
RETURN;
END;

GLOBAL ROUTINE LNK$INSERT_CLU (CLUDESC) =
BEGIN
!
! THIS ROUTINE IS CALLED TO INSERT A CLUSTER DESCRIPTOR INTO THE BALANCED
! BINARY TREE OF CLUSTER DESCRIPTORS.
!
! INPUTS:
!
!	CLUDESC		ADDRESS OF CLUSTER DESCRIPTOR
!
! OUTPUTS:
!
!	DESCRIPTOR IS ENTERED INTO TREE
!
ROUTINE CLUNODEALLOC (KEYNAME,RETADR,CLUDESC) =
BEGIN
!
! ROUTINE TO ALLOCATE NODE FOR NEW CLUSTER
!
MAP
    KEYNAME : REF VECTOR[,BYTE],
    RETADR : REF VECTOR[,LONG],
    CLUDESC : REF BLOCK[,BYTE];

LOCAL
    NODEPTR : REF BLOCK[,BYTE];

LNK$ALLOBLK(NODE$C_LONG+.KEYNAME[0],NODEPTR);
NODEPTR[NODE$L_PTR] = .CLUDESC;
RETADR[0] = .NODEPTR;

RETURN TRUE
END;
!
! MAIN BODY OF LNK$INSERT_CLU
!
MAP
    CLUDESC : REF BLOCK[,BYTE];

LOCAL
    BLOCKADDR;

RETURN LIB$INSERT_TREE(LNK$GL_CLUTREE,CLUDESC[CLU$B_NAMLNG],
			%REF(0),LNK$CLUNAMCMP,CLUNODEALLOC,
			BLOCKADDR,.CLUDESC)

END;
END ELUDOM
