MODULE LNK_IMGOUT (IDENT='V03-010',
			ADDRESSING_MODE(EXTERNAL=GENERAL,
					NONEXTERNAL=LONG_RELATIVE)
			) =

BEGIN
!
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
!
!
!
!++
!
! MODULE: LNK_IMGOUT
!
! FACILITY: LINKER
!
! ABSTRACT: CONTROL PRODUCTION OF IMAGE FILE
!
! HISTORY:
!
!	VERSION: X01.00
!
!	AUTHOR: T.J. PORTER 06-APR-77
!
! MODIFIED BY:
!
!	V03-010	BLS0151		Benn Schreiber		21-Feb-1982
!		Allocate virtual memory for fixup section using lnk$allovirmem
!		to catch case of based image coming down on top of where
!		fixup section was going to be.
!
!	V03-010	BLS0165		Benn Schreiber		23-Mar-1982
!		Set pointer to NAM when closing file in case deleting
!
!	V03-009	BLS0135		Benn Schreiber		14-Jan-1982
!		Set protect in fixup vector isd if /protect.  Set fixupvec
!		bit in fixup vector isd.
!
!	V03-008	BLS0109		Benn Schreiber		17-Nov-1981
!		Correct basing of .address fixup data
!
!	V03-007	BLS0102		Benn Schreiber		 9-Nov-1981
!		Correct basing of protection data addresses
!
!	V03-006	BLS0078		Benn Schreiber		 4-Sep-1981
!		Subtract low cluster base address from .address fixup
!		address stored
!
!	V03-005	BLS0068		Benn Schreiber		12-Aug-1981
!		Add shl_extra link option
!
!	V03-004	BLS0050		Benn Schreiber		23-Mar-1981
!		Independent shareable images
!
!	V03-003	BLS0042		Benn Schreiber		25-Feb-1981
!		Delete deferred relocation
!
!	V03-002	BLS0036		Benn Schreiber		19-Jan-1981
!		Add psect name to outsimg message if present
!	V03-001	BLS0007		Benn Schreiber,		3-Jun-1980
!		Convert to MDL data structures.
!--

!
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	THIS MODULE CONTAINS ALL ROUTINES ASSOCIATED WITH IMAGE OUTPUT
!	IT CONTAINS THE FOLLOWING EXTERNALLY CALLED ROUTINES:
!	LNK$IMGINIT	- NO ARGUMENTS
!
!	LNK$WRTIMGHDR	- NO ARGUMENTS
!			    - PROCESSES THE SINGLY LINKED LIST OF IMAGE
!			      SECTION DESCRIPTORS, BUILDING THE IMAGE
!			      HEADER WITH ALL ITS ISDS
!	LNK$WRTIMGBYTS(BYTECOUNT,BUFFRADR,REPTCOUNT)
!			     - WRITES "BYTECOUNT" BYTES FROM "BUFFRADR"
!			       "REPTCOUNT" TIMES AND UPDATES THE
!			        LINKER'S LOCATION COUNTER BY THE
!			        TOTAL NUMBER OF BYTES. IF 
!				REPTCOUNT IS ZERO, IT IS SET TO 1
!			     - ATTEMPTS TO WRITE A BYTE STREAM,
!			       ANY PART OF WHICH FALLS OUTSIDE
!			       THE SPACE ALLOCATED TO THE 
!			       IMAGE PRODUCES AN ERROR AND
!			       VALUE FALSE IS RETURNED.
!	LNK$FLUSHIMG         - NO ARGUMENTS
!			     - WRITES EVERY BLOCK OF IMAGE, ENSURING
!			       THAT THOSE NOT TOUCHED HERETOFORE
!			       ARE ZERO FILLED.
!	LNK$CLOSIMGFIL	- NO ARGUMENTS
!			- CLOSES THE IMAGE FILE
!
!	ANY OF THE ABOVE ERRORS TURNS OFF IMAGE PRODUCTION
!	(BIT LNK$S_IMAGE IN LNK$GL_CTLMSK).
!
!
!--
!
LIBRARY
	'LIBL32';				! SYSTEM USER DATA STRUCTURES
REQUIRE
	'PREFIX';
LIBRARY
	'DATBAS';				! INTERNAL DATABASE
REQUIRE
	'ISGENC';				! IMAGE SECTION FORMATS

FORWARD ROUTINE
	LNK$CLOSIMGFIL : NOVALUE,		! CLOSE ROUTINE
	INCHDRSIZE : NOVALUE,			! ROUTINE THAT ACCUMULATES HEADER SIZE
	ISDTOHEADER : NOVALUE,			! COPY AN ISD INTO THE HEADER
	WRITEISECTS,				! WRITE ALL ISECTS TO IMAGE
	LNK$GETFIXSIZE,				! COMPUTE SIZE OF FIXUP SECTION
	STORESPCGFIX,				! STORE SPECIAL G^ FIXUP DATA
	LNK$CREATEFIX,				! CREATE AND INIT FIXUP SECTION
	READSECTION : NOVALUE,			! READ GLOBAL SECTIONS FROM SHAREABLE IMAGES
	WRITESECTION;				! WRITES A SECTION OF AN IMAGE

EXTERNAL ROUTINE
	LIB$TRAVERSE_TREE,				! TRAVERSE A BINARY TREE
	LNK$FILNAMDSC,					! GET FILE NAME FROM FAB
	LNK$ALLOBLK : NOVALUE, 				! ALLOCATE DYNAMIC MEMORY
	LNK$DEALBLK : NOVALUE, 				! DEALLOCATE DYNAMIC MEMORY
	LNK$ALLOVIRMEM,					! ALLOCATE VIRTUAL MEMORY
	LNK$CREFIXISD,					! CREATE FIXUP ISD
	LNK$SORTISECTS : NOVALUE,			! SORT IMAGE SECTION LIST
	LNK$SEARCH;					! SYMBOL TABLE SEARCH

EXTERNAL LITERAL
	LIN$_CLOSEIN,					! ERROR CLOSING INPUT FILE
	LIN$_CLOSEOUT,					! ERROR CLOSING OUTPUT FILE
	LIN$_CONFIXMEM,					! BASED IMAGE HAPPENED ON TOP OF FIXUP SECTION
	LIN$_DBGTFR,					! NO DEBUGGER TRANSFER ADDRESS
	LIN$_GETPTIERR,					! ERROR RETURNED FROM SYS$GETPTI
	LIN$_MEMFUL,					! FAILED TO MAP THE IMAGE
	LIN$_NOIMGFIL,					! NO IMAGE FILE CREATED
	LIN$_OPENIN,					! ERROR OPENING INPUT FILE
	LIN$_OPENOUT,					! ERROR OPENING OUTPUT FILE
	LIN$_OUTSIMG,					! ATTEMPT TO STORE OUTSIDE IMAGE
	LIN$_OUTSIMGP,					! DITTO, BUT WITH A PSECT NAME
	LIN$_READERR,					! READ FAILURE ON SHAREABLE IMAGE
	LIN$_TFRSYS,					! TRANSFER ADDRESS IN SYSTEM IMAGE
	LIN$_USRTFR,					! NO USER TRANSFER ADDRESS IN EXE IMAGE
	LIN$_WRITEERR;					! WRITE ERROR CODE

EXTERNAL
	LNK$GL_MINVA,					! LOWEST ADDRESS VA ALLOCATED BY VMCTRL
	LNK$GL_LASTGADR,				! LAST SPECIAL G^ FIXUP VA
	LNK$GL_SPCGFIX,					! NUMBER OF SPECIAL G^ FIXUPS
	LNK$GL_SPCGIMGS,				! NUMBER OF SHR IMGS REFERENCED BY SPECIAL G^ FIXUPS
	LNK$GL_ADREFS,					! NUMBER OF .ADDRESS FIXUP REFERENCES
	LNK$GL_SHRADR,					! NUMBER OF SHR IMAGES REF'D BY .ADDRESS
	LNK$GL_SHRIMGS,					! NUMBER OF PIC SHAREABLE IMAGES
	LNK$GL_SHRSYMS,					! NUMBER OF SYMBOLS IN THOSE IMAGEES
	LNK$GL_SHLEXTRA,				! SHL_EXTRA REQUEST
	LNK$GL_FIXISD : REF BLOCK[,BYTE],		! ISD OF FIXUP SECTION
	LNK$GL_LOWCLU : REF BLOCK[,BYTE],		! ADDR OF LOWEST VA NON-SHR IMG CLUSTER
	LNK$AW_VERSION : BLOCK[,BYTE],			! VERSION NUMBER
	LNK$GT_SYSVER : BLOCK[,BYTE],			! "SYS$K_VERSION" ASCIC STRING
	LNK$GL_CUROMD : REF BLOCK[,BYTE],		! POINTER TO CURRENT OBJ MODULE DESCRIPTOR
	LNK$GL_CURFIL : REF BLOCK[,BYTE],		! POINTER TO CURRENT FILE FDB
	LNK$GL_CURPSC : REF BLOCK[,BYTE],		! POINTER TO CURRENT PSECT DESCRIPTOR
	LNK$GL_INRELNAM,				! POINTER TO 1ST INPUT FILE NAM BLOCK
	LNK$GB_PASS : BYTE,				! PASS NUMBER
	LNK$GL_CTLMSK : BLOCK[,BYTE],			! CONTROL FLAGS
	LNK$GL_CLULST,					! CLUSTER LISTHEADE
	LNK$GL_CURCLU : REF BLOCK[,BYTE],		! CURRENT CLUSTER
	LNK$GL_LSTCLSTR : REF BLOCK[,BYTE],		! POINTER TO HIGHEST ADDRESSED CLUSTER
	LNK$GL_DEFCLU : BLOCK[,BYTE],			! DEFAULT CLUSTER BLOCK
	LNK$GL_IMGFIL : REF BLOCK[,BYTE],		! POINTER TO IMAGE DESCRIPTOR BLOCK
	LNK$GL_DBGESTIM,				! ESTIMATE OF DST BYTES ON PASS 1
	LNK$GL_DBGTFPS,					! P-SECT DESCRIPTOR FOR DEBUGGER
							! TRANSFER ADDRESS
	LNK$GL_DBGTFR,					! DEBUGGER TRANSFER ADDRESS
	LNK$GW_GSTRECS : WORD,				! NUMBER RECORDS WRITTEN TO GST OF IMAGE
	LNK$GL_TFRPSC,					! USER TRANSFER ADDRESS P-SECT
	LNK$GL_TFRADR,					! USER TRANSFER ADDRESS
	LNK$GQ_ALOSTIM : VECTOR,			! TIME OF MEMORY ALLOCATION
	LNK$GQ_PRIVS : VECTOR[2,LONG],			! VECTOR OF IMAGE PRIVILEGES
	LNK$GT_IMGNAM : VECTOR[,BYTE],			! IMAGE NAME AREA
	LNK$GT_IMGID  : VECTOR[,BYTE],			! IMAGE IDENT AREA
	LNK$GW_CHANS : WORD,				! NUMBER OF I/O CHANNELS
	LNK$GW_DZROMIN : WORD,				! NUMBER OF PAGES REQUIRED IN I-SECT BEFORE COMPRESSION
	LNK$GW_IOSEG : WORD,				! NUMBER OF PAGES OF IMAGE I/O SEGMENT
	LNK$GW_MISECTS : WORD,				! MAXIMUM NUMBER OF IMAGE SECTIONS
	LNK$GW_NISECTS : WORD,				! ACTUAL NUMBER OF IMAGE SECTIONS
	LNK$GW_SHRISCTS : WORD,				! NUMBER OF ISECTS FROM PIC SHAREABLE IMAGES
	LNK$GW_NSYMBOLS : WORD,				! NUMBER OF GLOBAL SYMBOLS
	LNK$GW_LSYMBOLS : WORD,				! NUMBER OF GLOBAL SYMBOLS IN THIS IMAGE (NOT IN SHR IMAGE)
	LNK$GL_GSBUFDSC : VECTOR[3];			! DESCRIPTOR FOR COPYING GLOBAL SECTIONS

GLOBAL
	LNK$AL_IMGRAB : $RAB(RAC=SEQ),			! IMAGE FILE RECORD ACCESS BLOCK.
	LNK$GL_IMGHDR : REF BLOCK[,BYTE],		! POINTER TO IMAGE HEADER
	LNK$GL_CURISD : REF BLOCK[,BYTE],		! CURRENT ISD ADDRESS
	LNK$GL_IMGTOP,					! MAPPED ADDRESS AT TOP + 1
	LNK$GL_LOCN,					! CURRENT LOCATION COUNTER
	LNK$GL_DSTLOCN,					! NEXT LOCATION IN DST
	LNK$GL_DSTEND,					! END OF DST WRITTEN
	LNK$GL_RPROTISD,				! NUMBER OF SECTIONS TO REPROTECT
	LNK$GL_SHRCLSTRS,				! NUMBER OF SHAREABLE IMAGE CLUSTERS (PIC AND NON-PIC)
	LNK$GW_NCLUSTERS : WORD,			! NUMBER OF CLUSTERS CREATED
	LNK$GW_DSTVBN : WORD,				! VBN AT WHICH DST BEGINS
	LNK$GW_HDRBLKS : WORD,				! BLOCKS IN IMAGE HEADER
	LNK$GW_IMGBLKS : WORD,				! BLOCKS OF IMAGE
	LNK$GW_IMGIFI : WORD,				! IFI OF IMAGE FILE
	LNK$GW_DSTBLKS : WORD,				! NUMBER OF BLOCKS OF DST
	LNK$GW_GSTVBN : WORD,				! VBN OF GLOBAL SYMBOL TABLE
	LNK$GL_MATCHID,					! MATCH CONTROL ID FOR THIS SHAREABLE IMAGE
	LNK$GB_MATCHCTL : BYTE INITIAL(%X'FF');		! MATCH CONTROL FLAGS

OWN
	SHRIMGRAB : $RAB(RAC=SEQ),			! RAB FOR READING SECTIONS OF SHAREABLE IMAGES
	CURVBN,						! CURRENT VBN FOR IMAGE SECTION
	SHRIMGCLU : REF BLOCK[,BYTE],			! POINTER TO CLUSTER DESC. OF LAST OPEN SHAREABLE IMAGE
	DSTVIRTOP,					! AND THE TOP
	DSTBUFFER : VECTOR[2],				! BUFFER DESCRIPTOR FOR DST GENERATED
	HEADERDESC : VECTOR[2],				! DESCRIPTOR OF HEADER BUFFER
	HEADER_SIZE : INITIAL(IHD$K_MAXLENGTH);		! ACCUMULATOR FOR IMAGE HEADER - STARTS
							! INCLUDING FIXED PART, ACTIVATION PART
							! SYMBOL TABLE DESCRIPTORS AND IDENTS

LITERAL
	TFRLENGTH = 5120;				! MAXIMUM TRANSFER BYTE COUNT

GLOBAL ROUTINE LNK$IMGINIT : NOVALUE =
BEGIN
!
!	THIS ROUTINE IS CALLED TO INITIALIZE THE IMAGE GENERATION
!
BIND
    AUXFNB = LNK$GL_IMGFIL[FDB$T_AUXFNB] : BLOCK[NAM$C_BLN,BYTE]; ! NAME THE NAM BLOCK
LOCAL
    IMGFAB : BLOCK[FAB$C_BLN,BYTE];

$FAB_INIT(FAB=IMGFAB,					! INITIALIZE THE FAB
	FNS=.LNK$GL_IMGFIL[FDB$W_USRNAMLEN],
	FNA=.LNK$GL_IMGFIL[FDB$L_USRNAMADR],
	DNS=%CHARCOUNT('.EXE'),
	DNA=UPLIT(BYTE('.EXE')),
	NAM=AUXFNB,
	FOP=OFP);
AUXFNB[NAM$L_RLF] = .LNK$GL_INRELNAM;			! SET RELATED FILE NAME ADDRESS
IF $PARSE(FAB=IMGFAB)					! PARSE THE FILENAME
THEN BEGIN
    IF .LNK$GT_IMGNAM[0] EQL 0				! NEED AN IMAGE NAME?
    THEN BEGIN
	LNK$GT_IMGNAM[0] = .AUXFNB[NAM$B_NAME];		! SET LENGTH OF FILENAME
	CH$MOVE(.LNK$GT_IMGNAM[0], .AUXFNB[NAM$L_NAME], ! AND MOVE IT IN
					LNK$GT_IMGNAM[1]);
	END;
    IF .LNK$GT_IMGID[0] EQL 0				! NEED AN IDENT?
    THEN BEGIN
	LNK$GT_IMGID[0] = .AUXFNB[NAM$B_TYPE];		! FIGURE THE LENGTH
	CH$MOVE(.LNK$GT_IMGID[0], .AUXFNB[NAM$L_TYPE],	! AND MOVE IT IN
					LNK$GT_IMGID[1]);
	END;
    CH$MOVE(DSC$C_S_BLN,LNK$FILNAMDSC(IMGFAB),
			LNK$GL_IMGFIL[FDB$Q_FILENAME]);
    END;

IF NOT .LNK$GL_CTLMSK[LNK$V_SYS]			! IF NOT A SYSTEM IMAGE,
THEN IF .LNK$GL_CTLMSK[LNK$V_TRACE]			! AND TRACEBACK 
     OR .LNK$GL_CTLMSK[LNK$V_DBG]			! OR DEBUGGING ENABLED, THEN
     THEN BEGIN
	LNK$GL_DSTEND = 0;				! INITIALIZE END POINT AT START
	DSTVIRTOP = (.LNK$GL_DBGESTIM OR 511) + 1;	! AND ADD THE SIZE INTO VIRTUAL DESCRIPTOR
	LNK$GL_DSTLOCN = 0;				! SET LOCATION COUNTER AT START
	IF NOT $EXPREG(PAGCNT=.DSTVIRTOP/512,RETADR=DSTBUFFER)	! ALLOCATE A BUFFER FOR IT
	THEN BEGIN						! BUT IF IT FAILS
		LNK$GL_CTLMSK[LNK$V_IMAGE] = FALSE;		! DISABLE IMAGE PRODUCTION
		SIGNAL(LIN$_MEMFUL,0,LIN$_NOIMGFIL);		! REPORT THE ERROR
		RETURN;						! AND GIVE UP
	     END;
	END;
IF .LNK$GL_CTLMSK[LNK$V_SHR]					! IF A SHAREABLE IMAGE
    OR (.LNK$GL_CTLMSK[LNK$V_SYS]
			 AND .LNK$GL_CTLMSK[LNK$V_SYSHEADR])	! OR SYSTEM IMAGE WITH A HEADER
THEN LNK$GW_MISECTS = 0;					! DISABLE IMAGE COMPRESSION

IF .LNK$GL_GSBUFDSC[0] NEQ 0					! IF ANY GLOBAL SECTIONS ARE TO BE COPIED
THEN IF NOT $EXPREG(PAGCNT=.LNK$GL_GSBUFDSC[0],			! THEN ALLOCATE A BUFFER EQUAL IN SIZE
			RETADR=LNK$GL_GSBUFDSC[1])		! TO THE LARGEST ONE SEEN
	THEN BEGIN						! BUT IF IT FAILS
		LNK$GL_CTLMSK[LNK$V_IMAGE] = FALSE;		! DISABLE IMAGE PRODUCTION
		SIGNAL(LIN$_MEMFUL,0,LIN$_NOIMGFIL);		! REPORT THE ERROR
		RETURN;						! AND GIVE UP
	     END;
RETURN;
END;

GLOBAL ROUTINE LNK$WRTIMGBYTS (BYTECOUNT, BUFFRADR, REPTCOUNT, POS, SIZ) =
BEGIN
!
! THIS ROUTINE IS CALLED TO WRITE "BYTECOUNT" BYTES FROM "BUFFRADR"
! WITH "REPTCOUNT" REPETITIONS TO THE OUTPUT IMAGE, STARTING AT
! THE CURRENT LOCATION, LNK$GL_LOCN.
! THE LOCATION COUNTER IS UPDATED BY BYTECOUNT*REPTCOUNT
!	IF "POS" AND "SIZ" ARE NON-NULL PARAMETERS, THE CALL IS ASSUMED TO BE A VARIABLE POSITION
!	AND SIZE BIT STORE.
!
! ANY ATTEMPT TO WRITE OUTSIDE THE IMAGE CAUSES AN ERROR
!
LOCAL
	STORELOLIMIT,						! LOWEST LEGAL OUTPUT ADDRESS
	STOREHILIMIT,						! HIGHEST LEGAL OUTPUT ADDRESS,
	STOREHIADDR,						! HIGHEST ADDRESS WE WILL OUTPUT TO
	BITSTORE,						! TRUE IF STORING VARIABLE POSITION AND SIZE
	PARTITION,						! POINTER TO IMAGE PARTITION NAME (DS OR EXE)
	STOREADDR;						! OUTPUT ADDRESS

BUILTIN
    AP;

BIND
    ARGLIST = .AP : VECTOR;
!
IF .BYTECOUNT EQL 0						! IF ZERO BYTE
OR NOT .LNK$GL_CTLMSK[LNK$V_IMAGE]				! COUNT, OR NO
THEN RETURN TRUE;						! IMAGE, RETURN DONE
BITSTORE = .(ARGLIST[0])<0,8> EQL 5;				! DETERMINE IF VARIABLE BIT STORE
IF .REPTCOUNT EQL 0						! SET REPEAT COUNT
THEN REPTCOUNT = 1;						! TO BE AT LEAST 1
STOREHIADDR = .LNK$GL_LOCN + .BYTECOUNT*.REPTCOUNT;		! FIGURE HIGHEST ADDRESS WE WANT TO STORE INTO
STORELOLIMIT = 0;						! LIMITS ARE INITIALLY 0
STOREHILIMIT = 0;						! 
PARTITION = CSTRING('image binary');
IF .LNK$GL_CTLMSK[LNK$V_DBGREC]					! IF THIS IS DEBUGGER DATA
OR .BITSTORE							! OR ITS A VARIABLE BIT STORE COMMAND
OR NOT CH$FAIL(CH$FIND_NOT_CH(.BYTECOUNT,.BUFFRADR,0))		! OR THERE IS A NON ZERO CHARACTER
OR (IF .LNK$GL_CURISD EQL 0 THEN FALSE				! IF NO ISECT SET UP
	ELSE IF .LNK$GL_CURISD[ISL$L_BUFADR] EQL 0		! OR IF NO BUFFER SET UP
		THEN (						! THEN WE ARE DONE
			LNK$GL_LOCN = .STOREHIADDR;		! SO SET THE LOCATION COUNTER
			RETURN TRUE;				! AND RETURN SUCCESS
		     )
		ELSE TRUE)					! NO NON-ZERO BYTES TO STORE
								! BUT OTHERWISE OK
THEN BEGIN							! IT HAS BEEN TOUCHED BEFORE
!
!	THEN WE ARE GOING TO WRITE IT TO THE IMAGE SECTION
!
IF NOT .LNK$GL_CTLMSK[LNK$V_DBGREC]				! IF NOT A DEBUG DATA BYTE STREAM
THEN BEGIN							! SET UP THE LO AND HI ADDRESS
	IF .LNK$GL_CURISD NEQ 0					! IF A IMAGE SECTION HAS BEEN
	THEN BEGIN						! SET UP
		BIND HDRISD = LNK$GL_CURISD[ISL$T_HDRISD]	! LABEL FOR PART GOING TO HEADER
					: BLOCK[,BYTE];		! 
		STORELOLIMIT = .HDRISD[ISD$V_VPG] ^ 9;		! LOW LIMIT IS BASE OF ISECT
		STOREHILIMIT = .STORELOLIMIT  +			! AND HIGH LIMIT IS BYTE BEYOND
					.HDRISD[ISD$W_PAGCNT]*512;
	IF .STOREHIADDR GTRU .STOREHILIMIT			! IF WE WILL EXCEED IMAGE SECTION
	AND .LNK$GL_CURPSC[PSC$L_BASE]+.LNK$GL_CURPSC[PSC$L_LENGTH] ! AND PSECT EXCEEDS IMAGE SECTION
		GTRU .STOREHILIMIT
	THEN BEGIN						! THEN WE MUST STORE AS SECTIONS
	    LOCAL
		BYTES2WRITE,					! BYTES LEFT TO WRITE
		CURISD;						! SAVED CURRENT ISD POINTER
	    CURISD = .LNK$GL_CURISD;				! SAVE CURRENT ISECT DESCR. POINTER
	    IF .LNK$GL_LOCN GTRU .STORELOLIMIT			! IF ALREADY INTO ANOTHER ISECT
	    THEN BEGIN						! THEN FIND STARTING ISECT
	    WHILE (LNK$GL_CURISD = .LNK$GL_CURISD[ISL$L_NXTISD]) ! WHILE THERE ARE MORE ISECT DESCRIPTORS
				NEQ 0
	    DO BEGIN
		BIND
		    HDRISD = LNK$GL_CURISD[ISL$T_HDRISD] : BLOCK[,BYTE]; ! NAME PART FOR HEADER
		STORELOLIMIT = .HDRISD[ISD$V_VPG] ^ 9;		! COMPUTE LOW LIMIT
		STOREHILIMIT = .STORELOLIMIT + .HDRISD[ISD$W_PAGCNT]*512; ! AND HI LIMIT
		IF .STOREHIADDR LEQU .STOREHILIMIT THEN EXITLOOP;
		END;
	    IF .LNK$GL_CURISD EQL 0 THEN RETURN FALSE;		! ERROR IF NO ISECT FOUND
	    END;				! FINDING STARTING ISECT
	    BYTES2WRITE = .BYTECOUNT*.REPTCOUNT;		! FIGURE BYTES TO WRITE
	    WHILE .BYTES2WRITE NEQ 0				! WHILE THERE ARE MORE TO DO
	    DO BEGIN
		LOCAL
		    ROOMLEFT,					! ROOM LEFT IN THE CURRENT IMAGE SECTION
		    ISDREPT,					! REPEAT COUNT THIS ISD
		    ISDLEFT;					! BYTES LEFT FROM NON-FULL REPEAT COUNT
		ROOMLEFT = .STOREHILIMIT - .LNK$GL_LOCN;	! FIGURE ROOM LEFT IN IMAGE SECTION
		WHILE .ROOMLEFT NEQ 0				! WHILE THERE IS ROOM IN THIS IMAGE SECTION
		AND .BYTES2WRITE NEQ 0				! AND THERE ARE MORE BYTES TO WRITE
		DO BEGIN
		    ISDREPT = MINU(.ROOMLEFT/.BYTECOUNT,.REPTCOUNT); ! FIGURE NUMBER FULL REPEATS
		    BYTES2WRITE = .BYTES2WRITE - .BYTECOUNT*.ISDREPT; ! ADJUST BYTE COUNT
		    ISDLEFT = .ROOMLEFT - .BYTECOUNT*.ISDREPT;	! AND NUMBER OF BYTES LEFT AFTER FULL REPEATS
		    IF .BYTES2WRITE EQL 0 THEN ISDLEFT = 0;	! NO PARTIAL BLOCK IF FINISHED ALL BYTES
		    IF NOT LNK$WRTIMGBYTS(.BYTECOUNT,.BUFFRADR,.ISDREPT) ! WRITE THE FULL REPEATS
			THEN RETURN FALSE;
		    IF .ISDLEFT NEQ 0				! IF THERE IS A PARTIAL WRITE
			THEN IF NOT LNK$WRTIMGBYTS(.ISDLEFT,.BUFFRADR,1) ! THEN WRITE IT OUT NOW
				THEN RETURN FALSE
				ELSE BYTES2WRITE = .BYTES2WRITE - .ISDLEFT; ! ADJUST COUNT
		    ROOMLEFT = .ROOMLEFT - .BYTECOUNT*.ISDREPT	! ADJUST THE ROOM LEFT THIS ISECT
				 - .ISDLEFT;
		    END;			! WHILE ROOM AND BYTES TO WRITE
		LNK$GL_CURISD = .LNK$GL_CURISD[ISL$L_NXTISD];	! LINK TO NEXT ISD
		BEGIN
		    BIND
			HDRISD = LNK$GL_CURISD[ISL$T_HDRISD]	! NAME PART GOING TO HEADER
				: BLOCK[,BYTE];
		IF .ISDLEFT NEQ 0				! IF WE WROTE A PARTIAL STRING
		    THEN IF NOT LNK$WRTIMGBYTS(.BYTECOUNT-.ISDLEFT,	! THEN WRITE THE REST OF THE STRING
			.BUFFRADR+.ISDLEFT,1)			! 
				THEN RETURN FALSE;
		STORELOLIMIT = .HDRISD[ISD$V_VPG] ^ 9;		! SET NEW LOW LIMIT
		STOREHILIMIT = .STORELOLIMIT +			! AND NEW HIGH LIMIT
			.HDRISD[ISD$W_PAGCNT]*512;		!
		END;				! BEGIN BLOCK
		END;				! BYTES2WRITE NEQ 0
	    LNK$GL_CURISD = .CURISD;				! RESTORE CURISD
	    RETURN TRUE;					! ALL DONE, RETURN SUCCESS
	    END;				! EXCEEDING IMAGE SECTION
	     END;						! POSITION TO WRITE BYTE STREAM
     IF .LNK$GL_CURISD NEQ 0
     THEN BEGIN
	BIND HDRISD = LNK$GL_CURISD[ISL$T_HDRISD] : BLOCK[,BYTE];

     IF .LNK$GL_CURISD[ISL$L_BUFADR] EQL 0			! IF A BUFFER HAS NOT YET BEEN
	AND .HDRISD[ISD$W_PAGCNT] GTRU 0			! AND ISECT IS NON-NULL
	THEN IF NOT $EXPREG(PAGCNT=.HDRISD[ISD$W_PAGCNT],	! ALLOCATED, EXPAND MY PROGRAM REGION
				RETADR=LNK$GL_CURISD[ISL$L_BUFADR])
	THEN BEGIN						! BY SIZE OF I-SECT BEING WRITTEN
		SIGNAL(LIN$_MEMFUL,0,LIN$_NOIMGFIL);		! REPORT THE ERROR
		LNK$GL_CTLMSK[LNK$V_IMAGE] =  FALSE;		! SPACE AND TURN OFF ANY MORE
		RETURN TRUE;					! ATTEMPTS
	        END;
     STOREADDR = .LNK$GL_CURISD[ISL$L_BUFADR];			! START STORE ADDRESS COMPUTATION
     END
     END
ELSE BEGIN							! BUT IF IT IS THE DST BEING WRITTEN
	STORELOLIMIT = 0;					! THEN LIMITS ARE THE BASE AND TOP OF
	STOREHILIMIT = .DSTVIRTOP;				! THE DST AS IF IT WERE MAPPED INTO THE EXE
	PARTITION = CSTRING('Debugger Symbol Table');		! AT THE END
	STOREADDR = .DSTBUFFER[0];				! START COMPUTATION OF ACTUAL STORE ADDRESS
     END;
END;
IF .LNK$GL_LOCN LSSU .STORELOLIMIT				! IF LOCATION COUNTER
OR .STOREHIADDR GTRU .STOREHILIMIT				! BEYOND IMAGE
THEN BEGIN							! ALLOCATION, ISSUE AN
	IF .LNK$GL_CURPSC EQL 0					! IF PSECT NOT AVAILABLE
	    THEN SIGNAL(LIN$_OUTSIMG,6,.LNK$GL_LOCN,		! ERROR AND GIVE UP
			.PARTITION,.STORELOLIMIT,.STOREHILIMIT,
			LNK$GL_CUROMD[OMD$B_NAMLNG],LNK$GL_CURFIL[FDB$Q_FILENAME],LIN$_NOIMGFIL)
	    ELSE SIGNAL(LIN$_OUTSIMGP,7,.LNK$GL_LOCN,		! ERROR AND GIVE UP
			.PARTITION,.STORELOLIMIT,.STOREHILIMIT,
			LNK$GL_CURPSC[PSC$B_NAMLNG],LNK$GL_CUROMD[OMD$B_NAMLNG],LNK$GL_CURFIL[FDB$Q_FILENAME],LIN$_NOIMGFIL);
	LNK$GL_CTLMSK[LNK$V_IMAGE] = FALSE;			! TURNING OFF ANY
	RETURN FALSE;						! MORE ATTEMPTS
     END;
IF .BITSTORE					! IF VARIABLE BIT STORE
THEN BEGIN
    BIND
	IMAGEBUF = .LNK$GL_CURISD [ISL$L_BUFADR] : BLOCK [,BYTE];
    MAP
	BUFFRADR : REF BLOCK [,BYTE];

    IMAGEBUF [(.LNK$GL_LOCN-.STORELOLIMIT), .POS, .SIZ, 0] = .BUFFRADR; ! DO THE BIT STORE
    RETURN TRUE;
    END;
STOREADDR = .STOREADDR + .LNK$GL_LOCN - .STORELOLIMIT;		! COMPUTE MAPPED
INCR I FROM 1 TO .REPTCOUNT DO					! LOOP, MOVING THE
	BEGIN							! REQUIRED BYTES,
	STOREADDR = CH$MOVE(.BYTECOUNT,.BUFFRADR,.STOREADDR);	! UPDATING THE ADDRESS
	END;
LNK$GL_LOCN = .STOREHIADDR;					! UPDATE LOCATION COUNTER
IF .LNK$GL_CTLMSK[LNK$V_DBGREC]					! IF THIS IS A DEBUG RECORD
AND (.LNK$GL_LOCN-1) GTRU .LNK$GL_DSTEND			! AND THIS IS NEW HIGH DST ADDRESS
THEN LNK$GL_DSTEND = .LNK$GL_LOCN;
RETURN TRUE;							! AND ALL DONE
END;

GLOBAL ROUTINE LNK$FLUSHIMG : NOVALUE =
BEGIN
!
!++
!	THIS ROUTINE IS CALLED WITHOUT ANY ARGUMENTS TO FLUSH THE
!	BINARY THAT WAS GENERATED TO AN IMAGE FILE.
!	THE FIRST PHASE IS TO GO DOWN THE LIST OF IMAGE SECTION DESCRIPTORS
!	AND WITH THE USE OF THE MEMORY MANAGEMENT SYSTEM SERVICE
!	$GETPTI, COMPRESSING THE UNINITIALIZED PAGES FROM EACH IMAGE SECTION
!	THE COMPRESSION IS ACHIEVED BY GENERATING A DEMAND ZERO IMAGE
!	SECTION DESCRIPTOR FOR EACH REGION OF AN IMAGE SECTION THAT
!	HAS NOT BEEN TOUCHED DURING PASS 2.
!	THE SIZES OF THE IMAGE HEADER AND IMAGE BINARY ARE ACCUMULATED DURING THIS 
!	PHASE WHICH ENDS WITH CREATION OF THE FILE AND ALLOCATION OF A BUFFER FOR THE HEADER.
!	THE NEXT PHASE CONSISTS OF ANOTHER PASS DOWN THE LIST OF 
!	IMAGE SECTION DESCRIPTORS, CREATING THE ISD ENTRY IN THE 
!	HEADER (STILL IN MEMORY) AND WRITING TO THE IMAGE FILE THOSE
!	IMAGE SECTIONS THAT CONTAIN BINARY DATA.
!	FINALLY THE DEBUG SYMBOL TABLE, IF ANY IS WRITTEN TO THE FILE
!	AND THE SUMMARY PARAMETERS OF THE IMAGE HEADER ARE COMPUTED.
!	THE FILE IS LEFT OPEN FOR POSSIBLE APPENDING OF THE GLOBAL SYMBOL
!	TABLE FOLLOWED BY THE WRITING OF THE IMAGE HEADER.
!
!--
!
LABEL
	PROCSISD;
!
LOCAL
	ISDLIST : REF VECTOR[,LONG],				! POINTER TO TABLE IF ISD ADDRESSES
	ISDNUM,							! INDEX INTO ISECT LIST
	SHRISDLIST : REF VECTOR[,LONG],				! POINTER TO TABLE OF ISD ADDRESSES IN PIC SHR IMAGES
	SHRISDNUM,						! INDEX INTO SHRISDLIST
	SHRCLULST : REF VECTOR[,LONG],				! LIST OF CLUSTER DESCRIPTORS
	SHRCLUNUM,						! INDEX IN SHRCLULST
	ADRCLULST : REF VECTOR[,LONG],				! LIST OF LOCAL CLUSTERS REFERENCED BY .ADDRESS
	ADRCLUNUM,						! INDEX INTO ADRCLULST
	NENTRIES,						! NUMBER OF ENTRIES TO ALLOCATE
	ERRORCODE,						! WRITE ERROR CODE RETURNED
	RMSSTV,							! STV RETURNED FROM RMS
	EMPTYDESC : VECTOR[2],					! DESCRIPTOR RETURNED FOR EMPTY PAGES
	FILEBLKS,						! NUMBER OF BLOCKS IN FILE
	LASTCLUSTER,						! TRUE IF CLUSTER IS LAST CLUSTER
	IMAGEFAB : BLOCK[FAB$C_BLN,BYTE],			! FILE ACCESS BLOCK - JUST FOR CREATE
	FIRSTISD : REF BLOCK[,BYTE],				! POINTER TO FIRST ISD IN CLUSTER
	PREVISD : REF BLOCK[,BYTE];				! POINTER TO PREVIOUS ISD
!
BIND
	AUXFNB = LNK$GL_IMGFIL[FDB$T_AUXFNB] : BLOCK[NAM$C_BLN,BYTE]; ! AUXILIARY FILENAME BLOCK
!
IF .LNK$GL_CTLMSK[LNK$V_SYS]					! IF A SYSTEM IMAGE
	AND NOT .LNK$GL_CTLMSK[LNK$V_SYSHEADR]			! AND NO HEADER REQUESTED
THEN BEGIN							! THERE IS ONLY ONE ISD (BUT NO HEADER)
	BIND	SYSISD = LNK$GL_DEFCLU[CLU$L_FSTISD] : REF BLOCK[,BYTE],	! GIVE IT A NAME
		SYSHDRISD = SYSISD[ISL$T_HDRISD] : BLOCK[,BYTE]; ! AND FOR PART THAT WOULD BE HEADER
	IF .LNK$GL_DEFCLU[CLU$L_FSTISD] NEQ 0			! IF THERE IS AN IMAGE SECTION
	THEN LNK$GW_IMGBLKS = .SYSHDRISD[ISD$W_PAGCNT];		! GET THE BLOCK COUNT
	HEADER_SIZE = 0;					! NO HEADER
     END
ELSE BEGIN
    IF .LNK$GB_MATCHCTL  EQL %X'FF'			! IF NO GSMATCH OPTION (IGNORED EXCEPT FOR SHAREABLE IMAGES)
	THEN BEGIN					! THEN FORCE A MATCH EQUAL
	    LNK$GB_MATCHCTL = ISD$K_MATEQU;		! SINCE USER OPTED NOT TO SPECIFY
	    LNK$GL_MATCHID = .LNK$GQ_ALOSTIM<16,32,0>;	! USE THE MIDDLE 32 BITS OF LINK TIME
	    END;
     LNK$GL_CURCLU = LNK$GL_CLULST;				! START AT FIRST CLUSTER
     WHILE(LNK$GL_CURCLU = .LNK$GL_CURCLU[CLU$L_NXTCLU]) NEQ 0 DO	! GO DOWN THE LIST
     BEGIN
     LASTCLUSTER = (.LNK$GL_CURCLU EQL .LNK$GL_LSTCLSTR)	! SEE IF THIS IS THE LAST CLUSTER
			AND NOT .LNK$GL_CTLMSK[LNK$V_SHR];	!  BUT ONLY IN EXECUTABLE IMAGES
     PREVISD = LNK$GL_CURCLU[CLU$L_FSTISD];
     WHILE (LNK$GL_CURISD = .PREVISD[ISL$L_NXTISD]) NEQ 0 DO	! WHILE THERE IS ANOTHER
     PROCSISD: BEGIN
	BIND CURHDRISD = LNK$GL_CURISD[ISL$T_HDRISD] 		! NAME THE HEADER PART OF IT
				: BLOCK[,BYTE];
	IF .LNK$GL_CURISD EQL .LNK$GL_FIXISD			! IF THIS IS THE FIXUP SECTION
	THEN BEGIN
	    PREVISD = .LNK$GL_CURISD;				! MOVE TO NEXT
	    LEAVE PROCSISD;					! AND DON'T TOUCH THE FIXUP SECTION
	    END;
	IF .CURHDRISD[ISD$W_PAGCNT] EQL 0			! IF ZERO LENGTH I-SECTION
	THEN BEGIN
		PREVISD = .LNK$GL_CURISD;			! MOVE TO NEXT
		LNK$GW_NISECTS = .LNK$GW_NISECTS  - 1;		! DISCOUNT 
		LEAVE PROCSISD;					! AND SKIP THIS ONE
		END;
	IF .LNK$GL_CTLMSK[LNK$V_PROTECT]			! IF IMAGE IS PROTECTED
	    OR .LNK$GL_CURCLU[CLU$V_PROTECT]			! OR IMAGE IS PROTECTED
	    OR .CURHDRISD[ISD$V_VECTOR]				! OR ISECT IS A VECTOR ISECT
	    THEN CURHDRISD[ISD$V_PROTECT] = TRUE;		!   THEN PROTECT THE IMAGE SECTION
	IF .LASTCLUSTER
	    THEN CURHDRISD[ISD$V_LASTCLU] = TRUE;
	IF NOT .CURHDRISD[ISD$V_DZRO]				! IF NOT ALREADY A DEMAND ZERO SECTION
	AND .LNK$GL_CURISD[ISL$L_BUFADR] EQL 0			! BUT NO BUFFER YET ALLOCATED
	THEN IF .CURHDRISD[ISD$W_PAGCNT] GEQU .LNK$GW_DZROMIN	! THEN IF SECTION IS BIG ENOUGH
	     AND .CURHDRISD[ISD$V_WRT]				! AND WRITABLE
	     AND NOT .CURHDRISD[ISD$V_GBL]			! AND NOT GLOBAL
	     AND NOT .LNK$GL_CTLMSK[LNK$V_SHR]			! AND NOT A SHAREABLE IMAGE
	     THEN BEGIN
			CURHDRISD[ISD$W_SIZE] = ISD$K_LENDZRO;	! THEN CONVERT WHOLE SECTION
			CURHDRISD[ISD$V_DZRO] = TRUE;		! TO A DEMAND ZERO
			CURHDRISD[ISD$V_CRF] = FALSE;		! DISABLING POSSIBLE COPY ON REFERENCE
		  END
	     ELSE IF .CURHDRISD[ISD$V_GBL]				! OTHERWISE, IF IT IS GLOBAL
		  THEN ( IF .LNK$GL_CURCLU[CLU$V_COPY]			! AND THE CLUSTER IS TO BE
				AND NOT .CURHDRISD[ISD$V_PROTECT]	! COPIED INTO THIS IMAGE
			 THEN BEGIN
				LNK$GL_CURISD[ISL$L_BUFADR] = .LNK$GL_GSBUFDSC[1]; ! SET THE BUFFER
				LNK$GL_CURISD[ISL$L_BUFEND] = .LNK$GL_GSBUFDSC[2]; ! DESCRIPTOR
			      END
			 ELSE BEGIN
				CURHDRISD[ISD$L_VBN] = 0;		! SET NO VBN
				LNK$GL_CURISD[ISL$L_BUFADR] = 0;	! AND NO BUFFER
				LNK$GL_CURISD[ISL$L_BUFEND] = 0;
				END;
			)
		  ELSE IF NOT $EXPREG(PAGCNT=.CURHDRISD[ISD$W_PAGCNT],	! IF LOCAL SECTION, ALLOCATE
					RETADR=LNK$GL_CURISD[ISL$L_BUFADR])	! A BUFFER OF ZEROES
				THEN BEGIN
					SIGNAL(LIN$_MEMFUL,0,LIN$_NOIMGFIL);	! REPORT THE ERROR
					LNK$GL_CTLMSK[LNK$V_IMAGE] = FALSE;	! DISABLE IMAGE PRODUCTION
					RETURN;					! AND GIVE UP
			END;
	IF .LNK$GL_CURISD[ISL$L_BUFADR] NEQ 0			! IF THERE IS NOW A BUFFER
	AND (.CURHDRISD[ISD$W_PAGCNT] LSSU .LNK$GW_DZROMIN	! BUT SECTION TOO SMALL FOR COMPRESSION
	    OR NOT .CURHDRISD[ISD$V_WRT]			! OR IS READ ONLY
	    OR .LNK$GW_NISECTS GEQU .LNK$GW_MISECTS)		! OR WE HAVE EXCEEDED LIMIT ON ISD'S
	THEN LNK$GW_IMGBLKS = .LNK$GW_IMGBLKS +			! THEN ADD THE SECTION SIZE TO IMAGE
				.CURHDRISD[ISD$W_PAGCNT];
	IF .CURHDRISD[ISD$V_DZRO]				! IF SECTION IS STILL DEMAND ZERO
	OR NOT .CURHDRISD[ISD$V_WRT]				! OR IS NOT WRITABLE
	OR .CURHDRISD[ISD$W_PAGCNT] LSSU .LNK$GW_DZROMIN	! OR THE SECTION IS TOO SMALL
	OR .LNK$GW_NISECTS GEQU .LNK$GW_MISECTS			! OR WE HAVE ENOUGH OF THEM
	OR .CURHDRISD[ISD$V_GBL]				! OR THIS IS GLOBAL
	THEN 							! WE ARE DONE WITH IT
	    PREVISD = .LNK$GL_CURISD				! THIS IS NOW THE PREVIOUS
	ELSE BEGIN
	     DO BEGIN							! BEGIN LOOPING CALLS TO PTI SERVICE
		BIND CURHDRISD = LNK$GL_CURISD[ISL$T_HDRISD]		! RENAME THE HEADER PART
					: BLOCK[,BYTE];			! FOR POSSIBLE CHANGE OF CURRENT ISD
		IF NOT (ERRORCODE=$GETPTI(INADR=LNK$GL_CURISD[ISL$L_BUFADR], ! CALL $GETPTI TO FIND UNTOUCHED PAGES
					RETADR=EMPTYDESC[0],		! TWO -LONGWORD RETURN ARRAY
					ACMODE=0,			! ACCESS MODE IS USER
					MASK=1,				! PAGES WHICH ARE DEMAND ZERO
					PAGCNT=.LNK$GW_DZROMIN))	! MUST BE AT LEAST THIS MANY PAGES
		THEN BEGIN						! BUT IF AN ERROR RETURNED

			SIGNAL(LIN$_GETPTIERR,4,			! THEN TELL THE USER AND CONTINUE WITHOUT THE IMAGE
					.LNK$GL_CURISD[ISL$L_BUFADR],.LNK$GL_CURISD[ISL$L_BUFEND],
					.CURHDRISD[ISD$V_VPG],.CURHDRISD[ISD$W_PAGCNT],
					.ERRORCODE,0,LIN$_NOIMGFIL);
			LNK$GL_CTLMSK[LNK$V_IMAGE] = FALSE;		! DISABLE ANY MORE IMAGE OUTPUT
			RETURN;
		     END;
		IF (EMPTYDESC[1] = .EMPTYDESC[1] + 1) EQL 0		! IF WE DON'T HAVE ANOTHER EMPTY REGION
		OR .LNK$GW_NISECTS GEQU .LNK$GW_MISECTS			! OR WE HAVE ENOUGH OF THEM
		THEN BEGIN
			PREVISD = .LNK$GL_CURISD;			! THEN CURRENT BECOMES PREVIOUS
			LNK$GW_IMGBLKS = .LNK$GW_IMGBLKS + .CURHDRISD[ISD$W_PAGCNT];	! AND TO THE IMAGE
			EMPTYDESC[1] = 0;				! ENSURE END OF LOOP
		     END
		ELSE BEGIN						! IF WE DO HAVE ANOTHER ....
			LOCAL
				NEWISD : REF BLOCK[,BYTE],		! POINTER FOR NEWLY ALLOCATED ISD
				NEWHDRISD : REF BLOCK[,BYTE];		! AND THE HEADER PART OF IT

			LNK$ALLOBLK(ISD$C_SIZE,NEWISD);			! ALLOCATE AN IMAGE SECTION DESCRIPTOR
			NEWISD[ISL$L_CLUDSC] = .LNK$GL_CURCLU;		! SET CLUSTER DESCRIPTOR POINTER
			NEWISD[ISL$L_BUFADR] = 0;			! ZERO THE BUFFER ADDRESS
			NEWISD[ISL$L_BUFEND] = 0;			! QUADWORD
			NEWHDRISD = NEWISD[ISL$T_HDRISD];		! SET POINTER TO HEADER PART
			NEWHDRISD[ISD$W_SIZE] = ISD$K_LENDZRO;		! SET LENGTH OF DESCRIPTOR
			NEWHDRISD[ISD$W_PAGCNT] = (.EMPTYDESC[1] -	! SET SECTION SIZE
					.EMPTYDESC[0])/512;		! IN PAGES
			NEWHDRISD[ISD$L_FLAGS] = (.CURHDRISD[ISD$L_FLAGS]! COPY THE CURRENT
						OR ISD$M_DZRO) AND	! SECTION FLAGS AND SET DEMAND ZERO
						NOT ISD$M_CRF;		! CLEARING POSSIBLE COPY ON REFERENCE
			NEWHDRISD[ISD$V_PFC] = 0;			! SET THE PAGE FAULT CLUSTER
			IF .CURHDRISD[ISD$V_PROTECT]			! IF ISECT SHOULD BE PROTECTED
				THEN NEWHDRISD[ISD$V_PROTECT] = TRUE; ! THEN DO SO
!
!	THE IMAGE SECTION DESCRIPTOR FOR THE NEW DEMAND ZERO
!	SECTION IS NOW SET UP. HOWEVER WE STILL HAVE TO DETERMINE
!	THE BASE VIRTUAL ADDRESS OF IT AND THE REMNANT OF THE ORIGINAL
!	IMAGE SECTION. IN ADDITION THE BUFFER ADDRESS OF THE BINARY
!	OF THE REMNANT MUST BE ADJUSTED.
!	AFTER THIS THE NEW ISD IS LINKED ONTO THE LIST OF ISD, IN
!	USER VIRTUAL ADDRESS ORDER.
!
			IF .EMPTYDESC[0] EQL .LNK$GL_CURISD[ISL$L_BUFADR]	! IF THE EMPTY REGION IS AT
			THEN BEGIN						! THE BEGINNING OF THIS SECTION
				PREVISD[ISL$L_NXTISD] = .NEWISD;		! PREVIOUS ISD POINTS TO NEW
				NEWHDRISD[ISD$V_VPG] = .CURHDRISD[ISD$V_VPG];	! AND NEW I-SECT IS AT
				CURHDRISD[ISD$W_PAGCNT] =			! THIS ONES VIRTUAL ADDRESS
					.CURHDRISD[ISD$W_PAGCNT] -		! REDUCE CURRENT I-SECT'S PAGE
					.NEWHDRISD[ISD$W_PAGCNT];		! BY NUMBER THAT ARE EMPTY
				NEWISD[ISL$L_NXTISD] = .LNK$GL_CURISD;		! ONLY PART OF SECTION
				LNK$GL_CURISD[ISL$L_BUFADR] = .EMPTYDESC[1];	! SO NEW ISD POINTS TO
				CURHDRISD[ISD$V_VPG] = .CURHDRISD[ISD$V_VPG]	! CURRENT AND THE 
					+ .NEWHDRISD[ISD$W_PAGCNT];		! BUFFER AND VIRTUAL
										! ADDRESSES OF CURRENT ARE THE
										! PAGES BEYOND EMPTY REGION'S
				LNK$GW_NISECTS = .LNK$GW_NISECTS + 1;		! COUNT NEW IMAGE SECTION
				PREVISD = .LNK$GL_CURISD;			! CURRENT ISD BECOMES PREVIOUS
			     END
			ELSE BEGIN						! EMPTY REGION IS NOT AT FRONT
				NEWISD[ISL$L_NXTISD] = .LNK$GL_CURISD[ISL$L_NXTISD];	! CURRENT POINTS TO NEW
				LNK$GL_CURISD[ISL$L_NXTISD] = .NEWISD;		! THEN CURRENT I-SECT PAGE
				CURHDRISD[ISD$W_PAGCNT] = (.EMPTYDESC[0] -	! COUNT BECOMES NO. BEFORE
						.LNK$GL_CURISD[ISL$L_BUFADR])/512;	! UNTOUCHED REGION
				LNK$GW_IMGBLKS = .LNK$GW_IMGBLKS +			! ADD CURRENT I-SECTS
					.CURHDRISD[ISD$W_PAGCNT];		! INTO IMAGE BINARY TOTAL
				NEWHDRISD[ISD$V_VPG] = .CURHDRISD[ISD$V_VPG]	! VIRTUAL ADDRESS OF
					+ .CURHDRISD[ISD$W_PAGCNT];		! BEYOND CURRENT
				LNK$GW_NISECTS = .LNK$GW_NISECTS + 1;		! COUNT NEW IMAGE SECTION
				IF .EMPTYDESC[1] GEQU .LNK$GL_CURISD[ISL$L_BUFEND] ! IF EMPTY REGION IS
				THEN BEGIN					   ! ALL THAT REMAINS
					LNK$GL_CURISD[ISL$L_BUFEND] = .EMPTYDESC[0] -1;	! ADJUST END OF CURRENT
					PREVISD = .NEWISD;			! BUFFER AND NEW BECOMES PREVIOUS
					EXITLOOP;
				     END
				ELSE BEGIN					! NOW GENERATE AN ISD FOR REMNANT
					PREVISD = .NEWISD;			! SAVING NEW AS THE PREVIOUS
					LNK$ALLOBLK(ISD$C_SIZE,NEWISD);		! ALLOCATE THE DESCRIPTOR
					NEWISD[ISL$L_NXTISD] = .PREVISD[ISL$L_NXTISD];	! TO POINT
					PREVISD[ISL$L_NXTISD] = .NEWISD;	! FORWARD AND POINTED TO
					LNK$GW_NISECTS = .LNK$GW_NISECTS + 1;	! COUNT NEW IMAGE SECTION
					NEWISD[ISL$L_CLUDSC] = .LNK$GL_CURCLU; ! SET CLUSTER DESCRIPTOR POINTER
					NEWISD[ISL$L_BUFADR] = .EMPTYDESC[1];	! BUFFER IS BEYOND EMPTY
					NEWISD[ISL$L_BUFEND] = .LNK$GL_CURISD	! REGION TO END
						[ISL$L_BUFEND];			! OF REMNANT
					NEWHDRISD = NEWISD[ISL$T_HDRISD];	! NAME THE HEADER PART
					CH$MOVE(.CURHDRISD[ISD$W_SIZE],		! COPY THE CURRENT ISD
						CURHDRISD,.NEWHDRISD);		! TO THE NEW NE
					NEWHDRISD[ISD$W_PAGCNT] = ( .NEWISD[ISL$L_BUFEND] ! PAGE COUNT IS AT
						-.NEWISD[ISL$L_BUFADR]		! MOST THE REMNANT
						+ 511)/512;			! BUFFER SIZE
					NEWHDRISD[ISD$V_VPG] = .CURHDRISD[ISD$V_VPG]
						+ (.NEWISD[ISL$L_BUFADR] -	! VIRT ADDR IS PAGE BEYOND
					    .LNK$GL_CURISD[ISL$L_BUFADR])/512;	! THE EMPTY REGION
					LNK$GL_CURISD[ISL$L_BUFEND] = .EMPTYDESC[0] - 1;	! CURRENT BUFFER BEFORE
					LNK$GL_CURISD = .NEWISD;	! AND CREATE A NEW CURRENT ISD
					IF .CURHDRISD[ISD$V_PROTECT]	! PROTECT THE ISECT?
					    THEN NEWHDRISD[ISD$V_PROTECT] = TRUE; ! 
				     END;				! THE EMPTY REGION
			     END;
		     END;
		END
		UNTIL .EMPTYDESC[1] EQL 0;
	     END;
	END;
     END;
     END;
!
!	ALLOCATE A TABLE TO HOLD ISECT DESCRIPTOR ADDRESSES, AND FILL IT
!	IN.  THEN SORT THE LIST INTO ASCENDING VPN ORDER.
!
IF .LNK$GL_SHRADR NEQ 0						! CREATE FIXUP ISD IF NEEDED
    AND .LNK$GL_FIXISD EQL 0		
    THEN LNK$CREFIXISD();
IF (NENTRIES = .LNK$GW_NISECTS - .LNK$GW_SHRISCTS) GTR 0
    THEN LNK$ALLOBLK (.NENTRIES*4, ISDLIST)			! ALLOCATE SPACE FOR ISECT LIST
    ELSE ISDLIST = 0;
IF .LNK$GW_SHRISCTS NEQ 0
    THEN LNK$ALLOBLK (.LNK$GW_SHRISCTS*4, SHRISDLIST)		! AND FOR THE SHAREABLE ISECT LIST
    ELSE SHRISDLIST = 0;
IF .LNK$GW_NCLUSTERS NEQ 0
    THEN LNK$ALLOBLK (.LNK$GW_NCLUSTERS*4, SHRCLULST)		! AND THE SHAREABLE CLUSTER LIST
    ELSE SHRCLULST = 0;
IF .LNK$GL_SHRADR NEQ 0
    THEN LNK$ALLOBLK (.LNK$GL_SHRADR*4, ADRCLULST)		! AND THE .ADDRESS CLUSTER REF LIST
    ELSE ADRCLULST = 0;
LNK$GL_CURCLU = LNK$GL_CLULST;
SHRCLUNUM = SHRISDNUM = ADRCLUNUM = ISDNUM = 0;
WHILE (LNK$GL_CURCLU = .LNK$GL_CURCLU[CLU$L_NXTCLU]) NEQ 0
DO BEGIN	
    IF .LNK$GL_CURCLU[CLU$V_SHRIMG]				! IF CLUSTER IS A SHAREABLE IMAGE
    THEN BEGIN
	SHRCLULST[.SHRCLUNUM] = .LNK$GL_CURCLU;			! SAVE CLUSTER ADDRESS IN LIST
	SHRCLUNUM = .SHRCLUNUM + 1;
	FIRSTISD = .LNK$GL_CURCLU[CLU$L_FSTISD];		! GET POINTER TO FIRST ISECT DESCRIPTOR
	FIRSTISD = FIRSTISD[ISL$T_HDRISD];			! POINT TO PART BOUND FOR HEADER
	END;
    IF NOT .LNK$GL_CURCLU[CLU$V_SHRIMG]				! IF NOT SHAREABLE IMAGE CLUSTER
    AND .LNK$GL_CURCLU[CLU$L_ADRCNT] NEQ 0			!  AND IT HAS .ADDRESS REFERENCES TO IT
    THEN BEGIN
	ADRCLULST[.ADRCLUNUM] = .LNK$GL_CURCLU;			! SET ADDRESS INTO LIST
	ADRCLUNUM = .ADRCLUNUM + 1;
	END;
    PREVISD = LNK$GL_CURCLU[CLU$L_FSTISD];			! POINT TO ISD LIST THIS CLUSTER
    WHILE (PREVISD = .PREVISD[ISL$L_NXTISD]) NEQ 0		! AND RUN THRU THEM ALL
    DO BEGIN
	BIND ISDHDR = PREVISD[ISL$T_HDRISD] : BLOCK[,BYTE];	! NAME PART BOUND FOR HEADER
	IF .ISDHDR[ISD$W_PAGCNT] NEQ 0				! ONLY PUT ISECTS WITH MEMORY ALLOCATED
	THEN BEGIN
	    IF NOT (.LNK$GL_CURCLU[CLU$V_SHRIMG]		! IF NOT A NON-BASED SHR IMG
			AND NOT .LNK$GL_CURCLU[CLU$V_BASED])
		THEN BEGIN					! CLUSTER IS EITHER LOCAL OR BASED SHAREABLE IMAGE
		    ISDLIST[.ISDNUM] = .PREVISD;		! INSERT INTO THE LIST
		    ISDNUM = .ISDNUM + 1;
		    END
		ELSE BEGIN					! IT IS A  NON-BASED SHAREABLE IMAGE
		    SHRISDLIST[.SHRISDNUM] = .PREVISD;
		    SHRISDNUM = .SHRISDNUM + 1;
		    IF NOT .LNK$GL_CURCLU[CLU$V_COPY]		! UNLESS TAKING A PRIVATE COPY OF THIS IMAGE
		    THEN BEGIN
			IF .ISDHDR[ISD$V_WRT]			! IF THIS IS A WRITEABLE
				AND NOT .ISDHDR[ISD$V_CRF]	!  NON-CRF SECTION (I.E. SHAREABLE WRITEABLE)
			    THEN FIRSTISD[ISD$V_WRT] = TRUE;	!  THEN FLAG IN SECTION THAT WILL GO INTO HEADER
			EXITLOOP;				! THEN ALL DONE WITH ISECTS IN THIS PIC SHR IMG CLUSTER
			END;
		    END;
		END;
	END;
    END;
IF .LNK$GL_SHRADR NEQ 0
    OR .LNK$GL_FIXISD NEQ 0
    AND NOT .LNK$GL_CTLMSK[LNK$V_SYS]
    THEN LNK$CREATEFIX(.SHRCLUNUM,.SHRCLULST,.ADRCLUNUM,.ADRCLULST);! CREATE THE FIXUP SECTION IF NECESSARY

LNK$SORTISECTS (.ISDNUM, .ISDLIST);				! SORT ISECTS FOR BASED AND LOCAL SECTIONS

IF NOT .LNK$GL_CTLMSK[LNK$V_SYS]				! IF  NOT A SYSTEM IMAGE
    OR .LNK$GL_CTLMSK[LNK$V_SYSHEADR]				!  OR A SYSTEM IMAGE WITH A HEADER
THEN BEGIN
    INCHDRSIZE(.ISDNUM, .ISDLIST);				! COUNT ISD'S INTO IMAGE HEADER
    INCHDRSIZE(.SHRISDNUM, .SHRISDLIST);			!  FOR SHAREABLE IMAGE ISD'S ALSO
    LNK$GW_HDRBLKS = .LNK$GW_HDRBLKS + (.HEADER_SIZE + 511)/512;! ROUND UP THE HEADER BLOCK COUNT
    IF NOT $EXPREG(PAGCNT=.LNK$GW_HDRBLKS,RETADR=HEADERDESC)	! GET SOME MEMORY FOR THE HEADER
    THEN BEGIN							! BUT ON FAILURE
	SIGNAL(LIN$_MEMFUL,0,LIN$_NOIMGFIL);			! REPORT THE ERROR
	LNK$GL_CTLMSK[LNK$V_IMAGE] = FALSE;			! DISABLE IMAGE PRODUCTION
	RETURN;							! AND QUIT
        END;
    LNK$GW_DSTBLKS = (.LNK$GL_DSTEND + 511)/512;		! COMPUTE THE NUMBER OF BLOCKS
    END;
!
! OPEN THE IMAGE FILE
!
FILEBLKS = .LNK$GW_HDRBLKS + .LNK$GW_IMGBLKS + .LNK$GW_DSTBLKS;		! COMPUTE THE FILE SIZE
IF .LNK$GL_CTLMSK[LNK$V_DBG]						! IF A DEBUGGABLE EXECUTABLE IMAGE
    OR .LNK$GL_CTLMSK[LNK$V_SHR]
    THEN FILEBLKS = .FILEBLKS + (.LNK$GW_LSYMBOLS + 39)/20;		! OR A SHAREABLE IMAGE MAKE INITIAL ALLOCATION
									! LARGER FOR THE SYMBOL TABLE
$FAB_INIT(FAB=IMAGEFAB,
	FAC=(BRO,GET),
	MRS=512,
	RFM=FIX,
	ALQ=.FILEBLKS,
	FNS=.LNK$GL_IMGFIL[FDB$W_USRNAMLEN],
	FNA=.LNK$GL_IMGFIL[FDB$L_USRNAMADR],
	DNS=%CHARCOUNT('.EXE'),
	DNA=UPLIT(BYTE('.EXE')),
	NAM=AUXFNB,
	FOP=OFP);
IF .LNK$GL_CTLMSK[LNK$V_CONTIG]				! IF USER SAID CONTIGUOUS THEN
    THEN IMAGEFAB[FAB$V_CTG] = TRUE			! ATTEMPT TO DO IT, OTHERWISE
    ELSE IMAGEFAB[FAB$V_CBT] = TRUE;			! AS CONTIGUOUS A FILE AS POSSIBLE
LNK$AL_IMGRAB[RAB$L_FAB] = IMAGEFAB;			! AND POINT THE RAB AT THIS FAB
IF NOT (
	ERRORCODE = $CREATE(FAB=IMAGEFAB);		! ATTEMPT TO CREATE THE FILE
	RMSSTV = .IMAGEFAB[FAB$L_STV];
	.ERRORCODE)
OR NOT (
	ERRORCODE = $CONNECT(RAB=LNK$AL_IMGRAB);	! CONNECT A STREAM
	RMSSTV = .LNK$AL_IMGRAB[RAB$L_STV];
	.ERRORCODE)
THEN BEGIN						! AND IF THERE IS AN ERROR
	SIGNAL(LIN$_OPENOUT,1,LNK$FILNAMDSC(IMAGEFAB),	! THEN REPORT IT
		.ERRORCODE,.RMSSTV);			! THEN THE RMS STATUS
	LNK$GL_CTLMSK[LNK$V_IMAGE] = FALSE;		! TURN OFF IMAGE PRODUCTION
	RETURN;						! THEN GIVE UP
     END;
CH$MOVE(DSC$C_S_BLN,LNK$FILNAMDSC(IMAGEFAB),		! SET UP REAL FILE NAME DESCRIPTOR
			LNK$GL_IMGFIL[FDB$Q_FILENAME]);
LNK$GW_IMGIFI = .IMAGEFAB[FAB$W_IFI];			! SAVE THE INTERNAL ID FOR CLOSE LATER

CURVBN = 1 + .LNK$GW_HDRBLKS;					! FIRST I-SECTION STARTS AFTER HEADER
HEADER_SIZE = IHD$K_MAXLENGTH;					! SET INITIAL LENGTH
WRITEISECTS(.ISDNUM, .ISDLIST);					! WRITE OUT LOCAL AND BASED ISECTS
WRITEISECTS(.SHRISDNUM, .SHRISDLIST);				! WRITE OUT PIC SHAREABLE ISECTS
IF NOT .LNK$GL_CTLMSK[LNK$V_SYS]				! IF IMAGE HAS A HEADER
    OR .LNK$GL_CTLMSK[LNK$V_SYSHEADR]				! EITHER SYSTEM WITH HEADER
    THEN ISDTOHEADER(0);					! ISD LIST AND FILL LAST HEADER BLOCK

IF .DSTBUFFER[0] NEQ 0						! IF A DST BUFFER IS ALLOCATED
AND .LNK$GW_DSTBLKS NEQ 0					! AND DST WAS WRITTEN
THEN BEGIN
    LNK$GW_DSTVBN = .CURVBN;					! RECORD THE VBN OF IT
    IF NOT WRITESECTION(.LNK$GW_DSTBLKS,.CURVBN,		! AND OUTPUT THE BLOCKS
			.DSTBUFFER[0])
	THEN RETURN;
    CURVBN = .CURVBN + .LNK$GW_DSTBLKS;				! SET NEXT VBN
     END;
IF .LNK$GL_CTLMSK[LNK$V_SHR]				! IF PRODUCING A SHAREABLE
OR .LNK$GL_CTLMSK[LNK$V_DBG]				! OR DEBUGGABLE IMAGE
THEN BEGIN
	$DISCONNECT(RAB=LNK$AL_IMGRAB);			! DISCONNECT THE RAB
	LNK$GW_GSTVBN = .CURVBN;			! SET THE VBN OF THE GST
     END;
							! AND WILL CLOSE IT AFTER SYMBOLS
RETURN;						! AND HEADER ARE WRITTEN
END;

ROUTINE INCHDRSIZE(NUMISDS, ISDLIST) : NOVALUE =
BEGIN
!
!	THIS ROUTINE RUNS THROUGH THE ISD'S IN THE LIST AND
!	ADDS THEIR HEADER SIZE CONTRIBUTION UP.  THIS ROUTINE
!	MUST BE CALLED AFTER THE ISD'S HAVE BEEN SORTED.
!
MAP
    ISDLIST : REF VECTOR[,LONG];

LOCAL
    ISD : REF BLOCK[,BYTE],
    HDRISD : REF BLOCK[,BYTE];

IF .NUMISDS NEQ 0
    THEN INCRU I FROM 0 TO .NUMISDS-1
DO BEGIN
    ISD = .ISDLIST[.I];
    HDRISD = ISD[ISL$T_HDRISD];

    IF (.HEADER_SIZE + .HDRISD[ISD$W_SIZE]) GEQU 	! IF THIS ISD WILL NOT FIT WITHIN
					(512 - HDR$K_MINFILL)
    THEN BEGIN						! THE CURRENT HEADER BLOCK
	LNK$GW_HDRBLKS = .LNK$GW_HDRBLKS + 1;		! INCREMENT THE BLOCK COUNT
	HEADER_SIZE = .HDRISD[ISD$W_SIZE];		! AND NEXT BLOCK HAS JUST THIS MUCH
	END
    ELSE HEADER_SIZE = .HEADER_SIZE + 			! OTHERWISE ADD TO THE CURRENT BLOCK SIZE
				.HDRISD[ISD$W_SIZE];
    END;

RETURN;
END;

ROUTINE ISDTOHEADER(ISD) : NOVALUE =
BEGIN
!
!	THIS ROUTINE COPIES IMAGE SECTION DESCRIPTORS TO THE
!	IMAGE HEADER AND ENSURES THAT THE UNUSED PART OF EACH
!	BLOCK IS -1 FILLED (I.E. VALUE OF HDR$K_FILLCHR). IF THE
!	ARGUMENT IS 0, IT IS ASSUMED THAT THIS IS THE END OF THE
!	ISD LIST FOR THE HEADER.
!
LOCAL
	CURHEADOFF,
	FILLCOUNT,
	ISDSIZE;
!
OWN
	HEADBLOCKOFF;
!
MAP	ISD : REF BLOCK[,BYTE];					! ARGUMENT IS A POINTER
!
CURHEADOFF = .HEADBLOCKOFF*512 + .HEADER_SIZE + .HEADERDESC[0];	! COMPUTE CURRENT OFFSET INTO HEADER BUFFER
IF .ISD EQL 0							! IF THIS IS THE LAST I-SECTION
THEN ISDSIZE = 0
ELSE ISDSIZE = .ISD[ISD$W_SIZE];
IF (FILLCOUNT = 512 - .HEADER_SIZE) LEQU (.ISDSIZE + HDR$K_MINFILL)	! IF THERE IS NOT ROOM FOR THIS
THEN BEGIN								! DESCRIPTOR IN THE CURRENT BLOCK
	CURHEADOFF = CH$FILL(HDR$K_FILLCHR,.FILLCOUNT,.CURHEADOFF);	! THEN FILL IT UP
	HEADER_SIZE = 0;						! RESET SIZE OF THIS BLOCK
	HEADBLOCKOFF = .HEADBLOCKOFF + 1;				! INCREMENT TO NEXT BLOCK
     END;
IF .ISDSIZE EQL 0							! IF THIS IS THE END OF IT
THEN BEGIN
	CURHEADOFF = CH$FILL(0,HDR$K_MINFILL,.CURHEADOFF);		! INSERT MINIMUM ISD OF 0 (END OF LIST)
	CH$FILL(HDR$K_FILLCHR,(((.CURHEADOFF+511)AND NOT 511) - 	! THEN FILL UP REMAINDER OF
			.CURHEADOFF),.CURHEADOFF);			! THIS BLOCK
     END
ELSE BEGIN
	CH$MOVE(.ISDSIZE,ISD[ISD$W_SIZE],.CURHEADOFF);			! OTHERWISE JUST COPY IN
	HEADER_SIZE = .HEADER_SIZE + .ISDSIZE;				! CURRENT ISD
     END;
RETURN;
END;

ROUTINE WRITEISECTS (NUMISECTS, ISDLIST) =
BEGIN
!
! THIS ROUTINE WRITES OUT THE SPECIFIED NUMBER OF IMAGE SECTIONS TO
! THE IMAGE FILE.  ISDLIST IS A LIST OF THE ADDRESSES OF THE ISD'S
! TO WRITE
!
MAP
    ISDLIST : REF VECTOR[,LONG];

IF .NUMISECTS NEQ 0
THEN INCRU ISDNUM FROM 0 TO .NUMISECTS- 1			! LOOP THRU ALL IN LIST
DO BEGIN
    LNK$GL_CURISD = .ISDLIST[.ISDNUM];				! POINT TO ISECT DESCRIPTOR
    BEGIN
	BIND CURHDRISD = LNK$GL_CURISD[ISL$T_HDRISD] 		! NAME PART FOR HEADER
				: BLOCK[,BYTE];
	LNK$GL_CURCLU = .LNK$GL_CURISD[ISL$L_CLUDSC];		! SET CLUSTER DESCRIPTOR ADDRESS
	IF .CURHDRISD[ISD$V_GBL]				! IF A GLOBAL SECTION
	AND .LNK$GL_CURISD[ISL$L_BUFADR] NEQ 0			! WITH A BUFFER ALLOCATED
	THEN READSECTION();					! GO READ IT FROM ITS FILE
	IF NOT .CURHDRISD[ISD$V_DZRO]				! IF NOT A DEMAND ZERO SECTION
	AND .LNK$GL_CURISD[ISL$L_BUFADR] NEQ 0			! AND A BUFFER IS ALLOCATED
	THEN CURHDRISD[ISD$L_VBN] = .CURVBN;			! INSERT THE VBN OF BINARY
	IF (IF .LNK$GL_CTLMSK[LNK$V_SYS]			! IF A SYSTEM IMAGE WITH A HEADER
			THEN .LNK$GL_CTLMSK[LNK$V_SYSHEADR]	! ...
			ELSE TRUE)				! OR A REGULAR IAMGE
	AND .CURHDRISD[ISD$W_PAGCNT] NEQ 0			! AND SECTION IS NON ZERO IN LENGTH
	THEN ISDTOHEADER(CURHDRISD);				! INSERT ISD IN HEADER
	IF NOT .CURHDRISD[ISD$V_DZRO]				! IF NOT A DEMAND ZERO SECTION
	AND .LNK$GL_CURISD[ISL$L_BUFADR] NEQ 0			! AND A BUFFER IS ALLOCATED
	THEN BEGIN
		IF NOT WRITESECTION(.CURHDRISD[ISD$W_PAGCNT],	! THEN WRITE IT OUT
			.CURVBN,.LNK$GL_CURISD[ISL$L_BUFADR])	! TO THE FILE
		THEN RETURN;					! GIVING UP ON ERROR
		CURVBN = .CURVBN + .CURHDRISD[ISD$W_PAGCNT];	! UPDATE TO NEXT AVAILABLE VBN
	     END;
	END;
    END;
RETURN TRUE
END;

GLOBAL ROUTINE LNK$GETFIXSIZE =
BEGIN
!
! THIS ROOUTINE COMPUTES AND RETURNS AS A VALUE THE SIZE (IN PAGES)
! REQUIRED FOR THE FIXUP SECTION
!

RETURN ((((.LNK$GL_SHRIMGS*2)+(.LNK$GL_SHRSYMS+1)		! NUMBER OF SHR IMGS REFERENCED 
		+.LNK$GL_SPCGFIX				! PLUS NUMBER OF SPECIAL G^ FIXUPS
		+(.LNK$GL_SHRADR*2)+(.LNK$GL_ADREFS+1))*4)	! PLUS THE SIZE FOR THE .ADDR FIXUPS
		+(.LNK$GL_SHRCLSTRS+1)*SHL$C_LENGTH		! PLUS THE SIZE OF THE SHL LIST
		+(.LNK$GL_SHLEXTRA*SHL$C_LENGTH)		! PLUS ANY EXTRA SHL'S REQUESTED
		+(.LNK$GL_RPROTISD+1)*ICP$C_LENGTH+4		! PLUS THE SIZE OF THE FIXUP INFO
		+IAF$C_LENGTH+511)/512				! PLUS THE FIXED PART, ALL ROUNDED UP TO NEXT PAGE BOUNDARY
END;

ROUTINE STORESPCGFIX (NODE,TRAVINFO) =
BEGIN
!
! THIS ROUTINE IS CALLED BY THE TRAVERSE_TREE ROUTINE FOR EACH
! ELEMENT IN THE TREE.
!
! INPUTS:
!
!	NODE		ADDRESS OF CURRENT NODE
!	TRAVINFO	ADDRESS OF INFO SET UP BY LNK$CREATEFIX
!
MAP
    NODE : REF BLOCK[,BYTE],
    TRAVINFO : REF VECTOR[,LONG];

BIND
    BUFLOC = .TRAVINFO[0] + (.NODE[SPCR$L_FIXADR] - .TRAVINFO[1]),
    STOREADDR = BUFLOC : VECTOR[,LONG];

STOREADDR[0] = .NODE[SPCR$L_OFFSET];
RETURN TRUE
END;

ROUTINE LNK$CREATEFIX (SHRCLUNUM,CLUSTERLIST,ADRCLUNUM,ADRCLULST) =
BEGIN
!
! THIS ROUTINE ALLOCATES BUFFER SPACE AND FILLS IN THE
! FIXUP IMAGE SECTION FOR COMMUNICATION WITH THE IMAGE
! ACTIVATOR.
!
! INPUTS:
!
!	SHRCLUNUM	NUMBER OF ITEMS IN CLUSTERLIST
!	CLUSTERLIST	ADDRESS OF LIST OF CLUSTER DESCRIPTOR ADDRESSES OF SHAREABLE IMAGES
!	ADRCLUNUM	NUMBER OF ITEMS IN ADRCLULST
!	ADRCLULST	ADDRESS OF LIST OF CLUSTER DESCRIPTOR ADDRESSES OF NON-SHR IMAGE CLUSTERS 
!			 REFERENCED VIA .ADDRESS
!
MAP
    CLUSTERLIST : REF VECTOR[,LONG],
    ADRCLULST : REF VECTOR[,LONG];
LOCAL
    CLUSTERINDEX,
    FIXSIZE,
    FIXBUF : REF BLOCK[,BYTE],
    SYMBOLBLOCK : REF BLOCK[,BYTE],
    ADRBLOCK : REF VECTOR[,LONG],
    SHRNAMLIST : REF BLOCK[,BYTE],
    SHRIMGINDEX,
    CURISD : REF BLOCK[,BYTE],
    CURHDRISD : REF BLOCK[,BYTE],
    SPCGFIXVEC : REF VECTOR[,LONG],
    TRAVINFO : VECTOR[2,LONG],			! INFO FOR ACTION ROUTINE OF TREE TRAVERSAL
    REPROTVEC : REF BLOCK[,BYTE],
    EXTADRVEC : REF VECTOR[,LONG],
    EXTINDEX,
    FIXISDHDR : REF BLOCK[,BYTE],
    DOTADRVEC : REF VECTOR[,LONG],
    DOTADRINDEX;

FIXISDHDR = LNK$GL_FIXISD[ISL$T_HDRISD];		! POINT TO PART BOUND FOR IMAGE HEADER

IF .LNK$GL_CTLMSK[LNK$V_PROTECT]					! IF /PROTECT
    THEN FIXISDHDR[ISD$V_PROTECT] = TRUE;				! THEN PROTECT SECTION
FIXISDHDR[ISD$V_FIXUPVEC] = TRUE;					! DECLARE ISD TO BE FIXUP VECTOR SECTION
FIXSIZE = LNK$GETFIXSIZE();						! GET SIZE OF FIXUP SECTION NEEDED
FIXISDHDR[ISD$W_PAGCNT] = .FIXSIZE;					! SET NUMBER OF PAGES INTO ISD
IF NOT $EXPREG(PAGCNT=.FIXSIZE,						! ALLOCATE SPACE FOR SECTION
		RETADR=LNK$GL_FIXISD[ISL$L_BUFADR])
THEN BEGIN								! BUT IF IT FAILS, ISSUE AN ERROR MESSAGE
    SIGNAL(LIN$_MEMFUL,0,LIN$_NOIMGFIL);
    LNK$GL_CTLMSK[LNK$V_IMAGE] = FALSE;
    RETURN TRUE
    END;
!
! ALLOCATE VIRTUAL MEMORY FOR FIXUP SECTION.  THIS IS DONE TO ENSURE THAT
! WE DID NOT BASE THE WORLD DURING PASS 2 AND PUT A SHAREABLE IMAGE WHERE
! WE THOUGHT THE FIXUP SECTION WAS GOING TO GO
!
IF NOT .LNK$GL_FIXISD[ISL$V_MEMALO]
THEN BEGIN
    IF NOT LNK$ALLOVIRMEM(.FIXISDHDR[ISD$V_VPN]^9,.FIXISDHDR[ISD$W_PAGCNT])
    THEN BEGIN
	SIGNAL(LIN$_CONFIXMEM,1,LNK$GL_IMGFIL[FDB$Q_FILENAME],
		LIN$_NOIMGFIL);
	LNK$GL_CTLMSK[LNK$V_IMAGE] = FALSE;
	RETURN TRUE
	END;
    LNK$GL_FIXISD[ISL$V_MEMALO] = TRUE;
    END;
FIXBUF = .LNK$GL_FIXISD[ISL$L_BUFADR];
TRAVINFO[0] = .FIXBUF;							! SET INFO FOR TREE TRAVERSAL
TRAVINFO[1] = .FIXISDHDR[ISD$V_VPN] ^ 9;
FIXBUF[IAF$L_IAFLINK] = 0;						! ZERO IMAGE ACTIVATOR LINK
FIXBUF[IAF$W_SIZE] = IAF$C_LENGTH;					! SET SIZE OF FIXED PART OF FIXUP ISD HEADER
FIXBUF[IAF$V_SHR] = .LNK$GL_CTLMSK[LNK$V_SHR];				! SET FLAGS
FIXBUF[IAF$L_SHRIMGCNT] = .LNK$GL_SHRCLSTRS + 1;			! SET COUNT OF SHAREABLE IMAGES (+1 FOR CURRENT IMAGE)
FIXBUF[IAF$L_SHLEXTRA] = .LNK$GL_SHLEXTRA;				! SET COUNT OF EXTRA SHL SLOTS
EXTADRVEC = .FIXBUF + IAF$C_LENGTH;					! SET ADDRESS OF START OF G^ VECTOR
SPCGFIXVEC = .EXTADRVEC + ((.LNK$GL_SHRIMGS*2)+(.LNK$GL_SHRSYMS+1))*4;	! SET ADDRESS OF SPECIAL G^ FIXUP VECTOR
IF .LNK$GL_SPCGFIX NEQ 0						! IF THERE ARE SPECIAL G^ FIXUPS
    THEN REPROTVEC = (.LNK$GL_LASTGADR - .TRAVINFO[1]) + .FIXBUF	!  THEN SET REPROT VEC AFTER THAT
    ELSE REPROTVEC = .SPCGFIXVEC;					!  OTHERWISE RIGHT ON IT
SHRNAMLIST = .REPROTVEC + (.LNK$GL_RPROTISD+1)*ICP$C_LENGTH + 4;	! SET ADDRESS OF SHR IMG NAME LIST
DOTADRVEC = .SHRNAMLIST + (.LNK$GL_SHRCLSTRS+1+.LNK$GL_SHLEXTRA)*SHL$C_LENGTH;! SET ADDRESS OF .ADDR VECTOR
!
! SET OFFSETS TO THE SEGMENTS INTO THE FIXUP ISECT HEADER
!
FIXBUF[IAF$L_CHGPRTOFF] = .REPROTVEC - .FIXBUF;				! SET OFFSET TO CHANGE PROTECTION DATA
IF .LNK$GL_SHRSYMS NEQ 0						! IF THERE ARE G^ FIXUPS
    THEN FIXBUF[IAF$L_G_FIXOFF] = .EXTADRVEC - .FIXBUF			! THEN CALCULATE OFFSET
    ELSE FIXBUF[IAF$L_G_FIXOFF] = 0;					! OTHERWISE GUARANTEE A 0
IF .LNK$GL_ADREFS NEQ 0							! IF THERE ARE .ADDR FIXUPS
    THEN FIXBUF[IAF$L_DOTADROFF] = .DOTADRVEC - .FIXBUF			! THEN CALCULATE OFFSET
    ELSE FIXBUF[IAF$L_DOTADROFF] = 0;					! OTHERWISE GUARANTEE A 0
FIXBUF[IAF$L_SHLSTOFF] = .SHRNAMLIST - .FIXBUF;				! CALCULATE OFFSET TO SHR IMG NAME LIST

DOTADRINDEX = SHRIMGINDEX =  EXTINDEX = 0;				! INIT INDICES INTO THE VECTORS
!
! SET REPROTECTION DATA FOR FIXUP SECTION
!
.REPROTVEC = .LNK$GL_RPROTISD + 1;
REPROTVEC = .REPROTVEC + 4;
REPROTVEC[ICP$L_BASEVA] = .FIXISDHDR[ISD$V_VPN]^9 			! SET BASE ADDRESS
						- .LNK$GL_MINVA;
REPROTVEC[ICP$W_NPAGES] = .FIXSIZE;
REPROTVEC[ICP$W_NEWPRT] = PRT$C_UREW;
REPROTVEC = .REPROTVEC + ICP$C_LENGTH;
!
! LOOP THROUGH THE LOCAL CLUSTERS AND DO THE IMAGE 0 .ADDRESS REFERENCES
!
IF .ADRCLUNUM NEQ 0							! IF THERE ARE ANY .ADDR CLUSTER REFS
THEN BEGIN
    DOTADRVEC[0] = 0;							! INITIALIZE THE FIXUP COUNT
    DOTADRVEC[1] = 0;							! THE IMAGE IS NUMBER 0
    DOTADRINDEX = 2;							! SKIP THE IMAGE NUMBER AND COUNT OF ITEMS
    INCRU CLUSTERINDEX FROM 0 TO .ADRCLUNUM-1				! LOOP THROUGH THE LIST
    DO BEGIN
	LNK$GL_CURCLU = .ADRCLULST[.CLUSTERINDEX];			! PICK UP CURRENT CLUSTER
	DOTADRVEC[0] = .DOTADRVEC[0] + .LNK$GL_CURCLU[CLU$L_ADRCNT];	! INCREMENT COUNT OF REFERENCES
	ADRBLOCK = LNK$GL_CURCLU[CLU$L_FSTADRL];			! GET THE LISTHEAD OF ADDRESS BLOCKS
	WHILE (ADRBLOCK = .ADRBLOCK[0]) NEQ 0				! LOOP THROUGH ALL THE ADDRESS BLOCKS
	DO BEGIN
	    BIND ADRCNT = (IF .ADRBLOCK NEQ .LNK$GL_CURCLU[CLU$L_LSTADRL] ! COMPUTE COUNT OF ELEMENTS IN THIS BLOCK
					THEN CLU$C_ADRBLOCK - 1
					ELSE CLU$C_ADRBLOCK - .LNK$GL_CURCLU[CLU$L_ADRLEFT] - 1);
	    INCRU I FROM 1 TO ADRCNT					! LOOP THROUGH THIS BLOCK
	    DO BEGIN
		DOTADRVEC[.DOTADRINDEX] = .ADRBLOCK[.I] - 		! AND STORE PC IN THE NEXT LOCATION
						.LNK$GL_MINVA;
		DOTADRINDEX = .DOTADRINDEX + 1;				! MOVE TO NEXT LOCATION
	        END
	    END;
	END
    END;
!
! FIND ALL ISECTS THAT NEED TO BE REPROTECTED IN THE LOCAL CLUSTERS.  IF THE
! CLUSTER IS A SHAREABLE IMAGE AND CONTAINS SPECIAL G^ FIXUPS, DO THOSE NOW.
!
LNK$GL_CURCLU = LNK$GL_CLULST;						! POINT TO START OF CLUSTER LIST
WHILE (LNK$GL_CURCLU = .LNK$GL_CURCLU[CLU$L_NXTCLU]) NEQ 0		! LOOK AT ALL CLUSTERS
DO IF NOT .LNK$GL_CURCLU[CLU$V_SHRIMG]					!  BUT IGNORE SHAREABLE IMAGES
THEN BEGIN
    CURISD = LNK$GL_CURCLU[CLU$L_FSTISD];				! POINT TO LISTHEAD
    WHILE (CURISD = .CURISD[ISL$L_NXTISD]) NEQ 0			! LOOP THROUGH ALL ISECTS THIS CLUSTER
    DO IF .CURISD[ISL$V_REPROT]						! IF THIS SECTION NEEDS TO BE REPROTECTED
    THEN BEGIN
	CURHDRISD = CURISD[ISL$T_HDRISD];				! POINT TO HEADER PART
	REPROTVEC[ICP$L_BASEVA] = .CURHDRISD[ISD$V_VPN]^9		! SET BASE VA OF ISECT
						- .LNK$GL_MINVA;
	REPROTVEC[ICP$W_NPAGES] = .CURHDRISD[ISD$W_PAGCNT];		! AND NUMBER OF PAGES
	REPROTVEC[ICP$W_NEWPRT] = .CURISD[ISL$B_NEWPRT];		! COPY NEW PROTECTION
	REPROTVEC = .REPROTVEC + ICP$C_LENGTH;				! POINT TO NEXT SLOT
	END;
    END
ELSE IF .LNK$GL_CURCLU[CLU$L_SPCRLST] NEQ 0				! SHR IMG--IF IT CONTAINS SPECIAL G^ FIXUPS
    THEN LIB$TRAVERSE_TREE(LNK$GL_CURCLU[CLU$L_SPCRLST],STORESPCGFIX,	!  THEN TRAVERSE THE TREE AND STORE THE INFO
				TRAVINFO);
!
! NOW LOOP THROUGH THE CLUSTERS AND STORE THE INFORMATION
!
SHRNAMLIST = .SHRNAMLIST + SHL$C_LENGTH;				! LEAVE ROOM FOR IMAGE 0 (CURRENT IMAGE)
IF .SHRCLUNUM NEQ 0
THEN INCRU CLUSTERINDEX FROM 0 TO .SHRCLUNUM-1				! FOR ALL SHAREABLE IMAGES
DO BEGIN
    LNK$GL_CURCLU = .CLUSTERLIST[.CLUSTERINDEX];			! GET CLUSTER DESCRIPTOR ADDRESS
    CH$COPY(.LNK$GL_CURCLU[CLU$B_NAMLNG]+1,				! COPY THE SHAREABLE IMAGE NAME INTO THE SHR IMG LIST
			LNK$GL_CURCLU[CLU$B_NAMLNG],0,
			SHL$C_MAXNAMLNG,SHRNAMLIST[SHL$T_IMGNAM]);
    SHRNAMLIST = .SHRNAMLIST + SHL$C_LENGTH;				! NEXT SHR IMAGE NAME SLOT
    SHRIMGINDEX = .SHRIMGINDEX + 1;					! NEXT IMAGE INDEX
    IF .LNK$GL_CURCLU[CLU$L_SHRSYMS] NEQ 0				! IF THERE ARE G^ SYMBOLS IN THIS CLUSTER
    THEN BEGIN
	EXTADRVEC[.EXTINDEX] = .LNK$GL_CURCLU[CLU$L_SHRSYMS];		! SET NUMBER OF REFERENCES
	EXTINDEX = .EXTINDEX + 1;					! NEXT LOCATION
	EXTADRVEC[.EXTINDEX] = .SHRIMGINDEX;				! SET SHR IMAGE INDEX INTO G^ VECTOR
	EXTINDEX = .EXTINDEX + 1;					! NEXT LOCATION
	SYMBOLBLOCK = .LNK$GL_CURCLU[CLU$L_SHRLST];			! GET LIST OF SHR IMG SYMBOLS THIS CLUSTER
	WHILE .SYMBOLBLOCK NEQ 0					! LOOP THROUGH THEM AND PUT THE OFFSETS INTO THE G^ VECTOR
	DO BEGIN
	    EXTADRVEC[.EXTINDEX] = .SYMBOLBLOCK[SYM$L_OFFSET];		! STORE OFFSET FOR THIS SYMBOL
	    EXTINDEX = .EXTINDEX + 1;					! NEXT G^ VECTOR LOCATION
	    SYMBOLBLOCK = .SYMBOLBLOCK[SYM$L_SHRLNK];			! LINK TO NEXT SYMBOL
	    END;
	END;
!
! IF THIS CLUSTER HAS .ADDR REFERENCES THEN STORE THEM ALSO
!
    IF .LNK$GL_CURCLU[CLU$L_ADRCNT] NEQ 0
    THEN BEGIN
	DOTADRVEC[.DOTADRINDEX] = .LNK$GL_CURCLU[CLU$L_ADRCNT];		! STORE NUMBER OF SUCH REFERENCES
	DOTADRVEC[.DOTADRINDEX+1] = .SHRIMGINDEX;			! SET SHR IMG INDEX INTO .ADDR VECTOR
	DOTADRINDEX = .DOTADRINDEX + 2;					! INCREMENT THE INDEX
	ADRBLOCK = LNK$GL_CURCLU[CLU$L_FSTADRL];			! GET THE FIRST .ADDR BLOCK FOR THIS CLUSTER
	WHILE (ADRBLOCK = .ADRBLOCK[0]) NEQ 0				! LOOP THROUGH ALL .ADDR BLOCKS IN THIS CLUSTER
	DO BEGIN
	    BIND ADRCNT = (IF .ADRBLOCK NEQ .LNK$GL_CURCLU[CLU$L_LSTADRL] ! COMPUTE NUMBER OF ENTRIES IN THIS BLOCK
				THEN CLU$C_ADRBLOCK - 1
				ELSE CLU$C_ADRBLOCK - .LNK$GL_CURCLU[CLU$L_ADRLEFT] - 1);
	    !
	    ! STORE THE ADDRESSES IN THE .ADDR VECTOR
	    !
	    INCRU I FROM 1 TO ADRCNT
	    DO BEGIN
		DOTADRVEC[.DOTADRINDEX] = .ADRBLOCK[.I] - .LNK$GL_MINVA;
		DOTADRINDEX = .DOTADRINDEX + 1;
		END;
	    END;
	END;
    END;

RETURN TRUE
END;

ROUTINE READSECTION : NOVALUE =
BEGIN
!++
!		THIS ROUTINE COPIES GLOBAL SECTION FROM A SHAREABLE
!	IMAGE TO THE IMAGE BEING PRODUCED. IF THIS IS THE FIRST ENTRY FOR
!	A PARTICULAR CLUSTER THEN THE IMAGE FILE OPEN ON A PREVIUOS 
!	CLUSTER IS CLOSED AND THIS ONE IS OPENED. THE SECTION IS READ
!	INTO A BUFFER WHICH IS DESCRIBED BY THE DESCRIPTOR IN THE
!	IMAGE SECTION DESCRIPTOR.
!--
OWN
	SHRIMGIFI,				! IFI OF THE SHAREABLE IMAGE FILE
	PREVAUXFNB : REF BLOCK[,BYTE];		! AUXILIARY FILE NAME BLOCK OF PREVIOUS FILE
!
LOCAL
	FABLOCK : BLOCK[FAB$C_BLN,BYTE],	! FAB FOR OPENING AND CLOSING
	ERRORCODE,				! RMS ERROR CODE
	STVCODE,
	BYTECOUNT;
!
BIND
	SHRIMGFDB = LNK$GL_CURCLU[CLU$L_FSTFDB] : REF BLOCK[,BYTE],
	SHRIMGAUXFNB = SHRIMGFDB[FDB$T_AUXFNB] : BLOCK[,BYTE],
	CURHDRISD = LNK$GL_CURISD[ISL$T_HDRISD] : BLOCK[,BYTE];
!
IF .SHRIMGIFI NEQ 0				! IF A FILE IS POEN
AND NOT .LNK$GL_CURCLU[CLU$V_OPEN]		! AND NOT THIS FILE
THEN BEGIN
	$FAB_INIT(FAB=FABLOCK);				! INITIALIZE THE FAB
	FABLOCK[FAB$W_IFI] = .SHRIMGIFI;		! AND THE INTERNAL FILE IDENT
	IF NOT (ERRORCODE = $CLOSE(FAB=FABLOCK))	! ATTEMPT THE CLOSE
	THEN BEGIN					! AND ON FAILURE
		SIGNAL(LIN$_CLOSEIN,1,SHRIMGFDB[FDB$Q_FILENAME],
				.ERRORCODE,.FABLOCK[FAB$L_STV]);
	     END;
	SHRIMGCLU[CLU$V_OPEN] = FALSE;			! FLAG FILE NOT OPEN
	SHRIMGIFI = 0;					! RESET THE IFI
     END;
IF NOT .LNK$GL_CURCLU[CLU$V_COPY]				! IF THIS CLUSTER IS NOT TO BE COPIED
OR (SHRIMGRAB[RAB$L_BKT] = .CURHDRISD[ISD$L_VBN]) EQL 0		! IF THIS CLUSTER NOT TO BE COPIED
THEN BEGIN
	LNK$GL_CURISD[ISL$L_BUFADR] = 0;			! CLEAR THE BUFFER ADDRESS
	CURHDRISD[ISD$L_VBN] = 0;				! AND THE VBN
	RETURN;						! AND THAT'S ALL
     END;
IF NOT .LNK$GL_CURCLU[CLU$V_OPEN]			! IF THE FILE IS NOT OPEN
THEN BEGIN
	$FAB_INIT(FAB=FABLOCK,				! INITIALIZE THE FAB
		FAC=(BIO,GET),
		FOP=NAM,
		NAM=SHRIMGAUXFNB);
	SHRIMGRAB[RAB$L_FAB] = FABLOCK;			! SET FAB ADDRESS IN RAB
	SHRIMGRAB[RAB$W_ISI] = 0;			! RESET STREAM IDENTIFIER
	IF NOT BEGIN
		IF NOT (ERRORCODE = $OPEN(FAB=FABLOCK))	! ATTEMPT TO OPEN
		THEN BEGIN				! THE IMAGE FILE AND
			STVCODE = .FABLOCK[FAB$L_STV];	! ON FAILURE SET STV
			FALSE				! AND SKIP
		     END
		ELSE TRUE
	       END
	OR NOT BEGIN
		IF NOT (ERRORCODE = $CONNECT(RAB=SHRIMGRAB))	! ATTEMPT TO CONNECT RAB
		THEN BEGIN					! AND ON FAILURE
			STVCODE = .SHRIMGRAB[RAB$L_STV];	! SET STV CODE
			FALSE					! AND SKIP
		     END
		ELSE TRUE
	         END
	THEN BEGIN
		SIGNAL((LIN$_OPENIN AND NOT STS$M_SEVERITY) OR STS$K_WARNING,1,SHRIMGFDB[FDB$Q_FILENAME],
				.ERRORCODE,.STVCODE);
		LNK$GL_CURCLU[CLU$V_OPEN] = FALSE;			! RESET OPEN FLAG
		CURHDRISD[ISD$L_VBN] = 0;				! AND THE VBN
		RETURN;
	     END;
	SHRIMGIFI = .FABLOCK[FAB$W_IFI];				! SAVE THE IFI
	SHRIMGCLU = .LNK$GL_CURCLU;					! SAVE CLUSTER DESCRIPTOR
	SHRIMGCLU[CLU$V_OPEN] = TRUE;					! FLAG IMAGE FILE OPEN
	PREVAUXFNB = SHRIMGAUXFNB;					! THIS WILL BE PREVIOUS NEXT TIME
     END;

SHRIMGRAB[RAB$L_UBF] = .LNK$GL_CURISD[ISL$L_BUFADR];		! SET BUFFER ADDRESS
BYTECOUNT = .CURHDRISD[ISD$W_PAGCNT] * 512;			! AND BYTE COUNT
WHILE .BYTECOUNT GTR 0					! BEGIN LOOP
DO BEGIN
	SHRIMGRAB[RAB$W_USZ] = MINU(.BYTECOUNT,TFRLENGTH);	! SET BYTE COUNT
	IF NOT (ERRORCODE = $READ(RAB=SHRIMGRAB))		! ATTEMPT NEXT READ
	THEN BEGIN
		SIGNAL(LIN$_READERR,1,
			SHRIMGFDB[FDB$Q_FILENAME],
			.ERRORCODE,.SHRIMGRAB[RAB$L_STV]);
		LNK$GL_CURISD[ISL$L_BUFADR] = 0;		! RESET BUFFER ADDRESS
		CURHDRISD[ISD$L_VBN] = 0;			! AND VBN
		RETURN;
	      END;
	BYTECOUNT = .BYTECOUNT - TFRLENGTH;			! REDUCE THE BYTECOUNT
	SHRIMGRAB[RAB$L_UBF] = .SHRIMGRAB[RAB$L_UBF] +		! ADJUST BUFFER
				.SHRIMGRAB[RAB$W_USZ];		! FOR AMOUNT OF READ
	SHRIMGRAB[RAB$L_BKT] = 0;
     END;
RETURN;
END;		! OF READSECTION ROUTINE

ROUTINE WRITESECTION(PAGES,VBN,BUFFER) =
BEGIN
LOCAL
	BYTECOUNT,							! NUMBER OF BYTES OF IMAGE FILE
	ERRORCODE;							! WRITE ERROR CODE RETURNED
!
BIND AUXFNB = LNK$GL_IMGFIL[FDB$T_AUXFNB] : BLOCK[NAM$C_BLN,BYTE];	! AUXILIARY FILENAME BLOCK
!
BYTECOUNT = .PAGES * 512;
LNK$AL_IMGRAB[RAB$L_BKT] = .VBN;
LNK$AL_IMGRAB[RAB$L_RBF] = .BUFFER;
WHILE .BYTECOUNT GTR 0							! LOOP TILL ALL DONE
DO BEGIN
	LNK$AL_IMGRAB[RAB$W_RSZ] = MIN(.BYTECOUNT,TFRLENGTH);		! SET BYTE COUNT FOR THIS WRITE
	IF NOT (ERRORCODE = $WRITE(RAB=LNK$AL_IMGRAB))			! AND DO IT
	THEN BEGIN							! BUT IF AN
		SIGNAL(LIN$_WRITEERR,1,LNK$GL_IMGFIL[FDB$Q_FILENAME],	! AND REPORT THE ERROR
			.ERRORCODE,.LNK$AL_IMGRAB[RAB$L_STV],LIN$_NOIMGFIL);
		LNK$GL_CTLMSK[LNK$V_IMAGE] = FALSE;			! MESSAGE
		RETURN FALSE;						! THEN GIVE UP
	     END;
	BYTECOUNT = .BYTECOUNT - TFRLENGTH;				! REDUCE THE BYTE COUNT
	LNK$AL_IMGRAB[RAB$L_RBF] = .LNK$AL_IMGRAB[RAB$L_RBF] +		! UPDATE BUFFER POINTER
					.LNK$AL_IMGRAB[RAB$W_RSZ];	! TO THE NEXT PIECE
	LNK$AL_IMGRAB[RAB$L_BKT] = 0;					! FORCE RMS TO USE NEXT BLOCK POINTER
   END;									! AND GO AGAIN
RETURN TRUE;
END;

GLOBAL ROUTINE LNK$WRTIMGHDR : NOVALUE =
BEGIN
!
! THIS ROUTINE IS CALLED TO WRITE THE IMAGE HEADER. IT FIRST WRITES
! THE HEADER FIXED RECORD INTO THE FIRST HEADER BUFFER BLOCK THEN
! OUTPUTS TO THE (OPEN) IMAGE FILE ALL BLOCKS OF THE IMAGE HEADER
! FINALLY THE IMAGE FILE IS CLOSED.
!
GLOBAL
	LNK$GL_OTSEPDSC : REF BLOCK[,BYTE];			! POINTER TO DESCRIPTOR OF OTS ENTRY POINT
!
LOCAL
	CURTFR,							! ADDRESS IN HEADER FOR NEXT TRANSFER ADDRESS
	OTSEPNAM : REF BLOCK[,BYTE],				! POINTER TO OTS EPT NAME BLOCK
	SYSVER : REF BLOCK[,BYTE],				! POINTER TO VALUE PART OF SYS$K_VERSION
	SYSVERNAM : REF BLOCK[,BYTE],				! POINTER TO NAME PART OF SYS$K_VERSION
	IHDACTIV : REF BLOCK[,BYTE];				! IMAGE ACTIVATION AREA OF HEADER
!
BIND	OTSENTRYSYM = CSTRING('LIB$INITIALIZE'),		! OTS ENTRY POINT NAME
	IMAGEHEADER = HEADERDESC[0] : REF BLOCK[,BYTE],		! POINT TO THE BUFFER
	IMAGEPRIVS = IMAGEHEADER[IHD$Q_PRIVREQS] : VECTOR[2,LONG], ! POINT TO PRIVILEGES
	IMGIDAREA = IHDACTIV : REF BLOCK[,BYTE],		! USE SAME CELL TO POINT TO ID AREA
	SYMDBGDATA = IHDACTIV : REF BLOCK[,BYTE];		! AND FOR SYMBOL TABLE AND DEBUG DATA
!
IF (.LNK$GL_CTLMSK[LNK$V_SYS]					! IF A SYSTEM IMAGE
	AND NOT .LNK$GL_CTLMSK[LNK$V_SYSHEADR])			!  WITHOUT A HEADER
OR .LNK$GW_HDRBLKS EQL 0					! OR THERE IS NO HEADER
THEN BEGIN
	LNK$CLOSIMGFIL();					! CLOSE THE IMAGE FILE
	RETURN;							! AND THAT'S ALL
     END;
IMAGEHEADER[IHD$B_HDRBLKCNT] = .LNK$GW_HDRBLKS;			! INSERT NUMBER OF BLOCKS OF HEADER IN HEADER
IMAGEHEADER[IHD$W_SIZE] = IHD$K_MAXLENGTH;			! SIZE OF HEADER
IMAGEHEADER[IHD$W_ACTIVOFF] = IHD$K_ACTIVOFF;			! OFFSET TO ACTIVATION CONTROL
IMAGEHEADER[IHD$W_SYMDBGOFF] = IHD$K_SYMDBGOFF;			! SYMBOL AND DEBUG DATA
IMAGEHEADER[IHD$W_IMGIDOFF] = IHD$K_IMGIDOFF;			! THE IDENTIFICATION AREA
IMAGEHEADER[IHD$B_IMGTYPE] = IHD$K_EXE;				! ASSUME EXECUTABLE IMAGE
IF .LNK$GL_CTLMSK[LNK$V_SHR]					! IF SHAREABLE, THEN SET
    THEN IMAGEHEADER[IHD$B_IMGTYPE] = IHD$K_SHR;		! TO SHAREABLE
IMAGEHEADER[IHD$W_IOCHANCNT] = .LNK$GW_CHANS;			! SET NUMBER OF CHANNELS
IMAGEHEADER[IHD$W_IMGIOCNT] = .LNK$GW_IOSEG;			! AND SIZE OF I/O SEGMENT
IMAGEHEADER[IHD$V_LNKDEBUG] = .LNK$GL_CTLMSK[LNK$V_DBG];	! AND THE STATE OF DEBUG FLAG
IMAGEHEADER[IHD$V_PICIMG] = .LNK$GL_CTLMSK[LNK$V_PICIMG];	! EXTRACT POSITION DEPENDENCE FLAG
IMAGEHEADER[IHD$V_NOP0BUFS] = .LNK$GL_CTLMSK[LNK$V_NOP0BUFS]; 	! AND STATE OF RMS P0 BUFFER INDICATOR
IMAGEHEADER[IHD$V_MATCHCTL] = .LNK$GB_MATCHCTL;			! MATCH CONTROL FLAGS
IMAGEHEADER[IHD$L_IDENT] = .LNK$GL_MATCHID;			! AND THE ASSOCIATED IDENT
IMAGEPRIVS[0] = .LNK$GQ_PRIVS[0];				! SET PRIVS INTO HEADER
IMAGEPRIVS[1] = .LNK$GQ_PRIVS[1];				! ...
IF LNK$SEARCH(LNK$GT_SYSVER,SYSVER,SYSVERNAM)			! LOOK UP SYS$K_VERSION
    THEN IMAGEHEADER[IHD$L_SYSVER] = .SYSVER[SYM$L_VALUE]	! AND STORE THE VALUE
    ELSE IMAGEHEADER[IHD$L_SYSVER] = 0;				! WE REALLY SHOULD ALWAYS FIND IT!
IF .LNK$GL_FIXISD NEQ 0						! IF THERE IS A FIXUP SECTION
THEN BEGIN
    BIND
	FIXHDRISD = LNK$GL_FIXISD[ISL$T_HDRISD] : BLOCK[,BYTE];	! NAME PART BOUND FOR HEADER

    IMAGEHEADER[IHD$L_IAFVA] = .FIXHDRISD[ISD$V_VPN]^9;		! SET VA OF FIXUP SECTION
    END
ELSE IMAGEHEADER[IHD$L_IAFVA] = 0;				! IF NOT PRESENT THEN SET 0
IMAGEHEADER[IHD$V_P0IMAGE] = .LNK$GL_CTLMSK[LNK$V_P0IMAGE];	! SET P0-ONLY STATUS
IHDACTIV = .IMAGEHEADER + .IMAGEHEADER[IHD$W_ACTIVOFF];		! POINT TO ACTIVATION AREA
CURTFR = IHDACTIV[IHA$L_TFRADR1];				! START AT FIRST TRANSFER ADDRESS
IF .LNK$GL_DBGTFPS NEQ 0					!  IF A
THEN BEGIN							! DEBUGGER TRANSFER
	.CURTFR = .LNK$GL_DBGTFR;				! ADDRESS WAS FOUND
	CURTFR = IHDACTIV[IHA$L_TFRADR2];			! THEN IT IS FIRST AND UPDATE TO NEXT
     END
ELSE IF .LNK$GL_CTLMSK[LNK$V_DBG]				! NO DEBUGGER TRANSFER ADDRESS SO
THEN SIGNAL(LIN$_DBGTFR,1,					! CHECK IF DEBUG WAS REQUESTED
		LNK$GL_IMGFIL[FDB$Q_FILENAME]);			! AND ISSUE ERROR IF SO
IF NOT .LNK$GL_CTLMSK[LNK$V_SYS]				! FOR A NON SYSTEM IMAGE
THEN IF LNK$SEARCH(OTSENTRYSYM,LNK$GL_OTSEPDSC,OTSEPNAM)	! IF THE RESERVED EPT NAME FOR
     THEN BEGIN							! THE OTS HAS BEEN DEFINED
	.CURTFR = .LNK$GL_OTSEPDSC[SYM$L_VALUE];		! THEN NEXT TRANSFER IS TO THE OTS
	IF .CURTFR EQL IHDACTIV[IHA$L_TFRADR2]			! AND UPDATE THE POINTER FOR THE
	THEN CURTFR = IHDACTIV[IHA$L_TFRADR3]			! USER TRANSFER ADDRESS TO BE THE SECOND
	ELSE CURTFR = IHDACTIV[IHA$L_TFRADR2];			! OR THIRD DEPENDING ON PRESENCE OF DEBUGGER
     END;							! BEFORE THE OTS
IMAGEHEADER[IHD$V_LNKNOTFR] = TRUE;				! ASSUME NO TRANSFER ADDRESS
IF .LNK$GL_TFRPSC NEQ 0						! FINALLY IF THE USER HAD A
THEN BEGIN							! A TRANSFER ADDRESS
	IMAGEHEADER[IHD$V_LNKNOTFR] = FALSE;			! CLEAR NO TRANSFER ADDRESS FLAG
	IF NOT (.LNK$GL_CTLMSK[LNK$V_SYS]			! IF NOT A SYSTEM IMAGE
		 AND NOT .LNK$GL_CTLMSK[LNK$V_SYSHEADR])	!    WITH NO HEADER
	THEN .CURTFR = .LNK$GL_TFRADR				! AND IF SO INSERT IT LAST
	ELSE SIGNAL(LIN$_TFRSYS,1,				! REPORT IGNORED TRANSFER ADDRESS
			LNK$GL_IMGFIL[FDB$Q_FILENAME]);		! IN OTHER KINDS OF IMAGE
     END
ELSE IF .LNK$GL_CTLMSK[LNK$V_EXE]				! IF IT IS AN EXECUTABLE
THEN SIGNAL(LIN$_USRTFR,1,					! IMAGE REPORT THE ERROR
		LNK$GL_IMGFIL[FDB$Q_FILENAME]);			! WHEN TRANSFER ADDRESS IS MISSING
SYMDBGDATA = .IMAGEHEADER + .IMAGEHEADER[IHD$W_SYMDBGOFF];	! POINT TO STB AND DBG DATA AREA
IF (SYMDBGDATA[IHS$W_DSTBLKS] = .LNK$GW_DSTBLKS) NEQ 0		! IF A DST WAS WRITTEN
THEN SYMDBGDATA[IHS$L_DSTVBN] = .LNK$GW_DSTVBN;			! SET BLOCK COUNT AND ITS VBN
IF (SYMDBGDATA[IHS$W_GSTRECS] = .LNK$GW_GSTRECS) NEQ 0		! IF A GST WAS WRITTEN
THEN SYMDBGDATA[IHS$L_GSTVBN] = .LNK$GW_GSTVBN;			! THEN SET RECORD COUNT AND VBN IN HEADER
!
! THE MAJOR AND MINOR IDENTS OF THE HEADER RECORD ARE USED
! BY IMAGE ACTIVATOR AS FOLLOWS:-
!			MAJOR ID - MATCH REQUIRED ALWAYS
!			MINOR ID - MORE RECENT (GREATER THAN
!			OR EQUAL) THAN IMAGE ACTIVATOR'S
!			VERSION ARE PERMITTED.
!
IMAGEHEADER[IHD$W_MAJORID] = IHD$K_MAJORID;				! MAJOR IDENT
IMAGEHEADER[IHD$W_MINORID] = IHD$K_MINORID;				! MINOR IDENT
IMGIDAREA = .IMAGEHEADER + .IMAGEHEADER[IHD$W_IMGIDOFF];		! POINT TO IMAGE ID AREA
LNK$GT_IMGNAM[0] = MINU(SYM$C_SHORTNAME,.LNK$GT_IMGNAM[0]);		! TRIM NAME LENGTH TO MAX ALLOWED IN HEADER
LNK$GT_IMGID[0] = MINU(SYM$C_SHORTNAME,.LNK$GT_IMGID[0]);		! ...
CH$MOVE(.LNK$GT_IMGNAM[0]+1,LNK$GT_IMGNAM[0],IMGIDAREA[IHI$T_IMGNAM]);	! MOVE IN THE IMAGE NAME
CH$MOVE(.LNK$GT_IMGID[0]+1,LNK$GT_IMGID[0],IMGIDAREA[IHI$T_IMGID]);	! MOVE IN THE IMAGE IDENTIFICATION
(IMGIDAREA[IHI$Q_LINKTIME])<0,32,0> = .LNK$GQ_ALOSTIM[0];		! THE TIME OF LINK IS THAT AT WHICH
IMGIDAREA[IHI$Q_LINKTIME] + 4 = .LNK$GQ_ALOSTIM[1];			! MEMORY ALLOCATION BEGAN
(IMGIDAREA[IHI$T_LINKID])<0,8,0> = LID$C_SIZE + 1;			! INSERT THE LENGTH OF LINKER ID
IMGIDAREA[IHI$T_LINKID] + 1 = .LNK$AW_VERSION[LID$W_MAJOR];		! FOLLOWED BY THE MAJOR ID
IMGIDAREA[IHI$T_LINKID] + 3 = %C'-';					! SEPARETED BY A HYPHEN
IMGIDAREA[IHI$T_LINKID] + 4 = .LNK$AW_VERSION[LID$W_MINOR];		! FROM THE MINOR ID
!
! FINALLY WRITE OUT THE WHOLE HEADER.
!
IF WRITESECTION(.LNK$GW_HDRBLKS,1,.HEADERDESC[0])		! IF SUCCESSFULLY WRITTEN TO VBN 1
THEN LNK$CLOSIMGFIL();						! CLOSE THE FILE
RETURN;
END;

GLOBAL ROUTINE LNK$CLOSIMGFIL : NOVALUE =
BEGIN
!
!	ROUTINE TO CLOSE THE IMAGE FILE
!
LOCAL	ERRORCODE,
	IMAGEFAB : BLOCK[FAB$C_BLN,BYTE];
!
BIND AUXFNB = LNK$GL_IMGFIL[FDB$T_AUXFNB] : BLOCK[NAM$C_BLN,BYTE];	! AUXILIARY FILENAME BLOCK
!
IF .LNK$GW_IMGIFI EQL 0					! IF NO IMAGE RETURN NOW
    THEN RETURN;

$FAB_INIT(FAB=IMAGEFAB,					! SET UP FAB TO CLOSE FILE
	NAM=AUXFNB,					! SET POINTER TO NAM
	FOP=TEF);					! SET TO TRUNCATE TO END OF FILE
IMAGEFAB[FAB$W_IFI] = .LNK$GW_IMGIFI;			! JAM THE SAVED IFI
IF NOT .LNK$GL_CTLMSK[LNK$V_IMAGE]			! IF IMAGE DISABLED
    THEN IMAGEFAB[FAB$V_DLT] = TRUE;			!  THEN DELETE THE FILE
IF NOT(ERRORCODE = $CLOSE(FAB=IMAGEFAB))		! DO IT AND IF AN ERROR
THEN BEGIN
	SIGNAL(LIN$_CLOSEOUT,1,LNK$GL_IMGFIL[FDB$Q_FILENAME],
		.ERRORCODE,IMAGEFAB[FAB$L_STV]);
     END;
LNK$GW_IMGIFI = 0;					! CLEAR THE ID

RETURN TRUE						! AND ALL DONE
END;

END ELUDOM
