MODULE LNK_PSCTSERINS (IDENT='V03-000',
			ADDRESSING_MODE(EXTERNAL=GENERAL,
					NONEXTERNAL=LONG_RELATIVE)
			) =

BEGIN
!
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
!
!
!
!++
!
! MODULE: LNK_PSCTSERINS
!
! FACILITY: LINKER
!
! ABSTRACT: SEARCH AND INSERT ROUTINES FOR P-SECTIONS
!
! HISTORY:
!
!	VERSION: X01.00
!
!	AUTHOR: T.J. PORTER 16-MAR-77
!
! MODIFIED BY:
!
!	V03-005	BLS0111		Benn Schreiber		21-Nov-1981
!		Ignore deleted global psects
!
!	V03-004	BLS0100		Benn Schreiber		 7-Nov-1981
!		Don't zero name field on allocation
!
!	V03-003	BLS0035		Benn Schreiber		13-Jan-1981
!		65K psects
!
!	V03-002	BLS0025		Benn Schreiber		28-Nov-1980
!		Add pointer from psect descriptor to cluster descriptor.
!
!	V03-001	BLS0007		Benn Schreiber,		3-Jun-1980
!		Convert to MDL data structures
!--

!
!++
!
! FUNCTIONAL DESCRIPTION:
!
! PROGRAM SECTIONS ARE REPRESENTED BY DESCRIPTORS (NAMES OF
! FORM PSC$X_YY...) IN A SINGLY LINKED, LEXICALLY ORDERED
! LIST. THE LIST HEAD IS IN THE CLUSTER DESCRIPTOR.
!
! THIS MODULE CONTAINS THE ROUTINES TO INSERT A P-SECTION
! IN SUCH A LIST AS WELL AS TO FIND P-SECTIONS. AN INSERT
! OF A P-SECTION IS PRECEEDED BY A SEARCH FOR A
! P-SECTION OF THE SAME NAME. IF NOT FOUND, THEN THE DESCRIPTOR IS
! ALLOCATED IN THE CORRECT PLACE IN THE CURRENT CLUSTER'S LIST.
!
! THERE ARE TWO WAYS OF SEARCHING FOR P-SECTION
!		(1) BY NAME (LNK$FNDPSCNAM)
!		(2) BY ATTRIBUTE MASK (LNK$FNDPSCMSK)
!
! THE CALLING SEQUENCES ARE AS FOLLOWS:
!
!		LNK$FNDPSCNAM (PSCTNAME,GPSBITS,SCOPE,PSCTDESC)
!		LNK$FNDPSCMSK (MASK,MATCH,PSCTDESC)
!
! WHERE:
!	PSCTNAME	=	ADDRESS OF COUNTED ASCII STRING
!				WHICH IS THE P-SECTION NAME
!	PSCTDESC	=	ADDRESS OF LONGWORD TO RECEIVE
!				THE P-SECTION DESCRIPTOR ADDRESS IF
!				P-SECTION FOUND OR INSERTED.
!	GPSBITS		=	PSECT ATTRIBUTES
!	SCOPE		=	0 FOR SEARCH OF CURRENT CLUSTER ONLY
!				ELSE ALL DOWN TO CURRENT.
!	MASK		=	MASK OF FLAG BITS TO BE EXTRACTED
!				(FOR PURPOSES OF COMPARISON) FROM
!				THE P-SECTION DESCRIPTOR FLAGS.
!	MATCH		=	THE PATTERN OF FLAGS TO BE MATCHED
!				AFTER ADDING THE P-SECTION
!				FLAGS WITH THE MASK.
!			I.E., SEARCH BY MASK IS SUCCESSFUL IF (P-SECTION
!			FLAGS) .AND. (MASK) = MATCH.
!	ROUTINES HAVE THE VALUE TRUE IF P-SECTION IS
!	FOUND TO EXIST BEFORE THE CALL, FALSE OTHERWISE.
!
!--
!
LIBRARY
	'STARLETL32';					! SYSTEM DATA STRUCTURES
REQUIRE
	'PREFIX';					! MACROS ETC.
LIBRARY
	'DATBAS';					! DATA BASE DEFINITIONS
!
GLOBAL
	LNK$GL_PSCALLOC : VECTOR[2];			! LENGTH AND ADDRESS OF PSECT DESC ALLOCATION POOL

EXTERNAL LITERAL
	PSC$C_ALLOBLK : BYTLIT;				! NUMBER OF PAGES TO PREALLOCATE

EXTERNAL ROUTINE
	LIB$INSERT_TREE,				! LOOKUP/INSERT IN BINARY TREE
	LIB$LOOKUP_TREE,				! LOOKUP IN BINARY TREE
	LNK$ALLOBLK;					! DYNAMIC MEMORY ALLOCATOR
!
EXTERNAL
	LNK$GW_NMODULES : WORD,				! NUMBER OF MODULES
	LNK$GL_CTLMSK : BLOCK[,BYTE],
	LNK$GL_CLULST : VECTOR[2],			! CLUSTER DESCRIPTOR LISTHEAD
	LNK$GL_CURCLU;					! CURRENT CLUSTER DESCRIPTOR

EXTERNAL LITERAL
	LIB$_NORMAL;					! NORMAL RETURN FROM LIB$INSERT_TREE

GLOBAL ROUTINE LNK$COMPARE_PSCNOD (PSECTNAME, CURRENTNODE) =
!
! LOCAL ROUTINE TO COMPARE PSECT NAME WITH CURRENT NODE.  CALLED BY
! LIB$INSERT_TREE.  THIS ROUTINE DIFFERES FROM COMPARE_PSECTS IN THAT
! CURRENTNODE IS A POINTER TO A NODE WHICH POINTS TO A PSECT DESCRIPTOR.
!
BEGIN

MAP
    PSECTNAME : REF VECTOR[,BYTE],
    CURRENTNODE : REF BLOCK[,BYTE];

LOCAL
    THISPSECT : REF BLOCK[,BYTE];

THISPSECT = .CURRENTNODE[NODE$L_PTR];				! PICK UP POINTER TO PSECT DESCRIPTOR
RETURN CH$COMPARE(.PSECTNAME[0],PSECTNAME[1],
		.THISPSECT[PSC$B_NAMLNG],THISPSECT[PSC$T_NAME])

END;

GLOBAL ROUTINE LNK$FNDPSCNAM(PSCTNAME,GPSBITS,SCOPE,PSCTDESC)=
BEGIN
!
! FIND P-SECTION BY NAME. PSCTNAME IS THE ADDRESS OF THE ASCIC
! STRING P-SECTION NAME. PSCTDESC IS THE PLACE TO  PUT THE
! FOUND OR ALLOCATED DESCRIPTOR. IF SCOPE IS NON ZERO, ALL CLUSTERS
! ARE SEARCHED.  IF PSECT IS NOT FOUND, IT IS ENTERED IN CURRENT CLUSTER.
! GPSBITS ARE THE PSECT ATTRIBUTES FROM THE PSECT DEFINITION IN THE GSD.
!

ROUTINE COMPARE_PSECTS (PSECTNAME, CURRENTNODE) =
!
! LOCAL ROUTINE TO COMPARE PSECT NAME WITH CURRENT DESCRIPTOR.  CALLED BY
! LIB$INSERT_TREE
!
BEGIN

MAP
    PSECTNAME : REF VECTOR[,BYTE],
    CURRENTNODE : REF BLOCK[,BYTE];

RETURN CH$COMPARE(.PSECTNAME[0],PSECTNAME[1],
		.CURRENTNODE[PSC$B_NAMLNG],CURRENTNODE[PSC$T_NAME])

END;

ROUTINE ALLOC_PSECT (PSECTNAME,RETADR) =
BEGIN
!
! LOCAL ROUTINE TO ALLOCATE PSECT DESCRIPTOR.  CALLED BY LIB$INSERT_NODE
!
MAP
    PSECTNAME : REF VECTOR[,BYTE];

LOCAL
    BLOCKSIZE;

BLOCKSIZE = PSC$C_SIZE+.PSECTNAME[0];			! COMPUTE SIZE OF BLOCK
IF .LNK$GL_PSCALLOC[0] LEQU .BLOCKSIZE			! IF NO ROOM IN THIS PREALLOCATED BLOCK
THEN BEGIN						!  THEN ALLOCATE ANOTHER ONE
    LNK$ALLOBLK(PSC$C_ALLOBLK*512,LNK$GL_PSCALLOC[1]);
    LNK$GL_PSCALLOC[0] = PSC$C_ALLOBLK*512;
    END;

.RETADR = .LNK$GL_PSCALLOC[1];				! RETURN BLOCK ADDRESS
CH$FILL(0,PSC$C_SIZE,.LNK$GL_PSCALLOC[1]);		! ZERO THE BLOCK
LNK$GL_PSCALLOC[0] = .LNK$GL_PSCALLOC[0] - .BLOCKSIZE;	! UPDATE SIZE AND ADDRESS IN PREALLOCATED BLOCK
LNK$GL_PSCALLOC[1] = .LNK$GL_PSCALLOC[1] + .BLOCKSIZE;

RETURN TRUE
END;

ROUTINE ALLOC_NODE (PSECTNAME,RETADR,PSECTDESC) =
BEGIN
!
! LOCAL ROUTINE TO ALLOCATE A NODE WHICH WILL POINT TO A PSECT
! DESCRIPTOR
!
MAP
    PSECTNAME : REF VECTOR[,BYTE];

LOCAL
    BLOCKADDR : REF BLOCK[,BYTE];

IF .LNK$GL_PSCALLOC[0] LEQU NODE$C_LONG			! IF NOT ROOM IN CURRENT PREALLOCATED BLOCK
THEN BEGIN						!  THEN ALLOCATE ANOTHER BLOCK
    LNK$ALLOBLK(PSC$C_ALLOBLK*512,LNK$GL_PSCALLOC[1]);
    LNK$GL_PSCALLOC[0] = PSC$C_ALLOBLK*512;
    END;

BLOCKADDR = .LNK$GL_PSCALLOC[1];			! GET ADDRESS OF NEW BLOCK
.RETADR = .BLOCKADDR;					! RETURN ADDRESS TO CALLER
BLOCKADDR[NODE$L_PTR] = .PSECTDESC;			! POINT NODE TO PSECT DESCRIPTOR
LNK$GL_PSCALLOC[0] = .LNK$GL_PSCALLOC[0] - NODE$C_LONG;	! UPDATE POINTER AND COUNTER FOR PREALLOCATED BLOCK
LNK$GL_PSCALLOC[1] = .LNK$GL_PSCALLOC[1] + NODE$C_LONG;

RETURN TRUE
END;

!
! MAIN BODY OF LNK$FNDPSCNAM
!
MAP
	PSCTNAME : REF VECTOR[,BYTE];				! FOR ASCIC STRING
LOCAL
	FOUND,
	NDESC : REF BLOCK[,BYTE],
	PDESC : REF BLOCK[,BYTE],
	CLUSTER : REF BLOCK[,BYTE];				! CLUSTER DESCRIPTOR
!
IF .SCOPE NEQ 0							! IF GLOBAL SEARCH SCOPE
    THEN CLUSTER = LNK$GL_CLULST[0]				! START AT TOP OF CLUSTER LIST
    ELSE CLUSTER = LNK$GL_CURCLU;				! IF LOCAL START AT CURRENT CLUSTER

WHILE (CLUSTER = .CLUSTER[CLU$L_NXTCLU]) NEQ 0			! MOVE ON TO NEXT CLUSTER IN LIST
DO BEGIN
	IF .CLUSTER EQL .LNK$GL_CURCLU				! IF THIS IS CURRENT CLUSTER
	    AND .SCOPE EQL 0					!  AND PSECT IS NON-GLOBAL
	THEN BEGIN
	    FOUND = LIB$INSERT_TREE(CLUSTER[CLU$L_LPSLST],.PSCTNAME,%REF(0),
				COMPARE_PSECTS,ALLOC_PSECT,PDESC);
	    !
	    ! FILL IN THE ALLOCATED NODE
	    !
	    IF .FOUND EQL LIB$_NORMAL
	    THEN BEGIN
		CH$MOVE(.PSCTNAME[0]+1,PSCTNAME[0],PDESC[PSC$B_NAMLNG]); ! COPY IN THE NAME
		PDESC[PSC$L_LSTMPC] = PDESC[PSC$L_MPCLST]; 		! INIT LAST ENTRY POINTER
		PDESC[PSC$L_CLUDSC] = .LNK$GL_CURCLU;			! SET CLUSTER DESCRIPTOR ADDRESS
		PDESC[PSC$L_OMDNUM] = .LNK$GW_NMODULES;			! SET DEFINER MODULE NUMBER
		PDESC[PSC$B_ALIGN] = -1;				! FLAG NO ALIGNMENT SET
		IF (.GPSBITS AND GPS$M_GBL) NEQ 0			! IF THIS IS A GLOBAL PSECT
		    THEN LIB$INSERT_TREE(CLUSTER[CLU$L_GPSLST],		!  THEN INSERT INTO GLOBAL PSECT LIST ALSO
					.PSCTNAME,%REF(0),
					LNK$COMPARE_PSCNOD,ALLOC_NODE,NDESC,.PDESC);
		END;
	    .PSCTDESC = .PDESC;						! RETURN ADDRESS TO CALLER
	    RETURN .FOUND
	    END
	ELSE IF LIB$LOOKUP_TREE(CLUSTER[CLU$L_GPSLST],.PSCTNAME,	! GLOBAL PSECT, SO LOOK IN GLOBAL PSECT LIST
					LNK$COMPARE_PSCNOD,PDESC)
		AND NOT (PDESC = .PDESC[NODE$L_PTR];			! GET PSECT DESCRIPTOR ADDRESS
			.PDESC[PSC$V_DELETED])				! TEST IF PSECT HAS BEEN DELETED
		THEN BEGIN
		    .PSCTDESC = .PDESC;					! FOUND, SO RETURN TO CALLER
		    RETURN TRUE;
		    END;
   END;
!
! PSECT WAS NOT FOUND IN ANY CLUSTER, AND IF WE GOT HERE IT MUST HAVE BEEN A GLOBAL
! PSECT.  CALL LNK$FNDPSCNAM AGAIN WITH LOCAL SCOPE TO ENTER IN CURRENT CLUSTER.
!
RETURN LNK$FNDPSCNAM (.PSCTNAME, .GPSBITS, 0, .PSCTDESC)		! CALL WITH LOCAL SCOPE TO ENTER IN CURRENT CLUSTER

END;									! OF LNK$FNDPSCNAM

GLOBAL ROUTINE LNK$FNDPSCMSK(MASK,MATCH,ACTION_ROUTINE) =
BEGIN
!
! FIND NEXT P-SECTION (IN CURRENT CLUSTER) WHOSE ATTRIBUTES
! HAVE A PARTICULAR VALUE (MATCH) AFTER EXTRACTING
! WITH MASK.
!
OWN
	PREVENTRY : REF BLOCK[,BYTE],			! PREVIOUS ENTRY
	PREVMASK,					! MASK ON LAST CALL
	PREVMATCH;					! MATCH ON LAST CALL
!
MAP
	LNK$GL_CURCLU : REF BLOCK[,BYTE];		! CHANGE ATTRIBUTES
!
LOCAL
	CURENTRY : REF BLOCK[,BYTE];			! CURRENT ENTRY BEING EXAMINED
!
IF .PREVENTRY EQL 0					! IF FIRST TIME IN
OR .MASK NEQ .PREVMASK					! OR A NEW SEARCH
OR .MATCH NEQ .PREVMATCH				! PATTERN
THEN BEGIN						! START AT THE BEGINNING OF THE CORRECT LIST
	PREVENTRY = .LNK$GL_CURCLU[CLU$L_LPSLST];
	PREVMASK  = .MASK;				! RESET MASK AND
	PREVMATCH = .MATCH;				! MATCH VALUES.
	END;

IF (CURENTRY = .PREVENTRY) EQL 0			! IF NO PSECTS AT ALL
    THEN RETURN TRUE;					!  THEN ALL DONE
PREVENTRY = .PREVENTRY[PSC$L_LEFT];			! PROCESS LEFT SUBTREE
IF .PREVENTRY NEQ 0					! IF THERE IS A LEFT SUBTREE
    THEN LNK$FNDPSCMSK(.MASK,.MATCH,.ACTION_ROUTINE);
PREVENTRY = .CURENTRY;					! PROCESS CURRENT NODE
IF (.CURENTRY[PSC$W_FLAGS] AND .PREVMASK) EQL .PREVMATCH ! IF THIS PSECT IS CORECT
    AND NOT .CURENTRY[PSC$V_DELETED]			!  AND IT HAS NOT BEEN DELETED
    THEN (.ACTION_ROUTINE)(.CURENTRY);			! CALL ROUTINE FOR CURRENT ENTRY
PREVENTRY = .CURENTRY[PSC$L_RIGHT];			! PROCESS RIGHT SUBTREE
IF .PREVENTRY NEQ 0
    THEN LNK$FNDPSCMSK(.MASK,.MATCH,.ACTION_ROUTINE);	! PROCESS RIGHT SUBTREE IF PRESENT
PREVENTRY = .CURENTRY;					! RESTORE ENTRY
RETURN TRUE;
END;
END ELUDOM
