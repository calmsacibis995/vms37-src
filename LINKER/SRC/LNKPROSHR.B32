MODULE LNK_PROCSHRIM (	! PROCESS SHAREABLE IMAGES ON PASS 1
		IDENT = 'V03-000',
		ADDRESSING_MODE(EXTERNAL=GENERAL,
				NONEXTERNAL=LONG_RELATIVE)
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!++
! FACILITY:	LINKER
!
! ABSTRACT:	THIS MODULE CONTAINS THE ROUTINES TO READ SHAREABLE
!			IMAGES ON PASS 1.
!
!
! ENVIRONMENT:	VMS NATIVE MODE
!
! AUTHOR:	T.J. PORTER, CREATION DATE: 15-DEC-77
!
! MODIFIED BY:
!
!	V03-012	BLS0104		Benn Schreiber		13-Nov-1981
!		Set FIXUPVEC in ISD if section is fixup section
!
!	V03-011	BLS0088		Benn Schreiber		12-Oct-1981
!		Save vpg of first isect for isect relocation
!
!	V03-010	BLS0079		Benn Schreiber		14-Sep-1981
!		Don't set CLU$V_INTCLU here, since it is set in
!		LNK$ADDIMAGE
!
!	V03-009	BLS0074		Benn Schreiber		29-Aug-1981
!		Enhancements for based shareable images
!
!	V03-008	BLS0050		Benn Schreiber		23-Mar-1981
!		Independent shareable images
!
!	V03-007	BLS0049		Benn Schreiber		22-May-1981
!		Allow positioning PIC shareable images via CLUSTER=
!		option.
!
!	V03-006	BLS0048		Benn Schreiber		14-Mar-1981
!		Issue warning if non-pic image creating shr image.
!
!	V03-005	BLS0042		Benn Schreiber		25-Feb-1981
!		Catch deferred reloc and issue error message
!
!	V03-004	BLS0024		Benn Schreiber		3-Feb-1981
!		Rework of ISD order handling
!
!	V03-003	BLS0035		Benn Schreiber		19-Jan-1981
!		65K psects
!
!	V03-002	BLS0029		Benn Schreiber		30-Dec-1980
!		Check GSMATCH against GSMATCH found in library for
!		libraries of shareable images.
!
!	V03-001	BLS0007		Benn Schreiber,		3-Jun-1980
!		Convert to MDL data structures.
!--

!
! TABLE OF CONTENTS:
!
FORWARD ROUTINE
	READNEXTBLOCK;				! READS THE NEXT HEADER BLOCK OF IMAGE
!
! INCLUDE FILES:
!
LIBRARY
	'LIBL32';				! VMS SYSTEM STRUCTURE DEFINITIONS
REQUIRE
	'PREFIX';				! USEFUL GENERAL MACROS
LIBRARY
	'DATBAS';				! INTERNAL DATA BASE DEFINITIONS
REQUIRE
	'ISGENC';				! IMAGE SECTION PARAMETERS
!
! MACROS:
!
!	NONE
!
! EQUATED SYMBOLS:
!
!	NONE
!
! EXTERNAL REFERENCES:
!
EXTERNAL ROUTINE
	LNK$ADDIMAGE,				! ADD ANOTHER SHAREABLE IMAGE TO BE PROCESSED
	LNK$ALLOBLK : NOVALUE, 			! DYNAMIC MEMORY ALLOCATOR
	LNK$ALLOCLUSTER,			! ALLOCATE CLUSTER DESCRIPTOR
	LNK$CLOSCURFIL : NOVALUE,		! CLOSE CURRENT INPUT FILE
	LNK$POINTOBJ : NOVALUE,			! POINTS TO NEW PLACE IN FILE
	LNK$PROCSOBJ;				! PROCESSES OBJECT MODULES (I.E. THE GST)

EXTERNAL LITERAL
	LIN$_BADIMGHDR,				! BAD IMAGE HEADER ERROR MESSAGE
	LIN$_BASSHRBEL,				! BASED SHAREABLE IMAGE BELOW BASE=
	LIN$_CONFBASADR,			! CONFLICTING BASE ADDRESSES FOR SHR IMGS
	LIN$_IDMISMCH,				! GSMATCH MISMATCH WITH SHR IMG STB LIBRARY
	LIN$_IMGBASED,				! ATTEMPT TO RE-BASE A NON-PIC IMAGE
	LIN$_NOIMGFIL,				! NO IMAGE FILE CREATED
	LIN$_NONPICIMG,				! SHAREABLE IMAGE IS NON-PIC
	LIN$_RELINK,				! RELINK DUE TO COPYALWAYS SECTION
	LIN$_READERR;				! READ ERROR

EXTERNAL
	LNK$GL_SHRCLSTRS,			! COUNT OF NUMBER OF SHAREABLE IMAGE CLUSTERS (PIC AND NON-PIC)
	LNK$AL_RAB : BLOCK[,BYTE],		! RAB FOR OPEN IMAGE FILE
	LNK$GW_NISECTS : WORD,			! IMAGE SECTION ACCUMULATOR
	LNK$GW_SHRISCTS : WORD,			! NUMBER OF SHAREABLE IMAGE ISECTS
	LNK$GB_PASS : BYTE,			! CURRENT PASS
	LNK$GL_CURFIL : REF BLOCK[,BYTE],	! CURRENT FILE POINTER
	LNK$GL_CURCLU : REF BLOCK[,BYTE],	! CURRENT CLUSTER DESCRIPTOR
	LNK$GL_DEFCLU : BLOCK[,BYTE],		! DEFAULT_CLUSTER DESCRIPTOR
	LNK$GL_LASTCLU : REF BLOCK[,BYTE],	! POINTER TO LAST CLUSTER DESCRIPTOR
	LNK$GL_CTLMSK : BLOCK[,BYTE],		! CONTROL FLAGS
	LNK$GL_OBJRECS;				! COUNT OF OBJECT RECORDS
!
! MODULE OWN STORAGE:
!
GLOBAL
	LNK$GL_GSBUFDSC : VECTOR[3],		! BUFFER DESCRIPTOR FOR COPIED GLOBAL SECTIONS
	LNK$GL_IMGRECS;				! COUNT OF IMAGE RECORDS
OWN
	CURISDSEQ : VECTOR[4,BYTE] INITIAL(
				%ASCII '_000'),	! SUFFIX TO SCLUSTER NAME GIVING GBL ISD NAME
	HDRBLKCNT,				! NUMBER REMAINING HEADER BLOCKS
	HEADERBLOCK;				! CURRENT HEADER VBN

GLOBAL ROUTINE LNK$PROCSHRIM(MODRFA)  =	!
BEGIN
!++
! FUNCTIONAL DESCRIPTION:
!			THIS ROUTINE IS CALLED TO PROCESS SHAREABLE IMAGES ON PASS
!	ONE OF THE LINK. IT READS AND VALIDATES EVERY BLOCK OF THE IMAGE HEADER
!	BUILDING THE LIST OF IMAGE SECTION DESCRIPTORS. AFTER COMPLETING THE HEADER
!	IT SETS THE RAB POINTING TO THE SYMBOL TABLE PART OF THE IMAGE FILE AND
!	CALLS LNK$PROCSOBJ TO DO THE PASS ONE OBJECT MODULE PROCESSING
!	OF THE SYMBOL TABLE.
!			THE SYMBOL TABLE OF A SHAREABLE IMAGE CONTAINS ALL THE UNIVERSAL
!	SYMBOLS DEFINED FOR THE IMAGE AND IS IN THE OBJECT MODULE FORMAT.
!
! FORMAL PARAMETERS:
!	MODRFA IS A POINTER TO THE 6 BYTE RFA OF THE SHAREABLE IMAGE IF
!	IT IS IN A LIBRARY. IF NOT A LIBRARY SHAREABLE IMAGE THE ARGUMENT
!	DOES NOT EXIST.
!
! IMPLICIT INPUTS:
!	SEE ABOVE EXTERNAL DECLARATIONS.
!	IN ADDITION THE FILE CONTAINING THE IMAGE IS ALREADY OPEN
!	FOR BLOCK READ OPERATIONS.
!
! IMPLICIT OUTPUTS:
!	SEE ABOVE GLOBAL DECLARATIONS.
!	IN ADDITION ALL IMAGE SECTIONS FOUND IN THIS SHAREABLE IMAGE
!	ARE APPENDED TO THE LIST AND THE GST HAS BEEN PROCESSED AS AN OBJECT
!	MODULE. THAT IS ALL UNIVERSAL SYMBOLS ARE IN THE LINKER SYMBOL TABLE.
!
! ROUTINE VALUE:
!	RETURNS VALUE TRUE IF SUCCESSFULLY PROCESSED, ELSE FALSE
!
! SIDE EFFECTS:
!	THE ROUTINE DOES NOT RETURN IF A FATAL ERROR IS DETECTED.
!
!--
!
BUILTIN
	ACTUALCOUNT;						! GETS COUNT OF ARGUMENTS

LOCAL	NXTISDOFF,						! OFFSET TO NEXT ISD
	BLOCKOFFSET,						! OFFSET IN FILE TO FIRST HEADER BLOCK
	ISECTIDENT,						! MAJOR AND MINOR ID FROM HEADER
	FIRSTISDVPG,						! VPG OF FIRST ISECT
	SYMDBGDATDSC : REF BLOCK[,BYTE],			! POINTER TO SYMBOL TABLE DESCRIPTOR
	GSTRECS,						! NUMBER OF RECORDS IN SYMBOL TABLE
	OWNCLU : REF BLOCK[,BYTE],				! POINTER TO OWNING CLUSTER DESCRIPTOR
	OWNFDB : REF BLOCK[,BYTE],				!  AND IT'S FILE DESCRIPTOR BLOCK
	CLUDESC : REF BLOCK[,BYTE],				! POINTER TO CREATED CLUSTER DESCRIPTOR
	CURHDRISD : REF BLOCK[,BYTE],				! POINTER TO CURRENT ISD IN HEADER
	CURISD : REF BLOCK[,BYTE],				! POINTER TO CURRENT ISD BEING BUILT
	NEWHDRISD : REF BLOCK[,BYTE],				! POINTER TO HEADER PART OF CURRENT ISD BEING BUILT
	FIRSTISD : REF BLOCK[,BYTE],				! POINTER TO FIRST ISECT IN CLUSTER
	GSTVBN : VECTOR[2,LONG],				! RFA OF GST
	IAFVA,							! RELATIVE VA OF FIXUP SECTION
	SAVERECOUNT,						! SAVED RECORD COUNT WHILE IN OBJPS1
	MAXISDVBN;						! LAST IMAGE VBN + 1

MAP	MODRFA : REF BLOCK[,BYTE];				! POINTER TO BLOCK

BIND
	HEADER = LNK$AL_RAB[RAB$L_UBF] : REF BLOCK[,BYTE];	! POINTER TO BLOCK BUFFER

LNK$GL_SHRCLSTRS = .LNK$GL_SHRCLSTRS + 1;			! COUNT THIS SHAREABLE IMAGE CLUSTER
CLUDESC = 0;							! NO CREATED CLUSTER YET
IF ACTUALCOUNT() EQL 0						! IF CALLED WITH NO ARGUMENTS
    THEN BLOCKOFFSET = 0					! HEADER AT START OF FILE
    ELSE BLOCKOFFSET = .MODRFA[RFA$L_VBN] - 1;			! OTHERWISE GET OFFSET
HEADERBLOCK = .BLOCKOFFSET;					! AND SET FOR FIRST BLOCK READ
HDRBLKCNT = 1;							! MUST BE AT LEAST ONE BLOCK
NXTISDOFF = -1;							! NEXT ISD IS ON NEXT BLOCK
MAXISDVBN = 0;							! RESET LAST BLOCK OF IMAGE
CH$FILL(%C'0',3,CURISDSEQ[1]);					! INITIALIZE THE ISD NAME SUFFIX
!
WHILE .NXTISDOFF EQL -1							! WHILE THERE ARE MORE
DO BEGIN								! HEADER BLOCKS
    IF NOT READNEXTBLOCK()						! GET THE NEXT ONE
	THEN SIGNAL_STOP(LIN$_BADIMGHDR,1,				! AND IF UNSUCCESSFUL, FATAL IMAGE
			LNK$GL_CURFIL[FDB$Q_FILENAME]);
    IF .HEADERBLOCK EQL (.BLOCKOFFSET + 1)				! IF THE FIRST
    THEN BEGIN								! HAVE SOME VALIDATION TO DO
!
! VALIDATE IMAGE HEADER
!
	IF .HEADER[IHD$B_IMGTYPE] NEQ IHD$K_SHR				! CHECK IT IS A SHAREABLE IMAGE
	    OR .HEADER[IHD$W_MAJORID] NEQ IHD$K_MAJORID			! MAJOR HEADER ID MUST MATCH
	    OR (.(HEADER[IHD$W_MINORID])<0,8,0> EQL (IHD$K_MINORID AND %X'FF')
		AND .(HEADER[IHD$W_MINORID])<8,8,0> GTRU (IHD$K_MINORID AND %X'FF00')/256)
	    OR .HEADER[IHD$W_SIZE] GTRU MAXU((.HEADER[IHD$W_PATCHOFF] 	! THE HEADER FIXED PART
				+ IHP$K_LENGTH),IHD$K_MAXLENGTH)	! MUST BE LESS THAN A BLOCK AND MUST
	    OR (HDRBLKCNT = .HEADER[IHD$B_HDRBLKCNT] - 1) LSS 0		! CONTAIN PATCH AREA. 0 TO
	    OR (SYMDBGDATDSC = .HEADER + .HEADER[IHD$W_SYMDBGOFF])	! 127 MORE BLOCKS. GET THE
				GEQU (.HEADER + .HEADER[IHD$W_SIZE])	! GST DESCRIPTOR WHICH MUST BE CONTAINED
	    OR (GSTRECS = .SYMDBGDATDSC[IHS$W_GSTRECS]) LSSU 3		! IN HEADER. MUST BE AT LEAST THREE RECORDS
	    OR (GSTVBN[0] = .SYMDBGDATDSC[IHS$L_GSTVBN]) LEQU		! AND MUST BE BEYOND THE HEADER BLOCKS
						(.HDRBLKCNT + 2)
	    THEN SIGNAL_STOP(LIN$_BADIMGHDR,1,				! ANY ABOVE NOT TRUE, FATAL IMAGE
				LNK$GL_CURFIL[FDB$Q_FILENAME]);		!  HEADER ERROR
	IF NOT (LNK$GL_CURCLU[CLU$V_PIC] = .HEADER[IHD$V_PICIMG])	! EXTRACT THE PIC BIT AND IF NON-PIC
	    THEN BEGIN
		LNK$GL_CTLMSK[LNK$V_PICIMG] = FALSE;			! THIS IMAGE IS ALSO NON-PIC
		IF .LNK$GL_CURCLU[CLU$V_USRBASED]			! IF NON-PIC IMAGE BASED BY USER
		    AND NOT .LNK$GL_CURCLU[CLU$V_INTCLU]		!  (AND NOT AN INTERNALLY CREATED CLUSTER)
		THEN BEGIN
		    SIGNAL(LIN$_IMGBASED,1,				! THEN THAT'S AN ERROR, CAUSE WE CAN'T RELOCATE IT
				LNK$GL_CURFIL[FDB$Q_FILENAME]);
		    LNK$GL_CURCLU[CLU$V_USRBASED] = FALSE;
		    LNK$GL_CURCLU[CLU$L_USRBASE] = 0;
		    END;
		END
	    ELSE IF .LNK$GL_CURCLU[CLU$V_USRBASED]			! BUT IF CLUSTER BASED BY OPTION
		THEN LNK$GL_CTLMSK[LNK$V_PICIMG] = FALSE;
	IF .LNK$GL_CTLMSK[LNK$V_SHR]					! IF CREATING A SHAREABLE IMAGE
	    AND NOT .LNK$GL_CTLMSK[LNK$V_UBASED]			!  AND IMAGE NOT BASED BY USER
	    AND NOT .LNK$GL_CURCLU[CLU$V_PIC]				!  AND THIS IMAGE JUST MADE IT NON-PIC
	    THEN SIGNAL(LIN$_NONPICIMG,1,				! THEN TELL USER ABOUT IT (INFO)
				LNK$GL_CURFIL[FDB$Q_FILENAME]);
	IF (LNK$GL_CURCLU[CLU$V_MATCHCTL] =				! EXTRACT THE GLOBAL SECTION MATCH CONTROL
					.HEADER[IHD$V_MATCHCTL]) EQL ISD$K_MATNEV
	    THEN LNK$GL_CURCLU[CLU$V_COPY] = TRUE;			! MAKING PRIVATE COPY IF MATCH NEVER
	ISECTIDENT = .HEADER[IHD$L_IDENT];				! NOW THE IDENT TO WHICH IT APPLIES
	IAFVA = 0;
	IF (.HEADER + .HEADER[IHD$W_ACTIVOFF]) GTRU HEADER[IHD$L_IAFVA]	! IF THIS IMAGE HAS FIXUP VA OFFSET
	THEN BEGIN
	    IAFVA = .HEADER[IHD$L_IAFVA];				!  THEN PICK IT UP
	    IF .IAFVA EQL 0
		THEN LNK$GL_CURCLU[CLU$V_PREFIXUP] = TRUE;		! FIXVA THERE, BUT 0, SO ASSUME NOT THERE
	    END
	ELSE LNK$GL_CURCLU[CLU$V_PREFIXUP] = TRUE;			! NO FIXUP VA, FLAG OLD IMAGE
	LNK$GL_IMGRECS = .LNK$GL_IMGRECS + .HDRBLKCNT + 1;		! COUNTER HEADER BLOCKS AS RECORDS
	CURHDRISD = .HEADER + .HEADER[IHD$W_SIZE];			! POINT TO FIRST ISD IN HEADER
!
! CHECK GSMATCH OF IMAGE AGAINST GSMATCH FOUND IN SHAREABLE IMAGE
! LIBRARY IF THIS IMAGE FOUND IN A LIBRARY
!
	IF .LNK$GL_CURCLU[CLU$L_GSMATCH] NEQ 0				! IF IMAGE WAS FOUND IN LIBRARY OF SHAREABLE IMAGES
	    AND .LNK$GL_CURCLU[CLU$L_GSMATCH] NEQ .ISECTIDENT		!  AND NOT THE SAME AS ONE IN THE IMAGE
	THEN BEGIN
	    BIND
		LIBIDENT = LNK$GL_CURCLU[CLU$L_GSMATCH] : BLOCK[,BYTE],
		IMGIDENT = ISECTIDENT : BLOCK[,BYTE];

	    SIGNAL(LIN$_IDMISMCH,6,.IMGIDENT[GMT$B_MAJORID],		! WARN THE USER THAT THERE IS AN IDENT PROBLEM
				.IMGIDENT[GMT$B_MINORID],LNK$GL_CURFIL[FDB$Q_FILENAME],
				.LIBIDENT[GMT$B_MAJORID],.LIBIDENT[GMT$B_MINORID],
				LNK$GL_CURFIL[FDB$Q_LIBNAMDSC]);
	    END;
	LNK$GL_CURCLU[CLU$L_GSMATCH] = 0;				! ZERO FIELD SINCE RE-USED IN PASS 2
	END								! ALL DONE WITH FIRST BLOCK
    ELSE CURHDRISD = .HEADER;						! OTHER BLOCKS ARE ALL ISD
!
! PROCESS IMAGE SECTION DESCRIPTORS
!
    WHILE (NXTISDOFF = .(CURHDRISD[ISD$W_SIZE])<0,16,1>) GTR 0		! WHILE MORE ISD'S ON THIS BLOCK
    DO IF .CURHDRISD[ISD$B_TYPE] NEQ ISD$K_USRSTACK			! BEGIN LOOP THAT PROCESSES EACH
    THEN BEGIN								! IGNORING STACK SECTION
	IF .CURHDRISD[ISD$V_COPYALWAY]					! IF THIS IS COPY ALWAYS SECTION
	    THEN SIGNAL_STOP(LIN$_RELINK,2,LNK$GL_CURFIL[FDB$Q_FILENAME], ! THEN ISSUE MESSAGE AND GIVE UP NOW
						LNK$GL_CURFIL[FDB$Q_FILENAME]);
	IF .CURHDRISD[ISD$V_GBL]					! IF GLOBAL ISECT
	THEN BEGIN							!  THEN CHECK FROM SAME SHAREABLE IMAGE
	    LOCAL
		FOUND,
		SHRDESC : BLOCK[DSC$C_S_BLN,BYTE];

	    BIND
		GBLNAM = CURHDRISD[ISD$T_GBLNAM] : VECTOR[,BYTE];

	    SHRDESC[DSC$W_LENGTH] = CH$FIND_CH(.GBLNAM[0],GBLNAM[1], 	! FIND LENGTH OF GLOBAL 
						%ASCII'_') - GBLNAM[1];	! SECTION NAME IN ISECT DESCRIPTOR
	    SHRDESC[DSC$A_POINTER] = GBLNAM[1];				! COMPLETE THE DESCRIPTOR OF SECTION NAME
	    IF .CLUDESC EQL 0						! IF NO CREATED CLUSTERS YET
		OR NOT CH$EQL(.SHRDESC[DSC$W_LENGTH],GBLNAM[1],		! OR THIS IS FOR A DIFFERENT CLUSTER
				.SHRDESC[DSC$W_LENGTH],CLUDESC[CLU$T_NAME])
	    THEN BEGIN
		LNK$ADDIMAGE(SHRDESC,0,CLUDESC,FOUND);			! ADD IMAGE TO THE CLUSTER LIST
		IF .CLUDESC NEQ 0
		    AND NOT .FOUND
		THEN BEGIN
		    CLUDESC[CLU$V_PREFIXUP] = .LNK$GL_CURCLU[CLU$V_PREFIXUP]; ! COPY PREFIXUP FLAG FROM PARENT CLUSTER
		    CLUDESC[CLU$L_OWNCLU] = .LNK$GL_CURCLU;		! SET OWNING CLUSTER DESCRIPTOR
		    IF NOT .LNK$GL_CURCLU[CLU$V_PIC]			! IF THIS IMAGE IS NON-PIC
		    THEN BEGIN
			CLUDESC[CLU$V_BASED] = TRUE;			! FLAG CLUSTER AS BASED
			CLUDESC[CLU$L_BASE] = (IF .CURHDRISD[ISD$V_BASED]
						THEN .CURHDRISD[ISD$V_VPG]^9
						ELSE .LNK$GL_CURCLU[CLU$L_BASE]
							+ .LNK$GL_CURCLU[CLU$L_CLUOFF]);
			LNK$GL_CURCLU[CLU$L_CLUOFF] = .LNK$GL_CURCLU[CLU$L_CLUOFF]
							+ .CURHDRISD[ISD$W_PAGCNT]*512;
			END;
		    END
		ELSE BEGIN
		    IF (.LNK$GL_CURCLU[CLU$V_BASED]			! IF THIS CLUSTER IS BASED
			    AND NOT .LNK$GL_CURCLU[CLU$V_PIC])
			OR .LNK$GL_CURCLU[CLU$V_USRBASED]
		    THEN BEGIN
	    		OWNCLU = .CLUDESC[CLU$L_OWNCLU];		! GET OWNING CLUSTER POINTER
			IF .OWNCLU NEQ 0
			    THEN LNK$GL_CURCLU[CLU$L_CLUOFF] =
					.LNK$GL_CURCLU[CLU$L_CLUOFF] + .CURHDRISD[ISD$W_PAGCNT]*512;
			IF .OWNCLU NEQ 0				! IF THERE IS AN OWNING CLUSTER
			    AND .OWNCLU[CLU$V_BASED]			!  WHICH IS ALSO BASED
			    AND .CLUDESC[CLU$L_BASE] NEQ .CURHDRISD[ISD$V_VPG]^9 ! AND WANTS THIS CLUSTER AT A DIFFERENT PLACE
			THEN BEGIN
			    OWNFDB = .OWNCLU[CLU$L_FSTFDB];		! GET FIRST FILE DESCRIPTOR BLOCK
			    SIGNAL(LIN$_CONFBASADR,5,CLUDESC[CLU$B_NAMLNG],
				.CURHDRISD[ISD$V_VPG]^9,LNK$GL_CURFIL[FDB$Q_FILENAME],
				.CLUDESC[CLU$L_BASE],OWNFDB[FDB$Q_FILENAME],LIN$_NOIMGFIL);
			    LNK$GL_CTLMSK[LNK$V_IMAGE] = FALSE;		! DON'T MAKE A NON-RUNNABLE IMAGE
			    END
			ELSE IF NOT .LNK$GL_CURCLU[CLU$V_USRBASED]
			THEN BEGIN
			    IF NOT .CLUDESC[CLU$V_BASED]		! IF CLUSTER NOT ALREADY BASED
				THEN LNK$GW_SHRISCTS = .LNK$GW_SHRISCTS - .CLUDESC[CLU$L_NISECTS];
			    CLUDESC[CLU$V_BASED] = TRUE;		! FLAG AS BASED
			    CLUDESC[CLU$L_BASE] = .CURHDRISD[ISD$V_VPG]^9;
			    END;
			END;
		    END;
		END
	    ELSE IF .LNK$GL_CURCLU[CLU$V_BASED]
		OR .LNK$GL_CURCLU[CLU$V_USRBASED]
		THEN LNK$GL_CURCLU[CLU$L_CLUOFF] = .LNK$GL_CURCLU[CLU$L_CLUOFF]
						+ .CURHDRISD[ISD$W_PAGCNT]*512;
	    END
	ELSE BEGIN
	    LNK$ALLOBLK(ISD$C_SIZE,CURISD);				! ALLOCATE A DESCRIPTOR
	    CURISD[ISL$L_NXTISD] = 0;					! CURRENT IS LAST
	    CURISD[ISL$L_BUFADR] = 0;					! NO BUFFER FOR IT YET
	    CURISD[ISL$L_BUFEND] = 0;					! ...
	    CURISD[ISL$L_CLUDSC] = .LNK$GL_CURCLU;			! SET POINTER TO CLUSTER DESCRIPTOR
	    NEWHDRISD = CURISD[ISL$T_HDRISD];				! POINT TO PART DESTINED FOR HEADER
	    CH$COPY(.CURHDRISD[ISD$W_SIZE],CURHDRISD[ISD$W_SIZE],	! COPY THE ISD FROM THE
				0,ISD$K_LENGLBL,CURISD[ISL$T_HDRISD]);	! HEADER TO DESCRIPTOR 0 FILLED
	    IF .LNK$GL_CURCLU[CLU$L_FSTISD] EQL 0			! IF THIS IS THE FIRST
	    THEN BEGIN
		IF .LNK$GL_CURCLU[CLU$V_USRBASED]			! IF BASED BY USER
		THEN BEGIN
		    IF .LNK$GL_CURCLU[CLU$V_BASED]			! IF CLUSTER IS ALSO BASED
			AND .LNK$GL_CURCLU[CLU$L_BASE] NEQ .LNK$GL_CURCLU[CLU$L_USRBASE]
		    THEN BEGIN
			SIGNAL(LIN$_CONFBASADR,5,LNK$GL_CURCLU[CLU$B_NAMLNG],
				.LNK$GL_CURCLU[CLU$L_BASE],LNK$GL_CURFIL[FDB$Q_FILENAME],
				.LNK$GL_CURCLU[CLU$L_USRBASE],$DESCRIPTOR('Options file'),LIN$_NOIMGFIL);
			LNK$GL_CTLMSK[LNK$V_IMAGE] = FALSE;
			END;
		    LNK$GL_CURCLU[CLU$L_BASE] = .LNK$GL_CURCLU[CLU$L_USRBASE];
		    LNK$GL_CURCLU[CLU$L_USRBASE] = 0;
		    LNK$GL_CURCLU[CLU$V_BASED] = TRUE;
		    END
		ELSE IF .LNK$GL_CURCLU[CLU$V_BASED]			! IF BASED DUE TO ANOTHER IMAGE BASING IT
		    AND NOT .LNK$GL_CURCLU[CLU$V_PIC]			!  AND IT TURNED OUT TO BE NON-PIC
		    THEN BEGIN
			IF .LNK$GL_CURCLU[CLU$L_BASE] NEQ .NEWHDRISD[ISD$V_VPG]^9
			THEN BEGIN
			    OWNCLU = .LNK$GL_CURCLU[CLU$L_OWNCLU];
			    OWNFDB = .OWNCLU[CLU$L_FSTFDB];
			    SIGNAL(LIN$_CONFBASADR,5,LNK$GL_CURCLU[CLU$B_NAMLNG],
					.NEWHDRISD[ISD$V_VPG]^9,LNK$GL_CURFIL[FDB$Q_FILENAME],
					.LNK$GL_CURCLU[CLU$L_BASE],OWNFDB[FDB$Q_FILENAME],LIN$_NOIMGFIL);
			    LNK$GL_CTLMSK[LNK$V_IMAGE] = FALSE;
			    END
			END
		ELSE IF NOT .LNK$GL_CURCLU[CLU$V_PIC]
		    THEN BEGIN
			LNK$GL_CURCLU[CLU$L_BASE] = 			! THEN EXTRACT BASE VPN
					.NEWHDRISD[ISD$V_VPG] ^9;
			LNK$GL_CURCLU[CLU$V_BASED] = TRUE;
			END;
		FIRSTISD = .NEWHDRISD;					! POINT TO THE FIRST ISECT IN CLUSTER
		END;
	    LNK$GL_CURCLU[CLU$L_NISECTS] = .LNK$GL_CURCLU[CLU$L_NISECTS] + 1; ! COUNT ISECT IN CLUSTER
	    BEGIN
		BIND
		    LASTISD = LNK$GL_CURCLU[CLU$L_LSTISD] : REF BLOCK[,BYTE]; ! POINTER TO LAST ISD IN CLUSTER
		LASTISD[ISL$L_NXTISD] = .CURISD;			! PUT AT END OF LIST
		LASTISD = .CURISD;					! AND MAKE CURRENT THE NEW LAST
		END;
	    IF .LNK$GL_CURCLU[CLU$V_PIC]				! IF A PIC CLUSTER
	    THEN BEGIN
		IF .NEWHDRISD EQL .FIRSTISD				! IF THIS IS THE FIRST ISECT THIS CLUSTER
		    THEN FIRSTISDVPG = .NEWHDRISD[ISD$V_VPG];		! THEN SAVE VPG OF FIRST ISECT
		NEWHDRISD[ISD$V_VPG] = .NEWHDRISD[ISD$V_VPG] -		! THEN SUBTRACT OUT THE BASE
					.FIRSTISDVPG;			! FOR LATER RE-LOCATION (NEEDED FOR OLD IMAGES LINKED @200)
		IF NOT .LNK$GL_CURCLU[CLU$V_BASED]
		    THEN LNK$GW_SHRISCTS = .LNK$GW_SHRISCTS + 1;	! COUNT IT
		END;
	    LNK$GL_CURCLU[CLU$L_PAGES] = .LNK$GL_CURCLU[CLU$L_PAGES] 	! ACCUMULATE THE PAGES REQUIRED
					+ .NEWHDRISD[ISD$W_PAGCNT];
	    IF (OWNCLU = .LNK$GL_CURCLU[CLU$L_OWNCLU]) EQL 0
		THEN LNK$GL_CURCLU[CLU$L_CLUOFF] = .LNK$GL_CURCLU[CLU$L_CLUOFF]
					+ .NEWHDRISD[ISD$W_PAGCNT]*512
		ELSE OWNCLU[CLU$L_CLUOFF] = .OWNCLU[CLU$L_CLUOFF]
					+ .NEWHDRISD[ISD$W_PAGCNT]*512;
	    IF .CURHDRISD[ISD$V_WRT]					! IF SECTION IS WRITEABLE
		AND NOT .CURHDRISD[ISD$V_CRF]				!  AND NOT COPY-ON-REF
		THEN LNK$GL_CURCLU[CLU$V_WRT] = TRUE;			!  THEN REMEMBER FOR LNKIMGOUT
	    IF .LNK$GL_CURCLU[CLU$V_BASED]				! IF CLUSTER IS BASED
		THEN NEWHDRISD[ISD$V_BASED] = TRUE;			! THEN FLAG IN CLUSTER DESCRIPTOR ALSO
	    IF NOT .CURHDRISD[ISD$V_DZRO]				! PROVIDED NOT A DEMAND ZERO ISD
		AND .CURHDRISD[ISD$L_VBN] NEQ 0				!  AND SECTION IS PRESENT IN THE IMAGE
		THEN IF .CURHDRISD[ISD$L_VBN] GEQU .MAXISDVBN		! IF THIS IMAGE SECTION GOES BEYOND LAST
		    THEN MAXISDVBN = .CURHDRISD[ISD$L_VBN] +		! BLOCK OF LAST ISECT, THEN
				.CURHDRISD[ISD$W_PAGCNT];		! COMPUTE NEW MAX VBN IN USE
	    IF NOT .CURHDRISD[ISD$V_DZRO]				! IF THE SECTION IS NOT DEMAND ZERO
		AND NOT .CURHDRISD[ISD$V_GBL]				! AND NOT ALREADY GLOBAL
	    THEN BEGIN
		NEWHDRISD[ISD$W_SIZE] = ISD$K_LENGLBL;			! SET SIZE AND 
		NEWHDRISD[ISD$V_GBL] = TRUE;				! MAKE IT GLOBAL NOW
		DECR I FROM 3 TO 1					! COMPUTE THE ISD NAME
		    DO IF (CURISDSEQ[.I] = .CURISDSEQ[.I] + 1) GTRU %C'9'! BY INCREMENTING THE SUFFIX
			THEN CURISDSEQ[.I] = %C'0'
			ELSE EXITLOOP;
		(NEWHDRISD[ISD$T_GBLNAM])<0,8,0> = .LNK$GL_CURCLU[CLU$B_NAMLNG]	! COPY THE CLUSTER
							+ 4;		! NAME CONCATENATED WITH
		CH$COPY(.LNK$GL_CURCLU[CLU$B_NAMLNG],LNK$GL_CURCLU[CLU$T_NAME],4, ! THE SEQUENTIAL NUMBER
					CURISDSEQ[0],0,15,		! OF THE SECTION AND ZERO
					NEWHDRISD[ISD$T_GBLNAM] + 1);	! FILL THEN SET MATCH CONTROL
		NEWHDRISD[ISD$V_MATCHCTL] = .LNK$GL_CURCLU[CLU$V_MATCHCTL];
		NEWHDRISD[ISD$L_IDENT] = .ISECTIDENT;			! AND THE MATCH CONTROL IDENT
		END;
	    IF NOT .CURHDRISD[ISD$V_DZRO]				! IF NOT DEMAND ZERO
		AND .LNK$GL_CURCLU[CLU$V_COPY]				! AND SHAREABLE IMAGE TO BE COPIED
		AND .CURHDRISD[ISD$L_VBN] NEQ 0				! AND SECTION IS PRESENT IN THIS ONE
		THEN (IF .CURHDRISD[ISD$W_PAGCNT] GTRU .LNK$GL_GSBUFDSC[0]	! MAXIMIZE THE SIZE OF
			THEN LNK$GL_GSBUFDSC[0] = .CURHDRISD[ISD$W_PAGCNT];);	! THE BUFFER WE WILL NEED
	    IF .IAFVA NEQ 0						! IF THERE IS A FIXUP SECTION
		AND (.NEWHDRISD[ISD$V_VPG]^9 EQL .IAFVA)		!  AND THIS IS IT
	    THEN BEGIN
		LNK$GL_CURCLU[CLU$L_FIXISD] = .CURISD;			!  THEN REMEMBER IT FOR LATER
		NEWHDRISD[ISD$V_FIXUPVEC] = TRUE;			! FLAG FIXUP SECTION IN ISD UNCONDITIONALLY
		END;
	    LNK$GW_NISECTS = .LNK$GW_NISECTS + 1;			! COUNT THAT IMAGE SECTION
	    END;							! OF LOCAL ISECT
	IF (CURHDRISD = .CURHDRISD + .NXTISDOFF) GTRU (.HEADER + 510) 	! CHECK IT WAS COMPLETELY
									! CONTAINED BY THE CURRENT BLOCK
	    THEN SIGNAL_STOP(LIN$_BADIMGHDR,1,				! IF NOT TRUE, FATAL IMAGE
				LNK$GL_CURFIL[FDB$Q_FILENAME]);		!  HEADER ERROR
	END								! END OF ISECTION LOOP
    ELSE IF (CURHDRISD = .CURHDRISD + .NXTISDOFF) GTRU (.HEADER + 510)	! IMAGE SECTION WAS A STACK ISD, JUST SKIP IT
									!  BUT MAKE SURE CONTAINED BY THE CURRENT BLOCK
	THEN SIGNAL_STOP(LIN$_BADIMGHDR,1,LNK$GL_CURFIL[FDB$Q_FILENAME]);!  AND ISSUE ERROR AND QUIT IF NOT
    END;								! END OF BLOCK LOOP

IF .MAXISDVBN GTRU .GSTVBN[0]						! AND THIS SHOULD ALSO POINT TO GST
    OR .HDRBLKCNT NEQ 0							! AND NO HEADER BLOCKS REMAIN
    THEN SIGNAL_STOP(LIN$_BADIMGHDR,1,LNK$GL_CURFIL[FDB$Q_FILENAME]);	! IF EITHER ABOVE NOT TRUE, FATAL IMAGE HEADER ERROR

IF .LNK$GL_CURCLU[CLU$V_BASED]						! IF THIS CLUSTER IS BASED
    AND .LNK$GL_DEFCLU[CLU$V_BASED]					! AND BASE= IN OPTION FILE
    AND .LNK$GL_CURCLU[CLU$L_BASE] LEQU .LNK$GL_DEFCLU[CLU$L_BASE]	!  AND THIS IMAGE IS BELOW IT
    THEN SIGNAL(LIN$_BASSHRBEL,3,LNK$GL_CURFIL[FDB$Q_FILENAME],		!  THEN WARN USER SHR IMG BELOW BASE=
			.LNK$GL_CURCLU[CLU$L_BASE],.LNK$GL_DEFCLU[CLU$L_BASE]);

GSTVBN[0] = .GSTVBN[0] + .BLOCKOFFSET;					! RELOCATE DOWN FILE IF NECESSARY
GSTVBN[1] = 0;								! CLEAR THE BYTE OFFSET IN THE RFA
SAVERECOUNT = .LNK$GL_OBJRECS;						! SAVE CURRENT RECORD COUNT
LNK$POINTOBJ(GSTVBN);							! POINT TO GST
IF NOT LNK$PROCSOBJ(GSTVBN)						! AND GO PROCESS IT LIKE AN
    THEN RETURN FALSE;							! OBJECT RETURNING IF ERROR
SAVERECOUNT = .LNK$GL_OBJRECS - .SAVERECOUNT;				! GET NUMBER PROCESSED
IF .SAVERECOUNT NEQ .GSTRECS						! AND IF NOT CORRECT NUMBER
    THEN SIGNAL_STOP(LIN$_BADIMGHDR,1,LNK$GL_CURFIL[FDB$Q_FILENAME]);	! FATAL IMAGE HEADER ERROR
LNK$GL_IMGRECS = .LNK$GL_IMGRECS + .SAVERECOUNT;			! ACCUMULATE RECORD COUNT


RETURN TRUE								! ALL DONE SO RETURN SUCCESS
END;								! End of LNK$PROCSHRIM

ROUTINE READNEXTBLOCK =			! READ NEXT BLOCK IF ANY
BEGIN
!
!++
!	THIS ROUTINE IS CALLED TO READ THE NEXT BLOCK OF THE IMAGE HEADER
!	READ ERRORS ARE FATAL. A REQUEST TO READ ANOTHER BLOCK
!	WHEN HDRBLKCNT IS ALREADY ZERO RETURNS FATAL.
!	HDRBLKCNT IS DECREMENTED AFTER EACH READ AND HEADERBLOCK IS
!	INCREMENTED BEFORE EACH READ.
!
!--
!
LOCAL
	SAVEUSZ,
	READERROR;
!
IF .HDRBLKCNT LEQ 0						! IF NO MORE BLOCKS
THEN RETURN FALSE;						! RETURN FAILURE
SAVEUSZ = .LNK$AL_RAB[RAB$W_USZ];				! SAVE USZ
HEADERBLOCK = .HEADERBLOCK + 1;					! SET THE BLOCK TO READ
LNK$AL_RAB[RAB$L_BKT] = .HEADERBLOCK;				! SET STARTING VBN
LNK$AL_RAB[RAB$W_USZ] = 512;					! AND SET THE BYTE COUNT
IF NOT (READERROR = $READ(RAB = LNK$AL_RAB))				! ATTEMPT TO READ LIBRARY, USING
THEN BEGIN								! BUFFER ALREADY SET UP
	SIGNAL(LIN$_READERR,1,						! 
			LNK$GL_CURFIL[FDB$Q_FILENAME],
			.READERROR,.LNK$AL_RAB[RAB$L_STV]);
	LNK$CLOSCURFIL();						! THE MESSAGES AND ATTEMPT TO
	LNK$AL_RAB[RAB$W_USZ] = .SAVEUSZ;				! RESTORE USZ
	RETURN FALSE;
     END;
HDRBLKCNT = .HDRBLKCNT - 1;					! DECREMENT THE BLOCK COUNT
LNK$AL_RAB[RAB$W_USZ] = .SAVEUSZ;
RETURN TRUE;				! AND ALL DONE SUCCESSFULLY
END;			! END OF READNEXTBLOCK
END ELUDOM		! End of module
