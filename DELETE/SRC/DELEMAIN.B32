MODULE delemain (	! STARLET Native File Deletion Utility
                        IDENT = 'V03-001',
                        MAIN = del$main,
			ADDRESSING_MODE(EXTERNAL=GENERAL)
                        ) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY:  DELETE
!
! ABSTRACT:
!
!	This utility program deletes one or more user-specified files.
!
! ENVIRONMENT:  
!
!	VAX/VMS operating system, unprivileged user mode utility,
!	operates at non-AST level.
!
! AUTHOR:  Carol Peters,	CREATION DATE:  03 May 1978
!
! Modified by:
!
!	V03-001	SHZ0004		Stephen H. Zalewski,	23-Mar-1982  14:30
!		Have correct version number displayed when /CONFIRM is
!		used and version number is negative or zero.
!
!	V02-011	KRM0041		Karl Malik		 5-Feb-1982
!		Modified DELETE_FILE to avoid an unnecessary $SEARCH
!		when the filespec contains an explicit (non-null)
!		version number.
!		
!	V02-010	KRM0039		Karl Malik		20-Jan-1982
!		Modified CHECK_WILDCARDS so that only network quoted
!		filespecs are acceptable without a version number (ANSI
!		magtape quoted filespecs must have versions).
!
!	V02-009	SHZ0003		Stephen H. Zalewski,	19-Nov-1981  15:54
!		Added ADDRESSING_MODE(EXTERNAL=GENERAL) to module header
!
!	V02-008	SHZ0002		Stephen H. Zalewski,	11-Nov-1981  17:33
!		Fixed DELETE/CONFIRM so that an input string of more than
!		eight characters does not return "internal logic error
!		detected".
!
!	V02-007	SHZ0001		Stephen H. Zalewski,	13-Aug-1981  15:38
!		Have version number printed when /CONFIRM is used and
!		a semicolon is used to denote latest version is to
!		be deleted.
!
!	V02-006	ACG0184		Andrew C. Goldstein,	14-Jan-1981  10:12
!		Add /ERASE qualifier
!
!	X00005	TMH0005		T. Halvorsen	30-Oct-1979
!		Setup XABPRO to PURGE FAB rather than XABFHC which is
!		no longer needed.
!
!	X00004	TMH0004		T. Halvorsen	29-Oct-1979
!		Make routine file_error global.  Change name of
!		del$purge_spec to purge_files.
!
!	X00003	T. Halvorsen	24-Aug-1979
!		Avoid all error messages in condition handler which do not
!		have facility = 3 which was appended via DEL$MSG_NUMBER
!		via put_message macro.  Allows LIB$ messages to be signaled
!		correctly.
!
!	X00002	CHP19984	C. Peters	7-Oct-1978	14:24
!		Test for RMS$_EOF return from LIB$GET_COMMAND. If the
!		status returns, stop processing the command.
!
!--

!
! Table of contents
!

FORWARD ROUTINE
    del$main,						! Main DELETE control routine
    delete_file		: NOVALUE,			! Deletes one file
    check_wildcards,					! Validates wildcards and version numbers
    check_date,						! Selects deletions based on date
    confirm_delete,					! Asks user whether a file is to be deleted.
    close_error		: NOVALUE,			! Handles errors on closing a file
    condit_handler,					! Condition handler for errors and messages
    file_error	: NOVALUE,				! Handles errors on RMS file functions
    get_confirm;					! PUTMSG action routine for /CONFIRM.

!
! Include files
!

LIBRARY 'SYS$LIBRARY:STARLET.L32';			! VAX/VMS common definitions
LIBRARY	'SYS$LIBRARY:CLIMAC.L32';			! CLI macros

REQUIRE	'SRC$:DELETE.REQ';				! COPY literal definitions and macros
REQUIRE 'SRC$:DELEMSG.REQ';				! Definition of macros to SIGNAL a message

OWN
    control_z_stop,					! Flag saying to stop processing
    del_or_not;						! Flag saying delete a file or not


EXTERNAL
    cli_work_area	: BLOCK [, BYTE],		! CLI dynamic work area
    del$before_date	: BLOCK [, BYTE],		! Specified /BEFORE date value.
    del$cli_status	: BITVECTOR,			! Status bits for DELETE utility
    del$keepver_val,					! Number of versions to keep in a PURGE session
    del$severe_err	: BLOCK [, BYTE],		! Most severe error code that has occurred
    del$since_date	: BLOCK [, BYTE],		! Specified /SINCE date value.
    infile_desc		: BLOCK [, BYTE],		! CLI input file descriptor block
    infile_fab		: BLOCK [, BYTE],		! FAB block for file
    infile_nam_blk	: BLOCK [, BYTE],		! NAM block for file
    infile_xabdat	: BLOCK [, BYTE],		! XAB date/time block for file specifications
    infile_xabpro	: BLOCK [, BYTE],		! XAB protection block
    initial_desc	: BLOCK [, BYTE];		! CLI initialization block

EXTERNAL ROUTINE
    del$get_cmdqual,					! Gets the command qualifiers
    del$get_file,					! Gets the file specification from command line.
    del$del_error,					! Handles an error on a file deletion.
    del$parse_file,					! Parses a file specification
    purge_files,					! Purges files related to one file specification
    lib$cvt_dtb,					! Converts an ASCII string to an integer value.
    lib$get_command,					! Gets a line from SYS$COMMAND.
    lib$set_erase,					! Mark a file for erase-on-delete
    del$search_fil,					! Searches for the next file
    sys$putmsg	: ADDRESSING_MODE (ABSOLUTE);		! Outputs a message to the user.

ROUTINE del$main =					! Main DELETE control routine

!++
! Functional description
!
!	This routine is the central control routine for the DELETE utility.
!	It determines the basic logical flow and calls support routines
!	that perform each logical function in deleting and purging files.
!
! Calling sequence
!
!	del$main ()
!
! Input parameters
!
!	AP.rlu.va - Argument list passed from the Command Language Interpreter
!
! Implicit inputs
!
!	infile_fab	- the FAB block to use for each file specification
!	infile_nam_blk	- the NAM block to use for each file specification
!
! Output parameters
!
!	none
!
! Implicit outputs
!
!	del$severe_err	- set whenever an error occurs
!
! Routine value
!
!	Most severe error encountered during processing or SS$_NORMAL
!
! Side effects
!
!	The specified files are deleted.
!
!--

    BEGIN

    BUILTIN
	AP;						! Declare the name of the argument pointer.

    BIND
	argument_list = AP	:  REF BLOCK [,BYTE];	! Declare the form of the argument list.

    LOCAL
	status;						! General routine return code

    LABEL
        process_loop;					! Label for file processing loop

!
! Enable a condition handler for this utility.
!

    ENABLE condit_handler;				! Enable a local handler.

!
! Initialization consists of storing the address of the parsing callback routine,
! and initializing the CLI work areas. This initializes all bit settings in the CLI status word.
!

    del$cli_result = .argument_list [cli$a_utilserv];	! Save the address of the CLI result parse routine.

    call_cli (						! Call the CLI with the following arguments:
                initial_desc,				!    CLI initialization request descriptor address,
		cli_work_area,				!    CLI work area address,
		del$cli_status);			!    and the DELETE status bit vector address.

!
! Set a bit in the status word that says that some input parameters have been specified.
! This allows for first time through the "get-input" loop.
!

    infile_desc [cli$v_concatinp] = TRUE;		! Needed to allow a retrieve of
							! the first file-specification.

    del$get_cmdqual ();					! Get the command qualifiers.

!
! The remainder of this routine is executed for each
! file specification supplied by the user.
!

    WHILE 1 DO						! Beginning of repeat loop
process_loop:
	BEGIN
        IF NOT .del$cli_status [wildcard_bit] THEN	! If not processing a wildcard specification,
            BEGIN					!    then get another specification.
            status = del$get_file (			! Call the routine del$get_file with
                                    infile_fab,		!    the address of the FAB block,
                                    infile_nam_blk,	!    and the address of the NAM block.
                                    (IF .del$cli_status [purge_cmd_bit]
                                     THEN
                                         infile_xabpro
                                     ELSE
                                         infile_xabdat)
                                    );			!    Choose a XABDAT block for deleting
							!    and a XABPRO for purging.

            IF .status EQL no_more_files		! If there are no more file specs,
                THEN EXITLOOP;				!    then exit the file spec processing loop.

            IF NOT .status				! If the file specification wasn't okay,
                THEN LEAVE process_loop;		!    then go get the next one.

!
! See whether this new file specification contains any wildcards. Also confirm that
! a DELETE command specifies an explicit or wildcard version number, and that a PURGE
! command does not specify any version number.
!

            IF NOT check_wildcards (infile_nam_blk)	! If wildcard settings are not valid,
            THEN
                LEAVE process_loop;			!    then go get next file specification.

            END;

!
! Perform DELETE or PURGE processing for this file specification.
!

        IF .del$cli_status [purge_cmd_bit]		! If this is a PURGE command
            THEN  purge_files (infile_fab)		!  then call purge routine with addresses of the FAB and NAM
            ELSE  delete_file (infile_fab);		! Otherwise, call delete routine with the addresses of the FAB.

        IF .control_z_stop				! If the user said <control-Z> to a delete confirmation message,
            THEN EXITLOOP;				! then, stop

	END;						! End of "WHILE 1 DO" file spec processing loop.


    RETURN .del$severe_err;				! Use the most severe error encountered
							! as the completion code from this routine.

    END;

ROUTINE delete_file (fab_block) : NOVALUE =		! Deletes a file

!++
! Functional description
!
!	This routine deletes one file. If a wildcard specification is active, an RMS SEARCH
!	function is called to find the next file that matches the wildcard specification.
!	If the user specified the /CONFIRM qualifier, the name of the file is output to
!	SYS$OUTPUT and the user can advise whether the file is to be deleted or not. Then
!	the file is opened, closed with the delete bit set, and the deletion reported if
!	the /LOG qualifier was specified.
!
! Calling sequence
!
!	delete_file (fab_block.ra.v)
!
! Input parameters
!
!	fab_block	- The FAB block for the file specification
!
! Implicit inputs
!
!	Bits are tested in the status word:
!
!		WILDCARD_BIT	- determines whether the specification contains wildcards.
!		CONFIRM_BIT	- whether the user wishes to decide on a per file
!				  basis whether the file is to be deleted.
!		LOG_MSG_BIT	- whether each deletion is to be logged on SYS$OUTPUT.
!
!	Fields in the NAM block are used to log the deletion:
!
!		RSA	- address of the resultant name string
!		RSL	- length of the resultant name string
!
! Output parameters
!
!	none
!
! Implicit outputs
!
!	The routine DEL$SEARCH_FIL turns off the wildcard flag if a wildcard
!	specification is exhausted.
!
! Routine value
!
!	novalue
!
! Side effects
!
!	Errors are signaled. Files are deleted. If a file is opened by the check_date routine,
!	it is closed (and perhaps also deleted).
!
!--
    BEGIN

    MAP
        fab_block	: REF BLOCK [, BYTE];

    BIND
        nam_block	=				! Associated NAM block address.
                .fab_block [fab$l_nam]	: BLOCK [, BYTE];

    LOCAL
        status;						! Holds RMS status codes

!
! If the current file specification contains a wildcard, or the user has
! specified the /CONFIRM qualifier, then search for the next matching file.
!
    IF .del$cli_status [wildcard_bit] OR
            .del$cli_status [confirm_bit]
    THEN
        BEGIN
        status = del$search_fil (.fab_block);			! Search through the directory for the next matching file
        IF NOT .status OR					! If the SEARCH fails, or if
            (.status EQL no_more_files)          		!    no more files matching wildcards exist,
        THEN
            RETURN;						! then return to caller.
	END;

!
! If the /BEFORE or /SINCE qualifier was specified, see whether this file should
! be deleted based the relation between its date field and the specified date field.
! The user can select deletion based on creation, expiration, or modification date.
!

    IF .del$cli_status [since_bit] OR			! If the /SINCE or the /BEFORE
        .del$cli_status [before_bit]			!    qualifier was specified,
    THEN
        BEGIN
        IF NOT check_date (.fab_block)			!    see whether this file qualifies for deletion.
        THEN
            RETURN;					! If the file doesn't qualify, just return.
        END;

!
! If the /CONFIRM qualifier was specified, ask the user whether this file
! should be deleted. If the user says no, then just go process the next file.
!

    IF .del$cli_status [confirm_bit]			! If /CONFIRM was requested,
    THEN
        BEGIN
        IF NOT confirm_delete (.fab_block) THEN		! Ask the user whether to delete the file.
            BEGIN
            IF .fab_block [fab$w_ifi] NEQ 0		! If the file is open due to date checking operation,
            THEN
                status = $RMS_CLOSE (FAB=.fab_block,	!    then close it.
                                     ERR = close_error);
            RETURN;					! Return to caller.
            END;
        END;

!
! Delete the current file. If /ERASE is requested, mark the file for erase first.
! If the file was opened by the check_date routine, just close it with the
! delete bit set. Otherwise simply call RMS to perform the erase function.
! If the erase or delete doesn't work, just return. The calling routine
! will go on to process the next file.
!

    IF .del$cli_status [erase_bit]			! If erase requested
    THEN 
	BEGIN
	LOCAL nam_block : REF bblock, descriptor : VECTOR [2];
	nam_block = .fab_block[fab$l_nam];
	descriptor[0] = .nam_block[nam$b_esl];
	descriptor[1] = .nam_block[nam$l_esa];
	status = lib$set_erase (descriptor);		! do it
	fab_block[fab$l_sts] = .status;
	fab_block[fab$l_stv] = 0;
	END
    ELSE
	status = true;

    IF .status
    THEN
	BEGIN
	IF .fab_block [fab$w_ifi] NEQ 0			! If the file is open,
	THEN
	    BEGIN
	    fab_block [fab$v_dlt] = TRUE;		!    then set the deletion bit,
	    status = $RMS_CLOSE (			!    and ask RMS to close and delete the file.
	                            FAB = .fab_block);	!    Specify the address of the FAB block.
	    fab_block [fab$v_dlt] = FALSE;		! Turn off the delete bit to avoide side effects.
	    END

	ELSE
	    status = $RMS_ERASE (			! Erase the file.
	                            FAB = .fab_block);	!    Specify the address of the FAB block.
	END;

    IF NOT .status					! If the ERASE function fails
    THEN
        file_error (					!    then report an error to the user.
                        msg$_filnotdel,			!    Specify that the file was not deleted,
                        .fab_block);			!    and give the address of the FAB block.

!
! If the deletion worked, and the /LOG qualifier was given, report the deletion.
!

    IF .status AND .del$cli_status [log_msg_bit]
    THEN						! If successful deletion and logging going on,
        BEGIN						!    then report the deletion.

        LOCAL
            name_desc	: VECTOR [2];			! String descriptor for file name

        name_desc [0] = .nam_block [nam$b_rsl];		! Load the length and address of the
        name_desc [1] = .nam_block [nam$l_rsa];		! file into the string descriptor.
        put_messagex (					! and output the message.
                        msg$_deleted,			!    This is the message number,
                        1,				!    one argument coming, which is
                        name_desc);			!    the file name descriptor.
        END;


    IF .fab_block [fab$w_ifi] NEQ 0			! If the file was left open because of some error, now 
    THEN						! just close it quietly.
	$RMS_CLOSE (FAB=.fab_block);

    END;

ROUTINE check_wildcards (nam_block) =			! Validate wildcards and version numbers.

!++
! Functional description
!
!	This routine validates the version number specification. Then it sets a bit in
!	the status word if any wildcards are present in the specification.
!
!	The rule is that the DELETE command requires explicit or wildcard version number
!	specification, whereas the PURGE command does NOT allow any version number
!	specification. Note that for file specifications that are network quoted
!	strings, no wildcard or explicit version number is needed for DELETE.
!
!	If specifications are improper for the command given, an error is signaled and
!	an error return taken.
!
! Calling sequence
!
!	check_wildcards (nam_block.ra.v)
!
! Input parameters
!
!	nam_block	- the NAM block for the file specification being checked
!
! Implicit inputs
!
!	The file specification associated with the NAM block has been PARSED with an RMS function call.
!
!	The following fields in the NAM block are read:
!
!		NAM$V_WILDCARD	- wildcards are present in the specification
!		NAM$V_WILD_VER	- a wildcard version number was given
!		NAM$V_EXP_VER	- an explicit version number was given
!		NAM$V_NODE	- a nodename was given
!		NAM$V_QUOTED	- a quoted file specification was given. Wildcard
!				  specification is as yet unknown.
!
!	The PURGE_CMD_BIT in DEL$CLI_STATUS is read to determine whether the
!		command given was a DELETE or a PURGE command.
!
! Output parameters
!
!	none
!
! Implicit outputs
!
!	The WILDCARD_BIT in DEL$CLI_STATUS is set if wildcards are present in the specification.
!
! Routine value
!
!	TRUE	- all settings are valid
!	FALSE	- invalid setting
!
! Side effects
!
!	If any part of the specification is seen to be invalid, then an error is signaled.
!
!--

    BEGIN

    MAP
        nam_block	: REF BLOCK [, BYTE];

!
! Don't allow version number specification for a PURGE command.
!

    IF .del$cli_status [purge_cmd_bit]			! If this is a PURGE command,
    THEN
        BEGIN
        IF .nam_block [nam$v_wild_ver] OR		!    then look for version number
            .nam_block [nam$v_exp_ver]			!    specification.
        THEN
            BEGIN
            put_message (msg$_purgever);		! If present, signal an error,
            RETURN FALSE;				!    and return an error status code.
            END;
        END

!
! A DELETE command, to the contrary, requires an explicit or wildcard version number.
!

    ELSE
        BEGIN
        IF  NOT  .nam_block [nam$v_wild_ver] AND		! If an explicit or wildcard version
            NOT  .nam_block [nam$v_exp_ver] AND		!    number is not present,
            NOT (.nam_block [nam$v_quoted] AND		!    and the file specification
	         .nam_block [nam$v_node])		!    is not a network quoted filespec
        THEN
            BEGIN
            put_message (msg$_delver);			!    then signal an error,
            RETURN FALSE;				!    and return an error status code.
            END;
        END;


    IF .nam_block [nam$v_wildcard]			! If a wildcard is present in the specification
    THEN
        del$cli_status [wildcard_bit] = TRUE;		!    then set a flag in the status word.

!
! Arrival here means that no invalid specifications were noticed.
!

    RETURN TRUE;					! Return a success code.

    END;

ROUTINE check_date (fab_block) =			! Selects file for deletion based on date comparison

!++
! Functional description
!
!	This routine decides whether a file can be deleted by comparing one of the file's date
!	values with prespecified dates from the command line. The date value chosen is the
!	creation date, the revision date, and/or the expiration date. Which date is used is based
!	on the user having said /CREATE, /MODIFY, and/or /EXPIRE, or on the default date selection.
!
!	The appropriate date is compared with dates specified in the command line. If the
!	user said /BEFORE, the file is a candidate for deletion if the selected date is previous
!	in time to the specified date. If the user said /SINCE, the file is a candidate for deletion
!	if the selected date is later than the specified date.
!
!	This routine returns a true value if the file is a candidate for deletion.
!
! Calling sequence
!
!	check_date (fab_block.ra.v)
!
! Input parameters
!
!	fab_block	- the FAB block associated with the file specification
!
! Implicit inputs
!
!	Fields in the associated XABDAT block.
!
!		CDT0	- high bits of creation date
!		CDT4	- low bits of creation date
!		EDT0	- high bits of expiration date
!		EDT4	- low bits of expiration date
!		RDT0	- high bits of modification date
!		RDT4	- low bits of modification date
!
!	del$before_date	- Specified /BEFORE date.
!	del$since_date	- Specified /SINCE date.
!
! Output parameters
!
!	none
!
! Implicit outputs
!
!	none
!
! Routine value
!
!	TRUE	- file is to be deleted
!	FALSE	- file is not to be deleted
!
! Side effects
!
!	none
!
!--

    BEGIN

    MAP
        fab_block	: REF BLOCK [, BYTE];

    BIND
        xabdat_block	=				! Associated XABDAT block
                .fab_block [fab$l_xab]	: BLOCK [, BYTE];

    LOCAL
        status,						! Holds RMS status codes
        earlier,					! Boolean, says /BEFORE was true
        later,						! Boolean, says /SINCE was true
        xab_high_offset,				! Offset to high-bit XAB date field
        xab_low_offset;					! Offset to low-bit XAB date field

    MACRO
        offset_value (o, p, s, e) = o%,			! Get offset field from a field macro.
        pos_siz_ext (o, p, s, e) = p, s, e%,		! Get position, size, and extension fields from a
							!    field macro.
        high_date	= 4, 0, 32, 0%,			! High-bits in specified date
        low_date	= 0, 0, 32, 0%;			! Low-bits in specified date

!
! First open the current file so that the XABDAT fields are filled in.
! If the OPEN fails, signal a message, and return FALSE so that the file is not deleted.
!

    status = $RMS_OPEN (				! Open the file.
                        FAB = .fab_block,		!    Specify the address of the FAB
                        ERR = del$del_error);		!    and an error action routine.

    IF NOT .status					! If the open fails,
    THEN
        RETURN FALSE;					!    then return with indication of no delete.

    status = $RMS_CLOSE (				! Close the file too.
                            FAB = .fab_block,		!    Specify the address of the FAB
                            ERR = close_error);		!    and an error action routine.

    IF NOT .status					! If the CLOSE fails,
    THEN
        RETURN FALSE;					!    then return with no delete indication.

!
! For each date that the user said to check, decide whether the file's related date value
! indicates that the file should be deleted.
!

    SELECT TRUE OF
        SET

        [.del$cli_status [create_bit]]:			! Creation date

            BEGIN
            earlier = FALSE;				! Initialize Boolean date matches
            later = FALSE;				!    for both /BEFORE and /SINCE.

!
! If the user said /BEFORE, and the file's creation date is previous to the specified
! date, then set Boolean indicator that /BEFORE was satisfied.
!

            IF .del$cli_status [before_bit]		! If /BEFORE was specified,
            THEN
                BEGIN
                xab_low_offset =			!    calculate the byte offset of the high and low
                    offset_value (xab$l_cdt0);		!    32-bit halves of the file's creation date.
                xab_high_offset =
                    offset_value (xab$l_cdt4);

                IF (.xabdat_block [.xab_high_offset, pos_siz_ext (xab$l_cdt0)]
                    LSSU .del$before_date [high_date])	! If the creation high date value is earlier
                THEN
                    earlier = TRUE			!    then the /BEFORE condition is met.
                ELSE
                    BEGIN
                    IF (.xabdat_block [.xab_high_offset, pos_siz_ext (xab$l_cdt0)]
                        EQLU .del$before_date [high_date])
                        AND (.xabdat_block [.xab_low_offset, pos_siz_ext (xab$l_cdt0)]
                        LSSU .del$before_date [low_date])
							!    than the specified /BEFORE date,
                    THEN
                        earlier = TRUE;			!    then set the /BEFORE condition Boolean.
                    END;
                END;

!
! If the user said /SINCE, and the file's creation date is later than the specified
! date, and the /BEFORE condition was satisfied, then return with an indication to delete the file.
!

            IF .del$cli_status [since_bit]		! If /SINCE was specified,
            THEN
                BEGIN
                xab_low_offset =			!    calculate the byte offset of the high and low
                    offset_value (xab$l_cdt0);		!    32-bit halves of the file's creation date.
                xab_high_offset =
                    offset_value (xab$l_cdt4);

                IF (.xabdat_block [.xab_high_offset, pos_siz_ext (xab$l_cdt0)]
                    GTRU .del$since_date [high_date])	! If the file's high date is later than the
                THEN
                    later = TRUE			!    /SINCE high date, then the /SINCE condition is met.
                ELSE
                    BEGIN
                    IF (.xabdat_block [.xab_high_offset, pos_siz_ext (xab$l_cdt0)]
                        EQLU .del$since_date [high_date])
							! Otherwise, if high date is equal, and low
                        AND (.xabdat_block [.xab_low_offset, pos_siz_ext (xab$l_cdt0)]
                        GTRU .del$since_date [low_date])!    date is greater,
                    THEN
                        later = TRUE;			!    then the /SINCE condition is met.
                    END;
                END;

            IF (.earlier OR				! If the /BEFORE condition is met,
                NOT .del$cli_status [before_bit])	!    or /BEFORE was not specified,
                AND (.later OR				!    and the /SINCE condition is met,
                NOT .del$cli_status [since_bit])	!    or /SINCE was not specified,
            THEN
                RETURN TRUE;				!    then delete the file.
            END;


        [.del$cli_status [modify_bit]]:			! Revision date

            BEGIN
            earlier = FALSE;				! Initialize Boolean date matches
            later = FALSE;				!    for both /BEFORE and /SINCE.

!
! If the user said /BEFORE, and the file's revision date is previous to the specified
! date, then set Boolean indicator that /BEFORE was satisfied.
!

            IF .del$cli_status [before_bit]		! If /BEFORE was specified,
            THEN
                BEGIN
                xab_low_offset =			!    calculate the byte offset of the high and low
                    offset_value (xab$l_rdt0);		!    32-bit halves of the file's revision date.
                xab_high_offset =
                    offset_value (xab$l_rdt4);

                IF (.xabdat_block [.xab_high_offset, pos_siz_ext (xab$l_rdt0)]
                    LSSU .del$before_date [high_date])	! If the revision high date value is earlier
                THEN
                    earlier = TRUE			!    then the /BEFORE condition is met.
                ELSE
                    BEGIN
                    IF (.xabdat_block [.xab_high_offset, pos_siz_ext (xab$l_rdt0)]
                        EQLU .del$before_date [high_date])
                        AND (.xabdat_block [.xab_low_offset, pos_siz_ext (xab$l_rdt0)]
                        LSSU .del$before_date [low_date])
							!    than the specified /BEFORE date,
                    THEN
                        earlier = TRUE;			!    then set the /BEFORE condition Boolean.
                    END;
                END;

!
! If the user said /SINCE, and the file's revision date is later than the specified
! date, and the /BEFORE condition was satisfied, then return with an indication to delete the file.
!

            IF .del$cli_status [since_bit]		! If /SINCE was specified,
            THEN
                BEGIN
                xab_low_offset =			!    calculate the byte offset of the high and low
                    offset_value (xab$l_rdt0);		!    32-bit halves of the file's revision date.
                xab_high_offset =
                    offset_value (xab$l_rdt4);

                IF (.xabdat_block [.xab_high_offset, pos_siz_ext (xab$l_rdt0)]
                    GTRU .del$since_date [high_date])	! If the file's high date is later than the
                THEN
                    later = TRUE			!    /SINCE high date, then the /SINCE condition is met.
                ELSE
                    BEGIN
                    IF (.xabdat_block [.xab_high_offset, pos_siz_ext (xab$l_rdt0)]
                        EQLU .del$since_date [high_date])
							! Otherwise, if high date is equal, and low
                        AND (.xabdat_block [.xab_low_offset, pos_siz_ext (xab$l_rdt0)]
                        GTRU .del$since_date [low_date])!    date is greater,
                    THEN
                        later = TRUE;			!    then the /SINCE condition is met.
                    END;
                END;

            IF (.earlier OR				! If the /BEFORE condition is met,
                NOT .del$cli_status [before_bit])	!    or /BEFORE was not specified,
                AND (.later OR				!    and the /SINCE condition is met,
                NOT .del$cli_status [since_bit])	!    or /SINCE was not specified,
            THEN
                RETURN TRUE;				!    then delete the file.
            END;


        [.del$cli_status [expire_bit]]:			! Expiration date


            BEGIN
            earlier = FALSE;				! Initialize Boolean date matches
            later = FALSE;				!    for both /BEFORE and /SINCE.

!
! If the user said /BEFORE, and the file's expiration date is previous to the specified
! date, then set Boolean indicator that /BEFORE was satisfied.
!

            IF .del$cli_status [before_bit]		! If /BEFORE was specified,
            THEN
                BEGIN
                xab_low_offset =			!    calculate the byte offset of the high and low
                    offset_value (xab$l_edt0);		!    32-bit halves of the file's expiration date.
                xab_high_offset =
                    offset_value (xab$l_edt4);

                IF (.xabdat_block [.xab_high_offset, pos_siz_ext (xab$l_edt0)]
                    LSSU .del$before_date [high_date])	! If the expiration high date value is earlier
                THEN
                    earlier = TRUE			!    then the /BEFORE condition is met.
                ELSE
                    BEGIN
                    IF (.xabdat_block [.xab_high_offset, pos_siz_ext (xab$l_edt0)]
                        EQLU .del$before_date [high_date])
                        AND (.xabdat_block [.xab_low_offset, pos_siz_ext (xab$l_edt0)]
                        LSSU .del$before_date [low_date])
							!    than the specified /BEFORE date,
                    THEN
                        earlier = TRUE;			!    then set the /BEFORE condition Boolean.
                    END;
                END;

!
! If the user said /SINCE, and the file's expiration date is later than the specified
! date, and the /BEFORE condition was satisfied, then return with an indication to delete the file.
!

            IF .del$cli_status [since_bit]		! If /SINCE was specified,
            THEN
                BEGIN
                xab_low_offset =			!    calculate the byte offset of the high and low
                    offset_value (xab$l_edt0);		!    32-bit halves of the file's expiration date.
                xab_high_offset =
                    offset_value (xab$l_edt4);

                IF (.xabdat_block [.xab_high_offset, pos_siz_ext (xab$l_edt0)]
                    GTRU .del$since_date [high_date])	! If the file's high date is later than the
                THEN
                    later = TRUE			!    /SINCE high date, then the /SINCE condition is met.
                ELSE
                    BEGIN
                    IF (.xabdat_block [.xab_high_offset, pos_siz_ext (xab$l_edt0)]
                        EQLU .del$since_date [high_date])
							! Otherwise, if high date is equal, and low
                        AND (.xabdat_block [.xab_low_offset, pos_siz_ext (xab$l_edt0)]
                        GTRU .del$since_date [low_date])!    date is greater,
                    THEN
                        later = TRUE;			!    then the /SINCE condition is met.
                    END;
                END;

            IF (.earlier OR				! If the /BEFORE condition is met,
                NOT .del$cli_status [before_bit])	!    or /BEFORE was not specified,
                AND (.later OR				!    and the /SINCE condition is met,
                NOT .del$cli_status [since_bit])	!    or /SINCE was not specified,
            THEN
                RETURN TRUE;				!    then delete the file.
            END;

        TES;

!
! If the routine gets this far, no dates were appropriate for file deletion.
! Return a status code that says don't delete the file.
!

    RETURN FALSE;					! Return no delete status code.

    END;

ROUTINE confirm_delete (fab_block) =			! See whether user wants to delete this file

!++
! Functional description
!
!	This routine signals the condition handler with a code signifying that
!	confirmation to delete a file is needed. The condition handler processing
!	causes a global variable to be set TRUE if deletion is to occur, and
!	FALSE if deletion is not to occur. This routine also returns TRUE if deletion
!	is to occur.
!
! Calling sequence
!
!	confirm_delete (fab_block.ra.v)
!
! Input parameters
!
!	fab_block	- the address of the FAB block associated with the file to be deleted
!
! Implicit inputs
!
!	The file associated with the FAB passed as a parameter is assumed to be OPEN.
!	Fields in the associated NAM block are read:
!
!		RSL	- length of the resultant name field.
!		RSA	- address of the resultant name field.
!		ESL	- length of the expanded name field.
!		ESA	- address of the expanded name field.
!
! Output parameters
!
!	none
!
! Implicit outputs
!
!	DEL_OR_NOT	- set to TRUE if deletion is to occur.
!			- set to FALSE if deletion is not to occur.
!
! Routine value
!
!	TRUE	- if deletion
!	FALSE	- if no deletion
!
! Side effects
!
!	A read to the terminal occurs. The prompt string is the name of the
!	file to be deleted plus a brief question. If the read fails, a severe error
!	is signaled.
!
!--

    BEGIN

    MAP
        fab_block	: REF BLOCK [, BYTE];

    BIND
        nam_block	=				! Associated NAM block address
                .fab_block [fab$l_nam]	: BLOCK [, BYTE];

    LOCAL
        name_desc	: VECTOR [2];			! String descriptor for file name

!
! Load the file name and length into the local string descriptor.
!

    IF .nam_block [nam$b_rsl] NEQ 0			! If a resultant file name string exists,
    THEN						!    then use it.
        BEGIN
        name_desc [0] = .nam_block [nam$b_rsl];		! Length of file is from RSL field of NAM block.
        name_desc [1] = .nam_block [nam$l_rsa];		! Address is from RSA field of NAM block.
        END
    ELSE
        BEGIN						! Otherwise, use expanded name string.
        name_desc [0] = .nam_block [nam$b_esl];		! Length of file is from ESL field of NAM block.
        name_desc [1] = .nam_block [nam$l_esa];		! Address is from ESA field of NAM block.
        END;

!
! Signal an error, specifying the error code MSG$_CONFDEL. This message causes
! PUTMSG to be called with an action routine that is called before the message
! is output. This action routine does the read, and stores the answer as a setting
! in DEL_OR_NOT. The action routine also suppresses PUTMSG's outputting of
! the message.
!

     put_message (					! Signal the confirm message.
                    msg$_confdel,			!    Specify the "confirm deletion" message code,
                    1,					!    one FAO argument,
                    name_desc);				!    and the FAO argument - the name of the file.

!
! If the action routine set the global variable, then return with success. Otherwise,
! return with failure.
!

    IF .del_or_not					! If the file is to be deleted,
    THEN
        RETURN TRUE					!    then return with a success code,
    ELSE
        RETURN FALSE;					!    otherwise, return with a FALSE code.

    END;

GLOBAL ROUTINE file_error (message_id, fab_block) : NOVALUE =	! RMS failure error action routine

!++
! Functional description
!
!	This RMS error action routine sends an error message to the user.
!
! Calling sequence
!
!	file_error (message_id.rv, fab_block.ra.v)
!
! Input parameters
!
!	message_id	- The message code for the message to send.
!	fab_block	- Address of the FAB block of the file for which the error occurred
!
! Implicit inputs
!
!	Fields in the associated NAM block:
!
!		RSA	- the address of the resultant name string of an opened file
!		RSL	- the length of the resultant name string
!		ESA	- the address of the expanded name string of a parsed file
!		ESL	- the length of the expanded name string
!
!	Fields in the FAB block:
!
!		STS	- primary RMS status code
!		STV	- secondard RMS status code
!
!	INFILE_DESC	- the CLI data block for the parameter
!
! Output parameters
!
!	none
!
! Implicit outputs
!
!	none
!
! Routine value
!
!	novalue
!
! Side effects
!
!	none
!
!--

    BEGIN

    MAP
        fab_block	: REF BLOCK [, BYTE];

    BIND
        nam_block	=				! Associated NAM block address
                .fab_block [fab$l_nam]	: BLOCK [, BYTE];

    LOCAL
        name_desc	: VECTOR [2];			! String descriptor for the file name

!
! Fill in the file name descriptor with the most complete name possible.
!

    IF .nam_block [nam$b_rsl] NEQ 0			! If a resultant name string exists,
    THEN						!
	BEGIN						!
	name_desc [0] = .nam_block [nam$b_rsl];		! then fill in the resultant name length
	name_desc [1] = .nam_block [nam$l_rsa];		! and address.
	END
    ELSE
	IF .nam_block [nam$b_esl] NEQ 0			! If RMS created an expanded string
	THEN						! but couldn't open the file,
	    BEGIN					!
	    name_desc [0] = .nam_block [nam$b_esl];	! then fill in the expanded name length
	    name_desc [1] = .nam_block [nam$l_esa];	! and address.
	    END
	ELSE						! Otherwise, no RMS name information is available.
	    BEGIN
	    name_desc [0] = .infile_desc [cli$w_rqsize];! So use the file name length
	    name_desc [1] = .infile_desc [cli$a_rqaddr];! and length passed by the CLI.
	    END;

!
! Signal the error condition.
!

    put_messagex (					! Signal "input open error" with the following arguments:
                    .message_id,			!    the message identifier,
                    1,					!    the number of message arguments,
                    name_desc,				!    the address of input name descriptor,
                    .fab_block [fab$l_sts],		!    the primary RMS completion code,
                    .fab_block [fab$l_stv]);		!    and the scondary RMS completion code.

!
! Return to the caller.
!

    RETURN;						! Return to the caller.

    END;

ROUTINE close_error (fab_block) : NOVALUE =		! RMS close file failure error action routine

!++
! Functional description
!
!	This RMS error action routine sends a file close error message to the user.
!
! Calling sequence
!
!	close_error (fab_block.ra.v)
!
! Input parameters
!
!	fab_block	- Address of the FAB block of the file that couldn't be closed.
!
! Implicit inputs
!
!	Fields in the associated NAM block:
!
!		RSA	- the address of the name of the opened file
!		RSL	- the length of the name of the opened file
!
! Output parameters
!
!	none
!
! Implicit outputs
!
!	none
!
! Routine value
!
!	novalue
!
! Side effects
!
!	none
!
!--

    BEGIN

    MAP
        fab_block	: REF BLOCK [, BYTE];

    BIND
        nam_block	=				! Associated NAM block address
                .fab_block [fab$l_nam]	: BLOCK [, BYTE];

    LOCAL
        name_desc	: VECTOR [2];			! String descriptor for the file name

!
! Set up a string descriptor that describes that file that couldn't be closed.
!

    name_desc [0] = .nam_block [nam$b_rsl];		! The length is the resultant name length.
    name_desc [1] = .nam_block [nam$l_rsa];		! The address, the resultant name address.

!
! Signal a close error.
!

    put_message (					! Signal a "delete error" with the following arguments:
                    msg$_closedel,			!    a "file not closed" error,
                    1,					!    the number of message arguments,
                    name_desc,				!    the address of file name descriptor,
                    .fab_block [fab$l_sts],		!    the primary RMS completion code,
                    .fab_block [fab$l_stv]);		!    and the secondary RMS completion code.

!
! Return to the caller.
!

    RETURN;						! Return to the caller.

    END;


ROUTINE condit_handler (signal_array, mechan_array) =	! Condition handler for DELETE utility

!++
! Functional description
!
!	This condition handler is called because a condition has been signaled by
!	the DELETE utility. This handler calls SYS$PUTMSG to report the problem or
!	information. Then the signal code is examined for severity level. Severe errors
!	are resignaled. These subsequently cause the program to halt through the actions
!	of LIB$STOP (a library routine). All other errors cause the condition handler to
!	return a continue code, which continues the execution of the DELETE utility.
!
! Calling sequence
!
!	condit_handler (signal_array.ra.v, mechan_array.ra.v)
!
! Input parameters
!
!	signal_array	- the address of the signal array for the condition
!	mechan_array	- the address of the mechanism array for the condition
!
! Implicit inputs
!
!	The PURGE_CMD_BIT in DEL$CLI_STATUS tells whether a DELETE or a PURGE command
!		caused this error.
!
! Output parameters
!
!	none
!
! Implicit outputs
!
!	The number of arguments listed in the signal argument list is reduced by two.
!
! Routine value
!
!	SS$_RESIGNAL	- on a severe error
!	SS$_CONTINUE	- on a continuable error
!
! Side effects
!
!	The message is output to the device SYS$ERROR or SYS$OUTPUT.
!
!--

    BEGIN

    MAP
        signal_array	: REF BLOCK [, BYTE];

    MACRO
        putmsg_flags	= 2, 0, 16, 0%;			! Flags for PUTMSG in signal argument list

    LOCAL
        condition_name	: BLOCK [4, BYTE],		! Temporary home for condition name
        confirm_msg,					! Boolean, says whether the message is just delete confirmation
        facil_name_desc	: VECTOR [2];			! String descriptor for the message prefix

!
! Bypass system messages. We don't know how to handle them.
!

    condition_name = .signal_array [chf$l_sig_name];	! Get the condition name.
    IF .condition_name [sts$v_fac_no] NEQ 3		! If no facility name,
    THEN
        RETURN ss$_resignal;				!    then this is a system message. Resignal it.

!
! Remove PC and PSL from the signal argument list by reducing the argument count.
!

    signal_array [chf$l_sig_args] = 			! Reduce the length of the signal argument
        .signal_array [chf$l_sig_args] - 2;		!    list so that PC and PSL are not included.
    IF ((.condition_name [sts$v_msg_no] ^ 3) OR		! If this is the file deletion confirmation message,
        .condition_name [sts$v_severity])		!    then don't output a facility name.
        EQL msg$_confdel
    THEN
        confirm_msg = TRUE				! Set flag that this is just delete confirmation.
    ELSE
        confirm_msg = FALSE;				!    Otherwise, set flag to FALSE.

    IF .confirm_msg					! If confirming the deletion of a file,
    THEN
        signal_array [putmsg_flags] = 1;		! Set PUTMSG flags to suppress facility and severity.

!
! Create a string descriptor for the facility name. These are "PURGE" or "DELETE".
! Don't do this for the file confirmation message.
!

    IF NOT .confirm_msg					! If this is an average message, not confirmation
    THEN
        BEGIN
        IF .del$cli_status [purge_cmd_bit]		! If this is a PURGE command,
        THEN
            BEGIN
            facil_name_desc [1] =			!    set up for a "PURGE" prefix.
                 UPLIT BYTE (%ASCII 'PURGE');
            facil_name_desc [0] = 5;			!    Length is five characters.
            END
        ELSE
            BEGIN
            facil_name_desc [1] =			! Otherwise, set up for a "DELETE" prefix.
                UPLIT BYTE (%ASCII 'DELETE');
            facil_name_desc [0] = 6;			! Length is six characters.
            END;
        END;

!
! Now output the message. If this is a "confirm whether or not to delete this file"
! message, then specify an action routine. The action routine actually outputs the
! message and waits for input. Otherwise, just let PUTMSG do its work.
!

    sys$putmsg (					! Output the message.
                .signal_array,				!    Pass the address of the signal list;
                (IF .confirm_msg			!    if confirmation message,
                 THEN
                     get_confirm			!    then specify an action routine;
                 ELSE
                     0),				!    otherwise, no action routine;
                (IF .confirm_msg			!    again, if confirmation,
                 THEN
                     0					!    then no facility name descriptor;
                 ELSE
                     facil_name_desc)			!    otherwise, specify descriptor of facility name.
                );

!
! If this was a severe error, then resignal the exception. Otherwise, continue from
! this condition back into the normal program execution.
!

    IF .signal_array [chf$l_sig_name] MOD 8		! If the message is severe,
        EQL sts$k_severe
    THEN
        RETURN ss$_resignal				!    then resignal the error;
    ELSE
        RETURN ss$_continue;				!    otherwise, continue as before.

    END;

ROUTINE get_confirm (msg_desc) =			! Reads (with prompt) from the terminal

!++
! Functional description
!
!	This routine calls a library routine -- LIB$GET_COMMAND -- to obtain a "Y" or "N"
!	from the user. "Y" means delete the file just opened. "N" means don't delete it;
!	just close it.
!
!	If the library routine returns with an error code, a severe error is signaled,
!	and this utility halts.
!
!	The user's answer causes the value of DEL_OR_NOT to be set on or off.
!
!	This routine always resignals so that PUTMSG, its caller, does no further
!	processing.
!
! Calling sequence
!
!	get_confirm (msg_desc.rd.s)
!
! Input parameters
!
!	msg_desc	- the address of a string descriptor that describes the prompt message
!
! Implicit inputs
!
!	none
!
! Output parameters
!
!	none
!
! Implicit outputs
!
!	DEL_OR_NOT	- set if user says "Y"
!			- set to zero if user says anything else
!	CONTROL_Z_STOP	- set if user says <control-Z>
!
! Routine value
!
!	ss$_resignal	- error code that causes PUTMSG to cease processing and return to caller
!
! Side effects
!
!	If the READ fails, another error is signaled, a severe error, and control
!	never returns to this routine.
!
!--

    BEGIN

    MAP
        msg_desc	: REF BLOCK [, BYTE];

    LOCAL
        buffer		: VECTOR [CH$ALLOCATION (8)],	! Buffer for response string
        char,						! Holds one character
        answer_desc	: BLOCK [8, BYTE],		! String descriptor for response string
	status;						! Status of get_command call


    CH$FILL (' ', 8, CH$PTR (buffer));			! Zero the local response buffer.
    answer_desc [dsc$w_length] = 8;			! Length of response buffer is eight characters
    answer_desc [dsc$a_pointer] = buffer;		! Load address of response buffer.
    answer_desc [dsc$b_class] = dsc$k_class_s;		! This is a static descriptor.

!
! Call the library routine to READ from the terminal. If this routine fails,
! signal a severe error and don't return to this routine.
!

    status = lib$get_command (				! Call a routine to output a prompt
                            answer_desc,		!    string and solicit input from
                            .msg_desc);			!    the user.
    IF NOT .status					! If the solicited input does not arrive,
    THEN
        IF .status EQL RMS$_EOF				! Allow a <control-Z> from user.
        THEN						! Don't allow any other errors.
            BEGIN					! The user said <control_Z>.
            del_or_not = FALSE;				! Set flags saying don't delete file,
            control_z_stop = TRUE;			! and stop processing.
            RETURN ss$_resignal;			! And complete as usual.
            END;

!
! Read the first character of the response. If it is "Y", then set the TRUE the global
! variable that says delete the file. Otherwise, any other response causes the global
! to be set to FALSE, meaning don't delete the file.
!

    char = CH$RCHAR (CH$PTR (buffer));			! Get one character from the input buffer.
    IF (.char EQL 'Y') OR (.char EQL 'y')		! If the character is "Y",
    THEN
        del_or_not = TRUE				!    set the variable to TRUE, meaning delete;
    ELSE
        del_or_not = FALSE;				!    otherwise, set it to FALSE, meaning no delete.

    RETURN ss$_resignal					! Return error code so PUTMSG returns.

    END;

END
ELUDOM
