%TITLE	'VAX-11 CONVERT'
MODULE	CONV$FSTLD	( IDENT='V03-003',
			OPTLEVEL=3
			) =

BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! Facility:	VAX-11 CONVERT
!
! Abstract:	This module contains the high level calls for the fast load
!		process along with the declaratons for the data specifically
!		used by fast load
!
! Contents:
!		FAST_LOAD
!		INIT_FAST_LOAD
!		LOAD_PRIMARY
!		LOAD_SECONDARY
!		LOAD_DATA_BUCKET
!		LOAD_INDEX_BUCKET
!		FINISH_INDEX
!		BACKUP_INDEX
!
! Environment:
!
!		VAX/VMS Operating System
!
!--

!
! Author:	Keith B Thompson	Creation date:	August-1980
!
!
! Modified by:
!
!	V03-003	KBT0047		Keith Thompson		14-Apr-1982
!		Fix end condition problem with the index buckets
!
!	V03-002	KBT0022		Keith Thompson		24-Mar-1982
!		Fix problem with last data bucket being continuation bucket
!		and more duplicate problems.  Change some linkages.
!
!	V03-001	KBT0012		Keith Thompson		16-Mar-1982
!		Fix some prologue 3 duplicate bugs in load_data_bucket
!		and remove prologue 3 secondary key code
!****


PSECT
	OWN	= _CONV$FAST_D	(PIC),
	GLOBAL	= _CONV$FAST_D	(PIC),
	PLIT	= _CONV$PLIT	(SHARE,PIC),
	CODE	= _CONV$FAST_S	(SHARE,PIC);

LIBRARY	'SYS$LIBRARY:LIB.L32';
REQUIRE	'SRC$:CONVERT';
REQUIRE	'SRC$:CONVDEF';

DEFINE_ERROR_CODES;

EXTERNAL ROUTINE
	CONV$$GET_VM		: JSB_LINK,
	CONV$$GET_TEMP_VM	: JSB_LINK,
	CONV$$FREE_TEMP_VM	: JSB_LINK,
	CONV$$EXCEPTION,
	CONV$$END_OF_FILE	: NOVALUE,
	CONV$$SORT_SECONDARY	: JSB_REG11,
	CONV$$GET_RECORD	: JSB_LINK,
	CONV$$CHECK_S_DUP	: JSB_REG,
	CONV$$CHECK_NULL	: JSB_REG,
	CONV$$SPLIT_DATA	: JSB_REG,
	CONV$$COMPRESS_KEY	: NOVALUE JSB_REG,
	CONV$$COMPRESS_INDEX	: NOVALUE JSB_REG,
	CONV$$MAKE_INDEX	: NOVALUE JSB_REG,
	CONV$$WRITE_VBN		: NOVALUE JSB_REG,
	CONV$$COPY_KEY		: NOVALUE JSB_REG,
	CONV$$WRITE_BUCKET	: NOVALUE JSB_REG,
	CONV$$GET_BUCKET	: NOVALUE JSB_REG_ARG1,
	CONV$$INIT_BUCKET	: NOVALUE JSB_REG,
	CONV$$CREATE_HIGH_KEY	: NOVALUE JSB_REG,
	CONV$$WRITE_PROLOGUE	: NOVALUE,
	CONV$$CONVERT_VBN_ID	: NOVALUE CONVERT_VBN_ID_LINK,
	CONV$$SET_KEY_BLOCK	: JSB_REG11_ARG1,
	CONV$$WRITE_KEY_DESC	: NOVALUE JSB_LINK;

FORWARD ROUTINE
	INIT_FAST_LOAD		: NOVALUE JSB_REG,
	LOAD_PRIMARY		: JSB_REG,
	LOAD_SECONDARY		: NOVALUE JSB_REG,
	LOAD_DATA_BUCKET	: NOVALUE JSB_REG,
	LOAD_INDEX_BUCKET	: NOVALUE JSB_REG,
	FINISH_INDEX		: NOVALUE JSB_REG,
	BACKUP_INDEX		: NOVALUE JSB_REG;

EXTERNAL
	CONV$GL_FILL		: LONG,

	CONV$GW_OUT_REC_SIZ	: SIGNED WORD,		! Output Rec. Size

	CONV$GL_VALID_COUNT,

	CONV$GW_MAX_REC_SIZ	: WORD,			! Aprox. size of record buffer
	CONV$GL_REC_BUF_PTR	: LONG,			! Bottom of Record Buffer

	CONV$AB_IN_RAB		: $RAB_DECL,
	CONV$AB_OUT_XABSUM	: $XABSUM_DECL,
	CONV$AB_OUT_FAB		: $FAB_DECL,
	CONV$AB_OUT_RAB		: $RAB_DECL,
	CONV$AB_RFA_RAB		: $RAB_DECL,

	CONV$GL_EOF_VBN		: LONG,
	CONV$GB_PROL_V1		: BYTE,
	CONV$GB_PROL_V2		: BYTE,
	CONV$GB_PROL_V3		: BYTE,
	CONV$AR_PROLOGUE	: REF BLOCK [ ,BYTE ],
	CONV$GL_KEY_DESC_VBN	: LONG,
	CONV$AR_AREA_BLOCK	: REF BLOCKVECTOR [ ,AREA$C_BLN,BYTE ];

MACRO
!	Some needed macros to define the data record for a bucket
!
	IRC$L_RRV_VBN	= 3,0,32,0%,	! RRV VBN Pointer
	IRC$L_RRV_VBN3	= 5,0,32,0%,	! RRV VBN Pointer (Prologue 3)
	IRC$W_VAR_SIZ	= 7,0,16,0%,	! Var. Rec. Format Size field
	IRC$L_DUPCOUNT	= 2,0,32,0%,	! Duplicate count field
	IRC$W_DUPSZ	= 6,0,16,0%,	! Size field when dup. are allowed
	IRC$W_NODUPSZ	= 2,0,16,0%,	! Size field when dup. are not allowed
	IRC$W_P3SZ	= 3,0,16,0%,	! Size field for prologue 3 files

!	These macros make the code look a little better
!
	BKT$W_VBNFS	= .CONV$GW_VBN_FS_PTR,0,16,0%,	! VBN Freespace Pointer in index level
	BKT$W_VBNFS0	= .CONV$GW_VBN_FS_PTR0,0,16,0%,	! VBN Freespace Pointer at the data level
	BKT$L_LCBPTR	= .CONV$GW_LCB_PTR,0,32,0%;	! Last Contuation Bucket Pointer

!	Data Decl. for Fast Load routines
!
GLOBAL
	CONV$GB_KEY_REF	: SIGNED BYTE		! Current Key of Reference NOTE:
				 INITIAL (-1),	! it is init. to -1 to indicate
						! that no key is selected.

	CONV$GL_RECORD_PTR	: LONG,		! Pointer to record bffer

	CONV$GW_VBN_FS_PTR	: WORD,
	CONV$GW_VBN_FS_PTR0	: WORD,
	CONV$GW_LCB_PTR		: WORD,
	
	CONV$GL_CTX_BLOCK	: LONG,		! Pointer to the contex block
	CONV$GL_DUP_BUF		: LONG;		! Pointer to the Duplicate buffer

OWN
	CONTINUATION	: BYTE,		! Continuation bucket
	DUPLICATE	: BYTE,		! Duplicate record

	SAVE_FREESPACE	: WORD,		! Save pointer for backing up index
	SAVE_KEYFRESPC	: WORD,		!   "
	SAVE_VBNFS	: WORD,		!   "

	SIDR_BUF	: LONG,		! Pointer to the SIDR buffer
	SIDR_PTR	: LONG;		! Pointer to present loaction
					!  in SIDR buffer

%SBTTL	'FAST_LOAD'
GLOBAL ROUTINE	CONV$$FAST_LOAD : JSB_REG11 =
!++
!
! Functional Description:
!
!	FAST_LOAD is the driving routine for the fast loading process.  It
!	will load the primary key then sort and load all secondary keys if
!	any.
!
! Calling Sequence:
!
!	CONV$$FAST_LOAD()
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!	none
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!
!	RMS$_EOF or error code
!
! Routines called:
!
!	INIT_FAST_LOAD
!	LOAD_PRIMARY
!	CONV$$END_OF_FILE
!	CONV$$WRITE_PROLOGUE
!	CONV$$SET_KEY_BLOCK
!	CONV$$SORT_SECONDARY
!	LOAD_SECONDARY
!	CONV$$WRITE_KEY_DESC
!
! Side Effects:
!	none
!
!--

    BEGIN

    DEFINE_KEY_BLOCK;
    DEFINE_CTX_GLOBAL;
    DEFINE_BUCKET_GLOBAL;

    ! Init the fast load process
    !
    INIT_FAST_LOAD();

    ! Load the primary data and index
    !
    RET_ON_ERROR( LOAD_PRIMARY() );

    ! Finish off the input file
    !
    CONV$$END_OF_FILE();

    ! Process the secondary keys if any and if there we records put into the
    ! output file.
    !
    ! NOTE: This could cause secondary key indexes to be uninitialized.
    ! At the moment RMS doesn't mind, if they ever do, something must be fixed.
    !
    IF ( .CONV$AB_OUT_XABSUM [ XAB$B_NOK ] GTR 1 ) AND
						( .CONV$GL_VALID_COUNT GTR 0 )
    THEN

	! Loop for each key
	!
	INCR KEY FROM 1 TO ( .CONV$AB_OUT_XABSUM [ XAB$B_NOK ] - 1 )
	DO
	    BEGIN

	    ! Free the space taken up by the last key load
	    !
	    CONV$$FREE_TEMP_VM();

	    ! Write the prologue so that SORT-32 can read the Half Loaded file
	    ! we just made.
	    !
	    CONV$$WRITE_PROLOGUE();

	    ! Set key of ref
	    !
	    RET_ON_ERROR( CONV$$SET_KEY_BLOCK( .KEY ) );

	    ! Set up the sort for the secondary key.  The sort is a INDEX sort.
	    ! This type of sort will produce a file of RFA's and keys of the
	    ! primary data level we just made.
	    !
	    RET_ON_ERROR( CONV$$SORT_SECONDARY() );

	    ! Now that the file is sorted get the data and load it in.
	    !
	    LOAD_SECONDARY()

	    END;

    ! Write prologue for the last time
    !
    CONV$$WRITE_PROLOGUE();

    ! Also write the last key desc. block
    !
    CONV$$WRITE_KEY_DESC();

    RETURN RMS$_EOF

    END;

%SBTTL	'INIT_FAST_LOAD'
ROUTINE	INIT_FAST_LOAD : NOVALUE JSB_REG =
!++
!
! Functional Description:
!
!	Initialize the fast load process.  Get memory for buffers and set up
!	pointers.  There are up to 3 pointers to record buffers at each level
!	RCP, RDP and LKB for level 0 and prologue 3 files.  The RCP, LKP and
!	RDP for all but level 0 pointers are set here.  The proper sizes are:
!
!				-----------------------------------------
!	LEVEL 0		RCP --->|	max_key + 13			|
!				-----------------------------------------
!
!				-----------------------------------------
!	LEVEL 1+	RCP --->|	5				|
!				-----------------------------------------
!
!				-----------------------------------------
!			RDP --->|	max_key + 2			|
!				-----------------------------------------
!
!				-----------------------------------------
!	ALL LEVELS	LKP --->|	max_key				|
!				-----------------------------------------
!
!	The RDP for level 0 is set in load_primary and load_secondary.
!
! Calling Sequence:
!
!	INIT_FAST_LOAD();
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!	none
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!	none
!
! Routines Called:
!
!	CONV$$SET_KEY_BLOCK
!	CONV$GET_VM
!
! Side Effects:
!
!	Sets the end of file VBN pointer.  Allocates memory for record buffers.
!	Sets up the record data pointers, record control pointers and last key
!	pointers.
!
!--

    BEGIN

    DEFINE_CTX;
    DEFINE_BUCKET;
    DEFINE_KEY_BLOCK;

    ! Since we are doing block IO we dont need the XABs anymore
    ! If they are keep around area xabs (if any) will override the fab during
    ! an extend a screw everything up.
    !
    CONV$AB_OUT_FAB [ FAB$L_XAB ] = 0;

    ! Since reading the prologue etc. the output rab can be changed so
    ! save the record pointer now
    !
    CONV$GL_RECORD_PTR = .CONV$AB_OUT_RAB [ RAB$L_RBF ];

    ! Find the end of file VBN. In a new file it the one block past the last
    ! allocated area (the last area may not be allocated therefore look at
    ! one)
    !
    BEGIN		! HIGH_VBN local

    LOCAL	HIGH_VBN;

    HIGH_VBN = 0;

    INCR AREA FROM 0 TO ( .CONV$AB_OUT_XABSUM [ XAB$B_NOA ] - 1 ) BY 1
    DO

	! If the current extent starts at a higher VBN then the last one
	! us this one to find the end of file
	!
	IF .CONV$AR_AREA_BLOCK [ .AREA,AREA$L_CVBN ] GTR .HIGH_VBN
	THEN

	    ! The end of file is this the start of this extent plus the number
	    ! of blocks in the extent
	    !
	    CONV$GL_EOF_VBN = .CONV$AR_AREA_BLOCK [ .AREA,AREA$L_CVBN ] +
				.CONV$AR_AREA_BLOCK [ .AREA,AREA$L_CNBLK ];

    END;		! HIGH_VBN local

    BEGIN		! MAX_KEY local

    LOCAL	MAX_KEY;

    ! Calculate the max space needed for index key buffers and init. the contex
    ! block
    !
    MAX_KEY = 0;

    ! The max. size is the size of the logest key.  So we check each key desc.
    !
    INCR  I FROM 0 TO ( .CONV$AB_OUT_XABSUM [ XAB$B_NOK ] - 1 ) BY 1
    DO
	BEGIN

	RET_ON_ERROR( CONV$$SET_KEY_BLOCK( .I ) );

	IF .KEY_BLOCK [ KEY$B_KEYSZ ] GTR .MAX_KEY
	THEN
	    MAX_KEY = .KEY_BLOCK [ KEY$B_KEYSZ ];

	END;

    BEGIN	! Global register block

    LOCAL
	BYTES,
	VM_POINTER;

    ! Figure the total number of bytes. (SEE ABOVE)
    !
    BYTES = ( .MAX_KEY * ( MAX_IDX_LVL + 1 ) ) + ( MAX_IDX_LVL * 7 ) + 13;

    ! For Prologue 3 files we may need the last key buffers
    !
    IF .CONV$GB_PROL_V3
    THEN
	BYTES = .BYTES + ( .MAX_KEY * ( MAX_IDX_LVL - 1 ) );

    ! Add the space for the contex block
    !
    BYTES = .BYTES + ( MAX_IDX_LVL * CTX$K_BLN );

    ! Get the space
    !
    VM_POINTER = CONV$$GET_VM ( .BYTES );

    ! Zero the memory
    !
    CH$FILL( 0,.BYTES,.VM_POINTER );

    CONV$GL_CTX_BLOCK = .VM_POINTER

    END;	! Global register block

    ! Set all of the record control pointers and record data pointers for
    ! level one (1) and above.
    !
    CTX = .CONV$GL_CTX_BLOCK;

    CTX [ CTX$L_RCP ] = .CTX + ( MAX_IDX_LVL * CTX$K_BLN );

    BEGIN	! BUFFER_OFFSET local

    LOCAL	BUFFER_OFFSET;

    BUFFER_OFFSET = .CTX [ CTX$L_RCP ] + .MAX_KEY + 13;

    INCR I FROM 1 TO ( MAX_IDX_LVL - 1 ) BY 1
    DO
	BEGIN
	CTX = .CTX + CTX$K_BLN;
	CTX [ CTX$B_LVL ] = .I;
	CTX [ CTX$L_RCP ] = .BUFFER_OFFSET;
	CTX [ CTX$L_RDP ] = .BUFFER_OFFSET + 5;
	BUFFER_OFFSET = .BUFFER_OFFSET + .MAX_KEY + 7
	END;

    ! Set up the last key buffer for level 0
    !
    CTX = .CONV$GL_CTX_BLOCK;
    CTX [ CTX$L_LKP ] = .BUFFER_OFFSET;

    ! Set up the last key buffer if necessary for levels 1 and above
    !
    IF .CONV$GB_PROL_V3
    THEN
	INCR I FROM 1 TO ( MAX_IDX_LVL - 1 ) BY 1
	DO
	    BEGIN
	    CTX = .CTX + CTX$K_BLN;
	    BUFFER_OFFSET = .BUFFER_OFFSET + .MAX_KEY;
	    CTX [ CTX$L_LKP ] = .BUFFER_OFFSET
	    END

    END		! BUFFER_OFFSET local

    END;	! MAX_KEY local

    RETURN

    END;

%SBTTL	'LOAD_PRIMARY'
ROUTINE	LOAD_PRIMARY : JSB_REG =
!++
!
! Functional Description:
!
!	Loads the primary key of a index sequential file.
!
! Calling Sequence:
!
!	LOAD_PRIMARY()
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!	none
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!
!	RMS$_EOF or error codes
!
! Routine Called:
!
!	CONV$$SET_KEY_BLOCK
!	CONV$$GET_TEMP_VM
!	CONV$$GET_BUCKET
!	CONV$$GET_RECORD
!	CONV$$EXCEPTION
!	CONV$$SPLIT_DATA
!	LOAD_DATA_BUCKET
!	FINISH_INDEX
!
! Side Effects:
!
!	Loads primary key
!
!--

    BEGIN

    LABEL
	DUP_BLK;

    DEFINE_CTX;
    DEFINE_BUCKET;
    DEFINE_KEY_BLOCK;

    CTX = .CONV$GL_CTX_BLOCK;

    ! Set key to the primary index
    !
    CONV$$SET_KEY_BLOCK(0);

    ! Errors on the rab from now on are WRITEERRs
    !
    CONV$AB_OUT_RAB [ RAB$L_CTX ] = CONV$_WRITEERR;

    ! For prologue 3 files we need an extra buffer for the data record
    ! Else we let the REC_DATA_PTR point to the user buffer of the output rab
    !
    IF .CONV$GB_PROL_V3
    THEN
	BEGIN

	LOCAL	BYTES;

	! The worst case is fully non compressed record with compression info
	!
	BYTES = .CONV$GW_MAX_REC_SIZ + 3;

	! Get the space for the data buffer
	!
	! Record data pointer at level 0 will point to the new buffer
	!
	CTX [ CTX$L_RDP ] = CONV$$GET_TEMP_VM ( .BYTES )

	END
    ELSE

	! Record data pointer at level 0 points to Record Ptr
	!
	CTX [ CTX$L_RDP ] = .CONV$GL_RECORD_PTR;

    ! Get the Buckets for the data area and at least the first level of the index
    !
    ! Get the bucket for level 0
    !
    CONV$$GET_BUCKET( .KEY_BLOCK [ KEY$B_DANUM ] );

    KEY_BLOCK [ KEY$L_LDVBN ] = .CTX [ CTX$L_VBN ];

    ! Get the bucket for level 1
    !
    CTX = .CTX + CTX$K_BLN;
    CONV$$GET_BUCKET( .KEY_BLOCK [ KEY$B_LANUM ] );

    CTX = .CONV$GL_CTX_BLOCK;

    ! For the primary key the Data comes from GET_RECORD. NOTE: Don't use the
    ! UBF of the input RAB since some record conversion may be done. Also note
    ! the RBF pointer of the output RAB is destroyed after the first call to
    ! WRITE_BUCKET but it is ok to use it now.
    !
    BEGIN

    LOCAL
	RECORD_CTRL	: REF BLOCK [ ,BYTE ],
	STATUS;

    RECORD_CTRL = .CTX [ CTX$L_RCP ];

    ! Main record processing loop.  The call to GET_RECORD does any record format
    ! processing and exception handling before it returns.  The size of the record
    ! is passed back by OUT_REC_SIZ.
    !
    WHILE ( STATUS = CONV$$GET_RECORD() )
    DO
	BEGIN		! Main Loop

DUP_BLK:
	BEGIN		! DUP_BLK Primary duplicate block

	! If the record is shorter the minium record length of the primary key
	! cause an exception
	!
	IF .CONV$GW_OUT_REC_SIZ LSS .KEY_BLOCK [ KEY$W_MINRECSZ ]
	THEN
	    BEGIN

	    LOCAL STATUS;

	    ! If it was not fatal continue else exit
	    !
	    IF STATUS = CONV$$EXCEPTION( CONV$_RSK )
	    THEN
		LEAVE DUP_BLK
	    ELSE
		RETURN .STATUS
	    END;

	! Seperate the key from the data record if necessary and do
	! data compression if necessary also check if this is a duplicate
	!
	DUPLICATE = CONV$$SPLIT_DATA();

	! If this the first record in the bucket ignore the Dup
	! else check to see it it was an error
	!
	IF .CTX [ CTX$V_FST ]
	THEN
	    CTX [ CTX$V_FST ] = _CLEAR
	ELSE

	    ! If we got a dup and we dont allow dups then cause an exception
	    !
	    IF .DUPLICATE AND ( NOT .KEY_BLOCK [ KEY$V_DUPKEYS ] )
	    THEN
		BEGIN

		LOCAL	STATUS;

		! If not fatal exception then continue else bomb
		!
		IF STATUS = CONV$$EXCEPTION ( CONV$_DUP )
		THEN
		    LEAVE DUP_BLK
		ELSE
		    RETURN .STATUS
		END;

	! Set up the control byte for the record
	!
	RECORD_CTRL [ IRC$B_CONTROL ] = 2;

	! Set the size field int the record
	!
	IF .CONV$GB_PROL_V3
	THEN
	    BEGIN

	    ! A small non compressed fixed length record has no size field
	    !
	    IF .KEY_BLOCK [ KEY$V_REC_COMPR ] OR
		.KEY_BLOCK [ KEY$V_KEY_COMPR ] OR
		( .CONV$AB_OUT_FAB [ FAB$B_RFM ] EQLU FAB$C_VAR )
	    THEN
		RECORD_CTRL [ 9,0,16,0 ] = .CTX [ CTX$W_RCS ] +
							.CTX [ CTX$W_RDS ] - 11
	    END
	ELSE

	    ! Set up the record size for var. length records 
	    ! for prologue 1 and 2 files
	    !
	    IF .CONV$AB_OUT_FAB [ FAB$B_RFM ] EQLU FAB$C_VAR
	    THEN
		RECORD_CTRL [ IRC$W_VAR_SIZ ] = .CONV$GW_OUT_REC_SIZ;

	! If we are in a continuation bucket and the current record is NOT a
	! duplicate then write the current bucket out and start a new one
	!
	! For optimumization do the continuation check first
	!
	IF .CONTINUATION THEN IF NOT .DUPLICATE
	THEN
	    BEGIN

	    CONV$$WRITE_BUCKET();

	    CONV$$INIT_BUCKET();

	    ! Continuation no longer need be set.  (the next record will always
	    ! fix into the new bucket
	    !
	    CONTINUATION = _CLEAR

	    END;

	! Load the record
	!
	LOAD_DATA_BUCKET()

	END		! DUP_BLK Primary duplicate block
	END;		! Main loop

    ! If we exited because of end of file the finish off the index
    !
    IF ( .STATUS EQLU RMS$_EOF )
    THEN
	FINISH_INDEX();

    RETURN CONV$_SUCCESS

    END
    END;


%SBTTL	'LOAD_SECONDARY'
ROUTINE	LOAD_SECONDARY : NOVALUE JSB_REG =
!++
!
! Functional Description:
!
!	Loads a secondary key of an index sequential file.  Which secondary
!	index depends on KEY_REF which is set by SORT_SECONDARY.  The secondary
!	data records are read from the RFA file created and opened by
!	SORT_SECONDARY.  NOTE:  The overall operation of LOAD_SECONDARY is
!	fundementally different then LOAD_PRIMARY.
!
! Calling Sequence:
!
!	LOAD_SECONDARY();
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!	none
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!
!	RMS$_EOF or error codes
!
! Routines Called:
!
!	CONV$$GET_BUCKET
!	CONV$$GET_TEMP_VM
!	$GET
!	CONV$$CHECK_NULL
!	CONV$$CHECK_S_DUP
!	LOAD_DATA_BUCKET
!	CONV$$COPY_KEY
!	CONV$$WRITE_BUCKET
!	CONV$$INIT_BUCKET
!	CONV$$CONVERT_VBN_ID
!	STUFF_SIDR_ARRAY
!	FINISH_INDEX
!
! Side Effects:
!
!	Loads secondary index defined by KEY_REF
!
!--

    BEGIN

    DEFINE_CTX;
    DEFINE_BUCKET;
    DEFINE_KEY_BLOCK;

    LABEL
	NULL_BLK;

    LOCAL
	DUP_COUNT,
	MAX_NUM_DUP;

    ! Init some values
    !
    CONTINUATION = _CLEAR;
    DUPLICATE = _CLEAR;

    ! Errors on the rab from now on are WRITEERRs
    !
    CONV$AB_OUT_RAB [ RAB$L_CTX ] = CONV$_WRITEERR;

    ! Point to the first block
    !
    CTX = .CONV$GL_CTX_BLOCK;

    ! Get the Buckets for the secondary data area and at least the
    ! first level of the index
    !
    ! Get the bucket for level 0
    !
    CONV$$GET_BUCKET( .KEY_BLOCK [ KEY$B_DANUM ] );

    KEY_BLOCK [ KEY$L_LDVBN ] = .CTX [ CTX$L_VBN ];

    ! Get the bucket for level 1
    !
    CTX = .CTX + CTX$K_BLN;
    CONV$$GET_BUCKET( .KEY_BLOCK [ KEY$B_LANUM ] );

    CTX = .CONV$GL_CTX_BLOCK;

    ! Before we start we need to calcluate the size of the level 0 index record
    ! buffer.  This calculation is VERY important it must be very accurate!
    !
    ! If we allow dup. keys the it becomes complicated
    !
    ! Find out the max. number of duplicates that can fit in this bucket
    !
    IF .KEY_BLOCK [ KEY$V_DUPKEYS ]
    THEN

	! Sizes are different for prologue 3
	!
	IF .CONV$GB_PROL_V3
	THEN

	    ! For compression it is also different
	    !
	    IF .KEY_BLOCK [ KEY$V_IDX_COMPR ]
	    THEN

		! The space in the bucket minus the key size and the record 
		!	overhead (2+5) divided by the size of the SIDR record
		!	pointer (7)
		!
		MAX_NUM_DUP = ( .CTX [ CTX$W_SPC ] -
				    ( .KEY_BLOCK [ KEY$B_KEYSZ ] + 7 ) ) / 7
	    ELSE

		! The space in the bucket minus the key size and the record 
		!	overhead (5) divided by the size of the SIDR record
		!	pointer (7)
		!
		MAX_NUM_DUP = ( .CTX [ CTX$W_SPC ] -
				    ( .KEY_BLOCK [ KEY$B_KEYSZ ] + 5 ) ) / 7

	ELSE

	    ! The space in the bucket minus the key size and the record 
	    !		overhead (8) divided by the size of the SIDR record
	    !		pointer (6)
	    !
	    MAX_NUM_DUP = ( .CTX [ CTX$W_SPC ] -
				    ( .KEY_BLOCK [ KEY$B_KEYSZ ] + 8 ) ) / 6
    ELSE
	MAX_NUM_DUP = 1;

    BEGIN

    LOCAL
	BYTES,
	VM_POINTER;

    ! The size of the level 0 buffer consist of:
    !	the space needed for record data buffer which is:
    !		RRVs (one for each dup) + prologue 3 overhead (3 bytes)
    !	a buffer for duplicates (size of the key)
    !	[for prologue 3] a buffer for the SIDR chain (size of the bucket)
    !
    BYTES = ( .MAX_NUM_DUP * 7 ) + 3 + .KEY_BLOCK [ KEY$B_KEYSZ ];

    ! For prologue 3 files we need an extra buffer about the size
    ! of the bucket for the SIDR VBN chain
    !
    IF .CONV$GB_PROL_V3
    THEN
	BYTES = .BYTES + .CTX [ CTX$L_SIZ ];

    ! Allocate the memory for the buffer
    !
    VM_POINTER = CONV$$GET_TEMP_VM ( .BYTES );

    ! The level 0 data record pointers points to this buffer
    !
    CTX [ CTX$L_RDP ] = .VM_POINTER;

    ! The duplicate buffer is just past that
    !
    CONV$GL_DUP_BUF =  .VM_POINTER + ( .MAX_NUM_DUP * 7 ) + 3;

    ! Set up the SIDR buffer if necessary
    !
    IF .CONV$GB_PROL_V3
    THEN
	BEGIN

	! The buffer is just past the record buffer
	!
	SIDR_BUF = .CONV$GL_DUP_BUF + .KEY_BLOCK [ KEY$B_KEYSZ ];
	SIDR_PTR = .SIDR_BUF
	END

    END;

    ! For the secondary key the Data comes from $GET on the RFA RAB
    !
    BEGIN		! RECORD_CTRL local

    LOCAL
	SKIP,
	RECORD_CTRL	: REF BLOCK [ ,BYTE ],
	STATUS;

    SKIP = _CLEAR;

    ! The record control bytes are keep in different parts of the record
    ! for prologue 3 sidrs
    !
    IF .CONV$GB_PROL_V3
    THEN
	RECORD_CTRL = .CTX [ CTX$L_RDP ]
    ELSE
	RECORD_CTRL = .CTX [ CTX$L_RCP ];

    ! Main record processing loop. The size of the record is returned in
    ! RFA_RAB [ RAB$W_RSZ ]
    !
    WHILE ( STATUS = $GET( RAB=CONV$AB_RFA_RAB ) )
    DO
	BEGIN		! Main Loop

NULL_BLK:
	BEGIN		! NULL_BLK null key value block

	LOCAL	DUP;

	! If the record is too short (does not contain the complete key)
	! then treat it as a null key
	!
	IF ( .CONV$AB_RFA_RAB [ RAB$W_RSZ ] - 6 ) LSSU .KEY_BLOCK [ KEY$B_KEYSZ ]
	THEN
	    LEAVE NULL_BLK;

	! If the file allows null keys check to see if this is one
	!
	IF .KEY_BLOCK [ KEY$V_NULKEYS ]
	THEN

	    ! If this is a null key then just ignore this record
	    !
	    IF CONV$$CHECK_NULL()
	    THEN
		LEAVE NULL_BLK;

	! Check to see if this is a duplicate.
	!
	DUP = CONV$$CHECK_S_DUP();

	! Process the key
	!
	IF .KEY_BLOCK [ KEY$V_DUPKEYS ]
	THEN
	    BEGIN

	    ! If this was a dup 
	    !
	    IF .DUP
	    THEN
		BEGIN

		DUP_COUNT = .DUP_COUNT + 1;

		! If we have exceeded the max number of dups per bucket then
		! get rid of this bucket and start a new one
		!
		IF .DUP_COUNT GEQ .MAX_NUM_DUP
		THEN
		    BEGIN

		    LOAD_DATA_BUCKET();

		    ! The record to go into the next bucket will be a duplicate
		    !
		    DUPLICATE = _SET;

		    ! We are now in a continuation bucket
		    !
		    SKIP = _SET;

		    ! Copy the key into the record (in a continuation bucket
		    ! there is no dup count ie. the 4)
		    !
		    CONV$$COPY_KEY ( 4 );

		    ! Start counting dups again
		    !
		    DUP_COUNT = 0;

		    ! Set some control fields
		    !
		    IF .CONV$GB_PROL_V3
		    THEN
			BEGIN

			! Prologue 3 records have the control info in the RD
			! buffer (1 control,2 ID,2 Size)
			!
			CTX [ CTX$W_RDS ] = 5;

			! Zero the size field
			!
			RECORD_CTRL [ IRC$W_P3SZ ] = 0

			END
		    ELSE
			BEGIN

			CTX [ CTX$W_RDS ] = 0;

			! A continuation record has no duplicate pointer
			!
		    	RECORD_CTRL [ IRC$B_CONTROL ] = IRC$M_NOPTRSZ;

			! Prologue 1,2 size field includes a key
			!
		    	RECORD_CTRL [ IRC$W_NODUPSZ ] = .KEY_BLOCK [ KEY$B_KEYSZ ]

			END
		    END
		END
	    ELSE
		BEGIN

		! If this is the first non-dup then don't load anything else
		! load the last record processed
		!
		IF NOT .CTX [ CTX$V_FST ]
		THEN
		    BEGIN

		    LOAD_DATA_BUCKET();

		    ! The next record will not be a duplicate record
		    !
		    DUPLICATE = _CLEAR;

		    ! If we were in a continuatio bucket then dont make an index
		    ! for it. Also write the bucket because we don't put anything
		    ! in a bucket after a dup.
		    !
		    IF .SKIP
		    THEN
			BEGIN
			SKIP = _CLEAR;

!			IF .CONV$GB_PROL_V3
!			THEN
!			    STUFF_SIDR_ARRAY();

			CONV$$WRITE_BUCKET();
			CONV$$INIT_BUCKET();

			! The next record will always fit into the new bucket
			! so clearing the continuation flag is ok
			!
			CONTINUATION = _CLEAR

			END
		    END;

		! Copy the key into the record past the dup count field (ie the 8)
		!
		CONV$$COPY_KEY ( 8 );

		! Start counting the dups
		!
		DUP_COUNT = 0;

		! Set some control fields
		!
		IF .CONV$GB_PROL_V3
		THEN
		    BEGIN

		    ! Prologue 3 records have the control info in the RD buffer
		    ! (1 control,2 ID,2 Size)
		    !
		    CTX [ CTX$W_RDS ] = 5;

		    ! Zero the size field
		    !
		    RECORD_CTRL [ IRC$W_P3SZ ] = 0

		    END
		ELSE
		    BEGIN

		    CTX [ CTX$W_RDS ] = 0;

		    ! The size of the dup pointer (1=4bytes)
		    !
		    RECORD_CTRL [ IRC$B_CONTROL ] = 1;

		    ! Zero the field (not implemented)
		    !
		    RECORD_CTRL [ IRC$L_DUPCOUNT ] = 0;

		    ! Prologue 1,2 size field includes a key
		    !
		    RECORD_CTRL [ IRC$W_DUPSZ ] = .KEY_BLOCK [ KEY$B_KEYSZ ]

		    END

		END;

	    ! Add to the size of the dup for this record.
	    !
	    ( IF .CONV$GB_PROL_V3
	    THEN

		! A prologue 3 RRV is 7 bytes (1 control,2 ID,4 VBN)
		!
		RECORD_CTRL [ IRC$W_P3SZ ] = .RECORD_CTRL [ IRC$W_P3SZ ] + 7

	    ELSE
		BEGIN

		! A prologue 1,2 RRV is 6 bytes (1 control,1 ID,4 VBN )
		!
		IF .RECORD_CTRL [ IRC$V_NOPTRSZ ]
		THEN
		    RECORD_CTRL [ IRC$W_NODUPSZ ] =
					    .RECORD_CTRL [ IRC$W_NODUPSZ ] + 6
		ELSE
		    RECORD_CTRL [ IRC$W_DUPSZ ] =
					    .RECORD_CTRL [ IRC$W_DUPSZ ] + 6
		END )

	    END
	ELSE
	    BEGIN

	    ! If the keys are duplicate and we are not allowing dup. then error
	    !
	    IF .DUP
	    THEN
		SIGNAL_STOP( CONV$_LOADIDX,1,.CONV$GB_KEY_REF,RMS$_DUP );

	    ! If this is the first record don't load anything else load the
	    ! last record
	    !
	    IF NOT .CTX [ CTX$V_FST ]
	    THEN
		LOAD_DATA_BUCKET();

	    ! Move the key value
	    !
	    CONV$$COPY_KEY ( 4 );

	    ! Set some control fields
	    !
	    IF .CONV$GB_PROL_V3
	    THEN
		BEGIN

		! Prologue 3 records have the control info in the RD buffer
		! (1 control,2 ID,2 Size)
		!
		CTX [ CTX$W_RDS ] = 5;

		! Set the size field
		!
		RECORD_CTRL [ IRC$W_P3SZ ] = 7

		END
	    ELSE
		BEGIN

		! For prologue 1,2 files the RRV starts at the beginning
		!
		CTX [ CTX$W_RDS ] = 0;

		! Non dup records don't have a dup count
		!
		RECORD_CTRL [ IRC$B_CONTROL ] = IRC$M_NOPTRSZ;

		RECORD_CTRL [ IRC$W_NODUPSZ ] = .KEY_BLOCK [ KEY$B_KEYSZ ] + 6

		END

	    END;

	! Load the SIDR array pointer
	!
	BEGIN	! SIDR local

	DEFINE_VBN_ID_GLOBAL;

	LOCAL	SIDR	: REF BLOCK [ ,BYTE ];

	! Convert the VBN and the ID that SORT returns in the file
	!
	CONV$$CONVERT_VBN_ID();

	! Move the record pointer right after the last one, if any
	!
	SIDR = .CTX [ CTX$L_RDP ] + .CTX [ CTX$W_RDS ];

	! If prologue 3 the ID is bigger
	!
	IF .CONV$GB_PROL_V3
	THEN
	    BEGIN
	    SIDR [ 0,0,8,0 ] = 2;
	    SIDR [ 1,0,16,0 ] = .SORT_ID;
	    SIDR [ 3,0,32,0 ] = .SORT_VBN;
	    CTX [ CTX$W_RDS ] = .CTX [ CTX$W_RDS ] + 7
	    END
	ELSE
	    BEGIN
	    SIDR [ 0,0,8,0 ] = 2;
	    SIDR [ 1,0,8,0 ] = .SORT_ID;
	    SIDR [ 2,0,32,0 ] = .SORT_VBN;
	    CTX [ CTX$W_RDS ] = .CTX [ CTX$W_RDS ] + 6
	    END

	END;		! SIDR local

	! If we are here then we have processed at least one non null record
	!
	CTX [ CTX$V_FST ] = _CLEAR;

	! If this is a non dup key then copy it into the last key buffer
	!
	IF NOT .DUP
	THEN
	    CH$MOVE ( .KEY_BLOCK [ KEY$B_KEYSZ ],
			.CONV$GL_DUP_BUF,
			.CTX [ CTX$L_LKP ] )

	END		! NULL_BLK null key value block

	END;		! Main loop

    ! If we exited because of end of file the finish off the index
    !
    IF .STATUS EQL RMS$_EOF
    THEN
	BEGIN

	! There is a SIDR record left over at this point
	! We must load it in before we finish off the index
	!
	LOAD_DATA_BUCKET();

!	! If prologue 3 then the sidrs left over have not had there
!	! pointers stuffed into the bucket so do it here
!	!
!	IF .CONV$GB_PROL_V3
!	THEN
!	    STUFF_SIDR_ARRAY();

	FINISH_INDEX()

	END;

    RETURN

    END		! RECORD_CTRL local

    END;

%SBTTL	'LOAD_DATA_BUCKET'
ROUTINE	LOAD_DATA_BUCKET : NOVALUE JSB_REG =
!++
!
! Functional Description:
!
!	Loads a data bucket independent of key of reference in the
!	index.  On a call to LOAD_DATA_BUCKET a record is loaded into a bucket
!	and return.  If the record for some reason does not fit into the current
!	bucket an index is made for the bucket and the bucket is written to the
!	output file.  The written bucket is initialized and then loaded with
!	the original record.  The index for a bucket is made by calling
!	LOAD_INDEX_BUCKET.
!
! Calling Sequence:
!
!	LOAD_DATA_BUCKET();
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!
!	SS$NORMAL or error codes
!
! Routines Called:
!
!	CONV$$GET_BUCKET
!	LOAD_INDEX_BUCKET
!	CONV$$SAVE_BUCKET
!	CONV$$WRITE_BUCKET
!	CONV$$INIT_BUCKET
!	CONV$$RESTORE_BUCKET
!	CONV$$COMPRESS_KEY
!	CONV$$MAKE_INDEX
!	CONV$$WRITE_VBN
!
! Side Effects:
!
!	Loads a record into a bucket.  Writes buckets and creates indexs
!	for lower level buckets
!
!--

    BEGIN

    DEFINE_CTX;
    DEFINE_BUCKET;
    DEFINE_KEY_BLOCK;

    ! Set the bucket pointer to the bucket at this level
    !
    BUCKET = .CTX [ CTX$L_PTR ];

    ! Will the record fit into the bucket, if not then call this thing
    ! with an index to the record.
    !
    ! A record will not fit into a bucket if:
    !
    !	For all files:
    !
    ! a) the combined record data size and record control size is greater then
    !	 the space availaible in the bucket.
    !
    ! b) the FILL switch is OFF and the space left in the bucket is less then
    !	 that allowed by bucket fill quanities
    !
    !	For prologue 1 & 2 files:
    !
    ! c) the record ID of the new record is 0 indicating that the bucket is
    !	 filled (as far as id are concerned)
    !
    IF ( ( ( .CTX [ CTX$W_RDS ] + .CTX [ CTX$W_RCS ] ) GTRU
							.CTX [ CTX$W_SPC ] ) OR
	( IF .CONV$GB_PROL_V3
	  THEN	0
	  ELSE	.BUCKET [ BKT$B_NXTRECID ] EQLU 0 ) OR
	( ( NOT .CONV$GL_FILL ) AND
			( .CTX [ CTX$W_USE ] GEQU .KEY_BLOCK [ KEY$W_DATFILL ]) ) )
    THEN
	BEGIN	! Load index block

	! If for some reason we dont want to make an index entry for this
	! record then skip it.
	!
	IF NOT .CONTINUATION
	THEN
	    BEGIN

	    ! Increse the level number for the next index level
	    !
	    CTX = .CTX + CTX$K_BLN;

	    ! Call to LOAD_INDEX_BUCKET to load the next level of the index
	    !
	    LOAD_INDEX_BUCKET();

	    ! Return the level
	    !
	    CTX = .CTX - CTX$K_BLN;

	    ! Restore the bucket pointer to the current level bucket since
	    ! we should be looking at some other one.
	    !
	    BUCKET = .CTX [ CTX$L_PTR ]

	    END;

!	! If this is a prologue 3 secondary key then we must load the VBN
!	! chain into the bucket
!	!
!	IF .CONV$GB_PROL_V3 AND ( .CONV$GB_KEY_REF NEQ 0 )
!	THEN
!	    STUFF_SIDR_ARRAY();

	! Write the bucket we filled
	!
	CONV$$WRITE_BUCKET();

	! If this is a dup then the next bucket is a continuation bucket
	!
	IF .DUPLICATE
	THEN
	    CONTINUATION = _SET
	ELSE
	    CONTINUATION = _CLEAR;

	! Initialize the bucket to use it again
	!
	CONV$$INIT_BUCKET()

	END;	! Load index block

    BEGIN	! BKT_*_PTR local

    ! Load the record into the bucket...
    ! First we must set up pointers to where the record will go in the bucket
    ! These are:
    !
    LOCAL
	BKT_CTRL_PTR,	! Control information
	BKT_DATA_PTR;	! Actual data record

    ! The reason we split them up is because prologue 3 files put the two pieces
    ! in two different places depending on bucket type (ie. INDEX, PRIMARY data
    ! and SECONDARY data bucket.
    !
    ! For Prologue 3 files...
    !
    IF .CONV$GB_PROL_V3
    THEN
	BEGIN

	! Key of ref. specific things
	!
	IF .CONV$GB_KEY_REF EQL 0
	THEN

	    ! The Primary key...
	    !
	    BEGIN

	    LOCAL	    RECORD_CTRL	: REF BLOCK [ ,BYTE ];

	    RECORD_CTRL = .CTX [ CTX$L_RCP ];

	    ! The record ID
	    !
	    RECORD_CTRL [ IRC$W_ID ] = .BUCKET [ BKT$W_NXTRECID ];

	    ! The RRV points to it's self ie. it's own ID and VBN
	    !
	    RECORD_CTRL [ IRC$W_RRV_ID ] = .BUCKET [ BKT$W_NXTRECID ];
	    RECORD_CTRL [ IRC$L_RRV_VBN3 ] = .CTX [ CTX$L_VBN ];

	    ! If key compression is on do it
	    !
	    IF .KEY_BLOCK [ KEY$V_KEY_COMPR ]
	    THEN
		CONV$$COMPRESS_KEY();

	    ! For the primary data level the control bytes are put at
	    ! the bucket freespace.  The data bytes are put directly
	    ! after the control.
	    !
	    BKT_CTRL_PTR = .BUCKET [ BKT$W_FREESPACE ] + .BUCKET;
	    BKT_DATA_PTR = .BKT_CTRL_PTR + .CTX [ CTX$W_RCS ];

	    ! Update the bucket pointer
	    !
	    BUCKET [ BKT$W_FREESPACE ] = .BUCKET [ BKT$W_FREESPACE ] +
						.CTX [ CTX$W_RDS ] +
						.CTX [ CTX$W_RCS ]
	    END
	ELSE
	    BEGIN
!
!	    ! The Secondary key...
!	    !
!	    LOCAL	    RECORD_CTRL	: REF BLOCK [ ,BYTE ];
!
!	    RECORD_CTRL = .CTX [ CTX$L_RDP ];
!
!	    ! The record ID
!	    !
!	    RECORD_CTRL [ IRC$W_ID ] = .BUCKET [ BKT$W_NXTRECID ];
!
!	    ! For the secondary data level the control bytes are put at the
!	    ! key freespace.
!	    !
!	    BKT_CTRL_PTR = .BUCKET [ BKT$W_KEYFRESPC ] + .BUCKET;
!
!	    ! The data bytes are put into the SIDR VBN buffer to be loaded
!	    ! into the bucket at a later time
!	    !
!	    BKT_DATA_PTR = .SIDR_PTR;
!
!	    ! Update the bucket pointers
!	    !
!	    BUCKET [ BKT$W_KEYFRESPC ] = .BUCKET [ BKT$W_KEYFRESPC ] +
!							.CTX [ CTX$W_RCS ];
!
!	    ! Update the SIDR buffer pointer
!	    !
!	    SIDR_PTR = .SIDR_PTR + .CTX [ CTX$W_RDS ]
!
0	    END;

	! Update the record next record id in the bucket
	!
	BUCKET [ BKT$W_NXTRECID ] = .BUCKET [ BKT$W_NXTRECID ] + 1

	END
    ELSE

	! For prologue 1 and 2 files...
	!
	BEGIN

	LOCAL
	    RECORD_CTRL	: REF BLOCK [ ,BYTE ];

	RECORD_CTRL = .CTX [ CTX$L_RCP ];

	! The record ID
	!
	RECORD_CTRL [ IRC$B_ID ] = .BUCKET [ BKT$B_NXTRECID ];

	! If this is the primary data level the set up the RRV
	!
	IF .CONV$GB_KEY_REF EQL 0
	THEN
	    BEGIN

	    ! The RRV points to itself ie. it's own ID and VBN
	    !
	    RECORD_CTRL [ IRC$B_RRV_ID ] = .BUCKET [ BKT$B_NXTRECID ];
	    RECORD_CTRL [ IRC$L_RRV_VBN ] = .CTX [ CTX$L_VBN ]
	    END;

	! Update the next record id in the bucket
	!
	BUCKET [ BKT$B_NXTRECID ] = .BUCKET [ BKT$B_NXTRECID ] + 1;

	! Set some pointers...
	! For prologue 1 and 2 files the control bytes are put at the bucket
	! freespace.  The data bytes are put directly after the control.
	!
	BKT_CTRL_PTR = .BUCKET [ BKT$W_FREESPACE ] + .BUCKET;
	BKT_DATA_PTR = .BKT_CTRL_PTR + .CTX [ CTX$W_RCS ];

	! Update the bucket pointer (NOTE: Same update for all cases)
	!
	BUCKET [ BKT$W_FREESPACE ] = .BUCKET [ BKT$W_FREESPACE ] +
						.CTX [ CTX$W_RCS ] +
						.CTX [ CTX$W_RDS ]
	END;

    ! Load the record into the bucket...
    ! Move the control bytes into the bucket
    !
    CH$MOVE( .CTX [ CTX$W_RCS ],.CTX [ CTX$L_RCP ],.BKT_CTRL_PTR );

    ! Move the data bytes into the bucket
    !
    CH$MOVE( .CTX [ CTX$W_RDS ],.CTX [ CTX$L_RDP ],.BKT_DATA_PTR );

    END;	! BKT_*_PTR local

    ! Update the amount of space left in the bucket and the amount used
    !
    BEGIN

    LOCAL
	SPACE_USED;

    SPACE_USED = .CTX [ CTX$W_RCS ] + .CTX [ CTX$W_RDS ];

    CTX [ CTX$W_SPC ] = .CTX [ CTX$W_SPC ] - .SPACE_USED;

    CTX [ CTX$W_USE ] = .CTX [ CTX$W_USE ] + .SPACE_USED;

    END;

    ! Make an index for the next level
    !
    CONV$$MAKE_INDEX();

    ! Set the index record control bytes and bucket pointer
    !
    CONV$$WRITE_VBN();

    RETURN CONV$_SUCCESS

    END;

%SBTTL	'LOAD_INDEX_BUCKET'
ROUTINE	LOAD_INDEX_BUCKET : NOVALUE JSB_REG =
!++
!
! Functional Description:
!
!	Loads an index bucket independent level in the index.  On a
!	call to LOAD_INDEX_BUCKET a record is loaded into a bucket and
!	return.  If the record for some reason does not fit into the current
!	bucket an index is made for the bucket and the bucket is written to the
!	output file.  The written bucket is initialized and then loaded with
!	the original record.  The index for a bucket is made by calling
!	LOAD_INDEX_BUCKET recursivly. Each recursive call to LOAD_INDEX_BUCKET
!	is to moving up the index tree.  CTX keeps track to where you are in
!	the tree.  Most all variables are dependent on CTX so that the
!	context of each level is saved.
!
! Calling Sequence:
!
!	LOAD_INDEX_BUCKET()
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!	none
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!
!	SS$NORMAL or error codes
!
! Routines Called:
!
!	CONV$$GET_BUCKET
!	LOAD_INDEX_BUCKET	- Recursive call
!	CONV$$WRITE_BUCKET
!	CONV$$INIT_BUCKET
!	CONV$$COMPRESS_INDEX
!	CONV$$WRITE_VBN
!
! Side Effects:
!
!	Loads a record into a bucket.  Writes buckets and creates indexs
!	for lower level buckets
!
!--

    BEGIN

    DEFINE_CTX;
    DEFINE_BUCKET;
    DEFINE_KEY_BLOCK;

    ! Set the bucket pointer to the bucket at this level
    !
    BUCKET = .CTX [ CTX$L_PTR ];

    ! Will the record fit into the bucket, if not then call this thing
    ! with an index to the record.
    !
    ! A record will not fit into a bucket if:
    !
    !	For all files:
    !
    ! a) the combined record data size and record control size is greater then
    !	 the space availaible in the bucket.
    !
    ! b) the FILL switch is OFF and the space left in the bucket is less then
    !	 that allowed by bucket fill quanities
    !
    !	For prologue 3 files:
    !
    ! c) the bucket below has a different size vbn then this bucket (this
    !	 is to keep the same size vbn index buckets)
    !
    IF ( ( ( .CTX [ CTX$W_RDS ] + .CTX [ CTX$W_RCS ] ) GTRU
							.CTX [ CTX$W_SPC ] ) OR
	( ( NOT .CONV$GL_FILL ) AND
		( .CTX [ CTX$W_USE ] GEQU .KEY_BLOCK [ KEY$W_IDXFILL ] ) ) OR
	( IF .CONV$GB_PROL_V3
	  THEN
	      ( LOCAL CTX_M1 : REF BLOCK [ ,BYTE ];
		CTX_M1 = .CTX - CTX$K_BLN;
		IF .BUCKET [ BKT$V_PTR_SZ ] NEQU .CTX_M1 [ CTX$V_VBN ]
		THEN 1
		ELSE 0
		)
	  ELSE 0 ) )
    THEN
	BEGIN	! Load index block

	! See if we have reached the maximun level. (If we have this is the
	! biggest file in the world!)
	!
	IF .CTX [ CTX$B_LVL ] EQLU MAX_IDX_LVL
	THEN
	    SIGNAL_STOP( CONV$_IDX_LIM );

	! Switch for the next index level
	!
	CTX = .CTX + CTX$K_BLN;

	! See if the bucket in at the next level is ready if not get it ready
	!
	IF NOT .CTX [ CTX$V_RDY ]
	THEN

	    ! Get the space for the bucket
	    !
	    CONV$$GET_BUCKET( .KEY_BLOCK [ KEY$B_IANUM ] );

	! Recursive call to LOAD_INDEX_BUCKET to load the next level of the index
	!
	LOAD_INDEX_BUCKET();

	! Return the level
	!
	CTX = .CTX - CTX$K_BLN;

	! Restore the bucket pointer to the current level bucket since
	! we should be looking at some other one.
	!
	BUCKET = .CTX [ CTX$L_PTR ];
	
	! Write the bucket we filled
	!
	CONV$$WRITE_BUCKET();

	! Initialize the bucket to use it again
	!
	CONV$$INIT_BUCKET()

	END;	! Load index block

    BEGIN	! CTX_P1 local

    LOCAL	CTX_P1	: REF BLOCK [ ,BYTE ];

    CTX_P1 = .CTX + CTX$K_BLN;

    ! An index record is made for levels 2 and above ( level 0 and 1 are
    ! made by LOAD_PRIMARY and LOAD_SECONDARY depending on KEY_REF )
    ! NOTE: Do this now because latter the key could get compressed
    !
    CH$MOVE( .CTX [ CTX$W_RDS ],.CTX [ CTX$L_RDP ],.CTX_P1 [ CTX$L_RDP ] );

    ! Set the size of the data record
    !
    CTX_P1 [ CTX$W_RDS ] = .CTX [ CTX$W_RDS ];

    ! Set the size of the control record
    !
    IF .CONV$GB_PROL_V3
    THEN
	CTX_P1 [ CTX$W_RCS ] = .CTX [ CTX$V_VBN ] + 2
    ELSE
	CTX_P1 [ CTX$W_RCS ] = .CTX [ CTX$V_VBN ] + 3

    END;	! CTX_P1 local

    BEGIN	! BKT_*_PTR local

    ! Load the record into the bucket...
    ! First we must set up pointers to where the record will go in the bucket
    ! These are:
    !
    LOCAL
	BKT_CTRL_PTR,	! Control information
	BKT_DATA_PTR;	! Actual data record

    ! The reason we split them up is because prologue 3 files put the two pieces
    ! in two different places depending on bucket type (ie. INDEX, PRIMARY data
    ! and SECONDARY data bucket.
    !
    ! For Prologue 3 files...
    !
    IF .CONV$GB_PROL_V3
    THEN
	BEGIN

	! Prologue 3 files...
	!
	IF .KEY_BLOCK [ KEY$V_IDX_COMPR ]
	THEN
	    CONV$$COMPRESS_INDEX();

	! If level 1 save the pointers so we can backup latter
	!
	IF .BUCKET [ BKT$B_LEVEL ] EQLU 1
	THEN
	    BEGIN
	    SAVE_VBNFS = .BUCKET [ BKT$W_VBNFS ];
	    SAVE_KEYFRESPC = .BUCKET [ BKT$W_KEYFRESPC ]
	    END;

	! Update this pointer first since we go backwards with it
	!
	BUCKET [ BKT$W_VBNFS ] = .BUCKET [ BKT$W_VBNFS ] - .CTX [ CTX$W_RCS ];

	! For the index levels the control bytes are put at the bucket
	! vbn freespace.  The data bytes are put at the key free space.
	!
	BKT_CTRL_PTR = .BUCKET [ BKT$W_VBNFS ] + .BUCKET + 1;
	BKT_DATA_PTR = .BUCKET [ BKT$W_KEYFRESPC ] + .BUCKET;

	! Update the rest of the bucket pointers
	!
	BUCKET [ BKT$W_KEYFRESPC ] = .BUCKET [ BKT$W_KEYFRESPC ] +
							.CTX [ CTX$W_RDS ]

	END
    ELSE

	! For prologue 1 and 2 files...
	!
	BEGIN

	! If level 1 save the pointers so we can backup latter
	!
	IF .BUCKET [ BKT$B_LEVEL ] EQLU 1
	THEN
	    SAVE_FREESPACE = .BUCKET [ BKT$W_FREESPACE ];

	! Set some pointers...
	!
	! For prologue 1 and 2 files the control bytes are put at the bucket
	! freespace.  The data bytes are put directly after the control.
	!
	BKT_CTRL_PTR = .BUCKET [ BKT$W_FREESPACE ] + .BUCKET;
	BKT_DATA_PTR = .BKT_CTRL_PTR + .CTX [ CTX$W_RCS ];

	! Update the bucket pointer (NOTE: Same update for all cases)
	!
	BUCKET [ BKT$W_FREESPACE ] = .BUCKET [ BKT$W_FREESPACE ] +
						.CTX [ CTX$W_RCS ] +
						.CTX [ CTX$W_RDS ];

	END;

    ! Load the record into the bucket...
    ! Move the control bytes into the bucket
    !
    CH$MOVE( .CTX [ CTX$W_RCS ],.CTX [ CTX$L_RCP ],.BKT_CTRL_PTR );

    ! Move the data bytes into the bucket
    !
    CH$MOVE( .CTX [ CTX$W_RDS ],.CTX [ CTX$L_RDP ],.BKT_DATA_PTR );

    END;	! BKT_*_PTR local

    ! Update the amount of space left in the bucket and the amount used
    !
    BEGIN

    LOCAL
	SPACE_USED;

    SPACE_USED = .CTX [ CTX$W_RCS ] + .CTX [ CTX$W_RDS ];

    CTX [ CTX$W_SPC ] = .CTX [ CTX$W_SPC ] - .SPACE_USED;

    CTX [ CTX$W_USE ] = .CTX [ CTX$W_USE ] + .SPACE_USED;

    END;

    ! Set the index record control bytes and bucket pointer
    !
    CONV$$WRITE_VBN();

    RETURN

    END;

%SBTTL	'FINISH_INDEX'
ROUTINE	FINISH_INDEX : NOVALUE JSB_REG =
!++
!
! Functional Description:
!
!	Loads and writes the last buckets in an index.
!
! Calling Sequence:
!
!	FINISH_INDEX()
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!	none
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!
!	CONV$_SUCCESS or error codes
!
! Routines Called:
!
!	CONV$$WRITE_BUCKET
!	BACKUP_INDEX
!	CONV$$CREATE_HIGH_KEY
!	LOAD_INDEX_BUCKET
!
! Side Effects:
!
!	Loads and writes the last buckets in an index.  Deallocates memory used
!	for bucket buffers.
!
!--

    BEGIN

    DEFINE_CTX;
    DEFINE_BUCKET;
    DEFINE_KEY_BLOCK;


    ! Finish off the data level bucket.  The reason why we do ths seperatly
    ! is that there are no more records to go in this bucket.  In the index
    ! levels there are.
    !
    CTX = .CONV$GL_CTX_BLOCK;
    BUCKET = .CTX [ CTX$L_PTR ];
    BUCKET [ BKT$V_LASTBKT ] = _SET;

    ! Write the data level bucket
    !
    CONV$$WRITE_BUCKET();

    ! If the last data bucket was a continuation bucket then backup one
    ! index record an put the high key there
    !
    IF .CONTINUATION
    THEN
	BACKUP_INDEX();

    ! Create the high key index record to finish things off
    !
    CONV$$CREATE_HIGH_KEY();

    ! Write the last index records into the buckets and then write the
    ! buckets out
    !
    ! Move up to level 1
    !
    CTX = .CTX + CTX$K_BLN;

    ! Loop until each level is processed
    !
    WHILE .CTX [ CTX$V_RDY ]
    DO
	BEGIN

	LOCAL	CTX_P1 : REF BLOCK [ ,BYTE ];

	! This call to load bucket will finish off this level bucket and create
	! the index to the next.
	!
	LOAD_INDEX_BUCKET();

	! Before we write out the last bucket set some control info. in it
	!
	BUCKET = .CTX [ CTX$L_PTR ];
	BUCKET [ BKT$V_LASTBKT ] = _SET;

	CTX_P1 = .CTX + CTX$K_BLN;

	! If there is no bucket above this one then this is the root
	!
	IF ( NOT .CTX_P1 [ CTX$V_RDY ] )
	THEN
	    BEGIN
	    BUCKET [ BKT$V_ROOTBKT ] = _SET;
	    KEY_BLOCK [ KEY$B_ROOTLEV ] = .CTX [ CTX$B_LVL ];
	    KEY_BLOCK [ KEY$L_ROOTVBN ] = .CTX [ CTX$L_VBN ];
	    KEY_BLOCK [ KEY$V_INITIDX ] = _CLEAR
	    END;

	! Write the last bucket at this level
	!
	CONV$$WRITE_BUCKET();

	! Clear the bucket ready flag at this level
	!
	CTX [ CTX$V_RDY ] = _CLEAR;

	! Prepare to work on the bucket one level up
	!
	CTX = .CTX_P1

	END;

    ! Make sure the last IO has completed
    !
    $WAIT( RAB=CONV$AB_OUT_RAB );

    ! Any more IO will be Syncronous
    !
    CONV$AB_OUT_RAB [ RAB$V_ASY ] = _CLEAR;

    RETURN

    END;

%SBTTL	'BACKUP_INDEX'
ROUTINE	BACKUP_INDEX : NOVALUE JSB_REG =
!++
!
! Functional Description:
!
! Calling Sequence:
!
!	BACKUP_INDEX()
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!	none
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!	none
!
! Routines Called:
!	none
!
! Side Effects:
!
!	Loads and writes the last buckets in an index.  Deallocates memory used
!	for bucket buffers.
!
!--

    BEGIN

    DEFINE_CTX;
    DEFINE_BUCKET;
    DEFINE_KEY_BLOCK;

    LOCAL
	VBN_SIZE,
	CTX_P1		: REF BLOCK [ ,BYTE ],
	RECORD_CTRL	: REF BLOCK [ ,BYTE ];

    CTX_P1 = .CTX + CTX$K_BLN;

    BUCKET = .CTX_P1 [ CTX$L_PTR ];

    ! If the last data bucket was a continuation bucket then we will be backing
    ! up index record which requires using the vbn in the last record.  We
    ! can fake out conv$$write_vbn (called in conv$$create_high_key) by stuffing
    ! the vbn in the ctx field.  This is ok since it it never referenced again.
    !
    ! Get the size of the vbn in the old record (in bits)
    !
    VBN_SIZE = ( .CTX_P1 [ CTX$V_VBN ] + 2 ) * 8;

    ! Backup the pointers in the bucket above and get the vbn in the record
    !
    IF .CONV$GB_PROL_V3
    THEN
	BEGIN

	! For prologue 3 the vbn is at where we are (they go backwards)
	!
	RECORD_CTRL = .BUCKET [ BKT$W_VBNFS ] + .BUCKET + 1;

	CTX [ CTX$L_VBN ] = .RECORD_CTRL [ 0,0,.VBN_SIZE,0 ];

	BUCKET [ BKT$W_VBNFS ] = .SAVE_VBNFS;
	BUCKET [ BKT$W_KEYFRESPC ] = .SAVE_KEYFRESPC

	END
    ELSE
	BEGIN

	BUCKET [ BKT$W_FREESPACE ] = .SAVE_FREESPACE;

	RECORD_CTRL = .BUCKET [ BKT$W_FREESPACE ] + .BUCKET;

	CTX [ CTX$L_VBN ] = .RECORD_CTRL [ 1,0,.VBN_SIZE,0 ]

	END;

    RETURN

    END;

!%SBTTL	'STUFF_SIDR_ARRAY'
!ROUTINE	STUFF_SIDR_ARRAY : NOVALUE JSB_REG =
!
!    BEGIN
!
!    DEFINE_BUCKET;
!
!    LOCAL
!	ARRAY_SIZ,
!	ARRAY_PTR;
!
!    ! Find the size in bytes of the SIDR VBN array
!    !
!    ARRAY_SIZ = .SIDR_PTR - .SIDR_BUF;
!
!    ! Find where the array should go in the bucket
!    !
!    ARRAY_PTR = ( .BUCKET [ BKT$W_VBNFS0 ] + .BUCKET + 1) - .ARRAY_SIZ;
!
!    ! Move the array into the bucket
!    !
!    CH$MOVE( .ARRAY_SIZ,.SIDR_BUF,.ARRAY_PTR );
!
!    ! Set up the pointer in the bucket
!    !
!    BUCKET [ BKT$W_VBNFS0 ] = .BUCKET [ BKT$W_VBNFS0 ] - .ARRAY_SIZ;
!
!    ! Reset the SIDR VBN pointer
!    !
!    SIDR_PTR = .SIDR_BUF;
!
!    RETURN
!
!    END;
!
END	ELUDOM
