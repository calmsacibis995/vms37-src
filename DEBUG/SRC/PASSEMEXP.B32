MODULE	PASSEMEXP ( ! Semantic Routines for handling expressions
	IDENT = 'V03-000'
	)=
BEGIN
!
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
!++
!
! FACILITY:	VAX-11 PASCAL-SPECIFIC DEBUGGER MODULES
!
! ABSTRACT:
!
!	This routine contains the Semantic routines associated with the
!	expression handling
!
! ENVIRONMENT:	VAX/VMS user mode
!
! AUTHOR: R. Gottlieb, CREATION DATE: 12-March-1980
!
! MODIFIED BY:	P. Hohensee	17-July-1980	Stolen from PASCAL-PLUS
!
!--

REQUIRE 'SRC$:PASPROLOG';

!
! Table of Contents
!
FORWARD ROUTINE
	PAS$_Sem_Addition		: NOVALUE,	! Addition
	PAS$_Sem_AND			: NOVALUE,	! AND
	PAS$_Sem_Append_Integer		: NOVALUE,	! Append integer onto string literal
	PAS$_Sem_Append_String		: NOVALUE,	! Append string literal onto string literal
	PAS$_Sem_Arithmetic_Binary_Op	: NOVALUE,	! general for Math binary ops
	PAS$_Sem_Boolean_Binary_Op	: NOVALUE,	! general for Boolean binary Ops
	PAS$_Sem_Comparison_Binary_Op	: NOVALUE,	! general for Comparisons
	PAS$_Sem_DIV			: NOVALUE,	! DIV
	PAS$_Sem_Divide			: NOVALUE,	! Division
	PAS$_Sem_Equal			: NOVALUE,	! Equal
	PAS$_Sem_Exponentiation		: NOVALUE,	! Exponentiation
	PAS$_Sem_Field			: NOVALUE,	! Field Access
	PAS$_Sem_Float_F		: NOVALUE,	! Floating F Literal
	PAS$_Sem_Float_D		: NOVALUE,	! Floating D Literal
	PAS$_Sem_Float_G		: NOVALUE,	! Floating G Literal
	PAS$_Sem_Float_H		: NOVALUE,	! Floating H Literal
	PAS$_Sem_Function_Call_1	: NOVALUE,	! Function Call
	PAS$_Sem_Function_Call_2	: NOVALUE,	! Function Call
	PAS$_Sem_Greater		: NOVALUE,	! Greater Than
	PAS$_Sem_GreaterEqual		: NOVALUE,	! Greater Than or Equal to
	PAS$_Sem_IN			: NOVALUE,	! IN
	PAS$_Sem_Inclusive_OR		: NOVALUE,	! OR
	PAS$_Sem_Integer		: NOVALUE,	! <Integer Constant>
	PAS$_Sem_Label_Reference	: NOVALUE,	! %LABEL
	PAS$_Sem_Last_Value		: NOVALUE,	! Debug Last Value ('\')
	PAS$_Sem_Less			: NOVALUE,	! Less Than
	PAS$_Sem_LessEqual		: NOVALUE,	! Less Than or Equal to
	PAS$_Sem_Line_Reference		: NOVALUE,	! %LINE
	PAS$_Sem_MOD			: NOVALUE,	! MOD
	PAS$_Sem_Multiply		: NOVALUE,	! Multiply
	PAS$_Sem_Negation		: NOVALUE,	! Negation
	PAS$_Sem_NOT			: NOVALUE,	! NOT
	PAS$_Sem_NotEqual		: NOVALUE,	! Not Equal
	PAS$_Sem_Permanent_Symbol	: NOVALUE,	! Debug Permanent Symbol (%R0 - %PSL)
	PAS$_Sem_REM			: NOVALUE,	! REM
	PAS$_Sem_Set_Binary_Op		: NOVALUE,	! Binary Ops for Sets
	PAS$_Sem_Set_1			: NOVALUE,	! <Set> #1
	PAS$_Sem_Set_2			: NOVALUE,	! <Set> #2
	PAS$_Sem_Set_3			: NOVALUE,	! <Set> #3
	PAS$_Sem_Set_4			: NOVALUE,	! <Set> #4
	PAS$_Sem_String			: NOVALUE,	! String
	PAS$_Sem_Subscript		: NOVALUE,	! Subscripting
	PAS$_Sem_Subtraction		: NOVALUE,	! Subtraction
	PAS$_Sem_UpArrow		: NOVALUE,	! Pointer Reference
	PAS$_Sem_Variable		: NOVALUE,	! Variable
	PAS$_Sem_Variable_Reference	: NOVALUE;	! Variable Reference

!
! External ROUTINEs
!
EXTERNAL ROUTINE
	PAS$_Lex_Enter_Name,				! Enter/Lookup a name in the Name Table

	PAS$_Get_Version,				! Get current version number
	PAS$_Read_Access		: NOVALUE,	! Check read access
	PAS$_Arith_Convert,				! Convert value
	PAS$_Variant_Check		: NOVALUE,	! Check current variant(s) against referenced field
	PAS$_Assign			: NOVALUE,	! Assignments
	PAS$_Create_Type,				! Create Type Entry
	PAS$_Type_Equal,				! Check type compatibility
	PAS$_String,					! Check for character string type
	PAS$_Get_Symbol,				! Look up a symbol in the Debugger RST
	PAS$_Get_Value			: NOVALUE,	! Get address of an object's value
	PAS$_Push_Primary_Operand	: NOVALUE,	! Push a value into the Primary Descriptor
	PAS$_Push_Value_Desc		: NOVALUE;	! Push the contents of a value descriptor
							! onto the expression stack

!
! EXTERNALs
!
EXTERNAL
	! Error Handling
	!
	PAS$_Message_Vector	: LONG,			! Address of address of error message vector

	!
	! Primary Interpreter global storage
	!
	PAS$_Result_Type	: LONG,			! Result Type
							! descriptor (value or primary)
	PAS$_Static_Desc	: PAS$_Primary_Desc;	! Static part of Result Descriptor

EXTERNAL
	PAS$_Token_Positions	: VECTOR [4,LONG],			! Position of tokens in file

	PAS$_TRW_Boolean	: BLOCK [,BYTE],			! Type entry for BOOLEAN
	PAS$_TRW_Char		: BLOCK [,BYTE],			! Type entry for CHAR
	PAS$_TRW_Double		: BLOCK [,BYTE],			! Type entry for DOUBLE
	PAS$_TRW_Integer	: BLOCK [,BYTE],			! Type entry for INTEGER
	PAS$_TRW_Nil		: BLOCK [,BYTE],			! Type entry for NIL
	PAS$_TRW_Quadruple	: BLOCK [,BYTE],			! Type entry for QUADRUPLE
	PAS$_TRW_Real		: BLOCK [,BYTE],			! Type entry for REAL
	PAS$_TRW_Unsigned	: BLOCK [,BYTE];			! Type entry for UNSIGNED

!
! Semantic Analysis Global Storage
!
GLOBAL
	PAS$_Is_Primary			: BYTE UNSIGNED,! True = in Primary Interpreter,
							! False = in Expression Interpreter

	PAS$_Current_Symbol_Header	: LONG,		! Pointer to symbol table head
	PAS$_Current_Symbol_Trailer	: LONG,		! Pointer to symbol table tail
	PAS$_Expr_Depth			: LONG,		! Current Expression Sttack Depth
	PAS$_Expr_Stack			: BLOCKVECTOR [Expr_Stack_Depth, Expr_S_Entry, BYTE]
		FIELD(Expression_Stack_Fields);		! Expression Stack

!
! Special Interpreter Semantic Routines
!
EXTERNAL ROUTINE
	PAS$_Arith_Add,					! Addition
	PAS$_Arith_Sub,					! Subtract
	PAS$_Arith_Mul,					! Multiplication
	PAS$_Arith_Div,					! Division
	PAS$_Arith_Fetch,				! Fetch
	PAS$_Arith_Mod,					! MOD
	PAS$_Arith_Rem,					! REM
	PAS$_Arith_Neg,					! Negate
	PAS$_Arith_Add_Float,				! Floating Addition
	PAS$_Arith_Sub_Float,				! Floating Subtract
	PAS$_Arith_Mul_Float,				! Floating Multiplication
	PAS$_Arith_Div_Float,				! Floating Division
	PAS$_Arith_Neg_Float,				! Floating Negate
	PAS$_Arith_Lor,					! Logical Or
	PAS$_Arith_Land,				! Logical And
	PAS$_Arith_Lnot,				! Logical Not
	PAS$_Arith_Eql,					! Compare Equal
	PAS$_Arith_Neq,					! Compare Not Equal
	PAS$_Arith_Lss,					! Compare Less Than
	PAS$_Arith_Leq,					! Compare Less Than or Equal To
	PAS$_Arith_Gtr,					! Compare Greater Than
	PAS$_Arith_Geq,					! Compare Greater Than or Equal To
	PAS$_Arith_Expo;				! Exponentiation

GLOBAL ROUTINE PAS$_Sem_Addition : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Arithmetic Add, Set Union
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN

    IF  (.BLOCK[.PAS$_Expr_Stack[.PAS$_Expr_Depth-1, Expr_Type], TYP_Class; ,BYTE] EQL TYP_K_Set) AND
	(.BLOCK[.PAS$_Expr_Stack[.PAS$_Expr_Depth,   Expr_Type], TYP_Class; ,BYTE] EQL TYP_K_Set)
    THEN

	! Set Operation, do it
	!
	PAS$_Sem_Set_Binary_Op(Op_Union)

    ELSE

	! Arithmetic Operation
	!
	PAS$_Sem_Arithmetic_Binary_Op(Op_Add);

    END;

GLOBAL ROUTINE PAS$_Sem_AND : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Logical AND
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN

    PAS$_Sem_Boolean_Binary_Op(Op_Land);

    END;

GLOBAL ROUTINE PAS$_Sem_Append_Integer (String_Block) : NOVALUE  =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Append the value on the top of the Expression Stack to a
!	string literal
!
! FORMAL PARAMETERS:
!
!	String_Block	- Address of a pointer to a String Block
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Stack		- The Expression Stack
!	PAS$_Expr_Depth		- Current depth of Expression Stack
!
! IMPLICIT OUTPUTS:
!
!	PAS$_Expr_Stack		- The Expression Stack
!	PAS$_Expr_Depth		- Current depth of Expression Stack
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    BIND
	Char_Expr		= PAS$_Expr_Stack[.PAS$_Expr_Depth, 0, A_]
		: BLOCK [,BYTE] FIELD(Expression_Stack_Fields);

    LOCAL
	Char_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
	Char_Value,
	Current_String_Block	: REF BLOCK [,BYTE] FIELD(STR_Fields),
	New_String_Block	: REF BLOCK [,BYTE] FIELD(STR_Fields);

    Char_Type	= .Char_Expr[Expr_Type];

    IF NOT
	(IF .Char_Type[TYP_Class] EQL TYP_K_Ordinal
	THEN
	    (.Char_Type[ORD_Type] EQL PAS$_TRW_Integer)	OR
	    (.Char_Type[ORD_Type] EQL PAS$_TRW_Unsigned)
	)
    THEN
	SIGNAL(DBG$_STRNGVAL);
	
    IF .Char_Type[ORD_Unsigned]
    THEN
	Char_Value	= .(Char_Expr[Expr_Value])<0, .Char_Type[TYP_Packed_Size], 0>
    ELSE
	Char_Value	= .(Char_Expr[Expr_Value])<0, .Char_Type[TYP_Packed_Size], 1>;

    IF (.Char_Value AND (NOT 255)) NEQ 0
    THEN
	SIGNAL(DBG$_STRVALRNG);
	
    ! Create a new String Block and append it to the current string chain
    !
    IF NOT DBG$NLIST_FREEZ(ROUND_BYTE_TO_LONG_(STR_S_Entry + 1), New_String_Block, .PAS$_Message_Vector)
    THEN
	SIGNAL(DBG$_NOFREE);

    New_String_Block[STR_Length]		= 1;
    New_String_Block[STR_Next]			= 0;
    (New_String_Block[STR_First_Char])<B0_>	= .Char_Value<B0_>;

    Current_String_Block		= ..String_Block;
    Current_String_Block[STR_Next]	= .New_String_Block;
    .String_Block			= .New_String_Block;

    ! Get rid of character value
    !
    PAS$_Expr_Depth	= .PAS$_Expr_Depth - 1;
    END;

GLOBAL ROUTINE PAS$_Sem_Append_String (String_Block, String_Literal) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Appends a string literal to a list of such literals
!
! FORMAL PARAMETERS:
!
!	String_Block	- Address of a pointer to String Block to append to
!	String_Literal	- Address of String Block to append
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    MAP
	String_Literal		: REF BLOCK [,BYTE] FIELD(STR_Fields);

    LOCAL
	Current_String_Block	: REF BLOCK [,BYTE] FIELD(STR_Fields);

    Current_String_Block		= ..String_Block;
    Current_String_Block[STR_Next]	= .String_Literal;
    .String_Block			= .String_Literal;
    END;

GLOBAL ROUTINE PAS$_Sem_Arithmetic_Binary_Op (Op_Code) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	This routine performs a specified Binary Operation on the
!	two elements on the top of the Expression Stack
!
! FORMAL PARAMETERS:
!
!	Op_Code		- Indicates which Operation is to be Performed
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! IMPLICIT OUTPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    BIND
	Left_Expr	= PAS$_Expr_Stack[.PAS$_Expr_Depth - 1, 0, A_]
				: BLOCK [,BYTE] FIELD(Expression_Stack_Fields),
	Right_Expr	= PAS$_Expr_Stack[.PAS$_Expr_Depth    , 0, A_]
				: BLOCK [,BYTE] FIELD(Expression_Stack_Fields);

    LOCAL
	Condition_Status	: LONG,
	Operation		: LONG,
	Left_Value		: VECTOR [4, LONG],
	Right_Value		: VECTOR [4, LONG],

	Left_DType		: LONG,
	Right_DType		: LONG,
	Result_DType		: LONG,

	Left_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
	Right_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
	Result_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields);

    MACRO
	Result_Expr	= Left_Expr %;

    ! Compute the Result Type
    !
    Operation        = .Op_Code;

    Left_Type    = .Left_Expr [Expr_Type];
    Right_Type   = .Right_Expr[Expr_Type];
    Result_Type  = 0;

    ! One of the source types is zero. Bugcheck.
    !
    IF  (.Left_Type  EQL 0) OR
	(.Right_Type EQL 0)
    THEN
	Pascal_Bugcheck(PAS$K_EXPSTK)

    ! Check to see if the arguments are both REAL or INTEGER (more or less)
    ! If not, give an error
    !
    ELIF       ((NOT
		    (IF .Left_Type [Typ_Class] EQL Typ_K_Real
		    THEN
			(Left_DType = .Left_Type[REAL_DType]; True)))
	    AND
		(NOT
		    (IF .Left_Type [Typ_Class] EQL Typ_K_Ordinal
		    THEN
			IF (.Left_Type[ORD_Type] EQL PAS$_TRW_INTEGER)	OR
			   (.Left_Type[ORD_Type] EQL PAS$_TRW_Unsigned)
			THEN
			    (Left_DType = .BLK_B(.Left_Type[ORD_Type], ORD_Dtype); True))))
	OR
		((NOT
		    (IF .Right_Type[Typ_Class] EQL Typ_K_Real
		    THEN
			(Right_DType = .Right_Type[REAL_DType]; True)))
	    AND
		 (NOT
		    (IF .Right_Type[Typ_Class] EQL Typ_K_Ordinal
		    THEN
			IF (.Right_Type[ORD_Type] EQL PAS$_TRW_INTEGER)	OR
			   (.Right_Type[ORD_Type] EQL PAS$_TRW_Unsigned)
			THEN
			    (Right_DType = .BLK_B(.Right_Type[ORD_Type], ORD_Dtype); True))))
    THEN
	SIGNAL(DBG$_ILLTYPE)		! Illegal type of operand(s)

    ! Ok, valid Arithmetic Expression
    !
    ELSE
	BEGIN
	LOCAL
	    Left_Priority,
	    Right_Priority;

	OWN
	    Result_Priority_Table	: VECTOR [Last_DType+1, BYTE] PRESET(
		[BU_int]	= 2,		[B_int]		= 1,
		[WU_int]	= 2,		[W_int]		= 1,
		[LU_int]	= 2,		[L_int]		= 1,
		[F_float]	= 3,		[D_float]	= 4,
		[G_float]	= 5,		[H_float]	= 6),

	    Result_DType_Table		: VECTOR [7, BYTE]
		INITIAL( BYTE(0, L_int, LU_int, F_float, D_Float, G_Float, H_Float) );

	! Find the winner in the "Compute the result type" contest
	!
	Right_Priority = .Result_Priority_Table[.Right_DType];
	Left_Priority  = .Result_Priority_Table[.Left_DType];

	IF .Right_Priority LEQ .Left_Priority
	THEN
	    (Result_DType = .Result_DType_Table[.Left_Priority];  Result_Type = .Left_Type )
	ELSE
	    (Result_DType = .Result_DType_Table[.Right_Priority]; Result_Type = .Right_Type );

	IF .Result_DType EQL 0 THEN Pascal_BugCheck(PAS$K_EXPSTK);

	! Special Check for Floating result
	!
	IF OneOf_(.Result_DType, BMSK_(F_float, D_Float, G_float, H_float))
	THEN

	    ! Translate Integer Op Code to Floating Op Code
	    !
	    SELECTONE .Operation OF
		SET

[Op_Add]:	Operation = Op_Add_Float;
[Op_Sub]:	Operation = Op_Sub_Float;
[Op_Mul]:	Operation = Op_Mul_Float;

[Op_Div,
 Op_Mod,
 Op_Rem]:	SIGNAL(DBG$_ILLTYPE);

[OTHERWISE]:	;

		TES

	! Special Check for Divide - <Integer> / <Integer> returns <Float>
	!
	ELIF .Operation EQL Op_Div_Float
	THEN
	    BEGIN
	    Result_Type  = PAS$_TRW_REAL;
	    Result_DType = .Result_Type[REAL_DType];
	    END;

	! Perform the operation
	!
	BEGIN
	BIND ROUTINE
	    Operation_Routine =
		(SELECTONE .Operation OF
		    SET
	[Op_Add]:	PAS$_Arith_Add;
	[Op_Sub]:	PAS$_Arith_Sub;
	[Op_Mul]:	PAS$_Arith_Mul;
	[Op_Div]:	PAS$_Arith_Div;
	[Op_Mod]:	PAS$_Arith_Mod;
	[Op_Rem]:	PAS$_Arith_Rem;

	[Op_Add_Float]:	PAS$_Arith_Add_Float;
	[Op_Sub_Float]:	PAS$_Arith_Sub_Float;
	[Op_Mul_Float]:	PAS$_Arith_Mul_Float;
	[Op_Div_Float]:	PAS$_Arith_Div_Float;

	[Op_Exponentiation]:	PAS$_Arith_Expo;
	[OTHERWISE]:		Pascal_Bugcheck(PAS$K_OPER);
		    TES);

	IF (Condition_Status = PAS$_Arith_Convert
		(.Left_DType,  Left_Expr[Expr_Value], .Result_DType, Left_Expr[Expr_Value]))
	THEN
	    IF (Condition_Status = PAS$_Arith_Convert
		    (.Right_DType, Right_Expr[Expr_Value], .Result_DType, Right_Expr[Expr_Value]))
	    THEN
		Condition_Status = Operation_Routine
		    (.Result_DType, Result_Expr[Expr_Value], Left_Expr[Expr_Value], Right_Expr[Expr_Value]);

	IF NOT .Condition_Status
	THEN
	    SIGNAL(.Condition_Status);

	END;

	END;

    ! Establish values for exit
    !
    PAS$_Expr_Depth             = .PAS$_Expr_Depth - 1;
    Result_Expr[Expr_Type]	= .Result_Type;

    END;

GLOBAL ROUTINE PAS$_Sem_Boolean_Binary_Op (Op_Code) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	This routine performs a specified Binary Operation on the
!	two elements on the top of the Expression Stack
!
! FORMAL PARAMETERS:
!
!	Op_Code		- Indicates which Operation is to be Performed
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! IMPLICIT OUTPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    BIND
	Left_Expr	= PAS$_Expr_Stack[.PAS$_Expr_Depth - 1, 0, A_]
				: BLOCK [,BYTE] FIELD(Expression_Stack_Fields),
	Right_Expr	= PAS$_Expr_Stack[.PAS$_Expr_Depth    , 0, A_]
				: BLOCK [,BYTE] FIELD(Expression_Stack_Fields);

    LOCAL
	Condition_Status	: LONG,

	Left_DType		: LONG,
	Right_DType		: LONG,

	Left_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
	Right_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
	Result_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields);

    MACRO
	Result_Expr	= Left_Expr %;

    ! Compute the Result Type
    !
    Left_Type    = .Left_Expr [Expr_Type];
    Right_Type   = .Right_Expr[Expr_Type];
    Result_Type  = 0;

    ! One of the source types is zero. Bugcheck
    !
    IF  (.Left_Type  EQL 0) OR
	(.Right_Type EQL 0)
    THEN
	Pascal_Bugcheck(PAS$K_EXPSTK)

    ! Check to see if the arguments are both BOOLEAN. If not, give an error
    !
    ELIF
		(NOT
		    (IF .Left_Type [Typ_Class] EQL Typ_K_Ordinal
		    THEN
			.Left_Type[ORD_Type] EQL PAS$_TRW_BOOLEAN))
	OR
		(NOT
		    (IF .Right_Type[Typ_Class] EQL Typ_K_Ordinal
		    THEN
			.Right_Type[ORD_Type] EQL PAS$_TRW_BOOLEAN))
    THEN
	SIGNAL(DBG$_ILLTYPE)			! Illegal type of operand(s)

    ! Ok, valid Boolean Expression
    !
    ELSE
	! Perform the operation
	!
	BEGIN
	BIND ROUTINE
	    Operation_Routine =
		(SELECTONE .Op_Code OF
			SET
	[Op_Lor]:	PAS$_Arith_Lor;
	[Op_Land]:	PAS$_Arith_Land;

	[OTHERWISE]:	Pascal_Bugcheck(PAS$K_OPER);
			TES);

	IF (Condition_Status = PAS$_Arith_Convert
		(.Left_Type[ORD_DType],  Left_Expr[Expr_Value],  U_bool, Left_Expr[Expr_Value]))
	THEN
	    IF (Condition_Status = PAS$_Arith_Convert
		    (.Right_Type[ORD_DType], Right_Expr[Expr_Value], U_bool, Right_Expr[Expr_Value]))
	    THEN
		IF (Condition_Status = Operation_Routine
		    (U_bool, Result_Expr[Expr_Value], Right_Expr[Expr_Value], Left_Expr[Expr_Value]))
		THEN
		    Result_Type = PAS$_TRW_BOOLEAN;

	IF NOT .Condition_Status
	THEN
	    SIGNAL(.Condition_Status);

	END;

    ! Establish values for exit
    !
    PAS$_Expr_Depth        = .PAS$_Expr_Depth - 1;
    Result_Expr[Expr_Type] = .Result_Type;

    END;

GLOBAL ROUTINE PAS$_Sem_Comparison_Binary_Op (Op_Code) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	This routine performs a specified Binary Comparison on the
!	two elements on the top of the Expression Stack
!
! FORMAL PARAMETERS:
!
!	Op_Code		- Indicates which Operation is to be Performed
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! IMPLICIT OUTPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! ROUTINE VALUE:
!
!	NONE
!--

    BEGIN
    BIND
	Left_Expr	= PAS$_Expr_Stack[.PAS$_Expr_Depth - 1, 0, A_]
				: BLOCK [,BYTE] FIELD(Expression_Stack_Fields),
	Right_Expr	= PAS$_Expr_Stack[.PAS$_Expr_Depth    , 0, A_]
				: BLOCK [,BYTE] FIELD(Expression_Stack_Fields);

    LOCAL
	Condition_Status	: LONG,
	Operation		: LONG,
	Left_Value		: VECTOR [4, LONG],
	Right_Value		: VECTOR [4, LONG],

	Left_DType		: LONG,
	Right_DType		: LONG,
	Compare_DType		: LONG,

	Left_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
	Right_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
	Result_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields);


    MACRO
	Result_Expr	= Left_Expr %;

    ! Compute the Result Type
    !
    Operation        = .Op_Code;

    Left_Type    = .Left_Expr [Expr_Type];
    Right_Type   = .Right_Expr[Expr_Type];
    Result_Type  = 0;

    ! One of the source types is zero. Bugcheck
    !
    IF  (.Left_Type  EQL 0) OR
	(.Right_Type EQL 0)
    THEN
	Pascal_Bugcheck(PAS$K_EXPSTK)

    ! Check to see if the arguments are both REAL or INTEGER (more or less)
    ! If not, check for Ordinals or Packed Arrays of Char
    !
    ELIF       ((NOT
		    (IF .Left_Type [Typ_Class] EQL Typ_K_Real
		    THEN
			(Left_DType = .Left_Type[REAL_DType]; True)))
	    AND
		(NOT
		    (IF .Left_Type [Typ_Class] EQL Typ_K_Ordinal
		    THEN
			IF (.Left_Type[ORD_Type] EQL PAS$_TRW_INTEGER)	OR
			   (.Left_Type[ORD_Type] EQL PAS$_TRW_Unsigned)
			THEN
			    (Left_DType = .BLK_B(.Left_Type[ORD_Type], ORD_Dtype); True))))
	OR
		((NOT
		    (IF .Right_Type[Typ_Class] EQL Typ_K_Real
		    THEN
			(Right_DType = .Right_Type[REAL_DType]; True)))
	    AND
		 (NOT
		    (IF .Right_Type[Typ_Class] EQL Typ_K_Ordinal
		    THEN
			IF (.Right_Type[ORD_Type] EQL PAS$_TRW_INTEGER)	OR
			   (.Right_Type[ORD_Type] EQL PAS$_TRW_Unsigned)
			THEN
			    (Right_DType = .BLK_B(.Right_Type[ORD_Type], ORD_Dtype); True))))
    THEN

	! Not arithmetic, check for Ordinals
	!
	IF  (.Right_Type[Typ_Class] EQL Typ_K_Ordinal) AND
	    (.Left_Type [Typ_Class] EQL Typ_K_Ordinal)
	THEN
	    IF .Right_Type[ORD_Type] EQLA .Left_Type[ORD_Type]
	    THEN

		! Perform the operation
		!
		BEGIN
		BIND ROUTINE
		    Operation_Routine =
			(CASE .Operation
			    FROM Min(Op_Eql, Op_Neq, Op_Lss, Op_Leq, Op_Gtr, Op_Geq)
			    TO   Max(Op_Eql, Op_Neq, Op_Lss, Op_Leq, Op_Gtr, Op_Geq)
			    OF   SET
	
	    [Op_Eql]:	    PAS$_Arith_Eql;
	    [Op_Neq]:	    PAS$_Arith_Neq;
	    [Op_Lss]:	    PAS$_Arith_Lss;
	    [Op_Leq]:	    PAS$_Arith_Leq;
	    [Op_Gtr]:	    PAS$_Arith_Gtr;
	    [Op_Geq]:	    PAS$_Arith_Geq;
	
	    [INRANGE,OUTRANGE]: Pascal_Bugcheck(PAS$K_OPER);
			    TES);
	
		IF (Condition_Status = Operation_Routine
		    (.Right_Type[ORD_DType], Result_Expr[Expr_Value], Right_Expr[Expr_Value], Left_Expr[Expr_Value]))
		THEN
		    Result_Type = PAS$_TRW_BOOLEAN

		ELSE
		    SIGNAL(.Condition_Status);

		END

	    ELSE
		SIGNAL(DBG$_NOTCOMPAT)			! Operands are of incompatible types

	! Check for string comparison
	!
	ELIF
	    (IF PAS$_String(.Left_Type)
	    THEN
		IF
		    (IF PAS$_String(.Right_Type)
		    THEN
			True
		    ELIF
			(IF .Right_Type[TYP_Class] EQL TYP_K_Ordinal
			THEN
			    .Right_Type[ORD_Type] EQLA PAS$_TRW_Char)
		    THEN
			True
		    ELSE
			False)
		THEN
		    ! Right operand is string or char
		    !
		    True
		ELSE
		    ! Right operand not string or coercible to string
		    !
		    False

	    ELIF PAS$_String(.Right_Type)
	    THEN
		IF
		    (IF PAS$_String(.Left_Type)
		    THEN
			True
		    ELIF
			(IF .Left_Type[TYP_Class] EQL TYP_K_Ordinal
			THEN
			    .Left_Type[ORD_Type] EQLA PAS$_TRW_Char)
		    THEN
			True
		    ELSE
			False)
		THEN
		    ! Left operand is string or char
		    !
		    True
		ELSE
		    ! Left operand not string or coercible to string
		    !
		    False

	    ELSE
		! Neither left or right operand is a string
		!
		False)

	THEN
	    ! Perform the operation
	    !
	    BEGIN
	    LOCAL
		Left_Address,
		Right_Address,
		Left_Length,
		Right_Length,
		Left_Temp,
		Right_Temp,
		Result;

	    IF .Left_Type[TYP_Class] EQL TYP_K_Array
	    THEN
		BEGIN
		Left_Length	= .BLK_B(.Left_Type[ARR_Itype], ORD_Upper);

		IF .Left_Expr[Expr_Bit_Offset] NEQ 0
		THEN
		    ! Packed, extract to a temporary
		    !
		    BEGIN
		    Left_Temp		= .(.Left_Expr[Expr_Byte_Address])
				<.Left_Expr[Expr_Bit_Offset], .Left_Type[TYP_Packed_Size], 0>;
		    Left_Address	= Left_Temp;
		    END
		ELSE
		    Left_Address	= .Left_Expr[Expr_Byte_Address];
		END
	    ELIF .Left_Type[TYP_Class] EQL TYP_K_Varying
	    THEN
		Not_Implemented()
	    ELSE
		BEGIN
		Left_Length	= 1;
		Left_Address	= Left_Expr[Expr_Value];
		END;

	    IF .Right_Type[TYP_Class] EQL TYP_K_Array
	    THEN
		BEGIN
		Right_Length	= .BLK_B(.Right_Type[ARR_Itype], ORD_Upper);

		IF .Right_Expr[Expr_Bit_Offset] NEQ 0
		THEN
		    ! Packed, extract to a temporary
		    !
		    BEGIN
		    Right_Temp		= .(.Right_Expr[Expr_Byte_Address])
				<.Right_Expr[Expr_Bit_Offset], .Right_Type[TYP_Packed_Size], 0>;
		    Right_Address	= Right_Temp;
		    END
		ELSE
		    Right_Address	= .Right_Expr[Expr_Byte_Address];
		END
	    ELIF .Right_Type[TYP_Class] EQL TYP_K_Varying
	    THEN
		Not_Implemented()
	    ELSE
		BEGIN
		Right_Length	= 1;
		Right_Address	= Right_Expr[Expr_Value];
		END;

	    ! Check for identical lengths
	    !
	    IF .Left_Length NEQ .Right_Length
	    THEN
		SIGNAL(DBG$_STRNGPAD);

	    ! Perform the comparison
	    !
	    Result = CH$COMPARE(.Left_Length, .Left_Address, .Right_Length, .Right_Address, 0);

	    CASE .Operation
		FROM MIN(Op_Eql, Op_Neq, Op_Lss, Op_Leq, Op_Gtr, Op_Geq)
		TO   MAX(Op_Eql, Op_Neq, Op_Lss, Op_Leq, Op_Gtr, Op_Geq)
		OF   SET

	    [Op_Eql]:	Result	= .Result EQL 0;
	    [Op_Neq]:	Result	= .Result NEQ 0;
	    [Op_Lss]:	Result	= .Result LSS 0;
	    [Op_Leq]:	Result	= .Result LEQ 0;
	    [Op_Gtr]:	Result	= .Result GTR 0;
	    [Op_Geq]:	Result	= .Result GEQ 0;

	    [INRANGE, OUTRANGE]:	Pascal_Bugcheck(PAS$K_OPER);
		TES;

	    Result_Expr[Expr_Value]	= .Result;
	    Result_Type			= PAS$_TRW_Boolean;
	    END

	ELSE
	    SIGNAL(DBG$_ILLTYPE)		! Illegal type of operands

    ELSE

	! Ok, valid Arithmetic Expression
	!

	! Perform the operation
	!
	BEGIN
	BIND ROUTINE
	    Operation_Routine =
		(CASE .Operation
		    FROM Min(Op_Eql, Op_Neg, Op_Lss, Op_Leq, Op_Gtr, Op_Geq)
		    TO   Max(Op_Eql, Op_Neg, Op_Lss, Op_Leq, Op_Gtr, Op_Geq)
		    OF   SET

    [Op_Eql]:	    PAS$_Arith_Eql;
    [Op_Neq]:	    PAS$_Arith_Neq;
    [Op_Lss]:	    PAS$_Arith_Lss;
    [Op_Leq]:	    PAS$_Arith_Leq;
    [Op_Gtr]:	    PAS$_Arith_Gtr;
    [Op_Geq]:	    PAS$_Arith_Geq;

    [INRANGE,OUTRANGE]: Pascal_Bugcheck(PAS$K_OPER);
		    TES);

	LOCAL
	    Left_Priority,
	    Right_Priority;

	OWN
	    Result_Priority_Table	: VECTOR [Last_DType+1, BYTE] PRESET(
		[BU_int]	= 2,		[B_int]		= 1,
		[WU_int]	= 2,		[W_int]		= 1,
		[LU_int]	= 2,		[L_int]		= 1,
		[F_float]	= 3,		[D_float]	= 4,
		[G_float]	= 5,		[H_float]	= 6),

	    Result_DType_Table		: VECTOR [7, BYTE]
		INITIAL( BYTE(0, L_int, LU_int, F_float, D_Float, G_Float, H_Float) );

	! Find the winner in the "Compute the result type" contest
	!
	Right_Priority = .Result_Priority_Table[.Right_DType];
	Left_Priority  = .Result_Priority_Table[.Left_DType];

	IF .Right_Priority LEQ .Left_Priority
	THEN
	    Compare_DType = .Result_Dtype_Table[.Left_Priority]
	ELSE
	    Compare_DType = .Result_DType_Table[.Right_Priority];

	IF .Compare_DType EQL 0 THEN Pascal_BugCheck(PAS$K_EXPSTK);

	IF (Condition_Status = PAS$_Arith_Convert
		(.Left_DType,  Left_Expr[Expr_Value], .Compare_DType, Left_Expr[Expr_Value]))
	THEN
	    IF (Condition_Status = PAS$_Arith_Convert
		    (.Right_DType, Right_Expr[Expr_Value], .Compare_DType, Right_Expr[Expr_Value]))
	    THEN
		IF (Condition_Status = Operation_Routine
			(.Compare_DType, Result_Expr[Expr_Value], Right_Expr[Expr_Value], Left_Expr[Expr_Value]))
		THEN
		    Result_Type = PAS$_TRW_BOOLEAN;

	IF NOT .Condition_Status
	THEN
	    SIGNAL(.Condition_Status);

	END;

    ! Establish values for exit
    !
    PAS$_Expr_Depth        = .PAS$_Expr_Depth - 1;
    Result_Expr[Expr_Type] = .Result_Type;

    END;

GLOBAL ROUTINE PAS$_Sem_DIV : NOVALUE =

!++
!
!	DIV
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN

    PAS$_Sem_Arithmetic_Binary_Op(Op_Div);

    END;

GLOBAL ROUTINE PAS$_Sem_Divide : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Divide
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN

    PAS$_Sem_Arithmetic_Binary_Op(Op_Div_Float);

    END;

GLOBAL ROUTINE PAS$_Sem_Equal : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Equivalence
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN

    IF  (.BLOCK[.PAS$_Expr_Stack[.PAS$_Expr_Depth-1, Expr_Type], TYP_Class; ,BYTE] EQL TYP_K_Set) AND
	(.BLOCK[.PAS$_Expr_Stack[.PAS$_Expr_Depth,   Expr_Type], TYP_Class; ,BYTE] EQL TYP_K_Set)
    THEN

	! Set Operation, do it
	!
	PAS$_Sem_Set_Binary_Op(Op_Set_Eql)

    ELSE

	! Arithmetic Operation
	!
	PAS$_Sem_Comparison_Binary_Op(Op_Eql);

    END;

GLOBAL ROUTINE PAS$_Sem_Exponentiation : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Exponentiation
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN

    PAS$_Sem_Arithmetic_Binary_Op(Op_Exponentiation);

    END;

GLOBAL ROUTINE PAS$_Sem_Field (Name_Ptr) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	This routine is used to check/generate a Field Reference
!	within a Record
!
! FORMAL PARAMETERS:
!
!	Name_Ptr	- Pointer to the Field Name Block
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Stack	- The Type and Address of the Record is on the Expression Stack
!
! IMPLICIT OUTPUTS:
!
!	PAS$_Expr_Stack	- The Type and Address of the Field is on the Expression Stack
!
! ROUTINE VALUE:
!
!
!
!--

    BEGIN
    MAP
	Name_Ptr		: REF BLOCK [,BYTE] FIELD(Nam_Fields);

    BIND
	Source_Expr		= PAS$_Expr_Stack[.PAS$_Expr_Depth, 0, A_]
		: BLOCK [EXPR_S_Entry, BYTE] FIELD(Expression_Stack_Fields);
    
    MACRO
	Result_Expr		= Source_Expr %;

    LOCAL
	Record_Type_Entry	: REF BLOCK [,BYTE] FIELD(Type_Fields),
	Result_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
	Field_Entry		: REF BLOCK [,BYTE] FIELD(Keyword_Fields);

    ! Initialize Variables
    !
    Result_Type      = 0;


    ! Find the Block describing the Field, if any
    !
    Record_Type_Entry = .Source_Expr[EXPR_Type];
    Field_Entry       = .Name_Ptr[NAM_Keyword];

    IF .Record_Type_Entry EQLA 0
    THEN
	SIGNAL(DBG$_NOEXAM);

    IF .Field_Entry EQLA 0
    THEN
	SIGNAL(DBG$_NOFIELD, Name_Ptr[NAM_Text]);

    ! Type is known, look for it
    !
    WHILE .Field_Entry NEQA 0 DO
	IF .Field_Entry[FLD_Record] EQLA .Record_Type_Entry
	THEN
	    EXITLOOP
	ELSE
	    Field_Entry = .Field_Entry[KEYW_Link];

    IF .Field_Entry EQLA 0
    THEN
	! I see no such field here
	!
	SIGNAL(DBG$_NOFIELD, Name_Ptr[NAM_Text])

    ELSE
	! Found the Field, now reference it
	!
	BEGIN
	BIND
	    Variant_Entry	= .Field_Entry[FLD_Variant]
			: BLOCK [,BYTE] FIELD(Type_Fields);

	Result_Type = .Field_Entry[FLD_Type];

	! Update the address on the expression stack
	!
	Source_Expr[Expr_Bit_Offset]	= .Source_Expr[Expr_Bit_Offset] + .Field_Entry[FLD_Position];
	Source_Expr[Expr_Byte_Address]	= .Source_Expr[Expr_Byte_Address] +
						(.Source_Expr[Expr_Bit_Offset] ^ -3);
	Source_Expr[Expr_Bit_Offset]	= .Source_Expr[Expr_Bit_Offset] AND 7;

	! Push the field symid, if we're building a Primary descriptor
	!
	IF .PAS$_Is_Primary
	THEN
	    BEGIN
	    PAS$_Push_Primary_Operand(.Field_Entry[FLD_Rst_Symid]);
	    IF .Field_Entry[FLD_Packed]
	    THEN
		PAS$_Static_Desc[PAS$PRIM_Size]	= .Result_Type[TYP_Packed_Size]
	    ELSE
		PAS$_Static_Desc[PAS$PRIM_Size]	= .Result_Type[TYP_Full_Size] * 8;
	    END;

	! Check for correct variant(s), if applicable
	!
	IF Variant_Entry NEQA 0
	THEN
	    PAS$_Variant_Check(Source_Expr[Expr_Byte_Address], .Field_Entry);

	! Assign the result type
	!
	Result_Expr[Expr_Type] = .Result_Type;
	END;

    END;

GLOBAL ROUTINE PAS$_Sem_Float_F (Value_Ptr) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Stack an F_Float value
!
! FORMAL PARAMETERS:
!
!	Value_Ptr	- Pointer to the value to stack
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! IMPLICIT OUTPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN

    ! Push value on the Stack
    !
    IF (PAS$_Expr_Depth = .PAS$_Expr_Depth + 1) GEQ Expr_Stack_Depth
    THEN
	SIGNAL(DBG$_EXPSTKOVR)

    ELSE
	BEGIN

	PAS$_Expr_Stack[.PAS$_Expr_Depth, Expr_Type]     = PAS$_TRW_REAL;

	! Stack the value
	!
	MOVEBYTE(4, .Value_Ptr, PAS$_Expr_Stack[.PAS$_Expr_Depth, Expr_Value]);

	END;

    END;

GLOBAL ROUTINE PAS$_Sem_Float_D (Value_Ptr) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Stack a D_Float value
!
! FORMAL PARAMETERS:
!
!	Value_Ptr	- Pointer to value to stack
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! IMPLICIT OUTPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN

    ! Push value on the Stack
    !
    IF (PAS$_Expr_Depth = .PAS$_Expr_Depth + 1) GEQ Expr_Stack_Depth
    THEN
	SIGNAL(DBG$_EXPSTKOVR)

    ELSE
	BEGIN

	PAS$_Expr_Stack[.PAS$_Expr_Depth, Expr_Type]     = PAS$_TRW_DOUBLE;

	! Stack the value
	!
	MOVEBYTE(8, .Value_Ptr, PAS$_Expr_Stack[.PAS$_Expr_Depth, Expr_Value]);

	END;

    END;

GLOBAL ROUTINE PAS$_Sem_Float_G (Value_Ptr) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Stack a G_Float value
!
! FORMAL PARAMETERS:
!
!	Value_Ptr	- Pointer to value to stack
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! IMPLICIT OUTPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN

    ! Push value on the Stack
    !
    IF (PAS$_Expr_Depth = .PAS$_Expr_Depth + 1) GEQ Expr_Stack_Depth
    THEN
	SIGNAL(DBG$_EXPSTKOVR)

    ELSE
	BEGIN

	PAS$_Expr_Stack[.PAS$_Expr_Depth, Expr_Type]     = PAS$_TRW_DOUBLE;

	! stack the value
	!
	MOVEBYTE(8, .Value_Ptr, PAS$_Expr_Stack[.PAS$_Expr_Depth, Expr_Value]);

	END;

    END;

GLOBAL ROUTINE PAS$_Sem_Float_H (Value_Ptr) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Stack an H_Float value
!
! FORMAL PARAMETERS:
!
!	Value_Ptr	- Pointer to value to stack
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! IMPLICIT OUTPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN

    ! Push value on the Stack
    !
    IF (PAS$_Expr_Depth = .PAS$_Expr_Depth + 1) GEQ Expr_Stack_Depth
    THEN
	SIGNAL(DBG$_EXPSTKOVR)

    ELSE
	BEGIN

	PAS$_Expr_Stack[.PAS$_Expr_Depth, Expr_Type]     = PAS$_TRW_QUADRUPLE;

	! Stack the value
	!
	MOVEBYTE(16, .Value_Ptr, PAS$_Expr_Stack[.PAS$_Expr_Depth, Expr_Value]);

	END;

    END;

GLOBAL ROUTINE PAS$_Sem_Function_Call_1 (Symbol_Ptr) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!
!
! FORMAL PARAMETERS:
!
!	Symbol_Ptr	- Pointer to the Symbol Table Entry
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    MAP
	Symbol_Ptr		: REF BLOCK [,BYTE] FIELD(Symbol_Fields);

    IF .Symbol_Ptr[SYM_Class] NEQ SYM_K_Function
    THEN
	SIGNAL(DBG$_INVEXPR);	! Invalid expression

    END;

GLOBAL ROUTINE PAS$_Sem_Function_Call_2 (Symbol_Ptr) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!
!
! FORMAL PARAMETERS:
!
!	Symbol_Ptr	- Pointer to Symbol Table Entry for the Function
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    MAP
	Symbol_Ptr		: REF BLOCK [,BYTE] FIELD(Symbol_Fields);

    LOCAL
	Operation		: LONG,
	DType			: LONG,
	Type_Entry		: REF BLOCK [,BYTE] FIELD(Type_Fields);

    ! Push value on the Stack
    !
    IF (PAS$_Expr_Depth = .PAS$_Expr_Depth + 1) GEQ Expr_Stack_Depth
    THEN
	SIGNAL(DBG$_EXPSTKOVR)

    ELSE
	BEGIN

	! Stack info
	!
	PAS$_Expr_Stack[.PAS$_Expr_Depth, Expr_Type]      = .Symbol_Ptr[PROC_FUNC_Type];
	Not_Implemented();

!	ELSE

	    ! Generate Polish
	    !
!	    BEGIN

	    ! Pointer to Polish for Function Call
	    !
!	    Type_Entry                         = .Symbol_Ptr[PROC_Func_Type];
!	    PAS$_Expr_Stack[.PAS$_Expr_Depth, Expr_Type] = .Type_Entry;
!	    DType                              = 0;

!	    CASE .Type_Entry[TYP_Class] FROM 1 TO TYP_K_Real OF
!		SET

!	[TYP_K_Set]:
!		Operation = Op_Func_Set;

!	[TYP_K_Array,
!	 TYP_K_Record]:
!		Operation = Op_Func_Structure;

!	[TYP_K_Pointer]:
!		(Operation = Op_Func_Scalar; DType = L_int);

!	[TYP_K_Ordinal]:
!		(Operation = Op_Func_Scalar; DType = .Type_Entry[ORD_DType]);

!	[TYP_K_Real]:
!		(Operation = Op_Func_Scalar; DType = .Type_Entry[REAL_DType]);

!	[INRANGE,
!	 OUTRANGE]:
!		Pascal_BugCheck();

!		TES;

!	    Polish_Structure             = Emit_Polish(.Operation);

!	    Polish_Structure[P_Flags]    = 0;
!	    Polish_Structure[P_DType]    = .DType;
!	    Polish_Structure[P_Function] = .Symbol_Ptr;

!	    PAS$_Expr_Stack[.PAS$_Expr_Depth, Expr_Codestring] = .Polish_Structure;
!	    END;
	END;

    END;

GLOBAL ROUTINE PAS$_Sem_Greater : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Greater Than
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN

    PAS$_Sem_Comparison_Binary_Op(Op_Gtr);

    END;

GLOBAL ROUTINE PAS$_Sem_GreaterEqual : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Greater Than or Equal, Set Inclusion
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN

    IF  (.BLOCK[.PAS$_Expr_Stack[.PAS$_Expr_Depth-1, Expr_Type], TYP_Class; ,BYTE] EQL TYP_K_Set) AND
	(.BLOCK[.PAS$_Expr_Stack[.PAS$_Expr_Depth,   Expr_Type], TYP_Class; ,BYTE] EQL TYP_K_Set)
    THEN

	! Set Operation, do it
	!
	PAS$_Sem_Set_Binary_Op(Op_Set_Geq)

    ELSE

	! Arithmetic Operation
	!
	PAS$_Sem_Comparison_Binary_Op(Op_Geq);

    END;

GLOBAL ROUTINE PAS$_Sem_IN : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	IN
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! IMPLICIT OUTPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    BIND
	Left_Expr		= PAS$_Expr_Stack[.PAS$_Expr_Depth - 1, 0, A_]
			: BLOCK [,BYTE] FIELD(Expression_Stack_Fields),
	Right_Expr		= PAS$_Expr_Stack[.PAS$_Expr_Depth    , 0, A_]
			: BLOCK [,BYTE] FIELD(Expression_Stack_Fields);

    LOCAL
	Left_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
	Right_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),

	Right_Set_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),

	Test_Value,
	Result;

    MACRO
	Result_Expr	= Left_Expr %;

    Left_Type	= .Left_Expr [Expr_Type];
    Right_Type	= .Right_Expr[Expr_Type];

    Right_Set_Type	= .Right_Type[SET_Type];

    ! Check for the null set
    !
    IF .Right_Set_Type EQLA 0
    THEN
	Result = False

    ELSE
	BEGIN

	! Sign or zero-extend the ordinal expression value to a longword
	!
	IF NOT .Left_Type[ORD_Unsigned]
	THEN
	    Test_Value	= .(Left_Expr[Expr_Value])<0, .Left_Type[TYP_Packed_Size], 1>
	ELSE
	    Test_Value	= .(Left_Expr[Expr_Value])<0, .Left_Type[TYP_Packed_Size], 0>;

	! Check compatibility
	!
	IF .Left_Type[TYP_Class] EQL TYP_K_Ordinal
	THEN
	    IF .Left_Type[ORD_Type] EQLA .Right_Set_Type[ORD_Type]
	    THEN

		! Ordinal expression value is compatible with the set expression
		!
		IF
		    (IF	(.Left_Type EQLA PAS$_TRW_Integer)	OR
			(.Left_Type EQLA PAS$_TRW_Unsigned)	OR
			(.Right_Set_Type EQLA PAS$_TRW_Integer)	OR
			(.Right_Set_Type EQLA PAS$_TRW_Unsigned)
		    THEN
			(.Test_Value LSS 0) OR (.Test_Value GTR 255)
		    ELIF NOT .Left_Type[ORD_Unsigned]
		    THEN
			(.Test_Value LSS .Right_Set_Type[ORD_Lower])  OR
			(.Test_Value GTR .Right_Set_Type[ORD_Upper])
		    ELSE
			(.Test_Value LSSU .Right_Set_Type[ORD_Lower]) OR
			(.Test_Value GTRU .Right_Set_Type[ORD_Upper])
		    )
		THEN
		    Result = False

		ELSE
		    Result = .(.Right_Expr[Expr_Byte_Address])<.Test_Value, 1, 0>

	    ELSE
		SIGNAL(DBG$_ILLINSET)
	ELSE
	    SIGNAL(DBG$_ILLINSET);

	END;

    ! Put result on Expression Stack
    !
    PAS$_Expr_Depth		= .PAS$_Expr_Depth - 1;
    Result_Expr[Expr_Type]	= PAS$_TRW_Boolean;
    Result_Expr[Expr_Value]	= .Result;
    END;

GLOBAL ROUTINE PAS$_Sem_Inclusive_OR : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	OR
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN

    PAS$_Sem_Boolean_Binary_Op(Op_Lor);

    END;

GLOBAL ROUTINE PAS$_Sem_Integer (Value_Ptr) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Stack a longword integer
!
! FORMAL PARAMETERS:
!
!	Value_Ptr	- Pointer to value to stack
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! IMPLICIT OUTPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN

    ! Stack the Value
    !
    IF (PAS$_Expr_Depth = .PAS$_Expr_Depth + 1) GEQ Expr_Stack_Depth
    THEN
	SIGNAL(DBG$_EXPSTKOVR)

    ELSE
	BEGIN

	PAS$_Expr_Stack[.PAS$_Expr_Depth, Expr_Type]     = PAS$_TRW_INTEGER;

	! Push on the stack
	!
	MOVELONG(1, .Value_Ptr, PAS$_Expr_Stack[.PAS$_Expr_Depth, Expr_Value]);
	END;

    END;

GLOBAL ROUTINE PAS$_Sem_Label_Reference (Pathname) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Semantics for a label reference
!
! FORMAL PARAMETERS:
!
!	Pathname	- Address of a pathname vector
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    MAP
	Pathname		: REF PTH$Pathname;

    BIND
	Pathvector		= Pathname[PTH$A_Pathvector]
		: VECTOR;

    LOCAL
	Name_String		: REF VECTOR [,BYTE],
	Name_Desc		: BLOCK [8, BYTE],
	Symbol_Name		: REF BLOCK [,BYTE] FIELD(Nam_Fields),
	Symbol_Entry		: REF BLOCK [,BYTE] FIELD(Symbol_Fields);

    ! Enter the line in the Name Table
    !
    Name_String	= .Pathvector[.Pathname[PTH$B_Pathcnt] - 1];

    Name_Desc[DSC$W_Length]	= .Name_String[0];
    Name_Desc[DSC$B_Dtype]	= DSC$K_Dtype_T;
    Name_Desc[DSC$B_Class]	= DSC$K_Class_S;
    Name_Desc[DSC$A_Pointer]	= Name_String[1];

    Symbol_Name	= PAS$_Lex_Enter_Name(Name_Desc);

    ! Look up the label
    !
    Symbol_Entry = PAS$_Get_Symbol(.Pathname, .Symbol_Name);

    ! Check the result
    !
    IF .Symbol_Entry[Sym_Class] EQL Sym_K_Label
    THEN
	BEGIN
	LOCAL
	    Value_Kind;

	! Get the label's address
	!
	DBG$STA_Setcontext(.Symbol_Entry[SYM_Rst_Symid]);

	DBG$STA_Symvalue(.Symbol_Entry[SYM_Rst_Symid], PAS$_Static_Desc[PAS$PRIM_Address],
				Value_Kind, PAS$_Static_Desc[PAS$PRIM_Frame]);

	! Set up the kind
	!
	PAS$_Static_Desc[PAS$PRIM_Kind] = .Value_Kind;

	! Push the label's Symid
	!
	PAS$_Push_Primary_Operand(.Symbol_Entry[SYM_Rst_Symid]);
	END
    ELSE
	! Not a label
	!
	SIGNAL(DBG$_NOTLABEL, .Pathname);

    END;

GLOBAL ROUTINE PAS$_Sem_Last_Value : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Get the value descriptor for '\' == Debug Last Value
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    LOCAL
	Descriptor;		! Value Descriptor Address

    IF DBG$NGET_LASTVAL(Descriptor, .PAS$_Message_Vector)
    THEN
	BEGIN
	! Push the value onto the expression stack
	!
	PAS$_Push_Value_Desc(.Descriptor);

	IF .PAS$_Is_Primary
	THEN
	    ! Place address of value descriptor in PAS$_Static_Desc
	    !
	    BEGIN
	    PAS$_Static_Desc = .Descriptor;
	    PAS$_Result_Type = DBG$K_VALUE_DESC;
	    END;
	END
    ELSE
	SIGNAL(DBG$_NOLASTVAL);			! No last value

    END;

GLOBAL ROUTINE PAS$_Sem_Less : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Less Than
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN

    PAS$_Sem_Comparison_Binary_Op(Op_Lss);

    END;

GLOBAL ROUTINE PAS$_Sem_LessEqual : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Less Than or Equal, Subset
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN

    IF  (.BLOCK[.PAS$_Expr_Stack[.PAS$_Expr_Depth-1, Expr_Type], TYP_Class; ,BYTE] EQL TYP_K_Set) AND
	(.BLOCK[.PAS$_Expr_Stack[.PAS$_Expr_Depth,   Expr_Type], TYP_Class; ,BYTE] EQL TYP_K_Set)
    THEN

	! Set Operation, do it
	!
	PAS$_Sem_Set_Binary_Op(Op_Set_Leq)

    ELSE

	! Arithmetic Operation
	!
	PAS$_Sem_Comparison_Binary_Op(OP_Leq);

    END;

GLOBAL ROUTINE PAS$_Sem_Line_Reference (Pathname) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Semantics for a line number reference
!
! FORMAL PARAMETERS:
!
!	Pathname	- Address of a pathname vector
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    MAP
	Pathname		: REF PTH$Pathname;

    BIND
	Pathvector		= Pathname[PTH$A_Pathvector]
		: VECTOR;

    LOCAL
	Name_String		: REF VECTOR [,BYTE],
	Name_Desc		: BLOCK [8, BYTE],
	Symbol_Name		: REF BLOCK [,BYTE] FIELD(Nam_Fields),
	Symbol_Entry		: REF BLOCK [,BYTE] FIELD(Symbol_Fields);

    ! Enter the line in the Name Table
    !
    Name_String	= .Pathvector[.Pathname[PTH$B_Pathcnt] - 1];

    Name_Desc[DSC$W_Length]	= .Name_String[0];
    Name_Desc[DSC$B_Dtype]	= DSC$K_Dtype_T;
    Name_Desc[DSC$B_Class]	= DSC$K_Class_S;
    Name_Desc[DSC$A_Pointer]	= Name_String[1];

    Symbol_Name	= PAS$_Lex_Enter_Name(Name_Desc);

    ! Look up the line number
    !
    Symbol_Entry = PAS$_Get_Symbol(.Pathname, .Symbol_Name);

    ! Check the result
    !
    IF .Symbol_Entry[Sym_Class] EQL Sym_K_Line
    THEN
	BEGIN
	LOCAL
	    Value_Kind;

	! Get the line's address
	!
	DBG$STA_Setcontext(.Symbol_Entry[SYM_Rst_Symid]);

	DBG$STA_Symvalue(.Symbol_Entry[SYM_Rst_Symid], PAS$_Static_Desc[PAS$PRIM_Address],
				Value_Kind, PAS$_Static_Desc[PAS$PRIM_Frame]);

	! Set up the kind
	!
	PAS$_Static_Desc[PAS$PRIM_Kind] = .Value_Kind;

	! Push the line's Symid
	!
	PAS$_Push_Primary_Operand(.Symbol_Entry[SYM_Rst_Symid]);
	END
    ELSE
	! Not a line number
	!
	SIGNAL(DBG$_NOTLINE, .Pathname);

    END;

GLOBAL ROUTINE PAS$_Sem_MOD : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	MOD
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN

    IF PAS$_Get_Version() EQL 1
    THEN
	PAS$_Sem_Arithmetic_Binary_Op(Op_Rem)
    ELSE
	PAS$_Sem_Arithmetic_Binary_Op(Op_Mod);

    END;

GLOBAL ROUTINE PAS$_Sem_Multiply : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Multiply, Set Intersection
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN

    IF  (.BLOCK[.PAS$_Expr_Stack[.PAS$_Expr_Depth-1, Expr_Type], TYP_Class; ,BYTE] EQL TYP_K_Set) AND
	(.BLOCK[.PAS$_Expr_Stack[.PAS$_Expr_Depth,   Expr_Type], TYP_Class; ,BYTE] EQL TYP_K_Set)
    THEN

	! Set Operation, do it
	!
	PAS$_Sem_Set_Binary_Op(Op_Intersection)

    ELSE

	! Arithmetic Operation
	!
	PAS$_Sem_Arithmetic_Binary_OP(Op_Mul);

    END;

GLOBAL ROUTINE PAS$_Sem_Negation : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Negate
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! IMPLICIT OUTPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    BIND
	Source_Expr		= PAS$_Expr_Stack[.PAS$_Expr_Depth, 0, A_]
	    : BLOCK [,BYTE] FIELD(Expression_Stack_Fields);

    LOCAL
	Condition_Status,
	Op_Code,
	Result_Dtype,
	Source_DType,
	Source_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields);

    ! See if we do this or not (check type)
    !
    IF (Source_Type = .Source_Expr[Expr_Type]) NEQ 0
    THEN
	IF
		(NOT
		    (IF .Source_Type[Typ_Class] EQL Typ_K_Ordinal
		    THEN
			IF (.Source_Type[ORD_Type] EQL PAS$_TRW_INTEGER)	OR
			   (.Source_Type[ORD_Type] EQL PAS$_TRW_Unsigned)
			THEN
			    (Source_DType = .Source_Type[ORD_DType];
			     Result_Dtype = .BLK_B(.Source_Type[ORD_Type], ORD_Dtype);
			     True)))
	    AND
		(NOT
		    (IF .Source_Type[Typ_Class] EQL Typ_K_Real
		    THEN
			(Source_DType = .Source_Type[REAL_DType];
			 Result_Dtype = .Source_Dtype;
			 True)))
	THEN

	    ! Not Real or Integer, issue error
	    !
	    SIGNAL(DBG$_ILLTYPE)		! Illegal type of operand(s)

	ELSE

	    ! Is OK
	    !
	    BEGIN
	    IF ONEOF_(.Source_DType, BMSK_(F_float, D_float, G_float, H_float))
	    THEN
		Op_Code		= Op_Neg_Float
	    ELSE
		Op_Code = Op_Neg;

	    BEGIN
	    BIND ROUTINE
		Operation_Routine =
		    (IF .Op_Code EQL Op_Neg_Float THEN PAS$_Arith_Neg_Float ELSE PAS$_Arith_Neg);

	    IF .Source_Dtype NEQ .Result_Dtype
	    THEN
		IF NOT (Condition_Status = PAS$_Arith_Convert
			(.Source_Dtype, Source_Expr[Expr_Value], .Result_Dtype, Source_Expr[Expr_Value]))
		THEN
		    SIGNAL(.Condition_Status);

	    IF NOT (Condition_Status = Operation_Routine
		(.Result_DType, Source_Expr[Expr_Value], Source_Expr[Expr_Value]))
	    THEN
		SIGNAL(.Condition_Status);

	    END;

	    END;

    END;

GLOBAL ROUTINE PAS$_Sem_NOT : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	NOT
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! IMPLICIT OUTPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    BIND
	Source_Expr		= PAS$_Expr_Stack[.PAS$_Expr_Depth, 0, A_]
	    : BLOCK [,BYTE] FIELD(Expression_Stack_Fields);

    LOCAL
	Condition_Status	: LONG,
	Source_DType		: LONG,
	Source_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields);

    ! See if we do this or not (check type)
    !

    IF (Source_Type = .Source_Expr[Expr_Type]) NEQ 0
    THEN
	IF NOT
	    (IF .Source_Type[Typ_Class] EQL Typ_K_Ordinal
	    THEN
		IF .Source_Type[ORD_Type] EQL PAS$_TRW_BOOLEAN
		THEN
		    (Source_DType = .Source_Type[ORD_DType]; True))
	THEN

	    ! Not Boolean, issue error
	    !
	    SIGNAL(DBG$_ILLTYPE)		! Illegal type of operand(s)

	ELSE

	    ! Is OK
	    !
	    IF NOT (Condition_Status = PAS$_Arith_Lnot(.Source_DType, Source_Expr[Expr_Value], Source_Expr[Expr_Value]))
	    THEN
		SIGNAL(.Condition_Status);

    END;

GLOBAL ROUTINE PAS$_Sem_NotEqual : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Not Equal
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN

    IF  (.BLOCK[.PAS$_Expr_Stack[.PAS$_Expr_Depth-1, Expr_Type], TYP_Class; ,BYTE] EQL TYP_K_Set) AND
	(.BLOCK[.PAS$_Expr_Stack[.PAS$_Expr_Depth,   Expr_Type], TYP_Class; ,BYTE] EQL TYP_K_Set)
    THEN

	! Set Operation, do it
	!
	PAS$_Sem_Set_Binary_Op(Op_Set_Neq)

    ELSE

	! Arithmetic Operation
	!
	PAS$_Sem_Comparison_Binary_Op(Op_Neq);

    END;

GLOBAL ROUTINE PAS$_Sem_Permanent_Symbol (Pathname, Token) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Gets a permanent symbol descriptor for the debug
!	pseudo symbols %R0 - %PSL
!
! FORMAL PARAMETERS:
!
!	Pathname	- The address of a pathname vector (currently not used)
!	Token		- The token corresponding to the debug permanent symbol
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! IMPLICIT OUTPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    MAP
	Pathname		: REF PTH$Pathname;

    LOCAL
	Descriptor		: REF DBG$Permsd;	! Address of permanent symbol descriptor

    IF (.Token LSSU Syn_K_$R0) OR
       (.Token GTRU Syn_K_$PSL)
    THEN
	! Should never happen
	!
	Pascal_Bugcheck(PAS$K_ILLPERM)

    ELSE
	! Permanent symbol
	!
	BEGIN
	BIND
	    Permanent_Symbol_Table	= UPLIT BYTE(DBG$K_R0, DBG$K_R1, DBG$K_R2, DBG$K_R3,
			DBG$K_R4, DBG$K_R5, DBG$K_R6, DBG$K_R7, DBG$K_R8, DBG$K_R9, DBG$K_R10,
			DBG$K_R11, DBG$K_AP, DBG$K_FP, DBG$K_SP, DBG$K_PC, DBG$K_PSL)
	    : VECTOR [17, BYTE];

	LOCAL
	    Permanent_Symbol;

	Permanent_Symbol = .Permanent_Symbol_Table[.Token - Syn_K_$R0];

	! Look up the symbol
	!
	IF DBG$NPERM_SYM_INT(.Permanent_Symbol, Descriptor, 0, .PAS$_Message_Vector)
	THEN
	    BEGIN
	    ! Push value address onto Expression Stack
	    !
	    IF (PAS$_Expr_Depth = .PAS$_Expr_Depth + 1) GEQ Expr_Stack_Depth
	    THEN
		SIGNAL(DBG$_EXPSTKOVR);

	    PAS$_Expr_Stack[.PAS$_Expr_Depth, Expr_Type]	= PAS$_TRW_Unsigned;
	    PAS$_Expr_Stack[.PAS$_Expr_Depth, Expr_Byte_Address]= .Descriptor[DBG$L_Permsd_Addr];
	    PAS$_Expr_Stack[.PAS$_Expr_Depth, Expr_Bit_Offset]	= 0;

	    IF .PAS$_Is_Primary
	    THEN
		! Place address of descriptor in PAS$_Static_Desc
		!
		BEGIN
		PAS$_Static_Desc = .Descriptor;
		PAS$_Result_Type = DBG$K_PERM_DESC;
		END;

	    END

	ELSE
	    ! Error
	    !
	    SIGNAL(DBG$_NOPERMSYM);

	END;

    END;

GLOBAL ROUTINE PAS$_Sem_REM : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	REM
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN

    PAS$_Sem_Arithmetic_Binary_Op(Op_Rem);

    END;

GLOBAL ROUTINE PAS$_Sem_Set_Binary_Op (Op_Code) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Binary operations on sets
!
! FORMAL PARAMETERS:
!
!	Op_Code		- Indicates which Operation is to be Performed
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! IMPLICIT OUTPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! ROUTINE VALUE:
!
!	Condition Status Code
!
!--

    BEGIN
    BIND
	Left_Expr	= PAS$_Expr_Stack[.PAS$_Expr_Depth - 1, 0, A_]
				: BLOCK [,BYTE] FIELD(Expression_Stack_Fields),
	Right_Expr	= PAS$_Expr_Stack[.PAS$_Expr_Depth    , 0, A_]
				: BLOCK [,BYTE] FIELD(Expression_Stack_Fields),

	Left_Set	= .Left_Expr[Expr_Byte_Address]
				: VECTOR [,BYTE],
	Right_Set	= .Right_Expr[Expr_Byte_Address]
				: VECTOR [,BYTE];

    LOCAL
	Left_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
	Right_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),

	Left_Set_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
	Right_Set_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),

	Result_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),

	Result,
	Result_Set		: REF VECTOR [,BYTE],
	Shorter_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
	Longer_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields);

    MACRO
	Result_Expr	= Left_Expr %;

    ! Compute the Result Type
    !
    Result_Type  = 0;

    Left_Type    = .Left_Expr [Expr_Type];
    Right_Type   = .Right_Expr[Expr_Type];

    Left_Set_Type  = .Left_Type [SET_Type];
    Right_Set_Type = .Right_Type[SET_Type];

    ! Check Left and Right for Null Sets
    !
    IF   .Left_Set_Type EQLA 0
    THEN
	Result_Type = .Right_Type

    ELIF .Right_Set_Type EQLA 0
    THEN
	Result_Type = .Left_Type

    ! Check sets for Compatibility
    !
    ELIF .Right_Set_Type[ORD_Type] NEQA .Left_Set_Type[ORD_Type]
    THEN
	SIGNAL(DBG$_NOTCOMPAT)		! Operands are of incompatible types

    ! Sets are Compatible, figure out which to use for value return
    !
    ELSE
	CASE .Op_Code FROM Op_Set_Eql TO Op_Set_Geq OF
	    SET

	[Op_Set_Eql, Op_Set_Neq, Op_Set_Leq, Op_Set_Geq] :

	    Result_Type	= PAS$_TRW_Boolean;

	[INRANGE, OUTRANGE] :

	    IF   .Right_Set_Type EQLA .Left_Set_Type
	    THEN
		Result_Type = .Right_Type

	    ELIF .Right_Set_Type EQLA .Right_Set_Type[ORD_Type]
	    THEN
		Result_Type = .Right_Type

	    ELIF .Left_Set_Type  EQLA .Left_Set_Type[ORD_Type]
	    THEN
		Result_Type = .Left_Type

	    ELSE

		! Cannot use other Set Type entry, create our own
		!
		BEGIN
		Result_Type = PAS$_Create_Type( TYP_K_Set );

		Result_Type[TYP_Packed]		= False;
		Result_Type[TYP_Rst_Class]	= DSC$K_Dtype_Z;
		Result_Type[TYP_Symbol]		= 0;
		Result_Type[TYP_Packed_Size]	= MAX(.Right_Type[TYP_Packed_Size],
							.Left_Type[TYP_Packed_Size]);
		Result_Type[TYP_Full_Size]	= MAX(.Right_Type[TYP_Full_Size],
							.Left_Type[TYP_Full_Size]);

		Result_Type[SET_Type]		= .Right_Set_Type[ORD_Type];
		END;

	    TES;

    ! Find out which operand is shorter. The result is formed in the longer one.
    !
    IF .Right_Type[TYP_Full_Size] LSSU .Left_Type[TYP_Full_Size]
    THEN
	BEGIN
	Result_Set	= Left_Set;
	Shorter_Type	= .Right_Type;
	Longer_Type	= .Left_Type;
	END
    ELSE
	BEGIN
	Result_Set	= Right_Set;
	Shorter_Type	= .Left_Type;
	Longer_Type	= .Right_Type;
	END;

    ! Perform the operation
    !
    CASE .Op_Code FROM Op_Union TO Op_Set_Geq OF
	SET

	[Op_Union] :
	    INCRU Current_Byte FROM 0 TO .Shorter_Type[TYP_Full_Size] - 1 DO
		Result_Set[.Current_Byte] = .Left_Set[.Current_Byte] OR .Right_Set[.Current_Byte];

	[Op_Set_Difference] :
	    BEGIN

	    INCRU Current_Byte FROM 0 TO .Shorter_Type[TYP_Full_Size] - 1 DO
		Result_Set[.Current_Byte] = .Left_Set[.Current_Byte] AND (NOT .Right_Set[.Current_Byte]);

	    CH$FILL(0, .Longer_Type[TYP_Full_Size] - .Shorter_Type[TYP_Full_Size],
			Result_Set[.Shorter_Type[TYP_Full_Size]]);
	    END;

	[Op_Intersection] :
	    BEGIN

	    INCRU Current_Byte FROM 0 TO .Shorter_Type[TYP_Full_Size] - 1 DO
		Result_Set[.Current_Byte] = .Left_Set[.Current_Byte] AND .Right_Set[.Current_Byte];

	    CH$FILL(0, .Longer_Type[TYP_Full_Size] - .Shorter_Type[TYP_Full_Size],
			Result_Set[.Shorter_Type[TYP_Full_Size]]);
	    END;

	[Op_Set_Eql] :
	    Result =
		CH$EQL(.Right_Type[TYP_Full_Size], .Right_Expr[Expr_Byte_Address],
			.Left_Type[TYP_Full_Size],  .Left_Expr[Expr_Byte_Address],
			0);

	[Op_Set_Neq] :
	    Result = NOT
		CH$EQL(.Right_Type[TYP_Full_Size], .Right_Expr[Expr_Byte_Address],
			.Left_Type[TYP_Full_Size],  .Left_Expr[Expr_Byte_Address],
			0);

	[Op_Set_Leq] :
	    Result = (
		BEGIN
		LABEL
		    Set_Leq;

	Set_Leq:BEGIN
		INCRU Current_Byte FROM 0 TO .Shorter_Type[TYP_Full_Size] - 1 DO
		    IF (.Left_Set[.Current_Byte] AND (NOT .Right_Set[.Current_Byte])) NEQ 0
		    THEN
			LEAVE Set_Leq WITH False;

		IF .Left_Type[TYP_Full_Size] GTRU .Right_Type[TYP_Full_Size]
		THEN
		    CH$EQL(0, Right_Set[.Shorter_Type[TYP_Full_Size]],
				.Longer_Type[TYP_Full_Size] - .Shorter_Type[TYP_Full_Size],
				Left_Set[.Shorter_Type[TYP_Full_Size]],
				0)
		ELSE
		    True
		END

		END);

	[Op_Set_Geq] :
	    Result = (
		BEGIN
		LABEL
		    Set_Geq;

	Set_Geq:BEGIN
		INCRU Current_Byte FROM 0 TO .Shorter_Type[TYP_Full_Size] - 1 DO
		    IF (.Right_Set[.Current_Byte] AND (NOT .Left_Set[.Current_Byte])) NEQ 0
		    THEN
			LEAVE Set_Geq WITH False;

		IF .Right_Type[TYP_Full_Size] GTRU .Left_Type[TYP_Full_Size]
		THEN
		    CH$EQL(0, Left_Set[.Shorter_Type[TYP_Full_Size]],
				.Longer_Type[TYP_Full_Size] - .Shorter_Type[TYP_Full_Size],
				Right_Set[.Shorter_Type[TYP_Full_Size]],
				0)
		ELSE
		    True
		END

		END);

	[INRANGE, OUTRANGE] :
	    Pascal_Bugcheck(PAS$K_OPER);

	TES;

    ! Put result on Expression Stack
    !
    PAS$_Expr_Depth			= .PAS$_Expr_Depth - 1;
    Result_Expr[Expr_Type]		= .Result_Type;
    Result_Expr[Expr_Byte_Address]	= .Result_Set;
    Result_Expr[Expr_Value]		= BOOL(.Result);
    END;

GLOBAL ROUTINE PAS$_Sem_Set_1 : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Push a skeletal set entry onto the expression
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! IMPLICIT OUTPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    LOCAL
	Result_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields);

    Result_Type      = 0;

    IF (PAS$_Expr_Depth = .PAS$_Expr_Depth + 1) LSS Expr_Stack_Depth
    THEN
	! Stack the set
	!
	BEGIN

	! Create a Type Entry, of type Set, initialized for the null set
	!
	Result_Type = PAS$_Create_Type( Typ_K_Set );

	Result_Type[TYP_Packed]         = False;
	Result_Type[TYP_Rst_Class]	= DSC$K_Dtype_Z;
	Result_Type[TYP_Symbol]         = 0;
	Result_Type[TYP_Packed_Size]    = 256;
	Result_Type[TYP_Full_Size]      = 32;

	Result_Type[SET_Type]           = 0;

	END
    ELSE
	! Expression Stack Overflow
	!
	SIGNAL(DBG$_EXPSTKOVR);
    
    ! Assign Result Type and clear address
    !
    PAS$_Expr_Stack[.PAS$_Expr_Depth, Expr_Type]		= .Result_Type;
    PAS$_Expr_Stack[.PAS$_Expr_Depth, Expr_Byte_Address]	= 0;
    PAS$_Expr_Stack[.PAS$_Expr_Depth, Expr_Bit_Offset]		= 0;

    END;

GLOBAL ROUTINE PAS$_Sem_Set_2 : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Include the value on top of the stack in the set just below
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! IMPLICIT OUTPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    BIND
	Source_Expr		= PAS$_Expr_Stack[.PAS$_Expr_Depth - 1, 0, A_]
		: BLOCK [,BYTE] FIELD(Expression_Stack_Fields),
	Element_Expr		= PAS$_Expr_Stack[.PAS$_Expr_Depth, 0, A_]
		: BLOCK [,BYTE] FIELD(Expression_Stack_Fields);

    LOCAL
	Source_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
	Element_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields);

    ! Check validity of Set Element
    !
    IF (Element_Type = .Element_Expr[Expr_Type]) NEQA 0
    THEN
	IF .Element_Type[TYP_Class] EQL Typ_K_Ordinal
	THEN
	    IF (Source_Type = .Source_Expr[Expr_Type]) NEQA 0
	    THEN
		IF
		    (IF .Source_Type[Set_Type] EQLA 0
		    THEN
			BEGIN
			LOCAL
			    Base_Type	: REF BLOCK [,BYTE] FIELD(Type_Fields);

			Base_Type = .Element_Type[ORD_Type];

			IF	(.Base_Type NEQA PAS$_TRW_Integer)	AND
				(.Base_Type NEQA PAS$_TRW_Unsigned)
			THEN
			    BEGIN
			    Source_Type[TYP_Packed_Size]= .Base_Type[ORD_Upper] + 1;
			    Source_Type[TYP_Full_Size]	= (.Base_Type[ORD_Upper] + 8) ^ -3;
			    END;

			Source_Type[Set_Type]		= .Base_Type;

			! Allocate space for the set constant
			!
			IF NOT DBG$NLIST_FREEZ(ROUND_BYTE_TO_LONG_(.Source_Type[TYP_Full_Size]),
					Source_Expr[Expr_Byte_Address], .PAS$_Message_Vector)
			THEN
			    SIGNAL(DBG$_NOFREE);

			! Initialize to the null set
			!
			CH$FILL(0, .Source_Type[TYP_Full_Size], .Source_Expr[Expr_Byte_Address]);

			True
			END
		    ELSE
			.Source_Type[Set_Type] EQLA .Element_Type[ORD_Type])
		THEN	

		    ! Add the expression to the set constant
		    !
		    BEGIN
		    BIND
			Base_Type	= Source_Type[SET_Type]
				: REF BLOCK [,BYTE] FIELD(Type_Fields);

		    LOCAL
			Element_Value;

		    ! Get the element value into a longword
		    !
		    IF NOT .Base_Type[ORD_Unsigned]
		    THEN
			Element_Value = .(Element_Expr[Expr_Value])<0, .Element_Type[TYP_Packed_Size], 1>
		    ELSE
			Element_Value = .(Element_Expr[Expr_Value])<0, .Element_Type[TYP_Packed_Size], 0>;

		    ! Check that it's in range
		    !
		    IF
			(IF	(.Source_Type[SET_Type] EQLA PAS$_TRW_Integer)
			    OR
				(.Source_Type[SET_Type] EQLA PAS$_TRW_Unsigned)
			THEN
				(.Element_Value LSS 0) OR (.Element_Value GTR 255)
			ELSE
				(.Base_Type[ORD_Upper] LSSU .Element_Value)
			    OR
				(.Base_Type[ORD_Lower] GTRU .Element_Value))
		    THEN
			SIGNAL(DBG$_SETNOTCOMP);

		    ! Add the value to the set
		    !
		    (.Source_Expr[Expr_Byte_Address])<.Element_Value, 1> = 1;

		    END

		ELSE
		    SIGNAL(DBG$_SETNOTCOMP)	! Element type not compatible with set base type
	    ELSE
		Pascal_Bugcheck(PAS$K_EXPSTK)
	ELSE
	    SIGNAL(DBG$_ILLSETELEM)		! Set element type not scalar or subrange
    ELSE
	Pascal_Bugcheck(PAS$K_EXPSTK);

    ! Decrement Expression Stack (throw away element expression value)
    !
    PAS$_Expr_Depth = .PAS$_Expr_Depth - 1;

    END;

GLOBAL ROUTINE PAS$_Sem_Set_3 : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Add the values in the subrange bracketed by the top 2 values on the
!	Expression Stack to the set just below
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! IMPLICIT OUTPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    BIND
	Source_Expr		= PAS$_Expr_Stack[.PAS$_Expr_Depth - 2, 0, A_]
		: BLOCK [,BYTE] FIELD(Expression_Stack_Fields),
	Lower_Expr		= PAS$_Expr_Stack[.PAS$_Expr_Depth - 1, 0, A_]
		: BLOCK [,BYTE] FIELD(Expression_Stack_Fields),
	Upper_Expr		= PAS$_Expr_Stack[.PAS$_Expr_Depth, 0, A_]
		: BLOCK [,BYTE] FIELD(Expression_Stack_Fields);

    LOCAL
	Lower_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
	Upper_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
	Source_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields);

    ! Check validity of Set Element
    !
    IF  ((Upper_Type = .Upper_Expr[Expr_Type]) NEQA 0) AND
	((Lower_Type = .Lower_Expr[Expr_Type]) NEQA 0)
    THEN
	IF  (.Lower_Type[TYP_Class] EQL Typ_K_Ordinal) AND
	    (.Upper_Type[TYP_Class] EQL Typ_K_Ordinal)
	THEN
	    IF (Source_Type = .Source_Expr[Expr_Type]) NEQA 0
	    THEN
		IF .Lower_Type[ORD_Type] EQLA .Upper_Type[ORD_Type]
		THEN
		    IF NOT
			(IF .Source_Type[Set_Type] EQLA 0
			THEN
			    BEGIN
			    LOCAL
				Base_Type	: REF BLOCK [,BYTE] FIELD(Type_Fields);

			    Base_Type = .Lower_Type[ORD_Type];

			    IF	(.Base_Type NEQA PAS$_TRW_Integer) AND
				(.Base_Type NEQA PAS$_TRW_Unsigned)
			    THEN
				BEGIN
				Source_Type[TYP_Packed_Size]	= .Base_Type[ORD_Upper] + 1;
				Source_Type[TYP_Full_Size]	= (.Base_Type[ORD_Upper] + 8) ^ -3;
				END;

			    Source_Type[Set_Type]		= .Base_Type;

			    ! Allocate space for the set constant
			    !
			    IF NOT DBG$NLIST_FREEZ(ROUND_BYTE_TO_LONG_(.Source_Type[TYP_Full_Size]),
					Source_Expr[Expr_Byte_Address], .PAS$_Message_Vector)
			    THEN
				SIGNAL(DBG$_NOFREE);

			    ! Initialize to the null set
			    !
			    CH$FILL(0, .Source_Type[TYP_Full_Size], .Source_Expr[Expr_Byte_Address]);

			    True
			    END
			ELSE
			    .Source_Type[Set_Type] EQLA .Lower_Type[ORD_Type])
		    THEN
			SIGNAL(DBG$_SETNOTCOMP)	! Set element types not compatible
		    ELSE

			! Add the subrange to the set
			!
		    BEGIN
		    BIND
			Base_Type	= Source_Type[SET_Type]
				: REF BLOCK [,BYTE] FIELD(Type_Fields);

		    LOCAL
			Lower_Value,
			Upper_Value;

		    ! Get the upper and lower values into longwords
		    !
		    IF NOT .Base_Type[ORD_Unsigned]
		    THEN
			BEGIN
			Upper_Value = .(Upper_Expr[Expr_Value])<0, .Upper_Type[TYP_Packed_Size], 1>;
			Lower_Value = .(Lower_Expr[Expr_Value])<0, .Lower_Type[TYP_Packed_Size], 1>;
			END
		    ELSE
			BEGIN
			Upper_Value = .(Upper_Expr[Expr_Value])<0, .Upper_Type[TYP_Packed_Size], 0>;
			Lower_Value = .(Lower_Expr[Expr_Value])<0, .Lower_Type[TYP_Packed_Size], 0>;
			END;

		    ! Check that they're in range
		    !
!		    IF
!			(IF NOT .Base_Type[ORD_Unsigned]
!			THEN
!			    .Lower_Value GTR .Upper_Value
!			ELSE
!			    .Lower_Value GTRU .Upper_Value)
!		    THEN
!			SIGNAL(DBG$_LOWGTRUP);		! Lower bound exceeds upper bound

		    IF
			(IF	(.Source_Type[SET_Type] EQLA PAS$_TRW_Integer)
			    OR
				(.Source_Type[SET_Type] EQLA PAS$_TRW_Unsigned)
			THEN
			    (.Upper_Value GTR 255) OR (.Lower_Value LSS 0)
			ELSE
			    (.Upper_Value GTRU .Base_Type[ORD_Upper])	OR
			    (.Lower_Value LSSU .Base_Type[ORD_Lower]))

		    THEN
			SIGNAL(DBG$_SETNOTCOMP);

		    ! Add the values to the set
		    !
		    INCRU Element_Value FROM .Lower_Value TO .Upper_Value DO
			(.Source_Expr[Expr_Byte_Address])<.Element_Value, 1> = 1;

		    END

		ELSE
		    SIGNAL(DBG$_SETNOTCOMP)	! Set element types not compatible
	    ELSE
		Pascal_Bugcheck(PAS$K_EXPSTK)
	ELSE
	    SIGNAL(DBG$_ILLSETELEM)		! Element type not scalar or subrange
    ELSE
	Pascal_Bugcheck(PAS$K_EXPSTK);

    ! Decrement Expression Stack (throw away subrange bounds expressions)
    !
    PAS$_Expr_Depth = .PAS$_Expr_Depth - 2;

    END;

GLOBAL ROUTINE PAS$_Sem_Set_4 : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Clean up after parsing a set constant
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    BIND
	Source_Expr		= PAS$_Expr_Stack[.PAS$_Expr_Depth, 0, A_]
		: BLOCK [,BYTE] FIELD(Expression_Stack_Fields);

    LOCAL
	Source_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields);

    ! Check for the null set
    !
    Source_Type = .Source_Expr[Expr_Type];

    IF .Source_Type[SET_Type] EQLA 0
    THEN
	BEGIN

	! Allocate space for the set constant
	!
	IF NOT DBG$NLIST_FREEZ(ROUND_BYTE_TO_LONG_(.Source_Type[TYP_Full_Size]),
			Source_Expr[Expr_Byte_Address], .PAS$_Message_Vector)
	THEN
	    SIGNAL(DBG$_NOFREE);

	! Initialize to the null set
	!
	CH$FILL(0, .Source_Type[TYP_Full_Size], .Source_Expr[Expr_Byte_Address]);
	END;

    END;

GLOBAL ROUTINE PAS$_Sem_String ( String_Ptr ) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Semantics for string literal
!
! FORMAL PARAMETERS:
!
!	String_Ptr	- Pointer to the String
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! IMPLICIT OUTPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    MAP
	String_Ptr		: REF BLOCK [,BYTE] FIELD(Str_Fields);

    LOCAL
	Bounds_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
	Result_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
	String_Entry		: REF BLOCK [,BYTE] FIELD(Str_Fields),
	String_Length		: LONG;

    ! Verify that there is space on the stack
    !
    IF (PAS$_Expr_Depth = .PAS$_Expr_Depth + 1) GEQ Expr_Stack_Depth
    THEN
	SIGNAL(DBG$_EXPSTKOVR)

    ELSE
    
	! Scan the strings to get the length
	!
	BEGIN
	String_Length = 0;
	String_Entry  = .String_Ptr;
    
	WHILE .String_Entry NEQ 0 DO
	    BEGIN
	    String_Length = .String_Length + .String_Entry[Str_Length];
	    String_Entry  = .String_Entry[Str_Next];
	    END;
	
	! Four cases: if length > 1, Packed Array [1..n] of Char
	!             length = 1, Char
	!	      length = 0, Packed Varying [0] of Char
	!             length < 0, Error
	!
	IF .String_Length GTR 1
	THEN
    
	    ! Allocate a type entry for the bounds (subrange)
	    !
	    BEGIN
	    LOCAL
		Current_Byte;

	    Bounds_Type = PAS$_Create_Type( Typ_K_Ordinal );
	
	    Bounds_Type[Typ_Packed]         = False;
	    Bounds_Type[Typ_Rst_Class]      = DSC$K_Dtype_Z;
	    Bounds_Type[Typ_Symbol]         = 0;
	    Bounds_Type[Typ_Packed_Size]    = 32;
	    Bounds_Type[Typ_Full_Size]      = 4;
	
	    Bounds_Type[ORD_Type]           = PAS$_TRW_INTEGER;
	    Bounds_Type[ORD_Lower]          = 1;
	    Bounds_Type[ORD_Upper]          = .String_Length;
	    Bounds_Type[ORD_DType]          = L_int;
	    Bounds_Type[ORD_Enum_Count]     = 0;
	    Bounds_Type[ORD_Enum_Element]   = 0;
	
	    ! Allocate a type entry for the array
	    !
	    Result_Type = PAS$_Create_Type( Typ_K_Array );
	
	    Result_Type[Typ_Packed]         = True;
	    Result_Type[Typ_Rst_Class]	    = DSC$K_Dtype_Z;
	    Result_Type[Typ_Symbol]         = 0;
	    Result_Type[Typ_Packed_Size]    = .String_Length * 8;
	    Result_Type[Typ_Full_Size]      = .String_Length;
	
	    Result_Type[Arr_Type]           = PAS$_TRW_CHAR;
	    Result_Type[Arr_IType]          = .Bounds_Type;

	    ! Stack the address
	    !
	    IF .String_Ptr[STR_Next] NEQA 0
	    THEN
		! More than one string block
		!
		BEGIN
		IF NOT DBG$NLIST_FREEZ(ROUND_BYTE_TO_LONG_(.String_Length),
			PAS$_Expr_Stack[.PAS$_Expr_Depth, Expr_Byte_Address], .PAS$_Message_Vector)
		THEN
		    SIGNAL(DBG$_NOFREE);

		Current_Byte	= .PAS$_Expr_Stack[.PAS$_Expr_Depth, Expr_Byte_Address];
		String_Entry	= .String_Ptr;

		WHILE .String_Entry NEQA 0 DO
		    BEGIN
		    MOVEBYTE(.String_Entry[STR_Length], String_Entry[STR_First_Char], .Current_Byte);
		    Current_Byte	= .Current_Byte + .String_Entry[STR_Length];
		    String_Entry	= .String_Entry[STR_Next];
		    END;
		END

	    ELSE
		PAS$_Expr_Stack[.PAS$_Expr_Depth, Expr_Byte_Address] = String_Ptr[STR_First_Char];

	    PAS$_Expr_Stack[.PAS$_Expr_Depth, Expr_Bit_Offset]	= 0;

	    PAS$_Expr_Stack[.PAS$_Expr_Depth, Expr_Type]	= .Result_Type;
	    END
    
	ELIF .String_Length EQL 1
	THEN
    
	    ! CHAR type entry
	    !
	    BEGIN
	    LOCAL
		String_Char		: BYTE UNSIGNED;

	    PAS$_Expr_Stack[.PAS$_Expr_Depth, Expr_Type]     = PAS$_TRW_CHAR;

	    ! Extract the character
	    !
	    String_Entry = .String_Ptr;

	    WHILE .String_Entry NEQ 0 DO
		IF .String_Entry[Str_Length] NEQ 0
		THEN
		    BEGIN
		    String_Char	= .(String_Entry[Str_First_Char])<B0_>;
		    EXITLOOP;
		    END
		ELSE
		    String_Entry= .String_Entry[Str_Next];

	    ! Stack the character
	    !
	    (PAS$_Expr_Stack[.PAS$_Expr_Depth, Expr_Value])<B0_> = .String_Char;
	    END
    
	ELIF .String_Length EQL 0
	THEN
    
	    ! Zero-Length Strings are constants of VARYING [0]
	    !
	    BEGIN

	    ! Mask partial implementation
	    !
	    SIGNAL(DBG$_NULLSTRNG);

	    ! Allocate a type entry for the varying
	    !
	    Result_Type	= PAS$_Create_Type(TYP_K_Varying);

	    Result_Type[TYP_Packed]		= True;
	    Result_Type[TYP_Rst_Class]		= DSC$K_Dtype_Z;
	    Result_Type[TYP_Symbol]		= 0;
	    Result_Type[TYP_Packed_Size]	= 16;
	    Result_Type[TYP_Full_Size]		= 2;
	    Result_Type[VARY_Type]		= PAS$_TRW_Char;
	    Result_Type[VARY_Bound]		= 0;

	    PAS$_Expr_Stack[.PAS$_Expr_Depth, Expr_Type] = .Result_Type;

	    PAS$_Expr_Stack[.PAS$_Expr_Depth, Expr_Byte_Address]= 0;
	    PAS$_Expr_Stack[.PAS$_Expr_Depth, Expr_Bit_Offset]	= 0;
	    END

	ELSE
	    Pascal_Bugcheck(PAS$K_NEGSTR);

	END;
    
    END;

GLOBAL ROUTINE PAS$_Sem_Subscript : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Semantics for a subscript
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Stack	- The Expression Stack contains:
!			    1) The Array Type info
!			    2) The Index Type info
!
! IMPLICIT OUTPUTS:
!
!	PAS$_Expr_Stack	- The Expression Stack contains:
!			    1) The Variable Type info
!
! ROUTINE VALUE:
!
!	Condition Status
!
!--

    BEGIN
    BIND
	Source_Expr		= PAS$_Expr_Stack[.PAS$_Expr_Depth-1, 0, A_]
		: BLOCK [,BYTE] FIELD(Expression_Stack_Fields),
	Index_Expr		= PAS$_Expr_Stack[.PAS$_Expr_Depth  , 0, A_]
		: BLOCK [,BYTE] FIELD(Expression_Stack_Fields);

    LOCAL
	Subscript_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
	Source_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
	Index_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
	Result_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
	Index_Value,
	Bit_Offset;

    MACRO
	Result_Expr		= Source_Expr %;

    Source_Type      = .Source_Expr[Expr_Type];
    Index_Type       = .Index_Expr[Expr_Type];
    Result_Type      = 0;

    IF .Source_Type EQL 0
    THEN
	SIGNAL(DBG$_NOTARRAY)

    ELSE

	! Source Type is Defined, check for errors
	!
	BEGIN
	Subscript_Type = .Source_Type[ARR_IType];

	IF .Source_Type[Typ_Class] NEQ Typ_K_Array
	THEN
	    SIGNAL(DBG$_NOTARRAY)		! Type of variable is not array

	ELIF .Index_Type[Typ_Class] NEQ Typ_K_Ordinal
	THEN
	    SIGNAL(DBG$_ILLINDTYPE)		! Index type must be scalar or subrange

	ELIF .Subscript_Type EQL 0
	THEN
	    Pascal_Bugcheck(PAS$K_EXPSTK)	! No subscript

	ELIF .Subscript_Type[Typ_Class] NEQ Typ_K_Ordinal
	THEN
	    Pascal_Bugcheck(PAS$K_EXPSTK)	! Illegal array description

	ELIF .Subscript_Type[ORD_Type] NEQ .Index_Type[ORD_Type]
	THEN
	    SIGNAL(DBG$_INDNOTCOMP)		! Index type not compatible with declaration

	ELSE
	    BEGIN

	    ! Extract the index value to a longword
	    !
	    IF .Subscript_Type[ORD_Unsigned]
	    THEN
		Index_Value = .(Index_Expr[Expr_Value])<0, .Subscript_Type[TYP_Packed_Size], 0>
	    ELSE
		Index_Value = .(Index_Expr[Expr_Value])<0, .Subscript_Type[TYP_Packed_Size], 1>;

	    ! Bounds check
	    !
	    IF
		(IF .Subscript_Type[ORD_Unsigned]
		THEN
		    (.Index_Value LSSU .Subscript_Type[ORD_Lower])	OR
		    (.Index_Value GTRU .Subscript_Type[ORD_Upper])
		ELSE
		    (.Index_Value LSS .Subscript_Type[ORD_Lower])	OR
		    (.Index_Value GTR .Subscript_Type[ORD_Upper])
		)
	    THEN
		SIGNAL(DBG$_SUBOUTBNDS, .Index_Value, .Subscript_Type);

	    ! We've passed all the tests!
	    !

	    ! Change the type to the element type
	    !
	    Result_Type = .Source_Type[ARR_Type];

	    IF .PAS$_Is_Primary
	    THEN
		BEGIN

		! Push the subscript value onto the Primary Descriptor
		!
		PAS$_Push_Primary_Operand(.Index_Expr[Expr_Value]);

		! Change the size field
		!
		IF .Source_Type[TYP_Packed]
		THEN
		    PAS$_Static_Desc[PAS$PRIM_Size] = .Result_Type[TYP_Packed_Size]
		ELSE
		    PAS$_Static_Desc[PAS$PRIM_Size] = .Result_Type[TYP_Full_Size] * 8;
		END;

	    ! Calculate bit offset
	    !
	    Bit_Offset	= (.Index_Expr[Expr_Value] - .Subscript_Type[ORD_Lower]) *
			(IF .Source_Type[TYP_Packed]
			THEN
			    .Result_Type[TYP_Packed_Size]
			ELSE
			    .Result_Type[TYP_Full_Size] * 8);

	    ! Add indexing offset to current address
	    !
	    Source_Expr[Expr_Bit_Offset]	= .Source_Expr[Expr_Bit_Offset] + .Bit_Offset;
	    Source_Expr[Expr_Byte_Address]	= .Source_Expr[Expr_Byte_Address] +
						(.Source_Expr[Expr_Bit_Offset] ^ -3);
	    Source_Expr[Expr_Bit_Offset]	= .Source_Expr[Expr_Bit_Offset] AND %X'00000007';

	    END;

	END;

    ! Set up result info
    !
    PAS$_Expr_Depth		= .PAS$_Expr_Depth - 1;
    Result_Expr[Expr_Type]	= .Result_Type;

    END;

GLOBAL ROUTINE PAS$_Sem_Subtraction : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Subtraction
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN

    IF  (.BLOCK[.PAS$_Expr_Stack[.PAS$_Expr_Depth-1, Expr_Type], TYP_Class; ,BYTE] EQL TYP_K_Set) AND
	(.BLOCK[.PAS$_Expr_Stack[.PAS$_Expr_Depth,   Expr_Type], TYP_Class; ,BYTE] EQL TYP_K_Set)
    THEN

	! Set Operation, do it
	!
	PAS$_Sem_Set_Binary_Op(Op_Set_Difference)

    ELSE

	! Arithmetic Operation
	!
	PAS$_Sem_Arithmetic_Binary_Op(Op_Sub);

    END;

GLOBAL ROUTINE PAS$_Sem_Uparrow : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	This routine performs a pointer dereference
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! IMPLICIT OUTPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    BIND
	Source_Expr		= PAS$_Expr_Stack[.PAS$_Expr_Depth, 0, A_]
		: BLOCK [,BYTE] FIELD(Expression_Stack_Fields);

    LOCAL
	Size,
	Base_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
	Fetch_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields);

    ! Initialize Variables
    !
    Fetch_Type       = .Source_Expr[Expr_Type];

    IF .Fetch_Type NEQ 0
    THEN
	BEGIN

	CASE .Fetch_Type[TYP_Class] FROM Typ_K_Array TO Typ_K_Varying OF
	    SET

	    ! Pointer type, point to type
	    !
[Typ_K_Pointer]:
	    BEGIN

	    IF .Fetch_Type EQLA PAS$_TRW_Nil
	    THEN
		! Attempt to dereference NIL
		!
		SIGNAL(DBG$_NILREF);

	    ! Check read access
	    !
	    PAS$_Read_Access(Source_Expr[Expr_Byte_Address], 32);

	    Base_Type			= .Fetch_Type[PTR_Type];
	    Source_Expr[Expr_Type]	= .Fetch_Type[PTR_Type];

	    ! Dereference the pointer
	    !
	    Source_Expr[Expr_Byte_Address]	= .(.Source_Expr[Expr_Byte_Address])
						<.Source_Expr[Expr_Bit_Offset], 32, 0>;
	    Source_Expr[Expr_Bit_Offset]	= 0;

	    ! Get the size of the object pointed to
	    !
	    Size			= .Base_Type[TYP_Full_Size] * 8;
	    END;


	    ! File Type, point to file element
	    !
[Typ_K_File]:
	    BEGIN

	    ! Check read access to the file variable
	    !
	    PAS$_Read_Access(Source_Expr[Expr_Byte_Address], 32);

	    Base_Type			= .Fetch_Type[FIL_Type];
	    Source_Expr[Expr_Type]	= .Fetch_Type[FIL_Type];

	    ! Fetch the address of the file buffer.
	    !
	    IF .Fetch_Type[FIL_Version] EQL 0
	    THEN
		! Pascal V2
		!
		IF .(.Source_Expr[Expr_Byte_Address])<B0_> EQL 0
		THEN
		    ! Pascal V2.0. The file buffer starts at an offset of 16(10)
		    ! from the start of the File Variable.
		    !
		    Source_Expr[Expr_Byte_Address] = .Source_Expr[Expr_Byte_Address] + 16
		ELSE
		    SIGNAL(DBG$_FILEVERS)

	    ELIF .Fetch_Type[FIL_Version] EQL 1
	    THEN
		! Pascal V1.2. The file pointer is the first longword in
		! the File Status Block
		!
		Source_Expr[Expr_Byte_Address] = ..Source_Expr[Expr_Byte_Address]

	    ELSE
		! Unsupported version
		!
		SIGNAL(DBG$_FILEVERS);

	    Source_Expr[Expr_Bit_Offset]= 0;

	    Size			= .Base_Type[TYP_Full_Size] * 8;
	    END;


	    ! None of the Above, error
	    !
[INRANGE]:
	    SIGNAL(DBG$_NOTPTR);	! Variable must be of pointer or file type

[OUTRANGE]:
	    Pascal_BugCheck(PAS$K_TYPCLASS);

	    TES;

	IF .PAS$_Is_Primary
	THEN
	    BEGIN
	    PAS$_Static_Desc[PAS$PRIM_Operations]	= .PAS$_Static_Desc[PAS$PRIM_Operations] + 1;
	    PAS$_Static_Desc[PAS$PRIM_Size]		= .Size;
	    END;

	END

    ELSE
	Pascal_Bugcheck(PAS$K_EXPSTK);

    END;

GLOBAL ROUTINE PAS$_Sem_Variable ( Pathname, Symbol_Name ) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	This routine processes an identifier (usually a variable) reference
!
! FORMAL PARAMETERS:
!
!	Pathname	- Address of a pathname vector
!	Symbol_Name	- Address of a Name Table entry
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! IMPLICIT OUTPUTS:
!
!	PAS$_Expr_Depth	- Current Depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    MAP
	Pathname			: REF PTH$Pathname,
	Symbol_Name			: REF BLOCK [,BYTE] FIELD(NAM_Fields);

    LOCAL
	Symbol_Entry			: REF BLOCK [,BYTE] FIELD(Symbol_Fields),
	Value_Kind,
	Frame,
    	Size;						! Size in bits of variable

    ! Check for Expression Stack Overflow
    !
    IF (PAS$_Expr_Depth = .PAS$_Expr_Depth + 1) GEQ Expr_Stack_Depth
    THEN
	SIGNAL(DBG$_EXPSTKOVR)
    ELSE
    
	BEGIN
	BIND
	    Expr		= PAS$_Expr_Stack[.PAS$_Expr_Depth, 0, A_]
			: BLOCK [,BYTE] FIELD(Expression_Stack_Fields);

	Expr[Expr_Type]	= 0;
    	Size		= 0;

	! Look up the symbol in the RST
	!
	Symbol_Entry = PAS$_Get_Symbol(.Pathname, .Symbol_Name);

	! Stack address of the variable (or whatever)
	!
	IF .Symbol_Entry[SYM_Rst_Symid] EQL 0
	THEN
	    IF .Symbol_Entry[SYM_Class] EQL SYM_K_Constant
	    THEN
		BEGIN
		Expr[Expr_Byte_Address]	= Symbol_Entry[CON_Literal];
		Expr[Expr_Bit_Offset]	= 0;
		Value_Kind		= DBG$K_Val_Literal;
		Frame			= 0;
		END
	    ELSE
		SIGNAL(DBG$_NOVALUE)
	ELSE
	    BEGIN
	    DBG$STA_Setcontext(.Symbol_Entry[SYM_Rst_Symid]);

	    PAS$_Get_Value(.Symbol_Entry[SYM_Rst_Symid], Expr[Expr_Byte_Address], Value_Kind, Frame);
	    END;

	! Stack pointer to the type
	!
	CASE .Symbol_Entry[SYM_Class] FROM SYM_K_Constant TO SYM_K_Line OF
	    SET

[SYM_K_Constant]:
	    BEGIN
	    LOCAL
		Type_Entry	: REF BLOCK [,BYTE] FIELD(Type_Fields);

	    Type_Entry = .Symbol_Entry[CON_Type];

	    Expr[Expr_Type]	= .Type_Entry;
    	    Size		= .Type_Entry[TYP_Full_Size] * 8;
	    END;

[SYM_K_Variable]:
    	    BEGIN
    	    LOCAL
    		Type_Entry	: REF BLOCK [,BYTE] FIELD(Type_Fields);

    	    Type_Entry = .Symbol_Entry[VAR_Type];

	    Expr[Expr_Type]	= .Type_Entry;
	    Size		= .Type_Entry[TYP_Full_Size] * 8;
    	    END;

[SYM_K_Procedure]:
    	    IF NOT .PAS$_Is_Primary
    	    THEN
    		! Illegal in expressions
    		!
    		SIGNAL(DBG$_NOVALUE)
	    ELSE
		Size		= 0;

[SYM_K_Function] :
	    IF NOT .PAS$_Is_Primary
	    THEN
		! Illegal in expressions
		!
		SIGNAL(DBG$_NOVALUE)
	    ELSE
		BEGIN
		LOCAL
		    Type_Entry	: REF BLOCK [,BYTE] FIELD(Type_Fields);

		Type_Entry = .Symbol_Entry[PROC_Func_Type];

		Expr[Expr_Type]	= .Type_Entry;
		Size		= .Type_Entry[TYP_Full_Size] * 8;
		END;

![SYM_K_Field] :

[SYM_K_Label, SYM_K_Line] :
    	    IF NOT .PAS$_Is_Primary
    	    THEN
    		! Illegal in expressions
    		!
    		SIGNAL(DBG$_NOVALUE)
	    ELSE
		Size		= 0;

[INRANGE] : SIGNAL(DBG$_NOVALUE);	! Reference does not have a value

[OUTRANGE]: Pascal_Bugcheck(PAS$K_TYPCLASS);

	    TES;

	IF .PAS$_Is_Primary
	THEN
	    BEGIN

	    ! Set size field
	    !
	    PAS$_Static_Desc[PAS$PRIM_Size] = .Size;

	    ! Set address field
	    !
	    PAS$_Static_Desc[PAS$PRIM_Byte_Address]	= .Expr[Expr_Byte_Address];
	    PAS$_Static_Desc[PAS$PRIM_Bit_Offset]	= .Expr[Expr_Bit_Offset];

	    ! Set frame field
	    !
	    PAS$_Static_Desc[PAS$PRIM_Frame] = .Frame;

	    ! Set kind field
	    !
	    PAS$_Static_Desc[PAS$PRIM_Kind] = .Value_Kind;

	    IF .Symbol_Entry[SYM_Rst_Symid] EQLA 0
	    THEN
		! Predefined constant, thus no RST entry
		!
		PAS$_Static_Desc[PAS$PRIM_Symbol] = .Symbol_Entry;

	    ! Push the identifier symid into the Primary Descriptor
	    !
	    PAS$_Push_Primary_Operand(.Symbol_Entry[SYM_Rst_Symid]);
	    END;

	END;

    END;

GLOBAL ROUTINE PAS$_Sem_Variable_Reference : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Variable reference
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    BIND
	Source_Expr		= PAS$_Expr_Stack[.PAS$_Expr_Depth, 0, A_]
		: BLOCK [,BYTE] FIELD(Expression_Stack_Fields);

    LOCAL
	Condition_Status	: LONG,
	Fetch_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields);

    Fetch_Type       = .Source_Expr[Expr_Type];

    ! Fetch the value, if possible
    !
    IF .Fetch_Type NEQ 0
    THEN
	BEGIN

	CASE .Fetch_Type[TYP_Class] FROM TYP_K_Array TO TYP_K_Varying OF
	    SET

	    ! Fetch the value
	    !
[TYP_K_Pointer,
 TYP_K_Ordinal,
 TYP_K_Real]:
	    BEGIN
	    LOCAL
		Fetch_DType		: LONG;
    
	    ! Get data type
	    !
	    Fetch_DType =
		(SELECTONE .Fetch_Type[TYP_Class] OF
		    SET
[Typ_K_Ordinal]:    .Fetch_Type[ORD_DType];
[Typ_K_Real]:	    .Fetch_Type[Real_DType];
[OTHERWISE]:	    LU_int;
		    TES);

	    ! Get the value
	    !
	    IF NOT (Condition_Status = PAS$_Arith_Fetch(.Fetch_Dtype, Source_Expr[Expr_Byte_Address],
				Source_Expr[Expr_Value], .Fetch_Type[TYP_Packed_Size]))
	    THEN
		SIGNAL(.Condition_Status);

	    ! Range check on ordinal types
	    !
	    IF .Fetch_Type[TYP_Class] EQL TYP_K_Ordinal
	    THEN
		BEGIN
		LOCAL
		    Fetch_Value;

		IF .Fetch_Type[ORD_Unsigned]
		THEN
		    BEGIN
		    Fetch_Value = .(Source_Expr[Expr_Value])<0, .Fetch_Type[TYP_Packed_Size], 0>;

		    IF	(.Fetch_Value GTRU .Fetch_Type[ORD_Upper])	OR
			(.Fetch_Value LSSU .Fetch_Type[ORD_Lower])
		    THEN
			SIGNAL(DBG$_ILLSCALAR, .Fetch_Value);
		    END
		ELSE
		    BEGIN
		    Fetch_Value = .(Source_Expr[Expr_Value])<0, .Fetch_Type[TYP_Packed_Size], 1>;

		    IF	(.Fetch_Value GTR .Fetch_Type[ORD_Upper])	OR
			(.Fetch_Value LSS .Fetch_Type[ORD_Lower])
		    THEN
			SIGNAL(DBG$_ILLSCALAR, .Fetch_Value);
		    END;
		END;

	    END;

	    ! Structure. Do nothing (address is already on the Expression Stack)
	    !
[TYP_K_Array,
 TYP_K_File,
 TYP_K_Record,
 TYP_K_Varying]:
	    ;

	    ! Set. Allocate a temporary and move the set into it
	    !
[TYP_K_Set]:
	    BEGIN
	    LOCAL
		Set_Temp	: DBG$Address_Desc;	! Temp address descriptor

	    Set_Temp[DBG$L_Address_Bit_Offset]	= 0;

	    ! Allocate the space
	    !
	    IF NOT DBG$NLIST_FREEZ(ROUND_BYTE_TO_LONG_(.Fetch_Type[TYP_Full_Size]), Set_Temp[DBG$L_Address_Byte_Addr],
			.PAS$_Message_Vector)
	    THEN
		SIGNAL(DBG$_NOFREE);

	    ! Copy the set
	    !
	    PAS$_Assign(Source_Expr[Expr_Byte_Address], .Fetch_Type[TYP_Packed_Size], .Fetch_Type,
			Set_Temp, .Fetch_Type[TYP_Full_Size] * 8, .Fetch_Type);

	    ! Copy the address into the Expression Stack
	    !
	    MOVELONG(2, Set_Temp, Source_Expr[Expr_Byte_Address]);

	    END;

[INRANGE]:  SIGNAL(DBG$_NOVALUE);	! Reference does not have a value

[OUTRANGE]: Pascal_BugCheck(PAS$K_TYPCLASS);

	    TES;
	END;

    END;
END
ELUDOM
