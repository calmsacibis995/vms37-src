!----------------------------------------------------------------------
!
!	DBGLIB -- COMMON DEFINITION FILE FOR THE VAX DEBUGGER
!
!----------------------------------------------------------------------
!
!
!**+
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
!**-
!
! WRITTEN BY
!	Bert Beander	June, 1980.
!
! MODIFIED BY
!	Richard Title   Sep,  1981	Added DBG$K_TYPE_VERB to implement
!					the TYPE command
! MODULE FUNCTION:
!	This REQUIRE file contains all literal, macro, and data structure defin-
!	itions used by new Bliss modules in the Debugger.  Old Bliss modules do
!	not use this file for historical reasons.
!

!			T A B L E   O F   C O N T E N T S
!
!
!
!	General Debugger Definitions  . . . . . . . . . . . . . . . .   4
!	    Data Structure Definition and Access  . . . . . . . . . .   4
!	    Bliss-32 Language Extensions  . . . . . . . . . . . . . .   4
!	    Miscellaneous Literals  . . . . . . . . . . . . . . . . .   6
!	    Utility Macros  . . . . . . . . . . . . . . . . . . . . .   9
!
!	Address Descriptor Definitions  . . . . . . . . . . . . . . .  10
!
!	Address Expression Descriptor Definitions   . . . . . . . . .  11
!
!	Error Status Codes  . . . . . . . . . . . . . . . . . . . . .  12
!
!	Free Memory Management  . . . . . . . . . . . . . . . . . . .  13
!	    Format of a Free Memory Block   . . . . . . . . . . . . .  13
!	    Format of an Allocated Memory Block   . . . . . . . . . .  14
!	    Overall Structure of Memory Pool  . . . . . . . . . . . .  16
!	    Temporary Memory Blocks   . . . . . . . . . . . . . . . .  18
!
!	Image File Header Definitions   . . . . . . . . . . . . . . .  19
!
!	Least Recently Used Module Table Definitions  . . . . . . . .  21
!
!	Linked List Node Definition   . . . . . . . . . . . . . . . .  22
!
!	Pathname Descriptor Definitions   . . . . . . . . . . . . . .  23
!
!	Permanent Symbol Descriptor Definitions   . . . . . . . . . .  25
!
!	Run-Time Symbol Table (RST) Definitions   . . . . . . . . . .  27
!	    RST Entry Common Core   . . . . . . . . . . . . . . . . .  28
!	    RST Entry for a Module  . . . . . . . . . . . . . . . . .  31
!	    RST Entry for a Routine   . . . . . . . . . . . . . . . .  34
!	    RST Entry for a Lexical Block   . . . . . . . . . . . . .  36
!	    RST Entry for an Entry Point  . . . . . . . . . . . . . .  37
!	    RST Entry for an Instruction Label  . . . . . . . . . . .  38
!	    RST Entry for a Line Number   . . . . . . . . . . . . . .  39
!	    RST Entry for a Data Symbol   . . . . . . . . . . . . . .  40
!	    RST Entry for a Data Type Component   . . . . . . . . . .  42
!	    RST Entry for a Data Type   . . . . . . . . . . . . . . .  43
!	    RST Entry for a Record Variant Set  . . . . . . . . . . .  45
!	    RST Entry for an Invocation Number  . . . . . . . . . . .  48
!
!	Scope List Definitions  . . . . . . . . . . . . . . . . . . .  49
!
!	Source Directory Search List  . . . . . . . . . . . . . . . .  50
!	    Source Directory Search List Header Block   . . . . . . .  51
!	    Source Directory Search List Entry  . . . . . . . . . . .  52
!
!	Source File Control Block   . . . . . . . . . . . . . . . . .  53
!
!	Source File ID Table  . . . . . . . . . . . . . . . . . . . .  55
!
!	Static Address Table (SAT) Definitions  . . . . . . . . . . .  56
!
!	Value and Primary Descriptor Definitions  . . . . . . . . . .  58
!
!	Old Debugger Definitions  . . . . . . . . . . . . . . . . . .  60
!

!		G E N E R A L   D E B U G G E R   D E F I N I T I O N S
!
!
!
!	The declarations in this section define symbols of general utility
!	throughout the Debugger.  This includes widely used literals and
!	various utility macros.
!
!
!
!**+
!
!	DATA STRUCTURE DEFINITION AND ACCESS
!
!
!	Here we declare all the macros used to define and acccess BLISS data
!	structures.  These are the names L_, W_, B_, W0_, W1_, and so forth.
!	The actual definitions are in a separate REQUIRE file, but they are
!	required for the LIBRARY compilation of the present REQUIRE file.
!
LIBRARY 'SRC$:STRUCDEF.L32';
!
!**-
!
!
!	BLISS-32 LANGUAGE EXTENSIONS
!
!
!**+
!	Here we declare various minor extensions to the Bliss-32 langauge.
!
LITERAL
	TRUE	= 1,			! Define TRUE and FALSE
	FALSE	= 0;			!
!**-

MACRO
	REPEAT		= WHILE 1 DO%,	! Infinite Loop


! ZEROCOR zeroes an area of memory.  The two parameters are ADDRESS and COUNT,
! which are the address of the area to be zeroed and the number of contiguous
! longwords to be zeroed, respectively.
!
	ZEROCOR (ADDRESS, COUNT) =
		CH$FILL (0, (COUNT) * 4, CH$PTR (ADDRESS))%,

	ONEOF (X) [] =
		(MASK (%REMAINING)) ^ (X) LSS 0%,

	OR_OP (X) [] =
		OR%,

	MASK (X) [] =
		1 ^ (31-X) OR_OP (%REMAINING) MASK (%REMAINING)%,

	ch$sequence (n) =
		VECTOR [ch$allocation (n)]%,

	CONSECUTIVE [X] = LITERAL X = %COUNT%;

!	MISCELLANEOUS LITERALS
!
!
!
!	This section defines literals which are used throughout the Debugger but
!	which do not belong with any specific data structures.
!
!**+
!
! Define the Debug Language Codes.
!
LITERAL
	DBG$K_MACRO	= 0,		! Macro
	DBG$K_FORTRAN	= 1,		! Fortran
	DBG$K_BLISS	= 2,		! Bliss-32
	DBG$K_COBOL	= 3,		! Cobol-74, Cobol-79
	DBG$K_BASIC	= 4,		! Basic
	DBG$K_PLI	= 5,		! PL/I
	DBG$K_PASCAL	= 6,		! Pascal
	DBG$K_C		= 7,		! C
	DBG$K_DIBOL	= 8,		! Dibol
	DBG$K_CORAL	= 9,		! Coral
	DBG$K_PEARL	= 10,		! Pearl
	DBG$K_ADA	= 11,		! Ada
	DBG$K_APL	= 12;		! APL


! Object type literals.  These values are used by the Address Expression
! Interpreter and the Command Language Interpreter to identity the objects
! returned by the Address Expression Interpreter.  Some of these values also
! appear in certain descriptors including the Primary, Value, and Address
! Expression descriptors.
!
LITERAL
	DBG$K_LITERAL		= 120,	! Literal value
	DBG$K_PRIMARY_DESC	= 121,	! Primary descriptor
	DBG$K_VALUE_DESC	= 122,	! Value descriptor
	DBG$K_PERM_DESC		= 123,	! Permanent Symbol descriptor
	DBG$K_INSTRUCTION	= 124,	! Instruction
	DBG$K_NC_INSTRUCTION	= 125,	! Named constant, instruction type
	DBG$K_NC_OTHER		= 126,	! Named constant, not instruction
	DBG$K_OTHER		= 127,	! Language-specific data type
	DBG$K_NOTYPE		= 128,	! Virtual address without any type
	DBG$K_EXTERNAL_DESC	= 129,	! External (printable) format
	DBG$K_VAX_DESC		= 130,	! VAX standard descriptor
	DBG$K_V_VALUE_DESC	= 131;	! Volatile Value descriptor


! Define the Radix literals.
!
LITERAL
	DBG$K_DEFAULT	= 1,		! Default source language radix
	DBG$K_BINARY	= 2,		! Binary radix
	DBG$K_OCTAL	= 8,		! Octal radix
	DBG$K_DECIMAL	= 10,		! Decimal radix
	DBG$K_HEX	= 16;		! Hexadecimal radix


! Define Pseudo-Symbol codes.
!
LITERAL
	DBG$K_CURRENT_LOC	= 220,	! Current location "."
	DBG$K_PREDECESSOR	= 221,	! Previous location "^"
	DBG$K_SUCCESSOR		= 222,	! Next location <CR>
	DBG$K_LAST_VALUE	= 223,	! Last value "\"
    	DBG$K_INDIRECTION	= DBG$K_CURRENT_LOC;
    					! An alternative meaning of "."
    					! 	is indirection


! Token type literals. These are used by the Pathname Parser and scanners.
!
LITERAL
	DBG$K_TOK_NULL		= 0,	! Null or EOL token
	DBG$K_TOK_INVAL		= 1,	! Invalid token
	DBG$K_TOK_LINE		= 2,	! '%LINE' token
	DBG$K_TOK_LABEL		= 3,	! '%LABEL' token
	DBG$K_TOK_BS		= 4,	! '\' token
	DBG$K_TOK_ID		= 5,	! ID token
	DBG$K_TOK_INT		= 6,	! integer token
	DBG$K_TOK_DOT		= 7,	! '.' token
	DBG$K_TOK_REG		= 8,	! '%REGISTER' token
	DBG$K_TOK_QNAME		= 9,	! '%NAME' token
	DBG$K_TOK_LOWEST	=DBG$K_TOK_NULL,
	DBG$K_TOK_HIGHEST	=DBG$K_TOK_QNAME;


! Return state values for the Pathname Parser
!
LITERAL
	DBG$K_PN		= 0,	! Data reference or lexical reference
	DBG$K_REG		= 1,	! Register reference
	DBG$K_LINE		= 2,	! '%LINE' reference
	DBG$K_LABEL		= 3;	! '%LABEL' reference


! Command verb literals. These are used by the Command Line Interpreter.
!
LITERAL
	DBG$K_AT_SIGN_VERB	= 1,	! @
	DBG$K_CALL_VERB		= 2,	! CALL
	DBG$K_CANCEL_VERB	= 3,	! CANCEL
	DBG$K_DEFINE_VERB	= 4,	! DEFINE 
	DBG$K_DEPOSIT_VERB	= 5,	! DEPOSIT
	DBG$K_EVALUATE_VERB	= 6,	! EVALUATE
	DBG$K_EXAMINE_VERB	= 7,	! EXAMINE
	DBG$K_EXIT_VERB		= 8,	! EXIT 
	DBG$K_GO_VERB		= 9,	! GO 
	DBG$K_SET_VERB		= 10,	! SET
	DBG$K_SHOW_VERB		= 11,	! SHOW
	DBG$K_STEP_VERB		= 12,	! STEP
	DBG$K_HELP_VERB		= 13,	! HELP	
        DBG$K_TYPE_VERB		= 14,	! TYPE
    	DBG$K_SEARCH_VERB	= 15,	! SEARCH

	DBG$K_FIRST_VERB 	= DBG$K_AT_SIGN_VERB,
	DBG$K_LAST_VERB		= DBG$K_SEARCH_VERB;


! Value kind literals.  These values are returned as "value kinds" by routines
! DBG$STA_SYMVALUE and DBG$STA_VALSPEC.
!
LITERAL
	DBG$K_VAL_NOVALUE	= 0,	! Symbol has no value
	DBG$K_VAL_LITERAL	= 1,	! Value is a literal
	DBG$K_VAL_ADDR		= 2,	! Value is an address
	DBG$K_VAL_DESCR		= 3;	! Value is a descriptor pointer


!**-

!	UTILITY MACROS
!
!
!
!	This section defines various macros of general utility throughout the
!	Debugger.
!
MACRO RETURN_ERROR(message_vector,error_code) =
			BEGIN
%IF %LENGTH LSS 2
%THEN
			%WARN('Too few parameters to RETURN_ERROR')
%ELSE
    %IF %LENGTH EQL 2
    %THEN
			message_vector = dbg$nmake_arg_vect(error_code);
    %ELSE
			message_vector = dbg$nmake_arg_vect(error_code,
							    %LENGTH - 2,
							    %REMAINING);
    %FI
			RETURN sts$k_severe
%FI
			END
%;

MACRO REPORT_BUG(msg_vect,bug_id)=RETURN_ERROR(msg_vect,dbg$_debugbug,bug_id)%;

!		A D D R E S S   D E S C R I P T O R S
!
!
!
!	The Address Descriptor is used to define an address where a bit offset
!	is needed in addition to a byte address.
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------------------------------------------------------+
!   0	|                    DBG$L_ADDRESS_BYTE_ADDR			|
!	+---------------------------------------------------------------+
!   1	|                    DBG$L_ADDRESS_BIT_OFFSET                   |
!	+---------------------------------------------------------------+
!
!
!	A pointer to an Address Descriptor is declared as follows:
!
!			ADDPTR: REF DBG$ADDRESS_DESC;
!
!
! Define the fields in the Address Descriptor.  Also define the declaration
! macro.
!**+
FIELD DBG$ADDRESS_DESC_FIELDS =
	SET
	DBG$L_ADDRESS_BYTE_ADDR	 = [ 0, L_ ],	! Byte address
	DBG$L_ADDRESS_BIT_OFFSET = [ 1, L_ ]    ! Bit offset
	TES;

LITERAL
	DBG$K_ADDRESS_DESC_SIZE	= 2;	      ! Size of descriptor in longwords

MACRO
	DBG$ADDRESS_DESC = BLOCK[DBG$K_ADDRESS_DESC_SIZE]
		  	   FIELD(DBG$ADDRESS_DESC_FIELDS) %;
!**-

!		A D D R E S S   E X P R E S S I O N   D E S C R I P T O R S
!
!
!
!	The Address Expression Descriptor is used to define an address expres-
!	sion.  It has the following structure:
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+-----------------------------------------------+---------------+
!   0	|                    Unused                     |DBG$B_AED_TYPE |
!	+-----------------------------------------------+---------------+
!   1	|                        DBG$L_AED_VALUE                        |
!	+---------------------------------------------------------------+
!
!
!
!	A pointer to an Address Expression Descriptor is declared as follows:
!
!				AEDPTR: REF DBG$AED
!
!
! Define the fields in the Address Expression Descriptor.  Also define the
! declaration macro.
!
FIELD DBG$AED_FIELDS =
	SET
	DBG$B_AED_TYPE	= [ 0, B0_ ],	! The type of the value field
	DBG$L_AED_VALUE	= [ 1, L_ ]	! L-value or pointer to descriptor
	TES;

LITERAL
	DBG$K_AED_SIZE	= 2;		! Size of descriptor in longwords

MACRO
	DBG$AED = BLOCK[DBG$K_AED_SIZE] FIELD(DBG$AED_FIELDS) %;


! The following are the legal values for the DBG$B_AED_TYPE field.
!
! DBG$K_PRIMARY_DESC			! The value field contains the address
!					!      of a primary descriptor
! DBG$K_PERM_DESC			! The value field contains the address
!					!      of a permanent symbol descriptor
! DBG$K_INSTRUCTION			! The value field contains a PC value
! DBG$K_NOTYPE				! The value field contains an untyped
!					!      L-value

!			E R R O R   S T A T U S   C O D E S
!
!
!
!	Debugger status codes are defined in the MDL file DBGMES.MDL--new ones
!	should therefore be entered in that file.  All that is found here are
!	definitions relating to components of status codes.
!
!
! Define the possible values of the status severity field.
!
LITERAL
	SYS$K_INFO	= 3;		! Informational status severity

!		F R E E   M E M O R Y   M A N A G E M E N T
!
!
!
!	The Free Memory Manager manages the Debugger's free memory pool.  Its
!	routines are thus called throughout the Debugger to allocate and de-
!	allocate memory blocks used for RST entries, Static Address Table en-
!	tries, and numerous other kinds of descriptors and records.  The Free
!	Memory Manager has two kinds of blocks in its memory pool: free blocks
!	and allocated blocks.  The formats of both kinds of blocks and the over-
!	all structure of the memory pool is illustrated below.
!
!
!
!	FORMAT OF A FREE MEMORY BLOCK
!
!
!
!	The format of a free memory block is shown here:
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------+-+-+-------------------------------------------+
!   0	|     SENT      |P|T|               FMEM$V_LENGTH               |
!	+---------------+-+-+-------------------------------------------+
!   1	|                         FMEM$L_FLINK                          |
!	+---------------------------------------------------------------+
!   2	|                         FMEM$L_BLINK                          |
!	+---------------------------------------------------------------+
!   3	|                                                               |
!	|                                                               |
!  ..	|                                                               |
!	|                            Unused                             |
!  ..	|                                                               |
!	|                                                               |
!  ..	|                                                               |
!	+---------------------------------------------------------------+
!  ..	|                        FMEM$L_PREVLEN                         |
!	+---------------------------------------------------------------+
!
!
!
!	Here SENT represents FMEM$B_SENTINEL, P is FMEM$V_PREVALLOC, and T is
!	FMEM$V_THISALLOC as defined on the next page.
!
!	A free block has its length (in longwords) stored both at the beginning
!	of the block (FMEM$V_LENGTH) and at the end (FMEM$L_PREVLEN).  The mini-
!	mum length of a free block is four longwords.  Free blocks are chained
!	together on a doubly linked free-list.  This list has a list head which
!	is never allocated--the list is thus never empty.  The address of the
!	free-list list head is always stored in the OWN variable DBG$FREE_LIST.

!	FORMAT OF AN ALLOCATED MEMORY BLOCK
!
!
!
!	The format of an allocated block is as follows:
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------+-+-+-------------------------------------------+
!   0	|     SENT      |P|T|               FMEM$V_LENGTH               |
!	+---------------+-+-+-------------------------------------------+
!   1	|                        FMEM$A_ALLOCBLK                        |
!	|                                                               |
!  ..	|                                                               |
!	|                                                               |
!  ..	|                     Allocated Memory Area                     |
!	|                                                               |
!  ..	|                                                               |
!	|                                                               |
!  ..	|                                                               |
!	+---------------------------------------------------------------+
!
!
!
!	Here SENT represents FMEM$B_SENTINEL, P is FMEM$V_PREVALLOC, and T is
!	FMEM$V_THISALLOC as defined below.  In an allocated block, the address
!	returned to the requestor is represented by FMEM$A_ALLOCBLK.
!
!	A pointer to a memory block (free or allocated) is declared as follows:
!
!				BLKPTR: REF FMEM$BLOCK
!
!	This declaration is used in the Free Memory Manager only.
!
!
!
! Define the fields in the two kinds of memory blocks.
!
FIELD FMEM$FLD_DEF =
	SET
	FMEM$V_LENGTH	= [ 0, V_(0,22) ],! The length of the block in longwords
	FMEM$V_THISALLOC= [ 0, V_(22) ],! Set to TRUE if this block is allocated
	FMEM$V_PREVALLOC= [ 0, V_(23) ],! Set to TRUE if the previous block is
					!      allocated (block at smaller addr)
	FMEM$B_SENTINEL	= [ 0, B3_ ],	! Sentinel value--always FMEM$K_SENTINEL
	FMEM$L_FLINK	= [ 1, L_ ],	! Forward link on free list
	FMEM$L_BLINK	= [ 2, L_ ],	! Backward link on free list
	FMEM$L_PREVLEN	= [ -1, L_ ],	! Length of this free block relative to
					!      the start of the next block
	FMEM$A_ALLOCBLK	= [ 1, A_ ],	! Address returned to caller requesting
					!      a new memory block
	FMEM$A_HEADER	= [ -1, A_ ]	! Address of block's header relative to
					!      the FMEM$A_ALLOCBLK location
	TES;


! Declare the sentinel value and the declaration macro.
!
LITERAL
	FMEM$K_SENTINEL	= %X'B2';	! Magic sentinel value--used for error
					!      checking only

MACRO
	FMEM$BLOCK = BLOCK[] FIELD(FMEM$FLD_DEF) %;

!	OVERALL STRUCTURE OF MEMORY POOL
!
!
!
!	The memory pool consists of one or more memory pool areas.  The first
!	such area is initialized to have the format shown here:
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------------------------------------------------------+
!   0	|             Forward link to next memory pool area             |
!	+---------------------------------------------------------------+
!   1	|            Size in bytes of this memory pool area             |
!	+---------------+-+-+-------------------------------------------+
!   2	|     SENT      |1|0|                     4                     |
!	+---------------+-+-+-------------------------------------------+
!   3	|                         FMEM$L_FLINK                          |
!	+---------------------------------------------------------------+
!   4	|                         FMEM$L_BLINK                          |
!	+---------------------------------------------------------------+
!   5	|                               4                               |
!	+---------------+-+-+-------------------------------------------+
!   6	|     SENT      |1|0|               FMEM$V_LENGTH               |
!	+---------------+-+-+-------------------------------------------+
!   7	|                         FMEM$L_FLINK                          |
!	+---------------------------------------------------------------+
!   8	|                         FMEM$L_BLINK                          |
!	+---------------------------------------------------------------+
!   9	|                                                               |
!	|                                                               |
!  ..	|                                                               |
!	|                                                               |
!  ..	|                                                               |
!	|             Free memory available for allocation              |
!  ..	|                                                               |
!	|                                                               |
!  ..	|                                                               |
!	|                                                               |
!  ..	|                                                               |
!	+---------------------------------------------------------------+
!  ..	|                        FMEM$L_PREVLEN                         |
!	+---------------+-+-+-------------------------------------------+
!  ..	|     SENT      |0|1|                     1                     |
!	+---------------+-+-+-------------------------------------------+
!
!
!
!	Here longword 0 contains a pointer to the next memory pool area (for
!	this initial area the pointer is always zero) and longword 1 contains
!	the size of this area in bytes.  These two fields are present for in-
!	ternal error checking purposes only.
!
!	Longwords 2 - 5 contain the free-list list head.  This is a free block
!	which is always at the start of the doubly linked free list and which
!	is never coalesced with any other free block--the code thus never has
!	to worry about a completely empty free list.  The very last longword
!	in the memory pool area is the header of an allocated block.  It pre-
!	vents any attempt to coalesce free blocks off the end of the area.
!	The rest of the area (longword 6 to the next to last longword) is ini-
!	tially one big free block from which allocation can take place.  Note
!	how the P and T flags (FMEM$V_PREVALLOC and FMEM$V_THISALLOC) are set to
!	prevent free block coalescing off either end of the memory pool area.
!
!	Additional memory pool areas may be acquired from LIB$GET_VM during the
!	Debugger's initialization phase.  Each such area is initialized to have
!	the same format as the first one except that the free-list list head is
!	absent--only one is needed for the whole memory pool.  The initial for-
!	mat of each additional memory pool area is illustrated here:
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------------------------------------------------------+
!   0	|             Forward link to next memory pool area             |
!	+---------------------------------------------------------------+
!   1	|            Size in bytes of this memory pool area             |
!	+---------------+-+-+-------------------------------------------+
!   2	|     SENT      |1|0|               FMEM$V_LENGTH               |
!	+---------------+-+-+-------------------------------------------+
!   3	|                         FMEM$L_FLINK                          |
!	+---------------------------------------------------------------+
!   4	|                         FMEM$L_BLINK                          |
!	+---------------------------------------------------------------+
!   5	|                                                               |
!	|                                                               |
!  ..	|                                                               |
!	|                                                               |
!  ..	|                                                               |
!	|             Free memory available for allocation              |
!  ..	|                                                               |
!	|                                                               |
!  ..	|                                                               |
!	|                                                               |
!  ..	|                                                               |
!	+---------------------------------------------------------------+
!  ..	|                        FMEM$L_PREVLEN                         |
!	+---------------+-+-+-------------------------------------------+
!  ..	|     SENT      |0|1|                     1                     |
!	+---------------+-+-+-------------------------------------------+

!	TEMPORARY MEMORY BLOCKS
!
!
!
!	"Temporary" memory blocks are blocks which automatically are released
!	at the end of the current command.  Such blocks are allocated by a
!	special allocation routine (DBG$GET_TEMPMEM), but they do not have to
!	be explicitly released to the memory pool.  Instead one routine is
!	called (DBG$REL_TEMPMEM) which automatically releases all "temporary"
!	blocks accumulated since the last such call.  Temporary blocks have
!	the following format:
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------+-+-+-------------------------------------------+
!   0	|     SENT      |P|1|               FMEM$V_LENGTH               |
!	+---------------+-+-+-------------------------------------------+
!   1	|          Forward link to next temporary memory block          |
!	+---------------+-+-+-------------------------------------------+
!   2	|   TEMPSENT    |1|1|               FMEM$V_LENGTH               |
!	+---------------+-+-+-------------------------------------------+
!   3	|                        FMEM$A_ALLOCBLK                        |
!	|                                                               |
!  ..	|                                                               |
!	|                                                               |
!  ..	|                     Allocated Memory Area                     |
!	|                                                               |
!  ..	|                                                               |
!	|                                                               |
!  ..	|                                                               |
!	+---------------------------------------------------------------+
!
!
!
!	Longword 0 is the same as for any other memory pool block.  Longword 1
!	contains a forward link to the next block on the temporary block list.
!	Longword 2 is similar to longword 0, but the length there is two less
!	and the sentinel value is a different sentinel value (FMEM$K_TEMPSENT).
!
!
! Define the distinguishing sentinel value for "temporary" memory blocks.
!
LITERAL
	FMEM$K_TEMPSENT	= %X'B4';	! Sentinel value in longword 2

!		I M A G E   F I L E   H E A D E R   D E F I N I T I O N S
!
!
!
!	The executable image file header block contains a pointer in a fixed
!	location which points to a small block later in the header which gives
!	the size and location of the Debug Symbol Table (DST) and the Global
!	Symbol Table (GST).  The first part of the executable image file header
!	looks as follows:
!
!	
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------------------------------------------------------+
!   0	|                                                               |
!	+-------------------------------+-------------------------------+
!   1	|                               |        IHD$W_SYMDBGOFF        |
!	+-------------------------------+-------------------------------+
!   2	|                                                               |
!	|                                                               |
!  ..	|                                                               |
!	+---------------------------------------------------------------+
!
!
!
!	Here IHD$W_SYMDBGOFF contains the byte offset relative to the start of
!	the header of an image header symbol table descriptor of the following
!	format:
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------------------------------------------------------+
!   0	|                         IHS$L_DSTVBN                          |
!	+---------------------------------------------------------------+
!   1	|                         IHS$L_GSTVBN                          |
!	+-------------------------------+-------------------------------+
!   2	|         IHS$W_GSTRECS         |         IHS$W_DSTBLKS         |
!	+-------------------------------+-------------------------------+
!
!
!
!	Here IHS$W_DSTBLKS and IHS$L_DSTVBN give the size (in blocks) and loca-
!	tion (Virtual Block Number) of the Debug Symbol Table (DST) within the
!	executable image file.  The fields IHS$W_GSTRECS and IHS$L_GSTVBN give
!	the size (in GST records) and start location (Virtual Block Number) of
!	the Global Symbol Table (GST). The field names are declared by macros
!	in SYS$LIBRARY:LIB.L32.
!
!	The symbol IHD$W_SYMDBGOFF is defined in SYS$LIBRARY:LIB.L32 and is
!	therefore not defined here.  A pointer to the image file header is
!	declared as follows:
!
!			IHDPTR: REF BLOCK[,BYTE]
!
!	A pointer to the image header symbol descriptor is declared like this:
!
!			IHSPTR: REF IHS$ENTRY
!
! 	Define the IHSPTR macro
!
MACRO
	IHS$ENTRY = BLOCK[IHS$K_LENGTH,BYTE] %;		! IHS$K_LENGTH is defined
							! in SYS$LIBRARY:LIB.L32


!	L E A S T   R E C E N T L Y   U S E D   M O D U L E   T A B L E
!
!
!
!	The Least Recently Used Module (LRUM) table keeps track of the Least
!	Recently Used module in the RST.  This information is used to select
!	modules to be removed from the RST when the free memory pool is full
!	and new space must be created by releasing old RST entries.  The LRUM
!	table is built and maintained by the DBG$MOST_RECENT_MODULE routine in
!	module RSTACCESS and is accessed by routine DBG$GET_MEMORY when memory
!	space must be released by removing the Least Recently Used module.
!	Routine DBG$RST_INIT builds the initial LRUM list head.
!
!	The LRUM table consists of a doubly linked list of LRUM entries, with
!	a permanent list head and one entry per module currently in the RST.
!	The address of the list head is given by the global LRUM$LISTHEAD.
!	The format of the individual LRUM entry is show here:
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------------------------------------------------------+
!   0	|                         LRUM$L_FLINK                          |
!	+---------------------------------------------------------------+
!   1	|                         LRUM$L_BLINK                          |
!	+---------------------------------------------------------------+
!   2	|                         LRUM$L_RSTPTR                         |
!	+---------------------------------------------------------------+
!
!
!
!	A pointer to a Least Recently Used Module entry is declared as follows:
!
!			LRUMPTR: REF LRUM$ENTRY
!
!
!
! Define the fields in the Least Recently Used Module entry.  Also define the
! entry size and the declaration macro.
!
FIELD LRUM$FLD_DEF =
	SET
	LRUM$L_FLINK	= [ 0, L_ ],	! The LRUM chain forward link
	LRUM$L_BLINK	= [ 1, L_ ],	! The LRUM chain backward link
	LRUM$L_RSTPTR	= [ 2, L_ ]	! A pointer to the Module RST Entry
	TES;

LITERAL
	LRUM$ENTSIZE	= 3;		! The longword size of the LRUM entry

MACRO
	LRUM$ENTRY = BLOCK[] FIELD(LRUM$FLD_DEF) %;	! Declaration macro

!		L I N K E D   L I S T   N O D E
!
!
!
!	Linked lists using this definition are generated by language specific
!	routines to indicate:
!	
!	1. The pages on which a symbol's r value is contained. 
!			( dbg$nxxx_get_pages )
!
!	2. Primary descriptors which represent a range specification.
!			( dbg$nxxx_range_val )
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------------------------------------------------------+
!   0	|		      DBG$L_LINK_NODE_LINK			|
!	+---------------------------------------------------------------+
!   1   |		      DBG$L_LINK_NODE_VALUE			|
!	+---------------------------------------------------------------+
!
!
!
!	A pointer to a Link Node is declared as follows:
!
!			LINKNODE: REF DBG$LINK_NODE
!
!**+
!
! Define the Link Node fields and declaration macro.
!
FIELD DBG$LINK_NODE_FIELDS =
	SET
	DBG$L_LINK_NODE_LINK	= [ 0, L_ ],	! Pointer to next node
	DBG$L_LINK_NODE_VALUE	= [ 1, L_ ]	! Node value field
	TES;

LITERAL
	DBG$K_LINK_NODE_SIZE = 2;		! Size of link node in
						! longwords

MACRO
	DBG$LINK_NODE = BLOCK [DBG$K_LINK_NODE_SIZE] 
	FIELD (DBG$LINK_NODE_FIELDS)  %;
!**-

!		P A T H N A M E   D E S C R I P T O R S
!
!
!
!	The pathname descriptor is used internally in the Debugger to represent
!	a pathname, including data qualification.  Thus "MOD\ROUT\X" is a path-
!	name in this sense, and so is "MOD\ROUT\A.B.C".  The format of a path-
!	name descriptor is shown here:
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------+---------------+---------------+---------------+
!   0	|    Unused     |PTH$B_LOCINVOC | PTH$B_PATHCNT | PTH$B_TOTCNT  |
!	+---------------+---------------+---------------+---------------+
!   1	|                        PTH$L_INVOCNUM                         |
!	+---------------------------------------------------------------+
!   2	|                       PTH$A_PATHVECTOR                        |
!	|                                                               |
!  ..	|                                                               |
!	|               Pointers to Counted ASCII Strings               |
!  ..	|                                                               |
!	|                      (one per longword)                       |
!  ..	|                                                               |
!	|                                                               |
!  ..	|                                                               |
!	|                                                               |
!  ..	|                                                               |
!	+---------------------------------------------------------------+
!
!
!
!	The Pathname Descriptor contains two counts fields which give the total
!	number of names in the pathname (five for M\R\A.B.C) and the total num-
!	ber of names before the first dot (three for M\R\A.B.C).  It also con-
!	tains an invocation number (which is zero if none was explicitly speci-
!	fied) and an index into PTH$A_PATHVECTOR which indicates which pathname
!	component was qualified by the invocation number (1 for A 2\X and 4 for
!	M\R1\R2\R3 5\X).  This index is zero if no invocation number was given.
!	The rest of the descriptor consists of longwords containing pointers to
!	the individual names in the pathname, each represented by a Counted
!	ASCII String.
!
!	A pointer to a Pathname Descriptor is declared as follows:
!
!			PATHPTR: REF PTH$PATHNAME
!
!
!**+
!
! Define the Pathname Descriptor fields.
!
FIELD PTH$FLD_DEF =
	SET
	PTH$B_TOTCNT	= [ 0, B0_ ],	! Total number of names in pathname
					!      including all data qualification
	PTH$B_PATHCNT	= [ 0, B1_ ],	! Number of names in pathname proper
					!      before any data qualification
	PTH$B_LOCINVOC	= [ 0, B2_ ],	! The location in the vector below of
					!      the name with an invocation num-
					!      ber (first name is 1) or zero
	! ---		= [ 0, B3_ ],	! Unused
	PTH$L_INVOCNUM	= [ 1, L_ ],	! The invocation number or zero
	PTH$A_PATHVECTOR= [ 2, A_ ]	! The start of the pathname vector--has
					!      one name pointer (pointing to a
					!      Counted ASCII name) per longword.
	TES;


! Define the maximum allowed size of a pathname, i.e. the maximum number of
! individual names, including data components.  Also define the size of the
! fixed part of the descriptor and the declaration macro.
!
LITERAL
	DBG$K_MAX_PATHNAME = 50,	! Maximum size of a pathname
	DBG$K_PATHDESCSIZE = 2,		! Size of fixed part of Pathname
					!      Descriptor
	DBG$K_PATHNAME_SIZE = DBG$K_MAX_PATHNAME + DBG$K_PATHDESCSIZE;

MACRO
	PTH$PATHNAME = BLOCK[DBG$K_PATHNAME_SIZE] FIELD(PTH$FLD_DEF) %;
!**-

!		P E R M A N E N T   S Y M B O L   D E S C R I P T O R S
!
!
!
!	The Permanent Symbol Descriptor is used to describe Debugger "permanent
!	symbols" in Value Descriptors, Primary Descriptors, and address expres-
!	sions.  Permanent symbols name the VAX registers; "R0" is thus a perma-
!	nent symbol.  A Permanent Symbol Descriptor has this format:
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+-----------------------------------------------+---------------+
!   0	|                    Unused                     |DBG$B_PERMSD_ID|
!	+-----------------------------------------------+---------------+
!   1	|                       DBG$L_PERMSD_ADDR                       |
!	+---------------------------------------------------------------+
!   2	|                       DBG$L_PERMSD_PATH                       |
!	+---------------------------------------------------------------+
!
!
!
! 	A pointer to a Permanent Symbol Descriptor is declared as follows:
!
!			PSDPTR: REF DBG$PERMSD
!
!**+
!
! Define the Permanent Symbol Descriptor fields and declaration macro.
!
FIELD DBG$PERMSD_FIELDS =
	SET
	DBG$B_PERMSD_ID   = [ 0, B0_ ],	! Symbol ID (register number)
	DBG$L_PERMSD_ADDR = [ 1, L_ ],	! Address of the register contents
	DBG$L_PERMSD_PATH = [ 2, L_ ]	! Address of symbol's pathname descr.
	TES;

LITERAL
	DBG$K_PERMSD_SIZE = 3;		! Size of Permanent Symbol Descriptor
					!      in longwords

MACRO
	DBG$PERMSD = BLOCK[DBG$K_PERMSD_SIZE] FIELD(DBG$PERMSD_FIELDS) %;


! These are the possible values of the DBG$B_PERMSD_ID field.
!
LITERAL
	DBG$K_R0	= 200,		! Register R0
	DBG$K_R1	= 201,		! Register R1
	DBG$K_R2	= 202,		! Register R2
	DBG$K_R3	= 203,		! Register R3
	DBG$K_R4	= 204,		! Register R4
	DBG$K_R5	= 205,		! Register R5
	DBG$K_R6	= 206,		! Register R6
	DBG$K_R7	= 207,		! Register R7
	DBG$K_R8	= 208,		! Register R8
	DBG$K_R9	= 209,		! Register R9
	DBG$K_R10	= 210,		! Register R10
	DBG$K_R11	= 211,		! Register R11
	DBG$K_AP	= 212,		! Argument Pointer (AP)
	DBG$K_FP	= 213,		! Frame Pointer (FP)
	DBG$K_SP	= 214,		! Stack Pointer (SP)
	DBG$K_PC	= 215,		! Program Counter (PC)
	DBG$K_PSL	= 216;		! Processor Status Longword (PSL)
!**-

!	    R U N - T I M E   S Y M B O L   T A B L E   D E F I N I T I O N S
!
!
!
!	This section contains all definitions related to the structure and con-
!	tents of the Run-Time Symbol Table (RST) through which the Debugger
!	accesses the Debug Symbol Table (DST) in the user's executable image.
!	The RST itself is built and accessed entirely through the Symbol-Table
!	Access Routines in modules RSTCNTRL and RSTACCESS.
!
!	The RST is the structure through which the DST is accessed, one module
!	at a time.  This means that for each "active" module in the user's
!	program, there is an RST data structure which describes that module
!	and all lexical entities and data items in it.  This structure, which
!	is scattered through the Debugger's free memory, contains one entry for
!	each lexical entity and data item in the module's DST.  Each RST entry
!	contains a pointer to the corresponding DST entry so all the DST entry
!	information can be accessed rapidly.  In addition, the RST itself is
!	hashed by symbol name so that a symbol's RST and DST entries can be loc-
!	ated rapidly given the symbol name.
!
!<<---------------------- DESCRIBE MORE OF STRUCTURE --------------------------

!	RST ENTRY COMMON CORE
!
!
!
!	All entries in the Run-Time Symbol Table have the same information in
!	their first parts.  This RST entry "common core" is described here:
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------------------------------------------------------+
!   0	|                       RST$L_HASH_FLINK                        |
!	+---------------------------------------------------------------+
!   1	|                       RST$L_HASH_BLINK                        |
!	+---------------------------------------------------------------+
!   2	|                        RST$L_SYMCHNPTR                        |
!	+---------------------------------------------------------------+
!   3	|                         RST$L_DSTPTR                          |
!	+---------------------------------------------------------------+
!   4	|                       RST$L_UPSCOPEPTR                        |
!	+-------------------------------+---------------+---------------+
!   5	|        RST$W_REFCOUNT         |   Flag bits   |  RST$B_KIND   |
!	+-------------------------------+---------------+---------------+
!
!
!
!	The hash chain forward and backward links link together all RST entries
!	for symbols whose names have the same hash value.  The hash chain is
!	doubly linked so that RST entries can be removed from the hash chains
!	when the whole RST for a module is removed to free up its space.  Each
!	hash chain has a permanent list head; RST entries in the RST Hash Table
!	therefore never have zero hash links.
!
!	Some RST entries are not in the RST Hash Table, however.  Such entries
!	are "temporary" in the sense that they are created when needed and are
!	thrown away when no longer referenced.  Examples include many Data Type
!	RST Entries and RST entries with invocation numbers.  Such RST entries
!	are put on the Temporary RST Entry List.  This is a singly linked list
!	which uses the RST$L_HASH_FLINK field for the links; RST$L_HASH_BLINK
!	is left zero in this case.
!
!	All RST entries for a given module are linked together through the
!	RST$L_SYMCHNPTR pointer in a singly linked list.  The list starts at the
!	Module RST Entry and is terminated by a zero forward link.  This list is
!	traversed when the Module's whole RST is released to make room for an-
!	other module.
!
!	The RST$L_DSTPTR pointer gives the address of the symbol's DST entry.
!	The RST$L_UPSCOPEPTR pointer generally points to the RST entry of the
!	symbol's "containing" entity.  This usually means the containing lexical
!	entity, but for data record components it means the containing record.
!
!	The RST$B_KIND field identifies what kind of symbol and what kind of RST
!	entry this is.  The possible values are listed at the end of this sec-
!	tion.  The RST$W_REFCOUNT field contains a reference count which speci-
!	fies how many references (pointers) to this RST entry have been passed
!	to the rest of the Debugger.  When this count is non-zero, this RST en-
!	try cannot be released to free storage.  The reference count is thus
!	used to prevent a "dangling pointer" problem.
!
!	A pointer to a Run-Time Symbol Table Entry is declared as follows:
!
!			RSTPTR: REF RST$ENTRY
!
!
! This declaration macro collects together all the individual FIELD sets
! declared below for the various kinds of RST entries.
!
MACRO
	RST$ENTRY = BLOCK[] FIELD(RST$FLD_CORE,RST$FLD_MOD,RST$FLD_LEX,RST$FLD_DATA) %;


! These are the RST entry common core field definitions.
!
FIELD RST$FLD_CORE =
	SET
	RST$L_HASH_FLINK = [ 0, L_ ],	! Symbol name hash chain forward link
	RST$L_HASH_BLINK = [ 1, L_ ],	! Symbol name hash chain backward link
	RST$L_SYMCHNPTR  = [ 2, L_ ],	! Pointer to the next RST entry belong-
					!      to the same module as this one
	RST$L_DSTPTR     = [ 3, L_ ],	! Pointer to this symbol's DST entry
	RST$L_UPSCOPEPTR = [ 4, L_ ],	! Pointer to the RST entry one level up
					!      in scope from this one
	RST$B_KIND       = [ 5, B0_ ],	! The kind of RST entry this is
	RST$V_GLOBAL	 = [ 5, V1_(0)],! Flag set if this is a global symbol
	RST$V_NONZLENGTH = [ 5, V1_(1)],! Flag set to TRUE if this symbol has a
					!      non-zero length
	RST$V_INVOCNUM	 = [ 5, V1_(2)],! Flag set if symbol has invocation num.
	RST$V_SET_TYPEPTR= [ 5, V1_(3)],! Flag set to indicate that the Data RST
					!      Entry RST$L_TYPEPTR field should
					!      be set during RST build.
	RST$V_MARKBIT	 = [ 5, V1_(4)],! Mark bit available for temporary use
					!      (such as stopping recursion)
	RST$V_COBOLGBL	 = [ 5, V1_(5)],! Flag bit set to indicate this symbol
					!      has the COBOL "global" attribute
	RST$W_REFCOUNT   = [ 5, W1_ ]	! Reference count for storage management
	TES;


!**+
!
! The following are the possible values for the RST$B_KIND field.  This field
! specifies what kind of RST entry this is; it thus indicates both what kind of
! symbol the RST entry represents and what the format of the RST entry is after
! the "common core" part.
!
LITERAL
	RST$K_INVALID	= 0,		! Invalid code--cannot occur in RST en-
					!      try but can be returned by some
					!      Symbol Table Access routines
	RST$K_NOTUNIQUE	= 9,		! Symbol not unique--cannot occur in RST
					!      entry but can be returned by the
					!      DBG$STA_GETSYMBOL routine.
	RST$K_MODULE	= 1,		! Module RST entry
	RST$K_ROUTINE	= 2,		! Routine RST entry
	RST$K_BLOCK	= 3,		! Block RST entry
	RST$K_ENTRY	= 8,		! Entry Point RST entry
	RST$K_LABEL	= 4,		! Label RST entry
	RST$K_LINE	= 5,		! Line number RST entry
	RST$K_DATA	= 6,		! Data item RST entry
	RST$K_TYPCOMP	= 10,		! Type component RST entry
	RST$K_TYPE	= 7,		! Data type RST entry
	RST$K_VARIANT	= 11,		! Record variant set RST entry
	RST$K_INVOCNUM	= 12,		! Invocation number RST Entry
	RST$K_KIND_MINIMUM = RST$K_INVALID,	! Minimum possible kind value
	RST$K_KIND_MAXIMUM = RST$K_INVOCNUM;	! Maximum possible kind value
!**-

!	RST ENTRY FOR A MODULE
!
!
!
!	A module is represented by a Module RST Entry at all times, whether the
!	rest of the module is in the RST or not.  This Module Entry then points
!	to a linked list of RST entries for the remaining symbols in the module
!	via the RST$L_SYMCHNPTR pointer; the end of this list is indicated by a
!	zero pointer.  The RST$L_UPSCOPEPTR pointer is not used as an up-scope
!	pointer in a Module Entry--there is nothing up-scope from a module.  In-
!	stead RST$L_NXTMODPTR, which occupies the same location in the RST entry
!	as RST$L_UPSCOPEPTR, is used to link all Module RST Entries in the whole
!	program into a singly linked list.  This list is scanned during RST ini-
!	tialization and when processing the SHOW MODULES command.
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------------------------------------------------------+
!   0	|                       RST$L_HASH_FLINK                        |
!	+---------------------------------------------------------------+
!   1	|                       RST$L_HASH_BLINK                        |
!	+---------------------------------------------------------------+
!   2	|                        RST$L_SYMCHNPTR                        |
!	+---------------------------------------------------------------+
!   3	|                         RST$L_DSTPTR                          |
!	+---------------------------------------------------------------+
!   4	|                       RST$L_NXTMODPTR                         |
!	+-------------------------------+---------------+---------------+
!   5	|        RST$W_REFCOUNT         |   Flag bits   |  RST$B_KIND   |
!	+-------------------------------+---------------+---------------+
!   6	|                         RST$L_SAT_PTR                         |
!	+---------------------------------------------------------------+
!   7	|                       RST$L_PCTBL_BASE                        |
!	+---------------------------------------------------------------+
!   8	|                        RST$L_MODRSTSIZ                        |
!	+---------------------------------------------------------------+
!   9	|                        RST$L_MODSRCTBL                        |
!	+-------------------------------+---------------+---------------+
!  10	|        RST$W_NUMPCTBLS        |RST$B_LANGUAGE |   Flag bits   |
!	+-------------------------------+---------------+---------------+
!  11	|                        RST$A_MODPCTBL                         |
!	|                                                               |
!  ..	|       Pointers to DST PC-Correlation Tables for module        |
!	|                                                               |
!  ..	|                                                               |
!	+---------------------------------------------------------------+
!  ..	|   Number of Source Line Correlation DST Records for module    |
!	+---------------------------------------------------------------+
!  ..	|                                                               |
!	|   Pointers to module's Source Line Correlation DST Records    |
!  ..	|                                                               |
!	+---------------------------------------------------------------+
!
!
!
!	Each PC Correlation Table Pointer points to a PC Correlation Table in
!	the DST.  These pointers are stored in consecutive longwords, with one
!	pointer for each PC Correlation Table in the DST for this module.  These
!	tables need not have any special order or nesting with respect to the
!	DST records for routines and lexical blocks, and are therefore viewed as
!	belonging to the module as a whole.  The PC Correlation Tables for a
!	module are scanned by searching them in the order of their pointers in
!	the Module RST Entry.  The addresses given by the PC Correlation Tables
!	are relative to the address given by RST$L_PCTBL_BASE, which contains
!	the address of the lowest address routine in the module.
!
!	The RST$L_MODSRCTBL field points to a table of pointers to the Source
!	Line Correlation DST Records for this module.  The first cell of this
!	table (i.e., MODSRCTBL[0]) contains the number of Source Line Correla-
!	tion DST Records in this module's DST and the remaining cells (i.e.,
!	MODSCRTBL[1] through MODSRCTBL[.MODSRCTBL[0]]) contain pointers to those
!	DST records.  Each cell in the table is a longword.  If there are no
!	such DST records at all, the RST$L_MODSRCTBL field is zero.  The table
!	itself (if present at all) is at the end of the Module RST Entry.
!
!
!
! This set of field declarations includes all fields outside the RST common core
! used in the Module RST Entry.
!
FIELD RST$FLD_MOD =
	SET
	RST$L_NXTMODPTR = [ 4, L_ ],	! Pointer to the next Module RST Entry
	RST$L_SAT_PTR	= [ 6, L_ ],	! Pointer to this module's Static
					!      Address Table (SAT)
	RST$L_PCTBL_BASE= [ 7, L_ ],	! The base address for the offsets given
					!      by the PC Correlation Tables
	RST$L_MODRSTSIZ = [ 8, L_ ],	! The total size in bytes of the RST
					!      for this module--used only by the
					!      SHOW MODULE command.
	RST$L_MODSRCTBL	= [ 9, L_ ],	! Pointer to table of pointers to the
					!      module's Source Line Correlation
					!      DST Records (or zero)
	RST$V_MODSET	= [ 10, V_(0) ],! Flag indicating this module is SET
	RST$V_MOD_IN_RST= [ 10, V_(1) ],! Flag indicating module is in the RST
	RST$V_ANONMOD	= [ 10, V_(2) ],! Flag indicating this is the "anonymous
					!      module" containing all unclaimed
					!      global symbols.
	RST$B_LANGUAGE	= [ 10, B1_ ],	! The language of this module
	RST$W_NUMPCTBLS	= [ 10, W1_ ],	! The number of PC Correlation Table
					!      pointers in the RST$A_MODPCTBL
					!      area below
	RST$A_MODPCTBL	= [ 11, A_ ]	! The start location of the vector of
					!      PC-Correlation Table pointers
					!      in the Module RST Entry.
	TES;


! Define a symbolic name for the size of the fixed portion of the Module RST
! Entry.  The size is expressed in longwords.
!
LITERAL
	RST$K_MODENTSIZ = 11;		! Size of Module RST Entry (fixed part)

!	RST ENTRY FOR A ROUTINE
!
!
!
!	The RST entry for a routine has the format shown here.  Each Routine RST
!	Entry has an up-scope pointer (RST$L_UPSCOPEPTR) which points to the RST
!	entry for the containing lexical entity.  That can be a module, a lexi-
!	cal block, or another routine.  The start and end addresses of the rout-
!	ine's code are also given in the RST entry.  There is also a Static
!	Address Table (SAT) pointer which points to the SAT entry for this rout-
!	ine, and there is a Static Link pointer which points to the routine's
!	Static Link DST record (or is zero).  The Routine RST Entry is always
!	built when the RST for a module is built.
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------------------------------------------------------+
!   0	|                       RST$L_HASH_FLINK                        |
!	+---------------------------------------------------------------+
!   1	|                       RST$L_HASH_BLINK                        |
!	+---------------------------------------------------------------+
!   2	|                        RST$L_SYMCHNPTR                        |
!	+---------------------------------------------------------------+
!   3	|                         RST$L_DSTPTR                          |
!	+---------------------------------------------------------------+
!   4	|                       RST$L_UPSCOPEPTR                        |
!	+-------------------------------+---------------+---------------+
!   5	|        RST$W_REFCOUNT         |   Flag bits   |  RST$B_KIND   |
!	+-------------------------------+---------------+---------------+
!   6	|                        RST$L_STARTADDR                        |
!	+---------------------------------------------------------------+
!   7	|                         RST$L_ENDADDR                         |
!	+---------------------------------------------------------------+
!   8	|                        RST$L_RTNSATPTR                        |
!	+---------------------------------------------------------------+
!   9	|                       RST$L_STATIC_LINK                       |
!	+---------------------------------------------------------------+
!
!
!
! This set of field declarations includes the fields outside the RST common core
! used in the Routine, Lexical Block, Entry Point, Label, and Line Number RST
! Entries.  The individual illustrations show which RST entries use which fields.
!
FIELD RST$FLD_LEX =
	SET
	RST$L_STARTADDR	= [ 6, L_ ],	! Lexical entity start address
	RST$L_ENDADDR	= [ 7, L_ ],	! Lexical entity end address
	RST$L_RTNSATPTR	= [ 8, L_ ],	! Address of Routine's SAT entry
	RST$L_STATIC_LINK = [ 9, L_ ]	! Address of Static Link DST record or 0
	TES;


! Define symbolic names for the lengths of the lexical entity RST entries.
! All lengths are expressed in longwords.
!
LITERAL
	RST$K_ROUTENTSIZ = 10,		! Size of Routine RST Entry
	RST$K_LEXENTSIZ  = 8,		! Size of Lexical Block RST Entry
	RST$K_EPTENTSIZ  = 7,		! Size of Entry Point RST Entry
	RST$K_LBLENTSIZ  = 7,		! Size of Instruction Label RST Entry
	RST$K_LINENTSIZ  = 8;		! Size of Line Number RST Entry

!	RST ENTRY FOR A LEXICAL BLOCK
!
!
!
!	The RST entry for a lexical block has the same format as that for a
!	routine.  Again the up-scope pointer points to the RST entry of the
!	containing lexical entity, and the start and end addresses of the
!	block's code are given.  The Lexical Block RST Entry is always built
!	when the RST for the whole module is built.
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------------------------------------------------------+
!   0	|                       RST$L_HASH_FLINK                        |
!	+---------------------------------------------------------------+
!   1	|                       RST$L_HASH_BLINK                        |
!	+---------------------------------------------------------------+
!   2	|                        RST$L_SYMCHNPTR                        |
!	+---------------------------------------------------------------+
!   3	|                         RST$L_DSTPTR                          |
!	+---------------------------------------------------------------+
!   4	|                       RST$L_UPSCOPEPTR                        |
!	+-------------------------------+---------------+---------------+
!   5	|        RST$W_REFCOUNT         |   Flag bits   |  RST$B_KIND   |
!	+-------------------------------+---------------+---------------+
!   6	|                        RST$L_STARTADDR                        |
!	+---------------------------------------------------------------+
!   7	|                         RST$L_ENDADDR                         |
!	+---------------------------------------------------------------+

!	RST ENTRY FOR AN ENTRY POINT
!
!
!
!	The RST entry for an entry point (i.e., an alternate point through which
!	a routine can be called) is shown here.  The up-scope pointer points to
!	the RST entry of the containing lexical entity.  An entry point has no
!	independent extent and therefore its RST entry has only a start address.
!	The Entry Point RST Entry is always built when the whole module's RST is
!	built.
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------------------------------------------------------+
!   0	|                       RST$L_HASH_FLINK                        |
!	+---------------------------------------------------------------+
!   1	|                       RST$L_HASH_BLINK                        |
!	+---------------------------------------------------------------+
!   2	|                        RST$L_SYMCHNPTR                        |
!	+---------------------------------------------------------------+
!   3	|                         RST$L_DSTPTR                          |
!	+---------------------------------------------------------------+
!   4	|                       RST$L_UPSCOPEPTR                        |
!	+-------------------------------+---------------+---------------+
!   5	|        RST$W_REFCOUNT         |   Flag bits   |  RST$B_KIND   |
!	+-------------------------------+---------------+---------------+
!   6	|                        RST$L_STARTADDR                        |
!	+---------------------------------------------------------------+

!	RST ENTRY FOR AN INSTRUCTION LABEL
!
!
!
!	The RST entry for a label (which labels a point in the user's code) is
!	shown here.  The up-scope pointer points to the RST entry of the con-
!	taining lexical entity.  Since a label does not have extent, there is
!	only a start address in the RST entry; no end address is given.  The
!	Label RST Entry is always built when the whole module's RST is built.
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------------------------------------------------------+
!   0	|                       RST$L_HASH_FLINK                        |
!	+---------------------------------------------------------------+
!   1	|                       RST$L_HASH_BLINK                        |
!	+---------------------------------------------------------------+
!   2	|                        RST$L_SYMCHNPTR                        |
!	+---------------------------------------------------------------+
!   3	|                         RST$L_DSTPTR                          |
!	+---------------------------------------------------------------+
!   4	|                       RST$L_UPSCOPEPTR                        |
!	+-------------------------------+---------------+---------------+
!   5	|        RST$W_REFCOUNT         |   Flag bits   |  RST$B_KIND   |
!	+-------------------------------+---------------+---------------+
!   6	|                        RST$L_STARTADDR                        |
!	+---------------------------------------------------------------+

!	RST ENTRY FOR A LINE NUMBER
!
!
!
!	The RST entry for a line number has the format shown here.  The up-scope
!	pointer points to the RST entry of the containing lexical entity (always
!	a routine or a block).  Both the start and the end address are given.
!	Line Number RST Entries are not built when the whole module's RST is
!	built, however; there are too many lines in a program to make this prac-
!	tical.  Instead each Line Number RST Entry is built when the correspond-
!	ing line number is referenced through the Symbol Table Access routines.
!	A dummy Label DST Record for the Line Number is built in the same memory
!	block as the Line Number RST Entry.  The RST entry points to this DST
!	record and the DST record's name field contains the line number as a
!	counted ASCII string (e.g. "%LINE 25.2").
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------------------------------------------------------+
!   0	|                       RST$L_HASH_FLINK                        |
!	+---------------------------------------------------------------+
!   1	|                       RST$L_HASH_BLINK                        |
!	+---------------------------------------------------------------+
!   2	|                        RST$L_SYMCHNPTR                        |
!	+---------------------------------------------------------------+
!   3	|                         RST$L_DSTPTR                          |
!	+---------------------------------------------------------------+
!   4	|                       RST$L_UPSCOPEPTR                        |
!	+-------------------------------+---------------+---------------+
!   5	|        RST$W_REFCOUNT         |   Flag bits   |  RST$B_KIND   |
!	+-------------------------------+---------------+---------------+
!   6	|                        RST$L_STARTADDR                        |
!	+---------------------------------------------------------------+
!   7	|                         RST$L_ENDADDR                         |
!	+-----------------------------------------------+---------------+

!	RST ENTRY FOR A DATA SYMBOL
!
!
!
!	The RST entry for a data symbol has the format shown here.  The up-scope
!	pointer points to the RST entry for the containing lexical entity (i.e.,
!	module, routine, or lexical block) or, if this is a data component, to
!	the RST entry for the containing data object.  The Data Symbol RST Entry
!	also has a Type Pointer (RST$L_TYPEPTR).  For simple data types (those
!	defined by one-byte type codes or standard descriptors) this pointer is
!	zero, but for more complex data types (records, variants, unions, and
!	enumeration types) this pointer points to the RST entry for that data
!	type.  If the type pointer is zero, the type can be found directly in
!	the data symbol's DST entry.
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------------------------------------------------------+
!   0	|                       RST$L_HASH_FLINK                        |
!	+---------------------------------------------------------------+
!   1	|                       RST$L_HASH_BLINK                        |
!	+---------------------------------------------------------------+
!   2	|                        RST$L_SYMCHNPTR                        |
!	+---------------------------------------------------------------+
!   3	|                         RST$L_DSTPTR                          |
!	+---------------------------------------------------------------+
!   4	|                       RST$L_UPSCOPEPTR                        |
!	+-------------------------------+---------------+---------------+
!   5	|        RST$W_REFCOUNT         |   Flag bits   |  RST$B_KIND   |
!	+-------------------------------+---------------+---------------+
!   6	|                         RST$L_TYPEPTR                         |
!	+---------------------------------------------------------------+
!
!
!
! This set of field declarations includes the fields outside the RST common core
! used in the Data Symbol, Data Type Component, Data Type, Variant Set, and
! Invocation Number RST Entries.  The individual illustrations show which RST
! entries use which fields.
!
FIELD RST$FLD_DATA =
	SET
	RST$L_TYPEPTR	= [ 6, L_ ],	! A pointer to the Data Type RST Entry
					!      which gives the data type of this
					!      data object.  For simple types,
					!      this pointer is zero.
	RST$B_FCODE	= [ 6, B0_ ],	! The "Format Code" of a Data Type RST
					!      Entry--indicates nature of type:
					!      array, atomic, record, etc.
	RST$W_TYPREFCNT	= [ 6, W1_ ],	! The number of Data RST Entries that
					!      reference this Type RST Entry
	RST$L_TYPREFTBL	= [ 7, L_ ],	! Pointer to Type Reference Table
	RST$L_BITSIZE	= [ 8, L_ ],	! The length in bits of data items of
					!      this data type
	RST$L_DST_TYP_REC_PTR =		! A pointer to the DST record containing
			  [ 9, L_ ],	!      the embedded type-spec described
					!      by the DEBUG built DST record
					!      pointed to by RST$L_DSTPTR.
	RST$L_TYPCOMPCNT= [ 10, L_ ],	! The number of record components if
					!      this is a data record type
	RST$A_TYPCOMPLST= [ 11, A_ ],	! The start of a table of record compon-
					!      ent RST pointers
	RST$L_VARSETCNT	= [ 2, L_ ],	! The number of distinct variants in
					!      this record variant set
	RST$L_VARTAGPTR	= [ 4, L_ ],	! A pointer to the RST entry of the tag
					!      variable for this variant set
	RST$A_VARSETTBL	= [ 6, A_ ],	! The start of a table of variant set
					!      members, giving the tag value and
					!      component list for each variant.
	RST$L_INVOCNUM	= [ 6, L_ ]	! The desired invocation number
	TES;


! Declare symbolic names for the lengths of the various data, type, and
! invocation number RST entries.  All lengths are in longwords.
!
LITERAL
	RST$K_DATENTSIZ = 7,		! Size of the Data Symbol RST Entry and
					!      the Type Component RST Entry
	RST$K_TYPENTSIZ = 11,		! Size of the Data Type RST Entry
	RST$K_VARENTSIZ	= 6,		! Size of the Variant Set RST Entry
	RST$K_INVENTSIZ = 7;		! Size of Invocation Number RST Entry

!	RST ENTRY FOR A DATA TYPE COMPONENT
!
!
!
!	The RST entry for a data type component has the format shown here.  A
!	"component" in this sense is a record component, one of a set of vari-
!	ants, a member of a union, or one of the enumeration literals of an
!	enumeration type.  The interpretation of a data type component is thus
!	dependent on the "type kind" of the containing data type.
!
!	The up-scope pointer always points to the RST entry for the data type to
!	which this is a component.  Data Type Component RST Entries are always
!	built when the RST for the whole module is built.
!
!	Like the Data Item RST Entry, the this RST entry also has a type pointer
!	which specifies the data type of the component.  This is zero for simple
!	types or a pointer to a Data Type RST Entry for a more complex data type
!	(such as records).
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------------------------------------------------------+
!   0	|                       RST$L_HASH_FLINK                        |
!	+---------------------------------------------------------------+
!   1	|                       RST$L_HASH_BLINK                        |
!	+---------------------------------------------------------------+
!   2	|                        RST$L_SYMCHNPTR                        |
!	+---------------------------------------------------------------+
!   3	|                         RST$L_DSTPTR                          |
!	+---------------------------------------------------------------+
!   4	|                       RST$L_UPSCOPEPTR                        |
!	+-------------------------------+---------------+---------------+
!   5	|        RST$W_REFCOUNT         |   Flag bits   |  RST$B_KIND   |
!	+-------------------------------+---------------+---------------+
!   6	|                         RST$L_TYPEPTR                         |
!	+---------------------------------------------------------------+

!	RST ENTRY FOR A DATA TYPE
!
!
!
!	The RST entry for a data type has the format shown here.  Not all data
!	types have RST entries--those described by one-byte type codes or stand-
!	ard descriptors do not.  Data Type RST Entries are used for all record,
!	variant, union, and enumeration type data types, however.  The up-scope
!	pointer always points to the RST entry for the lexical entity (module,
!	routine, or lexical block) in which the data type was declared.  A data
!	type need not have a name, however--it can be anonymous as it is in a
!	PL/I or COBOL record declaration.  Data Type RST Entries for records,
!	variants, and enumeration types are built when the RST as a whole is
!	built.  All other Data Type RST Entries are built only when needed.
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------------------------------------------------------+
!   0	|                       RST$L_HASH_FLINK                        |
!	+---------------------------------------------------------------+
!   1	|                       RST$L_HASH_BLINK                        |
!	+---------------------------------------------------------------+
!   2	|                        RST$L_SYMCHNPTR                        |
!	+---------------------------------------------------------------+
!   3	|                         RST$L_DSTPTR                          |
!	+---------------------------------------------------------------+
!   4	|                       RST$L_UPSCOPEPTR                        |
!	+-------------------------------+---------------+---------------+
!   5	|        RST$W_REFCOUNT         |   Flag bits   |  RST$B_KIND   |
!	+-------------------------------+---------------+---------------+
!   6	|        RST$W_TYPREFCNT        |    Unused     |  RST$B_FCODE  |
!	+-------------------------------+---------------+---------------+
!   7	|                        RST$L_TYPREFTBL                        |
!	+---------------------------------------------------------------+
!   8	|                         RST$L_BITSIZE                         |
!	+---------------------------------------------------------------+
!   9	|                     RST$L_DST_TYP_REC_PTR                     |
!	+---------------------------------------------------------------+
!  10	|                       RST$L_TYPCOMPCNT                        |
!	+---------------------------------------------------------------+
!  11	|                       RST$A_TYPCOMPLST                        |
!	|                                                               |
!  ..	|                                                               |
!	|         Pointers to the Type Component RST Entries of         |
!  ..	|                 the components of this record                 |
!	|        or to the Data Item RST Entries of the elements        |
!  ..	|                   of this enumeration type                    |
!	|           (Not used for other kinds of data types)            |
!  ..	|                                                               |
!	|                                                               |
!  ..	|                                                               |
!	+---------------------------------------------------------------+
!
!
!**+
!
! These are the possible values for the RST$B_FCODE field.
!
LITERAL
	RST$K_TYPE_ARRAY	= 1,	! Array type
	RST$K_TYPE_ATOMIC	= 2,	! Atomic VAX standard type
	RST$K_TYPE_DESCR	= 3,	! VAX standard descriptor type
	RST$K_TYPE_ENUM		= 4,	! Enumeration type
	RST$K_TYPE_PICT		= 5,	! Picture type (as in Cobol and PL/I)
	RST$K_TYPE_TPTR		= 6,	! Typed pointer type
	RST$K_TYPE_RECORD	= 7,	! Record data type
	RST$K_TYPE_SET		= 8,	! Set type
	RST$K_TYPE_SUBRNG	= 9,	! Subrange data type
	RST$K_TYPE_SUBSET	= 10,	! Subset data type (as in Ada)
	RST$K_TYPE_UNION	= 11,	! Union data type
	RST$K_TYPE_COBHACK	= 12,	! Cobol Hack data item
	RST$K_TYPE_BLIDATA	= 13,	! Bliss data item
	RST$K_TYPE_BLIFLD	= 14,	! Bliss field
	RST$K_TYPE_FILE		= 15,	! File data type (as in Pascal)
	RST$K_TYPE_PTR		= 16,	! Untyped pointer data type
	RST$K_TYPE_AREA		= 17,	! Area type
	RST$K_TYPE_OFFSET	= 18,	! Offset type
	RST$K_TYPE_MINIMUM = 1,		! Minimum possible FCODE value
	RST$K_TYPE_MAXIMUM = 18;	! Maximum possible FCODE value
!**-

!	RST ENTRY FOR A RECORD VARIANT SET
!
!
!
!	The RST entry for a record variant set has the format shown here.  A
!	record variant set is the set of variants of some data record which
!	are distinguished by the same tag variable.  This RST entry does not
!	appear free-standing--it is always built inside the memory block alloc-
!	ated for the containing record's Data Type RST Entry.  Its hash links,
!	symbol chain pointer, and up-scope pointers are thus not used.  Its DST
!	pointer points to the variant set's Variant-Set Begin DST record.  The
!	entry has extra fields which point to the tag variable's RST entry and
!	give the list of individual record variants within the set.
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------------------------------------------------------+
!   0	|                       RST$L_HASH_FLINK                        |
!	+---------------------------------------------------------------+
!   1	|                       RST$L_HASH_BLINK                        |
!	+---------------------------------------------------------------+
!   2	|                        RST$L_VARSETCNT                        |
!	+---------------------------------------------------------------+
!   3	|                         RST$L_DSTPTR                          |
!	+---------------------------------------------------------------+
!   4	|                        RST$L_VARTAGPTR                        |
!	+-------------------------------+---------------+---------------+
!   5	|        RST$W_REFCOUNT         |   Flag bits   |  RST$B_KIND   |
!	+-------------------------------+---------------+---------------+
!   6	|                        RST$A_VARSETTBL                        |
!	|                                                               |
!  ..	|        Pointers to the Variant Entries (see next page)        |
!	|             for the variants in this variant set              |
!  ..	|                (One such pointer per longword)                |
!	|                                                               |
!  ..	|                                                               |
!	+---------------------------------------------------------------+

!	This is the format of a Variant Entry as pointed to by the pointers
!	in the Variant-Set RST Entry.  This entry gives the list of record
!	components which comprise this particular record variant.  It also
!	gives a pointer to the Variant-Value DST record for this variant.
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------------------------------------------------------+
!   0	|                       RST$L_VAR_DSTPTR                        |
!	+---------------------------------------------------------------+
!   1	|                       RST$L_VAR_COMPCNT                       |
!	+---------------------------------------------------------------+
!   2	|                       RST$A_VAR_COMPLST                       |
!	|                                                               |
!  ..	|              List of RST pointers to the record               |
!	|                  components in this variant                   |
!  ..	|                      (One per longword)                       |
!	|                                                               |
!  ..	|                                                               |
!	+---------------------------------------------------------------+
!
!
!
! Declarations for the fields in the Variant Entry.  Also a declaration macro.
!
FIELD RST$FLD_VARENT =
	SET
	RST$L_VAR_DSTPTR  = [ 0, L_ ],	! Pointer to Variant-Value DST record
	RST$L_VAR_COMPCNT = [ 1, L_ ],	! Number of components in this variant
	RST$A_VAR_COMPLST = [ 2, A_ ]	! Start of component RST pointer list
	TES;

MACRO
	RST$VAR_ENTRY = BLOCK[] FIELD(RST$FLD_VARENT) %; ! Declaration macro

!**+
LITERAL
	rst$k_tag_block_size = 3;
FIELD rst$tag_block_fields =
	SET
	rst$l_tag_numvals = [ 0, L_ ],	! Number of values to follow (1 or 2)
	rst$l_tag_lowbound = [ 1, L_ ],	! Lower bound value
	rst$l_tag_highbound = [ 2, L_ ]	! High bound value
	TES;
MACRO
	rst$tag_list = BLOCKVECTOR[ ,rst$k_tag_block_size]
				FIELD(rst$tag_block_fields) %;
!**-

!	RST ENTRY FOR AN INVOCATION NUMBER
!
!
!
!	The RST entry for an invocation number has the format shown here.  This
!	RST entry always follows the RST entry to which the invocation number
!	belongs on the module's Symbol Chain.  If a Data Item RST Entry, for
!	example, has an associated invocation number, then its RST$V_INVOCNUM
!	bit is set and its RST$L_SYMCHNPTR field points to an Invocation Number
!	RST Entry.  The Invocation Number RST Entry then specifies the desired
!	invocation number (which is assumed to apply to the innermost routine
!	in the scope of the symbol's declaration).  The RST$L_UPSCOPEPTR field
!	in the Invocation Number RST Entry points to the original RST entry of
!	the object (usually data item) without an invocation number.  The format
!	of the Invocation Number RST Entry is as follows:
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------------------------------------------------------+
!   0	|                       RST$L_HASH_FLINK                        |
!	+---------------------------------------------------------------+
!   1	|                       RST$L_HASH_BLINK                        |
!	+---------------------------------------------------------------+
!   2	|                        RST$L_SYMCHNPTR                        |
!	+---------------------------------------------------------------+
!   3	|                         RST$L_DSTPTR                          |
!	+---------------------------------------------------------------+
!   4	|                       RST$L_UPSCOPEPTR                        |
!	+-------------------------------+---------------+---------------+
!   5	|        RST$W_REFCOUNT         |   Flag bits   |  RST$B_KIND   |
!	+-------------------------------+---------------+---------------+
!   6	|                        RST$L_INVOCNUM                         |
!	+---------------------------------------------------------------+

!		S C O P E   L I S T   D E F I N I T I O N S
!
!
!
!	The scope list maintains the list of scopes declared with the SET SCOPE
!	command.  It is a singly linked list pointed to by the global variable
!	SCOPE$LIST in module RSTCNTRL.  Each scope entry on the list has this
!	format:
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------------------------------------------------------+
!   0	|                         SCOPE$L_FLINK                         |
!	+---------------------------------------------------------------+
!   1	|                         SCOPE$L_STATE                         |
!	+---------------------------------------------------------------+
!   2	|                        SCOPE$L_RSTPTR                         |
!	+---------------------------------------------------------------+
!   3	|                        SCOPE$L_MODPTR                         |
!	+---------------------------------------------------------------+
!
!
!
!	A pointer to a scope list entry is declared as follows:
!
!			SCOPEPTR: REF SCOPE$ENTRY
!
!
!
! Declare the scope entry fields and the definition macro.
!
FIELD SCOPE$FLD_DEF =
	SET
	SCOPE$L_FLINK	= [ 0, L_ ],	! Scope list forward link or zero
	SCOPE$L_STATE	= [ 1, L_ ],	! The scope "state" or kind
	SCOPE$L_RSTPTR	= [ 2, L_ ],	! Pointer to scope's own RST entry
	SCOPE$L_MODPTR	= [ 3, L_ ]	! Pointer to scope's Module RST Entry
	TES;

LITERAL
	SCOPE$K_ENTSIZE	= 4;		! Size of scope entry in longwords

MACRO
	SCOPE$ENTRY = BLOCK[SCOPE$K_ENTSIZE] FIELD(SCOPE$FLD_DEF) %;


! These are the possible values of the SCOPE$L_STATE field.  Each of these val-
! ues indicates what kind of scope is to be searched to match a given pathname.
!
LITERAL
	SCOPE$K_NORMAL	= 1,		! Normal named scope
	SCOPE$K_NUMBERED= 2,		! Numbered scope (PC in CALL stack)
	SCOPE$K_GLOBAL	= 3,		! Global Symbol Table
	SCOPE$K_SETMODS	= 4;		! All SET modules

!		S O U R C E   D I R E C T O R Y   S E A R C H   L I S T
!
!
!
!	The Source Directory Search List is a list structure which keeps track
!	of all source directory names specified by the user via SET SOURCE and
!	SET SOURCE/MODULE=xxx commands.  This structure is thus searched when
!	a source file must be opened so that the file is opened in the proper
!	directory.
!
!	The structure of this list is as follows.  Variable DBF$SRC_DIR_LIST in
!	module DBGSOURCE points to a singly linked list of Source Directory
!	Search List Header Blocks.  Each Header Block contains a Module RST
!	Entry pointer (which may be zero) and points to a singly linked list of
!	Source Directory Search List Entries.  Each such entry contains a direc-
!	tory name as a Counted ASCII string.
!
!	The list is searched by first searching all the Header Blocks for the
!	Module RST Entry pointer for the current module, i.e. the module from
!	which source lines are to be displayed.  If the desired module is not
!	found, the Header Block with the zero Module RST Entry pointer is used
!	instead.  The found Header Block then points to the linked list of
!	directory names to use when searching for the desired source file.  If
!	there is no Header Block with either the desired module pointer or the
!	zero module pointer, no Source Directory Search List Entries are used--
!	the file name from the Declare Source File DST command is used as is.
!
!	The command SET SOURCE/MODULE=modname dir1,...,dirN is represented by a
!	Header Block with a pointer to the Module RST Entry for module "modname"
!	and a pointer to a linked list of Entries.  There is one Entry for each
!	of dir1, ..., dirN.  The command SET SOURCE dir1,...,dirN is represented
!	by a Header Block with a zero Module RST Entry pointer and of course a
!	pointer to a linked list of Entries for dir1, ..., dirN.

!	SOURCE DIRECTORY SEARCH LIST HEADER BLOCK
!
!
!
!	The Source Directory Search List Header Block, as described on the
!	previous page, has the following format:
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------------------------------------------------------+
!   0	|                         SDSL$L_FLINK                          |
!	+---------------------------------------------------------------+
!   1	|                        SDSL$L_LIST_PTR                        |
!	+---------------------------------------------------------------+
!   2	|                         SDSL$L_MODPTR                         |
!	+---------------------------------------------------------------+
!
!
!
!	A pointer to a Source Directory Search List Header Block is declared as
!	follows:
!
!			SDSL_PTR: REF SDSL$HEADER
!
!
! Declare the fields of the Source Directory Search List Header Block.  Also
! declare the declaration macro.
!
FIELD SDSL$FLD_HEADER =
	SET
	SDSL$L_FLINK	= [ 0, L_ ],	! Forward link to next Header Block
	SDSL$L_LIST_PTR	= [ 1, L_ ],	! Pointer to list of SDSL Entries
	SDSL$L_MODPTR	= [ 2, L_ ]	! Pointer to Module RST Entry of module
					!      to which search list applies; is
					!      zero if for all other modules
	TES;

LITERAL
	SDSL$K_HDR_SIZE	= 3;		! Size of SDSL Header Block in longwords

MACRO SDSL$HEADER = BLOCK[SDSL$K_HDR_SIZE] FIELD(SDSL$FLD_HEADER) %;

!	SOURCE DIRECTORY SEARCH LIST ENTRY
!
!
!
!	There is one Source Directory Search List Entry for each directory name
!	specified on a SET SOURCE command.  The "directory name" may in fact
!	contains a full file name, including extension and version number, but
!	in most cases it is used only to override the directory name as given
!	in the Declare Source File DST command.  This is the format of a Source
!	Directory Search List Entry:
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------------------------------------------------------+
!   0	|                       SDSL$L_ENT_FLINK                        |
!	+-----------------------------------------------+---------------+
!   1	|              SDSL$A_ENT_DIRNAME               | $B_ENT_DIRLEN |
!	|                                               +---------------+
!  ..	|               (Directory name in Counted ASCII)               |
!	|                                                               |
!  ..	|                                                               |
!	+---------------------------------------------------------------+
!
!
!
!	A pointer to a Source Directory Search List Entry is declared like this:
!
!			SDSL_ENT_PTR: REF SDSL$ENTRY
!
!
! Declare the fields of the Source Directory Search List Entry.  Also declare
! the declaration macro.
!
FIELD SDSL$FLD_ENTRY =
	SET
	SDSL$L_ENT_FLINK   = [ 0, L_ ],	! Forward link to next SDSL Entry
	SDSL$B_ENT_DIRLEN  = [ 1, B0_ ],! Length in characters of directory name
	SDSL$A_ENT_DIRNAME = [ 1, A1_ ]	! First character of directory name
	TES;

LITERAL
	SDSL$K_ENT_SIZE	= 1;		! Size of fixed portion of SDSL Entry
					!      in longwords

MACRO SDSL$ENTRY = BLOCK[] FIELD(SDSL$FLD_ENTRY) %;

!		S O U R C E   F I L E   C O N T R O L   B L O C K
!
!
!
!	This is the format of the Source File Control Block:
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------------------------------------------------------+
!   0	|                         SFCB$L_FLINK                          |
!	+---------------------------------------------------------------+
!   1	|                         SFCB$L_BLINK                          |
!	+-----------------------------------------------+---------------+
!   2	|                 Unused (MBZ)                  |  SFCB$B_KIND  |
!	+-------------------------------+---------------+---------------+
!   3	|       SFCB$W_RFACURLEN        |       SFCB$W_RFASPACING       |
!	+-------------------------------+-------------------------------+
!   4	|                       SFCB$L_RFATBLPTR                        |
!	+---------------------------------------------------------------+
!   5	|                         SFCB$L_DSTPTR                         |
!	+---------------------------------------------------------------+
!   6	|                         SFCB$L_FABPTR                         |
!	+---------------------------------------------------------------+
!   7	|                         SFCB$L_RABPTR                         |
!	+---------------------------------------------------------------+
!   8	|                         SFCB$L_NAMPTR                         |
!	+---------------------------------------------------------------+
!   9	|                       SFCB$L_XABDATPTR                        |
!	+---------------------------------------------------------------+
!  10	|                       SFCB$L_XABFHCPTR                        |
!	+---------------------------------------------------------------+
!  11	|                       SFCB$L_NAMBUFFER                        |
!	+---------------------------------------------------------------+
!  12	|                       SFCB$L_CURRECNUM                        |
!	+---------------------------------------------------------------+
!  13	|                        SFCB$L_CUR_RFA0                        |
!	+-------------------------------+-------------------------------+
!  14	|            Unused             |        SFCB$W_CUR_RFA4        |
!	+-------------------------------+-------------------------------+
!  15	|                        SFCB$L_LBRINDEX                        |
!	+---------------------------------------------------------------+
!
!
!
!	The Source File Control Blocks (SFCBs) keep track of all currently open
!	source files.  This includes modules within source libraries as well as
!	normal RMS files.  Each such block contains all information needed to
!	read source records from the corresponding file.  These blocks form a
!	circular doubly linked list, where variable DBG$SRC_SFCB_PTR in module
!	DBGSOURCE points to the first block on the list.  The blocks are always
!	maintained in order so that the Most Recently Used SFCB is first on the
!	list and the Least Recently Used block is last.  This ordering allows
!	DEBUG to close the Least Recently Used source file when a file must be
!	closed in order to open a new file.
!
!	DEBUG always keeps a fixed number of Source File Control Blocks on the
!	list.  This number is given by variable DBG$SRC_MAX_FILES in module
!	DBGSOURCE.  It can be changed by the user with the SET MAX_SOURCE_FILES
!	command.  This number limits the number of source files which are open
!	at the same time.  Such a limit is required to prevent DEBUG from using
!	up too many of the limited number of channels the user can have open at
!	any one time.  Thus, when all SFCBs are in use and a new source file
!	must be opened, the Least Recently Used file is closed and its SFCB is
!	reused for the new file.
!
!	A pointer to a Source File Control Block is declared as follows:
!
!			SFCB_PTR: REF SFCB$BLOCK
!
!
! Declare the fields of the Source File Control Block.  Also declare the
! declaration macro.
!
FIELD SFCB$FLD_DEF =
	SET
	SFCB$L_FLINK	= [ 0, L_ ],	! Forward link to next SFCB
	SFCB$L_BLINK	= [ 1, L_ ],	! Backward link to previous SFCB
	SFCB$B_KIND	= [ 2, B0_ ],	! The kind of source file this is
	SFCB$W_RFASPACING=[ 3, W0_ ],	! The allocated length of the RFA table
	SFCB$W_RFACURLEN= [ 3, W1_ ],	! The used length of the RFA table
	SFCB$L_RFATBLPTR= [ 4, L_ ],	! Pointer to Record File Address (RFA)
					!      table for this source file
	SFCB$L_DSTPTR	= [ 5, L_ ],	! Pointer to DST Declare Source File
					!      command for this source file
	SFCB$L_FABPTR	= [ 6, L_ ],	! Pointer to the FAB for this file
	SFCB$L_RABPTR	= [ 7, L_ ],	! Pointer to the RAB for this file
	SFCB$L_NAMPTR	= [ 8, L_ ],	! Pointer to the NAM block for this file
	SFCB$L_XABDATPTR= [ 9, L_ ],	! Pointer to the XAB Date and Time block
					!      for this file
	SFCB$L_XABFHCPTR= [ 10, L_ ],	! Pointer to XAB File Header Character-
					!      istics block for this file
	SFCB$L_NAMBUFFER= [ 11, L_ ],	! Pointer to buffer for NAM block file
					!      name strings for this file
	SFCB$L_CURRECNUM= [ 12, L_ ],	! Record number at which the source file
					!      is currently positioned
	SFCB$L_CUR_RFA0	= [ 13, L_ ],	! RFA at which the source file is cur-
					!      rently positioned (first 4 bytes)
	SFCB$W_CUR_RFA4	= [ 14, W0_ ],	! RFA at which the source file is cur-
					!      rently positioned (last 2 bytes)
	SFCB$L_LBRINDEX	= [ 15, L_ ]	! Library file index used by librarian
	TES;

LITERAL
	SFCB$K_SIZE	= 16;		! Size of SFCB in longwords

MACRO SFCB$BLOCK = BLOCK[SFCB$K_SIZE] FIELD(SFCB$FLD_DEF) %;


! Declare the possible values of the SFCB$B_KIND field.
!
LITERAL
	SFCB$K_NOTUSED	= 1,		! This SFCB is not used (is available)
	SFCB$K_RMSFILE	= 2,		! This SFCB is used for an RMS file
	SFCB$K_LBRFILE	= 3;		! This SFCB is used for a module within
					!      a source library

!			R E C O R D   F I L E   A D D R E S S   T A B L E
!
!
!	This is the format of each Record File Address Table entry:
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------------------------------------------------------+
!   0	|                       RFATBL$L_RFA0                           |
!	+---------------------------------------------------------------+
!   1	                                |         RFATBL$W_RFA4         |
!	                                +-------------------------------+
!
!
!
!	The Record File Address Table correlates record numbers in a source
!	file with RFA's for that file. It is used during the TYPE command
!	and other commands that cause source lines to be displayed, to
!	help locate the desired record more efficiently.
!
!	There is one RFA table for each open file. The table is allocated
!	during DBG$SRC_INIT and a pointer to the table is placed in the
!	Source File Control Block. The table consists of a fixed number 
!	of entries (RFATBL_SIZE_ENTRIES, defined in DBGSOURCE). 
!
!	For every N records in the file, there is one RFA entry. That is,
!	the first entry is the RFA for record 1, the next for record (1+N),
!	the next for record (1+2N), and so on. The spacing N can be adjusted
!	dynamically and is kept in the Source File Control Block.
!
!	A pointer to an RFA table is declared as follows:
!
!		RFATBL_PTR : REF RFATBL$BLOCKVECTOR(RFATBL_SIZE_ENTRIES)
!
!	Declare the fields of an RFA table entry. Also declare the
!	declaration macro

FIELD RFATBL$FLD_DEF =
    SET
    RFATBL$L_RFA0	=	[ 0 , L_ ] ,
    RFATBL$W_RFA4	=	[ 4 , W0_]
    TES;

LITERAL
    RFATBL$K_SIZE	=	6;

MACRO RFATBL$BLOCKVECTOR(N)  
    = BLOCKVECTOR [N, RFATBL$K_SIZE, BYTE] FIELD(RFATBL$FLD_DEF) %;


!			S O U R C E   F I L E   I D   T A B L E
!
!
!
!	The Source File ID Table is used during the decoding of the Source Line
!	Correlation DST Record to keep track of the File IDs used to reference
!	the current module's source files.  The Source File ID Table consists of
!	a singly linked list of Source File ID Table Entries, where each entry
!	gives a File ID, a pointer to the corresponding Declare Source File
!	command, (This command gives all needed information about the identity
!	and nature of the source file.), and the current source record number.
!	This table is used locally in routine DBG$SRC_TYPE_LNUM_SOURCE in 
!	module DBGSOURCE.  This is the format of each Source File ID Table 
!	Entry:
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------------------------------------------------------+
!   0	|                         SFIT$L_FLINK                          |
!	+---------------------------------------------------------------+
!   1	|                        SFIT$L_FILE_ID                         |
!	+---------------------------------------------------------------+
!   2	|                         SFIT$L_DSTPTR                         |
!	+---------------------------------------------------------------+
!   3   |                         SFIT$L_CURRECNUM                      |
!       +---------------------------------------------------------------+
!
!
!
!	A pointer to a Source File ID Table Entry is declared as follows:
!
!			SFIT_PTR: REF SFIT$ENTRY
!
!
! Declare the fields of the Source File ID Table Entry.  Also declare the
! declaration macro.
!
FIELD SFIT$FLD_DEF =
	SET
	SFIT$L_FLINK	 = [ 0, L_ ],	! Forward link to next SFIT entry
	SFIT$L_FILE_ID	 = [ 1, l_ ],	! File ID value for this source file
	SFIT$L_DSTPTR	 = [ 2, L_ ],	! Pointer to DST Declare Source File
					!      command for this source file
    	SFIT$L_CURRECNUM = [3, L_]      ! Current source record number for
    					!      this source file
	TES;

LITERAL
	SFIT$K_SIZE	= 4;		! Size of SFIT entry in longwords

MACRO SFIT$ENTRY = BLOCK[SFIT$K_SIZE] FIELD(SFIT$FLD_DEF) %;

!	    S T A T I C   A D D R E S S   T A B L E   D E F I N I T I O N S
!
!
!
!	The Static Address Table (SAT) consists of a two-level structure.  There
!	is a Program Static Address Table which specifies what static addresses
!	(code addresses and static data addresses) belong to what modules.  This
!	table consists of a linked list of SAT entries where each entry speci-
!	fies an address range and a pointer to the corresponding Module RST
!	Entry.  The list is ordered by start address so that low start addresses
!	come before higher start addresses.  It should be noted that a given
!	address may be covered by more than one SAT entry because different mod-
!	ules can have global PSECTs in common--Fortran COMMON blocks cause this
!	situation to arise.  Given an address, the Program Static Address Table
!	can thus be searched to find the module that contains the address.
!
!	On a second level, there is a Module Static Address Table for each mod-
!	ule that is SET.  This SAT is a linked list of exactly the same structure
!	as the Program SAT except that the RST pointer in the SAT entry points
!	to the RST entry of the symbol, not the module, containing the address
!	range.  This list is also ordered by start address and again more than
!	one symbol may contain the same address (due to Fortran EQUIVALENCEing
!	for example).  If two entries have the same start address, the entry
!	with the larger end address is placed first in the Module SAT; this is
!	crucial to the correct behavior of the DBG$STA_SETCONTEXT routine where
!	routine addresses are compared to PC values from the VAX call stack.
!	The Module RST Entry contains a pointer (RST$L_SAT_PTR) which points to
!	the first SAT entry on the module's SAT chain.
!
!	The individual Static Address Table entry has this format:
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------------------------------------------------------+
!   0	|                          SAT$L_FLINK                          |
!	+---------------------------------------------------------------+
!   1	|                          SAT$L_START                          |
!	+---------------------------------------------------------------+
!   2	|                           SAT$L_END                           |
!	+---------------------------------------------------------------+
!   3	|                         SAT$L_RSTPTR                          |
!	+---------------------------------------------------------------+
!
!
!
!	A pointer to a Static Address Table entry is declared as follows:
!
!			SATPTR: REF SAT$ENTRY
!
!
! Field definitions for the SAT entry.
!
FIELD SAT$FLD_DEF =
	SET
	SAT$L_FLINK	= [ 0, L_ ],	! Forward link to next SAT entry on the
					!      chain--zero terminate the chain.
	SAT$L_START	= [ 1, L_ ],	! Start address of address range
	SAT$L_END	= [ 2, L_ ],	! End address of address range
	SAT$L_RSTPTR	= [ 3, L_ ]	! Pointer to RST entry of module or sym-
					!      bol containing this address range
	TES;

LITERAL
	SAT$K_ENTSIZE	= 4;		! Size of one SAT entry in longwords

MACRO
	SAT$ENTRY = BLOCK[SAT$K_ENTSIZE] FIELD(SAT$FLD_DEF) %;

!		V A L U E   A N D   P R I M A R Y   D E S C R I P T O R S
!
!
!
!	The Value Descriptor and the Primary Descriptor are descriptor blocks
!	built by the language-specific routines.  As such their contents are
!	unknown to the Debugger kernel (and are not described here), but they
!	all must have the common header described here.  A Value Descriptor or
!	Primary Descriptor thus has this format:
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------+---------------+-------------------------------+
!   0	| $B_DHEAD_LANG | $B_DHEAD_TYPE |      DBG$W_DHEAD_LENGTH       |
!	+---------------+---------------+-------------------------------+
!   1	|                      DBG$L_DHEAD_POINTER                      |
!	+---------------------------------------------------------------+
!   2	|                                                               |
!	|                                                               |
!  ..	|                                                               |
!	|                 Language-Specific Information                 |
!  ..	|                                                               |
!	|                                                               |
!  ..	|                                                               |
!	+---------------------------------------------------------------+
!
!
!
!	A pointer to a descriptor header block is declared as follows:
!
!			DESCPTR: REF DBG$DHEAD
!
!**+
!
! Define the Value or Primary Descriptor Header Block fields and the declaration
! macro.
!
FIELD DBG$DHEAD_FIELDS =
	SET
	DBG$W_DHEAD_LENGTH = [ 0, W0_ ],! Length of descriptor in bytes
					!      including this header
	DBG$B_DHEAD_TYPE   = [ 0, B2_ ],! The type of this descriptor
	DBG$B_DHEAD_LANG   = [ 0, B3_ ],! Language of the descriptor
	DBG$L_DHEAD_POINTER= [ 1, L_ ]	! Unused at present
	TES;

LITERAL
	DBG$K_DHEAD_SIZE = 2;		! Size of descriptor header in longwords

MACRO
	DBG$DHEAD = BLOCK[DBG$K_DHEAD_SIZE] FIELD(DBG$DHEAD_FIELDS) %;


! The possible values of the DBG$B_DHEAD_LANG field are the language codes
! defined in the section entitled "Miscellaneous Literals" above.  The possible
! value of the DBG$B_DHEAD_TYPE field, which are defined in the same section,
! are the following:
!
!	DBG$K_PRIMARY_DESC		! This is a Primary Descriptor
!	DBG$K_VALUE_DESC		! This is a non-volatile Value Descriptor
!	DBG$K_V_VALUE_DESC		! This is a volatile Value Descriptor
!**-

!		O L D   D E B U G G E R   D E F I N I T I O N S
!
!
!
!	These definitions are used by old Debugger modules which also need to
!	use the new RST (and other) definitions.
!
LITERAL
	! constants used to identify individual rst flags
	rst$f_global = 1,
	rst$f_nonzlength = 2,
	rst$f_modset	= 3;

MACRO

	!
	!  Get the srm type address from a dst with address calculation commands
	!  The type is following the name string
	!    7 - size of fixed portion of dst
	!    1 - byte to hold count of name string
	!    dst[dstr_name] - contains count of characters in name string
	!
	!    add this distance to base address to get address of byte 
	!	containing the srm type

	CAD_SRM_TYPEA(DST) =
		( .DST + 7 + 1 + .DST[dst$b_name] ) %,

	!  Get the srm type from a dst with address calculation commands

	CAD_SRM_TYPE(DST) =
		( .(CAD_SRM_TYPEA(DST))<0,8,0>)   %,

	!  Get the address of the calculation commands in a dst which contains
	!   them.  They start one byte past the srm type.

	CAD_COMMANDS(DST) =
		( CAD_SRM_TYPEA(DST) + 1 ) %;


MACRO
	RST_UNITS( bytes ) =

		( ((bytes) + %upval-1)/%upval )
	%;

MACRO
				! DEBUG tells the RST module about ASCII
				! strings by passing a counted string pointer.
	CS_POINTER	= REF VECTOR[1,BYTE] %;

LITERAL

	! We will never print "symbol+offset" when the
	! upper bound for "symbol" is 0 and when
	! the offset is greater than RST_MAX_OFFSET

	RST_MAX_OFFSET		= %X'100';


!+
! Since scope definitions are recursive, we must
! stack ROUTINE BEGINs in the routine ADD_MODULE.
! It is no coincidence that this stack limit is the
! same as the limit on the length (in elements) of
! symbol pathnames.
!-

LITERAL
	MAX_SCOPE_DEPTH	= dbg$k_max_pathname;	! Routines can be nested to a maximum depth.


FIELD
	VALU_FIELD_SET =
    SET
	VALU_NT_PTR	= [  0,0,32,0 ],	! Associated NT pointer.
	VALU_VALUE	= [  4,0,32,0 ]		! The actual value.
    TES;

!+
! Declare an occurrence or REF to a VALUE_DESCRIPTOR
! via the following macros.
!-

LITERAL
	VALU_DESC_SIZE	= 8;		! Each one is 2 longwords long.

MACRO
	VALU_DESCRIPTOR	= BLOCK[ VALU_DESC_SIZE, BYTE ] FIELD( VALU_FIELD_SET ) %;

!++
!  Array Bounds Descriptor
!
!  An array bounds Descriptor is used to pass around all needed
!  information about an array and its associated dimensions.
!  Like VALU_DESCRIPTORs, they are simply 2-longword blocks,
!  but this might change.
!
!	!------longword-----!
!
!	!-------------------!
!	! address of array  !
!	!-------------------!
!	! length of array   !
!	!-------------------!
!
!  Such Descriptors must be accessed via the following
!  field names.
!--

FIELD
	ARRAY_BNDS_SET =
    SET
	ARRAY_ADDRESS	= [  0,0,32,0 ],	! Beginning address of array.
	ARRAY_LENGTH	= [  4,0,32,0 ]		! Size, in bytes, of array.
    TES;

!+
! Declare an occurrence or REF to an array bounds
! descriptor via the following macros.
!-

LITERAL
	ARRAY_BNDS_SIZE	= 8;		! Each one is 2 longwords long.

MACRO
	ARRAY_BNDS_DESC	= BLOCK[ ARRAY_BNDS_SIZE, BYTE ] FIELD( ARRAY_BNDS_SET ) %;


LITERAL
	SL_ACCE_INIT	= 0,	! See above.   "SL" --> SAT/LVT
	SL_ACCE_RECS	= 1,
	SL_ACCE_SORT	= 2,
	SL_ACCE_FREE	= 3;



!+
! You declare an occurrence or REF of an SAT datum via
! the macro, SAT_RECORD.
!-


MACRO
	SAT_RECORD	= BLOCK[ ] FIELD( sat$fld_def ) %;


!++
! The format of GST records is defined as a BLOCK
! (even though the records are variable sized)
! with the following fields:
!--

FIELD
	GST_FIELD_SET =
    SET
	GST_ENTRY_TYPE	= [  0,0, 8,0 ],	! Type of GST record.
	GST_IS_DEFN	= [  2,1, 1,0 ],	! This flag implies whether o no
						! the record is an entry definition.
	GST_VALUE	= [  5,0,32,0 ],	! The value of the global.
						! (This won't work for PSECTs)
	! The following 2 pairs are mutually
	! exclusive.  The first one is for GST
	! records of type GST_GLOBAL_DEFN, the
	! second is for GST_ENTRY_DEFN or GST_PROC_DEFN.

	GST_G_NAME_CS	= [ 9,0, 8,0 ],		! The symbol name is a counted string.
						! A dotted reference to this field
						! picks up the count, an undotted
						! one addresses the counted string.
	GST_G_NAME_ADDR	= [10,0, 8,0 ],		! The name string itself.  An undotted
						! reference is the address of the name,
						! a dotted one is the 1st character.


	GST_E_NAME_CS	= [11,0, 8,0 ],		! The entry name is a counted string.
						! A dotted reference to this field
						! picks up the count, an undotted
						! one addresses the counted string.
	GST_E_NAME_ADDR	= [12,0, 8,0 ],		! The name string itself.  An undotted
						! reference is the address of the name,
						! a dotted one is the 1st character.
	GST_P_MAX_ARG	= [ 1,0, 8,0 ],		! Maximum number of formal arguments.
	GST_P_REM_CNT	= [ 1,0, 8,0 ]		! Remaining byte count of argument
						! descriptor.
    TES;

!+
! You declare an occurrence or REF of a GST datum via:
!-

LITERAL
	GST_RECORD_SIZE	= 43;	! Each GST record is at most 43 bytes long.

MACRO
	GST_RECORD = BLOCK[ GST_RECORD_SIZE, BYTE] FIELD( GST_FIELD_SET ) %;


!+
! The GST record types are defined as:
!-

LITERAL
	! GST types:

	GST_LOWEST	= 1,		! We don't support global PSECTs now.

	GST_PSECT_DEFN	= 0,		! P-SECT record.
	GST_GLOBAL_DEFN	= 1,		! A global symbol definition record.
	GST_ENTRY_DEFN	= 2,		! An entry point definition.
	GST_PROC_DEFN	= 3,		! A procedure with formal argument desc.

	GST_HIGHEST	= 3;		! Highest one we support.

!++
! BLISS uses 'non-standard' DST records to encode
! most of its local symbol information.  These records
! are like most DST records except that the TYPE
! information is variable-sized.
!--

FIELD
	BLZ_FIELD_SET =
    SET
	BLZ_SIZE	= [  0,0, 8,0 ],	! First byte is record size in bytes.

	! The next byte contains DSC$K_DTYPE_Z, or we
	! wouldn't be applying this structure to a given
	! DST record.

	BLZ_TYP_SIZ	= [  2,0, 8,0 ],	! Type info takes up this
						!  many bytes.
	BLZ_TYPE	= [  3,0, 8,0 ],	! Which type of type Zero
						!  this corresponds to.
	BLZ_ACCESS	= [  4,0, 8,0 ],	! Access field.

	! Sub fields of _ACCESS are offset from beginning
	! of the BLZ record.

		BLZ_ACCES_TYPE	= [  4,0, 2,0 ],	! Type of access,
		BLZ_ACCES_BASD	= [  4,2, 2,0 ],	! based or not,
		BLZ_ACCES_BREG	= [  4,4, 4,0 ],	! associated register.

	BLZ_STRUCT	= [  5,0,3,0 ],			! Type of STRUCTURE reference.
	BLZ_REF		= [  5,7,1,0 ], 		! Indicates whether symbol has REF attribute

	! **** The following only work when BLZ_TYP_SIZ is 3.

	BLZ_VALUE	= [  6,0,32,0 ],	! DST VALUE field.
	BLZ_NAME_CS	= [ 10,0, 8,0 ],	! The symbol name is a counted string.
						! A dotted reference to this field
						! picks up the count, an undotted
						! one addresses the counted string.
	BLZ_NAME_ADDR	= [11,0, 8,0 ],		! The name string itself.  An undotted
						! reference is the address of the name,
						! a dotted one is the 1st character.
	
	! The following fields are in the variable length part of the DST record.
	! They should only be applied once the structure type has been determined 
	! or errors could result.		
	
	U_ALLOC_STRUC	= [ 6, 0, 32, 0],	! no of units alloc (except BLOCKVECTOR)
	U_ALLOC_BVEC	= [10, 0, 32, 0],	! no of units alloc for BLOCKVECTOR
	SIGN_EXT_VEC	= [10, 7,  1, 0],	! sign ext field for VECTOR
	UNIT_SIZE_BLOCK = [10, 0,  8, 0],	! unit size for BLOCK
	UNIT_SIZE_BVEC	= [14, 0,  8, 0],	! unit size for BLOCKVECTOR
	UNIT_SIZE_VEC	= [10, 0,  4, 0]	! unit size for VECTOR
    TES;

!+
! You declare a REF to a BLZ_DST datum via:
!-

LITERAL
	BLZ_REC_SIZ	= 54;	! Each DST record is at most 54 bytes long.

MACRO
	BLZ_RECORD = BLOCK[ BLZ_REC_SIZ, BYTE] FIELD( BLZ_FIELD_SET ) %;


!+
! The type zero sub types,
! as defined in CP0021.MEM, 
! must be within the following
! range.
!-

LITERAL

	! Type Zero Sub-Types:

	BLZ_LOWEST	= 1,	! Lowest variable type we support.

	BLISS_Z_FORMAL	= 1,	! Description of a ROUTINE formal.
	BLISS_Z_SYMBOL	= 2,	! A BLISS LOCAL symbol.

	BLZ_HIGHEST	= 2;	! Highest variable type we support.




!+
!  Dummy descriptors
!
!  Whenever a type DSC$K_DTYPE_CAD item is being accessed by descriptor
!  we must build a dummy one in free storage and put the current address
!  in it.  The address of this dummy descriptor is then used by the rest
!  of the debugger in referencing the item.  To be able to free up all this
!  space, the items are kept on a linked list. At the end of command processing
!  this list is walked down and all the space is returned to the free storage
!  manager.
!
!  Each entry on the linked list is a 3 longword vector 
!        
!	|-----------------------------------------------------------------|
!	|      pointer to next item on the linked list	                  |
!	|-----------------------------------------------------------------|
!	|      pointer to the dummy descriptor                            |
!	|-----------------------------------------------------------------|
!	|      size in bytes of the dummy descriptor                      |
!	|-----------------------------------------------------------------|
!
!
!  The global variable  DBG$GL_DLISHEAD if nonzero points to the first
!  item on the list.
!

LITERAL
	DLIS_ENTRY =	3 ,		! Size in longwords of entry on list
	DLIS_LINK  =	0 ,		! Pointer to next item on list
	DLIS_POINTER = 1  ,		! Pointer to dummy descriptor
	DLIS_DESCSIZE=  2 ;		! Size in bytes of descriptor



!	E N D   O F   D B G L I B . R E Q
