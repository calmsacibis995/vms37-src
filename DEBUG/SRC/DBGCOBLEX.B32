MODULE	DBGCOBLEX(IDENT = 'V03-000') =
BEGIN
!
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
!++
!
! FACILITY:	VAX-11 COBOL-SPECIFIC DEBUGGER MODULES
!
! ABSTRACT:
!
!	Cobol-Specific lexical routines for VAX/VMS DEBUG
!
! ENVIRONMENT:	VAX/VMS user mode
!
! AUTHOR:	J. Francis,	CREATION DATE: 1-May-1981
!
! MODIFIED BY:
!
!--

!
! Table of Contents
!
FORWARD ROUTINE
! Global Routines :
	dbg$ncob_prim_int,			! Primary Interpreter
	dbg$ncob_exp_int,			! Expression interpreter
! Local Routines  :
	dbg$ncob_get_token	: NOVALUE,	! Lexical Scanner (for paths)
	dbg$ncob_get_lexeme,			! Lexical Scanner (general)
	dbg$ncob_more_input,			! Lexical Scanner (checks EOL)
	dbg$ncob_advance	: NOVALUE,	! Advance command line pointer
	dbg$ncob_numeric_token;			! Scan numeric values
! Need Comments :-
!	Module-level definitions
!	dbg$ncob_exp_int
!	dbg$ncob_get_token
!	dbg$ncob_get_lexeme
!	dbg$ncob_more_input
!	dbg$ncob_advance
!	dbg$ncob_numeric_token

!
! INCLUDE FILES
!
REQUIRE 'SRC$:DBGPROLOG';
!
!
! EXTERNAL ROUTINES
!
EXTERNAL ROUTINE
	dbg$ncob_type_conv,			! COBOL type converter
	dbg$ncob_evaluate,			! Arithmetic routines
	dbg$ncob_make_desc,			! Prototype Descriptor builder
	dbg$ncob_make_val_desc,			! COBOL Value Descriptor builder
	dbg$ncob_make_packed_desc,		! Construct packed decimal value
	dbg$ncob_force_to_numeric,		! Get value into internal format
	dbg$ncob_pathdesc_to_cs,		! Convert pathname to string
	dbg$nmake_arg_vect,			! Error message builder
	dbg$nmatch,				! Routine to match strings
	dbg$npathname_parser,			! DEBUG path-name parser
	dbg$sta_getsymbol	: NOVALUE,	! Symbol lookup routine
	dbg$sta_setcontext	: NOVALUE,	! Context establishing routine
	dbg$sta_symtype		: NOVALUE,	! Return type of symbol
	dbg$sta_symname		: NOVALUE,	! Return name of symbol
	dbg$sta_typ_atomic	: NOVALUE,	! Routines for obtaining "type"
	dbg$sta_typ_descr	: NOVALUE,	!  information about data items
	dbg$sta_typ_array	: NOVALUE,	!    .    .    .    .    .    .
	dbg$sta_symparent,			! Get "parent" of record item
	dbg$nperm_sym_int,			! Bind register references
	dbg$nget_lastval,			! Return value for '\'
	dbg$get_tempmem,			! Storage space allocator
	lib$cvt_otb : ADDRESSING_MODE(GENERAL),	! Convert digit-string (base 8)
	lib$cvt_dtb : ADDRESSING_MODE(GENERAL),	! Convert digit-string (base 10)
	lib$cvt_htb : ADDRESSING_MODE(GENERAL);	! Convert digit-string (base 16)

!
! MACROS
!
FIELD dbg$ncob_fields =
    SET
    cob_primary_kind	= [2,B0_],	! KIND of primary descriptor
    cob_primary_symid	= [3,L_],	! SYMID of actual data item
    cob_subscript_count = [2,B1_],	! Count of subscripts
    cob_subscript_vector= [4,A_],	! Vector of subscript values
    cob_value_vmsdesc	= [2,A_],	! VAX/VMS standard descriptor for value
    cob_value_dschead	= [2,L_],	! Maps first 4 bytes of descriptor
    cob_value_dtype	= [2,B2_],	! "Dtype" field of descriptor
    cob_value_pointer	= [3,L_],	! Pointer to actual data item
    cob_value_scaling	= [4,L_],	! Scale factor and digit-count
    cob_value_picture	= [5,L_],	! TYPEID of picture if edited
    cob_value_literal	= [6,L_],	! "Value" for integer items
    cob_value_byte	= [6,B_],	! Reference to short
    cob_value_word	= [6,W_],	! (less than 32 bit)
    cob_value_long	= [6,L_],	!   integer values
    cob_value_high	= [7,L_],	! High-order 32 bits of quadword
    cob_value_address	= [6,A_] 	! Address of first byte of value
   TES;
LITERAL cob_fixed = 4;
MACRO dbg$ncob_descriptor = BLOCK[cob_fixed]
			    FIELD(dbg$dhead_fields,dbg$ncob_fields) %;
!
! LITERALS
!
LITERAL
	lex_type_char	= 0,
	lex_type_symbol	= 1,
	lex_type_number	= 2,
	lex_type_string	= 3,
	lex_type_word	= 4,
	lex_type_reg	= 5,
	lex_type_minimum= lex_type_char,
	lex_type_maximum= lex_type_reg,

	lexical_char	= %X'10000' * lex_type_char,
	lexical_symbol	= %X'10000' * lex_type_symbol,
	lexical_number	= %X'10000' * lex_type_number,
	lexical_string	= %X'10000' * lex_type_string,
	lexical_line	= %X'10000' * lex_type_word+dbg$k_tok_line,
	lexical_label	= %X'10000' * lex_type_word+dbg$k_tok_label,
	lexical_qname	= %X'10000' * lex_type_word+dbg$k_tok_qname,
	lexical_reg	= %X'10000' * lex_type_reg;

BIND	valid_digits = UPLIT('0123456789ABCDEF')	: VECTOR[16,BYTE],
	alphanumeric = UPLIT(%X'00000000',%X'03FF2010',
			     %X'07FFFFFE',%X'07FFFFFE') : BITVECTOR[128];
!
! OWN STORAGE
!
OWN
	operator_list	: INITIAL ('+-*/'),	! Recognised operators
	numeric_kind,				! kind of numeric item seen
	numeric_value,				! Storage for integer values
	numeric_desc	: dbg$stg_desc		! Pointer to numeric string
	    PRESET ([dsc$b_class]=dsc$k_class_d,[dsc$b_dtype]=dsc$k_dtype_t),
	token_kind,				! Type of token scanned
	token_desc	: dbg$stg_desc		! Descriptor for lexical token
	    PRESET ([dsc$b_class]=dsc$k_class_d,[dsc$b_dtype]=dsc$k_dtype_t);

BIND	token_type = token_kind<16,8>	: BYTE,
	token_char = token_kind<0,8>	: BYTE,
	token_code = token_kind<0,16>	: WORD;

GLOBAL ROUTINE DBG$NCOB_PRIM_INT(input_desc,result_type,result,radix,msg_vect) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Parses a maximal initial substring of the input string as a source
!	language symbolic reference or literal with certain DEBUG extensions.
!	Returns one of four types of data:
!
!	1) Primary descriptors are constructed for symbolic source language
!	   entities. In addition, primary descriptors are constructed for
!	   the DEBUG %LINE and %LABEL artifacts. Primary descriptors for
!	   %LINE and %LABEL should retain enough information to allow
!	   DBG$NxxxGETTYPE to associate a type of 'instruction' with the
!	   described entity.
!
!	2) A value descriptor is obtained (from DBG$NGET_LASTVAL) for
!	   the DEBUG pseudo symbol '\'.
!
!	   Note that the other DEBUG pseudo-symbols, '^' and '.' are NOT
!	   interpreted by this routine. They are to be regarded as syntax errors.
!
!	3) Permanent symbol descriptors are obtained (from DBG$NPERM_SYM_INT)
!	   for the DEBUG permanent symbols R0-R11, AP, SP, PC, and PSL. If the
!	   source language allows explicit operations on registers, then the
!	   use of these symbols overrides user defined symbolic references
!	   with the same name, unless an explicit pathname is given such as
!	   MODULE\ROUTINE\R5. If the source language does not allow
!	   explicit operations on registers, then a register name must be
!	   preceeded with '%', such as %R5, to be recognized. Otherwise, the
!	   symbol will be assumed to be a user defined symbolic reference.
!
!	4) An unsigned longword integer is returned as the value of numeric
!	   literals encountered in the input string. Literals which do not
!	   represent longword integers (such as ASCII strings and aggregates)
!	   are invalid.
!

! FORMAL PARAMETERS:
!
!	input_desc  -	A longword containing the address of a VAX standard
!			string descriptor describing the input string
!
!	result_type -	The address of a longword to contain an unsigned
!			value specifying the interpretation of the result
!			parameter according to the following code:
!
!	    dbg$k_literal	(120)	- result is an unsigned longword integer
!					  representing a numeric literal value
!
!	    dbg$k_primary_desc	(121)	- result is the address of a primary
!					  descriptor
!
!	    dbg$k_value_desc	(122)	- result is the address of a value
!					  descriptor
!
!	    dbg$k_perm_desc	(123)	- result is the address of a
!					  permanent symbol descriptor
!
!		   Unlike most other languages, COBOL allows variable names to
!		begin with digits, and to contain embedded hyphens. This means
!		that "123A" and "5-3" are valid variable names.  By default, a
!		string consisting of (decimal) digits only will be interpreted
!		as being a number (unless prefixed by %NAME), while "123A" and
!		"5-3" will be interpreted as variable names unless prefixed by
!		radix operators (^O, ^D or ^X).
!
!	result	   -	The address of a longword to contain either the address
!			of one of the three types of descriptors mentioned
!			above, or an unsigned longword integer.
!
!	radix	   -	A longword which contains an unsigned integer code which
!			describes the radix to be used in the interpretation of
!			numeric literals as follows:
!
!		dbg$k_default	 (1)	- source language default radix (decimal)
!		dbg$k_binary	 (2)	- binary
!		dbg$k_octal	 (8)	- octal
!		dbg$k_decimal	(10)	- decimal
!		dbg$k_hex	(16)	- hexadecimal
!
!	msg_vect - The address of a longword to contain the address of a
!			message argument vector as described on page 4-119 of
!			the VAX/VMS reference manual, volume 1A

! IMPLICIT INPUTS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	Primary descriptors are constructed from dynamic storage.
!	In case of a severe error return, a message argument vector is
!	constructed from dynamic storage.
!
! ROUTINE VALUE:
!	unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_WARNING (0) -	Result returned. Unexpected input encountered.
!				Note that some DEBUG commands allow address
!				expression lists, seperated by commas. This
!				return should be used in these cases ( or
!				when any foreign character is encountered
!				following complete processing of a primary).
!
!	STS$K_SUCCESS (1) -	Result returned. No error encountered.
!				Input string exhausted.
!
!	STS$K_ERROR   (2) -	No result returned. Syntax error encountered
!				immediately - no input accepted.
!				Note that this return should be used when encountering
!				any foreign character at the start of primary
!				processing such as a DEBUG pseudo-symbol other
!				than '\'.
!
!	STS$K_SEVERE  (4) -	No result returned. Fatal syntax or semantic
!				error encountered during processing of primary.
!				Message argument vector returned. No input
!				accepted.
!				Note that the input string descriptor fields
!				should be returned to their initial (on input)
!				values even though some input characters (but
!				not a complete primary string) have been accepted.
!
! SIDE EFFECTS:
!
!	The VAX standard string descriptor describing the input string is
!	updated to reflect the character following the last character accepted.
!	Informational message such as string or number truncation may be issued
!	during processing.
!--

!DBG$NCOB_PRIM_INT (input_desc, result_type, result, radix, msg_vect)
    BEGIN
    !
    ! Describe formal parameters that are structures
    !
    MAP	input_desc   : REF dbg$stg_desc;	! Pointer to input
    !
    !
    !
    ! Declare routine-level local variables
    !
    LOCAL
	local_desc   : dbg$stg_desc,		! Local copy of pointer
	lexeme_desc  : REF dbg$stg_desc,	! Pointer to lexical token
	result_desc  : REF dbg$ncob_descriptor,	! Pointer to primary descriptor
	pathtype,				! Type from pathname parser
	ref_path     : REF pth$pathname,	! Pathname Descriptor address
	pathname     : pth$pathname,		! Local Pathname Descriptor
	prim_symid,				! SYMID of COBOL identifier
	prim_kind,				! KIND information
	target_lexeme,				! Token to scan for next
	subscript   : dbg$stg_desc,		! Pointer to subscript entry
	fcode,					! Format code of data item
	typeid,					! Type-code of data item
	desc        : REF dbg$stg_desc;		! Pointer to VAX/VMS descriptor

    BIND name = pathname[pth$a_pathvector] : VECTOR[dbg$k_max_pathname,LONG];
    !+
    !
    ! The current pointers to the input command line must be preserved,
    ! as they must be returned to their initial state when an error is
    ! encountered.  Rather than saving the initial state and restoring
    ! it on an error we take a local copy of the command line pointers
    ! for use within the routine, and only update the command pointers
    ! if the routine completes successfully.
    !
    !-

    ch$move(8,.input_desc,local_desc);
    IF NOT dbg$ncob_more_input(local_desc,.msg_vect) THEN RETURN sts$k_severe;

    !+
    ! The first thing we do is call the pathname parser to see if what
    ! the user has typed is something that it recognises.
    !-
    IF dbg$npathname_parser(local_desc,dbg$ncob_get_token,
			    ref_path,pathtype,lexeme_desc)
    THEN
	BEGIN
	!+
	! Some sort of pathname reference seen. Check for the
	! special case of a register reference.
	!-
	IF .pathtype EQL dbg$k_reg
	THEN
	    BEGIN
	    !+
	    ! Register (or PSL) reference. In this case the pathname
	    ! parser will NOT have advanced the command line pointer
	    ! over the lexical token. We call dbg$ncob_get_lexeme to
	    ! find out exactly what type of reference we have.
	    !-
	    dbg$ncob_get_lexeme(local_desc);
	    !+
	    ! If this was a named register reference (%FP, %AP, %SP,
	    ! %PC or %PSL)  dbg$ncob_get_lexeme will have returned a
	    ! non-zero value in token_code. If the value returned in
	    ! token_code is zero this is a register reference of the
	    ! form %Rn, and we need to read & check the value of n.
	    !-
	    IF .token_code EQL 0
	    THEN
		BEGIN
		LOCAL number;
		!+
		!  Advance the pointers over the current token (%R),
		! and check for a number with no intervening blanks.
		!-
		dbg$ncob_advance(local_desc,token_desc);
		dbg$ncob_get_lexeme(local_desc,false);
		IF .token_type NEQ lex_type_number THEN RETURN sts$k_error;
		!+
		! Obtain the value of n (the register number). This
		! must be a valid register reference.  Note that we
		! are fairly permissive about the register numbers,
		! allowing the user to say %R05 as well as %R5, and
		! also permitting references to the named registers
		! (%FP, etc.) by register number (%R12 to %R15).
		!-
		IF lib$cvt_dtb(.token_code,.local_desc[dsc$a_pointer],number)
					AND
				.number LSSU 16
		THEN
		    token_code = .number+dbg$k_r0
		ELSE
		    RETURN sts$k_error;
		END;

	    !+
	    ! We have now parsed what we think is a valid reference
	    ! to a register.  Call the permanent symbol interpreter
	    ! to obtain a permanent symbol descriptor.
	    !-
	    IF dbg$nperm_sym_int(.token_code,result_desc,0,.msg_vect)
	    THEN
		BEGIN
		!+
		! Permanent symbol descriptor returned. Advance the
		! command line pointer over the register number and
		! set the result type to dbg$k_perm_desc.
		!-
		dbg$ncob_advance(local_desc,token_desc);
		.result_type = dbg$k_perm_desc;
		END
	    ELSE
		RETURN sts$k_severe;
	    END
	ELSE	!	dbg$k_pn,dbg$k_line,dbg$k_label
	    BEGIN
	    !+
	    ! Not a register reference (i.e. a label, line number, or a
	    ! data item).  If this is a data item reference check for a
	    ! COBOL qualified data reference ( A OF B or A IN B).
	    !-
	    LOCAL subscript_count;

	    subscript_count = 0;
	    IF .pathtype EQL dbg$k_pn
	    THEN
		BEGIN
		LOCAL new_count : BYTE;
		ch$move(4*(.ref_path[pth$b_totcnt]+2),.ref_path,pathname);
		new_count = .pathname[pth$b_totcnt];
		WHILE .new_count EQL 1 AND .pathname[pth$l_invocnum] EQL 0 DO
		    BEGIN
		    LOCAL pointer;
		    IF NOT (dbg$nmatch(local_desc,UPLIT BYTE(2,'OF'),2)
			OR  dbg$nmatch(local_desc,UPLIT BYTE(2,'IN'),2))
		    THEN EXITLOOP;

		    !+
		    ! Found a qualified data reference. Check that what follows
		    ! the "OF" is also a data reference, and that the number of
		    ! qualifiers does not exceed the maximum length for a DEBUG
		    ! pathname descriptor.
		    !-
		    pointer  = .local_desc[dsc$a_pointer];
		    IF dbg$npathname_parser(local_desc,dbg$ncob_get_token,
					    ref_path,pathtype,lexeme_desc)
					AND
				.pathtype EQL dbg$k_pn
		    THEN
			BEGIN
			new_count = .ref_path[pth$b_totcnt];
			IF .pathname[pth$b_totcnt]+.new_count GTR dbg$k_max_pathname
			THEN RETURN_ERROR(.msg_vect,dbg$_pathtlong);
			!+
			! Now coalesce the two pathname descriptors to obtain
			! a pathname descriptor for the qualified data name.
			!-
			DECR index FROM .pathname[pth$b_totcnt]-1 TO 0 DO
			    name[.index+.new_count] = .name[.index];
			ch$move(4*(.new_count+2)-1,.ref_path+1,pathname+1);
			pathname[pth$b_totcnt] = .pathname[pth$b_totcnt]+.new_count;
			ref_path = pathname;
			END
		    ELSE
			BEGIN
			LOCAL argd : dbg$stg_desc;
			!+
			! Error detected in qualified data reference. Set up
			! a descriptor to the erroneous lexeme and return an
			! error message saying pathname is invalid.
			!-
			argd[dsc$a_pointer] = .input_desc[dsc$a_pointer];
			argd[dsc$w_length]  = ch$diff(.pointer,.input_desc[dsc$a_pointer]);
			RETURN_ERROR(.msg_vect,dbg$_invpath,argd);
			END;
		    END;
		END;

	    !+
	    !  At this point we have built a pathname descriptor for the data
	    ! reference and any qualifiers supplied. We now search the symbol
	    ! table to obtain a SYMID for the data item,  and return an error
	    ! message if the symbol is undefined or not unique.
	    !-
	    dbg$sta_getsymbol(.ref_path,prim_symid,prim_kind);
	    IF .prim_symid EQL 0
	    THEN
		BEGIN
		LOCAL pathname_string,error_code;

		dbg$ncob_pathdesc_to_cs(.ref_path,pathname_string);
		error_code =(IF .prim_kind EQL rst$k_notunique
			     THEN dbg$_nounique ELSE dbg$_nosymbol);
		RETURN_ERROR(.msg_vect,.error_code,.pathname_string);
		END;

	    !+
	    ! If this is a reference to a data item (i.e not a label or line
	    ! number) we now need to find out how many subscripts are needed
	    ! for a reference to this variable. This means checking not only
	    ! this data item but also all "ancestors" of the data item, as a
	    ! COBOL data reference has all subscripts given on the last item.
	    !-
	    IF .prim_kind EQL rst$k_data
	    THEN
		BEGIN
		LOCAL symid;
		!+
		! Before calling any of the symbol table access routines to
		! obtain "type" information we need to establish a context.
		!-
		dbg$sta_setcontext(.prim_symid);
		symid = .prim_symid;
		!+
		! Now loop for data item and all ancestors.
		!-
		WHILE .symid NEQ 0 DO
		    BEGIN
		    !+
		    ! Obtain "type" information about this data item, and
		    ! dispatch to the relevant portion of code.
		    !-
		    dbg$sta_symtype(.symid,fcode,typeid);
		    CASE .fcode FROM rst$k_type_minimum TO rst$k_type_maximum OF
			SET
			[rst$k_type_atomic,rst$k_type_pict,rst$k_type_record] :
			    !+
			    ! Nothing to do for simple types.
			    !-
			    0;

			[rst$k_type_array] :
			    BEGIN
			    LOCAL type,dims,bits,dvec : REF VECTOR[,LONG];
			    !+
			    ! Array. Check the array elements are byte-aligned.
			    !  If so, increment number of subscripts expected.
			    !-
			    dbg$sta_typ_array(.typeid,desc,type,dims,dvec,bits);
			    DECR d from .dims-1 TO 0 DO IF (.dvec[.d] NEQ 0)
			      THEN RETURN_ERROR(.msg_vect,dbg$_unimplent);
			    subscript_count = .subscript_count + .dims;
			    END;


			[rst$k_type_descr] :
			    BEGIN
			    !+
			    ! Variable is described by a VAX/VMS descriptor.
			    !-
			    dbg$sta_typ_descr(.typeid,desc);
			    IF (.desc[dsc$b_class] NEQ dsc$k_class_s
						AND
				.desc[dsc$b_class] NEQ dsc$k_class_d
						AND
				.desc[dsc$b_class] NEQ dsc$k_class_sd)
			    THEN
				RETURN_ERROR(.msg_vect,dbg$_unimplent);
			    END;

			[INRANGE,OUTRANGE] :
			    RETURN_ERROR(.msg_vect,dbg$_unimplent);
			TES;

		    symid = dbg$sta_symparent(.symid);
		    END;
		END;

	    !+
	    ! We now know hom many subscripts to expect on this data item.
	    ! Call dbg$ncob_make_desc to construct a prototype COBOL primary
	    ! descriptor with enough space for the subscripts, and fill in
	    ! the primary_symid, primary_kind & subscript_count fields, and
	    ! set up a VAX/VMS descriptor (for dbg$ncob_type_conv) to point
	    ! to the subscript vector in the primary descriptor.
	    !-
	    .result_type = dbg$k_primary_desc;
	    result_desc  = dbg$ncob_make_desc(dbg$k_primary_desc,.subscript_count+2);
	    result_desc[cob_primary_symid]   = .prim_symid;
	    result_desc[cob_primary_kind]    = .prim_kind;
	    result_desc[cob_subscript_count] = .subscript_count;
	    subscript[dsc$b_class]   = dsc$k_class_s;
	    subscript[dsc$b_dtype]   = dsc$k_dtype_l;
	    subscript[dsc$w_length]  = 4;
	    subscript[dsc$a_pointer] = result_desc[cob_subscript_vector];
	    !+
	    !  If we expect subscripts loop, calling dbg$ncob_exp_int to get
	    ! the value of each subscript, and calling dbg$ncob_type_conv to
	    ! store the (longword) subscript value in the primary descriptor.
	    !-
	    IF .subscript_count NEQ 0
	    THEN
		BEGIN
		LOCAL	value_ptr	: REF dbg$ncob_descriptor;
		!+
		! Initialize the expected delimiter to '(', then loop,
		! evaluating each subscript in turn.
		!-
		target_lexeme = lexical_char + '(';
		INCR index FROM 0 TO .subscript_count-1 DO
		    BEGIN
		    !+
		    ! First check that we have the expected delimiter
		    !  ["(" for the first subscript, "," otherwise].
		    !-
		    dbg$ncob_get_lexeme(local_desc);
		    IF .target_lexeme NEQ .token_kind
		    THEN
			BEGIN
			IF .token_kind EQL lexical_char + ')' OR .index EQL 0
			THEN
			    RETURN_ERROR(.msg_vect,dbg$_invaccess,
					 .subscript_count,.index)
			ELSE
			    RETURN_ERROR(.msg_vect,dbg$_notcomma,token_desc);
			END;

		    dbg$ncob_advance(local_desc,token_desc);
		    target_lexeme = lexical_char + ',';
		    !+
		    ! Call dbg$ncob_exp_int to evaluate a subscript expression.
		    ! N.B. subscripts are evaluated as DECIMAL, ignoring radix.
		    ! Note that a "success" return from dbg$ncob_exp_int is an
		    ! error, as this means that the input line was exhausted.
		    !+
		    SELECTONE dbg$ncob_exp_int(local_desc,dbg$k_decimal,value_ptr,.msg_vect)
		     OF SET
			[sts$k_severe] :
			    RETURN sts$k_severe;
			[sts$k_success] :
			    RETURN_ERROR(.msg_vect,dbg$_needmore);
			[sts$k_warning] :
			    !+
			    ! Call dbg$ncob_type_conv to convert subscript to
			    ! a longword integer value (stored in the primary
			    ! descriptor), and step to next subscript address.
			    !-
			    IF dbg$ncob_type_conv(.value_ptr,dbg$k_decimal,
					dbg$k_vax_desc,subscript,.msg_vect)
			    THEN
				subscript[dsc$a_pointer] = .subscript[dsc$a_pointer] + 4
			    ELSE
				RETURN sts$k_severe;
			TES;
		    END;
		!+
		! Collected enough subscripts. Check that the next lexical
		! token is the ")" to terminate the subscript list.
		!-
		IF NOT dbg$ncob_more_input(local_desc,.msg_vect) THEN RETURN sts$k_severe;
		IF .token_kind NEQ lexical_char + ')'
		THEN
		    IF .token_kind EQL lexical_char + ','
		    THEN
			RETURN_ERROR(.msg_vect,dbg$_invaccess,
				     .subscript_count,.subscript_count+1)
		    ELSE
			RETURN_ERROR(.msg_vect,dbg$_notrparen,token_desc);
		dbg$ncob_advance(local_desc,token_desc);
		END;

	    !+
	    ! Check for data type of ASCII text, which can have sub-strings.
	    !-
	    IF .prim_kind EQL rst$k_data
	    THEN
		BEGIN
		LOCAL data_type,dummy;
		data_type = 0;
		!+
		! Obtain the format code and typeid for this data item,
		! and get the VAX/VMS dtype code for the data type.
		!-
		dbg$sta_symtype(.prim_symid,fcode,typeid);
		IF .fcode EQL rst$k_type_array
		THEN
		    BEGIN
		    LOCAL cell_type,dims,bits;
		    dbg$sta_typ_array(.typeid,desc,cell_type,dims,dummy,bits);
		    dbg$sta_symtype(.cell_type,fcode,typeid);
		    END;
		SELECTONE .fcode OF
		    SET
		    [rst$k_type_pict,rst$k_type_record] :
			data_type = dsc$k_dtype_t;
		    [rst$k_type_atomic] :
			dbg$sta_typ_atomic(.typeid,data_type,dummy);
		    [rst$k_type_descr] :
			BEGIN
			dbg$sta_typ_descr(.typeid,desc);
			data_type = .desc[dsc$b_dtype];
			END;
		    TES;
		!+
		! If the data-type is dsc$k_dtype_t (ASCII text) and the next
		! character is an opening parenthesis then check for a string
		! subscripting reference of the form (start:length).
		! N.B. This format is NOT the same as the old style DEBUG way
		!      of referring to substrings which was (start:finish).
		!-
		dbg$ncob_get_lexeme(local_desc);
		IF .data_type EQL dsc$k_dtype_t
				AND
		   .token_kind EQL lexical_char + '('
		THEN
		    BEGIN
		    dbg$ncob_advance(local_desc,token_desc);
		    target_lexeme = lexical_char + ':';

		    WHILE true DO
			BEGIN
			LOCAL value_ptr : REF dbg$ncob_descriptor;
			!+
			!   Call dbg$ncob_exp_int to evaluate the substring
			! parameters.  Note that the only check here is for
			! a value of zero - fuller checking will be done by
			! dbg$ncob_make_val_desc.
			!-
			SELECTONE dbg$ncob_exp_int(local_desc,dbg$k_decimal,value_ptr,.msg_vect)
			 OF SET
			    [sts$k_severe] :
				RETURN sts$k_severe;
			    [sts$k_success] :
				RETURN_ERROR(.msg_vect,dbg$_needmore);
			    [sts$k_warning] :
				IF dbg$ncob_type_conv(.value_ptr,dbg$k_decimal,
						       dbg$k_vax_desc,
						       subscript,.msg_vect)
				THEN
				    BEGIN
				    IF ..subscript[dsc$a_pointer] NEQ 0
				    THEN
					subscript[dsc$a_pointer] = .subscript[dsc$a_pointer] + 4
				    ELSE
					IF .target_lexeme EQL lexical_char + ':'
					THEN
					    BEGIN
					    LOCAL name_string;
					    dbg$sta_symname(.prim_symid,
							    name_string);
					    RETURN_ERROR(.msg_vect,
							 dbg$_badsubscript,
							 0,.name_string);
					    END
					ELSE
					    RETURN_ERROR(.msg_vect,dbg$_nullstrng);
				    END
				ELSE
				    RETURN sts$k_severe;
			    TES;

			!+
			! Check that we have the expected delimiter at the end
			! of the expression.
			!-
			IF NOT dbg$ncob_more_input(local_desc,.msg_vect)
			  THEN RETURN sts$k_severe;
			IF .target_lexeme EQL .token_kind
			THEN
			    BEGIN
			    dbg$ncob_advance(local_desc,token_desc);
			    IF .target_lexeme EQL lexical_char + ':'
			    THEN
				BEGIN
				!+
				! COBOL allows references of the form (START:)
				! which means from START to last character.
				!-
				target_lexeme  =  lexical_char + ')';
				dbg$ncob_get_lexeme(local_desc);
				IF .token_kind EQL .target_lexeme
				THEN
				    BEGIN
				    dbg$ncob_advance(local_desc,token_desc);
				    EXITLOOP;
				    END;
				END
			    ELSE
				EXITLOOP;
			    END
			ELSE
			    !+
			    ! Allow just a single reference (a character
			    ! subscript).
			    !-
			    IF .target_lexeme EQL lexical_char + ':'
					    AND
			       .token_kind EQL lexical_char + ')'
			    THEN
				.subscript[dsc$a_pointer] = 1
			    ELSE
				RETURN_ERROR(.msg_vect,dbg$_invexpr,token_desc);
			END;
		    END;
		END;
	    END;
	END

    ELSE	! First token is not a pathname reference
	BEGIN
	!+
	! We get here if the pathname parser failed to parse a data reference.
	! We now need to check for the DEBUG pseudo-symbol \ (last value), and
	! for numeric literals.
	! The first action to take is to restore our copy of the command line
	! pointers (as they may have been altered by the pathname parser), and
	! to scan the first lexical token.
	!-
	ch$move(8,.input_desc,local_desc);
	dbg$ncob_get_lexeme(local_desc);

	IF .token_kind EQL '\'
	THEN
	    BEGIN
	    !+
	    ! If this is the DEBUG pseudo-symbol "\" we call dbg$nget_lastval
	    ! to obtain a value descriptor.
	    !-
	    LOCAL last_value : REF dbg$ncob_descriptor;
	    IF NOT dbg$nget_lastval(last_value,.msg_vect) THEN RETURN sts$k_severe;
	    result_desc = dbg$get_tempmem(.last_value[dbg$w_dhead_length]/%UPVAL);
	    ch$move(.last_value[dbg$w_dhead_length],.last_value,.result_desc);
	    result_desc[cob_value_pointer] = result_desc[cob_value_address];
	    .result_type = dbg$k_value_desc;
	    dbg$ncob_advance(local_desc,token_desc);
	    END
	ELSE
	    BEGIN
	    !+
	    ! Call dbg$ncob_numeric_token to see if we have a numeric literal.
	    !-
	    SELECTONE dbg$ncob_numeric_token(local_desc,.radix,.msg_vect) OF
		SET
		[sts$k_success] :
		    BEGIN
		    .result_type = dbg$k_literal;
		    result_desc =.numeric_value;
		    dbg$ncob_advance(local_desc,numeric_desc);
		    END;
		[sts$k_severe] :
		    RETURN sts$k_severe;
		[OTHERWISE] :
		    RETURN sts$k_error;
		TES;
	    END;
	END;

    !+
    ! At this point we have successfully parsed a complete COBOL primary.
    ! Store a pointer to the result in the formal parameter, and return a
    ! completion code of sts$k_success or sts$k_warning (sts$k_warning if
    ! there is still more input available on the command line).
    ! It is at this point that we update the command line pointers passed
    ! as parameters to reflect the amount of the command line accepted.
    !-
    .result = .result_desc;

    dbg$ncob_get_lexeme(local_desc);
    IF .token_kind EQL %X'0D' THEN dbg$ncob_advance(local_desc,token_desc);

    ch$move(8,local_desc,.input_desc);

    RETURN (.local_desc[dsc$w_length] EQL 0);

    END;		! end of routine dbg$ncob_prim_int

GLOBAL ROUTINE DBG$NCOB_EXP_INT (input_desc, radix, value_ptr, msg_vect) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Evaluates source language expressions, with certain DEBUG extensions, 
!	which occur in DEBUG commands. Expressions are defined to be source
!	language constructs which may appear on the right hand side of an
!	assignment statement. A language specific value descriptor is con-
!	structed to describe the value of the expression. This value descriptor
!	must be marked (within the language independent header portion)
!	as to whether the value descriptor is to be considered volatile or
!	non-volatile. This is done by writing the value of dbg$k_value_desc
!	(non-volatile) or dbg$k_v_value_desc (volatile) into the type field.
!
!	Non-volatile value descriptors will be stored to represent the DEBUG
!	psuedo symbol '\', 'last value'. Volatile value descriptors will not.
!
!	A maximal initial substring of the input string is parsed. The input
!	string descriptor is updated to reflect one character beyond the last
!	character accepted.
!
!	DEBUG extensions to source language expressions include the use of the
!	following as expression operands:
!
!	1) DEBUG permanent symbols R0-R11, AP, SP, PC, PSL. If the language
!	   allows explicit operations on registers, then the use of these symbols
!	   overrides user defined symbolic references with the same name, unless
!	   an explicit pathname is specified such as MODULE\ROUTINE\R5. If the
!	   source language does not allow explicit operations on registers, then
!	   a register name must be preceeded with '%', such as %R5, to be re-
!	   cognized. Otherwise the symbol wil be assumed to be a user defined
!	   symbolic reference.
!
!	2) The DEBUG pseudo-symbol '\'. This symbol stands for 'last value'
!	   as represented by the stored value descriptor corresponding to the
!	   value of the last expression EVALUATEd. The 'last value' value descriptor
!	   will be obtained by a call to dbg$nget_lastval.
!
!	   Note that other DEBUG pseudo-symbols are NOT allowed in an expression.

!
! FORMAL PARAMETERS:
!
!	input_desc  -	the address of a VAX standard string descriptor which
!			describes the input string
!
!	radix	    -	a longword containing an unsigned integer encoding of the
!			radix to be used in the evaluation of numeric literals
!			appearing in the input string as follows:
!
!		dbg$k_default	(1)	- source language default radix
!
!		dbg$k_binary	(2)	- binary
!
!		dbg$k_octal	(8)	- octal
!
!		dbg$k_decimal	(10)	- decimal
!
!		dbg$k_hex	(16)	- hexadecimal
!
!	value_ptr    -	the address of a longword to contain the address of a
!			language specific value descriptor upon return
!
!	msg_vect -	the address of a longword to contain the address of a
!			message argument vector as described on page 4-119 of
!			the VAX/VMS system reference manual, volume 1A
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	In case of a success or warning return, a language specific value 
!	descriptor is constructed from dynamic storage. Value_ptr is set to
!	contain the address of this descriptor.
!
!	In case of a severe error return, a message argument vector is 
!	constructed from dynamic storage and msg_vect is set to contain the
!	beginning address of the vector.

!
! ROUTINE VALUE:
!
!	unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) -	A value descriptor was constructed and 
!				returned. No unfamilar input was encountered.
!				Input string exhausted.
!
!	STS$K_WARNING (0) 	A value descriptor was constructed and
!				returned. Unfamiliar input encountered. 
!
!				Note that some DEBUG commands allow expression
!				lists where each expression is seperated by
!				commas. In these cases (or whenever unfamilar input
!				is encountered), this return should be 
!				used.
!
!	STS$K_SEVERE  (4) -	No value descriptor constructed. Message ar-
!				gument vector constructed and returned. Fatal
!				syntax or semantic error encountered. No input 
!				accepted.
!
!				Note that the input string descriptor fields
!				should be returned to their initial (on input)
!				values even though some characters (but not a
!				complete expression string) have been accepted.
!
! SIDE EFFECTS:
!
!	Informational messages such as number or string truncation may be 
!	issued by this routine.
!
!	The VAX standard string descriptor which describes the input string
!	is updated to reflect one character beyond the last character accepted.
!
!--

!dbg$ncob_exp_int (input_desc, radix, value_ptr, msg_vect)
    BEGIN
    !
    ! Describe formal parameters that are structures
    !
    MAP	input_desc   : REF dbg$stg_desc;	! Pointer to input
    !
    !
    !
    ! Declare routine-level local variables
    !
    LOCAL
	local_desc	: dbg$stg_desc,		! Copy of command line pointer.
	signed_flag,				! Set if unary operator seen.
	negate_flag,				! Set if unary operator is -.
	exp_desc	: REF dbg$ncob_descriptor,
	op_stack	: VECTOR [2,LONG],	! Operator Stack
	ev_stack	: VECTOR [2,LONG],	! Operand  Stack
	stack_depth,				! Number of terms stacked
	temp_value;
    BIND
	ps_desc = exp_desc : REF dbg$permsd,	! Permanent Symbol Descriptor
	result_value = exp_desc;		! For returned literal values


    !+
    !
    ! The current pointers to the input command line must be preserved,
    ! as they must be returned to their initial state when an error is
    ! encountered.  Rather than saving the initial state and restoring
    ! it on an error we take a local copy of the command line pointers
    ! for use within the routine, and only update the command pointers
    ! if the routine completes successfully.
    !
    !-

    ch$move(8,.input_desc,local_desc);

    stack_depth = 0;

    WHILE true DO
	BEGIN
	!+
	! First check for leading unary plus or minus.
	!-
	dbg$ncob_get_lexeme(local_desc);
	signed_flag = .token_kind EQL lexical_char + '+'
				    OR
		      .token_kind EQL lexical_char + '-';
	IF .signed_flag
	THEN
	    BEGIN
	    negate_flag = .token_char EQL '-';
	    dbg$ncob_advance(local_desc,token_desc);
	    END;

	IF NOT dbg$ncob_more_input(local_desc,.msg_vect) THEN RETURN sts$k_severe;

	IF (.token_kind EQL lexical_char+'\') OR (.token_kind EQL lexical_char+'.')
	  THEN token_kind = lexical_symbol+1;

	SELECTONE .token_type OF
	    SET
	    [lex_type_string] :
		BEGIN
		LOCAL quote,len_1,len_2,ptr_1,ptr_2;

		exp_desc = dbg$ncob_make_desc(dbg$k_value_desc,(.token_code+11)/4);
		exp_desc[cob_value_dschead] = dsc$k_class_s^24+dsc$k_dtype_t^16+.token_code;
		exp_desc[cob_value_pointer] = exp_desc[cob_value_address];

		quote = ch$rchar(.token_desc[dsc$a_pointer]);
		len_1 = .token_desc[dsc$w_length];
		ptr_1 = .token_desc[dsc$a_pointer];
		ptr_2 = ch$ptr(exp_desc[cob_value_address]);
		WHILE .len_1 GTR 0 DO
		    BEGIN
		    len_1 = .len_1 - 1;
		    ptr_1 = ch$plus(.ptr_1,1);
		    len_2 = ch$diff(ch$find_ch(.len_1,.ptr_1,.quote),.ptr_1);
		    len_1 = .len_1 - .len_2 - 1;
		    IF .len_1 NEQ 0 THEN len_2 = .len_2 + 1;
		    ch$move(.len_2,.ptr_1,.ptr_2);
		    ptr_1 = ch$plus(.ptr_1,.len_2);
		    ptr_2 = ch$plus(.ptr_2,.len_2);
		    END;
		dbg$ncob_advance(local_desc,token_desc);
		END;

	    [lex_type_char] :
		BEGIN
		IF .token_char EQL '('
		THEN
		    BEGIN
		    dbg$ncob_advance(local_desc,token_desc);
		    CASE dbg$ncob_exp_int(local_desc,.radix,exp_desc,.msg_vect)
		      FROM sts$k_warning TO sts$k_severe OF
			SET
			[sts$k_severe] :
			    RETURN sts$k_severe;
			[sts$k_success] :
			    RETURN_ERROR(.msg_vect,dbg$_needmore);
			[sts$k_warning] :
			    BEGIN
			    dbg$ncob_get_lexeme(local_desc);
			    IF .token_kind EQL lexical_char + ')'
			    THEN
				dbg$ncob_advance(local_desc,token_desc)
			    ELSE
				RETURN_ERROR(.msg_vect,dbg$_notrparen,token_desc);
			    END;
			[INRANGE,OUTRANGE] :
			    REPORT_BUG(.msg_vect,dbg$k_illegal_return_value);
			TES;
		    IF NOT dbg$ncob_force_to_numeric(exp_desc,.msg_vect) THEN RETURN sts$k_severe;
		    END
		ELSE
		    RETURN_ERROR(.msg_vect,dbg$_invexpr,token_desc);
		END;

	    [OTHERWISE] :		! Numeric value or primary expression
		BEGIN
		SELECTONE dbg$ncob_prim_int(local_desc,temp_value,
					    exp_desc,.radix,.msg_vect)
		 OF SET
		    [sts$k_success,sts$k_warning] :
			BEGIN
			SELECTONE .temp_value OF
			    SET
			    [dbg$k_perm_desc,dbg$k_literal] :
				BEGIN
				LOCAL literal_value,literal_dtype;
				IF .temp_value EQL dbg$k_literal
				THEN
				    BEGIN
				    literal_value = .result_value;
				    literal_dtype = dsc$k_dtype_lu;
				    END
				ELSE
				    BEGIN
				    literal_value = .(.ps_desc[dbg$l_permsd_addr]);
				    literal_dtype = dsc$k_dtype_l;
				    END;
				exp_desc = dbg$ncob_make_desc(dbg$k_value_desc,3);
				exp_desc[cob_value_dschead] = dsc$k_class_sd^24+4;
				exp_desc[cob_value_pointer] = exp_desc[cob_value_address];
				exp_desc[cob_value_literal] = .literal_value;
				exp_desc[cob_value_dtype]   = .literal_dtype;
				END;
			    [dbg$k_primary_desc] :
				BEGIN
				IF .exp_desc[cob_primary_kind] NEQ rst$k_data
				  THEN RETURN_ERROR(.msg_vect,dbg$_novalue);
				IF NOT dbg$ncob_make_val_desc(.exp_desc,false,
							       exp_desc,.msg_vect)
				  THEN RETURN sts$k_severe;
				END;
			    TES;
			END;

		    [sts$k_error] :	! Not a Primary - could be a number !
			BEGIN
			SELECTONE dbg$ncob_numeric_token(local_desc,.radix,.msg_vect)
			 OF SET
			    [sts$k_warning] :
				IF NOT dbg$ncob_make_packed_desc(numeric_desc,exp_desc,.msg_vect)
				THEN
				    RETURN sts$k_severe
				ELSE
				    dbg$ncob_advance(local_desc,numeric_desc);
			    [sts$k_error] :
				BEGIN
				dbg$ncob_get_lexeme(local_desc);
				RETURN_ERROR(.msg_vect,dbg$_invexpr,token_desc);
				END;
			    [OTHERWISE] :
				REPORT_BUG(.msg_vect,dbg$k_illegal_return_value);
			    TES;
			END;
		    [sts$k_severe] :
			RETURN sts$k_severe;
		    [OTHERWISE] :
			REPORT_BUG(.msg_vect,dbg$k_illegal_return_value);
		    TES;
		END;
	    TES;

	IF .signed_flag THEN
	    BEGIN
	    IF NOT dbg$ncob_force_to_numeric(exp_desc,.msg_vect) THEN RETURN sts$k_severe;
	    IF .negate_flag THEN SELECTONE .exp_desc[cob_value_dtype] OF
		SET
		[dsc$k_dtype_b] :
		    exp_desc[cob_value_byte] = -.exp_desc[cob_value_byte];
		[dsc$k_dtype_w] :
		    exp_desc[cob_value_word] = -.exp_desc[cob_value_word];
		[dsc$k_dtype_l] :
		    exp_desc[cob_value_long] = -.exp_desc[cob_value_long];
		[dsc$k_dtype_q] :
		    BEGIN
		    exp_desc[cob_value_high] = NOT .exp_desc[cob_value_high];
		    exp_desc[cob_value_long] =  -  .exp_desc[cob_value_long];
		    IF .exp_desc[cob_value_long] EQL 0 THEN
		      exp_desc[cob_value_high] = 1+.exp_desc[cob_value_high];
		    END;
		[dsc$k_dtype_p] :
		    BEGIN
		    BIND vmsdsc = exp_desc[cob_value_vmsdesc] : BLOCK[8,BYTE];
		    LOCAL sign_ptr : REF BITVECTOR[1];

		    sign_ptr = .vmsdsc[dsc$a_pointer]+(.vmsdsc[dsc$w_length]/2);
		    sign_ptr[0] = NOT .sign_ptr[0];
		    END;
		TES;
	    END;

	IF .stack_depth GTR 0 THEN
	  IF NOT dbg$ncob_force_to_numeric(exp_desc,.msg_vect) THEN RETURN sts$k_severe;

	CASE .stack_depth FROM 0 TO 2 OF
	    SET
	    [0]: stack_depth = .stack_depth + 1;

	    [1]: IF .op_stack[0] LSS 2 THEN stack_depth = .stack_depth + 1 ELSE
		  exp_desc = dbg$ncob_evaluate(.ev_stack[0],.exp_desc,.op_stack[0]);

	    [2]: IF .op_stack[1] GTR 1
		 THEN
		     exp_desc = dbg$ncob_evaluate(.ev_stack[1],.exp_desc,.op_stack[1])
		 ELSE
		     BEGIN
		     ev_stack[0] = dbg$ncob_evaluate(.ev_stack[0],.ev_stack[1],.op_stack[0]);
		     op_stack[0] = .op_stack[1];
		     END;
	    TES;

	ev_stack[.stack_depth-1] = .exp_desc;

	dbg$ncob_get_lexeme(local_desc);
	IF .token_type NEQ lex_type_char THEN EXITLOOP;
	temp_value = ch$find_ch(4,ch$ptr(operator_list),.token_char);
	IF ch$fail(.temp_value) THEN EXITLOOP;
	op_stack[.stack_depth-1] = ch$diff(.temp_value,ch$ptr(operator_list));
	IF NOT dbg$ncob_force_to_numeric(ev_stack[.stack_depth-1],.msg_vect)
	  THEN RETURN sts$k_severe;
	dbg$ncob_advance(local_desc,token_desc);
	END;

    .value_ptr = (IF .stack_depth EQL 1 THEN .ev_stack[0] ELSE
		  dbg$ncob_evaluate(.ev_stack[0],.ev_stack[1],.op_stack[0]));

    IF .token_kind EQL %X'0D' THEN dbg$ncob_advance(local_desc,token_desc);
    ch$move(8,local_desc,.input_desc);

    RETURN (.local_desc[dsc$w_length] EQL 0);
    END;		! end of routine dbg$ncob_exp_int

ROUTINE dbg$ncob_get_token(input_desc,output_desc,token) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is the interface between the pathname parser and
!	the COBOL lexical analysis routines.
!
! FORMAL PARAMETERS:
!
!	input_desc	The address of a VAX standard string descriptor
!			which points to the current DEBUG command line.
!
!	output_desc	The address of a VAX standard string descriptor
!			to be set to the portion of the command scanned
!
!	token		The address of a longword to recieve one of the
!			following codes :-
!
!		dbg$k_tok_null	- end of command
!
!		dbg$k_tok_dot	- first non-blank character is "."
!
!		dbg$k_tok_bs	- first non-blank character is "\"
!
!		dbg$k_tok_reg	- register name (e.g. %R0, %AP, %PSL)
!
!		dbg$k_tok_line	- %LINE
!
!		dbg$k_tok_label	- %LABEL
!
!		dbg$k_tok_qname	- %NAME
!
!		dbg$k_tok_int	- integer (N.B. 32-bit maximum)
!
!		dbg$k_tok_id	- identifier
!
!		dbg$k_tok_inval	- anything else
!--

    BEGIN
    LITERAL eol = %X'0D';

    IF dbg$ncob_get_lexeme(.input_desc)
    THEN
	BEGIN
	ch$move(8,token_desc,.output_desc);

	.token = (CASE .token_type FROM lex_type_minimum TO lex_type_maximum OF
	    SET
	    [lex_type_char]:
		SELECTONE .token_char OF
		    SET

		    [eol]:	dbg$k_tok_null;

		    ['.']:	dbg$k_tok_dot;

		    ['\']:	dbg$k_tok_bs;

		    [OTHERWISE]:dbg$k_tok_inval;

		    TES;


	    [lex_type_symbol]:	dbg$k_tok_id;

	    [lex_type_number]:	dbg$k_tok_int;

	    [lex_type_string]:	dbg$k_tok_inval;

	    [lex_type_word]:	.token_code;

	    [lex_type_reg]:	dbg$k_tok_reg;

	    [INRANGE,OUTRANGE]:	dbg$k_tok_inval;

	    TES);
	END


    ELSE .token = dbg$k_tok_null;

    END;		! end of routine dbg$ncob_get_token

ROUTINE dbg$ncob_get_lexeme(input_desc) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	 This routine is the main COBOL lexical analysis routine. It scans
!	the current DEBUG command line, and processes a single lexeme at a
!	time according to COBOL lexical rules (with DEBUG extensions).
!
! FORMAL PARAMETERS:
!
!	input_desc	The address of a VAX standard string descriptor
!			which points to the current DEBUG command line.
!
!	skip_flag	A logical flag (passed by value), which is TRUE
!			if leading blanks are to be ignored.
!
!	hyphen_flag	A logical flag (passed by value), which is TRUE
!			if hyphens are to be recognized
!
!	N.B. both these flags are optional parameters which default to TRUE!
!
! COMPLETION CODES:
!
!	sts$k_success	(1)	lexeme scanned
!
!	sts$k_warning	(0)	no non-blank characters in command
!
! SIDE EFFECTS:
!
!	On a successful return the module-level OWN variables
!	token_kind and token_desc will be updated to indicate
!	the kind of lexeme scanned.
!
!--

    BEGIN
    BUILTIN ACTUALCOUNT,ACTUALPARAMETER;
    MAP input_desc	: REF dbg$stg_desc;

    LOCAL length,pointer,character,skip_flag,hyphen_flag;

    skip_flag   = (IF actualcount() GTR 1 THEN ACTUALPARAMETER(2) ELSE true);
    hyphen_flag = (IF actualcount() GTR 2 THEN ACTUALPARAMETER(3) ELSE true);

    length  = .input_desc[dsc$w_length];
    pointer = .input_desc[dsc$a_pointer];
    IF .skip_flag THEN DECR index FROM .length-1 DO
	BEGIN
	IF ch$rchar(.pointer) NEQ %C' ' THEN EXITLOOP;
	length  = .length  - 1;
	pointer = .pointer + 1;
	END;
    IF .length LEQ 0 THEN RETURN (token_kind = 0);

    token_desc[dsc$w_length]  = .length;
    token_desc[dsc$a_pointer] = .pointer;

    character = ch$rchar(.pointer);

    IF .alphanumeric[.character] AND .character NEQ '-'
    THEN
	BEGIN
	LABEL scan;
	WHILE ((.alphanumeric[.character] OR (.character EQL '_'))
	  AND  (.hyphen_flag              OR (.character NEQ '-'))
	  AND  (.length GTR 0)) DO
	    BEGIN
	    length  = .length  - 1;
	    pointer = .pointer + 1;
	    character = ch$rchar(.pointer)
	    END;
	length = .token_desc[dsc$w_length] - .length;
	IF ch$rchar(ch$plus(.token_desc[dsc$a_pointer],.length-1)) EQL '-'
	  THEN length = .length - 1;
	token_desc[dsc$w_length] = .length;

     scan : BEGIN
	    token_kind = lexical_symbol + .length;
	    pointer = .token_desc[dsc$a_pointer];
	    INCR index FROM 1 TO .length DO
		BEGIN
		character = ch$rchar_a(pointer);
		IF .character LSS '0' OR .character GTR '9' THEN LEAVE scan;
		END;
	    token_kind = lexical_number + .length;
	    END
	END

    ELSE		! Not an alphanumeric character
	BEGIN
	LABEL string,number;
	token_desc[dsc$w_length]  = .token_desc[dsc$w_length] - 1;
	token_desc[dsc$a_pointer] = ch$plus(.token_desc[dsc$a_pointer],1);
	token_kind = lexical_char + .character;
	SELECTONE .character OF
	    SET
	    ['''','"'] :
	string:	BEGIN
		LOCAL strip,e_ptr,s_ptr,s_len;
		strip = 2;
		s_ptr = .pointer;
		s_len = .length;
		WHILE .s_len GTR 0 DO
		    BEGIN
		    e_ptr = ch$find_ch(.s_len-1,ch$plus(.s_ptr,1),.character);
		    IF ch$fail(.e_ptr) THEN LEAVE string;
		    s_len = .s_len-1-ch$diff(.e_ptr,.s_ptr);
		    s_ptr = ch$plus(.e_ptr,1);
		    IF .s_len EQL 0 OR ch$rchar(.s_ptr) NEQ .character THEN EXITLOOP;
		    strip = .strip+1;
		    END;
		token_desc[dsc$a_pointer] = .s_ptr;
		token_kind = lexical_string + ch$diff(.s_ptr,.pointer) - .strip;
		END;
	    ['^'] :
	number:	BEGIN
		LOCAL radix,digit_pointer,count;
		SELECTONE ch$rchar(.token_desc[dsc$a_pointer]) OF
		    SET
		    ['O'] : radix =  8;
		    ['D'] : radix = 10;
		    ['X'] : radix = 16;
		    [OTHERWISE] : LEAVE number;
		    TES;
		digit_pointer = ch$plus(.token_desc[dsc$a_pointer],1);
		count   = 0;
		DECR length FROM .token_desc[dsc$w_length]-1 TO 1 DO
		    BEGIN
		    IF ch$fail(ch$find_ch(.radix,ch$ptr(valid_digits),
					   ch$rchar_a(digit_pointer)))
		      THEN (IF .count EQL 0 THEN LEAVE number ELSE EXITLOOP);
		    count = .count+1;
		    END;
		token_desc[dsc$a_pointer] = ch$plus(.digit_pointer,-1);
		token_kind = lexical_number + .count + 2;
		END;	! end of block "number"

	    ['%'] :
		BEGIN
		token_kind =(SELECTONE true OF
		    SET
		    [dbg$nmatch(token_desc,UPLIT BYTE(4,'LINE'),2)] :	lexical_line;
		    [dbg$nmatch(token_desc,UPLIT BYTE(5,'LABEL'),2)] :	lexical_label;
		    [dbg$nmatch(token_desc,UPLIT BYTE(4,'NAME'),1)] :	lexical_qname;
		    [dbg$nmatch(token_desc,UPLIT BYTE(1,'R'),1)] :	lexical_reg+0;
		    [dbg$nmatch(token_desc,UPLIT BYTE(2,'AP'),2)] :	lexical_reg+dbg$k_ap;
		    [dbg$nmatch(token_desc,UPLIT BYTE(2,'FP'),2)] :	lexical_reg+dbg$k_fp;
		    [dbg$nmatch(token_desc,UPLIT BYTE(2,'SP'),2)] :	lexical_reg+dbg$k_sp;
		    [dbg$nmatch(token_desc,UPLIT BYTE(2,'PC'),2)] :	lexical_reg+dbg$k_pc;
		    [dbg$nmatch(token_desc,UPLIT BYTE(3,'PSL'),3)] :	lexical_reg+dbg$k_psl;
		    [OTHERWISE] :					lexical_char+'%';
		    TES);
		END;
	    TES;
	token_desc[dsc$w_length]  = ch$diff(.token_desc[dsc$a_pointer],.pointer);
	token_desc[dsc$a_pointer] = .pointer
	END;
    RETURN sts$k_success
    END;		! end of routine dbg$ncob_get_lexeme

ROUTINE dbg$ncob_more_input(input_desc,msg_vect) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine parses the next lexeme in the command line (by calling
!	dbg$ncob_get_lexeme), and also reports unexpected end-of-line.
!
! FORMAL PARAMETERS:
!
!	input_desc	- The address of a VAX standard string descriptor
!			  which points to the current DEBUG command line.
!
!	msg_vect	- The address of a longword to contain the address of a
!			  message argument vector as described on page 4-119 of
!			  the VAX/VMS system reference, volume 1A
!
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS	(1)	Lexeme scanned.
!
!	STS$K_SEVERE	(4)	No non-blank characters in command line.
!				Message argument vector constructed and
!				returned.
!
! SIDE EFFECTS:
!
!	On a successful return the module-level OWN variables token_kind and
!	token_desc will be updated to indicate	the kind of lexeme scanned.
!
!--
    BEGIN
    IF dbg$ncob_get_lexeme(.input_desc)
		    AND
	.token_kind NEQ lexical_char + %X'0D'
    THEN
	RETURN sts$k_success
    ELSE
	RETURN_ERROR(.msg_vect,dbg$_needmore);
    END;		! end of routine dbg$ncob_more_input

ROUTINE dbg$ncob_advance(input_desc,token_desc) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine advances the pointers to the current DEBUG command line
!	to reflect the current state of parsing of the command.
!
! FORMAL PARAMETERS:
!
!	input_desc	The address of a VAX standard string descriptor
!			which points to the current DEBUG command line.
!
!	token_desc	The address of a VAX standard string descriptor
!			which points to the last token scanned.
!--
    BEGIN
    MAP
	input_desc	: REF dbg$stg_desc,
	token_desc	: REF dbg$stg_desc;
    LOCAL length : WORD;

    length = .token_desc[dsc$w_length] + ch$diff(.token_desc[dsc$a_pointer],
						 .input_desc[dsc$a_pointer]);
    input_desc[dsc$w_length]  = .input_desc[dsc$w_length] - .length;
    input_desc[dsc$a_pointer] = ch$plus(.input_desc[dsc$a_pointer],.length)
    END;		! end of routine dbg$ncob_advance

ROUTINE dbg$ncob_numeric_token(input_desc,radix,msg_vect) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	%text%
!
! FORMAL PARAMETERS:
!
!	%text%
!
! IMPLICIT INPUTS.
!
!	%text%
!
! IMPLICIT OUTPUTS:
!
!	%text%
!
! ROUTINE VALUE:
!
!	%text%
!
! COMPLETION CODES:
!
!	%text%
!
! SIDE EFFECTS:
!
!	%text%
!--

    BEGIN
    LOCAL local_desc : dbg$stg_desc;
    ch$move(8,.input_desc,local_desc);

    dbg$ncob_get_lexeme(local_desc);
    IF (.token_type NEQ lex_type_number) AND (.token_kind NEQ lexical_char+'.')
     THEN RETURN sts$k_error;
    IF .token_kind EQL lexical_char+'.' THEN token_desc[dsc$w_length] = 0;
    ch$move(8,token_desc,numeric_desc);

    IF ch$rchar(.token_desc[dsc$a_pointer]) EQL '^'
    THEN
	BEGIN
	LOCAL string_length,string_pointer;
	BIND ROUTINE conversion_routine =
	  (SELECTONE ch$rchar(ch$plus(.token_desc[dsc$a_pointer],1)) OF
	    SET
	    ['O'] : lib$cvt_otb;
	    ['D'] : lib$cvt_dtb;
	    ['X'] : lib$cvt_htb;
	    TES);
	string_pointer = .token_desc[dsc$a_pointer] + 2;
	string_length  = .token_desc[dsc$w_length]  - 2;
	dbg$ncob_advance(local_desc,token_desc);
	dbg$ncob_get_lexeme(local_desc,false);
	IF .token_type EQL lex_type_number OR .token_type EQL lex_type_symbol
	THEN
	    BEGIN
	    numeric_desc[dsc$w_length]  = .numeric_desc[dsc$w_length]
					  + .token_desc[dsc$w_length];
	    RETURN_ERROR(.msg_vect,dbg$_invnumber,numeric_desc);
	    END;
	IF .token_type NEQ lex_type_char OR .token_kind EQL '.'
				OR
			.string_length LEQ 0
	THEN
	    RETURN_ERROR(.msg_vect,dbg$_imptermno,numeric_desc);

	RETURN (numeric_kind = conversion_routine(.string_length,
						  .string_pointer,
						   numeric_value));
	END

    ELSE	! No explicit radix operator
	BEGIN
	dbg$ncob_advance(local_desc,token_desc);
	dbg$ncob_get_lexeme(local_desc,false);
	IF .token_kind NEQ lexical_char+'.'
	THEN
	    BEGIN
	    BIND ROUTINE conversion_routine =(SELECTONE .radix OF
		SET
		[dbg$k_hex]:	lib$cvt_htb;
		[dbg$k_octal]:	lib$cvt_otb;
		[dbg$k_default,
		dbg$k_decimal]:	lib$cvt_dtb;
		[OTHERWISE]:
		    REPORT_BUG(.msg_vect,cob$k_radix);
		TES);
	    numeric_kind = conversion_routine(.numeric_desc[dsc$w_length],
					      .numeric_desc[dsc$a_pointer],
					       numeric_value);
	    IF .radix EQL dbg$k_decimal OR .radix EQL dbg$k_default
	    THEN
		numeric_kind = .numeric_kind AND (.numeric_value GEQ 0);
	    RETURN .numeric_kind;
	    END
	ELSE
	    BEGIN
	    numeric_desc[dsc$w_length] = .numeric_desc[dsc$w_length]+1;
	    dbg$ncob_advance(local_desc,numeric_desc);
	    dbg$ncob_get_lexeme(local_desc,false,false);
	    IF .token_type EQL lex_type_number
			OR
	    .token_type EQL lex_type_symbol
			OR
	    .token_kind EQL lexical_char+'.'
	    THEN
		BEGIN
		numeric_desc[dsc$w_length] = .numeric_desc[dsc$w_length]
					     + .token_desc[dsc$w_length];
		IF .token_type NEQ lex_type_number
		  THEN RETURN_ERROR(.msg_vect,dbg$_invnumber,numeric_desc);
		END;
	    IF .numeric_desc[dsc$w_length] EQL 1 THEN return sts$k_error;
	    numeric_kind = 2;
	    RETURN sts$k_warning;
	    END;
	END;
    END;	! end of routine dbg$ncob_numeric_token

END
ELUDOM
