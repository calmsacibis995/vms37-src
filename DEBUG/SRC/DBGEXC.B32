MODULE DBGEXC (	IDENT = 'V03-000') =
BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! FACILITY:	DEBUG
!
!++
! FUNCTIONAL DESCRIPTION:
!	EXCEPTION HANDLER FOR DEBUG FACILITY UNDER STARLET
!
! Version:	3.13
!
! History:
!	Author:
!		Carol Peters, 05 Oct 1976: Version 01
!
!	Modified by:
!		David Plummer, DLP 1 July 1980
!		John Francis, 7-April-1981
!		John Francis, 21-May-1981
!		Richard Title, 9-Sep-1981
!		Sid Maxwell, 3-Dec-1981
!
!+
! Revision history:
! 1.11	1-July-80	DLP	Modified command_proc to call the new debugger
!				control routine if dbg$gb_language > lang_basic
! 1.12	 7-APR-81	JF	Recognize DBG$_SUPERDEBUG condition
! 1.13	21-May-81	JF	Changed COBOL to new-style debugger
! 1.14	9-Sep-81	RT	Put in code to cause source to be printed
!				at breakpoints, steps, and watchpoints.
! 1.15	1-Oct-81	RT	Declared the exception handler dbg$final_handl
!				in the routine announce_trace. This is needed
!				in case the source display routines signal
!				an error.
! 1.16	3-Dec-81	SRM	Added IS_FAULT to check exception type, setting
!				DBG$V_AT_FAULT in run frame appropriately.
! 3.00	7-Dec-81	RT	Added handling of SS$_DBGOPCREQ exception
!				to the routine dbg$exc_handler. This exception
!				is used by the emulator to determine the 'real'
!				opcode that exists at a breakpoint.
! 3.01  7-Dec-81	RT	Deleted changes 1.01 through 1.10 from this list
! 3.02	8-Dec-81	RT	Restructured dbg$exc_handler so that there is
!				less overhead when DEBUG is just resignalling
!				a user exception.
! 3.03 16-Dec-81	RT	Changed handling of EXCEPTION BREAK so that
!				the exception is resignalled after the user
!				types GO.
!--

! TABLE OF CONTENTS
!--
FORWARD ROUTINE
	dbg$sho_optrace,			! Report on opcode tracing.
	dbg$set_optrace,			! init/set/cancel opcode tracing
	list_opcodes : NOVALUE,			! used by SHO_OPTRACE
	decrement_step,				! See if a whole step has been done.
	tbit_handler,				! validates tbit halt
	check_step,				! Check for stepping.
	reset_user,				! Start up user program
	announce_trace : NOVALUE,		! announce that the step count has
						! gone to zero.
	command_proc : NOVALUE,			! accepts a command from the user
	dbg$exc_handler,			! handles DEBUG set exception conditions
	dbg$exception_is_fault,			! if exception is fault, true
	DBG$PUTMSG : NOVALUE,			! checks exception type before calling SYS$PUTMSG
	report_msg : NOVALUE,			! outputs a message from system message file
	user_proc,				! controls command processing
    	type_pc_source: NOVALUE;		! Interface to DBG$SRC_TYPE_PC_SOURCE

!
! Require and Library files:
!

REQUIRE 'SRC$:DBGPROLOG.REQ';
REQUIRE 'SRC$:DBGGEN.REQ';
REQUIRE 'SRC$:COMTER.REQ';
REQUIRE 'SRC$:VAXOPS.REQ';
REQUIRE 'SRC$:BSTRUC.REQ';
REQUIRE 'SRC$:SYSSER.REQ';


EXTERNAL LITERAL dbg$gl_sup_or_test : WEAK;	! Switch for SUPERDEBUG or TEST debug

EXTERNAL ROUTINE
	dbg$ninitialize : NOVALUE,		! Initialize language specific context
	dbg$nsymbolize,				! Symbolize from primary descriptor
	dbg$pc_to_line,
	dbg$val_to_sym,
	dbg$init_step : NOVALUE,		! Reset step level to what is
	dbg$set_stp_lvl : NOVALUE,		!  needed at begin_of_command
	dbg$conv_r_50,				! Convert rad50 to ascii
	dbg$get_lineno,				! FORTRAN %line Stepping.
	dbg$cancel_bpt : NOVALUE,		! Delete a breakpoint
	DBG$IS_IT_ENTRY,			! MATCH ADDRESS TO ROUTINE SYMBOL.
	dbg$pseudo_prog,			! DBGSTART code to implement CALL
	dbg$fao_put : NOVALUE,			! build an output buffer full of data
	dbg$final_handl,			! call frame exception handler
	dbg$save_bpt : NOVALUE,			! sets a breakpoint
	dbg$find_bpt,				! searches for one breakpoint
	dbg$find_watch,				! identifies watchpoints and their pages
	dbg$freerelease,			! releases free storage
	dbg$freez,				! allocates free storage
	dbg$ins_decode,				! turn hex instruction into ASCII
	dbg$ins_opcodes,			! removes breakpoints and inserts opcodes
	dbg$out_message : NOVALUE,		! writes string descriptor message
						! to DBG$OUTPUT
	dbg$out_put : NOVALUE,			! output a buffer to output device
	dbg$out_num_val,			! outputs an absolute value
	dbg$out_sym_val : NOVALUE,		! Output numeric or symbolic values.
	dbg$out_typ_val,			! outputs typed value.
	dbg$pars_a_line,			! parses a line of input text
	dbg$ncontrol : NOVALUE,			! New debugger control routine
	dbg$rem_opcodes,			! inserts breakpoints in user code
	dbg$write_mem,				! Writes data to user program
	dbg$cis_remove,				! Remove a link from the cis
	dbg$cis_add,				! Add a link to the cis
	dbg$nprim_out,				! Outputs a primary descriptor value
	dbg$nget_length,			! Obtains a primary rvalue length
	dbg$nget_type,				! Obtains type of primary
	dbg$nget_lval,				! Obtains primary lvalue
	dbg$nformat_with_radix,			! Formats rvalue with hex or octal radix
	dbg$nmake_val_desc,			! Makes value descriptor from prim. desc
	dbg$ntype_conv,				! Type converter
	dbg$nget_radix,				! Returns user set radix
	dbg$nget_trans_radix,			! Returns translation of default radix
    	dbg$src_type_pc_source : NOVALUE,	! Outputs source line to terminal
	SYS$PUTMSG : ADDRESSING_MODE (GENERAL);	! system output message routine

BUILTIN
	PROBER,					! Probes address for read access
	FP;					! register 14

EXTERNAL
    	dbg$gb_exc_bre_flag: BYTE,		! Flag saying we are in an
    						!     exception break.
    	dbg$gb_go_arg_flag: BYTE,		! Flag saying whether there
    						!     is an argument to GO.
	dbg$gb_no_globals : BYTE,
	dbg$gl_asci_len,			! Length of string data.
	dbg$gb_opinfo : OPCODE_TBL,
	dbg$cp_out_str : REF VECTOR[,BYTE],	! pointer to current output buffer
	dbg$gb_exit_dbg: BYTE,			! exit flag
	dbg$gb_debug: BYTE,			! debug flag
	dbg$gb_stp_ptr : REF VECTOR [, BYTE],	! pointer to current STEP type
	dbg$gb_mod_ptr : REF VECTOR [, BYTE],	! pointer to current mode settings
	dbg$gb_def_out : VECTOR [,BYTE],	! Current OUTPUT configuration
	dbg$gb_resignal : BYTE,			! flag that says resignal all exceptions
	dbg$gb_take_cmd: BYTE,			! flag that controls command taking
	dbg$gl_buf_siz,				! Holds count of output buffer
	dbg$gl_context: BITVECTOR,		! DEBUG command context word
	dbg$gl_inprab: BLOCK [, BYTE],		! RAB for 'INPUT'
	dbg$gl_outprab: BLOCK [, BYTE],		! RAB for 'OUTPUT'
	dbg$gl_lograb : BLOCK [,BYTE],		! RAB for LOG file
	dbg$gl_log_buf,				! Ptr to log filespec
	dbg$gl_runframe : REF BLOCK [, BYTE],	! pointer to current run context
	dbg$gl_step_num,			! number of steps to single step
	dbg$pseudo_exit,			! Label in pseudo code for CALL 
	dbg$term_handlr,			! Label in termination handler
	prim_handl_2,				! Label in primary handler
	dbg$user_exit,				! Label in exit code
	dbg$gb_language : BYTE,			! Language setting
	dbg$gl_cishead : REF cis_link;		! Head of command input stream

OWN
	watchpoint_entry,			! Pointer to watchpoint entry
	primary_pointer;			! Pointer to xpoint primary descriptor

LITERAL
	signal_arg_coun	= 0,			! offset in exception call frame
	exception_name	= 1,			! ditto, offset to exception name
	add_sig_arg_one	= 2,			! first additional argument
	add_sig_arg_two	= 3,			! second additional argument

	try_read	= 0,			! attempt to read
	try_write	= 1,			! attempt to write
	inhibit_msg	= 1^28;			! inhibit message bit

MACRO
	! inp_read_error signals any RMS error encountered when reading input

	inp_read_error =
		BEGIN
		LOCAL
			fab_ptr  : REF $FAB_DECL,
			msg_desc : BLOCK [8,BYTE];

		fab_ptr = .inprab [rab$l_fab];
		msg_desc [dsc$w_length]  = .fab_ptr [fab$b_fns];
		msg_desc [dsc$a_pointer] = .fab_ptr [fab$l_fna];

		SIGNAL ((shr$_readerr + dbg_fac_code) OR fatal_bit, 1, msg_desc,
		        .inprab [rab$l_sts], .inprab [rab$l_stv]);
		END %,

	! log_write_error signals any RMS error encountered in writing to the LOG file

	log_write_error = 
		BEGIN
		LOCAL
			fab_ptr : REF $FAB_DECL,
			msg_desc : BLOCK [8,BYTE];

		fab_ptr = .dbg$gl_lograb [rab$l_fab];
		IF .dbg$gl_log_buf NEQ 0
		THEN
			BEGIN
			msg_desc [dsc$w_length]  = .fab_ptr [fab$b_fns];
			msg_desc [dsc$a_pointer] = .fab_ptr [fab$l_fna];
			END
		ELSE
			BEGIN
			msg_desc [dsc$w_length]  = .fab_ptr [fab$b_dns];
			msg_desc [dsc$a_pointer] = .fab_ptr [fab$l_dna];
			END;

		SIGNAL (shr$_writeerr + dbg_fac_code, 1, msg_desc,
		       .dbg$gl_lograb[rab$l_sts], .dbg$gl_lograb[rab$l_stv]);
		END %;

MACRO
	dbg$_noinfo	= 0 %,			! For FORTRAN %LINE stepping.

	TBIT		= 0,4,1,0 %,		! Trace bit is PSL

	intended_accs	= 2, 2, 1, 0%;		! bit in first additional argument
						! that says whether a read or write
						! was attempted in the access violation.


! OPCODE DATA STRUCTURES FOR TRACING AND STEPPING.
!+
! The data structure for opcode tracing is defined herein
! because no other module in DEBUG knows about it.
! It consists of two logical parts which are virtually contiguous:
!
!	1) a sequence of fixed two-longword entries, the first
!	   word of which is a pointer to the name of the
!	   opcode set, and the second word of which is (later) set
!	   to point to the opcode structure which defines the set.
!	   (one which is built with MAKE_OPCODE_TBL, below)
!	   If this second longword is 0, then this set of opcodes
!	   is not being traced.
!
!	** There are NUM_OPCODE_SETS of these opcode sets.
!
!	2) a 1-word entry which is either 0 or a pointer to some
!	   structure which defines user-given opcode lists.
!	   (Probably a linked version of the above 2-longword entries).
!	   Currently this word is always 0 because we have not
!	   yet implemented user-given opcode lists.  (It will be
!	   done via something like DBG>SET TRACE/INSTRUCT opcode_list).
!
!-

!+
! Currently there are only 2 pre-defined opcode lists.
!-

LITERAL
	NUM_OPCODE_SETS	= 2;

OWN
			! We need 2 entries for each opcode set,
			! and 1 entry at the end to point to
			! user-given sets.

	trace_opcodes : vector[ NUM_OPCODE_SETS*2 +1, LONG];

!+
! Macro for STEP/OVER and for SET TRACE/CALL and /BRANCH.
! It builds a fixed byte sequences which contains a count
! byte at the beginning, and a sequence of opcodes
! following that.  These structures are those pointed
! to in the TRACE_OPCODES structure, described above.
!-

MACRO
	make_opcode_tbl( table_name )[] =
		BIND table_name = UPLIT BYTE (%LENGTH-1, %REMAINING)
			: VECTOR [, BYTE]%;

!+
! The command SET TRACE /CALL causes a trace
! to be output to the output device every time one of the
! following instructions is about to be executed.
!-

make_opcode_tbl( trace_opc,
		%X'FB',	! CALLS
		%X'FA',	! CALLG
		%X'30',	! BSBW
		%X'10',	! BSBB
		%X'16',	! JSB
		%X'05',	! RSB
		%X'04'); ! RET
!+
! The command SET TRACE /BRANCH causes a trace
! to be output to the output device every time one of the
! following instructions is about to be executed.
!-

make_opcode_tbl( branch_opc,
		%X'12',	! BNEQ or BNEQU
		%X'13',	! BEQL or BEQLU
		%X'14',	! BGTR
		%X'15',	! BLEQ
		%X'18',	! BGEQ
		%X'19',	! BLSS
		%X'1A',	! BGTRU
		%X'1B',	! BLEQU
		%X'1C',	! BVC
		%X'1D',	! BVS
		%X'1E',	! BGEQU or BCC
		%X'1F',	! BLSSU or BCS
		%X'11',	! BRB
		%X'31',	! BRW
		%X'17',	! JMP
		%X'E0',	! BBS
		%X'E1',	! BBC
		%X'E2',	! BBSS
		%X'E3',	! BBCS
		%X'E4',	! BBSC
		%X'E5',	! BBCC
		%X'E6',	! BBSSI
		%X'E7',	! BBCCI
		%X'E8',	! BLBS
		%X'E9',	! BLBC
		%X'9D',	! ACBB
		%X'3D',	! ACBW
		%X'F1',	! ACBL
		%X'4F',	! ACBF
		%X'6F',	! ACBD
		%X'F3',	! AOBLEQ
		%X'F2',	! AOBLSS
		%X'F4',	! SOBGEQ
		%X'F5',	! SOBGTR
		%X'8F',	! CASEB
		%X'AF',	! CASEW
		%X'CF'); ! CASEL

!+
!	We step /OVER any instruction which begins
!	with an opcode which is in the following structure.
!-

make_opcode_tbl( step_over_set,
		%X'FB',	! CALLS
		%X'FA',	! CALLG
		%X'30',	! BSBW
		%X'10',	! BSBB
		%X'16'); ! JSB

GLOBAL ROUTINE DBG$SET_OPTRACE (SET_TOKEN) =
!++
! Functional Description:
!	This routine is called for one of 3 reasons:
!	1) to initialize the data structure needed for any type
!	   of opcode tracing.
!	2) to SET TRACE /CALL or /BRANCH.
!	3) to CANCEL TRACE /CALL or /BRANCH.
!
!	This routine is in this module so that all of the
!	opcode tracing structures, etc, can remain local to it.
!	
! Formal Parameters:
!
!	SET_TOKEN	0 => this is the initialize call
!			otherwise, this should be BRANCH_TOKEN (=> /branch)
!			or CALLS_TOKEN (=> /call)
!
! Implicit Inputs:
!	The context bit which says whether we are SETting or CANcelling
!	the indicated opcode tracing is used when this is NOT
!	the initialization call to this routine.
!
!	We assume that an outer routine has already checked that
!	the SET_TOKEN corresponds to /CALLS or /BRANCH.
!
! Routine Value:
!	FALSE - on the initialize call,
!	TRUE or FALSE, otherwise.  TRUE => there is
!		still some opcode tracing happening,
!		FALSE => otherwise.
!
!--
BEGIN
	LOCAL
		set_pointer,
		index;

	!+
	! First check to see if this was the initialization call.
	!-

	IF( .set_token eql 0 )
	then
		begin

		! Initially there is no opcode tracing in
		! effect.  The opcode set names must always 
		! be there, though.  They never change.
		! We assume that the initial TRACE_OPCODES structure
		! is all 0s, so that the pointers are null.

		trace_opcodes[1] = uplit( %ascic '/CALL' );
		trace_opcodes[3] = uplit( %ascic '/BRANCH' );
		return (false);
		end;

	!+
	! Whether or not this call is to cancel or set the
	! indicated opcode tracing, the index into the
	! trace_opcodes table will be the same.  While we're
	! at it, pick up the address of the fixed opcode list
	! which defines the set of opcodes we will trace.
	!-

	IF( .set_token EQL CALLS_TOKEN )
	THEN
		BEGIN

		! We 'build in' the fact that the 0th
		! entry is for the /CALL set.

		index = 0;
		set_pointer = trace_opc;
		END
	ELSE
		BEGIN

		! Assume that SET_TOKEN is EQL BRANCH_TOKEN.
		! We 'build in' the fact that the next
		! entry is for the /BRANCH set.

		index = 2;
		set_pointer = branch_opc;
		END;

	!+
	! If we are not cancelling the tracing,
	! then we must be setting it.
	!-

	IF( .dbg$gl_context[ DBG$K_CANCEL ] )
	then
		trace_opcodes[.index] = 0
	else
		trace_opcodes[.index] = .set_pointer;

	! Return an indication of whether or not there
	! is still any opcode tracing in effect.

	RETURN( .TRACE_OPCODES[0] NEQA 0
	       OR
		.TRACE_OPCODES[2] NEQA 0)
END;

GLOBAL ROUTINE DBG$SHO_OPTRACE =
!++
! Functional Description:
!	Produce a report of which type of opcode tracing
!	is in effect.
!
!	This routine is in this module so that all of the
!	opcode tracing structures, etc, can remain local to it.
!	
! Implicit Inputs:
!
!	The structure and manipulation of the TRACE_OPCODES structure.
!
! Routine Value:
!	TRUE, if some display is produced,
!	FALSE, otherwise.
!--
BEGIN
	LOCAL
		one_set_found;

	!+
	! No matter what the TRACE_OPCODES data structure
	! says, no opcode tracing is in effect if the runframe
	! bit that makes this happen in not set.
	!-

	IF( NOT .dbg$gl_runframe[DBG$V_TRACE_ALL] )
	then
		return(false);

	!+
	! Loop around displaying each built-in opcode
	! set that is currently known about and enabled.
	! Maintain a flag which indicates if any set
	! has been found.
	!-

	one_set_found = FALSE;

	INCR i FROM 0 TO (NUM_OPCODE_SETS*2) -1 BY 2
		DO

		! It is the opcode set pointer field of each record
		! being or not being 0 which indicates whether or not
		! the indicated set is being traced.

		IF( .trace_opcodes[.i] NEQ 0 )
		then
			begin
			one_set_found = TRUE;

			! Pass on the name of the opcode set and a pointer to
			! a counted byte stream of opcodes in that set.

			list_opcodes( .trace_opcodes[.i+1], .trace_opcodes[.i] );
			end;

	! Now we can display any user-given opcode sets,
	! once this has been implemented.  The check for this will
	! be whether or not TRACE_OPCODES[ NUM_OPCODE_SETS *2 ] is
	! 0 or not.  A non-zero value will point to a linked 2-word structure
	! just like those displayed above.


	! Return an indicator of whether or not any
	! opcode tracing is in effect.

	return(.one_set_found);
END;

ROUTINE LIST_OPCODES ( list_name, list_pointer ) : novalue =
!++
! Functional Description:
!	Produce a report of which type of opcode tracing
!	is in effect.
!
!	This routine is in this module so that all of the
!	opcode tracing structures, etc, can remain local to it.
!	
! Implicit Inputs:
!
!	The structure and manipulation of the TRACE_OPCODES structure.
!
! Routine Value:
!	NOVALUE
!--
BEGIN
	MAP
		list_name : ref vector[,byte],
		list_pointer : ref vector[,byte];
	local
		output_buffer : vector[ tty_out_width, byte];

	! Set up to do standard DEBUG I/O.

	dbg$cp_out_str = output_buffer+1;
	dbg$gl_buf_siz = 0;

	dbg$fao_put( output_buffer, 
    			UPLIT( %ASCIC 'tracing !AC instructions: '),
    			   .list_name);

	! Display the actual opcodes in the list.  The structure
	! expected here is one made by MAKE_OPCODE_TBL, described
	! at the beginning of this module.

	INCR I from 1 to .list_pointer[0] 
		do
		BEGIN
		local
			op_size;

		! Each time around the loop we add one more opcode
		! to the list we are building.

		op_size = dbg$conv_r_50( .dbg$gb_opinfo[ .list_pointer[.i], OP_NAME], .dbg$cp_out_str );
		dbg$cp_out_str = .dbg$cp_out_str + .op_size;
		dbg$gl_buf_siz = .dbg$gl_buf_siz + .op_size;

		IF( .i eql .list_pointer[0] )
		then
			! No more opcodes to list.
			exitloop;

		! Separate or terminate the list.

		IF( .I neq .list_pointer[0] -1 )
		then
			dbg$fao_put( output_buffer, UPLIT(%ASCIC ', '))
		else
			dbg$fao_put( output_buffer, UPLIT(%ASCIC ' and '));

		! Watch out for line overflow due to large opcode sets.

		IF( .dbg$cp_out_str GTRA output_buffer+72 )
		then
			begin

			! Flush the partial message and set up
			! to fill the buffer again with the rest of it.

			dbg$out_put( output_buffer );
			dbg$cp_out_str = output_buffer+1;
			dbg$gl_buf_siz = 0;
			dbg$fao_put( output_buffer, 
    				UPLIT(%ASCIC '!8AC'), uplit(%ascic' '));
			end;
		END;

	! The list has been exhausted.
	! Flush the message and we're done.

	dbg$out_put( output_buffer );
END;

ROUTINE TBIT_HANDLER ( psl_ptr, at_pc ) =
!++
! Functional Description:
!
!	Decide why a trace trap has occurred, and return
!	an indicator to tell an outer routine (EXC_HANDLER)
!	what to do about it.
!
! Formal Parameters:
!	
!	PSL_PTR	-A pointer to the supposed PSL that we set or
!		 clear the TBIT in.
!	AT_PC	-PC of current exception.
!
! Return Value:
!
!	0	=> pass control back to get commands,
!		   i.e. STEPping is over
!	1	=> continue STEPping
!	2	=> found a watchpoint while STEPping.
!
! Side Effects:
!
!--
BEGIN
	MAP
		PSL_PTR : REF BLOCK[ %upval, BYTE];
	LOCAL
		status;

	!+
	! Start by assuming that the result will be that
	! the TBIT should be turned off and flagged
	! as not begin an expected thing to happen.
	!-

	PSL_PTR[ TBIT ] = FALSE;
	dbg$gl_runframe[ dbg$V_tbit_ok ] = FALSE;
	dbg$gl_runframe[ dbg$V_in_a_bpt ] = FALSE;

	!+
	! If we have watchpoint mucking to do,
	! let EXC_HANDLER look after it.
	!-

	IF ( .dbg$gl_runframe[ DBG$V_IN_A_WPT ] )
	THEN
		BEGIN
		dbg$gl_runframe[ DBG$V_IN_A_WPT ] = FALSE;
		IF ( .dbg$gl_runframe[ DBG$V_REAL_WPT ] )
		THEN	! Found a watchpoint while stepping.

			RETURN(2);
		END;

	!+
	! If there are no steps to take, then
	! we will continue the user program
	! in non-step mode.  STEP_NUM should never
	! get below 0, but we include negative numbers
	! here in the test which implies "no steps left
	! to do".
	!-

	IF( .dbg$gl_step_num LEQ 0 )
	then
		! Continue the user program in non-step mode.
		! The TBIT, etc, has already been disabled.

		return(1);
	
	!+
	! If we are in the middle of stepping /OVER a routine
	! call, then there should be no TBIT setting (for step,
	! anyways), until the temporary breakpoint for the /OVER step
	! is hit.
	!-

	if( .dbg$gl_runframe[ DBG$V_STEP_OVER ] )
	then
		! Continue the user program in non-step mode
		! until the temporary (/OVER) breakpoint is hit.

		return(1);
	
	!+
	! If we are in the step mode where we ignore steps
	! in system space, then we turn on the TBIT and
	! continue stepping WITHOUT decrementing the step
	! count since none of the times when the PC is left
	! in system space is supposed to count as a step.
	!-

	IF( .dbg$gb_stp_ptr[ step_nosystem ]
	   AND
	    .at_pc GEQA SYSTEM_SPACE
	  )
	THEN
		BEGIN

		! Skip thru system space, TBIT trapping but
		! ignoring the traps as long as we're
		! still in system space.

		psl_ptr[ TBIT ] = TRUE;
		dbg$gl_runframe[ DBG$V_TBIT_OK ] = TRUE;
		RETURN(1);
		END;

	!+
	! Check for FORTRAN stepping by lines.
	!-

	IF( decrement_step(.at_pc) LEQ 0 )
	THEN
		! Done stepping => now take commands.

		RETURN(0);
	!+
	! If we get here, then we have decided to
	! continue stepping.
	!-

	psl_ptr[ TBIT ] = TRUE;
	dbg$gl_runframe[ DBG$V_TBIT_OK ] = TRUE;

	RETURN(1);
END;

ROUTINE DECREMENT_STEP ( at_pc ) =
!++
! Functional Description:
!
!	See if the given PC corresponds to a FORTRAN %line
!	number so that we can properly decrement the STEP
!	count while stepping.
!
!	It is in this routine that the decision is made about
!	how step types LINE and INSTRUCTION relate with regard
!	to whether or not there exists PC-correlation tables
!	for the routine that we are currently stopped in.
!
! Formal Parameters:
!	
!	AT_PC	-PC of current exception.
!
! Implicit Outputs:
!
!	The assignment is made to DBG$GL_STEP_NUM
!
! Return Value:
!
!	The new value which we have stored in DBG$GL_STEP_NUM
!
! Side Effects:
!
!--
BEGIN
	LOCAL
		status;

	! Assume that we either won't be stepping by %LINEs,
	! or that if we are, there won't be enough information
	! available to do so.

	status = DBG$_NOINFO;

	!+
	! Check for FORTRAN stepping by lines if the
	! step mode indicates this is desired.
	!-

	IF( .dbg$gb_stp_ptr[ STEP_LINE ] )
	THEN
		IF( (status = dbg$get_lineno(.at_pc)) )
		then
			! One step has been done.
	
			IF( (dbg$gl_step_num = .dbg$gl_step_num -1) LEQ 0 )
			THEN
				! Done stepping => now take commands.
	
				RETURN(0);
	!+
	! If the status, above, says that no information is
	! available which pertains to FORTRAN line numbers,
	! then we equate 1 step to 1 instruction.
	!-

	IF( .status EQL DBG$_NOINFO )
	then
		! One step has been done.

		IF( (dbg$gl_step_num = .dbg$gl_step_num -1) LEQ 0 )
		THEN
			! Done stepping => now take commands.

			RETURN(0);
	!+
	! If we get here, then the PC is in the
	! the middle of a %LINE number.  We don't
	! alter DBG$GL_STEP_NUM but instead return its
	! current value.

	RETURN(.dbg$gl_step_num);
end;

ROUTINE ANNOUNCE_TRACE ( at_pc ) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	Inform user that the program has stopped at a tracepoint
!	and display next instruction that will be executed.
!
! FORMAL PARAMETERS:
!	at_pc	- the address of the next instruction to be executed
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUTS:
!	The message is printed. Either it includes the symbolic instruction
!	or its hex equivalent.
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE.
!	novalue
!
! SIDE EFFECTS:
!	none
!--
    BEGIN
	MAP
		at_pc : REF VECTOR[, WORD];

	LOCAL
		announce_pc,
		entry_cs,
		output_buffer : VECTOR[ tty_out_width, BYTE ],
		backup_count,
		backup_ptr : REF VECTOR[,BYTE];

	! Set up to do standard DEBUG I/O.

	dbg$cp_out_str = output_buffer + 1;
	dbg$gl_buf_siz = 0;

	! If the PC value is on a routine boundary,
	! (actually, 2 after the value bound to a routine
	! symbol - due to the entry mask), then we
	! announce "routine" in front of the
	! rest of the message and print or symbolize a PC
	! value which is actually 2 less than what the PC value
	! really is.  This is because we consistently try to cover
	! up the entry-mask muckiness.

	entry_cs = uplit( %ascic '' );
	announce_pc = .at_pc;

	IF( DBG$IS_IT_ENTRY(.ANNOUNCE_PC -2) )
	THEN
		BEGIN
		ENTRY_CS = UPLIT( %ASCIC 'routine ');
		announce_pc = .announce_pc -2;
		END;
%IF THREAD_CODE
%THEN
	IF PROBER (%REF(0), %REF(2), .at_pc)	! Can this location be read?
	THEN
	    BEGIN
	    IF .dbg$gb_stp_ptr[step_line]	! Is step mode LINE ?
	    AND .at_pc[0] EQL %X'9B17'		! and instruction "JMP @(R11)+"
	    THEN
		announce_pc = .dbg$gl_runframe[dbg$l_user_r11];
	    END;
%FI
	!+
	! The announcement is different depending on whether
	! we have stopped because of a trace point or because
	! the step count has gone to 0.
	!-
	IF .dbg$gl_runframe[dbg$v_stepping]
	THEN
	    dbg$fao_put ( output_buffer,  UPLIT ( %ASCIC 'stepped to !AC' ),
    				 .ENTRY_CS)
	ELSE
	    dbg$fao_put ( output_buffer, UPLIT ( %ASCIC '!ACtrace at PC ' ),
    			    .ENTRY_CS);
	dbg$out_sym_val (.announce_pc, long_length, 0, output_buffer);

	IF (NOT .dbg$gb_stp_ptr[step_line])	! Output instruction if not stepping by line
	OR (NOT .dbg$gl_runframe[dbg$v_stepping]) ! Or tracing by opcode.
	THEN
	    BEGIN
	    !+
	    ! WE HOPE TO BE ABLE TO DECODE THE INSTRUCTION, BUT
	    ! WILL PRINT OUT SUCCESSIVE BYTES @PC IF WE CAN'T.
	    ! WE START BY BUILDING THE OUTPUT MESSAGE IN A LOCAL BUFFER.
	    !-
	
	    dbg$fao_put ( output_buffer, UPLIT (%ASCIC ': '));
	    backup_ptr = .dbg$cp_out_str;
	    backup_count = .dbg$gl_buf_siz;

	    ! THEN TRY TO DO THE SYMBOLIC DECODING.

	    IF dbg$ins_decode (.at_pc, output_buffer) EQL 0
	    THEN
		BEGIN
		!+
		! WRITE OVER WHATEVER dbg$ins_decode MAY HAVE
		!  WRITTEN, AND JUST DISPLAY THE VALUES.
		!-
		MAP
		    at_pc : REF VECTOR [, BYTE];
		dbg$cp_out_str = .backup_ptr;
		dbg$gl_buf_siz = .backup_count;
		DECR I FROM 3 TO 0
		DO
		    dbg$fao_put (output_buffer,  UPLIT( %ASCIC ' !XB' ), 
    					.at_pc[.I]);
		END;
	    END;

	dbg$out_put( output_buffer );	! WRITE OUT THE MESSAGE AND WE'RE DONE.

    	! Now output source if the user has said SET STEP SOURCE
    	IF .dbg$gl_runframe[dbg$v_stepping]
    	    AND .dbg$gb_stp_ptr[step_source]
    	THEN
    	    type_pc_source(.announce_pc, .announce_pc, 0);

    END;

ROUTINE CHECK_STEP =
!++
! Functional Description:
!
!	Determine if the user program should be started up
!	in such a way as DEBUG will regain control
!	after it has executed only one instruction.
!	This is not quite the same as stepping because that is
!	not always done by trapping on each instruction.
!
! Routine Value:
!
!	TRUE - if the TIBT should be turned on,
!	FALSE, otherwise.
!--
BEGIN
	LOCAL
		next_pc : ref vector[,byte],
		current_pc : ref vector[,byte];

	!+
	! If we are in the middle of stepping over a routine
	! call, then we are essentially not stepping insofar
	! as setting the TBIT and planting temporary breakpoints
	! is concerned.  This is the meaning of the DBG$V_STEP_OVER
	! bit in the runframe.
	!-

	IF ( .dbg$gl_runframe[ DBG$V_STEP_OVER ] )
	THEN
		RETURN (FALSE);

	!+
	! Even if we are stepping, there must be some
	! steps to do or there is something wrong.
	!-

	IF ( .dbg$gl_step_num LEQ 0 )
	THEN
		RETURN (FALSE);

	!+
	! If the current STEP type is not OVER
	! we have nothing further to do here.
	!-

	IF ( NOT .dbg$gb_stp_ptr[ step_over ] )
	THEN
		RETURN (TRUE);
	
	!+
	! Check for /OVER stepping.
	!
	! Given the current pc, pick up the next opcode
	! that will be executed and see if it is one of
	! those that we want to step over.
	!-
	current_pc = .dbg$gl_runframe[ DBG$L_USER_PC ];

	!+
	! /OVER steps are nothing special if the current
	! opcode does not belong to the step_over opcode set.
	! The first entry in the table is the size of the set.
	!-
	IF (INCR i FROM 1 TO .step_over_set[0]
		DO
		BEGIN
		IF ( .step_over_set[.i] EQL .current_pc[0] )
		THEN
			EXITLOOP(false);	! Found the matching element.
		END)
	THEN
		RETURN (TRUE);			! Nothing further to do.

	!+
	! If we get this far, we will try to implement /OVER.
	! First, get the address of the instruction following
	! the current one by calling the instruction decoder.
	!-
	next_pc = dbg$ins_decode (.current_pc,0);

	IF (.next_pc GEQA system_space) AND (.dbg$gb_stp_ptr[ step_nosystem ])
	THEN
	    RETURN (TRUE);
	IF (.next_pc EQL 0) OR (.next_pc GEQA system_space)
	THEN
	    BEGIN
	    SIGNAL (DBG$_STEPINTO, 1, .current_pc);
	    RETURN (TRUE);
	    END;
	!+
	! Insure that the breakpoint can be placed in the I-stream
	! before saving the opcode and the address.
	!-
	IF NOT dbg$write_mem (.next_pc, .next_pc, 1)	! DST_ADR, SRC_ADR, LEN
	THEN
	    BEGIN
	    SIGNAL (DBG$_STEPINTO, 1, .current_pc);
	    RETURN (TRUE);
	    END;
	!+
	! Save the opcode byte where the temporary breakpoint will be placed,
	! the address of the temporary breakpoint and set the runframe bit that
	! indicates a step over is in progress.
	!-
	dbg$gl_runframe[dbg$b_bpt_ins] = .next_pc[0];
	dbg$gl_runframe[dbg$l_bpt_pc] = .next_pc;
	dbg$gl_runframe[dbg$v_step_over] = TRUE;

	!+
	! Cause the TBIT to be turned OFF so that trapping
	! stops until the temporary breakpoint is hit.
	!-
	RETURN (FALSE);
END;

ROUTINE RESET_USER( skip_pc, psl_ptr ) =
!++
! Functional Description:
!
!	This routine is called when we are about to turn over
!	control to the user program and we have to decide
!	whether or not this should be done with the TBIT turned on.
!
! Formal Parameters:
!
!	SKIP_PC		-The PC which REM_OPCODES will NOT
!			 remove.
!	PSL_PTR		-The address of where the PSL that we should
!			 modify is stored.
!
! Implicit Inputs:
!
!	If SKIP_PC is not 0, then we are skipping over an
!	instruction which we have to later put a BPT at.
!
! Implicit Inputs:
!
!	The _IN_A_BPT runframe bit gets set if SKIP_IC
!	is not 0.
!
! Routine VALUE:
!	SS$_CONTINUE
!
! Side Effects:
!	The TBIT in the supposed PSL we are passed a pointer
!	to is turned on if this routine decides it should be.
!	The RUNFRAME's V_TBIT_OK bit is also set accordingly.
!--

BEGIN
	MAP
		PSL_PTR : REF BLOCK[ %upval, BYTE];

	!+
	! If we are in the state where an outer routine has 
	! decided that we need to 'step around a BPT instruction',
	! then we just do so.
	!-

	IF( .skip_pc NEQ 0 )
	THEN
		BEGIN

		PSL_PTR[ TBIT ] = TRUE;
		DBG$GL_RUNFRAME[ DBG$V_TBIT_OK ] = TRUE;
		DBG$GL_RUNFRAME[ DBG$V_IN_A_BPT ] = TRUE;
		END;

	!+
	! There may be special processing
	! for stepping.
	!-

	IF( .dbg$gl_runframe[ DBG$V_STEPPING ] )
	THEN
		BEGIN

		! Check for stepping - i.e. set the TBIT
		! for all STEPs except /OVER ones.
	
		IF( (PSL_PTR[ TBIT ] = check_step()) )
		then
			DBG$GL_RUNFRAME[ DBG$V_TBIT_OK ] = TRUE;
		END;
	!+
	! If we are doing any kind of opcode tracing, then
	! we have to turn the TBIT on after every instruction,
	! no matter what.
	!-

	IF( .DBG$GL_RUNFRAME[ DBG$V_TRACE_ALL ] )
	THEN
		BEGIN

		PSL_PTR[ TBIT ] = TRUE;
		DBG$GL_RUNFRAME[ DBG$V_TBIT_OK ] = TRUE;
		END;

	! Just before finally letting the user program
	! take over control, we take out all the opcodes
	! stored at what will become breakpoint locations, and
	! put breakpoint instructions in their place.
	! If there is an exception to this list of PCs, it
	! is passed on to us, and is because we sometimes 
	! want to leave the real instruction in place.

	dbg$rem_opcodes( .skip_pc );

	return( SS$_CONTINUE);
END;

ROUTINE command_proc  : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	Accepts a single (possibly multiple through the use of
!	continuation lines) command sequence from the user at DEBUG
!	command level. If the argument buffer_desc holds a value other
!	than a zero, then the command comes from this buffer.
!	Otherwise a command is read from the input device.
!
!	This routine declares an exception vector. Exceptions
!	encountered from this point generally cause an unwind, and then
!	this routine is called again by user_proc. They are generally
!	caused by user typing errors.
!
!	If the command read from the device INPUT is interpreted by
!	RMS as EOF, or any other nonsuccessful return from RMS is seen,
!	then set the exit flag, cancel the command
!	taking flag, and return.
!
! FORMAL PARAMETERS:
!	None
!
! IMPLICIT INPUTS:
!	The name of the DEBUG command level exception handler that is
!	declared within the context of this routine.
!
!	The fact that if the DBG$_L_BPT_PC field in the runframe
!	has a non-zero value then it must be the address
!	of a "temporary" breakpoint which DEBUG set to implement
!	step /OVER.
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	novalue
!
! SIDE EFFECTS:
!	The parser is called with the contents of the input buffer.
!--

	BEGIN

	BUILTIN
		FP;

	LITERAL
		null_byte_loc	= 1;

	BIND
		pmt_string_1	= UPLIT BYTE 
			(%ASCII %STRING (%CHAR (carriage_ret), %CHAR (linefeed), 'DBG>')),
		pmt_size_1	= %CHARCOUNT
			(%ASCII %STRING (%CHAR (carriage_ret), %CHAR (linefeed), 'DBG>')),
		pmt_string_sup	= UPLIT BYTE 
			(%ASCII %STRING (%CHAR (carriage_ret), %CHAR (linefeed), 'SDBG>')),
		pmt_size_sup	= %CHARCOUNT
			(%ASCII %STRING (%CHAR (carriage_ret), %CHAR (linefeed), 'SDBG>')),
		pmt_string_2	= UPLIT BYTE
			(%ASCII %STRING (%CHAR (carriage_ret), %CHAR (linefeed), '_')),
		pmt_size_2	= %CHARCOUNT
			(%ASCII %STRING (%CHAR (carriage_ret), %CHAR (linefeed), '_'));

	LOCAL
		input_buffer: VECTOR [no_of_inp_chars + %UPVAL, BYTE],
		inprab : REF $RAB_DECL,
		LENGTH,					! Input line length
		have_a_line,
		prev_count,				! current character count
		old_pointer,				! pointer to previous buffer
		new_pointer : REF VECTOR [, BYTE],	! pointer to current buffer
		status,					! status returned by $GET operation
    	        alphavector: vector [150,byte],
                alphaptr,
    		nbuf:	vector [tty_out_width, byte];

	!+
	! Enable a condition handler as described above.
	!-

	.FP = dbg$final_handl;

	!+
	! Delete all record of a "step over" breakpoint. It has
	! already been removed from the I-stream by DBG$INS_OPCODES.
	!-
	dbg$gl_runframe[ DBG$L_BPT_PC ] = 0;
	dbg$gl_runframe[ DBG$B_BPT_INS ] = 0;

	!+
	! Reset the level in the STP type structure so that we forget about
	! any kind of "override" type stepping we may have been doing.
	!-
	dbg$init_step( override_step, user_def_step );
	dbg$set_stp_lvl( user_def_step );

	have_a_line = FALSE;


	DO	BEGIN

	! If the head of the command argument list is of type buffer, process it

		IF .dbg$gl_cishead [dsc$b_dtype] EQL cis_inpbuf
		OR .dbg$gl_cishead [dsc$b_dtype] EQL cis_acbuf
		THEN
			BEGIN
			IF (.dbg$gb_language GTR lang_basic
					OR
			    .dbg$gb_language EQL lang_cobol)
			THEN
			    dbg$ncontrol (.dbg$gl_cishead)
			ELSE
			    dbg$pars_a_line(.dbg$gl_cishead);
			RETURN
			END;

		IF .dbg$gl_cishead [dsc$b_dtype] EQL cis_rab
		OR .dbg$gl_cishead [dsc$b_dtype] EQL cis_dbg$input
		THEN

		! If link is flagged for removal due to RMS problems, do it now	

		    IF .dbg$gl_cishead [remove_flag] 
		    THEN
			dbg$cis_remove()
		    ELSE
			BEGIN

		! Must collect an entire command line before calling the parser.
		! Enter a loop that collects multiple lines of input, ceasing
		! only when a line ends with other than a hyphen ("-"), which
		! is the line continuation character. Buffer the possibly
		! multiple lines into free storage.

			inprab = .dbg$gl_cishead [dsc$a_pointer] ;
			prev_count = 0;
			old_pointer = 0;
			IF .dbg$gl_cishead [dsc$b_dtype] EQL cis_dbg$input
			THEN
				IF dbg$gl_sup_or_test EQL 2
				THEN
					BEGIN
					inprab [rab$l_pbf] = pmt_string_sup;
					inprab [rab$b_psz] = pmt_size_sup;
					END
				ELSE
					BEGIN
					inprab [rab$l_pbf] = pmt_string_1;
					inprab [rab$b_psz] = pmt_size_1;
					END;
			inprab [rab$w_usz] = no_of_inp_chars;
			inprab [rab$l_ubf] = input_buffer;
			status = $GET (RAB = .inprab);


			IF NOT .status
			THEN
				! The $GET failed. Try to determine why...check for EOF
	
				IF .status EQL rms$_eof
				THEN
		
				! We have an EOF, resume taking input from the next
				! link in the cis. If there is none, exit.
	
					IF .dbg$gl_cishead [dsc$b_dtype] EQL cis_dbg$input
					THEN
						BEGIN
						dbg$gb_exit_dbg = TRUE;
						dbg$gb_debug = FALSE;
						$EXIT (code = SS$_NORMAL);
						END
					ELSE
						dbg$cis_remove()
				ELSE

				! there is some other problem, SIGNAL the error

					inp_read_error 

			! No problems, we read a line
	
			ELSE
				have_a_line = TRUE ;
			END;
		END UNTIL .have_a_line ;

	inprab [rab$v_pta] = FALSE;
	IF .dbg$gl_cishead [dsc$b_dtype] EQL cis_dbg$input
	THEN
		BEGIN
		inprab [rab$l_pbf] = pmt_string_2;
		inprab [rab$b_psz] = pmt_size_2;
  
	! If logging is enabled, copy the newly read input line to the LOG file
	! Note this is only done if we are reading commands from DBG$INPUT,
	! otherwise DBG$VERIFY_OUT takes care of things.

		IF .dbg$gb_def_out [out_log]
		THEN
			BEGIN
			LOCAL
				cmt_buf : VECTOR [no_of_inp_chars + %UPVAL + 1, BYTE];

		! If this is a comment line, insert a leading "!" if there
		! are less than two already.

			IF  .input_buffer[0] EQL %C'!' AND
			    .input_buffer[1] NEQ %C'!'
			THEN
				BEGIN
				cmt_buf[0] = %C'!';
				LENGTH = MIN(.INPRAB[RAB$W_RSZ], NO_OF_INP_CHARS - 1);
				INCR K FROM 0 TO .LENGTH - 1 DO
				   cmt_buf[.k+1] = .input_buffer[.k];

				dbg$gl_lograb [rab$l_rbf] = cmt_buf;
				dbg$gl_lograb [rab$w_rsz] = .LENGTH + 1;
				END
			ELSE
				BEGIN
				dbg$gl_lograb [rab$l_rbf] = input_buffer;
				dbg$gl_lograb [rab$w_rsz] = .inprab [rab$w_rsz];
				END;
	
			status = $PUT (RAB = dbg$gl_lograb);
			IF .status EQL rms$_rsa			! Record stream active error
			THEN
				BEGIN
				$WAIT (RAB = dbg$gl_lograb);	! Wait and retry
				status = $PUT (RAB = dbg$gl_lograb);
				END;
			IF NOT .status
			THEN
				log_write_error ;
			END;
		END;


	REPEAT
		BEGIN

		LOCAL
			cont_line;		! boolean test for end of line character


    		! Check for continuation character '-' only if the
    		! length of the input line was greater than zero.
    		!
    		cont_line = FALSE;
    		IF .inprab [rab$w_rsz] GTR 0
    		THEN
    		    BEGIN
		    IF .input_buffer [.inprab [rab$w_rsz] - 1] EQL '-'
		    THEN
			BEGIN
			inprab [rab$w_rsz] = .inprab [rab$w_rsz] - 1;
			cont_line = TRUE;
			END;

    		    END;

    		
		!+
		! Allocate space for this buffer plus all previous buffers.
		! If the space can be found, write the old and new buffers
		! into the new space.
		!-
		new_pointer = dbg$freez ((.prev_count + null_byte_loc +
			.inprab [rab$w_rsz] + 3) / 4);

		IF .old_pointer NEQ 0
		THEN
			BEGIN
			ch$move (.prev_count, .old_pointer, .new_pointer);
			dbg$freerelease (.old_pointer, (.prev_count + null_byte_loc + 3) / 4);
			END;
		ch$move (.inprab [rab$w_rsz], input_buffer,
				ch$plus (.new_pointer, .prev_count));
		prev_count = .prev_count + .inprab [rab$w_rsz];
		new_pointer [.prev_count] = 0;
		old_pointer = .new_pointer;

		!+
		! See whether this line ends with a continuation character.
		! If so, get another line.
		!-
		IF NOT .cont_line
		THEN EXITLOOP;
		status = $GET (RAB = .inprab);


		IF NOT .status
		THEN
			!+
			! The $GET failed. Set status so
			! that DEBUG returns to CLI.
			!-

			inp_read_error ;
		
		! Another write to LOG file, but only if we are taking commands
		! from DBG$INPUT

		IF .dbg$gb_def_out [out_log]
		AND .dbg$gl_cishead [dsc$b_dtype] EQL cis_dbg$input
		THEN
			BEGIN
			dbg$gl_lograb [rab$l_rbf] = input_buffer;
			dbg$gl_lograb [rab$w_rsz] = .inprab [rab$w_rsz];
			status = $PUT (RAB = dbg$gl_lograb);
			IF .status EQL rms$_rsa			! Record stream active error
			THEN
				BEGIN
				$WAIT (RAB = dbg$gl_lograb);	! Wait and retry
				status = $PUT (RAB = dbg$gl_lograb);
				END;
			IF NOT .status
			THEN
				log_write_error ;

			END;
		END;

	!+
	! A complete line has been collected. Put the just read in
	! buffer at the top of the command input stream. Call the parser with
	! the address of a string descriptor that describes the
	! concatenated input string.
	!-






	dbg$cis_add (.new_pointer, .prev_count, cis_inpbuf);
	IF (.dbg$gb_language GTR lang_basic
			OR
	    .dbg$gb_language EQL lang_cobol)
	THEN
	    dbg$ncontrol (.dbg$gl_cishead)
	ELSE
	    dbg$pars_a_line (.dbg$gl_cishead);
	END;

GLOBAL ROUTINE dbg$exc_handler (signal_arg_ptr, mechan_arg_ptr) =
!++
! FUNCTIONAL DESCRIPTION:
!	Exception analyzer called by the primary vector exception handler,
!	which is a MARS routine found in DBGSTART.MAR. The MARS routine
!	immediately resignals if the user program was not running. Otherwise
!	it saves the registers of the user program and disables ASTs for
!	the time that DEBUG is running.
!
!	Then it calls this routine, where the exception is analyzed for
!	the type of exception. Breakpoints and trace traps are given
!	special handling, which usually ends with control being passed
!	to the user. If the breakpoint or trace trap was illegal, then
!	the exception is resignaled unless the user has asked for control
!	on every exception.
!
!	Some trace traps cause an interim halt that requires some action,
!	but doesn't pass control back to the user. After checking the
!	validity of these trace traps, the value ss$_continue is returned.
!
!	After the exception is analyzed and it is determined that immediate
!	resignaling or continuing is not desired, the user_proc routine is
!	called. This routine accepts user commands either from prespecified
!	action commands from breakpoints, or interactively from the terminal.
!	Eventually, a command is given that either causes the user program
!	to continue or DEBUG to exit. If the user program is to continue,
!	the value returned from user_proc is ss$_continue, and that value
!	is passed back to the MARS handler.
!
! 	If an exception occurs during DEBUG processing, the exception
!	handler is final_handl, not this routine.
!
! FORMAL PARAMETERS:
!	signal_arg_ptr	- address of block that contains at least four longwords.
!			  THE PERTINENT WORDS ARE THE EXCEPTION NAME, THE
!			  PC AT THE TIME OF THE EXCEPTION, AND THE PSL AT
!			  THE TIME OF THE EXCEPTION. THE NAME IS ALWAYS
!			  THE SECOND LONGWORD, THE PC AND THE PSL THE NEXT
!			  TO LAST AND LAST RESPECTIVELY.
!	mechan_arg_ptr	- address of block that contains five longwords.
!			  THE PERTINENT WORDS ARE THE SAVED R0 AND R1.
!			  THEY ARE IN THE FOURTH AND FIFTH LONGWORDS RESPECTIVELY.
!			  NEITHER IS USED AT THIS TIME.
!
! IMPLICIT INPUTS:
!	SOME VARIABLE NUMBER OF ADDITIONAL ARGUMENTS MAY EXIST BETWEEN THE EXCEPTION
!	NAME AND THE PC. FLAGS INDICATING THE VALIDITY OF TBITS AND BREAKPOINTS
!	ARE REFERENCED. THE FLAG DBG$GB_RESIGNAL CAUSES ILLEGAL EXCEPTIONS TO
!	BE RESIGNALED IF THE FLAG IS SET TO TRUE.
!
! IMPLICIT OUTPUTS:
!	THE PC AND PSL MAY BE OVERWRITTEN BY THIS HANDLER
!
! ROUTINE VALUE:
!	ss$_resignal OR ss$_continue FOR RESIGNALING AND CONTINUING
!	RESPECTIVELY.
!
! SIDE EFFECTS:
!	ANY NUMBER OF THINGS.
!--

	BEGIN

	MAP
		signal_arg_ptr : REF VECTOR;

	LOCAL
		dummy,
		string_desc : BLOCK [8,BYTE],
		output_buffer	: VECTOR [tty_out_width, BYTE],
		sig_arg_count;


	string_desc [dsc$b_dtype] = dsc$k_dtype_t;
	string_desc [dsc$b_class] = dsc$k_class_s;
	string_desc [dsc$w_length] = 0;
	string_desc [dsc$a_pointer] = 0;


	! SAVE THE NUMBER OF ARGUMENTS IN THE SIGNAL ARGUMENT LIST SO
	! THAT LATER REFERENCING TO PC AND PSL IS SIMPLIFIED.
	! NOTE THAT THE PSL IS THE LAST ARGUMENT, AND THUS ITS OFFSET IN
	! THE LIST IS THE SAME AS THE count. THE PC IS THE NEXT TO LAST
	! ARGUMENT, AND ITS OFFSET THE count MINUS 1.
	!
	sig_arg_count = .signal_arg_ptr [signal_arg_coun];


	! Clear the flag saying that we are at the end of a STEP operation.  We
	! set that flag later if it turns out that we are at the end of a STEP
	! after all.
	!
    	dbg$gl_runframe[dbg$v_at_step_end] = FALSE;	

    	! Clear the flag saying that we are in an exception break. We set the
    	! flag later if it turns out that we are in an exception break after all.
    	!
    	dbg$gb_exc_bre_flag = FALSE;

	! ANALYZE THE TYPE OF EXCEPTION. THE BASIC STRATEGY IS TO
	! ACCEPT BPT, TBIT, AND ss$_debug, AND TO RESIGNAL ALL OTHERS
	! (UNLESS THE USER HAS SET BREAK ON EXCEPTION).
	!
	SELECTONE .signal_arg_ptr [exception_name] OF

		SET

		[ss$_break]:
			BEGIN
			LOCAL
				at_pc,
				entry_cs,
				entry;

			! RE-INSERT REAL OPCODES FOR EACH USER-SET BREAKPOINT.
			!
			dbg$ins_opcodes (all_bpts);

			!+
			! No matter what the reason for the breakpoint,
			! we can no longer be in the state where we are
			! TBITting to get around an instruction that is
			! usually replaced with a BPT.
			!-

			dbg$gl_runframe[ dbg$V_in_a_bpt ] = FALSE;

			!+
			! SEE IF THE BREAKPOINT IS STORED. IF IT IS, LOOK FOR
			! AN ACTION BUFFER ADDRESS TO PASS TO THE COMMAND
			! PROCESSING HANDLER.
			!-
			entry = dbg$find_bpt (.dbg$gl_runframe[dbg$l_user_pc]);
			IF .entry NEQ 0
			THEN
				BEGIN

				at_pc = .dbg$gl_runframe[ DBG$L_USER_PC ];	! Pick up the PC where the BPT happened.

				!+
				! THE BREAKPOINT IS REALLY ACCOUNTED FOR.  If
				! this was also A TRACEPOINT, SET THE APPROPRIATE
				! flag.  In any case, set the at_a_break flag.
				! For breaks, then see if we are to stop at
				! this break yet.
				!-
				dbg$gl_runframe [dbg$v_at_break] = TRUE;

				IF .bpt_type (.entry) EQL trace_point
				THEN
				    dbg$gl_runframe [dbg$v_at_trace] = TRUE;
				!+
				! For breakpoints, we must first
				! decrement the after count.
				!-
				IF ( (bpt_aftc(.entry) = .bpt_aftc(.entry) - 1) LEQ 0)
				THEN
					BEGIN
    					LOCAL saved_pc;
					!+
					! If the after count gets to 0, but 
					! does not go below, then we put it back
					! to 1 and continue to announce the break.
					!
					! Temporary breakpoints (/AFTER:0) are
					! removed by "USER_PROC".
					!-
					IF ( .bpt_aftc(.entry) EQL 0 ) 
					THEN
						bpt_aftc(.entry) = 1;
					!+
					! We actually stop for this break/trace point.
					! Therefore we make sure we forget about any
					! stepping we may have been doing.
					!-
					dbg$gl_runframe[ DBG$V_STEPPING ] = FALSE;
					dbg$gl_runframe[ DBG$V_STEP_OVER ] = FALSE;
					dbg$gl_runframe[ DBG$V_TBIT ] = FALSE;
					dbg$gl_step_num = 0;

					!+
					! Announce whether this is a break or
					! trace point, its location, and whether
					! or not it is on a routine.  If the
					! latter is ture, we actually announce a PC
					! 2 less than what it really is so that the
					! "routine..." and PC match.
					!-
					dbg$gl_outprab [rab$v_cco] = TRUE;
					dbg$cp_out_str = output_buffer + 1;
					dbg$gl_buf_siz = 0;

    					! Save away PC before decrementing
    					!
    					saved_pc = .at_pc;

					ENTRY_CS = UPLIT(%ASCIC '');
					IF( DBG$IS_IT_ENTRY(.at_pc -2 ) )
					THEN
						begin
						ENTRY_CS = UPLIT(%ASCIC 'routine ' );
						at_pc = .at_pc -2;
						end;
					dbg$fao_put (output_buffer, 
    					 UPLIT (%ASCIC '!AC!AC at '),.ENTRY_CS,
						(IF .bpt_type (.entry) EQL trace_point
						 THEN (UPLIT (%ASCIC 'trace'))
						 ELSE (UPLIT (%ASCIC 'break'))));

					IF .bpt_prim (.entry) NEQA 0
					THEN
				    	    BEGIN
					    dbg$ninitialize ();
				    	    IF NOT dbg$nsymbolize (.bpt_prim (.entry),
								   string_desc,
							   	   dummy)
				    	    THEN
						dbg$out_sym_val (.at_pc,
							 	 long_length, 0, output_buffer)
				    	    ELSE
						dbg$fao_put (output_buffer,
							     UPLIT BYTE (%ASCIC '!AS'),
						     	     string_desc);
				    	    END
					ELSE
				    	    dbg$out_sym_val (.at_pc, long_length, 0, 
    							     output_buffer);

					dbg$out_put (output_buffer);

    					! Now output source line if the user
    					! has selected SET STEP SOURCE
    					IF .bpt_type(.entry) NEQ trace_point
    					    AND
    					    .dbg$gb_stp_ptr[step_source]
    					THEN
    					    type_pc_source(
    						.saved_pc, .saved_pc, 0);

					!+
					! Call the command processor with the
					! address of this BPT table entry so that it
					! can execute the action buffer, if there is
					! one, and so that it can delete the BPT entry
					! from the table if it was a temporary one.
					!-
					RETURN user_proc (.signal_arg_ptr, .sig_arg_count, .entry)
					END;
				END;

			IF (.dbg$gl_runframe[dbg$l_bpt_pc] EQL .dbg$gl_runframe[dbg$l_user_pc])
			THEN
			    BEGIN

			    ! We have hit the temporary breakpoint used
			    ! to implement stepping over routine calls.
			    !
			    DBG$GL_RUNFRAME[DBG$V_AT_STEP_END] = TRUE;
			    dbg$gl_runframe[ DBG$V_STEP_OVER ] = FALSE;
			    decrement_step (.dbg$gl_runframe[dbg$l_user_pc]);

			    IF ( .dbg$gl_step_num EQL 0 )
			    THEN
				BEGIN
				!+
				! The step count has reached 0, give the
				! user control after announcing the step.
				!-
				dbg$gl_outprab[rab$v_cco] = true;
				announce_trace (.dbg$gl_runframe[dbg$l_user_pc]);
				dbg$gl_runframe[ dbg$v_stepping ] = false;
				dbg$gl_runframe[ dbg$V_TBIT ] = false;
				dbg$gl_runframe[dbg$b_bpt_ins] = 0;
				dbg$gl_runframe[dbg$l_bpt_pc] = 0;
				!+
				! Return accepting user commands.
				!-
				RETURN ( user_proc (.signal_arg_ptr,.sig_arg_count,0));
				END;
			    END;

			IF .entry NEQ 0
			THEN
			    BEGIN
			    !+
			    ! This is an /AFTER break for which 
			    ! the count has not yet run out.
			    !
			    ! Before continuing we have to
			    ! put back all the BPTs except
			    ! the one that just caused us to
			    ! stop.  It doesn't go back, and
			    ! we turn on the TBIT, so that we
			    ! can then execute and 'walk thru'
			    ! the instruction that IS there.
			    ! The TBIT is turned on so that we regain
			    ! control later so that we can then insert
			    ! the BPT we have just left out.
			    !-
			    dbg$gl_runframe[dbg$b_bpt_ins] = 0;
			    dbg$gl_runframe[dbg$l_bpt_pc] = 0;
			    RETURN RESET_USER (.at_pc, signal_arg_ptr[.sig_arg_count]);
			    END;

			IF .dbg$gl_runframe[dbg$l_bpt_pc] EQL .dbg$gl_runframe[dbg$l_user_pc]
			THEN
			    BEGIN
			    !+
			    ! Still stepping, let the user program continue running.
			    !-
			    dbg$gl_runframe[dbg$b_bpt_ins] = 0;
			    dbg$gl_runframe[dbg$l_bpt_pc] = 0;
			    RETURN RESET_USER (0, signal_arg_ptr[.sig_arg_count]);
			    END;

			!+
			! THIS BREAKPOINT IS NOT ONE SET BY THE USER.
			! RESIGNAL IF SO DIRECTED. OTHERWISE, ANNOUNCE
			! SCREW UP AND ACCEPT COMMANDS.
			!-
			dbg$gl_step_num = 0;		! Zero step count
			IF .dbg$gb_resignal
			THEN
			    BEGIN
			    ! Put the BPTs back into the user program
			    ! and refuse to handle this exception.

			    dbg$rem_opcodes (0);
			    RETURN ss$_resignal
			    END
			ELSE
			    BEGIN
			    report_msg (.signal_arg_ptr);
			    RETURN user_proc (.signal_arg_ptr, .sig_arg_count, 0);
			    END;

			END;


		[ss$_tbit]:
			BEGIN

			! RE-INSERT REAL OPCODES FOR EACH USER-SET BREAKPOINT.
			!
			dbg$ins_opcodes (all_bpts);

			! Set the flag saying we are at the end of a STEP opera-
			! tion.  This flag should be set even if this was an in-
			! valid or other non-STEP T-bit trap.
			!
			DBG$GL_RUNFRAME[DBG$V_AT_STEP_END] =TRUE;


			! See if the trace trap is a valid one.
			! If not, tell user if the user has asked to see
			! all exceptions. Otherwise resignal.
			! The stack handler will catch this exception
			! again if the user does not handle it.
			!
			IF NOT .dbg$gl_runframe [dbg$v_tbit_ok]
			THEN

				!++
				! Invalid trace trap halt. Resignal or
				! tell user and give command control.
				!--
				BEGIN
				IF .dbg$gb_resignal
				THEN
					BEGIN
					dbg$rem_opcodes (0);
					RETURN ss$_resignal
					END
				ELSE
					BEGIN
					report_msg (.signal_arg_ptr);
					RETURN user_proc (.signal_arg_ptr, .sig_arg_count, 0);
					END;
				END
			ELSE
				BEGIN

				!+
				! Take care of valid t-bit trap
				!-
				LOCAL
					status;
				dbg$gl_runframe [dbg$v_tbit] = FALSE;	! Turn off t-bit in user's PSL
				!++
				! See whether user program has run to
				! end, or if a DBG>CALLed routine has run to
				! end. If it has, turn off the tbit and
				! set the step count to 0 to stop stepping.
				! Returning continue then causes DEBUG
				! to simulate a sys$exit, thus indicating
				! to the user that the program has run to
				! the end, in the former case, or do the
				! end of CALL processing, in the latter.
				!--
				IF (.dbg$gl_runframe [dbg$l_user_pc] EQLA dbg$user_exit
				    OR .dbg$gl_runframe [dbg$l_user_pc] EQLA dbg$pseudo_exit
				    OR .dbg$gl_runframe [dbg$l_user_pc] EQLA dbg$term_handlr
				    OR .dbg$gl_runframe [dbg$l_user_pc] EQLA prim_handl_2
				   )
				THEN
					BEGIN
					signal_arg_ptr [.sig_arg_count] = .dbg$gl_runframe [dbg$l_user_psl];
					dbg$gl_runframe [dbg$v_trace_all] = FALSE;
					dbg$gl_runframe [dbg$v_stepping] = FALSE;
					dbg$gl_step_num = 0;
					dbg$gl_runframe [dbg$v_tbit_ok] = FALSE;
					dbg$gl_outprab [rab$v_cco] = TRUE;
					RETURN ss$_continue
					END;
				!+
				! Call a routine to  evaluate the cause
				! of the t-bit trap
				!-
				status = tbit_handler (signal_arg_ptr [.sig_arg_count],
						.dbg$gl_runframe[dbg$l_user_pc]);
				!++
				! IF the user has dbg$v_trace_all on (because
				! all occurrences of a certain set of
				! instructions are being monitored), then
				! see whether the next instruction to
				! to be executed is one of those special
				! instructions. If so, display the trace
				! on the output device and then continue
				! the user program. Otherwise, just
				! reset the tbit and continue.
				! This section is skipped unless the TBIT_HANDLER
				! routine returns a code which says to continue
				! running (1).
				!--
				IF .dbg$gl_runframe [dbg$v_trace_all] AND .status EQL 1
				THEN
					BEGIN
					LOCAL
						opcode_found,	! A flag
						stepping,	! A flag
						user_pc : REF VECTOR [, BYTE];

					LITERAL
						opcode_byte	= 0;

					user_pc = .dbg$gl_runframe[dbg$l_user_pc];
					stepping = .dbg$gl_runframe[ DBG$V_STEPPING ];
					!+
					! Loop around checking each built-in opcode
					! set that is currently known about and enabled.
					! Maintain a flag which indicates if any matching
					! opcode has been found.
					!-
				
					opcode_found = FALSE;
				
					INCR i FROM 0 TO (NUM_OPCODE_SETS*2) -1 BY 2
						DO
				
						! For each set of opcodes currently
						! enabled for tracing (pointed to
						! in the TRACE_OPCODES structure),
						! see if the current opcode is in
						! that set.
				
						IF( .trace_opcodes[.i] NEQ 0 )
						then
							begin
							LOCAL
								opcode_set : ref vector[,byte];

							! Loop thru the counted byte
							! stream of opcodes.

							opcode_set = .trace_opcodes[.i];

							INCR j from 1 to .opcode_set[0]
								do
								begin
								if( .opcode_set[.j] EQL .user_pc[0] )
								then
									begin
									opcode_found = TRUE;
									exitloop;
									end;
								END;
				
							! It doesn't matter in what
							! set an opcode is found.  If
							! it is anywhere, we're done.

							IF( .opcode_found )
							then
								exitloop;
							end;
				
					! At this point OPCODE_FOUND says whether
					! or not we should announce the trace.
					! The rest of the processing is the same
					! in either case.

					IF( .opcode_found )
					THEN
						begin

						! Pretend we're not stepping because
						! otherwise the trace will be announced
						! as a step completion.

						dbg$gl_runframe[ dbg$v_stepping ] = FALSE;
						announce_trace(.dbg$gl_runframe[dbg$l_user_pc]);
						end;
					dbg$gl_runframe [dbg$v_tbit] = TRUE;
					dbg$gl_runframe [dbg$v_tbit_ok] = TRUE;
					signal_arg_ptr [.sig_arg_count] = .dbg$gl_runframe[dbg$l_user_psl];
					dbg$gl_runframe[dbg$v_stepping] = .stepping;

					IF( NOT .stepping )
					THEN
						BEGIN
						dbg$rem_opcodes (0);
						RETURN ss$_continue
						END;
					END;
				!+
				! Now take action depending on what
				! TBIT_HANDLER, above, has determined.
				!-
				IF .status
				THEN
					BEGIN
					return reset_user( 0, signal_arg_ptr[.sig_arg_count]);
					END;

				!+
				! Step count was reduced to zero. Tell user
				! of position of halt. Status of zero means
				! this was a normal tracepoint. Status
				! of 2 means it is a watchpoint.
				!-
				dbg$gl_outprab[rab$v_cco] = TRUE;	! Purge type ahead
				IF .status EQL 0
				THEN
					BEGIN
					announce_trace (.dbg$gl_runframe[dbg$l_user_pc]);
					dbg$gl_runframe[dbg$v_at_break] = FALSE;
					dbg$gl_runframe[dbg$v_stepping] = FALSE;
					END
				ELSE	IF .dbg$gl_runframe[dbg$v_real_wpt]
					THEN
					BEGIN
					dbg$gl_runframe[dbg$v_real_wpt] = FALSE;
					dbg$gl_runframe[dbg$v_stepping] = FALSE;
					dbg$gl_step_num = 0;
					dbg$cp_out_str = output_buffer + 1;
					dbg$gl_buf_siz = 0;

					dbg$fao_put (output_buffer, 
						     UPLIT BYTE (%ASCIC '!AC'),
    					   	     UPLIT BYTE (%ASCIC '        new value = '));

					IF .primary_pointer NEQA 0
					THEN
					    BEGIN
					    LOCAL
						address : vector [2],
						type,
						radix,
						length,
						value_desc,
						dummy;

					    dbg$nget_type (.primary_pointer,
							   type, dummy);

					    IF .type EQL dbg$k_other
					    THEN
						BEGIN
						radix = dbg$nget_trans_radix (
							 dbg$nget_radix ());
						dbg$nget_lval (.primary_pointer,
								    address [0],
								    dummy);
						dbg$nget_length (.primary_pointer,
								 length,
								 dummy);
						IF .radix NEQ dbg$k_decimal
						THEN
						    BEGIN
						    dbg$nformat_with_radix (
							 .address [0], .address [1],
							 .length, .radix, output_buffer);
						    END
						ELSE
						    BEGIN
						    IF dbg$nmake_val_desc (
						       .primary_pointer, false,
						       value_desc, dummy)
						    THEN
						        BEGIN
						        IF dbg$ntype_conv (
						        .value_desc, dbg$k_default,
						        dbg$k_external_desc,
						        string_desc, dummy)
						        THEN
						            dbg$fao_put (output_buffer,
							     UPLIT BYTE (%ASCIC '!AS'),
							     string_desc)
						    	ELSE
							    dbg$nformat_with_radix (
							    .address [0], .address [1],
							    .length, .radix, output_buffer);
						    	END
						    ELSE
						        BEGIN
							dbg$nformat_with_radix (
							 .address [0], .address [1],
							 .length, .radix, output_buffer);
						    	END;
						    END;
						END
					    ELSE
						BEGIN
						dbg$out_num_val (output_buffer,
								..bpt_addr (.watchpoint_entry),
								.bpt_leng (.watchpoint_entry),
								0);
						END;
					    END
					ELSE
					    BEGIN
					    IF NOT dbg$out_typ_val (output_buffer,
    					       .dbg$gl_runframe[dbg$l_watchpt], -1)
					    THEN
					        dbg$out_num_val (output_buffer,
								 ..bpt_addr (.watchpoint_entry),
								 .bpt_leng (.watchpoint_entry),
								 0);
					    END;
					primary_pointer = 0;
					watchpoint_entry = 0;
					dbg$out_put (output_buffer);
					END;
				END;

			!+
			! Call the user command processor with a buffer address 
			! of zero so that commands are taken from the terminal.
			! The value returned from this routine is returned to
			! the outer handler.
			!-
			RETURN user_proc (.signal_arg_ptr, .sig_arg_count, 0)
			END;


		[ss$_accvio]:
			BEGIN
			LOCAL
				entry,
				PSL_PTR : ref block[ %upval, BYTE];

			!+
			! Look at the location of the access violation. If
			! it is on a page that has a watchpoint on it,
			! then the access violation is caused by DEBUG's
			! deliberate protection of that page. If the location
			! is the location being watched, report it. Then,
			! restore the original protection of the page, turn
			! on the tbit, execute one instruction, reprotect
			! the page, and proceed. If the location is not
			! being watched, do all of the above except don't
			! report it.
			!-

			! RE-INSERT REAL OPCODES FOR EACH USER-SET BREAKPOINT.
			!
			dbg$ins_opcodes (all_bpts);


			IF NOT dbg$find_watch (.signal_arg_ptr [add_sig_arg_two], entry)
			THEN
				BEGIN

				IF .dbg$gb_resignal
				THEN
					BEGIN

					!+
					! This is normal state. We didn't
					! cause the access violation. The
					! user doesn't want DEBUG to intercept
					! any user handlers, so just resignal.
					!-
					dbg$rem_opcodes (0);
					RETURN ss$_resignal
					END
				ELSE
					BEGIN

					!+
					! User wants to see all exceptions.
					! Report access violation and
					! give user control.
					!-
					report_msg (.signal_arg_ptr);
					RETURN user_proc (.signal_arg_ptr, .sig_arg_count, 0);
					END;
				END;

			!+
			! If this is an actual watchpoint match, report 
			! it to user.
			!-
			IF .bpt_addr(.entry) LEQA .signal_arg_ptr [add_sig_arg_two]
			AND .signal_arg_ptr [add_sig_arg_two] LEQA (.bpt_addr(.entry) + .bpt_leng(.entry))
			THEN
				BEGIN

				BIND
					signal_arg_blk	= signal_arg_ptr : REF BLOCK;

				dbg$gl_runframe[dbg$v_real_wpt] = TRUE;
				dbg$gl_outprab [rab$v_cco] = TRUE;
				dbg$gl_asci_len = .bpt_leng(.entry) + 1;

				dbg$cp_out_str = output_buffer + 1;
				dbg$gl_buf_siz = 0;
				dbg$fao_put (output_buffer, 
    					UPLIT (%ASCIC 'write to '));
				IF .bpt_prim (.entry) NEQA 0
				THEN
				    BEGIN
				    dbg$ninitialize ();
				    IF NOT dbg$nsymbolize (.bpt_prim (.entry),
							   string_desc,
							   dummy)
				    THEN
					dbg$out_sym_val (.bpt_addr (.entry),
							 long_length, 0, output_buffer)
				    ELSE
					dbg$fao_put (output_buffer,
						     UPLIT BYTE (%ASCIC '!AS'),
						     string_desc);
				    END
				ELSE
				    dbg$out_sym_val (.bpt_addr(.entry), long_length, 0, 
    						     output_buffer);

				dbg$fao_put (output_buffer, 
    					UPLIT (%ASCIC ' at PC '));
				dbg$out_sym_val (.dbg$gl_runframe[dbg$l_user_pc], 
    							long_length, 0, output_buffer);
				dbg$out_put (output_buffer);

    				! Now output source line if user has selected
    				! SET STEP SOURCE
    				IF .dbg$gb_stp_ptr[step_source]
    				THEN
    				    type_pc_source(
    					.dbg$gl_runframe[dbg$l_user_pc],
    					.dbg$gl_runframe[dbg$l_user_pc],
    					0);

				dbg$cp_out_str = output_buffer + 1;
				dbg$gl_buf_siz = 0;
				dbg$fao_put (output_buffer, 
					     UPLIT BYTE (%ASCIC '!AC'),
    					     UPLIT BYTE (%ASCIC '        old value = '));
	
				IF .bpt_prim (.entry) NEQA 0
				THEN
				    BEGIN
				    LOCAL
					address : vector [2],
					type,
					radix,
					length,
					value_desc,
					dummy;

				    dbg$nget_type (.bpt_prim (.entry),
						   type, dummy);

				    IF .type EQL dbg$k_other
				    THEN
					BEGIN
					radix = dbg$nget_trans_radix (
						 dbg$nget_radix ());
					dbg$nget_lval (.bpt_prim (.entry),
						       address [0],
						       dummy);
					dbg$nget_length (.bpt_prim (.entry),
							 length,
							 dummy);
					IF .radix NEQ dbg$k_decimal
					THEN
					    BEGIN
					    dbg$nformat_with_radix (
						 .address [0], .address [1],
						 .length, .radix, output_buffer);
					    END
					ELSE
					    BEGIN
					    IF dbg$nmake_val_desc (
					       .bpt_prim (.entry), false,
					       value_desc, dummy)
					    THEN
						BEGIN
					    	IF dbg$ntype_conv (
					           .value_desc, dbg$k_default,
					           dbg$k_external_desc,
					           string_desc, dummy)
					    	THEN
					            dbg$fao_put (output_buffer,
							  UPLIT BYTE (%ASCIC '!AS'),
						 	  string_desc)
					    	ELSE
						    dbg$nformat_with_radix (
						   .address [0], .address [1],
						   .length, .radix, output_buffer);
						END
					    ELSE
						BEGIN
						dbg$nformat_with_radix (
						 .address [0], .address [1],
						 .length, .radix, output_buffer);
						END;
					    END;
					END
				    ELSE
					BEGIN
					dbg$out_num_val (output_buffer,
							 ..bpt_addr (.entry),
							 .bpt_leng (.entry),
							 0);
					END;
				    END
				ELSE
				    BEGIN
				    IF NOT dbg$out_typ_val (output_buffer,
    							    .bpt_addr (.entry),
							    -1)
				    THEN
				        dbg$out_num_val (output_buffer, 
							 ..bpt_addr (.entry),
    						         .bpt_leng (.entry),
							 0);
				    END;
				primary_pointer = .bpt_prim (.entry);
				watchpoint_entry = .entry;
				dbg$out_put (output_buffer);
				END

			;

			!+
			! Now change the protection to its original
			! state, turn on the tbit, and REI.
			!-
			dbg$gl_runframe[dbg$l_watchpt] = .bpt_addr(.entry);
			dbg$gl_runframe[dbg$b_prev_pro1] = .bpt_pro1 (.entry);
			dbg$gl_runframe[dbg$b_prev_pro2] = .bpt_pro2 (.entry);
			psl_ptr = signal_arg_ptr [.sig_arg_count];
			psl_ptr[ TBIT ] = TRUE;
			dbg$gl_runframe[ DBG$V_IN_A_WPT ] = TRUE;
			dbg$gl_runframe[ DBG$V_tbit_ok ] = TRUE;


			!+
			! reinsert all the break/trace points and reset
			! the protections on all watchpoints. Then unset
			! the protection on this watchpoint.
			!-
			dbg$rem_opcodes (.dbg$gl_runframe[dbg$l_user_pc]); ! except for one that
									   ! may be at this location
			dbg$ins_opcodes (.bpt_addr(.entry));		   ! undo protection
			RETURN ss$_continue
			END;


		[ss$_debug]:
			BEGIN

			! RE-INSERT REAL OPCODES FOR EACH USER-SET BREAKPOINT.
			!
			dbg$ins_opcodes (all_bpts);

			!+
			! This is the phony way into the user control. This
			! exception name is passed by the DEBUG startup
			! routine, and by the final handler when an exception
			! condition in a user program has not been handled
			! by anyone, and the user is passed control in order
			! to fix up the instruction that caused the problem.
			! Just call the user command processor and return
			! the value it returns to the outer handler.
			!-

			RETURN user_proc (.signal_arg_ptr, .sig_arg_count, 0)
			END;


    		[ss$_dbgopcreq]:
    			BEGIN
    			! This signal is generated by the library routine
    			! LIB$GET_OPCODE. It is used to inquire what the
    			! real instruction was before the debugger replaced
    			! the instruction with a BPT. (The emulator needs
    			! this capability).
    			!
    			LOCAL 
    			    bpt_ptr,	! A pointer to the DEBUG structure 
    					!    that describes a breakpoint.
    			    result_addr,! The address where we are to put 
    					!    the 'real' opcode.
    		            user_pc; 	! The address that LIB$GET_OPCODE 
    					!    is inquiring about.

    			user_pc = .signal_arg_ptr[2];
    			result_addr = .signal_arg_ptr[3];
    			bpt_ptr = dbg$find_bpt(.user_pc);

    			! The above routine will return zero if there is no
    			! breakpoint at that instruction.
    			!
    			IF .bpt_ptr NEQ 0
    			THEN
    			    (.result_addr)<0,8,0> = .bpt_opco(.bpt_ptr);

    			RETURN ss$_continue;
    			END;

		[OTHERWISE]:
			BEGIN

			!+
			! First check for DBG$_SUPERDEBUG if we are SUPERDEBUG
			!-
			IF dbg$gl_sup_or_test EQL 2
			 AND .signal_arg_ptr [exception_name] EQL DBG$_SUPERDEBUG
			THEN
				RETURN user_proc (.signal_arg_ptr, .sig_arg_count, 0);

			! Set the AT_FAULT flag TRUE if the exception is a fault-type,
			! otherwise FALSE.
			!
			! IF	dbg$exception_is_fault (.signal_arg_ptr [exception_name])
			! THEN	dbg$gl_runframe [dbg$v_at_fault] = TRUE
			! ELSE	dbg$gl_runframe [dbg$v_at_fault] = FALSE;


			!+
			! Some exception in the user program besides BPT,
			! trace trap, or initialization. If resignaling,
			! just resignal; otherwise, announce the
			! problem and pass control to the user.
			!-


			IF .dbg$gb_resignal
			THEN
				BEGIN
				RETURN ss$_resignal
				END
			ELSE
				BEGIN
    				LOCAL
    				    status;

    				! Set the flag saying we are in an exception
    				! break
    				!
    				dbg$gb_exc_bre_flag = TRUE;

				! RE-INSERT REAL OPCODES FOR EACH USER-SET BREAKPOINT.
				!
				dbg$ins_opcodes (all_bpts);

    				! Give message and accept user commands
    				!
				report_msg (.signal_arg_ptr);
				status = user_proc (.signal_arg_ptr, .sig_arg_count, 0);

    				! See if the user said "GO <addr>". If so,
    				! continue from address <addr>. Else, resignal
    				! the exception so user handlers can get
    				! called.
    				!
    				IF .dbg$gb_go_arg_flag	
    				THEN
    				    RETURN .status
    				ELSE
    				    RETURN ss$_resignal;
				END;
			END;

		TES;

	END;

GLOBAL	ROUTINE	dbg$exception_is_fault	(exception) =
!++
!
! Functional Description:
!
!	Given an exception name - the longword which encodes the
!	type, etc, of an exception - deduce if this exception is
!	the so-called FAULT_EXC type.  This is for the PC_TO_LINE
!	translation - we have to know if the PC is on the instruction
!	which caused the exception, or if it is on the next instruction.
!
!	The answer to the question is simply whether
!	the given EXC_NAME is in our table of exceptions.  The only
!	trickery is that this routine makes sure only to look at
!	the part of the longword which encodes the error code - and
!	not at the rest of it since that may change.
!
! Formal Parameters:
!
!	EXCEPTION - the longword system-defined exception name.
!
! Routine Value:
!
!	TRUE or FALSE.  See above.
!
! Side Effects:
!	None.
!--

BEGIN	MAP	exception :	BLOCK	[%UPVAL, BYTE];

	BIND	! The 0-ended list of exception codes.

		exception_list =	UPLIT WORD
					(	SS$_ACCVIO,
						SS$_NOTRAN,
						SS$_RADRMOD,
						SS$_ROPRAND,
						SS$_OPCDEC,
						SS$_OPCCUS,
						SS$_BREAK,
						SS$_FLTOVF_F,
						SS$_FLTUND_F,
						SS$_FLTDIV_F,
						SS$_TBIT,
						SS$_COMPAT,
						0
					) :	VECTOR	[, WORD];

	! Simply loop thru the list checking each one,
	! ending when the 0 one is encountered.
	!
	INCR	i
	FROM	0
	DO	BEGIN	LOCAL	list_entry :	BLOCK	[%UPVAL, BYTE];

			IF	((list_entry = .exception_list [.i]) EQL 0)
			THEN	EXITLOOP;

			IF	(.exception [STS$V_CODE] EQL .list_entry [STS$V_CODE])
			THEN	RETURN	(TRUE);
		END;

	! Entry not found in the exception list.

	RETURN	(FALSE);
END;

GLOBAL ROUTINE DBG$PUTMSG (sig_arg_list) : NOVALUE =
!++
! Functional description:
!	Reports a message by calling SYS$PUTMSG with an action routine
!	address of a routine to write the formatted string to DBG$OUTPUT.
!	This routine checks the exception name to see if the exception is not
!	a hardware exception.  If it is not a hardware exception 2 is subtracted
!	from the signal argument list count before calling SYS$PUTMSG.
!	After SYS$PUTMSG returns the original count is restored.
!
! Formal Parameters:
!	sig_arg_list	- the address of the signal argument list.
!
! Implicit inputs:
!	NONE
!
! Implicit outputs:
!	none
!
! Routine value:
!	novalue
!
! Side effects:
!	The message is output to DBG$OUTPUT.
!--

	BEGIN

	LOCAL
		orig_arg_count,
		index,
		excep_name : BLOCK [%UPVAL, BYTE],
		table_value : BLOCK [%UPVAL, BYTE];

	MAP
		sig_arg_list : REF VECTOR;

	BIND
		hardware_excep = UPLIT WORD (ss$_accvio, ss$_artres, ss$_intovf,
				ss$_intdiv, ss$_fltovf, ss$_fltdiv, ss$_fltund,
				ss$_decovf, ss$_subrng, ss$_astflt, ss$_break,
				ss$_cmodsupr, ss$_cmoduser, ss$_compat,
				ss$_debug, ss$_opccus, ss$_opcdec, ss$_pagrderr,
				ss$_radrmod, ss$_roprand, ss$_ssfail, ss$_tbit,
				0) : VECTOR [, WORD];

	orig_arg_count = .sig_arg_list[0];		! Get orignial arg. count
	excep_name = .sig_arg_list[1];			! Get exception name
	IF (.excep_name[STS$V_FAC_NO] NEQ 0)		! Not SYSTEM facility
	THEN
		BEGIN
		sig_arg_list[0] = .sig_arg_list[0] - 2;	! update argument count
		END
	ELSE
		BEGIN
		index = 0;
		!+
		! This loop will exit with -1 if the exception name is not found.
		! In that case we must subtract 2 from the signal argument list
		! argument count before calling SYS$PUTMSG.
		!-
		IF (WHILE (.hardware_excep[.index] NEQ 0)
		    DO
		    BEGIN
		    table_value = .hardware_excep[.index]; ! pick up next value
		    IF (.excep_name[STS$V_CODE] EQL .table_value[STS$V_CODE])
		    THEN
			EXITLOOP 0;

		    index = .index + 1;
		    END)
		THEN
		    sig_arg_list[0] = .sig_arg_list[0] - 2;
		END;
	SYS$PUTMSG (.sig_arg_list, DBG$OUT_MESSAGE, 0);
	sig_arg_list[0] = .orig_arg_count;

	END;

ROUTINE report_msg ( sig_arg_list ) : NOVALUE =

!++
! Functional description:
!	This routine reports the exception message and then announces
!	the EXCEPTION break at the user's location counter.
!
! Formal Parameters:
!	sig_arg_list	- Address of the signal argument list
!
! Implicit inputs:
!	DBG$GL_RUNFRAME	- The address of the user's runframe.
!
! Implicit outputs:
!	none
!
! Routine value:
!	novalue
!
! Side effects:
!	A message is output to DBG$OUTPUT.
!
!--

	BEGIN

	MAP
		sig_arg_list : REF VECTOR;

	LITERAL
		buffer_size	= 256,
		dsc_size	= 0,
		dsc_address	= 1,
		msg_flags	= 15;

	LOCAL
		exc_type,
		pc_value,
		status,
		rst_ptr : REF rst$entry,
		dst_ptr : REF dst$record,
		line_no,
		stmt_no,
		excep_name : BLOCK [%UPVAL, BYTE],
		outbuf: VECTOR [buffer_size, BYTE],
		outbufdesc : VECTOR [2, LONG];

	dbg$putmsg (.sig_arg_list);		! format and output message.

	! Announce the exc break in the standard way.

	dbg$cp_out_str = outbuf + 1;
	dbg$gl_buf_siz = 0;
	excep_name = .sig_arg_list[1];			! Get exception name
	IF (.excep_name[STS$V_FAC_NO] EQL 0)		! Not SYSTEM facility
	THEN
		SELECTONE .excep_name OF
				SET

			[ss$_astflt, ss$_break,	ss$_compat, ss$_opccus,
			ss$_opcdec, ss$_radrmod, ss$_roprand]:
				exc_type = fault_exc;
			[OTHERWISE]:
				exc_type = trap_exc;
			TES
	ELSE
		exc_type = trap_exc;

	pc_value = .dbg$gl_runframe[dbg$l_user_pc];
	dbg$gb_no_globals = TRUE;
	status = dbg$val_to_sym(.pc_value, rst_ptr);
	dbg$gb_no_globals = FALSE;
	IF .status
	THEN
		BEGIN
		dst_ptr = .rst_ptr[rst$l_dstptr];
		status = (.dst_ptr NEQ 0);
		IF .status
		THEN
			status = dbg$pc_to_line( (IF .exc_type EQL trap_exc
							THEN .pc_value - 1
							ELSE .pc_value),
						.dst_ptr[dst$l_value],
						.exc_type,line_no,stmt_no,
						pc_value);
	END;
	IF .status
	THEN
		dbg$fao_put (outbuf,
			UPLIT (%ASCIC 'exception break during line '))
	ELSE
		IF .exc_type EQL trap_exc
		THEN
			dbg$fao_put(outbuf,
				UPLIT (%ASCIC 'exception break preceding '))
		ELSE
			dbg$fao_put(outbuf,
				UPLIT (%ASCIC 'exception break at '));
	dbg$out_sym_val (.pc_value, long_length, 0, outbuf);
	dbg$out_put (outbuf);

    	! Now output source if the user has selected SET STEP SOURCE
    	IF .dbg$gb_stp_ptr[step_source]
    	THEN
    	    type_pc_source(.pc_value, .pc_value, 0);

	END;

ROUTINE user_proc (signal_arg_ptr, sig_arg_count, bpt_table_entry) =

!++
! FUNCTIONAL DESCRIPTION:
!	ROUTINE CALLED AFTER THE USER PROGRAM HALTS BECAUSE OF A DEBUG
!	CAUSED EXCEPTION (SUCH AS INITIALIZATION, BREAKPOINT, OR TRACE TRAP).
!
!	AN OUTER HANDLER DETERMINES THAT THE HALT IS LEGAL. THEN THIS ROUTINE
!	PROCESSES USER COMMANDS (BOTH PREDEFINED AND INTERACTIVE) UNTIL
!	SOME COMMAND CAUSES THE USER PROGRAM TO BE CONTINUED
!	OR RESTARTED.
!
!	THEN THIS ROUTINE TRIES TO CONTINUE OR RESTART THE PROGRAM. IF EVERY
!	THING WORKS OKAY, THE VALUE OF ss$_continue IS RETURNED TO THE OUTER
!	HANDLER AND THIS VALUE IS PASSED BACK TO THE OPERATING SYSTEM.
!
!	OTHERWISE, THE dbg$gb_exit_dbg FLAG IS SET TO TRUE, AND A SYS$EXIT
!	IS TAKEN BECAUSE SOME IRRECOVERABLE ERROR HAS OCCURRED.
!
! FORMAL PARAMETERS:
!	signal_arg_ptr	- ADDRESS OF BLOCK WHICH CONTAINS FOUR LONGWORDS.
!			  THE PERTINENT WORDS ARE THE EXCEPTION NAME, THE
!			  PC AT THE TIME OF THE EXCEPTION, AND THE PSL AT
!			  THE TIME OF THE EXCEPTION. THE NAME IS ALWAYS
!			  THE SECOND LONGWORD, THE PC AND THE PSL THE NEXT
!			  TO LAST AND LAST RESPECTIVELY.
!	sig_arg_count	- THE NUMBER OF ARGUMENTS IN THE SIGNAL ARGUMENT
!			  LIST.
!	bpt_table_entry - the address of the BPT table entry for the
!			  break/trace point we are stopped at.
!
! IMPLICIT INPUTS:
!	none
!
! IMPLICIT OUTPUTS:
!	DEBUG COMMANDS ARE EXECUTED. THE PC AND PSL MAY BE OVERWRITTEN.
!	IF AN IRRECOVERABLE ERROR OCCURS, DEBUG EXITS TO THE COMMAND
!	LINE INTERPRETER.
!
! ROUTINE VALUE:
!	ss$_continue
!
! SIDE EFFECTS:
!	ANY NUMBER OF THINGS
!--

BEGIN

	MAP
		signal_arg_ptr : REF VECTOR;

	LOCAL
		ENTRY_CS,
		start_pc : REF VECTOR [, WORD],
		output_buffer : VECTOR [tty_out_width, BYTE];

	!+
	! Turn off RMS cancel control-O bit so
	! that user can toggle control-O in the normal fashion.
	!-
	dbg$gl_outprab [rab$v_cco] = FALSE;

	!+
	! Set the dbg$gb_take_cmd flag to true. This says that user
	! commands can be executed. This flag is turned off by a start,
	! step, continue, or exit command.
	!-
	dbg$gb_take_cmd = TRUE;

	!+
	! If an action command was specified for the breakpoint at which
	! the program is halted, then execute the action command.
	! The presence of the action command is a non-zero address value
	! in the APTR field of the given BPT table entry.
	!
	! If the point we're stopped at is a temporary breakpoint, then
	! delete this entry from the BPT table now cause we must be
	! done with it.
	!-
	IF .bpt_table_entry NEQA 0
	THEN
		BEGIN
		LOCAL
			cmd_buffer : ref vector[,byte];
		!+
		! See if there is an action buffer associated with
		! the stopped-at breakpoint.
		!-

		IF( (cmd_buffer = .bpt_aptr(.bpt_table_entry)) NEQA 0 )
		then
			BEGIN

			! Add a link of type cis_acbuf to the cis
			! and pass this on to have executed as a
			! DEBUG command string.

			dbg$cis_add (cmd_buffer[1], .cmd_buffer[0], cis_acbuf);

			command_proc ();
			END;

		! Whether or not there was an action buffer, see if
		! this is a temporary breakpoint.  Note that the 
		! following check is why the AFTC field must be signed.

		IF( .BPT_AFTC(.BPT_TABLE_ENTRY) LEQ 0 )
		then
			begin
			! Delete the breakpoint entry from the BPT table.

			dbg$gl_context[ DBG$K_BREAK ] = TRUE;
			dbg$cancel_bpt(.bpt_addr(.bpt_table_entry));
			dbg$gl_context[ DBG$K_BREAK ] = FALSE;
			END;
		END;

	!+
	! If this was a tracepoint, then the at_a_trace flag will be on.
	! Turn off the take command flag so that no further commands
	! are processed.
	!
	! Since this branch is here, actions stored at tracepoints
	! can be implemented easily at any time.
	!-
	IF .dbg$gl_runframe [dbg$v_at_trace]
	THEN dbg$gb_take_cmd = FALSE;

	!+
	! As long as no commands in the action buffer caused the
	! program to continue (or restart), the command taking flag
	! will still be turned on, and further commands can be
	! processed from the input device. Otherwise, the while loop
	! below does not execute at all.
	!-
	WHILE .dbg$gb_take_cmd DO
		command_proc ();

	!+
	! Unless we have stopped at a tracepoint, we
	! now print out a message to say we're starting again.
	!-

	IF NOT .DBG$GL_RUNFRAME[DBG$V_AT_TRACE]
	THEN
		BEGIN
		dbg$cp_out_str = output_buffer + 1;
		dbg$gl_buf_siz = 0;
		!+
		! Report the address that the user called if we are
		! starting at DBG$PSEUDO_PROG.
		!-
		start_pc = .dbg$gl_runframe[dbg$l_user_pc];
		IF .start_pc EQL DBG$PSEUDO_PROG
		THEN
		    start_pc = .DBG$GL_RUNFRAME[DBG$L_CALL_ADDR] + 2;
	
%IF THREAD_CODE
%THEN
		IF PROBER (%REF(0), %REF(2), .start_pc)	! Can start address be read?
		THEN
		    BEGIN
		    IF .dbg$gb_stp_ptr[step_line]	! Is step mode LINE and
		    AND .start_pc[0] EQL %X'9B17'	! instruction "JMP @(R11)+" ?
		    THEN
			start_pc = .dbg$gl_runframe[dbg$l_user_r11];
		    END;
%FI
	
		entry_cs = uplit( %ascic '' );
	
		IF dbg$is_it_entry (.start_pc - 2)	! announce as routine ?
		THEN
		    BEGIN
		    entry_cs = uplit( %ascic 'routine ' );
		    start_pc = .start_pc - 2;
		    END;
		dbg$fao_put (output_buffer, UPLIT (%ASCIC '!ACstart at '),
    			.entry_cs);
		dbg$out_sym_val (.START_PC, long_length, 0, output_buffer);


		dbg$out_put (output_buffer);
		END;

	!+
	! See whether the PC that is being returned to has a breakpoint
	! which we have already 'hit' at where it points to.
	! If so, remove this breakpoint for one instruction, turn
	! on the tbit, and continue. This causes the instruction to be
	! executed, and then the breakpoint reinserted for the next time
	! through.  We use START_PC to tell RESET_USER about this.
	!-

	IF ( dbg$find_bpt(.dbg$gl_runframe[dbg$l_user_pc]) NEQ 0
	AND  .dbg$gl_runframe[dbg$v_at_break]
	AND  .dbg$gl_runframe[dbg$l_user_pc] EQL .signal_arg_ptr[.sig_arg_count - 1] )
	THEN
		BEGIN
		!+
		! The breakpoint is still active. Therefore, take out
		! all opcodes and insert BPTs for all breakpoints EXCEPT
		! the one we're currently looking at.  Then turn
		! on the TBIT and continue so that we can 'step around' 
		! this instruction.
		!-
		start_pc = .dbg$gl_runframe [dbg$l_user_pc];
		END
	ELSE
		BEGIN
		!+
		! If no break/tracepoint or watchpoint was found, then 
		! this is a normal continue.  The TBIT gets set only
		! if we are stepping.
		!-
		start_pc = 0;
		END;

	!+
	! Before continuing the program, turn off two context bits.
	!-
	dbg$gl_runframe [dbg$v_at_break] = FALSE;
	dbg$gl_runframe [dbg$v_at_trace] = FALSE;

	!+
	! Since the user may have changed PC or the PSL, and these registers
	! are not reloaded in any other routines, reload them
	! into the exception call frame here.
	!-
	signal_arg_ptr [.sig_arg_count - 1] = .dbg$gl_runframe [dbg$l_user_pc];
	signal_arg_ptr [.sig_arg_count] = .dbg$gl_runframe [dbg$l_user_psl];

	RETURN( RESET_USER( .start_pc, signal_arg_ptr [.sig_arg_count] ));

END;

ROUTINE type_pc_source (low_pc, high_pc, flag) : NOVALUE =
!++
! Routine Purpose
!
!	Interface to DBG$SRC_TYPE_PC_SOURCE. This routine establishes a
!	handler so that errors that are signaled will not cause an unwind
!	all the way to system level.
!
! Inputs
!
!	low_pc, high_pc, flag -	These get passed along to DBG$SRC_TYPE_PC_SOURCE.
!
! Outputs
!
!	None
!--
    BEGIN

    BUILTIN
    	FP;

    ! Establish the handler.
    !
    .FP = dbg$final_handl;

    ! Call the routine in DBGSOURCE.
    !
    dbg$src_type_pc_source (.low_pc, .high_pc, .flag);

    END;
END
ELUDOM
