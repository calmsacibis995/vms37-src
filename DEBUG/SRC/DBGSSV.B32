MODULE DBGSSV (	IDENT = 'V03-000') =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! FACILITY:	DEBUG
!
!++
! FUNCTIONAL DESCRIPTION:
!	CALLS TO STARLET OPERATING SYSTEM I/O SERVICES.  INCLUDE
!	ASSIGNMENT AND DEASSIGNMENT OF CHANNELS, READS, WRITES.
!
! Version:	1.24
!
! History:
!	Author:
!		Carol Peters, 21 Sep 1976: Version 01
!
!	Modified by:
!		Mike Candela, 12 Jan 1979
!		TKM, 6 Aug 79
!		TKM, 21 AUG 79
!		JBD, Bruce Dawson
!		KAN, 16 JAN 80
!		ALA, Alyson L. Abramowitz
!		DLP, David Plummer 23-June-80
!               PLS, Ping Sager 18-June-81
!		RT , Richard Title 13-Jul-81
!
! Revision History:
! 1.01	22-SEP-78	DAR	Deleted require file DLLNAM...
! 1.02	25-SEP-78	MCC	Deleted require file SYSLIT.	
! 1.03	01-NOV-78	DAR	Added preliminary support for numeric string
!				data types to DBG$OUT_SYM_VAL.
! 1.04	07-NOV-78	MCC	Made changes to support BLISS structure references,
!				including addition of routine put_access_act
! 1.05	05-DEC-78	DAR	Fixed DBG$OUT_SYM_VAL to check for DSC$K_DTYPE_Z
!				in the name table record.
!				Output array bounds and line numbers in COBOL
!				and BASIC as well as FORTRAN.
! 1.06	 9-DEC-78	MCC	Added support for BLISS field references
! 1.07	15-DEC-78	DAR	For floating point numbers in DBG$OUT_TYP_VAL we
!				check to see that the number is not illegal before
!				calling the RTL conversion routine.
!				Added support for packed decimal in DBG$OUT_TYP_VAL
! 1.08	29-DEC-78	DAR	Initialized output length variable for packed
!				to leading separate converison.
! 1.09	12-JAN-79	MCC	Changed put_bounds to accomodate resymbolization
!				of COBOL-74 arrays. 
! 1.10   6-AUG-79	TKM	Changed out_typ_val to use the length from the
!				descriptor in outputing decimal numbers and
!				strings.  It accepts the nt-ptr optionally,
!				assuming that it has a type of -1 if the nt-ptr
!				is not passed to it.
! 1.11	21-AUG-70	TKM	Changed out_sym_val to handle class DSC$K_DTYPE_SD
!				Added additional data types to out_typ_val
!					dsc$k_dtype_q,dsc$k_dtype_g,dsc$k_dtype_h
!					dsc$k_dtype_gc,dsc$k_dtype_hc
!				modified out_typ_val to handle decimal scaling
!				on data types where necessary
! 1.12	8-Nov-79	JBD	Changed call to DBG$PC_TO_LINE to handle 
!				statement numbers.
! 1.13	28-NOV-79	BAO 	Added support for override type.
! 1.14  17-dec-79	tkm	changed reference of dbgrst.req to rstreq.req
! 1.15	17-Dec-79	JBD	Made resymbolization for row major arrays
!				work (PUT_BOUNDS).
! 1.16	16-Jan-80	KAN	Changed PUT_LINE to find outermost BASIC
!				routine when resymbolizing a %line reference.
! 1.17	17-JAN-80	MCC	Corrected a bug in out_type_val concerning
!				scaling of array variables
! 1.18	24-JAN-80	KAN	Fixed dbg$out_typ_val to use dbg$gl_dflttyp
!				if it doesn't understand the input type field.
! 1.19	28-JAN-80	MCC	Fixed dbg$show_module to correctly format 31
!				character module names
! 1.20	 4-FEB-80	MCC	Fixed dbg$show_module to show actual number of bytes
!				used, instead of estimated.
! 1.21	 6-FEB-80	MCC	Fixed bug concerning displaying of offsets by
!				dbg$out_sym_val
! 1.22	29-FEB-80	ALA	Changed dbg$fao_put to deal with formating
!				output of a length longer than tty_out_width.
!				Changed dbg$pv_to_cs to accomodate this
!				change in dbg$fao_put by no longer truncating
!				at tty_out_width length pathnames.
! 1.23	23-Jun-80	DLP	Added version 3 error message return capability
! 1.24  18-Jun-81       PLS     In DBG$OUT_TYP_VAL, if there is no type info,
!                               if STATUS is reset to 0, then NT_PTR must be
!                               reset to 0 also
! 1.25  13-Jul-81	RT	In DBG$OUT_TYP_VAL, added cases for hex quadword
!				and octal quadword (formerly, quadwords were
!				always output in decimal regardless of
!				what mode was specified). Also, added case
!				for octa_word. 
! 3.01	10-Mar-82	RT	Made a change to PUT_BOUNDS to fix a bug in
!				the SHOW WATCH command.
!--

! TABLE OF CONTENTS:
!
FORWARD ROUTINE
	PUT_LINE,			! Symbolize %line references.
	PUT_BOUNDS,			! Symbolize an array reference.
	put_access_act,			! Symbolize a BLISS structure reference
	dbg$fao_put : NOVALUE,		! Stuff output into current output buffer.
	DBG$OUT_NUM_VAL : NOVALUE,	! Output of numeric values.
	DBG$OUT_PUT : NOVALUE,		! ACTUALLY WRITE OUT A LINE TO TTY.
	DBG$OUT_SYM_VAL : NOVALUE,	! Output values either in numeric
					! or in symbolic form.
	dbg$out_typ_val,		! outputs the typed contents of a location.
	decimal_scale:  NOVALUE,	! Do scaling on decimal 							! numbers fo
	DBG$READ_ACCESS,		! PROBE read accessability.
	DBG$SHOW_MODULE : NOVALUE,	! List off the module chain.
	DBG$SHOW_TYPE : NOVALUE,	! Print out the current TYPE.
	DBG$PRINT_PATH : NOVALUE,	! Print out a symbol pathname
	DBG$OUT_DIMENSN : NOVALUE;	! Build string of FORTRAN array bounds.
	
!
! REQUIRE FILES:
!

REQUIRE 'src$:dbgprolog.req';
REQUIRE 'SRC$:DBGGEN.REQ';
REQUIRE 'src$:sysser.req';
REQUIRE 'src$:bstruc.req';
REQUIRE 'src$:dbgmes.req';

!
! EQUATED SYMBOLS:
!


LINKAGE
	otscvtroutine =
		JSB (REGISTER=6,REGISTER=7,REGISTER=8,REGISTER=9) :
			NOPRESERVE(0,1,2,3,4,5,6,7,8,9) ;
GLOBAL
    	dbg$gb_signal_flag : byte initial(0); ! indicate to dbg$fao_put that a 
    				              ! signal is in effect

EXTERNAL ROUTINE
	dbg$npathdesc_to_cs : NOVALUE,
	dbg$rst_type,
	dbg$rst_name_addr,
	dbg$rst_name_count,
	dbg$out_regname,		! Symbolize register names
	dbg$language,			! Report on a given language name.
	dbg$find_val,			! Val_to_sym on DEFine symbols.
	DBG$PC_TO_LINE,			! FORTRAN PC correlation
	DBG$GET_BOUNDS : NOVALUE,	! Understand array descriptors.
	DBG$ADD_NT_2_PV,		! Build pathname vectors.
	DBG$REPORT_FREE,		! BYTES REMAINING IN FREE STORAGE.
	DBG$VAL_TO_SYM,			! Translate values to their
					!  symbolic equivalent.
	for$cvt_d_tg,			! converts double to ascii string
        for$cvt_g_tg,		        ! converts grand to ascii string
        for$cvt_h_tg,		        ! converts huge to ascii strging
	for$cnv_out_i,			! converts integer to ascii string.
	cob$cvtqp_r9 : otscvtroutine,	! Convert a quad word to packed
	DBG$SYMBOL_VALU,		! convert symbol 
					! name to value.
    	dbg$freez,			! Create space dynamically
    	dbg$freerelease,		! Release space dynamically allocated.
	dbg$octal_valtostg_cvt,
	dbg$decimal_valtostg_cvt,
	SYS$FAOL: ADDRESSING_MODE (ABSOLUTE);		! SYSTEM SERVICE TO DO FORMATTED OUTPUT.

EXTERNAL
	dbg$gb_no_globals : BYTE,
	dbg$gb_language : BYTE,			! current SET language encoding.
	dbg$cp_out_str: VECTOR[, BYTE],		! POINTS INTO CURRENT OUTPUT BUFFER.
	dbg$gb_mod_ptr: REF VECTOR[, BYTE],	! POINTS TO CURRENT I/O MODE SETTINGS.
	DBG$GB_STP_PTR: REF VECTOR[,BYTE],	! Pointer to STEP modes buffer
	dbg$gw_dfltleng : WORD,			! The length specified in a SET TYPE statement.
	dbg$gw_gbllngth : WORD,			! the length given in a SET TYPE/OVERRIDE ASCII:LENGTH command.
	dbg$gl_gbltyp,				! the type given in a SET TYPE/OVERRIDE command.
	dbg$gl_dflttyp,				! the type specified in a SET TYPE statement.
	dbg$gl_asci_len,			! the length of the ascii string to display
	dbg$gl_buf_siz,				! holds current character count in output buffer
	dbg$gl_last_val,			! the last value displayed
	rst$start_addr	: REF rst$entry,	! Pointer to the module chain (MC).	
	dbg$gl_lis_ptr,				! ptr to current element of command arg list
	dbg$gl_runframe : REF BLOCK[, BYTE],	! the stored user registers.
	dbg$gl_next_loc,			! next location to display
	dbg$gl_loctyp ,				! command override type
	dbg$gw_loclngth : WORD;			! override length

MACRO
	single_bit	= 0, 0, 1, 0%,
	byte_logical	= 0, 0, 8, 0%,
	word_logical	= 0, 0, 16, 0%,
	byte_integer	= 0, 0, 8, 1%,
	word_integer	= 0, 0, 16, 1%,
	longword_1	= 0, 0, 32, 0%,
	longword_2	= 4, 0, 32, 0%,
	longword_3	= 8, 0, 32, 0%,
	longword_4	= 12,0, 32, 0%,
	longword_5	= 16,0, 32, 0%,
	longword_6	= 20,0, 32, 0%,
	longword_7	= 24,0, 32, 0%,
	longword_8	= 28,0, 32, 0%,
	elif		= ELSE IF %;

	
BIND
	stg_desc_ascii	= UPLIT (%ASCIC '!AS'),
	comma_space	= UPLIT (%ASCIC ', '),
	open_parenth	= UPLIT (%ASCIC '('),
	closed_parenth	= UPLIT (%ASCIC ')'),
	cs_ascii	= UPLIT (%ASCIC '!AD');

LITERAL
	flting_buf_len	= 43,
	float_buf_len	= 15,
	dbl_buf_len	= 25,
	grand_buf_len	= 25,
	huge_buf_len	= 42,
	float_fra_dig	= 7,
	dbl_fra_dig	= 16,
	grand_fra_dig	= 15,
	huge_fra_dig	= 33,
	digits_in_int	= 1,
	scale_factor	= 0,
	float_exp_dig	= 2,
	dbl_exp_dig	= 2,
	grand_exp_dig	= 3,
	huge_exp_dig	= 4;

OWN
	ang_bracket	;	! 1 if <> present, 0 if not

GLOBAL ROUTINE dbg$fao_put( buffer, STRING, ARGUMENTS ) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION
!	DO JUST WHAT $FAO DOES, ONLY HERE WE WORK IN
!	CO-OPERATION WITH A GLOBAL CHARACTER BUFFER INTO
!	WHICH WE ARE ENCODING ARBITRARY LINES OF OUTPUT.
!
!	All console output done within DEBUG should use this
!	routine to build output lines.  The only other 
!	I/O call which DEBUG should be making (for the console)
!	is to DBG$OUT_PUT, which simply says "put out whatever
!	dbg$fao_put built".
!
!	If the buffer reaches tty_out_width length, it is forced
!	out to the terminal immediately and another buffer is
!	started with whatever further output was required to be
!	formatted. This means that although the output buffer is
!	currently implemented as a local buffer for each routine,
!	one must treat it as if it were a global output buffer
!	or output will come out of the debugger in a random format.
!
!
! INPUTS:
!	STRING	  - A COUNTED STRING WHICH CONTAINS THE DIRECTIVES FOR $FAO.
!	ARGUMENTS - THE ARGS FOR $FAO.
!	buffer	  - The address of the beginning of the current output buffer.
!
! IMPLICIT INPUTS:
!	dbg$cp_out_str	- POINTER TO WHERE WE ARE IN THE
!			CURRENT OUTPUT BUFFER.
!	dbg$gl_buf_siz	- count of characters in output buffer.
!
! OUTPUTS:
!	THE $FAO OUTPUT IS PUT INTO THE OUTPUT BUFFER.
!
! IMPLICIT OUTPUTS:
!	THE GLOBAL CHARACTER POINTER IS INCREMENTED SO THAT IT
!	POINTS (AS ALWAYS) TO THE NEXT AVAILABLE PLACE IN THE
!	OUTPUT BUFFER. The buffer count variable is incremented
!	by the size of this string.
!
! ROUTINE VALUE:
!	NONE.
!
! SIDE EFFECTS:
!	The current output buffer may be outputed to the terminal
!	one or more times if it is about to overflow in length, 
! 	otherwise, the output buffer is just added to.
!--

	BEGIN
	MAP
		STRING : REF VECTOR[,BYTE];	! The string to be formatted
    						! for output
	LOCAL
		INP_DESC : VECTOR[2],		! INPUT DESC FOR $FAO.
		OUT_DESC : VECTOR[2],		! OUTPUT DESC FOR $FAO.
		STR_SIZE : WORD,		! $FAO RETURNS OUTPUT SIZE HERE
    		temp_out_buf : REF VECTOR[,BYTE], ! Temporary place to format
    						! new additions to the output
    						! buffer.
    		success_alloc,			! Flag to tell if we could
    						! successfully allocate space.
    		space_needed,			! The amount of dynamically
    						! allocated space needed for
    						! output buffer.
    		not_enough_space,		! Determines when enough space
    						! to format output was given
    						! to FAOL call.
    		status_faol,			! Determines the result of
    						! the sys$faol call.
    		dest_ptr,			! Pointer to address where 
    						! we are in temp_out_buf
    		ind_temp_buf,			! Index into temp_out_buf
    		cur_temp_size,			! The initial size of the
    						! dynamic output buffer
    		char_to_move;			! The number of characters
    						! to move.



	!+
	! BUILD THE DESCRIPTORS THAT $FAO WANTS, ASK IT TO DO
	! THE ENCODING, COPYING THE OUTPUT INTO OUR GLOBAL
	! OUTPUT BUFFER, AND FINALLY UPDATE THE GLOBAL POINTER
	! TO THE NEXT FREE CHARACTER POSITION IN THE BUFFER.
	!-

	INP_DESC[0] = .STRING[0];
	INP_DESC[1] = STRING[1];




    		! Set up for temporary buffer

    		space_needed = tty_out_width + 1;
    		success_alloc = 1;

    		DO BEGIN
    			not_enough_space = 0;
    			
    			!+
    			! While not enough (or any) space for output from
    			! impending FAOL call, create the space.
    			!-


    			! Note that the space needed is in long words in
    			! this routine

    			temp_out_buf = dbg$freez( (.space_needed/%UPVAL)+1,
    							.success_alloc);

    			! Check if we can't allocate enough free space

    	
    			IF .temp_out_buf EQL 0 THEN signal(dbg$_nofree)
    			ELSE BEGIN


    				 ! finish setting up for sys$faol call

    				 ! address of start of output buffer
		
    				 out_desc[1] = .temp_out_buf; 

    				 ! size of output buffer for sys$faol's use

    				 out_desc[0] = .space_needed; 

  
    				status_faol = sys$faol( inp_desc, str_size,
    						       out_desc, arguments);


    				!+
    				! Was sys$faol successful?
    				! 
    				! Check for bad return
    				!-

    				IF .status_faol NEQ ss$_normal THEN
    				    BEGIN

    					!+
    					! Was it an invalid sys$faol
    					! directive--should never happen
    					!-


    					IF .status_faol EQL ss$_badparam
    					THEN SIGNAL(dbg$_debugbug,1,
						dbg$k_sys$faol_badparam)

    					!+
    					! Was it an overflowed buffer? We
    					! can recover from this
    					!-
    				
    					ELSE IF .status_faol EQL ss$_bufferovf
    					     THEN BEGIN


    						      ! Get rid of temp.
    						      ! buffer and try again

    						      dbg$freerelease(.temp_out_buf,
    							(.space_needed/%UPVAL)+1);
    						      space_needed = .space_needed
    							+ tty_out_width;
    						      not_enough_space = 1;
    						  END

    					     ! unknown error
    					     
    					     ELSE
						SIGNAL(dbg$_debugbug,1,
						dbg$k_sys$faol_badparam);
    			      END;
    			  END;
    		    END
    		UNTIL NOT .not_enough_space;


    		dest_ptr = .temp_out_buf; ! set up pointer to temporary buffer
    		ind_temp_buf = 0;	 ! and index to temporary buffer



    		IF (.dbg$gl_buf_siz LSS (tty_out_width - 1)) THEN
    		    BEGIN
    			cur_temp_size = .str_size;
    			WHILE .ind_temp_buf LSS .str_size DO
    			    BEGIN

    				char_to_move = (tty_out_width-1) - .dbg$gl_buf_siz;
    				


    				!+
    				! If less than the maximum number of characters
    				! to move, then move all that are in the 
    				! temporary buffer
    				!-

    				IF .char_to_move GTR .cur_temp_size THEN
    					char_to_move = .cur_temp_size;


    				!+
    				! update the output buffer pointer and size of
    				! output buffer plus the pointer to where we're
    				! at in the temporary buffer
    				!-


    				dbg$cp_out_str = ch$move(.char_to_move,
    						 .dest_ptr, .dbg$cp_out_str);


    				dbg$gl_buf_siz = .dbg$gl_buf_siz + .char_to_move;
    				ind_temp_buf = .ind_temp_buf + .char_to_move;

    				dest_ptr = .temp_out_buf + .ind_temp_buf;


    				IF .dbg$gl_buf_siz EQL (tty_out_width -1)
    				THEN BEGIN

    					 ! If this is a signal then
    					 ! truncate at tty_out_width

    					 IF dbg$gb_signal_flag 
    					 THEN EXITLOOP;

    					 dbg$out_put(.buffer);
    					 dbg$gl_buf_siz = 0;
    					 dbg$cp_out_str = .buffer + 1;

    					 cur_temp_size = .cur_temp_size - 
    							.char_to_move;
	  	
    				     END;
    			    END;
    			END;


         dbg$freerelease(.temp_out_buf, (.space_needed/%UPVAL) + 1);

END;


GLOBAL ROUTINE DBG$OUT_NUM_VAL ( buffer, VALUE, NEW_LENGTH, NEW_RADIX ) : NOVALUE =
!++
! Functional Description:
!	Write out the given value according to the
!	current output mode settings.  (By write out,
!	we mean 'encode into the output buffer').
!	Ignore the [NO]SYMBOLS mode setting to simply
!	assure numeric output.
!
! Inputs:
!	VALUE - the actual value we are to write out.
!	NEW_LENGTH - either 0, or the MODE_LENGTH we should use.
!		     (0 => use current LENGTH, non-zero allows
!		      it to be overridden.)
!		     (The literal, NO_OVERRIDE = 0, is used for this.)
!	NEW_RADIX - either 0, or the MODE_RADIX we should use.
!	unsigned_flag - optional argument which determines whether to
!			treat decimal radix as signed or unsigned. Used
!			by dbg$out_sym_val to symbolize offsets.
!	buffer	      - The output buffer.
!
! Implicit Inputs:
!	dbg$cp_out_str - points into the output buffer at the first
!			 place in the buffer which is available.
!	dbg$gl_buf_siz - holds the current number of characters in
!			 the buffer.
!	dbg$gl_loctyp  - Command override type
!	dbg$gl_gbltyp  - Global override type
!	dbg$gl_dflttyp - holds default type
!
! Outputs:
!	The (numeric) character representation
!	of the value is encoded into the output buffer.
!
! Implicit Outputs:
!	The buffer pointer, dbg$cp_out_str, is incremented.  
!	The buffer count, dbg$gl_buf_siz, is incremented.
!
! Routine Value:
!	NOVALUE.
!
! Side Effects.
!	A leading 0 is output before HEX numerics which start with A-F
!---
BEGIN
	BUILTIN
		ACTUALCOUNT,
		ACTUALPARAMETER;
	MAP
				! We want to look at the passed-in value
				! as a byte vector only to see if we may
				! need to put in a leading 0 for hex output.
		value : vector[ %UPVAL, byte ];
	LOCAL
		unsigned_flag,		
		USE_LENGTH,	! THE MODE_LENGTH WE ACTUALLY USE.
		USE_RADIX;	! THE MODE_RADIX WE ACTUALLY USE.
	OWN
		format : VECTOR[4,BYTE]	! BUILD FORMAT STRING HERE.
			 INITIAL( BYTE( %ASCIC '!??' ) );

	! pick up optional argument if there is one

	IF ACTUALCOUNT() GTR 4
	THEN
		unsigned_flag = ACTUALPARAMETER(5)
	ELSE
		unsigned_flag = 0;

	! Assume that we are passed an override for
	! the LENGTH and RADIX, but revert to the
	! globally-set one if this is untrue.



	IF( (USE_LENGTH = .NEW_LENGTH) EQL 0 )
	THEN
		USE_LENGTH = (CASE (IF .dbg$gl_loctyp NEQ -1
				    THEN .dbg$gl_loctyp
				    ELSE
					IF .dbg$gl_gbltyp NEQ -1
					THEN
					   .dbg$gl_gbltyp
					ELSE
					   .dbg$gl_dflttyp)

				    FROM dsc$k_dtype_b
				    TO   dsc$k_dtype_l
				 OF
				 SET

				 [dsc$k_dtype_b] : byte_length;
				 [dsc$k_dtype_w] : word_length;
				 [INRANGE,OUTRANGE] : long_length;

				 TES);

	IF( (USE_RADIX = .NEW_RADIX) EQL 0 )
	THEN
		USE_RADIX = .dbg$gb_mod_ptr [ MODE_RADIX ];

	!+
	! -Now just build the required 2-character format
	!  string descriptor, based upon the current
	!  setting of the mode LENGTH and RADIX.
	!
	! -We assume SIGNED, for DECimal output, unless an optional 
	! argument was supplied and
	!  take LONGword HEXadecimal either when that
	!  is explicitly the case, or when some unknown
	!  LENGTH or RADIX is indicated.
	!-

	FORMAT[2] = ( SELECTONE .USE_RADIX OF
			SET
			[OCTAL_RADIX]:		'O';
			[DECIMAL_RADIX]: IF .unsigned_flag THEN 'U' ELSE 'S';
			[OTHERWISE]:		'X';
			TES
		    );


	FORMAT[3] = ( SELECTONE .USE_LENGTH OF
			SET
			[BYTE_LENGTH]:	'B';
			[WORD_LENGTH]:	'W';
			[OTHERWISE]:	'L';
			TES
		    );


	! Check for hex output which begins with A-F
	
	IF( .use_radix EQL HEX_RADIX )
	then
		! Perform the check by extracting the upper BYTE of
		! what we will later output, comparing that byte with
		! the max hex number we will print out 'unadorned',
		! and then inserting a leading 0 if the check fails.

		IF( .value[.use_length-1] GTRA %X'9F' )
		then
			dbg$fao_put( .buffer, UPLIT( %ASCIC '0' ));
		
	! Output the value and we're done.

	dbg$fao_put ( .buffer, FORMAT, .VALUE);
END;

GLOBAL ROUTINE DBG$OUT_PUT ( BUFFER ) : NOVALUE =
!++
! Functional Description:
!	Cause the current output buffer to be actually
!	output to the console.
!
! Inputs:
!	BUFFER - pointer to the beginning of the current output
!		buffer.  this is supposed to be a counted
!		string except that noone has supplied the count yet.
!		ie we expect that the actual string to be printed
!		starts in byte BUFFER+1.
!
! Implicit Inputs:
!	dbg$cp_out_str - points into this output buffer at the first
!			 place in the buffer which is NOT to be printed.
!	dbg$gl_buf_siz - holds count of characters in buffer
!
! Outputs:
!	The string is printed, exactly as it is in the
!	buffer - ie, it should contain whatever carriage control 
!	you want.
!
! Implicit Outputs:
!	The buffer pointer, dbg$cp_out_str, is set to zero.  This will
!	help routines know if they are to use their own buffer or
!	if one is already partially built.
! ***	I don't think we have ever actually used the above
!	'feature', and feel that this routine ought, instead, set
!	up for more dbg$fao_put calls on the current buffer when we
!	are called to output it.
!
! Routine Value:
!	NOVALUE.
!
! Side Effects.
!	none.
!--

	BEGIN
	MAP
		BUFFER : REF VECTOR[,BYTE];	! POINTS TO OUTPUT BUFFER.


	! Fill in the count, and pass it to QIO.

	BUFFER [0] = .dbg$gl_buf_siz;
	$FAO_TT_OUT ( '!AC', .BUFFER );
	dbg$cp_out_str = 0;
	END;

GLOBAL ROUTINE DBG$OUT_SYM_VAL ( VALUE, OVER_LENGTH, symbol_nt_ptr, buffer ) 
    								: NOVALUE =
!++
! Functional Description:
!	Write out the given value according to the current
!	mode settings - including the current mode setting
!	for the [NO]SYMBOLS flag.  (By 'write out', we mean
!	'encode into the output buffer').
!
! Inputs:
!	VALUE - the actual value we are to write out.
!	OVER_LENGTH -   If non-zero, then we are outputting an instruction
!			or watchpoint entity. Therefore, do not emit '<xxx>'
!			for BLISS. If 0, then emit '<xxx>', if appropriate.
!	symbol_nt_ptr	-Either 0, or the supposed NT_PTR which the
!			 VALUE came from in the first place.
!	buffer		- Contains the address of the output buffer.
!
! Implicit Inputs:
!
!	If OUT_SYM_VAL is called, no radix override is desired
!	if we have to resort to numeric output.
!
!	dbg$gb_mod_ptr - points to the current mode data structure.
!	dbg$cp_out_str - points into the output buffer at the first
!			 place in the buffer which is available.
!	dbg$gl_buf_siz - holds the current number of characters in
!			 the buffer.
!
! Outputs:
!	The symbolic or numeric (or symbolic+residue) representation
!	of the value is encoded into the output buffer.
!
! Implicit Outputs:
!	The buffer pointer, dbg$cp_out_str, is incremented.  
!	The buffer count, dbg$gl_buf_siz, is incremented.
!
! Routine Value:
!	NOVALUE.
!
! Side Effects.
!	The VALUE is printed out.
!--
	BEGIN
	MAP
		symbol_nt_ptr : ref rst$entry;
	LOCAL
		new_length,     ! Used for offsets

		array_desc_addr,! The address of an array descriptor,
				! if we symbolize an array reference.

		NT_PTR : REF rst$entry,
				! A pointer to the name table (NT) entry
				! which corresponds to the symbol which we
				! deal with if we do symbolic output.

		real_value,	! Used to recover the actual or real value
				! of the symbol we may base our symbolic
				! output off.

		MODPTR: REF RST$ENTRY,	! Pointer to label's Module RST Entry

		ROUTPTR: REF RST$ENTRY,	! Pointer to label's Routine RST Entry

		PATH_VEC : pth$pathname;
				! Symbol path vector used to contain the
				! whole pathname assocaited with the
				! symbol pointed to by NT_PTR, above.


ang_bracket = 0;		! Initialize angle bracket flag
new_length = long_length;

! First, see if the value is an exact match to a DEFine
! type symbol.  Note that these symbols have nothing to do with
! the so-called RST and so much be handled specially.

IF .dbg$gb_mod_ptr[ mode_symbols ]
THEN
	BEGIN
	LOCAL
		index;

	IF( (INDEX = DBG$FIND_VAL(.VALUE,TRUE)) NEQ 0 )
	THEN
		BEGIN

		! Found an exact match.  Print this and
		! return an OK status.

		dbg$fao_put( .buffer, uplit(%ascic '!AD'), 
    				.sym_chcount(.index),sym_name(.index));
		RETURN;
		END;
	END;

!+
! Then, see if the value is an exact match to a register name
! symbol.  Note that these symbols have nothing to do with
! the so-called RST and so much be handled specially.  Also
! note that this symbolization is done whether or not
! the MODE is SYMBOLIC, unless the value we are
! to symbolize came from some other RST symbol.
!-

IF NOT .dbg$gb_mod_ptr[ MODE_SYMBOLS ]
OR .symbol_nt_ptr EQL 0
THEN
	IF( dbg$out_regname( .buffer, .value) )
	THEN
		! An exact match was found and output so we're done.

		RETURN;

!+
! Now we try to symbolize based on the RST.  The are two
! flavors here, either we have to work things out from
! scratch, or someone has passed us a hint of where to
! start from.  This is indicated by symbol_nt_ptr.
!-

IF .dbg$gl_lis_ptr NEQ 0
THEN
    IF .list_elem_ref (.dbg$gl_lis_ptr)
		AND
       (.list_elem_dot (.dbg$gl_lis_ptr)
		    OR
        .list_elem_args (.dbg$gl_lis_ptr) NEQ 0)
		
    THEN
	symbol_nt_ptr = 0;

array_desc_addr = 0;
nt_ptr = 0;

IF( .symbol_nt_ptr EQL 0 )
THEN
	BEGIN

	! Next, ask VAL_TO_SYM for the NT-pointer which
	! corresponds to the symbol we should use.
	
	IF( NOT DBG$VAL_TO_SYM( .VALUE, NT_PTR ) )
	THEN
	    nt_ptr = 0;
	END
ELSE
	! We graciously accept the given hint.

	nt_ptr = .symbol_nt_ptr;

!+
! At this point, nt_ptr either tells us where to start from,
! or it being 0 tells us not to bother.  Likewise we don't
! bother to symbolize if the MODE says not to.
!-

IF( .dbg$gb_mod_ptr[ MODE_SYMBOLS ] )
THEN
	IF( .nt_ptr NEQ 0 )
	THEN
		! Then, to be able to output "symbol+offset",
		! we must be able to recover the actual value
		! of the indicated symbol.


		IF dbg$symbol_valu (.nt_ptr, real_value)
		THEN
			BEGIN

			! See if the value picked up by DBG$SYMBOL_VALU is
			! really the address which is bound to the
			! symbol, or if it is the address of a descriptor.
			! Note that DST_PTR is invalid for NTs which
			! were created only for global symbols.

			IF( NOT .nt_ptr[rst$v_global] )
			AND (.nt_ptr[rst$b_kind] NEQ rst$k_module)
			THEN
				BEGIN
				LOCAL
					bounds : array_bnds_desc,
					dst_recrd : REF dst$record;

				! Pick up the DST pointer so that we can see
				! if access is via descriptor.  

				DST_RECRD = .NT_PTR[rst$l_dstptr];

			        IF( .DST_RECRD[ dst$v_valkind ] EQL dst$k_valkind_desc)
				THEN
					BEGIN

					! REAL_VALUE, returned above, is actually
					! the address of a descriptor.  Modify this
					! value to be the beginning virtual address
					! of the array.

					array_desc_addr = .real_value;
					dbg$get_bounds( .array_desc_addr, bounds );
    					real_value = .bounds[ array_address ];
					END;
				END;


			! If the symbol we found is a label whose address does
			! not match the VALUE address exactly, we really would
			! like to symbolize the address as ROUTNAME\%LINE nn
			! if this module has line number information.  In other
			! words, if we can symbolize to a line number, we will
			! do so unless we symbolize to a label exactly.  Here
			! we will change NT_PTR to point to the Routine RST
			! Entry instead of the Label RST Entry in this case.
			! We treat entry points and lexical blocks the same as
			! labels in this regard.
			!
			IF (.NT_PTR[RST$B_KIND] EQL RST$K_LABEL OR
			    .NT_PTR[RST$B_KIND] EQL RST$K_ENTRY OR
			    .NT_PTR[RST$B_KIND] EQL RST$K_BLOCK) AND
			   (.REAL_VALUE NEQ .VALUE)
			THEN
			    BEGIN
			    ! Get the RST pointer for the routine which contains
			    ! the current label.  Note that in MACRO, there will
			    ! not be any such routine so we leave NT_PTR alone.
			    !
			    ROUTPTR=.NT_PTR[RST$L_UPSCOPEPTR];
			    WHILE .ROUTPTR[RST$B_KIND] EQL RST$K_LABEL OR
				  .ROUTPTR[RST$B_KIND] EQL RST$K_ENTRY OR
				  .ROUTPTR[RST$B_KIND] EQL RST$K_BLOCK
			    DO
				ROUTPTR = .ROUTPTR[RST$L_UPSCOPEPTR];

			    IF .ROUTPTR[RST$B_KIND] EQL RST$K_ROUTINE
			    THEN
				BEGIN


				! Get the RST pointer for the module which con-
				! tains this routine.
				!
				MODPTR = .ROUTPTR;
				WHILE .MODPTR[RST$B_KIND] NEQ RST$K_MODULE DO
				     MODPTR = .MODPTR[RST$L_UPSCOPEPTR];


				! If this module has Line Number PC-Correlation
				! DST records, change NT_PTR to point to the
				! Routine RST Entry and also change REAL_VALUE
				! to have that routine's start address.  This
				! will later cause the symbolization to come out
				! as ROUTNAME\%LINE nn.
				!
				IF .MODPTR[RST$W_NUMPCTBLS] NEQ 0
				THEN
				    BEGIN
				    NT_PTR = .ROUTPTR;
				    REAL_VALUE = .ROUTPTR[RST$L_STARTADDR];
				    END;

				END;

			    END;


			! For unbounded symbols, we don't
			! allow "symbol+offset" unless "offset"
			! is less than a maximum value.
			!
			IF (.VALUE - .REAL_VALUE) LSSA RST_MAX_OFFSET
			OR  .NT_PTR[rst$v_nonzlength]
			THEN
				BEGIN

				! We have all we need now, so just
				! encode the characters into the
				! output stream. To do this we
				! must first build a pathname vector
				! to correspond to the NT scope chain we
				! implicitly now have.

				path_vec[pth$b_pathcnt] = 0;
				path_vec[pth$b_totcnt] = 0;
				path_vec[pth$l_invocnum] = 0;
				path_vec[pth$b_locinvoc] = 0;
				dbg$add_nt_2_pv( .nt_ptr, path_vec );

				! Then we simply print this vector.
				!
				dbg$print_path( path_vec, .buffer );


				! Extra symbolization for arrays if the language
				! is not MACRO or BLISS.
				!
				IF .dbg$gb_language NEQ lang_macro
						AND
				   .dbg$gb_language NEQ lang_bliss
				THEN
				    BEGIN
				    IF (.ARRAY_DESC_ADDR NEQ 0
					     AND
					( .dbg$gb_language EQL lang_fortran
							OR
					  .dbg$gb_language EQL lang_basic
							OR
					  .dbg$gb_language EQL lang_cobol))
				    THEN
      					BEGIN
       					LOCAL
      					    watch_flag;
       					! If the variable OVER_LENGTH is 
       					! non-zero, we are outputting a
      					! watchpoint. Set watch_flag
       					! to indicate this.
       					watch_flag = .over_length NEQ 0;
   					real_value = put_bounds( .value, 
     							.array_desc_addr, 
      							  .buffer,
       							    .watch_flag);
       					END;
				    END;


				! Symbolize to line numbers unless the STEP mode
				! is INSTRUCTION in language MACRO or BLISS.
				! "\%LINE nn" can only follow a Routine symbol.
				!
				IF (.DBG$GB_LANGUAGE NEQ LANG_MACRO AND
				    .DBG$GB_LANGUAGE NEQ LANG_BLISS) OR
				   .DBG$GB_STP_PTR[STEP_LINE]
				THEN
				    BEGIN
			    	    IF .nt_ptr[rst$b_kind] EQL rst$k_routine
				        AND NOT .nt_ptr[rst$v_global]
				    THEN
					Real_value = put_line( .nt_ptr,
    						.value, .real_value, .buffer );

				    END;


				! Extra symbolization for BLISS structure references
				!
				IF .dbg$gb_language EQL lang_bliss
				THEN
				    BEGIN
				    LOCAL
					blz_recrd : REF blz_record;

				    IF dbg$rst_type(.nt_ptr) EQL dsc$k_dtype_z
				    THEN
					BEGIN
					blz_recrd = .nt_ptr[rst$l_dstptr];
					IF .blz_recrd[blz_struct] NEQ 0
					THEN
					    real_value = put_access_act(.value,
    						.real_value, .blz_recrd, 
    							.buffer);
					END;
				    END;

				!+
				! See if there is any residue - i.e. see if
				! "symbol", "symbol %line NN ", or "symbol(x,y,z)"
				! is enough, or if we need to add "+offset".
				!-
				IF .VALUE EQL .REAL_VALUE
				THEN
					! No residue, symbolize angle brackets
					! (if necessary) and we're done.

					BEGIN
					LOCAL
					     no_fld_ref;
					IF .dbg$gl_lis_ptr NEQ 0
					THEN
					     no_fld_ref = .list_elem_fldrf(.dbg$gl_lis_ptr)
					ELSE
					     no_fld_ref = 0;
					IF .dbg$gb_language EQL lang_bliss
						       AND
					   .over_length EQL no_override
					THEN	
					    BEGIN
					    LOCAL
						pos,
						size,
						ext_flag,
						ext;
					    ext_flag = true;
					    IF .no_fld_ref EQL 0
					    THEN
						BEGIN
						pos = 0;
						ext = 1;
						SELECTONE TRUE
						    OF
						    SET

						    [.dbg$gl_loctyp NEQ -1] :
						        BEGIN
							size = 0;
							END;

						    [.dbg$gl_gbltyp NEQ -1] :
							BEGIN
							size = %BPUNIT *
							(CASE .dbg$gl_gbltyp 
								FROM dsc$k_dtype_b
								TO   dsc$k_dtype_zi
							    OF
							    SET

							    [dsc$k_dtype_b] : 1;
							    [dsc$k_dtype_w] : 2;
							    [dsc$k_dtype_l] : 4;
							    [dsc$k_dtype_t] :
								BEGIN
								ext_flag = false;
								.dbg$gw_gbllngth
								END;
							    [INRANGE,OUTRANGE] : 0;
							    TES);
						    	END;

						    [OTHERWISE] :
							BEGIN
							size = 0;
							END;
						    TES;
						END
					    ELSE
						BEGIN
						pos = .list_elem_pos(.dbg$gl_lis_ptr);
						size = .list_elem_size(.dbg$gl_lis_ptr);
						ext = .list_elem_ext(.dbg$gl_lis_ptr);
						END;
					    IF (.size GTR 0 AND .size LEQ %BPVAL)
							     OR
					       (.no_fld_ref NEQ 0)
					    THEN
						BEGIN
					    	dbg$fao_put( .buffer, 
    							    UPLIT(%ASCIC '<'));
					    	dbg$out_num_val(.buffer, .pos, 
    								long_length, 
    								decimal_radix);
					    	dbg$fao_put( .buffer,
    							UPLIT(%ASCIC ','));
					    	dbg$out_num_val(.buffer, .size, 
    							     long_length, 
    							     decimal_radix);
						IF .ext_flag
						THEN
						    BEGIN
						    dbg$fao_put( .buffer,
    							UPLIT(%ASCIC ','));
						    dbg$out_num_val(.buffer, 
    							.ext, long_length, 
    							decimal_radix);
						    END;
					    	dbg$fao_put( .buffer,
    						    UPLIT(%ASCIC '>'));
						END;
					    END;
				    RETURN;
					END;

				! The residue (offset) should
				! be printed in numeric form, preceeded
				! by a '+'.

				dbg$fao_put( .buffer, UPLIT(%ASCIC '+'));

				value = .value-.real_value;

				! We should be able to simply
				! drop out of this part of the
				! code and have this done by DBG$OUT_NUM_VAL.
				! Until FAO can print HEX without the leading
				! 0s, we must do the following...


				IF .value<16,16,0> NEQ 0
				THEN
					new_length = 4
				ELSE
					IF .value<8,8,0> NEQ 0
					THEN
						new_length = 2
					ELSE
						new_length = 1;
				END;
			END;

! At this point, we didn't try to do symbolic output, or
! we failed completely at it, or
! it went OK but we still have a 'residue'. 
! Therefore we still have a value to output before we're done.

dbg$out_num_val( .buffer, .value, .new_length, no_override, true);

! Output angle brackets if necessary

BEGIN
LOCAL
	no_fld_ref;
IF .dbg$gl_lis_ptr NEQ 0
THEN
	no_fld_ref = .list_elem_fldrf(.dbg$gl_lis_ptr)
ELSE
	no_fld_ref = 0;
IF .dbg$gb_language EQL lang_bliss
		AND
   .over_length EQL no_override
THEN	
    BEGIN
    LOCAL
	pos,
	size,
	ext_flag,
	ext;
    ext_flag = true;
    IF .no_fld_ref EQL 0
    THEN
	BEGIN
	pos = 0;
	ext = 1;
	SELECTONE TRUE
	    OF
	    SET

	    [.dbg$gl_loctyp NEQ -1] :
	        BEGIN
		size = 0;
		END;

	    [.dbg$gl_gbltyp NEQ -1] :
		BEGIN
		size = %BPUNIT *
		(CASE .dbg$gl_gbltyp 
			FROM dsc$k_dtype_b
			TO   dsc$k_dtype_zi
		    OF
		    SET

		    [dsc$k_dtype_b] : 1;
		    [dsc$k_dtype_w] : 2;
		    [dsc$k_dtype_l] : 4;
		    [dsc$k_dtype_t] : 
			BEGIN
			ext_flag = false;
		        .dbg$gw_gbllngth
			END;
		    [INRANGE,OUTRANGE] : 0;
		    TES);
	    	END;

	    [OTHERWISE] :
		BEGIN

		LOCAL
		    status,
		    local_nt_ptr : REF rst$entry,
		    local_value;

		! We must duplicate the test used by dbg$out_typ_val to see
		! if the default type will be used to type the result.
		! We emit <...> only if the default type is used.
		! We start off by assuming that the default size (and type) will
		! be used.
		
		size = %BPUNIT * 
		(CASE .dbg$gl_dflttyp 
			FROM dsc$k_dtype_b
			TO   dsc$k_dtype_zi
		    OF
		    SET

		    [dsc$k_dtype_b] : 1;
		    [dsc$k_dtype_w] : 2;
		    [dsc$k_dtype_l] : 4;
		    [dsc$k_dtype_t] : 
			BEGIN
			ext_flag = false;
			.dbg$gw_dfltleng
			END;
		    [INRANGE,OUTRANGE] : 0;
		    TES);

		! Now perform the same tests as out_typ_val
		
		IF .symbol_nt_ptr EQL 0
		THEN
		    BEGIN
		    dbg$gb_no_globals = true;
		    status = dbg$val_to_sym (.value, local_nt_ptr, false);
		    dbg$gb_no_globals = false;
		    IF .status
		    THEN
			IF dbg$symbol_valu(.local_nt_ptr, local_value)
			THEN
			    IF (.value EQL .local_value)
					OR
				.local_nt_ptr[rst$v_nonzlength]
			    THEN
				size = 0;
		    END
		ELSE
		    size = 0;
		END;
	    TES;
	END
    ELSE
	BEGIN
	pos = .list_elem_pos(.dbg$gl_lis_ptr);
	size = .list_elem_size(.dbg$gl_lis_ptr);
	ext = .list_elem_ext(.dbg$gl_lis_ptr);
	END;

    IF (.size GTR 0 AND .size LEQ %BPVAL)
		    OR
       (.no_fld_ref NEQ 0)
    THEN
    	BEGIN
    	dbg$fao_put( .buffer, UPLIT(%ASCIC '<'));
    	dbg$out_num_val(.buffer, .pos, long_length, decimal_radix);
    	dbg$fao_put( .buffer, UPLIT(%ASCIC ','));
    	dbg$out_num_val(.buffer, .size, long_length, decimal_radix);
	IF .ext_flag
	THEN
	    BEGIN
            dbg$fao_put( .buffer, UPLIT(%ASCIC ','));
            dbg$out_num_val(.buffer, .ext, long_length, decimal_radix);
	    END;
    	dbg$fao_put( .buffer, UPLIT(%ASCIC '>'));
	END;
    END;
END;
END;




ROUTINE PUT_LINE( NT_PTR, PC_IN_RTN, PC_BEGIN_RTN, buffer ) =
!++
! Functional Description:
!
!	See if we are outputting a FORTRAN %line symbolization,
!	and output the %line part of it if this is so.
!
! Formal Parameters:
!
!	NT_PTR		-A pointer to the name table record
!			 for the symbol we are offsetting from
!	PC_IN_RTN	-The PC in the indicated routine,
!	PC_BEGIN_RTN	-The PC value at the beginning of the routine.
!
! Implicit Inputs:
!
!	The output buffer has been initialized and
!	the pathname of the routine we are %LINE-ing from
!	has been encoded into it.
!
! Implicit Outputs:
!
!	The output buffer is filled in unless this is
!	not a %line reference.
!
! Routine Value:
!
!	The real PC value of the %line we put out,
! OR
!	the value of what has been symbolized so far
!	if no %line symbolization was done herein.
!
! Side Effects:
!
!	The output buffer may be filled in. (see above)
!--
BEGIN
	LOCAL
		STMT_1,		! The %LINE statment number we will output.
		line_1,		! The %line number we will put out.
		line_1_pc,	! The PC value for LINE_1
		real_value,	! The PC value for the outermost routine
				! containing a BASIC %LINE #.
		new_nt_ptr : ref rst$entry,	! NT pointing to outermost rtn.
		temp_nt_ptr : ref rst$entry,	! Used for finding new_nt_ptr.
		exc_type;

	! If the PC we're at is exactly the same at
	! the beginning of the routine, then there
	! is no %LINE symbolization.

	IF( .pc_in_rtn EQLA .pc_begin_rtn )
	THEN
		RETURN(.pc_begin_rtn);

	! If we are in BASIC, our pc-correlation is 'global.'
	! Therefore, we want to compute a line number from the
	! outermost routine in the current nt chain.

	IF .dbg$gb_language EQL lang_basic
	THEN
		BEGIN
		temp_nt_ptr = .nt_ptr;
		DO
			BEGIN
			IF .temp_nt_ptr[rst$b_kind] EQL rst$k_module
			THEN EXITLOOP;
			IF .temp_nt_ptr[rst$b_kind] EQL rst$k_routine
			THEN
				new_nt_ptr = .temp_nt_ptr;
			temp_nt_ptr = .temp_nt_ptr[rst$l_upscopeptr];
			END
		UNTIL (.temp_nt_ptr EQL 0);


		IF dbg$symbol_valu(.new_nt_ptr, real_value)
		THEN
			BEGIN
			pc_begin_rtn = .real_value;
			END;
		END;

	! A DPC routine does most of the work.
	! We just do the initializations and check
	! the return status.

	line_1_pc = .nt_ptr;
	exc_type = lookup_exc;
	stmt_1 = 0;

	IF NOT dbg$pc_to_line (.pc_in_rtn, .pc_begin_rtn, .exc_type, line_1, 
		stmt_1, line_1_pc)
	THEN		! No %line symbolization is possible.
		RETURN(.pc_begin_rtn);

	IF .stmt_1 EQL 0 OR .stmt_1 EQL 1
	THEN dbg$fao_put( .buffer, uplit(%ascic '\%LINE !UL '), .line_1 )
	ELSE dbg$fao_put( .buffer, UPLIT(%ASCIC '\%LINE !UL.!UL'), 
    				 .line_1, .stmt_1);

	! Return the PC value of the %LINE we just
	! output.

	RETURN(.line_1_pc);
END;

ROUTINE PUT_BOUNDS( in_array, descrip_block, out_buf, watch_flag) =
!++
! Functional Description:
!
!	Put the description of the given array reference
!	into the current output buffer in the form "(X1, X2, ... Xn)",
!	or symbolize a given CHARACTER [sub-]string reference
!	using the form "(begin_position : end_position)".
!
! Formal Parameters:
!	IN_ARRAY	-address, supposedly in the indicated array
!			 or CHARACTER string which we are to symbolize.
!	DESCRIP_BLOCK	-address of SRM array descriptor. _CLASSes _S 
!			 and _A are supported.
!	OUT_BUF		-the address of the output buffer is contained
!			 in this variable
!	WATCH_FLAG	-A flag indicating we are outputting a watchpoint.
!
! Implicit Inputs:
!
!	FORTRAN arrays have a max of 7 dimensions.
!
!	The SRM-defined notion of 'array descriptor' is assumed.
!
! Implicit Outputs:
!
!	The output buffer is filled in unless the given IN_ARRAY
!	value is before the supposed beginning of the array.
!	This should never happen because DBG$VAL_TO_SYM has
!	already checked this.  If it does, the 'residue' value
!	returned in the IN_ARRAY value given in the first place
!	so the effect will be as if this routine had
!	not been called.  The same is done if a CHARACTER reference
!	is detected which overflows the supposed string.
!
! Routine Value:
!	How many bytes there are left after the array
!	reference we printed is taken into consideration.
!
! Side Effects:
!
!	The output buffer is filled in. (see above)
!--
BEGIN
	MAP
		DESCRIP_BLOCK : REF BLOCK [,BYTE];
	LOCAL
		start_num,
		end_num,
		max_dimension,
		residue,			! Bytes left over
		bounds : array_bnds_desc,
		INDEX : VECTOR[7,LONG],
		SPAN_BLOCK : REF VECTOR,
		LB_BLOCK : REF VECTOR;
	BIND
				! CHARACTER sub-string references in FORTRAN
		substring = UPLIT( %ASCIC '(!SL:!SL)' );


	! See that we have been given a valid array
	! descriptor.  This should already have been
	! checked.  If it fails, there is no return
	! because a signal is generated.

	dbg$get_bounds( .descrip_block, bounds );

	! If the given IN_ARRAY address comes before
	! the beginning of the array, this symbolization could
	! not possibly work.  If this is the case, simply return
	! the address where the 'array' does start
	! and OUT_SYM_VAL will print the residue in a
	! non-elegant fashion.

	IF( .IN_ARRAY LSSA .BOUNDS[ ARRAY_ADDRESS ] )
	THEN
		RETURN(.bounds[ array_address ]);

	! Set 'residue' to the number of bytes into the array
	! that the given reference is to.

	residue = .in_array - .descrip_block[ dsc$a_pointer ];


	! If this is not really an array reference,
	! then it must be a _CLASS_S type symbolization.
	! This corresponds to FORTRAN CHARACTER variables.

	IF( .DESCRIP_BLOCK[ DSC$B_CLASS ] EQL DSC$K_CLASS_S ) OR
	  ( .DESCRIP_BLOCK[ DSC$B_CLASS ] EQL DSC$K_CLASS_SD) OR
	  ( .DESCRIP_BLOCK[ DSC$B_CLASS ] EQL DSC$K_CLASS_D )
	THEN
		BEGIN

		! Static character string symbolizations look kinda
		! like array references.  First check that the
		! reference is actually within the string.

		IF( NOT .RESIDUE LSS .BOUNDS[ ARRAY_LENGTH ] )
		THEN
			! Don't symbolize and cause the calling
			! routine to output simply "sym + off"

			RETURN(.BOUNDS[ ARRAY_ADDRESS ]);

		!+
		! The first number we print out is the
		! beginning character position (starting from 1).
		! The second number is the final character position.
		!-
		start_num = .residue + 1;
		end_num = .start_num - 1 +
			 (  SELECTONE true OF
				SET
			
				[.dbg$gl_loctyp NEQ -1] : ! Command override
				    BEGIN
				    CASE .dbg$gl_loctyp FROM dsc$k_dtype_b 
							TO dsc$k_dtype_zi
					OF
					SET

					[dsc$k_dtype_b] : 1;
					[dsc$k_dtype_w] : 2;
					[dsc$k_dtype_l] : 4;
					[dsc$k_dtype_t] : .dbg$gw_loclngth;
					[INRANGE, OUTRANGE] : .descrip_block [dsc$w_length];

					TES
				    END;

				[.dbg$gl_gbltyp NEQ -1] :
				    BEGIN
				    CASE .dbg$gl_gbltyp FROM dsc$k_dtype_b 
							TO dsc$k_dtype_zi
					OF
					SET

					[dsc$k_dtype_b] : 1;
					[dsc$k_dtype_w] : 2;
					[dsc$k_dtype_l] : 4;
					[dsc$k_dtype_t] : .dbg$gw_gbllngth;
					[INRANGE, OUTRANGE] : .descrip_block [dsc$w_length];

					TES
				    END;

				[.dbg$gl_lis_ptr NEQ 0] :
				    BEGIN
				    IF .list_elem_size (.dbg$gl_lis_ptr) NEQ 0
				    THEN
					.list_elem_size (.dbg$gl_lis_ptr)
				    ELSE
					.dbg$gl_asci_len
				    END;

       				! This OTHERWISE clause may be reached when we
       				! are called from DBG$SHOW_BPTS during
      				! a SHOW WATCH command. In this case, 
       				! DBG$GL_ASCI_LEN has been set to the
      				! length of the watchpoint by the
       				! DBG$SHOW_BPTS routine, so this is
       				! what we use for the length.
       				!
   				[OTHERWISE] : 
       				    BEGIN
       				    IF .watch_flag 
       			 	    THEN .dbg$gl_asci_len
       				    ELSE .descrip_block [dsc$w_length]
       				    END;

				TES);



	    
		dbg$fao_put(.out_buf, 
			    substring, 
			    .start_num,
			    .end_num);

		! Pass back an indication of how many bytes
		! there would be left given the symbolization
		! we came up with.  In this case we know
		! that we have completely symbolized the value
		! because 'residue' is how far into the CHARACTER
		! string we are beginning the display.
	
		RETURN(.in_array);
		END;

	! Class _A type references.

	! Point to the sequence of longwords which contain
	! the number of array elements in each dimension, and
	! the LB-UB bound blocks which give the origin
	! for the bound for each dimension.

	span_block = descrip_block[ dsc$l_m1 ];
	max_dimension = .descrip_block[ dsc$b_dimct ] -1;
	lb_block = span_block[ .max_dimension +1];


	! Initialize a vector which has one element for each
	! of the dimensions we will symbolize, so that each 
	! INDEX contains the lower-bound value for that
	! dimension.

	INCR I FROM 0 TO .MAX_DIMENSION
		DO
		index[.i] = .lb_block[.i*2];

	! Check whether the array descriptor is _CLASS_A or _CLASS_nca. Currently
	! only COBOL-74 (of the languages supported by DEBUG) uses _CLASS_nca.
	! Consequently this code may need to be generalized if DEBUG 
	! ever supports another language that uses this scheme

	IF .descrip_block [dsc$b_class] EQL dsc$k_class_a
	THEN

	    IF .DESCRIP_BLOCK[DSC$V_FL_COLUMN]
	    THEN	! Column major arrays (FORTRAN)
		! Loop 'backwards' thru each dimension, successively
		! seeing how many (if any) times the number of
		! elements needed to 'fill' the current dimension
		! once can be taken from the remaining 'residue'.
		! This number is the 0-origin subscript which must
		! have been given to effect the array reference
		! we are to symbolize.

		DECR I FROM .MAX_DIMENSION TO 0
			DO
			BEGIN
			LOCAL
				DIMENSION_SIZE;

			! Calculate how many bytes it would take to fill
			! up one of the current dimension.  This is done by
			! tallying up how much each lower dimension takes.
			! Calculate the number of ELEMENTS in the subvector,
			! and then convert this to bytes.

			DIMENSION_SIZE = 1;	! Multiplicative identity
			IF( .I NEQ 0 )
			THEN
				INCR J FROM 0 TO .I-1
				DO
				dimension_size = .dimension_size * 
					.span_block[.j];
 
			dimension_size = .dimension_size * .descrip_block[ dsc$w_length ];
			! Subsume the whole of one sub-dimension.

			index[.i] = .index[.i] + .residue/.dimension_size;
			residue = .residue - (.dimension_size * (.residue/.dimension_size));

			! Loop back to consider the next lower dimension.
			END
	    ELSE
		! Row major arrays (BASIC)
		INCR I FROM 0 TO .MAX_DIMENSION DO
			BEGIN
			LOCAL DIMENSION_SIZE;
			DIMENSION_SIZE = 1;
			IF .I NEQ .MAX_DIMENSION
			THEN
			   DECR J FROM .MAX_DIMENSION TO 1 DO
				DIMENSION_SIZE = .DIMENSION_SIZE *
					.SPAN_BLOCK[.J];
			DIMENSION_SIZE = .DIMENSION_SIZE *
				.DESCRIP_BLOCK[DSC$W_LENGTH];
			INDEX[.I] = .INDEX[.I] + .RESIDUE/.DIMENSION_SIZE;
			RESIDUE = .RESIDUE - (.DIMENSION_SIZE * 
				(.RESIDUE/.DIMENSION_SIZE));
			END

	ELSE

	! This is a _CLASS_nca descriptor so
	! Loop forward thru each dimension etc...

	BEGIN

	INCR i FROM 0 TO .max_dimension
		DO
		BEGIN

		index [.i] = .index [.i] + .residue / .span_block [ .i];
		residue = .residue - (.span_block[.i] * (.residue / .span_block[.i]));
		END;


	END;

	! At this point the symbolization is complete 
	! as far as the array reference is concerned.
	! We simply have to 'print' it out.

	DBG$FAO_PUT( .out_buf, UPLIT(%ASCIC '('));
	DBG$OUT_NUM_VAL(.out_buf, .INDEX[0],long_length,decimal_radix);
	INCR I FROM 1 TO .MAX_DIMENSION
		DO
		BEGIN
		DBG$FAO_PUT(.out_buf, UPLIT(%ASCIC ','));
		DBG$OUT_NUM_VAL( .out_buf, .INDEX[.I], long_length, 
    					decimal_radix);
		END;
	DBG$FAO_PUT( .out_buf, UPLIT(%ASCIC ')'));

	! Normally any further residue is handled by an outer
	! routine.  Since we know this is FORTRAN, and
	! since CHARACTER sub-string designators are specific
	! to FORTRAN, we deal with this 'residue' here.

	IF( .descrip_block[ DSC$B_DTYPE ] EQL DSC$K_DTYPE_T )
	THEN
		BEGIN
		LOCAL
			string_length;
		string_length = (IF .dbg$gl_loctyp NEQ -1 THEN
							.dbg$gw_loclngth
				 ELSE IF .dbg$gl_gbltyp NEQ -1 THEN
							.dbg$gw_gbllngth
				 ELSE .descrip_block[dsc$w_length]);
		dbg$fao_put( .out_buf, substring,
    				.residue+1, .residue+.string_length);
		residue = 0;
		END;

	! Pass back an indication of how many bytes
	! there would be left given the symbolization
	! we came up with.

	RETURN(.IN_ARRAY-.RESIDUE);
END;

ROUTINE put_access_act( value, base_value, blz_rec, buffer) =

!++
! Functional Description:
!
! Put the description of the given structure reference into the current
! output buffer in the form "[a1, a2,...an]".
!
! Formal Parameters:
!	value		- address we are trying to symbolize in the structure. 
!	base_value	- the beginning address of the structure being
!			  referenced.
!	blz_rec		- pointer to the DST entry for the structure
!	buffer		- contains the address of the output buffer
!
! Implicit Inputs:
!	The pointer to the command argument list which contains the access
!	actuals to be symbolized.
!
! Implicit Outputs:
!	The output buffer is filled in with the appropriate access actuals.
!
! Routine Value:
!	The number of bytes that are left after the structure reference to
!	be printed is taken into consideration.
!
! Side Effects:
!	The output buffer is filled in
!
!--
BEGIN

	MAP blz_rec : REF blz_record;

LOCAL
	residue,			! no of bytes left over
	act_set,			! 1=access act supplied, 0=no
	act : VECTOR [6];		! temp storage for access actuals

residue = 0;

!+
!	See if access actuals were given in the command line. If they were,
!	we will use them. Otherwise, we symbolize with "+ offset" 
!-

IF .dbg$gl_lis_ptr NEQ 0		
THEN
	act_set = .list_elem_args(.dbg$gl_lis_ptr) 
ELSE
	act_set = 0;			! user said "ex" without any arguments


CASE .act_set FROM 0 TO 2 OF
SET

	! When access_act is 2 we are examining a range of locations where access
	! actuals were specified in the command line, so we try to deduce what
	! the access actuals should be for each element inn the range

[2] :	CASE .blz_rec [blz_struct] FROM vectr TO blockvec OF
	SET
	   [vectr] :	BEGIN			! compute the VECTOR index
			LOCAL  temp;
			act[0] = 1 ;		! act[0] is the count of access actuals
			act[1] = 0;

			IF .value NEQ .base_value
			THEN
				BEGIN
				temp = .base_value;

				WHILE 1 DO
				  BEGIN
				  IF .value GTR .temp + (.blz_rec [unit_size_vec] - 1)
				  THEN
					act[1] = .act[1] + 1
				  ELSE
					BEGIN
					residue = .value - .temp;
					EXITLOOP;
					END;


				  IF .value EQL (.temp + .blz_rec [unit_size_vec])
				  THEN
					EXITLOOP;
				  
				  temp = .temp + .blz_rec[unit_size_vec];
				  END;
          		        END;
			END;
	   [bitvec] : 	BEGIN
			act[0] = 1;
			act[1] = (.value - .base_value) * %BPUNIT;
			END;
	   [blok]   :	BEGIN
			LOCAL  temp;
			act[0] = 4;
			act[1] = 0;
			act[4] = 0;
			act[3] = .blz_rec[unit_size_block] * %BPUNIT;

			IF .value EQL .base_value
			THEN
				act[2] = 0
			ELSE
				BEGIN
				temp = .base_value;
				WHILE 1 DO
					BEGIN
					IF .value GTR .temp + (.blz_rec[unit_size_block] - 1)
					THEN
					    act[1] = .act[1] + 1
					ELSE
					    BEGIN
					    act[2] = (.value - .temp) * %BPUNIT;
					    EXITLOOP;
					    END;

					IF .value EQL (.temp + .blz_rec[unit_size_block])
					THEN
					    BEGIN
					    act[2] = 0;
					    EXITLOOP;
					    END;

					temp = .temp + .blz_rec[unit_size_block];
					END;
				END;
	   		END;
	   [blockvec] :	BEGIN
			LOCAL   temp;
			act[0] = 5;
			act[5] = 0;
			act[4] = .blz_rec[unit_size_bvec] * %BPUNIT;

			IF .value EQL .base_value
			THEN
				BEGIN
				act[3] = 0;
				act[2] = 0;
				act[1] = 0;
				END
			ELSE
				BEGIN
				act[1] = 0;
				temp = .base_value;

				WHILE 1 DO
				  BEGIN
				  IF .value GTR .temp + (.blz_rec[u_alloc_bvec]
							* .blz_rec[unit_size_bvec]) - 1
				  THEN
					act[1] = .act[1] + 1
				  ELSE
					BEGIN
					act[2] = 0;

					WHILE 1 DO
					  BEGIN
					  IF .value GTR .temp + (.blz_rec[unit_size_bvec] - 1)
					  THEN
						act[2] = .act[2] + 1
					  ELSE
						BEGIN
						act[3] = (.value - .temp) * %BPUNIT;
						EXITLOOP;
						END;

					  IF .value EQL (.temp + .blz_rec[unit_size_bvec])
					  THEN
						BEGIN
						act[3] = 0;
						EXITLOOP;
						END;
					  temp = .temp + .blz_rec[unit_size_bvec];
					  END;
					EXITLOOP;
					END;

				IF .value EQL .temp + (.blz_rec[u_alloc_bvec] *
							.blz_rec[unit_size_bvec])
				THEN
					BEGIN
					act[2] = 0;
					act[3] = 0;
					EXITLOOP;
					END;
				
				temp = .temp + (.blz_rec[u_alloc_bvec] * 
						.blz_rec[unit_size_bvec]);
				END;
			   END;
			END;
	TES;

	! Access actuals were not specified in the command line, so symbolize
	! the structure reference as  "struc + offset<0, mode_length>" or
	! <pos,size,ext> if field selectors were specified

[0] :	BEGIN
	ang_bracket = 1;
	RETURN (.base_value);
	END;

	! Access actuals were given in command line..so use them

[1] :	CASE .blz_rec [blz_struct] FROM vectr TO blockvec OF
	SET
	   [vectr]  :	BEGIN
			act[0] = 1;
			act[1] = .list_elem_index(.dbg$gl_lis_ptr);
			residue = .value - (.base_value + (.act[1] * .blz_rec[unit_size_vec]));
			END;
	   [bitvec] :	BEGIN
			act[0] = 1;
			act[1] = .list_elem_index(.dbg$gl_lis_ptr);
			END;
	   [blok]   : 	BEGIN
			act[0] = 4;
			act[1] = .list_elem_offst(.dbg$gl_lis_ptr);
			act[2] = .list_elem_pos  (.dbg$gl_lis_ptr);
			act[3] = .list_elem_size (.dbg$gl_lis_ptr);
			act[4] = .list_elem_ext  (.dbg$gl_lis_ptr);
			residue = .value - (.base_value + (.act[1] * .blz_rec[unit_size_block]));
			END;
	   [blockvec] :	BEGIN
			act[0] = 5;
			act[1] = .list_elem_index(.dbg$gl_lis_ptr);
			act[2] = .list_elem_offst(.dbg$gl_lis_ptr);
			act[3] = .list_elem_pos  (.dbg$gl_lis_ptr);
			act[4] = .list_elem_size (.dbg$gl_lis_ptr);
			act[5] = .list_elem_ext  (.dbg$gl_lis_ptr);
			residue = .value - (.base_value + (.act[1] * .blz_rec[u_alloc_bvec] *
			          .blz_rec[unit_size_bvec]) + (.act[2] * .blz_rec[unit_size_bvec]));
			END;
	TES;
TES;

!	Write the access actuals to the output buffer. 

	dbg$fao_put(.buffer, UPLIT(%ASCIC '['));
	dbg$out_num_val( .buffer, .act[1], long_length, decimal_radix);


	INCR i FROM 2 TO .act[0] DO
		BEGIN
		dbg$fao_put(.buffer, UPLIT(%ASCIC ','));
		dbg$out_num_val( .buffer, .act[.i], long_length, 
    					decimal_radix);
		END;
	dbg$fao_put(.buffer, UPLIT(%ASCIC ']'));

	RETURN (.value - .residue);
END;

GLOBAL ROUTINE dbg$out_typ_val (output_buffer, value_ptr, type) =
!++
! Functional description:
!	This routine outputs the contents of a memory location in the
!	format specified by the type field in a symbol's DST record.
!
!	If the type field cannot be satisfied, this routine returns
!	false, and the caller has the responsibility of getting
!	the value output by some other method.
!
! Formal parameters:
!	value_ptr	- the address of the symbol
!	type		- The symbol's type.
!			  If -1 then use the value to try to deduce the type.
!	output_buffer   - The address of the output buffer.
!	nt_ptr		- optional fourth parameter.  pointer to name table 
!			  entry for the location being output
!
! Implicit inputs:
!	the DST record and NT record for the symbol bound to the
!	address in value_ptr, if such records exist.
!
! Implicit outputs:
!	the value of the symbol is written into the output buffer.
!
! Routine value:
!	true with success, false with failure.
!
! Side effects:
!	eventually, the value is printed, however, not in this routine
!--

	BEGIN
	BUILTIN
		ACTUALCOUNT,
		ACTUALPARAMETER;

	MAP
		value_ptr	: REF BLOCK [,BYTE];

	EXTERNAL
	   	lib$ab_cvt_o_u ;

	LOCAL
		desc		: REF BLOCK[,BYTE],
		case_index,
		status,
		floating_buffer	: VECTOR [flting_buf_len, BYTE],
		default_flag,
		buffer		: VECTOR [ 40, BYTE ],
		nt_ptr		:REF rst$entry,
		a,
		size,
		temp_desc : block[8,byte],	! build a descriptor here occasionally.
		outbuf		: VECTOR [ 40, BYTE ],
		newsize,
		offset,
		real_value;
	!++
	! The MACRO delta_bytes computes the number of bytes to add to the
	! current location in order to correctly update dbg$gl_next_loc
	! when a field reference was explicitly made
	!--

	MACRO
		delta_bytes (pos,size) =
		    (IF size EQL 0 THEN 0 ELSE
			(IF (pos + size) MOD %BPUNIT NEQ 0
			 THEN
				((pos + size) / %BPUNIT) + 1
			 ELSE
				((pos + size) / %BPUNIT)))%;

	!++
	! This table is used to translate a overpunch character to the
	! ascii representation of it's sign
	!--

	BIND
	    sign_tbl = UPLIT BYTE
		( REP 33 OF (%C' '), %C'-', REP 14 OF (%C' '), REP 10 OF (%C'+'),
		  %C'-', REP 4 OF (%C' '), %C'+', %C' ', REP 9 OF (%C'+'), 
		  REP 9 OF (%C'-'), REP 8 OF (%C' '), %C'+', %C' ', %C'-', 
		  REP 3 OF (%C' '), REP 9 OF (%C'+'), REP 9 OF (%C'-'), 
		  REP 8 OF (%C' '), %C'+', %C' ', %C'-', REP 130 OF (%C' ')) : VECTOR [,BYTE];

	default_flag = false;

	!+
	! If there was no type supplied then we must try to find the
	! symbol's type from scratch.
	!-
	nt_ptr = 0;

	!+
	! If the optional nt_ptr was given to us, get it
	! -
	IF ACTUALCOUNT() GTR 3
	THEN
	    BEGIN
	    nt_ptr = ACTUALPARAMETER(4) ;


	    dbg$symbol_valu(.nt_ptr,desc);		! get it's descriptor
	    END;

	case_index = .type;
	IF .case_index EQL -1
		THEN
		    BEGIN
		    !+
		    ! If we get in here, ie the outside routine did not know what
		    ! type to display location in.
		    !
		    ! Find the symbol name that is closest in value to the address
		    ! whose contents is to be output. If this fails use the default
		    ! type.
		    ! LOCK the GST before calling val_to_sym because a global
		    ! answer can not give us the type info we need.
		    !-
		    dbg$gb_no_globals = TRUE;
		    status = dbg$val_to_sym (.value_ptr, nt_ptr, FALSE);
		    dbg$gb_no_globals = FALSE;
		
		    IF .status 
			THEN
			    !+
			    ! Now find the precise value of the symbol returned above or
			    ! passed in.  This is due to val_to_syms willingness to send
			    ! a close match as well as an exact match. If the match is not
			    ! exact then use the type field of the value passed in.
			    !-
			    IF dbg$symbol_valu(.nt_ptr, real_value)
			    THEN
				IF (.VALUE_PTR EQL .REAL_VALUE)
				OR (.NT_PTR[rst$v_nonzlength])
				THEN
				    BEGIN
				    ! if we plan on outputing something get its descriptor also
				    desc = .real_value ;
				    case_index = dbg$rst_type(.nt_ptr);
				    END
				ELSE status = 0
			    ELSE status = 0;
		    IF NOT .status THEN
		        BEGIN
		        NT_PTR = 0;
                 	case_index = .dbg$gl_dflttyp;
			IF .case_index EQL dsc$k_dtype_t
			    THEN
				BEGIN
				    desc = temp_desc;
				    temp_desc[dsc$w_length] = .dbg$gw_dfltleng;
				END;
		        END;
		    END;
	!+
	! If the language is BLISS and <p,s,e> were specified explicitly,
	! they override the type of the variable for purposes of display.
	! So show the requested field and RETURN
	!-
	IF .dbg$gb_language EQL lang_bliss
	AND .dbg$gl_lis_ptr NEQ 0
	AND .list_elem_fldrf(.dbg$gl_lis_ptr) NEQ 0
	THEN
	    BEGIN
	    LOCAL
		temp_val;

	    IF .list_elem_ext(.dbg$gl_lis_ptr) EQL 1
	    THEN
		temp_val = .value_ptr[0, .list_elem_pos(.dbg$gl_lis_ptr),
					 .list_elem_size(.dbg$gl_lis_ptr), 1]
	    ELSE
		temp_val = .value_ptr[0, .list_elem_pos(.dbg$gl_lis_ptr),
					 .list_elem_size(.dbg$gl_lis_ptr), 0];
	    dbg$out_num_val ( .output_buffer, .temp_val, long_length, 0);
	    dbg$gl_next_loc = .value_ptr + delta_bytes(.list_elem_pos(.dbg$gl_lis_ptr),
			.list_elem_size(.dbg$gl_lis_ptr));
	    dbg$gl_last_val = .temp_val;
	    RETURN TRUE;
	    END;

	!+
	! The symbol from the name table in the RST is bound to the
	! address whose contents is to be displayed. Display it according
	! to its particular type.
	!-
	if (.case_index gtr dsc$k_dtype_hc)
	then
	    BEGIN
	    case_index = .dbg$gl_dflttyp;
	    default_flag = true;
	    END;

	CASE .case_index FROM 0 TO dsc$k_dtype_hc	! 0 to 30
	OF
	    SET

	    [dsc$k_dtype_z]:				! BLISS type 0
		BEGIN
		LOCAL
			blz_ptr : REF blz_record,
			nt_rec  : REF rst$entry,
			struc,		
			index,
			ext,
			pos,
			size,
			u_size ;			! temp structure unit size


		IF .dbg$gl_lis_ptr EQL 0
		THEN
			RETURN FALSE	! so we display mode_length instead of unit_size

		ELSE
		   BEGIN

		    ! Get DST entry using the command argument list. Even though
		    ! we have an argument list, access actuals may not have been
		    ! specified. If this is the case, we RETURN FALSE so that
		    ! mode_length, not unit_size, determines how many bits we
		    ! output.

		   IF .list_elem_args(.dbg$gl_lis_ptr) EQL 0
		   THEN
			RETURN FALSE; 

 		   nt_rec  = .list_elem_ntptr (.dbg$gl_lis_ptr);
         	   blz_ptr = .nt_rec[rst$l_dstptr];
 		   struc   = .list_elem_struc (.dbg$gl_lis_ptr);
 		   index   = .list_elem_index (.dbg$gl_lis_ptr);
 		   ext     = .list_elem_ext (.dbg$gl_lis_ptr);
 		   pos     = .list_elem_pos (.dbg$gl_lis_ptr);
 		   size    = .list_elem_size (.dbg$gl_lis_ptr);
		   END;


		! Output the value of the relevant structure reference. This
		! section is only arrived at if we are to symbolize access actuals
		! with square brackets
		
		CASE .struc FROM no_struc TO blockvec OF
		SET
		
		   [no_struc] : RETURN FALSE;

		   [vectr]    : BEGIN
				LOCAL  temp_val;
				
				u_size = .blz_ptr [unit_size_vec];

				CASE .u_size FROM byte_length TO long_length OF
				SET
				   [byte_length] : temp_val = (IF .ext EQL 1
								THEN .value_ptr[byte_integer]
								ELSE .value_ptr[byte_logical]);
				   [word_length] : temp_val = (IF .ext EQL 1
								THEN .value_ptr[word_integer]
								ELSE .value_ptr[word_logical]);
				   [3]           : temp_val = (IF .ext EQL 1
								THEN .value_ptr[0,0,24,1]
								ELSE .value_ptr[0,0,24,0]);
				   [long_length] : temp_val = (IF .ext EQL 1
								THEN .value_ptr[longword_1]
								ELSE .value_ptr[longword_1]);
				   [outrange]    : RETURN FALSE;
				TES;

				! output the value

				dbg$out_num_val( .output_buffer, .temp_val, 
    						   long_length, 0);
				dbg$gl_next_loc = .value_ptr + .u_size;
				dbg$gl_last_val = .temp_val;

				END;
				
		[bitvec]  :	BEGIN
				LOCAL  temp_pos;
				temp_pos = .index MOD %BPUNIT;
				dbg$out_num_val (.output_buffer, 
    					.value_ptr[0,.temp_pos, 1, 0], 
    					long_length,0);
				dbg$gl_next_loc = .value_ptr + 1;
				dbg$gl_last_val = .value_ptr[0,.temp_pos,1,0];

				END;
		[blok,
		  blockvec] :	BEGIN
				LOCAL
					temp_val;

				IF .ext EQL 0
				THEN
				    temp_val = .value_ptr [0, .pos, .size, 0]
				ELSE
				    temp_val = .value_ptr [0, .pos, .size, 1];

				dbg$out_num_val (.output_buffer, .temp_val, 
    							long_length, 0);

				! Set next_loc to the byte address following the 
				! one just displayed, independent of the unit size

				dbg$gl_next_loc = .value_ptr + delta_bytes(.pos, .size);
				dbg$gl_last_val = .temp_val;

				END;
		[outrange] :	RETURN FALSE;
		TES;
		END;

	    [dsc$k_dtype_v]:				! single bit
		BEGIN
		dbg$out_num_val (.output_buffer, .value_ptr [single_bit], 
    					long_length, 0);
		dbg$gl_next_loc = .value_ptr + 1;
		dbg$gl_last_val = .value_ptr [single_bit];
		END;

	    [dsc$k_dtype_bu]:			! 8-bit unsigned quantity
		BEGIN
		dbg$out_num_val ( .output_buffer, .value_ptr [byte_logical], 
    					byte_length, 0);
		dbg$gl_next_loc = .value_ptr + 1;
		dbg$gl_last_val = .value_ptr [byte_logical];
		END;


	    [dsc$k_dtype_wu]:				! 16-bit unsigned quantity
		BEGIN
		IF .nt_ptr NEQ 0
		THEN
		    BEGIN
		    IF ( NOT .nt_ptr[rst$v_global] )
		    AND (.nt_ptr[rst$b_kind] NEQ rst$k_module)
		    THEN
			BEGIN
			LOCAL
			    dst_recrd : REF dst$record ;
			! pick up the dst record and check for a descriptor
			dst_recrd = .nt_ptr[rst$l_dstptr];
			IF 
			  (IF .dst_recrd[dst$v_valkind] EQL dst$k_valkind_desc
				THEN ((.desc[dsc$b_class] eql DSC$K_CLASS_SD)
				  OR (.desc[dsc$b_class] eql DSC$K_CLASS_nca)
				  OR (.desc[dsc$b_class] eql DSC$K_CLASS_A))
				ELSE  false)
			AND .dbg$gb_mod_ptr[mode_radix] EQL decimal_radix
			THEN
			    BEGIN
			    LOCAL
				long_item ;
			    BUILTIN
				CVTPS,CVTLP ;
			    newsize = 5 ;
			    long_item = .value_ptr[word_logical];
			    CVTLP(long_item,newsize,outbuf);
			    CVTPS(newsize,outbuf,newsize,buffer);
			    decimal_scale(newsize,.desc[dsc$b_scale],buffer,outbuf,
				(IF .dbg$language EQL lang_cobol THEN FALSE ELSE TRUE));
			    outbuf[0] = %C' ' ;				! no sign


    				dbg$fao_put(.output_buffer, cs_ascii, .newsize+1, outbuf);
			    END
			ELSE
			    dbg$out_num_val( .output_buffer, 
    						.value_ptr[word_logical],
    					word_length, 0);
			END
		    ELSE
			dbg$out_num_val( .output_buffer, 
    					 .value_ptr[word_logical], word_length,
    						0);
		    END
		ELSE
		    dbg$out_num_val ( .output_buffer, 
    					.value_ptr [word_logical], word_length,
    					0);

		dbg$gl_next_loc = .value_ptr + 2;
		dbg$gl_last_val = .value_ptr [word_logical];

		END;


	    [dsc$k_dtype_lu]:				! 32-bit unsigned quantity
		BEGIN
		dbg$out_num_val ( .output_buffer, .value_ptr [longword_1], 
    					long_length, 0);
		dbg$gl_next_loc = .value_ptr + 4;
		dbg$gl_last_val = .value_ptr [longword_1];
		END;


	    [dsc$k_dtype_b]:				! 8-bit signed 2's-complement integer
		BEGIN
		dbg$out_num_val ( .output_buffer, .value_ptr [byte_integer], 
    					byte_length, 0);
		dbg$gl_next_loc = .value_ptr + 1;
		dbg$gl_last_val = .value_ptr [byte_integer];
		END;


	    [dsc$k_dtype_w]:				! 16-bit signed 2's-complement integer
		BEGIN
		IF .nt_ptr NEQ 0
		THEN
		    BEGIN
		    IF ( NOT .nt_ptr[rst$v_global] )
		    AND (.nt_ptr[rst$b_kind] NEQ rst$k_module)
		    THEN
			BEGIN
			LOCAL
			    dst_recrd : REF dst$record ;
			! pick up the dst record and check for a descriptor
			dst_recrd = .nt_ptr[rst$l_dstptr];
			IF 
			  (IF .dst_recrd[dst$v_valkind] EQL dst$k_valkind_desc
				THEN ((.desc[dsc$b_class] eql DSC$K_CLASS_SD)
				  OR (.desc[dsc$b_class] eql DSC$K_CLASS_nca)
				  OR (.desc[dsc$b_class] eql DSC$K_CLASS_A))
				ELSE  false)
			AND .dbg$gb_mod_ptr[mode_radix] EQL decimal_radix
			THEN
			    BEGIN
			    LOCAL
				long_item ;
			    BUILTIN
				CVTPS,CVTLP ;
			    newsize = 5 ;
			    long_item = .value_ptr[word_integer];
			    CVTLP(long_item,newsize,outbuf);
			    CVTPS(newsize,outbuf,newsize,buffer);
			    decimal_scale(newsize,.desc[dsc$b_scale],buffer,outbuf,
			
			    (IF .dbg$language EQL lang_cobol THEN FALSE ELSE TRUE));
			    


    			    dbg$fao_put(.output_buffer, cs_ascii, .newsize+1, outbuf);  
			    END
			ELSE
			    dbg$out_num_val( .output_buffer, 
    						.value_ptr[word_integer], 
    						word_length, 0);
			END
		    ELSE
			dbg$out_num_val( .output_buffer, 
    					  .value_ptr[word_integer], 
    					  word_length, 0);
		    END
		ELSE
		    dbg$out_num_val ( .output_buffer, 
    					.value_ptr [word_integer], 
    					word_length, 0);

		dbg$gl_next_loc = .value_ptr + 2;
		dbg$gl_last_val = .value_ptr [word_integer];
		END;


	    [dsc$k_dtype_l]:				! 32-bit signed integer.
		BEGIN

		IF .nt_ptr NEQ 0
		THEN
		    BEGIN
		    IF (NOT .nt_ptr[rst$v_global] )
		AND (.nt_ptr[rst$b_kind] NEQ rst$k_module)
		    THEN
			BEGIN
			LOCAL
			    dst_recrd : REF dst$record ;
			! pick up the dst record and check for a descriptor
			dst_recrd = .nt_ptr[rst$l_dstptr];
			IF 
			  (IF .dst_recrd[dst$v_valkind] EQL dst$k_valkind_desc
				THEN ((.desc[dsc$b_class] eql DSC$K_CLASS_SD)
				  OR (.desc[dsc$b_class] eql DSC$K_CLASS_nca)
				  OR (.desc[dsc$b_class] eql DSC$K_CLASS_A))
				ELSE  false)
			AND .dbg$gb_mod_ptr[mode_radix] EQL decimal_radix
			THEN
			    BEGIN
			    BUILTIN
				CVTPS,CVTLP ;
			    newsize = 10 ;
			    CVTLP(.value_ptr,newsize,outbuf);
			    CVTPS(newsize,outbuf,newsize,buffer);
			    decimal_scale(newsize,.desc[dsc$b_scale],buffer,outbuf,
				(IF .dbg$language EQL lang_cobol THEN FALSE ELSE TRUE));



    				dbg$fao_put(.output_buffer, cs_ascii, .newsize+1, outbuf); 
			    END
			ELSE
			    dbg$out_num_val( .output_buffer, 
    						.value_ptr[longword_1], 
    						long_length, 0);
			END
		    ELSE
			dbg$out_num_val( .output_buffer, 
    					   .value_ptr[longword_1], long_length,
    					   0);
		    END
		ELSE
		    dbg$out_num_val ( .output_buffer, .value_ptr [longword_1],
    						long_length, 0);

		dbg$gl_next_loc = .value_ptr + 4;
		dbg$gl_last_val = .value_ptr [longword_1];
		END;

	    [dsc$k_dtype_q]:				! 64-bit signed integer
		BEGIN
		BUILTIN
		    CVTPS;
		
		selectone .dbg$gb_mod_ptr[mode_radix] of
		    set

		    [decimal_radix]:
			begin
			newsize = 19 ;		! number of decimal digits
			cob$cvtqp_r9(0,value_ptr[longword_1],.newsize,outbuf);
			CVTPS(newsize,outbuf,newsize,buffer);

			a = buffer ;		!initialize address of data
	
			IF .nt_ptr NEQ 0
		            THEN
			    ! See if the value picked up by DBG$SYMBOL_VALU is
			    ! really the address which is bound to the
			    ! symbol, or if it is the address of a descriptor.
			    ! Note that DST_PTR is invalid for NTs which
			    ! were created only for global symbols.
	    		    IF( NOT .nt_ptr[rst$v_global] )
				AND (.nt_ptr[rst$b_kind] NEQ rst$k_module)
				THEN
			        BEGIN
			        LOCAL
	        		    DST_RECRD : REF dst$record;				        ! Pick up the DST pointer so that we can see
  		    		        ! if access is via descriptor.  

			        DST_RECRD = .NT_PTR[rst$l_dstptr];

			        IF 
				  (IF .dst_recrd[dst$v_valkind] EQL dst$k_valkind_desc
				    THEN ((.desc[dsc$b_class] eql DSC$K_CLASS_SD)
				    OR (.desc[dsc$b_class] eql DSC$K_CLASS_nca)
			            OR (.desc[dsc$b_class] eql DSC$K_CLASS_A))
				    ELSE  false)
				THEN
				    BEGIN
	   			    ! we will have to do scaling since that is the only 
				    ! reason for having a descriptor for a quad number
				    decimal_scale(newsize,.desc[dsc$b_scale],buffer,outbuf,false);
				    a = outbuf ;
				    END;	
				 END;



		        dbg$fao_put(.output_buffer, cs_ascii,.newsize+1,.a);
		        END;
		
		    [hex_radix] :
		        ! if radix is hex, output first the high-order
			! longword, then the low-order longword.
			begin
		        dbg$fao_put( .output_buffer,
			    uplit( %ascic '!XL'),
			    .value_ptr[longword_2]);
			dbg$fao_put( .output_buffer,
			    uplit( %ascic ' '));
		        dbg$fao_put( .output_buffer,
			    uplit( %ascic '!XL'),
			    .value_ptr[longword_1]);
	 	        end;
		
		    [octal_radix] :
			! note that octal radix is more complicated than
			! hex. The 12th digit of the 22-digit representation
			! spans both longwords.
			begin
			local 
			    temp_buffer :
			    ref vector [,byte];
			! output the first 11 octal digits based on the
			! first 31 bits.
			dbg$out_num_val( .output_buffer,
			    .value_ptr[4,1,31,0], long_length, 0);
			! output the next 10 digits.
			! dbg$octal_valtostg_cvt takes
			! a value, and a count of
			! the number of octal digits to be written.
			! It returns a pointer to a counted string.
			temp_buffer = dbg$octal_valtostg_cvt
			    ( .value_ptr[0,3,30,0],10);
			dbg$fao_put( .buffer, .temp_buffer);
			dbg$freerelease(.temp_buffer,0);
			! output the final octal digit.
			temp_buffer = dbg$octal_valtostg_cvt
			    ( .value_ptr[0,0,3,0],1);
			dbg$fao_put( .buffer, .temp_buffer);
			dbg$freerelease(.temp_buffer,0)
			end;

		    [otherwise]:
		        return false;
	
		    tes;		

	    	dbg$gl_next_loc = .value_ptr + 8 ;
		dbg$gl_last_val = .value_ptr[longword_1];
		end;		

	    [dsc$k_dtype_o]:
		begin

		selectone .dbg$gb_mod_ptr[mode_radix] of
		    set

		    [octal_radix] :
			begin
			local
			    temp_buffer : ref vector[,byte];
			! output the first 11 octal digits.
			dbg$out_num_val( .output_buffer,
			    .value_ptr[longword_4], long_length, 0);
			! output the next 10 digits.
			temp_buffer = dbg$octal_valtostg_cvt(
			    .value_ptr[8,2,30,0], 10);
			dbg$fao_put( .buffer, .temp_buffer);
			dbg$freerelease(.temp_buffer, 0);
			! and the next 10 digits...
			temp_buffer = dbg$octal_valtostg_cvt(
			    .value_ptr[4,4,30,0], 10);
			dbg$fao_put( .buffer, .temp_buffer);
			dbg$freerelease(.temp_buffer,0);
			! and the next 10 digits...
			temp_buffer = dbg$octal_valtostg_cvt(
			    .value_ptr[0,6,30,0], 10);
			dbg$fao_put( .buffer, .temp_buffer);
			dbg$freerelease(.temp_buffer,0);
			! output the last 2 digits.
			temp_buffer = dbg$octal_valtostg_cvt(
			    .value_ptr[0,0,6,0], 2);
			dbg$fao_put( .buffer, .temp_buffer);
			dbg$freerelease(.temp_buffer,0)
			end;
		 
		    [hex_radix] :
			begin
			! output the four words from high-order
			! word to low-order word.
			dbg$fao_put( .buffer,
			    uplit( %ascic '!XL'),
			    .value_ptr[longword_4]);
			dbg$fao_put( .buffer, uplit( %ascic ' '));
			dbg$fao_put( .buffer,
			    uplit( %ascic '!XL'),
			    .value_ptr[longword_3]);
			dbg$fao_put( .buffer, uplit( %ascic ' '));
			dbg$fao_put( .buffer,
			    uplit( %ascic '!XL'),
			    .value_ptr[longword_2]);
			dbg$fao_put( .buffer, uplit( %ascic ' '));
			dbg$fao_put( .buffer,
			    uplit( %ascic '!XL'),
			    .value_ptr[longword_1])
			end;

		    [decimal_radix] :
			begin
			local string : ref vector [,byte] ;
			string = dbg$decimal_valtostg_cvt(.value_ptr,16);
			! now output the string.
			dbg$fao_put(.buffer, .string);
			dbg$freerelease(.string);
			end;

		    [otherwise] :
			return false;

		    tes;

		dbg$gl_next_loc = .value_ptr + 16;
		dbg$gl_last_val = .value_ptr[longword_1];
		end;

	    [dsc$k_dtype_f]:				! 32-bit floating point
		BEGIN

		LOCAL
			dbl_value	: BLOCK [8, BYTE],
			float_stg_desc	: BLOCK [8, BYTE];
		BUILTIN
		    CVTFD ;

		float_stg_desc [dsc$w_length] = float_buf_len;
		float_stg_desc [dsc$a_pointer] = floating_buffer;
		IF .value_ptr[0,7,9,0] EQL %X'100'	! Illegal floating point?
		THEN
		    BEGIN
		    SIGNAL (DBG$_INVFLOAT);
		    dbg$fao_put (.output_buffer, UPLIT(%ASCIC'!XL'), 
    			.value_ptr[longword_1]);
		    END
		ELSE
		    BEGIN
		    CVTFD(.value_ptr,dbl_value);
		    for$cvt_d_tg (dbl_value, float_stg_desc, float_fra_dig, scale_factor,
					digits_in_int, float_exp_dig);
		    dbg$fao_put (.output_buffer, stg_desc_ascii, float_stg_desc)
		    END;
		dbg$gl_next_loc = .value_ptr + 4;
		dbg$gl_last_val = .value_ptr [longword_1];
		END;



	    [dsc$k_dtype_d]:				! 64-bit floating point
		BEGIN
		LOCAL
			float_stg_desc	: BLOCK [8, BYTE];

		float_stg_desc [dsc$w_length] = dbl_buf_len;
		float_stg_desc [dsc$a_pointer] = floating_buffer;
		IF .value_ptr[0,7,9,0] EQL %X'100'	! Illegal floating point?
		THEN
		    BEGIN
		    SIGNAL (DBG$_INVFLOAT);
		    dbg$fao_put (.output_buffer, UPLIT(%ASCIC'!XL!XL'), 
    			.value_ptr[longword_2], .value_ptr[longword_1]);
		    END
		ELSE
		    BEGIN
		    for$cvt_d_tg (.value_ptr, float_stg_desc, dbl_fra_dig, scale_factor,
					digits_in_int, dbl_exp_dig );
		    dbg$fao_put (.output_buffer, stg_desc_ascii, float_stg_desc)
		    END;
		dbg$gl_next_loc = .value_ptr + 8;
		dbg$gl_last_val = .value_ptr [longword_1];
		END;


	    [dsc$k_dtype_g]:				! 64-bit floating point
		BEGIN

		LOCAL
			float_stg_desc	: BLOCK [8, BYTE];

		float_stg_desc [dsc$w_length] = grand_buf_len ;
		float_stg_desc [dsc$a_pointer] = floating_buffer;
		IF .value_ptr[0,4,12,0] EQL %X'800'	! Illegal floating point?
		THEN
		    BEGIN
		    SIGNAL (DBG$_INVFLOAT);
		    dbg$fao_put (.output_buffer, UPLIT(%ASCIC'!XL!XL'), 
    			.value_ptr[longword_2],.value_ptr[longword_1]);
		    END
		ELSE
		    BEGIN
		    for$cvt_g_tg (.value_ptr, float_stg_desc, grand_fra_dig, scale_factor,
					digits_in_int, grand_exp_dig);
		    dbg$fao_put (.output_buffer, stg_desc_ascii, float_stg_desc)
		    END;
		dbg$gl_next_loc = .value_ptr + 8;
		dbg$gl_last_val = .value_ptr [longword_1];
		END;

	    [dsc$k_dtype_h]:				! 128-bit floating point
		BEGIN

		LOCAL
			float_stg_desc	: BLOCK [8, BYTE];

		float_stg_desc [dsc$w_length] = huge_buf_len;
		float_stg_desc [dsc$a_pointer] = floating_buffer;
		IF .value_ptr[0,0,15,0] EQL %X'8000'	! Illegal floating point?
		THEN
		    BEGIN
		    SIGNAL (DBG$_INVFLOAT);
		    dbg$fao_put (.output_buffer, UPLIT(%ASCIC'!XL!XL!XL!XL'), 
    				  .value_ptr[longword_4],
				  .value_ptr[longword_3],.value_ptr[longword_2],
					.value_ptr[longword_1]);
		    END
		ELSE
		    BEGIN
		    for$cvt_h_tg (.value_ptr, float_stg_desc, huge_fra_dig, scale_factor,
					digits_in_int, huge_exp_dig);
		    dbg$fao_put (.output_buffer, stg_desc_ascii, float_stg_desc)
		    END;
		dbg$gl_next_loc = .value_ptr + 16;
		dbg$gl_last_val = .value_ptr [longword_1];
		END;

	    [dsc$k_dtype_fc]:				! single-precision complex quantity
		BEGIN

		LOCAL
			dbl_value	: BLOCK [8, BYTE],
			float_stg_desc	: BLOCK [8, BYTE];

		BUILTIN
	 	    CVTFD ;

		float_stg_desc [dsc$w_length] = float_buf_len;
		float_stg_desc [dsc$a_pointer] = floating_buffer;
		dbg$fao_put (.output_buffer, open_parenth);
		IF .value_ptr[0,7,9,0] EQL %X'100'	! Illegal floating point?
		THEN
		    BEGIN
		    SIGNAL (DBG$_INVFLOAT);
		    dbg$fao_put (.output_buffer, UPLIT(%ASCIC'!XL'), 
    					.value_ptr[longword_1]);
		    END
		ELSE
		    BEGIN
		    CVTFD(.value_ptr,dbl_value);
		    for$cvt_d_tg (dbl_value, float_stg_desc, float_fra_dig, scale_factor,
					digits_in_int, float_exp_dig );
		    dbg$fao_put (.output_buffer, stg_desc_ascii, float_stg_desc)
		    END;
		dbg$fao_put (.output_buffer, comma_space);
		IF .value_ptr[4,7,9,0] EQL %X'100'	! Illegal floating point?
		THEN
		    BEGIN
		    SIGNAL (DBG$_INVFLOAT);
		    dbg$fao_put (.output_buffer, UPLIT(%ASCIC'!XL'), 
    					.value_ptr[longword_2]);
		    END
		ELSE
		    BEGIN
		    CVTFD(value_ptr[longword_2],dbl_value);
		    for$cvt_d_tg (dbl_value, float_stg_desc, float_fra_dig, scale_factor,
					digits_in_int, float_exp_dig );
		    dbg$fao_put (.output_buffer, stg_desc_ascii, float_stg_desc)
		    END;
		dbg$fao_put (.output_buffer, closed_parenth);
		dbg$gl_next_loc = .value_ptr + 8;
		dbg$gl_last_val = .value_ptr [longword_2];
		END;


	    [dsc$k_dtype_dc]:				! double-precision complex quantity
		BEGIN
		LOCAL
			float_stg_desc	: BLOCK [8, BYTE];

		float_stg_desc [dsc$w_length] = dbl_buf_len;
		float_stg_desc [dsc$a_pointer] = floating_buffer;
		dbg$fao_put (.output_buffer, open_parenth);
		IF .value_ptr[0,7,9,0] EQL %X'100'	! Illegal floating point?
		THEN
		    BEGIN
		    SIGNAL (DBG$_INVFLOAT);
		    dbg$fao_put (.output_buffer, UPLIT(%ASCIC'!XL!XL'), 
    			.value_ptr[longword_2], .value_ptr[longword_1]);
		    END
		ELSE
		    BEGIN
		    for$cvt_d_tg (.value_ptr, float_stg_desc, dbl_fra_dig, scale_factor,
					digits_in_int, dbl_exp_dig );
		    dbg$fao_put (.output_buffer, stg_desc_ascii, float_stg_desc)
		    END;
		dbg$fao_put (.output_buffer, comma_space);
		IF .value_ptr[8,7,9,0] EQL %X'100'	! Illegal floating point?
		THEN
		    BEGIN
		    SIGNAL (DBG$_INVFLOAT);
		    dbg$fao_put (.output_buffer, UPLIT(%ASCIC'!XL!XL'), 
    			.value_ptr[longword_4], .value_ptr[longword_3]);
		    END
		ELSE
		    BEGIN
		    for$cvt_d_tg (value_ptr[longword_3], float_stg_desc, dbl_fra_dig, scale_factor,
					digits_in_int, dbl_exp_dig );
		    dbg$fao_put (.output_buffer, stg_desc_ascii, float_stg_desc)
		    END;
		dbg$fao_put (.output_buffer, closed_parenth);
		dbg$gl_next_loc = .value_ptr + 16;
		dbg$gl_last_val = .value_ptr [longword_3];
		END;


	    [dsc$k_dtype_gc]:				! grand complex
		BEGIN
		LOCAL
			float_stg_desc	: BLOCK [8, BYTE];

		float_stg_desc [dsc$w_length] = grand_buf_len;
		float_stg_desc [dsc$a_pointer] = floating_buffer;
		dbg$fao_put (.output_buffer, open_parenth);
		IF .value_ptr[0,4,12,0] EQL %X'800'	! Illegal floating point?
		THEN
		    BEGIN
		    SIGNAL (DBG$_INVFLOAT);
		    dbg$fao_put (.output_buffer, UPLIT(%ASCIC'!XL!XL'), 
    			.value_ptr[longword_2], .value_ptr[longword_1]);
		    END
		ELSE
		    BEGIN
		    for$cvt_g_tg (.value_ptr, float_stg_desc, grand_fra_dig, scale_factor,
					digits_in_int, grand_exp_dig );
		    dbg$fao_put (.output_buffer, stg_desc_ascii, float_stg_desc)
		    END;
		dbg$fao_put (.output_buffer, comma_space);
		IF .value_ptr[8,4,12,0] EQL %X'800'	! Illegal floating point?
		THEN
		    BEGIN
		    SIGNAL (DBG$_INVFLOAT);
		    dbg$fao_put (.output_buffer, UPLIT(%ASCIC'!XL!XL'), 
    			.value_ptr[longword_4], .value_ptr[longword_3]);
		    END
		ELSE
		    BEGIN
		    for$cvt_g_tg (value_ptr[longword_3], 
    				float_stg_desc, grand_fra_dig, scale_factor,
					digits_in_int, grand_exp_dig );
		    dbg$fao_put (.output_buffer, stg_desc_ascii, 
    				float_stg_desc)
		    END;
		dbg$fao_put (.output_buffer, closed_parenth);
		dbg$gl_next_loc = .value_ptr + 16;
		dbg$gl_last_val = .value_ptr [longword_3];
		END;

	    [dsc$k_dtype_hc]:				! huge complex number
		BEGIN
		LOCAL
			float_stg_desc	: BLOCK [8, BYTE];

		float_stg_desc [dsc$w_length] = huge_buf_len;
		float_stg_desc [dsc$a_pointer] = floating_buffer;
		dbg$fao_put (.output_buffer, open_parenth);
		IF .value_ptr[0,0,15,0] EQL %X'8000'	! Illegal floating point?
		THEN
		    BEGIN
		    SIGNAL (DBG$_INVFLOAT);
		    dbg$fao_put (.output_buffer, UPLIT(%ASCIC'!XL!XL!XL!XL'), 
    				.value_ptr[longword_4], .value_ptr[longword_3],
					.value_ptr[longword_2],.value_ptr[longword_1]);
		    END
		ELSE
		    BEGIN
		    for$cvt_d_tg (.value_ptr, float_stg_desc, huge_fra_dig, scale_factor,
					digits_in_int, huge_exp_dig );
		    dbg$fao_put (.output_buffer, stg_desc_ascii, 
    				float_stg_desc)
		    END;
		dbg$fao_put (.output_buffer, comma_space);
		IF .value_ptr[16,0,15,0] EQL %X'8000'	! Illegal floating point?
		THEN
		    BEGIN
		    SIGNAL (DBG$_INVFLOAT);
		    dbg$fao_put (.output_buffer, UPLIT(%ASCIC'!XL!XL!XL!XL'), 
    			.value_ptr[longword_8], .value_ptr[longword_7],
					.value_ptr[longword_6],.value_ptr[longword_5]);
		    END
		ELSE
		    BEGIN
		    for$cvt_d_tg (value_ptr[longword_5], float_stg_desc, huge_fra_dig, scale_factor,
					digits_in_int, huge_exp_dig );
		    dbg$fao_put (.output_buffer, stg_desc_ascii, 
    				float_stg_desc)
		    END;
		dbg$fao_put (.output_buffer, closed_parenth);
		dbg$gl_next_loc = .value_ptr + 32;
		dbg$gl_last_val = .value_ptr [longword_5];
		END;

	    [dsc$k_dtype_t]:				! ASCII text string
		BEGIN

		size = (IF .default_flag THEN .dbg$gw_dfltleng ELSE .desc[dsc$w_length]);

		dbg$fao_put (.output_buffer, cs_ascii, 
    				.size, value_ptr [longword_1]);
		dbg$gl_next_loc = .value_ptr + .size;
		IF .size GTR %UPVAL
		THEN
		    BEGIN
		    offset = .size - %UPVAL;
		    size = %UPVAL;
		    END
		ELSE
		    offset = 0;
		dbg$gl_last_val = .value_ptr[.offset, 0, .size*8, 0];
		END;


	    [dsc$k_dtype_nu]:				! Numeric string, unsigned
		BEGIN

		size = .desc[dsc$w_length];
		newsize = .size ;

		buffer[0] = %C' ' ;
		CH$MOVE(.size,value_ptr[0,0,0,0],buffer[1]);

		a = (   IF .desc[dsc$b_class] EQL DSC$K_CLASS_SD OR
			.desc[dsc$b_class] EQL DSC$K_CLASS_A OR
			.desc[dsc$b_class] EQL DSC$K_CLASS_nca
			THEN
			    BEGIN
			    decimal_scale(newsize,.desc[dsc$b_scale],buffer,outbuf,false);
			    outbuf
			    END
			ELSE
			    buffer );


		dbg$fao_put (.output_buffer, cs_ascii, .newsize, .a+1 );
		dbg$gl_next_loc = .value_ptr + .size;
		IF .size GTR %UPVAL
		THEN
		    BEGIN
		    offset = .size - %UPVAL;
		    size = %UPVAL;
		    END
		ELSE
		    offset = 0;
		dbg$gl_last_val = .value_ptr[.offset, 0, .size*8, 0];
		END;


	    [dsc$k_dtype_nl,				! Numeric string, left separate sign
	     dsc$k_dtype_nr]:				! Numeric string, right separate sign
		BEGIN

		size = .desc[dsc$w_length];
		newsize = .size ;



		IF .case_index EQL dsc$k_dtype_nl
		THEN
		    CH$MOVE(.size,value_ptr[0,0,0,0],buffer[0])
		ELSE
		    BEGIN
		    CH$MOVE(.size,value_ptr[0,0,0,0],buffer[1]);
		    buffer[0] = .buffer[.size];
		    END;


		newsize = .size - 1 ;			! Get number of digits
	!
	! Now do the scaling of the number if necessary
	!
		a = (   IF .desc[dsc$b_class] EQL DSC$K_CLASS_SD OR
			.desc[dsc$b_class] EQL DSC$K_CLASS_A OR
			.desc[dsc$b_class] EQL DSC$K_CLASS_nca
			THEN
			    BEGIN
			    decimal_scale(newsize,.desc[dsc$b_scale],buffer,outbuf,false);
			    outbuf
			    END
			ELSE
			    buffer );



		dbg$fao_put (.output_buffer, cs_ascii, .newsize+1, .a);
		dbg$gl_next_loc = .value_ptr + .size;
		IF .size GTR %UPVAL
		THEN
		    BEGIN
		    offset = .size - %UPVAL;
		    size = %UPVAL;
		    END
		ELSE
		    offset = 0;
		dbg$gl_last_val = .value_ptr[.offset, 0, .size*8, 0];
		END;


	    [dsc$k_dtype_nlo]:				! Numeric string, left overpunch
		BEGIN

		size = .desc[dsc$w_length];
		newsize = .size ;

		buffer[0] = .sign_tbl[.value_ptr[0,0,8,0]];
		CH$TRANSLATE(lib$ab_cvt_o_u,.size,value_ptr[0,0,0,0],
				%C' ',.size,buffer[1]);

		a =(	IF .desc[dsc$b_class] EQL DSC$K_CLASS_SD OR
			.desc[dsc$b_class] EQL DSC$K_CLASS_A OR
			.desc[dsc$b_class] EQL DSC$K_CLASS_nca
			THEN
			    BEGIN
			    decimal_scale(newsize,.desc[dsc$b_scale],buffer,outbuf,false);
			    outbuf
			    END
			ELSE
			    buffer );



		dbg$fao_put (.output_buffer, cs_ascii, .newsize+1, .a);
		dbg$gl_next_loc = .value_ptr + .size;

		IF .size GTR %UPVAL
		THEN
		    BEGIN
		    offset = .size - %UPVAL;
		    size = %UPVAL;
		    END
		ELSE
		    offset = 0;
		dbg$gl_last_val = .value_ptr[.offset, 0, .size*8, 0];
		END;


	    [dsc$k_dtype_nro]:				! Numeric string, right overpunch
		BEGIN

		size = .desc[dsc$w_length];
		newsize = .size ;

		buffer[0] = .sign_tbl[.value_ptr[.size-1,0,8,0]];
		CH$TRANSLATE(lib$ab_cvt_o_u,.size,value_ptr[0,0,0,0],
				%C' ',.size,buffer[1]);

		a =(	IF .desc[dsc$b_class] EQL DSC$K_CLASS_SD OR
			.desc[dsc$b_class] EQL DSC$K_CLASS_A OR
			.desc[dsc$b_class] EQL DSC$K_CLASS_nca
			THEN
			    BEGIN
			    decimal_scale(newsize,.desc[dsc$b_scale],buffer,outbuf,false);
			    outbuf
			    END
			ELSE
			    buffer );




		dbg$fao_put (.output_buffer, cs_ascii, .newsize+1, .a);
		dbg$gl_next_loc = .value_ptr + .size;
		IF .size GTR %UPVAL
		THEN
		    BEGIN
		    offset = .size - %UPVAL;
		    size = %UPVAL;
		    END
		ELSE
		    offset = 0;
		dbg$gl_last_val = .value_ptr[.offset, 0, .size*8, 0];
		END;


	[dsc$k_dtype_p]:				! Packed decimal string
		BEGIN
		MAP
		    buffer : BLOCK[,BYTE];

		BUILTIN
		    CVTPS;

	        size = .desc[dsc$w_length];
		newsize = .size ;

		CVTPS (size, .value_ptr, size, buffer);

		a = (IF .desc[dsc$b_class] EQL DSC$K_CLASS_SD OR 
			.desc[dsc$b_class] EQL DSC$K_CLASS_A  OR
			.desc[dsc$b_class] EQL DSC$K_CLASS_nca
		     THEN
			 BEGIN
		         decimal_scale(newsize,.desc[dsc$b_scale],buffer,outbuf,false);
			 outbuf
			 END
		     ELSE
			 buffer);


		dbg$fao_put (.output_buffer, cs_ascii, .newsize+1, .a);
		dbg$gl_next_loc = .value_ptr + (.size/2) + 1;
		IF .size GTR %UPVAL
		THEN
		    BEGIN
		    offset = .size - %UPVAL;
		    size = %UPVAL;
		    END
		ELSE
		    offset = 0;
		dbg$gl_last_val = .buffer[.offset, 0, .size*8, 0];
		END;

	    [INRANGE, OUTRANGE]:			! anything else
		RETURN FALSE;

	    TES;


	RETURN TRUE
	END;

ROUTINE decimal_scale(size,scale,inbuf,outbuf,flag): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine will do decimal scaling on the input buffer.
!	That is, we will stick in a decimal point and necessary zeros
!
! FORMAL PARAMETERS:
!
!	size -  address of location that contains the number of digits 
!		in input buffer
!	scale - the decimal scale factor
!	inbuf -	address of the input buffer( expected to be a leading 
!		separate number)
!	outbuf-	address of buffer to hold the scaled number, expected to
!		be large enough to hold the final result
!	flag -  True or False to indicate whether we are to do leading
!		zero suppression
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	the value of SIZE is changed to be the new length of the number
!	including the decimal point if there is one
!
!--

    BEGIN


    MAP
	INBUF : REF VECTOR[,BYTE],
	OUTBUF: REF VECTOR[,BYTE];
    LOCAL 
	S,
	L;


    S = - .SCALE ;					! Get scale as positive
							!  if it is negative

!
! If the scale is GEQ 0 then we only will have to add zeros to the
!  end of the buffer possibly.
!
    IF .SCALE GEQ 0 
    THEN
	BEGIN
	CH$FILL('0',(..SIZE+1+.SCALE),.OUTBUF);		! Make it all zeros
        CH$MOVE(..SIZE+1,.INBUF,.OUTBUF);		! Move in number, add 1 
							!  for the sign at front
	.SIZE = ..SIZE + .SCALE ;			! Update size
	END

!
! So the scale is less than 0. That means a decimal point will have to
!  be put in somewhere.
!

    ELIF .S GTR ..SIZE
    THEN
	BEGIN
!
! We need a decimal point at front with some extra zeros

	CH$FILL('0',.S+2,.OUTBUF);			! Zero fill first
							! Remem sign and point
	OUTBUF[0] = .INBUF[0];				! Get sign
	OUTBUF[1] = %C'.' ;				! Put in point
        L=.S-..SIZE+2;
	CH$MOVE(..SIZE,INBUF[1],OUTBUF[.L]);
	.SIZE = ..SIZE + .L - 1 ;			! Update sign
	END

! Just use the digits we have , we need no zeros

    ELIF .S EQL ..SIZE 
    THEN
	BEGIN
	OUTBUF[0] = .INBUF[0] ;
	OUTBUF[1] = %C'.' ;
	CH$MOVE(..SIZE,INBUF[1],OUTBUF[2]);		! Put in the digits
        .SIZE = ..SIZE + 1 ;				! Update size
	END
    ELSE
	BEGIN
	CH$MOVE((L=..SIZE-.S+1),INBUF[0],OUTBUF[0]);	! Put in whole part
	OUTBUF[.L] = %C'.' ;			! Decimal point
	CH$MOVE(.S,INBUF[.L],OUTBUF[.L+1]);		! Put in fraction
        .SIZE = ..SIZE + 1 ;				! Update size
	END;


! NOW CHECK FOR THE ZERO SUPPRESSION

    IF .flag
    THEN
	BEGIN
	! 
	! SIZE has the length and OUTBUF is the thing to work on
	! Note that we are using S for a flag now
	! Loop through looking for first nonzero item
	s = false ;
	INCR c from 1 to ..size
	DO
	    BEGIN
	    IF .outbuf[.c] NEQ %C'0'
	    THEN
		BEGIN
		s = true ;
		l = .c ;
		EXITLOOP;
		END;
	    END;
!
! If we didn't find anything to exit the loop on , the number has a 
! value of zero so make it a length of 1
 	IF NOT .s
	THEN
	    BEGIN
	    .size = 1 ;
	    END
	ELSE			! we will move from first nonzero back to beginning
	    BEGIN
	    LOCAL t : VECTOR[40,BYTE];
	    CH$MOVE((.size=(..size-.l+1)),outbuf[.l],t[0]);
	    CH$MOVE(..size,t[0],outbuf[1]);
	    END;
	END;
	
    RETURN;
    END;


GLOBAL ROUTINE DBG$READ_ACCESS( ADDR, NUM_BYTES ) =
!++
! Functional Description:
!	Check that we have READ access for the number
!	of bytes indicated, starting at the given address.
!
!	Note that this routine has been modified to use version 3 error
!	reporting, when appropriate.
!
! Inputs:
!	ADDR		-Byte address where desired data begins.
!	NUM_BYTES	-Number of bytes which we want to access.
!	[message_vect]  - Address of a longword to contain the address of a
!			  message argument vector
!
! Implicit Inputs:
!	The PROBER instruction insists on using PSL <prev>, whether
!	we want it to or not.  Until/unless DEBUG is changed to be a
!	multi-mode tool, we will be OK as we are now.  Then, however,
!	we will have to put in substantially more code here to ensure
!	that current and previous mode are the same.
!
! Outputs:
!	None.
!
! Implicit Outputs:
!	None.
!
! Routine Value:
!	TRUE - if access will be granted,
!	If access is not possible routine signals and no return happens, if
!	a version 2 routine has called. If a version 3 has called with the
!	message_vect parameter, then this routine creates a message argument
!	vector and returns error.
!
!
! Side Effects:
!	None.
!
!--

	BEGIN
	BUILTIN
		ACTUALCOUNT,
		ACTUALPARAMETER,
		PROBER;	

	! Set up error handling for version 3 calls

	set_flag (2);

	! Note that we must pass PROBER a zero-extended WORD 
	! address for the LENGTH, and a BYTE address containing
	! the MODE field for the instruction.
	! Later, this byte field should be built by extracting
	! the proper 3 bits from the PSL.

	IF NOT PROBER( %REF(0), NUM_BYTES, .ADDR)
	THEN
	    IF_SIGNAL( dbg$_noaccessr, 1, .addr );	! Output error message

	RETURN TRUE;
	END;

GLOBAL ROUTINE DBG$SHOW_MODULE : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Show which modules from the MC are in the RST.
!
! FORMAL PARAMETERS:
!
!	NONE.
!
! IMPLICIT INPUTS:
!
!	rst$start_addr	-is assumed to point to the beginning
!			 of the MC.
!
! IMPLICIT OUTPUTS:
!
!	Numeric output is always in decimal.
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NOVALUE.
!
! SIDE EFFECTS:
!
!	A summary of the current modules which the RST knows
!	about is written to DBG$OUTPUT.
!
!--

	BEGIN
	LOCAL
		lang_change,		! Flag => all languages are the same.
		lang_name,		! Language encoding for each module.

					! Buffer to build report in.
		output_buffer : VECTOR[ TTY_OUT_WIDTH, BYTE ],

		NUM_MC_ENTRIES,		! How many entries there are in the MC.

		MC_PTR : REF rst$entry;	! Pointer to current MC record.

	! Set up to do standard DEBUG I/O.

	dbg$cp_out_str = output_buffer +1;
	dbg$gl_buf_siz = 0;

	! Initialize the pointer that we use to
	! 'chain' thru the module chain.

	IF( (MC_PTR = .rst$start_addr) EQL 0 )
	THEN
		BEGIN
		SIGNAL(DBG$_NOLOCALS);
		RETURN;
		END;

	! Just the existence of the MC doesn't mean that
	! we have anything to report on here - there may
	! only be the 1 MC record used to 'hang' globals
	! off.  If this is the case, produce a message
	! and get out.

	IF ( .rst$start_addr[rst$l_nxtmodptr] EQL 0 )
	THEN
		BEGIN
		SIGNAL(DBG$_NOLOCALS);
		RETURN;
		END;

	! See if the language which all modules are written
	! happens to be the same.

	lang_change = FALSE;

	IF( (mc_ptr = .mc_ptr[rst$l_nxtmodptr]) NEQ 0 )
	THEN
		BEGIN

		lang_name = .mc_ptr[rst$b_language];

		! Loop thru the entire MC to see if the language changes.

		WHILE( (mc_ptr = .mc_ptr[rst$l_nxtmodptr]) NEQ 0 )
			DO
			BEGIN
			IF( .lang_name NEQ .mc_ptr[rst$b_language] )
			THEN
				BEGIN
				lang_change = TRUE;
				EXITLOOP;
				END;
			END;

		! Restore MC_PTR to what it would be if this
		! loop had not been entered.

		mc_ptr = .rst$start_addr;
		END;

	! Print out the title, and then loop thru the
	! module chain simply giving the relevant
	! information for each module which we know about.

	num_mc_entries = 0;

	dbg$fao_put( output_buffer, UPLIT( %ASCIC 
'module name                     symbols   '));
	IF( .lang_change )
	THEN
		DBG$FAO_PUT( output_buffer, UPLIT( %ASCIC 'language  ' ));
	dbg$fao_put( output_buffer, uplit( %ascic ' size!/' ));
	dbg$out_put(output_buffer);

	! Don't print out the 'fake' MC record which we 
	! keep around to 'hang' globals off.

	WHILE( (mc_ptr = .mc_ptr[rst$l_nxtmodptr]) NEQ 0 )
		DO
		BEGIN

		! Print out the standard information - name and 
		! whether or not it has been initialized into the RST.

		num_mc_entries = .num_mc_entries +1;
		dbg$cp_out_str = output_buffer +1;
		dbg$gl_buf_siz = 0;
		IF dbg$rst_name_count(.mc_ptr) GTR 31
		THEN
		BEGIN
		    $fao_tt_out ('!63AC', dbg$rst_name_addr(.mc_ptr));
		    dbg$fao_put( output_buffer, 
			UPLIT( %ASCIC '!32* !3AC       '),
  			(IF( .mc_ptr[rst$v_modset] )
			THEN
				UPLIT( %ASCIC 'yes' )
			ELSE
				UPLIT( %ASCIC 'no' )));
		END

		ELSE
		dbg$fao_put(output_buffer, UPLIT( %ASCIC '!31AC !3AC       ' ),
			dbg$rst_name_addr(.mc_ptr),
			(IF( .mc_ptr[rst$v_modset] )
			THEN
				UPLIT( %ASCIC 'yes' )
			ELSE
				UPLIT( %ASCIC 'no' ))
			);

		IF .lang_change
		THEN
			dbg$fao_put(output_buffer, UPLIT( %ASCIC '!10AC' ),
				dbg$language(.mc_ptr[rst$b_language]));

		dbg$fao_put (output_buffer, UPLIT(%ASCIC '!5SL'), 
					.mc_ptr[rst$l_modrstsiz]);


		! Finally output the buffer. If this is the last module
		! append a <CRLF>.

		IF .mc_ptr[rst$l_nxtmodptr] EQL 0
		THEN
			dbg$fao_put (output_buffer, UPLIT (%ASCIC '!/'));

		dbg$out_put(output_buffer);
		END;

	! Give final summary information.

	dbg$cp_out_str = output_buffer +1;
	dbg$gl_buf_siz = 0;
	dbg$fao_put( output_buffer, UPLIT( %ASCIC 'total '));
	IF( (NOT .lang_change) AND .num_mc_entries NEQ 0 )
	then
		dbg$fao_put( output_buffer, UPLIT( %ASCIC '!AC '), 
    				dbg$language(.lang_name));
	dbg$fao_put( output_buffer, UPLIT( %ASCIC 'modules: !SL.'),
    			 .num_mc_entries);
	dbg$fao_put( output_buffer, UPLIT( %ASCIC '!_!_remaining size: !SL.'), 
    			 dbg$report_free() );
	dbg$out_put(output_buffer);
END;

GLOBAL ROUTINE DBG$PRINT_PATH( PATHname_PTR , output_buf) : NOVALUE =
!++
! Functional Description:
!
!	Encode a pathname vector into the output stream
!
! Formal Parameters:
!
!	PATHname_PTR	-A pointer to the pathname vector we want printed.
!
! Implicit Inputs:
!
!	Some exterior routine has done all the setup for
!	DEBUG standard I/O.  This routine just does 'puts'.
!
! Return Value:
!
!	NOVALUE.
!
! Side Effects:
!
!	The pathname is encoded into the current output buffer.
!
!--

BEGIN
	MAP
		PATHname_PTR : REF pth$pathname;
	LOCAL
		path_vec_ptr : REF VECTOR[],
		cs_ptr0 : cs_pointer,
		cs_ptr1 : cs_pointer,
		sym_buffer : cs_pointer;

	path_vec_ptr = pathname_ptr[pth$a_pathvector];
	IF .pathname_ptr[pth$b_totcnt] GTR 1
	THEN
		BEGIN
		cs_ptr0 = .path_vec_ptr[0];
		cs_ptr1 = .path_vec_ptr[1];
		IF CH$EQL(.cs_ptr0[0],cs_ptr0[1],.cs_ptr1[0],cs_ptr1[1])
		THEN
			BEGIN
			pathname_ptr[pth$b_totcnt] = .pathname_ptr[pth$b_totcnt]-1;
			pathname_ptr[pth$b_pathcnt] = .pathname_ptr[pth$b_pathcnt]-1;
			IF .pathname_ptr[pth$b_locinvoc] NEQ 0
			THEN
				pathname_ptr[pth$b_locinvoc] =
					.pathname_ptr[pth$b_locinvoc] - 1;
			INCR i FROM 0 TO .pathname_ptr[pth$b_totcnt]
			DO
				path_vec_ptr[.i] = .path_vec_ptr[.i + 1];
		END;
	END;
	dbg$npathdesc_to_cs( .pathname_ptr, sym_buffer );

	! Then simply output the pathname.

	dbg$fao_put (.output_buf, UPLIT(%ASCIC '!AC'), .sym_buffer );
END;

GLOBAL ROUTINE DBG$OUT_DIMENSN( DESCRIP_BLOCK, OUT_BUF ) : NOVALUE =
!++
! Functional Description:
! 
!	Build a string showing valid array bounds for a FORTRAN array.
!  
! Formal Parameters :
!
!	DESCRIP_BLOCK		Address of SRM array descriptor (Class A)
!
!	OUT_BUF			Address of buffer where string is to be built
!
! Implicit Inputs :
!
!	Some other routine has done the set up for the output buffer.
!
! Implicit Outputs :
!
!	The output buffer is filled.
!
! Routine Value :
!
!	NOVALUE
!
! Side Effects :
!
!	The output buffer is filled.
!
!--
BEGIN
	MAP
		descrip_block : REF BLOCK [,BYTE],
		out_buf       : REF VECTOR [,BYTE];
  
	LOCAL
		span_block : REF VECTOR,
		bounds     : REF VECTOR,
		bound_lim		,
		no_dim                 ;
  
!
! Set up for standard DEBUG I/O
!
 
dbg$cp_out_str = .out_buf + 1;
dbg$gl_buf_siz = 0 ;
 
!
! set up pointers to longwords containing array bounds and dimension info
!
 
no_dim = .descrip_block [dsc$b_dimct] ;
span_block = descrip_block [dsc$l_m1] ;
bounds     = span_block [.no_dim]     ;
 
!
! Build the string...
!
 
bound_lim = (2 * .no_dim) - 1 ;

INCR i FROM 0 TO .bound_lim BY 2
	DO  BEGIN
	    IF .bounds [.i] NEQ 1
		THEN dbg$fao_put (.out_buf, UPLIT (%ASCIC '!SL:'), 
    			 .bounds [.i]) ;
	    IF .i NEQ .bound_lim - 1
		THEN dbg$fao_put (.out_buf, UPLIT (%ASCIC '!SL, '), 
    			 .bounds [.i+1])
		ELSE dbg$fao_put (.out_buf, UPLIT (%ASCIC '!SL'),  
    			 .bounds [.i+1]) ;

	    END ;
 
!
!	fill in the count
!
	out_buf[0] = .dbg$gl_buf_siz ;
END;

GLOBAL ROUTINE DBG$SHOW_TYPE(FLAG) : NOVALUE =
!++
! Functional Description:
!
!	Print out the type specified in a SET TYPE[/OVERRIDE] statement,
!	depending on the value of the input parameter.
!
! Formal Parameters:
!
!	A flag to indicate whether the override type or the default type is to
!	be printed 
!
! Implicit Inputs:
!
!	The type information stored in dbg$gl_dflttyp, dbg$gw_dfltleng, 
!		dbg$gbl_gbltyp, dbg$gw_gbllngth.
!
! Return Value:
!
!	NOVALUE
!
!--

BEGIN
	LOCAL
		LENGTH : WORD, 		! local storage for the appropriate
		TYPE,			! length and type values.
			! Build output message here.
		OUTPUT_BUFFER : VECTOR[ TTY_OUT_WIDTH, BYTE ];


	! Set up to use a new output buffer,
	! and encode the standard beginning of
	! the SHOW TYPE message into it.

	dbg$cp_out_str = output_buffer + 1;
	dbg$gl_buf_siz = 0;

	!Insert the standard prefix.

	CASE .flag FROM default TO override OF
	    SET
		[default] :
				BEGIN
				dbg$fao_put( output_buffer, 
    					UPLIT( %ASCIC 'type: '));
				type = .dbg$gl_dflttyp;
				length = .dbg$gw_dfltleng;
				END;

		[override] : 	
				BEGIN
				dbg$fao_put( output_buffer, 
    					UPLIT( %ASCIC 'type/override: '));
				type = .dbg$gl_gbltyp;
				length = .dbg$gw_gbllngth;
				END;
	    TES;
	
	! We print out a character string which indicates the type.

	CASE .type FROM -1 TO dsc$k_dtype_highest OF
		SET
		[-1] :
			BEGIN
			dbg$fao_put( output_buffer, UPLIT( %ASCIC 'none'));
			END;
		[dsc$k_dtype_l] : 
			BEGIN
			dbg$fao_put( output_buffer, 
    				UPLIT( %ASCIC 'long integer'));
			END;
		[dsc$k_dtype_w] :
			BEGIN
			dbg$fao_put( output_buffer, 
    				UPLIT( %ASCIC 'word integer'));
			END;
		[dsc$k_dtype_b] :
			BEGIN
			dbg$fao_put( output_buffer, 
    				UPLIT( %ASCIC 'byte integer'));
			END;
		[dsc$k_dtype_zi] :
			BEGIN
			dbg$fao_put( output_buffer, 
    				UPLIT( %ASCIC 'instruction' ));
			END;
		[dsc$k_dtype_t] :
			BEGIN
			LOCAL 
				STRING_DESC : BLOCK [8,BYTE],
				COUNTED_STRNG : VECTOR[6,BYTE];
				
			! put keyword in buffer

			dbg$fao_put( output_buffer, UPLIT( %ASCIC 'ascii: '));

			! convert the length to counted string.
			counted_strng[0] = 5;
			string_desc[dsc$w_length] = 5;
			string_desc[dsc$a_pointer] = counted_strng[1];
			for$cnv_out_i(.length, string_desc);

			! place the result in the output buffer.
			dbg$fao_put( output_buffer, counted_strng);
			END;

		[dsc$k_dtype_q] :
			BEGIN
			dbg$fao_put( output_buffer,
				UPLIT( %ASCIC 'quadword integer' ));
			END;

		[dsc$k_dtype_o] :
			BEGIN
			dbg$fao_put( output_buffer,
				UPLIT( %ASCIC 'octaword integer' ));
			END;

		[dsc$k_dtype_f] :
			BEGIN
			dbg$fao_put( output_buffer,
				UPLIT( %ASCIC 'f_float' ));
			END;

		[dsc$k_dtype_d] :
			BEGIN
			dbg$fao_put( output_buffer,
				UPLIT( %ASCIC 'd_float' ));
			END;

		[dsc$k_dtype_g] :
			BEGIN
			dbg$fao_put( output_buffer,
				UPLIT( %ASCIC 'g_float' ));
			END;

		[dsc$k_dtype_h] :
			BEGIN
			dbg$fao_put( output_buffer,
				UPLIT( %ASCIC 'h_float' ));
			END;

		[inrange, outrange] : SIGNAL (dbg$_debugbug,1,dbg$k_bad_type);
		TES;

	! output the completed buffer.
	dbg$out_put(output_buffer);
END;	! of DBG$SHOW_TYPE.

END
ELUDOM
