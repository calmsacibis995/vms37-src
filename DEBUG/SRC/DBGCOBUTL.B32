MODULE	DBGCOBUTL(IDENT = 'V03-000') =
BEGIN
!
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
!++
!
! FACILITY:	VAX-11 COBOL-SPECIFIC DEBUGGER MODULES
!
! ABSTRACT:
!
!	Cobol-Specific utility routines for VAX/VMS DEBUG
!
! ENVIRONMENT:	VAX/VMS user mode
!
! AUTHOR:	J. Francis,	CREATION DATE: 1-May-1981
!
! MODIFIED BY:
!
!--

!
! Table of Contents
!
FORWARD ROUTINE
! Global Routines :
	dbg$ncob_copy_desc,			! Retain copy of transient data
	dbg$ncob_free_desc,			! Release  "  "    "   "     "
	dbg$ncob_force_to_numeric,		! Get value into internal format
	dbg$ncob_get_length,			! Get space used by variable
	dbg$ncob_get_lval,			! Get address of symbol
	dbg$ncob_get_rval,			! Get value of symbol
	dbg$ncob_get_pages,			! Get pages used by variable
	dbg$ncob_get_symid,			! Get SYMID list for symbol
	dbg$ncob_get_type,			! Check type of entities
	dbg$ncob_log_predsuc,			! Get 'adjacent' data item
	dbg$ncob_make_desc,			! Initialize descriptor
	dbg$ncob_make_packed_desc,		! Construct packed decimal value
	dbg$ncob_make_val_desc,			! Construct value descriptor
	dbg$ncob_make_vax_desc,			! Construct VAX/VMS descriptor
	dbg$ncob_pathdesc_to_cs : NOVALUE,	! Get printable form of name
	dbg$ncob_prim_out,			! Format name & value
	dbg$ncob_range_val,			! (Not Yet Implemented)
	dbg$ncob_symbolize,			! Obtain name for symbol
	dbg$ncob_symbolize_num	: NOVALUE;	! Convert number to text

!
! INCLUDE FILES
!
REQUIRE 'SRC$:DBGPROLOG';
!
!
! EXTERNALS
!
EXTERNAL ROUTINE
	dbg$ncob_type_conv,			! COBOL type converter
	dbg$ncob_convert_to_packed,		! Convert anything to packed
	dbg$get_tempmem,			! Storage space allocator
	dbg$get_memory,				! Preserved memory allocator
	dbg$rel_memory		: NOVALUE,	! Return memory to free pool
	dbg$nmake_arg_vect,			! Error message builder
	dbg$sta_sympathname	: NOVALUE,	! Get fully qualifed symbol name
	dbg$sta_getsymbol	: NOVALUE,	! Symbol lookup routine
	dbg$sta_setcontext	: NOVALUE,	! Context establishing routine
	dbg$sta_symvalue	: NOVALUE,	! Return value of symbol
	dbg$sta_symsize		: NOVALUE,	! Return length of symbol
	dbg$sta_symtype		: NOVALUE,	! Return type of symbol
	dbg$sta_symkind		: NOVALUE,	! Return kind of symbol
	dbg$sta_symname		: NOVALUE,	! Return name of symbol
	dbg$sta_typ_atomic	: NOVALUE,	! Routines for obtaining "type"
	dbg$sta_typ_descr	: NOVALUE,	!  information about data items
	dbg$sta_typ_array	: NOVALUE,	!    .    .    .    .    .    .
	dbg$sta_typ_pict	: NOVALUE,	!    .    .    .    .    .    .
	dbg$sta_typ_record	: NOVALUE,	!    .    .    .    .    .    .
	dbg$sta_symparent,			! Get "parent" of record item
	dbg$sta_record_index,			! Get index of record component
	dbg$sta_record_component,		! Get SYMID of record component
	dbg$npathdesc_to_cs	: NOVALUE;	! Get full name of data item

!
! MACROS
!
FIELD dbg$ncob_fields =
    SET
    cob_primary_kind	= [2,B0_],	! KIND of primary descriptor
    cob_primary_symid	= [3,L_],	! SYMID of actual data item
    cob_subscript_count = [2,B1_],	! Count of subscripts
    cob_subscript_vector= [4,A_],	! Vector of subscript values
    cob_value_vmsdesc	= [2,A_],	! VAX/VMS standard descriptor for value
    cob_value_dschead	= [2,L_],	! Maps first 4 bytes of descriptor
    cob_value_dtype	= [2,B2_],	! "Dtype" field of descriptor
    cob_value_pointer	= [3,L_],	! Pointer to actual data item
    cob_value_scaling	= [4,L_],	! Scale factor and digit-count
    cob_value_picture	= [5,L_],	! TYPEID of picture if edited
    cob_value_literal	= [6,L_],	! "Value" for integer items
    cob_value_byte	= [6,B_],	! Reference to short
    cob_value_word	= [6,W_],	! (less than 32 bit)
    cob_value_long	= [6,L_],	!   integer values
    cob_value_high	= [7,L_],	! High-order 32 bits of quadword
    cob_value_address	= [6,A_]	! Address of first byte of value
   TES;
LITERAL cob_fixed = 4;
MACRO dbg$ncob_descriptor = BLOCK[cob_fixed]
			    FIELD(dbg$dhead_fields,dbg$ncob_fields) %;
!
! LITERALS
!

LITERAL	class_s_dtypes	= (1^dsc$k_dtype_bu) + (1^dsc$k_dtype_wu)
			+ (1^dsc$k_dtype_lu) + (1^dsc$k_dtype_qu)
			+ (1^dsc$k_dtype_b)  + (1^dsc$k_dtype_w)
			+ (1^dsc$k_dtype_l)  + (1^dsc$k_dtype_q)
			+ (1^dsc$k_dtype_f)  + (1^dsc$k_dtype_d)
			+ (1^dsc$k_dtype_nz) + (1^dsc$k_dtype_nu)
			+ (1^dsc$k_dtype_nl) + (1^dsc$k_dtype_nlo)
			+ (1^dsc$k_dtype_nr) + (1^dsc$k_dtype_nro)
			+ (1^dsc$k_dtype_t)  + (1^dsc$k_dtype_p),

	class_d_dtypes	= (1^dsc$k_dtype_nz) + (1^dsc$k_dtype_nu)
			+ (1^dsc$k_dtype_nl) + (1^dsc$k_dtype_nlo)
			+ (1^dsc$k_dtype_nr) + (1^dsc$k_dtype_nro)
			+ (1^dsc$k_dtype_t)  + (1^dsc$k_dtype_p),

	class_sd_dtypes	= (1^dsc$k_dtype_bu) + (1^dsc$k_dtype_wu)
			+ (1^dsc$k_dtype_lu) + (1^dsc$k_dtype_qu)
			+ (1^dsc$k_dtype_b)  + (1^dsc$k_dtype_w)
			+ (1^dsc$k_dtype_l)  + (1^dsc$k_dtype_q)
			+ (1^dsc$k_dtype_nz) + (1^dsc$k_dtype_nu)
			+ (1^dsc$k_dtype_nl) + (1^dsc$k_dtype_nlo)
			+ (1^dsc$k_dtype_nr) + (1^dsc$k_dtype_nro)
			+ (1^dsc$k_dtype_t)  + (1^dsc$k_dtype_p);

GLOBAL ROUTINE DBG$NCOB_COPY_DESC (input_desc, copy, msg_vect) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Accepts as input a language specific primary or value descriptor
!	(constructed from listed storage)
!	and makes a copy of the descriptor out of non-listed storage. This
!	non-volatile copy will be stored in conjunction with x-points and
!	current location.
!
!	This routine may use DBG$NCOPY to copy each portion of the
!	descriptor that has been created from listed dynamic storage.
!
! FORMAL PARAMETERS:
!
!	input_desc		- The address of a language specifc primary or
!				  value descriptor
!
!	copy			- The address of a longword to contain the address
!				  of the non-volatile copy of the descriptor
!
!	msg_vect		- The address of a longword to contain the address
!				  of a message argument vector for errors
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	On success, the non-volatile copy of a primary descriptor.
!
!	On failure, a message argument vector.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS   (1)     - Success. Copy constructed and returned.
!
!	STS$K_SEVERE    (4)     - Failure. Copy not produced. Message argument
!				  vector constructed and returned.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

!DBG$NCOB_COPY_DESC (input_desc, copy, msg_vect)
    BEGIN
    MAP   input_desc : REF dbg$ncob_descriptor;
    LOCAL local_desc : REF dbg$ncob_descriptor;

    .copy = local_desc = dbg$get_memory(.input_desc[dbg$w_dhead_length]/%UPVAL);
    ch$move(.input_desc[dbg$w_dhead_length],.input_desc,.local_desc);
    IF .local_desc[dbg$b_dhead_type] EQL dbg$k_value_desc
      THEN local_desc[cob_value_pointer] = local_desc[cob_value_address];
    RETURN sts$k_success;
    END;		! end of routine dbg$ncob_copy_desc

GLOBAL ROUTINE DBG$NCOB_FREE_DESC (desc, msg_vect) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Releases dynamic storage associated with a non-volatile copy of a
!	language specific value or primary descriptor.
!	This routine accepts as input a copy of a primary or value
!	descriptor produced by DBG$NCOB_COPY_DESC and calls the
!	routine DBG$NFREERELEASE to release each block of non-listed dynamic
!	storage contained within the descriptor.
!
! FORMAL PARAMETERS:
!
!	desc			- The address of a non-volatile primary or
!				  value descriptor
!
!	msg_vect		- The address of a longword to contain the address
!				  of a message argument vector for errors
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	On failure, a message argument vector.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS	(1)	- Success. Storage for  descriptor released.
!
!	STS$K_SEVERE	(4)	- Failure. Storage for descriptor not released. Message
!				  argument vector constructed and returned.
!
! SIDE EFFECTS:
!
!	Dynamic memory is returned to the free storage pool.
!
!--
    BEGIN
    dbg$rel_memory(.desc);
    RETURN sts$k_success;
    END;		! end of routine dbg$ncob_free_desc;

GLOBAL ROUTINE DBG$NCOB_FORCE_TO_NUMERIC(valdsc_ptr,msg_vect) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	 Check that a COBOL value descriptor describes a numeric value
!	which is either a (signed) integer or a packed decimal number.
!	 All other data-types will be converted to packed decimal, and
!	the pointer to the COBOL value descriptor will be updated with
!	the address of the new descriptor.
!
! FORMAL PARAMETERS:
!
!	valdsc_ptr	- The address of a longword which holds a pointer
!			  to a COBOL value descriptor.
!
!	msg_vect	- The address of a longword to contain the address
!			  of a message argument vector as described on page
!			  4-119 of the VAX/VMS system reference, volume 1A
!
! IMPLICIT OUTPUTS:
!
!	 If the COBOL value descriptor describes an unsigned integer value
!	the data-type field in the embedded VAX/VMS descriptor will be set
!	to the corresponding signed integer data-type.
!--

! DBG$NCOB_FORCE_TO_NUMERIC(valdsc_ptr,msg_vect)
    BEGIN

    BIND value_desc = .valdsc_ptr : REF dbg$ncob_descriptor;



    !+
    ! Dispatch on data-type of data item.
    !-
    CASE .value_desc[cob_value_dtype] FROM dsc$k_dtype_bu TO dsc$k_dtype_p
     OF SET
	[dsc$k_dtype_bu,dsc$k_dtype_wu,
	 dsc$k_dtype_lu,dsc$k_dtype_qu] :
	    !+
	    ! Change unsigned integer data-types to signed data-types.
	    !-
	    value_desc[cob_value_dtype] = .value_desc[cob_value_dtype] + 4;

	[dsc$k_dtype_b,dsc$k_dtype_w,
	 dsc$k_dtype_l,dsc$k_dtype_q,
	 dsc$k_dtype_p] :
	    !+
	    ! Nothing to do for integer or packed decimal data-types.
	    !-
	    0;

	[dsc$k_dtype_f,dsc$k_dtype_d,dsc$k_dtype_nlo,dsc$k_dtype_nro,
	 dsc$k_dtype_nl,dsc$k_dtype_nr,dsc$k_dtype_nu,dsc$k_dtype_nz,
	 dsc$k_dtype_t] :
	    !+
	    ! Force all other data-types to packed decimal.
	    !-
	    IF NOT dbg$ncob_make_packed_desc(value_desc[cob_value_vmsdesc],
					     .valdsc_ptr,.msg_vect)
		THEN RETURN sts$k_severe;
	[INRANGE,OUTRANGE] :
	    RETURN_ERROR(.msg_vect,dbg$_unimplent);
	TES;
    RETURN sts$k_success;
    END;	! end of routine dbg$ncob_force_to_numeric

GLOBAL ROUTINE DBG$NCOB_GET_LENGTH (prim_desc, length, msg_vect) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Uses a symbol's primary descriptor to obtain the length of the symbol's
!	rvalue. The length is to be given in bits. Lengths longer than 2**32 - 1
!	must be truncated to this length.
!
!	The debugger assumes that rvalues refer to contiguous blocks of storage.
!	If this is not true for a given variable, this routine fails.
!
!	Length should reflect the maximum length for entities that may vary in
!	size, and include the length of a control word, if one is present.
!
!	This routine is called, among other things, to determine the length
!	of an object to be watchpointed. If the object described by the input
!	primary descriptor cannot have its value converted to external format
!	by the language specific dbg$ncob_type_conv routine, then this routine
!	should return sts$k_info. Note that this situation is presently true
!	for objects with aggregate values such as array references without
!	subscripts, and entire records and structures.
!
!
!
! FORMAL PARAMETERS:
!
!	prim_desc	- A longword containing the address of a primary descriptor
!
!	length		- The address of a longword to contain an unsigned integer
!			  longword representing the symbol's rvalue length in bits
!
!	msg_vect	- The address of a longword to contain the address of a
!			  message argument vector as described on page 4-119 of
!			  the VAX/VMS system reference, volume 1A
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	In case of a severe error return, a message argument vector is constructed
!	from dynamic storage and returned.

!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) - Success. Length of symbol's rvalue returned.
!
!	STS$K_INFO    (3) - Success. Length of symbol's rvalue returned but
!			    the symbol refers to object whose value cannot be
!			    converted to external format by dbg$ncob_type_conv.
!
!	STS$K_SEVERE  (4) - Failure. No length returned. Message argument vector
!			    constructed and returned.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

!dbg$ncob_get_length(prim_desc,length,msg_vect)
    BEGIN
    MAP prim_desc : REF dbg$ncob_descriptor;

    LOCAL
	vax_desc  : BLOCK [12,BYTE],		! VAX/VMS descriptor
	size,pict;

    IF NOT dbg$ncob_make_vax_desc(.prim_desc,vax_desc,size,pict,.msg_vect)
      THEN RETURN sts$k_severe;

    .length = .size*%BPUNIT;
    RETURN sts$k_success;
    END;		! end of routine dbg$ncob_get_length

GLOBAL ROUTINE DBG$NCOB_GET_LVAL (prim_desc, lvalue, msg_vect) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Obtains a symbol's lvalue using the primary descriptor for that
!	symbol. Note that most types of named constants do not have an
!	lvalue. The debugger gives special treatment to named constants
!	which have read only memory allocated to contain their value.
!
! FORMAL PARAMETERS:
!
!	prim_desc	- A longword which contains the address of a primary descriptor
!
!	lvalue		- The address of a quadword to contain the lvalue of the
!			  entity described by the primary descriptor and the bit
!			  offset, if any. The byte address will be contained in
!			  in the first longword, the bit offset in the second
!			  longword.
!
!	msg_vect	- The address of a longword to contain the address of
!			  a message argument vector as described on page 4-119
!			  of the VAX/VMS system reference, volume 1A
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	An unsigned longword integer completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) - Success. The object described by the input primary
!			    descriptor has an lvalue which is being returned.
!
!	STS$K_ERROR   (2) - Failure. Object does not have an lvalue. 
!
! SIDE EFFECTS:
!
!	NONE
!
!--

!DBG$NCOB_GET_LVAL(prim_desc,lvalue,msg_vect)
    BEGIN
    !
    ! Describe formal parameters that are structures
    !
    MAP prim_desc : REF dbg$ncob_descriptor,
	lvalue    : REF VECTOR[2,LONG];

    LOCAL
	vax_desc  : BLOCK[12,BYTE],
	symid,
	adr_ptrs  : VECTOR[3,LONG],
	adr_kind,
	val_kind,
	length,
	picture;

    BIND
	address = vax_desc[dsc$a_pointer],
	offset  = adr_ptrs[0];

    symid = .prim_desc[cob_primary_symid];
    dbg$sta_setcontext(.symid);
    dbg$sta_symvalue(.symid,adr_ptrs,adr_kind);
    IF .adr_ptrs[1] NEQ 0 THEN RETURN_ERROR(.msg_vect,dbg$_illtype);
    address = lvalue[1] = 0;
    dbg$sta_symkind(.symid,val_kind);
    CASE .val_kind FROM rst$k_kind_minimum TO rst$k_kind_maximum OF
	SET
	[rst$k_entry,rst$k_routine,rst$k_label,rst$k_line] :
	    BEGIN
	    SELECTONE .adr_kind OF
		SET
		[dbg$k_val_addr] :	address = .address + .offset;
		[dbg$k_val_descr] :	address = .address + .(.offset+4);
		[OTHERWISE] :		RETURN sts$k_error;
		TES;
	    END;
	[rst$k_data] :
	    IF NOT dbg$ncob_make_vax_desc(.prim_desc,vax_desc,length,picture,.msg_vect)
	      THEN RETURN sts$k_severe;
	[INRANGE,OUTRANGE] :
	    RETURN sts$k_error;
	TES;
    lvalue[0] = .address;
    RETURN sts$k_success;
    END;		! end of routine dbg$ncob_get_lval

GLOBAL ROUTINE DBG$NCOB_GET_RVAL (prim_desc, rvalue, msg_vect) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Uses a symbol's primary descriptor to obtain an rvalue for that symbol.
!	This rvalue is assumed by the debugger to be an integer longword. Byte
!	and word integers should be extended to longword size. If the rvalue
!	of the entity is not representable by a longword integer, then this
!	routine should fail (This is the case for floating point, complex, etc.
!	rvalues).
!
!	This routine is used to materialize the rvalue of a symbol in the
!	following two cases:
!
!		1) When the GET_TYPE routine has indicated that a symbol
!		   has a type of named-constant and the value of the constant
!		   must be obtained.
!
!		2) When the special DEBUG fetch operator has been applied to
!		   a symbol in an address expression. Note that when the
!		   fetch operator has been applied to a routine or label
!		   variable, a type of instruction must be associated with the
!		   rvalue. This routine uses a special return to indicate
!		   this circumstance. In all other cases, the rvalue is assumed
!		   to be untyped.
!
! FORMAL PARAMETERS:
!
!	prim_desc	- A longword containing the address of a primary descriptor
!
!	rvalue		- The address of a longword to contain the object's rvalue
!
!	msg_vect	- The address of a longword to contain the address of a
!			  message argument vector as described on page 4-119 of
!			  the VAX/VMS system reference, volume 1A

!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	In case of a severe error return, a message argument vector must be
!	constructed from dynamic storage and returned.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) - Success. The rvalue of the object described by the
!			    input primary descriptor is returned.
!
!	STS$K_WARNING (0) - Warning. The rvalue of the object described by the
!			    input primary descriptor is returned, but a type
!			    of instruction must be associated with it.
!
!	STS$K_SEVERE  (4) - Failure. The rvalue could not be obtained for the
!			    object, or the rvalue is not expressable by an
!			    integer longword. Message argument vector
!			    constructed and returned.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

!DBG$NCOB_GET_RVAL (prim_desc, rvalue, msg_vect)
    BEGIN
    MAP prim_desc : REF dbg$ncob_descriptor;
    LOCAL
	val_kind,
	val_table : VECTOR[3,LONG];
    dbg$sta_setcontext(.prim_desc[cob_primary_symid]);
    dbg$sta_symvalue(.prim_desc[cob_primary_symid],val_table,val_kind);
    CASE .prim_desc[cob_primary_kind] FROM rst$k_kind_minimum TO rst$k_kind_maximum OF
	SET
	[rst$k_line,rst$k_label,
	rst$k_entry,rst$k_block,rst$k_routine] :
	    BEGIN
	    SELECTONE .val_kind OF
		SET
		[dbg$k_val_addr] :
		    .rvalue = .val_table[0];
		[dbg$k_val_descr] :
		    .rvalue = .(.val_table[0] + 4);
		[OTHERWISE] :
		    RETURN_ERROR(.msg_vect,dbg$_novalue);
		TES;
	    RETURN sts$k_success;
	    END;
	[INRANGE,OUTRANGE] :
	    RETURN_ERROR(.msg_vect,dbg$_unimplent);
	TES;

    END;		! end of routine dbg$ncob_get_rval

GLOBAL ROUTINE DBG$NCOB_GET_PAGES (prim_desc, page_list, msg_vect) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Uses a symbol's primary descriptor to construct a linked list of page
!	numbers which reflect those pages of storage in which the symbol's
!	rvalue is contained. Note that the pages may be non-contiguous.
!	Only one entry per page should be constucted in the page list.
!
!	Control words, if present, are to be considered part of the rvalue.
!
!	A page number is represented by the high order 23 bits of a virtual 
!	address, with the low order 9 bits set to 0:
!
!	page = (virtual_address AND B'11111111111111111111111000000000')
!
! FORMAL PARAMETERS:
!
!	prim_desc	- A longword containing the address of a primary descriptor
!
!	page_list	- The address of a longword to contain the address of the
!			  head node in the page list. Nodes in the page list
!			  consist of blocks of two longwords each. The second
!			  longword of the node block contains a page number on
!			  which some portion of the symbol's rvalue resides. The
!			  first longword of the node block contains the address
!			  of the next node in the list. The last node in the list
!			  should contain a 0 in this link field.
!
!	msg_vect	- The address of a longword to contain the address of
!			  a message argument vector as described on page 4-119
!			  of the VAX/VMS system reference, volume 1A
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	In case of a success return, the page list is constructed from dynamic
!	storage and returned.
!
!	In case of a severe error return, a message arguement vector is constructed
!	and returned.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) - Success. Page list constructed and returned.
!
!	STS$K_SEVERE  (4) - Failure. Page list not constructed. Message argument
!			    vector constructed and returned.
!
!--

!dbg$ncob_get_pages(prim_desc,page_list,msg_vect)
    BEGIN
    MAP prim_desc : REF dbg$ncob_descriptor;
    LOCAL address : VECTOR [2,LONG],
	list_item : REF dbg$link_node,
	next_item;

    IF NOT dbg$ncob_get_lval  (.prim_desc,address[0],.msg_vect) THEN RETURN sts$k_severe;

    IF NOT dbg$ncob_get_length(.prim_desc,address[1],.msg_vect) THEN RETURN sts$k_severe;

    address[1] = (.address[0] + ((.address[1]-1)/%BPUNIT)) AND %X'FFFFFE00';
    address[0] =  .address[0] AND %X'FFFFFE00';
    next_item  = 0;

    DECRA page_number FROM .address[1] TO .address[0] BY %X'200' DO
	BEGIN
	list_item = dbg$get_tempmem(2);
	list_item[dbg$l_link_node_link]  = .next_item;
	list_item[dbg$l_link_node_value] = .page_number;
	next_item = .list_item;
	END;
    .page_list = .next_item;
    RETURN sts$k_success;
    END;		! end of routine dbg$ncob_get_pages

GLOBAL ROUTINE DBG$NCOB_GET_SYMID (desc, symid_list, msg_vect) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Returns a list of symids contained within a language specific primary
!	or value descriptor.
!
! FORMAL PARAMETERS:
!
!	desc		- A longword containing the address of a language specific
!			  primary or value descriptor.
!
!	symid_list	- The address of a longword to contain the address of
!			  the first node in the symid list. Each node in the list
!			  consists of a two longword block. The first longword
!			  is the link field and contains the address of the
!			  next node in the list. This field is 0 for the last
!			  node in the list. The second longword contains the
!			  value of a symid. Each symid that appears in a
!			  descriptor should appear once and only once in the
!			  symid list.
!
!	msg_vect    - The address of a longword to contain the address of
!			  a message argument vector as described on page 4-119
!			  of the VAX/VMS system reference, volume 1A
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	In case of a severe error return, a message argument vector is constructed
!	from dynamic storage and returned.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) - Success. Symid list constructed and returned.
!
!	STS$K_SEVERE  (4) - Failure. No symid list returned. Message argument
!			    vector constructed and returned.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

!DBG$NCOB_GET_SYMID (desc, symid_list, msg_vect)
    BEGIN
    MAP     desc	: REF dbg$ncob_descriptor;
    LOCAL   list_head	: REF dbg$link_node,
	    symid;

    SELECTONE .desc[dbg$b_dhead_type] OF
	SET
	[dbg$k_primary_desc] :
	    symid = .desc[cob_primary_symid];
	[dbg$k_value_desc] :
	    symid = 0;
	[dbg$k_v_value_desc] :
	    symid = .desc[cob_value_picture];
	TES;
    IF (.symid_list = .symid) NEQ 0
    THEN
	BEGIN
	.symid_list = list_head = dbg$get_tempmem(2);
	list_head[dbg$l_link_node_link]  = 0;
	list_head[dbg$l_link_node_value] = .symid;
	END;
    RETURN sts$k_success;
    END;		! end of routine dbg$ncob_get_symid

GLOBAL ROUTINE DBG$NCOB_GET_TYPE (prim_desc, type, msg_vect) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Uses a symbol's primary descriptor to return type information. The
!	types recognized are limited to three:
!
!	1)	- type named constant and instruction (lexical entities, labels)
!
!	2)	- type named constant and noinstruction (symbolic literals)
!
!	3)	- type other
!
!	The debugger uses kernel resources to display instructions. Therefore,
!	it must have enough information to decide when to do this. Also, special
!	handling is given to symbolic literals. This routine provides enough
!	information to allow the DEBUG kernel to handle these special cases.
!
! FORMAL PARAMETERS:
!
!	prim_desc	- A longword containing the address of a primary descriptor
!
!	type		- The address of a longword to contain an unsigned integer
!			  encoding of the symbol's type as follows:
!
!		dbg$k_nc_instruction	(125)	- named constant, instruction
!
!		dbg$k_nc_other		(126)	- named constant, noinstruction
!
!		dbg$k_other		(127)	- other
!
!	msg_vect	- The address of a longword to contain the address of
!			  a message argument vector as described on page 4-119
!			  of the VAX/VMS system reference, volume 1A
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	In case of a severe error return, a message argument vector is constructed
!	from dynamic storage and returned.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) - Success. Type information recovered and returned.
!
!	STS$K_SEVERE  (4) - Failure. No type information recovered. Message
!			    argument vector constructed and returned.
!
!--

!DBG$NCOB_GET_TYPE (prim_desc, type, msg_vect)
    BEGIN
    MAP prim_desc : REF dbg$ncob_descriptor;

    SELECTONE .prim_desc[cob_primary_kind] OF
	SET
	[rst$k_data,rst$k_type] :
	    BEGIN
	    LOCAL   val_ptr : VECTOR[3,LONG],
		    valkind;

	    dbg$sta_setcontext(.prim_desc[cob_primary_symid]);

	    dbg$sta_symvalue(.prim_desc[cob_primary_symid],val_ptr,valkind);

	    IF .valkind EQL dbg$k_literal
	    THEN
		.type = dbg$k_nc_other
	    ELSE
		.type = dbg$k_other;
	    END;


	[OTHERWISE] :
		.type = dbg$k_nc_instruction;
	TES;
    RETURN sts$k_success;
    END;	! end of routine dbg$ncob_get_type

GLOBAL ROUTINE DBG$NCOB_LOG_PREDSUC(input_prim,output_prim,target,msg_vect) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Produces a primary descriptor which specifies the logical successor
!	or predecessor to the symbol described by the input primary descriptor.
!
! FORMAL PARAMETERS:
!
!	input_prim  -	A longword containing the address of a primary descriptor
!
!	output_prim -	The address of a longword to contain the address of a
!			primary descriptor which describes the logical predecessor
!			or successor to the input primary
!
!	target -	A longword containing an integer code which specifies
!			whether a successor or predecessor is required as follows:
!
!		dbg$k_predecessor (221)  - logical predecessor required
!
!		dbg$k_successor   (222)  - logical successor required
!
!	msg_vect -	The address of a longword to contain the address of a
!			message argument vector as described in the VAX/VMS
!			system reference, page 4-119, volume 1A
!
! IMPLICIT OUTPUTS:
!
!	The primary descriptor representing the logical predecessor/successor
!	must be constructed from dynamic storage.
!
!	In case of a severe error return, a message argument vector is constructed
!	and returned.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) -  Success. Primary descriptor constructed for
!			     logical predecessor/successor and returned.
!
!	STS$K_SEVERE  (4) -  Failure. Primary descriptor for logical
!			     predecessor/successor not constructed. Message
!			     argument vector constructed and returned.
!--

!DBG$NCOB_LOG_PREDSUC(input_prim,output_prim,target,msg_vect)
    BEGIN
    !
    ! Describe formal parameters that are structures
    !
    MAP input_prim : REF dbg$ncob_descriptor;
    !
    !
    !
    ! Declare routine-level local variables
    !
    LOCAL
	result_desc  : REF dbg$ncob_descriptor,	! Local pointer to result
	subs,					! Number of subscripts
	ss_vect	     : VECTOR[50,LONG],		! Vector of subscripts
	ss_step,				! Increment for subscripts
	ss_flag,				! Flag for subscript builder
	pass_1,					! Flag for record successors
	symid,					! SYMID of current data item
	cmpid,					! SYMID of record component
	fcode,typeid,				! Results from dbg$sta_symtype
	vax_desc     : REF dbg$stg_desc,	! Pointer to VAX/VMS descriptor
	ncomps,					! Count of record components
	comp_v	     : REF VECTOR[,LONG],	! Vector of component SYMIDs
	path	     : pth$pathname,		! Pathname descriptor for item
	name	     : REF VECTOR[,LONG],	! Pointer to vector of names
	cell_type,dims,ptr,bits;		! Args for dbg$sta_typ_xxx

    BIND ref_path = ptr : REF pth$pathname;	! A more meaningful name

    LABEL search;

    SELECTONE .target OF
	SET
	[dbg$k_predecessor] : ss_step = -1;
	[dbg$k_successor]   : ss_step = +1;
	[OTHERWISE]         : ss_step =  0;
	TES;
    IF (.ss_step EQL 0) OR (.input_prim[cob_primary_kind] NEQ rst$k_data)
    THEN
	RETURN_ERROR(.msg_vect,dbg$_parseerr);

search:	BEGIN
	!+
	! Looking for the logical predecessor/successor of a data item.
	! Extract the SYMID of the data item and copy over the subscripts.
	!-
	symid = .input_prim[cob_primary_symid];
	subs  = .input_prim[cob_subscript_count];
	ch$move(4*.subs,input_prim[cob_subscript_vector],ss_vect);
	dbg$sta_setcontext(.symid);
	pass_1 = ss_flag = true;

	WHILE true DO
	    BEGIN
	    !+
	    ! Examine the type of data item. If it is an array then check
	    ! the subscript for this array against the array bounds. Most
	    ! of the time the logical predecessor/successor will be found
	    ! by stepping the array subscript by +/- 1. If we step beyond
	    ! the end of the array, however, we need to look for the next
	    ! component in the record as we do for non-array elements.
	    !-
	    dbg$sta_symtype(.symid,fcode,typeid);
	    IF .fcode EQL rst$k_type_array
	    THEN
		BEGIN
		LOCAL ss_index,ss_value;
		dbg$sta_typ_array(.typeid,vax_desc,cell_type,dims,ptr,bits);
		DECR d FROM .dims-1 TO 0 DO
		    BEGIN
		    IF .vax_desc[dsc$v_fl_column]
		    THEN
			ss_index = .subs - 1 - .d
		    ELSE
			ss_index = .subs - .dims + .d;
		    ss_value = ss_vect[.ss_index] = .ss_vect[.ss_index] + .ss_step;
		    IF (.ss_value GEQ .vax_desc[4*.dims+8*.d+20,0,32,1]
		    AND .ss_value LEQ .vax_desc[4*.dims+8*.d+24,0,32,1])
		    THEN
			BEGIN
			!+
			! Still inside the array. If the cell-type is 'record',
			! search for first/last component, otherwise all done.
			!-
			dbg$sta_symtype(.cell_type,fcode,typeid);
			IF .pass_1 OR .fcode NEQ rst$k_type_record THEN LEAVE search;
			ss_flag = false;
			EXITLOOP;
			END
		    ELSE
			ss_vect[.ss_index] = .vax_desc[4*.dims+8*.d-2*.ss_step+22,0,32,1];
		    END;
		IF NOT .ss_flag THEN EXITLOOP;
		subs = .subs - .dims;
		END;
	    pass_1 = false;

	    !+
	    ! Here we need to look for the next data item in the containing
	    ! record, so obtain a SYMID for the "ancestor" record. (If this
	    ! is zero, we do not have a predecessor/successor).
	    !-
	    cmpid = .symid;
	    IF (symid = dbg$sta_symparent(.cmpid)) EQL 0
	    THEN RETURN_ERROR(.msg_vect,(SELECTONE .target OF
					    SET
					    [dbg$k_predecessor] : dbg$_nopred;
					    [dbg$k_successor]   : dbg$_nosucc;
					    TES));
	    !+
	    ! Get the FCODE and TYPEID of this data item. The only types we
	    ! expect to find are 'record' and 'array of records'. Check for
	    ! an array, and if this is what we have obtain the cell-type.
	    !-
	    dbg$sta_symtype(.symid,fcode,typeid);
	    IF .fcode EQL rst$k_type_array
	    THEN
		BEGIN
		dbg$sta_typ_array(.typeid,vax_desc,cell_type,dims,ptr,bits);
		dbg$sta_symtype(.cell_type,fcode,typeid);
		END;

	    symid = dbg$sta_record_component(.symid,
		    dbg$sta_record_index(.symid,.cmpid)+.ss_step);

	    IF .symid NEQ 0 THEN EXITLOOP;
	    !+
	    !  SYMID is zero if we stepped beyond the end of the record,
	    ! so look for the component adjacent to the 'parent' record.
	    !-
	    symid = dbg$sta_symparent(.cmpid);
	    END;

	WHILE true DO
	    BEGIN
	    dbg$sta_symtype(.symid,fcode,typeid);
	    !+
	    ! We now have to check the SYMID to see the component is itself a
	    ! record (or an array of records).  If it is, we need to find the
	    ! component of the record.  For an array we also need to set up a
	    ! subscript value equal to the lower/upper bound for the array.
	    !-
	    IF .fcode EQL rst$k_type_array
	    THEN
		BEGIN
		dbg$sta_typ_array(.typeid,vax_desc,cell_type,dims,ptr,bits);
		IF .vax_desc[dsc$v_fl_bounds] EQL 0 THEN RETURN_ERROR(.msg_vect,dbg$_invarrdsc);
		dbg$sta_symtype(.cell_type,fcode,typeid);
		IF .ss_flag
		THEN
		    BEGIN
		    DECR d FROM .dims-1 TO 0 DO
		      ss_vect[.subs+.d] = .vax_desc[4*.dims+8*.d-2*.ss_step+22,0,32,1];
		    subs = .subs+.dims;
		    END;
		END;
	    IF .fcode NEQ rst$k_type_record THEN EXITLOOP;
	    !+
	    ! "Data item" is a record. Get the SYMID for first/last component.
	    !-
	    dbg$sta_typ_record(.typeid,ncomps,comp_v,bits);
	    SELECTONE .target OF SET
		[dbg$k_predecessor] :	cmpid = .ncomps;
		[dbg$k_successor] :	cmpid = 1;
		TES;
	    symid = dbg$sta_record_component(.symid,.cmpid);
	    ss_flag = true;
	    END;
	END;	! search

    !+
    ! We have now got all the way down to a data item which is not itself
    ! a record. Build a primary descriptor for this data item and return.
    !-
    result_desc  = dbg$ncob_make_desc(dbg$k_primary_desc,.subs+2);
    result_desc[cob_primary_symid]   = .symid;
    result_desc[cob_primary_kind]    = rst$k_data;
    result_desc[cob_subscript_count] = .subs;
    ch$move(4*.subs,ss_vect[0],result_desc[cob_subscript_vector]);
    .output_prim = .result_desc;
    RETURN sts$k_success;
    END;	! end of routine dbg$ncob_log_predsuc

GLOBAL ROUTINE DBG$NCOB_MAKE_DESC(type) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine constructs a skeleton COBOL primary or value descriptor.
!	It fills in the header fields for language (COBOL), type, and length.
!
! FORMAL PARAMETERS:
!
!	type		The type of descriptor to be constructed
!
!	size		An optional parameter which, if present, is the number
!			of longwords (in addition to the fixed-length portion)
!			which should be allocated in this descriptor.
!
! ROUTINE VALUE:
!
!	The address of the constructed descriptor.
!
!
! SIDE EFFECTS:
!
!	Temporary dynamic memory is allocated to hold the descriptor.
!--
    BEGIN
    BUILTIN actualcount,actualparameter;
    LOCAL size,header : REF dbg$dhead;

    size = cob_fixed+(IF actualcount() GTR 1 THEN actualparameter(2) ELSE 0);

    header = dbg$get_tempmem(.size);
    size = .size * %UPVAL;
    ch$fill(0,.size,.header);
    header[dbg$w_dhead_length] = .size;
    header[dbg$b_dhead_type]   = .type;
    header[dbg$b_dhead_lang]   = dbg$k_cobol;

    RETURN .header;
    END;		! end of routine dbg$ncob_make_desc

GLOBAL ROUTINE DBG$NCOB_MAKE_PACKED_DESC(vax_desc,value_desc,msg_vect) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Converts all numeric values to 'internal format', which is packed
!	decimal (data type dsc$k_dtype_p).
!
! FORMAL PARAMETERS:
!
!	vax_desc	- A longword containing the address of a VAX descriptor
!
!	value_desc	- The address of a longword to contain the address of the
!			  resulting value descriptor
!
!	msg_vect	- The address of a longword to contain the address of a
!			  message argument vector as described on page 4-119 of
!			  the VAX/VMS system reference, volume 1A
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	In case of a success return, the resulting value descriptor must be
!	constructed from dynamic storage and returned.
!
!	In case of a severe error return, a message argument vector must be
!	constructed from dynamic storage and returned.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) - Success. Value descriptor constructed and returned.
!
!	STS$K_SEVERE  (4) - Failure. Value descriptor not constructed. Message
!			    argument vector constructed and returned.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

!DBG$NCOB_MAKE_PACKED_DESC(vax_desc,value_desc,msg_vect) =
    BEGIN
    !
    ! Describe formal parameters that are structures
    !
    MAP     vax_desc	: REF dbg$stg_desc;

    LOCAL
	value_length,value_pointer,
	local_vax_desc	: REF dbg$stg_desc,
	local_val_desc	: REF dbg$ncob_descriptor;



    !+
    ! First call the type-converter routine to check the value.
    !-
    IF NOT dbg$ncob_convert_to_packed(.vax_desc,local_vax_desc,.msg_vect)
	THEN RETURN sts$k_severe;

    !+
    !  Get the length (in bytes) of the resulting packed decimal string,
    ! and set up a pointer to the digit-string. Then allocate sufficient
    ! storage for a COBOL value descriptor.
    !-
    value_length   = .local_vax_desc[dsc$w_length]/2 + 1;
    value_pointer  = .local_vax_desc[dsc$a_pointer];
    local_val_desc = dbg$ncob_make_desc(dbg$k_value_desc,(.value_length+11)/4);
    !+
    ! Copy over the VAX/VMS descriptor fields and the digit-string, and set
    ! up the dsc$a_pointer field of the VAX/VMS descriptor contained in the
    ! value descriptor. Then return a pointer to the value descriptor.
    !-
    ch$move(10,.local_vax_desc,local_val_desc[cob_value_dschead]);
    ch$move(.value_length,.value_pointer,local_val_desc[cob_value_address]);
    local_val_desc[cob_value_pointer] =  local_val_desc[cob_value_address];
    .value_desc = .local_val_desc;
    RETURN sts$k_success;
    END;	! end of routine dbg$ncob_make_packed_desc

GLOBAL ROUTINE DBG$NCOB_MAKE_VAL_DESC(prim_desc,target_flag,value_desc,msg_vect) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Translates language specific primary descriptors to language specific
!	value descriptors. This routine should be able to use the symbol table
!	access routines and the information contained within the primary descriptor
!	to construct a descriptor which represents a 'value materialization' for
!	the object represented by the input primary descriptor.
!
!	Note that this routine must be able to use life-time, invocation, and
!	generation information to produce an accurate value descriptor of the
!	input object, or to decide when the value of an object cannot be
!	materialized (such as when the user's PC is not within the scope of
!	a dynamic variable).
!
!	Value descriptors produced by this routine must be marked (within the
!	type field of the language independent header block) as to whether
!	they are non-volatile (dbg$k_value_desc) or volatile (dbg$k_v_value_desc).
!	Volatile value descriptors will NOT be stored to represent '\', 'last value'.
!
!	Since value descriptors may be used as target descriptors ( as input to
!	dbg$ncob_type_conv ), some provision must be made for incorporating
!	a value pointer field within the value descriptor. This type of value
!	descriptor is loosely defined as a volatile type.
!
! FORMAL PARAMETERS:
!
!	prim_desc	- A longword containing the address of a primary descriptor
!
!	target_flag	- A longword containing boolean true or false. When true,
!			  the caller is requesting the construction of a value
!			  descriptor that can be used as a target descriptor for
!			  the type converter. The resulting value must therefore
!			  contain a pointer to the value of the entity described
!			  by the input primary descriptor. Presumably, such a
!			  value descriptor will be of volatile type.
!
!	value_desc	- The address of a longword to contain the address of the
!			  resulting value descriptor
!
!	msg_vect	- The address of a longword to contain the address of a
!			  message argument vector as described on page 4-119 of
!			  the VAX/VMS system reference, volume 1A
!

! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	In case of a success return, the resulting value descriptor must be
!	constructed from dynamic storage and returned.
!
!	In case of a severe error return, a message argument vector must be
!	constructed from dynamic storage and returned.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) - Success. Value descriptor constructed and returned.
!
!	STS$K_SEVERE  (4) - Failure. Value descriptor not constructed. Message
!			    argument vector constructed and returned.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

!DBG$NCOB_MAKE_VAL_DESC(prim_desc,target_flag,value_desc,msg_vect)
    BEGIN
    !
    ! Describe formal parameters that are structures
    !
    MAP     prim_desc	: REF dbg$ncob_descriptor;
    !
    !
    ! Declare routine-level local variables
    !
    LOCAL   length,
	    picture,
	    vax_desc	: BLOCK [12,BYTE],  ! VAX/VMS descriptor for value,
	    result_desc : REF dbg$ncob_descriptor;
    !+
    ! First construct a VAX/VMS descriptor that for the desired value
    !-
    IF NOT dbg$ncob_make_vax_desc(.prim_desc,vax_desc,length,picture,.msg_vect)
      THEN RETURN sts$k_severe;
    !+
    ! Now build the actual value descriptor. If this is NOT a "volatile" value
    ! descriptor and the data-item is not more than 256 bytes long include the
    ! actual value in the descriptor (N.B. dbg$ncob_type_conv assumes that any
    ! byte or word value will be in the descriptor, ZERO EXTENDED to 32 bits).
    !-
    IF .target_flag
    THEN
	BEGIN
	result_desc = dbg$ncob_make_desc(dbg$k_v_value_desc,2);
	result_desc[cob_value_picture] = .picture;
	END
    ELSE
	BEGIN
	IF .length GTR 256
	THEN
	    result_desc = dbg$ncob_make_desc(dbg$k_v_value_desc,2)
	ELSE
	    BEGIN
	    result_desc = dbg$ncob_make_desc(dbg$k_value_desc,(.length+11)/4);
	    ch$move(.length,.vax_desc[dsc$a_pointer],result_desc[cob_value_address]);
	    END;
	END;
    ch$move(10,vax_desc,result_desc[cob_value_dschead]);
    IF .result_desc[dbg$b_dhead_type] EQL dbg$k_value_desc
    THEN
	result_desc[cob_value_pointer] = result_desc[cob_value_address];
    .value_desc = .result_desc;
    RETURN sts$k_success;
    END;		! end of routine dbg$ncob_make_val_desc

GLOBAL ROUTINE DBG$NCOB_MAKE_VAX_DESC(prim_desc,vax_desc,length,picture,msg_vect) =
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine constructs a VAX/VMS descriptor that points to the
!	value of a symbol (described by a primary symbol descriptor).
!	It first materializes the address by resolving all array and/or
!	record component references, and then determines the length and
!	data type.  Finally, in the case of alphanumeric data items, it
!	checks for sub-string references, and if one is present updates
!	the length and address fields accordingly.
!
! FORMAL PARAMETERS:
!
!	prim_desc	- A longword containing the address of a primary descriptor
!
!	vax_desc	- A longword containing the address of a block of at least
!			  10 bytes where a VAX/VMS descriptor will be constructed.
!
!	length		- The address of a longword to receive the length (in bytes)
!			  of the value.
!
!	picture		- The address of a longword which, if the symbol describes
!			  a COBOL picture data item, will be set to the TYPEID of
!			  the COBOL picture.
!
!	msg_vect	- The address of a longword to contain the address of a
!			  message argument vector as described on page 4-119 of
!			  the VAX/VMS system reference, volume 1A
!

!dbg$ncob_make_vax_desc(prim_desc,vax_desc,length,picture,msg_vect)
    BEGIN

    MAP
	prim_desc	: REF dbg$ncob_descriptor,
	vax_desc	: REF BLOCK [,BYTE];

    LOCAL fcode,typeid,				! Values returned from SYMTYPE
	  vms_dscaddr	   : REF dbg$stg_desc,	! Pointer to VAX/VMS descriptor
	  symid,				! SYMID being checked
	  address,				! Offset/Address of data item
	  adr_ptrs	   : VECTOR[3,LONG],	! Address and 'kind' information
	  adr_kind,				!  returned by dbg$sta_symvalue
	  val_kind,				! 'Kind' from dbg$sta_symkind
	  subscript,				! Current subscript value
	  subscript_index,			! Pointer into subscript vector
	  subscript_vector : REF VECTOR[,LONG],	! Vector of subscript values
	  desc : REF dbg$stg_desc;		! Pointer to VAX/VMS descriptor

    BIND offset = adr_ptrs[0];			! A more meaningful name

    !+
    ! Initialize pointers to subscript vector, and get lowest-level SYMID.
    !-
    address = 0;
    symid   = .prim_desc[cob_primary_symid];
    subscript_index  = .prim_desc[cob_subscript_count];
    subscript_vector =  prim_desc[cob_subscript_vector];
    dbg$sta_setcontext(.symid);
    !+
    ! Repeat the following loop for the lowest level SYMID and for all
    ! "ancestor" SYMIDS to relocate offsets to an actual address.
    !-
    WHILE .symid NEQ 0 DO
	BEGIN
	dbg$sta_symvalue(.symid,adr_ptrs,adr_kind);
	IF .adr_ptrs[1] NEQ 0 THEN RETURN_ERROR(.msg_vect,dbg$_illtype);
	dbg$sta_symkind(.symid,val_kind);
	IF .val_kind NEQ rst$k_data THEN RETURN_ERROR(.msg_vect,dbg$_illtype);
	!+
	! Find out type of DST record we have for the data item, and calculate
	! the address using information returned by the RST access routines.
	!-
	dbg$sta_symtype(.symid,fcode,typeid);
	CASE .fcode FROM rst$k_type_minimum TO rst$k_type_maximum
	 OF SET
	    [rst$k_type_atomic,rst$k_type_pict,rst$k_type_record] :
		!+
		! Address given directly for simple data types. Just check for
		! SYMTYPE being confused by stack-machine-built descriptors.
		!-
		IF .adr_kind EQL dbg$k_val_descr THEN address=.address+.(.offset+4);
	    [rst$k_type_descr] :
		!+
		!  Data item referenced by a descriptor. Compute sum of record
		! offset (from dbg$sta_symvalue) and contents of dsc$a_pointer
		! field in descriptor. We must check class field of descriptor
		! to make sure that this is a kind of data item we can handle.
		!-
		BEGIN
		dbg$sta_typ_descr(.typeid,desc);
		IF (.desc[dsc$b_class] EQL dsc$k_class_s
				    OR
		    .desc[dsc$b_class] EQL dsc$k_class_d
				    OR
		    .desc[dsc$b_class] EQL dsc$k_class_sd)
		THEN
		    address = .address + .desc[dsc$a_pointer]
		ELSE
		    RETURN_ERROR(.msg_vect,dbg$_unimplent);
		END;

	    [rst$k_type_array] :
		BEGIN
		LOCAL cell_type,dims,ptr,bits,stride,size;
		!+
		! Data item is an array. We need to calculate the address of a
		! single component of this array and range-check subscripts.
		!-
		dbg$sta_typ_array(.typeid,desc,cell_type,dims,ptr,bits);
		IF .desc[dsc$v_fl_bounds] EQL 0 THEN RETURN_ERROR(.msg_vect,dbg$_invarrdsc);
		subscript_index = .subscript_index - .dims;
		IF .desc[dsc$b_class] EQL dsc$k_class_a
		THEN
		    BEGIN
		    dbg$sta_symsize(.cell_type,size);
		    size = .size/%BPUNIT;
		    IF .desc[dsc$v_fl_column] THEN DECR d FROM .dims-1 TO 0 DO
		      size = .size*.desc[4*.d+20,0,32,1];
		    END;
		DECR d FROM .dims-1 TO 0 DO
		    BEGIN
		    subscript = .subscript_vector[.subscript_index + .d];
		    IF (.subscript LSS .desc[4*.dims+8*.d+20,0,32,1])
		    OR (.subscript GTR .desc[4*.dims+8*.d+24,0,32,1])
		    THEN
			BEGIN
			LOCAL name_string;
			dbg$sta_symname(.symid,name_string);
			RETURN_ERROR(.msg_vect,dbg$_badsubscript,.subscript,.name_string);
			END;
		    stride = .desc[4*.d+20,0,32,1];
		    SELECTONE .desc[dsc$b_class]
		     OF SET
			[dsc$k_class_a]:
			    IF .desc[dsc$v_fl_column]
			    THEN
				BEGIN
				size = .size/.stride;
				address = .address + .subscript*.size;
				END
			    ELSE
				BEGIN
				address = .address + .subscript*.size;
				size = .size*.stride;
				END;
			[dsc$k_class_nca] :
			    address = .address + .subscript*.stride;
			TES;
		    END;
		address = .address + .desc[dsc$a_a0];
		END;

	    [INRANGE,OUTRANGE] :
		!+
		! We get here if dbg$sta_symtype returns an FCODE other
		! than the values handled above.
		!-
		RETURN_ERROR(.msg_vect,dbg$_unimplent);
	    TES;
	!+
	! All addresses need to be relocated by the offset returned
	! by dbg$sta_symvalue (in case of record components)
	!-
	IF .adr_kind EQL dbg$k_val_addr THEN address=.address+.offset;

	!+
	! Step to "ancestor" of this data item. If this data item has no
	! ancestor (i.e. it is a top-level data item) the returned SYMID
	! will be zero, which will cause exit from the loop.
	!-
	symid = dbg$sta_symparent(.symid);
	END;

    vax_desc[dsc$a_pointer] = .address;
    vax_desc[dsc$b_digits]  = vax_desc[dsc$b_scale] = 0;
    vax_desc[dsc$b_class]   = dsc$k_class_sd;
    .picture = 0;
    vms_dscaddr = 0;

    !+
    ! Now find out what sort of variable this is, and obtain the data-type
    ! and length information.
    !-
    dbg$sta_symtype(.prim_desc[cob_primary_symid],fcode,typeid);

    IF .fcode EQL rst$k_type_array
    THEN
	BEGIN
	LOCAL cell_type,dims,ptr,bits;
	!+
	! Array - get information about individual array elements
	!-
	dbg$sta_typ_array(.typeid,vms_dscaddr,cell_type,dims,ptr,bits);
	dbg$sta_symtype(.cell_type,fcode,typeid);
	END
    ELSE
	vms_dscaddr = 0;		! Hack for COBOL V1




    CASE .fcode FROM rst$k_type_minimum TO rst$k_type_maximum OF
	SET
	[rst$k_type_atomic] :
	    BEGIN
	    LOCAL typecode,bitsize;

	    IF .vms_dscaddr NEQ 0	! Hack for COBOL V1
	    THEN
		BEGIN
		typecode = .vms_dscaddr[dsc$b_dtype];
		IF .typecode EQL dsc$k_dtype_p
		THEN
		    bitsize =(.vms_dscaddr[dsc$w_length]/2+1)*%BPUNIT
		ELSE
		    bitsize = .vms_dscaddr[dsc$w_length]*%BPUNIT;
		END
	    ELSE
		dbg$sta_typ_atomic(.typeid,typecode,bitsize);

	    .length = vax_desc[dsc$w_length] = .bitsize/%BPUNIT;
	    vax_desc[dsc$b_dtype] = .typecode;
	    END;

	[rst$k_type_descr] :
	    BEGIN
	    LOCAL   valid_dtypes;
	    BIND dtype_vector = valid_dtypes : BITVECTOR[32];
	    !+
	    ! DST contains a descriptor. Check that it is a class of
	    ! descriptor we are prepared to support, and that the data
	    ! type is consistent with this descriptor class.
	    !-
	    dbg$sta_typ_descr(.typeid,vms_dscaddr);
	    vax_desc[0,0,32,0] = .vms_dscaddr[0,0,32,0];

	    CASE .vax_desc[dsc$b_class] FROM dsc$k_class_s TO dsc$k_class_sd OF
		SET

		[dsc$k_class_s] :
		    valid_dtypes = class_s_dtypes;

		[dsc$k_class_d] :
		    valid_dtypes = class_d_dtypes;

		[dsc$k_class_sd] :
		    BEGIN
		    valid_dtypes = class_sd_dtypes;
		    vax_desc[8,0,16,0] = .vms_dscaddr[8,0,16,0];
		    END;
		[INRANGE,OUTRANGE] :
		    RETURN_ERROR(.msg_vect,dbg$_unimplent);
		TES;

	    CASE .vax_desc[dsc$b_dtype] FROM dsc$k_dtype_bu TO dsc$k_dtype_p OF
		SET
		[dsc$k_dtype_bu,dsc$k_dtype_wu, dsc$k_dtype_lu,dsc$k_dtype_qu,
		 dsc$k_dtype_b, dsc$k_dtype_w,  dsc$k_dtype_l, dsc$k_dtype_q,
		 dsc$k_dtype_f, dsc$k_dtype_d,  dsc$k_dtype_nz,dsc$k_dtype_nu,
		 dsc$k_dtype_nl,dsc$k_dtype_nlo,dsc$k_dtype_nr,dsc$k_dtype_nro,
		 dsc$k_dtype_t] :
		    .length = .vax_desc[dsc$w_length];
		[dsc$k_dtype_p] :
		    .length = .vax_desc[dsc$w_length]/2 + 1;
		[INRANGE,OUTRANGE] :
		    RETURN_ERROR(.msg_vect,dbg$_unimplent);
		TES;

	    IF NOT .dtype_vector[.vax_desc[dsc$b_dtype]]
	      THEN RETURN_ERROR(.msg_vect,dbg$_unimplent);

	    END;

	[rst$k_type_pict] :
	    BEGIN
	    LOCAL lang,pictptr,pictval;
	    !+
	    ! "Pictured" data item. This is really an item of data-type
	    ! dsc$k_dtype_t, but we need to retain extra information in
	    ! case we want to deposit a numeric value into this item.
	    ! We must, however, check that this is a COBOL picture.
	    !-
	    dbg$sta_typ_pict(.typeid,lang,pictptr,pictval);
	    IF .lang NEQ dbg$k_cobol THEN RETURN_ERROR(.msg_vect,dbg$_unimplent);
	    dbg$sta_symsize(.typeid,pictval);
	    .picture = .typeid;
	    vax_desc[dsc$b_dtype]  = dsc$k_dtype_t;
	    .length = vax_desc[dsc$w_length] = .pictval/%BPUNIT;
	    END;

	[rst$k_type_record] :
	    BEGIN
	    LOCAL ncomps,comp_v,bits;
	    !+
	    ! Examine of a record. Just get the record length, and set the
	    ! data-type to dsc$k_dtype_t (ASCII text).
	    !-
	    dbg$sta_typ_record(.typeid,ncomps,comp_v,bits);
	    vax_desc[dsc$b_dtype]  = dsc$k_dtype_t;
	    .length = vax_desc[dsc$w_length] = (.bits+%BPUNIT-1)/%BPUNIT;
	    END;

	[INRANGE,OUTRANGE] :
	    RETURN_ERROR(.msg_vect,dbg$_unimplent);
	TES;

    !+
    ! If this is a data item of type dsc$k_dtype_t, check for (and validate) a
    ! substring reference, and if one is present adjust the address and length.
    !-
    IF .vax_desc[dsc$b_dtype] EQL dsc$k_dtype_t
    THEN
	BEGIN
	LOCAL v : REF VECTOR[2,LONG];
	v = prim_desc[cob_subscript_vector]+4*.prim_desc[cob_subscript_count];
	IF .v[0] NEQ 0
	THEN
	    BEGIN
	    IF (.v[0] + (IF .v[1] EQL 0 THEN 0 ELSE .v[1] - 1)) GTRU ..length
	      THEN RETURN_ERROR(.msg_vect,dbg$_substring,.v[0],.v[1],..length);
	    vax_desc[dsc$a_pointer] = .vax_desc[dsc$a_pointer] + .v[0] - 1;
	    .length  = vax_desc[dsc$w_length] =
		(IF .v[1] NEQ 0 THEN .v[1] ELSE ..length - .v[0] + 1);
	    END;
	END;
    RETURN sts$k_success;
    END;		! end of routine dbg$ncob_make_vax_desc

GLOBAL ROUTINE DBG$NCOB_PATHDESC_TO_CS(pathname,name_string) : NOVALUE =
    BEGIN
    MAP pathname	: REF pth$pathname;

    LOCAL
	name_vector	: REF VECTOR[,LONG],
	name_count,
	top_name	: REF VECTOR[,BYTE],
	sub_name	: REF VECTOR[,BYTE],
	pointer,length;

    name_vector = pathname[pth$a_pathvector];
    name_vector = name_vector[.pathname[pth$b_pathcnt]];
    name_count  = .pathname[pth$b_totcnt] - .pathname[pth$b_pathcnt];
    pathname[pth$b_totcnt]   = .pathname[pth$b_pathcnt];
    dbg$npathdesc_to_cs(.pathname,top_name);
    length = .(.top_name)<0,8,0>;
    DECR index FROM .name_count-1 TO 0 DO
	BEGIN
	sub_name = .name_vector[.index];
	IF .(.sub_name)<0,8,0> GTR 0 THEN length=.length+.(.sub_name)<0,8,0>+4;
	END;
    .name_string = pointer = dbg$get_tempmem((.length/%UPVAL)+1);
    ch$wchar_a(.length,pointer);
    DECR index FROM .name_count-1 TO 0 DO
	BEGIN
	sub_name = .name_vector[.index];
	IF .(.sub_name)<0,8,0> GTR 0
	THEN
	    BEGIN
	    ch$move(.(.sub_name)<0,8,0>,sub_name[1],.pointer);
	    pointer = .pointer + .(.sub_name)<0,8,0>;
	    ch$move(4,UPLIT BYTE(' of '),.pointer);
	    pointer = .pointer + 4;
	    END;
	END;
    ch$move(.(.top_name)<0,8,0>,top_name[1],.pointer);
    END;		! end of routine dbg$ncob_pathdesc_to_cs

GLOBAL ROUTINE DBG$NCOB_PRIM_OUT (prim_desc, string_desc, msg_vect) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Uses a symbol's primary descriptor to construct an ascii string descriptor
!	which reflects both the symbolic information associated with the symbol,
!	and the rvalue associated with a symbol. This is of the form:
!
!	MODULE\ROUTINE INVOCATION_NUMBER\[LEXICAL_ENTITY] ...\SYMBOL_NAME: VALUE
!
!	Note that the capability to output aggregate values, such as an entire
!	array, will be required in a future release of DEBUG.
!
! FORMAL PARAMETERS:
!
!	prim_desc	- A longword containing the address of a primary descriptor
!
!	string_desc	- A longword containing the address of a VAX standard
!			  string descriptor with length and pointer fields set
!			  to 0
!
!	msg_vect	- The address of a longword to contain the address of a
!			  message argument vector as described on page 4-119
!			  of the VAX/VMS system reference, volume 1A
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	Dynamic storage must be allocated to contain the ascii string described
!	by string_desc on a successful return.
!
!	In case of a severe error return, a message argument vector must be
!	constructed from dynamic storage and returned.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) - Success. Information recovered and returned as an
!			    ascii string.
!
!	STS$K_SEVERE  (4) - Failure. Ascii string not constructed. Message
!			    argument vector constructed and returned.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

!DBG$NCOB_PRIM_OUT (prim_desc, string_desc, msg_vect)
    BEGIN
    MAP prim_desc	: REF dbg$ncob_descriptor,
	string_desc	: REF dbg$stg_desc;

    LOCAL length,pointer,
	name_string	: dbg$stg_desc,
	value_desc	: REF dbg$ncob_descriptor,
	value_string	: dbg$stg_desc;

    value_string[dsc$b_class]   = dsc$k_class_d;
    value_string[dsc$b_dtype]    = dsc$k_dtype_t;
    value_string[dsc$w_length]  = 0;
    value_string[dsc$a_pointer] = 0;

    IF .prim_desc[cob_primary_kind] NEQ rst$k_data
      THEN RETURN_ERROR(.msg_vect,dbg$_noexam);

    IF NOT dbg$ncob_make_val_desc(.prim_desc,false,value_desc,.msg_vect)
      THEN RETURN sts$k_severe;

    IF NOT dbg$ncob_symbolize(.prim_desc,name_string,.msg_vect)
      THEN RETURN sts$k_severe;

    IF NOT dbg$ncob_type_conv(.value_desc,dbg$k_default,dbg$k_external_desc,value_string,.msg_vect)
      THEN RETURN sts$k_severe;

    string_desc[dsc$w_length]  = length = .name_string[dsc$w_length] + 2
					  + .value_string[dsc$w_length];
    string_desc[dsc$a_pointer] = pointer = dbg$get_tempmem((.length+%UPVAL-1)/%UPVAL);
    ch$move(.name_string[dsc$w_length],.name_string[dsc$a_pointer],.pointer);
    pointer = .pointer + .name_string[dsc$w_length];
    ch$move(2,UPLIT BYTE(':	'),.pointer);
    ch$move(.value_string[dsc$w_length],.value_string[dsc$a_pointer],.pointer+2);
    return sts$k_success
    END;		! end of routine dbg$ncob_prim_out

GLOBAL ROUTINE DBG$NCOB_RANGE_VAL(prim_desc_1,prim_desc_2,prim_list,msg_vect) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Verifies that there is a sequence of data items D1,...,Dn each of
!	which is the logical successor of its predecessor such that
!	prim_desc_1 identifies D1 and prim_desc_2 identifies Dn. In addition,
!	this routine returns a linked list of primary descriptors representing
!	D1 through Dn.
!
!	This routine is used to support the DEBUG ranged EXAMINE command such as
!
!			EXAMINE A:B
!
! FORMAL PARAMETERS:
!
!	prim_desc_1	- A longword which contains the address of the primary
!			  descriptor which describes D1, the first element of the range
!
!	prim_desc_2	- A longword which contains the address of the primary
!			  descriptor which describes Dn, the last element of the range
!
!	prim_list	- The address of a longword to contain the address of the
!			  of the first node in the primary descriptor list. Nodes
!			  of the list consist of a block of two longwords. The
!			  second longword of the node block contains the address of
!			  a primary descriptor corresponding to a Di data item.
!			  The first longword of the node block contains the address
!			  of the next node in the list. This link field should
!			  contain a 0 for the last node in the list.
!
!	msg_vect	- The address of a longword to contain the address of a
!			  message argument vector as described on page 4-119 of
!			  the VAX/VMS system reference, volume 1A.
!
!
!
! IMPLICIT INPUTS:
!
!	The linked list of primary descriptors is constructed from dynamic storage
!	and returned on a success routine return.
!
!	The message argument vector is constructed and returned on a severe error
!	routine return.
!
! IMPLICIT OUTPUTS:
!
!	NONE

!
! ROUTINE VALUE:
!
!	A longword unsigned integer completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) - Success. Range specification verified and list of
!			    primary descriptors constructed and returned.
!
!	STS$K_SEVERE  (4) - Failure. Error in range specification. No list re-
!			    turned. Error message argument vector constructed
!			    and returned.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN
    RETURN_ERROR(.msg_vect,dbg$_notdone,UPLIT BYTE(16,'Range <V1>:<V2> '));
    END;	! end or routine dbg$ncob_range_val

GLOBAL ROUTINE DBG$NCOB_SYMBOLIZE (prim_desc, string_desc, msg_vect) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Produces a character string representation of the symbolic information
!	concerning a symbolic reference using a language specific primary
!	descriptor. This symbolic information includes pathname, invocation
!	number, and entity name. For example:
!
!		FOO\BAR 3\[LEXICAL_ENTITY]...\A
!
!	where FOO is the module name, BAR is the routine name, 3 is the routine
!	invocation number, and A is the variable name.
!
!	Note that this routine must obtain an invocation number for routines
!	using information stored in the primary descriptor.
!
!
! FORMAL PARAMETERS:
!
!	prim_desc	- A longword containing the address of a language
!			  specific primary descriptor
!
!	string_desc	- A longword containing the address of a VAX standard
!			  string descriptor with dsc$a_pointer and dsc$w_length
!			  fields of 0
!
!	msg_vect	- The address of a longword to contain the address of a
!			  message argument vector as described on page 4-119 of
!			  the VAX/VMS system reference, volume 1A

!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	On a successful return, the dsc$a_pointer and dsc$w_length fields of
!	string_desc are updated to reflect the ascii string representing the
!	symbolic information gleaned from the primary descriptor. Dynamic
!	storage must be allocated to contain the ascii string.
!
!	On a severe error return, a message argument vector is constructed from
!	dynamic storage and its address returned in msg_vect.
!
! ROUTINE VALUE:
!
!	An unsigned longword integer condition code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) - Success. Ascii string descriptor updated to reflect
!			     recovered symbolic information.
!
!	STS$K_SEVERE  (4) - Failure. No symbolic information recovered. Message
!			     argument vector constructed and returned.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

!DBG$NCOB_SYMBOLIZE (prim_desc, string_desc, msg_vect)
    BEGIN
    MAP
	prim_desc	: REF dbg$ncob_descriptor,
	string_desc	: REF dbg$stg_desc;
    LOCAL
	pointer,
	length,
	item_count,
	item_vector	: REF VECTOR[,LONG],
	compname	: REF VECTOR[,BYTE],
	pathname_string	: REF VECTOR[,BYTE],
	pathname	: REF pth$pathname;

    item_count = .prim_desc[cob_subscript_count];
    item_vector = prim_desc[cob_subscript_vector];
    IF .item_vector[.item_count] NEQ 0
    THEN
	length = (IF .item_vector[.item_count+1] EQL 0 THEN 1 ELSE 2) +
			 2*(item_count = .item_count+2)
    ELSE
	length = (IF .item_count EQL 0 THEN 0 ELSE 2*.item_count+1);
    DECR index FROM .item_count-1 TO 0 DO
	BEGIN
	LOCAL subscript_value;
	subscript_value = .item_vector[.index];
	WHILE .subscript_value GTR 9 DO
	    BEGIN
	    length = .length + 1;
	    subscript_value = .subscript_value/10;
	    END;
	END;
    dbg$sta_sympathname(.prim_desc[cob_primary_symid],pathname);
    dbg$ncob_pathdesc_to_cs(.pathname,pathname_string);
    length = .length + .(.pathname_string)<0,8,0>;
    pointer = dbg$get_tempmem((.length+%UPVAL-1)/%UPVAL);
    string_desc[dsc$w_length]  = .length;
    string_desc[dsc$a_pointer] = .pointer;
    ch$move(.(.pathname_string)<0,8,0>,pathname_string[1],.pointer);
    pointer = .pointer + .(.pathname_string)<0,8,0>;

    item_vector = prim_desc[cob_subscript_vector];
    item_count = .prim_desc[cob_subscript_count];
    IF .item_count GTR 0
    THEN
	BEGIN
	INCR index FROM 0 TO .item_count-1 DO
	    BEGIN
	    ch$wchar_a((IF .index EQL 0 THEN '(' ELSE ','),pointer);
	    dbg$ncob_symbolize_num(.item_vector[.index],pointer);
	    END;
	ch$wchar_a(')',pointer);
	END;
    IF .item_vector[.item_count] NEQ 0
    THEN
	BEGIN
	ch$wchar_a('(',pointer);
	dbg$ncob_symbolize_num(.item_vector[.item_count],pointer);
	ch$wchar_a(':',pointer);
	IF .item_vector[.item_count+1] NEQ 0
	THEN
	    dbg$ncob_symbolize_num(.item_vector[.item_count+1],pointer);
	ch$wchar_a(')',pointer);
	END;
    RETURN sts$k_success;
    END;		! end of routine dbg$ncob_symbolize

ROUTINE dbg$ncob_symbolize_num(number,pointer) : NOVALUE =
    BEGIN
    LOCAL digit,prefix;
    digit = .number - 10*(prefix = .number/10) + '0';
    IF .prefix GTR 0 THEN dbg$ncob_symbolize_num(.prefix,.pointer);
    ch$wchar_a(.digit,.pointer);
    RETURN;
    END;	! end of routine dbg$ncob_symbolize_num

END
ELUDOM
