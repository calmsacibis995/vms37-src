;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
	.title	pliwork
	$dscdef
	$stsdef
	$dbgdef
	$dbglib
	$plidef
	$dstrecrds
	$chfdef
	.psect	dbg$code,exe,nowrt,long,pic,shr
	.ident	'V03-000'
	.page
	.subtitle	pli_get_subscript_count
;
;********************************************************
;*	pli_get_subscript_count				*
;********************************************************
;
;This routine is passed a node pointer to an oprscr or oprcon node.
;This references a subtree which represents a subscript list. The
;routine modifies a count longword to reflect the number of such subscripts.
;
	.entry	pli_get_subscript_count,^m<r2,r3>
ap_count_ptr	=	4		;pointer to count longword
ap_node_ptr	=	8		;pointer to oprscr or oprcon node
	movl	ap_node_ptr(ap),r3	;point to operator node
	movl	pli_node_opr_arg_cur(r3),r2 ;number of arguments
	addl3	r2,r2,r1		;*2 flink+blink
	movl	pli_node_opr_sub_fl-8(r3)[r1],r0 ;point to last argument
	cmpl	#pli_node_type$k_oprcon,pli_node_type(r0) ;continue node?
	beql	100$			;branch if a continue node
	addl2	r2,@ap_count_ptr(ap)	;update count
	movl	#sts$k_success,r0	;successful return
	ret				;
100$:	decl	r2			;subscript count doesn't include
					;the continue node
	addl2	r2,@ap_count_ptr(ap)	;update the count
	pushl	r0			;point to oprcon node
	pushl	ap_count_ptr(ap)	;pass along count address
	calls	#2,pli_get_subscript_count ;recur
	ret				;use return value of called routine
	.subtitle pli_hot_to_vd
	.page
;
; ***********************************************************************
; *									*
; *	pli_hot_to_vd							*
; *									*
; ***********************************************************************
;
	.entry  pli_hot_to_vd,^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>
ap_node_ptr	=	4		;pointer to subtree
ap_head_ptr	=	8		;pointer to head node
ap_vd_ptr	=	12		;pointer to vd (storage supplied)
ap_message_vect =	16		;message vector
;
;	register	use
;	r11		pointer to vd being built
;	r10		initial subtree node pointer
;	r9		name node data, plivd node, or operator node being
;			converted
;	r8		general pointer for following data structure chains
;
	moval	conv_cdh,(fp)		;establish condition handler
	brb	cool_it			;go cool the tree
conv_cdh:	.word	^m<r2,r3,r4,r5>	;pli conversion condition handler
	movl	chf$l_sigarglst(ap),r3	;point to signal arguments
	cmpl	#pli$_error,chf$l_sig_name(r3) ;is it a pli conversion error?
	beql	10$			;branch if so
	movl	#ss$_resignal,r0	;resignal the error
	ret				;
10$:					;pli conversion error
	movl	chf$l_mcharglst(ap),r4	;point to mechanism list
	$unwind_s chf$l_mch_depth(r4),20$ ;unwind the frames
	cmpl	r0,#sts$k_success	;successful unwind call?
	beql	19$			;branch if ok
	brw	never_error		;we should never fall through here
;
;***later we should give system service failure message for the above
;
19$:	ret				;error
20$:	pushl	#0			;no fao arguments
	pushl	#dbg$_nocnvt		;conversion error	
	calls	#2,dbg$nmake_arg_vect	;make the argument vector
	movl	r0,@ap_message_vect(ap)	;update vector pointer
	movl	#sts$k_severe,r0	;severe error
	ret				;
cool_it:				;cool the tree
;
;cool the tree
;
	pushl	ap_message_vect(ap)	;pass along the message vector
	pushl	ap_head_ptr(ap)		;push the tree head node
	pushl	ap_node_ptr(ap)		;push node of subtree to cool
	calls	#3,pli_cool_tree	;cool the tree
	blbs	r0,10$			;branch if ok
	ret				;
10$:					;successful cooling
;
;point to the appropriate node in the tree
;***temp later expand to do operator evaluations
;
	movl	ap_vd_ptr(ap),r11	;point to value descriptor storage
	movl	ap_node_ptr(ap),r10	;point to first subtree node
	movl	r10,r9			;copy initial subtree node to current
					;to current node pointer
20$:	casel	pli_node_type(r9),#0,#19 ;node type case
30$:					;
	.word	never_error -	30$	;0 reserved
	.word	50$	    -	30$	;1 head node
	.word	never_error -	30$	;2 name node function
	.word	never_error -	30$	;3 name node data
	.word	never_error -	30$	;4 name node other (routine, module)
	.word	2000$	    -	30$	;5 operator node - infix or prefix opr
	.word	90$	    -	30$	;6 operator node - named function
	.word	150$	    -	30$	;7 operator node - named data
	.word	90$	    -	30$	;8 operator node - named other
	.word	100$	    -	30$	;9 operator node - pointer
	.word	notyet	    -	30$	;10 operator node - arguments
	.word	notyet	    -	30$	;11 operator node - subscripts
	.word	never_error -	30$	;12 operator node - left parenthesis
	.word	never_error -	30$	;13 operator node - continue
	.word	1000$	    -	30$	;14 pli value descriptor node
	.word	never_error -	30$	;15 debug special symbol node
	.word	never_error -	30$	;16 debug constant node
	.word	never_error -	30$	;17 oprnd -state = need more name
	.word	never_error -	10$	;18 oprscr - state = need more scr
	.word	never_error -	10$	;19 oprcon - state = need more operand
	brw	never_error		;node type code too high
;
;head node
;
50$:					;
	movl	pli_node_flink(r9),r9	;point to first node after head
	cmpl	r10,r9			;only head node in tree?
	beql	60$			;branch if only head node
	movl	r9,r10			;new subtree node pointer
	brb	20$			;convert this new node
60$:	brw	never_error		;this should have been trapped before
;
;reference has no value error
;
90$:	pushl	#0			;no fao arguments
	pushl	#dbg$_novalue		;reference has no value	
	calls	#2,dbg$nmake_arg_vect	;make the argument vector
	movl	r0,@ap_message_vect(ap)	;update vector pointer
	movl	#sts$k_severe,r0	;severe error
	ret				;
;
;pointer node
;
100$:					;
	movl	pli_node_opr_sub_fl+8(r9),r9 ;point to second operand
	movl	r9,r10			;new subtree
	brw	20$			;calculate vd for this subtree
;
;go look at the name node
;
150$:	movl	pli_node_opr_sub_fl(r9),r9 ;look at first argument node
	cmpl	#pli_node_type$k_named,pli_node_type(r9) ;name data node?
	beql	160$			;branch if so (ok)
	brw	never_error		;this should never happen
;
;create non volatile value descriptor
;
160$:					;
	movl	pli_node_nam_sd2_ptr(r9),r2 ;point to type 7 strides
	tstl	pli_sd_link(r2)		;make sure their is only one stride
	beql	170$			;branch if only one
;****temp return with appropriate message vector here
;****temp or do we create vd for structures?
	movl	#sts$k_severe,r0	;severe error
	ret				;
170$:					;
	movl	pli_node_nam_vd_ptr(r9),r8 ;point to vd template
	addl3	#7,pli_sd_bits(r2),r5	;add bit round term
	bicl3	#^c7,pli_vd$l_boff(r8),r0 ;bit offset low 3 order bits
	addl2	r0,r5			;add because offset can cause bit
					;field to cross a byte boundary
	ashl	#-3,r5,r5		;bits to bytes (round neg. numbers
					;away from zero)
	addl2	pli_sd_bytes(r2),r5	;total bytes of data
	addl3	#pli_vd$k_size+3,r5,r6	;add static vd size + round factor
;
; get storage for value descriptor
;
	pushl	ap_message_vect(ap)	;pointer to message vector
	pushl	r11			;the free storage will be value desc.
	ashl	#-2,r6,-(sp)		;number of longwords needed
	calls	#3,dbg$nlist_freez	;get listed storage
	blbs	r0,220$			;branch if ok
	ret				;
220$:					;
	movl	(r11),r11		;point to value descriptor
	movb	#dbg$k_pli,dsc$b_class(r11) ;language code
	movb	#dbg$k_value_desc,dsc$b_dtype(r11) ;type of descriptor
	clrl	dsc$a_pointer(r11)	;clear reserved field
	movw	r6,dsc$w_length(r11)	;length of value descriptor
	movl	pli_vd$l_type(r8),pli_vd$l_type(r11) ;pli datatype
	movl	pli_vd$l_size(r8),pli_vd$l_size(r11) ;vd size field
	movl	pli_vd$l_boff(r8),pli_vd$l_boff(r11) ;bit offset
	moval	pli_vd$a_ptr(r11),pli_vd$a_addr(r11) ;point to data pointer
	moval	pli_vd$k_size(r11),r3	;point to end of fixed area
	movl	r3,pli_vd$a_ptr(r11)	;put in data pointer
	movc3	r5,@pli_vd$a_ptr(r8),(r3) ;copy the data
	movl	#sts$k_success,r0	;success
	ret				;
;
;pli vd node -
; first convert as specified in node
;
1000$:					;
	movw	pli_node_vd_stype(r9),-(sp) ;type of target
	movw	pli_node_vd_ssize(r9),-(sp) ;size of target
	calls	#1,pli_byte_size	;get size of target in bytes
	blbs	r0,1020$		;branch if ok
	brw	90$			;must not have a value
1020$:					;
	movl	r1,r7			;save target byte count
	pushl	#0			;allocate pointer space
	subl2	r7,sp			;allocate target storage
	movl	sp,r8			;base of temporary storage
	pushl	#0			;offset of target
	pushl	pli_node_vd_ssize(r9)	;size of target
	pushl	pli_node_vd_stype(r9)	;type of target
	pushl	r8			;free storage area pointer
	moval	4(r8),(r8)		;create pointer
	moval	-16(sp),sp		;make room for 4 longwords
	moval	pli_node_vd$a_addr(r9),r0 ;point to 4 longwords
	movc3	#16,(r0),(sp)		;move the source description
	calls	#8,pli$cvrt_any		;convert data
	addl3	#pli_vd$k_size+3,r7,r6 ;add static vd size + round factor
;
; get storage for value descriptor
;
	pushl	ap_message_vect(ap)	;pointer to message vector
	pushl	r11			;the free storage will be value desc.
	ashl	#-2,r6,-(sp)		;number of longwords needed
	calls	#3,dbg$nlist_freez	;get listed storage
	blbs	r0,1220$		;branch if ok
	ret				;
1220$:					;
	movl	(r11),r11		;point to value descriptor
	movb	#dbg$k_pli,dsc$b_class(r11) ;language code
	movb	#dbg$k_value_desc,dsc$b_dtype(r11) ;type of descriptor
	clrl	dsc$a_pointer(r11)	;clear reserved field
	movw	r6,dsc$w_length(r11)	;length of value descriptor
	movl	pli_node_vd_stype(r9),pli_vd$l_type(r11) ;pli datatype
	movl	pli_node_vd_ssize(r9),pli_vd$l_size(r11) ;vd size field
	clrl	pli_vd$l_boff(r11) 	;bit offset
	moval	pli_vd$a_ptr(r11),pli_vd$a_addr(r11) ;point to data pointer
	moval	pli_vd$k_size(r11),r3 ;point to end of fixed area
	movl	r3,pli_vd$a_ptr(r11)	;put in data pointer
	movc3	r7,4(r8),(r3)		;copy the data
1900$:	movl	#sts$k_success,r0	;success
	ret				;
;
;	operator node - infix or prefix operator
;
;
;	register	use
;	r11		pointer to VD (output)
;	r10		pointer to operator node
;	r9		pointer to operator node subtree
;	r8		pointer to parent of (r9) node
;
2000$:	movl	pli_node_opr_sub_fl(r10),r9 ;point to operator node subtree
	cmpl	#pli_node_opr$k_unary_plus,pli_node_opr_subtype(r10) ;unary
					;plus operator
	beql	3000$			;branch if unary plus
	cmpl	#pli_node_opr$k_unary_minus,pli_node_opr_subtype(r10) ;unary
					;minus operator
	beql	4000$			;branch if unary minus
	pushl	#dbg$_invopr		;invalid operator message
	calls	#1,dbg$nmake_arg_vect	;make the message vector
	movl	r0,@ap_message_vect(ap)	;update message pointer
	movl	#sts$k_severe,r0	;severe error return
	ret				;
;
; unary plus operator
;
3000$:	pushl	ap_message_vect(ap)	;pointer to message vector
	pushl	r11			;pass along pointer to vd
	pushl	ap_head_ptr(ap)		;pass along head node
	pushl	r9			;subtree to convert to vd
	calls	#4,pli_hot_to_vd	;convert subtree to vd
	blbs	r0,3100$		;branch if successful
	ret				;unsuccessful return
3100$:	brw	1900$			;successful return
;
;
;unary minus
;
4000$:	pushl	ap_message_vect(ap)	;pointer to message vector
	pushl	r11			;pass along pointer to vd
	pushl	ap_head_ptr(ap)		;pass along head node
	pushl	r9			;subtree to convert to vd
	calls	#4,pli_hot_to_vd	;convert subtree to vd
	blbs	r0,4100$		;branch if successful
	ret				;unsuccessful return
4100$:					;got the value descriptor
	movl	(r11),r6		;point to vd	
	movl	pli_vd$a_ptr(r6),r8	;point to data
	movl	pli_vd$l_size(r6),r7	;vd size field
	casel	pli_vd$l_type(r6),#pictured_,#any_type_-pictured_
4200$:					;
	.word	4250$	-	4200$	;pictured_	1
	.word	4300$	-	4200$	;fixed_bin_	2
	.word	4400$	-	4200$	;float_bin_	3
	.word	4500$	-	4200$	;fixed_dec_	4
	.word	4400$	-	4200$	;float_dec_	5
	.word	4250$	-	4200$	;complex_fixed_bin_ 6
	.word	4250$	-	4200$	;complex_float_bin_ 7
	.word	4250$	-	4200$	;complex_fixed_dec_ 8
	.word	4250$	-	4200$	;complex_float_dec_ 9
	.word	4250$	-	4200$	;char_		10
	.word	4250$	-	4200$	;char_var_	11
	.word	4250$	-	4200$	;bit_		12
	.word	4250$	-	4200$	;bit_var_	13
	.word	4250$	-	4200$	;bit_aligned_	14
	.word	4250$	-	4200$	;pointer_	15
	.word	4250$	-	4200$	;offset_ 	16
	.word	4250$	-	4200$	;area_		17
	.word	4250$	-	4200$	;file_		18
	.word	4250$	-	4200$	;label_		19
	.word	4250$	-	4200$	;entry_		20
	.word	4250$	-	4200$	;format_	21
	.word	4250$	-	4200$	;dope_		22/* this should go away */
	.word	4250$	-	4200$	;data_		22/*untyped data -- for constants */
	.word	4250$	-	4200$	;structure_	23
	.word	4250$	-	4200$	;bif_		24
	.word	4250$	-	4200$	;cond_		25
	.word	4250$	-	4200$	;array_		27
	.word	4250$	-	4200$	;any_type_	28
;
;***temp later give better error message
4250$:	pushl	#dbg$_illtype		;illegal type of operand
	calls	#1,dbg$nmake_arg_vect	;make the error message
	movl	r0,@ap_message_vect(ap)	;update message vector pointer
	movl	#sts$k_severe,r0	;severe return
	ret				;
;
;- fixed_bin
;
;	register	use
;	r10
;	r9
;	r8		pointer to data
;	r7		vd size field
;	r6		vd node
;
4300$:	bbc	#4,r7,4350$		;branch if not longword
	mnegl	(r8),(r8)		;negate longword
4310$:	brw	1900$			;successful return
4350$:	bbc	#3,r7,4360$		;branch if byte
	mnegw	(r8),(r8)		;negate word
	brb	4310$			;successful return
4360$:	mnegb	(r8),(r8)		;negate byte
	brb	4310$			;successful return	

;
;- float_binary
;- float_decimal
;
;	register	use
;	r10
;	r9
;	r8		pointer to data
;	r7		vd size field
;	r6		vd node
;
4400$:	xorw2	#^x8000,(r8)		;reverse sign bit
	brw	1900$			;successful return
;***later check for reserved floating operand fault
;
;
; - fixed_dec
;
;	register	use
;	r10
;	r9
;	r8		pointer to data
;	r7		vd size field
;	r6		vd node
;
4499$:	.packed	+0			;zero constant
4500$:	bicl	#^c255,r7		;clear scale, leave precision
	moval	-16(sp),sp		;temp storage for 31 decimal digits
	subp6	r7,(r8),#1,4499$,r7,(sp);negate packed number
	movp	r7,(sp),(r8)		;move back to original area
	moval	16(sp),sp		;restore stack
	brw	1900$			;successful return
;
;
;
;
;error return codes
;
notyet:	movl	#pli$k_not_yet,r0	;not yet implemented
	brb	bug_check		;merge with common code
never_error:				;this should never occur
	movl	#pli$k_never,r0		;code for "never should happen"
bug_check:				;signal error - r0 must contain code
	pushl	r0			;push error code
	pushl	#1			;one fao argument
	pushl	#dbg$_debugbug		;pli debug module error
	calls	#3,lib$signal		;signal error, should never return
	ret				;
	.subtitle	pli_top_opr_arg_walk
	.page
;
;********************************************************
;*							*
;*	pli_top_opr_arg_walk			*
;*							*
;* searches the tree in pre_order, calling the specified*
;* routine whenever a top level operator node is	*
;* encountered. The action routine is called for each	*
;* of the arguments of this operator.			*
;* The action routine is passed a pointer to the	*
;* operator node subtrees (argument), the address of	*
;* the trees head node, a general			*
;* argument, and a message vector.			*
;* The action routine is allowed to modify the tree	*
;* (below) the  pointed to operator node.		*
;*							*
;********************************************************
;
;	register	use
;
;
ap_node_ptr	=	4		;first top level node
ap_head_ptr	=	8		;pointer to head node
ap_action_arg	=	12		;argument to pass action routine
ap_action	=	16		;entry point of action routine to call
ap_message_vect	=	20		;message vector to pass to action
					;routine
	.entry	pli_top_opr_arg_walk,^m<r2,r3,r4,r5,r6,r7,r8>
	movl	ap_node_ptr(ap),r6	;point to the node in question
	casel	pli_node_type(r6),#0,#19 ;node type case
10$:					;
	.word	never_error -	10$	;0 reserved
	.word	20$	-	10$	;1 head node
	.word	140$	-	10$	;2 name node function
	.word	140$	-	10$	;3 name node data
	.word	140$	-	10$	;4 name node other (routine, module)
	.word	100$	-	10$	;5 operator node - infix or prefix opr
	.word	100$	-	10$	;6 operator node - named function
	.word	100$	-	10$	;7 operator node - named data
	.word	100$	-	10$	;8 operator node - named other
	.word	100$	-	10$	;9 operator node - pointer
	.word	100$	-	10$	;10 operator node - arguments
	.word	100$	-	10$	;11 operator node - subscripts
	.word	100$	-	10$	;12 operator node - left parenthesis
	.word	100$ 	-	10$	;13 operator node - continue
	.word	140$ 	-	10$	;14 pli value descriptor node
	.word	140$ 	-	10$	;15 debug special symbol node
	.word	140$ 	-	10$	;16 debug constant node
;***later check for illegal tree states like the following?
	.word	100$ 	-	10$	;17 oprnd -state = need more name
	.word	100$    -	10$	;18 oprscr - state = need more scr
	.word	100$    -	10$	;19 oprcon - state = need more operand
	brw	never_error		;node type code too high
20$:					;head node
	cmpl	r6,pli_node_flink(r6)	;only a head node?
	bneq	30$			;branch if more to the tree
	movl	#sts$k_success,r0	;successfull return
	ret				;
30$:	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	ap_action(ap)		;pass along action routine
	pushl	ap_action_arg(ap)	;pass along action argument
	pushl	ap_head_ptr(ap)		;pass along head node address
	pushl	pli_node_flink(r6)	;point to next node in tree
	calls	#5,pli_top_opr_arg_walk ;recur
	ret				;
100$:					;operator node encountered
	clrl	r3			;argument counter
130$:	aobleq	pli_node_opr_arg_cur(r6),r3,150$ ;increment argument counter
140$:					;return immediately
	movl	#sts$k_success,r0	;successful return
	ret				;
150$:					;
	movq	pli_node_opr_sub_fl-8(r6)[r3],r4 ;point to next argument node
	cmpl	#pli_node_type$k_oprcon,pli_node_type(r4) ;is it a continue?
	beql	160$			;branch if a continue node
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	ap_action_arg(ap)	;pass along action argument
	pushl	ap_head_ptr(ap)		;pointer to tree head node
	pushl	r4			;point to the operator node argument
	calls	#4,@ap_action(ap)	;call the action routine
	blbs	r0,130$			;branch if ok
	ret				;
;
;continue node is one of the arguments
;
160$:
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	ap_action(ap)		;pass along action routine
	pushl	ap_action_arg(ap)	;pass along action argument
	pushl	ap_head_ptr(ap)		;pass along pointer to tree head
	pushl	r4			;point to next continue node
	calls	#5,pli_top_opr_arg_walk ;recur
	blbs	r0,130$			;branch if ok
	ret				;
	.subtitle	pli_top_nd_sub_eval
	.page
	.entry	pli_top_nd_sub_eval,^m<r2,r3,r4,r5,r6>
ap_node_ptr	=	4
ap_head_node	=	8
ap_message_vect	=	12
;
;this routine looks at the name node passed as a parameter and
;if the name node is a named node, creates the subscript vector
;associated with that name.
;
;	register	use
;	r6		named node
;	r5		base of subscript value vector
;
;first determine if the name node is a data node
;
	movl	ap_node_ptr(ap),r6	;point to name node
	cmpl	#pli_node_type$k_named,pli_node_type(r6) ;is it a named node?
	beql	30$			;branch if named
10$:	movl	#sts$k_success,r0	;successful return
	ret				;
30$:	pushl	pli_node_nam_arg_fl(r6)	;address of subscript subtree
	beql	10$			;branch if no such subtree
	pushal	pli_node_nam_vector_size(r6) ;number of subscripts represented
	calls	#2,pli_get_subscript_count
	blbs	r0,50$			;branch if ok
	ret				;
50$:					;number of subscript elements now known
	movl	pli_node_nam_vector_size(r6),r4 ;hold number of vector elements
	pushl	ap_message_vect(ap)	;pass along message vector
	pushal	pli_node_nam_vector(r6)	;storage will be the vector
	pushl	r4			;number of longwords needed
	calls	#3,dbg$nlist_freez	;get the free storage
	blbs	r0,60$			;branch if got the storage
	ret				;
60$:	movl	pli_node_nam_vector(r6),r5 ;point to subscript value vector
	pushal	-4(r5)[r4]		;address of last element
	pushl	ap_message_vect(ap)	;pass along message vector
	pushal	g^pli_get_subscript_value ;address of action routine
	pushal	8(sp)			;point to action argument
	pushl	ap_head_node(ap)	;pointer to head node of tree
	pushl	pli_node_nam_arg_fl(r6)	;subscript subtree
	calls	#5,pli_top_opr_arg_walk	;walk the top level operator arguments
	clrq	pli_node_nam_arg_fl(r6)	;prune the subscript subtree
	ret				;
	.subtitle	pli_get_subscript_value
	.page
;
;********************************************************
;	pli_get_subscript_value				*
;********************************************************
;
;this routine is passed a subtree which it evaluates
;and converts if necessary to a signed 32-bit longword value
;
;	register	use
;	r6		address where subscript value is to be placed
;
ap_subtree_ptr	=	4		;pointer to subscript subtree
ap_head_ptr	=	8		;pointer to head node
ap_ptr_value_ptr=	12		;pointer to value pointer
ap_message_vect	=	16		;message vector pointer
	.entry	pli_get_subscript_value,^m<r2,r3,r4,r5,r6>
	movl	@ap_ptr_value_ptr(ap),r6 ;put subscript value at this address
	subl2	#4,@ap_ptr_value_ptr(ap) ;other subscripts come before
					;this one, i.e. a(1,2,3) gets put
					;into a vector as 3,2,1
	pushl	#0			;temporary storage for vd pointer
	pushl	ap_message_vect(ap)	;pass along message vector
	pushal	4(sp)			;point to vd pointer storage
	pushl	ap_head_ptr(ap)		;pass along pointer to tree head node
	pushl	ap_subtree_ptr(ap)	;subtree that evaluates to a subscript
	calls	#4,pli_hot_to_vd	;convert to a value descriptor
	blbs	r0,100$			;branch if ok
	ret				;
100$:					;stack still has pointer to vd
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	r6			;address of resulting longword
	pushl	8(sp)			;address of vd
	calls	#3,pli_vd_to_fixed_bin_31 ;convert to fixed binary (31)
	ret				;

	.subtitle	pli_vd_to_fixed_bin_31
	.page
;
;********************************************************
;* pli_vd_to_fixed_bin_31				*
;********************************************************
;
;this routine is passed a valued descriptor which it converts
;to a signed 31-bit longword
;
ap_vd_ptr	=	4		;pointer to value descriptor
ap_result_ptr	=	8		;pointer to result longword
ap_message_vect	=	12		;address of message vector
	.entry	pli_vd_to_fixed_bin_31,^m<r2,r3,r4,r5>
	moval	conv_cdh,(fp)		;use condition handler from
					; pli_hot_to_vd
	pushl	ap_result_ptr(ap)	;point to result longword
	pushl	#0			;offset of target
	pushl	#31			;size of target
	pushl	#fixed_bin_		;type of target
	pushal	12(sp)			;result longword pointer
	moval	-16(sp),sp		;make room for 4 longwords
	movl	ap_vd_ptr(ap),r0	;point to value descriptor
	movc3	#16,pli_vd$a_addr(r0),(sp) ;move in source
	calls	#8,pli$cvrt_any		;convert to fixed bin(31)
	movl	#sts$k_success,r0	;successful return
	ret				;


	.subtitle	pli_byte_size
	.page
;
;********************************************************
;*	pli_byte_size					*
;********************************************************
; pli_byte_size -- determine byte size of an operand
;
; functional description:
;
;	This routine determines the size in bytes of an operand, based upon
;	the size field generated by the compiler and the operands data type.
;
; inputs:
;	(ap) - number of arguments (1)
;	4(ap) - word containing the size of the operand
;	6(ap) - word containing the data type of the operand
;
; outputs:
;	r0 - return status
;	r1 - contains the length in bytes of the operand
;--
	.entry	pli_byte_size,^m<r2,r3>
	movl	#sts$k_success,r0	;assume success
	movzwl	4(ap),r2		;get size of operand
	movzwl	6(ap),r3		;get data type of operand
	caseb	r3,#0,#27		;case on data type
5$:	.word	10$	-	5$	;undefined
	.word	90$	-	5$	;picture
	.word	20$	-	5$	;fixed binary 
	.word	50$	-	5$	;float binary
	.word	80$	-	5$	;fixed decimal
	.word	110$	-	5$	;float decimal
	.word	10$	-	5$	;complex fixed binary
	.word	10$	-	5$	;complex float binary
	.word	10$	-	5$	;complex fixed decimal
	.word	10$	-	5$	;complex float decimal
	.word	90$	-	5$	;character
	.word	85$	-	5$	;character varying
	.word	100$	-	5$	;bit (we assume aligned usage)
	.word	10$	-	5$	;bit varying
	.word	100$	-	5$	;bit aligned
	.word	150$	-	5$	;pointer
	.word	150$	-	5$	;offset
	.word	90$	-	5$	;area
	.word	10$	-	5$	;file
	.word	10$	-	5$	;label
	.word	10$	-	5$	;entry
	.word	10$	-	5$	;format
	.word	10$	-	5$	;dope vector
	.word	90$	-	5$	;structure
	.word	10$	-	5$	;built in function
	.word	10$	-	5$	;condition
	.word	10$	-	5$	;generic
	.word	90$	-	5$	;array
;
;error return
;
10$:    movl	#sts$k_severe,r0	;severe error return
	ret				;
;
;fixed binary
;
20$:	movl	#1,r1			;assume it fits in 1 byte
	bbc	#4,r2,40$		;if precision > 15 then
	movl	#4,r1			;set length of 4 bytes
30$:	ret				;
40$:	bbc	#3,r2,30$		;if precision > 7  then
	movl	#2,r1			;set length of 2 bytes
	ret				;
;
;float binary
;
50$:	movl	#4,r1			;for float bin, assume single precision
	cmpl	r2,#53			;if precision > 53
	bleq	70$			;then
	movl	#16,r1			;set 16 bytes	
60$:	ret				;
70$:	cmpl	r2,#24			;if precision > 24
	bleq	60$			;then
	movl	#8,r1			;set 8 bytes
	ret				;
;
;fixed decimal
;
80$:	movzbl	r2,r2			;ignore scale
	ashl	#-1,r2,r2		;divide number of decimal digits by 2
	incl	r2			;add 1
	movl	r2,r1			;set result
	ret				;
;
;character varying
;
85$:	addl3	#2,r2,r1		;maximum byte size + control word
	ret				;
;
;picture
;character
;area
;structure
;array (?)
90$:	movl	r2,r1			;set result
	ret				;
;
;bit and bit aligned
;
100$:	addl	#7,r2			;add 7 to number of bits
	ashl	#-3,r2,r1		;divide by 8
	ret				;
;
;float decimal
;
110$:	movl	#4,r1			;for flt dec, assume single prec
	cmpl	r2,#7			;prec > 7?
	bgtr	130$			;if gtr, yes, cont
120$:	ret				;
130$:	movl	#8,r1			;assume double prec
	cmpl	r2,#15			;prec > 15?
	bleq	120$			;if leq, no, it's double
	movl	#16,r1			;set quad prec
	ret				;
;
;pointer and offset
;
150$:	movl	#4,r1			;longword size
	ret				;
	.subtitle pli_create_type_block
	.page
	.entry pli_create_type_block,^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>
;
;****************************************************************
;*								*
;* pli_create_type_block					*
;*								*
;* 1) this routine assumes kind code is data			*
;* 2) THIS ROUTINE ASSUMES DBG$STA_SETCONTEXT HAS BEEN CALLED	*
;*								*
;* input:symid (for error messages)				*
;*	 fcode							*
;*	 type id						*
;* output:pli data type	(longword)				*
;*	  pli size code	(longword)				*
;*	  vd bit offset (longword)				*
;*	note: the output is part of a value descriptor		*
;*								*
;****************************************************************
;
;	This routine creates a structure descriptor optional
;	type block for the following fcode values:
;
;	fcode		$a_desc		arg1		arg2		cont
;
; rst$k_type_array	dscaddr		celltype	2nd fcode	(yes)
;
; rst$k_type_atomic	0		typecode	-		-
;
; rst$k_type_desc	dscaddr		-		-		-
;
; rst$k_type_pict	0		pictval		-		-
;
; rst$k_type_offset	0		area_id		-		-
;
; rst$k_type_area	0		byte_len	-		-
;
;
; No structure descriptor optional block is created for the following fcode
; values (kind code data)
;
; rst$k_type_file	(type routine called to check language)
; rst$k_type_record	(add later when we can examine structures in addition
;			to structure elements)
; rst$k_type_union
;
;
;
;***later*** currently we simplify copying the structure descriptor optional
;type block by having the descriptor pointer in a fixed location and consider
;the other values as fixed and relocatable. The structure descriptor block is
;however, of variable length, the first byte giving indirectly, the number
;of arguments present (it is a byte count). When we support record and union
;examines, we may wish to abandon this approach and have an optional type
;block that completely depends upon the fcode value. We then have to case
;on the fcode type in the pli_copy_tree routine.
;
;
;
; register	use
;	r11	points to optional type block
;	r10	points to descriptor
;
;
ap_symid	=	4		;symid (for error message creation)
ap_fcode_ptr	=	8		;pointer to fcode
ap_type_id	=	12		;value of type_id
ap_type_block_ptr =	16		;pointer to optional type block
ap_message_vect	=	20		;message vector
	movl	ap_type_block_ptr(ap),r11;point to start of type block
	casel	@ap_fcode_ptr(ap),#rst$k_type_minimum,- ;case on the fcode values
		#18-rst$k_type_minimum	;we currently only know about 18
10$:	.word	100$	-	10$	;1 array type
	.word	1000$	-	10$	;2 atomic (VAX std.)
	.word	2000$	-	10$	;3 descriptor (VAX std.)
	.word	9000$	-	10$	;4 enumeration type
	.word	3000$	-	10$	;5 picture
	.word	9000$	-	10$	;6 typed pointer
	.word	4000$	-	10$	;7 record
	.word	9000$	-	10$	;8 set
	.word	9000$	-	10$	;9 subrange
	.word	9000$	-	10$	;10 subset
	.word	9000$	-	10$	;11 union
	.word	9000$	-	10$	;12 cobol hack
	.word	9000$	-	10$	;13 bliss data item
	.word	9000$	-	10$	;14 bliss field
	.word	5000$	-	10$	;15 file
	.word	6000$	-	10$	;16 pointer
	.word	7000$	-	10$	;17 area
	.word	8000$	-	10$	;18 offset
	brw	9000$			;not supported yet (unknown type)
;
;array data type
;
;***later currently the pli compiler only outputs array dst's even if
;it could use descriptor dst's. If this changes or if we decide to
;try (the impossible) and support other compilers, the descriptor dst
;processing has to change
;
;	fcode		$a_desc		arg1		arg2		cont
;
; rst$k_type_array	dscaddr		celltype	2nd fcode	(yes)
;
100$:					;
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	ap_type_block_ptr(ap)	;address of type block pointer
	pushl	#5			;longwords of storage needed
	calls	#3,dbg$nlist_freez	;get the zeroed storage
	blbs	r0,110$			;branch if ok
	ret				;
110$:	movl	@ap_type_block_ptr(ap),r11 ;point to the optional type block
	movl	#20,pli_struc_opt$b_count(r11) ;byte count for type block
	moval	-12(sp),sp		;make room for 3 longwords
	pushal	8(sp)			;pointer to bitsize            8(sp)
	pushal	8(sp)			;pointer to dimvecptr value    4(sp)
	pushal	8(sp)			;pointer to ndims               (sp)
	pushal	pli_struc_opt$l_arg1(r11) ;celltype (a type_id)
	pushal	pli_struc_opt$a_desc(r11) ;descriptor address	
	pushl	ap_type_id(ap)		;type id for array
	calls	#6,dbg$sta_typ_array	;get type information for arrays
	addl2	#12,sp			;pop off temporary storage (values
					;are currently not used
;
;copy the descriptor
;
120$:	pushl	#0			;temporary storage for byte count
	pushl	ap_message_vect(ap)	;pass along message vector
	pushal	4(sp)			;point to zeroed byte count
	pushl	pli_struc_opt$a_desc(r11) ;point to descriptor to be copied
	calls	#3,pli_size_vax_desc	;determine size of vax descriptor
	blbs	r0,130$			;branch if ok
	ret				;
130$:	movl	(sp)+,r6		;save the byte count
	movl	pli_struc_opt$a_desc(r11),r2 ;save the source desc. address
	pushl	ap_message_vect(ap)	;pass along the message vector
	pushal	pli_struc_opt$a_desc(r11) ;pointer to new descriptor
	addl3	r6,#3,r0		;round up byte count
	ashl	#-2,r0,-(sp)		;number of longwords
	calls	#3,dbg$nlist_freez	;get the storage
	blbs	r0,140$			;branch if ok
	ret				;
140$:	movc3	r6,(r2),@pli_struc_opt$a_desc(r11) ;copy the descriptor
	movl	pli_struc_opt$a_desc(r11),r10 ;point to array descriptor
	tstb	dsc$b_dtype(r10)	;special 0 dtype?
	beql	200$			;branch if not standard vax dtype
	brw	1900$			;go make successful exit
;
;type code is not vax standard type
;
200$:	pushl	pli_struc_opt$l_arg1(r11) ;push type id for cell type
	calls	#1,dbg$sta_typefcode	;get the fcode value into r0
	movl	r0,pli_struc_opt$l_arg2(r11) ;secondary fcode
	pushl	ap_message_vect(ap)	;pass along message vector
	pushal	pli_struc_opt$a_cont(r11) ;continue pointer
	pushl	pli_struc_opt$l_arg1(r11) ;type id for cell type
	pushal	pli_struc_opt$l_arg2(r11) ;secondary fcode
	pushl	ap_symid(ap)		;pass symid for error messages
	calls	#5,pli_create_type_block ;recur
	ret				;use return from call
;
;atomic data type
;
;	fcode		$a_desc		arg1		arg2		cont
;
; rst$k_type_atomic	0		typecode	-		-
;
1000$:

	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	ap_type_block_ptr(ap)	;address of type block pointer
	pushl	#3			;longwords of storage needed
	calls	#3,dbg$nlist_freez	;get the zeroed storage
	blbs	r0,1010$		;branch if ok
	ret				;
1010$:	movl	@ap_type_block_ptr(ap),r11 ;point to optional type block
	movl	#12,pli_struc_opt$b_count(r11) ;number of bytes in type block
	pushal	-(sp)			;longword to receive bit length
	pushal	pli_struc_opt$l_arg1(r11) ;arg1 = typecode (vax dtype code)
	pushl	ap_type_id(ap)		;type id of atomic data
	calls	#3,dbg$sta_typ_atomic	;get the type code and bit size
;
;note: (sp) contains the bitsize of the data, this is not currently
;used
;
1900$:					;
	movl	#sts$k_success,r0	;successful return
	ret				;


;
; descriptor
;
;	fcode		$a_desc		arg1		arg2		cont
;
; rst$k_type_desc	dscaddr		-		-		-
;
2000$:					;
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	ap_type_block_ptr(ap)	;address of type block pointer
	pushl	#3			;longwords of storage needed
;
;we allocate 3 longwords just in case this turns out to be an array descriptor
;
	calls	#3,dbg$nlist_freez	;get the zeroed storage
	blbs	r0,2010$		;branch if ok
	ret				;
2010$:	movl	@ap_type_block_ptr(ap),r11 ;point to optional type block
	movl	#12,pli_struc_opt$b_count(r11) ;number of bytes in type block
	pushal	pli_struc_opt$a_desc(r11) ;holds pointer to descriptor
	pushl	ap_type_id(ap)		;type id of atomic data
	calls	#2,dbg$sta_typ_descr	;get the pointer to the descriptor
	movl	pli_struc_opt$a_desc(r11),r10 ;point to the descriptor
	movzbl	dsc$b_class(r10),r1	;get the class code
	casel	r1,#1,#13		;
2020$:	.word	1900$-2020$		;1 = dsc$k_class_s = scalar string
	.word	1900$-2020$		;2 = dsc$k_class_d = dynamic string
	.word	1900$-2020$		;3 = dsc$k_class_v = varying buffer
	.word	2050$-2020$		;4 = dsc$k_class_a = array
	.word	1900$-2020$		;5 = dsc$k_class_p = procedure
;***temp better error message
	.word	notyet-2020$		;6 = ????????
	.word	1900$-2020$		;7 = dsc$k_class_j = label
;**temp better error message
	.word	notyet-2020$		;8 = ????????
	.word	1900$-2020$		;9 = dsc$k_class_sd = decimal scalar
					;string

	.word	2050$-2020$		;10 = dsc$k_class_nca = non_contiguous
					;array
	.word	1900$-2020$		;11 = dsc$k_class_vs = varying string
	.word	2050$-2020$		;12 = dsc$k_class_vsa = varying string
					;array
	.word	1900$-2020$		;13 = dsc$k_class_ubs = unaligned bit
					;string
	.word	2050$-2020$		;14 = dsc$k_class_uba = unaligned bit
					;array
	brw	notyet			;**temp better error message later
;
;an array so we change the fcode value, put in datatype, and merge with
;the common code
;
2050$:	movl	#rst$k_type_array,@ap_fcode_ptr(ap) ;new fcode value
	movl	pli_struc_opt$a_desc(r11),r10 ;point to descriptor
	movzbl	dsc$b_dtype(r10),pli_struc_opt$l_arg1(r11) ;arg1 is data type
	brw	120$			;merge with common code
;
; picture
;
;	stack temp layout for call to picture type routine
;
;	+-----------------------+
;	! language code		! :sp (after call to type routine)
;	+-----------------------+
;	! picture pointer	!  sp+4 (not used)
;	+-----------------------+
;	! picture value		!  sp+8  (gets put in size field of vd)
;	+-----------------------+
;
;	fcode		$a_desc		arg1		arg2		cont
;
; rst$k_type_pict	0		pictval		-		-
;
3000$:					;
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	ap_type_block_ptr(ap)	;address of type block pointer
	pushl	#3			;longwords of storage needed
	calls	#3,dbg$nlist_freez	;get the zeroed storage
	blbs	r0,3010$		;branch if ok
	ret				;
3010$:	movl	@ap_type_block_ptr(ap),r11 ;point to optional type block
	movl	#12,pli_struc_opt$b_count(r11) ;number of bytes in type block
	moval	-8(sp),sp		;reserve 2 longwords
	pushal	pli_struc_opt$l_arg1(r11) ;pictval
	pushal	8(sp)			;pictptr
	pushal	8(sp)			;langcode
	pushl	ap_type_id(ap)		;type id
	calls	#4,dbg$sta_typ_pict	;get picture type dst info
	cmpb	#dbg$k_pli,(sp)		;is the lang code pli?
	bneq	9000$			;branch if not pli picture datatype
	brw	1900$			;common processing (successful return)
;
; structure
;
4000$:					;
	brw	1900$			;not yet ***later
;
; file
;
;	stack usage
;+------------------------------+
;!	language		! (sp)
;+------------------------------+
;!	rectypeid		! (sp)+4
;+------------------------------+
;
5000$:					;file
	moval	-8(sp),sp		;reserve 2 longwords
	pushal	4(sp)			;rectypeid
	pushal	4(sp)			;language
	pushl	ap_type_id(ap)		;type identifier
	calls	#3,dbg$sta_typ_file	;call file "type routine"
	cmpb	#dbg$k_pli,(sp)		;language is pli?
	bneq	9000$			;if not, unknown datatype (branch)
	brw	1900$			;merge with common code



;
; pointer
;
6000$:					;
	brw	1900$			;merge with common code
;
; area
;
;	fcode		$a_desc		arg1		arg2		cont
;
; rst$k_type_area	0		byte_len	-		-
;
7000$:
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	ap_type_block_ptr(ap)	;address of type block pointer
	pushl	#3			;longwords of storage needed
	calls	#3,dbg$nlist_freez	;get the zeroed storage
	blbs	r0,7010$		;branch if ok
	ret				;
7010$:	movl	@ap_type_block_ptr(ap),r11 ;point to the optional type block
	movl	#12,pli_struc_opt$b_count(r11) ;byte count for type block
	pushal	pli_struc_opt$l_arg1(r11) ;byte length of area
	pushl	ap_type_id(ap)		;type id
	calls	#2,dbg$sta_typ_area	;get the type information for area
	brw	1900$			;common successful exit
;
; offset
;
;	fcode		$a_desc		arg1		arg2		cont
;
; rst$k_type_offset	0		area_id		area_len	-
;
8000$:
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	ap_type_block_ptr(ap)	;address of type block pointer
	pushl	#4			;longwords of storage needed
	calls	#3,dbg$nlist_freez	;get the zeroed storage
	blbs	r0,8010$		;branch if ok
	ret				;
8010$:	movl	@ap_type_block_ptr(ap),r11 ;point to the optional type block
	movl	#12,pli_struc_opt$b_count(r11) ;byte count for type block
	pushal	pli_struc_opt$l_arg2(r11) ;area length
	pushal	pli_struc_opt$l_arg1(r11) ;area id (symid)
	pushl	ap_type_id(ap)		;type id
	calls	#3,dbg$sta_typ_offset	;get the type information for area
	brw	1900$			;common successful exit
;
;data type not known to pli
;
9000$:					;
;
;create fully qualified pathname vector
;
	pushl	#0			;make room for cs pointer
	pushal	-(sp)			;pointer to pathname vector
	pushl	ap_symid(ap)		;push symid
	calls	#2,dbg$sta_sympathname	;get the pathname vector
	pushal	4(sp)			;cs pointer
	pushl	4(sp)			;pn vector pointer
	calls	#2,pli_pn_to_cs	;convert to counted string
	pushal	msg_pli			;push the "PLI" string address
	pushl	8(sp)			;point to reference (a string)
	pushl	#2			;2 fao arguments
	pushl	#dbg$_unknowntyp	;type is not known to pli
	calls	#4,dbg$nmake_arg_vect	;make the message vector
	movl	r0,@ap_message_vect(ap) ;pass it as return code
	movl	#sts$k_severe,r0	;severe error
	ret				;	
	.subtitle pli_get_vector_offset
	.page
;
;****************************************************************
;*	pli_get_vector_offset					*
;****************************************************************
;
;	note: this routine assumes that the fcode associated with
;		the structure descriptor associated with the
;		optional type block passed to this routine was
;		of value rst$k_type_array
;
;	input:	pointer to the following array of longwords:
;			  (r11)	vector element count (modified by this routine)
;			 4(r11)	vector address
;			 8(r11)	byte offset (modified by this routine)
;			12(r11)	bit offset (modified by this routine)
;
;		pointer to structure descriptor optional type block
;
;		pointer to message vector
;
;	register	use
;	r11		pointer to argument block
;	r10		pointer to optional type block
;	r9		pointer to array descriptor
;	r8		subscript value array index
;	r7		stride pointer
;	r6		bounds pointer
;	r5		dimension count (used as sob index)
;	r4		running sum so byte and bit arrays can use common code
;
;
ap_arg_ptr	=	4		;pointer to the 4 longword arguments
ap_type_block_ptr =	8		;pointer to the optional type block
ap_symid	=	12		;symid value in case of error
ap_message_vect	=	16		;pointer to the message vector
	.entry	pli_get_vector_offset,^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>
	movl	ap_arg_ptr(ap),r11	;point to argument block
	movl	ap_type_block_ptr(ap),r10 ;point to optional type block
	movl	pli_struc_opt$a_desc(r10),r9 ;point to array descriptor
;
;check to see if the array is class dsc$k_class_a, for if it is
;certain data structure checks are made
;
	cmpb	#dsc$k_class_a,dsc$b_class(r9)	;dsc$k_class_a descriptor?
	bneq	100$			;branch if not
	bbs	#dsc$v_fl_column,-	;branch as an error if column
		dsc$b_aflags(r9),50$	;major array
	bbc	#dsc$v_fl_coeff,-	;branch as an error if there
		dsc$b_aflags(r9),50$	;are no multipliers
	bbs	#dsc$v_fl_bounds,-	;branch to process descriptor because
		dsc$b_aflags(r9),100$	;bounds are present
50$:					;we can't process this descriptor
;
;***later add another message indicating that this is an invalid
;array descriptor for pli or alternatively, try to support other descriptors.
;This is probably not possible because other languages may put the address
;field in the descriptor and this is not possible with pli
;
	pushl	#dbg$_invarrdsc		;invalid array descriptor
	calls	#1,dbg$nmake_arg_vect	;make the message vector
60$:	movl	r0,@ap_message_vect(ap)	;put in message vector value
	movl	#sts$k_severe,r0	;severe error
	ret				;
;
;setup to process descriptor
;
100$:	movl	4(r11),r8		;subscript value vector pointer
	beql	2000$			;branch if no vector given, e.g.
					;if no subscripts specified for an
					;array. (goto error message code)
	movzbl	dsc$b_dimct(r9),r5	;dimension count (sob index)
	moval	dsc$l_s1(r9)[r5],r7	;point to last stride + 4
	movaq	(r7)[r5],r6		;point to last bounds + 4
	clrl	r4			;running sum of displacement
;
;calculate the (byte or bit) displacement
;
500$:	decl	(r11)			;decrease subsc. vector count
	blss	2000$			;branch if not enough subscripts
					;were specified
	movl	(r8)+,r0		;get the next subscript value
	cmpl	r0,-(r6)		;compare subscript with upper bound
	bgtr	2100$			;branch if out of range (too high)
	subl2	-(r6),r0		;subtract lower bound
	blss	2100$			;branch if out of range (too low)
	mull2	-(r7),r0		;multiply normalized subs. * stride
	addl2	r0,r4			;add to running sum
	sobgtr	r5,500$			;iterate for all dimensions
	movl	r8,4(r11)		;restore subsc. value vector pointer
	cmpb	#dsc$k_class_uba,dsc$b_class(r9) ;unaligned bit array
	beql	610$			;branch if so
	addl2	r4,8(r11)		;add as a byte offset
600$:	movl	#sts$k_success,r0	;successful return code
	ret				;
;
;special unaligned bit array processing
610$:	movzbl	dsc$b_dimct(r9),r5	;dimension count
	addl2	r5,r5			;*2 because bounds are quadwords
	addl2	(r6)[r5],r4		;add pos field
	addl2	r4,12(r11)		;add to bit offset total
	brb	600$			;common successful return code
;
;not enough subscripts
;
2000$:	pushal	-(sp)			;pointer to counted string of name
	pushl	ap_symid(ap)		;symid
	calls	#2,dbg$sta_symname	;create name of variable element
;
;(sp) contains pointer to counted string
;
	pushl	#1			;fao argument count
	pushl	#dbg$_needsubs		;"need more subscripts" message
	calls	#3,dbg$nmake_arg_vect	;make the message vector
	brw	60$			;merge with common message exit code
;
;subscript out of bounds
;
2100$:	pushal	-(sp)			;pointer to counted string of name
	pushl	ap_symid(ap)		;symid
	calls	#2,dbg$sta_symname	;create name of variable element
;
;(sp) contains pointer to counted string
;
	pushl	-(r8)			;value of offending subscript
	pushl	#2			;fao argument count
	pushl	#dbg$_suboutval		;subscript out of bounds
	calls	#4,dbg$nmake_arg_vect	;make the message vector
	brw	60$			;mergw with common message exit code
	.subtitle	pli_datatype_to_str_size
	.page
;
;********************************************************
;*	pli_datatype_to_str_size			*
;********************************************************
; pli_datatype_to_str_size -- determine byte size of an operand
;
; functional description:
;
;	This routine determines the number of bytes to allocate for
;	a character varying string that is to hold the converted
;	ascii representation of a value with specified pli datatype
;	and size field.
;
; inputs:
;	(ap) - number of arguments (1)
;	4(ap) - word containing the size of the operand
;	6(ap) - word containing the data type of the operand
;
; outputs:
;	r0 - return status
;	r1 - contains the length in bytes for the character varying string
;--
	.entry	pli_datatype_to_str_size,^m<r2,r3>
	movl	#sts$k_success,r0	;assume success
	movzwl	4(ap),r2		;get size of operand
	movzwl	6(ap),r3		;get data type of operand
	caseb	r3,#0,#27		;case on data type
5$:	.word	10$	-	5$	;undefined
	.word	90$	-	5$	;picture
	.word	20$	-	5$	;fixed binary 
	.word	50$	-	5$	;float binary
	.word	80$	-	5$	;fixed decimal
	.word	110$	-	5$	;float decimal
	.word	10$	-	5$	;complex fixed binary
	.word	10$	-	5$	;complex float binary
	.word	10$	-	5$	;complex fixed decimal
	.word	10$	-	5$	;complex float decimal
	.word	90$	-	5$	;character
	.word	85$	-	5$	;character varying
	.word	100$	-	5$	;bit (we assume aligned usage)
	.word	10$	-	5$	;bit varying
	.word	100$	-	5$	;bit aligned
	.word	150$	-	5$	;pointer
	.word	150$	-	5$	;offset
	.word	90$	-	5$	;area
	.word	10$	-	5$	;file
	.word	10$	-	5$	;label
	.word	10$	-	5$	;entry
	.word	10$	-	5$	;format
	.word	10$	-	5$	;dope vector
	.word	90$	-	5$	;structure
	.word	10$	-	5$	;built in function
	.word	10$	-	5$	;condition
	.word	10$	-	5$	;generic
	.word	90$	-	5$	;array
;
;error return
;
10$:    movl	#sts$k_severe,r0	;severe error return
	ret				;
;
;fixed binary
;
20$:	movl	#5+2,r1			;assume it fits in 1 byte
	bbc	#4,r2,40$		;if precision > 15 then
	movl	#20+2,r1		;length of 4 bytes
30$:	ret				;
40$:	bbc	#3,r2,30$		;if precision > 7  then
	movl	#10+2,r1		;length of 2 bytes
	ret				;
;
;float binary
;
50$:	movl	#30,r1			;for float bin, assume single precision
	cmpl	r2,#53			;if precision > 53
	bleq	70$			;then
	movl	#100,r1			;16 bytes	
60$:	ret				;
70$:	cmpl	r2,#24			;if precision > 24
	bleq	60$			;then
	movl	#50,r1			;set 8 bytes
	ret				;
;
;fixed decimal
;
80$:	movzbl	r2,r2			;ignore scale
	addl3	#5,r2,r1		;add 5
	ret				;
;
;character varying
;
85$:	addl3	#2,r2,r1		;maximum byte size + control word
	ret				;
;
;picture
;character
;area
;structure
;array (?)
90$:	movl	r2,r1			;set result
	ret				;
;
;bit and bit aligned
;
100$:	addl3	#7,r2,r1		;add 7 to number of bits
	ret				;
;
;float decimal
;
110$:	movl	#20,r1			;for flt dec, assume single prec
	cmpl	r2,#7			;prec > 7?
	bgtr	130$			;if gtr, yes, cont
120$:	ret				;
130$:	movl	#50,r1			;assume double prec
	cmpl	r2,#15			;prec > 15?
	bleq	120$			;if leq, no, it's double
	movl	#100,r1			;quad prec
	ret				;
;
;pointer and offset
;
150$:	movl	#20,r1			;longword size
	ret				;
	.end
