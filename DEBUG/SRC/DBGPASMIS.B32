MODULE	DBGPASMIS ( ! Miscellaneous routines for the Debugger/Pascal interface
		IDENT = 'V03-000'
		) =

BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
!++
!
! FACILITY:	VAX-11 PASCAL-SPECIFIC DEBUGGER MODULES
!
! ABSTRACT:
!
!	Primary Output
!	Get L-Value
!	Get Type
!	Get R-Value
!	Make Value
!	Get Pages
!	Get Length
!	Get Symid
!	Copy Descriptor
!	Free Descriptor
!	Logical predecessor/successor
!	Command initialization
!	Symbolize
!
! ENVIRONMENT:	VAX/VMS user mode
!
! AUTHORS: Susan H. Azibert, Paul Hohensee	CREATION DATE: 10-July-1980
!
! MODIFIED BY:
!	PS	Dec-10-1981		Add code to reconfigue the Size field
!					for Record Data Type in Pascal Primary
!					Descriptor in routine DBG$NPAS_LOG_PREDSUC
!--

REQUIRE 'SRC$:PASPROLOG.R32';

!
! Table of Contents
!
FORWARD ROUTINE
	DBG$NPAS_PRIM_OUT,		! Construct an ASCII string representation
					! of a Primary Descriptor
	DBG$NPAS_GET_LVAL,		! Access the symbol table to recover the
					! L-value of a variable
	DBG$NPAS_GET_TYPE,		! Access the symbol table to determine the 
					! type of a variable

	DBG$NPAS_GET_RVAL,		! Access the symbol table to recover the 
					! R-value of a variable
	DBG$NPAS_MAKE_VAL_DESC,		! Construct a Value descriptor
	DBG$NPAS_GET_PAGES,		! Construct a linked list of pages 
					! containing a symbol's r-value
	DBG$NPAS_GET_LENGTH,		! Obtain the length in bits of an object
	DBG$NPAS_GET_SYMID,		! Construct a list of the RST symid's present
					! in a Primary or Value Descriptor
	DBG$NPAS_COPY_DESC,		! Copy a Primary or Value Descriptor to non-volatile storage
	DBG$NPAS_FREE_DESC,		! Deallocate storage for a Primary or Value
					! Descriptor constructed with DBG$NPAS_COPY_DESC
	DBG$NPAS_LOG_PREDSUC,		! Logical Predecessor/Successor
	DBG$NPAS_COM_INIT	: NOVALUE,	! Pascal-specific command initialization

	! Support routines for DBG$NPAS_SYMBOLIZE
	!
	Write_Character		: NOVALUE,
	Write_Character_String	: NOVALUE,
	Write_Integer_String	: NOVALUE,
	Copy_Reference		: NOVALUE,

	DBG$NPAS_SYMBOLIZE;		! Access the symbol table to construct
					! the name of a variable

!
! External Routines
!
EXTERNAL ROUTINE
    	PAS$_Error_Handler;		! Error trap

!
! EXTERNAL storage
!
EXTERNAL
    	PAS$_Message_Vector		: LONG,		! Address of address of error message vector

	! Standard Type Table entries
	!
	PAS$_TRW_Boolean		: BLOCK [,BYTE],
	PAS$_TRW_Char			: BLOCK [,BYTE],
	PAS$_TRW_Double			: BLOCK [,BYTE],
	PAS$_TRW_Double_G		: BLOCK [,BYTE],
	PAS$_TRW_Integer		: BLOCK [,BYTE],
	PAS$_TRW_Real			: BLOCK [,BYTE],
	PAS$_TRW_Quadruple		: BLOCK [,BYTE],
	PAS$_TRW_Unsigned		: BLOCK [,BYTE];

GLOBAL ROUTINE DBG$NPAS_PRIM_OUT (Prim_Desc, String_Desc, Message_Vect) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Uses a symbol's primary descriptor to construct an ascii string descriptor
!	which reflects both the symbolic information associated with the symbol,
!	and the rvalue associated with a symbol. This is of the form:
!
!	MODULE\ROUTINE INVOCATION_NUMBER\[LEXICAL_ENTITY] ...\SYMBOL_NAME: VALUE
!
!	Note that the capability to output aggregate values, such as an entire
!	array, will be required in a future release of DEBUG.
!
! FORMAL PARAMETERS:
!
!	prim_desc	- A longword containing the address of a primary descriptor
!
!	string_desc	- A longword containing the address of a VAX standard
!			  string descriptor with length and pointer fields set
!			  to 0
!
!	message_vect	- The address of a longword to contain the address of a
!			  message argument vector as described on page 4-119
!			  of the VAX/VMS system reference, volume 1A
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	Dynamic storage must be allocated to contain the ascii string described
!	by string_desc on a successful return.
!
!	In case of a severe error return, a message argument vector must be
!	constructed from dynamic storage and returned.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) - Success. Information recovered and returned as an
!			    ascii string.
!
!	STS$K_SEVERE  (4) - Failure. Ascii string not constructed. Message
!			    argument vector constructed and returned.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN
    EXTERNAL ROUTINE
    	DBG$NPAS_TYPE_CONV;					! Type Convertor

    MAP
	String_Desc	: REF BLOCK [8, BYTE],			! a parameter passed in
	Prim_Desc	: REF PAS$_Primary_Desc;		! a parameter passed in

    BIND
	Message_Vector_Address	= .Message_Vect,

	Colon_Space = UPLIT BYTE(': ');					! string containing colon space

    LITERAL
	Colon_Space_Length = 2;

    LOCAL
	Pathname_Desc		: BLOCK [8, BYTE],			! ASCIC pathname descriptor
	Value_Desc,							! address of address of value descriptor
	String_Desc_Of_Value	: BLOCK [8, BYTE];			! ASCII descriptor of the value


    ! call DBG$NPAS_Symbolize to return the string descriptor containing
    ! the variable name
    !
    IF NOT DBG$NPAS_Symbolize(.Prim_desc, Pathname_Desc, Message_Vector_Address)
    THEN
    	RETURN STS$K_SEVERE;


    ! call DBG$NPAS_Make_Val_Desc to get the value of the symbol described
    ! by the primary descriptor. Do not force a depositable value descriptor
    !
    IF NOT DBG$NPAS_Make_Val_Desc(.Prim_Desc, False, Value_Desc, Message_Vector_Address)
    THEN
    	RETURN STS$K_SEVERE;


    ! call DBG$NPAS_Type_Conv to convert the value of the variable from internal
    ! to external (printing) format
    !
    IF NOT DBG$NPAS_Type_Conv(.Value_Desc, DBG$K_Default, DBG$K_External_Desc, String_Desc_Of_Value,
			Message_Vector_Address)
    THEN
    	RETURN STS$K_SEVERE;


    ! start to fill in the string descriptor for the "pathname:value"
    !
    String_Desc[DSC$W_Length] = .Pathname_Desc[DSC$W_Length] + Colon_Space_Length +
			.String_Desc_Of_Value[DSC$W_Length];
    String_Desc[DSC$B_Dtype] = DSC$K_DTYPE_T;
    String_Desc[DSC$B_Class] = DSC$K_CLASS_S;

    ! allocate space for the "pathname:value"
    !
    IF NOT DBG$Nlist_Freez(ROUND_BYTE_TO_LONG_(.String_Desc[DSC$W_Length]), String_Desc[DSC$A_Pointer],
			Message_Vector_Address)
    THEN
	RETURN STS$K_SEVERE

    ELSE
	BEGIN

	! copy the "pathname: value" into the storage just allocated
	!
	CH$COPY(.Pathname_Desc[DSC$W_Length], .Pathname_Desc[DSC$A_Pointer],
	    Colon_Space_Length, CH$PTR(Colon_Space),
	    .String_Desc_Of_Value[DSC$W_Length], .String_Desc_Of_Value[DSC$A_Pointer],
	    %C' ', .String_Desc[DSC$W_Length], .String_Desc[DSC$A_Pointer]);
	RETURN STS$K_SUCCESS;
    	END;
END;

GLOBAL ROUTINE DBG$NPAS_GET_LVAL (Prim_Desc, Lvalue, Message_Vect) =

!++
! FUNCTIONAL DESCRIPTION:
!
! 	Obtains a symbol's lvalue using the primary descriptor for that
!	symbol. Note that most types of named constants do not have an
!	lvalue. The debugger gives special treatment to named constants
!	which have read only memory allocated to contain their value.
!
! FORMAL PARAMETERS:
!
!	prim_desc	- A longword which contains the address of a primary descriptor
!
!	lvalue		- The address of a quadword to contain the lvalue of the
!			  entity described by the primary descriptor and the bit
!			  offset, if any. The byte address will be contained in
!			  in the first longword, the bit offset in the second
!			  longword.
!
!	message_vect	- The address of a longword to contain the address of
!			  a message argument vector as described on page 4-119
!			  of the VAX/VMS system reference, volume 1A
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	An unsigned longword integer completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) - Success. The object described by the input primary
!			    descriptor has an lvalue which is being returned.
!
!	STS$K_ERROR   (2) - Failure. Object does not have an lvalue. 
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN
    EXTERNAL ROUTINE
	PAS$_Get_Address		: NOVALUE;		! Get virtual address using Primary Descriptor 

    MAP
	Prim_Desc	: REF PAS$_Primary_Desc,
	Lvalue		: REF DBG$Address_Desc;

    LOCAL
	Type_Entry	: REF BLOCK [, BYTE] FIELD(Type_Fields);

    ! Find out whether the symbol has an L-Value or not
    !
    IF .Prim_Desc[PAS$PRIM_Ident] EQLA 0
    THEN
	! Predefined, therfore no RST entry and no address
	!
	RETURN STS$K_Error;

    RETURN
	(IF .Prim_Desc[PAS$PRIM_Kind] EQL DBG$K_Val_Literal
	THEN
	    STS$K_Error
	ELSE
	    BEGIN
	    ! Get the address of the object
	    !
	    PAS$_Get_Address(.Prim_Desc, .Lvalue, Type_Entry);

	    STS$K_Success
	    END);

    END;

GLOBAL ROUTINE DBG$NPAS_GET_TYPE (Prim_Desc, Type, Message_Vect) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Uses a symbol's primary descriptor to return type information. The
!	types recognized are limited to three:
!
!	1)	- type named constant and instruction 
!		  (lexical entities, labels)
!
!	2)	- type named constant and
!		  noinstruction (symbolic literals)
!
!	3)	- type other
!
!	The debugger uses kernel resources to display instructions. Therefore,
!	it must have enough information to decide when to do this. Also, special
!	handling is given to symbolic literals. This routine provides enough
!	information to allow the DEBUG kernel to handle these special cases.
!
! FORMAL PARAMETERS:
!
!	prim_desc	- A longword containing the address of a primary descriptor
!
!	type		- The address of a longword to contain an unsigned integer
!			  encoding of the symbol's type as follows:
!
!		dbg$k_nc_instruction (125)	- named constant, instruction
!	
!		dbg$k_nc_other (126)		- named constant, noinstruction
!
!		dbg$k_other (127)		- other
!
!	message_vect	- The address of a longword to contain the address of
!			  a message argument vector as described on page 4-119
!			  of the VAX/VMS system reference, volume 1A
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	In case of a severe error return, a message argument vector is constructed
!	from dynamic storage and returned.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) - Success. Type information recovered and returned.
!
!	STS$K_SEVERE  (4) - Failure. No type information recovered. Message
!			    argument vector constructed and returned.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN
    MAP
	Prim_Desc	: REF PAS$_Primary_Desc;

    LOCAL
	Symid,						! RST pointer
	Kind;						! kind (a general classification of type) returned by STA routines

    ! Move the information about the variable from the primary descriptor to a
    ! local variable
    !
    Symid = .Prim_Desc[PAS$Prim_Ident];

    ! Check for predefined symbol
    !
    IF .Symid EQLA 0
    THEN
	BEGIN
	BIND
	    Symbol_Entry	= .Prim_Desc[PAS$PRIM_Symbol]	: BLOCK [, BYTE] FIELD(Symbol_Fields);

	RETURN
	    (IF .Symbol_Entry[SYM_Class] EQL SYM_K_Constant
	    THEN
		! Predefined constant
		!
		BEGIN
		.Type = DBG$K_NC_Other;
		STS$K_Success
		END
	    ELIF (.Symbol_Entry[SYM_Class] EQL SYM_K_Procedure)	OR
		 (.Symbol_Entry[SYM_Class] EQL SYM_K_Function)
	    THEN
		! Predefined routine
		!
		BEGIN
		.Type = DBG$K_NC_Instruction;
		STS$K_Success
		END
	    ELSE
		! Something else
		!
		BEGIN
		.Type = DBG$K_Other;
		STS$K_Success
		END);
	END;

    ! call the STA routine to get the Symid's Kind
    !
    DBG$STA_Symkind(.Symid, Kind);

    ! According to the value of Kind, return the appropriate type (named constant instruction,
    ! named constant non-instruction, or other)
    !
    RETURN
    	(CASE .Kind FROM RST$K_Kind_Minimum TO RST$K_Kind_Maximum OF
    	    SET

	[RST$K_Module, RST$K_Routine, RST$K_Block, RST$K_Label, RST$K_Line ] :
	    BEGIN
	    .Type = DBG$K_NC_Instruction;
	    STS$K_Success
	    END;

	[RST$K_Data]:
	    BEGIN
	    IF .Prim_Desc[PAS$PRIM_Kind] EQL DBG$K_Val_Literal
	    THEN
		.Type = DBG$K_NC_Other
	    ELSE
		.Type = DBG$K_Other;
	    STS$K_Success
	    END;

	[INRANGE] :
    	    BEGIN
    	    .Type = DBG$K_Other;
	    STS$K_Success
    	    END;

	    ! DBG$STA_Symkind died
	    !
	[RST$K_Invalid, OUTRANGE] :
	    Pascal_Bugcheck(PAS$K_RSTCODE);

    	    TES);

    END;

GLOBAL ROUTINE DBG$NPAS_GET_RVAL (Prim_Desc, Rvalue, Message_Vect) =

!++
! FUNCTIONAL DESCRIPTION:
!
! 	Uses a symbol's primary descriptor to obtain an rvalue for that symbol.
!	This rvalue is assumed by the debugger to be a signed longword integer,
!	except when the symbol has a type of instruction associated with it. In
!	this case, the rvalue is assumed to be an unsigned longword integer
!	representing the address of the first instruction associated with the
!	symbol.
!
!	This routine is used to materialize the rvalue of a symbol in the
!	following two cases:
!
!		1) When the GET_TYPE routine has indicated that a symbol
!		   has a type of named-constant and the value of the constant
!		   must be obtained.
!
!		2) When the special DEBUG fetch operator has been applied to
!		   a symbol in an address expression. Note that when the
!		   fetch operator has been applied to a routine or label
!		   variable, a type of instruction must be associated with the
!		   rvalue. This routine uses a special return to indicate
!		   this circumstance. In all other cases, the rvalue is assumed
!		   to be untyped.
!
! FORMAL PARAMETERS:
!
!	prim_desc	- A longword containing the address of a primary descriptor
!
!	rvalue		- The address of a longword to contain the object's rvalue
!
!	message_vect	- The address of a longword to contain the address of a
!			  message argument vector as described on page 4-119 of
!			  the VAX/VMS system reference, volume 1A
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	In case of a severe error return, a message argument vector must be 
!	constructed from dynamic storage and returned.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) - Success. The rvalue of the object described by the
!			    input primary descriptor is returned.
!
!	STS$K_WARNING (0) - Warning. The rvalue of the object described by the
!			    input primary descriptor is returned, but a type
!			    of instruction must be associated with it.
!
!	STS$K_SEVERE  (4) - Failure. The rvalue could not be obtained for the
!			    object, or the rvalue is not expressable within a longword.
!			    Message argument vector constructed and returned.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    EXTERNAL ROUTINE
    	PAS$_Arith_Fetch,						! Fetch a value
    	PAS$_Arith_Convert,						! Conversions
	PAS$_Read_Access		: NOVALUE,			! Check read access
    	PAS$_Get_Address		: NOVALUE;			! Get virtual address
    									! using Primary Descriptor

    EXTERNAL
    	PAS$_TRW_Integer	: BLOCK [,BYTE] FIELD(Type_Fields),
    	PAS$_TRW_Unsigned	: BLOCK [,BYTE] FIELD(Type_Fields);

    MAP
	Prim_Desc		: REF PAS$_Primary_Desc;		! a parameter passed in

    BIND
    	Message_Vector_Address	= .Message_Vect;

    LOCAL
    	Value_Address		: DBG$Address_Desc,
    	Type_Entry		: REF BLOCK [,BYTE] FIELD(Type_Fields),	! Pointer to a type table entry
    	Kind;								! RST kind of reference

    ! Set up error trap
    !
    ENABLE
    	PAS$_Error_Handler;

    PAS$_Message_Vector = Message_Vector_Address;


    ! Check validity
    !
    IF .Prim_Desc[DBG$B_Dhead_Lang] NEQ DBG$K_Pascal
    THEN
    	SIGNAL(DBG$_WRONGLANG);

    ! Get the address of the value
    !
    PAS$_Get_Address(.Prim_Desc, Value_Address, Type_Entry);

    ! Get kind of the value
    !
    IF .Prim_Desc[PAS$PRIM_Ident] EQLA 0
    THEN
	! Predefined
	!
	BEGIN
	BIND
	    Symbol_Entry	= .Prim_Desc[PAS$PRIM_Symbol]	: BLOCK [, BYTE] FIELD(Symbol_Fields);

	CASE .Symbol_Entry[SYM_Class] FROM SYM_K_Constant TO SYM_K_Line OF
	    SET
	[SYM_K_Constant,
	 SYM_K_Variable]	: Kind = RST$K_Data;
	[SYM_K_Procedure,
	 SYM_K_Function]	: Kind = RST$K_Routine;
	[SYM_K_Label]		: Kind = RST$K_Label;
	[SYM_K_Line]		: Kind = RST$K_Line;
	[INRANGE, OUTRANGE]	: Pascal_Bugcheck(PAS$K_ILLPRIM);
	    TES;
	END
    ELSE
	! RST entry
	!
	DBG$STA_SYMKIND(.Prim_Desc[PAS$PRIM_Ident], Kind);

    ! CASE on the Kind
    !
    CASE .Kind FROM RST$K_Kind_Minimum TO RST$K_Kind_Maximum OF
    	SET

    [RST$K_Module, RST$K_Routine, RST$K_Label, RST$K_Line] :
    	!
    	! Value_Address contains the address
    	! of the first byte of the reference.
    	!
    	.Rvalue = .Value_Address;

    [RST$K_Data] :
    	BEGIN

    	! Check the type
    	!
    	IF .Type_Entry NEQ 0
    	THEN
    	    IF .Type_Entry[TYP_Class] EQL TYP_K_Ordinal
    	    THEN
		BEGIN
		LOCAL
		    Condition_Status;

	    	! Get the value
	    	!
	    	IF (Condition_Status = PAS$_Arith_Fetch(.Type_Entry[ORD_Dtype], Value_Address,
	    		.Rvalue, .Type_Entry[TYP_Packed_Size]))
	    	THEN
	    	    IF  (.Type_Entry[ORD_Dtype] NEQ L_Int)	AND
	    		(.Type_Entry[ORD_Dtype] NEQ LU_Int)
	    	    THEN
	    		! Need to convert the value
	    		!
			BEGIN
			LOCAL
			    Target_Dtype;
	
			IF .Type_Entry[ORD_Unsigned]
			THEN
			    Target_Dtype = LU_Int
			ELSE
			    Target_Dtype = L_Int;
	
	    		Condition_Status = PAS$_Arith_Convert(.Type_Entry[ORD_Dtype], .Rvalue,
					.Target_Dtype, .Rvalue);
			END;

	    	IF NOT .Condition_Status
	    	THEN
		    ! Should never be an error
		    !
		    Pascal_Bugcheck(PAS$K_ARCONV);

		END

    	    ELSE
		BEGIN

		! Check read access
		!
		PAS$_Read_Access(Value_Address, .Prim_Desc[PAS$PRIM_Size]);

		! Get the first 32 bits of the value, zero-extending if necessary
		!
		IF .Prim_Desc[PAS$PRIM_Size] LEQU 32
		THEN
		    .Rvalue =  .(.Value_Address[DBG$L_Address_Byte_Addr])
				<.Value_Address[DBG$L_Address_Bit_Offset], .Prim_Desc[PAS$PRIM_Size], 0>
		ELSE
		    .Rvalue = ..Value_Address[DBG$L_Address_Byte_Addr];

		END

    	ELSE
    	    Pascal_Bugcheck(PAS$K_NILTYP);

    	END;

    [INRANGE] :
    	!
    	! Bad Primary Descriptor
    	!
    	Pascal_Bugcheck(PAS$K_ILLPRIM);

    [RST$K_Invalid, OUTRANGE] :
    	!
    	! DBG$STA_SYMKIND died
    	!
    	Pascal_Bugcheck(PAS$K_RSTCODE);

    	TES;

    ! If we've gotton this far, everything is go
    !
    STS$K_SUCCESS
    END;

GLOBAL ROUTINE DBG$NPAS_MAKE_VAL_DESC (Prim_Desc, Target_Flag, Value_Desc, Message_Vect) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Translates language specific primary descriptors to language specific
!	value descriptors. This routine should be able to use the symbol table
!	access routines and the information contained within the primary descriptor
!	to construct a descriptor which represents a 'value materialization' for
!	the object represented by the input primary descriptor.
!
!	Note that this routine must be able to use life-time, invocation, and
!	generation information to produce an accurate value descriptor of the
!	input object, or to decide when the value of an object cannot be
!	materialized (such as when the user's PC is not within the scope of
!	a dynamic variable).
!
!	Value descriptors produced by this routine must be marked (within the
!	type field of the language independent header block) as to whether
!	they are non-volatile (dsc$k_value_desc) or volatile (dsc$k_v_value_desc).
!	Volatile value descriptors will NOT be stored to represent '\', 'last value'.
!
!	Since value descriptors may be used as target descriptors ( as input to
!	dbg$npli_type_conv ), some provision must be made for incorporating
!	a value pointer field within the value descriptor. This type of value
!	descriptor is loosely defined as a volatile type.
!
! FORMAL PARAMETERS:
!
!	prim_desc	- A longword containing the address of a primary descriptor
!
!	target_flag	- A longword containing boolean true or false. When true,
!			  the caller is requesting the construction of a value
!			  descriptor that can be used as a target descriptor for
!			  the type converter. The resulting value must therefore
!			  contain a pointer to the value of the entity described
!			  by the input primary descriptor. Presumably, such a
!			  value descriptor will be of volatile type.
!
!	value_desc	- The address of a longword to contain the address of the
!			  resulting value descriptor
!
!	message_vect	- The address of a longword to contain the address of a
!			  message argument vector as described on page 4-119 of
!			  the VAX/VMS system reference, volume 1A
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Stack	- The Expression Stack
!	PAS$_Expr_Depth	- The current depth of the Expression Stack
!
! IMPLICIT OUTPUTS:
!
!	In case of a success return, the resulting value descriptor must be
!	constructed from dynamic storage and returned.
!
!	In case of a severe error return, a message argument vector must be
!	constructed from dynamic storage and returned.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) - Success. Value descriptor constructed and returned.
!
!	STS$K_SEVERE  (4) - Failure. Value descriptor not constructed. Message
!			    argument vector constructed and returned.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    EXTERNAL ROUTINE
    	PAS$_Construct_Value_Desc,		! Construct a value descriptor containing
    						! the address of a value, rather than a value
    	PAS$_Get_Address	: NOVALUE;	! Produce the virtual address of an
    						! object, given a primary descriptor

    EXTERNAL
    	PAS$_Expr_Depth		: LONG,		! Current Expression Stack Depth
    	PAS$_Expr_Stack		: BLOCKVECTOR [Expr_Stack_Depth, Expr_S_Entry, BYTE]
    		FIELD(Expression_Stack_Fields);	! Expression Stack

    MAP
	Prim_Desc		: REF PAS$_Primary_Desc;	! a parameter passed in

    BIND
	Message_Vector_Address = .Message_Vect;			! error message vector address

    LOCAL
	Value_Descriptor	: REF PAS$_Value_Desc,
    	Kind;						! RST Kind of object

    ! Enable error traps
    !
    ENABLE
    	PAS$_Error_Handler;

    PAS$_Message_Vector	= Message_Vector_Address;


    ! Make sure primary descriptor describes a data object
    !
    IF .Prim_Desc[PAS$PRIM_Ident] EQLA 0
    THEN
	! Predefined
	!
	BEGIN
	BIND
	    Symbol_Entry	= .Prim_Desc[PAS$PRIM_Symbol]	: BLOCK [, BYTE] FIELD(Symbol_Fields);

	CASE .Symbol_Entry[SYM_Class] FROM SYM_K_Constant TO SYM_K_Line OF
	    SET
	[SYM_K_Constant,
	 SYM_K_Variable]	: Kind = RST$K_Data;
	[SYM_K_Procedure,
	 SYM_K_Function]	: Kind = RST$K_Routine;
	[SYM_K_Label]		: Kind = RST$K_Label;
	[SYM_K_Line]		: Kind = RST$K_Line;
	[INRANGE, OUTRANGE]	: Pascal_Bugcheck(PAS$K_ILLPRIM);
	    TES;
	END
    ELSE
	! RST entry
	!
	DBG$STA_Symkind(.Prim_Desc[PAS$PRIM_Ident], Kind);

    IF .Kind NEQ RST$K_Data
    THEN
    	SIGNAL(DBG$_NOVALUE);

    ! Get the virtual address of the object and a pointer to its type
    !
    PAS$_Get_Address(.Prim_Desc, PAS$_Expr_Stack[0, Expr_Byte_Address], PAS$_Expr_Stack[0, Expr_Type]);

    ! Tell PAS$_Construct_Value_Desc that value
    ! is in first element of Expression Stack
    !
    PAS$_Expr_Depth = 0;

    ! Build a value descriptor
    !
    Value_Descriptor = PAS$_Construct_Value_Desc(.Target_Flag, True);

    ! Set it's size field to the size given in the Primary Descriptor
    !
    Value_Descriptor[PAS$VAL_Size] = .Prim_Desc[PAS$PRIM_Size];

    ! Return the address of the Value Descriptor
    !
    .Value_Desc = .Value_Descriptor;

    ! If we've gotton this far, everything is go
    !
    STS$K_SUCCESS
    END;

GLOBAL ROUTINE DBG$NPAS_GET_PAGES (Prim_Desc, Page_List, Message_Vect) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Uses a symbol's primary descriptor to construct a linked list of page
!	numbers which reflect those pages of storage in which the symbol's
!	rvalue is contained. Note that the pages may be non-contiguous.
!
!	A page number is represented by the high order 23 bits of a virtual 
!	address, with the low order 9 bits set to 0:
!
!	page = (virtual__address AND B'11111111111111111111111000000000')
!
! FORMAL PARAMETERS:
!
!	prim_desc	- A longword containing the address of a primary descriptor
!
!	page_list	- The address of a longword to contain the address of the
!			  head node in the page list. Nodes in the page list
!			  consist of blocks of two longwords each. The second
!			  longword of the node block contains a page number on
!			  which some portion of the symbol's rvalue resides. The
!			  first longword of the node block contains the address
!			  of the next node in the list. The last node in the list
!			  should contain a 0 in this link field.
!
!	message_vect	- The address of a longword to contain the address of
!			  a message argument vector as described on page 4-119
!			  of the VAX/VMS system reference, volume 1A
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	In case of a success return, the page list is constructed from dynamic
!	storage and returned.
!
!	In case of a severe error return, a message arguement vector is constructed
!	and returned.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) - Success. Page list constructed and returned.
!
!	STS$K_SEVERE  (4) - Failure. Page list not constructed. Message argument
!			    vector constructed and returned.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN
    MAP
	Prim_Desc		: REF PAS$_Primary_Desc;

    BIND
	Message_Vector_Address	= .Message_Vect;

    LOCAL
	Current_Block		: REF DBG$Link_Node,		! Pointer to current page number block
	Next_Block		: REF DBG$Link_Node,		! Pointer to next page number block
	Current_Page_Address,					! Address of first byte in current page
	End_Address,						! Address of last byte in the object
	Size,							! Size of the object in bytes
	L_Value			: DBG$Address_Desc;		! Object's L-value

    ! Get the object's L-Value
    !
    IF NOT DBG$NPAS_Get_Lval(.Prim_Desc, L_Value, Message_Vector_Address)
    THEN
	RETURN STS$K_SEVERE

    ELSE
	BEGIN
	! Round object size up to the nearest byte
	!
	Size = .Prim_Desc[PAS$PRIM_Byte_Size] + (.Prim_Desc[PAS$PRIM_Bit_Size] NEQ 0);

	IF .Size EQL 0
	THEN
	    Pascal_Bugcheck(PAS$K_ILLPRIM);

	!
	! Create the list
	! WARNING!!!	The following code assumes a page size of 512 bytes.
	!		The literal(s), mask value(s), and field reference(s)
	!		must be changed if the page size does

	Current_Block		= 0;
	Current_Page_Address	= .L_Value[DBG$L_Address_Byte_Addr] AND %X'FFFFFE00';	! Mask out low-order 9 bits
	End_Address		= .L_Value[DBG$L_Address_Byte_Addr] + .Size - 1;

	DO ! UNTIL .Current_Page_Address GTRA .End_Address

	    IF NOT DBG$NLIST_FREEZ(DBG$K_Link_Node_Size, Next_Block, Message_Vector_Address)
	    THEN
		! No space
		!
		RETURN STS$K_SEVERE

	    ELSE
		BEGIN

		! Link the block to the chain
		!
		Next_Block[DBG$L_Link_Node_Link]	= .Current_Block;
		Next_Block[DBG$L_Link_Node_Value]	= .Current_Page_Address;
		Current_Block				= .Next_Block;

		! Bump to next page
		!
		Current_Page_Address	= .Current_Page_Address + 512;
		END

	UNTIL .Current_Page_Address GTRA .End_Address;

	! Return address of the last block
	!
	.Page_List = .Current_Block;

	RETURN STS$K_SUCCESS;
	END;

    END;

GLOBAL ROUTINE DBG$NPAS_GET_LENGTH (Prim_Desc, Length, Message_Vect) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Uses a symbol's primary descriptor to obtain the length of the symbol's
!	rvalue. The length is to be given in bits. Lengths longer than 2 ** 32
!	must be truncated to this length.
!
!	The debugger assumes that rvalues refer to contiguous blocks of storage.
!	If this is not true for a given variable, this routine fails.
!
!	Length should reflect the maximum length for entities that may vary in
!	size, and include the length of a control word, if one is present.
!
!	If the value of the object can not be materialized by the Type Convertor
!	(DBG$NPLI_TYPE_CONV), this routine should return STS$K_INFO. This is
!	generally true for objects of aggregate type, e.g., PASCAL arrays and
!	record, PL/I structures.
!
! FORMAL PARAMETERS:
!
!	prim_desc	- A longword containing the address of a primary descriptor
!
!	length		- The address of a longword to contain an unsigned integer
!			  longword representing the symbol's rvalue length in bits
!
!	message_vect	- The address of a longword to contain the address of a
!			  message argument vector as described on page 4-119 of
!			  the VAX/VMS system reference, volume 1A
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	In case of a severe error return, a message argument vector is constructed
!	from dynamic storage and returned.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) - Success. Length of symbol's rvalue returned.
!
!	STS$K_INFO    (3) - Success. Length of the symbol's rvalue returned but
!			    the symbol refers to a value that the Type Convertor
!			    cannot materialize.
!
!	STS$K_SEVERE  (4) - Failure. No length returned. Message argument vector
!			    constructed and returned.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN
    EXTERNAL ROUTINE
	PAS$_Get_Address	: NOVALUE,			! Get virtual address. Used here to
								! get the type of the reference
	PAS$_String;						! Find out if a type is a string type

    MAP
	Prim_Desc		: REF PAS$_Primary_Desc;

    BIND
	Message_Vector_Address	= .Message_Vect;

    LOCAL
	Address_Desc		: DBG$Address_Desc,
	Type_Entry		: REF BLOCK [,BYTE] FIELD(Type_Fields);

    ! Enable error trap
    !
    ENABLE
	PAS$_Error_Handler;

    PAS$_Message_Vector = Message_Vector_Address;

    ! Check for Primary Descriptor
    !
    IF .Prim_Desc[DBG$B_Dhead_Type] NEQ DBG$K_Primary_Desc
    THEN
	Pascal_Bugcheck(PAS$K_ILLARG);

    ! Check for Pascal Primary Descriptor
    !
    IF .Prim_Desc[DBG$B_Dhead_Lang] NEQ DBG$K_Pascal
    THEN
	SIGNAL(DBG$_WRONGLANG);

    ! Check for data object (non-zero length)
    !
    IF .Prim_Desc[PAS$PRIM_Size] EQL 0
    THEN
	SIGNAL(DBG$_NOVALUE);

    ! Return the size of the object.
    !
    .Length = .Prim_Desc[PAS$PRIM_Size];

    ! Check the type
    !
    PAS$_Get_Address(.Prim_Desc, Address_Desc, Type_Entry);

    RETURN
	(IF .Type_Entry EQLA 0
	THEN
	    Pascal_Bugcheck(PAS$K_NILTYP)
	ELIF (.Type_Entry[TYP_Class] EQL TYP_K_Record)	OR
	     (.Type_Entry[TYP_Class] EQL TYP_K_File)
	THEN
	    STS$K_INFO
	ELIF
	    (IF (.Type_Entry[TYP_Class] EQL TYP_K_Array)	OR
		(.Type_Entry[TYP_Class] EQL TYP_K_Varying)
	    THEN
		NOT PAS$_String(.Type_Entry))
	THEN
	    STS$K_INFO
	ELSE
	    STS$K_SUCCESS);
    END;

GLOBAL ROUTINE DBG$NPAS_GET_SYMID (Desc, Symid_List, Message_Vect) =

!++
! FUNCTIONAL DESCRIPTION:
!	
!	Returns a list of symids contained within a language specific primary
!	or value descriptor.
!
! FORMAL PARAMETERS:
!
!	desc		- A longword containing the address of a language specific
!			  primary or value descriptor.
!
!	symid_list 	- The address of a longword to contain the address of 
!			  the first node in the symid list. Each node in the
!			  consists of a two longword block. The first longword
!			  is the link field and contains the address of the 
!			  next node in the list. This field is 0 for the last
!			  node in the list. The second longword contains the
!			  value of a symid. Each symid that appears in a 
!			  descriptor should appear once and only once in the
!			  symid list.
!
!	message_vect	- The address of a longword to contain the address of
!			  a message argument vector as described on page 4-119
!			  of the VAX/VMS system reference, volume 1A
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	In case of a severe error return, a message argument vector is constructed
!	from dynamic storage and returned.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) - Success. Symid list constructed and returned.
!
!	STS$K_SEVERE  (4) - Failure. No symid list returned. Message argument
!			    vector constructed and returned.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN
    EXTERNAL ROUTINE
	PAS$_Get_Type;					! Create a Type Table entry

    MAP
	Desc			: REF DBG$Dhead;

    BIND
	Message_Vector_Address	= .Message_Vect;

    LOCAL
	List_Head		: REF DBG$Link_Node;

    ! Enable error trap
    !
    ENABLE
	PAS$_Error_Handler;

    PAS$_Message_Vector = Message_Vector_Address;


    IF .Desc[DBG$B_Dhead_Lang] NEQ DBG$K_Pascal
    THEN
	SIGNAL(DBG$_WRONGLANG);

    ! Initialize list to the null list
    !
    .Symid_List = 0;

    IF	(.Desc[DBG$B_Dhead_Type] EQL DBG$K_Value_Desc)	OR
	(.Desc[DBG$B_Dhead_Type] EQL DBG$K_V_Value_Desc)
    THEN
	! Value Descriptor
	!
	BEGIN
	MAP
	    Desc		: REF PAS$_Value_Desc;

	IF .Desc[PAS$VAL_Type] NEQ 0
	THEN
	    ! Symid in the Value Descriptor
	    !
	    BEGIN

	    IF NOT DBG$NLIST_FREEZ(DBG$K_Link_Node_Size, .Symid_List, Message_Vector_Address)
	    THEN
		SIGNAL(DBG$_NOFREE);

	    List_Head				= ..Symid_List;
	    List_Head[DBG$L_Link_Node_Link]	= 0;
	    List_Head[DBG$L_Link_Node_Value]	= .Desc[PAS$VAL_Type];

	    END;

	END

    ELIF .Desc[DBG$B_Dhead_Type] EQL DBG$K_Primary_Desc
    THEN
	! Primary Descriptor
	!
	BEGIN
	MAP
	    Desc		: REF PAS$_Primary_Desc;

	BIND
	    Desc_Vector		= Desc[PAS$PRIM_Ident]		! Variable length part of Primary Descriptor
				: VECTOR;

	LOCAL
	    Current_Node	: REF DBG$Link_Node,		! Pointer to current symid list node
	    Current_Operand	: LONG,
	    Current_Type	: REF BLOCK [,BYTE] FIELD(Type_Fields),	! Pointer to current object type record
	    Kind		: LONG,				! RST Kind of object
	    Symbol_Class	: LONG,				! Pascal Symbol Class
	    Operation_Count	: LONG,				! Number of operations on the
								! Primary Descriptor to go
	    Symid		: LONG;				! Pointer to an RST entry

	! Initialize
	!
	Symid	= .Desc[PAS$PRIM_Ident];

	! Check for predefined symbol
	!
	IF .Symid EQLA 0
	THEN
	    RETURN STS$K_Success;

	! Create the first entry in the list
	!
	IF NOT DBG$NLIST_FREEZ(DBG$K_Link_Node_Size, .Symid_List, Message_Vector_Address)
	THEN
	    SIGNAL(DBG$_NOFREE);

	List_Head				= ..Symid_List;
	List_Head[DBG$L_Link_Node_Link]		= 0;
	List_Head[DBG$L_Link_Node_Value]	= .Symid;

	! Get the type of the object
	!
	DBG$STA_Symkind(.Symid, Kind);

	CASE .Kind FROM RST$K_Kind_Minimum TO RST$K_Kind_Maximum OF
	    SET

	    [RST$K_Module] :
		Symbol_Class = SYM_K_Procedure;

	    [RST$K_Routine] :
		Symbol_Class = SYM_K_Procedure;

	    [RST$K_Data] :
		SymboL_Class = SYM_K_Variable;

	    [RST$K_Label] :
		Symbol_Class = SYM_K_Label;

	    [RST$K_Line] :
		Symbol_Class = SYM_K_Line;

	    [INRANGE] :
		! Primary Interpreter generated an illegal Primary Descriptor
		!
		Pascal_Bugcheck(PAS$K_ILLPRIM);

	    [RST$K_Invalid, OUTRANGE] :
		! DBG$STA_Symkind died
		!
		Pascal_Bugcheck(PAS$K_RSTCODE);

	    TES;

	! If the symbol is not a data object (i.e., is of type instruction),
	! there is no more info in the Primary Descriptor
	!
	IF .Symbol_Class NEQ SYM_K_Variable
	THEN
	    RETURN STS$K_Success;

	! Get a pointer to the object's type
	!
	Current_Type = PAS$_Get_Type(.Symid, %REF(.Symbol_Class));

	! Loop thru the Primary Descriptor
	!
	Operation_Count = .Desc[PAS$PRIM_Operations];
	Current_Operand	= 0;
	Current_Node	= .List_Head;

	WHILE .Operation_Count GTRU 0 DO
	    BEGIN

	    ! CASE on the type class
	    !
	    CASE .Current_Type[TYP_Class] FROM TYP_K_Array TO TYP_K_Varying OF
		SET

		[TYP_K_Array] :
		    BEGIN

		    ! Point to next index
		    !
		    Current_Operand	= .Current_Operand + 1;

		    ! Get element type
		    !
		    Current_Type	= .Current_Type[ARR_Type];
		    END;

		[TYP_K_Varying] :
		    BEGIN

		    ! Point to the index
		    !
		    Current_Operand	= .Current_Operand + 1;

		    ! Get element type
		    !
		    Current_Type	= .Current_Type[VARY_Type];
		    END;

		[TYP_K_Pointer] :
		    BEGIN

		    ! Get base type
		    !
		    Current_Type	= .Current_Type[PTR_Type];
		    END;

		[TYP_K_File] :
		    BEGIN

		    ! Get base type
		    !
		    Current_Type	= .Current_Type[FIL_Type];
		    END;

		[TYP_K_Record] :
		    BEGIN
		    LOCAL
			Field_Entry	: REF BLOCK [,BYTE] FIELD(Keyword_Fields);

		    ! Point to field Symid
		    !
		    Current_Operand	= .Current_Operand + 1;

		    ! Create an entry in the list for it
		    !
		    IF NOT DBG$NLIST_FREEZ(DBG$K_Link_Node_Size, Current_Node[DBG$L_Link_Node_Link],
				.PAS$_Message_Vector)
		    THEN
			SIGNAL(DBG$_NOFREE);

		    Current_Node			= .Current_Node[DBG$L_Link_Node_Link];
		    Current_Node[DBG$L_Link_Node_Link]	= 0;
		    Current_Node[DBG$L_Link_Node_Value]	= .Desc_Vector[.Current_Operand];

		    ! Get the field type
		    !
		    Field_Entry = .Current_Type[REC_Fld_Head];
		    WHILE .Field_Entry NEQA 0 DO
			IF DBG$STA_Same_Dst_Object(.Field_Entry[FLD_Rst_Symid], .Desc_Vector[.Current_Operand])
			THEN
			    EXITLOOP
			ELSE
			    Field_Entry = .Field_Entry[FLD_Record_Link];

		    IF .Field_Entry EQLA 0
		    THEN
			Pascal_Bugcheck(PAS$K_ILLPRIM);

		    Current_Type	= .Field_Entry[FLD_Type];
		    END;

		[INRANGE, OUTRANGE] :
		    !
		    ! Illegal Primary Descriptor
		    !
		    Pascal_Bugcheck(PAS$K_ILLPRIM);

		TES;

	    Operation_Count	= .Operation_Count - 1;
	    END;

	END

    ELSE
	! Not a Primary or Value Descriptor
	!
	Pascal_Bugcheck(PAS$K_ILLARG);

    STS$K_Success
    END;

GLOBAL ROUTINE DBG$NPAS_COPY_DESC (Desc, Copy, Message_Vect) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Accepts as input a language specific primary or value descriptor
!	(constructed from listed storage)
!	and makes a copy of the descriptor out of non-listed storage. This 
!	non-volatile copy will be stored in conjunction with x-points and
!	current location.
!
!	This routine may use DBG$NCOPY to copy each portion of the 
!	descriptor that has been created from listed dynamic storage.
!
! FORMAL PARAMETERS:
!
!	desc			- The address of a language specifc primary or
!				  value descriptor
!
!	copy			- The address of a longword to contain the address
!				  of the non-volatile copy of the descriptor
!
!	message_vect		- The address of a longword to contain the address
!				  of a message argument vector for errors
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	On success, the non-volatile copy of a primary descriptor.
!
!	On failure, a message argument vector.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS	(1)	- Success. Copy constructed and returned.
!
!	STS$K_SEVERE    (4)	- Failure. Copy not produced. Message argument
!				  vector constructed and returned.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN
    MAP
	Desc			: REF DBG$Dhead;

    BIND
	Message_Vector_Address	= .Message_Vect;

    ! Copy the descriptor
    !
    DBG$NCOPY(.Desc, .Copy, Message_Vector_Address)

    END;

GLOBAL ROUTINE DBG$NPAS_FREE_DESC (Desc, Message_Vect) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Releases dynamic storage associated with a non-volatile copy of a 
!	language specific value or primary descriptor.
!	This routine accepts as input a copy of a primary or value
!	descriptor produced by DBG$NPAS_COPY_PRIM_DESC and calls the
!	routine DBG$NFREERELEASE to release each block of non-listed dynamic
!	storage contained within the descriptor.
!
! FORMAL PARAMETERS:
!
!	desc			- The address of a non-volatile primary or
!				  value descriptor
!
!	message_vect		- The address of a longword to contain the address
!				  of a message argument vector for errors
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	On failure, a message argument vector.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS   (1)	- Success. Storage for  descriptor released.
!
!	STS$K_SEVERE    (4)	- Failure. Storage for descriptor not released. Message
!				  argument vector constructed and returned.
!
! SIDE EFFECTS:
!
!	Dynamic memory is returned to the free storage pool.
!
!--

    BEGIN
    MAP
	Desc			: REF DBG$Dhead;

    BIND
	Message_Vector_Address	= .Message_Vect;

    ! Release the storage
    !
    DBG$NFREERELEASE(.Desc, Message_Vector_Address)

    END;

GLOBAL ROUTINE DBG$NPAS_LOG_PREDSUC (Input_Prim, Output_Prim, Symbol_Code,
					Message_Vect ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Produces a primary descriptor which specifies the logical successor
!	or predecessor to the symbol described by the input primary descriptor.
!	The definition of the passage from a primary to its successor/predecessor
!	is language dependent, but the successor/predecessor must lie within the
!	same aggregate as the input primary, such as cells within an array. 
!	Further guidelines are TBS.
!
! FORMAL PARAMETERS:
!
!	input_prim  -	A longword containing the address of a primary descriptor
!
!	output_prim -	The address of a longword to contain the address of a
!			primary descriptor which describes the logical predecessor
!			or successor to the input primary
!
!	symbol_code -	A longword containing an integer code which specifies
!			whether a successor or predecessor is required as follows:
!
!		dbg$k_predecessor (221)  - logical predecessor required
!
!		dbg$k_successor (222)    - logical successor required
!
!	message_vect -  The address of a longword to contain the address of a
!		      	message argument vector as described in the VAX/VMS
!			system reference, page 4-119, volume 1A
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	The primary descriptor representing the logical predecessor/successor
!	must be constructed from dynamic storage.
!
!	In case of a severe error return, a message argument vector is constructed
!	and returned.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) -  Success. Primary descriptor constructed for
!			     logical predecessor/successor and returned.
!
!	STS$K_SEVERE  (4) -  Failure. Primary descriptor for logical
!			     predecessor/successor not constructed. Message
!			     argument vector constructed and returned.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN
    EXTERNAL ROUTINE
	PAS$_Get_Address	: NOVALUE,	! Get a virtual address from a Primary Descriptor
	PAS$_Tag_Value,				! Get current value of a tag field
	PAS$_Get_Type;				! Create a Type Table entry

    MAP
	Input_Prim		: REF PAS$_Primary_Desc;

    BIND
	Message_Vector_Address	= .Message_Vect;

    LOCAL
	New_Prim		: REF PAS$_Primary_Desc,	! Address of new Primary Descriptor
	Desc_Vector		: REF VECTOR,

	Symbol_Entry		: REF BLOCK [,BYTE] FIELD(Symbol_Fields),
	Current_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
	Previous_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
    	Result_Type             : REF BLOCK [,BYTE] FIELD(Type_Fields),
	Field_Entry		: REF BLOCK [,BYTE] FIELD(Keyword_Fields),
	Current_Operand,
	Operation_Count,
	Symid,							! RST pointer
	Kind;							! RST kind of object

    ENABLE
	PAS$_Error_Handler;

    PAS$_Message_Vector	= Message_Vector_Address;


    ! Make sure language is Pascal
    !
    IF .Input_Prim[DBG$B_Dhead_Lang] NEQ DBG$K_Pascal
    THEN
	Pascal_Bugcheck(PAS$K_ILLARG);

    ! Make sure it's a Primary Descriptor
    !
    IF .Input_Prim[DBG$B_Dhead_Type] NEQ DBG$K_Primary_Desc
    THEN
	Pascal_Bugcheck(PAS$K_ILLARG);

    ! Initialize
    !
    Symid	= .Input_Prim[PAS$PRIM_Ident];

    ! Check for predefined objects. Such objects have no predecessor or successor.
    !
    IF .Symid EQLA 0
    THEN
	IF .Symbol_Code EQL DBG$K_Predecessor
	THEN
	    SIGNAL(DBG$_NOPRED)
	ELSE
	    SIGNAL(DBG$_NOSUCC);

    ! Get the type of the object
    !
    DBG$STA_Symkind(.Symid, Kind);

    CASE .Kind FROM RST$K_Kind_Minimum TO RST$K_Kind_Maximum OF
	SET

	[RST$K_Module,
	 RST$K_Routine,
	 RST$K_Label,
	 RST$K_Line] :
	    !
	    ! Cannot have predecessor/successor
	    !
	    IF .Symbol_Code EQL DBG$K_Predecessor
	    THEN
		SIGNAL(DBG$_NOPRED)
	    ELSE
		SIGNAL(DBG$_NOSUCC);

	[RST$K_Data] :
	    ;

	[INRANGE] :
	    ! Primary Interpreter generated an illegal Primary Descriptor
	    !
	    Pascal_Bugcheck(PAS$K_ILLPRIM);

	[OUTRANGE] :
	    ! DBG$STA_Symkind died
	    !
	    Pascal_Bugcheck(PAS$K_RSTCODE);

	TES;

    ! Allocate a new Primary Descriptor
    !
    IF NOT DBG$NLIST_FREEZ(ROUND_BYTE_TO_LONG_(.Input_Prim[DBG$W_Dhead_Length]), .Output_Prim,
			Message_Vector_Address)
    THEN
	SIGNAL(DBG$_NOFREE);

    ! Copy the old one into it
    !
    New_Prim	= ..Output_Prim;
    MOVEBYTE(.Input_Prim[DBG$W_Dhead_Length], .Input_Prim, .New_Prim);

    ! Get a pointer to the type
    !
    Current_Type	= PAS$_Get_Type(.Symid, %REF(SYM_K_Variable));

    ! Initialize for loop thru Primary Descriptor
    !
    Operation_Count	= .Input_Prim[PAS$PRIM_Operations];
    Current_Operand	= 0;
    Previous_Type	= 0;
    Field_Entry		= 0;
    Desc_Vector		= New_Prim[PAS$PRIM_Ident];

    WHILE .Operation_Count GTRU 0 DO
	BEGIN

	! Save the current type
	!
	Previous_Type	= .Current_Type;

	! CASE on the type class
	!
	CASE .Current_Type[TYP_Class] FROM TYP_K_Array TO TYP_K_Varying OF
	    SET

	    [TYP_K_Array] :
		BEGIN

		! Point to the next index
		!
		Current_Operand	= .Current_Operand + 1;

		! Get the element type
		!
		Current_Type	= .Current_Type[ARR_Type];
		END;

	    [TYP_K_Varying] :
		BEGIN

		! Point to the index
		!
		Current_Operand	= .Current_Operand + 1;

		! Get the element type
		!
		Current_Type	= .Current_Type[VARY_Type];
		END;

	    [TYP_K_Pointer] :
		BEGIN

		! Get the base type
		!
		Current_Type	= .Current_Type[PTR_Type];
		END;

	    [TYP_K_File] :
		BEGIN

		! Get the base type
		!
		Current_Type	= .Current_Type[FIL_Type];
		END;

	    [TYP_K_Record] :
		BEGIN

		! Point to the field Symid
		!
		Current_Operand	= .Current_Operand + 1;

		Field_Entry = .Current_Type[REC_Fld_Head];
		WHILE .Field_Entry NEQA 0 DO
		    IF DBG$STA_Same_Dst_Object(.Field_Entry[FLD_Rst_Symid], .Desc_Vector[.Current_Operand])
		    THEN
			EXITLOOP
		    ELSE
			Field_Entry = .Field_Entry[FLD_Record_Link];

		IF .Field_Entry EQLA 0
		THEN
		    Pascal_Bugcheck(PAS$K_ILLPRIM);

		Current_Type	= .Field_Entry[FLD_Type];
		END;

	    [INRANGE,
	     OUTRANGE] :
		! Illegal Primary Descriptor
		!
		Pascal_Bugcheck(PAS$K_ILLPRIM);

	    TES;

	Operation_Count	= .Operation_Count - 1;
	END;


    ! Check type of the result
    !
    IF
	(IF .Previous_Type NEQ 0
	THEN
	    IF .Previous_Type[TYP_Class] EQL TYP_K_Array
	    THEN

		IF .Symbol_Code EQL DBG$K_Predecessor
		THEN
		    ! Array Predecessor
		    !
		    BEGIN
		    LOCAL
			Index_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
			Index_Value,
			Current_Index;

		    Current_Index	= .Current_Operand;

		    DO
			BEGIN

			Index_Type = .Previous_Type[ARR_Itype];

			! Extract current index value
			!
			IF .BLK_B(.Index_Type[ORD_Type], ORD_Unsigned)
			THEN
			    Index_Value = .(Desc_Vector[.Current_Index])
					<0, .BLK_B(.Index_Type[ORD_Type], TYP_Packed_Size), 0>
			ELSE
			    Index_Value = .(Desc_Vector[.Current_Index])
					<0, .BLK_B(.Index_Type[ORD_Type], TYP_Packed_Size), 1>;

			! See if we can decrement it
			!
			IF
			    (IF .Index_Type[ORD_Unsigned]
			    THEN
				.Index_Value GTRU .Index_Type[ORD_Lower]
			    ELSE
				.Index_Value GTR .Index_Type[ORD_Lower])
			THEN
			    ! We can. Found a predecessor
			    !
			    BEGIN
			    Desc_Vector[.Current_Index]	= .Index_Value - 1;

			    INCR Operand FROM .Current_Index + 1 TO .Current_Operand DO
				BEGIN
				Previous_Type		= .Previous_Type[ARR_Type];
				Desc_Vector[.Operand]	= .BLK_B(.Previous_Type[ARR_Itype], ORD_Upper);
				END;

			    EXITLOOP;
			    END

			ELSE
			    ! Can't. Try the previous dimension
			    !
			    BEGIN
			    Previous_Type	= .Previous_Type[ARR_Up_Link];
			    Current_Index	= .Current_Index - 1;
			    END;

			END

		    UNTIL .Previous_Type EQLA 0;

		    .Previous_Type NEQA 0
		    END

		ELSE
		    ! Array Successor
		    !
		    BEGIN
		    LOCAL
			Index_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
			Index_Value,
			Current_Index;

		    Current_Index	= .Current_Operand;

		    DO
			BEGIN

			Index_Type = .Previous_Type[ARR_Itype];

			! Extract current index value
			!
			IF .BLK_B(.Index_Type[ORD_Type], ORD_Unsigned)
			THEN
			    Index_Value = .(Desc_Vector[.Current_Index])
					<0, .BLK_B(.Index_Type[ORD_Type], TYP_Packed_Size), 0>
			ELSE
			    Index_Value = .(Desc_Vector[.Current_Index])
					<0, .BLK_B(.Index_Type[ORD_Type], TYP_Packed_Size), 1>;

			! See if we can increment it
			!
			IF
			    (IF .Index_Type[ORD_Unsigned]
			    THEN
				.Index_Value LSSU .Index_Type[ORD_Upper]
			    ELSE
				.Index_Value LSS .Index_Type[ORD_Upper])
			THEN
			    ! We can. Found a successor
			    !
			    BEGIN
			    Desc_Vector[.Current_Index]	= .Index_Value + 1;

			    INCR Operand FROM .Current_Index + 1 TO .Current_Operand DO
				BEGIN
				Previous_Type		= .Previous_Type[ARR_Type];
				Desc_Vector[.Operand]	= .BLK_B(.Previous_Type[ARR_Itype], ORD_Lower);
				END;

			    EXITLOOP True;
			    END

			ELSE
			    ! Can't. Try the previous dimension
			    !
			    BEGIN
			    Previous_Type	= .Previous_Type[ARR_Up_Link];
			    Current_Index	= .Current_Index - 1;
			    END;

			END

		    UNTIL .Previous_Type EQLA 0;

		    .Previous_Type NEQA 0
		    END

	    ELIF .Previous_Type[TYP_Class] EQL TYP_K_Varying
	    THEN
		BEGIN
		LOCAL
		    Upper_Bound;

		! Find the current upper bound
		!
		Upper_Bound	= 0;

		IF .Symbol_Code EQL DBG$K_Predecessor
		THEN
		    IF .Desc_Vector[.Current_Operand] GTRU 0
		    THEN
			(Desc_Vector[.Current_Operand] = .Desc_Vector[.Current_Operand] - 1; True)

		    ELSE
			False

		ELSE
		    ! Successor
		    !
		    IF .Desc_Vector[.Current_Operand] LSSU .Upper_Bound
		    THEN
			(Desc_Vector[.Current_Operand] = .Desc_Vector[.Current_Operand] + 1; True)

		    ELSE
			False

		END

	    ELIF .Previous_Type[TYP_Class] EQL TYP_K_Record
	    THEN

		IF .Symbol_Code EQL DBG$K_Predecessor
		THEN
		    ! Record predecessor
		    !
		    IF
			(IF .Field_Entry NEQA 0
			THEN
			    IF .Field_Entry[FLD_Record_Link] NEQA 0
			    THEN

	! Got a field, check to see if it's in the current variant
	!
	IF .Field_Entry[FLD_Variant] EQLA .BLK_B(.Field_Entry[FLD_Record_Link], FLD_Variant)
	THEN
	    ! Got it
	    !
    	    Begin
    	    Result_type = .BLK_B(.Field_Entry[FLD_Record_Link], FLD_Type);
    	    If .BLK_B(.Field_Entry[FLD_Record_Link], FLD_Packed)
    	    THEN
    		New_Prim[PAS$Prim_Size] = .Result_Type[TYP_Packed_Size]
    	    ELSE
    		New_Prim[PAS$Prim_Size] = .Result_Type[TYP_Full_Size] * 8;
	    Desc_Vector[.Current_Operand] = .BLK_B(.Field_Entry[FLD_Record_Link], FLD_Rst_Symid);
    	    True
    	    End
	ELSE
	    ! Try to back up to an enclosing variant or record
	    !
	    BEGIN
	    LOCAL
		Variant_Entry	: REF BLOCK [,BYTE] FIELD(Type_Fields);

	    Variant_Entry	= .BLK_B(.Field_Entry[FLD_Variant], VAR_Variant);

	    WHILE .Variant_Entry NEQA 0 DO
		IF .Variant_Entry[VAR_Variant_Fixed_Fields] NEQA 0
		THEN
		    EXITLOOP
		ELSE
		    ! Check the next super-variant
		    !
		    Variant_Entry = .Variant_Entry[VAR_Variant];

	    IF .Variant_Entry EQLA 0
	    THEN
		! Backed up to record level
		!
		IF .BLK_B(.Field_Entry[FLD_Record], REC_Fixed_Fields) NEQA 0
		THEN
		    ! Got the last fixed field of the record
		    !
		    (Desc_Vector[.Current_Operand]
			= .BLK_B(.Field_Entry[FLD_Record], REC_Fixed_Fields, FLD_Rst_Symid); True)
		ELSE
		    ! No fixed fields, therefore no predecessor
		    !
		    False
	    ELSE
		! Got the last field of the enclosing super-variant
		!
		(Desc_Vector[.Current_Operand]
			= .BLK_B(.Variant_Entry[VAR_Variant_Fixed_Fields], FLD_Rst_Symid); True)
	    END

			    ELSE
				! We're at the first field in the record and can't back up
				!
				False

			)

		    THEN
			! Got it
			!
			True

		    ELSE
			! No fields in the record
			!
			False

		ELSE
		    ! Record Successor
		    !
		    IF
			(IF .Field_Entry NEQA 0
			THEN
			    ! Try for simple next field
			    !
			    IF .Field_Entry[FLD_Field_Link] NEQA 0
			    THEN

	! Got a field. find out if its in the current variant
	!
	IF .Field_Entry[FLD_Variant] EQLA .BLK_B(.Field_Entry[FLD_Field_Link], FLD_Variant)
	THEN
	    ! Got it
	    !
    	    Begin
    	    Result_type = .BLK_B(.Field_Entry[FLD_Field_Link], FLD_Type);
    	    If .BLK_B(.Field_Entry[FLD_Field_Link], FLD_Packed)
    	    THEN
    		New_Prim[PAS$Prim_Size] = .Result_Type[TYP_Packed_Size]
    	    ELSE
    		New_Prim[PAS$Prim_Size] = .Result_Type[TYP_Full_Size] * 8;
	    Desc_Vector[.Current_Operand] = .BLK_B(.Field_Entry[FLD_field_Link], FLD_Rst_Symid);
    	    True
    	    End
	ELSE
	    ! Look for a sub-variant
	    !
	    BEGIN
	    LOCAL
		Variant_Entry		: REF BLOCK [,BYTE] FIELD(Type_Fields),
		Try_Subvariant;

	    IF .Field_Entry[FLD_Variant] EQLA 0
	    THEN
		! Record level
		!
		Variant_Entry = .BLK_B(.Field_Entry[FLD_Record], REC_Var_Head)
	    ELSE
		! Variant
		!
		Variant_Entry = .BLK_B(.Field_Entry[FLD_Variant], VAR_Variant_Head);

	    ! See if the variant(s) have a tag field
	    !
	    IF
		(IF .Variant_Entry NEQA 0
		THEN
		    .Variant_Entry[VAR_Variant_Tag] NEQA 0)
	    THEN
		! Tag field
		!
		BEGIN
		LOCAL
		    Field_Address	: DBG$Address_Desc,
		    Record_Address	: DBG$Address_Desc,
		    Field_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),	! Redundant
		    Tag_Value,
		    Tag_Descriptor	: REF BLOCK [,BYTE] FIELD(Type_Fields);

		! Get the record address
		!
		PAS$_Get_Address(.Input_Prim, Field_Address, Field_Type);

		Record_Address[DBG$L_Address_Bit_Offset]
			= .Field_Address[DBG$L_Address_Bit_Offset] - .Field_Entry[FLD_Position];
		IF .Record_Address[DBG$L_Address_Bit_Offset] LSS 0
		THEN
		    BEGIN
		    LOCAL
			Rounded_Up_Bits;

		    Rounded_Up_Bits
			= (7 - .Record_Address[DBG$L_Address_Bit_Offset]) AND (NOT 7);
		    Record_Address[DBG$L_Address_Byte_Addr]
			= .Field_Address[DBG$L_Address_Byte_Addr] - (.Rounded_Up_Bits ^ -3);
		    Record_Address[DBG$L_Address_Bit_Offset]
			= .Rounded_Up_Bits + .Record_Address[DBG$L_Address_Bit_Offset];
		    END;

		! Fetch the current tag field value
		!
		Tag_Value = PAS$_Tag_Value(.Variant_Entry[VAR_Variant_Tag], Record_Address);

		! Scan the tags for the current variant
		!
		IF .Variant_Entry[VAR_Variant] EQLA 0
		THEN
		    Tag_Descriptor = .BLK_B(.Variant_Entry[VAR_Record], REC_Tag_Head)
		ELSE
		    Tag_Descriptor = .BLK_B(.Variant_Entry[VAR_Variant], VAR_Tag_Head);

		WHILE .Tag_Descriptor NEQA 0 DO
		    IF .Tag_Value EQL .Tag_Descriptor[VTAG_Constant]
		    THEN
			EXITLOOP
		    ELSE
			Tag_Descriptor = .Tag_Descriptor[VTAG_Constant_Link];

		IF .Tag_Descriptor EQLA 0
		THEN
		    BEGIN
		    SIGNAL(DBG$_ILLTAGVAL, BLK_B(.Variant_Entry[VAR_Variant_Tag], FLD_Name, NAM_Text), .Tag_Value);
		    Try_Subvariant	= True;
		    END
		ELSE
		    BEGIN
		    Variant_Entry	= .Tag_Descriptor[VTAG_Variant_Link];
		    Try_Subvariant	= False;
		    END
		END
	    ELSE
		Try_Subvariant = True;

	    IF .Try_Subvariant
	    THEN
		! Find a level with a sub-variant
		!
		WHILE .Variant_Entry NEQA 0 DO
		    IF .Variant_Entry[VAR_Variant_Fixed_Fields] NEQA 0
		    THEN
			EXITLOOP
		    ELSE
			Variant_Entry = .Variant_Entry[VAR_Variant_Head];

	    IF .Variant_Entry EQLA 0
	    THEN
		! Could not find a sub-variant
		!
		False
	    ELSE
		! Found a sub-variant. Find the first field in the sub-variant
		!
		BEGIN

		Field_Entry = .Variant_Entry[VAR_Variant_Fixed_Fields];
		REPEAT
		    IF .Field_Entry[FLD_Record_Link] EQLA 0
		    THEN
			EXITLOOP
		    ELIF .Field_Entry[FLD_Variant] NEQA .BLK_B(.Field_Entry[FLD_Record_Link], FLD_Variant)
		    THEN
			EXITLOOP
		    ELSE
			Field_Entry = .Field_Entry[FLD_Record_Link];

		Desc_Vector[.Current_Operand] = .Field_Entry[FLD_Rst_Symid];
		True
		END
	    END

			    ELSE
				! Last field in the record. No successor
				!
				False
			)

		    THEN
			! Got it
			!
			True

		    ELSE
			! No fields in the record.
			!
			False

	    ELSE
		! Not array, varying, or record
		!
		False
	ELSE
	    ! No previous type, therefore entire object
	    !
	    False
	)

    THEN
	! Got it
	!

    ELSE
	! Blew it
	!
	IF .Symbol_Code EQL DBG$K_Predecessor
	THEN
	    SIGNAL(DBG$_NOPRED)
	ELSE
	    SIGNAL(DBG$_NOSUCC);

    STS$K_SUCCESS
    END;

GLOBAL ROUTINE DBG$NPAS_COM_INIT : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Performs Pascal-specific initialization for a Debug command. This
!	routine is called before each command is executed.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	Lexical, Syntax, and Semantic Analysis storage
!
! IMPLICIT OUTPUTS:
!
!	Lexical, Syntax, and Semantic Analysis storage
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    EXTERNAL
	PAS$_Tables_Initialized	: BYTE UNSIGNED,	! False = Address offsets in Name,
							! Type, and Symbol tables need conversion

	PAS$_Lex_Clear0,		! Start of storage for scanner, tables, etc.
	PAS$_Lex_Clear1,		! End of storage for scanner, tables, etc.
	PAS$_Reswd_Clear0,		! Start of initial values for above storage
	PAS$_Reswd_Clear1;		! End of initial values for above storage

    EXTERNAL ROUTINE
	PAS$_Initialize_Tables	: NOVALUE;		! Initialize Name, Type, and
							! Symbol Table address offsets

    ! Fix addresses if this is the first call
    !
    IF NOT .PAS$_Tables_Initialized
    THEN
	PAS$_Initialize_Tables();

    ! Create static Name Table, etc. entries
    !
    CH$COPY(PAS$_Reswd_Clear1 - PAS$_Reswd_Clear0, PAS$_Reswd_Clear0,
	    0, PAS$_Lex_Clear1 - PAS$_Lex_Clear0, PAS$_Lex_Clear0);

    END;

!
!	Routines and data structures to build a reference string
!	for DBG$NPAS_SYMBOLIZE
!
LITERAL
	String_Vector_Size	= 256,				! Size of one string vector
	String_Block_Size	= String_Vector_Size + 4;

MACRO
	String_Block		= BLOCK [String_Block_Size, BYTE] %;

OWN
	String_First_Block	: String_Block,			! Initial (static) string block
	String_Current_Block	: REF String_Block,		! Pointer to current string block
	String_Byte,						! Current byte within block
	String_Blocks;						! Number of string blocks in
								! the chain minus 1
MACRO
	String_Vector(Index)	= String_Current_Block[(Index), 0, 8, 0] %,
								! Byte vector
	String_Next_Block	= String_Current_Block[String_Vector_Size, L_] %;
								! Pointer to next string block

ROUTINE Write_Character (Character) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Writes one character into the reference string buffer.
!	If the current block is full, a new one is allocated and
!
! FORMAL PARAMETERS:
!
!	Character	- The character to write
!
! IMPLICIT INPUTS:
!
!	String building static storage
!
! IMPLICIT OUTPUTS:
!
!	String building static storage
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN

    IF .String_Byte GEQU String_Vector_Size
    THEN
	! Need a new block
	!
	BEGIN
	LOCAL
	    New_Block	: REF String_Block;

	! Allocate storage for a new block
	!
	IF NOT DBG$NLIST_FREEZ(ROUND_BYTE_TO_LONG_(String_Block_Size), New_Block, .PAS$_Message_Vector)
	THEN
	    SIGNAL(DBG$_NOFREE);

	String_Blocks		= .String_Blocks + 1;
	String_Next_Block	= .New_Block;
	String_Current_Block	= .New_Block;
	String_Byte		= 0;
	END;

    ! Write the character into the buffer
    !
    String_Vector(.String_Byte)	= .Character;
    String_Byte			= .String_Byte + 1;

    END;

ROUTINE Write_Character_String (String_Length, String_Addr) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Write a character string to the string buffer.
!
! FORMAL PARAMETERS:
!
!	String_Length	- Length of string
!	String_Addr	- Address of string
!
! IMPLICIT INPUTS:
!
!	String building static storage
!
! IMPLICIT OUTPUTS:
!
!	String building static storage
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    MAP
	String_Addr	: REF VECTOR [,BYTE];

    INCR Character_Index FROM 0 TO .String_Length - 1 DO
	Write_Character(.String_Addr[.Character_Index]);

    END;

ROUTINE Write_Integer_String (Value, Is_Unsigned) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Writes a signed or unsigned integer to the string buffer
!
! FORMAL PARAMETERS:
!
!	Value		- Integer value to write
!	Is_Unsigned	- True = Value is unsigned
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    LITERAL
	Buffer_Length	= 11;

    LOCAL
	String_Length	: WORD UNSIGNED,
	String_Buffer	: VECTOR [Buffer_Length, BYTE],
	Integer_Desc	: BLOCK [8, BYTE],
	Control_Desc	: BLOCK [8, BYTE],
	Position;

    Integer_Desc[DSC$W_Length]	= Buffer_Length;
    Integer_Desc[DSC$B_Dtype]	= DSC$K_Dtype_T;
    Integer_Desc[DSC$B_Class]	= DSC$K_Class_S;
    Integer_Desc[DSC$A_Pointer]	= String_Buffer;

    Control_Desc[DSC$W_Length]	= 3;
    Control_Desc[DSC$B_Dtype]	= DSC$K_Dtype_T;
    Control_Desc[DSC$B_Class]	= DSC$K_Class_S;
    Control_Desc[DSC$A_Pointer]	=
			 	(IF .Is_Unsigned
				THEN
				    UPLIT BYTE(%ASCII '!UL')
				ELSE
				    UPLIT BYTE(%ASCII '!SL'));

    $FAO(Control_Desc, String_Length, Integer_Desc, .Value);

    IF CH$FAIL( (Position = CH$FIND_NOT_CH(.String_Length, String_Buffer, %C' ')) )
    THEN
	Position	= String_Buffer
    ELSE
	String_Length	= String_Buffer + .String_Length - .Position;

    Write_Character_String(.String_Length, .Position);
    END;

ROUTINE Copy_Reference (String_Desc, Reference) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Builds a contiguous reference string from the string buffer chain
!	and fills in String_Desc appropriately.
!
! FORMAL PARAMETERS:
!
!	String_Desc	- Address of a Vax-Standard string descriptor
!	Reference	- Address of an ASCIC character string to be used as
!			  the first part of the final reference string
!
! IMPLICIT INPUTS:
!
!	String building static storage
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    MAP
	String_Desc		: REF BLOCK [8, BYTE],
	Reference		: REF VECTOR [,BYTE];

    LOCAL
	Next_Block		: REF String_Block;

    ! Allocate space for the entire string
    !
    IF NOT DBG$NLIST_FREEZ(
		ROUND_BYTE_TO_LONG_((.String_Blocks * String_Vector_Size) + .String_Byte + .Reference[0]),
		String_Desc[DSC$A_Pointer], .PAS$_Message_Vector)
    THEN
	SIGNAL(DBG$_NOFREE);

    ! Set the string length in the descriptor
    !
    String_Desc[DSC$W_Length]	= (.String_Blocks * String_Vector_Size) + .String_Byte + .Reference[0];

    ! Copy the reference string
    !
    MOVEBYTE(.Reference[0], Reference[1], .String_Desc[DSC$A_Pointer]);

    ! Copy the string block chain, except the last block
    !
    String_Current_Block = String_First_Block;

    INCR String_Block_Count FROM 0 TO .String_Blocks - 1 DO
	BEGIN
	MOVEBYTE(String_Vector_Size, .String_Current_Block,
		.String_Desc[DSC$A_Pointer] + .Reference[0] + (.String_Block_Count * String_Vector_Size));

	String_Current_Block	= .String_Next_Block;
	END;

    ! Copy the (partial) last block
    !
    MOVEBYTE(.String_Byte, .String_Current_Block,
		.String_Desc[DSC$A_Pointer] + .Reference[0] + (.String_Blocks * String_Vector_Size));

    END;

GLOBAL ROUTINE DBG$NPAS_SYMBOLIZE (Prim_Desc, String_Desc, Message_Vect) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Produces a character string representation of the symbolic information
!	concerning a symbolic reference using a language specific primary
!	descriptor. This symbolic information includes pathname, invocation
!	number, and entity name. For example:
!
!		FOO\BAR 3\[LEXICAL_ENTITY]...\A
!
!	where FOO is the module name, BAR is the routine name, 3 is the routine
!	invocation number, and A is the variable name. 
!
!	Note that this routine must obtain an invocation number for routines
!	using information stored in the primary descriptor.
!
!
! FORMAL PARAMETERS:
!
!	prim_desc	- A longword containing the address of a language 
!			  specific primary descriptor
!
!	string_desc	- A longword containing the address of a VAX standard
!			  string descriptor with dsc$a_pointer and dsc$w_length
!			  fields of 0
!
!	message_desc	- The address of a longword to contain the address of a
!			  message argument vector as described on page 4-119 of
!			  the VAX/VMS system reference, volume 1A
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	On a successful return, the dsc$a_pointer and dsc$w_length fields of
!	string_desc are updated to reflect the ascii string representing the
!	symbolic information gleaned from the primary descriptor. Dynamic
!	storage must be allocated to contain the ascii string.
!
!	On a severe error return, a message argument vector is constructed from
!	dynamic storage and its address returned in message_vect.
!
! ROUTINE VALUE:
!
!	An unsigned longword integer condition code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) - Success. Ascii string descriptor updated to reflect
!			    recovered symbolic information.
!
!	STS$K_SEVERE  (4) - Failure. No symbolic information recovered. Message
!			    argument vector constructed and returned.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN
    EXTERNAL ROUTINE
	PAS$_Get_Type,							! Create a Type Table entry
	PAS$_Get_Value			: NOVALUE,			! Get value address from DBG$STA_Symvalue
    	PAS$_Get_Address		: NOVALUE;			! Get virtual address
    									! using Primary Descriptor

    MAP
	String_Desc	: REF BLOCK [8, BYTE],
	Prim_Desc	: REF PAS$_Primary_Desc;

    BIND
	Desc_Vector		= Prim_Desc[PAS$PRIM_Ident] : VECTOR,	! Variable length part
									! of Primary Descriptor
	Message_Vector_Address	= .Message_Vect;

    LOCAL
	Pathname		: REF PTH$Pathname,			! Pathname descriptor address
	Pathvector		: REF VECTOR,				! Vector of pointers to ASCIC strings
	Reference_String	: REF VECTOR [,BYTE],			! Address of module/routine
									! reference string
	Current_Name_Index,						! Index into pathname vector
	Current_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),	! Type of current object
	Current_Operand,						! Index into Primary Descriptor
	First_Index,							! True = Looking at
									! first array index
	Operation_Count,						! Number of operations to
									! perform on Primary Descriptor
	Symid;								! RST pointer

    ! Set up error trap
    !
    ENABLE
    	PAS$_Error_Handler;

    PAS$_Message_Vector = Message_Vector_Address;


    ! Make sure language is Pascal
    !
    IF .Prim_Desc[DBG$B_Dhead_Lang] NEQ DBG$K_Pascal
    THEN
    	SIGNAL(DBG$_WRONGLANG);

    ! Initialize the string descriptor
    !
    String_Desc[DSC$W_Length]	= 0;
    String_Desc[DSC$B_Dtype]	= DSC$K_DTYPE_T;
    String_Desc[DSC$B_Class]	= DSC$K_CLASS_S;
    String_Desc[DSC$A_Pointer]	= 0;

    ! Initialize
    !
    Symid           = .Prim_Desc[PAS$Prim_Ident];
    Operation_Count = .Prim_Desc[PAS$Prim_Operations];

    IF .Symid EQLA 0
    THEN
	! Predefined. The operation count is ALWAYS zero for such objects
	!
	Reference_String = BLK_B[.Prim_Desc[PAS$PRIM_Symbol], SYM_Name, NAM_Text]

    ELSE
	! RST entry
	!
	BEGIN
	LOCAL
	    New_Symid;

	! Check the current context of the user program, as opposed to the context
	! prevailing when the Primary Descriptor was created
	!
	New_Symid = DBG$STA_Symid_In_Frame(.Symid, .Prim_Desc[PAS$PRIM_Frame]);

	DBG$STA_Setcontext(.New_Symid);

	IF .New_Symid EQLA 0
	THEN
	    ! Definition frame not around any more
	    !
	    BEGIN

	    ! Get the pathname descriptor. This will be needed even though the definition frame is gone.
	    !
	    DBG$STA_Sympathname(.Symid, Pathname);

	    Reference_String = DBG$Address_String(Prim_Desc[PAS$PRIM_Address]);
	    END

	ELSE
	    ! Frame still around
	    !
	    BEGIN
	    LOCAL
		New_Address	: DBG$Address_Desc,
		New_Frame;

	    ! Get the pathname descriptor. This will be needed even if the
	    ! current address is not the same as the one in the Primary Descriptor
	    !
	    DBG$STA_Sympathname(.New_Symid, Pathname);

	    ! Get the current virtual address of the object
	    !
	    PAS$_Get_Value(.New_Symid, New_Address, 0, New_Frame);

	    ! Check if its the same as what's in the Primary Descriptor
	    !
	    IF	(.New_Address[DBG$L_Address_Byte_Addr] EQLA .Prim_Desc[PAS$PRIM_Byte_Address])	AND
		(.New_Address[DBG$L_Address_Bit_Offset] EQL .Prim_Desc[PAS$PRIM_Bit_Offset])	AND
		(.New_Frame EQLA .Prim_Desc[PAS$PRIM_Frame])
	    THEN
		! Same. Construct the module/routine/first data item reference string
		!
		DBG$NPATHDESC_TO_CS(.Pathname, Reference_String)
	    ELSE
		! Different. Produce an address
		!
		Reference_String = DBG$Address_String(Prim_Desc[PAS$PRIM_Address]);
	    END;

	END;

    ! Return if the Primary Descriptor describes a simple name
    !
    IF .Operation_Count EQL 0
    THEN
	BEGIN
	String_Desc[DSC$W_Length]	= .Reference_String[0];
	String_Desc[DSC$A_Pointer]	= Reference_String[1];

	RETURN STS$K_SUCCESS;
	END;

    ! Get the name vector address
    !
    Pathvector		= Pathname[PTH$A_Pathvector];

    ! Get a pointer to the type. The Primary Descriptor must describe
    ! a data object if .Operation_Count NEQ 0.
    !
    Current_Type	= PAS$_Get_Type(.Symid, %REF(SYM_K_Variable));

    ! Initialize string buffer
    !
    String_Current_Block	= String_First_Block;
    String_Byte			= 0;
    String_Blocks		= 0;

    ! Initialize interpretation loop
    !
    Current_Operand	= 0;
    Current_Name_Index	= .Pathname[PTH$B_Pathcnt] - 1;
    First_Index		= True;

    ! Loop thru the Primary Descriptor
    !
    WHILE .Operation_Count GTRU 0 DO
	BEGIN

	! CASE on the type class
	!
	CASE .Current_Type[TYP_Class] FROM TYP_K_Array TO TYP_K_Varying OF
	    SET

	    [TYP_K_Array] :
		BEGIN
		LOCAL
		    Index_Value,
		    Element_Type	: REF BLOCK [,BYTE] FIELD(Type_Fields),
		    Index_Base_Type	: REF BLOCK [,BYTE] FIELD(Type_Fields);

		Element_Type	= .Current_Type[ARR_Type];
		Index_Base_Type = .Current_Type[ARR_Itype];
		Index_Base_Type	= .Index_Base_Type[ORD_Type];

		! Point to the next index value
		!
		Current_Operand	= .Current_Operand + 1;

		! Load the index value
		!
		IF .Index_Base_Type[ORD_Unsigned]
		THEN
		    Index_Value = .(Desc_Vector[.Current_Operand])<0, .Index_Base_Type[TYP_Packed_Size], 0>
		ELSE
		    Index_Value = .(Desc_Vector[.Current_Operand])<0, .Index_Base_Type[TYP_Packed_Size], 1>;

		! Write the '['
		!
		IF .First_Index
		THEN
		    BEGIN
		    Write_Character(%C'[');
		    First_Index = False;
		    END
		ELSE
		    Write_Character(%C',');

		! Write the index value
		!
		SELECTONE .Index_Base_Type OF
		    SET

		    [PAS$_TRW_Char] :
			BEGIN
			Write_Character(%C'''');

			IF (.Index_Value GEQU %C' ')	AND
			   (.Index_Value LEQU 126)
			THEN
			    Write_Character(.Index_Value)
			ELSE
			    BEGIN
			    Write_Character(%C'(');
			    Write_Integer_String(.Index_Value, True);
			    Write_Character(%C')');
			    END;

			Write_Character(%C'''');
			END;

		    [PAS$_TRW_Integer] :
			Write_Integer_String(.Index_Value, False);

		    [PAS$_TRW_Unsigned] :
			Write_Integer_String(.Index_Value, True);

		    [OTHERWISE] :
			!
			! Enumerated type
			!
			BEGIN
			LOCAL
			    Symbol_Entry	: REF BLOCK [,BYTE] FIELD(Symbol_Fields);

			! Scan the Symbol Table chain for the value
			!
			Symbol_Entry	= .Index_Base_Type[ORD_Enum_Element];

			WHILE .Symbol_Entry NEQ 0 DO
			    IF .Symbol_Entry[CON_Literal] EQL .Index_Value
			    THEN
				! Found it
				!
				BEGIN
				LOCAL
				    Name_Entry	: REF BLOCK [,BYTE] FIELD(Nam_Fields);

				Name_Entry = .Symbol_Entry[SYM_Name];
				Write_Character_String(.Name_Entry[NAM_Length], Name_Entry[NAM_First_Char]);
				EXITLOOP;
				END
			    ELSE
				Symbol_Entry = .Symbol_Entry[CON_Next];

			IF .Symbol_Entry EQL 0
			THEN
			    ! Didn't find the element
			    !
			    SIGNAL(DBG$_BADSUBSCR, .Index_Value);

			END;

		    TES;

		Current_Type	= .Element_Type;
		END;

	    [TYP_K_Varying] :
		BEGIN

		IF NOT .First_Index
		THEN
		    ! Last thing in the reference was a subscript.
		    ! Write the ']'
		    !
		    BEGIN
		    Write_Character(%C']');
		    First_Index	= True;
		    END;

		! Point to the index value
		!
		Current_Operand	= .Current_Operand + 1;

		! Write the '['
		!
		Write_Character(%C'[');

		! Write the index value
		!
		Write_Integer_String(.Desc_Vector[.Current_Operand], True);

		! Write the ']'
		!
		Write_Character(%C']');

		Current_Type	= .Current_Type[VARY_Type];
		END;

	    [TYP_K_Pointer] :
		BEGIN

		IF NOT .First_Index
		THEN
		    ! Last thing in the reference was a subscript.
		    ! Write the ']'
		    !
		    BEGIN
		    Write_Character(%C']');
		    First_Index	= True;
		    END;

		! Write an '^' into the reference string
		!
		Write_Character(%C'^');

		! Get the base type
		!
		Current_Type	= .Current_Type[PTR_Type];
		END;

	    [TYP_K_File] :
		BEGIN

		IF NOT .First_Index
		THEN
		    ! Last thing in the reference was a subscript.
		    ! Write the ']'
		    !
		    BEGIN
		    Write_Character(%C']');
		    First_Index	= True;
		    END;

		! Write an '^' into the reference string
		!
		Write_Character(%C'^');

		! Get the base type
		!
		Current_Type	= .Current_Type[FIL_Type];
		END;

	    [TYP_K_Record] :
		BEGIN
		LOCAL
		    Field_Entry		: REF BLOCK [,BYTE] FIELD(Keyword_Fields),
		    Name_Entry		: REF BLOCK [,BYTE] FIELD(NAM_Fields);

		IF NOT .First_Index
		THEN
		    ! Last thing in the reference was a subscript.
		    ! Write the ']'
		    !
		    BEGIN
		    Write_Character(%C']');
		    First_Index	= True;
		    END;

		! Point to the field Symid
		!
		Current_Operand	= .Current_Operand + 1;

		! Write the '.'
		!
		Write_Character(%C'.');

		! Find the field block
		!
		Field_Entry = .Current_Type[REC_Fld_Head];
		WHILE .Field_Entry NEQA 0 DO
		    IF DBG$STA_Same_Dst_Object(.Field_Entry[FLD_Rst_Symid], .Desc_Vector[.Current_Operand])
		    THEN
			EXITLOOP
		    ELSE
			Field_Entry = .Field_Entry[FLD_Record_Link];

		IF .Field_Entry EQLA 0
		THEN
		    Pascal_Bugcheck(PAS$K_ILLPRIM);

		Name_Entry = .Field_Entry[FLD_Name];
		IF .Name_Entry EQLA 0
		THEN
		    Pascal_Bugcheck(PAS$K_NILNAM);

		Write_Character_String(.Name_Entry[NAM_Length], Name_Entry[NAM_First_Char]);

		! Get the field type
		!
		Current_Type	= .Field_Entry[FLD_Type];
		END;

	    [INRANGE,
	     OUTRANGE] :
		!
		! Bad Primary Descriptor
		!
		Pascal_Bugcheck(PAS$K_ILLPRIM);

	    TES;

	Operation_Count	= .Operation_Count - 1;
	END;

    IF NOT .First_Index
    THEN
	! Last thing in the reference was a subscript.
	! Write the ']'
	!
	BEGIN
	Write_Character(%C']');
	First_Index	= True;
	END;

    ! Copy the pathname into dynamic storage
    !
    Copy_Reference(.String_Desc, .Reference_String);

    ! If we've gotton this far, all ok
    !
    STS$K_SUCCESS
    END;

END
ELUDOM
