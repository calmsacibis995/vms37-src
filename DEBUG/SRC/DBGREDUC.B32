MODULE DBGREDUC ( IDENT = 'V03-000') = 
BEGIN 
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!++
! FACILITY:
!	DEBUG
!
! ABSTRACT:
!	This module contains the common reduction routines used by the
!	language specific parsers in DBGFOR, DBGBP2, DBGBLI, DBGMAR.
!
! ENVIRONMENT:
!	VAX/VMS
!
! VERSION:
!    	3.0
! 
! HISTORY:
!	Author: ???
!	Originally a require file containing macros; the macros were
!	made into procedures and this was turned into a module on
!	Sep 23 1981 - R. Title
!
!+
! MODIFIED BY:
!	R. Title 6 Jul 1981 - changed SAVE_TYPE routine to recognize new
!			      debugger types f_float, d_float, g_float
!			      h_float, quadword, octa_word.
!	R. Title 13 Nov 1981 - added routines DBG$PUSH_NEST_STACK and
!			       DBG$POP_NEST_STACK to handle nested 
!			       subscript expressions in FORTRAN and BASIC
!-

! TABLE OF CONTENTS:
!
FORWARD ROUTINE
    dbg$division : NOVALUE,
    dbg$logical_or : NOVALUE,
    dbg$logical_and : NOVALUE,
    dbg$exclusive_or : NOVALUE,
    dbg$pop_stack : NOVALUE,
    dbg$negation : NOVALUE,
    dbg$complement : NOVALUE,
    dbg$bli_complement : NOVALUE,
    dbg$mac_indirection : NOVALUE,
    dbg$ftn_indirection : NOVALUE,
    dbg$equivalence : NOVALUE,
    dbg$extract_bits : NOVALUE,
    dbg$add_module : NOVALUE,
    dbg$add_dimension : NOVALUE,
    dbg$char_substring : NOVALUE,
    dbg$save_name : NOVALUE,
    dbg$set_overr_step : NOVALUE,
    dbg$set_overr_mode : NOVALUE,
    dbg$set_dec_overs : NOVALUE,
    dbg$set_line_dec : NOVALUE,
    dbg$set_over_noadr : NOVALUE,
    dbg$set_over_adr : NOVALUE,
    dbg$get_step_count : NOVALUE,
    dbg$translate_name : NOVALUE,
    dbg$reduce_array : NOVALUE,
    dbg$save_lang_name : NOVALUE,
    dbg$reduce_pathname : NOVALUE,
    dbg$redu_path_addr : NOVALUE,
    dbg$reduce_label : NOVALUE,
    dbg$save_ascii_leng : NOVALUE,
    dbg$set_local_type : NOVALUE,
    dbg$set_default_typ : NOVALUE,
    dbg$set_over_typ : NOVALUE,
    dbg$save_type : NOVALUE,
    dbg$reduce_bli_path : NOVALUE,
    dbg$add_access_act : NOVALUE,
    dbg$bli_indirection : NOVALUE,
    dbg$check_size_fld,
    dbg$check_ext_fld : NOVALUE,
    dbg$push_nest_stack: NOVALUE,
    dbg$pop_nest_stack: NOVALUE;

! REQUIRE FILES
!
REQUIRE 'SRC$:DBGPROLOG.REQ';
REQUIRE 'SRC$:DBGGEN.REQ';
REQUIRE 'SRC$:COMTER.REQ';
REQUIRE 'SRC$:SCALIT.REQ';
REQUIRE 'SRC$:BSTRUC.REQ';
REQUIRE 'SRC$:SYSSER.REQ';

EXTERNAL ROUTINE
	dbg$get_bounds : NOVALUE,	! Calculate array bounds
	dbg$add_arg,			! Add arguments to the command arg list
	dbg$bld_num_pth,		! Builds numeric pathnames.
	dbg$break_setup,		! Collects args for breakpoint setup
	dbg$build_path,			! Builds a path name
	dbg$path_to_val,		! Evaluates pathnames
	dbg$cancel_parm,		! Arguments to a CANCEL command
    	dbg$rst_type,
	dbg$can_switch,			! Sets context bits for cancel command
	dbg$find_module,		! Finds the RST address of a module
	dbg$freez,			! Allocates a block of free storage
	dbg$getarrayadr,		! Gets absolute address of array element
	dbg$init_modes,			! Initializes I/O modes
	dbg$perform_cmd,		! Executes a complete command
	dbg$read_access,		! Checks read access to a page
	dbg$sav_pth_nam,		! places a pathname in the scope list
	dbg$set_mod_lvl,		! Resets modes to a specified level
	dbg$set_new_mod,		! Sets a mode in current level
	dbg$set_overs,			! Sets override or local mode
	dbg$show_param,			! Collects args to SHOW command
	dbg$trans_name,			! Translates a name into a binary value
	dbg$set_stp_lvl,		! Sets level of STEP
	dbg$set_new_stp,		! Sets a new STEP value
	dbg$get_bpt_act,		! Pick up BPT action string
	dbg$extract_str;		! Pick up delimited strings


EXTERNAL

	dbg$gb_mod_ptr : REF VECTOR [,BYTE],	! Current mode
	dbg$gw_length,				! temporarily holds user given length
	dbg$gw_loclngth,			! holds command override length
	dbg$gw_dfltleng,			! holds user defined default length
	dbg$gl_context : BITVECTOR,		! Context word	
	dbg$gl_dimenlst : VECTOR,		! Holds dimension elements for array
    	dbg$gl_nest_stack: VECTOR,		! A stack of subscript lists, used
    						!    during evaluation of 
    						!    expressions with nested subscripts. 
    	dbg$gl_nest_level,			! The level of nesting of subscript
    						!    expressions
	dbg$gl_asci_len,			! Holds length of ascii variables
	dbg$gl_head_lst,			! Head of command arg list
	dbg$gl_type,				! temporarily holds user given type 
	dbg$gl_loctyp,				! holds command override type
    	dbg$gw_gbllngth : WORD,
    	dbg$gl_gbltyp,
	dbg$gl_dflttyp,				! holds user defined default type
    	dbg$deposit_lengvec : VECTOR [,BYTE],	! Table of lengths
    	dbg$gl_stk : semantic_stack,
	dbg$gl_list : VECTOR;			! Holds breakpoint arguments


!++
! The following routines are simple actions to perform with reductions to
! the grammar. 
!--




    	!++
	! The division routine divides the value at the top of the stack
	! by the value at the third position in the stack and places
	! the result at the top of the stack.
	!--
GLOBAL ROUTINE dbg$division (semsp) : NOVALUE =
		BEGIN
		IF .dbg$gl_stk [.semsp + 2, stk$v_val1] EQL 0
		THEN SIGNAL (dbg$_divbyzero);
		dbg$gl_stk [.semsp, stk$v_val1] = .dbg$gl_stk [.semsp, stk$v_val1]
		 / .dbg$gl_stk [.semsp + 2, stk$v_val1];
		END;



	!++
	! The logical_or routine applies the OR operator to the values found
	! in the first and third position on the stack and places the
	! result on the top of the stack.
	!--
GLOBAL ROUTINE dbg$logical_or (semsp) : NOVALUE =
		BEGIN

		IF (.dbg$gl_stk [.semsp, stk$v_type] EQL dsc$k_dtype_l) AND
		(.dbg$gl_stk [.semsp + 2, stk$v_type]  EQL dsc$k_dtype_l)
		THEN
			dbg$gl_stk [.semsp, stk$v_val1] = .dbg$gl_stk [.semsp, stk$v_val1]
			 OR .dbg$gl_stk [.semsp + 2, stk$v_val1]
		ELSE SIGNAL (dbg$_integer);

		END;


	!++
	! The logical_and routine applies the AND operator to the values
	! found in the first and third position on the stack and places
	! the result on the top of the stack.
	!--
GLOBAL ROUTINE dbg$logical_and (semsp)  : NOVALUE =
		BEGIN

		IF (.dbg$gl_stk [.semsp, stk$v_type] EQL dsc$k_dtype_l) AND
			(.dbg$gl_stk [.semsp + 2, stk$v_type] EQL dsc$k_dtype_l)
		THEN
			dbg$gl_stk [.semsp, stk$v_val1] = .dbg$gl_stk [.semsp, stk$v_val1]
			 AND .dbg$gl_stk [.semsp + 2, stk$v_val1]
		ELSE SIGNAL (dbg$_integer);

		END;


	!++
	! The exclusive or routine performs an exclusive or operation on
	! the values found in the first and third positions on the stack,
	! and puts the result on the top of the stack.o
	!--
GLOBAL ROUTINE dbg$exclusive_or (semsp)  : NOVALUE =
		BEGIN

		IF (.dbg$gl_stk [.semsp, stk$v_type] EQL dsc$k_dtype_l) AND
			(.dbg$gl_stk [.semsp + 2, stk$v_type] EQL dsc$k_dtype_l)
		THEN
			dbg$gl_stk [.semsp, stk$v_val1] = .dbg$gl_stk [.semsp, stk$v_val1]
			 XOR .dbg$gl_stk [.semsp + 2, stk$v_val1]
		ELSE SIGNAL (dbg$_integer);

		END;

	!++
	! The pop_stack routine takes the value found in the second
	! position on the stack and places it on the top of the stack.
	!--
GLOBAL ROUTINE dbg$pop_stack (semsp)  : NOVALUE =
		BEGIN
		dbg$gl_stk [.semsp, stk$v_val1]		= .dbg$gl_stk [.semsp + 1, stk$v_val1];
		dbg$gl_stk [.semsp, stk$v_val2]		= .dbg$gl_stk [.semsp + 1, stk$v_val2];
		dbg$gl_stk [.semsp, stk$v_type]		= .dbg$gl_stk [.semsp + 1, stk$v_type];
		dbg$gl_stk [.semsp, stk$v_nt_ptr]	= .dbg$gl_stk [.semsp + 1, stk$v_nt_ptr];
		dbg$gl_stk [.semsp, stk$v_index]		= .dbg$gl_stk [.semsp + 1, stk$v_index];
		dbg$gl_stk [.semsp, stk$v_offset]	= .dbg$gl_stk [.semsp + 1, stk$v_offset];
		dbg$gl_stk [.semsp, stk$v_pos]		= .dbg$gl_stk [.semsp + 1, stk$v_pos];
		dbg$gl_stk [.semsp, stk$v_size]		= .dbg$gl_stk [.semsp + 1, stk$v_size];
		dbg$gl_stk [.semsp, stk$v_ext]		= .dbg$gl_stk [.semsp + 1, stk$v_ext];
		dbg$gl_stk [.semsp, stk$v_ref]		= .dbg$gl_stk [.semsp + 1, stk$v_ref];
		dbg$gl_stk [.semsp, stk$v_immed]		= .dbg$gl_stk [.semsp + 1, stk$v_immed];
		dbg$gl_stk [.semsp, stk$v_args]		= .dbg$gl_stk [.semsp + 1, stk$v_args];
		dbg$gl_stk [.semsp, stk$v_fldrf]		= .dbg$gl_stk [.semsp + 1, stk$v_fldrf];
		dbg$gl_stk [.semsp, stk$v_dot]		= .dbg$gl_stk [.semsp + 1, stk$v_dot];
		dbg$gl_stk [.semsp, stk$v_struc]		= .dbg$gl_stk [.semsp + 1, stk$v_struc];
		END;


	!++
	! The negation routine negates the value found in the second
	! position on the stack and places the result on the top of
	! the stack.
	!--
GLOBAL ROUTINE dbg$negation (semsp)  : NOVALUE =
		BEGIN
		dbg$pop_stack (.semsp);
		dbg$gl_stk [.semsp, stk$v_val1] = - .dbg$gl_stk [.semsp, stk$v_val1];

		END;


	!++
	! The complement routine applies the NOT operator to the value
	! found in the second position on the stack and places the
	! result on the top of the stack.
	!--
GLOBAL ROUTINE dbg$complement (semsp)  : NOVALUE =
		BEGIN

		IF .dbg$gl_stk [.semsp + 1, stk$v_type] EQL dsc$k_dtype_l
		THEN
			BEGIN
			dbg$pop_stack (.semsp);
			dbg$gl_stk [.semsp, stk$v_val1] = NOT .dbg$gl_stk [.semsp, stk$v_val1];
			END

		ELSE SIGNAL (dbg$_integer);

		END;



	!++
	! THE BLI_COMPLEMENT routine DOES THE SAME THING AS THE COMPLEMENT routine
	! EXCEPT THAT NO TYPE CHECKING OF THE SOURCE IS DONE.
	!--
GLOBAL ROUTINE dbg$BLI_COMPLEMENT (semsp)  : NOVALUE =
		BEGIN
		dbg$POP_STACK (.semsp);
		DBG$GL_STK [.semsp, STK$V_VAL1] = NOT .DBG$GL_STK [.semsp, STK$V_VAL1];
		END;



	!++
	! The mac_indirection routine considers the value at the second position
	! in the stack to be an address. It takes the contents of that
	! address and places it on the top of the stack.
	! It moves the data type of the item to the top of the second
	! stack.
	!--
GLOBAL ROUTINE dbg$mac_indirection (semsp)  : NOVALUE =
		BEGIN
		EXTERNAL routine
			 dbg$read_access;	! probe read accessibility


		dbg$read_access (.dbg$gl_stk [.semsp + 1, stk$v_val1], %UPVAL);
		dbg$pop_stack (.semsp);
		dbg$gl_stk [.semsp, stk$v_val1] = .(.dbg$gl_stk [.semsp, stk$v_val1])
						   <0, .dbg$gb_mod_ptr[mode_length] * %BPUNIT>;
		DBG$GL_STK [.semsp, STK$V_DOT] = 1;

		END;


	!++
	! The ftn_indirection routine considers the value at the top of
	! the stack to be an address.  If the mode is set to indicate
	! that indirection is desired, the routine takes the contents of that
	! address and replaces it on the top of the stack.  Note that if
	! the indirection is NOT done, the stk type still reflects
	! the rvalue (on stk), not the lvalue.  This is necessary 
	! because DEPOSIT does not want the indirection, but does want
	! the type to be set (left) as though it did.
	!--
GLOBAL ROUTINE dbg$ftn_indirection (semsp) : NOVALUE  =
		BEGIN
		EXTERNAL routine
			 dbg$read_access;	! probe read accessibility		

		!+
		! Indirection is not performed if "mode_immediate" is false
		! as in "EVALUATE/ADDR X".
		!-
		IF NOT .dbg$gb_mod_ptr[mode_immediate]
		THEN
			BEGIN
    			LOCAL
    			    type,
    			    length,
    			    value;

			! Be sure not to fault if the
			! indirection would fail.

			dbg$read_access (.dbg$gl_stk [.semsp, stk$v_val1], %UPVAL);

    			! Get the type of the data if possible

    			IF .dbg$gl_stk[.semsp,stk$v_nt_ptr] NEQ 0
    			THEN
    			    BEGIN
    			    type = dbg$rst_type(.dbg$gl_stk[.semsp,stk$v_nt_ptr]);
    			    IF .type GEQ 0 AND .type LEQ dsc$k_dtype_highest
    			    THEN
    				length = .dbg$deposit_lengvec[.type]
    			    ELSE
    				length = 4; ! Use 4 bytes as default if
    					    ! we cannot determine type
    			    END
    			ELSE
    			    length = 4; ! default
    			! Convert bytes to bits
    			length = .length * 8;

    			! Get the longword value at the address
    			value = ..dbg$gl_stk[.semsp,stk$v_val1]; 

    			! Put back on the stack the appropriate number of
    			! bits.
			dbg$gl_stk [.semsp, stk$v_val1] = .value<0,.length,1>;
			END;
		END;


	!++
	! The equivalence routine applies the EQV operator to the values found
	! in the first and third position on the stack and places the
	! result on the top of the stack.
	!--
GLOBAL ROUTINE dbg$equivalence (semsp) : NOVALUE  =
		BEGIN

		IF (.dbg$gl_stk [.semsp, stk$v_type] EQL dsc$k_dtype_l) AND
			(.dbg$gl_stk [.semsp + 2, stk$v_type] EQL dsc$k_dtype_l)
		THEN
			dbg$gl_stk [.semsp, stk$v_val1] = .dbg$gl_stk [.semsp, stk$v_val1]
			 EQV .dbg$gl_stk [.semsp + 2, stk$v_val1]
		ELSE SIGNAL (dbg$_integer);

		END;


	!++
	! The extract_bits routine extracts a bit field from the value
	! on the top of the stack and places that bit field on the
	! top of the stack. The starting bit number of the bit field
	! is in the fifth position on the stack. The end position
	! of the bit field is in the third position. After the value
	! is extracted, the mode is reset to override level.
	!--
GLOBAL ROUTINE dbg$extract_bits (semsp) : NOVALUE  =
		BEGIN
		EXTERNAL routine
			dbg$init_modes : NOVALUE,	! sets modes to specified level
			dbg$set_mod_lvl: NOVALUE;	! sets level of modes

		LOCAL
			value : BLOCK [4, BYTE];


		value = .dbg$gl_stk [.semsp, stk$v_val1];
		IF (.dbg$gl_stk [.semsp + 2, stk$v_val1] GTR 31) OR (.dbg$gl_stk [.semsp + 4, stk$v_val1] GTR 31)
		  OR (.dbg$gl_stk [.semsp + 4, stk$v_val1] GTR .dbg$gl_stk [.semsp + 2, stk$v_val1])
		THEN SIGNAL (dbg$_bitrange);
		dbg$gl_stk [.semsp, stk$v_val1] = .value [0, .dbg$gl_stk [.semsp + 4, stk$v_val1],
			.dbg$gl_stk [.semsp + 2, stk$v_val1] - .dbg$gl_stk [.semsp + 4, stk$v_val1] + 1, 0];


		dbg$init_modes (local_mode, override_mode);
		dbg$set_mod_lvl (override_mode);
		END;

	!++
	! The add_module routine translates the ASCII name of a module into
	! the address of that module's record in the RST, and puts that
	! address onto the top of the parse stack.  IF this translation
	! fails, a message is produced and an UNWIND is done.
	!--
GLOBAL ROUTINE dbg$add_module (semsp, lex_stg_desc) : NOVALUE  =
		BEGIN
	
		EXTERNAL routine
			dbg$find_module;	! scan MC for module name

		dbg$gl_stk [.semsp, stk$v_val1] = dbg$find_module(.lex_stg_desc,TRUE);

		END;


	!++
	! The add_dimension routine adds a dimension value to the
	! list of dimension values that will be applied to a single
	! array reference. If the value is the eighth dimension to be
	! applied to the same array, a SIGNAL is generated, and this
	! command is aborted.  If the type associated with the
	! supposed subscript is DOUBLE or FLOAT, it is converted to INTEGER.
	!--
GLOBAL ROUTINE dbg$add_dimension (semsp) : NOVALUE  =
		BEGIN

		EXTERNAL
			dbg$gl_dimenlst: VECTOR;

		BUILTIN
			CVTDL,
			CVTFL;

		IF .dbg$gl_dimenlst [0] EQL 7
		THEN
			! Max number of dimensions in FORTRAN is 7

			SIGNAL( DBG$_MAXDIMSN, 1, 7);
			! no return

		! See if conversion to integer is necessary.
		! Note: we only handle double and floating.

		IF( .DBG$GL_stk[ .semsp , stk$v_type] EQL DSC$K_DTYPE_F )
		THEN
			BEGIN
			CVTFL (dbg$gl_stk[.semsp, stk$v_val1], dbg$gl_stk[.semsp, stk$v_val1]);
			dbg$gl_stk [ .semsp , stk$v_type] = dsc$k_dtype_l;
			END
		ELSE
		IF( .DBG$GL_stk [ .semsp , stk$v_type] EQL DSC$K_DTYPE_D )
		THEN
			BEGIN
			CVTDL (dbg$gl_stk[.semsp, stk$v_val1], dbg$gl_stk[.semsp, stk$v_val1]);
			dbg$gl_stk [ .semsp , stk$v_type] = dsc$k_dtype_l;
			END;
		dbg$gl_dimenlst [0] = .dbg$gl_dimenlst [0] + 1;
		SELECTONE .dbg$gl_stk [.semsp, stk$v_type] OF
		SET
			
		[dsc$k_dtype_w] :
		dbg$gl_dimenlst [.dbg$gl_dimenlst [0] ]= 
				.(dbg$gl_stk [.semsp, stk$v_val1]) <0,16,1>;

		[dsc$k_dtype_wu]:
		dbg$gl_dimenlst [.dbg$gl_dimenlst [0] ]= 
				.(dbg$gl_stk [.semsp, stk$v_val1]) <0,16>;

		[dsc$k_dtype_b] :
		dbg$gl_dimenlst [.dbg$gl_dimenlst [0] ]=
				.(dbg$gl_stk [.semsp, stk$v_val1]) <0,8,1>;

		[dsc$k_dtype_bu]:
		dbg$gl_dimenlst [.dbg$gl_dimenlst [0] ]= 
				.(dbg$gl_stk [.semsp, stk$v_val1]) <0,8>;

		[OTHERWISE]:
		dbg$gl_dimenlst [.dbg$gl_dimenlst [0] ]= 
				.dbg$gl_stk [.semsp, stk$v_val1];

		TES;
		END;


	!++
	! The char_substring routine handles the symbolic reference
	! typified by "DBG>EXamine char(from:to)".  The "char" reference
	! has already been reduced - this routine handles the 'from' and 
	! 'to' references by stashing away the indicated values, having
	! converted them to INTEGER if necessary.  All further handling
	! of these numbers is done in ARI's dbg$getarrayadr()
	!--
GLOBAL ROUTINE dbg$char_substring(semsp) : NOVALUE  =
		BEGIN
		BUILTIN
			CVTFL,
			CVTDL;


		! See if conversion of 'from character' to integer is necessary.
		! Note: we only handle double and floating.

		IF( .DBG$GL_stk[ .semsp+1 ,stk$v_type] EQL DSC$K_DTYPE_F )
		THEN
			BEGIN
			CVTFL (dbg$gl_stk[.semsp+1, stk$v_val1],
				 dbg$gl_stk[.semsp+1, stk$v_val1]);
			dbg$gl_stk [ .semsp+1 , stk$v_type] = dsc$k_dtype_l;
			END
		ELSE
		IF( .DBG$GL_stk [ .semsp+1 , stk$v_type] EQL DSC$K_DTYPE_D )
		THEN
			BEGIN
			CVTDL (dbg$gl_stk[.semsp+1, stk$v_val1],
				 dbg$gl_stk[.semsp+1, stk$v_val1]);
			dbg$gl_stk [ .semsp , stk$v_type] = dsc$k_dtype_l;
			END;

		! See if conversion of 'to character' to integer is necessary.
		! Note: we only handle double and floating.

		IF( .DBG$GL_stk[ .semsp+3 , stk$v_type] EQL DSC$K_DTYPE_F )
		THEN
			BEGIN
			CVTFL (dbg$gl_stk[.semsp+3, stk$v_val1],
				 dbg$gl_stk[.semsp+3, stk$v_val1]);
			dbg$gl_stk [ .semsp+3 , stk$v_type] = dsc$k_dtype_l;
			END
		ELSE
		IF( .DBG$GL_stk [ .semsp+3 , stk$v_type] EQL DSC$K_DTYPE_D )
		THEN
			BEGIN
			CVTDL (dbg$gl_stk[.semsp+3, stk$v_val1],
				 dbg$gl_stk[.semsp+3, stk$v_val1]);
			dbg$gl_stk [ .semsp+3 , stk$v_type] = dsc$k_dtype_l;
			END;

		! The 'from' and 'to' character position fields are now
		! converted and in their proper places on the stack.
		! Now we put them were ARI's dbg$getarrayadr expects
		! them to be - namely, the 'from' number goes in the
		! last entry in dbg$gl_dimen_lst, and the 'to' number
		! gets stuffed into the current LENGTH MODE field.

		dbg$gl_dimenlst[8] = .dbg$gl_stk[.semsp + 1, stk$v_val1];
		dbg$gl_asci_len = .dbg$gl_stk[.semsp + 3, stk$v_val1] -
				  .dbg$gl_stk[.semsp + 1, stk$v_val1] +1;
		dbg$gl_stk [.semsp - 1, stk$v_size] = .dbg$gl_asci_len;

		! Set a flag to indicate that a substring modifier was given
		! along with the symbol.  This is needed because there is
		! no other way to determine if we should take the default.

		dbg$gl_dimenlst[9] = TRUE;
		END;

	!++
	! The SAVE_NAME routine allocates an area of free storage to hold
	! the name of a symbol and a string descriptor to that symbol.
	! This routine is called when a name occurs in a DEFINE command,
	! and the name stored in free storage is used by dbg$define_sym.
	! The storage is freed by dbg$perform_cmd.
	!--
GLOBAL ROUTINE dbg$save_name (semsp, lex_stg_desc) : NOVALUE  =
		BEGIN
		EXTERNAL routine
			dbg$freez;		! allocate/clear storage

    		MAP
    			lex_stg_desc : REF BLOCK [,BYTE];

		LOCAL
			pointer : REF VECTOR;


		pointer = dbg$freez (((.lex_stg_desc [dsc$w_length] + 3) / %UPVAL) + 2);
		ch$move (.lex_stg_desc [dsc$w_length], .lex_stg_desc [dsc$a_pointer],
				pointer [2]);
		pointer [0] = .lex_stg_desc [dsc$w_length];
		pointer [1] = pointer [2];
		dbg$gl_stk [.semsp, stk$v_val1] = .pointer;
		END;

  
GLOBAL ROUTINE dbg$set_overr_step(semsp) : NOVALUE  =
		BEGIN
		EXTERNAL routine
			dbg$set_stp_lvl: NOVALUE,	! set level of STEP
			dbg$set_new_stp: NOVALUE;	! set new STEP value

		dbg$set_stp_lvl (override_step);
		dbg$set_new_stp (.dbg$gl_stk[.semsp, stk$v_val1]);
		END;


!++
! The next set of routines manipulates mode settings.
!--

	!++
	! The set_overr_mode routine calls the routine dbg$set_overs to
	! set the mode pointer to OVERRIDE level, and to set the mode
	! according to the token found at the top of the stack.
	!--
GLOBAL ROUTINE dbg$set_overr_mode (semsp) : NOVALUE  =
		BEGIN
		EXTERNAL routine
			dbg$set_overs: NOVALUE;

		dbg$set_overs (override_mode, .dbg$gl_stk[.semsp, stk$v_val1])
		END;


	!++
	! The set_dec_overs routine calls the routine dbg$set_overs to
	! set the mode pointer to LOCAL level, and to set the mode
	! to decimal.
	!--
GLOBAL ROUTINE dbg$set_dec_overs : NOVALUE =
		BEGIN
		EXTERNAL routine
			dbg$set_overs: NOVALUE,
			dbg$set_mod_lvl: NOVALUE;

		dbg$set_mod_lvl (override_mode);
		dbg$set_overs (local_mode, decimal_token);
		END;


	!++
	! The set_line_dec routine sets the current mode level to local
	! mode. Then it sets the fortran_mode to %LINE and
	! the radix to decimal.
	!--
GLOBAL ROUTINE dbg$set_line_dec (semsp) : NOVALUE  =
		BEGIN
		EXTERNAL routine
			dbg$set_overs: NOVALUE,
			dbg$set_new_mod: NOVALUE;

		dbg$set_overs (local_mode, decimal_token);
		dbg$set_new_mod (.dbg$gl_stk [.semsp, stk$v_val1]);
		END;




	!++
	! The set_over_noadr routine sets the current mode level to
	! the override level, and turns the mode_immediate
	! to "off", so that symbols are translated to their contents
	! instead of to their addresses.
	!--
GLOBAL ROUTINE dbg$set_over_noadr : NOVALUE =
		BEGIN
		EXTERNAL routine
			dbg$set_overs : NOVALUE;

		dbg$set_overs (override_mode, noimmed_n_token);
		END;


	!++
	! The set_over_adr routine sets the current mode level to
	! the override level, and turns the mode_immediate
	! to "on", so that symbols are translated to their addresses
	! instead of to their contents.
	!--
GLOBAL ROUTINE dbg$set_over_adr : NOVALUE =
		BEGIN
		EXTERNAL routine
			dbg$set_overs : NOVALUE;

		dbg$set_overs (override_mode, immed_nam_token);
		END;

!++
! The next routine is used to translate the step count into a binary value
! and add that value to the top of the stack.  It calls DBG$TRANS_NAME and
! then calls DBG$ADD_ARG to put the count on the command argument list.
! The mode level is then returned the "override_mode" in case other parameters
! are needed in the command.
! The routine is also used to pick up the N  in "SHOW CALLS N".
!--
GLOBAL ROUTINE dbg$get_step_count (semsp, lex_stg_desc) : NOVALUE  =
		BEGIN
		EXTERNAL routine
			dbg$trans_name: NOVALUE,
			dbg$add_arg,
			dbg$set_mod_lvl: NOVALUE;

		dbg$trans_name (.semsp, .lex_stg_desc);
		dbg$add_arg (dbg$gl_stk[.semsp, stk$v_base], 0);
		dbg$set_mod_lvl (override_mode);
		END;



!++
! The routines below manipulate names of data specified in commands.
!--

	!++
	! The translate_name routine calls the routine dbg$trans_name to
	! translate a token into a binary value. If the routine fails in
	! the translation, a signal and unwind occurs.
	!--
GLOBAL ROUTINE dbg$translate_name (semsp, lex_stg_desc) : NOVALUE  =
		BEGIN
		EXTERNAL routine
			dbg$trans_name: NOVALUE;


		dbg$trans_name (.semsp, .lex_stg_desc);
		END;


	!++
	! The reduce_array routine reduces an array reference (with
	! specified dimension values) to an absolute address that
	! matches the element specified. The address is put on the
	! top of stack.  When we 'restore' the MODE_IMMEDIATE value,
	! we take it from the upper word of the stk stack.
	! (See routine REDU_PATH_ADDR).
	! We pass on the type of the array in the proper
	! place of the stk stack.
	!--
GLOBAL ROUTINE dbg$reduce_array (semsp) : NOVALUE  =
		BEGIN
		EXTERNAL routine
			dbg$getarrayadr;

		EXTERNAL
			dbg$gl_dimenlst: VECTOR;
			
		local
			type;

		type = dbg$getarrayadr (.dbg$gl_stk [.semsp, stk$v_val1], dbg$gl_dimenlst,
			 dbg$gl_stk [.semsp, stk$v_val1],
    			 .dbg$gl_stk[.semsp,stk$v_nt_ptr]);
		zerocor (dbg$gl_dimenlst, 8);
		dbg$gb_mod_ptr [mode_immediate] = .dbg$gl_stk [.semsp, stk$v_immed];
		dbg$gl_stk [.semsp, stk$v_type] = .type;
	 	dbg$ftn_indirection (.semsp);
		dbg$set_mod_lvl(override_mode);
		dbg$gb_mod_ptr [mode_immediate] = .dbg$gl_stk [.semsp, stk$v_immed];

		END;




!++
! The routine below is for setting DEBUG syntax.
!--

	!++
	! The save_lang_name routine invokes the routine "save_name", which
	! collects a name, builds a string descriptor for it and passes
	! the address of the string descriptor on dbg$gl_stk.
	! This routine also turns on the context bit for LANGUAGE
	! so that in dbg$perform_cmd, dbg$set_lang will be called.
	!--
GLOBAL ROUTINE dbg$save_lang_name (semsp, lex_stg_desc) : NOVALUE  =
		BEGIN
		dbg$save_name (.semsp, .lex_stg_desc);
		dbg$gl_context [dbg$k_language] = TRUE;
		END;


!++
! The next routines manipulate scope and pathnames.
!--

	!++
	! The reduce_pathname routine calls dbg$path_to_val to convert a
	! pathname into an equivalent value.  If the conversion fails,
	! then the symbol does not exist, a message is produced, and
	! an UNWIND is done.  Otherwise the corresponding value
	! replaces the token on top of the stk stack.  Correspondingly,
	! the associated TYPE is placed onto the stk stack.
	!--
GLOBAL ROUTINE dbg$reduce_pathname (semsp, lahead_stg_desc) : NOVALUE  =
		BEGIN
		EXTERNAL routine
			dbg$path_to_val: NOVALUE,
			dbg$get_bounds : NOVALUE;

		EXTERNAL
			dbg$gl_asci_len;

		LOCAL
				! Needed to interface with DBG$PATH_TO_VAL
			temp_nt_ptr : ref rst$entry,
			temp_valu_desc : VALU_DESCRIPTOR;


		DBG$PATH_TO_VAL(temp_valu_desc);

		! Pick up the returned NT pointer and extract the
		! type info so that it can be placed on the stk stack.
		! Assume a default type for symbols NOT from the RST.

		temp_nt_ptr = .temp_valu_desc[VALU_NT_PTR];
		dbg$gl_stk [.semsp, stk$v_val1] = .temp_valu_desc[VALU_VALUE];
		dbg$gl_stk [.semsp, stk$v_nt_ptr] = .temp_nt_ptr;
		dbg$gl_stk [.semsp, stk$v_type] = DSC$K_DTYPE_L;

		! The value bound to the symbol name, above, may be
		! the symbol's address, or the address of the descriptor
		! for that symbol.  If the latter is the case, we
		! go ahead and further reduce this address to that of
		! the first element in the array.  The reason that we
		! get away with this is that this routine is called ONLY
		! when we know that a 'real' array reference (i.e. one
		! with parenthesis) is NOT going to be made.


		IF .temp_nt_ptr NEQ 0
		THEN
		    BEGIN
		    dbg$gl_stk [.semsp, stk$v_type] = dbg$rst_type(.temp_nt_ptr);
		    IF NOT .temp_nt_ptr[rst$v_global]
		    THEN
			BEGIN
			LOCAL
				dst_recrd : ref dst$record;

			dst_recrd = .temp_nt_ptr[rst$l_dstptr];

			IF( .dst_recrd[ dst$v_valkind ] EQL dst$k_valkind_desc)
			THEN
				BEGIN
				LOCAL
						descrip_block : REF block[,byte],
						bounds : ARRAY_BNDS_DESC;

				! The symbol is bound to its array descriptor
				! address.  Get the bounds and bind the symbol
				! to the beginning element of the array.

				descrip_block = .temp_valu_desc[VALU_VALUE];
				dbg$get_bounds(.temp_valu_desc[VALU_VALUE], bounds );
				dbg$gl_stk[.semsp, stk$v_val1] = .bounds[ ARRAY_ADDRESS ];
				!+
				! Pick up the variable's length from the
				! descriptor.
				!-
				dbg$gl_asci_len = .descrip_block[dsc$w_length];
				dbg$gl_stk [.semsp, stk$v_size] = .dbg$gl_asci_len;
				END;
			END;
		    END;


	IF .TEMP_NT_PTR EQL 0 THEN
		dbg$FTN_INDIRECTION (.semsp)
	ELSE
	BEGIN
		IF dbg$rst_type(.temp_nt_ptr) NEQ dsc$k_dtype_t
		THEN
		    dbg$ftn_indirection (.semsp);	! Perform indirection if required.
	END;
		END;


	!++
	! The redu_path_addr routine saves the current setting of the
	! FORTRAN mode_immediate, turns mode_immediate on, and
	! reduces the name of an array. Then address mode is turned off
	! so that the array dimensions are taken as contents of symbols
	! instead of addresses of symbols.  The saving of this
	! MODE_IMMEDIATE value is done in the upper word of the
	! current stk stack entry, so that we can handle array
	! elements being used as subscripts.
	!--
GLOBAL ROUTINE dbg$redu_path_addr (semsp) : NOVALUE  =
		BEGIN

		LOCAL
				! Needed to interface with DBG$PATH_TO_VAL
			temp_nt_ptr : ref rst$entry,
			temp_valu_desc : VALU_DESCRIPTOR;
		dbg$gl_stk [.semsp, stk$v_immed] = .dbg$gb_mod_ptr [mode_immediate ];
		dbg$set_over_adr();

		! If DBG$PATH_TO_VAL fails for anticipated reasons,
		! a proper message is produced and an UNWIND is done.

		DBG$PATH_TO_VAL(temp_valu_desc);

		! Pick up the returned NT pointer and extract the
		! type info so that it can be placed on the stk stack.
		! Assume a default type for symbols NOT from the RST.
		! Likewise pass on the symbol's value and NT_PTR.

		dbg$gl_stk [.semsp, stk$v_type] = DSC$K_DTYPE_L;
		IF( (temp_nt_ptr = .temp_valu_desc[ VALU_NT_PTR ] ) NEQA 0 )
		THEN
		dbg$gl_stk [.semsp, stk$v_type] = dbg$rst_type(.temp_nt_ptr);
		dbg$gl_stk [.semsp, stk$v_val1] = .temp_valu_desc[VALU_VALUE];
		dbg$gl_stk [.semsp, stk$v_nt_ptr] = .temp_nt_ptr;
		dbg$set_over_noadr();

    		! The following was intended to always force evaluation of
    		! array subcripts in decimal. It was decided that this 
    		! may not be desirable, so this was commented out.
    		! ... Then we changed our mind so we put it back in
		dbg$set_dec_overs();
		END;


	!++
	! The reduce_label routine is similar to reduce_pathname
	! except that the pathname is in the second position on the
	! stack, and must be raised to the first position if the
	! translation is successful.
	!--
GLOBAL ROUTINE dbg$reduce_label (semsp, lahead_stg_desc)  : NOVALUE =
		BEGIN
		EXTERNAL routine
			dbg$path_to_val: NOVALUE,
			dbg$init_modes : NOVALUE,
			dbg$set_mod_lvl: NOVALUE;


		LOCAL
				! Needed to interface with DBG$PATH_TO_VAL
			temp_nt_ptr : ref rst$entry,
			temp_valu_desc : VALU_DESCRIPTOR;
		! Let DBG$PATH_TO_VAL do all the work.  For this call, we don't
		! care what the returned value is - it is sufficient
		! to know that if the routine returns at all (i.e. does NOT
		! SIGNAL its way out), then the evaluation went ok.

		dbg$PATH_TO_VAL( temp_valu_desc );
		dbg$init_modes (local_mode, override_mode);
		dbg$set_mod_lvl (override_mode);

		! Assume a default type for symbols NOT from the RST.

		dbg$gl_stk [.semsp, stk$v_type] = DSC$K_DTYPE_L;
		IF( (temp_nt_ptr = .temp_valu_desc[ VALU_NT_PTR ] ) NEQA 0 )
		THEN
		dbg$gl_stk [.semsp, stk$v_type] = dbg$rst_type(.temp_nt_ptr);
		dbg$gl_stk [.semsp, stk$v_val1] = .temp_valu_desc[ VALU_VALUE ];

		! Pass on the NT pointer only for %LABEL, this way
		! we will beable to distinguish labels from lines.

		IF ( .dbg$gb_mod_ptr[ MODE_FORTRAN ] NEQ LINE_MODE )
		THEN
			dbg$gl_stk [.semsp, stk$v_nt_ptr] = .temp_nt_ptr;
		dbg$ftn_indirection (.semsp);
		END;

GLOBAL ROUTINE dbg$SAVE_ASCII_LENG(strng_desc) : NOVALUE = 
		BEGIN
		LOCAL number_desc : REF BLOCK[,BYTE];
		number_desc = .strng_desc;
		CASE .number_desc[dsc$w_length] FROM 1 TO 4 OF
		    SET
			[1] :
			    BEGIN
			    LOCAL
				ERROR_STG : BLOCK [8,BYTE];
			    ERROR_STG[DSC$W_LENGTH] = 1;
			    ERROR_STG[DSC$A_POINTER] = UPLIT('0');
			    SIGNAL (DBG$_INVNUMBER,1,ERROR_STG);
			    END;
			[4] : 
    			    BEGIN
    			        IF ..number_desc[dsc$a_pointer] GTR 
    				   max_ascii_leng	
    			        THEN signal (dbg$_tobigasci, 
    					     ..number_desc[dsc$a_pointer])
				ELSE dbg$gw_length = ..number_desc[dsc$a_pointer];
			    END;
			[inrange, outrange] : SIGNAL(DBG$_DBGERR);
		    TES;
		dbg$gl_type = dsc$k_dtype_t;
		END;

GLOBAL ROUTINE dbg$SET_LOCAL_TYPE  : NOVALUE  =
		BEGIN
		dbg$gl_loctyp = .dbg$gl_type;
		dbg$gw_loclngth = .dbg$gw_length;
		END;

GLOBAL ROUTINE dbg$SET_DEFAULT_TYP : NOVALUE  = 
		BEGIN
		dbg$gl_dflttyp = .dbg$gl_type;
		dbg$gw_dfltleng = .dbg$gw_length;
		END;
GLOBAL ROUTINE dbg$SET_OVER_TYP : NOVALUE  = 
		BEGIN
		dbg$gl_gbltyp = .dbg$gl_type;
		dbg$gw_gbllngth = .dbg$gw_length;
		END;

GLOBAL ROUTINE dbg$SAVE_TYPE(semsp) : NOVALUE  =
		BEGIN
		dbg$gl_type = (CASE .dbg$gl_stk[.semsp, stk$v_val1] 
					FROM 0 to goalsy_token OF
				SET
				[ascii_token] : BEGIN
						dbg$gw_length = 4;
						dsc$k_dtype_t
						END;
				[byte_token] : dsc$k_dtype_b;
				[word_token] : dsc$k_dtype_w;
				[long_token] : dsc$k_dtype_l;
				[instruct_token] : dsc$k_dtype_zi;
				[quad_token] : dsc$k_dtype_q;
				[octa_word_token] : dsc$k_dtype_o;
				[f_float_token] : dsc$k_dtype_f;
				[d_float_token] : dsc$k_dtype_d;
				[g_float_token] : dsc$k_dtype_g;
				[h_float_token] : dsc$k_dtype_h;
				[inrange, outrange] : 0;
				TES);
		END;

	!++
	! The reduce_bli_path routine calls dbg$path_to_val to convert a
	! pathname into an equivalent value.  If the conversion fails,
	! then the symbol does not exist, a message is produced, and
	! an UNWIND is done.  Otherwise the corresponding value
	! replaces the token on top of the stack.  Correspondingly, the
	! appropriate DST fields are placed onto the semantic stack.
	!--
GLOBAL ROUTINE dbg$reduce_bli_path (semsp) : NOVALUE  =
		BEGIN
		EXTERNAL ROUTINE
			dbg$path_to_val: NOVALUE;

		LOCAL		! Needed to interface with DBG$PATH_TO_VAL

			temp_nt_ptr : ref rst$entry,
			temp_valu_desc : VALU_DESCRIPTOR;


		DBG$PATH_TO_VAL(temp_valu_desc);

		! Pick up the returned NT pointer and extract the
		! type info so that it can be placed on the semantic stack.
		! Assume a default type for symbols NOT from the RST.

		temp_nt_ptr = .temp_valu_desc[VALU_NT_PTR];
		dbg$gl_stk [.semsp, stk$v_val1] = .temp_valu_desc[VALU_VALUE];
		dbg$gl_stk [.semsp, stk$v_nt_ptr] = .temp_nt_ptr;
		dbg$gl_stk [.semsp, stk$v_type] = DSC$K_DTYPE_L;



		IF .temp_nt_ptr NEQ 0
		THEN
		    BEGIN
	    dbg$gl_stk [.semsp, stk$v_type] = dbg$rst_type(.temp_nt_ptr);
		    IF NOT .temp_nt_ptr[rst$v_global]
		    THEN
			BEGIN
			LOCAL
				blz_recrd : ref BLZ_RECORD;

			blz_recrd = .temp_nt_ptr[rst$l_dstptr];
			
			! If type zero record, pick up the needed info

			IF .blz_recrd[1,0,8,0] EQL DSC$K_DTYPE_Z
			THEN
			    BEGIN
			    dbg$gl_stk [.semsp, stk$v_struc] = .blz_recrd [blz_struct];
			    dbg$gl_stk [.semsp, stk$v_ref]  = .blz_recrd [blz_ref];
			    END;
  			END;
		    END;


		END;
	

	!++
	! The routine add_access_act adds one access actual to the access_list
	! vector. This vector, once completed, is used to fill in the appropriate
	! fields for the symbol on the semantic stack.
	!--

GLOBAL ROUTINE dbg$add_access_act (semsp, count) : NOVALUE  =
	BEGIN				! first check whether to reinit the access list
    	EXTERNAL
    		dbg$access_list : VECTOR;
	IF .count EQL 0
	THEN
	    dbg$access_list [0] = 0;


	! If we have a FIELD name extract the access actuals from the
	! DST entry pointed to by STK$V_VAL1.
	! Otherwise take the access actual from STK$V_VAL1 itself.
 
	IF .dbg$gl_stk[.semsp, stk$v_type] EQL dsc$k_dtype_fld
	THEN
		BEGIN
		LOCAL
		    no_fields,			! Number of fields in this name
		    fields  : REF BLOCK;	! Address of first value.		

		fields = .dbg$gl_stk[.semsp, stk$v_val1];
		no_fields = .fields[0,0,32,0];
		fields = .fields + 5 + .fields[1,0,8,0];

		! extract the access actuals

		INCR i FROM 0 TO .no_fields-1 DO
		    BEGIN
		    dbg$access_list[0] = .dbg$access_list[0] + 1;
		    IF .dbg$access_list[0] GTR 5
		    THEN
			SIGNAL (dbg$_exceedact, 1, 5);	! no return

		    dbg$access_list[.dbg$access_list[0]] = .fields [.i,0,32,0];
		    END;
		END
	ELSE
	    BEGIN
	    dbg$access_list[0] = .dbg$access_list[0] + 1;
	    IF .dbg$access_list[0] GTR 5
	    THEN
		SIGNAL (dbg$_exceedact, 1, 5);	! no return
		
	    dbg$access_list[.dbg$access_list[0]] = .dbg$gl_stk[.semsp,stk$v_val1];
	    END;
	END;


	!++
	! The bli_indirection routine considers the value in the second position
	! of the stack to be an address. It takes that address, applies any 
	! necessary field references and puts the contents of the resultant 
	! address on the top of the stack, COPYING all other fields.
	!--
GLOBAL ROUTINE dbg$bli_indirection (semsp) : NOVALUE  =
	BEGIN
	EXTERNAL ROUTINE
		dbg$read_access;		! probe read accessibility
	
	dbg$read_access(.dbg$gl_stk[.semsp+1, stk$v_val1],%UPVAL);
        dbg$POP_STACK (.semsp);

	! If there are no field references to resolve, the fldrf field
	! will contain zero

	IF .dbg$gl_stk[.semsp+1, stk$v_fldrf] EQL 0
	THEN
		dbg$gl_stk[.semsp, stk$v_val1] = ..dbg$gl_stk[.semsp+1,stk$v_val1]
	ELSE
		BEGIN			! we have field references to resolve
		LOCAL
			size;
	
		size = .dbg$gl_stk[.semsp+1, stk$v_size];

		IF .dbg$gl_stk[.semsp+1, stk$v_ext] EQL 0
		THEN
		    dbg$gl_stk[.semsp, stk$v_val1] = .(.dbg$gl_stk[.semsp+1, stk$v_val1])<0, .size, 0>
		ELSE
		    dbg$gl_stk[.semsp, stk$v_val1] = .(.dbg$gl_stk[.semsp+1, stk$v_val1])<0, .size, 1>;
		END;

		dbg$gl_stk[.semsp, stk$v_dot]    = 1;	! indicate that this was an indirect ref
	END;


	!++
	! The check_size_fld routine checks for a reference to a size field
	! greater than 32 in a BLISS field reference. If a size field is
	! specified that exceeds 32, an informational message is printed and
	! the size field is set to 32.
	!--
GLOBAL ROUTINE dbg$check_size_fld (size_field) =
    	BEGIN
	IF .size_field GTR 32
	THEN
		BEGIN
		SIGNAL (dbg$_sizetrunc);
		32
		END 
    	ELSE
    		.size_field
    	END;


	!++
	! The check_ext_fld routine checks for a sign extension field other than
	! 0 or 1. If an illegal extension field is given, an error message is
	! issued.
	!--
GLOBAL ROUTINE dbg$check_ext_fld (ext_field) : NOVALUE  =
	IF .ext_field NEQ 0 AND .ext_field NEQ 1
	THEN
		SIGNAL (dbg$_illsigext, 1, .ext_field) ;

GLOBAL ROUTINE dbg$push_nest_stack : NOVALUE =
!++
! Function
!	
!	This routine is called when an array name is encountered in FORTRAN
!	or BASIC. In these languages a global vector DBG$GL_DIMENLST is used
!	to accumulate the list of subscripts. If subscript
!	expressions are nested [e.g., EXAMINE A(1,A(1,2)) ] 
!	, some sort of stack mechanism must be used.
!	This routine provides that mechanism.
!
!	If the current nest level is 0 (i.e., we are not in a nested subscript
!	expression) then the nest level is incremented to 1 and we just return.
!
!	If the level is 1 or more, we save the contents of DBG$GL_DIMENLST by
!	pushing its contents onto DBG$GL_NEST_STACK. We then clear out 
!	DBG$GL_DIMENLST in preparation for evaluating the inner subscript
!	expression.
!
! (Implicit) Inputs
!	
!	DBG$GL_DIMENLST - A longword vector. DBG$GL_DIMENLST[0] countains
!			  a count of the number of  remaining elements. 
!			  DBG$GL_DIMENLST[1] through DBG$GL_DIMENLST[.DBG$GL_DIMENLST[0]]
!			  are the subscripts.
!	DBG$GL_NEST_LEVEL - The current level of nesting of subscript expressions
!	DBG$GL_NEST_STACK - A stack containing saved contents of DBG$GL_DIMENLST
!			    DBG$GL_NEST_STACK[0] contains a count of the 
!			    remaining elements.
!
! (Implicit) Outputs
!
!	All three of the above may be altered.
!
!--
    BEGIN

    ! Increment the nest level.
    !
    dbg$gl_nest_level = .dbg$gl_nest_level + 1;

    ! If we are not in a nested subscript, then return.
    !
    IF .dbg$gl_nest_level EQL 1 
    THEN
        RETURN;

    ! Check for potential overflow of DBG$GL_NEST_STACK
    !
    IF .dbg$gl_nest_level GTR 4
    THEN
        SIGNAL (dbg$_nessubovr);

    ! Transfer the contents of DBG$GL_DIMENLST to DBG$GL_NEST_STACK.
    ! The last element in DIMENLST is pushed first. The first element 
    ! (the count) is the last to be pushed. This is so that the count is
    ! easily accessible when it comes time to pop.
    !
    DECR i FROM .dbg$gl_dimenlst[0] TO 0 DO
    	BEGIN
    	dbg$gl_nest_stack[0] = .dbg$gl_nest_stack[0] + 1;
    	dbg$gl_nest_stack[.dbg$gl_nest_stack[0]] = .dbg$gl_dimenlst[.i];
    	END;

    ! Now clear out the subscript list.
    !
    dbg$gl_dimenlst[0] = 0;

    END; ! dbg$push_nest_stack 

GLOBAL ROUTINE dbg$pop_nest_stack : NOVALUE = 
!++
! Function
!
!	This routine is the inverse of DBG$PUSH_NEST_STACK. It is called
!	after evaluation of a subscripted array. If this evaluation
!	is part of a nested subscript expression [e.g., the evaluation
!	of B(1) within the expression A(2,B(1))] then the previous
!	contents of DBG$GL_DIMENLST are restored so we can move on to
!	the evaluation of the outer array expression.
!
! (Implicit) Inputs
!
!	DBG$GL_DIMENLST - 	A counted vector containing the current
!			        subscript list.
!	DBG$GL_NEST_LEVEL -	The number of levels of nesting of subscript
!				expressions.
!	DBG$GL_NEST_STACK -	A stack of saved subscript lists. DBG$GL_NEST_STACK[0]
!				contains a count of the remaining elements on the
!				the stack.
! (Implicit) Outputs
!
!	All three of the above may be altered.
!
!--
    BEGIN

    ! Decrement the current nesting level
    !
    dbg$gl_nest_level = .dbg$gl_nest_level - 1;

    ! Check for stack underflow
    !
    IF .dbg$gl_nest_level LSS 0
    THEN
    	SIGNAL (dbg$_debugbug, dbg$k_nest_stack_err);

    ! If we are at top level, (not inside an array expression), just return
    !
    IF .dbg$gl_nest_level EQL 0 
    THEN
    	RETURN;

    ! Pop the elements of DBG$GL_NEST_STACK off one by one and place them
    ! into DBG$GL_DIMENLST left to right. Remember that the count of the
    ! number of elements to pop off is at the top of the stack (i.e., in
    ! DBG$GL_NEST_STACK[.DBG$GL_NEST_STACK[0]] )
    ! 
    INCR i FROM 0 TO .dbg$gl_nest_stack[.dbg$gl_nest_stack[0]] DO
    	BEGIN
    	dbg$gl_dimenlst[.i] = .dbg$gl_nest_stack[.dbg$gl_nest_stack[0]];
    	dbg$gl_nest_stack[0] = .dbg$gl_nest_stack[0] - 1;
    	END;

    END; ! dbg$gl_pop_stack
END
ELUDOM
