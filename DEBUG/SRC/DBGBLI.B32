MODULE DBGBLI ( IDENT = 'V03-000') =
BEGIN

!++
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!--

!++
! FACILITY:	DEBUG (DBG)
!
! ABSTRACT:
!	This module contains the lexical scanner and reduction routines
!	for BLISS/DEBUG.
!
! ENVIRONMENT:	VAX/VMS, user mode, interrupts disabled.
!
! Version:	1.11
!
! Revision History:
!	Author:
!		Mike Candela, 28 August 1978
!
! Modified by:
!		Mike Candela, 20 December 1979
!		Richard Title 18 Jul 1981
!
!+
! 1.01	28-AUG-78	MCC	Original version.
! 1.02	26-SEP-78	DAR	Removed require file SYSLIT and added BLISS.REQ
! 1.03	04-OCT-78	DAR	All expression reductions perform their thing
!				in line instead of in macros.
! 1.04	18-OCT-78	MCC	Changed semantic stack from VECTOR to BLOCKVECTOR
!				to accomodate BLISS fields
! 1.05	 1-NOV-78	MCC	Made necessary changes to allow BLISS predefined
!				structures to be handled correctly. This included
!				the addition of the routine reduce_struc and
!				the MACROs dbg$reduce_bli_path and dbg$add_access_act.
! 1.06	 9-DEC-78	MCC	Added <field_ref> support in dbg$bli_reductn,
!				made lexical scanner accept %DECIMAL in additon
!				to %DEC
! 1.07	14-Mar-79	MCC	Modified DBG$BLI_REDUCTN to include actions for
!				LOG file support.
! 1.08	30-May-79	MCC	Fixed missing dot in check_valid_i in rtn
!				reduce_struc
! 1.09	13-Jul-79	MCC	Modified DBG$BLI_REDUCTN to include actions for
!				indirect command file support.
! 1.10	29-NOV-79	BAO	Added support for TYPE[/OVERRIDE].
! 1.11	20-DEC-79	MCC	Added support for HELP
! 1.12  18-Jul-81	 RT	Added support for %LINE
! 3.00  24-Aug-81	 RT	Added support for source line display commands.
! 3.01  02-Nov-81	 RT	Added support for search command.
! 3.02	21-Nov-81	 RT 	Changed processing of SET MODULE and CANCEL MODULE
!				to allow for module names that begin with numbers.
!--

! TABLE OF CONTENTS:
!
FORWARD ROUTINE

	dbg$bli_get_lex,	! extracts a BLISS lexeme from the input buffer
	dbg$bli_reductn,	! BLISS reduction routine
	reduce_struc: NOVALUE;	! action routine to fill in access actual fields
				! for a BLISS structure reference.

!
! INCLUDE FILES:
!

REQUIRE 'src$:dbgprolog.req';
REQUIRE 'src$:DBGGEN.REQ';
REQUIRE 'src$:COMTER.REQ';			
REQUIRE 'SRC$:scalit.REQ';
REQUIRE 'SRC$:BSTRUC.REQ';
REQUIRE 'SRC$:SYSSER.REQ';
REQUIRE 'src$:bliss.REQ';		! BLISS/DEBUG Parse tables.
! REQUIRE 'SRC$:REDMAC.REQ' is required further down in code in MACRO section



!
! EQUATED SYMBOLS:
!


!
! OWN STORAGE:	
!
GLOBAL
	dbg$access_list : VECTOR [6] INITIAL (REP 6 OF (0)); ! access actuals needed for structure
							 ! references. The first element will 
							 ! contain the no. of actuals
		
!
! EXTERNAL REFERENCES:
!
EXTERNAL ROUTINE
	dbg$rst_name_addr,
	dbg$get_filesp,			! extract filespec from input string
    	dbg$nlist_freez,		! Allocates temporary memory
	dbg$pars_linnum,	
	dbg$freerelease,		! Release dynamically allocated storage
	dbg$radx_convrt,		! converts ASCII strings to binary numbers
	dbg$cis_getfsp,			! get filespec of indirect command file
	dbg$verify_out,			! decide whether to verify input
	dbg$show_type,			! print out user specified type.
	dbg$get_help,			! Invoke librarian for HELP
	dbg$cis_openicf,		! Open the ind com file
	dbg$sta_getsourcemod,		! Find module rst pointer
	dbg$get_dir_list,		! Parse a directory list
    	dbg$parse_search;		! Parse the SEARCH command

EXTERNAL
	dbg$char_table : VECTOR [, BYTE],	! Character type table
	dbg$token_table : VECTOR [, BYTE],	! Table of token types.
	dbg$gb_def_mod : VECTOR [, BYTE],	! mode structure
    	dbg$gb_set_module_flag: BYTE,		! TRUE during SET MODULE or
    						!    CANCEL MODULE command.
	dbg$gl_get_lex,				! holds name of get lexeme routine
    	dbg$gl_set_source,
    	dbg$gl_set_source2,
	dbg$gl_gbltyp,				! the type override field.
	dbg$gw_gbllngth : WORD,			! The length field for use with 
	dbg$gl_log_buf,				! addr of buffer containing LOG filespec
	dbg$gl_stk : semantic_stack,		! semantic stack for tokens, etc.
    	dbg$gl_search_verb,			! Holds a pointer to the head of
    						!     the command execution tree
    						!     for the SEARCH command.
	dbg$gl_module,				! Holds module during 
						! SET SOURCE/MODULE=
						! command.
	dbg$gl_dirlist,				! Holds directory list being
						! parsed during SET SOURCE
						! command.
    	dbg$src_left_margin,			! Left margin for source display
    	dbg$src_right_margin;			! Right margin for source display


!
! MACROS :
!
REQUIRE 'src$:REDMAC.REQ';
REQUIRE 'src$:BLIMAC.REQ';

GLOBAL ROUTINE dbg$bli_get_lex (input_stg_desc, lexeme_stg_desc) =

!++
! Functional description:
!	Using the character pointer for the input line, extracts a lexeme
!	from the input line. A lexeme is defined as an operator, an
!	alphanumeric string, a numeric string, or an
!	illegal string. Blanks and comments are absorbed.
!	The lexeme is returned in the lexeme buffer in the
!	same form as in the input string, except for numeric
!	strings, in which case the string is converted to a
!	binary number and that is returned in the lexeme buffer.
!	A token equivalent of the lexeme is the value of the
!	routine.
!
! Formal parameters:
!	input_stg_desc	- string descriptor to the input buffer.
!	lexeme_stg_desc	- varying string descriptor to the lexeme buffer
!
! Implicit inputs:
!	DBG$CHAR_TABLE	- a 128 byte VECTOR that maps each ascii character
!			  onto a dense list of equivalents.
!	DBG$TOKEN_TABLE	- a 21 byte VECTOR that maps each operator onto
!			  its token equivalent.
!
! Outputs:
!	input_stg_desc	- the field dsc$a_pointer is updated to point to
!			  the next byte to be read in the input stream.
!			  This byte is the delimiter of the lexeme found.
!			  The field dsc$w_length contains the length of
!			  the yet unread input line.
!	lexeme_stg_desc	- the field dsc$w_length holds the actual length
!			  in bytes of the lexeme found. The lexeme buffer
!			  addressed by the field dsc$a_pointer holds the
!			  lexeme string or value.
!
! Implicit outputs:
!	The ASCII representation of the lexeme is written into the
!	string addressed by the dsc$a_pointer field of lexeme_stg_desc.
!
! Routine value:
!	The type of lexeme found, alpha_str_token, digit_str_token,
!	eol_token or "operator"_token.
!
! Side effects:
!	Signal if an input character is invalid,
!	or the input string has a negative length.
!--

	BEGIN

	LITERAL
		single_prec	= 1,
		double_prec	= 3,
		table_offset	= 9,
		operator_max	= 30;

	LITERAL
		max_state_index	= 4,			! index ranges from 0 to 4
		invalid_state	= 0,			! invalid character seen
		alpha_state	= 1,			! alphabetic string expected
		numeric_state	= 2,			! numeric string expected
		eocommand_state	= 3,			! logical end of line or error seen
		radix_state	= 4,			! radix setting expected
		unspec_state	= 5;			! unspecified state, probably special character operator

	BIND
		lex_type_tbl	= UPLIT (

		mask (illegal),
		mask (alpha, alpha_low, alpha_and_hex, alphalo_and_hex),
		mask (numeric),
		mask (ind_comment, end_of_line),
		mask (percent_sign)

		) : VECTOR;

	BIND
		lex_state_tbl	= UPLIT BYTE (

		invalid_state,
		alpha_state,
		numeric_state,
		eocommand_state,
		radix_state

		) : VECTOR [, BYTE];


	MAP
		input_stg_desc	: REF BLOCK [, BYTE],	! input string descriptor
		lexeme_stg_desc	: REF BLOCK [, BYTE];	! lexeme string descriptor

	LOCAL
		input_ptr,				! character pointer for input
		lexeme_ptr,				! character pointer for lexeme
		float_number,				! indicates floating point number
		radix_flag,				! special radix setting		
		previous_radix,				! current local radix
		quote_present,				! indicates presence of quote in special radix mode
		state_index,				! index into lex_state_tbl
		state,					! current state of lexical processor
		char,					! holds a single character
		count,					! counts characters used
		radix_to_alpha_flag;

	LABEL
		alpha_block;			! label for alpha case in the select

	!++
	! See whether there is any input line left. If not, signal
	! internal error.
	!--
	IF .input_stg_desc [dsc$w_length] LSS 0
	THEN SIGNAL (dbg$_parseerr);

	!+
	! Make the string pointers into formal BLISS character
	! pointers.
	!-
	input_ptr = ch$ptr (.input_stg_desc [dsc$a_pointer]);
	lexeme_ptr = ch$ptr (.lexeme_stg_desc [dsc$a_pointer]);

	previous_radix = .dbg$gb_mod_ptr [mode_radix];	! Save current radix in case of local override.

	float_number = FALSE;
	radix_flag = FALSE;

	radix_to_alpha_flag = FALSE;
	count = -1;
	DO						! Loop to skip leading blanks
	    BEGIN
	    char = ch$rchar_a (input_ptr);
	    count = .count + 1;
	    END
	UNTIL .dbg$char_table[.char] NEQ blanks;

	input_ptr = ch$plus (.input_ptr, -1);		! Adjust ptr to first significant character.
	input_stg_desc [dsc$w_length] = .input_stg_desc [dsc$w_length] - .count;


    	!+
    	! First check whether we are processing a SET SOURCE command.
    	! If so, just read a character and return alpha_str_token.
    	! The routine dbg$get_dir_list in DBGPAR will handle the rest.
    	!-
    	IF .dbg$gl_set_source
    	THEN
    	    BEGIN

    	    ! first check for exhausted input
    	    IF .input_stg_desc[dsc$w_length] EQL 0
    	    THEN
    		! an empty directory list is an error
    		SIGNAL(dbg$_MISDIRLIS);

    	    ch$wchar_a (.char, lexeme_ptr);
    	    lexeme_stg_desc [dsc$w_length] = 1;
    	    input_stg_desc [dsc$a_pointer] = ch$plus(.input_ptr,1);
    	    input_stg_desc [dsc$w_length] = .input_stg_desc[dsc$w_length] - 1;

    	    ! Check for SET SOURCE/MODU = XXX  command
    	    IF .char EQL '/'
    	    THEN
    		BEGIN
    		dbg$gl_set_source = FALSE;
    		dbg$gl_set_source2 = TRUE;
    		RETURN slash_token;
    		END
    	    ELSE
    	        RETURN alpha_str_token;
    	    END;

	!+
	! Convert the mapping of the first significant character
	! into a lexical state. This state drives the later CASE
	! processing.
	!-
	state_index = 0;
	REPEAT
		BEGIN
		IF .lex_type_tbl [.state_index] ^ .dbg$char_table [.char] LSS 0
		THEN
			BEGIN
			state = .lex_state_tbl [.state_index];
			EXITLOOP
			END
		ELSE
			BEGIN
			state_index = .state_index + 1;
			IF .state_index GTR max_state_index
			THEN
				BEGIN
				state = unspec_state;
				EXITLOOP
				END;
			END;
		END;

    	! If we are processing a SET MODULE or CANCEL MODULE command and
    	! if we are looking at a numeric character, then change state to
    	! alpha_state to allow for module names that begin with a number.
    	!
    	IF .dbg$gb_set_module_flag 
    	THEN
    	    IF .char GEQ %C'0' AND .char LEQ %C'9'
    	    THEN
    		state = alpha_state;

	WHILE 1 DO			! Do forever !!!!!!!!!!
	BEGIN


	CASE .state FROM 0 to max_state_index + 1 OF	! analyze current state

		SET

		[invalid_state]:			! if illegal, just signal
			SIGNAL (dbg$_invchar);

		[alpha_state]:				! alphanumeric string
			BEGIN

			!++
			! Now read the input buffer until a non-alpha
			! and non-numeric
			! character is encountered. Store each
			! character found in the buffer for the lexeme
			! unless the length of that buffer is expended.
			!--

			if .radix_to_alpha_flag then
			    count = 1
			else
			    count = 0;

			DO
				BEGIN
				IF (.char GEQU %C'a')
				THEN char = .char - upper_case_dif;
				count = .count + 1;
				IF .count LEQ sym_max_length
				THEN ch$wchar_a (.char, lexeme_ptr);
				char = ch$a_rchar (input_ptr);
				END
			WHILE	(oneof (.dbg$char_table [.char], alpha, alpha_low, numeric,
						alpha_and_hex, alphalo_and_hex));


			IF .count GTR sym_max_length
			THEN
				BEGIN
				SIGNAL (dbg$_stgtrunc);
				lexeme_stg_desc [dsc$w_length] = sym_max_length;
				END
			ELSE lexeme_stg_desc [dsc$w_length] = .count;
			input_stg_desc [dsc$a_pointer] = .input_ptr;
			input_stg_desc [dsc$w_length] = .input_stg_desc [dsc$w_length] - .count;

			RETURN alpha_str_token
			END;

		[numeric_state]:			! numeric string
			BEGIN

			!++
			! A floating point number can begin with
			! or contain a decimal point (period). When the
			! decimal point is found, set period_present to
			! indicate that.
			!--

			LOCAL
				sign_present,		
				period_present;


			sign_present = 0;
			period_present = FALSE;
			count = 0;

			!++ BLISS allows '+' or '-' to be the first character
			! within the quoted string when a special radix has 
			! been set. If char is a 'sign' set sign_present flag
			! so we dont forget to count the sign, yet can still
			! skip leading zeros.
			!--

			IF .radix_flag AND ((.char EQL %C'+') OR (.char EQL %C'-'))
			THEN
				BEGIN
				ch$wchar_a (.char, lexeme_ptr);
				sign_present = 1;
				char = ch$a_rchar (input_ptr);
				END;


			!++
			! If radix_state has already set the float_number
			! flag, check for a leading decimal point.
			!--

			IF (.float_number) AND (.char EQL asc_period)
			THEN	period_present = TRUE

				!++
				! The first character was not a period
				! so read the input buffer until a non-numeric
				! character is encountered. Ignore all leading
				! zeroes. Store each character in the 
				! buffer for the lexeme unless the length of
				! that buffer is expended.
				!--

			ELSE
				WHILE (.char EQL %C'0')
				DO
					BEGIN
					count = .count + 1;
					char = ch$a_rchar (input_ptr);
					END;

			!++
			! If the entire number was zero, put a single
			! zero in the lexeme buffer and return.
			!--

			input_stg_desc [dsc$w_length] = .input_stg_desc [dsc$w_length] - .count;
			count = .sign_present;
			IF .dbg$char_table [.char] NEQ numeric
				AND .dbg$char_table [.char] NEQ period
				AND NOT .period_present
				AND NOT (oneof (.dbg$char_table [.char], alpha_and_hex, alphalo_and_hex))
			THEN
				BEGIN
			!++
			! If char is a single quote (') we should eat it before
			! returning the zero.
			!--

				IF .char EQL %C'''' AND .quote_present
				THEN
					BEGIN
					input_ptr = ch$plus(.input_ptr, 1);
					input_stg_desc [dsc$w_length] = .input_stg_desc [dsc$w_length] - 1;
					END;


				ch$wchar (0, .lexeme_ptr);
				lexeme_stg_desc [dsc$w_length] = 1;
				input_stg_desc [dsc$a_pointer] = .input_ptr;
				RETURN digit_str_token
				END;

			!++
			! This is the normal store and pick up next
			! numeric character. This logic will pick up
			! all of a floating number to the left of the decimal
			! point as well as any number without a decimal point.
			!--

			IF (NOT .period_present) AND (.dbg$char_table [.char] NEQ period)
			THEN
				DO
					BEGIN
					IF .dbg$char_table[.char] EQL alphalo_and_hex
					THEN char = .char - upper_case_dif;
					count = .count + 1;
					IF .count GTR num_max_length
					THEN
						BEGIN


						ch$move (num_max_length - 1,
							ch$plus (ch$ptr (.lexeme_stg_desc [dsc$a_pointer]), 1),
							ch$ptr (.lexeme_stg_desc [dsc$a_pointer]));
						ch$wchar (.char, .lexeme_ptr-1);
						END
					ELSE ch$wchar_a (.char, lexeme_ptr);
					char = ch$a_rchar (input_ptr);


					END
				WHILE (oneof (.dbg$char_table [.char], numeric,
						alpha_and_hex, alphalo_and_hex));

			!++
			! BLISS may have a decimal point following the
			! string of digits (in floating point mode).
			! Look for the decimal point, if it is present as
			! the next character, set the period_present flag
			! and continue picking up numeric characters.
			!--

			IF (.char EQL asc_period) AND .float_number
			THEN IF NOT .period_present
			     THEN
				BEGIN
				period_present = TRUE;
				DO
					BEGIN
					count = .count + 1;
					IF .count LEQ .lexeme_stg_desc [dsc$w_maxlen]
					THEN ch$wchar_a (.char, lexeme_ptr);
					char = ch$a_rchar (input_ptr);
					END
				WHILE (.dbg$char_table[.char] EQL numeric);
				END;

			IF .float_number
			THEN	
				BEGIN

				!++
				! Now allow for a D or E form of floating
				! number, followed by an optional positive
				! or negative sign, followed by more digits.
				!--
				IF (.char GEQU %C'a')
				THEN char = .char - upper_case_dif;
				IF (.char EQL %C'D') OR (.char EQL %C'E')
				THEN
					BEGIN
				

					ch$wchar_a (.char, lexeme_ptr);
					count = .count + 1;
					char = ch$a_rchar (input_ptr);
					END;
				IF (.char EQL %C'+') OR (.char EQL %C'-')
				THEN
					BEGIN
					ch$wchar_a (.char, lexeme_ptr);
					count = .count + 1;
					char = ch$a_rchar (input_ptr);
					END;

				WHILE (.dbg$char_table[.char] EQL numeric)
				DO
					BEGIN
					count = .count + 1;
					IF .count LEQ .lexeme_stg_desc [dsc$w_maxlen]
					THEN ch$wchar_a (.char, lexeme_ptr);
					char = ch$a_rchar (input_ptr);
					END;
				END;




			!++
			! Store the length in the output lexeme buffer
			!--

			lexeme_stg_desc[dsc$w_length] = .count;
			!++
			! If the special radix flag is set, eat the trailing quote
			! but only if initial quote was there.
			!--


			IF .radix_flag
			THEN
				IF (.char EQL %C'''' AND .quote_present) 
				THEN	
					BEGIN
					char = ch$a_rchar(input_ptr);
					count = .count + 1;
					END
				ELSE
					IF (.char NEQ %C'''' AND .quote_present) OR
					   (.char EQL %C'''' AND NOT .quote_present)
					THEN
	       					BEGIN
						lexeme_stg_desc[dsc$w_length] = .count + 1;
						ch$wchar_a(.char, lexeme_ptr);
						SIGNAL(dbg$_imptermno, 1, .lexeme_stg_desc);  ! this call doesn't return
						RETURN(0);
						END;

			!++
			! Convert the number, restore the old radix,
			! and return the numeric lexeme.
			!--

			!++
			! See whether the user has said %LINE, in which
			! case a string must be returned instead of a
			! binary number.
			!--

			IF (NOT .period_present) AND (NOT .float_number)
			AND (.dbg$gb_mod_ptr[mode_fortran] NEQ line_mode)
			THEN
				BEGIN
				.lexeme_stg_desc[dsc$a_pointer] = dbg$radx_convrt (.lexeme_stg_desc);
				dbg$gb_mod_ptr [mode_radix] = .previous_radix;
				lexeme_stg_desc [dsc$w_length] = 4;


				END
			ELSE
				BEGIN
				IF .count GTR .lexeme_stg_desc [dsc$w_maxlen]
				THEN
					BEGIN
					lexeme_stg_desc [dsc$w_length] = .lexeme_stg_desc [dsc$w_maxlen];
					SIGNAL (dbg$_numtrunc);
					END;
				END;

			input_stg_desc [dsc$a_pointer] = .input_ptr;
			input_stg_desc [dsc$w_length] = .input_stg_desc [dsc$w_length] - .count;

			IF (.dbg$gb_mod_ptr[mode_fortran] EQL line_mode)
			THEN
			    BEGIN
			    IF .dbg$gb_mod_ptr[mode_radix] NEQ .previous_radix
			        OR .period_present
			    THEN
				BEGIN
				SIGNAL(dbg$_invnumber, 1, .lexeme_stg_desc);
				RETURN (0);
				END;
			    RETURN digit_str_token;
			    END
			ELSE
			    IF .float_number OR .period_present
			    THEN RETURN single_fl_token
			    ELSE RETURN digit_str_token
			END;

		[eocommand_state]:			! logical end of line
			BEGIN

			!++
			! The length of the input line should be set to
			! zero here. Reduce it one so that it is less than
			! zero. This will cause an error if this same
			! input line ever comes back to the lex routine.
			!--
			lexeme_stg_desc [dsc$w_length] = 0;
			input_stg_desc [dsc$a_pointer] = ch$plus (.input_ptr, 1);
			input_stg_desc [dsc$w_length] = .input_stg_desc [dsc$w_length] - 1;
			RETURN eol_token
			END;

		[radix_state]:				! percent sign

			BEGIN		! BLISS handling

			!++
			! The only recognized use of '%' is as an escape
			! character that precedes a radix qualifier. In
			! BLISS, '%' can be followed by 'D', 'O', 'X', or 
			! 'E' (floating point).
			!--

			quote_present = FALSE;

			char = ch$rchar(ch$plus(.input_ptr,1));
			IF (.char GEQU %C'a')			! lower case char
			   THEN char = .char - upper_case_dif;

			SELECTONE .char OF
			      SET
			      [%C'D']:	BEGIN
					!++
					! %DEC and %DECIMAL is the way DEBUG allows a decimal radix
					! qualifier to be specified. So if the input char is
					! a 'D' we must look ahead. 
					!--

					LOCAL
					  la_ptr,	! look ahead ptr
					  la_char;	!  "     "   char

					la_ptr = ch$plus (.input_ptr,2);
					la_char = ch$rchar_a (la_ptr);

					IF .la_char EQL %C'E' OR .la_char EQL %C'e'
					THEN
						! we have 'E', look for 'C'

						BEGIN	
						la_char = ch$rchar_a (la_ptr);
						
						IF .la_char EQL %C'C' OR .la_char EQL %C'c'
						THEN
						  ! We are OK, set radix flag etc.

						  BEGIN
						  dbg$gb_mod_ptr[mode_radix] = decimal_radix;
						  radix_flag = TRUE;					
						  input_ptr = ch$plus(.input_ptr,2);
						  input_stg_desc[dsc$w_length] = 
						    .input_stg_desc[dsc$w_length] - 2;
						  la_char = ch$rchar_a(la_ptr);
						  IF .la_char EQL %C'I' 
						  OR .la_char EQL %C'i'
						  THEN
						    BEGIN
						    la_char = ch$rchar_a(la_ptr);
						    IF .la_char EQL %C'M'
						    OR .la_char EQL %C'm'
						    THEN
						      BEGIN
						      la_char = ch$rchar_a(la_ptr);
						      IF .la_char EQL %C'A'
						      OR .la_char EQL %C'a'
						      THEN
							BEGIN
							la_char = ch$rchar(.la_ptr);
							IF .la_char EQL %C'L'
							OR .la_char EQL %C'l'
							THEN
							  BEGIN
							    input_ptr = ch$plus(.input_ptr, 4);
							    input_stg_desc[dsc$w_length] = 
							     .input_stg_desc[dsc$w_length] - 4;
							  END;
							END;
						      END;
						    END;
						  END

						! User blew it, try again

						ELSE
						  BEGIN
						  char = %C'%';
						  state = unspec_state;
						  END;
						END

					ELSE
						BEGIN
						char = %C'%';
						state = unspec_state;
						END;
					END;
			      [%C'O']:	BEGIN
					dbg$gb_mod_ptr[mode_radix] = octal_radix;
					radix_flag = TRUE;
					END;
			      [%C'X']:	BEGIN
					dbg$gb_mod_ptr[mode_radix] = hex_radix;
					radix_flag = TRUE;
					END;
			      [%C'E']:	BEGIN
					radix_flag = TRUE;
					float_number = TRUE;
					END;
			      [%C'L'] :
					BEGIN
					! Assume we are looking at 
					! a %LINE token.
					! Write the %
					ch$wchar_a(%c'%', lexeme_ptr);
					! Bump input_ptr since we
					! have already picked up the L
					input_ptr = ch$plus(.input_ptr,1);
					! Set a flag used in alpha_state.
					radix_to_alpha_flag = TRUE;
					! Go to alpha state
					state = alpha_state;
					END;
			      [OTHERWISE]: BEGIN
					char = %C'%';
					state = unspec_state;
					END;
			      TES;
			
			IF .radix_flag
			THEN
				!++
				! Check for optional first quote, but first move
				! input_ptr past radix designators
				!--

				BEGIN		
				input_ptr = ch$plus(.input_ptr,2);
				input_stg_desc[dsc$w_length] = .input_stg_desc[dsc$w_length] - 2;

				char = ch$rchar(.input_ptr);
				IF .char NEQ %C''''
				THEN		! Leading quote not present
					state = numeric_state
				ELSE		! Have a leading quote, eat it and go on. 

					BEGIN
					quote_present = TRUE;
					input_ptr = ch$plus(.input_ptr,1);
					char = ch$rchar(.input_ptr);
					input_stg_desc[dsc$w_length] = .input_stg_desc[dsc$w_length] - 1;
					state = numeric_state;
					END;
				END;
			END;

		[unspec_state]:				! special character like operator or illegal
			BEGIN

			!++
			! Most likely, this is a single character
			! operator. Write its ASCII value into the
			! lexeme buffer, and return its equivalent
			! token.
			!--
			LOCAL
				index;

			index = .dbg$char_table[.char];
			IF ((.index GEQ table_offset) AND (.index LEQ operator_max))
			THEN
				BEGIN
				ch$wchar (.char, .lexeme_ptr);
				lexeme_stg_desc[dsc$w_length] = 1;
				input_stg_desc[dsc$a_pointer] = ch$plus (.input_ptr, 1);
				input_stg_desc[dsc$w_length] = .input_stg_desc[dsc$w_length] - 1;
				RETURN .dbg$token_table[.index - table_offset]
				END;

			!++
			! This doesn't seem to be anything about which
			! we know. SIGNAL invalid character.
			!--
			SIGNAL (dbg$_invchar);
			END;

		TES;
	END;					! End of WHILE 1 loop.

	RETURN 1;
	END;					! end of dbg$bli_get_lex

GLOBAL ROUTINE dbg$bli_reductn (action_key, stack, lex_stg_desc, lahead_stg_desc, parse_stg_desc) =
!++
! Functional description:
!	Does the action associated with a reduction. The action is chosen
!	based on the action_key, which is the name of an action routine
!	as specified in the semantics table.
!
! Formal Parameters:
!	action_key	- name of the action routine
!	stack		- top of stack in the context of the reduction
!
! Implicit inputs:
!	the name of the parse stack : dbg$gl_stk
!
! Outputs:
!	none
!
! Routine value:
!	TRUE or FALSE
!
! Side effects:
!	The top of stack is often changed. arguments are put into
!	linked lists, context values are altered.
!--

    BEGIN

    LITERAL
	line_num = 0;

    GLOBAL
    	dbg$gl_modrstptr2; ! Holds module rst pointer during TYPE command.
        		   ! e.g., TYPE MOD1\10,20,30


    MAP
	lex_stg_desc	: REF BLOCK [ ,BYTE],
	lahead_stg_desc	: REF BLOCK [ ,BYTE],
	parse_stg_desc	: REF BLOCK [ ,BYTE];

    CASE .action_key FROM 1 TO blinone OF

	SET

	[blicomlin]:	BEGIN
			dbg$verify_out (.parse_stg_desc);
			IF NOT dbg$perform_cmd (.stack) 
			THEN 
				RETURN FALSE;
			END;

	[bliaddexa]:	dbg$add_arg (dbg$gl_stk[.stack+2, stk$v_base], 0);
	[bliaddsrc]:	dbg$add_arg (dbg$gl_stk[.stack+2, stk$v_base], -1);
	[bliaddexp]:	dbg$gl_stk [.stack, stk$v_val1] = .dbg$gl_stk [.stack, stk$v_val1]
			 + .dbg$gl_stk [.stack+2, stk$v_val1];
	[bliaddran]:	dbg$add_arg (dbg$gl_stk[.stack+2, stk$v_base],
					dbg$gl_stk[.stack+4, stk$v_base]);
	[bliaftcnt]:	dbg$get_step_count (.stack + 1, .lex_stg_desc);
	[bliandopr]:	dbg$gl_stk [.stack, stk$v_val1] = .dbg$gl_stk [.stack, stk$v_val1]
				 AND .dbg$gl_stk [.stack+2, stk$v_val1];
	[bliascclr]:	IF .dbg$gl_gbltyp EQL dsc$k_dtype_t
			THEN dbg$gl_gbltyp = -1;
	[bliasclen]:	dbg$save_ascii_leng(.lex_stg_desc);
	[blibreacb]:	dbg$gl_list[2] = dbg$get_bpt_act(.parse_stg_desc);
	[blicanarg]:	dbg$cancel_parm (.stack);
    	[blicanmod]:	dbg$gl_context[dbg$k_module] = TRUE;
	[blicanovr]:	dbg$gl_gbltyp = -1;
	[blicanswi]:	dbg$can_switch (.stack);
	[blicalsub]:	dbg$add_arg (dbg$gl_stk[.stack+1, stk$v_base], 0);
	[blidefarg]:	dbg$add_arg (dbg$gl_stk[.stack, stk$v_base],
					dbg$gl_stk[.stack+2, stk$v_base]);
	[blideflst]:	dbg$add_arg (dbg$gl_stk[.stack+2, stk$v_base],
					dbg$gl_stk[.stack+4, stk$v_base]);
	[blidefmod]:	BEGIN
			IF .dbg$gl_modrstptr2 EQL 0
			THEN
			dbg$gl_stk[.stack,stk$v_nt_ptr] =
			    dbg$sta_getsourcemod(0)
			ELSE
			dbg$gl_stk[.stack,stk$v_nt_ptr] =
			    .dbg$gl_modrstptr2;
			IF .dbg$gl_stk[.stack,stk$v_nt_ptr] EQL 0
			THEN 
			    SIGNAL(dbg$_noscope,
				.dbg$gl_stk[.stack,stk$v_val1]);
			END;
	[blidefnam]:	dbg$save_name (.stack, .lex_stg_desc);
	[blideploc]:	BEGIN
			dbg$add_arg (dbg$gl_stk [.stack, stk$v_base], 0);
			dbg$set_overs (override_mode, noimmed_n_token);
			END;
	[blidgptho]:	dbg$bld_num_pth(.lahead_stg_desc);
	[blidigpat]:	dbg$bld_num_pth(.lex_stg_desc);
	[blidigstr]:	dbg$trans_name(.stack, .lahead_stg_desc);
	[blidimadd]:	dbg$add_access_act (.stack + 2, 1);
	[blidimone]:	dbg$add_access_act (.stack, 0);
	[blidivexp]:	dbg$division (.stack);
	[blidfltyp]:	dbg$set_default_typ();
	[blieqvopr]:	dbg$gl_stk [.stack, stk$v_val1] = .dbg$gl_stk [.stack, stk$v_val1]
				 EQV .dbg$gl_stk [.stack+2, stk$v_val1];
	[bliexaone]:	dbg$add_arg (dbg$gl_stk[.stack, stk$v_base], 0);
	[bliaddone]:	dbg$add_arg (dbg$gl_stk[.stack, stk$v_base], -1);
	[bliexasrc]:	dbg$gl_stk[.stack,stk$v_val1] = exsource_token;
	[bliexpran]:	dbg$add_arg (dbg$gl_stk[.stack, stk$v_base],
					dbg$gl_stk[.stack+2, stk$v_base]);
	[bliextrv] :	BEGIN
			dbg$gl_stk[.stack, stk$v_fldrf] = 3;
			dbg$gl_stk[.stack, stk$v_pos]   = .dbg$gl_stk[.stack+2, stk$v_val1]; 
			dbg$gl_stk[.stack, stk$v_size]  = .dbg$gl_stk[.stack+4, stk$v_val1]; 
    			dbg$gl_stk[.stack,stk$v_size] = 
			    dbg$check_size_fld(.dbg$gl_stk[.stack, stk$v_size]);
			dbg$check_ext_fld(.dbg$gl_stk[.stack+6, stk$v_val1]);
			dbg$gl_stk[.stack, stk$v_ext]   = .dbg$gl_stk[.stack+6, stk$v_val1]; 
			dbg$gl_asci_len = .dbg$gl_stk[.stack, stk$v_size] / %BPUNIT;
			dbg$set_mod_lvl(override_mode);
			END;
	[bliextrzv]:	BEGIN
			dbg$gl_stk[.stack, stk$v_fldrf] = 2;
			dbg$gl_stk[.stack, stk$v_pos]   = .dbg$gl_stk[.stack+2, stk$v_val1]; 
			dbg$gl_stk[.stack, stk$v_size]  = .dbg$gl_stk[.stack+4, stk$v_val1]; 
    			dbg$gl_stk[.stack,stk$v_size] =
			    dbg$check_size_fld(.dbg$gl_stk[.stack, stk$v_size]);
			dbg$gl_stk[.stack, stk$v_ext]   = 0;
			dbg$gl_asci_len = .dbg$gl_stk[.stack, stk$v_size] / %BPUNIT;
			dbg$set_mod_lvl(override_mode);
			END;
	[bligetdir]:	BEGIN
			dbg$get_dir_list(.lex_stg_desc,.parse_stg_desc,.stack);
    			dbg$gl_set_source = FALSE;
			END;
	[bliindcom]:	dbg$cis_openicf();
	[bliindexp]:	dbg$bli_indirection (.stack);
	[bliinsclr]:	IF .dbg$gl_gbltyp EQL dsc$k_dtype_zi
			THEN dbg$gl_gbltyp = -1;
	[bliintstr]:	dbg$trans_name(.stack,.lex_stg_desc);
	[bligethlp]:	dbg$get_help(.parse_stg_desc);
	[bligeticf]:	dbg$cis_getfsp(.lex_stg_desc, .parse_stg_desc);
	[bligetfsp]:	BEGIN
			MAP dbg$gl_log_buf : REF VECTOR [,BYTE];
			dbg$gl_log_buf = dbg$get_filesp(.lex_stg_desc, .parse_stg_desc);
			END;
	[bliloctyp]:	dbg$set_local_type();
    	[blimodule]:	! We have just made a SET_MODULE -> SET MODULE or a
    			! CANCEL_MODULE -> CANCEL MODULE reduction.
    			dbg$gb_set_module_flag = TRUE;
    	[blimarone]:	BEGIN
    			! SET MARGIN R
    			! Right margin goes in val2,
    			! left margin in val1.
    			! Since only one margin was specified, it was the
    			! right margin so put it in val2
    			dbg$gl_stk[.stack,stk$v_val2] = 
    			    .dbg$gl_stk[.stack,stk$v_val1];
    			! The left margin is 1.
    			!
    	    		dbg$gl_stk[.stack,stk$v_val1] = 1;
    			END;
    	[blimartwo]:	BEGIN
    			! SET MARGINS L:R
    			! Right margin is in position stack+2.
    			! Put it on top of the stack in field val2.
    			dbg$gl_stk[.stack,stk$v_val2] = 
    			    .dbg$gl_stk[.stack+2,stk$v_val1];
    			END;
    	[blimarlef]:	BEGIN
    			! SET MARGIN L:
    			dbg$gl_stk[.stack,stk$v_val2] = -1;
    			END;
    	[blimarrig]: 	BEGIN
    			! SET MARGIN :R
    			dbg$gl_stk[.stack,stk$v_val1] = -1;
    			dbg$gl_stk[.stack,stk$v_val2] =
    			    .dbg$gl_stk[.stack+1,stk$v_val1];
    			END;
	[blimaxfil]:	BEGIN
			dbg$gl_context[dbg$k_maxfiles] = TRUE;
			END;
	[blimodexp]:	dbg$gl_stk [.stack, stk$v_val1] = .dbg$gl_stk [.stack, stk$v_val1]
				 MOD .dbg$gl_stk [.stack+2, stk$v_val1];
	[blimodcan]:	BEGIN
			dbg$gl_context[dbg$k_source] = TRUE;
			dbg$gl_module = .dbg$gl_stk[.stack+5,stk$v_val1];
			END;
	[blimodsou]:	BEGIN
			dbg$gl_context[dbg$k_source] = TRUE;
			dbg$gl_dirlist = .dbg$gl_stk[.stack+5,stk$v_val1];
			dbg$gl_module = .dbg$gl_stk[.stack+4,stk$v_val1];
			END;
	[blimulexp]:	dbg$gl_stk [.stack, stk$v_val1] = .dbg$gl_stk [.stack, stk$v_val1]
				 * .dbg$gl_stk [.stack+2, stk$v_val1];
	[blinegexp]:	dbg$negation (.stack);
	[blinotopr]:	dbg$bli_complement (.stack);
	[blioropr]:	dbg$gl_stk [.stack, stk$v_val1] = .dbg$gl_stk [.stack, stk$v_val1]
				 OR .dbg$gl_stk [.stack+2, stk$v_val1];
	[bliovrins]:	dbg$gl_gbltyp = dsc$k_dtype_zi;
	[bliovrasc]:	BEGIN
			    dbg$gl_gbltyp = dsc$k_dtype_t;
			    dbg$gw_gbllngth = 4;
			END;
	[bliovropl]:	dbg$set_overr_mode (.stack + 2);
	[bliovropr]:	dbg$set_overr_mode (.stack);
	[bliovropt]:	dbg$set_overr_mode (.stack + 1);
	[bliovrstl]:	dbg$set_overr_step (.stack + 2);
	[bliovrstp]:	dbg$set_overr_step (.stack + 1);
	[bliovrtyp]:	dbg$set_over_typ();
	[bliposexp]:	dbg$pop_stack (.stack);
	[bliquotec]:	BEGIN
			dbg$gl_stk [.stack, stk$v_val1] = dbg$extract_str (.parse_stg_desc);
			dbg$gl_stk [.stack, stk$v_val2] = .dbg$gl_stk [.stack, stk$v_val1];
			DBG$GL_STK [.STACK, STK$V_TYPE] = DSC$K_DTYPE_T;
			END;
	[blirempar]:	dbg$pop_stack (.stack);
	[blisavlno]:	! if path was %LINE FOO\10 then lexeme has line num,
			! else lahead does.
			IF ch$rchar (.lahead_stg_desc[dsc$a_pointer]) eql '\'
			THEN 
			    dbg$pars_linnum(.lex_stg_desc,line_num)
			ELSE
			    dbg$pars_linnum(.lahead_stg_desc,line_num);
	[blisavone]:	dbg$sav_pth_nam();
	[blisavpat]:	BEGIN
		        dbg$build_path (.lex_stg_desc, FALSE);
			END;
	[blisavmod]:	BEGIN
    			dbg$gl_stk [.stack, stk$v_val1] = dbg$find_module (.lex_stg_desc, TRUE);
    			IF .dbg$gl_set_source2
    			THEN
    			    dbg$gl_set_source = TRUE;
    			END;
	[blisavtyp]:	dbg$save_type(.stack);
	[blisvolpt]:	dbg$build_path(.lahead_stg_desc, FALSE);
    	[blisetsea]:	dbg$gl_context[dbg$k_search] = TRUE;
     	[blisearch]: 	BEGIN
    			! Call a routine which will parse the remainder of
    			! the input line. It will construct a command 
    			! execution network and leave a pointer to the
    			! result on the stack.
    			!
    			dbg$gl_search_verb = 
    			    dbg$parse_search (.parse_stg_desc);
    			END;
	[blisetbre]:	dbg$break_setup (.stack, .dbg$gl_stk [.stack + 2, stk$v_val1], 1);
	[blisetbra]:	dbg$break_setup (.stack, .dbg$gl_stk [.stack + 3, stk$v_val1],
					.list_elem_exp1(.dbg$gl_head_lst));
	[blisettrc]:	dbg$gl_context[dbg$k_trce_call] = TRUE;
	[blisettrb]:	dbg$gl_context[dbg$k_trce_brch] = TRUE;
	[blisetdec]:	dbg$set_dec_overs() ;
	[blisetlan]:	dbg$save_lang_name (.stack+2, .lex_stg_desc);
	[blisetlin]:	BEGIN
			dbg$set_line_dec(.stack);
			END;
	[blisetlog]:	dbg$gl_context[dbg$k_log] = TRUE;
    	[blisetmar]:	dbg$gl_context[dbg$k_margins] = TRUE;
	[blisetmdl]:	dbg$gl_context[dbg$k_module] = TRUE;
	[blisetmod]:	dbg$gl_context[dbg$k_mode] = TRUE;
	[blisetout]:	dbg$gl_context[dbg$k_output] = TRUE;
	[blisetsco]:	dbg$gl_context[dbg$k_scope] = TRUE;
	[blisetsou]: 	BEGIN
			dbg$gl_context[dbg$k_source] = TRUE;
			dbg$gl_dirlist = .dbg$gl_stk[.stack+1,stk$v_val1];
			dbg$gl_module = 0;
			END;
	[blisetstp]:	dbg$gl_context[dbg$k_step] = TRUE;
	[blishoarg]:	dbg$show_param (.stack);
	[blishocal]:	dbg$gl_context[dbg$k_traceback] = TRUE;
	[blishcall]:	BEGIN
			dbg$get_step_count (.stack + 1, .lex_stg_desc);
			dbg$gl_context[dbg$k_traceback] = TRUE;
			END;
	[blishfexp]:	dbg$gl_stk [.stack, stk$v_val1] = .dbg$gl_stk [.stack, stk$v_val1]
				 ^ .dbg$gl_stk [.stack+2, stk$v_val1];
	[blishotyp]:	dbg$show_type(default);
	[blishovtp]:	dbg$show_type(override);
    	[blisoucon]:	dbg$gl_set_source = TRUE;
	[blisrcmod]:	BEGIN
			dbg$gl_modrstptr2 = dbg$gl_stk[.stack,stk$v_nt_ptr] =
				.dbg$gl_stk[.stack,stk$v_val1];
			dbg$gl_stk[.stack,stk$v_val1] =
				.dbg$gl_stk[.stack+2,stk$v_val1];
			dbg$gl_stk[.stack,stk$v_val2] =
				.dbg$gl_stk[.stack+2,stk$v_val2];
			END;
	[blisrcone]:	BEGIN
			dbg$gl_stk[.stack,stk$v_val2] =
				.dbg$gl_stk[.stack,stk$v_val1];
			END;
	[blisrcran]:	BEGIN
			dbg$gl_stk[.stack,stk$v_val2] =
				.dbg$gl_stk[.stack+2,stk$v_val1];
			END;
	[blistaloc]:	dbg$add_arg (dbg$gl_stk[.stack+1, stk$v_base], 0);
	[blistcoun]:	dbg$get_step_count (.stack + 1, .lex_stg_desc);
	[blistpcnt]:	dbg$get_step_count (.stack + 2, .lex_stg_desc);
	[blistruct]:	reduce_struc (dbg$gl_stk [.stack, stk$v_base]);
	[blisubexp]:	dbg$gl_stk [.stack, stk$v_val1] = .dbg$gl_stk [.stack, stk$v_val1]
				 - .dbg$gl_stk [.stack+2, stk$v_val1];
	[blitrnlab]:	dbg$reduce_label(.stack, .lahead_stg_desc);
	[blitrnnam]:	dbg$reduce_bli_path (.stack);
	[bliuqunam]:	dbg$trans_name (.stack, .lex_stg_desc);
	[blixoropr]:	dbg$gl_stk [.stack, stk$v_val1] = .dbg$gl_stk [.stack, stk$v_val1]
				 XOR .dbg$gl_stk [.stack+2, stk$v_val1];
	[blinone]:	0;
		
	[inrange, outrange]:	RETURN FALSE;

	TES;

    RETURN TRUE
    END;

ROUTINE reduce_struc ( block_addr) : NOVALUE = 
!++
! Functional Description:
!	Fills in the appropriate access actual fields on the semantic stack
!	for a BLISS predefined structure reference. The access actuals are 
!	taken from the access_list vector built by the dbg$add_access_act MACRO
!	in an earlier reduction. Before putting the actuals on the stack they
!	are checked for validity.
!
! Formal Parameters:
!	block_addr	- address of the stack element whose access actual 
!			  fields will be filled in.
!
! Implicit Inputs:
!	dbg$access_list	- the VECTOR containing the access actuals
!
! Outputs:
!	none
!
! Implicit Outputs:
!	The stack fields are changed
!
! Routine Value:
!	none
!
! Side Effects:
!	The access_list is reset to zero. SIGNAL if an access actual is invalid.
!	The value contained in the stk$v_val1 field is the byte address of the
!	location being processed (i.e. the I and O access actuals for the
!	structure reference have been applied).
!--
	BEGIN
	
	MAP
		block_addr : REF BLOCK FIELD (stack_fields);

	LOCAL
		blz_rec : REF blz_record,
		 nt_rec : REF  rst$entry;

	MACRO
		check_fields (no_of_actuals) =
			IF .dbg$access_list [0] NEQ no_of_actuals
			THEN
			    SIGNAL (dbg$_invaccess, 2, no_of_actuals, .dbg$access_list[0])%,

		check_valid_i (no, o, p, s, e) =
			IF .dbg$access_list [no] GEQU .blz_rec [o, p, s, e] 
			AND .block_addr[stk$v_ref] NEQ 1
			AND .blz_rec [o, p, s, e] NEQ 0
			THEN
			    SIGNAL (dbg$_strucsize, 2, .blz_rec[o,p,s,e], .dbg$access_list[no])%;


	! get the address of the BLZ entry for this structure

	nt_rec = .block_addr [stk$v_nt_ptr];
	IF .nt_rec NEQ 0
	THEN
		blz_rec = .nt_rec[rst$l_dstptr];

	
	! Fill in the appropriate access actual fields on the semantic stack.
	! The stk$v_val1 field will contain the byte address of the location
	! being processed (The nearest byte for BITVECTOR).
 

	! If the ref bit is set, we want an extra level of indirection
	
	IF .block_addr[stk$v_ref] EQL 1
	THEN
		block_addr[stk$v_val1] = ..block_addr[stk$v_val1];

	CASE .block_addr [stk$v_struc] FROM no_struc TO blockvec OF
	SET
	  [no_struc]: 	IF .nt_rec NEQ 0
			THEN
				SIGNAL (dbg$_notastruct, 1,
					dbg$rst_name_addr(.nt_rec))
			ELSE
				SIGNAL (dbg$_notastruct, 1,
					UPLIT BYTE(%ASCIC 'NONAME'));

	  [vectr]  :	BEGIN
			check_fields(1);	! may not return
			check_valid_i(1, u_alloc_struc);
			block_addr [stk$v_index] = .dbg$access_list [1];
			block_addr [stk$v_size]  = .blz_rec [unit_size_vec] * %BPUNIT;
			block_addr [stk$v_ext]   = .blz_rec [sign_ext_vec];
			block_addr [stk$v_val1]  = .block_addr[stk$v_val1] + 
				.dbg$access_list[1] * .blz_rec[unit_size_vec];
			dbg$gl_asci_len = .block_addr[stk$v_size] / %BPUNIT;
			END;
	  [bitvec]  :	BEGIN
			check_fields(1);	! may not return
			check_valid_i(1, u_alloc_struc);
			block_addr [stk$v_index] = .dbg$access_list [1];
			block_addr [stk$v_size]  = 1;
		
			! For BITVECTOR, the val1 field is the address of the byte that
			! contains the referenced bit. The position field points

			! to the referenced bit within the byte

			block_addr [stk$v_val1]  = .block_addr[stk$v_val1] +
		         				.dbg$access_list[1]/8 ;
			block_addr [stk$v_pos] = .dbg$access_list[1] MOD %BPUNIT;
			dbg$gl_asci_len = 0;	! for char string deposits
			END;
	  [blok]   :	BEGIN
			check_fields(4);			! may not return
			check_valid_i(1, u_alloc_struc);
			block_addr [stk$v_offset] = .dbg$access_list [1];
			block_addr [stk$v_pos] = .dbg$access_list [2];
    			dbg$access_list[3] =
			    dbg$check_size_fld (.dbg$access_list[3]);
			block_addr [stk$v_size] = .dbg$access_list [3];
			dbg$check_ext_fld (.dbg$access_list [4]);
			block_addr [stk$v_ext]  = .dbg$access_list [4];
			block_addr [stk$v_val1] = .block_addr[stk$v_val1] +
				.dbg$access_list[1] * .blz_rec[unit_size_block];
			dbg$gl_asci_len = .block_addr[stk$v_size] / %BPUNIT;
			END;
	  [blockvec]:	BEGIN
			check_fields(5);			! may not return
			! checks no of blocks allocated for the vector, may not return

			check_valid_i(1, u_alloc_struc);
			block_addr [stk$v_index] = .dbg$access_list [1];
			check_valid_i(2, u_alloc_bvec);
			block_addr [stk$v_offset] = .dbg$access_list [2];
			block_addr [stk$v_pos] = .dbg$access_list [3];
    			dbg$access_list[4] =
			    dbg$check_size_fld (.dbg$access_list[4]);
			block_addr [stk$v_size] = .dbg$access_list [4];
			dbg$check_ext_fld (.dbg$access_list [5]);
			block_addr [stk$v_ext]  = .dbg$access_list [5];
			block_addr [stk$v_val1] = .block_addr[stk$v_val1] +
				((.dbg$access_list[1] * .blz_rec[u_alloc_bvec]) +
				.dbg$access_list[2]) * .blz_rec[unit_size_bvec] ;
			dbg$gl_asci_len = .block_addr[stk$v_size] / %BPUNIT;
			END;
	TES;
	
	!	Set the bit to indicate that access actuals were supplied in
	!	the DEBUG command line.  We will use this info for structure 
	!	reference symbolization

	block_addr [stk$v_args] = 1;

	!
	!	clear out access actual vector now that we are done
	!
		zerocor(dbg$access_list, 6);
		dbg$set_mod_lvl(override_mode);		
	END;
END
ELUDOM				! end of DBGBLI.B32

