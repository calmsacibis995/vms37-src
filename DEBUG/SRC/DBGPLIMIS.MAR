;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
	.page
	.title dbgplimis
	.ident/v02-001/
	.subtitle primary out
;
;GLOBAL ROUTINE DBG$NPLI_PRIM_OUT (prim_desc, string_desc, message_vect) =
;++
; FUNCTIONAL DESCRIPTION:
;
;       Uses a symbol's primary descriptor to construct an ascii string
;	descriptor which reflects both the symbolic information associated
;	with the symbol, and the rvalue associated with a symbol. This is of
;	the form:
;
;       MODULE\ROUTINE INVOCATION_NUMBER\[LEXICAL_ENTITY] ...
;							\SYMBOL_NAME: VALUE
;
;       Note that the capability to output aggregate values, such as an entire
;       array, will be required in a future release of DEBUG.
;
; FORMAL PARAMETERS:
;
;       prim_desc       - A longword containing the address of a primary
;			  descriptor
;
;       string_desc     - A longword containing the address of a VAX standard
;                         string descriptor with length and pointer fields set
;                         to 0
;
;       message_vect    - The address of a longword to contain the address of a
;                         message argument vector as described on page 4-119
;                         of the VAX/VMS system reference, volume 1A
;
; IMPLICIT INPUTS:
;
;       NONE
;
; IMPLICIT OUTPUTS:
;
;       Dynamic storage must be allocated to contain the ascii string described
;       by string_desc on a successful return.
;
;       In case of a severe error return, a message argument vector must be
;       constructed from dynamic storage and returned.
;
; ROUTINE VALUE:
;
;       An unsigned integer longword completion code
;
; COMPLETION CODES:
;
;       STS$K_SUCCESS (1) - Success. Information recovered and returned as an
;                           ascii string.
;
;       STS$K_SEVERE  (4) - Failure. Ascii string not constructed. Message
;                           argument vector constructed and returned.
;
; SIDE EFFECTS:
;
;       NONE
;
;--
;
	$dscdef
	$dbgdef
	$stsdef
	$dbglib
	$plidef
	$chfdef
;
; PARAMETER OFFSETS
;
ap_prim_desc    =  4
ap_string_desc  =  8
ap_message_vect = 12
	.psect	dbg$code,exe,nowrt,long,pic,shr
	.entry	dbg$npli_prim_out,^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11> ;
;
; register usage
;
;	r6	pointer to a string descriptor
;	r7	length of symbol string
;	r8	address of symbol string
;	r9	pointer to value descriptor
;	r10	length of data string
;	r11	address of data string
;
; get symbol string:
;
	moval	accvio_cdh,(fp)		;establish access violation condition
					;handler
	pushl	ap_message_vect(ap)	;pass message vector pointer longword
	pushl	ap_string_desc(ap)	;string descriptor pointer
	pushl	ap_prim_desc(ap)	;primary descriptor
	calls	#3,dbg$npli_symbolize	;get name string of symbol
	blbs	r0,10$			;branch if ok
	ret				;
10$:					;
	movl	ap_string_desc(ap),r6	;point to string descriptor
	movzwl	dsc$w_length(r6),r7	;length of symbol string
	movl	dsc$a_pointer(r6),r8	;address of symbol string
;
; make a value descriptor
;
	moval	-(sp),r9		;will hold address of value descriptor
	pushl	ap_message_vect(ap)	;message vector address passed on
	pushl	r9			;value descriptor pointer
	pushl	#1			;target desc. used by type convert rtn.
	pushl	ap_prim_desc(ap)	;pointer to primary descriptor
	calls	#4,dbg$npli_make_val_desc ;make a value descriptor
	blbs	r0,20$			;branch if ok
	ret				;
;
; convert to printable form
;
20$:	pushl	ap_message_vect(ap)	;pointer to message vector
	pushl	r6			;target descriptor
	pushl	#dbg$k_external_desc	;target type
	pushl	#dbg$k_default		;target radix
	pushl	(r9)			;value descriptor
	calls	#5,dbg$npli_type_conv	;convert to printable form
	blbs	r0,30$			;branch if ok
	ret				;
;
; construct the complete output string
;
30$:	movzwl	dsc$w_length(r6),r10	;length of data string
	movl	dsc$a_pointer(r6),r11	;address of data string
	pushl	ap_message_vect(ap)	;pointer to message vector
	pushal	dsc$a_pointer(r6)	;free storage pointer
	addl3	r10,r7,r0		;length of data + length of symbol
	incl	r0			;account for character ":"
	movw	r0,dsc$w_length(r6)	;new length
	addl2	#3,r0			;preparation for rounding to longwords
	ashl	#-2,r0,-(sp)		;convert to the number of longwords
	calls	#3,dbg$nlist_freez	;get listed storage
	blbs	r0,40$			;branch if ok
	ret				;
40$:	movl	dsc$a_pointer(r6),r3	;point to free storage
	movc3	r7,(r8),(r3)		;move in symbol string
	movb	#^a/:/,(r3)+		;put in separator
	movc3	r10,(r11),(r3)		;put in data string
	movl	#sts$k_success,r0	;successful return
	ret				;
;
;condition handler
;
accvio_cdh: .word	^m<r2,r3,r4,r5>	;access violation condition handler
	movl	chf$l_sigarglst(ap),r3	;point to signal arguments
	cmpl	#ss$_accvio,chf$l_sig_name(r3) ;access violation
	beql	10$			;branch if access violation
	movl	#ss$_resignal,r0	;resignal the error
	ret				;
10$:					;access violation
	movl	chf$l_mcharglst(ap),r4	;point to mechanism list
	$unwind_s chf$l_mch_depth(r4),20$ ;unwind the frames
	ret				;error
20$:					;
;
; register	use
;	r7	length of symbol string
;	r8	address of symbol string
	addl3	#4,r7,r0		;string length + byte count + round
	pushl	#0			;pointer to free storage
	pushl	ap_message_vect(ap)	;pass along message vector
	pushal	4(sp)			;point to free storage pointer
	ashl	#-2,r0,-(sp)		;number of longwords
	calls	#3,dbg$nlist_freez	;get the free storage
	blbs	r0,30$			;branch if ok
	ret				;
30$:	movl	(sp),r0			;point to free storage
	movb	r7,(r0)			;put in byte count
	movc3	r7,(r8),1(r0)		;copy string
;
;note that address of counted string is still on stack
;	
	pushl	#1			;one fao argument
	pushl	#dbg$_accaddcom		;access violation in computation
	calls	#3,dbg$nmake_arg_vect	;make the argument vector
	movl	r0,@ap_message_vect(ap)	;update vector pointer
	movl	#sts$k_severe,r0	;severe error
	ret				;
	.page
	.subtitle	get lval
;
;GLOBAL ROUTINE DBG$NPLI_GET_LVAL (prim_desc, lvalue, message_vect) =
;++
; FUNCTIONAL DESCRIPTION:
;
;       Obtains a symbol's lvalue using the primary descriptor for that
;       symbol. Note that most types of named constants do not have an
;       lvalue. The debugger gives special treatment to named constants
;       which have read only memory allocated to contain their value.
;
; FORMAL PARAMETERS:
;
;       prim_desc       - A longword which contains the address of a primary
;			  descriptor
;
;       lvalue          - The address of a quadword to contain the lvalue of
;			  the entity described by the primary descriptor and
;			  the bit offset, if any. The byte address will be
;			  contained in the first longword, the bit offset in
;			  the second longword.
;
;       message_vect    - The address of a longword to contain the address of
;                         a message argument vector as described on page 4-119
;                         of the VAX/VMS system reference, volume 1A
;
; IMPLICIT INPUTS:
;
;       NONE
;
; IMPLICIT OUTPUTS:
;
;       NONE
;
; ROUTINE VALUE:
;
;       An unsigned longword integer completion code
;
; COMPLETION CODES:
;
;       STS$K_SUCCESS (1) - Success. The object described by the input primary
;                           descriptor has an lvalue which is being returned.
;
;       STS$K_ERROR   (2) - Failure. Object does not have an lvalue. 
;
; SIDE EFFECTS:
;
;       NONE
;
;--
;
; PARAMETER LIST OFFSETS
ap_prim_desc = 4			;address of primary descriptor
ap_lvalue = 8				;quadword lvalue
ap_message_vect = 12			;address of message vector pointer
	.entry	dbg$npli_get_lval,^m<r2>;
	movl	ap_prim_desc(ap),r0	;point to primary descriptor
	cmpb	#dbg$k_primary_desc,dsc$b_dtype(r0) ;is it a prim. desc. ?
	bneq	bad_pd			;branch if bad primary descriptor
	pushl	#0			;will hold name node pointer
	pushl	ap_message_vect(ap)	;pass along message vector
	pushal	4(sp)			;holds pointer to name node
	pushl	r0			;primary descriptor address
	calls	#3,pli_pd_to_name_node ;return address of name node	
	blbs	r0,10$			;branch if ok
	ret				;
10$:	movl	(sp)+,r2		;point to name node
	movl	pli_node_nam_desc_ptr(r2),r0 ;point to main structure descrip.
	cmpl	#dbg$k_val_literal,pli_struct_desc_valkind(r0) ;literal value?
	beql	30$			;branch if literal (no lvalue)
	cmpl	#dbg$k_val_addr,pli_struct_desc_valkind(r0) ;use dataptr?
	beql	20$			;branch if so
	cmpl	#dbg$k_value_desc,pli_struct_desc_valkind(r0) ;use dataptr?
	beql	20$			;branch if value descriptor
	tstl	pli_struct_desc_valkind(r0) ;not filled in (e.g.
					;ex/word p->i  )
	bneq	bad_pd			;branch if not one of the above
20$:					;
	movl	pli_node_nam_vd_ptr(r2),r0 ;point to value descriptor
	movl	ap_lvalue(ap),r1	;point to dataptr quadword
	movl	pli_vd$a_ptr(r0),(r1)+	;put in address
	movl	pli_vd$l_boff(r0),(r1)	;bit offset
	movl	#sts$k_success,r0	;success return code, is lvalue
	ret				;
30$:	movl	#sts$k_error,r0		;error return code, is rvalue
	ret				;
not_yet:				;signal not yet implemented message
	movl	#pli$k_not_yet,r0	;not yet implemented code
	brb	bug_check		;merge with common code
never_error:				;signal that this should never happen
	movl	#pli$k_never,r0		;never happen error message code
	brb	bug_check		;merge with bug check code
bad_pd:	movl	#pli$k_prim_desc,r0	;bad primary descriptor code
bug_check:				;signal bug check errors
	pushl	r0			;holds type of error
	pushl	#1			;1 fao argument
	pushl	#dbg$_debugbug		;code to signal
	calls	#3,lib$signal		;signal error
	ret				;should never return here
	.page
	.subtitle get rval
;
;GLOBAL ROUTINE DBG$NPLI_GET_RVAL (prim_desc, rvalue, message_vect) =
;++
; FUNCTIONAL DESCRIPTION:
;
;       Uses a symbol's primary descriptor to obtain an rvalue for that symbol.
;       This rvalue is assumed by the debugger to be an integer longword. Byte
;       and word integers should be extended to longword size. If the rvalue
;       of the entity is not representable by a longword integer, then this
;       routine should fail (This is the case for floating point, complex, etc.
;       rvalues).
;
;       This routine is used to materialize the rvalue of a symbol in the
;       following two cases:
;
;               1) When the GET_TYPE routine has indicated that a symbol
;                  has a type of named-constant and the value of the constant
;                  must be obtained.
;
;               2) When the special DEBUG fetch operator has been applied to
;                  a symbol in an address expression. Note that when the
;                  fetch operator has been applied to a routine or label
;                  variable, a type of instruction must be associated with the
;                  rvalue. This routine uses a special return to indicate
;                  this circumstance. In all other cases, the rvalue is assumed
;                  to be untyped.
;
; FORMAL PARAMETERS:
;
;       prim_desc       - A longword containing the address of a primary
;			  descriptor
;
;       rvalue          - The address of a longword to contain the object's
;			  rvalue
;
;       message_vect    - The address of a longword to contain the address of a
;                         message argument vector as described on page 4-119 of
;                         the VAX/VMS system reference, volume 1A
;
; IMPLICIT INPUTS:
;
;       NONE
;
; IMPLICIT OUTPUTS:
;
;       In case of a severe error return, a message argument vector must be 
;       constructed from dynamic storage and returned.
;
; ROUTINE VALUE:
;
;       An unsigned integer longword completion code
;
; COMPLETION CODES:
;
;       STS$K_SUCCESS (1) - Success. The rvalue of the object described by the
;                           input primary descriptor is returned.
;
;       STS$K_WARNING (0) - Warning. The rvalue of the object described by the
;                           input primary descriptor is returned, but a type
;                           of instruction must be associated with it.
;
;       STS$K_SEVERE  (4) - Failure. The rvalue could not be obtained for the
;                           object, or the rvalue is not expressable by an 
;                           integer longword. Message argument vector
;                           constructed and returned.
;
; SIDE EFFECTS:
;
;       NONE
;
;--
;
; READ ONLY DATA:
;
	.psect	dbg$own,noexe,pic,long	;
exp_long_list:	.byte	exp_long_list_e - exp_long_list ;length of list
		.byte	dsc$k_dtype_bu	;unsigned byte
		.byte	dsc$k_dtype_wu	;unsigned word
		.byte	dsc$k_dtype_lu	;unsigned longword
		.byte	dsc$k_dtype_b	;byte
		.byte	dsc$k_dtype_w	;word
		.byte	dsc$k_dtype_l	;longword
exp_long_list_e:			;end of list
;
; CODE
;
	.psect	dbg$code,exe,nowrt,long,pic,shr ;	
;
;	register	use
;	r5		primary descriptor
;	r4		name node
;	r3		value descriptor associated with name
;	r2		structure descriptor associated with name
ap_prim_desc=4
ap_rvalue=8
ap_message_vect=12
	.entry	dbg$npli_get_rval,^m<r2,r3,r4,r5>
	movl	ap_prim_desc(ap),r5	;point to primary descriptor
	cmpb	#dbg$k_primary_desc,dsc$b_dtype(r5) ;is it a prim. desc. ?
	bneq	bad_pd			;branch if bad primary descriptor
	pushl	#0			;will hold name node pointer
	pushl	ap_message_vect(ap)	;pass along message vector
	pushal	4(sp)			;holds pointer to name node
	pushl	r5			;primary descriptor address
	calls	#3,pli_pd_to_name_node ;return address of name node	
	blbs	r0,10$			;branch if ok
	ret				;
10$:	movl	(sp)+,r4		;point to name node
	movl	pli_node_nam_vd_ptr(r4),r3 ;point to value descriptor
	movl	pli_node_nam_desc_ptr(r4),r2 ;point to structure descriptor
	casel	pli_node_nam_kind(r4),- ;check the original kind value
		#rst$k_kind_minimum,#<rst$k_kind_maximum- ;
		-rst$k_kind_minimum>	;
20$:
	.repeat	<rst$k_kind_maximum - rst$k_kind_minimum + 1>
	.word	30$		- 20$
	.endr
.=20$ + <2 * <rst$k_module-rst$k_kind_minimum>>
	.word	110$		- 20$	;module
.=20$ + <2 * <rst$k_routine-rst$k_kind_minimum>>
	.word	110$		- 20$	;routine
.=20$ + <2 * <rst$k_block-rst$k_kind_minimum>>
	.word	110$		- 20$	;block
.=20$ + <2 * <rst$k_label-rst$k_kind_minimum>>
	.word	110$		- 20$	;label
.=20$ + <2 * <rst$k_line-rst$k_kind_minimum>>
	.word	110$		- 20$	;line
.=20$ + <2 * <rst$k_data-rst$k_kind_minimum>>
	.word	200$		- 20$	;data
.=20$ + <2 * <rst$k_type-rst$k_kind_minimum>>
	.word	300$		- 20$	;type
.=20$ + <2 * <rst$k_entry-rst$k_kind_minimum>>
	.word	110$		- 20$	;entry
.=20$ + <2 * <rst$k_notunique-rst$k_kind_minimum>>
	.word	20$		- 20$	;not unique (can't happen)
.=20$ + <2 * <rst$k_typcomp-rst$k_kind_minimum>>
	.word 	300$		- 20$	;type component
.=20$ + <2 * <rst$k_variant-rst$k_kind_minimum>>
	.word	300$		- 20$	;variant
.=20$ + <2 * <rst$k_kind_maximum-rst$k_kind_minimum+1>> ;reset location
					;counter past case
30$:	brw	never_error		;this should never happen
;
;type is label or entry variable. Use special return to indicate same.
;
100$:					;
	movl	pli_vd$a_ptr(r3),@ap_rvalue(ap) ;put in longword
	movl	#sts$k_warning,r0	;warning return for type instruction
	ret				;
;
;type is line
;
110$:	movl	pli_vd$a_ptr(r3),@ap_rvalue(ap) ;put in longword
	movl	#sts$k_success,r0	;successful return
	ret				;
;
;type is data
;
200$:					;
	casel	pli_struct_desc_fcode(r2),-;case on original fcode value
		#rst$k_type_minimum,#<rst$k_type_maximum- ;
		-rst$k_type_minimum>	;
210$:					;
	.repeat	<rst$k_type_maximum - rst$k_type_minimum + 1> ;
	.word	30$		- 210$	;type is invalid unless specifically
	.endr				;specified below
.=210$ + <2 * <rst$k_type_array-rst$k_type_minimum>> ;
	.word	400$		- 210$	;array
.=210$ + <2 * <rst$k_type_atomic-rst$k_type_minimum>> ;
	.word	500$		- 210$	;atomic data type
.=210$ + <2 * <rst$k_type_descr-rst$k_type_minimum>> ;
	.word	600$		- 210$	;descriptor
.=210$ + <2 * <rst$k_type_enum-rst$k_type_minimum>> ;
	.word	300$		- 210$	;enumeration
.=210$ + <2 * <rst$k_type_pict-rst$k_type_minimum>> ;
	.word	300$		- 210$	;picture
.=210$ + <2 * <rst$k_type_tptr-rst$k_type_minimum>> ;
	.word	300$		- 210$	;typed pointer
.=210$ + <2 * <rst$k_type_record-rst$k_type_minimum>> ;
	.word	300$		- 210$	;record
.=210$ + <2 * <rst$k_type_set-rst$k_type_minimum>> ;
	.word	300$		- 210$	;set
.=210$ + <2 * <rst$k_type_subrng-rst$k_type_minimum>> ;
	.word	300$		- 210$	;subrange
.=210$ + <2 * <rst$k_type_subset-rst$k_type_minimum>> ;
	.word	300$		- 210$	;subset
.=210$ + <2 * <rst$k_type_union-rst$k_type_minimum>> ;
	.word	300$		- 210$	;union
.=210$ + <2 * <rst$k_type_cobhack-rst$k_type_minimum>> ;
	.word	300$		- 210$	;cobol hack
.=210$ + <2 * <rst$k_type_blidata-rst$k_type_minimum>> ;
	.word	300$		- 210$	;bliss data item
.=210$ + <2 * <rst$k_type_blifld-rst$k_type_minimum>> ;
	.word	300$		- 210$	;bliss field
.=210$ + <2 * <rst$k_type_file-rst$k_type_minimum>> ;
	.word	300$		- 210$	;file
.=210$ + <2 * <rst$k_type_ptr-rst$k_type_minimum>> ;
	.word	250$		- 210$	;pointer


.=210$ + <2 * <rst$k_type_maximum-rst$k_type_minimum+1>> ;reset location
					;counter to end of case
	brw	30$			;invalid type
;
;pointer type
;
250$:					;
;***temp change, this is too general, pointers must be byte aligned
	movl	pli_vd$l_boff(r3),r0	;get bit offset
	beql	270$			;branch if no bit offset
	extv	r0,#32,@pli_vd$a_ptr(r3),@ap_rvalue(ap) ;move the
					;bit field
	brb	280$			;
270$:	movl	@pli_vd$a_ptr(r3),@ap_rvalue(ap) ;value of pointer
280$:					;
	brw	900$			;successful return


;
;no longword rvalue that is any conceivable address
;so we make a severe error return
;
300$:					;not valid rvalue (not pointer)
	movl	pli_node$a_str(r4),r3	;addr of original name string
	movzwl	pli_node$w_sl(r4),r2	;length of string
	addl3	#4,r2,r0		;string length + byte count + round
	pushl	#0			;pointer to free storage
	pushl	ap_message_vect(ap)	;pass along message vector
	pushal	4(sp)			;point to free storage pointer
	ashl	#-2,r0,-(sp)		;number of longwords
	calls	#3,dbg$nlist_freez	;get the free storage
	blbs	r0,330$			;branch if ok
	ret				;
330$:	movl	(sp),r0			;point to free storage
	movb	r2,(r0)			;put in byte count
	movc3	r2,(r3),1(r0)		;copy string
;
;note that address of counted string is still on stack
;	
	pushl	#1			;one fa0 argument
	pushl	#dbg$_valnotaddr	;only valid if address
	calls	#3,dbg$nmake_arg_vect	;make the message
	movl	r0,@ap_message_vect(ap)	;update message vector
	movl	#sts$k_severe,r0	;severe error
	ret				;
;
;type array
;
400$:					;
	brb	300$			;can't use any of these as addresses
;
;type atomic
;
500$:					;
	cmpl	#fixed_bin_,pli_vd$l_type(r3) ;is it fixed binary data type?
	bneq	300$			;branch to signal "not usable"
	cmpl	#31,pli_vd$l_size(r3)	;fixed bin(31)?
	beql	250$			;use as a pointer
	brb	300$			;not usable as an address
;
;type descriptor
;
600$:					;
	brb	300$			;can't use any of these as addresses
;
;exit code
;
900$:					;
	movl	#sts$k_success,r0	;success status returned for call
	ret				;
	.page
	.subtitle	get type
;
;GLOBAL ROUTINE DBG$NPLI_GET_TYPE (prim_desc, type, message_vect) =
;++
; FUNCTIONAL DESCRIPTION:
;
;       Uses a symbol's primary descriptor to return type information. The
;       types recognized are limited to three:
;
;       1)      - type named constant and instruction 
;                 (lexical entities, labels)
;
;       2)      - type named constant and
;                 noinstruction (symbolic literals)
;
;       3)      - type other
;
;       The debugger uses kernel resources to display instructions. Therefore,
;       it must have enough information to decide when to do this. Also,
;	special handling is given to symbolic literals. This routine provides
;	enough information to allow the DEBUG kernel to handle these special
;	cases.
;
; FORMAL PARAMETERS:
;
;       prim_desc       - A longword containing the address of a primary
;	descriptor
;
;       type            - The address of a longword to contain an unsigned
;			  integer encoding of the symbol's type as follows:
;
;               dbg$k_nc_instruction (125)      - named constant, instruction
;       
;               dbg$k_nc_other (126)            - named constant, noinstruction
;
;               dbg$k_other (127)               - other
;
;       message_vect    - The address of a longword to contain the address of
;                         a message argument vector as described on page 4-119
;                         of the VAX/VMS system reference, volume 1A
;
; IMPLICIT INPUTS:
;
;       NONE
;
; IMPLICIT OUTPUTS:
;
;       In case of a severe error return, a message argument vector is
;	constructed from dynamic storage and returned.
;
; ROUTINE VALUE:
;
;       An unsigned integer longword completion code
;
; COMPLETION CODES:
;
;       STS$K_SUCCESS (1) - Success. Type information recovered and returned.
;
;       STS$K_SEVERE  (4) - Failure. No type information recovered. Message
;                           argument vector constructed and returned.
;
; SIDE EFFECTS:
;
;       NONE
;
;--
;
; REGISTER USAGE
;
;	register	use
;	r5	primary descriptor pointer
;	r4	name node pointer
;	r3	value descriptor pointer
;	r2	structure descriptor
;
; PARAMETER LIST OFFSETS
ap_prim_desc     =  4			;address of primary descriptor
ap_type          =  8			;address of output longword for type
ap_message_vect  = 12			;address of pointer to message vector
	.entry	dbg$npli_get_type,^m<r2,r3,r4,r5> ;
	movl	ap_prim_desc(ap),r5	;point to primary descriptor
	cmpb	#dbg$k_primary_desc,dsc$b_dtype(r5) ;is it a prim. desc. ?
	bneq	80$			;branch if bad primary descriptor
	pushl	#0			;will hold name node pointer
	pushl	ap_message_vect(ap)	;pass along message vector
	pushal	4(sp)			;holds pointer to name node
	pushl	r5			;primary descriptor address
	calls	#3,pli_pd_to_name_node ;return address of name node	
	blbs	r0,10$			;branch if ok
	ret				;
10$:	movl	(sp)+,r4		;point to name node
	movl	pli_node_nam_vd_ptr(r4),r3 ;point to value descriptor
	movl	pli_node_nam_desc_ptr(r4),r2 ;point to structure descriptor
	cmpl	#dbg$k_val_literal,pli_struct_desc_valkind(r2) ;literal value?
	beql	90$			;it is a named constant
	cmpl	#dbg$k_val_addr,pli_struct_desc_valkind(r2) ;value an address?
	beql	90$			;branch if so
	brb	900$			;not a named constant
80$:	brw	bad_pd			;branch to signal bad prim. desc.
90$:	casel	pli_node_nam_kind(r4),- ;check the original kind value
		#rst$k_kind_minimum,#rst$k_kind_maximum- ;
		-rst$k_kind_minimum	;
100$:
	.repeat	<rst$k_kind_maximum - rst$k_kind_minimum + 1>
	.word	200$		- 100$
	.endr
.=100$ + <2 * <rst$k_module-rst$k_kind_minimum>>
	.word	850$		- 100$	;module
.=100$ + <2 * <rst$k_routine-rst$k_kind_minimum>>
	.word	850$		- 100$	;routine
.=100$ + <2 * <rst$k_block-rst$k_kind_minimum>>
	.word	850$		- 100$	;block
.=100$ + <2 * <rst$k_label-rst$k_kind_minimum>>
	.word	850$		- 100$	;label
.=100$ + <2 * <rst$k_line-rst$k_kind_minimum>>
	.word	850$		- 100$	;line
.=100$ + <2 * <rst$k_data-rst$k_kind_minimum>>
	.word	860$		- 100$	;data
.=100$ + <2 * <rst$k_type-rst$k_kind_minimum>>
	.word	800$		- 100$	;type
.=100$ + <2 * <rst$k_entry-rst$k_kind_minimum>>
	.word	850$		- 100$	;entry
.=100$ + <2 * <rst$k_notunique-rst$k_kind_minimum>>
	.word	200$		- 100$	;not unique (can't happen)
.=100$ + <2 * <rst$k_typcomp-rst$k_kind_minimum>>
	.word 	800$		- 100$	;type component
.=100$ + <2 * <rst$k_variant-rst$k_kind_minimum>>
	.word	800$		- 100$	;variant
.=100$ + <2 * <rst$k_kind_maximum-rst$k_kind_minimum+1>> ;reset location
					;counter past case
200$:	brw	never_error		;this should never happen
;
;named constant other (no instruction)
;
800$:					;
	movl	#dbg$k_nc_other,@ap_type(ap) ;returned type is "other"
	brb	1000$			;successful return
;
;named constant instruction
;
850$:					;
	movl	#dbg$k_nc_instruction,@ap_type(ap) ;returned type setup
	brb	1000$			;successful return
;
;kind code data, check if a literal
;
860$:	cmpl	#dbg$k_val_literal,pli_struct_desc_valkind(r2) ;literal value?
	bneq	900$			;if not literal, not names constant
	cmpl	#rst$k_type_file,pli_struct_desc_fcode(r2) ;file constant?
	bneq	800$			;nc_other if literal, data, not file
;
;not a literal (i.e. not a named constant)
;
900$:					;
	movl	#dbg$k_other,@ap_type(ap) ;not a named constant
1000$:					;successful return entry point
	movl	#sts$k_success,r0	;success status returned for call
	ret				;
	.page
	.subtitle symbolize
;
;GLOBAL ROUTINE DBG$NPLI_SYMBOLIZE (prim_desc, string_desc, message_vect) =
;++
; FUNCTIONAL DESCRIPTION:
;
;       Produces a character string representation of the symbolic information
;       concerning a symbolic reference using a language specific primary
;       descriptor. This symbolic information includes pathname, invocation
;       number, and entity name. For example:
;
;               FOO\BAR 3\[LEXICAL_ENTITY]...\A
;
;       where FOO is the module name, BAR is the routine name, 3 is the routine
;       invocation number, and A is the variable name. 
;
;       Note that this routine must obtain an invocation number for routines
;       using information stored in the primary descriptor.
;
;
; FORMAL PARAMETERS:
;
;       prim_desc       - A longword containing the address of a language 
;                         specific primary descriptor
;
;       string_desc     - A longword containing the address of a VAX standard
;                         string descriptor with dsc$a_pointer and dsc$w_length
;                         fields of 0
;
;       message_desc    - The address of a longword to contain the address of a
;                         message argument vector as described on page 4-119 of
;                         the VAX/VMS system reference, volume 1A
;
; IMPLICIT INPUTS:
;
;       NONE
;
; IMPLICIT OUTPUTS:
;
;       On a successful return, the dsc$a_pointer and dsc$w_length fields of
;       string_desc are updated to reflect the ascii string representing the
;       symbolic information gleaned from the primary descriptor. Dynamic
;       storage must be allocated to contain the ascii string.
;
;       On a severe error return, a message argument vector is constructed from
;       dynamic storage and its address returned in message_vect.
;
; ROUTINE VALUE:
;
;       An unsigned longword integer condition code
;
; COMPLETION CODES:
;
;       STS$K_SUCCESS (1) - Success. Ascii string descriptor updated to reflect
;                            recovered symbolic information.
;
;       STS$K_SEVERE  (4) - Failure. No symbolic information recovered. Message
;                            argument vector constructed and returned.
;
; SIDE EFFECTS:
;
;       NONE
;
;--
;
ap_prim_desc    = 4			;parameter offset to primary descriptor
ap_string_desc  = 8			;parameter offset to string descriptor
ap_message_vect = 12			;paramter offset to message vector
;
;	register	use
;	r11		primary descriptor pointer
;	r10		name node pointer
;	r9		value descriptor pointer
;	r8		structure descriptor pointer
;	r7
;	r6		string descriptor pointer (output)
;
	.entry	dbg$npli_symbolize,^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11> ;
	movl	ap_prim_desc(ap),r11	;point to primary descriptor
	cmpb	#dbg$k_primary_desc,dsc$b_dtype(r11) ;is it a prim. desc. ?
	beql	10$			;branch if ok, i.e. is primary desc.
	brw	bad_pd			;branch to signal bad prim. desc.
10$:					;
	pushl	#0			;will hold name node pointer
	pushl	ap_message_vect(ap)	;pass along message vector
	pushal	4(sp)			;holds pointer to name node
	pushl	r11			;primary descriptor address
	calls	#3,pli_pd_to_name_node ;return address of name node	
	blbs	r0,20$			;branch if ok
	ret				;
20$:	movl	(sp)+,r10		;point to name node
	movl	pli_node_nam_vd_ptr(r10),r9 ;point to value descriptor
	movl	pli_node_nam_desc_ptr(r10),r8 ;point to structure descriptor

	movl	ap_string_desc(ap),r6	;point to string descriptor
;
;determine if we are to symbolize symbolically or use an address
;
	movl	pli_node_blink(r10),r1	;point to name node operator
	movl	pli_node_blink(r1),r0	;parent of name node operator
	cmpl	#pli_node_type$k_oprptr,pli_node_type(r0) ;pointer node?
;
;note: since pli_pd_to_name_node followed right links, we don't
;	have to check to see if we are a left operand. We are a right
;	operand if r0 points to a pointer node
;
	beql	90$			;branch if pointer qualified reference
	cmpl	#dbg$k_val_literal,pli_struct_desc_valkind(r8) ;literal?
	bneq	100$			;branch if not a literal value
;
;a literal value is pointed to by pli_vd$a_ptr. In order to
;properly symbolize, we must use that value as the symbolic
;address of the symbol. The type converter knows that for
;symbols that can be literals, that it is always passed a pointer
;to either the place where the literal is stored, or, in the case
;of a variable, the address of where the value of the variable is stored.
;It must (for example with file) then go to that location and use that
;pointer to find the actual data.
;

	pushl	@pli_vd$a_ptr(r9)	;get literal value
	brb	91$			;merge with common code
;
;general address printing required
;
90$:	pushl	pli_vd$a_ptr(r9)	;data pointer
91$:	pushal	(sp)			;address of "address descriptor"
	calls	#1,dbg$address_string	;convert address to string
	movzbw	(r0)+,dsc$w_length(r6)	;update length of string descriptor
	movl	r0,dsc$a_pointer(r6)	;update pointer in descriptor
	movl	#sts$k_success,r0	;successful return code
	ret				;
100$:	pushl	pli_struct_desc$l_fp(r8);frame pointer from symvalue
	pushl	pli_struct_desc_symid(r8) ;referent's symid
	calls	#2,dbg$sta_symid_in_frame ;establish the proper frame
	movl	r0,r5			;save the symid relative to specified
	pushl	r0			;frame
	calls	#1,dbg$sta_setcontext	;set the context for this symid
	tstl	r5			;was the frame zero?
	beql	90$			;branch if symbol's call frame gone
;***temp later, call symvalue and calculate address (subscripts, parents etc.
;are involved), if possible (see dirty dot). If address is the same,
;then continue else goto 90$ to print as an address
	pushal	-(sp)			;address of pathname pointer
	pushl	pli_struct_desc_symid(r8) ;referent's symid
	calls	#2,dbg$sta_sympathname	;get fully qualified path name
;
; At this point there is one longword on the stack, a pointer to a pathname
;
	pushl	(sp)			;copy pathname pointer
	pushl	r10			;point to name node
	calls	#2,pli_struct_name_size	;determine size of symbolized name
	movw	r0,dsc$w_length(r6)	;update string descriptor
	movzwl	r0,r2			;save length
	addl3	#3,r2,r3		;rounding addend
	pushl	ap_message_vect(ap)	;pass along message vector pointer
	pushal	dsc$a_pointer(r6)	;string descriptor points to free area
	ashl	#-2,r3,-(sp)		;push longwords of free storage needed
	calls	#3,dbg$nlist_freez	;get the storage
	blbs	r0,150$			;branch if got storage
	ret				;
150$:	pushab	@dsc$a_pointer(r6)[r2]	;address just beyond free storage
	pushal	dsc$a_pointer(r6)	;address of pointer to free storage
	pushl	8(sp)			;address of pathname vector
	pushl	r10			;address of name node
	calls	#4,pli_struct_to_string	;convert to counted string
	ret				;
200$:	movl	#sts$k_success,r0	;successful return code
	ret
	.page
	.subtitle	pli_pn_to_cs
;
;converts a pathname to a counted string
;
	.entry	pli_pn_to_cs,^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>
ap_pn_ptr	=	4		;pointer to pathname
ap_cs_ptr_addr	=	8		;pointer to address of counted string
;
;	register	use
;	r11		total actual byte count
;	r10		pointer to pathname symbolization we create
;	r9		holds total pathname element count
;	r8		holds path element count before dots
;	r7		points to pathname vector
;	r6		address of cs target byte count
;	r3		index into pathname symbolization (for movc)
;
	movl	ap_pn_ptr(ap),r7	;point to pathname
	cmpb	pth$b_pathcnt(r7),pth$b_totcnt(r7) ;see if it is a structure
	bneq	500$			;branch if it is a structure
	pushl	ap_cs_ptr_addr(ap)	;pass address of cs pointer
	pushl	r7			;pathname vector address
	calls	#2,dbg$npathdesc_to_cs	;use kernal debug routine to convert
	brb	1000$			;successful return common code
500$:	pushl	r7			;push pathname pointer on stack
	calls	#1,pli_get_pn_string_size ;get the required number of bytes
	pushl	ap_message_vect(ap)	;pass along the message vector
	pushl	ap_cs_ptr_addr(ap)	;address to receive storage pointer
	addl2	#4,r0			;round factor + 1 byte for length count
	ashl	#-2,r0,-(sp)		;longwords needed
	calls	#3,dbg$nlist_freez	;get storage
	blbs	r0,510$			;branch if ok
	ret				;error, use nlist_freez return code
510$:	movl	@ap_cs_ptr_addr(ap),r10	;will be counted string's address
	movl	r10,r6			;point to byte count
	incl	r10			;point past byte count
	movzbl	pth$b_pathcnt(r7),r8	;path count (non-structure part)
	movzbl	pth$b_totcnt(r7),r9	;total count of pn elements
	movb	pth$b_pathcnt(r7),pth$b_totcnt(r7) ;dummy pn desc. for call
					;to dbg$npathdesc_to_cs
	pushal	-(sp)			;address of pointer to counted string
	pushl	r7			;pathname vector
	calls	#2,dbg$npathdesc_to_cs	;convert pathname to counted string
	movb	r9,pth$b_totcnt(r7)	;restore proper total count value
	movl	(sp),r0			;point to counted string
	movzbl	(r0)+,r1		;byte count
	movl	r1,r11			;initialize byte count total
	movc3	r1,(r0),(r10)		;move "non-structure" part of pn
550$:	movl	pth$a_pathvector(r7)[r8],r0 ;point to pathname element
	movzbl	(r0)+,r1		;get byte count
	movb	#^a/./,(r3)+		;put in structure separator
	addl2	r1,r11			;add to byte count
	incl	r11			;account for dot
	movc3	r1,(r0),(r3)		;move in structure name
	aoblss	r9,r8,550$		;iterate for all structure elements
	movb	r11,(r6)		;put in actual byte count
;
;note: the above is necessary because dbg$npathdesc_to_cs may
;	eliminate the module name if it is equal to the program
;	name and the byte count will then not be correct
;
1000$:	movl	#sts$k_success,r0	;successful return
	ret				;



	.page
	.subtitle get symid
;
;GLOBAL ROUTINE DBG$NPLI_GET_SYMID (desc, symid_list, message_vect) =
;++
; FUNCTIONAL DESCRIPTION:
;       
;       Returns a list of symids contained within a language specific primary
;       or value descriptor.
;
; FORMAL PARAMETERS:
;
;       desc            - A longword containing the address of a language
;			  specific
;                         primary or value descriptor.
;
;       symid_list      - The address of a longword to contain the address of 
;                         the first node in the symid list. Each node in the
;			  list consists of a two longword block. The first
;			  longword is the link field and contains the address
;			  of the next node in the list. This field is 0 for the
;			  last node in the list. The second longword contains
;			  the value of a symid. Each symid that appears in a 
;                         descriptor should appear once and only once in the
;                         symid list.
;
;       message_vect    - The address of a longword to contain the address of
;                         a message argument vector as described on page 4-119
;                         of the VAX/VMS system reference, volume 1A
;
; IMPLICIT INPUTS:
;
;       NONE
;
; IMPLICIT OUTPUTS:
;
;       In case of a severe error return, a message argument vector is
;	constructed from dynamic storage and returned.
;
; ROUTINE VALUE:
;
;       An unsigned integer longword completion code
;
; COMPLETION CODES:
;
;       STS$K_SUCCESS (1) - Success. Symid list constructed and returned.
;
;       STS$K_SEVERE  (4) - Failure. No symid list returned. Message argument
;                           vector constructed and returned.
;
; SIDE EFFECTS:
;
;       NONE
;
;--
;
ap_desc=4				;parameter offset - primary descriptor
ap_symid_list=8				;parameter offset for symid
ap_message_vect=12			;parameter offset for message vector
	.entry	dbg$npli_get_symid,^m<r2>	;
	movl	ap_desc(ap),r2		;point to descriptor
	cmpb	#dbg$k_primary_desc,dsc$b_dtype(r2) ;is it a prim. desc. ?
	beql	100$			;branch if ok, i.e. is primary desc.
	cmpb	#dbg$k_value_desc,dsc$b_dtype(r2) ;is it a value descriptor
	beql	10$			;branch if value descriptor
	cmpb	#dbg$k_v_value_desc,dsc$b_dtype(r2) ;volatile value descriptor?
	beql	10$			;branch if volatile value descriptor
	brw	bad_pd			;branch to signal bad prim. desc.
10$:	clrl	@ap_symid_list(ap)		;value descriptors don't have symids
	brb	1000$			;successful return
;
;primary descriptor processing
; upon entrance, r2 points to primary descriptor
;
100$:					;
	pushl	ap_symid_list(ap)	;pointer to last symid block
	pushl	ap_message_vect(ap)	;pass along the message vector
	pushal	4(sp)			;action routine parameter
	pushal	pli_get_symid		;action routine
	pushal	pli_pd$l_head_node(r2)	;address of head node	
	calls	#4,pli_pre_order_name_walk ;collect the symid's into list
	ret				;use return value for our return value
1000$:	movl	#sts$k_success,r0	;successful return
	ret				;
	.page
	.subtitle pli_get_symid
;
; this routine looks through all the structure descriptors of a
; name node and builds symid descriptors as required by
; routine dbg$npli_get_symid
;	register	use
;	r3		points to successive symid descriptors
;	r2		points to successive structure descriptors


;	parameters
ap_node_ptr	=	4		;address of name node
ap_parameter	=	8		;addr of last symid descriptor pointer
ap_message_vect	=	12		;message vector in case of error
	.entry	pli_get_symid,^m<r2,r3>
	movl	ap_node_ptr(ap),r2	;point to name node
	movl	pli_node_nam_desc_ptr(r2),r2 ;point to first structure descr.
	movl	@ap_parameter(ap),r3	;point to last symid descriptor
10$:	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	r3			;last symid descriptor (or head)
	pushl	#2			;two longwords per symid list node
	calls	#3,dbg$nlist_freez	;get some listed storage
	blbs	r0,200$			;branch if successful return
	ret				;
200$:	movl	(r3),r3			;point to new structure descriptor
;***temp get symbolic offset from debug group
	movl	pli_struct_desc_symid(r2),4(r3) ;put in symid
	movl	pli_struct_desc_flink(r2),r2 ;get next structure desc
	bneq	10$			;branch if no more
	movl	r3,@ap_parameter(ap)	;update last symid descriptor pointer
	movl	#sts$k_success,r0	;successful return
	ret				;
	.page
	.subtitle make value descriptor
;
;GLOBAL ROUTINE DBG$NPLI_MAKE_VAL_DESC (prim_desc, target_flag,
;                                          value_desc, message_vect) =
;++
; FUNCTIONAL DESCRIPTION:
;
;       Translates language specific primary descriptors to language specific
;       value descriptors. This routine should be able to use the symbol table
;       access routines and the information contained within the primary
;	descriptor to construct a descriptor which represents a 'value
;	materialization' for the object represented by the input primary
;	descriptor.
;
;       Note that this routine must be able to use life-time, invocation, and
;       generation information to produce an accurate value descriptor of the
;       input object, or to decide when the value of an object cannot be
;       materialized (such as when the user's PC is not within the scope of
;       a dynamic variable).
;
;       Value descriptors produced by this routine must be marked (within the
;       type field of the language independent header block) as to whether
;       they are non-volatile (dbg$k_value_desc) or volatile
;	(dbg$k_v_value_desc).  Volatile value descriptors will NOT be stored
;	to represent '\', 'last value'.
;
;       Since value descriptors may be used as target descriptors ( as input to
;       dbg$npli_type_conv ), some provision must be made for incorporating
;       a value pointer field within the value descriptor. This type of value
;       descriptor is loosely defined as a volatile type.
;
; FORMAL PARAMETERS:
;
;       prim_desc       - A longword containing the address of a primary
;			  descriptor
;
;       target_flag     - A longword containing boolean true or false. When
;			  true, the caller is requesting the construction of a
;			  value descriptor that can be used as a target
;			  descriptor for the type converter. The resulting
;			  value must therefore contain a pointer to the value
;			  of the entity described by the input primary
;			  descriptor. Presumably, such a value descriptor will
;			  be of volatile type.
;
;       value_desc      - The address of a longword to contain the address of
;			  the resulting value descriptor
;
;       message_vect    - The address of a longword to contain the address of a
;                         message argument vector as described on page 4-119 of
;                         the VAX/VMS system reference, volume 1A
;
; IMPLICIT INPUTS:
;
;       NONE
;
; IMPLICIT OUTPUTS:
;
;       In case of a success return, the resulting value descriptor must be
;       constructed from dynamic storage and returned.
;
;       In case of a severe error return, a message argument vector must be
;       constructed from dynamic storage and returned.
;
; ROUTINE VALUE:
;
;       An unsigned integer longword completion code
;
; COMPLETION CODES:
;
;       STS$K_SUCCESS (1) - Success. Value descriptor constructed and returned.
;
;       STS$K_SEVERE  (4) - Failure. Value descriptor not constructed. Message
;                           argument vector constructed and returned.
;
; SIDE EFFECTS:
;
;       NONE
;
;--
;
	.entry	dbg$npli_make_val_desc,^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>
ap_prim_desc    =  4			;parameter offset - primary descriptor
ap_target_flag  =  8			;parameter offset - target flag
ap_value_desc   = 12			;parameter offset - value descriptor
ap_message_vect = 16			;parameter offset - message vector
;
;	register	use
;	r11		primary descriptor pointer
;	r10		name node pointer
;	r9		value descriptor pointer (source)
;	r8		structure descriptor pointer
;	r7		value descriptor pointer (target)
;	r6		string descriptor pointer (output)
;
	movl	ap_prim_desc(ap),r11	;point to primary descriptor
	cmpb	#dbg$k_primary_desc,dsc$b_dtype(r11) ;is it a prim. desc. ?
	beql	20$			;branch if ok, i.e. is primary desc.
10$:	brw	bad_pd			;branch to signal bad prim. desc.
20$:					;
	pushl	#0			;will hold name node pointer
	pushl	ap_message_vect(ap)	;pass along message vector
	pushal	4(sp)			;holds pointer to name node
	pushl	r11			;primary descriptor address
	calls	#3,pli_pd_to_name_node ;return address of name node	
	blbs	r0,30$			;branch if ok
	ret				;
30$:	movl	(sp)+,r10		;point to name node
	movl	pli_node_nam_vd_ptr(r10),r9 ;point to value descriptor
	movl	pli_node_nam_desc_ptr(r10),r8 ;point to structure descriptor
	cmpb	#rst$k_data,pli_node_nam_kind(r10) ;kind code data?
	bneq	10$			;bad primary desc if not data
;***temp later - if literal value (used?) then use longword datatype
;	cmpl	#dbg$k_val_literal,pli_struct_desc_valkind(r8) ;literal?
;
;
;set the proper context
;


	pushl	pli_struct_desc$l_fp(r8);frame pointer from symvalue
	pushl	pli_struct_desc_symid(r8) ;referent's symid
	calls	#2,dbg$sta_symid_in_frame ;establish the proper frame
	pushl	r0			;symid relative to specified frame
	calls	#1,dbg$sta_setcontext	;set the context for this symid
	blbc	ap_target_flag(ap),40$ ;branch if non volatile type
	brw	1000$			;branch to code for volatile type
;
;non volatile value descriptor
;
40$:					;
	movl	pli_node_nam_sd2_ptr(r10),r2 ;point to type 7 strides
	tstl	pli_sd_link(r2)		;make sure their is only one stride
	beql	60$			;branch if only one
;****temp return with appropriate message vector here
;****temp or do we create vd for structures?
	movl	#sts$k_severe,r0	;severe error
	ret				;
60$:					;
	
	addl3	#7,pli_sd_bits(r2),r5	;add bit round term
	bicl3	#^c7,pli_vd$l_boff(r9),r0;get bit offset and clear all but the
					;3 low order bits. Add to bit count;
	addl2	r0,r5			;the shift may carry field across a
					;byte boundary
	ashl	#-3,r5,r5		;bits to bytes (round neg. numbers
					;away from zero)
	addl2	pli_sd_bytes(r2),r5	;total bytes of data
	addl3	#pli_vd$k_size+3,r5,r6 ;add static vd size + round factor
;
; get storage for value descriptor
;
	pushl	ap_message_vect(ap)	;pointer to message vector
	pushl	ap_value_desc(ap)	;the free storage will be value desc.
	ashl	#-2,r6,-(sp)		;number of longwords needed
	calls	#3,dbg$nlist_freez	;get listed storage
	blbs	r0,220$			;branch if ok
	ret				;
220$:					;
	movl	@ap_value_desc(ap),r7	;point to value descriptor	
	movb	#dbg$k_pli,dsc$b_class(r7) ;language code
	movb	#dbg$k_value_desc,dsc$b_dtype(r7) ;type of descriptor
	clrl	dsc$a_pointer(r7)	;clear reserved field
	movw	r6,dsc$w_length(r7)	;length of value descriptor
	movl	pli_vd$l_type(r9),pli_vd$l_type(r7) ;pli datatype
	movl	pli_vd$l_size(r9),pli_vd$l_size(r7) ;vd size field
	movl	pli_vd$l_boff(r9),pli_vd$l_boff(r7) ;bit offset
	moval	pli_vd$k_size(r7),r3 ;point to end of fixed area
;
;note: the type converter does the relocation of pli_vd$a_ptr and
;	pli_vd$a_addr
;
	movc3	r5,@pli_vd$a_ptr(r9),(r3) ;copy the data
	movl	#sts$k_success,r0	;success
	ret				;
1000$:					;
;
;volatile value descriptor
;get storage for value descriptor
;
	pushl	ap_message_vect(ap)	;pass along message vector pointer
	pushl	ap_value_desc(ap)	;free storage will be value desc.
	pushl	#<pli_vd$k_size+3>/4	;# of longwords needed
	calls	#3,dbg$nlist_freez	;get free zeroed storage
	blbs	r0,1330$		;branch if we got the storage
	ret				;
;
; set up header for value descriptor
;
1330$:	movl	@ap_value_desc(ap),r7	;point to the value descriptor
	movb	#dbg$k_pli,dsc$b_class(r7) ;language code
	movb	#dbg$k_v_value_desc,dsc$b_dtype(r7) ;volatile value descriptor
	clrl	dsc$a_pointer(r7)	;clear reserved field
	movw	#pli_vd$k_size,dsc$w_length(r7) ;length of vd
	movl	pli_vd$l_type(r9),pli_vd$l_type(r7) ;pli datatype
	movl	pli_vd$l_size(r9),pli_vd$l_size(r7) ;vd size field
	movl	pli_vd$l_boff(r9),pli_vd$l_boff(r7) ;bit offset
;
;note: type converter relocates pli_vd$a_addr
	movl	pli_vd$a_ptr(r9),pli_vd$a_ptr(r7) ;data ptr
	movl	#sts$k_success,r0	;success
	ret				;
	.page
	.subtitle get length
;
;GLOBAL ROUTINE DBG$NPLI_GET_LENGTH (prim_desc, length, message_vect) =
;++
; FUNCTIONAL DESCRIPTION:
;
;       Uses a symbol's primary descriptor to obtain the length of the symbol's
;       rvalue. The length is to be given in bits. Lengths longer than 2**32
;	- 1 must be truncated to this length.
;
;       The debugger assumes that rvalues refer to contiguous blocks of
;	storage. If this is not true for a given variable, this routine fails.
;
;       Length should reflect the maximum length for entities that may vary in
;       size, and include the length of a control word, if one is present.
;
;       This routine is called, among other things, to determine the length
;       of an object to be watchpointed. If the object described by the input
;       primary descriptor cannot have its value converted to external format
;       by the language specific dbg$nplitypeconv routine, then this routine
;       should return sts$kinfo. Note that this situation is presently
;       true for objects with aggregate values such as array references without
;       subscripts, and entire records ans structures.
;
;
;
; FORMAL PARAMETERS:
;
;       prim_desc       - A longword containing the address of a primary
;			  descriptor
;
;       length          - The address of a longword to contain an unsigned
;			  integer longword representing the symbol's rvalue
;			  length in bits
;
;       message_vect    - The address of a longword to contain the address of a
;                         message argument vector as described on page 4-119 of
;                         the VAX/VMS system reference, volume 1A
;
; IMPLICIT INPUTS:
;
;       NONE
;
; IMPLICIT OUTPUTS:
;
;       In case of a severe error return, a message argument vector is
;	constructed from dynamic storage and returned.
;
; ROUTINE VALUE:
;
;       An unsigned integer longword completion code
;
; COMPLETION CODES:
;
;       STS$K_SUCCESS (1) - Success. Length of symbol's rvalue returned.
;
;       STS$K_INFO    (3) - Success. Length of symbol's rvalue returned but
;                           the symbol refers to object whose value cannot be
;                           converted to external format by dbg$nplitypeconv.
;
;       STS$K_SEVERE  (4) - Failure. No length returned. Message argument
;			    vector constructed and returned.
;
; SIDE EFFECTS:
;
;       NONE
;
;--
;
; REGISTER USAGE
;
;
;	register	use
;	r7		name node pointer
ap_prim_desc	=	4		;parameter offset to primary descriptor
ap_length	=	8		;parameter offset to bit length
ap_message_vect =      12		;parameter offset to message vector
	.entry	dbg$npli_get_length,^m<r2,r3,r4,r5,r6,r7>
	movl	ap_prim_desc(ap),r7	;point to primary descriptor
	cmpb	#dbg$k_primary_desc,dsc$b_dtype(r7) ;is it a prim. desc. ?
	beql	20$			;branch if ok, i.e. is primary desc.
10$:	brw	bad_pd			;branch to signal bad prim. desc.
20$:					;
	pushl	#0			;will hold name node pointer
	pushl	ap_message_vect(ap)	;pass along message vector
	pushal	4(sp)			;holds pointer to name node
	pushl	r7			;primary descriptor address
	calls	#3,pli_pd_to_name_node ;return address of name node	
	blbs	r0,30$			;branch if ok
	ret				;
30$:	movl	(sp)+,r7		;point to name node


	movl	pli_node_nam_sd2_ptr(r7),r2 ;point to type 7 strides
	tstl	pli_sd_link(r2)		;make sure their is only one stride
	beql	40$			;branch if only one
;****temp return with appropriate message vector here
;
;***temp later we must do unconnected arrays etc.
	movl	#sts$k_severe,r0	;severe error
	ret				;
40$:					;
	movl	ap_length(ap),r6	;point to length quadword
	movl	pli_sd_bytes(r2),r3	;get number of bytes
	movl	pli_sd_bits(r2),r4	;get number of bits
	ashl	#3,r3,r5		;bytes to bits
	addl3	r5,r4,@ap_length(ap)	;pass back bit length
	movl	#sts$k_success,r0	;successful return
	ret				;
	.page
	.subtitle get pages
;
;GLOBAL ROUTINE DBG$NPLI_GET_PAGES (prim_desc, page_list, message_vect) =
;++
; FUNCTIONAL DESCRIPTION:
;
;       Uses a symbol's primary descriptor to construct a linked list of page
;       numbers which reflect those pages of storage in which the symbol's
;       rvalue is contained. Note that the pages may be non-contiguous.
;       Only one entry per page should be constucted in the page list.
;
;       Control words, if present, are to be considered part of the rvalue.
;
;       A page number is represented by the high order 23 bits of a virtual 
;       address, with the low order 9 bits set to 0:
;
;       page = (virtual_address AND B'11111111111111111111111000000000')
;
; FORMAL PARAMETERS:
;
;       prim_desc       - A longword containing the address of a primary
;			  descriptor
;
;       page_list       - The address of a longword to contain the address of
;			  the head node in the page list. Nodes in the page
;			  list consist of blocks of two longwords each. The
;			  second longword of the node block contains a page
;			  number on which some portion of the symbol's rvalue
;			  resides. The first longword of the node block
;			  contains the address of the next node in the list.
;			  The last node in the list should contain a 0 in this
;			  link field.
;
;       message_vect    - The address of a longword to contain the address of
;                         a message argument vector as described on page 4-119
;                         of the VAX/VMS system reference, volume 1A
;
; IMPLICIT INPUTS:
;
;       NONE
;
; IMPLICIT OUTPUTS:
;
;       In case of a success return, the page list is constructed from dynamic
;       storage and returned.
;
;       In case of a severe error return, a message arguement vector is
;	constructed and returned.
;
; ROUTINE VALUE:
;
;       An unsigned integer longword completion code
;
; COMPLETION CODES:
;
;       STS$K_SUCCESS (1) - Success. Page list constructed and returned.
;
;       STS$K_SEVERE  (4) - Failure. Page list not constructed. Message
;			    argument vector constructed and returned.
;
; SIDE EFFECTS:
;
;       NONE
;
;--
;
;
; REGISTER USAGE
;	r2	stride pointer
;	r5	address of first byte of a stride
;	r6	address of the last byte of a stride
;	r7	page_list pointer to last node
;	r8	page_list pointer when looking for duplicate page numbers
;
; temporary storage layout:
;
;	longword (sp) : low bit clear - creating first page list
;			node so there is no precessor to check.
;		       low bit set   - a predecessor node
;			exists, check the page number for a
;			duplicate.
;
;
;
ap_prim_desc	=	4		;parameter offset - primary descriptor
ap_page_list	=	8		;parameter offset - page list
ap_message_vect	=      12		;parameter offset - message vector
	.entry	dbg$npli_get_pages,^m<r2,r3,r4,r5,r6,r7,r8>

	movl	ap_prim_desc(ap),r7	;point to primary descriptor
	cmpb	#dbg$k_primary_desc,dsc$b_dtype(r7) ;is it a prim. desc. ?
	beql	20$			;branch if ok, i.e. is primary desc.
10$:	brw	bad_pd			;branch to signal bad prim. desc.
20$:					;
	pushl	#0			;will hold name node pointer
	pushl	ap_message_vect(ap)	;pass along message vector
	pushal	4(sp)			;holds pointer to name node
	pushl	r7			;primary descriptor address
	calls	#3,pli_pd_to_name_node	;return address of name node	
	blbs	r0,30$			;branch if ok
	ret				;
30$:	movl	(sp),r7			;point to name node. Longword
					;temporary space reserved on stack
	movl	pli_node_nam_sd2_ptr(r7),r2 ;point to type 7 strides
	tstl	pli_sd_link(r2)		;make sure their is only one stride
	beql	50$			;branch if only one stride
	movl	#pli$k_not_yet,r0	;not implemented yet
	brw	bug_check		;go signal error

50$:	movl	ap_page_list(ap),r7	;address of page_list head
	clrl	(sp)			;currently no page_list elements
	brb	80$			;
;
; calculate the start address of the next stride
;
70$:	movl	pli_sd_link(r2),r2	;look at next stride node
	bneq	80$			;branch if more exist
	movl	#sts$k_success,r0	;successful return
	ret				;
80$:	movl	pli_sd_beg_byte(r2),r3	;get starting byte address
	movl	pli_sd_beg_bit(r2),r4	;offset to first bit
;**question, pages of actual use, or including page from which reference
; occurs. currently we calculate it by the actual bits in use
	ashl	#-3,r4,r0		;bit displacement relative to base
	addl3	r0,r3,r5		;address of first byte
	addl2	pli_sd_bytes(r2),r3	;add byte length to start addr
	addl2	pli_sd_bits(r2),r4	;add bit length to bit displacement
	ashl	#-3,r4,r0		;bit displacement in bytes (rounded
					;away from zero)
	addl3	r0,r3,r6		;add to "last byte" address
	bicl2	#^b111111111,r5		;get start page
	bicl2	#^b111111111,r6		;last page
90$:					;
	bbcs	#0,(sp),95$		;branch if no page list nodes
	movl	@ap_page_list(ap),r8	;point to first node of page_list
92$:	cmpl	4(r8),r5		;already have that page?
	beql	110$			;branch if already present
	movl	(r8),r8			;point to next node
	bneq	92$			;branch if not the last one
95$:					;we must create a new page_list node
	pushl	ap_message_vect(ap)	;pass along message vector pointer
	pushl	r7			;node pointer points to free storage
	pushl	#2			;2 longwords needed
	calls	#3,dbg$nlist_freez	;get free zeroed storage
	blbs	r0,100$			;branch if we got the storage
	ret				;
100$:	movl	(r7),r7			;point to page_list node	
	movl	r5,4(r7)		;enter page address
110$:	cmpl	r5,r6			;last page?
	beql	70$			;branch if there are no more
	addl2	#512,r5			;address of the next page
	brb	90$			;go make next page_list node
	.page
	.subtitle	copy descriptor
;************************************************************************
;*	copy primary and value descriptors				*
;************************************************************************
;
;GLOBAL ROUTINE DBG$NPLI_COPY_DESC (desc, copy, message_vect) =
;++
; FUNCTIONAL DESCRIPTION:
;
;       Accepts as input a language specific primary or value descriptor
;       (constructed from listed storage)
;       and makes a copy of the descriptor out of non-listed storage. This 
;       non-volatile copy will be stored in conjunction with x-points and
;       current location.
;
;       This routine may use DBG$NCOPY to copy each portion of the 
;       descriptor that has been created from listed dynamic storage.
;
; FORMAL PARAMETERS:
;
;       desc                    - The address of a language specifc primary or
;                                 value descriptor
;
;       copy                    - The address of a longword to contain the
;				address
;                                 of the non-volatile copy of the descriptor
;
;       message_vect            - The address of a longword to contain the
;				address
;                                 of a message argument vector for errors
;
; IMPLICIT INPUTS:
;
;       NONE
;
; IMPLICIT OUTPUTS:
;
;       On success, the non-volatile copy of a primary descriptor.
;
;       On failure, a message argument vector.
;
; ROUTINE VALUE:
;
;       An unsigned integer longword completion code
;
; COMPLETION CODES:
;
;       STS$K_SUCCESS   (1)     - Success. Copy constructed and returned.
;
;       STS$K_SEVERE    (4)     - Failure. Copy not produced. Message argument
;                                 vector constructed and returned.
;
; SIDE EFFECTS:
;
;       NONE
;
;--
;
	.entry	dbg$npli_copy_desc,^m<r2,r3,r4,r5,r6>
ap_desc	=	4			;address of source descriptor
ap_copy =	8			;addr of pointer to copy
ap_message_vect = 12			;message vector
;
;*****warning****
; this routines assumes that value descriptors are position independent
; and of fixed length
; THIS ROUTINE WILL NOT WORK if this is not true
;
; primary descriptors do not have this restriction placed upon them
;
	movl	ap_desc(ap),r6		;point to descriptor
	cmpb	#dbg$k_primary_desc,dsc$b_dtype(r6) ;is it a primary descriptor
	beql	100$			;branch if primary descriptor
;
;copy value descriptor
;
	pushl	ap_message_vect(ap)	;message vector passed along
	pushl	ap_copy(ap)		;pass along pointer to copy
	pushl	ap_desc(ap)		;first byte to copy
	calls	#3,dbg$ncopy		;copy in non_listed storage
	ret
;
;copy primary descriptor
;
100$:
	pushl	ap_message_vect(ap)	;message vector passed along
	pushl	ap_copy(ap)		;address of longword to contain
					;pointer to free zeroed storage
	movzwl	dsc$w_length(r6),r0	;bytes in source primary descriptor
	addl2	#3,r0			;round factor
	ashl	#-2,r0,-(sp)		;number of longwords needed
	calls	#3,dbg$nfreez		;get the non-listed storage
	blbs	r0,200$			;branch if ok
	ret				;
200$:	movl	@ap_copy(ap),r3		;point to free storage
	movc3	#pli_pd$l_head_node,(r6),(r3) ;copy the fixed portion
	pushl	r3			;save pointer to free storage
	pushl	ap_message_vect(ap)	;pass along the message vector
	pushal	pli_pd$l_head_node(r6)	;stop node will be head node
	pushl	#0			;no back link used
	pushal	pli_pd$l_head_node(r6)	;node to be copied
	pushal	16(sp)			;free storage pointer
	calls	#5,pli_copy_tree	;copy the tree
	ret				;use return from copy tree
	.subtitle	free descriptor
;
;GLOBAL ROUTINE DBG$NPLI_FREE_DESC (desc, message_vect) =
;++
; FUNCTIONAL DESCRIPTION:
;
;       Releases dynamic storage associated with a non-volatile copy of a 
;       language specific value or primary descriptor.
;       This routine accepts as input a copy of a primary or value
;       descriptor produced by DBG$NPLI_COPY_DESC and calls the
;       routine DBG$NFREERELEASE to release each block of non-listed dynamic
;       storage contained within the descriptor.
;
; FORMAL PARAMETERS:
;
;       desc                    - The address of a non-volatile primary or
;                                 value descriptor
;
;       message_vect            - The address of a longword to contain the
;				  address of a message argument vector for
;				  errors
;
; IMPLICIT INPUTS:
;
;       NONE
;
; IMPLICIT OUTPUTS:
;
;       On failure, a message argument vector.
;
; ROUTINE VALUE:
;
;       An unsigned integer longword completion code
;
; COMPLETION CODES:
;
;       STS$K_SUCCESS  (1)      - Success. Storage for  descriptor released.
;
;       STS$K_SEVERE    (4)     - Failure. Storage for descriptor not released.
;				  Message argument vector constructed and
;				  returned.
;
; SIDE EFFECTS:
;
;       Dynamic memory is returned to the free storage pool.
;
;--
;
	.entry	dbg$npli_free_desc,0
ap_desc		=	4		;address of non_volitile descriptor
ap_message_vect	=	8		;message vector
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	ap_desc(ap)		;pass along address of area to be freed
	calls	#2,dbg$nfreerelease	;release the storage
	ret
	.page
	.subtitle	pli_copy_desc_to_temp
	.page
	.subtitle	copy descriptor
;************************************************************************
;*	copy primary and value descriptors to temporary storage		*
;************************************************************************
;
;++
; FUNCTIONAL DESCRIPTION:
;
;       Accepts as input a language specific primary or value descriptor
;       and makes a copy of the descriptor out of listed (temporary) storage. 
;
; FORMAL PARAMETERS:
;
;       desc                    - The address of a language specifc primary or
;                                 value descriptor
;
;       copy                    - The address of a longword to contain the
;				address of the volatile copy of the descriptor
;
;       message_vect            - The address of a longword to contain the
;				address of a message argument vector for errors
;
; IMPLICIT INPUTS:
;
;       NONE
;
; IMPLICIT OUTPUTS:
;
;       On success, the volatile copy of a primary descriptor.
;
;       On failure, a message argument vector.
;
; ROUTINE VALUE:
;
;       An unsigned integer longword completion code
;
; COMPLETION CODES:
;
;       STS$K_SUCCESS   (1)     - Success. Copy constructed and returned.
;
;       STS$K_SEVERE    (4)     - Failure. Copy not produced. Message argument
;                                 vector constructed and returned.
;
; SIDE EFFECTS:
;
;       NONE
;
;--
;
	.entry	pli_copy_desc_to_temp,^m<r2,r3,r4,r5,r6>
ap_desc	=	4			;address of source descriptor
ap_copy =	8			;addr of pointer to copy
ap_message_vect = 12			;message vector
;
;*****warning****
; this routines assumes that value descriptors are position independent
; and of fixed length
; THIS ROUTINE WILL NOT WORK if this is not true
;
; primary descriptors do not have this restriction placed upon them
;
	movl	ap_desc(ap),r6		;point to descriptor
	cmpb	#dbg$k_primary_desc,dsc$b_dtype(r6) ;is it a primary descriptor
	beql	100$			;branch if primary descriptor
;
;copy value descriptor
;
	brw	not_yet			;***later add code if call every made
					;with this purpose in mind
;
;copy primary descriptor
;
100$:
	pushl	ap_message_vect(ap)	;message vector passed along
	pushl	ap_copy(ap)		;address of longword to contain
					;pointer to free zeroed storage
	movzwl	dsc$w_length(r6),r0	;bytes in source primary descriptor
	addl2	#3,r0			;round factor
	ashl	#-2,r0,-(sp)		;number of longwords needed
	calls	#3,dbg$nlist_freez	;get the listed storage
	blbs	r0,200$			;branch if ok
	ret				;
200$:	movl	@ap_copy(ap),r3		;point to free storage
	movc3	#pli_pd$l_head_node,(r6),(r3) ;copy the fixed portion
	pushl	r3			;save pointer to free storage
	pushl	ap_message_vect(ap)	;pass along the message vector
	pushal	pli_pd$l_head_node(r6)	;stop node will be head node
	pushl	#0			;no back link used
	pushal	pli_pd$l_head_node(r6)	;node to be copied
	pushal	16(sp)			;free storage pointer
	calls	#5,pli_copy_tree	;copy the tree
	ret				;use return from copy tree
	.subtitle	logical predecessor - successor
;
;GLOBAL ROUTINE DBG$NPLI_LOG_PREDSUC (input_prim, output_prim, symbol_code,
;++
; FUNCTIONAL DESCRIPTION:
;
;       Produces a primary descriptor which specifies the logical successor
;       or predecessor to the symbol described by the input primary descriptor.
;       The definition of the passage from a primary to its
;	successor/predecessor is language dependent, but the
;	successor/predecessor must lie within the same aggregate as the input
;	primary, such as cells within an array. Further guidelines are TBS. 
;
; FORMAL PARAMETERS:
;
;       input_prim  -   A longword containing the address of a primary
;			descriptor
;
;       output_prim -   The address of a longword to contain the address of a
;                       primary descriptor which describes the logical
;			predecessor or successor to the input primary
;
;       symbol_code -   A longword containing an integer code which specifies
;                       whether a successor or predecessor is required as
;			follows:
;
;               dbg$k_predecessor (221)  - logical predecessor required
;
;               dbg$k_successor (222)    - logical successor required
;
;       message_vect -  The address of a longword to contain the address of a
;                       message argument vector as described in the VAX/VMS
;                       system reference, page 4-119, volume 1A
;
; IMPLICIT INPUTS:
;
;       NONE
;
; IMPLICIT OUTPUTS:
;
;       The primary descriptor representing the logical predecessor/successor
;       must be constructed from dynamic storage.
;
;       In case of a severe error return, a message argument vector is
;	constructed and returned.
;
; ROUTINE VALUE:
;
;       An unsigned integer longword completion code
;
; COMPLETION CODES:
;
;       STS$K_SUCCESS (1) -  Success. Primary descriptor constructed for
;                            logical predecessor/successor and returned.
;
;       STS$K_SEVERE  (4) -  Failure. Primary descriptor for logical
;                            predecessor/successor not constructed. Message
;                            argument vector constructed and returned.
;
; SIDE EFFECTS:
;
;       NONE
;
;--
;
	.entry	dbg$npli_log_predsuc,^m<r2,r3,r4,r5,r6,r7,r8,r9,r10>
;
;	register	use
;	r10		name node pointer
;	r9		structure descriptor pointer
;
;
;+------------------------------+
;! subscript vector size	! (sp)
;+------------------------------+
;! subscript vector pointer	! 4(sp)
;+------------------------------+
;! byte offset			! 8(sp)
;+------------------------------+
;! bit offset			! 12(sp)
;+------------------------------+
;! original byte offset		! 16(sp)
;+------------------------------+
;! original bit offset		! 20(sp)
;+------------------------------+
;				! 24(sp)
;
ap_input_prim	=	4		;address of input pd
ap_output_prim	=	8		;pointer to new pd
ap_symbol_code	=	12		;successor or predecessor switch
ap_message_vect	=	16		;message vector
	moval	-24(sp),sp		;allocate 6 longwords


	pushl	ap_message_vect(ap)	;pass along message vector
	pushal	4(sp)			;will receive name node pointer
	pushl	ap_input_prim(ap)	;input primary descriptor
	calls	#3,pli_pd_to_name_node	;get the top level rightmost name node
	blbs	r0,10$			;branch if ok
	ret				;
10$:	movl	(sp),r10		;point to name node
	cmpl	#pli_node_type$k_named,pli_node_type(r10) ;name node data?
	beql	20$			;branch if name node data
	brw	never_error		;should never happen
20$:	movl	pli_node_nam_vector_size(r10),(sp) ;size of subscript vector
	bneq	50$			;branch if legal request
;
;no subscripts given so the element can't have a predecessor or successor
;It is important to test this first because if a copy where made (the
;assumption made that the operation requested would succeed) and memory
;was in short supply, then an insufficient memory message would be
;displayed instead of a "no successor" or "no predecessor" message.
;
	cmpl	#dbg$k_predecessor,ap_symbol_code(ap) ;predecessor needed?
	beql	40$			;branch if predecessor
	cmpl	#dbg$k_successor,ap_symbol_code(ap) ;successor needed?
	beql	30$			;branch if successor
	brw	never_error		;should never happen
30$:					;successor reqested
	pushl	#dbg$_nosucc		;no successor possible
	brw	9999$			;merge with common code
40$:					;predecessor requested
	pushl	#dbg$_nopred		;no predecessor possible
	brw	9999$			;merge with common code
50$:					;we have some kind of array
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	ap_output_prim(ap)	;pointer to output primary desc.pointer
	pushl	ap_input_prim(ap)	;pointer to input primary desc. pointer
	calls	#3,pli_copy_desc_to_temp ;copy the input descriptor
	blbs	r0,100$			;branch if ok
	ret				;
;
;upon entrance:
;		(sp)	=	subscript vector size
;temporary storage used:
;		4(sp)	=	address of name node
;
100$:					;
	pushl	ap_message_vect(ap)	;pass along message vector
	pushal	8(sp)			;will receive name node pointer
	pushl	@ap_output_prim(ap)	;output primary descriptor
	calls	#3,pli_pd_to_name_node	;get the top level rightmost name node
	blbs	r0,110$			;branch if ok
	ret				;
110$:	movl	4(sp),r10		;point to name node
	cmpl	#pli_node_type$k_named,pli_node_type(r10) ;name node data?
	beql	120$			;branch if name node data
	brw	never_error		;should never happen
;
;determine the byte and bit offset currently due to the subscripts
;note: (sp) has value pli_node_nam_vector_size(r10) upon entrance
;
120$:	movl	pli_node_nam_desc_ptr(r10),r9 ;point to first structure desc.
	movl	pli_node_nam_vector(r10),4(sp) ;address of target subscript
					;vector (at this point, copy of input
					;subscript vector)
	clrq	8(sp)			;zero out byte and bit offset values
150$:	cmpl	#rst$k_type_array,pli_struct_desc_fcode(r9) ;element an array?
	bneq	170$			;branch if not an array
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	pli_struct_desc_symid(r9) ;symid in case of error
	pushl	pli_struct_desc$a_opt(r9) ;optional type block address
	pushal	12(sp)			;address of 4 longword temp. area
	calls	#4,pli_get_vector_offset ;determine offset due to subscripts
	blbs	r0,170$			;branch if ok
	ret				;
170$:	movl	pli_struct_desc_flink(r9),r9 ;point to next structure desc.
	bneq	150$			;branch if another structure desc.
	tstl	(sp)			;any subscripts left over
	beql	180$			;branch if ok
	brw	never_error		;this should never happen
180$:					;
	movq	8(sp),16(sp)		;save byte and bit offset values
	cmpl	#dbg$k_successor,ap_symbol_code(ap) ;successor needed?
	beql	200$			;branch if successor
	cmpl	#dbg$k_predecessor,ap_symbol_code(ap) ;predecessor needed?
	beql	190$			;branch if predecessor
	brw	never_error		;this should never happen
190$:	brw	5000$			;goto predecessor code
;
;successor requested
;
200$:					;
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	pli_node_nam_vector(r10);address of subscript vector (new)
	pushl	pli_node_nam_vector_size(r10) ;number of vector elements
	pushl	pli_node_nam_desc_ptr(r10) ;first structure descriptor
	calls	#4,pli_inc_subscript	;increment the subscript
	blbs	r0,220$			;branch if ok
	ret				;
220$:					;
	movl	pli_node_nam_desc_ptr(r10),r9 ;point to first structure desc.
	movl	pli_node_nam_vector(r10),4(sp) ;address of target subscript
					;vector (at this point, copy of input
					;subscript vector)
	movl	pli_node_nam_vector_size(r10),(sp) ;size of subscript vector
	clrq	8(sp)			;zero out byte and bit offset values
250$:	cmpl	#rst$k_type_array,pli_struct_desc_fcode(r9) ;element an array?
	bneq	270$			;branch if not an array
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	pli_struct_desc_symid(r9) ;symid in case of error
	pushl	pli_struct_desc$a_opt(r9) ;optional type block address
	pushal	12(sp)			;address of 4 longword temp. area
	calls	#4,pli_get_vector_offset ;determine offset due to subscripts
	blbs	r0,270$			;branch if ok
	ret				;
270$:	movl	pli_struct_desc_flink(r9),r9 ;point to next structure desc.
	bneq	250$			;branch if another structure desc.
	tstl	(sp)			;any subscripts left over
	beql	280$			;branch if ok
	brw	never_error		;this should never happen
280$:					;
;
;calculate the byte and bit offset to add in adjusting strides and vd template
;
	subl3	16(sp),8(sp),r6		;new - original byte offset
	bgeq	530$			;branch if non-negative
525$:	brw	never_error		;should never happen
530$:	subl3	20(sp),12(sp),r5	;new - original bit offset
	bgeq	550$			;branch if non-negative
540$:	decl	r6			;get 8 bits from byte offset
	blss	525$			;branch if negative (never happens)
	addl2	#8,r5			;add to bit offset
	blss	540$			;repeat if still negative
550$:
;
;relocate name node stride lists
;
	movl	pli_node_nam_sd2_ptr(r10),r8 ;point to stride list 2 (type 7)
1020$:	addl2	r6,pli_sd_beg_byte(r8)	;add byte addr
	addl2	r5,pli_sd_beg_bit(r8)	;add bit offset
	movl	pli_sd_link(r8),r8	;point to next stride node
	bneq	1020$			;branch if more stride elements
	movl	pli_node_nam_sd1_ptr(r10),r8 ;point to stride list 1 (type 0)
1050$:	addl2	r6,pli_sd_beg_byte(r8)	;add byte addr
	addl2	r5,pli_sd_beg_bit(r8)	;add bit offset
	movl	pli_sd_link(r8),r8	;point to next stride node
	bneq	1050$			;branch if more stride elements
;
;use stride list to fix up value descriptor template
;
	movl	pli_node_nam_vd_ptr(r10),r9 ;point to vd template
	addl2	r6,pli_vd$a_ptr(r9)	;add to byte address
	addl2	pli_vd$l_boff(r9),r5	;add bit offset values
	ashl	#-3,r5,r0		;INT(number_of_bits/8)
	ashl	#3,r0,r1		;whole bytes as bits
	addl2	r0,pli_vd$a_ptr(r9)	;add as part of byte address
	subl3	r1,r5,pli_vd$l_boff(r9)	;excess is bit offset
2000$:	movl	#sts$k_success,r0	;successful return
	ret				;
;
;predecessor requested
;
5000$:					;
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	pli_node_nam_vector(r10);address of subscript vector (new)
	pushl	pli_node_nam_vector_size(r10) ;number of vector elements
	pushl	pli_node_nam_desc_ptr(r10) ;first structure descriptor
	calls	#4,pli_dec_subscript	;increment the subscript
	blbs	r0,5020$			;branch if ok
	ret				;
5020$:	
	movl	pli_node_nam_desc_ptr(r10),r9 ;point to first structure desc.
	movl	pli_node_nam_vector(r10),4(sp) ;address of target subscript
					;vector (at this point, copy of input
					;subscript vector)
	movl	pli_node_nam_vector_size(r10),(sp) ;size of subscript vector
	clrq	8(sp)			;zero out byte and bit offset values
5050$:	cmpl	#rst$k_type_array,pli_struct_desc_fcode(r9) ;element an array?
	bneq	5070$			;branch if not an array
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	pli_struct_desc_symid(r9) ;symid in case of error
	pushl	pli_struct_desc$a_opt(r9) ;optional type block address
	pushal	12(sp)			;address of 4 longword temp. area
	calls	#4,pli_get_vector_offset ;determine offset due to subscripts
	blbs	r0,5070$		;branch if ok
	ret				;
5070$:	movl	pli_struct_desc_flink(r9),r9 ;point to next structure desc.
	bneq	5050$			;branch if another structure desc.
	tstl	(sp)			;any subscripts left over
	beql	5080$			;branch if ok
	brw	never_error		;this should never happen
5080$:					;
;
;calculate the byte and bit offset to add in adjusting strides and vd template
;
	subl3	8(sp),16(sp),r6		;original - new  byte offset
	bgeq	5130$			;branch if non-negative
5125$:	brw	never_error		;should never happen
5130$:	subl3	12(sp),20(sp),r5	;original - new bit offset
	bgeq	5150$			;branch if non-negative
5140$:	decl	r6			;get 8 bits from byte offset
	blss	5125$			;branch if negative (never happens)
	addl2	#8,r5			;add to bit offset
	blss	5140$			;repeat if still negative
5150$:
;
;relocate name node stride lists
;
	movl	pli_node_nam_sd2_ptr(r10),r8 ;point to stride list 2 (type 7)
6020$:	subl3	r6,pli_sd_beg_byte(r8),r0 ;subtract byte displacements
	subl3	r5,pli_sd_beg_bit(r8),r1 ;subtract bit displacements
	bsbb	pli_normalize_byte_bit	;normalize bit and byte displacments
	movl	r0,pli_sd_beg_byte(r8)	;normalized byte displacement
	movl	r1,pli_sd_beg_bit(r8)	;normalized bit displacement
	movl	pli_sd_link(r8),r8	;point to next stride node
	bneq	6020$			;branch if more stride elements
	movl	pli_node_nam_sd1_ptr(r10),r8 ;point to stride list 1 (type 0)
6050$:	subl3	r6,pli_sd_beg_byte(r8),r0 ;subtract byte displacements
	subl3	r5,pli_sd_beg_bit(r8),r1 ;subtract bit displacements
	bsbb	pli_normalize_byte_bit	;normalize bit and byte displacments
	movl	r0,pli_sd_beg_byte(r8)	;normalized byte displacement
	movl	r1,pli_sd_beg_bit(r8)	;normalized bit displacement
	movl	pli_sd_link(r8),r8	;point to next stride node
	bneq	6050$			;branch if more stride elements
;
;use stride list to fix up value descriptor template
;
	movl	pli_node_nam_vd_ptr(r10),r9 ;point to vd template

	subl3	r6,pli_vd$a_ptr(r9),r0	;subtract byte displacements
	subl3	r5,pli_vd$l_boff(r9),r1 ;subtract bit displacements
	bsbb	pli_normalize_byte_bit	;normalize bit and byte displacments
	movl	r0,pli_vd$a_ptr(r9)	;normalized byte displacement
	movl	r1,pli_vd$l_boff(r9)	;normalized bit displacement
	brw	2000$			;go make successful return
;
;common code to make message vector with one argument
;
9999$:	calls	#1,dbg$nmake_arg_vect	;make the message
	movl	r0,@ap_message_vect(ap)	;update message vector
	movl	#sts$k_severe,r0	;severe error
	ret				;
;
;internal subroutine pli_normalize_byte_bit
;
; upon entrance:
;	r0	byte displacement
;	r1	bit displacement
;
; upon exit - byte and bit values are such
;	that bit displacement is positive and
;	the smallest possible value (i.e.
;	multiples of 8 are converted to
;	byte displacements
;
; +-----------------------------+
; ! INT(bits/8)			! (sp)
; +-----------------------------+
; ! INT(bits/8)*8		! 4(sp)
; +-----------------------------+
;
pli_normalize_byte_bit:			;
;
;determine if bit displacement is negative
;
	tstl	r1			;bit displacment negative
	blss	100$			;branch if bit displacement is negative
	moval	-8(sp),sp		;reserve 2 longwords temp. storage
	ashl	#-3,r1,(sp)		;INT(number_of_bits/8)
	ashl	#3,(sp),4(sp)		;INT(number_of_bits/8)*8
	addl2	(sp),r0			;add number of 8 bit groups to
					;byte count
	subl2	4(sp),r1		;bits (between 0 and 7 inclusive)
	moval	8(sp),sp		;free 2 longwords temp. storage
	rsb				;
;
;negative bit displacement
;
100$:	decl	r0			;carry into byte count
	bgeq	110$			;branch if legal
	brw	never_error		;this should never happen
110$:	addl2	#8,r1			;add to bit count
	blss	100$			;if still negative, repeat
	rsb				;
	.page
	.subtitle	pli_get_datatype
	.psect	dbg$own,noexe,pic,long		;

vax_to_pli_tbl::				;table converts to control the
						;converstion from vax standard
						;descriptors to pli value
						;descriptors
	.repeat	<36>
	.byte	-1				;default type is no convert
	.byte	0
	.endr
end_vax_to_pli::
	.macro	mte vax_type,code,pli_type=0
	.=vax_to_pli_tbl+<vax_type*2>
	.byte	code
	.byte	pli_type
	.endm	mte
;
; build the table
;
	mte	dsc$k_dtype_z,-1		;unspecified
	mte	dsc$k_dtype_v,-5,bit_aligned_	;aligned bit
	mte	dsc$k_dtype_bu,+8,fixed_bin_	;byte unsigned
	mte	dsc$k_dtype_wu,+16,fixed_bin_	;word unsigned
;***temp for now unsigned longword treated as fixed bin(31)
;this is needed for ex \ to convert to an address
;later change to make conversion in dbg$npli_type_conv
	mte	dsc$k_dtype_lu,+31,fixed_bin_	;longword unsigned
	mte	dsc$k_dtype_qu,-16		;quadword unsigned
	mte	dsc$k_dtype_ou,-17		;octaword unsigned
	mte	dsc$k_dtype_b,+7,fixed_bin_	;byte signed integer
	mte	dsc$k_dtype_w,+15,fixed_bin_	;word signed integer
	mte	dsc$k_dtype_l,+31,fixed_bin_	;longword signed integer
	mte	dsc$k_dtype_q,-18		;quadword signed integer
	mte	dsc$k_dtype_o,-19		;octaword signed integer
	mte	dsc$k_dtype_f,24,float_bin_	;f_float
	mte	dsc$k_dtype_d,53,float_bin_	;d_float
	mte	dsc$k_dtype_g,53,float_bin_	;g_float
	mte	dsc$k_dtype_h,113,float_bin_	;h_float
	mte	dsc$k_dtype_fc,-1		;f_float complex
	mte	dsc$k_dtype_dc,-1		;d_float complex
	mte	dsc$k_dtype_gc,-1		;g_float complex
	mte	dsc$k_dtype_hc,-1		;h_float complex
	mte	dsc$k_dtype_cit,-1		;cobol intermediate temporary
;***temp
dsc$k_dtype_vu=34
dsc$k_dtype_blv=33
	mte	dsc$k_dtype_vu,-3,bit_		;bit unaligned
	mte	dsc$k_dtype_blv,-6,label_	;bound label value
	mte	dsc$k_dtype_bpv,-7,entry_	;bound procedure value
	mte	dsc$k_dtype_t,-2,char_		;text
	mte	dsc$k_dtype_nu,-1		;numeric string unsigned
	mte	dsc$k_dtype_nl,-1		;left separate signed
	mte	dsc$k_dtype_nlo,-1		;right separate signed
	mte	dsc$k_dtype_nr,-1		;right overpunched signed
	mte	dsc$k_dtype_nro,-1		;zoned signed
	mte	dsc$k_dtype_nz,-1		;numeric string zoned signed
	mte	dsc$k_dtype_p,-4,fixed_dec_	;packed decimal
;insert 23-Nov-81 by PS, new data type - 37
        mte     dsc$k_dtype_vt,-2,char_var_     ;varying text
;
.=end_vax_to_pli				;point to end of table
	.psect	dbg$code,exe,nowrt,long,pic,shr ;	
	.entry	pli_get_datatype,^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>
;
;****************************************************************
;*								*
;* pli_get_datatype						*
;*								*
;* 1) this routine assumes kind code is data			*
;* 2) THIS ROUTINE ASSUMES DBG$STA_SETCONTEXT HAS BEEN CALLED	*
;* 3) this routine ADDS to the bit offset so it must be cleared	*
;*	upon entrance to this routine unless it contains	*
;*	a value.						*
;*								*
;* input:symid (for error messages)				*
;*	 fcode							*
;*	 type id						*
;* output:pli data type	(longword)				*
;*	  pli size code	(longword)				*
;*	  vd bit offset (longword)				*
;*	note: the output is part of a value descriptor		*
;*								*
;****************************************************************
;
; register	use
;	r11	points to value descriptor
;	r10	points to descriptor
;	r9	holds bit offset addend
;	r8	byte address from descriptor
;***temp ***warning currently r8 is not used because of the
;***temp convention that descriptors always will have 0 for
;***temp dsc$a_pointer.
;	r7	pointer to structure descriptor optional type block
;
ap_symid	=	4		;symid
ap_fcode	=	8		;value of fcode
ap_type_id	=	12		;value of type_id
ap_type_block_ptr =	16		;pointer to optional type block
					;(or zero if none)
ap_vd_ptr	=	20		;pointer to value descriptor
ap_message_vect	=	24		;message vector
	movl	ap_vd_ptr(ap),r11	;point to value desc. storage
	clrl	r9			;clear bit offset addend
	casel	ap_fcode(ap),#rst$k_type_minimum,- ;case on the fcode values
		#18-rst$k_type_minimum	;we currently only know about 18
10$:	.word	100$	-	10$	;1 array type
	.word	1000$	-	10$	;2 atomic (VAX std.)
	.word	2000$	-	10$	;3 descriptor (VAX std.)
	.word	9200$	-	10$	;4 enumeration type
	.word	3000$	-	10$	;5 picture
	.word	9200$	-	10$	;6 typed pointer
	.word	4000$	-	10$	;7 record
	.word	9200$	-	10$	;8 set
	.word	9200$	-	10$	;9 subrange
	.word	9200$	-	10$	;10 subset
	.word	9200$	-	10$	;11 union
	.word	9200$	-	10$	;12 cobol hack
	.word	9200$	-	10$	;13 bliss data item
	.word	9200$	-	10$	;14 bliss field
	.word	5000$	-	10$	;15 file
	.word	6000$	-	10$	;16 pointer
	.word	7000$	-	10$	;17 area
	.word	8000$	-	10$	;18 offset
	brw	9000$			;not supported yet (unknown type)
;
;array data type
;***later currently the pli compiler never outputs dst's of type descriptor
;if it has an array. If we decide to support output from other compilers
;(if his is possible) then this code should change
;
;	fcode		$a_desc		arg1		arg2		cont
;
; dbg$sta_typ_array	dscaddr		celltype	2nd fcode	(yes)
;
100$:					;
	movl	ap_type_block_ptr(ap),r7 ;point to struc. desc. opt. type block
	movl	pli_struc_opt$a_desc(r7),r10 ;point to array descriptor
	tstb	dsc$b_dtype(r10)	;special 0 dtype?
	beql	200$			;branch if not standard vax dtype
	cmpb	#dsc$k_class_vsa,dsc$b_class(r10) ;varying string array?
	beql	150$			;branch if varying string array
	brw	2100$			;merge with standard descriptor code
;
;special case varying string array, dtype looks like text but isn't translated
;into char_, instead translated into char_var_
;
150$:	movzwl	dsc$w_length(r10),r3	;maximum size in bytes
	movl	#char_var_,r2		;pli datatype
	brb	1020$			;merge with common code
;
;type code is not vax standard type
;
200$:
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	ap_vd_ptr(ap)		;pass along vd pointer
	pushl	pli_struc_opt$a_cont(r7);point to next optional type block
	pushl	pli_struc_opt$l_arg1(r7);type id
	pushl	pli_struc_opt$l_arg2(r7);fcode
	pushl	ap_symid(ap)		;pass symid for error messages
	calls	#6,pli_get_datatype	;recur
	ret				;use return from call
;
;atomic data type
;
;
;	fcode		$a_desc		arg1		arg2		cont
;
; dbg$sta_typ_atomic	0		typecode	-		-
;
;
1000$:
	movl	ap_type_block_ptr(ap),r7 ;point to struc. desc. opt. type block
	movl	pli_struc_opt$l_arg1(r7),r1 ;get dtype
1010$:	bsbw	convert_vax		;get pli type and length
	bgtr	1020$			;branch if ok
	brw	9200$			;signal datatype not implemented yet
;
;upon entrance:
;	register	use
;	r2		pli type
;	r3		pli "size"
;	r9		pli bit offset
1020$:					;
	movl	r2,pli_vd$l_type(r11)	;pli type code
	movl	r3,pli_vd$l_size(r11)	;pli "size" code
	addl2	r9,pli_vd$l_boff(r11)	;pli bit offset
	movl	#sts$k_success,r0	;successful return
	ret				;


;
; descriptor
;
;	fcode		$a_desc		arg1		arg2		cont
;
; dbg$sta_typ_desc	dscaddr		-		-		-
;
;
2000$:					;
	movl	ap_type_block_ptr(ap),r7 ;point to struc. desc. opt. type block
	movl	pli_struc_opt$a_desc(r7),r10 ;point to descriptor
	movzbl	dsc$b_class(r10),r1	;get the class code
	casel	r1,#1,#13		;
2010$:	.word	2100$-2010$		;1 = dsc$k_class_s = scalar string
	.word	2100$-2010$		;2 = dsc$k_class_d = dynamic string
	.word	2300$-2010$		;3 = dsc$k_class_v = varying buffer
	.word	2090$-2010$		;4 = dsc$k_class_a = array
	.word	2090$-2010$		;5 = dsc$k_class_p = procedure
	.word	9000$-2010$		;6 = ????????
	.word	9200$-2010$		;7 = dsc$k_class_j = label
	.word	9000$-2010$		;8 = ????????
	.word	2800$-2010$		;9 = dsc$k_class_sd = decimal scalar
					;string

	.word	2090$-2010$		;10 = dsc$k_class_nca = non_contiguous
					;array
	.word	2850$-2010$		;11 = dsc$k_class_vs = varying string
	.word	2090$-2010$		;12 = dsc$k_class_vsa = varying string
					;array
	.word	2900$-2010$		;13 = dsc$k_class_ubs = unaligned bit
					;string
	.word	2090$-2010$		;14 = dsc$k_class_uba = unaligned bit
					;array
;
; not implemented yet
;
2090$:	movl	#pli$k_not_yet,r0	;not yet implemented code
	brw	bug_check		;go signal error
;
; has descriptor and fields convert directly to pli value descriptor
;
2100$:					;bit offset zero
	movzwl	dsc$w_length(r10),r4	;length saved in register
	movzbl	dsc$b_dtype(r10),r1	;get type of data
	bsbw	convert_vax		;get the pli data type
;****temp later add bug_check code, message is illegal standard descriptor
;***temp or descriptor not supported by pli
	bgeq	2150$			;branch if standard size, otherwise
	casel	r3,#-7,#5
2110$:	.word	9200$	-	2110$	;-7 bound procedure value
	.word	9200$	-	2110$	;-6 bound label value
	.word	2140$	-	2110$	;-5 bit aligned
	.word	2130$	-	2110$	;-4 fixed decimal
	.word	2140$	-	2110$	;-3 bit unaligned
	.word	2140$	-	2110$	;-2 char_
	brw	9000$			;type unknown to pli
2130$:	movzbl	dsc$b_scale(r10),r3	;get scale
	ashl	#8,r3,r3		;shift to second byte
	movb	dsc$b_digits(r10),r3	;add precision
	bneq	2150$			;merge if non-zero (ok)
	movb	r4,r3			;use the length field for precision
	brb	2150$			;then merge with common code
2140$:	movl	r4,r3			;use length in descriptor as size
2150$:	brw	1020$			;merge with common code



;3 = dsc$k_class_v = varying buffer descriptor
;
; since pli only as char_varying (not bit varying yet, or any other
; kind of varying) we convert EVERYTHING to char_var_. In order
; to process correctly, the value descriptor needs a flag or code
; byte that dbgplityp recognizes so that before the pli run-time
; type converter is called, the varying buffer descriptor is converted
; to a char_var_ string.
;
2300$:	brb	2090$			;later we'll do it (maybe)
;
; 9 = dsc$k_class_sd = decimal scalar string descriptor
;
2800$:	cmpb	#dsc$k_dtype_p,dsc$b_dtype(r10) ;make sure it is packed decimal
	beql	2810$			;branch if packed decimal
	brw	9000$			;unknown type
2810$:	movl	#fixed_dec_,pli_vd$l_type(r11) ;pli type code
	movzbl	dsc$b_scale(r10),r0	;get scale
	ashl	#8,r0,r0		;shift to second byte
	movb	dsc$w_length(r10),r0	;add the precision
	movl	r0,pli_vd$l_size(r11)	;pli size description
;***temp check this out
	addl2	dsc$a_pointer(r10),pli_vd$a_ptr(r11);address of data
	movl	#sts$k_success,r0	;successful return
	ret				;
;
;11 = dsc$k_class_vs = varying string
;
2850$:	movl	#char_var_,r2		;pli character varying data type
	movzwl	dsc$w_maxstrlen(r10),r3	;max size (probably not needed)
	brw	1020$			;merge with common code




;
; 13 = dsc$k_class_ubs = unaligned bit string descriptor
;
2900$:	brb	2100$			;merge with common code
	
;
; picture
;
;
;	fcode		$a_desc		arg1		arg2		cont
;
; dbg$sta_typ_pict	0		pictval		-		-
;
3000$:	movl	ap_type_block_ptr(ap),r7 ;point to struc. desc. opt. type block
	movl	pli_struc_opt$l_arg1(r7),r3 ;size field (pointer to static
					;picture block)
	movl	#pictured_,r2		;pli data type
	clrl	r9			;boff value
	brw	1020$			;common processing
;
; structure
;
4000$:					;
	brw	9100$			;signal oper. on datatype not supported
;
; file
;
; note: language check mae by routine pli_create_type_block
;
5000$:					;file
	movl	#file_,r2		;pli data type of file
	clrl	r3			;size
	clrl	r9			;bit offset
	brw	1020$			;merge with common code
;
; pointer
;
6000$:					;
	movl	#pointer_,r2		;pli data type of pointer
	clrl	r3			;vd size field 0(?)
	brw	1020$			;merge with common code
;
; area
;
7000$:
	brw	9200$			;data type not yet supported
;
; offset
;
8000$:
	brw	9200$			;data type not yet supported
;
;
9000$:					;
;
;create fully qualified pathname vector
;
	pushl	#0			;make room for cs pointer
	pushal	-(sp)			;pointer to pathname vector
	pushl	ap_symid(ap)		;push symid
	calls	#2,dbg$sta_sympathname	;get the pathname vector
	pushal	4(sp)			;cs pointer
	pushl	4(sp)			;pn vector pointer
	calls	#2,pli_pn_to_cs	;convert to counted string
	pushal	msg_pli			;push the "PLI" string address
	pushl	8(sp)			;point to reference (a string)
	pushl	#2			;2 fao arguments
	pushl	#dbg$_unknowntyp	;type is not known to pli
	calls	#4,dbg$nmake_arg_vect	;make the message vector
9090$:	movl	r0,@ap_message_vect(ap) ;pass it as return code
	movl	#sts$k_severe,r0	;severe error
	ret				;	
;
;data type is known but the operation is not supported
;
9100$:	pushl	#dbg$_operdtype		;operation on datatype not supported
9110$:	calls	#1,dbg$nmake_arg_vect	;make the message vector
	brb	9090$			;merge with common code
;
;attempt to evaluate unimplemented type
;
9200$:	pushl	#dbg$_unimplent		;attempt to evaluate unimplemented type
	brb	9110$			;merge with common code
;
; internal subroutine 
; input: r1 holds vax dtype code
; ouput: r2 = PLI data type code
;	 r3 = (length of pli data type) or case code
;	condition code reflects (length of pli data type) or case code (neg.)
;
convert_vax:				;
	movl	#pli$k_never,r0		;default error code
	cmpl	r1,#<end_vax_to_pli - vax_to_pli_tbl>/2 ;bigger than table?
	bgeq	10$			;branch if too big
	ashl	#1,r1,r1		;convert to word displacement
	movab	vax_to_pli_tbl[r1],r1	;point to bytes for entry of interest
	movzbl	1(r1),r2		;pli's data type code	
	cvtbl	(r1),r3			;length of data element or code if
					;descriptor
	rsb				;
10$:	brw	bug_check		;go signal error
	.subtitle pli_make_strides
	.page
	.psect	dbg$own,noexe,pic,long	;
datatyp_len_tbl:			;table converts data types and data
	.repeat	<66>
	.byte	-1			;default type is no convert
	.endr
end_datatyp_len:			;
	.macro	mdlte vax_type,code
	.=datatyp_len_tbl+vax_type
	.byte	code
	.endm	mdlte
;
; build the table
;
	mdlte	dsc$k_dtype_z,-1		;unspecified
	mdlte	dsc$k_dtype_v,-5		;aligned bit
	mdlte	dsc$k_dtype_bu,+1		;byte unsigned
	mdlte	dsc$k_dtype_wu,+2		;word unsigned
	mdlte	dsc$k_dtype_lu,+4		;longword unsigned
	mdlte	dsc$k_dtype_qu,+8		;quadword unsigned
	mdlte	dsc$k_dtype_ou,+16		;octaword unsigned
	mdlte	dsc$k_dtype_b,+1		;byte signed integer
	mdlte	dsc$k_dtype_w,+2		;word signed integer
	mdlte	dsc$k_dtype_l,+4		;longword signed integer
	mdlte	dsc$k_dtype_q,+8		;quadword signed integer
	mdlte	dsc$k_dtype_o,+16		;octaword signed integer
	mdlte	dsc$k_dtype_f,+4		;f_float
	mdlte	dsc$k_dtype_d,+8		;d_float
	mdlte	dsc$k_dtype_g,+8		;g_float
	mdlte	dsc$k_dtype_h,+16		;h_float
	mdlte	dsc$k_dtype_fc,+8		;f_float complex
	mdlte	dsc$k_dtype_dc,+16		;d_float complex
	mdlte	dsc$k_dtype_gc,+16		;g_float complex
	mdlte	dsc$k_dtype_hc,+32		;h_float complex
	mdlte	dsc$k_dtype_cit,-1		;cobol intermediate temporary
dsc$k_dtype_vu=34 ;***temp***
dsc$k_dtype_blv=33 ;***temp***
	mdlte	dsc$k_dtype_vu,-3		;bit unaligned
	mdlte	dsc$k_dtype_blv,-6		;bound label value
	mdlte	dsc$k_dtype_t,-2		;text
	mdlte	dsc$k_dtype_nu,-1		;numeric string unsigned
	mdlte	dsc$k_dtype_nl,-1		;left separate signed
	mdlte	dsc$k_dtype_nlo,-1		;right separate signed
	mdlte	dsc$k_dtype_nr,-1		;right overpunched signed
	mdlte	dsc$k_dtype_nro,-1		;zoned signed
	mdlte	dsc$k_dtype_nz,-1		;numeric string zoned signed
	mdlte	dsc$k_dtype_p,-4		;packed decimal
;insert 23-Nov-81 by PS, new data type 37
        mdlte   dsc$k_dtype_vt,-2               ;varying text
;
.=end_datatyp_len				;point to end of table
	.psect	dbg$code,exe,nowrt,long,pic,shr ;	
msg_pli::.ascic	/PLI/				;language type pli
	.entry	pli_make_strides,^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>
;
;****************************************************************
;*								*
;* pli_make_strides						*
;*								*
;* 1) this routine assumes kind code is data			*
;* 2) THIS ROUTINE ASSUMES DBG$STA_SETCONTEXT HAS BEEN CALLED	*
;*								*
;* input:symid (for error messages)				*
;*	 fcode							*
;*	 type id						*
;*	 stride type						*
;*	 address of stride pointer				*
;* output:stride list						*
;*	  message vector (if error)				*
;*								*
;* The stride list is not guaranteed to be ordered in any way,	*
;* it reflects the structure of the specified data reference.	*
;*								*
;****************************************************************
;
; register	use
;	r11	points to stride list element
;	r10	points to descriptor
;	r9	holds bit offset addend
;	r8	holds byte offset addend
;	r7	points to struct. desc. optional type block (or 0)
;
ap_symid	=	4		;symid
ap_fcode	=	8		;value of fcode
ap_type_id	=	12		;value of type_id
ap_type_block_ptr =	16		;ptr. to struc. desc. opt. type block
ap_stride_type	=	20		;type of stride
ap_stride_ptr	=	24		;pointer to stride list element
ap_message_vect	=	28		;message vector
	movl	ap_stride_ptr(ap),r11	;point to stride pointer
	clrq	r8			;default bit and byte offset
	movl	ap_type_block_ptr(ap),r7;point to struc. desc. opt. type block
	casel	ap_fcode(ap),#rst$k_type_minimum,- ;case on the fcode values
		#18-rst$k_type_minimum	;we currently only know about 18
20$:	.word	100$	-	20$	;1 array type
	.word	1000$	-	20$	;2 atomic (VAX std.)
	.word	2000$	-	20$	;3 descriptor (VAX std.)
	.word	9000$	-	20$	;4 enumeration type
	.word	3000$	-	20$	;5 picture
	.word	9000$	-	20$	;6 typed pointer
	.word	4000$	-	20$	;7 record
	.word	9000$	-	20$	;8 set
	.word	9000$	-	20$	;9 subrange
	.word	9000$	-	20$	;10 subset
	.word	9000$	-	20$	;11 union
	.word	9000$	-	20$	;12 cobol hack
	.word	9000$	-	20$	;13 bliss data item
	.word	9000$	-	20$	;14 bliss field
	.word	5000$	-	20$	;15 file
	.word	6000$	-	20$	;16 pointer
	.word	7000$	-	20$	;17 area
	.word	8000$	-	20$	;18 offset
	brw	9000$			;not supported yet (unknown type)
;
;array
;
;	fcode		$a_desc		arg1		arg2		cont
;
; dbg$sta_typ_array	dscaddr		celltype	2nd fcode	(yes)
;
;
100$:					;
	movl	pli_struc_opt$a_desc(r7),r10 ;point to array descriptor
	tstb	dsc$b_dtype(r10)	;special 0 dtype?
	beql	900$			;branch if special non standard dtype
	bsbw	get_stride_block	;get the stride block
	movl	pli_struc_opt$l_arg1(r7),r1 ;get dtype value
	bsbw	vax_to_bytes		;size in bytes
	bgtr	1020$			;branch if ok
	casel	r8,#-5,#4
200$:	.word	500$	-	200$	;-5	aligned bit
	.word	300$	-	200$	;-4	packed decimal
	.word	500$	-	200$	;-3	bit unaligned
	.word	400$	-	200$	;-2	text, varying text
	.word	9000$	-	200$	;-1	unsupported whatevers
	brw	9000$			;not supported yet
;
;array with dtype of dsc$k_dtype_p - packed decimal
;
300$:	movzwl	dsc$w_length(r10),r0	;length field gives digits
	brw	2130$			;merge with common code
;
;array with dtype of dsc$k_dtype_t - text, dsc$k_dtype_vt - varying text
400$:	movzwl	dsc$w_length(r10),r8	;use length field for length
;
;insert the following code by P.S. - Nov. 20, 1981
        cmpb    #dsc$k_class_vs,dsc$b_class(r10) ;is this varying string descr.
    	beql    410$			;check for the stride type
    	cmpb    #dsc$k_class_vsa,dsc$b_class(r10);is this varying string array
    						 ;   descr.
    	beql    410$			;check for the stride type
    	brw     1020$			;merge with common code
410$:   cmpl    #7,ap_stride_type(ap)   ;is this stride type 7
    	beql    420$                    ;need to add two more bytes to length
    	brw     1020$                   ;merge with common code
420$:   addl2   #2,r8                   ;take control characters into account
;end of insertion.
;
	brw	1020$			;merge with common code
;
;array with length field number of bits
;
500$:	movzwl	dsc$w_length(r10),r9	;number of bits
	clrl	r8			;zero byte count
	brw	1020$			;merge with common code
;
;type code is not vax standard data type
;
900$:	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	ap_stride_ptr(ap)	;pass along stride pointer
	pushl	ap_stride_type(ap)	;pass along stride type
	pushl	pli_struc_opt$a_cont(r7);continued type block address
	pushl	pli_struc_opt$l_arg1(r7);type_id
	pushl	pli_struc_opt$l_arg2(r7);2nd fcode
	pushl	ap_symid(ap)		;pass along symid for error messages
	calls	#7,pli_make_strides	;recur
	ret				;use return from call
;
;atomic data type
;
;	fcode		$a_desc		arg1		arg2		cont
;
; dbg$sta_typ_atomic	0		typecode	-		-
;
;
1000$:	bsbw	get_stride_block	;get the stride block
	movl	pli_struc_opt$l_arg1(r7),r1 ;get dtype value
1010$:	bsbw	vax_to_bytes		;size in bytes
	bgtr	1020$			;branch if ok
;*******temp, code to handle special atomic types goes here

	brw	9000$	;*temp
;
;upon entrance:
;	register	use
;	r11		new stride block
;	r9		bits of data
;	r8		byte bytes of data
1020$:					;
	movl	r8,pli_sd_bytes(r11)	;put in bytes
	movl	r9,pli_sd_bits(r11)	;put in bits
	movl	#sts$k_success,r0	;successful return
	ret				;
;
; descriptor
;
;	fcode		$a_desc		arg1		arg2		cont
;
; dbg$sta_typ_desc	dscaddr		-		-		-
;
2000$:	bsbw	get_stride_block	;get the stride block
	movl	pli_struc_opt$a_desc(r7),r10 ;point to descriptor
	movzbl	dsc$b_class(r10),r1	;get the class code
	casel	r1,#1,#13		;
2010$:	.word	2100$-2010$		;1 = dsc$k_class_s = scalar string
	.word	2100$-2010$		;2 = dsc$k_class_d = dynamic string
	.word	2300$-2010$		;3 = dsc$k_class_v = varying buffer
	.word	2090$-2010$		;4 = dsc$k_class_a = array
	.word	2090$-2010$		;5 = dsc$k_class_p = procedure
	.word	9000$-2010$		;6 = ????????
	.word	2090$-2010$		;7 = dsc$k_class_j = label
	.word	9000$-2010$		;8 = ????????
	.word	2800$-2010$		;9 = dsc$k_class_sd = decimal scalar
					;string

	.word	2090$-2010$		;10 = dsc$k_class_nca = non_contiguous
					;array
	.word	2100$-2010$		;11 = dsc$k_class_vs = varying string
	.word	2090$-2010$		;12 = dsc$k_class_vsa = varying string
					;array
	.word	2900$-2010$		;13 = dsc$k_class_ubs = unaligned bit
					;string
	.word	2090$-2010$		;14 = dsc$k_class_uba = unaligned bit
					;array
;
; not implemented yet
;
2090$:	movl	#pli$k_not_yet,r0	;not yet implemented code
	brw	bug_check		;go signal error
;
; has descriptor and fields convert directly to pli stride descriptor
; upon entrance,
;	register	use
;	r11		stride block pointer
;	r10		descriptor pointer
;	r9		bit offset
;	r8		byte offset
;	r7		pointer to optional type block
;
2100$:					;bit offset zero
	movzwl	dsc$w_length(r10),r0	;length saved in register
2110$:	movzbl	dsc$b_dtype(r10),r1	;get type of data
	cmpb	#dsc$k_dtype_vu,r1	;unaligned bit?
	beql	2120$			;branch if unaligned bit
	cmpb	#dsc$k_dtype_v,r1	;aligned bit?
	beql	2120$			;branch if aligned bit
	cmpb	#dsc$k_dtype_p,r1	;packed decimal string?
	beql	2130$			;branch if packed decimal
;
;length field represents number of bytes
	movl	r0,r8			;common code preparation (no. bytes)
	brw	1020$			;merge with common code (r9 = 0)
;
;length field represents number of bits
2120$:	movl	r0,r9			;common code preparation (no. bits)
	brw	1020$			;merge with common code (r8 = 0)
;
;length field represents number of packed decimal digits
;
2130$:	ashl	#-1,r0,r0		;number of bytes for digits
	addl3	#1,r0,r8		;add byte for sign
	brw	1020$			;merge with common code (r9 = 0)
;3 = dsc$k_class_v = varying buffer descriptor
;
;
2300$:					;
	bitl	#pli_st$m_maxlen,ap_stride_type(ap) ;use current for length?
	beql	2100$			;branch if we use current length
	movzwl	dsc$w_maxlen(r10),r0	;use maximum length
	brw	2110$			;merge with common code


;
; 9 = dsc$k_class_sd = decimal scalar string descriptor
;
2800$:	cmpb	#dsc$k_dtype_p,dsc$b_dtype(r10) ;make sure it is packed decimal
	bneq	9000$			;branch if unknown type
	brw	2100$			;merge with common code
;
; 13 = dsc$k_class_ubs = unaligned bit string descriptor
;
2900$:					;
	movl	dsc$l_pos(r10),pli_sd_beg_bit(r11);bit offset from starting
					;address
	movzwl	dsc$w_length(r10),r0	;length saved in register
	brw	2120$			;merge with common bit code	
;
; picture
;
;	fcode		$a_desc		arg1		arg2		cont
;
; dbg$sta_typ_pict	0		pictval		-		-
;
;
;
;
3000$:	bsbw	get_stride_block	;get the stride block
	movl	pli_struc_opt$l_arg1(r7),r2 ;size field (pointer to static
					;picture block
	movzbl	pic$b_byte_size(r2),r8	;number of bytes in picture
	clrl	r9			;bit offset
	brw	1020$			;common processing
;
; structure
;
4000$:					;
	brw	9000$			;***temp
;
; file
;
;	note: language check made by routine pli_create_type_block
;
5000$:	bsbw	get_stride_block	;get the stride block
	movl	#4,r8			;4 bytes for pointer
	clrl	r9			;no bit offset
	brw	1020$			;merge with common code
;
; pointer
;
6000$:	bsbw	get_stride_block	;get the stride block
	movl	#4,r8			;4 bytes for pointer
	clrl	r9			;no bit offset
	brw	1020$			;merge with common code
;
; area
;
;	fcode		$a_desc		arg1		arg2		cont
;
; dbg$sta_typ_area	0		byte_len	-		-
;
;*****later
;
7000$:
;
; offset
;
;	fcode		$a_desc		arg1		arg2		cont
;
; dbg$sta_typ_offset	0		area_id		-		-
;
;
;***later
;
8000$:
;
;data type not known to pli
;
9000$:					;
;
;create fully qualified pathname vector
;
	pushl	#0			;make room for cs pointer
	pushal	-(sp)			;pointer to pathname vector
	pushl	ap_symid(ap)		;push symid
	calls	#2,dbg$sta_sympathname	;get the pathname vector
	pushal	4(sp)			;cs pointer
	pushl	4(sp)			;pn vector pointer
	calls	#2,pli_pn_to_cs		;convert to counted string
	pushal	msg_pli			;push the "PLI" string address
	pushl	8(sp)			;point to reference (a string)
	pushl	#2			;2 fao arguments
	pushl	#dbg$_unknowntyp	;type is not known to pli
	calls	#4,dbg$nmake_arg_vect	;make the message vector
	movl	r0,@ap_message_vect(ap) ;pass it as return code
	movl	#sts$k_severe,r0	;severe error
	ret				;	
;
; internal subroutine 
;  input:  r1 holds vax dtype code
; output:  r8 = length in bytes or case code
;
; condition code set by value of r8
;
vax_to_bytes:				;
	movl	#pli$k_tbl,r0		;default error code
	cmpl	r1,#<end_datatyp_len - datatyp_len_tbl> ;bigger than table?
	bgeq	10$			;branch if too big
	movab	datatyp_len_tbl[r1],r1	;point to bytes for entry of interest
	cvtbl	(r1),r8			;length of data element or code if
	rsb				;descriptor
10$:	brw	bug_check		;go signal error
;
; internal subroutine
;
;	get_stride_block
;
;routine gets a stride descriptor block, using pli_sd_link(r11)
;(r11 is a pointer to dummy head or previous stride descriptor),
;to point to this new block. R11 is then updated to point to the
;new stride descriptor block.
;
get_stride_block:			;
	pushl	ap_message_vect(ap)	;pass along message vector
	pushal	pli_sd_link(r11)	;longword that points to storage
	pushl	#<pli_sd$k_size+3>/4	;number of longwords needed
	calls	#3,dbg$nlist_freez	;get the storage
	blbs	r0,10$			;branch if ok
	ret				;
10$:	movl	pli_sd_link(r11),r11	;point to new sd list element
	rsb				;

	.page
	.subtitle	pli_get_pn_desc_size
;
;************************************************************************
;	pli_get_pn_desc_size						*
;************************************************************************
;
;	function is passed the address of a pathname descriptor
;	value returned is the number of bytes in that descriptor
;
;	register	use
;	r3		pointer to individual pn strings
;	r2		sob counter
;	r1		pointer within pathname desciptor
;	r0		sums up total bytes
;
ap_pn_desc_addr	=	4		;address of pathname descriptor
	.entry	pli_get_pn_desc_size,^m<r2,r3,r4>
	movl	ap_pn_desc_addr(ap),r1	;point to start of pathname descriptor
	movzbl	pth$b_totcnt(r1),r2	;total number of path vector elements
	ashl	#2,r2,r0		;bytes required by path vector elements
	addl2	#pth$a_pathvector,r0	;add fixed area of pathname vector
	moval	pth$a_pathvector(r1),r1	;point to first path vector element
10$:	movl	(r1)+,r3		;point to individual string
	movzbl	(r3),r4			;get the byte count
	addl2	r4,r0			;add to running sum
	incl	r0			;add byte for byte count
	sobgtr	r2,10$			;iterate for each vector element
	ret				;
	.page
	.subtitle	pli_get_pn_string_size
;
;************************************************************************
;	pli_get_pn_string_size						*
;************************************************************************
;
;	function is passed the address of a pathname descriptor
;	value returned is the number of bytes required to hold the
;	printable symbolization of that pathname
;
;	register	use
;	r3		pointer to individual pn strings
;	r2		sob counter
;	r1		pointer within pathname desciptor
;	r0		sums up total bytes
;
ap_pn_desc_addr	=	4		;address of pathname descriptor
	.entry	pli_get_pn_string_size,^m<r2,r3,r4>
	movl	ap_pn_desc_addr(ap),r1	;point to start of pathname descriptor
	movzbl	pth$b_totcnt(r1),r2	;total number of path vector elements
	movl	#-1,r0			;total byte count, bias because last
					;element has no separating character
	moval	pth$a_pathvector(r1),r1	;point to first path vector element
10$:	movl	(r1)+,r3		;point to individual string
	movzbl	(r3),r4			;get the byte count
	addl2	r4,r0			;add to running sum
	incl	r0			;add byte for separator character
	sobgtr	r2,10$			;iterate for each vector element
	ret				;
	.end

