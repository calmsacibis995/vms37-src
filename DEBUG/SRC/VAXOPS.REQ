!  VAXOPS.REQ - OP CODE TABLE FOR VAX INSTRUCTIONS
!
!	Version 'V03-000'
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!  Author:
!		KEVIN PAMMETT, MARCH 2, 1977.
!
!  Modified by:
!		Dale Roedger, 17 May 1978: Version V02-003
!
!  Revision History
!
!	01	30-JUN-77	KGP	-Added another AMODE literal
!					for PC-Displacement mode.
!
!	02	2-nov-77	KGP	-Added literals to enable us to
!					 special-case CASE instructions.
!	03	17-MAY-78	DAR	Changed branch_token to brch_token
!					and literal_token to lit_token to avoid
!					confusion with the grammar.
!	04	27-Jun-79	JBD	- Added structure decl to 
!					support 2 byte opcodes.
!	05	29-JUN-79	JBD	- Changed things to support
!					new context indicators. Required

!					expanding the OPx fields in OPI
! 06	6-DEC-79	JBD	Maybe the 3 bit fields in OPI wasn't such a
!				good idea after all. Increasing it to 4 bits
! 07	10-Dec-79	JBD	BLISS has bugs in STRUCTURE declarations. Added
!				a local var to bypass the bug.
!--

LITERAL		! CONTEXT INDICATORS USED TO FILL THE 3-BIT
		!  PER OPERAND FIELD OF EACH OPINFO ENTRY PER OPCODE.
		! Note that these numbers are the power to which to 
		! raise 2 to in order to get the number of bytes an
		! operand consumes.

	NUL	= 0,	! OPCODE DOES NOT HAVE THIS OPERAND.
	BYT	= 0,	! PC-RELATIVE MODE CONSUMES 1 BYTE.
	WRD	= 1,	! PC-RELATIVE MODE CONSUMES 2 BYTES,
	LNG	= 2,	! PC-RELATIVE MODE CONSUMES 4 BYTES
	QAD	= 3,	! PC-RELATIVE MODE CONSUMES 8 BYTES.
	GRN	= 3,	! PC-RELATIVE MODE CONSUMES 8 BYTES.
	HUG	= 4,	! PC-RELATIVE MODE CONSUMES 16 BYTES.

	! BRANCH TYPE INDICATORS.

	NO_BR	= 0,	! OPCODE HAS NO BRANCH TYPE OPERANDS
	BR_BY	= 1,	! LAST OPERAND'S BYTE OPERAND SPECIFIES BRANCH DISPL.
	BR_WD	= 2;	! LAST OPERAND'S WORD OPERAND SPECIFIES BRANCH DISPL.


MACRO
	!++
	!
	! THE FOLLOWING 'OPI' MACRO IS USED TO BUILD SUCCESSIVE ENTRIES FOR
	! THE 'OPINFO' TABLE.  EACH MACRO CALL CONTAINS THE
	! INFO FOR 1 VAX OPCODE, AND THE ENTRIES ARE SIMPLY
	! BUILT IN THE ORDER THAT THE MACRO CALLS ARE MADE -
	! THE ASSUMPTION IS THAT THEY WILL BE MADE IN ORDER OF
	! INCREASING OPCODE VALUES.  THIS IS NECESSARY BECAUSE
	! THE TABLE IS ACCESSED BY USING A GIVEN OPCODE AS THE
	! TABLE INDEX.

	! WARNING:
	!	THE FOLLOWING MACRO BUILDS THE TABLE IN A POSSIBLY-DANGEROUS
	!  WAY.  SPECIFICALLY, THERE IS NOT REALLY A SEPARATE FIELD TO
	!  CONTAIN THE 'BRANCH ADDRESSING' INFORMATION.  A SEPARATE
	!  FIELD IS NAMED AND ACCESSED VIA THE OP_BR_TYPE MACRO,
	!  BUT THIS INFORMATION IS ACTUALLY STUFFED INTO THE SAME
	!  FIELD AS THE LAST OP_CONTEXT ENTRY.  THE ONLY REASON WE
	!  GET AWAY WITH THIS IS:
	!	1) WE KNOW HOW MANY OPERANDS EACH INSTRUCTION IS
	!	   SUPPOSED TO HAVE, SO WE KNOW WHETHER OR NOT 
	!	   THE LAST OP_CONTEXT ENTRY IS BEING USED TO
	!	   CONTAIN CONTEXT INFORMATION.
	!	2) IT SO HAPPENS THAT
	!		2.1) IF ANY OPCODE HAS A BRANCH TYPE ADDRESSING
	!		     OPERAND, THEN IT IS THE LAST OPERAND TO
	!		     WHICH THIS SPECIAL ADDRESSING APPLIES,
	!		AND
	!		2.2) NO OPCODES WHICH HAVE BRANCH TYPE ADDRESSING
	!		     AT ALL EVER HAVE THE MAXIMUM NUMBER OF OPERANDS.
	!
	!  WE CAN CHECK OUT THESE CONDITIONS IN THE PROPER ORDER
	!  TO ASCERTAIN WHEN THIS POPULAR FIELD IS BEING USED FOR WHAT.
	!  IF/WHEN THE ABOVE CONDITIONS DO NOT HOLD, THE DATA
	!  STRUCTURE CAN BE REBUILT SIMPLY BY CHANGING THE MACRO GIVEN BELOW.
	!  ALL OF THIS IS DONE TO MINIMIZE THE TABLE SIZE OF DBG$GB_OPINFO.
	!
	!--


	OPI( NAME, NUMOP, OPC, OP1, OP2, OP3, OP4, OP5, OP6, BR_TYP ) =
	%RAD50_11 NAME,
	( OP1^4 OR NUMOP ),
	( OP2 OR OP3^4 ),
	( OP4 OR OP5^4 ),
	( OP6 OR BR_TYP^4 ) %,

	! MACROS TO ACCESS THE FIELDS.

		! OPCODE MNEMONIC
	OP_NAME		= 0,0,32,0	%,	! LONGWORD CONTAINS 6 RAD50 CHARS.

		! FIELD TO SAY HOW MANY OPERANDS
		!  THIS OPCODE HAS.  THIS IS ALWAYS FIXED.
	OP_NUMOPS	= 4,0,4,1	%,	!  NOTE THE SIGN EXTENSION.
						!  IT IS NECESSARY BECAUSE WE
						!  USE -1 TO INDICATE A
						!  RESERVED OPCODE.

		! 1 FIELD FOR EACH POSSIBLE OPERAND
	OP_CONTEXT(I) = 4+I/2, ((I) AND 1)*4, 4, 0 %,
		! Context field for each possible operand. 

		! BRANCH TYPE ADDRESSING FIELD
	OP_BR_TYPE = 7,4,2,0 %;		! 2 Bit field which contains
						! ONE OF THE 'BRANCH TYPE'
						! INDICATORS GIVEN ABOVE.

LITERAL
	OPTSIZE	= 8,		! EACH OPINFO BLOCK IS 9 BYTES LONG.
	MAXOPCODE = %X'FD',	! MAXIMUM VAX OP CODE WHICH IS VALID.
	MAXOPRNDS = 6,		! MAXIMUM NUMBER OF OPERANDS PER INSTRUCTION.
				! NO INSTRUCTION THAT HAS BRANCH TYPE ADDRESSING
				! CAN HAVE THIS MANY OPERANDS UNLESS WE CHANGE
				! THE ORGANIZATION OF EACH OPINFO BLOCK.
	BITS_PER_BYTE = 8,	! NUMBER OF BITS IN A VAX BYTE.
	AP_REG	= 12,		! NUMBER OF PROCESSOR REGISTER, 'AP'.
	PC_REG	= 15,		! NUMBER OF PROCESSOR REGISTER, 'PC'.

	PC_REL_MODE = 8,	! ADDRESSING MODE: (PC)+
	AT_PC_REL_MODE = 9,	! ADDRESSING MODE: @(PC)+
	INDEXING_MODE = 4,	! ADDRESSING MODE: XXX[RX]

	SHORT_LIT_AMODE	= 0,	! Short literals fit right into the mode byte.
	REGISTER_AMODE	= 5,	! Register mode addressing.
	REG_DEF_AMODE	= 6,	! Register deferred addressing mode.
	AUTO_DEC_AMODE	= 7,	! Auto decrement addressing mode.
	AUTO_INC_AMODE	= 8,	! Auto Increment addressing mode.
	DISP_BYTE_AMODE	= 10,	! All of the displacement modes start from
				!  here.  See ENC_OPERAND() IN DBGENC.B32
	DISP_LONG_AMODE	= 14,
	OP_CH_SIZE = 6;		! SIZE, IN ASCII CHARS, OF OPCODE MNEMONIC.

MACRO
	DSPL_MODE = 0,4,4,0 %,	! ADDRESSING MODE BITS FROM THE DOMINANT MODE
				!  BYTE OF AN OPERAND REFERENCE.
	DOM_MOD_FIELD = 0,5,2,1 %, 
				! BITS WHICH WE PICK UP TO DIFFERENTIATE CERTAIN
				!  TYPES OF DOMINANT MODES.  SEE DBGMAC.B32
	SHORT_LITERAL = 0,0,6,0 %,
				! HOW TO EXCTRACT A 'SHORT LITERAL' FROM
				!   THE INSTRUCTION STREAM.  SEE SRM.
	AMODE	= 0,4,4,1 %,	! BITS OF DOMINANT MODE ADDRESSING BYTE
				!   WHICH SPECIFY THE ACTUAL MODE.
	AREG	= 0,0,4,0 %,	! BITS OF DOMINANT MODE ADDRESSING BYTE
				!   WHICH SPECIFY REGISTER NUMBER, ETC.
	NOT_AN_OP = -1 %,	! OPINFO INDICATOR FOR UNASSIGNED OPCODES.
	RESERVED = 'UNUSED' %;	! NAME OF RESERVED OPCODES.


MACRO
	NEXT_FIELD(INDEX) 	! USED TO GET THE ADDRESS OF THE NEXT
				!   FIELD OF A BLOCK.
		= (INDEX),0,0,0 %;

!  MACROS AND LITERALS SPECIFICALLY FOR INSTRUCTON ENCODING.
!  ('MACHINE -IN'.)

LITERAL
	BAD_OPCODE	= 1,	! CAN'T INTERPRET THE GIVEN ASCII OPCODE.
	BAD_OPERAND	= 2,	! UNDECODABLE OPERAND REFERENCE.
	BAD_OPRNDS	= 3,	! WRONG NUMBER OF OPERANDS.
	INS_RESERVED	= 4;	! GIVEN OPCODE IS RESERVED.

LITERAL
		! We only have to special-case a few OPCODES,


	OP_CASEB	= %X'8F',
	OP_CASEW	= %X'AF',
	OP_CASEL	= %X'CF';
!++
!
!	TOKEN VALUES USED FOR ENCODING/DECODING
!
!--

LITERAL
	indexing_token	= 240,
	val_token	= 241,
	byte_val_token	= val_token + byte_length,	! 242
	word_val_token	= val_token + word_length,	! 243
	brch_token	= 244,
	long_val_token	= val_token + long_length,	! 245
	at_reg_token	= 246,
	register_token	= 247,
	lit_token	= 248,
	bad_token	= 249;


! The following structure declaration selects the proper opcode
! table by looking for the extended opcode opcode(s).
STRUCTURE OPCODE_TBL [OPC,O,P,S,E] =
	BEGIN
	EXTERNAL DBG$GB_OPINFO1 : BLOCKVECTOR[256,OPTSIZE,BYTE];
	EXTERNAL DBG$GB_OPINFO2 : BLOCKVECTOR[256,OPTSIZE,BYTE];
	LOCAL OFFSET;
	OFFSET = O;
	IF (OPC AND %X'FF') NEQ %X'FD'
	THEN DBG$GB_OPINFO1[OPC,.OFFSET,0,8,0]	! One byte opcodes
	ELSE DBG$GB_OPINFO2[(OPC^-8),.OFFSET,0,8,0]	! Two byte opcodes
	END<P,S,E>;

!	VAXOPS.REQ	- last line
