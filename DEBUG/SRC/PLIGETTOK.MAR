;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
	.title pligettok
	.ident 'V03-000'
	$dscdef
	$stsdef
	$dbgdef
	$dbglib
	$plidef
	$dstrecrds
	.subtitle	get token mainline

;
; ROUTINE - gettoken(mode,input_desc,radix,no_path,token_type,result,
;			message_vect)
;
;   INPUT PARAMETERS
; mode = pointer to a longword containing the mode code
; input_desc = pointer to the input string descriptor
; radix = pointer to a longword that contains a legal radix value or 0
;	  (if zero, then the pli default radix of 10 is used)
; no_path=bit value, if set no pathname lookup (value)
;   OUTPUT PARAMETERS
; input_desc = generally points past token (see below for details)
; token_type = pointer to longword to contain the token type
; result = pointer to the longword vector of result values
; message_vect = points to message vector if severe return
;
;
;
; Where modes are:
;
;	pli_node_mode$k_dae		debug address expression
;	pli_node_mode$k_pli		pli expression (with debug extensions)
;	pli_node_mode$k_c		c (not supported yet)
;
;
; Where input descriptor initially gives input string including cr.
; On exit it "points past token":
;
;	tokens on line		Input descriptor update
;	--------------        ----------------------------
;
;	0			If non-blank and not CR then point to first
;				such character.
;				If CR or all blanks (followed by CR), zero
;			        descriptor.
;
;	1			Descriptor points to CR.
;
;	2 or more		point to first non-blank after 1st token.
;
;
;
; 
;
; note:if a token, or absence of a token is considered an error, it
;	is usually best to use the result vector to determine where
;	the problem occured. Even when returning token type null,
;	the result vector points to the character(s) last scanned.
;	The input vector on the other hand may be zeroed, and in
;	general points to where the scan should continue next time
;	this routine is called.
;
;
;
;Where radix is the radix to be used when calculating debug address
; expressions. It is not used if mode is pli expressions.
;
;
;
;
; DESIGN GOALS:
;
;	1) separate pathname parsing so it can evolve (and be maintained
;	   separately (by the debug group).
;
;	2) support multiple language expressions within a single parse tree
;
;
;
; ERROR LEVEL DISCIPLINE:
;
;	As parsing of the input line takes place, information about the input
;	string in the form of a pointer, a length, and an input descriptor, is
;	stacked to aid in error recovery. Initially nothing is
;	stacked and code is said to be executing at error level 0. Once we
;	stack the current position in the input string we increase our error
;	level to one. The address of the input descriptor is stacked
;	redundantly for ease of processing.
;
;
;	The stacked values are independent of (and supercede in a sense), the
;	value of the input string descriptor. This is because called routines
;	are allowed to modify the input string descriptor and this routine
;	can still decide that a called routine was wrong about  accepting
;	part of the input string. By using previously stacked input
;	descriptor values, it can "back up the input descriptor" and recover.
;
;
;	level zero stack assumptions: no error recovery information stacked
;
;
;	level one stack assumptions:
;             +-------------------------------------------+
;       (SP): !      length of original input string      !
;             +-------------------------------------------+
;      (SP)+4 !     address of original input string      !
;             +-------------------------------------------+
;      (SP)+8 !     address of input string's descriptor  !
;	      +-------------------------------------------+
;
;
;
;	...
;
;
;	level n stack assumptions:
;             +-------------------------------------------+
;       (SP): !      length of remaining input string     !
;             +-------------------------------------------+
;      (SP)+4 !     address of remaining input string     !
;             +-------------------------------------------+
;      (SP)+8 !     address of input string's descriptor  !
;	      +-------------------------------------------+
;      (SP)+12!   error level n-1 stack values            !
;	      !   on stack				  !
;	      !						  !
;
;
;
;
;
;
;	typical use would relate error levels to positions in
;	a string such as:
;
;	             PATHNAME  \    %r0
;        ^           ^		    ^
;        !           !		    !
; level 1!      level 2		level 3
;
;
;
;
; ROUTINES CALLED:
;
;	dbg$npathname_parser(input_desc,scanner_addr,pathname_desc,value)
;
;
;
; REGISTER   USE
;
;	General:
;
;	r11	input descriptor
;	r10	pathname descriptor pointer
;	r6	length of string
;	r7	address of first character of string
;
;
;
;	permsym:
;	
;	r9	start of symbol list
;	r8	pointer into index list
;	r7	address of string
;	r6	length of test
;	r5	address of identifier
;	r4	length of identifier
;
;
;	digit:
;
;	r10	= number of digits
;	r9	= radix
;	r8	= holds individual ascii digits
;
;
;
; PARSE TABLE ENTRY CODE
;
; Each byte in the 256 byte table is coded as follows:
;
;    7        6       5       4      3        2       1       0
; +-------+-------+-------+-------########+#######+#######+#######+
; !       !       !       !       #       !       !       !       #
; !       !       ! alpha !       #       !       !       !       #
; ! a - f ! digit !   $   !       #     case code (see below)     #
; !       !       !   _   !       #       !       !       !       #
; !       !       !       !       #       !       !       !       #
; +-------+-------+-------+-------########+#######+#######+#######+
;
;
;
;	case	value
;   ---------- ---------
;    error	  0
;    alpha,$,_	  1
;    digit	  2
;    backslash	  3
;    %		  4
;    CR		  5
;    dot	  6
;    left paren.  7
;    right paren. 8
;    comma       10
;    dash        11
;    slash       12
;    pli oper    13
;
;
;
;
; LOCAL MACROS
;  MTE makes table entries into the parse table p_table
	.macro	mte char,code
	.if idn /,<char>
	.if_true
 .=p_table+^Aa/a
	.if_false
 .=p_table+^A/char/
	.endc
	.byte	code
	.endm	mte
; LOCAL SYMBOL DEFINITIONS
;
;
; parse table byte masks for the classes of characters
m_alpha$_ = ^b00100000
m_digit   = ^b01000000
m_a_to_f  = ^b10000000
;
; parse table codes
;
error_code	=	 0
alpha_code	=	 1
digit_code	=	 2
backslash_code	=	 3
percent_code	=	 4
cr_code		=	 5
dot_code	=	 6
lp_code		=	 7
rp_code		=	 8
comma_code	=	 9
dash_code	=	10
slash_code	=	11
pli_oper_code	=	12
quote_code	=	13
last_code	=	13
;
;pli operators consist of:
;	+ - ^				(prefix operators)
;	> >= = < <= ^> ^= ^<		(comparison)
;	+ - * / **			(infix operators)
;	->				(pointer)
;	!!				(concatenation)
;	!  &				(logical)
;
; notes on operators and codes:
;
;	Dash is a special parse code because pointer is a token type returned
;	by this routine.
;
;	Slash is a special parse code because it is a pli comment delimiter.
;
;	We chose not to make codes for each pli operator to reserve a table
;	code bit for possible extensions. It also has the effect of isolating
;	language operators (perhaps causing other tables for this purpose to
;	be used.)
;
;
;number of bits used for each parse table code entry for code
;
tbl_code_size = 4
;
;ascii codes
;
cr_ascii_code = 13
lt_ascii_code = ^A/</			;"<"
gt_ascii_code = ^A/>/			;">"
bs_ascii_code = ^A/\/			;"\"
; parameter list offsets
;
ap_mode		=	 4
ap_input_desc	=	 8
ap_radix	=	12
ap_no_path	=	16
ap_token_type	=	20
ap_result	=	24
ap_message_vect	=	28
;
; error level constants
;
err_lev_reg_cnt = 3			;number of registers saved per level
err_lev_pop_val = err_lev_reg_cnt*4	;value to add to stack to pop 1 level
;
;
;
; LOCAL READ-ONLY DATA
;
; parse table
;
	.psect	dbg$own,noexe,pic,long
p_table:	.blkb	256
p_table_end:
	mte	a,<m_alpha$_ ! m_a_to_f ! alpha_code>
	mte	b,<m_alpha$_ ! m_a_to_f ! alpha_code>
	mte	c,<m_alpha$_ ! m_a_to_f ! alpha_code>
	mte	d,<m_alpha$_ ! m_a_to_f ! alpha_code>
	mte	e,<m_alpha$_ ! m_a_to_f ! alpha_code>
	mte	f,<m_alpha$_ ! m_a_to_f ! alpha_code>
	mte	g,<m_alpha$_ ! alpha_code>
	mte	h,<m_alpha$_ ! alpha_code>
	mte	i,<m_alpha$_ ! alpha_code>
	mte	j,<m_alpha$_ ! alpha_code>
	mte	k,<m_alpha$_ ! alpha_code>
	mte	l,<m_alpha$_ ! alpha_code>
	mte	m,<m_alpha$_ ! alpha_code>
	mte	n,<m_alpha$_ ! alpha_code>
	mte	o,<m_alpha$_ ! alpha_code>
	mte	p,<m_alpha$_ ! alpha_code>
	mte	q,<m_alpha$_ ! alpha_code>
	mte	r,<m_alpha$_ ! alpha_code>
	mte	s,<m_alpha$_ ! alpha_code>
	mte	t,<m_alpha$_ ! alpha_code>
	mte	u,<m_alpha$_ ! alpha_code>
	mte	v,<m_alpha$_ ! alpha_code>
	mte	w,<m_alpha$_ ! alpha_code>
	mte	x,<m_alpha$_ ! alpha_code>
	mte	y,<m_alpha$_ ! alpha_code>
	mte	z,<m_alpha$_ ! alpha_code>
	mte	A,<m_alpha$_ ! m_a_to_f ! alpha_code>
	mte	B,<m_alpha$_ ! m_a_to_f ! alpha_code>
	mte	C,<m_alpha$_ ! m_a_to_f ! alpha_code>
	mte	D,<m_alpha$_ ! m_a_to_f ! alpha_code>
	mte	E,<m_alpha$_ ! m_a_to_f ! alpha_code>
	mte	F,<m_alpha$_ ! m_a_to_f ! alpha_code>
	mte	G,<m_alpha$_ ! alpha_code>
	mte	H,<m_alpha$_ ! alpha_code>
	mte	I,<m_alpha$_ ! alpha_code>
	mte	J,<m_alpha$_ ! alpha_code>
	mte	K,<m_alpha$_ ! alpha_code>
	mte	L,<m_alpha$_ ! alpha_code>
	mte	M,<m_alpha$_ ! alpha_code>
	mte	N,<m_alpha$_ ! alpha_code>
	mte	O,<m_alpha$_ ! alpha_code>
	mte	P,<m_alpha$_ ! alpha_code>
	mte	Q,<m_alpha$_ ! alpha_code>
	mte	R,<m_alpha$_ ! alpha_code>
	mte	S,<m_alpha$_ ! alpha_code>
	mte	T,<m_alpha$_ ! alpha_code>
	mte	U,<m_alpha$_ ! alpha_code>
	mte	V,<m_alpha$_ ! alpha_code>
	mte	W,<m_alpha$_ ! alpha_code>
	mte	X,<m_alpha$_ ! alpha_code>
	mte	Y,<m_alpha$_ ! alpha_code>
	mte	Z,<m_alpha$_ ! alpha_code>
	mte	1,<m_digit ! digit_code>
	mte	2,<m_digit ! digit_code>
	mte	3,<m_digit ! digit_code>
	mte	4,<m_digit ! digit_code>
	mte	5,<m_digit ! digit_code>
	mte	6,<m_digit ! digit_code>
	mte	7,<m_digit ! digit_code>
	mte	8,<m_digit ! digit_code>
	mte	9,<m_digit ! digit_code>
	mte	0,<m_digit ! digit_code>
	mte	%,<percent_code>
	mte	(,<lp_code>
	mte	),<rp_code>
	mte	<,>,<comma_code>
	mte	-,<dash_code>
	mte	/,<slash_code>
	mte	',<quote_code>
	mte	+,<pli_oper_code>
	mte	^%^%,<pli_oper_code>
	mte	^%.%,<dot_code>
	mte	^%=%,<pli_oper_code>
	mte	!,<pli_oper_code>
	mte	&,<pli_oper_code>
	mte	*,<pli_oper_code>
	mte	$,<m_alpha$_ ! alpha_code>
	mte	_,<m_alpha$_ ! alpha_code>
.=p_table+cr_ascii_code			;position in table set
	.byte	cr_code			;carriage return code
.=p_table+lt_ascii_code			;"<"
	.byte	pli_oper_code		;pli operator code
.=p_table+gt_ascii_code			;">"
	.byte	pli_oper_code		;pli operator code
.=p_table+bs_ascii_code			;"\"
	.byte	<backslash_code>	;backslash code
.=p_table_end
;
;
;make pli operator table
;
; local macro to generate table entries
	.macro	mpot char,code
.=pli_op_tab + ^a%char%
	.byte	code
	.end	mpot
pli_op_tab:	.blkb	256
pli_op_tab_end:
	mpot	+,1			;"+"
	mpot	-,2			;"-"
	mpot	*,3			;"*"
	mpot	/,4			;"/"
	mpot	!,5			;"!"
	mpot	&,6			;"&"
.=pli_op_tab+lt_ascii_code		;
	.byte	7			;"<"
.=pli_op_tab+gt_ascii_code		;
	.byte	8			;">"
	mpot	^%=%,9			;"="
	mpot	^%^%,10			;"^"
pli_last_op=10				;
.=pli_op_tab_end			;restore location counter to table end
;
;PLI operator code vector
; this vector is indexed by the codes in the pli_op_tab and
; are often the same value as the final operator code. Exceptions are
; treated in code plie_oper (this routine) and the caller of this routine.
; If choice between unary and binary operator code, code returned is unary.
; Next level up changes to binary if appropriate.
;
pli_one_char_op:
	.long	0			;error
	.long	pli_node_opr$k_binary_plus ;+
	.long	pli_node_opr$k_binary_minus ;-
	.long	pli_node_opr$k_multiply ;*
	.long	pli_node_opr$k_divide	;/
	.long	pli_node_opr$k_or	;!
	.long	pli_node_opr$k_and	;&
	.long	pli_node_opr$k_less_than;<
	.long	pli_node_opr$k_greater_than ;>
	.long	pli_node_opr$k_equal	;=
	.long	pli_node_opr$k_not	;^
	.blkl	10			;error
;
;
;
;permanent symbol list
;
perm_sym_list:				;
	.long	str_r0e - str_r0	;
	.long	str_r0-perm_sym_list	;"R0"
	.long	str_r1e - str_r1	;
	.long	str_r1-perm_sym_list	;"R1"
	.long	str_r2e - str_r2	;
	.long	str_r2-perm_sym_list	;"R2"
	.long	str_r3e - str_r3	;
	.long	str_r3-perm_sym_list	;"R3"
	.long	str_r4e - str_r4	;
	.long	str_r4-perm_sym_list	;"R4"
	.long	str_r5e - str_r5	;
	.long	str_r5-perm_sym_list	;"R5"
	.long	str_r6e - str_r6	;
	.long	str_r6-perm_sym_list	;"R6"
	.long	str_r7e - str_r7	;
	.long	str_r7-perm_sym_list	;"R7"
	.long	str_r8e - str_r8	;
	.long	str_r8-perm_sym_list	;"R8"
	.long	str_r9e - str_r9	;
	.long	str_r9-perm_sym_list	;"R9"
	.long	str_r10e - str_r10	;
	.long	str_r10-perm_sym_list	;"R10"
	.long	str_r11e - str_r11	;
	.long	str_r11-perm_sym_list	;"R11"
	.long	str_r12e - str_r12	;
	.long	str_r12-perm_sym_list	;"R12"
	.long	str_r13e - str_r13	;
	.long	str_r13-perm_sym_list	;"R13"
	.long	str_r14e - str_r14	;
	.long	str_r14-perm_sym_list	;"R14"
	.long	str_r15e - str_r15	;
	.long	str_r15-perm_sym_list	;"R15"
	.long	str_ape - str_ap	;
	.long	str_ap-perm_sym_list	;"AP"
	.long	str_fpe - str_fp	;
	.long	str_fp-perm_sym_list	;"FP"
	.long	str_spe - str_sp	;
	.long	str_sp-perm_sym_list	;"SP"
	.long	str_pce - str_pc	;
	.long	str_pc-perm_sym_list	;"PC"
	.long	str_psle - str_psl	;
	.long	str_psl-perm_sym_list	;"PSL"
	.long	0,0			;end of list marker
;
;permanent symbol string list
;
str_r0:	.ascii	/R0/			;
str_r0e:				;
str_r1:	.ascii	/R1/			;
str_r1e:				;
str_r2:	.ascii	/R2/			;
str_r2e:				;
str_r3:	.ascii	/R3/			;
str_r3e:				;
str_r4:	.ascii	/R4/			;
str_r4e:				;
str_r5:	.ascii	/R5/			;
str_r5e:				;
str_r6:	.ascii	/R6/			;
str_r6e:				;
str_r7:	.ascii	/R7/			;
str_r7e:				;
str_r8:	.ascii	/R8/			;
str_r8e:				;
str_r9:	.ascii	/R9/			;
str_r9e:				;
str_r10: .ascii	/R10/			;
str_r10e:				;
str_r11: .ascii /R11/			;
str_r11e:				;
str_r12: .ascii /R12/			;
str_r12e:				;
str_r13: .ascii /R13/			;
str_r13e:				;
str_r14: .ascii /R14/			;
str_r14e:				;
str_r15: .ascii /R15/			;
str_r15e:				;
str_ap:	.ascii	/AP/			;
str_ape:				;
str_fp:	.ascii	/FP/			;
str_fpe:				;
str_sp:	.ascii	/SP/			;
str_spe:				;
str_pc:	.ascii	/PC/			;
str_pce:				;
str_psl: .ascii	/PSL/			;
str_psle:				;
;
;string for %line keyword
;
line_tok_min = 3			;minimum length for %line lexical unit
line_tok_max = 5			;maximum length for %line lexical unit
str_line: .ascii	/%LINE/		;
;
;string for %label keyword
;
label_tok_min = 3			;minimum length for %label lexical unit
label_tok_max = 6			;maximum length for %label lexical unit
str_label: .ascii	/%LABEL/	;
;
;permanent symbol code list
;
perm_sym_code:	.long	dbg$k_r0	;
		.long	dbg$k_r1	;
		.long	dbg$k_r2	;
		.long	dbg$k_r3	;
		.long	dbg$k_r4	;
		.long	dbg$k_r5	;
		.long	dbg$k_r6	;
		.long	dbg$k_r7	;
		.long	dbg$k_r8	;
		.long	dbg$k_r9	;
		.long	dbg$k_r10	;
		.long	dbg$k_r11	;
		.long	dbg$k_ap	;
		.long	dbg$k_fp	;
		.long	dbg$k_sp	;
		.long	dbg$k_pc	;
		.long	dbg$k_ap	;
		.long	dbg$k_fp	;
		.long	dbg$k_sp	;
		.long	dbg$k_pc	;
		.long	dbg$k_psl	;
;
; local data for string to bit conversion
;

revbit:	.byte	0,1			;reversed bits for b1
	.byte	0,2,1,3			;reversed bits for b2
	.byte	0,4,2,6,1,5,3,7		;reversed bits for b3
	.byte	0,8,4,12,2,10,6,14,1,9	;reversed bits for b4
	.byte	5,13,3,11,7,15		;
;
	.psect	dbg$code,exe,nowrt,long,pic,shr
;
	.entry	pli_get_token,^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>
;
;enter at error level 0
;raise to error level 1
;
start_search:				;
	movl	ap_input_desc(ap),r11	;address of input descriptor
	movzwl	dsc$w_length(r11),r0	;length of input string
	movl	dsc$a_pointer(r11),r1	;address of input string
	pushr	#^m<r0,r1,r11>		;establish error level 1
	skpc	#^a/ /,r0,(r1)		;skip blanks
	bneq	look_for_pn		;debug pn parser has first chance at
					;finding recognizable syntax
	movl	#pli$k_input_str,r0	;all blanks, no terminating cr
	brw	bug_check		;signal error
;
;enter at error level 1
;
look_for_pn:				;
	pushr	#^m<r0,r1,r11>		;error level 1 to error level 2
					;we are now pointing to the first
					;non-blank character
;
;update string descriptor so pathname_parser doesn't have to skip initial
;blanks also
;
	movw	r0,dsc$w_length(r11)	;update length of input descriptor
	movl	r1,dsc$a_pointer(r11)	;point to first non_blank
	movq	r0,r6			;save the remaining length of string
					;and the starting address
;
;see if any pathname lookup should take place
;
	blbs	ap_no_path(ap),10$	;skip lookup if bit is set
	moval	-12(sp),sp		;reserve 3 longwords
;
;create temporary storage area:
;
;	+------------------------------+
;	!address of pathname descriptor!  SP:
;	+------------------------------+
;	!         value		       !  SP+4:
;	+------------------------------+
;	!    last token descriptor     !  SP+8:
;	+------------------------------+
;
	pushal	8(sp)			;last token descriptor
	pushal	8(sp)			;value
	pushal	8(sp)			;pathname descriptor
	pushal	pli_get_tok_prm		;address of scanner
	pushl	ap_input_desc(ap)	;input descriptor
	calls	#5,dbg$npathname_parser	;call pathname parser
	movl	(sp)+,r10		;get possible pathname descriptor
	movl	(sp)+,r1		;get possible token value
	movl	(sp)+,r2		;pointer to last token descriptor
	blbs	r0,100$			;branch if pathname found
;
;no pathname found
;(or none is legal so no lookup was made)
;
10$:	clrl	r10			;no pathname descriptor present




	movq	r6,r0			;point to first non_blank
	movzbl	(r1),r3			;get character into register
	ashl	#3,r3,r3		;convert ascii code to bit displacement
	extzv	r3,#tbl_code_size,p_table,r4 ;get type of character as a code
	mull3	@ap_mode(ap),#<last_code+1>,r5 ;mode displacement of codes
	addl2	r5,r4			;add to actual code


	caseb	r4,#0,#<last_code*2+1>	;case on 1st character's type
;
;all case branch targets are entered at error level 2
;
; mode = debug address expressions
;
20$:	.word	none		- 20$	;invalid character
	.word	alpha     	- 20$	;alpha,$,or _
	.word	dae_constant	- 20$	;digit
	.word	backslash  	- 20$	;backslash
	.word	none		- 20$	;%
	.word	null		- 20$	;carriage return
	.word	dae_dot	   	- 20$	;dot
	.word	lp	   	- 20$	;left parenthesis
	.word	rp	   	- 20$	;right parenthesis
	.word	comma	   	- 20$	;comma
	.word	dae_dash	- 20$	;dash
	.word	dae_oper	- 20$	;slash
	.word	dae_oper	- 20$	;pli operator
	.word	none		- 20$	;single quote 
;
; mode = pli expressions
;
	.word	none	   - 20$	;invalid character
	.word	alpha      - 20$	;alpha,$,or _
	.word	plie_digit - 20$	;digit
	.word	backslash  - 20$	;backslash
	.word	none	   - 20$	;%
	.word	null	   - 20$	;carriage return
	.word	plie_dot   - 20$	;dot
	.word	lp	   - 20$	;left parenthesis
	.word	rp	   - 20$	;right parenthesis
	.word	comma	   - 20$	;comma
	.word	plie_dash  - 20$	;dash
	.word	plie_slash - 20$	;slash
	.word	plie_oper  - 20$	;pli operator
	.word	plie_quote - 20$	;single quote
;#########
;pli_toktyp_err		=	0	; internal coding error
;pli_toktyp_null	=	1	; null
;pli_toktyp_name	=	2	; name
;pli_toktyp_dbgc	=	3	; debug constant (address)
;pli_toktyp_plic	=	4	; pli constant (held as a string)
;pli_toktyp_oper	=	5	; operator
;pli_toktyp_lpar	=	6	; "("
;pli_toktyp_rpar	=	7	; ")"
;pli_toktyp_ptr		=	8	; "->"
;pli_toktyp_dot		=	9	; "."
;pli_toktyp_dbgr	=	10	; debug special symbols %r0 ... %psl
;pli_toktyp_line	=	11	; %line
;pli_toktyp_label	=	12	; %label (not used)
;pli_toktyp_bs		=	13	; "\"
;pli_toktyp_comma	=	14	; ","
;pli_toktyp_none	=	15	; no token identified, line not empty
;pli_toktyp_bad		=	16	; syntax error encountered
;					; currently not used since we let the
;					; next level of parsing determine what
;					; this means
;
;
	movl	#pli$k_tbl,r0		;parse table contains illegal value
	brw	bug_check		;internal error
;
;***************************************************************************
;*                                                                         *
;*	pathname found by dbg$npathname_parser				   *
;*                                                                         *
;***************************************************************************
;
;	r11	address of input string descriptor (updated by pn_parser)
;	r10	address of pathname vector
;	r7	address of 1st char. in input string passed to pn_parser
;	r6	length of input string passed to pathname_parser
;	r2	pointer to last token descriptor
;	r1	value from dbg$npathname_parser giving pathname type
;	r0	return code from dbg$npathname_parser
;
100$:					;
	cmpl	#dbg$k_line,r1		;did pathname_parser find %line?
	bneq	110$			;branch if not %line
;
; %line processing
;
	movl	ap_result(ap),r3	;point to result vector
	movzwl	dsc$w_length(r11),r4	;length of input string after %line x
	movl	dsc$a_pointer(r11),r5	;address of input string after %line x
	subl3	r4,r6,pli_tokr$l_0(r3)	;length of token into result vector
	movl	r7,pli_tokr$l_1(r3)	;address of token
	movl	r10,pli_tokr$l_2(r3)	;pathname vector
	movl	#pli_toktyp_line,@ap_token_type(ap) ;token type is line
	movq	r4,r6			;point past token for final processing
	brw	finish			;final token processing
110$:
;
; %label processing (currently unused by pli)
;
	cmpl	#dbg$k_label,r1		;%label found?
	bneq	120$			;branch if not found
	movl	ap_result(ap),r3	;point to result vector
	movzwl	dsc$w_length(r11),r4	;length of input string after %label x
	movl	dsc$a_pointer(r11),r5	;address of input string after %label x
	subl3	r4,r6,pli_tokr$l_0(r3)	;length of token into result vector
	movl	r7,pli_tokr$l_1(r3)	;address of token
	movl	r10,pli_tokr$l_2(r3)	;pathname vector
	movl	#pli_toktyp_label,@ap_token_type(ap) ;token type is label
	movq	r4,r6			;point past token for final processing
	brw	finish			;final token processing
120$:					;
;
; %r0, %r1, ... , %psl
;
	cmpl	#dbg$k_reg,r1		;pathname_parser found register?
	bneq	200$			;branch if not a register
	movq	r6,r0			;copy length and pointer to "%"
	brw	percent			;go process debug register
200$:	cmpl	#dbg$k_pn,r1		;is it a pathname (i.e. a name)
	beql	500$			;branch to get name
	movl	#pli$k_pn_parser,r0	;bad code from pathname parser
	brw	bug_check		;go signal the error
;
;***************************************************************************
;*									   *
;*      alphabetic $  or _     with pathname				   *
;*									   *
;***************************************************************************
;
; enter at error level 2 (1st non_blank character)
;
500$:					;
	movl	ap_result(ap),r3	;point to result vector
	movzwl	dsc$w_length(r2),pli_tokr$l_0(r3) ;number of bytes in string
	movl	dsc$a_pointer(r2),pli_tokr$l_1(r3) ;address of first char.
					;in string
	movl	r10,pli_tokr$l_2(r3)	;address of pathname vector
	movw	dsc$w_length(r11),r6	;new length of the rest of string
	movl	dsc$a_pointer(r11),r7	;start of the rest of the string
	movl	#pli_toktyp_name,@ap_token_type(ap) ;token type is name
	brw	finish			;final processing
;
;***************************************************************************
;*                                                                         *
;*	none								   *
;*                                                                         *
;***************************************************************************
;
; assumes r6 = length of the rest of the line (including CR)
;	  r7 = address of character that does not start a token
;	NO pathname present.
;	error level is irrelevant
;
none:	movl	#pli_toktyp_none,@ap_token_type(ap) ;no token recognized
	movl	ap_result(ap),r3	;point to result vector
	movl	r6,pli_tokr$l_0(r3)	;number of bytes in string
	decl	pli_tokr$l_0(r3)	;don't include cr at end of string
	movl	r7,pli_tokr$l_1(r3)	;address of first char. in string
	brw	ok_exit			;successful return
;
;***************************************************************************
;*                                                                         *
;*   alphabetic   $    or _          no pathname                           *
;*                                                                         *
;***************************************************************************
;
;upon entering this code, we assume:
;	r0 = r6 = length of the remaining string (including cr)
;	r1 = r7 = address of the remaining string
;	r8	= descriptor length restoration value. Used in case
;		it is necessary to assume the max_id length in scanning
;		for an identifier. It holds the difference between the
;		actual length of the string and the assumed scan length.
;		Usually the value is 0, the case when the rest of the
;		string is less than pli$k_max_id.
;	r11     = address of input string descriptor
;	r10	= valid pathname descriptor or 0 if none
;enter at error level 2
;
alpha:
	movl	#pli_toktyp_name,@ap_token_type(ap) ;token type of name
	clrl	r8			;default descriptor length restoration
	cmpl	r0,#pli$k_max_id	;more than 31 characters?
	bleq	50$			;branch if not more than 31 characters
	movl	#pli$k_max_id,r0	;if more than 31, we look at only 31
	subl3	r0,r6,r8		;desc. restoration length
	movl	r0,r6			;maximum length
50$:	moval	p_table,r3		;save p_table address to restart spanc
60$:	spanc	r0,(r1),(r3),#<m_alpha$_ ! m_digit> ;span alphanumerics,$,_
	cmpb	#^a/%/,(r1)		;scan terminated by %? (special case
					;for begin%xx (wanted to save that one
					;extra bit in p_table ))
	bneq	70$			;branch if no terminal "%"
	incl	r1			;skip past "%"
	decl	r0			;decrease count of remaining characters
	brb	60$			;continue scan
70$:	subl2	r0,r6			;length of identifier
	movl	ap_result(ap),r2	;point to result longword vector
	movq	r6,(r2)			;length and address of name token
	clrl	pli_tokr$l_2(r2)	;no pathname vector
	movq	r0,r6			;finish up starts looking here
	addl2	r8,r6			;fix up length in case max_id used
	brw	finish			;final processing of this part of input
;
;
;***************************************************************************
;*                                                                         *
;*  digit encountered                                                      *
;*	mode = debug address expression					   *
;*	no pathname present						   *
;*                                                                         *
;***************************************************************************
;
;register values on input:
;	r0 = r6 = length of remaining string
;	r1 = r7 = address of remaining string
;	r11     = address of input string descriptor
;
;register use within this code section:
;	r10	= number of digits
;	r9	= radix
;	r8	= holds individual ascii digits
;
;
;enter  digit:  at error level 2
;
dae_constant:				;
	spanc	r0,(r1),p_table,#<m_digit ! m_a_to_f> ;find first non-digit
	pushr	#^m<r0,r1,r11>		;push to error level 3
	subl3	r0,r6,r10		;number of digits
	movl	ap_result(ap),r2	;point to result
	movl	r10,pli_tokr$l_0(r2)	;length of digit string into result vec
	movl	r7,pli_tokr$l_1(r2)	;address of the digit string
	movzbl	@ap_radix(ap),r9	;radix code
	cmpl	#dbg$k_default,r9	;default radix code?
	bneq	10$			;branch if default not used
	movl	#pli$k_def_radix,r9	;use default radix
10$:	clrq	r2			;will hold value of digits
	movb	(r7)+,r8		;get 1st char. (clear high bits later)
	bicl	#^c<^x4f>,r8		;clear all but low nibble and ^X40
	cmpb	r8,#^x40		;is it a hex digit?
	blss	20$			;branch if not hex digit
	addl2	#<9-^x40>,r8		;cancel bit 7, convert ascii to binary
20$:	cmpl	r8,r9			;valid digit for given radix?
	bgeq	no_number		;branch if not legal
	movl	r8,r2			;hold the value of the first digit
	brb	50$			;first char. ok, continue processing
30$:	movb	(r7)+,r8		;get next char. (clear high bits later)
	bicl	#^c<^x4f>,r8		;clear all but low nibble and ^X40
	cmpb	r8,#^x40		;is it a hex digit?
	blss	40$			;branch if not hex digit
	addl2	#<9-^x40>,r8		;cancel bit 7, convert ascii to binary
40$:	cmpl	r8,r9			;valid digit for given radix?
	bgeq	bad_number		;branch if not legal
	emul	r9,r2,r8,r2		;calculate the value so far
	tstl	r3			;overflow of unsigned longword?
	bneq	bad_number		;branch if overflow
50$:	sobgtr	r10,30$			;count the digits previously spanned
	popr	#^m<r6,r7,r11>		;point past scanned characters
	movl	#pli_toktyp_dbgc,@ap_token_type(ap) ;debug constant code
	movl	ap_result(ap),r3	;point to result vector
	movl	r2,pli_tokr$l_2(r3)	;binary value of token
	clrl	pli_tokr$l_3(r3)	;literal radix over_ride (unused)
	brw	finish			;final token processing
;
; no_number - entered if first character is not a legal number for
; the given radix. e.g.  examine/octal 8
;
no_number:				;
;
;enter  bad_number:  at error level 3
;enter  bad_number2: at error level 2
; the scan was terminated prematurely by finding a digit that was
; improper for the given radix, e.g. examine/decimal 123a
; r2 holds the value of the token as an unsigned binary (possibly truncated)
;    32 bit number.
; r7 points one character beyond the bad character
; r10 is length of unprocessed characters of digit string plus the bad
; digit that caused branch to bad_number:
;
bad_number:				;
	moval	err_lev_pop_val(sp),sp	;level 3 to level 2
bad_number2:				;enter at error level 2
	movl	#pli_toktyp_bad,@ap_token_type(ap) ;bad token token type
	popr	#^m<r0,r1,r11>		;level 2 to level 1
	subl2	r1,r7			;length of digit str. (including
					;the bad character)
	movl	r7,@ap_result(ap)	;make this result token length
	pushl	r1			;address of bad token
	pushl	r7			;length of bad token
	movq	r0,r6			;save start and length of bad string
	pushl	#2			;2 fao arguments
	pushl	#dbg$_ildigit		;"terminated by illegal digit"
	calls	#4,dbg$nmake_arg_vect	;make the message vector
	movl	ap_result(ap),r2	;point to result vector
	movl	r0,pli_tokr$l_2(r2)	;move in message vector address
	popr	#^m<r6,r7,r11>		;point to start of bad token
	brw	ok_exit			;ok exit return
;
;***************************************************************************
;*                                                                         *
;*  backslash                                                              *
;*                                                                         *
;***************************************************************************
;
; r0 = r6 = length of remaining string (including backslash)
; r1 = r7 = address of backslash
; r11 = address of input string descriptor
; error level is irrelevant
;
backslash:				;
	movl	#1,r0			;string is 1 character long
	movq	r0,@ap_result(ap)	;result points to backslash
	movl	#pli_toktyp_bs,@ap_token_type(ap) ;token code for backslash
	incl	r7			;skip over backslash
	decl	r6			;don't count backslash
	brw	finish			;finish up exit processing
;
;***************************************************************************
;*                                                                         *
;*   percent                                                               *
;*                                                                         *
;***************************************************************************
;
; % encountered is a result of pathname_parser indicating a possible permanent
; symbol. It is not the result of encountering %line. That case is taken
; care of by the pathname parser.
;
; upon entering this code, we assume
; r0 = r6 = length of the remaining string (including %)
; r1 = r7 = address of the remaining string
; r8	= descriptor length restoration value. Used in case
;	it is necessary to assume the max_id length in scanning
;	for an identifier. It holds the difference between the
;	actual length of the string and the assumed scan length.
;	Usually the value is 0, the case when the rest of the
;	string is less than pli$k_max_id.
; r10 = address of a valid pathname descriptor (or zero if there is none)
; r11 = address of input string descriptor
;
;enter at error level 2 (first non_blank)
;
percent:				;
	decl	r0			;skip
	incl	r1			;over
	movq	r0,r6			;the %
	clrl	r8			;default desc. restore value
	cmpl	r0,#<pli$k_max_id-1>	;maximum identifier length
	bleq	10$			;branch if not over maximum
	movl	#<pli$k_max_id-1>,r0	;we'll only look at the first 31
	subl3	r0,r6,r8		;desc. restore value if max_id used
	movl	r0,r6			;maximum length
10$:					;
	spanc	r0,(r1),p_table,#<m_alpha$_!m_digit> ;skip alphanumerics
	addl2	r8,r0			;desc. restore value if max_id used
	addl2	r8,r6			;desc. restore value if max_id used
	pushr	#^m<r0,r1,r11>		;push to error level 3
	subl2	r0,r6			;length of identifier
	bneq	60$			;branch if not lone %
;
;encountered a lone %
;
30$:	movl	#pli$k_pn_parser,r0	;pathname parser was supposed to
					;return with dbg$k_reg only if valid
					;register name was present
	brw	bug_check		;go signal error
;
;permanent symbol check: %r0,%r1,%r2, ..., %pc,%psl
;
60$:					;
	movab	perm_sym_list,r9	;point to permanent symbol list
	movl	r9,r8			;save start of the list
	brb	70$			;go get length and address of test
;
;register usage for the following code
;	r9	start of symbol list
;	r8	pointer into index list
;	r7	address of identifier
;	r6	length of identifier
;	r5	address of string
;	r4	length of test
; check for permanent symbols
;enter (70$) at error level 3 (pointing past identifying string)
;
65$:	cmpl	r4,r6			;length test = length identifier
	bneq	70$			;branch if not the same length
	cmpc3	r6,(r7),(r5)		;are the strings the same?
	beql	80$			;branch if equal
70$:	movl	(r8)+,r4		;get length
	beql	30$			;branch if no more
	movl	(r8)+,r5		;address of name
	addl2	r9,r5			;relocate name
	brb	65$			;
;
;permanent symbol
;
80$:
	movl	#pli_toktyp_dbgr,@ap_token_type(ap) ;debug register token type
	subl2	r9,r8			;displacement to name
	ashl	#-3,r8,r8		;number of names skipped
	movab	perm_sym_code - 4,r9	;permanent symbol code list base
	movl	ap_result(ap),r3	;point to result vector
	movq	r6,(r3)			;len. and addr. of symbol
	movl	(r9)[r8],pli_tokr$l_2(r3) ;permanent symbol register code
	movl	r10,pli_tokr$l_3(r3)	;pathname vector (or 0 if none)
	popr	#^m<r6,r7,r11>		;restore pointers past token
	brw	finish
;
;***************************************************************************
;*                                                                         *
;*	null		(input line is empty)				   *
;*                                                                         *
;***************************************************************************
;
null:	movl	#pli_toktyp_null,@ap_token_type(ap) ;token type is null
	movq	r6,@ap_result(ap)	;point to the cr
	clrq	r6			;setup to zero input descriptor
	brw	ok_exit			;
;
;***************************************************************************
;*                                                                         *
;*    mode = debug address expression					   *
;*    dot is first character						   *
;*                                                                         *
;***************************************************************************
;
; r0 = r6 = length of remaining string (including dot)
; r1 = r7 = address of dot
; r11 = address of input string descriptor
; error level is irrelevant
;
;
dae_dot: 				;
	movl	#1,r0			;string is 1 character long
	movq	r0,@ap_result(ap)	;result points to dot
	movl	#pli_toktyp_dot,@ap_token_type(ap) ;token type is dot
	decl	r6			;remaining length of input string
	incl	r7			;address of first byte in remaining
	brw	finish			;string. Go finish up processing
;
;***************************************************************************
;*                                                                         *
;*    dae_dash								   *
;*                                                                         *
;***************************************************************************
;
; r0 = r6 = length of remaining string (including operator)
; r1 = r7 = address of operator
; r11 = address of input string descriptor
; error level is irrelevant
dae_dash:				;
	cmpb	#^a/>/,1(r1)		;is it a pointer?
	bneq	dae_oper		;if not, treat as ordinary operator
common_ptr:				;pointer code common to dae and plie
	movl	#2,r0			;string is 2 characters long
	movq	r0,@ap_result(ap)	;result points to operator
	movl	#pli_toktyp_ptr,@ap_token_type(ap) ;token type oper
	subl2	#2,r6			;remaining length of input string
	addl2	#2,r7			;address of first byte in remaining
	brw	finish			;
;
;***************************************************************************
;*                                                                         *
;*    dae_oper								   *
;*                                                                         *
;***************************************************************************
;
; r0 = r6 = length of remaining string (including operator)
; r1 = r7 = address of operator
; r11 = address of input string descriptor
; error level is irrelevant
;
; since we don't really handle debug address expression operators, we
; could also have returned token type none. This is the way we would
; do it if we ever did handle some of the debug address expression operators.
; The caller of this routine knows that we don't handle d.a.e. operators and
; returns warning to the debug address interpreter.
;
dae_oper:					;
	movl	#1,r0			;string is 1 character long
	movq	r0,@ap_result(ap)	;result points to operator
	movl	#pli_toktyp_oper,@ap_token_type(ap) ;token type oper
	decl	r6			;remaining length of input string
	incl	r7			;address of first byte in remaining
	brw	finish			;
;
;***************************************************************************
;*                                                                         *
;*    left parenthesis							   *
;*                                                                         *
;***************************************************************************
;
; r0 = r6 = length of remaining string (including parenthesis)
; r1 = r7 = address of parenthesis
; r11 = address of input string descriptor
; error level is irrelevant
;
;
lp:					;
	movl	#1,r0			;string is 1 character long
	movq	r0,@ap_result(ap)	;result points to left parenthesis
	movl	#pli_toktyp_lpar,@ap_token_type(ap) ;token type left
					;parenthesis
	decl	r6			;remaining length of input string
	incl	r7			;address of first byte in remaining
	brw	finish			;
;
;***************************************************************************
;*                                                                         *
;*    right parenthesis							   *
;*                                                                         *
;***************************************************************************
;
; r0 = r6 = length of remaining string (including parenthesis)
; r1 = r7 = address of parenthesis
; r11 = address of input string descriptor
; error level is irrelevant
;
;
rp:					;
	movl	#1,r0			;string is 1 character long
	movq	r0,@ap_result(ap)	;result points to right parenthesis
	movl	#pli_toktyp_rpar,@ap_token_type(ap) ;token type right
					;parenthesis
	decl	r6			;remaining length of input string
	incl	r7			;address of first byte in remaining
	brw	finish			;
;
;***************************************************************************
;*                                                                         *
;*    comma								   *
;*                                                                         *
;***************************************************************************
;
; r0 = r6 = length of remaining string (including comma)
; r1 = r7 = address of comma
; r11 = address of input string descriptor
; error level is irrelevant
;
;
comma:					;
	movl	#1,r0			;string is 1 character long
	movq	r0,@ap_result(ap)	;result points to comma
	movl	#pli_toktyp_comma,@ap_token_type(ap) ;token type comma
	decl	r6			;remaining length of input string
	incl	r7			;address of first byte in remaining
	brw	finish			;
;
;***************************************************************************
;*                                                                         *
;*    plie_digit	digit encountered				   *
;*                      mode = pli expression				   *
;*                                                                         *
;***************************************************************************
;
; r0 = r6 = length of remaining string (including first digit)
; r1 = r7 = address of first digit
; r11 = address of input string descriptor
;
; register 	use
;
;   r10		number of digits before "."
;   r9		number of digits after "."
;	(so precision = (r9) + (r10), scale = (r9) if fixed decimal)
;
; enter at error level 2 - (points to first digit)
;
	.enable	local_block		;will include plie_dot
plie_digit:				;
	clrl	r9			;initialize scale counter
	movl	r0,r10			;copy string length
	spanc	r0,(r1),p_table,#<m_digit> ;skip initial digits
	subl2	r0,r10			;length of initial string of digits
	cmpb	(r1),#^a/./		;is the next character "." ?
	beql	80$			;branch if there is a trailing dot
	cmpb	(r1),#^a/E/		;exponent specification?
	beql	50$			;branch if so
	cmpb	(r1),#^A/e/		;lower case exponent specification
	beql	50$			;branch if so
;
;constant is a string consisting of only digits
;
	cmpl	r10,#pli$k_fixed_dec_max;is the length too large for conversion
	bleq	40$			;branch if ok
	movq	r0,r2			;save r0,r1
	pushl	#0			;no fao arguments
	pushl	#dbg$_numtrunc		;number truncation message
	calls	#2,dbg$nout_info	;give informational message
	movq	r2,r0			;restore r0,r1
	movl	#pli$k_fixed_dec_max,r10 ;truncate
40$:	movl	ap_result(ap),r3	;point to result vector
	movl	r10,pli_tokr$l_0(r3)	;length of token
	movl	r7,pli_tokr$l_1(r3)	;address of token
	movl	#char_,pli_tokr$l_2(r3)	;pli data type (primary)
	movl	r10,pli_tokr$l_3(r3)	;size of pli data (primary)
	movl	#fixed_dec_,pli_tokr$l_4(r3) ;pli data type (secondary)
	movl	r10,pli_tokr$l_5(r3)	;size of data (secondary)
	movl	#pli_toktyp_plic,@ap_token_type(ap) ;token type - pli constant
	movq	r0,r6			;point past digit string
	brw	finish			;final processing
;
;E encountered immediately after digit string (no dot)
;
50$:	pushr	#^m<r0,r1,r11>		;push to error level 3 (if the exponent
					;is in error, this is the first char.
					;after the legal token
	brb	140$			;go look for the rest of the exponent
;
;dot encountered
; r0 = length of remaining string including the "."
; r1 = address of "."
; r10 = number of digits up to the "."
; r9 = 0 (to hold number of digits after the dot)
;
80$:	decl	r0			;length not to include "."
	incl	r1			;skip "."
	pushr	#^m<r0,r1,r11>		;push to error level 3 (if there are
					;no digits after the "." or if the
					;exponent is found to be in error, at
					;LEAST the preceding is returned as a
					;valid token.
	movl	r0,r9			;copy length of the rest of the string
	spanc	r0,(r1),p_table,#<m_digit> ;skip any digits after the "."
	subl2	r0,r9			;number of digits skipped
	beql	100$			;branch if none found
	moval	err_lev_pop_val(sp),sp	;pop to error level 2. Make new error
	pushr	#^m<r0,r1,r11>		;level so we know this much is ok
100$:	cmpb	(r1),#^A/E/		;look for exponent specification
	beql	140$			;branch if there is an exponent spec.
	cmpb	(r1),#^A/e/		;look for lower case exponent spec.
	beql	140$			;branch if there is an exponent spec.
;
;character after (optional) initial digit string, ".", and (optional) following
;digits is not E so we must have a fixed decimal string
;
	movl	ap_result(ap),r3	;point to result vector
	popr	#^m<r6,r7,r11>		;pointers to 1st char. after "."
	popr	#^m<r0,r1,r11>		;pointer to 1st char. of token
120$:					;common fixed decimal result processing
	addl	r9,r10			;precision = total number of digits
	ashl	#8,r9,r9		;shift scale to second byte
	addl	r9,r10			;precision and scale encoding
	subl2	r6,r0			;length of token
	movl	ap_result(ap),r3	;point to result vector
	movq	r0,pli_tokr$l_0(r3)	;length and address of token
	movl	#char_,pli_tokr$l_2(r3)	;pli data type (primary)
	movl	r0,pli_tokr$l_3(r3)	;size of data (primary)
	movl	#fixed_dec_,pli_tokr$l_4(r3) ;pli data type (secondary)
	movl	r10,pli_tokr$l_5(r3)	;size of data (secondary)
	movl	#pli_toktyp_plic,@ap_token_type(ap) ;token type code - pli
					;constant
	brw	finish			;final processing
;
;E was found. Thus we have a float decimal with precision = (r10) + (r9)
;if the exponent specification is legal.
;
;	r0	length of remaining string from "E" on
;	r1	points to the "E"
;	r9	the number of digits immediately following the "."
;	r10	number of digits before the (optionally present) "."
;
140$:					;
	incl	r1			;skip the "E"
	decl	r0			;don't count the "E" in the length
	cmpb	(r1),#^A/+/		;exponent sign present?
	beql	160$			;branch if so
	cmpb	(r1),#^A/-/		;exponent sign of minus present?
	bneq	180$			;branch if sign present
160$:	incl	r1			;skip exponent sign
	decl	r0			;don't count exponent in length
180$:	movl	r0,r4			;copy length of remaining string
	spanc	r0,(r1),p_table,#<m_digit> ;skip exponent digits
	cmpl	r0,r4			;any exponent digits?
	beql	200$			;branch if there are no exponent digits
					;(this is an error so the token was
					;the string up to but not including the
					;"E")
	movq	r0,r6			;point past the token
	moval	err_lev_pop_val(sp),sp	;pop off pointer to "E"
	popr	#^M<r0,r1,r11>		;point to start of token
	addl2	r9,r10			;precision = all digits except exponent
	subl2	r6,r0			;length of token
	movl	ap_result(ap),r3	;point to result vector
	movq	r0,pli_tokr$l_0(r3)	;length and address of token
	movl	#char_,pli_tokr$l_2(r3)	;pli data type (primary)
	movl	r0,pli_tokr$l_3(r3)	;size of data (primary)
	movl	#float_dec_,pli_tokr$l_4(r3) ;pli data type (secondary)
	movl	r10,pli_tokr$l_5(r3)	;size of data (secondary)
	movl	#pli_toktyp_plic,@ap_token_type(ap) ;token type code - pli
					;constant
	brw	finish			;final processing
;
;no exponent digits so error, char. before the "E" was the last good character
;
200$:	popr	#^m<r6,r7,r11>		;level 3 to lev. 2 - point to E
	popr	#^m<r0,r1,r11>		;level 2 to lev. 1 - initial digits
	brw	120$			;common fixed decimal processing
;
;***************************************************************************
;*                                                                         *
;*    plie_dot								   *
;*                                                                         *
;***************************************************************************
;
; r0 = r6 = length of remaining string (including dot)
; r1 = r7 = address of dot
; r11 = address of input string descriptor
;
; enter at error level 2
;
plie_dot:				;
	incl	r1			;skip dot
	decl	r0			;don't count dot in length
	clrl	r10			;no digits before dot
	movl	r0,r9			;copy length remaining string
	spanc	r0,(r1),p_table,#<m_digit> ;skip any digits
	subl2	r0,r9			;number of digits skipped
	beql	1000$			;branch if no digits
	pushr	#^m<r0,r1,r11>		;push to error level 3, if error
					;in processing exponent, this is
					;just past the last char. of the legal
					;token
	brw	100$			;merge with plie_digit code
;
;token is just a dot
;
1000$:					;
	movq	r0,r6			;point past token
	popr	#^m<r0,r1,r11>		;get pointer to start of token
	movl	#1,r0			;token is a single character
	movq	r0,@ap_result(ap)	;length and address of dot
	movl	#pli_toktyp_dot,@ap_token_type(ap) ;token type is dot
	brw	finish			;final token processing
	.disable local_block		;
;
;***************************************************************************
;*                                                                         *
;*    plie_dash								   *
;*                                                                         *
;***************************************************************************
;
; r0 = r6 = length of remaining string (including dash)
; r1 = r7 = address of dash
; r11 = address of input string descriptor
;
; enter at error level 2
;
plie_dash:				;
	cmpb	#^a/>/,1(r1)		;is it a pointer
	bneq	10$			;if not branch
	brw	common_ptr		;goto common pointer operator code
10$:	brw	plie_oper		;no, so - is an operator
;
;***************************************************************************
;*                                                                         *
;*    plie_slash							   *
;*                                                                         *
;***************************************************************************
;
; r0 = r6 = length of remaining string (including slash)
; r1 = r7 = address of slash
; r11 = address of input string descriptor
;
; enter at error level 2
;
plie_slash:				;
;
;check to see if we have a pli comment statement
;
	addl3	#1,r1,r3		;point past "/"
	cmpb	(r3)+,#^A/*/		;is the next character "*" ?
	beql	10$			;branch if it is "*"
	brw	plie_oper		;must really be an operator
10$:					;start of a comment at least
	subl3	#2,r0,r2		;characters left in input string
20$:	cmpb	(r3)+,#^A/*/		;start of comment close characters?
	beql	40$			;branch if possible start of close
30$:	sobgtr	r2,20$			;look at all the remaining characters
					;didn't find any close, first chars.
					;are the start of an unknown token type
	brw	none			;go report no token found
40$:	cmpb	(r3),#^AX/X		;is it a legal close?
	bneq	30$			;branch if not really a close of
					;comment
;
;it was a completely legal comment
;
	incl	r3			;point past comment
	subl2	#2,r2			;don't include comment in count
	movw	r2,dsc$w_length(r11)	;length of input updated
	movl	r3,dsc$a_pointer(r11)	;address of new first character
	moval	<2*err_lev_pop_val>(sp),sp ;level 2 to level 0
	brw	start_search		;start all over again looking for a
					;token
;
;***************************************************************************
;*                                                                         *
;*    plie_oper								   *
;*                                                                         *
;***************************************************************************
;
;
; r0 = r6 = length of remaining string (including operator)
; r1 = r7 = address of operator
; r11 = address of input string descriptor
;
; enter at error level 2
;
;pli operators consist of:
;	+ - ^				(prefix operators)
;	> >= = < <= ^> ^= ^<		(comparison)
;	+ - * / **			(infix operators)
;	->				(pointer)
;	!!				(concatenation)
;	!  &				(logical)
;
;
plie_oper:				;
	movzbl	(r1),r4			;get first character of operator
	movzbl	pli_op_tab[r4],r3	;operator case and index code
	caseb	r3,#0,#10		;case on the operator code
10$:	.word	bug_check	- 10$	;pli_op_tab inconsistent with p_table
	.word	30$		- 10$	; +
	.word	30$		- 10$	; -      ("->" checked at plie_dash)
	.word	40$		- 10$	; *
	.word	30$		- 10$	; /      ("/*" checked at plie_slash)
	.word	50$		- 10$	; !
	.word	30$		- 10$	; &
	.word	70$		- 10$	; <
	.word	80$		- 10$	; >
	.word	30$		- 10$	; =
	.word	90$		- 10$	; ^
20$:	movl	#pli$k_tbl,r0		;table in conconsistant state
	brw	bug_check		;go signal error
;
; r3 has index into operator code vector, operator is only 1 character long
;
30$:	movl	#1,r0			;length of token
	movl	ap_result(ap),r4	;address of result vector
	movq	r0,pli_tokr$l_0(r4)	;length and address of token
	movl	pli_one_char_op[r3],pli_tokr$l_2(r4) ;operator code
	incl	r7			;point past operator
	decl	r6			;don't count operator in length
	movl	#pli_toktyp_oper,@ap_token_type(ap) ;token type is operator
	brw	finish			;final exit processing
;
; *
;
40$:	cmpb	1(r1),#^A/*/		;do we have "**" ?
	bneq	30$			;branch if not, process as one operator
	movl	ap_result(ap),r4	;point to result vector
	movl	#pli_node_opr$k_exponentiation,pli_tokr$l_2(r4) ;operator code
					; for "**"
	brb	60$			;common processing for 2 character oper
;
; !
;
50$:					;
	cmpb	1(r1),#^A/!/		;do we have "!!" ?
	bneq	30$			;branch if not, process as one operator
	movl	ap_result(ap),r4	;point to result vector
	movl	#pli_node_opr$k_concatenate,pli_tokr$l_2(r4) ;operator code
					;for "!!"
60$:	movl	#2,r0			;operator is 2 bytes long
	movq	r0,pli_tokr$l_0(r4)	;length and address of token
	addl2	#2,r7			;point past operator
	subl2	#2,r6			;don't count operator in length count
	movl	#pli_toktyp_oper,@ap_token_type(ap) ;type of token is operator
	brw	finish			;final exit processing
;
; <
;
70$:					;
	cmpb	1(r1),#^A/=/		;do we have "<=" ?
	bneq	30$			;branch if not, process as one operator
75$:	movl	ap_result(ap),r4	;point to result vector
	movl	#pli_node_opr$k_less_or_equal,pli_tokr$l_2(r4) ;operator code
					;for "<="
	brb	60$			;common processing for 2 character oper
;
; >
;
80$:					;
	cmpb	1(r1),#^A/=/		;do we have ">=" ?
	bneq	30$			;branch if not, process as one operator
85$:	movl	ap_result(ap),r4	;point to result vector
	movl	#pli_node_opr$k_greater_or_equal,pli_tokr$l_2(r4) ;operator
					;code for ">="
	brb	60$			;common processing for 2 character oper

;
; ^
;
90$:					;
	movzbl	1(r1),r5		;get second character of operator
	movzbl	pli_op_tab[r5],r2	;operator case and index code
	caseb	(r2),#0,#10		;case on the operator code
100$:	.word	30$		- 100$	; any other character
	.word	30$		- 100$	; +
	.word	30$		- 100$	; -
	.word	30$		- 100$	; *
	.word	30$		- 100$	; /
	.word	30$		- 100$	; !
	.word	30$		- 100$	; &
	.word	85$		- 100$	; <
	.word	75$		- 100$	; >
	.word	110$		- 100$	; =
	.word	30$		- 100$	; ^
	movl	#pli$k_tbl,r0		;unaccounted for code
	brw	bug_check		;go signal error
;
; ^=
;
110$:					;
	movl	ap_result(ap),r4	;point to result vector
	movl	#pli_node_opr$k_not_equal,pli_tokr$l_2(r4) ;operator code for
					;not equal
	brb	60$			;common processing for 2 character
					; oper	
;
;***************************************************************************
;*                                                                         *
;*    plie_quote							   *
;*                                                                         *
;***************************************************************************
;
;
; r0 = r6 = length of remaining string (including quote)
; r1 = r7 = address of quote
; r11 = address of input string descriptor
;
; enter at error level 2
;
; register	use
;	r4	target pointer
;	r5	index source token
;	r6	input descriptor update length
;	r7	input descriptor update address
;	r8	length of old token
;	r9	start of old token
;	r10	pointer to result vector
;
plie_quote:				;
	movq	r0,r8			;copy pointer and length of string
	movl	ap_result(ap),r10	;point to result vector
5$:	incl	r1			;point past "'"
	decl	r0			;don't count first "'"
10$:	cmpb	(r1)+,#^A/'/		;possible closing quote?	
	beql	30$			;branch if we found one
20$:	sobgtr	r0,10$			;look through all characters
	brw	none			;wasn't really a quoted string
30$:	decl	r0			;synchronize remaining length
	cmpb	(r1),#^A/'/		;is the following also a quote?
	beql	5$			;if so, just a representation for quote
	cmpb	(r1),#^A/B/		;is it a bit string?
	beql	150$			;branch if a bit string
	cmpb	(r1),#^A/b/		;is it a bit string with lower case b?
	beql	150$			;branch if a bit string
;
;we copy the string to free storage, deleting enclosing quotes and
;converting double quotes to single quotes
;
	movq	r0,r6			;input descriptor update values
	subl2	r0,r8			;length of string with 2 quotes
	subl2	#2,r8			;length of string, no enclosing quotes
	beql	140$			;branch if null string
	addl3	#1,r9,r5		;one beyond initial quote mark
	pushl	ap_message_vect(ap)	;pass along message vector
	pushal	pli_tokr$l_1(r10)	;free storage will hold new "token"
	addl3	#3,r8,r0		;round up factor added to byte count
	ashl	#-2,r0,-(sp)		;longwords of storage needed
	calls	#3,dbg$nlist_freez	;get listed storage
	blbs	r0,100$			;branch if ok
	ret				;
100$:	movl	pli_tokr$l_1(r10),r4	;point to free storage
110$:	movb	(r5)+,(r4)+		;copy characters
	cmpb	#^a/'/,(r5)		;is next character a quote
	bneq	120$			;branch if not a quote
	incl	r5			;skip in source
	decl	r8			;decrease source counter
120$:	sobgtr	r8,110$			;do all the source characters
	subl2	r9,r5			;length of new string + 2
	subl2	#2,r5			;length of new string (no quotes)
130$:	movl	r5,pli_tokr$l_0(r10)	;length of string (no enclosing quotes)
	movl	#char_,pli_tokr$l_2(r10)	;data type of token
	movl	r5,pli_tokr$l_3(r10)	;number of bytes in string currently

	movl	#char_,pli_tokr$l_4(r10)	;data type (secondary)
	movl	r5,pli_tokr$l_5(r10)	;size of token (secondary)
	movl	#pli_toktyp_plic,@ap_token_type(ap) ;pli constant is token type
	brw	finish			;final token processing
140$:					;null string encountered
	clrl	pli_tokr$l_1(r10)	;zero out address word of token
	clrl	r5			;length of token (no quotes)
	brb	130$			;common processing for the rest of it
;
;bit string processing
;
150$:					;
	subl2	r0,r8			;number of characters + quotes
	subl2	#2,r8			;number of characters, no quotes
	decl	r0			;don't count "'B" in count
	incl	r1			;point to first char. after "B"
	movl	#1,r5			;default bits per input character
	cmpb	(r1),#^A/1/		;radix = 2 ?
	beql	1100$			;branch if radix is 2
	cmpb	(r1),#^A/2/		;radix = 4 ?
	beql	170$			;branch if radix is 4
	cmpb	(r1),#^A/3/		;radix = 8 ?
	beql	180$			;branch if radix is 8
	cmpb	(r1),#^A/4/		;radix = 16 ?
	beql	190$			;branch if radix is 16
	brb	1110$			;
;
;
170$:	movl	#2,r5			;radix is 4
	brb	1100$			;merge with common code
180$:	movl	#3,r5			;radix is 8
	brb	1100$			;merge with common code
190$:	movl	#4,r5			;radix is 16
1100$:	incl	r1			;point past radix digit
	decl	r0			;don't count radix digit in count
;
;	register	use
;	r0		number of bits per char
;	r1		address of source characters
;	r2		number of bytes in target
;	r3		number of bytes in source
;	r4		2**(r0-1)-1 max valid integer source digit
;	r5		current char
;	r6		offset into source
;	r7		temp
;	r8		# of characters between quotes
;	r9		start of token, points to first quote
;	r10		points to result vector


1110$:					;
	movq	r0,-(sp)		;save descriptor update values
	movl	r5,r0			;bits per input character
	addl3	#1,r9,r1		;point to first input character
	movl	r8,r3			;length of input field
;
	mull3	r0,r3,r2		;get number of bits required
	addl	#7,r2			;round up
	ashl	#-3,r2,r2		;get number of bytes to allocate
	addl3	#3,r2,r7		;add round factor
	pushl	#0			;temp for free storage pointer
	pushl	ap_message_vect(ap)	;pass along message vector
	pushal	4(sp)			;pointer to free storage
	ashl	#-2,r7,-(sp)		;number of longwords needed
	calls	#3,dbg$nlist_freez	;get the storage
	blbs	r0,1200$		;branch if got storage
	ret				;
1200$:	movl	r5,r0			;bits per input character
	addl3	#1,r9,r1		;point to first input character
	movl	(sp)+,r7		;point to target storage
	clrb	-1(r7)[r2]		;clear last byte
	ashl	r0,#1,r4		;get the max bit value
	decl	r4			;
	clrl	r6			;start at bit offset 0
	brb	1280$			;enter loop
1240$:	movzbl	(r1)+,r5		;pick up next char 
	subb	#^x30,r5		;find bit equiv
	bgeq	1260$			;if geq then continue


1250$:	movl	r1,r7			;pointer past bad character
	addl2	#8,sp			;clean up stack
	brw	bad_number2		;bad number processing

1260$:	cmpb	r5,#9			;is it a number?
	bleq	1270$			;if leq, then yes, cont
	cmpb	r5,#16			;is it between 9 and A
	bleq	1250$			;if leq, then yes, fail
	subb	#7,r5			;try for cap A-F
	cmpb	r5,#15			;is it A-F?
	bleq	1270$			;if leq, then yes, cont
	cmpb	r5,#41			;is it between F and a?
	bleq	1250$			;if leq, then yes, fail
	subb	#32,r5			;try for a-f
	cmpb	r5,#15			;is it a-f?
	bleq	1270$			;if leq, then yes
	brb	1250$			;it's past f, fail
1270$:	cmpb	r5,r4			;is it in range?
	bgtr	1250$			;if gtr then fail
	movab	<revbit-1>[r5],r5	;get addr of table entry
	movb	(r5)[r4],r5		;get the reversed bits of the value
	insv	r5,r6,r0,(r7)		;insert reversed bits in string
	addl	r0,r6			;address next offset
1280$:	sobgeq	r3,1240$			;go again
1290$:	

	movl	r6,pli_tokr$l_0(r10)	;length of complete token
	movl	r7,pli_tokr$l_1(r10)	;address of first bit of token
	movl	#bit_,pli_tokr$l_2(r10)	;data type of token
	movl	r6,pli_tokr$l_3(r10)	;size of token (number of bits)
	movl	#bit_,pli_tokr$l_4(r10)	;data type (secondary)
	movl	r6,pli_tokr$l_5(r10)	;size of token (secondary)
	movq	(sp)+,r6		;input descriptor update values
	movl	#pli_toktyp_plic,@ap_token_type(ap) ;pli constant is token type
	brw	finish			;final token processing
;
;***************************************************************************
;*                                                                         *
;*    error processing                                                     *
;*                                                                         *
;***************************************************************************
;
;
;inconsistency within this module (or bad parameter passed to this module
;on input, r0 contains error type (pli debug error codes 200 - 299)
;error will be signaled
;
bug_check:				;
	pushl	r0			;error type
	pushl	#1			;one fa0 argument
	pushl	#dbg$_debugbug		;pli debug module error
	calls	#3,lib$signal		;signal error, should never return
	movl	#dbg$_debugbug,r0	;return code
	ret				;
;
;***************************************************************************
;*                                                                         *
;*   exit processing                                                       *
;*                                                                         *
;***************************************************************************
;
;
;assumes:
;	r6 = "new" length of input string
;	r7 = "new" address of start of input string
;	r11 = address of input string's descriptor
;error level at entrance to this code is irrelevant
;
finish:	skpc	#^A/ /,r6,(r7)		;skip any trailing blanks
	movq	r0,r6			;updated length and address of input
;
;assumes:
;	r6 = "new" length of input string
;	r7 = "new" address of start of input string
;	r11 = address of input string's descriptor
;error level at entrance to this code is irrelevant
;
ok_exit: 				;
	movl	#sts$k_success,r0	;success return code
	brb	exit			;join common code
;
;assumes:
;	r0 = required return code
;	r6 = "new" length of input string
;	r7 = "new" address of start of input string
;	r11 = address of input string's descriptor
;error level at entrance to this code is irrelevant
;
exit:
	movw	r6,dsc$w_length(r11)	;new length of input string
	movl	r7,dsc$a_pointer(r11)	;new start address of input string
	ret				;
	.page
	.subtitle pli_get_tok_prm
;	ROUTINE PLI_GET_TOK_PRM (input_desc, lex_str_desc, token)
;++
; FUNCTIONAL DESCRIPTION:
;	This routine is called by the pathname parser to obtain tokens. The
;	tokens of interest are those which can occur within a pathname or
;	those which terminate a pathname. The pathname returned as the
;	result of encountering  a\b 10\c.d   is  a\b 10\c
;	and			a\b 10\c(20) is  a\b 10\c
;	In both cases, the last name is not really part of the pathname but
;	is instead the first element of the variable name.
;
;
; FORMAL PARAMETERS:
;
;       input_desc  -   A longword containing the address of a VAX standard
;                       string descriptor describing the input string
;			This descriptor is NOT modified by this routine.
;
;	lex_str_desc -	This routine fills in dsc$a_pointer and dsc$w_length
;			so as to point to the lexical entity it found. The
;			descriptor is created by the caller of this routine.
;			Note that the token as described by this descriptor
;			does NOT include preceding blanks.
;
;	token	   - The address of a longword to contain the address of the
;			encoded lexical type:
;
;			symbolic name        meaning
;
;			dbg$k_tok_null		the input string contains zero
;						or more blanks followed by an
;						optional CR. Lex_str_desc has
;						length field value = 0 and the
;						pointer points either one byte
;						beyond the field (if no CR) or
;						one byte beyond the CR. 
;
;			dbg$k_tok_inval		the pointed to character is
;						not recognized by the scanner
;						as valid input. e.g. a\b + 10
;						would result in this code when
;						the '+' was encountered. The
;						length field of lex_str_desc
;						is not updated.
;
;			dbg$k_tok_line		%li, %lin, %line encountered
;
;			dbg$k_tok_label		%label encountered (not
;						returned by pli)
;
;			dbg$k_tok_bs		"\"
;
;			dbg$k_tok_id		legal pli identifier
;						encountered.
;						Legal forms are:
;						name
;						name (...)
;
;						May be part of forms:
;						name1 . name2
;						name1 (...) . name2
;
;						Illegal forms:
;						name1 (...) name2
;						name1 . (...) name2
;
;						Note that blanks may occur
;						anywhere except within
;						identifiers.
;
;
;			dbg$k_tok_int		valid integer string
;						encountered (interpreted
;						according to radix = base 10)
;
;			dbg$k_tok_dot		"."
;
;			dbg$k_tok_reg		%r0, %r1, ..., %psl
;
;
;
;
;
;
;
; IMPLICIT INPUTS:
;
;       NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; ROUTINE VALUE:
;
;       unsigned integer longword completion code
;	(always success)
;
; COMPLETION CODES:
;
;
;       STS$K_SUCCESS (1) -     Token returned. No error encountered.
;
;
;
; SIDE EFFECTS:
;
;	none
;
;
; REGISTER      USE
;
;	r11	points to input string descriptor
;	r10	points to lex_str_desc (lexical string descriptor)
;	r6	length of lexical unit
;	r7	address of first byte of lexical unit;
;
;
;
; parameter list offsets
;
ap_input_desc    =  4
ap_lex_str_desc  =  8
ap_token	 = 12
;
;
;
	.psect	dbg$code,exe,nowrt,long,pic,shr
;
	.entry	pli_get_tok_prm,^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>
	movl	ap_input_desc(ap),r11	;address of input descriptor
	movl	ap_lex_str_desc(ap),r10	;address of lexical string descriptor
	movzwl	dsc$w_length(r11),r0	;length of input string
	movl	dsc$a_pointer(r11),r1	;address of input string
	skpc	#^a/ /,r0,(r1)		;skip blanks
	bneq	10$			;branch if ok
;
;all blanks encountered
;
	movq	r0,r6			;transfer length and start address
	movl	#dbg$k_tok_null,@ap_token(ap) ;null token code
	brw	300$			;finish up processing
10$:					;
	movq	r0,r6			;save the remaining length of string
					;and the starting address
	movzbl	(r1),r3			;get character into register
	ashl	#3,r3,r3		;convert ascii code to bit displacement
	extzv	r3,#tbl_code_size,p_table,r4 ;get type of character as a code
	caseb	r4,#0,#13		;case on 1st character's type
20$:	.word	280$   	   - 20$	;invalid character
	.word	30$        - 20$	;alpha,$,or _
	.word	50$        - 20$	;digit
	.word	60$        - 20$	;backslash
	.word	70$        - 20$	;%
	.word	260$       - 20$	;carriage return
	.word	270$       - 20$	;dot
	.word	280$	   - 20$	;left parenthesis
	.word	280$	   - 20$	;right parenthesis
	.word	280$	   - 20$	;comma
	.word	280$	   - 20$	;dash
	.word	280$	   - 20$	;slash
	.word	280$	   - 20$	;pli operator
	.word	280$	   - 20$	;single quote
	movl	#pli$k_tbl,r0		;parse table contains illegal value
	brw	bug_check		;internal error
;
;alphabetic
;$
;or _
;
;upon entering this code, we assume:
;	r0 = r6 = length of the remaining string (including cr)
;	r1 = r7 = address of first alphabetic character of string
;	r8	= descriptor length restoration value. Used in case
;		it is necessary to assume the max_id length in scanning
;		for an identifier. It holds the difference between the
;		actual length of the string and the assumed scan length.
;		Usually the value is 0, the case when the rest of the
;		string is less than pli$k_max_id.
;	r10     = address of lex_str_desc
;
30$:					;		
	movl	#dbg$k_tok_id,@ap_token(ap) ;token code for identifier
	clrl	r8			;default desc. restore value
	cmpl	r0,#pli$k_max_id	;more than 31 characters?
	bleq	40$			;branch if not more than 31 characters
	movl	#pli$k_max_id,r0	;if more than 31, we look at only 31
	subl3	r0,r6,r8		;desc. restore if max_id used
	movl	r0,r6			;maximum length
40$:	moval	p_table,r3		;parse table address for spanc restart
41$:	spanc	r0,(r1),(r3),#<m_alpha$_ ! m_digit> ;span alphanumerics,$,_
	addl2	r8,r0			;restore proper length to r0
	addl2	r8,r6			;restore proper length to r6
	cmpb	#^a/%/,(r1)		;scan terminated by %? (special case
					;for begin%xx (wanted to save that one
					;extra bit in p_table ))
	bneq	43$			;branch if no terminal "%"
	incl	r1			;skip past "%"
	decl	r0			;decrease count of remaining characters
	brb	41$			;continue scan
43$:	subl2	r0,r6			;length of identifier
	brw	300$			;finish up processing
;
;digit encountered
;
;register values on input:
;	r0 = r6 = length of remaining string
;	r1 = r7 = address of remaining string
;	r10     = address of lex_str_desc
;
;
50$:					;
	movl	#dbg$k_tok_int,@ap_token(ap) ;value descriptor type
	spanc	r0,(r1),p_table,#<m_digit ! m_a_to_f> ;find first non-digit
	subl2	r0,r6			;length of identifier
	brw	300$			;
;
; got back slash
;
60$:					;
	movl	#dbg$k_tok_bs,@ap_token(ap) ;token code for back slash
	brw	290$			;process that one character token
;
; got a %
;
70$:					;
	movq	r6,r8			;pointer and length starting at "%"
	decl	r0			;length beyond "%"
	incl	r1			;point past "%"
	movq	r0,r6			;save pointer, length past "%"
	spanc	r0,(r1),p_table,#<m_alpha$_!m_digit> ;skip alphanumerics
	subl2	r0,r6			;length of identifier with %
	cmpl	r6,#<line_tok_min-1>	;minimum number of characters? (don't
	blss	90$			;count %). Branch if too few.
	cmpl	r6,#<line_tok_max-1>	;maximum number of character (less %)
					;(scan normally stopped by blank)
	bgtr	100$			;branch if too many characters
	cmpc3	r6,(r7),str_line+1	;line? (li,lin,line)
	bneq	100$			;branch if not
	cmpb	#^a/ /,(r7)[r6]		;byte after identifer is blank?
	bneq	100$			;branch if can't be legal %line
;
;%line encountered
;
	movl	#dbg$k_tok_line,@ap_token(ap) ;token code for dot
	incl	r6			;include % in count
	decl	r7			;point to %
	brw	300$			;successful return
;
; not %line because too few characters
;
90$:					;
;
; not %line because of other reasons
; check for %label
;
; register	value upon entrance
;
;	r6	length of characters checked in %line check (not including "%")
;	r7	points past initial "%"
;	r8	length of initial input string starting at "%"
;	r9	points to initial "%"
;
100$:					;
	movq	r8,r0			;pointer and length from %
	decl	r0			;length beyond "%"
	incl	r1			;point past "%"
	movq	r0,r6			;pointer and length beyond %
	spanc	r0,(r1),p_table,#<m_alpha$_!m_digit> ;skip alphanumerics
	subl2	r0,r6			;length of identifier with %
	cmpl	r6,#<label_tok_min-1>	;minimum number of characters? (don't
	blss	190$			;count %). Branch if too few.
	cmpl	r6,#<label_tok_max-1>	;maximum number of character (less %)
					;(scan normally stopped by blank)
	bgtr	200$			;branch if too many characters
	cmpc3	r6,(r7),str_label+1	;line? (li,lin,line)
	bneq	200$			;branch if not
	cmpb	#^a/ /,(r7)[r6]		;byte after identifer is blank?
	bneq	200$			;branch if can't be legal %line
;
;%label found
;
	movl	#dbg$k_tok_label,@ap_token(ap) ;token code for dot
	incl	r6			;include % in count
	decl	r7			;point to %
	brw	300$			;successful return
;
; register	use
;
;	r6     length of characters checked in %label check (not including "%")
;	r7     points past initial "%"
;	r8     length of initial input string starting at "%"
;	r9     points to initial "%"
;
; check for %r0, %r1, ... , %psl
;
190$:					;not %label because of too few chars.
200$:					;not %label because of other reasons
	subl3	#1,r8,r6		;point past the initial "%"
	movq	r6,r0			;make a copy of length and pointer
; upon entering this code, we assume
; r0 = r6 = length of the remaining string (just past "%")
; r1 = r7 = address of the remaining string (just past "%")
; r10 = address of a lexical string descriptor
; r11 = address of input string descriptor
;
;note: we removed check of pli$k_max_id to simplify the code. It
;is not really necessary and r8 is not available here
	spanc	r0,(r1),p_table,#<m_alpha$_!m_digit> ;skip alphanumerics
	subl2	r0,r6			;length of identifier, not including %
	bneq	220$			;branch if not lone %
;
;encountered a lone %
;
	movq	r8,r6			;invalid token starts at "%"
	brw	280$			;common invalid character processing
;
;permanent symbol check: %r0,%r1,%r2, ..., %pc,%psl
;
220$:					;
	pushr	#^m<r8,r9>		;save the len. and addr. of initial "%"
	movab	perm_sym_list,r9	;point to permanent symbol list
	movl	r9,r8			;save start of the list
	brb	240$			;go get length and address of test
;
;register usage for the following code
;	r9	start of symbol list
;	r8	pointer into index list
;	r7	address of identifier, (past %)
;	r6	length of identifier, (not including %)
;	r5	address of string
;	r4	length of test
; check for permanent symbols
;enter (240$ (pointing past identifying string)
;
230$:	cmpl	r4,r6			;length test = length identifier
	bneq	240$			;branch if not the same length
	cmpc3	r6,(r7),(r5)		;are the strings the same?
	beql	250$			;branch if equal
240$:	movl	(r8)+,r4		;get length
	beql	109$			;branch if no more
	movl	(r8)+,r5		;address of name
	addl2	r9,r5			;relocate address
	brb	230$			;
;
;permanent symbol
;
250$:					;
	moval	8(sp),sp		;pop off saved values
	movl	#dbg$k_tok_reg,@ap_token(ap) ;token type of register
	incl	r6			;include % in identifier
	decl	r7			;point to %
	brw	300$			;common exit processing
;
;not a permanent symbol
;
109$:	popr	#^m<r6,r7>		;back up to start of string ("%")
	brb	280$			;go return invalid character
;
; null token processing (CR encountered)
;	assumes r6 = 1 or greater
;		r7 points to CR
;		r10 = address of lex_str_desc
;
260$:					;
	movl	#dbg$k_tok_null,@ap_token(ap) ;null token code
	clrl	r6			;make length zero
	incl	r7			;point past CR
	brb	300$			;successful return
;
; "." encountered
;	assumes r0 = r6 = length of remaining string (includes .)
;		r1 = r7 = address of remaining string (points to .)
;		r10     = address of lex_str_desc
270$:					;
	movl	#dbg$k_tok_dot,@ap_token(ap) ;token code for dot
	brb	290$			;go process on character token
;
;invalid character encountered
;
280$:					;
	movl	#dbg$k_tok_inval,@ap_token(ap) ;invalid token encountered
	brb	300$			;final processing
;
;one character processing
;	assumes:
;	r7 = address of start of lexical entity
;	r10 = address of lex_str_desc
;
290$:	movl	#1,r6			;length of token

;
;assumes:
;	r6 = length of lexical entity
;	r7 = address of start of lexical entity
;	r10 = address of lex_str_desc
;
300$: 					;
	movl	#sts$k_success,r0	;success return code
	movw	r6,dsc$w_length(r10)	;length of lexical token
	movl	r7,dsc$a_pointer(r10)	;start address of lexical token
	ret				;

	.end
