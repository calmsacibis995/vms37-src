	.SBTTL	Definitions & Data
	.TITLE	DBGCOBCVT - COBOL type converter & arithmetic for DEBUG

;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

	$SSDEF
	$DSCDEF
	$STSDEF
	$CHFDEF
	$DBGDEF

	.__.	= 0		; Place marker in conversion tables

	value_vmsdesc	=  8

	default_radix	=  1

	value_format	= 122
	external_format	= 129
	vax_format	= 130

	value_picture	=  20

	EO_END		= ^X00
	EO_END_FLOAT	= ^X01
	EO_SET_SIGNIF	= ^X03
	EO_STORE_SIGN	= ^X04
	EO_LOAD_FILL	= ^X40
	EO_LOAD_PLUS	= ^X42
	EO_INSERT	= ^X44
	EO_ADJUST_INPUT	= ^X47
	EO_FILL		= ^X80
	EO_MOVE		= ^X90
	EO_FLOAT	= ^XA0

	.PSECT	DBG$PLIT,BYTE,PIC,SHR,NOWRT

signed_dtypes:	.LONG	  <1@dsc$k_dtype_b>  + <1@dsc$k_dtype_w> -
			+ <1@dsc$k_dtype_l>  + <1@dsc$k_dtype_q> -
			+ <1@dsc$k_dtype_f>  + <1@dsc$k_dtype_d> -
			+ <1@dsc$k_dtype_nl> + <1@dsc$k_dtype_nlo> -
			+ <1@dsc$k_dtype_nr> + <1@dsc$k_dtype_nro> -
			+ <1@dsc$k_dtype_nz> + <1@dsc$k_dtype_p>

numeric_dtypes:	.LONG	  <1@dsc$k_dtype_bu> + <1@dsc$k_dtype_b> -
			+ <1@dsc$k_dtype_wu> + <1@dsc$k_dtype_w> -
			+ <1@dsc$k_dtype_lu> + <1@dsc$k_dtype_l> -
			+ <1@dsc$k_dtype_qu> + <1@dsc$k_dtype_q> -
			+ <1@dsc$k_dtype_f>  + <1@dsc$k_dtype_d>
		.LONG	0,0,0,0,0,0,0		; Make table 256 bits long

fudge_factor:	.WORD	^X5C00,0,0,0
two_to_the_32:	.WORD	^X5080,0,0,0
two_to_the_64:	.WORD	^X6080,0,0,0
packed_factor:	.BYTE	^X04,^X29,^X49,^X67,^X29,^X6C

edit_codes_1:	.BYTE	EO_MOVE,	EO_FLOAT,	EO_FILL
edit_codes_2:	.BYTE	EO_SET_SIGNIF,	EO_END_FLOAT

sign_codes:	.BYTE	^A"+",^A"-"

default_length:	.BYTE 0,0,3,5,10,18,3,5,10,18,18,18,0,0,0,-1,-1,-1,-1,-1,-1,-1,-1

translation_table:
    .ASCII  `                                 !"#$%&'()*+,-./0123456789:;<=>?`
    .ASCII  '@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~ '
    .ASCII  `                                 !"#$%&'()*+,-./0123456789:;<=>?`
    .ASCII  '@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~ '

valid_digits:
	.ASCII	'0123456789ABCDEF'

	.PSECT	DBG$OWN ,LONG,PIC,NOEXE

packed_desc:
	.WORD	0		; Length
	.BYTE	dsc$k_dtype_p	; Dtype = packed
	.BYTE	dsc$k_class_sd	; Class = scaled
	.BLKL	1		; Address
	.BLKB	1		; Scale Factor
	.BLKB	1		; Digit Count
	.BLKB	2		; <Reserved>
digit_string:
	.BLKB	16		; Storage for digits

fixed_desc:
	.WORD	8		; Length
	.BYTE	dsc$k_dtype_q	; Dtype = quadword
	.BYTE	dsc$k_class_sd	; Class = scaled
	.BLKL	1		; Address
	.BLKB	1		; Scale Factor
	.BLKB	1		; Digit Count
	.BLKB	2		; <Reserved>
fixed_value:
	.BLKQ	1		; Storage for value

shift_desc:
	.WORD	8		; Length
	.BYTE	dsc$k_dtype_qu	; Dtype = unsigned quadword
	.BYTE	dsc$k_class_sd	; Class = scaled
	.BLKL	1		; Address
	.BYTE	0		; Scale Factor
	.BYTE	0		; Digit Count
	.BLKB	2		; <Reserved>

	.PSECT	DBG$CODE,BYTE,PIC,SHR,NOWRT

	.SBTTL	DBG$NCOB_TYPE_CONV
;GLOBAL ROUTINE DBG$NCOB_TYPE_CONV(value_desc,target_radix,target_type,target_desc,message_vect) =
;++
; FUNCTIONAL DESCRIPTION:
;
;	Performs language specific and language independent type conversions.
;	These will be both internal-to-internal and internal-to-external in
;	nature. Source is described by a language specific value descriptor.
;	Target may be described by either a language specific value descriptor
;	or a VAX standard descriptor from the following set:
;
;	dsc$k_dtype_b 
;
;	dsc$k_dtype_w 
;
;	dsc$k_dtype_l
;
;	dsc$k_dtype_t
;
;	Note that this routine will be used to obtain the 'printable' (external)
;	value of the source as the result of EXAMINE commands. In this case,
;	the target descriptor will be a VAX standard descriptor of type
;	dsc$k_dtype_t.
;
; FORMAL PARAMETERS:
;
;	value_desc	- A longword which contains the address of a language
;			  specific value descriptor
;	
;	target_radix	- A longword containing an integer encoding of the radix
;			  to be used when converting to a 'printable' value:
;
;		dbg$k_default	(1)	- source language default radix
;
;		dbg$k_binary	(2)	- binary radix
;
;		dbg$k_octal	(8)	- octal radix
;
;		dbg$k_decimal	(10)	- decimal radix
;
;		dbg$k_hex	(16)	- hexadecimal radix
;
;			Note that this parameter is significant ONLY when the
;			object described by the source descriptor is to be
;			converted to external format. A request for a binary,
;			octal, or hex 'printable' value means to consider the
;			value of source as a bit pattern to be translated to
;			special characters. In this sense, the type of the source
;			value is not significant - only the length. Values will
;			therefore be displayed as unsigned integers within the
;			specified radix. Values will be left-extended to nibble
;			boundaries.

;	
;	target_type	- A longword containing an unsigned integer encoding of the
;			  type of information contained within the target parameter:
;
;		dbg$k_vax_desc      (130) -  target contains the address of a
;					     VAX standard descriptor
;
;					     Note: The caller of dbg$ncob_type_conv
;					     must assure that the dsc$a_pointer
;					     field of the descriptor contains the
;					     address of an appropriately large
;					     block of storage.
;
;		dbg$k_value_desc    (122) -  target contains the address of a
;					     language specific value descriptor
;
;		dbg$k_external_desc (129) -  target contains the address of
;					     a VAX standard string descriptor.
;					     This is a request to convert to
;					     'printable' format. Conversion must
;					     include check for unprintable characters.
;
;	target_desc	- A longword which contains the address of either a VAX
;			  standard descriptor, or a language specific value descriptor
;
;	message_vect	- The address of a longword to contain the address of
;			  a message argument vector as described on page 4-119 of
;			  the VAX/VMS system reference, volume 1A
;
; IMPLICIT INPUTS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	When this routine is called to obtain the 'printable' (external) value
;	of the source object, the target will contain the address of a VAX
;	standard string descriptor with length and pointer fields set to 0.
;	Dynamic storage must be obtained to contain the resulting ascii string.
;
;	In all other cases, this routine is not required to allocate storage to
;	contain the resulting value of a conversion request. Targets which are
;	described by VAX standard descriptors MUST contain the address of a
;	block of storage (the dsc$a_pointer field)
;	in which the resulting value of the conversion will be stored. 
;
;	Dynamic storage must be used to construct the message argument vector
;	upon a severe error return.

;
; ROUTINE VALUE:
;
;	unsigned integer longword completion code
;
; COMPLETION CODES:
;
;	STS$K_SUCCESS (1) - Success. Conversion performed.
;
;	STS$K_SEVERE  (4) - Failure. No conversion. Message argument vector
;			     constructed and returned.
;
; SIDE EFFECTS:
;
;	Informational messages such as string and number truncation may be 
;	issued during processing.
;
;--

;DBG$NCOB_TYPE_CONV(value_desc,target_radix,target_type,target_desc,message_vect)

	value_desc	=  4
	target_radix	=  8
	target_type	= 12
	target_desc	= 16
	message_vect	= 20

.ENTRY dbg$ncob_type_conv,^M<R2,R3,R4,R5,R6,R7,R8>

	MOVAB	W^local_handler,0(FP)		; Set up exception handler
	MOVL	target_desc(AP),R4		; Get target descriptor address
	CMPB	target_type(AP),#value_format	; Target a value descriptor ?
	BNEQ	1$				; No  - just check dtype
	ADDL2	#value_vmsdesc,R4		; Yes - get descriptor address
1$:	ADDL3	#value_vmsdesc,value_desc(AP),R5; Get VMS descriptor address
	MOVZBL	dsc$b_dtype(R4),R2		; Get type of destination
	MOVZBL	dsc$b_dtype(R5),R3		; Get type of source
	CMPB	target_type(AP),#external_format; Convert to printing format ?
	BNEQ	2$				; No  - ignore radix value
	CMPB	target_radix(AP),#default_radix	; Yes - explicit radix given ?
	BEQL	2$				; No  - use implicit format
	BRW	output_in_special_radix		; Yes - output value specially
2$:	BBS	R3,L^numeric_dtypes,3$		; Check for simple numeric type
	CMPB	R3,#dsc$k_dtype_t		; Is this a text data item ?
	BNEQ	pack_unpack			; No  - must be numeric string
	BRW	src_type_text			; Yes - go handle specially
3$:	TSTW	dsc$b_scale(R5)			; Scaled or sized value ?
	BNEQ	pack_unpack			; If so, do it the hard way
	CMPB	dsc$b_class(R4),#dsc$k_class_sd	; Is this a scaled descriptor ?
	BNEQ	4$				; If not, just check dtype
	TSTW	dsc$b_scale(R4)			; Scaled or sized value ?
	BNEQ	pack_unpack			; If so, do it the hard way
4$:	BBC	R2,L^numeric_dtypes,pack_unpack	; Check for simple numeric type
	BBC	R2,L^signed_dtypes,pack_unpack	;  and check destination is signed
	BSBW	dbg$ncob_convert_numeric	; Convert numeric to numeric
	CASEB	R0,#0,#2			; Check status returned
5$:	.WORD	6$-5$				; 0 - Issue truncation warning
	.WORD	7$-5$				; 1 - Return
	.WORD	pack_unpack-5$			; 2 - convert the hard way
6$:	PUSHL	I^#dbg$_numtrunc		; Stack actual error code
	CALLS	#1,G^lib$signal			; Signal the error condition
	MOVL	#sts$k_success,R0		; Set up completion code
7$:	RET					; And return

pack_unpack:
	CMPB	R2,#dsc$k_dtype_t		; Convert to text string ?
	BNEQ	1$				; No  - convert to packed value
	CMPB	target_type(AP),#external_format; Yes - converting for output ?
	BEQL	1$				; Yes - convert to packed value
	CMPB	target_type(AP),#value_format	; No  - doing a "deposit" ?
	BNEQ	no_conversion			; No  - incompatible types
	ADDL3	#value_picture,target_desc(AP),-(SP); Check to see if we have
	TSTL	@(SP)+				;  a "picture" specification
	BEQL	no_conversion			;   and report error if not
1$:	CLRL	-(SP)				; Initialize descriptor address
	PUSHL	message_vect(AP)		; Push address of message vector
	PUSHAL	4(SP)				; Say where we want address
	PUSHL	R5				; Stack VAX descriptor address
	CALLS	#3,W^dbg$ncob_convert_to_packed	; Convert to packed decimal
	BLBC	R0,return			; Return any errors seen
	POPL	R6				; Get packed descriptor address
	CMPB	R2,#dsc$k_dtype_t		; Convert to text string ?
	BNEQ	2$				; No  - do the conversion here
	BRW	dst_type_text			; Yes - go perform conversion
2$:	PUSHL	message_vect(AP)		; Push message vector address
	PUSHL	R4				; Stack address of destination
	PUSHL	R6				; Stack address of packed descriptor
	CALLS	#3,W^dbg$ncob_convert_from_packed;Convert from packed decimal
return:	RET					; Return status code in R0

no_conversion:
	PUSHL	I^#dbg$_notcompat		; Error - types are incompatible
	CALLS	#1,G^dbg$nmake_arg_vect		; Create error message vector
	MOVL	R0,@message_vect(AP)		; Store address of message
	MOVL	#sts$k_severe,R0		; Get failure completion code
	RET					; And return

output_in_special_radix:
	CMPB	R3,#dsc$k_dtype_t		; Is source a text string ?
	BEQL	4$				; Yes - handle this specially
	CMPB	dsc$b_class(R5),#dsc$k_class_sd	; Scaled descriptor ?
	BNEQ	1$				; No  - don't check scaling !
	TSTB	dsc$b_scale(R5)			; Yes - is scale factor zero ?
	BNEQ	3$				; No  - incompatible argument !
1$:	CLRQ	R1				; Initialize sign & high 32 bits
	MOVL	@dsc$a_pointer(R5),R0		; Get low 32 bits of value
	CASEB	R3,#dsc$k_dtype_bu,#dsc$k_dtype_q - dsc$k_dtype_bu
2$:	.WORD	size_x  - 2$		;  2 = dsc$k_dtype_bu
	.WORD	size_x  - 2$		;  3 = dsc$k_dtype_wu
	.WORD	size_x  - 2$		;  4 = dsc$k_dtype_lu
	.WORD	size_q  - 2$		;  5 = dsc$k_dtype_qu
	.WORD	size_b  - 2$		;  6 = dsc$k_dtype_b
	.WORD	size_w  - 2$		;  7 = dsc$k_dtype_w
	.WORD	size_l  - 2$		;  8 = dsc$k_dtype_l
	.WORD	size_q  - 2$		;  9 = dsc$k_dtype_q
3$:	PUSHL	I^#dbg$_integer			; Error - not integer variable
	CALLS	#1,G^dbg$nmake_arg_vect		; Create error message vector
	MOVL	R0,@message_vect(AP)		; Store address of message
	MOVL	#sts$k_severe,R0		; Get failure completion code
	RET					; And return

4$:	MOVZWL	dsc$w_length(R5),R3		; Get length of text string
	BEQL	7$				; Easy if zero-length string !
	CMPL	R3,#16				; Sixteen or less bytes ?
	BLEQ	5$				; Yes - proceed
	PUSHL	I^#dbg$_stgtrunc		; No  - get error message
	CALLS	#1,G^lib$signal			; Signal the error condition
	MOVL	#16,R3				; Get maximum length we handle
5$:	PUSHL	R3				; Stack length (in bytes)
	CALLS	#1,L^dbg$get_tempmem		; Allow that many longwords
	MOVL	R0,dsc$a_pointer(R4)		; Set up pointer to output
	MOVL	dsc$a_pointer(R5),R1		; Get pointer to input text
6$:	SUBL3	target_radix(AP),#34,R2		; Convert "output radix" to
	ASHL	#-3,R2,R2			;  characters-per-byte
	MOVZBL	(R1)+,R5			; Get next byte of input string
	BSBB	format_byte			; Go output a single byte
	MOVB	#^A" ",(R0)+			; Add a trailing space
	SOBGTR	R3,6$				; Loop for all bytes
	DECL	R0				; Remove last space character
	SUBL3	dsc$a_pointer(R4),R0,R3		; Get actual length of string
7$:	CVTLW	R3,dsc$w_length(R4)		; Set up length in descriptor
	MOVL	#sts$k_success,R0		; get completion code
	RET					; And return

format_byte:
	DECL	R2				; Count field-width down
	BLEQ	1$				; Branch if width exhausted
	CLRL	R6				; Extend to 64-bit quantity
	EDIV	target_radix(AP),R5,R5,R6	; Split off "remainder" digit
	PUSHL	R6				; Save remainder on stack
	BSBB	format_byte			; Go 'print' leading digits
	MOVL	(SP)+,R5			; Get remainder digit
1$:	MOVB	L^valid_digits[R5],(R0)+	; Insert ASCII character code
	RSB					; And return

size_b:	CVTBW	R0,R0				; Sign-extend to 16 bits
size_w:	CVTWL	R0,R0				; Sign-extend to 32 bits
size_l:	ASHL	#-31,R0,R2			; Test sign of quantity
	BGEQ	size_x				; O.K. if really positive
	MNEGL	R0,R0				; Otherwise negate value
	BRB	size_x				; Go split off digits
size_q:	MOVQ	@dsc$a_pointer(R5),R0		; Copy 64 bits of value
	BGEQ	size_x				; O.K. if really positive
	CMPB	R3,#dsc$k_dtype_q		; Is value signed ?
	BNEQ	size_x				; No  - full 64-bit value
	DECL	R2				; Remember sign was negative
	MCOML	R1,R1				; Complement high-order bits
	MNEGL	R0,R0				;  and negate low-order bits
	BNEQ	size_x				; Any low-order bits set ?
	INCL	R1				; No  - propagate 'carry'
size_x:	MOVAB	(SP),R3				; Initialize text-pointer
	SUBL	#24,SP				; reserve space on the stack
	MOVQ	R0,R4				; Copy over quadword value
	ASHL	#1,target_radix(AP),R8		; Get twice radix value
1$:	CLRL	R6				; Extend to 96-bit value
	EDIV	target_radix(AP),R5,R1,R5	; Do 1st half of division
	EDIV	R8,R4,R0,R6			;  & 2nd half of division
	ROTL	#1,R0,R0			; Get bits into correct place
	SUBL3	target_radix(AP),R6,R7		; Is remainder correct ?
	BLSS	2$				; Yes - go insert ASCII code
	MOVL	R7,R6				; No  - get new remainder
	INCL	R0				; And increment quotient
2$:	MOVB	L^valid_digits[R6],-(R3)	; Store final digit code
	MOVQ	R0,R4				; Copy over quadword value
	BNEQ	1$				; Loop for all digits
	BLBC	R2,3$				; Was value really negative ?
	MOVB	#^A"-",-(R3)			; Yes - insert sign char
3$:	ADDL3	#24,SP,R2			; Get address of end of string
	SUBL2	R3,R2				; Get length of string
	ADDL3	#3,R2,R0			; Allow for possible pad bytes
	DIVL3	#4,R0,-(SP)			; Get number of longwords needed
	CALLS	#1,L^dbg$get_tempmem		; Allocate space for string
	MOVL	target_desc(AP),R5		; Get address of output descriptor
	MOVW	R2,dsc$w_length(R5)		; Store actual string length
	MOVL	R0,dsc$a_pointer(R5)		; Store address in descriptor
	MOVC3	R2,(R3),(R0)			; Copy over actual characters
	MOVL	#sts$k_success,R0		; Get completion code
	RET					; And return

dst_type_text:
	CMPB	target_type(AP),#external_format; Converting to output format ?
	BEQL	format_for_output		; Yes - go allocate space
	SUBL	#20,SP				; No  - reserve local storage
	PUSHAB	4(SP)				; Where to store scale factor
	PUSHAB	4(SP)				; Where to store encoding ptr
	PUSHAB	16(SP)				; Where to store picture ptr
	PUSHAB	24(SP)				; Where to store language code
	MOVL	target_desc(AP),R0		; Get address of v_value desc
	PUSHL	value_picture(R0)		; Stack "Picture" TYPEID
	CALLS	#5,L^dbg$sta_typ_pict		; Get pointers to picture
	SUBB3	4(SP),dsc$b_scale(R6),R7	; Get change in scale needed
	MOVZBL	5(SP),R8			; Get target number length
	MOVZBL	dsc$b_digits(R6),R9		; Get current number length
	MOVL	dsc$a_pointer(R4),R10		; Get final destination address
	ASHP	R7,R9,@dsc$a_pointer(R6),#0,R8,4(SP)	; Set correct length
	BVC	1$				; Check for decimal overflow
	PUSHL	I^#dbg$_valoutbnds		; Get error code 
	CALLS	#1,G^lib$signal			; Report the error
1$:	EDITPC	R8,4(SP),@(SP)+,(R10)		; Perform editing
	MOVL	#sts$k_success,R0		; Set completion code
	RET					; And return

format_for_output:
	SUBL	#20,SP				; Reserve space for 'picture'
	MOVZBL	dsc$b_digits(R6),R0		; Get number of actual digits
	CVTBL	dsc$b_scale(R6),R1		; Get scaling factor
	BGEQ	2$				; Easy if no fraction !
	ADDL2	R0,R1				; Are there leading digits ?
	BLEQ	1$				; If not, allow for '0.xxx'
	MOVL	#1,R1				; If so, just allow for '.'
1$:	SUBL3	R1,#2,R1			; Get hidden character count
2$:	ADDL2	R1,R0				; Get number of bytes needed
	MOVZBL	dsc$b_dtype(R5),R3		; Get source data-type
	EXTZV	R3,#1,L^signed_dtypes,R3	; Get bit to say signed value
	ADDL2	R3,R0				; Allow for sign, if needed
	MOVL	target_desc(AP),R5		; Get address of output descriptor
	MOVW	R0,dsc$w_length(R5)		; Store actual string length
	ADDL2	#3,R0				; Allow for possible pad bytes
	DIVL3	#4,R0,-(SP)			; Get number of longwords needed
	CALLS	#1,L^dbg$get_tempmem		; Allocate space for string
	MOVL	R0,dsc$a_pointer(R5)		; Store address in descriptor

	MOVL	SP,R2				; Get pointer to picture string
	MOVZBL	dsc$b_digits(R6),R4		; Get actual number of digits
	ADDB3	R4,dsc$b_scale(R6),R0		; Get scaling factor for output
	BGTR	3$				; Branch if leading digits
	SUBB3	R0,#1,R0			; Otherwise get number of "0"s
	ADDB2	R0,R4				; Adjust count of digits
	MOVB	#EO_ADJUST_INPUT,(R2)+		; And tell EDITPC instruction
	MOVB	R4,(R2)+			;  how many digits to expect
3$:	BLBC	R3,4$				; Branch if no sign wanted
	MOVW	#EO_LOAD_PLUS+<<^A"+">@8>,(R2)+	; Signed - force plus sign
	CMPB	dsc$b_digits(R6),R4		; Is this a fraction only ?
	BEQL	4$				; No  - all is set up
	MOVB	#EO_STORE_SIGN,(R2)+		; Yes - store the sign NOW
	CLRL	R3				; Say sign has been processed
4$:	MOVL	R4,R0				; Get total number of digits
	CVTBL	dsc$b_scale(R6),R1		; Get scaling factor
	BGEQ	5$				; Branch if no decimal point
	ADDL2	R1,R0				; Otherwise get high digit count
5$:	SUBL2	R0,R4				; Account for these digits
	DECL	R0				; Remember one is significant !
	BEQL	6$				; Branch if nothing to float
	BSBB	move_or_float_or_fill		; Go insert correct opcode
6$:	MOVB	L^edit_codes_2[R3],(R2)+	; END_FLOAT or SET_SIGNIF
	MOVB	#EO_MOVE+1,(R2)+		; Insert significant digit
	MOVL	R4,R0				; Get number of digits left
	BEQL	7$				; Branch if no fraction
	CLRL	R3				; Force 'EO_MOVE' opcode
	MOVW	#EO_INSERT+<<^A".">@8>,(R2)+	; Insert decimal point
	BSBB	move_or_float_or_fill		; Go insert opcode & count
7$:	CVTBL	dsc$b_scale(R6),R0		; Get scale factor again
	BLEQ	8$				; Branch if no trailing zeros
	MOVW	#EO_LOAD_FILL+<<^A"0">@8>,(R2)+	; Otherwise insert code to
	MOVL	#2,R3				;  load fill register with
	BSBB	move_or_float_or_fill		;  "0" and insert the fill
8$:	MOVB	#EO_END,(R2)+			; Terminate picture string
	EDITPC	dsc$w_length(R6),@dsc$a_pointer(R6),(SP),@dsc$a_pointer(R5)
	MOVL	#sts$k_success,R0		; Get completion code
	RET					;  and return

move_or_float_or_fill:
	MOVL	#15,R1				; Get maximum repeat count
	SUBL2	R1,R0				; Count off number of digits
	BGEQ	1$				; Branch if really that many
	ADDL2	R0,R1				; Otherwise get actual count
1$:	BISB	L^edit_codes_1[R3],R1		; Get EO_MOVE or EO_FLOAT
	MOVB	R1,(R2)+			; Insert in picture string
	TSTL	R0				; If more digits to process,
	BGTR	move_or_float_or_fill		;  repeat loop again
	RSB					;   otherwise return

src_type_text:
	CMPB	target_type(AP),#external_format; Converting for output ?
	BNEQ	6$				; No  - check compatibility
	MOVL	target_desc(AP),R6		; Get address of descriptor
	MOVZWL	dsc$w_length(R5),R4		; Get length of actual text
	BEQL	3$				; Branch if empty string
	CMPW	R4,#256				; More than the maximum length ?
	BLEQU	1$				; No  - output full string
	PUSHL	I^#dbg$_stgtrunc		; Yes - get error message
	CALLS	#1,G^lib$signal			; Signal the error condition
	MOVZWL	#256,R4				; Get maximum length we handle
1$:	MOVL	R4,R0				; Otherwise get copy of length
	MOVL	dsc$a_pointer(R5),R1		; Get start address of string
2$:	LOCC	#^A'"',R0,(R1)			; Look for a quote character
	BEQL	3$				; Branch if not found
	INCL	R4				; Count length up by one
	INCL	R1				; Step pointer over quote
	SOBGTR	R0,2$				; Loop if more string to test
3$:	ADDW3	#2,R4,dsc$w_length(R6)		; Store length in descriptor
	ADDL3	#5,R4,-(SP)			; Allow for quotes & pad bytes
	DIVL2	#4,(SP)				; Get number of longwords needed
	CALLS	#1,L^dbg$get_tempmem		; Allocate temporary storage
	MOVL	R0,dsc$a_pointer(R6)		; Store address in descriptor
	MOVB	#^A'"',(R0)+			; Store leading quote character
	MOVL	dsc$a_pointer(R5),R1		; Get address of source
	MOVL	R0,R5				; Get address of destination
	MOVL	R4,R0				; Get length of source
	MOVAB	L^translation_table,R3		; Set up address of escape table
4$:	MOVTUC	R0,(R1),#^A'"',(R3),R4,(R5)	; Copy over string characters
	MOVB	#^A'"',(R5)+			; Insert extra quote character
	DECL	R4				; Count destination length down
	BLSS	5$				; Exit loop if all copied
	MOVB	(R1)+,(R5)+			; Otherwise copy "escape" char
	SOBGTR	R0,4$				; Loop for rest of string
5$:	MOVL	#sts$k_success,R0		; Get completion code into R0
	RET					; And return to caller

6$:	CMPB	R2,#dsc$k_dtype_t		; Is destination text ?
	BEQL	7$				; Yes - go assign value
	brw	no_conversion			; No  - report error
7$:	MOVC5	dsc$w_length(R5),@dsc$a_pointer(R5),#^A" ",-
		dsc$w_length(R4),@dsc$a_pointer(R4);Copy over text string
	TSTL	R0				; Source string exhausted ?
	BEQL	8$				; Yes - no truncation
	PUSHL	I^#dbg$_stgtrunc		; No  - get error code
	CALLS	#1,G^lib$signal			; Signal the error condition
8$:	MOVL	#sts$k_success,R0		; Get completion code into R0
	RET					; And return to caller

	.SBTTL	DBG$NCOB_CONVERT_NUMERIC
;
;   Local routine to convert between numeric dtypes (b,bu,w,wu,l,lu,q,qu,f,d)
;
;   Called with	R2	Type of target
;		R3	Type of source
;		R4	Address of target descriptor
;		R5	Address of source descriptor
;
dbg$ncob_convert_numeric:
	PUSHR	#^M<R2,R3,R4,R5,R6,R7>		; Save all registers used
	MOVL	#1,R0				; Load "success" completion code
	MOVL	dsc$a_pointer(R4),R6		; Get address of target
	MOVL	dsc$a_pointer(R5),R7		; and address of source
	MOVL	(R7),R1				; Load 32 bits of value
						; N.B. zero-extended !!
	BSBB	convert				; Perform actual conversion
	POPR	#^M<R2,R3,R4,R5,R6,R7>		; Restore contents of registers
	RSB					; And return

convert:CASEB	R2,#dsc$k_dtype_b,#dsc$k_dtype_d - dsc$k_dtype_b
1$:	.WORD	convert_to_b   - 1$	;  6 = dsc$k_dtype_b
	.WORD	convert_to_w   - 1$	;  7 = dsc$k_dtype_w
	.WORD	convert_to_l   - 1$	;  8 = dsc$k_dtype_l
	.WORD	convert_to_q   - 1$	;  9 = dsc$k_dtype_q
	.WORD	convert_to_f   - 1$	; 10 = dsc$k_dtype_f
	.WORD	convert_to_d   - 1$	; 11 = dsc$k_dtype_d
	CLRL	R0			; Unknown data-type
	RSB				; Return 'failure'

	.SBTTL	Routines to convert to BYTE length

convert_to_b:	CASEB	R3,#dsc$k_dtype_bu,#dsc$k_dtype_d - dsc$k_dtype_bu
1$:	.WORD	c_bubs  - 1$		;  2 = dsc$k_dtype_bu
	.WORD	c_wubs  - 1$		;  3 = dsc$k_dtype_wu
	.WORD	c_lubs  - 1$		;  4 = dsc$k_dtype_lu
	.WORD	c_qubs  - 1$		;  5 = dsc$k_dtype_qu
	.WORD	c_bsbs  - 1$		;  6 = dsc$k_dtype_b
	.WORD	c_wsbs  - 1$		;  7 = dsc$k_dtype_w
	.WORD	c_lsbs  - 1$		;  8 = dsc$k_dtype_l
	.WORD	c_qsbs  - 1$		;  9 = dsc$k_dtype_q
	.WORD	c_fsbs  - 1$		; 10 = dsc$k_dtype_f
	.WORD	c_dsbs  - 1$		; 11 = dsc$k_dtype_d

c_qubs:	TSTL	4(R7)			; Check bits 32:63
	BNEQ	over_b			; Non-zero means error
c_lubs:	TSTW	2(R7)			; Check bits 16:31
	BNEQ	over_b			; Non-zero means error
c_wubs:	TSTB	1(R7)			; Check bits  8:15
	BNEQ	over_b			; Non-zero means error
c_bubs:
c_bsbs:	MOVB	R1,(R6)			; Store 8 bits of value
	RSB				; Return

c_qsbs:	TSTL	4(R7)			; Check bits 32:63
	BEQL	c_lubs			; Branch if all zero
	ASHL	#-31,R1,-(SP)		; Get copy of low-order sign bit
	CMPL	4(R7),(SP)+		; Check for negative values
	BNEQ	over_b			; Overflow if not sign-extended

c_lsbs:	CVTLB	R1,(R6)			; Store 8 bits of value
	BVS	fail_b			; Fail if overflow set
	RSB				; Otherwise return

c_wsbs:	CVTWB	R1,(R6)			; Store 8 bits of value
	BVS	fail_b			; Fail if overflow set
	RSB				; Otherwise return

c_fsbs:
c_dsbs:	CVTFB	R1,(R6)			; Convert from floating
	BVS	fail_b			; Branch if overflow
	RSB

over_b:	MOVB	R1,(R6)			; Copy over bits 0:7
fail_b:	CLRL	R0			; Say value was truncated
	RSB				; And return

	.SBTTL	Routines to convert to WORD length

convert_to_w:	CASEB	R3,#dsc$k_dtype_bu,#dsc$k_dtype_d - dsc$k_dtype_bu
1$:	.WORD	c_buws  - 1$		;  2 = dsc$k_dtype_bu
	.WORD	c_wuws  - 1$		;  3 = dsc$k_dtype_wu
	.WORD	c_luws  - 1$		;  4 = dsc$k_dtype_lu
	.WORD	c_quws  - 1$		;  5 = dsc$k_dtype_qu
	.WORD	c_bsws  - 1$		;  6 = dsc$k_dtype_b
	.WORD	c_wsws  - 1$		;  7 = dsc$k_dtype_w
	.WORD	c_lsws  - 1$		;  8 = dsc$k_dtype_l
	.WORD	c_qsws  - 1$		;  9 = dsc$k_dtype_q
	.WORD	c_fsws  - 1$		; 10 = dsc$k_dtype_f
	.WORD	c_dsws  - 1$		; 11 = dsc$k_dtype_d

c_bsws:	CVTBW	R1,R1			; Sign-extend byte to word
c_buws:
c_wsws:
c_wuws:	MOVW	R1,(R6)			; Store 16 bits of value
	RSB				; Return

c_quws:	TSTL	4(R7)			; Check bits 32:63
	BNEQ	over_w			; Non-zero means error
c_luws:	TSTW	2(R7)			; Check bits 16:31
	BEQL	c_wuws			; O.K. if all bits zero
	BRB	over_w			; Otherwise report error

c_qsws:	ASHL	#-31,R1,-(SP)		; Get copy of low-order sign bit
	CMPL	4(R7),(SP)+		; Check for negative values
	BNEQ	over_w			; Overflow if not sign-extended

c_lsws:	CVTLW	R1,(R6)			; Store 16 bits of value
	BVS	fail_w			; Fail if overflow set
	RSB				; Otherwise return

c_fsws:
c_dsws:	CVTFW	R1,(R6)			; Convert from floating
	BVS	fail_w			; Branch if overflow
	RSB

over_w:	MOVW	R1,(R6)			; Copy over bits 0:15
fail_w:	CLRL	R0			; Say value was truncated
	RSB				; And return

	.SBTTL	Routines to convert to LONG length

convert_to_l:	CASEB	R3,#dsc$k_dtype_bu,#dsc$k_dtype_d - dsc$k_dtype_bu
1$:	.WORD	c_buls  - 1$		;  2 = dsc$k_dtype_bu
	.WORD	c_wuls  - 1$		;  3 = dsc$k_dtype_wu
	.WORD	c_luls  - 1$		;  4 = dsc$k_dtype_lu
	.WORD	c_quls  - 1$		;  5 = dsc$k_dtype_qu
	.WORD	c_bsls  - 1$		;  6 = dsc$k_dtype_b
	.WORD	c_wsls  - 1$		;  7 = dsc$k_dtype_w
	.WORD	c_lsls  - 1$		;  8 = dsc$k_dtype_l
	.WORD	c_qsls  - 1$		;  9 = dsc$k_dtype_q
	.WORD	c_fsls  - 1$		; 10 = dsc$k_dtype_f
	.WORD	c_dsls  - 1$		; 11 = dsc$k_dtype_d

c_bsls:	CVTBW	R1,R1
c_wsls:	CVTWL	R1,R1
c_buls:
c_wuls:
c_luls:
c_lsls:	MOVL	R1,(R6)			; Store 32 bits of value
	RSB				; And return

c_qsls:	ASHL	#-31,R1,-(SP)		; Get copy of low-order sign bit
	CMPL	4(R7),(SP)+		; Check for negative values
	BNEQ	over_l			; Overflow if not sign-extended
	TSTL	R1			; Check magnitude is 31 bits only
	BLSS	over_l			; Overflow if value too large

c_quls:	TSTL	4(R7)			; Check bits 32:63
	BEQL	c_luls			; Branch if all zero

over_l:	MOVL	R1,(R6)			; Copy over bits 0:31
fail_l:	CLRL	R0			; Say value was truncated
	RSB				; And return

c_fsls:	CVTFL	R1,(R6)			; Convert from floating
	BVS	fail_l			; Branch if overflow
	RSB

c_dsls:	CVTDL	R1,(R6)			; Convert from floating
	BVS	fail_l			; Branch if overflow
	RSB

	.SBTTL	Routines to convert to QUAD length

convert_to_q:	CASEB	R3,#dsc$k_dtype_bu,#dsc$k_dtype_d - dsc$k_dtype_bu
1$:	.WORD	c_buqs  - 1$		;  2 = dsc$k_dtype_bu
	.WORD	c_wuqs  - 1$		;  3 = dsc$k_dtype_wu
	.WORD	c_luqs  - 1$		;  4 = dsc$k_dtype_lu
	.WORD	c_quqs  - 1$		;  5 = dsc$k_dtype_qu
	.WORD	c_bsqs  - 1$		;  6 = dsc$k_dtype_b
	.WORD	c_wsqs  - 1$		;  7 = dsc$k_dtype_w
	.WORD	c_lsqs  - 1$		;  8 = dsc$k_dtype_l
	.WORD	c_qsqs  - 1$		;  9 = dsc$k_dtype_q
	.WORD	c_fsqs  - 1$		; 10 = dsc$k_dtype_f
	.WORD	c_dsqs  - 1$		; 11 = dsc$k_dtype_d

c_bsqs:	CVTBW	R1,R1			; Sign-extend to 16 bits
c_wsqs:	CVTWL	R1,R1			; Sign-extend to 32 bits
c_buqs:
c_wuqs:
c_lsqs:	MNEGL	#1,4(R6)		; Assume negative value
	MOVL	R1,(R6)			; Store 32 bits of value
	BGEQ	c_luqs			; Correct sign if positive
	RSB				; Return

c_luqs:	CLRL	4(R6)			; Clear high 32 bits
	MOVL	R1,(R6)			; Store 32 bits of value
	RSB				; Return

c_quqs:
c_qsqs:	MOVQ	(R7),(R6)		; Copy 64 bits of value
	RSB				; Return

c_fsqs:	CLRL	-(SP)			; Clear low-order bits
	MOVF	R1,-(SP)		; Stack floating value
	BRB	c_fdqs			; Join common code
c_dsqs:	MOVD	(R7),-(SP)		; Stack floating value
c_fdqs:	CVTDL	(SP)+,(R6)		; Attempt the conversion
	BVS	fail_q			; Take error return on overflow
	ASHL	#-31,(R6),4(R6)		; Propagate sign to bits 32:63
	RSB				; And return

fail_q:	MOVL	#2,R0			; Say we failed to convert value
	RSB				; And return

	.SBTTL	Routines to convert to floating

convert_to_f:	BSBB	float		; Convert to d_floating in R3'R2
		CVTDF	R2,(R6)		; Store floating value
		BVC	1$		; Branch if no overflow
		MOVF	R2,(R6)		; Overflowed - truncate low order bits
		CLRL	R0		; Set status to "warning"
1$:		RSB			; And return

convert_to_d:	BSBB	float		; Convert to d_floating in R3'R2
		MOVD	R2,(R6)		; Store result of conversion
		RSB			; And return

float:	CASEB	R3,#dsc$k_dtype_bu,#dsc$k_dtype_d - dsc$k_dtype_bu
1$:	.WORD	c_bufd  - 1$		;  2 = dsc$k_dtype_bu
	.WORD	c_wufd  - 1$		;  3 = dsc$k_dtype_wu
	.WORD	c_lufd  - 1$		;  4 = dsc$k_dtype_lu
	.WORD	c_qufd  - 1$		;  5 = dsc$k_dtype_qu
	.WORD	c_bsfd  - 1$		;  6 = dsc$k_dtype_b
	.WORD	c_wsfd  - 1$		;  7 = dsc$k_dtype_w
	.WORD	c_lsfd  - 1$		;  8 = dsc$k_dtype_l
	.WORD	c_qsfd  - 1$		;  9 = dsc$k_dtype_q
	.WORD	c_fsfd  - 1$		; 10 = dsc$k_dtype_f
	.WORD	c_dsfd  - 1$		; 11 = dsc$k_dtype_d

c_bsfd:	CVTBW	R1,R1			; Sign-extend to 16 bits
c_wsfd:	CVTWL	R1,R1			; Sign-extend to 32 bits
c_lsfd:
c_bufd:
c_wufd:	CVTLD	R1,R2			; Convert longword to d_floating
	RSB				; And return

c_lufd:	CVTLD	R1,R2			; Get low 32 bits of fraction
	BGEQ	1$			; Check for appearent negative value
	ADDD2	L^two_to_the_32,R2	; Negative - add in correction of 2^32
1$:	RSB				; All done - return

c_qufd:	MOVQ	(R7),R1			; Load 64-bit value
	BGEQ	c_qxfd			; Check for apparent negative value
	BSBB	c_qxfd			; If "negative", we need to add in
	ADDD2	L^two_to_the_64,R2	;  a correction factor of 2^64
	RSB				; All done - return

c_qsfd:	MOVQ	(R7),R1			; Load 64-bit value
c_qxfd:	CVTLD	R2,-(SP)		; Convert high-order bits to d_floating
	MULD2	L^two_to_the_32,(SP)	; Weight value by factor of 2^32
	BSBB	c_lufd			; Go convert low-order bits
	ADDD2	(SP)+,R2		; Add in high-order bits of result
	RSB				; And return

c_fsfd:	CVTFD	R1,R2			; Convert f_floating to d_floating
	RSB				; And return

c_dsfd:	MOVD	(R7),R2			; Load d_floating value
	RSB				; And return

	.SBTTL	DBG$NCOB_CONVERT_TO_PACKED
;DBG$NCOB_CONVERT_TO_PACKED(source_desc,result_desc,message_vector)

	source_desc	=  4
	result_desc	=  8
	message_vector	= 12

.ENTRY dbg$ncob_convert_to_packed,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	MOVAB	W^local_handler,0(FP)		; Set up exception handler
	MOVAB	L^packed_desc,R6		; Get local descriptor address
	MOVL	source_desc(AP),R7		; Get source descriptor address
	CMPL	R6,R7				; Called with local address ?
	BEQL	src_common			; Yes - everything is set up
	MOVAB	L^digit_string,dsc$a_pointer(R6); Set up address field
	MOVZBL	dsc$b_dtype(R7),R8		; Get data type of item
	CMPB	R8,#dsc$k_dtype_p		; Range-check dtype field
	BGTRU	bad_type			; Immediate error if unknown
	BEQL	src_packed			; Easy if already packed !
	BBS	R8,L^numeric_dtypes,src_numeric	; Branch if integer or floating
	MOVW	dsc$w_length(R7),dsc$w_length(R6);Assume no separate sign char
	CASEB	R8,#dsc$k_dtype_t,#dsc$k_dtype_nz - dsc$k_dtype_t
1$:	.WORD	src_type_t   - 1$	; 14 = dsc$k_dtype_t
	.WORD	src_type_nu  - 1$	; 15 = dsc$k_dtype_nu
	.WORD	src_type_nl  - 1$	; 16 = dsc$k_dtype_nl
	.WORD	src_type_nlo - 1$	; 17 = dsc$k_dtype_nlo
	.WORD	src_type_nr  - 1$	; 18 = dsc$k_dtype_nr
	.WORD	src_type_nro - 1$	; 19 = dsc$k_dtype_nro
	.WORD	src_type_nz  - 1$	; 20 = dsc$k_dtype_nz
bad_type:
	PUSHL	I^#dbg$_unimplent	; Get "unknown type" error code
	PUSHL	message_vector(AP)	; Push address of message vector
	CALLS	#2,G^dbg$nmake_arg_vect	; Format the error message
	MOVL	#sts$k_severe,R0	; Say we had an error
	RET				; And return
src_packed:
	MOVW	dsc$w_length(R7),dsc$w_length(R6);Set up length field
	MOVP	dsc$w_length(R7),@dsc$a_pointer(R7),@dsc$a_pointer(R6)
src_return:
	CLRB	dsc$b_scale(R6)			; Assume no scaling factor
	CMPB	dsc$b_class(R7),#dsc$k_class_sd	; Source a scaled descriptor ?
	BNEQ	src_common			; If not, scale factor is zero
	MOVB	dsc$b_scale(R7),dsc$b_scale(R6)	; Set up correct scale factor
src_common:
	MOVL	R6,@result_desc(AP)		; Store address of result
	CVTWB	dsc$w_length(R6),dsc$b_digits(R6); set up digit-count field
	MOVL	#sts$k_success,R0		; Say everything worked
	RET					; Return to caller

	.SBTTL	Scalar source dtypes

src_numeric:
	CASEB	R8,#dsc$k_dtype_bu,#dsc$k_dtype_d - dsc$k_dtype_bu
1$:	.WORD	src_type_bu  - 1$	;  2 = dsc$k_dtype_bu
	.WORD	src_type_wu  - 1$	;  3 = dsc$k_dtype_wu
	.WORD	src_type_lu  - 1$	;  4 = dsc$k_dtype_lu
	.WORD	src_type_qu  - 1$	;  5 = dsc$k_dtype_qu
	.WORD	src_type_b   - 1$	;  6 = dsc$k_dtype_b
	.WORD	src_type_w   - 1$	;  7 = dsc$k_dtype_w
	.WORD	src_type_l   - 1$	;  8 = dsc$k_dtype_l
	.WORD	src_type_q   - 1$	;  9 = dsc$k_dtype_q
	.WORD	src_type_f   - 1$	; 10 = dsc$k_dtype_f
	.WORD	src_type_d   - 1$	; 11 = dsc$k_dtype_d

src_type_b:	CVTBL	@dsc$a_pointer(R7),R10	; Sign-extend byte to longword
		BRB	src_type_int		; Go join common code
src_type_bu:	MOVZBL	@dsc$a_pointer(R7),R10	; Zero-extend byte to longword
		BRB	src_type_int		; Go join common code
src_type_w:	CVTWL	@dsc$a_pointer(R7),R10	; Sign-extend word to longword
		BRB	src_type_int		; Go join common code
src_type_wu:	MOVZWL	@dsc$a_pointer(R7),R10	; Zero-extend word to longword
		BRB	src_type_int		; Go join common code
src_type_l:	MOVL	@dsc$a_pointer(R7),R10	; Pick up signed longword value

src_type_int:
	MOVZBW	dsc$b_digits(R7),dsc$w_length(R6);Use supplied digit-count
	BNEQ	2$				; (unless given as zero)
1$:	MULW3	dsc$w_length(R7),#12,R0		; Convert from number of bytes
	DIVW3	#5,R0,dsc$w_length(R6)		;  to number of decimal digits
	INCW	dsc$w_length(R6)		;  needed to hold actual value
2$:	CVTLP	R10,dsc$w_length(R6),@dsc$a_pointer(R6)	; Perform conversion
	BVS	3$				; Handle decimal overflow
	BRW	src_return			; Go join common cleanup code
3$:	PUSHL	I^#dbg$_valoutbnds		; Get error code 
	CALLS	#1,G^lib$signal			; Report the error
	BRB	1$				; Convert using maximum length

src_type_lu:	MOVL	@dsc$a_pointer(R7),R10	; Get unsigned longword value
		BGEQ	src_type_int		; Easy if non-negative !
		CLRL	R11			; Convert from long to quadword
		BRB	src_type_quad		; Go convert to packed

src_type_q:	MOVQ	@dsc$a_pointer(R7),R10	; Get signed quadword value
		BGEQ	src_type_quad		; Easy if non-negative !
		MCOML	R11,R11			; Complement high-order bits
		MNEGL	R10,R10			;  and negate low-order bits
		BNEQ	src_type_quad		; All done if non-zero low bits
		INCL	R11			; Propagate carry to high bits
		BRB	src_type_quad		; (don't worry about -<2^63>)

src_type_qu:	MOVQ	@dsc$a_pointer(R7),R10	; Get unsigned quadword value

src_type_quad:
	MOVAB	-12(SP),SP			; Reserve temporary work-space
	BSBB	extract_digits			; Go extract low nine digits
	MOVL	R0,R8				; Save low nine decimal digits
	BSBB	extract_digits			; Extract next 8 digits and "0"
	MOVL	R0,R9				; Preserve value over "CVTLP"
	CVTLP	R10,#4,(SP)			; Insert first 3 decimal digits
	CVTLP	R9,#9,2(SP)			;  Append next 8 decimal digits
	CVTLP	R8,#9,6(SP)			;  Append last 9 decimal digits
	CMPB	dsc$b_dtype(R7),#dsc$k_dtype_q	; Signed quadword wanted ?
	BNEQ	1$				; No  - unsigned means positive
	ADDL3	#4,dsc$a_pointer(R7),-(SP)	; Yes - get address of sign bit
	TSTL	@(SP)+				; Was original value negative ?
	BGEQ	1$				; No  - sign is correct
	INCB	10(SP)				; Yes - change sign nibble
1$:	MOVZBW	dsc$b_digits(R7),dsc$w_length(R6);Use supplied digit-count
	BNEQ	3$				; (unless given as zero)
2$:	MULW3	dsc$w_length(R7),#12,R0		; Convert from number of bytes
	DIVW3	#5,R0,dsc$w_length(R6)		;  to number of decimal digits
	INCW	dsc$w_length(R6)		;  needed to hold actual value
3$:	CLRL	R0				; Assume zero scaling factor
	MOVAB	L^fixed_desc,-(SP)		; Get address of fixed descriptor
	CMPL	(SP)+,R7			; Converting floating value ?
	BNEQ	4$				; No  - just copy value
	ADDB3	#18,dsc$b_scale(R7),R1		; Yes - check for too many digits
	BGEQ	4$				; Valid length - carry on
	MNEGB	#18,dsc$b_scale(R7)		; Too long - truncate value
	CVTBL	R1,R0				; Get adjustment into R0
4$:	ASHP	R0,#20,(SP),#0,dsc$w_length(R6),@dsc$a_pointer(R6)
	BVS	5$				; Branch if overflow set
	MOVAB	12(SP),SP			; Otherwise  reclaim work space
	BRW	src_return			;  and join common exit code
5$:	PUSHL	I^#dbg$_valoutbnds		; Get error code 
	CALLS	#1,G^lib$signal			; Report the error
	BRB	2$				; Convert using maximum length

extract_digits:
	CLRL	R3				; Initialize high quotient
	MOVL	R11,R2				; Is dividend "negative" ?
	BLSS	1$				; Yes - simultate division
	EDIV	#1000000000,R10,R2,R0		; No  - try to do the division
	BVC	2$				; Branch if no overflow
	MOVL	R11,R2				; Otherwise do division in stages
1$:	EDIV	#1000000000,R2,R3,R1		; Get first 'digit' of quotient
	MOVL	R10,R0				; Get low 32 bits into R0
	EDIV	#2000000000,R0,R2,R0		; Get next 31 bits into R2
	ASHL	#1,R2,R2			; Shift up to correct position
	SUBL3	#1000000000,R0,R1		; Check for final quotient bit
	BLSS	2$				; Should be 0 - all is well
	INCL	R2				; Should be 1 - increment value
	MOVL	R1,R0				; Get correct remainder into R0
2$:	TSTL	R2				; Do low bits appear negative ?
	BGEQ	3$				; No  - values are correct
	INCL	R3				; Yes - add in bias of <2^32>
3$:	MULL3	R3,#10,R1			; Get high word of 10*quotient
	EMUL	R2,#10,#0,R10			;  and low word of 10*quotient
	ADDL2	R1,R11				; Add in final correction
	RSB					; And return

src_type_f:	MOVL	#7,R8			; Get number of digits
		CVTFD	@dsc$a_pointer(R7),R10	; Get floating value
		BRB	src_type_floating	; Join common code

src_type_d:	MOVL	#16,R8			; Get number of digits
		MOVD	@dsc$a_pointer(R7),R10	; Get floating value

src_type_floating:
	MOVAB	L^fixed_desc,R7			; Get address of descriptor
	MOVAQ	L^fixed_value,dsc$a_pointer(R7)	; Store address of value
	ASHL	#8,R8,dsc$b_scale(R7)		; Set up scale & digit count
	MOVW	R10,R9				; Save copy of original sign
	MOVQ	R10,R0				; Get value into R1'R0
	BEQL	3$				; Branch if value is zero
	BICW2	#^X8000,R0			; Get absolute magnitude
	PUSHR	#^M<R6,R7,R8>			; Save addresses & sign word
	JSB	G^MTH$DLOG10_R8			; Get scaling factor needed
	POPR	#^M<R6,R7,R8>			; Restore contents of R6-R8
	EMODD	R0,#0,#^F1.0,R2,R0		; Split off int & fract parts
	BLSS	1$				; Branch if fraction negative
	INCL	R2				; Force rounding upwards
1$:	SUBL3	R2,R8,-(SP)			; Get scaling factor wanted
	MNEGB	(SP),dsc$b_scale(R7)		; Save scale in descriptor
	MOVD	#^F10.0,-(SP)			; Say we want power of ten
	CALLS	#3,G^OTS$POWDJ			; Get power of ten for scaling
	MULD3	R10,R0,R2			; Get scaled value of number
	BICW2	#^X8000,R2			; Get absolute magnitude
	PUSHL	R8				; Get number of sig. figs.
	MOVD	#^F10.0,-(SP)			; Say we want power of ten
	CALLS	#3,G^OTS$POWDJ			; Get upper bound for value
	SUBD2	#^F0.5,R0			; Allow for final rounding
	CMPD	R2,R0				; Is value within range ?
	BLSS	2$				; Yes - scale factor is correct
	DIVD2	#^F10.0,R2			; No  - divide value by ten
	INCB	dsc$b_scale(R7)			;  and adjust scale factor
2$:	ADDD2	L^fudge_factor,R2		; "CVTDQ" (floating format)
	BICW2	#^X7F00,R2			; Clear exponent field
	ROTL	#16,R3,R10			; Shuffle low-order bits
	ROTL	#16,R2,R11			;  and high-order bits
3$:	MOVZBL	#dsc$k_dtype_q,R8		; Change type to quadword
	MOVQ	R10,@dsc$a_pointer(R7)		; Store fixed-point value
	TSTW	R9				; Test original sign
	BGEQ	4$				; Was original value negative ?
	ADDL3	#4,dsc$a_pointer(R7),R9		; Yes - get high word address
	MCOML	R11,(R9)			; Complement high-order bits
	MNEGL	R10,-(R9)			;  and negate low-order bits
	BNEQ	4$				; Branch if value non-zero
	INCL	4(R9)				; Otherwise propagate carry
4$:	BRW	src_type_quad			; Go convert from quadword

	.SBTTL	Source dtypes nl, nr & nlo

src_type_nl:
	DECW	dsc$w_length(R6)		; Don't count sign in length
	CVTSP	dsc$w_length(R6),@dsc$a_pointer(R7),-
		dsc$w_length(R6),@dsc$a_pointer(R6)
	BRW	src_return

src_type_nr:
	DECW	dsc$w_length(R6)		; Don't count sign in length
	CVTTP	dsc$w_length(R6),@dsc$a_pointer(R7),W^src_nu_table,-
		dsc$w_length(R6),@dsc$a_pointer(R6)
	BNEQ	1$				; Branch if non-zero result
	INCL	R0				; Get 'zero' flag into R0
1$:	MOVZWL	dsc$w_length(R6),R1		; Get number of actual digits
	ADDL2	dsc$a_pointer(R7),R1		; Get address of trailing sign
	MOVZBL	(R1),R1				; Get actual sign character
	BICB2	#^X80,R1			; Mask to just seven bits
	CMPB	R1,#^A" "			; Check that actual sign
	BEQL	2$				;  character is either
	CMPB	R1,#^A"+"			;  ASCII " " or "+" for
	BEQL	2$				;  a positive number, or
	CMPB	R1,#^A"-"			;  ASCII "-" for negative
	BNEQ	reserved_operand		; Report bad sign character
	BLBS	R0,2$				; Don't change '+0' to '-0'
	DIVB3	#2,dsc$w_length(R6),R0		; Get (longword) length
	ADDL2	dsc$a_pointer(R6),R0		; Get address of sign byte
	INCB	(R0)				; Change sign from 'C' to 'D'
2$:	BRW	src_return			; Go perform exit cleanup

src_type_nlo:
	SUBW3	#1,dsc$w_length(R6),R0		; Get number of normal digits
	BLEQ	src_type_nro			; Easy if short string !
	CMPW	R0,#30				; Valid number of digits ?
	BGTR	reserved_operand		; Illegal length !
	MOVL	dsc$a_pointer(R7),R1		; Get address of source string
	MOVAB	-32(SP),SP			; Get temporary working space
	MOVZBL	(R1)+,R2			; Get first byte of string
	MOVZBL	B^src_nro_table[R2],R3		; Get translation for byte
	BEQL	reserved_operand		; Report bad sign code
	BICB3	#^XF0,R3,R2			; Get sign code into R2
	MOVB	L^sign_codes-12[R2],(SP)	; Insert actual sign character
	ASHL	#-4,R3,R2			; Get high nibble (digit)
	ADDB3	#^A"0",R2,1(SP)			; Insert ASCII code for digit
	MOVC3	R0,(R1),2(SP)			; Copy over remaining digits
	CVTSP	dsc$w_length(R6),(SP),dsc$w_length(R6),@dsc$a_pointer(R6)
	MOVAB	32(SP),SP			; Release working space
	BRW	src_return			; Join common code
reserved_operand:
	PUSHL	I^#ss$_roprand			; Get "reserved operand" code
	CALLS	#1,G^lib$stop			; Signal the error

	.SBTTL	Source dtype dsc$k_type_nro

src_type_nro:
	CVTTP	dsc$w_length(R7),@dsc$a_pointer(R7),B^src_nro_table,-
		dsc$w_length(R6),@dsc$a_pointer(R6)
	BRW	src_return

src_nro_table:	;0/8  1/9  2/A  3/B  4/C  5/D  6/E  7/F
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 00 - 07
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 08 - 0F
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 10 - 17
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 18 - 1F
	.BYTE	.__.,^X0D,.__.,.__.,.__.,.__.,.__.,.__.		; 20 - 27
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 28 - 2F
	.BYTE	^X0C,^X1C,^X2C,^X3C,^X4C,^X5C,^X6C,^X7C		; 30 - 37
	.BYTE	^X8C,^X9C,^X0D,.__.,.__.,.__.,.__.,^X0C		; 38 - 3F
	.BYTE	.__.,^X1C,^X2C,^X3C,^X4C,^X5C,^X6C,^X7C		; 40 - 47
	.BYTE	^X8C,^X9C,^X1D,^X2D,^X3D,^X4D,^X5D,^X6D		; 48 - 4F
	.BYTE	^X7D,^X8D,^X9D,.__.,.__.,.__.,.__.,.__.		; 50 - 57
	.BYTE	.__.,.__.,.__.,^X0C,.__.,^X0D,.__.,.__.		; 58 - 5F
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 60 - 67
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 68 - 6F
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 70 - 77
	.BYTE	.__.,.__.,.__.,^X0C,.__.,^X0D,.__.,.__.		; 78 - 7F
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 80 - 87
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 88 - 8F
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 90 - 97
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 98 - 9F
	.BYTE	.__.,^X0D,.__.,.__.,.__.,.__.,.__.,.__.		; A0 - A7
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; A8 - AF
	.BYTE	^X0C,^X1C,^X2C,^X3C,^X4C,^X5C,^X6C,^X7C		; B0 - B7
	.BYTE	^X8C,^X9C,^X0D,.__.,.__.,.__.,.__.,^X0C		; B8 - BF
	.BYTE	.__.,^X1C,^X2C,^X3C,^X4C,^X5C,^X6C,^X7C		; C0 - C7
	.BYTE	^X8C,^X9C,^X1D,^X2D,^X3D,^X4D,^X5D,^X6D		; C8 - CF
	.BYTE	^X7D,^X8D,^X9D,.__.,.__.,.__.,.__.,.__.		; D0 - D7
	.BYTE	.__.,.__.,.__.,^X0C,.__.,^X0D,.__.,.__.		; D8 - DF
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; E0 - E7
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; E8 - EF
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; F0 - F7
	.BYTE	.__.,.__.,.__.,^X0C,.__.,^X0D,.__.,.__.		; F8 - FF

	.SBTTL	Source dtype dsc$k_type_nu

src_type_nu:
	CVTTP	dsc$w_length(R7),@dsc$a_pointer(R7),B^src_nu_table,-
		dsc$w_length(R6),@dsc$a_pointer(R6)
	BRW	src_return

src_nu_table:	;0/8  1/9  2/A  3/B  4/C  5/D  6/E  7/F
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 00 - 07
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 08 - 0F
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 10 - 17
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 18 - 1F
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 20 - 27
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 28 - 2F
	.BYTE	^X0C,^X1C,^X2C,^X3C,^X4C,^X5C,^X6C,^X7C		; 30 - 37
	.BYTE	^X8C,^X9C,.__.,.__.,.__.,.__.,.__.,.__.		; 38 - 3F
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 40 - 47
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 48 - 4F
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 50 - 57
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 58 - 5F
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 60 - 67
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 68 - 6F
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 70 - 77
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 78 - 7F
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 80 - 87
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 88 - 8F
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 90 - 97
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 98 - 9F
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; A0 - A7
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; A8 - AF
	.BYTE	^X0C,^X1C,^X2C,^X3C,^X4C,^X5C,^X6C,^X7C		; B0 - B7
	.BYTE	^X8C,^X9C,.__.,.__.,.__.,.__.,.__.,.__.		; B8 - BF
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; C0 - C7
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; C8 - CF
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; D0 - D7
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; D8 - DF
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; E0 - E7
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; E8 - EF
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; F0 - F7
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; F8 - FF

	.SBTTL	Source dtype dsc$k_type_nz

src_type_nz:
	CVTTP	dsc$w_length(R7),@dsc$a_pointer(R7),B^src_nz_table,-
		dsc$w_length(R6),@dsc$a_pointer(R6)
	BRW	src_return

src_nz_table:	;0/8  1/9  2/A  3/B  4/C  5/D  6/E  7/F
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 00 - 07
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 08 - 0F
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 10 - 17
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 18 - 1F
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 20 - 27
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 28 - 2F
	.BYTE	^X0C,^X1C,^X2C,^X3C,^X4C,^X5C,^X6C,^X7C		; 30 - 37
	.BYTE	^X8C,^X9C,.__.,.__.,.__.,.__.,.__.,.__.		; 38 - 3F
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 40 - 47
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 48 - 4F
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 50 - 57
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 58 - 5F
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 60 - 67
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 68 - 6F
	.BYTE	^X0D,^X1D,^X2D,^X3D,^X4D,^X5D,^X6D,^X7D		; 70 - 77
	.BYTE	^X8D,^X9D,.__.,.__.,.__.,.__.,.__.,.__.		; 78 - 7F
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 80 - 87
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 88 - 8F
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 90 - 97
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; 98 - 9F
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; A0 - A7
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; A8 - AF
	.BYTE	^X0C,^X1C,^X2C,^X3C,^X4C,^X5C,^X6C,^X7C		; B0 - B7
	.BYTE	^X8C,^X9C,.__.,.__.,.__.,.__.,.__.,.__.		; B8 - BF
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; C0 - C7
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; C8 - CF
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; D0 - D7
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; D8 - DF
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; E0 - E7
	.BYTE	.__.,.__.,.__.,.__.,.__.,.__.,.__.,.__.		; E8 - EF
	.BYTE	^X0D,^X1D,^X2D,^X3D,^X4D,^X5D,^X6D,^X7D		; F0 - F7
	.BYTE	^X8D,^X9D,.__.,.__.,.__.,.__.,.__.,.__.		; F8 - FF

	.SBTTL	source dtype dsc$k_dtype_t
;
;	We get here to convert a text string to a numeric value.
;	The text string is either a COBOL variable (or a substring
;	thereof) or an explicit ASCII string (input within quotes)
;	or a digit-string (hex,dec, or oct) whose value exceeds 32
;	bits or which has a decimal point.
;	We can differentiate between the three input types as follows :-
;
;	dsc$b_class contains dsc$k_dtype_sd for COBOL variables
;
;	dsc$b_class contains dsc$k_dtype_s  for quoted strings
;
;	dsc$b_class contains dsc$k_dtype_d  for unquoted strings
;
src_type_t:
	MOVL	dsc$a_pointer(R7),R9		; Get address of actual text
	MOVZWL	dsc$w_length(R7),R8		; Get number of chars
	BEQL	1$				; Easy if zero length !
	LOCC	#^A".",R8,(R9)			; Check for decimal point
	BEQL	2$				; Branch if not found
	SUBW3	#1,R8,dsc$w_length(R6)		; Set up length of string
	SUBW3	R0,#1,dsc$b_scale(R6)		;  and scaling factor
	SUBL	R8,SP				; Get temporary work space
	SUBL3	R0,R8,R0			; Get leading digit count
	MOVC3	R0,(R9),(SP)			; Copy over leading digits
	MNEGW	dsc$b_scale(R6),R0		; Get trailing digit count
	MOVC3	R0,1(R1),(R3)			; Copy over trailing digits
1$:	CVTTP	dsc$w_length(R6),(SP),W^src_nu_table,-
		dsc$w_length(R6),@dsc$a_pointer(R6)
	BRW	src_common			; Go do common exit code

2$:	CALLS	#0,L^dbg$nget_radix		; Get current radix
	PUSHL	R0				; Stack returned radix_code
	CALLS	#1,L^dbg$nget_trans_radix	; Translate to actual value
	CMPB	dsc$b_class(R7),#dsc$k_class_d	; Unquoted digit string ?
	BNEQ	4$				; No - no radix select allowed
	CMPB	(R9),#^A"^"			; Radix select operator ?
	BNEQ	4$				; No
	INCL	R9				; Yes - step over "^"
	SUBL	#2,R8				; Count length down
	BLEQ	3$				; Error if no digits !
	BICB3	#^XA0,(R9)+,R1			; Get actual selector char
	MOVL	#16,R0				; Assume radix hexadecimal
	CMPB	#^A"X",R1			; ^Xnnnnn ?
	BEQL	6$				; Yes
	MOVL	#8,R0				; Assume radix octal
	CMPB	#^A"O",R1			; ^Onnnnn ?
	BEQL	6$				; Yes
;	MOVL	#10,R0				; Assume radix decimal
	CMPB	#^A"D",R1			; ^Dnnnnn ?
	BEQL	5$				; Yes
3$:	PUSHL	R7				; Bad string - push descriptor
	PUSHL	#1				; Stack FAO argument count
	PUSHL	I^#dbg$_invnumber		; Stack DEBUG error code
	PUSHL	message_vector(AP)		; Stack msg vector address
	CALLS	#4,L^dbg$nmake_arg_vect		; Format error message
	MOVL	#sts$k_severe,R0		; Get error code
	RET					; And return
4$:	CMPB	#10,R0				; Is radix decimal ?
	BNEQ	6$				; No  - need to set up bits
5$:	CVTTP	R8,(R9),W^src_nu_table,R8,@dsc$a_pointer(R6) ; Convert digits
	MOVW	R8,dsc$w_length(R6)		; Store actual length of string
	BRW	src_return			; Go perform common exit
6$:	CLRQ	R10				; Reserve space for number
	FFS	#0,#32,R0,R3			; Get shift count
7$:	MOVZBL	(R9)+,R0			; Get next ASCII character
	CLRL	R2				; Initialize index (digit)
	BITB	#^X40,R0			; Alphabetic character ?
	BEQL	8$				; No  - assume numeric for now
	BICB	#^X20,R0			; Yes - force to upper case
8$:	CMPB	L^valid_digits[R2],R0		; Is this a known digit ?
	BEQL	9$				; Carry on if O.K.
	AOBLSS	R1,R2,8$			; Loop for all known digits
	BRB	3$				; Report invalid character
9$:	ASHQ	R3,R10,R10			; Shift up old value
	ADDL	R2,R10				; Insert low-order bits
	SOBGTR	R8,7$				; Loop for all digits
	MOVAB	L^shift_desc,R7			; Get local descriptor
	MOVAB	L^fixed_value,dsc$a_pointer(R7)	; Set up pointer to value
	MOVQ	R10,@dsc$a_pointer(R7)		; Store full 64-bit value
	BRW	src_type_quad			; Go convert to packed

	.SBTTL	DBG$NCOB_CONVERT_FROM_PACKED
;DBG$NCOB_CONVERT_FROM_PACKED(source_desc,result_desc,message_vector)

	source_desc	=  4
	result_desc	=  8
	message_vector	= 12

.ENTRY	dbg$ncob_convert_from_packed,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	MOVL	result_desc(AP),R6		; Get destination descriptor
	MOVZBL	dsc$b_dtype(R6),R7		; Get type of destination
	CMPL	R7,#dsc$k_dtype_f		; If this is a floating-point
	BLSS	1$				; data type (either single or
	CMPL	R7,#dsc$k_dtype_d		; double precision) extract
	BGTR	1$				; 18 digits, but keep current
	MOVL	source_desc(AP),R9		; scale factor for now.
	CVTBL	dsc$b_scale(R9),R9		; Pick up current scale factor
	BRB	3$				; Go pick up length code
1$:	CLRQ	R8				; Initialize count & scale
	CMPB	dsc$b_class(R6),#dsc$k_class_sd	; Scaled descriptor ?
	BNEQ	2$				; No
	CVTBL	dsc$b_scale(R6),R9		; Yes - get scaling factor
	MOVZBL	dsc$b_digits(R6),R8		; Get number of digits
	BNEQ	4$				; O.K. if explicitly given
2$:	CMPL	R7,#dsc$k_dtype_p		; Check range of dtype
	BGTR	bad_dest			; Error if out of range
3$:	CVTBL	L^default_length[R7],R8		; Get default precision
	BEQL	bad_dest			; Error if no default length
	BGTR	4$				; O.K. if explicitly stated
	CVTWL	dsc$w_length(R6),R8		; Otherwise get length field
	CMPL	R7,#dsc$k_dtype_nr		; For unsigned, overpunched
	BGTR	4$				;  and zoned numbers, digit
	BLBS	R7,4$				;  count equals length. For
	DECL	R8				;  others, adjust for sign.
4$:	MOVL	source_desc(AP),R2		; Get source descriptor
	SUBB3	R9,dsc$b_scale(R2),R3		; Get change of scale needed
	SUBL	#16,SP				; Reserve space for number
	CLRL	R10				; Assume no overflow
	ASHP	R3,dsc$w_length(R2),@dsc$a_pointer(R2),#0,R8,(SP)
	BVC	5$				; O.K. if no overflow
	BISL2	#1,R10				; Flag overflow occurred
5$:	BBS	R7,L^signed_dtypes,6$		; O.K. if signed destination
	ASHL	#-1,R8,R0			; Get # of bytes to skip
	ADDL2	SP,R0				; Get address of sign byte
	CMPZV	#0,#4,(R0),#13			; Check for minus sign
	BNEQ	6$				; O.K. if value is positive
	DECB	(R0)				; Otherwise change sign
	BISL2	#1,R10				; And remember we had an error

6$:	CASEB	R7,#dsc$k_dtype_bu,#dsc$k_dtype_p - dsc$k_dtype_bu
7$:	.WORD	dst_type_bu  - 7$	;  2 = dsc$k_dtype_bu
	.WORD	dst_type_wu  - 7$	;  3 = dsc$k_dtype_wu
	.WORD	dst_type_lu  - 7$	;  4 = dsc$k_dtype_lu
	.WORD	dst_type_qu  - 7$	;  5 = dsc$k_dtype_qu
	.WORD	dst_type_b   - 7$	;  6 = dsc$k_dtype_b
	.WORD	dst_type_w   - 7$	;  7 = dsc$k_dtype_w
	.WORD	dst_type_l   - 7$	;  8 = dsc$k_dtype_l
	.WORD	dst_type_q   - 7$	;  9 = dsc$k_dtype_q
	.WORD	dst_type_f   - 7$	; 10 = dsc$k_dtype_f
	.WORD	dst_type_d   - 7$	; 11 = dsc$k_dtype_d
	.WORD	bad_dest     - 7$	; 12 = dsc$k_dtype_fc
	.WORD	bad_dest     - 7$	; 13 = dsc$k_dtype_dc
	.WORD	bad_dest     - 7$	; 14 = dsc$k_dtype_t
	.WORD	dst_type_nu  - 7$	; 15 = dsc$k_dtype_nu
	.WORD	dst_type_nl  - 7$	; 16 = dsc$k_dtype_nl
	.WORD	dst_type_nlo - 7$	; 17 = dsc$k_dtype_nlo
	.WORD	dst_type_nr  - 7$	; 18 = dsc$k_dtype_nr
	.WORD	dst_type_nro - 7$	; 19 = dsc$k_dtype_nro
	.WORD	dst_type_nz  - 7$	; 20 = dsc$k_dtype_nz
	.WORD	dst_type_p   - 7$	; 21 = dsc$k_dtype_p
bad_dest:
	PUSHL	I^#dbg$_unimplent		; Get "unknown type" error code
	PUSHL	message_vector(AP)		; Push address of message vector
	CALLS	#2,G^dbg$nmake_arg_vect		; Format the error message
	MOVL	#sts$k_severe,R0		; Say we had an error
	RET					; And return

	.SBTTL	Destination BYTE, WORD or LONG

dst_type_b:
dst_type_bu:
	CVTPL	R8,(SP),R0			; Get longword value
	BVC	1$				; Check for overflow condition
	BISL2	#1,R10				; Remember if overflow occurred
1$:	CVTLB	R0,@dsc$a_pointer(R6)		; Convert to byte value
	BRB	dst_check			; Check overflow and return

dst_type_w:
dst_type_wu:
	CVTPL	R8,(SP),R0			; Get longword value
	BVC	1$				; Check for overflow condition
	BISL2	#1,R10				; Remember if overflow occurred
1$:	CVTLW	R0,@dsc$a_pointer(R6)		; Convert to word value
	BRB	dst_check			; Check overflow and return

dst_type_l:
dst_type_lu:
	CVTPL	R8,(SP),@dsc$a_pointer(R6)	; Get longword value
;	BRB	dst_check			; Check overflow and return

dst_check:
	BVC	dst_return			; Check for overflow
	BISL2	#1,R10				; Say overflow occurred
dst_return:
	BLBC	R10,1$				; Check for overflow
	PUSHL	I^#dbg$_valoutbnds		; Get "out-of-bounds" error code
	CALLS	#1,G^lib$signal			; Signal condition
1$:	MOVL	#sts$k_success,R0		; Set completion code
	RET					; And return

	.SBTTL	Destination QUAD or FLOATING

dst_type_q:
dst_type_f:
dst_type_d:
	ASHL	#-1,R8,R0			; Get # of bytes to skip
	ADDL2	SP,R0				; Get address of sign byte
	CMPZV	#0,#4,(R0),#13			; Check for minus sign
	BNEQ	dst_type_qu			; O.K. if value is positive
	DECB	(R0)				; Otherwise change sign
	BISL2	#2,R10				; And remember we did this
dst_type_qu:
	SUBL	#16,SP				; Get more temp. workspace
	DIVP	#10,L^packed_factor,R8,16(SP),#10,(SP); Split into longwords
	CVTPL	#10,(SP),R11			; Get high-order 32 bits
	BVC	1$				; Check for overflow condition
	BISL2	#1,R10				; Remember if overflow occurred
1$:	MULP	#10,(SP),#10,L^packed_factor,#18,6(SP); Get part accounted for
	SUBP4	#18,6(SP),R8,16(SP)		; Get 'remainder' of division
	CVTPL	R8,16(SP),R4			; Convert to binary value
	MOVL	R11,R5				; Get high bits back again
	ADDL	#16,SP				; Reclaim workspace
	CASEB	R7,#dsc$k_dtype_q,#dsc$k_dtype_d - dsc$k_dtype_q
2$:	.WORD	3$ - 2$		;  9 = dsc$k_dtype_q
	.WORD	5$ - 2$		; 10 = dsc$k_dtype_f
	.WORD	5$ - 2$		; 11 = dsc$k_dtype_d
	BRW	4$		;  5 = dsc$k_dtype_qu
3$:	BBCC	#1,R10,4$			; Check for negative values
	MCOML	R5,R5				; Complement high-order bits
	MNEGL	R4,R4				; Negate low-order bits
	BNEQ	4$				; Check for all low bits zero
	INCL	R5				; Change Complement to Negate
4$:	MOVQ	R4,@dsc$a_pointer(R6)		; Store binary value
	BRW	dst_return			; And return

5$:	EXTZV	#23,#9,R5,R0			; Get 'exponent' field
	BEQL	7$				; Easy if 'small' value !
	MOVL	#9,R1				; Set up loop index
6$:	DECL	R1				; Count index down by one
	BBC	R1,R0,6$			; Look for 'highest' bit
	MCOML	R1,R0				; Get shift value
	ASHQ	R0,R4,R4			; Normalize number
7$:	ROTL	#16,R4,R3			; Get bits into correct
	ROTL	#16,R5,R2			; floating-point format
	SUBW3	R0,#^XB8,R0			; Get value for exponent
	INSV	R0,#7,#9,R2			; Store exponent field
	BICL3	#^XFFFF807F,R2,R4		; Get just the exponent
	CLRL	R5				;  with all fraction 0
	SUBD2	R4,R2				; Get double-precision value
	BEQL	9$				; Zero is always positive !
	BBCC	#1,R10,8$			; Check for negative values
	BISW2	#^X8000,R2			; Set floating sign bit
8$:	PUSHL	R9				; Stack scaling exponent
	MOVD	#^F10.0,-(SP)			; Say we want power of ten
	CALLS	#3,G^OTS$POWDJ			; Get scale factor
	MULD2	R0,R2				; Get final result value
9$:	CMPB	R7,#dsc$k_dtype_f		; Single or double precision ?
	BEQL	10$				; Handle each separately
	MOVD	R2,@dsc$a_pointer(R6)		; Store D.P. value
	BRW	dst_return			; Perform common ending
10$:	MOVF	R2,@dsc$a_pointer(R6)		; Store S.P. value
	BRW	dst_return			; Perform common ending

	.SBTTL	Numeric String destination types

dst_type_p:
	MOVP	R8,(SP),@dsc$a_pointer(R6)	; Copy over the number
	BRW	dst_return			; Perform common ending

dst_type_nu:
	CVTPT	R8,(SP),W^dst_nu_table,R8,@dsc$a_pointer(R6)
	BRW	dst_return			; Perform common ending

dst_type_nl:
	CVTPS	R8,(SP),R8,@dsc$a_pointer(R6)
	BRW	dst_return			; Perform common ending

dst_type_nlo:
	CMPL	R8,#1				; Less than two digits ?
	BLEQ	dst_type_nro			; Yes - handle directly
	MOVAB	W^dst_nro_table-^X300+^XC,R11	; Get address of overpunches
	CVTPT	R8,(SP),W^dst_nx_table,R8,@dsc$a_pointer(R6)
	BGEQ	1$				; Was number positive ?
	INCL	R11				; No  - get correct column
1$:	MOVZBL	(R3),R0				; Get current leading digit
	MULL2	#16,R0				; Get offset to start of row
	MOVB	(R11)[R0],(R3)			; Replace with overpunch
	BRW	dst_return			; Perform common ending

dst_type_nr:
	MOVB	#^A"+",R11			; Get positive sign
	CVTPT	R8,(SP),W^dst_nx_table,R8,@dsc$a_pointer(R6)
	BGEQ	1$				; Was number positive ?
	MOVB	#^A"-",R11			; No  - get negative sign
1$:	MOVB	R11,@dsc$a_pointer(R6)[R8]	; Store trailing sign
	BRW	dst_return			; Perform common ending

dst_type_nro:
	CVTPT	R8,(SP),W^dst_nro_table,R8,@dsc$a_pointer(R6)
	BRW	dst_return			; Perform common ending

dst_type_nz:
	CVTPT	R8,(SP),W^dst_nz_table,R8,@dsc$a_pointer(R6)
	BRW	dst_return			; Perform common ending


dst_table:
	.BYTE	^A'0',0,0,0,^A'0',^A'0',0,0,^A'{',^A'}',0,0,^A'0',^A'0'+40,0,0
	.BYTE	^A'1',0,0,0,^A'1',^A'1',0,0,^A'A',^A'J',0,0,^A'1',^A'1'+40,0,0
	.BYTE	^A'2',0,0,0,^A'2',^A'2',0,0,^A'B',^A'K',0,0,^A'2',^A'2'+40,0,0
	.BYTE	^A'3',0,0,0,^A'3',^A'3',0,0,^A'C',^A'L',0,0,^A'3',^A'3'+40,0,0
	.BYTE	^A'4',0,0,0,^A'4',^A'4',0,0,^A'D',^A'M',0,0,^A'4',^A'4'+40,0,0
	.BYTE	^A'5',0,0,0,^A'5',^A'5',0,0,^A'E',^A'N',0,0,^A'5',^A'5'+40,0,0
	.BYTE	^A'6',0,0,0,^A'6',^A'6',0,0,^A'F',^A'O',0,0,^A'6',^A'6'+40,0,0
	.BYTE	^A'7',0,0,0,^A'7',^A'7',0,0,^A'G',^A'P',0,0,^A'7',^A'7'+40,0,0
	.BYTE	^A'8',0,0,0,^A'8',^A'8',0,0,^A'H',^A'Q',0,0,^A'8',^A'8'+40,0,0
	.BYTE	^A'9',0,0,0,^A'9',^A'9',0,0,^A'I',^A'R',0,0,^A'9',^A'9'+40,0,0

	dst_nu_table  = dst_table - 12
	dst_nx_table  = dst_table -  8
	dst_nro_table = dst_table -  4
	dst_nz_table  = dst_table -  0

	.SBTTL	DBG$NCOB_EVALUATE - Arithmetic Routines
;DBG$NCOB_EVALUATE(v1_desc,v2_desc,operator)

	v1_desc = 4
	v2_desc = 8
	operator = 12

	l_op_desc = -12
	r_op_desc = -24

.ENTRY	dbg$ncob_evaluate,^M<R2,R3,R4,R5,R6,R7,R8,R9>

	MOVAB	W^local_handler,0(FP)		; Set up exception handler
	MOVAB	-72(SP),SP			; Reserve work-space on stack
	PUSHL	#0				; Reserve space for result
	PUSHAL	(SP)				; Stack 'message vector' address
	PUSHAL	4(SP)				; Stack pointer to result
	ADDL3	#value_vmsdesc,v1_desc(AP),-(SP); Get address of L.H. arg
	CALLS	#3,W^dbg$ncob_convert_to_packed	; Convert to packed decimal
	BLBC	R0,internal_error		; Report any errors seen
	CALLS	#0,normalize_decimal_value	; Normalize result
	MOVAB	l_op_desc(FP),R6		; Get new descriptor address
	MOVC3	#10,@(SP)+,(R6)			; Copy over 1st descriptor
	MOVP	dsc$w_length(R6),@dsc$a_pointer(R6),32(SP)	;and value
	MOVAB	32(SP),dsc$a_pointer(R6)	;  & set up pointer to value
	PUSHL	#0				; Reserve space for result
	PUSHAL	(SP)				; Stack 'message vector' address
	PUSHAL	4(SP)				; Stack pointer to result
	ADDL3	#value_vmsdesc,v2_desc(AP),-(SP); Get address of R.H. arg
	CALLS	#3,W^dbg$ncob_convert_to_packed	; Convert to packed decimal
	BLBC	R0,internal_error		; Report any errors seen
	CALLS	#0,normalize_decimal_value	; Normalize result
	MOVAB	r_op_desc(FP),R7		; Get new descriptor address
	MOVC3	#10,@(SP)+,(R7)			; Copy over 2nd descriptor
	MOVP	dsc$w_length(R7),@dsc$a_pointer(R7),16(SP)	;and value
	MOVAB	16(SP),dsc$a_pointer(R7)	;  & set up pointer to value
	MOVAB	L^packed_desc,R8		; Get local descriptor address
	MOVAB	L^digit_string,dsc$a_pointer(R8); Set up address field
	MOVW	#31,dsc$w_length(R8)		; Set length field to 31
	CASEB	operator(AP),#0,#3		; Dispatch on operator type
1$:	.WORD	decimal_add-1$		; '+' is code 0
	.WORD	decimal_sub-1$		; '-' is code 1
	.WORD	decimal_mul-1$		; '*' is code 2
	.WORD	decimal_div-1$		; '/' is code 3

internal_error:
	PUSHL	I^#dbg$_dbgerr			; This should never happen,
	CALLS	#1,G^lib$stop			;  so report error and quit

decimal_sub:
	MOVZWL	dsc$w_length(R7),R0		; Get length of R.H. operand
	ASHL	#-1,R0,R0			; Get offset to sign byte
	XORB2	#1,@dsc$a_pointer(R7)[R0]	; Change sign of operand
decimal_add:
	SUBB3	dsc$b_scale(R7),dsc$b_scale(R6),R5 ; Get change of scale needed
	BGEQ	1$				; O.K. if shorter fraction
	MNEGB	R5,R5				; Otherwise reverse operands
	XORL2	R6,R7				; These 3 XORL instructions
	XORL2	R7,R6				;  interchange the contents
	XORL2	R6,R7				;  of Registers R6 and R7 !
1$:	ADDB3	R5,dsc$w_length(R6),R0		; Get total number of digits
	SUBB3	R0,#30,R1			; Check length is within range
	BGEQ	2$				; O.K. if less than 31 digits !
	ADDB2	R1,R5				; Too long - adjust shift count
	SUBB2	R1,dsc$b_scale(R7)		; Remember scaling has changed
	ASHP	R1,dsc$w_length(R7),@dsc$a_pointer(R7),#0,dsc$w_length(R7),(SP)
	MOVP	dsc$w_length(R7),(SP),@dsc$a_pointer(R7)
2$:	ASHP	R5,dsc$w_length(R6),@dsc$a_pointer(R6),#0,#31,(SP)
	ADDP6	dsc$w_length(R7),@dsc$a_pointer(R7),#31,(SP),#31,@dsc$a_pointer(R8)
	MOVB	dsc$b_scale(R7),dsc$b_scale(R8)	; Copy over scale factor
;	BRW	decimal_return			; Go return normalized result

decimal_return:
	PUSHL	R8				; Stack VAX descriptor address
	CALLS	#1,W^normalize_decimal_value	; Strip leading/trailing 0's
	MOVZWL	dsc$w_length(R8),R9		; Get number of packed digits
	ASHL	#-3,R9,-(SP)			; Get longwords needed
	ADDL2	#3,(SP)				; Allow for overhead fields
	PUSHL	#value_format			; Say this is a value desc
	CALLS	#2,dbg$ncob_make_desc		; Construct skeleton desc
	PUSHL	R0				; Save descriptor address
	MOVL	 0(R8),value_vmsdesc+0(R0)	; Copy over fixed fields
	MOVW	 8(R8),value_vmsdesc+8(R0)	;  of VAX/VMS descriptor
	MOVAB	24(R0),value_vmsdesc+4(R0)	; Set up address field
	MOVP	R9,@dsc$a_pointer(R8),24(R0)	; Copy over decimal value
	MOVL	(SP)+,R0			; Retrieve descriptor address
	RET					; And return

decimal_mul:
	ADDB3	dsc$b_scale(R7),dsc$b_scale(R6),dsc$b_scale(R8)
	MULP	dsc$w_length(R7),@dsc$a_pointer(R7),-
		dsc$w_length(R6),@dsc$a_pointer(R6),-
		dsc$w_length(R8),@dsc$a_pointer(R8)
	BVC	1$				; Check for small numbers !
	ADDB2	#10,dsc$b_scale(R8)		; Too long - adjust scaling
	ASHP	#-10,dsc$w_length(R6),@dsc$a_pointer(R6),#0,#10,(SP)
	MULP	dsc$w_length(R7),@dsc$a_pointer(R7),#10,(SP),-
		dsc$w_length(R8),@dsc$a_pointer(R8)	; Get high-order digits
	SUBL	#16,SP				; Get some more work-space
	ASHP	#10,#10,16(SP),#0,#20,(SP)	; Re-normalize high digits
	SUBP4	#20,(SP),dsc$w_length(R6),@dsc$a_pointer(R6)
	MULP	dsc$w_length(R7),@dsc$a_pointer(R7),-
		dsc$w_length(R6),@dsc$a_pointer(R6),-
		#31,16(SP)			; Get low-order digits
	ASHP	#-10,#31,16(SP),#5,#21,(SP)	; Truncate and round result
	ADDP4	#21,(SP),dsc$w_length(R8),@dsc$a_pointer(R8)
1$:	BRW	decimal_return

decimal_div:
	SUBB3	dsc$b_scale(R7),dsc$b_scale(R6),dsc$b_scale(R8)
	SUBW3	dsc$w_length(R6),#31,R0		; Get number of trailing 0's
	SUBB2	R0,dsc$b_scale(R8)		; Adjust final scale factor
	ASHP	R0,dsc$w_length(R6),@dsc$a_pointer(R6),#0,#31,(SP)
	DIVP	dsc$w_length(R7),@dsc$a_pointer(R7),#31,(SP),-
		dsc$w_length(R8),@dsc$a_pointer(R8)
	SUBL	#32,SP				; Get more work-space
	ASHP	#10,dsc$w_length(R8),@dsc$a_pointer(R8),#0,#31,16(SP)
	BVS	1$				; O.K. if already got 20 digits
	MULP	dsc$w_length(R7),@dsc$a_pointer(R7),-
		dsc$w_length(R8),@dsc$a_pointer(R8),#31,(SP)
	SUBP6	#31,(SP),#31,32(SP),#21,@dsc$a_pointer(R6)
	ASHP	#10,#21,@dsc$a_pointer(R6),#0,#31,32(SP)
	DIVP	dsc$w_length(R7),@dsc$a_pointer(R7),#31,32(SP),-
		dsc$w_length(R8),@dsc$a_pointer(R8)
	ADDP4	#31,16(SP),dsc$w_length(R8),@dsc$a_pointer(R8)
	SUBB2	#10,dsc$b_scale(R8)		; Adjust scale factor of result
1$:	BRW	decimal_return			; Go return normalized result

.ENTRY	normalize_decimal_value,^M<R2,R3,R4,R5,R6,R7,R8,R9>

	SUBL	#16,SP				; Reserve local storage space
	MOVL	4(AP),R6			; Get address of descriptor
	CVTWL	dsc$w_length(R6),R7		; Get number of decimal digits
	MOVL	dsc$a_pointer(R6),R8		; Get address of digit string
1$:	MOVP	R7,(R8),(SP)			; Copy decimal value to stack
	BEQL	7$				; Special check for zero !
2$:	ASHL	#-1,R7,R9			; Get offset to sign byte
	BEQL	5$				; Leave at least one digit
	BITB	#^XF0,(SP)[R9]			; Test high nibble of sign byte
	BNEQ	3$				; Branch if no trailing zeros
	MOVL	R7,R0				; Get original number of digits
	DECL	R7				; Count length down by one
	INCB	dsc$b_scale(R6)			; Remember scaling has changed
	ASHP	#-1,R0,(SP),#0,R7,(R8)		; Scale number by one digit
	BRB	1$				; Go repeat test for zeros
3$:	ADDL3	#1,R9,R0			; Get number of bytes written
	SKPC	#0,R0,(SP)			; Find first non-zero byte
	DECL	R0				; Get <# of bytes> minus 1
	ASHL	#1,R0,R7			; Convert bytes to nibbles
	BITB	#^XF0,(R1)			; Check high nibble of byte
	BEQL	4$				; Ignore high nibble if zero
	INCL	R7				; Otherwise increase length
4$:	MOVP	R7,(R1),(R8)			; Copy over trailing digits
5$:	SUBW3	R7,#20,R0			; Check length of result
	BGEQ	6$				; Branch if 20 digits or less
	SUBB2	R0,dsc$b_scale(R6)		; Too long - adjust scaling
	ASHP	R0,R7,(R8),#0,#20,(SP)		; Truncate trailing digits
	MOVP	#20,(SP),(R8)			; Copy truncated value
	MOVW	#20,R7				; Set length to 20
	BRB	2$				; Go re-normalize result
6$:	ADDB3	dsc$b_scale(R6),#30,R9		; Get digits beyond 30 D.P.
	BGEQ	8$				; O.K. if value within bounds
	MOVL	R7,R5				; Otherwise remember length
	ADDB2	R9,R7				; Get number of digits left
	BLEQ	7$				; No digits means zero result !
	ASHP	R9,R5,(R8),#0,R7,(SP)		; Truncate value to 30 D.P.
	SUBB2	R9,dsc$b_scale(R6)		; Adjust scale factor
	MOVP	R7,(SP),(R8)			; Copy truncated value
	BRB	2$				; Go re-normalize result
7$:	MOVL	#1,R7				; Special handling if result
	CLRB	dsc$b_scale(R6)			;  is zero - scale factor is
	MOVL	#^X0C,(R8)			;  zero and sign is positive
8$:	CVTLW	R7,dsc$w_length(R6)		; Set length in descriptor
	CVTLB	R7,dsc$b_digits(R6)		; Ensure digit count is set up
	RET					; All normalized - return

	.SBTTL	Exception Handler

.ENTRY	local_handler,^M<>

	MOVL	4(AP),R1		; Get address of mechanism vector
	CMPL	4(R1),#ss$_unwind	; Unwinding stack ?
	BNEQ	1$			; No  - try next condition
	MOVL	#ss$_continue,R0	; Yes - say we handled condition
	RET				; Then exit from handler
1$:	CMPL	4(R1),#ss$_roprand	; Reserved operand fault ?
	BNEQ	2$			; No  - try next condition
	PUSHL	I^#dbg$_rsrvdoprand	; Reserved operand - get DEBUG
	CALLS	#1,G^lib$stop		;  error exception code
2$:	CMPL	4(R1),#ss$_fltdiv	; Floating/Decimal divide by zero ?
	BNEQ	3$			; No  - try next condition
	PUSHL	I^#dbg$_divbyzero	; Division by zero - get DEBUG
	CALLS	#1,G^lib$stop		;  error exception code
3$:	MOVL	#ss$_resignal,R0	; Otherwise say we don't want
	RET				;  to handle this condition

	.END

