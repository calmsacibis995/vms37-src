MODULE DBGNSET (IDENT = 'V03-000') =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	DEBUG
!
! ABSTRACT:
!
!	This module contains the ATN parse network and the command execution network
!	for the SET verb. These are currently the largest and most complicated
!	networks. Briefly, the parse network constructs a command execution tree
! 	which consists of at least a verb node, and possibly one or more noun nodes
!	The execution network accepts this tree as input and decodes the arguments
!	of the various nodes to perform the specified command.
!
! ENVIRONMENT:	VAX/VMS
!
! AUTHOR:	David Plummer	, CREATION DATE:	3/28/80
!
! VERSION:	V02.2-001
!
! MODIFIED BY:
!
!		Richard Title	31-Jul-81
!
! REVISION HISTORY:
! 3.0	31-JUL-81	RT	Added new nouns FLOAT, D_FLOAT, etc.
!				in the SET TYPE command.
! 3.1	13-SEP-81	RT	Implemented new SET commands: 
!				SET STEP SOURCE
!				SET SOURCE dir-list 
!				SET MAX_SOURCE_FILES n
!				as part of source line display
! 3.2 	 9-Oct-81	RT	Implemented SET MARGINS
! 3.3	13-Oct-81	RT	Implemented SET SEARCH
!--

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
	DBG$NPARSE_SET,				! SET verb parse network
	DBG$NEXECUTE_SET,			! SET verb execution network
	DBG$NSET_LOG,				! Sets up an output log
	DBG$NSETUP_LOG;				! Opens and connects an output log

!
! REQUIRE FILES:
!

REQUIRE 'SRC$:DBGPROLOG.REQ';

REQUIRE 'SRC$:DBGGEN.REQ';
REQUIRE 'SRC$:COMTER.REQ';

MACRO

	! Output_rms_error reports RMS errors caused by $CREATE, $OPEN, and $CONNECT

	OUTPUT_RMS_ERROR (BLOCK_TYPE) =
	    BEGIN
		LOCAL
		    MSG_DESC : REF dbg$stg_desc,
		    STS,
		    STV;

		IF NOT dbg$nlist_freez (2, msg_desc, .message_vect)
		THEN
		    RETURN sts$k_severe;

		build_error_desc (msg_desc);
		IF block_type EQL 1
		THEN
		    BEGIN
			sts = .dbg$gl_logfab [fab$l_sts];
			stv = .dbg$gl_logfab [fab$l_stv];
		    END
		ELSE
		    BEGIN
			sts = .dbg$gl_lograb [rab$l_sts];
			stv = .dbg$gl_lograb [rab$l_stv];
		    END;

	    	.message_vect = dbg$nmake_arg_vect (shr$_openout+dbg_fac_code,
						    1, .msg_desc, .sts, .stv);

		RETURN sts$k_severe;

	    END %,

	! Build_error_desc creates a descriptor for RMS error reporting

	BUILD_ERROR_DESC (MSG_DESC) =
	    IF .dbg$gl_log_buf NEQ 0
	    THEN
		BEGIN
		    msg_desc [dsc$w_length] = .dbg$gl_logfab [fab$b_fns];
		    msg_desc [dsc$a_pointer] = .dbg$gl_logfab [fab$l_fna];
		END
	    ELSE
		BEGIN
		    msg_desc [dsc$w_length] = .dbg$gl_logfab [fab$b_dns];
		    msg_desc [dsc$a_pointer] = .dbg$gl_logfab [fab$l_dna];
		END %,

	! Restore_nam restores an  RMS NAM block

	RESTORE_NAM =

	    BEGIN

	    LOCAL
		ERR,
		TYPE_B;

	    ! Release storage for the aborted log file

	    IF NOT dbg$nfreerelease (.temp_nam, .message_vect)
	    THEN
		RETURN sts$k_severe;

	    IF NOT dbg$nfreerelease (.temp_fsr, .message_vect)
	    THEN
		RETURN sts$k_severe;

	    IF NOT dbg$nfreerelease (.temp_fse, .message_vect)
	    THEN
		RETURN sts$k_severe;

	    dbg$gl_lognam = .old_nam_ptr;
	    old_nam_ptr = 0;
	    dbg$gl_logfab [fab$l_nam] = .dbg$gl_lognam;
	    dbg$gl_logfab [fab$l_fna] = .fna;
	    dbg$gl_logfab [fab$b_fns] = .fns;

	    dbg$gl_logfab [fab$v_nam] = 1;
	    dbg$gl_logfab [fab$v_cif] = 1;
	    dbg$gl_logfab [fab$v_mxv] = 0;

	    err = dbg$nsetup_log (type_b);

	    IF NOT .err
	    THEN output_rms_error (.type_b);

	    dbg$gb_def_out [out_log] = .log_temp;

	    END %;


!
! EQUATED SYMBOLS:
!
LITERAL

	! These are composite verb literals used in parsing and execution

	set_break = 1,
	set_break_do = 2,
	set_exception_break = 3,
	set_language = 4,
	set_log = 5,
	set_mode = 6,
	set_module = 7,
	set_module_all = 8,
	set_output = 9,
	set_scope = 10,
	set_step = 11,
	set_type = 12,
	set_type_override = 13,
	set_trace = 14,
	set_trace_calls = 15,
	set_trace_branch = 16,
	set_watch = 17,
    	set_source = 18,
    	set_max_source_files = 19,
    	set_margins = 20,
    	set_search = 21;


LITERAL				! These are legal mode literals
	mode_binary 	= 1,
	mode_octal	= 2,
	mode_decimal	= 3,
	mode_hex	= 4,
	mode_symbls	= 5,
	mode_nosymbls	= 6;

!
! EXTERNAL REFERENCES:
!

EXTERNAL ROUTINE
	DBG$NGET_LENGTH,			! Returns bit length for a primary
    	DBG$NGET_DIR_LIST,			! Parses a directory list for
    						! the SET SOURCE dir-list 
    						! command
    	DBG$STA_GETSOURCEMOD,			! Finds a module rst pointer
    	DBG$SRC_SET_SOURCE : NOVALUE,		! Implements the SET SOURCE command
	DBG$NSAVE_DECIMAL_INTEGER,		! Saves an inline numeric literal
	DBG$NSAVE_STRING,			! Saves a counted string from input
	DBG$NSAVE_BREAK_BUFFER,			! Saves away a break action buffer
	DBG$SET_OPTRACE,			! Sets opcode tracing
	DBG$NGET_ADDRESS,			! Recovers an address from addr exp desc
	DBG$NGET_TYPE,				! Obtains type of primary
	DBG$SAVE_BPT,				! Makes entry in xpoint table
    	DBG$SET_SEARCH_LVL : NOVALUE,		! Sets search data structure pointer
	DBG$SET_STP_LVL : NOVALUE,		! Sets step data structure pointer
	DBG$SET_MOD_LVL,			! Sets mode structure level
	DBG$RST_SETSCOPE : NOVALUE,		! Sets user specified scopes
	DBG$NPARSE_SCOPE_LIST,			! Parses a scope list
    	DBG$NSHOW_MARGINS : NOVALUE,		! Shows the margins
    	DBG$SRC_SET_MAX_FILES : NOVALUE,	! Performs SET MAX command
	DBG$NPATHDESC_TO_CS : NOVALUE,		! Translates a pathname desc to a c.s.
	DBG$RST_SETMOD,				! Sets a module
	DBG$NFREEZ,				! Allocates semi-permanent (non-listed) storage
	DBG$NFREERELEASE,			! Releases dynamic storage
	DBG$NLIST_FREEZ,			! Allocates and lists dynamic storage
	DBG$NSAVE_FILESP,			! Eats and stores a filespec string
	DBG$NMATCH,				! Routine to match keywords
	DBG$NPARSE_ADDRESS,			! Interface routine to Address Expression Interpreter
	DBG$NNEXT_WORD,				! Isolates next word of input for syntax errors
	DBG$NOUT_INFO,				! Outputs an informational message
	DBG$NMAKE_ARG_VECT,			! Constructs a message argument vector
	DBG$NSYNTAX_ERROR,			! Constructs a syntax error message
	DBG$SET_LANG;				! Version 2 routine to change languages
						! storage chunks

EXTERNAL
	DBG$GL_GBLTYP,			    ! Override type
	DBG$GW_GBLLNGTH : WORD,		    ! Override length
	DBG$GL_DFLTTYP,			    ! Default type
	DBG$GW_DFLTLENG : WORD,		    ! Default length
    	DBG$GB_SEARCH_PTR:REF VECTOR[,BYTE],! Search structure
	DBG$GB_MOD_PTR : REF VECTOR [,BYTE],! Mode structure
	DBG$GL_RUNFRAME : REF BLOCK [,BYTE],! pointer to current runframe
	DBG$GB_RESIGNAL : BYTE,		    ! If true, then resignal exeptions
	DBG$GL_LOG_BUF,			    ! Old debugger pointer to counted string filespec
	DBG$GL_CONTEXT : BITVECTOR,	    ! Old debugger context switches 
	DBG$GB_DEF_OUT : VECTOR [,BYTE],    ! Old debugger output control vector
	DBG$GL_LOGFAB : BLOCK [,BYTE],	    ! FAB for log file
	DBG$GL_LOGRAB : BLOCK [,BYTE],	    ! RAB for log file
	DBG$GL_LOGNAM : REF $NAM_DECL,	    ! NAM block for file spec
	DBG$GB_LOGFSR : REF VECTOR [,BYTE], ! Resultant LOG filespec buffer
	DBG$GB_LOGFSE : REF VECTOR [,BYTE], ! Expanded LOG filespec buffer
	DBG$GB_STP_PTR : REF VECTOR [,BYTE],! Pointer to step types
	DBG$SRC_LEFT_MARGIN,		    ! Left margin for source display
    	DBG$SRC_RIGHT_MARGIN;		    ! Right margin for source display


GLOBAL ROUTINE DBG$NPARSE_SET (INPUT_DESC, VERB_NODE, MESSAGE_VECT) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine comprises the ATN parse network for the SET verb. The network
!	recognizes various keywords and contructs appropriate noun nodes which it
! 	links to the verb node. Many composite verbs are recognized in this network
!	as well. The value of these composite verbs are placed in the verb node (verb composite)
!	field.
!
! FORMAL PARAMETERS:
!
!	input_desc -		The present command line input descriptor
!
!	verb_node _		The first node in the command execution tree. Value
!				field has already been filled in by dbg$nparse_cmd
!
!	message_vect -		The address of a longword to contain the address
!				of a message argument vector
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	The command execution tree corresponding to the input command is constructed.
!
! ROUTINE VALUE:	
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	sts$k_severe (4)	- Unsuccessful parse
!
!	sts$k_success (1)	- Successful parse
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    ! Define string used at this level

    BIND
	DBG$CS_BREAK 		= UPLIT BYTE (5, 'BREAK'),
	DBG$CS_EXCEPTION 	= UPLIT BYTE (9, 'EXCEPTION'),
	DBG$CS_LANGUAGE 	= UPLIT BYTE (8, 'LANGUAGE'),
	DBG$CS_LOG 		= UPLIT BYTE (3, 'LOG'),
    	DBG$CS_MARGINS		= UPLIT BYTE (7, 'MARGINS'),
    	DBG$CS_MAX_SOURCE_FILES = UPLIT BYTE (16,'MAX_SOURCE_FILES'),
	DBG$CS_MODE		= UPLIT BYTE (4, 'MODE'),
	DBG$CS_MODULE 		= UPLIT BYTE (6, 'MODULE'),
	DBG$CS_OUTPUT 		= UPLIT BYTE (6, 'OUTPUT'),
	DBG$CS_SCOPE		= UPLIT BYTE (5, 'SCOPE'),
    	DBG$CS_SEARCH		= UPLIT BYTE (6, 'SEARCH'),
        DBG$CS_SOURCE		= UPLIT BYTE (6, 'SOURCE'),
	DBG$CS_STEP 		= UPLIT BYTE (4, 'STEP'),
	DBG$CS_TYPE		= UPLIT BYTE (4, 'TYPE'),
	DBG$CS_TRACE 		= UPLIT BYTE (5, 'TRACE'),
	DBG$CS_WATCH 		= UPLIT BYTE (5, 'WATCH'),
    	DBG$CS_COLON		= UPLIT BYTE (1, dbg$k_colon),
	DBG$CS_COMMA 		= UPLIT BYTE (1, dbg$k_comma),
    	DBG$CS_EQUAL		= UPLIT BYTE (1, dbg$k_equal),
	DBG$CS_SLASH 		= UPLIT BYTE (1, dbg$k_slash),
	DBG$CS_CR 		= UPLIT BYTE (1, dbg$k_car_return);

    MAP 
	VERB_NODE : REF dbg$verb_node;

    LOCAL
	NOUN_NODE : REF dbg$noun_node;

    ! Construct the noun node

    IF NOT dbg$nlist_freez (dbg$k_noun_node_size, noun_node, .message_vect)
    THEN
	RETURN sts$k_severe;

    ! Link the noun node to the verb node

    verb_node [dbg$l_verb_object_ptr] = .noun_node;

    ! Recognize keyword and transfer control to subnetwork if appropriate.


    SELECTONE true
	OF
	SET

	[dbg$nmatch (.input_desc, dbg$cs_break, 1)] :	! Set break
	    BEGIN
	    LOCAL
		STATUS,					! Holds return status
		ADVERB_NODE : REF dbg$adverb_node;	! Will contain the after count
	    BIND			! Strings used at this level
		DBG$CS_AFTER = UPLIT BYTE (5, 'AFTER'),
		DBG$CS_DO = UPLIT BYTE (2, 'DO'),
		DBG$CS_COLON= UPLIT BYTE (1, dbg$k_colon),
		DBG$CS_LEFT_PAREN = UPLIT BYTE (1, dbg$k_left_parenthesis),
		DBG$CS_RIGHT_PAREN = UPLIT BYTE (1, dbg$k_right_parenthesis);

	    ! Create the adverb node to hold the after count. Set the value
	    ! to 1 unless proven otherwise ( encounter a /after:xxx).

	    IF NOT dbg$nlist_freez (dbg$k_adverb_node_size, 
				    adverb_node,
	 			    .message_vect)
	    THEN
		RETURN sts$k_severe;

	    verb_node [dbg$l_verb_adverb_ptr] = .adverb_node;
	    adverb_node [dbg$l_adverb_value] = 1;

	    ! Set the verb composite to set_break until/unless we find a DO.

	    verb_node [dbg$b_verb_composite] = set_break;

	    ! Now look for a /after:xxx sequence

	    IF dbg$nmatch (.input_desc, dbg$cs_slash, 1)
	    THEN
		BEGIN
		IF NOT dbg$nmatch (.input_desc, dbg$cs_after, 1)
		THEN
		    BEGIN
		    .message_vect =
		    (
		     IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
		     THEN
		         dbg$nmake_arg_vect (dbg$_needmore)
		     ELSE
		         dbg$nsyntax_error (dbg$nnext_word (.input_desc))
		    );
		    RETURN sts$k_severe;
		    END;
		IF NOT dbg$nmatch (.input_desc, dbg$cs_colon, 1)
		THEN
		    BEGIN
		    .message_vect =
		    (
		     IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
		     THEN
		         dbg$nmake_arg_vect (dbg$_needmore)
		     ELSE
		         dbg$nsyntax_error (dbg$nnext_word (.input_desc))
		    );
		    RETURN sts$k_severe;
		    END;

		! We have stripped the /after:. Now get the integer.

		IF NOT dbg$nsave_decimal_integer (.input_desc, 
					          adverb_node [dbg$l_adverb_value],
						  .message_vect)
		THEN
		    RETURN sts$k_severe;
		END;	! This finishes the /after:xxx sequence

	    ! We are now looking for the object. (address expression).
	    ! Invoke the address expression interpreter. On a return of
	    ! sts$k_warning, we may have a DO action sequence.

	    status = dbg$nparse_address (.input_desc, noun_node [dbg$l_noun_value],
					 dbg$k_default, .message_vect);

	    ! Look for severe error.

	    IF .status EQL sts$k_severe
	    THEN
		RETURN sts$k_severe;

	    ! sts$k_warning means more input - probably a DO action buffer

	    IF .status EQL sts$k_warning
	    THEN
		BEGIN
		LOCAL
		LINK;		! Address of link field

		! Check for the DO

		IF NOT dbg$nmatch (.input_desc, dbg$cs_do, 1)
		THEN
		    BEGIN
		    .message_vect = dbg$nsyntax_error (dbg$nnext_word (.input_desc));
		    RETURN sts$k_severe;
		    END;

		! Look for the opening parenthesis '('

		IF NOT dbg$nmatch (.input_desc, dbg$cs_left_paren, 1)
		THEN
		    BEGIN
		    .message_vect = 
		    (
		     IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
		     THEN
		         dbg$nmake_arg_vect (dbg$_needmore)
		     ELSE
		         dbg$nsyntax_error (dbg$nnext_word (.input_desc))
		    );
		    RETURN sts$k_severe;
		    END;

		! Allocate a new noun node to hold the buffer address.

		link = noun_node [dbg$l_noun_link];

		IF NOT dbg$nlist_freez (dbg$k_noun_node_size, noun_node, .message_vect)
		THEN
		    RETURN sts$k_severe;
		.link = .noun_node;

		! Now save the break action buffer

		IF NOT dbg$nsave_break_buffer (.input_desc,
					       noun_node [dbg$l_noun_value],
					       .message_vect)
		THEN
		    RETURN sts$k_severe;

		! Set the verb composite and we're done

		verb_node [dbg$b_verb_composite] = set_break_do;
		END;

	    END;

	[dbg$nmatch (.input_desc, dbg$cs_exception, 1)] :	! Set exception break
	    BEGIN

	    ! We are looking for SET EXCEPTION BREAK

	    IF NOT dbg$nmatch (.input_desc, dbg$cs_break, 1)
	    THEN
	    	BEGIN
		.message_vect =
		( IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
		  THEN
		      dbg$nmake_arg_vect (dbg$_needmore)
		  ELSE
		      dbg$nsyntax_error (dbg$nnext_word (.input_desc)));
		RETURN sts$k_severe;
		END;

	    ! Set the verb composite

	    verb_node [dbg$b_verb_composite] = set_exception_break;

	    END;

	[dbg$nmatch (.input_desc, dbg$cs_language, 2)]:
	    BEGIN

	    BIND
		DBG$CS_MACRO = UPLIT BYTE (5, 'MACRO'),
		DBG$CS_FORTRAN = UPLIT BYTE (7, 'FORTRAN'),
 		DBG$CS_BLISS = UPLIT BYTE (5, 'BLISS'),
		DBG$CS_COBOL = UPLIT BYTE (5, 'COBOL'),
		DBG$CS_BASIC = UPLIT BYTE (5, 'BASIC'),
		DBG$CS_PLI = UPLIT BYTE (3, 'PLI'),
		DBG$CS_PASCAL = UPLIT BYTE (6, 'PASCAL');

	    verb_node [dbg$b_verb_composite] = set_language;

	    SELECTONE true
	   	OF
		SET

		[dbg$nmatch (.input_desc, dbg$cs_macro, 2)] :
		    BEGIN
		    noun_node [dbg$l_noun_value] = dbg$k_macro;
		    END;

		[dbg$nmatch (.input_desc, dbg$cs_fortran, 2)] :
		    BEGIN
		    noun_node [dbg$l_noun_value] = dbg$k_fortran;
		    END;

		[dbg$nmatch (.input_desc, dbg$cs_bliss, 2)] :
		    BEGIN
		    noun_node [dbg$l_noun_value] = dbg$k_bliss;
		    END;

		[dbg$nmatch (.input_desc, dbg$cs_cobol, 2)] :
		    BEGIN
		    noun_node [dbg$l_noun_value] = dbg$k_cobol;
		    END;

		[dbg$nmatch (.input_desc, dbg$cs_basic, 2)] :
		    BEGIN
		    noun_node [dbg$l_noun_value] = dbg$k_basic;
		    END;
			
		[dbg$nmatch (.input_desc, dbg$cs_pli, 2)] :
		    BEGIN
		    noun_node [dbg$l_noun_value] = dbg$k_pli;
		    END;

		[dbg$nmatch (.input_desc, dbg$cs_pascal, 2)] :
		    BEGIN
		    noun_node [dbg$l_noun_value] = dbg$k_pascal;
		    END;

		[OTHERWISE] :
		    BEGIN
		    IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
		    THEN
		    	.message_vect = dbg$nmake_arg_vect (dbg$_needmore)
		    ELSE
			.message_vect = dbg$nsyntax_error
						 (dbg$nnext_word (.input_desc));
		    RETURN sts$k_severe;
		    END;

		TES;

	    END;

	[dbg$nmatch (.input_desc, dbg$cs_log, 2)] :
	    BEGIN
	    verb_node [dbg$b_verb_composite] = set_log;
	    IF NOT dbg$nsave_filesp (.input_desc,
				     noun_node [dbg$l_noun_value], 
				     .message_vect)
	    THEN
	 	RETURN sts$k_severe;
	    END;

    	[dbg$nmatch (.input_desc, dbg$cs_margins, 3)] :
    	    BEGIN
    	    LOCAL
    		left_margin,
    		right_margin;
    	    verb_node[dbg$b_verb_composite] = set_margins;

    	    ! Legal forms of the SET MARGINS command are:
    	    ! 1. SET MARGINS l:r
    	    ! 2. SET MARGINS r
    	    ! 3. SET MARGINS l:
    	    ! 4. SET MARGINS :r
    	    !
    	    IF dbg$nmatch (.input_desc, dbg$cs_colon, 1)
    	    THEN
    		! This must be case four, above
    		BEGIN
    		IF NOT dbg$nsave_decimal_integer(.input_desc,
    			right_margin, .message_vect)
    		THEN
    		    RETURN sts$k_severe;
    		left_margin = .dbg$src_left_margin;
    		END
    	    ELSE
    		BEGIN
    		IF NOT dbg$nsave_decimal_integer (.input_desc, 
    		    right_margin, .message_vect)
    		THEN 
    		    RETURN sts$k_severe;
    	        ! Look for colon
    	        !
    	        IF dbg$nmatch (.input_desc, dbg$cs_colon, 1)
    	        THEN
    		    ! This must be case 1 or case 3 above
    		    BEGIN
    		    left_margin = .right_margin;
    		    IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
    		    THEN ! case 3
    			right_margin = .dbg$src_right_margin
    		    ELSE ! case 1
    		        IF NOT dbg$nsave_decimal_integer (.input_desc,
    		            right_margin, .message_vect)
    		        THEN
    			    RETURN sts$k_severe;
    		    END
   	        ELSE
   		    ! case 2
    		    BEGIN
    		    left_margin = 1;
    		    END;
    		END;

    	    ! Check that left margin is less than right margin
    	    !
    	    IF .left_margin GEQ .right_margin
    	    THEN
    		BEGIN
    		dbg$nshow_margins();
    		SIGNAL(dbg$_invmar);
    		END;

    	    ! Fill in the noun node
    	    !
    	    noun_node[dbg$l_noun_value] = .left_margin;
    	    noun_node[dbg$l_noun_value2] = .right_margin;

    	    END;

    	[dbg$nmatch (.input_desc, dbg$cs_max_source_files, 3)] :
    	    BEGIN
    	    LOCAL
    		max_files;
    	    verb_node[dbg$b_verb_composite] = set_max_source_files;
    	    IF NOT dbg$nsave_decimal_integer(
    		.input_desc, max_files, .message_vect)
    	    THEN
    		RETURN sts$k_severe;
    	    noun_node[dbg$l_noun_value] = .max_files;
    	    END;

	[dbg$nmatch (.input_desc, dbg$cs_mode, 1)] :
	    BEGIN
	    LOCAL
		LINK;
	    BIND
		DBG$CS_BINARY		= UPLIT BYTE (6, 'BINARY'),
		DBG$CS_OCTAL		= UPLIT BYTE (5, 'OCTAL'),
		DBG$CS_DECIMAL		= UPLIT BYTE (7, 'DECIMAL'),
		DBG$CS_HEXADECIMAL	= UPLIT BYTE (11, 'HEXADECIMAL'),
		DBG$CS_SYMBOLS		= UPLIT BYTE (8, 'SYMBOLIC'),
		DBG$CS_NOSYMBOLS	= UPLIT BYTE (10, 'NOSYMBOLIC');

	    verb_node [dbg$b_verb_composite] = set_mode;
	    
	    ! Accept the mode switches

	    WHILE true
	    DO
		BEGIN

		SELECTONE true 
		    OF
		    SET

!***		    [dbg$nmatch (.input_desc, dbg$cs_binary, 1)] :
!***			BEGIN
!***			noun_node [dbg$l_noun_value] = mode_binary;
!***			END;

		    [dbg$nmatch (.input_desc, dbg$cs_octal, 1)] :
			BEGIN
			noun_node [dbg$l_noun_value] = mode_octal;
			END;

		    [dbg$nmatch (.input_desc, dbg$cs_decimal, 1)] :
			BEGIN
			noun_node [dbg$l_noun_value] = mode_decimal;
			END;

		    [dbg$nmatch (.input_desc, dbg$cs_hexadecimal, 1)] :
			BEGIN
			noun_node [dbg$l_noun_value] = mode_hex;
			END;

		    [dbg$nmatch (.input_desc, dbg$cs_symbols, 1)] :
			BEGIN
			noun_node [dbg$l_noun_value] = mode_symbls;
			END;

		    [dbg$nmatch (.input_desc, dbg$cs_nosymbols, 1)] :
			BEGIN
			noun_node [dbg$l_noun_value] = mode_nosymbls;
			END;

		    [OTHERWISE] :
			BEGIN
			.message_vect =
			(IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
			THEN
			    dbg$nmake_arg_vect (dbg$_needmore)
			ELSE
			    dbg$nsyntax_error (dbg$nnext_word (.input_desc)));
			RETURN sts$k_severe;
			END;
	
		    TES;

		! Check for a comma to see if more input should follow

		IF NOT dbg$nmatch (.input_desc, dbg$cs_comma, 1)
		THEN
		    EXITLOOP;

		! More input should follow. Create another noun node and link

		link = noun_node [dbg$l_noun_link];
		IF NOT dbg$nlist_freez (dbg$k_noun_node_size, noun_node, .message_vect)
		THEN
		    RETURN sts$k_severe;

		.link = .noun_node;

		END;	! End of loop

	    ! Place a 0 in the last noun link field

	    noun_node [dbg$l_noun_link] = 0;

	    END;

	[dbg$nmatch (.input_desc, dbg$cs_module, 4)] :
	    BEGIN

	    ! Check for SET MODULE/ALL

	    IF dbg$nmatch (.input_desc, dbg$cs_slash, 1)
	    THEN
		BEGIN
		BIND
		    DBG$CS_ALL = UPLIT BYTE (3, 'ALL');

		IF NOT dbg$nmatch (.input_desc, dbg$cs_all, 1)
		THEN
		    BEGIN
		    .message_vect =
		    (IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
		     THEN
		         dbg$nmake_arg_vect (dbg$_needmore)
		     ELSE
		         dbg$nsyntax_error (dbg$nnext_word (.input_desc)));
		    RETURN sts$k_severe;
		    END;

		verb_node [dbg$b_verb_composite] = set_module_all;
		END

	    ELSE
	 	BEGIN

		! We have a module name list to parse

		BIND
		    DBG$CS_COMMA = UPLIT BYTE (1, dbg$k_comma);
		LOCAL
		    LINK;		! Temporary pointer

		! Accept strings and commas
		
		WHILE true
		DO
		    BEGIN

		    IF NOT DBG$NSAVE_STRING  (.input_desc, 
					      noun_node [dbg$l_noun_value],
					      .message_vect)
		    THEN
			RETURN sts$k_severe;

		    ! Check for a comma

		    IF NOT dbg$nmatch (.input_desc, dbg$cs_comma, 1)
		    THEN
			EXITLOOP;

		    ! Create a new noun node to hold the next string

		    link = noun_node [dbg$l_noun_link];
		    IF NOT dbg$nlist_freez (dbg$k_noun_node_size,
					    noun_node,
					    .message_vect)
		    THEN
			RETURN sts$k_severe;
	
		    .link = .noun_node;

		    END;	! End of loop

		! Place a zero in the last link field

		noun_node [dbg$l_noun_link] = 0;

		verb_node [dbg$b_verb_composite] = set_module;

		END;

	    END;

	[dbg$nmatch (.input_desc, dbg$cs_output, 1)] :
	    BEGIN
	    LITERAL
		NOUN_LITERAL_LOG = 1,
		NOUN_LITERAL_NOLOG = 2,
		NOUN_LITERAL_TERMINAL = 3,
		NOUN_LITERAL_NOTERMINAL = 4,
		NOUN_LITERAL_VERIFY = 5,
		NOUN_LITERAL_NOVERIFY = 6;

	    BIND
		DBG$CS_LOG = UPLIT BYTE (3, 'LOG'),
	   	DBG$CS_NOLOG = UPLIT BYTE (5, 'NOLOG'),
		DBG$CS_TERMINAL = UPLIT BYTE (8, 'TERMINAL'),
		DBG$CS_NOTERMINAL = UPLIT BYTE (10, 'NOTERMINAL'),
		DBG$CS_VERIFY = UPLIT BYTE (6, 'VERIFY'),
		DBG$CS_NOVERIFY = UPLIT BYTE (8, 'NOVERIFY');

	    LOCAL
		LINK;		! Used as a link pointer

	    ! Set the verb composite

	    verb_node [dbg$b_verb_composite] = set_output;

	    ! Accept the SET OUTPUT xxx objects

	    WHILE true
	    DO
		BEGIN
		SELECTONE true
		    OF
		    SET

		    [dbg$nmatch (.input_desc, dbg$cs_log, 1)] :
			BEGIN
			noun_node [dbg$l_noun_value] = noun_literal_log;
			END;

		    [dbg$nmatch (.input_desc, dbg$cs_nolog, 3)] :
			BEGIN
			noun_node [dbg$l_noun_value] = noun_literal_nolog;
			END;

		    [dbg$nmatch (.input_desc, dbg$cs_terminal, 1)] :
			BEGIN
			noun_node [dbg$l_noun_value] = noun_literal_terminal;
			END;

		    [dbg$nmatch (.input_desc, dbg$cs_noterminal, 3)] :
			BEGIN
			noun_node [dbg$l_noun_value] = noun_literal_noterminal;
			END;

		    [dbg$nmatch (.input_desc, dbg$cs_verify, 1)] :
			BEGIN
			noun_node [dbg$l_noun_value] = noun_literal_verify;
			END;

		    [dbg$nmatch (.input_desc, dbg$cs_noverify, 3)] :
			BEGIN
			noun_node [dbg$l_noun_value] = noun_literal_noverify;
			END;

		    [OTHERWISE] :
			BEGIN
			IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
			THEN
			    .message_vect = dbg$nmake_arg_vect (dbg$_needmore)
			ELSE
			    .message_vect = dbg$nsyntax_error (dbg$nnext_word
							       (.input_desc));
			RETURN sts$k_severe;
			END;
	
		    TES;

		! Look for a comma and exit the loop if none found

		IF NOT dbg$nmatch (.input_desc, dbg$cs_comma, 1)
		THEN
		    EXITLOOP;

		! Since we expect more input, create another noun node

		link = noun_node [dbg$l_noun_link];
		IF NOT dbg$nlist_freez (dbg$k_noun_node_size, noun_node, .message_vect)
		THEN
		    RETURN sts$k_severe;

		.link = .noun_node;

		END;	! End of loop

	    ! Put a zero in the last link field of the noun node chain

	    noun_node [dbg$l_noun_link] = 0;

	    END;
		    
	[dbg$nmatch (.input_desc, dbg$cs_scope, 2)] :
	    BEGIN
	    verb_node [dbg$b_verb_composite] = set_scope;
	    IF NOT dbg$nparse_scope_list (.input_desc, 
					  noun_node [dbg$l_noun_value],
					  .message_vect)
	    THEN
		RETURN sts$k_severe;
	    END;

    	[dbg$nmatch (.input_desc, dbg$cs_search, 2)] :
    	    BEGIN
    	    LITERAL
    	        noun_literal_all = 1,
    	        noun_literal_next = 2,
    	        noun_literal_string = 3,
    	        noun_literal_ident = 4;

    	    BIND
    		dbg$cs_all = UPLIT BYTE (3, 'ALL'),
    		dbg$cs_next = UPLIT BYTE (4, 'NEXT'),
    		dbg$cs_string = UPLIT BYTE (6, 'STRING'),
    		dbg$cs_ident = UPLIT BYTE (10, 'IDENTIFIER');
    	    LOCAL
    		link; 	! Used as a link pointer

    	    ! Set up the verb composite
    	    !
    	    verb_node[dbg$b_verb_composite] = set_search;

    	    ! Accept the SET SEARCH xxx  objects
    	    !
    	    WHILE TRUE DO
    		BEGIN
    		SELECTONE TRUE OF
    		    SET

    		    [dbg$nmatch (.input_desc, dbg$cs_all, 1)] :
    			BEGIN
    			noun_node [dbg$l_noun_value] = noun_literal_all;
    			END;

    		    [dbg$nmatch (.input_desc, dbg$cs_ident, 1)] :
    			BEGIN
    			noun_node [dbg$l_noun_value] = noun_literal_ident;
    			END;
    
    		    [dbg$nmatch (.input_desc, dbg$cs_next, 1)] :
    			BEGIN
    			noun_node [dbg$l_noun_value] = noun_literal_next;
    			END;

    		    [dbg$nmatch (.input_desc, dbg$cs_string, 1)] :
    			BEGIN
    			noun_node [dbg$l_noun_value] = noun_literal_string;
    			END;

    		    [OTHERWISE] :
    			BEGIN
    			IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
    			THEN
    			    .message_vect = dbg$nmake_arg_vect (dbg$_needmore)
    			ELSE
    			    .message_vect = dbg$nsyntax_error (dbg$nnext_word(
    				.input_desc));
    			RETURN sts$k_severe;
    			END;

    		    TES;

    		! Look for comma and exit the loop if none found
    		!
    		IF NOT dbg$nmatch (.input_desc, dbg$cs_comma, 1)
    		THEN
    		    EXITLOOP;

    		! Since we expect more input, create another noun node
    		!
    		link = noun_node[dbg$l_noun_link];
    		IF NOT dbg$nlist_freez (dbg$k_noun_node_size, noun_node,
    			.message_vect)
    		THEN
    		    RETURN sts$k_severe;
    		.link = .noun_node;

    		END; ! End of loop

    	    ! Put a zero in the last link field of the noun node chain
    	    !
    	    noun_node [dbg$l_noun_link] = 0;

    	    END;

    	[dbg$nmatch (.input_desc, dbg$cs_source, 2)] : 
    	    BEGIN
    	    verb_node[dbg$b_verb_composite] = set_source;
    
    	    ! Check for SET SOURCE/MODULE=dir-list

    	    IF dbg$nmatch (.input_desc, dbg$cs_slash, 1)
    	    THEN
    		BEGIN ! SET SOURCE/MODULE=dir-list
    		LOCAL
    		    modnameptr;

    		BIND
    		    dbg$cs_module = UPLIT BYTE (6, 'MODULE');

    		! Read the string MODULE

    		IF NOT dbg$nmatch (.input_desc, dbg$cs_module, 4)
    		THEN
    		    BEGIN
    		    .message_vect = dbg$nsyntax_error(
    			dbg$nnext_word(.input_desc));
    		    RETURN sts$k_severe;
    		    END;

    		! Read the = sign

    		IF NOT dbg$nmatch (.input_desc, dbg$cs_equal, 1)
    		THEN
    		    BEGIN
    		    .message_vect = dbg$nsyntax_error(
    			dbg$nnext_word(.input_desc));
    		    RETURN sts$k_severe;
    		    END;

    		! Read the module name
    		
    		IF NOT dbg$nsave_string (.input_desc,
    		    modnameptr, .message_vect)
    		THEN
    		    RETURN sts$k_severe;

    		! Convert the module name into an rst pointer and
    		! save into the adjective field of the noun node.

    		noun_node[dbg$l_adjective_ptr] =
    		    dbg$sta_getsourcemod(.modnameptr);
    	
    		! If the above routine returns zero then the user has
    		! entered an invalid module.

    		IF .noun_node[dbg$l_adjective_ptr] EQL 0
    		THEN
    		    BEGIN
    		    .message_vect = dbg$nmake_arg_vect(
    			dbg$_nosuchmodu, 1, .modnameptr);
    		    RETURN sts$k_severe;
    		    END;

    		END; ! SET SOURCE/MODULE=

    	    ! Now read the directory list

    	    IF NOT dbg$nget_dir_list (.input_desc,
    		noun_node[dbg$l_noun_value], .message_vect)
    	    THEN
    		RETURN sts$k_severe;

    	    END; ! SET SOURCE
    	    		

	[dbg$nmatch (.input_desc, dbg$cs_step, 1)] :
	    BEGIN

	    ! Define appropriate set step objects

	    BIND
		DBG$CS_LINE = UPLIT BYTE (4, 'LINE'),
		DBG$CS_INSTRUCTION = UPLIT BYTE (11, 'INSTRUCTION'),
		DBG$CS_INTO = UPLIT BYTE (4, 'INTO'),
		DBG$CS_OVER = UPLIT BYTE (4, 'OVER'),
		DBG$CS_SYSTEM = UPLIT BYTE (6, 'SYSTEM'),
		DBG$CS_NOSYSTEM = UPLIT BYTE (8, 'NOSYSTEM'),
    		DBG$CS_SOURCE = UPLIT BYTE (6, 'SOURCE'),
    		DBG$CS_NOSOURCE = UPLIT BYTE (8, 'NOSOURCE');

	    LITERAL
		NOUN_LITERAL_LINE = 1,	! These are legal noun values
		NOUN_LITERAL_INSTRUCTION = 2,
		NOUN_LITERAL_INTO = 3,
		NOUN_LITERAL_OVER = 4,
		NOUN_LITERAL_SYSTEM = 5,
		NOUN_LITERAL_NOSYSTEM = 6,
    		NOUN_LITERAL_SOURCE = 7,
    		NOUN_LITERAL_NOSOURCE = 8;

	    LOCAL
		LINK;		! Used as a link pointer

	    verb_node [dbg$b_verb_composite] = set_step;

	    ! Now accept the object keywords. Remember that the first noun
	    ! node is already created and linked.

	    WHILE true		! LOOP until we run out of objects
	    DO
		BEGIN
		SELECTONE true
		    OF
		    SET

		    [dbg$nmatch (.input_desc, dbg$cs_line, 1)] :
			BEGIN
			noun_node [dbg$l_noun_value] = noun_literal_line;
			END;

		    [dbg$nmatch (.input_desc, dbg$cs_instruction, 3)] :
			BEGIN
			noun_node [dbg$l_noun_value] = noun_literal_instruction;
			END;

		    [dbg$nmatch (.input_desc, dbg$cs_into, 3)] :
			BEGIN
			noun_node [dbg$l_noun_value] = noun_literal_into;
			END;

		    [dbg$nmatch (.input_desc, dbg$cs_over, 1)] :
			BEGIN
			noun_node [dbg$l_noun_value] = noun_literal_over;
			END;

		    [dbg$nmatch (.input_desc, dbg$cs_system, 1)] :
			BEGIN
			noun_node [dbg$l_noun_value] = noun_literal_system;
			END;

		    [dbg$nmatch (.input_desc, dbg$cs_nosystem, 1)] :
			BEGIN
			noun_node [dbg$l_noun_value] = noun_literal_nosystem;
			END;

    		    [dbg$nmatch(.input_desc, dbg$cs_source, 2)] :
    			BEGIN
    			noun_node[dbg$l_noun_value] = noun_literal_source;
    			END;

    		    [dbg$nmatch (.input_desc, dbg$cs_nosource, 4)] :
    			BEGIN
    			noun_node[dbg$l_noun_value] = noun_literal_nosource;
    			END;

		    [OTHERWISE] :		! Syntax error
			BEGIN
			IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
			THEN
			    .message_vect = dbg$nmake_arg_vect (dbg$_needmore)
			ELSE
			    .message_vect = dbg$nsyntax_error (dbg$nnext_word 
							       (.input_desc));
			RETURN sts$k_severe;
			END;

		    TES;

		! Now exit if there is not a comma (another object)

		IF NOT dbg$nmatch (.input_desc, dbg$cs_comma, 1)
		THEN
		    EXITLOOP;

		! Since there is more input, create another noun node and link

		link = noun_node [dbg$l_noun_link];

		IF NOT dbg$nlist_freez (dbg$k_noun_node_size, noun_node, .message_vect)
		THEN
		    RETURN sts$k_severe;

		.link = .noun_node;

		END;		! End of loop

	    ! Now put a zero in the link field of the last noun node

	    noun_node [dbg$l_noun_link] = 0;

	    END;

	[dbg$nmatch (.input_desc, dbg$cs_trace, 1)] : ! SET TRACE
	    BEGIN

	    ! Define strings used at this level

	    BIND
		DBG$CS_CALLS = UPLIT BYTE (5, 'CALLS'),
		DBG$CS_BRANCH = UPLIT BYTE (6, 'BRANCH');

	    ! Check for /CALLS or /BREAK

	    IF dbg$nmatch (.input_desc, dbg$cs_slash, 1)
	    THEN
		BEGIN

		! We expect to find CALLS or BRANCH next.

		SELECTONE true
		    OF
		    SET

		    [dbg$nmatch (.input_desc, dbg$cs_calls, 1)] :
			BEGIN
			verb_node [dbg$b_verb_composite] = set_trace_calls;
			END; 

		    [dbg$nmatch (.input_desc, dbg$cs_branch, 1)] :
			BEGIN
			verb_node [dbg$b_verb_composite] = set_trace_branch;
			END;

		    [OTHERWISE] :    ! Syntax error
			BEGIN
			.message_vect = 
			(IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
			 THEN
			     dbg$nmake_arg_vect (dbg$_needmore)
			 ELSE
			     dbg$nsyntax_error (dbg$nnext_word (.input_desc)));
			RETURN sts$k_severe;
			END;

		    TES;

		END

	    ELSE
		BEGIN	! Looking for a regular trace
		LOCAL
		    STATUS;		! Holds return status

		! Obtain the address expression descriptor

		IF NOT (status = dbg$nparse_address (.input_desc,
						     noun_node [dbg$l_noun_value],
						     dbg$k_default,
						     .message_vect))
		THEN
		    BEGIN
		    IF .status EQL sts$k_warning
		    THEN
			.message_vect = dbg$nsyntax_error (dbg$nnext_word (.input_desc));
		    RETURN sts$k_severe;
		    END;

		! Set the verb composite

		verb_node [dbg$b_verb_composite] = set_trace;

		END;

	    END;

	[dbg$nmatch (.input_desc, dbg$cs_type, 2)] :	! SET TYPE or SET TYPE/OVERRIDE
	    BEGIN
	    LOCAL
		LENGTH_NODE : REF dbg$noun_node;

	    BIND
		DBG$CS_BYTE	= UPLIT BYTE (4, 'BYTE'),
		DBG$CS_WORD	= UPLIT BYTE (4, 'WORD'),
		DBG$CS_LONGWORD	= UPLIT BYTE (8, 'LONGWORD'),
		DBG$CS_ASCII	= UPLIT BYTE (5, 'ASCII'),
		DBG$CS_INSTRUCTION = UPLIT BYTE (11, 'INSTRUCTION'),
		DBG$CS_COLON	= UPLIT BYTE (1, dbg$k_colon),
		DBG$CS_OVERRIDE	= UPLIT BYTE (8, 'OVERRIDE'),
		DBG$CS_QUADWORD = UPLIT BYTE (8, 'QUADWORD'),
		DBG$CS_OCTAWORD = UPLIT BYTE (8, 'OCTAWORD'),
		DBG$CS_FLOAT	= UPLIT BYTE (5, 'FLOAT'),
		DBG$CS_F_FLOAT	= UPLIT BYTE (7, 'F_FLOAT'),
		DBG$CS_D_FLOAT	= UPLIT BYTE (7, 'D_FLOAT'),
		DBG$CS_G_FLOAT	= UPLIT BYTE (7, 'G_FLOAT'),
		DBG$CS_H_FLOAT	= UPLIT BYTE (7, 'H_FLOAT');

	    ! Create and link the length node (the second noun node).

	    IF NOT dbg$nlist_freez (dbg$k_noun_node_size, length_node, .message_vect)
	    THEN
		RETURN sts$k_severe;

	    noun_node [dbg$l_noun_link] = .length_node;

	    ! Look for slash

	    IF dbg$nmatch (.input_desc, dbg$cs_slash, 1)
	    THEN
		BEGIN

		! Must find 'override'

		IF NOT dbg$nmatch (.input_desc, dbg$cs_override, 1)
		THEN
		    BEGIN
		    .message_vect =
		    (IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
		    THEN
			dbg$nmake_arg_vect (dbg$_needmore)
		    ELSE
			dbg$nsyntax_error (dbg$nnext_word (.input_desc)));
		    RETURN sts$k_severe;
		    END;
		
		! Set the verb composite

		verb_node [dbg$b_verb_composite] = set_type_override;

		END

	    ELSE
		BEGIN
		verb_node [dbg$b_verb_composite] = set_type;
		END;

	    ! The verb composite has been set. We must recognize the type specified.

	    SELECTONE true
		OF
		SET

		[dbg$nmatch (.input_desc, dbg$cs_byte, 1)] :
		    BEGIN
		    noun_node [dbg$l_noun_value] = dsc$k_dtype_b;
		    length_node [dbg$l_noun_value] = 1;
		    END;

		[dbg$nmatch (.input_desc, dbg$cs_word, 1)] :
		    BEGIN
		    noun_node [dbg$l_noun_value] = dsc$k_dtype_w;
		    length_node [dbg$l_noun_value] = 2;
		    END;

		[dbg$nmatch (.input_desc, dbg$cs_longword, 1)] :
		    BEGIN
		    noun_node [dbg$l_noun_value] = dsc$k_dtype_l;
		    length_node [dbg$l_noun_value] = 4;
		    END;

		[dbg$nmatch (.input_desc, dbg$cs_quadword, 1)] :
		    BEGIN
		    noun_node [dbg$l_noun_value] = dsc$k_dtype_q;
		    length_node [dbg$l_noun_value] = 8;
		    END;

		[dbg$nmatch (.input_desc, dbg$cs_octaword, 1)] :
		    BEGIN
		    noun_node [dbg$l_noun_value] = dsc$k_dtype_o;
		    length_node [dbg$l_noun_value] = 16;
		    END;

		[dbg$nmatch (.input_desc, dbg$cs_float, 1),
		 dbg$nmatch (.input_desc, dbg$cs_f_float, 1)] :
		    BEGIN
		    noun_node [dbg$l_noun_value] = dsc$k_dtype_f;
		    length_node [dbg$l_noun_value] = 4;
		    END;

		[dbg$nmatch (.input_desc, dbg$cs_d_float, 1) ] :
		    BEGIN
		    noun_node [dbg$l_noun_value] = dsc$k_dtype_d;
		    length_node [dbg$l_noun_value] = 8;
		    END;

		[dbg$nmatch (.input_desc, dbg$cs_g_float, 1) ] :
		    BEGIN
		    noun_node [dbg$l_noun_value] = dsc$k_dtype_g;
		    length_node [dbg$l_noun_value] = 8;
		    END;

		[dbg$nmatch (.input_desc, dbg$cs_h_float, 1) ] :
		    BEGIN
		    noun_node [dbg$l_noun_value] = dsc$k_dtype_h;
		    length_node [dbg$l_noun_value] = 16;
		    END;

		[dbg$nmatch (.input_desc, dbg$cs_instruction, 1)] :
		    BEGIN
		    noun_node [dbg$l_noun_value] = dsc$k_dtype_zi;
		    length_node [dbg$l_noun_value] = 0;
		    END;

		[dbg$nmatch (.input_desc, dbg$cs_ascii, 1)] :
		    BEGIN

		    noun_node [dbg$l_noun_value] = dsc$k_dtype_t;

		    ! There may be a colon followed by integer. If not,
		    ! we use a default length of 4.

		    length_node [dbg$l_noun_value] = 4;

		    ! See if a colon follows

		    IF dbg$nmatch (.input_desc, dbg$cs_colon, 1)
		    THEN
			BEGIN

			! Obtain the integer.

			IF NOT dbg$nsave_decimal_integer (.input_desc,
							  length_node [dbg$l_noun_value],
							  .message_vect)
			THEN
			    RETURN sts$k_severe;

			! Check for a zero length

			IF .length_node [dbg$l_noun_value] EQL 0
			THEN
			    BEGIN

			    ! Set up for an error message

			    OWN
				ZERO_DESC : dbg$stg_desc;

			    zero_desc [dsc$w_length] = 1;
			    zero_desc [dsc$a_pointer] = UPLIT BYTE ('0');

			    .message_vect = dbg$nmake_arg_vect (dbg$_invnumber,
								1,
								zero_desc);
			    RETURN sts$k_severe;
			    END;
			END;
		    END;

		[OTHERWISE] :
		    BEGIN
		    .message_vect =
		    (IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
		    THEN
			dbg$nmake_arg_vect (dbg$_needmore)
		    ELSE
			dbg$nsyntax_error (dbg$nnext_word (.input_desc)));
		    RETURN sts$k_severe;
		    END;

		TES;

	    END;

	[dbg$nmatch (.input_desc, dbg$cs_watch, 1)] : ! Set watch
	    BEGIN
	    LOCAL
		STATUS;		! Holds return status

	    ! Obtain an address expression descriptor

	    IF NOT (status = dbg$nparse_address (.input_desc, noun_node [dbg$l_noun_value],
	  					 dbg$k_default, .message_vect))
	    THEN
		BEGIN

		! Must format syntax errors here if sts$k_warning

		IF .status EQL sts$k_warning
		THEN
		    .message_vect = dbg$nsyntax_error (dbg$nnext_word (.input_desc));
		RETURN sts$k_severe;
		END;

	    ! Set the verb composite

	     verb_node [dbg$b_verb_composite] = set_watch;

	    END;

	[OTHERWISE] : ! Parsing error
	    BEGIN
	    IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
	    THEN
	 	.message_vect = dbg$nmake_arg_vect (dbg$_needmore)
	    ELSE
		.message_vect = dbg$nsyntax_error (dbg$nnext_word (.input_desc));
	    RETURN sts$k_severe;

	    END;

	TES;

    RETURN sts$k_success;

    END;			! End of dbg$nparse_set


GLOBAL ROUTINE DBG$NEXECUTE_SET (VERB_NODE, MESSAGE_VECT) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine processes the command execution tree corresponding to the parsed
!	SET ... command. Appropriate semantic actions are taken.
!
! FORMAL PARAMETERS:
!
!	verb_node -		The head node in the command execution tree
!
!	message_vect -		The address of a longword to contain the address
!				of a message argument vector
!
! IMPLICIT INPUTS:
!
!	dbg$gl_log_buf -	Version 2 debugger pointer to counted string filespec
!
!	dbg$gl_context -	   "    "    "     context switch vector for log and output
!
!	dbg$gb_def_out -	   "    "    "     output control vector
!
!	dbg$gl_logfab -		   "    "    "     FAB for log file
!
!	dbg$gl_lograb -		   "    "    "     RAB  "   "   "
!
! IMPLICIT OUTPUTS:
!
!	Any of the above implicit inputs may be altered
!
! ROUTINE VALUE:	
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	sts$k_severe (4)	 - Signifies that the command was not executed
!
!	sts$k_success (1)	 - Signifies that a command was executed.
!
! SIDE EFFECTS:
!
!	Various semantic actions are performed on data structures. That is, the
!	state of the debugger is altered.
!
!--

    BEGIN

    MAP
	VERB_NODE : REF dbg$verb_node;

    LOCAL
	NOUN_NODE : REF dbg$noun_node;

    ! Recover the noun node

    noun_node = .verb_node [dbg$l_verb_object_ptr];
        
    ! Transfer to a subnetwork on the basis of the composite verb

    CASE .verb_node [dbg$b_verb_composite] FROM  set_break TO set_search
	    OF
	    SET

	    [set_break] :	
		BEGIN
		LOCAL
		    PRIM_DESC,				! Address of primary descriptor
		    ADVERB_NODE : REF dbg$adverb_node,	! Holds the after count
		    ADDR_EXP_DESC : REF dbg$aed,	! Holds the addr exp desc
		    ADDRESS : VECTOR [2],		! Holds the address for break
		    TYPE;				! Holds the type of the address

		! The after count is always supplied. Recover the adverb_node

		adverb_node = .verb_node [dbg$l_verb_adverb_ptr];

		! Recover the address expression descriptor and obtain an address

		addr_exp_desc = .noun_node [dbg$l_noun_value];
		IF NOT dbg$nget_address (.addr_exp_desc, address [0], type, .message_vect)
		THEN
		    RETURN sts$k_severe;

		! Don't want to save a primary descriptor for dbg$k_nc_other

		IF .addr_exp_desc [dbg$b_aed_type] EQL dbg$k_primary_desc
		THEN
		    BEGIN
		    IF NOT dbg$nget_type (.addr_exp_desc [dbg$l_aed_value],
					  type, .message_vect)
		    THEN
			RETURN sts$k_severe;

		    prim_desc = (IF .type EQL dbg$k_nc_other THEN 0 ELSE .addr_exp_desc [dbg$l_aed_value]);
		    END
		ELSE
		    prim_desc = 0;

		! Tuck away the break point

		dbg$gl_context [dbg$k_break] = true;

		IF NOT dbg$save_bpt (.address [0], 0, 
				     .adverb_node [dbg$l_adverb_value],
				     .prim_desc,
				     .message_vect)
		THEN
		    RETURN sts$k_severe;
		END;

	    [set_break_do] :
		BEGIN
		LOCAL
		    ADVERB_NODE : REF dbg$adverb_node,	! Holds the after count
		    ADDR_EXP_DESC : REF dbg$aed,	! Holds the addr exp desc
		    ADDRESS : VECTOR [2],		! Holds the address for break
		    TYPE;				! Holds the type of the address

		! The after count is always supplied. Recover the adverb_node

		adverb_node = .verb_node [dbg$l_verb_adverb_ptr];

		! Recover the address expression descriptor and obtain an address

		addr_exp_desc = .noun_node [dbg$l_noun_value];
		IF NOT dbg$nget_address (.addr_exp_desc, address [0], type, .message_vect)
		THEN
		    RETURN sts$k_severe;

		! The break action buffer address is stored in the second noun node

		noun_node = .noun_node [dbg$l_noun_link];

		! Tuck away the break point

		dbg$gl_context [dbg$k_break] = true;

		IF NOT dbg$save_bpt (.address [0], 
				     .noun_node [dbg$l_noun_value],
				     .adverb_node [dbg$l_adverb_value],
				     (IF .addr_exp_desc [dbg$b_aed_type] EQL dbg$k_primary_desc
				      THEN .addr_exp_desc [dbg$l_aed_value] ELSE 0),
				     .message_vect)
		THEN
		    RETURN sts$k_severe;
		END;

	    [set_exception_break] :
		BEGIN
		dbg$gb_resignal = false;
		END;
	   
	    [set_language] :
		BEGIN
		dbg$set_lang (0, .noun_node [dbg$l_noun_value]);
		END;

	    [set_log] :
		BEGIN
		dbg$gl_log_buf = .noun_node [dbg$l_noun_value];
		IF NOT dbg$nset_log (.message_vect)
		THEN
		    RETURN sts$k_severe;
		END;

    	    [set_margins] :
    		BEGIN
    		dbg$src_left_margin = .noun_node[dbg$l_noun_value];
    		dbg$src_right_margin = .noun_node[dbg$l_noun_value2];
    		END;

    	    [set_max_source_files] :
    		BEGIN
    		dbg$src_set_max_files(.noun_node[dbg$l_noun_value]);
    		END;

	    [set_mode] :
		BEGIN

		! Set the mode level to the correct level

		dbg$set_mod_lvl (user_def_mode);

		! Now fill in the correct mode values

		WHILE .noun_node NEQA 0
		DO
		    BEGIN

		    CASE .noun_node [dbg$l_noun_value] FROM mode_binary TO mode_nosymbls
			OF
			SET

			[mode_binary] :
			    BEGIN
			    dbg$gb_mod_ptr [mode_radix] = binary_radix;
			    END;

			[mode_octal] :
			    BEGIN
			    dbg$gb_mod_ptr [mode_radix] = octal_radix;
			    END;

			[mode_decimal] :
			    BEGIN
			    dbg$gb_mod_ptr [mode_radix] = decimal_radix;
			    END;

			[mode_hex] :
			    BEGIN
			    dbg$gb_mod_ptr [mode_radix] = hex_radix;
			    END;

			[mode_symbls] :
			    BEGIN
			    dbg$gb_mod_ptr [mode_symbols] = true;
			    END;

			[mode_nosymbls] :
			    BEGIN
			    dbg$gb_mod_ptr [mode_symbols] = false;
			    END;

			TES;

		    ! Recover the next noun node

		    noun_node = .noun_node [dbg$l_noun_link];

		    END;     ! End of loop

		END;

	    [set_module] :
		BEGIN
		
		! Module names are stored away as counted strings

		LOCAL
		    NAME_BUFF : REF VECTOR [,BYTE];	! Module name buffer

		WHILE .noun_node NEQA 0
	 	DO
		    BEGIN

		    ! Retrieve the name buffer and call the symbol table

		    name_buff = .noun_node [dbg$l_noun_value];
		    IF NOT dbg$rst_setmod (name_buff [1], .name_buff [0])
		    THEN
			BEGIN
			.message_vect = dbg$nmake_arg_vect (dbg$_nosuchmodu,
							    1,
							    name_buff [0]);
			RETURN sts$k_severe;
			END;

		    ! Obtain the next noun node

		    noun_node = .noun_node [dbg$l_noun_link];

		    END;	! End of Loop
	
		END;

	    [set_module_all] :
		BEGIN
		dbg$rst_setmod (0, 0);
		END;

	    [set_output] :
		BEGIN
		LITERAL
		    NOUN_LITERAL_LOG = 1,
		    NOUN_LITERAL_NOLOG = 2,
		    NOUN_LITERAL_TERMINAL = 3,
		    NOUN_LITERAL_NOTERMINAL = 4,
		    NOUN_LITERAL_VERIFY = 5,
		    NOUN_LITERAL_NOVERIFY = 6;

		! Add the user defined output setting

		WHILE true
		DO
		    BEGIN
		    CASE .noun_node [dbg$l_noun_value] FROM noun_literal_log TO noun_literal_noverify
		        OF
		        SET

		        [noun_literal_log] :
		 	    BEGIN
			    LOCAL
				STATUS,
				B_TYPE;

			    status = dbg$nsetup_log (b_type);
			    IF NOT .status
			    THEN
				output_rms_error (.b_type);
			    dbg$gb_def_out [out_log] = true;
			    END;

			[noun_literal_nolog] :
			    BEGIN
			    IF NOT .dbg$gb_def_out [out_term]
			    THEN
				dbg$nout_info (dbg$_outputlost);
			    dbg$gb_def_out [out_log] = false;
			    END;

			[noun_literal_terminal] :
			    BEGIN
			    dbg$gb_def_out [out_term] = true;
			    END;

			[noun_literal_noterminal] :
			    BEGIN
			    IF NOT .dbg$gb_def_out [out_log]
			    THEN
				dbg$nout_info (dbg$_outputlost);
			    dbg$gb_def_out [out_term] = false;
			    END;

			[noun_literal_verify] :
			    BEGIN
			    dbg$gb_def_out [out_verify] = true;
			    END;

			[noun_literal_noverify] :
			    BEGIN
			    dbg$gb_def_out [out_verify] = false;
			    END;

			TES;

		    ! Check for another object

		    IF .noun_node [dbg$l_noun_link] EQLA 0
		    THEN
		        EXITLOOP;

		    ! Update the noun node

		    noun_node = .noun_node [dbg$l_noun_link];

		    END;	! End of loop

		END;

	    [set_scope] :
		BEGIN
		LOCAL
		    SCOPE_LIST : REF VECTOR [,LONG],
		    BAD_SCOPE,
		    ERR_INDEX;

		! Recover the scope vector

		scope_list = .noun_node [dbg$l_noun_value];

		! Set the scopes

		dbg$rst_setscope (.scope_list, err_index);

		! Check for an error

		IF .err_index NEQ 0
		THEN
		    BEGIN

		    ! Translate the bad scope to a counted string

		    dbg$npathdesc_to_cs (.scope_list [.err_index], bad_scope);

		    ! Format an error message

		    .message_vect = dbg$nmake_arg_vect (dbg$_badscope, 1, .bad_scope);

		    RETURN sts$k_severe;
		    END;
		END;

    	    [set_search] :
    		BEGIN

    	        LITERAL
    		    noun_literal_all = 1,
    		    noun_literal_next = 2,
    		    noun_literal_string = 3,
    		    noun_literal_ident = 4;

    		! First set the search structure to the user defined level
    		!
    		dbg$set_search_lvl (user_def_search);

    		! Add the new user defined settings. Remember the first noun
    		! node has already been recovered.
    		!
    		WHILE TRUE DO
    		    BEGIN
    		    
    		    CASE .noun_node [dbg$l_noun_value] FROM noun_literal_all
    						       TO   noun_literal_ident
    			OF SET

    			[noun_literal_all] : ! SET SEARCH ALL
    			    BEGIN
    			    dbg$gb_search_ptr[search_all] = TRUE;
    			    END;

    			[noun_literal_next] : ! SET SEARCH NEXT
    			    BEGIN
    			    dbg$gb_search_ptr[search_all] = FALSE;
    			    END;

    			[noun_literal_ident] : ! SET SEARCH IDENT
    			    BEGIN
    			    dbg$gb_search_ptr[search_ident] = TRUE;
    			    END;

    			[noun_literal_string] : ! SET SEARCH STRING
    			    BEGIN
    			    dbg$gb_search_ptr[search_ident] = FALSE;
    			    END;

    			TES;

    		    ! Now check for another switch. If none, exit the loop.
    		    !
    		    IF .noun_node [dbg$l_noun_link] EQL 0
    		    THEN
    			EXITLOOP;

    		    ! Update the noun node to the next object
    		    !
    		    noun_node = .noun_node [dbg$l_noun_link];

    		    END;	! End of loop
    	
    		END;

    	    [set_source] :		! Set source directory search list
    		BEGIN

    		dbg$src_set_source(
    		    .noun_node[dbg$l_adjective_ptr],
    		    .noun_node[dbg$l_noun_value]);

    		END;

	    [set_step] :		! Set step values
		BEGIN

		LITERAL				! Legal objects
		    NOUN_LITERAL_LINE = 1,
		    NOUN_LITERAL_INSTRUCTION = 2,
		    NOUN_LITERAL_INTO = 3,
		    NOUN_LITERAL_OVER = 4,
		    NOUN_LITERAL_SYSTEM = 5,
		    NOUN_LITERAL_NOSYSTEM = 6,
    		    NOUN_LITERAL_SOURCE = 7,
    		    NOUN_LITERAL_NOSOURCE = 8;

		! First set the step structure pointer to the user defined leverl

		dbg$set_stp_lvl (user_def_step);

		! Add the new user defined setting. Remember the first noun node
		! has already been recovered.

		WHILE true
		DO
		    BEGIN

		    CASE .noun_node [dbg$l_noun_value] FROM noun_literal_line
						       TO   noun_literal_nosource
			OF
			SET

			[noun_literal_line] :	! SET STEP LINE
			    BEGIN
			    dbg$gb_stp_ptr [step_line] = true;
			    END;

			[noun_literal_instruction] : ! SET STEP INSTRUCTION
			    BEGIN
			    dbg$gb_stp_ptr [step_line] = false;
			    END;

			[noun_literal_into] :	! SET STEP INTO
			    BEGIN
			    dbg$gb_stp_ptr [step_over] = false;
			    END;

			[noun_literal_over] :	! SET STEP OVER
			    BEGIN
			    dbg$gb_stp_ptr [step_over] = true;
			    END;

			[noun_literal_system] : ! SET STEP SYSTEM
			    BEGIN
			    dbg$gb_stp_ptr [step_nosystem] = false;
			    END;

			[noun_literal_nosystem] : ! SET STEP NOSYSTEM
			    BEGIN
			    dbg$gb_stp_ptr [step_nosystem] = true;
			    END;

    		 	[noun_literal_source] : ! SET STEP SOURCE
    			    BEGIN
    			    dbg$gb_stp_ptr [step_source] = true;
    			    END;

    			[noun_literal_nosource] : ! SET STEP NOSOURCE
    			    BEGIN
    			    dbg$gb_stp_ptr [step_source] = false;
    			    END;

			TES;

		    ! Now check for another switch. If none, exit the loop

		    IF .noun_node [dbg$l_noun_link] EQLA 0
		    THEN
		        EXITLOOP;

		    ! Update the noun node to the next object

		    noun_node = .noun_node [dbg$l_noun_link];

		    END;	! End of loop

		END;

	    [set_trace] : ! Setting a tracepoint
		BEGIN
		LOCAL
		    PRIM_DESC,			 ! Pointer to primary descriptor
		    ADDR_EXP_DESC : REF dbg$aed, ! address expression descriptor
		    ADDRESS : VECTOR [2],	 ! Address for tracepoint
		    TYPE;			 ! Type of address in aed

		! Recover the address expression descriptor

		addr_exp_desc = .noun_node [dbg$l_noun_value];

		! Obtain the address for the tracepoint

		IF NOT dbg$nget_address (.addr_exp_desc, address [0],
					 type, .message_vect)
		THEN
		    RETURN sts$k_severe;

	 	! Don't want to save a primary descriptor for dbg$k_nc_other

		IF .addr_exp_desc [dbg$b_aed_type] EQL dbg$k_primary_desc
		THEN
		    BEGIN
		    IF NOT dbg$nget_type (.addr_exp_desc [dbg$l_aed_value],
					  type, .message_vect)
		    THEN
			RETURN sts$k_severe;

		    prim_desc = (IF .type EQL dbg$k_nc_other THEN 0 ELSE .addr_exp_desc [dbg$l_aed_value]);
		    END
		ELSE
		    prim_desc = 0;

		! Now set the trace point

		dbg$gl_context [dbg$k_trace] = true;

		IF NOT dbg$save_bpt (.address [0], 0, 0,
				     .prim_desc,
				     .message_vect)
		THEN
		    RETURN sts$k_severe;
		END;

	    [set_trace_calls] :
		BEGIN
		dbg$gl_context [dbg$k_trce_call] = true;
		dbg$gl_runframe [dbg$v_trace_all] = true;
		dbg$set_optrace (calls_token);
		true
		END;

	    [set_trace_branch] :
		BEGIN
		dbg$gl_context [dbg$k_trce_brch] = true;
		dbg$gl_runframe [dbg$v_trace_all] = true;
		dbg$set_optrace (branch_token);
		END;

	    [set_type] :
		BEGIN
		LOCAL
		    LENGTH_NODE : REF dbg$noun_node;

		! We always have a second noun node (containing the length).

		length_node = .noun_node [dbg$l_noun_link];

		dbg$gl_dflttyp = .noun_node [dbg$l_noun_value];
		dbg$gw_dfltleng = .length_node [dbg$l_noun_value];
		END;

	    [set_type_override] :
		BEGIN
		LOCAL
		    LENGTH_NODE : REF dbg$noun_node;

		! We always have a second noun node (containing the length).

		length_node = .noun_node [dbg$l_noun_link];

		dbg$gl_gbltyp = .noun_node [dbg$l_noun_value];
		dbg$gw_gbllngth = .length_node [dbg$l_noun_value];
		END;

	    [set_watch] : ! Setting a watchpoint
		BEGIN
		LOCAL
		    PRIM_DESC,			! Pointer to primary descriptor
		    ADDR_EXP_DESC : REF dbg$aed,! Address expression descriptor
		    ADDRESS : VECTOR [2],	! Holds address for watchpoint
		    LENGTH,			! Length of watchpoint
		    TYPE;			! Holds type of address

		! Recover the address expression descriptor

		addr_exp_desc = .noun_node [dbg$l_noun_value];

		! Obtain the address for the watchpoint

		IF NOT dbg$nget_address (.addr_exp_desc, address [0],
					 type, .message_vect)
		THEN
		    RETURN sts$k_severe;

		! Determine the length for the watchpoint. If we have a primary
		! descriptor, we call get_length. For anything else, we use 
		! a length of 4 bytes.

		IF .addr_exp_desc [dbg$b_aed_type] EQL dbg$k_primary_desc
		THEN
		    BEGIN

		    ! Check for a named constant, If we have one, use a length of 4

		    IF NOT dbg$nget_type (.addr_exp_desc [dbg$l_aed_value],
					  type,
					  .message_vect)
		    THEN
			RETURN sts$k_severe;

		    IF .type EQL dbg$k_other
		    THEN
			BEGIN

			IF NOT dbg$nget_length (.addr_exp_desc [dbg$l_aed_value],
					        length,
					        .message_vect)
		    	THEN
			    RETURN sts$k_severe;

		    	length = (IF .length MOD %BPUNIT EQL 0 
				  THEN .length / %BPUNIT
				  ELSE (.length / %BPUNIT) + 1);
			END
		    ELSE
			BEGIN
			length = 4;	! Named constant of one flavor or another
			END;
		    END
		ELSE
		    BEGIN
		    length = 4;
		    END;

		! Don't want to save a primary descriptor for dbg$k_nc_other

		IF .addr_exp_desc [dbg$b_aed_type] EQL dbg$k_primary_desc
		THEN
		    BEGIN
		    IF NOT dbg$nget_type (.addr_exp_desc [dbg$l_aed_value],
					  type, .message_vect)
		    THEN
			RETURN sts$k_severe;

		    prim_desc = (IF .type EQL dbg$k_nc_other THEN 0 ELSE .addr_exp_desc [dbg$l_aed_value]);
		    END
		ELSE
		    prim_desc = 0;

		! Call save_bpt to tuck away the watchpoint. Supply a primary
		! descriptor, if there is one. 

		dbg$gl_context [dbg$k_watch] = true;

		IF NOT dbg$save_bpt (.address [0], 0, .length,
				     .prim_desc,
				     .message_vect)
		THEN
		    RETURN sts$k_severe;
		END;

	    [INRANGE, OUTRANGE] :
		BEGIN
		.message_vect = dbg$nmake_arg_vect (dbg$_notimplan, 1,
				    UPLIT BYTE (17, 'full verb support'));
		RETURN sts$k_severe;    
		END;

	    TES;

    RETURN sts$k_success;

    END;			! End of dbg$nexecute_set

GLOBAL ROUTINE DBG$NSET_LOG  (MESSAGE_VECT) =
!++
! FUNCTIONAL DESCRIPTION:
!	This routine closes any log file that is currently open and opens
! the file specified by the user in SET LOG "filespec"
!
! FORMAL PARAMETERS:
!	
!	message_vect	- The address of a longword to contain the address of a
!			  message argument vector
!
! IMPLICIT INPUTS:
!	The RMS-set IFI (internal file identifier field) bit is used to
! determine if a previous log file is still open.
!
!	dbg$gl_log_buf _ 	pointer to log filespec buffer
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!
!	sts$k_severe (4) -	the log could not be set to the specified filespec
!
!	sts$k_success (1) -	the log file was set to the user specified filespec
!
! SIDE EFFECTS:
!	Any previously open log file is closed and a new log file is opened.
! Logging is inhibited for the duration of this routine.
!--

	BEGIN
	
	LOCAL
		STATUS,
		OPENED_LOG,
		FNS : BYTE,
		FNA,
		OLD_NAM_PTR,
		B_TYPE,
		TEMP_NAM : REF $NAM_DECL,
		TEMP_FSE : REF VECTOR [,BYTE],
		TEMP_FSR : REF VECTOR [,BYTE],
		LOG_TEMP : BYTE;
	
	opened_log = FALSE ;

	! inhibit logging until we can redirect the log file

	log_temp = .dbg$gb_def_out [out_log];
	dbg$gb_def_out [out_log] = FALSE;

	! see if a log file has been previously opened. If so, close it,
	! since it must be CLOSEd befor we can do the new $PARSE.

	IF .dbg$gl_logfab [fab$w_ifi] NEQ 0
	THEN
		BEGIN

		opened_log = TRUE;
		fna = .dbg$gl_logfab [fab$l_fna];
		fns = .dbg$gl_logfab [fab$b_fns];

		status = $CLOSE (FAB = dbg$gl_logfab);
		IF NOT .status
		THEN
			BEGIN

			LOCAL
				MSG_DESC : REF dbg$stg_desc;

			IF NOT dbg$nlist_freez (2, msg_desc, .message_vect)
			THEN
			    RETURN sts$k_severe;

			build_error_desc (msg_desc);
			.message_vect = dbg$nmake_arg_vect
						 (shr$_closeout+dbg_fac_code, 
						  1, .msg_desc,
			       			  .dbg$gl_logfab[fab$l_sts],
						  .dbg$gl_logfab[fab$l_stv]); 

			RETURN sts$k_severe;

			END;

		! get new NAM block, preserve the original

		IF NOT dbg$nfreez ((nam$c_bln+3) / %UPVAL, temp_nam, .message_vect)
		THEN
		    RETURN sts$k_severe;

		$nam_init (nam = .temp_nam);
		IF NOT dbg$nfreez ((nam$c_maxrss+3)/%UPVAL, temp_fse, .message_vect)
		THEN
		    RETURN sts$k_severe;

		IF NOT dbg$nfreez ((nam$c_maxrss+3)/%UPVAL, temp_fsr, .message_vect)
		THEN
		    RETURN sts$k_severe;

		temp_nam [nam$l_esa] = .temp_fse;
		temp_nam [nam$l_rsa] = .temp_fsr;
		temp_nam [nam$b_ess] = nam$c_maxrss;
		temp_nam [nam$b_rss] = nam$c_maxrss;
		dbg$gl_logfab [fab$l_nam] = .temp_nam;
		old_nam_ptr = .dbg$gl_lognam;
		dbg$gl_lognam = .temp_nam;

		END;

	! reset the appropriate FAB file process options

	dbg$gl_logfab [fab$v_cif] = 0;
	dbg$gl_logfab [fab$v_mxv] = 1;
	dbg$gl_logfab [fab$v_nam] = 0;

	! Set up file name

	IF .dbg$gl_log_buf NEQ 0
	THEN
		BEGIN

		MAP
		    DBG$GL_LOG_BUF : REF VECTOR [,BYTE];

		dbg$gl_logfab [fab$l_fna] = .dbg$gl_log_buf + 1; ! filename addr starts in 2nd byte
		dbg$gl_logfab [fab$b_fns] = .dbg$gl_log_buf [0];  ! 1st byte is count

		! Parse the filespec to see if an explicit version number was
		! given. If so set the CIF bit, otherwise we must maximize
		! the version number.

		status = $PARSE (FAB = dbg$gl_logfab);
		IF NOT .status
		THEN
			BEGIN
			LOCAL
				STS,
				STV,
				MSG_DESC : REF dbg$stg_desc;

			IF NOT dbg$nlist_freez (2, msg_desc, .message_vect)
			THEN
			    RETURN sts$k_severe;

			! save these because restore_nam will reset them

			sts = .dbg$gl_logfab [fab$l_sts];
			stv = .dbg$gl_logfab [fab$l_stv];
			build_error_desc (msg_desc);

			IF .opened_log
			THEN
				restore_nam 
			ELSE
				BEGIN
				dbg$gl_logfab [fab$l_fna] = 0;
				dbg$gl_logfab [fab$b_fns] = 0;
				dbg$gl_log_buf	= 0;
				END;

			.message_vect = dbg$nmake_arg_vect
					 (shr$_syntax + dbg_fac_code,
					  1, .msg_desc, .sts, .stv);

			RETURN sts$k_severe;

			END;

		IF .dbg$gl_lognam [nam$v_exp_ver]
		THEN
			BEGIN
			dbg$gl_logfab [fab$v_cif] = 1;
			dbg$gl_logfab [fab$v_mxv] = 0;
			END;

		dbg$gl_logfab [fab$v_nam] = 1;		! open by NAM block since
		END;					! we've already parsed the filespec

	! now open the new log file

	status = dbg$nsetup_log (b_type);
	IF NOT .status
	THEN
		BEGIN
		LOCAL 
			MSG_DESC : REF dbg$stg_desc,
			STS,
			STV;

		IF NOT dbg$nlist_freez (2, msg_desc, .message_vect)
		THEN
		    RETURN sts$k_severe;

		build_error_desc (msg_desc);
		IF .b_type EQL 1
		THEN
			BEGIN
			sts = .dbg$gl_logfab [fab$l_sts];
			stv = .dbg$gl_logfab [fab$l_stv];
			END
		ELSE
			BEGIN
			sts = .dbg$gl_lograb [rab$l_sts];
			stv = .dbg$gl_lograb [rab$l_stv];
			END;

		IF .opened_log
		THEN
			restore_nam 
		ELSE
			BEGIN
			dbg$gl_logfab [fab$l_fna] = 0;
			dbg$gl_logfab [fab$b_fns] = 0;
			dbg$gl_log_buf	= 0;
			dbg$gl_logfab [fab$v_nam] = 0;
			END;

		.message_vect = dbg$nmake_arg_vect
				 (shr$_openout+dbg_fac_code, 3,
				 .msg_desc, .sts, .stv);

		RETURN sts$k_severe;

		END;

	! restore logging status and free temp storage

	dbg$gb_def_out [out_log] = .log_temp;		
	IF .opened_log
	THEN
	
		! Cleanup the "original" NAM block

		BEGIN
		IF NOT dbg$nfreerelease (.old_nam_ptr, .message_vect)
		THEN
		    RETURN sts$k_severe;

		IF NOT dbg$nfreerelease (.dbg$gb_logfse, .message_vect)
		THEN
		    RETURN sts$k_severe;

		IF NOT dbg$nfreerelease (.dbg$gb_logfsr, .message_vect)
		THEN
		    RETURN sts$k_severe;

		dbg$gb_logfsr = .temp_fsr;
		dbg$gb_logfse = .temp_fse;

		! Release the buffer that holds the log file spec. Since this
		! is a counted string we have to adjust the address to free

		IF .fns NEQ 0
		THEN
			IF NOT dbg$nfreerelease (.fna-1, .message_vect)
			THEN
			    RETURN sts$k_severe;
		END;

	RETURN sts$k_success;

	END;

ROUTINE DBG$NSETUP_LOG (BLOCK_TYPE)  =
!++
! FUNCTIONAL DESCRIPTION:
!	This routine creates and opens the log file.
!
! FORMAL PARAMETERS:
!
!	block_type - indicates whether error to report is for 
!		     FAB ( = 1) or RAB ( = 2)
!
! IMPLICIT INPUTS:
!
!	dbg$gl_log_buf - 	pointer to log filespec buffer
!
! IMPLICIT OUTPUTS:
!	The resultant LOG file-spec as resolved by RMS
!
! ROUTINE VALUE:
!	Returns the RMS status code if there's an error, otherwise returns TRUE
!
! SIDE EFFECTS:
!	The log file is created and a RAB connected to it.
!--

	BEGIN
	
	LOCAL 
		STATUS;
	MAP
		DBG$GL_LOG_BUF : REF VECTOR [,BYTE];

	! See if a log file is already open

	IF .dbg$gl_logfab [fab$w_ifi] NEQ 0
	THEN
		RETURN sts$k_success;

	.block_type = 1;
	status = $CREATE(FAB = dbg$gl_logfab);

	IF NOT .status
	THEN
		RETURN (.status) ;

	dbg$gl_lograb [rab$l_fab] = dbg$gl_logfab;
	.block_type = 2;
	status = $CONNECT (RAB = dbg$gl_lograb);

	IF NOT .status
	THEN
		RETURN (.status) ;


	! Eventually put out the title line here

	RETURN true;

	END;		! END OF DBG$NSET_UP_LOG

END				! End of module
ELUDOM
