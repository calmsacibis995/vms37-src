MODULE DBGMOD (IDENT = 'V03-000') =
BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! FACILITY:	DEBUG
!
!++
! FUNCTIONAL DESCRIPTION:
!
! ABSTRACT:
!
! Version:	1.08
!
! History:
!	Author:
!		Carol Peters, 03 Jul 1976: Version 01
!
!	Modified by:
!		Mike Candela, 18 October 1979
!		Richard Title, 12 AUG 1981
!
! Revision history:
! 1.01	19-SEP-78	MCC	Made DECIMAL the default radix for all
!				languages except MACRO.
! 1.02	22-SEP-78	DAR	Deleted reference to def_mode_length and
!				def_fortran_no.
! 1.03	03-OCT-78	DAR	Fixed bug in DBG$SET_STP_LVL.
! 1.04	30-NOV-78	DAR	Default radix is hexadecimal for MACRO and BLISS
!				it's decimal for all other languages.
!				The default step unit is instruction for MACRO
!				and BLISS, it's line for all other languages.
! 1.05	15-JAN-79	MCC	The default step type is into routine calls for COBOL-74
! 1.06	14-MAR-79	MCC	Added routines to handle SET and SHOW for OUTPUT
!				configuration
! 1.07	25-JUL-79	MCC	Added routine dbg$verify_out to decide when
!				to verify input.
! 1.08	18-OCT-79	MCC	Added support for SHOW LOG in dbg$show_output
! 3.00  21-Aug-81	 RT	Added support for SET STEP SOURCE and
!				SET STEP NOSOURCE
! 3.01	20-Oct-81	 RT	Added support for SEARCH command.
!--

! TABLE OF CONTENTS:
!
FORWARD ROUTINE
	dbg$init_modes:  NOVALUE,		! SETS MODES TO A SPECIFIED level
	dbg$set_mod_def: NOVALUE,		! SETS DEFAULT MODES TO INITIALIZATION values
	dbg$set_mod_lst: NOVALUE,		! SETS A LIST OF MODES
	dbg$set_mod_lvl: NOVALUE,		! SETS level OF MODES
	dbg$set_new_mod: NOVALUE,		! SETS A NEW MODE
	dbg$show_mode:   NOVALUE,		! ACTION ROUTINE TO SHOW DEFAULT modes
	dbg$init_step:   NOVALUE,		! SETS step LEVELS AS SPECIFIED
	dbg$set_stp_def: NOVALUE,		! RESETS step LEVELS TO INITIALIZATION VALUES
	dbg$set_stp_lst: NOVALUE,		! SETS A LIST OF steps
	dbg$set_stp_lvl: NOVALUE,		! SETS level OF step
	dbg$set_new_stp: NOVALUE,		! SETS A NEW step VALUE
	dbg$show_step:   NOVALUE,		! ACTION ROUTINE TO SHOW step
    	dbg$init_search: NOVALUE,		! resets search levels to initial
    	dbg$set_search_def: NOVALUE,		! sets search levels as specified
    	dbg$set_search_lst: NOVALUE,		! sets a list of SEARCH settings
    	dbg$set_search_lvl: NOVALUE,		! set level of search
    	dbg$set_new_search: NOVALUE,		! sets a new search value
    	dbg$show_search: NOVALUE,		! action routine for show search
 	dbg$set_out_def: NOVALUE,		! Sets default OUTPUT config
	dbg$set_out_lst: NOVALUE,		! Sets a list of OUTPUT settings
	dbg$show_output: NOVALUE,		! Displays OUTPUT configuration
	dbg$set_log:     NOVALUE,		! Set a new LOG file name
	setup_log:       ,			! Creates & opens log file
	dbg$verify_out:	 NOVALUE;		! Decides whether to VERIFY input
!
! REQUIRE FILES:
!
REQUIRE 'src$:DBGPROLOG.REQ';

REQUIRE 'SRC$:DBGPCT.REQ';
REQUIRE 'src$:DBGGEN.REQ';
REQUIRE 'src$:comter.req';
REQUIRE 'SRC$:BSTRUC.REQ';
REQUIRE 'SRC$:SYSSER.REQ';


EXTERNAL ROUTINE
	dbg$freez,				! allocate block of free storage
	dbg$freerelease;			! return storage to free pool

EXTERNAL
	dbg$gb_def_stp: VECTOR [, BYTE],	! BLOCK FOR Step types
	dbg$gb_stp_ptr: REF VECTOR [, BYTE],	! pointer TO Step types
    	dbg$gb_def_search: VECTOR [, BYTE],	! Block for SEARCH settings
    	dbg$gb_search_ptr: REF VECTOR [, BYTE],	! pointer to search settings
	dbg$gb_def_mod: VECTOR [, BYTE],	! BLOCK FOR MODES
	dbg$gb_def_out: VECTOR [, BYTE],	! Vector for output config
	dbg$gl_cishead: REF cis_link,		! Head of cis
	dbg$gb_verptr : REF VECTOR [,BYTE],	! Verify pointer
	dbg$gb_mod_ptr: REF VECTOR [, BYTE],	! pointer TO MODES
	dbg$gl_context : BITVECTOR,		! CONTEXT WORD
	dbg$gl_head_lst,			! HEAD OF ARGUMENT LIST
	dbg$gb_language: BYTE,			! contains index to current language
	dbg$gl_lognam : REF $NAM_DECL,		! NAM block for LOG file
	dbg$gl_logfab : BLOCK [,BYTE],		! FAB for LOG file
	dbg$gl_lograb : BLOCK [,BYTE],		! RAB for LOG file
	dbg$gb_logfsr : REF VECTOR [,BYTE],	! Resultant LOG filespec buffer
	dbg$gb_logfse : REF VECTOR [,BYTE],	! Expanded LOG filespec buffer
	dbg$gl_log_buf;				! pointer to buffer containing
						! filespec from SET LOG cmd.

LITERAL
	dbg_mod		= 0,			! DEBUGGING AID FOR mode
	dbg_mod1	= 0,			! DEBUGGING AID FOR step
	dbg_mod2	= 0;			!      "     "   "  log file 

!++
! The following table holds the valid mode settings and values
! relevant to them. Each entry in the table is three bytes long.
! The entry has three fields, each of them one byte
! long.
!
!	-------------------------------
!	! keyword !  offset ! value !
!	-------------------------------
!
! The keyword field holds the token value that represents the particular
! mode, e.g., byte_token indicates that the mode is BYTE.
! The offset field holds the location of the mode setting in any of
! the mode levels.
! The value field holds the value that represents a particular mode
! to DEBUG in an internal sense.
!
LITERAL
	keyword_field	= 0,
	offset_field	= 1,
	value_field	= 2,
	mode_entry_len	= 3,
	step_entry_len  = 3,
    	search_entry_len = 3;

BIND
	mode_table	= UPLIT BYTE (

	byte_token,	mode_length,	byte_length,
	word_token,	mode_length,	word_length,
	long_token,	mode_length,	long_length,
	decimal_token,	mode_radix,	decimal_radix,
	hexadecim_token,mode_radix,	hex_radix,
	octal_token,	mode_radix,	octal_radix,
	instruct_token,	mode_instruc,	TRUE,
	noinstruc_token,mode_instruc,	FALSE,
	ascii_token,	mode_ascii,	TRUE,
	noascii_token,	mode_ascii,	FALSE,
	symbols_token,	mode_symbols,	TRUE,
	nosymbols_token,mode_symbols,	FALSE,
	scope_token,	mode_scope,	TRUE,
	noscope_token,	mode_scope,	FALSE,
	global_token,	mode_globals,	TRUE,
	noglobal_token,	mode_globals,	FALSE,
	immed_nam_token,mode_immediate, TRUE,
	noimmed_n_token,mode_immediate, FALSE,
	label_token,	mode_fortran,	label_mode,
	line_token,	mode_fortran,	line_mode,
	literal_token,	mode_fortran,	literal_mode,

	0 ) : VECTOR [, BYTE];
    
BIND	
	step_table	= UPLIT BYTE (
  
	instruct_token, step_line,	FALSE,
	stepline_token, step_line,	TRUE,
	into_token,     step_over,	FALSE,
	over_token,     step_over,	TRUE,
	system_token,   step_nosystem,	FALSE,
	nosystem_token, step_nosystem,	TRUE,
	source_token,	step_source,	TRUE,
	nosource_token,	step_source,	FALSE,
	0 ) : VECTOR [,BYTE];

BIND
    	search_table 	= UPLIT BYTE (
    	
    	all_token,	search_all,	TRUE,
    	next_token,	search_all,	FALSE,
    	ident_token,	search_ident,	TRUE,
    	string_token,	search_ident,	FALSE,
    	0 ) : VECTOR [,BYTE];

BIND
	deflog_name = UPLIT BYTE(%ASCII 'DEBUG.LOG'),
	deflog_size = %CHARCOUNT(%ASCII 'DEBUG.LOG');

! build_err_desc creates a descriptor that contains the filespec for RMS error
! reporting using the shared message file
	
MACRO
	build_err_desc (msg_desc) = 

	IF .dbg$gl_log_buf NEQ 0
	THEN
		BEGIN
		msg_desc [dsc$w_length]  = .dbg$gl_logfab [fab$b_fns];
		msg_desc [dsc$a_pointer] = .dbg$gl_logfab [fab$l_fna];
		END
	ELSE
		BEGIN
		msg_desc [dsc$w_length]  = .dbg$gl_logfab [fab$b_dns];
		msg_desc [dsc$a_pointer] = .dbg$gl_logfab [fab$l_dna];
		END %,

! signal_rms_err reports RMS errors caused by $CREATE, $OPEN or $CONNECT 

	signal_rms_err (block_type) =
		BEGIN
		LOCAL
			msg_desc : BLOCK [8,BYTE], 
			sts,
			stv ;

		build_err_desc (msg_desc) ;
		IF block_type EQL 1
		THEN
			BEGIN
			sts = .dbg$gl_logfab [fab$l_sts];
			stv = .dbg$gl_logfab [fab$l_stv];
			END
		ELSE
			BEGIN
			sts = .dbg$gl_lograb [rab$l_sts];
			stv = .dbg$gl_lograb [rab$l_stv];
			END;
		SIGNAL (shr$_openout+dbg_fac_code, 1, msg_desc, .sts, .stv);
		END %,

! restore_nam restores an RMS NAM block 

	restore_nam =
		BEGIN
		LOCAL
			err,
			type_b;

		! release storage for the aborted log file

		dbg$freerelease ( .temp_nam, (nam$c_bln+3)/%UPVAL);
		dbg$freerelease ( .temp_fsr, (nam$c_maxrss+3)/%UPVAL);
		dbg$freerelease ( .temp_fse, (nam$c_maxrss+3)/%UPVAL);
		dbg$gl_lognam = .old_nam_ptr;
		old_nam_ptr = 0;
		dbg$gl_logfab [fab$l_nam] = .dbg$gl_lognam;
		dbg$gl_logfab [fab$l_fna] = .fna;
		dbg$gl_logfab [fab$b_fns] = .fns;

		dbg$gl_logfab [fab$v_nam] = 1;
		dbg$gl_logfab [fab$v_cif] = 1;
		dbg$gl_logfab [fab$v_mxv] = 0;
		err = setup_log(type_b);
		IF NOT .err
		THEN
			signal_rms_err (.type_b) ;

		dbg$gb_def_out [out_log] = .log_temp ;
		END%;

GLOBAL ROUTINE dbg$init_modes (goal_level, source_level) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	Sets all levels from local level to the goal level specified
!	with the mode settings of the source level.
!
! FORMAL PARAMETERS:
!	goal_level	- highest level to set
!	source_level	- level from which to obtain mode settings
!
! IMPLICIT INPUTS:
!	none
!
! IMPLICIT OUTPUTS:
!	THE mode settings of the local level to the goal level
!	are reset to the mode settings of the source level.
!
! Routine value:
!	NOVALUE
!
! SIDE EFFECTS:
!	NONE
!--

	BEGIN

	LOCAL
		temp_level: REF VECTOR [, BYTE];

%IF dbg_mod
%THEN
	$fao_tt_out ('copying level !SL modes to level !SL thru !SL',
			 .source_level, .goal_level, local_mode);
%FI

	temp_level = dbg$gb_def_mod [.source_level * mode_lvl_size];
	DECR I FROM local_mode TO .goal_level DO
		BEGIN
		dbg$gb_mod_ptr = dbg$gb_def_mod [.I * mode_lvl_size];
		dbg$gb_mod_ptr [mode_radix] = .temp_level [mode_radix];
		dbg$gb_mod_ptr [mode_length] = .temp_level [mode_length];
		dbg$gb_mod_ptr [mode_symbols] = .temp_level [mode_symbols];
		dbg$gb_mod_ptr [mode_instruc] = .temp_level [mode_instruc];
		dbg$gb_mod_ptr [mode_ascii] = .temp_level [mode_ascii];
		dbg$gb_mod_ptr [mode_scope] = .temp_level [mode_scope];
		dbg$gb_mod_ptr [mode_globals] = .temp_level [mode_globals];
		dbg$gb_mod_ptr [mode_immediate] = .temp_level [mode_immediate];
		dbg$gb_mod_ptr [mode_fortran] = .temp_level [mode_fortran];
		END;
	END;

GLOBAL ROUTINE dbg$set_mod_def : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	CANCELS USER SET DEFAULTS FOR MODE SETTINGS.
!	RESETS ALL MODE LEVELS TO LANGUAGE DEFAULTS.
!	Called from  DBG$INIT_DEBUG as part of the
!	once-only initialization phase of DEBUG.
!
! FORMAL PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	THE DEFAULT MODES
!
! IMPLICIT OUTPUTS:
!	NONE
!
! Routine value:
!	NOVALUE
!
! SIDE EFFECTS:
!	NONE
!--

	BEGIN

%IF dbg_mod
%THEN
	$fao_tt_out ('initializing modes, language byte is !SB', .dbg$gb_language);
%FI

	!+
	! Set up the MODE data structure
	!-

	dbg$gb_mod_ptr = dbg$gb_def_mod [default_mode * mode_lvl_size];

	IF .dbg$gb_language EQL lang_macro
	OR .dbg$gb_language EQL lang_bliss
	THEN
	    dbg$gb_mod_ptr [mode_radix] = hex_radix
	ELSE
	    dbg$gb_mod_ptr [mode_radix] = decimal_radix;

	dbg$gb_mod_ptr [mode_length] = long_length;
	dbg$gb_mod_ptr [mode_symbols] = TRUE;
	dbg$gb_mod_ptr [mode_instruc] = FALSE;
	dbg$gb_mod_ptr [mode_ascii] = FALSE;
	dbg$gb_mod_ptr [mode_scope] = TRUE;
	dbg$gb_mod_ptr [mode_globals] = FALSE;
	dbg$gb_mod_ptr [mode_immediate] = TRUE;
	dbg$gb_mod_ptr [mode_fortran] = 0;
	dbg$init_modes (user_def_mode, default_mode);
	END;

GLOBAL ROUTINE dbg$set_mod_lst (level) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	SETS A LIST OF MODES AT THE SPECIFIED LEVEL.
!	FIRST THE LEVEL IS CHANGED VIA A CALL TO DBG$SET_MOD_LVL
!	THEN THE COMMAND ARGUMENT LIST IS SCANNED UNTIL THE END
!	CALLING DBG$SET_NEW_MOD WITH THE TOKEN VALUE TO BE SET.
!
! FORMAL PARAMETERS:
!	level	- level AT WHICH TO SET MODES
!
! IMPLICIT INPUTS:
!	-THE ADDRESS OF THE LINKED LIST WHICH HOLDS THE SWITCHES.
!	-THE GLOBAL pointerS TO THE CURRENT MODE levelS.
!
! IMPLICIT OUTPUTS:
!	NONE
!
! Routine value:
!	NOVALUE
!
! SIDE EFFECTS:
!	NONE
!--

	BEGIN

	LOCAL
		pointer;

%IF dbg_mod
%THEN
	$fao_tt_out ('set_mod_lst: new level is !SL', .level);
%FI

	dbg$set_mod_lvl (.level);
	pointer = .dbg$gl_head_lst;
	DO
		dbg$set_new_mod ( .list_elem_exp1 (.pointer) )
		UNTIL (pointer = .list_elem_flink (.pointer)) EQLA 0;
	END;

!++
! THE FOLLOWING ROUTINES CONTROL INTERPRETATION AND TYPEOUT MODES.
!
!	ADDRESS INTERPRETATION AND DATA TYPEOUT ARE CONTROLLED BY FOUR MODE
!	SETTINGS. THEY ARE 'DEFAULT_MODE', WHICH IS THE MODE SET BY
!	DEBUG INITIALIZATION; 'user_def_mode', WHICH IS THE MODE SET
!	BY USER 'SET DEFAULT' COMMANDS; 'override_mode', WHICH IS
!	THE MODE SET BY A SINGLE LINE OVERRIDE MODE COMMAND; AND
!	'local_mode', WHICH IS THE MODE SET FOR A SINGLE VARIABLE.
!	WHICH MODE IS USED DEPENDS ON THE pointer INTO THE BLOCK
!	dbg$gb_def_mod.
!
!	AT INITIALIZATION TIME, THE FOUR MODE SETTINGS ARE INITIALIZED
!	TO THE SAME values. WHEN THESE values ARE CHANGED BY USER COMMANDS,
!	SOME PROPAGATION OF MODE values MUST MOVE UP AND DOWN THROUGH THE
!	DIFFERENT BLOCKS SO THAT THE ITEMS DISPLAYED OR INTERPRETED WILL
!	HAVE VALID AND TIMELY MODE SETTINGS FOR BOTH RADIX AND LENGTH.
!
!	THE ROUTINES THAT FOLLOW SET THE MODE BLOCK pointerS TO THEIR NEW
!	value AND PROPAGATE values AS NECESSARY.
!
!	THE GENERAL STRATEGY IS AS FOLLOWS:
!	DEFAULT_MODE SETTINGS ARE NEVER CHANGED
!	user_def_mode SETTINGS ARE NEVER CHANGED AS A RESULT OF pointer JIGGLING.
!		THEY ARE ONLY CHANGED EXPLICITLY IN ACTION ROUTINES.
!	override_mode SETTINGS ARE CHANGED TO REFLECT USER-SET DEFAULTS 
!		WHEN THEY ARE THE OBJECT OF THE pointer.
!	local_mode SETTINGS ARE COPIED FROM override_mode SETTINGS WHEN THEY
!		ARE THE OBJECT OF THE pointer.
!	WHEN THE pointer IS MOVING UP THE BLOCK, FROM local_mode TOWARD
!		DEFAULT_MODE, NO values ARE PROPAGATED.
!	SETTING OF local_mode AND override_mode TO DEFAULT SETTINGS AT THE END OF
!		A COMMAND LINE IS THE EXPLICIT RESPONSIBILITY OF EOC ACTION
!		ROUTINE.
!--

GLOBAL ROUTINE dbg$set_mod_lvl (level) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION
!	SEE DESCRIPTION ON PAGE 2
!
! FORMAL PARAMETERS:
!	level	- The structure level to set the pointer to.
!		  user_def_mode
!		  override_mode
!		  local_mode
!
! IMPLICIT INPUTS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! Routine value:
!	NO value
!
! SIDE EFFECTS:
!	NONE
!--

	BEGIN

	LOCAL
		temp_level: REF VECTOR [, BYTE];

%IF dbg_mod
%THEN
	$fao_tt_out ('set_mod_lvl: new level is !SL', .level);
%FI

	IF (dbg$gb_def_mod[.level * mode_lvl_size] LEQA .dbg$gb_mod_ptr)
	OR (.level EQL user_def_mode)
	THEN
	    BEGIN
	    dbg$gb_mod_ptr = dbg$gb_def_mod [.level * mode_lvl_size];
%IF dbg_mod
%THEN
	    $fao_tt_out ('lvl:setting mode pointer to level !SL', .level);
	    $fao_tt_out ('lvl current radix is !SL', .dbg$gb_mod_ptr[mode_radix]);
%FI
	    RETURN
	    END;

	SELECT .level OF

		SET

		[override_mode]:
			BEGIN
			temp_level = dbg$gb_def_mod [user_def_mode * mode_lvl_size];
			dbg$gb_mod_ptr = dbg$gb_def_mod [override_mode * mode_lvl_size];

%IF dbg_mod
%THEN
	$fao_tt_out ('copying user-define modes to override');
%FI

			END;

		[local_mode]:
			BEGIN
%IF dbg_mod
%THEN
			IF .dbg$gb_mod_ptr EQLA dbg$gb_def_mod [override_mode * mode_lvl_size]
			THEN
			    $fao_tt_out ('copying override modes to local')
			ELSE
			    $fao_tt_out ('copying user-define modes to local');
%FI
			temp_level = .dbg$gb_mod_ptr;
			dbg$gb_mod_ptr = dbg$gb_def_mod [local_mode * mode_lvl_size];
			END;

		TES;
	dbg$gb_mod_ptr [mode_radix] = .temp_level [mode_radix];
	dbg$gb_mod_ptr [mode_length] = .temp_level [mode_length];
	dbg$gb_mod_ptr [mode_symbols] = .temp_level [mode_symbols];
	dbg$gb_mod_ptr [mode_instruc] = .temp_level [mode_instruc];
	dbg$gb_mod_ptr [mode_ascii] = .temp_level [mode_ascii];
	dbg$gb_mod_ptr [mode_scope] = .temp_level [mode_scope];
	dbg$gb_mod_ptr [mode_globals] = .temp_level [mode_globals];
	dbg$gb_mod_ptr [mode_immediate] = .temp_level [mode_immediate];
	dbg$gb_mod_ptr [mode_fortran] = .temp_level [mode_fortran];
%IF dbg_mod
%THEN
	$fao_tt_out('lvl: radix mode is !SL', .dbg$gb_mod_ptr[mode_radix]);
%FI
	END;

GLOBAL ROUTINE dbg$set_new_mod ( switch_value ): NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	This routine sets one mode according to the value
!	specified.
!
! FORMAL PARAMETERS:
!	switch_value	- value to set
!
! IMPLICIT INPUTS:
!	The current level of modes being used; held in dbg$gb_mod_ptr.
!
! IMPLICIT OUTPUTS:
!	MODIFIES THE VALUE OF THE ENTRY
!	IN WHATEVER LEVEL WE ARE IN OF THE MODE
!	DATA STRUCTURE.
!
! Routine value:
!	NOVALUE
!
! SIDE EFFECTS:
!	NONE
!--

	BEGIN

	LOCAL
		table_ptr : REF VECTOR [, BYTE];

%IF dbg_mod
%THEN
	$fao_tt_out ('new_mod: new mode is !SL', .switch_value);
%FI

	table_ptr = mode_table;
	WHILE (.table_ptr [keyword_field] NEQ 0) DO
		BEGIN
		IF .switch_value EQL .table_ptr [keyword_field]
		THEN
			BEGIN
			dbg$gb_mod_ptr [.table_ptr [offset_field]] =
				.table_ptr [value_field];
			EXITLOOP
			END
		ELSE table_ptr = table_ptr [0] + mode_entry_len;
		END;
	END;

GLOBAL ROUTINE dbg$show_mode : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	ACTION ROUTINE TO SHOW MODES
!
! FORMAL PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	THE POINTER TO THE CURRENT MODE STRUCTURE.
!
! IMPLICIT OUTPUTS:
!	NONE
!
! Routine value:
!	NOVALUE
!
! SIDE EFFECTS:
!	THE MODES ARE DISPLAYED ON THE OUTPUT DEVICE
!--

	BEGIN

	MACRO
	yes_no (value)=(IF value 
			THEN cs_boolean_on
			ELSE cs_boolean_off ) %;

	!+
	! counted strings for FAO
	!-

	BIND
	cs_octal	= UPLIT ( %ASCIC 'octal'),
	cs_decimal	= UPLIT ( %ASCIC 'decimal'),
	cs_hexadecimal	= UPLIT ( %ASCIC 'hexadecimal'),
	cs_boolean_on	= UPLIT ( %ASCIC ' ' ),
	cs_boolean_off	= UPLIT ( %ASCIC ' no' );


	LOCAL
		level_ptr : REF VECTOR [, BYTE];	! CURRENT MODE level.

	level_ptr = .dbg$gb_mod_ptr;
	$fao_tt_out ( 'modes:!ACsymbolic, !AC' ,
		yes_no ( .level_ptr[ mode_symbols ] ),

		(SELECTONE .level_ptr[ mode_radix ] OF

			SET

			[octal_radix]:	cs_octal;
			[hex_radix]:	cs_hexadecimal;
			[decimal_radix]: cs_decimal;

			TES),

		);

	END;

GLOBAL ROUTINE dbg$init_step (goal_level, source_level) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	Sets all levels from override level to the goal level specified
!	with the step settings of the source level.
!
!
! INPUTS:
!	goal_level	- highest level to set
!	source_level	- level from which to obtain step settings
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUTS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	THE step settings of the override level to the goal level
!	are reset to the step settings of the source level.
!
! Routine value:
!	NOVALUE
!
! SIDE EFFECTS:
!	NONE
!--

	BEGIN

	LOCAL
		temp_level: REF VECTOR [, BYTE];

%IF dbg_mod1
%THEN
	$fao_tt_out ('copying !SL level step settings up to !SL level', .source_level, .goal_level);
%FI

	temp_level = dbg$gb_def_stp [.source_level * step_lvl_size];
	DECR I FROM override_step TO .goal_level DO
		BEGIN
		dbg$gb_stp_ptr = dbg$gb_def_stp [.I * step_lvl_size];
		dbg$gb_stp_ptr [step_line] = .temp_level [step_line];
		dbg$gb_stp_ptr [step_nosystem] = .temp_level [step_nosystem];
		dbg$gb_stp_ptr [step_over] = .temp_level [step_over];
		dbg$gb_stp_ptr [step_source] = .temp_level [step_source];
		END;
	END;

GLOBAL ROUTINE dbg$set_stp_def : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	CANCELS USER SET DEFAULTS FOR STEP SETTINGS.
!	RESETS ALL STEP LEVELS TO SYSTEM DEFAULTS FOR THE CURRENT LANGUAGE.
!
!
! INPUTS:
!	NONE
!
! IMPLICIT INPUTS:
!	THE DEFAULT STEP SETTINGS
!
! OUTPUTS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! Routine value:
!	NOVALUE
!
! SIDE EFFECTS:
!	RESETS DEFAULT values FOR STEP.
!--

	BEGIN

%IF dbg_mod1
%THEN
	$fao_tt_out ('initializing step values, language byte is !SB', .dbg$gb_language);
%FI

	!+
	! Set up the step data structure
	!-
   
	dbg$gb_stp_ptr = dbg$gb_def_stp[default_step * step_lvl_size];
     
	IF .dbg$gb_language EQL lang_macro
	OR .dbg$gb_language EQL lang_bliss
	THEN
	    dbg$gb_stp_ptr[step_line] = FALSE
	ELSE
	    dbg$gb_stp_ptr[step_line] = TRUE;
   
	dbg$gb_stp_ptr[step_nosystem] = TRUE;
	dbg$gb_stp_ptr[step_over] = TRUE;
	dbg$gb_stp_ptr[step_source] = FALSE;
	dbg$init_step (user_def_step, default_step);
	END;

GLOBAL ROUTINE dbg$set_stp_lst (level) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	SETS A LIST OF STEPS AT THE SPECIFIED level.
!
! INPUTS:
!	level	- level AT WHICH TO SET STEP SETTINGS
!
! IMPLICIT INPUTS:
!	-THE ADDRESS OF THE LINKED LIST WHICH HOLDS THE SWITCHES.
!	-THE GLOBAL pointerS TO THE CURRENT STEP levelS.
!
! OUTPUTS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! Routine value:
!	NOVALUE
!
! SIDE EFFECTS:
!	THE APPROPRIATE STEP SETTINGS ARE MADE  .
!--

	BEGIN

	LOCAL
		pointer;

%IF dbg_mod1
%THEN
	$fao_tt_out ('new level is !SL', .level);
%FI

	dbg$set_stp_lvl (.level);
	pointer = .dbg$gl_head_lst;
	DO
		dbg$set_new_stp ( .list_elem_exp1 (.pointer) )
		UNTIL (pointer = .list_elem_flink (.pointer)) EQLA 0;
	END;

GLOBAL ROUTINE dbg$set_stp_lvl (level) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION
!	This routine sets the pointer to the step structure to the specified
!	level.  If the level is not user_def_step the step values there are
!	copied to override_step level.  If the level is user_def_step the
!	pointer is just reset to that level.
!
! FORMAL PARAMETERS:
!	LEVEL	- The new step structure level.
!		  user_def_step
!		  override_step
!
! IMPLICIT INPUTS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! Routine value:
!	NO value
!
! SIDE EFFECTS:
!	NONE
!--

	BEGIN

	LOCAL
		temp_level: REF VECTOR [, BYTE];

%IF dbg_mod1
%THEN
	$fao_tt_out ('new level is !SL', .level);
%FI

	IF .level EQL user_def_step
	THEN
		BEGIN
%IF dbg_mod1
%THEN
	$fao_tt_out ('resetting to user-define level');
%FI
		dbg$gb_stp_ptr = dbg$gb_def_stp [user_def_step * step_lvl_size];
		END
	ELSE
		BEGIN
		temp_level = dbg$gb_def_stp [user_def_step * step_lvl_size];
		dbg$gb_stp_ptr = dbg$gb_def_stp [override_step * step_lvl_size];

%IF dbg_mod1
%THEN
	$fao_tt_out ('copying user-define modes to override');
%FI

		dbg$gb_stp_ptr [step_line] = .temp_level [step_line];
		dbg$gb_stp_ptr [step_nosystem] = .temp_level [step_nosystem];
		dbg$gb_stp_ptr [step_over] = .temp_level [step_over];
		dbg$gb_stp_ptr [step_source] = .temp_level [step_source];
		END;

	END;

GLOBAL ROUTINE dbg$set_new_stp ( switch_value ): NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	This routine sets one step setting according to the value
!	specified.
!
! INPUTS:
!	switch_value	- value to set
!
! IMPLICIT INPUTS:
!	The current level of steps being used; held in dbg$gb_stp_ptr.
!
! OUTPUTS:
!	NOVALUE RETURNED.
!	MODIFIES THE value OF THE ENTRY
!	IN WHATEVER level WE ARE IN OF THE STEP
!	DATA STRUCTURE.
!
! IMPLICIT OUTPUTS:
!	NONE
!
! Routine value:
!	NOVALUE
!
! SIDE EFFECTS:
!	NONE
!--

	BEGIN

	LOCAL
		table_ptr : REF VECTOR [, BYTE];

%IF dbg_mod1
%THEN
	$fao_tt_out ('new step setting is !SL', .switch_value);
%FI

	table_ptr = step_table;
	WHILE (.table_ptr [keyword_field] NEQ 0) DO
		BEGIN
		IF .switch_value EQL .table_ptr [keyword_field]
		THEN
			BEGIN
			dbg$gb_stp_ptr [.table_ptr [offset_field]] =
				.table_ptr [value_field];
			EXITLOOP
			END
		ELSE table_ptr = table_ptr [0] + step_entry_len;
		END;
	END;

GLOBAL ROUTINE dbg$show_step : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	ACTION ROUTINE TO DISPLAY THE CURRENT SETTING OF THE
!	"STEP TYPE" DATA STRUCTURE
!
! INPUTS:
!	NONE
!
! IMPLICIT INPUTS:
!	none.
!
! OUTPUTS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! Routine value:
!	NOVALUE
!
! SIDE EFFECTS:
!	THE STEP SETTINGS ARE DISPLAYED ON THE OUTPUT DEVICE
!--

BEGIN
	LOCAL
		system_cs	: REF VECTOR[,byte],
		line_cs		: REF VECTOR[,byte],
		into_cs		: REF VECTOR[,byte],
		source_cs	: REF VECTOR[,byte];

	!+
	! We simply put out one line describing the
	! current step types, based on the TRUE/FALSE
	! indicators given in the STP structure.
	!-

	! If the step mode is not SYSTEM, then it 
	! must be NOSYSTEM.

	system_cs = uplit( %ascic '');
	if( .dbg$gb_stp_ptr[ step_nosystem ] )
	then
		system_cs = uplit( %ascic 'no' );

	! If the step mode is not LINE, then it 
	! must be INSTRUCTION.

	line_cs = uplit( %ascic 'instruction');
	if( .dbg$gb_stp_ptr[ step_line ] )
	then
		line_cs = uplit( %ascic 'line' );

	! If the step mode is not INTO, then it 
	! must be OVER.

	into_cs = uplit( %ascic 'into');
	if( .dbg$gb_stp_ptr[ step_over ] )
	then
		into_cs = uplit( %ascic 'over' );

	source_cs = uplit( %ascic '');
	IF (NOT .dbg$gb_stp_ptr [step_source])
	THEN
		source_cs = uplit (%ascic 'no');

	! Put out the line and return.

	$fao_tt_out('step type: !ACsystem, by !AC, !AC routine calls, !ACsource',
		.system_cs,.line_cs,.into_cs,.source_cs);
END;

GLOBAL ROUTINE dbg$init_search (goal_level, source_level) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	Sets all levels from override level to the goal level specified
!	with the search settings of the source level.
!
!
! INPUTS:
!	goal_level	- highest level to set
!	source_level	- level from which to obtain search settings
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUTS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	THE search settings of the override level to the goal level
!	are reset to the search settings of the source level.
!
! Routine value:
!	NOVALUE
!
! SIDE EFFECTS:
!	NONE
!--

	BEGIN

	LOCAL
		temp_level: REF VECTOR [, BYTE];

	temp_level = dbg$gb_def_search [.source_level * search_lvl_size];
	DECR I FROM override_search TO .goal_level DO
		BEGIN
		dbg$gb_search_ptr = dbg$gb_def_search [.I * search_lvl_size];
		dbg$gb_search_ptr [search_all] = .temp_level [search_all];
		dbg$gb_search_ptr [search_ident] = .temp_level [search_ident];
		END;
	END;

GLOBAL ROUTINE dbg$set_search_def : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	CANCELS USER SET DEFAULTS FOR SEARCH SETTINGS.
!	RESETS ALL SEARCH LEVELS TO SYSTEM DEFAULTS FOR THE CURRENT LANGUAGE.
!
!
! INPUTS:
!	NONE
!
! IMPLICIT INPUTS:
!	THE DEFAULT SEARCH SETTINGS
!
! OUTPUTS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! Routine value:
!	NOVALUE
!
! SIDE EFFECTS:
!	RESETS DEFAULT values FOR SEARCH.
!--

	BEGIN


	!+
	! Set up the search data structure
	!-
   
	dbg$gb_search_ptr = dbg$gb_def_search[default_search * search_lvl_size];
     
	dbg$gb_search_ptr[search_all] = FALSE;
	dbg$gb_search_ptr[search_ident] = FALSE;
	dbg$init_search (user_def_search, default_search);
	END;

GLOBAL ROUTINE dbg$set_search_lst (level) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	SETS A LIST OF SEARCH SETTINGS AT THE SPECIFIED level.
!
! INPUTS:
!	level	- level AT WHICH TO SET SEARCH SETTINGS
!
! IMPLICIT INPUTS:
!	-THE ADDRESS OF THE LINKED LIST WHICH HOLDS THE SWITCHES.
!	-THE GLOBAL pointerS TO THE CURRENT SEARCH levelS.
!
! OUTPUTS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! Routine value:
!	NOVALUE
!
! SIDE EFFECTS:
!	THE APPROPRIATE SEARCH SETTINGS ARE MADE  .
!--

	BEGIN

	LOCAL
		pointer;

	dbg$set_search_lvl (.level);
	pointer = .dbg$gl_head_lst;
	DO
		dbg$set_new_search ( .list_elem_exp1 (.pointer) )
		UNTIL (pointer = .list_elem_flink (.pointer)) EQLA 0;
	END;

GLOBAL ROUTINE dbg$set_search_lvl (level) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION
!	This routine sets the pointer to the search structure to the specified
!	level.  If the level is not user_def_search the search values there are
!	copied to override_search level.  If the level is user_def_search the
!	pointer is just reset to that level.
!
! FORMAL PARAMETERS:
!	LEVEL	- The new search structure level.
!		  user_def_search
!		  override_search
!
! IMPLICIT INPUTS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! Routine value:
!	NO value
!
! SIDE EFFECTS:
!	NONE
!--

	BEGIN

	LOCAL
		temp_level: REF VECTOR [, BYTE];

	IF .level EQL user_def_search
	THEN
		BEGIN
		dbg$gb_search_ptr = dbg$gb_def_search [user_def_search * search_lvl_size];
		END
	ELSE
		BEGIN
		temp_level = dbg$gb_def_search [user_def_search * search_lvl_size];
		dbg$gb_search_ptr = dbg$gb_def_search [override_search * search_lvl_size];

		dbg$gb_search_ptr [search_all] = .temp_level [search_all];
		dbg$gb_search_ptr [search_ident] = .temp_level [search_ident];
		END;

	END;

GLOBAL ROUTINE dbg$set_new_search ( switch_value ): NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	This routine sets one search setting according to the value
!	specified.
!
! INPUTS:
!	switch_value	- value to set
!
! IMPLICIT INPUTS:
!	The current level of search being used; held in dbg$gb_search_ptr.
!
! OUTPUTS:
!	NOVALUE RETURNED.
!	MODIFIES THE value OF THE ENTRY
!	IN WHATEVER level WE ARE IN OF THE SEARCH
!	DATA STRUCTURE.
!
! IMPLICIT OUTPUTS:
!	NONE
!
! Routine value:
!	NOVALUE
!
! SIDE EFFECTS:
!	NONE
!--

	BEGIN

	LOCAL
		table_ptr : REF VECTOR [, BYTE];

	table_ptr = search_table;
	WHILE (.table_ptr [keyword_field] NEQ 0) DO
		BEGIN
		IF .switch_value EQL .table_ptr [keyword_field]
		THEN
			BEGIN
			dbg$gb_search_ptr [.table_ptr [offset_field]] =
				.table_ptr [value_field];
			EXITLOOP
			END
		ELSE table_ptr = table_ptr [0] + search_entry_len;
		END;
	END;

GLOBAL ROUTINE dbg$show_search : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	ACTION ROUTINE TO DISPLAY THE CURRENT SETTING OF THE
!	"SEARCH TYPE" DATA STRUCTURE
!
! INPUTS:
!	NONE
!
! IMPLICIT INPUTS:
!	none.
!
! OUTPUTS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! Routine value:
!	NOVALUE
!
! SIDE EFFECTS:
!	THE SEARCH SETTINGS ARE DISPLAYED ON THE OUTPUT DEVICE
!--

BEGIN
	LOCAL
		all_cs		: REF VECTOR[,byte],
		ident_cs	: REF VECTOR[,byte];

	!+
	! We simply put out one line describing the
	! current search types, based on the TRUE/FALSE
	! indicators given in the SEARCH structure.
	!-

	! If the search mode is not ALL, then it 
	! must be NEXT.

	if( .dbg$gb_search_ptr[ search_all ] )
	then
		all_cs = uplit( %ascic 'all occurences' )
    	else
    		all_cs = uplit( %ascic 'next occurence' );

	! If the search mode is not IDENT, then it 
	! must be STRING.

	if( .dbg$gb_search_ptr[ search_ident] )
	then
		ident_cs = uplit( %ascic 'an identifier' )
    	else
    		ident_cs = uplit( %ascic 'a string');

	! Put out the line and return.

	$fao_tt_out('search settings: search for !AC, as !AC',
		.all_cs,.ident_cs);
END;

GLOBAL ROUTINE dbg$set_out_def : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	Sets OUTPUT configuration to default settings. Is called from
!	DBG$INIT_DEBUG as part of the once only initialization phase.
!	Also initializes the default LOG filespec and the string buffers and
!	location of the LOG file's NAM block.
!
! FORMAL PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	The default modes
!
! IMPLICIT OUTPUTS:
!	The vector dbg$gb_def_out is initialized
!
! ROUTINE VALUE:
!	none
!
! SIDE EFFECTS:
!	none
!--

	BEGIN


	dbg$gb_def_out [out_log] 	= FALSE;	! nolog
	dbg$gb_def_out [out_term]	= TRUE;		! terminal
	dbg$gb_def_out [out_verify]	= FALSE;	! noverify

	! This variable is used to hold pointer to a user defined filespec

	dbg$gl_log_buf = 0;
	
	! initialize default log file spec

	dbg$gl_logfab [fab$l_dna] = deflog_name;
	dbg$gl_logfab [fab$b_dns] = deflog_size;

	! Initialize address of related NAM block and the resultant string buffers

	dbg$gl_lognam = dbg$freez((nam$c_bln+3)/%UPVAL);
	$nam_init (nam=.dbg$gl_lognam);
	dbg$gb_logfse = dbg$freez((nam$c_maxrss+3)/%UPVAL);
	dbg$gb_logfsr = dbg$freez((nam$c_maxrss+3)/%UPVAL);
	dbg$gl_logfab [fab$l_nam] = .dbg$gl_lognam;
	dbg$gl_lognam [nam$l_esa] = .dbg$gb_logfse;
	dbg$gl_lognam [nam$l_rsa] = .dbg$gb_logfsr;
	dbg$gl_lognam [nam$b_ess] = nam$c_maxrss;
	dbg$gl_lognam [nam$b_rss] = nam$c_maxrss;

	END;

GLOBAL ROUTINE dbg$set_out_lst : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	Sets either a single or a list of OUTPUT settings. The command
!	argument list is scanned until all OUTPUT qualifiers have been set.
!
! FORMAL PARAMETERS:	
!	none
!
! IMPLICIT INPUTS:
!	The address of the command argument list
!
! IMPLICIT OUTPUTS:
!	The appropriate flags are set in dbg$gb_def_out
!
! ROUTINE VALUE:
!	none
!
! SIDE EFFECTS:
!	If one of the specified qualifiers was "LOG", the log file is
!	opened.
!--

	BEGIN

	LOCAL
		status,
		b_type,		
		pointer;

	pointer = .dbg$gl_head_lst;		! get the head of the command arg list

	DO BEGIN
	   
	   SELECTONE .list_elem_exp1 (.pointer) OF
	   SET
		[log_token] :		BEGIN
					status = setup_log(b_type);
					IF NOT .status
					THEN
						signal_rms_err (.b_type) ;
					dbg$gb_def_out [out_log] = TRUE;
					END;
	
		[nolog_token]:		BEGIN
					IF NOT .dbg$gb_def_out [out_term]
					THEN 
						SIGNAL (dbg$_outputlost); ! Info message
					dbg$gb_def_out [out_log] = FALSE;
					END;

		[terminal_token]:	dbg$gb_def_out [out_term] = TRUE;

		[noterm_token]:		BEGIN
					IF NOT .dbg$gb_def_out [out_log]
					THEN 

						SIGNAL (dbg$_outputlost); ! Info message
					dbg$gb_def_out [out_term] = FALSE;
					END;

		[verify_token]:		dbg$gb_def_out [out_verify] = TRUE;

		[noverify_token]:	dbg$gb_def_out [out_verify] = FALSE;
	   TES;

	   pointer = .list_elem_flink(.pointer);
	   END
	
	UNTIL .pointer EQLA 0;

	END;

GLOBAL ROUTINE dbg$show_output(full_rep) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:  
!	Action routine to show OUTPUT configuration
!
! FORMAL PARAMETERS:
!	full_rep    equals 1 for a full report (i.e. "SHOW OUTPUT")
!		           2 for just "SHOW LOG"
!
! IMPLICIT INPUTS:
!	The OUTPUT configuration data structure, dbg$gb_def_out
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
! 	none
!
! SIDE EFFECTS:
! 	A message is generated that displays the current output configuration
!	and the log file name
!--

	BEGIN

	LOCAL
		verify_cs :	REF VECTOR [,BYTE],
		term_cs :	REF VECTOR [,BYTE],
		log_cs :	REF VECTOR [,BYTE],
		no_count: 	word,
		string_count:	word;			! count of chars in output string

	no_count = 0;				! count of "no" characters

	IF .full_rep 
	THEN
		BEGIN
		IF .dbg$gb_def_out [out_verify]
		THEN
			verify_cs = UPLIT(%ASCIC '')
		ELSE
			BEGIN
			verify_cs = UPLIT(%ASCIC 'no');
			no_count = .no_count + 2;
			END;
	
		IF .dbg$gb_def_out [out_term]
		THEN
			term_cs = UPLIT(%ASCIC '')
		ELSE
			BEGIN
			term_cs = UPLIT(%ASCIC 'no');
			no_count = .no_count + 2
			END;
		END;

	IF .dbg$gb_def_out [out_log]
	THEN
		log_cs = UPLIT(%ASCIC '')
	ELSE
		BEGIN
		log_cs = UPLIT(%ASCIC 'not ');
		no_count = .no_count + 3;
		END;

%IF dbg_mod2
%THEN
$fao_tt_out('show_output: rss !SB, rsa !XL',.dbg$gl_lognam[nam$b_rss], .dbg$gl_lognam[nam$l_rsa]);
%FI

	! If a LOG file is open report the filespec in the NAM block, otherwise
	! use the default filespec


	IF .dbg$gl_logfab [fab$w_ifi] LEQ 0
	THEN
		IF .full_rep
		THEN
		$fao_tt_out('output: !ACverify, !ACterminal, !AClogging to !AD', 
		.verify_cs, .term_cs, .log_cs, deflog_size, deflog_name) 
		ELSE
		$fao_tt_out('!AClogging to !AD',.log_cs, deflog_size, deflog_name)

	ELSE
	    IF .full_rep
	    THEN
	    BEGIN
            ! string count is initialized to the no. of characters in the output
            ! string (not counting "no"s and the log filespec).

	    string_count = 38;
	    string_count = .string_count + .no_count + .dbg$gl_lognam[nam$b_rsl];

	    ! If we exceed the max record length, output two lines

	    IF .string_count LEQ tty_out_width
	    THEN
	    $fao_tt_out('output: !ACverify, !ACterminal, !AClogging to !AD', 
	    .verify_cs, .term_cs, .log_cs, .dbg$gl_lognam[nam$b_rsl], .dbg$gl_lognam[nam$l_rsa])
	
	    ELSE
     		BEGIN
	        $fao_tt_out('output: !ACverify, !ACterminal, !AClogging to :', 
			.verify_cs, .term_cs, .log_cs); 
		$fao_tt_out('!AD', .dbg$gl_lognam[nam$b_rsl], .dbg$gl_lognam[nam$l_rsa]);
		END;
	    END
	
	    ELSE
	    $fao_tt_out('!AClogging to !AD', .log_cs, .dbg$gl_lognam[nam$b_rsl],
		        .dbg$gl_lognam[nam$l_rsa]);

	END;

GLOBAL ROUTINE dbg$set_log : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	This routine closes any log file that is currently open and opens
! the file specified by the user in SET LOG "filespec"
!
! FORMAL PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	The RMS-set IFI (internal file identifier field) bit is used to
! determine if a previous log file is still open.
!
! The user specified LOG filespec is pointed to by dbg$gl_log_buf
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	none
!
! SIDE EFFECTS:
!	Any previously open log file is closed and a new log file is opened.
! Logging is inhibited for the duration of this routine.
!--

	BEGIN
	
	LOCAL
		status,
		opened_log,
		fns : BYTE,
		fna,
		old_nam_ptr,
		b_type,
		temp_nam : REF $NAM_DECL,
		temp_fse : REF VECTOR [,BYTE],
		temp_fsr : REF VECTOR [,BYTE],
		log_temp : BYTE;
	
	opened_log = FALSE ;

	! inhibit logging until we can redirect the log file

	log_temp = .dbg$gb_def_out [out_log];
	dbg$gb_def_out [out_log] = FALSE;

	! see if a log file has been previously opened. If so, close it,
	! since it must be CLOSEd befor we can do the new $PARSE.

	IF .dbg$gl_logfab [fab$w_ifi] NEQ 0
	THEN
		BEGIN

		opened_log = TRUE;
		fna = .dbg$gl_logfab [fab$l_fna];
		fns = .dbg$gl_logfab [fab$b_fns];

		status = $CLOSE (FAB = dbg$gl_logfab);
		IF NOT .status
		THEN
			BEGIN
			LOCAL
				msg_desc : BLOCK [8,BYTE];
			build_err_desc (msg_desc);
			SIGNAL (shr$_closeout+dbg_fac_code, 1, msg_desc,
			       .dbg$gl_logfab[fab$l_sts], .dbg$gl_logfab[fab$l_stv]); 
			END;

		! get new NAM block, preserve the original

		temp_nam = dbg$freez ((nam$c_bln+3)/%UPVAL);
		$nam_init (nam = .temp_nam);
		temp_fse = dbg$freez ((nam$c_maxrss+3)/%UPVAL);
		temp_fsr = dbg$freez ((nam$c_maxrss+3)/%UPVAL);
		temp_nam [nam$l_esa] = .temp_fse;
		temp_nam [nam$l_rsa] = .temp_fsr;
		temp_nam [nam$b_ess] = nam$c_maxrss;
		temp_nam [nam$b_rss] = nam$c_maxrss;
		dbg$gl_logfab [fab$l_nam] = .temp_nam;
		old_nam_ptr = .dbg$gl_lognam;
		dbg$gl_lognam = .temp_nam;

		END;

%IF dbg_mod2
%THEN
$fao_tt_out('dbg$gl_log_buf- !XL',.dbg$gl_log_buf);
%FI

	! reset the appropriate FAB file process options

	dbg$gl_logfab [fab$v_cif] = 0;
	dbg$gl_logfab [fab$v_mxv] = 1;
	dbg$gl_logfab [fab$v_nam] = 0;

	! Set up file name, dbg$gl_log_buf contains the pointer to the user
	! specified filespec.

	IF .dbg$gl_log_buf NEQ 0
	THEN
		BEGIN

		MAP
			dbg$gl_log_buf : REF VECTOR [,BYTE];

		dbg$gl_logfab [fab$l_fna] = .dbg$gl_log_buf + 1; ! filename addr starts in 2nd byte
		dbg$gl_logfab [fab$b_fns] = .dbg$gl_log_buf[0];  ! 1st byte is count
%IF dbg_mod2
%THEN
$fao_tt_out('fna !AD',.dbg$gl_logfab[fab$b_fns], .dbg$gl_logfab[fab$l_fna]);
%FI

		! Parse the filespec to see if an explicit version number was
		! given. If so set the CIF bit, otherwise we must maximize
		! the version number.

		status = $PARSE (FAB = dbg$gl_logfab);
		IF NOT .status
		THEN
			BEGIN
			LOCAL
				sts,
				stv,
				msg_desc : BLOCK [8,BYTE];

			! save these because restore_nam will reset them

			sts = .dbg$gl_logfab [fab$l_sts];
			stv = .dbg$gl_logfab [fab$l_stv];
			build_err_desc (msg_desc);

			IF .opened_log
			THEN
				restore_nam 
			ELSE
				BEGIN
				dbg$gl_logfab [fab$l_fna] = 0;
				dbg$gl_logfab [fab$b_fns] = 0;
				dbg$gl_log_buf	= 0;
				END;

			SIGNAL (shr$_syntax + dbg_fac_code, 1, msg_desc, .sts, .stv);
			END;

%IF dbg_mod2
%THEN
$fao_tt_out('status; !XL', .status);
$fao_tt_out('nam esa- !AD',.dbg$gl_lognam[nam$b_esl], .dbg$gl_lognam[nam$l_esa]);
%FI
		IF .dbg$gl_lognam [nam$v_exp_ver]
		THEN
			BEGIN
			dbg$gl_logfab [fab$v_cif] = 1;
			dbg$gl_logfab [fab$v_mxv] = 0;
			END;

		dbg$gl_logfab [fab$v_nam] = 1;		! open by NAM block since
		END;					! we've already parsed the filespec


%IF dbg_mod2
%THEN
$fao_tt_out('fna !AD',.dbg$gl_logfab[fab$b_fns], .dbg$gl_logfab[fab$l_fna]);
%FI

	! now open the new log file

	status = setup_log(b_type);
	IF NOT .status
	THEN
		BEGIN
		LOCAL 
			msg_desc : BLOCK [8,BYTE],
			sts,
			stv;

		build_err_desc (msg_desc);
		IF .b_type EQL 1
		THEN
			BEGIN
			sts = .dbg$gl_logfab [fab$l_sts];
			stv = .dbg$gl_logfab [fab$l_stv];
			END
		ELSE
			BEGIN
			sts = .dbg$gl_lograb [rab$l_sts];
			stv = .dbg$gl_lograb [rab$l_stv];
			END;

		IF .opened_log
		THEN
			restore_nam 
		ELSE
			BEGIN
			dbg$gl_logfab [fab$l_fna] = 0;
			dbg$gl_logfab [fab$b_fns] = 0;
			dbg$gl_log_buf	= 0;
			dbg$gl_logfab [fab$v_nam] = 0;
			END;

		SIGNAL (shr$_openout+dbg_fac_code, 1, msg_desc, .sts, .stv);
		END;

	! restore logging status and free temp storage

	dbg$gb_def_out [out_log] = .log_temp;		
	IF .opened_log
	THEN
	
		! Cleanup the "original" NAM block

		BEGIN
		dbg$freerelease (.old_nam_ptr, (nam$c_bln+3)/%UPVAL);
		dbg$freerelease (.dbg$gb_logfse, (nam$c_maxrss+3)/%UPVAL);
		dbg$freerelease (.dbg$gb_logfsr, (nam$c_maxrss+3)/%UPVAL);
		dbg$gb_logfsr = .temp_fsr;
		dbg$gb_logfse = .temp_fse;

		! Release the buffer that holds the log file spec. Since this
		! is a counted string we have to adjust the address to free

		IF .fns NEQ 0
		THEN
			dbg$freerelease (.fna-1, (.fns+2)/%UPVAL+1);
		END;
	END;

ROUTINE setup_log (block_type)  =
!++
! FUNCTIONAL DESCRIPTION:
!	This routine creates and opens the log file.
!
! FORMAL PARAMETERS:
!	block_type - indicates whether error to report is for 
!		     FAB ( = 1) or RAB ( = 2)
!
! IMPLICIT INPUTS:
!	The name of the log file to be opened
!
! IMPLICIT OUTPUTS:
!	The resultant LOG file-spec as resolved by RMS
!
! ROUTINE VALUE:
!	Returns the RMS status code if there's an error, otherwise returns TRUE
!
! SIDE EFFECTS:
!	The log file is created and a RAB connected to it.
!--

	BEGIN
	
	LOCAL 
		status;
	MAP
		dbg$gl_log_buf : REF VECTOR [,BYTE];


%IF dbg_mod2
%THEN
$fao_tt_out ('setup esa 1 !AD', .dbg$gl_lognam[nam$b_esl], .dbg$gl_lognam[nam$l_esa]);
$fao_tt_out ('rsa 1 !AD', .dbg$gl_lognam[nam$b_rsl],.dbg$gl_lognam[nam$l_rsa]);
%FI

	! See if a log file is already open

	IF .dbg$gl_logfab [fab$w_ifi] NEQ 0
	THEN
		RETURN (TRUE);

	.block_type = 1;
	status = $CREATE(FAB = dbg$gl_logfab);

	IF NOT .status
	THEN
		RETURN (.status) ;

%IF dbg_mod2
%THEN
$fao_tt_out(' about to connect');
%FI
	dbg$gl_lograb [rab$l_fab] = dbg$gl_logfab;
	.block_type = 2;
	status = $CONNECT (RAB = dbg$gl_lograb);

%IF dbg_mod2
%THEN
$fao_tt_out(' after connect, status : !XL' , .status);
$fao_tt_out('block_type !XL' , .block_type);
%FI
	IF NOT .status
	THEN
		RETURN (.status) ;


	! Eventually put out the title line here
	RETURN (TRUE)
	END;


GLOBAL ROUTINE dbg$verify_out (parse_stg_desc) : NOVALUE =
!++
! Functional Description:
! 	Routine figures out whether or not to verify input commands by
! consulting the command input stream. It always updates dbg$gb_verptr, even
! if VERIFY is not set. This is so we can support an imbedded SET OUTPUT VERIFY
! in a command sequence
!
! Formal Parameters:
!	parse_stg_desc -- The input buffer from which we are taking commands
!
! Implicit Inputs:
!	dbg$gl_cishead : The head of the command input stream 
!	dbg$gb_verptr  : The pointer to the beginning of the command to 
!			 be verified
!
! Outputs:
!	None.
!
! Routine Value:
!	None.
!
! Side Effects:
!	An input command is "VERIFYed" (copied) to the terminal and/or log file
!--

BEGIN


MAP
	parse_stg_desc 	: REF BLOCK [,BYTE];

LOCAL
	prev_link	: REF cis_link,
	ok_to_verify,
	buf_len;

	! get address of previous link in cis

	prev_link = .dbg$gl_cishead [next_link];

%IF dbg_mod2
%THEN
$fao_tt_out ('head type !SL, prev type !SL',.dbg$gl_cishead[dsc$b_dtype],
			.prev_link [dsc$b_dtype]);
%FI

	CASE .dbg$gl_cishead[dsc$b_dtype] FROM cis_dbg$input TO cis_acbuf OF
	SET
	
	[cis_dbg$input]:	ok_to_verify = FALSE;

	[cis_rab]:		IF .prev_link [dsc$b_dtype] NEQ cis_inpbuf
				THEN
					ok_to_verify = TRUE
				ELSE
					BEGIN
					LOCAL pre_prev : REF cis_link;
					pre_prev = .prev_link [next_link];
					IF .pre_prev[dsc$b_dtype] NEQ cis_dbg$input
					THEN
						ok_to_verify = TRUE
					ELSE
						ok_to_verify = FALSE;
					END;

	[cis_inpbuf]:		IF .prev_link [dsc$b_dtype] EQL cis_dbg$input
				THEN
					ok_to_verify = FALSE
				ELSE
					ok_to_verify = TRUE;

	[cis_acbuf]:		ok_to_verify = TRUE;

	TES;

	! buf_len is the number of characters for VERIFY to print from the
	! command input buffer

	buf_len = .parse_stg_desc[dsc$a_pointer] - .dbg$gb_verptr;

	! Exclamation point (!) is mapped as end-of-line by the lexical
	! analysers. In order to capture comments for inclusion in VERIFY
	! reporting we must check each EOL for "!".


	IF .dbg$gb_verptr [.buf_len - 1] EQL %C'!'
	AND (.parse_stg_desc [dsc$w_length] AND %X'8000') EQL 0
	THEN
		buf_len = .buf_len + .parse_stg_desc [dsc$w_length] ;

	IF  .dbg$gb_def_out [out_verify]
	AND .buf_len GTR 1
	AND .ok_to_verify
	THEN
		$fao_tt_out (' !AD',.buf_len, .dbg$gb_verptr);

	dbg$gb_verptr =  .parse_stg_desc [dsc$a_pointer];
%IF dbg_mod2
%THEN
$fao_tt_out ('len !SL ; psd len !SW', .buf_len, .parse_stg_desc[dsc$w_length]);
%FI
	RETURN
	END;

END
ELUDOM
