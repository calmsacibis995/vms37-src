MODULE DBGEXM ( IDENT = 'V03-000') =
BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! FACILITY:	DEBUG
!
!++
! FUNCTIONAL DESCRIPTION:
!	EXAMINE ROUTINES FOR STARLET DEBUG FACILITY
!
! Version:	1.22
!
! History:
!	Author:
!		Carol Peters, 21 Jul 1976: Version 01
!
!	Modified by:
!		John Francis, 6 April 1981
!		Richard Title, 21 AUG 1981
!
! Revision history:
! 1.01	22-SEP-78	DAR	Deleted require file LISTEL.
! 1.02	25-SEP-78	MCC	Deleted require file SYSLIT
! 1.03	27-SEP-78	MCC	Converted dbg$cnv...routines to BUILTIN
!				calls, streamlined diagnostics in symbol_deposit
! 1.04	 8-NOV-78	MCC	Changed dbg$examine_cmd to set the global
!				pointer dbg$gl_lis_ptr so that access to
!				the command arg list will be possible
!				when examining BLISS structures.
! 1.05	13-NOV-78	DAR	Fixed cause of informational message in dbg$reg_match
!				Fixed up dbg$deposit_cmd and symbol_deposit, they
!				now handle numeric string data types and use the
!				new command argument list format.
! 1.06	04-DEC-78	DAR	DBG$EVALUAT_CMD now handles DSC$K_DTYPE_FLD and
!				tries to output a register name if the address
!				is that of a register.
! 1.07	 9-DEC-78	MCC	Made changes to allow depositing into BLISS
!				structures or variables with field references.
!				This included the addition of the routine bli_write_mem.
!				Also changed dbg$evaluate_cmd to handle field refs
! 1.08	18-DEC-78	DAR	Added support for depositing packed decimal data
! 1.09	24-APR-79	MCC	Modified dbg$examine_cmd to first check that a
!				variable to be examined is not a reference to
!				a permanent symbol before resetting the type
!				field to -1. (Bug fix)
! 1.10	24-APR-79	MCC	Fixed a bug in symbol_deposit which prevented
!				deposits into globals with field references from
!				working correctly.
! 1.11   6-AUG-79	TKM	Changed OUTPUT_MEM_LOC to pass the symbol name
!				name table pointer to dbg$out_typ_val if it had
!				one.
! 1.12   12-SEP-79	TKM     Changed deposit command to handle new data types
!
! 1.13	28-NOV-79	BAO	Added support for override types.
!
! 1.14  3-JAN-80  	DLP	Changed size for asci output to reflect overrides
!
! 1.15	15-JAN-80	DLP	Added support for word integer to single or
!				double precision float Deposits.
!
! 1.15  16-JAN-80	DLP	Added check for asci deposits crossing
!				page boundaries (bug fix).
! 1.17	16-JAN-80	MCC	Fixed bug with default type of ascii when doing
!				deposits.	
! 1.18	20-Feb-80	JBD	Null strings are now output without an access
!				violation, which is to say, nothing is output.
! 1.19	21-Feb-80	JBD	Made EV <string-symbol> work. Also made deposits
!				into null strings work.
!
! 1.20	19-apr-80	ala	Added parameter to output routines to give
!				address of output buffer.
! 1.21  28-APR-80	KAN	Split this module (DBGEXM) away from DBGEXA.
!
! 1.22	 6-APR-81	JF	Allow EVAL/OCTAL '}' to show character code
! 3.00	21-AUG-81	RT	Added routines dbg$type_cmd and dbg$exa_source_cmd
!				for the source-level display feature.
! 3.01	2-Sep-81	RT	Made changes to dbg$examine_cmd so that it 
!				passes along the nt_ptr even when type 
!				override is present. This provides better
!				symbolization of variables in EX/LONG,
!				EX/FLOAT, etc.
!--

! TABLE OF CONTENTS
!--
FORWARD ROUTINE
	dbg$out_regname,		! Match and symbolize register names
	dbg$examine_cmd : NOVALUE,	! ROUTINE TO EXAMINE A location
	output_mem_loc  : NOVALUE,	! ROUTINE TO OUTPUT THE CONTENTS OF A MEMORY location
	dbg$evaluat_cmd : NOVALUE,	! Do the evaluate command.
	dbg$reg_match,			! MATCHES A STRING TO A REGISTER NAME
	dbg$digit_scan,			! scan string for valid numeric
	dbg$output_psl      : NOVALUE,	! ROUTINE TO OUTPUT PSL IN SPECIAL FORMAT
	dbg$map_to_reg_addr,		! Tries to map input address to an address
					! in the reg area in user_runframe
	dbg$exact_map_to_reg,		! Tries to map input address to the address
					! of a reg in user_runframe
	dbg$type_cmd : NOVALUE,		! Handles the TYPE command
	dbg$exa_source_cmd : NOVALUE;	! Handles the EXAMINE/SOURCE command.

!
! Require files:
!

REQUIRE 'src$:dbgprolog.req';
REQUIRE 'src$:DBGGEN.REQ';
REQUIRE 'SRC$:BSTRUC.REQ';
REQUIRE 'SRC$:SYSSER.REQ';

EXTERNAL

	dbg$gl_loctyp,				! TYPE SPECIFIED BY VERB MODIFIER
	dbg$gw_loclngth : WORD,			! LENGTH SPECIFIED BY VERB MODIFIER
	dbg$gl_gbltyp,				! OVERRIDE TYPE
	dbg$gw_gbllngth : WORD,			! OVERRIDE LENGTH
	dbg$gl_dflttyp,				! DEFAULT TYPE
	dbg$gb_loc_type: BYTE,			! TYPE OF END RANGE ARGUMENT
	dbg$gb_mod_ptr: REF VECTOR [, BYTE],	! POINTER TO MODE LEVEL
	dbg$cp_out_str : REF VECTOR[,BYTE],	! POINTS INTO CURRENT OUTPUT BUFFER.
	dbg$gl_context: BITVECTOR,		! CONTEXT BITS WORD
	dbg$gl_asci_len,			! Holds the length of the char. variable
  	dbg$gl_buf_siz,				! Holds count in output buffer
	dbg$gl_head_lst,			! HEAD OF LINKED LIST OF EXPRESSIONS
	dbg$gl_lis_ptr,				! ptr to current element of command arg list
	dbg$gl_last_loc,			! LAST location DISPLAYED
	dbg$gl_last_val,			! LAST VALUE DISPLAYED
	dbg$gl_next_loc,			! NEXT location TO DISPLAY
	dbg$gb_language : BYTE,			! LANGUAGE INDEX
	dbg$reg_values : VECTOR,		! Context regs save area
	dbg$gl_runframe : REF BLOCK [, BYTE],	! pointer to current run frame
	dbg$src_next_modrstptr,			! module pointer used by 
						! dbg$type_cmd.
	dbg$src_next_lnum,			! Contains next line num to
						! typed if no line num is 
						! specified in the TYPE
						! command.
	dbg$src_next_stmt;			! as above with stmt num

EXTERNAL ROUTINE
	dbg$rst_type,
	dbg$fao_put : NOVALUE,			! FORMATTED BUFFERED OUTPUT.
	dbg$hex_dec_cvrt,			! Conversion routine (see
						! DBGCON for description)
	dbg$ins_decode,				! ROUTINE TO OUTPUT MEMORY AS
						!  SYMBOLIC INSTRUCTIONS.
	dbg$ins_encode,				! routine to encode a symbolic instruction
	dbg$out_put : NOVALUE,			! ACTUALLY DO TERMINAL I/O.
	dbg$out_num_val,			! outputs numeric value
	dbg$out_sym_val,			! output symbolic value if possible
	dbg$out_typ_val,			! outputs typed contents of a location
	dbg$read_access,			! PROBE for read accessability.
	dbg$sta_getsourcemod,			! looks up module rst pointer
	dbg$sta_symname : NOVALUE,		! looks up module name,
						! given the RST pointer
	dbg$src_type_lnum_source : NOVALUE,	! types a range of source line nums
	dbg$src_type_pc_source : NOVALUE;	! types source for a range
						! of PCs.


! THE REGISTER_TABLE HOLDS ONE ENTRY PER REGISTER. EACH ENTRY IS MADE
! UP OF ONE LONGWORD. THE FIRST BYTE HOLDS THE CHARACTER COUNT OF
! THE REGISTER NAME. THE SECOND THROUGH FOURTH BYTES HOLD THE REGISTER
! NAME STRING. A SAMPLE ENTRY FOLLOWS:
!
!	----------------------------------------------------
!	!            !      0     !      R     !     2     !
!	!--------------------------------------------------!
!--

MACRO
	register_entry (string) =
		%CHARCOUNT (STRING), %ASCII STRING, REP 3 - %CHARCOUNT (STRING) OF BYTE (0)%;

BIND
	register_table = UPLIT BYTE (

		register_entry ('R0'),
		register_entry ('R1'),
		register_entry ('R2'),
		register_entry ('R3'),
		register_entry ('R4'),
		register_entry ('R5'),
		register_entry ('R6'),
		register_entry ('R7'),
		register_entry ('R8'),
		register_entry ('R9'),
		register_entry ('R10'),
		register_entry ('R11'),
		register_entry ('AP'),
		register_entry ('FP'),
		register_entry ('SP'),
		register_entry ('PC'),
		register_entry ('PSL')):

	BLOCK [, LONG];

!++
! THESE FIELD DEFINITIONS CONTROL ACCESS TO THE REGISTER TABLE
!--
MACRO
	REG_NAME	=8, 24, 0%,
	ctd_reg_name	=0, 24, 0%,
	REG_CH_CNT	=0, 8, 0%;

!++
! COMMON ASCII COUNTED STRINGS USED IN FAO CALLS.
!--

BIND
	cs_ascii	= UPLIT ( %ASCIC '!AD'),
	colon_tab_stg	= UPLIT ( %ASCIC ':  ');

!++
! The following macros translate addresses to register offsets and
! vice versa.
!--
	MACRO
		this_is_reg (location) =
			(((location) GEQA dbg$gl_runframe [dbg$l_user_r0]) AND
				((location) LEQA dbg$gl_runframe [dbg$l_user_psl]))%,

		reg_offset (location) =
			(location - dbg$gl_runframe [dbg$l_user_regs]) / %UPVAL%;

GLOBAL ROUTINE dbg$out_regname( out_buf, address) =
!++
! Functional Description
!
!	Given an address, see if it falls within the current
!  runframe in such a way as one could say that this address
!  corresponds to one of the general registers.  If this is
!  not the case, we return FALSE.  Otherwise we output the
!  name of the indicated register and return TRUE.
!
! Formal Parameters:
!
!	address	-the address which we are trying to symbolize
!	out_buf - the address of the output buffer
! Implicit Inputs:
!
!	The format and use of the register table
!  which is local to this module.
!
! Return Value
!	TRUE or FALSE.  See above.
!
! Side Effects:
!
!	We may output a register name to the current output buffer.
!
!--
BEGIN
	BIND
		register_vector = dbg$gl_runframe [ DBG$L_USER_REGS ] : VECTOR;
	LOCAL
		reg_index;

	IF( NOT this_is_reg(.address) )
	then
		return(false);

	reg_index = reg_offset(.address);

	! Check that the address EXACTLY matches one which
	! we currently bind to a register name.

	IF( register_vector[.reg_index] NEQA .address )
	then
		return(FALSE);

	! An exact match has been found.
	! Output the register name and return
	! a success status.

	dbg$fao_put( .out_buf, UPLIT( %ASCIC '!AC' ),
		register_table[.reg_index, ctd_reg_name ]);

	return(TRUE);
END;

ROUTINE output_mem_loc(location, symbol_nt_ptr, type) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	Outputs the value of a memory location to the output
!	device. If this routine is called as a result of an EXAMINE
!	command, the location itself is also displayed, followed by
!	a colon and a tab.
!
!	The appropriate mode settings are used to control the output
!	style.
!
! INPUTS:
!	location	- location whose contents are to be displayed.
!	symbol_nt_ptr	- The NT_PTR of the symbol where the LOCATION
!			  may have originated.
!	type		- The type of the expression to be examined.
!
! IMPLICIT INPUTS:
!	dbg$gl_context [dbg$k_examine]	- if this bit is set, the
!					  address of the value
!					  is also displayed.
!	DBG$GL_MOD_PTR			- pointer to the current mode level.
!
! OUTPUTS:
!	True for success, false for failure.
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	TRUE OR FALSE
!
! SIDE EFFECTS:
!	-An error message is produced if the memory location
!	 is not readable.
!--

BEGIN
	MAP
		symbol_nt_ptr : ref rst$entry;
	LOCAL
		output_buffer : VECTOR[ tty_out_width, BYTE];
	bind
		register_vector = dbg$gl_runframe[dbg$l_user_regs] : vector;

	! Set up to do standard DEBUG I/O.

	dbg$cp_out_str = output_buffer + 1;
	dbg$gl_buf_siz = 0;
	IF .dbg$gl_context [dbg$k_examine]
	THEN
		BEGIN

		!++
		! Print the address, symbolically or otherwise,
		! making it come out as LONG regardless of the current
		! LENGTH mode.  Also pass on the associated NT pointer
		! since OUT_SYM_VAL appreciates all the help it can get.
		!--
		if (.symbol_nt_ptr eql 0)
		and (this_is_reg(.location))
		and (.type eql -1)
		and (register_vector[reg_offset(.location)] eqla .location)
		then
			type = dsc$k_dtype_lu;
		dbg$out_sym_val( .location, 0,
					.symbol_nt_ptr, output_buffer);
		dbg$gl_last_loc = .location;
		dbg$gb_loc_type = memory_loc;
		dbg$fao_put ( output_buffer, colon_tab_stg );
		END;

	IF .location EQLA dbg$gl_runframe[ DBG$L_USER_PSL ]	! We output the PSL in a special format
	then
		BEGIN


		! The output is either symbolic or numeric.

		IF .dbg$gb_mod_ptr[ MODE_SYMBOLS ]
		THEN
			dbg$output_psl(..location, output_buffer )
		ELSE
			dbg$out_num_val( output_buffer, ..location, 0, 0 );

		! Set the 'next location' and 'last value' pseudos.

		dbg$gl_next_loc = .location + %upval;
		dbg$gl_last_val = ..location;

		END
	ELSE			!  HANDLE OUTPUT AS SYMBOLIC INSTRUCTIONS SEPARATELY.

	    IF .type EQL dsc$k_dtype_zi
	    THEN
		IF (location = dbg$ins_decode( .location, output_buffer )) EQL 0
		THEN
		    SIGNAL (dbg$_nodecode)
		ELSE
		    dbg$gl_next_loc = .location
	    ELSE	
		BEGIN		! THEN, SPECIAL ATTENTION FOR ASCII OUTPUT.

		IF .type EQL dsc$k_dtype_t
		THEN
			BEGIN
			LOCAL
				pos,
				size;
			!+
			! Set number of characters to be output by command
			! argument list, if possible. Check for command
			! or global overrides.
			!-
			size = ( selectone true
				of
				set

				[.dbg$gl_loctyp neq -1] :
					begin
					.dbg$gw_loclngth
					end;

				[.dbg$gl_gbltyp neq -1] :
					begin
					.dbg$gw_gbllngth
					end;

				[.list_elem_size(.dbg$gl_lis_ptr) neq 0] :
					begin
					.list_elem_size(.dbg$gl_lis_ptr)
					end;

				[.dbg$gl_asci_len GEQ 0] :
					begin
					.dbg$gl_asci_len
					end;

				[otherwise] :
					begin
					4
					end;
				tes);
			!+
			! CHECK FOR ASCI STRING BEING LOCATED INSIDE OF A BLISS
			! STRUCTURE WITH FIELD REFS.
			!-
			if .dbg$gl_lis_ptr neq 0
			then
			if .list_elem_args(.dbg$gl_lis_ptr) neq 0
					or
			   .list_elem_fldrf(.dbg$gl_lis_ptr) neq 0
			then
			    begin
			    location = .location + .list_elem_pos(.dbg$gl_lis_ptr) / %bpunit;
			    end;

			IF .SIZE NEQ 0
			THEN
			    dbg$read_access (.location, .size);

			IF .SIZE EQL 0
			THEN DBG$FAO_PUT( output_buffer, CS_ASCII, 1,
					UPLIT(%ASCII ' '))
			ELSE 
				BEGIN
				dbg$fao_put( output_buffer, cs_ascii,
					.size, .location );
				END;
			dbg$gl_next_loc = .location + .size;
			IF .size GTR %UPVAL		! Truncate if necessary to set last_val.
			THEN
			    size = %UPVAL;
			pos = .dbg$gl_asci_len - .size;	! Calculate starting position
			IF .LOCATION NEQA 0
			THEN dbg$gl_last_val = .(.location) <.pos * 8,.size * 8>
			ELSE DBG$GL_LAST_VAL = 0;
			END
		ELSE	
			BEGIN
			dbg$read_access (.location, .dbg$gb_mod_ptr[mode_length]);
			IF 
			   NOT ( IF .symbol_nt_ptr EQL 0 
				 THEN
					dbg$out_typ_val(output_buffer,
						.location, .type)
				 ELSE
					dbg$out_typ_val(output_buffer,
						.location, .type,
						   .symbol_nt_ptr))
			THEN
				if .dbg$gl_dflttyp eql dsc$k_dtype_zi
				then
					if (location = dbg$ins_decode(.location,output_buffer)) eql 0
					then
						signal (dbg$_nodecode)
					else dbg$gl_next_loc = .location
				else
			BEGIN
				dbg$out_num_val (output_buffer, ..location,
							0, 0);
				dbg$gl_next_loc = .location + .dbg$gb_mod_ptr [mode_length];
				dbg$gl_last_val = .(.location) <0, .dbg$gb_mod_ptr [mode_length] * 8>;
				END;
			END;
		END;

	dbg$out_put( output_buffer );	! Write out the string and we're done.

END;

GLOBAL ROUTINE dbg$evaluat_cmd : novalue =
!++
! Functional description:
!
!	This routine performs DEBUG's action for the evaluate
! command - DEBUG's "desk calculator".  It relies on a common
! routine used by examine for most cases - having first extracted
! out the only two which are different, instruction and ascii evaluations.
!
! Implicit Inputs:
!
!	A global contains a pointer to the so-called 'command arg list'
! which this and most commands work from.  For evaluate, each
! record of the arg list essentially contains all that  is needed
! for one evaluation.
!
! Routine Value:
!	novalue
!
! Side Effects:
!
!	Output is produced which corresponds to whatever the
! user has asked us to EValuate.
!
!	A SIGNAL and UNWIND may be produced if some error occurs.
!--
BEGIN
	LOCAL
		pointer,
		output_buffer : vector[ TTY_OUT_WIDTH, BYTE];

	!+
	! Loop thru the arg list evaluating each expression therein.
	! If there is nothing in the list, the the bulk of this
	! routine is not executed.
	!-

	pointer = .dbg$gl_head_lst;

	WHILE .pointer NEQ 0
		DO
		BEGIN
		dbg$cp_out_str = output_buffer + 1;	! Set up to do standard DEBUG I/O.
		dbg$gl_buf_siz = 0;
		DBG$GL_LIS_PTR = .POINTER;   ! SET GLOBAL POINTER FOR OUTPUT_MEM_LOC

		!+
		! If auxiliary storage is associated with this command
		! arg record, then a quoted string must have been given
		! in some context as part of an evaluate expression.
		! In the case where ONLY this string was given, we
		! take evaluate to mean "print out the hex bytes which
		! correspond to the given string".  
		!-

		IF  (.list_elem_store(.pointer) NEQA 0)
		AND (.list_elem_store(.pointER) EQLA .list_elem_exp1(.pointER))
		THEN
			BEGIN
			LOCAL
				size,
				cs_ptr : ref vector[,byte],
				out_instruc : vector[tty_out_width,byte];
			! If the data is in the form of an ascii string
			! which is supposed to be an instruction, we
			! must first perform this transformation.

			IF .dbg$gb_mod_ptr[mode_instruc]
			THEN
				begin

				! Using the current PC, if needed, for
				! this instruction, cause it to be encoded
				! from the ASCII form to a counted-byte
				! (binary) form in a local buffer.

				IF NOT dbg$ins_encode (.list_elem_store(.pointer),
							out_instruc,
							.dbg$gl_runframe[DBG$L_USER_PC] )
				then
					! A message should already have
					! been produced...
			
					SIGNAL(DBG$_NODECODE);
					! no return
				! Transformation complete.  Now the encoded
				! byte stream is the one which we want to 
				! print out.

				cs_ptr = out_instruc;
				end
			ELSE
				! ASCII strings are already in the
				! counted-byte format.

				cs_ptr = .list_elem_store(.pointer);

			!+
			! Loop printing out each byte of the counted
			! byte stream we were given or we have produced.
			! We print the bytes out backwards to conform to
			! how numbers are always printed.  This is also why
			! we force the radix to HEX - you can't easily
			! decimalize arbitrary-size values.  We also go
			! to some trouble to make the HEX output look
			! like hex - atleast 8 characters and a leading 0.
			!-
			!+
			! As per the usual hex output, we force a
			! leading 0 if otherwise it would begin with
			! an alphabetic.  Moreover, for output which
			! would be less than 8 characters, we force
			! out some leading 0s to fill it out.
			!-
			size = .cs_ptr[0];

			IF .size EQL 1
			THEN
				BEGIN
				dbg$out_num_val(output_buffer,.cs_ptr[1],
					byte_length,0)
				END
			ELSE
				BEGIN
				IF( .size LSS %UPVAL )
				THEN
					BEGIN
					! Force out the right number of '00's.
					INCR j from 1 to %UPVAL-.size
						DO
						dbg$fao_put(output_buffer,
							uplit(%ascic '00'));
					END
				ELSE
					IF( .cs_ptr[.size] GTRA %X'9F' )
					THEN
						dbg$fao_put(output_buffer,
							uplit(%ascic '0'));
				! Now print the number out backwards.
				decr i from .size to 1
					do
					dbg$fao_put(output_buffer,
						uplit(%ASCIC '!XB'),.cs_ptr[.i]);
				END;
			! Write out the string, set the pseudo for
			! last-value-displayed, and we're done.
			! Note that we pick up at most 4 bytes
			! to copy into last_val, that we truncate without
			! warning, and that we 0-fill if necessary.

			dbg$out_put( output_buffer );
			dbg$gl_last_val = 0;
			IF( .size GTR %upval )
			then
				size = %upval;
			ch$move(.size, cs_ptr[1], dbg$gl_last_val);
			END
		ELSE
			IF .list_elem_type(.pointer) EQL dsc$k_dtype_fld
			THEN
			    BEGIN
			    LOCAL
				num,				! number of fields
				addr : REF BLOCK [,BYTE];	! address of values
			    addr = .list_elem_exp1(.pointer);
			    num = .addr[0,0,32,0] - 1;
			    addr = .addr + 5 + .addr[4,0,8,0];
			    dbg$out_num_val (output_buffer, .addr[0,0,32,0],
					long_length, decimal_radix);
			    INCR I from 1 to .num DO
				BEGIN
				dbg$fao_put (output_buffer,
					UPLIT (%ASCIC', ') );
				addr = .addr + 4;
				dbg$out_num_val (output_buffer,
						.addr[0,0,32,0], long_length,
						decimal_radix);
				END;
			    dbg$out_put (output_buffer);
			    dbg$gl_last_val = .addr[0,0,32,0];
			    END
			ELSE
			    !+
			    ! If there was no indirection specified, but there
			    ! was a field reference, just add the pos to the address
			    IF .list_elem_dot (.pointer) NEQ 1
			    AND (.list_elem_args(.pointer) NEQ 0 
				 OR .list_elem_fldrf(.pointer) NEQ 0)
			    THEN
				BEGIN
				list_elem_exp1 (.pointer) = .list_elem_exp1 (.pointer) +
						.list_elem_pos(.pointer) / %BPUNIT;
				dbg$out_num_val(output_buffer,
						.list_elem_exp1(.pointer),
						long_length, 0);
				dbg$out_put (output_buffer);
				dbg$gl_last_val = .list_elem_exp1 (.pointer);
				END
			    ELSE
			    !+
			    ! SET UP DOT FIELD TO CHECK FOR INDIRECTION IN BLISS OR MACRO
			    !-
		 		BEGIN
				IF .DBG$GB_LANGUAGE NEQ LANG_BLISS
					AND
				   .DBG$GB_LANGUAGE NEQ LANG_MACRO
					AND
				   NOT .DBG$GB_MOD_PTR[MODE_IMMEDIATE]
				THEN
				    LIST_ELEM_DOT(.POINTER) = 1;

				! NOW CHECK FOR INDIRECTION
				IF NOT .LIST_ELEM_DOT(.POINTER)

				THEN ! OUTPUT AN ADDRESS
				    BEGIN
			     	    IF .DBG$GB_MOD_PTR[MODE_SYMBOLS]

				    THEN  ! TRY TO SYMBOLIZE REGISTER
				  	BEGIN

					LOCAL
					    reg_addr;

					! See if the address wil map to a
					! register

				        IF dbg$exact_map_to_reg (.list_elem_exp1(.pointer),
								 reg_addr)
					THEN
					    list_elem_exp1 (.pointer) = .reg_addr;

					IF NOT DBG$OUT_REGNAME(output_buffer,
						.LIST_ELEM_EXP1(.POINTER))
					THEN
					    DBG$OUT_NUM_VAL(output_buffer,
						.LIST_ELEM_EXP1(.POINTER),
							LONG_LENGTH, 0);
					END

				    ELSE  ! DO NOT SYMBOLIZE
					DBG$OUT_NUM_VAL(output_buffer,
						.LIST_ELEM_EXP1(.POINTER),
							LONG_LENGTH, 0);
				    DBG$OUT_PUT(OUTPUT_BUFFER);
				    DBG$GL_LAST_VAL = .LIST_ELEM_EXP1(.POINTER);
				    END

				ELSE  ! VALUE TO BE OUTPUT, NOT ADDRESS
				    BEGIN
				    LOCAL
					NEXT_LOCATION;
				    NEXT_LOCATION = .DBG$GL_NEXT_LOC;
				    DBG$GL_ASCI_LEN = .DBG$GB_MOD_PTR[MODE_LENGTH];
				    OUTPUT_MEM_LOC(LIST_ELEM_EXP1(.POINTER),
						   .LIST_ELEM_NTPTR(.POINTER),
						   .LIST_ELEM_TYPE(.POINTER));
				    DBG$GL_NEXT_LOC = .NEXT_LOCATION;
				    END;
				END;
		!+
		! Go back and evaluate anything else in the
		! command arg list.
		!-
		pointer = .list_elem_flink (.pointer);
		END;

	RETURN;
END;

GLOBAL ROUTINE dbg$reg_match (string_desc) =
!++
! Functional description:
!	Compares a string described by the string descriptor passed
!	as the routine formal to each of the names of the machine
!	registers. If the string matches a register name, return the
!	number of the register (0-16, where 16 is the PSL). Otherwise,
!	return a -1.
!
! Inputs:
!	string_desc	- string descriptor to symbol string
!
! Implicit inputs:
!	the VAX machine register table
!
! Implicit outputs:
!	none
!
! Routine value:
!	The register number 0 - 16 if a match is found.
!	-1 if no match is found.
!
! Side effects:
!	none
!--

	BEGIN

	MAP
		string_desc : REF BLOCK [, BYTE];



	INCR index from 0 to register_count-1 DO
	    BEGIN
	    IF ch$eql (.string_desc[dsc$w_length], ch$ptr(.string_desc [dsc$a_pointer]),
			.register_table[.index, reg_ch_cnt],
			ch$ptr(register_table[.index, reg_name]))
	    THEN
		RETURN .index;
	    END;

	RETURN (-1);

	END;

GLOBAL ROUTINE dbg$output_psl (value, buffer) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	Formats and outputs two lines of specially
!	formatted data contained in the PSL. The fields shown are
!
!		CMP	- compatibility mode
!		TP	- trace trap pending
!		FPD	- first part done
!		IS	- interrupt stack
!		CURMOD	- current access mode
!		PRVMOD	- previous access mode
!		IPL	- interrupt priority level
!		DV	- decimal overflow trap enable
!		FU	- floating underflow trap enable
!		IV	- integer overflow trap enable
!		T	- trace trap
!		N	- condition code
!		Z	- condition code
!		V	- condition code
!		C	- condition code
!
! CALLING SEQUENCE:
!	dbg$output_psl ()
!
! INPUTS:
!	value	-The current contents of the PSL
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUTS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE value:
!	NOVALUE
!
! SIDE EFFECTS:
!	Two lines are output to the output device.
!--

BEGIN
	MAP
		value: BLOCK;
	MACRO
		position_field	= 0, 8, 1%,
		size_field	= 8, 8, 1%,
		mode_field	= 16, 4, 1%,
		blanks_field	= 20, 4, 1%,
		width_field	= 24, 8, 1%,

		psl_field (name, position, size, mode, width, leading_blanks) =
			position, size, mode OR (leading_blanks ^ 4), width%;

	LITERAL
		decimal		= 0,
		max_psl_field	= 15;

	BIND
		psl_table = UPLIT BYTE (

		psl_field (CMP, 31, 1, 0, 1, 1),
		psl_field (TP, 30, 1, 0, 1, 3),
		psl_field (FPD, 27, 1, 0, 1, 2),
		psl_field (IS, 26, 1, 0, 1, 3),
		psl_field (CURMOD, 24, 2, 1, 4, 2),
		psl_field (PRVMOD, 22, 2, 1, 4, 3),
		psl_field (IPL, 16, 5, 0, 2, 3),
		psl_field (DV, 7, 1, 0, 1, 2),
		psl_field (FU, 6, 1, 0, 1, 2),
		psl_field (IV, 5, 1, 0, 1, 2),
		psl_field (T, 4, 1, 0, 1, 1),
		psl_field (N, 3, 1, 0, 1, 1),
		psl_field (Z, 2, 1, 0, 1, 1),
		psl_field (V, 1, 1, 0, 1, 1),
		psl_field (C, 0, 1, 0, 1, 1))

		: BLOCK,

		hex_number	= UPLIT BYTE (%ASCIC '!AD!#XB'),
		stg_desc	= UPLIT BYTE (%ASCIC '!AD!AD'),
		blanks		= UPLIT BYTE (%ASCII '    '),

		priv_modes	= UPLIT BYTE (

		%ASCII 'KERN',
		%ASCII 'EXEC',
		%ASCII 'SUPR',
		%ASCII 'USER')

		: VECTOR;

	! Write out the standard title which describes the PSL fields.

	dbg$fao_put (.buffer,
	 UPLIT (%ASCIC '!_CMP TP FPD IS CURMOD PRVMOD IPL DV FU IV T N Z V C'));
	dbg$out_put (.buffer);
	dbg$cp_out_str = .buffer + 1;
	dbg$gl_buf_siz = 0;
	dbg$fao_put (.buffer, UPLIT (%ASCIC '!_'));
	INCR count FROM 0 TO max_psl_field - 1 DO
		IF .psl_table [.count, mode_field] EQL decimal
		THEN
			BEGIN
			dbg$fao_put (.buffer, hex_number,
				.psl_table [.count, blanks_field], blanks,
				.psl_table [.count, width_field],
				.value [0, .psl_table [.count, position_field],
				.psl_table [.count, size_field], 0]);
			END
		ELSE
			BEGIN
			dbg$fao_put (.buffer, stg_desc,
				.psl_table [.count, blanks_field], blanks,
				.psl_table [.count, width_field],
				priv_modes [.value [0, .psl_table [.count, position_field],
					.psl_table [.count, size_field], 0]]);
			END;
END;

GLOBAL ROUTINE dbg$examine_cmd : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	THE COMMAND ARGUMENT LIST WHICH DESCRIBES A SEQENCE OF OPERANDS EACH
!	OF WHICH DESCRIBES A SINGLE OBJECT OR A RANGE OF OBJECTS TO BE EXAMINED
!
! INPUTS:
!	NONE
!
! IMPLICIT INPUTS:
!	THE HEAD OF THE LINKED COMMAND ARGUMENT LIST.
!	THE LAST EXPRESSION EXAMINED, AND THE NEXT LOGICAL EXPRESSION
!	TO EXAMINE.
!
! OUTPUTS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NEW VALUES FOR LAST AND NEXT location, AND LAST VALUE
!
! ROUTINE VALUE:
!	NOVALUE
!
! SIDE EFFECTS:
!	THE VALUES OF VARIOUS EXPRESSIONS ARE OUTPUT TO THE TERMINAL
!	If an error occurs, the routine returns without further
!	processing except to output an error message to the output
!	device.
!--

	BEGIN

	LOCAL
		pointer;


	pointer = .dbg$gl_head_lst;
	IF .pointer EQLA 0
	THEN
		!++
		! No location was specified.
		! Print the next location using the type override 
		! if one was given.
		! NOTE:  if no override type was specified, the
		! type is set to -1.  output_mem_loc interprets this
		! to mean no type information was supplied.
		!--
		IF .dbg$gl_loctyp EQL -1
		    THEN  output_mem_loc(.dbg$gl_next_loc, 0, .dbg$gl_gbltyp)
		    ELSE  output_mem_loc(.dbg$gl_next_loc, 0, .dbg$gl_loctyp)
	ELSE
	    DO
		BEGIN

		LOCAL
			last_loc;

		!++
		! Pick up the next value which we will try to
		! display and copy it into last_loc.
		!--
		last_loc = .list_elem_exp1 (.pointer);

		!++
		! Save the pointer in a GLOBAL location so that the "current"
		! element of the command argument list will be accesible later
		!--
		dbg$gl_lis_ptr = .pointer;

		!++
		! If the end range argument is null, then make it the
		! same as the start range argument so that only one
		! location will be displayed.
		!--
		IF .list_elem_exp2 (.pointer) EQLA 0
		THEN list_elem_exp2 (.pointer) = .list_elem_exp1 (.pointer);


		!++
		! Check for range reversal.
		!--
		IF( .list_elem_exp2(.pointer) LSSA .list_elem_exp1(.pointer) )
		THEN
			BEGIN
			SIGNAL (dbg$_exarange);
			RETURN
			END;

		! Now output each location in the range.

		WHILE (.last_loc LEQA .list_elem_exp2 (.pointer))
			DO
			BEGIN
			LOCAL
			    type,
			    nt_ptr : REF rst$entry;

    			IF .dbg$gl_lis_ptr NEQ 0
    			THEN
    			    nt_ptr = .list_elem_ntptr(.pointer)
    			ELSE
    			    nt_ptr = 0;

			!+
			! If an override type is present use it.
			!-
			IF .dbg$gl_loctyp NEQ -1
			    THEN
				BEGIN
				type = .dbg$gl_loctyp;

    				! zero out nt_ptr if type is instruction.
    				! ( I'm not quite sure why, but symbolization
    				!   of program locations works better when
    				!   no name table pointer is supplied)
    				IF .type EQL dsc$k_dtype_zi
    				THEN
    				    nt_ptr = 0;
				END
			ELSE IF .dbg$gl_gbltyp NEQ -1
			    THEN
				BEGIN
				type = .dbg$gl_gbltyp;

    				! zero out nt_ptr if type is instruction.
    				! ( I'm not quite sure why, but symbolization
    				!   of program locations works better when
    				!   no name table pointer is supplied)
    				IF .type EQL dsc$k_dtype_zi
    				THEN
    				    nt_ptr = 0;
				END
			!+
			! The NTPTR field in the command arg list contains
			! the NT_PTR which the symbols came from in
			! the first place.  Extract this pointer and pass it
			! on to OUTPUT_MEM_LOC. If we are examining a range of
			! locations, however, we can't rely on the command arg
			! list. So NT_PTR will be set to 0.
			!-
			ELSE 
			    BEGIN

			    IF .nt_ptr NEQ 0
			        THEN
			        type = dbg$rst_type(.nt_ptr)
				ELSE
				!+
				! The nt_ptr is 0, but only reset type to -1 if the
				! variable being examined is NOT a permanent symbol.
				! If it is a permanent symbol, the type is longword
				! logical.
				!-
			    	type = -1;
			    END;

			output_mem_loc(.last_loc, .nt_ptr, .type);

			! If a BLISS field reference was made with the size field = 0
			! then next_loc will not have been updated. So we must
			! fudge last_loc in order to terminate the WHILE loop

			IF .last_loc EQLA .dbg$gl_next_loc	
			THEN					
				last_loc = .last_loc + 1
			ELSE
				last_loc = .dbg$gl_next_loc;

			! If access actuals were suppplied in the command line
			! we have to symbolize every location in the range 
			! with access actuals

			IF .list_elem_args(.pointer) EQL 1
			THEN
				list_elem_args(.pointer) = 2;
			END;

		END
	    UNTIL (pointer = .list_elem_flink (.pointer)) EQLA 0;

	END;	! of DBG$EXAMINE_CMD

GLOBAL ROUTINE dbg$digit_scan(a,l,nd)=
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine will scan the string pointed to by 'a' with
!	length 'l' to determine if it is a valid digit string.
!	it will also build a new descriptor for the input
!
! INPUTS:
!
!	a - address of string
!	l - length of string
!	nd - pointer to new descriptor
!
! IMPLICIT INPUTS:
!
! OUTPUTS:
!	none
!
! IMPLICIT OUTPUTS:
!
! ROUTINE VALUE:
!	1 - a valid digit string
!	3 - a valid digit string beginning with a sign   + or -
!	0 - not a valid digit string
!
! SIDE EFFECTS:
!
!--
BEGIN
builtin cvtsp,cvtpl;
MAP  a : ref vector[,byte],nd : ref block[,byte];
LOCAL s,i,dp,dpp,ep,esn,p : vector [40,byte],ln,f,nwl;
BIND max_packed_size = uplit(31);


    i = 0 ;
    s = 1 ;
    f = dp=ep=dpp=esn=0;
!
! get possible trailing spaces
    nwl = .l ;
    WHILE .a[.nwl-1] EQL %c' '
    DO
	if (nwl = .nwl-1) leq 0 then return 0;
! skip over possible leading spaces
    WHILE .a[.i] eql %c' '
	DO
	BEGIN
	INCR c from 0 to .nwl-1
	    DO
		a[.c] = .a[.c+1];
	if (nwl = .nwl-1) leq 0 then return 0;
	END;

    nd[dsc$w_length] = .nd[dsc$w_length] - (.l-.nwl);

    IF .a[.i] eql %C'+' OR .a[.i] eql %C'-'
    THEN
	BEGIN
	s = 3 ;
	i = .i + 1 ;
	nd[dsc$b_dtype] = dsc$k_dtype_nl ;
	END
    ELSE
	nd[dsc$b_dtype] = dsc$k_dtype_nro ;

    INCR c from .i to .nwl-1 
    DO
	BEGIN
	if .a[.c] eql %c'.'
	then
	    if .dp
	    then 
		return 0
	    else
		begin
		dp = 1;
		dpp = .c;
		end
	else
	    if .a[.c] eql %c'd' or .a[.c] eql %c'D' or 
		.a[.c] eql %c'e' or .a[.c] eql %c'E'
	    then
		if .ep neq 0
		then
		    return 0
		else
		    ep = .c
	    else
		if .a[.c] eql %c'+' or .a[.c] eql %c'-'
		then
		    if .esn neq 0 or .ep eql 0
		    then
			return 0
		    else
			esn =(if .a[.c] eql %c'+' then 1 else -1)
		else
		    if not (.a[.c] geq %c'0' and .a[.c] leq %c'9')
		    then
			return 0
	END;

! now construct scale factor for desc and redo the length


    if .ep neq 0
    then
	begin
	i =.nwl-.ep-1;
	if .esn eql 0
	then
	    begin
	    a[.ep] = %c'+';
	    cvtsp(i,a[.ep],max_packed_size,p[0]);
	    end
	else
	    begin
	    i = .i -1 ;
	    cvtsp(i,a[.ep+1],max_packed_size,p[0]);
	    end;
	cvtpl(max_packed_size,p[0],ln);
	nd[dsc$b_scale] = .ln ;
	nd[dsc$w_length] = .ep ;
	nwl = .ep ;
	end;


    if .dp eql 0
    then
	0
    else
	begin
	ln = (.nwl-.dpp-1);
	nd[dsc$b_scale] = .nd[dsc$b_scale] - .ln ;
	nd[dsc$w_length] = .nd[dsc$w_length] - 1 ;
	ch$move(.ln,a[.dpp+1],p[0]);
	ch$move(.ln,p[0],a[.dpp]);
	end;
    if .nd[dsc$b_dtype] eql dsc$k_dtype_nl
    then
	nd[dsc$w_length] = .nd[dsc$w_length] - 1;


    return .s 				! catch all return
END;		! End of digit_scan


GLOBAL ROUTINE DBG$MAP_TO_REG_ADDR (INPUT_ADDR, OUTPUT_ADDR) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine examines the input address to see if it corresponds to some
!	address in the dbg$reg_values register save area maintained by the
!	routines dbg$sta_setcontext and dbg$sta_setregisters routines. If the
!	address represents some address in the register value save area, then
!	the address is mapped to the corresponding address in the dbg$l_user_regs
!	register save area.
!
! FORMAL PARAMETERS:
!
!	INPUT_ADDR	- A longword containing the address on which to attempt 
!			  the mapping
!
!	OUTPUT_ADDR	- The address of a longword to contain the resulting mapped
!			  address
!
! IMPLICIT INPUTS:
!
!	The address of the register context save area, dbg$reg_values, and the
!	address of the user runframe register save area, dbg$gl_runframe [dbg$l_user_regs].
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS	(1)	- Success. Input address mapped, and mapped address
!				  returned.
!
!	STS$K_SEVERE	(4)	- Failure. No mapping.
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN

    LOCAL
	RUNFRAME_ADDRS_VECT	: REF VECTOR [,BYTE]; ! Runframe regs area

    runframe_addrs_vect = dbg$gl_runframe [dbg$l_user_regs];

    ! Check to see if the input address falls in the register context save area.

    IF .input_addr GEQA dbg$reg_values [0]
			AND
       .input_addr LSSA dbg$reg_values [17] ! The register vector has only 17 longwords
    THEN
	BEGIN

	! Input_addr definitely coresponds to some address in the context area.
        ! Map it to the user runframe.

	.output_addr = runframe_addrs_vect [.input_addr - dbg$reg_values [0]];

	RETURN sts$k_success;
	END
    ELSE
	BEGIN

	! No match

	RETURN sts$k_severe;
	END;
    END;		! End of dbg$map_to_reg_addr


GLOBAL ROUTINE DBG$EXACT_MAP_TO_REG (INPUT_ADDR, REG_ADDR) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine checks to see if the input address can be mapped to the
!	exact starting address of one of the context register value save areas.
!	If it can, then the address is mapped to the starting address of the
!	corresponding runframe registers.
!
! FORMAL PARAMETERS:
!
!	INPUT_ADDR	- A longword containing the address to be mapped
!
!	REG_ADDR	- The address of a longword to contain the address of
!			  the mapped-to register
!
! IMPLICIT INPUTS:
!
!	dbg$gl_runframe [dbg$l_user_regs] - the beginning address of the runframe
!					    registers
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS	(1)	- Success. Input address mapped to register address.
!
!	STS$K_SEVERE	(4)	- Failure. Input address not mapped.
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN

    LOCAL
	RUNFRAME_ADDRESS;				! Address within runframe
							! area

    ! See if the input address maps to any place in the runframe regs

    IF dbg$map_to_reg_addr (.input_addr, runframe_address)
    THEN
	BEGIN

	! See if the resulting mapped address corresponds exactly to a reg
	! beginning address

	IF ((.runframe_address - dbg$gl_runframe [dbg$l_user_regs]) MOD 4) EQL 0
	THEN
	    BEGIN

	    ! Exact match to runframe reg

	    .reg_addr = .runframe_address;
	    RETURN sts$k_success;
	    END;
	END;

    ! No match

    RETURN sts$k_severe;

    END;		! End of dbg$exact_map_to_reg


	
GLOBAL ROUTINE dbg$type_cmd : NOVALUE =
!++
! Functional Description
!	This routine is called from PERFORM_CMD to handle the TYPE command.
!	It uses the list of line number ranges at dbg$gl_head_lst.
!
! Inputs
!	None
!
! Outputs
!	None
!
! Routine Value
!	None
!
! Side Effects
!	The name of the module is displayed at the terminal.
!	This calls a routine in DBSOURCE. Routines in DBGSOURCE eventually
!	cause the text to be displayed at the terminal.
!--
    BEGIN
    LOCAL
	buffer: VECTOR [120, BYTE],
	modnameptr,
	pointer;


    pointer = .dbg$gl_head_lst;

    IF .pointer EQLA 0
    THEN 
	BEGIN ! no line numbers specified
	IF .dbg$src_next_modrstptr EQL 0
	THEN
    	    BEGIN
	    SIGNAL(dbg$_nonxtlin);
	    END;

	! Output the module name
	dbg$sta_symname(.dbg$src_next_modrstptr,modnameptr);

        ! Set up the buffer for dbg$fao_put
        dbg$cp_out_str = buffer[1];
        dbg$gl_buf_siz = 0;

	dbg$fao_put(buffer, UPLIT BYTE(%ASCIC 'module !AC'), .modnameptr);
	dbg$out_put(buffer);

	IF .dbg$gb_language NEQ lang_basic
	THEN
	    BEGIN
	    ! output the lines
	    dbg$src_type_lnum_source(
		.dbg$src_next_modrstptr,
		.dbg$src_next_lnum,
		0,
		.dbg$src_next_lnum,
    		0,
		0);
	    END
	ELSE
	    BEGIN
	    ! basic must be handled separately because of statement numbers.

	    ! *** source line display is not yet implemented for basic

	    ! dbg$src_type_lnum_source(
	    !	.dbg$src_next_modrstptr,
	    !	.dbg$src_next_lnum,
	    !	.dbg$src_next_stmt,
	    !	.dbg$src_next_lnum,
	    !	.dbg$src_next_stmt,
    	    !   0);
	    ! need to find a way to increment the pair (lnum,stnum) to
	    ! point to the next basic line.
	    0
	    END;
	END ! no line numbers specified
    ELSE
	DO
	BEGIN 
	LOCAL
	    low_lnum,
	    high_lnum;

	! Output the module name
	dbg$sta_symname(.list_elem_ntptr(.pointer),modnameptr);

        ! Set up the buffer for dbg$fao_put
        dbg$cp_out_str = buffer[1];
        dbg$gl_buf_siz = 0;

	dbg$fao_put(buffer, UPLIT BYTE(%ASCIC 'module !AC'),.modnameptr);
	dbg$out_put(buffer);


	    ! Line numbers are always decimal. If mode was set to hex, the
	    ! lexer read them as hex numbers so we convert them here.
	    IF .dbg$gb_mod_ptr[mode_radix] EQL hex_radix
	    THEN
		BEGIN
		low_lnum = dbg$hex_dec_cvrt(.list_elem_exp1(.pointer));
		high_lnum = dbg$hex_dec_cvrt(.list_elem_exp2(.pointer));
		END
	    ELSE
		BEGIN
		low_lnum = .list_elem_exp1(.pointer);
		high_lnum = .list_elem_exp2(.pointer);
		END;


	IF .dbg$gb_language NEQ lang_basic
	THEN
	    BEGIN

	    dbg$src_type_lnum_source(
		.list_elem_ntptr(.pointer),
		.low_lnum,
		0,
		.high_lnum,
    		0,
		0);
	    END
	ELSE
	    BEGIN !basic
	    0
	    ! *** this feature is not yet implemented for basic
	    END;
	END
	UNTIL (pointer = .list_elem_flink(.pointer)) EQLA 0;

    END; ! dbg$type_cmd

GLOBAL ROUTINE dbg$exa_source_cmd : NOVALUE =
!++
! Functional Description
!	This routine is called from PERFORM_CMD to handle the EX/SOURCE command.
!	It uses the list of line number ranges at dbg$gl_head_lst.
!
! Inputs
!	None
!
! Outputs
!	None
!
! Routine Value
!	None
!
! Side Effects
!	This calls a routine in DBGSOURCE. Routines in DBGSOURCE eventually
!	cause the text to be displayed at the terminal.
!--
    BEGIN
    LOCAL
	pointer;

    pointer = .dbg$gl_head_lst;

    IF .pointer EQLA 0
    THEN 
	BEGIN ! no PC range specified
        ! output the lines
        dbg$src_type_pc_source(
	    .dbg$gl_next_loc,
	    .dbg$gl_next_loc,
	    1);
	! *** need to update dbg$gl_next_loc here
	END ! no PC range specified
    ELSE
	DO
	BEGIN 
	IF .list_elem_exp2(.pointer) NEQ 0 
	THEN
        dbg$src_type_pc_source(
            .list_elem_exp1(.pointer),
	    .list_elem_exp2(.pointer),
	    1)
	ELSE
	dbg$src_type_pc_source(
	    .list_elem_exp1(.pointer),
	    .list_elem_exp1(.pointer),
	    1);
	! *** need to update dbg$gl_next_loc here
        END
	UNTIL (pointer = .list_elem_flink(.pointer)) EQLA 0;

    END; ! dbg$exa_source_cmd

END
ELUDOM
