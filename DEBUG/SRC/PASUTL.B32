MODULE	PASUTL ( ! Pascal-Specific Utility Routines
	IDENT = 'V03-000'
	)=
BEGIN
!
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
!++
!
! FACILITY:	VAX-11 PASCAL-SPECIFIC DEBUGGER MODULES
!
! ABSTRACT:
!
!	This module contains various routines common to more than the
!	Expression and Primary Interpreters
!
! ENVIRONMENT:	VAX/VMS user mode
!
! AUTHOR: P. Hohensee, CREATION DATE: 21-AUG-1980
!
! MODIFIED BY:
!	PS              28-OCT-1981
!
! REVISION HISTORY:
! 3.0	28-OCT-1981	PS	When deposit a source string <= 32 bits to
!				a target string,  only the 1st byte of the
!				source string is deposited.  This problem is
!				corrected in PAS$_ASSIGN.
!--

REQUIRE 'SRC$:PASPROLOG';

!
! Table of Contents
!
FORWARD ROUTINE
	PAS$_Read_Access		: NOVALUE,	! Check read access
	PAS$_Write_Access		: NOVALUE,	! Check write access
    	Construct_Address_Desc,				! Construct a value descriptor that contains an address
	PAS$_Construct_Value_Desc,			! Construct a value descriptor
    	PAS$_Get_Address		: NOVALUE,	! Obtain the virtual address of an object,
    							! given a Primary Descriptor
	PAS$_Get_Value			: NOVALUE,	! Get the address of an object's value
	PAS$_Tag_Value,					! Get current tag field value
	PAS$_Variant_Check		: NOVALUE,	! Check current variant(s) against a field reference
	PAS$_Assign			: NOVALUE;	! Perform an assignment

!
! EXTERNAL routines
!
EXTERNAL ROUTINE
    	PAS$_Arith_Fetch,					! Fetches

	PAS$_Arith_Convert,					! Conversions
	PAS$_Type_Equal,					! Check type compatibility
    	PAS$_Get_Type;						! Create type record for an object

!
! EXTERNAL storage
!
EXTERNAL
    	PAS$_Message_Vector		: LONG;			! Address of address of error message vector

!
! Semantic Analysis EXTERNAL Storage
!
EXTERNAL
	PAS$_Expr_Depth			: LONG,		! Current Expression Sttack Depth
	PAS$_Expr_Stack			: BLOCKVECTOR [Expr_Stack_Depth, Expr_S_Entry, BYTE]
		FIELD(Expression_Stack_Fields);		! Expression Stack

!
! Standard types
!
EXTERNAL
	PAS$_TRW_Boolean		: BLOCK [,BYTE],
	PAS$_TRW_Char			: BLOCK [,BYTE],
	PAS$_TRW_Double			: BLOCK [,BYTE],
	PAS$_TRW_Double_G		: BLOCK [,BYTE],
	PAS$_TRW_Integer		: BLOCK [,BYTE],
	PAS$_TRW_Quadruple		: BLOCK [,BYTE],
	PAS$_TRW_Real			: BLOCK [,BYTE],
	PAS$_TRW_Unsigned		: BLOCK [,BYTE];

GLOBAL ROUTINE PAS$_Read_Access (Address_Desc, Size) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Checks read access to a specific portion of virtual memory
!
! FORMAL PARAMETERS:
!
!	Address_Desc	- Address of an address descriptor
!	Size		- Number of bits to check
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    MAP
	Address_Desc		: REF DBG$Address_Desc;

    LOCAL
	Number_Of_Bytes;

    BUILTIN
	PROBER;

    IF .Address_Desc[DBG$L_Address_Byte_Addr] EQLA 0
    THEN
	SIGNAL(DBG$_NILDEREF);

    Number_Of_Bytes = .Size ^ -3;
    IF .Address_Desc[DBG$L_Address_Bit_Offset] NEQ 0
    THEN
	Number_Of_Bytes	= .Number_Of_Bytes + 1;

    IF NOT PROBER(%REF(0), Number_Of_Bytes, .Address_Desc[DBG$L_Address_Byte_Addr])
    THEN
	SIGNAL(DBG$_NOACCESSR, .Address_Desc[DBG$L_Address_Byte_Addr]);

    END;

GLOBAL ROUTINE PAS$_Write_Access (Address_Desc, Size) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Checks write access to a specific portion of virtual memory
!
! FORMAL PARAMETERS:
!
!	Address_Desc	- Address of an address descriptor
!	Size		- Number of bits to check
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    MAP
	Address_Desc		: REF DBG$Address_Desc;

    LOCAL
	Number_Of_Bytes;

    BUILTIN
	PROBEW;

    IF .Address_Desc[DBG$L_Address_Byte_Addr] EQLA 0
    THEN
	SIGNAL(DBG$_NILDEREF);

    Number_Of_Bytes = .Size ^ -3;
    IF .Address_Desc[DBG$L_Address_Bit_Offset] NEQ 0
    THEN
	Number_Of_Bytes	= .Number_Of_Bytes + 1;

    IF NOT PROBEW(%REF(0), Number_Of_Bytes, .Address_Desc[DBG$L_Address_Byte_Addr])
    THEN
	SIGNAL(DBG$_NOACCESSW, .Address_Desc[DBG$L_Address_Byte_Addr]);

    END;

ROUTINE Construct_Address_Desc (Is_Data_Object) =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Construct a value descriptor that contains the address of a value,
!	rather than an actual value
!
! FORMAL PARAMETERS:
!
!	Is_Data_Object	- True = Value on the Expression Stack is a data object
!				 (i.e., not the result of an expression evaluation)
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Depth	- Current depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	The address of a value descriptor
!
!--

    BEGIN
    BIND
	Source_Expr		= PAS$_Expr_Stack[.PAS$_Expr_Depth, 0, A_]
		: BLOCK [,BYTE] FIELD(Expression_Stack_Fields);

    LOCAL
	Source_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
	Descriptor		: REF PAS$_Value_Desc;


    ! Allocate space for the value descriptor
    !
    IF NOT DBG$NLIST_FREEZ(PAS$S_VAL_Transient_Size, Descriptor, .PAS$_Message_Vector)
    THEN
    	SIGNAL(DBG$_NOFREE);

    ! Initialize it
    !
    Descriptor[DBG$W_Dhead_Length]	= PAS$S_VAL_Transient_Size * 4;
    Descriptor[DBG$B_Dhead_Type]	= DBG$K_V_Value_Desc;
    Descriptor[DBG$B_Dhead_Lang]	= DBG$K_Pascal;

    ZEROLONG(PAS$S_VAL_Transient_Size - 1, Descriptor[DBG$L_Dhead_Pointer]);

    !
    ! The Permanent_Address field will have to change later on. It is true only
    ! if one of the following hold:
    !	1) static address
    !	2) no lvalue
    !
    Descriptor[PAS$VAL_Permanent_Address]	= False;

    Descriptor[PAS$VAL_Depositable]		= True;

    Source_Type	= .Source_Expr[Expr_Type];

    ! CASE on the type
    !
    CASE .Source_Type[TYP_Class] FROM TYP_K_Array TO TYP_K_Varying OF
    	SET

    [TYP_K_Ordinal] :
    	BEGIN

	IF .Source_Type[TYP_Rst_Class] EQL DSC$K_Dtype_Z
	THEN
	    ! Scalar type
	    !
	    BEGIN
	    BIND
		Symbol_Entry	= .Source_Type[TYP_Symbol]
			: BLOCK [,BYTE] FIELD(Symbol_Fields);

	    Descriptor[PAS$VAL_Type]		= .Symbol_Entry[SYM_Rst_Symid];
	    END

	ELSE
	    Descriptor[PAS$VAL_Srm_Type_Code]	= .Source_Type[TYP_Rst_Class];

	Descriptor[PAS$VAL_Size]		= .Source_Type[TYP_Full_Size] * 8;
	Descriptor[PAS$VAL_Dtype]		= .Source_Type[ORD_Dtype];

	IF .Is_Data_Object
	THEN
	    MOVELONG(2, Source_Expr[Expr_Byte_Address], Descriptor[PAS$VAL_Value_Address])

	ELSE
	    BEGIN
	    LOCAL
		Source_Address;

	    ! Allocate space for the object's value
	    !
	    IF NOT DBG$NLIST_FREEZ(ROUND_BYTE_TO_LONG_(.Source_Type[TYP_Full_Size]), Source_Address,
			.PAS$_Message_Vector)
	    THEN
		SIGNAL(DBG$_NOFREE);

	    PAS$_Arith_Fetch(.Descriptor[PAS$VAL_Dtype], Source_Expr[Expr_Value],
			.Source_Address, .Source_Type[TYP_Packed_Size]);
	    END;

    	END;

    [TYP_K_Pointer] :
    	BEGIN
	BIND
	    Symbol_Entry	= .Source_Type[TYP_Symbol]
			: BLOCK [,BYTE] FIELD(Symbol_Fields);

	IF
	    (IF Symbol_Entry NEQA 0
	    THEN
		.Symbol_Entry[SYM_Rst_Symid] NEQ 0)
	THEN
	    ! RST entry for the type
	    !
	    Descriptor[PAS$VAL_Type]		= .Symbol_Entry[SYM_Rst_Symid]
	ELSE
	    ! No RST entry for the type
	    !
	    Descriptor[PAS$VAL_Type_Entry]	= .Source_Type;

	Descriptor[PAS$VAL_Size]		= .Source_Type[TYP_Full_Size] * 8;
	Descriptor[PAS$VAL_Dtype]		= LU_Int;

	IF .Is_Data_Object
	THEN
	    MOVELONG(2, Source_Expr[Expr_Byte_Address], Descriptor[PAS$VAL_Value_Address])

	ELSE
	    BEGIN
	    LOCAL
		Source_Address;

	    ! Allocate space for the object's value
	    !
	    IF NOT DBG$NLIST_FREEZ(ROUND_BYTE_TO_LONG_(.Source_Type[TYP_Full_Size]), Source_Address,
			.PAS$_Message_Vector)
	    THEN
		SIGNAL(DBG$_NOFREE);

	    PAS$_Arith_Fetch(.Descriptor[PAS$VAL_Dtype], Source_Expr[Expr_Value],
			.Source_Address, .Source_Type[TYP_Packed_Size]);
	    END;

    	END;

    [TYP_K_Real] :
    	BEGIN

	Descriptor[PAS$VAL_Srm_Type_Code]	= .Source_Type[TYP_Rst_Class];
	Descriptor[PAS$VAL_Size]		= .Source_Type[TYP_Packed_Size];
	Descriptor[PAS$VAL_Dtype]		= .Source_Type[REAL_Dtype];

	IF .Is_Data_Object
	THEN
	    MOVELONG(2, Source_Expr[Expr_Byte_Address], Descriptor[PAS$VAL_Value_Address])

	ELSE
	    BEGIN
	    LOCAL
		Source_Address;

	    ! Allocate space for the object's value
	    !
	    IF NOT DBG$NLIST_FREEZ(ROUND_BYTE_TO_LONG_(.Source_Type[TYP_Full_Size]), Source_Address,
			.PAS$_Message_Vector)
	    THEN
		SIGNAL(DBG$_NOFREE);

	    PAS$_Arith_Fetch(.Descriptor[PAS$VAL_Dtype], Source_Expr[Expr_Value],
			.Source_Address, .Source_Type[TYP_Packed_Size]);
	    END;

    	END;

    [TYP_K_Array,
     TYP_K_Record] :
	BEGIN
	BIND
	    Symbol_Entry	= .Source_Type[TYP_Symbol]
			: BLOCK [,BYTE] FIELD(Symbol_Fields);

	IF
	    (IF Symbol_Entry NEQA 0
	    THEN
		.Symbol_Entry[SYM_Rst_Symid] NEQ 0)
	THEN
	    ! RST entry for the type
	    !
	    Descriptor[PAS$VAL_Type]		= .Symbol_Entry[SYM_Rst_Symid]
	ELSE
	    ! No RST entry for the type
	    !
	    Descriptor[PAS$VAL_Type_Entry]	= .Source_Type;

	Descriptor[PAS$VAL_Size]		= .Source_Type[TYP_Packed_Size];

	MOVELONG(2, Source_Expr[Expr_Byte_Address], Descriptor[PAS$VAL_Value_Address]);
	END;

    [TYP_K_Set,
     TYP_K_Varying] :
	BEGIN
	BIND
	    Symbol_Entry	= .Source_Type[TYP_Symbol]
			: BLOCK [,BYTE] FIELD(Symbol_Fields);

	IF
	    (IF Symbol_Entry NEQ 0
	    THEN
		.Symbol_Entry[SYM_Rst_Symid] NEQ 0)
	THEN
	    ! RST entry for the type
	    !
	    Descriptor[PAS$VAL_Type]		= .Symbol_Entry[SYM_Rst_Symid]
	ELSE
	    ! No RST entry for the type
	    !
	    Descriptor[PAS$VAL_Type_Entry]	= .Source_Type;

	Descriptor[PAS$VAL_Size]		= .Source_Type[TYP_Full_Size] * 8;

	MOVELONG(2, Source_Expr[Expr_Byte_Address], Descriptor[PAS$VAL_Value_Address]);
	END;

    [INRANGE] :
	SIGNAL(DBG$_NOVALUE);

    [OUTRANGE] :
    	Pascal_Bugcheck(PAS$K_TYPCLASS);

    	TES;

    ! Return address of descriptor
    !
    .Descriptor
    END;

GLOBAL ROUTINE PAS$_Construct_Value_Desc (Force_Address_Desc, Is_Data_Object) =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Construct a value descriptor corresponding to the top element
!	of the Expression Stack
!
! FORMAL PARAMETERS:
!
!	Force_Address_Desc	- True = Force creation of a value descriptor
!					 that contains the address of a value
!					 rather than the value itself
!	Is_Data_Object		- True = Value on top of the Exression Stack does
!					 not result from an expression evaluation
!					 This also means that the address of the object,
!					 rather than the object itself, is on the
!					 Expression Stack
!
! IMPLICIT INPUTS:
!
!	PAS$_Expr_Depth	- Current depth of the Expression Stack
!	PAS$_Expr_Stack	- The Expression Stack
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	The address of the new value descriptor
!
!--

    BEGIN
    BIND
	Source_Expr		= PAS$_Expr_Stack[.PAS$_Expr_Depth, 0, A_]
		: BLOCK [,BYTE] FIELD(Expression_Stack_Fields);

    LOCAL
	Source_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
	Descriptor		: REF PAS$_Value_Desc;

    ! Check for forced address
    !
    IF .Force_Address_Desc
    THEN
    	RETURN Construct_Address_Desc(.Is_Data_Object);

    !
    ! No forced address, construct a permanent descriptor if possible
    !

    Source_Type	= .Source_Expr[Expr_Type];

    CASE .Source_Type[TYP_Class] FROM TYP_K_Array TO TYP_K_Varying OF
	SET

	! Construct a permanent value descriptor
	!
    [TYP_K_Ordinal] :
	BEGIN
    	LOCAL
    	    Source_Address	: DBG$Address_Desc;

	IF NOT DBG$NLIST_FREEZ(PAS$S_VAL_Perm_Size, Descriptor, .PAS$_Message_Vector)
	THEN
	    SIGNAL(DBG$_NOFREE);

	Descriptor[DBG$W_Dhead_Length]		= PAS$S_VAL_Perm_Size * 4;
	Descriptor[DBG$B_Dhead_Type]		= DBG$K_Value_Desc;
	Descriptor[DBG$B_Dhead_Lang]		= DBG$K_Pascal;
	Descriptor[DBG$L_Dhead_Pointer]		= 0;

	IF .Source_Type[TYP_Rst_Class] EQL DSC$K_Dtype_Z
	THEN
	    ! Scalar type
	    !
	    BEGIN
	    BIND
		Symbol_Entry	= .Source_Type[TYP_Symbol]
			: BLOCK [,BYTE] FIELD(Symbol_Fields);

	    Descriptor[PAS$VAL_Srm_Type_Code]	= 0;
	    Descriptor[PAS$VAL_Type]		= .Symbol_Entry[SYM_Rst_Symid];
	    END

	ELSE
	    BEGIN
	    Descriptor[PAS$VAL_Srm_Type_Code]	= .Source_Type[TYP_Rst_Class];
	    Descriptor[PAS$VAL_Type]		= 0;
	    END;

	Descriptor[PAS$VAL_Permanent_Address]	= False;
	Descriptor[PAS$VAL_Depositable]		= False;
	Descriptor[PAS$VAL_Dtype]		= .Source_Type[ORD_Dtype];
	Descriptor[PAS$VAL_Size]		= .Source_Type[TYP_Full_Size] * 8;
	Descriptor[PAS$VAL_Type_Entry]		= 0;

    	IF .Is_Data_Object
    	THEN
    	    ! Address of object is on the Expression Stack
    	    !
    	    MOVELONG(2, Source_Expr[Expr_Byte_Address], Source_Address)
    	ELSE
    	    ! Value of object is on the Expression Stack
    	    !
    	    BEGIN
    	    Source_Address[DBG$L_Address_Byte_Addr]	= Source_Expr[Expr_Value];
    	    Source_Address[DBG$L_Address_Bit_Offset]	= 0;
    	    END;

	PAS$_Arith_Fetch(.Descriptor[PAS$VAL_Dtype], Source_Address,
    		Descriptor[PAS$VAL_Value], .Source_Type[TYP_Packed_Size]);

	END;

	! Construct a permanent value descriptor
	!
    [TYP_K_Real] :
	BEGIN
    	LOCAL
    	    Source_Address	: DBG$Address_Desc;

	IF NOT DBG$NLIST_FREEZ(PAS$S_VAL_Perm_Size, Descriptor, .PAS$_Message_Vector)
	THEN
	    SIGNAL(DBG$_NOFREE);

	Descriptor[DBG$W_Dhead_Length]		= PAS$S_VAL_Perm_Size * 4;
	Descriptor[DBG$B_Dhead_Type]		= DBG$K_Value_Desc;
	Descriptor[DBG$B_Dhead_Lang]		= DBG$K_Pascal;
	Descriptor[DBG$L_Dhead_Pointer]		= 0;

	Descriptor[PAS$VAL_Srm_Type_Code]	= .Source_Type[TYP_Rst_Class];
	Descriptor[PAS$VAL_Permanent_Address]	= False;
	Descriptor[PAS$VAL_Depositable]		= False;
	Descriptor[PAS$VAL_Dtype]		= .Source_Type[REAL_Dtype];
	Descriptor[PAS$VAL_Type]		= 0;
	Descriptor[PAS$VAL_Size]		= .Source_Type[TYP_Packed_Size];

    	IF .Is_Data_Object
    	THEN
    	    ! Address of object is on the Expression Stack
    	    !
    	    MOVELONG(2, Source_Expr[Expr_Byte_Address], Source_Address)
    	ELSE
    	    ! Value of object is on the Expression Stack
    	    !
    	    BEGIN
    	    Source_Address[DBG$L_Address_Byte_Addr]	= Source_Expr[Expr_Value];
    	    Source_Address[DBG$L_Address_Bit_Offset]	= 0;
    	    END;

	PAS$_Arith_Fetch(.Descriptor[PAS$VAL_Dtype], Source_Address,
    		Descriptor[PAS$VAL_Value], .Source_Type[TYP_Packed_Size]);

	END;

	! Construct a permanent value descriptor
	!
    [TYP_K_Pointer] :
	BEGIN
	BIND
	    Symbol_Entry		= .Source_Type[TYP_Symbol]
			: BLOCK [,BYTE] FIELD(Symbol_Fields);

    	LOCAL
    	    Source_Address	: DBG$Address_Desc;

	IF NOT DBG$NLIST_FREEZ(PAS$S_VAL_Perm_Size, Descriptor, .PAS$_Message_Vector)
	THEN
	    SIGNAL(DBG$_NOFREE);

	Descriptor[DBG$W_Dhead_Length]		= PAS$S_VAL_Perm_Size * 4;
	Descriptor[DBG$B_Dhead_Type]		= DBG$K_Value_Desc;
	Descriptor[DBG$B_Dhead_Lang]		= DBG$K_Pascal;
	Descriptor[DBG$L_Dhead_Pointer]		= 0;

	Descriptor[PAS$VAL_Srm_Type_Code]	= 0;
	Descriptor[PAS$VAL_Permanent_Address]	= False;
	Descriptor[PAS$VAL_Depositable]		= False;
	Descriptor[PAS$VAL_Dtype]		= LU_Int;
	Descriptor[PAS$VAL_Size]		= .Source_Type[TYP_Packed_Size];

	IF
	    (IF Symbol_Entry NEQA 0
	    THEN
		.Symbol_Entry[SYM_Rst_Symid] NEQ 0)
	THEN
	    ! RST entry for the type
	    !
	    BEGIN
	    Descriptor[PAS$VAL_Type]		= .Symbol_Entry[SYM_Rst_Symid];
	    Descriptor[PAS$VAL_Type_Entry]	= 0;
	    END
	ELSE
	    ! No RST entry for the type
	    !
	    BEGIN
	    Descriptor[PAS$VAL_Type]		= 0;
	    Descriptor[PAS$VAL_Type_Entry]	= .Source_Type;
	    END;

    	IF .Is_Data_Object
    	THEN
    	    ! Address of object is on the Expression Stack
    	    !
    	    MOVELONG(2, Source_Expr[Expr_Byte_Address], Source_Address)
    	ELSE
    	    ! Value of object is on the Expression Stack
    	    !
    	    BEGIN
    	    Source_Address[DBG$L_Address_Byte_Addr]	= Source_Expr[Expr_Value];
    	    Source_Address[DBG$L_Address_Bit_Offset]	= 0;
    	    END;

	PAS$_Arith_Fetch(.Descriptor[PAS$VAL_Dtype], Source_Address,
    		Descriptor[PAS$VAL_Value], .Source_Type[TYP_Packed_Size]);

	END;

    [TYP_K_Array,
     TYP_K_Record,
     TYP_K_Set,
     TYP_K_Varying] :
	!
	! Construct an address descriptor
	!
	RETURN Construct_Address_Desc(.Is_Data_Object);

    [INRANGE] :
	SIGNAL(DBG$_NOVALUE);

    [OUTRANGE]	:
	Pascal_Bugcheck(PAS$K_TYPCLASS);

	TES;

    ! Return pointer to the descriptor
    !
    .Descriptor
    END;

GLOBAL ROUTINE PAS$_Get_Address (Prim_Desc, Virtual_Address, Type_Entry) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Given a Primary Descriptor, obtain the virtual address of the object
!	it describes. As a side effect, return the last symid used (explicitly
!	or implicitly) in the Primary Descriptor
!
! FORMAL PARAMETERS:
!
!	Prim_Desc	- Address of a Primary Descriptor
!	Virtual_Address	- Address of an address descriptor
!	Type_Entry	- Address of a longword to contain the address of a type table entry
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    MAP
    	Prim_Desc		: REF PAS$_Primary_Desc,
    	Virtual_Address		: REF DBG$Address_Desc;

    BIND
    	Desc_Vector		= Prim_Desc[PAS$PRIM_Ident]	! Variable length part of Primary Descriptor
    				: VECTOR;

    LOCAL
    	Current_Operand,					! Pointer to current primary descriptor operand
    								! (index into Desc_Vector)
    	Current_Address		: DBG$Address_Desc,		! Current virtual address
    	Current_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),	! Pointer to current object type record
    	Kind,							! RST kind of object
    	Symbol_Class,						! Pascal Symbol Class
    	Operation_Count,					! Number of operations on the
    								! Primary Descriptor to go
    	Symid;							! Pointer to an RST entry

    ! Initialize
    !
    Symid	= .Prim_Desc[PAS$PRIM_Ident];

    ! Get the address of the object
    !
    IF .Prim_Desc[PAS$PRIM_Kind] EQL DBG$K_Val_Literal
    THEN
	! Value is in the Primary Descriptor
	!
	BEGIN
	Current_Address[DBG$L_Address_Byte_Addr]	= Prim_Desc[PAS$PRIM_Address];
	Current_Address[DBG$L_Address_Bit_Offset]	= 0;
	END
    ELSE
	! Address is in the Primary Descriptor. Note that this may be the
	! address of a saved register in the Debugger's register save area,
	! which may contain garbage. We ignore that, for the moment.
	!
	BEGIN
	Current_Address[DBG$L_Address_Byte_Addr]	= .Prim_Desc[PAS$PRIM_Byte_Address];
	Current_Address[DBG$L_Address_Bit_Offset]	= .Prim_Desc[PAS$PRIM_Bit_Offset];
	END;

    ! Get the class of the symbol
    !
    IF .Symid EQLA 0
    THEN
	Symbol_Class = .BLK_B[.Prim_Desc[PAS$PRIM_Symbol], SYM_Class]

    ELSE
	BEGIN

        ! Set up correct context, in case the value is in a register
        !
	DBG$STA_Setcontext( DBG$STA_Symid_In_Frame(.Symid, .Prim_Desc[PAS$PRIM_Frame]) );

	! Get the kind of the object
	!
	DBG$STA_Symkind(.Symid, Kind);

	CASE .Kind FROM RST$K_Kind_Minimum TO RST$K_Kind_Maximum OF
	    SET

	[RST$K_Module] :
    	    Symbol_Class = SYM_K_Procedure;

	[RST$K_Routine] :
    	    Symbol_Class = SYM_K_Procedure;

	[RST$K_Data] :
    	    Symbol_Class = SYM_K_Variable;

	[RST$K_Label] :
    	    Symbol_Class = SYM_K_Label;

	[RST$K_Line] :
    	    Symbol_Class = SYM_K_Line;

	[INRANGE] :
    	    ! Primary Interpreter generated an illegal primary descriptor
	    !
	    Pascal_Bugcheck(PAS$K_ILLPRIM);

	[RST$K_Invalid, OUTRANGE] :
    	    ! DBG$STA_Symkind died
	    !
	    Pascal_Bugcheck(PAS$K_RSTCODE);

	    TES;

	END;

    ! If the symbol is not a data object (i.e., is of type instruction),
    ! there is no more info in the primary descriptor.
    !
    IF	(.Symbol_Class NEQ SYM_K_Constant)	AND
	(.Symbol_Class NEQ SYM_K_Variable)
    THEN
    	BEGIN

    	! Set return values. Virtual_Address is set to contain the address
    	! of the first byte of the first instruction of the reference.
    	!
    	MOVELONG(DBG$K_Address_Desc_Size, Current_Address, .Virtual_Address);
    	.Type_Entry = 0;

    	RETURN;
    	END;

    ! Create a type record for the first object in the descriptor
    !
    IF .Symid EQLA 0
    THEN
	! Predefined
	!
	BEGIN
	BIND
	    Symbol_Entry	= .Prim_Desc[PAS$PRIM_Symbol]	: BLOCK [, BYTE] FIELD(Symbol_Fields);

	IF .Symbol_Class EQL SYM_K_Variable
	THEN
	    Current_Type = .Symbol_Entry[CON_Type]
	ELSE
	    Current_Type = .Symbol_Entry[VAR_Type];
	END
    ELSE
	! RST entry
	!
	Current_Type = PAS$_Get_Type(.Symid, %REF(.Symbol_Class));

    ! Loop thru the Primary Descriptor
    !
    Operation_Count	= .Prim_Desc[PAS$PRIM_Operations];
    Current_Operand	= 0;

    WHILE .Operation_Count GTRU 0 DO
    	BEGIN

	! CASE on the type class
	!
	CASE .Current_Type[TYP_Class] FROM TYP_K_Array TO TYP_K_Varying OF
	    SET

	    [TYP_K_Array] :
		BEGIN
		LOCAL
		    Element_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
		    Index_Type			: REF BLOCK [,BYTE] FIELD(Type_Fields),
		    Index_Base_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
		    Index_Value,
		    Bit_Offset;

		Element_Type	= .Current_Type[ARR_Type];
		Index_Type	= .Current_Type[ARR_Itype];
		Index_Base_Type = .Index_Type[ORD_Type];

		! Point to the next subscript
		!
		Current_Operand	= .Current_Operand + 1;

		! Get the subscript value
		!
		IF .Index_Base_Type[ORD_Unsigned]
		THEN
		    Index_Value = .(Desc_Vector[.Current_Operand])<0, .Index_Base_Type[TYP_Packed_Size], 0>
		ELSE
		    Index_Value = .(Desc_Vector[.Current_Operand])<0, .Index_Base_Type[TYP_Packed_Size], 1>;

		! Calculate bit offset
		!
		Bit_Offset	= (.Index_Value - .Index_Type[ORD_Lower]) *
				(IF .Current_Type[TYP_Packed]
				THEN
				    .Element_Type[TYP_Packed_Size]
				ELSE
				    .Element_Type[TYP_Full_Size] * 8);

		! Add offset to current address
		!
		Bit_Offset
			= .Current_Address[DBG$L_Address_Bit_Offset] + .Bit_Offset;
		Current_Address[DBG$L_Address_Byte_Addr]
			= .Current_Address[DBG$L_Address_Byte_Addr] + (.Bit_Offset ^ -3);
		Current_Address[DBG$L_Address_Bit_Offset]
			= .Bit_Offset AND 7;

		Current_Type	= .Element_Type;
		END;

	    [TYP_K_Pointer] :
		BEGIN

		! Check read access
		!
		PAS$_Read_Access(Current_Address, 32);

		! Dereference the current address
		!
		Current_Address[DBG$L_Address_Byte_Addr]
			= .(.Current_Address[DBG$L_Address_Byte_Addr])
			   <.Current_Address[DBG$L_Address_Bit_Offset], 32>;
		Current_Address[DBG$L_Address_Bit_Offset]
			= 0;

		Current_Type	= .Current_Type[PTR_Type];
		END;

	    [TYP_K_File] :
		BEGIN

		! Check read access to the file variable
		!
		PAS$_Read_Access(Current_Address, 32);

		! Get the address of the file buffer
		!
		IF .Current_Type[FIL_Version] EQL 0
		THEN
		    ! Pascal V2
		    !
		    IF .(.Current_Address[DBG$L_Address_Byte_Addr])<B0_> EQL 0
		    THEN
			! Pascal V2.0. The file buffer is at offset 16(10) from
			! the start of the file variable
			!
			Current_Address[DBG$L_Address_Byte_Addr] =
					.Current_Address[DBG$L_Address_Byte_Addr] + 16
		    ELSE
			! Unsupported version
			!
			SIGNAL(DBG$_FILEVERS)
		ELIF .Current_Type[FIL_Version] EQL 1
		THEN
		    ! Pascal V1.2. The file pointer is the first longword of
		    ! the File Status Block.
		    !
		    Current_Address[DBG$L_Address_Byte_Addr] =
					..Current_Address[DBG$L_Address_Byte_Addr]
		ELSE
		    ! Unsupported version
		    !
		    SIGNAL(DBG$_FILEVERS);

		Current_Address[DBG$L_Address_Bit_Offset] = 0;

		! Get the component type
		!
		Current_Type	= .Current_Type[PTR_Type];
		END;

	    [TYP_K_Record] :
		BEGIN
		LOCAL
		    Field_Entry		: REF BLOCK [,BYTE] FIELD(Keyword_Fields);

		! Point to the symid for the field
		!
		Current_Operand	= .Current_Operand + 1;

		! Find the field block
		!
		Field_Entry = .Current_Type[REC_Fld_Head];
		WHILE .Field_Entry NEQA 0 DO
		    IF DBG$STA_Same_Dst_Object(.Field_Entry[FLD_Rst_Symid], .Desc_Vector[.Current_Operand])
		    THEN
			EXITLOOP
		    ELSE
			Field_Entry = .Field_Entry[FLD_Record_Link];

		IF .Field_Entry EQLA 0
		THEN
		    Pascal_Bugcheck(PAS$K_ILLPRIM);

		! Add the field offset to the current address
		!
		Current_Address[DBG$L_Address_Bit_Offset]
			= .Current_Address[DBG$L_Address_Bit_Offset] + .Field_Entry[FLD_Position];
		Current_Address[DBG$L_Address_Byte_Addr]
			= .Current_Address[DBG$L_Address_Byte_Addr] +
			  (.Current_Address[DBG$L_Address_Bit_Offset] ^ -3);
		Current_Address[DBG$L_Address_Bit_Offset]
			= .Current_Address[DBG$L_Address_Bit_Offset] AND 7;

		! Get the field type
		!
		Current_Type	= .Field_Entry[FLD_Type];
		END;

	    [TYP_K_Varying] :
		BEGIN
		LOCAL
		    Element_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
		    Bit_Offset;

		Element_Type	= .Current_Type[VARY_Type];

		! Point to the next subscript
		!
		Current_Operand	= .Current_Operand + 1;

		! Calculate bit offset
		!
		Bit_Offset	= (.Desc_Vector[.Current_Operand] - 1) *
				((.Current_Type[TYP_Packed_Size] - 16)/ .Element_Type[TYP_Packed_Size]) + 16;

		! Add offset to current address
		!
		Bit_Offset
			= .Current_Address[DBG$L_Address_Bit_Offset] + .Bit_Offset;
		Current_Address[DBG$L_Address_Byte_Addr]
			= .Current_Address[DBG$L_Address_Byte_Addr] + (.Bit_Offset ^ -3);
		Current_Address[DBG$L_Address_Bit_Offset]
			= .Bit_Offset AND 7;

		Current_Type	= .Element_Type;
		END;

	    [INRANGE, OUTRANGE] :
		! Illegal Primary Descriptor
		!
		Pascal_Bugcheck(PAS$K_ILLPRIM);

	    TES;

	Operation_Count	= .Operation_Count - 1;
    	END;

    ! Return current virtual address
    !
    MOVELONG(DBG$K_Address_Desc_Size, Current_Address, .Virtual_Address);

    ! Return the type of the object
    !
    .Type_Entry	= .Current_Type;

    END;

GLOBAL ROUTINE PAS$_Get_Value (Symid, Address_Desc, Kind, Frame) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Obtains the address of an object's value
!	Context is assumed to have been set up by a call to
!	DBG$STA_Setcontext prior to the call to this routine
!
! FORMAL PARAMETERS:
!
!	Symid		- Object's RST Symid
!	Address_Desc	- Address of an address descriptor
!	Kind		- Optional output parameter. Address of longword to place value's kind. May be
!			  zero, in which case nothing is returned.
!	Frame		- Optional output parameter. Address of longword to place frame pointer for
!			  the frame containing the object described by Symid. May be zero, in which case
!			  nothing is returned.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    MAP
	Address_Desc	: REF DBG$Address_Desc;

    LOCAL
	Object_Desc	: VECTOR [3, LONG],
	Value_Kind;

    BUILTIN
	ACTUALCOUNT;

    ! Get the value
    !
    DBG$STA_SYMVALUE(.Symid, Object_Desc, Value_Kind);

    Address_Desc[DBG$L_Address_Byte_Addr]	= .Object_Desc[0];
    Address_Desc[DBG$L_Address_Bit_Offset]	= .Object_Desc[1];

    IF .Value_Kind EQL DBG$K_Val_Descr
    THEN
	! Descriptor address (mostly dynamic arrays)
	!
	BEGIN
	LOCAL
	    Desc	: REF BLOCK [,BYTE];

	! Check read access to the first 4 longwords of the descriptor
	!
	PAS$_Read_Access(.Address_Desc, 128);

	Desc	= .Address_Desc[DBG$L_Address_Byte_Addr];

	IF (.Desc[DSC$B_Class] EQL DSC$K_Class_A)	OR
	   (.Desc[DSC$B_Class] EQL DSC$K_Class_NCA)	OR
	   (.Desc[DSC$B_Class] EQL DSC$K_Class_VS)	OR
	   (.Desc[DSC$B_Class] EQL DSC$K_Class_VSA)
	THEN
	    BEGIN
	    Address_Desc[DBG$L_Address_Byte_Addr] 	= .Desc[DSC$A_Pointer];
	    Address_Desc[DBG$L_Address_Bit_Offset]	= 0;
	    END
	ELIF .Desc[DSC$B_Class] EQL DSC$K_Class_UBS
	THEN
	    BEGIN
	    Address_Desc[DBG$L_Address_Byte_Addr]	= .Desc[DSC$A_Pointer];
	    Address_Desc[DBG$L_Address_Bit_Offset]	= .Desc[DSC$L_Pos];
	    END
	ELIF .Desc[DSC$B_Class] EQL DSC$K_Class_UBA
	THEN
	    BEGIN
	    LOCAL
		Pos_Address	: DBG$Address_Desc;

	    Address_Desc[DBG$L_Address_Byte_Addr]	= .Desc[DSC$A_Pointer];

	    Pos_Address[DBG$L_Address_Byte_Addr]	= Desc[DSC$L_S1] + (.Desc[DSC$B_Dimct] * 12);
	    Pos_Address[DBG$L_Address_Bit_Offset]	= 0;

	    ! Check read access to the bit offset
	    !
	    PAS$_Read_Access(Pos_Address, 32);

	    Address_Desc[DBG$L_Address_Bit_Offset]	= ..Pos_Address[DBG$L_Address_Byte_Addr];
	    END
	ELSE
	    Pascal_Bugcheck(PAS$K_ILLDESC);

	END;

    ! Set the value kind, if requested
    !
    IF ACTUALCOUNT() GTR 2
    THEN
	IF .Kind NEQA 0
	THEN
	    .Kind = .Value_Kind;

    ! Set the frame pointer, if requested
    !
    IF ACTUALCOUNT() GTR 3
    THEN
	IF .Frame NEQA 0
	THEN
	    .Frame = .Object_Desc[2];
    END;

GLOBAL ROUTINE PAS$_Tag_Value (Tag_Field, Record_Address) =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Retrieves the value of the specified tag field
!
! FORMAL PARAMETERS:
!
!	Tag_Field	- Address of a field entry
!	Record_Address	- Address of an address descriptor for the enclosing record
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	The current value of the tag field
!
!--

    BEGIN
    MAP
	Tag_Field	: REF BLOCK [,BYTE] FIELD(Keyword_Fields),
	Record_Address	: REF DBG$Address_Desc;

    LOCAL
	Tag_Field_Size,
	Tag_Field_Address	: DBG$Address_Desc,
	Tag_Value,
	Tag_Value_Address	: DBG$Address_Desc;

    ! Get the field address
    !
    Tag_Field_Address[DBG$L_Address_Bit_Offset]
		= .Record_Address[DBG$L_Address_Bit_Offset] + .Tag_Field[FLD_Position];
    Tag_Field_Address[DBG$L_Address_Byte_Addr]
		= .Record_Address[DBG$L_Address_Byte_Addr] + (.Tag_Field_Address[DBG$L_Address_Bit_Offset] ^ -3);
    Tag_Field_Address[DBG$L_Address_Bit_Offset]
		= .Tag_Field_Address[DBG$L_Address_Bit_Offset] AND 7;

    ! Get the field size
    !
    IF .Tag_Field[FLD_Packed]
    THEN
	Tag_Field_Size = .BLK_B(.Tag_Field[FLD_Type], TYP_Packed_Size)
    ELSE
	Tag_Field_Size = .BLK_B(.Tag_Field[FLD_Type], TYP_Full_Size) * 8;

    ! Set up the target tag value
    !
    Tag_Value_Address[DBG$L_Address_Byte_Addr]	= Tag_Value;
    Tag_Value_Address[DBG$L_Address_Bit_Offset]	= 0;

    ! Get the current tag field value
    !
    PAS$_Assign(Tag_Field_Address, .Tag_Field_Size, .Tag_Field[FLD_Type],
			Tag_Value_Address, 32, .Tag_Field[FLD_Type]);

    ! Return tag value
    !
    .Tag_Value
    END;

GLOBAL ROUTINE PAS$_Variant_Check (Field_Address, Field_Entry) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Checks current tagfield values (if any) against a variant field reference
!
! FORMAL PARAMETERS:
!
!	Field_Address	- Address of address descriptor for field address
!	Field_Entry	- Address of field Keyword entry
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    MAP
	Field_Address		: REF DBG$Address_Desc,
	Field_Entry		: REF BLOCK [,BYTE] FIELD(Keyword_Fields);

    LOCAL
	Record_Address		: DBG$Address_Desc,
	Variant_Entry		: REF BLOCK [,BYTE] FIELD(Type_Fields);

    ! Preliminary check
    !
    IF .Field_Entry[FLD_Variant] EQLA 0
    THEN
	! Not part of a variant
	!
	RETURN;

    ! Get the address of the record
    !
    Record_Address[DBG$L_Address_Bit_Offset]
		= .Field_Address[DBG$L_Address_Bit_Offset] - .Field_Entry[FLD_Position];
    IF .Record_Address[DBG$L_Address_Bit_Offset] LSS 0
    THEN
	BEGIN
	LOCAL
	    Rounded_Up_Bits;

	Rounded_Up_Bits	= (7 - .Record_Address[DBG$L_Address_Bit_Offset]) AND (NOT 7);
	Record_Address[DBG$L_Address_Byte_Addr]
			= .Field_Address[DBG$L_Address_Byte_Addr] - (.Rounded_Up_Bits ^ -3);
	Record_Address[DBG$L_Address_Bit_Offset]
			= .Rounded_Up_Bits + .Record_Address[DBG$L_Address_Bit_Offset];
	END;

    ! Scan up thru the variants
    !
    Variant_Entry	= .Field_Entry[FLD_Variant];

    WHILE .Variant_Entry NEQA 0 DO
	BEGIN
	LOCAL
	    Tag_Field		: REF BLOCK [,BYTE] FIELD(Keyword_Fields);

	! Get a pointer to the tag field block
	!
	Tag_Field = .Variant_Entry[VAR_Variant_Tag];

	IF .Tag_Field NEQA 0
	THEN
	    ! Explicit Tagfield
	    !
	    BEGIN
	    LOCAL
		Tag_Value,
		Tag_Descriptor		: REF BLOCK [,BYTE] FIELD(Type_Fields);

	    ! Get the current tag value
	    !
	    Tag_Value = PAS$_Tag_Value(.Tag_Field, Record_Address);

	    ! Bounds check on the tag value
	    !
	    IF
		(IF .BLK_B(.Tag_Field[FLD_Type], ORD_Unsigned)
		THEN
		    (.Tag_Value GTRU .BLK_B(.Tag_Field[FLD_Type], ORD_Upper))
		OR
		    (.Tag_Value LSSU .BLK_B(.Tag_Field[FLD_Type], ORD_Lower))
		ELSE
		    (.Tag_Value GTR .BLK_B(.Tag_Field[FLD_Type], ORD_Upper))
		OR
		    (.Tag_Value LSS .BLK_B(.Tag_Field[FLD_Type], ORD_Lower))
		)
	    THEN
		SIGNAL(DBG$_ILLTAGVAL, BLK_B(.Tag_Field[FLD_Name], NAM_Text), .Tag_Value);

	    ! Check the tag value against the current variant
	    !
	    IF .Variant_Entry[VAR_Variant] EQLA 0
	    THEN
		Tag_Descriptor = .BLK_B(.Tag_Field[FLD_Record], REC_Tag_Head)
	    ELSE
		Tag_Descriptor = .BLK_B(.Variant_Entry[VAR_Variant], VAR_Tag_Head);

	    WHILE .Tag_Descriptor NEQA 0 DO
		IF .Tag_Descriptor[VTAG_Constant] EQLA .Tag_Value
		THEN
		    EXITLOOP
		ELSE
		    Tag_Descriptor = .Tag_Descriptor[VTAG_Constant_Link];

	    IF .Tag_Descriptor EQLA 0
	    THEN
		! Illegal tag value
		!
		SIGNAL(DBG$_ILLTAGVAL, BLK_B(.Tag_Field[FLD_Name], NAM_Text), .Tag_Value)

	    ELIF .Tag_Descriptor[VTAG_Variant_Link] NEQA .Variant_Entry
	    THEN
		! Field is not in the current variant
		!
		SIGNAL(DBG$_WRONGVAR, BLK_B(.Field_Entry[FLD_Name], NAM_Text),
			.Tag_Value, .Tag_Field[FLD_Type], BLK_B(.Tag_Field[FLD_Name], NAM_Text));

	    END;

	Variant_Entry	= .Variant_Entry[VAR_Variant];
	END;

    END;

GLOBAL ROUTINE PAS$_Assign (Source_Location, Source_Size, Source_Type,
			    Target_Location, Target_Size, Target_Type) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Performs an assignment. Type compatibility is checked, but only
!	a warning is given if source and target types are incompatible.
!	In such a case, the source bit pattern is moved directly to the
!	target address. The source is truncated or zero-extended on the left
!	as necessary to fit the target.
!
! FORMAL PARAMETERS:
!
!	Source_Location	- Address of a quadword address descriptor
!	Source_Size	- Source size in bits
!	Source_Type	- Address of Source Type Table entry
!	Target_Location	- Address of a quadword address descriptor
!	Target_Size	- Target size in bits
!	Target_Type	- Address of Target Type Table entry
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    MAP
	Source_Location		: REF DBG$Address_Desc,
	Target_Location		: REF DBG$Address_Desc,
	Source_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
	Target_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields);

    LOCAL
	Source_Address,
	Target_Address,
	Source,
	Target,
	Not_Compatible;

    ! Check read access to the source
    !
    PAS$_Read_Access(.Source_Location, .Source_Size);

    ! Check write access to the target
    !
    PAS$_Write_Access(.Target_Location, .Target_Size);


    ! If the source is <= 32 bits, extract it to a temporary
    ! This also covers the case where the source is unaligned
    !
    IF .Source_Size LEQU 32
    THEN
	BEGIN
	IF
	    (IF .Source_Type[TYP_Class] EQL TYP_K_Ordinal
	    THEN
		NOT .Source_Type[ORD_Unsigned])
	THEN
	    Source	= .(.Source_Location[DBG$L_Address_Byte_Addr])
				<.Source_Location[DBG$L_Address_Bit_Offset], .Source_Size, 1>

	ELSE
		Source	= .(.Source_Location[DBG$L_Address_Byte_Addr])
				<.Source_Location[DBG$L_Address_Bit_Offset], .Source_Size, 0>;

	Source_Address	= Source;
	END

    ELSE
	Source_Address	= .Source_Location[DBG$L_Address_Byte_Addr];

    ! If the target is <= 32 bits, make the target a temporary
    ! This also covers the case where the target is unaligned
    !
    IF .Target_Size LEQU 32
    THEN
	Target_Address	= Target
    ELSE
	Target_Address	= .Target_Location[DBG$L_Address_Byte_Addr];

    ! Case on the different result (Variable) types
    !
    Not_Compatible	= False;

    CASE .Target_Type[Typ_Class] FROM Typ_K_Array TO Typ_K_Varying OF
	SET

 	[Typ_K_Array,
 	 Typ_K_Record,
	 Typ_K_Varying]:
		IF PAS$_Type_Equal(.Target_Type, .Source_Type, True)
		THEN
		    ! Do the assignment. If source and target are packed,
		    ! and their sizes are <= 32 bits, the size is rounded up
		    ! to the nearest byte
		    !
		    MOVEBYTE((.Source_Size + 7) ^ -3, .Source_Address, .Target_Address)

		ELSE
		    Not_Compatible = True;

 	[Typ_K_File]:
		SIGNAL(DBG$_FILEASGN);		! File assignment not allowed

 	[Typ_K_Pointer]:
		IF PAS$_Type_Equal(.Target_Type, .Source_Type, True)
		THEN
		    ! Do the assignment
		    !
		    .Target_Address = ..Source_Address

		ELSE
		    Not_Compatible = True;

 	[Typ_K_Set]:
		IF PAS$_Type_Equal(.Target_Type, .Source_Type, True)
		THEN
		    ! Do the assignment. If source and target are packed,
		    ! and their sizes are <= 32 bits, the size is rounded up
		    ! to the nearest byte
		    !
		    MOVEBYTE((.Source_Size + 7) ^ -3, .Source_Address, .Target_Address)

		ELSE
		    Not_Compatible = True;

 	[Typ_K_Ordinal]:
		IF .Source_Type[Typ_Class] EQL Typ_K_Ordinal
		THEN
		    IF .Target_Type[ORD_Type] EQL .Source_Type[ORD_Type]
		    THEN
			BEGIN

			! Do the assignment. Both source and target are
			! longword temporarys.
			!
			.Target_Address = ..Source_Address;

			! Check bounds
			!
			IF .Source_Type[ORD_Unsigned]
			THEN
			    IF	(..Source_Address LSSU .Target_Type[ORD_Lower])	OR
				(..Source_Address GTRU .Target_Type[ORD_Upper])
			    THEN
				SIGNAL(DBG$_VALOUTBNDS)

			    ELSE

			ELSE
			    IF	(..Source_Address LSS .Target_Type[ORD_Lower]) OR
				(..Source_Address GTR .Target_Type[ORD_Upper])
			    THEN
				SIGNAL(DBG$_VALOUTBNDS);

			END

		    ELSE
			Not_Compatible = True
		ELSE
		    Not_Compatible = True;

 	[Typ_K_Real]:
		IF	(.Source_Type[Typ_Class] EQL Typ_K_Real)
		    OR
			(IF .Source_Type[Typ_Class] EQL Typ_K_Ordinal
			THEN
			    (.Source_Type[ORD_Type] EQL PAS$_TRW_Integer) OR
			    (.Source_Type[ORD_Type] EQL PAS$_TRW_Unsigned)
			)
		THEN
		    BEGIN
		    LOCAL
			Source_Dtype,
			Condition_Status;

		    IF .Source_Type[TYP_Class] EQL TYP_K_Real
		    THEN
			Source_Dtype	= .Source_Type[REAL_Dtype]
		    ELSE
			Source_Dtype	= .Source_Type[ORD_Dtype];

		    IF NOT (Condition_Status = PAS$_Arith_Convert
				(.Source_Dtype, .Source_Address, .Target_Type[REAL_Dtype], .Target_Address))
		    THEN
			SIGNAL(DBG$_NUMTRUNC);

		    END

		ELSE
		    Not_Compatible = True;

 	[INRANGE,
	 OUTRANGE]:
		Pascal_BugCheck(PAS$K_TYPCLASS);

		TES;

    IF .Not_Compatible
    THEN
	! Move the source to the target, truncating or zero-extending as appropriate
	!
	IF .Source_Size GTRU .Target_Size
	THEN
	    BEGIN

	    IF .Target_Size LEQU 32
	    THEN
		(.Target_Address)<0, .Target_Size> = .(.Source_Address)<0, .Target_Size>
	    ELSE
		! Source and target are an integral number of bytes
		!
		MOVEBYTE(.Target_Size, .Source_Address, .Target_Address);

	    ! Issue an informational message
	    !
	    SIGNAL(DBG$_NOTCMPTRNC);
	    END

	ELIF .Source_Size LSSU .Target_Size
	THEN
	    BEGIN

	    IF .Source_Size LEQU 32
	    THEN
		IF .Target_Size LEQU 32
		THEN
		    .Target_Address	= .(.Source_Address)<0, .Source_Size, 0>
		ELSE
		    BEGIN

		    ! Target must be an integral number of bytes
		    !
		    .Target_Address	= .(.Source_Address)<0, .Source_Size, 0>;
		    CH$FILL(0, ((.Target_Size ^ -3) - (.Source_size / 8)),
    			    .Target_Address + (.source_size / 8));
		    END
	    ELSE
		! Source and target are both an integral number of bytes
		!
		CH$COPY(.Source_Size ^ -3, .Source_Address, 0, .Target_Size ^ -3, .Target_Address);

	    ! Issue an informational message
	    !
	    SIGNAL(DBG$_NOTCMPEXT);
	    END

	ELSE
	    BEGIN

	    IF .Source_Size LEQU 32
	    THEN
		! Source and target are longword temporarys
		!
		.Target_Address = ..Source_Address
	    ELSE
		! Source and target are an integral number of bytes
		!
		MOVEBYTE(.Source_Size ^ -3, .Source_Address, .Target_Address);

	    ! Issue an informational message
	    !
	    SIGNAL(DBG$_NOTCMP);
	    END;

    ! If the target is <= 32 bits, move the temporary to the target
    ! This also covers the case where the target is unaligned
    !
    IF .Target_Size LEQU 32
    THEN
	(.Target_Location[DBG$L_Address_Byte_Addr])
		<.Target_Location[DBG$L_Address_Bit_Offset], .Target_Size>
			= .(.Target_Address)<0, .Target_Size>;

    END;

END
ELUDOM
