MODULE	PASSEMUTL ( ! Semantic Utility Routines
	IDENT = 'V03-000'
	)=
BEGIN
!
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
!++
!
! FACILITY:	VAX-11 PASCAL-PLUS
!
! ABSTRACT:
!
!	This routine contains the Semantic routines associated with the
!	Parsing Phase
!
! ENVIRONMENT:	VAX/VMS user mode
!
! AUTHOR: R. Gottlieb, CREATION DATE: 20-Feb-1980
!
! MODIFIED BY:	P. Hohensee	17-July-1980	Stolen from PASCAL-PLUS
!               P. Sager        27-July-1981
!
! Revision History:
!        27-July-1981    PS     in PAS$_CREATE_SYMBOL,
!                               only PAS$_CURRENT_SYMBOL_HEADER, &
!                                    PAS$_CURRENT_SYMBOL_TRAILER are updated
!                                    from SYMBOL_ENTRY, there is no link
!                               list threaded in between, the old way will
!                               destory the memory
!--

REQUIRE 'SRC$:PASPROLOG';

!
! Table of Contents
!
FORWARD ROUTINE
	Number_Of_Bits,					! Calculate the number of bits a value occupies

	PAS$_Get_Version,				! Get the compiler version number

	PAS$_Create_Symbol		: NOVALUE,	! Create a Symbol Table Entry
	PAS$_Create_Type,				! Create a Type Table Entry
	PAS$_Type_Equal,				! Compatibility check
	Equal_Lists,					! Field list compatibility check
	PAS$_String,					! Check for character string
	PAS$_Get_Symbol,				! Get symbol information from the dubugger RST
							! and create a local symbol table entry
	PAS$_Get_Type,					! Get type information from the debugger RST

							! and create a local type table entry
	PAS$_Get_Srm_Type,				! Create a type table entry for
							! certain Vax-Standard Srm types
	Get_Subrange_Type	: NOVALUE,		! Fill in a Type Table entry
							! for a subrange type
	Get_Enumerated_Type	: NOVALUE,		! Fill in a Type Table entry
							! for an enumerated type
	Get_Pointer_Type	: NOVALUE,		! Fill in a Type Table entry
							! for a pointer type
	Get_Descriptor_Type	: NOVALUE,		! Fill in a Type Table entry for a
							! type described by an SRM descriptor
	Get_Array_Type		: NOVALUE,		! Fill in a Type Table entry
							! for an array type
	Get_Dynamic_Dimensions	: NOVALUE,		! Load dimension info for a dynamic array
	Get_Record_Type		: NOVALUE,		! Fill in a Type Table entry
							! for a record type
	Get_Field		: NOVALUE,		! Create a Field entry for a record field
	Get_Variant		: NOVALUE,		! Create a Type Table entry for a variant
	Get_Set_Type		: NOVALUE,		! Fill in a Type Table entry
							! for a set type
	Get_File_Type		: NOVALUE;		! Fill in a Type Table entry
							! for a file type

!
! EXTERNAL ROUTINEs
!
EXTERNAL ROUTINE
	PAS$_Lex_Enter_Name,				! Enter/Lookup a name in the Name Table
	PAS$_Get_Value		: NOVALUE;		! Get address of an object's value

!
! EXTERNALs
!
EXTERNAL
	PAS$_Message_Vector	: LONG,			! Address of address of error message vector

	! Primary Interpreter GLOBAL storage
	!
	PAS$_Static_Desc	: PAS$_Primary_Desc,	! Static part of Primary Descriptor
	PAS$_Nonstatic_Desc_Head: REF VECTOR,		! Pointer to first block or nonstatic descriptor
	PAS$_Nonstatic_Desc_Tail: REF VECTOR,		! Pointer to last block of nonstatic descriptor

	PAS$_Token_Positions	: VECTOR [4,LONG],	! Position of tokens in file

	PAS$_SRW_True		: BLOCK [,BYTE],	! Symbol entry for TRUE
	PAS$_SRW_False		: BLOCK [,BYTE],	! Symbol entry for FALSE
	PAS$_SRW_Nil		: BLOCK [,BYTE],	! Symbol entry for NIL
	PAS$_SRW_Maxint		: BLOCK [,BYTE],	! Symbol entry for MAXINT

	PAS$_TRW_Boolean	: BLOCK [,BYTE],	! Type entry for BOOLEAN
	PAS$_TRW_Char		: BLOCK [,BYTE],	! Type entry for CHAR
	PAS$_TRW_Double		: BLOCK [,BYTE],	! Type entry for DOUBLE
	PAS$_TRW_Double_G	: BLOCK [,BYTE],	! Type entry for DOUBLE G-Float
	PAS$_TRW_Integer	: BLOCK [,BYTE],	! Type entry for INTEGER
	PAS$_TRW_Nil		: BLOCK [,BYTE],	! Type entry for NIL
	PAS$_TRW_Quadruple	: BLOCK [,BYTE],	! Type entry for QUADRUPLE
	PAS$_TRW_Real		: BLOCK [,BYTE],	! Type entry for REAL
	PAS$_TRW_Unsigned	: BLOCK [,BYTE];	! Type entry for UNSIGNED

!
! Semantic EXTERNALs
!
EXTERNAL
	PAS$_Is_Primary			: BYTE UNSIGNED,	! True = in Primary Interpreter,
								! False = in Expression Interpreter

	PAS$_Current_Symbol_Header	: LONG,			! Pointer to Linked List
	PAS$_Current_Symbol_Trailer	: LONG,			! Pointer to Linked List
	PAS$_Expr_Depth		: LONG,			! Expression Stack Depth
	PAS$_Expr_Stack		: BLOCKVECTOR [Expr_Stack_Depth, Expr_S_Entry, BYTE]
	    FIELD(Expression_Stack_Fields);		! Expression Stack

ROUTINE Number_Of_Bits (Value) =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Calculates the minimum number of bits required to hold a given value
!
! FORMAL PARAMETERS:
!
!	Value	- Longword containing value whose size is to be calculated
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	The minimum number of bits required to hold .Value
!
!--

    BEGIN
    BUILTIN
	CVTLD;

    REGISTER
	Result	= 0;

    RETURN
	(IF	(.Value EQL 0)
	    OR
		(.Value EQL -1)
	THEN
	    1

	ELIF .Value LSS 0
	THEN
	    BEGIN
	    CVTLD(%REF(NOT .Value), Result);
	    .Result<7, 8> - 127
	    END

	ELSE
	    BEGIN
	    CVTLD(Value, Result);
	    .Result<7, 8> - 128
	    END
	);

    END;

GLOBAL ROUTINE PAS$_Get_Version =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Retrieves the compiler version number from the RST
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	The compiler version number
!
!--

    BEGIN

    BIND
	Version_Symbol_Name	= UPLIT BYTE(%ASCIC '.PAS$VERSION.');

    OWN
	Version_Pathname: BLOCK[DBG$K_PATHDESCSIZE+1, LONG] FIELD(PTH$FLD_DEF)
			PRESET(	[PTH$B_TOTCNT]	= 1,
				[PTH$B_PATHCNT]	= 1,
				[PTH$B_LOCINVOC]= 0,
				[PTH$L_INVOCNUM]= 0);

    LOCAL
	Kind,
	Version_Symid,
	Value_Kind,
	Version_Address		: DBG$Address_Desc,
	Version_Pathvector	: REF VECTOR;

    ! Set up the version symbol name pathname descriptor
    !
    Version_Pathvector    = Version_Pathname[PTH$A_Pathvector];
    Version_Pathvector[0] = Version_Symbol_Name;

    ! Look up the symbol
    !
    DBG$STA_Getsymbol(Version_Pathname, Version_Symid, Kind);

    RETURN

	(IF .Kind EQL RST$K_Invalid
	THEN
	    ! Version 2 doesn't put out the version symbol
	    !
	    0

	ELIF .Kind EQL RST$K_Data
	THEN
	    BEGIN

	    ! Get it's value
	    !
	    PAS$_Get_Value(.Version_Symid, Version_Address);

	    ..Version_Address[DBG$L_Address_Byte_Addr]
	    END

	ELSE
	    ! Someone else defined the symbol '.PAS$VERSION.'
	    !
	    0
	);

    END;

GLOBAL ROUTINE PAS$_Create_Symbol ( Symbol_Ptr, Symbol_Class, Symbol_Name ) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	This routine is used to create a Symbol Table entry
!	for various semantic routines.
!
! FORMAL PARAMETERS:
!
!	Symbol_Ptr	- Where to Store address of Symbol Entry
!	Symbol_Class	- The class of the Symbol table entry
!	Symbol_Name	- A pointer to the name table entry
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    MAP
	Symbol_Name		: REF BLOCK [,BYTE] FIELD(Nam_Fields);

    BIND
	Symbol_Size_Table	= UPLIT BYTE(
	    0,		    SYM_S_Constant, SYM_S_Variable, SYM_S_Type,           SYM_S_Procedure,
	    SYM_S_Function, SYM_S_Field,    0,		    SYM_S_Reserved_Word,  SYM_S_Label,
	    SYM_S_Line)
		: VECTOR [11, BYTE, UNSIGNED];

    LOCAL
	Symbol_Entry		: REF BLOCK [,BYTE] FIELD(Symbol_Fields);

    ! Error check
    !
    IF .Symbol_Name EQL 0
    THEN
	Pascal_Bugcheck(PAS$K_NILNAM);	! Name Table Address = 0

    ! Attempt to allocate the entry
    !
    IF DBG$NLIST_FREEZ(ROUND_BYTE_TO_LONG_(.Symbol_Size_Table[.Symbol_Class]),
			 Symbol_Entry, .PAS$_Message_Vector)
    THEN    
	BEGIN
	! Initialize the values and link into the NAMe List
	!
	Symbol_Entry[SYM_Class]   	= .Symbol_Class;
	Symbol_Entry[SYM_Previous]	= .Symbol_Name[NAM_Pointer];
	Symbol_Entry[SYM_Name]		= .Symbol_Name;
    	Symbol_Entry[SYM_Thread]	= 0;

	Symbol_Name[NAM_Pointer]   = .Symbol_Entry;

	! Insert Symbol Table Entry into the Linked List
	!
	IF .PAS$_Current_Symbol_Header EQLA 0
	THEN
	    PAS$_Current_Symbol_Header  = .Symbol_Entry;
	!ELSE
	!   BLOCK[.PAS$_Current_Symbol_Trailer, SYM_Thread; ,BYTE] = .Symbol_Entry;

	PAS$_Current_Symbol_Trailer = .Symbol_Entry;

	END

    ELSE
	! No space for the Symbol Table entry
	!
	SIGNAL(DBG$_NOFREE);

    ! Return pointer to Symbol Table entry
    !
    (.Symbol_Ptr) = .Symbol_Entry;

    END;

GLOBAL ROUTINE PAS$_Create_Type ( Type_Class ) =

!++
! FUNCTIONAL SPECIFICATION:
!
!	This routine is used to create a Symbol Table entry
!	for various semantic routines.
!
! FORMAL PARAMETERS:
!
!	Type_Class	- The class of the Type table entry
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	A pointer to the created Type table entry
!
!--

    BEGIN

    BIND
	Type_Size_Table	= UPLIT BYTE(TYP_S_Error,  TYP_S_Array,   0,                0,
				     TYP_S_File,   TYP_S_Pointer, TYP_S_Set,        TYP_S_Ordinal,
				     TYP_S_Record, TYP_S_Variant, TYP_S_Real,       TYP_S_Varying)
	    : VECTOR [12, BYTE];

    LOCAL
	Type_Entry		: REF BLOCK [,BYTE] FIELD(Type_Fields),
	Type_Entry_Size;

    ! Allocate the entry
    !
    Type_Entry_Size = .Type_Size_Table[.Type_Class];

    IF DBG$NLIST_FREEZ(ROUND_BYTE_TO_LONG_(.Type_Entry_Size), Type_Entry, .PAS$_Message_Vector)
    THEN
	BEGIN

	! Initialize the values
	!
	Type_Entry[Typ_Class] = .Type_Class;

	! Zero the rest of the entry, just in case
	!
	ZEROBYTE(.Type_Entry_Size - 1, Type_Entry[1, A_]);

	Type_Entry[0, A_]
	END

    ELSE
	! No space for the Type Table Entry
	!
	SIGNAL(DBG$_NOFREE)

    END;

GLOBAL ROUTINE PAS$_Type_Equal ( Entry_1, Entry_2, Exact ) =

!++
! FUNCTIONAL SPECIFICATION:
!
!	This routine decides whether or not two types are compatible
!
! FORMAL PARAMETERS:
!
!	Entry_1		- Pointer to 1st Type
!	Entry_2		- Pointer to 2nd Type
!	Exact		- Must be Exact Match
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	True if types equal, false otherwise
!--

    BEGIN
    MAP
	Entry_1		: REF BLOCK [,BYTE] FIELD(Type_Fields),
	Entry_2		: REF BLOCK [,BYTE] FIELD(Type_Fields);

    BUILTIN
	ACTUALCOUNT;

    LOCAL
	Is_Exact;

    ! Simple test: see if it is the same Type entry
    !
    IF .Entry_1 EQLA .Entry_2
    THEN
	RETURN True;

    IF ACTUALCOUNT() GTR 2
    THEN
	Is_Exact = .Exact
    ELSE
	Is_Exact = False;

    ! Simple Test: see if they don't have the same entry class
    !
    IF .Entry_1[Typ_Class] NEQ .Entry_2[Typ_Class]
    THEN
	RETURN False;

    CASE .Entry_1[Typ_Class] FROM Typ_K_Array TO Typ_K_Real OF
	SET
    
	! See if both are ordinal with the same sub-type
	!
[Typ_K_Ordinal]:
	IF .Entry_1[ORD_Type] EQLA .Entry_2[ORD_Type]
	THEN
	    IF .Is_Exact
	    THEN
		(.Entry_1[ORD_Lower] EQL .Entry_2[ORD_Lower]) AND
		(.Entry_1[ORD_Upper] EQL .Entry_2[ORD_Upper])
	    ELSE
		True
	ELSE
	    False;

	! See if both are arrays with the same Index and Sub-Type
	!
[Typ_K_Array]:
	IF .Entry_1[Typ_Packed] EQL .Entry_2[Typ_Packed]
	THEN
	    PAS$_Type_Equal(.Entry_1[ARR_IType], .Entry_2[ARR_IType], True)      AND
	    (IF
		(IF .Entry_1[TYP_Packed]
		THEN
		    .BLOCK[.Entry_1[ARR_Type], TYP_Class; ,BYTE] EQL TYP_K_Ordinal)
	    THEN
		PAS$_Type_Equal(.Entry_1[ARR_Type], .Entry_2[ARR_Type], True)
	    ELSE
		PAS$_Type_Equal(.Entry_1[ARR_Type], .Entry_2[ARR_Type], .Is_Exact));

	! Check File Types for Compatibility
	!
[Typ_K_File]:
	IF .Entry_1[Typ_Packed] EQL .Entry_2[Typ_Packed]
	THEN
	    (IF
		(IF .Entry_1[TYP_Packed]
		THEN
		    .BLOCK[.Entry_1[ARR_Type], TYP_Class; ,BYTE] EQL TYP_K_Ordinal)
	    THEN
		PAS$_Type_Equal(.Entry_1[FIL_Type], .Entry_2[FIL_Type], True)
	    ELSE
		PAS$_Type_Equal(.Entry_1[FIL_Type], .Entry_2[FIL_Type], .Is_Exact));

	! Check Pointer Types for Compatibility
	!
[TYP_K_Pointer]:
	IF  (.Entry_1[PTR_Type] EQLA 0) OR (.Entry_2[PTR_Type] EQLA 0)
	THEN
	    True
	ELSE
	    True;
!	    PAS$_Type_Equal(.Entry_1[PTR_Type], .Entry_2[PTR_Type], .Is_Exact);

	! Check Set Types for Compatibility
	!
[Typ_K_Set]:
	IF  (.Entry_1[SET_Type] EQLA 0)	OR (.Entry_2[SET_Type] EQLA 0)
	THEN
	    True
	ELSE
	    PAS$_Type_Equal(.Entry_1[SET_Type], .Entry_2[SET_Type], .Is_Exact);

	! Check Record Types for Compatibility
	!
[Typ_K_Record]:
	IF .Entry_1[TYP_Packed] EQL .Entry_2[TYP_Packed]
	THEN
	    Equal_Lists(.Entry_1[REC_Fld_Head], .Entry_2[REC_Fld_Head],
			.Entry_1[REC_Var_Head], .Entry_2[REC_Var_Head],
			.Entry_1[REC_Tag_Head], .Entry_2[REC_Var_Head],
			.Is_Exact)
	ELSE
	    False;

[INRANGE]:
	False;

[OUTRANGE]:
	(Pascal_BugCheck(PAS$K_TYPCLASS); False);

	TES

    END;

ROUTINE Equal_Lists (Field_Head_1, Field_Head_2, Variant_Head_1, Variant_Head_2,
		Tag_Head_1, Tag_Head_2, Is_Exact) =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Decides whether or not 2 field lists are compatible
!
! FORMAL PARAMETERS:
!
!	Field_Head_1	-
!	Field_Head_2	-
!	Variant_Head_1	-
!	Variant_Head_2	-
!	Tag_Head_1	-
!	Tag_Head_2	-
!	Is_Exact	-
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	True	- The field lists are compatible
!	False	- The field lists are not compatible
!
!--

    BEGIN
    LOCAL
	Field_Entry_1		: REF BLOCK [,BYTE] FIELD(Keyword_Fields),
	Field_Entry_2		: REF BLOCK [,BYTE] FIELD(Keyword_Fields);

    Field_Entry_1	= .Field_Head_1;
    Field_Entry_2	= .Field_Head_2;

    WHILE (.Field_Entry_1 NEQA 0) AND (.Field_Entry_2 NEQA 0) DO
	BEGIN
	IF NOT
	    (IF
		(IF .Field_Entry_1[FLD_Packed]
		THEN
		    .BLOCK[.Field_Entry_1[FLD_Type], TYP_Class; ,BYTE] EQL TYP_K_Ordinal)
	    THEN
		PAS$_Type_Equal(.Field_Entry_1[FLD_Type], .Field_Entry_2[FLD_Type], True)
	    ELSE
		PAS$_Type_Equal(.Field_Entry_1[FLD_Type], .Field_Entry_2[FLD_Type], .Is_Exact))
	THEN
	    Return False;

	IF	(.Field_Entry_1 NEQA 0)
	    OR
		(.Field_Entry_2 NEQA 0)
	THEN
	    RETURN False;

	Field_Entry_1	= .Field_Entry_1[FLD_Record_Link];
	Field_Entry_2	= .Field_Entry_2[FLD_Record_Link];
	END;

    ! If we've gotton this far, lists are compatible
    !
    True
    END;

GLOBAL ROUTINE PAS$_String (Type_Entry) =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Determines whether or not a Type Table entry describes a character string
!
! FORMAL PARAMETERS:
!
!	Type_Entry	- Address of a Type Table entry
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	True	- If the Type Table entry is for a character string
!	False	- Otherwise
!
!--

    BEGIN
    MAP
	Type_Entry		: REF BLOCK [,BYTE] FIELD(Type_Fields);

    IF
	(IF .Type_Entry[TYP_Class] EQL TYP_K_Array
	THEN
	    IF PAS$_Type_Equal(.Type_Entry[ARR_Type], PAS$_TRW_Char, False)
	    THEN
		IF PAS$_Type_Equal(.Type_Entry[ARR_Itype], PAS$_TRW_Integer, False)
		THEN
		    BEGIN
		    BIND
			Index_Type		= Type_Entry[ARR_Itype]
				: REF BLOCK [,BYTE] FIELD(Type_Fields);

		    (.Index_Type[ORD_Lower] EQL 1) AND
		    (.Index_Type[ORD_Upper] LEQU 65535)
		    END
		ELSE
		    False
	    ELSE
		False
	ELIF .Type_Entry[TYP_Class] EQL TYP_K_Varying
	THEN
	    PAS$_Type_Equal(.Type_Entry[VARY_Type], PAS$_TRW_Char, False))
    THEN
	RETURN True

    ELSE
	RETURN False;

    END;

GLOBAL ROUTINE PAS$_Get_Symbol ( Pathname, Symbol_Name ) =

!++
! FUNCTIONAL SPECIFICATION:
!
!	This routine looks up a name in the Debugger Run-Time Symbol Table
!	(RST). If found, it looks for it in the local symbol table, creating
!	a new entry if the symbol doesn't exist there.
!
! FORMAL PARAMETERS:
!
!	Pathname		- A pointer to a pathname vector
!	Symbol_Name		- A pointer to a name table entry
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	If the name is found in RST, a pointer to its local symbol table entry
!
!--

    BEGIN
    MAP
	Pathname		: REF PTH$Pathname,
	Symbol_Name		: REF BLOCK [,BYTE] FIELD(Nam_Fields);

    BIND
	Vector_Size		= Pathname[PTH$B_Totcnt]	: BYTE UNSIGNED,
	Pathvector		= Pathname[PTH$A_Pathvector]	: VECTOR;

    LOCAL
	Symid,							! RST Symid
	Kind,							! RST Symbol Kind
	Symbol_Class,						! PASCAL SYM_Class
	Last_Entry		: REF BLOCK [,BYTE] FIELD(Symbol_Fields),
	Symbol_Entry		: REF BLOCK [,BYTE] FIELD(Symbol_Fields);

    IF (.Symbol_Name EQLA 0) OR (.Pathname EQLA 0)
    THEN
	Pascal_Bugcheck(PAS$K_NILNAM);

    ! Look up the name in the RST
    !
    DBG$STA_GETSYMBOL(.Pathname, Symid, Kind);

    ! Check the result
    !
    CASE .Kind FROM RST$K_Kind_Minimum TO RST$K_Kind_Maximum OF
	SET

	!
	! Not found
	!
    [RST$K_INVALID] :
	IF .Pathname[PTH$B_Totcnt] EQL .Pathname[PTH$B_Pathcnt]
	THEN
	    ! Check for pre-declared names
	    !
	    BEGIN
	    BIND
		Name_String		= .Pathvector[.Pathname[PTH$B_Pathcnt] - 1]
			: VECTOR [,BYTE];

	    IF CH$EQL(4, UPLIT BYTE(%ASCII 'TRUE'), .Name_String[0], Name_String[1])
	    THEN
		RETURN(PAS$_SRW_TRUE)
	    ELIF CH$EQL(5, UPLIT BYTE(%ASCII 'FALSE'), .Name_String[0], Name_String[1])
	    THEN
		RETURN(PAS$_SRW_FALSE)
	    ELIF CH$EQL(3, UPLIT BYTE(%ASCII 'NIL'), .Name_String[0], Name_String[1])
	    THEN
		RETURN(PAS$_SRW_NIL)
	    ELIF CH$EQL(6, UPLIT BYTE(%ASCII 'MAXINT'), .Name_String[0], Name_String[1])
	    THEN
		RETURN(PAS$_SRW_MAXINT)
	    ELSE
		! Signal error
		!
		SIGNAL(DBG$_NOSYMBOL, .Pathname);
	    END
	ELSE
	    ! Signal error
	    !
	    SIGNAL(DBG$_NOSYMBOL, .Pathname);

	!
	! Not unique
	!
    [RST$K_NOTUNIQUE] :
	!
	!
	SIGNAL(DBG$_NOUNIQUE, .Pathname);

	!
	! Module is always a procedure
	!
    [RST$K_MODULE ] :
	Symbol_Class = SYM_K_Procedure;

	!
	! Routine (assume its a procedure for now)
	!
    [RST$K_ROUTINE] :
	Symbol_Class = SYM_K_Procedure;		! or SYM_K_Function

	!
	! Data Object (assume its a variable for now)
	!
    [RST$K_DATA] :
	Symbol_Class = SYM_K_Variable;		! or SYM_K_Constant

	!
	! Label
	!
    [RST$K_LABEL] :
	Symbol_Class = SYM_K_Label;

	!
	! Line Number
	!
    [RST$K_LINE] :
	Symbol_Class = SYM_K_Line;

	!
	! Illegal type for a primary
	!
    [INRANGE] :
	! Signal error
	!
	SIGNAL(DBG$_ILLREF, .Pathname);

    [OUTRANGE] :
	Pascal_Bugcheck(PAS$K_RSTCODE);

	TES;

    ! Look for the symbol in the local symbol table
    !

    Symbol_Entry = .Symbol_Name[NAM_Pointer];
    Last_Entry	 = 0;

    WHILE .Symbol_Entry NEQA 0
    DO
	IF DBG$STA_Same_Dst_Object(.Symbol_Entry[SYM_Rst_Symid], .Symid)
	THEN
	    ! Already in table
	    !
	    BEGIN
	    ! Move to head of name list
	    !
	    IF .Last_Entry NEQA 0
	    THEN
		BEGIN
		Last_Entry[SYM_Name]		= .Symbol_Entry[SYM_Name];
		Symbol_Entry[SYM_Name]		= .Symbol_Name[NAM_Pointer];
		Symbol_Name[NAM_Pointer]	= .Symbol_Entry;
		END;

	    ! Return address
	    !
	    RETURN .Symbol_Entry;
	    END
	ELSE
	    ! Keep looking
	    !
	    BEGIN
	    Last_Entry	 = .Symbol_Entry;
	    Symbol_Entry = .Symbol_Entry[SYM_Previous];
	    END;

    ! Not found. Create new entry
    !
    PAS$_Create_Symbol(Symbol_Entry, .Symbol_Class, .Symbol_Name);

    ! Fill in the new entry
    !
    Symbol_Entry[SYM_Rst_Symid] = .Symid;

    ! Set context for evaluation of the type
    !
    DBG$STA_Setcontext(.Symid);

    CASE .Symbol_Class FROM SYM_K_Constant TO SYM_K_Line OF
	SET

	[SYM_K_Variable] :
	    BEGIN
	    LOCAL
		Type_Entry		: REF BLOCK [,BYTE] FIELD(Type_Fields);

	    Type_Entry			= PAS$_Get_Type(.Symid, .Symbol_Entry);
	    Symbol_Entry[VAR_Type]	= .Type_Entry;

	    Type_Entry[TYP_Symbol]	= .Symbol_Entry;

	    IF .Type_Entry[TYP_Class] EQL TYP_K_Array
	    THEN
		! Check for dynamic array
		!
		BEGIN
		LOCAL
		    Descriptor_Address	: Vector[3],
		    Value_Kind;

		DBG$STA_Symvalue(.Symid, Descriptor_Address, Value_Kind);

		IF .Value_Kind EQL DBG$K_Val_Descr
		THEN
		    ! Dynamic array
		    !
		    Get_Dynamic_Dimensions(.Symid, .Type_Entry, .Descriptor_Address[0]);
		END;
	    END;

	[SYM_K_Procedure] :
	    BEGIN
	    LOCAL
		Type_Entry		: REF BLOCK [,BYTE] FIELD(Type_Fields);

	    Type_Entry			= PAS$_Get_Type(.Symid, .Symbol_Entry);
	    Symbol_Entry[PROC_Func_Type]= .Type_Entry;

	    IF .Symbol_Entry[SYM_Class] EQL SYM_K_Function
	    THEN
		Type_Entry[TYP_Symbol]	= .Symbol_Entry;
	    END;

	[SYM_K_Label, SYM_K_Line] :
	    ;

	! Not in the range established by previous CASE
	!
	[INRANGE, OUTRANGE] :
	    Pascal_Bugcheck(PAS$K_SYMCLASS);

	TES;

    .Symbol_Entry
    END;

GLOBAL ROUTINE PAS$_Get_Type (Symid, Symbol_Entry) =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Get type information from the RST and create a type table
!	entry with it.
!
!	WARNING!!!	Symbol_Entry[SYM_Class] is the only part of the symbol
!			table entry that may be tested and/or changed by this
!			routine
!
! FORMAL PARAMETERS:
!
!	Symid		- RST pointer to a symbol
!	Symbol_Entry	- Pointer to a local symbol table entry
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Pointer to a type table entry
!
!--

    BEGIN
    MAP
	Symbol_Entry		: REF BLOCK [,BYTE] FIELD(Symbol_Fields);

    LOCAL
	Typid,							! RST Symid for the type
	Format_Code,						! RST Type Class

	Name_String		: REF VECTOR [,BYTE],		! Address of ASCIC type name string
	Name_Descriptor		: BLOCK [8, BYTE],		! Type name string descriptor
	Name_Entry		: REF BLOCK [,BYTE] FIELD(Nam_Fields),
								! Address of type Name Table entry
	Type_Symbol_Entry	: REF BLOCK [,BYTE] FIELD(Symbol_Fields),
								! Symbol Table for the type
	Type_Entry		: REF BLOCK [,BYTE] FIELD(Type_Fields),
								! Address of returned Type Table entry
	Type_Class;						! Pascal type class

    IF .Symbol_Entry[SYM_Class] EQL SYM_K_Procedure
    THEN
	! Find out whether it's a procedure or function.
	! Functions aren't implemented yet
	!
	RETURN 0;

    ! Find out what type class it is. If Atomic, get a pointer to a
    ! Type Table entry immediately and exit. Otherwise, if the type is
    ! already in the Type Table, return a pointer to it. Otherwise, create
    ! and fill in a Type Table entry
    !
    DBG$STA_SYMTYPE(.Symid, Format_Code, Typid);

    CASE .Format_Code FROM RST$K_TYPE_MINIMUM TO RST$K_TYPE_MAXIMUM OF
	SET

	[RST$K_Type_Atomic] :
	    BEGIN
	    LOCAL
		Size,
		Srm_Type_Code;

	    ! Get the Srm type code
	    !
	    DBG$STA_TYP_ATOMIC(.Symid, Srm_Type_Code, Size);

	    ! Return a pointer to a Type Table entry
	    !
	    IF (Type_Entry = PAS$_Get_Srm_Type(.Srm_Type_Code, .Size)) EQL 0
	    THEN
		SIGNAL(DBG$_UNKNOWNTYP);

	    RETURN .Type_Entry;
	    END;

	[RST$K_Type_Array, RST$K_Type_Descr] :
	    Type_Class = TYP_K_Array;

	[RST$K_Type_Enum] :
	    Type_Class = TYP_K_Ordinal;

	[RST$K_Type_File] :
	    Type_Class = TYP_K_File;

	[RST$K_Type_Record] :
	    Type_Class = TYP_K_Record;

	[RST$K_Type_Ptr] :
	    RETURN PAS$_TRW_Nil;

	[RST$K_Type_Tptr] :
	    Type_Class = TYP_K_Pointer;

	[RST$K_Type_Set] :
	    Type_Class = TYP_K_Set;

	[RST$K_Type_Subrng] :
	    Type_Class = TYP_K_Ordinal;

	[INRANGE] :
	    !
	    ! Compiler put out something unintelligable
	    !
	    SIGNAL(DBG$_UNKNOWNTYP);

	[OUTRANGE] :
	    Pascal_Bugcheck(PAS$K_RSTCODE);

	TES;	    

    ! Get the name and check to see if the type is already in the Type Table
    !

    DBG$STA_SYMNAME(.Typid, Name_String);

    Name_Descriptor[DSC$W_Length]	= .Name_String[0];
    Name_Descriptor[DSC$A_Pointer]	= Name_String[1];

    ! Enter/Lookup the name in the Name Table
    !
    Name_Entry = PAS$_Lex_Enter_Name(Name_Descriptor);

    ! Search the Symbol Table for the name. If found,
    ! return a pointer to the type's Type Table entry
    !
    Type_Symbol_Entry = .Name_Entry[NAM_Pointer];

    WHILE .Type_Symbol_Entry NEQ 0 DO
	BEGIN
	IF .Type_Symbol_Entry[SYM_Rst_Symid] NEQA 0
	THEN
	    BEGIN
	    IF DBG$STA_Same_Dst_Object(.Type_Symbol_Entry[SYM_Rst_Symid], .Typid)
	    THEN
		! Found it
		!
		RETURN .Type_Symbol_Entry[STY_Type]
	    END;

	! Keep looking
	!
	Type_Symbol_Entry = .Type_Symbol_Entry[SYM_Previous];
	END;

    ! Search failed. Create a Symbol Table entry for the type
    !
    PAS$_Create_Symbol(Type_Symbol_Entry, SYM_K_Type, .Name_Entry);

    Type_Symbol_Entry[SYM_Rst_Symid]	= .Typid;

    ! Create a blank Type Table entry and link it to the Symbol Table entry
    !
    Type_Entry			= PAS$_Create_Type(.Type_Class);
    Type_Entry[TYP_Symbol]	= .Type_Symbol_Entry;
    Type_Symbol_Entry[STY_Type]	= .Type_Entry;

    ! Fill in the new Type Table entry
    !
    CASE .Type_Class FROM TYP_K_Array TO TYP_K_Record OF
	SET

	[TYP_K_Array] :
	    IF .Format_Code EQL RST$K_Type_Descr
	    THEN
		Get_Descriptor_Type(.Typid, .Type_Entry)
	    ELSE
		BEGIN
		LOCAL
		    Descriptor_Address	: Vector[3],
		    Value_Kind;

		Get_Array_Type(.Typid, .Type_Entry);

		DBG$STA_Symvalue(.Typid, Descriptor_Address, Value_Kind);

		IF .Value_Kind EQL DBG$K_Val_Descr
		THEN
		    ! Dynamic array
		    !
		    Get_Dynamic_Dimensions(.Symid, .Type_Entry, .Descriptor_Address[0]);
		END;

	[TYP_K_File] :
	    Get_File_Type(.Typid, .Type_Entry);

	[TYP_K_Ordinal] :
	    IF .Format_Code EQL RST$K_Type_Subrng
	    THEN
		Get_Subrange_Type(.Typid, .Type_Entry)

	    ELSE
		! Enumerated type
		!
		Get_Enumerated_Type(.Typid, .Type_Entry);

	[TYP_K_Pointer] :
	    Get_Pointer_Type(.Typid, .Type_Entry);

	[TYP_K_Record] :
	    Get_Record_Type(.Typid, .Type_Entry);

	[TYP_K_Set] :
	    Get_Set_Type(.Typid, .Type_Entry);

	[INRANGE] :
	    SIGNAL(DBG$_UNKNOWNTYP);

	[OUTRANGE] :
	    Pascal_Bugcheck(PAS$K_TYPCLASS);

	TES;

    ! Return pointer to type table entry
    !
    .Type_Entry
    END;

GLOBAL ROUTINE PAS$_Get_Srm_Type (Srm_Type_Code, Type_Size) =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Convert certain Vax-Standard Srm type codes to a Type Table entry
!
! FORMAL PARAMETERS:
!
!	Srm_Type_Code	- A Vax-Standard Srm type code
!	Type_Size	- Optional input parameter. Size of an object of the type in bits.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	A pointer to a Type Table entry
!
!--

    BEGIN
    LOCAL
	Size,
	Type_Entry			: REF BLOCK [,BYTE] FIELD(Type_Fields);

    BUILTIN
	ACTUALCOUNT;

    IF ACTUALCOUNT() GTRU 1
    THEN
	Size	= .Type_Size
    ELSE
	! Assume byte boolean
	!
	Size	= 8;

    SELECTONE .Srm_Type_Code OF
	SET

    [DSC$K_Dtype_B, DSC$K_Dtype_BU, DSC$K_Dtype_W, DSC$K_Dtype_WU] :
	BEGIN

	Type_Entry = PAS$_Create_Type(TYP_K_Ordinal);

	Type_Entry[TYP_Rst_Class]	= .Srm_Type_Code;

	CASE .Srm_Type_Code FROM DSC$K_Dtype_BU TO DSC$K_Dtype_W OF
	    SET

	[DSC$K_Dtype_BU] :
	    BEGIN
	    Type_Entry[TYP_Packed_Size]	= 8;
	    Type_Entry[TYP_Full_Size]	= 1;
	    Type_Entry[ORD_Type]	= PAS$_TRW_Unsigned;
	    Type_Entry[ORD_Lower]	= 0;
	    Type_Entry[ORD_Upper]	= 255;
	    Type_Entry[ORD_Dtype]	= BU_Int;
	    END;

	[DSC$K_Dtype_B] :
	    BEGIN
	    Type_Entry[TYP_Packed_Size]	= 8;
	    Type_Entry[TYP_Full_Size]	= 1;
	    Type_Entry[ORD_Type]	= PAS$_TRW_Integer;
	    Type_Entry[ORD_Lower]	= -128;
	    Type_Entry[ORD_Upper]	= 127;
	    Type_Entry[ORD_Dtype]	= B_Int;
	    END;

	[DSC$K_Dtype_WU] :
	    BEGIN
	    Type_Entry[TYP_Packed_Size]	= 16;
	    Type_Entry[TYP_Full_Size]	= 2;
	    Type_Entry[ORD_Type]	= PAS$_TRW_Unsigned;
	    Type_Entry[ORD_Lower]	= 0;
	    Type_Entry[ORD_Upper]	= 65535;
	    Type_Entry[ORD_Dtype]	= WU_Int;
	    END;

	[DSC$K_Dtype_W] :
	    BEGIN
	    Type_Entry[TYP_Packed_Size]	= 16;
	    Type_Entry[TYP_Full_Size]	= 2;
	    Type_Entry[ORD_Type]	= PAS$_TRW_Integer;
	    Type_Entry[ORD_Lower]	= -32768;
	    Type_Entry[ORD_Upper]	= 32767;
	    Type_Entry[ORD_Dtype]	= W_Int;
	    END;

	[INRANGE, OUTRANGE] :
	    ;

	    TES;

	END;

    [DSC$K_Dtype_LU] :
	Type_Entry	= PAS$_TRW_Unsigned;

    [DSC$K_Dtype_L] :
	Type_Entry	= PAS$_TRW_Integer;

    [DSC$K_Dtype_F] :
	Type_Entry	= PAS$_TRW_Real;

    [DSC$K_Dtype_D] :
	Type_Entry	= PAS$_TRW_Double;

    [DSC$K_Dtype_G] :
	Type_Entry	= PAS$_TRW_Double_G;

    [DSC$K_Dtype_H] :
	Type_Entry	= PAS$_TRW_Quadruple;

    [DSC$K_Dtype_T] :
	Type_Entry	= PAS$_TRW_Char;

    [DST$K_Bool] :
	Type_Entry	= PAS$_TRW_Boolean;

    [OTHERWISE] :
	!
	! Compiler put out something unintelligable
	!
	Type_Entry	= 0;

	TES;

    .Type_Entry
    END;

ROUTINE Get_Subrange_Type (Typid, Type_Entry) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Fill in a Type Table entry for a subrange type
!
! FORMAL PARAMETERS:
!
!	Typid		- RST Symid for the type
!	Type_Entry	- A Pointer to a Type Table entry
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    MAP
	Type_Entry		: REF BLOCK [,BYTE] FIELD(Type_Fields);

    LOCAL
	Base_Type_Typid,
	Lower_Address,
	Upper_Address,
	Size,
	Base_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields);

    ! Get info about the type
    !
    DBG$STA_TYP_SUBRNG(.Typid, Base_Type_Typid, Lower_Address, Upper_Address, Size);

    ! Fill in the Type Table entry
    !
    Type_Entry[ORD_Lower]	= ..Lower_Address;
    Type_Entry[ORD_Upper]	= ..Upper_Address;

    Type_Entry[TYP_Rst_Class]	= DSC$K_Dtype_Z;

    Base_Type			= PAS$_Get_Type(.Base_Type_Typid, %REF(SYM_K_Type));

    Type_Entry[ORD_Type]	= .Base_Type;

    Type_Entry[TYP_Full_Size]	= .Base_Type[TYP_Full_Size];

    IF
	(IF .Type_Entry[ORD_Type] EQL PAS$_TRW_Integer
	THEN
	    .Type_Entry[ORD_Lower] LSS 0)
    THEN
	BEGIN
	LOCAL
	    Low_Size,
	    High_Size;

	! Compute the size needed
	!
	Low_Size	= Number_Of_Bits(.Type_Entry[ORD_Lower]);
	High_Size	= Number_Of_Bits(.Type_Entry[ORD_Upper]);
	IF .Type_Entry[ORD_Upper] GTR 0
	THEN
	    ! Allow for the sign bit
	    !
	    High_Size = .High_Size + 1;

	Type_Entry[TYP_Packed_Size]	= MAX(.Low_Size, .High_Size);
	Type_Entry[ORD_Dtype]		=
			(CASE .Type_Entry[TYP_Full_Size] FROM 1 TO 4 OF
			    SET
			    [1]	:	B_Int;
			    [2]	:	W_Int;
			    [INRANGE] :	L_Int;
			    TES);
	END

    ELSE
	BEGIN

	Type_Entry[TYP_Packed_Size]	= Number_Of_Bits(.Type_Entry[ORD_Upper]);
	Type_Entry[ORD_Dtype]		=
			(CASE .Type_Entry[TYP_Full_Size] FROM 1 TO 4 OF
			    SET
			    [1]	:	BU_Int;
			    [2]	:	WU_Int;
			    [INRANGE] :	LU_Int;
			    TES);
	END;

    END;

ROUTINE Get_Enumerated_Type (Typid, Type_Entry) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Fill in a Type Table entry for an enumerated type
!
! FORMAL PARAMETERS:
!
!	Typid		- RST Symid for the type
!	Type_Entry	- A pointer to a Type Table entry
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    MAP
	Type_Entry		: REF BLOCK [,BYTE] FIELD(Type_Fields);

    LOCAL
	Size,
	Elements		: REF VECTOR,			! Vector of element symids
	Number_Of_Elements,

	Low_Bound,
	High_Bound,
	Current_Symbol_Address;					! Address of address of an element
								! Symbol Table entry

    ! Get info about the type
    !
    DBG$STA_TYP_ENUM(.Typid, Number_Of_Elements, Elements, Size);

    ! Fill in the Type Table Entry
    !
    Type_Entry[TYP_Rst_Class]	= DSC$K_Dtype_Z;
    Type_Entry[ORD_Type]	= .Type_Entry;

    Type_Entry[TYP_Packed_Size]	= Number_Of_Bits(.Number_Of_Elements - 1);

    IF ((.Type_Entry[TYP_Packed_Size] + 7) ^ -3) EQL 3
    THEN
	Type_Entry[TYP_Full_Size] = 4
    ELSE
	Type_Entry[TYP_Full_Size] = (.Type_Entry[TYP_Packed_Size] + 7) ^ -3;

    Type_Entry[ORD_Dtype]	=
			(CASE .Type_Entry[TYP_Full_Size] FROM 1 TO 4 OF
			    SET
			    [1]	:	BU_Int;
			    [2]	:	WU_Int;
			    [INRANGE] :	LU_Int;
			    TES);

    Type_Entry[ORD_Enum_Count]	= .Number_Of_Elements;

    ! Create Name and Symbol Table entries for the elements
    !

    Current_Symbol_Address	= Type_Entry[ORD_Enum_Element];
    Low_Bound			= %X'FFFFFFFF';
    High_Bound			= 0;

    INCR Element_Count FROM 0 TO .Number_Of_Elements - 1 DO
	BEGIN
	LOCAL
	    Name_Entry		: REF BLOCK [,BYTE] FIELD(Nam_Fields),	! Pointer to element Name Table entry
	    Name_String		: REF VECTOR [,BYTE],			! Pointer to element ASCIC name
	    Name_Descriptor	: BLOCK [8, BYTE],			! Element name string descriptor

	    Symbol_Entry	: REF BLOCK [,BYTE] FIELD(Symbol_Fields),

	    Address		: DBG$Address_Desc;			! Address descriptor for element value

	! Get a pointer to the element's name
	!
	DBG$STA_SYMNAME(.Elements[.Element_Count], Name_String);
	Name_Descriptor[DSC$A_POINTER]	= Name_String[1];
	Name_Descriptor[DSC$W_LENGTH]	= .Name_String[0];

	! Enter/Lookup the name in the Name Table
	!
	Name_Entry = PAS$_Lex_Enter_Name(Name_Descriptor);

	! Create a Symbol Table entry for the element
	!
	PAS$_Create_Symbol(Symbol_Entry, SYM_K_Constant, .Name_Entry);

	Symbol_Entry[SYM_Rst_Symid]	= .Elements[.Element_Count];
	Symbol_Entry[CON_Type]		= .Type_Entry;
	Symbol_Entry[CON_Dtype]		= .Type_Entry[ORD_Dtype];
	Symbol_Entry[CON_Next]		= 0;

	PAS$_Get_Value(.Elements[.Element_Count], Address);

	Symbol_Entry[CON_Literal]	= ..Address[DBG$L_Address_Byte_Addr];

	! Link the Symbol Table entry into the element list
	!
	.Current_Symbol_Address		= .Symbol_Entry;
	Current_Symbol_Address		= Symbol_Entry[CON_Next];

	! Get the next set of high and low bounds
	!
	IF .High_Bound LSSU ..Address[DBG$L_Address_Byte_Addr]
	THEN
	    High_Bound	= ..Address[DBG$L_Address_Byte_Addr];
	IF .Low_Bound GTRU ..Address[DBG$L_Address_Byte_Addr]
	THEN
	    Low_Bound	= ..Address[DBG$L_Address_Byte_Addr];

	END;

    Type_Entry[ORD_Lower]	= .Low_Bound;
    Type_Entry[ORD_Upper]	= .High_Bound;

    END;

ROUTINE Get_Pointer_Type (Typid, Type_Entry) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Fill in a Type Table entry for a pointer type
!
! FORMAL PARAMETERS:
!
!	Typid		- RST Symid for the type
!	Type_Entry	- A pointer to a Type Table entry
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    MAP
	Type_Entry		: REF BLOCK [,BYTE] FIELD(Type_Fields);
	
    LOCAL
	Base_Type_Typid;

    ! Get info about the type
    !
    DBG$STA_TYP_TYPEDPTR(.Typid, Base_Type_Typid);

    ! Fill in the Type Table entry
    !
    Type_Entry[TYP_Rst_Class]	= DSC$K_Dtype_Z;
    Type_Entry[TYP_Packed_Size]	= 32;
    Type_Entry[TYP_Full_Size]	= 4;
    Type_Entry[PTR_Type]	= PAS$_Get_Type(.Base_Type_Typid, %REF(SYM_K_Type));

    END;

ROUTINE Get_Descriptor_Type (Typid, Type_Entry) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Fill in a Type Table entry for a type described by an SRM descriptor
!	Currently, we only understand string and varying string descriptors
!
! FORMAL PARAMETERS:
!
!	Typid		- RST Symid for the type
!	Type_Entry	- A pointer to a Type Table entry
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    MAP
	Type_Entry		: REF BLOCK [,BYTE] FIELD(Type_Fields);

    LOCAL
	Descriptor		: REF BLOCK [,BYTE],			! String Descriptor address
	Index_Type_Entry	: REF BLOCK [,BYTE] FIELD(Type_Fields);	! Pointer to index type table entry
	
    ! Get info about the type
    !
    DBG$STA_TYP_DESCR(.Typid, Descriptor);

    ! Make sure it's a string descriptor
    !
    IF .Descriptor[DSC$B_Dtype] NEQ DSC$K_Dtype_T
    THEN
	SIGNAL(DBG$_UNKNOWNTYP);

    IF .Descriptor[DSC$B_Class] EQL DSC$K_Class_S
    THEN
	BEGIN

	! Fill in the Type Table entry
	!

	Type_Entry[TYP_Packed]			= True;
	Type_Entry[TYP_Rst_Class]		= DSC$K_Dtype_Z;
	Type_Entry[TYP_Packed_Size]		= .Descriptor[DSC$W_Length] * 8;
	Type_Entry[TYP_Full_Size]		= .Descriptor[DSC$W_Length];

	! Get index type
	!
	Index_Type_Entry			= PAS$_Create_Type(TYP_K_Ordinal);

	Index_Type_Entry[TYP_Rst_Class]		= DSC$K_Dtype_L;
	Index_Type_Entry[TYP_Packed_Size]	= 32;
	Index_Type_Entry[TYP_Full_Size]		= 4;
	Index_Type_Entry[ORD_Type]		= PAS$_TRW_Integer;
	Index_Type_Entry[ORD_Lower]		= 1;
	Index_Type_Entry[ORD_Upper]		= .Descriptor[DSC$W_Length];
	Index_Type_Entry[ORD_Dtype]		= L_Int;

	Type_Entry[ARR_Itype]		= .Index_Type_Entry;

	! Fill in element type
	!
	Type_Entry[ARR_Type]		= PAS$_TRW_Char;
	END

    ELIF .Descriptor[DSC$B_Class] EQL DSC$K_Class_VS
    THEN
	BEGIN

	! Mask partial implementation
	!
	SIGNAL(DBG$_UNKNOWNTYP);

	! Fill in the Type Table entry
	!

	Type_Entry[TYP_Class]			= TYP_K_Varying;
	Type_Entry[TYP_Packed]			= True;
	Type_Entry[TYP_Rst_Class]		= DSC$K_Dtype_Z;
	Type_Entry[TYP_Packed_Size]		= .Descriptor[DSC$W_Length] * 8 + 16;
	Type_Entry[TYP_Full_Size]		= .Descriptor[DSC$W_Length] + 2;

	Type_Entry[VARY_Type]		= PAS$_TRW_Char;
	Type_Entry[VARY_Bound]		= .Descriptor[DSC$W_Length];
	END

    ELSE
	SIGNAL(DBG$_UNKNOWNTYP);

    END;

ROUTINE Get_Array_Type (Typid, Type_Entry) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Fill in a Type Table entry for an array type
!
! FORMAL PARAMETERS:
!
!	Typid		- RST Symid for the type
!	Type_Entry	- A pointer to a Type Table entry
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    MAP
	Type_Entry		: REF BLOCK [,BYTE] FIELD(Type_Fields);

    LOCAL
	Descriptor		: REF BLOCK [,BYTE],		! Array Descriptor
	Cell_Type_Typid,					! Cell type symid
	Number_Of_Dimensions,
	Index_Types		: REF VECTOR,			! Vector of index type symids
	Size,

	Packed,							! True = Array is bit-accessed
	DSC$L_L1,						! Address of lower bound of 1st
								! dimension in Descriptor
	Array_Type_Entry	: REF BLOCK [,BYTE] FIELD(Type_Fields);
	
    ! Get info about the type
    !
    DBG$STA_TYP_ARRAY(.Typid, Descriptor, Cell_Type_Typid, Number_Of_Dimensions, Index_Types, Size);

    ! Check for correct descriptor type
    !
    IF	(.Descriptor[DSC$B_Class] NEQ DSC$K_Class_NCA)	AND
	(.Descriptor[DSC$B_Class] NEQ DSC$K_Class_UBA)
    THEN
	SIGNAL(DBG$_UNKNOWNTYP);

    Packed	= .Descriptor[DSC$B_Class] EQL DSC$K_Class_UBA;
    DSC$L_L1	= Descriptor[DSC$L_S1] + (.Number_Of_Dimensions * 4);

    ! Loop thru the index types
    !
    Array_Type_Entry			= .Type_Entry;
    Array_Type_Entry[ARR_Up_Link]	= 0;

    INCR Index FROM 0 TO .Number_Of_Dimensions - 1 DO
	BEGIN

	! Fill in the Array type record
	!
	Array_Type_Entry[TYP_Packed]	= .Packed;
	Array_Type_Entry[TYP_Rst_Class]	= DSC$K_Dtype_Z;

	IF .Packed
	THEN
	    BEGIN
	    Array_Type_Entry[TYP_Packed_Size]	= .(Descriptor[DSC$L_S1] - 4 + (.Index * 4));
	    Array_Type_Entry[TYP_Full_Size]	= .(Descriptor[DSC$L_S1] - 4 + (.Index * 4)) ^ -3;
	    END
	ELSE
	    BEGIN
	    Array_Type_Entry[TYP_Full_Size]	= .(Descriptor[DSC$L_S1] - 4 + (.Index * 4));
	    Array_Type_Entry[TYP_Packed_Size]	= .(Descriptor[DSC$L_S1] - 4 + (.Index * 4)) * 8;
	    END;

	! Get index type
	!
	IF .Index_Types[.Index] EQL 0
	THEN
	    ! Integer subrange. An UNSIGNED subrange is indicated explicitly
	    ! by the compiler and is not the default handled here.
	    !
	    BEGIN
	    LOCAL
		Index_Type_Entry		: REF BLOCK [,BYTE] FIELD(Type_Fields);

	    Index_Type_Entry = PAS$_Create_Type(TYP_K_Ordinal);

	    Index_Type_Entry[TYP_Rst_Class]	= DSC$K_Dtype_L;
	    Index_Type_Entry[TYP_Packed_Size]	= 32;
	    Index_Type_Entry[TYP_Full_Size]	= 4;
	    Index_Type_Entry[ORD_Type]		= PAS$_TRW_Integer;
	    Index_Type_Entry[ORD_Lower]		= .(.DSC$L_L1 + (.Index * 8));
	    Index_Type_Entry[ORD_Upper]		= .(.DSC$L_L1 + (.Index * 8) + 4);
	    Index_Type_Entry[ORD_Dtype]		= L_Int;

	    Array_Type_Entry[ARR_Itype] = .Index_Type_Entry;
	    END

	ELSE
	    Array_Type_Entry[ARR_Itype] = PAS$_Get_Type(.Index_Types[.Index], %REF(SYM_K_Type));

	! Get the element type
	!
	IF .Index EQL (.Number_Of_Dimensions - 1)
	THEN
	    BEGIN
	    LOCAL
		Cell_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields);

	    Array_Type_Entry[ARR_Type]	= PAS$_Get_Type(.Cell_Type_Typid, %REF(SYM_K_Type));

	    IF .BLOCK[.Array_Type_Entry[ARR_Type], TYP_Class; ,BYTE] EQL TYP_K_Array
	    THEN
		! Fill in up-link
		!
		BLOCK[.Array_Type_Entry[ARR_Type], ARR_Up_Link] = .Array_Type_Entry;

	    IF .Packed
	    THEN
		IF .(Descriptor[DSC$L_S1] - 4 + (.Number_Of_Dimensions * 4)) EQL (.Cell_Type[TYP_Full_Size] * 8)
		THEN
		    ! Unpacked elements
		    !
		    Array_Type_Entry[TYP_Packed] = False
		ELSE

	    ELSE
		! Not UBA. Check for other special cases
		!
		IF PAS$_String(.Array_Type_Entry)
		THEN
		    ! Character string. Such arrays are always marked packed.
		    !
		    Array_Type_Entry[TYP_Packed] = True

		ELIF .Number_of_Dimensions NEQ 1 THEN
    		IF	.Array_Type_Entry[TYP_Packed_Size] LSSU
		(
		 (.BLK_B[.Array_Type_Entry[ARR_Type], TYP_Full_Size] * 8) *
		 (.BLK_B[.Array_Type_Entry[ARR_Itype], ORD_Upper] - .BLK_B[.Array_Type_Entry[ARR_Itype], ORD_Lower] + 1)
		)
		THEN
		    ! Packed array, even though its DST descriptor is not UBA.
		    ! The size of the array is smaller than the sum of the sizes of its unpacked elements
		    !
		    Array_Type_Entry[TYP_Packed] = True;
	    END

	ELSE
	    BEGIN
	    Array_Type_Entry[ARR_Type]	= PAS$_Create_Type(TYP_K_Array);

	    BLOCK[.Array_Type_Entry[ARR_Type], ARR_Up_Link; ,BYTE]	= .Array_Type_Entry;
	    END;

	! Get set for next go-round
	!
	Array_Type_Entry = .Array_Type_Entry[ARR_Type];
	END;

    ! Fix up the total size of the array
    !
    IF .Packed
    THEN
	BEGIN
	Type_Entry[TYP_Packed_Size]	= .Descriptor[DSC$L_Arsize];
	Type_Entry[TYP_Full_Size]	= (.Descriptor[DSC$L_Arsize] + 7) ^ -3;
	END
    ELSE
	BEGIN
	Type_Entry[TYP_Full_Size]	= .Descriptor[DSC$L_Arsize];
	Type_Entry[TYP_Packed_Size]	= .Descriptor[DSC$L_Arsize] * 8;
	END;

    END;

ROUTINE Get_Dynamic_Dimensions (Typid, Type_Entry, Descriptor) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Load dimensions of a dynamic array from the descriptor
!
! FORMAL PARAMETERS:
!
!	Typid		- RST pointer for the type. Used only for error signalling
!	Type_Entry	- Address of a complete array Type Table entry
!	Descriptor	- Address of an array descriptor in user memory
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    MAP
	Type_Entry		: REF BLOCK [,BYTE] FIELD(Type_Fields),
	Descriptor		: REF BLOCK [,BYTE];

    LOCAL
	Number_Of_Dimensions,
	DSC$L_L1,
	Previous_Array_Type	: REF BLOCK [,BYTE] FIELD(Type_Fields),
	Array_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields);

    IF .Descriptor[DSC$B_Class] EQL DSC$K_Class_A
    THEN
	BEGIN

	! Get number of dynamic dimensions and offset of 1st lower bound
	!
	Number_Of_Dimensions	= .Descriptor[DSC$B_Dimct];
	DSC$L_L1		= Descriptor[DSC$L_M1] + (.Number_Of_Dimensions * 4);

	! Initialize for bounds scan
	!
	Previous_Array_Type	= 0;
	Array_Type		= .Type_Entry;

	! Run thru the bounds
	!
	INCR Index FROM 0 TO .Number_Of_Dimensions - 1 DO
	    BEGIN
	    BIND
		Index_Type	= .Array_Type[ARR_Itype]
			: BLOCK [,BYTE] FIELD(Type_Fields);

	    ! Fill in the bounds
	    !
	    Index_Type[ORD_Lower]	= .(.DSC$L_L1 + (.Index * 8));
	    Index_Type[ORD_Upper]	= .(.DSC$L_L1 + (.Index * 8) + 4);

	    ! Get set for next go-round
	    !
	    Previous_Array_Type	= .Array_Type;
	    Array_Type		= .Array_Type[ARR_Type];
	    END;

	! Scan multipliers to get the size of each dynamic dimension
	!
	DECR Index FROM .Number_Of_Dimensions - 1 TO 0 DO
	    BEGIN
	    LOCAL
		Dimension_Size;		! Byte size of previous dimension

	    IF (.Array_Type[TYP_Packed_Size] AND 7) NEQ 0
	    THEN
		! Bit-accessed elements (can only happen on the last dimension)
		! Bit multiplier
		!
		Dimension_Size
			= (.Array_Type[TYP_Packed_Size] * .(Descriptor[DSC$L_M1] + (.Index * 4)) + 7) ^ -3
	    ELSE
		! Elements not bit-accessed. Byte multiplier
		!
		Dimension_Size
			= (.Array_Type[TYP_Packed_Size] ^ -3) * .(Descriptor[DSC$L_M1] + (.Index * 4));

	    Previous_Array_Type[TYP_Full_Size]	= .Dimension_Size;
	    Previous_Array_Type[TYP_Packed_Size]= .Dimension_Size * 8;

	    Array_Type		= .Previous_Array_Type;
	    Previous_Array_Type	= .Previous_Array_Type[ARR_Up_Link];
	    END;

	END

    ELSE
	SIGNAL(DBG$_INVARRDSC);

    END;

ROUTINE Get_Record_Type(Typid, Type_Entry) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Fill in a Type Table entry for a record type
!
! FORMAL PARAMETERS:
!
!	Typid		- RST Symid for the type
!	Type_Entry	- A pointer to a Type Table entry
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    MAP
	Type_Entry		: REF BLOCK [,BYTE] FIELD(Type_Fields);

    LOCAL
	Size,
	Number_Of_Components,
	Components		: REF VECTOR,

	Kind,
	Variant_Present,
	Variant_Symid;

    ! Get info about the type from the RST
    !
    DBG$STA_TYP_RECORD(.Typid, Number_Of_Components, Components, Size);

    ! Fill in the record Type Table entry
    !
    Type_Entry[TYP_Packed]		= False;
    Type_Entry[TYP_Rst_Class]		= DSC$K_Dtype_Z;
    Type_Entry[TYP_Packed_Size]		= .Size;
    Type_Entry[TYP_Full_Size]		= (.Size + 7) ^ -3;
    Type_Entry[REC_Fld_Head]		= 0;
    Type_Entry[REC_Var_Head]		= 0;
    Type_Entry[REC_Tag_Head]		= 0;
    Type_Entry[REC_Record]		= 0;

    ! Initialize for component vector scan
    !
    Variant_Present	= False;

    ! Scan the component vector
    !
    INCR Component_Number FROM 0 TO .Number_Of_Components - 1 DO
	BEGIN

	DBG$STA_Symkind(.Components[.Component_Number], Kind);

	IF .Kind NEQ RST$K_Variant
	THEN
	    ! Normal field. May also be an anonymous tag field, but we don't
	    ! worry about that here.
	    !
	    Get_Field(.Components[.Component_Number], .Type_Entry, 0)

	ELSE
	    ! Variant. Note that we have one, but defer processing until
	    ! after all regular fields are done. This way, multiple variants
	    ! won't kill us (we use the last variant we see).
	    !
	    BEGIN
	    Variant_Present	= True;
	    Variant_Symid	= .Components[.Component_Number];
	    END;

	END;

    ! Point to the fixed fields
    !
    Type_Entry[REC_Fixed_Fields] = .Type_Entry[REC_Fld_Head];

    ! Check for variant
    !
    IF .Variant_Present
    THEN
	Get_Variant(.Variant_Symid, .Type_Entry, Type_Entry[REC_Var_Head], Type_Entry[REC_Tag_Head], 0);

    ! Check for packed record
    !
    IF .Size NEQ (.Type_Entry[TYP_Full_Size] * 8)
    THEN
	Type_Entry[TYP_Packed] = True

    ELSE
	! Check for any packed fields
	!
	BEGIN
	LOCAL
	    Field_Entry		: REF BLOCK [,BYTE] FIELD(Keyword_Fields);

	Field_Entry = .Type_Entry[REC_Fld_Head];
	WHILE .Field_Entry NEQA 0 DO
	    IF .Field_Entry[FLD_Packed]
	    THEN
		BEGIN
		Type_Entry[TYP_Packed] = True;
		EXITLOOP;
		END
	    ELSE
		Field_Entry = .Field_Entry[FLD_Record_Link];
	END;

    END;

ROUTINE Get_Field(Field_Symid, Record_Entry, Variant_Entry) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Get information from the RST for a record field and build
!	a field list entry for it
!
! FORMAL PARAMETERS:
!
!	Field_Symid	- RST symid for the field
!	Record_Entry	- Pointer to the parent record Type Table entry
!	Variant_Entry	- Pointer to parent variant Type Table entry, if any
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    MAP
	Record_Entry		: REF BLOCK [,BYTE] FIELD(Type_Fields);

    LOCAL
	New_Field		: REF BLOCK [,BYTE] FIELD(Keyword_Fields),
	Name_String		: REF VECTOR [,BYTE],
	Name_Desc		: BLOCK [8, BYTE],
	Symbol_Name		: REF BLOCK [,BYTE] FIELD(NAM_Fields),
	Field_Offset		: DBG$Address_Desc,
	Field_Size;

    DBG$STA_Symname(.Field_Symid, Name_String);

    Name_Desc[DSC$W_Length]	= .Name_String[0];
    Name_Desc[DSC$B_Dtype]	= DSC$K_Dtype_T;
    Name_Desc[DSC$B_Class]	= DSC$K_Class_S;
    Name_Desc[DSC$A_Pointer]	= Name_String[1];

    ! Create or Lookup the Name Table entry
    !
    Symbol_Name			= PAS$_Lex_Enter_Name(Name_Desc);

    ! Allocate space for a field entry
    !
    IF NOT DBG$NLIST_FREEZ(ROUND_BYTE_TO_LONG_(FLD_S_Entry), New_Field, .PAS$_Message_Vector)
    THEN
	SIGNAL(DBG$_NOFREE);

    ! Fill in the field entry
    !
    New_Field[FLD_Name]		= .Symbol_Name;
    New_Field[FLD_Rst_Symid]	= .Field_Symid;

    PAS$_Get_Value(.Field_Symid, Field_Offset);

    New_Field[FLD_Position]	= .Field_Offset[DBG$L_Address_Byte_Addr] * 8
				+ .Field_Offset[DBG$L_Address_Bit_Offset];

    New_Field[FLD_Type]		= PAS$_Get_Type(.Field_Symid, %REF(SYM_K_Variable));

    IF .BLK_B(.New_Field[FLD_Type], TYP_Class) EQL TYP_K_Record
    THEN
	! Fill in up-link
	!
	BLK_B(.New_Field[FLD_Type], REC_Record) = .Record_Entry;

    ! Find out whether the field is packed
    !
    DBG$STA_Symsize(.Field_Symid, Field_Size);

    IF .Field_Size EQL 0
    THEN
	! Not packed, since Symsize couldn't find an explicit length
	!
	New_Field[FLD_Packed] = False
    ELIF .Field_Size NEQ (.BLK_B(.New_Field[FLD_Type], TYP_Full_Size) * 8)
    THEN
	! Actual size NEQ full size, therefore packed
	!
	BEGIN
	! Set the packed size field of the field type record,
	! in case the compiler didn't know it was going to be
	! used in a packed context
	!
	BLK_B(.New_Field[FLD_Type], TYP_Packed_Size) = .Field_Size;

	New_Field[FLD_Packed] = True;
	END
    ELSE
	New_Field[FLD_Packed] = False;

    ! Link the field to its parent record and variant
    !
    New_Field[FLD_Record]	= .Record_Entry;
    New_Field[FLD_Variant]	= .Variant_Entry;

    ! Link it to the Keyword List
    !
    New_Field[KEYW_Link]	= .Symbol_Name[NAM_Keyword];
    Symbol_Name[NAM_Keyword]	= .New_Field;

    ! Link field entry to list of record fields
    !
    New_Field[FLD_Field_Link]	= 0;
    IF .Record_Entry[REC_Fld_Head] NEQA 0
    THEN
	BLK_B(.Record_Entry[REC_Fld_Head], FLD_Field_Link) = .New_Field;

    New_Field[FLD_Record_Link]	= .Record_Entry[REC_Fld_Head];
    Record_Entry[REC_Fld_Head]	= .New_Field;

    END;

ROUTINE Get_Variant (Variant_Symid, Record_Entry, Variant_Head, Tag_Head, Super_Variant_Entry) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Get information from the RST for a variant and create a
!	Type Table entry for it.
!
! FORMAL PARAMETERS:
!
!	Variant_Symid		- RST symid for the variant
!	Record_Entry		- Address of parent record Type Table entry
!	Variant_Head		- Address of pointer to variant list
!	Tag_Head		- Address of pointer to tag value list
!	Super_Variant_Entry	- Address of super_variant Type Table entry
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	A pointer to the Type Table entry for the variant
!
!--

    BEGIN
    MAP
	Record_Entry		: REF BLOCK [,BYTE] FIELD(Type_Fields);

    LOCAL
	Number_Of_Variants,
	Variants		: REF VECTOR,
	Tag_Symid,
	Size,

	Number_Of_Fields,
	Fields			: REF VECTOR,
	Number_Of_Tags,
	Tags			: REF RST$Tag_List,
	Variant_Size,

	New_Variant		: REF BLOCK [,BYTE] FIELD(Type_Fields),

	Anonymous_Tagfield,
	Tag_Field_Entry		: REF BLOCK [,BYTE] FIELD(Keyword_Fields),
	Tag_Type_Entry		: REF BLOCK [,BYTE] FIELD(Type_Fields),

	Kind,
	Sub_Variant_Present,
	Sub_Variant_Symid;

    ! Get info about all the variants
    !
    DBG$STA_TYP_Variant(.Variant_Symid, Number_Of_Variants, Variants, Tag_Symid, Size);

    ! Look for the tag symid in the field list
    !
    Tag_Field_Entry	= .Record_Entry[REC_Fld_Head];
    WHILE .Tag_Field_Entry NEQA 0 DO
	IF DBG$STA_Same_Dst_Object(.Tag_Field_Entry[FLD_Rst_Symid], .Tag_Symid)
	THEN
	    ! Found it
	    !
	    EXITLOOP
	ELSE
	    Tag_Field_Entry = .Tag_Field_Entry[FLD_Record_Link];

    IF .Tag_Field_Entry EQLA 0
    THEN
	! Compiler failed to put out a tagfield record
	!
	Pascal_Bugcheck(PAS$K_COMPILER);

    ! Set tag info to include in each variant type table entry
    !
    Tag_Type_Entry	= .Tag_Field_Entry[FLD_Type];

    IF .BLK_B(.Tag_Field_Entry[FLD_Name], NAM_First_Char) EQL %C' '
    THEN
	! Anonymous tagfield. Zero the pointer to tag field
	!
	Anonymous_Tagfield = True
    ELSE
	Anonymous_Tagfield = False;


    ! Loop thru the variants
    !
    INCR Variant_Number FROM 0 TO .Number_Of_Variants - 1 DO
	BEGIN

	Sub_Variant_Present = False;

	! Get info about the particular variant
	!
	DBG$STA_TYP_Variant_Comp(.Variants[.Variant_Number], Number_Of_Fields, Fields, Number_Of_Tags, Tags, Variant_Size);

	! Allocate space for the variant Type Table entry
	!
	New_Variant = PAS$_Create_Type(TYP_K_Variant);

	! Fill in the new variant
	!
	New_Variant[VAR_Variant_Head]	= 0;
	New_Variant[VAR_Variant_Tag]	= (IF .Anonymous_Tagfield THEN 0 ELSE .Tag_Field_Entry);
	New_Variant[VAR_Variant_Type]	= .Tag_Type_Entry;
	New_Variant[VAR_Record]		= .Record_Entry;
	New_Variant[VAR_Variant]	= .Super_Variant_Entry;
	New_Variant[VAR_Tag_Head]	= 0;
	New_Variant[VAR_Variant_Fixed_Fields]	= 0;

	! Create the field list
	!
	INCR Field_Number FROM 0 TO .Number_Of_Fields - 1 DO
	    BEGIN

	    DBG$STA_Symkind(.Fields[.Field_Number], Kind);

	    IF .Kind NEQ RST$K_Variant
	    THEN
		Get_Field(.Fields[.Field_Number], .Record_Entry, .New_Variant)

	    ELSE
		BEGIN
		Sub_Variant_Present	= True;
		Sub_Variant_Symid	= .Fields[.Field_Number];
		END;
	    END;

	! Point to the fixed fields of the variant
	!
	IF .Number_Of_Fields NEQ 0
	THEN
	    New_Variant[VAR_Variant_Fixed_Fields] = .Record_Entry[REC_Fld_Head];

	! Take care of a sub-variant, if present
	!
	IF .Sub_Variant_Present
	THEN
	    Get_Variant(.Sub_Variant_Symid, .Record_Entry,
		New_Variant[VAR_Variant_Head], New_Variant[VAR_Tag_Head], .New_Variant);


	! Create the tag list
	!
	INCR Tag_Number FROM 0 TO .Number_Of_Tags - 1 DO
	    BEGIN
	    LOCAL
		Variant_Tag_Entry	: REF BLOCK [,BYTE] FIELD(Type_Fields);

	    IF .Tags[.Tag_Number, RST$L_Tag_Numvals] EQL 1
	    THEN
		! Create a single tag descriptor
		!
		BEGIN

		IF NOT DBG$NLIST_FREEZ(ROUND_BYTE_TO_LONG_(TYP_S_Variant_Tag), Variant_Tag_Entry, .PAS$_Message_Vector)
		THEN
		    SIGNAL(DBG$_NOFREE);

		Variant_Tag_Entry[VTAG_Constant]	= ..Tags[.Tag_Number, RST$L_Tag_Lowbound];
		Variant_Tag_Entry[VTAG_Variant_Link]	= .New_Variant;

		Variant_Tag_Entry[VTAG_Constant_Link]	= ..Tag_Head;
		.Tag_Head				= .Variant_Tag_Entry;
		END

	    ELIF .Tags[.Tag_Number, RST$L_Tag_Numvals] EQL 2
	    THEN
		INCR Tag_Value	FROM ..Tags[.Tag_Number, RST$L_Tag_Lowbound]
				TO   ..Tags[.Tag_Number, RST$L_Tag_Highbound] DO
		    ! Create tag descriptors for all the tag values
		    !
		    BEGIN

		    IF NOT DBG$NLIST_FREEZ(ROUND_BYTE_TO_LONG_(TYP_S_Variant_Tag), Variant_Tag_Entry,
					.PAS$_Message_Vector)
		    THEN
			SIGNAL(DBG$_NOFREE);

		    Variant_Tag_Entry[VTAG_Constant]		= .Tag_Value;
		    Variant_Tag_Entry[VTAG_Variant_Link]	= .New_Variant;

		    Variant_Tag_Entry[VTAG_Constant_Link]	= ..Tag_Head;
		    .Tag_Head					= .Variant_Tag_Entry;
		    END

	    ELSE
		! Illegal number of values
		!
		Pascal_Bugcheck(PAS$K_TAGVAL);
	    END;


	! Link variant just created to the Variant chain
	!
	New_Variant[VAR_Variant_Link]	= ..Variant_Head;
	.Variant_Head			= .New_Variant;
	END;


    ! Delete possible anonymous tagfield from the field list
    !
    IF .Anonymous_Tagfield
    THEN
	BEGIN

	! Eliminate from possible variant fixed field list
	!
	IF .Tag_Field_Entry[FLD_Variant] NEQA 0
	THEN
	    IF .BLK_B(.Tag_Field_Entry[FLD_Variant], VAR_Variant_Fixed_Fields) EQLA .Tag_Field_Entry
	    THEN
		BLK_B(.Tag_Field_Entry[FLD_Variant], VAR_Variant_Fixed_Fields)
			= .Tag_Field_Entry[FLD_Record_Link];

	! Eliminate from the record field list
	!
	IF .Tag_Field_Entry[FLD_Field_Link] EQLA 0
	THEN
	    ! Last field in the record
	    !
	    BEGIN
	    Record_Entry[REC_Fld_Head] = .Tag_Field_Entry[FLD_Record_Link];
	    IF .Tag_Field_Entry[FLD_Record_Link] NEQA 0
	    THEN
		BLK_B(.Tag_Field_Entry[FLD_Record_Link], FLD_Field_Link) = 0;
	    END
	ELSE
	    ! Embedded in the field list
	    !
	    BEGIN
	    BLK_B(.Tag_Field_Entry[FLD_Field_Link], FLD_Record_Link) = .Tag_Field_Entry[FLD_Record_Link];
	    IF .Tag_Field_Entry[FLD_Record_Link] NEQA 0
	    THEN
		BLK_B(.Tag_Field_Entry[FLD_Record_Link], FLD_Field_Link) = .Tag_Field_Entry[FLD_Field_Link];
	    END;

	END;

    END;

ROUTINE Get_Set_Type (Typid, Type_Entry) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Fill in a Type Table entry for a set type
!
! FORMAL PARAMETERS:
!
!	Typid		- RST Symid for the type
!	Type_Entry	- A pointer to a Type Table entry
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    MAP
	Type_Entry		: REF BLOCK [,BYTE] FIELD(Type_Fields);

    LOCAL
	Base_Type		: REF BLOCK [,BYTE] FIELD(Type_Fields),
	Base_Type_Typid,
	Size;
	
    ! Get info about the type from the RST
    !
    DBG$STA_TYP_SET(.Typid, Base_Type_Typid, Size);

    ! Fill in the Type Table entry
    !
    Type_Entry[TYP_Rst_Class]		= DSC$K_Dtype_Z;
    Base_Type				= PAS$_Get_Type(.Base_Type_Typid, %REF(SYM_K_Type));
    Type_Entry[SET_Type]		= .Base_Type;

    Type_Entry[TYP_Packed_Size]		= .Base_Type[ORD_Upper] + 1;
    Type_Entry[TYP_Full_Size]		= (.Size + 7) ^ -3;

    END;

ROUTINE Get_File_Type (Typid, Type_Entry) : NOVALUE =

!++
! FUNCTIONAL SPECIFICATION:
!
!	Fill in a Type Table entry for a file type
!
! FORMAL PARAMETERS:
!
!	Typid		- RST Symid for the type
!	Type_Entry	- A pointer to a Type Table entry
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
!--

    BEGIN
    MAP
	Type_Entry		: REF BLOCK [,BYTE] FIELD(Type_Fields);

    LOCAL
	Language,
	Component_Type_Typid;

    ! Get info about the type from the RST
    !
    DBG$STA_TYP_FILE(.Typid, Language, Component_Type_Typid);

    IF .Language NEQ DBG$K_Pascal
    THEN
	SIGNAL(DBG$_UNKNOWNTYP);

    ! Fill in the type table entry
    !
    Type_Entry[TYP_Rst_Class]	= DSC$K_Dtype_Z;
    Type_Entry[FIL_Type]	= PAS$_Get_Type(.Component_Type_Typid, %REF(SYM_K_Type));
    Type_Entry[FIL_Version]	= PAS$_Get_Version();

    END;

END
ELUDOM
