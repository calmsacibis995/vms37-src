!
! File:   PASLIB.R32
!
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
!++
!
! FACILITY:	VAX-11 PASCAL LANGUAGE-SPECIFIC DEBUGGER MODULES
!
! ABSTRACT:
!
!	This is the common definition file for VAX-11 PASCAL Debugger Modules.
!	All definitions of interest to more than one module are in this file.
!	This file is used as a library source.  See also PASPROLOG.R32, which
!	invokes the resulting library file.
!
! ENVIRONMENT:	VAX/VMS user mode
!
! AUTHOR: M. Jack, CREATION DATE: 04-Mar-1978
!
! MODIFIED BY:
!	  P. Hohensee	07-Jul-80	Stolen from Pascal_Plus Project
!
!--

!			T A B L E    O F    C O N T E N T S
!
!
!	Common Language-Specific Kernal Debugger Definitions and
!		Position and Size Macros
!	General
!	    Common Definitions
!	Data Structures
!	    Name Table
!	    String Data Set
!	    Symbol Table
!	    Type Table
!	Pascal-Specific Data Structures
!	    Pascal-specific fixed primary descriptor fields
!

!	C O M M O N   K E R N E L   D E B U G G E R   D E F I N I T I O N S
!
!				A N D
!
!		P O S I T I O N    A N D    S I Z E    M A C R O S
!
!
!
!	The following macros must be used in defining field names for compiler data structures to supply
!	the position, size, and extension values for a BLOCK or VECBLOCK structure reference.
!	The various generic forms are described below:
!
!		A		Materialized address.
!		L		Longword.
!		W		Zero extended word.
!		B		Zero extended byte.
!		V		Zero extended bit field.
!		SW		Sign extended word.
!		SB		Sign extended byte.
!		SV		Sign extended bit field.
!
!	The "A" forms should be used whenever the field being defined is such that the only valid structure
!	reference is one that materializes the address of the field; that is, fetch and store operations
!	are not valid.  An example of such a field is one containing an ASCII string.
!
!	Each of the "V" and "SV" forms takes one or two parameters.  The first parameter is the bit
!	position within the longword or byte, and the second is the field size.  The second parameter is
!	optional; the default is 1.
!
SWITCHES
	LIST (REQUIRE);

LIBRARY 'SRC$:STRUCDEF.L32';

LIBRARY 'SRC$:DBGCOMLIB.L32';

!			POSITION AND SIZE MACROS
!
!
MACRO
	!
	! Macros to construct a bit mask from a standard four-component field definition (offset, position, size,
	! extension).  The result has set bits in those positions that belong to the field.  A list of field
	! definitions can be specified.
	!
	! Example:
	!
	!	FIELD
	!	    A=[0,2,4,0],
	!	    B=[0,9,1,0];
	!
	!	MASK_(A,B) is equal to %B'1000111100'
	!
	MASK_[]=
	    (0 OR XMASK_(%REMAINING)) %,

	XMASK_[P]=
	    (1 ^ (%FIELDEXPAND(P,1)+%FIELDEXPAND(P,2))) - (1 ^ %FIELDEXPAND(P,1)) %,


	! Macros to align a specified value at the bit position specified by a standard four-component field definition
	! (offset, position, size, extension).  A list of values and field definitions can be specified.
	!
	! Example:
	!
	!	FIELD
	!	    A=[0,2,4,0],
	!	    B=[0,9,1,0];
	!
	!	ALIGN_(7,A,1,B) is equal to 7^2 OR 1^9
	!
	ALIGN_[]=
	    (0 OR XALIGN_(%REMAINING)) %,


	XALIGN_[V,P]=
	    ((V) ^ %FIELDEXPAND(P,1)) %;


MACRO
	!
	! Form the composition of several succesive references through REF BLOCK structures.
	!
	! This macro lets you do multi-level pointer-chasing without having to program
	! each level of indirection as an assignment to a pointer variable.
	!
	! Example:
	!
	!	If T has been declared as  T: REF BLOCK
	!
	!	IF .BLK_B[.T, TRXP1, SYMDPT, DIMFLG(FADJAR) ]	or equivalently
	!
	!	IF .BLK_B[.T[TRXP1], SYMDPT, DIMFLG(FADJAR) ]
	!
	! The effect is to test the Adjustable Array flag of the descriptor record
	! that is pointed to by the SYMDPT field of the symbol table record
	! that is pointed to by the TRXP1  field of the triple.
	!
	!
	BLK_B(A,P) [] =
	    %IF %NULL( %REMAINING )
	    %THEN
		BLOCK[A,P; ,BYTE]
	    %ELSE
		BLK_B(.BLOCK[A,P; ,BYTE],  %REMAINING )
	    %FI %;

!			G E N E R A L
!
!

MACRO
	ELIF=		ELSE IF %,
	REPEAT=		WHILE 1 DO %,			! Note: in new BLISSes repeat can not be labeled
	LOOP=		BEGIN WHILE 1 DO BEGIN %,	!	but LOOP / END_LOOP can.
	END_LOOP=	END END %,


	! Round a value to the next higher multiple of 4.
	!
	ROUND_LONG_(A)=
	    (((A) + 3) AND NOT 3) %,


	! Convert number of bytes to number of longwords (rounding up)
	!
	ROUND_BYTE_TO_LONG_(A)=
	    (((A) + 3) ^ -2 ) %,

	! Signal a compiler internal consistency check.
	!
	Pascal_BugCheck(A)=
	    BEGIN
	    %IF %LENGTH EQL 0
	    %THEN
		SIGNAL(%NAME('DBG$_DEBUGBUG'), 1, 0);
	    %ELSE
		SIGNAL(%NAME('DBG$_DEBUGBUG'), 1, A);
	    %FI
	    0
	    END %,


	! Signal not yet implemented error check.
	!
	Not_Implemented(A)=
	    BEGIN
	    %IF %LENGTH EQL 0
	    %THEN
		SIGNAL(%NAME('DBG$_NOTDONE'), 1, UPLIT(%ASCIC 'Pascal construct'));
	    %ELSE
		SIGNAL(%NAME('DBG$_NOTDONE'), 1, UPLIT(%ASCIC A));
	    %FI
	    0
	    END %,


	! Build a literal string w/ descriptor
	!
	String(Char_String) = UPLIT(
	    WORD( %CHARCOUNT(Char_String) ),
	    BYTE( DSC$K_DTYPE_T ),
	    BYTE( DSC$K_CLASS_S ),
	    LONG( UPLIT BYTE(Char_String) ) ) %,


	! "Canonicalize" a Truth Value; converts a VAX low-bit 0/1 tested value into a clean 0 or 1.
	!
	BOOL(X) = ((X) AND 1) %;

!	UTILITY MACROS
!
MACRO
	MOVEBYTE(CNT,SRC,DST)=
	    %IF NOT %CTCE((CNT))
	    %THEN
		CH$MOVE((CNT),(SRC),(DST)) 
	    %ELSE
		%IF (CNT) MOD 2 EQL 0
		%THEN
		    MOVEWORD((CNT)/2,(SRC),(DST))
		%ELSE
		    %IF (CNT) GTR 1
		    %THEN
			CH$MOVE((CNT),(SRC),(DST))
		    %ELSE
			%IF (CNT) EQL 1
			%THEN
			    (DST)<B0_> = .(SRC)<B0_>
			%FI
		    %FI
		%FI
	    %FI					%,


	MOVEWORD(CNT,SRC,DST)=
	    %IF NOT %CTCE((CNT))
	    %THEN
		CH$MOVE((CNT)*2,(SRC),(DST)) 
	    %ELSE
		%IF (CNT) MOD 2 EQL 0
		%THEN
		    MOVELONG((CNT)/2,(SRC),(DST))
		%ELSE
		    %IF (CNT) GTR 1
		    %THEN
			CH$MOVE((CNT)*2,(SRC),(DST))
		    %ELSE
			%IF (CNT) EQL 1
			%THEN
			    (DST)<W0_> = .(SRC)<W0_>
			%FI
		    %FI
		%FI
	    %FI					%,

	MOVELONG(CNT,SRC,DST)=
	    %IF NOT %CTCE((CNT))
	    %THEN
		CH$MOVE((CNT)*4,(SRC),(DST)) 
	    %ELSE
		%IF (CNT) GTR 2
		%THEN
		    CH$MOVE((CNT)*4,(SRC),(DST))
		%ELSE
		    %IF (CNT) GTR 0
		    %THEN
			%IF (CNT) GTR 1
			%THEN
			    BEGIN
				(DST)<L_> = .(SRC)<L_>;
				((DST)+4)<L_> = .((SRC)+4)<L_>
			    END
			%ELSE
			    (DST)<L_> = .(SRC)<L_>
			%FI
		    %FI
		%FI
	    %FI					%;


LITERAL
	MAX_ZEROLONG	= 4;		! Maximum number of longwords cleared by hand in ZEROxxxx macros

MACRO
	ROUND(X)=( ((X)+3) AND %X'FFFFFFFC') %,

	ZEROLONG(CNT,DST)[] = 
	    %IF NOT %CTCE((CNT))
	    %THEN
		CH$FILL(0,(CNT)*4,(DST))
	    %ELSE
		%IF  (CNT) GTR MAX_ZEROLONG
		%THEN
		    CH$FILL(0,(CNT)*4,(DST))
		%ELSE
		    %IF %COUNT GEQ (CNT)
		    %THEN
			%EXITMACRO
		    %ELSE
			(DST) + %COUNT*4 = 0;
			ZEROLONG((CNT),DST)
		    %FI
		%FI
	    %FI					%,

	ZEROWORD(CNT,DST) =
	    %IF NOT %CTCE((CNT))
	    %THEN
		CH$FILL(0,(CNT)*2,(DST))
	    %ELSE
		%IF (CNT)/2 GTR MAX_ZEROLONG
		%THEN
		    CH$FILL(0,(CNT)*2,(DST))
		%ELSE
		    ZEROLONG((CNT)/2, DST);
		    %IF (CNT) MOD 2 EQL 0
		    %THEN
			%EXITMACRO
		    %ELSE
			BEGIN
			MAP
			    DST:	VECTOR[,WORD];
			DST[2*((CNT)/2)] = 0;
			END;
		    %FI
		%FI
	    %FI					%,

	ZEROBYTE(CNT,DST) =
	    %IF NOT %CTCE((CNT))
	    %THEN
		CH$FILL(0,(CNT),(DST))
	    %ELSE
		%IF (CNT)/4 GTR MAX_ZEROLONG
		%THEN
		    CH$FILL(0,(CNT),(DST))
		%ELSE
		    ZEROWORD((CNT)/2, DST);
		    %IF (CNT) MOD 2 EQL 0
		    %THEN
			%EXITMACRO
		    %ELSE
			BEGIN
			MAP
			    DST:	VECTOR[,BYTE];
			DST[(CNT)-1] = 0;
			END;
		    %FI
		%FI
	    %FI					%,

	AUTOCLR(LOW,HIGH)=
	    ZEROBYTE((HIGH)-(LOW), (LOW)) %,

	BLANKFILL(CNT,DST) =
	    %IF NOT %CTCE((CNT))
	    %THEN
		CH$FILL(%C' ',(CNT),(DST))
	    %ELSE
		%IF (CNT) GTR 1
		%THEN
		    CH$FILL(%C' ',(CNT),(DST))
		%ELSE
		    %IF (CNT) EQL 1
		    %THEN
			(DST)<B0_> = %C' '
		    %FI
		%FI
	    %FI					%;


!			THE "ONEOF" MACRO
!
MACRO
	!
	! Macros to determine if the value of an expression is one of a set of
	! specified small-integer values.  These macros can be used only if the
	! following conditions are met:
	!
	!	The value to be tested is in the range 0 through 127.
	!
	!	The values to be tested for are all in the range 0 through 31.
	!
	! Example:
	!
	!	IF ONEOF_(.X, BMSK_(1,3,5)) ...
	!
	! The code generated is much more efficient than a series of comparisons
	! (provided that the parameters of BMSK_ are all compile-time constant).
	!
	! BRANGE_(A,B) produces a bit mask of all bits between A and B.
	!
	XBMSK_[A]=
	    (1 ^ (31 - (A))) %,


	BMSK_[]=
	    (0 OR XBMSK_(%REMAINING)) %,


	BRANGE_(A,B)=
	    BEGIN
	    IF A GTR B
	    THEN
		0
	    ELSE
		(1 ^ ((B)+1)) - (1 ^ (A))
	    END %,



	ONEOF_(A,B)=
	    (((B) ^ (A)) LSS 0) %;

!			B I T   V E C T O R   S U P P O R T
!
MACRO
	!
	! Macros to create plit-items for a bit-vector, which can be used to
	! determine whether a value is amoung the values which are set in this
	! bit-vector.  The first parameter to BV_ is the largest element which
	! will be accessed in the bit-vector.
	!
	! For example:
	!
	!	BV_( 50, 0,2,4,16,33,17,35,47 )	would (essentially) expand to:
	!
	!	%B'00000000000000110000000000010101'  ,
	!	%B'00000000000000001000000000001010'
	!
	! And, given the definition:
	!
	!	BIND FOO = UPLIT( BV_(100, 1,4,9,16,25,36) ) : BITVECTOR;
	!
	! Then
	!	.FOO[0]	is 0,	.FOO[1] is 1, ... , .FOO[100] is 0.
	!
	BV_XBMSK_(B)[A]=
	    %IF (A)-(B) LSSU %BPVAL
	    %THEN
		( 1 ^ ((A)-(B)) )
	    %ELSE
		0
	    %FI
	    %,

	BV_LBMSK_(M,B)[]=
	    (0 OR BV_XBMSK_(B, %REMAINING))
	    %IF B + %BPVAL  LEQ  M
	    %THEN
		,  BV_LBMSK_(M, B+%BPVAL, %REMAINING)
	    %FI
	    %,

	BV_(MAXB) =
	    %QUOTE BV_LBMSK_(MAXB, 0, %REMAINING)
	    %,


	!
	! The BITS_ macro is used to construct a bit vector from a string
	! of 0's and 1's; e.g. BITS_(1,1,0,1) = %X'1101' = 13(decimal).
	!
	XBITS_[V] =
	    ((V) ^ %COUNT) %,

	BITS_[] =
	    (0 OR XBITS_(%REMAINING)) %;

!		A U T O - I N C R / D E C R   S U P P O R T
!
!
	!
	! The follow macros allow you to scan across a block structure and successively access its named fields.
	!
	! In order to be useful (that is generate decent code) various conditions must be met:
	!
	!	FLD must be byte alligned and either 8, 16 or 32 bits wide.
	!
	!	PTR must be a REF BLOCK[,BYTE] and should be allocated to a register.  At the point of use of any of
	!		these macros, PTR must point to the field whose name is FLD.
	!
	!	VAL may be any appropriate expression.
	!

	! Dummy structure to get free parenthesization without really using them
	!
STRUCTURE
	Bliss_Hack_[] = Bliss_Hack_;

MACRO Auto_INC_and_DEC =

	MACRO

		! GET -- Get field value and and advance pointer
		!
		GET(PTR,FLD)=
		    BEGIN
		    %IF ((%FIELDEXPAND(FLD,1) OR
			%FIELDEXPAND(FLD,2))
			AND 7 ) NEQ 0
		    %THEN %ERROR('Field size or allignment')
		    %FI
		    Bliss_Hack_[PTR] = .Bliss_Hack_[PTR] + ( %FIELDEXPAND(FLD,2) / 8 );
		    .BLOCK[.Bliss_Hack_[PTR],
			-( %FIELDEXPAND(FLD,2) / 8),
			0,
			%FIELDEXPAND(FLD,2),
			%FIELDEXPAND(FLD,3)
			;,BYTE]
		    END %QUOTE %,

		! GETR -- Decrement pointer and get field value
		!
		GETR(PTR,FLD)=
		    BEGIN
		    %IF ((%FIELDEXPAND(FLD,1) OR
			%FIELDEXPAND(FLD,2))
			AND 7 ) NEQ 0
		    %THEN %ERROR('Field size or allignment')
		    %FI
		    Bliss_Hack_[PTR] = .Bliss_Hack_[PTR] - ( %FIELDEXPAND(FLD,2) / 8 );
		    .BLOCK[.Bliss_Hack_[PTR],
			0,
			0,
			%FIELDEXPAND(FLD,2),
			%FIELDEXPAND(FLD,3)
			;,BYTE]
		    END %QUOTE %;

!			AUTO-INCR/DECR SUPPORT
!
!
	MACRO
		! PUT -- Put field value and increment pointer
		!
		PUT(PTR,FLD,VAL)=
		    BEGIN
		    %IF ((%FIELDEXPAND(FLD,1) OR
			%FIELDEXPAND(FLD,2))
			AND 7 ) NEQ 0
		    %THEN %ERROR('Field size or allignment')
		    %FI
		    Bliss_Hack_[PTR] = .Bliss_Hack_[PTR] + ( %FIELDEXPAND(FLD,2) / 8 );
		    BLOCK[.Bliss_Hack_[PTR],
			-( %FIELDEXPAND(FLD,2) / 8),
			0,
			%FIELDEXPAND(FLD,2),
			%FIELDEXPAND(FLD,3)
			;,BYTE]
			= (VAL)
		    END %QUOTE %,

		! PUTR -- Decrement pointer and put field value
		!
		PUTR(PTR,FLD,VAL)=
		    BEGIN
		    %IF ((%FIELDEXPAND(FLD,1) OR
			%FIELDEXPAND(FLD,2))
			AND 7 ) NEQ 0
		    %THEN %ERROR('Field size or allignment')
		    %FI
		    Bliss_Hack_[PTR] = .Bliss_Hack_[PTR] - ( %FIELDEXPAND(FLD,2) / 8 );
		    BLOCK[.Bliss_Hack_[PTR],
			0,
			0,
			%FIELDEXPAND(FLD,2),
			%FIELDEXPAND(FLD,3)
			;,BYTE]
			= (VAL)
		    END %QUOTE %;

	%;	! end of Auot_INC_and_DEC

FIELD
	!
	! The following definitions may be used for accessing anonymous items.
	!
	Next_Char  = [ 0, B0_  ],
	Next_Byte  = [ 0, B0_  ],
	Next_Word  = [ 0, W0_  ],
	Next_Long  = [ 0, L_   ],
	Next_SByte = [ 0, SB0_ ],
	Next_SWord = [ 0, SW0_ ],
	Prev_Char  = [ 0, B0_  ],
	Prev_Byte  = [ 0, B0_  ],
	Prev_Word  = [ 0, W0_  ],
	Prev_Long  = [ 0, L_   ],
	Prev_SByte = [ 0, SB0_ ],
	Prev_SWord = [ 0, SW0_ ];

MACRO

	! This macro "should" generate a simple SCANC instruction
	!
	!	LENA	- Address of a word containing the length
	!	ADDR	- Address of the start of the string
	!	TBLADDR	- Address of the Bit Table
	!	MASKA	- Address of a Byte Mask for use with the Bit Table
	!	OLENA	- Address of a word to receive the remaining length
	!	OADDR	- Address of a Longword to receive the pointer to the next character
	!
	PAS_SCANC(LENA, ADDR, TBLADDR, MASKA, OLENA, OADDR) =
	    BEGIN
		BUILTIN SCANC, R0, R1;
		LOCAL T0, T1;
		T1 = T0 = SCANC(LENA, ADDR, TBLADDR, %REF(MASKA));
		IF CH$FAIL(.T0) THEN T1 = .ADDR + .LENA<W0_>;
		%IF NOT %NULL(OADDR) %THEN OADDR = .T1; %FI
		%IF NOT %NULL(OLENA) %THEN OLENA = .LENA<W0_> + ADDR - .T1; %FI
		CH$FAIL(.T0)
	    END %,


	! This macro "should" generate a simple SPANC instruction
	!
	!	LENA	- Address of a word containing the length
	!	ADDR	- Address of the start of the string
	!	TBLADDR	- Address of the Bit Table
	!	MASKA	- Address of a Byte Mask for use with the Bit Table
	!	OLENA	- Address of a word to receive the remaining length
	!	OADDR	- Address of a Longword to receive the pointer to the next character
	!
	PAS_SPANC(LENA, ADDR, TBLADDR, MASKA, OLENA, OADDR) =
	    BEGIN
		BUILTIN SPANC, R0, R1;
		LOCAL T0, T1;
		T1 = T0 = SPANC(LENA, ADDR, TBLADDR, %REF(MASKA));
		IF CH$FAIL(.T0) THEN T1 = .ADDR + .LENA<W0_>;
		%IF NOT %NULL(OADDR) %THEN OADDR = .T1; %FI
		%IF NOT %NULL(OLENA) %THEN OLENA = .LENA<W0_> + ADDR - .T1; %FI
		CH$FAIL(.T0)
	    END %,

	PAS_MOVTUC(SRCLENA, SRCADDR, ESCA, TBLADDR, DSTLENA, DSTADDR, OSRCLENA, OSRCADDR, ODSTLENA, ODSTADDR) =
	    BEGIN
		BUILTIN MOVTUC, R0, R1, R4, R5;
		MOVTUC(SRCLENA, SRCADDR, %REF(ESCA), TBLADDR,
		    DSTLENA, DSTADDR);
		%IF NOT %NULL(OSRCLENA) %THEN OSRCLENA = .R0; %FI
		%IF NOT %NULL(OSRCADDR) %THEN OSRCADDR = .R1; %FI
		%IF NOT %NULL(ODSTLENA) %THEN ODSTLENA = .R4; %FI
		%IF NOT %NULL(ODSTADDR) %THEN ODSTADDR = .R5; %FI
		(.R0 NEQ 0)
	    END %,


	! This macro "should" generate a simple LOCC instruction
	!
	!	SRCLENA	- Address of a word containing the length
	!	SRCADDR	- Address of the start of the string
	!	ESCA	- Address of the Escape Character
	!	OSRCLENA- Address of a word to receive the remaining length
	!	OSRCADDR- Address of a Longword to receive the pointer to the next character
	!
	PAS_LOCC(SRCLENA, SRCADDR, ESCA, OSRCLENA, OSRCADDR) =
	    BEGIN
		BUILTIN R0, R1;
		LOCAL T0, T1;
		T1 = T0 = CH$FIND_CH(.SRCLENA<W0_>, SRCADDR, ESCA);
		IF CH$FAIL(.T0) THEN T1 = .SRCLENA<W0_> + SRCADDR;
		%IF NOT %NULL(OSRCADDR) %THEN OSRCADDR = .T1; %FI
		%IF NOT %NULL(OSRCLENA) %THEN OSRCLENA = .SRCLENA<W0_> + SRCADDR - .T1; %FI
		CH$FAIL(.T0)
	    END %,


	! This macro "should" generate a simple SKPC instruction
	!
	!	SRCLENA	- Address of a word containing the length
	!	SRCADDR	- Address of the start of the string
	!	ESCA	- Address of the Escape Character
	!	OSRCLENA- Address of a word to receive the remaining length
	!	OSRCADDR- Address of a Longword to receive the pointer to the next character
	!
	PAS_SKPC(SRCLENA, SRCADDR, ESCA, OSRCLENA, OSRCADDR) =
	    BEGIN
		BUILTIN R0, R1;
		LOCAL T0, T1;
		T1 = T0 = CH$FIND_NOT_CH(.SRCLENA<W0_>, SRCADDR, ESCA);
		IF CH$FAIL(.T0) THEN T1 = .SRCLENA<W0_> + SRCADDR;
		%IF NOT %NULL(OSRCADDR) %THEN OSRCADDR = .T1; %FI
		%IF NOT %NULL(OSRCLENA) %THEN OSRCLENA = .SRCLENA<W0_> + SRCADDR - .T1; %FI
		CH$FAIL(.T0)
	    END %,

	PAS_MATCHC(SRC1LENA, SRC1ADDR, SRC2LENA, SRC2ADDR, OSRCLENA, OSRCADDR) =
	    BEGIN
		BUILTIN R0, R1;
		LOCAL T0, T1;
		T1 = T0 = CH$FIND_SUB(.(SRC1LENA)<W0_>, SRC1ADDR,
		    .(SRC2LENA)<W0_>, SRC2ADDR);
		IF CH$FAIL(.T0) THEN T1 = .(SRC1LENA)<W0_> + SRC1ADDR;
		%IF NOT %NULL(OSRCADDR) %THEN OSRCADDR = .T1; %FI
		%IF NOT %NULL(OSRCLENA) %THEN OSRCLENA = .(SRC1LENA)<W0_> + SRC1ADDR - .T1; %FI
		CH$FAIL(.T0)
	    END %;

!			N A M E   T A B L E
!
!	The NAME TABLE uses a chained-hash structure, with the actual name
!	entries allocated in command-temporary storage.
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------------------------------------------------------+
!	|                          NAM_Pointer                          |   0
!	+---------------------------------------------------------------+
!	|                           NAM_Chain                           |   4
!	+---------------------------------------------------------------+
!	|                          NAM_KeyWord                          |   8
!	+-----------------------------------------------+---------------+
!	|                                 NAM_First_Char|  NAM_Length   |   12
!	|                                               +---------------+
!	|                              ...                              |
!	+---------------------------------------------------------------+
!
!

FIELD
   NAM_FIELDS =
	SET
	NAM_Pointer	= [ 0, L_],	! Pointer to Symbol Table entry
	NAM_Chain	= [ 4, L_],	! Name Table linked list chain word
	NAM_KeyWord	= [ 8, L_],	! Pointer to linked list of field names
	NAM_Text	= [12, A_],	! ASCIC name text
	NAM_Length	= [12, B0_],	! Length of ASCIC Name
	NAM_First_Char	= [12, B1_]	! First Character of ASCIC Name
	TES;

LITERAL
	NAM_S_ENTRY	= 13;		! Minimum size of Entry

!		      F I E L D    E N T R I E S
!
!	These entries are used to describe field names within a record
!
!	These entries are linked linearly off of the name table entry,
!	and due to their infrequency should pose no speed problems.
!
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------------------------------------------------------+
!	|                           KEYW_Link                           |  0
!	+---------------------------------------------------------------+
!	|                           FLD_Name                            |  4
!	+---------------------------------------------------------------+
!	|                        FLD_Rst_Symid                          |  8
!	+---------------------------------------------------------------+
!	|                         FLD_Position                          |  12
!	+---------------------------------------------------------------+
!	|                           FLD_Type                            |  16
!	+---------------------------------------------------------------+
!	|                        FLD_Attributes                         |  20
!	+---------------------------------------------------------------+
!	|                          FLD_Record                           |  24
!	+---------------------------------------------------------------+
!	|                          FLD_Variant                          |  28
!	+---------------------------------------------------------------+
!	|                        FLD_Record_Link                        |  32
!	+---------------------------------------------------------------+
!	|                        FLD_Field_Link                         |  36
!	+---------------------------------------------------------------+
!
!
LITERAL
	FLD_S_Entry		= 40;			! Size of a Field Description

FIELD
    Keyword_Fields =
	SET

	! General
	!
	KEYW_Link		= [0, L_],		! Link to next entry

	! Specific to fields of records
	!
	FLD_Name		= [ 4, L_],		! Pointer to Name Entry
	FLD_Rst_Symid		= [ 8, L_],		! RST pointer for the field
	FLD_Position		= [12, L_],		! Position within entry
	FLD_Type		= [16, L_],		! Pointer to Type Entry
	FLD_Attributes		= [20, L_],		! Attribute Bits
		FLD_Packed	= [20, V_(0)],		! Indicates if Packed
	FLD_Record		= [24, L_],		! Pointer to Record Symbol Table ENtry
	FLD_Variant		= [28, L_],		! Pointer to Variant Type Table Entry
	FLD_Record_Link		= [32, L_],		! Pointer to next Record Field
	FLD_Field_Link		= [36, L_]		! Pointer to preceding Record Field

	TES;

!		S T R I N G   D A T A - S E T   E N T R Y
!
!	These entries are used to describe character strings. They
!	have the capability to consist of concatenated strings, by
!	chaining the entries togethter.
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+-------------------------------+-------------------------------+
!	|                               |          STR_Length           |
!	+-------------------------------+-------------------------------+
!	|                            STR_Next                           |
!	+-----------------------------------------------+---------------+
!	|                                                STR_First_Char |
!	+                                               +---------------+
!
FIELD
    STR_FIELDS =
	SET
	STR_Length	= [ 0, W0_],	! Length of String
	STR_Next	= [ 4, L_ ],	! Pointer to next string entry (concatenate)
	STR_First_Char	= [ 8, A0_]	! Rest of String
	TES;

LITERAL
	STR_S_ENTRY	= 8;		! Minimum size of Entry

!		S Y M B O L   T A B L E   E N T R I E S
!
!	This is the Symbol Table Entry, which is distinct from
!	the NAMe table, the TYPe table, and other random tables
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+-----------------------------------------------+--------------+
!	|                                               |   SYM_Class  |   0
!	+-----------------------------------------------+--------------+
!	|                         SYM_Rst_Symid                        |   4
!	+--------------------------------------------------------------+
!	|                         SYM_Previous                         |   8
!	+--------------------------------------------------------------+
!	|                          SYM_Thread                          |  12
!	+--------------------------------------------------------------+
!	|                           SYM_Name                           |  16
!	+--------------------------------------------------------------+
!
!
! for CONSTANTs:
!
!	+--------------------------------------------------------------+
!	|                           CON_Type                           |  20
!	+--------------------------------------------------------------+
!
!
! for VARIABLEs
!
!	+--------------------------------------------------------------+
!	|                           VAR_Type                           |  20
!	+--------------------------------------------------------------+
!
!
! for TYPEs
!
!	+--------------------------------------------------------------+
!	|                           STY_Type                           |  20
!	+--------------------------------------------------------------+

!			SYMBOL TABLE ENTRIES
!
!
! for PROCEDUREs and FUNCTIONs
!
!	+--------------------------------------------------------------+
!	|                        PROC_Func_Type                        |  20
!	+--------------------------------------------------------------+
!
!
! for FIELDs
!
!	+--------------------------------------------------------------+
!	|                          WFLD_Type                           |  20
!	+--------------------------------------------------------------+
!
!
!
! for RESERVED WORDS:
!
!	+--------------------------------------------------------------+
!	|                          RESW_Token                          |  20
!	+--------------------------------------------------------------+
!

LITERAL

	! These constants define the field in the symbol table entry
	! designated SYM_Class, and determine which type of entry it is
	!
	SYM_K_Constant		= 1,		! CONST entry
	SYM_K_Variable		= 2,		! VAR entry
	SYM_K_Type		= 3,		! TYPE Entry
	SYM_K_Procedure		= 4,		! Procedure
	SYM_K_Function		= 5,		! Function
	SYM_K_Field		= 6,		! Field Name Entry
	SYM_K_Reserved_Word	= 8,		! Reserved Word
	SYM_K_Label		= 9,		! Label
	SYM_K_Line		= 10,		! Line Number

	! These constants describe the sizes of the different entries
	! for the Symbol Table
	!
	SYM_S_Constant		= 36,		! CONST entry
	SYM_S_Variable		= 24,		! VAR entry
	SYM_S_Type		= 24,		! TYPE Entry
	SYM_S_Procedure		= 24,		! Procedure & Function
	SYM_S_Function		= 24,		!     "           "
	SYM_S_Field		= 24,		! Field Name Entry
	SYM_S_Reserved_Word	= 24,		! Reserved Word
	SYM_S_Label		= 20,		! Label
	SYM_S_Line		= 20;		! Line Number

FIELD
    Symbol_Fields	=
	SET

    ! General to all Symbol Table Entries
    !
	SYM_Class		= [0, B0_],	! Symbol Class
	SYM_Rst_Symid		= [4, L_],	! Debugger Run-Time Symbol Table
						! pointer
	SYM_Previous		= [8, L_],	! Pointer to entry for previous block
	SYM_Thread		= [12, L_],	! Pointer to next entry for current command
	SYM_Name		= [16, L_],	! Pointer to NAMe table entry

    ! Constant Entry
    !
	CON_Type		= [20, L_],	! Constant Type
	CON_Dtype		= [24, L_],	! Constant Data Type
	CON_Next		= [28, L_],	! Constant Next Scalar
	CON_Literal		= [32, L_],	! Constant Literal Value

    ! Variable Entry
    !
	VAR_Type		= [20, L_],	! Variable Type

    ! Types
    !
	STY_Type		= [20, L_],	! Type Data-Set Pointer

    ! Procedures & Functions
    !
	PROC_Func_Type		= [20, L_],	! Type Entry or 0

    ! Field
    !
	WFLD_Type		= [20, L_],	! Type Entry

    ! Reserved Words
    !
	RESW_Redefinable	= [ 0, V_(10)],	! True if Redefinable
	RESW_Token		= [20, L_]	! Token value

    ! Label
    !


    ! Line Number
    !

	TES;

!		T Y P E   D A T A - S E T   E N T R I E S
!
!	Type Data-Set entries describe what the data type of an
!	entity (Variable, Constant, Expression, ...) is, in order
!	to handle type checking, storage allocation, specific
!	instruction types, etc.
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------+---------------+-------------+-+---------------+
!	| TYP_Rst_Class |               |             | |   TYP_Class   |  0
!	+---------------+---------------+-------------+-+---------------+
!	|                          TYP_Symbol                           |  4
!	+---------------------------------------------------------------+
!	|                        TYP_Packed_Size                        |  8
!	+---------------------------------------------------------------+
!	|                         TYP_Full_Size                         |  12
!	+---------------------------------------------------------------+
!
!
! for ARRAY type:
!
!	+---------------------------------------------------------------+
!	|                           ARR_Type                            |  16
!	+---------------------------------------------------------------+
!	|                           ARR_IType                           |  20
!	+---------------------------------------------------------------+
!	|                           ARR_Up_Link                         |  24
!	+---------------------------------------------------------------+
!
!
! for FILE type:
!
!	+---------------------------------------------------------------+
!	|                           FIL_Type                            |  16
!	+---------------------------------------------------------------+
!	|                          FIL_Version                          |  20
!	+---------------------------------------------------------------+

!			TYPE DATA-SET ENTRIES
!
!
! for POINTER type:
!
!	+---------------------------------------------------------------+
!	|                           PTR_Type                            |  16
!	+---------------------------------------------------------------+
!
!
! for SET type:
!
!	+---------------------------------------------------------------+
!	|                           SET_Type                            |  16
!	+---------------------------------------------------------------+
!
!
! for ORDINAL type:
!
!	+---------------------------------------------------------------+
!	|                           ORD_Type                            |  16
!	+---------------------------------------------------------------+
!	|                          ORD_Lower                            |  20
!	+---------------------------------------------------------------+
!	|                          ORD_Upper                            |  24
!	+---------------------------------------------------------------+
!	|                          ORD_DType                            |  28
!	+---------------------------------------------------------------+
!	!                        ORD_Enum_Count                         |  32
!	+---------------------------------------------------------------+
!	|                       ORD_Enum_Element                        |  36
!	+---------------------------------------------------------------+
!
!
! for RECORD type:
!
!	+---------------------------------------------------------------+
!	|                        REC_Fld_Head                           |  16
!	+---------------------------------------------------------------+
!	|                        REC_Var_Head                           |  20
!	+---------------------------------------------------------------+
!	|                        REC_Tag_Head                           |  24
!	+---------------------------------------------------------------+
!	|                        REC_Record                             |  28
!	+---------------------------------------------------------------+
!	|                      REC_Fixed_Fields                         |  32
!	+---------------------------------------------------------------+

!			TYPE DATA-SET ENTRIES
!
!
! for VARIANT record:
!
!	+---------------------------------------------------------------+
!	|                     VAR_Variant_Head                          |  16
!	+---------------------------------------------------------------+
!	|                     VAR_Variant_Tag                           |  20
!	+---------------------------------------------------------------+
!	|                     VAR_Variant_Type                          |  24
!	+---------------------------------------------------------------+
!	|                        VAR_Record                             |  28
!	+---------------------------------------------------------------+
!	|                        VAR_Variant                            |  32
!	+---------------------------------------------------------------+
!	|                     VAR_Variant_Link                          |  36
!	+---------------------------------------------------------------+
!	|                       VAR_Tag_Head                            |  40
!	+---------------------------------------------------------------+
!	|                  VAR_Variant_Fixed_Fields                     |  44
!	+---------------------------------------------------------------+
!
!
! for Variant Tags:
!
!	+---------------------------------------------------------------+
!	|                       VTAG_Constant                           |  0
!	+---------------------------------------------------------------+
!	|                       VTAG_Variant_Link                       |  4
!	+---------------------------------------------------------------+
!	|                       VTAG_Constant_Link                      |  8
!	+---------------------------------------------------------------+
!
!
! for REAL type:
!
!	+---------------------------------------------------------------+
!	|                       REAL_DType                              |  16
!	+---------------------------------------------------------------+
!
!
! for VARYING type:
!
!	+---------------------------------------------------------------+
!	|                          VARY_Type                            |  16
!	+---------------------------------------------------------------+
!	|                          VARY_Bound                           |  20
!	+---------------------------------------------------------------+

LITERAL

	! These are the different valid Types for Type records, and
	! as such are used in the field "TYP_Class" to describe the
	! different types. (Redundant!!!!)
	!
	TYP_K_Error		= 0,		! ERROR in Type
	TYP_K_Array		= 1,		! Array Type
	TYP_K_File		= 4,		! File Type
	TYP_K_Pointer		= 5,		! Pointer Type
	TYP_K_Set		= 6,		! Set Type
	TYP_K_Ordinal		= 7,		! Ordinal Type
	TYP_K_Record		= 8,		! Record Type (-> Field, Variant)
	TYP_K_Variant		= 9,		! Variant of Record
	TYP_K_Real		= 10,		! Real Data Type
	TYP_K_Varying		= 11;		! Varying Data Type

LITERAL
	! Sizes of the various type entries
	!
	TYP_S_Error		= 0,
	TYP_S_Array		= 28,
	TYP_S_File		= 24,
	TYP_S_Pointer		= 20,
	TYP_S_Set		= 20,
	TYP_S_Ordinal		= 40,
	TYP_S_Record		= 36,
	TYP_S_Variant		= 48,
	TYP_S_Variant_Tag	= 12,
	TYP_S_Real		= 20,
	TYP_S_Varying		= 24;

FIELD
    Type_Fields =
	SET
	TYP_Class		= [ 0, B0_],	! Class of Type
	TYP_Packed		= [ 0, V_(8)],	! Packed Indicator
	TYP_Rst_Class		= [ 0, B3_],	! RST Class Code
	TYP_Symbol		= [ 4, L_],	! Pointer to Symbol Table Entry (if any)
	TYP_Packed_Size		= [ 8, L_],	! Bit size in packed record
	TYP_Full_Size		= [12, L_],	! Byte size in unpacked record

    ! Array Type
    !
	ARR_Type		= [16, L_],	! Pointer to TYPe entry for array
	ARR_IType		= [20, L_],	! Pointer to TYPe entry for Index
	ARR_Up_Link		= [24, L_],	! Pointer to TYPe entry for next higher array
						! dimension, or 0 if none
    ! File
    !
	FIL_Type		= [16, L_],	! Type of the FILe
	FIL_Version		= [20, L_],	! Compiler version (1 or 0 currently)

    ! Pointer
    !
	PTR_Type		= [16, L_],	! Type of what the pointer points to

    ! Set
    !
	SET_Type		= [16, L_],	! Pointer to Set Type

    ! Ordinal Type
    !
	ORD_Type		= [16, L_],	! Type field
	ORD_Lower		= [20, L_],	! Lower Bound
	ORD_Upper		= [24, L_],	! Upper Bound
	ORD_DType		= [28, L_],	! Data Type
	ORD_Unsigned		= [28, V_(0)],	! Unsigned (if Integer)
	ORD_Enum_Count		= [32, L_],	! Count of Enumerated Types
	ORD_Enum_Element	= [36, L_],	! Pointer to First Named Constant

    ! Record Type
    !
	REC_Fld_Head		= [16, L_],	! First Field (if any)
	REC_Var_Head		= [20, L_],	! First Variant (if any)
	REC_Tag_Head		= [24, L_],	! First Tag (if any)
	REC_Record		= [28, L_],	! Pointer to containing record, 0 if none
	REC_Fixed_Fields	= [32, L_],	! Pointer to last fixed field

    ! Record Variant
    !
	VAR_Variant_Head	= [16, L_],	! Pointer to 1st Sub-Variant or 0
	VAR_Variant_Tag		= [20, L_],	! Pointer to Tag Field or 0
	VAR_Variant_Type	= [24, L_],	! Pointer to Tag Field Type
	VAR_Record		= [28, L_],	! Pointer to Record
	VAR_Variant		= [32, L_],	! Pointer to Super-Variant or 0
	VAR_Variant_Link	= [36, L_],	! Link to next variant at same level
	VAR_Tag_Head		= [40, L_],	! Pointer to 1st Sub-Variant tag or 0
	VAR_Variant_Fixed_Fields= [44, L_],	! Pointer to last fixed field of the variant

    ! Variant Tag Descriptor
    !
	VTAG_Constant		= [0, L_],	! Tag constant value
	VTAG_Variant_Link	= [4, L_],	! Pointer to Variant for the tag
	VTAG_Constant_Link	= [8, L_],	! Link to next tag at same record level

    ! REAL Type
    !
	REAL_DType		= [16, B0_],	! Floating: F, D, G, H

    ! VARYING Type
    !
	VARY_Type		= [16, L_],	! Pointer to element type
	VARY_Bound		= [20, L_]	! Maximum number of elements
	TES;

!
!		D A T A   T Y P E S
!
!	These data types are used in the Type entries and
!	the trees and polish for the intermediate code
!
LITERAL
	BU_Int		= 1,		! Byte Integer Unsigned
	B_Int		= 2,		! Byte Integer
	WU_Int		= 3,		! Word Integer Unsigned
	W_Int		= 4,		! Word Integer
	LU_Int		= 5,		! Longword Integer Unsigned
	L_Int		= 6,		! Longword Integer
	QU_Int		= 7,		! Quadword Integer Unsigned
	Q_Int		= 8,		! Quadword Integer
	OU_Int		= 9,		! Octaword Integer Unsigned
	O_Int		= 10,		! Octaword Integer

	F_Float		= 11,		! F-floating
	D_Float		= 12,		! D-floating
	G_Float		= 13,		! G-floating
	H_Float		= 14,		! H-floating

	U_Bool		= 15,		! Uncomitted boolean
	B_Bool		= 16,		! Byte boolean
	W_Bool		= 17,		! Word boolean
	L_Bool		= 18,		! Longword boolean

        Last_Dtype	= 18;		! Last Dtype code

!
! Sizes of the Different Data Types
!
LITERAL
	BU_Int_S	= 1,		! Byte Integer Unsigned
	B_Int_S		= 1,		! Byte Integer
	WU_Int_S	= 2,		! Word Integer Unsigned
	W_Int_S		= 2,		! Word Integer
	LU_Int_S	= 4,		! Longword Integer Unsigned
	L_Int_S		= 4,		! Longword Integer
	QU_Int_S	= 8,		! Quadword Integer Unsigned
	Q_Int_S		= 8,		! Quadword Integer
	OU_Int_S	= 16,		! Octaword Integer Unsigned
	O_Int_S		= 16,		! Octaword Integer

	F_Float_S	= 4,		! F-floating
	D_Float_S	= 8,		! D-floating
	G_Float_S	= 8,		! G-floating
	H_Float_S	= 16,		! H-floating

	U_Bool_S	= 4,		! Uncomitted boolean
	B_Bool_S	= 1,		! Byte boolean
	W_Bool_S	= 2,		! Word boolean
	L_Bool_S	= 4,		! Longword boolean

	Max_Dtype_Size	= 16;		! Largest Dtype (currently O_Int / O_IntU / H_Float)

!
! MACROs
!
MACRO
	DType_List=
		BU_Int,  B_Int,   WU_Int,  W_Int,   LU_Int,
		L_Int,   QU_Int,  Q_Int,   OU_Int,  O_Int,
		F_float, D_Float, G_Float, H_Float, U_bool,
		B_Bool,  W_Bool,  L_Bool %;

! Lexical Analysis Phase
!
LITERAL

	! These are the different token types that the Lexical Analyser
	! can return
	!
	LEX_K_Error	= 0,		! Error Token
	LEX_K_Name	= 1,		! Pointer to Name Table
	LEX_K_String	= 2,		! Pointer to String Table
	LEX_K_Integer	= 3,		! Integer (Longword) Value
	LEX_K_Float_F	= 4,		! F-Floating
	LEX_K_Float_D	= 5,		! D-Floating
	LEX_K_Float_G	= 6,		! G Floating
	LEX_K_Float_H	= 7,		! H Floating
	LEX_K_Eof	= 8,		! End of File

	LEX_K_Min	= 1,		! Minimum Value
	LEX_K_Max	= 8,		! Maximum Value

	! Bit values used for string searches within the Lexical Analyser
	!
	LEX_M_Space	= %B'00000001',	! Space, Tab, CR, or Form-Feed
	LEX_M_Binary	= %B'00000010',	! "0" or "1"
	LEX_M_Octal	= %B'00000100',	! "0" - "7"
	LEX_M_Decimal	= %B'00001000',	! "0" - "9"
	LEX_M_Hex	= %B'00010000', ! "0" - "9", "A" - "F", "a" - "f"
	Lex_M_Ident	= %B'00100000',	! "A" - "Z", "a" - "z", "$", "_"

	LEX_Hash_Bucket	= 128,		! Number of Hash Buckets
	LEX_K_Max_Str	= 1024,		! Maximum String Length

	! These entries are used specify the different character types.
	!
	LEX$M_Ident	= 1^0,		! 'Tis an Identifier
	LEX$M_Space	= 1^1,		! A space, tab, or the like
	LEX$M_Hex	= 1^2,		! Hex Value
	LEX$M_Decimal	= 1^3,		! Decimal Value
	LEX$M_Octal	= 1^4,		! Octal Value
	LEX$M_Binary	= 1^5;		! Binary Value

!		SYNTAX ANALYSIS ROUTINES
!
!	These are the tokens that may be returned to the Syntax Analyser
!
LITERAL
	Syn_K_Error		= -1,		! Error Token (all ones)
	Syn_K_Ident		= 0,		! Vanilla Identifier
	Syn_K_String		= 1,		! Quoted String
	Syn_K_Integer		= 2,		! Integer Constant
	Syn_K_Float		= 3,		! Floating Constant
	Syn_K_Eof		= 4,		! End of File

	Syn_K_Assign		= 5,		! :=
	Syn_K_CloseBrkt		= 6,		! ]
	Syn_K_CloseParen	= 7,		! )
	Syn_K_Colon		= 8,		! :
	Syn_K_Comma		= 9,		! ,
	Syn_K_Divide		= 10,		! /
	Syn_K_Equal		= 11,		! =
	Syn_K_Greater		= 12,		! >
	Syn_K_GreatEqual	= 13,		! >=
	Syn_K_Less		= 14,		! <
	Syn_K_LessEqual		= 15,		! <=
	Syn_K_Minus		= 16,		! -
	Syn_K_Multiply		= 17,		! *
	Syn_K_NotEqual		= 18,		! <>
	Syn_K_OpenBrkt		= 19,		! [
	Syn_K_OpenParen		= 20,		! (
	Syn_K_Period		= 21,		! .
	Syn_K_Plus		= 22,		! +
	Syn_K_Semicolon		= 23,		! ;
	Syn_K_Subrange		= 24,		! ..
	Syn_K_UpArrow		= 25,		! ^
	Syn_K_Power		= 26,		! **

	Syn_K_AND		= 27,		! AND
	Syn_K_ARRAY		= 28,		! ARRAY
	Syn_K_BEGIN		= 29,		! BEGIN
	Syn_K_CASE		= 30,		! CASE
	Syn_K_CONST		= 31,		! CONST
	Syn_K_DIV		= 32,		! DIV
	Syn_K_DO		= 33,		! DO
	Syn_K_DOWNTO		= 34,		! DOWNTO
	Syn_K_ELSE		= 35,		! ELSE
	Syn_K_END		= 36,		! END
	Syn_K_FOR		= 37,		! FOR
	Syn_K_FILE		= 38,		! FILE
	Syn_K_FUNCTION		= 39,		! FUNCTION
	Syn_K_GOTO		= 40,		! GOTO
	Syn_K_IF		= 41,		! IF
	Syn_K_IN		= 42,		! IN
	Syn_K_LABEL		= 43,		! LABEL
	Syn_K_MOD		= 44,		! MOD
	Syn_K_MODULE		= 45,		! MODULE
	Syn_K_NOT		= 46,		! NOT
	Syn_K_OF		= 47,		! OF
	Syn_K_OR		= 48,		! OR
	Syn_K_PACKED		= 49,		! PACKED
	Syn_K_PROCEDURE		= 50,		! PROCEDURE
	Syn_K_PROGRAM		= 51,		! PROGRAM
	Syn_K_RECORD		= 52,		! RECORD
	Syn_K_REPEAT		= 53,		! REPEAT
	Syn_K_SET		= 54,		! SET
	Syn_K_THEN		= 55,		! THEN
	Syn_K_TO		= 56,		! TO
	Syn_K_TYPE		= 57,		! TYPE
	Syn_K_UNTIL		= 58,		! UNTIL
	Syn_K_WHILE		= 59,		! WHILE
	Syn_K_WITH		= 60,		! WITH
	Syn_K_VAR		= 61,		! VAR

!	Syn_K_$REF		= 62,		! %REF
!	Syn_K_$DESCR		= 63,		! %DESCR
!	Syn_K_$IMMED		= 64,		! %IMMED
!	Syn_K_$STDESCR		= 65,		! %STDESCR

	Syn_K_EXTERN		= 66,		! EXTERN
	Syn_K_FORTRAN		= 67,		! FORTRAN
	Syn_K_FORWARD		= 68,		! FORWARD
	Syn_K_OTHERWISE		= 69,		! OTHERWISE
	Syn_K_VALUE		= 70,		! VALUE

	Syn_K_$LABEL		= 71,		! %LABEL
	Syn_K_$LINE		= 72,		! %LINE

	Syn_K_Backslash		= 79,		! \

	! WARNING!!!	The following declarations (Syn_K_$R0 thru Syn_K_$PSL)
	!		MUST be in the order given, though not necessarily with
	!		the same numeric values

	Syn_K_$R0		= 80,		! R0
	Syn_K_$R1		= 81,		! R1
	Syn_K_$R2		= 82,		! R2
	Syn_K_$R3		= 83,		! R3
	Syn_K_$R4		= 84,		! R4
	Syn_K_$R5		= 85,		! R5
	Syn_K_$R6		= 86,		! R6
	Syn_K_$R7		= 87,		! R7
	Syn_K_$R8		= 88,		! R8
	Syn_K_$R9		= 89,		! R9
	Syn_K_$R10		= 90,		! R10
	Syn_K_$R11		= 91,		! R11
	Syn_K_$AP		= 92,		! AP
	Syn_K_$FP		= 93,		! FP
	Syn_K_$SP		= 94,		! SP
	Syn_K_$PC		= 95,		! PC
	Syn_K_$PSL		= 96,		! PSL

	Syn_S_Min		= 0,		! Lowest value
	Syn_S_Max		= 96;		! Highest Value

!			E X P R E S S I O N   S T A C K
!
!	This describes the format for the Syntax Analyzer's expression
!	Stack, which is used for evaluating Pascal expressions and primarys
!
!	 3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!	 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!	+---------------------------------------------------------------+
!	|                          EXPR_Type                            |   0
!	+---------------------------------------------------------------+
!	|                        EXPR_Byte_Address                      |   4
!	+---------------------------------------------------------------+
!	|                         EXPR_Bit_Offset                       |   8
!	+---------------------------------------------------------------+
!	|                          EXPR_Value                           |  12
!	|								|
!	|								|  16
!	|								|
!	|								|  20
!	|								|
!	|								|  24
!	+---------------------------------------------------------------+
!
LITERAL
	EXPR_Stack_Depth	= 128,		! Number of Stack Elements
	EXPR_S_Entry		= 28;		! Size of Stack Element

FIELD
    Expression_Stack_Fields =
	SET
	EXPR_Type		= [ 0, L_],	! Pointer to Type Field
	EXPR_Byte_Address	= [ 4, L_],	! Byte Address of Expression Value
	EXPR_Bit_Offset		= [ 8, L_],	! Bit Offset from Byte Address
	EXPR_Value		= [12, L_]	! Value Data
	TES;

!		I N T E R M E D I A T E   O P E R A T I O N S
!
!	Definitions of the operators in the intermediate language executed by
!	the primary and expression interpreters
!
MACRO
    OP_Names =

	!	These values are the classes of intermediate operations
	!
	OP,Proc_Head		,	      ,	! 1 Header block of a PROCEDURE
	OP,Func_Head		,	      ,	! 2 Header block of a FUNCTION
	OP,Symbol		,	      ,	! 3 Refererence to symbol table entry
	OP,Literal_Scalar	,	      ,	! 4 Scalar literal value
	OP,Literal_Structure	,	      ,	! 5 Structured literal reference
	OP,Literal_Set		,	      ,	! 6 Set literal reference
	OP,Value_Scalar		,	      ,	! 7 Scalar CSE value reference
	OP,Value_Set		,	      ,	! 8 Set CSE value reference
	OP,Value_With		,	      ,	! 9 WITH CSE value reference
	OP,Create_Scalar	,	      ,	! 10 Scalar CSE creation
	OP,Create_Set		,	      ,	! 11 Set CSE creation
	OP,Create_With		,	      ,	! 12 WITH selector CSE creation
	OP,Add			,Add	      ,	! 13 Integer addition
	OP,Sub			,Rev_Sub      ,	! 14 Integer subtraction
	OP,Rev_Sub		,Sub	      ,	! 15 Integer reverse subtraction
	OP,Mul			,Mul	      ,	! 16 Integer multiplication
	OP,Div			,Rev_Div      ,	! 17 Integer division
	OP,Rev_Div		,Div	      ,	! 18 Integer reverse division
	OP,Rem			,Rev_Rem      ,	! 19 Integer remainder
	OP,Rev_Rem		,Rem	      ,	! 20 Integer reverse remainder
	OP,Mod			,Rev_Mod      ,	! 21 Integer modulus
	OP,Rev_Mod		,Mod	      ,	! 22 Integer reverse modulus
	OP,Lor			,Lor	      ,	! 23 Logical OR
	OP,Land			,Land	      ,	! 24 Logical AND
	OP,Lxor			,Lxor	      ,	! 25 Logical XOR
	OP,Bic			,Rev_Bic      , ! 26 BIC instruction
	OP,Rev_Bic		,Bic	      ,	! 27 Reverse BIC instruction
	OP,Add_Float		,Add_Float    ,	! 28 Floating addition
	OP,Sub_Float		,Rev_Sub_Float,	! 29 Floating subtraction
	OP,Rev_Sub_Float	,Sub_Float    ,	! 30 Floating reverse subtraction
	OP,Mul_Float		,Mul_Float    ,	! 31 Floating multiplication
	OP,Div_Float		,Rev_Div_Float,	! 32 Floating division
	OP,Rev_Div_Float	,Div_Float    ,	! 33 Floating reverse division
	OP,Eql			,Eql	      ,	! 34 Scalar equality test
	OP,Neq			,Neq	      ,	! 35 Scalar inequality test
	OP,Lss			,Gtr	      ,	! 36 Scalar less than test
	OP,Leq			,Geq	      ,	! 37 Scalar less than or equal test
	OP,Gtr			,Lss	      ,	! 38 Scalar greater than test
	OP,Geq			,Leq	      ,	! 39 Scalar greater than or equal test
	OP,Neg			,	      ,	! 40 Integer negate
	OP,Lnot			,	      ,	! 41 Logical NOT
	OP,Neg_Float		,	      ,	! 42 Floating negate
	OP,Scalar_Convert	,	      ,	! 43 Scalar to Scalar Conversion
	OP,Range_Check		,	      ,	! 44 Scalar range check
	OP,Union		,Union	      ,	! 45 Set union
	OP,Set_Difference	,Rev_Set_Difference,
						! 46 Set difference
	OP,Rev_Set_Difference	,Set_Difference,
						! 47 Set reverse difference
	OP,Intersection		,Intersection ,	! 48 Set intersection
	OP,Set_Eql		,Set_Eql      ,	! 49 Set equality test
	OP,Set_Neq		,Set_Neq      ,	! 50 Set inequality test
	OP,Set_Leq		,Set_Geq      ,	! 51 Set less than or equal test
	OP,Set_Geq		,Set_Leq      ,	! 52 Set greater than or equal test
	OP,In			,	      ,	! 53 IN -- set membership test
	OP,Set_Constructor	,	      ,	! 54 Set constructor
	OP,Set_Range		,	      ,	! 55 Set range constructor
	OP,Set_Element		,	      ,	! 56 Set element constructor
	OP,Str_Eql		,Str_Eql      ,	! 57 String equality test
	OP,Str_Neq		,Str_Neq      ,	! 58 String inequality test
	OP,Str_Lss		,Str_Gtr      ,	! 59 String less than test
	OP,Str_Leq		,Str_Geq      ,	! 60 String less than or equal test
	OP,Str_Gtr		,Str_Lss      ,	! 61 String greater than test
	OP,Str_Geq		,Str_Leq      ,	! 62 String greater then or equal test
	OP,Str_Pad_Eql		,Str_Pad_Eql  ,	! 63 Padded string equality test
	OP,Str_Pad_Neq		,Str_Pad_Neq  ,	! 64 Padded string inequality test
	OP,Str_Pad_Lss		,Str_Pad_Gtr  ,	! 65 Padded string less than test
	OP,Str_Pad_Leq		,Str_Pad_Geq  ,	! 66 Padded string less than or equal test
	OP,Str_Pad_Gtr		,Str_Pad_Lss  ,	! 67 Padded string greater than test
	OP,Str_Pad_Geq		,Str_Pad_Leq  ,	! 68 Padded string greater then or equal test
	OP,Var_Eql		,Var_Eql      ,	! 69 Varying string equality test
	OP,Var_Neq		,Var_Neq      ,	! 70 Varying string inequality test
	OP,Var_Lss		,Var_Gtr      ,	! 71 Varying string less than test
	OP,Var_Leq		,Var_Geq      ,	! 72 Varying string less than or equal test
	OP,Var_Gtr		,Var_Lss      ,	! 73 Varying string greater than test
	OP,Var_Geq		,Var_Leq      ,	! 74 Varying string greater then or equal test
	OP,Arr_Index		,	      ,	! 75 Array index high level addressing
	OP,Rec_Select		,	      ,	! 76 Record field selection high level addressing
	OP,Ptr_Dereference	,	      ,	! 77 Pointer deference high level addressing
	OP,File_Ref		,	      ,	! 78 File buffer reference high level addressing
	OP,File_Ref_In		,	      ,	! 79 File buffer reference for input
	OP,File_Ref_Out		,	      ,	! 80 File buffer reference for output
	OP,Address_P_S		,	      ,	! 81 Position/size low level address
	OP,Fetch		,	      ,	! 82 Scalar fetch
	OP,Fetch_Structure	,	      ,	! 83 Structured fetch
	OP,Fetch_Set		,	      ,	! 84 Set fetch
	OP,Fetch_Varying	,	      ,	! 85 Varying string fetch
	OP,Assign		,	      ,	! 86 Scalar assignment
	OP,Assign_Structure	,	      ,	! 87 Structured assignment
	OP,Assign_Set		,	      ,	! 88 Set assignment
	OP,Assign_Varying	,	      ,	! 89 Varying string assignment
	OP,Void			,	      ,	! 90 Void expression value statement
	OP,If			,	      ,	! 91 IF statement
	OP,Case			,	      ,	! 92 CASE statement
	OP,Case_Element		,	      ,	! 93 Element of CASE statement
	OP,'Repeat'		,	      ,	! 94 REPEAT statement
	OP,While		,	      ,	! 95 WHILE statement
	OP,For_Upto		,	      ,	! 96 FOR statement, UPTO variety
	OP,For_Downto		,	      ,	! 97 FOR statement, DOWNTO variety
	OP,With			,	      ,	! 98 WITH statement list
	OP,Label		,	      ,	! 99 Statement label
	OP,Goto			,	      ,	! 100 GOTO statement
	OP,Proc_Call		,	      ,	! 101 PROCEDURE call
	OP,Func_Scalar		,	      ,	! 102 Scalar FUNCTION call
	OP,Func_Structure	,	      ,	! 103 Structured FUNCTION call
	OP,Func_Set		,	      ,	! 104 Set FUNCTION call
	OP,Parm_Value		,	      ,	! 105 By value semantics (by reference mechanism) parameter
	OP,Parm_Immed		,	      ,	! 106 Immediate value mechanism parameter
	OP,Parm_Descr		,	      ,	! 107 Descriptor mechanism parameter
	OP,New			,	      ,	! 108 NEW pointer variable allocation
	OP,Dispose		,	      ,	! 109 DISPOSE pointer variable deallocation
	OP,Abs			,	      ,	! 110 ABS -- absolute value
	OP,Abs_Float		,	      ,	! 111 Floating absolute value
	OP,Sqr			,	      ,	! 112 SQR -- square
	OP,Odd			,	      ,	! 113 ODD -- odd value test
	OP,Succ			,	      ,	! 114 SUCC -- ordinal successor
	OP,Pred			,	      ,	! 115 PRED -- ordinal predecessor
	OP,Exponentiation	,	      ,	! 116 Exponentiation operator
	OP,Math			,	      	! 117 Math library reference
    %;

MACRO
    DEF_OPS_[prefix, name, reverse_name] =
	%NAME(prefix, '_', name) = %COUNT + 1 %,

    DEF_OP_LITERALS[prefix, name, reverse_name] =
	UPLIT BYTE(%ASCIC %STRING(prefix, '_', name) ) %,

    DEF_REVERSE_OPS[prefix, name, reverse_name] =
	%IF NOT %NULL(reverse_name)
	%THEN %NAME(prefix, '_', reverse_name)
	%ELSE 0
	%FI %;

LITERAL
    DEF_OPS_(OP_Names),
    T_Last_Op		= OP_Math;	! Last operation

!
!		E X T E R N A L   P A S C A L - S P E C I F I C
!			D E F I N I T I O N S
!
!	This module contains Pascal-specific definitions of interest to the
!	entire debugger.
!

REQUIRE 'SRC$:PASDBG.R32';

!
!	PASLIB.R32 LAST LINE
