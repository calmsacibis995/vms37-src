;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
	.page
	.psect	dbg$code,exe,nowrt,long,pic,shr
;
; In order to build the debugger with the pli_print_tree
; routine called, include the following symbol definition:
;
;call_pli_print_tree	=	1
;
; By making this definition, routine plimaktre.mar will
; call this routine to see if the expression tree should
; be output to logical device print$tree. In order
; for the routine to actual do any output, it is necessary
; to deposit a 1 into global symbol print_tree_switch
;
;****later move this macro elsewhere
;+
; define picture control block
;-
	.MACRO $DEFPIC
	$defini pic
$equ	pic$w_pq		0	; p,q
$equ	pic$b_type		2	; type
$equ	pic$b_prog_size		3	; program size
$equ	pic$b_byte_size		4	; size of character string
$equ	pic$b_flags		5	; flags bits
	_vield	pic,0,<-		; 
		<minus,1,m>,-		;
		<t_format,1,m>,-	; t format
		<i_format,1,m>,-	; i format
		<r_format,1,m>,-	; r format
		<has_sign,1,m>,-	; has a sign specifier
		>
$equ	pic$b_language		6	; language of picture program
$equ	pic$c_rt_edit		0	; type is runtime edit
$equ	pic$c_editpc		1	; type is editpc 
$equ	pic$b_spare		7	; spare
$equ	pic$b_program		8	;
	$defend	pic
 
	.mdelete $defpic
	.ENDM	$DEFPIC
	$defpic

; ***********************************************************************
; *		PLI LANGUAGE CONSTANTS					*
; ***********************************************************************
;
;maximum length of pli identifiers
;
pli$k_max_id	= 31
;
;pli default radix
;
pli$k_def_radix = 10			;
;
;maximum number of digits in a fixed decimal number
;
pli$k_fixed_dec_max = 31
;
; ***********************************************************************
; *		PLI DATA TYPE CODES					*
; ***********************************************************************
 ;/* datatype codes */
 ;
pictured_		= 1 ;
fixed_bin_		= 2 ;
float_bin_		= 3 ;
fixed_dec_		= 4 ;
float_dec_		= 5 ;
complex_fixed_bin_	= 6 ;
complex_float_bin_	= 7 ;
complex_fixed_dec_	= 8 ;
complex_float_dec_	= 9 ;
char_			= 10 ;
char_var_		= 11 ;
bit_			= 12 ;
bit_var_		= 13 ;
bit_aligned_		= 14 ;
pointer_		= 15 ;
offset_ 		= 16 ;
area_			= 17 ;
file_			= 18 ;
label_			= 19 ;
entry_			= 20 ;
format_			= 21 ;
dope_			= 22 ;/* this should go away */
data_			= 22 ;/*untyped data -- for constants */
structure_		= 23 ;
bif_			= 24 ;
cond_			= 25 ;
array_			= 27 ;
any_type_		= 28 ;
; ***********************************************************************
; *		   VALUE DESCRIPTOR LAYOUT				*
; ***********************************************************************
;	+-------------------------------+
;	!  lang  !  type !    length    ! 0   <--+
;	+-------------------------------+        ! language independent header
;	!    reserved for future use    ! 4      !
;	+-------------------------------+     <--+
;	!  address of address of source ! 8
;	+-------------------------------+
;	!  data type of source          ! 12
;	+-------------------------------+
;	!  size (p,q) of source         ! 16
;	+-------------------------------+
;	! bit offset of source if nec.  ! 20
;	+-------------------------------+
;	!pointer to data (next longword)! 24
;	+-------------------------------+
;	!  copy of data			! 28
;	+===============================+
pli_vd$a_addr	=	 8		;address of address of source
pli_vd$l_type	=	12		;pli coded type of source
pli_vd$l_size	=	16		;size of source
pli_vd$l_boff	=	20		;optional bit offset of source
pli_vd$a_ptr	=	24		;pointer to the data
pli_vd$k_size	=	28		;size of value descriptor
;
;
;
;
;
; ***********************************************************************
; *		 PRIMARY DESCRIPTOR LAYOUT				*
; ***********************************************************************
;
;	note: all offsets are relative to the start of the primary descriptor
;
;	+-------+-------+---------------+			   ----------
;	! lang	! type	!   length	!  language independent header	^
;	+-------+-------+---------------+				!
;	!       reserved (0)		!  language independent header	!
;	+-------------------------------+			  (fixed size)
;	!  primary descriptor type	!	pli_pd$l_type		!
;	+-------+-------+-------+-------+				v
;	!	tree head node		!	pli_pd$l_head_node ----------
;	+-------------------------------+
;	!	cool tree		!
;		........
;	!				!
;	+-------------------------------+
;
;
pli_pd$l_type		=  	8	;type of primary descriptor
	pli_pd$k_type_hot	=	1	;pd describes a hot tree
	pli_pd$k_type_line	=	2	;pd contains %line information
	pli_pd$k_type_label	=	3	;reference to a label (unused)
	pli_pd$k_type_cool	=	4	;pd describes a cool tree
	pli_pd$k_type_frozen	=	5	;pd describes a frozen tree
	pli_pd$k_type_last	=	5	;last legal type
pli_pd$k_fixed_size		= 12	;size for fixed area of primary desc.
pli_pd$l_head_node		= 12	;head node of cool tree
;
;
;
; ***********************************************************************
; *		stride descriptor layout				*
; ***********************************************************************
;	+-----------------------+
;	!        link		!  0 = pli_sd_link (terminate if address = 0)
;	+-----------------------+   ***warning*** code assumes value is 0
;	! address first byte    !  4 = pli_sd_beg_byte
;	+-----------------------+
;	! bit offset to 1st bit !  8 = pli_sd_beg_bit  (signed longword)
;	+-----------------------+
;	!   number of bytes	! 12 = pli_sd_bytes
;	+-----------------------+
;	!   number of bits      ! 16 = pli_sd_bits
;	+-----------------------+
;				  20 = pli_sd$k_size (size of descriptor)
;   length of stride in bits = (8 * pli_sd_bytes) + pli_sd_bits
;
pli_sd_link	=  0	;***warning*** code assumes value is 0
pli_sd_beg_byte	=  4
pli_sd_beg_bit	=  8
pli_sd_bytes	= 12
pli_sd_bits	= 16
pli_sd$k_size	= 20
;
;
; stride types:
;
;	bit encoding:   3             2              1           0
;		+---------------+-------------+-------------+---------+
;		!   include     ! start addr. !   include   ! maximum !
;		!discontiguities! is control  !   control   ! length  !
;		+---------------+-------------+-------------+---------+
;
;	0	= current data length (no control, start address is data)
;	1	= maximum data length (no control, start address is data)
;	2	= current data length plus conrol (start address is data)
;	3	= maximum data length plus control (start address is data)
;	4	= current data length (no control) start address is control
;	5	= maximum data length (no control) start address is control
;	6	= current data length plus control, start address is control
;	7	= maximum data length plus control, start address is control
;	8 ...
; only class 0 and 7 are currently supported
pli_st$m_maxlen	=  1			;mask - length of data is maximum
pli_st$m_cntrl	=  1@1			;mask - length includes control fields
pli_st$m_addr	=  1@2			;mask - start address at control field
pli_st$m_discon	=  1@3			;mask - length includes skipped areas
;
; ***********************************************************************
; *		PLI EXPRESSION TREE NODES				*
; ***********************************************************************
;pli expression tree node definitions
;
; note: currently we point to the input string passed to make_tree. We
;	could make a copy in the head node or even copy pieces as needed
;	throughout the tree. This will not be done unless the need to do
;	so is clear.
;
;head node
;
;+--------------------------------------+
;!  forward link			!	 0	pli_node_flink
;+--------------------------------------+
;!  backward  link			!	 4	pli_node_blink
;+--------------------------------------+
;!	node type			!	 8	pli_node_type
;+--------------------------------------+
;!	node identifier			!	12	pli_node_ident
;+--------------------------------------+
;! address of substring in input	!	16	pli_node$a_str
;+------------------+-------------------+
;!   reserved       ! length of string  !	20	pli_node$w_sl
;+------------------+-------------------+
;! 	bit flags			!	24	pli_head_node_bits
;+--------------------------------------+
;!     number of nodes in tree		!	28	pli_head_node_count
;+--------------------------------------+
;!			original_verb	!	32	pli_head_node_orig_verb
;+--------------------------------------+
;! fp when call original reference made !	36	pli_head_node_orig_fp
;+--------------------------------------+

;
; pli_head_bits bit definitions
;
;	bit number	meaning when set
;
;		0	tree build terminated with additional input unprocessed
;
;
;
;name node
;
;+--------------------------------------+
;!  forward link			!	 0	pli_node_flink
;+--------------------------------------+
;!  backward  link			!	 4	pli_node_blink
;+--------------------------------------+
;!	node type			!	 8	pli_node_type
;+--------------------------------------+
;!	node identifier			!	12	pli_node_ident
;+--------------------------------------+
;! address of substring in input	!	16	pli_node$a_str
;+------------------+-------------------+
;!   reserved       ! length of string  !	20	pli_node$w_sl
;+------------------+-------------------+
;!	kind				!	24	pli_node_nam_kind
;+--------------------------------------+
;!	symid				!	28	pli_node_nam_symid
;+--------------------------------------+
;!	arguments forward link		!	32	pli_node_nam_arg_fl
;+--------------------------------------+
;!	arguments backward link		!	36	pli_node_nam_arg_bl
;+--------------------------------------+
;!	pointer to pathname vector	!	40	pli_node_nam_pn_ptr
;+--------------------------------------+
;! pointer to (unrelocated) strides	!	44	pli_node_nam_sd1_ptr
;+--------------------------------------+
;! pointer to (unrelocated) strides	!	48	pli_node_nam_sd2_ptr
;+--------------------------------------+
;! pointer to structure descriptors	!	52	pli_node_nam_desc_ptr
;+--------------------------------------+
;! pointer to VD template		!	56	pli_node_nam_vd_ptr
;+--------------------------------------+
;! subscript vector size		!	60	pli_node_nam_vector_size
;+--------------------------------------+
;! pointer to subscript vector		!	64	pli_node_nam_vector
;+--------------------------------------+

;
; structure descriptors
;
;+--------------------------------------+
;!	flink				!	0	pli_struct_desc_flink
;+--------------------------------------+
;!	symid				!	4	pli_struct_desc_symid
;+--------------------------------------+
;!	kind				!	8	pli_struct_desc_kind
;+--------------------------------------+
;!	fcode				!	12	pli_struct_desc_fcode
;+--------------------------------------+
;!	type_id				!	16	pli_struct_desc_typeid
;+--------------------------------------+
;!	valkind				!	20	pli_struct_desc_valkind
;+--------------------------------------+
;!	symval vector - byte value	!	24	pli_struct_desc$l_byte
;+--------------------------------------+
;!	symval vector - bit value	!	28	pli_struct_desc$l_bit
;+--------------------------------------+
;!	symval vector - fp		!	32	pli_struct_desc$l_fp
;+--------------------------------------+
;!	pointer to optional type block	!	36	pli_struct_desc$a_opt
;+--------------------------------------+

;
; structure descriptor optional type block
;
;+--------------------------------------+
;! byte count of this optional block	!	0	pli_struc_opt$b_count
;+--------------------------------------+
;! pointer to array descriptor		!	4	pli_struc_opt$a_desc
;+--------------------------------------+
;! optional argument number 1		!	8	pli_struc_opt$l_arg1
;+--------------------------------------+
;! optional argument number 2		!	12	pli_struc_opt$l_arg2
;+--------------------------------------+
;! optional pointer to another block	!	16	pli_struc_opt$a_cont
;+--------------------------------------+
;
;
;
;
;	fcode		$a_desc		arg1		arg2		cont
;
; dbg$sta_typ_array	dscaddr		celltype	2nd fcode	(yes)
;
; dbg$sta_typ_atomic	0		typecode	-		-
;
; dbg$sta_typ_desc	dscaddr		-		-		-
;
; dbg$sta_typ_pict	0		pictval		-		-
;
; dbg$sta_typ_offset	0		area_id		area_len	-
;
; dbg$sta_typ_area	0		byte_len	-		-
;
;
; No structure descriptor optional block is created for the following fcode
; values (kind code data)
;
; dbg$sta_typ_file	(type routine called to check language)
; dbg$sta_typ_record	(add later when we can examine structures in addition
;			to structure elements)
; dbg$sta_typ_union
;
;
;
;debug special symbol node
;
;+--------------------------------------+
;!  forward link			!	 0	pli_node_flink
;+--------------------------------------+
;!  backward  link			!	 4	pli_node_blink
;+--------------------------------------+
;!	node type			!	 8	pli_node_type
;+--------------------------------------+
;!	node identifier			!	12	pli_node_ident
;+--------------------------------------+
;! address of substring in input	!	16	pli_node$a_str
;+------------------+-------------------+
;!   reserved       ! length of string  !	20	pli_node$w_sl
;+--------------------------------------+
;!	kind				!	24	pli_node_dss_kind
;+--------------------------------------+
;!	symbol code			!	28	pli_node_dss_sym_cod
;+------------------+-------------------+
;!	arguments forward link		!	32	pli_node_dss_arg_fl
;+--------------------------------------+
;!	arguments backward link		!	36	pli_node_dss_arg_bl
;+--------------------------------------+
;!	pointer to pathname vector	!	40	pli_node_dss_pn_ptr
;+--------------------------------------+
;
;
;
;
; debug constant node
;
;
;+--------------------------------------+
;!  forward link			!	 0	pli_node_flink
;+--------------------------------------+
;!  backward  link			!	 4	pli_node_blink
;+--------------------------------------+
;!	node type			!	 8	pli_node_type
;+--------------------------------------+
;!	node identifier			!	12	pli_node_ident
;+--------------------------------------+
;! address of substring in input	!	16	pli_node$a_str
;+------------------+-------------------+
;!   reserved       ! length of string  !	20	pli_node$w_sl
;+------------------+-------------------+
;!	value				!	24	pli_node_dbg_value
;+--------------------------------------+
;!	radix				!	28	pli_node_dbg_radix
;+--------------------------------------+
;
;
;
;
;
; value descriptor node
;
; If the constant 3.14 is entered as a literal in an expression, the
; data type is string, size is 6 (bytes), secondary type is fixed binary,
; and secondary size is [scale = 2, precision = 3]. 
;
; If the constant 'string' is entered, the "address of substring in input"
; value is the address of the character "'", the length of the string
; (pli_node$w_sl) is 8, the data type is string, the size is 6 and the
; secondary type and size is the same as the primary type and size.
;
;
;+--------------------------------------+
;!  forward link			!	 0	pli_node_flink
;+--------------------------------------+
;!  backward  link			!	 4	pli_node_blink
;+--------------------------------------+
;!	node type			!	 8	pli_node_type
;+--------------------------------------+
;!	node identifier			!	12	pli_node_ident
;+--------------------------------------+
;! address of substring in input	!	16	pli_node$a_str
;+------------------+-------------------+
;!   reserved       ! length of string  !	20	pli_node$w_sl
;+------------------+-------------------+
;!   secondary data type		!	24	pli_node_vd_stype
;+--------------------------------------+
;!   secondary size			!	28	pli_node_vd_ssize
;+--------------------------------------+
;!   address of address of source       !	32	pli_node_vd$a_addr
;+--------------------------------------+
;!       data type of source		!	36	pli_node_vd$l_type
;+--------------------------------------+
;!       size (p,q) of source		!	40	pli_node_vd$l_size
;+--------------------------------------+
;!   bit offset of source if necessary	!	44	pli_node_vd$l_boff
;+--------------------------------------+
;! pointer to the actual data		!	48	pli_node_vd$a_data
;+--------------------------------------+
;						52	pli_node$k_vd_size
;
;
;
;operator node (used for arguments and subscripts also)
;
;+--------------------------------------+
;!  forward link			!	 0	pli_node_flink
;+--------------------------------------+
;!  backward  link			!	 4	pli_node_blink
;+--------------------------------------+
;!	node type			!	 8	pli_node_type
;+--------------------------------------+
;!	node identifier			!	12	pli_node_ident
;+--------------------------------------+
;! address of substring in input	!	16	pli_node$a_str
;+------------------+-------------------+
;!   reserved       ! length of string  !	20	pli_node$w_sl
;+------------------+-------------------+
;! operator subtype code		!	24	pli_node_opr_subtype
;+--------------------------------------+
;!	current number of arguments	!	28	pli_node_opr_arg_cur
;+--------------------------------------+
;!	minimum number of arguments	!	32	pli_node_opr_arg_min
;+--------------------------------------+
;!	maximum number of arguments	!	36	pli_node_opr_arg_max
;+--------------------------------------+
;!  forward link to subtree one		!	40	pli_node_opr_sub_fl
;+--------------------------------------+
;!  backward link to subtree one	!	44	pli_node_opr_sub_bl
;+--------------------------------------+
;!           . . .			!		(more subtrees)
;
;


	pli_node_flink=	 0
	pli_node_blink=	 4
	pli_node_type=	 8
	pli_node_ident=	12
	pli_node$a_str=	16
	pli_node$w_sl=20

	pli_head_node_bits=	24
	pli_head_node_count=	28
	pli_head_node_orig_verb=32
; legal values for verbs:
;	dbg$k_first_verb = dbg$k_at_sign_verb
;	dbg$k_at_sign_verb
;	dbg$k_call_verb		(not implemented)
;	dbg$k_cancel_verb
;	dbg$k_define_verb	(not implemented)
;	dbg$k_deposit_verb
;	dbg$k_evaluate_verb
;	dbg$k_examine_verb
;	dbg$k_exit_verb
;	dbg$k_go_verb
;	dbg$k_set_verb
;	dbg$k_show_verb
;	dbg$k_step_verb
;	dbg$k_help_verb
;	dbg$k_last_verb	= dbg$k_help_verb
; note: these values are generally valid except for the symbolize routine that
;	is called as a result of a break (xpoint) after a GO or STEP command
;	was executed.
;
	pli_head_node_orig_fp=  36
	pli_head_node$k_size =	40


	pli_node_nam_kind=	24
	pli_node_nam_symid=	28
	pli_node_nam_arg_fl=	32
	pli_node_nam_arg_bl=	36
	pli_node_nam_pn_ptr=	40
	pli_node_nam_sd1_ptr=	44
	pli_node_nam_sd2_ptr=	48
	pli_node_nam_desc_ptr=	52
	pli_node_nam_vd_ptr=	56
	pli_node_nam_vector_size=60
	pli_node_nam_vector = 	64
	pli_node_nam$k_size =	68
;
; structure descriptors
	pli_struct_desc_flink=	0
	pli_struct_desc_symid=	4
	pli_struct_desc_kind=	8
	pli_struct_desc_fcode=	12
	pli_struct_desc_typeid=	16
	pli_struct_desc_valkind=20
	pli_struct_desc$l_byte=	24	;***warning**** contiguous requirement
	pli_struct_desc$l_bit=	28	;***warning**** contiguous requirement
	pli_struct_desc$l_fp=	32	;***warning**** contiguous requirement
	pli_struct_desc$a_opt=	36
	pli_struct_desc$k_size=	40

; pli structure descriptor optional block (size is variable length)
	pli_struc_opt$b_count =	0
	pli_struc_opt$a_desc  = 4	;(descriptor is copied)
	pli_struc_opt$l_arg1  =	8	;(value copied)
	pli_struc_opt$l_arg2  = 12	;(value copied)
	pli_struc_opt$a_cont  = 16	;(recursive copy)
;
; node - debug special symbol
	pli_node_dss_kind=	24
	pli_node_dss_sym_cod=	28
	pli_node_dss_arg_fl=	32
	pli_node_dss_arg_bl=	36
	pli_node_dss_pn_ptr=	40
	pli_node_dss$k_size =	44


	pli_node_dbg_value=	24
	pli_node_dbg_radix=	28
	pli_node_dbg$k_size =	32

	pli_node_vd_stype=	24
	pli_node_vd_ssize=	28
	pli_node_vd$a_addr=	32
	pli_node_vd$l_type=	36
	pli_node_vd$l_size=	40
	pli_node_vd$l_boff=	44
	pli_node_vd$a_data=	48
	pli_node_vd$k_size=	52

	pli_node_opr_subtype=	24
	pli_node_opr_arg_cur=	28
	pli_node_opr_arg_min=	32
;
;note:	pli_node_opr_arg_max is the maximum number of arguments for the node
;	PLUS any continuation nodes. If the node is itself a continue node,
;	it is the maximum number of arguments for the continue nodes of this
;	node. To see if a particular node is full, use the constant
;	pli_node_opr$k_max_arg.
;
	pli_node_opr_arg_max=	36
	pli_node_opr_sub_fl=	40
	pli_node_opr_sub_bl=	44
;
;note:	some of the code in plimaktre assumes (see ***warning***) that
;	operator nodes that are infix or prefix operators can be held
;	by a single operator node, i.e. they don't have to consider the
;	case of an operator node of this type being continued.
;
	pli_node_opr$k_max_arg = 2
	pli_node_opr$k_min_arg = 1
	pli_node_opr$k_size = pli_node_opr_sub_fl+<8*pli_node_opr$k_max_arg>
;
;
;  node types:
;+--------+---------+----------+--------+
;! mode   !reserved ! sub_type ! type   !
;+--------+---------+----------+--------+
;
;
; processing modes
;	bit 0 - 3 : 0 debug address calculations
;		    1 pli expression with debug extensions
;		    2 c expression with debug extensions
;
;	bit 4	  : 0 normal (right hand side of assignment
;		    1 left hand side of assignment
pli_node_mode$k_dae	=	0	;debug address expression mode
pli_node_mode$k_pli	=	1	;pli expression mode
pli_node_mode$k_c	=	2	;c expression mode
;
;
;
;basic node types (and parse states):
; used by the following routines:
;	pli_print_tree.pli
;	plimaktre.mar
;	ptable.mar
pli_node_type$k_reserv	=	0	;reserved
pli_node_type$k_head	=	1	;head node
pli_node_type$k_namef	=	2	;name node function
pli_node_type$k_named	=	3	;name node data
pli_node_type$k_nameo	=	4	;name node other (routine, module)
pli_node_type$k_opriop	=	5	;operator node - infix or postfix opr
pli_node_type$k_oprnf	=	6	;operator node - named function
pli_node_type$k_oprnd	=	7	;operator node - named data
pli_node_type$k_oprno	=	8	;operator node - named other
pli_node_type$k_oprptr	=	9	;operator node - pointer
pli_node_type$k_oprarg	=	10	;operator node - arguments
pli_node_type$k_oprscr	=	11	;operator node - subscripts
pli_node_type$k_oprlp	=	12	;operator node - left parenthesis
pli_node_type$k_oprcon	=	13	;operator node - continue
pli_node_type$k_plivd	=	14	;pli value descriptor node
pli_node_type$k_dss	=	15	;debug special symbol node
pli_node_type$k_dbgcon	=	16	;debug constant node
;
;the following node types are really parse states that are associated with
;another kind of node type
;
pli_node_type$k_more_oprnd=	17	;state - oprnd node - more name needed
pli_node_type$k_more_oprscr =	18	;state - oprscr node - more subscript
					;			is required
pli_node_type$k_more_oprcon =	19	;state -oprcon node - another operand
					;			is required
pli_node_type$k_last_type =	19	;last valid node type
;
;operator node subtypes - precedence ordered
;
pli_node_opr$k_exponentiation = 105*16	;(binary) **
pli_node_opr$k_unary_plus =	100*16+0;(unary) prefix +
pli_node_opr$k_unary_minus = 	100*16+1;(unary) prefix -	
pli_node_opr$k_not	=	100*16+2;(unary) logical ^
;
;if values are greater than pli_node_opr$k_right_to_left, then if
;two operators have equal precedence, they are evaluated from right to
;left. In other words, the current node becomes the (left if a binary
;operator) operand.
;
pli_node_opr$k_right_to_left =	95*16	;if greater than this value and
					;= precedence, eval. right to left.
pli_node_opr$k_multiply	=	90*16	;(binary) *
pli_node_opr$k_divide	=	85*16	;(binary) /
pli_node_opr$k_binary_plus =	80*16+0	;(binary) +
pli_node_opr$k_binary_minus =	80*16+1	;(binary) -
pli_node_opr$k_concatenate =	75*16	;(binary) !!
pli_node_opr$k_greater_than =	70*16+0	;(binary) logical >
pli_node_opr$k_less_than =	70*16+1	;(binary) logical <
pli_node_opr$k_not_greater_than = 70*16+2 ;(binary) logical ^>
pli_node_opr$k_not_less_than =	70*16+3	;(binary) logical ^<
pli_node_opr$k_equal	=	70*16+4	;(binary) logical =
pli_node_opr$k_not_equal =	70*16+5	;(binary) logical ^=
pli_node_opr$k_less_or_equal =	70*16+6	;(binary) logical <=
pli_node_opr$k_greater_or_equal=70*16+7	;(binary) logical >=
pli_node_opr$k_and	=	65*16	;(binary) logical &
pli_node_opr$k_or	=	60*16	;(binary) logical !
;
;
;
;token types
;
;	call is made as get_token(processing mode)
;
pli_toktyp_err	=	0		; internal coding error
pli_toktyp_null	=	1		; null
pli_toktyp_name	=	2		; name
pli_toktyp_dbgc	=	3		; debug constant (address)
pli_toktyp_plic	=	4		; pli constant (held as a string)
pli_toktyp_oper	=	5		; operator
pli_toktyp_lpar	=	6		; "("
pli_toktyp_rpar	=	7		; ")"
pli_toktyp_ptr	=	8		; "->"
pli_toktyp_dot	=	9		; "."
pli_toktyp_dbgr	=	10		; debug special symbols %r0 ... %psl
pli_toktyp_line	=	11		; %line
pli_toktyp_label =	12		; %label (not used)
pli_toktyp_bs	=	13		; "\"
pli_toktyp_comma =	14		; ","
pli_toktyp_none	=	15		; no token found
pli_toktyp_bad	=	16		; syntax error encountered

pli_toktyp_lasttyp =	16		;highest code for any token type
;
;
;
;
; result is the address of an array of longwords that have the
; following use for each token type. 
;***************
;****warning**** - The calling routine should assume that this routine may
;***************   modify unused result array longwords.
;
;
;pli_toktyp_err		=	0	; internal coding error
;	result array not used
;
;pli_toktyp_null	=	1	; null
;	result array not used, input descriptor zeroed
;
;pli_toktyp_name	=	2	; name
;	result array:	longword	use
;			0		length in bytes of symbol
;			1		address of first character of symbol
;			2		pointer to pathname descriptor (0 if
;					none.
;
;	input descriptor points past name (blanks skipped)
;
;
;pli_toktyp_dbgc	=	3	; debug constant (address)
;	result array:	longword	use
;			0		length in bytes of constant
;			1		address of first character of constant
;			2		value of debug constant (address)
;			3		literal radix override
;					(currently unused)
;
;pli_toktyp_plic	=	4	; pli constant (held as a string)
;	result array:	longword	use
;			0		length in bytes of constant
;			1		address of first character of constant
;			2		pli datatype code
;			3		pli size
;			4		secondary datatype code
;			5		secondary size (precision, scale)
;
;pli_toktyp_oper	=	5	; operator
;	result array:	longword	use
;			0		length in bytes of operatorn
;			1		address of first character of operator
;			2		operator code
;
;pli_toktyp_lpar	=	6	; "("
;
;	result array:	longword	use
;
;			0		address of left parenthesis
;			1		1 (one byte used to hold string)
;
;pli_toktyp_rpar	=	7	; ")"
;	result array:	longword	use
;
;			0		address of right parenthesis
;			1		1 (one byte used to hold string)
;
;pli_toktyp_ptr		=	8	; "->"
;	result array:	longword	use
;
;			0		address of "-" in "->"
;			1		2 (length of string in bytes)
;
;pli_toktyp_dot		=	9	; "."
;	result array:	longword	use
;
;			0		address of "."
;			1		1 (length of string in bytes)
;
;pli_toktyp_dbgr	=	10	; debug special symbols %r0 ... %psl
;	result array:	longword	use
;			0		length in bytes of symbol
;			1		address of first character of symbol
;			2		debug register number code
;			3		pathname vector (or 0 if none)
;
;pli_toktyp_line	=	11	; %line
;	result array:	longword	use
;
;			0		length in bytes of symbol
;			1		address of first character of symbol
;			2		pointer  to pathname vector
;
;pli_toktyp_label	=	12	; %label (not used)
;	result array:	longword	use
;			0		length in bytes of symbol
;			1		address of first character of symbol
;			2		pointer  to pathname vector
;
;pli_toktyp_bs		=	13	; "\"
;	result array:	longword	use
;			0		length of symbol (value = 1)
;			1		address of backslash
;
;pli_toktyp_comma	=	14	; ","
;	result array:	longword	use
;			0		length in bytes of symbol (value = 1)
;			1		address of comma
;
;pli_toktyp_none	=	15	; no token found, line not empty
;	result array is not used
;	input descriptor is updated to point to 1st non-blank on line. This
;	non-blank can not be CR (return pli_toktyp_null in this case).
;
;pli_toktyp_bad		=	16	; syntax error encountered
;	result array:	longword	use
;			0		length in bytes of offending syntax
;			1		address of first byte of offending str.
;			2		address of formatted message vector
;
;
;
;	result array offset definitions:
;
;
;***************
;****warning**** - the meaning of the first two longwords in the result
;***************   array is fixed with respect to meaning and order. This
;		   is wired into the code, e.g. movq r0,@ap_result(ap) and
;	  	   should never ever be changed.
pli_tokr$l_0	=	0		;always length of token in input string
pli_tokr$l_1	=	4		;always address of 1st char. of token
pli_tokr$l_2	=	8		;
pli_tokr$l_3	=	12		;
pli_tokr$l_4	=	16		;
pli_tokr$l_5	=	20		;	
pli_tokr$k_size = 	24		;
;	result array:	longword	use
;			0		length in bytes of syntactically
;					correct characters.
;
;
;			1		address of first character that starts
;					the string of syntactically correct
;					characters.
;
;
;
;
;
;
; parse expression action codes
;
; pea_ok	expression tree completed
;
; pea_never	if this occurs, then an internal coding error exists
;
; pea_null	no input, no tree
;
; pea_warning	tree (possibly null) completed and a warning return should
;		be made to debug address interpreter
;
; pea_error	null tree, unknown symbol detected immediately
;
; pea_severe	syntax error detected
;
; pea_severe_msg syntax error detected by gettoken. Result vector contains
;		appropriate message vector
;
; pea_pop	Go up tree looking for left parenthesis. If we do not extend
;		our syntax to allow %debug_expression(...) and if mode is debug
;		address expression, then this should fail and
;		we simply give a warning return.
;
;		Result vector returned with pli_toktyp_rpar.
;
; pea_comma	Comma encountered, pop to operator-argument or operator-
;		subscript node. If already there, enter null argument (if
;		subscript and already there then comma is illegal). If no
;		operator node found and mode is debug_address_expression, then
;		return warning. If no operator node and mode is not
;		debug_address_expression then return severe error.
;
;		Result vector returned with pli_toktyp_comma.
;
; pea_ptr	create operator node for pointer. This involves looking back
;		up the tree for another pointer, perhaps reaching head, another
;		mode, or another operator.
;
;		Result vector returned with pli_toktyp_ptr.
;
; pea_subscript	create operator node for subscripts. Mode change possible.
;
; pea_argument	create operator node for arguments. Mode change possible.
;
; pea_first_id	create name operator and name node. This is the first possible
;		identifier in a name.
;
;		Result vector returned with pli_toktyp_name.
;
; pea_more_id	Change more_oprnd node to oprnd. Put name into tree.
;		Result vector returned with pli_toktyp_name.
;
; pea_name_dot	Result vector not used. We have a dot after a name so more
;		of the name is expected. Change the oprnd node to
;		more_oprnd and continue parse.
;		
; pea_prefix	create operator node for prefix operator
;
;		Result vector returned with pli_toktyp_oper.
;
; pea_infix	create operator node for  infix operator
;
;		Result vector returned with pli_toktyp_oper.
;
; pea_plivd	create pli value descriptor
;
;		Result vector returned with pli_toktyp_plic.
;
; pea_dss	create debug special symbol node
;
;		Result vector returned with pli_toktyp_dbgr.
;
; pea_dbg_line	debug symbol %line encountered
;
;		Result vector returned with pli_toktyp_line.
;
; pea_dbg_bs	debug special symbol "\" (last value symbol) encountered
;
;		Result vector returned with pli_toktyp_bs.
;
; pea_dbgcon	create debug constant node
;
;		Result vector returned with pli_toktyp_dbgc.
;
; pea_push	create operator node - lpar
;
;		Result vector returned with pli_toktyp_lpar.
;
; pea_err_ptr	pointer argument error. If mode is debug expression interpreter
;		then an attempt is made to back up, the hope being that the
;		preceding is valid and we can return with a warning return
;		indicating that the pointer might be known to the debug
;		expression interpreter.
; pea_err_fun	pop (if necessary) to nearest function and report severe
;		error. If pruning the function from the tree leaves a valid
;		tree and if mode is debug_address_expression, then return
;		with return warning. Otherwise return is always severe.
;
; pea_err_mis_rp severe error. Missing right parenthesis.
;
; pea_err_var	Pop to operator-named data (if necessary) and report error
;		in input after the identifier. Severe error occured unless
;		mode is debug_address_expression and the pruned tree is valid.
;
; pea_err_token Invalid return from get_token. This means that the get_token
;		routine determined that a syntax error exists and get_token
;		will supply the address of the illegal character in the input
;		stream.
;
; pea_err_more_name An identifier was specified but more of the name is
;		required. The result vector points to the current token
;		be scanned. The usual procedure is to use the current
;		named node to determine the name string to this point in
;		printing out an error message
;
; pea_err_more_scr Either the start of a subscript list or a comma within
;		a subscript list has been encountered and the next token
;		did not result in anything that could be a subscript, i.e.
;		it was not the start of a valid pli expression. Thus an
;		syntax error is present.
;
; pea_err_more_operand The current mode is oprcon, that is, an operator
;		continue node (such as a continue operand for a subscript)
;		and it has been determined that an error has occured because
;		an operand is required and the next token can't be used as
;		the start of a pli expression. In order to determine the
;		proper error message, use the subtype field to determine
;		the kind of operator this continue operator continues.
;
; pea_need_scr_got_id Current node is more_oprscr and an identifier
;		has been encountered. Change current node to oprscr
;		then goto action_first_id
;
; pea_need_scr_got_dbgc Current node is more_oprscr and a debug constant
;		has been encountered. Change current node to oprscr
;		then goto action_dbgcon
;
; pea_need_scr_got_plic Current node is more_oprscr and a pli constant
;		has been encountered. Change current node to oprscr
;		then goto action_plivd
;
; pea_need_scr_got_dbgr Current node is more_oprscr and a debug register
;		has been encountered. Change current node to oprscr
;		then goto action_dss
;
; pea_need_scr_got_bs Current node is more_oprscr and a backspace
;		has been encountered. Change current node to oprscr
;		then goto action_dbg_bs
;
; pea_need_scr_got_oper Current node is more_oprscr and an operator
;		has been encountered. Change current node to oprscr
;		then goto action_prefix
;
; pea_need_scr_got_lpar Current node is more_oprscr and a left parenthesis
;		has been encountered. Change current node to oprscr
;		then goto action_push
;		
; pea_need_operand_got_id Current node is more_oprcon and an identifier
;		has been encountered. Change current node to oprcon
;		then goto action_first_id
;
; pea_need_operand_got_dbgc Current node is more_oprcon and a debug constant
;		has been encountered. Change current node to oprcon
;		then goto action_dbgcon
;
; pea_need_operand_got_plic Current node is more_oprcon and a pli constant
;		has been encountered. Change current node to oprcon
;		then goto action_plivd
;
; pea_need_operand_got_dbgr Current node is more_oprcon and a debug register
;		has been encountered. Change current node to oprcon
;		then goto action_dss
;
; pea_need_operand_got_bs Current node is more_oprcon and a backspace
;		has been encountered. Change current node to oprcon
;		then goto action_dbg_bs
;
; pea_need_operand_got_lpar Current node is more_oprcon and a left parenthesis
;		has been encountered. Change current node to oprcon
;		then goto action_push
;
; pea_continue	Current node is oprcon. To determine action, find
;		the node type of the parent operator and go through
;		case table again. Note that this means in some cases
;		that to complete an action, the action routine must
;		differentiate between real operators and their continuations.
;
pea_ok		=	1		;tree completed
pea_never	=	2		;internal coding error
pea_null	=	3		;no input, no tree
pea_warning	=	4		;tree (possibly null), warning ret
pea_error	=	5		;null tree, unknown error immediately
pea_severe	=	6		;syntax error detected
pea_err_token	=	7		;syntax error from gettoken
pea_pop		=	8		;up tree for left parenthesis
pea_comma	=	9		;comma encountered
pea_ptr		=	10		;pointer encountered
pea_subscript	=	11		;subscripts (possible mode change)
pea_argument	=	12		;arguments (possible mode change)
pea_first_id	=	13		;first identifier in a name
pea_more_id	=	14		;identifiers in a name after the first
pea_prefix	=	15		;prefix operator encountered
pea_infix	=	16		;infix operator encountered
pea_dss		=	17		;debug special symbol encountered
pea_plivd	=	18		;pli value descriptor
pea_dbgcon	=	19		;debug constant (address)
pea_push	=	20		;left parenthesis encountered
pea_err_ptr	=	21		;error - pointer
pea_err_fun	=	22		;error - function
pea_err_mis_rp	=	23		;error - missing right parenthesis
pea_err_var	=	24		;error - variable name
pea_dbg_line	=	25		;debug special symbol %line encountered
pea_dbg_bs	=	26		;debug special symbol "\" encountered
pea_name_dot	=	27		;dot following name encountered
pea_err_more_name =	28		;error - more name is required
pea_severe_msg	=	29		;severe error, result vector has msg
pea_err_more_scr=	30		;error - a subscript is required
pea_err_more_operand =	31		;error - an operand is required
					;(oprcon node, state=more)
pea_need_scr_got_id =	32		;need subscript, got identifier
pea_need_scr_got_dbgc =	33		;need subscript, to debug constant
pea_need_scr_got_plic = 34		;need subscript, got pli constant
pea_need_scr_got_dbgr = 35		;need subscript, got debug register
pea_need_scr_got_bs =	36		;need subscript, got back space
pea_need_scr_got_oper = 37		;need subscript, got operator
pea_need_scr_got_lpar =	38		;need subscript, got left parenthesis
pea_need_operand_got_lpar=39		;need operand, got left parenthesis
pea_need_operand_got_id=40		;need operand, got identifier
pea_need_operand_got_dbgc=41		;need operand, got debug constant
pea_need_operand_got_plic=42		;need operand, got pli constant
pea_need_operand_got_dbgr=43		;need operand, got debug register
pea_need_operand_got_bs  =44		;need operand, got back space
pea_continue	=	45		;oprcon is current node
pea_last_code	=	45		;last parse expression action code
;
; decision matrix for expression parsing
;
;This decision matrix is set up for the parsing at a level just above that
;provided by the get_token(mode) routine. The idea here is to provide a  parse
;with minimal knowledge about semantics. The parse should allow for  debug
;address expression syntax changes in such a way that little or no  changes are
;required in the decision matrix. This  is why there are so very few syntax
;error returns if the mode is debug  address expression. We want the debug
;address expression interpreter to  always have a chance to interprete the
;expression, even though we know that  the expression is presently ( or even
;most certainly always) in error. For  example, if we encounter (in debug
;address expression mode) the string  %r0 -> we collect the %r0 and upon
;reaching the -> we point to the - and  return with a warning return. The
;expression interpreter calls us again with  the -> and we return immediately
;with an error return. If debug address  expression syntax was changed to
;accept this, then it could handle it as  part of this procedure or we could be
;given more syntax information and handle it as part of an action. In the
;latter case we would create a  debug specific operator of whatever the -> was
;to mean and most likely  manipulate the tree instead of doing anything in the
;action routine. 
;
;Names (functions, symbolic references to data) are always pointed to by
;operator nodes. If we see "abc", the following characters could be such that
;we are to parse "abc.def" or "abc(x)" so we always point to the operator node
;for names until the next token is obtained. If the token is a left parenthesis
;we go down to the name node in the process of executing the action routine to
;create an operator node for the subscripts or the arguments. This means that
;we are never pointing to name nodes when using this matrix to determine the
;action routines to execute.
;
;Currently the action routine pea_first_id determines a names type. The
;assumption is that no look ahead is needed to determine the type (this
;is currently true of pli). If this changes (or languages added for which
;this is not true), then there are several alternative approaches that fit
;within the tree structure being defined. One could
;	1) create a new name node type that causes look back and fill in
;	  when the next token is parsed.
;	2) we can use look-ahead in the action routine to determine the type
;My own preference is for the 1st approach since:
;		a) we don't hide syntax in the action routine
;		b) look back uses a structure that is easy to manipulate
;		c) error recovery would probably be neater
;
;NOTE: we are never looking at name nodes when we do the
;parsing. 
;
;NOTE: if continue nodes are created, we stay at the continue node and
;	when done with that operator, pop back up through the originating
;	operator node. This is a change from the way it was once handled.
;	It is more efficient this way and by propogating the proper value
;	for max_arg, we can determine while parsing if the number of
;	arguments have been exceeded. For those nodes that have an
;	unlimited number of arguments, we always fill in pli_omega_max_arg
;	as the value at each level
pli_omega_max_arg = 2147483647		;infinite number of arguments allowed

