MODULE RSTACCESS (IDENT = 'V03-000') =

BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! WRITTEN BY
!	Bert Beander	June, 1980.
!
! MODULE FUNCTION
!	This module contains most of the Symbol Table Access routines (except
!	for the type routines in module RSTTYPES) that the language-specific
!	routines call to look up symbols in the Debug Symbol Table and to
!	extract symbol table information about those symbols.
!

REQUIRE 'SRC$:DBGPROLOG.REQ';

FORWARD ROUTINE
    DBG$ADDRESS_STRING,			! Returns ASCII encoding of an address
    DBG$GST_TO_RST,			! Create RST entry for a global symbol
    DBG$IS_IT_ENTRY,			! See if an address is an entry point
    DBG$RST_SHOWSCOPE:	NOVALUE,	! Handle the SHOW SCOPE command
    DBG$RST_TEMP_RELEASE: NOVALUE,	! Release all temporary RST entries
					!      which are not locked
    DBG$STA_GETSOURCEMOD,		! Get Module RST pointer to use for
					!      source line display
    DBG$STA_GETSYMBOL:	NOVALUE,	! Convert pathname to a symbol
    DBG$STA_GETSYMOFF:	NOVALUE,	! Convert address to symbol and offset
    DBG$STA_LOCK_SYMID:	NOVALUE,	! Lock an RST entry in RST memory
    DBG$STA_LOOKUP_GBL,			! Look up a symbol in the image's Global
					!      Symbol Table (the GST)
    DBG$STA_NOEVALBIT,			! See if the NOEVAL bit is set in a
					!      symbol's value spec.
    DBG$STA_RECORD_COMPONENT,		! Returns SYMID of N-th record component
    DBG$STA_RECORD_INDEX,		! Returns index of a record component
    DBG$STA_SAME_DST_OBJECT,		! See if two SYMIDs refer to same DST
    DBG$STA_SETCONTEXT:	NOVALUE,	! Set up context for value evaluation
    DBG$STA_SETREGISTERS: NOVALUE,	! Set register values back in save areas
    DBG$STA_SYMID_IN_FRAME,		! See if symbol is in a specified frame
    DBG$STA_SYMKIND:	NOVALUE,	! Get a symbol's kind
    DBG$STA_SYMNAME:	NOVALUE,	! Get a symbol's name
    DBG$STA_SYMPARENT,			! Get parent SYMID for a data component
    DBG$STA_SYMPATHNAME: NOVALUE,	! Get a symbol's full pathname
    DBG$STA_SYMVALUE:	NOVALUE,	! Get a symbol's value or address
    DBG$STA_UNLOCK_SYMID: NOVALUE,	! Unlock an RST entry lock in RST memory
    DBG$STA_VALSPEC:	NOVALUE,	! Evaluate a DST Value Spec
    DBG$TRANS_TO_REGNAME,		! Translates address of register
    ADD_TO_REF_COUNT:	NOVALUE,	! Increment or decrement RST entry ref-
					!      erence count
    BUILD_INVOC_RST,			! Build Invocation Number RST Entry
    EVAL_MAT_SPEC:	NOVALUE,	! Evaluate a Materialization Spec
    FOLLOW_STATIC_LINK,			! Follow static links through call stack
					!      for up-level addressing
    LINE_NUM_RST,			! Build a Line Number RST Entry
    NUMBERED_SCOPE:	NOVALUE,	! Find "numbered" scope from PC in stack
    SCOPE_RULE_COBOL,			! Select candidate symbol using COBOL
					!      scope rules
    SCOPE_RULE_NORMAL,			! Select candidate symbol using "normal"
					!      scope rules
    SCOPE_RULE_PLI,			! Select candidate symbol using PL/I
					!      scope rules
    STACK_MACHINE:	NOVALUE,	! Value Spec stack machine interpreter
    VALSPEC_ERROR_HANDLER,		! Error handler for DBG$STA_VALSPEC
    VALSPEC_SCOPE_ERROR: NOVALUE,	! Value Spec scope error routine
    VALSPEC_ROUT_CALL:	NOVALUE;	! Do routine call on a compiler-supplied
					!      routine for Value Spec evaluation

EXTERNAL ROUTINE
    DBG$COPY_MEMORY,			! Create a new copy of a memory block
    DBG$FAO_PUT:	NOVALUE,	! Output some ASCII text
    DBG$GET_DST_NAME,			! Get the ASCII name from a DST record
    DBG$GET_MEMORY,			! Get a permanent memory block
    DBG$GET_NXT_GST,			! Scan the global symbol table
    DBG$GET_TEMPMEM,			! Get a "temporary" memory block
    DBG$HASH_FIND,			! Find a name in the RST hash table
    DBG$HASH_FIND_SETUP:NOVALUE,	! Set up calls on HASH_FIND routine
    DBG$HASH_INSERT:	NOVALUE,	! Insert an RST entry in hash table
    DBG$LINE_TO_PC_LOOKUP,		! Look up the PC for a given line number
    DBG$NGET_RADIX,			! Returns present radix
    DBG$NGET_TRANS_RADIX,		! Returns translation of default radix
    DBG$NPATHDESC_TO_CS:NOVALUE,	! Generate pathname ASCII string from a
					!      pathname descriptor
    DBG$OUT_PUT:	NOVALUE,	! Flush the DBG$FAO_PUT output buffer
    DBG$PC_TO_LINE_LOOKUP,		! Look up a line number given a PC addr
    DBG$REL_MEMORY:	NOVALUE,	! Release a memory block to memory pool
    DBG$RST_BUILD:	NOVALUE,	! Build the RST for a specified module
    DBG$RST_MOST_RECENT:NOVALUE,	! Mark a module as being the Most
					!      Recently Referenced module
    DBG$STA_SYMTYPE :   NOVALUE,	! Get TYPE of Data Item
    DBG$STA_TYP_ARRAY : NOVALUE,	! Return information about arrays
    SYS$FAO: ADDRESSING_MODE (ABSOLUTE);! System service for formatting output

EXTERNAL
    DBG$CP_OUT_STR,			! Buffer pointer used by DBG$FAO_PUT
    DBG$FINAL_HANDL,			! Call frame exception handler--used
					!      searching for a numeric scope
    DBG$GB_LANGUAGE: BYTE,		! The currently SET language code
    DBG$GB_NO_GLOBALS: BYTE,		! Number of global symbols in the GST
    DBG$GB_VERB	: BYTE,			! Holds command verb
    DBG$GL_BUF_SIZ,			! Buffer length used by DBG$FAO_PUT
    DBG$GL_CMND_RADIX,			! Radix to use for EXAMINE
    DBG$GL_RUNFRAME: REF BLOCK[,BYTE],	! The current user run frame
    DBG$PSEUDO_EXIT,			! Point to which CALL command CALL re-
					!      turns--used to find numeric scope
    DST$BEGIN_ADDR,			! Virtual address where the DST begins
    DST$END_ADDR,			! Virtual address of last byte of DST
    GST$BEGIN_ADDR,			! Virtual address where the GST (Global
					!      Symbol Table) begins
    GST$REC_COUNT,			! Number of records in the GST
    LRUM$MOST_RECENT,			! Pointer to the RST entry of the Most
					!      Recently Referenced module
    RST$REF_LIST: REF VECTOR[,LONG],	! Pointer to list of RST entries refer-
					!      enced by current Debug command
    RST$TEMP_LIST,			! Pointer to Temporary RST Entry List
    DBG$REG_VALUES: VECTOR[,LONG],	! Vector of user register values in the
					!      current context
    DBG$REG_VECTOR: VECTOR[,LONG],	! Vector of pointers to user register
					!      save locations in current context
    RST$SET_SCOPE,			! Set if called from DBG$RST_SETSCOPE
    RST$START_ADDR: REF RST$ENTRY,	! Pointer to first Module RST Entry
    SAT$START_ADDR,			! Address of first Static Address Table
					!      (SAT) entry on Program SAT chain
    SCOPE$LIST;				! Pointer to first Scope List entry

OWN
    DBG$REG_SCOPE: INITIAL(0),		! Numeric scope for context register
    DBG$REG_SYMID: INITIAL(0),		! SYMID used to set the current context
    SPECIAL_SCOPE;			! Points to special scope to be searched
					!      by DBG$STA_GETSYMBOL--used only
					!      for data components of a type


! Field definitions and declaration macro for the "candidate block" block-vector
! used by DBG$STA_GETSYMBOL and the SCOPE_RULE_xxx routines.
!
FIELD CAND_FLD_DEF =
    SET
    CAND_RSTPTR	= [ 0, L_ ],		! Pointer to symbol's RST entry
    CAND_PINDEX	= [ 1, L_ ]		! Pathname vector index + 1 for symbol
    TES;

LITERAL
    CAND_ENTSIZ	= 2;			! Longword size of a candidate entry

MACRO
    CAND_BLOCKVECTOR = BLOCKVECTOR[,CAND_ENTSIZ,LONG] FIELD(CAND_FLD_DEF) %;


GLOBAL ROUTINE DBG$ADDRESS_STRING (ADDRESS_DESC) =
!
! FUNCTION
!	This routine accepts an address descriptor and converts the contained
!	virtual address (within the address descriptor), ignoring offset, to a
!	counted ASCII string, the address of which is returned as the routine
!	value. If the address is in the Debugger's register save area, the
!	corresponding register name is returned in the counted string. Otherwise,
!	the address is returned as a numeric string in the proper radix. If a
!	register name is returned, it is preceded by the corresponding scope
!	number, for example, '2\%R5' for register R5 in the scope two call frames
!	down in the stack. For the top call frame, the scope number is zero. The
!	scope number is determined by the last call to DBG$STA_SETCONTEXT.
!
!	This routine gets the current scope number from the global symbol
!	DBG$REG_SCOPE which set up by DBG$STA_SETCONTEXT.  It also uses the
!	global symbols DBG$GB_VERB (which points to the current command being
!	processed) and DBG$GL_CMND_RADIX (the radix in effct for an EXAMINE\
!	command) to determine the appropriate radix to use.
!
! INPUTS
!	ADDRESS_DESC	- A longword containing the address of an address
!			  descriptor of a VAX virtual address.
!
! OUTPUTS
!	The address of a counted ASCII string representing the input address
!		  is returned as the routine value.
!

    BEGIN

    MAP
	ADDRESS_DESC: REF DBG$ADDRESS_DESC;  ! Pointer to input address descr.

    LOCAL
	RADIX,				! Radix to use for output
	CONTROL_DESC: BLOCK [8,BYTE],	! $FAO control block
	FAO_LENGTH: WORD,		! $FAO output length
	OUTPUT_DESC: BLOCK [8,BYTE],	! Output descriptor
	OUTPUT_BUFFER: REF VECTOR [,BYTE];  ! Output buffer



    ! Check to see if address can be resymbolized to a register.
    !
    IF DBG$TRANS_TO_REGNAME (.ADDRESS_DESC [DBG$L_ADDRESS_BYTE_ADDR], 
			     OUTPUT_BUFFER)
    THEN
	RETURN .OUTPUT_BUFFER;


    ! Register resymbolization not possible. Check to determine what radix to
    ! use and set up for FAO call.
    !
    IF .DBG$GB_VERB EQL DBG$K_EXAMINE_VERB
    THEN
	RADIX = .DBG$GL_CMND_RADIX

    ELSE
	RADIX = DBG$NGET_TRANS_RADIX(DBG$NGET_RADIX());

    CONTROL_DESC [DSC$A_POINTER] = (
	CASE .RADIX FROM DBG$K_DEFAULT TO DBG$K_HEX OF
	    SET


	    ! Octal radix.  Edit the address into ASCII octal.
	    !
	    [DBG$K_OCTAL]:
		BEGIN
		CONTROL_DESC [DSC$W_LENGTH] = %CHARCOUNT ('!OL');
		UPLIT BYTE ('!OL')
		END;


	    ! Hexadecimal radix.  Edit the address into hexadecimal.
	    !
	    [DBG$K_HEX]:
		BEGIN
		CONTROL_DESC [DSC$W_LENGTH] = %CHARCOUNT ('!XL');
		UPLIT BYTE ('!XL')
		END;


	    ! Use decimal radix for all other cases.  Edit the address into
	    ! decimal ASCII.
	    !
	    [INRANGE, OUTRANGE]:
		BEGIN
		CONTROL_DESC [DSC$W_LENGTH] = %CHARCOUNT ('!UL');
		UPLIT BYTE ('!UL')
		END;

	    TES);


    ! Get some storage for the string.
    !
    OUTPUT_BUFFER = DBG$GET_TEMPMEM(5);


    ! Call $FAO to do the formatting.
    !
    OUTPUT_DESC [DSC$W_LENGTH] = (5 * %UPVAL) - 2;
    OUTPUT_DESC [DSC$A_POINTER] = OUTPUT_BUFFER [2];
    IF NOT SYS$FAO (CONTROL_DESC,
	            FAO_LENGTH,
		    OUTPUT_DESC,
	            .ADDRESS_DESC [DBG$L_ADDRESS_BYTE_ADDR])
    THEN
	SIGNAL (DBG$_DEBUGBUG, 1, DBG$K_SYS$FAOL_BADPARAM);


    ! The string is formatted, but we want to insert a leading '0' for HEX
    ! When the first character is ABCDE or F.
    !
    IF .RADIX EQL DBG$K_HEX
    THEN
	BEGIN
	IF .OUTPUT_BUFFER [2] GTR '9'
	THEN
	    BEGIN
	    OUTPUT_BUFFER [1] = '0';
	    OUTPUT_BUFFER [0] = .FAO_LENGTH + 1;
	    RETURN OUTPUT_BUFFER [0];
	    END;

	END;


    ! Just return what $FAO formatted.
    !
    OUTPUT_BUFFER [1] = .FAO_LENGTH;
    RETURN OUTPUT_BUFFER [1];

    END;

GLOBAL ROUTINE DBG$GST_TO_RST(NAMEPTR, VALUE, ROUTINE_FLAG) =
!
! FUNCTION
!	This routine accepts the characteristics of a global symbol as input
!	and returns a Run-Time Symbol Table (RST) pointer for that symbol.
!	The global symbol has normally been looked up in the Global Symbol
!	Table (GST), and its name, value, and routine flag has been extracted
!	from the GST entry.  This routine is then called to convert that infor-
!	mation to the corresponding RST pointer.  A new RST
!	entry is constructed, added to the anonymous module's symbol chain,
!	and added to the RST Hash Table.  In addition, a "dummy" DST entry is
!	created for the symbol so that other symbol table access routines do
!	not have to make a special case of global symbols--these symbols seem
!	to have perfectly normal DST entries like all others.  The DST entry is
!	created in the same memory block as the RST entry.
!
! INPUTS
!	NAMEPTR	- A pointer to the global symbol's name, represented as a
!		  Counted ASCII string.
!
!	VALUE	- The value (i.e., address) of the global symbol.
!
!	ROUTINE_FLAG - A flag set to TRUE if the global symbol is a routine
!		  name.  If this flag is FALSE, the symbol is assumed to be
!		  a data symbol.
!
! OUTPUTS
!	A pointer to the global symbol's RST entry is returned as the routine's
!		  value.
!

    BEGIN

    MAP
	NAMEPTR: REF VECTOR[,BYTE];	! Pointer to Counted ASCII name of the
					!      global symbol

    LOCAL
	DSTPTR: REF DST$RECORD,		! Pointer to the dummy DST record we
					!      build for the global symbol
	MODRSTPTR: REF RST$ENTRY,	! Pointer to anonymous module RST entry
	RSTPTR: REF RST$ENTRY;		! Pointer to the RST entry we construct
					!      for the global symbol



    ! The global symbol is not yet in the RST.  If it is a routine name, con-
    ! struct a Routine RST Entry and a corresponding dummy DST record for it.
    !
    IF .ROUTINE_FLAG
    THEN
	BEGIN
	RSTPTR = DBG$GET_MEMORY(RST$K_ROUTENTSIZ + (11 + .NAMEPTR[0])/4);

	DSTPTR = .RSTPTR + 4*RST$K_ROUTENTSIZ;
	RSTPTR[RST$B_KIND] = RST$K_ROUTINE;
	RSTPTR[RST$L_STARTADDR] = .VALUE;
	RSTPTR[RST$L_ENDADDR] = .VALUE;
	DSTPTR[DST$B_LENGTH] = 7 + .NAMEPTR[0];
	DSTPTR[DST$B_TYPE] = DST$K_RTNBEG;
	DSTPTR[DST$V_RTNBEG_UNUSED] = 0;
	DSTPTR[DST$V_RTNBEG_NO_CALL] = FALSE;
	DSTPTR[DST$L_RTNBEG_ADDRESS] = .VALUE;
	CH$MOVE(.NAMEPTR[0] + 1, NAMEPTR[0], DSTPTR[DST$B_RTNBEG_NAME]);
	END


    ! If the global symbol is a data symbol, build a Data Item RST Entry for
    ! it.  Also construct the corresponding dummy DST record.  The DST data
    ! type is set to be longword integer.
    !
    ELSE
	BEGIN
	RSTPTR = DBG$GET_MEMORY(RST$K_DATENTSIZ + (11 + .NAMEPTR[0])/4);
	DSTPTR = .RSTPTR + 4*RST$K_DATENTSIZ;
	RSTPTR[RST$B_KIND] = RST$K_DATA;
	RSTPTR[RST$L_TYPEPTR] = 0;
	DSTPTR[DST$B_LENGTH] = 7 + .NAMEPTR[0];
	DSTPTR[DST$B_TYPE] = DSC$K_DTYPE_L;
	DSTPTR[DST$B_VFLAGS] = 1;
	DSTPTR[DST$L_VALUE] = .VALUE;
	CH$MOVE(.NAMEPTR[0] + 1, NAMEPTR[0], DSTPTR[DST$B_NAME]);
	END;


    ! Fill in the remainder of the RST entry and mark the symbol as global.
    ! Attach the symbol to the anonymous module's symbol chain.
    !
    MODRSTPTR = .RST$START_ADDR;
    IF NOT .MODRSTPTR[RST$V_ANONMOD] THEN SIGNAL(DBG$_DEBUGBUG,1,158);
    RSTPTR[RST$L_SYMCHNPTR] = .MODRSTPTR[RST$L_SYMCHNPTR];
    MODRSTPTR[RST$L_SYMCHNPTR] = .RSTPTR;
    RSTPTR[RST$L_DSTPTR] = .DSTPTR;
    RSTPTR[RST$L_UPSCOPEPTR] = .MODRSTPTR;
    RSTPTR[RST$V_GLOBAL] = TRUE;
    RSTPTR[RST$W_REFCOUNT] = 0;
    DBG$HASH_INSERT(.RSTPTR);


    ! We are all done--return the address of the RST entry.
    !
    RETURN .RSTPTR;

    END;

GLOBAL ROUTINE DBG$IS_IT_ENTRY(ADDR) =
!
! FUNCTION
!	This routine decides whether a given virtual address in the user program
!	is the address of a CALL entry mask.  It returns TRUE if the given ad-
!	dress is the start address of a routine or entry point callable with the
!	CALLS and CALLG instructions.  It returns FALSE in all other cases.
!
!	This routine is called in the processing of breakpoints because if a
!	breakpoint is set on a CALL routine (as opposed to a JSB routine or an
!	ordinary code location), the BPT instruction must be placed two bytes
!	past the routine address so it falls on the first instruction instead
!	of the entry mask.
!
! INPUTS
!	ADDR	- The input address.  This routine will determine whether this
!		  address points to an entry mask or not.
!
! OUTPUTS
!	The routine returns TRUE if ADDR is the address of an entry mask, i.e.
!		  is the address of a CALLS or CALLG routine or entry point.
!		  The routine returns FALSE otherwise.
!

    BEGIN

    LOCAL
	DSTPTR: REF DST$RECORD,		! Pointer to Routine Begin DST Record
	GSTPTR: REF GST_RECORD,		! Pointer to Global Symbol Table record
	MODRSTPTR: REF RST$ENTRY,	! Pointer to current Module RST Entry
	PROG_SATPTR: REF SAT$ENTRY,	! Pointer to Program SAT entry
	RSTPTR: REF RST$ENTRY,		! Pointer to current RST entry
	SATPTR: REF SAT$ENTRY;		! Pointer to SAT entry for a symbol



    ! Search through the Program Static Address Table.  Here we are looking for
    ! a module which covers the ADDR address.
    !
    PROG_SATPTR = .SAT$START_ADDR;
    WHILE .PROG_SATPTR NEQ 0 DO
	BEGIN


	! If the current Static Address Table entry is past the address we are
	! looking for (has a higher start address), we exit the search loop
	! without finding a suitable SAT entry.  This works because the Static
	! Address Table is sorted on the start address.
	!
	IF .PROG_SATPTR[SAT$L_START] GTRA .ADDR THEN EXITLOOP;


	! If ADDR is in the range of this SAT entry, we go to the corresponding
	! Module RST Entry and search that module's Static Address Table.
	!
	IF .PROG_SATPTR[SAT$L_END] GEQA .ADDR
	THEN
	    BEGIN


	    ! Loop through this module's SAT looking for a symbol whose address
	    ! matches the desired ADDR address.  If we find such a symbol, we
	    ! see if it is an entry point.
	    !
	    MODRSTPTR = .PROG_SATPTR[SAT$L_RSTPTR];
	    SATPTR = .MODRSTPTR[RST$L_SAT_PTR];
	    WHILE .SATPTR NEQ 0 DO
		BEGIN


		! If this SAT entry is past the desired address, exit this
		! loop--there is no symbol for the address in this module.
		! (Again, this Static Address Table is sorted on start address.)
		!
		IF .SATPTR[SAT$L_START] GTRA .ADDR THEN EXITLOOP;


		! If this SAT entry has exactly the start address we want, we
		! return TRUE if the corresponding symbol is a CALL routine or
		! an entry point.
		!
		IF .SATPTR[SAT$L_START] EQLA .ADDR
		THEN
		    BEGIN
		    RSTPTR = .SATPTR[SAT$L_RSTPTR];
		    IF .RSTPTR[RST$B_KIND] EQL RST$K_ROUTINE
		    THEN
			BEGIN
			DSTPTR = .RSTPTR[RST$L_DSTPTR];
			IF (.DSTPTR[DST$B_TYPE] EQL DST$K_RTNBEG) AND
			   (NOT .DSTPTR[DST$V_RTNBEG_NO_CALL])
			THEN
			    RETURN TRUE;

			END;

		    IF .RSTPTR[RST$B_KIND] EQL RST$K_ENTRY THEN RETURN TRUE;
		    END;


		! Loop for the next symbol SAT entry in this module.
		!
		SATPTR = .SATPTR[SAT$L_FLINK];
		END;

	    END;			! End of IF for ADDR in SAT entry range


	! Address not found in this module--loop for the next Program Static
	! Address Table entry.
	!
	PROG_SATPTR = .PROG_SATPTR[SAT$L_FLINK];
	END;


    ! A CALL routine or entry point symbol for the address could not be found
    ! anywhere in the Static Address Table or in any SET module.  We therefore
    ! have to search the Global Symbol Table to see if a symbol for the address
    ! is declared there.
    !
    DBG$GET_NXT_GST(1);
    WHILE TRUE DO
	BEGIN


	! Get a pointer to the next GST entry.  Exit loop if there are no more.
	!
	GSTPTR = DBG$GET_NXT_GST(0);
	IF .GSTPTR EQL 0 THEN EXITLOOP;


	! Now see what kind of GST entry we have and act accordingly.
	!
	CASE .GSTPTR[GST_ENTRY_TYPE] FROM GST_LOWEST TO GST_HIGHEST OF
	    SET


	    ! If this is a Routine or Entry GST Record for the exact address we
	    ! are looking for, return TRUE--the address is an entry point.
	    !
	    [GST_PROC_DEFN,
	     GST_ENTRY_DEFN]:
		IF .GSTPTR[GST_VALUE] EQLA .ADDR THEN RETURN TRUE;


	    ! Ignore all other kinds of GST records.
	    !
	    [INRANGE, OUTRANGE]:
		0;

	    TES;

	END;


    ! We did not find an entry or procedure definition for the address in the
    ! GST either.  It is thus not an entry point and we return FALSE.
    !
    RETURN FALSE;

    END;

GLOBAL ROUTINE DBG$RST_SHOWSCOPE: NOVALUE =
!
! FUNCTION
!	This routine does most of the work of handling the SHOW SCOPE command.
!	It goes through the internal Scope List, and for each scope entry it
!	prints out the corresponding scope name.
!
! INPUTS
!	NONE
!
! OUTPUTS
!	The SHOW SCOPE response (i.e., "scope: scope-list") is printed out.
!		  No value is returned.
!

    BEGIN

    LOCAL
	INVOCNUM,			! Invocation number for numeric scope
	MODRSTPTR,			! Return parameter not actually used
	PATHNAME,			! Pointer to Pathname Descriptor
	PATH_STRING,			! Pointer to pathname counted string
	RSTPTR,				! Pointer to scope RST entry
	SCOPE: REF SCOPE$ENTRY,		! Pointer to current scope list entry
	BUFFER: VECTOR[140,BYTE]; 	! Output buffer for DBG$FAO_PUT



    ! Set up the output buffer for the print routines (i.e., DBG$FAO_PUT).
    !
    DBG$CP_OUT_STR = BUFFER[1];
    DBG$GL_BUF_SIZ = 0;


    ! Print the initial "scope: " text.
    !
    DBG$FAO_PUT(BUFFER, UPLIT BYTE(%ASCIC 'scope: '), 0);


    ! Loop through all the Scope List entries until we find the all-set-modules
    ! scope.  For each scope, print out the scope name.
    !
    SCOPE = .SCOPE$LIST;
    WHILE .SCOPE[SCOPE$L_STATE] NEQ SCOPE$K_SETMODS DO
	BEGIN


	! Print the comma between scope entries.
	!
	IF .SCOPE NEQ .SCOPE$LIST
	THEN
	    DBG$FAO_PUT(BUFFER, UPLIT BYTE(%ASCIC ', '), 0);


	! Now do a CASE on the kind of Scope List entry this is.
	!
	CASE .SCOPE[SCOPE$L_STATE] FROM SCOPE$K_NORMAL TO SCOPE$K_SETMODS OF
	    SET


	    ! Handle normal scopes as set with the SET SCOPE command.  Convert
	    ! the scope to a Pathname Descriptor; then convert that to a counted
	    ! ASCII string and print that string.
	    !
	    [SCOPE$K_NORMAL]:
		BEGIN
		DBG$STA_SYMPATHNAME(.SCOPE[SCOPE$L_RSTPTR], PATHNAME);
		DBG$NPATHDESC_TO_CS(.PATHNAME, PATH_STRING);
		DBG$FAO_PUT(BUFFER, UPLIT BYTE(%ASCIC '!AC'), .PATH_STRING);
		END;


	    ! Handle "numbered" scopes, i.e. scopes relative to the current top
	    ! of the call stack.  Here we first print the number itself and then
	    ! the actual scope this corresponds to at present.
	    !
	    [SCOPE$K_NUMBERED]:
		BEGIN
		DBG$FAO_PUT(BUFFER, UPLIT BYTE(%ASCIC '!SL'),
						.SCOPE[SCOPE$L_MODPTR]);
		NUMBERED_SCOPE(.SCOPE[SCOPE$L_MODPTR],
					MODRSTPTR, RSTPTR, INVOCNUM);
		IF .RSTPTR NEQ 0
		THEN
		    BEGIN
		    IF .INVOCNUM NEQ 0
		    THEN
			RSTPTR = BUILD_INVOC_RST(.RSTPTR, .INVOCNUM);

		    DBG$STA_SYMPATHNAME(.RSTPTR, PATHNAME);
		    DBG$NPATHDESC_TO_CS(.PATHNAME, PATH_STRING);
		    DBG$FAO_PUT(BUFFER, UPLIT BYTE(%ASCIC ' [ = !AC ]'),
								.PATH_STRING);
		    END;

		END;


	    ! Handle the Global scope.  This is done by simply printing "\".
	    !
	    [SCOPE$K_GLOBAL]:
		DBG$FAO_PUT(BUFFER, UPLIT BYTE(%ASCIC '\'), 0);


	    ! Handle the all SET modules scope.  Since we should never get here,
	    ! we just signal an error.
	    !
	    [SCOPE$K_SETMODS]:
		SIGNAL(DBG$_DEBUGBUG, 1, 187);

	    TES;


	! Link on to the next Scope List entry and loop for the next scope.
	!
	SCOPE = .SCOPE[SCOPE$L_FLINK];
	END;


    ! We are all done.  Flush the output buffer and return.
    !
    DBG$OUT_PUT(BUFFER);
    RETURN;

    END;

GLOBAL ROUTINE DBG$RST_TEMP_RELEASE: NOVALUE =
!
! FUNCTION
!	This routine releases all "temporary" RST entries back to the DEBUG
!	memory pool.  "Temporary" RST entries are RST entries which are created
!	dynamically during the execution of a DEBUG command.  These include
!	Data RST Entries for record components, RST entries for objects with
!	invocation numbers, Line Number RST Entries, and most Data Type RST
!	Entries.  RST entries which are created by the SET MODULE command or
!	during DEBUG initialization are not temporary RST entries.
!
!	When a temporary RST entry is created, it is not put on the module's
!	symbol chain or entered in the RST Hash Table.  Instead, it is added
!	to the singly linked list pointed to by RST$TEMP_LIST.  This routine
!	is called at the end of every command to go through that list and to
!	release every RST entry with a zero reference count to the DEBUG mem-
!	ory pool.  An entry with a non-zero reference count cannot be released
!	since something references that entry; the current location pseudo-
!	symbol may be bound to a Primary Descriptor which in turn points to
!	that RST entry, for example.
!
! INPUTS
!	NONE
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
	OLDPTR: REF RST$ENTRY,		! Pointer to the previous RST entry in
					!      temporary RST entry list
	RSTPTR: REF RST$ENTRY;		! Pointer to the current RST entry in
					!      the temporary RST entry list



    ! Loop through the Temporary RST Entry List.  Release every entry with
    ! a zero reference count back to the memory pool.
    !
    OLDPTR = RST$TEMP_LIST;
    RSTPTR = .OLDPTR[RST$L_HASH_FLINK];
    WHILE .RSTPTR NEQ 0 DO
	BEGIN
	IF .RSTPTR[RST$W_REFCOUNT] EQL 0
	THEN
	    BEGIN
	    OLDPTR[RST$L_HASH_FLINK] = .RSTPTR[RST$L_HASH_FLINK];
	    DBG$REL_MEMORY(.RSTPTR);
	    END

	ELSE
	    OLDPTR = .RSTPTR;

	RSTPTR = .OLDPTR[RST$L_HASH_FLINK];
	END;


    ! We are all done--return.
    !
    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_GETSOURCEMOD(MODNAMEPTR) =
!
! FUNCTION
!	This routine looks up what module should be used when displaying source
!	lines.  It accepts a pointer to a Counted ASCII module name and returns
!	a pointer to the corresponding Module RST Entry.  However, if the name
!	pointer is zero, it determines which module contains the current scope
!	(as defined by the Scope List) and returns a pointer to that module's
!	Module RST Entry.  If the module name does not exist or if no known
!	module contains the current scope, the routine returns a zero value.
!
!	This routine is called during the processing of the TYPE command to
!	determine which module to type source lines from.  It is also called
!	during the processing of the SET SOURCE/MODULE and CANCEL SOURCE/MODULE
!	commands to look up module names.  Only the TYPE command passes a zero
!	module name pointer; this happens when no module name is specified on
!	the command.
!
! INPUTS
!	MODNAMEPTR - A pointer to the Counted ASCII module name to be looked up.
!		  If the module of the current scope is to be looked up, this
!		  pointer should be zero.
!
! OUTPUTS
!	A pointer to the Module RST Entry of the module specified by MODNAMEPTR
!		  is returned as the routine value.  If the desired module could
!		  not be found (no such module name or current scope not in any
!		  known module), zero is returned as the value.
!

    BEGIN

    LOCAL
	INVOCNUM,			! Invocation number parameter
	MODRSTPTR: REF RST$ENTRY,	! Pointer to found Module RST Entry
	SCOPE,				! Scope pointer parameter
	SCOPEPTR: REF SCOPE$ENTRY;	! Pointer to current Scope List Entry



    ! If the MODNAMEPTR parameter is non-zero, we search the RST Hash Table for
    ! the Counted ASCII module name pointed to by MODNAMEPTR.
    !
    IF .MODNAMEPTR NEQ 0
    THEN
	BEGIN
	DBG$HASH_FIND_SETUP(.MODNAMEPTR);
	WHILE TRUE DO
	    BEGIN
	    MODRSTPTR = DBG$HASH_FIND(.MODNAMEPTR);
	    IF .MODRSTPTR EQL 0 THEN RETURN 0;
	    IF .MODRSTPTR[RST$B_KIND] EQL RST$K_MODULE THEN RETURN .MODRSTPTR;
	    END;

	END;


    ! MODNAMEPTR is zero.  We thus search the Scope List for the first scope
    ! with a known module and return a pointer to that Module RST Entry.
    !
    SCOPEPTR = .SCOPE$LIST;
    WHILE .SCOPEPTR NEQ 0 DO
	BEGIN
	CASE .SCOPEPTR[SCOPE$L_STATE] FROM SCOPE$K_NORMAL TO SCOPE$K_SETMODS OF
	    SET


	    ! Normal scope--just return the scope's Module RST Entry pointer.
	    !
	    [SCOPE$K_NORMAL]:
		RETURN .SCOPEPTR[SCOPE$L_MODPTR];


	    ! Numbered scope--look up the corresponding lexical entity and
	    ! module in the call stack and return its Module RST Entry pointer.
	    ! If the module is not found, we continue the Scope List search.
	    !
	    [SCOPE$K_NUMBERED]:
		BEGIN
		NUMBERED_SCOPE(.SCOPEPTR[SCOPE$L_MODPTR], MODRSTPTR,
							SCOPE, INVOCNUM);
		IF .MODRSTPTR NEQ 0 THEN RETURN .MODRSTPTR;
		END;


	    ! Global symbol scope--just ignore this entry and continue search.
	    !
	    [SCOPE$K_GLOBAL]:
		0;


	    ! All SET modules scope--ignore this entry and continue search.
	    !
	    [SCOPE$K_SETMODS]:
		0;

	    TES;


	! Link to the next Scope List Entry and loop.
	!
	SCOPEPTR = .SCOPEPTR[SCOPE$L_FLINK];
	END;


    ! No usable scope was found in the Scope List.  Return zero to the caller.
    !
    RETURN 0;

    END;

GLOBAL ROUTINE DBG$STA_GETSYMBOL(PATHNAME, SYMID, KIND): NOVALUE =
!
! FUNCTION:
!	This routine accepts a pathname and returns the corresponding symbol.
!	The pathname, which is passed in internal format, consists of a symbolic
!	name (such as "X") or a symbolic name with pathname qualification (such
!	as "M\R\X").  It also includes any data record qualification which may
!	be present; thus "M\R\A.B.C" constitutes a pathname in this context.
!	This routine is the central routine one calls to search the Debug Symbol
!	Table (the DST) to find the symbol table entry corresponding to a given
!	symbolic name.  The search takes into account all scope rules dictated
!	by the language and the SET SCOPE and SET MODULE commands.
!
! INPUTS:
!	PATHNAME - The address of a pathname descriptor describing the symbolic
!		  name to be looked up in the DST.  A "pathname descriptor" is
!		  the internal data structure which describes an already parsed
!		  symbolic name including all pathname and data record qualifi-
!		  cation.
!
!	SYMID	- The address of a longword location where the "symbol identi-
!		  fier" should be returned.  The "symbol identifier" is a value
!		  which uniquely identifies the returned symbol.  This value is
!		  not directly understood outside the symbol table access rou-
!		  tines, but can be passed to various other symbol table access
!		  routines to extract information about the symbol.
!
!	KIND	- The address of a longword location where the "kind" of the
!		  SYMID symbol should be returned.  KIND specifies whether SYMID
!		  identifies a routine, a line, or a data item, etc.  See the
!		  OUTPUTS section below for more detail.
!
! OUTPUTS:
!	SYMID	- A symbol identifier which uniquely identifies the symbol spec-
!		  ified by PATHNAME is returned to SYMID.  This symbol identi-
!		  fier can then be passed to any symbol table access routine
!		  which accepts a SYMID parameter.  If no unique symbol corre-
!		  sponding to PATHNAME can be found in the DST (given the scope
!		  rules in effect), a zero is returned to SYMID.
!
!	KIND	- The "kind" of the SYMID symbol is returned to KIND.  This is
!		  a small integer value with the following possible values:
!
!			RST$K_INVALID	-- No symbol was found (SYMID = 0)
!			RST$K_NOTUNIQUE	-- Symbol is not unique (SYMID = 0)
!			RST$K_ROUTINE	-- SYMID is a Routine
!			RST$K_BLOCK	-- SYMID is a Block
!			RST$K_ENTRY	-- SYMID is an Entry Point
!			RST$K_LABEL	-- SYMID is a Label
!			RST$K_LINE	-- SYMID is a Line
!			RST$K_DATA	-- SYMID is a Data Item
!			RST$K_TYPCOMP	-- SYMID is a Data Type Component
!
!	No value is returned by DBG$STA_GETSYMBOL.
!

    BEGIN

    MAP
	PATHNAME: REF PTH$PATHNAME,	! Pointer to input pathname descriptor
	SYMID: REF VECTOR[1],		! Pointer to SYMID location
	KIND: REF VECTOR[1];		! Pointer to KIND location

    LITERAL
	MAX_STACK = 100;		! Maximum size of the symbol name stack

    FIELD STK_FLDS =			! Field definitions for SYMSTACK vector
	SET				!
	STK_RSTPTR	= [ 0, L_ ],	! RST pointer to current stack component
	STK_PINDEX	= [ 1, W0_ ],	! Pathname vector index + 1
	STK_TPINDEX	= [ 1, W1_ ]	! Next Type RST Entry ref table index
	TES;

    OWN
	CANDLST: REF VECTOR[,LONG]	! Pointer to RST entry candidate list
			INITIAL(0),	!      for the current scope
	MODU_SCOPE: SCOPE$ENTRY		! Scope list entry used for explicitly
		INITIAL(0, SCOPE$K_NORMAL, 0, 0),	! specified module scope
	NORM_SCOPE: SCOPE$ENTRY		! Scope list entry used for explicitly
		INITIAL(0, SCOPE$K_NORMAL, 0, 0),	! specified scopes
	NUMB_SCOPE: SCOPE$ENTRY		! Scope list entry used for numbered
		INITIAL (0, SCOPE$K_NUMBERED, 0, 0);	! scopes (i.e., n\X).

    LOCAL
	CANDBLK: REF CAND_BLOCKVECTOR,	! Pointer to candidate block-vector
	DEFDEPTH,			! Definition depth of symbol in scope
	GOOD_CAND,			! CANDLST index of good candidate symbol
	HAVE_LINE_NUM,			! Flag set if pathname has a line number
	HAVE_NUM_SCOPE,			! Flag set if pathname has a numbered
					!      scope in first position ("0\I")
	HAVE_SCOPE,			! Flag set when we have scope to search
	IN_SCOPE,			! Flag set if symbol is in current scope
	J,				! Loop index for CANDBLK vector
	LINEEND,			! Line number end address
	LINE_LEX_PTR,			! Pointer to the inner-most lexical
					!      entity containing the line number
	LINE_NUM,			! Line number if pathname contains one
	LINE_NUM_IS_LAST,		! Flag set if there is a line number and
					!      it is last in the pathname
	LINE_NUM_LOC,			! Index of line number (if present) in
					!      pathname vector (1-based).
	LINESTART,			! Line number start address
	MODRSTPTR: REF RST$ENTRY,	! Pointer to Module RST Entry for the
					!      current scope being searched
	NAMEPTR: REF VECTOR[,BYTE],	! Pointer to RST entry symbol name as
					!      a counted ASCII string
	NCANDS,				! Number of candidate list entries
	NEWREFLIST,			! Temporary pointer to new RST Reference
					!      List memory block
	NEXTSETMOD: REF RST$ENTRY,	! Pointer to the next SET module after
					!      this one--used when searching all
					!      SET modules for a pathname match
	NUMBER,				! Used to convert line number to binary
	NUMSCP_INVOC_NUM,		! Invocation number of the current
					!      numbered scope
	OLDCAND,			! Pointer to candidate list about to be
					!      copied to a larger memory block
	PATH_NAME_PTR,			! Pointer to pathname counted ASCII
	PATH_START_LOC,			! Start location of scope in pathname
	PATHSTRING,			! Pointer to pathname counted ASCII
	PATHVEC: REF VECTOR[,LONG],	! Pointer to the pathname vector
	PINDEX,				! Index into pathname vector
	PNAME: REF VECTOR[,BYTE],	! Pointer to pathname component counted
					!      ASCII string
	RNAME: REF VECTOR[,BYTE],	! Pointer to RST entry scope chain com-
					!      ponent's name as counted ASCII
	ROUTPTR: REF RST$ENTRY,		! Pointer to Routine RST Entry of rout-
					!      ine with invocation number
	RPTR: REF RST$ENTRY,		! Pointer to current RST entry in RSTPTR
					!      entry's up-scope chain
	RSTPTR: REF RST$ENTRY,		! Pointer to candidate RST entry
	SATPTR: REF SAT$ENTRY,		! Pointer to Static Address Table entry
	SCOPE: REF RST$ENTRY,		! Pointer to current scope's RST entry
	SCOPEPTR: REF SCOPE$ENTRY,	! Points to the current scope list entry
	SCOPE_STATE,			! The current state in our traversal of
					!      the scopes to be searched
	SCPTR: REF RST$ENTRY,		! Pointer used to follow current scope's
					!      up-scope chain
	SET_SCOPE,			! Set to TRUE if called by SET SCOPE
	STATUS,				! Status code returned by called routine
	STKPTR,				! Current SYMSTACK index
	STMT_NUM,			! Statement number within line number
	SYMSCOPE: REF RST$ENTRY,	! The actual scope of the current symbol
	SYMSTACK:			! Symbol name stack for name components
		BLOCKVECTOR[MAX_STACK, 2, LONG] FIELD(STK_FLDS), !
	TPINDEX,			! Index into a Type RST Entry's table of
					!      references to that type
	TPTR: REF VECTOR[,LONG],	! Pointer to the Type RST Entry refer-
					!      ence table
	VALID_LINE_FLAG;		! Flag set if line number is valid



    ! Note whether we were called by the SET scope command.
    !
    SET_SCOPE = RST$SET_SCOPE;
    RST$SET_SCOPE = FALSE;


    ! Set up pointers to the pathname descriptor's pathname vector and the last
    ! name in the pathname vector.
    !
    PATHVEC = PATHNAME[PTH$A_PATHVECTOR];
    NAMEPTR = .PATHVEC[.PATHNAME[PTH$B_TOTCNT] - 1];


    ! See if there is any line number reference in the pathname.  If there is,
    ! extract the line and statement numbers and set the HAVE_LINE_NUM flag.
    !
    HAVE_LINE_NUM = FALSE;
    LINE_NUM_IS_LAST = FALSE;
    LINE_NUM_LOC = 0;
    VALID_LINE_FLAG = TRUE;
    INCR I FROM 1 TO .PATHNAME[PTH$B_TOTCNT] DO
	BEGIN
	PNAME = .PATHVEC[.I - 1];
	IF (.PNAME[0] GTR 6) AND
	   CH$EQL(6, PNAME[1], 6, UPLIT BYTE(%ASCII '%LINE '), 0)
	THEN
	    BEGIN
	    IF .PNAME[7] LSS '0' OR .PNAME[7] GTR '9' THEN VALID_LINE_FLAG = FALSE;
	    IF .HAVE_LINE_NUM THEN VALID_LINE_FLAG = FALSE;
	    HAVE_LINE_NUM = TRUE;
	    LINE_NUM_LOC = .I;


	    ! Loop over the line number ASCII to pick up the actual line number
	    ! and statement number.
	    !
	    LINE_NUM = -1;
	    NUMBER = 0;
	    INCR I FROM 7 TO .PNAME[0] DO
		BEGIN
		IF .PNAME[.I] EQL '.' AND .LINE_NUM EQL -1
		THEN
		    BEGIN
		    LINE_NUM = .NUMBER;
		    NUMBER = 0;
		    END

		ELSE IF (.PNAME[.I] GEQ '0') AND (.PNAME[.I] LEQ '9') AND
			(.NUMBER LEQ 1000000)
		THEN
		    NUMBER = 10*.NUMBER + (.PNAME[.I] - '0')

		ELSE
		    BEGIN
		    VALID_LINE_FLAG = FALSE;
		    EXITLOOP;
		    END;

		END;


	    ! Set LINE_NUM and STMT_NUM properly on loop exit.
	    !
	    IF .LINE_NUM EQL -1
	    THEN
		BEGIN
		LINE_NUM = .NUMBER;
		STMT_NUM = 0;
		END

	    ELSE
		STMT_NUM = .NUMBER;

	    END;

	END;				! End of line number INCR loop


    ! If we got a line number, make some additional validity checks on it.
    ! If the line number is not valid for any reason (including syntax errors),
    ! return the invalid symbol code to the caller.
    !
    IF .HAVE_LINE_NUM
    THEN
	BEGIN
	LINE_NUM_IS_LAST = .LINE_NUM_LOC EQL .PATHNAME[PTH$B_TOTCNT];
	IF (.LINE_NUM_LOC GTR .PATHNAME[PTH$B_PATHCNT])     OR
	   (.LINE_NUM_LOC LSS .PATHNAME[PTH$B_PATHCNT] - 1) OR
	   (.LINE_NUM_LOC EQL .PATHNAME[PTH$B_PATHCNT] AND NOT .LINE_NUM_IS_LAST)
	THEN
	    VALID_LINE_FLAG = FALSE;

	IF NOT .VALID_LINE_FLAG
	THEN
	    BEGIN
	    SYMID[0] = 0;
	    KIND[0] = RST$K_INVALID;
	    RETURN;
	    END;

	END;


    ! If we do not yet have a candidate list memory block, get one and initial-
    ! ize its first element to give the list size that will fit in the block.
    !
    NCANDS = 0;
    IF .CANDLST EQL 0
    THEN
	BEGIN
	CANDLST = DBG$GET_MEMORY(11);
	CANDLST[0] = 10;
	END;


    ! Set up the "scope pointer" to point to the list of scopes to be searched.
    ! If the symbol is of the form \X, we search the Global Symbol Table only,
    ! and if it is of the form n\X, we search the n-th "numbered scope" only.
    ! Otherwise, we use the normal scope list given by SCOPE$LIST.
    !
    SCOPEPTR = .SCOPE$LIST;
    HAVE_NUM_SCOPE = FALSE;
    PNAME = .PATHVEC[0];
    IF .PNAME[0] EQL 0
    THEN
	BEGIN
	IF .PATHNAME[PTH$B_LOCINVOC] EQL 0
	THEN
	    SCOPEPTR = UPLIT(0, SCOPE$K_GLOBAL, 0, 0)

	ELSE IF .PATHNAME[PTH$B_LOCINVOC] EQL 1
	THEN
	    BEGIN
	    HAVE_NUM_SCOPE = TRUE;
	    SCOPEPTR = NUMB_SCOPE;
	    SCOPEPTR[SCOPE$L_MODPTR] = .PATHNAME[PTH$L_INVOCNUM];
	    IF .PATHNAME[PTH$B_PATHCNT] LSS 2 THEN SCOPEPTR = 0;
	    END

	ELSE
	    SIGNAL(DBG$_DEBUGBUG, 1, 179);

	END


    ! If there is pathname qualification on the variable name other than the
    ! global scope or a numbered scope, we determine what scope is specified
    ! and set up a scope list entry for that scope.
    !
    ELSE IF (.PATHNAME[PTH$B_PATHCNT] GTR 1) AND (.LINE_NUM_LOC NEQ 1)
    THEN
	BEGIN
	PATH_START_LOC = .PATHNAME[PTH$B_PATHCNT] - 1;
	IF .LINE_NUM_LOC EQL .PATH_START_LOC
	THEN
	    PATH_START_LOC = .PATH_START_LOC - 1;


	! Loop over the RST Hash Table chain for this symbol name (i.e., for the
	! scope specified by the pathname).  For each such symbol, see if it
	! matches the rest of the pathname qualification.
	!
	MODU_SCOPE[SCOPE$L_RSTPTR] = 0;
	NORM_SCOPE[SCOPE$L_RSTPTR] = 0;
	PATH_NAME_PTR = .PATHVEC[.PATH_START_LOC - 1];
	DBG$HASH_FIND_SETUP(.PATH_NAME_PTR);
	WHILE TRUE DO
	    BEGIN


	    ! Get the next symbol from the hash chain.  Check for chain's end.
	    !
	    RSTPTR = DBG$HASH_FIND(.PATH_NAME_PTR);
	    IF .RSTPTR EQL 0 THEN EXITLOOP;


	    ! Scan the symbol's up-scope chain and see if it fully matches the
	    ! specified pathname qualification.  If so, this is the scope.
	    !
	    RPTR = .RSTPTR;
	    PINDEX = .PATH_START_LOC;
	    WHILE TRUE DO
		BEGIN
		IF .RSTPTR[RST$V_GLOBAL] THEN EXITLOOP;
		IF (.RSTPTR[RST$B_KIND] NEQ RST$K_MODULE)  AND
		   (.RSTPTR[RST$B_KIND] NEQ RST$K_ROUTINE) AND
		   (.RSTPTR[RST$B_KIND] NEQ RST$K_BLOCK)
		THEN
		    EXITLOOP;

		PNAME = .PATHVEC[.PINDEX - 1];
		RNAME = DBG$GET_DST_NAME(.RPTR[RST$L_DSTPTR]);
		IF CH$EQL(.PNAME[0], PNAME[1], .RNAME[0], RNAME[1], 0)
		THEN
		    BEGIN


		    ! If the pathname ended and everything matched so far, this
		    ! may be the desired scope.  Create a scope list entry for
		    ! it and check for uniqueness.
		    !
		    IF .PINDEX EQL 1
		    THEN
			BEGIN
			MODRSTPTR = .RSTPTR;
			WHILE .MODRSTPTR[RST$B_KIND] NEQ RST$K_MODULE DO
			    MODRSTPTR = .MODRSTPTR[RST$L_UPSCOPEPTR];

			SCOPEPTR = NORM_SCOPE;
			IF .RSTPTR EQL .MODRSTPTR THEN SCOPEPTR = MODU_SCOPE;
			IF .SCOPEPTR[SCOPE$L_RSTPTR] NEQ 0
			THEN
			    BEGIN
			    SYMID[0] = 0;
			    KIND[0] = RST$K_NOTUNIQUE;
			    RETURN;
			    END;

			SCOPEPTR[SCOPE$L_RSTPTR] = .RSTPTR;
			SCOPEPTR[SCOPE$L_MODPTR] = .MODRSTPTR;
			EXITLOOP;
			END;


		    ! Decrement the PATHVEC index and continue the search.
		    !
		    PINDEX = .PINDEX - 1;
		    END;


		! Link up-scope and continue the search.
		!
		IF .RPTR[RST$B_KIND] EQL RST$K_MODULE THEN EXITLOOP;
		RPTR = .RPTR[RST$L_UPSCOPEPTR];
		END;

	    END;			! End of WHILE loop over hash table


	! Depending on whether a normal scope or a module scope or both were
	! found to match the pathname, put the corresponding scope list entries
	! on the scope list.
	!
	SCOPEPTR = 0;
	MODU_SCOPE[SCOPE$L_FLINK] = 0;
	IF .NORM_SCOPE[SCOPE$L_RSTPTR] NEQ 0
	THEN
	    BEGIN
	    MODU_SCOPE[SCOPE$L_FLINK] = NORM_SCOPE;
	    SCOPEPTR = NORM_SCOPE;
	    END;

	IF .MODU_SCOPE[SCOPE$L_RSTPTR] NEQ 0 THEN SCOPEPTR = MODU_SCOPE;
	END;


    ! If another routine has set SPECIAL_SCOPE, we use that scope list instead.
    ! (This feature is not actually used at present.)
    !
    IF .SPECIAL_SCOPE NEQ 0
    THEN
	BEGIN
	SCOPEPTR = .SPECIAL_SCOPE;
	SPECIAL_SCOPE = 0;
	END;


    ! Set up NEXTSETMOD for search through all SET modules.
    !
    NEXTSETMOD = .RST$START_ADDR;


    ! Loop through all the proper scopes, searching for a symbol which matches
    ! the specified pathname.
    !
    WHILE TRUE DO
	BEGIN


	! Loop through the scope selection code until we find a scope in which
	! to search for the specified pathname.
	!
	HAVE_SCOPE = FALSE;
	WHILE TRUE DO
	    BEGIN


	    ! If the scope list has no more entries, we have searched all scopes
	    ! on the list without finding the desired symbol.  Return to the
	    ! caller indicating that the symbol is not in the RST.
	    !
	    IF .SCOPEPTR EQL 0
	    THEN
		BEGIN
		SYMID[0] = 0;
		KIND[0] = RST$K_INVALID;
		RETURN;
		END;


	    ! Try to select a scope to search based on the current scope state.
	    !
	    SCOPE_STATE = .SCOPEPTR[SCOPE$L_STATE];
	    CASE .SCOPE_STATE FROM SCOPE$K_NORMAL TO SCOPE$K_SETMODS OF
		SET


		! Search a normal, named scope as declared with a SET SCOPE
		! command.  We pick up the scope information directly from the
		! scope list entry.  Note that the scope's module must be SET;
		! otherwise the scope is not searched.
		!
		[SCOPE$K_NORMAL]:
		    BEGIN
		    SCOPE = .SCOPEPTR[SCOPE$L_RSTPTR];
		    MODRSTPTR = .SCOPEPTR[SCOPE$L_MODPTR];
		    IF .MODRSTPTR[RST$V_MODSET] THEN HAVE_SCOPE = TRUE;
		    SCOPEPTR = .SCOPEPTR[SCOPE$L_FLINK];
		    END;


		! Search a "numbered scope", i.e. the scope where the PC is cur-
		! rently positioned N levels down in the CALL stack.  To do this
		! we look up the PC in the Static Address Table to find the con-
		! taining lexical entity.  If that succeeds (and the module is
		! SET), we use that scope.
		!
		[SCOPE$K_NUMBERED]:
		    BEGIN
		    NUMBERED_SCOPE(.SCOPEPTR[SCOPE$L_MODPTR],
					MODRSTPTR, SCOPE, NUMSCP_INVOC_NUM);
		    IF .SCOPE NEQ 0 THEN HAVE_SCOPE = TRUE;
		    SCOPEPTR = .SCOPEPTR[SCOPE$L_FLINK];
		    END;


		! Search the Global Symbol Table (GST) for the symbol.  We do
		! this only if the symbol is of the form "X" or "\X".  We do
		! the search right here, and if we find the symbol, we return
		! to the caller right away with the proper SYMID and KIND.
		!
		[SCOPE$K_GLOBAL]:
		    BEGIN
		    PNAME = .PATHVEC[0];
		    IF (.PATHNAME[PTH$B_TOTCNT] EQL .PATHNAME[PTH$B_PATHCNT])AND
		       ((.PATHNAME[PTH$B_TOTCNT] EQL 2 AND .PNAME[0] EQL 0) OR
			(.PATHNAME[PTH$B_TOTCNT] EQL 1))
		    THEN
			BEGIN
			RSTPTR = DBG$STA_LOOKUP_GBL(
					.PATHVEC[.PATHNAME[PTH$B_TOTCNT] - 1]);
			IF .RSTPTR NEQ 0
			THEN
			    BEGIN
			    SYMID[0] = .RSTPTR;
			    KIND[0] = .RSTPTR[RST$B_KIND];
			    RETURN;
			    END;

			END;

		    SCOPEPTR = .SCOPEPTR[SCOPE$L_FLINK];
		    END;


		! Search all SET modules for the symbol.  Here we locate the
		! next SET module and use that as the current scope.  Note that
		! we accumulate candidate symbols over all SET modules before
		! selecting the candidate that best matches the name.
		!
		[SCOPE$K_SETMODS]:
		    BEGIN


		    ! The first time through, make NEXTSETMOD point to the first
		    ! SET module and set the number of candidates to zero.
		    !
		    IF .NEXTSETMOD EQL .RST$START_ADDR
		    THEN
			BEGIN
			WHILE .NEXTSETMOD NEQ 0 DO
			    BEGIN
			    IF .NEXTSETMOD[RST$V_MODSET] THEN EXITLOOP;
			    NEXTSETMOD = .NEXTSETMOD[RST$L_NXTMODPTR];
			    END;

			END;


		    ! Make MODRSTPTR and SCOPE point to the next SET module and
		    ! make NEXTSETMOD point to the SET module we will search the
		    ! next time around.  When NEXTSETMOD becomes zero, there is
		    ! no next time around.
		    !
		    MODRSTPTR = .NEXTSETMOD;
		    SCOPE = .MODRSTPTR;
		    WHILE .NEXTSETMOD NEQ 0 DO
			BEGIN
			NEXTSETMOD = .NEXTSETMOD[RST$L_NXTMODPTR];
			IF .NEXTSETMOD EQL 0 THEN EXITLOOP;
			IF .NEXTSETMOD[RST$V_MODSET] THEN EXITLOOP;
			END;

		    IF .MODRSTPTR NEQ 0 THEN HAVE_SCOPE = TRUE;
		    IF .NEXTSETMOD EQL 0 THEN SCOPEPTR = .SCOPEPTR[SCOPE$L_FLINK];
		    END;

		TES;


	    ! If we now have a scope to search, exit the scope-locating loop
	    ! and search that scope.  Otherwise, loop to locate another scope.
	    !
	    IF .HAVE_SCOPE THEN EXITLOOP;

	    END;			! End of WHILE loop to find a scope


	! We now have a scope to search.  Make sure the corresponding module's
	! symbol table is in the RST.
	!
	IF NOT .MODRSTPTR[RST$V_MOD_IN_RST] THEN DBG$RST_BUILD(.MODRSTPTR);


	! If there is a line number in the pathname, find the lexical entity
	! within this scope's module which contains that line number.  Note
	! that we search for the lowest level (innermost) lexical entity.
	!
	IF .HAVE_LINE_NUM
	THEN
	    BEGIN


	    ! Look up the line and statement numbers in the scope's module.
	    !
	    STATUS = DBG$LINE_TO_PC_LOOKUP(.LINE_NUM, .STMT_NUM,
					.MODRSTPTR, LINESTART, LINEEND);


	    ! Look up the lowest-level (innermost) lexical entity which contains
	    ! the line we just looked up.  We do this by searching the module's
	    ! Static Address Table.
	    !
	    SATPTR = .MODRSTPTR[RST$L_SAT_PTR];
	    IF NOT .STATUS THEN SATPTR = 0;
	    LINE_LEX_PTR = 0;
	    WHILE .SATPTR NEQ 0 DO
		BEGIN
		IF .SATPTR[SAT$L_START] GTR .LINESTART THEN EXITLOOP;
		RSTPTR = .SATPTR[SAT$L_RSTPTR];
		IF (.SATPTR[SAT$L_END] GEQ .LINESTART) AND
		   (.RSTPTR[RST$B_KIND] EQL RST$K_ROUTINE OR
		    .RSTPTR[RST$B_KIND] EQL RST$K_BLOCK)
		THEN
		    BEGIN
		    IF .LINE_LEX_PTR EQL 0
		    THEN
			LINE_LEX_PTR = .RSTPTR

		    ELSE
			BEGIN
			RPTR = .RSTPTR;
			WHILE .RPTR[RST$B_KIND] NEQ RST$K_MODULE DO
			    BEGIN
			    IF .RPTR EQL .LINE_LEX_PTR
			    THEN
				BEGIN
				LINE_LEX_PTR = .RSTPTR;
				EXITLOOP;
				END;

			    RPTR = .RPTR[RST$L_UPSCOPEPTR];
			    END;

			END;

		    END;

		SATPTR = .SATPTR[SAT$L_FLINK];
		END;			! End of WHILE loop over the SAT

	    END;			! End of line number lexical entity code


	! Set up the RST Hash Table search for this symbol and loop over all
	! hash table entries for the symbol's name.  For each RST entry we find,
	! we try to match the full pathname.  If this succeeds and the symbol is
	! in the current scope, the RST entry is added to a "candidate list".
	!
	DBG$HASH_FIND_SETUP(.NAMEPTR);
	WHILE TRUE DO
	    BEGIN


	    ! Get the next hash table entry with the specified symbol name.
	    ! If the desired symbol is a line number, we pick up the lexical
	    ! entity which contains the line instead.  When no more names are
	    ! found, exit the hash table loop.
	    !
	    IF .LINE_NUM_IS_LAST
	    THEN
		BEGIN
		RSTPTR = .LINE_LEX_PTR;
		LINE_LEX_PTR = 0;
		END

	    ELSE
		RSTPTR = DBG$HASH_FIND(.NAMEPTR);

	    IF .RSTPTR EQL 0 THEN EXITLOOP;


	    ! Loop through the RST entry's scope chain to match it to the speci-
	    ! fied pathname.  If the full pathname matches and the symbol is in
	    ! the current scope, we add the RST entry to the "candidate list".
	    !
	    STKPTR = 0;
	    RPTR = .RSTPTR;
	    PINDEX = .PATHNAME[PTH$B_TOTCNT];
	    WHILE TRUE DO
		BEGIN


		! If this is a global symbol or a module, do not even attempt to
		! match it to the pathname--exit the pathname matching loop now.
		!
		IF .RSTPTR[RST$V_GLOBAL] OR .RSTPTR[RST$B_KIND] EQL RST$K_MODULE
		THEN
		    EXITLOOP;


		! Also, if we are called by DBG$RST_SETSCOPE, do not consider
		! the symbol unless it is a routine or lexical block.
		!
		IF .SET_SCOPE
		THEN
		    BEGIN
		    IF (.RSTPTR[RST$B_KIND] NEQ RST$K_ROUTINE) AND
		       (.RSTPTR[RST$B_KIND] NEQ RST$K_BLOCK)
		    THEN
			EXITLOOP;

		    END;


		! Make a new SYMSTACK entry for this RST entry in the up-scope
		! chain.
		!
		STKPTR = .STKPTR + 1;
		IF .STKPTR GEQ MAX_STACK THEN EXITLOOP;
		SYMSTACK[.STKPTR, STK_RSTPTR] = .RPTR;
		SYMSTACK[.STKPTR, STK_PINDEX] = 0;
		SYMSTACK[.STKPTR, STK_TPINDEX] = 0;


		! If this pathname component is a line number or a scope number,
		! we skip over it in pathname matching.
		!
		IF (.HAVE_LINE_NUM AND (.PINDEX EQL .LINE_NUM_LOC)) OR
		   (.HAVE_NUM_SCOPE AND (.PINDEX EQL 1))
		THEN
		    PINDEX = .PINDEX - 1;


		! If the current pathname component matches the current scope
		! chain name, set PINDEX to point to the next pathname compo-
		! nent.  If PINDEX already pointed to the top component name,
		! the pathname matches and we make a candidate list entry.
		!
		PNAME = .PATHVEC[.PINDEX - 1];
		IF .PINDEX EQL 0 THEN PNAME = .PATHVEC[0];
		RNAME = DBG$GET_DST_NAME(.RPTR[RST$L_DSTPTR]);
		IF CH$EQL(.PNAME[0], PNAME[1], .RNAME[0], RNAME[1], 0) OR
		   (.PINDEX EQL 0)
		THEN
		    BEGIN


		    ! Record the fact that RPTR matches this Pathname component.
		    !
		    SYMSTACK[.STKPTR, STK_PINDEX] = .PINDEX;


		    ! If the last (top-level) pathname component just matched,
		    ! we see if the symbol is in the current scope.  If it is,
		    ! we add the symbol to the candidate list (CANDLST).
		    !
		    IF (.PINDEX LEQ .PATHNAME[PTH$B_PATHCNT]) AND
		       (.RPTR[RST$B_KIND] NEQ RST$K_TYPCOMP)
		    THEN
			BEGIN


			! Determine what the scope of the current symbol is.
			!
			SYMSCOPE = .RSTPTR;
			IF .RSTPTR[RST$B_KIND] NEQ RST$K_MODULE
			THEN
			    SYMSCOPE = .RSTPTR[RST$L_UPSCOPEPTR];

			IF .SYMSCOPE[RST$B_KIND] EQL RST$K_TYPE
			THEN
			    SYMSCOPE = .SYMSCOPE[RST$L_UPSCOPEPTR];


			! If we are searching all set modules, we claim that the
			! the symbol is declared at the module level so that all
			! symbols have the same definition depth.  Also, if we
			! are looking for a line number, we treat it as being
			! defined at the module level.
			!
			IF .SCOPE_STATE EQL SCOPE$K_SETMODS OR .LINE_NUM_IS_LAST
			THEN
			    BEGIN
			    WHILE .SYMSCOPE[RST$B_KIND] NEQ RST$K_MODULE DO
				SYMSCOPE = .SYMSCOPE[RST$L_UPSCOPEPTR];

			    END;


			! Determine whether the symbol is in the current scope.
			!
			SCPTR = .SCOPE;
			DEFDEPTH = 0;
			IN_SCOPE = TRUE;
			WHILE TRUE DO
			    BEGIN
			    IF .SCPTR EQL .SYMSCOPE THEN EXITLOOP;
			    IF .SCPTR[RST$B_KIND] EQL RST$K_MODULE
			    THEN
				BEGIN
				IN_SCOPE = FALSE;
				EXITLOOP;
				END;

			    SCPTR = .SCPTR[RST$L_UPSCOPEPTR];
			    DEFDEPTH = .DEFDEPTH + 1;
			    END;


			! If a line number is present in the pathname, make sure
			! this symbol has the line's lexical entity in its up-
			! scope chain.  Otherwise set IN_SCOPE to FALSE.
			!
			IF .HAVE_LINE_NUM AND .IN_SCOPE AND NOT .LINE_NUM_IS_LAST
			THEN
			    BEGIN
			    IN_SCOPE = FALSE;
			    SCPTR = .RSTPTR;
			    WHILE .SCPTR[RST$B_KIND] NEQ RST$K_MODULE DO
				BEGIN
				IF .SCPTR EQL .LINE_LEX_PTR
				THEN
				    BEGIN
				    IN_SCOPE = TRUE;
				    EXITLOOP;
				    END;

				SCPTR = .SCPTR[RST$L_UPSCOPEPTR];
				END;

			    END;


			! If the symbol is in the current scope, create a "can-
			! didate entry" for it.  Then enter that entry on the
			! "candidate list".
			!
			IF .IN_SCOPE
			THEN
			    BEGIN


			    ! Create the candidate entry for the symbol.
			    !
			    CANDBLK = DBG$GET_MEMORY(CAND_ENTSIZ*(.STKPTR+1));
			    J = 0;
			    INCR I FROM 1 TO .STKPTR DO
				BEGIN
				IF .SYMSTACK[.I, STK_TPINDEX] EQL 0
				THEN
				    BEGIN
				    CANDBLK[.J, CAND_RSTPTR] = .SYMSTACK[.I, STK_RSTPTR];
				    CANDBLK[.J, CAND_PINDEX] = .SYMSTACK[.I, STK_PINDEX];
				    J = .J + 1;
				    END;

				END;

			    CANDBLK[.J, CAND_RSTPTR] = 0;
			    CANDBLK[.J, CAND_PINDEX] = .DEFDEPTH;


			    ! Enter the candidate entry on the candidate list.
			    ! Note that we expand the candidate list memory
			    ! block if it is too small.
			    !
			    NCANDS = .NCANDS + 1;
			    IF .NCANDS GTR .CANDLST[0]
			    THEN
				BEGIN
				CANDLST[0] = .CANDLST[0] + 10;
				OLDCAND = .CANDLST;
				CANDLST = DBG$GET_MEMORY(.CANDLST[0] + 1);
				CH$MOVE(4*.NCANDS, .OLDCAND, .CANDLST);
				DBG$REL_MEMORY(.OLDCAND);
				END;

			    CANDLST[.NCANDS] = .CANDBLK;
			    END;


			! Now tear down SYMSTACK until we get to the bottom or
			! until we get to a TYPE entry whose type reference
			! table has not been exhausted.  If no such entry is
			! found, we exit the pathname match loop (with STKPTR =
			! 0) for this hash table symbol.
			!
			WHILE .STKPTR GTR 0 DO
			    BEGIN
			    IF .SYMSTACK[.STKPTR, STK_TPINDEX] NEQ 0
			    THEN
				BEGIN
				TPINDEX = .SYMSTACK[.STKPTR, STK_TPINDEX];
				RPTR = .SYMSTACK[.STKPTR, STK_RSTPTR];
				IF .TPINDEX LSS .RPTR[RST$W_TYPREFCNT] THEN EXITLOOP;
				END;

			    STKPTR = .STKPTR - 1;
			    END;

			IF .STKPTR EQL 0 THEN EXITLOOP;


			! If we found a type entry in SYMSTACK whose reference
			! table is not exhausted, we reset RPTR and PINDEX to
			! continue generating possible candidates from symbols
			! of this type.
			!
			SYMSTACK[.STKPTR, STK_TPINDEX] = .TPINDEX + 1;
			TPTR = .RPTR[RST$L_TYPREFTBL];
			RPTR = .TPTR[.TPINDEX];
			PINDEX = .SYMSTACK[.STKPTR, STK_PINDEX] + 1;

			END;		! End of .PINDEX LEQ ... THEN clause


		    ! We have more pathname components to match.  Decrement
		    ! PINDEX and stay in the pathname matching loop.
		    !
		    PINDEX = .PINDEX - 1;
		    IF .PINDEX LSS 0 THEN PINDEX = 0;

		    END;		! End of CH$EQL test's THEN clause


		! If the RST entry's up-scope chain has ended, we exit the path-
		! name matching loop.  Otherwise, we link up the up-scope chain
		! and continue pathname matching.
		!
		IF .RPTR[RST$B_KIND] EQL RST$K_MODULE THEN EXITLOOP;
		RPTR = .RPTR[RST$L_UPSCOPEPTR];


		! If the up-scope symbol is a Type RST Entry, we set up an entry
		! for it on SYMSTACK.  This stack entry will enable us to try
		! all possible symbols of this type as the up-scope continuation
		! of a type component (e.g., record or variant component).
		!
		IF .RPTR[RST$B_KIND] EQL RST$K_TYPE
		THEN
		    BEGIN
		    IF .RPTR[RST$L_TYPREFTBL] EQL 0 THEN EXITLOOP;
		    STKPTR = .STKPTR + 1;
		    IF .STKPTR GEQ MAX_STACK THEN EXITLOOP;
		    SYMSTACK[.STKPTR, STK_RSTPTR] = .RPTR;
		    SYMSTACK[.STKPTR, STK_PINDEX] = .PINDEX;
		    SYMSTACK[.STKPTR, STK_TPINDEX] = 1;
		    TPTR = .RPTR[RST$L_TYPREFTBL];
		    RPTR = .TPTR[0];
		    END;

		END;			! End of pathname matching WHILE loop

	    END;			! End of WHILE loop over hash table


	! We now have a list of candidate symbols which are in the current scope
	! and which may match the pathname.  Unless the list is empty, call a
	! language-specific routine to select the candidate symbol which best
	! matches the pathname.  Note that when we search all SET modules, we
	! do not call this selection routine until candidate symbols have been
	! accumulated from all SET modules.
	!
	IF (.NCANDS GTR 0) AND
	   (.SCOPE_STATE NEQ SCOPE$K_SETMODS OR .NEXTSETMOD EQL 0)
	THEN
	    BEGIN
	    CASE .DBG$GB_LANGUAGE FROM DBG$K_MACRO TO DBG$K_APL OF
		SET


		! Handle languages with "normal" scope rules--data qualification
		! must be complete, or it is absent from the language.
		!
		[DBG$K_MACRO, DBG$K_FORTRAN,
		 DBG$K_BLISS, DBG$K_BASIC,
		 DBG$K_PASCAL]:
		    GOOD_CAND = SCOPE_RULE_NORMAL(.PATHNAME, .NCANDS, .CANDLST);


		! Handle COBOL scope rules--data qualification need not be
		! complete and is resolved by COBOL scope rules.
		!
		[DBG$K_COBOL]:
		    BEGIN
		    SCPTR = 0;
		    IF (.SCOPE_STATE EQL SCOPE$K_NORMAL) OR
		       (.SCOPE_STATE EQL SCOPE$K_NUMBERED)
		    THEN
			SCPTR = .SCOPE;

		    GOOD_CAND = SCOPE_RULE_COBOL(.PATHNAME,
						.NCANDS, .CANDLST, .SCPTR);
		    END;


		! Handle PL/I scope rules--data qualification need not be
		! complete and is resolved by PL/I rules.
		!
		[DBG$K_PLI]:
		    GOOD_CAND = SCOPE_RULE_PLI(.PATHNAME, .NCANDS, .CANDLST);


		! Any other language code is invalid--signal an error.
		!
		[INRANGE, OUTRANGE]:
		    SIGNAL(DBG$_DEBUGBUG, 1, 180);

		TES;


	    ! If we found a valid and unique match for the pathname in this
	    ! scope, make CANDBLK point to that symbol and exit the scope
	    ! search loop.
	    !
	    IF .GOOD_CAND GTR 0
	    THEN
		BEGIN
		CANDBLK = .CANDLST[.GOOD_CAND];
		EXITLOOP;
		END;


	    ! We did not find a valid and unique symbol.  Release all candidate
	    ! blocks on the candidate list to the free memory pool.
	    !
	    INCR I FROM 1 TO .NCANDS DO DBG$REL_MEMORY(.CANDLST[.I]);
	    NCANDS = 0;


	    ! If the symbol turns out not be unique, return the not-unique
	    ! code to KIND and a zero to SYMID; then return to the caller.
	    ! Otherwise, loop to locate another scope to search.
	    !
	    IF .GOOD_CAND EQL -1
	    THEN
		BEGIN
		SYMID[0] = 0;
		KIND[0] = RST$K_NOTUNIQUE;
		RETURN;
		END;

	    END;

	END;				! End of WHILE loop over all scopes


    ! We have found a symbol which uniquely matches the specified pathname.
    ! Now go through the symbol's candidate entry to create new Data RST Entries
    ! from any Type Component RST Entries.  These new RST entries represent this
    ! specific instance of data qualification.  These RST entries are put on the
    ! Temporary RST Entry List.
    !
    J = 0;
    WHILE TRUE DO
	BEGIN
	RPTR = .CANDBLK[.J, CAND_RSTPTR];
	IF .RPTR EQL 0 THEN EXITLOOP;
	IF .RPTR[RST$B_KIND] NEQ RST$K_TYPCOMP THEN EXITLOOP;
	RSTPTR = DBG$GET_MEMORY(RST$K_DATENTSIZ);
	RSTPTR[RST$L_HASH_FLINK] = .RST$TEMP_LIST;
	RST$TEMP_LIST = .RSTPTR;
	RSTPTR[RST$L_DSTPTR] = .RPTR[RST$L_DSTPTR];
	RSTPTR[RST$L_UPSCOPEPTR] = .RPTR[RST$L_UPSCOPEPTR];
	RSTPTR[RST$B_KIND] = RST$K_INVALID;
	RSTPTR[RST$L_TYPEPTR] = .RPTR[RST$L_TYPEPTR];
	CANDBLK[.J, CAND_RSTPTR] = .RSTPTR;
	J = .J + 1;
	END;


    ! Then make a second scan over the new Data RST Entries to fix up their
    ! up-scope pointers.
    !
    J = 0;
    WHILE TRUE DO
	BEGIN
	RSTPTR = .CANDBLK[.J, CAND_RSTPTR];
	IF .RSTPTR EQL 0 THEN EXITLOOP;
	IF .RSTPTR[RST$B_KIND] NEQ RST$K_INVALID THEN EXITLOOP;
	RSTPTR[RST$B_KIND] = RST$K_DATA;
	IF .CANDBLK[.J + 1, CAND_RSTPTR] NEQ 0
	THEN
	    RSTPTR[RST$L_UPSCOPEPTR] = .CANDBLK[.J + 1, CAND_RSTPTR];

	J = .J + 1;
	END;


    ! If the symbol is a line number, create the Line Number RST Entry for the
    ! symbol and make its address the symbol's SYMID.
    !
    IF .LINE_NUM_IS_LAST
    THEN
	BEGIN
	MODRSTPTR = .CANDBLK[0, CAND_RSTPTR];
	WHILE .MODRSTPTR[RST$B_KIND] NEQ RST$K_MODULE DO
	    MODRSTPTR = .MODRSTPTR[RST$L_UPSCOPEPTR];

	STATUS = DBG$LINE_TO_PC_LOOKUP(.LINE_NUM, .STMT_NUM,
					.MODRSTPTR, LINESTART, LINEEND);
	CANDBLK[0, CAND_RSTPTR] = LINE_NUM_RST(.CANDBLK[0, CAND_RSTPTR],
		.LINE_NUM, .STMT_NUM, .LINESTART, .LINEEND);
	END;


    ! Pick up the SYMID (RST pointer) of the symbol we found.
    !
    RSTPTR = .CANDBLK[0, CAND_RSTPTR];


    ! If there is an invocation number, check that the invocation number was
    ! applied to the inner-most routine in the up-scope chain.  If that looks
    ! good, create an Invocation Number RST Entry for the symbol.
    !
    IF (.PATHNAME[PTH$B_LOCINVOC] NEQ 0) AND (NOT .HAVE_NUM_SCOPE)
    THEN
	BEGIN


	! Find the inner-most routine containing the declaration of this symbol.
	! This is the routine to which the invocation number must apply.
	!
	ROUTPTR = .RSTPTR;
	WHILE .ROUTPTR[RST$B_KIND] NEQ RST$K_ROUTINE DO
	    BEGIN
	    IF .ROUTPTR[RST$B_KIND] EQL RST$K_MODULE
	    THEN
		BEGIN
		DBG$NPATHDESC_TO_CS(.PATHNAME, PATHSTRING);
		SIGNAL(DBG$_MISINVNUM, 1, .PATHSTRING);
		END;

	    ROUTPTR = .ROUTPTR[RST$L_UPSCOPEPTR];
	    END;


	! Now make sure the invocation number was indeed appended to that
	! routine name in the pathname.
	!
	PNAME = .PATHVEC[.PATHNAME[PTH$B_LOCINVOC] - 1];
	RNAME = DBG$GET_DST_NAME(.ROUTPTR[RST$L_DSTPTR]);
	IF CH$NEQ(.PNAME[0], PNAME[1], .RNAME[0], RNAME[1], 0)
	THEN
	    BEGIN
	    DBG$NPATHDESC_TO_CS(.PATHNAME, PATHSTRING);
	    SIGNAL(DBG$_MISINVNUM, 1, .PATHSTRING);
	    END;


	! All looks good.  Create the Invocation Number RST Entry along with a
	! new copy of the symbol's RST entry if the number is non-zero.
	!
	IF .PATHNAME[PTH$L_INVOCNUM] NEQ 0
	THEN
	    RSTPTR = BUILD_INVOC_RST(.RSTPTR, .PATHNAME[PTH$L_INVOCNUM]);

	END


    ! If this symbol was specified with a numbered scope (i.e. 2\X) and the
    ! invocation number is non-zero, create an Invocation Number RST Entry
    ! for the symbol.
    !
    ELSE IF .HAVE_NUM_SCOPE AND (.NUMSCP_INVOC_NUM NEQ 0)
    THEN
	RSTPTR = BUILD_INVOC_RST(.RSTPTR, .NUMSCP_INVOC_NUM)


    ! And also, if the symbol was a simple symbol without any pathname qualifi-
    ! cation, do the proper up-level addressing (if any) in the scope we found
    ! it in to get the proper invocation number for the symbol.
    !
    ELSE IF (.PATHNAME[PTH$B_LOCINVOC] EQL 0) AND
	    (.PATHNAME[PTH$B_PATHCNT] EQL 1)
    THEN
	RSTPTR = FOLLOW_STATIC_LINK(.RSTPTR, .SCOPE);


    ! Now return the selected symbol's SYMID and KIND to the caller.
    !
    SYMID[0] = .RSTPTR;
    KIND[0] = .RSTPTR[RST$B_KIND];


    ! Release all candidate blocks on the candidate list to the memory pool.
    !
    INCR I FROM 1 TO .NCANDS DO DBG$REL_MEMORY(.CANDLST[.I]);


    ! Mark this symbol's RST entry as being referenced by adding its address
    ! to the RST Reference List (RST$REF_LIST).  This only says that the RST
    ! entry is referenced by the current Debug command.  Note that we expand
    ! the list memory block if it is about to overflow.
    !
    IF .RST$REF_LIST[1] EQL .RST$REF_LIST[0]
    THEN
	BEGIN
	RST$REF_LIST[0] = .RST$REF_LIST[0] + 20;
	NEWREFLIST = DBG$GET_MEMORY(.RST$REF_LIST[0] + 2);
	CH$MOVE(4*(.RST$REF_LIST[1] + 2), .RST$REF_LIST, .NEWREFLIST);
	DBG$REL_MEMORY(.RST$REF_LIST);
	RST$REF_LIST = .NEWREFLIST;
	END;

    RST$REF_LIST[1] = .RST$REF_LIST[1] + 1;
    RST$REF_LIST[.RST$REF_LIST[1] + 1] = .RSTPTR;


    ! Mark the symbol's module as being the Most Recently Referenced module.
    ! Then return.
    !
    IF .MODRSTPTR NEQ .LRUM$MOST_RECENT THEN DBG$RST_MOST_RECENT(.MODRSTPTR);
    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_GETSYMOFF(ADDR, SYMID, KIND, OFFSET): NOVALUE =
!
! FUNCTION:
!	This routine accepts a 32-bit virtual address and attempts to symbolize
!	it, returning a symbol and an offset.  If the address is found to be an
!	instruction address, the routine will attempt to symbolize it as a line
!	number and a byte offset from the start of that line.  If no line number
!	can be found (as in MACRO modules, for example), it will try to symbol-
!	ize the address as a label, routine name, or module name with an offset.
!
!	If the address turns out to be a data address (that is, if it turns out
!	not to be in any routine's instruction address range), this routine will
!	see if it corresponds to any static data item.  If so, that data symbol
!	and an offset from it will be returned.  Symbolization will not be done
!	to array elements or record components--only the outer level static data
!	item will be returned as the symbol.  If no suitable symbolization can
!	be found at all, no symbol is returned (SYMID is set to zero) and the
!	absolute virtual address is returned as the offset.
!
!	DBG$STA_GETSYMOFF is called to symbolize addresses only in certain cir-
!	cumstances.  One is when the user program has faulted somewhere (with an
!	access violation, for example) and the fault address must be symbolized
!	and displayed in an understandable form.  Another is when VAX machine
!	instructions are displayed symbolically (through E/I or STEP, for exam-
!	ple) and operands must be displayed in as symbolic a form as possible.
!
! INPUTS:
!	ADDR	- The 32-bit virtual address to be symbolized, passed by value.
!
!	SYMID	- The address of a longword location where the "symbol identi-
!		  fier" should be returned.  The "symbol identifier" is a value
!		  which uniquely identifies the returned symbol.  This value is
!		  not directly understood outside the symbol table access rou-
!		  tines, but can be passed to various other symbol table access
!		  routines to extract information about the symbol.
!
!	KIND	- The address of a longword location where the "kind" of the
!		  SYMID symbol should be returned.  KIND specifies whether SYMID
!		  identifies a routine, a line, or a data item, etc.  See the
!		  OUTPUTS section below for more detail.
!
!	OFFSET	- The address of a longword location where the byte offset from
!		  the SYMID symbol should be returned.
!
! OUTPUTS:
!	SYMID	- A symbol identifier which uniquely identifies the symbol
!		  which best symbolizes ADDR is returned to SYMID.  This symbol
!		  identifier can then be passed to any symbol table access rou-
!		  tine which accepts a SYMID parameter.  If no suitable symbol
!		  can be found, a zero is returned to SYMID.
!
!	KIND	- The "kind" of the SYMID symbol is returned to KIND.  This is
!		  a small integer value with the following possible values:
!
!			RST$K_INVALID	-- No symbol was found (SYMID = 0)
!			RST$K_MODULE	-- SYMID is a Module
!			RST$K_ROUTINE	-- SYMID is a Routine
!			RST$K_BLOCK	-- SYMID is a Block
!			RST$K_ENTRY	-- SYMID is an Entry Point
!			RST$K_LABEL	-- SYMID is a Label
!			RST$K_LINE	-- SYMID is a Line
!			RST$K_DATA	-- SYMID is a Data Item
!
!	OFFSET	- The byte offset of ADDR relative to the SYMID symbol is
!		  returned to OFFSET.  If KIND (and SYMID) is zero, this
!		  offset is simply the original absolute virtual address.
!
!	No value is returned by DBG$STA_GETSYMOFF.
!

    BEGIN

    LOCAL
	XXXXXXXXXX;			! --------------------------------------



    ! Code starts here.
    !
    ! --------------------------------------------------------------------------
    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_LOCK_SYMID(SYMID_LIST_PTR): NOVALUE =
!
! FUNCTION
!	This routine "locks" a list of SYMIDs in the RST so that the correspond-
!	ing RST entries cannot be released to the free memory pool.  SYMIDs are
!	locked this way only when they will be saved in a Primary Descriptor or
!	elsewhere accross Debug commands.  SYMIDs used to represent "." (current
!	location) or breakpoint locations are examples of SYMIDs which must be
!	locked accross commands.  A locked SYMID remains locked until it is ex-
!	plicitly unlocked by a call to DBG$STA_UNLOCK_SYMID.
!
!	The actual locking procedure involves incrementing the Reference Count
!	in the SYMID's RST entry and in most RST entries directly accessible
!	from this RST entry.  This includes all RST entries upscope from the
!	present entry and all Data Type RST Entries attached to the up-scope
!	chain.
!
! INPUTS
!	SYMID_LIST_PTR - A pointer to a linked list of Linked List Nodes, where
!		  each node contains a forward link and a SYMID value.  Each
!		  SYMID on the list is "locked" in the RST by incrementing the
!		  reference count of the corresponding RST entry.
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
	LISTPTR: REF DBG$LINK_NODE;	! Pointer to current linked list node



    ! Loop through all the SYMIDs (i.e., RST pointers) on the linked list.
    ! For each SYMID on the list, call ADD_TO_REF_COUNT to increment the RST
    ! entry's reference count.
    !
    LISTPTR = .SYMID_LIST_PTR;
    WHILE .LISTPTR NEQ 0 DO
	BEGIN
	ADD_TO_REF_COUNT(.LISTPTR[DBG$L_LINK_NODE_VALUE], +1);
	LISTPTR = .LISTPTR[DBG$L_LINK_NODE_LINK];
	END;

    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_LOOKUP_GBL(NAMEPTR) =
!
! FUNCTION
!	This routine looks up a symbol in the Global Symbol Table (the GST)
!	and only in the GST.  It accepts the symbol name as input, looks up
!	that symbol in the GST, and returns a pointer to an RST entry for the
!	global symbol.  The actual lookup is done in two stages.  First the
!	RST Hash Table is searched for the symbol name, but an RST entry is
!	only accepted if its RST$V_GLOBAL bit is set.  If such an entry is
!	found, the symbol is necessarily in the GST because the RST entry was
!	created by a previous call on this routine.  Second, if no RST entry
!	was found, the GST itself is searched sequentially for the symbol.
!	If the symbol is found, an RST entry is created for it and a pointer
!	to that entry is returned.  If the symbol is not found in the GST, a
!	value of zero is returned.
!
!	The whole RST and GST search is suppressed if the DBG$GB_NO_GLOBALS
!	flag is set.  In this case, the routine always returns zero.
!
! INPUTS
!	NAMEPTR - A pointed to the symbol name to be looked up in the GST.
!		  The name must be represented by a Counted ASCII string.
!
! OUTPUTS
!	A pointer to an RST entry for the global symbol is returned as the
!		  routine value.  If the symbol is not in the GST, zero is
!		  returned as the routine value.
!

    BEGIN

    MAP
	NAMEPTR: REF VECTOR[,BYTE];	! Pointer to Counted ASCII symbol name


    LOCAL
	GSTPTR: REF GST_RECORD,		! Pointer to the current GST record
	RSTPTR: REF RST$ENTRY;		! Pointer to current symbol's RST entry
					!      symbol is a routine entry point



    ! If the Global Symbol Table is suppressed, return zero right away.
    !
    IF .DBG$GB_NO_GLOBALS THEN RETURN 0;


    ! Search the RST Hash Table for a symbol with the desired name which is
    ! also marked as being global (meaning that it is derived from the GST).
    ! If we find such an RST entry, we return its address to the caller.
    !
    DBG$HASH_FIND_SETUP(.NAMEPTR);
    WHILE TRUE DO
	BEGIN
	RSTPTR = DBG$HASH_FIND(.NAMEPTR);
	IF .RSTPTR EQL 0 THEN EXITLOOP;
	IF .RSTPTR[RST$V_GLOBAL] THEN RETURN .RSTPTR;
	END;


    ! We did not find the symbol in the RST.  We therefore loop over the whole
    ! Global Symbol Table, looking for a symbol with the desired name.  If we
    ! find the symbol, we build an RST entry for it and return the RST address.
    !
    DBG$GET_NXT_GST(1);
    WHILE TRUE DO
	BEGIN
	GSTPTR = DBG$GET_NXT_GST(0);
	IF .GSTPTR EQL 0 THEN EXITLOOP;


	! Do a CASE on the GST record type and handle each type separately.
	!
	CASE .GSTPTR[GST_ENTRY_TYPE] FROM GST_LOWEST TO GST_HIGHEST OF
	    SET


	    ! Handle the definition of a global symbol.  If this is the symbol
	    ! we are looking for, build an RST entry for it and return a pointer
	    ! to that RST entry.  Otherwise, continue the search.
	    !
	    [GST_GLOBAL_DEFN]:
		BEGIN
		IF CH$EQL(.NAMEPTR[0], NAMEPTR[1],
			.GSTPTR[GST_G_NAME_CS], GSTPTR[GST_G_NAME_ADDR])
		THEN
		    RETURN DBG$GST_TO_RST(.NAMEPTR, .GSTPTR[GST_VALUE], FALSE);

		END;


	    ! Handle the definition of a global routine or a global entry point.
	    ! If this is the symbol we are looking for, build an RST entry for
	    ! it and return the entry's address.  Otherwise continue the search.
	    !
	    [GST_PROC_DEFN,
	     GST_ENTRY_DEFN]:
		BEGIN
		IF CH$EQL(.NAMEPTR[0], NAMEPTR[1],
			.GSTPTR[GST_E_NAME_CS], GSTPTR[GST_E_NAME_ADDR])
		THEN
		    RETURN DBG$GST_TO_RST(.NAMEPTR, .GSTPTR[GST_VALUE], TRUE);

		END;


	    ! We ignore all other kinds of GST records.
	    !
	    [INRANGE, OUTRANGE]:
		0;

	    TES;

	END;				! End of WHILE loop over the GST


    ! We did not find the symbol in the Global Symbol Table--just return zero.
    !
    RETURN 0;

    END;

GLOBAL ROUTINE DBG$STA_NOEVALBIT(SYMID) =
!
! FUNCTION
!	This routine determines whether the DST$V_MS_NOEVAL bit is set in the
!	Value Spec for a specified symbol.  This bit is used by PL/I to suppress
!	re-evaluation of Value Specs when such Value Specs can have side effects
!	(as is the case for certain kinds of BASED variables).  The side effects
!	are acceptable when such a symbol is initially examined, but not when
!	the symbol is reexamined via the dot pseudosymbol.  Thus, when dot is
!	bound to a symbol with the DST$V_MS_NOEVAL bit set in its Value Spec,
!	that Value Spec is not reevaluated.  The PL/I-specific code makes this
!	check, but this routine returns the value of the bit.
!
!	The DST$V_MS_NOEVAL bit can only occur in a Value Spec containing a
!	Materialization Spec.  If the Value Spec does not have that form, this
!	routine always returns FALSE--the bit is treated as not set.
!
! INPUTS
!	SYMID	- The SYMID of the symbol whose DST$V_MS_NOEVAL bit is to be
!		  interrogated.
!
! OUTPUTS
!	The routine returns TRUE if the DST$V_MS_NOEVAL bit is set in the
!		  symbol's value spec.  If the bit is not set or if the bit
!		  is not present at all in the symbol's value spec, FALSE
!		  is returned.
!

    BEGIN

    MAP
	SYMID: REF RST$ENTRY;		! Pointer to input symbol's RST entry

    LOCAL
	DSTPTR: REF DST$RECORD,		! Pointer to symbol's DST record.
	MSPTR: REF DST$MATER_SPEC,	! Pointer to DST Materialization Spec
	VSPTR: REF DST$VAL_SPEC;	! Pointer to DST Value Spec



    ! Determine what kind of RST entry SYMID identifies and act accordingly.
    !
    CASE .SYMID[RST$B_KIND] FROM RST$K_KIND_MINIMUM TO RST$K_KIND_MAXIMUM OF
	SET


	! For anything but Data and Type Component symbols, return FALSE.  These
	! symbols do not have value specs containing a DST$V_MS_NOEVAL bit.
	!
	[RST$K_ROUTINE, RST$K_BLOCK,
	 RST$K_ENTRY, RST$K_LABEL,
	 RST$K_LINE, RST$K_TYPE]:
	    RETURN FALSE;


	! For Data and Type Components, do nothing here--we handle them below.
	!
	[RST$K_DATA, RST$K_TYPCOMP]:
	    0;


	! For everything else (including Module), signal an internal error.
	!
	[INRANGE, OUTRANGE]:
	    SIGNAL(DBG$_DEBUGBUG, 1, 186);

	TES;


    ! For the items not yet handled (i.e., for data), we determine the type of
    ! DST record which holds the value specification and act accordingly.
    !
    DSTPTR = .SYMID[RST$L_DSTPTR];
    CASE .DSTPTR[DST$B_TYPE] FROM 0 TO 255 OF
	SET


	! Handle the DST records which can conceivably have Materialization
	! Specs and thus the DST$V_MS_NOEVAL bit.  If the bit exists, return
	! its value; otherwise return FALSE.
	!
	[DSC$K_DTYPE_LOWEST TO DSC$K_DTYPE_HIGHEST,
	 DST$K_BOOL, DST$K_SEPTYP, DST$K_LBLORLIT,
	 DST$K_RECBEG, DST$K_ENUMELT]:
	    BEGIN


	    ! Indirect through any Trailing Value Specs to get to the symbol's
	    ! Value Spec.  If this Value Spec cannot have a Materialization
	    ! Spec, return FALSE right away.
	    !
	    VSPTR = DSTPTR[DST$B_VFLAGS];
	    WHILE .VSPTR[DST$B_VS_VFLAGS] EQL DST$K_VFLAGS_TVS DO
		VSPTR = VSPTR[DST$A_VS_TVS_BASE] + .VSPTR[DST$L_VS_TVS_OFFSET];

	    IF .VSPTR[DST$B_VS_VFLAGS] NEQ DST$K_VS_FOLLOWS THEN RETURN FALSE;


	    ! If this is a Static or Dynamic DST$K_VS_FOLLOWS type Value Spec,
	    ! return the DST$V_MS_NOEVAL bit from the Materialization Spec.
	    !
	    IF (.VSPTR[DST$B_VS_ALLOC] EQL DST$K_VS_ALLOC_STAT) OR
	       (.VSPTR[DST$B_VS_ALLOC] EQL DST$K_VS_ALLOC_DYN)
	    THEN
		BEGIN
		MSPTR = VSPTR[DST$A_VS_MATSPEC];
		RETURN .MSPTR[DST$V_MS_NOEVAL];
		END;


	    ! Any other value in the DST$B_VS_ALLOC field is an error.
	    !
	    SIGNAL(DBG$_INVDSTREC);

	    END;


	! For all DST records which cannot have Materialization Specs in their
	! Value Specs, fall through to return FALSE at the end of the routine.
	!
	[INRANGE]:
	    0;

	TES;


    ! Return FALSE.  If we got here, there is no Materialization Spec.
    !
    RETURN FALSE;

    END;

GLOBAL ROUTINE DBG$STA_RECORD_COMPONENT(RECSYMID, INDEX) =
!
! FUNCTION
!	This routine returns the SYMID of the N-th record component of a record
!	data object.  It accepts as input a pointer to a Data RST Entry of a
!	record ("structure") data object and an index ("N") into the list of
!	record components for the record.  This routine is used mainly to find
!	the logical successor or predecessor of a record component of a known
!	index into the record component list.  In other words, if the current
!	location is the N-th component of a record, its predecessor is the N-1
!	and its successor the N+1 component of the record.  This routine returns
!	a pointer to the Data RST Entry for such a component.
!
!	To accomplish this, the INDEX-th record component is looked up in the
!	component list in the record's Data Type RST Entry.  This gives a
!	pointer to the component's Type Component RST Entry.  A new Data Item
!	RST Entry is then build from the information in the Type Component
!	RST Entry.  This new entry is put on the Temporary RST Entry List and
!	its address is returned as the component SYMID.
!
! INPUTS
!	RECSYMID - The SYMID of the Record data object whose INDEX-th component
!		  is to be returned.
!
!	INDEX	- The index of the desired component into the record component
!		  list for RECSYMID.  The first component of a record has the
!		  INDEX value of 1.
!
! OUTPUTS
!	The SYMID of the INDEX-th component of RECSYMID is returned as the
!		  routine value.  If INDEX is out of range (no such component
!		  number), this routine returns zero.
!

    BEGIN

    MAP
	RECSYMID: REF RST$ENTRY;	! SYMID of record data object

    LOCAL
	FCODE,
	NEWRSTPTR: REF RST$ENTRY,	! Pointer to new Data Item RST Entry
	RSTPTR: REF RST$ENTRY,		! Pointer to Type Component RST Entry
	TYPCOMPLST: REF VECTOR[,LONG],	! Pointer to type component list
	TYPEPTR: REF RST$ENTRY;		! Pointer to record's Type RST Entry



    ! Check that RECSYMID points to the Data Item RST Entry for a Record object.
    ! If not, signal an internal DEBUG error.
    !
    IF (.RECSYMID[RST$B_KIND] NEQ RST$K_DATA) THEN SIGNAL(DBG$_DEBUGBUG, 1, 184);

    DBG$STA_SYMTYPE(.RECSYMID,FCODE,TYPEPTR);

    IF (.FCODE EQL RST$K_TYPE_ARRAY)
    THEN
	BEGIN
	LOCAL DSCADDR,NDIMS,DIMVECPTR,BITSIZE;
	DBG$STA_TYP_ARRAY(.TYPEPTR,DSCADDR,TYPEPTR,NDIMS,DIMVECPTR,BITSIZE);
	END;

   IF (.TYPEPTR[RST$B_FCODE] NEQ RST$K_TYPE_RECORD) THEN SIGNAL(DBG$_DEBUGBUG, 1, 184);

    ! If the INDEX value is out of range, return zero to the caller.  Otherwise,
    ! pick up a pointer to the INDEX-th Type Component RST Entry.
    !
    IF (.INDEX LEQ 0) OR (.INDEX GTR .TYPEPTR[RST$L_TYPCOMPCNT]) THEN RETURN 0;
    TYPCOMPLST = TYPEPTR[RST$A_TYPCOMPLST];
    RSTPTR = .TYPCOMPLST[.INDEX - 1];
    IF .RSTPTR[RST$B_KIND] NEQ RST$K_TYPCOMP THEN SIGNAL(DBG$_DEBUGBUG, 1, 184);


    ! Now construct a Data Item RST Entry from the Type Component RST Entry,
    ! make its up-scope pointer point to the RECSYMID Data Item RST Entry,
    ! and return the address (i.e., SYMID) of the new RST entry to the caller.
    ! Note that the new RST entry is put on the Temporary RST Entry List.
    !
    NEWRSTPTR = DBG$GET_MEMORY(RST$K_DATENTSIZ);
    NEWRSTPTR[RST$L_HASH_FLINK] = .RST$TEMP_LIST;
    RST$TEMP_LIST = .NEWRSTPTR;
    NEWRSTPTR[RST$L_DSTPTR] = .RSTPTR[RST$L_DSTPTR];
    NEWRSTPTR[RST$L_UPSCOPEPTR] = .RECSYMID;
    NEWRSTPTR[RST$B_KIND] = RST$K_DATA;
    NEWRSTPTR[RST$L_TYPEPTR] = .RSTPTR[RST$L_TYPEPTR];
    RETURN .NEWRSTPTR;

    END;

GLOBAL ROUTINE DBG$STA_RECORD_INDEX(RECSYMID, COMPSYMID) =
!
! FUNCTION
!	This routine accepts the SYMID of a Record data object and the SYMID
!	of a component of that record and it returns the index of the component
!	in the record's component list.  Both the Record and Component SYMIDs
!	should point to Data Item RST Entries (kind is RST$K_DATA).  The re-
!	turned index starts at 1 so that the index of the first component of
!	the record is 1, the index of the second component is 2, and so forth.
!	This routine is used together with routine DBG$STA_RECORD_COMPONENT in
!	the processing of logical predecessors and successors.
!
!	If the COMPSYMID object is not a component of the RECSYMID object or if
!	the RECSYMID object is not of a Record type, an internal DEBUG error is
!	signalled.
!
!	The routine does it job by searching the Type Component List in the
!	Data Type RST Entry for the record type for a Type Component RST Entry
!	which has the same DST pointer as the COMPSYMID Data Item RST Entry.
!	When such an entry is found, its index in the list is returned.
!
! INPUTS
!	RECSYMID - The SYMID of a Record ("structure") data object.  Its kind
!		  must be RST$K_DATA.
!
!	COMPSYMID - The SYMID of a component of the RECSYMID record.  Its kind
!		  must also be RST$K_DATA.
!
! OUTPUTS
!	The index of the COMPSYMID data object in the record component list for
!		  the RECSYMID data record.  The first component has index 1.
!

    BEGIN

    MAP
	RECSYMID: REF RST$ENTRY,	! Pointer to Data RST Entry for record
	COMPSYMID: REF RST$ENTRY;	! Pointer to Data RST Entry for a com-
					!      ponent within the above record

    LOCAL
	FCODE,
	RSTPTR: REF RST$ENTRY,		! Pointer to Type Component RST Entry
	TYPCOMPLST: REF VECTOR[,LONG],	! Pointer to type component list in the
					!      Data Type RST Entry
	TYPEPTR: REF RST$ENTRY;		! Pointer to Type RST Entry for record



    ! Make sure RECSYMID points to a Data Item RST Entry for a record and that
    ! COMPSYMID points to a Data Item RST Entry.  Get a pointer to the Type RST
    ! Entry for the record type.
    !
    IF (.RECSYMID[RST$B_KIND] NEQ RST$K_DATA) OR
       (.COMPSYMID[RST$B_KIND] NEQ RST$K_DATA)
    THEN
	SIGNAL(DBG$_DEBUGBUG, 1, 185);

    DBG$STA_SYMTYPE(.RECSYMID,FCODE,TYPEPTR);

    IF (.FCODE EQL RST$K_TYPE_ARRAY)
    THEN
	BEGIN
	LOCAL DSCADDR,NDIMS,DIMVECPTR,BITSIZE;
	DBG$STA_TYP_ARRAY(.TYPEPTR,DSCADDR,TYPEPTR,NDIMS,DIMVECPTR,BITSIZE);
	END;

   IF (.TYPEPTR[RST$B_FCODE] NEQ RST$K_TYPE_RECORD) THEN SIGNAL(DBG$_DEBUGBUG, 1, 185);

    ! Now loop through the record components for the RECSYMID Record Data Type.
    ! For each component, we get an index and a pointer to the corresponding
    ! Type Component RST Entry.  If that Type Component RST Entry has the same
    ! DST pointer as COMPSYMID, we return that component's index.
    !
    TYPCOMPLST = TYPEPTR[RST$A_TYPCOMPLST];
    INCR INDEX FROM 1 TO .TYPEPTR[RST$L_TYPCOMPCNT] DO
	BEGIN
	RSTPTR = .TYPCOMPLST[.INDEX - 1];
	IF .RSTPTR[RST$L_DSTPTR] EQL .COMPSYMID[RST$L_DSTPTR] THEN RETURN .INDEX;
	END;


    ! We did not find COMPSYMID in the component list.  Signal an error.
    !
    SIGNAL(DBG$_DEBUGBUG, 1, 185);
    RETURN 0;

    END;

GLOBAL ROUTINE DBG$STA_SAME_DST_OBJECT(SYMID1, SYMID2) =
!
! FUNCTION
!	This routine determines whether two SYMIDs refer to the same DST object.
!	To do so, it checks that the corresponding RST entries have the same
!	kind and the same DST pointer.  (Data records and their types point to
!	the same DST record; hence the kind must be checked as well.)
!
! INPUTS
!	SYMID1	- The SYMID of the first of the two symbols to be compared.
!
!	SYMID2	- The SYMID of the second of the two symbols to be compared.
!
! OUTPUTS
!	The value TRUE is returned if both symbols are of the same kind and have
!		  the same SYMID.  The value FALSE is returned otherwise.
!

    BEGIN

    MAP
	SYMID1: REF RST$ENTRY,		! Pointer to first RST entry
	SYMID2: REF RST$ENTRY;		! Pointer to second RST entry



    ! Return the desired boolean value.
    !
    IF (.SYMID1[RST$B_KIND] EQL .SYMID2[RST$B_KIND]) AND
       (.SYMID1[RST$L_DSTPTR] EQL .SYMID2[RST$L_DSTPTR])
    THEN
	RETURN TRUE;

    RETURN FALSE;

    END;

GLOBAL ROUTINE DBG$STA_SETCONTEXT(SYMID): NOVALUE =
!
! FUNCTION
!	This routine sets up the context needed for subsequent DST value spec
!	evaluations.  This specifically means determining the VAX CALL frame
!	and associated register values which are to be used for evaluating value
!	specs and determining symbol addresses.  This routine must therefore
!	be called before routines DBG$STA_SYMTYPE, DBG$STA_SYMVALUE, and all
!	routines of the form DBG$STA_TYPE_xxx.  Failure to do so may cause in-
!	correct value computations.
!
!	The context is defined by an input SYMID.  The innermost invocable enti-
!	ty (i.e. routine) in the environment of the symbol's declaration is
!	looked up in the VAX CALL stack and the associated register set is loc-
!	ated.  If an invocation number is attached to the SYMID, that is taken
!	into account.  Context will not be established (and the previous context
!	will be deleted) if the input SYMID is zero or if the symbol's environ-
!	ment is not presently active.  If context is not established, subsequent
!	value specs may still be evaluated, but if they refer to any register
!	values or locations (i.e., to any context) an error will be signalled.
!
! INPUTS
!	SYMID	- The SYMID of the symbol whose environment of declaration is to
!		  be used to define the context of subsequent value spec.  SYMID
!		  must be of kind RST$K_DATA or RST$K_TYPCOMP.  If SYMID is zero
!		  no context is established.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	SYMID: REF RST$ENTRY;		! Pointer to the input RST entry

    OWN
	SPVALUE: REF VECTOR[,LONG];	! Current CALL frame's SP value

    LOCAL
	CURRENT_REG: REF VECTOR[,LONG],	! Pointer to vector of current register
					!      values (at top of stack)
	ENDADDR,			! The routine's PC end address
	FRAME_FOUND_FLAG,		! Flag set to TRUE when a CALL frame for
					!      the desired routine is found
	FRAMEPTR: REF BLOCK[,BYTE],	! Pointer to current VAX CALL frame
	GOOD_R0,			! Set to TRUE if R0 save area is good
					!      (R0 is volatile in subr. calls)
	GOOD_R1,			! Set to TRUE if R1 save area is good
	INVOC_COUNT,			! Number of invocations of routine
					!      found so far in CALL stack
	INVOCNUM,			! The desired invocation number
	INVPTR: REF RST$ENTRY,		! Pointer to Invocation Number RST Entry
	J,				! CALL frame register-vector index
	PCVAL,				! Current CALL frame's PC value
	REGMASK: BITVECTOR[16],		! Register save mask from the CALL frame
	REGPTR: REF VECTOR[,LONG],	! Pointer to a register's save location
	REGSAVELOC: REF VECTOR[,LONG],	! Pointer to CALL frame register save
					!      area for registers R0 - R11
	REGVEC: VECTOR[17, LONG],	! Vector of pointers to save areas for
					!      the current frame's registers
	ROUTPTR: REF RST$ENTRY,		! Pointer to Routine RST Entry of rout-
					!      ine to look for in CALL stack
	RSTPTR: REF RST$ENTRY,		! RST pointer from SAT entry
	SATPTR: REF SAT$ENTRY,		! Pointer to Static Address Table entry
					!      for possible nested routine
	STARTADDR;			! The routine's PC start address



    ! If the input SYMID is zero, clear the current context and return.
    !
    IF .SYMID EQL 0
    THEN
	BEGIN
	CURRENT_REG = DBG$GL_RUNFRAME[DBG$L_USER_REGS];
	DBG$REG_SYMID = 0;
	INCR I FROM 0 TO 16 DO
	    BEGIN
	    DBG$REG_VECTOR[.I] = 0;
	    DBG$REG_VALUES[.I] = .CURRENT_REG[.I];
	    END;

	RETURN;
	END;


    ! We have a non-zero SYMID.  Make sure SYMID is of a valid kind.
    !
    IF (.SYMID[RST$B_KIND] EQL RST$K_TYPE)
    THEN
	SIGNAL(DBG$_DEBUGBUG, 1, 184);


    ! Set the current context to "not established".  We do this by zeroing all
    ! the register save location pointers in DBG$REG_VECTOR.  Also save the in-
    ! put SYMID for later use in error messages.
    !
    INCR I FROM 0 TO 16 DO DBG$REG_VECTOR[.I] = 0;
    DBG$REG_SYMID = .SYMID;


    ! Find the RST entry and PC address range of the inner-most routine contain-
    ! ing the declaration of the SYMID symbol.  If no such routine exists (if
    ! the symbol is declared at the module level) return with no context set.
    !
    ROUTPTR = .SYMID;
    WHILE .ROUTPTR[RST$B_KIND] NEQ RST$K_ROUTINE DO
	BEGIN
	IF .ROUTPTR[RST$B_KIND] EQL RST$K_MODULE THEN RETURN;
	ROUTPTR = .ROUTPTR[RST$L_UPSCOPEPTR];
	END;

    STARTADDR = .ROUTPTR[RST$L_STARTADDR];
    ENDADDR = .ROUTPTR[RST$L_ENDADDR];


    ! Determine what the corresponding invocation number is (default is zero).
    !
    INVOCNUM = 0;
    IF .SYMID[RST$V_INVOCNUM]
    THEN
	BEGIN
	INVPTR = .SYMID[RST$L_SYMCHNPTR];
	INVOCNUM = .INVPTR[RST$L_INVOCNUM];
	END;


    ! Initialize the PC, the Frame Pointer, and the register values to their
    ! current (top of stack) values.
    !
    PCVAL = .DBG$GL_RUNFRAME[DBG$L_USER_PC];
    FRAMEPTR = .DBG$GL_RUNFRAME[DBG$L_USER_FP];
    CURRENT_REG = DBG$GL_RUNFRAME[DBG$L_USER_REGS];
    INCR I FROM 0 TO 16 DO
	REGVEC[.I] = CURRENT_REG[.I];


    ! Note that the addresses for the R0 and R1 save areas are good at this
    ! point.  They will not be good if a subroutine call is encountered in
    ! the stack which does not explicitly save them since R0 and R1 are con-
    ! sidered to be volatile register across subroutine calls.
    !
    GOOD_R0 = TRUE;
    GOOD_R1 = TRUE;


    ! Now search through the CALL frames on the VAX stack looking for the proper
    ! invocation of the ROUTPTR routine.  Pick up all register save addresses in
    ! the stack along the way.
    !
    INVOC_COUNT = 0;
    WHILE TRUE DO
	BEGIN


	! If we got to the bottom of the stack without finding the desired
	! invocation, return with the context not set.
	!
	IF (.PCVAL EQL 0)               OR
	   (.PCVAL EQL DBG$PSEUDO_EXIT) OR
	   (.FRAMEPTR[SF$A_HANDLER] EQL DBG$FINAL_HANDL)
	THEN
	    RETURN;


	! If this is a CALL frame of the routine we are looking for, increment
	! the invocation count.  When that reaches the desired invocation number
	! we have found the desired CALL frame and exit the loop.
	!
	IF (.PCVAL GEQU .STARTADDR) AND (.PCVAL LEQU .ENDADDR)
	THEN
	    BEGIN


	    ! The PC from this CALL frame is in the address range of the routine
	    ! we are looking for.  However, to make sure the PC is not really in
	    ! a nested routine within the desired routine, we search the Module
	    ! SAT starting at the desired routine's SAT entry looking for nested
	    ! routines which cover the CALL frame's PC value.  If we find such a
	    ! routine, the CALL frame is not for the desired routine.
	    !
	    FRAME_FOUND_FLAG = TRUE;
	    SATPTR = .ROUTPTR[RST$L_RTNSATPTR];
	    SATPTR = .SATPTR[SAT$L_FLINK];
	    WHILE TRUE DO
		BEGIN


		! If there are no more SAT entries in the chain or if they no
		! longer cover the PCVAL address, exit the SAT loop.
		!
		IF .SATPTR EQL 0 THEN EXITLOOP;
		IF .SATPTR[SAT$L_START] GTRU .PCVAL THEN EXITLOOP;


		! If this SAT entry is for a routine which covers the PCVAL
		! address, we clear FRAME_FOUND_FLAG because the PC is in this
		! nested routine instead of the routine we are looking for.
		!
		RSTPTR = .SATPTR[SAT$L_RSTPTR];
		IF (.PCVAL GEQU .SATPTR[SAT$L_START]) AND
		   (.PCVAL LEQU .SATPTR[SAT$L_END])   AND
		   (.RSTPTR[RST$B_KIND] EQL RST$K_ROUTINE)
		THEN
		    BEGIN
		    FRAME_FOUND_FLAG = FALSE;
		    EXITLOOP;
		    END;


		! Link on to the next SAT entry.
		!
		SATPTR = .SATPTR[SAT$L_FLINK];
		END;


	    ! If the CALL frame we found really is for the desired routine,
	    ! check the invocation count.  If this is the desired invocation,
	    ! exit the CALL stack loop.  Otherwise, increment the invocation
	    ! count and keep looping.
	    !
	    IF .FRAME_FOUND_FLAG
	    THEN
		BEGIN
		IF .INVOC_COUNT EQL .INVOCNUM THEN EXITLOOP;
		INVOC_COUNT = .INVOC_COUNT + 1;
		END;

	    END;


	! We have not found the desired frame yet.  Dig out the register save
	! locations in this CALL frame and save those addresses in REGVEC.
	!
	REGMASK = .FRAMEPTR[SF$W_SAVE_MASK];
	GOOD_R0 = .REGMASK[0];
	GOOD_R1 = .REGMASK[1];
	REGSAVELOC = FRAMEPTR[SF$L_SAVE_REGS];
	J = 0;
	INCR I FROM 0 TO 11 DO
	    BEGIN
	    IF .REGMASK[.I]
	    THEN
		BEGIN
		REGVEC[.I] = REGSAVELOC[.J];
		J = .J + 1;
		END;

	    END;

	REGVEC[12] = FRAMEPTR[SF$L_SAVE_AP];
	REGVEC[13] = FRAMEPTR[SF$L_SAVE_FP];
	REGVEC[14] = SPVALUE;
	REGVEC[15] = FRAMEPTR[SF$L_SAVE_PC];
	REGVEC[16] = FRAMEPTR[SF$W_SAVE_PSW];


	! Determine what the value of SP (the Stack Pointer) will be when this
	! CALL frame is torn down by the RET instruction.  Save that in SPVALUE.
	!
	SPVALUE = REGSAVELOC[.J];
	SPVALUE = .SPVALUE + .FRAMEPTR[SF$V_STACKOFFS];
	IF .FRAMEPTR[SF$V_CALLS] THEN SPVALUE = .SPVALUE + 4*(.SPVALUE[0] + 1);


	! Loop for the next stack frame.
	!
	PCVAL = .FRAMEPTR[SF$L_SAVE_PC];
	FRAMEPTR = .FRAMEPTR[SF$L_SAVE_FP];
	END;


    ! We have found the CALL frame and thus the context we wanted.  Set the
    ! address of each register's save location in DBG$REG_VECTOR and the regis-
    ! ter's value in DBG$REG_VALUES.  This makes the context available to the
    ! value spec routines.  Then return.
    !
    INCR I FROM 0 TO 16 DO
	BEGIN
	REGPTR = .REGVEC[.I];
	DBG$REG_VECTOR[.I] = .REGPTR;
	IF .REGPTR NEQ 0 THEN DBG$REG_VALUES[.I] = .REGPTR[0];
	END;

    IF (NOT .GOOD_R0) OR (NOT .GOOD_R1) THEN DBG$REG_VECTOR[0] = 0;
    IF (NOT .GOOD_R1) THEN DBG$REG_VECTOR[1] = 0;
    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_SETREGISTERS: NOVALUE =
!
! FUNCTION
!	This routine re-sets all register values in the current context (as
!	established by DBG$STA_SETCONTEXT) from the DBG$REG_VALUES vector.
!	This is done by copying each register's value from DBG$REG_VALUES to
!	the register save location in the VAX CALL stack (or in the Debugger's
!	save area for the top of stack register set).  The addresses of these
!	save locations is given by DBG$REG_VECTOR.  This routine must be called
!	at the end of each DEPOSIT command since this is the command which may
!	have changed the values of the registers in the current context.
!
!	As a side effect, this routine also clears the current context.  It is
!	thus necessary to call DBG$STA_SETCONTEXT again before evaluating more
!	value specs containing register references.
!
! INPUTS
!	DBG$REG_VECTOR and DBG$REG_VALUES are the implicit inputs.  There are
!	no input parameters.
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
	REGPTR: REF VECTOR[,LONG],	! Pointer to register save location
	PSWPTR: REF VECTOR[,WORD];	! Pointer to PSW save location



    ! Loop over the register set, re-setting all register values we can in the
    ! current context.  Note that SP (R14) cannot be explicitly restored.
    !
    DBG$REG_VECTOR[14] = 0;
    INCR I FROM 0 TO 15 DO
	BEGIN
	REGPTR = .DBG$REG_VECTOR[.I];
	IF .REGPTR NEQ 0 THEN REGPTR[0] = .DBG$REG_VALUES[.I];
	DBG$REG_VECTOR[.I] = 0;
	END;


    ! Also re-set the Processor Status Word (PSW) in its save location.
    ! Then return.
    !
    PSWPTR = .DBG$REG_VECTOR[16];
    IF .PSWPTR NEQ 0 THEN PSWPTR[0] = .DBG$REG_VALUES[16];
    DBG$REG_VECTOR[16] = 0;
    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_SYMID_IN_FRAME(SYMID, SYMFRAME) =
!
! FUNCTION
!	This routine is called during the processing of the dot pseudosymbol.
!	It determines whether a symbol associated with a given call frame is
!	still active in memory.  It accepts the symbol's SYMID and its associ-
!	ated frame pointer, as originally returned by DBG$STA_SYMVALUE and
!	saved in the symbol's Primary Descriptor, as inputs.  If the call frame
!	given by that frame pointer is still in the call stack (at the same
!	address and for the same routine), this routine indicates this by re-
!	turning the input symbol's SYMID as its output.  This output SYMID is
!	the same as the input SYMID unless the invocation number is now differ-
!	ent.  (The invocation number can be different since the user program
!	can execute between the definition and the accessing of dot.)
!
!	If the call frame is no longer there, the routine indicates this by
!	returning a zero.  This means that the symbol name is longer associated
!	with the dot location; the symbol is no longer active.  Dot can there-
!	for only be identified by its virtual address.
!
!	The frame pointer returned by DBG$STA_SYMVALUE is zero if the symbol is
!	static.  When a zero frame pointer is input to this routine, the output
!	is a SYMID for the input symbol with no invocation number specified.  A
!	static or literal symbol cannot become inactive, even if the call frame
!	of the declaring routine disappears, and the invocation number is not
!	significant.
!
! INPUTS
!	SYMID	- The SYMID of the symbol to be located in the SYMFRAME stack
!		  frame.  This should be the SYMID saved in the Primary Descrip-
!		  tor and associated with the SYMFRAME frame pointer value.
!
!	SYMFRAME - The Frame Pointer associated with the SYMID symbol.  This
!		  should be the Frame Pointer saved in the Primary Descriptor
!		  and originally returned by DBG$STA_SYMVALUE for the SYMID
!		  symbol.
!
! OUTPUTS
!	If a call frame for the routine in which SYMID is declared exists at
!		  the location given by SYMFRAME or if SYMFRAME is zero, the
!		  symbol's SYMID is returned as the routine value.  This out-
!		  put SYMID is normally the same as the input SYMID, but will
!		  be different if the SYMFRAME frame's invocation number is
!		  now different.  If the call frame is no longer present at
!		  the SYMFRAME location, zero is returned as the routine value.
!

    BEGIN

    MAP
	SYMID: REF RST$ENTRY;		! Pointer to input symbol's RST entry

    LOCAL
	BASE_RSTPTR: REF RST$ENTRY,	! Pointer to "base" RST entry for SYMID
					!      symbol.  "Base" RST entry has
					!      zero invocation number and is
					!      entered in the RST Hash Table.
	ENDADDR,			! The routine's PC end address
	FRAMEPTR: REF BLOCK[,BYTE],	! Pointer to current VAX call frame
	INVOC_COUNT,			! Number of invocations of routine
					!      found so far in call stack
	INVOCNUM,			! Invocation number of the input SYMID
	INVPTR: REF RST$ENTRY,		! Pointer to Invocation Number RST Entry
	PCVAL,				! Current call frame's PC value
	ROUTPTR: REF RST$ENTRY,		! Pointer to Routine RST Entry of rout-
					!      ine to look for in call stack
	STARTADDR;			! The routine's PC start address



    ! If the input SYMID is zero, signal an error.  Also, if it is non-zero,
    ! make sure SYMID is of a valid kind.
    !
    IF .SYMID EQL 0 THEN SIGNAL(DBG$_DEBUGBUG, 1, 183);
    IF (.SYMID[RST$B_KIND] EQL RST$K_TYPE)
    THEN
	SIGNAL(DBG$_DEBUGBUG, 1, 184);


    ! SYMID seems to be valid.  If the SYMFRAME frame pointer value is zero,
    ! return the symbol's SYMID, but with the invocation number removed.
    ! In this case, the symbol's value does not depend on any call frame.
    !
    IF .SYMFRAME EQL 0
    THEN
	BEGIN
	BASE_RSTPTR = .SYMID;
	IF .SYMID[RST$V_INVOCNUM]
	THEN
	    BEGIN
	    INVPTR = .SYMID[RST$L_SYMCHNPTR];
	    BASE_RSTPTR = .INVPTR[RST$L_UPSCOPEPTR];
	    END;

	RETURN .BASE_RSTPTR;
	END;


    ! Find the RST entry and PC address range of the inner-most routine contain-
    ! ing the declaration of the SYMID symbol.  If no such routine exists (if
    ! the symbol is declared at the module level), we signal an error since
    ! SYMFRAME should have been zero in this case.
    !
    ROUTPTR = .SYMID;
    WHILE .ROUTPTR[RST$B_KIND] NEQ RST$K_ROUTINE DO
	BEGIN
	IF .ROUTPTR[RST$B_KIND] EQL RST$K_MODULE
	THEN
	    SIGNAL(DBG$_DEBUGBUG, 1, 185);

	ROUTPTR = .ROUTPTR[RST$L_UPSCOPEPTR];
	END;

    STARTADDR = .ROUTPTR[RST$L_STARTADDR];
    ENDADDR = .ROUTPTR[RST$L_ENDADDR];


    ! Determine what the corresponding invocation number is (default is zero).
    !
    INVOCNUM = 0;
    IF .SYMID[RST$V_INVOCNUM]
    THEN
	BEGIN
	INVPTR = .SYMID[RST$L_SYMCHNPTR];
	INVOCNUM = .INVPTR[RST$L_INVOCNUM];
	END;


    ! Initialize the PC and Frame Pointer to their top of stack values.
    ! Then search through the call frames on the VAX stack looking for a
    ! call frame for the ROUTPTR routine at the SYMFRAME location.
    !
    PCVAL = .DBG$GL_RUNFRAME[DBG$L_USER_PC];
    FRAMEPTR = .DBG$GL_RUNFRAME[DBG$L_USER_FP];
    INVOC_COUNT = 0;
    WHILE TRUE DO
	BEGIN


	! If we got to the bottom of the stack without finding the SYMFRAME
	! call frame, return zero (the frame is no longer there).
	!
	IF (.PCVAL EQL 0)               OR
	   (.PCVAL EQL DBG$PSEUDO_EXIT) OR
	   (.FRAMEPTR[SF$A_HANDLER] EQL DBG$FINAL_HANDL)
	THEN
	    RETURN 0;


	! If this is a call frame of the routine we are looking for, see if it
	! is the SYMFRAME frame.  If so, exit the stack loop.  If the frame is
	! for the desired routine but the wrong frame, increment the invocation
	! number.
	!
	IF (.PCVAL GEQ .STARTADDR) AND (.PCVAL LEQ .ENDADDR)
	THEN
	    BEGIN
	    IF .FRAMEPTR EQL .SYMFRAME THEN EXITLOOP;
	    INVOC_COUNT = .INVOC_COUNT + 1;
	    END;


	! We have not found the desired frame yet.  Loop for next stack frame.
	!
	PCVAL = .FRAMEPTR[SF$L_SAVE_PC];
	FRAMEPTR = .FRAMEPTR[SF$L_SAVE_FP];
	END;


    ! We have found the call frame we wanted at the SYMFRAME location and for
    ! the ROUTPTR routine.  If the invocation number of this frame is the same
    ! as the SYMID invocation number, return the original SYMID.
    !
    IF .INVOC_COUNT EQL .INVOCNUM THEN RETURN .SYMID;


    ! Otherwise, create a new RST entry for the SYMID symbol but with the invo-
    ! cation number of the SYMFRAME CALL frame.  Return the address of this RST
    ! entry as the new SYMID.
    !
    BASE_RSTPTR = .SYMID;
    IF .SYMID[RST$V_INVOCNUM]
    THEN
	BEGIN
	INVPTR = .SYMID[RST$L_SYMCHNPTR];
	BASE_RSTPTR = .INVPTR[RST$L_UPSCOPEPTR];
	END;

    RETURN BUILD_INVOC_RST(.BASE_RSTPTR, .INVOC_COUNT);

    END;

GLOBAL ROUTINE DBG$STA_SYMKIND(SYMID, KIND): NOVALUE =
!
! FUNCTION
!	This routine returns the "kind" of a specified symbol.  The symbol is
!	represented by a symbol identifier as produced by DBG$STA_GETSYMBOL or
!	DBG$STA_GETSYMOFF.  The returned "kind" is the same kind as originally
!	produced by those two routines.
!
! INPUTS
!	SYMID	- A longword symbol identifier previously produced by routine
!		  DBG$STA_GETSYMBOL or DBG$STA_GETSYMOFF.  SYMID uniquely ident-
!		  ifies the symbol whose kind is to be returned.
!
!	KIND	- The address of a longword location where the symbol's kind
!		  code should be returned.
!
! OUTPUTS
!	KIND	- The "kind" of the SYMID symbol is returned to KIND.  This is
!		  a small integer with the following possible values:
!
!			RST$K_MODULE	-- SYMID is a Module
!			RST$K_ROUTINE	-- SYMID is a Routine
!			RST$K_BLOCK	-- SYMID is a Block
!			RST$K_ENTRY	-- SYMID is an Entry Point
!			RST$K_LABEL	-- SYMID is a Label
!			RST$K_LINE	-- SYMID is a Line
!			RST$K_DATA	-- SYMID is a Data Item
!			RST$K_TYPE	-- SYMID is a Data Type
!
!	No value is returned by DBG$STA_SYMKIND.
!

    BEGIN

    MAP
	SYMID: REF RST$ENTRY,		! Pointer to the RST entry whose "kind"
					!      is to be returned.
	KIND: REF VECTOR[1];		! Pointer to the location where the
					!      kind is to be returned.



    ! Make sure SYMID points to a valid RST entry (or at least seems to).  Then
    ! copy the entry's kind to KIND and return.
    !
    IF .SYMID[RST$B_KIND] LEQ RST$K_KIND_MINIMUM OR
       .SYMID[RST$B_KIND] GTR RST$K_KIND_MAXIMUM
    THEN
	SIGNAL(DBG$_DEBUGBUG, 1, 152);

    KIND[0] = .SYMID[RST$B_KIND];
    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_SYMNAME(SYMID, NAMEPTR): NOVALUE =
!
! FUNCTION:
!	This routine accepts a symbol identifier and returns the corresponding
!	symbol's name without any qualification.  The symbol identifier is the
!	unique identifier produced by DBG$STA_GETSYMBOL or DBG$STA_GETSYMOFF.
!	The returned symbol name is represented as a counted ASCII string.
!
!	Since this routine does not produce a completely qualified, unambiguous
!	name, it is primarily used to get the names of data record components.
!	Such component names are needed by language-specific routines when
!	printing the values of data records.
!
! INPUTS:
!	SYMID	- A longword symbol identifier previously produced by routine
!		  DBG$STA_GETSYMBOL or DBG$STA_GETSYMOFF.  SYMID uniquely ident-
!		  ifies the symbol whose name is to be returned.
!
!	NAMEPTR	- The address of a longword location where a pointer to the
!		  symbol's name should be returned.
!
! OUTPUTS:
!	NAMEPTR	- A pointer to the counted ASCII string giving the symbol's
!		  bottom level, unqualified name is returned to NAMEPTR.
!
!	No value is returned by DBG$STA_SYMNAME.
!

    BEGIN

    MAP
	SYMID: REF RST$ENTRY,		! Pointer to the RST entry whose name
					!      string is to be returned.
	NAMEPTR: REF VECTOR[1];		! Pointer to the location where the
					!      string address is to be returned.



    ! Make sure SYMID seems to point to a valid RST entry.  Copy the address
    ! of the name string to NAMEPTR by calling GET_DST_NAME.  Then return.
    !
    IF .SYMID[RST$B_KIND] LSS RST$K_KIND_MINIMUM OR
       .SYMID[RST$B_KIND] GTR RST$K_KIND_MAXIMUM
    THEN
	SIGNAL(DBG$_DEBUGBUG, 1, 153);

    NAMEPTR[0] = DBG$GET_DST_NAME(.SYMID[RST$L_DSTPTR]);
    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_SYMPARENT(SYMID) =
!
! FUNCTION
!	This routine returns the parent data item of a record (structure) compo-
!	nent.  Thus, if there is a data item A.B(2).C, then the parent of C is
!	B and the parent of B is A.  A does not have any parent.  This routine
!	should only be called when the data component has been looked up direct-
!	ly in the RST via DBG$STA_GETSYMBOL, as would be done in languages like
!	PL/I or Cobol where record qualification need not be explicitly stated.
!
! INPUTS
!	SYMID	- The SYMID returned by DBG$STA_GETSYMBOL for the data item
!		  whose parent data item is to be found.  This symbol must
!		  be of kind RST$K_DATA.
!
! OUTPUTS
!	The SYMID of the input symbol's parent symbol is returned as the routine
!		  value.  If the input symbol does not have a parent, i.e. if
!		  the input symbol is not a record component but a separate data
!		  item in its own right, zero is returned as the routine value.
!

    BEGIN

    MAP
	SYMID: REF RST$ENTRY;		! Pointer to input symbol's RST entry

    LOCAL
	RSTPTR: REF RST$ENTRY;		! Pointer to the first up-scope symbol
					!      --this may be the parent symbol



    ! Make sure the input parameter is the SYMID of a Data Item RST Entry.
    !
    IF .SYMID[RST$B_KIND] NEQ RST$K_DATA THEN SIGNAL(DBG$_DEBUGBUG, 1, 187);


    ! Get the first RST entry up-scope from the input symbol.  If this is a Data
    ! Item RST Entry, return its SYMID as the routine value.  Otherwise, return
    ! a zero as the routine value.
    !
    RSTPTR = .SYMID[RST$L_UPSCOPEPTR];
    IF .RSTPTR[RST$B_KIND] EQL RST$K_DATA THEN RETURN .RSTPTR;
    RETURN 0;

    END;

GLOBAL ROUTINE DBG$STA_SYMPATHNAME(SYMID, PATHNAME): NOVALUE =
!
! FUNCTION
!	This routine accepts a symbol identifier and returns the corresponding
!	symbol's fully qualified pathname.  The symbol identifier is the unique
!	identifier produced by the DBG$STA_GETSYMBOL or DBG$STA_GETSYMOFF rou-
!	tine.  The returned pathname is represented in internal format by a
!	pathname descriptor which includes the symbol name with all possible
!	pathname qualification and all possible data record qualification.  This
!	does not include array subscripts, however.
!
!	This routine is called when a symbol's name is to be printed in a com-
!	pletely unambiguous form.  The returned pathname is not in a directly
!	printable form, but can relatively easily be converted to a character
!	string by language-specific routines.
!
! INPUTS
!	SYMID	- A longword symbol identifier previously produced by routine
!		  DBG$STA_GETSYMBOL or DBG$STA_GETSYMOFF.  SYMID uniquely ident-
!		  ifies the symbol whose complete pathname is to be returned.
!
!	PATHNAME - The address of a longword location where a pointer to the
!		  symbol's pathname descriptor should be returned.
!
! OUTPUTS
!	PATHNAME - A full pathname descriptor for the SYMID symbol is generated
!		  and a pointer to that descriptor is returned to PATHNAME.  The
!		  descriptor will disappear after the processing of the current
!		  DEBUG command.
!
!	No value is returned by DBG$STA_SYMPATHNAME.
!

    BEGIN

    MAP
	SYMID: REF RST$ENTRY,		! Pointer to input RST entry
	PATHNAME: REF VECTOR[1];	! Pointer to returned pathname descr.

    LOCAL
	COMPCNT,			! Number of data components in pathname
	DATACNT,			! Number of Data RST Entries in chain
	INVOC_LOC,			! Location in NAMELIST where invocation
					!      number belongs (inner-most rout-
					!      ine in SYMID's environment)
	INVOCNUM,			! The invocation number itself
	INVPTR: REF RST$ENTRY,		! Pointer to Invocation Number RST Entry
	J,				! Pathname vector index
	LINE_END,			! Line end address (not actually used)
	LINE_LWRDS,			! Number of longwords needed for line
					!      number counted ASCII string
	LINE_NUM,			! The line number used to identify an
					!      anonymous lexical entity
	LINE_NUM_FOUND,			! Set to TRUE if a line number RST entry
					!      is in the symbol's up-scope chain
	LINE_NUM_LOC,			! Location in NAMELIST before which the
					!      line number should be inserted
	LINE_NUM_PTR: REF VECTOR[,BYTE],! Pointer to line number counted ASCII
	LINE_START,			! Line start address (not actually used)
	LINE_STRING: VECTOR[40,BYTE],	! Vector used to build ASCII line number
	LSI,				! Index of next location in LINE_STRING
	MODPTR,				! Module RST pointer (not actually used)
	NAMECNT,			! The number of pathname components
	NAMELIST: VECTOR[DBG$K_MAX_PATHNAME],	! Vector of pointers to names
	NAMEPTR: REF VECTOR[,BYTE],	! Pointer to current pathname component
					!      (as a Counted ASCII string)
	NO_NULL_NAME,			! Set to TRUE if no null lexical entity
					!      name is in up-scope chain
	NO_ROUTINE,			! Set to TRUE if inner-most routine has
					!      not yet been found up-scope
	PATHDESCR: REF PTH$PATHNAME,	! Pointer to Pathname Descriptor
	PATHVEC: REF VECTOR[,LONG],	! Pointer to pathname vector in descr.
	RSTPTR: REF RST$ENTRY,		! Pointer to current RST entry
	STATUS,				! Status code returned by called routine
	STMT_NUM;			! Statement number within line number



    ! Initialize some pointers and counters for the up-scope chain loop.
    !
    RSTPTR = .SYMID;
    NAMECNT = 0;
    DATACNT = 0;
    LINE_NUM_FOUND = FALSE;
    LINE_NUM_LOC = 1000000;
    NO_NULL_NAME = TRUE;
    NO_ROUTINE = TRUE;


    ! Go up the input symbol's up-scope chain to determine how many pathname
    ! components the symbol has.  We also determine how much data qualification
    ! there is and whether a line number needs to be supplied in the pathname.
    !
    WHILE TRUE DO
	BEGIN


	! Get the name of the pathname component.  Unless the name is null,
	! save a pointer to the name string in the NAMELIST vector.
	!
	NAMEPTR = DBG$GET_DST_NAME(.RSTPTR[RST$L_DSTPTR]);
	IF .NAMEPTR[0] NEQ 0
	THEN
	    BEGIN
	    IF .NAMECNT GEQ DBG$K_MAX_PATHNAME THEN EXITLOOP;
	    NAMELIST[.NAMECNT] = .NAMEPTR;
	    NAMECNT = .NAMECNT + 1;
	    END;


	! If this is a global symbol, exit the up-scope loop right away.
	!
	IF .RSTPTR[RST$V_GLOBAL] THEN EXITLOOP;


	! Determine what kind of RST entry this is and act accordingly.
	!
	CASE .RSTPTR[RST$B_KIND] FROM RST$K_KIND_MINIMUM TO RST$K_KIND_MAXIMUM OF
	    SET

	    [RST$K_MODULE]:
		EXITLOOP;

	    [RST$K_ROUTINE,
	     RST$K_BLOCK]:
		BEGIN
		IF .NO_ROUTINE AND (.NAMEPTR[0] NEQ 0) AND
		   (.RSTPTR[RST$B_KIND] EQL RST$K_ROUTINE)
		THEN
		    BEGIN
		    NO_ROUTINE = FALSE;
		    INVOC_LOC = .NAMECNT - 1;
		    END;

		IF (.NAMEPTR[0] EQL 0) AND .NO_NULL_NAME
		THEN
		    BEGIN
		    LINE_NUM_LOC = .NAMECNT;
		    STATUS = DBG$PC_TO_LINE_LOOKUP(.RSTPTR[RST$L_STARTADDR],
			LINE_NUM, STMT_NUM, LINE_START, LINE_END, MODPTR);
		    IF .STATUS THEN NO_NULL_NAME = FALSE;
		    END;

		END;

	    [RST$K_ENTRY,
	     RST$K_LABEL]:
		0;

	    [RST$K_LINE]:
		LINE_NUM_FOUND = TRUE;

	    [RST$K_DATA,
	     RST$K_TYPE,
	     RST$K_TYPCOMP]:
		IF .NAMEPTR[0] NEQ 0 THEN DATACNT = .DATACNT + 1;

	    [INRANGE]:
		SIGNAL(DBG$_DEBUGBUG, 1, 179);

	    TES;


	! Link to the next RST entry up-scope from this one.  Then loop.
	!
	RSTPTR = .RSTPTR[RST$L_UPSCOPEPTR];
	END;


    ! Determine how many levels of data qualification (e.g., 2 for M\A.B.C)
    ! there is in the pathname.
    !
    IF .DATACNT EQL 0
    THEN
	COMPCNT = 0
    ELSE
	COMPCNT = .DATACNT - 1;


    ! If there already is a line number in the pathname, do not insert an extra
    ! line number due to a null lexical entity name.
    !
    IF .NO_NULL_NAME OR .LINE_NUM_FOUND THEN LINE_NUM_LOC = 1000000;


    ! If we do have to supply a line number in the pathname to identify an
    ! anonymous lexical entity, generate the line number counted ASCII string.
    !
    LINE_LWRDS = 0;
    IF .LINE_NUM_LOC NEQ 1000000
    THEN
	BEGIN
	LSI = 0;


	! If there is a statement number, convert that to ASCII decimal.
	!
	IF .STMT_NUM NEQ 0
	THEN
	    BEGIN
	    WHILE .STMT_NUM NEQ 0 DO
		BEGIN
		LINE_STRING[.LSI] = (.STMT_NUM MOD 10) + '0';
		LSI = .LSI + 1;
		STMT_NUM = .STMT_NUM/10;
		END;

	    LINE_STRING[.LSI] = '.';
	    LSI = .LSI + 1;
	    END;


	! Convert the main statement number to ASCII decimal.
	!
	WHILE .LINE_NUM NEQ 0 DO
	    BEGIN
	    LINE_STRING[.LSI] = (.LINE_NUM MOD 10) + '0';
	    LSI = .LSI + 1;
	    LINE_NUM = .LINE_NUM/10;
	    END;


	! Compute the number of longwords we will need for the line number.
	!
	LINE_LWRDS = (.LSI + 13)/4;
	END;


    ! Determine what the invocation number is.  If it turns out to be zero,
    ! we do not explicitly put it in the Pathname Descriptor.
    !
    INVOCNUM = 0;
    IF .SYMID[RST$V_INVOCNUM]
    THEN
	BEGIN
	INVPTR = .SYMID[RST$L_SYMCHNPTR];
	INVOCNUM = .INVPTR[RST$L_INVOCNUM];
	END;

    IF .INVOCNUM EQL 0 THEN INVOC_LOC = 1000000;


    ! Allocate space for a Pathname Descriptor for the symbol.
    !
    PATHDESCR = DBG$GET_TEMPMEM(DBG$K_PATHDESCSIZE + .NAMECNT + .LINE_LWRDS);
    PATHVEC = PATHDESCR[PTH$A_PATHVECTOR];


    ! Fill in the Pathname Descriptor's header.
    !
    PATHDESCR[PTH$B_TOTCNT] = .NAMECNT;
    PATHDESCR[PTH$B_PATHCNT] = .NAMECNT - .COMPCNT;
    PATHDESCR[PTH$B_LOCINVOC] = 0;
    PATHDESCR[PTH$L_INVOCNUM] = 0;


    ! Fill in the pointers to the pathname component names.
    !
    J = 0;
    DECR I FROM .NAMECNT - 1 TO 0 DO
	BEGIN
	PATHVEC[.J] = .NAMELIST[.I];
	J = .J + 1;


	! If this is where the invocation number goes, mark that in the header.
	!
	IF .I EQL .INVOC_LOC
	THEN
	    BEGIN
	    PATHDESCR[PTH$B_LOCINVOC] = .J;
	    PATHDESCR[PTH$L_INVOCNUM] = .INVOCNUM;
	    END;


	! If this is where the extra line number goes, fill that in.
	!
	IF .J EQL .LINE_NUM_LOC
	THEN
	    BEGIN
	    LINE_NUM_PTR = PATHVEC[.NAMECNT + 1];
	    LINE_NUM_PTR[0] = .LSI + 6;
	    LINE_NUM_PTR[1] = '%';
	    LINE_NUM_PTR[2] = 'L';
	    LINE_NUM_PTR[3] = 'I';
	    LINE_NUM_PTR[4] = 'N';
	    LINE_NUM_PTR[5] = 'E';
	    LINE_NUM_PTR[6] = ' ';
	    INCR K FROM 1 TO .LSI DO
		LINE_NUM_PTR[.K + 6] = .LINE_STRING[.LSI - .K];

	    PATHVEC[.J] = .LINE_NUM_PTR;
	    J = .J + 1;
	    END;

	END;


    ! Finally return the address of the Pathname Descriptor to PATHNAME.  Then
    ! return.
    !
    PATHNAME[0] = .PATHDESCR;
    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_SYMVALUE(SYMID, VALPTR, VALKIND): NOVALUE =
!
! FUNCTION
!	This routine accepts a symbol identifier and returns a pointer to the
!	corresponding symbol's value.  The symbol identifier is the unique
!	identifier produced by routine DBG$STA_GETSYMBOL or DBG$STA_GETSYMOFF.
!
!	This routine requires a "context" to have been established by a call on
!	routine DBG$STA_SETCONTEXT if there are any register references in the
!	DST Value Spec which defines the symbol's value.  If such a reference
!	occurs and no context exists, an error is signalled.
!
!	The interpretation of the value stored at the returned address is up to
!	the language-specific routines in light of the symbol's data type.  The
!	data type specification must therefore include all length information.
!
! INPUTS
!	SYMID	- A longword symbol identifier previously produced by routine
!		  DBG$STA_GETSYMBOL or DBG$STA_GETSYMOFF.  SYMID uniquely ident-
!		  ifies the symbol whose "value" is to be returned.
!
!	VALPTR	- The address of a three-longword vector to receive the value
!		  pointer and the corresponding stack frame pointer.
!
!	VALKIND	- The address of a longword location to receive the value kind.
!
! OUTPUTS
!	VALPTR	- A pointer to the desired value is returned to VALPTR.  The
!		  byte address of the value is returned to VALPTR[0] and the
!		  bit offset from that address is returned to VALPTR[1].  The
!		  corresponding stack Frame Pointer is returned to VALPTR[2].
!		  VALPTR[2] will contain zero if no frame pointer is applicable.
!
!	VALKIND	- The kind of the value pointed to by VALPTR is returned to
!		  VALKIND.  These are the possible values:
!
!			DBG$K_VAL_NOVALUE - The symbol has no value.
!			DBG$K_VAL_LITERAL - VALPTR points to a literal value.
!			DBG$K_VAL_ADDR    - VALPTR contains an address.
!			DBG$K_VAL_DESCR   - VALPTR contains the address of a
!					    descriptor.
!
!	No value is returned by DBG$STA_SYMVALUE.
!

    BEGIN

    MAP
	SYMID: REF RST$ENTRY,		! Pointer to input symbol's RST entry
	VALPTR: REF VECTOR[3],		! Pointer to caller's value vector
	VALKIND: REF VECTOR[1];		! Pointer to value kind parameter

    LOCAL
	BLITRLR: REF DST$BLI_TRAILER1,	! Pointer to Bliss DST record trailer
	BLIVALSPEC: BLOCK[8,BYTE]	! Value Spec buffer for Bliss special
		FIELD(DST$VS_HDR_FIELDS), !    cases DST record
	CH_TRLR_PTR: REF DST$CH_TRLR,	! Pointer to COBOL Hack DST trailer
	DSTPTR: REF DST$RECORD,		! Pointer to symbol's DST record
	VALLOC: REF VECTOR[,LONG];	! Value location from Stack Machine



    ! Initially zero out the returned value pointer and frame pointer.
    !
    VALPTR[0] = 0;
    VALPTR[1] = 0;
    VALPTR[2] = 0;


    ! Determine what kind of RST entry SYMID identifies and act accordingly.
    !
    CASE .SYMID[RST$B_KIND] FROM RST$K_KIND_MINIMUM TO RST$K_KIND_MAXIMUM OF
	SET


	! For instruction addresses, return the start address in the RST entry.
	!
	[RST$K_ROUTINE, RST$K_BLOCK,
	 RST$K_ENTRY, RST$K_LABEL,
	 RST$K_LINE]:
	    BEGIN
	    VALPTR[0] = .SYMID[RST$L_STARTADDR];
	    VALKIND[0] = DBG$K_VAL_ADDR;
	    RETURN;
	    END;


	! For Types, return the No-Value code to VALKIND.
	!
	[RST$K_TYPE]:
	    BEGIN
	    VALKIND[0] = DBG$K_VAL_NOVALUE;
	    RETURN;
	    END;


	! For most other kinds (including Module) signal an internal error.
	!
	[INRANGE, OUTRANGE]:
	    SIGNAL(DBG$_DEBUGBUG, 1, 186);


	! For Data and Type Components, do nothing here--we handle them below.
	!
	[RST$K_DATA, RST$K_TYPCOMP]:
	    0;

	TES;


    ! For the items not yet handled (i.e., for data), we determine the type of
    ! DST record which holds the value specification and act accordingly.
    !
    DSTPTR = .SYMID[RST$L_DSTPTR];
    CASE .DSTPTR[DST$B_TYPE] FROM 0 TO 255 OF
	SET


	! Handle all normal DST records, i.e. those of the standard format.
	! Find the Value Spec and pass it to DBG$STA_VALSPEC for evaluation.
	!
	[DSC$K_DTYPE_LOWEST TO DSC$K_DTYPE_HIGHEST,
	 DST$K_BOOL, DST$K_SEPTYP, DST$K_LBLORLIT,
	 DST$K_ENTRY, DST$K_RTNBEG, DST$K_BLKBEG,
	 DST$K_RECBEG, DST$K_ENUMELT]:
	    DBG$STA_VALSPEC(DSTPTR[DST$B_VFLAGS], .VALPTR, .VALKIND);


	! Handle the Label DST record.  Here we get the label address directly
	! from the DST$L_VALUE field--the DST$B_VFLAGS field is not provided.
	!
	[DST$K_LABEL]:
	    BEGIN
	    VALPTR[0] = .DSTPTR[DST$L_VALUE];
	    VALKIND[0] = DBG$K_VAL_ADDR;
	    END;


	! Handle the Bliss Special Cases DST record.  Construct a Value Spec
	! from the VFLAGS and VALUE fields in the record (which are not adjacent
	! in this particular record) and call DSG$STA_VALSPEC with it.
	!
	[DST$K_BLI]:
	    BEGIN
	    BLIVALSPEC[DST$B_VS_VFLAGS] = .DSTPTR[DST$B_BLI_VFLAGS];
	    BLITRLR = DSTPTR[DST$A_BLI_TRLR1] + .DSTPTR[DST$B_BLI_LNG];
	    BLIVALSPEC[DST$L_VS_VALUE] = .BLITRLR[DST$L_BLI_VALUE];
	    DBG$STA_VALSPEC(BLIVALSPEC, .VALPTR, .VALKIND);
	    END;


	! Handle the Bliss Field DST record.  Here we just return the address of
	! the number-of-components field in the DST record.
	!
	[DST$K_BLIFLD]:
	    BEGIN
	    VALPTR[0] = DSTPTR[DST$L_BLIFLD_COMPS];
	    VALKIND[0] = DBG$K_VAL_LITERAL;
	    END;


	! Handle the COBOL Hack DST Record.  Here we evaluate the Stack Machine
	! code in the DST record and return its value as the symbol address.
	!
	[DST$K_COB_HACK]:
	    BEGIN
	    CH_TRLR_PTR = DSTPTR[DST$A_COBHACK_TRLR] + .DSTPTR[DST$B_NAME];
	    STACK_MACHINE(CH_TRLR_PTR[DST$A_CH_STKRTN_ADDR], VALLOC, VALPTR[2]);
	    VALPTR[0] = .VALLOC[0];
	    VALPTR[1] = 0;
	    VALKIND[0] = DBG$K_VAL_ADDR;
	    END;


	! Handle the PSECT DST record.  Here we pick the PSECT start address
	! directly from the DST record.
	!
	[DST$K_PSECT]:
	    BEGIN
	    VALPTR[0] = .DSTPTR[DST$L_PSECT_VALUE];
	    VALKIND[0] = DBG$K_VAL_ADDR;
	    END;


	! Any other DST record causes an error to be signalled.
	!
	[INRANGE]:
	    SIGNAL(DBG$_DEBUGBUG, 1, 187);

	TES;


    ! We have the value.  Now return.
    !
    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_UNLOCK_SYMID(SYMID_LIST_PTR): NOVALUE =
!
! FUNCTION
!	This routine "unlocks" a list of SYMIDs which have previously been
!	"locked" in the RST by routine DBG$STA_LOCK_SYMID.  SYMIDs are locked
!	in the RST when the corresponding RST entries must be preserved accross
!	Debug commands because they are referenced by "." (current location),
!	breakpoints, or the like.  They should then be "unlocked" when they are
!	no longer so referenced, i.e. when "." assumes a different value or the
!	breakpoint is cancelled.
!
!	The unlocking is effected by decrementing the Reference Count in the
!	SYMID's RST entry and all other RST entries whose reference counts were
!	incremented when the SYMID was originally locked.  This includes all
!	RST entries up-scope from the original RST entry.
!
! INPUTS
!	SYMID_LIST_PTR - A pointer to a linked list of Linked List Nodes, where
!		  each node contains a forward link and a SYMID value.  Each
!		  SYMID on the list is "unlocked" in the RST by decrementing the
!		  reference count of the corresponding RST entry.
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
	LISTPTR: REF DBG$LINK_NODE;	! Pointer to current linked list node



    ! Loop through all the SYMIDs (i.e., RST pointers) on the linked list.
    ! For each SYMID on the list, call ADD_TO_REF_COUNT to decrement the RST
    ! entry's reference count.
    !
    LISTPTR = .SYMID_LIST_PTR;
    WHILE .LISTPTR NEQ 0 DO
	BEGIN
	ADD_TO_REF_COUNT(.LISTPTR[DBG$L_LINK_NODE_VALUE], -1);
	LISTPTR = .LISTPTR[DBG$L_LINK_NODE_LINK];
	END;

    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_VALSPEC(VALSPEC, VALPTR, VALKIND): NOVALUE =
!
! FUNCTION
!	This routine accepts the address of a DST Value Spec as input and pro-
!	duces the corresponding value as output.  It handles all the special
!	cases of value specs, including stack machine value specs, to compute
!	the proper output value.  It requires a "context" to have been estab-
!	lished by DBG$STA_SETCONTEXT if there are any register references in
!	the value spec.  If such a reference occurs and no context exists, an
!	error is signalled.
!
! INPUTS
!	VALSPEC	- A pointer to the DST Value Spec to be evaluated.
!
!	VALPTR	- The address of a three-longword vector to receive the value
!		  pointer and the corresponding stack frame pointer.
!
!	VALKIND	- The address of a longword location to receive the value kind.
!
! OUTPUTS
!	VALPTR	- A pointer to the desired value is returned to VALPTR.  The
!		  byte address of the value is returned to VALPTR[0] and the
!		  bit offset from that address is returned to VALPTR[1].  The
!		  corresponding stack Frame Pointer is returned to VALPTR[2].
!		  VALPTR[2] will contain zero if no frame pointer is applicable.
!
!	VALKIND	- The kind of the value pointed to by VALPTR is returned to
!		  VALKIND.  These are the possible values:
!
!			DBG$K_VAL_LITERAL - VALPTR points to a literal value.
!			DBG$K_VAL_ADDR    - VALPTR contains an address.
!			DBG$K_VAL_DESCR   - VALPTR contains the address of a
!					    descriptor.
!

    BEGIN

    MAP
	VALSPEC: REF DST$VAL_SPEC,	! Pointer to DST Value Spec to evaluate
	VALPTR: REF VECTOR[3],		! Pointer to value return location
	VALKIND: REF VECTOR[1];		! Pointer to value kind return location

    LOCAL
	REGNUM,				! Register number
	REGPTR: REF VECTOR[,LONG],	! Pointer to register save location
	VALUE: REF VECTOR[,LONG],	! Computed value
	VSPTR: REF DST$VAL_SPEC;	! Pointer to current DST Value Spec

    ENABLE
	VALSPEC_ERROR_HANDLER;		! Set up error handler for this routine



    ! Initially zero the returned frame pointer value in VALPTR[2].  This
    ! value will be changed later if a register is used in the evaluation.
    !
    VALPTR[2] = 0;


    ! If the value is given by a trailing Value Spec, we get to that Value
    ! Spec.  We loop in case the indirection is repeated.
    !
    VSPTR = .VALSPEC;
    WHILE .VSPTR[DST$B_VS_VFLAGS] EQL DST$K_VFLAGS_TVS DO
	VSPTR = VSPTR[DST$A_VS_TVS_BASE] + .VSPTR[DST$L_VS_TVS_OFFSET];


    ! If the Value Spec gives the offset to a descriptor (in the DST), return
    ! the address of that descriptor to the caller.
    !
    IF .VSPTR[DST$B_VS_VFLAGS] EQL DST$K_VFLAGS_DSC
    THEN
	BEGIN
	VALPTR[0] = VSPTR[DST$A_VS_DSC_BASE] + .VSPTR[DST$L_VS_DSC_OFFS];
	VALPTR[1] = 0;
	VALKIND[0] = DBG$K_VAL_DESCR;
	RETURN;
	END;


    ! If this is a Bit Offset Value Spec, return that bit offset as a byte
    ! address plus bit offset to the caller.
    !
    IF .VSPTR[DST$B_VS_VFLAGS] EQL DST$K_VFLAGS_BITOFFS
    THEN
	BEGIN
	VALPTR[0] = .VSPTR[DST$L_VS_VALUE]/8;
	VALPTR[1] = .VSPTR[DST$L_VS_VALUE] AND 7;
	VALKIND[0] = DBG$K_VAL_ADDR;
	RETURN;
	END;


    ! If this is a Value-Spec-Follows value spec, a more complex value spec
    ! follows the VFLAGS field.  Here we handle those kinds of value specs.
    !
    IF .VSPTR[DST$B_VS_VFLAGS] EQL DST$K_VS_FOLLOWS
    THEN
	BEGIN


	! Sort out which particular kind of complex value specification follows.
	!
	CASE .VSPTR[DST$B_VS_ALLOC] FROM DST$K_VS_ALLOC_STAT TO DST$K_VS_ALLOC_VARIES OF
	    SET


	    ! Handle statically or dynamically allocated objects without Binding
	    ! Specs.  Here we just evaluate the Materialization Spec.
	    !
	    [DST$K_VS_ALLOC_STAT,
	     DST$K_VS_ALLOC_DYN]:
		BEGIN
		EVAL_MAT_SPEC(VSPTR[DST$A_VS_MATSPEC], .VALPTR, .VALKIND);
		END;


	    ! Handle objects with a Binding Spec in the value spec.
	    !
	    [DST$K_VS_ALLOC_VARIES]:
		BEGIN
		SIGNAL(DBG$_INVDSTREC);
		END;


	    ! Any other value in the DST$B_VS_ALLOC field is an error.
	    !
	    [INRANGE, OUTRANGE]:
		SIGNAL(DBG$_INVDSTREC);

	    TES;


	! We are done with the complex value spec.  Return to the caller.
	!
	RETURN;
	END;


    ! This is an ordinary garden variety Value Spec with a normal VFLAGS field
    ! and a normal VALUE field.  If this is a literal, return the address of the
    ! literal to the caller.
    !
    IF .VSPTR[DST$V_VS_VALKIND] EQL DST$K_VALKIND_LITERAL
    THEN
	BEGIN
	VALPTR[0] = VSPTR[DST$L_VS_VALUE];
	VALPTR[1] = 0;
	VALKIND[0] = DBG$K_VAL_LITERAL;
	RETURN;
	END;


    ! If this is a register number, return the address of the corresponding
    ! register save area.  If the register is not available in this context,
    ! signal an error.
    !
    IF .VSPTR[DST$V_VS_VALKIND] EQL DST$K_VALKIND_REG
    THEN
	BEGIN
	REGNUM = .VSPTR[DST$L_VS_VALUE];
	IF (.REGNUM LSS 0) OR (.REGNUM GTR 15) THEN SIGNAL(DBG$_INVDSTREC);
	IF .DBG$REG_VECTOR[.REGNUM] EQL 0 THEN VALSPEC_SCOPE_ERROR();
	VALPTR[0] = DBG$REG_VALUES[.REGNUM];
	VALPTR[1] = 0;
	VALPTR[2] = .DBG$REG_VALUES[13];
	VALKIND[0] = DBG$K_VAL_ADDR;
	RETURN;
	END;


    ! This value spec requires the value to be computed.  The resulting value is
    ! either the address of some object or the address of a descriptor.
    !
    VALUE = .VSPTR[DST$L_VS_VALUE];
    IF .VSPTR[DST$V_VS_DISP]
    THEN
	BEGIN
	REGNUM = .VSPTR[DST$V_VS_REGNUM];
	IF .DBG$REG_VECTOR[.REGNUM] EQL 0 THEN VALSPEC_SCOPE_ERROR();
	VALUE = .VALUE + .DBG$REG_VALUES[.REGNUM];
	VALPTR[2] = .DBG$REG_VALUES[13];
	END;

    IF .VSPTR[DST$V_VS_INDIRECT] THEN VALUE = .VALUE[0];


    ! Return the computed value and its kind: address or descriptor address.
    !
    VALPTR[0] = .VALUE;
    VALPTR[1] = 0;
    IF .VSPTR[DST$V_VS_VALKIND] EQL DST$K_VALKIND_DESC
    THEN
	VALKIND[0] = DBG$K_VAL_DESCR

    ELSE
	VALKIND[0] = DBG$K_VAL_ADDR;

    RETURN;

    END;

GLOBAL ROUTINE DBG$TRANS_TO_REGNAME (ADDRESS, NAME) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine determines if the input address corresponds to an address
!	in the context register save area. If it does, a counted string of the
!	register name is returned. This string includes the scope number.
!
! FORMAL PARAMETERS:
!
!	ADDRESS		- Address to be translated to a register name
!
!	NAME		- The address of a longword to contain the address
!			  of the resulting counted string.
!
! IMPLICIT INPUTS:
!
!	DBG$REG_VALUES  - Vector of context register save areas
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS		- Success. Input address mapped to register name.
!
!	STS$K_SEVERE		- Failure. Input address does not correspond to
!				  context register save area.
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN
	
    LOCAL
	INDEX,				! Index into arrays
	REGNAME_TABLE: VECTOR [68,LONG],! Register name table
	CONTROL_DESC: BLOCK [8,BYTE],	! $FAO control descriptor
	FAO_LENGTH: WORD,		! $FAO output length
	OUTPUT_DESC: BLOCK [8,BYTE],	! Output descriptor for FAO
	OUTPUT_BUFFER: REF VECTOR [,BYTE]; ! Output buffer

    BIND
	FAO_STRING	= UPLIT BYTE ('!UL!AC!AC'),  ! $FAO directive string
	SEP_STRING	= UPLIT BYTE (%ASCIC '\%');  ! Separator string



    ! Fill in the register name table. Note that this MUST be done at runtime.
    !
    REGNAME_TABLE [0] =	UPLIT BYTE (%ASCIC 'R0');
    REGNAME_TABLE [1] =	UPLIT BYTE (%ASCIC 'R0+1');
    REGNAME_TABLE [2] =	UPLIT BYTE (%ASCIC 'R0+2');
    REGNAME_TABLE [3] =	UPLIT BYTE (%ASCIC 'R0+3');
    REGNAME_TABLE [4] =	UPLIT BYTE (%ASCIC 'R1');
    REGNAME_TABLE [5] =	UPLIT BYTE (%ASCIC 'R1+1');
    REGNAME_TABLE [6] =	UPLIT BYTE (%ASCIC 'R1+2');
    REGNAME_TABLE [7] =	UPLIT BYTE (%ASCIC 'R1+3');
    REGNAME_TABLE [8] =	UPLIT BYTE (%ASCIC 'R2');
    REGNAME_TABLE [9] =	UPLIT BYTE (%ASCIC 'R2+1');
    REGNAME_TABLE [10] = UPLIT BYTE (%ASCIC 'R2+2');
    REGNAME_TABLE [11] = UPLIT BYTE (%ASCIC 'R2+3');
    REGNAME_TABLE [12] = UPLIT BYTE (%ASCIC 'R3');
    REGNAME_TABLE [13] = UPLIT BYTE (%ASCIC 'R3+1');
    REGNAME_TABLE [14] = UPLIT BYTE (%ASCIC 'R3+2');
    REGNAME_TABLE [15] = UPLIT BYTE (%ASCIC 'R3+3');
    REGNAME_TABLE [16] = UPLIT BYTE (%ASCIC 'R4');
    REGNAME_TABLE [17] = UPLIT BYTE (%ASCIC 'R4+1');
    REGNAME_TABLE [18] = UPLIT BYTE (%ASCIC 'R4+2');
    REGNAME_TABLE [19] = UPLIT BYTE (%ASCIC 'R4+3');
    REGNAME_TABLE [20] = UPLIT BYTE (%ASCIC 'R5');
    REGNAME_TABLE [21] = UPLIT BYTE (%ASCIC 'R5+1');
    REGNAME_TABLE [22] = UPLIT BYTE (%ASCIC 'R5+2');
    REGNAME_TABLE [23] = UPLIT BYTE (%ASCIC 'R5+3');
    REGNAME_TABLE [24] = UPLIT BYTE (%ASCIC 'R6');
    REGNAME_TABLE [25] = UPLIT BYTE (%ASCIC 'R6+1');
    REGNAME_TABLE [26] = UPLIT BYTE (%ASCIC 'R6+2');
    REGNAME_TABLE [27] = UPLIT BYTE (%ASCIC 'R6+3');
    REGNAME_TABLE [28] = UPLIT BYTE (%ASCIC 'R7');
    REGNAME_TABLE [29] = UPLIT BYTE (%ASCIC 'R7+1');
    REGNAME_TABLE [30] = UPLIT BYTE (%ASCIC 'R7+2');
    REGNAME_TABLE [31] = UPLIT BYTE (%ASCIC 'R7+3');
    REGNAME_TABLE [32] = UPLIT BYTE (%ASCIC 'R8');
    REGNAME_TABLE [33] = UPLIT BYTE (%ASCIC 'R8+1');
    REGNAME_TABLE [34] = UPLIT BYTE (%ASCIC 'R8+2');
    REGNAME_TABLE [35] = UPLIT BYTE (%ASCIC 'R8+3');
    REGNAME_TABLE [36] = UPLIT BYTE (%ASCIC 'R9');
    REGNAME_TABLE [37] = UPLIT BYTE (%ASCIC 'R9+1');
    REGNAME_TABLE [38] = UPLIT BYTE (%ASCIC 'R9+2');
    REGNAME_TABLE [39] = UPLIT BYTE (%ASCIC 'R9+3');
    REGNAME_TABLE [40] = UPLIT BYTE (%ASCIC 'R10');
    REGNAME_TABLE [41] = UPLIT BYTE (%ASCIC 'R10+1');
    REGNAME_TABLE [42] = UPLIT BYTE (%ASCIC 'R10+2');
    REGNAME_TABLE [43] = UPLIT BYTE (%ASCIC 'R10+3');
    REGNAME_TABLE [44] = UPLIT BYTE (%ASCIC 'R11');
    REGNAME_TABLE [45] = UPLIT BYTE (%ASCIC 'R11+1');
    REGNAME_TABLE [46] = UPLIT BYTE (%ASCIC 'R11+2');
    REGNAME_TABLE [47] = UPLIT BYTE (%ASCIC 'R11+3');
    REGNAME_TABLE [48] = UPLIT BYTE (%ASCIC 'AP');
    REGNAME_TABLE [49] = UPLIT BYTE (%ASCIC 'AP+1');
    REGNAME_TABLE [50] = UPLIT BYTE (%ASCIC 'AP+2');
    REGNAME_TABLE [51] = UPLIT BYTE (%ASCIC 'AP+3');
    REGNAME_TABLE [52] = UPLIT BYTE (%ASCIC 'FP');
    REGNAME_TABLE [53] = UPLIT BYTE (%ASCIC 'FP+1');
    REGNAME_TABLE [54] = UPLIT BYTE (%ASCIC 'FP+2');
    REGNAME_TABLE [55] = UPLIT BYTE (%ASCIC 'FP+3');
    REGNAME_TABLE [56] = UPLIT BYTE (%ASCIC 'SP');
    REGNAME_TABLE [57] = UPLIT BYTE (%ASCIC 'SP+1');
    REGNAME_TABLE [58] = UPLIT BYTE (%ASCIC 'SP+2');
    REGNAME_TABLE [59] = UPLIT BYTE (%ASCIC 'SP+3');
    REGNAME_TABLE [60] = UPLIT BYTE (%ASCIC 'PC');
    REGNAME_TABLE [61] = UPLIT BYTE (%ASCIC 'PC+1');
    REGNAME_TABLE [62] = UPLIT BYTE (%ASCIC 'PC+2');
    REGNAME_TABLE [63] = UPLIT BYTE (%ASCIC 'PC+3');
    REGNAME_TABLE [64] = UPLIT BYTE (%ASCIC 'PSL');
    REGNAME_TABLE [65] = UPLIT BYTE (%ASCIC 'PSL+1');
    REGNAME_TABLE [66] = UPLIT BYTE (%ASCIC 'PSL+2');
    REGNAME_TABLE [67] = UPLIT BYTE (%ASCIC 'PSL+3');


    ! Check to see if the input address falls in the context register area.
    ! If so, we format the scope number and register name in a buffer which
    ! we then return to the caller.  We return with the status STS$K_SUCCESS.
    !
    IF (.ADDRESS GEQA DBG$REG_VALUES [0]) AND
       (.ADDRESS LSSA DBG$REG_VALUES [17])
    THEN
	BEGIN


	! Calculate the register index and get a temporary memory buffer for
	! ASCII register name.
	!
	INDEX = .ADDRESS - DBG$REG_VALUES [0];
	OUTPUT_BUFFER = DBG$GET_TEMPMEM(10);


	! Set up the FAO call
	!
	CONTROL_DESC [DSC$W_LENGTH] = %CHARCOUNT ('!UL!AC!AC');
	CONTROL_DESC [DSC$A_POINTER] = FAO_STRING;
	OUTPUT_DESC [DSC$W_LENGTH] = (10 * %UPVAL) - 1;
	OUTPUT_DESC [DSC$A_POINTER] = OUTPUT_BUFFER [1];
	

	! Format the scope number, the separator, and the register name.
	!
	IF NOT SYS$FAO (CONTROL_DESC,
		        FAO_LENGTH,
			OUTPUT_DESC,
		        .DBG$REG_SCOPE,
		        SEP_STRING,
		        .REGNAME_TABLE [.INDEX])
	THEN
	    SIGNAL (DBG$_DEBUGBUG, 1, DBG$K_SYS$FAOL_BADPARAM);


	! Copy the count into the first byte of the output buffer and return.
	!
	OUTPUT_BUFFER [0] = .FAO_LENGTH;
	.NAME = .OUTPUT_BUFFER;
	RETURN STS$K_SUCCESS;
	
	END


    ! The input address does not fall in the register save area.  Hence we
    ! return the status STS$K_SEVERE to indicate this.
    !
    ELSE
	RETURN STS$K_SEVERE;

    END;


ROUTINE ADD_TO_REF_COUNT(RSTPTR, INCREMENT): NOVALUE =
!
! FUNCTION
!	This routine increments or decrements the reference count field of a
!	specified RST entry and all entries reachable from that entry.  An RST
!	is "reachable" from a specified entry if it is up-scope from that entry,
!	if it is referenced by the RST$L_TYPEPTR field, or it is a record com-
!	ponent or enumeration type element of the specified Type RST Entry.
!
! INPUTS
!	RSTPTR	- A pointer to the RST entry whose reference count is to be
!		  incremented or decremented.
!
!	INCREMENT - The value to be added to the RST entry's reference count.
!		  Thus +1 increments the count and -1 decrements it.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	RSTPTR: REF RST$ENTRY;		! Pointer to the input RST entry

    LOCAL
	COMPLST: REF VECTOR[,LONG],	! Pointer to Type or Variant Entry
					!      component list
	INVOCPTR: REF RST$ENTRY,	! Pointer to invocation number RST entry
	VARPTR: REF RST$VAR_ENTRY,	! Pointer to a Variant Entry pointed to
					!      by a Variant-Set RST Entry
	VARSETTBL: REF VECTOR[,LONG];	! Pointer to list of variants in a
					!      Variant-Set RST Entry



    ! Determine what kind of RST entry this is and act accordingly.
    !
    CASE .RSTPTR[RST$B_KIND] FROM RST$K_KIND_MINIMUM TO RST$K_KIND_MAXIMUM OF
	SET


	! Handle the Module RST Entry.  Since a Module RST Entry terminates
	! every up-scope chain but is itself never removed from memory, we
	! just return here.  This stops any up-scope recursion.
	!
	[RST$K_MODULE]:
	    RETURN;


	! Handle all lexical entity and instruction label RST entries.  Incre-
	! ment the RST entry's reference count and call ADD_TO_REF_COUNT recur-
	! sively to increment reference counts in the whole up-scope chain.
	!
	[RST$K_ROUTINE, RST$K_BLOCK,
	 RST$K_ENTRY, RST$K_LABEL,
	 RST$K_LINE]:
	    BEGIN
	    RSTPTR[RST$W_REFCOUNT] = .RSTPTR[RST$W_REFCOUNT] + .INCREMENT;
	    ADD_TO_REF_COUNT(.RSTPTR[RST$L_UPSCOPEPTR], .INCREMENT);
	    END;


	! Handle the Data and Type Component RST Entries.  Increment the refer-
	! ence count and call this routine recursively for the up-scope pointer
	! and the type pointer (if non-zero).
	!
	[RST$K_DATA, RST$K_TYPCOMP]:
	    BEGIN
	    RSTPTR[RST$W_REFCOUNT] = .RSTPTR[RST$W_REFCOUNT] + .INCREMENT;
	    ADD_TO_REF_COUNT(.RSTPTR[RST$L_UPSCOPEPTR], .INCREMENT);
	    IF .RSTPTR[RST$L_TYPEPTR] NEQ 0
	    THEN
		ADD_TO_REF_COUNT(.RSTPTR[RST$L_TYPEPTR], .INCREMENT);

	    END;


	! Handle the Data Type RST Entry.  Increment its reference count.  Then
	! call ADD_TO_REF_COUNT recursively to increment the reference counts of
	! the up-scope chain and all record components or enumeration elements.
	! Note that we use a mark bit to stop infinite recursion which would
	! otherwise occur for enumeration types and possibly in other cases.
	!
	[RST$K_TYPE]:
	    BEGIN
	    IF .RSTPTR[RST$V_MARKBIT] THEN RETURN;
	    RSTPTR[RST$V_MARKBIT] = TRUE;
	    RSTPTR[RST$W_REFCOUNT] = .RSTPTR[RST$W_REFCOUNT] + .INCREMENT;
	    ADD_TO_REF_COUNT(.RSTPTR[RST$L_UPSCOPEPTR], .INCREMENT);
	    COMPLST = RSTPTR[RST$A_TYPCOMPLST];
	    INCR I FROM 1 TO .RSTPTR[RST$L_TYPCOMPCNT] DO
		ADD_TO_REF_COUNT(.COMPLST[.I - 1], .INCREMENT);

	    RSTPTR[RST$V_MARKBIT] = FALSE;
	    END;


	! Handle the Variant-Set RST Entry.  Here we call ADD_TO_REF_COUNT re-
	! cursively to cover all record components of the parent type.
	!
	[RST$K_VARIANT]:
	    BEGIN
	    ADD_TO_REF_COUNT(.RSTPTR[RST$L_VARTAGPTR], .INCREMENT);
	    VARSETTBL = RSTPTR[RST$A_VARSETTBL];
	    INCR I FROM 1 TO .RSTPTR[RST$L_VARSETCNT] DO
		BEGIN
		VARPTR = .VARSETTBL[.I - 1];
		COMPLST = VARPTR[RST$A_VAR_COMPLST];
		INCR J FROM 1 TO .VARPTR[RST$L_VAR_COMPCNT] DO
		    ADD_TO_REF_COUNT(.COMPLST[.J - 1], .INCREMENT);

		END;

	    END;


	! Any other kind should never show up here.  If it does, error out.
	!
	[INRANGE, OUTRANGE]:
	    SIGNAL(DBG$_DEBUGBUG, 1, 181);

	TES;


    ! If there is an Invocation Number RST Entry following this one on the Sym-
    ! bol chain, increment its reference count also.
    !
    IF .RSTPTR[RST$V_INVOCNUM]
    THEN
	BEGIN
	INVOCPTR = .RSTPTR[RST$L_SYMCHNPTR];
	IF .INVOCPTR[RST$B_KIND] NEQ RST$K_INVOCNUM
	THEN
	    SIGNAL(DBG$_DEBUGBUG, 1, 182);

	INVOCPTR[RST$W_REFCOUNT] = .INVOCPTR[RST$W_REFCOUNT] + .INCREMENT;
	END;


    ! We are all done--return.
    !
    RETURN;

    END;

ROUTINE BUILD_INVOC_RST(OLDRST, INVOCNUM) =
!
! FUNCTION
!	This routine builds an RST entry with an attached invocation number for
!	a specified symbol.  To do this, it accepts the symbol's RST entry as
!	input and creates a new copy of that RST entry.  The RST$V_INVOCNUM flag
!	is set in the new copy.  It then builds an Invocation Number RST Entry
!	to hold the actual invocation number.  The RST$L_SYMCHNPTR field in the
!	new symbol entry is set to point to the Invocation Number RST Entry.
!	Both new RST entries are added to the Temporary RST Entry List pointed
!	to by RST$TEMP_LIST.  The new symbol RST entry represents this specific
!	invocation of the new symbol, and its address is returned to the caller.
!
! INPUTS
!	OLDRST	- Pointer to the RST entry of the symbol to which an invocation
!		  number should be attached.
!
!	INVOCNUM - The desired invocation number.  This is assumed to be applied
!		  to the inner-most invocable entity (routine) in the scope in
!		  which the OLDRST symbol is declared.
!
! OUTPUTS
!	A pointer to the new symbol RST entry (which includes the invocation
!		  information) is returned as the routine value.
!

    BEGIN

    MAP
	OLDRST: REF RST$ENTRY;		! Pointer to the symbol RST entry

    OWN
	RST_SIZE_TBL:			! RST entry size look-up table indexed
		VECTOR[RST$K_KIND_MAXIMUM + 1, BYTE]	!      by entry kind
		PRESET(	[RST$K_INVALID]		= 0,
			[RST$K_NOTUNIQUE]	= 0,
			[RST$K_MODULE]		= 0,
			[RST$K_ROUTINE]		= RST$K_ROUTENTSIZ,
			[RST$K_BLOCK]		= RST$K_LEXENTSIZ,
			[RST$K_ENTRY]		= RST$K_EPTENTSIZ,
			[RST$K_LABEL]		= RST$K_LBLENTSIZ,
			[RST$K_LINE]		= RST$K_LINENTSIZ,
			[RST$K_DATA]		= RST$K_DATENTSIZ,
			[RST$K_TYPCOMP]		= RST$K_DATENTSIZ,
			[RST$K_TYPE]		= 0,
			[RST$K_VARIANT]		= 0,
			[RST$K_INVOCNUM]	= 0);

    LOCAL
	INVPTR: REF RST$ENTRY,		! Pointer to Invocation Number RST Entry
	NEWRST: REF RST$ENTRY,		! Pointer to new copy of symbol RST
	SIZE;				! The size of this RST entry



    ! Determine the size and validity of the symbol RST entry.  We do not accept
    ! Module, Type, or Variant RST entries.
    !
    SIZE = 0;
    IF (.OLDRST[RST$B_KIND] GEQ RST$K_KIND_MINIMUM) AND
       (.OLDRST[RST$B_KIND] LEQ RST$K_KIND_MAXIMUM)
    THEN
	SIZE = .RST_SIZE_TBL[.OLDRST[RST$B_KIND]];

    IF .SIZE EQL 0 THEN SIGNAL(DBG$_DEBUGBUG, 1, 183);


    ! Copy the symbol's RST entry (the "old" RST entry) into a new memory
    ! block (the "new" RST entry).  Note that we copy the whole memory block
    ! so that any embedded DST entry is copied also.  Then fill in all fields
    ! in the new entry that must be different from those in the old entry.
    !
    NEWRST = DBG$COPY_MEMORY(.OLDRST);
    NEWRST[RST$L_HASH_BLINK] = 0;
    IF .OLDRST[RST$L_DSTPTR] EQL (.OLDRST + 4*.SIZE)
    THEN
	NEWRST[RST$L_DSTPTR] = .NEWRST + 4*.SIZE;

    NEWRST[RST$W_REFCOUNT] = 0;


    ! Put the new symbol entry on the Temporary RST Entry List.
    !
    NEWRST[RST$L_HASH_FLINK] = .RST$TEMP_LIST;
    RST$TEMP_LIST = .NEWRST;


    ! Now build the Invocation Number RST Entry to go with the new symbol entry.
    ! Also put it on the Temporary RST Entry List.
    !
    INVPTR = DBG$GET_MEMORY(RST$K_INVENTSIZ);
    INVPTR[RST$L_UPSCOPEPTR] = .OLDRST;
    INVPTR[RST$B_KIND] = RST$K_INVOCNUM;
    INVPTR[RST$L_INVOCNUM] = .INVOCNUM;
    INVPTR[RST$L_HASH_FLINK] = .RST$TEMP_LIST;
    RST$TEMP_LIST = .INVPTR;


    ! Finally put a link in the symbol's new RST entry which points to the
    ! Invocation Number RST Entry.  Then return the address of the new entry.
    !
    NEWRST[RST$L_SYMCHNPTR] = .INVPTR;
    NEWRST[RST$V_INVOCNUM] = TRUE;
    RETURN .NEWRST;

    END;

ROUTINE EVAL_MAT_SPEC(MSPTR, VALPTR, VALKIND): NOVALUE =
!
! FUNCTION
!	This routine evaluates a Materialization Spec.  Materialization Specs
!	are found inside certain kinds of Value Specs when more complex computa-
!	tions are needed to produce a symbol's value.  In particular, they are
!	used when a call on a compiler-provided run-time routine or an invoca-
!	tion of the DST stack machine is used to compute the value.
!
! INPUTS
!	MSPTR	- Pointer to the Materialization Spec to be evaluated.
!
!	VALPTR	- The address of a three-longword vector to receive the value
!		  pointer and the corresponding stack frame pointer.
!
!	VALKIND	- The address of a longword location to receive the value kind.
!
! OUTPUTS
!	VALPTR	- A pointer to the desired value is returned to VALPTR.  The
!		  byte address of the value is returned to VALPTR[0] and the
!		  bit offset from that address is returned to VALPTR[1].  The
!		  corresponding stack Frame Pointer is returned to VALPTR[2].
!		  VALPTR[2] will contain zero if no frame pointer is applicable.
!
!	VALKIND	- The kind of the value pointed to by VALPTR is returned to
!		  VALKIND.  These are the possible values:
!
!			DBG$K_VAL_LITERAL - VALPTR points to a literal value.
!			DBG$K_VAL_ADDR    - VALPTR contains an address.
!			DBG$K_VAL_DESCR   - VALPTR contains the address of a
!					    descriptor.
!
!	No value is returned by EVAL_MAT_SPEC.
!

    BEGIN

    MAP
	MSPTR: REF DST$MATER_SPEC,	! Pointer to the materialization spec
	VALPTR: REF VECTOR[3],		! Pointer to value pointer vector
	VALKIND: REF VECTOR[1];		! Pointer to value kind location

    LOCAL
	VALLOC: REF VECTOR[,LONG],	! Pointer to value as computed by the
					!      mechanism specified in the spec
	REGNUM;				! Register number



    ! Determine what kind of materialization spec we have.  Compute the value
    ! of each kind as appropriate.
    !
    CASE .MSPTR[DST$B_MS_MECH] FROM DST$K_MS_MECH_RTNCALL TO DST$K_MS_MECH_STK OF
	SET


	! Routine Call mechanism spec.  Call a run-time routine provided by the
	! compiler in the user image to compute the desired value.
	!
	[DST$K_MS_MECH_RTNCALL]:
	    BEGIN
	    VALPTR[2] = .DBG$REG_VALUES[13];
	    VALLOC = DBG$GET_TEMPMEM(4);
	    VALSPEC_ROUT_CALL(.VALLOC, .MSPTR[DST$L_MS_MECH_RTNADDR],
						.MSPTR[DST$V_MS_DUMARG]);
	    END;


	! Stack machine mechanism spec.  Use the DST "stack machine" to compute
	! the desired value.
	!
	[DST$K_MS_MECH_STK]:
	    STACK_MACHINE(MSPTR[DST$A_MS_MECH_SPEC], VALLOC, VALPTR[2]);


	! Any other value is an error.
	!
	[OUTRANGE]:
	    SIGNAL(DBG$_INVDSTREC);

	TES;


    ! We have now computed the value.  Return the value and the value kind to
    ! the caller.
    !
    CASE .MSPTR[DST$B_MS_KIND] FROM DST$K_MS_BYTADDR TO DST$K_MS_DSC OF
	SET


	! We have a byte address.
	!
	[DST$K_MS_BYTADDR]:
	    BEGIN
	    VALPTR[0] = .VALLOC[0];
	    VALPTR[1] = 0;
	    VALKIND[0] = DBG$K_VAL_ADDR;
	    END;


	! We have a bit address, i.e. a byte address with a bit offset.
	!
	[DST$K_MS_BITADDR]:
	    BEGIN
	    VALPTR[0] = .VALLOC[0];
	    VALPTR[1] = .VALLOC[1];
	    VALKIND[0] = DBG$K_VAL_ADDR;
	    END;


	! We have a bit offset.
	!
	[DST$K_MS_BITOFFS]:
	    BEGIN
	    VALPTR[0] = .VALLOC[0]/8;
	    VALPTR[1] = .VALLOC[0] AND 7;
	    VALKIND[0] = DBG$K_VAL_ADDR;
	    END;


	! We have an "R-value", i.e a literal or constant value.
	!
	[DST$K_MS_RVAL]:
	    BEGIN
	    VALPTR[0] = VALLOC[0];
	    VALPTR[1] = 0;
	    VALKIND[0] = DBG$K_VAL_LITERAL;
	    END;


	! We have a register number.  Convert it into a pointer into the regis-
	! ter value vector.
	!
	[DST$K_MS_REG]:
	    BEGIN
	    REGNUM = .VALLOC[0];
	    IF (.REGNUM LSS 0) OR (.REGNUM GTR 15) THEN SIGNAL(DBG$_INVDSTREC);
	    IF .DBG$REG_VECTOR[.REGNUM] EQL 0 THEN VALSPEC_SCOPE_ERROR();
	    VALPTR[0] = DBG$REG_VALUES[.REGNUM];
	    VALPTR[1] = 0;
	    VALPTR[2] = .DBG$REG_VALUES[13];
	    VALKIND[0] = DBG$K_VAL_ADDR;
	    END;


	! We have a descriptor address.
	!
	[DST$K_MS_DSC]:
	    BEGIN
	    VALPTR[0] = VALLOC[0];
	    VALPTR[1] = 0;
	    VALKIND[0] = DBG$K_VAL_DESCR;
	    END;


	! Any other value is an error.
	!
	[INRANGE, OUTRANGE]:
	    SIGNAL(DBG$_INVDSTREC);

	TES;


    ! All done--now return.
    !
    RETURN;

    END;

ROUTINE FOLLOW_STATIC_LINK(RSTPTR, SCOPE_RSTPTR) =
!
! FUNCTION
!	This routine determines the proper invocation number for a data item
!	which has been looked up in a specific scope.  This is accomplished by
!	starting with the call frame of the routine defining the scope and then
!	following the Static Links (in the call stack) until we get to a frame
!	for the routine in which the data item is declared.  The invocation
!	number of that routine is computed along the way, and is returned as the
!	invocation number of the data item.
!
!	The Static Links take us from call frame to call frame as we go up-scope
!	from the scope routine to the declaring routine.  Static links are spec-
!	ified by Value Specs in Static Link DST records.  There can be one such
!	record per routine.  However, if no such record is specified (BLISS, for
!	example, does not use them), we take the first invocation we find in the
!	call stack (after the current call frame) for the up-scope routine.  The
!	Static Link DST record always gives the right final invocation number,
!	but the first-invocation-we-find method works equally well in all but a
!	few anomalous cases.
!
! INPUTS
!	RSTPTR	- Pointer to the RST entry of the object (normally a data item)
!		  whose invocation number is to be determined.
!
!	SCOPE_RSTPTR - Pointer to the RST entry which defines the scope in which
!		  the RSTPTR item is to be found.  This scope defines the invoc-
!		  ation of RSTPTR we want.  This routine assumes that the RSTPTR
!		  item is known to be in the scope defined by SCOPE_RSTPTR.
!
! OUTPUTS
!	A pointer to an RST entry for the RSTPTR object is returned as the
!		  routine value.  This RST entry will have the proper invocation
!		  number for the object.  The returned pointer is identical to
!		  RSTPTR if the invocation number is zero.  RSTPTR is also re-
!		  turned unchanged if it does not point to a data object.
!

    BEGIN

    MAP
	RSTPTR: REF RST$ENTRY,		! Pointer to RST entry for data object
					!      whose invocation number is to be
					!      determined
	SCOPE_RSTPTR: REF RST$ENTRY;	! Pointer to the RST entry which
					!      defines the scope in which
					!      the object is to be found

    OWN
	SPVALUE: REF VECTOR[,LONG];	! Current call frame's SP value

    LOCAL
	CURRENT_REG: REF VECTOR[,LONG],	! Pointer to vector of current register
					!      values (at top of stack)
	DSTPTR: REF DST$RECORD,		! Pointer to Static Link DST record
	FRAME_FOUND_FLAG,		! Set to TRUE when a call frame for a
					!      desired routine has been found
	FRAMEPTR: REF BLOCK[,BYTE],	! Pointer to current VAX call frame
	GOOD_R0,			! Set to TRUE if R0 save area is good
					!      (R0 is volatile in subr. calls)
	GOOD_R1,			! Set to TRUE if R1 save area is good
	INVPTR: REF RST$ENTRY,		! Pointer to Invocation Number RST Entry
	J,				! Call frame register-vector index
	PATHNAME,			! Pointer to data item Pathname Descr.
	PATHSTRING,			! Pointer to pathname counted ASCII
	PCVAL,				! Current call frame's PC value
	REGMASK: BITVECTOR[16],		! Register save mask from the call frame
	REGPTR: REF VECTOR[,LONG],	! Pointer to a register's save location
	REGSAVELOC: REF VECTOR[,LONG],	! Pointer to call frame register save
					!      area for registers R0 - R11
	REGVEC: VECTOR[17,LONG],	! Vector of pointers to save areas for
					!      the current frame's registers
	ROUTPTR: REF RST$ENTRY,		! Pointer to RST entry for routine which
					!      declares the RSTPTR data item
	ROUT_INVOC_COUNT,		! Invocation count of ROUTPTR routine
	RPTR: REF RST$ENTRY,		! Pointer to RST entry for possible
					!      nested routine
	SATPTR: REF SAT$ENTRY,		! Pointer to Static Address Table entry
	SAVEREGSYMID,			! Save area for DBG$REG_SYMID
	SAVEREGVAL: VECTOR[17,LONG],	! Save area for DBG$REG_VALUES
	SAVEREGVEC: VECTOR[17,LONG],	! Save area for DBG$REG_VECTOR
	SCOPE: REF RST$ENTRY,		! Pointer to scope RST entry
	SCOPE_INVOC_COUNT,		! Invocation count of SCOPE routine
	SCOPE_INVOC_NUM,		! Invocation number we are looking for
					!      of routine pointed to by SCOPE
	STATIC_LINK_FP,			! Frame Pointer value from Static Link
					!      DST record
	VALKIND,			! Value kind returned by DBG$STA_VALSPEC
	VALVECTOR: VECTOR[3,LONG];	! Value vector returned by VALSPEC rout-
					!      ine: byte address, bit offset,
					!      and frame pointer value.



    ! If RSTPTR does not point to a Data Item RST Entry, we return it unchanged
    ! since invocation numbers are only meaningful for data objects.
    !
    IF .RSTPTR[RST$B_KIND] NEQ RST$K_DATA THEN RETURN .RSTPTR;


    ! If the scope is anything other than a routine or a block in a routine,
    ! it cannot have an associated invocation number.  We thus return the input
    ! RST pointer without change.
    !
    IF .SCOPE_RSTPTR EQL 0 THEN RETURN .RSTPTR;
    IF (.SCOPE_RSTPTR[RST$B_KIND] NEQ RST$K_ROUTINE) AND
       (.SCOPE_RSTPTR[RST$B_KIND] NEQ RST$K_BLOCK)
    THEN
	RETURN .RSTPTR;


    ! Get the invocation number associated with the scope RST entry.
    !
    SCOPE = .SCOPE_RSTPTR;
    SCOPE_INVOC_NUM = 0;
    IF .SCOPE[RST$V_INVOCNUM]
    THEN
	BEGIN
	INVPTR = .SCOPE[RST$L_SYMCHNPTR];
	SCOPE_INVOC_NUM = .INVPTR[RST$L_INVOCNUM];
	SCOPE = .INVPTR[RST$L_UPSCOPEPTR];
	END;


    ! If SCOPE points to a lexical block, find the nearest up-scope routine.
    ! This is the routine to which the scope's invocation number applies.
    !
    WHILE .SCOPE[RST$B_KIND] NEQ RST$K_ROUTINE DO
	BEGIN
	IF .SCOPE[RST$B_KIND] EQL RST$K_MODULE THEN RETURN .RSTPTR;
	SCOPE = .SCOPE[RST$L_UPSCOPEPTR];
	END;


    ! Get a pointer to the RST entry for the innermost routine up-scope from
    ! the data object RST entry.  This is the routine which immediately contains
    ! the desired data object.
    !
    ROUTPTR = .RSTPTR;
    WHILE .ROUTPTR[RST$B_KIND] NEQ RST$K_ROUTINE DO
	BEGIN
	IF .ROUTPTR[RST$B_KIND] EQL RST$K_MODULE THEN RETURN .RSTPTR;
	ROUTPTR = .ROUTPTR[RST$L_UPSCOPEPTR];
	END;


    ! If that innermost routine is the desired scope, we build a new RST entry
    ! for the data item with the scope's invocation number and return that.
    !
    IF .ROUTPTR EQL .SCOPE
    THEN
	BEGIN
	IF .SCOPE_INVOC_NUM EQL 0 THEN RETURN .RSTPTR;
	RETURN BUILD_INVOC_RST(.RSTPTR, .SCOPE_INVOC_NUM);
	END;


    ! The innermost routine and the desired scope are different.  We must thus
    ! go through the VAX call stack to find the proper ROUTPTR frame to go with
    ! the SCOPE we are starting with.  This requires us to follow static links
    ! where present to do the up-level addressing correctly.
    !
    ! We start by initializing the current stack frame's Program Counter (PC),
    ! Frame Pointer (FP), and other register values.  We mark R0 and R1 as being
    ! good--later in the stack they may not be since R0 and R1 are considered to
    ! be volatile accross subroutine calls.
    !
    PCVAL = .DBG$GL_RUNFRAME[DBG$L_USER_PC];
    FRAMEPTR = .DBG$GL_RUNFRAME[DBG$L_USER_FP];
    CURRENT_REG = DBG$GL_RUNFRAME[DBG$L_USER_REGS];
    INCR I FROM 0 TO 16 DO REGVEC[.I] = CURRENT_REG[.I];
    GOOD_R0 = TRUE;
    GOOD_R1 = TRUE;


    ! Search through the VAX call stack looking for the SCOPE routine's call
    ! frame and then the ROUTPTR call frame up-scope from it.  Pick up all
    ! register save area addresses in the stack along the way.
    !
    ROUT_INVOC_COUNT = 0;
    SCOPE_INVOC_COUNT = 0;
    STATIC_LINK_FP = 0;
    WHILE TRUE DO
	BEGIN


	! If we got to the bottom of the stack without finding the desired
	! invocation of the ROUTPTR routine, report an error.
	!
	IF (.PCVAL EQL 0)               OR
	   (.PCVAL EQL DBG$PSEUDO_EXIT) OR
	   (.FRAMEPTR EQL 0)            OR
	   (.FRAMEPTR[SF$A_HANDLER] EQL DBG$FINAL_HANDL)
	THEN
	    BEGIN
	    DBG$STA_SYMPATHNAME(.RSTPTR, PATHNAME);
	    DBG$NPATHDESC_TO_CS(.PATHNAME, PATHSTRING);
	    SIGNAL(DBG$_PROFRANOT, 1, .PATHSTRING);
	    END;


	! Check to see if the current call frame is a frame for the routine
	! currently pointed to by SCOPE.  If so, find the static link (if any)
	! and make SCOPE point to the RST entry of the routine immediately
	! up-scope from the routine currently pointed to by SCOPE.
	!
	IF (.PCVAL GEQU .SCOPE[RST$L_STARTADDR]) AND
	   (.PCVAL LEQU .SCOPE[RST$L_ENDADDR])
	THEN
	    BEGIN


	    ! The current PC value is in the range of the SCOPE routine, so we
	    ! set FRAME_FOUND_FLAG.  However, this frame could actually be for
	    ! a nested routine within the SCOPE routine.  We check for that and
	    ! clear FRAME_FOUND_FLAG if that turns out to be the case.
	    !
	    FRAME_FOUND_FLAG = TRUE;
	    SATPTR = .SCOPE[RST$L_RTNSATPTR];
	    SATPTR = .SATPTR[SAT$L_FLINK];
	    WHILE TRUE DO
		BEGIN
		IF .SATPTR EQL 0 THEN EXITLOOP;
		IF (.PCVAL LSSU .SATPTR[SAT$L_START]) THEN EXITLOOP;
		RPTR = .SATPTR[SAT$L_RSTPTR];
		IF (.PCVAL LEQU .SATPTR[SAT$L_END]) AND
		   (.RPTR[RST$B_KIND] EQL RST$K_ROUTINE)
		THEN
		    BEGIN
		    FRAME_FOUND_FLAG = FALSE;
		    EXITLOOP;
		    END;

		SATPTR = .SATPTR[SAT$L_FLINK];
		END;


	    ! If this call frame really is for the SCOPE routine, we see if it
	    ! is the invocation we are looking for.
	    !
	    IF .FRAME_FOUND_FLAG
	    THEN
		BEGIN


		! If this is the invocation we are looking for, determine which
		! invocation of the next routine up-scope from SCOPE to look
		! for next.
		!
		IF (.STATIC_LINK_FP EQL .FRAMEPTR) OR
		   (.SCOPE_INVOC_COUNT EQL .SCOPE_INVOC_NUM)
		THEN
		    BEGIN


		    ! This is the invocation of the SCOPE routine we want.  If
		    ! this frame is also a frame for the ROUTPTR routine, we
		    ! have found the call frame we want for the data item.  We
		    ! thus exit the loop searching through the call stack.
		    !
		    IF .SCOPE EQL .ROUTPTR THEN EXITLOOP;


		    ! If no Static Link DST record was specified, we want to
		    ! look for the first invocation in the stack of the routine
		    ! up-scope from the SCOPE routine.  We set SCOPE_INVOC_NUM
		    ! and SCOPE_INVOC_COUNT to make this happen.
		    !
		    IF .SCOPE[RST$L_STATIC_LINK] EQL 0
		    THEN
			BEGIN
			SCOPE_INVOC_NUM = 1;
			SCOPE_INVOC_COUNT = 0;
			STATIC_LINK_FP = 0;
			END


		    ! But if a Static Link DST record was specified for this
		    ! routine, we use the Value Spec in that DST record to pick
		    ! up the Static Link (in the form of a Frame Pointer).  We
		    ! disable looking for the first up-scope invocation.
		    !
		    ELSE
			BEGIN
			SCOPE_INVOC_NUM = 0;
			SCOPE_INVOC_COUNT = 0;


			! Save the current register values and pointers set up
			! by DBG$STA_SETCONTEXT.  Then substitute our own regis-
			! ter set in the arrays used in Value Spec evaluation.
			!
			SAVEREGSYMID = .DBG$REG_SYMID;
			DBG$REG_SYMID = .RSTPTR;
			INCR I FROM 0 TO 16 DO
			    BEGIN
			    SAVEREGVEC[.I] = .DBG$REG_VECTOR[.I];
			    SAVEREGVAL[.I] = .DBG$REG_VALUES[.I];
			    DBG$REG_VECTOR[.I] = .REGVEC[.I];
			    REGPTR = .REGVEC[.I];
			    IF .REGPTR NEQ 0 THEN DBG$REG_VALUES[.I] = .REGPTR[0];
			    END;

			IF (NOT .GOOD_R0) OR (NOT .GOOD_R1) THEN DBG$REG_VECTOR[0] = 0;
			IF (NOT .GOOD_R1) THEN DBG$REG_VECTOR[1] = 0;


			! Evaluate the Static Link Value Spec.  This produces a
			! pointer to the desired up-scope call frame.
			!
			DSTPTR = .SCOPE[RST$L_STATIC_LINK];
			DBG$STA_VALSPEC(DSTPTR[DST$A_SL_VALSPEC],
						VALVECTOR, VALKIND);
			STATIC_LINK_FP = .VALVECTOR[0];


			! Restore the saved register values and pointers.
			!
			DBG$REG_SYMID = .SAVEREGSYMID;
			INCR I FROM 0 TO 16 DO
			    BEGIN
			    DBG$REG_VECTOR[.I] = .SAVEREGVEC[.I];
			    DBG$REG_VALUES[.I] = .SAVEREGVAL[.I];
			    END;

			END;		! End of Static Link evaluation


		    ! Follow the up-scope pointer from the SCOPE routine's RST
		    ! entry to the next routine up-scope.  Set SCOPE to point
		    ! to that routine's Routine RST Entry.
		    !
		    SCOPE = .SCOPE[RST$L_UPSCOPEPTR];
		    WHILE .SCOPE[RST$B_KIND] NEQ RST$K_ROUTINE DO
			BEGIN
			IF .SCOPE[RST$B_KIND] EQL RST$K_MODULE
			THEN
			    SIGNAL(DBG$_DEBUGBUG, 1, 187);

			SCOPE = .SCOPE[RST$L_UPSCOPEPTR];
			END;

		    END;		! End of STATIC_LINK_FP IF-statement


		! We now know what routine and frame to look for next.  Incre-
		! ment the invocation count for the current SCOPE routine.
		!
		SCOPE_INVOC_COUNT = .SCOPE_INVOC_COUNT + 1;

		END;			! End of FRAME_FOUND_FLAG IF-statement

	    END;			! End of PCVAL in SCOPE IF-statement


	! Check to see if the current call frame is a frame for the ROUTPTR
	! routine (but not for a nested routine within the ROUTPTR routine).
	! If so, increment the ROUTPTR routine's invocation count.  This code
	! thus computes the data item's final invocation count.
	!
	IF (.PCVAL GEQU .ROUTPTR[RST$L_STARTADDR]) AND
	   (.PCVAL LEQU .ROUTPTR[RST$L_ENDADDR])
	THEN
	    BEGIN
	    FRAME_FOUND_FLAG = TRUE;
	    SATPTR = .ROUTPTR[RST$L_RTNSATPTR];
	    SATPTR = .SATPTR[SAT$L_FLINK];
	    WHILE TRUE DO
		BEGIN
		IF .SATPTR EQL 0 THEN EXITLOOP;
		IF (.PCVAL LSSU .SATPTR[SAT$L_START]) THEN EXITLOOP;
		RPTR = .SATPTR[SAT$L_RSTPTR];
		IF (.PCVAL LEQU .SATPTR[SAT$L_END]) AND
		   (.RPTR[RST$B_KIND] EQL RST$K_ROUTINE)
		THEN
		    BEGIN
		    FRAME_FOUND_FLAG = FALSE;
		    EXITLOOP;
		    END;

		SATPTR = .SATPTR[SAT$L_FLINK];
		END;

	    IF .FRAME_FOUND_FLAG
	    THEN
		ROUT_INVOC_COUNT = .ROUT_INVOC_COUNT + 1;

	    END;


	! Pick up the addresses of the register save areas in this call frame.
	! Save those addresses in REGVEC.  This allows us to keep track of the
	! current register values as we go on to the next frame in the stack.
	!
	REGMASK = .FRAMEPTR[SF$W_SAVE_MASK];
	GOOD_R0 = .REGMASK[0];
	GOOD_R1 = .REGMASK[1];
	REGSAVELOC = FRAMEPTR[SF$L_SAVE_REGS];
	J = 0;
	INCR I FROM 0 TO 11 DO
	    BEGIN
	    IF .REGMASK[.I]
	    THEN
		BEGIN
		REGVEC[.I] = REGSAVELOC[.J];
		J = .J + 1;
		END;

	    END;

	REGVEC[12] = FRAMEPTR[SF$L_SAVE_AP];
	REGVEC[13] = FRAMEPTR[SF$L_SAVE_FP];
	REGVEC[14] = SPVALUE;
	REGVEC[15] = FRAMEPTR[SF$L_SAVE_PC];
	REGVEC[16] = FRAMEPTR[SF$W_SAVE_PSW];


	! Determine what the value of SP (the Stack Pointer) will be when this
	! call frame is torn down by the RET instruction.  Save that in SPVALUE.
	!
	SPVALUE = REGSAVELOC[.J];
	SPVALUE = .SPVALUE + .FRAMEPTR[SF$V_STACKOFFS];
	IF .FRAMEPTR[SF$V_CALLS] THEN SPVALUE = .SPVALUE + 4*(.SPVALUE[0] + 1);


	! Loop for the next stack frame.
	!
	PCVAL = .FRAMEPTR[SF$L_SAVE_PC];
	FRAMEPTR = .FRAMEPTR[SF$L_SAVE_FP];

	END;				! End of loop through the call stack


    ! We have now found the proper invocation number for the ROUTPTR routine.
    ! We thus build an RST entry for the data item with that invocation number
    ! (if necessary) and return a pointer to that RST entry.
    !
    IF .ROUT_INVOC_COUNT EQL 0 THEN RETURN .RSTPTR;
    RETURN BUILD_INVOC_RST(.RSTPTR, .ROUT_INVOC_COUNT);

    END;

ROUTINE LINE_NUM_RST(LEXPTR, LINE_NUM, STMT_NUM, LINESTART, LINEEND) =
!
! FUNCTION
!	This routine builds a Line Number RST Entry for a specified line and
!	links it into the RST.  In addition to the RST entry, a dummy Label DST
!	Record is built (in the same memory block) to contain the line's name
!	as Counted ASCII (e.g. "%LINE 25.3").  The RST entry is linked into the
!	Temporary RST Entry List pointed to by RST$TEMP_LIST.
!
! INPUTS
!	LEXPTR	- A pointer to the lexical entity RST entry to which the Line
!		  Number RST Entry should be attached via the up-scope pointer.
!
!	LINE_NUM - The line's line number.
!
!	STMT_NUM - The line's statement number.
!
!	LINESTART - The line's start address in virtual memory.
!
!	LINEEND	- The line's end address in virtual memory.
!
! OUTPUTS
!	A pointer to the line's Line Number RST Entry is returned as the
!		  routine's value.
!

    BEGIN

    LOCAL
	DSTPTR: REF DST$RECORD,		! Pointer to dummy Label DST Record
	J,				! Index into the TEXT array; number of
					!      characters in the line's name
	NAMEPTR: REF VECTOR[,BYTE],	! Pointer to DST record name vector
	NUMBER,				! Used to convert the statement and line
					!      numbers to ASCII
	RSTPTR: REF RST$ENTRY,		! Pointer to Line Number RST Entry
	TEXT: VECTOR[40,BYTE];		! Vector used to generate ASCII name



    ! Build the line number name as an ASCII string in the TEXT vector.  Note
    ! that the string is stored backward in this vector since we generate low-
    ! order numeric digits before high-order ones.
    !
    J = 0;
    IF .STMT_NUM NEQ 0
    THEN
	BEGIN
	NUMBER = .STMT_NUM;
	WHILE TRUE DO
	    BEGIN
	    TEXT[.J] = (.NUMBER MOD 10) + '0';
	    J = .J + 1;
	    NUMBER = .NUMBER/10;
	    IF .NUMBER EQL 0 THEN EXITLOOP;
	    END;

	TEXT[.J] = '.';
	J = .J + 1;
	END;

    NUMBER = .LINE_NUM;
    WHILE TRUE DO
	BEGIN
	TEXT[.J] = (.NUMBER MOD 10) + '0';
	J = .J + 1;
	NUMBER = .NUMBER/10;
	IF .NUMBER EQL 0 THEN EXITLOOP;
	END;

    J = .J + 6;
    TEXT[.J - 1] = '%';
    TEXT[.J - 2] = 'L';
    TEXT[.J - 3] = 'I';
    TEXT[.J - 4] = 'N';
    TEXT[.J - 5] = 'E';
    TEXT[.J - 6] = ' ';


    ! Allocate enough space for the Line Number RST Entry and for a Label DST
    ! record (which we will build in the same memory block).
    !
    RSTPTR = DBG$GET_MEMORY(RST$K_LINENTSIZ + (.J + 11)/4);
    DSTPTR = .RSTPTR + 4*RST$K_LINENTSIZ;


    ! Construct the dummy Label DST record for the line number.
    !
    DSTPTR[DST$B_LENGTH] = 7 + .J;
    DSTPTR[DST$B_TYPE] = DST$K_LABEL;
    DSTPTR[DST$B_VFLAGS] = 0;
    DSTPTR[DST$L_VALUE] = .LINESTART;
    NAMEPTR = DSTPTR[DST$B_NAME];
    NAMEPTR[0] = .J;
    INCR I FROM 1 TO .J DO NAMEPTR[.I] = .TEXT[.J - .I];


    ! Then construct the Line Number RST Entry for the line.
    !
    RSTPTR[RST$L_DSTPTR] = .DSTPTR;
    RSTPTR[RST$L_UPSCOPEPTR] = .LEXPTR;
    RSTPTR[RST$B_KIND] = RST$K_LINE;
    RSTPTR[RST$L_STARTADDR] = .LINESTART;
    RSTPTR[RST$L_ENDADDR] = .LINEEND;


    ! Link the RST entry into the Temporary RST Entry List.
    !
    RSTPTR[RST$L_HASH_FLINK] = .RST$TEMP_LIST;
    RST$TEMP_LIST = .RSTPTR;


    ! Return to the caller with the RST entry address as the routine value.
    !
    RETURN .RSTPTR;

    END;

ROUTINE NUMBERED_SCOPE(SCOPE_NUMBER, MODRSTPTR, SCOPE, INVOCNUM): NOVALUE =
!
! FUNCTION
!	This routine determines what scope corresponds to a given "numbered"
!	scope at this point in the user program's execution.  This scope is de-
!	termined by looking SCOPE_NUMBER levels down in the VAX CALL-stack and
!	picking up the PC value in that call frame.  The Program Static Address
!	Table (SAT) is searched for this PC value to find the containing module,
!	and after that the module's SAT is searched if the module is marked as
!	SET.  The module's RST is built if not already present.  The search is
!	successful if a Routine RST Entry or a Lexical Block RST Entry is found
!	whose address range contains the PC value.
!
! INPUTS
!	SCOPE_NUMBER - The number of the "numbered scope" to be located.  This
!		  number is zero for the current scope, i.e. the scope where
!		  the PC is located at present, and it is N for the scope which
!		  contains the PC N levels down in the VAX CALL-stack.
!
!	MODRSTPTR - The address of a longword location to receive a pointer to
!		  the Module RST Entry for the numbered scope.
!
!	SCOPE	- The address of a longword location to receive a pointer to the
!		  Routine or Lexical Block RST Entry which defines the numbered
!		  scope.
!
!	INVOCNUM - The address of a longword location to receive the correspond-
!		  ing invocation number.
!
! OUTPUTS
!	MODRSTPTR - A pointer to the numbered scope's Module RST Entry is
!		  returned to MODRSTPTR.  If the scope cannot be found, a
!		  zero is returned to MODRSTPTR.
!
!	SCOPE	- A pointer to the RST entry of the routine or lexical block
!		  which constitutes the numbered scope is returned to SCOPE.
!		  If the scope cannot be found, a zero is returned to SCOPE.
!
!	INVOCNUM - The invocation number of the scope is returned to INVOCNUM.
!
!	No value is returned.
!

    BEGIN

    MAP
	MODRSTPTR: REF VECTOR[1],	! Pointer to longword to receive the
					!      Module RST Entry pointer
	SCOPE: REF VECTOR[1],		! Pointer to longword to receive the
					!      numbered scope RST pointer
	INVOCNUM: REF VECTOR[1];	! Pointer to longword to receive the
					!      scope's invocation number

    LOCAL
	FRAMEPTR: REF BLOCK[,BYTE],	! Pointer to stack CALL frames
	MODPTR: REF RST$ENTRY,		! Pointer to scope's Module RST Entry
	PCVAL,				! The CALL-frame Program Counter value
	ROUTPTR: REF RST$ENTRY,		! Pointer to RST entry for inner-most
					!       routine in up-scope chain
	RPTR: REF RST$ENTRY,		! Pointer used to search up-scope chain
	RSTPTR: REF RST$ENTRY,		! Pointer to numbered scope's RST entry
	SATPTR: REF SAT$ENTRY;		! Pointer to the current Static Address
					!      Table entry



    ! Return zeroes (no find) to MODRSTPTR and SCOPE initially.
    !
    MODRSTPTR[0] = 0;
    SCOPE[0] = 0;


    ! Pick up the current Program Counter value from the user's run frame.
    ! Then search through the CALL frames on the stack until the desired run
    ! frame (and thus PC value) is reached.  If the CALL stack ends before
    ! then, return with MODRSTPTR and SCOPE containing zeroes.
    !
    PCVAL = .DBG$GL_RUNFRAME[DBG$L_USER_PC];
    IF .PCVAL EQL 0 THEN RETURN;
    FRAMEPTR = .DBG$GL_RUNFRAME[DBG$L_USER_FP];
    INCR I FROM 1 TO .SCOPE_NUMBER DO
	BEGIN
	IF (.FRAMEPTR[SF$A_HANDLER] EQL DBG$FINAL_HANDL) OR
	   (.PCVAL EQL DBG$PSEUDO_EXIT)
	THEN
	    RETURN;

	PCVAL = .FRAMEPTR[SF$L_SAVE_PC];
	FRAMEPTR = .FRAMEPTR[SF$L_SAVE_FP];
	END;


    ! Search the Program Static Address Table (SAT) for the module which con-
    ! tains the PC value we found.  If we don't find such a module, return
    ! with MODRSTPTR and SCOPE containing zeroes.
    !
    SATPTR = .SAT$START_ADDR;
    WHILE TRUE DO
	BEGIN
	IF .SATPTR EQL 0 THEN RETURN;
	IF .PCVAL GEQ .SATPTR[SAT$L_START] AND .PCVAL LEQ .SATPTR[SAT$L_END]
	THEN
	    EXITLOOP;

	SATPTR = .SATPTR[SAT$L_FLINK];
	END;


    ! We found the module.  If the module is SET, search its SAT chain for the
    ! inner-most lexical entity containing the PC value.
    !
    MODPTR = .SATPTR[SAT$L_RSTPTR];
    IF NOT .MODPTR[RST$V_MODSET] THEN RETURN;
    IF NOT .MODPTR[RST$V_MOD_IN_RST] THEN DBG$RST_BUILD(.MODPTR);
    RSTPTR = 0;
    SATPTR = .MODPTR[RST$L_SAT_PTR];
    WHILE TRUE DO
	BEGIN
	IF .SATPTR EQL 0 THEN EXITLOOP;
	IF .SATPTR[SAT$L_START] GTR .PCVAL THEN EXITLOOP;
	IF .SATPTR[SAT$L_END] GEQ .PCVAL
	THEN
	    BEGIN
	    RPTR = .SATPTR[SAT$L_RSTPTR];


	    ! If this static item is not a routine of block, ignore it.
	    !
	    IF .RPTR[RST$B_KIND] NEQ RST$K_ROUTINE AND
	       .RPTR[RST$B_KIND] NEQ RST$K_BLOCK
	    THEN
		0


	    ! It is a lexical entity.  If it is the first one we have found,
	    ! save its RST pointer in RSTPTR.
	    !
	    ELSE IF .RSTPTR EQL 0
	    THEN
		RSTPTR = .SATPTR[SAT$L_RSTPTR]


	    ! Otherwise, make sure it is the inner-most lexical entity so far.
	    ! If not, ignore it.
	    !
	    ELSE
		BEGIN
		WHILE .RPTR[RST$B_KIND] NEQ RST$K_MODULE DO
		    BEGIN
		    IF .RPTR EQL .RSTPTR
		    THEN
			BEGIN
			RSTPTR = .SATPTR[SAT$L_RSTPTR];
			EXITLOOP;
			END;

		    RPTR = .RPTR[RST$L_UPSCOPEPTR];
		    END;

		END;

	    END;

	SATPTR = .SATPTR[SAT$L_FLINK];
	END;


    ! If we did not find the containing lexical entity, return with MODRSTPTR
    ! and SCOPE containing zeroes.
    !
    IF .RSTPTR EQL 0 THEN RETURN;


    ! We found the scope successfully.  Return the proper RST pointers to
    ! MODRSTPTR and SCOPE.
    !
    MODRSTPTR[0] = .MODPTR;
    SCOPE[0] = .RSTPTR;


    ! Now search the CALL stack again to determine what the invocation number is
    ! for the routine which constitutes or immediately contains the scope.
    !
    INVOCNUM[0] = 0;
    ROUTPTR = .RSTPTR;
    WHILE .ROUTPTR[RST$B_KIND] NEQ RST$K_ROUTINE DO
	BEGIN
	IF .ROUTPTR[RST$B_KIND] EQL RST$K_MODULE THEN RETURN;
	ROUTPTR = .ROUTPTR[RST$L_UPSCOPEPTR];
	END;

    PCVAL = .DBG$GL_RUNFRAME[DBG$L_USER_PC];
    FRAMEPTR = .DBG$GL_RUNFRAME[DBG$L_USER_FP];
    INCR I FROM 1 TO .SCOPE_NUMBER DO
	BEGIN
	IF (.PCVAL GEQ .ROUTPTR[RST$L_STARTADDR]) AND
	   (.PCVAL LEQ .ROUTPTR[RST$L_ENDADDR])
	THEN
	    INVOCNUM[0] = .INVOCNUM[0] + 1;

	PCVAL = .FRAMEPTR[SF$L_SAVE_PC];
	FRAMEPTR = .FRAMEPTR[SF$L_SAVE_FP];
	END;


    ! We are all done.  Now return.
    !
    RETURN;

    END;

ROUTINE SCOPE_RULE_COBOL(PATHNAME, NCANDS, CANDLST, SCOPE) =
!
! FUNCTION
!	This routine selects the symbol from a specified list of candidate sym-
!	bols which best matches a specified pathname.  This routine assumes
!	COBOL scope rules when doing so.  This means that incomplete data quali-
!	fication is accepted, and that uniqueness is determined by these rules:
!
!	    (1)	By definition, the "lowest definition depth" is the
!		inner-most definition depth in the current scope at
!		which at least one candidate symbol is declared.
!
!	    (2)	If only one candidate symbol is defined at the lowest
!		definition depth, then that is the unique symbol we
!		want.
!
!	    (3)	Otherwise, the symbol is not unique.
!
!	An additional COBOL scope rule is that any candidate which is not marked
!	as "global" (i.e., does not have the RST$V_COBOLGBL bit set) may not be
!	declared outside the routine which contains the current scope.  In other
!	words, a COBOL symbol declared in one routine is not visible in any
!	nested routine unless it is specifically marked as being so visible.
!
!	The list of candidate symbols is produced by DBG$STA_GETSYMBOL, and each
!	candidate is guaranteed to be in the current scope being searched.  What
!	this routine must do is to determine which candidates have valid data
!	qualification, which candidate is defined at the lowest definition depth
!	(i.e., defined inner-most in the current scope), and whether that candi-
!	date is unique.  The routine then returns one of three things: an indi-
!	cation that no symbol was valid, an indication that the symbol is not
!	unique, or an index pointing to the one selected candidate symbol.
!
! INPUTS
!	PATHNAME - Pointer to the pathname descriptor for the symbol name to
!		  be looked up in the symbol table.
!
!	NCANDS	- The number of candidate symbols found by DBG$STA_GETSYMBOL.
!
!	CANDLST	- A vector of pointers to the "candidate blocks" for the candi-
!		  date symbols found by DBG$STA_GETSYMBOL.  Each of these candi-
!		  dates is in the scope currently searched.  The candidate block
!		  pointers are found in CANDLST[1] through CANDLST[.NCANDS].
!
!	SCOPE	- A pointer to the RST entry for the current scope in which the
!		  symbol is being looked up.  This normally points to a Routine
!		  RST Entry or a Lexical Block RST Entry.  (COBOL Sections and
!		  Paragraphs are represented as lexical blocks in DEBUG.)  If
!		  the current scope is the Global Scope (\) or All Set Modules,
!		  the SCOPE parameter is zero.
!
! OUTPUTS
!	The CANDLST index for the candidate block which best matches the path-
!		  name is returned as the routine's value.  If no candidate is
!		  acceptable, zero is returned, and if more than one candidate
!		  is acceptable (the symbol is not unique), -1 is returned.
!

    BEGIN

    MAP
	PATHNAME: REF PTH$PATHNAME,	! Pointer to symbol pathname descriptor
	CANDLST: REF VECTOR[,LONG],	! Pointer to candidate vector
	SCOPE: REF RST$ENTRY;		! Pointer to current scope RST entry

    LABEL
	CHECK_THIS_CANDIDATE;		! Label of block we want to LEAVE

    LOCAL
	CANDBLK: REF CAND_BLOCKVECTOR,	! Pointer to current "candidate block"
	COBOLGBL_FLAG,			! Flag set to TRUE if the COBOL Global
					!      Attribute applies to this item
	DATA_INDEX,			! Index into CANDBLK vector of Data Item
					!      RST Entry pointer (or zero)
	DATAQUAL_FLAG,			! Set to TRUE when we are in the data
					!      qualification part of a name
	DEFDEPTH,			! Definition depth of current candidate
	DSTPTR: REF DST$RECORD,		! Pointer to symbol DST record
	GOOD_CAND,			! CANDLST index of best candidate so far
	GOOD_DEFDEPTH,			! Definition depth of GOOD_CAND symbol
	GOOD_STATADDR,			! Static address of GOOD_CAND symbol
	J,				! Index for CANDBLK vector
	RSTPTR: REF RST$ENTRY,		! Pointer to current symbol RST entry
	SCPTR: REF RST$ENTRY,		! Pointer used to follow current scope's
					!      up-scope chain
	STATADDR,			! Static address of symbol or zero
	SYMSCOPE: REF RST$ENTRY;	! The actual scope of the current symbol



    ! Initially we do not have a good candidate.
    !
    GOOD_CAND = 0;
    GOOD_DEFDEPTH = 1000000;
    GOOD_STATADDR = 0;


    ! Loop over all the candidate blocks on the candidate list.  This loop
    ! searches for the best candidate symbol matching the pathname.
    !
    INCR I FROM 1 TO .NCANDS DO
	BEGIN


	! Set up a labelled block to check out the current candidate.  We can
	! LEAVE this block if we find that the candidate is not acceptable.
	!
	CHECK_THIS_CANDIDATE:
	    BEGIN
	    CANDBLK = .CANDLST[.I];


	    ! Loop over the candidate's up-scope chain--that is what the CANDBLK
	    ! vector gives us.  Reject any candidate whose data qualification in
	    ! the up-scope chain does not agree with that in the pathname.
	    !
	    DATA_INDEX = 0;
	    COBOLGBL_FLAG = FALSE;
	    DATAQUAL_FLAG = TRUE;
	    J = 0;
	    WHILE .CANDBLK[.J, CAND_RSTPTR] NEQ 0 DO
		BEGIN
		RSTPTR = .CANDBLK[.J, CAND_RSTPTR];


		! Clear DATAQUAL_FLAG if we have left the data qualification
		! part of the name.
		!
		IF (.CANDBLK[.J, CAND_PINDEX] LSS .PATHNAME[PTH$B_PATHCNT]) AND
		   (.CANDBLK[.J, CAND_PINDEX] NEQ 0)
		THEN
		    DATAQUAL_FLAG = FALSE;

		IF (.RSTPTR[RST$B_KIND] NEQ RST$K_DATA) AND
		   (.RSTPTR[RST$B_KIND] NEQ RST$K_TYPCOMP)
		THEN
		    DATAQUAL_FLAG = FALSE;


		! After we leave the data qualification part going up-scope, we
		! do not accept Data Items or Type Components in the name.
		!
		IF (NOT .DATAQUAL_FLAG)                AND
		   (.RSTPTR[RST$B_KIND] EQL RST$K_DATA OR
		    .RSTPTR[RST$B_KIND] EQL RST$K_TYPCOMP)
		THEN
		    LEAVE CHECK_THIS_CANDIDATE;


		! If this is the main Data Item RST Entry in the CANDBLK up-
		! scope chain, save its index in DATA_INDEX.  Also set the
		! COBOL Global Attribute flag if the RST entry is so marked.
		!
		IF .RSTPTR[RST$B_KIND] EQL RST$K_DATA
		THEN
		    BEGIN
		    DATA_INDEX = .J;
		    IF .RSTPTR[RST$V_COBOLGBL] THEN COBOLGBL_FLAG = TRUE;
		    END;


		! Increment the CANDBLK index and loop up-scope.
		!
		J = .J + 1;
		END;


	    ! Pick up the definition depth from the last CANDBLK cell.  Reject
	    ! this candidate if we already have a candidate with a smaller def-
	    ! inition depth (i.e., defined closer to the current scope).
	    !
	    RSTPTR = .CANDBLK[.DATA_INDEX, CAND_RSTPTR];
	    DEFDEPTH = .CANDBLK[.J, CAND_PINDEX];
	    IF .DEFDEPTH GTR .GOOD_DEFDEPTH THEN LEAVE CHECK_THIS_CANDIDATE;


	    ! Unless the COBOL "global" flag is set for this symbol, we see if
	    ! the symbol is declared in a routine outside the current scope.
	    ! If it is, we must reject the symbol.  In COBOL, a symbol is not
	    ! visible in nested routines unless marked as "global".  Note that
	    ! we skip this check if SCOPE is zero, meaning that the scope is
	    ! the GST or all SET modules.  We also skip the check for symbols
	    ! which are not data--these rules do not apply to routines, etc.
	    !
	    IF (NOT .COBOLGBL_FLAG) AND
	       (.SCOPE NEQ 0)       AND
	       (.RSTPTR[RST$B_KIND] EQL RST$K_DATA)
	    THEN
		BEGIN


		! Determine the scope in which the current symbol is declared.
		!
		SYMSCOPE = .RSTPTR;
		IF .RSTPTR[RST$B_KIND] NEQ RST$K_MODULE
		THEN
		    SYMSCOPE = .RSTPTR[RST$L_UPSCOPEPTR];

		IF .SYMSCOPE[RST$B_KIND] EQL RST$K_TYPE
		THEN
		    SYMSCOPE = .SYMSCOPE[RST$L_UPSCOPEPTR];


		! See if there is a routine declaration between the current
		! scope and the environment in which the symbol is declared.
		! If so, reject this candidate--it is not visible from the
		! current scope.
		!
		SCPTR = .SCOPE;
		WHILE .SCPTR NEQ .SYMSCOPE DO
		    BEGIN
		    IF .SCPTR[RST$B_KIND] EQL RST$K_ROUTINE
		    THEN
			LEAVE CHECK_THIS_CANDIDATE;

		    IF .SCPTR[RST$B_KIND] EQL RST$K_MODULE
		    THEN
			SIGNAL(DBG$_DEBUGBUG, 1, 188);

		    SCPTR = .SCPTR[RST$L_UPSCOPEPTR];
		    END;

		END;


	    ! Determine the static address of this symbol.  This is needed to
	    ! allow us to pick one symbol in a Common Block even if it is not
	    ! unique.  For non-static symbols, we make that address zero.
	    !
	    STATADDR = 0;
	    IF .RSTPTR[RST$B_KIND] EQL RST$K_DATA
	    THEN
		BEGIN
		DSTPTR = .RSTPTR[RST$L_DSTPTR];
		IF ((.DSTPTR[DST$B_TYPE] GEQ DSC$K_DTYPE_LOWEST AND
		     .DSTPTR[DST$B_TYPE] LEQ DSC$K_DTYPE_HIGHEST) OR
		    (.DSTPTR[DST$B_TYPE] EQL DST$K_SEPTYP))       AND
		   (.DSTPTR[DST$B_VFLAGS] EQL DST$K_VALKIND_ADDR)
		THEN
		    STATADDR = .DSTPTR[DST$L_VALUE];

		END;


	    ! We have a good candidate here.  If we already have another candi-
	    ! date at the same definition depth, the symbol is not unique.  We
	    ! set GOOD_CAND to -1 to indicate this and reject the candidate.
	    !
	    IF .DEFDEPTH EQL .GOOD_DEFDEPTH
	    THEN
		BEGIN
		IF .STATADDR EQL 0 OR .STATADDR NEQ .GOOD_STATADDR
		THEN
		    GOOD_CAND = -1;

		LEAVE CHECK_THIS_CANDIDATE;
		END;


	    ! We have a good candidate which is unique (so far) at this defini-
	    ! tion depth.  Set GOOD_CAND accordingly.
	    !
	    GOOD_CAND = .I;
	    GOOD_DEFDEPTH = .DEFDEPTH;
	    GOOD_STATADDR = .STATADDR;

	    END;			! End of the CHECK_THIS_CANDIDATE block

	END;				! End of INCR loop over candidate list


    ! Return the GOOD_CAND value.  This may be -1, 0, or a true CANDLST index.
    !
    RETURN .GOOD_CAND;

    END;

ROUTINE SCOPE_RULE_NORMAL(PATHNAME, NCANDS, CANDLST) =
!
! FUNCTION
!	This routine selects the symbol from a specified list of candidate sym-
!	bols which best matches a specified pathname.  This routine assumes
!	"normal" scope rules when doing so; in particular, it assumes that data
!	qualification must be complete (A.C is not accepted for A.B.C) or is not
!	present in the language.  These rules suit languages like Pascal and
!	Fortran.
!
!	The list of candidate symbols is produced by DBG$STA_GETSYMBOL, and each
!	candidate is guaranteed to be in the current scope being searched.  What
!	this routine must do is to determine which candidates have valid data
!	qualification, which candidate is defined at the lowest definition depth
!	(i.e., defined inner-most in the current scope), and whether that candi-
!	date is unique.  The routine then returns one of three things: an indi-
!	cation that no symbol was valid, an indication that the symbol is not
!	unique, or an index pointing to the one selected candidate symbol.
!
! INPUTS
!	PATHNAME - Pointer to the pathname descriptor for the symbol name to
!		  be looked up in the symbol table.
!
!	NCANDS	- The number of candidate symbols found by DBG$STA_GETSYMBOL.
!
!	CANDLST	- A vector of pointers to the "candidate blocks" for the candi-
!		  date symbols found by DBG$STA_GETSYMBOL.  Each of these candi-
!		  dates is in the scope currently searched.  The candidate block
!		  pointers are found in CANDLST[1] through CANDLST[.NCANDS].
!
! OUTPUTS
!	The CANDLST index for the candidate block which best matches the path-
!		  name is returned as the routine's value.  If no candidate is
!		  acceptable, zero is returned, and if more than one candidate
!		  is acceptable (the symbol is not unique), -1 is returned.
!

    BEGIN

    MAP
	PATHNAME: REF PTH$PATHNAME,	! Pointer to symbol pathname descriptor
	CANDLST: REF VECTOR[,LONG];	! Pointer to candidate vector

    LABEL
	CHECK_THIS_CANDIDATE;		! Label of block we want to LEAVE

    LOCAL
	CANDBLK: REF CAND_BLOCKVECTOR,	! Pointer to current "candidate block"
	DEFDEPTH,			! Definition depth of current candidate
	DSTPTR: REF DST$RECORD,		! Pointer to symbol DST record
	GOOD_CAND,			! CANDLST index of best candidate so far
	GOOD_DEFDEPTH,			! Definition depth of GOOD_CAND symbol
	GOOD_STATADDR,			! Static address of GOOD_CAND symbol
	J,				! Index for CANDBLK vector
	RSTPTR: REF RST$ENTRY,		! Pointer to current symbol RST entry
	STATADDR;			! Static address of symbol or zero



    ! Initially we do not have a good candidate.
    !
    GOOD_CAND = 0;
    GOOD_DEFDEPTH = 1000000;
    GOOD_STATADDR = 0;


    ! Loop over all the candidate blocks on the candidate list.  This loop
    ! searches for the best candidate symbol matching the pathname.
    !
    INCR I FROM 1 TO .NCANDS DO
	BEGIN


	! Set up a labelled block to check out the current candidate.  We can
	! LEAVE this block if we find that the candidate is not acceptable.
	!
	CHECK_THIS_CANDIDATE:
	    BEGIN
	    CANDBLK = .CANDLST[.I];


	    ! Loop over the candidate's up-scope chain--that is what the CANDBLK
	    ! vector gives us.  Reject any candidate whose data qualification in
	    ! the up-scope chain does not agree with that in the pathname.
	    !
	    J = 0;
	    WHILE .CANDBLK[.J, CAND_RSTPTR] NEQ 0 DO
		BEGIN
		RSTPTR = .CANDBLK[.J, CAND_RSTPTR];


		! No item before a backslash and no item not explicitly given
		! in the Pathname Descriptor may be a Data Item or Type Compo-
		! nent.  This ensures complete data qualification when present.
		!
		IF (.CANDBLK[.J, CAND_PINDEX] LSS .PATHNAME[PTH$B_PATHCNT] OR
		    .CANDBLK[.J, CAND_PINDEX] EQL 0)                       AND
		   (.RSTPTR[RST$B_KIND] EQL RST$K_DATA OR
		    .RSTPTR[RST$B_KIND] EQL RST$K_TYPCOMP)
		THEN
		    LEAVE CHECK_THIS_CANDIDATE;


		! No item immediately before the first dot (i.e., X in A\X or
		! A\X.B) may be a Type Component and, if there are record com-
		! ponents, that item must be a Data item.  Again, this ensures
		! that data qualification is complete.
		!
		IF (.CANDBLK[.J, CAND_PINDEX] EQL .PATHNAME[PTH$B_PATHCNT]) AND
		   ((.RSTPTR[RST$B_KIND] EQL RST$K_TYPCOMP) OR
		    (.PATHNAME[PTH$B_TOTCNT] GTR .PATHNAME[PTH$B_PATHCNT] AND
		     .RSTPTR[RST$B_KIND] NEQ RST$K_DATA))
		THEN
		    LEAVE CHECK_THIS_CANDIDATE;


		! If this item is part of the data qualification, it must be a
		! Type Component.
		!
		IF (.CANDBLK[.J, CAND_PINDEX] GTR .PATHNAME[PTH$B_PATHCNT]) AND
		   (.RSTPTR[RST$B_KIND] NEQ RST$K_TYPCOMP)
		THEN
		    LEAVE CHECK_THIS_CANDIDATE;


		! Increment the CANDBLK index and loop up-scope.
		!
		J = .J + 1;
		END;


	    ! Pick up the definition depth from the last CANDBLK cell.  Reject
	    ! this candidate if we already have a candidate with a smaller def-
	    ! inition depth (i.e., defined closer to the current scope).
	    !
	    DEFDEPTH = .CANDBLK[.J, CAND_PINDEX];
	    IF .DEFDEPTH GTR .GOOD_DEFDEPTH THEN LEAVE CHECK_THIS_CANDIDATE;


	    ! Determine the static address of this symbol.  This is needed to
	    ! allow us to pick one symbol in a Common Block even if it is not
	    ! unique.  For non-static symbols, we make that address zero.
	    !
	    STATADDR = 0;
	    IF .RSTPTR[RST$B_KIND] EQL RST$K_DATA
	    THEN
		BEGIN
		DSTPTR = .RSTPTR[RST$L_DSTPTR];
		IF ((.DSTPTR[DST$B_TYPE] GEQ DSC$K_DTYPE_LOWEST AND
		     .DSTPTR[DST$B_TYPE] LEQ DSC$K_DTYPE_HIGHEST) OR
		    (.DSTPTR[DST$B_TYPE] EQL DST$K_SEPTYP))       AND
		   (.DSTPTR[DST$B_VFLAGS] EQL DST$K_VALKIND_ADDR)
		THEN
		    STATADDR = .DSTPTR[DST$L_VALUE];

		END;


	    ! We have a good candidate here.  If we already have another candi-
	    ! date at the same definition depth, the symbol is not unique.  We
	    ! set GOOD_CAND to -1 to indicate this and reject the candidate.
	    !
	    IF .DEFDEPTH EQL .GOOD_DEFDEPTH
	    THEN
		BEGIN
		IF .STATADDR EQL 0 OR .STATADDR NEQ .GOOD_STATADDR
		THEN
		    GOOD_CAND = -1;

		LEAVE CHECK_THIS_CANDIDATE;
		END;


	    ! We have a good candidate which is unique (so far) at this defini-
	    ! tion depth.  Set GOOD_CAND accordingly.
	    !
	    GOOD_CAND = .I;
	    GOOD_DEFDEPTH = .DEFDEPTH;
	    GOOD_STATADDR = .STATADDR;

	    END;			! End of the CHECK_THIS_CANDIDATE block

	END;				! End of INCR loop over candidate list


    ! Return the GOOD_CAND value.  This may be -1, 0, or a true CANDLST index.
    !
    RETURN .GOOD_CAND;

    END;

ROUTINE SCOPE_RULE_PLI(PATHNAME, NCANDS, CANDLST) =
!
! FUNCTION
!	This routine selects the symbol from a specified list of candidate sym-
!	bols which best matches a specified pathname.  This routine assumes
!	PL/I scope rules when doing so.  This means that incomplete data quali-
!	fication is accepted, and that uniqueness is determined by these rules:
!
!	    (1)	By definition, the "lowest definition depth" is the
!		inner-most definition depth in the current scope at
!		which at least one candidate symbol is declared.
!
!	    (2)	If only one candidate symbol is defined at the lowest
!		definition depth, then that is the unique symbol we
!		want.
!
!	    (3)	If more than one symbol is defined at the lowest defi-
!		nition depth, but only one of them has complete data
!		qualification, then that is the unique symbol we want.
!
!	    (4)	Otherwise, the symbol is not unique.
!
!	The list of candidate symbols is produced by DBG$STA_GETSYMBOL, and each
!	candidate is guaranteed to be in the current scope being searched.  What
!	this routine must do is to determine which candidates have valid data
!	qualification, which candidate is defined at the lowest definition depth
!	(i.e., defined inner-most in the current scope), and whether that candi-
!	date is unique.  The routine then returns one of three things: an indi-
!	cation that no symbol was valid, an indication that the symbol is not
!	unique, or an index pointing to the one selected candidate symbol.
!
! INPUTS
!	PATHNAME - Pointer to the pathname descriptor for the symbol name to
!		  be looked up in the symbol table.
!
!	NCANDS	- The number of candidate symbols found by DBG$STA_GETSYMBOL.
!
!	CANDLST	- A vector of pointers to the "candidate blocks" for the candi-
!		  date symbols found by DBG$STA_GETSYMBOL.  Each of these candi-
!		  dates is in the scope currently searched.  The candidate block
!		  pointers are found in CANDLST[1] through CANDLST[.NCANDS].
!
! OUTPUTS
!	The CANDLST index for the candidate block which best matches the path-
!		  name is returned as the routine's value.  If no candidate is
!		  acceptable, zero is returned, and if more than one candidate
!		  is acceptable (the symbol is not unique), -1 is returned.
!

    BEGIN

    MAP
	PATHNAME: REF PTH$PATHNAME,	! Pointer to symbol pathname descriptor
	CANDLST: REF VECTOR[,LONG];	! Pointer to candidate vector

    LABEL
	CHECK_THIS_CANDIDATE;		! Label of block we want to LEAVE

    LOCAL
	CANDBLK: REF CAND_BLOCKVECTOR,	! Pointer to current "candidate block"
	COMPLETE_FLAG,			! Set to TRUE if current candidate's
					!      data qualification is complete
	DATAQUAL_FLAG,			! Set to TRUE when we are in the data
					!      qualification part of a name
	DEFDEPTH,			! Definition depth of current candidate
	DSTPTR: REF DST$RECORD,		! Pointer to symbol DST record
	GOOD_CAND,			! CANDLST index of best candidate so far
	GOOD_COMPLETE_FLAG,		! Complete-data-qualification flag for
					!      the GOOD_CAND symbol
	GOOD_DEFDEPTH,			! Definition depth of GOOD_CAND symbol
	GOOD_STATADDR,			! Static address of GOOD_CAND symbol
	J,				! Index for CANDBLK vector
	RSTPTR: REF RST$ENTRY,		! Pointer to current symbol RST entry
	STATADDR;			! Static address of symbol or zero



    ! Initially we do not have a good candidate.
    !
    GOOD_CAND = 0;
    GOOD_DEFDEPTH = 1000000;
    GOOD_STATADDR = 0;
    GOOD_COMPLETE_FLAG = FALSE;


    ! Loop over all the candidate blocks on the candidate list.  This loop
    ! searches for the best candidate symbol matching the pathname.
    !
    INCR I FROM 1 TO .NCANDS DO
	BEGIN


	! Set up a labelled block to check out the current candidate.  We can
	! LEAVE this block if we find that the candidate is not acceptable.
	!
	CHECK_THIS_CANDIDATE:
	    BEGIN
	    CANDBLK = .CANDLST[.I];
	    COMPLETE_FLAG = TRUE;


	    ! Loop over the candidate's up-scope chain--that is what the CANDBLK
	    ! vector gives us.  Reject any candidate whose data qualification in
	    ! the up-scope chain does not agree with that in the pathname.
	    !
	    DATAQUAL_FLAG = TRUE;
	    J = 0;
	    WHILE .CANDBLK[.J, CAND_RSTPTR] NEQ 0 DO
		BEGIN
		RSTPTR = .CANDBLK[.J, CAND_RSTPTR];


		! Clear DATAQUAL_FLAG if we have left the data qualification
		! part of the name.
		!
		IF (.CANDBLK[.J, CAND_PINDEX] LSS .PATHNAME[PTH$B_PATHCNT]) AND
		   (.CANDBLK[.J, CAND_PINDEX] NEQ 0)
		THEN
		    DATAQUAL_FLAG = FALSE;


		! After we leave the data qualification part going up-scope, we
		! do not accept Data Items or Type Components in the name.
		!
		IF (NOT .DATAQUAL_FLAG)                AND
		   (.RSTPTR[RST$B_KIND] EQL RST$K_DATA OR
		    .RSTPTR[RST$B_KIND] EQL RST$K_TYPCOMP)
		THEN
		    LEAVE CHECK_THIS_CANDIDATE;


		! The last thing before the dot when there are things after the
		! dot must be a Data Item or Type Component.
		!
		IF (.CANDBLK[.J, CAND_PINDEX] EQL .PATHNAME[PTH$B_PATHCNT]) AND
		   (.PATHNAME[PTH$B_TOTCNT] GTR .PATHNAME[PTH$B_PATHCNT])   AND
		   (.RSTPTR[RST$B_KIND] NEQ RST$K_DATA)                     AND
		   (.RSTPTR[RST$B_KIND] NEQ RST$K_TYPCOMP)
		THEN
		    LEAVE CHECK_THIS_CANDIDATE;


		! After the dot, everything must be Type Components.
		!
		IF (.CANDBLK[.J, CAND_PINDEX] GTR .PATHNAME[PTH$B_PATHCNT]) AND
		   (.RSTPTR[RST$B_KIND] NEQ RST$K_TYPCOMP)
		THEN
		    LEAVE CHECK_THIS_CANDIDATE;


		! If we are in the data qualification part and PINDEX is zero,
		! we have an RST entry on the up-scope chain whose name is not
		! given in the Pathname Descriptor.  This means that data quali-
		! fication is not complete for this variable.
		!
		IF .DATAQUAL_FLAG AND (.CANDBLK[.J, CAND_PINDEX] EQL 0)
		THEN
		    COMPLETE_FLAG = FALSE;


		! Increment the CANDBLK index and loop up-scope.
		!
		J = .J + 1;
		END;


	    ! Pick up the definition depth from the last CANDBLK cell.  Reject
	    ! this candidate if we already have a candidate with a smaller def-
	    ! inition depth (i.e., defined closer to the current scope).
	    !
	    DEFDEPTH = .CANDBLK[.J, CAND_PINDEX];
	    IF .DEFDEPTH GTR .GOOD_DEFDEPTH THEN LEAVE CHECK_THIS_CANDIDATE;


	    ! Determine the static address of this symbol.  This is needed to
	    ! allow us to pick one symbol in a Common Block even if it is not
	    ! unique.  For non-static symbols, we make that address zero.
	    !
	    STATADDR = 0;
	    IF .RSTPTR[RST$B_KIND] EQL RST$K_DATA
	    THEN
		BEGIN
		DSTPTR = .RSTPTR[RST$L_DSTPTR];
		IF ((.DSTPTR[DST$B_TYPE] GEQ DSC$K_DTYPE_LOWEST AND
		     .DSTPTR[DST$B_TYPE] LEQ DSC$K_DTYPE_HIGHEST) OR
		    (.DSTPTR[DST$B_TYPE] EQL DST$K_SEPTYP))       AND
		   (.DSTPTR[DST$B_VFLAGS] EQL DST$K_VALKIND_ADDR)
		THEN
		    STATADDR = .DSTPTR[DST$L_VALUE];

		END;


	    ! We have a good candidate here.  If we already have another candi-
	    ! date at the same definition depth and if both have incomplete (or
	    ! both have complete) data qualification, the symbol is not unique.
	    ! We set GOOD_CAND to -1 to indicate this and reject the candidate.
	    ! If only one of the two candidates has complete data qualification,
	    ! we accept that one candidate as being the one we want (so far).
	    !
	    IF (.DEFDEPTH EQL .GOOD_DEFDEPTH) AND
	       (.GOOD_COMPLETE_FLAG OR NOT .COMPLETE_FLAG)
	    THEN
		BEGIN
		IF (.STATADDR EQL 0 OR .STATADDR NEQ .GOOD_STATADDR) AND
		   (.COMPLETE_FLAG OR NOT .GOOD_COMPLETE_FLAG)
		THEN
		    GOOD_CAND = -1;

		LEAVE CHECK_THIS_CANDIDATE;
		END;


	    ! We have a good candidate which is unique (so far) at this defini-
	    ! tion depth.  Set GOOD_CAND accordingly.
	    !
	    GOOD_CAND = .I;
	    GOOD_DEFDEPTH = .DEFDEPTH;
	    GOOD_STATADDR = .STATADDR;
	    GOOD_COMPLETE_FLAG = .COMPLETE_FLAG;

	    END;			! End of the CHECK_THIS_CANDIDATE block

	END;				! End of INCR loop over candidate list


    ! Return the GOOD_CAND value.  This may be -1, 0, or a true CANDLST index.
    !
    RETURN .GOOD_CAND;

    END;

ROUTINE STACK_MACHINE(STK_CODE_PTR, RESULT_PTR, FRAMEPTR): NOVALUE =
!
! FUNCTION
!	This routine evaluates "Stack Machine" code from a Materialization Spec
!	in a DST Value Spec.  It accepts as input a pointer to the Stack Machine
!	"routine" (i.e., the "code") to be evaluated.  That "routine" is then
!	evaluated on a stack built in a temporary memory block.  Upon return,
!	the address of the computed value in the temporary memory block is
!	returned as the result of the evaluation.
!
! INPUTS
!	STK_CODE_PTR - The address of the first byte of "Stack Machine" code.
!		  Evaluation of this "code" starts at this address and con-
!		  tinues until the DST$K_STK_STOP command is reached.
!
!	RESULT_PTR - The address of a longword location to receive the result
!		  pointer.
!
!	FRAMEPTR - The address of a longword location to receive the frame
!		  pointer associated with the result location.
!
! OUTPUTS
!	RESULT_PTR - A pointer to the result of evaluating the stack machine
!		  routine is returned to RESULT_PTR.
!
!	FRAMEPTR - The Frame Pointer (FP) value of the register set used in
!		  the stack machine computations is returned to FRAMEPTR if
!		  any register was used in the computations.  If no register
!		  value was used, zero is returned to FRAMEPTR.
!
!	No value is returned by routine STACK_MACHINE.
!

    BEGIN

    MAP 
	RESULT_PTR: REF VECTOR[1],	! Pointer to result location
	FRAMEPTR: REF VECTOR[1];	! Pointer to frame pointer location

    LITERAL
	STACK_SIZE 	= 256;

    LOCAL 
	CALL_RESULT,			! Result of embedded routine call
	STACK_PTR,			! Pointer to the top of stack.
	OVERFLOW_POINT,			! Pointer to stack upper limit.
	UNDERFLOW_POINT,		! Pointer to stack lower limit.
	INSTRUC : REF VECTOR [,BYTE];	! Pointer to the current stack instruct

    MACRO 
	TOP_CELL = 	(.STACK_PTR) %,
	SECOND_CELL = 	(.STACK_PTR + 4) %,
	PUSH(I) = 	STACK_PTR = .STACK_PTR - (I)*%UPVAL;
			IF .STACK_PTR LSSA .OVERFLOW_POINT 
			THEN
			    SIGNAL(DBG$_DEBUGBUG, 1, 191) %,

	POP(I) = 	STACK_PTR = .STACK_PTR + (I)*%UPVAL;
			IF .STACK_PTR GTRA .UNDERFLOW_POINT
			THEN
			    SIGNAL(DBG$_DEBUGBUG, 1, 191) %,

	PUSH_BYTE(I) = 	STACK_PTR = 
				.STACK_PTR -
					((I) + (IF (I) MOD %UPVAL NEQ 0 
					      THEN %UPVAL - ((I) MOD %UPVAL)
					      ELSE 0));
			IF .STACK_PTR LSSA .OVERFLOW_POINT 
			THEN
			    SIGNAL(DBG$_DEBUGBUG, 1, 181) %,

	CHECK_CELLS(I) = IF .UNDERFLOW_POINT - .STACK_PTR LSS (I)*%UPVAL
			 THEN
			     SIGNAL(DBG$_DEBUGBUG, 1, 191) %;



    ! Initialize the stack and the pointer to the instruction stream.
    !
    OVERFLOW_POINT = DBG$GET_TEMPMEM(STACK_SIZE);
    UNDERFLOW_POINT = .OVERFLOW_POINT + 4*STACK_SIZE;
    STACK_PTR = .UNDERFLOW_POINT;
    INSTRUC = .STK_CODE_PTR;


    ! Initialize FRAMEPTR to zero--this will be changed if registers are used.
    !
    FRAMEPTR[0] = 0;


    ! Evaluate the Stack Machine "routine" by looping through its instructions
    ! until we reach the Stop command.
    !
    WHILE .INSTRUC[0] NEQ DST$K_STK_STOP DO
	BEGIN


	! Do a CASE on the current Stack Machine Op Code and execute each
	! op code as appropriate.
	!
	CASE .INSTRUC[0] FROM DST$K_STK_LOW TO DST$K_STK_HIGH OF
	    SET


	    ! Push the value of a register on the stack.
	    !
	    [DST$K_STK_PUSHR0,
	     DST$K_STK_PUSHR1,
	     DST$K_STK_PUSHR2,
	     DST$K_STK_PUSHR3,
	     DST$K_STK_PUSHR4,
	     DST$K_STK_PUSHR5,
	     DST$K_STK_PUSHR6,
	     DST$K_STK_PUSHR7,
	     DST$K_STK_PUSHR8,
	     DST$K_STK_PUSHR9,
	     DST$K_STK_PUSHR10,
	     DST$K_STK_PUSHR11,
	     DST$K_STK_PUSHRAP,
	     DST$K_STK_PUSHRFP,
	     DST$K_STK_PUSHRSP,
	     DST$K_STK_PUSHRPC]:	
		BEGIN
		LOCAL REGISTR;
		PUSH(1);
		REGISTR = 
			   (CASE .INSTRUC[0] 
				FROM DST$K_STK_PUSHR0 TO DST$K_STK_PUSHRPC OF
				SET
				[DST$K_STK_PUSHR0]: 0;
				[DST$K_STK_PUSHR1]: 1;
				[DST$K_STK_PUSHR2]: 2;
				[DST$K_STK_PUSHR3]: 3;
				[DST$K_STK_PUSHR4]: 4;
		 		[DST$K_STK_PUSHR5]: 5;
				[DST$K_STK_PUSHR6]: 6;
				[DST$K_STK_PUSHR7]: 7;
				[DST$K_STK_PUSHR8]: 8;
		 		[DST$K_STK_PUSHR9]: 9;
				[DST$K_STK_PUSHR10]: 10;
				[DST$K_STK_PUSHR11]: 11;
 				[DST$K_STK_PUSHRAP]: 12;
				[DST$K_STK_PUSHRFP]: 13;
				[DST$K_STK_PUSHRSP]: 14;
				[DST$K_STK_PUSHRPC]: 15;
				TES
			   );

		IF .DBG$REG_VECTOR[.REGISTR] NEQ 0
		THEN
		    BEGIN
		    TOP_CELL = .DBG$REG_VALUES[.REGISTR];
	 	    INSTRUC = .INSTRUC + 1;
		    END

		ELSE
		    VALSPEC_SCOPE_ERROR();

		FRAMEPTR[0] = .DBG$REG_VALUES[13];
		END;


	    ! PUSH IMMEDIATE 		1, 2, or 4 bytes following this opcode 
	    ! BYTE WORD OR LONG		are sign extended to 32 bits and PUSHed 
	    ! 				on the stack
	    !
	    [DST$K_STK_PUSHIMB]:	
		BEGIN
		LOCAL OPERAND : REF VECTOR [,BYTE,SIGNED];
		PUSH(1);
		OPERAND = INSTRUC[1];
		TOP_CELL = .OPERAND[0];
		INSTRUC = .INSTRUC + 2;
		END;

	    [DST$K_STK_PUSHIMW]:	
		BEGIN
		LOCAL OPERAND : REF VECTOR [,WORD, SIGNED];
		PUSH(1);
		OPERAND = INSTRUC[1];
		TOP_CELL = .OPERAND[0];
		INSTRUC = .INSTRUC + 3;
		END;

	    [DST$K_STK_PUSHIML]:	
		BEGIN
		LOCAL OPERAND : REF VECTOR [,LONG];
		PUSH(1);
		OPERAND = INSTRUC[1];
		TOP_CELL = .OPERAND[0];
		INSTRUC = .INSTRUC + 5;
		END;


	    ! PUSH IMMEDIATE VARIABLE	The byte following the opcode is 
	    ! 				interpreted as an unsigned byte count.
	    ! 				A block of data, immediately following 
	    ! 				the count byte, is PUSHed on the stack. 
	    ! 				It is left padded with zeros to a
	    ! 				longword boundary. The last longword in
	    ! 				the resulting block is PUSHed first.
	    !
	    [DST$K_STK_PUSHIM_VAR]:	
		BEGIN
		PUSH_BYTE(.INSTRUC[1]);
		CH$MOVE( .INSTRUC[1], 
			 INSTRUC[2], 
			 TOP_CELL + (.INSTRUC[1] MOD %UPVAL));
		INSTRUC = INSTRUC[2] + .INSTRUC[1];
		END;


	    ! PUSH IMMEDIATE UNSIGNED	1 or 2 bytes following this opcode 
	    ! BYTE OR WORD 		are zero extended to 32 bits and PUSHed 
	    ! 				on the stack
	    ! 
	    [DST$K_STK_PUSHIMBU]:	
		BEGIN
		PUSH(1);
		TOP_CELL = .INSTRUC[1];
		INSTRUC = .INSTRUC + 2;
		END;

	    [DST$K_STK_PUSHIMWU]:
		BEGIN
		LOCAL OPERAND : REF VECTOR [,WORD];
		PUSH(1);
		OPERAND = INSTRUC[1];
		TOP_CELL = .OPERAND[0];
		INSTRUC = .INSTRUC + 3;
		END;


	    ! PUSH INDIRECT	The top stack cell is popped and 1, 2, or 4
	    ! BYTE WORD OR LONG bytes at the address given by the popped
	    !			stack cell are sign extended to 32 bits and
	    !			pushed on the stack.
	    ! 
	    [DST$K_STK_PUSHINB]:	
		BEGIN
		LOCAL OPERAND : REF VECTOR [,BYTE, SIGNED];
		OPERAND = .TOP_CELL;
		TOP_CELL = .OPERAND[0];
		INSTRUC = .INSTRUC + 1;
		END;

	    [DST$K_STK_PUSHINW]:	
		BEGIN
		LOCAL OPERAND : REF VECTOR [,WORD,SIGNED];
		OPERAND = .TOP_CELL;
		TOP_CELL = .OPERAND[0];
		INSTRUC = .INSTRUC + 1;
		END;

	    [DST$K_STK_PUSHINL]:	
		BEGIN
		LOCAL OPERAND: REF VECTOR[,LONG];
		OPERAND = .TOP_CELL;
		TOP_CELL = .OPERAND[0];
		INSTRUC = .INSTRUC + 1;
		END;


	    ! PUSH INDIRECT UNSIGNED	The top stack cell is popped and 1 or 2
	    ! BYTE OR WORD		bytes at the address given by the popped
	    !				stack cell are zero extended to 32 bits
	    !				and pushed on the stack.
	    ! 
	    [DST$K_STK_PUSHINBU]:	
		BEGIN
		LOCAL OPERAND : REF VECTOR [,BYTE];
		OPERAND = .TOP_CELL;
		TOP_CELL = .OPERAND[0];
		INSTRUC = .INSTRUC + 1;
		END;

	    [DST$K_STK_PUSHINWU]:	
		BEGIN
		LOCAL OPERAND : REF VECTOR [,WORD];
		OPERAND = .TOP_CELL;
		TOP_CELL = .OPERAND[0];
		INSTRUC = .INSTRUC + 1;
		END;


	    ! ADD			The top two stack cells are added and 
	    ! 				replaced by a single cell containing 
	    ! 				their sum
	    ! 
	    [DST$K_STK_ADD]:	
		BEGIN
		CHECK_CELLS(2);	
		SECOND_CELL = .TOP_CELL + .SECOND_CELL;
		POP(1);
		INSTRUC = .INSTRUC + 1;
  		END;


	    ! SUBTRACT		The second stack cell is subtracted from 
	    ! 			the first stack cell. Both are popped. 
	    ! 			Their difference is PUSHed.
	    ! 
	    [DST$K_STK_SUB]:		
		BEGIN
		CHECK_CELLS(2);
		SECOND_CELL = .TOP_CELL - .SECOND_CELL;
		POP(1);
		INSTRUC = .INSTRUC + 1;
		END;


	    ! MULTIPLY		The top two stack cells are multiplied 
	    ! 			and replaced by a single cell containing 
	    ! 			their product
	    !
	    [DST$K_STK_MULT]:	
		BEGIN
		CHECK_CELLS(2);
		SECOND_CELL = (.TOP_CELL)*(.SECOND_CELL);
		POP(1);
		INSTRUC = .INSTRUC + 1;
		END;


	    ! DIVIDE			The top stack cell is divided by the 
	    ! 				secondstack cell. Both are popped. 
	    ! 				Their qoutient is PUSHed.
	    ! 
	    [DST$K_STK_DIV]:		
		BEGIN
		CHECK_CELLS(2);
		IF .(SECOND_CELL) EQL 0 
		THEN SIGNAL (DBG$_DEBUGBUG, DBG$K_BADSTKMACH)
		ELSE 
		    BEGIN
	    	    SECOND_CELL = (.TOP_CELL)/(.SECOND_CELL);
		    POP(1);
	    	    INSTRUC = .INSTRUC + 1;
		    END
		END;


	    ! LOGICAL SHIFT	The top stack cell is interpreted as 
	    ! 			the number of bit positions to shift the 
	    ! 			second stack cell. Both are popped. 
	    ! 			The shifted second cell is PUSHed.
	    ! 
	    [DST$K_STK_LSH]:	
		BEGIN
		CHECK_CELLS(2);
		IF ABS( .TOP_CELL ) GEQ %BPVAL
		THEN 
		    BEGIN
		    POP(1);
		    TOP_CELL = 0;
		    INSTRUC = .INSTRUC + 1;
		    END
		ELSE 
		    BEGIN
		    IF .TOP_CELL GTR 0 
		    THEN 

			! Number of bit positions is positive, shift to the left.
			!
			BEGIN
			SECOND_CELL = (.SECOND_CELL)^(.TOP_CELL);
			POP(1);
	    		INSTRUC = .INSTRUC + 1;
			END
	 	    ELSE

			! Number of bit positions is negative, shift to the right.
			! This is a logical, rather than an arithmetic shift, so
			! we'll have to do some magic, rather than use the BLISS
			! shift operator.
			!
			BEGIN
			LOCAL POSITION, SIZ;
			POSITION = -.TOP_CELL;
			SIZ = %BPVAL - .POSITION;
			SECOND_CELL = .(SECOND_CELL)<.POSITION, .SIZ>;
			POP(1);
	    		INSTRUC = .INSTRUC + 1;
			END;
		    END
		END;


	    ! ROTATE		The top stack cell is interpreted as the
	    ! 			number of bit positions to rotate the 
	    ! 			second stack cell. Both are popped. 
	    ! 			The rotated second cell is PUSHed.
	    ! 
	    [DST$K_STK_ROT]:		
		BEGIN
		LOCAL BITS_TO_ROT;
		CHECK_CELLS(2);
		BITS_TO_ROT = .TOP_CELL MOD %BPVAL;
		IF .BITS_TO_ROT GTR 0 
		THEN 

		    ! Number of bit positions is positive, rotate to the left. 
		    !
		    BEGIN
		    LOCAL OPERAND, TARG_POS, SRC_POS, SIZ;
		    OPERAND = .(SECOND_CELL);

		    ! Move the low order bits of the source to the high order
		    ! bits of the target and the high order bits of the source to
		    ! the low order bits of the target.
		    !
		    !		 31                    0
		    !		+-----------------------+
		    !   source      |	     |		|
		    !		+-----------------------+
		    !		|.BITS_TO_ROT|     |
		    !			|	   |
		    !		      -------------
		    !		     |  |
		    !		     |   ----------
		    !		     |		   |
		    !		    \ /		  \ /
		    !		+-----------------------+
		    !   target      |	     |		|
		    !		+-----------------------+
				
		    TARG_POS = .BITS_TO_ROT;
		    SRC_POS  = 0;
		    SIZ = %BPVAL - TARG_POS;
		    (SECOND_CELL)<.TARG_POS, .SIZ> = .OPERAND<.SRC_POS, .SIZ>;

		    ! Move the high order bits of the source to the low order
		    ! bits of the target.
		    !
		    TARG_POS = 0;
		    SRC_POS  = %BPVAL - .BITS_TO_ROT;
		    SIZ = .BITS_TO_ROT;
		    (SECOND_CELL)<.TARG_POS, .SIZ> = .OPERAND<.SRC_POS, .SIZ>;
		    
		    ! Adjust the stack pointer,
		    !
		    POP(1);
	    	    INSTRUC = .INSTRUC + 1;
		    END

		 ELSE

		    ! Number of bit positions is negative, rotate to the right.
		    !
		    BEGIN
		    LOCAL OPERAND, TARG_POS, SRC_POS, SIZ;
		    OPERAND = .SECOND_CELL;

		    ! Move the high order bits of the source to the low order
		    ! bits of the target and the low order bits of the source to
		    ! the high order bits of the target.
		    !
		    !		 31                    0
		    !		+-----------------------+
		    !   source      |	  |   		|
		    !		+-----------------------+
		    !		       |  |-.BITS_TO_ROT|
		    !		       |	   |
		    !		      -------------
		    !		     | |
		    !		     |  -----------
		    !		     |		   |
		    !		    \ /		  \ /
		    !		+-----------------------+
		    !   target      |	     |		|
		    !		+-----------------------+
		    !
		    TARG_POS = %BPVAL - .BITS_TO_ROT;
		    SRC_POS  = 0;
		    SIZ 	 = .BITS_TO_ROT;
		    (SECOND_CELL)<.TARG_POS, .SIZ> = .OPERAND<.SRC_POS, .SIZ>;


		    ! Move the high order bits of the source to the low order
		    ! bits of the target.
		    !
		    TARG_POS = 0;
		    SRC_POS  = .BITS_TO_ROT;
		    SIZ 	 = %BPVAL - .BITS_TO_ROT;
		    (SECOND_CELL)<.TARG_POS, .SIZ> = .OPERAND<.SRC_POS, .SIZ>;
		    

		    ! Adjust the stack pointer,
		    !
		    POP(1);
	    	    INSTRUC = .INSTRUC + 1;
		    END;

		END;


	    ! COPY 			The top stack cell is PUSHed 
	    !
	    [DST$K_STK_COP]:	
		BEGIN
		PUSH(1);
		TOP_CELL = .SECOND_CELL;
		INSTRUC = .INSTRUC + 1;
		END;


	    ! EXCHANGE			The top two stack cells are exchanged
	    ! 
	    [DST$K_STK_EXCH]:
		BEGIN
		LOCAL WORK_CELL;
		WORK_CELL = .TOP_CELL;
		TOP_CELL = .SECOND_CELL;
		SECOND_CELL = .WORK_CELL;
		INSTRUC = .INSTRUC + 1;
		END;


	    ! STORE BYTE WORD OR LONG	
	    !			The byte following this operand is 
	    ! 			interpreted as a signed (for consistency
	    ! 			with something, see Grove) byte offset 
	    ! 			into the stack. The low order byte, word, 
	    ! 			or longword of the top stack cell is 
	    ! 			copied into the byte, word or longword 
	    ! 			at this location:
	    !
	    !	 			address of the second stack cell 
	    ! 					+
	    ! 				the specified byte offset.
	    !
	    ! 			(Keep in mind that the address of the 
	    ! 			third stack cell is the address of the
	    ! 			second stack cell plus four.)
	    ! 			The stack is popped.
	    !
	    [DST$K_STK_STO_B,
	     DST$K_STK_STO_W,	
	     DST$K_STK_STO_L]:
		BEGIN
		LOCAL TARGET, SIZ;
		TARGET = SECOND_CELL + .INSTRUC[1];
		SIZ = 
		    (CASE .INSTRUC[0] FROM DST$K_STK_STO_B TO DST$K_STK_STO_L OF
			SET
			[DST$K_STK_STO_B]: 1;
			[DST$K_STK_STO_W]: 2;
			[DST$K_STK_STO_L]: 4;
				TES);
		CH$MOVE(.SIZ, TOP_CELL, .TARGET);
		POP(1);
		INSTRUC = .INSTRUC + 2;
		END;


	    ! POP			The top stack cell is removed from the 
	    ! 				stack.
	    !
	    [DST$K_STK_POP]:	
		BEGIN
		POP(1);
		INSTRUC = .INSTRUC + 1;
		END;


	    ! RTNCALL			Call a compiler-supplied routine to
	    !				compute a value to be put on the stack.
	    !				We assume that the routine address is
	    !				already on top of the stack.  That ad-
	    !				dress is popped and the returned value
	    !				is pushed on the stack.
	    !
	    [DST$K_STK_RTNCALL]:
		BEGIN
		CALL_RESULT = 0;
		VALSPEC_ROUT_CALL(CALL_RESULT, .TOP_CELL, FALSE);
		TOP_CELL = .CALL_RESULT;
		FRAMEPTR[0] = .DBG$REG_VALUES[13];
		INSTRUC = .INSTRUC + 1;
		END;


	    ! Any other op-code is an error.  Signal an internal bug.
	    !
	    [INRANGE, OUTRANGE]:
		SIGNAL(DBG$_DEBUGBUG, 1, 192);

	    TES;

	END;				! End of WHILE loop over instructions


    ! Fill in the result address and return.
    !
    RESULT_PTR[0] = TOP_CELL;
    RETURN;

    END;

ROUTINE VALSPEC_ERROR_HANDLER(SIGARG, MECHARG, ENBLARG) =
!
! FUNCTION
!	This routine is the error handler for the DBG$STA_VALSPEC routine.  It
!	handles Access Violations which occur during the evaluation of DST Value
!	Specs.  Since such access violations are not normally caused by errors
!	in Debug but rather by errors in the user program (e.g., by clobbered
!	registers), we give a special message for this kind of access violation.
!	The message says that the error occurred in the address computation for
!	some symbol and gives the symbol name.  The symbol name comes from the
!	SYMID last passed to DBG$STA_SETCONTEXT.
!
! INPUTS
!	SIGARG	- The signal argument vector.
!
!	MECHARG	- The mechanism argument vector.
!
!	ENBLARG	- The enable argument vector (not used here).
!
! OUTPUTS
!	For the SS$_ACCVIO error, the DBG$_ACCADDCOM error is signalled instead.
!	For all other errors, this routine just resignals.
!

    BEGIN

    MAP
	SIGARG: REF VECTOR[,LONG];	! Pointer to the signal argument vector

    LOCAL
	PATHDESCR,			! Pointer to pathname descriptor
	PATHSTRING;			! Pointer to pathname string for symbol



    ! If this is anything other than an access violation, just resignal it.
    !
    IF .SIGARG[1] NEQ SS$_ACCVIO THEN RETURN SS$_RESIGNAL;


    ! It is an access violation.  Determine the name of the last symbol passed
    ! to DBG$STA_SETCONTEXT to set up the register context and use that in the
    ! error message we substitute.
    !
    IF .DBG$REG_SYMID EQL 0
    THEN
	PATHSTRING = UPLIT BYTE(%ASCIC 'object')

    ELSE
	BEGIN
	DBG$STA_SYMPATHNAME(.DBG$REG_SYMID, PATHDESCR);
	DBG$NPATHDESC_TO_CS(.PATHDESCR, PATHSTRING);
	END;


    ! Signal the substitute error.  We never get control back from the signal.
    !
    SIGNAL(DBG$_ACCADDCOM, 1, .PATHSTRING);
    RETURN 0;

    END;

ROUTINE VALSPEC_SCOPE_ERROR: NOVALUE =
!
! FUNCTION
!	This routine is called during DST Value Spec evaluation if a register
!	is referenced which is not available in the current context as set by
!	routine DBG$STA_SETCONTEXT.  Use of such a register usually means that
!	a variable is being referenced whose scope is not currently active, i.e.
!	there is no CALL frame on the VAX stack for the routine in which the
!	symbol is declared.  This routine just sets up and signals the "Symbol
!	not in active scope" error message.
!
! INPUTS
!	DBG$REG_SYMID is an implicit input.  It gives the SYMID of the symbol
!	last used to establish context.  There are no input parameters.
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
	PATHNAME,			! Pointer to symbol's pathname descriptor
	PATHSTRING;			! Pointer to symbol's pathname string



    ! Use the SYMID passed to DBG$STA_SETCONTEXT last to format the symbol name
    ! for the error message.  If no such name exists, use the null string.
    !
    IF .DBG$REG_SYMID EQL 0
    THEN
	PATHSTRING = UPLIT(0)

    ELSE
	BEGIN
	DBG$STA_SYMPATHNAME(.DBG$REG_SYMID, PATHNAME);
	DBG$NPATHDESC_TO_CS(.PATHNAME, PATHSTRING);
	END;


    ! Signal the error--we do not return from the signal.
    !
    SIGNAL(DBG$_SYMNOTACT, 1, .PATHSTRING);

    END;

ROUTINE VALSPEC_ROUT_CALL(VALBUFFER, ROUT_ADDR, OCTAWORD_FLAG): NOVALUE =
!
! FUNCTION
!	This routine is called to handle calls on compiler-supplied routines
!	in the user's address-space during Value Spec evaluation.  Calls to
!	compiler-supplied Value Spec routines can be specified in Materializa-
!	tion Specs in Value Specs, both directly and via the DST Stack Machine.
!	The compiler-supplied routine is called as follows:
!
!		- The desired symbol's Frame Pointer value is passed to
!		  the routine in register R1.
!
!		- If OCTAWORD_FLAG is FALSE, a pointer to the vector of
!		  register values for the symbol's frame (as represented
!		  by DBG$REG_VALUES) is passed as a parameter in the argu-
!		  ment vector, and the routine returns the symbol's value
!		  in register R0.
!
!		- If OCTAWORD_FLAG is TRUE, a pointer to a 4-longword result
!		  buffer and a pointer to the vector of register values in
!		  the symbol's frame are passed as parameters in the argument
!		  vector.  The routine's result is returned directly to the
!		  result buffer in this case, and not through register R0.
!
!	If the Frame Pointer (FP) is not available in the current context (as
!	set up by DBG$STA_SETCONTEXT), the "symbol not in active scope" error
!	is signalled.  Otherwise the compiler-supplied routine is called as
!	described above and its value returned.  The routine that called
!	VALSPEC_ROUT_CALL can then use the value as it sees fit.
!
! INPUTS
!	VALBUFFER - The address of a 1-longword or 4-longword buffer which is
!		  to receive the value returned by the called routine.  The
!		  size of the buffer depends on the value of OCTAWORD_FLAG.
!		  The buffer should be zeroed out by the caller.
!
!	ROUT_ADDR - The address of the routine to be called to get the value.
!
!	OCTAWORD_FLAG - A flag value set to TRUE if the called routine is
!		  expected to return a 4-longword value to VALBUFFER.  If
!		  this flag is FALSE, a single longword is expected to be
!		  returned to VALBUFFER.  If OCTAWORD_FLAG is TRUE, the called
!		  routine is expected to return its value to the address given
!		  by the first parameter;  otherwise, the value is returned in
!		  register R0.
!
! OUTPUTS
!	VALBUFFER - The value returned by the called compiler-supplied
!		  routine is returned to the buffer pointed to by
!		  VALBUFFER.
!
!	No routine value is returned.
!

    BEGIN

    MAP
	VALBUFFER: REF VECTOR[,LONG];	! Pointer to buffer to receive value


    ! Define the linkage by which we call the compiler-supplied routine.
    !
    LINKAGE
	ROUT_CALL_LINKAGE = CALL(REGISTER = 1, STANDARD);

    BIND ROUTINE
	ROUTINE_TO_CALL = (.ROUT_ADDR): ROUT_CALL_LINKAGE;



    ! Make sure there is a current register set to take FP from.
    !
    IF .DBG$REG_VECTOR[13] EQL 0 THEN VALSPEC_SCOPE_ERROR();


    ! Call the compiler-provided routine to compute the desired value.  If the
    ! octaword flag is set, we pass the buffer to receive the value (up to four
    ! longwords) as the first parameter.  Otherwise we get the value from R0.
    ! The frame pointer value is always passed in in register R1.
    !
    IF .OCTAWORD_FLAG
    THEN
	ROUTINE_TO_CALL(.DBG$REG_VALUES[13], .VALBUFFER, DBG$REG_VALUES[0])

    ELSE
	VALBUFFER[0] = ROUTINE_TO_CALL(.DBG$REG_VALUES[13], DBG$REG_VALUES[0]);

    RETURN;

    END;

END ELUDOM
