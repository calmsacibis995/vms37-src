;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
	.title plimaktre
	.subtitle	pli_make_tree
	.ident	/V03-000/
	$dscdef
	$stsdef
	$dbgdef
	$dbglib
	$plidef
	$dstrecrds
	$chfdef
;
;
; REGISTER     USE
;
;	r11	address of input string descriptor
;	r10	pointer to head node
;	r9	current node pointer
;	r8	pointer to new node
;	fp	base of local storage
;
; local storage offsets from fp
new_node	=	 -4
current_mode	=	 -8		;current mode
current_token_type =	-12		;current token type code
start_length	=	-16		;original length of input string
start_pointer	=	-20		;starting address of original string
result_vector_last =	-24		;result vector last longword
					;***warning*** must be last
local_storage_size = <result_vector_last - pli_tokr$k_size> ; minus the size
					;in bytes of the local storage
result_vector	= local_storage_size+4	;first longword of result vector
;
;parameter offset definitions
;
ap_input_desc	=	4		;input descriptor (pointer to)
ap_radix	=	8		;radix (value)
ap_tree_ptr	=	12		;addr head node (pointer to)
ap_tree_mode	=	16		;mode (value)
ap_hot_tree_code =	20		;hot tree code (pointer to)
ap_message_vect	=	24		;message vector (pointer to)
	.psect	dbg$code,exe,nowrt,long,pic,shr
	.entry	pli_make_tree,^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>
	movl	ap_input_desc(ap),r11	;address of input descriptor
	movzwl	dsc$w_length(r11),r6	;length of input string
	movl	dsc$a_pointer(r11),r7	;address of input string
;
;create work area for local values
;
	moval	<local_storage_size>(sp),sp ;get local storage
;
;initialize local storage
;
	movl	ap_tree_mode(ap),current_mode(fp) ;current mode setup
	movl	r6,start_length(fp)	;initialize starting length
	movl	r7,start_pointer(fp)	;initialize starting pointer
;
;create head node
;
	pushl	ap_message_vect(ap)	;copy message vector
	pushl	ap_tree_ptr(ap)		;pass addr of ptr to head node
	pushl	#pli_head_node$k_size+3/4 ;size of head node in longwords
	calls	#3,dbg$nlist_freez	;get the storage
	movl	@ap_tree_ptr(ap),r10	;get pointer to free storage
	movl	r10,r9			;this is the current node
	movl	r10,pli_node_flink(r10) ;flink
	movl	r10,pli_node_blink(r10)	;blink
	movl	#pli_node_type$k_head,pli_node_type(r10) ;node type = head
	movl	#1,pli_node_ident(r10)	;node identifier = 1
	movl	r7,pli_node$a_str(r10)	;address of input string
	movw	r6,pli_node$w_sl(r10)	;size of input string
	movl	ap_tree_mode(ap),pli_head_node_bits(r10) ;mode of tree
	movl	#1,pli_head_node_count(r10) ;nodes in tree
	movzbl	g^dbg$gb_verb,pli_head_node_orig_verb(r10) ;original verb
	clrl	pli_head_node_orig_fp(r10) ;****temp (is this needed anyway?)



;
;create parameter list for call to pli_get_token
;
p_loop:	pushl	ap_message_vect(ap)	;parameter - message vector
	pushal	result_vector(fp)	;parameter - ptr. to result vector
	pushal	current_token_type(fp)	;parameter - ptr. to current token type
	movl	r9,r0			;current node
10$:	cmpl	pli_node_type(r0),-	;see if current node is
		#pli_node_type$k_more_oprnd ;is operator node, more named data
	beql	50$			;branch if it is
	cmpl	pli_node_type(r0),-	;see if it is the continuation of 
		#pli_node_type$k_more_oprcon ;more operator node?
	bneq	90$			;branch if not
20$:	movl	pli_node_blink(r0),r0	;look at parent
	cmpl	#pli_node_type$k_oprcon,pli_node_type(r0) ;continue node?
	beql	20$			;if continue, branch to get parent
	cmpl	#pli_node_type$k_oprnd,pli_node_type(r0) ;is primary parent
					;a name data operator?
	bneq	90$			;branch if not
50$:	pushl	#1			;operator node for named data, so
					;don't call get_token to look for
					;a pathname
	brb	100$			;continue pushing parameters
90$:	pushl	#0			;call get_token to look for pathname
100$:	pushal	ap_radix(ap)		;parameter - ptr. to radix
	pushl	r11			;parameter - ptr. to input descriptor
	pushal	current_mode(fp)	;parameter - ptr. to current mode
;
;get the next token
;
	calls	#7,pli_get_token	;get the next token
	blbs	r0,110$			;branch if successful return
	ret				;
;
;note: action_continue uses the register values "left over" as
;	the action routine is entered. If any of these registers
;	are changed prior to the case, change action_continue also.
;
110$:	movl	current_token_type(fp),r0 ;get type of token
	mull3	current_mode(fp),#<pli_node_type$k_last_type+1*4>,r1
					;displacement to node list for this
					;mode
	moval	parse_matrix,r3		;point to parse matrix
	addl2	r1,r3			;point to proper node list for mode
	movl	pli_node_type(r9),r4	;get current node type
continue_entry:				;re-enter here if a continue node
	movl	(r3)[r4],r5		;point to token list for this mode and
					;node
	addl2	r3,r5			;relocate address
	movzbl	(r5)[r0],r2		;parse expression action code
	caseb	r2,#0,#45		;
200$:	.word	never_error	- 200$	;there is no expression action zero
	.word	action_ok	- 200$	;pea_ok; tree completed
	.word	never_error	- 200$	;pea_never; internal coding error
	.word	action_error_null-200$	;pea_null; no input, no tree
	.word	action_warning	- 200$	;pea_warning; tree (possibly null),
					;warning return
	.word	action_error	- 200$	;pea_error; null tree, unknown error
					;immediately
	.word	action_severe	- 200$	;pea_severe; syntax error detected
	.word	action_err_token- 200$	;pea_err_token; syntax error from
					;gettoken
	.word	action_pop	- 200$	;pea_pop; up tree for left parenthesis
	.word	action_comma	- 200$	;pea_comma; comma encountered
	.word	action_ptr	- 200$	;pea_ptr; pointer encountered
	.word	action_subscript- 200$	;pea_subscript; subscripts 
					;(possible mode change)
	.word	never_error	- 200$	;pea_argument; arguments
					;(possible mode change)
	.word	action_first_id	- 200$	;pea_first_id; first identifier in a
					;name
	.word	action_more_id	- 200$	;pea_more_id; identifiers in a name
					;after the first
	.word	action_prefix	- 200$	;pea_prefix; prefix operator
					;encountered
	.word	action_infix	- 200$	;pea_infix; infix operator encountered
	.word	action_dss	- 200$	;pea_dss; debug special symbol
					;encountered
	.word	action_plivd	- 200$	;pea_plivd; pli value descriptor
	.word	action_dbgcon 	- 200$	;pea_dbgcon; debug constant (address)
	.word	action_push	- 200$	;pea_push; left parenthesis encountered
	.word	action_err_ptr	- 200$	;pea_err_ptr; error - pointer
	.word	action_err_fun	- 200$	;pea_err_fun; error - function
	.word	action_err_mis_rp-200$	;pea_err_mis_rp; error - missing right
					;parenthesis
	.word	action_err_var	- 200$	;pea_err_var; error - variable name
	.word	action_dbg_line - 200$	;pea_dbg_line ; %line encountered
					;%line encountered
	.word	action_dbg_bs	- 200$	;"\" encountered
	.word	action_name_dot - 200$	;pea_name_dot; now expect another name
	.word	action_err_more_name - 200$ ;pea_err_more_name ;need more name
	.word	action_severe_msg-200$	;pea_severe_msg ;gettoken error msg
	.word	action_err_more_scr-200$;pea_err_more_scr
	.word	action_err_more_operand- 200$ ;pea_err_more_operand
	.word	action_need_scr_got_id-200$ ;pea_need_scr_got_id
	.word	action_need_scr_got_dbgc-200$ ;pea_need_scr_got_dbgc
	.word	action_need_scr_got_plic-200$ ;pea_need_scr_got_plic
	.word	action_need_scr_got_dbgr-200$ ;action_need_scr_got_dbgr
	.word	action_need_scr_got_bs-200$ ;pea_need_scr_got_bs
	.word	action_need_scr_got_oper-200$ ;pea_need_scr_got_oper
	.word	action_need_scr_got_lpar-200$ ;pea_need_scr_got_lpar
	.word	action_need_operand_got_lpar-200$ ;pea_need_operand_got_lpar
	.word	action_need_operand_got_id-200$ ;pea_need_operand_got_id
	.word	action_need_operand_got_dbgc-200$ ;pea_need_operand_got_dbgc
	.word	action_need_operand_got_plic-200$ ;pea_need_operand_got_plic
	.word	action_need_operand_got_dbgr-200$ ;pea_need_operand_got_dbgr
	.word	action_need_operand_got_bs-200$ ;pea_need_operand_got_bs
	.word	action_continue	- 200$	;pea_continue
never_error:				;this should never occur
	movl	#pli$k_never,r0		;code for "never should happen"
bug_check:				;signal error - r0 must contain code
	pushl	r0			;push error code
	pushl	#1			;one fao argument
	pushl	#dbg$_debugbug		;pli debug module error
	calls	#3,lib$signal		;signal error, should never return
	ret				;
notyet:					;not yet implemented
	movl	#pli$k_not_yet,r0	;not yet code
	brb	bug_check		;go signal error
	.subtitle	action ok
action_ok:
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	@ap_tree_ptr(ap)	;pass address of head node
	calls	#1,pli_hot_fixup	;fixup the hot tree
	movl	r0,@ap_hot_tree_code(ap) ;update hot tree code with fixup code
	ret				;
	.subtitle	action warning
action_warning:				;
	subl3	result_vector+pli_tokr$l_1(fp)- ;difference between start of
		,dsc$a_pointer(r11),r0	;token and start of rest of string
					;gives amount to add to length to get
					;back original string. Can't use token
					;length because blanks following the
					;token may have been skipped to get
					;the address of the first non-blank
					;after the token.
	movl	result_vector+pli_tokr$l_1(fp)- ;address of token is address
		,dsc$a_pointer(r11)	;of start of the rest of the string
	addw2	r0,dsc$w_length(r11)	;length of the rest of the string
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	@ap_tree_ptr(ap)	;pass address of head node
	calls	#1,pli_hot_fixup	;fixup the hot tree
	cmpl	r0,#sts$k_success	;was the fixup successful?
	bneq	10$			;branch if not
	movl	#sts$k_warning,@ap_hot_tree_code(ap) ;warning return
	ret				;
10$:	movl	r0,@ap_hot_tree_code(ap) ;use the return code from hot_fixup
	ret				;
	.subtitle	action err_more_name
action_err_more_name:			;
	pushl	pli_node$a_str(r9)	;start of name that is incomplete
	subl3	pli_node$a_str(r9),-	;calculate the length of the name
		result_vector+pli_tokr$l_1(fp),-(sp) ;up to error point
	pushl	#2			;2 fao arguments
	pushl	#dbg$_incomname	;"incomplete name specified" code
	calls	#4,dbg$nmake_arg_vect	;make the message vector
	movl	r0,@ap_message_vect(ap) ;put in message vector address
	brb	restore_severe		;restore input desc. and set severe
	.subtitle	action_severe_msg
action_severe_msg:			;
	movl	result_vector+pli_tokr$l_2(fp),- ;get address of message
		@ap_message_vect(ap)	;and place in pointer
	brb	restore_severe		;restore input desc. and set severe
	.subtitle	action_error
action_error:				;return code is to be error
	movw	start_length(fp),dsc$w_length(r11) ;restore length
	movl	start_pointer(fp),dsc$a_pointer(r11) ;restore address
	movl	#sts$k_error,r0		;error return code
	ret				;
	.subtitle	action_error_null
action_error_null:			;null line - syntax error
	pushl	start_pointer(fp)	;push old start address
	pushl	start_length(fp)	;push old start length
	decl	(sp)			;don't include cr at end
	brb	out_syntax_err		;goto common error processing
	.subtitle	action_severe
action_severe:
	tstl	result_vector+pli_tokr$l_0(fp) ;is length of token zero?
	beql	action_error_null	;branch if so
	pushl	result_vector+pli_tokr$l_1(fp) ;push address of token
	pushl	result_vector+pli_tokr$l_0(fp) ;push size of token
out_syntax_err:				;
	cmpb	#13,@4(sp)		;carriage return only character?
	bneq	10$			;branch if more than CR
	clrl	(sp)			;null token
10$:	pushl	#2			;number of fa0 arguments
	pushl	#dbg$_syntaxd		;syntax error !AD form
	calls	#4,dbg$nmake_arg_vect	;make the message
	movl	r0,@ap_message_vect(ap)	;update pointer to message vector
	brb	restore_severe		;restore input desc. and severe ret
restore_severe:				;restore input desc. and severe ret
	movw	start_length(fp),dsc$w_length(r11) ;restore length
	movl	start_pointer(fp),dsc$a_pointer(r11) ;restore address
	movl	#sts$k_severe,r0	;severe error return
	ret				;
	.subtitle	action err_token
action_err_token:
	movl	result_vector+pli_tokr$l_2(fp),- ;get message vector address
		@ap_message_vect(ap)	;and place in message vector ptr
	brb	restore_severe		;restore input desc. and severe ret
	.subtitle	err_excess_rp
err_excess_rp:				;
	pushl	#0			;no fao arguments
	pushl	#dbg$_rtparnfound	;unmatched right parenthesis found
	calls	#2,dbg$nmake_arg_vect	;make the message vector
	movl	r0,@ap_message_vect(ap)	;update message vector pointer
	brb	restore_severe		;severe error return
	.subtitle	action continue
;
;********************************
;*   action - continue		*
;********************************
;
; This action routine finds the operator node that this (and possibly
; some of its parents) continues. It re-enters the parse case instruction
; with the "current node" type as this operator type. It does not
; actually change the current node, that stays as a continue node. This
; means that any action routines that operate on operators may have to
; examine the node type to determine if it is actually a continue node.
; Usually this should not be necessary, for example, things like
; pli_node_opr_max_arg have been adjusted so that the continue node
; can just be treated as the original operator node would be if continue
; nodes were not needed.
;
; This action routine is entered with the current node of type
; oprcon or more_oprcon. Later we may wish to break out these two cases.
;	 register	use
;	r11		input descriptor pointer (leave alone)
;	r10		pointer to head node (leave alone)
;	r9		pointer to current node (leave alone)
;	r4		put in "parent" operator node type in here
;	r3		points to proper ptable list for current mode (leave
;			alone)
;	r2		temporary
;	r0		current token type (leave alone)
;
action_continue:			;
;
;note: we can't optimize the following code to look at the parent immediately
;	because we may be looking at a more_oprcon node pointed to by
;	an oprnd node.
;
	movl		r9,r2		;copy pointer to current node
10$:	cmpl		#pli_node_type$k_oprcon,pli_node_type(r2) ;continue?
	bneq		50$		;branch if not
	movl		pli_node_blink(r2),r2 ;point to parent
	brb		10$		;go see if operator continue node
50$:	cmpl		#pli_node_type$k_more_oprcon,pli_node_type(r2) ;more
					;operator continue node?
	beql		200$		;branch if more_oprcon
100$:	movl		pli_node_type(r2),r4 ;get type of node
	brw		continue_entry	;go case on this type
;
;continue node is a more_oprcon node so when we jam the type in r4 we
;must give it the proper state
;
200$:	movl	pli_node_blink(r2),r2	;point to parent
	cmpl	#pli_node_type$k_oprcon,pli_node_type(r2) ;a continue node?
	beql	200$			;branch to get parent if a continue
	cmpl	#pli_node_type$k_oprnd,pli_node_type(r2) ;name data node?
	beql	210$			;branch if ok, i.e. named
	brw	never_error		;this is the only kind supported now
;
;***later we change the above to support more kinds of more continue operators
;
210$:	movl	#pli_node_type$k_more_oprnd,r4 ;jam the node type
	brw	continue_entry		;re_enter parse table case setup

	.subtitle	action pop
;
;********************************
;*   action - pop		*
;********************************
;
action_pop:				;
	clrl	r7			;(to trap errors if tree corrupted)
10$:	casel	pli_node_type(r9),#0,#19 ;node type case
20$:					;
	.word	never_error -	20$	;0 reserved
	.word	err_excess_rp -	20$	;1 head node
	.word	never_error -	20$	;2 name node function
	.word	never_error -	20$	;3 name node data
	.word	never_error -	20$	;4 name node other (routine, module)
	.word	100$	    -	20$	;5 operator node - infix or prefix opr
	.word	never_error -	20$	;6 operator node - named function
	.word	100$	    -	20$	;7 operator node - named data
	.word	never_error -	20$	;8 operator node - named other
	.word	100$	    -	20$	;9 operator node - pointer
	.word	never_error -	20$	;10 operator node - arguments
	.word	200$	    -	20$	;11 operator node - subscripts
	.word	300$	    -	20$	;12 operator node - left parenthesis
	.word	100$	    -	20$	;13 operator node - continue
	.word	100$	    -	20$	;14 pli value descriptor node
	.word	100$	    -	20$	;15 debug special symbol node
	.word	100$	    -	20$	;16 debug constant node
	.word	never_error -	20$	;17 oprnd -state = need more name
	.word	never_error -	20$	;18 oprscr - state = need more scr
	.word	never_error -	20$	;19 oprcon - state = need more operand
	brw	never_error		;node type code too high
100$:	movl	r9,r7			;save previous node
	movl	pli_node_blink(r9),r9	;current node is parent
	brb	10$			;continue popping
;
;operator node subscript
;
200$:	movl	pli_node_blink(r9),r9	;point to name node
	movl	pli_node_blink(r9),r9	;point to oprnd node
210$:					;check to see if mode change required
;***later*** we will have to be more sophisticated when we actually do
;debug address expression calculations
	movl	r9,r0			;copy current node pointer
220$:	movl	pli_node_blink(r0),r0	;find parent of current node
	cmpl	#pli_node_type$k_head,pli_node_type(r0) ;is it the head node?
	beql	230$			;branch if head node
	cmpl	#pli_node_type$k_oprptr,pli_node_type(r0) ;parent a pointer?
	beql	220$			;if so, find its parent
	brb	290$			;neither head nor pointer
230$:	cmpl	#pli_node_mode$k_dae,ap_tree_mode(ap) ;was original mode dae?
	bneq	290$			;if not, branch (keep mode the same)
	movl	#pli_node_mode$k_dae,current_mode(fp) ;change the current mode
290$:	brw	p_loop			;continue parsing
;
;current node is left parenthesis
;the action is to make the oprlp node disappear
;
300$:					;
	tstl	r7			;previous node undefined?
	beql	399$			;should never happend
	movl	pli_node_blink(r9),r9	;parent of left parenthesis node
	casel	pli_node_type(r9),#0,#19 ;node type case
350$:					;
	.word	never_error -	350$	;0 reserved
	.word	400$	    -	350$	;1 head node
	.word	never_error -	350$	;2 name node function
	.word	never_error -	350$	;3 name node data
	.word	never_error -	350$	;4 name node other (routine, module)
	.word	500$	    -	350$	;5 operator node - infix or prefix opr
	.word	never_error -	350$	;6 operator node - named function
	.word	never_error -	350$	;7 operator node - named data
	.word	never_error -	350$	;8 operator node - named other
	.word	500$	    -	350$	;9 operator node - pointer
	.word	never_error -	350$	;10 operator node - arguments
	.word	500$	    -	350$	;11 operator node - subscripts
	.word	500$	    -	350$	;12 operator node - left parenthesis
	.word	500$	    -	350$	;13 operator node - continue
	.word	never_error -	350$	;14 pli value descriptor node
	.word	never_error -	350$	;15 debug special symbol node
	.word	never_error -	350$	;16 debug constant node
	.word	never_error -	350$	;17 oprnd -state = need more name
	.word	never_error -	350$	;18 oprscr - state = need more scr
	.word	never_error -	350$	;19 oprcon - state = need more operand
399$:	brw	never_error		;node type code too high
;
;head node
;
400$:					;head node
	movl	r7,pli_node_flink(r9)	;left paren. parent flink
	movl	r7,pli_node_blink(r9)	;left paren. parent blink
450$:	movl	r9,pli_node_flink(r7)	;first node after "(" flink
	movl	r9,pli_node_blink(r7)	;first node after "(" blink
	movl	r7,r9			;new current node
	brw	p_loop			;continue parsing
;
;parent of left parenthesis is an operator node
;
500$:					;
	movl	pli_node_opr_arg_cur(r9),r5 ;get current number of arguments
	addl2	r5,r5			;*2 for flink+blink
	movl	r7,pli_node_opr_sub_fl-8(r9)[r5] ;put in flink for lp parent
	movl	r7,pli_node_opr_sub_bl-8(r9)[r5] ;put in blink for lp parent
	brb	450$			;merge with common code
	.subtitle	action comma
;
;********************************
;*   action - comma		*
;********************************
;
action_comma:				;
10$:	cmpl	#pli_node_type$k_head,pli_node_type(r9) ;reached head node?
	beql	100$			;should never happen
	movl	pli_node_blink(r9),r9	;look at parent node
	cmpl	#pli_node_type$k_oprscr,pli_node_type(r9) ;up to subscript node
					;yet?
	bneq	10$			;keep going up tree
	movl	#pli_node_type$k_more_oprscr,pli_node_type(r9) ;change node
					;type
	brw	p_loop			;continue parsing
100$:	brw	action_severe		;syntax error
	.subtitle	action ptr
;
;********************************
;*   action - ptr		*
;********************************
;
action_ptr:				;
;
;p1->...->Pn->Q is equivalent to ((P1->...)->Pn)->Q and
; -> has higher precedence than any other operator. If current node
;has a parent that is a pointer, then the curretn node is a right operand
;of its parent since theleft operand is found first, the operator (pointer)
;next, and curretn node is not pointer (otherwise we have encountered
;"->->" which was trapped as a syntax error).
;
	movl	pli_node_blink(r9),r7	;point to parent node
	cmpl	#pli_node_type$k_oprptr,pli_node_type(r7) ;is current node the
					;right operand of a pointer node?
	bneq	10$			;branch if not
	movl	r7,r9			;make parent the current node
	movl	pli_node_blink(r9),r7	;get parent of new current node
;
;get storage for pointer node and fill in the values
;
10$:	pushl	ap_message_vect(ap)	;pass message vector
	pushal	new_node(fp)		;pointer to operator node
	pushl	#pli_node_opr$k_size+3/4 ;longwords needed by operator node
	calls	#3,dbg$nlist_freez	;get the storage
	blbs	r0,30$			;branch if ok
	ret				;
30$:	movl	new_node(fp),r8		;point to new node
	movl	#pli_node_type$k_oprptr,- ;operator node type is
		pli_node_type(r8)	;pointer
	incl	pli_head_node_count(r10);number of nodes in tree
	movl	pli_head_node_count(r10),- ;this is the id for this new
		pli_node_ident(r8)	;node
	movw	result_vector+pli_tokr$l_0(fp),- ;get length of token
		pli_node$w_sl(r8)	;put in node
	movl	result_vector+pli_tokr$l_1(fp),- ;get address of token
		pli_node$a_str(r8)	;put in node
	clrl	pli_node_opr_subtype(r8);clear operator subtype
	movl	#1,pli_node_opr_arg_cur(r8) ;current number of arguments
	movl	#pli_node_opr$k_min_arg,- ;move in the minimum number of
		pli_node_opr_arg_min(r8) ;arguments allowed
	movl	#2,-			;move in the maximum number of
		pli_node_opr_arg_max(r8) ;arguments allowed
;
;link current node as left operand of newly created pointer node
;
	movl	r8,pli_node_flink(r9)	;flink for current points to new ptr
	movl	r8,pli_node_blink(r9)	;blink for curretn points to new ptr
	movl	r9,pli_node_opr_sub_fl(r8) ;new ptr node's first argument flink
	movl	r9,pli_node_opr_sub_bl(r8) ;new ptr node's first argument blink
;
;case on parent node in preparation to linking to newly created pointer node
;
	casel	pli_node_type(r7),#0,#19 ;node type case
100$:					;
	.word	never_error -	100$	;0 reserved
	.word	120$	    -	100$	;1 head node
	.word	never_error -	100$	;2 name node function
	.word	never_error -	100$	;3 name node data
	.word	never_error -	100$	;4 name node other (routine, module)
;
;***later add code for the following to check for syntax errors for
;special operator cases (true?) e.g.
; (a+b)->q  the action results in a left parenthesis disappearing when
;the right parenthesis is found so that when the pointer is encountered,
;current node is the + operator. This is currently illegal syntax for
;pli but what about version 2? In any case, do we extend the syntax for
;the debugger?
;
	.word	200$	    -	100$	;5 operator node - infix or prefix opr
	.word	never_error -	100$	;6 operator node - named function
	.word	200$	    -	100$	;7 operator node - named data
	.word	never_error -	100$	;8 operator node - named other
	.word	200$	    -	100$	;9 operator node - pointer
	.word	never_error -	100$	;10 operator node - arguments
	.word	200$	    -	100$	;11 operator node - subscripts
	.word	never_error -	100$	;12 operator node - left parenthesis
	.word	never_error -	100$	;13 operator node - continue
	.word	never_error -	100$	;14 pli value descriptor node
	.word	never_error -	100$	;15 debug special symbol node
	.word	never_error -	100$	;16 debug constant node
	.word	never_error -	100$	;17 oprnd -state = need more name
	.word	never_error -	100$	;18 oprscr - state = need more scr
	.word	never_error -	100$	;19 oprcon - state = need more operand
	brw	never_error		;node type code too high
;
;parent is head node, attach new pointer node to head node
;
120$:	movl	r8,pli_node_flink(r7)	;head node flink to new pointer node
	movl	r8,pli_node_blink(r7)	;head node blink to new pointer node
150$:	movl	r7,pli_node_flink(r8)	;new pointer node flink
	movl	r7,pli_node_blink(r8)	;new pointer node blink
	movl	r8,r9			;pointer node is current node
	brw	p_loop			;go get next token
;
;parent is operator node - oprptr, oprnd, or oprscr
;or parent is infix or prefix operator
;***warning***
; we assume that the current node is pointed to by the last argument of
; the operator node. If this changes, so must the following code
;
;	register	use
;	r9	current node
;	r8	new pointer node
;	r7	parent
;
200$:	movl	pli_node_opr_arg_cur(r7),r5 ;get current number of arguments
	addl2	r5,r5			;arguments are 2 longwords
	movl	r8,pli_node_opr_sub_fl-8(r7)[r5] ;operator node's arg. flink
	movl	r8,pli_node_opr_sub_bl-8(r7)[r5] ;operator node's arg. blink
	brb	150$			;branch to common code
	.subtitle	action subscript
;
;********************************
;*   action - subscript		*
;********************************
;
action_subscript:			;
;we are currently at a oprnd node and have encountered a left parenthesis.
;First we find the rightmost name node to add the subscript to. We do
;not find the leftmost name node because otherwise the parse would
;accept things like a(1,2)(3,4).b which for now we exclude, at the cost
;of having to later move all the subscripts to the first node for a
;canonical representation of a name.
;
	cmpl	#pli_node_type$k_oprnd,pli_node_type(r9) ;make sure it really
	beql	10$			;is a operator name node, branch if ok
	cmpl	#pli_node_type$k_oprcon,pli_node_type(r9) ;could also be a
	beql	10$			;continue node, branch if ok
	brw	never_error		;this should never happen
10$:	movl	pli_node_opr_arg_cur(r9),r5 ;get the number of arguments
	addl2	r5,r5			;double the value (flink+blink)
	movl	pli_node_opr_sub_fl-8(r9)[r5],r9 ;point to the last argument
	cmpl	#pli_node_type$k_oprcon,pli_node_type(r9) ;continuation?
	beql	10$			;get the next operand if a continuation
;
;we are now at the last named node
;
	tstl	pli_node_nam_arg_fl(r9)	;see if we have previously made
					;subscripts
	beql	50$			;branch if no previous subscripts
;***later we could give a more specific error message here
	brw	action_severe		;merge with common syntax error code
50$:					;
	pushl	ap_message_vect(ap)	;pass message vector
	pushal	pli_node_nam_arg_fl(r9)	;pointer to operator node
	pushl	#pli_node_opr$k_size+3/4 ;longwords needed by operator node
	calls	#3,dbg$nlist_freez	;get the storage
	blbs	r0,130$			;branch if ok
	ret				;
130$:	movl	pli_node_nam_arg_fl(r9),r8 ;point to new node
	movl	r8,pli_node_nam_arg_bl(r9) ;put in blink
	movl	r9,pli_node_flink(r8)	;flink for new node
	movl	r9,pli_node_blink(r8)	;blink for new node
	movl	#pli_node_type$k_more_oprscr,- ;operator node type is
		pli_node_type(r8)	;need more subscript
	incl	pli_head_node_count(r10);number of nodes in tree
	movl	pli_head_node_count(r10),- ;this is the id for this new
		pli_node_ident(r8)	;node
	movw	result_vector+pli_tokr$l_0(fp),- ;get length of token
		pli_node$w_sl(r8)	;put in node
	movl	result_vector+pli_tokr$l_1(fp),- ;get address of token
		pli_node$a_str(r8)	;put in node
	clrl	pli_node_opr_subtype(r8);clear operator subtype
	clrl	pli_node_opr_arg_cur(r8) ;current number of arguments
	movl	#1,-			;move in the minimum number of
		pli_node_opr_arg_min(r8) ;arguments allowed
;***later aren't we limited to 256 arguments? add error code later
	movl	#pli_omega_max_arg,-	;move in the maximum number of
		pli_node_opr_arg_max(r8) ;arguments allowed
;
;change current mode if necessary
;
	cmpl	#pli_node_mode$k_dae,current_mode(fp) ;processing debug address
					;expression
	bneq	200$			;branch if not debug address expression
	movl	#pli_node_mode$k_pli,current_mode(fp) ;change modes
200$:	movl	r8,r9			;operator node more_oprscr is current
					;node
	brw	p_loop			;
	.subtitle	action first identifier
;
;********************************
;*   action - first identifier	*
;********************************
;
action_first_id:			;
	casel	pli_node_type(r9),#0,#19 ;node type case
10$:					;
	.word	never_error -	10$	;0 reserved
	.word	20$	    -	10$	;1 head node
	.word	never_error -	10$	;2 name node function
	.word	never_error -	10$	;3 name node data
	.word	never_error -	10$	;4 name node other (routine, module)
	.word	100$	    -	10$	;5 operator node - infix or prefix opr
	.word	never_error -	10$	;6 operator node - named function
	.word	100$	    -	10$	;7 operator node - named data
	.word	never_error -	10$	;8 operator node - named other
	.word	100$	    -	10$	;9 operator node - pointer
	.word	never_error -	10$	;10 operator node - arguments
	.word	100$	    -	10$	;11 operator node - subscripts
	.word	100$	    -	10$	;12 operator node - left parenthesis
	.word	never_error -	10$	;13 operator node - continue
	.word	never_error -	10$	;14 pli value descriptor node
	.word	never_error -	10$	;15 debug special symbol node
	.word	never_error -	10$	;16 debug constant node
	.word	never_error -	10$	;17 oprnd -state = need more name
	.word	never_error -	10$	;18 oprscr - state = need more scr
	.word	never_error -	10$	;19 oprcon - state = need more operand
	brw	never_error		;node type code too high
;
20$:					;head node
	pushl	ap_message_vect(ap)	;pass message vector
	pushal	new_node(fp)		;pointer to operator node
	pushl	#pli_node_opr$k_size+3/4 ;longwords needed by operator node
	calls	#3,dbg$nlist_freez	;get the storage
	blbs	r0,30$			;branch if ok
	ret				;

30$:	movl	new_node(fp),r8		;point to new node
	insque	(r8),(r9)		;insert new node
40$:	movl	#pli_node_type$k_oprnd,- ;operator node type is
		pli_node_type(r8)	;named data
	incl	pli_head_node_count(r10);number of nodes in tree
	movl	pli_head_node_count(r10),- ;this is the id for this new
		pli_node_ident(r8)	;node
	movw	result_vector+pli_tokr$l_0(fp),- ;get length of token
		pli_node$w_sl(r8)	;put in node
	movl	result_vector+pli_tokr$l_1(fp),- ;get address of token
		pli_node$a_str(r8)	;put in node
	clrl	pli_node_opr_subtype(r8);clear operator subtype
	movl	#1,pli_node_opr_arg_cur(r8) ;current number of arguments
	movl	#pli_node_opr$k_min_arg,- ;move in the minimum number of
		pli_node_opr_arg_min(r8) ;arguments allowed
	movl	#pli_omega_max_arg,-	;move in the maximum number of
		pli_node_opr_arg_max(r8) ;arguments allowed
	pushl	ap_message_vect(ap)	;pass message vector
	pushal	pli_node_opr_sub_fl(r8) ;pointer to name node
	pushl	#pli_node_nam$k_size+3/4 ;longwords needed by name node
	calls	#3,dbg$nlist_freez	;get the storage
	blbs	r0,50$			;branch if ok
	ret				;
50$:	movl	pli_node_opr_sub_fl(r8),- ;flink is
		r7			;saved
	movl	r7,pli_node_opr_sub_bl(r8) ;made the blink
	movl	r8,pli_node_flink(r7)	;flink of name node
	movl	r8,pli_node_blink(r7)	;blink of name node
	movl	#pli_node_type$k_named,- ;type of node is
		pli_node_type(r7)	;name data node
	incl	pli_head_node_count(r10);number of nodes in tree
	movl	pli_head_node_count(r10),- ;this is the id for this new
		pli_node_ident(r7)	;node
	movw	result_vector+pli_tokr$l_0(fp),- ;get length of token
		pli_node$w_sl(r7)	;put in node
	movl	result_vector+pli_tokr$l_1(fp),- ;get address of token
		pli_node$a_str(r7)	;put in node
	movl	result_vector+pli_tokr$l_2(fp),- ;get address of pn if
		pli_node_nam_pn_ptr(r7)	;it exits (0 otherwise)
;
;**kind,symid,pn_pointer done later in hot_fixup
;**arg (subscripts) are zero for now
;
	movl	r8,r9			;operator node is current node
	brw	p_loop			;go get next token
;
;operator node is current
;
100$:					;operator node is current node
	bsbw	pli_continue_operator	;make a continue node if necessary
	movl	pli_node_opr_arg_cur(r9),r5 ;get current number of arguments
	addl2	r5,r5			;*2 for flink+blink
	incl	pli_node_opr_arg_cur(r9);increment current argument count
	pushl	ap_message_vect(ap)	;pass message vector
	pushal	pli_node_opr_sub_fl(r9)[r5] ;pointer to operator node
	pushl	#pli_node_opr$k_size+3/4 ;longwords needed by operator node
	calls	#3,dbg$nlist_freez	;get the storage
	blbs	r0,130$			;branch if ok
	ret				;
130$:	movl	pli_node_opr_sub_fl(r9)[r5],r8 ;point to new node
	movl	r8,pli_node_opr_sub_bl(r9)[r5] ;put in blink
	movl	r9,pli_node_flink(r8)	;flink for new node
	movl	r9,pli_node_blink(r8)	;blink for new node
	brw	40$			;merge with common code
	.subtitle	action more identifier
;
;************************************************
;* action - more identifier			*
;************************************************
;we must be at a more_oprnd or more_oprcon node
;	
action_more_id:				;
	cmpl	pli_node_type(r9),#pli_node_type$k_more_oprnd ;proper state?
	beql	20$			;branch if ok
	cmpl	pli_node_type(r9),#pli_node_type$k_more_oprcon ;continue?
	bneq	10$			;branch if not (error)
	movl	#pli_node_type$k_oprcon,pli_node_type(r9) ;change current node
	brb	40$			;merge with common code
10$:	brw	never_error		;this should never happen
20$:	movl	#pli_node_type$k_oprnd,pli_node_type(r9) ;change current node
					;type to operator named
40$:	bsbw	pli_continue_operator	;continue the operator if necessary
	movl	pli_node_opr_arg_cur(r9),r5 ;old argument count
	incl	pli_node_opr_arg_cur(r9) ;new argument count
	addl2	r5,r5			;number of longwords to new flink arg
	pushl	ap_message_vect(ap)	;pass message vector
	pushal	pli_node_opr_sub_fl(r9)[r5] ;pointer to name node
	pushl	#pli_node_nam$k_size+3/4 ;longwords needed by name node
	calls	#3,dbg$nlist_freez	;get the storage
	blbs	r0,50$			;branch if ok
	ret				;
50$:	movl	pli_node_opr_sub_fl(r9)[r5],- ;flink is
		r7			;saved
	movl	r7,pli_node_opr_sub_bl(r9)[r5] ;made the blink
	movl	r9,pli_node_flink(r7)	;flink of name node
	movl	r9,pli_node_blink(r7)	;blink of name node
	movl	#pli_node_type$k_named,- ;type of node is
		pli_node_type(r7)	;name data node
	incl	pli_head_node_count(r10);number of nodes in tree
	movl	pli_head_node_count(r10),- ;this is the id for this new
		pli_node_ident(r7)	;node
	movw	result_vector+pli_tokr$l_0(fp),- ;get length of token
		pli_node$w_sl(r7)	;put in node
	movl	result_vector+pli_tokr$l_1(fp),- ;get address of token
		pli_node$a_str(r7)	;put in node
;
;**kind,symid,pn_pointer done later in hot_fixup
;**arg (subscripts) are zero for now
;
	brw	p_loop			;get next token
	.subtitle	action prefix
;
;********************************
;*   action - prefix		*
;********************************
;
action_prefix:				;
	movl	result_vector+pli_tokr$l_2(fp),r0 ;get operator type
	cmpl	#pli_node_opr$k_binary_minus,r0 ;was it a "-" ?
	bneq	50$			;branch if not "-"
	movl	#pli_node_opr$k_unary_minus,- ;since this is known by context
		result_vector+pli_tokr$l_2(fp) ;to be a unary operator, change
					;operator code
	brb	200$			;continue
50$:	cmpl	#pli_node_opr$k_binary_plus,r0 ;was it a "+"
	bneq	60$			;branch if not a "+"
	movl	#pli_node_opr$k_unary_plus,- ;since this is known by context
		result_vector+pli_tokr$l_2(fp) ;to be a unary operator, change
					;operator code
	brb	200$			;continue
60$:	cmpl	#pli_node_opr$k_not,r0	;was it a "^"
	beql	200$			;continue
	brw	never_error		;should have trapped as a syntax error
200$:	casel	pli_node_type(r9),#0,#19 ;node type case
300$:					;
	.word	never_error -	300$	;0 reserved
	.word	400$	    -	300$	;1 head node
	.word	never_error -	300$	;2 name node function
	.word	never_error -	300$	;3 name node data
	.word	never_error -	300$	;4 name node other (routine, module)
	.word	500$	    -	300$	;5 operator node - infix or prefix opr
	.word	never_error -	300$	;6 operator node - named function
	.word	never_error -	300$	;7 operator node - named data
	.word	never_error -	300$	;8 operator node - named other
	.word	500$	    -	300$	;9 operator node - pointer
	.word	never_error -	300$	;10 operator node - arguments
	.word	500$	    -	300$	;11 operator node - subscripts
	.word	500$	    -	300$	;12 operator node - left parenthesis
	.word	never_error -	300$	;13 operator node - continue
	.word	never_error -	300$	;14 pli value descriptor node
	.word	never_error -	300$	;15 debug special symbol node
	.word	never_error -	300$	;16 debug constant node
	.word	never_error -	300$	;17 oprnd -state = need more name
	.word	never_error -	300$	;18 oprscr - state = need more scr
	.word	never_error -	300$	;19 oprcon - state = need more operand
	brw	never_error		;node type code too high
;
400$:					;head node
	pushl	ap_message_vect(ap)	;pass message vector
	pushal	new_node(fp)		;pointer to operator node
	pushl	#pli_node_opr$k_size+3/4 ;longwords needed by operator node
	calls	#3,dbg$nlist_freez	;get the storage
	blbs	r0,430$			;branch if ok
	ret				;
430$:	movl	new_node(fp),r8		;point to new node
	insque	(r8),(r9)		;insert new node
440$:	movl	#pli_node_type$k_opriop,- ;operator node type is
		pli_node_type(r8)	;infix or prefix operator
	incl	pli_head_node_count(r10);number of nodes in tree
	movl	pli_head_node_count(r10),- ;this is the id for this new
		pli_node_ident(r8)	;node
	movw	result_vector+pli_tokr$l_0(fp),- ;get length of token
		pli_node$w_sl(r8)	;put in node
	movl	result_vector+pli_tokr$l_1(fp),- ;get address of token
		pli_node$a_str(r8)	;put in node
	movl	result_vector+pli_tokr$l_2(fp),- ;put in the operator
		pli_node_opr_subtype(r8);code
	clrl	pli_node_opr_arg_cur(r8) ;current number of arguments = 0
	movl	#1,-			;move in the minimum number of
		pli_node_opr_arg_min(r8) ;arguments allowed
	movl	#1,-			;move in the maximum number of
		pli_node_opr_arg_max(r8) ;arguments allowed
	movl	r8,r9			;operator node is current node
	brw	p_loop			;go get next token
;
;prefix operator or
;pointer operator or
;subscript operator or
;left parenthesis operator
;	is the current operator node
; note: the infix operator case should never come up. Thus the situation
;	is one where the current node is a prefix operator and the
;	node we are to add is also a prefix operator. In all cases
;	(currently) we can just link in the node as the argument
;	of the current operator node and let the new node be current.
;	The effect is that unary operators all have the same
;	precedence with respect to each other and operate right to left
;
500$:					;prefix,pointer,subscript, or left
					;left parenthesis
	bsbw	pli_continue_operator	;make a continue node if necessary
	movl	pli_node_opr_arg_cur(r9),r5 ;get current number of arguments
	addl2	r5,r5			;*2 for flink+blink
	incl	pli_node_opr_arg_cur(r9);increment current argument count
	pushl	ap_message_vect(ap)	;pass message vector
	pushal	pli_node_opr_sub_fl(r9)[r5] ;pointer to operator node
	pushl	#pli_node_opr$k_size+3/4 ;longwords needed by operator node
	calls	#3,dbg$nlist_freez	;get the storage
	blbs	r0,530$			;branch if ok
	ret				;
530$:	movl	pli_node_opr_sub_fl(r9)[r5],r8 ;point to new node
	movl	r8,pli_node_opr_sub_bl(r9)[r5] ;put in blink
	movl	r9,pli_node_flink(r8)	;flink for new node
	movl	r9,pli_node_blink(r8)	;blink for new node
	brw	440$			;merge with common code
	.subtitle	action infix
;
;********************************
;*   action - infix		*
;********************************
;
action_infix:				;
	movl	r9,r7			;current node
	movl	pli_node_blink(r7),r9	;parent of current node
	casel	pli_node_type(r9),#0,#19 ;node type case
300$:					;
	.word	never_error -	300$	;0 reserved
	.word	1100$	    -	300$	;1 head node
	.word	never_error -	300$	;2 name node function
	.word	never_error -	300$	;3 name node data
	.word	never_error -	300$	;4 name node other (routine, module)
	.word	500$	    -	300$	;5 operator node - infix or prefix opr
	.word	never_error -	300$	;6 operator node - named function
	.word	never_error -	300$	;7 operator node - named data
	.word	never_error -	300$	;8 operator node - named other
	.word	never_error -	300$	;9 operator node - pointer
	.word	never_error -	300$	;10 operator node - arguments
	.word	1200$	    -	300$	;11 operator node - subscripts
	.word	1200$	    -	300$	;12 operator node - left parenthesis
;
;***warning*** the following branch address implicitly assumes that infix and 
;prefix operators are never continued
;
	.word	1200$	    -	300$	;13 operator node - continue
	.word	never_error -	300$	;14 pli value descriptor node
	.word	never_error -	300$	;15 debug special symbol node
	.word	never_error -	300$	;16 debug constant node
	.word	never_error -	300$	;17 oprnd - state = need more name
	.word	never_error -	300$	;18 oprscr - state = need more scr
	.word	never_error -	300$	;19 oprcon - state = need more operand
	brw	never_error		;node type code too high
;
;parent of current is operator infix or prefix
;
500$:	movl	result_vector+pli_tokr$l_2(fp),r0 ;get the operator type
	cmpl	r0,pli_node_opr_subtype(r9) ;compare with parent of current
	blss	900$			;branch if lower precedence
	beql	520$			;branch if equal precedence
	brw	1200$			;higher precedence, use common code
;
;new operator has equal precedence with the parent of the current node
;
520$:					;new operator has equal precedence
	cmpl	r0,#pli_node_opr$k_right_to_left ;eval as if higher precedence?
	bgtr	1000$			;branch if so
;
;new operator has lower precedence than the parent of the current node
;
900$:					;new operator has lower precedence
	movl	r9,r7			;new current node
	movl	pli_node_blink(r9),r9	;new parent node
;
;the infix operator node is created and linked into the tree
;this code assumes:
;	r9	the immediate parent (possibly a continue node) of the
;		node pointed to by r9, i.e. the parent of the left operand.
;	r8	is free, it will be used to point to the new operator node
;	r7	points to node that is to be the left operand of the new
;		operator node
;
1000$:					;common code to link new operator
	casel	pli_node_type(r9),#0,#19 ;node type case on parent's type
1020$:					;
	.word	never_error -	1020$	;0 reserved
	.word	1100$	    -	1020$	;1 head node
	.word	never_error -	1020$	;2 name node function
	.word	never_error -	1020$	;3 name node data
	.word	never_error -	1020$	;4 name node other (routine, module)
	.word	1200$	    -	1020$	;5 operator node - infix or prefix opr
	.word	never_error -	1020$	;6 operator node - named function
	.word	1200$	    -	1020$	;7 operator node - named data
	.word	never_error -	1020$	;8 operator node - named other
	.word	1200$	    -	1020$	;9 operator node - pointer
	.word	never_error -	1020$	;10 operator node - arguments
	.word	1200$	    -	1020$	;11 operator node - subscripts
	.word	1200$	    -	1020$	;12 operator node - left parenthesis
	.word	1200$	    -	1020$	;13 operator node - continue
	.word	never_error -	1020$	;14 pli value descriptor node
	.word	never_error -	1020$	;15 debug special symbol node
	.word	never_error -	1020$	;16 debug constant node
	.word	never_error -	1020$	;17 oprnd -state = need more name
	.word	never_error -	1020$	;18 oprscr - state = need more scr
	.word	never_error -	1020$	;19 oprcon - state = need more operand
	brw	never_error		;node type code too high
;
;parent of current node is the head node
;
1100$:					;head node
	pushl	ap_message_vect(ap)	;pass message vector
	pushal	new_node(fp)		;pointer to operator node
	pushl	#pli_node_opr$k_size+3/4 ;longwords needed by operator node
	calls	#3,dbg$nlist_freez	;get the storage
	blbs	r0,1130$		;branch if ok
	ret				;
1130$:	movl	new_node(fp),r8		;point to new node
	movl	r8,pli_node_flink(r9)	;create head node flink
	movl	r8,pli_node_blink(r9)	;create head node blink
1140$:	movl	r9,pli_node_flink(r8)	;new node flink to parent
	movl	r9,pli_node_blink(r8)	;new node blink to parent
	movl	#pli_node_type$k_opriop,- ;operator node type is
		pli_node_type(r8)	;infix or prefix operator
	incl	pli_head_node_count(r10);number of nodes in tree
	movl	pli_head_node_count(r10),- ;this is the id for this new
		pli_node_ident(r8)	;node
	movw	result_vector+pli_tokr$l_0(fp),- ;get length of token
		pli_node$w_sl(r8)	;put in node
	movl	result_vector+pli_tokr$l_1(fp),- ;get address of token
		pli_node$a_str(r8)	;put in node
	movl	result_vector+pli_tokr$l_2(fp),- ;put in the operator
		pli_node_opr_subtype(r8);code
	movl	#1,pli_node_opr_arg_cur(r8) ;current number of arguments = 1
	movl	#2,-			;move in the minimum number of
		pli_node_opr_arg_min(r8) ;arguments allowed
	movl	#2,-			;move in the maximum number of
		pli_node_opr_arg_max(r8) ;arguments allowed
	movl	r7,pli_node_opr_sub_fl(r8) ;forward link to current node
	movl	r7,pli_node_opr_sub_bl(r8) ;backward link to current node
	movl	r8,pli_node_flink(r7)	;forward link from current to new node
	movl	r8,pli_node_blink(r7)	;backward link from current to new node
	movl	r8,r9			;operator node is current node
	brw	p_loop			;go get next token
;
;parent of current is an operator node
;
1200$:					;
	bsbw	pli_continue_operator	;continue parent (operator) as required
	movl	pli_node_opr_arg_cur(r9),r5 ;current number of arguments
	addl2	r5,r5			;*2 for flink+blink
	pushl	ap_message_vect(ap)	;pass message vector
	pushal	new_node(fp)		;pointer to operator node
	pushl	#pli_node_opr$k_size+3/4 ;longwords needed by operator node
	calls	#3,dbg$nlist_freez	;get the storage
	blbs	r0,1230$		;branch if ok
	ret				;
1230$:					;
	movl	new_node(fp),r8		;get the address of the new node
	movl	r8,pli_node_opr_sub_fl-8(r9)[r5] ;replace last argument flink
	movl	r8,pli_node_opr_sub_bl-8(r9)[r5] ;replace last argument blink
	brb	1140$			;merge with common code
	.subtitle	action dss
;
;********************************
;*   action - dss		*
;********************************
;
action_dss:				;
	casel	pli_node_type(r9),#0,#19 ;node type case
10$:					;
	.word	never_error -	10$	;0 reserved
	.word	20$	-	10$	;1 head node
	.word	never_error -	10$	;2 name node function
	.word	never_error -	10$	;3 name node data
	.word	never_error -	10$	;4 name node other (routine, module)
	.word	100$	    -	10$	;5 operator node - infix or prefix opr
	.word	100$	    -	10$	;6 operator node - named function
	.word	100$	    -	10$	;7 operator node - named data
	.word	100$	    -	10$	;8 operator node - named other
	.word	100$	    -	10$	;9 operator node - pointer
	.word	100$	    -	10$	;10 operator node - arguments
	.word	100$	    -	10$	;11 operator node - subscripts
	.word	100$	    -	10$	;12 operator node - left parenthesis
	.word	never_error -	10$	;13 operator node - continue
	.word	never_error -	10$	;14 pli value descriptor node
	.word	never_error -	10$	;15 debug special symbol node
	.word	never_error -	10$	;16 debug constant node
	.word	never_error -	10$	;17 oprnd -state = need more name
	.word	never_error -	10$	;18 oprscr - state = need more scr
	.word	never_error -	10$	;19 oprcon - state = need more operand
	brw	never_error		;node type code too high
;
;head node
;
20$:					;
	pushl	ap_message_vect(ap)	;pass message vector
	pushal	new_node(fp)		;pointer to pli vd node
	pushl	#pli_node_vd$k_size+3/4 ;longwords needed by pli vd node
	calls	#3,dbg$nlist_freez	;get the storage
	blbs	r0,30$			;branch if ok
	ret				;
30$:	movl	new_node(fp),r8		;point to new node
	insque	(r8),(r9)		;insert new node
40$:	movl	#pli_node_type$k_plivd,- ;node type is
		pli_node_type(r8)	;pli vd node
	incl	pli_head_node_count(r10);number of nodes in tree
	movl	pli_head_node_count(r10),- ;this is the id for this new
		pli_node_ident(r8)	;node
	movw	result_vector+pli_tokr$l_0(fp),- ;get length of token
		pli_node$w_sl(r8)	;put in node
	movl	result_vector+pli_tokr$l_1(fp),- ;get address of token
		pli_node$a_str(r8)	;put in node
	movl	#fixed_bin_,pli_node_vd_stype(r8) ;secondary datatype code
	movl	#31,pli_node_vd_ssize(r8) ;secondary size
	moval	pli_node_vd$a_data(r8),-;pointer to data pointer
		pli_node_vd$a_addr(r8)	;put in node
	movl	#fixed_bin_,pli_node_vd$l_type(r8) ;pli data type code
	movl	#31,pli_node_vd$l_size(r8) ;pli size code
	clrl	pli_node_vd$l_boff(r8)	;zero bit offset longword
;
;call permanent symbol interpreter
;
	pushl	#0			;pointer to perm sym descriptor
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	result_vector+pli_tokr$l_3(fp) ;pathname vector
	pushal	8(sp)			;ptr to perm sym descriptor
	pushl	result_vector+pli_tokr$l_2(fp) ;register number code
	calls	#4,dbg$nperm_sym_int	;get value of register
	blbs	r0,60$			;branch if ok
	ret				;
60$:	movl	(sp)+,r2		 ;point to perm sym descriptor
;***temp get symbolic offset from debug group
	movl	4(r2),pli_node_vd$a_data(r8) ;point to data
	movl	r8,r9			;pli vd node is current node
	brw	p_loop			;go get next token
;
;operator node is current
;
100$:					;operator node is current node
	bsbw	pli_continue_operator	;continue the operator if necessary
	movl	pli_node_opr_arg_cur(r9),r5 ;get current number of arguments
	addl2	r5,r5			;*2 for flink+blink
	incl	pli_node_opr_arg_cur(r9);increment current argument count
	pushl	ap_message_vect(ap)	;pass message vector
	pushal	pli_node_opr_sub_fl(r9)[r5] ;pointer to pli vd node
	pushl	#pli_node_vd$k_size+3/4 ;longwords needed by pli vd node
	calls	#3,dbg$nlist_freez	;get the storage
	blbs	r0,130$			;branch if ok
	ret				;
130$:	movl	pli_node_opr_sub_fl(r9)[r5],r8 ;point to new node
	movl	r8,pli_node_opr_sub_bl(r9)[r5] ;put in blink
	movl	r9,pli_node_flink(r8)	;flink for new node
	movl	r9,pli_node_blink(r8)	;blink for new node
	brw	40$			;merge with common code
	.page
	.subtitle	utility routines for actions
;
;************************************************
;* utility routines for actions			*
;************************************************
;
;
;	output message indicating that an operator is missing.
;
;	typical use by action routines:an operator node is current but
;		the total number of required arguments have been filled
;		in (e.g. if A+B has been parsed). This means that if
;		an identifier were encountered, that it could not be
;		used as an argument of the + operator and so an operator
;		is missing. Thus we would branch to this routine.
;
;	NOTE: result_vector must hod size and address of a token.
;		start_length and start_pointer are also used.
;		
;
;	register	use
;	r11		input string descriptor
;	r0		return value
;
need_operator:				;too many operands, missing operator?
	pushl	result_vector+pli_tokr$l_1(fp) ;push address of token
	pushl	result_vector+pli_tokr$l_0(fp) ;push size of token
	pushl	#2			;number of fa0 arguments
	pushl	#dbg$_needopr		;need operator !AD form
	calls	#4,dbg$nmake_arg_vect	;make the message
	movl	r0,@ap_message_vect(ap)	;update pointer to message vector
	movw	start_length(fp),dsc$w_length(r11) ;restore length
	movl	start_pointer(fp),dsc$a_pointer(r11) ;restore address
	movl	#sts$k_severe,r0	;severe return code
	ret
	.subtitle	action plivd
;
;************************************************
;* pli_continue_operator			*
;************************************************
;
; Input:	r9 points to an operator node. It is assumed that another
;		operand is to be added as the next argument of this operator.
; On exit:	r9 is unchanged if the original operator node can hold another
;		argument. Otherwise, r9 points to the continue node that has
;		been added to the tree.
;
;	register	use
;	r11		address of input string descriptor (input, not changed)
;	r10		head node pointer (input, not changed)
;	r9		operator node pointer (input, changed if continue node
;			is added.
;	r8		pointer to newly created node
;	r6-r7		point to last argument of current operator node (holds
;			flink and blink
;	r5		holds current number of arguments in current operator
;
;
; result_vector+pli_tokr$l_0(fp) = size of input token
; result_vector+pli_tokr$l_1(fp) = address of token
;
pli_continue_operator:			;
10$:	movl	pli_node_opr_arg_cur(r9),r0 ;get cur number of arguments
	cmpl	r0,pli_node_opr_arg_max(r9) ;already maximum allowed arguments?
	blss	20$			;branch if we have less than maximum
	brb	need_operator		;go output "missing operator" message
20$:	cmpl	r0,#pli_node_opr$k_max_arg ;maximum arguments allowed for node?
	bgeq	30$			;branch if at maximum to add oprcon
	rsb				;
30$:					;
	addl2	r0,r0			;*2 for blink + flink
	movl	pli_node_opr_sub_fl-8(r9)[r0],r0 ;point to last argument
	cmpl	#pli_node_type$k_oprcon,pli_node_type(r0) ;continue node
	bneq	50$			;go make new continue node
	movl	r0,r9			;make continue node current
	brb	10$			;continue this new current node
50$:					;
;
;we need to make a new continue node
;
110$:					;
	pushl	ap_message_vect(ap)	;pass along message vector
	pushal	new_node(fp)		;place for new node address
	pushl	#pli_node_opr$k_size+3/4 ;number of longwords for continue node
	calls	#3,dbg$nlist_freez	;get the number of bytes
	blbs	r0,120$			;branch if ok
	ret				;
120$:	movl	new_node(fp),r8		;address of continue node
	movl	pli_node_opr_arg_cur(r9),r5 ;current number of arguments
	movl	#pli_node_type$k_oprcon,- ;node type is
		pli_node_type(r8)	;continue node
	incl	pli_head_node_count(r10);number of nodes in tree
	movl	pli_head_node_count(r10),- ;this count is the id for the
		pli_node_ident(r8)	;new node
	movw	pli_node$w_sl(r9),pli_node$w_sl(r8) ;copy string length
	movl	pli_node$a_str(r9),pli_node$a_str(r8) ;copy address of string
	movl	#1,pli_node_opr_arg_cur(r8) ;we will have one argument soon
	movl	#pli_node_opr$k_min_arg,- ;move in the minimum number of
		pli_node_opr_arg_min(r8) ;arguments allowed
	subl3	r5,-			;calculate the maximum number of
		pli_node_opr_arg_max(r9),- ;arguments allowed in the next
		pli_node_opr_arg_max(r8);node
	movl	pli_node_opr_subtype(r9),- ;copy the parent's subtype code
		pli_node_opr_subtype(r8);to the continue node
	movaq	pli_node_opr_sub_fl-8(r9)[r5],r0 ;point to the last argument
	movq	(r0),r6			;hold old last argument node
	movq	r6,pli_node_opr_sub_fl(r8) ;old last argument is the first
					;argument of the new node
	movl	r8,pli_node_flink(r7)	;old last arg. gets new flink
	movl	r8,pli_node_blink(r6)	;old last arg. gets new blink
	movl	r8,(r0)			;old flink pts to new node
	movl	r8,4(r0)		;old blink pts to new node
	movl	r9,pli_node_flink(r8)	;new nodes flink pts to old node
	movl	r9,pli_node_blink(r8)	;new nodes blink pts to old node
	movl	r8,r9			;continue node is current node
	rsb				;
;
;************************************************
;* action - pli value descriptor		*
;************************************************
;
action_plivd:				;
	casel	pli_node_type(r9),#0,#19 ;node type case
10$:					;
	.word	never_error -	10$	;0 reserved
	.word	20$	    -	10$	;1 head node
	.word	never_error -	10$	;2 name node function
	.word	never_error -	10$	;3 name node data
	.word	never_error -	10$	;4 name node other (routine, module)
	.word	100$	    -	10$	;5 operator node - infix or prefix opr
	.word	100$	    -	10$	;6 operator node - named function
	.word	100$	    -	10$	;7 operator node - named data
	.word	100$	    -	10$	;8 operator node - named other
	.word	100$	    -	10$	;9 operator node - pointer
	.word	100$	    -	10$	;10 operator node - arguments
	.word	100$	    -	10$	;11 operator node - subscripts
	.word	100$	    -	10$	;12 operator node - left parenthesis
	.word	never_error -	10$	;13 operator node - continue
	.word	never_error -	10$	;14 pli value descriptor node
	.word	never_error -	10$	;15 debug special symbol node
	.word	never_error -	10$	;16 debug constant node
	.word	never_error -	10$	;17 oprnd -state = need more name
	.word	never_error -	10$	;18 oprscr - state = need more scr
	.word	never_error -	10$	;19 oprcon - state = need more operand
	brw	never_error		;node type code too high
;
;head node
;
20$:					;head node
	pushl	ap_message_vect(ap)	;pass message vector
	pushal	new_node(fp)		;pointer to pli vd node
	pushl	#pli_node_vd$k_size+3/4 ;longwords needed by pli vd node
	calls	#3,dbg$nlist_freez	;get the storage
	blbs	r0,30$			;branch if ok
	ret				;
30$:	movl	new_node(fp),r8		;point to new node
	insque	(r8),(r9)		;insert new node
40$:	movl	#pli_node_type$k_plivd,- ;node type is
		pli_node_type(r8)	;pli vd node
	incl	pli_head_node_count(r10);number of nodes in tree
	movl	pli_head_node_count(r10),- ;this is the id for this new
		pli_node_ident(r8)	;node
	movw	result_vector+pli_tokr$l_0(fp),- ;get length of token
		pli_node$w_sl(r8)	;put in node
	movl	result_vector+pli_tokr$l_1(fp),- ;get address of token
		pli_node$a_str(r8)	;put in node
	movl	result_vector+pli_tokr$l_4(fp),- ;secondary datatype code
		pli_node_vd_stype(r8)	;put in node
	movl	result_vector+pli_tokr$l_5(fp),- ;secondary size code
		pli_node_vd_ssize(r8)	;put in node
	moval	pli_node_vd$a_data(r8),-;pointer to data pointer
		pli_node_vd$a_addr(r8)	;put in node
	movl	result_vector+pli_tokr$l_2(fp),- ;pli datatype code
		pli_node_vd$l_type(r8)	;put in node
	movl	result_vector+pli_tokr$l_3(fp),- ;pli size code
		pli_node_vd$l_size(r8)	;put in node
	clrl	pli_node_vd$l_boff(r8)	;zero bit offset longword
	movl	result_vector+pli_tokr$l_1(fp),- ;first character of constant
		pli_node_vd$a_data(r8)	;put in node
	movl	r8,r9			;pli vd node is current node
	brw	p_loop			;go get next token
;
;operator node is current
;
100$:					;operator node is current node
	bsbw	pli_continue_operator	;continue operator node if necessary
	movl	pli_node_opr_arg_cur(r9),r5 ;get current number of arguments
	addl2	r5,r5			;*2 for flink+blink
	incl	pli_node_opr_arg_cur(r9);increment current argument count
	pushl	ap_message_vect(ap)	;pass message vector
	pushal	pli_node_opr_sub_fl(r9)[r5] ;pointer to pli vd node
	pushl	#pli_node_vd$k_size+3/4 ;longwords needed by pli vd node
	calls	#3,dbg$nlist_freez	;get the storage
	blbs	r0,130$			;branch if ok
	ret				;
130$:	movl	pli_node_opr_sub_fl(r9)[r5],r8 ;point to new node
	movl	r8,pli_node_opr_sub_bl(r9)[r5] ;put in blink
	movl	r9,pli_node_flink(r8)	;flink for new node
	movl	r9,pli_node_blink(r8)	;blink for new node
	brw	40$			;merge with common code
	.subtitle	action dbgcon
;
;********************************
;*   action - dbgcon		*
;********************************
;
action_dbgcon:				;
	movl	#pli$k_not_yet,r0	;
	brw	bug_check		;
	.subtitle	action push
;
;************************************************
;* action - push  (left parenthesis found	*
;************************************************
;
action_push:				;
	casel	pli_node_type(r9),#0,#19 ;node type case
10$:					;
	.word	never_error -	10$	;0 reserved
	.word	20$	    -	10$	;1 head node
	.word	never_error -	10$	;2 name node function
	.word	never_error -	10$	;3 name node data
	.word	never_error -	10$	;4 name node other (routine, module)
	.word	100$	    -	10$	;5 operator node - infix or prefix opr
	.word	never_error -	10$	;6 operator node - named function
					;(named data nodes changed to this type
					;later
	.word	never_error -	10$	;7 operator node - named data
					;(called action_subscript)
	.word	never_error -	10$	;8 operator node - named other
					;(named data changed to this type
					;later)
	.word	never_error -	10$	;9 operator node - pointer
					;(should have given syntax error)
	.word	never_error -	10$	;10 operator node - arguments
					;(oprscr changed to this type later)
	.word	never_error -	10$	;11 operator node - subscripts
					;(should have given syntax error)
	.word	100$	    -	10$	;12 operator node - left parenthesis
	.word	never_error -	10$	;13 operator node - continue
					;(should have given syntax error)
	.word	never_error -	10$	;14 pli value descriptor node
					;(should have given syntax error)
	.word	never_error -	10$	;15 debug special symbol node
					;(should have given syntax error)
	.word	never_error -	10$	;16 debug constant node
					;(should have given syntax error)
	.word	never_error -	10$	;17 oprnd -state = need more name
					;(should have given syntax error)
	.word	never_error -	10$	;18 oprscr - state = need more scr
	.word	never_error -	10$	;19 oprcon - state = need more operand
	brw	never_error		;node type code too high
;
;current node is head node
;
20$:					;head node
	pushl	ap_message_vect(ap)	;pass message vector
	pushal	new_node(fp)		;pointer to operator node
	pushl	#pli_node_opr$k_size+3/4 ;longwords needed by operator node
	calls	#3,dbg$nlist_freez	;get the storage
	blbs	r0,30$			;branch if ok
	ret				;
30$:	movl	new_node(fp),r8		;point to new node
	insque	(r8),(r9)		;insert new node
40$:	movl	#pli_node_type$k_oprlp,- ;operator node type is
		pli_node_type(r8)	;oprlp (left parenthesis)
	incl	pli_head_node_count(r10);number of nodes in tree
	movl	pli_head_node_count(r10),- ;this is the id for this new
		pli_node_ident(r8)	;node
	movw	result_vector+pli_tokr$l_0(fp),- ;get length of token
		pli_node$w_sl(r8)	;put in node
	movl	result_vector+pli_tokr$l_1(fp),- ;get address of token
		pli_node$a_str(r8)	;put in node
	clrl	pli_node_opr_subtype(r8);clear operator subtype
	clrl	pli_node_opr_arg_cur(r8) ;current number of arguments
	movl	#1,- 			;move in the minimum number of
		pli_node_opr_arg_min(r8) ;arguments allowed
	movl	#1,- 			;move in the maximum number of
		pli_node_opr_arg_max(r8) ;arguments allowed
	movl	r8,r9			;operator node is current node
	brw	p_loop			;go get next token
;
;operator node is current
;
100$:					;operator node is current node
	bsbw	pli_continue_operator	;continue the operator node if required
	movl	pli_node_opr_arg_cur(r9),r5 ;get current number of arguments
	addl2	r5,r5			;*2 for flink+blink
	incl	pli_node_opr_arg_cur(r9);increment current argument count
	pushl	ap_message_vect(ap)	;pass message vector
	pushal	pli_node_opr_sub_fl(r9)[r5] ;pointer to operator node
	pushl	#pli_node_opr$k_size+3/4 ;longwords needed by operator node
	calls	#3,dbg$nlist_freez	;get the storage
	blbs	r0,130$			;branch if ok
	ret				;
130$:	movl	pli_node_opr_sub_fl(r9)[r5],r8 ;point to new node
	movl	r8,pli_node_opr_sub_bl(r9)[r5] ;put in blink
	movl	r9,pli_node_flink(r8)	;flink for new node
	movl	r9,pli_node_blink(r8)	;blink for new node
	brw	40$			;merge with common code
	.subtitle	action ptr
action_err_ptr:				;
	movl	#pli$k_not_yet,r0	;
	brw	bug_check		;
	.subtitle	action err_fun
action_err_fun:				;
	movl	#pli$k_not_yet,r0	;
	brw	bug_check		;
	.subtitle	action err_mis_rp
action_err_mis_rp:			;
	movl	#pli$k_not_yet,r0	;
	brw	bug_check		;
	.subtitle	action err_var
action_err_var:				;
	movl	#pli$k_not_yet,r0	;
	brw	bug_check		;
	.subtitle	action dbg_line
;
;********************************
;*   action - dbg_line		*
;********************************
;
action_dbg_line:			;
	movl	#pli$k_not_yet,r0	;
	brw	bug_check		;
	.subtitle	action dbg_bs
;
;********************************
;*   action - dbg_bs		*
;********************************
;
action_dbg_bs:				;
	casel	pli_node_type(r9),#0,#19 ;node type case
10$:					;
	.word	never_error -	10$	;0 reserved
	.word	20$	    -	10$	;1 head node
	.word	never_error -	10$	;2 name node function
	.word	never_error -	10$	;3 name node data
	.word	never_error -	10$	;4 name node other (routine, module)
	.word	100$	    -	10$	;5 operator node - infix or prefix opr
	.word	100$	    -	10$	;6 operator node - named function
	.word	100$	    -	10$	;7 operator node - named data
	.word	100$	    -	10$	;8 operator node - named other
	.word	100$	    -	10$	;9 operator node - pointer
	.word	100$	    -	10$	;10 operator node - arguments
	.word	100$	    -	10$	;11 operator node - subscripts
	.word	100$	    -	10$	;12 operator node - left parenthesis
	.word	never_error -	10$	;13 operator node - continue
	.word	never_error -	10$	;14 pli value descriptor node
	.word	never_error -	10$	;15 debug special symbol node
	.word	never_error -	10$	;16 debug constant node
	.word	never_error -	10$	;17 oprnd -state = need more name
	.word	never_error -	10$	;18 oprscr - state = need more scr
	.word	never_error -	10$	;19 oprcon - state = need more operand
	brw	never_error		;node type code too high
;
;head node
;
20$:					;head node
	pushl	ap_message_vect(ap)	;pass message vector
	pushal	new_node(fp)		;pointer to pli vd node
	pushl	#pli_node_vd$k_size+3/4 ;longwords needed by pli vd node
	calls	#3,dbg$nlist_freez	;get the storage
	blbs	r0,30$			;branch if ok
	ret				;

30$:	movl	new_node(fp),r8		;point to new node
	insque	(r8),(r9)		;insert new node
40$:	movl	#pli_node_type$k_plivd,- ;node type is
		pli_node_type(r8)	;pli vd node
	incl	pli_head_node_count(r10);number of nodes in tree
	movl	pli_head_node_count(r10),- ;this is the id for this new
		pli_node_ident(r8)	;node
	movw	result_vector+pli_tokr$l_0(fp),- ;get length of token
		pli_node$w_sl(r8)	;put in node
	movl	result_vector+pli_tokr$l_1(fp),- ;get address of token
		pli_node$a_str(r8)	;put in node
	pushl	#0			;will hold pointer to last value
	pushl	ap_message_vect(ap)	;pass along the message vector
	pushal	4(sp)			;point to pointer longword
	calls	#2,dbg$nget_lastval	;get the last value descriptor
	blbs	r0,50$			;branch if ok
	ret				;
50$:	movl	(sp)+,r7		;point to old value descriptor
	movl	pli_vd$l_type(r7),pli_node_vd_stype(r8) ;secondary datatype
	movl	pli_vd$l_type(r7),pli_node_vd$l_type(r8) ;pli datatype code
	movl	pli_vd$l_size(r7),pli_node_vd_ssize(r8) ;secondary size
	movl	pli_vd$l_size(r7),pli_node_vd$l_size(r8) ;pli size code
	moval	pli_node_vd$a_data(r8),-;pointer to data pointer
		pli_node_vd$a_addr(r8)	;put in node
	movl	pli_vd$l_boff(r7),pli_node_vd$l_boff(r8) ;bit offset
	movl	pli_vd$a_ptr(r7),pli_node_vd$a_data(r8) ;point to data
	movl	r8,r9			;pli vd node is current node
	brw	p_loop			;go get next token
;
;operator node is current
;
100$:					;operator node is current node
	bsbw	pli_continue_operator	;continue operator node if necessary
	movl	pli_node_opr_arg_cur(r9),r5 ;get current number of arguments
	addl2	r5,r5			;*2 for flink+blink
	incl	pli_node_opr_arg_cur(r9);increment current argument count
	pushl	ap_message_vect(ap)	;pass message vector
	pushal	pli_node_opr_sub_fl(r9)[r5] ;pointer to pli vd node
	pushl	#pli_node_vd$k_size+3/4 ;longwords needed by pli vd node
	calls	#3,dbg$nlist_freez	;get the storage
	blbs	r0,130$			;branch if ok
	ret				;
130$:	movl	pli_node_opr_sub_fl(r9)[r5],r8 ;point to new node
	movl	r8,pli_node_opr_sub_bl(r9)[r5] ;put in blink
	movl	r9,pli_node_flink(r8)	;flink for new node
	movl	r9,pli_node_blink(r8)	;blink for new node
	brw	40$			;merge with common code
	.subtitle	action name_dot
;
;********************************
;*   action - name_dot		*
;********************************
;
action_name_dot:			;
	cmpl	#pli_node_type$k_oprnd,pli_node_type(r9) ;operator name data?
	bneq	20$			;branch if not
	movl	#pli_node_type$k_more_oprnd,pli_node_type(r9) ;change state
10$:	brw	p_loop			;go get next token
20$:	cmpl	#pli_node_type$k_oprcon,pli_node_type(r9) ;operator continue?
	bneq	100$			;branch if not
	movl	#pli_node_type$k_more_oprcon,pli_node_type(r9) ;change state
	brb	10$			;go get next token
100$:	brw	never_error		;should never happen
	.subtitle action_err_more_scr
;
;********************************
;*   action - err_more_scr	*
;********************************
;
action_err_more_scr:			;error - subscript required
	pushl	result_vector+pli_tokr$l_1(fp) ;address of token
	pushl	result_vector+pli_tokr$l_0(fp) ;length of token
	cmpb	#13,@4(sp)		;null argument
	bneq	10$			;branch if not null
	clrl	(sp)			;zero token length
10$:	pushl	#2			;two fao arguments
	pushl	#dbg$_reqsubs		;syntax requires subscript
	calls	#4,dbg$nmake_arg_vect	;make the message vector
	movl	r0,@ap_message_vect(ap)	;fill in message vector value
	brw	restore_severe		;severe error return (restore input
					;descriptor before ret
	.subtitle	action_err_more_operand
;
;********************************
;*   action - err_more_operand	*
;********************************
;
action_err_more_operand:		;
;*****temp for now, the only type of operand with more is a subscript
;when operators are supported, this code has to give appropriate
;message according to the type of operator the oprcon node refers
;to. this will be done by looking in subtype field
	brb	action_err_more_scr	;***temp
	.subtitle	action_need_scr_got_id
action_need_scr_got_id:			;
	movl	#pli_node_type$k_oprscr,pli_node_type(r9) ;convert more_oprscr
					;to oprscr node
	brw	action_first_id		;merge with common code
	.subtitle	action_need_scr_got_dbgc
action_need_scr_got_dbgc:		;
	movl	#pli_node_type$k_oprscr,pli_node_type(r9) ;convert more_oprscr
					;to oprscr node
	brw	action_dbgcon		;merge with common code
	.subtitle	action_need_scr_got_plic
action_need_scr_got_plic:		;
	movl	#pli_node_type$k_oprscr,pli_node_type(r9) ;convert more_oprscr
					;to oprscr node
	brw	action_plivd		;merge with common code
	.subtitle	action_need_scr_got_dbgr
action_need_scr_got_dbgr:		;
	movl	#pli_node_type$k_oprscr,pli_node_type(r9) ;convert more_oprscr
					;to oprscr node
	brw	action_dss		;merge with common code
	.subtitle	action_need_scr_got_bs
action_need_scr_got_bs:			;
	movl	#pli_node_type$k_oprscr,pli_node_type(r9) ;convert more_oprscr
					;to oprscr node
	brw	action_dbg_bs		;merge with common code
	.subtitle	action_need_scr_got_oper
action_need_scr_got_oper:		;
	movl	#pli_node_type$k_oprscr,pli_node_type(r9) ;convert to
					;oprscr node
	brw	action_prefix		;merge with common code
	.subtitle	action_need_scr_got_lpar
action_need_scr_got_lpar:		;
	movl	#pli_node_type$k_oprscr,pli_node_type(r9) ;convert to
					;oprscr node
	brw	action_push		;merge with common code
	.subtitle	action_need_operand_got_lpar
action_need_operand_got_lpar:		;
	movl	#pli_node_type$k_oprcon,pli_node_type(r9) ;convert to
					;operator continue node
	brw	action_push		;merge with common code
	.subtitle	action_need_operand_got_id
action_need_operand_got_id:		;
;***temp later add code when operators could result in this action
;being executed
	movl	#pli_node_type$k_oprscr,pli_node_type(r9) ;convert more_oprscr
					;to oprscr node
	brw	action_first_id		;merge with common code
	.subtitle	action_need_operand_got_dbgc
action_need_operand_got_dbgc:		;
;***temp later add code when operators could result in this action
;being executed
	movl	#pli_node_type$k_oprscr,pli_node_type(r9) ;convert more_oprscr
					;to oprscr node
	brw	action_dbgcon		;merge with common code
	.subtitle	action_need_operand_got_plic
action_need_operand_got_plic:		;
;***temp later add code when operators could result in this action
;being executed
	movl	#pli_node_type$k_oprscr,pli_node_type(r9) ;convert more_oprscr
					;to oprscr node
	brw	action_plivd		;merge with common code
	.subtitle	action_need_operand_got_dbgr
action_need_operand_got_dbgr:		;
;***temp later add code when operators could result in this action
;being executed
	movl	#pli_node_type$k_oprscr,pli_node_type(r9) ;convert more_oprscr
					;to oprscr node
	brw	action_dss		;merge with common code
	.subtitle	action_need_operand_got_bs
action_need_operand_got_bs:		;
;***temp later add code when operators could result in this action
;being executed
	movl	#pli_node_type$k_oprscr,pli_node_type(r9) ;convert more_oprscr
					;to oprscr node
	brw	action_dbg_bs		;merge with common code
	.subtitle	pli_hot_fixup
	.page
;
;********************************************************
;*							*
;*	pli_hot_fixup					*
;********************************************************
;
ap_tree_head	=	4		;address of head node
ap_message_vect	=	8		;message vector
	.entry pli_hot_fixup,0
	.if	defined	call_pli_print_tree
	pushal	ap_tree_head(ap)	;address of tree head
	calls	#1,pli_print_tree	;print tree if print_tree_switch = 1
	.endc
	pushl	ap_message_vect(ap)	;pass along message vector pointer
	pushal	g^pli_fix_name		;address of routine to process nodes
	pushl	ap_tree_head(ap)	;pass along tree head node address
	pushl	ap_tree_head(ap)	;start walk at head of tree
	calls	#4,pli_pre_order_opr_walk ;search for operator nodes in
	blbs	r0,10$			;pre_order. branch if ok
	ret				;
10$:					;name nodes have been fixed up
	.if	defined	call_pli_print_tree
	pushal	ap_tree_head(ap)	;address of tree head
	calls	#1,pli_print_tree	;print tree if print_tree_switch = 1
	.endc
	ret				;
	.subtitle pli_fix_name
	.page
;
;****************************************************************
;*								*
;*	pli_fix_name						*
;*								*
;****************************************************************
;
;this routine fixes up name nodes by doing the following
;	1) collect all the named nodes
;	2) build a new pathname descriptor for the (new) name node
;	3) get the symid and kind associated with this pathname
;	4) obtain a new (fully qualified) pathname (***temp***)
;	5) move subscript (or argument) nodes to first name node
;	6) if function, change oprnd and named nodes as appropriate
;
;	register	use
;	r11		operator node pointer
;
	.entry	pli_fix_name,^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>	
ap_node_ptr	=	4		;argument - points to node
ap_head_ptr	=	8		;argument - point to head node
ap_message_vect =	12		;argument - message vector
;
;local storage layout
;
new_pn		=	-4		;local storage - new pn vector
ascic_blk	=	-8		;local storage - block for ascic string
temp_size	=	-8		;size of local storage
	moval	temp_size(sp),sp	;make local storage
	movl	ap_node_ptr(ap),r11	;point to operator node	
	cmpl	#pli_node_type$k_oprnd,-;is the node a named operator
		pli_node_type(r11)	;node?
	beql	10$			;we branch if it is to process
	movl	#sts$k_success,r0	;otherwise we are all done
	ret				;
10$:					;we have an oprnd node
;
;	register	use
;	r10		current operator node pointer
;	r9		current argument
;	r8		;temporary
;	r7		current named node
;	r6		length sum in bytes
;	r5		total name count for pathname vector
;
	clrl	r6			;initialize length count
	clrl	r5			;total name count for pn vector
	movl	ap_node_ptr(ap),r10	;current operator is top level operator
20$:	movl	#1,r9			;start with first argument
30$:	movq	pli_node_opr_sub_fl-8(r10)[r9],r7 ;point to name node
	cmpl	#pli_node_type$k_named,pli_node_type(r7) ;make sure it is a
	bneq	100$			;name node data type node
	tstl	pli_node_nam_pn_ptr(r7)	;see if any pn vector present
	beql	80$			;branch if no pn vector
	movl	pli_node_nam_pn_ptr(r7),r3 ;point to pathname vector
	movzbl	pth$b_totcnt(r3),r2	;get totcnt from pathname vector
	addl2	r2,r5			;add to total name count
	brb	90$			;check for next argument
80$:	incl	r5			;add to total name count
	movzwl	pli_node$w_sl(r7),r8	;get length of name string
	incl	r8			;one byte for ascic count field
	addl2	r8,r6			;add in the count
90$:	incl	r9			;add to argument count value
	cmpl	r9,pli_node_opr_arg_cur(r10) ;compare with current arg count
	bleq	30$			;branch if more args
	brb	200$			;get some storage
100$:					;not a name node
	cmpl	#pli_node_type$k_oprcon,- ;continue node?
	pli_node_type(r7)		;(this is the only other legal kind)
	beql	110$			;branch if a continue node
	brw	never_error		;must be an error
110$:	movl	r7,r10			;operator continue becomes current opr
	brb	20$			;go count some more bytes
;
;get memory for the new ascic strings
;r6 contains number of bytes needed
;r5 holds total name count
;
200$:	tstl	r6			;any ascic strings to create?
	beql	210$			;branch if none needed
	addl2	#3,r6			;add round factor
	pushl	ap_message_vect(ap)	;pass message vector
	pushal	ascic_blk(fp)		;point to free storage pointer longword
	ashl	#-2,r6,-(sp)		;number of longwords needed
	calls	#3,dbg$nlist_freez	;get the storage
	blbs	r0,210$			;branch if ok
	ret				;
;
;get memory for the new "pathname descriptor"
;
;	register	use
;	r11		index into newly formed pn vector
;	r10		current operator node
;	r9		current argument
;	r8		temporary
;	r7		current name node
;	r3		ascic string index
;	r5		total name count
;
210$:					;
	pushl	ap_message_vect(ap)	;pass along message vector
	pushal	new_pn(fp)		;pointer to new free area
	addl3	#pth$a_pathvector+3/4,r5,-(sp) ;longwords of storage needed
	calls	#3,dbg$nlist_freez	;get the storage
	blbs	r0,220$			;branch if ok
	ret				;
220$:	movl	new_pn(fp),r0		;point to temorary storage
	movb	r5,pth$b_totcnt(r0)	;total count for pn vector
;
;go look at first name node
;
	movl	ap_node_ptr(ap),r10	;top most operator is current operator
	movl	#1,r9			;start with first argument
	movq	pli_node_opr_sub_fl-8(r10)[r9],r7 ;point to name node
	tstl	pli_node_nam_pn_ptr(r7)	;see if any pn vector present
	bneq	250$			;branch if pn vector
;
;no pn vector, input was like eval/addr x+1
;
	movl	r0,pli_node_nam_pn_ptr(r7) ;put in the pn vector we create
	moval	pth$a_pathvector(r0),r11 ;point to ascic pointer list start
	movb	#1,pth$b_pathcnt(r0)	;names before 1st dot
	movl	ascic_blk(fp),r3	;point to ascic block of free storage
	brb	280$			;go make the rest of the pn vector
;
;pn vector present
;
250$:	movl	pli_node_nam_pn_ptr(r7),r3 ;point to pathname vector
	movzbl	pth$b_totcnt(r3),r1	;get the total count of current pn vect
	movb	pth$b_pathcnt(r3),pth$b_pathcnt(r0) ;copy path count
	movw	pth$b_locinvoc(r3),pth$b_locinvoc(r0) ;locinvoc and unused byte
	movl	pth$l_invocnum(r3),pth$l_invocnum(r0) ;invocation number moved
	movl	r0,pli_node_nam_pn_ptr(r7) ;we have a new pathname vector
	moval	pth$a_pathvector(r3),r3	;point to name pointer in old pn vect
	moval 	pth$a_pathvector(r0),r0 ;point to name pointer in new pn vect
260$:	movl	(r3)+,(r0)+		;copy each pointer
	sobgtr	r1,260$			;copy all the pointers
	movl	r0,r11			;save pointer in newly formed pn vect
	movl	ascic_blk(fp),r3	;point to ascic storage
270$:					;
	incl	r9			;add to argument count value
280$:	cmpl	r9,pli_node_opr_arg_cur(r10) ;compare with current arg count
	bgtr	1000$			;branch if no more arguments
300$:	movq	pli_node_opr_sub_fl-8(r10)[r9],r7 ;point to name node
	cmpl	#pli_node_type$k_named,pli_node_type(r7) ;a name node?
	bneq	400$			;branch if not
	movzwl	pli_node$w_sl(r7),r8	;get length of name string
	movl	pli_node$a_str(r7),r1	;point to string start
	movl	r3,(r11)+		;string address into pn vect
	movb	r8,(r3)+		;string count
	movc3	r8,(r1),(r3)		;copy string
;
;call routine to collect all the subscripts
;
	pushl	ap_head_ptr(ap)		;pointer to head node
	pushl	r7			;pointer to current name node
	movl	ap_node_ptr(ap),r0	;point to oprnd node
	pushl	pli_node_opr_sub_fl(r0)	;first named node
	calls	#3,pli_collect_subscripts ;collect all the subscripts
	blbs	r0,270$			;branch if ok (look at next arg.)
	ret				;
;
;not a name node, process continue nodes here
;
400$:					;not a name node
	cmpl	#pli_node_type$k_oprcon,- ;continue node?
	pli_node_type(r7)		;(this is the only other legal kind)
	beql	410$			;branch if a continue node
	brw	never_error		;must be an error
410$:	movl	r7,r10			;operator continue becomes current opr
	movl	#1,r9			;look at first argument
	brb	300$			;go look at the name node
;
;get symid and kind code
;
1000$:	movl	ap_node_ptr(ap),r10	;point to first operator
	movl	#1,pli_node_opr_arg_cur(r10) ;only 1 argument now
	movl	pli_node_opr_sub_fl(r10),r9 ;point to name node
	pushal	pli_node_nam_kind(r9)	;longword for kind code
	pushal	pli_node_nam_symid(r9)	;longword for symid
	pushl	pli_node_nam_pn_ptr(r9)	;pointer to "pathname" vector
	calls	#3,dbg$sta_getsymbol	;get symid and kind code
	casel	pli_node_nam_kind(r9),#rst$k_kind_minimum,-;
		#rst$k_kind_maximum-rst$k_kind_minimum	;
1100$:
	.repeat	<rst$k_kind_maximum - rst$k_kind_minimum + 1>
	.word	1200$	- 1100$
	.endr
.=1100$ + <2 * <rst$k_invalid-rst$k_kind_minimum>>
	.word	1250$ - 1100$		;invalid 0 (symbol not found)
.=1100$ + <2 * <rst$k_module-rst$k_kind_minimum>>
	.word	1400$ - 1100$		;module 1
.=1100$ + <2 * <rst$k_routine-rst$k_kind_minimum>>
	.word	1400$ - 1100$		;routine 2
.=1100$ + <2 * <rst$k_block-rst$k_kind_minimum>>
	.word	1400$ - 1100$		;block	3
.=1100$ + <2 * <rst$k_label-rst$k_kind_minimum>>
	.word	1400$ - 1100$		;label	4
.=1100$ + <2 * <rst$k_line-rst$k_kind_minimum>>
	.word	1400$ - 1100$		;line	5
.=1100$ + <2 * <rst$k_data-rst$k_kind_minimum>>
	.word	2000$ - 1100$		;data	6
.=1100$ + <2 * <rst$k_type-rst$k_kind_minimum>>
	.word	1200$ - 1100$		;type	7
.=1100$ + <2 * <rst$k_entry-rst$k_kind_minimum>>
	.word	1400$	- 1100$		;entry	8
.=1100$ + <2 * <rst$k_notunique-rst$k_kind_minimum>>
	.word	1300$	- 1100$		;not unique name in symbol table 9
.=1100$ + <2 * <rst$k_typcomp-rst$k_kind_minimum>>
	.word	1200$	- 1100$		;type component 10
.=1100$ + <2 * <rst$k_variant-rst$k_kind_minimum>>
	.word	1200$	- 1100$		;variant	11
.=1100$ + <2 * <rst$k_invocnum-rst$k_kind_minimum>>
	.word	1200$	- 1100$		;invocation number rst entry???
.=1100$ + <2 * <rst$k_kind_maximum-rst$k_kind_minimum+1>> ;reset location
					;counter past case
;******** temp
;	movl	#pli$k_kind,r0	;invalid rst kind code value
;	brw	bug_check	;go signal error

;
; invalid kind
;
1200$:					;
	pushal	-(sp)			;point to cs pointer (ptr allocated)
	pushl	pli_node_nam_pn_ptr(r9)	;pointer to "pathname" vector
	calls   #2,pli_pn_to_cs  	;convert to counted string
	pushal  msg_pli                 ;push the "PLI" string address
	pushl   4(sp)                   ;point to reference (a string)
	pushl   #2                      ;2 fao arguments
	pushl   #dbg$_unknowntyp        ;type is not known to pli
	calls   #4,dbg$nmake_arg_vect   ;make the message vector
	brb	1211$			;merge with common code
1210$:	calls	#3,dbg$nmake_arg_vect	;make the message vector
1211$:	movl	r0,@ap_message_vect(ap) ;pass it as return code
	movl	#sts$k_severe,r0	;severe error
	ret				;	
;
;symbol not found
;
1250$:	pushal	-(sp)			;cs pointer
	pushl	pli_node_nam_pn_ptr(r9)	;pointer to "pathname" vector
	calls	#2,pli_pn_to_cs		;convert to counted string
	pushl	#1			;1 fao argument (already on stack)
	pushl	#dbg$_nosymbol		;symbol not in symbol table
	brb	1210$			;merge with common code
;
; symbol not unique
;
1300$:					;
	pushal	-(sp)			;cs pointer
	pushl	pli_node_nam_pn_ptr(r9)	;pointer to "pathname" vector
	calls	#2,pli_pn_to_cs		;convert to counted string
	pushl	#1			;1 fao arguments (already on stack)
	pushl	#dbg$_nounique		;symbol is not unique
	brb	1210$			;merge with common code
;
; routine, line, block, label, entry
;
1400$:	movl	#pli_node_type$k_oprno,pli_node_type(r10) ;convert operator
					;to name other operator
	movl	#pli_node_type$k_nameo,pli_node_type(r9) ;convert name node to
					;name node other
	brb	2000$			;successful return
;
; data
;
2000$:				;
	movl	#sts$k_success,r0	;successfull return
	ret				;	
9999$:	movl	#pli$k_not_yet,r0	;
	brw	bug_check
	.subtitle	pli_collect_subscript
	.page
;
;********************************************************
;*							*
;*							*
;*	pli_collect_subscripts				*
;*							*
;*							*
;********************************************************
;
;	register	use
;	r11		points to first name node
;	r10		points to name node holding subscripts to move
;	r9		rightmost subscript operator (or continue) of
;			first name node
;	r8		subscript node of subtree to move
;	r7		points to continue node during continue creation
;
ap_first_named	=	4		;first named node address
ap_current_name_node =	8		;current name node(possible subscripts)
ap_head_ptr	=	12		;pointer to head node
	.entry	pli_collect_subscripts,^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>
	movl	ap_first_named(ap),r11	;point to first named node
	movl	ap_current_name_node(ap),r10 ;point to current name_node
	cmpl	r10,r11			;same node?
	beql	90$			;branch if same node (successful ret)
;
;see if there are any new subscripts in the current name node
;
	movl	pli_node_nam_arg_fl(r10),r8 ;any subscripts?
	beql	90$			;branch if no subscripts
;
;find the "rightmost subscript operator"
;
	movl	pli_node_nam_arg_fl(r11),r9 ;point to possible oprscr
	bneq	100$			;branch if at least one subscript
;
;first name node has no subscripts but one of the following nodes does
;
	movl	r8,pli_node_nam_arg_fl(r11) ;flink to new subscripts
	movl	r8,pli_node_nam_arg_bl(r11) ;blink to new subscripts
	movl	r11,pli_node_flink(r8)	;subscript node flink to name node
	movl	r11,pli_node_blink(r8)	;subscript node blink to name node
90$:	brw	10000$			;successful return
;
;first name already has an oprscr node
;
100$:	movl	pli_node_opr_arg_cur(r9),r5 ;current number of arguments
	addl2	r5,r5			;*2 for flink+blink
	movl	pli_node_opr_sub_fl-8(r9)[r5],r0 ;point to last argument
	cmpl	#pli_node_type$k_oprcon,pli_node_type(r0) ;continue node?
	bneq	200$			;branch if the "rightmost operator"
	movl	r0,r9			;point to operator continue node
	brb	100$			;go see if this is the "last" one
200$:					;
	movl	pli_node_opr_arg_cur(r9),r0 ;get cur number of arguments
;
;***warning*** code assumes that we can always create more subscript
;continue nodes, so pli_node_opr_arg_max is not checked
;
	cmpl	r0,#pli_node_opr$k_max_arg ;maximum arguments allowed for node?
	blss	300$			;branch if we can add to this node
;
;we need to make a new continue node
;
	pushl	#0			;will hold pointer to new oprcon
	pushl	ap_message_vect(ap)	;pass along message vector
	pushal	4(sp)			;pointer to pointer to oprcon
	pushl	#pli_node_opr$k_size+3/4 ;number of longwords for continue node
	calls	#3,dbg$nlist_freez	;get the number of bytes
	blbs	r0,220$			;branch if ok
	ret				;
220$:	movl	(sp)+,r7		;address of continue node
	movl	pli_node_opr_arg_cur(r9),r4 ;current number of arguments
	movl	#pli_node_type$k_oprcon,- ;node type is
		pli_node_type(r7)	;continue node
	movl	ap_head_ptr(ap),r0	;point to head node
	incl	pli_head_node_count(r0)	;number of nodes in tree
	movl	pli_head_node_count(r0),- ;this count is the id for the
		pli_node_ident(r7)	;new node
	movw	pli_node$w_sl(r9),pli_node$w_sl(r7) ;copy string length
	movl	pli_node$a_str(r9),pli_node$a_str(r7) ;copy address of string
	movl	#1,pli_node_opr_arg_cur(r7) ;we will have one argument soon
	movl	#pli_node_opr$k_min_arg,- ;move in the minimum number of
		pli_node_opr_arg_min(r7) ;arguments allowed
	subl3	r4,-			;calculate the maximum number of
		pli_node_opr_arg_max(r9),- ;arguments allowed in the next
		pli_node_opr_arg_max(r7);node
	movl	pli_node_opr_subtype(r9),- ;copy the parent's subtype code
		pli_node_opr_subtype(r7);to the continue node
	movaq	pli_node_opr_sub_fl-8(r9)[r4],r0 ;point to the last argument
	movq	(r0),r5			;hold old last argument node
	movq	r5,pli_node_opr_sub_fl(r7) ;old last argument is the first
					;argument of the new node
	movl	r7,pli_node_flink(r6)	;old last arg. gets new flink
	movl	r7,pli_node_blink(r5)	;old last arg. gets new blink
	movl	r7,(r0)			;old flink pts to new node
	movl	r7,4(r0)		;old blink pts to new node
	movl	r9,pli_node_flink(r7)	;new nodes flink pts to old node
	movl	r9,pli_node_blink(r7)	;new nodes blink pts to old node
	movl	r7,r9			;continue node is current node
;
;subscript operator node (or continue) pointed to be r9 has
;room for another argument
;
300$:					;
	cmpl	#1,pli_node_opr_arg_cur(r8) ;only one subscript to move?
	bneq	400$			;branch if more than one
	movl	pli_node_opr_sub_fl(r8),r7 ;point to single subscript
310$:	movl	r9,pli_node_flink(r7)	;flink of new subscript
	movl	r9,pli_node_blink(r7)	;blink of new subscript
	movl	pli_node_opr_arg_cur(r9),r5 ;number of argument 
	incl	pli_node_opr_arg_cur(r9) ;we are adding another argument
	addl2	r5,r5			;*2 for flink+blink
	movl	r7,pli_node_opr_sub_fl(r9)[r5] ;new argument flink
	movl	r7,pli_node_opr_sub_bl(r9)[r5] ;new argument blink
	brb	10000$			;successful return
400$:	movl	#pli_node_type$k_oprcon,pli_node_type(r8) ;change to continue
					;node
	movl	r8,r7			;merge setup
	brb	310$			;merge with common link code
;
;success exit code
;
10000$:	movl	#sts$k_success,r0	;successful return
	ret				;
	.subtitle	pli_pre_order_opr_walk
	.page
;
;********************************************************
;*							*
;*	pli_pre_order_opr_walk				*
;*							*
;* searches the tree in pre_order, calling the specified*
;* routine whenever an operator node is encountered.	*
;* The action routine is passed a pointer to the	*
;* operator node, the head node, and a message vector.	*
;* The action routine is allowed to modify the tree	*
;* (below) the  pointed to operator node.		*
;*							*
;********************************************************
;
;	register	use
;
;
ap_node_ptr	=	4		;address of head node of tree
					;or any node of tree
ap_head_ptr	=	8		;head node of tree
ap_action	=	12		;entry point of action routine to call
ap_message_vect	=	16		;message vector to pass to action
					;routine
	.entry	pli_pre_order_opr_walk,^m<r2,r3,r4,r5,r6,r7,r8>
	movl	ap_node_ptr(ap),r6	;point to the node in question
	casel	pli_node_type(r6),#0,#19 ;node type case
10$:					;
	.word	never_error -	10$	;0 reserved
	.word	20$	-	10$	;1 head node
	.word	200$	-	10$	;2 name node function
	.word	200$	-	10$	;3 name node data
	.word	200$	-	10$	;4 name node other (routine, module)
	.word	100$	-	10$	;5 operator node - infix or prefix opr
	.word	100$	-	10$	;6 operator node - named function
	.word	100$	-	10$	;7 operator node - named data
	.word	100$	-	10$	;8 operator node - named other
	.word	100$	-	10$	;9 operator node - pointer
	.word	100$	-	10$	;10 operator node - arguments
	.word	100$	-	10$	;11 operator node - subscripts
	.word	100$	-	10$	;12 operator node - left parenthesis
	.word	100$ 	-	10$	;13 operator node - continue
	.word	999$ 	-	10$	;14 pli value descriptor node
	.word	999$ 	-	10$	;15 debug special symbol node
	.word	999$ 	-	10$	;16 debug constant node
;***later check for illegal tree states like the following?
	.word	100$ 	-	10$	;17 oprnd -state = need more name
	.word	100$    -	10$	;18 oprscr - state = need more scr
	.word	100$    -	10$	;19 oprcon - state = need more operand
	brw	never_error		;node type code too high
20$:					;head node
	cmpl	r6,pli_node_flink(r6)	;only a head node?
	bneq	30$			;branch if more to the tree
	movl	#sts$k_success,r0	;successfull return
	ret				;
30$:	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	ap_action(ap)		;pass along action routine
	pushl	ap_head_ptr(ap)		;pass along head node address
	pushl	pli_node_flink(r6)	;point to next node in tree
	calls	#4,pli_pre_order_opr_walk ;recur
	ret				;
100$:					;operator node encountered
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	ap_head_ptr(ap)		;pass along head node pointer
	pushl	r6			;point to the operator node
	calls	#3,@ap_action(ap)	;call the action routine
	blbs	r0,110$			;branch if ok
	ret				;
110$:	movl	#1,r3			;argument counter
130$:	cmpl	r3,pli_node_opr_arg_cur(r6) ;last argument?
	bgtr	999$			;branch if no more
	movq	pli_node_opr_sub_fl-8(r6)[r3],r4 ;point to next argument node
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	ap_action(ap)		;pass along action routine
	pushl	ap_head_ptr(ap)		;pass along head node address
	pushl	r4			;point to next node in tree
	calls	#4,pli_pre_order_opr_walk	;recur
	blbs	r0,140$			;branch if ok
	ret				;
140$:	incl	r3			;next argument
	brb	130$			;see if no more
;
;name node encountered
;
200$:					;
	movl	pli_node_nam_arg_fl(r6),r4 ;any arguments or subscripts?
	beql	999$			;branch if none
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	ap_action(ap)		;pass along action routine
	pushl	ap_head_ptr(ap)		;pass along head node address
	pushl	r4			;point to next node in tree
	calls	#4,pli_pre_order_opr_walk ;recur
	blbs	r0,999$			;branch if ok
	ret				;
999$:					;return immediately
	movl	#sts$k_success,r0	;successful return
	ret				;
	.subtitle	pli_pre_order_name_walk
	.page
;
;********************************************************
;*							*
;*	pli_pre_order_name_walk				*
;*							*
;* searches the tree in pre_order, calling the specified*
;* routine whenever a name node is encountered.		*
;* A specified routine is called with a specified	*
;* parameter as well as the address of the name node	*
;*							*
;********************************************************
;
;	register	use
;
;
ap_node_ptr	=	4		;address of head node of tree
					;or any node of tree
ap_action	=	8		;entry point of action routine to call
ap_parameter	=	12		;parameter to pas to action routine
ap_message_vect	=	16		;message vector to pass to action
					;routine
	.entry	pli_pre_order_name_walk,^m<r2,r3,r4,r5,r6,r7,r8>
	movl	ap_node_ptr(ap),r6	;point to the node in question
	casel	pli_node_type(r6),#0,#19 ;node type case
10$:					;
	.word	never_error -	10$	;0 reserved
	.word	20$	-	10$	;1 head node
	.word	100$	-	10$	;2 name node function
	.word	100$	-	10$	;3 name node data
	.word	100$	-	10$	;4 name node other (routine, module)
	.word	200$	-	10$	;5 operator node - infix or prefix opr
	.word	200$	-	10$	;6 operator node - named function
	.word	200$	-	10$	;7 operator node - named data
	.word	200$	-	10$	;8 operator node - named other
	.word	200$	-	10$	;9 operator node - pointer
	.word	200$	-	10$	;10 operator node - arguments
	.word	200$	-	10$	;11 operator node - subscripts
	.word	200$	-	10$	;12 operator node - left parenthesis
	.word	200$ 	-	10$	;13 operator node - continue
	.word	999$ 	-	10$	;14 pli value descriptor node
	.word	999$ 	-	10$	;15 debug special symbol node
	.word	999$ 	-	10$	;16 debug constant node
;***later add code to detect invalid tree for the following nodes (?)
	.word	never_error -	10$	;17 oprnd -state = need more name
	.word	never_error -	10$	;18 oprscr - state = need more scr
	.word	never_error -	10$	;19 oprcon - state = need more operand
	brw	never_error		;node type code too high
20$:					;head node
	cmpl	r6,pli_node_flink(r6)	;only a head node?
	bneq	30$			;branch if more to the tree
	movl	#sts$k_success,r0	;successfull return
	ret				;
30$:	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	ap_parameter(ap)	;pass along parameter
	pushl	ap_action(ap)		;pass along action routine
	pushl	pli_node_flink(r6)	;point to next node in tree
	calls	#4,pli_pre_order_name_walk ;recur
	ret				;
100$:					;name node data encountered
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	ap_parameter(ap)	;pass along parameter
	pushl	r6			;point to the name node
	calls	#3,@ap_action(ap)	;call the action routine
	blbs	r0,130$			;branch if ok
	ret				;
130$:	movl	pli_node_nam_arg_fl(r6),r4 ;point to possible arg. or subscript
	beql	999$			;successful return if none
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	ap_parameter(ap)	;pass along parameter
	pushl	ap_action(ap)		;pass along action routine
	pushl	r4			;point to next node in tree
	calls	#4,pli_pre_order_name_walk ;recur
	ret				;
200$:					;operator node encountered
	movl	#1,r3			;argument counter
230$:	cmpl	r3,pli_node_opr_arg_cur(r6) ;last argument?
	bgtr	999$			;branch if no more
	movq	pli_node_opr_sub_fl-8(r6)[r3],r4 ;point to next argument node
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	ap_parameter(ap)	;pass along the parameter
	pushl	ap_action(ap)		;pass along action routine
	pushl	r4			;point to next node in tree
	calls	#4,pli_pre_order_name_walk ;recur
	blbs	r0,240$			;branch if ok
	ret				;
240$:	incl	r3			;next argument
	brb	230$			;see if no more
999$:					;return immediately
	movl	#sts$k_success,r0	;successful return
	ret				;
	.subtitle	pli_pre_order_top_name_walk
	.page
;
;********************************************************
;*							*
;*	pli_pre_order_top_name_walk			*
;*							*
;* searches the tree in pre_order, calling the specified*
;* routine whenever a top level node of type name	*
;* is encountered.					*
;*							*
;********************************************************
;
;	register	use
;
;
ap_node_ptr	=	4		;address of head node of tree
					;or any node of tree
ap_head_node	=	8		;head node of tree
ap_action	=	12		;entry point of action routine to call
ap_message_vect	=	16		;message vector to pass to action
					;routine
	.entry	pli_pre_order_top_name_walk,^m<r2,r3,r4,r5,r6,r7,r8>
	movl	ap_node_ptr(ap),r6	;point to the node in question
	casel	pli_node_type(r6),#0,#19 ;node type case
10$:					;
	.word	never_error -	10$	;0 reserved
	.word	20$	-	10$	;1 head node
	.word	100$	-	10$	;2 name node function
	.word	100$	-	10$	;3 name node data
	.word	100$	-	10$	;4 name node other (routine, module)
	.word	200$	-	10$	;5 operator node - infix or prefix opr
	.word	200$	-	10$	;6 operator node - named function
	.word	200$	-	10$	;7 operator node - named data
	.word	200$	-	10$	;8 operator node - named other
	.word	200$	-	10$	;9 operator node - pointer
	.word	200$	-	10$	;10 operator node - arguments
	.word	200$	-	10$	;11 operator node - subscripts
	.word	200$	-	10$	;12 operator node - left parenthesis
	.word	200$ 	-	10$	;13 operator node - continue
	.word	999$ 	-	10$	;14 pli value descriptor node
	.word	999$ 	-	10$	;15 debug special symbol node
	.word	999$ 	-	10$	;16 debug constant node
;***later add code to report error if tree inconsistent (has the following
;	nodes in it?
	.word	never_error -	10$	;17 oprnd -state = need more name
	.word	never_error -	10$	;18 oprscr - state = need more scr
	.word	never_error -	10$	;19 oprcon - state = need more operand
	brw	never_error		;node type code too high
20$:					;head node
	cmpl	r6,pli_node_flink(r6)	;only a head node?
	bneq	30$			;branch if more to the tree
	movl	#sts$k_success,r0	;successfull return
	ret				;
30$:	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	ap_action(ap)		;pass along action routine
	pushl	ap_head_node(ap)	;pass along tree head node
	pushl	pli_node_flink(r6)	;point to next node in tree
	calls	#4,pli_pre_order_top_name_walk ;recur
	ret				;
100$:					;name node data encountered
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	ap_head_node(ap)	;pass along tree head node
	pushl	r6			;point to the operator node
	calls	#3,@ap_action(ap)	;call the action routine
	ret				;use actions return code
200$:					;operator node encountered
	movl	#1,r3			;argument counter
230$:	cmpl	r3,pli_node_opr_arg_cur(r6) ;last argument?
	bgtr	999$			;branch if no more
	movq	pli_node_opr_sub_fl-8(r6)[r3],r4 ;point to next argument node
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	ap_action(ap)		;pass along action routine
	pushl	ap_head_node(ap)	;pass along tree head node address
	pushl	r4			;point to next node in tree
	calls	#4,pli_pre_order_top_name_walk ;recur
	blbs	r0,240$			;branch if ok
	ret				;
240$:	incl	r3			;next argument
	brb	230$			;see if no more
999$:					;return immediately
	movl	#sts$k_success,r0	;successful return
	ret				;
	.subtitle pli_cool_tree
	.page
;
; ***********************************************************************
; *									*
; *	pli_cool_tree							*
; *									*
; ***********************************************************************
;
	.entry pli_cool_tree,0
;
; the hot tree is cooled:
;	1) For each name node with kind code = data:
;		a) structure descriptor created
;		b) vd template created
;		c) unrelocated stride descriptors created
;	2) All subscripts are evaluated
;	3) For each name node with kind code = data
;		a) strides are relocated using structure descriptors
;		b) VD template data pointer updated using strides
;
;
ap_subtree_ptr	=	4
ap_tree_head	=	8
ap_message_vect	=	12
	pushl	ap_message_vect(ap)	;pass along message vector pointer
	pushal	g^pli_cool_name		;address of routine to process nodes
	pushl	ap_tree_head(ap)	;pass along tree head node address
	pushl	ap_subtree_ptr(ap)	;start search at this node
	calls	#4,pli_pre_order_top_name_walk ;walk tree looking at top level nd
					;nodes
	blbs	r0,10$			;pre_order. branch if ok
	ret				;
10$:	pushl	ap_message_vect(ap)	;pass along message vector pointer
	pushal	g^pli_top_nd_sub_eval		;evaluate subscripts on top level
	pushl	ap_tree_head(ap)	;pass along tree head node address
	pushl	ap_subtree_ptr(ap)	;start search at this node
	calls	#4,pli_pre_order_top_name_walk ;walk tree looking at top level nd
					;nodes
	blbs	r0,50$			;branch if ok
	ret				;
50$:	pushl	ap_message_vect(ap)	;pass along message vector pointer
	pushal	g^pli_fix_stride_and_vd	;fix stride list and vd template
	pushl	ap_tree_head(ap)	;pass along tree head node address
	pushl	ap_subtree_ptr(ap)	;start search at this node
	calls	#4,pli_pre_order_top_name_walk ;walk tree looking at top level nd
					;nodes
	blbs	r0,100$			;branch if ok
	ret				;
100$:	
	ret				;
	.subtitle	pli_cool_name
	.page
;
; ***********************************************************************
; *									*
; *	pli_cool_name							*
; *									*
; ***********************************************************************
;
;
;	register	use
;	r7		name node pointer
;
	.entry	pli_cool_name,^m<r2,r3,r4,r5,r6,r7,r8>
ap_node		=	4		;argument - points to name node
ap_head_ptr	=	8		;argument - point to head node
ap_message_vect =	12		;argument - message vector
	movl	ap_node(ap),r7		;point to name node
	cmpl	#pli_node_type$k_named,-;is the node a name node
		pli_node_type(r7)	;data?
	beql	10$			;we branch if it is to process
	cmpl	#pli_node_type$k_nameo,-;is the node a name node
		pli_node_type(r7)	;other?
	beql	100$			;go proccess name node other operator
	brb	50$			;successful return common code
10$:					;we have an nameo node
;
; name node data only
;
;	register	use
;	r8		temporary
;	r7		current named node
;
	cmpl	#rst$k_data,pli_node_nam_kind(r7) ;kind code of data?
	bneq	50$			;skip node if not data
	pushl	pli_node_nam_symid(r7)	;push symid
	calls	#1,dbg$sta_setcontext	;set the context
	bsbw	create_structure	;create structure descriptors
	bsbw	create_vd		;create the value descriptor template
	bsbw	create_strides		;create unrelocated strides
50$:					;successful return entry point
	movl	#sts$k_success,r0	;successful return
	ret				;
100$:					;
;
;proccess name node other operator node
;
;
;	register	use
;	r8		temporary
;	r7		current name node other node
;
	movl	pli_node_nam_symid(r7),r5 ;save the symid
	pushl	r5			;push symid
	calls	#1,dbg$sta_setcontext	;set the context
;
;get memory for structure descriptor block 1
;
	pushl	ap_message_vect(ap)	;pass along message vector
	pushal	pli_node_nam_desc_ptr(r7) ;point to memory block
	pushl	#pli_struct_desc$k_size+3/4 ;number of longwords needed
	calls	#3,dbg$nlist_freez	;get the storage
	blbs	r0,140$			;branch if ok
	ret				;if error, exit called routine
140$:	movl	pli_node_nam_desc_ptr(r7),r6 ;point to structure block
	movl	pli_node_nam_symid(r7),r5 ;copy the symid from name node proper
	movl	r5,pli_struct_desc_symid(r6) ;to structure block
	movl	pli_node_nam_kind(r7),-	;copy the kind code from name node
		pli_struct_desc_kind(r6);proper to the structure block
;
;note, these are special structure descriptors with
;no value for typeid or fcode
;
	pushal	pli_struct_desc_valkind(r6) ;valkind longword
	pushal	pli_struct_desc$l_byte(r6) ;byte,bit,fp longword vector
	pushl	r5			;symid
	calls	#3,dbg$sta_symvalue	;call symvalue
;
;create value descriptor for name node other
;
	pushl	ap_message_vect(ap)	;pass along message vector
	pushal	pli_node_nam_vd_ptr(r7) ;point to memory block
	pushl	#pli_vd$k_size+3/4 	;number of longwords needed
	calls	#3,dbg$nlist_freez	;get the storage
	blbs	r0,150$			;branch if ok
	ret				;
150$:	movl	pli_node_nam_vd_ptr(r7),r8 ;point to value descriptor
	movl	pli_struct_desc$l_byte(r6),pli_vd$a_ptr(r8) ;value of nameo 
	brw	50$			;
	.page
;
;********************************************************
;*	create structure descriptors			*
;********************************************************
;
create_structure:			;create structure descriptors
;
;assumes context has been set
;	For the name data node pointed to by r7:
;		1. create structure descriptor for each part of the
;		   full name of the structure
;		2. for each structure descriptor copy or get symid
;		3. for each structure descriptor copy or get kind code
;		4. for each structure descriptor get fcode
;		5. for each structure descriptor get typeid
;		6. if appropriate, for each structure descriptor,
;		   call symvalue to get:
;		   valkind
;		   byte
;		   bit
;		   fp
;		7. for each structure descriptor, build optional
;		   type block if necessary
;
;	r8		temporary
;	r7		current named node
;
;get memory for structure descriptor block 1
;
	pushl	ap_message_vect(ap)	;pass along message vector
	pushal	pli_node_nam_desc_ptr(r7) ;point to memory block
	pushl	#pli_struct_desc$k_size+3/4 ;number of longwords needed
	calls	#3,dbg$nlist_freez	;get the storage
	blbs	r0,10$			;branch if ok
	ret				;if error, exit called routine
10$:	movl	pli_node_nam_desc_ptr(r7),r6 ;point to structure block
	movl	pli_node_nam_symid(r7),r5;copy the symid from name node proper
	movl	r5,pli_struct_desc_symid(r6) ;to structure block
	movl	pli_node_nam_kind(r7),-	;copy the kind code from name node
		pli_struct_desc_kind(r6);proper to the structure block
20$:					;
	pushal	pli_struct_desc_typeid(r6);type id
	pushal	pli_struct_desc_fcode(r6);fcode
	pushl	r5			;symid
	calls	#3,dbg$sta_symtype	;get fcode and type id
;
;call routine to put in structure descriptor optional type block
; (if not required, no update of pointer is made so it stays with value = 0)
;
	pushl	ap_message_vect(ap)	;pass along message vector
	pushal	pli_struct_desc$a_opt(r6) ;pointer to optional type block
	pushl	pli_struct_desc_typeid(r6) ;type id
	pushal	pli_struct_desc_fcode(r6) ;fcode
	pushl	r5			;symid
	calls	#5,pli_create_type_block ;create the optional type block
	blbs	r0,30$			;branch if ok
	ret				;
30$:	pushl	r5			;push the current element's symid
	calls	#1,dbg$sta_symparent	;see if there are any parents
	movl	r0,r4			;save the return value
	beql	100$			;branch if no parents
;
;we have a parent, so always call symvalue
;
	pushal	pli_struct_desc_valkind(r6) ;valkind longword
	pushal	pli_struct_desc$l_byte(r6) ;byte,bit,fp longword vector
	pushl	r5			;symid
	calls	#3,dbg$sta_symvalue	;call symvalue
	movl	r4,r5			;use parent as new structure element
	pushl	ap_message_vect(ap)	;pass along message vector
	pushal	pli_struct_desc_flink(r6) ;point to memory block
	pushl	#pli_struct_desc$k_size+3/4 ;number of longwords needed
	calls	#3,dbg$nlist_freez	;get the storage
	blbs	r0,50$			;branch if ok
	ret				;if error, exit called routine
50$:	movl	pli_struct_desc_flink(r6),r6 ;point to the new desc. block
	movl	r5,pli_struct_desc_symid(r6) ;symid into desc. block
	pushal	pli_struct_desc_kind(r6);kind code
	pushl	r5			;symid
	calls	#2,dbg$sta_symkind	;get the kind code
	brb	20$			;treat like any other desc. block
90$:	movl	pli_node_blink(r1),r1	;find parent of continue node
	brb	101$			;see if that is also a continue node
;
;no parent
;
;determine if we call symvalue
100$:	movl	pli_node_blink(r7),r1	;look at operator node
101$:	cmpl	#pli_node_type$k_oprcon,pli_node_type(r1) ;operator continue?
	beql	90$			;if so, branch to skip it
	movl	pli_node_blink(r1),r0	;look at previous operator
	cmpl	#pli_node_type$k_oprptr,pli_node_type(r0) ;is previous node a
	bneq	150$			;pointer? branch if not
	cmpl	r1,pli_node_opr_sub_fl+8(r0) ;right operand of a pointer?
	bneq	150$			;branch if not
;
;we are right operand of a pointer so don't call symvalue
;
	rsb
;
;we are not a right operand, so call symvalue the final time
;
150$:	pushal	pli_struct_desc_valkind(r6) ;valkind longword
	pushal	pli_struct_desc$l_byte(r6) ;byte,bit,fp longword vector
	pushl	r5			;symid
	calls	#3,dbg$sta_symvalue	;call symvalue
	rsb
	.page
;
;********************************************************
;*	create_vd					*
;********************************************************
;
;create vd template
;assumes that the name node structure block has be created
;
create_vd:				;
;
;	r8		temporary
;	r7		current named node
;
	pushl	ap_message_vect(ap)	;pass along message vector
	pushal	pli_node_nam_vd_ptr(r7) ;pointer to vd
	pushl	#pli_vd$k_size+3/4	;size of value descriptor
	calls	#3,dbg$nlist_freez	;get the storage
	blbs	r0,10$			;branch if ok
	ret				;
10$:	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	pli_node_nam_vd_ptr(r7)	;address of vd
	movl	pli_node_nam_desc_ptr(r7),r0 ;point to 1st descriptor block
	pushl	pli_struct_desc$a_opt(r0) ;structure desc. optional type block
	pushl	pli_struct_desc_typeid(r0) ;type id
	pushl	pli_struct_desc_fcode(r0) ;fcode
	pushl	pli_struct_desc_symid(r0) ;symid
	calls	#6,pli_get_datatype	;get the pli_data_type, size, bit off.
	blbc	r0,20$			;branch if error
	rsb				;
20$:	ret				;error return
	.page
;
;********************************************************
;	create_strides					*
;********************************************************
;
;
;	r8		temporary
;	r7		current named node
;
create_strides:				;
	pushl	ap_message_vect(ap)	;pass along message vector
	pushal	pli_node_nam_sd1_ptr(r7);address of stride pointer
	movl	pli_node_nam_desc_ptr(r7),r0 ;point to 1st descriptor block
	pushl	#0			;stride class 0 (current data length,
					;no control, start address is data)
	pushl	pli_struct_desc$a_opt(r0) ;pointer to optional type block
	pushl	pli_struct_desc_typeid(r0) ;type id
	pushl	pli_struct_desc_fcode(r0) ;fcode
	pushl	pli_struct_desc_symid(r0) ;symid
	calls	#7,pli_make_strides	;get the unrelocated stride list
	blbs	r0,20$			;branch if ok
	ret				;error return
20$:	pushl	ap_message_vect(ap)	;pass along message vector
	pushal	pli_node_nam_sd2_ptr(r7);address of stride pointer
	movl	pli_node_nam_desc_ptr(r7),r0 ;point to 1st descriptor block
	pushl	#7			;stride class (maximum data length plus
					;control, start address is control)
	pushl	pli_struct_desc$a_opt(r0) ;pointer to optional type block
	pushl	pli_struct_desc_typeid(r0) ;type id
	pushl	pli_struct_desc_fcode(r0) ;fcode
	pushl	pli_struct_desc_symid(r0) ;symid
	calls	#7,pli_make_strides	;get the unrelocated stride list
	blbc	r0,30$			;branch if error
	rsb				;
30$:	ret				;error return
	.subtitle	pli_fix_stride_and_vd
	.page
;
; ***********************************************************************
; *									*
; *	pli_fix_stride_and_vd						*
; *									*
; ***********************************************************************
;
	.entry	pli_fix_stride_and_vd,^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>
;
; this routine uses 1) if name node is part of right operand of pointer
;			then byte and bit offset of left operand
;		    2) structure descriptor byte and bit offset for this
;			name node
;		    3) optional array block associated with each structure
;			descriptor associated with the name node
;
;to relocate the stride lists. Once the stride lists are relocated, one
;of them is used to relocate the value descriptor.
;
; register	use
;	r11	point to named node
;	r10	point to vd template
;	r9	point to descriptor block
;	r8	point to stride list
;	r7	general node pointer
;	r6	running byte value
;	r5	running bit value
;
ap_node_ptr	=	4
ap_head_node	=	8
ap_message_vect	=	12
;*temp later use descriptor block to fix up stride list properly
;
	movl	ap_node_ptr(ap),r11	;point to name node data 
	movl	pli_node_nam_vd_ptr(r11),r10 ;point to vd template
	cmpl	#pli_node_type$k_namef,pli_node_type(r11);name node function?
	beql	60$			;branch to successful return if so
	movl	pli_node_nam_desc_ptr(r11),r9 ;point to descriptor list
	clrq	r5			;zero running byte and bit value
;
;obtain byte and bit offset from any pointer qualifications. Note that
;evaluation is done so that we are assured that if we are a right (the
;second) operand of a pointer then the left operand has already been
;cooled so that the value descriptor for that node has the proper values.
;
	movl	pli_node_blink(r11),r0	;point to operator name node
	movl	pli_node_blink(r0),r7	;point to parent of operator name node
	cmpl	#pli_node_type$k_oprptr,pli_node_type(r7) ;is it a pointer node?
	bneq	50$			;branch if no pointer qualification
	movl	pli_node_opr_sub_fl(r7),r1 ;point to left operand of pointer
	cmpl	r0,r1			;is name node a left operand?
	bneq	99$			;branch if right operand
50$:	cmpl	#pli_node_type$k_nameo,pli_node_type(r11);name node other?
	beql	60$			;branch if name node data
	brw	1000$			;go get structure offset values
60$:	brw	2000$			;successful return
;
;follow any right links if necessary to find appropriate node
;
99$:	casel	pli_node_type(r1),#0,#19 ;node type case
100$:					;
	.word	never_error -	100$	;0 reserved
	.word	never_error -	100$	;1 head node
	.word	notyet	    -	100$	;2 name node function
	.word	400$	    -	100$	;3 name node data
	.word	400$	    -	100$	;4 name node other (routine, module)
	.word	notyet      -	100$	;5 operator node - infix or prefix opr
	.word	notyet	    -	100$	;6 operator node - named function
	.word	200$	    -	100$	;7 operator node - named data
	.word	200$	    -	100$	;8 operator node - named other
	.word	200$	    -	100$	;9 operator node - pointer
	.word	never_error -	100$	;10 operator node - arguments
	.word	never_error -	100$	;11 operator node - subscripts
	.word	never_error -	100$	;12 operator node - left parenthesis
	.word	never_error -	100$	;13 operator node - continue
	.word	notyet	    -	100$	;14 pli value descriptor node
	.word	notyet	    -	100$	;15 debug special symbol node
	.word	notyet	    -	100$	;16 debug constant node
	.word	never_error -	100$	;17 oprnd -state = need more name
	.word	never_error -	100$	;18 oprscr - state = need more scr
	.word	never_error -	100$	;19 oprcon - state = need more operand
	brw	never_error		;node type code too high
;
;operator node as left operand of pointer
;
200$:					;
	movl	pli_node_opr_arg_cur(r1),r0 ;current number of arguments
	addl2	r0,r0			;arguments have flink and blink
	movl	pli_node_opr_sub_fl-8(r1)[r0],r1 ;point to right operand
	brb	99$			;
;
;name node data or name node other
;
400$:	movl	pli_node_nam_vd_ptr(r1),r0 ;point to value descriptor
	cmpl	#pointer_,pli_vd$l_type(r0) ;value descriptor type must be
					;pointer
;***temp later allow offsets?
	beql	420$			;branch if a pointer
	pushal	-(sp)			;stack will contain address of c.s.
	pushl	pli_node_nam_pn_ptr(r1)	;pathname vector
	calls	#2,pli_pn_to_cs		;convert to counted string
					;argument left on stack
	pushl	#1			;number of fa0 arguments
	pushl	#dbg$_valnotaddr	;value not usable as an address
	calls	#3,dbg$nmake_arg_vect	;make the message
	movl	r0,@ap_message_vect(ap)	;update pointer to message vector
	movl	#sts$k_severe,r0	;severe return
	ret				;
420$:	addl2	@pli_vd$a_ptr(r0),r6	;get value of pointer
	beql	500$			;branch if null
	cmpl	#pli_node_type$k_nameo,pli_node_type(r11);name node other?
	beql	450$			;branch if name node data
	brw	1000$			;go obtain structure descriptor values
;
;name node other as target of pointer qualified reference
;
450$:	movl	r6,pli_vd$a_ptr(r10)	;use byte value as actual address
	brw	2000$			;successful return
;
;pointer has null value
;
500$:					;pointer has null value
	pushal	-(sp)			;stack will contain address of c.s.
	pushl	pli_node_nam_pn_ptr(r1)	;pathname vector
	calls	#2,pli_pn_to_cs		;convert to counted string
					;argument left on stack
	movl	(sp)+,r0		;point to counted string
	pushal	1(r0)			;address of counted string
	movzbl	(r0),-(sp)		;length of counted string
	pushl	#2			;number of fa0 arguments
	pushl	#dbg$_nullref		;pointer value is null
	calls	#4,dbg$nmake_arg_vect	;make the message
	movl	r0,@ap_message_vect(ap)	;update pointer to message vector
	movl	#sts$k_severe,r0	;severe return
	ret				;
;
;add in byte and bit values from structure descriptors
;
;	register	use
;	r11		points to name node
;	r10		points to vd template
;	r9		points to successive structure descriptors
;
;		temporary storage layout
;
;	  (sp)	subscript vector size
;	 4(sp)	subscript vector pointer
;	 8(sp)	byte offset due to array subscripts
;	12(sp)	bit offset due to array subscripts
;
1000$:					;
	moval	-16(sp),sp		;allocate 4 longwords of temporary
	movl	pli_node_nam_vector_size(r11),(sp) ;init subscript vector size
	movl	pli_node_nam_vector(r11),4(sp) ;init pointer to vector
	clrq	8(sp)			;init byte and bit offset values
1010$:	cmpl	#rst$k_type_array,pli_struct_desc_fcode(r9) ;array?
	bneq	1015$			;branch if not array of structures
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	pli_struct_desc_symid(r9) ;symid in case of error
	pushl	pli_struct_desc$a_opt(r9) ;optional type block address
	pushal	12(sp)			;address of temporary storage
	calls	#4,pli_get_vector_offset ;get offset of array
	blbs	r0,1015$		;branch if ok
	ret				;error return
1015$:	addl2	pli_struct_desc$l_byte(r9),r6 ;add byte value
	addl2	pli_struct_desc$l_bit(r9),r5 ;add bit offset
	movl	pli_struct_desc_flink(r9),r9 ;any more descriptors?
	bneq	1010$			;branch to get the next one
	tstl	(sp)			;left over subscripts
	beql	1018$			;branch if non left over
	brw	9000$			;error, too many subscripts specified
1018$:	addl2	8(sp),r6		;add byte offset from arrays
	addl2	12(sp),r5		;add bit offset from arrays
;
;relocate name node stride lists
;
	movl	pli_node_nam_sd2_ptr(r11),r8 ;point to stride list 2 (type 7)
1020$:	addl2	r6,pli_sd_beg_byte(r8)	;add byte addr
	addl2	r5,pli_sd_beg_bit(r8)	;add bit offset
	movl	pli_sd_link(r8),r8	;point to next stride node
	bneq	1020$			;branch if more stride elements
	movl	pli_node_nam_sd1_ptr(r11),r8 ;point to stride list 1 (type 0)
1050$:	addl2	r6,pli_sd_beg_byte(r8)	;add byte addr
	addl2	r5,pli_sd_beg_bit(r8)	;add bit offset
	movl	pli_sd_link(r8),r8	;point to next stride node
	bneq	1050$			;branch if more stride elements
;
;use stride list to fix up value descriptor template
;
	movl	pli_node_nam_sd2_ptr(r11),r8 ;point to stride list 2 (type 7)
	addl2	pli_sd_beg_byte(r8),pli_vd$a_ptr(r10) ;add to byte address
	ashl	#-3,pli_sd_beg_bit(r8),r0 ;INT(number_of_bits/8)
	ashl	#3,r0,r1		;whole bytes as bits
	addl2	r0,pli_vd$a_ptr(r10)	;add as part of byte address
	subl3	r1,pli_sd_beg_bit(r8),r0;excess bits
	addl2	r0,pli_vd$l_boff(r10)	;add as part of bit offset
2000$:	movl	#sts$k_success,r0	;successful return
	ret				;
;
;too many subscripts were specified
;
9000$:	subl3	(sp),pli_node_nam_vector_size(r11),(sp) ;maximum # allowed
	pushl	#1			;fao argument count
	pushl	#dbg$_maxdimsn		;too many subscripts specified
	calls	#3,dbg$nmake_arg_vect	;make the message
	movl	r0,@ap_message_vect(ap)	;update pointer to message
	movl	#sts$k_severe,r0	;severe return
	ret				;
	.subtitle pli_make_pd
	.page
;
; ***********************************************************************
; *									*
; *	pli_make_pd							*
; *									*
; ***********************************************************************
;
	.entry pli_make_pd,^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>
ap_tree_head	=	4		;address of pointer to tree head
ap_pd_ptr	=	8		;pointer to pd (storage supplied)
ap_message_vector =	12		;message vector
;	register	use
;	r11		pointer to pd being built
;	r10		tree head node pointer
;	r9		name node data
;	r8		general pointer for following data structure chains
;
; note:	the storage for the primary descriptor is zeroed except for
;	dsc$w_length which contains the storage size in bytes
;
	movl	@ap_pd_ptr(ap),r11	;point to primary descriptor storage
	movl	@ap_tree_head(ap),r10	;point to tree head node
;
;create pd language independent header
;
	movb	#dbg$k_pli,dsc$b_class(r11) ;language code
	movb	#dbg$k_primary_desc,dsc$b_dtype(r11) ;type code into header
	movl	#pli_pd$k_type_cool,pli_pd$l_type(r11) ;type of primary desc.
	pushal	pli_pd$l_head_node(r11)	;pointer to start of copy of tree
					;this is temporary storage
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	r10			;stop node
	pushl	#0			;back link
	pushl	r10			;first node of subtree to be copied
	pushal	16(sp)			;point to pointer to free storage
	calls	#4,pli_copy_tree	;copy the tree to primary descriptor
	ret				;
	.subtitle	pli_validate_tree
	.page
;
; ***********************************************************************
; *									*
; *	pli_validate_tree						*
; *									*
; ***********************************************************************
;
;This routine is passed a pointer to a hot tree and it validates the
;tree. Currently this consists of:
;    1. Make sure that there are no left parenthesis nodes.
;	If there are, in means that a right parenthesis was missing.
;
	.entry	pli_validate_tree,0
ap_tree_ptr	=	4		;address of head node of tree
ap_message_vect	=	8		;message vector pointer address
	pushl	ap_message_vect(ap)	;pass along message vector
	pushal	10$			;address of action routine
	pushl	ap_tree_ptr(ap)		;pass along head node address
	pushl	ap_tree_ptr(ap)		;pass along tree pointer
	calls	#4,pli_pre_order_opr_walk ;look at all operator nodes
	ret				;use return from walk
10$:	.word	0			;
ap_node_ptr	=	4		;pointer to operator node
ap_head_ptr	=	8		;pointer to head node
ap_message_vect	=	12		;message vector pointer address
	movl	ap_node_ptr(ap),r0	;point to operator node
	cmpl	#pli_node_type$k_oprlp,pli_node_type(r0) ;is it a left
					;parenthesis node?
	beql	20$			;branch if oprlp
	movl	#sts$k_success,r0	;successful return
	ret				;
20$:	pushl	#0			;zero fao arguments
	pushl	#dbg$_unmtchparn	;unmatched left parenthesis
	calls	#2,dbg$nmake_arg_vect	;make the argument vector
	movl	r0,ap_message_vect(ap)	;fill in the message vector pointer
	movl	#sts$k_severe,r0	;severe error return
	ret				;
	.subtitle pli_copy_tree
;
;copies a tree to pre-allocated storage
; used to make primary descriptors and copy primary descriptors
;
;	register	use
;	r11		major pointer into new area (start of node)
;	r3		minor pointer into new area (actual data pointer)
;	r10		pointer to node being copied
; ***warning*** this code assumes that the pre-allocated storage has
;		been zeroed.
;
; convention:	all called routines leave @ap_ptr_to_free_ptr(ap) properly
;		updated on return.
;		All (bsb) subroutines leave r3 updated upon return
;
;
ap_ptr_to_free_ptr	=	4	;pointer to the pointer to the
					;pre-allocated storage
ap_node_ptr		=	8	;pointer to the node whose subtree is
					;to be copied
ap_back_link		=	12	;pointer to back link or 0
ap_stop_node		=	16	;if flink points here,no further calls
ap_message_vect		=	20	;message vector for severe returns
	.entry	pli_copy_tree,^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>
	movl	@ap_ptr_to_free_ptr(ap),r11 ;point to pre-allocated storage
	movl	ap_node_ptr(ap),r10	;point to node to be copied
	casel   pli_node_type(r10),#0,#17 ;node type case
10$:                                    ;
	.word   never_error -   10$     ;0 reserved
	.word   100$	    -   10$     ;1 head node
	.word   200$	    -   10$     ;2 name node function
	.word   200$	    -   10$     ;3 name node data
	.word   200$	    -   10$     ;4 name node other (routine, module)
	.word   300$        -   10$     ;5 operator node - infix or prefix opr
	.word   300$        -   10$     ;6 operator node - named function
	.word   300$        -   10$     ;7 operator node - named data
	.word   300$        -   10$     ;8 operator node - named other
	.word   300$        -   10$     ;9 operator node - pointer
	.word   300$        -   10$     ;10 operator node - arguments
	.word   300$        -   10$     ;11 operator node - subscripts
	.word   300$        -   10$     ;12 operator node - left parenthesis
	.word   300$	    -   10$     ;13 operator node - continue
	.word   400$	    -   10$     ;14 pli value descriptor node
	.word   500$	    -   10$     ;15 debug special symbol node
	.word   600$	    -   10$     ;16 debug constant node
	.word   never_error -   10$     ;17 oprnd -state = need more name
	brw     never_error             ;node type code too high
;
;************************************************************************
;*	head node							*
;************************************************************************
;
100$:					;
	moval	pli_head_node$k_size(r11),r3 ;point to free area
	bsbw	copy_common		;copy the common part of node
	movl	r11,pli_node_flink(r11)	;setup head node flink
	movl	r11,pli_node_blink(r11)	;setup head node blink
	movl	pli_head_node_bits(r10),pli_head_node_bits(r11) ;bit flags
	movl	pli_head_node_count(r10),pli_head_node_count(r11) ;node count
	movl	pli_head_node_orig_verb(r10),pli_head_node_orig_verb(r11) ;the
					;invoking debug verb
	movl	pli_head_node_orig_fp(r10),pli_head_node_orig_fp(r11) ;original
					;frame pointer when invoked
	cmpl	ap_stop_node(ap),pli_node_flink(r10) ;non-null subtree?
	bneq	110$			;branch if subtree
	brw	ok_ret			;successful return
110$:	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	ap_stop_node(ap)	;pass along stop node
	pushal	pli_node_flink(r11)	;back link address	
	pushl	pli_node_flink(r10)	;next node to copy
	movl	r3,@ap_ptr_to_free_ptr(ap) ;update free target storage address
	pushl	ap_ptr_to_free_ptr(ap)	;pass along pointer to free pointer
	calls	#5,pli_copy_tree	;recurse
	ret				;use returning status code
;
;************************************************************************
;*	name node							*
;************************************************************************
;
200$:					;
	moval	pli_node_nam$k_size(r11),r3 ;point to free storage
	bsbw	copy_common		;copy the common part
	movl	pli_node_nam_kind(r10),pli_node_nam_kind(r11) ;kind code
	movl	pli_node_nam_symid(r10),pli_node_nam_symid(r11) ;symid of name
	tstl	pli_node_nam_arg_fl(r10);any arguments or subscripts?
	beql	215$			;branch if no arguments (subscripts)
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	r10			;current node is stop node
	pushal	pli_node_nam_arg_fl(r11);back link address	
	pushl	pli_node_nam_arg_fl(r10);next node to copy
	movl	r3,@ap_ptr_to_free_ptr(ap) ;update free target storage address
	pushl	ap_ptr_to_free_ptr(ap)	;pass along pointer to free pointer
	calls	#5,pli_copy_tree	;recurse
	blbs	r0,210$			;branch of ok
	ret				;use returning status code
210$:					;
	movl	@ap_ptr_to_free_ptr(ap),r3 ;update minor pointer value
;
; copy pathname descriptor
;
215$:	movl	pli_node_nam_pn_ptr(r10),r6 ;point to source pathname desc.
	movl	r3,pli_node_nam_pn_ptr(r11) ;point to copy of pathname area
	movq	(r6),(r3)+		;copy 2 longword header
	movzbl	pth$b_totcnt(r6),r7	;number of vector elements
	ashl	#2,r7,r8		;bytes required by vector elements
	addl3	r3,r8,r9		;last vector element + 4
	movl	r9,r3			;target counted strings start here
220$:	movl	pth$a_pathvector-4(r6)[r7],r1 ;get next counted string
	movl	r3,-(r9)		;point to counted string
	movzbw	(r1)+,r0		;length of counted string
	movb	r0,(r3)+		;store in target
	movc3	r0,(r1),(r3)		;copy string
	sobgtr	r7,220$			;copy all strings
;
;copy stride descriptors
;
	movl	pli_node_nam_sd1_ptr(r10),r6 ;point to source stride desc.1
	beql	235$			;branch if no stride desc (e.g. %line)
	moval	pli_node_nam_sd1_ptr(r11),r7 ;address of stride desc 1 ptr
230$:	movl	r3,(r7)			;put in forward pointer value
	moval	pli_sd_link(r3),r7	;next forward pointer
	movc3	#pli_sd$k_size,(r6),(r3);copy stride descriptor
	movl	pli_sd_link(r6),r6	;point to next source descriptor
	bneq	230$			;if more, go copy descriptor
235$:	movl	pli_node_nam_sd2_ptr(r10),r6 ;point to source stride desc. 2
	beql	245$			;branch if no stride desc (e.g. %line)
	moval	pli_node_nam_sd2_ptr(r11),r7 ;address of stride desc 2 ptr
240$:	movl	r3,(r7)			;put in forward pointer value
	moval	pli_sd_link(r3),r7	;next forward pointer
	movc3	#pli_sd$k_size,(r6),(r3);copy stride descriptor
	movl	pli_sd_link(r6),r6	;point to next source descriptor
	bneq	240$			;if more, go copy descriptor
;
;copy structure descriptor
;
;	register	use
;	r11		target name node pointer
;	r10		source name node pointer
;	r9		target structure desc pointer
;	r8		target optional block pointer
;	r7		source optional block pointer
;	r6		source structure desc pointer
;
245$:	movl	pli_node_nam_desc_ptr(r10),r6 ;point to first structure desc.
	movl	r3,pli_node_nam_desc_ptr(r11) ;point to structure descriptor
250$:	movl	r3,r9			;start of target structure desc.
	addl2	#pli_struct_desc$k_size,r3 ;point past this struct. desc.
	movl	pli_struct_desc_symid(r6),pli_struct_desc_symid(r9) ;symid
	movl	pli_struct_desc_kind(r6),pli_struct_desc_kind(r9) ;kind code
	movl	pli_struct_desc_fcode(r6),pli_struct_desc_fcode(r9) ;fcode
	movl	pli_struct_desc_typeid(r6),pli_struct_desc_typeid(r9) ;typeid
	movl	pli_struct_desc_valkind(r6),pli_struct_desc_valkind(r9);valkind
	movl	pli_struct_desc$l_byte(r6),pli_struct_desc$l_byte(r9) ;byte
	movl	pli_struct_desc$l_bit(r6),pli_struct_desc$l_bit(r9) ;bit
	movl	pli_struct_desc$l_fp(r6),pli_struct_desc$l_fp(r9) ;symval fp
;
;copy structure descriptor optional block
;
	movl	pli_struct_desc$a_opt(r6),r7 ;optional type block present?
	beql	280$			;branch if no optional block

	movl	r3,pli_struct_desc$a_opt(r9) ;point to optional block
255$:	movl	r3,r8			;target optional block
	movzbl	pli_struc_opt$b_count(r7),r0 ;byte count of optional type block
	movc3	r0,(r7),(r3)		;copy the optional type block, now
					;we go back and fix descriptor	
	tstl	pli_struc_opt$a_desc(r7) ;any vax descriptor?
	beql	270$			;branch if no vax descriptor
	movl	r3,pli_struc_opt$a_desc(r8) ;pointer to vax descriptor

	movl	r3,@ap_ptr_to_free_ptr(ap) ;update pointer to free
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	ap_ptr_to_free_ptr(ap)	;pass along pointer to free
	pushl	pli_struc_opt$a_desc(r7);pass address of descriptor to copy
	calls	#3,pli_copy_vax_desc	;copy the vax descriptor
	blbs	r0,260$			;branch if ok
	ret				;
260$:	movl	@ap_ptr_to_free_ptr(ap),r3 ;point to new free area
270$:	cmpb	#pli_struc_opt$a_cont+4,pli_struc_opt$b_count(r7) ;continue?
	bgtr	280$			;branch if no continue
	movl	pli_struc_opt$a_cont(r7),r0 ;point to next opt. type block
	beql	280$			;branch (continue) if none present
	movl	r3,pli_struc_opt$a_cont(r8) ;target pointer to continue block
	movl	r0,r7			;new source continue type block
	brb	255$			;copy this optional type block
280$:	movl	pli_struct_desc_flink(r6),r6 ;another structure descriptor?
	beql	290$			;branch if no more struct. desc.
	movl	r3,pli_struct_desc_flink(r9) ;point to new structure desc.
					;(target)
	brw	250$			;go copy the next structure desc.
;
;copy value descriptor
;
;****warning****
;	N.B.
;	this value descriptor points to data that is part of the user's
;	program. The data will not be copied. This means that at the
;	present, typed data constants are not supported.
;
290$:	movl	pli_node_nam_vd_ptr(r10),r6 ;point to source vd
	movl	r3,pli_node_nam_vd_ptr(r11) ;point to target vd
	movc3	#pli_vd$k_size,(r6),(r3) ;copy value descriptor
;
;
;copy subscript vector
;
	movl	pli_node_nam_vector_size(r10),r0 ;number of vector elements
	beql	295$			;branch if no vector
	movl	r0,pli_node_nam_vector_size(r11) ;copy vector element count
	ashl	#2,r0,r0		;bytes required for vector
	movl	r3,pli_node_nam_vector(r11) ;point to vector
	movc3	r0,-			;copy the subscript
		@pli_node_nam_vector(r10),(r3)	;vector
295$:	movl	r3,@ap_ptr_to_free_ptr(ap) ;update pointer to free
	brw	ok_ret			;successful return
;
;************************************************************************
;*	operator node copied						*
;************************************************************************
;
;	register	use
;	r11		operator node target pointer
;	r10		operator node source pointer
;	r6		index subscripts
;	r7		source subscript array pointer
;	r8		target subscript array pointer
;
300$:	moval	pli_node_opr$k_size(r11),r3 ;point to free storage
	bsbw	copy_common		;copy the common part of node
	movq	pli_node_flink(r11),-(sp) ;save flink and blink for this node
	movl	pli_node_opr_subtype(r10),pli_node_opr_subtype(r11) ;operator
					;sub type
	movl	pli_node_opr_arg_cur(r10),r6 ;retain number of subscripts
	movl	r6,pli_node_opr_arg_cur(r11) ;current argument count
	movl	pli_node_opr_arg_min(r10),pli_node_opr_arg_min(r11) ;argument
					;minimum
	movl	pli_node_opr_arg_max(r10),pli_node_opr_arg_max(r11) ;argument
					;maximum
	moval	pli_node_opr_sub_fl(r10),r7 ;point to first source subs. ptr.
	moval	pli_node_opr_sub_fl(r11),r8 ;point to first target subs. ptr.
320$:					;
	movl	r11,pli_node_flink(r11)	;dummy flink, points to self
	movl	r11,pli_node_blink(r11)	;dummy blink, points to self
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	r10			;current node is stop node
	pushal	pli_node_flink(r11)	;back link address	
	pushl	(r7)+			;next node to copy
	addl2	#4,r7			;point past blink
	movl	r3,@ap_ptr_to_free_ptr(ap) ;update free target storage address
	pushl	ap_ptr_to_free_ptr(ap)	;pass along pointer to free pointer
	calls	#5,pli_copy_tree	;recurse
	blbs	r0,330$			;branch of ok
	ret				;use returning status code
330$:					;
	movl	@ap_ptr_to_free_ptr(ap),r3 ;update minor pointer value
	movq	pli_node_flink(r11),(r8)+;copy updated forward pointers	
	sobgtr	r6,320$			;similarly for all arguments
	movq	(sp)+,pli_node_flink(r11) ;restore nodes flink and blink
	brw ok_ret			;successful return
;
;************************************************************************
;*	pli value descriptor node copied				*
;************************************************************************
;
400$:;***temp
;this should never get executed until we have function calls because
;subscripts get reduced to a vector that hangs off the optional
;structure descriptor that hangs off the associated name node.
;Pointer (left) operands reduce to debug address nodes (pli_node_dbg)
	movl	#pli$k_not_yet,r0	;don't have functions yet
	brw	bug_check		;
	moval	pli_node_vd$k_size(r11),r3 ;point to free storage
	bsbw	copy_common		;copy the common part of node
	movl	pli_node_vd_stype(r10),pli_node_vd_stype(r11) ;secondary type
	movl	pli_node_vd_ssize(r10),pli_node_vd_ssize(r11) ;secondary size
;vd$a_addr
	movl	pli_node_vd$l_type(r10),pli_node_vd$l_type(r11) ;primary type
	movl	pli_node_vd$l_size(r10),pli_node_vd$l_size(r11) ;primary size
	movl	pli_node_vd$l_boff(r10),pli_node_vd$l_boff(r11) ;bit offset
;$a_data
;
;************************************************************************
;*	debug special symbol node					*
;************************************************************************
;
500$:
;***temp
;currently unsupported
	movl	#pli$k_not_yet,r0	;don't have functions yet
	brw	bug_check		;

	moval	pli_node_dss$k_size(r11),r3 ;point to free storage
	bsbw	copy_common		;copy the common part of node
	movl	pli_node_dss_kind(r10),pli_node_dss_kind(r11) ;kind code
	movl	pli_node_dss_sym_cod(r10),pli_node_dss_sym_cod(r11) ;symbol
					;encoding
;	movl	...
	brw ok_ret			;successful return
;
;************************************************************************
;*	debug constant node copied					*
;************************************************************************
;
600$:	moval	pli_node_dbg$k_size(r11),r3 ;point to free storage
	bsbw	copy_common		;copy the common part of node
	movl	pli_node_dbg_value(r10),pli_node_dbg_value(r11) ;address
	movl	pli_node_dbg_radix(r10),pli_node_dbg_radix(r11) ;radix
	brw ok_ret			;successful return
;
;************************************************************************
;*	copy common node header						*
;************************************************************************
;
;assumes r3 points to free storage (used to copy input string)
;	upon exit r3 points past this inserted string
copy_common:				;
	movl	ap_back_link(ap),r6	;point to back link quadword
	beql	10$			;skip following if no back link
	insque	pli_node_flink(r11),(r6);insert in queue using back link ptr
10$:	movl	pli_node_type(r10),pli_node_type(r11) ;node type
	movl	pli_node_ident(r10),pli_node_ident(r11) ;node identifier
	movw	pli_node$w_sl(r10),pli_node$w_sl(r11) ;length of input string
	movl	r3,pli_node$a_str(r11)	;address of (copy of) input string
	movc3	pli_node$w_sl(r10),@pli_node$a_str(r10),(r3) ;copy input string
	rsb				;	
ok_ret:	movl	#sts$k_success,r0	;successful return
	ret				;
	.subtitle	pli_copy_vax_desc
;
;************************************************************************
;*	copy vax descriptor						*
;************************************************************************
;	register	use
;	r11		points to vax descriptor
;	r10		number of dimensions
;	r9		running byte count of vax descriptor size
;	r3		free storage pointer
;
ap_vax_desc_addr	=	4	;vax descriptor address (value)
ap_ptr_to_free_ptr	=	8	;pointer to free pointer
ap_message_vect		=	12	;message vector
	.entry	pli_copy_vax_desc,^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>
	movl	@ap_ptr_to_free_ptr(ap),r3 ;point to free zeroed storage
	movl	ap_vax_desc_addr(ap),r11 ;point to vax descriptor
	beql	160$			;if none, successful return
	movb	dsc$b_class(r11),r0	;save class code
	cmpb	#dsc$k_class_a,r0	;array descriptor
	beql	100$			;branch if array descriptor
	cmpb	#dsc$k_class_nca,r0	;non contiguous array
	beql	1000$			;branch if non contiguous array
	cmpb	#dsc$k_class_uba,r0	;unaligned bit array?
	beql	2000$			;branch if unaligned bit array
	cmpb	#dsc$k_class_vsa,r0	;varying string array?
	beql	1000$			;if so, treat as non_contiguous array
	cmpb	#dsc$k_class_s,r0	;scalar string descriptor?
	beql	3000$			;branch if so
	cmpb	#dsc$k_class_d,r0	;dynamic string?
	beql	3000$			;branch if so
	cmpb	#dsc$k_class_p,r0	;procedure (obsolete)
	beql	3000$			;branch if so
	cmpb	#dsc$k_class_j,r0	;label (obsolete)
	beql	3000$			;branch if so
	cmpb	#dsc$k_class_vs,r0	;varying string
	beql	3000$			;branch if so
	cmpb	#dsc$k_class_v,r0	;varying buffer
	beql	4000$			;branch if so
	cmpb	#dsc$k_class_sd,r0	;decimal scalar string
	beql	4000$			;branch if so
	cmpb	#dsc$k_class_ubs,r0	;unaligned bit string
	beql	4000$			;branch if so
	movl	#pli$k_never,r0		;we should know about all the different
					;kinds of vax descriptors
	brw	bug_check
;
;array descriptor
;
100$:	movzbl	dsc$b_dimct(r11),r10	;number of dimensions
	movl	#dsc$a_a0,r9		;size of block 1 in bytes
	bbc	#dsc$v_fl_coeff,dsc$b_aflags(r11),150$ ;branch if no block 2
	ashl	#2,r10,r1		;bytes for multipliers
	addl2	#4,r9			;bytes for a0
	addl2	r1,r9			;bytes for multipliers added to total
	bbc	#dsc$v_fl_bounds,dsc$b_aflags(r11),150$ ;branch if no block 3
140$:	ashl	#3,r10,r1		;bytes for bounds
	addl2	r1,r9			;add to total bytes needed
150$:	movc3	r9,(r11),(r3)		;copy array descriptor
	movl	r3,@ap_ptr_to_free_ptr(ap) ;update free storage pointer
160$:	brw	ok_ret			;successful return
;
;non_contiguous array descriptor
;
1000$:	movzbl	dsc$b_dimct(r11),r10	;number of dimensions
	movl	#dsc$a_a0,r9		;size of block 1 in bytes
1010$:	ashl	#2,r10,r1		;bytes for multipliers or strides
	addl2	#4,r9			;bytes for a0 or v0
	addl2	r1,r9			;bytes for multipliers added to total
	brb	140$			;merge with common code
;
;unaligned bit array descriptor
;
2000$:	movzbl	dsc$b_dimct(r11),r10	;number of dimensions
	movl	#dsc$l_v0,r9		;size of block 1 in bytes
	addl2	#4,r9			;add bytes for block 4
	brb	1010$			;merge with common code
;
;8 byte descriptors
;
3000$:	movl	#8,r9			;size in bytes of descriptor
	brb	150$			;merge with common code
;
;12 byte descriptors
;
4000$:	movl	#12,r9			;size in bytes of descriptor
	brb	150$			;merge with common code
	.page
	.subtitle	pli_pd_to_name_node
;
;************************************************************************
;*	pli_pd_to_name_node						*
;************************************************************************
;
; this routine is given the address of a primary descriptor and
; returns the first top level name node
;
ap_pd_addr	=	4	;pointer to primary descriptor
ap_ptr_name_node_ptr =	8	;pointer to pointer to name node (output)
ap_message_vect	=	12	;message vector
	.entry	pli_pd_to_name_node,0
	movl	ap_pd_addr(ap),r0	;point to primary descriptor
	movl	pli_pd$l_head_node(r0),r0 ;point to head node
10$:	casel	pli_node_type(r0),#0,#19 ;node type case
20$:					;
	.word	never_error -	20$	;0 reserved
	.word	never_error -	20$	;1 head node
	.word	300$	    -	20$	;2 name node function
	.word	300$	    -	20$	;3 name node data
	.word	300$	    -	20$	;4 name node other (routine, module)
	.word	never_error -	20$	;5 operator node - infix or prefix opr
	.word	100$	    -	20$	;6 operator node - named function
	.word	100$	    -	20$	;7 operator node - named data
	.word	100$	    -	20$	;8 operator node - named other
	.word	200$	    -	20$	;9 operator node - pointer
	.word	never_error -	20$	;10 operator node - arguments
	.word	never_error -	20$	;11 operator node - subscripts
	.word	never_error -	20$	;12 operator node - left parenthesis
	.word	never_error -	20$	;13 operator node - continue
	.word	never_error -	20$	;14 pli value descriptor node
	.word	never_error -	20$	;15 debug special symbol node
	.word	never_error -	20$	;16 debug constant node
	.word	never_error -	20$	;17 oprnd -state = need more name
	.word	never_error -	20$	;18 oprscr - state = need more scr
	.word	never_error -	20$	;19 oprcon - state = need more operand
30$:	brw	never_error		;node type code too high
;
;named operator node
;
100$:	movl	pli_node_opr_sub_fl(r0),r0 ;point to first operand
	brb	10$			;examine next node
;
;pointer operator node
;
200$:	cmpl	#2,pli_node_opr_arg_cur(r0) ;currently 2 arguments
	bneq	30$			;if not, internal error
	movl	pli_node_opr_sub_fl+8(r0),r0 ;point to second operand
	brb	10$			;examine next node
;
;name node
;
300$:	movl	r0,@ap_ptr_name_node_ptr(ap) ;return name node address
	movl	#sts$k_success,r0	;successful return
	ret				;
	.subtitle pli_get_pd_length
	.page
;
; ***********************************************************************
; *									*
; *	pli_get_pd_length						*
; *									*
; ***********************************************************************
;
	.entry pli_get_pd_length,0
ap_tree_head	=	4		;address of pointer to tree head
ap_pd_length	=	8		;address of pd length in bytes
ap_message_vect	=	12		;error message vector
	movl	#pli_pd$k_fixed_size,@ap_pd_length(ap);start with the
					;fixed size of the primary desc.
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	@ap_tree_head(ap)	;address of stop node (head node)
	pushl	@ap_tree_head(ap)	;(head node) subtree to size
	pushl	ap_pd_length(ap)	;address of length longword
	calls	#4,pli_get_tree_length	;go size the subtree
	ret				;use return from sizing routine
	.subtitle pli_get_tree_length
;
;Determines the number of bytes contained in (an therefore required to
;copy) a specified subtree. Used by routines that make primary descriptors
;and copy primary descriptors
;
;	register	use
;	r11		points to longword that retains byte count
;	r10		pointer to node being sized
;
ap_bytes_ptr		=	4	;pointer to the pointer to the
					;pre-allocated storage
ap_node_ptr		=	8	;pointer to the node whose subtree is
					;to be copied
ap_stop_node		=	12	;if flink points here,no further calls
ap_message_vect		=	16	;message vector for severe returns
	.entry	pli_get_tree_length,^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>
	movl	ap_bytes_ptr(ap),r11	;point to running byte total
	movl	ap_node_ptr(ap),r10	;point to node to be sized
	casel   pli_node_type(r10),#0,#17 ;node type case
10$:                                    ;
	.word   never_error -   10$     ;0 reserved
	.word   100$	    -   10$     ;1 head node
	.word   200$	    -   10$     ;2 name node function
	.word   200$	    -   10$     ;3 name node data
	.word   200$	    -   10$     ;4 name node other (routine, module)
	.word   300$        -   10$     ;5 operator node - infix or prefix opr
	.word   300$        -   10$     ;6 operator node - named function
	.word   300$        -   10$     ;7 operator node - named data
	.word   300$        -   10$     ;8 operator node - named other
	.word   300$        -   10$     ;9 operator node - pointer
	.word   300$        -   10$     ;10 operator node - arguments
	.word   300$        -   10$     ;11 operator node - subscripts
	.word   300$        -   10$     ;12 operator node - left parenthesis
	.word   300$	    -   10$     ;13 operator node - continue
	.word   400$	    -   10$     ;14 pli value descriptor node
	.word   500$	    -   10$     ;15 debug special symbol node
	.word   600$	    -   10$     ;16 debug constant node
	.word   never_error -   10$     ;17 oprnd - state = need more name
	brw     never_error             ;node type code too high
;
;************************************************************************
;*	head node sized							*
;************************************************************************
;
100$:					;
	addl2	#pli_head_node$k_size,(r11) ;add in fixed size of head node
	movzwl	pli_node$w_sl(r10),r0	;input token string length
	addl2	r0,(r11)		;add to running total
	cmpl	ap_stop_node(ap),pli_node_flink(r10) ;non-null subtree?
	bneq	110$			;branch if subtree
	brw	ok_ret			;successful return
110$:	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	ap_stop_node(ap)	;pass along stop node
	pushl	pli_node_flink(r10)	;next node to copy
	pushl	ap_bytes_ptr(ap)	;pass along pointer to free pointer
	calls	#4,pli_get_tree_length	;recurse
	ret				;use returning status code
;
;************************************************************************
;*	name node sized							*
;************************************************************************
;
200$:					;
	addl2	#pli_node_nam$k_size,(r11) ;add fixed size of name node
	movzwl	pli_node$w_sl(r10),r0	;input token string length
	addl2	r0,(r11)		;add to running total
	tstl	pli_node_nam_arg_fl(r10);any arguments or subscripts?
	beql	215$			;branch if no arguments (subscripts)
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	r10			;current node is stop node
	pushl	pli_node_nam_arg_fl(r10);next node to copy
	pushl	ap_bytes_ptr(ap)	;pass along pointer to free pointer
	calls	#4,pli_get_tree_length	;recurse
	blbs	r0,210$			;branch of ok
	ret				;use returning status code
210$:					;
;
; pathname descriptor sized
;
215$:	movl	pli_node_nam_pn_ptr(r10),r6 ;point to source pathname desc.
	addl2	#pth$a_pathvector,(r11)	;add fixed size of pathname vector
	movzbl	pth$b_totcnt(r6),r7	;number of vector elements
	ashl	#2,r7,r8		;bytes required by vector elements
	addl2	r8,(r11)		;vector size add to total
220$:	movl	pth$a_pathvector-4(r6)[r7],r1 ;point to next counted string
	incl	(r11)			;account for count byte
	movzbl	(r1),r0			;number of characters in string
	addl2	r0,(r11)		;add to total
	sobgtr	r7,220$			;copy all strings
;
;add size due to stride descriptors
;
	movl	pli_node_nam_sd1_ptr(r10),r6 ;point to source stride desc.1
	beql	235$			;branch if no stride desc (e.g. %line)
230$:	addl2	#pli_sd$k_size,(r11)	;add size of this stride descriptor
	movl	pli_sd_link(r6),r6	;point to next source descriptor
	bneq	230$			;if more, go copy descriptor
235$:	movl	pli_node_nam_sd2_ptr(r10),r6 ;point to source stride desc. 2
	beql	245$			;branch if no stride desc (e.g. %line)
240$:	addl2	#pli_sd$k_size,(r11)	;add size of this stride descriptor
	movl	pli_sd_link(r6),r6	;point to next source descriptor
	bneq	240$			;if more, go copy descriptor
;
;add size due to structure descriptor
;
;	register	use
;	r11		points to total size count
;	r10		source name node pointer
;	r7		source optional block pointer
;	r6		source structure desc pointer
;
245$:	movl	pli_node_nam_desc_ptr(r10),r6 ;point to first structure desc.
250$:	addl2	#pli_struct_desc$k_size,(r11) ;add in size of this struc. desc.
;
;add size due to structure descriptor optional type block
;
	movl	pli_struct_desc$a_opt(r6),r7 ;optional block (arrays) present?
	beql	285$			;branch if no optional block
260$:					;
	movzbl	pli_struc_opt$b_count(r7),r0 ;get size of optional type block
	addl2	r0,(r11)		;add size of optional type block


	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	r11			;pass along pointer to byte total
	pushl	pli_struc_opt$a_desc(r7);pass address of descriptor to copy
	calls	#3,pli_size_vax_desc	;size the vax descriptor
	blbs	r0,280$			;branch if ok
	ret				;
280$:	cmpb	#pli_struc_opt$a_cont+4,pli_struc_opt$b_count(r7) ;continue?
	bgtr	285$			;branch if no continue
	movl	pli_struc_opt$a_cont(r7),r7 ;point to continue block
	bneq	260$			;branch if really present

285$:	movl	pli_struct_desc_flink(r6),r6 ;another structure descriptor?
	beql	290$			;branch if no more struct. desc.
	brb	250$			;go copy the next structure desc.
;
;add size due to value descriptor
;
;****warning****
;	N.B.
;	this value descriptor points to data that is part of the user's
;	program. The data will not be sized. This means that at the
;	present, typed data constants are not supported.
;
290$:	addl2	#pli_vd$k_size,(r11)	;size the value descriptor
;
;
;
; add size due to subscript vector
	movl	pli_node_nam_vector_size(r10),r0 ;number of vector elements
	ashl	#2,r0,r0		;number of bytes
	addl2	r0,(r11)		;add to total bytes
	brw	ok_ret			;successful return
;
;************************************************************************
;*	operator node sized						*
;************************************************************************
;
;	register	use
;	r11		pointer to total byte count
;	r10		operator node source pointer
;	r6		index subscripts
;	r7		source subscript array pointer
;	r8		target subscript array pointer
;
300$:	addl2	#pli_node_opr$k_size,(r11) ;add in fixed size of operator node
	movzwl	pli_node$w_sl(r10),r0	;input token string length
	addl2	r0,(r11)		;add to running total
	movl	pli_node_opr_arg_cur(r10),r6 ;retain number of subscripts
	moval	pli_node_opr_sub_fl(r10),r7 ;point to first source subs. ptr.
320$:					;
	pushl	ap_message_vect(ap)	;pass along message vector
	pushl	r10			;current node is stop node
	pushl	(r7)+			;next node to size
	addl2	#4,r7			;point past blink
	pushl	ap_bytes_ptr(ap)	;pass along pointer to free pointer
	calls	#4,pli_get_tree_length	;recurse
	blbs	r0,330$			;branch of ok
	ret				;use returning status code
330$:					;
	sobgtr	r6,320$			;similarly for all arguments
	brw ok_ret			;successful return
;
;************************************************************************
;*	pli value descriptor node sized					*
;************************************************************************
;
400$:;***temp
;this should never get executed until we have function calls because
;subscripts get reduced to a vector that hangs off the optional
;structure descriptor that hangs off the associated name node.
;Pointer (left) operands reduce to debug address nodes (pli_node_dbg)
	movl	#pli$k_not_yet,r0	;don't have functions yet
	brw	bug_check		;
;***later	addl2	#pli_node_vd$k_size,(r11);add fixed size of value desc. node
;	movzwl	pli_node$w_sl(r10),r0	;input token string length
;	addl2	r0,(r11)		;add to running total
;***temp should data be size also?
;$a_data
;

;
;************************************************************************
;*	debug special symbol node					*
;************************************************************************
;
500$:
;***temp
;currently unsupported
	movl	#pli$k_not_yet,r0	;don't have functions yet
	brw	bug_check		;

;***later	addl2	#pli_node_dss$k_size,(r11) ;add fixed size of debug 
;					;special symbol node
;	movzwl	pli_node$w_sl(r10),r0	;input token string length
;	addl2	r0,(r11)		;add to running total
;
;************************************************************************
;*	debug constant node sized					*
;************************************************************************
;
600$:	addl2	#pli_node_dbg$k_size,(r11) ;add fixed size of debug constant
	movzwl	pli_node$w_sl(r10),r0	;input token string length
	addl2	r0,(r11)		;add to running total
	brw ok_ret			;successful return
	.subtitle	pli_size_vax_desc
;
;************************************************************************
;*	size vax descriptor						*
;************************************************************************
;	register	use
;	r4		running byte count
;	r3		points to vax descriptor
;	r2		number of dimensions
;
ap_vax_desc_addr	=	4	;vax descriptor address (value)
ap_bytes_ptr		=	8	;pointer running byte total
ap_message_vect		=	12	;message vector
	.entry	pli_size_vax_desc,^m<r2,r3,r4>
	movl	ap_bytes_ptr(ap),r4	;point to running byte total
	movl	ap_vax_desc_addr(ap),r3 ;point to vax descriptor
	beql	150$			;success if no real descriptor (branch)
	movb	dsc$b_class(r3),r0	;save class code
	cmpb	#dsc$k_class_a,r0	;array descriptor
	beql	100$			;branch if array descriptor
	cmpb	#dsc$k_class_nca,r0	;non contiguous array
	beql	1000$			;branch if non contiguous array
	cmpb	#dsc$k_class_uba,r0	;unaligned bit array?
	beql	2000$			;branch if unaligned bit array
	cmpb	#dsc$k_class_vsa,r0	;varying string array?
	beql	1000$			;if so, treat as non_contiguous array
	cmpb	#dsc$k_class_s,r0	;scalar string descriptor?
	beql	3000$			;branch if so
	cmpb	#dsc$k_class_d,r0	;dynamic string?
	beql	3000$			;branch if so
	cmpb	#dsc$k_class_p,r0	;procedure (obsolete)
	beql	3000$			;branch if so
	cmpb	#dsc$k_class_j,r0	;label (obsolete)
	beql	3000$			;branch if so
	cmpb	#dsc$k_class_vs,r0	;varying string
	beql	3000$			;branch if so
	cmpb	#dsc$k_class_v,r0	;varying buffer
	beql	4000$			;branch if so
	cmpb	#dsc$k_class_sd,r0	;decimal scalar string
	beql	4000$			;branch if so
	cmpb	#dsc$k_class_ubs,r0	;unaligned bit string
	beql	4000$			;branch if so
	movl	#pli$k_never,r0		;we should know about all the different
					;kinds of vax descriptors
	brw	bug_check		;
;
;array descriptor
;
100$:	movzbl	dsc$b_dimct(r3),r2	;number of dimensions
	addl2	#dsc$a_a0,(r4)		;size of block 1 in bytes
	bbc	#dsc$v_fl_coeff,dsc$b_aflags(r3),150$ ;branch if no block 2
	ashl	#2,r2,r1		;bytes for multipliers
	addl2	#4,(r4)			;bytes for a0
	addl2	r1,(r4)			;bytes for multipliers added to total
	bbc	#dsc$v_fl_bounds,dsc$b_aflags(r3),150$ ;branch if no block 3
140$:	ashl	#3,r2,r1		;bytes for bounds
	addl2	r1,(r4)			;add to total bytes needed
150$:	brw	ok_ret			;successful return
;
;non_contiguous array descriptor
;
1000$:	movzbl	dsc$b_dimct(r3),r2	;number of dimensions
	addl2	#dsc$a_a0,(r4)		;size of block 1 in bytes
1010$:	ashl	#2,r2,r1		;bytes for multipliers or strides
	addl2	#4,(r4)			;bytes for a0 or v0
	addl2	r1,(r4)			;bytes for multipliers added to total
	brb	140$			;merge with common code
;
;unaligned bit array descriptor
;
2000$:	movzbl	dsc$b_dimct(r3),r2	;number of dimensions
	addl2	#dsc$l_v0,(r4)		;size of block 1 in bytes
	addl2	#4,(r4)			;add bytes for block 4
	brb	1010$			;merge with common code
;
;8 byte vax descriptors
;
3000$:	addl2	#8,(r4)			;add size of descriptor
	brb	150$			;merge with common code
;
;12 byte vax descriptors
;
4000$:	addl2	#12,(r4)		;add size of descriptor
	brb	150$			;merge with common code
	.end
