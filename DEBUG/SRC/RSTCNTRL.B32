MODULE RSTCNTRL (IDENT = 'V03-000') =

BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! WRITTEN BY
!	Bert Beander	June, 1980.
!
! MODULE FUNCTION
!	This module contains the routines which build and remove DEBUG's
!	Run-Time Symbol Table (RST).  This includes the routines which
!	initialize the RST when DEBUG is started up as well as the routines
!	which build and remove (SET and CANCEL) a specific module's RST
!	during the debugging session.  The routines which maintain the
!	DEBUG Scope List are also here.
!
! MODIFIED BY
!	Rich Title	Nov, 1981	Fixed a bug in DBG$RST_SETSCOPE :
!					SET SCOPE MOD1 sometimes failed if
!					MOD1 is a module which is already
!					set.
!

REQUIRE 'SRC$:DBGPROLOG.REQ';

FORWARD ROUTINE
    DBG$GET_DST_NAME,			! Find the name string in a DST record
    DBG$HASH_FIND,			! Find a name in the RST Hash Table
    DBG$HASH_FIND_SETUP:NOVALUE,	! Set up calls on DBG$HASH_FIND routine
    DBG$HASH_INSERT:	NOVALUE,	! Insert an RST entry in the Hash Table
    DBG$RST_BUILD:	NOVALUE,	! Build the RST for one module
    DBG$RST_CANMOD,			! CANCEL a module in the RST
    DBG$RST_INIT:	NOVALUE,	! Initialize DST and RST
    DBG$RST_MOST_RECENT:NOVALUE,	! Mark the Most Recently Used module
    DBG$RST_REMOVE:	NOVALUE,	! Remove a module from the RST
    DBG$RST_SETMOD,			! SET a module in the RST
    DBG$RST_SETSCOPE:	NOVALUE,	! Set a list of scopes from SET SCOPE
    BUILD_LABEL_RST,			! Build RST entries for numeric labels
    CHECK_DUPLICATE:	NOVALUE,	! Check for duplicated BLISS symbols
    COPY_COMP_LIST:	NOVALUE,	! Copy a record component list to RST
    COPY_VARIANT_LIST,			! Copy a record variant list to RST
    COMP_LIST_ADD_ENTRY:NOVALUE,	! Add entry to a record component list
    GET_MEM,				! Get memory from the free memory pool
    GET_MOD_RST,			! Find a specified module in the RST
    GET_TYPEPTR:	NOVALUE,	! Find record or enum type DST pointer
    RST_BUILD_ERROR_HANDLER,		! Error handler for DBG$RST_BUILD
    SETSCOPE_ERROR_HANDLER,		! Error handler for DBG$RST_SETSCOPE
    SHARED_IMAGE_NAMES: NOVALUE,	! Make global symbols from all shared
					!      image names in this execution
    STATIC_ADDRESS:	NOVALUE,	! Make a Static Address Table entry
    STATIC_CHECK:	NOVALUE,	! Check whether a data item is static
    TEST_DST_SIZE;			! Find DST size for Testable Debugger

EXTERNAL ROUTINE
    DBG$EXPAND_MEMORY,			! Expand the free memory pool
    DBG$FREE_MEM_LEFT,			! Return the free memory pool size
    DBG$GET_MEMORY,			! Get a memory block from memory pool
    DBG$GST_TO_RST,			! Create RST entry for a global symbol
    DBG$LANGUAGE,			! Return ASCIC name from a language code
    DBG$NPATHDESC_TO_CS:NOVALUE,	! Convert pathname to counted ASCII
    DBG$REL_MEMORY:	NOVALUE,	! Release a block to free memory pool
    DBG$SET_LANG: NOVALUE,		! Set the current language setting
    DBG$SRC_INIT:	NOVALUE,	! Initialize source line display blocks
    DBG$STA_GETSYMBOL:	NOVALUE,	! Look up a symbol in the RST
    DBG$STA_LOCK_SYMID:	NOVALUE,	! Lock a SYMID in RST memory
    DBG$STA_LOOKUP_GBL,			! Look up a Global symbol in the GST
    DBG$STA_SYMNAME: NOVALUE,		! Get the name string of a given symbol
    DBG$STA_UNLOCK_SYMID: NOVALUE,	! Unlock a SYMID locked in RST memory
    LIB$_CREMAPSEC;			! Create Map Section system service

EXTERNAL
    DBG$GB_LANGUAGE: BYTE,		! The currently SET language code
    DBG$GL_RUNFRAME: REF BLOCK[,BYTE],	! The current user run frame
    SYS$GL_IAFLINK: REF VECTOR[1];	! Pointer to pointer to start of Image
					!      Activator Fixup Block List

EXTERNAL LITERAL
    DBG$GL_SUP_OR_TEST;			! Symbol defined at link-time.  The
					!      possible values are:
					!	0 = Standard Debugger
					!	1 = Testable Debugger
					!	2 = Super-Debugger

GLOBAL
    DST$BEGIN_ADDR: INITIAL(0),		! Virtual address where the DST begins
    DST$END_ADDR: INITIAL(0),		! Virtual address of last byte of DST
    DST$NEXT_ADDR,			! -
    GST$BEGIN_ADDR: INITIAL(0),		! Virtual address where the GST (Global
					!      Symbol Table) begins
    GST$NEXT_ADDR,			! -
    GST$REC_COUNT: INITIAL(0),		! Number of records in the GST
    LRUM$LISTHEAD: REF LRUM$ENTRY	! Pointer to the list head for the Least
			INITIAL(0),	!      Recently Used Module (LRUM) chain
    LRUM$MOST_RECENT: INITIAL(0),	! Pointer to the Module RST Entry of the
					!      Most Recently Used module
    RST$REF_LIST: REF VECTOR[,LONG]	! Pointer to a list of pointers to RST
			INITIAL(0),	!      entries referenced by the current
					!      command.
    RST$SET_SCOPE: INITIAL(FALSE),	! Flag set to TRUE if DBG$STA_GETSYMBOL
					!      is called from DBG$RST_SETSCOPE
    RST$START_ADDR: INITIAL(0),		! Address of the first Module RST Entry
					!      on the RST module chain.
    RST$TEMP_LIST: INITIAL(0),		! Pointer to Temporary RST Entry List
    SAT$START_ADDR: INITIAL(0),		! Address of first Static Address Table
					!      (SAT) entry on Program SAT chain
    SCOPE$LIST: REF SCOPE$ENTRY;	! Pointer to current Scope List

LITERAL
    RST$K_HASHTBLSIZE	= 251;		! The size of the RST Hash Table

OWN
    DBG$HASH_INDEX,			! Hash index used to communicate between
					!      routines DBG$HASH_FIND_SETUP and
					!      DBG$HASH_FIND
    DBG$HASH_RSTPTR: REF RST$ENTRY	! Pointer to current RST entry on the
		INITIAL(0),		!      current hash chain--used to com-
					!      municate between DBG$HASH_FIND
					!      and DBG$HASH_FIND_SETUP
    EXEFAB: $FAB(),			! RMS File Access Block (FAB) for the
					!      executable image file
    EXERAB: $RAB(),			! RMS Record Access Block (RAB) for the
					!      executable image file
    MOD_BEING_BUILT,			! Pointer to RST entry for module being
					!      built--used to communicate with
					!      error handler.
    RST$HASH_TABLE: 			! The RST Hash Table--a vector of list
	VECTOR[2*RST$K_HASHTBLSIZE],	!      heads for RST hash chains.
    TYPRSTLOC: REF VECTOR[,LONG],	! Pointer to next available location in
					!      the current Type RST Entry block
    TYPRSTPTR: REF RST$ENTRY;		! Pointer to the current Type RST Entry

GLOBAL ROUTINE DBG$GET_DST_NAME(DSTPTR) =
!
! FUNCTION
!	This routine accepts a pointer to a DST entry and returns the address of
!	the counted string that contains the name of that DST symbol.  If there
!	is no name field in the specified DST entry, an error is signalled.
!
! INPUTS
!	DSTPTR	- A pointer to the Debug Symbol Table entry whose name field is
!		  to be located.
!
! OUTPUTS
!	The address of the counted string containing the symbol name is returned
!		  as DBG$GET_DST_NAME's value.
!

    BEGIN

    MAP
	DSTPTR: REF DST$RECORD;		! Pointer to the input DST record

    LOCAL
	BPTR: REF DST$BLI_TRAILER1;	! Pointer to Bliss special cases DST
					!      record's first trailer



    ! Use the DST record type as a CASE index.  For each type of DST record,
    ! we then locate the corresponding name field.
    !
    CASE .DSTPTR[DST$B_TYPE] FROM 0 TO 255 OF
	SET


	! Handle all the DST record types of the "standard" format.
	!
	[DSC$K_DTYPE_LOWEST TO DSC$K_DTYPE_HIGHEST,
	 DST$K_SEPTYP, DST$K_BOOL, DST$K_RECBEG,
	 DST$K_VARBEG, DST$K_ENUMELT, DST$K_ENTRY,
	 DST$K_LABEL, DST$K_LBLORLIT, DST$K_BLIFLD,
	 DST$K_COB_HACK]:
	    RETURN DSTPTR[DST$B_NAME];


	! Handle the Module-Begin record.
	!
	[DST$K_MODBEG]:
	    RETURN DSTPTR[DST$B_MODBEG_NAME];


	! Handle the Routine-Begin record.
	!
	[DST$K_RTNBEG]:
	    RETURN DSTPTR[DST$B_RTNBEG_NAME];


	! Handle the Lexical Block-Begin record.
	!
	[DST$K_BLKBEG]:
	    RETURN DSTPTR[DST$B_BLKBEG_NAME];


	! Handle the PSECT record.
	!
	[DST$K_PSECT]:
	    RETURN DSTPTR[DST$B_PSECT_NAME];


	! Handle the Bliss Special Cases record.
	!
	[DST$K_BLI]:
	    BEGIN
	    BPTR = DSTPTR[DST$A_BLI_TRLR1] + .DSTPTR[DST$B_BLI_LNG];
	    RETURN BPTR[DST$B_BLI_NAME];
	    END;


	! Handle the Enumeration Type Begin record.
	!
	[DST$K_ENUMBEG]:
	    RETURN DSTPTR[DST$B_ENUMBEG_NAME];


	! Handle the Type Specification DST record.
	!
	[DST$K_TYPSPEC]:
	    RETURN DSTPTR[DST$B_TYPSPEC_NAME];


	! Handle all DST records which do not have symbol name fields by signal-
	! ling an internal coding error.
	[INRANGE]:
	    SIGNAL(DBG$_DEBUGBUG, 1, 155);


	TES;


    ! We should never get here--if we do, signal an internal coding error.
    !
    SIGNAL(DBG$_DEBUGBUG, 1, 156);
    RETURN 0;

    END;

GLOBAL ROUTINE DBG$HASH_FIND(NAMEPTR) =
!
! FUNCTION
!	This routine looks up a specified symbol name in the RST Hash Table and
!	returns a pointer to the corresponding RST entry.  This routine is al-
!	ways used in conjunction with routine DBG$HASH_FIND_SETUP.  Since there
!	can in general be many RST entries with the same symbolic name, there
!	has to be a way of finding all such entries.  DBG$HASH_FIND_SETUP is
!	thus called to compute the initial hash index and to intialize this
!	search.  DBG$HASH_FIND can then be called repeatedly to find each indi-
!	vidual occurrence of the given name in the RST.  When no more RST
!	entries with that name are found, a zero RST pointer is returned.
!
! INPUTS
!	NAMEPTR	- A pointer to the counted string that gives the name of the
!		  symbol to be looked up.  This name must be a single symbol
!		  name, not a complete pathname.
!
!	The OWN variables DBG$HASH_RSTPTR and DBG$HASH_INDEX are implicit
!		  inputs.  These variables are set by DBG$HASH_FIND_SETUP
!		  initially.  Of these, variable DBG$HASH_RSTPTR is updated
!		  by this routine.
!
! OUTPUTS
!	A pointer to the next RST entry with the specified symbol name is
!		  returned as the routine's value.  If there are no more RST
!		  entries with that name, zero is returned.
!
!	DBG$HASH_RSTPTR is an implicit output.  It is updated to contain the
!		  returned RST pointer.
!

    BEGIN

    MAP
	NAMEPTR: REF VECTOR[,BYTE];	! A pointer to a counted string contain-
					!      ing the desired symbol name

    LOCAL
	DSTNAMEPTR: REF VECTOR[,BYTE];	! Pointer to DST name counted string



    ! Loop through the current RST hash chain until the chain ends, i.e. until
    ! we get back to the chain list head.  For each RST entry, we see if it has
    ! the name we are searching for.  If it does, we return it to the caller.
    !
    IF .DBG$HASH_RSTPTR EQL 0 THEN SIGNAL(DBG$_DEBUGBUG, 1, 158);
    DBG$HASH_RSTPTR = .DBG$HASH_RSTPTR[RST$L_HASH_FLINK];
    WHILE .DBG$HASH_RSTPTR NEQ RST$HASH_TABLE[2*.DBG$HASH_INDEX] DO
	BEGIN
	IF .DBG$HASH_RSTPTR[RST$V_GLOBAL]
	THEN
	    DBG$STA_SYMNAME(.DBG$HASH_RSTPTR, DSTNAMEPTR)
	ELSE
	    DSTNAMEPTR = DBG$GET_DST_NAME(.DBG$HASH_RSTPTR[RST$L_DSTPTR]);

	IF CH$EQL(.NAMEPTR[0], NAMEPTR[1], .DSTNAMEPTR[0], DSTNAMEPTR[1], 0)
	THEN
	    RETURN .DBG$HASH_RSTPTR;

	DBG$HASH_RSTPTR = .DBG$HASH_RSTPTR[RST$L_HASH_FLINK];
	END;


    ! The hash chain ended before we found another RST symbol with the same
    ! name.  Set DBG$HASH_RSTPTR to zero and return that as the routine value.
    !
    DBG$HASH_RSTPTR = 0;
    RETURN 0;

    END;

GLOBAL ROUTINE DBG$HASH_FIND_SETUP(NAMEPTR): NOVALUE =
!
! FUNCTION
!	This routine sets up a search through the RST hash table for a specified
!	symbol name.  The routine computes the symbol's hash index and saves it
!	and a pointer to the corresponding RST hash chain's list head in OWN
!	variables where they can be accessed by routine DBG$HASH_FIND.  After
!	the initial DBG$HASH_FIND_SETUP call, DBG$HASH_FIND should be called
!	repeatedly to find all RST entries with the specified symbol name.
!
!	Note that the hashing method is encoded both here and in routine
!	DBG$HASH_INSERT.  If it is changed in one place, it must be changed
!	in the other as well.
!
! INPUTS
!	NAMEPTR	- A pointer to the counted string that gives the name of the
!		  symbol to be looked up.  This name must be a single symbol
!		  name, not a complete pathname.
!
! OUTPUTS
!	No value is returned by DBG$HASH_FIND_SETUP.
!
!	There are two implicit outputs: DBG$HASH_INDEX and DBG$HASH_RSTPTR
!		  are set so they can be used by routine DBG$HASH_FIND.
!

    BEGIN

    MAP
	NAMEPTR: REF VECTOR[,BYTE];	! Pointer to symbol name counted string



    ! Compute the hash index for the specified symbol name.  Set DBG$HASH_INDEX
    ! and DBG$HASH_RSTPTR so they can be used by the DBG$HASH_FIND routine.
    !
    DBG$HASH_INDEX = 0;
    INCR I FROM 0 TO .NAMEPTR[0] DO
	DBG$HASH_INDEX = .DBG$HASH_INDEX + .NAMEPTR[.I];

    DBG$HASH_INDEX = .DBG$HASH_INDEX MOD RST$K_HASHTBLSIZE;
    DBG$HASH_RSTPTR = RST$HASH_TABLE[2*.DBG$HASH_INDEX];
    RETURN;

    END;

GLOBAL ROUTINE DBG$HASH_INSERT(RSTPTR): NOVALUE =
!
! FUNCTION
!	This routine inserts an RST entry in the RST Hash Table.  The symbolic
!	name associated with the RST entry is looked up the DST and is hashed.
!	The RST entry is then linked into the corresponding hash chain.
!
!	Note that the hashing method is encoded both here and in routine
!	DBG$HASH_FIND_SETUP.  If it is changed in one place, it must thus
!	be changed in the other as well.
!
! INPUTS
!	RSTPTR	- A pointer to the RST entry to be inserted in the hash table.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	RSTPTR: REF RST$ENTRY;		! A pointer to the RST entry to be
					!      inserted in the RST Hash Table

    LOCAL
	HASHINDEX,			! The computed hash index.
	NAMEPTR: REF VECTOR[,BYTE],	! Pointer to symbol name (counted ASCII)
	NEXTPTR: REF RST$ENTRY,		! A pointer to the RST entry in the hash
					!      chain before which the new RST
					!      entry is inserted.
	PREVPTR: REF RST$ENTRY;		! A pointer to the RST entry in the hash
					!      chain after which the new RST
					!      entry is inserted.



    ! Get the RST entry's symbol name from the DST and compute its hash index.
    !
    IF .RSTPTR[RST$V_GLOBAL]
    THEN
	DBG$STA_SYMNAME(.RSTPTR, NAMEPTR)
    ELSE
	NAMEPTR = DBG$GET_DST_NAME(.RSTPTR[RST$L_DSTPTR]);

    HASHINDEX = 0;
    INCR I FROM 0 TO .NAMEPTR[0] DO
	HASHINDEX = .HASHINDEX + .NAMEPTR[.I];

    HASHINDEX = .HASHINDEX MOD RST$K_HASHTBLSIZE;


    ! Link the RST entry into the appropriate hash chain.
    !
    PREVPTR = RST$HASH_TABLE[2*.HASHINDEX];
    NEXTPTR = .PREVPTR[RST$L_HASH_FLINK];
    RSTPTR[RST$L_HASH_FLINK] = .NEXTPTR;
    RSTPTR[RST$L_HASH_BLINK] = .PREVPTR;
    PREVPTR[RST$L_HASH_FLINK] = .RSTPTR;
    NEXTPTR[RST$L_HASH_BLINK] = .RSTPTR;
    RETURN;

    END;

GLOBAL ROUTINE DBG$RST_BUILD(MODRSTPTR): NOVALUE =
!
! FUNCTION
!	This routine builds the RST for a specified module.  It takes as input a
!	pointer to the desired module's Module RST Entry.  From that it can get
!	to the module's DST records which are scanned until the Module-End DST
!	record is found.  For each DST record, a corresponding RST entry is cre-
!	ated if appropriate.  Each such RST entry is added to the module's sym-
!	bol chain and to the RST Hash Table.  Symbols with static addresses are
!	added to the module's Static Address Table (SAT) as well.
!
! INPUTS
!	MODRSTPTR - A pointer to the Module RST Entry of the module whose RST
!		  is to be built.
!
! OUTPUTS
!	The RST for the specified module is constructed.  No value is returned.
!

    BEGIN

    MAP
	MODRSTPTR: REF RST$ENTRY;	! Pointer to the Module RST Entry of the
					!      module whose RST is to be built

    LITERAL
	MAX_NESTING	= 50;		! Maximum lexical and record component
					!      nesting we will allow

    FIELD RS_FIELDS =			! Field definitions for RECSTACK array
	SET				!      to handle nested data records
	RS_CLPTR	= [ 0, L_ ],	! Component list pointer
	RS_CLSIZ	= [ 1, L_ ],	! Component list size
	RS_RCDST	= [ 2, L_ ],	! Record Begin DST address
	RS_VRPTR	= [ 3, L_ ],	! Variant record pointer
	RS_TRSIZ	= [ 4, L_ ]	! Type record size in longwords
	TES;

    LOCAL
	ADDRESS,			! Static address to be added to SAT
	ARRAY_FLAG,			! Flag set if item is array of records
	BLIFLG,				! Flag set if current language is BLISS
	BLINK: REF RST$ENTRY,		! RST entry backward hash link
	COBOLGBL_FLAG,			! Flag set to TRUE is the COBOL "global"
					!      attribute applies to the next
					!      symbol defined in the DST
	COMP_LST_PTR: REF VECTOR[,LONG],! Pointer to current component list
	COMP_LST_SIZE,			! Size of current component list block
	DSTPTR: REF DST$RECORD,		! Pointer to the current DST record
	DSTPTR_TO_SAVE,			! The DST pointer to be saved in the
					!      current RST entry
	DST_TYPE,			! The DST type of the current DST record
	ENUM_BITSIZE,			! Bit-size of current enumeration type
	ENUMELT: REF VECTOR[,LONG],	! Pointer to enumeration element list in
					!      the Type RST Entry
	ENUM_DSTPTR,			! Pointer to Enumeration Type Begin DST
					!      record for current enum type
	ENUM_LST_PTR: REF VECTOR[,LONG],! Pointer to list block used to accumu-
					!      late enumeration type elements
	ENUM_LST_SIZE,			! Size of the ENUM_LST_PTR memory block
	FLINK: REF RST$ENTRY,		! RST entry forward hash link
	LENGTH,				! Length of static address to add to SAT
	MODNAMEPTR,			! Pointer to the module name as Counted
					!      ASCII--used for error messages
	NAMEPTR,			! Pointer to symbol name counted ASCII
	NEST_FLAG,			! Set to TRUE if the new RST entry def-
					!      ines a new level of nesting
	NESTING,			! Current DST record nesting depth
	NEST_STACK: VECTOR[MAX_NESTING],! Stack containing RST pointers for
					!      nested DST items: lexical enti-
					!      ties and record components
	NEWENT_FLAG,			! Flag set to TRUE if a new RST entry is
					!      being built from this DST record
	PPTR: REF DST$PSECT_TRAILER,	! Pointer to PSECT DST record trailer
	RECBEGTRLR:			! Pointer to Record Begin DST record's
		REF DST$RECBEG_TRLR,	!      trailer fields
	REC_DSTPTR: REF DST$RECORD,	! Pointer to Record Begin DST record
	RECSTACK: BLOCKVECTOR		! Record stack to keep track of nested
		[MAX_NESTING, 5]	!      record and variant definitions
		FIELD(RS_FIELDS),	!
	RSPTR,				! Current RECSTACK index (next available
					!      location in RECSTACK)
	RSTPTR: REF RST$ENTRY,		! Pointer to the RST entry we are
					!      currently building
	STATIC_FLAG,			! Flag set to TRUE for static data items
	SYMCHNPTR: REF RST$ENTRY,	! Pointer to the last entry on the mod-
					!      ule's symbol chain
	TAGDSTPTR,			! Address of the DST record of a record
					!      variant's tag variable
	TAGRSTPTR,			! Address of the RST entry of a record
					!      variant's tag variable
	TYPE_DST_LST: REF VECTOR[,LONG],! Pointer to DST part of DST to RST
					!      translate table for type entries
	TYPE_DST_LEN,			! Size of TYPE_RST_LST memory block
	TYPEPTR: REF RST$ENTRY,		! Pointer to Type RST Entry
	TYPE_RST_LST: REF VECTOR[,LONG],! Pointer to RST part of DST to RST
					!      translate table for type entries
	TYPE_RST_LEN,			! Size of TYPE_DST_LST memory block
	TYPREFTBL: REF VECTOR[,LONG],	! Pointer to Type RST Entry's type
					!      reference table
	TYP_RST_SIZE,			! Size in longwords needed for the Type
					!      RST memory block being built
	UNNEST_FLAG,			! Set to TRUE if this DST entry termi-
					!      nates a level of DST nesting
	VARBEG_DSTPTR:			! Pointer to the Variant-Set Begin DST
		REF DST$VARBEG_TRAILER,	!      record trailer fields
	VARIANT_VALUE_FOUND,		! Set to TRUE when a DST$K_VARVAL
					!      record has been found
	VAR_REC_PTR: REF RST$ENTRY;	! Pointer to the current Variant RST
					!      Entry being built

    ENABLE
	RST_BUILD_ERROR_HANDLER;	! Set up error handler for DBG$_NOFREE



    ! We have declared an error handler to handle the DBG$_NOFREE condition,
    ! i.e. running out of memory while building the module's RST.  The handler 
    ! removes the partially built module from the RST.  We set the address of
    ! the Module RST Entry in MOD_BEING_BUILT for the error handler to use.
    !
    MOD_BEING_BUILT = .MODRSTPTR;


    ! If the module's RST has already been built, we return immediately.
    ! Otherwise, we set the Module-in-RST flag and continue processing.
    !
    IF .MODRSTPTR[RST$B_KIND] NEQ RST$K_MODULE THEN SIGNAL(DBG$_DEBUGBUG,1,151);
    IF .MODRSTPTR[RST$V_MOD_IN_RST] THEN RETURN;
    MODRSTPTR[RST$V_MOD_IN_RST] = TRUE;


    ! Mark this as the Most Recently Used module.  (The Most Recently Used mod-
    ! ule will not be removed by DBG$GET_MEMORY to get more free space.)
    !
    DBG$RST_MOST_RECENT(.MODRSTPTR);


    ! Set the Debug Symbol Table (DST) pointer to point to the first DST record
    ! after the specified module's Module-Begin record.
    !
    DSTPTR = .MODRSTPTR[RST$L_DSTPTR];
    MODNAMEPTR = DSTPTR[DST$B_MODBEG_NAME];
    DSTPTR = DSTPTR[DST$A_NEXT] + .DSTPTR[DST$B_LENGTH];


    ! Set BLIFLG if the module's language is BLISS.  If the language is BLISS
    ! we remove duplicate names in the code that follows.
    !
    BLIFLG = .MODRSTPTR[RST$B_LANGUAGE] EQL DBG$K_BLISS;


    ! Initialize the module's Static Address Table pointer to zero.  Also set up
    ! the module's symbol chain pointer.  Clear a random flag as well.
    !
    MODRSTPTR[RST$L_SAT_PTR] = 0;
    SYMCHNPTR = .MODRSTPTR;
    COBOLGBL_FLAG = FALSE;


    ! Initialize the lexical nesting stack to have one entry pointing to the
    ! Module RST Entry.
    !
    NESTING = 0;
    NEST_STACK[0] = .MODRSTPTR;


    ! Initialize the record and variant nesting stack to be empty and initialize
    ! the variables which keep track of record and variant components.
    !
    RSPTR = 0;
    COMP_LST_PTR = 0;
    COMP_LST_SIZE = 0;
    REC_DSTPTR = 0;
    VAR_REC_PTR = 0;
    TYP_RST_SIZE = 0;
    ENUM_LST_PTR = 0;


    ! Now loop over the whole DST for this module.  For each DST record we find,
    ! we build the appropriate RST record and link all such records on the mod-
    ! ule's symbol chain.  Each such symbol is also inserted in the RST Hash
    ! Table.
    !
    WHILE TRUE DO
	BEGIN


	! Initialize flags for this DST record and get the DST record type.
	!
	NEWENT_FLAG = FALSE;
	NEST_FLAG = FALSE;
	UNNEST_FLAG = FALSE;
	DSTPTR_TO_SAVE = .DSTPTR;
	IF .DSTPTR LSSU .DST$END_ADDR
	THEN
	    DST_TYPE = .DSTPTR[DST$B_TYPE]
	ELSE
	    DST_TYPE = DST$K_MODBEG;


	! Now handle each type of DST record individually.
	!
	CASE .DST_TYPE FROM 0 TO 255 OF
	    SET


	    ! Handle the Module-Begin record.  Since the Module-End record seems
	    ! to be missing, we signal an error and terminate the DST scan.
	    !
	    [DST$K_MODBEG]:
		BEGIN
		SIGNAL(DBG$_MISMODEND, 1, .MODNAMEPTR);
		EXITLOOP;
		END;


	    ! Handle the Module-End record.  Terminate the DST scan normally
	    ! after checking that the nesting level is down to 1.
	    !
	    [DST$K_MODEND]:
		BEGIN
		IF .NESTING NEQ 0 THEN SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);
		EXITLOOP;
		END;


	    ! Handle the PSECT record.  Enter it in the symbol table only if
	    ! the language is MACRO.  Also make a Static Address Table entry.
	    !
	    [DST$K_PSECT]:
		BEGIN
		IF .MODRSTPTR[RST$B_LANGUAGE] EQL DBG$K_MACRO
		THEN
		    BEGIN


		    ! See if there already is a label with the same name as the
		    ! PSECT name (PSECTs are always declared last in MACRO).  If
		    ! so, do not build a Label RST Entry for the PSECT.
		    !
		    NAMEPTR = DBG$GET_DST_NAME(.DSTPTR);
		    DBG$HASH_FIND_SETUP(.NAMEPTR);
		    WHILE TRUE DO
			BEGIN
			RSTPTR = DBG$HASH_FIND(.NAMEPTR);


			! If there is no previous definition for the PSECT name,
			! make a Label RST Entry for it.  Also make a Static
			! Address Table entry.
			!
			IF .RSTPTR EQL 0
			THEN
			    BEGIN
			    RSTPTR = DBG$GET_MEMORY(RST$K_LBLENTSIZ);
			    RSTPTR[RST$B_KIND] = RST$K_LABEL;
			    RSTPTR[RST$L_STARTADDR] = .DSTPTR[DST$L_PSECT_VALUE];
			    NEWENT_FLAG = TRUE;
			    PPTR = DSTPTR[DST$A_PSECT_TRLR_BASE]
					+ .DSTPTR[DST$B_PSECT_TRLR_OFFS];
			    LENGTH = .PPTR[DST$L_PSECT_SIZE];
			    RSTPTR[RST$V_NONZLENGTH] = TRUE;
			    STATIC_ADDRESS(.RSTPTR[RST$L_STARTADDR], .LENGTH,
				.RSTPTR, MODRSTPTR[RST$L_SAT_PTR], FALSE);
			    EXITLOOP;
			    END;


			! If there already is a definition for the PSECT name in
			! the current scope (i.e., the user defined a label by
			! the same name), exit the name search loop without
			! making a Label RST Entry for the PSECT.
			!
			IF .RSTPTR[RST$L_UPSCOPEPTR] EQL .NEST_STACK[.NESTING]
			THEN
			    EXITLOOP;

			END;		! End of Hash Table search loop

		    END;		! End of language = MACRO if statement

		END;


	    ! Handle the Routine-Begin record.  Create the Routine RST Entry and
	    ! make a NEST_STACK entry so we know when the matching Routine-End
	    ! record is found (except that MACRO has no Routine-End records).
	    !
	    [DST$K_RTNBEG]:
		BEGIN
		IF .BLIFLG THEN CHECK_DUPLICATE(.DSTPTR, .NEST_STACK[.NESTING]);
		RSTPTR = DBG$GET_MEMORY(RST$K_ROUTENTSIZ);
		RSTPTR[RST$B_KIND] = RST$K_ROUTINE;
		RSTPTR[RST$L_STARTADDR] = .DSTPTR[DST$L_RTNBEG_ADDRESS];
		RSTPTR[RST$L_ENDADDR] = .RSTPTR[RST$L_STARTADDR];
		NEWENT_FLAG = TRUE;
		IF .MODRSTPTR[RST$B_LANGUAGE] EQL DBG$K_MACRO
		THEN
		    STATIC_ADDRESS(.RSTPTR[RST$L_STARTADDR], 0, .RSTPTR,
					MODRSTPTR[RST$L_SAT_PTR], FALSE)
		ELSE
		    NEST_FLAG = TRUE;

		END;


	    ! Handle the Routine-End record.  Compute the routine end address,
	    ! add it to the Routine RST Entry, make a Static Address Table
	    ! entry, and pop NEST_STACK.
	    !
	    [DST$K_RTNEND]:
		BEGIN
		RSTPTR = .NEST_STACK[.NESTING];
		IF .RSTPTR[RST$B_KIND] NEQ RST$K_ROUTINE
		THEN
		    SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);

		LENGTH = .DSTPTR[DST$L_RTNEND_SIZE];
		IF .LENGTH LSS 1 THEN LENGTH = 1;
		RSTPTR[RST$L_ENDADDR] = .RSTPTR[RST$L_STARTADDR] + .LENGTH - 1;
		RSTPTR[RST$V_NONZLENGTH] = TRUE;
		STATIC_ADDRESS(.RSTPTR[RST$L_STARTADDR], .LENGTH, .RSTPTR,
					MODRSTPTR[RST$L_SAT_PTR], FALSE);
		UNNEST_FLAG = TRUE;
		END;


	    ! Handle the Lexical Block-Begin record.  Create the Lexical Block
	    ! RST Entry and push the block on NEST_STACK.
	    !
	    [DST$K_BLKBEG]:
		BEGIN
		RSTPTR = DBG$GET_MEMORY(RST$K_LEXENTSIZ);
		RSTPTR[RST$B_KIND] = RST$K_BLOCK;
		RSTPTR[RST$L_STARTADDR] = .DSTPTR[DST$L_BLKBEG_ADDRESS];
		RSTPTR[RST$L_ENDADDR] = .RSTPTR[RST$L_STARTADDR];
		NEWENT_FLAG = TRUE;
		NEST_FLAG = TRUE;
		END;


	    ! Handle the Lexical Block-End record.  Compute the block's end ad-
	    ! dress, add it to the RST entry, make a Static Address Table entry,
	    ! and pop NEST_STACK.
	    !
	    [DST$K_BLKEND]:
		BEGIN
		RSTPTR = .NEST_STACK[.NESTING];
		IF .RSTPTR[RST$B_KIND] NEQ RST$K_BLOCK
		THEN
		    SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);

		LENGTH = .DSTPTR[DST$L_BLKEND_SIZE];
		IF .LENGTH LSS 1 THEN LENGTH = 1;
		RSTPTR[RST$L_ENDADDR] = .RSTPTR[RST$L_STARTADDR] + .LENGTH - 1;
		RSTPTR[RST$V_NONZLENGTH] = TRUE;
		STATIC_ADDRESS(.RSTPTR[RST$L_STARTADDR], .LENGTH, .RSTPTR,
					MODRSTPTR[RST$L_SAT_PTR], FALSE);
		UNNEST_FLAG = TRUE;
		END;


	    ! Handle the Static Link record.  Just put a pointer to this DST
	    ! record in the Routine RST Entry currently on top of the nesting
	    ! stack.  If the top of the nesting stack is not a routine, signal
	    ! an error.
	    !
	    [DST$K_STATLINK]:
		BEGIN
		RSTPTR = .NEST_STACK[.NESTING];
		IF .RSTPTR[RST$B_KIND] NEQ RST$K_ROUTINE
		THEN
		    SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);

		RSTPTR[RST$L_STATIC_LINK] = .DSTPTR;
		END;


	    ! Handle the Label record.  Create a Label RST Entry for it and make
	    ! a Static Address Table entry.
	    !
	    [DST$K_LABEL]:
		BEGIN
		IF .BLIFLG THEN CHECK_DUPLICATE(.DSTPTR, .NEST_STACK[.NESTING]);
		RSTPTR = BUILD_LABEL_RST(.DSTPTR);
		DSTPTR_TO_SAVE = .RSTPTR[RST$L_DSTPTR];
		RSTPTR[RST$B_KIND] = RST$K_LABEL;
		RSTPTR[RST$L_STARTADDR] = .DSTPTR[DST$L_VALUE];
		NEWENT_FLAG = TRUE;
		STATIC_ADDRESS(.RSTPTR[RST$L_STARTADDR], 0, .RSTPTR,
					MODRSTPTR[RST$L_SAT_PTR], FALSE);
		END;


	    ! Handle the Label-or-Literal record.  If this is an instruction
	    ! label, create a Label RST Entry and a Static Address Table entry.
	    ! If this is a literal, create a Data Item RST Entry for it.
	    !
	    [DST$K_LBLORLIT]:
		BEGIN
		IF .BLIFLG THEN CHECK_DUPLICATE(.DSTPTR, .NEST_STACK[.NESTING]);
		IF .DSTPTR[DST$B_VFLAGS] EQL 1
		THEN
		    BEGIN
		    RSTPTR = BUILD_LABEL_RST(.DSTPTR);
		    DSTPTR_TO_SAVE = .RSTPTR[RST$L_DSTPTR];
		    RSTPTR[RST$B_KIND] = RST$K_LABEL;
		    RSTPTR[RST$L_STARTADDR] = .DSTPTR[DST$L_VALUE];
		    STATIC_ADDRESS(.RSTPTR[RST$L_STARTADDR], 0, .RSTPTR,
					MODRSTPTR[RST$L_SAT_PTR], FALSE);
		    END

		ELSE
		    BEGIN
		    RSTPTR = DBG$GET_MEMORY(RST$K_DATENTSIZ);
		    RSTPTR[RST$B_KIND] = RST$K_DATA;
		    RSTPTR[RST$L_TYPEPTR] = 0;
		    END;

		NEWENT_FLAG = TRUE;
		END;


	    ! Handle the Entry-Point record.  Create an Entry-Point RST Entry
	    ! for it and make a Static Address Table entry.
	    !
	    [DST$K_ENTRY]:
		BEGIN
		RSTPTR = DBG$GET_MEMORY(RST$K_EPTENTSIZ);
		RSTPTR[RST$B_KIND] = RST$K_ENTRY;
		RSTPTR[RST$L_STARTADDR] = .DSTPTR[DST$L_VALUE];
		NEWENT_FLAG = TRUE;
		STATIC_ADDRESS(.RSTPTR[RST$L_STARTADDR], 0, .RSTPTR,
					MODRSTPTR[RST$L_SAT_PTR], FALSE);
		END;


	    ! Handle the Record-Begin record.  Generate a Data Item RST Entry
	    ! for the record unless this is just a Type definition.  Then stack
	    ! the information which keeps track of the currently open record
	    ! definition (if any) and set up the same information for this new
	    ! record.
	    !
	    [DST$K_RECBEG]:
		BEGIN


		! Generate a Data Item RST Entry if this is a data record defin-
		! ition (not just a Type definition).
		!
		IF .DSTPTR[DST$B_VFLAGS] NEQ DST$K_VFLAGS_NOVAL
		THEN
		    BEGIN
		    RSTPTR = DBG$GET_MEMORY(RST$K_DATENTSIZ);
		    RSTPTR[RST$B_KIND] = RST$K_DATA;
		    RSTPTR[RST$L_TYPEPTR] = .DSTPTR;
		    RSTPTR[RST$V_SET_TYPEPTR] = TRUE;
		    NEWENT_FLAG = TRUE;
		    IF .COMP_LST_PTR EQL 0
		    THEN
			BEGIN
			STATIC_CHECK(.DSTPTR, ADDRESS, LENGTH, STATIC_FLAG);
			IF .STATIC_FLAG
			THEN
			    BEGIN
			    IF .LENGTH NEQ 0 THEN RSTPTR[RST$V_NONZLENGTH] = TRUE;
			    STATIC_ADDRESS(.ADDRESS, .LENGTH, .RSTPTR,
					MODRSTPTR[RST$L_SAT_PTR], FALSE);
			    END;

			END

		    ELSE
			COMP_LIST_ADD_ENTRY(COMP_LST_PTR,COMP_LST_SIZE,.RSTPTR);

		    END;


		! Stack the variables which keep track of the current record
		! definition (if any).  Then set these variables up to keep
		! track of this new record definition.
		!
		IF .RSPTR GEQ MAX_NESTING
		THEN
		    SIGNAL(DBG$_DSTNESDEP, 1, .MODNAMEPTR);

		RECSTACK[.RSPTR, RS_CLPTR] = .COMP_LST_PTR;
		RECSTACK[.RSPTR, RS_CLSIZ] = .COMP_LST_SIZE;
		RECSTACK[.RSPTR, RS_RCDST] = .REC_DSTPTR;
		RECSTACK[.RSPTR, RS_VRPTR] = .VAR_REC_PTR;
		RECSTACK[.RSPTR, RS_TRSIZ] = .TYP_RST_SIZE;
		RSPTR = .RSPTR + 1;
		COMP_LST_PTR = DBG$GET_MEMORY(11);
		COMP_LST_SIZE = 10;
		REC_DSTPTR = .DSTPTR;
		VAR_REC_PTR = 0;
		TYP_RST_SIZE = RST$K_TYPENTSIZ;
		END;


	    ! Handle the Record-End record.  Here we create the Data Type RST
	    ! Entry for the record type.  We then pop the record stack to re-
	    ! store the context for any outer record definition.
	    !
	    [DST$K_RECEND]:
		BEGIN
		IF .VAR_REC_PTR NEQ 0
		THEN
		    SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);


		! Build the Data Type RST Entry for the record type.
		!
		TYP_RST_SIZE = .TYP_RST_SIZE + .COMP_LST_PTR[0];
		RSTPTR = DBG$GET_MEMORY(.TYP_RST_SIZE);
		RSTPTR[RST$B_KIND] = RST$K_TYPE;
		RSTPTR[RST$B_FCODE] = RST$K_TYPE_RECORD;
		RECBEGTRLR = REC_DSTPTR[DST$B_NAME] + 1 + .REC_DSTPTR[DST$B_NAME];
		RSTPTR[RST$L_BITSIZE] = .RECBEGTRLR[DST$L_RECBEG_SIZE];
		DSTPTR_TO_SAVE = .REC_DSTPTR;
		NEWENT_FLAG = TRUE;


		! Now copy all component and variant set lists into the Type RST
		! Entry's memory block after the RST entry proper.  This is done
		! by a call on recursive routine COPY_COMP_LIST.
		!
		TYPRSTPTR = .RSTPTR;
		TYPRSTLOC = RSTPTR[RST$L_TYPCOMPCNT];
		COPY_COMP_LIST(.COMP_LST_PTR);


		! Pop the record stack so we continue the accumulation of record
		! components at the next outer level of record nesting (if any).
		!
		IF .RSPTR LEQ 0 THEN SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);
		RSPTR = .RSPTR - 1;
		COMP_LST_PTR = .RECSTACK[.RSPTR, RS_CLPTR];
		COMP_LST_SIZE = .RECSTACK[.RSPTR, RS_CLSIZ];
		REC_DSTPTR = .RECSTACK[.RSPTR, RS_RCDST];
		VAR_REC_PTR = .RECSTACK[.RSPTR, RS_VRPTR];
		TYP_RST_SIZE = .RECSTACK[.RSPTR, RS_TRSIZ];
		END;


	    ! Handle the Variant-Set Begin record.  This signals the start of a
	    ! set of variants of the current record which all have the same tag
	    ! variable (though the tag variable need not be materialized).  Here
	    ! we find the tag variable and build a Variant RST Entry.  We then
	    ! set up a new component list to accumulate the individual variants
	    ! of this variant set.
	    !
	    [DST$K_VARBEG]:
		BEGIN
		IF .COMP_LST_PTR EQL 0
		THEN
		    SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);


		! Determine the address of the RST entry of the variant set's
		! tag variable if present.  We do this by searching the already
		! existing record components for a symbol with the desired DST
		! pointer.
		!
		VARBEG_DSTPTR = DSTPTR[DST$B_NAME] + 1 + .DSTPTR[DST$B_NAME];
		TAGDSTPTR = .VARBEG_DSTPTR[DST$L_VARBEG_TAG_PTR];
		TAGRSTPTR = 0;
		IF .TAGDSTPTR NEQ 0
		THEN
		    BEGIN
		    TAGDSTPTR = .TAGDSTPTR + .DST$BEGIN_ADDR;
		    INCR I FROM 1 TO .COMP_LST_PTR[0] DO
			BEGIN
			RSTPTR = .COMP_LST_PTR[.I];
			IF (.RSTPTR[RST$L_DSTPTR] EQL .TAGDSTPTR) AND
			   (.RSTPTR[RST$B_KIND] EQL RST$K_DATA)
			THEN
			    BEGIN
			    TAGRSTPTR = .RSTPTR;
			    EXITLOOP;
			    END;

			END;

		    IF .TAGRSTPTR EQL 0
		    THEN
			SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);

		    END;


		! Build a Variant RST Entry for this variant set.  This entry is
		! temporary in the sense that it will eventually be copied into
		! the Type RST Entry for the containing record data type.
		!
		RSTPTR = DBG$GET_MEMORY(RST$K_VARENTSIZ);
		RSTPTR[RST$L_DSTPTR] = .DSTPTR;
		RSTPTR[RST$L_VARTAGPTR] = .TAGRSTPTR;
		RSTPTR[RST$B_KIND] = RST$K_VARIANT;
		COMP_LIST_ADD_ENTRY(COMP_LST_PTR, COMP_LST_SIZE, .RSTPTR);


		! Push the current component list pointer and size on the
		! record stack and set up a new component list for the
		! variant set.
		!
		IF .RSPTR EQL MAX_NESTING
		THEN
		    SIGNAL(DBG$_DSTNESDEP, 1, .MODNAMEPTR);

		RECSTACK[.RSPTR, RS_CLPTR] = .COMP_LST_PTR;
		RECSTACK[.RSPTR, RS_CLSIZ] = .COMP_LST_SIZE;
		RECSTACK[.RSPTR, RS_VRPTR] = .VAR_REC_PTR;
		RSPTR = .RSPTR + 1;
		COMP_LST_PTR = DBG$GET_MEMORY(11);
		COMP_LST_SIZE = 10;
		VAR_REC_PTR = .RSTPTR;
		VARIANT_VALUE_FOUND = FALSE;
		END;


	    ! Handle the Variant-Set End record.  Close out the component list
	    ! of the last variant in the variant set, and then close out the
	    ! whole set.
	    !
	    [DST$K_VAREND]:
		BEGIN
		IF .VAR_REC_PTR EQL 0
		THEN
		    SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);


		! Pop the record stack and put the address of the last variant's
		! component list on the variant set list.
		!
		IF .VARIANT_VALUE_FOUND
		THEN
		    BEGIN
		    TYP_RST_SIZE = .TYP_RST_SIZE + 1 + .COMP_LST_PTR[0];
		    RSTPTR = .COMP_LST_PTR;
		    RSPTR = .RSPTR - 1;
		    IF .RSPTR LEQ 0 THEN SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);
		    COMP_LST_PTR = .RECSTACK[.RSPTR, RS_CLPTR];
		    COMP_LST_SIZE = .RECSTACK[.RSPTR, RS_CLSIZ];
		    COMP_LIST_ADD_ENTRY(COMP_LST_PTR, COMP_LST_SIZE, .RSTPTR);
		    END;


		! Then close out the current variant set by saving the address
		! of the variant set list in the temporary Variant RST Entry.
		! Then pop the record stack to continue accumulating record
		! components for the outer level record definition.
		!
		VARIANT_VALUE_FOUND = TRUE;
		TYP_RST_SIZE = .TYP_RST_SIZE + RST$K_VARENTSIZ + .COMP_LST_PTR[0];
		VAR_REC_PTR[RST$L_SYMCHNPTR] = .COMP_LST_PTR;
		IF .RSPTR LEQ 0 THEN SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);
		RSPTR = .RSPTR - 1;
		COMP_LST_PTR = .RECSTACK[.RSPTR, RS_CLPTR];
		COMP_LST_SIZE = .RECSTACK[.RSPTR, RS_CLSIZ];
		VAR_REC_PTR = .RECSTACK[.RSPTR, RS_VRPTR];
		END;


	    ! Handle the Variant-Value record.  This record defines a new vari-
	    ! ant of the current record and the corresponding tag value.  Close
	    ! out the previous variant (if any) and set things up to accumulate
	    ! the components of this new variant.
	    !
	    [DST$K_VARVAL]:
		BEGIN
		IF .VAR_REC_PTR EQL 0 THEN SIGNAL(DBG$_INCDSTNES,1,.MODNAMEPTR);


		! Unless this is the first variant, pop the record stack and put
		! the address of the last variant's component list on the vari-
		! ant set list.
		!
		IF .VARIANT_VALUE_FOUND
		THEN
		    BEGIN
		    TYP_RST_SIZE = .TYP_RST_SIZE + 1 + .COMP_LST_PTR[0];
		    RSTPTR = .COMP_LST_PTR;
		    RSPTR = .RSPTR - 1;
		    IF .RSPTR LEQ 0 THEN SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);
		    COMP_LST_PTR = .RECSTACK[.RSPTR, RS_CLPTR];
		    COMP_LST_SIZE = .RECSTACK[.RSPTR, RS_CLSIZ];
		    COMP_LIST_ADD_ENTRY(COMP_LST_PTR, COMP_LST_SIZE, .RSTPTR);
		    END;


		! Then set things up to accumulate the components of the new
		! variant definition.  Push the tag value DST pointer on the
		! current variant component list, push the record stack, and
		! set up a component list for the new variant.
		!
		VARIANT_VALUE_FOUND = TRUE;
		COMP_LIST_ADD_ENTRY(COMP_LST_PTR, COMP_LST_SIZE, .DSTPTR);
		IF .RSPTR EQL MAX_NESTING
		THEN
		    SIGNAL(DBG$_DSTNESDEP, 1, .MODNAMEPTR);

		RECSTACK[.RSPTR, RS_CLPTR] = .COMP_LST_PTR;
		RECSTACK[.RSPTR, RS_CLSIZ] = .COMP_LST_SIZE;
		RSPTR = .RSPTR + 1;
		COMP_LST_PTR = DBG$GET_MEMORY(11);
		COMP_LST_SIZE = 10;
		END;


	    ! Handle the Enumeration Type Begin record.  Set up the accumulation
	    ! of the enumeration type elements.
	    !
	    [DST$K_ENUMBEG]:
		BEGIN
		IF .ENUM_LST_PTR NEQ 0
		THEN
		    SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);

		ENUM_DSTPTR = .DSTPTR;
		ENUM_BITSIZE = .DSTPTR[DST$B_ENUMBEG_LENG];
		ENUM_LST_PTR = DBG$GET_MEMORY(11);
		ENUM_LST_SIZE = 10;
		END;


	    ! Handle the Enumeration Type Element record.  Build a Data Item RST
	    ! Entry for the element (it constitutes a literal of the enumeration
	    ! type).  Also add the element to the type's element list.
	    !
	    [DST$K_ENUMELT]:
		BEGIN
		IF .ENUM_LST_PTR EQL 0
		THEN
		    SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);

		RSTPTR = DBG$GET_MEMORY(RST$K_DATENTSIZ);
		RSTPTR[RST$B_KIND] = RST$K_DATA;
		RSTPTR[RST$L_TYPEPTR] = .ENUM_DSTPTR;
		RSTPTR[RST$V_SET_TYPEPTR] = TRUE;
		NEWENT_FLAG = TRUE;
		COMP_LIST_ADD_ENTRY(ENUM_LST_PTR, ENUM_LST_SIZE, .RSTPTR);
		END;


	    ! Handle the Enumeration Type End record.  Build the Data Type RST
	    ! Entry for the enumeration type and include the element list as
	    ! the type's "component" list.  Then clear ENUM_LST_PTR to indicate
	    ! that we are no longer accumulating enumeration type elements.
	    !
	    [DST$K_ENUMEND]:
		BEGIN
		IF .ENUM_LST_PTR EQL 0
		THEN
		    SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);

		RSTPTR = DBG$GET_MEMORY(RST$K_TYPENTSIZ + .ENUM_LST_PTR[0]);
		RSTPTR[RST$B_KIND] = RST$K_TYPE;
		RSTPTR[RST$B_FCODE] = RST$K_TYPE_ENUM;
		RSTPTR[RST$L_BITSIZE] = .ENUM_BITSIZE;
		DSTPTR_TO_SAVE = .ENUM_DSTPTR;
		NEWENT_FLAG = TRUE;
		RSTPTR[RST$L_TYPCOMPCNT] = .ENUM_LST_PTR[0];
		ENUMELT = RSTPTR[RST$A_TYPCOMPLST];
		INCR I FROM 1 TO .ENUM_LST_PTR[0] DO
		    ENUMELT[.I - 1] = .ENUM_LST_PTR[.I];

		DBG$REL_MEMORY(.ENUM_LST_PTR);
		ENUM_LST_PTR = 0;
		END;


	    ! Handle all Data Symbol records.  This includes Boolean records and
	    ! Separate Type Spec records.  Create a Data Item RST Entry for the
	    ! data symbol and make a Static Address Table entry if the data item
	    ! is static.
	    !
	    [DSC$K_DTYPE_LOWEST TO DSC$K_DTYPE_HIGHEST,
	     DST$K_BOOL,
	     DST$K_SEPTYP]:
		BEGIN
		IF .BLIFLG THEN CHECK_DUPLICATE(.DSTPTR, .NEST_STACK[.NESTING]);


		! Build the Data Item RST Entry.
		!
		RSTPTR = DBG$GET_MEMORY(RST$K_DATENTSIZ);
		RSTPTR[RST$B_KIND] = RST$K_DATA;
		RSTPTR[RST$L_TYPEPTR] = 0;
		NEWENT_FLAG = TRUE;


		! If this is a DST$K_SEPTYP record, see if the separate Type
		! Spec record ultimately points to a record or enumeration type
		! definition.  If so, set up the RST$L_TYPEPTR field in the RST
		! entry.  We also set RST$V_MARKBIT if this is an array whose
		! cell type is a record type.
		!
		IF .DSTPTR[DST$B_TYPE] EQL DST$K_SEPTYP
		THEN
		    BEGIN
		    GET_TYPEPTR(.DSTPTR, .MODNAMEPTR, TYPEPTR, ARRAY_FLAG);
		    RSTPTR[RST$L_TYPEPTR] = .TYPEPTR;
		    RSTPTR[RST$V_SET_TYPEPTR] = .TYPEPTR NEQ 0;
		    RSTPTR[RST$V_MARKBIT] = .ARRAY_FLAG;
		    END;


		! If we are not nested in a record definition and if the data
		! item is static, make a Static Address Table entry.
		!
		IF .COMP_LST_PTR EQL 0
		THEN
		    BEGIN
		    STATIC_CHECK(.DSTPTR, ADDRESS, LENGTH, STATIC_FLAG);
		    IF .STATIC_FLAG
		    THEN
			BEGIN
			IF .LENGTH NEQ 0 THEN RSTPTR[RST$V_NONZLENGTH] = TRUE;
			STATIC_ADDRESS(.ADDRESS, .LENGTH, .RSTPTR,
					MODRSTPTR[RST$L_SAT_PTR], FALSE);
			END;

		    END


		! If this is a record component, add the data item to the cur-
		! rent record's component list.  We do not make a SAT entry for
		! a record component (though we may have for the whole record).
		!
		ELSE
		    COMP_LIST_ADD_ENTRY(COMP_LST_PTR, COMP_LST_SIZE, .RSTPTR);

		END;


	    ! Handle the BLISS special cases record.  Here we create a Data Item
	    ! RST Entry for the BLISS data item.  We also make a Static Address
	    ! Table entry if appropriate.
	    !
	    [DST$K_BLI]:
		BEGIN
		IF .BLIFLG THEN CHECK_DUPLICATE(.DSTPTR, .NEST_STACK[.NESTING]);
		RSTPTR = DBG$GET_MEMORY(RST$K_DATENTSIZ);
		RSTPTR[RST$B_KIND] = RST$K_DATA;
		RSTPTR[RST$L_TYPEPTR] = 0;
		NEWENT_FLAG = TRUE;
		STATIC_CHECK(.DSTPTR, ADDRESS, LENGTH, STATIC_FLAG);
		IF .STATIC_FLAG
		THEN
		    BEGIN
		    IF .LENGTH NEQ 0 THEN RSTPTR[RST$V_NONZLENGTH] = TRUE;
		    STATIC_ADDRESS(.ADDRESS, .LENGTH, .RSTPTR,
					MODRSTPTR[RST$L_SAT_PTR], FALSE);
		    END;

		END;


	    ! Handle the BLISS field record.  Just build a Data Item RST Entry.
	    !
	    [DST$K_BLIFLD]:
		BEGIN
		IF .BLIFLG THEN CHECK_DUPLICATE(.DSTPTR, .NEST_STACK[.NESTING]);
		RSTPTR = DBG$GET_MEMORY(RST$K_DATENTSIZ);
		RSTPTR[RST$B_KIND] = RST$K_DATA;
		RSTPTR[RST$L_TYPEPTR] = 0;
		NEWENT_FLAG = TRUE;
		END;


	    ! Handle the COBOL special cases.  Build a Data Item RST Entry.
	    !
	    [DST$K_COB_HACK]:
		BEGIN
		RSTPTR = DBG$GET_MEMORY(RST$K_DATENTSIZ);
		RSTPTR[RST$B_KIND] = RST$K_DATA;
		RSTPTR[RST$L_TYPEPTR] = 0;
		NEWENT_FLAG = TRUE;
		END;


	    ! Handle the COBOL Global Attribute record.  Here we just set the
	    ! COBOL "global" flag.  This flag will then be set in the RST entry
	    ! for the next symbol to be defined in the DST.  This attribute is
	    ! needed to correctly emulate COBOL's scope rules.
	    !
	    [DST$K_COBOLGBL]:
		COBOLGBL_FLAG = TRUE;


	    ! Handle all other cases by ignoring the DST record.
	    !
	    [INRANGE]:
		0;

	    TES;			! End of CASE over the DST record type


	! If a new RST entry is being created from this DST record, fill in the
	! remaining fields, link it into the module's symbol chain, and insert
	! it in the RST Hash Table.
	!
	IF .NEWENT_FLAG
	THEN
	    BEGIN
	    RSTPTR[RST$L_DSTPTR] = .DSTPTR_TO_SAVE;
	    RSTPTR[RST$L_UPSCOPEPTR] = .NEST_STACK[.NESTING];
	    IF .COBOLGBL_FLAG THEN RSTPTR[RST$V_COBOLGBL] = TRUE;
	    COBOLGBL_FLAG = FALSE;
	    SYMCHNPTR[RST$L_SYMCHNPTR] = .RSTPTR;
	    SYMCHNPTR = .RSTPTR;
	    IF .RSTPTR[RST$B_KIND] EQL RST$K_TYPE
	    THEN
		BEGIN
		RSTPTR[RST$L_HASH_FLINK] = .RSTPTR;
		RSTPTR[RST$L_HASH_BLINK] = .RSTPTR;
		END

	    ELSE
		DBG$HASH_INSERT(.RSTPTR);

	    END;


	! If this RST entry defines a new nesting level (either lexical nesting
	! or data record nesting), we push a new entry on NEST_STACK.
	!
	IF .NEST_FLAG
	THEN
	    BEGIN
	    IF .NESTING GEQ MAX_NESTING - 1
	    THEN
		SIGNAL(DBG$_DSTNESDEP, 1, .MODNAMEPTR);

	    NESTING = .NESTING + 1;
	    NEST_STACK[.NESTING] = .RSTPTR;
	    END;


	! If this DST record terminates the current nesting level, pop an entry
	! off the nesting stack.
	!
	IF .UNNEST_FLAG
	THEN
	    BEGIN
	    IF .NESTING LEQ 0 THEN SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);
	    NESTING = .NESTING - 1;
	    END;


	! Advance the DST pointer to the next sequential DST record and loop.
	!
	DSTPTR = DSTPTR[DST$A_NEXT] + .DSTPTR[DST$B_LENGTH];

	END;				! End of WHILE loop over module's DST


    ! Go through the module's symbol chain to construct a DST address to RST
    ! address translate table for Data Type RST Entries which refer to records
    ! or enumeration types.
    !
    TYPE_DST_LST = DBG$GET_MEMORY(11);
    TYPE_DST_LEN = 10;
    TYPE_RST_LST = DBG$GET_MEMORY(11);
    TYPE_RST_LEN = 10;
    RSTPTR = .MODRSTPTR[RST$L_SYMCHNPTR];
    WHILE .RSTPTR NEQ 0 DO
	BEGIN
	IF .RSTPTR[RST$B_KIND] EQL RST$K_TYPE
	THEN
	    BEGIN
	    COMP_LIST_ADD_ENTRY(TYPE_DST_LST, TYPE_DST_LEN,
					.RSTPTR[RST$L_DSTPTR]);
	    COMP_LIST_ADD_ENTRY(TYPE_RST_LST, TYPE_RST_LEN, .RSTPTR);
	    END;

	RSTPTR = .RSTPTR[RST$L_SYMCHNPTR];
	END;


    ! Now use this translate table to fill in the RST$L_TYPEPTR field of Data
    ! Item and Type Component RST Entries which reference the Record-Begin or
    ! Enumeration-Type-Begin DST record of their type.
    !
    RSTPTR = .MODRSTPTR[RST$L_SYMCHNPTR];
    WHILE .RSTPTR NEQ 0 DO
	BEGIN
	IF .RSTPTR[RST$V_SET_TYPEPTR]
	THEN
	    BEGIN
	    INCR I FROM 1 TO .TYPE_DST_LST[0] DO
		BEGIN
		IF .TYPE_DST_LST[.I] EQL .RSTPTR[RST$L_TYPEPTR]
		THEN
		    BEGIN
		    RSTPTR[RST$L_TYPEPTR] = .TYPE_RST_LST[.I];
		    RSTPTR[RST$V_SET_TYPEPTR] = FALSE;
		    EXITLOOP;
		    END;

		END;

	    IF .RSTPTR[RST$V_SET_TYPEPTR]
	    THEN
		SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);

	    END;

	RSTPTR = .RSTPTR[RST$L_SYMCHNPTR];
	END;


    ! Go through the symbol chain to find all Data RST Entries and all Type
    ! Component RST Entries which point to Type RST Entries for Record data
    ! types.  For each such RST entry, increment the RST$W_TYPREFCNT field
    ! in the corresponding Type RST Entry.  At the end of the loop, we will
    ! thus know how many RST entries reference each Record Type RST Entry.
    ! This is the information we need to allocate space for the Type Refer-
    ! ence Table for each Record Type RST Entry.
    !
    RSTPTR = .MODRSTPTR[RST$L_SYMCHNPTR];
    WHILE .RSTPTR NEQ 0 DO
	BEGIN
	IF (.RSTPTR[RST$B_KIND] EQL RST$K_DATA) OR
	   (.RSTPTR[RST$B_KIND] EQL RST$K_TYPCOMP)
	THEN
	    BEGIN
	    IF .RSTPTR[RST$L_TYPEPTR] NEQ 0
	    THEN
		BEGIN
		TYPEPTR = .RSTPTR[RST$L_TYPEPTR];
		IF .TYPEPTR[RST$B_KIND] NEQ RST$K_TYPE
		THEN
		    SIGNAL(DBG$_DEBUGBUG, 1, 192);

		IF .TYPEPTR[RST$B_FCODE] EQL RST$K_TYPE_RECORD
		THEN
		    TYPEPTR[RST$W_TYPREFCNT] = .TYPEPTR[RST$W_TYPREFCNT] + 1;

		END;

	    END;

	RSTPTR = .RSTPTR[RST$L_SYMCHNPTR];
	END;


    ! Now loop through all Type RST Entries, and allocate a "Type Reference
    ! Table" for each such entry with a non-zero reference count.  The type
    ! reference table for each entry will be used to store pointers to all
    ! RST entries which reference this Type RST Entry (i.e., to all symbols
    ! of this data type).
    !
    INCR I FROM 1 TO .TYPE_RST_LST[0] DO
	BEGIN
	TYPEPTR = .TYPE_RST_LST[.I];
	IF .TYPEPTR[RST$W_TYPREFCNT] NEQ 0
	THEN
	    BEGIN
	    TYPEPTR[RST$L_TYPREFTBL] = DBG$GET_MEMORY(.TYPEPTR[RST$W_TYPREFCNT]);
	    TYPEPTR[RST$W_TYPREFCNT] = 0;
	    END;

	END;


    ! To complete the "Type Reference Tables", go through the module's symbol
    ! chain once more.  For each Data or Type Component RST Entry with a type
    ! pointer to a Record Type RST Entry, add that entry's RST pointer to the
    ! Type RST Entry's Type Reference Table.  This data structure is later
    ! used by DBG$STA_GETSYMBOL to find all records which could have a given
    ! symbol as a record component.
    !
    RSTPTR = .MODRSTPTR[RST$L_SYMCHNPTR];
    WHILE .RSTPTR NEQ 0 DO
	BEGIN
	IF (.RSTPTR[RST$B_KIND] EQL RST$K_DATA) OR
	   (.RSTPTR[RST$B_KIND] EQL RST$K_TYPCOMP)
	THEN
	    BEGIN
	    IF .RSTPTR[RST$L_TYPEPTR] NEQ 0
	    THEN
		BEGIN


		! This RST entry has a type pointer.  Add a pointer to the
		! corresponding Type RST Entry's Type Reference Table which
		! points back to this current RST entry.
		!
		TYPEPTR = .RSTPTR[RST$L_TYPEPTR];
		IF .TYPEPTR[RST$B_FCODE] EQL RST$K_TYPE_RECORD
		THEN
		    BEGIN
		    TYPREFTBL = .TYPEPTR[RST$L_TYPREFTBL];
		    TYPREFTBL[.TYPEPTR[RST$W_TYPREFCNT]] = .RSTPTR;
		    TYPEPTR[RST$W_TYPREFCNT] = .TYPEPTR[RST$W_TYPREFCNT] + 1;
		    END;


		! If RST$V_MARKBIT is set, this RST entry is for an array of
		! records and RST$L_TYPEPTR points to the cell type of the
		! array.  This pointer is no longer needed and in fact should
		! no longer be there.  We thus clear it and the mark bit.
		!
		IF .RSTPTR[RST$V_MARKBIT]
		THEN
		    BEGIN
		    RSTPTR[RST$L_TYPEPTR] = 0;
		    RSTPTR[RST$V_MARKBIT] = FALSE;
		    END;

		END;

	    END;

	RSTPTR = .RSTPTR[RST$L_SYMCHNPTR];
	END;


    ! Now release the DST and RST address tables for types to the memory pool.
    ! We are then all done, and can return to the caller.
    !
    DBG$REL_MEMORY(.TYPE_DST_LST);
    DBG$REL_MEMORY(.TYPE_RST_LST);
    RETURN;

    END;

GLOBAL ROUTINE DBG$RST_CANMOD(MODNAMEPTR, LENGTH) =
!
! FUNCTION
!	This routine marks a specified module as being CANCELLED (not SET).
!	The routine accepts the desired module name and its length as input,
!	looks up that name in the RST Module Chain, and marks the module as
!	being not SET.  Alternatively, if no module name is specified, all
!	modules in the RST Module Chain are CANCELLED.
!
! INPUTS
!	MODNAMEPTR - A pointer to the first character of an ASCII string
!		  containing the module name.  If this pointer is zero, it
!		  is assumed that all modules should be marked as not SET.
!
!	LENGTH	- The length in characters of the module name.
!
! OUTPUTS
!	This routine returns the value STS$K_SUCCESS if the module was success-
!		  fully cancelled, or it returns STS$K_SEVERE if the specified
!		  module name does not exist in the RST Module Chain.  If all
!		  modules are cancelled, STS$K_SUCCESS is returned.
!

    BEGIN

    LOCAL
	RSTPTR: REF RST$ENTRY;		! Pointer to the Module RST Entry



    ! If a specific module name was specified, we look up the corresponding
    ! Module RST Entry, mark the module as being CANCELLED (not SET), and remove
    ! the module's RST symbol chain.
    !
    IF .MODNAMEPTR NEQ 0
    THEN
	BEGIN
	RSTPTR = GET_MOD_RST(.MODNAMEPTR, .LENGTH);
	IF .RSTPTR EQL 0 THEN RETURN STS$K_SEVERE;
	RSTPTR[RST$V_MODSET] = FALSE;
	DBG$RST_REMOVE(.RSTPTR);
	RETURN STS$K_SUCCESS;
	END;


    ! No module name was specified.  Go through the whole RST Module Chain (but
    ! ignore the anonymous module) and mark each module as being not SET.  Also
    ! remove each such module's RST symbol chain.
    !
    RSTPTR = .RST$START_ADDR;
    WHILE .RSTPTR NEQ 0 DO
	BEGIN
	IF NOT .RSTPTR[RST$V_ANONMOD]
	THEN
	    BEGIN
	    RSTPTR[RST$V_MODSET] = FALSE;
	    DBG$RST_REMOVE(.RSTPTR);
	    END;

	RSTPTR = .RSTPTR[RST$L_NXTMODPTR];
	END;

    RETURN STS$K_SUCCESS;

    END;

GLOBAL ROUTINE DBG$RST_INIT(IMGFILCHAN, FILENAME, 
    			    IMG_HEADER, TRANSFER_ADDR): NOVALUE =
!
! FUNCTION
!	This routine initializes the Debug Symbol Table (DST) and the Run-Time
!	Symbol Table (RST) when the Debugger is first invoked.  It locates the
!	DST in the user's executable image file and maps it into the Debugger's
!	(and thus the user's) virtual address space.  It does the same with the
!	Global Symbol Table (GST).  Thereafter, it scans the entire DST to find
!	all modules which have DST records.  For each such module, the amount of
!	RST space required for the module is recorded, the static address bounds
!	of the module are entered in the Program Static Address Table (SAT), and
!	a Module RST Entry is constructed.  The RST Hash Table is also initial-
!	ized and all module names are entered in it.  Finally, enough free memo-
!	ry space is allocated to accommodate the RSTs of the largest several
!	modules.  Thus it should always be possible to have several modules in
!	the RST at the same time no matter how large they are.
!
! INPUTS
!
!	IMGFILCHAN - The channel that the image file is open on 
!
!	FILENAME - The address of a Counted ASCII string containing the file-
!		  name of the executable image file.
!
!	IMG_HEADER - The address (in memory) of the executable image file's
!		  header block.
!
!	TRANSFER_ADDR - The program transfer address.  This is used only to
!		  select the module which is initially SET.
!
! OUTPUTS
!	The DST, GST, and RST are initialized.  No value is returned.
!

    BEGIN

    MAP
	FILENAME: REF VECTOR[,BYTE],	! The .EXE file's name in counted ASCII
	IMG_HEADER: REF BLOCK[,BYTE];	! Pointer to the .EXE file image header

    LITERAL
	MAX_ROUT_STACK	= 50,		! Maximum size of the internal routine
					!      start address stack--deeper rout-
					!      ine nesting can mess up SAT.
	MIN_MODS_IN_RST	= 6;		! Minimum number of modules the RST must
					!      be able to hold--in particular,
					!      the MIN_MODS_IN_RST largest mod-
					!      ules must fit in the RST.

    LOCAL
	ADDRESS,			! Memory block address from LIB$GET_VM
	DSTBLK_COUNT,			! Number of DST blocks to map to memory
	DSTPTR: REF DST$RECORD,		! Pointer to the current DST record
	ERROR_COUNT,			! Counts number of error messages given
					!      for Missing Module-Begin Record
	EXE_FILNAM_DESC: VECTOR[2,LONG],! File name descriptor for $CREMAPSEC
	EXE_SECBOUNDS: VECTOR[2,LONG],	! Map section bounds descriptor for the
					!      $CREMAPSEC system service
	EXE_SECNAM_DESC: VECTOR[2,LONG],! Map section name descriptor for the
					!      $CREMAPSEC system service
	GSTPTR: REF VECTOR[,WORD],	! Pointer to GST record--used to find
					!      first GST data record
	IMG_DST_BLOCK: REF IHS$ENTRY,	! Pointer to DST/GST descriptor in the
					!      executable image header
	IN_MODULE_FLAG,			! Set to TRUE if we are after a Module-
					!      Begin record and before a Module-
					!      End record in the DST
	LANGUAGE,			! Language of the current module
	LENGTH,				! Byte length of a static address range
	LONGS_NEEDED,			! Number of longwords of RST space we
					!      need from LIB$GET_VM to handle
					!      the largest several modules.
	MOD_DSTPTR: REF DST$RECORD,	! Pointer to the DST Module-Begin record
					!      for the current module
	MODNAMEPTR,			! Pointer to current module's name in
					!      counted ASCII (used for errors).
	MOD_PC_TBL: REF VECTOR[,LONG],	! Pointer to Module RST Entry vector of
					!      PC Correlation Table pointers
	MOD_SIZE_TBL: VECTOR[MIN_MODS_IN_RST],	! Table giving the sizes of the
					!      MIN_MODS_IN_RST largest modules
					!      in longwords of RST space.
	MOD_SRC_TBL: REF VECTOR[,LONG],	! Pointer to Module RST Entry vector of
					!      pointers to module's Source Line
					!      Correlation DST Records
	MST_INDEX,			! Index into MOD_SIZE_TBL vector
	NEXTSAT,			! Pointer to the next SAT entry on the
					!      TMP_SAT_CHAIN chain.
	NUM_BYTES,			! Number of bytes in LIB$GET_VM call
	NUM_PC_TBLS,			! Number of PC-Correlation Tables in the
					!      DST for the current module
	NUM_RST_ENTS,			! Number of RST entries needed for the
					!      current module's symbol table
	NUM_RST_LONGS,			! Number of RST longwords needed for the
					!      current module's symbol table
	NUM_SAT_ENTS,			! Number of Static Address Table entries
					!      in this module's RST
	NUM_SRC_DSTS,			! Number of Source Line Correlation DST
					!      Records for the current module
	PC_CORR_SIZE,			! Size of the PC_CORR_TBL memory block
	PC_CORR_TBL: REF VECTOR[,LONG],	! Pointer to table of pointers to the
					!      DST PC correlation table records
					!      for the current module
	PCTBL_BASE,			! Base address for offsets in current
					!      module's PC Correlation Tables
	PPTR: REF DST$PSECT_TRAILER,	! Pointer to PSECT DST record trailer
	PREV_RST_PTR: REF RST$ENTRY, 	! Pointer to the previous RST entry in
					!      the chain of Module RST entries
	PREV_SAT_PTR: REF SAT$ENTRY,	! Pointer to previous SAT entry in the
					!      Program SAT chain--used to insert
					!      new Static Address Table entries.
	PROG_SAT_PTR: REF SAT$ENTRY,	! Pointer to current SAT entry in the
					!      Program SAT chain--used to insert
					!      new Static Address Table entries.
	REC_NESTING,			! Depth of data record nesting in DST
	ROUT_STACK:			! Routine start address stack--used to
		VECTOR[MAX_ROUT_STACK],	!      build SAT for nested routines
	ROUT_STACK_INDEX,		! Current size of routine address stack
	RSTPTR: REF RST$ENTRY,		! Pointer to the current RST entry
	RSTSIZE,			! The RST space in longwords needed for
					!      the current module's symbol table
	SATPTR: REF SAT$ENTRY,		! Pointer to SAT entry when searching
					!      for module with transfer address
	SRC_CORR_SIZE,			! Size of the SRC_CORR_TBL memory block
	SRC_CORR_TBL: REF VECTOR[,LONG],! Pointer to the table of pointers to
					!      the current module's Source Line
					!      Correlation DST Records
	STARTADDR,			! The start address of a static area
	STATIC_FLAG,			! Flag set to TRUE for static data items
	STATUS: BLOCK[1, LONG],		! Status returned by RMS or $CREMAPSEC
	TESTDSTSIZE,			! Size of test program DST for a
					!      Testable Debugger
	TMP_SAT_CHAIN,			! Pointer to a temporary Static Address
					!      Table chain for current module
	TMP_SAT_PTR: REF SAT$ENTRY,	! Pointer to the current entry in the
					!      temporary SAT chain when copying
					!      to the Program SAT chain.
	TYPE;				! The type of the current DST record



    !---------------------------------------------------------------------------
    !
    ! The first task is to map the Debug Symbol Table (DST) and the Global Sym-
    ! bol Table (GST) into our virtual address space.  To do this, we must loc-
    ! ate the DST and GST in the executable image file (via the image header),
    ! open the file, call the Create Map Section system service for each symbol
    ! table, and then close the file.  Thereafter the DST and GST can be refer-
    ! enced directly by the other symbol table access routines.
    !
    !---------------------------------------------------------------------------
    !
    !
    ! Initialize some pointers in OWN or GLOBAL memory to zeroes.
    !
    RST$START_ADDR = 0;
    SAT$START_ADDR = 0;
    DST$BEGIN_ADDR = 0;
    DST$END_ADDR = 0;
    GST$BEGIN_ADDR = 0;
    GST$REC_COUNT = 0;


    ! Start by doing some consistency checks to ensure that the image header
    ! pointer is non-zero and that the debug symbol-table offset in the header
    ! is non-zero.  If either is wrong, signal an error and give up.
    !
    IF .IMG_HEADER EQL 0
    THEN
	BEGIN
	SIGNAL(DBG$_NORSTBLD);
	RETURN;
	END;

    IF .IMG_HEADER[IHD$W_SYMDBGOFF] EQL 0
    THEN
	BEGIN
	SIGNAL(DBG$_NORSTBLD);
	RETURN;
	END;


    ! We have a debug symbol table descriptor in the image header.  If no DST
    ! exists (because all the modules were compiled without /DEBUG or /TRACE),
    ! we indicate this by leaving the DST address zeroed.  Otherwise we set the
    ! DST address to 1 temporarily.
    !
    IMG_DST_BLOCK = .IMG_HEADER + .IMG_HEADER[IHD$W_SYMDBGOFF];
    DSTBLK_COUNT = .IMG_DST_BLOCK[IHS$W_DSTBLKS];
    IF .DSTBLK_COUNT NEQ 0 THEN DST$BEGIN_ADDR = 1;


    ! If the DST's Virtual Block Number (VNB) is invalid, we simply pretend that
    ! there is no DST.  (This is actually an error in the image header.)
    !
    IF .IMG_DST_BLOCK[IHS$L_DSTVBN] LEQ 2 THEN DST$BEGIN_ADDR = 0;


    ! If this is a Testable Debugger, determine the length of the DST for the
    ! test program, i.e. before the Debugger's own DST records.  Set the size
    ! of the DST in file blocks accordingly so that only the test program's DST
    ! is mapped into virtual memory below.
    !
    IF (DBG$GL_SUP_OR_TEST EQL 1) AND (.DST$BEGIN_ADDR NEQ 0)
    THEN
	BEGIN
	TESTDSTSIZE = TEST_DST_SIZE(.FILENAME, .IMG_DST_BLOCK);
	DSTBLK_COUNT = (.TESTDSTSIZE + 511)/512;
	END;


    ! If we decided above that there is no DST in the executable image, we print
    ! a message saying that there are no local symbols.
    !
    IF .DST$BEGIN_ADDR EQL 0
    THEN
	SIGNAL(DBG$_NOLOCALS)


    ! Otherwise we decided that there is a DST, so we create a map section which
    ! maps the DST into our virtual address space.  If this fails, we print the
    ! status message (with informational severity so we can continue) and set
    ! the DST start address to zero; if this succeeds, we set the DST start and
    ! end addresses to the values assigned by $CREMAPSEC.
    !
    ELSE
	BEGIN
	EXE_SECBOUNDS[0] = 200;
	EXE_SECBOUNDS[1] = 1^30;
	EXE_SECNAM_DESC[0] = 3;
	EXE_SECNAM_DESC[1] = UPLIT BYTE(%ASCIC 'DST');
	STATUS = LIB$_CREMAPSEC(EXE_SECBOUNDS, EXE_SECBOUNDS, SEC$M_EXPREG,
			EXE_SECNAM_DESC, 0, 0,
			.DSTBLK_COUNT, .IMG_DST_BLOCK[IHS$L_DSTVBN], 0,
    			IMGFILCHAN);
	IF NOT .STATUS
	THEN
	    BEGIN
	    DST$BEGIN_ADDR = 0;
	    STATUS[STS$V_SEVERITY] = SYS$K_INFO;
	    SIGNAL(.STATUS);
	    END

	ELSE
	    BEGIN
	    DST$BEGIN_ADDR = .EXE_SECBOUNDS[0];
	    DST$END_ADDR = .EXE_SECBOUNDS[1];
	    IF DBG$GL_SUP_OR_TEST EQL 1
	    THEN
		DST$END_ADDR = .DST$BEGIN_ADDR + .TESTDSTSIZE - 1;

	    DST$NEXT_ADDR = .DST$BEGIN_ADDR;
	    END;

	END;


    ! Next we want to map in the Global Symbol Table (GST) the same way.  First
    ! we make sure there is a GST--there must be at least four GST records (an
    ! image header, a sub-header, and an end-of-module record plus one data rec-
    ! ord).  If there is no GST, we leave the GST start address zeroed; other-
    ! wise we set it to 1 for now.
    !
    IF .IMG_DST_BLOCK[IHS$W_GSTRECS] GEQ 4 THEN GST$BEGIN_ADDR = 1;


    ! If the GST's Virtual Block Number (VBN) is invalid, we simply pretend that
    ! there is no GST, though this is actually an error in the image header.
    !
    IF .IMG_DST_BLOCK[IHS$L_GSTVBN] LEQ 2 THEN GST$BEGIN_ADDR = 0;


    ! If we have by now decided that there is no GST in the executable image, we
    ! print a message saying that there are no global symbols.
    !
    IF .GST$BEGIN_ADDR EQL 0
    THEN
	SIGNAL(DBG$_NOGLOBALS)


    ! Otherwise we decided that there is a GST, so we create another map section
    ! which maps the GST into our virtual address space.  Again, if this fails,
    ! we print the status message with informational severity and set the GST
    ! address to zero.  If this succeeds, we make the GST pointer point to the
    ! first data record in the GST--we skip over the header and sub-header here.
    ! We also set the GST record count minus the header and trailer records.
    !
    ELSE
	BEGIN
	EXE_SECBOUNDS[0] = 200;
	EXE_SECBOUNDS[1] = 1^30;
	EXE_SECNAM_DESC[0] = 3;
	EXE_SECNAM_DESC[1] = UPLIT BYTE(%ASCIC 'GST');
	STATUS = LIB$_CREMAPSEC(EXE_SECBOUNDS, EXE_SECBOUNDS, SEC$M_EXPREG,
			EXE_SECNAM_DESC, 0, 0,
			.IMG_DST_BLOCK[IHS$W_GSTRECS],
			.IMG_DST_BLOCK[IHS$L_GSTVBN], 0,
    			IMGFILCHAN);
	IF NOT .STATUS
	THEN
	    BEGIN
	    GST$BEGIN_ADDR = 0;
	    STATUS[STS$V_SEVERITY] = SYS$K_INFO;
	    SIGNAL(.STATUS);
	    END

	ELSE
	    BEGIN
	    GSTPTR = .EXE_SECBOUNDS[0];
	    GSTPTR = .GSTPTR + 2 + ((.GSTPTR[0] + 1)/2)*2;
	    GSTPTR = .GSTPTR + 2 + ((.GSTPTR[0] + 1)/2)*2;
	    GST$BEGIN_ADDR = .GSTPTR;
	    GST$NEXT_ADDR = .GST$BEGIN_ADDR;
	    GST$REC_COUNT = .IMG_DST_BLOCK[IHS$W_GSTRECS] - 3;
	    END;

	END;



    !---------------------------------------------------------------------------
    !
    ! We have now mapped the DST and the GST into our (and the user's) virtual
    ! address space.  Next we want to scan the DST to find all modules in the
    ! program and to build the Run-Time Symbol Table's (the RST's) Module Chain.
    ! We will also build the Program Static Address Table (SAT) which indicates
    ! which static addresses belong to which modules, and we will build the RST
    ! hash table.  Finally, we will determine how much RST space we need for the
    ! several largest modules and allocate enough free space so that their RSTs
    ! can be in memory at the same time.
    !
    !---------------------------------------------------------------------------
    !
    !
    ! First create a Module RST Entry for the "anonymous module" to which we
    ! assign all global symbols (from the GST) which do not belong elsewhere.
    ! Global symbols are attached to this module's symbol chain only as they
    ! are referenced, not now when the RST is initially built.
    !
    RSTPTR = GET_MEM(RST$K_MODENTSIZ);
    IF .RSTPTR EQL 0 THEN RETURN;
    RSTPTR[RST$B_KIND] = RST$K_MODULE;
    RSTPTR[RST$V_ANONMOD] = TRUE;
    RSTPTR[RST$B_LANGUAGE] = DBG$K_MACRO;


    ! Put the anonymous module at the start of the Module Entry RST chain.
    !
    RST$START_ADDR = .RSTPTR;
    PREV_RST_PTR = .RSTPTR;


    ! Initialize the RST Reference List so that RST$REF_LIST points to a list
    ! of zero RST entries.  This list is used by DBG$STA_GETSYMBOL to mark which
    ! RST entries are used by the current Debug command and thus cannot be re-
    ! moved from the RST until the command ends.
    !
    RST$REF_LIST = GET_MEM(22);
    RST$REF_LIST[0] = 20;
    RST$REF_LIST[1] = 0;


    ! Create the list head for the Least Recently Used Module (LRUM) table.
    ! This table is used by DBG$GET_MEMORY to determine what module to remove
    ! from the RST when more free memory space is needed.
    !
    LRUM$LISTHEAD = GET_MEM(LRUM$ENTSIZE);
    LRUM$LISTHEAD[LRUM$L_FLINK] = .LRUM$LISTHEAD;
    LRUM$LISTHEAD[LRUM$L_BLINK] = .LRUM$LISTHEAD;
    LRUM$LISTHEAD[LRUM$L_RSTPTR] = 0;


    ! Set up all Source File Control Blocks and associated RMS blocks that we
    ! need to do source line display.
    !
    DBG$SRC_INIT();


    ! Set up a buffer we will use to accumulate pointers to the current module's
    ! PC correlation table DST records.  We do the same for the Source Line
    ! Correlation DST Record pointers.
    !
    PC_CORR_SIZE = 100;
    PC_CORR_TBL = GET_MEM(.PC_CORR_SIZE);
    SRC_CORR_SIZE = 100;
    SRC_CORR_TBL = GET_MEM(.SRC_CORR_SIZE);


    ! Zero out all entries in the Module Size Table.  This table will give the
    ! RST space requirements of the several largest modules in the DST.  Also
    ! zero out several other counters and flags.
    !
    INCR I FROM 0 TO MIN_MODS_IN_RST - 1 DO
	MOD_SIZE_TBL[.I] = 0;

    IN_MODULE_FLAG = FALSE;
    ERROR_COUNT = 0;
    REC_NESTING = 0;
    SAT$START_ADDR = 0;


    ! Scan the Debug Symbol Table to find all modules in it.  For each module,
    ! determine how much RST space that module's symbol table will require when
    ! when brought into the RST.  Also build its Static Address Table entries.
    ! Then create its Module RST Entry and put it on the RST Module Chain.
    !
    DSTPTR = .DST$BEGIN_ADDR;
    WHILE .DSTPTR LSSU .DST$END_ADDR AND .DSTPTR[DST$B_LENGTH] NEQ 0 DO
	BEGIN


	! Pick up the DST record's type and use it as a CASE index so each
	! significant kind of DST record can be processed individually.
	!
	TYPE = .DSTPTR[DST$B_TYPE];
	IF (NOT .IN_MODULE_FLAG) AND (.TYPE NEQ DST$K_MODBEG) THEN EXITLOOP;
	CASE .TYPE FROM 0 TO 256 OF
	    SET


	    ! Handle the error case where we have a DST record not nested within
	    ! a Module-Begin/Module-End pair.  Give an error message, but quit
	    ! printing the message if we have done so too many times already.
	    !
	    [256]:
		BEGIN
		IF .ERROR_COUNT LSS 50 THEN SIGNAL(DBG$_MISMODBEG);
		IF .ERROR_COUNT EQL 50 THEN SIGNAL(DBG$_TOOMANERR);
		ERROR_COUNT = .ERROR_COUNT + 1;
		END;


	    ! Handle the Module Begin record.  Here we make sure we are not al-
	    ! ready in a module (i.e., we check for nesting errors), and then
	    ! we set up all pointers and counters we will need to collect infor-
	    ! mation about this module and later create a Module RST Entry.
	    !
	    [DST$K_MODBEG]:
		BEGIN
		IF .IN_MODULE_FLAG THEN SIGNAL(DBG$_MISMODEND, 1, .MODNAMEPTR);
		IN_MODULE_FLAG = TRUE;
		MOD_DSTPTR = .DSTPTR;
		MODNAMEPTR = MOD_DSTPTR[DST$B_MODBEG_NAME];
		NUM_RST_ENTS = 0;
		NUM_RST_LONGS = 0;
		NUM_SAT_ENTS = 0;
		NUM_PC_TBLS = 0;
		NUM_SRC_DSTS = 0;
		PCTBL_BASE = %X'7FFFFFFF';
		TMP_SAT_CHAIN = 0;
		ROUT_STACK_INDEX = 0;
		LANGUAGE = .MOD_DSTPTR[DST$L_MODBEG_LANGUAGE];
		END;


	    ! Handle the Module End record.  Build the Module RST Entry for this
	    ! module and link it into the RST Module Chain.  Then see if it is
	    ! among the several largest modules in RST space requirements--if so
	    ! we remember how much RST space it needs.  Also copy the Static
	    ! Address Table entries on this module's temporary SAT chain over to
	    ! the permanent Program Static Address Table chain.
	    !
	    [DST$K_MODEND]:
		BEGIN
		IN_MODULE_FLAG = FALSE;


		! Determine how much RST space the module needs for its symbol
		! table.  Note that this includes both the space needed for RST
		! and SAT entries plus one longword for memory allocation con-
		! trol for each such entry.
		!
		RSTSIZE = .NUM_RST_ENTS + .NUM_RST_LONGS
				+ .NUM_SAT_ENTS*(1 + SAT$K_ENTSIZE);


		! Build the Module RST Entry for the current module.
		!
		RSTPTR = GET_MEM(RST$K_MODENTSIZ + .NUM_PC_TBLS
				+ .NUM_SRC_DSTS + MIN(1,.NUM_SRC_DSTS));
		IF .RSTPTR EQL 0 THEN RETURN;
		RSTPTR[RST$L_DSTPTR] = .MOD_DSTPTR;
		RSTPTR[RST$B_KIND] = RST$K_MODULE;
		RSTPTR[RST$L_PCTBL_BASE] = .PCTBL_BASE;
		RSTPTR[RST$L_MODRSTSIZ] = 4*.RSTSIZE;
		RSTPTR[RST$B_LANGUAGE] = .LANGUAGE;
		RSTPTR[RST$W_NUMPCTBLS] = .NUM_PC_TBLS;
		MOD_PC_TBL = RSTPTR[RST$A_MODPCTBL];
		INCR I FROM 0 TO .NUM_PC_TBLS - 1 DO
		    MOD_PC_TBL[.I] = .PC_CORR_TBL[.I];


		! If there were any Source Line Correlation DST Records for
		! this module, copy the table of such pointers into the last
		! part of the Module RST Entry.
		!
		IF .NUM_SRC_DSTS NEQ 0
		THEN
		    BEGIN
		    MOD_SRC_TBL = MOD_PC_TBL[.NUM_PC_TBLS];
		    RSTPTR[RST$L_MODSRCTBL] = .MOD_SRC_TBL;
		    MOD_SRC_TBL[0] = .NUM_SRC_DSTS;
		    INCR I FROM 1 TO .NUM_SRC_DSTS DO
			MOD_SRC_TBL[.I] = .SRC_CORR_TBL[.I - 1];

		    END;


		! Link the Module RST Entry into the RST Module Chain.
		!
		PREV_RST_PTR[RST$L_NXTMODPTR] = .RSTPTR;
		PREV_RST_PTR = .RSTPTR;


		! If the amount of RST space the module needs makes it one of
		! the several largest modules, enter it in MOD_SIZE_TBL.  Note
		! that the table remains sorted on module size, largest first.
		!
		INCR I FROM 0 TO MIN_MODS_IN_RST - 1 DO
		    BEGIN
		    IF .RSTSIZE GTR .MOD_SIZE_TBL[.I]
		    THEN
			BEGIN
			DECR J FROM MIN_MODS_IN_RST - 2 TO .I DO
			    MOD_SIZE_TBL[.J+1] = .MOD_SIZE_TBL[.J];

			MOD_SIZE_TBL[.I] = .RSTSIZE;
			EXITLOOP;
			END;

		    END;


		! Copy the Static Address Table entries we have built and merged
		! on the TMP_SAT_CHAIN chain (which covers the current module
		! only) over to the permanent Program Static Address Table.
		!
		PREV_SAT_PTR = SAT$START_ADDR;
		PROG_SAT_PTR = .SAT$START_ADDR;
		TMP_SAT_PTR = .TMP_SAT_CHAIN;
		WHILE .TMP_SAT_PTR NEQ 0 DO
		    BEGIN


		    ! Find the proper place in the permanent chain to insert the
		    ! new entry so the chain remains sorted on start address.
		    !
		    WHILE .PROG_SAT_PTR NEQ 0 DO
			BEGIN
			IF .PROG_SAT_PTR[SAT$L_START] GTRU .TMP_SAT_PTR[SAT$L_START]
			THEN
			    EXITLOOP;

			PREV_SAT_PTR = .PROG_SAT_PTR;
			PROG_SAT_PTR = .PROG_SAT_PTR[SAT$L_FLINK];
			END;


		    ! Fill the module RST pointer into the new SAT entry and
		    ! link it into the permanent Program SAT.  Then step to
		    ! the next TMP_SAT_CHAIN entry.
		    !
		    NEXTSAT = .TMP_SAT_PTR[SAT$L_FLINK];
		    TMP_SAT_PTR[SAT$L_RSTPTR] = .RSTPTR;
		    TMP_SAT_PTR[SAT$L_FLINK] = .PROG_SAT_PTR;
		    PREV_SAT_PTR[SAT$L_FLINK] = .TMP_SAT_PTR;
		    PREV_SAT_PTR = .TMP_SAT_PTR;
		    TMP_SAT_PTR = .NEXTSAT;
		    END;

		END;			! End of Module-End-record code


	    ! Handle the PSECT record.  For each PSECT record we record its
	    ! address range in the temporary Static Address Table we are build-
	    ! ing for this module.  (That table will be copied to the Program
	    ! Static Address Table when the Module-End record is found.)  We
	    ! also tabulate that the PSECT will require a Label RST Entry.
	    !
	    [DST$K_PSECT]:
		BEGIN
		STARTADDR = .DSTPTR[DST$L_PSECT_VALUE];
		PPTR = DSTPTR[DST$A_PSECT_TRLR_BASE]
				+ .DSTPTR[DST$B_PSECT_TRLR_OFFS];
		LENGTH = .PPTR[DST$L_PSECT_SIZE];
		STATIC_ADDRESS(.STARTADDR, .LENGTH, 0, TMP_SAT_CHAIN, TRUE);
		NUM_SAT_ENTS = .NUM_SAT_ENTS + 1;
		NUM_RST_ENTS = .NUM_RST_ENTS + 1;
		NUM_RST_LONGS = .NUM_RST_LONGS + RST$K_LBLENTSIZ;
		END;


	    ! Handle the Line Number/PC Correlation Table record.  Here we save
	    ! its address which will later be moved to the Module RST Entry.
	    ! Note that we expand the buffer which holds the DST pointers if the
	    ! buffer overflows.
	    !
	    [DST$K_LINE_NUM,
	     DST$K_LINE_NUM_REL_R11]:
		BEGIN
		IF .NUM_PC_TBLS GEQ .PC_CORR_SIZE
		THEN
		    BEGIN
		    MOD_PC_TBL = .PC_CORR_TBL;
		    PC_CORR_SIZE = .PC_CORR_SIZE + 100;
		    PC_CORR_TBL = GET_MEM(.PC_CORR_SIZE);
		    CH$MOVE(4*.NUM_PC_TBLS, .MOD_PC_TBL, .PC_CORR_TBL);
		    DBG$REL_MEMORY(.MOD_PC_TBL);
		    END;

		PC_CORR_TBL[.NUM_PC_TBLS] = .DSTPTR;
		NUM_PC_TBLS = .NUM_PC_TBLS + 1;
		END;


	    ! Handle the Source Line Correlation record.  Here we save its
	    ! address which will later be moved into the Module RST Entry.
	    ! Note that we expand the buffer which holds the DST pointers
	    ! if the buffer overflows.
	    !
	    [DST$K_SOURCE]:
		BEGIN
		IF .NUM_SRC_DSTS GEQ .SRC_CORR_SIZE
		THEN
		    BEGIN
		    MOD_SRC_TBL = .SRC_CORR_TBL;
		    SRC_CORR_SIZE = .SRC_CORR_SIZE + 100;
		    SRC_CORR_TBL = GET_MEM(.SRC_CORR_SIZE);
		    CH$MOVE(4*.NUM_SRC_DSTS, .MOD_SRC_TBL, .SRC_CORR_TBL);
		    DBG$REL_MEMORY(.MOD_SRC_TBL);
		    END;

		SRC_CORR_TBL[.NUM_SRC_DSTS] = .DSTPTR;
		NUM_SRC_DSTS = .NUM_SRC_DSTS + 1;
		END;


	    ! Handle the Routine-Begin record.  Tabulate how much RST space it
	    ! requires.  Also remember the routine start address in the routine
	    ! start address stack--we will need it when we find the Routine-End
	    ! record.
	    !
	    [DST$K_RTNBEG]:
		BEGIN
		NUM_RST_ENTS = .NUM_RST_ENTS + 1;
		NUM_RST_LONGS = .NUM_RST_LONGS + RST$K_ROUTENTSIZ;
		NUM_SAT_ENTS = .NUM_SAT_ENTS + 1;
		IF .ROUT_STACK_INDEX LSS MAX_ROUT_STACK
		THEN
		    ROUT_STACK[.ROUT_STACK_INDEX] = .DSTPTR[DST$L_RTNBEG_ADDRESS]

		ELSE IF .LANGUAGE NEQ DBG$K_MACRO
		THEN
		    SIGNAL(DBG$_DSTNESDEP, 1, .MODNAMEPTR);

		ROUT_STACK_INDEX = .ROUT_STACK_INDEX + 1;
		IF .PCTBL_BASE GTR .DSTPTR[DST$L_RTNBEG_ADDRESS]
		THEN
		    PCTBL_BASE = .DSTPTR[DST$L_RTNBEG_ADDRESS];

		END;


	    ! Handle the Routine-End record.  Determine what address range the
	    ! routine body covers and enter that range in the temporary Static
	    ! Address Table we are building for the current module.  (That info
	    ! will be copied to the Program Static Address Table when we find
	    ! the Module-End record.)
	    !
	    [DST$K_RTNEND]:
		BEGIN
		ROUT_STACK_INDEX = .ROUT_STACK_INDEX - 1;
		IF .ROUT_STACK_INDEX LSS 0
		THEN
		    SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR)

		ELSE IF .ROUT_STACK_INDEX LSS MAX_ROUT_STACK
		THEN
		    BEGIN
		    STARTADDR = .ROUT_STACK[.ROUT_STACK_INDEX];
		    LENGTH = .DSTPTR[DST$L_RTNEND_SIZE];
		    STATIC_ADDRESS(.STARTADDR, .LENGTH, 0, TMP_SAT_CHAIN, TRUE);
		    END;

		END;


	    ! Handle the Lexical Block-Begin record.  Tabulate how much RST
	    ! space it will require.
	    !
	    [DST$K_BLKBEG]:
		BEGIN
		NUM_RST_ENTS = .NUM_RST_ENTS + 1;
		NUM_RST_LONGS = .NUM_RST_LONGS + RST$K_LEXENTSIZ;
		NUM_SAT_ENTS = .NUM_SAT_ENTS + 1;
		END;


	    ! Handle the Label record.  Again just tabulate how much RST space
	    ! is required for this record.
	    !
	    [DST$K_LABEL]:
		BEGIN
		NUM_RST_ENTS = .NUM_RST_ENTS + 1;
		NUM_RST_LONGS = .NUM_RST_LONGS + RST$K_LBLENTSIZ;
		NUM_SAT_ENTS = .NUM_SAT_ENTS + 1;
		END;


	    ! Handle the Label-or-Literal record.  If the record is for a Label,
	    ! tabulate the space needed for a Label RST Entry and a SAT entry.
	    ! If it is for a literal, tabulate the space needed for a Data Item
	    ! RST Entry.
	    !
	    [DST$K_LBLORLIT]:
		BEGIN
		NUM_RST_ENTS = .NUM_RST_ENTS + 1;
		IF .DSTPTR[DST$B_VFLAGS] EQL 1
		THEN
		    BEGIN
		    NUM_RST_LONGS = .NUM_RST_LONGS + RST$K_LBLENTSIZ;
		    NUM_SAT_ENTS = .NUM_SAT_ENTS + 1;
		    END

		ELSE
		    NUM_RST_LONGS = .NUM_RST_LONGS + RST$K_DATENTSIZ;

		END;


	    ! Handle the Entry-Point record.  Tabulate the RST space it needs.
	    !
	    [DST$K_ENTRY]:
		BEGIN
		NUM_RST_ENTS = .NUM_RST_ENTS + 1;
		NUM_RST_LONGS = .NUM_RST_LONGS + RST$K_EPTENTSIZ;
		NUM_SAT_ENTS = .NUM_SAT_ENTS + 1;
		END;


	    ! Handle the Record-Begin record.  Tabulate the space needed for the
	    ! Type RST Entry for the record and a possible Data Item RST Entry.
	    ! Also increment the current level of record nesting.
	    !
	    [DST$K_RECBEG]:
		BEGIN
		NUM_RST_ENTS = .NUM_RST_ENTS + 2;
		NUM_RST_LONGS = .NUM_RST_LONGS +
					RST$K_TYPENTSIZ + RST$K_DATENTSIZ + 1;
		IF .REC_NESTING GTR 0 THEN NUM_RST_LONGS = .NUM_RST_LONGS + 1;
		NUM_SAT_ENTS = .NUM_SAT_ENTS + 1;
		REC_NESTING = .REC_NESTING + 1;
		END;


	    ! Handle the Record End record.  Just decrement the record nesting
	    ! depth by one.
	    !
	    [DST$K_RECEND]:
		BEGIN
		IF .REC_NESTING LEQ 0 THEN SIGNAL(DBG$_INCDSTNES,1,.MODNAMEPTR);
		REC_NESTING = .REC_NESTING - 1;
		END;


	    ! Handle the Variant-Set Begin record.  Tabulate the space needed
	    ! for one Variant RST Entry plus a component list pointer to it.
	    !
	    [DST$K_VARBEG]:
		NUM_RST_LONGS = .NUM_RST_LONGS + RST$K_VARENTSIZ + 1;


	    ! Handle the Variant Value record.  Note that we need 2 longwords
	    ! per variant entry plus one more for a list pointer.
	    !
	    [DST$K_VARVAL]:
		NUM_RST_LONGS = .NUM_RST_LONGS + 3;


	    ! Handle the Enumeration Type Begin record.  Tabulate the space
	    ! needed for a Data Type RST Entry.
	    !
	    [DST$K_ENUMBEG]:
		BEGIN
		NUM_RST_ENTS = .NUM_RST_ENTS + 1;
		NUM_RST_LONGS = .NUM_RST_LONGS + RST$K_TYPENTSIZ;
		END;


	    ! Handle the Enumeration Type Element record.  Tabulate the space
	    ! needed for one Data RST Entry plus a longword pointer to it.
	    !
	    [DST$K_ENUMELT]:
		BEGIN
		NUM_RST_ENTS = .NUM_RST_ENTS + 1;
		NUM_RST_LONGS = .NUM_RST_LONGS + RST$K_DATENTSIZ + 1;
		END;


	    ! Handle all Data Symbol records.  This includes the Bliss special
	    ! cases, the Boolean record, and the Separate Type Spec record.  For
	    ! each, tabulate the amount of RST space needed for the data symbol
	    ! and make a Static Address Table entry if this is a static data
	    ! item.
	    !
	    [DSC$K_DTYPE_LOWEST TO DSC$K_DTYPE_HIGHEST,
	     DST$K_BLI,
	     DST$K_BOOL,
	     DST$K_SEPTYP]:
		BEGIN
		NUM_RST_ENTS = .NUM_RST_ENTS + 1;
		NUM_RST_LONGS = .NUM_RST_LONGS + RST$K_DATENTSIZ;
		IF .REC_NESTING GTR 0 THEN NUM_RST_LONGS = .NUM_RST_LONGS + 1;
		STATIC_CHECK(.DSTPTR, STARTADDR, LENGTH, STATIC_FLAG);
		IF .STATIC_FLAG
		THEN
		    BEGIN
		    STATIC_ADDRESS(.STARTADDR, .LENGTH, 0, TMP_SAT_CHAIN, TRUE);
		    NUM_SAT_ENTS = .NUM_SAT_ENTS + 1;
		    END;

		END;


	    ! Handle the BLISS field record.  Here we allow for one Data Item
	    ! RST Entry.
	    !
	    [DST$K_BLIFLD]:
		BEGIN
		NUM_RST_ENTS = .NUM_RST_ENTS + 1;
		NUM_RST_LONGS = .NUM_RST_LONGS + RST$K_DATENTSIZ;
		END;


	    ! Handle the COBOL special cases.  Tabulate the space needed for one
	    ! Data Item RST Entry.
	    !
	    [DST$K_COB_HACK]:
		BEGIN
		NUM_RST_ENTS = .NUM_RST_ENTS + 1;
		NUM_RST_LONGS = .NUM_RST_LONGS + RST$K_DATENTSIZ;
		END;


	    ! For all other records, we do nothing.
	    !
	    [INRANGE]:
		0;

	    TES;


	! Advance the DST pointer to point to the next record.  Then loop.
	!
	DSTPTR = DSTPTR[DST$A_NEXT] + .DSTPTR[DST$B_LENGTH];

	END;				! End of WHILE loop over whole DST



    ! Release the memory blocks used to hold PC correlation table pointers and
    ! the Source Line Correlation DST Record pointers.
    !
    DBG$REL_MEMORY(.PC_CORR_TBL);
    DBG$REL_MEMORY(.SRC_CORR_TBL);


    ! Now initialize the RST Hash Table and enter all module names in it.
    ! Note that we omit the anonymous module.
    !
    INCR I FROM 0 TO RST$K_HASHTBLSIZE - 1 DO
	BEGIN
	RST$HASH_TABLE[2*.I] = RST$HASH_TABLE[2*.I];
	RST$HASH_TABLE[2*.I + 1] = RST$HASH_TABLE[2*.I];
	END;

    RSTPTR = .RST$START_ADDR;
    RSTPTR = .RSTPTR[RST$L_NXTMODPTR];
    WHILE .RSTPTR NEQ 0 DO
	BEGIN
	DBG$HASH_INSERT(.RSTPTR);
	RSTPTR = .RSTPTR[RST$L_NXTMODPTR];
	END;


    ! Determine how much free memory space we need to accommodate the RST's of
    ! the largest several modules plus enough working space.  If we don't have
    ! that much, we expand the free memory pool (via DBG$EXPAND_MEMORY) so that
    ! we will have enough.  Note that if we cannot expand the pool that much
    ! (i.e, if DBG$EXPAND_MEMORY fails because the system cannot come up with
    ! the extra virtual address space), we scale down the request by one module
    ! at a time and try again--hence the WHILE loop here.
    !
    LONGS_NEEDED = 4096;			! 16K bytes of working space
    INCR I FROM 0 TO MIN_MODS_IN_RST - 1 DO
	LONGS_NEEDED = .LONGS_NEEDED + .MOD_SIZE_TBL[.I];

    LONGS_NEEDED = .LONGS_NEEDED - DBG$FREE_MEM_LEFT();
    MST_INDEX = MIN_MODS_IN_RST;
    WHILE .LONGS_NEEDED GTR 100 DO
	BEGIN
	STATUS = DBG$EXPAND_MEMORY(.LONGS_NEEDED);
	IF .STATUS OR (.MST_INDEX EQL 0) THEN EXITLOOP;
	MST_INDEX = .MST_INDEX - 1;
	LONGS_NEEDED = .LONGS_NEEDED - .MOD_SIZE_TBL[.MST_INDEX];
	END;


    ! The DST and RST are now initialized, the Program Static Address Table is
    ! built, the RST Hash Table is built, and the necessary free memory has
    ! been acquired (if it was possible).  We now set up the Scope List with
    ! the default scopes.
    !
    DBG$RST_SETSCOPE(UPLIT(0), RSTPTR);


    ! Also create a global symbol SHARE$xxx in the RST for each shared image
    ! xxx in the current execution.  This allows the user to see the start
    ! address of each shared image (actually every image whether shared or
    ! not) in the execution.
    !
    SHARED_IMAGE_NAMES();


    ! Now search the Static Address Table for the module with the transfer
    ! address so we can SET that module.
    !
    RSTPTR = 0;
    SATPTR = .SAT$START_ADDR;
    WHILE .SATPTR NEQ 0 DO
	BEGIN
	IF .TRANSFER_ADDR GEQ .SATPTR[SAT$L_START] AND
	   .TRANSFER_ADDR LEQ .SATPTR[SAT$L_END]
	THEN
	    BEGIN
	    RSTPTR = .SATPTR[SAT$L_RSTPTR];
	    EXITLOOP;
	    END;

	SATPTR = .SATPTR[SAT$L_FLINK];
	END;


    ! If we did not find the module with the transfer address, we SET the first
    ! module in the RST (and DST) instead.
    !
    IF .RSTPTR EQL 0
    THEN
	BEGIN
	RSTPTR = .RST$START_ADDR;
	RSTPTR = .RSTPTR[RST$L_NXTMODPTR];
	END;


    ! If we are in SUPERDEBUG, look up symbol BEGINHERE in the GST and set its
    ! address in the current PC.  If the lookup fails, we die right here.  Also
    ! set the language to BLISS and do not SET any initial module.
    !
    IF DBG$GL_SUP_OR_TEST EQL 2
    THEN
	BEGIN
	BIND BEGINHERENAME = UPLIT BYTE(%ASCIC 'BEGINHERE');
	RSTPTR = DBG$STA_LOOKUP_GBL(BEGINHERENAME);
	IF .RSTPTR EQL 0 THEN SIGNAL(DBG$_NOSYMBOL, 1, BEGINHERENAME);
	DSTPTR = .RSTPTR[RST$L_DSTPTR];
	DBG$GL_RUNFRAME[DBG$L_USER_PC] = .DSTPTR[DST$L_VALUE] + 2;
	DBG$SET_LANG(0, DBG$K_BLISS);
	RSTPTR = 0;
	END;


    ! Now actually SET the selected module and build its RST.  Also print the
    ! start-up message and set the language code accordingly.
    !
    IF .RSTPTR NEQ 0
    THEN
	BEGIN
	RSTPTR[RST$V_MODSET] = TRUE;
	DBG$RST_BUILD(.RSTPTR);
	DBG$SET_LANG(0, .RSTPTR[RST$B_LANGUAGE]);
	DSTPTR = .RSTPTR[RST$L_DSTPTR];
	SIGNAL(DBG$_INITIAL, 2,
		DBG$LANGUAGE(.RSTPTR[RST$B_LANGUAGE]),
		DSTPTR[DST$B_MODBEG_NAME]);
	END


    ! If no module could be SET, modify the initialization message accordingly.
    !
    ELSE
	BEGIN
	SIGNAL(DBG$_INITIAL, 2, DBG$LANGUAGE(.DBG$GB_LANGUAGE),
						UPLIT BYTE(%ASCIC 'no module'));
	END;


    ! The RST initialization is done.  Now return.
    !
    RETURN;

    END;

GLOBAL ROUTINE DBG$RST_MOST_RECENT(MODRSTPTR): NOVALUE =
!
! FUNCTION
!	This routine marks a specified module as being the Most Recently Used
!	module among the modules currently in the Run-Time Symbol Table (RST).
!	This is done by searching for the module in the LRUM (Least Recently
!	Used Module) table and moving its LRUM entry to the first position in
!	the table.  If no LRUM entry exists for the specified module, a new
!	entry is created and inserted at the beginning of the table.
!
!	The LRUM table is a doubly linked list of entries, where each entry
!	represents one module currently in the RST.  The list is ordered by
!	recency of reference, so that the first module on the list is the most
!	recently referenced and the last is the Least Recently Used.  This
!	routines moves entries to the beginning of the list--this keeps used
!	modules away from the Least Recently Used slot at the end of the list.
!
!	When more memory is needed in the free memory pool, DBG$GET_MEMORY will
!	use the LRUM table to find the Least Recently Used Module.  That module
!	is then removed from the RST so that its RST space can be reused.  The
!	Most Recently Used module will never be removed, however; this prevents
!	a module from being removed while its own RST is being built.
!
! INPUTS
!	MODRSTPTR - A pointer to the Module RST Entry for the module to be
!		  marked as being Most Recently Used.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	MODRSTPTR: REF RST$ENTRY;	! Pointer to Module RST Entry of the
					!      Most Recently Used module

    LOCAL
	BACKPTR: REF LRUM$ENTRY,	! Pointer to previous entry on LRUM list
	FORWPTR: REF LRUM$ENTRY,	! Pointer to the next entry on LRUM list
	PTR: REF LRUM$ENTRY;		! Pointer to the current LRUM entry



    ! If the specified module is already marked as being the Most Recently Used
    ! module, return right away.
    !
    IF .MODRSTPTR EQL .LRUM$MOST_RECENT THEN RETURN;


    ! Search the whole Least Recently Used Module list for the MODRSTPTR module.
    ! Exit the loop with PTR pointing to the corresponding LRUM entry.
    !
    PTR = .LRUM$LISTHEAD[LRUM$L_FLINK];
    WHILE TRUE DO
	BEGIN


	! If we have come to the end of the list, the specified module is not on
	! the LRUM list.  If so, create a new LRUM entry for the MODRSTPTR mod-
	! ule and exit the search loop.
	!
	IF .PTR EQL .LRUM$LISTHEAD
	THEN
	    BEGIN
	    IF NOT .MODRSTPTR[RST$V_MOD_IN_RST]
	    THEN
		SIGNAL(DBG$_DEBUGBUG, 1, 160);

	    PTR = DBG$GET_MEMORY(LRUM$ENTSIZE);
	    PTR[LRUM$L_RSTPTR] = .MODRSTPTR;
	    EXITLOOP;
	    END;


	! If this is the desired LRUM entry, unlink it from the doubly linked
	! list and exit the loop.
	!
	IF .PTR[LRUM$L_RSTPTR] EQL .MODRSTPTR
	THEN
	    BEGIN
	    FORWPTR = .PTR[LRUM$L_FLINK];
	    BACKPTR = .PTR[LRUM$L_BLINK];
	    FORWPTR[LRUM$L_BLINK] = .BACKPTR;
	    BACKPTR[LRUM$L_FLINK] = .FORWPTR;
	    EXITLOOP;
	    END;


	! We have not found it yet--link on and loop.
	!
	PTR = .PTR[LRUM$L_FLINK];
	END;


    ! We now have the desired LRUM entry.  Link it into the doubly linked LRUM
    ! list in the Most Recently Used position.  Also set LRUM$MOST_RECENT to
    ! point to the specified Module RST Entry.  Then return.
    !
    FORWPTR = .LRUM$LISTHEAD[LRUM$L_FLINK];
    BACKPTR = .LRUM$LISTHEAD;
    PTR[LRUM$L_FLINK] = .FORWPTR;
    PTR[LRUM$L_BLINK] = .BACKPTR;
    FORWPTR[LRUM$L_BLINK] = .PTR;
    BACKPTR[LRUM$L_FLINK] = .PTR;
    LRUM$MOST_RECENT = .MODRSTPTR;
    RETURN;

    END;

GLOBAL ROUTINE DBG$RST_REMOVE(MODRSTPTR): NOVALUE =
!
! FUNCTION
!	This routine removes the RST for one module from the Run-Time Symbol
!	Table (RST).  It accepts as input a pointer to the Module RST Entry of
!	the module to be removed.  The module's symbol chain is then scanned,
!	and all RST entries on it with zero reference counts are released to the
!	free memory pool.  The module's Static Address Table chain is also re-
!	leased and its Least Recently Used Module (LRUM) table entry is removed.
!
!	RST entries on the module's symbol chain which are locked (have non-zero
!	reference counts) cannot be released since there are pointers around
!	which point to them.  Such entries are therefore added to the Temporary
!	RST Entry List after being removed from the module's symbol chain and
!	from the RST Hash Table.  These RST entries are eventually released by
!	routine DBG$RST_TEMP_RELEASE after their reference counts have been re-
!	duced to zero.
!
! INPUTS
!	MODRSTPTR - A pointer to the Module RST Entry of the module which is to
!		  be removed from the RST.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	MODRSTPTR: REF RST$ENTRY;	! Pointer to the Module RST Entry of the
					!      module to be removed

    LOCAL
	BACKLRUM: REF LRUM$ENTRY,	! Pointer to previous LRUM entry
	BACKPTR: REF RST$ENTRY,		! Pointer to previous RST entry on
					!      the RST hash chain
	FORWLRUM: REF LRUM$ENTRY,	! Pointer to the next LRUM entry
	FORWPTR: REF RST$ENTRY,		! Pointer to the next RST entry on
					!      the RST hash chain
	LOCKNODE: DBG$LINK_NODE,	! Node used to lock or unlock SYMIDs
	LRUMPTR: REF LRUM$ENTRY,	! Pointer to the current LRUM (Least Re-
					!      cently Used Module) table entry
	NEXTRST,			! Pointer to the next RST entry on the
					!      module's symbol chain
	NEXTSAT,			! Pointer to the next entry on the
					!      module's SAT chain
	RSTPTR: REF RST$ENTRY,		! Pointer to the current RST entry on
					!      the module's symbol chain
	SATPTR: REF SAT$ENTRY;		! Pointer to the current Static Address
					!      Table entry being removed



    ! Mark the specified module as no longer being in the RST.  Also increment
    ! the reference counts of all RST entries which are referenced by the cur-
    ! rent Debug command (the entries on the RST Reference List).
    !
    MODRSTPTR[RST$V_MOD_IN_RST] = FALSE;
    LOCKNODE[DBG$L_LINK_NODE_LINK] = 0;
    INCR I FROM 1 TO .RST$REF_LIST[1] DO
	BEGIN
	LOCKNODE[DBG$L_LINK_NODE_VALUE] = .RST$REF_LIST[.I + 1];
	DBG$STA_LOCK_SYMID(LOCKNODE);
	END;


    ! Loop over the module's symbol chain and remove all entries on it from that
    ! chain and from the RST Hash Table.  Release all RST entries with zero ref-
    ! erence counts to the memory pool, and put those with non-zero reference
    ! counts on the Temporary RST Entry List.
    !
    RSTPTR = .MODRSTPTR[RST$L_SYMCHNPTR];
    MODRSTPTR[RST$L_SYMCHNPTR] = 0;
    WHILE .RSTPTR NEQ 0 DO
	BEGIN
	NEXTRST = .RSTPTR[RST$L_SYMCHNPTR];


	! Remove the RST entry from the RST Hash Table.
	!
	FORWPTR = .RSTPTR[RST$L_HASH_FLINK];
	BACKPTR = .RSTPTR[RST$L_HASH_BLINK];
	FORWPTR[RST$L_HASH_BLINK] = .BACKPTR;
	BACKPTR[RST$L_HASH_FLINK] = .FORWPTR;


	! Release the RST entry to the memory pool or put it on the
	! Temporary RST Entry List.
	!
	IF .RSTPTR[RST$W_REFCOUNT] EQL 0
	THEN
	    DBG$REL_MEMORY(.RSTPTR)

	ELSE
	    BEGIN
	    RSTPTR[RST$L_HASH_FLINK] = .RST$TEMP_LIST;
	    RSTPTR[RST$L_HASH_BLINK] = 0;
	    RST$TEMP_LIST = .RSTPTR;
	    RSTPTR[RST$L_SYMCHNPTR] = 0;
	    END;

	RSTPTR = .NEXTRST;
	END;


    ! Also remove all SAT entries on the module's Static Address Table chain.
    !
    SATPTR = .MODRSTPTR[RST$L_SAT_PTR];
    MODRSTPTR[RST$L_SAT_PTR] = 0;
    WHILE .SATPTR NEQ 0 DO
	BEGIN
	NEXTSAT = .SATPTR[SAT$L_FLINK];
	DBG$REL_MEMORY(.SATPTR);
	SATPTR = .NEXTSAT;
	END;


    ! Decrement the reference counts of all RST entries referenced by the
    ! current Debug command; we have already ensured that they will stay in
    ! memory for now.
    !
    INCR I FROM 1 TO .RST$REF_LIST[1] DO
	BEGIN
	LOCKNODE[DBG$L_LINK_NODE_VALUE] = .RST$REF_LIST[.I + 1];
	DBG$STA_UNLOCK_SYMID(LOCKNODE);
	END;


    ! Finally remove the LRUM (Least Recently Used Module) table entry for the
    ! module.  Such entries may only exist for modules currently in the RST.
    !
    IF .MODRSTPTR EQL .LRUM$MOST_RECENT THEN LRUM$MOST_RECENT = 0;
    LRUMPTR = .LRUM$LISTHEAD[LRUM$L_FLINK];
    WHILE .LRUMPTR NEQ .LRUM$LISTHEAD DO
	BEGIN
	IF .LRUMPTR[LRUM$L_RSTPTR] EQL .MODRSTPTR
	THEN
	    BEGIN
	    FORWLRUM = .LRUMPTR[LRUM$L_FLINK];
	    BACKLRUM = .LRUMPTR[LRUM$L_BLINK];
	    FORWLRUM[LRUM$L_BLINK] = .BACKLRUM;
	    BACKLRUM[LRUM$L_FLINK] = .FORWLRUM;
	    DBG$REL_MEMORY(.LRUMPTR);
	    EXITLOOP;
	    END;

	LRUMPTR = .LRUMPTR[LRUM$L_FLINK];
	END;


    ! We are all done with the module--now return.
    !
    RETURN;

    END;

GLOBAL ROUTINE DBG$RST_SETMOD(MODNAMEPTR, LENGTH) =
!
! FUNCTION
!	This routine marks a specified module as being SET.  The routine accepts
!	the desired module name and its length as input, looks that name up in
!	the RST Module Chain, and marks the module as being SET.  Alternatively,
!	if no module name is specified, all modules in the RST Module Chain are
!	marked as SET.
!
! INPUTS
!	MODNAMEPTR - A pointer to the first character of an ASCII string
!		  containing the module name.  If this pointer is zero, it is
!		  assumed that all modules should be marked as being SET.
!
!	LENGTH	- The length in characters of the module name.
!
! OUTPUTS
!	This routine returns the value STS$K_SUCCESS if the module was success-
!		  fully SET; it returns STS$K_SEVERE if the specified module
!		  name does not exist in the RST Module Chain.  If all modules
!		  are SET, STS$K_SUCCESS is always returned.
!

    BEGIN

    LOCAL
	RSTPTR: REF RST$ENTRY;		! Pointer to the Module RST Entry



    ! If a specific module name was specified, we look up the corresponding
    ! Module RST Entry, mark the module as being SET, and build the RST symbol
    ! chain for the module.
    !
    IF .MODNAMEPTR NEQ 0
    THEN
	BEGIN
	RSTPTR = GET_MOD_RST(.MODNAMEPTR, .LENGTH);
	IF .RSTPTR EQL 0 THEN RETURN STS$K_SEVERE;
	RSTPTR[RST$V_MODSET] = TRUE;
	DBG$RST_BUILD(.RSTPTR);
	RETURN STS$K_SUCCESS;
	END;


    ! No module name was specified.  Go through the whole RST Module Chain (but
    ! ignore the anonymous module) and mark each module as being SET.  Also
    ! build each such module's RST symbol chain.
    !
    RSTPTR = .RST$START_ADDR;
    WHILE .RSTPTR NEQ 0 DO
	BEGIN
	IF NOT .RSTPTR[RST$V_ANONMOD]
	THEN
	    BEGIN
	    RSTPTR[RST$V_MODSET] = TRUE;
	    DBG$RST_BUILD(.RSTPTR);
	    END;

	RSTPTR = .RSTPTR[RST$L_NXTMODPTR];
	END;

    RETURN STS$K_SUCCESS;

    END;

GLOBAL ROUTINE DBG$RST_SETSCOPE(PNVEC, ERRINDEX): NOVALUE =
!
! FUNCTION
!	This routine makes a new set of scopes available to the symbol table
!	access routines (DBG$STA_GETSYMBOL in particular).  It is thus called
!	in the course of processing the SET SCOPE command.  It accepts as in-
!	put a vector of pointers to Pathname Descriptors for the scopes speci-
!	fied on the SET SCOPE command.  It builds a linked list of the corre-
!	sponding Scope Entries, and makes SCOPE$LIST point to this list.
!
!	If an error in a scope pathname is detected, the index of that pathname
!	is returned to ERRINDEX.  The actual return is accomplished by signal-
!	ling an error which is intercepted by an error handler.  That handler
!	releases any partially built new scope list back to the free memory pool
!	and then unwinds to return control to the caller of DBG$RST_SETSCOPE.
!
! INPUTS
!	PNVEC	- A vector of pointers to Pathname Descriptors for the scopes
!		  specified on the SET SCOPE command.  PNVEC[0] gives the number
!		  of such pointers and PNVEC[1] through PNVEC[.PNVEC[0]] contain
!		  the pointers to the Pathname Descriptors.  The CANCEL SCOPE
!		  command is handled by making PNVEC[0] zero.
!
!	ERRINDEX - The address of a longword location to receive an "error
!		  index"; see description below.
!
! OUTPUTS
!	ERRINDEX - If some pathname is found to be invalid, the PNVEC index of
!		  that pathname is returned to ERRINDEX.  The calling routine
!		  can then use ERRINDEX to produce an error message.  If all
!		  scope pathnames are correct, zero is returned to ERRINDEX.
!
!	No value is returned.
!

    BEGIN

    MAP
	PNVEC: REF VECTOR[,LONG],	! Pointer to vector of Pathname Descrip-
					!      tor pointers
	ERRINDEX: REF VECTOR[1];	! Pointer to error index longword

    LOCAL
	KIND,				! The Kind of the scope's RST entry
	LOCKNODE: DBG$LINK_NODE,	! Node used to lock or unlock SYMIDs
	MODPTR: REF RST$ENTRY,		! Pointer to Module RST Entry for module
					!      containing the present scope
	NEW_SCOPE_LIST: VOLATILE,	! Pointer to new scope list being built
	PATHNAME: REF PTH$PATHNAME,	! Pointer to current Pathname Descriptor
	PATHVEC: REF VECTOR[,LONG],	! Pointer to current pathname vector
	PATH_STRING,			! Pointer to scope name as counted ASCII
	PNAME: REF VECTOR[,BYTE],	! Pointer to first name in the Pathname
					!      Descriptor (as Counted ASCII)
	PREVSCOPE: REF SCOPE$ENTRY,	! Pointer to the scope entry before the
					!      present scope entry
	RSTPTR: REF RST$ENTRY,		! Pointer to current scope's RST entry
	SCOPE: REF SCOPE$ENTRY,		! Pointer to the present scope entry
	STATUS;				! Status code returned by other routines

    ENABLE
	SETSCOPE_ERROR_HANDLER(NEW_SCOPE_LIST);	! Declare an error handler



    ! Make NEW_SCOPE_LIST point to the list of new scopes.
    !
    PREVSCOPE = NEW_SCOPE_LIST;
    PREVSCOPE[SCOPE$L_FLINK] = 0;


    ! If PNVEC is empty (as for CANCEL SCOPE), we build a scope list entry for
    ! numbered scope "0", i.e. for the scope containing the current PC.
    !
    IF .PNVEC[0] EQL 0
    THEN
	BEGIN
	SCOPE = DBG$GET_MEMORY(SCOPE$K_ENTSIZE);
	SCOPE[SCOPE$L_FLINK] = 0;
	SCOPE[SCOPE$L_STATE] = SCOPE$K_NUMBERED;
	SCOPE[SCOPE$L_RSTPTR] = 0;
	SCOPE[SCOPE$L_MODPTR] = 0;
	PREVSCOPE[SCOPE$L_FLINK] = .SCOPE;
	PREVSCOPE = .SCOPE;
	END;


    ! Loop through the PNVEC vector and build a new scope entry for each element
    ! in that vector.
    !
    INCR I FROM 1 TO .PNVEC[0] DO
	BEGIN
	ERRINDEX[0] = .I;


	! Set up pointers to the Pathname Descriptor, the pathname vector in
	! that descriptor, to the first name in the pathname vector, and to the
	! whole pathname string as Counted ASCII.
	!
	PATHNAME = .PNVEC[.I];
	PATHVEC = PATHNAME[PTH$A_PATHVECTOR];
	PNAME = .PATHVEC[0];
	DBG$NPATHDESC_TO_CS(.PATHNAME, PATH_STRING);


	! Make sure there is no data qualification in the pathname.
	!
	IF .PATHNAME[PTH$B_TOTCNT] NEQ .PATHNAME[PTH$B_PATHCNT]
	THEN
	    SIGNAL(DBG$_BADSCOPE, 1, .PATH_STRING);


	! If the first name in the pathname is null, we either have a numbered
	! scope or the global scope.  Handle these two cases.
	!
	IF .PNAME[0] EQL 0
	THEN
	    BEGIN
	    IF .PATHNAME[PTH$B_TOTCNT] NEQ 1
	    THEN
		SIGNAL(DBG$_BADSCOPE, 1, .PATH_STRING);


	    ! If this is the Global scope (i.e., "\"), build a Global Scope
	    ! Entry for inclusion on the new scope list.
	    !
	    IF .PATHNAME[PTH$B_LOCINVOC] EQL 0
	    THEN
		BEGIN
		SCOPE = DBG$GET_MEMORY(SCOPE$K_ENTSIZE);
		SCOPE[SCOPE$L_FLINK] = 0;
		SCOPE[SCOPE$L_STATE] = SCOPE$K_GLOBAL;
		SCOPE[SCOPE$L_RSTPTR] = 0;
		SCOPE[SCOPE$L_MODPTR] = 0;
		END


	    ! If this is a Numbered scope (i.e., "0"), build a Numbered Scope
	    ! Entry for inclusion on the new scope list.
	    !
	    ELSE IF .PATHNAME[PTH$B_LOCINVOC] EQL 1
	    THEN
		BEGIN
		SCOPE = DBG$GET_MEMORY(SCOPE$K_ENTSIZE);
		SCOPE[SCOPE$L_FLINK] = 0;
		SCOPE[SCOPE$L_STATE] = SCOPE$K_NUMBERED;
		SCOPE[SCOPE$L_RSTPTR] = 0;
		SCOPE[SCOPE$L_MODPTR] = .PATHNAME[PTH$L_INVOCNUM];
		END


	    ! Anything else with a null first name is an error.
	    !
	    ELSE
		SIGNAL(DBG$_BADSCOPE, 1, .PATH_STRING);

	    END


	! This seems to be an ordinary pathname.  Look it up in the RST.  If it
	! is not there, we see if it names a new module; if so, we SET that mod-
	! ule and look up the symbol in that module.
	!
	ELSE
	    BEGIN


	    ! Look up the pathname in the currently SET scopes and modules.  We
	    ! have a loop here since we may have to repeat the process if the
	    ! new scope is in a module which is not yet SET.
	    !
	    MODPTR = 0;
	    WHILE TRUE DO
		BEGIN


		! Look up the symbol in the current scopes.  Then see what KIND
		! of symbol we got back.  We do not accept global (GST) symbols.
		!
		RST$SET_SCOPE = TRUE;
		DBG$STA_GETSYMBOL(.PATHNAME, RSTPTR, KIND);
		IF .RSTPTR NEQ 0
		THEN
		    IF .RSTPTR[RST$V_GLOBAL] THEN KIND = RST$K_INVALID;

		CASE .KIND FROM RST$K_KIND_MINIMUM TO RST$K_KIND_MAXIMUM OF
		    SET


		    ! If the symbol is not unique, return with an error.
		    !
		    [RST$K_NOTUNIQUE]:
			BEGIN


			! If this is the second time through, cancel the module
			! we SET the last time through.  Then signal not unique.
			!
			IF .MODPTR NEQ 0
			THEN
			    STATUS = DBG$RST_CANMOD(PNAME[1], .PNAME[0]);
 		        SIGNAL(DBG$_NOUNIQUE, 1, .PATH_STRING);
			END;


		    ! If the symbol is a lexical entity, it is a valid scope.
		    ! Clear MODPTR to indicate this.
		    !
		    [RST$K_MODULE, RST$K_ROUTINE, RST$K_BLOCK]:
			BEGIN
			MODPTR = 0;
			END;


		    ! If the symbol is a Line Number, the actual scope is the
		    ! containing lexical entity.  Change RSTPTR accordingly and
		    ! set MODPTR to zero to indicate we have a good scope.
		    !
		    [RST$K_LINE]:
			BEGIN
			RSTPTR = .RSTPTR[RST$L_UPSCOPEPTR];
			KIND = .RSTPTR[RST$B_KIND];
			MODPTR = 0;
			END;


		    ! If the symbol is anything else, this is not a valid scope.
		    ! We thus try to interpret the first name in the pathname as
		    ! a module name.  If this succeeds, we SET that module and
		    ! loop to look up the scope again.
		    !
		    [INRANGE]:
			BEGIN


			! If this is the second time around (i.e., we tried a
			! new module), cancel the new module and return error.
			!
			IF .MODPTR NEQ 0
			THEN
			    BEGIN
			    STATUS = DBG$RST_CANMOD(PNAME[1], .PNAME[0]);
			    SIGNAL(DBG$_BADSCOPE, 1, .PATH_STRING);
			    END;


			! First time around.  Try to SET the module given by the
			! first name in the Pathname Descriptor.  If that is the
			! only name, the module is the scope we want; otherwise
			! we try the look-up again in the new module.
			!
			RSTPTR = GET_MOD_RST(PNAME[1], .PNAME[0]);
    		
    			! If the first name is not a module, signal an error.
    			!
			IF .RSTPTR EQL 0 THEN SIGNAL(DBG$_BADSCOPE, 1, .PATH_STRING);

    			! If the module is already set, and the pathname is more
    			! than a single name, then there is no use going on with
    			! the search. Signal an error.
    			!
    			IF .RSTPTR[RST$V_MODSET] AND 
    			   .PATHNAME[PTH$B_TOTCNT] NEQ 1
    			    THEN
    			    SIGNAL (DBG$_BADSCOPE, 1, .PATH_STRING);

    			! If the module is not set, try to set it.
    			!
			IF NOT .RSTPTR[RST$V_MODSET] 
    			THEN
    			    BEGIN    		
			    STATUS = DBG$RST_SETMOD(PNAME[1], .PNAME[0]);
			    IF NOT .STATUS THEN SIGNAL(DBG$_DEBUGBUG, 1, 186);
    			    END;

    			! If we had a single name, we leave MODPTR at zero, which
    			! implies that we exit the loop below. If we had a
    			! path with more than one name, we set MODPTR and this
    			! will cause us to loop, trying again to find the 
    			! pathname in the newly set module.
    			!
    			IF .PATHNAME[PTH$B_TOTCNT] NEQ 1 THEN MODPTR = .RSTPTR;
			END;

		    TES;


		! If MODPTR is non-zero, we have a new module to try the look-up
		! in, so we loop.  Otherwise, we exit this WHILE loop.
		!
		IF .MODPTR EQL 0 THEN EXITLOOP;
		END;


	    ! We have now found the scope in the RST.  Create a Normal scope
	    ! entry for it.
	    !
	    MODPTR = .RSTPTR;
	    WHILE .MODPTR[RST$B_KIND] NEQ RST$K_MODULE DO
		MODPTR = .MODPTR[RST$L_UPSCOPEPTR];

	    SCOPE = DBG$GET_MEMORY(SCOPE$K_ENTSIZE);
	    SCOPE[SCOPE$L_FLINK] = 0;
	    SCOPE[SCOPE$L_STATE] = SCOPE$K_NORMAL;
	    SCOPE[SCOPE$L_RSTPTR] = .RSTPTR;
	    SCOPE[SCOPE$L_MODPTR] = .MODPTR;


	    ! Lock the scope's RST entry in memory.
	    !
	    LOCKNODE[DBG$L_LINK_NODE_LINK] = 0;
	    LOCKNODE[DBG$L_LINK_NODE_VALUE] = .RSTPTR;
	    DBG$STA_LOCK_SYMID(LOCKNODE);

	    END;			! End of normal scope ELSE clause


	! We have now created a Scope Entry of some kind.  Attach it to the
	! end of the new scope list we are building.
	!
	PREVSCOPE[SCOPE$L_FLINK] = .SCOPE;
	PREVSCOPE = .SCOPE;

	END;				! End of INCR loop over PNVEC vector


    ! We have now built the new scope list successfully.  Note this by setting
    ! ERRINDEX to zero.
    !
    ERRINDEX[0] = 0;


    ! Append two more scope entries to the end of the new scope list: one for
    ! all SET modules and one for the global (GST) scope.
    !
    SCOPE = DBG$GET_MEMORY(SCOPE$K_ENTSIZE);
    SCOPE[SCOPE$L_FLINK] = 0;
    SCOPE[SCOPE$L_STATE] = SCOPE$K_SETMODS;
    SCOPE[SCOPE$L_RSTPTR] = 0;
    SCOPE[SCOPE$L_MODPTR] = 0;
    PREVSCOPE[SCOPE$L_FLINK] = .SCOPE;
    PREVSCOPE = .SCOPE;
    SCOPE = DBG$GET_MEMORY(SCOPE$K_ENTSIZE);
    SCOPE[SCOPE$L_FLINK] = 0;
    SCOPE[SCOPE$L_STATE] = SCOPE$K_GLOBAL;
    SCOPE[SCOPE$L_RSTPTR] = 0;
    SCOPE[SCOPE$L_MODPTR] = 0;
    PREVSCOPE[SCOPE$L_FLINK] = .SCOPE;


    ! Then loop through the old scope list and release all the old scope entries
    ! to the free memory pool.  Note that we unlock normal scope RST entries.
    !
    WHILE .SCOPE$LIST NEQ 0 DO
	BEGIN
	IF .SCOPE$LIST[SCOPE$L_STATE] EQL SCOPE$K_NORMAL
	THEN
	    BEGIN
	    LOCKNODE[DBG$L_LINK_NODE_LINK] = 0;
	    LOCKNODE[DBG$L_LINK_NODE_VALUE] = .SCOPE$LIST[SCOPE$L_RSTPTR];
	    DBG$STA_UNLOCK_SYMID(LOCKNODE);
	    END;

	PREVSCOPE = .SCOPE$LIST;
	SCOPE$LIST = .PREVSCOPE[SCOPE$L_FLINK];
	DBG$REL_MEMORY(.PREVSCOPE);
	END;


    ! Set the start address of the new scope list in SCOPE_LIST; that makes it
    ! official.  Then return.
    !
    SCOPE$LIST = .NEW_SCOPE_LIST;
    RETURN;

    END;

ROUTINE BUILD_LABEL_RST(DSTPTR) =
!
! FUNCTION
!	This routine builds a skeleton Label RST Entry.  The main thing it does,
!	however, is to determine if a label is a numeric label.  If the label is
!	numeric, a memory block is allocated to hold both the Label RST Entry
!	and a dummy DST record for that label.  The dummy DST record is set up
!	so that the name field contains "%LABEL nnn" where nnn is the label num-
!	ber stripped of all leading zeroes.  This allows the Debugger to search
!	for "%LABEL nnn" as it searches for any other symbol without making any
!	special provisions for the "%LABEL" part (other than when parsing).
!
! INPUTS
!	DSTPTR	- A pointer to the original label DST record for the label.
!
! OUTPUTS
!	A pointer to a skeleton Label RST Entry is returned as the routine's
!		  value.  The RST$L_DSTPTR field is filled in correctly in this
!		  entry, but all other fields are empty.  If the label is numer-
!		  ic, this pointer points to a dummy DST record with a modified
!		  label name; otherwise it points to the original DST record.
!

    BEGIN

    MAP
	DSTPTR: REF DST$RECORD;		! Pointer to original label DST record

    LOCAL
	FIRSTLOC,			! Location of first non-zero digit
	J,				! Index into new label name string
	NAMEPTR: REF VECTOR[,BYTE],	! Pointer to original name string
	NEWDST: REF DST$RECORD,		! Pointer to new "dummy" DST record
	NEWNAME: REF VECTOR[,BYTE],	! Pointer to new label name string
	NUMLBL_FLAG,			! Set to TRUE if label is numeric
	RSTPTR: REF RST$ENTRY;		! Pointer to new Label RST Entry



    ! Determine if the input label's name is fully numeric.  Also determine the
    ! location of the first non-zero digit in the name.
    !
    NAMEPTR = DSTPTR[DST$B_NAME];
    FIRSTLOC = 0;
    NUMLBL_FLAG = TRUE;
    INCR I FROM 1 TO .NAMEPTR[0] DO
	BEGIN
	IF (.NAMEPTR[.I] LSS '0') OR (.NAMEPTR[.I] GTR '9')
	THEN
	    BEGIN
	    NUMLBL_FLAG = FALSE;
	    EXITLOOP;
	    END;

	IF (.NAMEPTR[.I] NEQ '0') AND (.FIRSTLOC EQL 0) THEN FIRSTLOC = .I;
	END;

    IF .FIRSTLOC EQL 0 THEN FIRSTLOC = .NAMEPTR[0];


    ! If the label is not numeric, get a memory block for the Label RST Entry
    ! only, put the DST pointer in the RST$L_DSTPTR field, and return.
    !
    IF (NOT .NUMLBL_FLAG) OR (.NAMEPTR[0] EQL 0)
    THEN
	BEGIN
	RSTPTR = DBG$GET_MEMORY(RST$K_LBLENTSIZ);
	RSTPTR[RST$L_DSTPTR] = .DSTPTR;
	RETURN .RSTPTR;
	END;


    ! The label is numeric.  Allocate a memory block large enough to hold both
    ! the Label RST Entry and a dummy DST record for the label.  The name in
    ! this dummy DST record is set to "%LABEL nnn" where nnn is all the digits
    ! of the label number except for leading zeroes.  We then return.
    !
    RSTPTR = DBG$GET_MEMORY(RST$K_LBLENTSIZ + (.NAMEPTR[0] - .FIRSTLOC + 19)/4);
    NEWDST = .RSTPTR + 4*RST$K_LBLENTSIZ;
    RSTPTR[RST$L_DSTPTR] = .NEWDST;
    NEWDST[DST$B_LENGTH] = .NAMEPTR[0] - .FIRSTLOC + 15;
    NEWDST[DST$B_TYPE] = DST$K_LABEL;
    NEWDST[DST$B_VFLAGS] = 0;
    NEWDST[DST$L_VALUE] = .DSTPTR[DST$L_VALUE];
    NEWNAME = NEWDST[DST$B_NAME];
    NEWNAME[1] = '%';
    NEWNAME[2] = 'L';
    NEWNAME[3] = 'A';
    NEWNAME[4] = 'B';
    NEWNAME[5] = 'E';
    NEWNAME[6] = 'L';
    NEWNAME[7] = ' ';
    J = 7;
    INCR I FROM .FIRSTLOC TO .NAMEPTR[0] DO
	BEGIN
	J = .J + 1;
	NEWNAME[.J] = .NAMEPTR[.I];
	END;

    NEWNAME[0] = .J;
    RETURN .RSTPTR;

    END;

ROUTINE CHECK_DUPLICATE(DSTPTR, UPSCOPEPTR): NOVALUE =
!
! FUNCTION
!	This routine removes duplicate RST entries in BLISS modules from the
!	RST Hash Table.  It accepts as input the DST pointer for a new symbol
!	about to be inserted in the RST of a module whose RST is being built.
!	It also accepts as input the RST pointer immediately up-scope from the
!	new symbol.  It then determines if there are any "old" symbols already
!	in the RST with the same name in the same environment.  If such a sym-
!	bol is found, it is removed from the RST Hash Table so that subsequent
!	symbol look-ups for that name will only find the new symbol, not the
!	old one.  The old symbol's RST entry is left intact, however, because
!	it can still be accessed via the Static Address Table if the symbol is
!	static.
!
!	This peculiar algorithm is left over from the days when there were no
!	DST Block-Begin and Block-End records, even though BLISS programs could
!	declare the same symbol in different blocks.  BLISS puts out the DST
!	records for all such symbols and then expects DEBUG to throw away all
!	but the last such symbol.  This is a documented feature.  MAP declara-
!	tions for routine parameters also give rise to duplicate DST records.
!
! INPUTS
!	DSTPTR	- A pointer to the new symbol's DST record.  This pointer is
!		  used to find the new symbol's name.
!
!	UPSCOPEPTR - A pointer to the RST entry which defines the current
!		  environment, i.e. the RST entry which will be immediately
!		  up-scope from the new symbol's RST entry.  This defines
!		  the environment in which the new symbol must be unique.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	DSTPTR: REF DST$RECORD;		! Pointer to new symbol's DST record

    LOCAL
	BLINK: REF RST$ENTRY,		! RST Hash Chain backward link
	FLINK: REF RST$ENTRY,		! RST Hash Chain forward link
	NAMEPTR,			! Pointer to the new symbol's name
					!      as a Counted ASCII string
	RSTPTR: REF RST$ENTRY;		! Pointer to RST entry of an old symbol
					!      with same name as the new symbol



    ! If there already is a data item by the same name in the same
    ! scope, remove that item from the RST Hash Table.
    !
    NAMEPTR = DBG$GET_DST_NAME(.DSTPTR);
    DBG$HASH_FIND_SETUP(.NAMEPTR);
    WHILE TRUE DO
	BEGIN
	RSTPTR = DBG$HASH_FIND(.NAMEPTR);
	IF .RSTPTR EQL 0 THEN EXITLOOP;
	IF .RSTPTR[RST$L_UPSCOPEPTR] EQL .UPSCOPEPTR
	THEN
    	    BEGIN
    	    FLINK = .RSTPTR[RST$L_HASH_FLINK];
    	    BLINK = .RSTPTR[RST$L_HASH_BLINK];
    	    FLINK[RST$L_HASH_BLINK] = .BLINK;
    	    BLINK[RST$L_HASH_FLINK] = .FLINK;
    	    RSTPTR[RST$L_HASH_FLINK] = .RSTPTR;
    	    RSTPTR[RST$L_HASH_BLINK] = .RSTPTR;
    	    EXITLOOP;
    	    END;

	END;

    RETURN;

    END;

ROUTINE COPY_COMP_LIST(OLDPTR): NOVALUE =
!
! FUNCTION
!	This routine copies a record component list from a component list
!	memory block to memory inside a Data Type RST Entry memory block.
!	This is done because component lists must be accumulated in separate
!	memory blocks which can be dynamically grown, but once accumulated,
!	they are packed into the exact amount of space they need in the Type
!	RST Entry.  Putting the component list in the same memory block as
!	the Type RST Entry also simplifies keeping reference counts and the
!	deallocation of RST entries.
!
!	This routine calls COPY_VARIANT_LIST which in turn calls this routine
!	recursively.  This recursion corresponds to the nesting of records and
!	variants in the DST.
!
! INPUTS
!	OLDPTR	- A pointer to the component list memory block to be copied.
!		  This memory block is released to the free memory pool after
!		  being copied.
!
!	TYPRSTLOC is an implicit input.  It specifies where the new copy should
!		  be placed in the Type RST Entry memory block.
!
! OUTPUTS
!	TYPRSTLOC is an implicit output.  It is updated to point to the next
!		  available location in the Type RST Entry memory block.
!
!	No value is returned.
!

    BEGIN

    MAP
	OLDPTR: REF VECTOR[,LONG];	! Pointer to the list to be copied

    LOCAL
	NEWPTR: REF VECTOR[,LONG],	! Pointer to the new copy of the list
	RPTR: REF RST$ENTRY;		! Pointer to component RST entry



    ! Allocate space for the new copy in the Data Type RST Entry.  Then copy the
    ! old list over to the new location.  Copy any Variant RST Entries into the
    ! Type RST Entry by calling COPY_VARIANT_LIST recursively.  Also change the
    ! kind of all data record components to RST$K_TYPCOMP and set their up-scope
    ! pointers to point to the Type RST Entry.
    !
    NEWPTR = .TYPRSTLOC;
    TYPRSTLOC = TYPRSTLOC[.OLDPTR[0] + 1];
    NEWPTR[0] = .OLDPTR[0];
    INCR I FROM 1 TO .OLDPTR[0] DO
	BEGIN
	RPTR = .OLDPTR[.I];
	IF .RPTR[RST$B_KIND] EQL RST$K_VARIANT
	THEN
	    RPTR = COPY_VARIANT_LIST(.RPTR)

	ELSE
	    BEGIN
	    RPTR[RST$B_KIND] = RST$K_TYPCOMP;
	    RPTR[RST$L_UPSCOPEPTR] = .TYPRSTPTR;
	    END;

	NEWPTR[.I] = .RPTR;
	END;


    ! Finally release the old component list back to the free memory pool and
    ! return to the caller.
    !
    DBG$REL_MEMORY(.OLDPTR);
    RETURN;

    END;

ROUTINE COPY_VARIANT_LIST(OLDRSTPTR) =
!
! FUNCTION
!	This routine copies a Variant RST Entry and the corresponding variant
!	set list from free-standing memory blocks into memory inside the current
!	Data Type RST Entry's memory block.  This is done so that the variant
!	set list can be grown dynamically while being accumulated, and still use
!	only just enough space in the final RST entry.
!
!	This routine is called only by COPY_COMP_LIST, which it also calls re-
!	cursively.
!
! INPUTS
!	OLDRSTPTR - A pointer to the Variant RST Entry to be copied into the
!		  Data Type RST Entry memory block.  This "old" RST entry and
!		  the associated component list are released back to the free
!		  memory pool.
!
! OUTPUTS
!	A pointer to the new copy of the Variant RST Entry is returned as the
!		  routine value.  This copy is located within the current
!		  Data Type RST Entry.
!

    BEGIN

    MAP
	OLDRSTPTR: REF RST$ENTRY;	! Pointer to Variant RST Entry to copy

    LOCAL
	NEWPTR: REF VECTOR[,LONG],	! Pointer to new variant set table
	NEWRSTPTR: REF RST$ENTRY,	! Pointer to the new Variant RST Entry
	OLDPTR: REF VECTOR[,LONG];	! Pointer to "old" variant set list



    ! Allocate space in the current Data Type RST Entry for the new Variant RST
    ! Entry and its component list.
    !
    OLDPTR = .OLDRSTPTR[RST$L_SYMCHNPTR];
    NEWRSTPTR = .TYPRSTLOC;
    TYPRSTLOC = TYPRSTLOC[RST$K_VARENTSIZ + .OLDPTR[0]/2];
    NEWPTR = NEWRSTPTR[RST$A_VARSETTBL];


    ! Fill in the fields in the Variant RST Entry.
    !
    NEWRSTPTR[RST$L_HASH_FLINK] = .NEWRSTPTR;
    NEWRSTPTR[RST$L_HASH_BLINK] = .NEWRSTPTR;
    NEWRSTPTR[RST$L_SYMCHNPTR] = 0;
    NEWRSTPTR[RST$L_DSTPTR] = .OLDRSTPTR[RST$L_DSTPTR];
    NEWRSTPTR[RST$L_VARTAGPTR] = .OLDRSTPTR[RST$L_VARTAGPTR];
    NEWRSTPTR[RST$B_KIND] = RST$K_VARIANT;
    NEWRSTPTR[RST$W_REFCOUNT] = 0;


    ! Copy the variant set component list (which points to the tag value DST
    ! record and the variant component list for each variant in the set) over
    ! to the new Variant RST Entry in the current Type RST Entry's memory
    ! block.  Note that we call COPY_COMP_LIST which may recursively call this
    ! routine again.
    !
    NEWRSTPTR[RST$L_VARSETCNT] = .OLDPTR[0]/2;
    INCR I FROM 1 TO .OLDPTR[0]/2 DO
	BEGIN
	NEWPTR[.I - 1] = .TYPRSTLOC;
	TYPRSTLOC[0] = .OLDPTR[2*.I - 1];
	TYPRSTLOC = TYPRSTLOC[1];
	COPY_COMP_LIST(.OLDPTR[2*.I]);
	END;


    ! Finally release the old variant RST entry and component list memory blocks
    ! back to the memory pool.  Return the address of the new Variant RST Entry
    ! to the caller.
    !
    DBG$REL_MEMORY(.OLDRSTPTR);
    DBG$REL_MEMORY(.OLDPTR);
    RETURN .NEWRSTPTR;

    END;

ROUTINE COMP_LIST_ADD_ENTRY(COMP_LST_PTR, COMP_LST_SIZE, VALUE): NOVALUE =
!
! FUNCTION
!	This routine adds an entry to a "component list".  Such a list consists
!	of a memory block whose first longword contains a count giving the num-
!	ber of entries on the list.  The longwords that follow contain the list
!	elements, one per longword.  This routine increments the count and ap-
!	pends the new component value to the list.  If this would cause the list
!	memory block to overflow, a new, larger block is allocated and the list
!	is copied to that block before the new value is appended.
!
! INPUTS
!	COMP_LST_PTR - The address of the pointer to the component list memory
!		  block to which the new value should be appended.
!
!	COMP_LST_SIZE - The address of the location giving the number of list
!		  components the memory block can hold.  This is one less than
!		  the size of the list memory block in longwords.
!
!	VALUE	- The value to be appended at the end of the component list.
!
! OUTPUTS
!	COMP_LST_PTR - If a new memory block had to be allocated to accommodate
!		  the new list entry, the address of that new memory block is
!		  returned to COMP_LST_PTR.  The old block is deallocated.
!
!	COMP_LST_SIZE - If a new memory block had to be allocated to accommodate
!		  the new list entry, the number of list entries the new memory
!		  block can hold is returned to COMP_LST_SIZE.
!

    BEGIN

    MAP
	COMP_LST_PTR: REF VECTOR[1],	! Pointer to pointer to component list
	COMP_LST_SIZE: REF VECTOR[1];	! Pointer to size of component list

    LOCAL
	LISTPTR: REF VECTOR[,LONG],	! Pointer to component list
	NEWPTR;				! Pointer to new memory block for list



    ! If the component list memory block is about to overflow, get a new,
    ! larger memory block and copy the contents of the old block into the
    ! new block.  Then release the old block to the free memory pool.
    !
    LISTPTR = .COMP_LST_PTR[0];
    IF .LISTPTR[0] EQL .COMP_LST_SIZE[0]
    THEN
	BEGIN
	NEWPTR = DBG$GET_MEMORY(.COMP_LST_SIZE[0] + 11);
	CH$MOVE(4*(.LISTPTR[0] + 1), .LISTPTR, .NEWPTR);
	COMP_LST_PTR[0] = .NEWPTR;
	COMP_LST_SIZE[0] = .COMP_LST_SIZE[0] + 10;
	DBG$REL_MEMORY(.LISTPTR);
	LISTPTR = .NEWPTR;
	END;


    ! Append the new value at the end of the component list vector.
    !
    LISTPTR[0] = .LISTPTR[0] + 1;
    LISTPTR[.LISTPTR[0]] = .VALUE;
    RETURN;

    END;

ROUTINE GET_MEM(LENGTH) =
!
! FUNCTION
!	This routine gets a memory block of a specified size from the free mem-
!	ory pool.  If there is no memory left in the pool, it expands the free
!	memory pool via DBG$EXPAND_MEMORY (which gets more space from the system
!	via LIB$GET_VM).  It then gets the desired block from the expanded pool.
!	If the expansion fails for some reason, zero is returned instead of a
!	block address.
!
!	This routine is used only during Run-Time Symbol Table initialization.
!	After that, the free memory pool is not allowed to expand into the user
!	address space because that could cause DEBUG space and user space to
!	become checkerboarded.  That would make it more likely that the Debugger
!	could interfere with the behavior of the user program being debugged.
!
! INPUTS
!	LENGTH	- The length in longwords of the desired memory block.
!
! OUTPUTS
!	The start address of the returned memory block is returned as the value
!	of GET_MEM.  If no memory could be found, the returned value is zero.
!

    BEGIN

    LOCAL
	ADDRESS,			! Pointer to the allocated memory block
	STATUS: BLOCK[1,LONG];		! Status code from DBG$EXPAND_MEMORY



    ! Get the desired memory block from DBG$GET_MEMORY.  If that succeeds,
    ! simply return the block's address right away.
    !
    ADDRESS = DBG$GET_MEMORY(.LENGTH, 0);
    IF .ADDRESS NEQ 0 THEN RETURN .ADDRESS;


    ! If we could not get any memory, try to expand the memory pool.  If that
    ! fails, signal the error (with informational severity) and return a zero
    ! instead of a block address.
    !
    STATUS = DBG$EXPAND_MEMORY(MAX(16384 - 3, .LENGTH + 1));
    IF NOT .STATUS
    THEN
	BEGIN
	STATUS = DBG$_NOFREE;
	STATUS[STS$V_SEVERITY] = SYS$K_INFO;
	SIGNAL(.STATUS);
	RETURN 0;
	END;


    ! The memory pool was successfully expanded.  Now allocate the block we
    ! desire--this time it is guaranteed to work.
    !
    RETURN DBG$GET_MEMORY(.LENGTH);

    END;

ROUTINE GET_MOD_RST(MODNAMEPTR, LENGTH) =
!
! FUNCTION
!	This routine looks up a specified module name in the RST and returns a
!	pointer to the corresponding Module RST Entry.
!
! INPUTS
!	MODNAMEPTR - A pointer to the first character of the ASCII string con-
!		  taining the desired module's name.
!
!	LENGTH	- The length of the module name in characters.
!
! OUTPUTS
!	A pointer to the specified module's Module RST Entry is returned as the
!		  routine's value.  If no such routine exists in the RST, a zero
!		  is returned instead.
!

    BEGIN

    LOCAL
	DSTNAME: REF VECTOR[,BYTE],	! Pointer to the current module's name
					!      in the DST (as Counted ASCII)
	RSTPTR: REF RST$ENTRY;		! A pointer to the current Module RST
					!      Entry



    ! Search the RST Module Chain for a module with the specified name.  If we
    ! find such a module, exit the search loop with RSTPTR pointing to the
    ! desired Module RST Entry.  If we exhaust the loop, RSTPTR is zero.  In
    ! either case, return whatever value RSTPTR has.
    !
    RSTPTR = .RST$START_ADDR;
    WHILE .RSTPTR NEQ 0 DO
	BEGIN
	IF NOT .RSTPTR[RST$V_ANONMOD]
	THEN
	    BEGIN
	    DSTNAME = DBG$GET_DST_NAME(.RSTPTR[RST$L_DSTPTR]);
	    IF CH$EQL(.DSTNAME[0], DSTNAME[1], .LENGTH, .MODNAMEPTR, 0)
	    THEN
		EXITLOOP;

	    END;

	RSTPTR = .RSTPTR[RST$L_NXTMODPTR];
	END;

    RETURN .RSTPTR;

    END;

ROUTINE GET_TYPEPTR(DATA_DSTPTR, MODNAMEPTR, TYPE_DSTPTR, ARRAY_FLAG): NOVALUE =
!
! FUNCTION
!	This routine determines whether a given data item is of a record type or
!	an enumeration type, and if so, what the address is of the DST record
!	which defines that type (the Record Begin or Enumeration Type Begin DST
!	record).  The routine is called during the RST build procedure so that
!	the RST$L_TYPEPTR field can be filled in for record and enumeration type
!	data items.
!
!	If the given data item is of an array type, this routine determines if
!	the array's cell type is a record data type.  If so, the address of the
!	cell type's Record Begin DST record is returned and TRUE is returned to
!	the ARRAY_FLAG parameter.  This information allows the RST build proce-
!	dure to build the record type's Type RST Entry so that it has a refer-
!	ence pointer to the array's Data RST Entry.  This information is later
!	used by the DBG$STA_GETSYMBOL routine during symbol lookup.
!
! INPUTS
!	DATA_DSTPTR - A pointer to the data item DST record whose type is to be
!		  determined.
!
!	MODNAMEPTR - A pointer to the current module's name as Counted ASCII.
!		  This is used only for error messages.
!
!	TYPE_DSTPTR - A pointer to a longword location to receive a pointer
!		  to a Record Begin or Enumeration Type Begin DST record.
!
!	ARRAY_FLAG - A pointer to a longword location to receive the array
!		  flag returned by this routine.
!
! OUTPUTS
!	TYPE_DSTPTR - If the data item is an object of a record or enumeration
!		  data type, the address of the corresponding Record Begin or
!		  Enumeration Type Begin DST record is returned to TYPE_DSTPTR.
!		  If the data item is an array whose cell type is a record data
!		  type, the address of the cell type's Record Begin DST record
!		  is returned to TYPE_DSTPTR.  In all other cases, zero is re-
!		  turned to TYPE_DSTPTR.
!
!	ARRAY_FLAG - If the data item is an array whose cell type is a record
!		  data type, TRUE is returned to ARRAY_FLAG.  Otherwise, FALSE
!		  is returned to ARRAY_FLAG.
!
!	No value is returned.
!

    BEGIN

    MAP
	TYPE_DSTPTR: REF VECTOR[1],	! Pointer to Type DST pointer longword
	ARRAY_FLAG: REF VECTOR[1];	! Pointer to array flag longword

    LOCAL
	DSTPTR: REF DST$RECORD,		! Pointer to the current DST record
	FBPTR: REF BITVECTOR[],		! Pointer to Array Type Spec flag bits
	LOCAL_ARRAY_FLAG,		! Set to TRUE if data item is an array
	TSPTR: REF DST$TYPE_SPEC,	! Pointer to a DST Type Spec
	VSPTR: REF DST$VAL_SPEC;	! Pointer to the descriptor Value Spec
					!      in an Array Type Spec



    ! Initially we clear both output parameters.
    !
    TYPE_DSTPTR[0] = 0;
    ARRAY_FLAG[0] = FALSE;


    ! Unless the data item is a DST$K_SEPTYP DST record, it cannot point to a
    ! record or enumeration type definition, so we return immediately.
    !
    DSTPTR = .DATA_DSTPTR;
    IF .DSTPTR[DST$B_TYPE] NEQ DST$K_SEPTYP THEN RETURN;


    ! Advance DSTPTR past the DST$K_SEPTYP record.  If the next record is a
    ! Global-is-Next record, skip past that too to get to the record
    ! defining the data type.
    !
    DSTPTR = DSTPTR[DST$A_NEXT] + .DSTPTR[DST$B_LENGTH];
    IF .DSTPTR[DST$B_TYPE] EQL DST$K_GLOBNXT
    THEN
	DSTPTR = DSTPTR[DST$A_NEXT] + .DSTPTR[DST$B_LENGTH];


    ! Loop through any Type Spec indirection in the DST so we can get to the
    ! ultimate type specification for the data item.
    !
    LOCAL_ARRAY_FLAG = FALSE;
    WHILE TRUE DO
	BEGIN


	! If we have now gotten to a Record Begin or Enumeration Type Begin DST
	! record, we exit the indirection loop and return a pointer to that DST
	! record to TYPE_DSTPTR.
	!
	IF .DSTPTR[DST$B_TYPE] EQL DST$K_RECBEG THEN EXITLOOP;
	IF .DSTPTR[DST$B_TYPE] EQL DST$K_ENUMBEG
	THEN
	    BEGIN
	    IF .LOCAL_ARRAY_FLAG THEN RETURN;
	    EXITLOOP;
	    END;


	! If DSTPTR points to anything other than a Record Begin, Enumeration
	! Type Begin, or Type Spec DST record, there is an error in the DST.
	!
	IF .DSTPTR[DST$B_TYPE] NEQ DST$K_TYPSPEC
	THEN
	    SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);


	! This is a Type Spec DST record.  Loop through any nested cell types
	! in Array Type Specs until we get to an Indirect Type Spec or a Novel
	! Length Type Spec (which also indirects).  If we get to an Indirect
	! or Novel Length Type Spec, we pick up the new DST pointer and con-
	! tinue the outer loop; otherwise we return a zero to TYPE_DSTPTR.
	!
	TSPTR = DSTPTR[DST$A_TYPSPEC_TS_ADDR] + .DSTPTR[DST$B_TYPSPEC_NAME];
	WHILE TRUE DO
	    BEGIN


	    ! If this is an Indirect Type Spec, get the new DST pointer and
	    ! continue the outer loop.
	    !
	    IF .TSPTR[DST$B_TS_KIND] EQL DST$K_TS_IND
	    THEN
		BEGIN
		DSTPTR = .TSPTR[DST$L_TS_IND_PTR] + .DST$BEGIN_ADDR;
		EXITLOOP;
		END


	    ! If this is a Novel Length Type Spec, do the same thing.
	    !
	    ELSE IF .TSPTR[DST$B_TS_KIND] EQL DST$K_TS_NOV_LENG
	    THEN
		BEGIN
		DSTPTR = .TSPTR[DST$L_TS_NOV_LENG_PAR_TSPEC] + .DST$BEGIN_ADDR;
		EXITLOOP;
		END


	    ! If this is an Array Type Spec, set the array flag and determine
	    ! whether the cell type can be a record type.  If not, return zero
	    ! to TYPE_DSTPTR.  Otherwise, get the pointer to the cell type Type
	    ! Spec and continue the inner loop.
	    !
	    ELSE IF .TSPTR[DST$B_TS_KIND] EQL DST$K_TS_ARRAY
	    THEN
		BEGIN
		LOCAL_ARRAY_FLAG = TRUE;
		FBPTR = TSPTR[DST$A_TS_ARRAY_FLAGS_ADDR];
		IF NOT .FBPTR[0] THEN RETURN;
		VSPTR = .FBPTR + (.TSPTR[DST$B_TS_ARRAY_DIM] + 8)/8;
		IF .VSPTR[DST$B_VS_VFLAGS] EQL DST$K_VS_FOLLOWS
		THEN
		    TSPTR = VSPTR[DST$B_VS_ALLOC] + .VSPTR[DST$W_VS_LENGTH]

		ELSE
		    TSPTR = VSPTR[DST$A_VS_TVS_BASE];

		END


	    ! For any other kind of Type Spec, it is not possible to reach a
	    ! Record Begin or Enumeration Type Begin DST record so we return
	    ! zero to TYPE_DSTPTR.
	    !
	    ELSE
		RETURN;

	    END;			! End of inner cell type loop

	END;				! End of outer indirection loop


    ! We found a Record or Enumeration Type type specification.  Return a
    ! pointer to the corresponding DST record and return the array flag value.
    !
    TYPE_DSTPTR[0] = .DSTPTR;
    IF .DSTPTR NEQ 0 THEN ARRAY_FLAG[0] = .LOCAL_ARRAY_FLAG;
    RETURN;

    END;

ROUTINE RST_BUILD_ERROR_HANDLER(SIGARG, MECHARG, ENBLARG) =
!
! FUNCTION
!	This routine is the error handler for DBG$RST_BUILD.  The only error
!	condition it checks for is DBG$_NOFREE, i.e. running out of memory
!	while building the RST for some module.  When this condition occurs,
!	this handler calls DBG$RST_REMOVE to release all the RST space which
!	was allocated during the attempt to build the module's RST.  It then
!	resignals the error.
!
! INPUTS
!	SIGARG	- The address of the signal argument vector.
!
!	MECHARG	- The address of the mechanism argument vector.
!
!	ENBLARG	- The address of the enable argument vector.
!
! OUTPUTS
!	If the error was DBG$_NOFREE, the module being built is removed from
!	the RST.  The error is always resignalled.
!

    BEGIN

    MAP
	SIGARG: REF VECTOR[,LONG];	! The signal argument vector

    LOCAL
    	RSTPTR: REF RST$ENTRY;


    ! If we ran out of memory, remove the partially built module from the RST.
    ! Also mark the module as being cancelled.
    ! Then resignal the error.
    !
    IF .SIGARG[1] EQL DBG$_NOFREE 
    THEN 
    	BEGIN
    	RSTPTR = .MOD_BEING_BUILT;
    	RSTPTR[RST$V_MODSET] = FALSE;
    	DBG$RST_REMOVE(.MOD_BEING_BUILT);
    	END;
    RETURN SS$_RESIGNAL;

    END;

ROUTINE SETSCOPE_ERROR_HANDLER(SIGARG, MECHARG, ENBLARG) =
!
! FUNCTION
!	This routine is the error handler for the DBG$RST_SETSCOPE routine.
!	All it does is to handle the DBG$_BADSCOPE and DBG$_NOFREE errors by
!	releasing all Scope Entries accumulated on NEW_SCOPE_LIST back to the
!	memory pool so they are not lost.  For DBG$_BADSCOPE, the handler then
!	unwinds so that control is returned to the routine that called routine
!	DBG$RST_SETSCOPE.  Otherwise, it just resignals the error.
!
! INPUTS
!	SIGARG	- The signal argument vector.
!
!	MECHARG	- The mechanism argument vector.
!
!	ENBLARG	- The enable argument vector.  ENBLARG[1] is assumed to
!		  contains the address of NEW_SCOPE_LIST.
!
! OUTPUTS
!	For the DBG$_BADSCOPE error, this handler unwinds the call stack.
!		  For all other errors, it resignals.
!

    BEGIN

    MAP
	SIGARG: REF VECTOR[,LONG],	! Signal argument vector
	ENBLARG: REF VECTOR[,LONG];	! Enable declaration argument vector

    BIND
	NEW_SCOPE_LIST = .ENBLARG[1];	! Address of pointer to new scope list

    LOCAL
	RELSCOPE,			! Pointer to scope entry being released
	SCOPE: REF SCOPE$ENTRY;		! Pointer to the next scope list entry



    ! If the condition code is anything other than DBG$_BADSCOPE or DBG$_NOFREE,
    ! just resignal the error.
    !
    IF .SIGARG[1] NEQ DBG$_BADSCOPE AND
       .SIGARG[1] NEQ DBG$_NOUNIQUE AND
       .SIGARG[1] NEQ DBG$_NOFREE
    THEN
	RETURN SS$_RESIGNAL;


    ! It is one of the errors we handle.  Loop through the new scope list and
    ! release each Scope Entry on it back to the free memory pool.
    !
    SCOPE = .NEW_SCOPE_LIST;
    WHILE .SCOPE NEQ 0 DO
	BEGIN
	RELSCOPE = .SCOPE;
	SCOPE = .SCOPE[SCOPE$L_FLINK];
	DBG$REL_MEMORY(.RELSCOPE);
	END;


    ! For DBG$_BADSCOPE, unwind the stack to return control to the caller of
    ! DBG$RST_SETSCOPE.  For DBG$_NOFREE, we simply resignal the error.
    !
    IF .SIGARG[1] EQL DBG$_BADSCOPE THEN SETUNWIND();
    RETURN SS$_RESIGNAL;

    END;

ROUTINE SHARED_IMAGE_NAMES: NOVALUE =
!
! FUNCTION
!	This routine goes through the list of image names in the current
!	execution and creates a Global Symbol for each such image name.
!	The images in the current execution include the user program, all
!	sharable images used by the user program, and even DEBUG itself.
!	For each image name xxx, this routine creates an RST entry for
!	the symbol SHARE$xxx, marks that RST entry as being a global symbol,
!	and attaches it to the global symbol chain off the anonymous module.
!	This is intended to be an aid to programmers debugging shared im-
!	ages since it provides a way of telling where a shared image starts.
!
!	The sharable image names and their addresses are gotten from the
!	Sharable Image List Elements in the Image Activator Fixup Blocks
!	in P1 space.  The external symbol SYS$GL_IAFLINK is used to access
!	the linked list of Image Activator Fixup Blocks; it points to a
!	pointer to the first Fixup Block on the list.
!
!	The Image Activator Fixup Blocks may contain duplicate entries for
!	the same sharable image.  This happens when two sharable images in
!	the execution reference a third image, for example--in this case
!	there are two entries for that third image.  This code assumes
!	that only the first such entry is valid and ignores all succeeding
!	duplicates.  If the image activator is ever changed to invalidate
!	this assumption, this routine could break.
!
! INPUTS
!	NONE
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
	GBLNAME: VECTOR[		! Buffer in which we build the global
		SHL$C_MAXNAMLNG+7,BYTE],!      symbol name "SHARE$xxx"
	IAFPTR: REF BLOCK[,BYTE],	! Pointer to Image Activator Fixup Block
	NAMEPTR: REF VECTOR[,BYTE],	! Pointer to shared image name "xxx"
	RSTPTR: REF RST$ENTRY,		! Pointer to duplicate RST entry
	SHLPTR: REF BLOCKVECTOR[	! Pointer to Sharable Image List vector
		,SHL$K_LENGTH,BYTE];	!



    ! Get the start address of the Image Activator Fixup Block list.  Then loop
    ! through this linked list of Fixup Blocks until we get to the end of the
    ! list, and for each Fixup Block, make global symbols for any image entries
    ! in the block.
    !
    IAFPTR = .SYS$GL_IAFLINK[0];
    WHILE .IAFPTR NEQ 0 DO
	BEGIN
	SHLPTR = .IAFPTR + .IAFPTR[IAF$L_SHLSTOFF];


	! Loop through the vector of Sharable Image List Elements in this Fixup
	! Block.  For each sharable image, create the corresponding global sym-
	! bol by prefixing the image name with "SHARE$".
	!
	INCR I FROM 0 TO .IAFPTR[IAF$L_SHRIMGCNT] - 1 DO
	    BEGIN


	    ! Create the new symbol name by prefixing SHARE$ to the image name.
	    !
	    NAMEPTR = SHLPTR[.I, SHL$T_IMGNAM];
	    CH$MOVE(6, UPLIT BYTE(%ASCII 'SHARE$'), GBLNAME[1]);
	    CH$MOVE(.NAMEPTR[0], NAMEPTR[1], GBLNAME[7]);
	    GBLNAME[0] = .NAMEPTR[0] + 6;


	    ! Determine whether we already have a Global symbol RST entry for
	    ! the SHARE$xxx symbol.  If so, this is a duplicate Fixup Block
	    ! entry and we ignore it.  Otherwise, create a Global symbol RST
	    ! entry for the new symbol.
	    !
	    DBG$HASH_FIND_SETUP(GBLNAME);
	    WHILE TRUE DO
		BEGIN
		RSTPTR = DBG$HASH_FIND(GBLNAME);
		IF .RSTPTR EQL 0
		THEN
		    BEGIN
		    DBG$GST_TO_RST(GBLNAME[0], .SHLPTR[.I,SHL$L_BASEVA], FALSE);
		    EXITLOOP;
		    END;

		IF .RSTPTR[RST$V_GLOBAL] THEN EXITLOOP;
		END;

	    END;


	! Link to the next Image Activator Fixup Block and loop.
	!
	IAFPTR = .IAFPTR[IAF$L_IAFLINK];
	END;


    ! We have now gone through all Fixup Blocks.  Return to the caller.
    !
    RETURN;

    END;


ROUTINE STATIC_ADDRESS(STARTADDR, LENGTH, RSTPTR, SAT_CHAIN, MERGE_FLAG): NOVALUE =
!
! FUNCTION:
!	This routine constructs a Static Address Table (SAT) entry and inserts
!	it in the proper place in a specified SAT chain.  It accepts an address
!	range as input and searches the specified Static Address Table chain
!	until it finds the proper place to insert an entry for the new address
!	range.  The insertion is always done so that the SAT chain remains sort-
!	ed by start address.  If the MERGE_FLAG parameter is set, SAT entries
!	along the way whose address ranges overlap or adjoin the new address
!	range are removed from the SAT chain and their address ranges merged
!	with the new address range.
!
!	This routine is called during RST initialization, when a SAT chain is
!	built for each module in the DST.  These SAT chains are then merged (not
!	by this routine) to produce the Program Static Address Table which says
!	in which modules a given address can be found.  (An address may be found
!	in several modules--Fortran COMMON blocks cause this situation.)
!
!	This routine is also called when the RST and SAT for an individual mod-
!	ule is built.  In this case, the SAT is of course still sorted by start
!	address.  However, if two SAT entries have the same start address, they
!	are always sorted so that the larger end address comes first.  This
!	ordering is required by routine DBG$STA_SETCONTEXT which needs it to
!	determine when there are nested routines which overlap the address range
!	of an outer routine.  The ordering ensures that a nested routine always
!	follows an outer routine in the Module SAT.
!
! INPUTS:
!	STARTADDR - The start address of the address range to be inserted in the
!		  specified Static Address Table Chain.
!
!	LENGTH	- The length in bytes of the STARTADDR address range.
!
!	RSTPTR	- The Run-Time Symbol Table (RST) pointer which specifies the
!		  symbol to which this address range belongs.  When the Program
!		  Static Address Table (which says which module covers which
!		  address range) is built, RSTPTR is zero.  Then GET_MEM is
!		  called to get SAT space instead of DBG$GET_MEMORY.
!
!	SAT_CHAIN - The address of a longword location which contains a pointer
!		  to the first entry on the Static Address Table chain being
!		  built.  If the chain is empty, this location contains a zero.
!
!	MERGE_FLAG - A flag which specifies whether SAT entries on the specified
!		  chain should be merged if their address ranges adjoin or over-
!		  lap.  The flag can have these two values:
!
!			TRUE  -- Merge SAT entries with adjoining or
!				 overlapping address ranges.
!			FALSE -- Do not merge such SAT entries.
!
! OUTPUTS:
!	SAT_CHAIN - A new SAT entry is added to the SAT_CHAIN chain.  Also, old
!		  entries whose address ranges can be merged with the new one
!		  are removed from the chain if MERGE_FLAG is set.  Either oper-
!		  ation can change the value at the SAT_CHAIN location.
!
!	No value is returned by STATIC_ADDRESS.
!

    BEGIN

    MAP
	RSTPTR: REF RST$ENTRY;		! Pointer to symbol's RST entry

    LOCAL
	ADDR1,				! The start address of the input address
					!      range, possibly as expanded by
					!      merging with existing SAT entries
	ADDR2,				! The end address of the input address
					!      range, possibly as expanded by
					!      merging with existing SAT entries
	OLDPTR: REF SAT$ENTRY,		! Pointer to the SAT entry just before
					!      the SATPTR entry in the SAT chain
	SATPTR: REF SAT$ENTRY;		! Pointer to the current SAT entry in
					!      the SAT chain.



    ! Compute the start and end addresses of the address range passed by the
    ! caller.  Also initialize the Static Address Table list pointers.
    !
    ADDR1 = .STARTADDR;
    IF .LENGTH LEQ 0
    THEN
	ADDR2 = .STARTADDR
    ELSE
	ADDR2 = .STARTADDR + .LENGTH - 1;

    OLDPTR = .SAT_CHAIN;
    SATPTR = .OLDPTR[SAT$L_FLINK];


    ! Loop through the entire Static Address Table linked list, looking to see
    ! where we should link in an entry for this static address range or merge
    ! it with existing SAT entries with overlapping address ranges.
    !
    WHILE .SATPTR NEQ 0 DO
	BEGIN


	! If this SAT entry's address range comes before the ADDR1 start address
	! we just link on to the next SAT entry.
	!
	IF .SATPTR[SAT$L_END] + 1 LSSU .ADDR1
	THEN
	    BEGIN
	    OLDPTR = .SATPTR;
	    SATPTR = .SATPTR[SAT$L_FLINK];
	    END


	! If this SAT entry's address range comes after the ADDR2 end address,
	! we have gone too far in the sorted SAT chain, so we exit the loop.
	!
	ELSE IF .ADDR2 + 1 LSSU .SATPTR[SAT$L_START]
	THEN
	    EXITLOOP


	! The current SAT entry's address range overlaps or adjoins the ADDR1 -
	! ADDR2 address range.  If merging of such address ranges is requested,
	! we compute the expanded address range (including both ranges) in ADDR1
	! and ADDR2 and delete the SAT entry from the SAT chain.  We then keep
	! searching the chain in case other SAT entries overlap the new range.
	!
	ELSE IF .MERGE_FLAG
	THEN
	    BEGIN
	    ADDR1 = MIN(.ADDR1, .SATPTR[SAT$L_START]);
	    ADDR2 = MAX(.ADDR2, .SATPTR[SAT$L_END]);
	    OLDPTR[SAT$L_FLINK] = .SATPTR[SAT$L_FLINK];
	    DBG$REL_MEMORY(.SATPTR);
	    SATPTR = .OLDPTR[SAT$L_FLINK];
	    END


	! The current SAT entry's address range overlaps the ADDR1 - ADDR2
	! address range, but merging address ranges is not allowed.  Exit the
	! loop if the ADDR1 start address is less than that in the SAT entry.
	! Also exit the loop if the ADDR1 start address equals that in the SAT
	! entry and the ADDR2 end address is greater than or equal to the SAT
	! entry's end address.  Otherwise, link to the next SAT entry.  This
	! ensures that the SAT chain will remain sorted on start address with
	! the larger end address first if two start addresses are the same.
	!
	ELSE IF (.ADDR1 LSSU .SATPTR[SAT$L_START]) OR
		(.ADDR1 EQLU .SATPTR[SAT$L_START] AND
		 .ADDR2 GEQU .SATPTR[SAT$L_END])
	THEN
	    EXITLOOP

	ELSE
	    BEGIN
	    OLDPTR = .SATPTR;
	    SATPTR = .SATPTR[SAT$L_FLINK];
	    END;

	END;				! End of WHILE loop


    ! Build a new SAT entry containing the ADDR1 - ADDR2 address range and link
    ! it into the SAT chain after the OLDPTR position.  Then return.
    !
    IF .RSTPTR EQL 0
    THEN
	SATPTR = GET_MEM(SAT$K_ENTSIZE)
    ELSE
	SATPTR = DBG$GET_MEMORY(SAT$K_ENTSIZE);

    IF .SATPTR EQL 0 THEN RETURN;
    SATPTR[SAT$L_FLINK] = .OLDPTR[SAT$L_FLINK];
    SATPTR[SAT$L_START] = .ADDR1;
    SATPTR[SAT$L_END] = .ADDR2;
    SATPTR[SAT$L_RSTPTR] = .RSTPTR;
    OLDPTR[SAT$L_FLINK] = .SATPTR;


    ! If RSTPTR points to a Routine RST Entry, put a pointer in that RST entry
    ! to the SAT entry we just built.  This pointer is later used by routine
    ! DBG$STA_SETCONTEXT to find a routine's SAT entry.
    !
    IF .RSTPTR NEQ 0
    THEN
	BEGIN
	IF .RSTPTR[RST$B_KIND] EQL RST$K_ROUTINE
	THEN
	    RSTPTR[RST$L_RTNSATPTR] = .SATPTR;

	END;

    RETURN;

    END;

ROUTINE STATIC_CHECK(DSTPTR, ADDRESS, LENGTH, STATIC_FLAG): NOVALUE =
!
! FUNCTION
!	This routine determines whether a specified data item is static or not.
!	This is done by inspecting the data item's DST entry; the data object is
!	deemed to be static if the object's data address is specified directly
!	in the DST entry or if it is specified in a descriptor directly in the
!	DST entry.  Any use of registers or indirection in the address calcula-
!	tion disqualifies the data item from being deemed static.
!
!	If the data item is static, STATIC_FLAG is set to TRUE and the item's
!	start address and byte length is returned to the caller.  If the data
!	item is not static or if the DST entry is not even that of a data item,
!	STATIC_FLAG is set to FALSE and nothing else is returned.
!
! INPUTS
!	DSTPTR	- A pointer to the Debug Symbol Table (DST) entry of the data
!		  item in question.
!
!	ADDRESS	- The address of a longword location where the address of the
!		  static area is to be returned.
!
!	LENGTH	- The address of a longword location where the length of the
!		  static area is to be returned.
!
!	STATIC_FLAG - The address of a longword location where a flag should
!		  be returned saying whether the data item is static or not.
!
! OUTPUTS
!	ADDRESS	- If the data item is static, the start address of its static
!		  address range is returned to ADDRESS.
!
!	LENGTH	- If the data item is static, the length in bytes of its static
!		  address range is returned to LENGTH.
!
!	STATIC_FLAG - If the data item is static, STATIC_FLAG is set to TRUE;
!		  otherwise STATIC_FLAG is set to FALSE.
!

    BEGIN

    MAP
	DSTPTR: REF DST$RECORD,		! Pointer to data item's DST record
	ADDRESS: REF VECTOR[1],		! Location where the static start
					!      address is returned
	LENGTH: REF VECTOR[1],		! Location where the length of the
					!      static area is returned
	STATIC_FLAG: REF VECTOR[1];	! Location where TRUE is returned if the
					!      data item is static--else FALSE

    BIND
	LENGTH_TBL = UPLIT BYTE(0, 1, 1,2,4,8, 1,2,4,8, 4,8,8,16,
				REP 11 OF (0), 16,16,8,16,16,32,
				12,8,8,0,0,0,0): VECTOR[,BYTE];
	%IF DSC$K_DTYPE_HIGHEST GTR 37	! If the LENGTH_TBL PLIT is too small,
	%THEN				!      generate a compile-time error
	    %ERROR('Error:  Must expand PLIT in Routine STATIC_CHECK')
	%FI;

    LOCAL
	BPTR1: REF DST$BLI_TRAILER1,	! Pointer to the Bliss special cases DST
					!      record first trailer
	BPTR2: REF DST$BLI_TRAILER2,	! Pointer to the Bliss special cases DST
					!      record second trailer
	DESCPTR: REF BLOCK[,BYTE];	! Pointer to VAX Standard Descriptor in
					!      the DST record



    ! If this is a BLISS special cases DST record, return its start address and
    ! length if the BLISS data item is static.
    !
    IF .DSTPTR[DST$B_TYPE] EQL DST$K_BLI
    THEN
	BEGIN
	STATIC_FLAG[0] = FALSE;
	IF .DSTPTR[DST$B_BLI_VFLAGS] NEQ DST$K_VALKIND_ADDR THEN RETURN;
	BPTR1 = DSTPTR[DST$A_BLI_TRLR1] + .DSTPTR[DST$B_BLI_LNG];
	ADDRESS[0] = .BPTR1[DST$L_BLI_VALUE];
	BPTR2 = BPTR1[DST$A_BLI_TRLR2] + .BPTR1[DST$B_BLI_NAME];
	LENGTH[0] = .BPTR2[DST$L_BLI_SIZE];
	IF .DSTPTR[DST$V_BLI_REF] THEN LENGTH[0] = 4;
	STATIC_FLAG[0] = TRUE;
	RETURN;
	END;


    ! If this is a boolean (as in PASCAL) and it is static, we mark it as static
    ! and return its address and a length of 1 byte.  We determine whether it is
    ! static by checking the Value-Flags field.
    !
    IF (.DSTPTR[DST$B_TYPE] EQL DST$K_BOOL) AND
       (.DSTPTR[DST$B_VFLAGS] EQL DST$K_VALKIND_ADDR)
    THEN
	BEGIN
	ADDRESS[0] = .DSTPTR[DST$L_VALUE];
	LENGTH[0] = 1;
	STATIC_FLAG[0] = TRUE;
	RETURN;
	END;


    ! If the data type of this item is specified by the DST$K_SEPTYP record and
    ! it is static, then we mark it as static and return its address.  However,
    ! we do not know its length (at least not readily), so we return a length of
    ! zero.  In effect, we treat the object as a label.
    !
    IF (.DSTPTR[DST$B_TYPE] EQL DST$K_SEPTYP) AND
       (.DSTPTR[DST$B_VFLAGS] EQL DST$K_VALKIND_ADDR)
    THEN
	BEGIN
	ADDRESS[0] = .DSTPTR[DST$L_VALUE];
	LENGTH[0] = 0;
	STATIC_FLAG[0] = TRUE;
	RETURN;
	END;


    ! If the DST record is anything other than a VAX Standard Data Type at this
    ! point, just return with STATIC_FLAG set to FALSE.
    !
    IF (.DSTPTR[DST$B_TYPE] LSS DSC$K_DTYPE_LOWEST) OR
       (.DSTPTR[DST$B_TYPE] GTR DSC$K_DTYPE_HIGHEST)
    THEN
	BEGIN
	STATIC_FLAG[0] = FALSE;
	RETURN;
	END;


    ! We have a VAX Standard data item.  If this is a static scalar, pick up its
    ! start address and length and return with STATIC_FLAG set to TRUE.
    !
    IF .DSTPTR[DST$B_VFLAGS] EQL DST$K_VALKIND_ADDR
    THEN
	BEGIN
	ADDRESS[0] = .DSTPTR[DST$L_VALUE];
	LENGTH[0] = .LENGTH_TBL[.DSTPTR[DST$B_TYPE]];
	STATIC_FLAG[0] = TRUE;
	RETURN;
	END;


    ! If this data item DST record contains a VAX Standard Descriptor, we can
    ! assume it to be static and we pick up its address and length from the
    ! embedded descriptor.
    !
    IF .DSTPTR[DST$B_VFLAGS] EQL DST$K_VFLAGS_DSC
    THEN
	BEGIN


	! Get the start address and data item length from the descriptor.
	!
	DESCPTR = DSTPTR[DST$A_DSC_BASE] + .DSTPTR[DST$L_DSC_OFFS];
	ADDRESS[0] = .DESCPTR[DSC$A_POINTER];
	IF .DESCPTR[DSC$B_CLASS] EQL DSC$K_CLASS_S
	THEN
	    LENGTH[0] = .DESCPTR[DSC$W_LENGTH]

	ELSE IF .DESCPTR[DSC$B_CLASS] EQL DSC$K_CLASS_A
	THEN
	    LENGTH[0] = .DESCPTR[DSC$L_ARSIZE]

	ELSE
	    LENGTH[0] = 0;


	! Convert the length from bits or nibbles to bytes for special cases.
	!
	IF .DESCPTR[DSC$B_DTYPE] EQL DSC$K_DTYPE_V
	THEN
	    LENGTH[0] = (.LENGTH[0] + 7)/8

	ELSE IF .DESCPTR[DSC$B_DTYPE] EQL DSC$K_DTYPE_P
	THEN
	    LENGTH[0] = .LENGTH[0]/2 + 1;


	! Set the static flag to TRUE and return.
	!
	STATIC_FLAG[0] = TRUE;
	RETURN;
	END;


    ! If we have come here, the data item is not static.  Return saying so.
    !
    STATIC_FLAG[0] = FALSE;
    RETURN;

    END;

ROUTINE TEST_DST_SIZE(FILENAME, IMG_DST_BLOCK) =
!
! FUNCTION
!	This routine is used only if this is a Testable Debugger.  It scans the
!	Debug Symbol Table (DST) to find where the User Program DST ends.  This
!	is done to exclude the Debugger's own DST from the DST mapped into the
!	virtual address space.  The routine thus scans the DST (using RMS I/O so
!	that no virtual address space is used up) looking for the Module-Begin
!	record for DBGSTART.  If this record is found, that location is returned
!	as the DST end location; otherwise the actual end of the DST is returned
!	as the end location.
!
! INPUTS
!	FILENAME - The address of a Counted ASCII string containing the file-
!		  name of the executable image file.
!
!	IMG_DST_BLOCK - A pointer to the image header DST/GST descriptor.  This
!		  is assumed to already be in memory.
!
! OUTPUTS
!	The number of bytes in the DST before the end of the DST or before the
!		  Module-Begin record for DBGSTART is returned as the value.
!

    BEGIN

    MAP
	FILENAME: REF VECTOR[,BYTE],	! Pointer to the executable image file-
					!      name in Counted ASCII
	IMG_DST_BLOCK: REF IHS$ENTRY;	! Pointer to the image header symbol
					!      table descriptor

    LITERAL
	BLKCOUNT = 10,			! Number of file blocks/buffer "block"
	BUFSIZE  = (BLKCOUNT + 1)*512;	! Size of the DST record buffer

    OWN
	DSTFAB: $FAB(FAC=<BIO,GET>),	! DST File Access Block (FAB)
	DSTRAB: $RAB(ROP=BIO);		! DST Record Access Block (RAB)

    LOCAL
	BLKNUM,				! Block number within the image file--a
					!      "block" is BLKCOUNT*512 bytes
	BYTNUM,				! Byte number within current "block"
	CURBLK,				! Number of current "block" in XBUFFER
	DSTADDR,			! Current byte address in the DST rela-
					!      tive to the start of the DST
	DSTENDADDR,			! Byte address of the end of the DST
	DSTPTR: REF DST$RECORD,		! Pointer to the current DST record
	STATUS,				! Status code returned by RMS
	XBUFFER: VECTOR[BUFSIZE,BYTE];	! DST file buffer



    ! Set up the FAB and the RAB for doing Block I/O to read the executable
    ! image file.  Then open and connect the executable image file.
    !
    DSTFAB[FAB$L_FNA] = FILENAME[1];
    DSTFAB[FAB$B_FNS] = .FILENAME[0];
    DSTRAB[RAB$L_FAB] = DSTFAB;
    DSTRAB[RAB$L_UBF] = XBUFFER;
    STATUS = $OPEN(FAB=DSTFAB);
    IF NOT .STATUS THEN SIGNAL(.STATUS);
    STATUS = $CONNECT(RAB=DSTRAB);
    IF NOT .STATUS THEN SIGNAL(.STATUS);


    ! Now loop over the whole Debug Symbol Table (DST) to find where the user
    ! program DST ends.  This is either at the true end of the DST or at the
    ! start of the Module-Begin DST record for DBGSTART.
    !
    CURBLK = -1;
    DSTADDR = 0;
    DSTENDADDR = 512*.IMG_DST_BLOCK[IHS$W_DSTBLKS] - 1;
    WHILE TRUE DO
	BEGIN


	! Find the "block" number and the byte offset within the block repre-
	! sented by the current DST address.  If that "block" of the file is
	! not now in the buffer, read it into the buffer.
	!
	BLKNUM = .DSTADDR/(BLKCOUNT*512);
	BYTNUM = .DSTADDR MOD (BLKCOUNT*512);
	IF .BLKNUM NEQ .CURBLK
	THEN
	    BEGIN
	    DSTRAB[RAB$L_BKT] = .BLKNUM*BLKCOUNT + .IMG_DST_BLOCK[IHS$L_DSTVBN];
	    DSTRAB[RAB$W_USZ] = MIN(BUFSIZE,
				.DSTENDADDR + 1 - .BLKNUM*BLKCOUNT*512);
	    STATUS = $READ(RAB=DSTRAB);
	    IF NOT .STATUS THEN SIGNAL(.STATUS);
	    CURBLK = .BLKNUM;
	    END;

	DSTPTR = XBUFFER[.BYTNUM];


	! Determine whether we have reached the end of the DST.  If we have,
	! return the current DST size in bytes to the caller.
	!
	IF (.DSTADDR GEQU .DSTENDADDR)   OR
	   (.DSTPTR[DST$B_LENGTH] EQL 0) OR
	   (.DSTPTR[DST$B_TYPE] EQL DST$K_MODBEG AND
	    CH$EQL(9, UPLIT BYTE(%ASCIC 'DBGSTART'),
		.DSTPTR[DST$B_MODBEG_NAME] + 1, DSTPTR[DST$B_MODBEG_NAME], 0))
	THEN
	    RETURN .DSTADDR;


	! We are not yet at the end of the DST.  Go to the next record and loop.
	!
	DSTADDR = .DSTADDR + 1 + .DSTPTR[DST$B_LENGTH];
	END;


    ! We should never get here.
    !
    RETURN 0;

    END;

END ELUDOM
