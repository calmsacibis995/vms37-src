MODULE DBGADDINT( IDENT = 'V03-000') =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	DEBUGGER
!	
! ABSTRACT:
!	This module implements the Address Expression Interpreter for
!	the VAX DEBUGGER. That is, it evaluates all valid address
!	expressions. The procedure which controls this evaluation
!	is dbg$naddr_exp_int.
!
!
! ENVIRONMENT:
!
! AUTHOR:	Alyson L. Abramowitz	, CREATION DATE: 02-June-80
!
! MODIFIED BY:
!
! VERSION
! 02	-  Alyson L. Abramowitz Dec 10, 1980 --
!	  
!	   Fixed sanity check in the routine get_char_or_end_of_line
!	   to update character count before it checks for something
!	   after carriage return.
!
! 03	-  John Francis	11-Jun-1981
!
!	   Check that "^" is not followed by a Radix-Selection digit
!
! 04    -  Ping Sager 6-Nov-1981
!
!          Prevent debug goes into infinite loop by doing dep ^x30 in
!          EVALUATE_PRECEDENCE
!
!--

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    DBG$NADDR_EXP_INT,			! Interpretes Address Expressions
    					! for the new debugger

    CREATE_ADDEXP_DESC,			! Creates an Address Expression
    					! Descriptor

    PUSH_OPERAND,			! Pushes an operand onto the Address
    					! Expression Interpreter's Operand
    					! Stack

    OPERATOR_PUSH,			! Pushes an operator onto the Address
    					! Expression Interpreter's Operator
    					! Stack

    OPERAND_POP,			! Pops an operator from the Address
    					! Expression Interpreter's Operand
    					! Stack

    OPERATOR_POP,			! Pops an operator from the Address
    					! Expression Interpreter's Operator
    					! Stack

    EVALUATE_PRECEDENCE,		! Evaluates the precedence of operators
    					! and does the appropriate actions to 
    					! the stack given the operator

    PARSE_AND_ANALYZE,			! Parses the next character in the 
    					! command line and determines if it
    					! it is a valid operator.

    DBG$NGET_TYPE_AND_VALUE,		! Converts an operand of any type
    					! to a value that the Address 
    					! Expression Interpreter can 
    					! understand.

    SET_UP_FOR_ADDRESS_ARITHMETIC,	! Sets up the Operator and Operand
    					! stacks to operate on two operands
    					! and an operator and gets the type 
    					! and value for each operand.

    THE_CURRENT_TYPE,			! Determines the type of the
    					! Address Expression being computed.

    UPDATE_PREV_OPER,			! Determines what the current
    					! previous operator actually is.
    
    GET_A_VALUE,			! Given a value descriptor interfaces
    					! with the language dependent type
    					! converter to get a value for it.

    CONVERT_TO_ADDEXP_DESC,		! Converts the information determined
    					! by the Address Expression Interpreter
    					! for its own internal format to the
    					! proper format for communication
    					! with the Command Line Interpreter.

    LOOK_AHEAD,				! Does look ahead of the command line
    					! given to the Address Expression 
    					! Interpreter to find what '.' actually
    					! means in the DEBUGGER.

    GET_CHAR_OR_END_OF_LINE,		! Determines if there are any more
    					! items to parse or if end of line
    					! has been encountered. 

    EVALUATE_INDIRECTION,		! Executes appropriate code to do
    					! indirection in the Address Expression
    					! Interpreter.

    UPDATE_STACK_VALUES: NOVALUE,	! Updates various flags for parsing
    					! Address Expressions

    EVALUATE_UNARY_ARITHMETIC,		! Evaluates the unary minus operator

    SET_UP_FOR_UNARY_ARITHMETIC,	! Sets up the Operand and Operator
    					! Stacks to deal with unary address
    					! arithmetic 

    EVALUATE_PSEUDO_SYMBOL,		! Interfaces with the Pseudo-symbol
    					! Interpreter to evaluate Pseudo-
    					! Symbols and then places them on
    					! the Address Expression Interpreter's
    					! Stack.

    DO_SIMPLE_BINARY_ARITHMETIC,	! Given two operands and an operator,
    					! this routine does simple arithmetic.

    RECOVER_DOT,			! Recovers the current location
    					! if we have to give a warning
    					! return to the CLI.

    ARE_STACKS_OK;			! Makes sure that no extra operator
    					! or operand is on the stack which
    					! cannot be recovered due to user 
    					! error.





!
! INCLUDE FILES:
!
    
    REQUIRE	'SRC$:DBGPROLOG.REQ';
    REQUIRE	'SRC$:SYSSER.REQ';
    

!
! FIELD DECLARATIONS
!

    FIELD 
    	  AE_OPERAND_STACK_DESC_FIELDS=
    		SET

    		B_OPERAND_DESC_TYPE = 		[0, 0, 8, 0],
    		B_OPERAND_DESC_OVERRIDE_TYPE =	[1, 0, 8, 0],
    		L_PTR_DESC_OR_VALUE =		[2, 0, 32, 0],
    		L_NEXT_PTR =			[3, 0, 32, 0]

    		TES;

    FIELD  
    	  AE_OPERATOR_STACK_DESC_FIELDS=
    		SET

    		L_OPERATOR =			[0, 0, 32, 0],
    		L_PTR_TO_NXT_OPERATOR =		[1, 0, 32, 0]

    		TES;

!
! LITERALS
!

    LITERAL
            AE_OPERAND_STACK_DESC_SIZE = 4,
    	    AE_OPERATOR_STACK_DESC_SIZE = 2,
    	    NIL = 0,
  	    AED$_INDIRECTION = 0,
    	    AED$_CURRENT_LOC = 1,
    	    AED$_ILLEGAL_ANSWER = 3,
  
    	    TEST = 0;

    		
!
! MACROS:
!

    MACRO	
    	  AE_OPERAND_STACK_DESC = 
    		BLOCK[ AE_OPERAND_STACK_DESC_SIZE] FIELD( AE_OPERAND_STACK_DESC_FIELDS) %,

    	  AE_OPERATOR_STACK_DESC =
    		BLOCK[ AE_OPERATOR_STACK_DESC_SIZE] FIELD( AE_OPERATOR_STACK_DESC_FIELDS) %;

!
! EQUATED SYMBOLS:
!

!
! OWN STORAGE:
!

!
! EXTERNAL REFERENCES:
!

EXTERNAL ROUTINE
    		 DBG$NPRIM_INT,			! Primary Interpreter

    		 DBG$NMAKE_ARG_VECT,		! Makes a VAX Standard
    						! Message Argument Vector

    		 DBG$NOUT_INFO,			! Outputs an informational
    						! error message

    		 DBG$NLIST_FREEZ,		! Does dynamic allocation

    		 DBG$NGET_TYPE,			! Gets the type of a
    						! Primary Descriptor

    		 DBG$NGET_LVAL,			! Gets the L-value of
    						! a Primary Descriptor

    		 DBG$NGET_RVAL,			! Gets the R-value of
    						! a Primary Descriptor

    		 DBG$NPSEUDO_SYM_INT,		! The Pseudo-Symbol
  						! Interpreter.

    		 DBG$NTYPE_CONV,		! Converts from Value 
    						! Descriptors to VAX
    						! Standard Scalar Descriptors.

    		 DBG$READ_ACCESS,		! Determines if read access
    						! is allowable for a specific
    						! number of bytes.

    		 DBG$NCHKOVER_SUB;		! Subtracts two integers and
    						! determines if there has
    						! been an overflow in 
    						! subtracting




GLOBAL ROUTINE DBG$NADDR_EXP_INT(input_desc, add_exp_descrptr,
 					  override_type, override_length,
    					  radix, error_msg_vector) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Parses all valid Address Expressions which occur in commands
!	typed in by the user. Address Expressions are defined to
!	be constructs in which address arithmetic might possibly
!	be done in a language without that capability or in which 
!	address arithmetic is illegal on the left hand side of an
!	assignment statement.
!
!	This routine calls other routines to parse all symbols
!	with the exception of the special DEBUGGER symbols:
!		
!		+   -   (   )   *   .
!
!	which may be parsed by this routine. The exception to this
!	rule is the Primary Interpreter for each language which
!	has the first opportunity to parse every command
!	that the Address Expression Interpreter knows about.
!
! FORMAL PARAMETERS:
!
!	input_desc	 -	The address of a VAX Standard String
!			  	Descriptor which describes the input
!			  	string.
!
!	add_exp_descrptr -	The address of an Address Expression
!				Descriptor. 
!
!	override_type	 -	The address of a longword to contain the
!				override type used in evaluating the
!				previous address that the user saw. Standard 
!				Argument Data Types as described 
!				in Appendix C of the VAX/11 
!				Architecture Handbook will be used,
!				however only the following subset of
!				those Data Types will be understood:
!
!					DSC$K_DTYPE_BU  ( 2)- Byte logical
!					DSC$K_DTYPE_LU  ( 3)- Word logical
!					DSC$K_DTYPE_LU  ( 4)- Longword logical
!					DSC$K_DTYPE_B	( 6)- Byte integer
!					DSC$K_DTYPE_W	( 7)- Word integer
!					DSC$K_DTYPE_L	( 8)- Longword integer
!					DSC$K_DTYPE_T	(14)- ASCII text
!					DSC$K_DTYPE_ZI  (22)- Instruction
!					DBG$K_NOTYPE	    - No type, the 
!						              default
!
!	override_length  -	In the case of a counted length override_type
!				(i.e., DSC$K_DTYPE_ZI) the length associated
!				with the override type
!
!	radix		 -	The radix to be used in interpreting this
!				Address Expression..
!
!	error_msg_vector -	A longword to contain the address of
!				a standard VAX Message Argument Vector
!				as described on page 4-119 of the
!				VAX/VMS system reference manual, 
!				volume 1A.
!
! IMPLICIT INPUTS:
!
!	None.
!
! IMPLICIT OUTPUTS:
!
!	o The Address Expression Descriptor has been filled in if
!	  Anything in the input line was parsed.
!
!	o One or more Primary Descriptors or
!	  Permanent Symbol Descriptors are created, if needed. If
!	  the <ADDRESS EXPRESSION> included address arithmetic 
!	  calculation to be done by the Address Expression Interpreter,
!	  the Primary Descriptors, Value Descriptors, and Permanent
!	  Symbol Descriptors are thrown away, otherwise, successful
!	  parsing results in a Primary Descriptor
!	  or Permanent Symbol Descriptor pointed to by the Address
!	  Expression Descriptor.
!
!	o The string descriptor describing the input string is updated
!	  to reflect the parsing that has been done by the Primary 
!	  Interpreter. The string descriptor's pointer to the input 
!	  string will now point to one character after the last
!	  character interpreted by the Address Expression Interpreter.
!	  If the whole input string was parsed, the pointer will have 
!	  a value of zero. The string descriptor's length field will
!	  have the current count of the input string which is 
!	  not currently parsed in it. 
!
!	o If a fatal error message was to be issued, the longword
!	  containing the address of the standard VAX Message Argument 
!	  Vector for that buffer is updated to contain the address of
!	  the error message buffer, otherwise it contains a zero.
!
! ROUTINE VALUE:
!
!	Unsigned integer longword completion code.
!
! COMPLETION CODES:
!
!	STS$K_WARNING (0) - The command string could not be parsed.
!			    This return is used for all bad returns
!			    that are not hopelessly fatal (for
!			    example, something is contained in the
!			    input string that both the Primary Interpreter
!			    and the Address Expression Interpreter
!			    could not parse).
!
!	STS$K_SUCCESS (1) - The command string was at least partially
!			    parsed and an Address Expression Descriptor
!			    has been built indicating type NO_INSTRUCTION
!			    and the value of the Address Expression.
!
!	STS$K_SEVERE (4)  - A fatal error occured. A longword
!			    containing the address of the standard
!			    VAX Messsage Argument Vector is filled 
!			    in to point to a fatal error message.
!			    This return is ONLY used in the case of
!			    an unrecoverable error (for example, an
!			    internal DEBUG error.
!
! SIDE EFFECTS:
!
!	NONE.
!
!--

    BEGIN
    	MAP
    		INPUT_DESC: REF BLOCK[,byte]; ! Set up input descriptor
    					! so pointers to parts of it work


    	LOCAL
       		HEAD_OPERATOR_STACK,		! Points to the head of the 
    						! operator stack

    		OPERAND_STACK_HEAD,		! Points to the head of the 
    						! operand stack

    		MSG_VEC,			! Temporary place for address 
    						! of error message

    		KIND_OF_RESULT,			! The type of result returned 
    						! by the Primary Interpreter 
    						! if it returned a result

    		PRIM_INTERP_RESULT,		! The descriptor or address 
    						! returned by the Primary 
    						! Interpreter if a result 
    						! was returned

    		ANSWER,				! Answer POPed off 
    						! operand stack

    		DESC,				! The descriptor passed
    						! back from the Primary
    						! Interpreter

    		PREV_OPER,			! The previous operator pushed
    						! on to the operator stack

    		WAS_IT_PARSED,			! Contains the resulting
    						! return from the Primary
    						! Interpreter

    		SHD_END,			! Determines if the Operator
    						! Stack is in the appropriate
    						! state to end parsing

    		HOW_END,			! Determines which kind of
    						! return this routine should
    						! have

    		RETURN_RESULT,			! A temporary place to put
    						! the kind of return this 
    						! routine should have

    		USER_TYPED: REF VECTOR[ ,BYTE], ! A way of accessing the
    						! characters that the user 
    						! typed

    		NEW_LINE: REF VECTOR[ , BYTE],

    		USER_INPUT: REF VECTOR[ ,BYTE],	! The input command accessable
    						! by the byte

    		IS_PREVIOUS_AN_OPERAND,		! States whether the previous
    						! thing parsed was either
    						! an operator or an operand

    		OPERATOR,			! The current operator being
    						! used by the AEI

    		PSEUD_SYM_RESULT,		! The result returned by the
    						! Pseudo_Symbol Interpreter

    		PSEUDO_SYMBOL,			! Determines if there was a
    						! Pseudo-Symbol.

    		LOOK_AHEAD_VALUE;		! The value of dot that was
    						! determined by looking ahead
    						! in the command line
    							
    	

    	! Initialization of variables
    	
    	! No stack currently exists

    	head_operator_stack = NIL;	
    	operand_stack_head = NIL;

    	! And a null previous and current operator

    	prev_oper = NIL;
    	operator = NIL;

    	! Initialize to expect an operand as the first thing the
    	! in the input command typed by the user

    	is_previous_an_operand = FALSE;

    	! The override type and length by default should be zero
    	! we may give them a better value later

    	.override_type = dbg$k_notype;
    	.override_length = 0;



    	! Start looking at the input descriptor
    
    	IF .input_desc[ dsc$w_length] LEQ 0
    	THEN 
    	     BEGIN
    		 	
    	         ! Can't have initial null string for input

    	         .error_msg_vector = dbg$nmake_arg_vect( dbg$_debugbug, 1, 
    						dbg$k_interr_blank_int);
    	         RETURN( sts$k_severe);  ! Bad return
    	     END;


    	DO 
    	    BEGIN

    		! Start without a pseudo-symbol each time thru the loop

    		pseudo_symbol = FALSE;

    		! And nothing to look ahead at since we havn't done any
    		! look ahead

    		look_ahead_value = aed$_illegal_answer;
    		
    	        ! Parse the string if possible

    	        was_it_parsed = dbg$nprim_int(.input_desc, kind_of_result, 
    				      prim_interp_result, .radix, 
    					.error_msg_vector);

    	        CASE .was_it_parsed 
    	            FROM sts$k_warning TO sts$k_severe OF
    		     SET

    		     [sts$k_success]:    			
    			
    			 BEGIN

    			     ! Everything parsed, we're through

			     IF push_operand( operand_stack_head, 
    			 	 	.kind_of_result, .override_type, 
    					.prim_interp_result, .error_msg_vector)
    			     THEN 
    			         BEGIN
    				     how_end = sts$k_success;
    				     shd_end = TRUE;
    				 END
    			     ELSE
    				 BEGIN
    				
    				     ! Stack not at end state-- it should be

    				     .error_msg_vector = dbg$nmake_arg_vect(
    					    dbg$_debugbug, 1,
    					    dbg$k_add_exp_parse_stack_prblm);
    				     RETURN (sts$k_severe);
    				 END;
    		       END;
    	  

    	           [sts$k_severe]:

    		       ! Disaster, recover as gracefully as possible

    		       RETURN (sts$k_severe);

    		   [sts$k_warning, sts$k_error]:

    	               BEGIN

    		           ! If it was an sts$k_error return, this had
    			   ! better be a left or right parenthesis,
    			   ! a plus, a dot, or a minus. We'll check this out
    			   ! when we parse the next item.

    			   IF .was_it_parsed EQL sts$k_error
    			   THEN 0

    			    !++          
    			    ! If it was an sts$k_warning error then we did
    			    ! successfully get an operand parsed by the
    			    ! Primary Interpreter. Now put that operand
       			    ! on the Operand Stack.
    			    !--

    			    ELSE 
    				BEGIN
			            ! The Primary Interpreter found an operand
    			            ! and something else. Put what was found
    			            ! on the Operand Stack and see what else
    			            ! there is.
    			            !--

   		                    is_previous_an_operand = TRUE;
    
                                    IF NOT push_operand( operand_stack_head, 
    				     		.kind_of_result, 
    						.override_type,
    					        .prim_interp_result, 
    						.error_msg_vector)
    			            THEN RETURN (sts$k_severe)

    				    ! If the operand was pushed on the stack
    				    ! then continue

       			            ELSE 0;
    			        END;

    			    ! IF we've gotten this far and had an sts$k_warning
    			    ! return, continue as if it were a sts$k_error
    			    ! return
    								

    		            CASE parse_and_analyze( prev_oper,
    					operator, .input_desc, 
    				        .operand_stack_head,
    					is_previous_an_operand, .was_it_parsed,
    					.error_msg_vector)

    			     FROM sts$k_warning TO sts$k_severe OF
    		                 SET
    				
    				 [sts$k_warning]:

    				     ! Couldn't parse the operand

    				     BEGIN

    					 ! If the last thing parsed
    					 ! was a dot, we evaluated
    					 ! it wrong, recover

    					 IF NOT .is_previous_an_operand
    					 THEN IF NOT recover_dot (
    						  head_operator_stack,
    						  operand_stack_head,
    						  operator, prev_oper,
    						  is_previous_an_operand,
    						  .override_type,
    						  .override_length,
    						  .error_msg_vector)
    					      THEN RETURN (sts$k_severe);


    					 ! IF we expected an operand than
    					 ! this is most definitely an error

    					 IF NOT .is_previous_an_operand
    					 THEN 
    					     BEGIN
    						 .error_msg_vector =
    							dbg$nmake_arg_vect(
    							    dbg$_nooprnd, 0);
    						 RETURN (sts$k_severe);
    					     END
    	
    					 ! Otherwise it may be recoverable
    					 ! from, let the CLI try to recover

    				         ELSE how_end = sts$k_warning;
    				         EXITLOOP;
    				     END;

    				 [sts$k_severe]:
    					     
    				     ! Disaster while parsing
    						 
    				     RETURN (sts$k_severe);

    				 [sts$k_success]:

    				     ! Got an operator, or a pseudosymbol,
    				     ! continue
    				
    				     BEGIN
    				
    					 ! If we got a dot it could be either
    					 ! a pseudo-symbol or an operator;
    					 ! lets's find out what it is.

    				         IF .operator EQL dbg$k_dot
    				         THEN
    				             BEGIN

    					         !++
    					         ! We've gotten a
    					         ! '.' of some sort.
    					         ! Find out whether
    					         ! it means last 
    					         ! location or to
    					         ! do an indirection.
    					         !--

    					         CASE look_ahead( .input_desc)
    					          FROM aed$_indirection TO
   						         aed$_illegal_answer
    						     	     OF

    					             SET

    				                     [aed$_indirection]:

    					                 BEGIN
  						             operator = 
    						 	      dbg$k_indirection;
    						             look_ahead_value =
    							      aed$_indirection;
    						         END;

    						     [aed$_current_loc]:
    						  
    						         BEGIN
    						             look_ahead_value =
    						 	       aed$_current_loc;
    						             operator =
    							       dbg$k_current_loc;
    						         END;

    						     [INRANGE, OUTRANGE]:

    						         ! This should never, 
    						         ! ever occur, 
    						         ! distaster struck

    						         signal(dbg$_debugbug, 
    						 	   1,
    						           dbg$k_illegal_return_value);
    					             TES;
    					     END
    					 ELSE 0;


    				
    					 ! If we have a pseudo-symbol then
    					 ! we want to deal with it basically
    					 ! as an operand--do so.

    				         IF ((.operator EQL dbg$k_predecessor)
    						 	OR
    				            (.look_ahead_value EQL
    							aed$_current_loc))
    				         THEN  
    					    IF NOT evaluate_pseudo_symbol(
    						      is_previous_an_operand, 
    						      .operator, 
    						      .override_type,
    						      .override_length,
    						      operand_stack_head,
    						      pseudo_symbol,
    						      .error_msg_vector)
    					    THEN RETURN (sts$k_severe)
    					    ELSE 0
    					 ELSE 0;

    			                 IF NOT .pseudo_symbol 
    			                 THEN 
    					     BEGIN
    						 IF get_char_or_end_of_line(
    							.input_desc, shd_end,
    							how_end)
    						 THEN 
    						     BEGIN

    							 ! If there is an
    							 ! end of line here
    							 ! and we just had
    							 ! an operator, then
    							 ! we expect an operand
    								
    							 IF NOT 
    							   .is_previous_an_operand
    							 THEN 
    							     BEGIN
    							         .error_msg_vector =
    							           dbg$nmake_arg_vect(
    								   dbg$_nooprnd,
    								   0);
    							         RETURN (sts$k_severe);
    							     END;
    						     END;

    						     IF NOT 
    							  evaluate_precedence( 
    							     .operator, 
    				                             prev_oper, 
    							     operand_stack_head, 
    				               		     head_operator_stack, 
    							     .error_msg_vector,
    							     shd_end)

    						     ! Couldn't parse the
    						     ! operator

    				              	     THEN RETURN (sts$k_severe)
    			        	      	     ELSE 0
    					         END
    					
    					 ! If not a pseudo-symbol then
    			                 ! check for end of line and if 
    					 ! not true then find the next 
    					 ! non-space character

    			                 ELSE IF get_char_or_end_of_line ( 
    						     .input_desc, shd_end, 
    						     how_end)
    			                      THEN EXITLOOP
    			                      ELSE 0;
    				     END;

    			         [INRANGE, OUTRANGE]:

    				     ! Illegal return value

    				     signal (dbg$_debugbug, 1, 
    					dbg$k_illegal_return_value);
    				 TES;

     		        END;    
    		   
    		   [INRANGE, OUTRANGE]:
    		       BEGIN
    			  .error_msg_vector = dbg$nmake_arg_vect( 
    						     dbg$_dbgerr, 0);
    			  RETURN ( sts$k_severe);
    		       END;
    	           TES;

    	       END

    	UNTIL ((.input_desc[dsc$w_length] EQL 0) OR (.shd_end EQL TRUE));


    	CASE .how_end
    	 FROM sts$k_warning TO sts$k_severe
    		OF
    	    SET

    	    [sts$k_warning, sts$k_error, sts$k_success]:

    	        BEGIN

    		    
    		    ! Evaluate the rest of the Address Expression

    		    operator = NIL;

	            IF evaluate_precedence( .operator, prev_oper,
    				operand_stack_head, head_operator_stack,
    				   .error_msg_vector, shd_end)
    		    THEN IF .shd_end EQL TRUE
    		         THEN return_result = .how_end
    		         ELSE
    	                     BEGIN 

    	                         ! Stack not at end state-- it
    			         ! should be
    					      
    		    	         .error_msg_vector = dbg$nmake_arg_vect
    					     (DBG$_DEBUGBUG, 1,
    			                      dbg$k_add_exp_parse_stack_prblm);
    		         	 RETURN( sts$k_severe);
    		             END

	            ! Problem in evaluating 
	            ! precedence

    		    ELSE RETURN( sts$k_severe);

                    ! Get the operand off the stack and return
    	            ! either successfully or with a warning
    	            ! as appropriate

	            IF operand_pop( operand_stack_head, kind_of_result, 
    				override_type, answer, .error_msg_vector)
    	            THEN 
 			IF convert_to_addexp_desc( .kind_of_result, 
    				.answer, .add_exp_descrptr, .error_msg_vector)
    			THEN IF are_stacks_ok ( head_operator_stack,
    					operand_stack_head, .error_msg_vector)
    			     THEN RETURN( .return_result)
    			     ELSE RETURN (sts$k_severe)

  		    	ELSE RETURN (sts$k_severe)


           	    ! couldn't pop the stack

    	            ELSE RETURN( sts$k_severe);

    	        END;

            [sts$k_severe]:

    		! Should never happen, but as a precausion

    		signal (dbg$_debugbug, 1, dbg$k_aed_confused);

    	    [inrange, outrange]:

    		! This shouldn't happen either

    		signal (dbg$_debugbug, 1, dbg$k_aed_confused);
    	    TES;


    	! We should have a length of zero for the command line
    	! and we should want to end.

        IF ((.input_desc[ dsc$w_length]) NEQ 0 OR (shd_end NEQ TRUE))
    	THEN signal( dbg$_debugbug, 1, dbg$k_aed_confused);
    	
    		

        RETURN( sts$k_success);
    END;





ROUTINE EVALUATE_PSEUDO_SYMBOL ( is_an_operand, operator, override_type,
    		override_length, operand_ptr, pseudo_symbol, error_message) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine finds the address representing a pseudo-symbol
!	and pushes the address on the operand stack. In the process,
!	this routine updates the flags determining whether an operand
!	or operator is expected and whether this is a pseudo-symbol.
!
! FORMAL PARAMETERS:
!
!	is_an_operand	-	A longword containing a flag which is true
!				if the next item to be parsed in an operand
!				and false if it is an operator.
!
!	override_type	-	A longword containing the current 
!				override_type.
!
!	override_length	-	A longword containing the current
!				override_length.
!
!	operand_ptr	-	A longword containing a pointer
!				to the head of the Operand Stack.
!
!	pseudo_symbol	-	A longword to contain a flag stating
!				that a Pseudo-Symbol has been parsed.
!
!	error_message	-	A longword to contain the address of a
!				Standard VAX Message Argument Vector as
!				described on page 4-119 of the VAX/VMS
!				System Reference Manual, Volume 1A.
!
! IMPLICIT INPUTS:
!
!	The Operand Stack for the Address Expression Interpreter.
!
! IMPLICIT OUTPUTS:
!
!	The Operand Stack has one more member added to it if the
!	Pseudo-symbol could be evaluated otherwise the longword
!	containing the address of the Standard VAX Message Argument
!	Vectior for that buffer is updated to contain the address of
!	the error message buffer.
!
! ROUTINE VALUE:
!
!	Unsigned integer longword completion code.
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS	(1)	-	The Pseudo-symbol was correctly
!					interpreted and pushed onto
!					the Operand Stack.
!
!	STS$K_SEVERE	(4)	-	The Pseudo-symbol could not be
!					correctly interpreted or pushed
!					onto the Operand Stack.
!
! SIDE EFFECTS:
!
!	None.
!
!__

    BEGIN

    	LOCAL
            kind_of_result,	! The type of descriptor returned by the
    				! Pseudo_symbol Interpreter.

    	    pseud_sym_result;	! The address of a longword to contain
    				! the address of a primary descriptor,
    				! a value descriptor, a permanent symbol
    				! descriptor, or a virtual address.

    	.is_an_operand = TRUE;
    	IF NOT dbg$npseudo_sym_int(.operator, kind_of_result, pseud_sym_result,
    			.override_type, .override_length, .error_message)
    	THEN RETURN (sts$k_severe)
    	ELSE IF NOT push_operand ( .operand_ptr, .kind_of_result, 
    			.override_type, .pseud_sym_result, .error_message)
    	     THEN RETURN (sts$k_severe)
    	     ELSE .pseudo_symbol = TRUE;
    	RETURN (sts$k_success);
    END;






ROUTINE CONVERT_TO_ADDEXP_DESC( kind_of_result, answer, add_exp_desc,
    			err_msg)=

!++
! FUNCTIONAL DESCRIPTION:
!
! Converts the information now known by the Address Expression Interpreter
! from its own internal format to the proper format for communication 
! with the CLI.
!
! FORMAL PARAMETERS:
!
!	kind_of_result	-	A longword containing the kind of result
!				that the Command Line Interpreter is to
!				be told about. This type may be changed
!				when converting from internal Address
!				Expression Interpreter format to external
!				format for communication with the Command
!				Line Interpreter.
!
!	answer		-	A longword containing either the address
!				of the descriptor passed back by the
!				Primary Interpreter as its interpretation
!				of an address or structure OR the actual
!				value representing an address. What this
!				parameter contains is determined by looking
!				at the kind_of_result that this parameter
!				actually is.
!
!	add_exp_desc	-	A longword to contain the address of the
!				Address Expression Descriptor which is
!				the fully converted and formatted format
!				with which the Address Expression Interpreter
!				communicates with the Command Line Interpreter.
!
!	err_msg		-	A longword to contain the address of a
!				Standard VAX Message Argument Vector as
!				described on page 4-119 of the VAX/VMS
!				System Reference Manual, Volume 1A.
!
! IMPLICIT INPUTS:
!
!	None.
!
! IMPLICIT OUTPUTS:
!
!	An Address Expression Descriptor is created if it was possible to
!	do so and its contents are filled in with the exception of the 
!	LANGUAGE field. Also, conversions are done when necessary to
!	change internal Address Expression Interpreter formats to external
!	formats readable by the Command Line Interpreter. This conversion
!	may involve changing the type and/or format of the descriptor 
!	about to be given back to the Command Line Interpereter.
!
! ROUTINE VALUE:
!
!	Unsigned integer longword completion code.
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS	-	An Address Expression Descriptor was created
!				and filled in. All conversions necessary were
!				successfully completed.
!
!	STS$K_SEVERE	-	A completed Address Expression Descriptor could
!				not be created or the conversions that were
!				necessary could not be completed. This is a
!				fatal error.
!
! SIDE EFFECTS:
!
!	The descriptor created by the Primary Interpreter to describe this
!	address expression may be destroyed and replaced with a 'descriptor'
!	which is in appropriate format for the Command Line Interpreter.
!
!--

    BEGIN
    	LOCAL
    	    converted_value;		! The value of a single member of an
    					! address expression which has been
    					! converted into a language independent
    					! Address Expression Interpreter
    					! understandable format.


    	CASE .kind_of_result
    	 FROM dbg$k_literal TO dbg$k_notype OF
    
    	    SET
    	    
    	    [dbg$k_literal]:
    		
    		! Convert type to no type

    		kind_of_result = dbg$k_notype;

    	    [dbg$k_primary_desc, dbg$k_perm_desc, dbg$k_notype,
    		dbg$k_instruction]:

    		! These are already in a format the Command Line Interpreter
    		! can understand. Do nothing.

    		0;

            [dbg$k_value_desc]:

    		! The Command Line Interpreter doesn't understand Value
    		! Descriptors. Convert them to a value.

    		IF get_a_value( .answer, converted_value, .err_msg)
    		THEN 
    		    BEGIN

    			! Get the newly converted value and assign it back
    			! to answer--where the old value previously resided

    			kind_of_result = dbg$k_notype;
    			answer = .converted_value;
    		    END

    		ELSE RETURN (sts$k_severe);

            [inrange, outrange]:

    		! Should never happen

    		signal (dbg$_debugbug, 1, dbg$k_invalid_type);

    	    TES;

        IF create_addexp_desc( .add_exp_desc, .kind_of_result, 
    		.answer, .err_msg)
    	THEN RETURN (sts$k_success)
        ELSE RETURN (sts$k_severe);
    END;



    





    	

ROUTINE CREATE_ADDEXP_DESC(add_exp_desc, type, value_or_ptr, error_msg)=

!++
! FUNCTIONAL DESCRIPTION:
!
!	Creates an Address Expression Descriptor.
!
! FORMAL PARAMETERS:
!
!	add_exp_desc	-	A longword to contain the address
!				of the Address Expression Descriptor.
!
!	type		-	The type of Address Expression Descriptor
!				this is to be. 
!				
!	value_or_ptr	-	The value to be contained in the Address
!				Expression Descriptor or the Address of
!				the Primary Descriptor to be contained in
!				the Address Expression Descriptor.
!
!	error_msg	-	A longword to contain the address of
!				a Standard VAX Message Argument Vector 
!				as described on page 4-119 of the 
!				VAX/VMS system reference manual, 
!				volume 1A.
!
! IMPLICIT INPUTS:
!
!	None.
!
! IMPLICIT OUTPUTS:
!
!	An Address Expression Descriptor is created if it was possible
!	to do so and its contents filled in with the exception of the
!	LANGUAGE field.
!
! ROUTINE VALUE:
!	
!	Unsigned integer longword completion code.
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS	-	An Address Expression Descriptor was
!				created and filled in.
!
!	STS$K_SEVERE	-	A completed Address Expression Descriptor
!				could not be created. This is a fatal
!				error.
!
! SIDE EFFECTS:
!
!	None.
!
!--

BEGIN
    
    LOCAL
    	desc:	REF DBG$AED;		! temporary place to allocate
    					! address of Address Expression
    					! Descriptor to.


    IF dbg$nlist_freez( dbg$k_aed_size, desc, .error_msg)
    	EQL sts$k_success
    THEN 
    	BEGIN
    	    desc[dbg$b_aed_type] = .type;
    	    desc[dbg$l_aed_value] = .value_or_ptr;
    	    .add_exp_desc = .desc;

    	    ! All went well, return successfully

    	    RETURN (sts$k_success); 
    	END

    ! Couldn't allocate space for the 
    ! descriptor, return unsuccessfully    				

    ELSE RETURN (sts$k_severe); 
END;





ROUTINE PUSH_OPERAND( stack_ptr, type_of_result, override_type,
    				result_to_add, msg_vec) =	


!++
! FUNCTIONAL DESCRIPTION:
!	Pushes an operand onto the Address Expression Interpreter's Operand
!	stack. Operands are defined as any valid address or literal
!	number.
!		
!
! FORMAL PARAMETERS:
!
!	stack_ptr	-	The pointer to the head of the 
!				Operand Stack.
!
!	type_of_result	-	The address of a longword to contain
!				the type of this operand. The types
!				may be one of the following:
!					
!					DBG$K_PRIMARY_DESC
!					DBG$K_PERM_DESC
!					DBG$K_INSTRUCTION
!					DBG$K_NOTYPE
!
!	override_type	-	The address of a longword to contain
!				the override type used in evaluating
!				the previous address that the user saw.
!				Standard Argument Data Types as 
!				described in Appendix C of the VAX/11
!				Architecture Handbook will be used, 
!				however only the following subset of 
!				those Data Types will be understood:
!
!					DSC$K_DTYPE_BU	( 2)- Byte logical
!					DSC$K_DTYPE_WU	( 3)- Word logical
!					DSC$K_DTYPE_LU	( 4)- Longword logical
!					DSC$K_DTYPE_T	(14)- ASCII text
!					DSC$K_DTYPE_ZI	(22)- Instruction
!
!	result_to_add	-	The address or value to push on to the
!				operand stack.
!
!	msg_vec		-	A longword to contain the address of
!				a standard VAX Message Argument Vector
!				as described on page 4-119 of the
!				VAX/VMS System Reference Manual, volume 1A.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	The Address Expression Interpreter Operand Stack has a new member
!	added to it if that was possible to do. The pointer to the head
!	of the stack has been updated to reflect this new member.
!
!	If the new member was not able to be added to the stack a fatal
!	message is created and the longword containing the address
!	of the Standard VAX Message Argument Vector for that buffer is 
!	updated to contain the address of the error message buffer, 
!	otherwise it contains a zero.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1)	- A new member was successfully added
!				  to the Operand Stack. 
!
!       STS$K_SEVERE  (4)	- A fatal error occured. The longword
!				  containing the address of the Standard
!				  VAX Message Argument Vector is filled
!				  in to point to a fatal error message.
!	
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    	MAP 
    	    STACK_PTR: 		REF AE_OPERAND_STACK_DESC;

    	LOCAL
    	      OPERAND_DESC: REF AE_OPERAND_STACK_DESC;  ! The operand 
    							! descriptor to
    							! be created


    	! Create an Address Expression Operand Stack Descriptor

    	IF dbg$nlist_freez( ae_operand_stack_desc_size, operand_desc, 
    			.msg_vec)
    		EQL sts$k_success
    	THEN 
    	    BEGIN

    		! Fill the operand descriptor


    		 operand_desc[ b_operand_desc_type] = .type_of_result;
    		 operand_desc[ b_operand_desc_override_type] = ..override_type;
    		 operand_desc[ l_ptr_desc_or_value] = .result_to_add;

    		! Now put it in the right place on the stack


    		! No previous members on the stack

    		IF ..stack_ptr EQL NIL
       		THEN operand_desc[ l_next_ptr] = 0

    		! Other members on the stack

    		ELSE operand_desc[ l_next_ptr] = ..stack_ptr; 		


    		! Update the stack pointer

    		.stack_ptr = .operand_desc;

    		! Quit while we're ahead

    		RETURN( sts$k_success);
     	    END

       ! couldn't get the space for the descriptor
	
       ELSE RETURN( sts$k_severe);
    END;
    






ROUTINE OPERAND_POP( stack_ptr, type_of_desc, override_type,
    			operand, msg_vec) =	


!++
! FUNCTIONAL DESCRIPTION:
!	Pops an operand off the Address Expression Interpreter's Operand
!	stack. Operands are defined as any valid address or literal
!	number.
!
! FORMAL PARAMETERS:
!
!	stack_ptr	-	The pointer to the head of the
!				Operand Stack.
!
!	type_of_desc	-	The address of a longword to contain the
!				type of this operand. The types may be one 
!				of the following:
!
!					DBG$K_PRIMARY_DESC
!					DBG$K_PERM_DESC
!					DBG$K_INSTRUCTION
!					DBG$K_NOTYPE
!					DBG$K_VALUE_DESC
!
!	override_type	-	The address of a longword to contain the
!				override type used in evaluating the
!				previous address that the user saw.
!				Standard Argument Data Types as described
!				in Appendix C of the VAX/11 Architecture 
!				Handbook will be used, however only the
!				following subset of those Data Types will
!				be understood:
!
!					DSC$K_DTYPE_BU	( 2)- Byte logical
!					DSC$K_DTYPE_WU	( 3)- Word logical
!					DSC$K_DTYPE_LU	( 4)- Longword logical
!					DSC$K_DTYPE_T	(14)- ASCII text
!					DSC$K_DTYPE_ZI	(22)- Instruction
!
!	msg_vec		-	A longword to contain the address of
!				a Standard VAX Message Argument Vector
!				as described on page 4-119 of the
!				VAX/VMS System Reference Manual, volume 1A.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	The Address Expression Interpreter Operand Stack has its "top" member
!	removed, if there was one. The pointer to the top of the stack is
!	updated to reflect this removal.
!
!	If there were no members of the stack to remove then an error message
!	is created and the longword containing the address of the Standard
!	VAX Message Argument Vector is updated to contain the address of the
!	error message buffer. The error message is a simple one stating
!	that an internal debug error occured. It is anticipated that
!	if the error was caused by something else, the calling routine
!	will provide its own error message. It is assumed that two operators
!	in a row will be caught by the Primary Interpreter and flaged as
!	an error so that this state should never happen.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1)	- The "top" member of the Operand Stack
!				  was removed.
!
!	STS$K_SEVERE  (4)	- A fatal error occured. The longword 
!				  containing the address of the Standard
!				  VAX Message Argument Vector is filled
!				  in to point to a fatal error message.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN
    
    	LOCAL
    	      TEMP_PTR: REF AE_OPERAND_STACK_DESC; ! A temporary pointer
    						! used to access the
    						! stack

    	! Check if there is a member to pop

    	IF ..stack_ptr EQL NIL
    	THEN 
    	    BEGIN
    		 .msg_vec = dbg$nmake_arg_vect(dbg$_debugbug, 1, 
    							dbg$k_end_stack);
    	    	 RETURN( sts$k_severe);
    	     END;

    	

    	! Stack has at least one member

    	temp_ptr = ..stack_ptr;
    	.type_of_desc = .temp_ptr[b_operand_desc_type];
    	.override_type = .temp_ptr[ b_operand_desc_override_type];
    	.operand = .temp_ptr[ l_ptr_desc_or_value];

    	! Update pointer to top of stack

    	IF .temp_ptr[ l_next_ptr] NEQ NIL 
    	THEN .stack_ptr = .temp_ptr[ l_next_ptr]
    	ELSE .stack_ptr = NIL;
    	RETURN( sts$k_success);
    END;


    		




ROUTINE OPERATOR_PUSH( head_ptr, operator, msg_vector)=

!++
! FUNCTIONAL DESCRIPTION:
!	Pushes an operator onto the Address Expression Interpreter's
!	Operator Stack. Operators are one of the following:
!
!		( + - * / ) . @
!
! FORMAL PARAMETERS:
!
!	head_ptr	-	The pointer to the head of the Operator stack.
!
!	operator	-	The operator to be pushed onto the stack.
!
!	msg_vector	-	A longword to contain the address of
!				a Standard VAX Message Argument Vector
!				as described on page 4-119 of the
!				VAX/VMS System Reference Manual, volume 1A.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	The Address Expression Interpreter Operator Stack has a new member
!	added to it if that was possible to do. The pointer to the head
!	of the stack has been updated to reflect this new member.
!
!	If the new member was not able to be added to the stack a fatal 
!	message is created and the longword containing the address of
!	the Standard VAX Message Argument Vector for that buffer is
!	updated to contain the address of the error message buffer,
!	otherwise it contains a zero.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS	 (1)	- A new member was successfully added
!				  to the Operator Stack.
!
!	STS$K_SEVERE	 (4)	- A fatal error occured. The longword
!				  containing the address of the Standard
!				  VAX Message Argument Vector is filled
!				  in to point to a fatal error message.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN
    	
    	MAP
    	    HEAD_PTR:		REF AE_OPERATOR_STACK_DESC;

    	LOCAL
    	      OPERATOR_DESC: REF AE_OPERATOR_STACK_DESC; ! The operator
    							 ! descriptor to
    							 ! be created


    	! Create an Address Expression Operator Stack Descriptor

    	IF dbg$nlist_freez( ae_operator_stack_desc_size, operator_desc,
    				.msg_vector)
    		EQL sts$k_success
    	THEN BEGIN

    		 ! Fill the operator descriptor

    		 operator_desc[ l_operator] = .operator;
    		

 
    		 ! Now put it in the right place on the stack

    		 
    		 ! No previous members on the stack

    		 IF ..head_ptr EQL nil
    		 THEN operator_desc[ l_ptr_to_nxt_operator] = 0

    		 ! Other members on the stack

    		 ELSE operator_desc[ l_ptr_to_nxt_operator] = ..head_ptr;

    		 
    		 ! Update the stack pointer

    		 .head_ptr = .operator_desc;

    		 ! Quit while we're ahead

    		 RETURN( sts$k_success);
    	     END

        ! Couldn't get the space for the descriptor

        ELSE RETURN (sts$k_severe);
    END;


    		

ROUTINE OPERATOR_POP( head_ptr, operator, msg_vector) =

!++
! FUNCTIONAL DESCRIPTION:
!	Pops an operator off the Address Expression Interpreter's Operator
!	stack. Operators are defined as one of the following:
!
!		( ) + * - /
!
!
! FORMAL PARAMETERS:
!
!	head_ptr	-	The pointer to the head of the Operator
!				Stack.
!
!	operator	-	The operator poped off the stack.
!
!	msg_vector	-	A longword to contain the address of a
!				Standard VAX Message Argument Vector
!				as described on page 4-119 of the
!				VAX/VMS System Reference Manual, volume 1A.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	The Address Expression Interpreter Operator Stack has its "top"
!	member removed, if there was one. The pointer to the top of the
!	stack is updated to reflect this removal.
!
!	If there were no members of the stack to remove then an error message
!	is created and the longword containing the address of the Standard
!	VAX Message Argument Vector is updated to contain the address of the
!	error message buffer. The error message is a simple one stating
!	that an operand was missing in the expression. It is the responsibility
!	of the caller to provide a better error message if he/she has more
!	information about the problem.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1)	- The "top" member of the Operator Stack
!				  was removed.
!
!	STS$K_SUCCESS (4)	- A fatal error occured. The longword 
!				  containing the address of the Standard
!				  VAX Message Argument Vector is filled
!				  in to point to a fatal error message.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN
    
    	LOCAL
    	      ACCESS_PTR: REF AE_OPERATOR_STACK_DESC;	! A temporary pointer
    						! used to access the stack


    	! Check if there is a member to pop

    	IF ..head_ptr EQL NIL
    	THEN BEGIN
    		 
    		 ! Stack is empty

    		 .msg_vector = dbg$nmake_arg_vect( dbg$_nooprnd, 0);
    		 RETURN( sts$k_severe);
    	     END;

    	! Stack has at least one member

    	access_ptr = ..head_ptr;
    	.operator = .access_ptr[ l_operator];
    	
    	IF .access_ptr[ l_ptr_to_nxt_operator] NEQ NIL
    	THEN .head_ptr = .access_ptr[ l_ptr_to_nxt_operator]
    	ELSE .head_ptr = NIL;
    	RETURN( sts$k_success);
    END;





ROUTINE EVALUATE_PRECEDENCE( operator, prev_oper, operand_ptr, operator_ptr,
    				msg_vec, shd_end) =

!++
! FUNCTIONAL DESCRIPTION:
!	Evaluates the precedence of operators and does the appropriate
!	actions to the stack given the previous operator and the current
!	operator. This routine ONLY works on operators. Operands are
!	simply pushed on the stack.
!
!	The following operands are valid:
!		
!		DOT
!		STAR
!		MINUS
!		PLUS
!		DIVIDE
!		LEFT_PARENTHESIS
!		RIGHT_PARENTHESIS
!		NIL -- (End of Statement)
!
! FORMAL PARAMETERS:
!
!	operator		- The operator which is currently being
!				  parsed.
!
!	prev_oper		- The previous operator which was parsed.
!
!	operand_ptr		- A longword containing the pointer to
!				  the head of the Operand Stack.
!
!	operator_ptr		- A longword containing the pointer to
!				  the head of the Operator Stack.
!
!	msg_vec			- A longword to contain the address of
!				  a Standard VAX Message Argument Vector
!				  as described on page 4-119 of the
!				  VAX/VMS System Reference Manual, Volume 1A.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	The operand and operator stacks are manipulated given the precedence
!	rules for the current operator. The prev_oper is then updated to
!	be the current operator.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1)	- The operand and operator stacks have been
!				  manipulated successfully given the current
!				  operand.
!
!	STS$K_SEVERE (4)	- The operand and operator stacks could not
!				  be successfully manipulated. The longword
!				  containing the address of the Standard
!				  VAX Message Argument Vector is filled in to
!				  point to a fatal error message.
!
! SIDE EFFECTS:
!
!	The Operator and Operand Stacks may have be altered to reflect the 
!	current operand.
!
!--

    BEGIN
    	LOCAL
    	      finished_operator,	! Determines when this operator
    					! has been fully acted upon

    	      temp_opr,			! Temporary place for new previous
    					! operator.

    	      operand_one,		! The first operand popped off
    					! the operand stack

    	      operand_two,		! The second operand popped off
    					! the operand stack

    	      result,			! The value found after doing
    					! address arithmetic

    	      override_type,		! The override type used in
    					! dealing with pseudo_symbols

    	      kind_of_operand_one,	! The kind of the first operand
    					! popped off the stack. This
    					! kind may be: dbg$k_primary_desc,
    					! dbg$k_perm_desc, dbg$k_instruction,
    					! dbg$k_literal or dbg$k_notype.
    
    	      kind_of_operand_two,	! The kind of the second operand
    					! popped off the stack. This
    					! kind may be: dbg$k_primary_desc,
    					! dbg$k_perm_desc, dbg$k_instruction,
    					! dbg$k_literal or dbg$k_notype.

    	      new_operator,		! The new operator to use in
    					! the current address arithmetic

    	      operand_one_value,	! The actual value in terms that
    					! the AEI can understand of the
    					! first operand
    					

    	      operand_two_value,	! The actual value, in terms that
    					! the AEI can understand, of the
    					! second operand

    	      prim_type_one,		! The converted type of the first 
    					! operand popped off the stack. 
    					! The kind may be either a type
   					! of instruction or a type of
    					! notype.

    	      prim_type_two,		! The converted type of the second
    					! operand popped off the stack.
    					! The kind may be either a type of
    					! instruction or a type of notype.

    	      operate_and_try_again,	! Flag that determines if one should
    				        ! evaluate the first to operands on
    					! the stack using the first operator
    					! on the stack and try again.

    	      the_type;			! The type of the new operand 
    					! computed using address arithmetic




    	operate_and_try_again = FALSE;
    	finished_operator = FALSE;

    	DO 
            BEGIN
    	        SELECTONE .operator OF 
    	            SET
    		
    		    [NIL]:
  		 	BEGIN
    			    SELECTONE ..prev_oper OF
    				SET

    			     	[NIL]:
    				    BEGIN

    				        .shd_end = TRUE;

    					finished_operator = TRUE;

%IF test
%THEN 
    $fao_tt_out('Got thru NIL operand and NIL operator');
%FI

    				    END;


    				[dbg$k_unary_minus]:

    				   BEGIN

    				       ! Change the value of the operand
    				       ! on the top of the stack to the
    				       ! opposite of what it is currently

    				       IF evaluate_unary_arithmetic( 
    						.operand_ptr, .operator_ptr,
    						.prim_type_one,	.msg_vec) 

    				       ! Update the flags and previous operator
     
    				       THEN  update_stack_values( 
    						    .shd_end, 
    						    .finished_operator, 
    						    .operator_ptr, .prev_oper)
    				       ELSE RETURN (sts$k_severe);
    				    END;



    				[dbg$k_indirection, dbg$k_at_sign]:

    				    BEGIN
    				        
    					! Go through various levels of 
    					! indirection till there are no more 
    					! to go

    					IF evaluate_indirection( 
    						.prim_type_one, .operand_ptr,
    						.operator_ptr, 
    						result, .msg_vec)

    					! Put the answer on top of the Operand
    					! Stack

    					THEN 
    					    BEGIN
    					
    						!++
    						! Since we've done address
    						! arithmetic of a sort,
    						! the type must be reset
    						! to be a literal address
    						!--
    					
    						the_type = dbg$k_literal;

    						IF push_operand( .operand_ptr, 
    						   .the_type, prim_type_one,
    						   .result, .msg_vec)

    					        ! And put the new operator on 
    					        ! the top of the operator stack

    					        THEN .prev_oper = 
    						          update_prev_oper(
    								.operator_ptr)
    					        ELSE RETURN (sts$k_severe)

    					   END

    					ELSE RETURN (sts$k_severe);

    					! Update the previous operator
    					! and try again

    					.shd_end = FALSE;
    				    END;
    					
    			    					
    				[dbg$k_left_parenthesis]:

    				    BEGIN

    					! Should never happen

    					.msg_vec = dbg$nmake_arg_vect(
    							dbg$_unmtchparn, 0);
    					RETURN (sts$k_severe);
    				    END;

    				[dbg$k_plus, dbg$k_minus, dbg$k_multiply,
    				   dbg$k_divide]:

    				        operate_and_try_again = TRUE;
    
    			   	[OTHERWISE]:
    				    BEGIN
    					
 				        ! Invalid previous operator

    					.msg_vec = dbg$nmake_arg_vect( dbg$_invopr,
    						 			  0);
    					RETURN(sts$k_severe);
    				    END
    				 TES;
    		         END;   			

    		


    		[dbg$k_unary_plus]:
    		    BEGIN
    			SELECTONE ..prev_oper OF
    			    SET

    			    [NIL, dbg$k_left_parenthesis, dbg$k_plus,
    				dbg$k_minus, dbg$k_multiply, dbg$k_divide,
    				   dbg$k_unary_minus]:
    				
    				BEGIN

    				    ! Unary pluses are irrelevant, throw
    				    ! the unary plus away and go parse
    				    ! the next item on the command line

    				    .shd_end = FALSE;
    				    finished_operator = TRUE;
    				END;

    			     [dbg$k_indirection, dbg$k_at_sign]:
    				
    				! This doesn't make sense, the previous
    				! operator must have been a plus, minus,
    			        ! times, divide, NIL, or left parenthesis
    			        ! for this operator to be a unary plus

    				signal (dbg$_debugbug, 1, 
    				    dbg$k_eval_prec_illegal_op);

    			     [OTHERWISE]:
    				
    				BEGIN

    				    ! Don't understand the previous operator.
    				    ! This should happen.

    				    .msg_vec = dbg$nmake_arg_vect( dbg$_invopr,
    							 0);
    				    RETURN (sts$k_severe);
    				END;
    			     TES;
    		    END;




    		[dbg$k_multiply, dbg$k_divide]:
    		    BEGIN
    			SELECTONE ..prev_oper OF
    			    SET

    			    [dbg$k_unary_minus]:
    				   BEGIN

    				       ! Change the value of the operand
    				       ! on the top of the stack to the
    				       ! opposite of what it is currently

    				       IF evaluate_unary_arithmetic( 
    						.operand_ptr, .operator_ptr,
    						.prim_type_one,	.msg_vec) 

    				       ! Update the flags and previous operator
     
    				       THEN  update_stack_values( 
    						    .shd_end, 
    						    .finished_operator, 
    						    .operator_ptr, .prev_oper)
    				       ELSE RETURN (sts$k_severe);
    				    END;



    			    [NIL, dbg$k_left_parenthesis, dbg$k_plus,
    				dbg$k_minus]:

    			        BEGIN

    			            ! Push the member on the stack

    				    IF NOT operator_push( .operator_ptr,
    						.operator, .msg_vec)
    				    THEN RETURN (sts$k_severe)
    				    ELSE .shd_end = FALSE;
    		
    				    ! We're through with the stacks till
    				    ! the next item is read

    				    finished_operator = TRUE;
    			        END;



    				[dbg$k_indirection, dbg$k_at_sign]:

    				    BEGIN
    				        
    					! Go through various levels of 
    					! indirection till there are no more 
    					! to go

    					IF evaluate_indirection( 
    						.prim_type_one, .operand_ptr,
    						.operator_ptr, 
    						result, .msg_vec)

    					! Put the answer on top of the Operand
    					! Stack

    					THEN 
    					    BEGIN

    						! We've done address arithmetic
    						! so it's a literal address

    						the_type = dbg$k_literal;

    						IF push_operand( .operand_ptr, 
    						   .the_type, prim_type_one,
    						   .result, .msg_vec)

    					        THEN .prev_oper =
    							   update_prev_oper(
    							 	 .operator_ptr)
    						ELSE RETURN (sts$k_severe)

    					    END

    				         ELSE RETURN (sts$k_severe);
    					.shd_end = FALSE;
    				    END;

    			    [dbg$k_multiply, dbg$k_divide]:

    				BEGIN
    				
    				    ! Get operands and operators off    
    				    ! stack and find the value of the operands

    				    IF set_up_for_address_arithmetic(
    						.operand_ptr, .operator_ptr,
    						kind_of_operand_one,
    						kind_of_operand_two,
    						new_operator, .msg_vec,
    						.operator, operand_one_value,
    						operand_two_value, 
    						prim_type_one, prim_type_two,
    						operand_one, operand_two)

    				    THEN 
    					BEGIN

    					    CASE ..prev_oper
    					     FROM dbg$k_multiply TO
    						dbg$k_divide OF

    					         SET

    						 [dbg$k_multiply, 
    							dbg$k_divide]:

    							IF NOT 
    							  do_simple_binary_arithmetic(
    							  ..prev_oper, 
    							  .operand_two_value, 
    							  .operand_one_value,
    							  result, .msg_vec)
    							THEN RETURN (sts$k_severe);
    						 
    						 [INRANGE, OUTRANGE]:

    						      ! This should never 
    						      ! happen

    						      signal ( dbg$_debugbug, 
    							1, 
    							dbg$k_eval_prec_illegal_op);

    						 TES;

    				             the_type = the_current_type ( 
    					 	          kind_of_operand_one,
    						          kind_of_operand_two,
    						          prim_type_one,
    						          prim_type_two);

    				             temp_opr = update_prev_oper(
    					 		    .operator_ptr);

    				             override_type = dbg$k_notype;

    				             ! Push both the operand and
    				             ! operator on the stack 

    				             IF push_operand( .operand_ptr, 
    						     .the_type,
    						     override_type, .result, 
    						     .msg_vec)
    				             THEN .prev_oper = .temp_opr
    				             ELSE RETURN (sts$k_severe);

    				             IF NOT operator_push (
    					                 .operator_ptr,
    						         .operator, .msg_vec)
    				             THEN RETURN (sts$k_severe)

    					     ELSE 0;

    				             ! Not the end of the statement

    				             .shd_end = FALSE;

    				             ! Finished for this time around

    				             finished_operator = TRUE;
    			                 END
    				     ELSE RETURN (sts$k_severe)
    				 END;



    			    [OTHERWISE ]:

    				BEGIN

    				    ! Invalid previous operator

    				    .msg_vec = dbg$nmake_arg_vect( dbg$_invopr,
    							0);
    				    RETURN( sts$k_severe);
    				END;


    			    TES;
    		    END;

    		[dbg$k_left_parenthesis, dbg$k_indirection, dbg$k_at_sign,
    			dbg$k_unary_minus]:

    		    BEGIN
    			SELECTONE ..prev_oper OF
    			    SET

    			    [NIL, dbg$k_left_parenthesis, dbg$k_plus,
    				dbg$k_plus, dbg$k_minus, dbg$k_multiply,
    				    dbg$k_divide, dbg$k_indirection, 
    					dbg$k_at_sign, dbg$k_unary_minus]:

    			        BEGIN

    				    ! All valid cases of left parenthesis
    				    ! are pushed on the stack

    				    IF operator_push( .operator_ptr,
    						.operator, .msg_vec)
    				    THEN .shd_end = FALSE
    				    ELSE RETURN (sts$k_severe);

    				    ! Done with left parenthesis

    				    finished_operator = TRUE;
    				END;

    			    [OTHERWISE]:
    				BEGIN

    				    ! Don't understand the previous operator
    				    ! this shouldn't be happening.

    				    .msg_vec = dbg$nmake_arg_vect( dbg$_invopr,
    							0);

    				    RETURN (sts$k_severe);
    				END;
    			    TES;
    		    END;

    		[dbg$k_right_parenthesis]:
    		    BEGIN
    			SELECTONE ..prev_oper OF
    			    SET

    			    [NIL]:

    			        BEGIN
    			
    				    !++
    				    ! Got a right parenthesis with no 
    				    ! left parenthesis currently on the stack.
    				    ! The user typed something wrong.
    				    !--

    				    .msg_vec = dbg$nmake_arg_vect ( 
    							dbg$_rtparnfound, 0);
    				    RETURN (sts$k_severe);
    				END;


    				[dbg$k_unary_minus]:
    				   BEGIN

    				       ! Change the value of the operand
    				       ! on the top of the stack to the
    				       ! opposite of what it is currently

    				       IF evaluate_unary_arithmetic( 
    						.operand_ptr, .operator_ptr,
    						.prim_type_one,	.msg_vec) 

    				       ! Update the flags and previous operator
     
    				       THEN  update_stack_values( 
    						    .shd_end, 
    						    .finished_operator, 
    						    .operator_ptr, .prev_oper)
    				       ELSE RETURN (sts$k_severe);
    				    END;



    				[dbg$k_indirection, dbg$k_at_sign]:

    				    BEGIN
    				        
    					! Go through various levels of 
    					! indirection till there are no more 
    					! to go

    					IF evaluate_indirection( 
    						.prim_type_one, .operand_ptr,
    						.operator_ptr, 
    						result, .msg_vec)

    					! Put the answer on top of the Operand
    					! Stack

    					THEN 
    					    BEGIN

    						! Type is literal since we've
    						! done address arithmetic
    						
    						the_type = dbg$k_literal;

    						IF push_operand( .operand_ptr, 
    						      .the_type, prim_type_one,
    						       .result, .msg_vec)

    					        THEN .prev_oper = 
    							  update_prev_oper(
    								.operator_ptr)
    						ELSE RETURN (sts$k_severe)
    					    END

    					 ELSE RETURN (sts$k_severe);

    					.shd_end = FALSE;
    				    END;


    			   [dbg$k_plus, dbg$k_minus, dbg$k_multiply,
    				dbg$k_divide]:

    			       operate_and_try_again = TRUE;
	


    			   [dbg$k_left_parenthesis]:
    			       BEGIN
    				   IF operator_pop( .operator_ptr,
    					new_operator, .msg_vec)
    				   THEN
    				       BEGIN
    				           .prev_oper = update_prev_oper(
    							.operator_ptr);
    				           .shd_end = FALSE;
    					   finished_operator = TRUE;
    				       END

    				   ELSE RETURN (sts$k_severe);
    			       END;
    				    				
    		    				
                           [OTHERWISE]:
    			       BEGIN

    				   ! Should never happen
		
    				   .msg_vec = dbg$nmake_arg_vect(
    							dbg$_invopr, 0);
    				   RETURN (sts$k_severe);
    			       END;

    			   TES;
    		    END;
    				
    		
    		[dbg$k_plus, dbg$k_minus]:
    		    BEGIN
    			SELECTONE ..prev_oper OF
    			     SET
    		
    			     [NIL, dbg$k_left_parenthesis]:
    			         BEGIN

    			             ! Plus or minus sign as input, 
    				     ! put the operand on the stack
    
    				     IF NOT operator_push( .operator_ptr, 
    						.operator, .msg_vec)
    			             THEN RETURN (sts$k_severe)
    		
    			             ! Not the end of the statement

    			             ELSE .shd_end = FALSE;

    			            ! And we are through with the 
    				    ! stacks till the
    			            ! next thing is read

    		                    finished_operator = TRUE;
    				END;



    	                    [dbg$k_unary_minus]:

    				   BEGIN

    				       ! Change the value of the operand
    				       ! on the top of the stack to the
    				       ! opposite of what it is currently

    				       IF evaluate_unary_arithmetic( 
    						.operand_ptr, .operator_ptr,
    						.prim_type_one,	.msg_vec) 

    				       ! Update the flags and previous operator
     
    				       THEN  update_stack_values( 
    						    .shd_end, 
    						    .finished_operator, 
    						    .operator_ptr, .prev_oper)
    				       ELSE RETURN (sts$k_severe);
    				    END;



    				[dbg$k_indirection, dbg$k_at_sign]:

    				    BEGIN
    				        
    					! Go through various levels of 
    					! indirection till there are no more 
    					! to go

    					IF evaluate_indirection( 
    						prim_type_one, .operand_ptr,
    						.operator_ptr, 
    						result, .msg_vec)

    					! Put the answer on top of the Operand
    					! Stack

    					THEN 
    					    BEGIN

    						! Did address arithmetic
    						! so type is literal

    						the_type = dbg$k_literal;

    						IF push_operand( .operand_ptr, 
    						      .the_type, prim_type_one,
    						         .result, .msg_vec)

    						THEN .prev_oper =
    							  update_prev_oper(
    								.operator_ptr)
    						ELSE RETURN (sts$k_severe)
    					    END

    					 ELSE RETURN (sts$k_severe);

    					.shd_end = FALSE;
    				    END;


    			    [dbg$k_plus, dbg$k_minus, dbg$k_multiply,
    			      dbg$k_divide]:
    				BEGIN
    				    
    				    ! Get operands and operators off 
    				    ! stack and find the value of the
    				    ! operands

    				    IF set_up_for_address_arithmetic(
    						.operand_ptr, .operator_ptr,
    						kind_of_operand_one,
    					        kind_of_operand_two, 
    						new_operator, .msg_vec,
    						.operator, operand_one_value,
    						operand_two_value, 
    						prim_type_one, prim_type_two,
    						operand_one, operand_two)
    				    THEN 
    					BEGIN

    					    IF NOT do_simple_binary_arithmetic(
    							.new_operator, 
    							.operand_two_value,
    							.operand_one_value,
    							result, .msg_vec)
    					    THEN RETURN (sts$k_severe)
    					    ELSE the_type = the_current_type (
    							  kind_of_operand_one,
    							  kind_of_operand_two,
    							  prim_type_one,
    							  prim_type_two);

    					    temp_opr = update_prev_oper(
    								.operator_ptr);
    					

    					    ! There is no override type
    					    ! as we're not dealing with
    					    ! a pseudo_symbol

    					    override_type = dbg$k_notype;


    					    ! Push both the operand and
    					    ! operator on the stack if
    					    ! its a plus or minus prev_oper

    					    IF push_operand( .operand_ptr,
    						  .the_type, override_type,
    						   .result, .msg_vec)
    					    THEN 

    					        CASE .new_operator
    					         FROM dbg$k_multiply TO
    						         dbg$k_divide OF

    					        SET

    					        [dbg$k_multiply, dbg$k_divide]:


    					           ! If multiply or divide
    						   ! then try again with 
    						   ! a new previous operator
    						  
    						   0;

    					        [dbg$k_plus, dbg$k_minus]:

    						   ! Quit while we're ahead
    						   ! Push operator on the stack

    						   IF NOT operator_push(
    								.operator_ptr,
    								 .operator,
    								  .msg_vec)
    						   THEN RETURN (sts$k_severe)
    						   ELSE finished_operator 
    								= TRUE;




    					        [inrange, outrange]:

    						   ! This should never happen

    						   signal( dbg$_debugbug, 1,
    						     dbg$k_eval_prec_illegal_op);
    					        TES

    					   ELSE RETURN (sts$k_severe);
    					   .prev_oper = .temp_opr;
    				

    					   ! Not the end of the statement
    					
    					   .shd_end = FALSE;
    					

    				    END;
    					
    		     END;

    	   	[OTHERWISE]:
    	            BEGIN
    		    
    		        ! Invalid current operator

    		        .msg_vec = dbg$nmake_arg_vect( dbg$_invopr, 0);
    		        RETURN( sts$k_severe);
    		    END;

           	TES;
    	   END;

    	  [OTHERWISE]:


    	  ! Add this section to prevent DEP 1024 ^X30 goes into a loop.
    	  !
    	      BEGIN
    	      .MSG_VEC = DBG$NMAKE_ARG_VECT(DBG$_INVOPR, 0);
 	      RETURN(STS$K_SEVERE);
    	      END;

    	  TES;

          IF .operate_and_try_again 
    	  THEN 
    	      BEGIN

    		  ! This implements state four for prev_oper which
    		  ! is either dbg$k_plus, dbg$k_minus, dbg$k_multiply,
    		  ! or dbg$k_divide

    		  ! Get operands and operators off stack and find 
    		  ! the value for of the operands

    		  IF set_up_for_address_arithmetic( .operand_ptr,
    			.operator_ptr, kind_of_operand_one,
    			kind_of_operand_two, new_operator, .msg_vec,
    			..prev_oper, operand_one_value, operand_two_value,
    			prim_type_one, prim_type_two, operand_one, 
    			operand_two)
    		  THEN 
    		      BEGIN

    			  IF NOT do_simple_binary_arithmetic ( .new_operator,
    					.operand_two_value, .operand_one_value,
    					result, .msg_vec)
    			  THEN RETURN (sts$k_severe)
    			  ELSE the_type = the_current_type (
    						kind_of_operand_one,
    						kind_of_operand_two, 
    						prim_type_one,
    						prim_type_two);

    			  ! Only update the previous operator if all went well

    			  temp_opr = update_prev_oper( .operator_ptr);

    			  ! No type for the overrride type as it's not a
    			  ! pseudo_symbol

    			  override_type = dbg$k_notype;

    			  IF push_operand( .operand_ptr, .the_type, 
    				override_type, .result, .msg_vec)
    			  THEN .prev_oper = .temp_opr
    			  ELSE RETURN (sts$k_severe);
    			  .shd_end = FALSE;
    			  operate_and_try_again = FALSE;
    		      END
    		  ELSE RETURN (sts$k_severe);

    	      END;

    	END

      UNTIL (.finished_operator EQL TRUE);

      
      IF ((.operator NEQ dbg$k_right_parenthesis) 
    		AND
    	 (.operator NEQ dbg$k_unary_plus))
      THEN .prev_oper = .operator;

      RETURN( sts$k_success); 
    END;




ROUTINE DO_SIMPLE_BINARY_ARITHMETIC ( operator, operand_one, operand_two,
    				result, error_msg)=

!++
!
! FUCTIONAL DESCRIPTION:
!
!	This routine does simple binary arithmetic. That is, given two
!	operands and an operator, it performs addition, subtraction,
!	multiplication, or division as indicated by the operator.
!	If the operator is not one of those four an Internal DEBUG Error
!	is signaled. Arithmetic is done using extended multiplication and
!	addition to avoid integer overflows. Any overflow is truncated to
!	a longword and the user is warned of the truncation.
!
! FORMAL PARAMETERS:
!
!	operator	-	A longword to contain the operator to
!				use in performing binary arithmetic.
!
!	operand_one	-	A longword to contain the first operand
!				to use in performing binary arithmetic.
!
!	operand_two	-	A longword to contain the second operand
!				to use in performing binary arithmetic.
!
!	result		-	A longword to contain the result from
!				the binary arithmetic done.
!
!	error_msg	-	A longword to contain the address of
!				a Standard VAX Message Argument Vector
!				as described on page 4-119 of the
!				VAX/VMS System Reference Manual, Volume 1A.
!
! IMPLICIT INPUTS:
!
!	None.
!
! IMPLICIT OUTPUTS:
!
!	None.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code.
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS 	(1)	-	The result was successfully computed.
!
!	STS$K_SEVERE	(4)	-	Division by zero was attempted. The
!					error message vector was updated to
!					reflect the error message.
!
! SIDE EFFECTS:
!
!	None.
!
!--

    BEGIN

    	BUILTIN EMUL;

    	LOCAL
    		quad_operand_one: VECTOR[2],  ! A quadword to contain operand
    					      ! one

    		quad_operand_two: VECTOR[2],  ! A quadword to contain operand
    					      ! two

    		quad_result:  VECTOR[2];      ! A quadword to contain the
    					      ! result of operations on 
    					      ! quad_operand_one and
    					      ! quad_operand_two


    	CASE .operator
    	 FROM dbg$k_multiply TO dbg$k_divide OF

    	    SET

    	    [dbg$k_multiply, dbg$k_plus]:
    		
    		BEGIN
    		
    		    !++
    		    ! To avoid integer overflow we're doing a quadword
    		    ! multiply here and checking if the top half of the
    		    ! word was zero. If it wasn't then we need to truncate.
    		    ! For addition we are still doing a multiply, since
    		    ! there is no quadword add. However EMUL allows us
    		    ! to do a quadword add to the result of the quadword
    		    ! multiply. So we're multiplying the first operand by
    		    ! one and adding the second operand, thereby doing
    		    ! the quadword add we wanted to do in the first place
    		    !--

    		    quad_operand_one[0] = .operand_one;
    		    quad_operand_one[1] = 0;
    		    quad_operand_two[0] = .operand_two;
    		    quad_operand_two[1] = 0;
    		    quad_result[0] = 0;
    		    quad_result[1] = 0;

    		    IF .operator EQL dbg$k_multiply
    		    THEN EMUL ( quad_operand_one, quad_operand_two, %REF (0), 
    			  quad_result)
    		    ELSE EMUL ( %REF (1), quad_operand_one, quad_operand_two,
    			   quad_result);

    		    ! If there was overflow, give a number truncation error

    		    IF .quad_result[1] NEQ 0 
    		    THEN dbg$nout_info (dbg$_numtrunc);

    		    .result = .quad_result[0];
    		END;

    	    [dbg$k_divide]:
    		
    	        ! Check for potential division by zero

    	        IF .operand_two EQL 0 
    	        THEN
    	 	    BEGIN
    		        .error_msg = dbg$nmake_arg_vect( dbg$_divbyzero,
    						0);
    		        RETURN (sts$k_severe);
    		    END
    		ELSE .result = .operand_one / .operand_two;

    	    [dbg$k_minus]:

    		! To check for overflow in a minus operation, we
    		! must call a macro subroutine

    		IF NOT dbg$nchkover_sub( .operand_two, .operand_one, .result)
    		THEN dbg$nout_info (dbg$_numtrunc);


    	    [INRANGE, OUTRANGE]:

    		signal (dbg$_debugbug, 1, dbg$k_unsupported_operator);
    		
    	    TES;
    	
    	RETURN (sts$k_success);
    END;








ROUTINE EVALUATE_INDIRECTION( override_type, operand_ptr, operator_ptr,
    			value, err_messge)=

!++
! FUNCTIONAL DESCRIPTION:
!
!	Evaluates the indirection operator for the Address Expression
!	interpreter. Unlike most other AEI operators, indirection 
!	takes a non-trivial amount of code to evaluate. Since this
!	code could potentially be called any time the previous operator
!	was a dot (of the indirection type), it is combined into a routine.
!
!	Note that this routine assumes that the first and potentially
!	other operands on the stack are dots (of the indirection type).
!	This routine will pop the appropriate number of dots off the
!	operand stack and one operator (to operate on the dots with)
!	off the operator stack. It is the responsibility of the caller
!	of this routine to make sure that they want this to happen at
!	the moment this routine is called.
!
!
! FORMAL PARAMETERS:
!
!	override_type	-	A longword to contain the override_type
!				currently in use. If there was previously
!				an override type in use, then this parameter
!				should be passed in with the current override
!				type, otherwise it should be initialized to
!				dbg$k_notype before entering this routine.
!
!	operand_ptr	-	A longword containing a pointer to the head
!				of the operand stack.
!
!	operator_ptr	-	A longword containing a pointer to the head
!				of the operator stack.
!
!	value		-	A longword to contain the actual value of
!				the operand which had indirection performed
!				upon it.
!
!	err_messge	-	A longword to contain the address of a Standard
!				VAX Message Argument Vector as described on 
!				page 4-119 of the VAX/VMS System Reference
!				Manual, Volume 1A.
!
! IMPLICIT INPUTS:
!
!	None.
!
! IMPLICIT OUTPUTS:
!
!	The Address Expression Interpreter's Operand Stack has its top most
!	member removed. The AEI's Operator Stack has all members of its 
!	stack removed until a dot (of type indirection) is not on the top
!	of the stack or the stack is empty.
!
!	An evaluation of the indirections indicated on the top most member of
!	the Operand Stack is done, if it is possible to do so. If this
!	is not possible an error message is produced.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code.
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS  (1)	-	Indirection was successfully
!					completed.
!
!	STS$K_SEVERE   (4)	-	Something went wrong and indirection
!					could not be successfully completed.
!					An error message is created to detail
!					the error.
!
! SIDE EFFECTS:
!
!	None.
!
!--

    BEGIN
    	
    	LOCAL
    	    ACCESS_OPERATOR: 
    		    REF AE_OPERATOR_STACK_DESC,   ! Helps to access individual
    						  ! portions of the Operator
    						  ! Stack.

    	    TYPE_OF_DESC,			  ! The type of the descriptor
    						  ! stored on the Operand 
    						  ! Stack.

    	    INDIRECTION_LEVEL,			  ! The current amount of
    						  ! indirections that must
    						  ! performed to evaluate
    						  ! the operand being 
    						  ! evaluated.

    	    THE_OPERATOR,			  ! The current operator 
    						  ! just popped off the
    						  ! AEI's Operator Stack.

    	    LANG_DEPT_VALUE,			  ! The language dependent
    						  ! value popped off the
    						  ! operand stack.

    	    IS_ANSWER;				  ! A temporary place to
    						  ! compute indirections
    						  ! in



    	! Get an operand and its value

    	IF NOT operand_pop( .operand_ptr, type_of_desc, override_type, 
    		    lang_dept_value, .err_messge)
    	THEN RETURN (sts$k_severe)
    	ELSE IF NOT dbg$nget_type_and_value( lang_dept_value, type_of_desc, 
       				override_type, is_answer, .err_messge)
    	     THEN RETURN (sts$k_severe)
    	     ELSE 0;


    	! Initialize the indirection level to one since we assume in this
        ! routine that there is at least one level of indirection

        indirection_level = 1;


    	IF operator_pop( .operator_ptr, the_operator, .err_messge)

    	! We assumed that if we got to this routine that the top operator
    	! on the stack was a dot (of type indirection). If it's an incorrect
    	! assumption then there is an internal DEBUG error

    	THEN IF (.the_operator NEQ dbg$k_indirection
    			       AND
    		 .the_operator NEQ dbg$k_at_sign)
    	     THEN signal ( dbg$_debugbug, 1, dbg$k_confused_stack_operator)
    	     ELSE
    		 BEGIN
    		     WHILE TRUE DO

    		     ! Keep removing the top member of the operator stack
    		     ! while that operator is a dot (of type indirection)

    			 BEGIN

    			     ! Make sure there is something to access
    			     ! before we try and access it

    			     IF ..operator_ptr NEQ NIL
    			     THEN access_operator = .operator_ptr
    			     ELSE EXITLOOP;


    			     ! Something is actually on the stack, see
    			     ! it's a dot (of type indirection)

    			     IF (.access_operator[l_operator] 
    				EQL dbg$k_indirection
    					OR
    				 .access_operator[l_operator]
    				EQL dbg$k_at_sign)
    			     THEN IF operator_pop( .operator_ptr, the_operator,
    					.err_messge)
    				  THEN indirection_level = .indirection_level
    								+ 1
    				  ELSE RETURN (sts$k_severe)
    			     ELSE EXITLOOP;
    			 END
    		 END
    	ELSE RETURN (sts$k_severe);


    	! Check if each indirection level is read-accessable and if
    	! so do the indirection, if not, give the user an error message

        INCRU index FROM 1 TO .indirection_level BY 1 DO
    	    IF dbg$read_access( .is_answer, 4, .err_messge)
    	    THEN is_answer = ..is_answer
    	    ELSE RETURN (sts$k_severe);

    	.value = .is_answer;

        ! Successful indirection performed

    	RETURN (sts$k_success);
    END;






ROUTINE EVALUATE_UNARY_ARITHMETIC( operand_ptr, operator_ptr, override_type, 
    					error_ms_buf)=

!++
! FUNCTIONAL DESCRIPTION:
!
!	Evaluates the unary minus operator for the Address Expression 
!	Interpreter.
!
!	Note that this routine assumes that the first operator on the
!	Address Expression Interpreter's Operator Stack is a unary minus.
!	This routine will pop that unary minus off the stack and one
!	operand off the top of the Address Expression Interpreter's 
!	Operand Stack. When done, it will put the answer that it found
!	in evaluating the unary minus back on the top of the Operand
!	Stack.
!
!	It is the responsibility of the caller of this routine to make sure
!	that the stacks are in the correct position at the point this
!	routine is called.
!
! FORMAL PARAMETERS:
!	
!	operand_ptr	-	A longword containing a pointer to the head of
!				the Operand Stack.
!
!	operator_ptr	-	A longword containing a pointer to the head of
!				the Operator Stack.
!
!	override_type	-	A longword to contain the override type 
!				currently in use. If there was previously an 
!				override type in use, then this parameter
!				should be passed in with the current override
!				type, otherwise it should be initialized to
!				dbg$k_notype before entering this routine.
!
!	error_ms_buf	-	A longword to cotai the address of a Standard
!				VAX Message Argument Vector as described on 
!				page 4-119 of the VAX/VMS System Reference
!				Manual, Volume 1A.
!
! IMPLICIT INPUTS:
!
!	None.
!
! IMPLICIT OUTPUTS:
!
!	The Address Expression Interpreter's Operand Stack has its top most
!	member removed and replaced by a new member. The AEI's Operator
!	Stack has its top most member removed.
!
!	An evaluation of unary minus on the top most member of the Operand
!	Stack is done, if it is possible to do so. If this is not
!	possible an error message is produced.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code.
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS	(1)	-	Unary minus was successfully completed.
!
!	STS$K_SEVERE	(4)	-	Something went wrong and unary 
!					minus arithmetic could not be 
!					successfully completed. An error
!					message is created to detail the error.
!
! SIDE EFFECTS:
!
!	None.
!
!__

    BEGIN
    	
        LOCAL
    	    operand,		! The value used in evaluating unary
    				! minus

            operator,		! The operator popped off the top of the
    				! operator stack

            type;		! The type of the answer to be put back
    				! on top of the Operand Stack. This value
    				! is always dbg$k_no_type



    	! Get an operand and its value

    	IF NOT set_up_for_unary_arithmetic( .operand_ptr, .operator_ptr,
    			   .override_type, operator, operand, .error_ms_buf)
        THEN RETURN (sts$k_severe)
    	ELSE 

    	    ! If the top operator on the stack wasn't unary minus
    	    ! somthing is very wrong, quit while we are behind

    	    IF .operator NEQ dbg$k_unary_minus
    	    THEN signal (dbg$_debugbug, 1, dbg$k_eval_prec_illegal_op)

    	    ! Otherwise get the opposite of the value

    	    ELSE operand = .operand - (.operand * 2);

    	! We've done address arithmetic so the type is no type

    	type = dbg$k_notype;

    	! Put the answer back on the stack

	    IF NOT push_operand( .operand_ptr, .type, override_type, 
    			.operand, .error_ms_buf)
        THEN RETURN (sts$k_severe)


    	! And we're done

        ELSE RETURN (sts$k_success);
END;




ROUTINE SET_UP_FOR_UNARY_ARITHMETIC( operand_ptr, operator_ptr, override_type,
    		operator, operand, error_message)=

!++
! FUNCTIONAL DESCRIPTION:
!
!	Sets up the operator and operand stacks to operate on unary operators.
!	To accomplish this task, one operator and one operand is popped
!	off the top of the Operator Stack and the Operand Stack, respectively.
!	The value of the operand is then translated into a form that the
!	Address Expression Interpreter can understand.
!
! FORMAL PARAMETERS:
!
!	operand_ptr	-	A longword containing a pointer to the
!				head of the Operand Stack.
!
!	operator_ptr	-	A longword containing a pointer to the head
!				of the Operator Stack.
!
!	override_type	-	A longword to contain the override type
!				currently i use. If there was previously
!				an override type in use, then this parameter
!				should be passed i with the current override 
!				type, otherwise it should be intialized to 
!				dbg$k_notype before entering this routine.
!
!	operator	- 	A longword to contain the operator popped off
!				the Operator Stack. No attempt is made to
!				tell if this is a valid unary operator.
!
!	operand		-	A longword to contain the value popped 
!				off the Operand Stack converted into 
!				the form of a longword 
!				integer which the Address Expression 
!				Interpreter can understand.
!
!	error_message	-	A longword to contain the address of a
!				Standard VAX Message Argument Vector
!				as described on page 4-119 of the VAX/VMS
!				System Reference Manual, Volume 1A.
!
! IMPLICIT INPUTS:
!
!	None.
!
! IMPLICIT OUTPUTS:
!
!	The Address Expression Interpreter's Operand Stack and Operator
!	Stack each have their top member removed. 
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code.
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS	(1)	-	The top members of the Operand and
!					and Operator Stack have been removed
!					and the Operand has been converted
!					to a format that the Address Expression
!					Interpreter can understand.
!
!	STS$K_SEVERE	(4)	-	Something went wrong in popping the
!					respective stacks or converting the
!					operand popped to a format that the
!					Address Expression Interpreter can
!					understand. An error message is
!					created to detail the error.
!
! SIDE EFFECTS:
!
!	None.
!
!--
	
    BEGIN
    	
    	LOCAL
    	    desc_type,		! The type of the descriptor stored on the
    				! Operand Stack

    	    lang_dept_value;	! The language dependent value popped off the
    				! Operand Stack
    	
    	IF operator_pop( .operator_ptr, .operator, .error_message)
    	THEN IF operand_pop( .operand_ptr, desc_type, override_type,
    			lang_dept_value, .error_message)
    	     THEN IF dbg$nget_type_and_value( lang_dept_value, desc_type, 
    			    override_type, .operand, .error_message)
    	          THEN RETURN (sts$k_success)
    		  ELSE RETURN (sts$k_severe)

    	     ELSE RETURN (sts$k_severe)

        ELSE RETURN (sts$k_severe);
    END;







ROUTINE PARSE_AND_ANALYZE( previous_operator, operator, cmd_line, operand_ptr,
    				is_an_operand, was_it_parsed, error_msg)=

!++
! FUNCTIONAL DESCRIPTION:
!
!	Parses the next character in the command line and determines
!	if it is an valid operator. Dependent upon parsing rules,
!	actions are taken upon recognition of valid operators.
!
! 	Valid operators to be understood are currently:
!
!		+ ) \ - * / ( . <space> <carriage return>
!
! FORMAL PARAMETERS:
!
!	previous_operator -	A longword containing the previous 
!				operator used for evaluation
!				of the Address Expression typed by the
!				user. This parameter is NIL if no
!				previous operator existed.
!
!	operator	-	A longword to contain the operator 
!				parsed by this procedure.
!
!	cmd_line	-	The address of a VAX Standard String 
!				Descriptor which describes the input
!				string.
!
!	operand_ptr	-	A longword containing the address of the
!				head of the operand stack.
!
!	is_an_operand	-	The address of a longword which states
!				what the previous item parsed (by either
!				the Primary Interpreter or the Address
!				Expression Interpreter) was. If true,
!				then the previous item parsed was an 
!				operand, otherwise, it was an operator.
!				The default type is operand if no item
!				was previously parsed.
!
!	was_it_parsed	-	A longword containing the resulting value
!				of success/failure returned to the
!				Address Expression Interpreter from the
!				Primary Interpreter.
!
!	error_msg	-	A longword to contain the address of
!				a Standard VAX Message Argument Vector as
!				Described on page 4-119 of the
!				VAX/VMS System Reference Manual, volume
!				1A.
!
! IMPLICIT INPUTS:
!
!	None.
!
! IMPLICIT OUTPUTS:
!
!	None.
!
! ROUTINE VALUE:
!
!	Unsigned integer longword completion code.
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS	-	Parsed a valid operator.
!
!	STS$K_WARNING	-	Didn't understand the operator. This return
!				is used unless there is a real disaster.
!				Note that no error message is created in
!				the case of a sts$k_warning return.
!
!	STS$K_SEVERE	- 	Something happened that was illegal while
!				parsing the operator. The longword containing
!				the address of the Standard VAX Message
!				Argument Vectior is filled in to point to
!				a fatal error message.
!
! SIDE EFFECTS:
!
!	None.
!
!--

    BEGIN
        MAP 
    	    CMD_LINE:	REF BLOCK[,BYTE];	! Set up input descriptor
    						! so pointers to parts
    						! of it work

        LOCAL
    	    STOP_PARSING,			! Determines when to stop
    						! parsing

    	    LINE_TO_PARSE: REF VECTOR[ ,BYTE];	! Gives a structure the
    						! actual command line
    						! the user typed



    	! initialize stop_parsing to continue parsing indifinitely

        stop_parsing = false;	

    	IF .cmd_line[ dsc$w_length] LEQ 0 

	! If there is nothing in the user's command line, then
        ! something went wrong, we're here to parse it

    	THEN signal( dbg$_debugbug, 1, dbg$k_unexpected_end_cmd_line);

    	DO 
            BEGIN

    		! There is something there to parse, what is it?

    	        line_to_parse = .cmd_line[dsc$a_pointer];

%IF test
%THEN
    $fao_tt_out('The first letter of the command line is:');
    $fao_tt_out('line_to_parse[0]:   !AD',  1, line_to_parse[0]);
%FI


                CASE .line_to_parse[ 0]
    	         FROM dbg$k_car_return TO dbg$k_predecessor OF
    		  SET
    		 
    		  [dbg$k_blank, dbg$k_car_return]:
    		     				
    		     BEGIN
%IF test
%THEN
$fao_tt_out('Got a blank or carriage return');
%FI

    			
    			 ! ignore this carracter and set up to read 
    			 ! the next one

    			 cmd_line[dsc$a_pointer] = .cmd_line[ dsc$a_pointer] 
    				+ 1;
    			 cmd_line[ dsc$w_length] = .cmd_line[ dsc$w_length]
    				-1;
    		     END;

    	          [dbg$k_plus, dbg$k_minus, dbg$k_multiply, dbg$k_divide,
    			dbg$k_left_parenthesis, dbg$k_right_parenthesis,
    			     dbg$k_dot, dbg$k_at_sign, dbg$k_current_loc, 
    				dbg$k_uparrow]:

    		     BEGIN			

    			 ! found a valid operator--if we were expecting
    			 ! an appropriate operator then quit while we're ahead


  			 IF .was_it_parsed EQL sts$k_error
    			 THEN 
    			     CASE .line_to_parse[ 0]
    			      FROM dbg$k_left_parenthesis TO dbg$k_divide OF
    			         SET

    				 [dbg$k_multiply, dbg$k_divide]:

    				     !++
    				     ! If there were previous operands, then
    				     ! this can be a perfectly valid state,
    				     ! otherwise, this is wrong.
    				     !--

    				     IF .operand_ptr EQL NIL
    				     THEN 
    				         BEGIN
    					     .error_msg = dbg$nmake_arg_vect(
    							     dbg$_needoprnd, 
    							     2, 1, 
    							     line_to_parse[0]);
    					     RETURN (sts$k_severe);
    					 END
    				     ELSE 0;

    			        [INRANGE, OUTRANGE]:

    				    ! This is fine, don't worry about it

    				    0;
    				TES;
 
    			 .operator = .line_to_parse[0];
    			 stop_parsing = true;
    		     END;


    		  [INRANGE, OUTRANGE]:

    			 ! not a valid operator in the Address Expression
    			 ! Interpreter
BEGIN

%IF test
%THEN
    $fao_tt_out('No character matched');
%FI

       			 RETURN (sts$k_warning);
    END

		
    		 TES
             END

        UNTIL ((.cmd_line[ dsc$w_length] LEQ 0) OR (.stop_parsing EQL TRUE));
    	


    	IF .cmd_line[dsc$w_length] LEQ 0
    		
    	!++
    	! Unexpected end of command line. This should never happen.
    	! The Primary Interpreter has done something wrong. Stop
    	! before something worse happens.
    	!--

    	THEN signal( dbg$_debugbug, 1, dbg$k_unexpected_end_cmd_line);

    	IF NOT ..is_an_operand 
    	THEN
 	     CASE ..operator
    	      FROM dbg$k_left_parenthesis TO dbg$k_predecessor OF
                 SET

  		 [dbg$k_left_parenthesis, dbg$k_dot, dbg$k_at_sign]:
    				
    		     ! This is o.k., do nothing

    		     0;

    		  [dbg$k_uparrow]:

		     ! If this is just uparrow (not ^X, ^D, ^O or ^B),
    		     ! then this is really an operand meaning predecessor
    		     ! but for the moment think of predecessor as an operator

		     BEGIN
		     IF .cmd_line[dsc$w_length] GTR 1
		     THEN
			 SELECTONE .line_to_parse[1] OF
			 SET
			 ['X','D','O','B'] :
			     RETURN sts$k_warning;
			 TES;
    		     .operator = dbg$k_predecessor;
		     END;    		


    		 [dbg$k_plus]:

    		     ! This is really a unary plus

    		     .operator = dbg$k_unary_plus;

    		 [dbg$k_minus]:

    		     ! This is really a unary minus

    		     .operator = dbg$k_unary_minus;

    		 [INRANGE, OUTRANGE]:
    		     BEGIN

    		         ! This shouldn't happen. The user typed something
    		         ! wrong. Tell him what the offending symbol was
    			  
    		         .error_msg = dbg$nmake_arg_vect( dbg$_nooprnd, 0);
    		         RETURN (sts$k_severe);
    		     END;
                 TES;
             

    	! Update the pointers past this operator as we have successfully
    	! parsed a known operator

    	cmd_line[ dsc$a_pointer] = .cmd_line[ dsc$a_pointer] +1;
    	cmd_line[ dsc$w_length] = .cmd_line[ dsc$w_length] - 1;

    	! And update the flags and deal with the special case of right
    	! parenthesis. With a right parenthesis we expect the next 
    	! thing to be an operator, in all other cases we "normally"
    	! believe the next thing will be an operand

    	IF ..operator EQL dbg$k_right_parenthesis
    	THEN .is_an_operand = TRUE
    	ELSE .is_an_operand = FALSE;

    	! Completely parsed a good operator--return successfully

    	RETURN (sts$k_success);

END;





ROUTINE LOOK_AHEAD (command_line)=

!++
! FUNCTIONAL DESCRIPTION:
!
! This routine performs lookahead in the Address Expression Interpreter
! for the purpose of finding out whether a '.' operator is actually
! representing 'the current location' or an indirection operator.
!
! FORMAL PARAMETERS:
!
! 	command_line	-	The address of a VAX Standard String
!				Descriptor which describes the input
!				string.
!
!
! IMPLICIT INPUTS:
!
!	None.
!
! IMPLICIT OUTPUTS:
!
!	None.
!
! ROUTINE VALUE:
!
!	Unsigned integer longword completion code.
!
! COMPLETION CODES:
!
!	aed$_current_loc		- 	The dot represents a 
!						current location.
!
!	aed$_indirection		-	The dot represents an 
!						indirection.
!
! SIDE EFFECTS:
!
!	None.
!
!--

    BEGIN
    	MAP
    	    COMMAND_LINE: REF BLOCK[, BYTE];	! Set up input descriptor so 
    						! we can access it.

        LOCAL 
    	    CURRENT_LINE: REF VECTOR[, BYTE],	! Gives a structure to the
    						! actual command line the 
    						! user typed.

    	    COMMAND_LENGTH,			! Command length within this
    						! routine. This length does
    						! NOT affect the overall
    						! command length of the 
    						! command line external to
    						! this routine.

    	    INDEX;				! Index into the current line.

    	

    	current_line = .command_line[ dsc$a_pointer];
    	index = 0;
    	command_length = .command_line[ dsc$w_length];


    	!++
    	! We should have at least 1 character on the command line.
    	! The previous character is the dot we just parsed and the current one
    	! should be a carriage return. If we don't have this then something
    	! is very wrong. Give up immediately.
    	!--


    	IF .command_length LSS 1
    	THEN SIGNAL (dbg$_debugbug, 1, dbg$k_unexpected_end_cmd_line)
    	ELSE
    	    DO
    	        BEGIN

    		    ! Otherwise see what the next item is

    		    CASE .current_line[ .index]
    		     FROM dbg$k_car_return TO dbg$k_last_value OF

    		        SET
    			
    			[dbg$k_blank]:

    			     ! Got a blank space. Ignore this character
    			     ! and look at the next one

    			     index = .index +1;

    			[dbg$k_plus, dbg$k_minus, dbg$k_multiply, 
    				dbg$k_divide, dbg$k_right_parenthesis, 
    				  dbg$k_car_return, dbg$k_comma, 
    				    dbg$k_colon, dbg$k_equal]:

    			     !++
    			     ! Got either a valid operator (other than
    			     ! left parenthesis) or an operator that
    			     ! the Command Line Interpreter will understand.
    			     ! Obviously we must have a dot
    			     ! meaning current location.
    			     !--

    			     RETURN (aed$_current_loc);


    			[INRANGE, OUTRANGE]:

    			     !++
    			     ! We've found either an operand, a pseudo-symbol,
    			     ! a left parenthesis or something illegal. 
    			     ! We won't worry about
    			     ! quite what it is for the moment, but the
    			     ! dot before it obviously must have meant
    			     ! indirection.
    			     !--

    			     RETURN (aed$_indirection);

    			TES;
    		    END
    		UNTIL ((.index+1) GTR .command_length);
    		    
    		!++
    		! We should never get this far. There wasn't a carriage
    		! return on the end of the line to tell us to stop.
    		! This is WRONG. Tell the user.
    		!--

    		signal ( dbg$_debugbug, 1, dbg$k_unexpected_end_cmd_line);

    		! Unfortunately, BLISS wants a return here though will never
    		! get here, so make it happy.

    		RETURN (aed$_illegal_answer);

    END;	
	



	 

GLOBAL ROUTINE DBG$NGET_TYPE_AND_VALUE( operand, descriptor_type, 
    					type, value, er_msg_vec) =

!++
! FUNCTIONAL DESCRIPTION:
!	Converts an operand of any type to a non-language dependent value 
!	and determines the internal type of the operand.
!
! FORMAL PARAMETERS:
!
!	operand		-	A longword containing either the address
!				of a descriptor to be converted to a
!				value which the Address Expression Descriptor
!				can understand or the actual value which
!				the Address Expression Descriptor can 
!				understand.
!
!	descriptor_type	-	A longword containing the type of descriptor
!				that was popped off the Operand Stack.
!				The only valid types are:
!
!					dbg$k_literal		
!					dbg$k_primary_desc	
!					dbg$k_perm_desc
!					dbg$k_value_desc
!					dbg$k_notype
!					dbg$k_instruction
!
!
!	type		-	A longword to contain the type of the value
!				which has been converted to a number which
!				the Address Expression Interpreter can
!				understand. The only valid types are:
!
!					dbg$k_notype		- no type
!					dbg$k_instruction	- instruction
!
!	value		-	A longword to contain the value that has
!				been extracted from the operand parameter.
!				This value is of a type that the Address
!				Expression Interpreter can understand.
!
!	er_msg_vec	-	A longword to contain the address of
!				a Standard VAX Message Argument Vector
!				as described on page 4-119 of the
!				VAX/VMS System Reference Manual,
!				Volume 1A.
!				
! IMPLICIT INPUTS:
!
!	None.
!
! IMPLICIT OUTPUTS:
!
!	None.
!
! ROUTINE VALUE:
!
!	STS$K_SUCCESS (1) -	The type has been successfully determined.
!
!	STS$K_SEVERE  (4) -	The type could not be determined. The 
!				longword containing the address of the 
!				Standard VAX Message Argument Vection is
!				filled in to point to a fatal error message.
!
! SIDE EFFECTS:
!
! 	None
!
!--

    BEGIN

    	LOCAL

    	    is_it_instr,		! The result of get_type on the
    					! Primary Descriptor. It contains
    					! the type of the Primary Descriptor

    	    lvalue: VECTOR [2],		! The l-value and the bit offset
    					! of the l-value (0 is the l-value,
    					! 1 is the bit offset)

    	    perm_desc: REF DBG$PERMSD;  ! Used as a way of accessing the
    					! operand if it was a Permanent
    					! Symbol Descriptor


    	
    	! Determine what type we've got

    	CASE ..descriptor_type
    	    FROM dbg$k_literal TO dbg$k_notype OF
    	        SET
    		
    	        [dbg$k_instruction]:

    		    BEGIN
    			
    		        ! Found an instruction, no conversion needed

    			.value = ..operand;
    			.type = dbg$k_instruction;
    		    END;

    		[dbg$k_literal, dbg$k_notype]:
    		    
    		    BEGIN

    			! Found a literal, no conversion needed	
    		 
    			.value = ..operand;
    			.type = dbg$k_notype;

    		    END;

    		[dbg$k_primary_desc]:

    		    

    			! Found a primary descriptor, try to find
    			! the internal type of the Primary Descriptor

    			IF dbg$nget_type( ..operand, is_it_instr,
    				.er_msg_vec)
    			THEN BEGIN
    				 
    				 ! Record the type
    				 
    				 CASE .is_it_instr
    				     FROM dbg$k_nc_instruction TO 
    					dbg$k_other OF
    				         SET
    			
    					 [dbg$k_nc_instruction]:
    					     
    					     .type = dbg$k_instruction;

    					 [dbg$k_nc_other, dbg$k_other]:

    					     .type = dbg$k_notype;

    					 [inrange, outrange]:

    					     signal ( dbg$_debugbug, 1,
    						dbg$k_invalid_type);
    					     
    					 TES;
    				 

    				 ! Now get the Primary descriptor's value

    				 CASE dbg$nget_lval( ..operand, lvalue, 
    						.er_msg_vec)
    			           FROM sts$k_success TO sts$k_severe OF

       				     SET	
   				   
    				     [sts$k_success]:

    					 ! Got l-value all done

    					 .value = .lvalue[0];
    				     
    				     [sts$k_error]:

    					 ! No l-value, try for an 
    					 ! r-value

    					 CASE dbg$nget_rval( ..operand,
    					  		.value, .er_msg_vec)
    					  FROM sts$k_warning TO sts$k_severe OF

    					     SET

    					     [sts$k_severe]:

    						 ! No r or l-value

    						 RETURN (sts$k_severe);

    					     [sts$k_success]:

    						 ! Got an r-value
    						
    						 0;

    					     [sts$k_warning]:

    						!++
    						! Got r-value and type
    						! of instruction. This
    						! override the current
    						! type. However, if the
    						! current type is 
    						! instruction, then this
    						! is an error
    						!__

    						IF ..type EQL dbg$k_instruction
    						THEN signal( dbg$_debugbug,
    						        1, 
    						        dbg$k_r_val_type_conflict)
    						ELSE .type = dbg$k_instruction;

    				            [inrange, outrange]:

    						! Should never happen

    						signal( dbg$_debugbug, 1,
    						   dbg$k_illegal_return_value);

    					    TES;
    						

    				     [sts$k_severe]:
    				         
    			    		 ! No l-value can be obtained--should
    					 ! never happen

    					 RETURN (sts$k_severe);


    				     [inrange, outrange]:

    						! Should never happen

    						signal( dbg$_debugbug, 1,
    						   dbg$k_illegal_return_value);
    				     TES

    			     END

    			! Couldn't get a type for the Primary Descriptor

    			ELSE RETURN (sts$k_severe);

    		[dbg$k_value_desc]:
    			
    			! Got a value descriptor. It's type by default is
    			! none, but we'll have to find its' value

    			IF NOT get_a_value ( ..operand, .value, .er_msg_vec)
    			THEN RETURN (sts$k_severe)
    			ELSE .type =dbg$k_notype;
    			

    		[dbg$k_perm_desc]:
    			
    			BEGIN

    			    ! Pick the address out of the permanent descriptor
    				
    			    perm_desc = ..operand;
    			    .value = .perm_desc [dbg$l_permsd_addr];
    			    .type = dbg$k_notype;
    			END;

    		[INRANGE, OUTRANGE]:

    			signal (dbg$_debugbug, 1, dbg$k_invalid_type);
	    			    
    		TES;

    	! Successful conversion

    	RETURN (sts$k_success);
    END; 	





ROUTINE SET_UP_FOR_ADDRESS_ARITHMETIC( operand_stack_ptr, operator_stack_ptr,
    			kind_of_operand_one, kind_of_operand_two, operator,
    			 msg_of_error_vtr, current_operator, operand_one_value,
    			  operand_two_value, prim_type_one, prim_type_two,
    			   operand_one, operand_two) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Sets up the operator and operand stacks to operate on two operands
!	and an operator and gets the type and value for each operand so
!	that they can be operated upon. To accomplish this task, two operands
!	are popped off the operand stack and an operator is popped off the
!	operator stack.
!
! FORMAL PARAMETERS:
!
!	operand_stack_ptr	-	A longword containing a pointer to the
!					head of the Operand Stack.
!
!	operator_stack_ptr	-	A longword containing a pointer to the
!					head of the Operator Stack.
!
!	kind_of_operand_one	-	The address of a longword to contain 
!					the kind of the first operand popped 
!					off the stack. The kind	may be one 
!					of the following:
!
!						DBG$K_PRIMARY_DESC
!						DBG$K_PERM_DESC
!						DBG$K_INSTRUCTION
!						DBG$K_LITERAL
!						DBG$K_NOTYPE
!
!	kind_of_operand_two	-	The address of a longword to contain 
!					the kind of the second operand popped
!					off the Operand Stack. The kind may 
!					be one of the following:
!
!						DBG$K_PRIMARY_DESC
!						DBG$K_PERM_DESC
!						DBG$K_INSTRUCTION
!						DBG$K_LITERAL
!						DBG$K_NOTYPE
!
!	operator		-	The address of a longword to contain
!					the operator to be popped of the
!					Operator Stack.
!
!	msg_of_error_vtr	-	A longword to contain the address of
!					a Standard VAX Message Argument Vector
!					as described on page 4-119 of the
!					VAX/VMS System Reference Manual, 
!					Volume 1A.
!
!	current_operator	-	A longword to contain the 
!					operator currently being operated
!					upon as determined previously.
!
!	operand_one_value	-	A longword to contain the value
!					of the first operand popped off
!					the Operand Stack.
!
!	operand_two_value	-	A longword to contain the value
!					of the second operand popped off
!					the Operand Stack.
!
!	prim_type_one		-	If the first operand popped off
!					the Operand Stack is a Primary
!					Descriptor, then this parameter
!					is a longword to contain the
!					type of the Primary Descriptor.
!
!	prim_type_two		-	If the second operand popped off
!					the Operand Stack is a Primary
!					Descriptor, then this parameter
!					is a longword to contain the 
!					type of the Primary Descriptor.
!
!	operand_one		-	A longword to contain the address
!					or value of the first operand
!					popped off the Operand Stack.
!
!	operand_two		-	A longword to contain the address
!					of value of the second operand
!					popped off the Operand Stack.
!
! IMPLICIT INPUTS:
!
!	None.
!
! IMPLICIT OUTPUTS:
!
!	If this routine is successful, the Operand Stack has two less
!	members and the Operator Stack has one less member. The respective
!	pointers to those two stack are updated to reflect this.
!
!	If there were no members of the stack to remove then an error message
!	is signaled.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code.
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS  (1)	-	The first two members of the Operand
!					Stack and the first member of the
!					Operator Stack has been removed and
!					a value and type has been found 
!					for each operand.
!
!	STE$K_SEVERE   (4)	-	Either the appropriate stacks could
!					not be popped or a value could not
!					be found for each of the operands.
!
! SIDE EFFECTS:
!	
!	None.
!
!--

    BEGIN
    	
    	LOCAL
    	    OVERRIDE_TYPE;		! The override type of this operand
    					! as used by the Pseudo-Symbol 
    					! Interpreter


    	! Get two operands and an operator

    	IF operand_pop( .operand_stack_ptr, .kind_of_operand_one, override_type,
    		.operand_one, .msg_of_error_vtr)
    	THEN IF operand_pop( .operand_stack_ptr, .kind_of_operand_two, 
    			override_type, .operand_two, .msg_of_error_vtr)
    	     THEN IF operator_pop( .operator_stack_ptr, .operator, 
    			.msg_of_error_vtr)

    		  ! Check that the operator we've got is o.k.

    		  THEN 
    		      IF dbg$nget_type_and_value( .operand_one, 
    			       .kind_of_operand_one,
    		    		.prim_type_one, .operand_one_value, 
    				 .msg_of_error_vtr)
    		      THEN IF dbg$nget_type_and_value( .operand_two, 
    				.kind_of_operand_two,
    				.prim_type_two, .operand_two_value, 
    				 .msg_of_error_vtr)

    			   ! Got all values, return successfully

    			   THEN RETURN (sts$k_success)


  	 		   ! Couldn't get the second operand's type

    			   ELSE RETURN (sts$k_severe)


    		      ! Couldn't get the first operand's type

    		      ELSE RETURN (sts$k_severe)


    		  ! Couldn't pop the Operator Stack

    		  ELSE RETURN (sts$k_severe)


    	     ! Couldn't pop the Operand Stack the second time

    	     ELSE RETURN(sts$k_severe)


    	! Couldn't pop the Operand Stack the first time

        ELSE RETURN(sts$k_severe);


    	! Should never get here but we'll make BLISS happy
    	
    !	RETURN (sts$k_severe);
    END;






ROUTINE THE_CURRENT_TYPE( kind_of_operand_one, kind_of_operand_two, 
    		primary_type_one, primary_type_two)=

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Determines the type of the Address Expression being computed,
!	given the two operands being used.
!
! FORMAL PARAMETERS:
!
!	kind_of_operand_one	-	The address of a longword to contain 
!					the kind of the first operand popped 
!					off the stack. The kind	may be one 
!					of the following:
!
!						DBG$K_PRIMARY_DESC
!						DBG$K_PERM_DESC
!						DBG$K_INSTRUCTION
!						DBG$K_LITERAL
!						DBG$K_NOTYPE
!
!	kind_of_operand_two	-	The address of a longword to contain 
!					the kind of the second operand popped
!					off the Operand Stack. The kind may 
!					be one of the following:
!
!						DBG$K_PRIMARY_DESC
!						DBG$K_PERM_DESC
!						DBG$K_INSTRUCTION
!						DBG$K_LITERAL
!						DBG$K_NOTYPE
!
!	primary_type_one	-	A longword to contain the
!					type of the Primary Descriptor
!					if the first operand is a Primary.
!
!	primary_type_two	-	A longword to contain the type of 
!					the Primary Descriptor if the
!					second operand is a Primary.
!
! IMPLICIT INPUTS:
!
!	None.
!
! IMPLICIT OUTPUTS:
!
!	None.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword whose value is the type of the 
!	Address Expression being computed.
!
! COMPLETION CODES:
!
!	None.
!
! SIDE EFFECTS:
!
!	None.
!
!--

BEGIN
    CASE ..kind_of_operand_one
      FROM dbg$k_literal TO dbg$k_notype OF
         SET

    	 [dbg$k_primary_desc]:
    	     BEGIN
    		 IF ..primary_type_one EQL dbg$k_instruction 
    		 THEN
    		     BEGIN
    			 IF ( ..kind_of_operand_two EQL dbg$k_literal)
    					AND
    			    ( ..primary_type_two EQL dbg$k_notype)
    			 THEN RETURN (dbg$k_instruction)
    			 ELSE RETURN (dbg$k_notype)
    		     END
    		 ELSE RETURN (dbg$k_notype)
    	     END;

    	 [dbg$k_instruction]:
    	     BEGIN
    		 IF ..primary_type_two EQL dbg$k_notype
    		 THEN 
    		     BEGIN
    			 IF ( ..kind_of_operand_two EQL dbg$k_literal)
    					AND
    			     ( ..primary_type_two EQL dbg$k_notype)
    			 THEN RETURN (dbg$k_instruction)
    			 ELSE RETURN (dbg$k_notype)
    		     END
    		 ELSE RETURN (dbg$k_notype)
    	     END;

    	 [dbg$k_literal]:
	     BEGIN
    		 IF ..primary_type_one EQL dbg$k_notype 
    		 THEN
    		     BEGIN
    		     	 IF ..kind_of_operand_two EQL dbg$k_primary_desc
    		     	 THEN 
    		     	     BEGIN
    		     		 IF ..primary_type_two EQL dbg$k_instruction
    		     		 THEN RETURN (dbg$k_instruction)
    		     		 ELSE RETURN (dbg$k_notype)
    		     	     END
    		     	 ELSE IF ..kind_of_operand_two EQL dbg$k_instruction
    			      THEN 
    				  BEGIN
    				      IF ..primary_type_two EQL dbg$k_notype
    				      THEN RETURN (dbg$k_notype)
    				      ELSE RETURN (dbg$k_notype)
    				  END
    			      ELSE RETURN (dbg$k_notype)
    		     END
                 ELSE RETURN (dbg$k_notype)
    	     END;

    	   [inrange, outrange]:

               RETURN (dbg$k_notype);


           TES;


END;    		    





ROUTINE UPDATE_PREV_OPER( operator_ptr) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Determines what the current previous operator actually is.
!
! FORMAL PARAMETERS:
!
!	operator_ptr		-	A longword to contain the pointer
!    					to the top of the Operator Stack.
! IMPLICIT INPUTS:
!
!	The Operator Stack.
!
! IMPLICIT OUTPUTS:
!
!	None.
!
! ROUTINE VALUE:
!
!	Unsigned integer longword whose value is an operator. Valid operators
!	may be one of the following:
!
!		DBG$K_PLUS
!		DBG$K_MINUS 			 	 
!		DBG$K_LEFT_PARENTHESIS
!		DBG$K_RIGHT_PARENTHESIS
!		DBG$K_DIVISION_SIGN
!		DBG$K_STAR
! 
! COMPLETION CODES:
!
!	None.
!
! SIDE EFFECTS:
!
!	None.
!
!--

      BEGIN
    	
            LOCAL
    	    
    	       TEMP_OP_PTR: REF AE_OPERATOR_STACK_DESC;	! Temporary pointer
    							! to allow access
    							! to the Operator
    							! Stack.

    	temp_op_ptr = ..operator_ptr;

    	! Make sure there is something on the stack

    	IF .temp_op_ptr NEQ NIL
    	THEN RETURN (.temp_op_ptr [l_operator])
    	ELSE RETURN (NIL);
    END;





ROUTINE  GET_A_VALUE( value_desc, value, err_msg )=

!++
! FUNCTIONAL DESCRIPTION:
!
!	Given a value descriptor describing an address, this routine 
!	converts it to a value that the Address Expression Interpreter
!	can understand.
!
! FORMAL PARAMETERS:
!
!	value_desc	-	A longword containing the address of a
!				value descriptor to be converted.
!
!	value		- 	A longword to contain the address of the
!				value described	by the value descriptor.
!
!	err_msg		-	A longword to contain the address of a
!				Standard VAX Message Argument Vector as
!				described on page 4-119 of the VAX/VMS
!				System Reference Manual, Volume 1A.
!
! IMPLICIT INPUTS:
!
!	None.
!
! IMPLICIT OUTPUTS:	
!
!	The value is extracted from the Value Descriptor given as an input
!	to this routine. The value may be truncated and an informational
!	message put out to the user if it is found to be necessary in the
!	conversion process.
!
! ROUTINE VALUE:
!
!	Unsigned integer longword completion code.
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS	-	The value was extracted and converted from
!				the Value Descriptor and has been returned.
!
!	STS$K_SEVERE	-	The value could not be gotten from the
!				Value Descriptor.
!
! SIDE EFFECTS:
!
!	None.
!
!--

    BEGIN
    	
    	LITERAL
    	    DBG$K_SCALAR_SIZE = 8;

    	MACRO
    	    DBG$SCALAR_DESC = BLOCK [DBG$K_SCALAR_SIZE, BYTE]% ;

    	LOCAL
    	    STNDRD_DESC: DBG$SCALAR_DESC;	! A VAX standard scalar
    						! descriptor.

    	! Set up VAX Standard Scalar Descriptor

    	stndrd_desc[ dsc$b_class] = dsc$k_class_s;

    	! Unsigned numbers only, please

    	stndrd_desc[ dsc$b_dtype] = dsc$k_dtype_lu;
    	stndrd_desc[ dsc$w_length] = 0;
    	stndrd_desc[ dsc$a_pointer] = .value;

    	IF dbg$ntype_conv ( .value_desc, dbg$k_default, dbg$k_vax_desc,
    				stndrd_desc, .err_msg)
    	THEN RETURN (sts$k_success)
    	ELSE RETURN (sts$k_severe);
    END;





ROUTINE UPDATE_STACK_VALUES( shd_end, finished_with_operator, operator_ptr,
    		top_operator): NOVALUE=
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine updates various values associated with manipulating 
!	the Address Expression Interpreter's Stacks. 
!
!	The next operator on the Operator Stack is found, the flag
!	that states one should stop parsing the Address Expression
!	is set to FALSE and the flag that states that one is finished
!	with the last operator used is set to TRUE.
!
! FORMAL PARAMETERS:
!
! 	shd_end			- 	A longword containing the address 
!					of a flag which states 
!					whether the Address Expression 
!					Interpreter should stop parsing.
!
!	finished_with_operator	-	A longword containing the address
!					of a flag which states whether
!					the Address Expression Interpreter
!					is done evaluating the current operator
!
!	operator_ptr		-	A longword containing a pointer to the 
!					head of the operator stack.
!	
!	top_operator		-	The operator at the top of the Operator
!					Stack.
!
! IMPLICIT INPUTS:
!
!	None.
!
! IMPLICIT OUTPUTS:
!
!	None.
!
! ROUTINE VALUE:
!
!	None.
!
! COMPLETION CODES:
!
!	None.
!
! SIDE EFFECTS:
!
!	None.
!
!--

    BEGIN
    	
    	.shd_end = FALSE;
    	finished_with_operator = TRUE;
    	.top_operator = update_prev_oper (.operator_ptr);
    END;







ROUTINE GET_CHAR_OR_END_OF_LINE ( input_desc, shd_end, how_end)=

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine determines if the end of the command line given
!	by the Command Line Interpreter to the Address Expression
!	Interpreter is true or if anything else (whether legal or
!	illegal syntactically) is on the command line. This 
!	is determined by checking if the
!	next character in the command line is a carriage return.
!	If this is true, this routine cleans up	for the Address 
!	Expression Interpreter.
!
!	By "cleans up" it is meant that:  1) The flag that states
!	we are done parsing is set to true; 2) The string descriptor
!	describing the command line has its length and pointer fields
!	explicitly set to 0; 3) The flag that determines if parsing
!	was successful is set to indicate success.
!
!	If the end of the command line has not been found then this
!	routine updates the string descriptor describing the command
!	line to reflect the next item to be parsed.
!
!	Note that all blanks on the command line are ignored.
!
! FORMAL PARAMETERS:
!
!	input_desc	-	A longword containing the address of 
!				the entire string descriptor describing
!				the command line passed by the Command
!				Line Interpreter to the Address Expression
!				Interpreter.
!
!	shd_end		-	A longword containg the flag that 
!				determines whether we should
!				stop parsing the command line now.
!
!	how_end		- 	A longword containing the flag that
!				determines the value of success that
!				the Address Expression Interpreter will
!				return to the Command Line Interpreter.
!
! IMPLICIT INPUTS:
!
!	None.
!
! IMPLICIT OUTPUTS:
!
!	If end of line is true according to the criterias set out above,
!	then the flag determining that the Address Expression Interpreter
!	should stop parsing will be set to true, the flag indicating the
!	outcome of the parsing will be set to success, and the string
!	descriptor describing the command line passed to the Address Expression
!	Interpreter by the Command Line Interpreter will have its length
!	and pointer fields set to 0.
!
!	If end of line is true according to the criterias set out above,
!	but there is something on the command line after the carriage return,
!	a signal of an internal debug error is done.
!
!	If end of line is false according to the criterias set out above,
!	then one of two things may happen. If the command line is not there
!	at all then a signal of an internal debug error is done (we should
!	have gotten out of the parsing and syntax analysis section of
!	the Address Expression Interpreter when this state occured in the
!	first place). If the command line still has something valid on it,
!	then the string descriptor describing it has its length and pointer
!	fields updated to point to the next item to be looked at.
!
! ROUTINE VALUE:
!
!	Unsigned integer longword completion code.
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) - End of line was found. The string descriptor
!			    and flags given as input to this routine have
!			    been updated to reflect the completion of all
!			    parsing successfully.
!
!	STS$K_SEVERE (4) -  End of line was not found. The string descriptor
!			    was updated to reveal the next item to be parsed.
!			    Other flags have not be altered.
!
! SIDE EFFECTS:
!
!	None.
!
!--

    BEGIN
    	MAP
    	    INPUT_DESC: REF BLOCK[ ,BYTE];

    	LOCAL
    	    OLD_PTR,		        	! A temporary place to put 
    						! the pointer to the input 
    						! string

    	    LINE_PTR,
    	    
    	    NEW_LINE: REF VECTOR[ ,BYTE];    	



    	! Find the next non_space

    	old_ptr = .input_desc[ dsc$a_pointer];
    	line_ptr = .input_desc[ dsc$a_pointer];
    	line_ptr = CH$FIND_NOT_CH( .input_desc[ dsc$w_length], .line_ptr,
    			dbg$k_blank);
    	new_line = .line_ptr;


    	IF .new_line[0] EQL dbg$k_car_return
    	THEN 
    	    BEGIN

    		! Update the length to the current length of the input line

    		input_desc[ dsc$w_length] = .input_desc[dsc$w_length] -
    					        (.new_line - .old_ptr);

    		!++
    		! Something following a carriage return
    		! on the input line:  how absurd.
    		! If true something is definitely wrong.
    		!--

    		IF .input_desc[ dsc$w_length] GTR 1
    		THEN signal (dbg$_debugbug, 1, dbg$k_garbage_end_input_line)
    		ELSE 0;



    		! End of line is true, update the flags and string descriptor

    		.shd_end = TRUE;

    		.how_end = sts$k_success;

    		input_desc[ dsc$w_length] = 0;
    		input_desc[ dsc$a_pointer] = 0;
    		RETURN (sts$k_success);
    	    END 


    ELSE

        ! If only one character and it wasn't a carriage return we have
    	! an internal DEBUG error

    	IF .input_desc [dsc$w_length] EQL 1
    	THEN signal (dbg$_debugbug, 1, dbg$k_garbage_end_input_line)
        ELSE 

    	    ! Not end of line, make sure we really have something here

            IF .new_line EQL 0
    	    THEN signal( dbg$_debugbug, 1, dbg$k_garbage_end_input_line)
    	    ELSE
    	        BEGIN
    		    input_desc[ dsc$w_length] = .input_desc[ dsc$w_length]
    				 		    - (.new_line - .old_ptr);
    	 	    input_desc[ dsc$a_pointer] = .new_line;
    	        END;

        RETURN (sts$k_severe);
END;





ROUTINE RECOVER_DOT ( operator_ptr, operand_ptr, operator, prev_oper, 
    			is_an_operand, override_type, override_length,
    			  err_message)=

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	If the last item correctly parsed on the command line was a
!	dot of type indirection and the item which came next could not be
!	parsed, then the dot of type indirection is assumed to be really
!	of type current location. This routine recovers the last dot
!	off the operator stack and makes it into the current location 
!	operator. If the top item on the Operator Stack is not a dot
!	then this routine returns without having done anything to the stacks.
!
! FORMAL PARAMETERS:
!
!	operator_ptr	-	A longword containing a pointer to
!				the Operator Stack.
!
!	operand_ptr	-	A longword containing a pointer to
!				the Operand Stack.
!
!	operator	-	A longword containing the integer
!				value representing the current operator.
!	
!	prev_oper	-	A longword containing the integer value
!				representing the previous operator.
!
!	is_an_operand	-	A longword containing a flag which states
!				whether the previous item parsed was an
!				operator or operand.
!
!	override_type	-	A longword to contain the current 
!				override type.
!
!	override_length	-	A longword to contain the override length
!				associated with the override type.
!
!	err_message	-	A longword to contain the address of a
!				Standard VAX Message Argument Vector
!			        as described on page 4-119 of the VAX/VMS
!				System Reference Manual, Volume 1A.
!
! IMPLICIT INPUTS:
!
!	The Operand and Operator Stack for the Address Expression Interpreter.
!
! IMPLICIT OUTPUTS:
!
!	If the first operator on the Operator Stack is a dot then
!	the Operator Stack has its first member popped off, the value
!	of the current location is found and the current location is
!	put onto the Operand Stack. If the first operator on the Operator
!	Stack is not a dot, then nothing is done.
!
!	If any of this could not be done then the longword containing the
!	address of the Standard VAX Message Argument Vector for that buffer
!	is updated to contain the address of the error message buffer.
!
! ROUTINE VALUE:
!
!	Unsigned integer longword completion code.
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS	(1)	-	The transforming of the 
!					last operator to current location
!					was done if necessary.	
!
!	STS$K_SEVERE	(4)	-	The transforming of the last operator
!					to current location could not be
!					done and was necessary.
!
! SIDE EFFECTS:
!
!	None.
!
!--

    BEGIN
    	LOCAL
    	    WHAT_POINT_TO: REF AE_OPERATOR_STACK_DESC,  ! Access variable to
    							! operator stack

    	    PSEUDO_SYMBOL;				! Flag to determine
    							! if there is a
    							! pseudo-symbol

    	IF ..operator_ptr NEQ NIL 
 	THEN BEGIN

                 what_point_to = ..operator_ptr;
    		 IF .what_point_to [ l_operator] EQL dbg$k_indirection
                 THEN 
    	            BEGIN
    		        IF operator_pop ( .operator_ptr, .operator, 
    				.err_message)
    		        THEN IF ..operator NEQ dbg$k_indirection
    		      	     THEN signal (dbg$_debugbug, 1, 
    			            dbg$k_confused_stack_operator)
    		     	     ELSE 
    			         BEGIN
    			             IF NOT evaluate_pseudo_symbol ( 
    						.is_an_operand,
    					        ..operator, .override_type, 
    					        .override_length, .operand_ptr,
    					        pseudo_symbol, .err_message)
    			             THEN RETURN (sts$k_severe)
    			             ELSE 
    				         BEGIN

    					     ! Update the current and previous
    					     ! operator

    				             what_point_to = ..operator_ptr;

    					     ! IF there is nothing on the
    					     ! operator stack then both
    					     ! the operator and the previous
    					     ! operator should be NIL

    					    IF .what_point_to EQL NIL
    					    THEN
    						BEGIN
    						    .operator = NIL;
    						    .prev_oper = NIL;
    						END
    					    ELSE
    					        BEGIN
    				                    .operator = 
    						        .what_point_to
    							   [l_operator];
    				       	            what_point_to = 
    						      .what_point_to[ 
    						        l_ptr_to_nxt_operator];
    					            IF .what_point_to NEQ
    							  NIL
    						    THEN .prev_oper = 
    							.what_point_to[
   							       l_operator]
    						    ELSE .prev_oper = NIL;
    						END;
    				         END;
    			         END
    	               ELSE RETURN (sts$k_severe);
    	         END;
             END;
    	 RETURN (sts$k_success);
    END;





ROUTINE ARE_STACKS_OK ( operator_ptr, operand_ptr, error_message) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine checks to see that there is nothing on either the
!	operator or operand stacks.
!
! FORMAL PARAMETERS:
!
!	operator_ptr	- 	A longword containing a pointer to the head
!				of the operator stack or NIL (0) if there
!				is no member on the Operator Stack.
!
!	operand_ptr	-	A longword containing a pointer to the head
!				of the operand stack or NIL (0) if there
!				is no member on the Operand Stack.
!
!	error_message	-	A longword to contain the address of a 
!				Standard VAX Message Argument Vector as
!				described on page 4-119 of the VAX/VMS
!				System Reference Manual, Volume 1A.
!
! IMPLICIT INPUTS:
!
!	The Address Expression Interpreter's Operator and Operand Stack.
!	
!
! IMPLICIT OUTPUTS:
!
!	None.
! 
! ROUTINE VALUE:
!
!	Unsigned integer longword completion code.
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS 	(1)	-	There are no members on the Operator
!					or Operand Stack.
!
!	STS$K_SEVERE	(4)	-	There is something on either the
!					Operator or Operand Stack. An
!					error message appropriate to which
!					is missing has been created.
!
! SIDE EFFECTS:
!
!	None.
!
!--

    BEGIN

    	! Generally if we don't pick something off the stack it is because
    	! we are missing an operator. Check for this first.

	IF ..operand_ptr NEQ NIL
	THEN
    	    BEGIN
    	        .error_message = dbg$nmake_arg_vect ( dbg$_nooprtr, 0);
    	        RETURN (sts$k_severe);
    	    END
    	ELSE IF ..operator_ptr NEQ NIL
    	     THEN 
    	         BEGIN
    		     .error_message = dbg$nmake_arg_vect ( dbg$_nooprnd, 0);
    		     RETURN (sts$k_severe);
    	         END;
    
    	RETURN (sts$k_success);
    END;
    			
    			     

END
ELUDOM
