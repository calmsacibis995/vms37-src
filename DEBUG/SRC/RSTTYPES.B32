MODULE RSTTYPES (IDENT = 'V03-000') =

BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! WRITTEN BY
!	Bert Beander	August, 1980
!	Ken Nappa	August, 1980
!
! MODULE FUNCTION
!	This module contains symbol table access routines for types.  These
!	routines accept a Type ID and return information about the correspond-
!	ing data type.
!

REQUIRE 'SRC$:DBGPROLOG.REQ';

FORWARD ROUTINE
    DBG$STA_SYMTYPE:	NOVALUE,	! Return a symbol's TYPEID and FCODE
    DBG$STA_SYMSIZE:	NOVALUE,	! Return the bit size of a data type
    DBG$STA_TYPEFCODE,			! Return the type format code
    DBG$STA_TYP_AREA:	NOVALUE,	! Return info for a PL/I area type
    DBG$STA_TYP_ARRAY:	NOVALUE,	! Return info for an array type
    DBG$STA_TYP_ATOMIC:	NOVALUE,	! Return type code for an atomic type
    DBG$STA_TYP_DESCR:	NOVALUE,	! Return descriptor for descriptor type
    DBG$STA_TYP_ENUM:	NOVALUE,	! Return info for an enumeration type
    DBG$STA_TYP_FILE:	NOVALUE,	! Return info for a file type
    DBG$STA_TYP_OFFSET:	NOVALUE,	! Return info for a PL/I offset type
    DBG$STA_TYP_PICT:	NOVALUE,	! Return info for a picture type
    DBG$STA_TYP_TYPEDPTR: NOVALUE,	! Return info for a typed pointer type
    DBG$STA_TYP_RECORD:	NOVALUE,	! Return info for a record type
    DBG$STA_TYP_SET:	NOVALUE,	! Return info for a set type
    DBG$STA_TYP_SUBRNG:	NOVALUE,	! Return info for a subrange type
    DBG$STA_TYP_SUBSET:	NOVALUE,	! Return info for a subset type
    DBG$STA_TYP_UNION:	NOVALUE,	! Return info for a union type
    DBG$STA_TYP_VARIANT:NOVALUE,	! Return info for a variant type
    DBG$STA_TYP_VARIANT_COMP: NOVALUE,	! XXX
    TYPEID_FOR_ATOMIC,			! Return Type ID for atomic type
    TYPEID_FOR_COB_HACK,		! Return Type ID for COBOL Hack record
    TYPEID_FOR_DESCR,			! Return Type ID for descriptor type
    TYPEID_FROM_DST_TYPESPEC,		! Return Type ID from a Type Speci-
					!      fication embedded in the DST
    typeid_from_dst_record,
    find_type_record,			! Returns symid of type info
    trans_type_code,			! Translates DST fcodes to RST fcodes
    desc_or_array_or_atom,		! Determines the nature of the type.
    get_typespec,
    find_typrec_from_tspec,
    dtype_to_bitsize,
    get_type_size,
    bli_bitsize,
    find_rst_type_entry;

EXTERNAL ROUTINE
    DBG$GET_MEMORY,			! Get a permanent memory block
    DBG$GET_TEMPMEM,			! Get a "temporary" memory block
    DBG$READ_ACCESS: NOVALUE,		!
    DBG$STA_SYMKIND,			! Get a specified symbol's kind
    DBG$STA_SYMVALUE: NOVALUE,		! Evaluate a specified symbol's value
    DBG$STA_VALSPEC: NOVALUE;		! Evaluate a DST Value Spec

EXTERNAL
    DBG$GB_SYM_STATUS: BYTE,		!
    DST$BEGIN_ADDR,			! The start address of the DST in memory
    RST$START_ADDR,			! Pointer to RST anonymous module
    RST$TEMP_LIST;			! Pointer to Temporary RST Entry List

GLOBAL ROUTINE DBG$STA_SYMTYPE(SYMID, FCODE, TYPEID): NOVALUE =
!
! FUNCTION
!	This routine takes a SYMID and returns a TYPEID and FCODE for the
!	type associated with the input SYMID.  In the case where the SYMID
!	defines a type item, the returned TYPEID is identical to the SYMID.
!
! INPUTS
!	SYMID	- The SYMID for the symbol or type whose TYPEID and  Format Code
!		  are to be returned.
!
!	FCODE	- The address of a longword location to receive the FCODE
!		  associated with the given SYMID.
!
!	TYPEID	- The address of a longword location to receive the
!		  TYPEID describing the type associated with SYMID.
!
! OUTPUTS
!	FCODE	- The format code associated with SYMID is returned to FCODE.
!
!	TYPEID 	- A TYPEID defining the type associated with the input
!		  SYMID is returned to TYPEID.
!
!

    BEGIN

    MAP
	SYMID: REF RST$ENTRY,		! Pointer to input symbol's RST entry
	FCODE: REF VECTOR[1],		! Address where FCODE is returned
	TYPEID: REF VECTOR[1];		! Address where TYPEID is returned

    LOCAL
	SIZE;				! Bit size of a data item of the type



    ! Find the Type RST Entry associated with the input SYMID.  Return its
    ! address to TYPEID[0] and its Format Code to FCODE[0].  Signal an internal
    ! error if the TYPEID turns out to be zero--that should never happen.
    !
    TYPEID[0] = FIND_TYPE_RECORD(.SYMID, FCODE[0], SIZE);
    IF .TYPEID[0] EQL 0
    THEN
	SIGNAL(DBG$_DEBUGBUG, 1, DBG$K_NO_TYPEID);

    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_SYMSIZE(SYMID, SIZE): NOVALUE =
!
! FUNCTION
!	This routine takes a SYMID and returns the size in bits associated
!	with that input SYMID.
!
! INPUTS
!	SYMID	- The SYMID for the symbol or type whose bitsize is to be
!		  returned.
!
!	SIZE	- The address of a longword location to receive the size in bits
!		  of the item described by the given SYMID.
!
! OUTPUTS
!	SIZE	- The size in bits of the input item is returned to SIZE.
!
!	No value is returned.
!

    BEGIN

    MAP
	SYMID: REF RST$ENTRY,		! Pointer to input symbol's RST entry
	SIZE: REF VECTOR[1];		! Address where size is to be returned

    LOCAL
	TYPEID: REF RST$ENTRY,		! The symbol's Type ID
	FCODE;				! The symbol's Type Format Code



    ! Get to the Type DST record and pick up the size information.  If no type
    ! info was found, set the bit size to zero (wich means size is unknown).
    !
    TYPEID = FIND_TYPE_RECORD(.SYMID, FCODE, SIZE[0]);
    IF .TYPEID EQL 0 THEN SIZE[0] = 0;
    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_TYPEFCODE(SYMID) =
!
! FUNCTION
!	This routine returns the Format Code (FCODE) associated with a specified
!	type (given by a SYMID or TYPEID).  The Format Code is simply picked up
!	from the type's RST entry.
!
! INPUTS
!	SYMID	- The SYMID for the symbol or type whose type Format Code
!		  is to be returned.
!
! OUTPUTS
!	The type's Format Code is returned as the routine value.  The possible
!		  Format Codes are listed in DBGLIB.REQ.
!
!

    BEGIN

    LOCAL
	TYPEID,				! The symbol's Type ID
	FCODE;				! The symbol's type Format Code



    ! Get the symbol's type and Format Code.  Then return the type Format Code.
    !
    DBG$STA_SYMTYPE(.SYMID, FCODE, TYPEID);
    RETURN .FCODE;

    END;

GLOBAL ROUTINE DBG$STA_TYP_ARRAY(TYPEID, DSCADDR, CELLTYPE,
					NDIMS, DIMVECPTR, BITSIZE): NOVALUE =
!
! FUNCTION
!	This routine returns the type information associated with an Array data
!	type.  The type of interest is identified by a Type ID, and the returned
!	information includes the array descriptor, the cell type, the number of
!	dimensions, the size in bits of the array, and information about each
!	specific dimension (the subscript type, the lower bound, and the upper
!	bound).
!
! INPUTS
!	TYPEID	- The Type ID of the Array data type about which information is
!		  desired.  Its Format Code must be RST$K_TYPE_ARRAY.
!
!	DSCADDR	- The address of a longword location to receive a pointer to the
!		  array's descriptor.
!
!	CELLTYPE - The address of a longword location to receive the Type ID of
!		  the data type of the individual array elements.
!
!	NDIMS	- The address of a longword location to receive the number of
!		  dimensions in the array.
!
!	DIMVECPTR - The address of a longword location to receive a pointer to a
!		  vector of subscript information.
!
!	BITSIZE	- The address of a longword location to receive the size in bits
!		  of an array of this type.
!
! OUTPUTS
!	DSCADDR - The address of the array descriptor is returned to DSCADDR.
!		  This may be a contiguous or noncontiguous array descriptor.
!		  The descriptor may disappear at the end of the current Debug
!		  command.
!
!	CELLTYPE - The Type ID of the individual array elements' data type is
!		  returned to CELLTYPE.
!
!	NDIMS	- The number of array dimensions is returned to NDIMS.
!
!	DIMVECPTR - A pointer to a subscript vector is returned to
!		  DIMVECPTR.  This vector contains one longword
!		  per dimension, giving the subscript Type ID.
!		  The vector is allocated in temporary storage--it disappears
!		  at the end of the current Debug command.
!
!	BITSIZE	- The size in bits is returned to BITSIZE.
!
!	No value is returned.
!

    BEGIN

    MAP
    	typeid : REF rst$entry;

    LOCAL
	i,
	size,
	fcode,
	valkind,
	type_spec : REF dst$type_spec,
	type_spec1 : REF dst$type_spec,
	dst_ptr : REF dst$record,
	type_ptr : REF rst$entry,
	desc_ptr : REF BLOCK[,BYTE],
	subscr_vect : REF VECTOR,
	val_vect : VECTOR[3],
	val_ptr : REF dst$val_spec;

    type_ptr = find_type_record(.typeid, fcode, size);

    ! type_ptr -> rst entry for this array type

    ! verify format code

    IF .fcode NEQ rst$k_type_array
    THEN
	SIGNAL(dbg$_debugbug, 1, dbg$k_wrong_typecode);
    dst_ptr = .type_ptr[rst$l_dstptr];
    type_spec = dst_ptr[dst$a_typspec_ts_addr] + .dst_ptr[dst$b_typspec_name];
    type_spec = get_typespec(.type_spec, size, dst_ptr);
    .bitsize = .size;

    ! type_spec -> type specification field for this array type

    ! If old format array spec, get info from descriptor

    IF .type_spec[dst$b_ts_kind] EQL dst$k_ts_dsc
    THEN
	BEGIN
	val_ptr = type_spec[dst$a_ts_dsc_vspec_addr];
	dbg$sta_valspec(.val_ptr, val_vect, valkind);
	IF .valkind NEQ dbg$k_val_descr
	THEN
	    SIGNAL(dbg$_debugbug, 1, dbg$k_wrong_val_kind);
	desc_ptr = .val_vect[0];
	dbg$read_access(.desc_ptr, 12);
	.dscaddr = .desc_ptr;
	.celltype = typeid_for_atomic(.desc_ptr[dsc$b_dtype],
		dtype_to_bitsize(.desc_ptr[dsc$b_dtype]),TRUE);
	.ndims = .desc_ptr[dsc$b_dimct];
	subscr_vect = dbg$get_tempmem(..ndims);
	.dimvecptr = .subscr_vect;
	INCR i FROM 0 TO ..ndims - 1
	DO
	    subscr_vect[.i] = 0;
	END
    ELSE
	IF .type_spec[dst$b_ts_kind] EQL dst$k_ts_array
	THEN
	! New format type specification for this array.
	    BEGIN
	    LOCAL
		flags_ptr : REF BITVECTOR;
	    .ndims = .type_spec[dst$b_ts_array_dim];
	    flags_ptr = type_spec[dst$a_ts_array_flags_addr];

	    ! flags_ptr -> bitvector of optional type-spec indicators

	    val_ptr = .flags_ptr + (..ndims/8) + 1;
	    dbg$sta_valspec(.val_ptr, val_vect, valkind);
	    IF .valkind NEQ dbg$k_val_descr
	    THEN
		SIGNAL(dbg$_debugbug, 1, dbg$k_wrong_val_kind);
	    desc_ptr = .val_vect[0];
	    .dscaddr = .desc_ptr;
	    type_spec1 = .val_ptr +
			(IF .val_ptr[dst$b_vs_vflags] EQL dst$k_vs_follows
			THEN (.val_ptr[dst$w_vs_length]+3)
			ELSE 5 );

	    ! type_spec1 -> first optional type spec within this record.
	    ! type_spec1 will move along through the optional type specs.

	    IF .flags_ptr[0]
	    THEN
		BEGIN
		! Optional cell type is present.
		.celltype = find_typrec_from_tspec(.type_spec1);
		type_spec1 = .type_spec1 + 2 + .type_spec1[dst$w_ts_length];
		END
	    ELSE
		BEGIN
		LOCAL data_type,bits_used;
		! no optional cell type; use cell type from descriptor.
		dbg$read_access(.desc_ptr, 12);
		data_type = .desc_ptr[dsc$b_dtype];
		bits_used = dtype_to_bitsize(.data_type);
		IF .bits_used NEQ 0
			AND
		.desc_ptr[dsc$b_scale] EQL 0
			AND
		.desc_ptr[dsc$b_digits] EQL 0
		THEN
		    .celltype = typeid_for_atomic(.data_type,.bits_used,TRUE)
		ELSE
		    .celltype = typeid_for_descr(.desc_ptr,rst$k_type_descr,TRUE);
		END;

	    ! Now build dimvecptr. Each element receives either a typeid or
	    ! zero, depending on the appropriate bit in the flags vector.

	    subscr_vect = dbg$get_tempmem(..ndims);
	    .dimvecptr = .subscr_vect;
	    INCR i FROM 1 TO ..ndims
	    DO
		IF .flags_ptr[.i]
		THEN
		    BEGIN
		    ! Optional subscript type exists; type_spec1 points to it.
		    subscr_vect[.i - 1] = find_typrec_from_tspec(.type_spec1);
		    type_spec1 = .type_spec1 + 2 + .type_spec1[dst$w_ts_length];
		    END
		ELSE
		    subscr_vect[.i-1] = 0;
	END;

    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_TYP_ATOMIC(TYPEID, TYPECODE, BITSIZE): NOVALUE =
!
! FUNCTION
!	This routine returns the VAX standard type code ("one-byte type code")
!	and the bit length for a specified atomic data type.
!
! INPUTS
!	TYPEID	- The Type ID of an Atomic data type whose VAX standard type
!		  code is to be returned.  This data type must have the Format
!		  Code RST$K_TYPE_ATOMIC.
!
!	TYPECODE - The address of a longword location to receive the type code.
!
!	BITSIZE	 - The address of a longword location to receive the bit length
!		   of an item of this type.
!
! OUTPUTS
!	TYPECODE - The VAX standard type code for the specified data type is
!		  returned to TYPECODE.
!
!	BITSIZE	 - The bit length is returned to BITSIZE.
!
!	No value is returned.
!

BEGIN
	MAP
		typeid : REF rst$entry;
	LOCAL
		fcode,
		size,
		dst_ptr : REF dst$record,
		type_spec : REF dst$type_spec,
		type_ptr : REF rst$entry;

	type_ptr = find_type_record(.typeid, fcode, size);
	IF .fcode NEQ rst$k_type_atomic
	THEN
		SIGNAL(dbg$_debugbug, 1, dbg$k_wrong_typecode);
	dst_ptr = .type_ptr[rst$l_dstptr];
	type_spec = dst_ptr[dst$a_typspec_ts_addr] +
			.dst_ptr[dst$b_typspec_name];
	.typecode = .type_spec[dst$b_ts_atom_typ];
	.bitsize = .size;

	RETURN;
END;


GLOBAL ROUTINE DBG$STA_TYP_DESCR(TYPEID, DSCADDR): NOVALUE =
!
! FUNCTION
!	This routine returns the address of a VAX standard descriptor for a
!	specified descriptor-defined data type.
!
! INPUTS
!	TYPEID	- The Type ID of the data type whose descriptor is to be
!		  returned.  Its Format Code must be RST$K_TYPE_DESCR.
!
!	DSCADDR	- The address of a longword location to receive the descriptor
!		  address.
!
! OUTPUTS
!	DSCADDR	- A pointer to the data type's VAX standard descriptor is
!		  returned to DSCADDR.  This descriptor may not survive past
!		  the end of the current command.
!
!	No value is returned.
!

BEGIN
	MAP
		typeid : REF rst$entry;
	LOCAL
		size,
		fcode,
		dsc_ptr,
		type_spec : REF dst$type_spec,
		dst_ptr : REF dst$record,
		type_ptr : REF rst$entry,
		valkind,
		val_vect : VECTOR[3],
		val_ptr : REF dst$val_spec;

	type_ptr = find_type_record(.typeid, fcode, size);
	IF .fcode NEQ rst$k_type_descr
	THEN
		SIGNAL(dbg$_debugbug, 1, dbg$k_wrong_typecode);
	dst_ptr = .type_ptr[rst$l_dstptr];
	type_spec = dst_ptr[dst$a_typspec_ts_addr] +
				.dst_ptr[dst$b_typspec_name];
	type_spec = get_typespec(.type_spec, size, dst_ptr);
	val_ptr = type_spec[dst$a_ts_dsc_vspec_addr];
	dbg$sta_valspec(.val_ptr, val_vect, valkind);
	IF .valkind NEQ dbg$k_val_descr
	THEN
		SIGNAL(dbg$_debugbug, 1, dbg$k_wrong_val_kind);
	.dscaddr = .val_vect[0];
	RETURN;
END;


GLOBAL ROUTINE DBG$STA_TYP_ENUM(TYPEID, NELTS, ELTVECPTR, BITSIZE): NOVALUE =
!
! FUNCTION
!	This routine returns information about a specified enumeration type.
!	The type is identified by a Type ID, and the returned information
!	includes the number of enumeration elements, a vector of SYMIDs
!	for all the elements, and the bit length of an element of this type.
!	(Each "element" is a constant of the enumeration type in this terminology.)
!
! INPUTS
!	TYPEID	- The Type ID of the Enumeration type whose information is to
!		  be returned.  Its Format Code must be RST$K_TYPE_ENUM.
!
!	NELTS	- The address of a longword location to receive the number of
!		  constants there are of the enumeration type.
!
!	ELTVECPTR - The address of a longword location to receive a pointer to
!		  a vector of SYMIDs for the enumeration type elements.
!
!	BITSIZE	- The address of a longword location to receive the bit length of
!		  an item of this type.
!
! OUTPUTS
!	NELTS	- The number of enumeration type "elements" (i.e., the number of
!		  distinct values of the type) is returned to NELTS.
!
!	ELTVECPTR - A pointer to a vector of SYMIDs for the enumeration type
!		  elements is returned to ELTVECPTR.  The elements are stored
!		  in order of their values.  Each element's SYMID can then be
!		  used to extract the element's name and value.  This vector
!		  disappears at the end of the current Debug command.
!
!	BITSIZE	- The bit length is returned to BITSIZE.
!
!	No value is returned.
!

BEGIN
	MAP
		typeid : REF rst$entry;

	LOCAL
		type_ptr : REF rst$entry,
		fcode;

	type_ptr = find_type_record(.typeid, fcode, .bitsize);
	IF .fcode NEQ rst$k_type_enum
	THEN
		SIGNAL(dbg$_debugbug, 1, dbg$k_wrong_typecode);
	.nelts = .type_ptr[rst$l_typcompcnt];
	.eltvecptr = type_ptr[rst$a_typcomplst];
	RETURN;
		
END;

GLOBAL ROUTINE DBG$STA_TYP_PICT(TYPEID, LANGCODE, PICTPTR, PICTVAL, PSCALE): NOVALUE =
!
! FUNCTION
!	This routine returns information about a Picture data type (as used in
!	Cobol and PL/I).  The input data type is represented by a Type ID, and
!	the picture's language code and picture string are returned as output.
!
! INPUTS
!	TYPEID	- The Type ID of the Picture data type whose information is to
!		  be returned.  Its Format Code must be RST$K_TYPE_PICT.
!
!	LANGCODE - The address of a longword location to receive the language
!		  code.
!
!	PICTPTR	- The address of a longword location to receive a pointer to the
!		  picture itself.
!
!	PICTVAL	- The address of a longword location to receive a pointer to the
!		  language-specific picture encoding.
!
!	PSCALE	- (Optional) The address of a longword to receive the
!		   scale factor and digit-count for this picture.
! OUTPUTS
!	LANGCODE - The picture language code is returned to LANGCODE.
!
!	PICTPTR	- A pointer to the picture itself, represented as a Counted
!		  ASCII string, is returned to PICTPTR.
!
!	PICTVAL	- A pointer to the language-specific picture encoding is returned
!		  to PICTVAL; if no such encoding exists, zero is returned.
!
!	No value is returned.
!

BEGIN
	BUILTIN ACTUALCOUNT;

	MAP	typeid : REF rst$entry;

	LOCAL
		type_ptr : REF rst$entry,
		fcode,
		dst_ptr : REF dst$record,
		size,
		val_vect : VECTOR[3],
		type_spec : REF dst$type_spec;

	type_ptr = find_type_record(.typeid, fcode, size);
	IF .fcode NEQ rst$k_type_pict
	THEN
		SIGNAL(dbg$_debugbug, 1, dbg$k_wrong_typecode);
	dst_ptr = .type_ptr[rst$l_dstptr];
	type_spec = dst_ptr[dst$a_typspec_ts_addr] +
			.dst_ptr[dst$b_typspec_name];
	type_spec = get_typespec(.type_spec, size, dst_ptr);
	.langcode = .type_spec[dst$b_ts_pic_lang];
	.pictptr = type_spec[dst$a_ts_pic_addr];
	IF .type_spec[dst$w_ts_length] GTR .type_spec[dst$b_ts_pic_pleng] + 3
	THEN
		BEGIN
		LOCAL
			val_spec,
			valkind;
		val_spec = ..pictptr + .type_spec[dst$b_ts_pic_pleng];
		dbg$sta_valspec(.val_spec, val_vect, valkind);
		.pictval = .val_vect[0];
		IF (..langcode EQL dbg$k_cobol) AND actualcount() GTR 4
		THEN
		    .pscale=.(.type_spec+.type_spec[dst$w_ts_length])<0,16,0>;
	END
	ELSE
		.pictval = 0;

	RETURN;

END;

GLOBAL ROUTINE DBG$STA_TYP_TYPEDPTR(TYPEID, REFTYPEID): NOVALUE =
!
! FUNCTION
!	This routine accepts as input the Type ID of a Typed Pointer data type
!	and returns the Type ID of the data type it points to.
!
! INPUTS
!	TYPEID	- The Type ID of the Typed Pointer type whose referenced type
!		  is to be returned.  Its Format Code must be RST$K_TYPE_PTR.
!
!	REFTYPEID - The address of a longword location to receive the pointed-to
!		  data type's Type ID.
!
! OUTPUTS
!	REFTYPEID - The Type ID of the data type which is pointed to by the
!		  TYPEID Typed Pointer type is returned to REFTYPEID.
!
!	No value is returned.
!

BEGIN
	MAP
		typeid : REF rst$entry;

	LOCAL
		fcode,
		type_ptr : REF rst$entry,
		size,
		dst_ptr : REF dst$record,
		type_spec : REF dst$type_spec;

	type_ptr = find_type_record(.typeid, fcode, size);
	IF .fcode NEQ rst$k_type_tptr
	THEN
		SIGNAL(dbg$_debugbug, 1, dbg$k_wrong_typecode);
	dst_ptr = .type_ptr[rst$l_dstptr];
	type_spec = dst_ptr[dst$a_typspec_ts_addr] +
			.dst_ptr[dst$b_typspec_name];
	type_spec = get_typespec(.type_spec, size, dst_ptr);
	type_spec = type_spec[dst$a_ts_tptr_tspec_addr];
	.reftypeid = find_typrec_from_tspec(.type_spec);
	RETURN;

END;

GLOBAL ROUTINE DBG$STA_TYP_FILE(TYPEID, LANGUAGE, RECTYPEID): NOVALUE =
!
! FUNCTION
!	This routine accepts as input the Type ID of a File data type
!	and returns the associated language code and record-type typeid.
!
! INPUTS
!	TYPEID	- The Type ID of the File type.
!		  Its Format Code must be RST$K_TYPE_FILE.
!
!	LANGUAGE - The address of a longword location to receive the File
!		  type's LANGUAGE code.
!
!	RECTYPEID - The address of a longword location to receive
!		    the typeid for the File's record type.
!
! OUTPUTS
!	LANGUAGE - The File type's language code.
!
!	RECTYPEID - The File's record-type typeid is returned to RECTYPEID.
!
!	No value is returned.
!

BEGIN
	MAP
		typeid : REF rst$entry;

	LOCAL
		dst_ptr : REF dst$record,
		type_spec : REF dst$type_spec,
		type_ptr : REF rst$entry,
		size,
		fcode;

	type_ptr = find_type_record(.typeid, fcode, size);
	IF .fcode NEQ rst$k_type_file
	THEN
		SIGNAL(dbg$_debugbug, 1, dbg$k_wrong_typecode);
	dst_ptr = .type_ptr[rst$l_dstptr];
	type_spec = dst_ptr[dst$a_typspec_ts_addr] +
			.dst_ptr[dst$b_typspec_name];
	type_spec = get_typespec(.type_spec, size, dst_ptr);
	.language = .type_spec[dst$b_ts_file_lang];
	IF .type_spec[dst$w_ts_length] GTR 2
	THEN
		BEGIN
		type_spec = type_spec[dst$a_ts_file_rcrd_typ];
		.rectypeid = find_typrec_from_tspec(.type_spec);
	END
	ELSE
		.rectypeid = 0;

	RETURN;
END;

GLOBAL ROUTINE DBG$STA_TYP_RECORD(TYPEID, NCOMPS, COMPVECPTR, BITSIZE): NOVALUE =
!
! FUNCTION
!	This routine accepts as input a Type ID for a record (or "structure")
!	data type, and returns the number of record components, a vector of
!	record component SYMIDs, and the bit length of the record as output.
!	The record component SYMIDs can then be used as input to other symbol
!	table access routines to extract the component names, types, and values.
!
! INPUTS
!	TYPEID	- The Type ID of the Record data type whose component informa-
!		  tion is to be returned.  The Format Code of this data type
!		  must be RST$K_TYPE_RECORD.
!
!	NCOMPS	- The address of a longword location to receive the number of
!		  record components associated with the specified data type.
!
!	COMPVECPTR - The address of a longword location to receive a pointer to
!		  a vector of component information.
!
!	BITSIZE	- The address of a longword location to receive the bit length
!		  of the record.
!
! OUTPUTS
!	NCOMPS	- The number of record components is returned to NCOMPS.
!
!	COMPVECPTR - A pointer to a vector of record component SYMIDs is re-
!		  turned to COMPVECPTR.  There is one SYMID for each record
!		  component in the vector; this SYMID can then be used to
!		  extract the component's data type, name, or value (offset
!		  from the start of the record).  This vector disappears at
!		  the end of the current Debug command.
!
!	BITSIZE	- The record's bit length is returned to BITSIZE.
!
!	No value is returned.
!

BEGIN

	MAP
		typeid : REF rst$entry;
	LOCAL
		type_ptr : REF rst$entry,
		fcode;

	type_ptr = find_type_record(.typeid, fcode, .bitsize);
	IF .fcode NEQ rst$k_type_record
	THEN
		SIGNAL(dbg$_debugbug, 1, dbg$k_wrong_typecode);
	.ncomps = .type_ptr[rst$l_typcompcnt];
	.compvecptr = type_ptr[rst$a_typcomplst];
	RETURN;

END;

GLOBAL ROUTINE DBG$STA_TYP_SET(TYPEID, PARENT_TYPE, BITSIZE): NOVALUE =
!
! FUNCTION
!	This routine accepts as input the Type ID of a Set data type (as in
!	Pascal, for example), and returns the set's length and parent data
!	type as output.  A set is always assumed to consist of a bit string
!	where each bit represents one member of the parent type.  The parent
!	data type, i.e. the data type of the set elements, can be any ordinal
!	type (such as integer, enumeration type, character, etc.).
!
! INPUTS
!	TYPEID	- The Type ID of the Set type whose attributes are to be
!		  returned.  Its Format Code must be RST$K_TYPE_SET.
!
!	PARENT_TYPE - The address of a longword location to receive the Type ID
!		  of the set's parent type.
!
!	BITSIZE	- The address of a longword location to receive the length of
!		  the set.
!
! OUTPUTS
!	PARENT_TYPE - The Type ID of the set's parent type (i.e., the data type
!		  of the set elements) is returned to PARENT_TYPE.
!
!	BITSIZE	- The length of the set type (in bits used to represent the
!		  set) is returned to BITSIZE.
!
!	No value is returned.
!

BEGIN
	MAP
		typeid : REF rst$entry;
	LOCAL
		fcode,
		type_ptr : REF rst$entry,
		dst_ptr : REF dst$record,
		size,
		type_spec : REF dst$type_spec;

	type_ptr = find_type_record(.typeid, fcode, size);
	IF .fcode NEQ rst$k_type_set
	THEN
		SIGNAL(dbg$_debugbug, 1, dbg$k_wrong_typecode);
	dst_ptr = .type_ptr[rst$l_dstptr];
	type_spec = dst_ptr[dst$a_typspec_ts_addr] +
				.dst_ptr[dst$b_typspec_name];
	type_spec = get_typespec(.type_spec, size, dst_ptr);
	type_spec = type_spec[dst$a_ts_set_par_tspec_addr];
	.parent_type = find_typrec_from_tspec(.type_spec);
	.bitsize = .size;
	RETURN;

END;

GLOBAL ROUTINE DBG$STA_TYP_SUBRNG(TYPEID, PARENT_TYPE, LOWPTR, HIGHPTR,
						BITSIZE): NOVALUE =
!
! FUNCTION
!	This routine accepts the Type ID of a Subrange data type (as in Pascal,
!	for instance) as input, and returns that type's parent type, subrange
!	interval, and bit length.  The parent type can be any data type with
!	values of reasonable size (e.g., anything that can be represented as an
!	integer or real	value), and the subrange interval is returned as
!	pointers to the lower bound value and the upper bound value.  Both
!	values are assumed to be of the parent type.
!
! INPUTS
!	TYPEID	- The Type ID of the Subrange data type whose attributes are to
!		  be returned.  Its Format Code must be RST$K_TYPE_SUBRNG.
!
!	PARENT_TYPE - The address of a longword location to receive the returned
!		  Type ID of subrange's parent type.
!
!	LOWPTR	- The address of a longword location to receive a pointer to the
!		  lower bound value of the subrange.
!
!	HIGHPTR	- The address of a longword location to receive a pointer to the
!		  upper bound value of the subrange.
!
!	BITSIZE	- The address of a longword location to receive the length in bits
!		  of an item of this type.
!
! OUTPUTS
!	PARENT_TYPE - The Type ID of the subrange's parent type (i.e., the data
!		  type of which this is a subrange) is returned to PARENT_TYPE.
!
!	LOWPTR	- A pointer to the lower bound value of the subrange is returned
!		  to LOWPTR.  This value must be interpreted as being of the
!		  parent type.  The value disappears at the end of the current
!		  Debug command.
!
!	HIGHPTR	- A pointer to the upper bound value of the subrange is returned
!		  to HIGHPTR.  This value must be intepreted as being of the
!		  parent type.  The value disappears at the end of the current
!		  Debug command.
!
!	BITSIZE	- The length in bits is returned to BITSIZE.
!
!	No value is returned.
!

    BEGIN

	MAP
		typeid : REF rst$entry;
	LOCAL
		size,
		type_ptr : REF rst$entry,
		type_spec : REF dst$type_spec,
		val_ptr : REF dst$val_spec,
		dst_ptr : REF dst$record,
		val_vect : VECTOR[3],
		valkind,
		fcode;

	type_ptr = find_type_record(.typeid, fcode, size);
	IF .fcode NEQ rst$k_type_subrng
	THEN
		SIGNAL(dbg$_debugbug, 1, dbg$k_wrong_typecode);

	dst_ptr = .type_ptr[rst$l_dstptr];
	type_spec = dst_ptr[dst$a_typspec_ts_addr] +
				.dst_ptr[dst$b_typspec_name];
	type_spec = get_typespec(.type_spec, size, dst_ptr);
	type_spec = type_spec[dst$a_ts_subr_par_tspec_addr];
	.parent_type = find_typrec_from_tspec(.type_spec);
	val_ptr = .type_spec + .type_spec[dst$w_ts_length] + 2;
	dbg$sta_valspec(.val_ptr, val_vect, valkind);
	.lowptr = .val_vect[0];
	val_ptr = .val_ptr + 
			(IF .val_ptr[dst$b_vs_vflags] EQL dst$k_vs_follows
				THEN (.val_ptr[dst$w_vs_length]+3)
				ELSE 5 );
	dbg$sta_valspec(.val_ptr, val_vect, valkind);
	.highptr = .val_vect[0];
	.bitsize = .size;

	RETURN;

    END;

GLOBAL ROUTINE DBG$STA_TYP_SUBSET(TYPEID, PARENT_TYPE, NBNDS, BNDVECPTR,
						BITSIZE): NOVALUE =
!
! FUNCTION
!	This routine accepts the Type ID of a Subset data type (as found in ADA,
!	for instance) as input, and returns the subset's parent type, the number
!	of subset ranges, and the lower and upper bounds for each such range.
!	The parent type can be any data type of reasonable size, including all
!	types that can be represented by integers or floating-point numbers of
!	various precisions.  The subset type then consists of a set of non-con-
!	tiguous ranges of parent type values, where each range is defined by a
!	lower and upper bound pair.
!
! INPUTS
!	TYPEID	- The Type ID of the Subset data type whose attributes are to be
!		  returned.  Its Format Code must be RST$K_TYPE_SUBSET.
!
!	PARENT_TYPE - The address of a longword location to receive the Type ID
!		  of the subset type's parent type.
!
!	NBNDS	- The address of a longword location to receive the number of
!		  bound pairs (number of ranges) associated with the data type.
!
!	BNDVECPTR - The address of a longword location to receive a pointer to a
!		  vector of lower and upper bound pointer pairs.
!
!	BITSIZE	- The address of a longword location to receive the length in bits
!		  of an item of this type.
!
! OUTPUTS
!	PARENT_TYPE - The Type ID of the subset type's parent type is returned
!		  to PARENT_TYPE.  The parent type is the data type of the ele-
!		  ments of the subset.
!
!	NBNDS	- The number of ranges (lower and upper bound pairs) that make
!		  up the subset type is returned to NBNDS.
!
!	BNDVECPTR - A pointer to a vector of bound pairs for the subset ranges
!		  is returned to BNDVECPTR.  There is one two-longword entry
!		  in the vector for each range in the subset; the two longwords
!		  contain a pointer to the lower bound value and a pointer to
!		  the upper bound value, respectively, of the range.  The values
!		  pointed to by these pointers should be interpreted as values
!		  of the parent type.  This vector disappears at the end of the
!		  current Debug command.
!
!	BITSIZE	- The length in bits is returned to BITSIZE.
!
!	No value is returned.
!

BEGIN

	MAP
		typeid : REF rst$entry;
	LOCAL
		size,
		type_ptr : REF rst$entry,
		type_spec : REF dst$type_spec,
		val_ptr : REF dst$val_spec,
		dst_ptr : REF dst$record,
		subr_list : REF VECTOR[],
		valkind,
		val_vect : VECTOR[3],
		fcode;

	type_ptr = find_type_record(.typeid, fcode, size);
	IF .fcode NEQ rst$k_type_subset
	THEN
		SIGNAL(dbg$_debugbug, 1, dbg$k_wrong_typecode);

	dst_ptr = .type_ptr[rst$l_dstptr];
	type_spec = dst_ptr[dst$a_typspec_ts_addr] +
				.dst_ptr[dst$b_typspec_name];
	type_spec = get_typespec(.type_spec, size, dst_ptr);
	.nbnds = .type_spec[dst$w_ts_subs_num_subrs];
	IF .size NEQ 0
	THEN
		.bitsize = .size
	ELSE
		.bitsize = .type_spec[dst$l_ts_subs_leng];
	type_spec = type_spec[dst$a_ts_subs_par_tspec_addr];
	.parent_type = find_typrec_from_tspec(.type_spec);
	subr_list = dbg$get_tempmem(..nbnds * 2);
	.bndvecptr = .subr_list;
	val_ptr = .type_spec + .type_spec[dst$w_ts_length] + 2;
	INCR i FROM 0 TO ..nbnds - 1
	DO
		BEGIN
		dbg$sta_valspec(.val_ptr, val_vect, valkind);
		subr_list[2*(.i)] = .val_vect[0];
		val_ptr = .val_ptr + 
			(IF .val_ptr[dst$b_vs_vflags] EQL dst$k_vs_follows
				THEN (.val_ptr[dst$w_vs_length]+3)
				ELSE 5 );
		dbg$sta_valspec(.val_ptr, val_vect, valkind);
		subr_list[(2*(.i)+1)] = .val_vect[0];
	END;

	RETURN;

END;

GLOBAL ROUTINE DBG$STA_TYP_UNION(TYPEID, NCOMPS, COMPVECPTR,
						BITSIZE): NOVALUE =
!
! FUNCTION
!	This routine accepts as input the Type ID of a Union data type (Pascal
!	variants without tag fields, for example), and it returns the number of
!	union components and the SYMID of each such component.  A union can be
!	viewed as a record ("structure") where all the components occupy the
!	same space; consequently this routine is very similar to the routine
!	which returns Record type information.
!
! INPUTS
!	TYPEID	- The Type ID of the Union data type whose attributes are to be
!		  returned.  Its Format Code must be RST$K_TYPE_UNION.
!
!	NCOMPS	- The address of a longword location to receive the number of
!		  components (members) of the union type.
!
!	COMPVECPTR - The address of a longword location to receive a pointer to
!		  a vector of SYMIDs for the union components (members).
!
!	BITSIZE	- The address of a longword location to receive the length in bits
!		  of an item of this type.
!
! OUTPUTS
!	NCOMPS	- The number of components in the TYPEID union data type is
!		  returned to NCOMPS.
!
!	COMPVECPTR - A pointer to a vector of union component SYMIDs is re-
!		  turned to COMPVECPTR.  These SYMIDs can then be used to
!		  extract each component's name and data type.  This vector
!		  disappears at the end of the current Debug command.
!
!	BITSIZE	- The length in bits is returned to BITSIZE.
!
!	No value is returned.
!

    BEGIN

    LOCAL
	XXXXXXX;			!<<--------- Local declarations --------



    ! The text of the routine starts here.
    !
    !<<-------------------------- FIRST LINE OF CODE ---------------------------
    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_TYP_OFFSET(TYPEID, AREA_ADDR, AREA_LEN): NOVALUE =
!
! FUNCTION
!	This routine accepts as input the Type ID of an Offset data type and
!	it returns the address and length of the associated Area.  Areas and
!	Offsets are PL/I data types.
!
! INPUTS
!	TYPEID	- The Type ID of the Offset data type whose attributes are to be
!		  returned.  Its Format Code must be RST$K_TYPE_OFFSET.
!
!	AREA_ADDR - The address of a longword location to receive the byte
!		  address of the Area associated with this Offset.
!
!	AREA_LEN - The address of a longword location to receive the byte
!		  length of the Area associated with this Offset.
!
! OUTPUTS
!	AREA_ADDR - The byte address of the Area associated with this Offset
!		  is returned to AREA_ADDR.
!
!	AREA_LEN - The byte length of the Area associated with this Offset
!		  is returned to AREA_LEN.
!
!	No routine value is returned.
!

    BEGIN

    MAP
	TYPEID: REF RST$ENTRY,		! Pointer to the input Type RST Entry
	AREA_ADDR: REF VECTOR[1],	! Address where we return Area address
	AREA_LEN: REF VECTOR[1];	! Address where we return Area length

    LOCAL
	DSTPTR: REF DST$RECORD,		! Pointer to Offset Type Spec DST record
	FCODE,				! The Format Code for this data type
	SIZE,				! The bit size of this data object
	TSPTR: REF DST$TYPE_SPEC,	! Pointer to DST Type Spec for Offset
	TYPEPTR: REF RST$ENTRY,		! Pointer to the offset Type RST Entry
	VALKIND,			! The kind of value returned by the
					!      DBG$STA_VALSPEC routine
	VALPTR: REF VECTOR[,LONG],	! Pointer to the Area length value
	VALVECTOR: VECTOR[3,LONG],	! Three-longword value vector returned
					!      by the DBG$STA_VALSPEC routine
	VSPTR: REF DST$VAL_SPEC;	! Pointer to Value Specs in the DST Type
					!      Spec for Offset



    ! In case the caller passed in a SYMID for the Offset symbol instead of its
    ! Type ID, we get the symbol's actual Type ID here.  We also make sure we
    ! really have an Offset data type.
    !
    TYPEPTR = FIND_TYPE_RECORD(.TYPEID, FCODE, SIZE);
    IF .FCODE NEQ RST$K_TYPE_OFFSET
    THEN
	SIGNAL(DBG$_DEBUGBUG, 1, DBG$K_WRONG_TYPECODE);


    ! Get a pointer to the Type Spec DST Record and get a pointer to the actual
    ! Type Spec within it (possibly after Type Spec indirection).
    !
    DSTPTR = .TYPEPTR[RST$L_DSTPTR];
    TSPTR = DSTPTR[DST$A_TYPSPEC_TS_ADDR] + .DSTPTR[DST$B_TYPSPEC_NAME];
    TSPTR = GET_TYPESPEC(.TSPTR, SIZE, DSTPTR);


    ! Evaluate the first Value Spec in the Offset Type Spec.  Return the result
    ! (i.e., the address of the Area) to the AREA_ADDR parameter.
    !
    VSPTR = TSPTR[DST$A_TS_OFFSET_VALSPEC];
    DBG$STA_VALSPEC(.VSPTR, VALVECTOR, VALKIND);
    AREA_ADDR[0] = .VALVECTOR[0];


    ! Get to the second Value Spec in the Offset Type Spec and evaluate it.
    ! Return its result (i.e., the length of the Area) to AREA_LEN.
    !
    IF .VSPTR[DST$B_VS_VFLAGS] EQL DST$K_VS_FOLLOWS
    THEN
	VSPTR = VSPTR[DST$B_VS_ALLOC] + .VSPTR[DST$W_VS_LENGTH]

    ELSE
	VSPTR = .VSPTR + 5;

    DBG$STA_VALSPEC(.VSPTR, VALVECTOR, VALKIND);
    VALPTR = .VALVECTOR[0];
    AREA_LEN[0] = .VALPTR[0];


    ! We are all done--return to the caller.
    !
    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_TYP_AREA(TYPEID, BYTE_LEN): NOVALUE =
!
! FUNCTION
!	This routine accepts as input the Type ID of an AREA data type
!	and returns the byte length of the AREA.
!
! INPUTS
!	TYPEID	- The Type ID of the AREA data type whose attributes are to be
!		  returned.  Its Format Code must be RST$K_TYPE_AREA.
!
!	BYTE_LEN - The address of a longword location to receive a pointer
!		  to the byte length of the AREA.
!
! OUTPUTS
!	BYTE_LEN - A pointer to the byte length of the AREA is returned to
!		    BYTE_LEN
!
!
!	No value is returned.
!

BEGIN
	MAP
		typeid : REF rst$entry;

	LOCAL
		type_ptr : REF rst$entry,
		dst_ptr : REF dst$record,
		type_spec : REF dst$type_spec,
		val_spec : REF dst$val_spec,
		valkind,
		fcode,
		val_vect : VECTOR[3],
		size;

	type_ptr = find_type_record(.typeid, fcode, size);
	IF .fcode NEQ rst$k_type_area
	THEN
		SIGNAL(dbg$_debugbug, 1, dbg$k_wrong_typecode);

	dst_ptr = .type_ptr[rst$l_dstptr];
	type_spec = dst_ptr[dst$a_typspec_ts_addr] +
				.dst_ptr[dst$b_typspec_name];
	type_spec = get_typespec(.type_spec, size, dst_ptr);
	IF .size EQL 0
	THEN
		BEGIN
		val_spec = type_spec[dst$a_ts_area_byte_len];
		dbg$sta_valspec(.val_spec, val_vect, valkind);
		.byte_len = .val_vect[0];
	END
	ELSE
		.byte_len = .size;

	RETURN;

END;

GLOBAL ROUTINE DBG$STA_TYP_VARIANT(TYPEID, NCOMPS, COMPVECPTR, TAG,
						BITSIZE): NOVALUE =
!
! FUNCTION
!	This routine accepts as input the Type ID of a Variant data type or the
!	SYMID of a symbol of variant type, and it returns the number of variant
!	components, the SYMID of each such component, and the SYMID of the vari-
!	ant's tag field.
!
! INPUTS
!	TYPEID	- The Type ID of the Variant data type whose attributes and var-
!		  iants are to be returned.  The Kind of this data type
!		  must be RST$K_VARIANT.
!
!	NCOMPS	- The address of a longword location to receive the number of
!		  variant components of the TYPEID data type.
!
!	COMPVECPTR - The address of a longword location to receive a pointer to
!		  a vector of variant component SYMIDs and tag values.
!
!	TAG	- The address of a longword location to receive the SYMID of the
!		  Variant data type's tag field.
!
!	BITSIZE	- The address of a longword location to receive the size in bits
!		  of an item of this type.
!
! OUTPUTS
!	NCOMPS	- The number of components of the Variant data type (the number
!		  of different "variants") is returned to NCOMPS.
!
!	COMPVECPTR - A pointer to a vector of variant component information is
!		  returned to COMPVECPTR.  In this vector, there is a two-long-
!		  word entry for each variant component; each such entry gives
!		  the SYMID and a pointer to the tag value, respectively, of
!		  the corresponding component.  The SYMID can then be used to
!		  extract the component's name, data type, and value.  The tag
!		  value must be intepreted as a value of tag field's data type.
!		  This vector disappears at the end of the current command.
!
!	TAG	- The SYMID of the variant tag field is returned to TAG.  This
!		  SYMID can be used to extract the tag field name, data type,
!		  and value.
!
!	BITSIZE	- The size in bits of an item of this type is returned to
!		  BITSIZE.
!
!	No value is returned.
!

BEGIN
	MAP
		typeid : REF rst$entry;

	LOCAL
		type_ptr : REF rst$entry,
		fcode,
		size,
		var_ptr : REF dst$varbeg_trailer,
		type_spec : REF dst$type_spec;

	type_ptr = find_type_record(.typeid, fcode, size);
	IF .fcode NEQ rst$k_variant
	THEN
		SIGNAL(dbg$_debugbug, 1, dbg$k_wrong_typecode);
	.ncomps = .type_ptr[rst$l_varsetcnt];
	.compvecptr = type_ptr[rst$a_varsettbl];
	.tag = .type_ptr[rst$l_vartagptr];
	var_ptr = (.type_ptr[rst$l_dstptr]) + 2;
	.bitsize = .var_ptr[dst$l_varbeg_size];

	RETURN;

END;

GLOBAL ROUTINE dbg$sta_typ_variant_comp( list_id, ncomps, compvecptr,
					ntags, tagvecptr, size ) : NOVALUE =
!
! FUNCTION
!	This routine accepts as input a pointer to a set of Variant fields,
!	and it returns the number of fields, the SYMID for each field, the number
!	of tag blocks, a value range for each tag block, and the bit length of
!	the variant.
!
! INPUTS
!	LIST_ID	- A pointer to a list of variant fields; this list was produced
!		  by DBG$STA_TYP_VARIANT and was pointed to by one element of
!		  the COMPVECPTR it returned.
!
!	NCOMPS	- The address of a longword location to receive the number of
!		  fields in this variant.
!
!	COMPVECPTR - The address of a longword location to receive a pointer to
!		  a vector of field SYMIDs.
!
!	NTAGS	- The address of a longword location to receive the number of
!		  tag blocks.
!
!	TAGVECPTR - The address of a longword location to receive a pointer to a
!		    vector of tag value ranges. An element of this vector is the
!		    address of a three longword block; each block has the following
!		    format:
!			longword 1: dst$k_varval_single = single tag value
!						or
!				    dst$k_varval_range = range of tag values
!			longword 2: pointer to low bound value of tag range
!			longword 3: pointer to high bound value of tag range
!				    (or zero if single value)
!
!	SIZE	- The address of a longword location to receive the size in bits
!		  of an item of this type.
!
! OUTPUTS
!	NCOMPS	- The number of fields is returned to NCOMPS.
!
!	COMPVECPTR - A pointer to a vector of field SYMIDs is returned to
!		  COMPVECPTR.
!		  This vector disappears at the end of the current command.
!
!	NTAGS	- The number of tag blocks is returned to NTAGS.
!
!	SIZE	- The size in bits of this variant is returned to SIZE.
!
!	No value is returned.
!
BEGIN
	MAP
		list_id : REF rst$var_entry;
	LOCAL
		tag_list : REF rst$tag_list,
		tag_ptr : REF VECTOR[,BYTE],
		dst_ptr : REF dst$record;

	dst_ptr = .list_id[rst$l_var_dstptr];
	IF .dst_ptr[dst$b_type] NEQ dst$k_varval
	THEN
		SIGNAL(dbg$_debugbug, 1, dbg$k_wrong_typecode);
	.ncomps = .list_id[rst$l_var_compcnt];
	.ntags = .dst_ptr[dst$w_varval_count];
	.size = .dst_ptr[dst$l_varval_size];
	IF ..ncomps NEQ 0
	THEN
		.compvecptr = list_id[rst$a_var_complst]
	ELSE
		.compvecptr = 0;
	tag_list = dbg$get_tempmem(rst$k_tag_block_size * ..ntags);
	tag_ptr = dst_ptr[dst$a_varval_rngspec];
	INCR i FROM 0 TO ..ntags - 1
	DO
		BEGIN
		LOCAL
			value_spec : REF dst$val_spec,
			val_lngth,
			val_vect : VECTOR[3],
			valkind;
		value_spec = tag_ptr[1];
		tag_list[.i,rst$l_tag_numvals] = .tag_ptr[0];
		dbg$sta_valspec(.value_spec, val_vect, valkind);
		tag_list[.i,rst$l_tag_lowbound] = .val_vect[0];
		val_lngth = 5;
		IF .value_spec[dst$b_vs_vflags] EQL dst$k_vs_follows
		THEN
			val_lngth = .value_spec[dst$w_vs_length] + 3;
		IF .tag_ptr[0] EQL dst$k_varval_range
		THEN
			BEGIN
			value_spec = .tag_ptr + .val_lngth + 1;
			dbg$sta_valspec(.value_spec, val_vect, valkind);
			tag_list[.i,rst$l_tag_highbound] = .val_vect[0];
			val_lngth = 5;
			IF .value_spec[dst$b_vs_vflags] EQL dst$k_vs_follows
			THEN
				val_lngth = .value_spec[dst$w_vs_length] + 3;
			tag_ptr = .tag_ptr + .val_lngth;
		END
		ELSE
			tag_ptr = .tag_ptr + .val_lngth + 1;
	END;
	.tagvecptr = .tag_list;

	RETURN;
END;

ROUTINE TYPEID_FOR_ATOMIC(TYPECODE, BITSIZE, DSC_FLAG) =
!
! FUNCTION
!	This routine returns the Type ID associated with a specified VAX stand-
!	ard type code (a "one-byte type code").  The Type ID is a pointer to an
!	RST entry for the data type.  This RST entry is added to the Temporary
!	RST Entry List so that it disappears as soon as there are no longer any
!	references to it.
!
!	The routine builds a Data Type RST Entry and a Type Specification DST
!	record, both in the same memory block.  The RST entry's FCODE is set to
!	be atomic and its DST pointer points to the DST record.  The DST record
!	is built to contain a DST Type Specification for the specified atomic
!	data type.
!
! INPUTS
!	TYPECODE - The VAX standard type code ("one-byte" type code) whose Type
!		  ID is to be returned.
!
!	BITSIZE  - The size in bits of an item of this type.
!
!	DSC_FLAG - A flag which, when set, indicates that we are processing a
!		   descriptor item; thus, we will signal INVALID ARRAY DESC
!		   in certain error situations.
!
! OUTPUTS
!	The corresponding Type ID (Type RST Entry pointer) is returned as the
!		  routine value.
!

    BEGIN

    LOCAL
	DSTPTR: REF DST$RECORD,		! Pointer to the generated DST record
	RSTPTR: REF RST$ENTRY,		! Pointer to the Type RST Entry
	TSPTR: REF DST$TYPE_SPEC;	! Pointer to Type Spec in DST record



    ! Make sure the VAX standard type code is in the valid range.
    !
    IF ((.TYPECODE LSS DSC$K_DTYPE_LOWEST) OR
	(.TYPECODE GTR DSC$K_DTYPE_HIGHEST)) AND
       (.TYPECODE NEQ DST$K_BOOL)
    THEN
	BEGIN
	IF .DSC_FLAG
	THEN
	    SIGNAL(DBG$_INVARRDSC)

	ELSE
	    SIGNAL(DBG$_DEBUGBUG, 1, DBG$K_WRONG_TYPECODE);

	END;


    ! Get a memory block large enough to contain both the RST entry and the
    ! dummy DST record.
    !
    RSTPTR = DBG$GET_MEMORY(RST$K_TYPENTSIZ + 2);
    DSTPTR = .RSTPTR + 4*RST$K_TYPENTSIZ;


    ! Build the Data Type RST Entry for the atomic type.
    !
    RSTPTR[RST$L_DSTPTR] = .DSTPTR;
    RSTPTR[RST$L_UPSCOPEPTR] = .RST$START_ADDR;
    RSTPTR[RST$B_KIND] = RST$K_TYPE;
    RSTPTR[RST$B_FCODE] = RST$K_TYPE_ATOMIC;
    RSTPTR[RST$L_BITSIZE] = .BITSIZE;


    ! Put this Data Type RST Entry on the Temporary RST Entry List.  This will
    ! cause the entry to be released at the end of a DEBUG command when there
    ! are no references to it (when it is not locked).
    !
    RSTPTR[RST$L_HASH_FLINK] = .RST$TEMP_LIST;
    RST$TEMP_LIST = .RSTPTR;


    ! Build the dummy Type Specification DST entry for the atomic type.
    !
    DSTPTR[DST$B_LENGTH] = 6;
    DSTPTR[DST$B_TYPE] = DST$K_TYPSPEC;
    DSTPTR[DST$B_TYPSPEC_NAME] = 0;
    TSPTR = .DSTPTR + 3;
    TSPTR[DST$W_TS_LENGTH] = 2;
    TSPTR[DST$B_TS_KIND] = DST$K_TS_ATOM;
    TSPTR[DST$B_TS_ATOM_TYP] = .TYPECODE;


    ! Return the type's Type ID (Data Type RST Entry address) to the caller.
    !
    RETURN .RSTPTR;

    END;

ROUTINE TYPEID_FOR_COB_HACK(CH_DSTPTR) =
!
! FUNCTION
!	This routine builds an appropriate Data Type RST Entry for the data
!	type of an object described by a Cobol Hack DST Record.  It accepts
!	as input a pointer to the DST record and it builds and returns the
!	address of a Data Type RST Entry for the corresponding type.  The
!	memory block which contains the Type RST Entry also contains a dummy
!	Type Spec DST Record for the data type in question.
!
!	Cobol Hack records are obsolete, but are still found in programs com-
!	piled with the Version 1 COBOL compiler.  This routine therefore con-
!	verts such DST records into more "regular" DST structures so that on-
!	ly this routine needs to understand the obsolete Cobol Hack Record.
!
! INPUTS
!	CH_DSTPTR - A pointer to the Cobol Hack DST Record whose data type is
!		  to be extracted.
!
! OUTPUTS
!	This routine returns as its value a pointer to a Data Type RST Entry
!		  for the data type specified in the Cobol Hack DST Record.
!

    BEGIN

    MAP
	CH_DSTPTR: REF DST$RECORD;	! Pointer to Cobol Hack DST Record

    LOCAL
	BITSIZ,				! The bitsize of an atomic data type
	CH_TRLR_PTR: REF DST$CH_TRLR,	! Pointer to Cobol Hack record trailer
	DESCADDR: REF BLOCK[,BYTE],	! Pointer to VAX standard descriptor
	DSTPTR: REF DST$RECORD,		! Pointer to dummy Type Spec DST Record
					!      built by this routine
	RSTPTR: REF RST$ENTRY,		! Pointer to Type RST Entry built by
					!      by this routine for data item
	TSPTR: REF DST$TYPE_SPEC,	! Pointer to Type Spec in Type Spec DST
					!      record built by this routine
	VSPTR: REF DST$VAL_SPEC;	! Pointer to Value Spec in Type Spec
					!      DST record built by this routine



    ! If the descriptor address in the DST record is zero, this is an atomic
    ! data type defined by the DST$CH_TYPE field.  Build a Type RST Entry for
    ! it and return that entry's address as a TYPEID.
    !
    IF .CH_DSTPTR[DST$L_VALUE] EQL 0
    THEN
	BEGIN
	CH_TRLR_PTR = CH_DSTPTR[DST$A_COBHACK_TRLR] + .CH_DSTPTR[DST$B_NAME];
	BITSIZ = DTYPE_TO_BITSIZE(.CH_TRLR_PTR[DST$B_CH_TYPE]);
	RSTPTR = TYPEID_FOR_ATOMIC(.CH_TRLR_PTR[DST$B_CH_TYPE], .BITSIZ, FALSE);
	RETURN .RSTPTR;
	END;


    ! We have a descriptor-specified data type.  Compute the address of the
    ! descriptor.
    !
    IF .CH_DSTPTR[DST$B_VFLAGS] EQL DST$K_VFLAGS_DSC
    THEN
	DESCADDR = CH_DSTPTR[DST$A_DSC_BASE] + .CH_DSTPTR[DST$L_DSC_OFFS]

    ELSE
	SIGNAL(DBG$_INVDSTREC);


    ! If the descriptor is an array descriptor, we build an Array Type RST Entry
    ! and the corresponding dummy Type Spec DST Record.  We also return the
    ! address of the Type RST Entry as a TYPEID.
    !
    IF (.DESCADDR[DSC$B_CLASS] EQL DSC$K_CLASS_A)   OR
       (.DESCADDR[DSC$B_CLASS] EQL DSC$K_CLASS_NCA) OR
       (.DESCADDR[DSC$B_CLASS] EQL DSC$K_CLASS_UBA) OR
       (.DESCADDR[DSC$B_CLASS] EQL DSC$K_CLASS_VSA)
    THEN
	BEGIN


	! Get a memory block to hold both the Type RST Entry and the Type Spec
	! DST Record for the array.
	!
	RSTPTR = DBG$GET_MEMORY(RST$K_TYPENTSIZ + 4);
	DSTPTR = .RSTPTR + 4*RST$K_TYPENTSIZ;


	! Build the Data Type RST Entry.
	!
	RSTPTR[RST$L_DSTPTR] = .DSTPTR;
	RSTPTR[RST$L_UPSCOPEPTR] = .RST$START_ADDR;
	RSTPTR[RST$B_KIND] = RST$K_TYPE;
	RSTPTR[RST$B_FCODE] = RST$K_TYPE_ARRAY;


	! Put this Data Type RST Entry on the Temporary RST Entry List.  This
	! will cause the entry to be released at the end of a DEBUG command
	! when there are no references to it.
	!
	RSTPTR[RST$L_HASH_FLINK] = .RST$TEMP_LIST;
	RST$TEMP_LIST = .RSTPTR;


	! Then build the Type Specification DST Record.  This contains a Type
	! Spec containing a Value Spec which contains the descriptor address.
	!
	DSTPTR[DST$B_LENGTH] = 12;
	DSTPTR[DST$B_TYPE] = DST$K_TYPSPEC;
	TSPTR = DSTPTR[DST$A_TYPSPEC_TS_ADDR];
	TSPTR[DST$W_TS_LENGTH] = 8;
	TSPTR[DST$B_TS_KIND] = DST$K_TS_ARRAY;
	TSPTR[DST$B_TS_ARRAY_DIM] = .DESCADDR[DSC$B_DIMCT];
	VSPTR = TSPTR[DST$A_TS_ARRAY_FLAGS_ADDR] + 1;
	VSPTR[DST$B_VS_VFLAGS] = DST$K_VALKIND_DESC;
	VSPTR[DST$L_VS_VALUE] = .DESCADDR;


	! Return the address of the Type RST Entry we built (the TYPEID).
	!
	RETURN .RSTPTR;
	END;


    ! It is not an array descriptor.  We therefore generate a Descriptor Type
    ! RST Entry and the corresponding dummy Type Spec DST Record.
    !
    RSTPTR = DBG$GET_MEMORY(RST$K_TYPENTSIZ + 3);
    DSTPTR = .RSTPTR + 4*RST$K_TYPENTSIZ;


    ! Build the Data Type RST Entry.
    !
    RSTPTR[RST$L_DSTPTR] = .DSTPTR;
    RSTPTR[RST$L_UPSCOPEPTR] = .RST$START_ADDR;
    RSTPTR[RST$B_KIND] = RST$K_TYPE;
    RSTPTR[RST$B_FCODE] = RST$K_TYPE_DESCR;


    ! Put the Data Type RST Entry on the Temporary RST Entry List.  This will
    ! cause the entry to be released when no longer referenced.
    !
    RSTPTR[RST$L_HASH_FLINK] = .RST$TEMP_LIST;
    RST$TEMP_LIST = .RSTPTR;


    ! Then build the Type Specification DST Record.  This will contain a Type
    ! Spec containing a Value Spec containing the descriptor address.
    !
    DSTPTR[DST$B_LENGTH] = 10;
    DSTPTR[DST$B_TYPE] = DST$K_TYPSPEC;
    TSPTR = DSTPTR[DST$A_TYPSPEC_TS_ADDR];
    TSPTR[DST$W_TS_LENGTH] = 6;
    TSPTR[DST$B_TS_KIND] = DST$K_TS_DSC;
    VSPTR = TSPTR[DST$A_TS_DSC_VSPEC_ADDR];
    VSPTR[DST$B_VS_VFLAGS] = DST$K_VALKIND_DESC;
    VSPTR[DST$L_VS_VALUE] = .DESCADDR;


    ! Return the address of the Type RST Entry we build, i.e. the TYPEID.
    !
    RETURN .RSTPTR;

    END;


ROUTINE TYPEID_FOR_DESCR(DESCADDR, FCODE) =
!
! FUNCTION
!	This routine returns the Type ID associated with a VAX standard descrip-
!	tor type.  The routine builds a Data Type RST Entry for the data type
!	and returns its address as the Type ID.  This RST entry points to a dum-
!	my Type Specification DST Record, also built by this routine, which con-
!	tains a descriptor type specification which in turn contains a value
!	specification which points to the specified descriptor.  The RST entry
!	and the DST record are both built in the same memory block.  This block
!	is put on the Temporary RST Entry List so that it disappears as soon as
!	there no longer are any references to it.
!
! INPUTS
!	DESCADDR - The address of the descriptor for which a Type ID is to be
!		  returned.
!
!	FCODE	 - The format code of the resultant Type ID.
!
!	ARRFLAG  - (Optional). If this argument is TRUE, DESCADDR is assumed
!		   to be an ARRAY descriptor,  and a VAX standard descriptor
!		   is built to describe an element of the array.
!		   The descriptor is also placed in the same memory block.
!
! OUTPUTS
!	The corresponding Type ID is returned as the routine value.
!

    BEGIN

    BUILTIN ACTUALCOUNT,ACTUALPARAMETER;

    LOCAL
	DSTPTR: REF DST$RECORD,		! Pointer to the type's DST record
	RSTPTR: REF RST$ENTRY,		! Pointer to the type's RST entry
	TSPTR: REF DST$TYPE_SPEC,	! Pointer to the DST Type Specification
	VSPTR: REF DST$VAL_SPEC,	! Pointer to the DST Value Specification
	ARRFLAG;

    ARRFLAG = (IF ACTUALCOUNT() GTR 2 THEN ACTUALPARAMETER(3) ELSE FALSE);

    ! Get a memory block to hold both the RST entry and the DST record,
    ! and the array element descriptor (if needed).
    !
    RSTPTR = DBG$GET_MEMORY(RST$K_TYPENTSIZ + 3 + 3*.ARRFLAG);
    DSTPTR = .RSTPTR + 4*RST$K_TYPENTSIZ;

    IF .ARRFLAG
    THEN
	BEGIN
	LOCAL element : REF dbg$stg_desc;
	element = .dstptr+12;
	ch$move(10,.descaddr,.element);
	element[dsc$a_pointer] = 0;
	element[dsc$b_class] = (IF .element[dsc$b_dtype] EQL dsc$k_dtype_t
				THEN dsc$k_class_s ELSE dsc$k_class_sd);
	descaddr = .element;
	END;
    !
    ! Build the Data Type RST Entry for the descriptor type.
    !
    rstptr[rst$l_dstptr] = .dstptr;
    rstptr[rst$l_upscopeptr] = .rst$start_addr;
    rstptr[rst$b_kind] = rst$k_type;
    rstptr[rst$b_fcode] = .fcode;


    ! Put this Data Type RST Entry on the Temporary RST Entry List.  This will
    ! cause the entry to be released at the end of a DEBUG command when there
    ! are no references to it (when it is not locked).
    !
    RSTPTR[RST$L_HASH_FLINK] = .RST$TEMP_LIST;
    RST$TEMP_LIST = .RSTPTR;


    ! Then build the corresponding Type Specification DST Record.  This contains
    ! a type spec which contains a value spec containing the descriptor address.
    !
    dstptr[dst$b_length] = 10;
    dstptr[dst$b_type] = dst$k_typspec;
    dstptr[dst$b_typspec_name] = 0;
    tsptr = dstptr[dst$a_typspec_ts_addr];
    tsptr[dst$w_ts_length] = 6;
    tsptr[dst$b_ts_kind] = dst$k_ts_dsc;
    vsptr = tsptr[dst$a_ts_dsc_vspec_addr];
    vsptr[dst$b_vs_vflags] = 0;
    vsptr[dst$v_vs_valkind] = dst$k_valkind_desc;
    vsptr[dst$l_vs_value] = .descaddr;


    ! Return the address of the Data Type RST Entry as the Type ID.
    !
    RETURN .RSTPTR;

    END;

ROUTINE TYPEID_FROM_DST_TYPESPEC(DSTADDR, FCODE, BITSIZE) =
!
! FUNCTION
!	This routine builds a Data Type RST Entry for a data type specified by a
!	DST Type Specification embedded in some other symbol's DST record.  For
!	example, the cell type of an array or the referenced type of a typed
!	pointer is specified by a Type Specification in the DST record for the
!	array or the typed pointer, but does not have a separate DST record of
!	its own.  This routine is normally called when a Type ID (i.e., an RST
!	pointer to a Type RST Entry) must be produced for such a data type.
!	The RST entry is added to the Temporary RST Entry List so that it is
!	released back to the memory pool once there are no longer any references
!	to it.
!
!	The routine builds a Data Type RST Entry and a dummy DST record in the
!	same memory block.  The DST record is a Type Specification DST record
!	with the null name and an Indirect Type Specification pointing to the
!	DST Type Specification given as the input parameter.  The RST entry is
!	then set to point to this dummy DST record.
!
! INPUTS
!	DSTADDR	- The address of the DST Type Specification for which a Type ID
!		  is to be generated.
!
!	FCODE	- The type Format Code associated with the Type Specification.
!
!	BITSIZE - The size in bits of an item of this type.
!
! OUTPUTS
!	The data type's Type ID (i.e., a pointer to the Type RST Entry) is
!		  returned as the routine's value.
!

    BEGIN

    LOCAL
	DSTPTR: REF DST$RECORD,		! Pointer to generated DST record
	RSTPTR: REF RST$ENTRY,		! Pointer to generated Type RST Entry
	TSPTR: REF DST$TYPE_SPEC;	! Pointer to Type Spec in DST record



    ! Get a memory block large enough to accommodate both the RST entry and
    ! the dummy DST record.
    !
    RSTPTR = DBG$GET_MEMORY(RST$K_TYPENTSIZ + 3);
    DSTPTR = .RSTPTR + 4*RST$K_TYPENTSIZ;


    ! Build the Data Type RST Entry for the input type.
    !
    rstptr[rst$l_dstptr] = .dstptr;
    rstptr[rst$l_upscopeptr] = .rst$start_addr;
    rstptr[rst$b_kind] = rst$k_type;
    rstptr[rst$b_fcode] = .fcode;
    rstptr[rst$l_bitsize] = .bitsize;


    ! Put this Data Type RST Entry on the Temporary RST Entry List.  This will
    ! cause the entry to be released at the end of a DEBUG command when there
    ! are no references to it (when it is not locked).
    !
    RSTPTR[RST$L_HASH_FLINK] = .RST$TEMP_LIST;
    RST$TEMP_LIST = .RSTPTR;


    ! Build the dummy DST record for the type.
    !
    dstptr[dst$b_length] = 9;
    dstptr[dst$b_type] = dst$k_typspec;
    dstptr[dst$b_typspec_name] = 0;
    tsptr = .dstptr + 3;
    tsptr[dst$w_ts_length] = 5;
    tsptr[dst$b_ts_kind] = dst$k_ts_ind_tspec;
    tsptr[dst$l_ts_ind_ptr] = .dstaddr - .dst$begin_addr;


    ! Return the RST pointer to the caller.
    !
    RETURN .RSTPTR;

    END;

ROUTINE TYPEID_FROM_DST_RECORD(DSTADDR, FCODE, BITSIZE) =
!
! FUNCTION
!	This routine returns a Type ID for the item described by the DST record
!	pointed to by DSTADDR.
!
! INPUTS
!	DSTADDR	- The DST address of the record defining this item.
!
!	FCODE	- The Format Code which corresponds to the type of this item.
!
!	BITSIZE - The size in bits of this item.
!
! OUTPUTS
!	A Type ID for the type of the item is returned as the routine's value.
!


    BEGIN

    MAP
	DSTADDR: REF DST$RECORD;	! Pointer to DST record from which we
					!      will construct a Type ID

    LOCAL
	RSTPTR: REF RST$ENTRY;		! Pointer to generated Type RST Entry



    ! If the data item is atomic, we call TYPEID_FOR_ATOMIC to build the
    ! desired Data Type RST Entry.  We return its output directly.
    !
    IF .FCODE EQL RST$K_TYPE_ATOMIC
    THEN
	RETURN TYPEID_FOR_ATOMIC(.DSTADDR[DST$B_TYPE], .BITSIZE, FALSE);


    ! Get a memory block to hold the Data Type RST Entry.
    !
    RSTPTR = DBG$GET_MEMORY(RST$K_TYPENTSIZ);


    ! Build the Data Type RST Entry for the input type.
    !
    rstptr[rst$l_dstptr] = .dstaddr;
    rstptr[rst$l_upscopeptr] = .rst$start_addr;
    rstptr[rst$b_kind] = rst$k_type;
    rstptr[rst$b_fcode] = .fcode;
    rstptr[rst$l_bitsize] = .bitsize;


    ! Put this Data Type RST Entry on the Temporary RST Entry List.  This will
    ! cause the entry to be released at the end of a DEBUG command when there
    ! are no references to it (when it is not locked).
    !
    RSTPTR[RST$L_HASH_FLINK] = .RST$TEMP_LIST;
    RST$TEMP_LIST = .RSTPTR;


    ! Return the RST pointer to the caller.
    !
    RETURN .RSTPTR;

    END;

ROUTINE FIND_TYPE_RECORD ( SYMID, FCODE, BITSIZE ) =
!
! FUNCTION
!	This routine takes a symid, and tracks down the type spec which
!	describes it. In the process, it determines the Format Code and
!	bit size of the item.
!
!
! INPUTS
!	symid	- The symid of the item whose type we want.
!		  (note that the symid may itself represent a named type)
!	fcode	- The address of a longword to receive the format code of
!		  the specified item.
!	bitsize - The address of a longword to receive the size in bits of
!		  the specified item.
!
! OUTPUTS
!	The data type's Type ID (i.e., a pointer to the Type RST Entry) is
!	  returned as the routine's value; zero is returned if no
!	  type exists.
!	FCODE	- The format code of the item is returned to FCODE.
!	BITSIZE	- The size in bits of the item is returned to BITSIZE.
!

    BEGIN
	MAP
		symid : REF rst$entry;

	LOCAL
		kind,
		dst_ptr : REF dst$record,
		type_ptr : REF dst$record,
		typeid : REF rst$entry,
		type_spec : REF dst$type_spec;

	dbg$sta_symkind(.symid, kind);
	SELECTONE .kind OF
		SET

	[rst$k_type]:
		BEGIN
		.fcode = .symid[rst$b_fcode];
		.bitsize = .symid[rst$l_bitsize];
		RETURN .symid;
		END;

	[rst$k_typcomp,
	 rst$k_data]:
		BEGIN
		LOCAL
			savefcode,
			saveid : REF rst$entry,
			have_type,
			size;
		size = 0;
		IF (typeid = .symid[rst$l_typeptr]) NEQ 0
		THEN
			BEGIN
			savefcode = .typeid[rst$b_fcode];
			saveid = .typeid;
			have_type = TRUE;
			dst_ptr = .typeid[rst$l_dstptr];
			IF .dst_ptr[dst$b_type] EQL dst$k_enumbeg
			THEN
				size = .dst_ptr[dst$b_enumbeg_leng];
			END
		ELSE
			have_type = FALSE;

		dst_ptr = .symid[rst$l_dstptr];
		SELECTONE .dst_ptr[dst$b_type] OF
			SET

		[dst$k_septyp]:
			BEGIN
			type_ptr = dst_ptr[dst$a_next] +
						.dst_ptr[dst$b_length];
			type_spec = type_ptr[dst$a_typspec_ts_addr] +
					.type_ptr[dst$b_typspec_name];
			WHILE TRUE DO
				BEGIN

				IF .type_ptr[dst$b_type] EQL DST$K_SEPTYP
				THEN
					BEGIN
					type_ptr = type_ptr[dst$a_next] +
						.type_ptr[dst$b_length];
					type_spec = .type_ptr[dst$b_typspec_name] +
					    type_ptr[dst$a_typspec_ts_addr];
					END

				ELSE IF .type_ptr[dst$b_type] EQL DST$K_GLOBNXT
				THEN
					BEGIN
					type_ptr = .type_ptr + 2;
					type_spec = .type_ptr[dst$b_typspec_name] +
					    type_ptr[dst$a_typspec_ts_addr];
					END

				ELSE IF .TYPE_PTR[DST$B_TYPE] NEQ DST$K_TYPSPEC
				THEN
					EXITLOOP

				ELSE IF .type_spec[dst$b_ts_kind] EQL DST$K_TS_NOV_LENG
				THEN
					BEGIN
					size = .type_spec[dst$l_ts_nov_leng];
					type_ptr = .dst$begin_addr +
					.type_spec[dst$l_ts_nov_leng_par_tspec];
					type_spec = .type_ptr[dst$b_typspec_name] +
					       type_ptr[dst$a_typspec_ts_addr];
					END

				ELSE IF .type_spec[dst$b_ts_kind] EQL DST$K_TS_IND
				THEN
					BEGIN
					type_ptr = .dst$begin_addr +
						.type_spec[dst$l_ts_ind_ptr];
					type_spec = .type_ptr[dst$b_typspec_name] +
					       type_ptr[dst$a_typspec_ts_addr];
					END

				ELSE
					EXITLOOP;

			END;

			IF .size EQL 0
			THEN
				size = get_type_size(.type_spec);

			.bitsize = .size;
			IF .have_type
			THEN
				BEGIN
				.fcode = .savefcode;
				RETURN .saveid;
				END;

			.fcode = trans_type_code(.type_spec[dst$b_ts_kind]);
			IF ..fcode EQL rst$k_type_atomic
			THEN
			    RETURN typeid_for_atomic(.type_spec[dst$b_ts_atom_typ],
				.size,FALSE)

			ELSE
			    RETURN (
				 typeid_from_dst_record(.type_ptr,..fcode,.size));

			END;

		[dst$k_bli]:
			BEGIN
			.fcode = rst$k_type_blidata;
			.bitsize = bli_bitsize(.symid[rst$l_dstptr]);
			RETURN typeid_for_atomic(rst$k_type_blidata,
				..bitsize, FALSE);
			END;

		[dst$k_enumelt,
		 DST$K_RECBEG]:
			BEGIN
			.fcode = .saveid[rst$b_fcode];
			.bitsize = .saveid[rst$l_bitsize];
			RETURN .saveid;
			END;


		! Handle the COBOL Hack DST Record.  Here we call a routine
		! which converts that DST record into a more regular Type RST
		! Entry.  We then get the FCODE from that RST entry and re-
		! turn the entry's address as a Type ID.
		!
		[DST$K_COB_HACK]:
			BEGIN
			TYPEID = TYPEID_FOR_COB_HACK(.DST_PTR);
			.FCODE = .TYPEID[RST$B_FCODE];
			.BITSIZE = 0;
			RETURN .TYPEID;
			END;


		[dst$k_blifld]:
			BEGIN
			.fcode = rst$k_type_blifld;
			.bitsize = 0;
			RETURN typeid_for_atomic(rst$k_type_blifld,0,FALSE);
			END;

		[dst$k_lblorlit]:
			BEGIN
			.fcode = rst$k_type_atomic;
			.bitsize = 32;
			RETURN typeid_for_atomic(dsc$k_dtype_lu,32,FALSE);
			END;

		[OTHERWISE]:
			BEGIN
			LOCAL
				desc_ptr : REF BLOCK[,BYTE];

			IF (.dst_ptr[dst$b_type] LSS dsc$k_dtype_lowest OR
			    .dst_ptr[dst$b_type] GTR dsc$k_dtype_highest) AND
			   .dst_ptr[dst$b_type] NEQ dst$k_bool
			THEN
				SIGNAL(dbg$_debugbug, 1, dbg$k_wrong_typecode);

			.fcode = desc_or_array_or_atom(.symid, desc_ptr);
			IF ..fcode EQL rst$k_type_atomic
			THEN
				BEGIN
				.bitsize=dtype_to_bitsize(.dst_ptr[dst$b_type]);
				RETURN typeid_for_atomic(.dst_ptr[dst$b_type],
				..bitsize,FALSE);
				END

			ELSE
				BEGIN
				.bitsize = 0;
				RETURN typeid_for_descr(.desc_ptr, ..fcode);
				END;
			END;

			TES;

		END;

	 [rst$k_variant]:
		BEGIN
		.fcode = rst$k_variant;
		.bitsize = .symid[rst$l_bitsize];
		RETURN .symid;
		END;

	[OTHERWISE]:
		RETURN 0;

	TES;


    END;


ROUTINE trans_type_code ( code ) =
!
! FUNCTION
!	This routine takes a DST type code and translates it to the
!	corresponding RST type code.
!
! INPUTS
!	CODE	- The DST type code to be translated.
!
! OUTPUTS
!	The corresponding RST type code is returned as the routine's value.
!
BEGIN
	CASE .code FROM dst$k_ts_atom TO dst$k_ts_nov_leng
	OF
		SET

		[dst$k_ts_atom]:
			RETURN rst$k_type_atomic;

		[dst$k_ts_dsc]:
			RETURN rst$k_type_descr;

		[dst$k_ts_tptr]:
			RETURN rst$k_type_tptr;

		[dst$k_ts_ptr]:
			RETURN rst$k_type_ptr;

		[dst$k_ts_pic]:
			RETURN rst$k_type_pict;

		[dst$k_ts_array]:
			RETURN rst$k_type_array;

		[dst$k_ts_set]:
			RETURN rst$k_type_set;

		[dst$k_ts_subrange]:
			RETURN rst$k_type_subrng;

		[dst$k_ts_subset]:
			RETURN rst$k_type_subset;

		[dst$k_ts_file]:
			RETURN rst$k_type_file;

		[dst$k_ts_offset]:
			RETURN rst$k_type_offset;

		[dst$k_ts_area]:
			RETURN rst$k_type_area;

		[INRANGE,OUTRANGE]:
			RETURN 0;

		TES;

	END;

ROUTINE desc_or_array_or_atom (symid, desc_ptr) =
!
! FUNCTION
!	This routine takes a SYMID and determines whether it is of type atomic,
!	array, or descriptor.
!
! INPUTS
!	SYMID	- The SYMID in question.
!	DESC_PTR - The address of a longword location to receive the address
!		   of the item's descriptor (if present).
!
! OUTPUTS
!	The routine's value will be one of RST$K_TYPE_ATOMIC, RST$K_TYPE_DESCR,
!	or RST$K_TYPE_ARRAY.
!
!	DESC_PTR - For return values of RST$K_TYPE_DESCR and RST$K_TYPE_ARRAY,
!		   DESC_PTR receives the address of the item's descriptor.
!

BEGIN
	MAP
		desc_ptr : REF BLOCK[,BYTE],
		symid : REF rst$entry;

	LOCAL
		desc_addr : REF BLOCK[,BYTE],
		dst_ptr : REF dst$record;

	dst_ptr = .symid[rst$l_dstptr];
	IF .dst_ptr[dst$v_valkind] NEQ dst$k_valkind_desc
	THEN
		RETURN rst$k_type_atomic
	ELSE
		BEGIN
		LOCAL
			class;

		IF .dst_ptr[dst$v_regnum] EQL 15
		THEN
			desc_addr = .dst_ptr[dst$l_value] +
				dst_ptr[dst$l_value] + %UPVAL
		ELSE
			BEGIN
			LOCAL
				valptr : VECTOR[2],
				vkind,
				save_status;
			save_status = .dbg$gb_sym_status;
			dbg$gb_sym_status = 0;
			dbg$sta_symvalue(.symid,valptr,vkind);
			dbg$gb_sym_status = .save_status;
			IF .vkind NEQ dbg$k_val_descr
			THEN
				SIGNAL(dbg$_debugbug, 1, dbg$k_wrong_val_kind);
			desc_addr = .valptr[0];
		END;
		dbg$read_access(.desc_addr, 12);
		class = .desc_addr[dsc$b_class];
		.desc_ptr = .desc_addr;
		IF .class EQL dsc$k_class_a
		OR .class EQL dsc$k_class_nca
		OR .class EQL dsc$k_class_uba
		OR .class EQL dsc$k_class_vsa
		THEN
			RETURN (rst$k_type_array)
		ELSE
			RETURN (rst$k_type_descr);
		END;

	END;

ROUTINE GET_TYPESPEC(TYPE_SPEC, BITSIZE, DST_PTR) =
!
! FUNCTION
!	This routine takes a starting TYPE_SPEC and traces through the DST
!	to find the destination type specification; in this process, the
!	routine is sensitive to DST$K_TS_IND, DST$K_SEPTYP, DST$K_GLOBNXT,
!	and DST$K_TS_NOV_LENG. (All of these types indicate that the actual
!	type specification is found elsewhere.) When a DST$K_TS_NOV_LENG is
!	detected, BITSIZE is updated to reflect the novel length.
!
!	The routine loops until a true type spec is located.
!
! INPUTS
!	TYPE_SPEC - The DST address of the initial type-specification.
!	BITSIZE   - The address of a longword location to receive the size in
!		    bits of the specified type.
!	DST_PTR	  - The address of a longword location to receive the DST
!		    address of the DST record which contains the desired
!		    type specification.
!
! OUTPUTS
!	The routine's value is the DST address of the desired type-specification.
!
!	BITSIZE	- The size in bits of an item of this type is returned to
!		  BITSIZE. If a novel length record was detected, BITSIZE
!		  reflects the novel length; otherwise, BITSIZE receives the
!		  default size for the indicated data type.
!
!	DST_PTR - The address of the DST record which contains the desired
!		  type-spec is returned to DST_PTR. The routine's value is
!		  always of type DST$TYPE_SPEC; DST_PTR enables the calling
!		  routine to know the start address of the containing DST record.
!

BEGIN

	LOCAL
		size,
		temp_ts : REF dst$type_spec,
		type_ptr : REF dst$record;

	size = 0;
	temp_ts = .type_spec;
	TYPE_PTR = 0;
	WHILE TRUE
	DO
		BEGIN
		IF .temp_ts[dst$b_ts_kind] EQL dst$k_ts_ind
		THEN
			BEGIN
			type_ptr = .dst$begin_addr +
					.temp_ts[dst$l_ts_ind_ptr];
			IF .type_ptr[dst$b_type] EQL dst$k_septyp
			THEN
				BEGIN
				type_ptr = type_ptr[dst$a_next] +
					.type_ptr[dst$b_length];
				IF .type_ptr[dst$b_type] EQL dst$k_globnxt
				THEN
					type_ptr = .type_ptr + 2;
			END;
			IF (.type_ptr[dst$b_type] EQL dst$k_enumbeg)
			OR (.type_ptr[dst$b_type] EQL dst$k_recbeg)
			THEN
				EXITLOOP;
			temp_ts = type_ptr[dst$a_typspec_ts_addr] +
					.type_ptr[dst$b_typspec_name];
			END


		! Handle the kind of indirect pointer which points directly to
		! a DST Type Spec (as opposed to a Type Spec DST record).
		!
		ELSE IF .TEMP_TS[DST$B_TS_KIND] EQL DST$K_TS_IND_TSPEC
		THEN
		    BEGIN
		    TEMP_TS = .DST$BEGIN_ADDR + .TEMP_TS[DST$L_TS_IND_PTR];
		    END


		! Handle the Novel Length Type Spec.  Here we pick up the length
		! of data objects of this type and indirect to the Type Spec.
		!
		ELSE IF .temp_ts[dst$b_ts_kind] EQL dst$k_ts_nov_leng
		THEN
			BEGIN
			size = .temp_ts[dst$l_ts_nov_leng];
			type_ptr = .dst$begin_addr +
				.temp_ts[dst$l_ts_nov_leng_par_tspec];
			IF .type_ptr[dst$b_type] EQL dst$k_septyp
			THEN
				BEGIN
				type_ptr = type_ptr[dst$a_next] +
					.type_ptr[dst$b_length];
				IF .type_ptr[dst$b_type] EQL dst$k_globnxt
				THEN
					type_ptr = .type_ptr + 2;
			END;
			IF (.type_ptr[dst$b_type] EQL dst$k_enumbeg)
			OR (.type_ptr[dst$b_type] EQL dst$k_recbeg)
			THEN
				EXITLOOP;
			temp_ts = type_ptr[dst$a_typspec_ts_addr] +
					.type_ptr[dst$b_typspec_name];
		END
		ELSE
			EXITLOOP;

	END;

	IF .size EQL 0
	THEN
		size = get_type_size(.temp_ts);
	IF .type_ptr NEQ 0
	THEN
		.dst_ptr = .type_ptr;

	.bitsize = .size;
	RETURN .temp_ts;
END;

ROUTINE find_typrec_from_tspec( type_spec ) =
!
! FUNCTION
!	This routine takes a TYPE SPECIFICATION and returns the (possibly)
!	constructed TYPEID which describes the type.
!
! INPUTS
!	TYPE_SPEC - The type specification for which we need a TYPEID.
!
! OUTPUTS
!	The address of a TYPEID describing type_spec.
!

BEGIN

	LOCAL
		fcode,
		size,
		temp_ts : REF dst$type_spec,
		typeid : REF rst$entry,
		type_ptr : REF dst$record;

	size = 0;
	type_ptr = 0;
	temp_ts = get_typespec(.type_spec, size, type_ptr);
	IF .type_ptr NEQ 0
	THEN
		IF .type_ptr[dst$b_type] EQL dst$k_enumbeg
		OR .type_ptr[dst$b_type] EQL dst$k_recbeg
		THEN
			IF (typeid = find_rst_type_entry(.type_ptr)) NEQ 0
			THEN
				RETURN .typeid;
	fcode = trans_type_code(.temp_ts[dst$b_ts_kind]);
	IF .fcode EQL rst$k_type_atomic
	THEN
		RETURN typeid_for_atomic(.temp_ts[dst$b_ts_atom_typ],.size,
									FALSE)
	ELSE
	IF .type_ptr NEQ 0
	THEN
		RETURN typeid_from_dst_record(.type_ptr, .fcode, .size)
	ELSE
		RETURN typeid_from_dst_typespec(.temp_ts,.fcode,.size);
END;

ROUTINE DTYPE_TO_BITSIZE(DTYPE) =
!
! FUNCTION
!	This routine takes an SRM DTYPE and returns the default bitsize
!	defined for that type.
!
! INPUTS
!	DTYPE	- The VAX Standard Data Type whose bit size we want.
!
! OUTPUTS
!	The corresponding bit size is returned as the routine's value.
!

    BEGIN

    BIND
	LENGTH_TBL = UPLIT BYTE(0, 1, 1,2,4,8, 1,2,4,8, 4,8,8,16,
				REP 11 OF (0), 16,16,8,16,16,32,
				12,8,8,0,0,0,0): VECTOR[,BYTE];

	%IF DSC$K_DTYPE_HIGHEST GTR 37	! If the LENGTH_TBL PLIT is too small,
	%THEN				!      generate a compile-time error
	    %ERROR('Error:  Must expand PLIT in Routine DTYPE_TO_BITSIZE')
	%FI;



    ! Return the bitsize corresponding to the input data type.  Note that
    ! we treat Boolean (as in PASCAL) as a special case.
    !
    IF .DTYPE EQL DST$K_BOOL THEN RETURN 8;
    RETURN 8*.LENGTH_TBL[.DTYPE];

    END;

ROUTINE get_type_size ( type_spec ) =
!
! FUNCTION
!	This routine takes a type specification and returns the corresponding
!	default bit size.
!
! INPUTS
!	type_spec - The type specification whose default size we want.
!
! OUTPUTS
!	The type's default bit size is returned as the routine's value.
!
BEGIN
	MAP
		type_spec : REF dst$type_spec;
	LOCAL
		size;

		SELECTONE .type_spec[dst$b_ts_kind] OF
			SET

		[dst$k_ts_atom]:
			size = dtype_to_bitsize(.type_spec[dst$b_ts_atom_typ]);

		[dst$k_ts_set]:
			size = .type_spec[dst$l_ts_set_leng];

		[dst$k_ts_subrange]:
			size = .type_spec[dst$l_ts_subr_leng];

		[dst$k_ts_subset]:
			size = .type_spec[dst$l_ts_subs_leng];

		[dst$k_ts_pic]:
			size = .type_spec[dst$b_ts_pic_dleng]*%BPUNIT;

		[OTHERWISE]:
			size = 0;
		TES;
	RETURN .size;
END;

ROUTINE	bli_bitsize ( dstptr ) =
!
! FUNCTION
!	This routine takes the address of a BLISS type zero DST record, and
!	determines the bit size of the data item.
!
! INPUTS
!	dstptr	- The address of the DST record.
!
! OUTPUTS
!	The bit size of the item is returned as the routine's value.
!
BEGIN
	MAP
		dstptr : REF dst$record;

	LOCAL
		size,
		bptr1: REF dst$bli_trailer1,
		bptr2: REF dst$bli_trailer2;

	IF .dstptr[dst$b_bli_vflags] NEQ 1 THEN RETURN 0;
	bptr1 = dstptr[dst$a_bli_trlr1] + .dstptr[dst$b_bli_lng];
	bptr2 = bptr1[dst$a_bli_trlr2] + .bptr1[dst$b_bli_name];
	size = .bptr2[dst$l_bli_size];
	IF .dstptr[dst$v_bli_ref] THEN size = 4;
	RETURN .size;
END;

ROUTINE find_rst_type_entry( dstptr ) =
!
! FUNCTION
!	This routine takes the address of a DST record, and tries to find the
!	RST record which it defined. In particular, this routine serves to find
!	the TYPEID for those types which were built into the RST at SET MODULE
!	time (RECORD, ENUMERATION), but are now being referenced via a DST
!	pointer. The routine simply passes through the RST looking for an
!	RST$L_DSTPTR which matches the input dstptr.
!
! INPUTS
!	dstptr	- The address of the DST record of interest.
!
! OUTPUTS
!   ROUTINE VALUE:
!	The TYPEID of the RECORD or ENUMERATED type we are seeking, or Zero
!	if not found.
!
BEGIN
	LOCAL
		modptr : REF rst$entry,
		symid : REF rst$entry;

	modptr = .rst$start_addr;
	DO
		BEGIN
		symid = .modptr;
		UNTIL (symid = .symid[rst$l_symchnptr]) EQL 0
		DO
			IF .symid[rst$l_dstptr] EQL .dstptr
			THEN
				EXITLOOP;
		IF .symid NEQ 0
		THEN
			EXITLOOP;
	END
	UNTIL (modptr = .modptr[rst$l_nxtmodptr]) EQL 0;

	RETURN .symid;
END;

END ELUDOM
