MODULE DBGDP2 ( IDENT = 'V03-000') =
BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! FACILITY:	DEBUG
!
!++
! FUNCTIONAL DESCRIPTION:
!	DEPOSIT ROUTINES FOR STARLET DEBUG FACILITY
!
! Version:	1.21
!
! History:
!	Author:
!		Carol Peters, 21 Jul 1976: Version 01
!
!	Modified by:
!		John Francis, 3 April 1981
!		Richard Title 16 Jul 1981
!
! Revision history:
! 1.01	22-SEP-78	DAR	Deleted require file LISTEL.
! 1.02	25-SEP-78	MCC	Deleted require file SYSLIT
! 1.03	27-SEP-78	MCC	Converted dbg$cnv...routines to BUILTIN
!				calls, streamlined diagnostics in symbol_deposit
! 1.04	 8-NOV-78	MCC	Changed dbg$examine_cmd to set the global
!				pointer dbg$gl_lis_ptr so that access to
!				the command arg list will be possible
!				when examining BLISS structures.
! 1.05	13-NOV-78	DAR	Fixed cause of informational message in dbg$reg_match
!				Fixed up dbg$deposit_cmd and symbol_deposit, they
!				now handle numeric string data types and use the
!				new command argument list format.
! 1.06	04-DEC-78	DAR	DBG$EVALUAT_CMD now handles DSC$K_DTYPE_FLD and
!				tries to output a register name if the address
!				is that of a register.
! 1.07	 9-DEC-78	MCC	Made changes to allow depositing into BLISS
!				structures or variables with field references.
!				This included the addition of the routine bli_write_mem.
!				Also changed dbg$evaluate_cmd to handle field refs
! 1.08	18-DEC-78	DAR	Added support for depositing packed decimal data
! 1.09	24-APR-79	MCC	Modified dbg$examine_cmd to first check that a
!				variable to be examined is not a reference to
!				a permanent symbol before resetting the type
!				field to -1. (Bug fix)
! 1.10	24-APR-79	MCC	Fixed a bug in symbol_deposit which prevented
!				deposits into globals with field references from
!				working correctly.
! 1.11   6-AUG-79	TKM	Changed OUTPUT_MEM_LOC to pass the symbol name
!				name table pointer to dbg$out_typ_val if it had
!				one.
! 1.12   12-SEP-79	TKM     Changed deposit command to handle new data types
!
! 1.13	28-NOV-79	BAO	Added support for override types.
!
! 1.14  3-JAN-80  	DLP	Changed size for asci output to reflect overrides
!
! 1.15	15-JAN-80	DLP	Added support for word integer to single or
!				double precision float Deposits.
!
! 1.15  16-JAN-80	DLP	Added check for asci deposits crossing
!				page boundaries (bug fix).
! 1.17	16-JAN-80	MCC	Fixed bug with default type of ascii when doing
!				deposits.	
! 1.18	20-Feb-80	JBD	Null strings are now output without an access
!				violation, which is to say, nothing is output.
! 1.19	21-Feb-80	JBD	Made EV <string-symbol> work. Also made deposits
!				into null strings work.
! 1.20	28-APR-80	KAN	Split this module (DBGDP2) away from DBGEXA
!
! 1.21	 3-APR-81	JF	Only call C74 routines if language is COBOL
! 1.22  16-JUL-1981     RT	Installed a new d_float to g_float conversion
!				routine because the old one didn't seem to
!				be working. Modified deposit routines
!				for floating type f, d, g and h so they
!				will accept conversions from type LU
!				(necessary for bliss and macro). Also,
!				added routine dbg$deposit_type_o for
!				octa_word. 
!--

! TABLE OF CONTENTS
!--
FORWARD ROUTINE
	dbg$deposit_type_hc ,
	dbg$deposit_type_gc ,
	dbg$deposit_type_h ,
	dbg$deposit_type_g ,
	dbg$deposit_type_p ,
	dbg$deposit_type_nro ,
	dbg$deposit_type_nr ,
	dbg$deposit_type_nlo ,
	dbg$deposit_type_nl ,
	dbg$deposit_type_nu ,
	dbg$deposit_type_dc ,
	dbg$deposit_type_fc ,
	dbg$deposit_type_d ,
	dbg$deposit_type_f ,
	dbg$deposit_type_q ,
	dbg$deposit_type_o ,
	dbg$deposit_type_l ,
	dbg$deposit_type_w ,
	cvt_d_g : novalue;

!
! Require files:
!

REQUIRE 'src$:dbgprolog.req';
REQUIRE 'SRC$:DBGGEN.REQ';
REQUIRE 'SRC$:BSTRUC.REQ';
REQUIRE 'SRC$:SYSSER.REQ';


EXTERNAL
	dbg$gb_mod_ptr : ref vector [,byte],
	dbg$floating_buffer : vector[,byte],
	dbg$float_desc : block[,byte],
	dbg$dbl_desc  :  block[,byte],
	dbg$deposit_source : BLOCK[,BYTE],
	dbg$deposit_target : BLOCK[,BYTE],
	dbg$deposit_lengvec : VECTOR[,BYTE],
	dbg$gb_language : BYTE;


EXTERNAL ROUTINE
	dbg$cvt_d_h,				! convert d_floating to h_floating
	ots$cvt_t_h,				! convert text to h_floating
	ots$cvt_t_g ,				! convert text to g_floating
	ots$cvt_t_d,				! convert text to double
	FOR$CVT_D_TG,
	C74$ME4B,
	C74$MS4B : NOVALUE ,
	dbg$digit_scan;


LITERAL
	DSC$K_DTYPE_CAS = 127,
	flting_buf_len  = 30,
	float_buf_len	= 15,
	dbl_buf_len	= 25,
	float_fra_dig	= 7,
	dbl_fra_dig	= 16,
	digits_in_int	= 1,
	scale_factor	= 0,
	float_exp_dig	= 2,
	dbl_exp_dig	= 2,
	MIN_BYTE_VAL = -128,
	MAX_BYTE_VAL = 127,
	MAX_UBYTE_VAL = 255,
	MIN_WORD_VAL = -32768,
	MAX_WORD_VAL = 32767,
	MAX_UWORD_VAL = 65535,
	MIN_LONG_VAL = -2147483648,
	MAX_LONG_VAL = 2147483647,
	max_inst_len	= 80,		! maximum number of binary bytes in an instruction
	page_size = 512;		! number of bytes / page of memory


MACRO	dsc$w_bit_offst	= 8, 0, 16, 0 %,	!fields for the descriptor
	dsc$_sgn_ext	= 10, 0, 1, 0 %;	!of an unalligned bit string

OWN
	dbl_value : block[8,byte],
	sd : block [12,byte],
	dstat;


BUILTIN
	CVTFL,CVTDL,CVTLF,CVTDF,CVTLD,CVTFD,
	CVTLP,CVTSP,CVTPL,CVTPS,CMPP;


GLOBAL ROUTINE dbg$deposit_type_w =

	! WORD INTEGER, 7
			BEGIN
			LOCAL TD : BLOCK[12,BYTE];
			CH$MOVE(12,dbg$deposit_target,TD);
			TD[DSC$W_LENGTH] = 4 ;
			SELECTONE .dbg$deposit_source[dsc$b_dtype]
			    OF
			    SET
			    [DSC$K_DTYPE_B] :
				BEGIN
				(.dbg$deposit_target[DSC$A_POINTER])<0,16> = .(.dbg$deposit_source[DSC$A_POINTER])<0,8,1>;
				END;
			    [DSC$K_DTYPE_BU] :
				BEGIN
				(.dbg$deposit_target[DSC$A_POINTER])<0,16> = .(.dbg$deposit_source[DSC$A_POINTER])<0,8>;
				END;
			    [DSC$K_DTYPE_W] :
				BEGIN
				IF .dbg$gb_language EQL lang_cobol
				THEN
				    BEGIN
				    IF C74$ME4B(dbg$deposit_source,TD) NEQ 0
				    THEN
					BEGIN
					SIGNAL(DBG$_NUMTRUNC);
					C74$MS4B(dbg$deposit_source,TD);
					END;
				    END
				ELSE
				    (.dbg$deposit_target[DSC$A_POINTER])<0,16> = ..dbg$deposit_source[DSC$A_POINTER];
				END;
			    [DSC$K_DTYPE_WU] :
				BEGIN
				(.dbg$deposit_target[DSC$A_POINTER])<0,16> = ..dbg$deposit_source[DSC$A_POINTER];
				END;
			    [dsc$k_dtype_l]:
				BEGIN
				IF .dbg$gb_language EQL lang_cobol
				THEN
				    BEGIN
				    if c74$me4b(dbg$deposit_source,td) neq 0
				    then
					begin
					signal(dbg$_numtrunc);
					c74$ms4b(dbg$deposit_source,td);
					end
				    END
				ELSE
				    BEGIN
				    IF ..dbg$deposit_source[DSC$A_POINTER] GTRU MAX_UWORD_VAL
					AND
				      (..dbg$deposit_source[DSC$A_POINTER] GTR MAX_WORD_VAL
					OR
				       ..dbg$deposit_source[DSC$A_POINTER] LSS MIN_WORD_VAL)
				    THEN
					SIGNAL(DBG$_NUMTRUNC);
				    (.dbg$deposit_target[DSC$A_POINTER])<0,16> = ..dbg$deposit_source[DSC$A_POINTER];
				    END
				END;
			    [DSC$K_DTYPE_LU] :
				BEGIN
				IF ..dbg$deposit_source[DSC$A_POINTER] GTRU MAX_UWORD_VAL
					AND
				   (..dbg$deposit_source[DSC$A_POINTER] GTR MAX_WORD_VAL
					OR
				    ..dbg$deposit_source[DSC$A_POINTER] LSS MIN_WORD_VAL)
				THEN
				    SIGNAL(DBG$_NUMTRUNC);
				(.dbg$deposit_target[DSC$A_POINTER])<0,16> = ..dbg$deposit_source[DSC$A_POINTER];
				END;
			    [dsc$k_dtype_f] :
				BEGIN
				CVTFD(.dbg$deposit_source[dsc$a_pointer],dbl_value);
				ch$fill(%x'00',flting_buf_len,dbg$floating_buffer);
				for$cvt_d_tg(dbl_value,dbg$float_desc,float_fra_dig,scale_factor,
					digits_in_int,float_exp_dig);
				ch$fill(%x'00',12,sd);
				ch$move(8,dbg$float_desc,sd);
				dbg$digit_scan(.dbg$float_desc[dsc$a_pointer],
				.dbg$float_desc[dsc$w_length],sd);
				if c74$me4b(sd,td) neq 0
				then
				    begin
				    signal(dbg$_numtrunc);
				    c74$ms4b(sd,td);
				    end;
				END;
			    [dsc$k_dtype_d] :
				BEGIN
				ch$fill(%x'00',flting_buf_len,dbg$floating_buffer);
				for$cvt_d_tg(.dbg$deposit_source[dsc$a_pointer],dbg$dbl_desc,dbl_fra_dig,scale_factor,
					digits_in_int,dbl_exp_dig);
				ch$fill(%x'00',12,sd);
				ch$move(8,dbg$dbl_desc,sd);
				dbg$digit_scan(.dbg$dbl_desc[dsc$a_pointer],
					.dbg$dbl_desc[dsc$w_length],sd);
				if c74$me4b(sd,td) neq 0
				then
				    begin
				    signal(dbg$_numtrunc);
				    c74$ms4b(sd,td);
				    end;
				END;
			    [dsc$k_dtype_t] :
				BEGIN
				ch$move(12,dbg$deposit_source,sd);
				dstat = dbg$digit_scan(.dbg$deposit_source[dsc$a_pointer],.dbg$deposit_source[dsc$w_length],sd);
				if not .dstat
				then
				    signal(dbg$_invnumber,1,dbg$deposit_source);
				if c74$me4b(sd,td) neq 0
				then
				    begin
				    signal(dbg$_numtrunc);
				    c74$ms4b(sd,td);
				    end;
				END;
			    [dsc$k_dtype_ubs] :
				BEGIN
					IF .dbg$deposit_source[dsc$w_length] GTR 16
					    then SIGNAL(DBG$_NUMTRUNC);
					(.dbg$deposit_target[dsc$a_pointer])<0,16> =
					    (IF .dbg$deposit_source[dsc$_sgn_ext] 
						THEN
					    .(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
								   .dbg$deposit_source[dsc$w_length], 1>
						ELSE
					    .(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
								   .dbg$deposit_source[dsc$w_length], 0> );

				END;
			    [OTHERWISE] :
				BEGIN
				RETURN false;
				END;
			    TES;

			RETURN true;
			END;

GLOBAL ROUTINE dbg$deposit_type_l =

	! LONGWORD INTEGER, 8
			BEGIN
			LOCAL TD:BLOCK[12,BYTE];
			CH$MOVE(12,dbg$deposit_target,TD);
			TD[DSC$W_LENGTH] = 9;
			SELECTONE .dbg$deposit_source[dsc$b_dtype]
			    OF
			    SET
			    [DSC$K_DTYPE_B] :
				BEGIN
				(.dbg$deposit_target[DSC$A_POINTER])<0,32> = .(.dbg$deposit_source[DSC$A_POINTER])<0,8,1>;
				END;
			    [DSC$K_DTYPE_BU] :
				BEGIN
				(.dbg$deposit_target[DSC$A_POINTER])<0,32> = .(.dbg$deposit_source[DSC$A_POINTER])<0,8>;
				END;
			    [DSC$K_DTYPE_W] :
				BEGIN
				IF .dbg$gb_language EQL lang_cobol
				THEN
				    BEGIN
				    IF C74$ME4B(dbg$deposit_source,TD) NEQ 0
				    THEN
					BEGIN
					SIGNAL(DBG$_NUMTRUNC);
					C74$MS4B(dbg$deposit_source,TD);
					END;
				    END
				ELSE
				(.dbg$deposit_target[DSC$A_POINTER])<0,32> = .(.dbg$deposit_source[DSC$A_POINTER])<0,16,1>;
				END;
			    [DSC$K_DTYPE_WU] :
				BEGIN
				(.dbg$deposit_target[DSC$A_POINTER])<0,32> = .(.dbg$deposit_source[DSC$A_POINTER])<0,16>;
				END;
			    [dsc$k_dtype_l]:
				BEGIN
				IF .dbg$gb_language EQL lang_cobol
				THEN
				    BEGIN
				    if c74$me4b(dbg$deposit_source,td) neq 0
				    then
					begin
					signal(dbg$_numtrunc);
					c74$ms4b(dbg$deposit_source,td);
					end;
				    END
				ELSE
				(.dbg$deposit_target[DSC$A_POINTER])<0,32> = ..dbg$deposit_source[DSC$A_POINTER];
				END;
			    [DSC$K_DTYPE_LU] :
				BEGIN
				(.dbg$deposit_target[DSC$A_POINTER])<0,32> = ..dbg$deposit_source[DSC$A_POINTER];
				END;
			    [dsc$k_dtype_f] :
				BEGIN
				CVTFD(.dbg$deposit_source[dsc$a_pointer],dbl_value);
				ch$fill(%x'00',flting_buf_len,dbg$floating_buffer);
				for$cvt_d_tg(dbl_value,dbg$float_desc,float_fra_dig,scale_factor,
					digits_in_int,float_exp_dig);
				ch$fill(%x'00',12,sd);
				ch$move(8,dbg$float_desc,sd);
				dbg$digit_scan(.dbg$float_desc[dsc$a_pointer],.dbg$float_desc[dsc$w_length],sd);
				if c74$me4b(sd,td) neq 0
				then
				    begin
				    signal(dbg$_numtrunc);
				    c74$ms4b(sd,td);
				    end;
				END;
			    [dsc$k_dtype_d] :
				BEGIN
				ch$fill(%x'00',flting_buf_len,dbg$floating_buffer);
				for$cvt_d_tg(.dbg$deposit_source[dsc$a_pointer],dbg$dbl_desc,dbl_fra_dig,scale_factor,
					digits_in_int,dbl_exp_dig);
				ch$fill(%x'00',12,sd);
				ch$move(8,dbg$dbl_desc,sd);
				dbg$digit_scan(.dbg$dbl_desc[dsc$a_pointer],.dbg$dbl_desc[dsc$w_length],sd);
				if c74$me4b(sd,td) neq 0
				then
				    begin
				    signal(dbg$_numtrunc);
				    c74$ms4b(sd,td);
				    end;
				END;
			    [dsc$k_dtype_t] :
				BEGIN
				ch$move(12,dbg$deposit_source,sd);
				dstat = dbg$digit_scan(.dbg$deposit_source[dsc$a_pointer],.dbg$deposit_source[dsc$w_length],sd);
				if not .dstat
				then
				    signal(dbg$_invnumber,1,dbg$deposit_source);
				if c74$me4b(sd,td) neq 0
				then
				    begin
				    signal(dbg$_numtrunc);
				    c74$ms4b(sd,td);
				    end;

				END;
			    [dsc$k_dtype_ubs] :
				BEGIN
					(.dbg$deposit_target[dsc$a_pointer]) =
					    (IF .dbg$deposit_source[dsc$_sgn_ext] 
						THEN
					    .(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
								   .dbg$deposit_source[dsc$w_length], 1>
						ELSE
					    .(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
								   .dbg$deposit_source[dsc$w_length], 0> );

				END;
			    [OTHERWISE] :
				BEGIN
				RETURN false;
				END;
			    TES;
			RETURN true;
			END;

GLOBAL ROUTINE dbg$deposit_type_q =

	! QUADWORD INTEGER, 9
			BEGIN
			local td:block[12,byte];
			ch$move(12,dbg$deposit_target,td);
			td[dsc$w_length] = 18 ;
			SELECTONE .dbg$deposit_source[dsc$b_dtype]
			    OF
			    SET
			    [dsc$k_dtype_l , dsc$k_dtype_lu]:
				begin
				! only sign extend for decimal radix.
				if .dbg$gb_mod_ptr[mode_radix] eql decimal_radix
				then
				    begin
				    if c74$me4b(dbg$deposit_source,td) neq 0
				    then
				        begin
				        signal(dbg$_numtrunc);
				        c74$ms4b(dbg$deposit_source,td);
				        end;
				    end
				else ! do not sign extend
				    begin
				    ! deposit the longword source into the
				    ! low-order word of the target, and
				    ! zero out the high-order word.
				    (.dbg$deposit_target[dsc$a_pointer]) =
					.(.dbg$deposit_source[dsc$a_pointer]);
				    (4+.dbg$deposit_target[dsc$a_pointer]) =
					0;
				    end;
				end;
			    [dsc$k_dtype_f] :
				BEGIN
				CVTFD(.dbg$deposit_source[dsc$a_pointer],dbl_value);
				ch$fill(%x'00',flting_buf_len,dbg$floating_buffer);
				for$cvt_d_tg(dbl_value,dbg$float_desc,float_fra_dig,scale_factor,
					digits_in_int,float_exp_dig);
				ch$fill(%x'00',12,sd);
				ch$move(8,dbg$float_desc,sd);
				dbg$digit_scan(.dbg$float_desc[dsc$a_pointer],.dbg$float_desc[dsc$w_length],sd);
				if c74$me4b(sd,td) neq 0
				then
				    begin
				    signal(dbg$_numtrunc);
				    c74$ms4b(sd,td);
				    end;
				END;
			    [dsc$k_dtype_d] :
				BEGIN
				ch$fill(%x'00',flting_buf_len,dbg$floating_buffer);
				for$cvt_d_tg(.dbg$deposit_source[dsc$a_pointer],dbg$dbl_desc,dbl_fra_dig,scale_factor,
					digits_in_int,dbl_exp_dig);
				ch$fill(%x'00',12,sd);
				ch$move(8,dbg$dbl_desc,sd);
				dbg$digit_scan(.dbg$dbl_desc[dsc$a_pointer],.dbg$dbl_desc[dsc$w_length],sd);
				if c74$me4b(sd,td) neq 0
				then
				    begin
				    signal(dbg$_numtrunc);
				    c74$ms4b(sd,td);
				    end;
				END;
			    [dsc$k_dtype_t] :
				BEGIN
				! assume an ascii string represents a 
				! decimal integer.
				ch$move(12,dbg$deposit_source,sd);
				dstat = dbg$digit_scan(.dbg$deposit_source[dsc$a_pointer],.dbg$deposit_source[dsc$w_length],sd);
				if not .dstat
				then
				    signal(dbg$_invnumber,1,dbg$deposit_source);
				if c74$me4b(sd,td) neq 0
				then
				    begin
				    signal(dbg$_numtrunc);
				    c74$ms4b(sd,td);
				    end;

				END;
			    [dsc$k_dtype_ubs] :
				BEGIN
				(.dbg$deposit_target[dsc$a_pointer]) =
					    (IF .dbg$deposit_source[dsc$_sgn_ext] 
						THEN
					    .(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
								   .dbg$deposit_source[dsc$w_length], 1>
						ELSE
					    .(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
								   .dbg$deposit_source[dsc$w_length], 0> );

				END;

			    [OTHERWISE] :
				BEGIN
				RETURN false;
				END;
			    TES;
			RETURN true;
			END;

global routine dbg$deposit_type_o =
	! octa_word integer

    begin
    local
	td : block[12, byte];    
    macro sign_extend = 
	if .(4+.dbg$deposit_target[dsc$a_pointer]) lss 0 
	then
	    begin
	    (8+.dbg$deposit_target[dsc$a_pointer]) = %X'FFFFFFFF';
	    (12+.dbg$deposit_target[dsc$a_pointer]) = %X'FFFFFFFF';
	    end
	else
	    begin
	    (8+.dbg$deposit_target[dsc$a_pointer]) = %X'00000000';
	    (12+.dbg$deposit_target[dsc$a_pointer]) = %x'00000000';
	    end; %;
    ch$move(12,dbg$deposit_target,td);
    td[dsc$w_length] = 18;
    ! Change type to quadword because the conversion routines
    ! can't handle octa_word.
    td[dsc$b_dtype] = dsc$k_dtype_q;
    selectone .dbg$deposit_source[dsc$b_dtype]
	of
	set
	[dsc$k_dtype_l, dsc$k_dtype_lu] :
	    begin
	    ! place longword source into low-order word of target.
	    .dbg$deposit_target[dsc$a_pointer] = 
		..dbg$deposit_source[dsc$a_pointer];
	    ! if mode is hex or octal,
	    ! or if decimal mode but no sign extension necessary,
	    ! place zeros into high-order words. Otherwise,
	    ! place 1's into high-order words.
	    incr i from 1 to 3 do    
		(4*.i+.dbg$deposit_target[dsc$a_pointer]) = 
		    (if .dbg$gb_mod_ptr[mode_radix] neq decimal_radix
			or ..dbg$deposit_source[dsc$a_pointer] geq 0
		    then
			0
		    else
			%x'FFFFFFFF');

	    end;
	! Conversion from f_float and d_float handled as in dep/quad, except
	! that here we have some logic to decide whether to sign extend 
	! to the 2 high-order longwords.
	[dsc$k_dtype_f] :
            BEGIN
	    CVTFD(.dbg$deposit_source[dsc$a_pointer],dbl_value);
	    ch$fill(%x'00',flting_buf_len,dbg$floating_buffer);
	    for$cvt_d_tg(dbl_value,dbg$float_desc,float_fra_dig,scale_factor,
		digits_in_int,float_exp_dig);
	    ch$fill(%x'00',12,sd);
	    ch$move(8,dbg$float_desc,sd);
	    dbg$digit_scan(.dbg$float_desc[dsc$a_pointer],.dbg$float_desc[dsc$w_length],sd);
	    if c74$me4b(sd,td) neq 0
	    then
	        begin
	        signal(dbg$_numtrunc);
	        c74$ms4b(sd,td);
	        end;
	    sign_extend
	    END;
	[dsc$k_dtype_d] :
	    BEGIN
	    ch$fill(%x'00',flting_buf_len,dbg$floating_buffer);
	    for$cvt_d_tg(.dbg$deposit_source[dsc$a_pointer],dbg$dbl_desc,dbl_fra_dig,scale_factor,
		digits_in_int,dbl_exp_dig);
	    ch$fill(%x'00',12,sd);
	    ch$move(8,dbg$dbl_desc,sd);
	    dbg$digit_scan(.dbg$dbl_desc[dsc$a_pointer],.dbg$dbl_desc[dsc$w_length],sd);
	    if c74$me4b(sd,td) neq 0
	    then
	        begin
	        signal(dbg$_numtrunc);
	        c74$ms4b(sd,td);
	        end;
	    sign_extend
	    END;
	[dsc$k_dtype_t] :
	    BEGIN
	    ! assume an ascii string represents a 
	    ! decimal integer.
	    ch$move(12,dbg$deposit_source,sd);
	    dstat = dbg$digit_scan(.dbg$deposit_source[dsc$a_pointer],.dbg$deposit_source[dsc$w_length],sd);
	    if not .dstat
	    then
	        signal(dbg$_invnumber,1,dbg$deposit_source);
	 	if c74$me4b(sd,td) neq 0
		then
		    begin
		    signal(dbg$_numtrunc);
		    c74$ms4b(sd,td);
		    end;
	    sign_extend
	    END;
	[dsc$k_dtype_ubs] :
	    BEGIN
	    (.dbg$deposit_target[dsc$a_pointer]) =
		(IF .dbg$deposit_source[dsc$_sgn_ext] 
		THEN
		    .(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
		       .dbg$deposit_source[dsc$w_length], 1>
		ELSE
		    .(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
		       .dbg$deposit_source[dsc$w_length], 0> );

	    END;

	[otherwise] :
	    return false;
	tes;
    return true;
    end;


GLOBAL ROUTINE dbg$deposit_type_f =

	! SINGLE PRECISION FLOATING, 10
			BEGIN
			SELECTONE .dbg$deposit_source[dsc$b_dtype]
			    OF
			    SET
			    [dsc$k_dtype_w] :
				begin
				local
				    temp_long;
				temp_long = .(.dbg$deposit_source[dsc$a_pointer])<0,16,1>;
				CVTLF (temp_long, (.dbg$deposit_target[dsc$a_pointer]));
				end;
			    [dsc$k_dtype_l , dsc$k_dtype_lu] :
				BEGIN
				CVTLF(.dbg$deposit_source[dsc$a_pointer], (.dbg$deposit_target[dsc$a_pointer]));
				END;
			    [dsc$k_dtype_f] :
				BEGIN
				CH$MOVE(.dbg$deposit_lengvec[dsc$k_dtype_f],
					.dbg$deposit_source[dsc$a_pointer],
					(.dbg$deposit_target[dsc$a_pointer]));
				END;
			    [dsc$k_dtype_d] :
				BEGIN
				IF CVTDF(.dbg$deposit_source[dsc$a_pointer], (.dbg$deposit_target[dsc$a_pointer])) EQL 0
					THEN SIGNAL (DBG$_NUMTRUNC);
				END;
			    [dsc$k_dtype_t] :
				BEGIN
				LOCAL a : VECTOR[2];
				dstat=ots$cvt_t_d(dbg$deposit_source,a);
				if not .dstat
				then
				    signal(dbg$_numtrunc)
				else
				IF CVTDF(a,.dbg$deposit_target[dsc$a_pointer]) EQL 0
				THEN
				    SIGNAL(dbg$_numtrunc);
				END;
			    [dsc$k_dtype_ubs] :
				BEGIN
				(.dbg$deposit_target[dsc$a_pointer])<0,32> =
					    (IF .dbg$deposit_source[dsc$_sgn_ext] 
						THEN
					    .(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
								   .dbg$deposit_source[dsc$w_length], 1>
						ELSE
					    .(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
								   .dbg$deposit_source[dsc$w_length], 0> );
				END;
				
			    [OTHERWISE] :
				BEGIN
				RETURN false;
				END;
			    TES;
			RETURN true;
			END;

GLOBAL ROUTINE dbg$deposit_type_d =

	! DOUBLE PRECISION FLOATING, 11
			BEGIN
			SELECTONE .dbg$deposit_source[dsc$b_dtype]
			    OF
			    SET
			    [dsc$k_dtype_w] :
				begin
				local
				    temp_long;
				temp_long = .(.dbg$deposit_source[dsc$a_pointer])<0,16,1>;
				CVTLD (temp_long, (.dbg$deposit_target[dsc$a_pointer]));
				end;
			    [dsc$k_dtype_l , dsc$k_dtype_lu] :
				BEGIN
				CVTLD(.dbg$deposit_source[dsc$a_pointer], .dbg$deposit_target[dsc$a_pointer]);
				END;
			    [dsc$k_dtype_f] :
				BEGIN
				CVTFD(.dbg$deposit_source[dsc$a_pointer], (.dbg$deposit_target[dsc$a_pointer]));
				END;
			    [dsc$k_dtype_d] :
				BEGIN
				CH$MOVE(.dbg$deposit_lengvec[dsc$k_dtype_d],
					.dbg$deposit_source[dsc$a_pointer],
					(.dbg$deposit_target[dsc$a_pointer]));
				END;
			    [dsc$k_dtype_t] :
				BEGIN
				dstat=ots$cvt_t_d(dbg$deposit_source,.dbg$deposit_target[dsc$a_pointer]);
				if not .dstat
				then
				    signal(dbg$_numtrunc);
				END;
			    [dsc$k_dtype_ubs] :
				BEGIN
				(.dbg$deposit_target[dsc$a_pointer])<0,32> =
					    (IF .dbg$deposit_source[dsc$_sgn_ext] 
						THEN
					    .(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
								   .dbg$deposit_source[dsc$w_length], 1>
						ELSE
					    .(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
								   .dbg$deposit_source[dsc$w_length], 0> );
				END;
			    [OTHERWISE] :
				BEGIN
				RETURN false;
				END;
			    TES;
			RETURN true;
			END;

GLOBAL ROUTINE dbg$deposit_type_fc =

	! COMPLEX, 12
			BEGIN
		SELECTONE .dbg$deposit_source[dsc$b_dtype]
			    OF
			    SET
			    [dsc$k_dtype_l] :
				BEGIN
				CVTLF(.dbg$deposit_source[dsc$a_pointer], (.dbg$deposit_target[dsc$a_pointer]));
				END;
			    [dsc$k_dtype_f] :
				BEGIN
				CH$MOVE(.dbg$deposit_lengvec[dsc$k_dtype_f],
					.dbg$deposit_source[dsc$a_pointer],
					(.dbg$deposit_target[dsc$a_pointer]));
				END;
			    [dsc$k_dtype_d] :
				BEGIN
				IF CVTDF(.dbg$deposit_source[dsc$a_pointer], (.dbg$deposit_target[dsc$a_pointer])) EQL 0
					THEN SIGNAL (DBG$_NUMTRUNC);
				END;
			    [dsc$k_dtype_t] :
				BEGIN
				LOCAL a : VECTOR[2];
				dstat=ots$cvt_t_d(dbg$deposit_source,a);
				if not .dstat
				then
				    signal(dbg$_numtrunc)
				else
				IF CVTDF(a,.dbg$deposit_target[dsc$a_pointer]) EQL 0
				THEN
				    SIGNAL(dbg$_numtrunc);
				END;
			    [dsc$k_dtype_ubs] :
				BEGIN
				(.dbg$deposit_target[dsc$a_pointer])<0,32> =
					    (IF .dbg$deposit_source[dsc$_sgn_ext] 
						THEN
					    .(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
								   .dbg$deposit_source[dsc$w_length], 1>
						ELSE
					    .(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
								   .dbg$deposit_source[dsc$w_length], 0> );
				END;
			    [OTHERWISE] :
				BEGIN
				RETURN false;
				END;
			    TES;
			RETURN true;
			END;

GLOBAL ROUTINE dbg$deposit_type_dc =

	! DOUBLE PRECISION FLOATING COMPLEX, 13
			BEGIN
			SELECTONE .dbg$deposit_source[dsc$b_dtype]
			    OF
			    SET
			    [dsc$k_dtype_l] :
				BEGIN
				CVTLD(.dbg$deposit_source[dsc$a_pointer], .dbg$deposit_target[dsc$a_pointer]);
				END;
			    [dsc$k_dtype_f] :
				BEGIN
				CVTFD(.dbg$deposit_source[dsc$a_pointer], (.dbg$deposit_target[dsc$a_pointer]));
				END;
			    [dsc$k_dtype_d] :
				BEGIN
				CH$MOVE(.dbg$deposit_lengvec[dsc$k_dtype_d],
					.dbg$deposit_source[dsc$a_pointer],
					(.dbg$deposit_target[dsc$a_pointer]));
				END;
			    [dsc$k_dtype_t] :
				BEGIN
				dstat=ots$cvt_t_d(dbg$deposit_source,.dbg$deposit_target[dsc$a_pointer]);
				if not .dstat
				then
				    signal(dbg$_numtrunc);
				END;
			    [dsc$k_dtype_ubs] :
				BEGIN
				(.dbg$deposit_target[dsc$a_pointer])<0,32> =
					    (IF .dbg$deposit_source[dsc$_sgn_ext] 
						THEN
					    .(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
								   .dbg$deposit_source[dsc$w_length], 1>
						ELSE
					    .(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
								   .dbg$deposit_source[dsc$w_length], 0> );
				END;
			    [OTHERWISE] :
				BEGIN
				RETURN false;
				END;
			    TES;
			RETURN true;
			END;

GLOBAL ROUTINE dbg$deposit_type_nu =

	! NUMERIC STRING UNSIGNED, 15
			BEGIN
			SELECTONE .dbg$deposit_source[dsc$b_dtype]
			    OF
			    SET
			    [dsc$k_dtype_l] :
				BEGIN
				if c74$me4b(dbg$deposit_source,dbg$deposit_target) neq 0
				then
				    begin
				    signal(dbg$_numtrunc);
				    c74$ms4b(dbg$deposit_source,dbg$deposit_target);
				    end;

				END;
			    [dsc$k_dtype_f] :
				BEGIN
				CVTFD(.dbg$deposit_source[dsc$a_pointer],dbl_value);
				ch$fill(%x'00',flting_buf_len,dbg$floating_buffer);
				for$cvt_d_tg(dbl_value,dbg$float_desc,float_fra_dig,scale_factor,
					digits_in_int,float_exp_dig);
				ch$fill(%x'00',12,sd);
				ch$move(8,dbg$float_desc,sd);
				dbg$digit_scan(.dbg$float_desc[dsc$a_pointer],.dbg$float_desc[dsc$w_length],sd);
				if c74$me4b(sd,dbg$deposit_target) neq 0
				then
				    begin
				    signal(dbg$_numtrunc);
				    c74$ms4b(sd,dbg$deposit_target);
				    end;
				END;
			    [dsc$k_dtype_d] :
				BEGIN
				ch$fill(%x'00',flting_buf_len,dbg$floating_buffer);
				for$cvt_d_tg(.dbg$deposit_source[dsc$a_pointer],dbg$dbl_desc,dbl_fra_dig,scale_factor,
					digits_in_int,dbl_exp_dig);
				ch$fill(%x'00',12,sd);
				ch$move(8,dbg$dbl_desc,sd);
				dbg$digit_scan(.dbg$dbl_desc[dsc$a_pointer],.dbg$dbl_desc[dsc$w_length],sd);
				if c74$me4b(sd,dbg$deposit_target) neq 0
				then
				    begin
				    signal(dbg$_numtrunc);
				    c74$ms4b(sd,dbg$deposit_target);
				    end;
				END;
			    [dsc$k_dtype_t] :
				BEGIN
				ch$move(12,dbg$deposit_source,sd);
				dstat = dbg$digit_scan(.dbg$deposit_source[dsc$a_pointer],.dbg$deposit_source[dsc$w_length],sd);
				if not .dstat
				then
				    signal(dbg$_invnumber,1,dbg$deposit_source);
				if c74$me4b(sd,dbg$deposit_target) neq 0
				then
				    begin
				    signal(dbg$_numtrunc);
				    c74$ms4b(sd,dbg$deposit_target);
				    end;

				END;
			    [dsc$k_dtype_ubs] :
				BEGIN
				IF .dbg$deposit_source[dsc$w_length]  GTR (8 * .dbg$deposit_target[dsc$w_length])
				THEN
				    BEGIN
					SIGNAL(DBG$_STGTRUNC);
					(.dbg$deposit_target[dsc$a_pointer]) = 
						.(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
									8 * .dbg$deposit_target[dsc$w_length]>
				    END
				ELSE 
					(.dbg$deposit_target[dsc$a_pointer]) =
					    (IF .dbg$deposit_source[dsc$_sgn_ext] 
						THEN
					    .(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
								   .dbg$deposit_source[dsc$w_length], 1>
						ELSE
					    .(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
								   .dbg$deposit_source[dsc$w_length], 0> );
				END;
			    [OTHERWISE] :
				BEGIN
				RETURN false;
				END;
			    TES;
			RETURN true;
			END;

GLOBAL ROUTINE dbg$deposit_type_nl =

	! NUMERIC STRING LEFT SEPARATE SIGN, 16
			BEGIN
			SELECTONE .dbg$deposit_source[dsc$b_dtype]
			    OF
			    SET
			    [dsc$k_dtype_l] :
				BEGIN
				ch$move (12,dbg$deposit_target,sd);
				sd[dsc$w_length] = .sd[dsc$w_length] - 1;
				IF c74$me4b(dbg$deposit_source,sd) NEQ 0
				THEN
				    BEGIN
				    SIGNAL(dbg$_numtrunc);
				    c74$ms4b(dbg$deposit_source,sd);
				    END;
				END;
			    [dsc$k_dtype_f] :
				BEGIN
				local td : block[12,byte];
				ch$move(12,dbg$deposit_target,td);
				td[dsc$w_length] = .td[dsc$w_length] - 1;
				CVTFD(.dbg$deposit_source[dsc$a_pointer],dbl_value);
				ch$fill(%x'00',flting_buf_len,dbg$floating_buffer);
				for$cvt_d_tg(dbl_value,dbg$float_desc,float_fra_dig,scale_factor,
					digits_in_int,float_exp_dig);
				ch$fill(%x'00',12,sd);
				ch$move(8,dbg$float_desc,sd);
				dbg$digit_scan(.dbg$float_desc[dsc$a_pointer],.dbg$float_desc[dsc$w_length],sd);
				if c74$me4b(sd,td) neq 0
				then
				    begin
				    signal(dbg$_numtrunc);
				    c74$ms4b(sd,td);
				    end;
				END;
			    [dsc$k_dtype_d] :
				BEGIN
				local td : block[12,byte];
				ch$move(12,dbg$deposit_target,td);
				td[dsc$w_length] = .td[dsc$w_length] - 1;
				ch$fill(%x'00',flting_buf_len,dbg$floating_buffer);
				for$cvt_d_tg(.dbg$deposit_source[dsc$a_pointer],dbg$dbl_desc,dbl_fra_dig,scale_factor,
					digits_in_int,dbl_exp_dig);
				ch$fill(%x'00',12,sd);
				ch$move(8,dbg$dbl_desc,sd);
				dbg$digit_scan(.dbg$dbl_desc[dsc$a_pointer],.dbg$dbl_desc[dsc$w_length],sd);
				if c74$me4b(sd,td) neq 0
				then
				    begin
				    signal(dbg$_numtrunc);
				    c74$ms4b(sd,td);
				    end;
				END;
			    [dsc$k_dtype_t] :
				BEGIN
				local td : block[12,byte];
				ch$move(12,dbg$deposit_target,td);
				td[dsc$w_length] = .td[dsc$w_length] - 1;
				ch$move(12,dbg$deposit_source,sd);
				dstat = dbg$digit_scan(.dbg$deposit_source[dsc$a_pointer],.dbg$deposit_source[dsc$w_length],sd);
				if not .dstat
				then
				    signal(dbg$_invnumber,1,dbg$deposit_source);
				if c74$me4b(sd,td) neq 0
				then
				    begin
				    signal(dbg$_numtrunc);
				    c74$ms4b(sd,td);
				    end;

				END;
			    [dsc$k_dtype_ubs] :
				BEGIN
				IF .dbg$deposit_source[dsc$w_length]  GTR (8 * .dbg$deposit_target[dsc$w_length])
				THEN
				    BEGIN
					SIGNAL(DBG$_STGTRUNC);
					(.dbg$deposit_target[dsc$a_pointer]) = 
						.(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
									8 * .dbg$deposit_target[dsc$w_length]>
				    END
				ELSE 
					(.dbg$deposit_target[dsc$a_pointer]) =
					    (IF .dbg$deposit_source[dsc$_sgn_ext] 
						THEN
					    .(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
								   .dbg$deposit_source[dsc$w_length], 1>
						ELSE
					    .(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
								   .dbg$deposit_source[dsc$w_length], 0> );
				END;
			    [OTHERWISE] :
				BEGIN
				RETURN false;
				END;
			    TES;
			RETURN true;
			END;

GLOBAL ROUTINE dbg$deposit_type_nlo =

	! NUMERIC STRING LEFT OVERPUNCHED SIGN, 17
			BEGIN
			SELECTONE .dbg$deposit_source[dsc$b_dtype]
			    OF
			    SET
			    [dsc$k_dtype_l] :
				BEGIN
				IF C74$ME4B(dbg$deposit_source,dbg$deposit_target) NEQ 0
				THEN
				    BEGIN
				    SIGNAL(dbg$_numtrunc);
				    c74$ms4b(dbg$deposit_source,dbg$deposit_target);
				    END;
				END;
			    [dsc$k_dtype_f] :
				BEGIN
				CVTFD(.dbg$deposit_source[dsc$a_pointer],dbl_value);
				ch$fill(%x'00',flting_buf_len,dbg$floating_buffer);
				for$cvt_d_tg(dbl_value,dbg$float_desc,float_fra_dig,scale_factor,
					digits_in_int,float_exp_dig);
				ch$fill(%x'00',12,sd);
				ch$move(8,dbg$float_desc,sd);
				dbg$digit_scan(.dbg$float_desc[dsc$a_pointer],.dbg$float_desc[dsc$w_length],sd);
				if c74$me4b(sd,dbg$deposit_target) neq 0
				then
				    begin
				    signal(dbg$_numtrunc);
				    c74$ms4b(sd,dbg$deposit_target);
				    end;
				END;
			    [dsc$k_dtype_d] :
				BEGIN
				ch$fill(%x'00',flting_buf_len,dbg$floating_buffer);
				for$cvt_d_tg(.dbg$deposit_source[dsc$a_pointer],dbg$dbl_desc,dbl_fra_dig,scale_factor,
					digits_in_int,dbl_exp_dig);
				ch$fill(%x'00',12,sd);
				ch$move(8,dbg$dbl_desc,sd);
				dbg$digit_scan(.dbg$dbl_desc[dsc$a_pointer],.dbg$dbl_desc[dsc$w_length],sd);
				if c74$me4b(sd,dbg$deposit_target) neq 0
				then
				    begin
				    signal(dbg$_numtrunc);
				    c74$ms4b(sd,dbg$deposit_target);
				    end;
				END;
			    [dsc$k_dtype_t] :
				BEGIN
				ch$move(12,dbg$deposit_source,sd);
				dstat = dbg$digit_scan(.dbg$deposit_source[dsc$a_pointer],.dbg$deposit_source[dsc$w_length],sd);
				if not .dstat
				then
				    signal(dbg$_invnumber,1,dbg$deposit_source);
				if c74$me4b(sd,dbg$deposit_target) neq 0
				then
				    begin
				    signal(dbg$_numtrunc);
				    c74$ms4b(sd,dbg$deposit_target);
				    end;
				END;
			    [dsc$k_dtype_ubs] :
				BEGIN
				IF .dbg$deposit_source[dsc$w_length]  GTR (8 * .dbg$deposit_target[dsc$w_length])
				THEN
				    BEGIN
					SIGNAL(DBG$_STGTRUNC);
					(.dbg$deposit_target[dsc$a_pointer]) = 
						.(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
									8 * .dbg$deposit_target[dsc$w_length]>
				    END
				ELSE 
					(.dbg$deposit_target[dsc$a_pointer]) =
					    (IF .dbg$deposit_source[dsc$_sgn_ext] 
						THEN
					    .(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
								   .dbg$deposit_source[dsc$w_length], 1>
						ELSE
					    .(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
								   .dbg$deposit_source[dsc$w_length], 0> );
				END;
			    [OTHERWISE] :
				BEGIN
				RETURN false;
				END;
			    TES;
			RETURN true;
			END;

GLOBAL ROUTINE dbg$deposit_type_nr =

	! NUMERIC STRING RIGHT SEPARATE SIGN, 18
			BEGIN
			SELECTONE .dbg$deposit_source[dsc$b_dtype]
			    OF
			    SET
			    [dsc$k_dtype_l] :
				BEGIN
				ch$move (12,dbg$deposit_target,sd);
				sd[dsc$w_length] = .sd[dsc$w_length] - 1;
				IF C74$ME4B(dbg$deposit_source,sd) NEQ 0
				THEN
				    BEGIN
				    SIGNAL(dbg$_numtrunc);
				    c74$ms4b(dbg$deposit_source,sd);
				    END;
				END;
			    [dsc$k_dtype_f] :
				BEGIN
				local td:block[12,byte];
				ch$move(12,dbg$deposit_target,td);
				td[dsc$w_length] = .td[dsc$w_length] - 1;
				CVTFD(.dbg$deposit_source[dsc$a_pointer],dbl_value);
				ch$fill(%x'00',flting_buf_len,dbg$floating_buffer);
				for$cvt_d_tg(dbl_value,dbg$float_desc,float_fra_dig,scale_factor,
					digits_in_int,float_exp_dig);
				ch$fill(%x'00',12,sd);
				ch$move(8,dbg$float_desc,sd);
				dbg$digit_scan(.dbg$float_desc[dsc$a_pointer],.dbg$float_desc[dsc$w_length],sd);
				if c74$me4b(sd,td) neq 0
				then
				    begin
				    signal(dbg$_numtrunc);
				    c74$ms4b(sd,td);
				    end;
				END;
			    [dsc$k_dtype_d] :
				BEGIN
				local td : block[12,byte];
				ch$move(12,dbg$deposit_target,td);
				td[dsc$w_length] = .td[dsc$w_length] - 1;
				CVTFD(.dbg$deposit_source[dsc$a_pointer],dbl_value);
				ch$fill(%x'00',flting_buf_len,dbg$floating_buffer);
				for$cvt_d_tg(dbl_value,dbg$float_desc,float_fra_dig,scale_factor,
					digits_in_int,float_exp_dig);
				ch$fill(%x'00',12,sd);
				ch$move(8,dbg$float_desc,sd);
				dbg$digit_scan(.dbg$float_desc[dsc$a_pointer],.dbg$float_desc[dsc$w_length],sd);
				if c74$me4b(sd,td) neq 0
				then
				    begin
				    signal(dbg$_numtrunc);
				    c74$ms4b(sd,td);
				    end;
				END;
			    [dsc$k_dtype_t] :
				BEGIN
				local td : block[12,byte];
				ch$move(12,dbg$deposit_target,td);
				td[dsc$w_length] = .td[dsc$w_length] - 1;
				ch$move(12,dbg$deposit_source,sd);
				dstat = dbg$digit_scan(.dbg$deposit_source[dsc$a_pointer],.dbg$deposit_source[dsc$w_length],sd);
				if not .dstat
				then
				    signal(dbg$_invnumber,1,dbg$deposit_source);
				if c74$me4b(sd,td) neq 0
				then
				    begin
				    signal(dbg$_numtrunc);
				    c74$ms4b(sd,td);
				    end;
				END;
			    [dsc$k_dtype_ubs] :
				BEGIN
				IF .dbg$deposit_source[dsc$w_length]  GTR (8 * .dbg$deposit_target[dsc$w_length])
				THEN
				    BEGIN
					SIGNAL(DBG$_STGTRUNC);
					(.dbg$deposit_target[dsc$a_pointer]) = 
						.(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
									8 * .dbg$deposit_target[dsc$w_length]>
				    END
				ELSE 
					(.dbg$deposit_target[dsc$a_pointer]) =
					    (IF .dbg$deposit_source[dsc$_sgn_ext] 
						THEN
					    .(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
								   .dbg$deposit_source[dsc$w_length], 1>
						ELSE
					    .(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
								   .dbg$deposit_source[dsc$w_length], 0> );
				END;
			    [OTHERWISE] :
				BEGIN
				RETURN false;
				END;
			    TES;
			RETURN true;
			END;

GLOBAL ROUTINE dbg$deposit_type_nro =

	! NUMERIC STRING RIGHT OVERPUNCHED SIGN, 19
			BEGIN
			SELECTONE .dbg$deposit_source[dsc$b_dtype]
			    OF
			    SET
			    [dsc$k_dtype_l] :
				BEGIN
				IF C74$ME4B(dbg$deposit_source,dbg$deposit_target) NEQ 0
				THEN
				    BEGIN
				    SIGNAL(dbg$_numtrunc);
				    c74$ms4b(dbg$deposit_source,dbg$deposit_target);
				    END;
				END;
			    [dsc$k_dtype_f] :
				BEGIN
				CVTFD(.dbg$deposit_source[dsc$a_pointer],dbl_value);
				ch$fill(%x'00',flting_buf_len,dbg$floating_buffer);
				for$cvt_d_tg(dbl_value,dbg$float_desc,float_fra_dig,scale_factor,
					digits_in_int,float_exp_dig);
				ch$fill(%x'00',12,sd);
				ch$move(8,dbg$float_desc,sd);
				dbg$digit_scan(.dbg$float_desc[dsc$a_pointer],.dbg$float_desc[dsc$w_length],sd);
				if c74$me4b(sd,dbg$deposit_target) neq 0
				then
				    begin
				    signal(dbg$_numtrunc);
				    c74$ms4b(sd,dbg$deposit_target);
				    end;
				END;
			    [dsc$k_dtype_d] :
				BEGIN
				ch$fill(%x'00',flting_buf_len,dbg$floating_buffer);
				for$cvt_d_tg(.dbg$deposit_source[dsc$a_pointer],dbg$dbl_desc,dbl_fra_dig,scale_factor,
					digits_in_int,dbl_exp_dig);
				ch$fill(%x'00',12,sd);
				ch$move(8,dbg$dbl_desc,sd);
				dbg$digit_scan(.dbg$dbl_desc[dsc$a_pointer],.dbg$dbl_desc[dsc$w_length],sd);
				if c74$me4b(sd,dbg$deposit_target) neq 0
				then
				    begin
				    signal(dbg$_numtrunc);
				    c74$ms4b(sd,dbg$deposit_target);
				    end;
				END;
			    [dsc$k_dtype_t] :
				BEGIN
				ch$move(12,dbg$deposit_source,sd);
				dstat = dbg$digit_scan(.dbg$deposit_source[dsc$a_pointer],.dbg$deposit_source[dsc$w_length],sd);
				if not .dstat
				then
				    signal(dbg$_invnumber,1,dbg$deposit_source);
				if c74$me4b(sd,dbg$deposit_target) neq 0
				then
				    begin
				    signal(dbg$_numtrunc);
				    c74$ms4b(sd,dbg$deposit_target);
				    end;
				END;
			    [dsc$k_dtype_ubs] :
				BEGIN
				IF .dbg$deposit_source[dsc$w_length]  GTR (8 * .dbg$deposit_target[dsc$w_length])
				THEN
				    BEGIN
					SIGNAL(DBG$_STGTRUNC);
					(.dbg$deposit_target[dsc$a_pointer]) = 
						.(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
									8 * .dbg$deposit_target[dsc$w_length]>
				    END
				ELSE 
					(.dbg$deposit_target[dsc$a_pointer]) =
					    (IF .dbg$deposit_source[dsc$_sgn_ext] 
						THEN
					    .(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
								   .dbg$deposit_source[dsc$w_length], 1>
						ELSE
					    .(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
								   .dbg$deposit_source[dsc$w_length], 0> );
				END;
			    [OTHERWISE] :
				BEGIN
				RETURN false;
				END;
			    TES;
			RETURN true;
			END;

GLOBAL ROUTINE dbg$deposit_type_p =

	! PACKED DECIMAL STRING, 21
			BEGIN
			SELECTONE .dbg$deposit_source[dsc$b_dtype]
			    OF
			    SET
			    [dsc$k_dtype_l] :
				BEGIN
				if c74$me4b(dbg$deposit_source,dbg$deposit_target) neq 0
				then
				    begin
				    signal(dbg$_numtrunc);
				    c74$ms4b(dbg$deposit_source,dbg$deposit_target);
				    end;
				END;
			    [dsc$k_dtype_f] :
				BEGIN
				CVTFD(.dbg$deposit_source[dsc$a_pointer],dbl_value);
				ch$fill(%x'00',flting_buf_len,dbg$floating_buffer);
				for$cvt_d_tg(dbl_value,dbg$float_desc,float_fra_dig,scale_factor,
					digits_in_int,float_exp_dig);
				ch$fill(%x'00',12,sd);
				ch$move(8,dbg$float_desc,sd);
				dbg$digit_scan(.dbg$float_desc[dsc$a_pointer],
					.dbg$float_desc[dsc$w_length],sd);
				if c74$me4b(sd,dbg$deposit_target) neq 0
				then
				    begin
				    signal(dbg$_numtrunc);
				    c74$ms4b(sd,dbg$deposit_target);
				    end;
				END;
			    [dsc$k_dtype_d] :
				BEGIN
				ch$fill(%x'00',flting_buf_len,dbg$floating_buffer);
				for$cvt_d_tg(.dbg$deposit_source[dsc$a_pointer],dbg$dbl_desc,dbl_fra_dig,scale_factor,
					digits_in_int,dbl_exp_dig);
				ch$fill(%x'00',12,sd);
				ch$move(8,dbg$dbl_desc,sd);
				dbg$digit_scan(.dbg$dbl_desc[dsc$a_pointer],
					.dbg$dbl_desc[dsc$w_length],sd);
				if c74$me4b(sd,dbg$deposit_target) neq 0
				then
				    begin
				    signal(dbg$_numtrunc);
				    c74$ms4b(sd,dbg$deposit_target);
				    end;

				END;
			    [dsc$k_dtype_t] :
				BEGIN
				ch$move(12,dbg$deposit_source,sd);
				dstat = dbg$digit_scan(.dbg$deposit_source[dsc$a_pointer],.dbg$deposit_source[dsc$w_length],sd);
				if not .dstat
				then
				    signal(dbg$_invnumber,1,dbg$deposit_source);
				if .sd[dsc$b_dtype] eql dsc$k_dtype_nro
				then
				    begin
				    if .sd[dsc$w_length] gtr 31
				    then
				        begin
					signal(dbg$_numtrunc);
					sd[dsc$w_length] = 31 ;
					end
				    end
				else
				    begin
				    if .sd[dsc$w_length] gtr 32
				    then
					begin
					signal(dbg$_numtrunc);
					sd[dsc$w_length] = 32 ;
					end
				    end;
				if c74$me4b(sd,dbg$deposit_target) neq 0
				then
				    begin
				    signal(dbg$_numtrunc);
				    c74$ms4b(sd,dbg$deposit_target);
				    end;
					
				END;
			    [dsc$k_dtype_ubs] :
				BEGIN
				IF .dbg$deposit_source[dsc$w_length]  GTR (8 * .dbg$deposit_target[dsc$w_length])
				THEN
				    BEGIN
					SIGNAL(DBG$_STGTRUNC);
					(.dbg$deposit_target[dsc$a_pointer]) = 
						.(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
									8 * .dbg$deposit_target[dsc$w_length]>
				    END
				ELSE 
					(.dbg$deposit_target[dsc$a_pointer]) =
					    (IF .dbg$deposit_source[dsc$_sgn_ext] 
						THEN
					    .(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
								   .dbg$deposit_source[dsc$w_length], 1>
						ELSE
					    .(.dbg$deposit_source[dsc$a_pointer])<.dbg$deposit_source[dsc$w_bit_offst],
								   .dbg$deposit_source[dsc$w_length], 0> );
				END;
			    [OTHERWISE] :
				BEGIN
				RETURN false;
				END;
			    TES;
			RETURN true;
			END;

GLOBAL ROUTINE dbg$deposit_type_g =

	! DOUBLE PRECISION G FLOATING, 64 BIT, 27
			BEGIN
			SELECTONE .dbg$deposit_source[dsc$b_dtype]
			    OF
			    SET
			    [dsc$k_dtype_l , dsc$k_dtype_lu] :
				BEGIN
				CVTLF(.dbg$deposit_source[dsc$a_pointer],dstat);
				CVTFD(dstat,dbl_value);
				! replaced call to mth$cvt_d_g with call
				! to cvt_d_g (at bottom of this module,
				! because mth$cvt_d_g didn't seem to
				! be working properly.
				cvt_d_g(dbl_value,.dbg$deposit_target[dsc$a_pointer]);
				END;
			    [dsc$k_dtype_f] :
				BEGIN
				CVTFD(.dbg$deposit_source[dsc$a_pointer],dbl_value);
				cvt_d_g(dbl_value,.dbg$deposit_target[dsc$a_pointer]);
				END;
			    [dsc$k_dtype_d] :
				BEGIN
				cvt_d_g(.dbg$deposit_source[dsc$a_pointer],.dbg$deposit_target[dsc$a_pointer]);
				END;
			    [dsc$k_dtype_t] :
				BEGIN
				dstat=ots$cvt_t_g(dbg$deposit_source,.dbg$deposit_target[dsc$a_pointer]);
				if not .dstat
				then
				    signal(dbg$_numtrunc);
				END;
			    [OTHERWISE] :
				BEGIN
				RETURN false;
				END;
			    TES;
			RETURN true;
			END;

GLOBAL ROUTINE dbg$deposit_type_h =

	! QUADRUPLE PRECISION FLOATING, 128 BIT, 28
			BEGIN
			SELECTONE .dbg$deposit_source[dsc$b_dtype]
			    OF
			    SET
			    [dsc$k_dtype_l , dsc$k_dtype_lu] :
				BEGIN
				CVTLF(.dbg$deposit_source[dsc$a_pointer],dstat);
				CVTFD(dstat,dbl_value);
				dbg$cvt_d_h(dbl_value,.dbg$deposit_target[dsc$a_pointer]);
				END;
			    [dsc$k_dtype_f] :
				BEGIN
				CVTFD(.dbg$deposit_source[dsc$a_pointer],dbl_value);
				dbg$cvt_d_h(dbl_value,.dbg$deposit_target[dsc$a_pointer]);
				END;
			    [dsc$k_dtype_d] :
				BEGIN
				dbg$cvt_d_h(.dbg$deposit_source[dsc$a_pointer],.dbg$deposit_target[dsc$a_pointer]);
				END;
			    [dsc$k_dtype_t] :
				BEGIN
				dstat=ots$cvt_t_h(dbg$deposit_source,.dbg$deposit_target[dsc$a_pointer]);
				if not .dstat
				then
				    signal(dbg$_numtrunc);
				END;
			   [OTHERWISE] :
				BEGIN
				RETURN false;
				END;
			    TES;
			RETURN true;
			END;

GLOBAL ROUTINE dbg$deposit_type_gc =

	! DOUBLE PRECISION COMPLEX, G FLOATING, 29
			BEGIN
			SELECTONE .dbg$deposit_source[dsc$b_dtype]
			    OF
			    SET
			    [dsc$k_dtype_l] :
				BEGIN
				CVTLF(.dbg$deposit_source[dsc$a_pointer],dstat);
				CVTFD(dstat,dbl_value);
				cvt_d_g(dbl_value,.dbg$deposit_target[dsc$a_pointer]);
				END;
			    [dsc$k_dtype_f] :
				BEGIN
				CVTFD(.dbg$deposit_source[dsc$a_pointer],dbl_value);
				cvt_d_g(dbl_value,.dbg$deposit_target[dsc$a_pointer]);
				END;
			    [dsc$k_dtype_d] :
				BEGIN
				cvt_d_g(.dbg$deposit_source[dsc$a_pointer],.dbg$deposit_target[dsc$a_pointer]);
				END;
			    [dsc$k_dtype_t] :
				BEGIN
				dstat=ots$cvt_t_g(dbg$deposit_source,.dbg$deposit_target[dsc$a_pointer]);
				if not .dstat
				then
				    signal(dbg$_numtrunc);
				END;
			    [OTHERWISE] :
				BEGIN
				RETURN false;
				END;
			    TES;
			RETURN true;
			END;

GLOBAL ROUTINE dbg$deposit_type_hc =

	! QUADRUPLE PRECISION COMPLEX, H FLOATING, 30
			BEGIN
			SELECTONE .dbg$deposit_source[dsc$b_dtype]
			    OF
			    SET
			    [dsc$k_dtype_l] :
				BEGIN
				CVTLF(.dbg$deposit_source[dsc$a_pointer],dstat);
				CVTFD(dstat,dbl_value);
				dbg$cvt_d_h(dbl_value,.dbg$deposit_target[dsc$a_pointer]);
				END;
			    [dsc$k_dtype_f] :
				BEGIN
				CVTFD(.dbg$deposit_source[dsc$a_pointer],dbl_value);
				dbg$cvt_d_h(dbl_value,.dbg$deposit_target[dsc$a_pointer]);
				END;
			    [dsc$k_dtype_d] :
				BEGIN
				dbg$cvt_d_h(.dbg$deposit_source[dsc$a_pointer],.dbg$deposit_target[dsc$a_pointer]);
				END;
			    [dsc$k_dtype_t] :
				BEGIN
				dstat=ots$cvt_t_h(dbg$deposit_source,.dbg$deposit_target[dsc$a_pointer]);
				if not .dstat
				then
				    signal(dbg$_numtrunc);
				END;
			    [OTHERWISE] :
				BEGIN
				RETURN false;
				END;
			    TES;
			RETURN true;
			END;

!++
! routine cvt_d_g
!
! purpose : 
!	Converts a d_float number to g_float format.
!
! inputs :
!	source -   a pointer to a 64 bit d_float number.
!	target -   a pointer to a 64 bit area where the g_float number
!		   is to be placed.
!
! outputs :
!	leaves the result in the target area.
!
! side effects :
!	none
!--

routine cvt_d_g(source, target) : novalue =

    begin

    map 
	source : ref vector[4,word],
	target : ref vector[4,word];

    local d_exp, g_exp;

    ! The fraction of the g_float number has 3 less bits of precision
    ! than the fraction of the d_float. Fill in bits 16 through 64 of
    ! the target (words 1 through 3) by shifting the source 3 bits.
    decr i from 3 to 1 do
	begin
	target[.i] = .source[.i]^-3;
	(target[.i])<13,3,0> = .(source[.i-1])<0,3,0>
	end;

    ! fill in the 4 most significant bits of the target's fraction:
    (target[0])<0,4,0> = .(source[0])<3,4,0>;

    ! fill in the exponent.
    d_exp = .(source[0])<7,8,0> - 128;
    g_exp = .d_exp + 1024;
    (target[0])<4,11,0> = .g_exp;

    ! fill in the sign bit
    (target[0])<15,1,0> = .(source[0])<15,1,0>

    end; ! cvt_d_g

END
ELUDOM
