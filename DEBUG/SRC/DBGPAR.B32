MODULE DBGPAR ( IDENT = 'V03-000') =
BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! FACILITY:	DEBUG
!
!++
! FUNCTIONAL DESCRIPTION:
!	Parser for MARS DEBUG syntax
!
! Version:	3-001
!
! History:
!	Author:
!		Carol Peters, 03 Jul 1976: Version 01
!
!	Modified by:
!		Mike Candela, 27 MARCH 1980
!		David Plummer, 15-DEC-1980
!		Richard Title 7-Jul-1980
!
! Revision history:
! 1.01	21-SEP-78	DAR	Made all routines global.  Deleted the
!				reduction routines and merged DBGSCA.B32
!				into this module.
! 1.02	25-SEP-78	MCC	Deleted require file SYSLIT.
! 1.03	17-OCT-78	MCC	Changed semantic stack from VECTOR to
!				BLOCKVECTOR to accomodate BLISS fields.
! 1.04	30-APR-79	MCC	Added routine dbg$get_filesp to get filespecs
!				from the input line.
! 1.05	16-JUL-79	MCC	Added routines to manipulate the command input
!				stream data structures.
! 1.06	17-JAN-80	MCC	Fixed error message report for long digit strings
! 1.07	29-JAN-80	MCC	Added routine dbg$get_help for HELP command
! 1.08	11-FEB-80	MCC	Fixed pars_a_line to correctly check for parse
!				stack overflow.
! 1.09	19-FEB-80	MCC	Fixed bug in dbg$get_help regarding "/"
! 2-10	27_MAR-80	MCC	Fixed bug in dbg$get_help concerning more than
!				10 keywords to librarian.
! 2-11  15-DEC-80	DLP	Modified HELP and @ facilities tor remove assorted
!				bugs
!       7 JUL 81        RT      Changed the keyword table in comkey.req.
!				Added keywords FLOAT, F_FLOAT, D_FLOAT, G_FLOAT
!				H_FLOAT, QUAD, OCTA_WORD to implement new
!				debugger types.      
! 3-01 24-Aug-81	RT	Added routine dbg$get_dir_list which parses
!				a directory list for the command
!				SET SOURCE dir-list
! 3-02 17-Dec-81	RT	Changed DBG$EMIT_HELP to use the new HELP
!				librarian.
!--

! Table of Contents:
!
FORWARD ROUTINE
	dbg$pars_a_line : NOVALUE,		! Parse an input (command) line
	dbg$get_bpt_act,			! Pick up DO action strings.
	dbg$extract_str,			! Pick up delimited strings.
	dbg$get_a_token,			! Returns token to parser.
	dbg$tran_lexeme,			! Translates "alpha_string" to token.
	dbg$get_filesp,				! Pick up a filespec
	dbg$cis_getfsp : NOVALUE,		! Get a filespec for an ind com file
	dbg$cis_connecticf : NOVALUE,		! Places icf into input stream
	dbg$cis_openicf : NOVALUE,		! Open an ind com file
	dbg$cis_remove : NOVALUE,		! Remove a link from the cis
	dbg$cis_add : NOVALUE,			! Add a link to the cis
	dbg$get_help : NOVALUE,			! Saves input for HELP
	dbg$emit_help : NOVALUE,		! Output HELP
	dbg$get_dir_list : NOVALUE;		! Parse a directory list.

!
! REQUIRE FILES:
!

REQUIRE 'src$:dbgprolog.req';
REQUIRE 'src$:DBGGEN.REQ';
REQUIRE 'src$:COMTER.REQ';
REQUIRE 'src$:comkey.req';
REQUIRE 'SRC$:SCALIT.REQ';
REQUIRE 'SRC$:SYSSER.REQ';

EXTERNAL ROUTINE
	dbg$sta_setcontext : NOVALUE,		! Sets registers context
	lbr$ini_control,			! Librarian init control table
	lbr$open,				! Librarian open library file
	lbr$close,				! Librarian close library file
	lbr$get_help,				! Librarian get help
	lbr$output_help,			! Librarian output help
    	lib$get_input,				! Librarian input routine
    	dbg$get_tempmem,			! allocate temporary memory
    	dbg$freez,				! allocate a block of free storage
	dbg$freerelease,			! return storage to free pool
    	dbg$nget_dir_list,			! new debugger parsing for 
    						! directory lists.
	dbg$set_mod_lvl;			! resets modes to a certain level

EXTERNAL
	dbg$gl_help_input,			! Pointer to input for HELP
	dbg$gl_ind_com_file,			! Pointer to icf filespec
	dbg$gl_partbptr: VECTOR,		! list of parse table addresses
	dbg$gl_reduc_rt,			! holds name of reduction routine
	dbg$gl_get_lex,				! holds name of lexical routine.
	dbg$char_table : VECTOR [,BYTE],	! character type table
    	dbg$gl_cishead : REF cis_link,
    	dbg$gl_inprab : BLOCK [,BYTE],		! RAB for input from DBG$INPUT
    	dbg$gl_outprab : BLOCK [,BYTE],		! RAB for output to DBG$OUTPUT
	dbg$gb_def_out : VECTOR [,BYTE],	! Current OUTPUT configuration
	dbg$gb_verptr  : REF VECTOR [,BYTE],	! pointer to input buffer for VERIFY
	dbg$gl_stk : semantic_stack;		! semantic stack for tokens, etc.

LITERAL
	dbg_par		= 0,		! for debugging
	dbg_par1	= 0,		! DBG$PARS_A_LINE
	dbg_par2	= 0,		! diagnostics in dbg$get_bpt_act
	dbg_par3	= 0,		! diagnostics in dbg$extract_str
	dbg_par4	= 0,		! diagnostics in dbg$get_filesp
	dbg_par5	= 0,		! diagnostics for cis / ind com files
	dbg_par6	= 0,		! diagnostics for dbg$get_help
	dbg_par_act	= 0,		! diagnostic before call to reduction routine.
	dbg_sca		= 0;		! diagnostics in dbg$tran_lexeme

BIND
	deficf_name	= UPLIT BYTE(%ASCII 'DEBUG.COM'),
	deficf_size	= %CHARCOUNT(%ASCII 'DEBUG.COM');
MACRO
	icf_message (prefix) =
	
	BEGIN
	BIND
		enter_phrase = UPLIT BYTE(8, %ASCII 'entering'),
		exit_phrase  = UPLIT BYTE(7, %ASCII 'exiting');

	LOCAL
		phrase;
	
	IF prefix EQL 1
	THEN
		phrase = enter_phrase
	ELSE
		phrase = exit_phrase;


	SIGNAL (dbg$_verifyicf, 3, .phrase, .fab_ptr[fab$b_fns], .fab_ptr[fab$l_fna]);	! Info message
    
	END % ;


GLOBAL ROUTINE dbg$pars_a_line (parse_stg_desc) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	PARSES A LINE OF DEBUG COMMANDS AND PERFORMS ASSOCIATED
!	ACTION ROUTINES.
!
! FORMAL PARAMETERS:
!	parse_stg_desc	- string descriptor of the buffer that holds
!			  the input string.
!
! IMPLICIT INPUTS:
!	The parsing tables whose base addresses are stored in the vector
!	DBG$GL_PARTBPTR.
!	The address of the reduction routine stored in DBG$GL_REDUC_RT.
!
! OUTPUTS:
!	OUTPUTS ARE THE EFFECTS OF THE ACTION ROUTINES CALLED.
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	NOVALUE
!
! SIDE EFFECTS:
!	none
!--

    BEGIN

	LITERAL
		!+
		! Constants required for the parser.
		!-
		CONT_CODE	= 9996,		! Continue in the State_table
		ELSE_CODE	= 9997,		! Else condition in the State_table
		SCAN_CODE	= 9998,		! Scan the State_table
		ERROR_CODE	= 9999,		! Error in the Action list

		!+
		! These are the offsets to each of the parse table
		! addresses.
		!-
		state_tbl_addr	= 0,	! address of transition state tables
		act_tbl_addr	= 1,	! address of action tables
		pop_tbl_addr	= 2,	! address of pops per reduction tables
		lhs_tbl_addr	= 3,	! address of left hand side identifier tables
		sem_tbl_addr	= 4;	! address of semantic action tables

	BIND
		!+
		! These binds substitute simple names for the addresses
		! of each of the parsing tables.
		!-
		state_tables	= .dbg$gl_partbptr [state_tbl_addr] : VECTOR [, WORD],
		action_table	= .dbg$gl_partbptr [act_tbl_addr] : VECTOR [, WORD, SIGNED],
		pop_table	= .dbg$gl_partbptr [pop_tbl_addr] : VECTOR [, BYTE],
		left_h_side_tbl	= .dbg$gl_partbptr [lhs_tbl_addr] : VECTOR [, BYTE],
		semantics_table	= .dbg$gl_partbptr [sem_tbl_addr] : VECTOR [, WORD];

		!+
		! This bind names the appropriate reduction routine
		! for the current language.
		!-
		BIND ROUTINE reduction = .dbg$gl_reduc_rt;

	LOCAL
		action_to_take,					! ACTION FROM action_table
		cur_parse_state,				! THE STATE OF THE PARSE MACHINE
		j,						! CONTROL VARIABLE
		lexeme_addr: VECTOR [chs_per_lexeme, BYTE],	! BUFFER FOR STRING LEXEME
		lahead_addr: VECTOR [chs_per_lexeme, BYTE],	! buffer for a lookahead
		lex_stg_desc: BLOCK [12, BYTE],			! string descriptor for lexemes
		lahead_stg_desc: BLOCK [12, BYTE],		! lookahead for one lexeme
		last_stg_desc: BLOCK [8, BYTE],		! previous place in parse_stg_desc
		match_transit,					! BOOLEAN, TRUE IF MATCHING TRANSITION IS FOUND
		next_token,					! SAVES NEXT token
		old_j,						! saves state 
		old_token,					! saved token
		parse_more,					! boolean, says whether to parse more
		parse_stack: VECTOR [max_stack_ptr, WORD],	! PARSE STATE STACK
		reduce_was_last,				! TRUE IF REDUCTION WAS LAST ACTION
		scan_next_sym,					! BOOLEAN, TRUE IF NEXT SYMBOL NEEDS TO BE SCANNED
		stack_ptr,					! STACK INDEX
		token,						! HOLDS LATEST token
		transit_code;					! TRANSITION CODE FROM state_tables

	MAP
		parse_stg_desc	: REF BLOCK [, BYTE];

	LABEL
		match_loop;

	! Initialize registers context to default

	dbg$sta_setcontext (0);

	!+
	! INITIALIZE CONTROL VARIABLES. GET A token FROM THE INPUT STRING.
	!-
	old_token = 0;
	reduce_was_last = FALSE;
	stack_ptr = 0;

	lex_stg_desc [dsc$w_length] = 0;
	lex_stg_desc [dsc$w_maxlen] = chs_per_lexeme;
	lex_stg_desc [dsc$a_pointer] = lexeme_addr;
	lahead_stg_desc [dsc$a_pointer] = lahead_addr;
	lahead_stg_desc [dsc$w_maxlen] = chs_per_lexeme;

	! We maintain a 'last' string descriptor which is always
	! what 'parse_stg_desc' was before the last time it was changed.

	last_stg_desc[ DSC$W_LENGTH ] = .parse_stg_desc[ DSC$W_LENGTH ];
	last_stg_desc[ DSC$A_POINTER ] = .parse_stg_desc[ DSC$A_POINTER ];

%IF dbg_par1
%THEN
	$fao_tt_out ('in parse: input string is !AS', .parse_stg_desc);
%FI

	! Initialize the input buffer pointer for VERIFY

	dbg$gb_verptr = .parse_stg_desc [dsc$a_pointer];

	!+
	! Pick up the first token in the command string.
	!-

	token = dbg$get_a_token (.parse_stg_desc, lex_stg_desc);

%IF dbg_par1
%THEN

	$fao_tt_out ('first token is !SL', .token);
	IF .lex_stg_desc[dsc$w_length] GTR 0
	THEN	
		$fao_tt_out ('lex_stg_desc : !AS', lex_stg_desc)
	ELSE
		$fao_tt_out ('lex_stg_desc : 0');
	$fao_tt_out ('in parse: input string is !AS', .parse_stg_desc);
%FI

	cur_parse_state = 0;
	scan_next_sym = TRUE;
	parse_more = TRUE;
	match_transit = FALSE;

	! THIS IS THE MAIN LOOP OF THE PARSER. IT CONTINUES
	! UNTIL THE VARIABLE "parse_more" HAS A VALUE OF FALSE.
	!
	DO
	    BEGIN
	    j = .cur_parse_state;
	    ! THE FOLLOWING LOOP SEARCHES FOR A MATCHING token
	    ! AND EXITS WHEN A MATCH IS FOUND.
	    !
	    DO
match_loop:	BEGIN
		match_transit = FALSE;
		transit_code = .state_tables [.j];

		!+
		! See whether this transit code is an else code,
		! and at the same time the token is a keyword
		! token. In these circumstances, try passing
		! through the loop again with the pretense
		! that the token is a alpha_str_token. The current
		! token and state must be saved so that
		! if alpha_str_token does not make a valid sentence,
		! then the effect of the else code can be
		! reestablished.
		!-
		IF (.transit_code EQL else_code) AND (.token LEQ keyword_range)
		THEN
		    BEGIN
		    old_token = .token;
		    old_j = .j;
		    j = .cur_parse_state;
%IF dbg_par1
%THEN
		    $fao_tt_out ('retrying token !SL as name token', .token);
%FI
		    token = alpha_str_token;
		    LEAVE match_loop;
		    END;

		!+
		! Now allow for restoring the original token
		! in the case that the newly inserted alpha_str_token
		! brought no better results.
		!-
		IF (.transit_code EQL else_code) AND (.token EQL alpha_str_token)
				AND (.old_token NEQ 0)
		THEN
		    BEGIN
		    token = .old_token;
		    j = .old_j;
		    old_token = 0;
%IF dbg_par1
%THEN
		    $fao_tt_out ('restoring token !SL and state !SL', .token, .j);
%FI
		    END;

		!+
		! No special handling here. Just compare the
		! token and the transit code.
		!-
		IF (.transit_code EQL .token) OR (.transit_code EQL else_code)
		THEN

		    !+
		    ! A MATCH HAS BEEN FOUND, SO THE LEXICAL STRING CAN BE
		    ! READ OR REDUCED.
		    !-
		    BEGIN
		    match_transit = TRUE;
		    action_to_take = .action_table [.j];
%IF dbg_par1
%THEN
		    $fao_tt_out ('match is !SL, action is !SL',
					.transit_code, .action_to_take);
%FI
		    IF .action_to_take NEQ error_code
		    THEN

			BEGIN
			IF .action_to_take GTR - scan_code
			THEN

			    !+
			    ! NOTHING ELSE TO SCAN. PERFORM THE ASSOCIATED ACTION ROUTINE
			    ! FOR THIS LEXICAL ENTITY.
			    !-
			    BEGIN
			    parse_stack [.stack_ptr] = .cur_parse_state;

			    !+
			    ! Put the token on the top of the parse stack
			    !-
			    IF NOT .reduce_was_last
			    THEN dbg$gl_stk [.stack_ptr, stk$v_val1] = .token;
			    END;
				
			IF .action_to_take GEQ 0
			THEN

			    ! THIS IS A READ STATE
			    !
			    BEGIN
			    cur_parse_state = .action_to_take;
			    reduce_was_last = FALSE;
			    IF .stack_ptr + 1 GEQ max_stack_ptr
			    THEN
				! Stack overflow error
				SIGNAL(dbg$_parstkovr)
				! no return
			    ELSE
				BEGIN

				! Decrement the stack pointer and clear out
				! the new top-of-stack so that there is no info
				! 'left around' therein which may cause later
				! confusion.

				stack_ptr = .stack_ptr + 1;
				dbg$gl_stk [.stack_ptr, stk$v_val1]   = 0;
				dbg$gl_stk [.stack_ptr, stk$v_val2]   = 0;
				dbg$gl_stk [.stack_ptr, stk$v_type]   = 0;
				dbg$gl_stk [.stack_ptr, stk$v_nt_ptr] = 0;
				dbg$gl_stk [.stack_ptr, stk$v_index]  = 0;
				dbg$gl_stk [.stack_ptr, stk$v_offset] = 0;
				dbg$gl_stk [.stack_ptr, stk$v_pos]    = 0;
				dbg$gl_stk [.stack_ptr, stk$v_size]   = 0;
				dbg$gl_stk [.stack_ptr, stk$v_ext]    = 0;
				dbg$gl_stk [.stack_ptr, stk$v_ref]    = 0;
				dbg$gl_stk [.stack_ptr, stk$v_immed]  = 0;
				dbg$gl_stk [.stack_ptr, stk$v_args]   = 0;
				dbg$gl_stk [.stack_ptr, stk$v_fldrf]  = 0;
				dbg$gl_stk [.stack_ptr, stk$v_dot]    = 0;
				dbg$gl_stk [.stack_ptr, stk$v_struc]  = 0;
				END;

			    ! NOW INPUT THE NEXT token IF MORE READING IS NECESSARY.
			    !
			    IF .scan_next_sym
			    THEN 
				BEGIN
				zerocor (.lahead_stg_desc [dsc$a_pointer],
					(.lahead_stg_desc [dsc$w_maxlen] / 4));
				lahead_stg_desc [dsc$w_length] =
					.lex_stg_desc [dsc$w_length];
				ch$move (.lex_stg_desc [dsc$w_length],
					.lex_stg_desc [dsc$a_pointer],
					.lahead_stg_desc [dsc$a_pointer]);
				last_stg_desc[ DSC$W_LENGTH ] = .parse_stg_desc[ DSC$W_LENGTH ];
				last_stg_desc[ DSC$A_POINTER ] = .parse_stg_desc[ DSC$A_POINTER ];
				token = dbg$get_a_token (.parse_stg_desc, lex_stg_desc);
%IF dbg_par1
%THEN
				$fao_tt_out ('token is !SL', .token);
				IF .lex_stg_desc[dsc$w_length] GTR 0
				THEN	
					$fao_tt_out ('lex_stg_desc : !AS', lex_stg_desc)
				ELSE
					$fao_tt_out ('lex_stg_desc : 0');

%FI
				END

			    ELSE

				! IF NO MORE SCANNING IS NEEDED, PUT THE NEXT token IN
				! THE VARIABLE "token".
				BEGIN
				scan_next_sym = TRUE;
				token = .next_token;
				END;

			    ! THIS IS THE END OF THE READ.
			    !
			    END

			ELSE

			    ! THIS IS A REDUCTION.
			    !
			    BEGIN
			    IF .action_to_take LEQ - scan_code
			    THEN
				! THIS IS A NOSCAN REDUCTION, WHICH TAKES AN
				! EXTRA STACK POP.
				!
				BEGIN
				action_to_take = .action_to_take + scan_code;
				scan_next_sym = FALSE;
				stack_ptr = .stack_ptr - 1;
				next_token = .token;
				END;

			    action_to_take = - .action_to_take;
			    stack_ptr = .stack_ptr - .pop_table [.action_to_take] ;
			    cur_parse_state = .parse_stack [.stack_ptr];
			    token = .left_h_side_tbl [.action_to_take];
			    reduce_was_last = TRUE;
			    !+
			    ! Call the proper reduction routine to get the
			    ! action performed.
			    !-
%IF dbg_par_act
%THEN
			    $fao_tt_out ('action index = !SB, token = !SL',
					.semantics_table[.action_to_take], .token);
%FI
			    IF NOT reduction (.semantics_table[.action_to_take],
				.stack_ptr, lex_stg_desc, lahead_stg_desc, .parse_stg_desc)
			    THEN
				RETURN;
%IF dbg_par1
%THEN
			    $fao_tt_out ('semsp is !SL', .stack_ptr);
%FI
			    END;

			END

		    !+
		    ! This is the error_code processing.  We attempt to 
		    ! give some indication of where we were when the
		    ! error was detected.  This is difficult only for
		    ! numbers.
		    !-
		    ELSE
			BEGIN
			IF( .token EQL EOL_TOKEN )
			THEN
				begin
				signal(dbg$_needmore);
				! no return
				end
			ELSE
			IF( .token EQL DIGIT_STR_TOKEN )
			OR( .token EQL L_DIG_STR_TOKEN )
			THEN
				BEGIN

				! Truncate the string to 10 characters
				! unless it is already smaller than that.
				
				IF( .last_stg_desc[ DSC$W_LENGTH ] GTR 10 )
				THEN
					last_stg_desc[ DSC$W_LENGTH ] = 10;
				signal( DBG$_SYNTAX, 1, last_stg_desc )
				! no return
				END
			ELSE
				BEGIN

				! The lex string buffer contains the token
				! which caused the command to be rejected.

				SIGNAL (dbg$_syntax, 1, lex_stg_desc);
				! no return
				END;
			END
		    END

		ELSE

		    IF .transit_code EQL cont_code
		    THEN j = .action_table [.j]
		    ELSE j = .j + 1;

		END

	    UNTIL .match_transit
	    END

	WHILE .parse_more;
    END;

GLOBAL ROUTINE dbg$get_bpt_act (parse_stg_desc) =
!++
! Functional Description:
!
!	This routine is essentially like dbg$extract_str()
! except that the bounding characters are "(" and ")" instead
! of "'", and nesting of parentheses is allowed.  This routine
! is called when the opening parenthesis of a list of breakpoint
! actions is encountered.  The breakpoint actions are collected
! but not lexically or semantically scanned.  Storage is reserved 
! for the new string, and a pointer to this storage is returned.
!
!	A further complication for this routine but not for
! exact_string, is that we can't just go blindly charging on
! looking for matching parenthesis.  i.e. we can't get 
! fooled by:
!
!	DBG>set b X do (d/as .=')'; etc)
!
! We resolve this problem by NOT paying any attention to characters
! inside quoted strings within the DO action string.
!
! Routine Value
!
!	A pointer to the action string.
!
! Side Effects:
!
!	Storage may be allocated to contain the string.
!
!	If an error is encountered, a SIGNAL/UNWIND is generated
! and the associated error message is output.
!--
BEGIN
	MAP
		parse_stg_desc : REF BLOCK [, BYTE];

	LOCAL
		pointer: REF VECTOR [, BYTE],	! holds address of dynamic storage for
						! action string when collected
		paren_count,			! count of paren levels
		char,				! holds a single character
		count,				! character count
		input_ptr,			! current pointer to input string
		in_string,			! 0 => we are not currently within
						! an embedded quoted string.  Otherwise
						! we are, and .in_string is the
						! string delimiter (' or ").
		temp_ptr : BLOCK[8,byte];	! string descriptor for
						! embedded quoted strings.

%IF dbg_par2
%THEN
	$fao_tt_out('action string is "!AS".',.parse_stg_desc);
%FI
	input_ptr = ch$ptr (.parse_stg_desc [dsc$a_pointer]);
	count = 0;
	in_string = 0;
	temp_ptr[DSC$A_POINTER] = 0;
	paren_count = 1;

	REPEAT
		BEGIN

		! Pick up the next character and see if we
		! have run off the end of the string.

		char = ch$rchar (.input_ptr);
		IF .char EQL 0
		THEN
			BEGIN
			LOCAL
				delimiter;

			! The string we complain about not begin delimited
			! is either the supposed break action string, or
			! a non-terminated embedded quoted string.

			IF( .temp_ptr[ DSC$A_POINTER ] NEQ 0 )
			THEN
				BEGIN

				! We didn't find the ending ')' for the break
				! action string because an embedded ascii 
				! string was not properly terminated.

				parse_stg_desc[DSC$A_POINTER] = .temp_ptr[DSC$A_POINTER];
				parse_stg_desc[DSC$W_LENGTH] = .temp_ptr[DSC$W_LENGTH];
				delimiter = .in_string;
				END
			ELSE
				BEGIN

				! The action string itself was not terminated.

				delimiter = %C')';

				! Adjust the string descriptor so that the
				! beginning delimiter is seen since this
				! gives the user more info about what we
				! were looking for.

				parse_stg_desc[DSC$A_POINTER] = .parse_stg_desc[DSC$A_POINTER] -1;
				parse_stg_desc[DSC$W_LENGTH] = .parse_stg_desc[DSC$W_LENGTH] +1;
				END;

			! Truncate the string to 10 characters
			! unless it is already smaller than that.
				
			IF( .parse_stg_desc[ DSC$W_LENGTH ] GTR 10 )
			THEN
				parse_stg_desc[ DSC$W_LENGTH ] = 10;

			signal(dbg$_noend, 3, .parse_stg_desc, 1, delimiter);
			! no return
			END;

		! If we are not already in an embedded quoted string,
		! then this may be the beginning of one.  If we are,
		! then this may be the end of it.

		IF( .char EQL %C'''' OR .char EQL %C'"' )
		THEN
			BEGIN

			! in_string tells not only whether or not we
			! are in a quoted string, but what that
			! string is delimited by.

			IF( .in_string EQL 0 )
			THEN
				BEGIN

				! Now we are within a string.  Save the
				! delimiter so we can find the end of it.

				in_string = .char;

				! Also save a string descriptor for this string
				! as we may need it for later error processing.
				! This string descriptor includes the supposed
				! delimiting character.

				temp_ptr[DSC$A_POINTER] = .input_ptr;
				temp_ptr[DSC$W_LENGTH] = .parse_stg_desc[DSC$W_LENGTH ] - .count;
				END
			ELSE
				! See if this quote ends the string we
				! were already in.

				IF( .in_string EQL .char )
				THEN
					BEGIN

					! End the string we were in.

					in_string = 0;
					temp_ptr[DSC$A_POINTER] = 0;
					END;
			END
		ELSE

		! If we are already in an embedded string, and there
		! is no chance that it is ending, then we don't care
		! what the current character is.  Otherwise we
		! have to look for parenthesis.

		IF( .in_string EQL 0 )
		THEN
			! We are not in an embedded string.
			! Now we sort out the parenthesis matching.
	
			IF( .char EQL %C')' )
			THEN
				BEGIN
	
				!+
				! Found a closing parenthesis. See
				! whether this one matches the opening
				! breakpoint action parenthesis, and
				! if it does, then exit from this loop,
				! and thus from the macro.
				!-
				paren_count = .paren_count - 1;
				IF .paren_count LEQ 0
				THEN
					BEGIN
					EXITLOOP
					END;
				END
			ELSE
				IF( .char EQL %C'(' )
				THEN
					paren_count = .paren_count + 1;

		! Increment the character counter, update the pointer
		! so that we are looking at the next character,
		! and loop back to do so.

		count = .count + 1;
		input_ptr = ch$plus (.input_ptr, 1);
		END;

	!+
	! The breakpoint action string has been isolated.
	!-
%IF dbg_par2
%THEN
	$fao_tt_out('action string of length !UL = "!AD".',
		.count,.count,.parse_stg_desc[DSC$A_POINTER]);
%FI
	!+
	! We want the string address to be the address of a buffer in
	! dynamic memory.  If such a buffer cannot be allocated,
	! a SIGNAL is generated and an UNWIND is done.  The number
	! of bytes we need to allocate is the action string size +1
	! because we need 1 more byte to hold the count.
	!-

	count = .count +1;
	pointer = dbg$freez ((.count + 1) / %UPVAL + 1);

	!+
	! Copy the action string from the input
	! buffer, and then overwrite the character before
	! the string begins so that is becomes a counted string
	! action buffer.  We also ensure that there is a 0
	! character at the end of the buffer to ensure proper
	! termination of parsing it when the break happens.
	!-

	ch$move (.count, .parse_stg_desc[DSC$A_POINTER]-1, pointer [0]);
	pointer [0] = .count;
	pointer[.count] = 0;

	!+
	! Now update the parse string descriptor to address
	! the character after the closing parenthesis.
	!-

	parse_stg_desc [dsc$a_pointer] = ch$plus (.input_ptr, 1);

	! Return a pointer to the saved-away action buffer.

	RETURN(.pointer);
END;

GLOBAL ROUTINE dbg$extract_str (parse_stg_desc) =
!++
! Functional Description:
! 	This routine reads characters from the input string,
! picks up the delimiting character ( ' or " ), and reads until
! the next occurance of that character is found.  If none
! is found, the invalid string message is output, and end of
! line processing is done.  Otherwise, dynamic storage is
! allocated for the string, which is then transformed into a
! counted string.  The address of this new storage is returned
! as the value of the function.
!
! Formal Parameters:
!
!	parse_stg_desc	-the address of the string descriptor which
!			 is where the parser is at (i.e. where the
!			 supposed string begins).
!
! Implicit Inputs:
!
!	The delimiting character is exactly 1 character before the
! given string.
!
! Routine Value:
!	The address of dynamic storage we allocated for the string.
!
! Side Effects:
!	Dynamic storage is allocated for the string.  Later, (in link_arg),
! the address of this storage is passed on via the command arg
! list's STORE field, so that FREE_ARG (dbglst.b32) can free it up.
!
!	The given (formal parameter) string descriptor is updated
! to reflect the extraction of the quoted string from the input
! command line.  Parsing resumes from this position.
!--
BEGIN
	MAP
			! The input parameter is a pointers to string
			! descriptor.
		parse_stg_desc : REF BLOCK [, BYTE];

	LOCAL
		char,
		count,
		delimiter,
		input_ptr,
		temp_ptr : ref vector[,byte];

	! Pick up a pointer to the supposed ASCII or INSTRUCTION string.

	input_ptr = ch$ptr (.parse_stg_desc [dsc$a_pointer]);

	! The string delimiter is assumed to be the character
	! immediately BEFORE where the indicated string begins.

	input_ptr = ch$plus (.input_ptr, -1);
	temp_ptr = .input_ptr;
	delimiter = ch$rchar_a (input_ptr);

%IF dbg_par3
%THEN
	$fao_tt_out ('string delimiter is "!AD"', 1, delimiter);
%FI

	count = 0;
	REPEAT
		BEGIN
		char = ch$rchar_a (input_ptr);
		IF .char EQL 0
		THEN
			BEGIN

			! Adjust the string descriptor so that the
			! beginning delimiter is seen since this
			! gives the user more info about what we
			! were looking for.

			parse_stg_desc[DSC$A_POINTER]= .parse_stg_desc[DSC$A_POINTER] -1;
			parse_stg_desc[DSC$W_LENGTH]= .parse_stg_desc[DSC$W_LENGTH] +1;

			! Truncate the string to 10 characters
			! unless it is already smaller than that.
				
			IF( .parse_stg_desc[ DSC$W_LENGTH ] GTR 10 )
			THEN
				parse_stg_desc[ DSC$W_LENGTH ] = 10;

			signal(dbg$_noend, 3, .parse_stg_desc, 1, delimiter);
			! no return
			END;

		IF( .char EQL .delimiter )
		THEN
			! Found a closing quote so we're done.
			EXITLOOP;

		! Go back to look at the next character in the string.
		count = .count + 1;
		END;

	!+
	! Quoted string found and 'count' gives its size.
	!-

%IF dbg_par3
%THEN
	$fao_tt_out('string of length !SL is "!AD".',
		.count,.count,.temp_ptr+1);
%FI
	! Reserve dynamic storage for this string plus its count.
	! If there is not enough such storage, the
	! following call does NOT return.  If it does, make
	! the new storage contain the counted string.

	count = .count + 1;
	temp_ptr = dbg$freez( RST_UNITS(.count) );
	ch$move(.count, .parse_stg_desc[DSC$A_POINTER]-1, .temp_ptr);
	temp_ptr[0] = .count-1;

%IF dbg_par3
%THEN
	$fao_tt_out ('new string is "!AC", length is !SL', .temp_ptr, .count);
%FI
	!+
	! Now update the parse string descriptor so that the
	! address of the buffer is the address of the character
	! after the closing quote.  Likewise update the length.
	!-
	parse_stg_desc [dsc$a_pointer] = ch$ptr (.input_ptr);
	parse_stg_desc [dsc$w_length] = .parse_stg_desc [dsc$w_length] - .count;

	! Return a pointer to this counted string.

	return(.temp_ptr);
END;

GLOBAL ROUTINE dbg$get_a_token (input_stg_desc, lexeme_stg_desc) =
!++
! Functional description:
!	Extracts a lexeme from the input stream by calling the routine
!	dbg$???_get_lex. Translates the lexeme to a token (sometimes a
!	null operation). Returns the token as the routine value and
!	the ASCII string representing the token in the character string
!	pointed to by the pointer field of lexeme_stg_desc. Also returns
!	the actual length of the ASCII string of the lexeme in the
!	length field of lexeme_stg_desc.
!
!	The pointer to the input buffer is updated and rewritten into
!	the pointer field of input_stg_desc.
!
! Formal parameters:
!	input_stg_desc	- string descriptor to the input buffer.
!	lexeme_stg_desc	- varying string descriptor to the lexeme buffer.
!
! Implicit inputs:
!	none
!
! Implicit outputs:
!	The mode level is set to local.
!
! Routine value:
!	an encoded representation of the token found.
!
! Side effects:
!	none
!--

	BEGIN

	MAP
		lexeme_stg_desc: REF BLOCK [, BYTE];	! descriptor of lexeme string

	LOCAL
		lexeme_type;				! type of lexeme found

	!+
	! Fill the lexeme buffer with zeroes.
	!-
	ZEROCOR (.lexeme_stg_desc [dsc$a_pointer], (.lexeme_stg_desc [dsc$w_maxlen] / 4));
	dbg$set_mod_lvl (local_mode);			! set mode level to local
	lexeme_type = (.dbg$gl_get_lex) (.input_stg_desc, .lexeme_stg_desc);
	IF .lexeme_type EQL alpha_str_token
	THEN RETURN dbg$tran_lexeme (.lexeme_stg_desc, keyword_table)
	ELSE RETURN .lexeme_type;
	END;						! end of dbg$get_a_token

GLOBAL ROUTINE dbg$tran_lexeme (lexeme_stg_desc, keyword_tbl) =
!++
! Functional description:
!	Maps an alphabetic string onto an element in the keyword table.
!	If the alphabetic string does not match a keyword, then
!	"alpha_str_token" is returned. If the alphabetic string does match
!	a keyword, then the token for the keyword is abstracted from
!	the keyword table and returned.
!
! Formal parameters:
!	lexeme_stg_desc	- varying string descriptor for lexeme string
!	keyword_tbl	- Address of the keyword table where this routine
!			  looks for a match.
!
! Implicit inputs:
!	The keyword table for the current DEBUG language.
!
! Implicit outputs:
!	none
!
! Routine value:
!	The token for the keyword that matches the ASCII string,
!	or "alpha_str_token", if no keyword matches the string.
!
! Side effects:
!	none
!--

	BEGIN

	MAP
		lexeme_stg_desc: REF BLOCK [, BYTE],	! lexeme string descriptor
		keyword_tbl: REF VECTOR [, BYTE];	! keyword table

	LOCAL
		keyword_entry : REF VECTOR [, BYTE];	! address of a keyword record;

%IF dbg_sca
%THEN
	$fao_tt_out ('string is "!AS"', .lexeme_stg_desc);
%FI

	keyword_entry = keyword_tbl [0];
	DO
		BEGIN
		!+
		! If the length of the keyword is at least as long as
		! the lexeme found, and the lexeme found is at least as
		! long as the abbreviation of the keyword, then try
		! to match the strings.
		!-
		IF .keyword_entry [kword_length] GEQ .lexeme_stg_desc [dsc$w_length]
			AND .lexeme_stg_desc [dsc$w_length] GEQ .keyword_entry [kword_abbrev]
		THEN
			BEGIN

%IF dbg_sca
%THEN
			$fao_tt_out ('keyword is "!AD"', .keyword_entry [kword_length], keyword_entry [kword_name]);
%FI

			IF ch$eql (.lexeme_stg_desc [dsc$w_length],
					ch$ptr (.lexeme_stg_desc [dsc$a_pointer]),
					.lexeme_stg_desc [dsc$w_length],
					ch$ptr (keyword_entry [kword_name]))
			!+
			! Keyword match found. Return the token
			! equivalent.
			!-
			THEN RETURN .keyword_entry [kword_token];
			END;
		!+
		! Keyword did not match. Advance the table pointer to
		! point to the next entry. If the first byte of this
		! next entry is zero, conclude that the table is
		! exhausted, and just return the name_token.
		!-
		keyword_entry = keyword_entry [0]
				+ .keyword_entry[kword_length] + kword_overhead;
		END
	UNTIL (.keyword_entry [kword_token] EQL 0);
	RETURN alpha_str_token;
	END;


GLOBAL ROUTINE dbg$get_filesp (lex_stg_desc, parse_stg_desc)  =
!++
! FUNCTIONAL DESCRIPTION
!
! 	This routine collects a filespec from the input string.
! The string is read until a zero or carriage return character is encountered.
! Quotes are optional. If a leading quote was given, a trailing quote will be
! scanned for.
! 	Because of constraints in the current grammars, lex_stg_desc contains the
! part of the filespec up to the first "punctuation mark" (i.e. the first
! "alpha string" of the filespec).This is concatenated with the results obtained
! by this routine to give the complete filespec. Dynamic storage is allocated
! to contain the filespec and the address of this storage is returned as the
! routine's value. 
!
! FORMAL PARAMETERS
! 	
! 	lex_stg_desc -   The address of the string descriptor containing the
!			 previous lexeme (the first part of the filespec in
!			 this case).
!	parse_stg_desc - The address of the remaining piece of the input string.
!			 (where the parser left off).
!
! IMPLICIT INPUTS
!	
!	none
!
! IMPLICIT OUTPUTS
!	
!	none
!
! ROUTINE VALUE
!
!	The address where the counted string containing the filespec is saved
!
! SIDE EFFECTS
!
!	Dynamic storage is allocated for the string. The parse string descriptor
!	is updated to reflect the extraction of the filespec from the input
!	command line. Parsing resumes from this point.
!--

BEGIN

	MAP
		parse_stg_desc : REF BLOCK [, BYTE],
		lex_stg_desc   : REF BLOCK [, BYTE];
	
	LOCAL 
		char,
		temp,
		count,
		input_ptr,
		quote_flag: byte,	
		icf_flag : byte,
		filesp_buf : REF VECTOR [,BYTE];

	icf_flag = 0;
	quote_flag = 0;
	input_ptr = ch$ptr (.parse_stg_desc [dsc$a_pointer]);
	char = ch$rchar (.input_ptr);
	
	! If an optional quote delimiter was supplied, it will be the only
	! character in lex_stg_desc. Also, if this routine was called to
	! pick up the filespec of an indirect command file "@" will be the
	! only character in lex_stg_desc.

	IF ..lex_stg_desc[dsc$a_pointer] EQL asc_quote
	OR ..lex_stg_desc[dsc$a_pointer] EQL asc_doub_quote
	THEN
		quote_flag = 1;

	IF ..lex_stg_desc[dsc$a_pointer] EQL asc_at_sign
	THEN
		icf_flag = 1;
%IF dbg_par4
%THEN
	$fao_tt_out ('get_filesp: parse_stg_desc !AS',.parse_stg_desc);
	$fao_tt_out ('first file spec character is "!AD"', 1, char);
	$fao_tt_out ('quote_flag !SB', .quote_flag);
%FI

	count = 0;

	REPEAT
		BEGIN
		IF oneof(.dbg$char_table[.char], end_of_line)
		THEN
			BEGIN


			IF .quote_flag EQL 1	! true if leading, but no terminating quote
			THEN
			    SIGNAL(dbg$_noend, 3, .parse_stg_desc, 1, .lex_stg_desc[dsc$a_pointer]);

			!++
			! Found the end of the file specification.
			!--
			EXITLOOP
			END;

		! Check for quote character (either ' or " )


		IF oneof(.dbg$char_table[.char], quote)
		THEN
			BEGIN
			quote_flag = .quote_flag + 1;
			IF .quote_flag EQL 1
			THEN
			     SIGNAL(dbg$_invchar);	! no return				

			! advance pointer over the quote


			input_ptr = ch$plus(.input_ptr, 1);
			parse_stg_desc[dsc$w_length] = .parse_stg_desc[dsc$w_length] - 1;
			EXITLOOP;
			END;


		! If we have a comment, we must have reached
		! the end of the filespec

		IF .dbg$char_table[.char] EQL ind_comment
		THEN
			EXITLOOP;


		! If we have a ";", the next character has to
		! be examined to see if we should terminate 
		! collection of the filespec.

		IF .dbg$char_table[.char] EQL semi_colon
		THEN			
		    BEGIN		! look ahead
		    LOCAL
			la_char,
			temp;
		    temp = .input_ptr;
		    la_char = ch$a_rchar (temp);

		    WHILE oneof(.dbg$char_table[.la_char], blanks)
		    DO
			la_char = ch$a_rchar (temp);

		    ! If we don't have one of these characters
		    ! we have reached the end of the filespec

		    IF NOT oneof(.dbg$char_table[.la_char], numeric, quote)
		    THEN
			BEGIN
			IF .quote_flag EQL 1
			THEN
			    SIGNAL(dbg$_noend, 3, .parse_stg_desc,
				    1, .lex_stg_desc[dsc$a_pointer]);
			EXITLOOP;
			END;
		    END;

		count = .count + 1;
		char = ch$a_rchar (input_ptr);
		END;


%IF dbg_par4
%THEN
	$fao_tt_out ('character after file spec is "!AD"', 1, char);
	$fao_tt_out ('total file spec count is !SL', .count);
%FI

	!++
	! Now put the address of the file specification into
	! a buffer allocated from dynamic storage.
	! The number of bytes we need to allocate is one greater than
	! the filespec size due to the need to store the count. Dont forget
	! we must also add in the length of the lex_stg_desc only if no quote
	! delimiters were supplied.
	!--
	IF .quote_flag EQL 2
	OR .icf_flag   EQL 1
	THEN
		temp = .count + 1
	ELSE
		temp = .count + .lex_stg_desc[dsc$w_length] + 1;

	filesp_buf = dbg$freez((.temp+1) / %UPVAL + 1);
	
	! Copy the complete filespec to the new buffer and save the count
	! in the first byte
	! If we had quotes around filespec or this is an indirect com filespec
	! don't use lex_stg_desc

	
	IF .quote_flag EQL 2
	OR .icf_flag EQL 1
	THEN
	    CH$MOVE(.count, .parse_stg_desc[dsc$a_pointer], .filesp_buf+1)
	ELSE
	    CH$COPY(.lex_stg_desc[dsc$w_length], .lex_stg_desc[dsc$a_pointer],
	        .count, .parse_stg_desc[dsc$a_pointer], %C' ', .temp, .filesp_buf+1);

	filesp_buf[0] = .temp - 1;
	!++
	! Increment the address of the parse string in
	! the parse string descriptor to address the delimiting
	! carriage return or null byte.
	!--
	parse_stg_desc [dsc$a_pointer] = .input_ptr;
	parse_stg_desc [dsc$w_length] = .parse_stg_desc [dsc$w_length] - .count;

%IF dbg_par4
%THEN
	$fao_tt_out ('last character is "!AD"',
		1, .parse_stg_desc [dsc$a_pointer] - 1);
%FI


	RETURN(.filesp_buf);
END;


GLOBAL ROUTINE dbg$cis_getfsp (lex_stg_desc, parse_stg_desc) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	Calls dbg$get_filesp to collect the filespec of the indirect command
!	file to be opened. The filespec is saved away in a global location.
!
! FORMAL PARAMETERS:
!	lex_stg_desc   - The address of the string descriptor containing the
!		        previous lexeme.
!	parse_stg_desc - The address of the remaining piece of the input string
!
! IMPLICIT INPUTS:
!	None
!
! IMPLICIT OUTPUTS:
!	None
!
! ROUTINE VALUE:
!	None
!
! SIDE EFFECTS:
!	None
!--
BEGIN
	
	! Get the filespec

	dbg$gl_ind_com_file = dbg$get_filesp (.lex_stg_desc, .parse_stg_desc);
	
	RETURN;
END;

GLOBAL ROUTINE DBG$CIS_CONNECTICF : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
     BEGIN

	LOCAL
		status,				! Return status
		fab_ptr : REF $FAB_DECL,	! ptr to allocated FAB storage
		rab_ptr : REF $RAB_DECL,	! ptr to allocated RAB storage
		ind_com_filesp : REF VECTOR [,BYTE];	! Filespec counted string

	ind_com_filesp = .dbg$gl_ind_com_file;

	! Allocate FAB and RAB storage

	fab_ptr = dbg$freez((fab$c_bln + 3)/ %UPVAL);
	rab_ptr = dbg$freez((rab$c_bln + 3)/ %UPVAL);

	! Initialize the FAB and the RAB

	$FAB_INIT (FAB=.fab_ptr, FAC=GET, FNA=.ind_com_filesp + 1, FNS=.ind_com_filesp[0],
		   DNA=deficf_name, DNS=deficf_size);
	$RAB_INIT (RAB=.rab_ptr, FAB=.fab_ptr);

	! Put them on the command input stream

	dbg$cis_add (.rab_ptr, 0, cis_rab);

	! Open and connect the file

	status = $OPEN (FAB=.fab_ptr);
	IF NOT .status
	THEN
		BEGIN
		

		LOCAL
			msg_desc : BLOCK [8,BYTE];

		msg_desc[dsc$w_length]  = .fab_ptr[fab$b_fns];
		msg_desc[dsc$a_pointer] = .fab_ptr[fab$l_fna];


		! Flag link for removal so we won't try to read from it again

		dbg$gl_cishead[remove_flag] = 1;

		SIGNAL (shr$_openin + dbg_fac_code, 1, msg_desc, 
			.fab_ptr[fab$l_sts], .fab_ptr[fab$l_stv]);

		END;

	! Connect the RAB to the just opened FAB

	status = $CONNECT (RAB=.rab_ptr);
	IF NOT .status
	THEN
		BEGIN
		LOCAL
			msg_desc : BLOCK [8,BYTE];

		msg_desc[dsc$w_length]  = .fab_ptr[fab$b_fns];
		msg_desc[dsc$a_pointer] = .fab_ptr[fab$l_fna];


		! Flag link for removal so we won't try to read from it again

		dbg$gl_cishead[remove_flag] = 1;

		SIGNAL (shr$_openin + dbg_fac_code, 1, msg_desc, 
			.fab_ptr[fab$l_sts], .fab_ptr[fab$l_stv]);

		END;

	IF .dbg$gb_def_out [out_verify]
	THEN
		icf_message(1);

	RETURN;

END;		! End of dbg$cis_connecticf


GLOBAL ROUTINE dbg$cis_openicf  : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine has been changed into a dummy to fix a bug pertaining to
!	indirect command file handling. The routine dbg$cis_connecticf now does
!	what this routine used to do.
!
! FORMAL PARAMETERS:
!	None
!
! IMPLICIT INPUTS:
!	None
!
! IMPLICIT OUTPUTS:
!	None
!
! ROUTINE VALUE:
!	None
!
! SIDE EFFECTS:
!	None
!--
BEGIN

	RETURN;
END;


GLOBAL ROUTINE dbg$cis_remove : NOVALUE =
!++
! FUNCTIONAL DECSRIPTION:
!	Removes the top link from the command input stream and delete the 
!	storage for it. If the link has additional dynamic storage related to
!	it, such as a FAB,RAB, input buffer etc., that storage is freed also.
!
! FORMAL PARAMETERS:
!	None
!
! IMPLICIT INPUTS:
!	The head of the command input stream
!
! IMPLICIT OUTPUTS:
!	None
!
! ROUTINE VALUE:
!	None
!
! SIDE EFFECTS:
!	The head of the command input stream is reset to what was the
!	"next" link before this routine was called. If SET OUTPUT VERIFY,
!	then a message is generated saying we are exiting the indirect
!	command file.
!--

BEGIN

	LOCAL
		temp,
		type;

!	If top link is an input buffer, release the storage for that buffer

	IF .dbg$gl_cishead [dsc$b_dtype] EQL cis_inpbuf
	THEN
		dbg$freerelease (.dbg$gl_cishead [init_addr], (.dbg$gl_cishead
		                 [init_length] + 3)/ %UPVAL);

!	If top link is a RAB, release the storage for the FAB, RAB and the
!	buffer that holds the indirect command filespec

	IF .dbg$gl_cishead [dsc$b_dtype] EQL cis_rab
	THEN
		BEGIN
		LOCAL
			fab_ptr : REF $FAB_DECL,
			rab_ptr : REF $RAB_DECL;

		rab_ptr = .dbg$gl_cishead [ dsc$a_pointer];
		fab_ptr = .rab_ptr [rab$l_fab];

		IF .dbg$gb_def_out [out_verify]
		THEN
			icf_message(2);

		! Release the filespec buffer. Remember this is a counted
		! string so the address and length have to be adjusted to 
		! include the count.

		dbg$freerelease( .fab_ptr[fab$l_fna]-1, (.fab_ptr[fab$b_fns]+2)/%UPVAL + 1);

		! CLOSE and DISCONNECT

		$CLOSE (FAB=.fab_ptr);

		dbg$freerelease (.rab_ptr, (rab$c_bln + 3)/%UPVAL);
		dbg$freerelease (.fab_ptr, (fab$c_bln + 3)/%UPVAL);
		END;

!	Remove the link from the command input stream

	temp = .dbg$gl_cishead ;
	dbg$gl_cishead = .dbg$gl_cishead [next_link];

!	Now release the storage for the link itself 
	
	dbg$freerelease (.temp, (cis_elements+3)/%UPVAL) ;

	RETURN;
END;

GLOBAL ROUTINE dbg$cis_add (pointer, length, type): NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!	Adds a link to the command input stream
!
! FORMAL PARAMETERS:
! 	pointer	-	The address of either a buffer or a RAB to be placed
!			in the dsc$a_pointer field of the new link.
!	length	-	The length of the above buffer. (0 for RAB)
!	type	-	The type of the link to be added
!
! IMPLICIT INPUTS:
!	The head of the command input stream
!
! IMPLICIT OUTPUTS:
!	None
!
! ROUTINE VALUE:
!	None
!
! SIDE EFFECTS:
!	None
!--

BEGIN
	LOCAL
		temp;

!	Save current list head and allocate a new one

	temp = .dbg$gl_cishead ;
	dbg$gl_cishead = dbg$freez ((cis_elements + 3)/%UPVAL);

	dbg$gl_cishead [next_link] = .temp;
	dbg$gl_cishead [dsc$a_pointer] = .pointer;
	dbg$gl_cishead [dsc$b_dtype] = .type;

	dbg$gl_cishead [dsc$w_length] 	= .length;

	! The fields "init_addr" and "init_length"  are used to determine
	! how much storage to release for this buffer, since the pointer
	! field is modified by the parser among others.

	dbg$gl_cishead [init_addr]	= .pointer;
	
	! If we are adding an input buffer add 1 byte to the length
	! to be released because we allocated an extra one so we could
	! guarantee a zero byte at the end of the string.

	IF .type EQL cis_inpbuf
	THEN
		dbg$gl_cishead [init_length]	= .length + 1
	ELSE
		dbg$gl_cishead [init_length]	= .length;


%IF dbg_par5
%THEN
$fao_tt_out(' added link type !SL, pointer !XL, next !XL', .dbg$gl_cishead[dsc$b_dtype],
		.dbg$gl_cishead[dsc$a_pointer], .dbg$gl_cishead[next_link]);
%FI

	RETURN;
END;	


GLOBAL ROUTINE DBG$GET_HELP (Input_desc) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
! Saves a copy of the input descriptor for dbg$emit_help.
!
! FORMAL PARAMETERS:
!
!	INPUT_DESC	- The address of a standard quadword string descriptor.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	DBG$GL_HELP_INPUT is set to contain the address of an input descriptor
!	which describes the present input.
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	The input descriptor is updated to the end of the HELP string.
!
!--
    BEGIN

    MAP
	INPUT_DESC : REF BLOCK [,BYTE];

    OWN
	INPUT_COPY : BLOCK [8,BYTE];		! Copy of input descriptor

    ! Copy the input descriptor

    ch$move (8, .input_desc, input_copy);

    ! Set the global pointer

    dbg$gl_help_input = input_copy;

    ! Update the input descriptor to the end of the present command

    WHILE ch$rchar (.input_desc [dsc$a_pointer]) NEQ ';'
			    AND
	  ch$rchar (.input_desc [dsc$a_pointer]) NEQ 0
    DO
	BEGIN

	input_desc [dsc$a_pointer] = .input_desc [dsc$a_pointer] + 1;
	input_desc [dsc$w_length] = .input_desc [dsc$w_length] - 1;

	END;

    END;		! End of dbg$get_help


GLOBAL ROUTINE dbg$emit_help (parse_stg_desc) : NOVALUE = 
!++
! FUNCTIONAL DESCRIPTION:
!
!	Invoke the VMS librarian to implement the HELP command. 
!
! FORMAL PARAMETERS:
!	
!	parse_stg_desc	- 	the input string specifying the HELP
!				arguments.
!
! IMPLICIT INPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	The HELP text is displayed to the terminal.
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
! 	The input string is updated to the end of the HELP command line.	
!
!--

BEGIN

    MAP 
	parse_stg_desc : REF dbg$stg_desc;

    LOCAL
    	CHAR,					! Temporary placeholder for a char
    	COUNT,					! Counter for leading blanks
    	INPUT_PTR,				! Temporary pointer into input
	LIB_NAME 	: REF dbg$stg_desc,	! descriptor for library name
	NOUN_NODE 	: REF dbg$noun_node, 	! noun node of command execution tree
    	SAVED_PARSE_STG_DESC,
	STATUS;					! Librarian routines return status


ROUTINE PRINT_HELP_LINE (LINE_DESC) =
!++
! Functional Description:
!	Print a line of HELP text to the DEBUG output device
!	It is necessary to pass this routine to LBR$OUTPUT_HELP, instead
!	of using the default routine LIB$PUT_OUTPUT, because DEBUG writes
!	its output to DBG$OUTPUT and not to SYS$OUTPUT.
!
! Formal Parameters:
!	linedesc  	- address of string descriptor for the line to be output
!
! Implicit Inputs:
!	None
!
! Implicit Outputs:
!	None
!
! Routine Value:
!	None
!
! Side Effects:
!	None
!
!--
    BEGIN

    MAP
        line_desc	: REF dbg$stg_desc;

    $fao_tt_out ('!AD', .line_desc[dsc$w_length], .line_desc[dsc$a_pointer]);

    RETURN ss$_normal;

    END;

ROUTINE input_help_line (get_str, prompt_str) =
!++
! FUNCTION
!
!	Reads a line of HELP input from the DEBUG input stream. This routine
!	is used by LBR$OUTPUT_HELP to collect responses to the "Topic? " and
!	"Subtopic? " prompts. It is necessary to use this instead of the
!	default LIB$GET_INPUT, because DEBUG reads its input from DBG$INPUT
!	and not from SYS$INPUT.
!
! INPUTS
!
!	get_str		- The address of a string descriptor to receive the input
!	prompt_str	- A string descriptor specifying the prompt string
!
! OUTPUTS
!
! 	The get_str and out_len parameters are output parameters.
!	The return value is SS$_NORMAL if everything went OK.
!--
    BEGIN

    MAP
    	get_str: REF dbg$stg_desc,
    	prompt_str: REF dbg$stg_desc;  

    LOCAL
    	status;

    ! Set up the RAB and call RMS to give the prompt and read a line
    !
    dbg$gl_inprab[rab$w_usz] = .get_str[dsc$w_length];
    dbg$gl_inprab[rab$l_ubf] = .get_str[dsc$a_pointer];
    dbg$gl_inprab[rab$b_psz] = .prompt_str[dsc$w_length];
    dbg$gl_inprab[rab$l_pbf] = .prompt_str[dsc$a_pointer];
    status = $get (rab = dbg$gl_inprab);

    ! Fill in the number of characters actually read.
    !
    get_str[dsc$w_length] = .dbg$gl_inprab[rab$w_rsz];

    ! Return status that was returned from $get.
    !
    RETURN .status;

    END; ! of input_help_line
    
    !
    ! Executable code for DBG$EMIT_HELP begins here
    !

    ! initialize the library name
    !
    lib_name = dbg$get_tempmem (2);
    lib_name [dsc$w_length] = 8;
    lib_name [dsc$a_pointer] = UPLIT BYTE(%ASCII 'DEBUGHLP');

    ! Suppress leading blanks
    !
    count = -1;
    input_ptr = ch$ptr (.parse_stg_desc[dsc$a_pointer]);
    DO
    	BEGIN
    	char = ch$rchar_a (input_ptr);
    	count = .count + 1;
    	END
    UNTIL
    	.dbg$char_table [.char] NEQ blanks; 	! blanks or tabs
    
    ! The above loop goes one too far, so correct it.
    !	
    input_ptr = ch$plus (.input_ptr, -1);
    parse_stg_desc[dsc$w_length] = .parse_stg_desc[dsc$w_length] - .count;
    parse_stg_desc[dsc$a_pointer] = .input_ptr;

    ! Save away the parse_stg_desc before we clobber it.
    !
    saved_parse_stg_desc = .parse_stg_desc;

    ! Remove the trailing carriage return from parse_stg_desc.
    !
    input_ptr = ch$ptr (.parse_stg_desc[dsc$a_pointer]);
    input_ptr = ch$plus (.input_ptr, .parse_stg_desc[dsc$w_length] - 1);
    IF ch$rchar(.input_ptr) EQL dbg$k_car_return
    THEN
    	parse_stg_desc[dsc$w_length] = .parse_stg_desc[dsc$w_length] - 1;

    ! Check for all blanks. If so, put zero in parse_stg_desc to tell the
    ! HELP librarian that no keys were specified.
    ! 
    IF .parse_stg_desc[dsc$w_length] EQL 0
    THEN
        parse_stg_desc = 0;    	

    ! Call the library routine to output help text
    !
    IF NOT (status = lbr$output_help (print_help_line, 0, .parse_stg_desc,
    				      .lib_name, UPLIT(HLP$M_PROMPT),
    			  	      input_help_line))
    THEN
    	BEGIN
    	SIGNAL (dbg$_debugbug, 1, dbg$k_lib_get_fail); ! No return
    	END;

    ! help has been displayed, cleanup and go home
    !
    parse_stg_desc = .saved_parse_stg_desc;
    parse_stg_desc[dsc$a_pointer] = ch$plus(.parse_stg_desc[dsc$a_pointer],
    					    .parse_stg_desc[dsc$w_length]);
    parse_stg_desc[dsc$w_length] = 0;

    RETURN;

    END;			! End of dbg$nexecute_help

GLOBAL ROUTINE dbg$get_dir_list(
	lex_stg_desc,
	parse_stg_desc,
	stack_level) : NOVALUE =
!+
! Function
!	Parse a directory list for the command
!	SET SOURCE dir-list
!
! Inputs
!	lex_stg_desc - a string descriptor for the first token in the
!		       directory list.
!	parse_stg_desc - a string descriptor for the remainder of the
!			input line.
!	stack_level - the result of the parse will be left in
!			dbg$gl_stk[.stack_level,stk$v_val1]
!
! Outputs
!	This routine builds a linked list of directory names and
!	leaves a pointer to this list in dbg$gl_stk[.stack_level,stk$v_val1]
!
! Algorithm
!	The directory list to be parsed is split between two string
!	descriptors. This routine first puts the whole string into
!	one descriptor.
!	It then passes this along to the new debugger routine
!	dbg$nget_dir_list. This avoids duplicating the code for 
!	parsing directory lists.
!-
    BEGIN

    MAP
	lex_stg_desc : REF BLOCK [,BYTE],
	parse_stg_desc : REF BLOCK [,BYTE];

    LOCAL
    	dummy_mess_vect;

    ! Back up parse_stg_desc so that it contains the entire string.

    parse_stg_desc[dsc$w_length] = .lex_stg_desc[dsc$w_length] +
    				 .parse_stg_desc[dsc$w_length];

    parse_stg_desc[dsc$a_pointer] = ch$plus(.parse_stg_desc[dsc$a_pointer],
    					-.lex_stg_desc[dsc$w_length]);

    ! call the new debugger parsing routine

    dbg$nget_dir_list (.parse_stg_desc,
    		       dbg$gl_stk[.stack_level,stk$v_val1],
    		       dummy_mess_vect);

    END ; ! dbg$get_dir_list

END							! End of module
ELUDOM
