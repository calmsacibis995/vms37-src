;!--------------------------------------------------------!
;!                                                        !
;!  DSTRECRDS.MAR -- DEBUG SYMBOL TABLE (DST) DEFINITION  !
;!                   FILE FOR MACRO MODULES               !
;!                                                        !
;!  THIS FILE IS BUILT AUTOMATICALLY FROM DSTRECRDS.REQ   !
;!     AND SHOULD THEREFORE NEVER BE UPDATED DIRECTLY--   !
;!     ALL SOURCE UPDATES MUST BE MADE TO DSTRECRDS.REQ   !
;!                                                        !
;!--------------------------------------------------------!
;
        .MACRO $DSTRECRDS


;----------------------------------------------------------------------
;
;	DSTRECRDS -- DEFINITION FILE FOR THE DEBUG SYMBOL TABLE
;
;----------------------------------------------------------------------
;
;
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;
;
; WRITTEN BY
;	Bruce Olsen	August, 1980.
;	Bert Beander	August, 1981.
;
; MODULE FUNCTION:
;	This REQUIRE file describes the structure of the Debug Symbol Table
;	generated by the VAX compilers and interpreted by the VAX Debugger.
;	It includes definitions for all field names and literals used in
;	building or interpreting the Debug Symbol Table (DST).
;

;			T A B L E  O F  C O N T E N T S
;
;	Miscellaneous Names
;	DST Record Headers
;	Supported Values for the Type Field
;	Standard Format Records
; 	Descriptor Format Records
;	Trailing Value Spec Records
;	Module Begin/End Records
;	Routine Begin/End Records
;	Block Begin/End Records
;	Static Link Records
;	BLISS Special Case Records
;	Variant Record Begin/End Records
;	Union Begin/End Records
;	PSECT Records
;	Enumerated Type Begin/End/Element Records
;	PC/Line Table Records
;	Source Line Correlation DST Records
;	Bliss Field Records
;	Prolog Records
;	Continuation Records
;	Type Specification Records
;	Value Specification Records
;	COBOL Hack Records
;	COBOL Global Attribute Records
;	GLOBAL-IS-NEXT Records
;	EXTERNAL-IS-NEXT Records
;	DST Record Declaration Macro
;	Type Specifications
;	Value Specifications

;	DATA STRUCTURE DEFINITON AND ACCESS
;
;
;
;	Here we declare all macros used to define and access BLISS data struc-
;	tures.  This includes the names L_, W_, B_, A_, and so forth which are
;	used throughout this REQUIRE file to specify BLISS Field-References.
;





;		M I S C E L L A N E O U S  N A M E S
;
;
;
	DST$K_MAX_NAME_SIZE		= 31 	; The longest name we support

;		D S T  R E C O R D  H E A D E R S
;
;
; These fields appear in all DST records.
;
	DST$B_LENGTH	= 0          	; The length of this DST record, not
					;      including this length byte
	DST$B_TYPE	= 1          	; The type of this DST record
	DST$A_NEXT	= 1        	; The next DST record starts at this
					;      location plus DST$B_LENGTH

;	S U P P O R T E D  V A L U E S  F O R  D S T $ B _ T Y P E 
;
;
;
	; APPENDIX C TYPE CODES.
	; They appear here for convenience. 
	; They are declared in STARLET.REQ

	DSC$K_DTYPE_LOWEST	= 1 	; Lowest TYPE data type we support--used
					;      for range checking
	; DSC$K_DTYPE_V		= 1,	! Bit.
	; DSC$K_DTYPE_BU	= 2,	! Byte logical.
	; DSC$K_DTYPE_WU	= 3,	! Word logical.
	; DSC$K_DTYPE_LU	= 4,	! Longword logical.
	; DSC$K_DTYPE_QU	= 5,	! Quadword logical.
	; DSC$K_DTYPE_B		= 6,	! Byte integer.
	; DSC$K_DTYPE_W		= 7,	! Word integer.
	; DSC$K_DTYPE_L		= 8,	! Longword integer.
	; DSC$K_DTYPE_Q		= 9,	! Quadword integer.
	; DSC$K_DTYPE_F		= 10,	! Single-precision floating.
	; DSC$K_DTYPE_D		= 11,	! Double-precision floating.
	; DSC$K_DTYPE_FC	= 12,	! Complex.
	; DSC$K_DTYPE_DC	= 13,	! Double-precision Complex.
	; DSC$K_DTYPE_T		= 14,	! ASCII text string.
	; DSC$K_DTYPE_NU	= 15,	! Numeric string, unsigned.
	; DSC$K_DTYPE_NL	= 16,	! Numeric string, left separate sign.
	; DSC$K_DTYPE_NLO	= 17,	! Numeric string, left overpunched sign.
	; DSC$K_DTYPE_NR	= 18,	! Numeric string, right separate sign.
	; DSC$K_DTYPE_NRO	= 19,	! Numeric string, right overpunched sign
	; DSC$K_DTYPE_NZ	= 20,	! Numeric string, zoned sign.
	; DSC$K_DTYPE_P		= 21,	! Packed decimal string.
	; DSC$K_DTYPE_ZI	= 22,	! Sequence of instructions.
	; DSC$K_DTYPE_ZEM	= 23,	! Procedure entry mask.
	; DSC$K_DTYPE_DSC 	= 24,	! Descriptor, used for arrays of dynamic strings
	; DSC$K_DTYPE_OU	= 25,	! Octaword logical
	; DSC$K_DTYPE_O		= 26,	! Octaword integer
	; DSC$K_DTYPE_G		= 27,	! Double precision G floating, 64 bit
	; DSC$K_DTYPE_H		= 28,	! Quadruple precision floating, 128 bit
	; DSC$K_DTYPE_GC	= 29,	! Double precision complex, G floating
	; DSC$K_DTYPE_HC	= 30,	! Quadruple precision complex, H floating
	; DSC$K_DTYPE_CIT	= 31, 	! COBOL intermediate temporary
	; DSC$K_DTYPE_BPV	= 32,	! Bound Procedure Value
	; DSC$K_DTYPE_BLV	= 33,	! Bound Label Value
	; DSC$K_DTYPE_VU	= 34,	! Bit Unaligned
    	; DSC$K_DTYPE_VT        = 37,   ! Varying Text
	DSC$K_DTYPE_HIGHEST	= 37 	; Highest TYPE data type we support--
					;      used for range checking.

	; The following literals are DEBUG codes which can appear
	; in DST$B_TYPE. Each indicates the format of 
	; the record which contains it, and some indicate the type of the
	; object described by that record.
	;
	DST$K_BLI	= 0 		; BLISS Special Case Record
					;      Special Format
	DST$K_LOWEST	= 154 		; Lowest numbered DST record in this
					;      range--used for range checking
	DST$K_COBOLGBL	= 154 		; COBOL Global Attribute DST Record
					;      Header Format
	DST$K_SOURCE	= 155 		; Source Line Correlation DST Record
					;      Special Format
	DST$K_STATLINK	= 156 		; Static Link Record for a routine
					;      Special format
	DST$K_VARVAL	= 157 		; Variant value Record
					;      Special Format
	DST$K_BOOL	= 158 		; Atomic object of type BOOLEAN,
					;      Allocated one byte.
					;	low order bit = 1 if TRUE,
					;	low order bit = 0 if FALSE.
					;      Standard Format
	DST$K_EXTRNXT	= 159 		; External-is-next Record.
					;      Header format
	DST$K_GLOBNXT	= 160 		; Global-is-next record.
					;      Header format
	DSC$K_DTYPE_UBS = 161 		; DEBUG internal use only.
					;      unaligned bit string
	DST$K_PROLOG	= 162 		; Prologue record
					;      Special Format
					;      TBT record.
	DST$K_SEPTYP	= 163 		; Separate Type Specification Flag
					;      Standard Format or 
					;      Trailing Value Spec Format
	DST$K_ENUMELT	= 164 		; Enumerated Type Element Record
					;      Standard Format
	DST$K_ENUMBEG	= 165 		; Enumerated Type Begin Record
					;      Special Format 
	DST$K_ENUMEND	= 166 		; Enumerated Type End Record
					;      Header Format
	DST$K_VARBEG	= 167 		; Variant-Set Begin Record
					;      Special Format 
	DST$K_VAREND	= 168 		; Variant-Set End Record
					;      Header format
	DST$K_UNIONBEG	= 169 		; Union Begin Record
					;      Standard format
	DST$K_UNIONEND	= 170 		; Union End Record
					;      Header format
	DST$K_RECBEG	= 171 		; Record Begin Record
					;      Special Format
	DST$K_RECEND	= 172 		; Record End Record
					;      Header Format
	DST$K_CONTIN	= 173 		; Continuation Record
					;      Special Format
	DST$K_VALSPEC	= 174 		; Value Specification Record
					;      Special Format
	DST$K_TYPSPEC	= 175 		; Type Specification Record
					;      Special Format
	DST$K_BLKBEG	= 176 		; Block Begin Record
					;      Special Format
	DST$K_BLKEND	= 177 		; Block End Record
					;      Routine/block End Format
	DST$K_COB_HACK 	= 178 		; COBOL HACK Record
					;      Special Format
	; 		= 179,		reserved to DEBUG
	; 		= 180,		reserved to DEBUG
	DST$K_ENTRY	= 181 		; Entry Point
					;      Standard format
	DST$K_LINE_NUM_REL_R11 = 182 	; Threaded Code PC Correlation Record
					;      Special Format
					;      TBT record
	DST$K_BLIFLD	= 183 		; BLISS Field Name
					;      Special Format
	DST$K_PSECT	= 184 		; PSECT Record
					;      Special Format
					;      TBT record
	DST$K_LINE_NUM	= 185 		; PC/Line Number Correlation Record
					;      Special Format 
					;      TBT record
	DST$K_LBLORLIT	= 186 		; Label/Literal Format
					;      Standard format
	DST$K_LABEL 	= 187 		; Label Record
					;      Standard format with DSC$B_VFLAGS = 0
	DST$K_MODBEG	= 188 		; Module Begin Record
					;      Special Format
					;      TBT record
	DST$K_MODEND	= 189 		; Module End Record
					;      Header format
					;      TBT record
	DST$K_RTNBEG	= 190 		; Routine Begin Record
					;      Special Format
					;      TBT record
	DST$K_RTNEND	= 191 		; Routine End record
					;      Routine/block End Format
					;      TBT record
	DST$K_HIGHEST	= 191 		; Highest numbered DST record in this
					;      range--used for range checking

;		S T A N D A R D  F O R M A T  R E C O R D S 
;
;
; This format consists of the header fields followed by the fields 
; declared here.
;
	DST$B_VFLAGS	= 2          	; Access information
;************ Untranslatable Bliss construct ************
;	DST$V_VALKIND   = [ 2, V_(0,2)],! How to interpret the specified value
;************ Untranslatable Bliss construct ************
;	DST$V_INDIRECT  = [ 2, V_(2) ], ! Set if address of address is produced
					;      by indicated computation
;************ Untranslatable Bliss construct ************
;	DST$V_DISP      = [ 2, V_(3) ],	! Set if content of DST$L_VALUE is used
					;      as a displacement off a register
					;      specified in DST$V_REGNUM
;************ Untranslatable Bliss construct ************
;	DST$V_REGNUM    = [ 2, V_(4,4)],! Number of register used in displace-
					;      ment mode addressing
	DST$L_VALUE	= 3          	; Value, address, or bit offset
	DST$B_NAME	= 7         	; Count byte of the name field,
					;      a counted ASCII string

	DST$K_VFLAGS_NOVAL	= 128 	; A flag which indicates that no value
					;      is specified, i.e. the object
					;      being described is a type.
	DST$K_VFLAGS_BITOFFS	= 255 	; A flag indicating that DST$L_VALUE
					;      contains a bit offset (used
					;      for record components)
	DST$K_VALKIND_LITERAL	= 0 	; DST$L_VALUE contains literal value
	DST$K_VALKIND_ADDR	= 1 	; Computation produces address of data
	DST$K_VALKIND_DESC	= 2 	; Computation produces address of
					;      descriptor of value.
	DST$K_VALKIND_REG	= 3 	; Value is contained in the register
					;      whose number is in DST$L_VALUE

;		D E S C R I P T O R  F O R M A T  R E C O R D S
;
;
; This format consists of the fields contained in a standard format record
; followed by a VAX standard descriptor. The third byte contains a special
; value indicating the presence of the descriptor. The longword beginning 
; at the fourth byte specifies the location of the descriptor.
;
	DST$L_DSC_OFFS		= 3          	; Offset in bytes to descriptor
						;      from DST$A_DSC_BASE
	DST$A_DSC_BASE		= 7         	; Descriptor starts at this loc-
						;      ation + DST$L_DSC_OFFS

	DST$K_VFLAGS_DSC	= 250 	; This value in DST$B_VFLAGS signals
					;       a descriptor format record

; The address of the descriptor is  
;
;	DST_RECORD[ DST$A_DSC_BASE ] + .DST_RECORD[ DST$L_DSC_OFFS ]

;		T R A I L I N G  V A L U E  S P E C   R E C O R D S
;
;
; This format consists of the fields contained in a standard format record
; followed by a value specification. The third byte contains a special
; value indicating the presence of the value spec. The longword beginning 
; at the fourth byte specifies the location of the value spec.
;
	DST$L_TVS_OFFSET = 3          	; Offset in bytes to descriptor
					;      from DST$A_TVS_BASE
	DST$A_TVS_BASE	 = 7         	; Descriptor starts at this loc-
					;      ation + .DST$L_TVS_OFFSET

	DST$K_VFLAGS_TVS = 251 	; This value in DST$B_VFLAGS signals
				;       a trailing value spec format.

; The address of the descriptor is  
;
;	DST_RECORD[ DST$A_TVS_BASE ] + .DST_RECORD[ DST$L_TVS_OFFSET ]

;		M O D U L E  B E G I N  R E C O R D S 
;
;
; This format consists of the header fields followed by 
;	o an unused byte that must be zero,
;	o a longword containing the encoded language in which this module was
;	  written, and
;	o the name of the module in counted ASCII string format.
;
	DST$B_MODBEG_UNUSED	= 2          	; MBZ
	DST$L_MODBEG_LANGUAGE 	= 3          	; Language code of language in
						;      which module was written
	DST$B_MODBEG_NAME	= 7         	; Count byte in name counted 
						;      ASCII string








;		M O D U L E  E N D  R E C O R D S 
;
;
; End records for modules, variants, unions, records, and enumerated types
; consist of just the fields in a DST header.
;

;		R O U T I N E  B E G I N  R E C O R D S
;
;
; This format has the same field layout as a standard DST record except
;
;	o a single bit of the third byte indicates the invocation mechanism
;	o the third byte is otherwise unused and must be zero
;
;************ Untranslatable Bliss construct ************
;	DST$V_RTNBEG_UNUSED	= [ 2, V_(0, 7)], ! MBZ
;************ Untranslatable Bliss construct ************
;	DST$V_RTNBEG_NO_CALL	= [ 2, V_(7, 1)], ! this bit is set if
						  ; this routine is invoked 
						  ; with JSB or BSB rather
						  ; than CALLx.
	DST$L_RTNBEG_ADDRESS	= 3           	  ; routine's virtual address
	DST$B_RTNBEG_NAME	= 7          	  ; count byte in name counted 









;		R O U T I N E  E N D  R E C O R D S 
;
;
; This format consists of the header fields followed by a longword 
; containing the size, in bytes, of the routine or block.
;
	DST$L_RTNEND_SIZE	= 3         	; length of routine in bytes

;		B L O C K  B E G I N  R E C O R D S
;
;
; This format has the same field layout as a standard DST record except
; that the third byte is unused an must be zero
;
	DST$B_BLKBEG_UNUSED	= 2          	; MBZ
	DST$L_BLKBEG_ADDRESS	= 3          	; routine's virtual address
	DST$B_BLKBEG_NAME	= 7         	; count byte in name counted 
						; string








;		B L O C K  E N D  R E C O R D S 
;
;
; This format consists of the header fields followed by a longword 
; containing the size, in bytes, of the routine or block.
;
	DST$L_BLKEND_SIZE	= 3         	; length of module in bytes

;		S T A T I C   L I N K   R E C O R D S
;
;
; This record specifies a "Static Link" for a routine.  The Static Link is a
; pointer to the VAX call frame for the proper up-scope invocation of the
; outer routine within which the present invocation of the present routine is
; nested.  The Static Link is thus used when DEBUG does up-level addressing
; in response to user commands.  A Static Link DST Record is always associated
; with the inner-most routine within whose Routine-Begin and Routine-End records
; it is nested.  The Static Link DST Record is optional--it need not be used by
; languages or for routines which do not keep track of static links in their
; run-time environments.
;
; This is the format of the Static Link DST Record:
;
;
;	+-----------------------------------------------+
;   b	|    LENGTH IN BYTES OF THE FOLLOWING FIELDS    | DST$B_LENGTH
;	+-----------------------------------------------+
;   b	|                DST$K_STATLINK                 | DST$B_TYPE
;	+-----------------------------------------------+
; var	|   VALUE SPEC GIVING THE VALUE OF THE STATIC   | VALUE SPEC
;	|   LINK, I.E. FP VALUE OF THE ROUTINE INVOC-   |
;	|   ATION STATICALLY UP-SCOPE FROM THIS ONE     |
;	+-----------------------------------------------+
;
;
	DST$A_SL_VALSPEC	= 2        	; Location of Value Spec giving
						;      the up-scope FP value

;		B L I S S  S P E C I A L  C A S E  R E C O R D S  
;
;
; This format consists of 
;	
;	o the DST header fields
;	o the fields in the set DST$BLI_FIELD
;	o a variable length, possibly empty, set of fields:
;	    - no fields, or
;	    - the fields in the set DST$BLI_VEC_FIELDS, or
;	    - the fields in the set DST$BLI_BITVEC_FIELDS, or
;	    - the fields in the set DST$BLI_BLOCK_FIELDS, or
;	    - the fields in the set DST$BLI_BLKVEC_FIELDS
;	o the fields in the set DST$BLI_TRAIL_FIELDS
;
; The set of fields which appear in the variable segment depends on the 
; symbol attribute given in DST$V_BLI_STRUC.
;
	DST$B_BLI_LNG		= 2          	; length, in bytes, of the set 
						; of fields between this one
						; and the TRAIL_FIELDS.
						; between 3 and 12
	DST$A_BLI_TRLR1		= 3         	; The first trailer is at this
						;      location + DST$B_BLI_LNG
	DST$B_BLI_FORMAL	= 3          	; routine formal or not
	DST$B_BLI_VFLAGS	= 4          	; access information
	DST$B_BLI_SYM_TYPE 	= 5             ; type of symbol
;************ Untranslatable Bliss construct ************
;	DST$V_BLI_STRUC	 	= [ 5, V_( 0, 3 ) ], ! structure of this symbol
	;			  [ 5, V_( 3, 4 ) ]  must be zero
;************ Untranslatable Bliss construct ************
;	DST$V_BLI_REF 		= [ 5, V_( 7, 1 ) ],
						; 1 => REF, 0 => no REF
	DST$A_BLI_SYM_ATTR	= 6         	; address of variable length
						; attribute segment


	DST$K_BLI_NOSTRUC	= 0 		; no structure
	DST$K_BLI_VEC		= 1 		; vector
	DST$K_BLI_BITVEC	= 2 		; bitvector
	DST$K_BLI_BLOCK		= 3 		; block
	DST$K_BLI_BLKVEC	= 4 		; blockvector


	DST$L_BLI_VEC_UNITS	 = 6         	; number of allocation units
;************ Untranslatable Bliss construct ************
;	DST$V_BLI_VEC_UNIT_SIZE  = [ 10, V_(0, 4) ],
						; unit size: 1 => byte
						;	     2 => word
						;	     4 => longword
;************ Untranslatable Bliss construct ************
;	DST$V_BLI_VEC_SIGN_EXT	 = [ 10, V_(4, 4)]
						; 1 => sign extension
						; 0 => no sign extension


	DST$L_BLI_BITVEC_SIZE = 6         ; number of bits

    
	DST$L_BLI_BLOCK_UNITS     = 6         	; number of allocation units

;************ Untranslatable Bliss construct ************
;	DST$V_BLI_BLOCK_UNIT_SIZE = [ 10, V_(0, 4) ]
						; unit size: 1 => byte
						;	     2 => word
						;	     4 => longword


	DST$L_BLI_BLKVEC_BLOCKS    = 6          ; number of blocks
	DST$L_BLI_BLKVEC_UNITS     = 10          ; number of units per block
	DST$B_BLI_BLKVEC_UNIT_SIZE = 14         
						; unit size: 1 => byte
						;	     2 => word
						;	     4 => longword


	DST$L_BLI_VALUE	= 0         	; Value longword, interpreted
					;      according to contents of
					;      DST$B_BLI_VFLAGS
	DST$B_BLI_NAME	= 4          	; First byte of name counted string
	DST$A_BLI_TRLR2	= 5        	; The second trailer starts at this
					;      location + DST$B_BLI_NAME



	DST$L_BLI_SIZE	= 0        	; Size of the Bliss data item in bytes


;		R E C O R D  B E G I N  R E C O R D S
;
;
; The Record Begin record consists of the fields of a STANDARD FORMAT record
; followed by a longword size field.  The size field contains zero if the size
; of the record is not known at compile-time.  If the size of the record is
; known at compile-time, that size (in bits) is put in the size field.  The
; records address is specified in the Value Flags and Value Longword fields.
; If necessary, these fields may specify that a Trailing Value Spec in the DST
; record gives the desired value.
;
; If the Record Begin DST Record defines a specific record, it must have a
; value defined.  However, if it defines a record data type (as opposed to a
; specific data object), Value Flags must contain the value DST$K_VFLAGS_NOVAL
; to indicate this.
;
;
;	+-----------------------------------------------+
;   b	|   LENGTH IN BYTES OF THE FOLLOWING FIELDS	| LENGTH
;	+-----------------------------------------------+
;   b	|   		  DST$K_RECBEG 			| TYPE
;	+-----------------------------------------------+
;   b	|						| VFLAGS
;	+-----------------------------------------------+
;   l	|						| VALUE LONGWORD
;	+-----------------------------------------------+
; var	|						| NAME
;	+-----------------------------------------------+
;   l	| 	    COMPILE TIME SIZE IN BITS		| SIZE 
;	+-----------------------------------------------+
;
;
	DST$L_RECBEG_SIZE		= 0         







;		R E C O R D   E N D   R E C O R D S
;
;
; A RECORD END record consists of just the fields of the DST header, i.e.
; the length (1) and type (DST$K_RECEND) fields.  This record terminates
; a set of record component declarations.  It thus terminates the scope
; set up by a RECORD BEGIN record.
;
;
;	+-----------------------------------------------+
;   b	|                       1                       | LENGTH
;	+-----------------------------------------------+
;   b	|   		  DST$K_RECEND 			| TYPE
;	+-----------------------------------------------+

;		V A R I A N T   S E T   B E G I N   R E C O R D S
;
;
; VARIANT SET BEGIN records consist of the fields of a STANDARD FORMAT record
; followed by the Variant-Set Begin trailer defined below.  The Variant-Set
; Begin record marks the beginning of a set of variant definitions for some
; data record ("structure").  It is followed by Variant-Value Records which
; precede the data items which constitute each record variant.  The whole set
; of variants is terminated by a Variant-Set End DST Record.
;
; The Variant-Set Begin record specifies the size of the variant part of the
; record (if known--otherwise zero is specified) and it specifies the tag
; variable by giving a DST pointer to the tag variable's DST record.  This
; DST record must be one of the components of the containing record and it
; must appear before the Variant-Set Begin record.
;
	DST$L_VARBEG_SIZE	  = 0         	; Size in bits of variant part
						;      of record (or zero)
	DST$L_VARBEG_TAG_PTR 	  = 4        	; Pointer to TAG field DST record









;		V A R I A N T   S E T   E N D   R E C O R D S
;
;
; A VARIANT-SET END record consists of just the fields of the DST header (the
; length and type fields).  A Variant-Set End record terminates a set of record
; variant declarations, i.e. a set of variants which have the same tag variable.
;

;		V A R I A N T   V A L U E   R E C O R D S
;
;
; A VARIANT VALUE record marks the beginning of a new variant within a variant
; set.  It also marks the end of the previous variant (if any).  It is thus
; always found between a Variant-Set Begin and a Variant-Set End DST record.
; Since the Variant-Set Begin record has already specified the tag variable,
; the Variant Value record specifies the corresponding tag value or values.
; The Variant Value record is followed by the data DST records (including
; nested records and variants if appropriate) which constitute the components
; of this specific record variant.
;
; A given variant may have many tag values or ranges of tag values; this DST
; record thus specifies a set of tag value ranges.  The way these ranges are
; specified is described in detail on the following page.
;
;
;	+-----------------------------------------------+
;   b	|    LENGTH IN BYTES OF THE FOLLOWING FIELDS    |
;	+-----------------------------------------------+
;   b	|                 DST$K_VARVAL                  |
;	+-----------------------------------------------+
;   l	|         SIZE OF THIS VARIANT IN BITS          |
;	+-----------------------------------------------+
;   w	|  NUMBER OF TAG VALUE RANGE SPECS THAT FOLLOW  |
;	+-----------------------------------------------+
; var	|                                               |
;	|            TAG VALUE RANGE SPECS,             |
;	|         ONE FOR EACH TAG VALUE RANGE          |
;	|                                               |
;	+-----------------------------------------------+
;
;
	DST$L_VARVAL_SIZE	= 2         	; Bit size of this variant part
	DST$W_VARVAL_COUNT	= 6         	; The number of tag value ranges
						;      which follow
	DST$A_VARVAL_RNGSPEC	= 8        	; Location where the tag value
						;      range specs start

; Each tag value range spec consists of one byte giving the kind of the range
; spec followed by one or two value specs.  If one value spec is given, that
; gives the tag value--the range consists of that one value.  If two value
; specs are given, they specify the lowest and highest value in the tag value
; range.  The illustrations below show the possible formats of the tag value
; range spec.
;
;
;	+-----------------------------------------------+
;   b	|              DST$K_VARVAL_SINGLE              |
;	+-----------------------------------------------+
; var	|        SINGLE VALUE SPEC FOR TAG VALUE        |
;	+-----------------------------------------------+
;
;
;	+-----------------------------------------------+
;   b	|              DST$K_VARVAL_RANGE               |
;	+-----------------------------------------------+
; var	|         VALUE SPEC GIVING LOWER BOUND         |
;	+-----------------------------------------------+
; var	|         VALUE SPEC GIVING UPPER BOUND         |
;	+-----------------------------------------------+
;
;
; These are the possible values of the tag value range spec "kind" byte.
;
	DST$K_VARVAL_SINGLE	= 1 	; The range consists of a single value
	DST$K_VARVAL_RANGE	= 2 	; The range is given by a lower and an
					;      upper bound (two value specs).

;			P S E C T  R E C O R D S
;
;
; This format consists of the same field layout as the standard format,
; record followed by a longword containing the length of the PSECT in bytes.
; The third byte in this format is unused and must be zero.
;
	DST$B_PSECT_UNUSED	= 2          	; MBZ
	DST$L_PSECT_VALUE	= 3          	; virtual address in PSECT
	DST$B_PSECT_NAME	= 7          	; count byte in name counted 
						;      ASCII string
	DST$B_PSECT_TRLR_OFFS	= 7          
	DST$A_PSECT_TRLR_BASE	= 8        	


; The address of the trailer fields is
;
;   DST_RECORD[ DST$A_PSECT_TRLR_BASE ] + .DST_RECORD[ DST$B_PSECT_TRLR_OFFS ]
;
	DST$L_PSECT_SIZE	 = 0        	; Number of bytes in PSECT


;	 E N U M E R A T E D  T Y P E  B E G I N  R E C O R D S
;
;
; This format consists of the header fields followed by 
;	o a field whose content is the length in bits of the internal 
;	  representation of an object of this type.
;	o the counted string representation of the type's name.
;
	DST$B_ENUMBEG_LENG	=  2          	; bit length of data
	DST$B_ENUMBEG_NAME   	=  3         	; count byte in name counted
						; string








; E N U M E R A T E D  T Y P E  E L E M E N T   R E C O R D  F O R M A T
;
;
; This DST record has the standard format.  The value spec specifies the
; internal value of the enumeration type element (normally as a literal value)
; and the name field specifies the corresponding print name.
;
;		+---------------+
;	b	|		| length
;		+---------------+ 
;	b	| DST$K_ENUMELT | type
;		+---------------+
;	b	|		| value flags
;		+---------------+
;	l	|		| value longword
;		+---------------+ 
;	var	|   		| name
;		+---------------+ 
;






;	 E N U M E R A T E D  T Y P E  E N D  R E C O R D S 
;
;
; ENUMERATED TYPE END RECORDS consist of the fields of a DST header.

;		P C / L I N E   T A B L E   R E C O R D S
;
;
; This format consists of the header fields followed by a variable length
; segment containing information relating line numbers and pc values.
;
	DST$A_LINE_NUM_DATA   = 2        

; The body of a PC/LINE Table Record is interpreted as a sequence of commands
; each of which supplies some information about line/statement numbers in the
; context of the preceding commands. 

; Commands are variable length, and come in two flavors distinguished by the 
; sign of the contents of the first byte:
 
; If the first byte is non-positive, the command is a one byte DELTA PC 
; command.
;
	DST$K_DELTA_PC_LOW 	= -128 
	DST$K_DELTA_PC_HIGH	= 0 

; If the first byte is positive, the contents of the first byte indicates
; the meaning of the command and the length of the optional operand which
; follows.
	DST$K_DELTA_PC_W	= 1 	; a 2 byte operand follows
	DST$K_INCR_LINUM	= 2 	; a 1 byte operand follows
	DST$K_INCR_LINUM_W	= 3  	; a 2 byte operand follows
	DST$K_SET_LINUM_INCR	= 4 	; a 1 byte operand follows
	DST$K_SET_LINUM_INCR_W	= 5 	; a 2 byte operand follows
	DST$K_RESET_LINUM_INCR	= 6 	; no operand follows
	DST$K_BEG_STMT_MODE	= 7 	; no operand follows
	DST$K_END_STMT_MODE	= 8 	; no operand follows
	DST$K_SET_STMTNUM	= 13 	; a 1 byte operand follows
	DST$K_SET_LINUM		= 9 	; a 2 byte operand follows
	DST$K_SET_PC		= 10 	; a 1 byte operand follows
	DST$K_SET_PC_W		= 11 	; a 2 byte operand follows
	DST$K_SET_PC_L		= 12 	; a 4 byte operand follows
	DST$K_TERM		= 14 	; a 1 byte operand follows
	DST$K_TERM_W		= 15 	; a 2 byte operand follows
	DST$K_SET_ABS_PC	= 16 	; a 4 byte operand follows
	DST$K_PCCOR_LOW		= -128 	; least value in the first byte of a
					; PC correlation command.
	DST$K_PCCOR_HIGH	= 16 	; largest value in the first byte of 
					; a PC correlation command.

;	S O U R C E   F I L E   C O R R E L A T I O N   R E C O R D S
;
;
; The Source File Correlation Record is used to specify the correlation between
; listing line numbers on the one hand and source files and source file record
; numbers on the other.  These records enable DEBUG to display source lines
; during the debugging session.
;
; Each Source File Correlation Record has the following format:
;
;
;	+---------------------------------------------------------------+
;   b	|           DST$B_LENGTH (Length of this DST record)            |
;	+---------------------------------------------------------------+
;   b	|               DST$B_TYPE (value = DST$K_SOURCE)               |
;	+---------------------------------------------------------------+
; var	|                                                               |
;	|                                                               |
;	|                     A variable number of                      |
;	|                                                               |
;	|               Source File Correlation commands                |
;	|                                                               |
;	|                                                               |
;	+---------------------------------------------------------------+
;
;
; After the length and DST type bytes, the record consists of a sequence of
; Source File Correlation commands.  These commands specify what source files
; contributed source lines to this module and how the module's listing line
; numbers are lined up with the source files and record numbers within those
; source files.  The available commands are described individually below.
;
; If the Source File Correlation commands needed to fully describe the current
; module will not fit in a single Source Line Correlation DST Record, they can
; be spread over any number of such DST records.  These records will be proc-
; essed sequentially, in the order that they appear, until there are no more
; such records for the current module.
;
; The purpose of the Source File Correlation commands is to allow DEBUG to con-
; struct a table of correlations between line numbers and source records.  A
; "line number" in this context means the listing line number.  This is the line
; number which is printed in the program listing and is output to the PC-Corre-
; lation DST records by the compiler.  (PC-Correlation DST records correlate
; listing line numbers with Program Counter values.)  A corresponding source
; line is identified by two things: a source file and a record number within
; that source file.
;
; The semantics of the Source File Correlation commands can be understood in
; terms of manipulating three state variables and issuing one command.  The
; three state variables are:
;
;		LINE_NUM -- The current listing line number.
;		SRC_FILE -- The File ID of the current source file,
;			    i.e. a small integer uniquely defining
;			    the source file.
;		SRC_REC  -- The record number (in the RMS sense) in
;			    the current source file of the current
;			    source line.
;
; LINE_NUM is assumed to have an initial value of 1 while SRC_FILE and SRC_REC
; are initially undefined.  The one command is:
;
;		DEFINE(LINE_NUM, SRC_FILE, SRC_REC)
;
; This command declares that line number LINE_NUM is associated with the source
; line at record number SRC_REC in the file specified by SRC_FILE.
;
; Given this, the compiler must output a sequence of Source File Correlation
; commands which cause LINE_NUM, SRC_FILE, and SRC_REC to be set up appropriate-
; ly and which cause the proper DEFINE operations to be issued to allow DEBUG to
; generate the correct line number to source record correlation table.  (DEBUG
; may not actually generate the full table, but it must be able to generate any
; part of such a table it needs.)  The semantics of each Source File Correlation
; command is described below in terms of these state variables and commands.
;
; It is perfectly legal for a compiler to generate commands which assign the
; same line number to many source lines (including source lines in separate
; source files).  Some languages do so for continuation lines, for example.
; It is also legal for some source lines not to have line numbers.  For in-
; stance, some languages do not assign line numbers to comment lines.  How-
; ever, line numbers must be DEFINEd in sequential order, from lowest line
; number to highest line number, in the Source File Correlation commands for
; one module.  The source records these line numbers correlate with may be in
; any order, of course.
;
; It should be clear from what follows that the source for one module may come
; from many source files.  This can be caused by plus-lists on the compiler
; command (e.g., $FORTRAN/DEBUG A+B+C) and by INCLUDE statements in the source.
; Also, source lines may come from modules within source libraries as well as
; from independent source files.
;
;
;
; Define the location of the first command in the DST record.
;
	DST$A_SRC_FIRST_CMD = 2        	; Location of first command in record


; Define the command codes for all the Source File Correlation commands.
;
	DST$K_SRC_MIN_CMD	=  1 	; Minimum command code for CASE ranges
	DST$K_SRC_DECLFILE	=  1 	; Declare a source file for this module
	DST$K_SRC_SETFILE	=  2 	; Set the current source file (word)
	DST$K_SRC_SETREC_L	=  3 	; Set source record number (longword)
	DST$K_SRC_SETREC_W	=  4 	; Set source record number (word)
	DST$K_SRC_SETLNUM_L	=  5 	; Set listing line number (longword)
	DST$K_SRC_SETLNUM_W	=  6 	; Set listing line number (word)
	DST$K_SRC_INCRLNUM_B	=  7 	; Increment listing line number (byte)
	DST$K_SRC_ENTER_STMODE	=  8 	; Enter statement mode
	DST$K_SRC_LEAVE_STMODE	=  9 	; Leave statement mode
	DST$K_SRC_DEFLINES_W	= 10 	; Define N separate lines (word)
	DST$K_SRC_DEFLINES_B	= 11 	; Define N separate lines (byte)
	DST$K_SRC_DEFSAME_W	= 12 	; Define N lines with same number (word)
	DST$K_SRC_DEFSAME_B	= 13 	; Define N lines with same number (byte)
	DST$K_SRC_DEFUNNUM_W	= 14 	; Define N unnumbered lines (word)
	DST$K_SRC_DEFUNNUM_B	= 15 	; Define N unnumbered lines (byte)
	DST$K_SRC_MAX_CMD	= 15 	; Maximum command code for CASE ranges


; Define the fields of the Source Line Correlation commands.  Also define the
; corresponding declaration macros.
;
	;
	; Field common to all Source File Correlation commands.
	;
	DST$B_SRC_COMMAND	= 0         	; Command code
	;
	; The fields of the Declare Source File command.
	;
	DST$B_SRC_DF_LENGTH	= 1         	; Length of this command
	DST$B_SRC_DF_FLAGS	= 2         	; Flag bits--reserved (MBZ)
	DST$W_SRC_DF_FILEID	= 3         	; Source file's File ID
	DST$Q_SRC_DF_RMS_RDT	= 5         	; Revision date and time or mod-
						;    ule insertion date and time
	DST$L_SRC_DF_RMS_EBK	= 13         	; End-of-File block number
	DST$W_SRC_DF_RMS_FFB	= 17         	; First Free Byte in EOF block
	DST$B_SRC_DF_RMS_RFO	= 19         	; Record and File Organization
	DST$B_SRC_DF_FILENAME	= 20         	; Source file name counted ASCII
	DST$A_SRC_DF_FILENAME	= 21         	;      (count byte, string addr)
	;
	; Fields used to access information in all other commands.
	;
	DST$L_SRC_UNSLONG	= 1         	; Unsigned longword parameter
	DST$W_SRC_UNSWORD	= 1         	; Unsigned word parameter
	DST$B_SRC_UNSBYTE	= 1        	; Unsigned byte parameter


; Declare trailer field in the Declare Source File command.
;
	DST$B_SRC_DF_LIBMODNAME	= 0         	; Module name counted ASCII
	DST$A_SRC_DF_LIBMODNAME = 1        	;      (count byte, string addr)


; Declaration macros for Source File Correlation command and trailer blocks.
;

; DECLARE SOURCE FILE (DST$K_SRC_DECLFILE)
;
;
;	This command declares a source file which contributes source lines to
;	the current module.  It declares the name of the file, its revision
;	date and time, and various other attributes.  The command also assigns
;	a one-word "file ID" to this source file.  This is the format of the
;	Declare Source File command:
;
;
;	+---------------------------------------------------------------+
;   b	|               Command code = DST$K_SRC_DECLFILE               |
;	+---------------------------------------------------------------+
;   b	|                      DST$B_SRC_DF_LENGTH                      |
;	+---------------------------------------------------------------+
;   b	|                      DST$B_SRC_DF_FLAGS                       |
;	+---------------------------------------------------------------+
;   w	|                      DST$W_SRC_DF_FILEID                      |
;	+---------------------------------------------------------------+
;   q	|                     DST$Q_SRC_DF_RMS_RDT                      |
;	+---------------------------------------------------------------+
;   l	|                     DST$L_SRC_DF_RMS_EBK                      |
;	+---------------------------------------------------------------+
;   w	|                     DST$W_SRC_DF_RMS_FFB                      |
;	+---------------------------------------------------------------+
;   b	|                     DST$B_SRC_DF_RMS_RFO                      |
;	+---------------------------------------------------------------+
; var	|                     DST$B_SRC_DF_FILENAME                     |
;	+---------------------------------------------------------------+
; var	|                    DST$B_SRC_DF_LIBMODNAME                    |
;	+---------------------------------------------------------------+
;
;
;	The fields in this command are the following:
;
;	DST$B_SRC_DF_LENGTH - The length of this command, i.e. the number of
;		bytes remaining in the command after this field.
;
;	DST$B_SRC_DF_FLAGS - Bit flags.  This field is reserved for future use.
;		At present this field Must Be Zero.
;
;	DST$W_SRC_DF_FILEID - The one-word "File ID" of this source file.  This
;		File ID, which can later be used in the Set File command, is
;		simply a unique number which the compiler assigns to each source
;		file which contributes source lines to the current module.  Each
;		source file thus has a number (the File ID) and is identified by
;		that number in the Set File (DST$K_SRC_SETFILE) command.
;
;	DST$Q_SRC_DF_RMS_RDT - The revision date and time of this source file.
;		This quadword quantity should be retrieved with a $XABDAT
;		extended attribute block from RMS via the $OPEN or $DISPLAY
;		system service.  The revision date and time should be taken
;		from the XAB$Q_RDT field of the XAB.
;
;		If the source file is a module in a source library, this field
;		should contain the module's Insertion Date and Time in the lib-
;		rary.  This value should be retrieved with the LBR$SET_MODULE
;		Librarian call.  The library file's revision date is not used.
;
;	DST$L_SRC_DF_RMS_EBK - The End-of-File block number for this source
;		file.  This longword quantity should be retrieved with a
;		$XABFHC extended attibute block from RMS via the $OPEN or
;		$DISPLAY system service.  The End-of-File block number should
;		be taken from the XAB$L_EBK field of the XAB.
;
;		This field should be zero for modules in source libraries.
;
;	DST$W_SRC_DF_RMS_FFB - The first free byte of the End-of-File block
;		for this source file.  This word quantity should be retrieved
;		with a $XABFHC extended attribute block from RMS via the $OPEN
;		or $DISPLAY system service.  The first free byte value should
;		be taken from the XAB$W_FFB field of the XAB.
;
;		This field should be zero for modules in source libraries.
;
;	DST$B_SRC_DF_RMS_RFO - The file organization and record format of this
;		source file.  This byte value should be retrieved with a
;		$XABFHC extended attribute block from RMS via the $OPEN or
;		$DISPLAY system service.  The file organization and record
;		format should be taken from the XAB$B_RFO field of the XAB.
;
;		This field should be zero for modules in source libraries.
;
;	DST$B_SRC_DF_FILENAME - The full filename of the source file.  This is
;		the fully specified filename, complete with device name and
;		version number, in which all wild cards and logical names have
;		been resolved.  This string should be retrieved with a $NAM
;		block from RMS via the $OPEN or $SEARCH system service.  The
;		desired string is the "Resultant String" specified by the
;		NAM$L_RSA, NAM$B_RSS, and NAM$B_RSL fields of the $NAM block.
;		Here the file name is represented as a Counted ASCII string (a
;		one-byte character count followed by the name string).
;
;	DST$B_SRC_DF_LIBMODNAME - The source library module name (if applicable)
;		or the null string.  If the source file is actually a module in
;		a source library, the DST$B_SRC_DF_FILENAME field gives the
;		filename of the source library and the DST$B_SRC_DF_LIBMODNAME
;		field gives the name of the source module within that library.
;		If the source file does not come from a source library, this
;		field (DST$B_SRC_DF_LIBMODNAME) contains the null (zero-length)
;		string.  This field is represented as a Counted ASCII string.

; SET SOURCE FILE (DST$K_SRC_SETFILE)
;
;
;	This command sets the current source file to the file denoted by the
;	one-word file ID given in the command.  The set file is then the file
;	from which further source lines are taken when the corresponding list-
;	ing lines are defined.  This is the format of the command:
;
;
;	+---------------------------------------------------------------+
;   b	|               Command code = DST$K_SRC_SETFILE                |
;	+---------------------------------------------------------------+
;   w	|   DST$W_SRC_UNSWORD: The File ID of the desired source file   |
;	+---------------------------------------------------------------+
;
;
;	The semantics of this command is:
;
;			SRC_FILE := file ID from command
;			SRC_REC  := set to current source record for this
;				    source file
;
;
;
; SET SOURCE RECORD NUMBER LONG (DST$K_SRC_SETREC_L)
;
;
;	This command sets the current source file record number to the longword
;	value specified in the command.  Its format is:
;
;
;	+---------------------------------------------------------------+
;   b	|               Command code = DST$K_SRC_SETREC_L               |
;	+---------------------------------------------------------------+
;   l	|    DST$L_SRC_UNSLONG: The desired new source record number    |
;	+---------------------------------------------------------------+
;
;
;	The semantics of this command is:
;
;			SRC_REC := longword value from command

; SET SOURCE RECORD NUMBER WORD (DST$K_SRC_SETREC_W)
;
;
;	This command set the current source file record number to the word
;	value specified in the command.  It is thus a more compact form of
;	the DST$K_SRC_SETREC_L command.  Its format is:
;
;
;	+---------------------------------------------------------------+
;   b	|               Command code = DST$K_SRC_SETREC_W               |
;	+---------------------------------------------------------------+
;   w	|    DST$W_SRC_UNSWORD: The desired new source record number    |
;	+---------------------------------------------------------------+
;
;
;	The semantics of this command is:
;
;			SRC_REC := word value from command
;
;
;
; SET LINE NUMBER LONG (DST$K_SRC_SETLNUM_L)
;
;
;	This command set the current listing line number to a longword value
;	specified in the command.  Its format is:
;
;
;	+---------------------------------------------------------------+
;   b	|              Command code = DST$K_SRC_SETLNUM_L               |
;	+---------------------------------------------------------------+
;   l	|      DST$L_SRC_UNSLONG: The desired listing line number       |
;	+---------------------------------------------------------------+
;
;
;	The semantics of this command is:
;
;			LINE_NUM := longword value in commmand

; SET LINE NUMBER WORD (DST$K_SRC_SETLNUM_W)
;
;
;	This command sets the current listing line number to a one-word value
;	specified in the command.  Its format is:
;
;
;	+---------------------------------------------------------------+
;   b	|              Command code = DST$K_SRC_SETLNUM_W               |
;	+---------------------------------------------------------------+
;   w	|      DST$W_SRC_UNSWORD: The desired listing line number       |
;	+---------------------------------------------------------------+
;
;
;	The semantics of this command is:
;
;			LINE_NUM := word value in command
;
;
;
; INCREMENT LINE NUMBER BYTE (DST$K_SRC_INCRLNUM_B)
;
;
;	This command increments the current listing line number by a one-byte
;	value specified in the command.  Its format is:
;
;
;	+---------------------------------------------------------------+
;   b	|              Command code = DST$K_SRC_INCRLNUM_B              |
;	+---------------------------------------------------------------+
;   b	| DST$B_SRC_UNSBYTE: The desired listing line number increment  |
;	+---------------------------------------------------------------+
;
;
;	The semantics of this command is:
;
;			LINE_NUM := LINE_NUM + byte value in command

; ENTER STATEMENT MODE (DST$K_SRC_ENTER_STMODE)
;
;
;	This command enters statement mode.  Statement mode allows separate
;	source lines to have statement numbers (e.g., 200.1, 200.2, 200.3,
;	etc.) instead of distinct line numbers.  This mode is only useful
;	for BASIC.  The format of the command is:
;
;
;	+---------------------------------------------------------------+
;   b	|             Command code = DST$K_SRC_ENTER_STMODE             |
;	+---------------------------------------------------------------+
;
;
;	The semantics of this command is:
;
;			STATEMENT_MODE := TRUE
;
;
;
; LEAVE STATEMENT MODE COMMAND (DST$K_SRC_LEAVE_STMODE)
;
;
;	This command leaves statement mode and returns to ordinary line mode.
;	It must match up with a preceding Enter Statement Mode command.  Its
;	format is:
;
;
;	+---------------------------------------------------------------+
;   b	|             Command code = DST$K_SRC_LEAVE_STMODE             |
;	+---------------------------------------------------------------+
;
;
;	The semantics of this command is:
;
;			STATEMENT_MODE := FALSE

; DEFINE N SEPARATE LINES WORD (DST$K_SRC_DEFLINES_W)
;
;
;	This command defines the source file and source record numbers for
;	a specified number of listing line numbers.  The specified number is
;	given by a one-word count in the command.  The command format is:
;
;
;	+---------------------------------------------------------------+
;   b	|              Command code = DST$K_SRC_DEFLINES_W              |
;	+---------------------------------------------------------------+
;   w	|   DST$W_SRC_UNSWORD: The number of separate lines to define   |
;	+---------------------------------------------------------------+
;
;
;	The semantics of this command is:
;
;			DO the number of times specified in the command:
;				BEGIN
;				DEFINE(LINE_NUM, SRC_FILE, SRC_REC);
;				LINE_NUM := LINE_NUM + 1;
;				SRC_REC := SRC_REC + 1;
;				END;
;
;
;
; DEFINE N SEPARATE LINES BYTE (DST$K_SRC_DEFLINES_B)
;
;
;	This command defines the source file and source record number for
;	a specified number of listing line numbers.  The specified number is
;	given by a one-byte count in the command.  This is thus a more compact
;	form of the DST$K_SRC_DEFLINES_W command.  Its format is:
;
;
;	+---------------------------------------------------------------+
;   b	|              Command code = DST$K_SRC_DEFLINES_B              |
;	+---------------------------------------------------------------+
;   b	|   DST$B_SRC_UNSBYTE: The number of separate lines to define   |
;	+---------------------------------------------------------------+
;
;
;	The semantics of this command is:
;
;
;			DO the number of times specified in the command:
;				BEGIN
;				DEFINE(LINE_NUM, SRC_FILE, SRC_REC);
;				LINE_NUM := LINE_NUM + 1;
;				SRC_REC := SRC_REC + 1;
;				END;

; DEFINE N LINES WITH SAME LINE NUMBER WORD (DST$K_SRC_DEFSAME_W)
;
;
;	This command defines a specified number of source lines to have the
;	same listing line number.  The number of such lines is specified by
;	a one-word count in the command.  The command is used in languages
;	where continuation lines have the same line number as the first line
;	of a statement.  Its format is:
;
;
;	+---------------------------------------------------------------+
;   b	|              Command code = DST$K_SRC_DEFSAME_W               |
;	+---------------------------------------------------------------+
;   w	| DST$W_SRC_UNSWORD: Number of lines to define with same number |
;	+---------------------------------------------------------------+
;
;
;	The semantics of this command is:
;
;			DO the number of times specified in the command:
;				BEGIN
;				DEFINE(LINE_NUM, SRC_FILE, SRC_REC);
;				SRC_REC := SRC_REC + 1;
;				END;
;
;
;
; DEFINE N LINES WITH SAME LINE NUMBER BYTE (DST$K_SRC_DEFSAME_B)
;
;
;	This command defines a specified number of source lines to have the
;	same listing line number.  The number of such lines is specified by
;	a one-byte count in the command.  This is a more compact form of the
;	DST$K_SRC_DEFSAME_W command.  Its format is:
;
;
;	+---------------------------------------------------------------+
;   b	|                Command code = DST$K_DEFSAME_B                 |
;	+---------------------------------------------------------------+
;   b	| DST$B_SRC_UNSBYTE: Number of lines to define with same number |
;	+---------------------------------------------------------------+
;
;
;	The semantics of this command is:
;
;			DO the number of times specified in the command:
;				BEGIN
;				DEFINE(LINE_NUM, SRC_FILE, SRC_REC);
;				SRC_REC := SRC_REC + 1;
;				END;

; DEFINE N UNNUMBERED LINES WORD (DST$K_SRC_DEFUNNUM_W)
;
;
;	This command specifies that a specified number of source lines do not
;	have line numbers.  In some languages, comments do not have line num-
;	bers even though they are part of the source.  The command format is:
;
;
;	+---------------------------------------------------------------+
;   b	|              Command code = DST$K_SRC_DEFUNNUM_W              |
;	+---------------------------------------------------------------+
;   w	|  DST$W_SRC_UNSWORD: The number of unnumbered lines to define  |
;	+---------------------------------------------------------------+
;
;
;	The semantics of this command is:
;
;			DO the number of times specified in the command:
;				BEGIN
;				DEFINE(no-number, SRC_FILE, SRC_REC);
;				SRC_REC := SRC_REC + 1;
;				END;
;
;
;
; DEFINE N UNNUMBERED LINES BYTE (DST$K_SRC_DEFUNNUM_B)
;
;
;	This command specifies that a specified number of source lines do not
;	have line numbers.  It is a compact form of the DST$K_SRC_DEFUNNUM_W
;	command and is also used mainly for unnumbered comment lines.  Its
;	format is:
;
;
;	+---------------------------------------------------------------+
;   b	|              Command code = DST$K_SRC_DEFUNNUM_B              |
;	+---------------------------------------------------------------+
;   b	|  DST$B_SRC_UNSBYTE: The number of unnumbered lines to define  |
;	+---------------------------------------------------------------+
;
;
;	The semantics of this command is:
;
;			DO the number of times specified in the command:
;				BEGIN
;				DEFINE(no-number, SRC_FILE, SRC_REC);
;				SRC_REC := SRC_REC + 1;
;				END;
;
;
;
; END OF SOURCE FILE CORRELATION DST RECORD DESCRIPTION.

;		B L I S S   F I E L D  R E C O R D S 
;
;
; This format is used to support field names in bliss.
; Its field layout is congruent to the standard format followed by a vector
; of longwords containing the values of the field components attached to 
; this name. The DST$B_VFLAGS and DST$L_VALUE fields have non-standard values.
;
;		+---------------+
;	b	!  		! length
;		+---------------+
;	b	!  DST$K_BLIFLD ! type
;		+---------------+
;	b	|	0	| unused, must be zero
;		+---------------+
;	l	|		| number of components 
;		+---------------+ 
;	var	|   		| name
;		+---------------+ 
;	l	|   		| component value
;		+---------------+
;			.
;			.
;			.
;		+---------------+
;	l	|   		| component value
;		+---------------+
;
	DST$B_BLIFLD_UNUSED	= 2           	; MBZ
	DST$L_BLIFLD_COMPS	= 3          	; number of components
	DST$B_BLIFLD_NAME	= 7         	; Count byte of name

;	P R O L O G  R E C O R D  F O R M A T 
;
;
; A PROLOG record tells DEBUG 2 things
;   o Where to set a breakpoint in reponse to a symbol which is an ENTRY point
;	or ROUTINE.
;   o What code is executed before the first executable statement in the user
;	program.
;
;		+---------------+
;	b	|		| length
;		+---------------+
;	b	| DST$K_PROLOG 	| type
;		+---------------+
;	l	|		| Breakpoint address
;		+---------------+		--
;	l	|		| PC LOWER BOUND  |
;		+---------------+		  |
;	l	|		| PC UPPER BOUND   > optional
;		+---------------+		  |
;			.			  |
;			.			  |
;			.			  |
;						--
	DST$L_PROLOG_BKPT_ADDR	= 2         
	DST$A_PROLOG_PC_SET	= 6        

; Each prologue record has zero, one, or more PC range specifications.
; Each of these consists of an lower and upper bound virtual address.
; The PC range specified is 
;				low <= pc <= high
;
; The prologue consists of the union of these ranges. 
;
	DST$L_PC_LOW		= 0         
	DST$L_PC_HIGH		= 4        



;	C O N T I N U A T I O N  R E C O R D  F O R M A T
;
;
; A continuation record consists of the DST$HEADER_FIELDS followed by a 
; block of data which DEBUG treats as logically contiguous to the previous
; DST record
	DST$A_CONTIN		=  2        

;	 T Y P E  S P E C I F I C A T I O N  R E C O R D S
;
;
;	+-----------------------------------------------+
;    b	|    LENGTH OF THE FOLLOWING FIELDS, IN BYTES 	| LENGTH
;	+-----------------------------------------------+
;    b	|    		DST$K_TYPSPEC			| TYPE
;	+-----------------------------------------------+
;  var	|   						| NAME
;	+-----------------------------------------------+
;  var	|  						| TYPE SPECIFICATION
;	+-----------------------------------------------+
;
	DST$B_TYPSPEC_NAME	= 2          
	DST$A_TYPSPEC_TS_ADDR	= 3        









;	 V A L U E  S P E C I F I C A T I O N  R E C O R D S
;
;
;	+-----------------------------------------------+
;    b	|    LENGTH OF THE FOLLOWING FIELDS, IN BYTES 	| LENGTH
;	+-----------------------------------------------+
;    b	|    		DST$K_VALSPEC			| TYPE
;	+-----------------------------------------------+
;  var	|  						| VALUE SPECIFICATION
;	+-----------------------------------------------+
;
	DST$A_VS_VALSPEC_ADDR	= 2        

;			C O B O L   H A C K   R E C O R D S
;
; Records of this format are used to support formal arguments in COBOL.
; They have been superceded by the more general value specification 
; now available. Their further use is discouraged.
;
; The fields of this record consist of DST$STD_FIELDS followed by a 
; type field and a sequence of commands for a stack machine. The result 
; of interpreting the stack machine routine is the address of the
; object described by this record. The VFLAGS and VALUE fields are
; zero unless the object has a descriptor. In the latter case they 
; specify the location of the descriptor. The result of the stack machine
; routine is placed in the DSC$A_POINTER field of the descriptor before it
; is used. In addition, if it is an array descriptor, the DSC$A_A0 field
; is added to the result of the stack machine routine and the result is
; placed in the DSC$A_A0 field before the descriptor is used.
; 
; The type field following the name field contains the VAX standard type code
; of the object being described here.  If the object also has a descriptor,
; its DSC$B_DTYPE field must agree with this code.
;
; The stack machine commands used in this context are those described in
; conjunction with stack machine routines in a GENERAL VALUE SPECIFICATION.
;
;	+-----------------------------------------------+
;   b	|    LENGTH OF THE FOLLOWING FIELDS, IN BYTES	| LENGTH
;	+-----------------------------------------------+ 
;   b	|		DST$K_COB_HACK			| TYPE
;	+-----------------------------------------------+
;   b	|	    					| VFLAGS
;	+-----------------------------------------------+
;   l	|						| VALUE 
;	+-----------------------------------------------+
; var	|						| NAME
;	+-----------------------------------------------+
;   b	|						| CH_TYPE
;	+-----------------------------------------------+ -
; var	|						|  |
;	+-----------------------------------------------+  |  STACK 
;				.			    > MACHINE
;				.			   |  ROUTINE
;				.			   |
;	+-----------------------------------------------+  |
;   b	|		DST$K_STK_STOP			|  |
;	+-----------------------------------------------+ -
;
	DST$A_COBHACK_TRLR	= 8        	; Location of trailer fields

	DST$B_CH_TYPE		= 0          	; VAX standard data type
	DST$A_CH_STKRTN_ADDR	= 1         	; Start of stack routine code


;	    C O B O L   G L O B A L   A T T R I B U T E   R E C O R D S
;
;
; This record is used to indicate that the object which follows has the COBOL
; "global" attribute.  This attribute is necessary in COBOL for a symbol to
; be visible in a scope nested within the scope in which the symbol is declared.
; DEBUG thus needs this attribute to correctly simulate COBOL scope rules.
; This is the format of the COBOL Global Attribute DST Record:
;
;
;	+---------------------------------------------------------------+
;   b	|                   DST$B_LENGTH (value = 1)                    |
;	+---------------------------------------------------------------+
;   b	|              DST$B_TYPE (value = DST$K_COBOLGBL)              |
;	+---------------------------------------------------------------+
;
;
; This record must immediately precede the DST record for the data symbol to
; which the COBOL "global" attribute applies.  If a DST record is not preceded
; by this record, it is assumed that the "global" attribute does not apply.
; All languages other than COBOL ignore this attribute.

;		G L O B A L - I S - N E X T  R E C O R D S
;
;
; This record format is used to indicate that the object which follows is
; GLOBAL. It consists of the DST$HEADER_FIELDS.









;		E X T E R N A L - I S - N E X T  R E C O R D S
;
;
; This record format is used to indicate that the object which follows is
; EXTERNAL. It consists of the DST$HEADER_FIELDS.


;		D S T  R E C O R D  D E C L A R A T I O N  M A C R O
;
;
; This macro allows symbols which are declared DST$RECORD or REF DST$RECORD
; to be qualified by all field names which represent various record formats.
; It is anticipated that users will declare separate symbols for field
; sets which describe trailing fields in DST records; DST$PSECT_TRAILER,
; for example. Separate macros are supplied for this purpose following the
; declaration of the associated field set.
;

;		T Y P E  S P E C I F I C A T I O N S
;
;
; A TYPE SPECIFICATION is one of the following:
;	o Atomic Type Specification
;	o VAX Standard Descriptor Specification
; 	o Type in Subsequent Record Specificaiton
;	o Indirect Type Specification
;	o Typed Pointer Specification
;	o Pointer Specification
;	o Pictured Specification
;	o Array Specification
;	o Set Specification
;	o Subrange Specification
;	o Subset Specification
;	o File Specification
;	o Area Specification
;	o Offset Specification
;	o Novel Length Type Specification

;------------------------------------------------------------------------------
; ATOMIC TYPE 
; SPECIFICATION 
;
;	+-----------------------------------------------+
;   w	|    LENGTH OF THE FOLLOWING FIELDS, IN BYTES 	| LENGTH
;	+-----------------------------------------------+
;   b	|    		DST$K_TS_ATOM 			| KIND
;	+-----------------------------------------------+
;   b	|    						| ATOMIC TYPE
;	+-----------------------------------------------+
; This format is used to specify types for which a one byte VAX standard
; type code is sufficient.






;------------------------------------------------------------------------------
; VAX STANDARD DESCRIPTOR
; SPECIFICATION
;
;	+-----------------------------------------------+
;   w	|    LENGTH OF THE FOLLOWING FIELDS, IN BYTES 	| LENGTH
;	+-----------------------------------------------+
;   b	|    		 DST$K_TS_DSC			| KIND
;	+-----------------------------------------------+
; var	|    		  DESCRIPTOR			| VALUE SPECIFICATION
;	+-----------------------------------------------+

;------------------------------------------------------------------------------
; INDIRECT TYPE 
; SPECIFICATION
;	
;	+-----------------------------------------------+
;   w	|    LENGTH OF THE FOLLOWING FIELDS, IN BYTES 	| LENGTH
;	+-----------------------------------------------+
;   b	|   		  DST$K_TS_IND			| KIND
;	+-----------------------------------------------+
;   l	|   						| DST POINTER
;	+-----------------------------------------------+
;
; This construct is used to mean that the type specified by this record is the
; same as the type specified by the record pointed to by the DST pointer
; field.





;------------------------------------------------------------------------------
; TYPED POINTER 
; SPECIFICATION 
;
;	+-----------------------------------------------+
;   w	|    LENGTH OF THE FOLLOWING FIELDS, IN BYTES 	| LENGTH
;	+-----------------------------------------------+
;   b	|    		DST$K_TS_TPTR			| KIND
;	+-----------------------------------------------+
; var	|     TYPE SPECIFICATION OF TYPE POINTED TO	| TYPE SPECIFICATION
;	+-----------------------------------------------+
;





;------------------------------------------------------------------------------
; POINTER 
; SPECIFICATION 
;
;	+-----------------------------------------------+
;   w	|    LENGTH OF THE FOLLOWING FIELDS, IN BYTES 	| LENGTH
;	+-----------------------------------------------+
;   b	|    		DST$K_TS_PTR			| KIND
;	+-----------------------------------------------+

;------------------------------------------------------------------------------
; PICTURED 
; SPECIFICATION
;
;	+-----------------------------------------------+
;   w	|    LENGTH OF THE FOLLOWING FIELDS, IN BYTES 	| LENGTH
;	+-----------------------------------------------+
;   b	|    		  DST$K_TS_PIC			| KIND
;	+-----------------------------------------------+
;   b	|    	     DATA LENGTH IN BYTES 		| DATA SIZE
;	+-----------------------------------------------+
;   b	|              LANGUAGE ENCODING                |
;	+-----------------------------------------------+
;   b	|    LENGTH OF THE FOLLOWING FIELD, IN BYTES 	| PICTURE LENGTH
;	+-----------------------------------------------+
; var	|                PICTURE STRING                 | PICTURE
;	+-----------------------------------------------+
; var	|		    OPTIONAL    		| VALUE
; 	|  	  VALUE SPEC OF ENCODED PICTURE		| SPECIFICATION
;	+-----------------------------------------------+
;
; If the optional value specification is present, it yields the virtual
; address of an encoding of the object's picture. This encoding is language
; specific, and is used only by language specific DEBUG modules.
;
; The data size field contains the length, in bytes, of a pictured object
; with this picture. DEBUG assumes that pictured symbols are represented 
; internally as character strings.
; 
; The language code is the same as that used in MODULE BEGIN records.
; 
; The picture field consists of a sequence of words. The high order byte of
; each word contains an unsigned repetition factor, and the low order byte
; contains the ASCII representation of a character in the picture.

;------------------------------------------------------------------------------
; ARRAY 
; SPECIFICATION
;
; This specification contains a value specification which yields a VAX standard
; array descriptor (descriptor classes DSC$K_CLASS_A, DSC$K_CLASS_NCA, 
; DSC$K_CLASS_UBA). If the cell type of the array is not adequately described 
; by the DSC$B_DTYPE field of the descriptor a separate TYPE specification may 
; be included in this record to describe the type. In this case the DSC$B_DTYPE
; field of the descriptor should be zero. Conversely, if the DSC$B_DTYPE field 
; is zero the cell type must be included in the array specification.
; The descriptor class DSC$K_CLASS_UBA
; is used to indicate that subscript arithmetic is done in terms of bits rather
; than bytes. If a subscript type is not a range of integers, a type 
; specification may be included which specifies the subscript type. This need
; arises in PASCAL, for example, when the subscript is an ENUMERATED type.
;
;	+-----------------------------------------------+
;   w	|    LENGTH OF THE FOLLOWING FIELDS, IN BYTES 	| LENGTH
;	+-----------------------------------------------+
;   b	|    		DST$K_TS_ARRAY 			| KIND
;	+-----------------------------------------------+
;   b	|    	      NUMBER OF DIMENSIONS		| DIMENSIONS
;	+-----------------------------------------------+
; var	|    		BITVECTOR OF FLAGS 		| LENGTH
;	+-----------------------------------------------+
; var	| 		ARRAY DESCRIPTOR 		| VALUE
;	|		 SPECIFICATION			| SPECIFICATION	
;	+-----------------------------------------------+
; var	|    		   OPTIONAL			| TYPE
;	|	   CELL TYPE SPECIFICATION		| SPECIFICATION
;	+-----------------------------------------------+
; var	|    		   OPTIONAL			| TYPE
;	|	   SUBSCRIPT TYPE SPECIFICATION		| SPECIFICATION
;	+-----------------------------------------------+
;				.
;				.
;				.
;	+-----------------------------------------------+
; var	|    		   OPTIONAL			| TYPE
;	|	   SUBSCRIPT TYPE SPECIFICATION		| SPECIFICATION
;	+-----------------------------------------------+
; This type specification is used when 
; an array has neither a compile-time-constant descriptor nor a run-time
; descriptor materialized in the user's address space, or
; the array can not be described using a VAX standard descriptor. 
;
; The length of the bit vector in this format is the number of dimensions 
; plus one. It is high order zero extended to a byte boundary. 
;
; The low order bit of the bit vector is set if the optional cell type 
; specification is present.
; The second bit of the bit vector is set if the first optional subscript type
; specification is present.
; Each subsequent bit is set if the corresponding optional subscript type
; specification is present.

;------------------------------------------------------------------------------
; SET 
; SPECIFICATION 
; 
;	+-----------------------------------------------+
;   w	|    LENGTH OF THE FOLLOWING FIELDS, IN BYTES 	| LENGTH
;	+-----------------------------------------------+
;   b	|    		  DST$K_TS_SET			| KIND
;	+-----------------------------------------------+
;   l	|						| LENGTH IN BITS
;	+-----------------------------------------------+
; var	|         	   PARENT TYPE			| TYPE SPECIFICATION
;	+-----------------------------------------------+
;
; The value of an object of set type is a subset of the possible values of 
; another "parent" type. 
;
; DEBUG assumes that the internal representation of a value of a set type is
; a bit vector. The length of this object, in bits, is contained in the 
; LENGTH field.






;------------------------------------------------------------------------------
; SUBRANGE 
; SPECIFICATION 
;
;	+-----------------------------------------------+
;   w	|    LENGTH OF THE FOLLOWING FIELDS, IN BYTES 	| LENGTH
;	+-----------------------------------------------+
;   b	|    	     DST$K_TS_SUBRANGE			| KIND
;	+-----------------------------------------------+
;   l	|						| LENGTH IN BITS
;	+-----------------------------------------------+
; var	|    		PARENT TYPE 			| TYPE SPECIFICATION 
;	+-----------------------------------------------+
; var	|    		LOWER BOUND			| VALUE SPECIFICATION
;	+-----------------------------------------------+
; var	|    		UPPER BOUND			| VALUE SPECIFICATION
;	+-----------------------------------------------+
;
; A subrange type indicates a subset of the set of values of a "parent" type.
; The values of the parent type are ordered, and the subrange is indicated by 
; giving value specfications for the lower and upper bounds.

;------------------------------------------------------------------------------
; SUBSET 
; SPECIFICATION
; 
;	+-----------------------------------------------+
;   w	|    LENGTH OF THE FOLLOWING FIELDS, IN BYTES 	| LENGTH
;	+-----------------------------------------------+
;   b	|    		 DST$K_TS_SUBSET		| KIND
;	+-----------------------------------------------+
;   w	|		NUMBER OF SUBRANGES		| SUBRANGES
;	+-----------------------------------------------+
;   l	|						| LENGTH IN BITS
;	+-----------------------------------------------+
; var	|    	     	   PARENT TYPE 			| TYPE SPECIFICATION
;	+-----------------------------------------------+
; var	|    	       SUBRANGE LOWER BOUND		| VALUE SPECIFICATION
;	+-----------------------------------------------+
; var	|    	       SUBRANGE UPPER BOUND		| VALUE SPECIFICATION
;	+-----------------------------------------------+
;				.
;				.
;				.



;------------------------------------------------------------------------------
; FILE SPECIFICATION
;
;	+-----------------------------------------------+
;   w	|    LENGTH OF THE FOLLOWING FIELDS, IN BYTES 	| LENGTH
;	+-----------------------------------------------+
;   b	|    		  DST$K_TS_FILE			| KIND
;	+-----------------------------------------------+
;   b	|    						| LANGUAGE
;	+-----------------------------------------------+
; var	|		   RECORD TYPE			| TYPE SPECIFICATION
;	|						| (optional)
;	+-----------------------------------------------+
; 
; The language is encoded as in MODULE BEGIN records.
; The optional RECORD TYPE SPEFICATION is present when the user has declared
; a type for the records of this file.



;------------------------------------------------------------------------------
; AREA SPECIFICATION
;
;	+-----------------------------------------------+
;   w	|    LENGTH OF THE FOLLOWING FIELDS, IN BYTES 	| LENGTH
;	+-----------------------------------------------+
;   b	|    		 DST$K_TS_AREA			| KIND
;	+-----------------------------------------------+
;  var	|    		LENGTH IN BYTES			| VALUE SPECIFICATION
;	+-----------------------------------------------+

;------------------------------------------------------------------------------
; OFFSET SPECIFICATION
;
;	+-----------------------------------------------+
;   w	|    LENGTH OF THE FOLLOWING FIELDS, IN BYTES 	| LENGTH
;	+-----------------------------------------------+
;   b	|    	         DST$K_TS_OFFSET		| KIND
;	+-----------------------------------------------+
; var	|    VALUE SPEC GIVING BASE ADDRESS OF AREA     | VALUE SPEC
;	+-----------------------------------------------+
; var	|       VALUE SPEC GIVING LENGTH OF AREA        | VALUE SPEC
;	+-----------------------------------------------+
;
; An OFFSET variable must have an associated AREA VARIABLE. 




;------------------------------------------------------------------------------
; NOVEL LENGTH TYPE SPECIFICATION
;
; This type specification is used to represent a type which is identical 
; to another type except that the size of its internal representation is
; different. Examples are PACKED types in PASCAL.
;
;	+-----------------------------------------------+
;   w	|    LENGTH OF THE FOLLOWING FIELDS, IN BYTES 	| LENGTH
;	+-----------------------------------------------+
;   b	|    	         DST$K_TS_NOV_LENG		| KIND
;	+-----------------------------------------------+
;   l	|     SIZE IN BITS OF AN OBJECT OF THIS TYPE	| SIZE
;	+-----------------------------------------------+
;   l	|     		PARENT TYPE			| DST POINTER
;	+-----------------------------------------------+



;-------------------------------------------------------------------------------
; SELF-RELATIVE LABEL SPECIFICATION
;
; This type specification declares an object to be a self-relative label as in
; PL/I.  A self-relative label is always part of an array of such labels where
; each element contains a label value relative to the start of the array.  This
; arrangement allows these labels to be Position-Independent (PIC).
;
;
;	+-----------------------------------------------+
;   w	|    LENGTH OF THE FOLLOWING FIELDS, IN BYTES 	| LENGTH
;	+-----------------------------------------------+
;   b	|            DST$K_TS_SELF_REL_LABEL            | KIND
;	+-----------------------------------------------+

	DST$W_TS_LENGTH			= 0          
	DST$B_TS_KIND			= 2          
	DST$B_TS_ATOM_TYP		= 3          
	DST$A_TS_DSC_VSPEC_ADDR		= 3          
	DST$L_TS_IND_PTR		= 3         
	DST$A_TS_TPTR_TSPEC_ADDR	= 3          
	DST$B_TS_PIC_DLENG		= 3          
	DST$B_TS_PIC_LANG		= 4          
	DST$B_TS_PIC_PLENG		= 5          
	DST$A_TS_PIC_ADDR		= 6          
	DST$B_TS_ARRAY_DIM		= 3          
	DST$A_TS_ARRAY_FLAGS_ADDR	= 4          
	DST$L_TS_SET_LENG		= 3          
	DST$A_TS_SET_PAR_TSPEC_ADDR	= 7          
	DST$L_TS_SUBR_LENG		= 3          
	DST$A_TS_SUBR_PAR_TSPEC_ADDR	= 7          
	DST$W_TS_SUBS_NUM_SUBRS		= 3          
	DST$L_TS_SUBS_LENG		= 5          
	DST$A_TS_SUBS_PAR_TSPEC_ADDR	= 9          
	DST$B_TS_FILE_LANG		= 3          
	DST$A_TS_FILE_RCRD_TYP		= 4          
	DST$A_TS_AREA_BYTE_LEN		= 3          
	DST$A_TS_OFFSET_VALSPEC		= 3          
	DST$L_TS_NOV_LENG		= 3          
	DST$L_TS_NOV_LENG_PAR_TSPEC	= 7         

; DST$B_TS_KIND can assume the following values.
;
	DST$K_TS_ATOM			= 1  	; Atomic type spec
	DST$K_TS_DSC			= 2 	; Vax standard desciptor type 
						; spec
;	DST$K_SEPTYPE				! Type spec in separate record
						; See DST$B_TYPE
	DST$K_TS_IND			= 3 	; Indirect type spec
	DST$K_TS_TPTR			= 4 	; Typed pointer spec
	DST$K_TS_PTR			= 5 	; Pointer spec
	DST$K_TS_PIC			= 6 	; Pictured spec
	DST$K_TS_ARRAY			= 7 	; Array spec
	DST$K_TS_SET			= 8 	; Set spec
	DST$K_TS_SUBRANGE		= 9 	; Subrange spec
	DST$K_TS_SUBSET			= 10 	; Subset spec
	DST$K_TS_FILE			= 11 	; File spec
	DST$K_TS_AREA			= 12 	; Area spec
	DST$K_TS_OFFSET			= 13 	; Offset spec
	DST$K_TS_NOV_LENG		= 14 	; Novel Length spec
	DST$K_TS_IND_TSPEC		= 15 	; DEBUG internally generated
						;      pointer to Type Spec
	DST$K_TS_SELF_REL_LABEL		= 16 	; Self-Relative Label spec

; The following set of literals give the length in bytes of those TYPE SPECs 
; which have a fixed length.
;
	DST$K_TS_ATOM_LENG		= 4  	; Atomic type spec length
	DST$K_TS_IND_LENG		= 7 	; Indirect type spec length
	DST$K_TS_PTR_LENG		= 3 	; Pointer spec length
	DST$K_TS_FILE_LENG		= 4 	; File spec length
	DST$K_TS_AREA_LENG		= 3 	; Area spec length
	DST$K_TS_OFFSET_LENG		= 7 	; Offset  spec length
	DST$K_TS_NOV_LENG_LENG		= 11 	; Novel Length spec length


; Declaration macro for the Type Specification fields.
;

;		V A L U E  S P E C I F I C A T I O N S
; 
; A VALUE SPECIFICATION has one of three formats. The first is the same
; as the VFLAGS and VALUE_LONGWORD in a standard DST record. 
; The second is used when a value has a single specification, valid throughout 
; its lifetime, and when its lifetime is adequately described by "STATIC" or 
; "DYNAMIC".
; The third is used in all other cases. 


;------------------------------------------------------------------------------
;
;	+-----------------------------------------------+
;     b	|						| VFLAGS
;	+-----------------------------------------------+
;     l	|						| VALUE
;	+-----------------------------------------------+
; 
; When the VFLAGS field specifies that a descriptor follows, the descriptor 
; should be placed at the end of the innermost containing piece of a DST
; which has its own length field. For example, if the value spec is immediately
; contained in a type specification, the descriptor should be placed at the
; end of that specification.
 

;----------------------------------------------------------------------------- 
;
; 	+-----------------------------------------------+
;     b	|		DST$K_VS_FOLLOWS		| VFLAGS
; 	+-----------------------------------------------+
;     w	|   LENGTH OF FOLLOWING FIELDS, IN BYTES	| LENGTH
; 	+-----------------------------------------------+
;     b	|        	STATIC or DYNAMIC		| ALLOCATION 
; 	+-----------------------------------------------+
;   var	|						| MATERIALIZATION SPEC
; 	+-----------------------------------------------+





;------------------------------------------------------------------------------
;
; 	+---------------------------------------+
;     b	|	     DST$K_VS_FOLLOWS		| VFLAGS
; 	+---------------------------------------+
;     w	| LENGTH OF FOLLOWING FIELDS, IN BYTES	| LENGTH
; 	+---------------------------------------+
;     b	|        	 VARIES			| ALLOCATION 
; 	+---------------------------------------+
;     b	|	    NUMBER OF BINDINGS		| BINDING COUNT
; 	+---------------------------------------+
;   var |					| BINDING SPEC
;	+---------------------------------------+
;			.
;			.
;			.
;
;  BINDING COUNT indicates the number of BINDING SPECs which appear
;





	DST$B_VS_VFLAGS		= 0          
;************ Untranslatable Bliss construct ************
;	DST$V_VS_VALKIND   	= [ 0, V_(0,2)],
;************ Untranslatable Bliss construct ************
;	DST$V_VS_INDIRECT  	= [ 0, V_(2)],
;************ Untranslatable Bliss construct ************
;	DST$V_VS_DISP      	= [ 0, V_(3)],
;************ Untranslatable Bliss construct ************
;	DST$V_VS_REGNUM    	= [ 0, V_(4,4)],
	DST$L_VS_VALUE		= 1         
	DST$L_VS_DSC_OFFS	= 1         
	DST$A_VS_DSC_BASE	= 5         
	DST$L_VS_TVS_OFFSET	= 1         
	DST$A_VS_TVS_BASE	= 5         
	DST$W_VS_LENGTH		= 1         
	DST$B_VS_ALLOC		= 3          
	DST$A_VS_MATSPEC	= 4         
	DST$B_VS_BINDS		= 4          
	DST$A_VS_BINDSPEC	= 5        


	DST$K_VS_FOLLOWS	= 253 	; Value specification follows
	DST$K_VS_ALLOC_STAT	= 1  	; Value is static
	DST$K_VS_ALLOC_DYN	= 2 	; Value is dynamic
	DST$K_VS_ALLOC_VARIES	= 3 	; Value has more than one binding or a
					;      non-standard lifetime

;-----------------------------------------------------------------------------
;
;  A BINDING SPEC is
;
; 	+---------------------------------------+
;     w	| LENGTH OF FOLLOWING FIELDS, IN BYTES	| LENGTH
; 	+---------------------------------------+
;     b	|	   NUMBER OF PC RANGES		| PC RANGES
; 	+---------------------------------------+ -
;     l	|	     LOWER PC BOUND		|  |
; 	+---------------------------------------+   > PC RANGE
;     l	|	     UPPER PC BOUND		|  |
; 	+---------------------------------------+ -
;			.
;			.
;			.
; 	+---------------------------------------+ -
;   var	|					| MATERIALIZATION 
;	|					| SPEC
;	+---------------------------------------+
; 
; 




	DST$W_BS_LENGTH		=  0         
	DST$B_BS_PC_RANGES	=  2          
	DST$A_BS_PC_RANGE_ADDR	=  3         



; The following field set and macro are defined in the PROLOG RECORD section
;
; FIELD	DST$PC_RANGE_FIELDS		=
;     SET
; 	DST$L_PC_LOW		= [ 0, L_ ],
; 	DST$L_PC_HIGH		= [ 4, L_ ]
;     TES;
; 
; 
; MACRO	DST$PC_RANGE	= BLOCK [ 2, LONG ] FIELD ( DST$PC_RANGE_FIELDS ) %;

; A MATERIALIZATION SPEC is this
;
; 	+-----------------------------------------------+
;     b	|   	  BYTE ADDRESS or BIT ADDRESS or 	| KIND OF VALUE
;	| 	  R-VALUE or REGISTER NUMBER or		|
;	|	    BIT OFFSET or DESCRIPTOR		|
; 	+-----------------------------------------------+
;     b	|	  STACK MACHINE or ROUTINE CALL 	| MECHANISM 
; 	+-----------------------------------------------+
;     b	|                   FLAG BITS                   | FLAG BITS
; 	+-----------------------------------------------+
;   var |						| MECHANISM 
; 	|						| SPECIFICATION
; 	+-----------------------------------------------+




	DST$B_MS_KIND			= 0          
	DST$B_MS_MECH			= 1          
	DST$B_MS_FLAGBITS		= 2          
;************ Untranslatable Bliss construct ************
;	DST$V_MS_NOEVAL			= [ 2, V_(0) ],
;************ Untranslatable Bliss construct ************
;	DST$V_MS_DUMARG			= [ 2, V_(1) ],
	DST$A_MS_MECH_SPEC		= 3         
	DST$L_MS_MECH_RTNADDR		= 3        	; Routine address


; DST$V_MS_KIND may take the following values
;
	DST$K_MS_BYTADDR		= 1 	; value is a byte address
	DST$K_MS_BITADDR		= 2 	; value is a bit address
	DST$K_MS_BITOFFS		= 3 	; value is a bit offset
	DST$K_MS_RVAL			= 4 	; value is an R-VALUE
	DST$K_MS_REG			= 5 	; value is a register number
	DST$K_MS_DSC			= 6 	; value is a VAX standard
						; descriptor

	DST$K_MS_MECH_RTNCALL		= 1 	; Routine call
	DST$K_MS_MECH_STK		= 2  	; Stack machine routine

; DST$V_VS_DUMARG is set just in case the materialization mechanism is
; a routine call in which the called routine expects an extra argument in which
; to pass the returned value.

; A MECHANISM SPECIFICATION is one of the following:
; 
;
; 
; (1) CALL ON A COMPILER-SUPPLIED ROUTINE:
;
;
; 	+-----------------------------------------------+
;     l	|  	    VIRTUAL ADDRESS OF ROUTINE		|
; 	+-----------------------------------------------+
; 
; DEBUG executes a CALL instruction to the specified virtual address.
; If DST$B_MS_MECH is DST$K_MS_MECH_RTNCALL, the argument list consists of 
; a single argument containing the address of a vector of longwords containing 
; the stored registers of the user program in the natural order. 
; IF DST$B_MS_MECH is DST$K_MS_MECH_RTNCALL_1, the stored FP is passed in R1.
; In either case, if the DUMMY 
; ARG flag is set, an additional argument is passed containing the address of 
; a quadword to contain the returned value.
;
	DST$REG_0		= 0          
	DST$REG_1		= 4          
	DST$REG_2		= 8          
	DST$REG_3		= 12         
	DST$REG_4		= 16         
	DST$REG_5		= 20         
	DST$REG_6		= 24         
	DST$REG_7		= 28         
	DST$REG_8		= 32         
	DST$REG_9		= 36         
	DST$REG_10		= 40         
	DST$REG_11		= 44         
	DST$REG_AP		= 48         
	DST$REG_FP		= 52         
	DST$REG_SP		= 56         
	DST$REG_PC		= 60         
	DST$REG_PSL		= 64        



; (2) EVALUATION OF A STACK MACHINE ROUTINE:
;
; 
; 	+-----------------------------------------------+
;   var |	       STACK MACHINE ROUTINE 		|
; 	+-----------------------------------------------+
; 
; 
; A STACK MACHINE ROUTINE is a sequence of stack machine instructions ending
; in a STOP instruction. The stack consists of longword cells and behaves just
; like a processor stack in a VAX-11.
; 
; The supported instructions  are the following:
; 
; PUSH REGISTER I			0 <= I <= 15
;
	DST$K_STK_LOW		= 0  	; For range checking
	DST$K_STK_PUSHR0	= 0 
	DST$K_STK_PUSHR1	= 1 
	DST$K_STK_PUSHR2	= 2 
	DST$K_STK_PUSHR3	= 3 
	DST$K_STK_PUSHR4	= 4 
	DST$K_STK_PUSHR5	= 5 
	DST$K_STK_PUSHR6	= 6 
	DST$K_STK_PUSHR7	= 7 
	DST$K_STK_PUSHR8	= 8 
	DST$K_STK_PUSHR9	= 9 
	DST$K_STK_PUSHR10	= 10 
	DST$K_STK_PUSHR11	= 11 
	DST$K_STK_PUSHRAP	= 12 
	DST$K_STK_PUSHRFP	= 13 
	DST$K_STK_PUSHRSP	= 14 
	DST$K_STK_PUSHRPC	= 15 
; 
; PUSH IMMEDIATE 		1, 2, or 4 bytes following this opcode 
; BYTE WORD OR LONG		are sign extended to 32 bits and pushed 
; 				on the stack
; 
	DST$K_STK_PUSHIMB	= 16 
	DST$K_STK_PUSHIMW	= 17 
	DST$K_STK_PUSHIML	= 18 
;
; PUSH IMMEDIATE VARIABLE	The byte following the opcode is 
; 				interpreted as an unsigned byte count.
; 				A block of data, immediately following 
; 				the count byte, is pushed on the stack. 
; 				It is left padded with zeros to a
; 				longword boundary. The last longword in
; 				the resulting block is pushed first.
; 
	DST$K_STK_PUSHIM_VAR	= 24 
;
; PUSH IMMEDIATE UNSIGNED	1 or 2 bytes following this opcode 
; BYTE OR WORD 			are zero extended to 32 bits and pushed 
; 				on the stack
; 
	DST$K_STK_PUSHIMBU	= 25 
	DST$K_STK_PUSHIMWU	= 26 
;
; PUSH INDIRECT			The top stack cell is popped and 1, 2, or 4
; BYTE WORD OR LONG		bytes at the address given by the popped
;				stack cell are sign extended to 32 bits and
;				pushed on the stack.
; 
	DST$K_STK_PUSHINB	= 20 
	DST$K_STK_PUSHINW 	= 21 
	DST$K_STK_PUSHINL	= 22 
;
; PUSH INDIRECT UNSIGNED	The top stack cell is popped and 1 or 2
; BYTE OR WORD			bytes at the address given by the popped
;				stack cell are zero extended to 32 bits
;				and pushed on the stack.
; 
	DST$K_STK_PUSHINBU	= 27 
	DST$K_STK_PUSHINWU	= 28 
;
; ADD				The top two stack cells are added and 
; 				replaced by a single cell containing 
; 				their sum
; 
	DST$K_STK_ADD		= 19 
; SUBTRACT			The second stack cell is subtracted from 
; 				the first stack cell. Both are popped. 
; 				Their difference is pushed.
; 
	DST$K_STK_SUB		= 29 
;
; MULTIPLY			The top two stack cells are multiplied 
; 				and replaced by a single cell containing 
; 				their product
; 
	DST$K_STK_MULT		= 30 
;
; DIVIDE			The top stack cell is divided by the 
; 				secondstack cell. Both are popped. 
; 				Their qoutient is pushed.
; 
	DST$K_STK_DIV		= 31 
;
; LOGICAL SHIFT			The top stack cell is interpreted as 
; 				the number of bit positions to shift the 
; 				second stack cell. Both are popped. 
; 				The shifted second cell is pushed.
; 
	DST$K_STK_LSH		= 32 
;
; ROTATE			The top stack cell is interpreted as the
; 				number of bit positions to rotate the 
; 				second stack cell. Both are popped. 
; 				The rotated second cell is pushed.
; 
	DST$K_STK_ROT		= 33 
; 
; COPY 				The top stack cell is pushed 
;
	DST$K_STK_COP		= 34 
; 
; EXCHANGE			The top two stack cells are exchanged
; 
	DST$K_STK_EXCH		= 35 
;
; STORE BYTE WORD OR LONG	The byte following this operand is 
; 				interpreted as a signed (for consistency
; 				with something, see Grove) byte offset 
; 				into the stack. The low order byte, word, 
; 				or longword of the top stack cell is 
; 				copied into the byte, word or longword 
; 				at this location:
; 				    address of the second stack cell 
; 						+
; 				    the specified byte offset.
; 				(Keep in mind that the address of the 
; 				 third stack cell is the address of the
; 				 second stack cell plus four.)
; 				The stack is popped.
;
	DST$K_STK_STO_B		= 36 
	DST$K_STK_STO_W		= 37 
	DST$K_STK_STO_L		= 38 
; 
; POP				The top stack cell is removed from the 
; 				stack.
;
	DST$K_STK_POP		= 39 
; 
; STOP				Signals the end of the stack machine 
; 				routine.
;
	DST$K_STK_STOP		= 23 
;
; EVALUATE ROUTINE		The routine whose address is on top of the 
;				stack is called with the stored FP from the
;				current context in R1. The stack is popped.
;				The value which is in R0 upon return is pushed.
;
	DST$K_STK_RTNCALL	= 40 

	DST$K_STK_HIGH		= 40 	; For range checking
; 
; END OF STACK MACHINE ROUTINE
;
; END OF MECHANISM SPECIFICATION
;
; 
; 	[END OF DSTRECRDS.REQ]
        .ENDM $DSTRECRDS
        .END
