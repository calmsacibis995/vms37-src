

	.TITLE	DBG$UTILIT  -   DEBUG DEPOSIT UTILITY MODULE
	.IDENT	'V03-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;


; DEBUGGING TOOLS

;DBG_UTL1 = 1


	.MACRO	START_COMMAND
	.ENDM

	.MACRO	NEXT_COMMAND
	JMP	@(R11)+
	.ENDM

	.MACRO	EXIT_WITH_VAL
	MOVZBL  WORK_OVF_FLAGS(R10),R0
.IF  DF,DBG_UTL1
	PUSHL	R0
	PUSHAB  DBG$UTL_STR8
	CALLS	#2,DBG$FAO_OUT
	MOVZBL   WORK_OVF_FLAGS(R10),R0
.ENDC
	RET
	.ENDM

	.MACRO	GET_DDD	R
	MOVQ	@(R11)+,R
	.ENDM

	.MACRO	GET_DDD_ADDRESS	R
	MOVL	(R11)+,R
	.ENDM

	.MACRO	GET_TEMP_DDD	NUM,R
	MOVAB	WORK_DDD_'NUM(R10),R
	.ENDM

	.MACRO	GET_TEMP	NUM,R
	MOVAB	WORK_TEMP_'NUM(R10),R
	.ENDM

	.MACRO	SET_OVF_FLAGS
	BISB2	#GBL_OVF_FLAG+LOC_OVF_FLAG,WORK_OVF_FLAGS(R10)
	.ENDM
	
	.MACRO	TEST_OVF_FLAGS
	TSTB	WORK_OVF_FLAGS(R10)
	.ENDM

	.MACRO	CLEAR_LOCAL_OVF
	BICB2	#LOC_OVF_FLAG,WORK_OVF_FLAGS(R10)
	.ENDM

	.MACRO	TEST_LOCAL_OVF
	BITB	WORK_OVF_FLAGS(R10),#LOC_OVF_FLAG
	.ENDM

	.MACRO	ABORT	MSG_NUM
	PUSHL	#4+<8*MSG_NUM>+32768+<29*65536>		; COND VALUE.
	CALLS	#1,LIB$STOP
	.ENDM

;
;	ASCIC STRINGS FOR USE IN DEBUGING THESE ROUTINES
	.SAVE
	.PSECT	DBG$PLIT,NOWRT,SHR,PIC

DBG$UTL_STR1:: .ASCIC / CONVERT LONG !XL TO PACKED /
DBG$UTL_STR2:: .ASCIC / AFTER CONVERSION TO QUAD  !XL !XL /
DBG$UTL_STR3:: .ASCIC / AFTER SCALING QUAD  !XL !XL /
DBG$UTL_STR4:: .ASCIC / AFTER CONVERTING TO PACKED !XL /
DBG$UTL_STR5:: .ASCIC / AFTER CONVERTING QUAD TO PACKED /
DBG$UTL_STR6:: .ASCIC / AT CONVERSION OF PACKED TO NL /
DBG$UTL_STR7:: .ASCIC / PACKED  !XL  LS  !AD /
DBG$UTL_STR8:: .ASCIC / RETURN STATUS !XL /

	.RESTORE


.MACRO	$COBOTSDEF
;
; DDD FIELD EQUATES:
;

DDD_LENGTH	=	0
DDD_TYPE	=	2
DDD_SCALE	=	8
DDD_ADDRESS	=	4
DDD_SIZE	=	12
DDD_SUB_RANGE_1	=	12
DDD_SUB_SIZE_1	=	16

MAXTYPE		=	30

;
; INDEX BLOCK EQUATES:
;
 
INDEX$W_ORDINAL	=	0
INDEX$W_T_OFSET	=	2
 
 
;
; OVERFLOW HANDLING EQUATES.
;

LOC_OVF_FLAG	=	1
GBL_OVF_FLAG	=	2

;
; MESSAGE NUMBERS.
;

MSG_SUBSCRIPT	=	1
MSG_OCCURS_DEP	=	2
MSG_RET_ORDER	=	3
MSG_RECUR_PERF	=	4
MSG_ALTER	=	5
MSG_ABORT	=	6
MSG_RECUR_CALL	=	7
MSG_NO_OF_ARGS	=	8
MSG_PERF_LARGE	=	9
MSG_EXP_LARGE	=	10
; IO MESSAGES IN THIS SPACE
MSG_OPEN_OUTPUT =	30
MSG_OPEN_INPUT	=	31
MSG_DISPLAY	=	32
MSG_ACCEPT	=	33
MSG_INVDATA	=	34

COND_INVDATA	=	4+<8*MSG_INVDATA>+32768+<29*65536>
COND_SUBERR	=	4+<8*MSG_SUBSCRIPT>+32768+<29*65536>

; DEF OF TYPE CODE FOR RIGHT JUSTIFIED ALPHANUMERIC.

DSC$K_DTYPE_TJ	=	30

;
; WORK AREA LAYOUT.
;

	.SAVE
	.PSECT	$ABS$,ABS
	.=0

WORK_DDD_1:	.BLKL	3		; TEMP DDD 1.
WORK_TEMP_1:	.BLKW	10		; TEMP 1.
WORK_DDD_2:	.BLKL	3		; TEMP DDD 2.
WORK_TEMP_2:	.BLKW	10		; TEMP 2.
WORK_DDD_3:	.BLKL	3		; TEMP DDD 3.
WORK_TEMP_3:	.BLKW	10		; TEMP 3.
WORK_DDD_4:	.BLKL	3		; TEMP DDD 4.
WORK_TEMP_4:	.BLKW	10		; TEMP 4.
WORK_DDD_5:	.BLKL	3		; TEMP DDD 5.
WORK_TEMP_5:	.BLKW	10		; TEMP 5.
WORK_DDD_6:	.BLKL	3		; TEMP DDD 6.
WORK_TEMP_6:	.BLKW	10		; TEMP 6.
WORK_DDD_7:	.BLKL	3		; TEMP DDD 7.
WORK_TEMP_7:	.BLKW	10		; TEMP 7.

WORK_FAB:	.BLKB	^X50
WORK_ACCDIS_RAB:.BLKB	^X44		; Formerly WORK_ACC_RAB.
WORK$W_ACC_ISI:	.BLKB	<2*7>		; Formerly WORK_DIS_RAB.
WORK$W_DIS_VFC:	.BLKB	<2*7>		; Seven logical names ACCEPT/DISPLAY.
		.BLKB	<^X44-<2*7>-<2*7>>; Remaining space  now spares.
		.BLKW	1		; formerly INTERNAL FILE IDENTIFIES
		.BLKW	1		; now spares.

WORK_SWITCH:	.BLKL	1		; COBOL SWITCHES.
WORK_OVF_FLAGS:	.BLKB	1		; OVERFLOW FLAGS.
WORK_FIRST_TIME:.BLKB	1		; THE FIRST TIME SWITCH FOR INIT.
 
;
;   Search specific variables
;
 
WORK$A_IXD:	.BLKL	1		; Saved address of index DDD.
 
WORK$L_P:	.BLKL	1		; Table subscript value.
 
WORK$L_SBM:	.BLKL	1		; Index item multiplier
 
WORK$L_TST:	.BLKL	1		; "compare not equal" hook,
					;	where
					;		-1	less than
					;		+1	greater than
 
WORK$L_UB:	.BLKL	1		; Upper-bound
 
WORK$A_FLS:	.BLKL	1		; Saved FALSE path.
 
WORK$A_TRU:	.BLKL	1		; Saved TRUE path.
 
;
;   INSPECT specific variables
;
 
WORK$L_SPS:	.BLKL	1		; Saved stack pointer.
 
WORK$L_TA1:	.BLKL	1		; Cursor (i.e., position within string).
 
WORK$DDD_ID1:	.BLKL	4		; Saved DDD of identifier-1.
 
WORK$A_ID4:	.BLKL	1		; Saved address of DDD of identifier-4.
 
WORK$A_ID5:	.BLKL	1		; Saved address of DDD of identifier-5.
 
WORK$A_ID6:	.BLKL	1		; Saved address of DDD of identifier-6
 
WORK$A_ID11:	.BLKL	1		; Saved address of DDD of identifier-7
 
;
;   String specific data
;
WORK$A_ID7:	.BLKL	1		; Saved address of DDD of identifier-7.
 
WORK$A_ID8:	.BLKL	1		; Saved address of DDD of identifier-8.
 
WORK$DDD_STR:	.BLKL	3		; DDD of substring under investigation.
 
;
; I/O related fields
;

WORK_IO_IOF:	.BLKL	1		; Flags for current I/O operation
WORK_IO_EXS:	.BLKL	1		; Will comment when I find out what it is
 
;
; ISAM specific fields
;
 
WORK_IO_KBF:	.BLKL	1		; Save area for RAB$L_KBF.
WORK_IO_KNB:	.BLKL	1		; Key reference number counter.
WORK_IO_KRF:	.BLKL	1		; Save area for RAB$B_KRF.
WORK_IO_KSZ:	.BLKL	1		; Save area for RAB$B_KSZ.
 

.=0
	.RESTORE
.ENDM

;++
; A SET OF MACROS TO GENERATE THE TABLES FOR CASE INSTRUCTIONS.
; A CASE CAN BE GENERATED AS FOLLOWS:
;
;	CASEx		SELECTOR,BASE,LIMIT
;	START_CASE	BASE
;	A_CASE		VALUE,ADDRESS
;	A_CASE		VALUE,ADDRESS
;		.
;		.
;		.
;	A_CASE		VALUE,ADDRESS
;	END_CASE
;
; WHERE:	SELECTOR IS THE OPERAND SPECIFICATION FOR THE SELECTOR.
;
;		BASE IS AN ASSEMBLY TIME CONSTANT GIVING THE LOWEST SELECTOR
;		     VALUE.
;
;		LIMIT IS THE OPERAND SPECIFIER FOR THE HIGHEST SECLECTOR.
;
;		VALUE AND ADDRESS ARE THE SECLECTOR VALUE AND ADDRESS OF THE
;		CORRESPONDING ROUTINE. (VALUE IS AN ASSEMBLY TIME CONSTANT).
;
; THE SELECTOR VALUES NEED NOT BE IN ORDER, THUS BY USING SYMBOLIC NAMES FOR
; THE VALUES, NO REARRANGEMENT IS NECESSARY IF SELECTOR VALUES ARE ALTERED.
;--
.MACRO	START_CASE	BASE=0
CASE_BASE=	BASE	
CASE_START=	.
MAX_DOT=	.
.ENDM


.MACRO	A_CASE	VALUE,ADDRESS
.=	CASE_START+<<VALUE-CASE_BASE>*2>
	.WORD	ADDRESS-CASE_START
.IF	GT,.-MAX_DOT
MAX_DOT =	.
.ENDC
.ENDM

.MACRO	END_CASE
.=	MAX_DOT
.ENDM


;++
; FACILITY: DEBUG 32
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS MODULE CONTAINS ALL THE CONVERSION ROUTINES BETWEEN ALL
;	COBOL DATA TYPES.  CONVERSION ROUTINES ARE CALLED WITH THE
;	SOURCE AND DESTINATION DESCRIPTORS AS PARAMETERS.  THE ROUTINE
;	THEN DETERMINES WHICH CONVERSION IS APPLICABLE AND RETURNS THE
;	DESCRIPTOR OF THE RESULT.
;
; ENVIRONMENT: DEBUG 32 / VAX-VMS
;
; AUTHOR: BOB KUSHLIS, CREATION DATE: 22-MAR-78
;
; MODIFIED BY:
;
; 01:	MARK STORM;	20-JUN-78	;KLUDGE FOR CVTTP INST.
;   :		MARK STORM;	07-JUL-78
;   :		MARK STORM;	28-JUL-78
;
;	Wm P Storey, 27-Jan-1979
; 02	-	change PSECT name from C74$ to C74$_ for shareable image.
;		note that CONVERT contains no UNIVERSAL symbols.
;
;	Wm P Storey, 31-Jan-1979
; 03	-	make addresses of tables global for Jud Leonard modifications.
;
;	Wm P Storey,  1-Mar-1979
; 04	-	make all global names of the form C74$xyzabc.
;
;	Wm P Storey,  5-Mar-1979
; 05	-	make module name of form C74$title.
;
;	Wm P Storey, 26-Mar-1979
; 06	-	modify C74$CVT_x_P routines for COMP data-types to maximize
;		the length of the (temporary) destination to 5, 10, and 19
;		digits for word, longword, and quadword, respectively;  also,
;		modify CVTM_Q_P to allow a maximum of 19 digits.
;
;--

	.SBTTL	DECLARATIONS

; CONSTANTS:
	SGNBIT	=	64


;
; INCLUDE FILES:
;

;	.LIBRARY	/[COB11VAX]COBOTS/
	$DSCDEF				; DEFINE DESCRIPTOR EQUATES.
	$COBOTSDEF			; DEFINE COBOL OTS EQUATES.

	.PSECT		DBG$_CONVERT,SHR,PIC,LONG,NOWRT

	.SBTTL	C74$CVT_ANY_L - CONVERT ANYTHING TO 2-WORD BINARY.
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE CONVERTS ANY TYPE TO A 2-WORD BINARY, LEAVING
;	IT IN REGISTER R2.  THIS ROUTINE IS USED FOR CONVERTING SOURCE
;	OPERANDS FOR BOTH 1-WORD AND TWO-WORD GENERAL CASE ROUTINES.
;	THE DESTINATION LENGTH IS THE MAXIMUM LENGTH WHICH WILL BE CONVERTED
;	ON DECIMAL TO BINARY CONVERSIONS.  ON RETURN, THE OVERFLOW BIT IS
;	SET IF THE ITEM WILL NOT FIT IN A SIGNED LONGWORD, OTHERWISE CLEAR.
;
; CALLING SEQUENCE:
;
;	JSB	C74$CVT_ANY_L
;
; INPUT PARAMETERS:
;
;	R6 - DEST LENGTH.
;	R7 - SOURCE DDD ADDRESS.
;
; IMPLICIT INPUTS:
;
;	NONE.
;
; OUTPUT PARAMETERS:
;
;	R2 - CONVERTED ITEM.
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; CONDITION CODES:
;
;	V - SET IF OVERFLOW OCCURS.
;
; SIDE EFFECTS:
;
;	R0,R1,R6 CLOBBERED.
;
;--

;
; THESE ENTRY POINTS ARE USED BY ARITHMETIC ROUTINES, AND FORCE THE
; DEST. LENGTH TO THE MAXIMUM.
; 

C74$CVT_ANY_W:	; CONVERT ANYTHING TO 1-WORD BINARY.
C74$CVT_ANY_L::	; CONVERT ANYTHING TO 2-WORD BINARY.

	MOVL		#9,R6

C74$CVT_ANY_W_M:	; CONVERT ANY TO WORD FOR MOVES
C74$CVT_ANY_L_M::	; CONVERT ANY TO LONG FOR MOVES
 	
	CASEB		DDD_TYPE(R7),#0,#MAXTYPE
	START_CASE
	A_CASE		DSC$K_DTYPE_W,C74$CVT_W_L
	A_CASE		DSC$K_DTYPE_L,C74$CVT_L_L
	A_CASE		DSC$K_DTYPE_Q,C74$CVT_Q_L
	A_CASE		DSC$K_DTYPE_WU,C74$CVT_WU_L
	A_CASE		DSC$K_DTYPE_LU,C74$CVT_LU_L
	A_CASE		DSC$K_DTYPE_QU,C74$CVT_QU_L
	A_CASE		DSC$K_DTYPE_NU,C74$CVT_NU_L
	A_CASE		DSC$K_DTYPE_NR,C74$CVT_NR_L
	A_CASE		DSC$K_DTYPE_NRO,C74$CVT_NRO_L
	A_CASE		DSC$K_DTYPE_NL,C74$CVT_NL_L
	A_CASE		DSC$K_DTYPE_NLO,C74$CVT_NLO_L
	A_CASE		DSC$K_DTYPE_P,C74$CVT_P_L
	A_CASE		DSC$K_DTYPE_NZ,C74$CVT_NU_L
	A_CASE		DSC$K_DTYPE_Z,C74$CVT_W_L
	A_CASE		DSC$K_DTYPE_T,C74$CVT_T_L
	A_CASE		DSC$K_DTYPE_TJ,C74$CVT_T_L
	END_CASE

C74$CVT_W_L:	; CONVERT 1-WORD TO 2-WORD.
C74$CVT_WU_L:	; CONVERT 1-WORD UNSIGNED TO 2-WORD.

	CVTWL		@DDD_ADDRESS(R7),R2	; JUST PICK UP THE WORD.
	RSB

C74$CVT_L_L:	; CONVERT 2-WORD TO 2-WORD.
C74$CVT_LU_L:	; CONVERT 2-WORD UNSIGNED TO 2-WORD.

	MOVL		@DDD_ADDRESS(R7),R2	; JUST PICK UP THE LONGWORD.
	RSB

C74$CVT_Q_L:	; CONVERT 4-WORD TO 2-WORD.
C74$CVT_QU_L:	; CONVERT 4-WORD UNSIGNED TO 2-WORD.

	MOVL		DDD_ADDRESS(R7),R0	; GET ADDRESS OF DATA.
	MOVL		(R0)+,R2		; GET LOWER LONGWORD.
	ASHL		#-31,R2,R1		; GET SIGN EXTEND.
	CMPL		(R0),R1			; COMPARE TO UPPER LONGWORD.
	BEQL		1$			; SKIP IF NO OVERFLOW.
	BISPSW		#2			; SET OVERFLOW BIT.
1$:	RSB

	
C74$CVT_T_L:	; CONVERT ALPHANUMERIC TO LONG.
C74$CVT_NU_L:	; CONVERT DECIMAL UNSIGNED TO 2-WORD.
C74$CVT_NR_L:	; CONVERT DECIMAL TRAILING SIGN TO 2-WORD.
C74$CVT_NRO_L:	; CONVERT DECIMAL RIGHT OVERPUNCH TO 2-WORD.
C74$CVT_NL_L:	; CONVERT DECIMAL LEADING SIGN TO 2-WORD.
C74$CVT_NLO_L:	; CONVERT DECIMAL LEFT OVERPUNCH TO 2-WORD.

	PUSHL		R6			; SAVE DEST LENGTH.
	GET_TEMP_DDD	6,R6			; GET A TEMP.
	MOVB		DDD_SCALE(R7),-		; COPY SCALE TO TEMP DDD.
			DDD_SCALE(R6)
	BSBW		C74$CVT_ANY_P		; CONVERT TO PACKED.
	POPL		R6			; GET DEST LENGTH BACK.
						; AND FALL INTO CONVERSION
						; FROM PACKED TO WORD.

C74$CVT_P_L:	; CONVERT PACKED TO 2-WORD.

	CVTWL		(R7),R0			; GET SOURCE LENGTH
	CMPL		R6,R0			; IS DEST LENGTH < SOURCE?
	BGEQ		1$			; BR IF NO.
	ASHL		#-1,R0,R0		; GET SOURCE BYTE LENGTH -1.
	ASHL		#-1,R6,R1		; GET DEST BYTE LENGTH - 1.
	SUBL2		R1,R0			; GET BYTE LENGTH DIF.
	ADDL2		DDD_ADDRESS(R7),R0	; GET ADJUSTED ADDRESS.
	CVTPL		R6,(R0),R2		; DO THE CONVERSION.
	RSB
	
1$:	CVTPL		(R7),@DDD_ADDRESS(R7),R2; DO THE CONVERSION.
	RSB

	.SBTTL	C74$CVT_L_ANY - CONVERT 2-WORD BINARY TO ANYTHING
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE WILL CONVERT A 2 WORD BINARY ITEM TO ANY TYPE.
;
; CALLING SEQUENCE:
;
;	JSB	C74$CVT_L_ANY
;
; INPUT PARAMETERS:
;
;	R2 - ITEM TO BE CONVERTED
;	R7 - DESTINATION DDD ADDRESS
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R7 - DESTINATION DDD ADDRESS
;
; IMPLICIT OUTPUTS:
;
;	SOURCE CONVERTED AND MOVED TO DESTINATION.
;
; CONDITION CODES:
;
;	UNDEFINED
;
; SIDE EFFECTS:
;
;	R0,R1,R6 CLOBBERED
;
;--

C74$CVT_W_ANY::	; CONVERT 1-WORD BINARY TO ANYTHING.

	CVTWL		R2,R2			; CONVERT TO LONG.

; AND FALL THROUGH TO THE CONVERT 2-WORD TO ANYTHING ROUTINES.

C74$CVT_L_ANY::	; CONVERT 2-WORD BINARY TO ANYTHING.

	CASEB	DDD_TYPE(R7),#0,#MAXTYPE; CASE ON TYPE.
	START_CASE
	A_CASE		DSC$K_DTYPE_W,CVTM_L_W
	A_CASE		DSC$K_DTYPE_WU,CVTM_L_WU
	A_CASE		DSC$K_DTYPE_L,CVTM_L_L
	A_CASE		DSC$K_DTYPE_LU,CVTM_L_LU
	A_CASE		DSC$K_DTYPE_Q,CVTM_L_Q
	A_CASE		DSC$K_DTYPE_QU,CVTM_L_QU
	A_CASE		DSC$K_DTYPE_NU,CVTM_L_NU
	A_CASE		DSC$K_DTYPE_NR,CVTM_L_NR
	A_CASE		DSC$K_DTYPE_NRO,CVTM_L_NRO
	A_CASE		DSC$K_DTYPE_NL,CVTM_L_NL
	A_CASE		DSC$K_DTYPE_NLO,CVTM_L_NLO
	A_CASE		DSC$K_DTYPE_P,CVTM_L_P
	A_CASE		DSC$K_DTYPE_NZ,CVTM_L_NU
	A_CASE		DSC$K_DTYPE_Z,CVTM_L_W
	A_CASE		DSC$K_DTYPE_T,CVTM_L_NU
	A_CASE		DSC$K_DTYPE_TJ,CVTM_L_NU
	END_CASE

CVTM_L_WU:	; CONVERT AND MOVE 2-WORD TO 1-WORD UNSIGNED.
CVTM_Q_WU:	; CONVERT AND MOVE 4-WORD TO 1-WORD UNSIGNED.

	TSTL		R2			; CHECK SIGN OF SOURCE.
	BGEQ		1$			; IS IT NEGATIVE?
	MNEGL		R2,R2			; YES, NEGATE IT.

1$:		; AND FALL THROUGH TO THE MOVE TO 1-WORD ROUTINE.


CVTM_L_W:	; CONVERT AND MOVE 2-WORD TO 1-WORD.
CVTM_Q_W:	; CONVERT AND MOVE 4-WORD TO 1-WORD.

	MOVW		R2,@DDD_ADDRESS(R7)	; JUST MOVE THE WORD.
	RSB


CVTM_L_LU:	; CONVERT AND MOVE 2-WORD TO 2-WORD UNSIGNED.
CVTM_Q_LU:	; CONVERT AND MOVE 4-WORD TO 2-WORD UNSIGNED.

	TSTL		R2			; CHECK SIGN OF SOURCE.
	BGEQ		1$			; IS IT NEGATIVE?
	MNEGL		R2,R2			; YES, NEGATE IT.

1$:		; AND FALL THROUGH TO THE MOVE TO 2-WORD ROUTINES.


CVTM_L_L:	; CONVERT AND MOVE 2-WORD TO 2-WORD.
CVTM_Q_L:	; CONVERT AND MOVE 4-WORD TO 2-WORD.

	MOVL		R2,@DDD_ADDRESS(R7)	; JUST MOVE IT.
	RSB


CVTM_L_Q:	; CONVERT AND MOVE 2-WORD TO 4-WORD.

	ASHL		#-31,R2,R3		; SIGN EXTEND.
						; AND FALL INTO QUAD WORD
						; CONVERT AND MOVE.

CVTM_Q_Q:	; CONVERT AND MOVE 4-WORD TO 4-WORD.

	MOVQ		R2,@DDD_ADDRESS(R7)	; MOVE THE QUAD WORD.
	RSB

CVTM_L_QU:	; CONVERT AND MOVE 2-WORD TO 4-WORD UNSIGNED.

	ASHL		#-31,R2,R3		; SIGN EXTEND.
						; AND FALL INTO 4-WORD
						; TO 4-WORD UNSIGNED MOVE.

CVTM_Q_QU:	; CONVERT AND MOVE 4-WORD TO 4-WORD UNSIGNED.

	TSTL		R3			; CHECK SIGN OF SOURCE.
	BGEQ		1$			; IS IT NEGATIVE?
	MNEGL		R2,R2			; YES, NEGATE IT.
	ADWC		#0,R3			; ADD CARRY.
	MNEGL		R3,R3			; NEGATE UPPER WORD.
1$:	MOVQ		R2,@DDD_ADDRESS(R7)	; MOVE THE QUAD WORD.
	RSB

CVTM_L_NR:	; CONVERT AND MOVE 2-WORD TO DECIMAL TRAILING SIGN.
CVTM_L_NRO:	; CONVERT AND MOVE 2-WORD TO DECIMAL RIGHT OVERPUNCH.
CVTM_L_NL:	; CONVERT AND MOVE 2-WORD TO DECIMAL LEADING SIGN.
CVTM_L_NLO:	; CONVERT AND MOVE 2-WORD TO DECIMAL LEFT OVERPUNCH.
CVTM_L_NU:	; CONVERT AND MOVE 2-WORD TO DECIMAL UNSIGNED.

	MOVL		R7,R6			; PUT DEST DDD IN R6.
	GET_TEMP_DDD	6,R7			; GET A TEMP.
	MOVL		(R6),(R7)		; COPY LENGTH TO TEMP DDD.
	CVTLP		R2,(R6),@DDD_ADDRESS(R7); CONVERT TO PACKED.
	JMP		C74$CVT_P_ANY		; AND GO TO CONVERT PACKED
						; TO ANY ROUTINE.
CVTM_L_P:	; CONVERT AND MOVE 2-WORD TO PACKED.

.IF	DF,DBG_UTL1
	PUSHL	R2
	PUSHAB	DBG$UTL_STR1
	CALLS	#2,DBG$FAO_OUT
.ENDC

	CVTLP		R2,(R7),@DDD_ADDRESS(R7); CONVERT TO PACKED.
.IF   DF,DBG_UTL1
	PUSHL  @DDD_ADDRESS(R7)
	PUSHAB DBG$UTL_STR4
	CALLS  #2,DBG$FAO_OUT
.ENDC
	RSB

	.SBTTL	C74$CVT_ANY_Q - CONVERT ANYTHING TO 4-WORD BINARY.
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE CONVERTS ANY TYPE TO A 4-WORD BINARY.  IF THE
;	SOURCE IS ALREADY COMPATABLE WITH 4-WORD BINARY, NO THE
;	SOURCE IS RETURNED WITHOUT CONVERSION.
;
; CALLING SEQUENCE:
;
;	JSB	C74$CVT_ANY_Q
;
; INPUT PARAMETERS:
;
;	R6 - DEST LENGTH.
;	R7 - SOURCE DDD ADDRESS.
;
; IMPLICIT INPUTS:
;
;	NONE.
;
; OUTPUT PARAMETERS:
;
;	R2,R3 CONVERTED RESULT.
;
; IMPLICIT OUTPUTS:
;
;	CONVERSION DONE IF NECESSARY.
;
; CONDITION CODES:
;
;	UNDEFINED.
;
; SIDE EFFECTS:
;
;	R0,R1,R6 CLOBBERED.
;
;--

;
; THIS ENTRY USED FOR ARITHMETICS, SETS DEST LENGTH TO MAX.
;

C74$CVT_ANY_Q::			; CONVERT ANYTHING TO 4-WORD BINARY.

	MOVL		#18,R6			; SET MAX LENGTH.

C74$CVT_ANY_Q_M::

	CASEB		DDD_TYPE(R7),#0,#MAXTYPE
	START_CASE
	A_CASE		DSC$K_DTYPE_W,C74$CVT_W_Q
	A_CASE		DSC$K_DTYPE_L,C74$CVT_L_Q
	A_CASE		DSC$K_DTYPE_Q,C74$CVT_Q_Q
	A_CASE		DSC$K_DTYPE_WU,C74$CVT_WU_Q
	A_CASE		DSC$K_DTYPE_LU,C74$CVT_LU_Q
	A_CASE		DSC$K_DTYPE_QU,C74$CVT_QU_Q
	A_CASE		DSC$K_DTYPE_NU,C74$CVT_NU_Q
	A_CASE		DSC$K_DTYPE_NR,C74$CVT_NR_Q
	A_CASE		DSC$K_DTYPE_NRO,C74$CVT_NRO_Q
	A_CASE		DSC$K_DTYPE_NL,C74$CVT_NL_Q
	A_CASE		DSC$K_DTYPE_NLO,C74$CVT_NLO_Q
	A_CASE		DSC$K_DTYPE_P,C74$CVT_P_Q
	A_CASE		DSC$K_DTYPE_NZ,C74$CVT_NU_Q
	A_CASE		DSC$K_DTYPE_Z,C74$CVT_W_Q
	A_CASE		DSC$K_DTYPE_T,C74$CVT_T_Q
	A_CASE		DSC$K_DTYPE_TJ,C74$CVT_T_Q
	END_CASE

C74$CVT_Q_Q:	; CONVERT 4-WORD TO 4-WORD.
C74$CVT_QU_Q:	; CONVERT 4-WORD UNSIGNED TO 4-WORD.

	MOVQ		@DDD_ADDRESS(R7),R2	; JUST MOVE THE QUAD-WORD.
	RSB					; NO CONVERSION NECESSARY.

C74$CVT_W_Q:	; CONVERT 1-WORD TO 4-WORD.
C74$CVT_WU_Q:	; CONVERT 1-WORD UNSIGNED TO 4-WORD.

	CVTWL		@DDD_ADDRESS(R7),R2	; CONVERT THE WORD TO LONG.
	ASHL		#-31,R2,R3		; AND SIGN EXTEND TO QUAD.
	RSB

C74$CVT_L_Q:	; CONVERT 2-WORD TO 4-WORD.
C74$CVT_LU_Q:	; CONVERT 2-WORD UNSIGNED TO 4-WORD.

	MOVL		@DDD_ADDRESS(R7),R2	; GET THE LONG-WORD.
	ASHL		#-31,R2,R3		; SIGN EXTEND IT.
	RSB

C74$CVT_T_Q:	; CONVERT ALPHANUMERIC TO 4-WORD.
C74$CVT_NRO_Q:	; CONVERT RIGHT OVERPUNCH TO 4-WORD.
C74$CVT_NR_Q:	; CONVERT TRAILING SEPARATE TO 4-WORD.
C74$CVT_NLO_Q:	; CONVERT LEFT OVERPUNCH TO 4-WORD.
C74$CVT_NL_Q:	; CONVERT LEADING SEPARATE TO 4-WORD.
C74$CVT_NU_Q:	; CONVERT DECIMAL UNSIGNED TO 4-WORD.

	PUSHL		R6			; SAVE DEST LENGTH.
	GET_TEMP_DDD	6,R6			; GET A TEMP DDD.
	MOVB		DDD_SCALE(R7),-		; COPY SCALE TO DEST DDD.
			DDD_SCALE(R6)
	BSBW		C74$CVT_ANY_P		; CONVERT TO PACKED.
	POPL		R6			; RESTORE DEST LENGTH.
						; AND FALL THROUGH.

C74$CVT_P_Q:	; CONVERT PACKED TO 4-WORD.

	CVTWL		(R7),R0			; GET LENGTH IN R0.
	MOVL		DDD_ADDRESS(R7),R1	; GET ADDRESS IN R1.
	CMPL		R0,R6			; IS SOURCE LENGTH < DEST?
	BLEQ		2$			; BR IF YES.
	ASHL		#-1,R0,R1		; GET SOURCE LENGTH-1.
	ASHL		#-1,R6,R0		; GET DEST LENGTH-1.
	SUBL2		R0,R1 			; GET LENGTH DIF.
	ADDL2		DDD_ADDRESS(R7),R1	; GET ADJUSTED ADDRESS.
	MOVL		R6,R0			; GET LENGTH.

2$:	CMPL		R0,#9			; LENGTH < 10?
	BGTR		1$			; IF NOT, DO IT THE HARD WAY.
	CVTPL		R0,(R1),R2		; ELSE, DO IT THE EASY WAY.
	ASHL		#-31,R2,R3		; SIGN EXTEND.
	RSB

1$:	MOVQ		R0,-(SP)		; SAVE ADJUSTED SOURCE DESC.
	SUBL2		#8,R0			; CALCULATE ADDRESS OF LOWER
	DIVL2		#2,R0			; NINE DIGITS OF THE PACKED
	ADDL2		R1,R0			; NUMBER.
	CVTPL		#9,(R0),R6		; CONVERT LOW 9 INT0 R6.
	MOVQ		(SP)+,R0		; RESTORE ADJUSTED DESC.
	SUBL2		#5,SP			; ALLOCATE 9 DIGIT PACKED TEMP
	ASHP		#-9,R0,(R1),-		; GET UPPER 9 (OR LESS) DIGITS
			#0,#9,(SP)
	CVTPL		#9,(SP),R0		; CONVERT UPPER 9 DIGITS.
	ADDL2		#5,SP			; DEALLOCATE OUR TEMP.
	EMUL		#1000000000,R0,R6,R2	; COMBINE THE TWO HALVES.
	RSB

	.SBTTL	C74$CVT_Q_ANY - CONVERT 4-WORD BINARY TO ANYTHING
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE WILL CONVERTY A 4 WORD BINARY ITEM TO ANY TYPE.
;	A MOVE TO THE DESTINATION IS GUARANTEED EVEN IF NO CONVERSION
;	IS NECESSARY.
;
; CALLING SEQUENCE:
;
;	JSB	C74$CVT_Q_ANY
;
; INPUT PARAMETERS:
;
;	R7 - SOURCE DDD ADDRESS
;	R2,R3 - ITEM TO BE CONVERTED
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R7 - DESTINATION DDD ADDRESS
;
; IMPLICIT OUTPUTS:
;
;	SOURCE CONVERTED AND MOVED TO DESTINATION.
;
; CONDITION CODES:
;
;	UNDEFINED
;
; SIDE EFFECTS:
;
;	R0,R1,R6 CLOBBERED
;
;--

C74$CVT_Q_ANY::				; CONVERT WORD TO ANYTHING.

	CASEB	DDD_TYPE(R7),#0,#MAXTYPE; CASE ON TYPE.
	START_CASE
	A_CASE		DSC$K_DTYPE_W,CVTM_Q_W
	A_CASE		DSC$K_DTYPE_WU,CVTM_Q_WU
	A_CASE		DSC$K_DTYPE_L,CVTM_Q_L
	A_CASE		DSC$K_DTYPE_LU,CVTM_Q_LU
	A_CASE		DSC$K_DTYPE_Q,CVTM_Q_Q
	A_CASE		DSC$K_DTYPE_QU,CVTM_Q_QU
	A_CASE		DSC$K_DTYPE_NU,CVTM_Q_NU
	A_CASE		DSC$K_DTYPE_NR,CVTM_Q_NR
	A_CASE		DSC$K_DTYPE_NRO,CVTM_Q_NRO
	A_CASE		DSC$K_DTYPE_NL,CVTM_Q_NL
	A_CASE		DSC$K_DTYPE_NLO,CVTM_Q_NLO
	A_CASE		DSC$K_DTYPE_P,CVTM_Q_P
	A_CASE		DSC$K_DTYPE_NZ,CVTM_Q_NU
	A_CASE		DSC$K_DTYPE_Z,CVTM_Q_W
	A_CASE		DSC$K_DTYPE_T,CVTM_Q_NU
	A_CASE		DSC$K_DTYPE_TJ,CVTM_Q_NU
	END_CASE

CVTM_Q_P:	; CONVERT AND MOVE 4-WORD TO PACKED.

	CMPW		(R7),#9			; LENGHT < 9?
	BGTR		1$			; IF NOT, DO IT THE HARD WAY.
	BRW		CVTM_L_P		; ELSE, DO IT THE EASY WAY

1$:	PUSHL		R3			; SAVE UPPER LONGWORD.
	EDIV		#1000000000,R2,R0,-(SP)	; GET TWO 9-DIGITS PIECES.
	SUBL2		#6,SP			; Get S9(19) COMP-3 stack temp.
	CVTLP		R0,#10,(SP)		; Convert upper 10 digits.
	ASHP		#9,#10,(SP),#0,(R7),-	; Move upper 10 into result.
			@DDD_ADDRESS(R7)
	ADDL2		#6,SP			; Deallocate stack temp.
	CVTWL		(R7),R0			; CALUCLATE THE ADDRESS OF
	SUBL2		#8,R0			; LOWER NINE DIGITS OF THE
	DIVL2		#2,R0			; PACKED STRING.
	ADDL2		DDD_ADDRESS(R7),R0	
	CVTLP		(SP)+,#9,(R0)		; CONVERT LOWER NINE.
	MOVL		(SP)+,R0		; GET BACK UPPER WORD.
	BGEQ		2$			; BR IF PLUS.
	ADDL2		#4,R3			; POINT TO NEXT DIGIT.
	BISB		#1,(R3)			; INSURE SIGN IS NEGATIVE.
2$:	RSB					; THAT'S ALL FOLKS.

CVTM_Q_NRO:	; CONVERT AND MOVE 4-WORD TO RIGHT OVERPUNCH.
CVTM_Q_NR:	; CONVERT AND MOVE 4-WORD TO TRAILING SEPARATE.
CVTM_Q_NLO:	; CONVERT AND MOVE 4-WORD TO LEFT OVERPUNCH.
CVTM_Q_NL:	; CONVERT AND MOVE 4-WORD TO LEADING SEPARATE.
CVTM_Q_NU:	; CONVERT AND MOVE 4-WORD TO DECIMAL UNSIGNED.

	MOVL		R7,R6			; MOVE DEST DDD TO R6.
	GET_TEMP_DDD	6,R7			; GET A TEMP IN R7.
	MOVW		(R6),(R7)		; PLUG IN THE LENGTH.
	JSB		CVTM_Q_P		; CONVERT TO PACKED IN TEMP.
.IF  DF,DBG_UTL1
	PUSHAB  DBG$UTL_STR5
	CALLS	#1,DBG$FAO_OUT
.ENDC
	BRW		C74$CVT_P_ANY		; CONVERT PACKED ITEM TO DEST.

.SBTTL	C74$CVT_ANY_P	- CONVERT ANYTHING TO PACKED DECIMAL
;++
; FUNCTIONAL DESCRIPTION:
;
;	$C74$CVT_ANY_P IS THE OTS UTILITY ROUTINE TO CONVERT ANY DATA TYPE
;	TO PACKED DECIMAL.  A CASE STATEMENT IS USED TO JUMP TO EACH
;	INDIVIDUAL CONVERSION ROUTINE.
;
; CALLING SEQUENCE:
;
;	JSB	C74$CVT_ANY_P
;
; INPUT PARAMETERS:
;
;	R7 - POINTER TO THE DDD OF THE OPERAND TO BE CONVERTED TO PACKED
;	R6 - POINTER TO THE DDD OF A TEMP TO CONVERT INTO
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R6 - POINTER TO DDD CONTAIN THE RESULT
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; CONDITION CODES:
;
;	UNDEFINED
;
; SIDE EFFECTS:
;
;	R0 - R3 CLOBBERED
;
;--

C74$CVT_ANY_P::

	CASEB	DDD_TYPE(R7),#0,#MAXTYPE

	START_CASE
	A_CASE		DSC$K_DTYPE_W,C74$CVT_W_P
	A_CASE		DSC$K_DTYPE_L,C74$CVT_L_P
	A_CASE		DSC$K_DTYPE_Q,C74$CVT_Q_P
	A_CASE		DSC$K_DTYPE_WU,C74$CVT_W_P
	A_CASE		DSC$K_DTYPE_LU,C74$CVT_L_P
	A_CASE		DSC$K_DTYPE_QU,C74$CVT_Q_P
	A_CASE		DSC$K_DTYPE_NU,C74$CVT_NU_P
	A_CASE		DSC$K_DTYPE_NR,C74$CVT_NR_P
	A_CASE		DSC$K_DTYPE_NRO,C74$CVT_NRO_P
	A_CASE		DSC$K_DTYPE_NL,C74$CVT_NL_P
	A_CASE		DSC$K_DTYPE_NLO,C74$CVT_NLO_P
	A_CASE		DSC$K_DTYPE_P,C74$CVT_P_P
	A_CASE		DSC$K_DTYPE_NZ,C74$CVT_NU_P
	A_CASE		DSC$K_DTYPE_Z,C74$CVT_W_P
	A_CASE		DSC$K_DTYPE_T,C74$CVT_T_P
	A_CASE		DSC$K_DTYPE_TJ,C74$CVT_T_P
	END_CASE

C74$CVT_P_P:

	RSB		;NO CONVERSION NECESSARY

C74$CVT_W_P:	; CONVERT 1-WORD TO PACKED.

	CVTWL		@DDD_ADDRESS(R7),R2	; CONVERT TO LONG.
;	MOVW		(R7),(R6)		; COPY LENGHT.
	MOVW		#5,(R6)			; Maximize length for COMP.
	MOVL		R6,R7			; RETURN DEST DDD.
	BRW		CVTM_L_P		; CONVERT LONG TO PACKED.

C74$CVT_L_P:	; CONVERT 2-WORD TO PACKED.

	MOVL		@DDD_ADDRESS(R7),R2	; GET THE LONGWORD.
;	MOVW		(R7),(R6)		; COPY LENGTH TO DEST.
	MOVW		#10,(R6)		; Maximize length for COMP.
	MOVL		R6,R7			; RETURN DEST DDD.
	BRW		CVTM_L_P		; CONVERT LONG TO PACKED.

C74$CVT_Q_P:	; CONVERT 4-WORD TO PACKED.

	MOVQ		@DDD_ADDRESS(R7),R2	; GET THE QUADWORD.
;	MOVW		(R7),(R6)		; COPY LENGTH TO DEST.
	MOVW		#19,(R6)		; Maximize length for COMP.
	MOVL		R6,R7			; RETURN DEST DDD.
	BRW		CVTM_Q_P		; CONVERT QUAD TO PACKED.

.SBTTL	C74$CVT_NR_P	- TRAILING SEPARATE TO PACKED CONVERION ROUTINE

C74$CVT_NR_P::

	GET_TEMP_DDD	7,R0		;GET THE TEMP DDD TO USE

	CVTWL	DDD_LENGTH(R7),R2	;GET SOURCE LENGTH
	MOVL	DDD_ADDRESS(R7),R1	;GET SOURCE ADDRESS
	MOVL	DDD_ADDRESS(R0),R3	;GET TEMP ADDRESS
	INCL	R3			;LEAVE A PLACE FOR THE LEADING SIGN

10$:	MOVB	(R1)+,(R3)+		;MOVE A DIGIT FROM SOURCE TO TEMP
	SOBGTR	R2,10$			;LOOP UNTIL ALL SOURCE DIGITS ARE MOVED

	MOVB	(R1),@DDD_ADDRESS(R0)	;MOVE SIGN BYTE FROM TRAILING SEPARATE
					;TO LEADING SEPARATE.

	MOVW	DDD_LENGTH(R7),DDD_LENGTH(R6)	;COPY LENGTH TO 'NEW' DDD

	CVTSP	DDD_LENGTH(R7),@DDD_ADDRESS(R0),-	;CONVERT TO PACKED
		DDD_LENGTH(R6),@DDD_ADDRESS(R6)

	MOVL	R6,R7			;RETURN DDD ADDRESS

	RSB				;FINISHED




.SBTTL	C74$CVT_NRO_P	- TRAILING NUMERIC TO PACKED CONVERSION ROUTINE


C74$CVT_NRO_P:
C74$CVT_NU_P:

	MOVW	DDD_LENGTH(R7),DDD_LENGTH(R6)		;COPY LENGTHS

	CVTTP	DDD_LENGTH(R7),@DDD_ADDRESS(R7),-	;CONVERT IT 
		C74$_OPCH_P_TBL,-
		DDD_LENGTH(R6),@DDD_ADDRESS(R6)

	MOVL	R6,R7					;RETURN RESULTING DDD

	RSB						;FINISHED

.SBTTL	CONVERT ALPHANUMERIC TO PACKED.

C74$CVT_T_P:

	CMPW		DDD_LENGTH(R7),#18	; IS IT < 18 IN LENGTH?
	BLEQ		C74$CVT_NRO_P		; NO, USE LOWER 18 DIGITS.
	CVTWL		DDD_LENGTH(R7),R0
	ADDL2		DDD_ADDRESS(R7),R0
	SUBL2		#18,R0
	CVTTP		#18,(R0),-		; DO THE CONVERT.
			C74$_OPCH_P_TBL,-
			#18,@DDD_ADDRESS(R6)
	MOVW		#18,DDD_LENGTH(R6)
	MOVL		R6,R7
	RSB

.SBTTL	C74$CVT_NL_P	- LEADING SEPARATE TO PACKED CONVERSION ROUTINE

C74$CVT_NL_P:

	MOVW	DDD_LENGTH(R7),DDD_LENGTH(R6)		;COPY LENGTHS

	CVTSP	DDD_LENGTH(R7),@DDD_ADDRESS(R7),-	;CONVERT IT
		DDD_LENGTH(R6),@DDD_ADDRESS(R6)

	MOVL	R6,R7					;RETURN DDD ADDRESS

	RSB						;FINISHED

.SBTTL	C74$CVT_NLO_P	- LEFT OVERPUNCH TO PACKED CONVERSION ROUTINE

C74$CVT_NLO_P:

	PUSHL	R4				;SAVE R4
	PUSHL	R5				;SAVE R5

	GET_TEMP_DDD	7,R5			;GET TEMP DDD ADDRESS

	MOVL	DDD_ADDRESS(R5),R3		;GET ADDRESS OF TEMP STRING
	CVTWL	DDD_LENGTH(R7),R2		;GET SOURCE LENGTH
	MOVW	R2,DDD_LENGTH(R6)		;COPY LENGTH TO RESULT DDD
	MOVL	DDD_ADDRESS(R7),R4		;GET SOURCE ADDRESS
	CVTBL	(R4)+,R0			;GET 1ST BYTE OF SOURCE
	MOVB	OVERPUNCH_Z_TBL[R0],R1		;PICK UP THE 1ST BYTE
	BITB	#SGNBIT,R1			;IS IT NEGATIVE
	BEQL	1$				;NO
	BICB	#SGNBIT,R1			;YES, TURN OFF SIGN BIT
	MOVB	#^A/-/,(R3)+			;MOVE '-' AS LEADING SIGN
	BRB	2$				;

1$:	MOVB	#^A/+/,(R3)+			;ITS POSITIVE, MOVE A '+'
2$:	MOVB	R1,(R3)+			;MOVE THE MOST SIGNIFICANT DIGIT
	DECL	R2				;DECREMENT LENGTH BY ONE
 	BEQL	3$				;

10$:	MOVB	(R4)+,(R3)+			;MOVE A DIGIT
	SOBGTR	R2,10$				;LOOP UNTIL ALL ARE MOVED

3$:	CVTSP	DDD_LENGTH(R7),@DDD_ADDRESS(R5),-	;CONVERT FROM THE LEADING
		DDD_LENGTH(R6),@DDD_ADDRESS(R6)		;SEPARATE TEMP TO PACKED

	MOVL	R6,R7				;RETURN DDD ADDRESS
	POPL	R5				;RESTORE R5
	POPL	R4				;RESTORE R4

	RSB




.SBTTL	OVERPUNCH TO PACKED TRANSLATION TABLE

C74$_OPCH_P_TBL::

;			     DECIMAL INDEX

	.BLKB	33.		;    0 - 32
	.BYTE	^X 0D		;	 33
	.BLKB	14.		;   34 - 47
	.BYTE	^X 0C		; 	 48
	.BYTE	^X 1C		;	 49
	.BYTE	^X 2C		;	 50
	.BYTE	^X 3C		;	 51
	.BYTE	^X 4C		;	 52
	.BYTE	^X 5C		;	 53
	.BYTE	^X 6C		;	 54
	.BYTE	^X 7C		;	 55
	.BYTE	^X 8C		;	 56
	.BYTE	^X 9C		;	 57
	.BYTE	^X 0D		;	 58
	.BLKB	4.		;   59 - 62
	.BYTE	^X 0C		;	 63
	.BYTE	0		;	 64
	.BYTE	^X 1C		;	 65
	.BYTE	^X 2C		;	 66
	.BYTE	^X 3C		;	 67
	.BYTE	^X 4C		;	 68
	.BYTE	^X 5C		;	 69
	.BYTE	^X 6C		;	 70
	.BYTE	^X 7C		;	 71
	.BYTE	^X 8C		;	 72
	.BYTE	^X 9C		;	 73
	.BYTE	^X 1D		;	 74
	.BYTE	^X 2D		;	 75
	.BYTE	^X 3D		;	 76
	.BYTE	^X 4D		;	 77
	.BYTE	^X 5D		;	 78
	.BYTE	^X 6D		;	 79
	.BYTE	^X 7D		;	 80
	.BYTE	^X 8D		;	 81
	.BYTE	^X 9D		;	 82
	.BLKB	8.		;   83 - 90
	.BYTE	^X 0C		;	 91
	.BYTE	0		;	 92
	.BYTE	^X 0D		;	 93
	.BLKB	29.		;  94 - 122
	.BYTE	^X 0C		;	123
	.BYTE	    0		;	124
	.BYTE	^X 0D		;	125

.SBTTL	C74$CVT_P_ANY	- CONVERT PACKED TO ANYTHING CASE
;++
; FUNCTIONAL DESCRIPTION:
;
;	$C74$CVT_P_ANY IS THE COBOL OTS UTILITY TO CONVERT A PACKED
;	OPERAND TO ANY DATA TYPE.  A CASE INSTRUCTION IS USED TO
;	BRANCH TO THE APPROPRIATE INDIVIDUAL CONVERSION ROUTINE.
;
; CALLING SEQUENCE:
;
;	JSB	C74$CVT_P_ANY
;
; INPUT PARAMETERS:
;
;	R7 - POINTER TO DDD OF OPERAND TO BE CONVERTED
;	R6 - POINTER TO DDD OF A TEMP TO BE USED IF NEEDED
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R7 - POINTER TO DDD CONTAINING THE CONVERTED OPERAND
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; CONDITION CODES:
;
;	UNDEFINED
;
; SIDE EFFECTS:
;
;	R0 - R3 CLOBBERED
;
;--

C74$CVT_P_ANY::

	CASEB	DDD_TYPE(R6),#0,#MAXTYPE

	START_CASE
	A_CASE		DSC$K_DTYPE_W,CVTM_P_W
	A_CASE		DSC$K_DTYPE_L,CVTM_P_L
	A_CASE		DSC$K_DTYPE_Q,CVTM_P_Q
	A_CASE		DSC$K_DTYPE_WU,CVTM_P_WU
	A_CASE		DSC$K_DTYPE_LU,CVTM_P_LU
	A_CASE		DSC$K_DTYPE_QU,CVTM_P_QU
	A_CASE		DSC$K_DTYPE_NU,CVTM_P_NU
	A_CASE		DSC$K_DTYPE_NR,CVTM_P_NR
	A_CASE		DSC$K_DTYPE_NRO,CVTM_P_NRO
	A_CASE		DSC$K_DTYPE_NL,CVTM_P_NL
	A_CASE		DSC$K_DTYPE_NLO,CVTM_P_NLO
	A_CASE		DSC$K_DTYPE_P,C74$CVT_P_P
	A_CASE		DSC$K_DTYPE_NZ,CVTM_P_NU
	A_CASE		DSC$K_DTYPE_Z,CVTM_P_W
	A_CASE		DSC$K_DTYPE_T,CVTM_P_NU
	A_CASE		DSC$K_DTYPE_TJ,CVTM_P_NU
	END_CASE

.SBTTL	CVTM_P_NU	- PACKED TO UNSIGNED DECIMAL CONVERSION ROUTINE

CVTM_P_NU:

	CVTPT	DDD_LENGTH(R7),@DDD_ADDRESS(R7),-
		C74$_P_UNSN_TBL,-
		DDD_LENGTH(R6),@DDD_ADDRESS(R6)

	MOVL	R6,R7
	RSB


.SBTTL	CVTM_P_NR	- PACKED TO TRAILING SEPARATE CONVERSION ROUTINE

CVTM_P_NR:

	PUSHL		R4		;SAVE R4
	GET_TEMP_DDD	7,R4		;GET TEMP DDD ADDRESS

	CVTWL	DDD_LENGTH(R7),R5	;GET SOURCE LENGTH

	CVTPS	R5,@DDD_ADDRESS(R7),-	;CONVERT PACKED TO LEADING SEPARATE
		DDD_LENGTH(R6),@DDD_ADDRESS(R4)

;* MOVE LEAD SEPARATE TEMP INTO THE TRAILING SEPARATE DESTINATION

	MOVL	DDD_ADDRESS(R4),R1	;GET ADDRESS OF THE TEMP STRING
	MOVL	DDD_ADDRESS(R6),R3	;GET ADDRESS OF THE DEST STRING
	INCL	R1			;POINT PAST THE LEADING SIGN

	CVTWL	DDD_LENGTH(R6),R5	;GET DEST LENGTH
10$:	MOVB	(R1)+,(R3)+		;MOVE A DIGIT FROM THE TEMP TO THE DEST
	SOBGTR	R5,10$			;LOOP UNTIL ALL DIGITS ARE MOVED

	MOVB	@DDD_ADDRESS(R4),(R3)	;MOVE THE SEPARATE SIGN

	MOVL	R6,R7			;RETURN THE CORRECT DDD POINTER
	POPL	R4			;RESTORE R4

	RSB				;FINISHED





.SBTTL	CVTM_P_NRO	- PACKED TO RIGHT OVERPUNCHED CONVERSION ROUTINE

CVTM_P_NRO:


	CVTPT	DDD_LENGTH(R7),@DDD_ADDRESS(R7),-
		C74$_P_OPCH_TBL,-
		DDD_LENGTH(R6),@DDD_ADDRESS(R6)

	MOVL	R6,R7

	RSB

.SBTTL	CVTM_P_NL	- PACKED TO LEADING SEPARATE SIGN CONVERSION ROUTINE

CVTM_P_NL:

.IF DF,DBG_UTL1
	PUSHAB   DBG$UTL_STR6
	CALLS   #1,DBG$FAO_OUT
.ENDC
	CVTPS	DDD_LENGTH(R7),@DDD_ADDRESS(R7),-
		DDD_LENGTH(R6),@DDD_ADDRESS(R6)

.IF DF,DBG_UTL1
	PUSHL	DDD_ADDRESS(R6)
	MOVZWL  DDD_LENGTH(R6),-(SP)
	INCL	(SP)
	PUSHL	@DDD_ADDRESS(R7)
	PUSHAB DBG$UTL_STR7
	CALLS	#4,DBG$FAO_OUT
.ENDC
	MOVL	R6,R7

	RSB

.SBTTL	CVTM_P_NLO	- PACKED TO LEFT OVERPUNCHED CONVERSION ROUTINE

CVTM_P_NLO:

	PUSHL		R4			;SAVE R4
	PUSHL		R5			;SAVE R5
	GET_TEMP_DDD	7,R5			;GET TEMP DDD ADDRESS

	CVTWL	DDD_LENGTH(R7),R4		;GET SOURCE LENGTH

	CVTPS	R4,@DDD_ADDRESS(R7),-		;CONVERT FROM PACKED TO
		DDD_LENGTH(R6),@DDD_ADDRESS(R5)	;LEADING SEPARATE SIGN

	MOVL	DDD_ADDRESS(R5),R3		;GET TEMP'S ADDRESS
	MOVL	DDD_ADDRESS(R6),R1		;GET DEST ADDRESS
	INCL	R3				;POINT PAST SIGN BYTE

	CVTWL	DDD_LENGTH(R6),R4		;GET LENGTH
10$:	MOVB	(R3)+,(R1)+			;MOVE A DIGIT FROM TEMP TO DEST
	SOBGTR	R4,10$				;LOOP UNTIL ALL DIGITS ARE MOVED
	MOVL	DDD_ADDRESS(R6),R1		;GET THE ADDRESS OF THE DEST
	CVTBL	(R1),R0				;GET THE LEFTMOST BYTE
	CMPB	#^A/-/,@DDD_ADDRESS(R5)		;IS THE TEMP NEGATIVE
	BNEQ	1$				;NO,
	BISB	#SGNBIT,R0			;YES, SET THE SIGN BIT ON
1$:	MOVB	Z_OVERPUNCH_TBL[R0],(R1)	;REPLACE IT WITH OVERPUNCH CHAR

	MOVL	R6,R7				;RETURN DDD ADDRESS
	POPL	R5				;RESTORE R5
	POPL	R4				;RESTORE R4
	RSB

	.SBTTL	CONVERT AND MOVE PACKED TO BINARY.

CVTM_P_WU:	; CONVERT PACKED TO 1-WORD UNSIGNED.

	CVTPL		(R7),@DDD_ADDRESS(R7),R0
	BGEQ		1$
	MNEGW		R0,R0
1$:	MOVW		R0,@DDD_ADDRESS(R6)
	RSB

CVTM_P_W:	; CONVERT PACKED TO 1-WORD.

	CVTPL		(R7),@DDD_ADDRESS(R7),R0
	MOVW		R0,@DDD_ADDRESS(R6)
	RSB

CVTM_P_LU:	; CONVERT PACKED TO 2-WORD UNSIGNED.

	CVTPL		(R7),@DDD_ADDRESS(R7),@DDD_ADDRESS(R6)
	BGEQ		1$
	MNEGL		@DDD_ADDRESS(R6),@DDD_ADDRESS(R6)
1$:	RSB

CVTM_P_L:	; CONVERT PACKED TO 2-WORD.

	CVTPL		(R7),@DDD_ADDRESS(R7),@DDD_ADDRESS(R6)
	RSB

CVTM_P_QU:	; CONVERT PACKED TO 4-WORD UNSIGNED.

	PUSHL		R6
	MOVL		#18,R6
	BSBW		C74$CVT_P_Q
	POPL		R7
	BRW		CVTM_Q_QU

CVTM_P_Q:	; CONVERT PACKED TO 4-WORD.

	PUSHL		R6
	MOVL		#18,R6
	BSBW		C74$CVT_P_Q
	POPL		R6
	MOVQ		R2,@DDD_ADDRESS(R6)
	RSB

.SBTTL	PACKED TO OVERPUNCH TRANSLATION TABLE

C74$_P_OPCH_TBL::					; edit 03

	.BLKB	   10.		;
	.BYTE	  123.		;		+0
	.BYTE	  125.		;		-0
	.BYTE	  123.		;	 	+0
	.BYTE	  125.		;	 	-0
	.BYTE	  123.		;		+0
	.BYTE	  123.		;		+0
	.BLKB	   10.		;
	.BYTE	   65.		;		+1
	.BYTE	   74.		;		-1
	.BYTE	   65.		;	 	+1
	.BYTE	   74.		;	 	-1
	.BYTE	   65.		;		+1
	.BYTE	   65.		;		+1
	.BLKB	   10.		;
	.BYTE	   66.		;		+2
	.BYTE	   75.		;		-2
	.BYTE	   66.		;	 	+2
	.BYTE	   75.		;		-2
	.BYTE	   66.		;		+2
	.BYTE	   66.		;		+2
	.BLKB	   10.		;
	.BYTE	   67.		;		+3
	.BYTE	   76.		;		-3
	.BYTE	   67.		;		+3
	.BYTE	   76.		;		-3
	.BYTE	   67.		;		+3
	.BYTE	   67.		;		+3
	.BLKB	   10.		;
	.BYTE	   68.		;		+4
	.BYTE	   77.		;		-4
	.BYTE	   68.		;		+4
	.BYTE	   77.		;		-4
	.BYTE	   68.		;		+4
	.BYTE	   68.		;		+4
	.BLKB	   10.		;
	.BYTE	   69.		;		+5
	.BYTE	   78.		;		-5
	.BYTE	   69.		;		+5
	.BYTE	   78.		;		-5
	.BYTE	   69.		;		+5
	.BYTE	   69.		;		+5
	.BLKB	   10.		;
	.BYTE	   70.		;		+6
	.BYTE	   79.		;		-6
	.BYTE	   70.		;		+6
	.BYTE	   79.		;		-6
	.BYTE	   70.		;		+6
	.BYTE	   70.		;		+6
	.BLKB	   10.		;
	.BYTE	   71.		;		+7
	.BYTE	   80.		;		-7
	.BYTE	   71.		;		+7
	.BYTE	   80.		;		-7
	.BYTE	   71.		;		+7
	.BYTE	   71.		;		+7
	.BLKB	   10.		;
	.BYTE	   72.		;		+8
	.BYTE	   81.		;		-8
	.BYTE	   72.		;		+8
	.BYTE	   81.		;		-8
	.BYTE	   72.		;		+8
	.BYTE	   72.		;		+8
	.BLKB	   10.		;
	.BYTE	   73.		;		+9
	.BYTE	   82.		;		-9
	.BYTE	   73.		;		+9
	.BYTE	   82.		;		-9
	.BYTE	   73.		;		+9
	.BYTE	   73.		;		+9

.SBTTL	PACKED TO UNSIGNED DECIMAL TRANSLATION TABLE

C74$_P_UNSN_TBL::				;  edit 03

	.BLKB	   10.		;
	.BYTE	   48.		;		+0
	.BYTE	   48.		;		+0
	.BYTE	   48.		;	 	+0
	.BYTE	   48.		;	 	+0
	.BYTE	   48.		;		+0
	.BYTE	   48.		;		+0
	.BLKB	   10.		;
	.BYTE	   49.		;		+1
	.BYTE	   49.		;		+1
	.BYTE	   49.		;	 	+1
	.BYTE	   49.		;	 	+1
	.BYTE	   49.		;		+1
	.BYTE	   49.		;		+1
	.BLKB	   10.		;
	.BYTE	   50.		;		+2
	.BYTE	   50.		;		+2
	.BYTE	   50.		;	 	+2
	.BYTE	   50.		;		+2
	.BYTE	   50.		;		+2
	.BYTE	   50.		;		+2
	.BLKB	   10.		;
	.BYTE	   51.		;		+3
	.BYTE	   51.		;		+3
	.BYTE	   51.		;		+3
	.BYTE	   51.		;		+3
	.BYTE	   51.		;		+3
	.BYTE	   51.		;		+3
	.BLKB	   10.		;
	.BYTE	   52.		;		+4
	.BYTE	   52.		;		+4
	.BYTE	   52.		;		+4
	.BYTE	   52.		;		+4
	.BYTE	   52.		;		+4
	.BYTE	   52.		;		+4
	.BLKB	   10.		;
	.BYTE	   53.		;		+5
	.BYTE	   53.		;		+5
	.BYTE	   53.		;		+5
	.BYTE	   53.		;		+5
	.BYTE	   53.		;		+5
	.BYTE	   53.		;		+5
	.BLKB	   10.		;
	.BYTE	   54.		;		+6
	.BYTE	   54.		;		+6
	.BYTE	   54.		;		+6
	.BYTE	   54.		;		+6
	.BYTE	   54.		;		+6
	.BYTE	   54.		;		+6
	.BLKB	   10.		;
	.BYTE	   55.		;		+7
	.BYTE	   55.		;		+7
	.BYTE	   55.		;		+7
	.BYTE	   55.		;		+7
	.BYTE	   55.		;		+7
	.BYTE	   55.		;		+7
	.BLKB	   10.		;
	.BYTE	   56.		;		+8
	.BYTE	   56.		;		+8
	.BYTE	   56.		;		+8
	.BYTE	   56.		;		+8
	.BYTE	   56.		;		+8
	.BYTE	   56.		;		+8
	.BLKB	   10.		;
	.BYTE	   57.		;		+9
	.BYTE	   57.		;		+9
	.BYTE	   57.		;		+9
	.BYTE	   57.		;		+9
	.BYTE	   57.		;		+9
	.BYTE	   57.		;		+9

.SBTTL	OVERPUNCH <==> ZONED TRANSLATION TABLE

OVERPUNCH_Z_TBL:
Z_OVERPUNCH_TBL:

	.BLKB	 48

	.BYTE	123		;	+0	*ZONED TO OVERPUNCH
	.BYTE	 65		;	+1	*
	.BYTE	 66		;	+2	*
	.BYTE	 67		;	+3	*
	.BYTE	 68		;	+4	*
	.BYTE	 69		;	+5	*
	.BYTE	 70		;	+6	*
	.BYTE	 71		;	+7	*
	.BYTE	 72		;	+8	*
	.BYTE	 73		;	+9	*

	.BLKB	  7

	.BYTE	 49		;	+1	*OVERPUNCH TO ZONED
	.BYTE	 50		;	+2	*
	.BYTE	 51		;	+3	*
	.BYTE	 52		;	+4	*
	.BYTE	 53		;	+5	*
	.BYTE	 54		;	+6	*
	.BYTE	 55		;	+7	*
	.BYTE	 56		;	+8	*
	.BYTE	 57		;	+9	*
	.BYTE	113		;	-1	*
	.BYTE	114		;	-2	*
	.BYTE	115		;	-3	*
	.BYTE	116		;	-4	*
	.BYTE	117		;	-5	*
	.BYTE	118		;	-6	*
	.BYTE	119		;	-7	*
	.BYTE	120		;	-8	*
	.BYTE	121		;	-9	*

	.BLKB	 29

	.BYTE	125		;	-0	*ZONED TO OVERPUNCHED
	.BYTE	 74		;	-1	*
	.BYTE	 75		;	-2	*
	.BYTE	 76		;	-3	*
	.BYTE	 77		;	-4	*
	.BYTE	 78		;	-5	*
	.BYTE	 79		;	-6	*
	.BYTE	 80		;	-7	*
	.BYTE	 81		;	-8	*
	.BYTE	 82		;	-9	*
	.BYTE	  0
	.BYTE	 48		;	+0	*OVERPUNCH TO ZONE
	.BYTE	  0		;
	.BYTE	112		;	-0	*OVERPUNCH TO ZONE

;
; AUTHOR: BOB KUSHLIS, CREATION DATE: 28-APR-78
;
; MODIFIED BY:
;
; 01	Bob Kushlis, 28-Apr-1978
;	-	original version.
;
; 02	Wm P Storey, 26-Jan-1979
;	-	fix C74$ME4B to calculate (prior to scaling) the maximum number
;		of digits that can be accepted into destination.
;
;	Wm P Storey,  1-Mar-1979
; 03	-	make all global names of the form C74$xyzabc.
;
;	Wm P Storey,  5-Mar-1979
; 04	-	make module name of form C74$title.
;--

;
; INCLUDE FILES:
;


	.PSECT		DBG$GENB4,SHR,PIC,LONG,NOWRT

	.SBTTL	$MS4B - MOVE 4-WORD BINARY WITH SCALING
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE WILL MOVE ANY DATA TYPE TO ANY OTHER WITH
;	SCALING IF NECESSARY.  THE ONLY RESTRICTION IS THAT BOTH
;	THE SOURCE AND THE DESTINATION MUST FIT IN A 4-WORD BINARY
;	TEMP.
;	
;
; CALLING SEQUENCE:
;
;	NEXT_COMMAND
;	
;
; INPUT PARAMETERS:
;
;	R11 - PARAMETER POINTER
;	
;	SOURCE DDD ADDRESS
;	DESTINATION DDD ADDRESS
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	SOURCE MOVED TO DESTINATION
;
; CONDITION CODES:
;
;	UNDEFINED
;
; SIDE EFFECTS:
;
;	REGISTERS R0-R7 CLOBBERED
;
;--

C74$MS4B::		; MOVE SCALE AND CONVERT 4-WORD BINARY.

	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVAB		DBG$WA,R10		; POINT AT DATA AREA
	MOVAB		4(AP),R11		; SET UP R11 FOR THEM
	CLRB		WORK_OVF_FLAGS(R10)
	GET_DDD_ADDRESS	R7			; GET SOURCE DDD.
	MOVL		(R11),R0		; GET DEST.
	CVTWL		DDD_LENGTH(R0),R6	; GET DEST LENGTH.
	SUBB3		DDD_SCALE(R0),-		; GET SCALE DIF.
			DDD_SCALE(R7),R1
	CVTBL		R1,R1			; CONVERT TO LONG.
	SUBL2		R1,R6			; ADJUST DEST LENGTH.
	BLEQ		1$			; BR IF NO DIGITS TO CONVERT.
	BSBW		C74$CVT_ANY_Q_M		; CONVERT TO 4-WORD.
.IF  DF,DBG_UTL1
	PUSHL	R2
	PUSHL	R3
	PUSHAB DBG$UTL_STR2
	CALLS	#3,DBG$FAO_OUT
.ENDC
	MOVB		DDD_SCALE(R7),R0	; GET SOURCE SCALE.
	BRW		SCALE_STORE		; SCALE AND STORE.

1$:	CLRQ		R2			; MAKE IT ZERO.
	MOVB		DDD_SCALE(R7),R0	; USE SOURCE SCALE.
	BRW		SCALE_STORE

	.SBTTL	$MR4B - MOVE 4-WORD BINARY ROUNDED.
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE MOVES A 4-WORD BINARY SOURCE TO ANY DESTINATION
;	WITH ROUNDING.  THE SOURCE MUST HAVE AT LEAST 1 MORE DECIMAL
;	PLACE THAN THE DESTINATION.  ROUNDING IS ACCOMPISHED BY ADDING
;	10**N/2 TO THE SOURCE WHERE N = SCALE OF SOURCE - SCALE OF
;	DESTINATION.  THE SOURCE IS (OF COURSE) SCALED TO MATCH THE
;	DESTINATION AFTER THE ROUNDING AND BEFORE THE MOVE.
;
; CALLING SEQUENCE:
;
;	NEXT_COMMAND
;
; INPUT PARAMETERS:
;
;	R11 - PARAMETER POINTER
;	
;	SOURCE DDD ADDRESS
;	DESTINATION DDD ADDRESS
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	SOURCE MOVE TO DESTINATION WITH ROUNDING
;
; CONDITION CODES:
;
;	UNDEFINED
;
; SIDE EFFECTS:
;
;	REGISTERS R0-R7 CLOBBERED
;
;--

C74$MR4B::		; MOVE ROUNDED 4-WORD.

	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVAB		DBG$WA,R10		; POINT AT DATA AREA
	MOVAB		4(AP),R11		; SET UP R11 FOR THEM
	GET_DDD_ADDRESS	R7			; GET SOURCE DDD.
	MOVB		DDD_SCALE(R7),R4	; GET SOURCE SCALE.
	BSBW		C74$CVT_ANY_Q		; CONVERT SOURCE TO 4-WORD.
	GET_DDD_ADDRESS	R7			; GET DEST DDD.
	SUBB3		R4,DDD_SCALE(R7),R0	; GET SCALE DIFFERENCE IN R0.
	BLEQ		2$			; SKIP IF NOT GREATER.
	CVTBL		R0,R0			; EXTEND TO LONGWORD.
	TSTL		R3			; IS SOURCE + OR - ?
	BLSS		1$			; BR IF -
	ADDL2		$LONG_FIVES[R0],R2	; ADD FIVE IN THE CORRECT PLACE
	ADWC		$QUAD_FIVES[R0],R3	; ADD HIGH LONGWORD.
	BRB		2$
	ADWC		$QUAD_FIVES[R0],R3	; ADD UPPER PORTION.
1$:	SUBL2		$LONG_FIVES[R0],R2	; SUBTRACT FIVE INSTEAD.
	SBWC		$QUAD_FIVES[R0],R3	; AND THE NEXT LONGWORD.
2$:	MNEGL		R0,R0			; NEGATE THE SCALE.
	BSBW		C74$SCALE_Q
	BSBW		C74$CVT_Q_ANY		; CONVERT TO DESTINATION.
	EXIT_WITH_VAL

	.SBTTL	$AAG4 - GENERAL 4-WORD BINARY ADD
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE ADDS ANY 2 SOURCE OPERANDS AND STORES THE RESULT
;	IN THE DESTINATION.  THE ONLY RESTRICTION IS THAT THE COMPOSITE
;	OF THE TWO SOURCES AND THE RESULT MUST FIT IN A 4-WORD TEMP.
;
; CALLING SEQUENCE:
;
;	NEXT_COMMAND
;
; INPUT PARAMETERS:
;
;	R11 - PARAMETER POINTER
;	
;	ADDEND-1 DDD ADDRESS
;	ADDEND-2 DDD ADDRESS
;	SUM DDD ADDRESS
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	SUM COMPUTED AND STORED
;
; CONDITION CODES:
;
;	UNDEFINED
;
; SIDE EFFECTS:
;
;	REGISTERS R0-R7 CLOBBERED
;
;--

C74$AAG4::		; GENERAL 4-WORD ADD.

	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVAB		DBG$WA,R10		; POINT AT DATA AREA
	MOVAB		4(AP),R11		; SET UP R11 FOR THEM
	BSBB		GET$2_Q_OPS		; GET THE TWO OPERANDS.
	ADDL2		R4,R2			; ADD LOWER LONGWORDS.
	ADWC		R5,R3			; ADD UPPER LONGWORDS.
	BVS		OVFL			; CHECK FOR OVERFLOW.

SCALE_STORE:	; SCALE AND STORE 4-WORD TO ANY TYPE.

;
; THE 4-WORD BINARY ITEM IN R2,R3 IS SCALED IF NECESSARY AND STORED IN
; THE RESULT DATA ITEM WHOSE DDD IS POINTED TO BY R11.
;
	GET_DDD_ADDRESS	R7			; GET THE DEST. DDD.
	SUBB2		DDD_SCALE(R7),R0	; GET SCALE DIFFERENCE.
	BSBW		C74$SCALE_Q		; SCALE IT.
.IF   DF,DBG_UTL1
	PUSHL  R2
	PUSHL  R3
	PUSHAB  DBG$UTL_STR3
	CALLS  #3,DBG$FAO_OUT
.ENDC
	BSBW		C74$CVT_Q_ANY		; CONVERT AND MOVE TO DEST.
	EXIT_WITH_VAL

	.SBTTL	$ASG4 - GENERAL 4-WORD SUBTRACT
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SUBTRACTS THE FIRST OPERAND FROM THE SECOND
;	AND STORES THE RESULT IN THE THIRD.  THE OPERANDS MAY BE ANY
;	TYPE AND SCALE.  THE ONLY RESTRICTION IS THAT THE COMPOSITE
;	OF THE TWO SOURCES AND THE DESTINATION MUST FIT IN A 4-WORD
;	TEMP.
;
; CALLING SEQUENCE:
;
;	NEXT_COMMAND
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	DIFFERENCE COMPUTED AND STORED
;
; CONDITION CODES:
;
;	UNDEFINED
;
; SIDE EFFECTS:
;
;	REGITSTER R0-R7 CLOBBERED
;	OVERFLOW FLAGS SET IF OVERFLOW OCCURS
;
;--

C74$ASG4::	; GENERAL SUBTRACT 4-WORD.

	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVAB		DBG$WA,R10		; POINT AT DATA AREA
	MOVAB		4(AP),R11		; SET UP R11 FOR THEM
	BSBB		GET$2_Q_OPS		; GET THE TWO SOURCE OPERANDS.
	SUBL2		R4,R2			; SUBTRACT LOWER LONGWORDS.
	SBWC		R5,R3			; SUBTRACT UPPER LONGWORDS.
	BVC		SCALE_STORE		; IF NO OVERFLOW, STORE RESULT

;
; OVERFLOW OCCURRED.  SET THE OVERFLOW FLAGS BEFORE STORING THE RESULT.
;

OVFL:	SET_OVF_FLAGS				; SET OVERFLOW FLAGS.
	BRB		SCALE_STORE		; STORE THE RESULT.

	.SBTTL	GET$2_Q_OPS - GET TWO 4-WORD OPERANDS
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE PICKS UP TWO SOURCE OPERANDS WHOSE DDD
;	ADDRESSES ARE IN THE PARAMETER LIST, CONVERTS THEM TO
;	BINARY, AND SCALES THE ONE WITH LESS DECIMAL PLACES TO
;	MATCH THE OTHER.
;
; CALLING SEQUENCE:
;
;	JSB	GET$2_Q_OPS
;
; INPUT PARAMETERS:
;
;	R11 - PARAMETER LIST POINTER
;	
;	FIRST OPERAND DDD ADDRESS
;	SECOND OPERAND DDD ADDRESS
;	
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R4 - FIRST OPERAND
;	R2 - SECOND OPERAND
;	R0 - SCALE (BYTE)
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; CONDITION CODES:
;
;	UNDEFINED
;
; SIDE EFFECTS:
;
;	R11 BUMPED PAST OPERAND DDD ADDRESSES
;	R0-R7 CLOBBERED
;
;--

GET$2_Q_OPS::

	GET_DDD_ADDRESS	R7			; GET OPERAND 1 DDD POINTER.
	MOVB		DDD_SCALE(R7),-(SP)	; GET OPERAND 1 SCALE.
	BSBW		C74$CVT_ANY_Q		; CONVERT TO 4-WORD BINARY.
	MOVQ		R2,R4			; PLACE FIRST OPERAND IN R4.
	GET_DDD_ADDRESS	R7			; GET OPERAND 2 DDD POINTER.
	MOVB		DDD_SCALE(R7),-(SP)	; GET SECOND OPERAND SCALE.
	BSBW		C74$CVT_ANY_Q		; CONVERT TO 4-WORD BINARY.
	SUBB3		1(SP),(SP),R0		; COMPARE THE SCALES.
	BGTR		SCALE_2
	BEQL		1$			; SKIP IF NO SCALING REQUIRED.
;
; SCALE FIRST OPERAND.
;
	MNEGB		R0,R0			; NEGATE SCALE DIFFERENCE.
	MOVQ		R2,-(SP)		; SAVE SECOND OPERAND.
	MOVQ		R4,R2			; GET FIRST OPERAND.
	BSBW		C74$SCALE_Q		; DO THE SCALE.
	MOVQ		R2,R4			; REPLACE SCALED FIRST OPERAND
	MOVQ		(SP)+,R2		; REPLACE SECOND OPERAND
1$:	CVTBL		(SP)+,R0		; GET THE SCALE.
	INCL		SP			; GET RID OF OTHER SCALE.
	RSB

SCALE_2:	; SCALE SECOND OPERAND.

	BSBW		C74$SCALE_Q		; DO THE SCALE.
	INCL		SP			; GET RID OF OTHER SCALE.
	CVTBL		(SP)+,R0		; GET SCALE OF OPERANDS.
	RSB

;	.SBTTL	$CB4XX - GENERAL 4-WORD COMPARES
;++
; FUNCTIONAL DESCRIPTION:
;
;	THESE ROUTINES COMPARE TWO OPERANDS AND CONDITIONALLY BRANCH
;	ON THE RESULT.  THE ONLY RESTRICTION ON THE OPERANDS IS THAT
;	THEIR COMPOSITE MUST FIT IN A 4-WORD TEMP.
;
; CALLING SEQUENCE:
;
;	NEXT_COMMAND
;
; INPUT PARAMETERS:
;
;	R11 - PARAMETER LIST POINTER
;	
;	FIRST OPERAND DDD ADDRESS
;	SECOND OPERAND DDD ADDRESS
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; CONDITION CODES:
;
;	UNDEFINED
;
; SIDE EFFECTS:
;
;	R0-R7 CLOBBERED
;
;--

; THIS MACRO IS USED TO GENERATE THE GENERAL 4-WORD COMPARES.

;.MACRO	CG4		BC			; BC IS THE CONDITION.
;	START_COMMAND				; ENTER OTS ROUTINE.
;	BSBW		GET$2_Q_OPS		; GET THE OPERANDS.
;	BRW		CB4'BC'$		; AND BRANCH TO FAST COMPARE.
;.ENDM


;C74$CG4LT::	; COMPARE GENERAL 4-WORD LESS.

;	CG4		LT

;C74$CG4LE::	; COMPARE GENERAL 4-WORD LESS OR EQUAL.

;	CG4		LE

;C74$CG4EQ::	; COMPARE GENERAL 4-WORD EQUAL.

;	CG4		EQ

;C74$CG4GE::	; COMPARE GENERAL 4-WORD GREATER OR EQUAL.

;	CG4		GE

;C74$CG4GT::	; COMPARE GENERAL 4-WORD GREATER.

;	CG4		GT

;C74$CG4NE::	; COMPARE GENERAL 4-WORD NOT EQUAL.

;	CG4		NE

	.SBTTL	$MC4B - MOVE AND CONVERT 4-WORD BINARY
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE MOVES A SOURCE TO A DESTINATION WITH THE SAME
;	FACTOR.  BOTH OPERAND MAY BE ANY TYPE BUT MUST FIT IN A 2-WORD
;	BINARY TEMP.
;
; CALLING SEQUENCE:
;
;	NEXT_COMMAND
;
; INPUT PARAMETERS:
;
;	R11 - PARAMETER LIST POINTER
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	SOURCE MOVED TO DESTINATION.
;
; CONDITION CODES:
;
;	UNDEFINED
;
; SIDE EFFECTS:
;
;	R0-R7 CLOBBERED
;
;--

C74$MC4B::		; MOVE AND CONVERT 4-WORD BINARY.

	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVAB		DBG$WA,R10		; POINT AT DATA AREA
	MOVAB		4(AP),R11		; SET UP R11 FOR THEM
	GET_DDD_ADDRESS	R7			; GET SOURCE.
	MOVL		(R11),R0		; GET DEST DDD.
	CVTWL		DDD_LENGTH(R0),R6	; GET DEST LENGTH.
	BSBW		C74$CVT_ANY_Q_M		; CONVERT TO 4-WORD.

GET_STORE:	; GET DESTINATION DDD AND STORE RESULT.

	GET_DDD_ADDRESS	R7			; GET DESTINATION

STORE:		; STORE A 4-WORD RESULT TO ANY DESTINATION.

	BSBW		C74$CVT_Q_ANY		; CONVERT TO DEST TYPE.
	EXIT_WITH_VAL

	.SBTTL	$MN4B - MOVE NEGATED 4-WORD BINARY.
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE MOVES THE NEGATIVE OF THE SOURCE OPERAND TO
;	THE DESTINATION.  THE SOURCE AND DESTINATION MUST HAVE THE
;	SAME SCALE FACTOR AND MUST FIT IN A 4-WORD BINARY TEMP.
;
; CALLING SEQUENCE:
;
;	NEXT_COMMAND
;
; INPUT PARAMETERS:
;
;	R11 - PARAMETER LIST POINTER
;	
;	SOURCE DDD POINTER
;	DEST DDD POINTER
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NEGATED SOURCE MOVED TO DESTINATION.
;
; CONDITION CODES:
;
;	UNDEFINED
;
; SIDE EFFECTS:
;
;	R0-R7 CLOBBERED
;
;--

C74$MN4B::		; MOVE NEGATED 4-WORD.

	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVAB		DBG$WA,R10		; POINT AT DATA AREA
	MOVAB		4(AP),R11		; SET UP R11 FOR THEM
	GET_DDD_ADDRESS	R7
	BSBW		C74$CVT_ANY_Q
	MNEGL		R2,R2			; NEGATE LOWER LONGWORD.
	ADWC		#0,R3			; CARRY.
	MNEGL		R3,R3			; NEGATE UPPER LONGWORD.
	BRB		GET_STORE		; GET DEST DDD AND STORE.

;	.SBTTL	$AMG4 - GENERAL 4-WORD MULTIPLY
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE MULTIPLIES TWO OPERANDS AND STORES THE RESULT
;	IN A THIRD.  EACH OF THE OPERANDS MUST FIT IN A 2-WORD BINARY
;	TEMP (THOUGH THE COMPOSITE NEED NOT).
;
; CALLING SEQUENCE:
;
;	NEXT_COMMAND
;
; INPUT PARAMETERS:
;
;	R11 - PARAMETER LIST POINTER
;	
;	MULTIPLIER DDD ADDRESS
;	MULTIPLICAND DDD ADDRESS
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	PRODUCT COMPUTED AND MOVED TO DESTINATION.
;
; CONDITION CODES:
;
;	UNDEFINED
;
; SIDE EFFECTS:
;
;	R0-R7 CLOBBERED
;	OVERFLOW FLAGS SET IF OVERFLOW OCCURS
;
;--

;C74$AMG4::		; 4-WORD GENERAL MULTIPLY.

;	.WORD	^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
;	MOVAB  4(AP),R11
;	GET_DDD_ADDRESS	R7			; GET FIRST OPERAND DDD.
;	BSBW		C74$CVT_ANY_Q		; CONVERT TO QUADWORD.
;	MOVQ		R2,R4			; SAVE IN R4,R5.
;	MOVB		DDD_SCALE(R7),-(SP)	; GET SCALE OF FIRST OPERAND.
;	GET_DDD_ADDRESS	R7			; GET SECOND OPERAND DDD.
;	BSBW		C74$CVT_ANY_Q		; CONVERT TO QUAD.
;	ADDB2		DDD_SCALE(R7),(SP)	; ADD THE SCALE.
;	MOVQ		R2,R0			; MOVE OPERAND TO R0.
;	MOVQ		R4,R6			; MOVE FIRST OPERAND TO R6
;	BSBW		C74$MUL_4_BY_4		; DO THE MULTIPLY.
;	GET_DDD_ADDRESS	R7			; GET RESULT DDD.
;	SUBB3		DDD_SCALE(R7),(SP)+,R0	; GET SCALE.
;	BSBW		C74$SCALE_8		; SCALE THE 8-WORD RESULT.
;
; CHECK FOR OVERFLOW.  UPPER QUADWORD MUST BE SIGN EXTENSION OF LOWER.
;
;	ASHL		#-31,R3,R1		; SIGN EXTEND LOW QUADWORD.
;	CMPL		R1,R4			; COMPARE TO THIRD LONGWORD.
;	BNEQ		OVFL1			; OVERFLOW IF NOT EQUAL.
;	CMPL		R1,R5			; COMPARE TO LAST LONGWORD.
;	BEQL		STORE			; IF EQUAL THEN STORE RESULT.
;
; RESULT OVERFLOWED, SET OVERFLOW FLAGS.
;

;OVFL1:		; OVERFLOW FOR MULTIPLY/DIVIDE.

;	SET_OVF_FLAGS				; SET OVERFLOW FLAGS.
;	BRB		STORE

	.SBTTL	DBG$WA_INIT - Init the work area for use by this module
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine will init the pointer fields in the descriptors
;	in the work area DBG$WA
;
; CALLING SEQUENCE:
;
;	CALLS	#0,DBG$WA_INIT
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	none
;
; CONDITION CODES:
;
;	UNDEFINED
;
; SIDE EFFECTS:
;
;
;--


DBG$WA_INIT::
	.word	0		; SAVE NO REGISTERS
	MOVAB	DBG$WA,R0	; GET BASE OF WORK AREA
	MOVAB	WORK_DDD_1(R0),R1
	ADDL3	R0,DDD_ADDRESS(R1),DDD_ADDRESS(R1)
	MOVAB	WORK_DDD_2(R0),R1
	ADDL3	R0,DDD_ADDRESS(R1),DDD_ADDRESS(R1)
	MOVAB	WORK_DDD_3(R0),R1
	ADDL3	R0,DDD_ADDRESS(R1),DDD_ADDRESS(R1)
	MOVAB	WORK_DDD_4(R0),R1
	ADDL3	R0,DDD_ADDRESS(R1),DDD_ADDRESS(R1)
	MOVAB	WORK_DDD_5(R0),R1
	ADDL3	R0,DDD_ADDRESS(R1),DDD_ADDRESS(R1)
	MOVAB	WORK_DDD_6(R0),R1
	ADDL3	R0,DDD_ADDRESS(R1),DDD_ADDRESS(R1)
	MOVAB	WORK_DDD_7(R0),R1
	ADDL3	R0,DDD_ADDRESS(R1),DDD_ADDRESS(R1)
	CLRL	R0
	RET

	.SBTTL	DBG$CVT_DG_H - convert d or g floating to h floating
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine will convert d floating or g floating to h floating.
;
; CALLING SEQUENCE:
;	
;	
;
; INPUT PARAMETERS:
;
;	4 (AP)	-  ADDRESS OF SOURCE NUMBER
;	8 (AP)	-  ADDRESS OF DESTINATION
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	none
;
; CONDITION CODES:
;
;	UNDEFINED
;
; SIDE EFFECTS:
;
;
;--

;
;  convert d or g floating to h floating

dbg$cvt_d_h ::
	.word	^M<r2,r3,r4,r5,r6,r7,r8,r9>
	movab	w^cvt_d_h,r8
	brb	common

dbg$cvt_g_h ::
	.word	^M<r2,r3,r4,r5,r6,r7,r8,r9>
	movab	w^cvt_g_h,r8
	brb	common


common:

	movl	4(ap),r6			; source address
	movab	-16(sp),sp
	movl	sp,r2
	clrq	(r2)
	clrq	8(r2)
	rotl	#16,(r6)+,r1
	rotl	#16,(r6)+,r0
	extzv	#31,#1,r0,r9			; get sign
	jsb	(r8)
;
; huge number is now in huge_temp

	movl	8(ap),r7
	rotl	#16,12(r2),(r7)+
	rotl	#16,8(r2),(r7)+
	rotl	#16,4(r2),(r7)+
	rotl	#16,(r2),(r7)
	clrl	r0
	ret


sign_h:						; put sign in number
	insv	r9,#15,#1,14(r2)
	rsb

cvt_d_h:					; convert d to h
	extzv	#23,#8,r1,r7			; get exponent
	beql	sign_h				; if zero just put sign in
	ashq	#9,r0,r0			; destroy old exponent
	addw2	#<16384-128>,r7
	movw	r7,14(r2)
	movq	r0,6(r2)
	brb	sign_h

cvt_g_h:					; convert g to h
	extzv	#20,#11,r1,r7
	beql	sign_h
	ashq	#12,r0,r0
	addw2	#<16384-1024>,r7
	movw	r7,14(r2)
	movq	r0,6(r2)
	brb	sign_h



;	.SBTTL	$ADG4 - GENERAL 4-WORD DIVIDE
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE DIVIDES THE FIRST OPERAND INTO THE SECOND
;	STORING THE RESULT IN THE THIRD.  THE ONLY RESTRICTION IS
;	THAT EACH OPERAND MUST FIT IN A 4-WORD TEMP.
;
; CALLING SEQUENCE:
;
;	NEXT_COMMAND
;
; INPUT PARAMETERS:
;
;	R11 - PARAMETER LIST POINTER
;	
;	DIVISOR DDD ADDRESS
;	DIVIDEND DDD ADDRESS
;	QUOTIENT DDD ADDRESS
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	QUOTIENT COMPUTED AND STORED
;
; CONDITION CODES:
;
;	UNDEFINED
;
; SIDE EFFECTS:
;
;	R0-R7 CLOBBERED
;	OVERFLOW FLAGS SET IF OVERFLOW OCCURS
;
;--

;C74$ADG4::		; 4-WORD GENERAL DIVIDE.

;	.WORD	^M<R0,R1,R2,R3,R4,R5,R6,R7,R11>
;	MOVAB  4(AP),R11
;	GET_DDD_ADDRESS	R7			; GET DIVISOR DDD.
;	BSBW		C74$CVT_ANY_Q		; GET 4-WORD DIVISOR.
;	MOVQ		R2,-(SP)		; SAVE ON STACK.
;	MOVB		DDD_SCALE(R7),-(SP)	; GET DIVISOR SCALE.
;	GET_DDD_ADDRESS	R7			; GET DIVIDEND DDD.
;	BSBW		C74$CVT_ANY_Q		; GET 4-WORD DIVIDEND.
;	ASHQ		#-63,R2,R4		; SIGN EXTEND TO 8-WORD.
;1$:	SUBB3		(SP)+,DDD_SCALE(R7),R0	; GET RESULT SCALE.
;	MOVL		(R11),R7		; GET THE RESULT DDD.
;	SUBB2		DDD_SCALE(R7),R0	; GET SCALE DIFFERENCE.
;	BSBW		C74$SCALE_8		; SCALE THE 8-WORD DIVIDEND.
;	MOVQ		(SP)+,R6		; GET THE DIVISOR BACK.
;	BSBW		C74$DIV_8_BY_4		; DO THE DIVIDE.
;	GET_DDD_ADDRESS	R7
;	BRW		STORE			; STORE THE RESULT.

	.SBTTL	$ME4B - MOVE 4-WORD WITH SIZE ERROR CHECK
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE CONDITIONALLY MOVES THE SOURCE TO THE DESTINATION
;	BASED ON WHETHER OR NOT A SIZE ERROR HAS OCCURRED.  THE SOURCE
;	IS A TWO WORD BINARY OF THE SAME SCALE AS THE DESTINATION, WHICH
;	MAY BE ANY TYPE WHICH WILL FIT IN A 4-WORD BINARY TEMP.  IF THE
;	LOCAL OVERFLOW FLAG IS ON, (INDICATING ARITHMETIC OVERFLOW) OR
;	THE SOURCE IS LARGER THAN THE PICTURE OF THE DESTINATION WILL ALLOW
;	THE MOVE IS NOT PERFORMED AND THE GLOBAL SIZE ERROR FLAG IS TURNED
;	ON.  IN EITHER CASE, THE LOCAL SIZE ERROR FLAG IS LEFT OFF AFTER
;	THIS ROUTINE.
;
; CALLING SEQUENCE:
;
;	NEXT_COMMAND
;
; INPUT PARAMETERS:
;
;	R11 - PARAMETER LIST POINTER
;	
;	SOURCE DDD ADDRESS
;	DESTINATION DDD ADDRESS
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	SOURCE (PERHAPS) MOVED TO DESTINATION
;
; CONDITION CODES:
;
;	UNDEFINED
;	
;
; SIDE EFFECTS:
;
;	R0-R7 CLOBBERED
;	GLOBAL SIZE ERROR FLAG SET IF SOURCE WILL NOT FIT IN DEST
;	LOCAL SIZE ERROR FLAG CLEARED
;
;--

C74$ME4B::	; 4-WORD MOVE WITH SIZE ERROR CHECK.

	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVAB		DBG$WA,R10		; POINT AT DATA AREA
	MOVAB		4(AP),R11		; SET UP R11 FOR THEM
	CLRB		WORK_OVF_FLAGS(R10)
	GET_DDD_ADDRESS	R7			; GET SOURCE DDD.
	MOVB		DDD_SCALE(R7),R5	; GET SCALE FACTOR.
	BSBW		C74$CVT_ANY_Q		; CONVERT TO QUAD.
	GET_DDD_ADDRESS	R7			; GET DEST DDD.
	TEST_LOCAL_OVF				; TEST OVERFLOW FLAGS.
	BNEQ		3$			; BR IF OVERFLOW OCCURED.
;
; THERE WAS NO OVERFLOW ON THE OPERATION, BUT WE STILL MUST CHECK TO
; SEE IF THE RESULT FITS IN THE DESTINATION.
;
; The maximum number of digits the destination can accept is
; 
;	(destination length) + (destination scale) - (source scale).
;
;
	CVTWL		(R7),R4			; GET DIGIT LENGTH.
	ADDB2	DDD_SCALE(R7),R4	; Add scale of destination.
	SUBB2	R5,R4			; Subtract scale of source.
	MOVQ		R2,R0			; GET COPY OF SOURCE.
	BGEQ		4$			; AND ABS VALUE IT.
	MNEGL		R0,R0			; NEG LOW WORD.
	ADWC		#0,R1			; ADD CARRY.
	MNEGL		R1,R1			; NEG HIGH WORD.
4$:	CMPL		R1,$QUAD_TENS[R4]	; COMPARE TO 10**LENGTH.
	BLSS		1$			; IF LESS STORE RESULT.
	BGTR		2$			; OVERFLOW, DO NOT STORE.
	CMPL		R0,$LONG_TENS[R4]	; EQUAL, CHECK LOWER WORDS.
	BGEQU		2$			; OVERFLOW IF GREATER OR EQUAL
1$:						;
	SUBB3		DDD_SCALE(R7),R5,R0	; GET SCALE DIFFERENCE.
	BSBW		C74$SCALE_Q		; SCALE THE SOURCE.
	BRW		STORE			; NO SIZE ERROR, STORE IT.
2$:	SET_OVF_FLAGS				; OVERFLOW, SET THE FLAGS.
3$:	CLEAR_LOCAL_OVF				; CLEAR THE LOCAL FLAG.
	EXIT_WITH_VAL


; FUNCTIONAL DESCRIPTION:
;
;	THIS MODULE CONTAINS SCALING ROUTINES FOR BINARY ITEMS.  THE
;	FUNCTION OF THE SCALING ROUTINES IS TO MULTIPLY A BINARY ITEM
;	BY A POWER OF TEN (WHICH MAY BE NEGATIVE).  SCALING ROUTINES ARE
;	PROVIDED FOR 2-WORD, 4-WORD AND 8-WORD ITEMS.
;
; ENVIRONMENT: COBOL-11 VAX ENVIRONMENT 
;
; AUTHOR: BOB KUSHLIS, CREATION DATE: 26-MAY-1978
;
; MODIFIED BY:
;
;	Wm P Storey, 27-Jan-1979
; 02	-	change PSECT name from C74$ to C74$_ for shareable image.
;		note that SCALE has no UNIVERSAL symbols.
;
;	Wm P Storey,  1-Mar-1979
; 03	-	make all global names of the form C74$xyzabc.
;
;	Wm P Storey,  5-Mar-1979
; 04	-	make module name of form C74$title.
;
;	Ann W Harrison, 25-jun-79
; 05	-	put an RSB at the end of NEGATE_8
;
;--

;
; DECLARATIONS.
;

	.PSECT		DBG$_SCALE,PIC,SHR,NOWRT

C74$SCALE_L::	; SCALE A 2-WORD BINARY OPERAND.

	CVTBL		R0,R0			; CONVERT BYTE SCALE TO LONG.
	BLSS		NEG_SCALE_L		; CHECK FOR NEGATIVE.
	CMPL		R0,#9			; CHECK FOR <= 9.
	BLEQ		2$			; IF SO, WE ONLY DO 1 MULTIPLY
;
; THIS LOOP SCALES BY 10**9 UNTIL THE SCALE BECOMES NINE OR LESS.
;

1$:	MULL2		TEN_TO_THE_9,R2		; MULTIPLY BY 10**9.
	ACBL		#10,#-9,R0,1$		; SUBTRACT 9 AND CONTINUE.

2$:	MULL2		$LONG_TENS[R0],R2	; DO THE LAST MULTIPLY.
DONE:	RSB

NEG_SCALE_L:	; SCALE A 2-WORD BINARY OPERAND BY A NEGATIVE POWER.
	
	MNEGL		R0,R0			; GET ABS VALUE OF SCALE.
	CMPL		R0,#9			; COMPARE TO NINE.
	BLEQ		2$			; IF IT IS, JUST DO 1 DIVIDE.

;
; DIVIDE BYE 10**9 AND SUBTRACT NINE FROM SCALE UNTIL IT BECOMES NINE OR LESS.
;

1$:	DIVL2		TEN_TO_THE_9,R2		; MULTIPLY BY 10**9.
	ACBL		#10,#-9,R0,1$		; SUBTRACT NINE AND BRANCH.

2$:	DIVL2		$LONG_TENS[R0],R2		; DO THE LAST DIVIDE.
	RSB

$LONG_TENS::	; LOWER LONGWORD OF POWERS OF TEN FROM 0 TO 18.

	.LONG		1		; 0
	.LONG		10		; 1
	.LONG		100		; 2
	.LONG		1000		; 3
	.LONG		10000		; 4
	.LONG		100000		; 5
	.LONG		1000000		; 6
	.LONG		10000000	; 7
	.LONG		100000000	; 8
TEN_TO_THE_9:
	.LONG		1000000000	; 9
	.LONG		1410065408	; 10
	.LONG		1215752192	; 11
	.LONG		3567587328	; 12
	.LONG		1316134912	; 13
	.LONG		0276447232	; 14
	.LONG		2764472320	; 15
	.LONG		1874919424	; 16
	.LONG		1569325056	; 17
	.LONG		2808348672	; 18

$QUAD_TENS::	; UPPER LONGWORD OF THE POWER OF TENS TABLE.

	.LONG		0		; 0
	.LONG		0		; 1
	.LONG		0		; 2
	.LONG		0		; 3
	.LONG		0		; 4
	.LONG		0		; 5
	.LONG		0		; 6
	.LONG		0		; 7
	.LONG		0		; 8
	.LONG		0		; 9
	.LONG		2		; 10
	.LONG		23		; 11
	.LONG		232		; 12
	.LONG		2328		; 13
	.LONG		23283		; 14
	.LONG		232830		; 15
	.LONG		2328306		; 16
	.LONG		23283064	; 17
	.LONG		232830643	; 18

C74$SCALE_Q::	; SCALE 4-WORD.

	CVTBL		R0,R0
	BLSS		NEG_SCALE_Q
	CMPL		R0,#9
	BLEQ		3$

1$:	MULL3		TEN_TO_THE_9,R3,R1
	EMUL		TEN_TO_THE_9,R2,#0,R2
	BGEQ		2$
	ADDL2		TEN_TO_THE_9,R3
2$:	ADDL2		R1,R3
	ACBL		#10,#-9,R0,1$

3$:	MULL3		$LONG_TENS[R0],R3,R1
	EMUL		$LONG_TENS[R0],R2,#0,R2
	BGEQ		4$
	ADDL2		$LONG_TENS[R0],R3
4$:	ADDL2		R1,R3
	RSB

NEG_SCALE_Q:	; SCALE 4-WORD.

	MNEGL		R0,R0
	TSTL		R3			; IS IT NEGATIVE.
	BGEQ		4$
	MNEGL		R2,R2			; YES, NEGATE THE OPERAND.
	ADWC		#0,R3
	MNEGL		R3,R3
	BSBB		4$			; CALL THE SCALE ROUTINE.
	MNEGL		R2,R2			; AND RE-NEGATE.
	ADWC		#0,R3
	MNEGL		R3,R3
	RSB

4$:	PUSHL		R4
	CMPL		R0,#9
	BLEQ		2$
	
1$:	MOVL		TEN_TO_THE_9,R1
	BSBB		DIV_2_BY_1
	ACBL		#10,#-9,R0,1$

2$:	MOVL		$LONG_TENS[R0],R1
	BSBB		DIV_2_BY_1
	MOVL		(SP)+,R4
	RSB

DIV_2_BY_1:	; DIVIDE TWO LONGWORDS (R2,R3) BY R1.

	ASHL		#-31,R3,R4
	EDIV		R1,R3,R8,R3
	EDIV		R1,R2,R2,R4
	BVC		1$
	ASHQ		#1,R2,R2
	SUBL2		R1,R3
	ASHQ		#-1,R2,R2
	EDIV		R1,R2,R2,R3
	INSV		#1,#31,#1,R2
1$:	MOVL		R8,R3
	RSB

C74$SCALE_8::	; SCALE 8-WORD.

	CVTBL		R0,R0
	BEQL		4$
	BLSS		NEG_SCALE_8
	MOVQ		R6,-(SP)
	CMPL		R0,#9
	BLEQ		3$

1$:	MOVL		TEN_TO_THE_9,R1
	BSBB		MUL_4_BY_1
	ACBL		#10,#-9,R0,1$

3$:	MOVL		$LONG_TENS[R0],R1
	BSBB		MUL_4_BY_1
	MOVQ		(SP)+,R6
4$:	RSB

MUL_4_BY_1:

	EMUL		R1,R2,#0,R6
	BGEQ		1$
	ADDL2		R1,R7
1$:	MOVL		R6,R2
	EMUL		R1,R3,R7,R6
	BGEQ		2$
	ADDL2		R1,R7
2$:	MOVL		R6,R3
	EMUL		R1,R4,R7,R6
	BGEQ		3$
	ADDL2		R1,R7
3$:	MOVL		R6,R4
	EMUL		R1,R5,R7,R5
	RSB

NEG_SCALE_8:	; SCALE 8-WORD.

	MNEGL		R0,R0
	TSTL		R5			; IS IT NEGATIVE.
	BGEQ		4$
	BSBB		NEGATE_8
	BSBB		4$			; CALL THE SCALE ROUTINE.
	BSBB		NEGATE_8		; AND RE-NEGATE.
	RSB

4$:	MOVQ		R6,-(SP)
	CMPL		R0,#9
	BLEQ		2$
	
1$:	MOVL		TEN_TO_THE_9,R1
	CLRL		R7
	BSBB		ONE_DIVIDE
	BSBB		ONE_DIVIDE
	BSBB		ONE_DIVIDE
	BSBB		ONE_DIVIDE
	ACBL		#10,#-9,R0,1$

2$:	MOVL		$LONG_TENS[R0],R1
	CLRL		R7			; CLEAR UPPER LONGWORD.
	BSBB		ONE_DIVIDE
	BSBB		ONE_DIVIDE
	BSBB		ONE_DIVIDE
	BSBB		ONE_DIVIDE
	MOVQ		(SP)+,R6
	RSB

NEGATE_8:	; NEGATE 8-WORD QUANTITY.

	MCOML		R2,R2
	MCOML		R3,R3
	MCOML		R4,R4
	MCOML		R5,R5
	INCL		R2
	ADWC		#0,R3
	ADWC		#0,R4
	ADWC		#0,R5
	RSB

ONE_DIVIDE:	; DIVIDES R1 INTO R7-R5, SHIFTING R2-R5 UPWARDS.

	MOVQ		R4,R5
	MOVQ		R2,R3
	EDIV		R1,R6,R2,R8
	BVC		1$
	ASHQ		#1,R6,R6
	SUBL2		R1,R7
	ASHQ		#-1,R6,R6
	EDIV		R1,R6,R2,R8
	INSV		#1,#31,#1,R2
1$:	MOVL		R8,R7
	RSB

$LONG_FIVES::	; LOWER LONGWORD OF POWERS 0F 10 OVER 2.

	.LONG		0		; 0
	.LONG		5		; 1
	.LONG		50		; 2
	.LONG		500		; 3
	.LONG		5000		; 4
	.LONG		50000		; 5
	.LONG		500000		; 6
	.LONG		5000000		; 7
	.LONG		50000000	; 8
	.LONG		500000000	; 9
	.LONG		705032704	; 10
	.LONG		2755359744	; 11
	.LONG		1783793664	; 12
	.LONG		0658067456	; 13
	.LONG		2285707264	; 14
	.LONG		1382236160	; 15
	.LONG		0937459712	; 16
	.LONG		0784662528	; 17
	.LONG		3551657984	; 18

$QUAD_FIVES::	; UPPER LONGWORD OF POWERS OF TEN OVER 2 TABLE.

	.LONG		0		; 0
	.LONG		0		; 1
	.LONG		0		; 2
	.LONG		0		; 3
	.LONG		0		; 4
	.LONG		0		; 5
	.LONG		0		; 6
	.LONG		0		; 7
	.LONG		0		; 8
	.LONG		0		; 9
	.LONG		1		; 10
	.LONG		11		; 11
	.LONG		116		; 12
	.LONG		1164		; 13
	.LONG		11641		; 14
	.LONG		116415		; 15
	.LONG		1164153		; 16
	.LONG		11641532	; 17
	.LONG		116415321	; 18

;	.TITLE	C74$WORKAR - VAX-11 Cobol-74 work area.
;	.IDENT	/1A.06/			; 006 edit
;
;
; COPYRIGHT (C) 1978, 1979
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS 01754
;
; THIS SOFTWARE IS FURNISHED  UNDER A LICENSE FOR USE ONLY ON A SINGLE
; COMPUTER  SYSTEM AND  MAY BE  COPIED ONLY WITH  THE INCLUSION OF THE
; ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE, OR ANY OTHER COPIES THEREOF,
; MAY NOT BE PROVIDED OR  OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON
; EXCEPT FOR USE ON SUCH SYSTEM AND TO ONE WHO AGREES TO THESE LECENSE
; TERMS.  TITLE TO AND  OWNERSHIP OF THE  SOFTWARE  SHALL AT ALL TIMES
; REMAIN IN DEC.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT NOTICE
; AND SHOULD  NOT BE CONSTRUED   AS A COMMITMENT  BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DEC ASSUMES  NO  RESPONSIBILITY  FOR  THE USE OR  RELIABILITY OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DEC.
;

;++
; FACILITY: COBOL-11/VAX OTS.
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS MODULE DEFINES AND INITIALIZED A WORK AREA FOR THE COBOL
;	OTS.
;
; ENVIRONMENT: VAX-11 COBOL-74 OTS ENVIRONMENT
;
; AUTHOR: BOB KUSHLIS, CREATION DATE: 26-MAY-1978
;
; MODIFIED BY:
;	Wm P Storey,	24-July-1978.
; 001	- 	STRING, UNSTRING, SEARCH specific variables.
;
;	Wm P Storey,	21-Sept-1978.
; 002	-	ISAM specific variables.
;
;	Wm P Storey,	15-Dec-1978.
; 003	-	ACCEPT/DISPLAY share common RAB (formerly WORK_ACC_RAB);
;		former WORK_DIS_RAB becomes ISI block with some leftover;
;		WORK_ACC_IFI/DIS_IFI removed to become spares.
;
;	Wm P Storey, 	 1-Feb-1979
; 04	-	add WORK$W_DIS_VFC (*7) to handle DISPLAY verb PRN format;
;		space needed taken from former WORK_DIS_RAB block.
;
;	Wm P Storey,	6-Feb-1979
; 05	-	change PSECT attributes to PIC so that WORKAR and LIB$DATA
;		fall in same image section.  Note that WORKAR contains the
;		UNIVERSAL symbol C74$WA, which is the base address of the
;		work area.  As a side affect, this means that the patch space
;		is sandwiched between UNIVERSAL symbols.
;
;	Wm P Storey,  5-Mar-1979
; 06	-	make module name of form C74$title.
;
;--


; INITIALIZE A WORK AREA TO CONTAIN THE TEMP DDD'S.
;	.LIBRARY	/[COB11VAX]COBOTS/
;	$COBOTSDEF
	.PSECT		DBG$_WORK,NOEXE,PIC			; edit 05

DBG$WA::	; COBOL WORK AREA

.=DBG$WA+WORK_DDD_1	
			.LONG	0,TEMP1-DBG$WA,0
.=DBG$WA+WORK_TEMP_1	
TEMP1:			.BLKW	10.
.=DBG$WA+WORK_DDD_2	
			.LONG	0,TEMP2-DBG$WA,0
.=DBG$WA+WORK_TEMP_2	
TEMP2:			.BLKW	10.
.=DBG$WA+WORK_DDD_3	
			.LONG	0,TEMP3-DBG$WA,0
.=DBG$WA+WORK_TEMP_3	
TEMP3:			.BLKW	10.
.=DBG$WA+WORK_DDD_4	
			.LONG	0,TEMP4-DBG$WA,0
.=DBG$WA+WORK_TEMP_4
TEMP4:			.BLKW	10.
.=DBG$WA+WORK_DDD_5
			.LONG	0,TEMP5-DBG$WA,0
.=DBG$WA+WORK_TEMP_5
TEMP5:			.BLKW	10.
.=DBG$WA+WORK_DDD_6
			.LONG	0,TEMP6-DBG$WA,0
.=DBG$WA+WORK_TEMP_6
TEMP6:			.BLKW	10.
.=DBG$WA+WORK_DDD_7
			.LONG	0,TEMP7-DBG$WA,0
.=DBG$WA+WORK_TEMP_7
TEMP7:			.BLKW	10.

.=DBG$WA+WORK_FAB
WORK_FAB_DEF:		$FAB
.=DBG$WA+WORK_ACCDIS_RAB
			$RAB	FAB=WORK_FAB_DEF,-
				ROP=<RAH,WBH>
.=DBG$WA+WORK$W_ACC_ISI
			.BLKB	<7*2>		; Space for seven word ISI's.
.=DBG$WA+WORK$W_DIS_VFC
			.BLKB	<7*2>		; Space for seven word VFC's.
			.BLKB	<^X44-<7*2>-<7*2>> ; Continue to hold space former RAB.
			.WORD	0		; Formerly WORK_ACC_IFI, now spare.
			.WORD	0		; Formerly WORK_DIS_IFI, now spare.
.=DBG$WA+WORK_SWITCH
			.LONG	0
.=DBG$WA+WORK_OVF_FLAGS
			.BYTE	0
.=DBG$WA+WORK_FIRST_TIME
			.BYTE	0
.=DBG$WA+WORK$A_IXD			; 001 edit
			.LONG	0	; 001 edit
 
.=DBG$WA+WORK$L_P			; 001 edit
			.LONG	0	; 001 edit
 
.=DBG$WA+WORK$L_SBM			; 001 edit
			.LONG	0	; 001 edit
 
.=DBG$WA+WORK$L_TST			; 001 edit
			.LONG	0	; 001 edit
 
.=DBG$WA+WORK$L_UB			; 001 edit
			.LONG	0	; 001 edit
 
.=DBG$WA+WORK$A_FLS			; 001 edit
			.LONG	0	; 001 edit
 
.=DBG$WA+WORK$A_TRU			; 001 edit
			.LONG	0	; 001 edit
.=DBG$WA+WORK$L_SPS			; 001 edit
			.LONG	0	; 001 edit
 
.=DBG$WA+WORK$L_TA1			; 001 edit
			.LONG	0	; 001 edit
.=DBG$WA+WORK$DDD_ID1			; 001 edit
			.LONG	0,0,0,0	; 001 edit
 
.=DBG$WA+WORK$A_ID4			; 001 edit
			.LONG	0
 
.=DBG$WA+WORK$A_ID5			; 001 edit
			.LONG	0	; 001 edit
 
.=DBG$WA+WORK$A_ID6			; 001 edit
			.LONG	0	; 001 edit
 
.=DBG$WA+WORK$A_ID11			; 001 edit
			.LONG	0	; 001 edit
 
.=DBG$WA+WORK$A_ID7			; 001 edit
			.LONG	0	; 001 edit
 
.=DBG$WA+WORK$A_ID8			; 001 edit
			.LONG	0	; 001 edit
 
.=DBG$WA+WORK$DDD_STR			; 001 edit
			.LONG	0,0,0	; 001 edit
 
 
.=DBG$WA+WORK_IO_IOF
			.LONG	0

.=DBG$WA+WORK_IO_EXS
			.LONG	0
 
.=DBG$WA+WORK_IO_KBF			; edit 002
			.LONG	0	; edit 002
.=DBG$WA+WORK_IO_KNB			; edit 002
			.LONG	0	; edit 002
.=DBG$WA+WORK_IO_KRF			; edit 002
			.LONG	0	; edit 002
.=DBG$WA+WORK_IO_KSZ			; edit 002
			.LONG	0	; edit 002
 
	.END
