	.TITLE	PASSEMART
	.IDENT	'V03-000'
;
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;
;++
;
; FACILITY:	VAX-11 PASCAL-SPECIFIC DEBUGGER MODULES
;
; ABSTRACT:
;
;	This module handles the arithmetic (floating) for the Expression Interpreter
;
; ENVIRONMENT:	VAX/VMS user mode
;
; AUTHOR: R. Gottlieb, CREATION DATE: 13-March-1980
;
; MODIFIED BY:	P. Hohensee	17-July-1980	Stolen from PASCAL-PLUS
;
;--

;
; These are predefined values (See PASLIB.R32)
;
$SSDEF
$SFDEF
$CHFDEF
$MTHDEF

	.PSECT	DBG$CODE, PIC, RD, NOWRT, EXE, SHR, BYTE

;+
; Declarations of Pascal V2.0 RTL routines
;-

.GLOBAL	OTS$POWLULU				; Unsigned Exponentiation

;+
; External routines
;-

.GLOBAL	PAS$_Read_Access			; Check read access

;+
; Declarations for the Expression Stack
;-

.GLOBAL	PAS$_Expr_Stack				; Expression Stack
.GLOBAL	PAS$_Expr_Depth				; Expression Depth

Expr_S_Entry	= 28				; Size of an Expression Block Entry

Expr_Stack_Depth= 128				; Maximum Stack Depth

Expr_Type		= 0			; Pointer to Type Entry for Source
Expr_Byte_Address	= 4			; Byte Address of Value
Expr_Bit_Offset		= 8			; Bit Offset from Byte Address
Expr_Value		= 12			; Value to Use

;+
; Data Types
;-

BU_int		= 1				; Byte Integer Unsigned
B_int		= 2				; Byte Integer
WU_int		= 3				; Word Integer Unsigned
W_int		= 4				; Word Integer
LU_int		= 5				; Long Integer Unsigned
L_int		= 6				; Long Integer
QU_int		= 7				; Quadword Unsigned
Q_int		= 8				; Quadword
OU_int		= 9				; Octaword Unsigned
O_int		= 10				; Octaword

F_float		= 11				; Float F
D_float		= 12				; Float D
G_float		= 13				; Float G
H_float		= 14				; Float H

U_bool		= 15				; Uncommitted Boolean
B_bool		= 16				; Byte Boolean
W_bool		= 17				; Word Boolean
L_bool		= 18				; Long Boolean


;+
; Error Codes
;-

DBG$_DEBUGBUG	= ^X00028322 + <  6*8>
DBG$_NOTDONE	= ^X00028190 + < 88*8>
DBG$_INVEXPR	= 165840     + < 10*8>
DBG$_DIVBYZERO	= ^X00028190 + < 94*8>
DBG$_INTOVER	= 165840     + < 25*8>
DBG$_FLTOVER	= 165840     + < 26*8>
DBG$_FLTUNDER	= 165840     + < 35*8>
DBG$_UNDEXP	= 165840     + < 36*8>
DBG$_ROPRAND	= 165840     + < 37*8>
DBG$_UNDMOD	= ^X00028CD8
DBG$_NOACCESSR	= ^X000282B8
DBG$_NILDEREF  	= ^X00028CB8

.SBTTL	Fetches

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine fetches a value, including arbitrary unaligned values
;
; FORMAL PARAMETERS:
;
;	+4	- Data Type
;	+8	- Address of quadword Source Address Descriptor. First longword
;		  is byte address, second longword is bit offset from byte address
;	+12	- Result Address
;	+16	- Source size in bits
;
; IMPLICIT INPUTS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; ROUTINE VALUE or STATUS CODE
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;--

	.ENTRY	PAS$_Arith_FETCH, ^M<>

; Check for odd sizes and unaligned data

	MOVQ	@8(AP),R0			; Get source address

; Check read access

	TSTL	R0				; Zero (nil) address ?
	BNEQ	1$				; Branch if not
	PUSHL	#DBG$_NILDEREF
	CALLS	#1,LIB$SIGNAL			; Signal error
1$:	ASHL	#-3,16(AP),-(SP)		; Get number of bytes to check
	TSTL	R1				; Excess bits ?
	BEQL	2$				; Branch if not
	INCL	(SP)
2$:	PROBER	#0,(SP),(R0)			; Check read access
	BNEQ	3$
	PUSHL	R0
	PUSHL	#DBG$_NOACCESSR
	CALLS	#2,LIB$SIGNAL			; Signal the error

3$:	CASEB	4(AP),#BU_Int,#L_Bool-BU_Int

4$:	.WORD	5$ - 4$				; Byte BU_int
	.WORD	6$ - 4$				; Byte B_int
	.WORD	5$ - 4$				; Word WU_int
	.WORD	6$ - 4$				; Word W_int
	.WORD	5$ - 4$				; Long LU_int
	.WORD	6$ - 4$				; Long L_int
	.WORD	9$ - 4$				; Quad QU_int
	.WORD	9$ - 4$				; Quad Q_int
	.WORD	9$ - 4$				; Octa OU_int
	.WORD	9$ - 4$				; Octa O_int3
	.WORD	5$ - 4$				; Long F_Float
	.WORD	9$ - 4$				; Quad D_Float
	.WORD	9$ - 4$				; Quad G_Float
	.WORD	9$ - 4$				; Octa H_Float

	.WORD	5$ - 4$				; Long U_bool
	.WORD	5$ - 4$				; Byte B_bool
	.WORD	5$ - 4$				; Word W_bool
	.WORD	5$ - 4$				; Long L_bool

5$:	EXTZV	R1,16(AP),(R0),(SP)		; Zero-Extend
	BRB	7$

6$:	EXTV	R1,16(AP),(R0),(SP)		; Sign_Extend

7$:	PUSHL	12(AP)				; Result Address
	PUSHAB	4(SP)				; Source Address
	BRB	10$

; Aligned and otherwise normal

9$:	PUSHL	12(AP)				; Result Address
	PUSHL	@8(AP)				; Source Address

10$:	PUSHL	4(AP)				; Data Type
	CALLS	#3,PAS$_Arith_MOVE
	MOVL	#1,R0				; Always successfull
	RET

.SBTTL	Moves

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine moves a value of one data type to another location
;
; FORMAL PARAMETERS:
;
;	+4	- Data Type
;	+8	- Source Address
;	+12	- Result Address
;
; IMPLICIT INPUTS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; ROUTINE VALUE or STATUS CODE
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;--

	.ENTRY	PAS$_Arith_MOVE, ^M<>

	MOVQ	8(AP),R0			; Get the Addresses for the Source/Destination
	CASEW	4(AP),#BU_int,#L_bool-BU_int

1$:	.WORD	2$ - 1$				; Byte BU_int
	.WORD	2$ - 1$				; Byte B_int
	.WORD	3$ - 1$				; Word WU_int
	.WORD	3$ - 1$				; Word W_int
	.WORD	4$ - 1$				; Long LU_int
	.WORD	4$ - 1$				; Long L_int
	.WORD	5$ - 1$				; Quad QU_int
	.WORD	5$ - 1$				; Quad Q_int
	.WORD	6$ - 1$				; Octa OU_int
	.WORD	6$ - 1$				; Octa O_int

	.WORD	4$ - 1$				; Long F_Float
	.WORD	5$ - 1$				; Quad D_Float
	.WORD	5$ - 1$				; Quad G_Float
	.WORD	6$ - 1$				; Octa H_Float

	.WORD	4$ - 1$				; Long U_bool
	.WORD	2$ - 1$				; Byte B_bool
	.WORD	3$ - 1$				; Word W_bool
	.WORD	4$ - 1$				; Long L_bool

2$:	MOVB	(R0),(R1)			; Byte Copy
	RET

3$:	MOVW	(R0),(R1)			; Word Copy
	RET

4$:	MOVL	(R0),(R1)			; Long Copy
	RET

5$:	MOVQ	(R0),(R1)			; Quad Copy
	RET

6$:	MOVQ	(R0)+,(R1)+			; Octa Copy
	MOVQ	(R0),(R1)
	RET

.SBTTL	Conversions

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine converts a value of one data type to another
;	data type
;
; FORMAL PARAMETERS:
;
;	+4	- Source DType
;	+8	- Source Address
;	+12	- Result DType
;	+16	- Result Address
;
; IMPLICIT INPUTS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; ROUTINE VALUE or STATUS CODE
;
;	Returns SS$_SUCCESS if no problems, or:
;
;	    DBG$_FLTOVER   if Floating Overflow
;	    DBG$_INTOVER   if Integer Overflow
;	    DBG$_NOTDONE   if conversion isn't Implemented
;
; SIDE EFFECTS:
;
;	NONE
;--

	.ENTRY	PAS$_Arith_CONVERT, ^M<R2,R3>

	MOVAB	W^PAS$_Arith_Error_Handler,(FP)	; Establish Error Handler
	MOVL	#1,R0				; Return Code of STS$K_SUCCESS
	MOVL	8(AP),R2			; Pointer to Source
	MOVL	16(AP),R3			; Pointer to Destination

	CASEB	4(AP),#BU_int,#U_bool-BU_int

1$:	.WORD	$_BU_int  - 1$			; BU_int
	.WORD	$_B_int   - 1$			; B_int
	.WORD	$_WU_int  - 1$			; WU_int
	.WORD	$_W_int   - 1$			; W_int
	.WORD	$_LU_int  - 1$			; LU_int
	.WORD	$_L_int   - 1$			; L_int
	.WORD	Quadword_Move - 1$		; QU_int
	.WORD	Quadword_Move - 1$		; Q_int
	.WORD	Octaword_Move - 1$		; OU_int
	.WORD	Octaword_Move - 1$		; O_int

	.WORD	$_F_float - 1$			; F_float
	.WORD	$_D_float - 1$			; D_float
	.WORD	$_G_float - 1$			; G_float
	.WORD	$_H_float - 1$			; H_float

	.WORD	$_U_bool  - 1$			; U_bool

Not_Implemented:
	MOVL	#DBG$_NOTDONE,R0		; Error, should not happen
	RET

Convert_Int_Overflow:
	MOVL	#DBG$_INTOVER,R0		; Error (Overflow)
	RET

Convert_Flt_Overflow:
	MOVL	#DBG$_FLTOVER,R0		; Error (Overflow)
	RET

;
; U_bool
;
$_U_bool:
	BRB	$_BU_Int			; The only things that can be U_Bools
						; the literals True and False
;	CMPB	12(AP),#U_bool			; Should be U_bool
;	BNEQ	Not_Implemented			; Nope, error
;	BBC	#0,(R2),2$			; Check low bit

;1$:	BBSS	#0,(R3),3$			; Set Low Bit
;	BRB	3$				; go

;2$:	BBCC	#0,(R3),3$			; Clear Low Bit

;3$:	RET					; Return

;
; Quadword Move
;
Quadword_Move:
	CMPL	4(AP),12(AP)			; DType must match
	BNEQ	Not_Implemented			; doesn't
	MOVQ	(R2),(R3)			; do the move
	RET

;
; Octaword Move
;
Octaword_Move:
	CMPL	4(AP),12(AP)			; DType must match
	BNEQ	Not_Implemented			; doesn't
	MOVQ	(R2)+,(R3)+			; Do first  move
	MOVQ	(R2),(R3)			; Do second move
	RET

;
; BU_int (rarely occurs)
;
$_BU_int:
	CASEB	12(AP),#BU_int,#O_int-BU_int	; B_int

1$:	.WORD	$_B_int.B_int   - 1$		; BU_int -> BU_int
	.WORD	$_B_int.BU_int  - 1$		; BU_int -> B_int
	.WORD	$_BU_int.WU_int - 1$		; BU_int -> WU_int
	.WORD	$_BU_int.WU_int - 1$		; BU_int -> W_int
	.WORD	$_BU_int.LU_int - 1$		; BU_int -> LU_int
	.WORD	$_BU_int.LU_int - 1$		; BU_int -> L_int
	.WORD	Not_Implemented - 1$		; BU_int -> QU_int
	.WORD	Not_Implemented - 1$		; BU_int -> Q_int
	.WORD	Not_Implemented - 1$		; BU_int -> OU_int
	.WORD	Not_Implemented - 1$		; BU_int -> O_int

$_BU_int.WU_int:
	MOVZBW	(R2),(R3)			; Simple Convert
	RET

$_BU_int.LU_int:
	MOVZBL	(R2),(R3)			; Simple Convert
	RET


;
; B_int (rarely occurs)
;
$_B_int:
	CASEB	12(AP),#BU_int,#H_float-BU_int	; B_int

1$:	.WORD	$_B_int.BU_int  - 1$		; B_int -> BU_int
	.WORD	$_B_int.B_int   - 1$		; B_int -> B_int
	.WORD	$_B_int.WU_int  - 1$		; B_int -> WU_int
	.WORD	$_B_int.W_int   - 1$		; B_int -> W_int
	.WORD	$_B_int.LU_int  - 1$		; B_int -> LU_int
	.WORD	$_B_int.L_int   - 1$		; B_int -> L_int
	.WORD	Not_Implemented - 1$		; B_int -> QU_int
	.WORD	Not_Implemented - 1$		; B_int -> Q_int
	.WORD	Not_Implemented - 1$		; B_int -> OU_int
	.WORD	Not_Implemented - 1$		; B_int -> O_int

	.WORD	$_B_int.F_float - 1$		; B_int -> F_float
	.WORD	$_B_int.D_float - 1$		; B_int -> D_float
	.WORD	$_B_int.G_float - 1$		; B_int -> G_float
	.WORD	$_B_int.H_float - 1$		; B_int -> H_float

$_B_int.BU_int:
$_B_int.B_int:
	MOVB	(R2),(R3)			; Simple Move
	RET

$_B_int.WU_int:
$_B_int.W_int:
	CVTBW	(R2),(R3)			; Simple Convert
	RET

$_B_int.LU_int:
$_B_int.L_int:
	CVTBL	(R2),(R3)			; Simple Convert
	RET

$_B_int.F_float:
	CVTBF	(R2),(R3)			; Simple Convert
	RET

$_B_int.D_float:
	CVTBD	(R2),(R3)			; Simple Convert
	RET

$_B_int.G_float:
	CVTBG	(R2),(R3)			; Simple Convert
	RET

$_B_int.H_float:
	CVTBH	(R2),(R3)			; Simple Convert
	RET


;
; WU_int (rarely occurs)
;
$_WU_int:
	CASEB	12(AP),#BU_int,#O_int-BU_int	; WU_int

1$:	.WORD	$_WU_int.BU_int - 1$		; WU_int -> BU_int
	.WORD	$_WU_int.B_int  - 1$		; WU_int -> B_int
	.WORD	$_W_int.W_int   - 1$		; WU_int -> WU_int
	.WORD	$_W_int.WU_int  - 1$		; WU_int -> W_int
	.WORD	$_WU_int.L_int  - 1$		; WU_int -> LU_int
	.WORD	$_WU_int.L_int  - 1$		; WU_int -> L_int
	.WORD	Not_Implemented - 1$		; WU_int -> QU_int
	.WORD	Not_Implemented - 1$		; WU_int -> Q_int
	.WORD	Not_Implemented - 1$		; WU_int -> OU_int
	.WORD	Not_Implemented - 1$		; WU_int -> O_int

$_WU_int.BU_int:
	MOVW	(R2),R2				; Simple Copy
	MOVB	R2,(R3)				; Store it
	CMPZV	#8,#8,R2,#0			; Check high Byte
	BNEQ	1$				; Overflow
	RET

1$:	BRW	Convert_Int_Overflow

$_WU_int.B_int:
	MOVW	(R2),R2				; Simple Copy
	MOVB	R2,(R3)				; Store it
	CMPZV	#7,#9,R2,#0			; Check high Byte
	BNEQ	1$				; Overflow
	RET

1$:	BRW	Convert_Int_Overflow

$_WU_int.L_int:
	MOVZWL	(R2),(R3)			; Simple Convert
	RET


;
; W_int (rarely occurs)
;
$_W_int:
	CASEB	12(AP),#BU_int,#H_float-BU_int	; W_int

1$:	.WORD	$_W_int.BU_int  - 1$		; W_int -> BU_int
	.WORD	$_W_int.B_int   - 1$		; W_int -> B_int
	.WORD	$_W_Int.WU_int  - 1$		; W_int -> WU_int
	.WORD	$_W_int.W_int   - 1$		; W_int -> W_int
	.WORD	$_W_int.LU_int  - 1$		; W_int -> LU_int
	.WORD	$_W_int.L_int   - 1$		; W_int -> L_int
	.WORD	Not_Implemented - 1$		; W_int -> QU_int
	.WORD	Not_Implemented - 1$		; W_int -> Q_int
	.WORD	Not_Implemented - 1$		; W_int -> OU_int
	.WORD	Not_Implemented - 1$		; W_int -> O_int

	.WORD	$_W_int.F_float - 1$		; W_int -> F_float
	.WORD	$_W_int.D_float - 1$		; W_int -> D_float
	.WORD	$_W_int.G_float - 1$		; W_int -> G_float
	.WORD	$_W_int.H_float - 1$		; W_int -> H_float

$_W_int.BU_int:
	MOVW	(R2),-(SP)			; Simple Copy
	MOVB	(SP)+,(R3)			; Copy the Low Byte
	TSTB	(SP)+				; High Byte should be clear
	BNEQ	1$				; Nope, Overflow
	RET

1$:	BRW	Convert_Int_Overflow

$_W_int.B_int:
	CVTWB	(R2),(R3)			; Simple Convert
	BVC	1$				; No Overflow
	BRW	Convert_Int_Overflow

1$:	RET

$_W_int.WU_int:
$_W_int.W_int:
	MOVW	(R2),(R3)			; Simple Move
	RET

$_W_int.LU_int:
$_W_int.L_int:
	CVTWL	(R2),(R3)			; Simple Convert
	RET

$_W_int.F_float:
	CVTWF	(R2),(R3)			; Simple Convert
	RET

$_W_int.D_float:
	CVTWD	(R2),(R3)			; Simple Convert
	RET

$_W_int.G_float:
	CVTWG	(R2),(R3)			; Simple Convert
	RET

$_W_int.H_float:
	CVTWH	(R2),(R3)			; Simple Convert
	RET


;
; LU_int
;
$_LU_int:
	CASEB	12(AP),#BU_int,#O_int-BU_int	; LU_int

1$:	.WORD	$_LU_int.BU_int - 1$		; LU_int -> BU_int
	.WORD	$_LU_int.B_int  - 1$		; LU_int -> B_int
	.WORD	$_LU_int.WU_int - 1$		; LU_int -> WU_int
	.WORD	$_LU_int.W_int  - 1$		; LU_int -> W_int
	.WORD	$_L_int.L_int   - 1$		; LU_int -> LU_int
	.WORD	$_L_int.LU_int  - 1$		; LU_int -> L_int
	.WORD	Not_Implemented - 1$		; LU_int -> QU_int
	.WORD	Not_Implemented - 1$		; LU_int -> Q_int
	.WORD	Not_Implemented - 1$		; LU_int -> OU_int
	.WORD	Not_Implemented - 1$		; LU_int -> O_int

$_LU_int.BU_int:
	MOVL	(R2),R2				; Simple Copy
	MOVB	R2,(R3)				; Store the Low Byte
	CMPZV	#8,#24,R2,#0			; High Bits Should be 0
	BNEQ	1$
	RET

1$:	BRW	Convert_Int_Overflow

$_LU_int.B_int:
	MOVL	(R2),R2				; Simple Copy
	MOVB	R2,(R3)				; Store the Low Byte
	CMPZV	#7,#25,R2,#0			; High Bits Should be 0
	BNEQ	1$
	RET

1$:	BRW	Convert_Int_Overflow

$_LU_int.WU_int:
	MOVL	(R2),R2				; Simple Copy
	MOVW	R2,(R3)				; Store the Low Word
	CMPZV	#16,#16,R2,#0			; Check the High Word
	BNEQ	1$				; Nothing happens here
	RET

1$:	BRW	Convert_Int_Overflow

$_LU_int.W_int:
	MOVL	(R2),R2				; Simple Copy
	MOVW	R2,(R3)				; Store the Low Word
	CMPZV	#15,#17,R2,#0			; Check the High Word
	BNEQ	1$				; Nothing happens here
	RET

1$:	BRW	Convert_Int_Overflow


;
; L_int
;
$_L_int:
	CASEB	12(AP),#BU_int,#H_float-BU_int	; L_int

1$:	.WORD	$_L_int.BU_int  - 1$		; L_int -> BU_int
	.WORD	$_L_int.B_int   - 1$		; L_int -> B_int
	.WORD	$_L_int.WU_int  - 1$		; L_int -> WU_int
	.WORD	$_L_int.W_int   - 1$		; L_int -> W_int
	.WORD	$_L_int.LU_int  - 1$		; L_int -> LU_int
	.WORD	$_L_int.L_int   - 1$		; L_int -> L_int
	.WORD	Not_Implemented - 1$		; L_int -> QU_int
	.WORD	Not_Implemented - 1$		; L_int -> Q_int
	.WORD	Not_Implemented - 1$		; L_int -> OU_int
	.WORD	Not_Implemented - 1$		; L_int -> O_int

	.WORD	$_L_int.F_float - 1$		; L_int -> F_float
	.WORD	$_L_int.D_float - 1$		; L_int -> D_float
	.WORD	$_L_int.G_float - 1$		; L_int -> G_float
	.WORD	$_L_int.H_float - 1$		; L_int -> H_float

$_L_int.BU_int:
	MOVL	(R2),R2				; Simple Copy
	MOVB	R2,(R3)				; Store the Low Byte
	CMPZV	#8,#24,R2,#0			; High Bits Should be 0
	BNEQ	1$
	RET

1$:	BRW	Convert_Int_Overflow

$_L_int.B_int:
	CVTLB	(R2),(R3)			; Simple Convert
	BVC	1$
	BRW	Convert_Int_Overflow

1$:	RET

$_L_int.WU_int:
	MOVL	(R2),R2				; Simple Copy
	MOVW	R2,(R3)				; Store the Low Word
	CMPZV	#16,#16,R2,#0			; Check the High Word
	BNEQ	1$				; Nothing happens here
	RET

1$:	BRW	Convert_Int_Overflow

$_L_int.W_int:
	CVTLW	(R2),(R3)			; Simple Convert
	BVC	1$
	BRW	Convert_Int_Overflow

1$:	RET

$_L_int.LU_int:
$_L_int.L_int:
	MOVL	(R2),(R3)			; Simple Move
	RET

$_L_int.F_float:
	CVTLF	(R2),(R3)			; Simple Convert
	RET

$_L_int.D_float:
	CVTLD	(R2),(R3)			; Simple Convert
	RET

$_L_int.G_float:
	CVTLG	(R2),(R3)			; Simple Convert
	RET

$_L_int.H_float:
	CVTLH	(R2),(R3)			; Simple Convert
	RET


;
; F_float
;
$_F_float:
	CASEB	12(AP),#BU_int,#H_float-BU_int	; F_float

1$:	.WORD	Not_Implemented - 1$		; F_float -> BU_int
	.WORD	$_F_float.B_int - 1$		; F_float -> B_int
	.WORD	Not_Implemented - 1$		; F_float -> WU_int
	.WORD	$_F_float.W_int - 1$		; F_float -> W_int
	.WORD	Not_Implemented - 1$		; F_float -> LU_int
	.WORD	$_F_float.L_int - 1$		; F_float -> L_int
	.WORD	Not_Implemented - 1$		; F_float -> QU_int
	.WORD	Not_Implemented - 1$		; F_float -> Q_int
	.WORD	Not_Implemented - 1$		; F_float -> OU_int
	.WORD	Not_Implemented - 1$		; F_float -> O_int

	.WORD	$_F_float.F_float - 1$		; F_float -> F_float
	.WORD	$_F_float.D_float - 1$		; F_float -> D_float
	.WORD	$_F_float.G_float - 1$		; F_float -> G_float
	.WORD	$_F_float.H_float - 1$		; F_float -> H_float

$_F_float.B_int:
	CVTFB	(R2),(R3)			; Simple Convert
	BVC	1$
	BRW	Convert_Int_Overflow

1$:	RET

$_F_float.W_int:
	CVTFW	(R2),(R3)			; Simple Convert
	BVC	1$
	BRW	Convert_Int_Overflow

1$:	RET

$_F_float.L_int:
	CVTFL	(R2),(R3)			; Simple Convert
	BVC	1$
	BRW	Convert_Int_Overflow

1$:	RET

$_F_float.F_float:
	MOVL	(R2),(R3)			; Simple Move
	RET

$_F_float.D_float:
	CVTFD	(R2),(R3)			; Simple Convert
	RET

$_F_float.G_float:
	CVTFG	(R2),(R3)			; Simple Convert
	RET

$_F_float.H_float:
	CVTFH	(R2),(R3)			; Simple Convert
	RET


;
; D_float
;
$_D_float:
	CASEB	12(AP),#BU_int,#H_float-BU_int	; D_float

1$:	.WORD	Not_Implemented - 1$		; D_float -> BU_int
	.WORD	$_D_float.B_int - 1$		; D_float -> B_int
	.WORD	Not_Implemented - 1$		; D_float -> WU_int
	.WORD	$_D_float.W_int - 1$		; D_float -> W_int
	.WORD	Not_Implemented - 1$		; D_float -> LU_int
	.WORD	$_D_float.L_int - 1$		; D_float -> L_int
	.WORD	Not_Implemented - 1$		; D_float -> QU_int
	.WORD	Not_Implemented - 1$		; D_float -> Q_int
	.WORD	Not_Implemented - 1$		; D_float -> OU_int
	.WORD	Not_Implemented - 1$		; D_float -> O_int

	.WORD	$_D_float.F_float - 1$		; D_float -> F_float
	.WORD	$_D_float.D_float - 1$		; D_float -> D_float
	.WORD	Not_Implemented   - 1$		; D_float -> G_float
	.WORD	$_D_float.H_float - 1$		; D_float -> H_float

$_D_float.B_int:
	CVTDB	(R2),(R3)			; Simple Convert
	BVC	1$
	BRW	Convert_Int_Overflow

1$:	RET

$_D_float.W_int:
	CVTDW	(R2),(R3)			; Simple Convert
	BVC	1$
	BRW	Convert_Int_Overflow

1$:	RET

$_D_float.L_int:
	CVTDL	(R2),(R3)			; Simple Convert
	BVC	1$
	BRW	Convert_Int_Overflow

1$:	RET

$_D_float.F_float:
	CVTDF	(R2),(R3)			; Simple Convert
	BVC	1$
	BRW	Convert_Flt_Overflow

1$:	RET

$_D_float.D_float:
	MOVQ	(R2),(R3)			; Simple Move
	RET

$_D_float.H_float:
	CVTDH	(R2),(R3)			; Simple Convert
	RET


;
; G_float
;
$_G_float:
	CASEB	12(AP),#BU_int,#H_float-BU_int	; G_float

1$:	.WORD	Not_Implemented - 1$		; G_float -> BU_int
	.WORD	$_G_float.B_int - 1$		; G_float -> B_int
	.WORD	Not_Implemented - 1$		; G_float -> WU_int
	.WORD	$_G_float.W_int - 1$		; G_float -> W_int
	.WORD	Not_Implemented - 1$		; G_float -> LU_int
	.WORD	$_G_float.L_int - 1$		; G_float -> L_int
	.WORD	Not_Implemented - 1$		; G_float -> QU_int
	.WORD	Not_Implemented - 1$		; G_float -> Q_int
	.WORD	Not_Implemented - 1$		; G_float -> OU_int
	.WORD	Not_Implemented - 1$		; G_float -> O_int

	.WORD	$_G_float.F_float - 1$		; G_float -> F_float
	.WORD	Not_Implemented   - 1$		; G_float -> D_float
	.WORD	$_G_float.G_float - 1$		; G_float -> G_float
	.WORD	$_G_float.H_float - 1$		; G_float -> H_float

$_G_float.B_int:
	CVTGB	(R2),(R3)			; Simple Convert
	BVC	1$
	BRW	Convert_Int_Overflow

1$:	RET

$_G_float.W_int:
	CVTGW	(R2),(R3)			; Simple Convert
	BVC	1$
	BRW	Convert_Int_Overflow

1$:	RET

$_G_float.L_int:
	CVTGL	(R2),(R3)			; Simple Convert
	BVC	1$
	BRW	Convert_Int_Overflow

1$:	RET

$_G_float.F_float:
	CVTGF	(R2),(R3)			; Simple Convert
	BVC	1$
	BRW	Convert_Flt_Overflow

1$:	RET

$_G_float.G_float:
	MOVQ	(R2),(R3)			; Simple Move
	RET

$_G_float.H_float:
	CVTGH	(R2),(R3)			; Simple Convert
	RET


;
; H_float
;
$_H_float:
	CASEB	12(AP),#B_int,#H_float-B_int	; H_float

1$:	.WORD	Not_Implemented - 1$		; H_float -> BU_int
	.WORD	$_H_float.B_int - 1$		; H_float -> B_int
	.WORD	Not_Implemented - 1$		; H_float -> WU_int
	.WORD	$_H_float.W_int - 1$		; H_float -> W_int
	.WORD	Not_Implemented - 1$		; H_float -> LU_int
	.WORD	$_H_float.L_int - 1$		; H_float -> L_int
	.WORD	Not_Implemented - 1$		; H_float -> QU_int
	.WORD	Not_Implemented - 1$		; H_float -> Q_int
	.WORD	Not_Implemented - 1$		; H_float -> OU_int
	.WORD	Not_Implemented - 1$		; H_float -> O_int

	.WORD	$_H_float.F_float - 1$		; H_float -> F_float
	.WORD	$_H_float.F_float- 1$		; H_float -> D_float
	.WORD	$_H_float.G_float - 1$		; H_float -> G_float
	.WORD	$_H_float.H_float - 1$		; H_float -> H_float

$_H_float.B_int:
	CVTHB	(R2),(R3)			; Simple Convert
	BVC	1$
	BRW	Convert_Int_Overflow

1$:	RET

$_H_float.W_int:
	CVTHW	(R2),(R3)			; Simple Convert
	BVC	1$
	BRW	Convert_Int_Overflow

1$:	RET

$_H_float.L_int:
	CVTHL	(R2),(R3)			; Simple Convert
	BVC	1$
	BRW	Convert_Int_Overflow

1$:	RET

$_H_float.F_float:
	CVTHF	(R2),(R3)			; Simple Convert
	BVC	1$
	BRW	Convert_Flt_Overflow

1$:	RET

$_H_float.D_float:
	CVTHD	(R2),(R3)			; Simple Convert
	BVC	1$
	BRW	Convert_Flt_Overflow

1$:	RET

$_H_float.G_float:
	CVTHG	(R2),(R3)			; Simple Convert
	BVC	1$
	BRW	Convert_Flt_Overflow

1$:	RET

$_H_float.H_float:
	MOVQ	(R2)+,(R3)+			; Copy first  Half
	MOVQ	(R2)+,(R3)+			; Copy second Half
	RET


.SBTTL	Logical Operations

;++
; FUNCTIONAL SPECIFICATION:
;
;	These routines are used to perform Logical operations.
;
; FORMAL PARAMETERS:
;
;	+4		- Data Type
;	+8		- Result Argument
;	+12		- Left   Argument
;	+16		- Right  Argument
;
; IMPLICIT INPUTS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;--

	.ENTRY	PAS$_Arith_LOR, ^M<>

	CMPL	4(AP),#U_bool			; Must be U_bool
	BNEQ	1$				; isn't, error

	BISL3	@16(AP),@12(AP),R0		; OR
	EXTZV	#0,#1,R0,@8(AP)			; Store the Result
	MOVL	#1,R0				; Return Code
	RET

1$:	MOVL	#DBG$_INVEXPR,R0		; Error in Type
	RET



	.ENTRY	PAS$_Arith_LAND, ^M<>

	CMPL	4(AP),#U_bool			; Must be U_bool
	BNEQ	2$				; isn't, error

	CLRL	R0				; Assume False
	BLBC	@16(AP),1$			; Left  Arg False
	BLBC	@12(AP),1$			; Right Arg False
	MOVL	#1,R0				; Is really True

1$:	MOVL	R0,@8(AP)			; Store the Result
	MOVL	#1,R0				; Return Code
	RET

2$:	MOVL	#DBG$_INVEXPR,R0		; Error in Type
	RET



	.ENTRY	PAS$_Arith_LNOT, ^M<>

	CMPL	4(AP),#U_bool			; Must be U_bool
	BNEQ	1$				; isn't, error

	MCOML	@12(AP),R0			; R0 <- NOT (Source Argument)
	EXTZV	#0,#1,R0,@8(AP)			; Store the Result
	MOVL	#1,R0				; Return Code
	RET

1$:	MOVL	#DBG$_INVEXPR,R0		; Error in Type
	RET

.SBTTL	Integer Addition

;++
; FUNCTIONAL SPECIFICATION:
;
;	These routines are used to perform addition operations.
;
; FORMAL PARAMETERS:
;
;	+4		- Data Type
;	+8		- Result Argument
;	+12		- Left   Argument
;	+16		- Right  Argument
;
; IMPLICIT INPUTS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;--

	.ENTRY	PAS$_Arith_ADD, ^M<R2,R3,R4>

	MOVL	#1,R0					; Assume Success

	MOVL	8(AP),R2				; Address of Result
	MOVL	12(AP),R3				; Address of Right Arg
	MOVL	16(AP),R4				; Address of Left  Arg

	CASEB	4(AP),#BU_int,#L_int-BU_int		; Case off the DType

1$:	.WORD	Add_BU_int  - 1$			; BU_int
	.WORD	Add_B_int   - 1$			; B_int
	.WORD	Add_WU_int  - 1$			; WU_int
	.WORD	Add_W_int   - 1$			; W_int
	.WORD	Add_LU_int  - 1$			; LU_int
	.WORD	Add_L_int   - 1$			; L_int

	MOVL	#DBG$_INVEXPR,R0			; Error, not allowed
	RET


; Overflow point
;
Add_Overflow:
	MOVL	#DBG$_INTOVER,R0			; Indicate Overflow
	RET


; BU_int
;
Add_BU_int:
	ADDB3	(R4),(R3),(R2)				; Perform the Add
;	BCS	Add_Overflow				; No check for Overflow
	RET


; B_int
;
Add_B_int:
	ADDB3	(R4),(R3),(R2)				; Perform the Add
	BVS	Add_Overflow				; Branch on Overflow
	RET


; WU_int
;
Add_WU_int:
	ADDW3	(R4),(R3),(R2)				; Perform the Add
;	BCS	Add_Overflow				; No check for Overflow
	RET


; W_int
;
Add_W_int:
	ADDW3	(R4),(R3),(R2)				; Perform the Add
	BVS	Add_Overflow				; Branch on Overflow
	RET


; LU_int
;
Add_LU_int:
	ADDL3	(R4),(R3),(R2)				; Perform the Add
;	BCS	Add_Overflow				; No check for Overflow
	RET


; L_int
;
Add_L_int:
	ADDL3	(R4),(R3),(R2)				; Perform the Add
	BVS	Add_Overflow				; Branch on Overflow
	RET

.SBTTL	Floating Addition

;++
; FUNCTIONAL SPECIFICATION:
;
;	These routines are used to perform addition operations. In the case of
;	an Overflow or Divide by Zero, an error condition is returned in R0.
;
; FORMAL PARAMETERS:
;
;	+4		- Data Type
;	+8		- Result Argument
;	+12		- Left   Argument
;	+16		- Right  Argument
;
; IMPLICIT INPUTS:
;
;	PAS$_Expr_Stack	- The Expression Stack
;	PAS$_Expr_Depth	- The Current Depth in the Expression Stack
;
; IMPLICIT OUTPUTS:
;
;	PAS$_Expr_Stack	- The Expression Stack
;
; SIDE EFFECTS:
;
;	Floating Overflows and Reserved Operand Faults are intercepted
;--

	.ENTRY	PAS$_Arith_ADD_FLOAT, ^M<>

	MOVAB	W^PAS$_Arith_Error_Handler,(FP)		; Establish Error Handler
	MOVL	#1,R0					; Assume everything will work

	CASEB	4(AP),#F_float,#H_float-F_float		; Case off the DType

1$:	.WORD	Add_F_float - 1$			; F_float
	.WORD	Add_D_float - 1$			; D_float
	.WORD	Add_G_float - 1$			; G_float
	.WORD	Add_H_float - 1$			; H_float

	MOVL	#DBG$_INVEXPR,R0			; Error, not allowed
	RET


; Overflow point
;
ADD_Overflow_Float:
	MOVL	#DBG$_FLTOVER,R0			; Indicate Overflow
	RET


; F_float
;
Add_F_float:
	ADDF3	@16(AP),@12(AP),@8(AP)			; Perform Floating Addition
	BVS	ADD_Overflow_Float			; Handle Overflow
	RET

; D_float
;
Add_D_float:
	ADDD3	@16(AP),@12(AP),@8(AP)			; Perform Floating Addition
	BVS	ADD_Overflow_Float			; Handle Overflow
	RET

; G_float
;
Add_G_float:
	ADDG3	@16(AP),@12(AP),@8(AP)			; Perform Floating Addition
	BVS	ADD_Overflow_Float			; Handle Overflow
	RET

; H_float
;
Add_H_Float:
	ADDH3	@16(AP),@12(AP),@8(AP)			; Perform Floating Addition
	BVS	ADD_Overflow_Float			; Handle Overflow
	RET

.SBTTL	Integer Subtraction

;++
; FUNCTIONAL SPECIFICATION:
;
;	These routines are used to perform Subtraction operations.
;
; FORMAL PARAMETERS:
;
;	+4		- Data Type
;	+8		- Result Argument
;	+12		- Left   Argument
;	+16		- Right  Argument
;
; IMPLICIT INPUTS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;--

	.ENTRY	PAS$_Arith_SUB, ^M<R2,R3,R4>

	MOVL	12(AP),R3				; Address of Right Arg
	MOVL	16(AP),R4				; Address of Left  Agr

Sub_Start:
	MOVL	#1,R0					; Assume Success
	MOVL	8(AP),R2				; Address of Result

	CASEB	4(AP),#BU_int,#L_int-BU_int		; Case off the DType

1$:	.WORD	SUB_BU_int  - 1$			; BU_int
	.WORD	SUB_B_int   - 1$			; B_int
	.WORD	SUB_WU_int  - 1$			; WU_int
	.WORD	SUB_W_int   - 1$			; W_int
	.WORD	SUB_LU_int  - 1$			; LU_int
	.WORD	SUB_L_int   - 1$			; L_int

	MOVL	#DBG$_INVEXPR,R0			; Error, not allowed
	RET


; Overflow point
;
SUB_Overflow:
	MOVL	#DBG$_INTOVER,R0			; Indicate Overflow
	RET


; BU_int
;
SUB_BU_int:
	SUBB3	(R4),(R3),(R2)				; Perform the SUB
;	BCS	SUB_Overflow				; No check for Overflow
	RET


; B_int
;
SUB_B_int:
	SUBB3	(R4),(R3),(R2)				; Perform the SUB
	BVS	SUB_Overflow				; Branch on Overflow
	RET


; WU_int
;
SUB_WU_int:
	SUBW3	(R4),(R3),(R2)				; Perform the SUB
;	BCS	SUB_Overflow				; No check for Overflow
	RET


; W_int
;
SUB_W_int:
	SUBW3	(R4),(R3),(R2)				; Perform the SUB
	BVS	SUB_Overflow				; Branch on Overflow
	RET


; LU_int
;
SUB_LU_int:
	SUBL3	(R4),(R3),(R2)				; Perform the SUB
;	BCS	SUB_Overflow				; No check for Overflow
	RET


; L_int
;
SUB_L_int:
	SUBL3	(R4),(R3),(R2)				; Perform the SUB
	BVS	SUB_Overflow				; Branch on Overflow
	RET

.SBTTL	Floating Subtraction

;++
; FUNCTIONAL SPECIFICATION:
;
;	These routines are used to perform Subtraction operations. In the case of
;	an Overflow or Divide by Zero, an error condition is returned in R0.
;
; FORMAL PARAMETERS:
;
;	+4		- Data Type
;	+8		- Result Argument
;	+12		- Left   Argument
;	+16		- Right  Argument
;
; IMPLICIT INPUTS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	Floating Overflows and Reserved Operand Faults are intercepted
;--

	.ENTRY	PAS$_Arith_SUB_FLOAT, ^M<R2,R3,R4>

	MOVL	12(AP),R3				; Address of Right Arg
	MOVL	16(AP),R4				; Address of Left  Agr

Sub_Float_Start:
	MOVL	#1,R0					; Assume Success
	MOVL	8(AP),R2				; Address of Result
	MOVAB	W^PAS$_Arith_Error_Handler,(FP)		; Establish Error Handler

	CASEB	4(AP),#F_float,#H_float-F_float		; Case off the DType

1$:	.WORD	SUB_F_float - 1$			; F_float
	.WORD	SUB_D_float - 1$			; D_float
	.WORD	SUB_G_float - 1$			; G_float
	.WORD	SUB_H_float - 1$			; H_float

	MOVL	#DBG$_INVEXPR,R0			; Error, not allowed
	RET


SUB_Overflow_Float:
	MOVL	#DBG$_FLTOVER,R0			; Error Return
	RET


; F_float
;
SUB_F_float:
	SUBF3	(R4),(R3),(R2)				; Perform Floating Subtraction
	BVS	SUB_Overflow_Float			; Handle Overflow
	RET


; D_float
;
SUB_D_float:
	SUBD3	(R4),(R3),(R2)				; Perform Floating Subtraction
	BVS	SUB_Overflow_Float			; Handle Overflow
	RET


; G_float
;
SUB_G_float:
	SUBG3	(R4),(R3),(R2)				; Perform Floating Subtraction
	BVS	SUB_Overflow_Float			; Handle Overflow
	RET


; H_float
;
SUB_H_Float:
	SUBH3	(R4),(R3),(R2)				; Perform Floating Subtraction
	BVS	SUB_Overflow_Float			; Handle Overflow
	RET

.SBTTL	Integer Multiply

;++
; FUNCTIONAL SPECIFICATION:
;
;	These routines are used to perform Multiply operations.
;
; FORMAL PARAMETERS:
;
;	+4		- Data Type
;	+8		- Result Argument
;	+12		- Left   Argument
;	+16		- Right  Argument
;
; IMPLICIT INPUTS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;--

	.ENTRY	PAS$_Arith_MUL, ^M<R2,R3,R4>

	MOVL	#1,R0					; Assume Success

	MOVL	8(AP),R2				; Address of Source
	MOVL	12(AP),R3				; Address of Right Arg
	MOVL	16(AP),R4				; Address of Left  Arg

	CASEB	4(AP),#BU_int,#L_int-BU_int		; Case off the DType

1$:	.WORD	MUL_BU_int  - 1$			; BU_int
	.WORD	MUL_B_int   - 1$			; B_int
	.WORD	MUL_WU_int  - 1$			; WU_int
	.WORD	MUL_W_int   - 1$			; W_int
	.WORD	MUL_LU_int  - 1$			; LU_int
	.WORD	MUL_L_int   - 1$			; L_int

	MOVL	#DBG$_INVEXPR,R0			; Error, not allowed
	RET


; Overflow point
;
MUL_Overflow:
	MOVL	#DBG$_INTOVER,R0			; Indicate Overflow
	RET


; BU_int
;
MUL_BU_int:
	MULB3	(R4),(R3),(R2)				; Perform the MUL
;	BCS	MUL_Overflow				; No check for Overflow
	RET


; B_int
;
MUL_B_int:
	MULB3	(R4),(R3),(R2)				; Perform the MUL
	BVS	MUL_Overflow				; Branch on Overflow
	RET


; WU_int
;
MUL_WU_int:
	MULW3	(R4),(R3),(R2)				; Perform the MUL
;	BCS	MUL_Overflow				; No check for Overflow
	RET


; W_int
;
MUL_W_int:
	MULW3	(R4),(R3),(R2)				; Perform the MUL
	BVS	MUL_Overflow				; Branch on Overflow
	RET


; LU_int
;
MUL_LU_int:
	MULL3	(R4),(R3),(R2)				; Perform the MUL
;	BCS	MUL_Overflow				; No check for Overflow
	RET


; L_int
;
MUL_L_int:
	MULL3	(R4),(R3),(R2)				; Perform the MUL
	BVS	MUL_Overflow				; Branch on Overflow
	RET

.SBTTL	Floating Multiply

;++
; FUNCTIONAL SPECIFICATION:
;
;	These routines are used to perform Multiply operations. In the case of
;	an Overflow or Divide by Zero, an error condition is returned in R0.
;
; FORMAL PARAMETERS:
;
;	+4		- Data Type
;	+8		- Result Argument
;	+12		- Left   Argument
;	+16		- Right  Argument
;
; IMPLICIT INPUTS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	Floating Overflows and Reserved Operand Faults are intercepted
;--

	.ENTRY	PAS$_Arith_MUL_FLOAT, ^M<>

	MOVAB	W^PAS$_Arith_Error_Handler,(FP)		; Establish Error Handler

	MOVL	#1,R0					; Assume success
	CASEB	4(AP),#F_float,#H_float-F_float		; Case off the DType

1$:	.WORD	MUL_F_float - 1$			; F_float
	.WORD	MUL_D_float - 1$			; D_float
	.WORD	MUL_G_float - 1$			; G_float
	.WORD	MUL_H_float - 1$			; H_float

	MOVL	#DBG$_INVEXPR,R0			; Error, not allowed
	RET


; Overflow point
;
MUL_Overflow_Float:
	MOVL	#DBG$_FLTOVER,R0			; Indicate Overflow
	RET


; F_float
;
MUL_F_float:
	MULF3	@16(AP),@12(AP),@8(AP)			; Perform Floating Multiply
	BVS	MUL_Overflow_Float			; Handle Overflow
	RET


; D_float
;
MUL_D_float:
	MULD3	@16(AP),@12(AP),@8(AP)			; Perform Floating Multiply
	BVS	MUL_Overflow_Float			; Handle Overflow
	RET


; G_float
;
MUL_G_float:
	MULG3	@16(AP),@12(AP),@8(AP)			; Perform Floating Multiply
	BVS	MUL_Overflow_Float			; Handle Overflow
	RET


; H_float
;
MUL_H_Float:
	MULH3	@16(AP),@12(AP),@8(AP)			; Perform Floating Multiply
	BVS	MUL_Overflow_Float			; Handle Overflow
	RET

.SBTTL	Integer Division

;++
; FUNCTIONAL SPECIFICATION:
;
;	These routines are used to perform DIV operations.
;
; FORMAL PARAMETERS:
;
;	+4		- Data Type
;	+8		- Result Argument
;	+12		- Left   Argument
;	+16		- Right  Argument
;
; IMPLICIT INPUTS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;--

	.ENTRY	PAS$_Arith_DIV, ^M<R2,R3,R4,R5>

	MOVL	#1,R0					; Assume Success

	MOVL	8(AP),R2				; Address of Source
	MOVL	12(AP),R3				; Address of Right Arg
	MOVL	16(AP),R5				; Address of Left  Arg

	CASEB	4(AP),#BU_int,#L_int-BU_int		; Case off the DType

1$:	.WORD	DIV_BU_int  - 1$			; BU_int
	.WORD	DIV_B_int   - 1$			; B_int
	.WORD	DIV_WU_int  - 1$			; WU_int
	.WORD	DIV_W_int   - 1$			; W_int
	.WORD	DIV_LU_int  - 1$			; LU_int
	.WORD	DIV_L_int   - 1$			; L_int

	MOVL	#DBG$_INVEXPR,R0			; Error, not allowed
	RET


; Overflow point
;
DIV_Overflow:
	MOVL	#DBG$_INTOVER,R0			; Indicate Overflow
	RET

; Divide by zero point
;
DIV_Divbyzero:
	MOVL	#DBG$_DIVBYZERO,R0			; Indicate division by zero
	RET

; BU_int
;
DIV_BU_int:
	MOVZBL	(R3),R3					; Zero-extend Dividend
	MOVZBL	(R5),R5					; Zero-extend Divisor
	BEQL	DIV_Divbyzero				; Branch on Divide by 0
	DIVL3	R5,R3,R4				; Perform the DIV
;	BCS	DIV_Overflow				; No check for Overflow
	MOVB	R4,(R2)
	RET


; B_int
;
DIV_B_int:
	TSTB	(R5)					; Check for Divide by 0
	BEQL	DIV_Divbyzero				; Branch on Divide by 0
	DIVB3	(R5),(R3),(R2)				; Perform the DIV
	BVS	DIV_Overflow				; Branch on Overflow
	RET


; WU_int
;
DIV_WU_int:
	MOVZWL	(R3),R3					; Zero-extend Dividend
	MOVZWL	(R5),R5					; Zero-extend Divisor
	BEQL	DIV_Divbyzero				; Branch on Divide by 0
	DIVL3	R5,R3,R4				; Perform the DIV
;	BCS	DIV_Overflow				; No check for Overflow
	MOVW	R4,(R2)
	RET


; W_int
;
DIV_W_int:
	TSTW	(R5)					; Check for Divide by 0
	BEQL	DIV_Divbyzero				; Branch on Divide by 0
	DIVW3	(R5),(R3),(R2)				; Perform the DIV
	BVS	DIV_Overflow				; Branch on Overflow
	RET


; LU_int
;
DIV_LU_int:
	TSTL	(R5)					; Check for Divide by 0
	BEQL	DIV_Divbyzero				; Branch on Divide by 0
	BGTR	2$					; Branch on + Divisor

	CLRL	(R2)					; Assume 0 Result
	CMPL	(R5),(R3)
	BGTRU	1$					; Branch on Divisor
							; GTRU Dividend
	INCL	(R2)					; 1 Result
1$:	RET

2$:	MOVL	(R3),R3					; Zero-extend Dividend
	CLRL	R4
	EDIV	(R5),R3,(R2),R1				; Perform the DIV
;	BCS	DIV_Overflow				; No check for Overflow
	RET


; L_int
;
DIV_L_int:
	TSTL	(R5)					; Check for Divide by 0
	BEQL	DIV_Divbyzero				; Branch on Divide by 0
	DIVL3	(R5),(R3),(R2)				; Perform the DIV
	BVS	DIV_Overflow				; Branch on Overflow
	RET

.SBTTL	Floating Division

;++
; FUNCTIONAL SPECIFICATION:
;
;	These routines are used to perform Division operations. In the case of
;	an Overflow or Divide by Zero, an error condition is returned in R0.
;
; FORMAL PARAMETERS:
;
;	+4		- Data Type
;	+8		- Result Argument
;	+12		- Left   Argument
;	+16		- Right  Argument
;
; IMPLICIT INPUTS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	Floating Overflows and Reserved Operand Faults are intercepted
;--

	.ENTRY	PAS$_Arith_DIV_FLOAT, ^M<>

	MOVAB	W^PAS$_Arith_Error_Handler,(FP)		; Establish Error Handler

	MOVL	#1,R0					; Assume success
	CASEB	4(AP),#F_float,#H_float-F_float		; Case off the DType

1$:	.WORD	DIV_F_float - 1$			; F_float
	.WORD	DIV_D_float - 1$			; D_float
	.WORD	DIV_G_float - 1$			; G_float
	.WORD	DIV_H_float - 1$			; H_float

	MOVL	#DBG$_INVEXPR,R0			; Error, not allowed
	RET


; Overflow point
;
DIV_Overflow_Float:
	MOVL	#DBG$_FLTOVER,R0			; Indicate Overflow
	RET

; Divide by zero point
;
DIV_Divbyzero_Float:
	MOVL	#DBG$_DIVBYZERO,R0
	RET

; F_float
;
DIV_F_float:
	TSTF	@16(AP)					; Check for Divide-by-0
	BEQL	DIV_Divbyzero_Float			; Branch on Divide by 0
	DIVF3	@16(AP),@12(AP),@8(AP)			; Perform Floating Division
	BVS	DIV_Overflow_Float			; Handle Overflow
	RET


; D_float
;
DIV_D_float:
	TSTD	@16(AP)					; Check for Divide-by-0
	BEQL	DIV_Divbyzero_Float			; Branch on Divide by 0
	DIVD3	@16(AP),@12(AP),@8(AP)			; Perform Floating Division
	BVS	DIV_Overflow_Float			; Handle Overflow
	RET


; G_float
;
DIV_G_float:
	TSTG	@16(AP)					; Check for Divide-by-0
	BEQL	DIV_Divbyzero_Float			; Branch on Divide by 0
	DIVG3	@16(AP),@12(AP),@8(AP)			; Perform Floating Division
	BVS	DIV_Overflow_Float			; Handle Overflow
	RET


; H_float
;
DIV_H_Float:
	TSTH	@16(AP)					; Check for Divide-by-0
	BEQL	DIV_Divbyzero_Float			; Branch on Divide by 0
	DIVH3	@16(AP),@12(AP),@8(AP)			; Perform Floating Division
	BVS	DIV_Overflow_Float			; Handle Overflow
	RET

.SBTTL	Integer Negation

;++
; FUNCTIONAL SPECIFICATION:
;
;	These routines are used to perform Negation operations.
;
; FORMAL PARAMETERS:
;
;	+4		- Data Type
;	+8		- Result Argument
;	+12		- Source Argument
;
; IMPLICIT INPUTS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;--

	.ENTRY	PAS$_Arith_NEG, ^M<R2,R3>

	MOVL	#1,R0					; Assume Success

	MOVL	8(AP),R2				; Address of Result
	MOVL	12(AP),R3				; Address of Source

	CASEB	4(AP),#BU_int,#L_int-BU_int		; Case off the DType

1$:	.WORD	2$        - 1$				; BU_int
	.WORD	NEG_B_int - 1$				; B_int
	.WORD	2$        - 1$				; WU_int
	.WORD	NEG_W_int - 1$				; W_int
	.WORD	2$        - 1$				; WU_int
	.WORD	NEG_L_int - 1$				; L_int

2$:	MOVL	#DBG$_INVEXPR,R0			; Error, not allowed
	RET


; Overflow point
;
NEG_Overflow:
	MOVL	#DBG$_INTOVER,R0			; Indicate Overflow
	RET


; B_int
;
NEG_B_int:
	MNEGB	(R3),(R2)				; Perform the Negation
	BVS	NEG_Overflow				; Branch on Overflow
	RET


; W_int
;
NEG_W_int:
	MNEGW	(R3),(R2)				; Perform the Negation
	BVS	NEG_Overflow				; Branch on Overflow
	RET


; L_int
;
NEG_L_int:
	MNEGL	(R3),(R2)				; Perform the Negation
	BVS	NEG_Overflow				; Branch on Overflow
	RET

.SBTTL	Floating Negation

;++
; FUNCTIONAL SPECIFICATION:
;
;	These routines are used to perform Negation operations. In the case of
;	an Overflow, an error condition is returned in R0.
;
; FORMAL PARAMETERS:
;
;	+4		- Data Type
;	+8		- Result Argument
;	+12		- Source Argument
;
; IMPLICIT INPUTS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	Floating Overflows and Reserved Operand Faults are intercepted
;--

	.ENTRY	PAS$_Arith_NEG_FLOAT, ^M<>

	MOVAB	W^PAS$_Arith_Error_Handler,(FP)		; Establish Error Handler

	MOVL	#1,R0					; Assume success
	CASEB	4(AP),#F_float,#H_float-F_float		; Case off the DType

1$:	.WORD	Neg_F_float - 1$			; F_float
	.WORD	Neg_D_float - 1$			; D_float
	.WORD	Neg_G_float - 1$			; G_float
	.WORD	Neg_H_float - 1$			; H_float

	MOVL	#DBG$_INVEXPR,R0			; Error, not allowed
	RET


NEG_Overflow_Float:
	MOVL	#DBG$_FLTOVER,R0			; Error Return
	RET


; F_float
;
NEG_F_float:
	MNEGF	@12(AP),@8(AP)				; Perform Floating Negation
	BVS	Neg_Overflow_Float			; Handle Overflow
	RET


; D_float
;
NEG_D_float:
	MNEGD	@12(AP),@8(AP)				; Perform Floating Negation
	BVS	Neg_Overflow_Float			; Handle Overflow
	RET


; G_float
;
NEG_G_float:
	MNEGG	@12(AP),@8(AP)				; Perform Floating Negation
	BVS	Neg_Overflow_Float			; Handle Overflow
	RET


; H_float
;
NEG_H_Float:
	MNEGH	@12(AP),@8(AP)				; Perform Floating Negation
	BVS	Neg_Overflow_Float			; Handle Overflow
	RET

.SBTTL	Integer Modulus

;++
; FUNCTIONAL SPECIFICATION:
;
;	These routines are used to perform MOD operations.
;
; FORMAL PARAMETERS:
;
;	+4		- Data Type
;	+8		- Result Argument
;	+12		- Left   Argument
;	+16		- Right  Argument
;
; IMPLICIT INPUTS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;--

	.ENTRY	PAS$_Arith_MOD, ^M<R2,R3,R4,R5>

	MOVL	#1,R0					; Assume Success

	MOVL	8(AP),R3				; Address of Result
	MOVL	12(AP),R4				; Address of Left Arg
	MOVL	16(AP),R5				; Address of Right Arg

	CASEB	4(AP),#LU_Int,#L_Int-LU_Int
1$:
	.WORD	MOD_LU_Int	-1$			; LU_Int
	.WORD	MOD_L_Int	-1$			; L_Int

	MOVL	#DBG$_INVEXPR,R0			; Invalid expression
	RET

; Division by zero point
;
MOD_Divbyzero:
	MOVL	#DBG$_DIVBYZERO,R0
	RET

; Undefined modulus point
;
MOD_Undmod:
	MOVL	#DBG$_UNDMOD,R0
	RET

; LU_Int
;
MOD_LU_Int:
	TSTL	(R5)
	BEQL	REM_Divbyzero
	BGTR	2$

	MOVL	(R4),R2					; Assume Dividend
	CMPL	(R5),R2
	BGTRU	1$
	SUBL2	(R5),R2
1$:	MOVL	R2,(R3)
	RET

2$:	CLRL	R2					; Zero-extend Left Arg
	MOVL	(R4),R1
	EDIV	(R5),R1,R1,(R3)
	RET

; L_Int
;
MOD_L_Int:
	TSTL	(R5)
	BEQL	MOD_Divbyzero
	BLSS	MOD_Undmod
	EMUL	(R4),#1,#0,R1				; Sign-extend Left Arg
	EDIV	(R5),R1,R1,R2
	TSTL	R2					; Result < 0 ?
	BGEQ	1$
	ADDL2	(R5),R2					; Add divisor into result
1$:	MOVL	R2,(R3)
	RET

.SBTTL	Integer Remainder

;++
; FUNCTIONAL SPECIFICATION:
;
;	These routines are used to perform REM operations.
;
; FORMAL PARAMETERS:
;
;	+4		- Data Type
;	+8		- Result Argument
;	+12		- Left   Argument
;	+16		- Right  Argument
;
; IMPLICIT INPUTS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;--

	.ENTRY	PAS$_Arith_REM, ^M<R2,R3,R4,R5>

	MOVL	#1,R0					; Assume Success

	MOVL	8(AP),R3				; Address of Result
	MOVL	12(AP),R4				; Address of Left Arg
	MOVL	16(AP),R5				; Address of Right Arg

	CASEB	4(AP),#LU_Int,#L_Int-LU_Int
1$:
	.WORD	REM_LU_Int	- 1$			; LU_Int
	.WORD	REM_L_Int	- 1$			; L_Int

	MOVL	#DBG$_INVEXPR,R0			; Invalid expression
	RET

; Division by zero point
;
REM_Divbyzero:
	MOVL	#DBG$_DIVBYZERO,R0
	RET

; LU_Int
;
REM_LU_Int:
	TSTL	(R5)
	BEQL	REM_Divbyzero
	BGTR	2$

	MOVL	(R4),R2					; Assume Dividend
	CMPL	(R5),R2
	BGTRU	1$
	SUBL2	(R5),R2
1$:	MOVL	R2,(R3)
	RET

2$:	CLRL	R2					; Zero-extend Left Arg
	MOVL	(R4),R1
	EDIV	(R5),R1,R1,(R3)
	RET

; L_Int
;
REM_L_Int:
	TSTL	(R5)
	BEQL	REM_Divbyzero
	EMUL	(R4),#1,#0,R1				; Sign_extend Left Arg
	EDIV	(R5),R1,R1,(R3)
	RET

.SBTTL	Integer Exponentiation

;++
; FUNCTIONAL SPECIFICATION:
;
;	These routines are used to perform Exponentiation operations.
;	In the case of an Overflow or Undefined Exponentiation, an error
;	condition is returned.
;
; FORMAL PARAMETERS:
;
;	+4		- Data Type
;	+8		- Result Argument
;	+12		- Left   Argument
;	+16		- Right  Argument
;
; IMPLICIT INPUTS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	Integer overflow and Undefined Exponentiation are intercepted
;--

	.ENTRY	PAS$_Arith_EXPO,^M<>

	CMPL	4(AP),#F_Float				; Check for floating operation
	BLSS	EXPO_Integer				; Branch if not
	CALLG	(AP),PAS$_Arith_Expo_Float		; Do the floating operation
	RET						; And return

EXPO_Integer:
	MOVAB	W^PAS$_Arith_Error_Handler,(FP)		; Set up Error Trap

	MOVL	12(AP),R0				; Address of Base (Left) Argument
	MOVL	16(AP),R1				; Address of Exponent (Right) Argument

	CASEB	4(AP),#LU_Int,#L_Int-LU_Int		; Case off the Dtype

1$:	.WORD	EXPO_LU_Int	- 1$			; LU_Int
	.WORD	EXPO_L_Int	- 1$			; L_Int

	MOVL	#DBG$_INVEXPR,R0			; Error, not allowed
	RET

; Overflow point
;
EXPO_Overflow:
	MOVL	#DBG$_INTOVER,R0			; Indicate Overflow
	RET

; Undefined Exponentiation point
;
EXPO_Undefined_Expo:
	MOVL	#DBG$_UNDEXP,R0				; Indicate Undefined Exponentiation
	RET

; LU_Int
;
EXPO_LU_Int:
	PUSHL	(R1)					; Exponent
	PUSHL	(R0)					; Base
	BNEQ	1$					; Branch if Base <> 0
	TSTL	4(SP)					; Check for Exponent = 0
	BNEQ	1$					; Branch if not
	BRW	EXPO_Undefined_Expo			; Undefined exponentiation
1$:	CALLS	#2,OTS$POWLULU				; Perform exponentiation
	MOVL	R0,@8(AP)				; Set result
	BRB	EXPO_Success

; L_Int
;
EXPO_L_Int:
	PUSHL	(R1)					; Exponent
	PUSHL	(R0)					; Base
	BNEQ	1$					; Branch if base <> 0
	TSTL	4(SP)					; Check for exponent <= 0
	BGTR	1$					; Branch if not
	BRW	EXPO_Undefined_Expo			; Undefined exponentiation
1$:	CALLS	#2,OTS$POWJJ				; Perform exponentiation
	MOVL	R0,@8(AP)				; Set result

Expo_Success:
	MOVL	#1,R0
	RET

.SBTTL	Floating Exponentiation

;++
; FUNCTIONAL SPECIFICATION:
;
;	These routines are used to perform Exponentiation operations. In the
;	cas of an Overflow, Underflow, or Undefined Exponentiation, an error
;	condition is returned in R0.
;
; FORMAL PARAMETERS:
;
;	+4		- Data Type
;	+8		- Result Argument
;	+12		- Left   Argument
;	+16		- Right  Argument
;
; IMPLICIT INPUTS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	Floating Overflows and Underflows, Reserved Operand Faults, and 
;	Undefined Exponentiations are intercepted
;--

	.ENTRY PAS$_Arith_EXPO_Float,^M<R2,R3>

	MOVAB	W^PAS$_Arith_Error_Handler,(FP)		; Establish Error Handler

	CASEB	4(AP),#F_Float,#H_Float - F_Float	; Case off the Dtype

1$:	.WORD	EXPO_F_Float - 1$			; F_Float
	.WORD	EXPO_D_Float - 1$			; D_Float
	.WORD	EXPO_G_Float - 1$			; G_Float
	.WORD	EXPO_H_Float - 1$			; H_Float

	MOVL	#DBG$_INVEXPR,R0			; Error, not allowed
	RET

; Overflow Point
;
EXPO_Overflow_Float:
	MOVL	#DBG$_FLTOVER,R0			; Indicate Overflow
	RET

; Undefined Exponentiation
;
EXPO_Undefined_Expo_Float:
	MOVL	#DBG$_UNDEXP,R0				; Indicate Undefined Exponentiation
	RET

; F_Float
;
EXPO_F_Float:
	TSTF	@12(AP)					; Check for Base <= 0
	BGTR	1$					; Branch if not
	BLSS	EXPO_Undefined_Expo_Float		; Branch if < 0
	TSTF	@16(AP)					; Check for Exponent <= 0
	BLEQ	EXPO_Undefined_Expo_Float		; Branch on Undefined Exponentiation

1$:	PUSHL	@16(AP)					; Push Exponent
	PUSHL	@12(AP)					; Push Base
	CALLS	#2,OTS$POWRR				; Perform the exponentiation
	MOVF	R0,@8(AP)				; Store result
	MOVL	#1,R0					; Return Success
	RET

; D_Float
;
EXPO_D_Float:
	TSTD	@12(AP)					; Check for Base <= 0
	BGTR	1$					; Branch if not
	BLSS	EXPO_Undefined_Expo_Float		; Branch if < 0
	TSTD	@16(AP)					; Check for Exponent <= 0
	BLEQ	EXPO_Undefined_Expo_Float		; Branch on Undefined Exponentiation

1$:	MOVD	@16(AP),-(SP)				; Push Exponent
	MOVD	@12(AP),-(SP)				; Push Base
	CALLS	#2,OTS$POWDD				; Perform the exponentiation
	MOVD	R0,@8(AP)				; Store result
	MOVL	#1,R0					; Return Success
	RET

; G_Float
;
EXPO_G_Float:
	TSTG	@12(AP)					; Check for Base <= 0
	BGTR	1$					; Branch if not
	BEQL	.+3					; Branch if = 0
	BRW	EXPO_Undefined_Expo_Float		; Undefined exponentiation
	TSTG	@16(AP)					; Check for Exponent <= 0
	BGTR	1$					; Tisn't
	BRW	EXPO_Undefined_Expo_Float		; Branch on Undefined Exponentiation

1$:	MOVG	@16(AP),-(SP)				; Push Exponent
	MOVG	@12(AP),-(SP)				; Push Base
	CALLS	#2,OTS$POWGG				; Perform the exponentiation
	MOVG	R0,@8(AP)				; Store result
	MOVL	#1,R0					; Return Success
	RET

; H_Float
;
EXPO_H_Float:
	TSTH	@12(AP)					; Check for Base <= 0
	BGTR	1$					; Branch if not
	BEQL	.+3					; Branch if = 0
	BRW	EXPO_Undefined_Expo_Float		; Branch on Undefined Exponentiation
	TSTH	@16(AP)					; Check for Exponent <= 0
	BGTR	1$					; Tisn't
	BRW	EXPO_Undefined_Expo_Float		; Branch on Undefined Exponentiation

1$:	MOVH	@16(AP),-(SP)				; Push Exponent
	MOVH	@12(AP),-(SP)				; Push Base
	CALLS	#2,OTS$POWHH_R3				; Perform the exponentiation
	MOVH	R0,@8(AP)				; Store result
	MOVL	#1,R0					; Return Success
	RET

.SBTTL	Comparison Main Routines

;++
; FUNCTIONAL SPECIFICATION:
;
;	These routines are used to perform comparison operations.
;
; FORMAL PARAMETERS:
;
;	+4		- Data Type
;	+8		- Result Argument
;	+12		- Left   Argument
;	+16		- Right  Argument
;
; IMPLICIT INPUTS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;--

	.ENTRY	PAS$_Arith_EQL, ^M<>

	CALLG	(AP),W^PAS$_Arith_CMP_ROUTINE		; Select Compare Routine
	
	MOVL	R0,R1					; Copy Routine Pointer
	BEQL	4$					; No routine, error
	CLRL	R0					; Assume False
	JSB	(R1)					; Call the Routine

	BNEQ	3$					; Not Equal
	MOVL	#1,R0					; Equal, result True
3$:	MOVL	R0,@8(AP)				; Store the Result

	MOVL	#1,R0					; Succeeded
	RET

4$:	MOVL	#DBG$_INVEXPR,R0			; Failed, Illegal Compare
	RET


	.ENTRY	PAS$_Arith_NEQ, ^M<>

	CALLG	(AP),W^PAS$_Arith_CMP_ROUTINE		; Select Compare Routine
	
	MOVL	R0,R1					; Copy Routine Pointer
	BEQL	2$					; No routine, error
	CLRL	R0					; Assume False
	JSB	(R1)					; Call the Routine

	BEQL	1$					; Equal
	MOVL	#1,R0					; Not Equal, result True
1$:	MOVL	R0,@8(AP)				; Store the Result

	MOVL	#1,R0					; Succeeded
	RET

2$:	MOVL	#DBG$_INVEXPR,R0			; Failed, Illegal Compare
	RET


	.ENTRY	PAS$_Arith_LSS, ^M<>

	CALLG	(AP),W^PAS$_Arith_CMP_ROUTINE		; Select Compare Routine
	
	MOVL	R0,R1					; Copy Routine Pointer
	BEQL	4$					; No routine, error
	MOVL	#1,R0					; Assume True
	CMPL	4(AP),#O_int				; Is it an Integer
	BGTR	1$					; Nope
	BLBC	4(AP),1$				; Isn't Unsigned
	JSB	(R1)					; Call the Routine

	BLSSU	3$					; Less Than
	BRB	2$					; Continue

1$:	JSB	(R1)					; Call the Routine
	BLSS	3$					; Not Less Than
2$:	CLRL	R0					; Not Less Than, Result False
3$:	MOVL	R0,@8(AP)				; Store the Result

	MOVL	#1,R0					; Succeeded
	RET

4$:	MOVL	#DBG$_INVEXPR,R0			; Failed, Illegal Compare
	RET



	.ENTRY	PAS$_Arith_LEQ, ^M<>

	CALLG	(AP),W^PAS$_Arith_CMP_ROUTINE		; Select Compare Routine
	
	MOVL	R0,R1					; Copy Routine Pointer
	BEQL	4$					; No routine, error
	MOVL	#1,R0					; Assume True
	CMPL	4(AP),#O_int				; Is it an Integer
	BGTR	1$					; Nope
	BLBC	4(AP),1$				; Isn't Unsigned
	JSB	(R1)					; Call the Routine

	BLEQU	3$					; Less Than or Equal
	BRB	2$					; Continue

1$:	JSB	(R1)					; Call the Routine
	BLEQ	3$					; Not Less Than or Equal
2$:	CLRL	R0					; Not Less Than or Equal, Result False
3$:	MOVL	R0,@8(AP)				; Store the Result

	MOVL	#1,R0					; Succeeded
	RET

4$:	MOVL	#DBG$_INVEXPR,R0			; Failed, Illegal Compare
	RET



	.ENTRY	PAS$_Arith_GTR, ^M<>

	CALLG	(AP),W^PAS$_Arith_CMP_ROUTINE		; Select Compare Routine
	
	MOVL	R0,R1					; Copy Routine Pointer
	BEQL	4$					; No routine, error
	MOVL	#1,R0					; Assume True
	CMPL	4(AP),#O_int				; Is it an Integer
	BGTR	1$					; Nope
	BLBC	4(AP),1$				; Isn't Unsigned
	JSB	(R1)					; Call the Routine

	BGTRU	3$					; Greater Than
	BRB	2$					; Continue

1$:	JSB	(R1)					; Call the Routine
	BGTR	3$					; Not Greater Than
2$:	CLRL	R0					; Not Greater Than, Result False
3$:	MOVL	R0,@8(AP)				; Store the Result

	MOVL	#1,R0					; Succeeded
	RET

4$:	MOVL	#DBG$_INVEXPR,R0			; Failed, Illegal Compare
	RET



	.ENTRY	PAS$_Arith_GEQ, ^M<>

	CALLG	(AP),W^PAS$_Arith_CMP_ROUTINE		; Select Compare Routine
	
	MOVL	R0,R1					; Copy Routine Pointer
	BEQL	4$					; No routine, error
	MOVL	#1,R0					; Assume True
	CMPL	4(AP),#O_int				; Is it an Integer
	BGTR	1$					; Nope
	BLBC	4(AP),1$				; Isn't Unsigned
	JSB	(R1)					; Call the Routine

	BGEQU	3$					; Greater Than or Equal To
	BRB	2$					; Continue

1$:	JSB	(R1)					; Call the Routine
	BGEQ	3$					; Not Greater Than or Equal To
2$:	CLRL	R0					; Not Greater Than or Equal To, Result False
3$:	MOVL	R0,@8(AP)				; Store the Result

	MOVL	#1,R0					; Succeeded
	RET

4$:	MOVL	#DBG$_INVEXPR,R0			; Failed, Illegal Compare
	RET

.SBTTL	Compare Routine Selection

;++
; FUNCTIONAL SPECIFICATION:
;
;	This routine is used to get the address of a routine to do comparisons.
;
; FORMAL PARAMETERS:
;
;	+4		- Data Type
;
; IMPLICIT INPUTS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; ROUTINE VALUE:
;
;	Pointer to a JSB-entry subroutine to do the compare
;
; SIDE EFFECTS:
;
;	NONE
;--

	.ENTRY	PAS$_Arith_CMP_ROUTINE, ^M<>

	CASEB	4(AP),#BU_int,#U_bool-BU_int		; Case off the DType

1$:	.WORD	3$ - 1$					; BU_int
	.WORD	3$ - 1$					; B_int
	.WORD	4$ - 1$					; WU_int
	.WORD	4$ - 1$					; W_int
	.WORD	5$ - 1$					; LU_int
	.WORD	5$ - 1$					; L_int
	.WORD	2$ - 1$					; QU_int
	.WORD	2$ - 1$					; Q_int
	.WORD	2$ - 1$					; OU_int
	.WORD	2$ - 1$					; O_int
	.WORD	6$ - 1$					; F_float
	.WORD	7$ - 1$					; D_float
	.WORD	8$ - 1$					; G_float
	.WORD	9$ - 1$					; H_float
	.WORD	5$ - 1$					; U_bool

2$:	CLRL	R0					; Error, not allowed
	RET

3$:	MOVAB	W^Cmp_B_int,R0				; Compare Byte
	RET

4$:	MOVAB	W^Cmp_W_int,R0				; Compare Word
	RET

5$:	MOVAB	W^Cmp_L_int,R0				; Compare Long
	RET

6$:	MOVAB	W^Cmp_F_float,R0			; Compare F_float
	RET

7$:	MOVAB	W^Cmp_D_float,R0			; Compare D_float
	RET

8$:	MOVAB	W^Cmp_G_float,R0			; Compare G_float
	RET

9$:	MOVAB	W^Cmp_H_float,R0			; Compare H_float
	RET


.SBTTL	Comparison Routines

;++
; FUNCTIONAL SPECIFICATION:
;
;	These routines are used to perform Comparison Operations.
;
; FORMAL PARAMETERS:
;
;	+4		- Data Type
;	+8		- Result Argument
;	+12		- Left   Argument
;	+16		- Right  Argument
;
; IMPLICIT INPUTS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;--


; B_int
;
Cmp_B_int:
	CMPB	@16(AP),@12(AP)				; Perform the Compare
	RSB


; W_int
;
Cmp_W_int:
	CMPW	@16(AP),@12(AP)				; Perform the Compare
	RSB


; L_int
;
Cmp_L_int:
	CMPL	@16(AP),@12(AP)				; Perform the Compare
	RSB


; F_float
;
Cmp_F_float:
	CMPF	@16(AP),@12(AP)				; Perform the Compare
	RSB


; D_float
;
Cmp_D_float:
	CMPD	@16(AP),@12(AP)				; Perform the Compare
	RSB


; G_float
;
Cmp_G_float:
	CMPG	@16(AP),@12(AP)				; Perform the Compare
	RSB


; H_float
;
Cmp_H_float:
	CMPH	@16(AP),@12(AP)				; Perform the Compare
	RSB

.SBTTL	Error Handler

;++
; FUNCTIONAL SPECIFICATION:
;
;	This routine intercepts interrupts and fields them for Floating
;	Overflows and Floating Divide-by-Zero and Reserved Operand Traps.
;
; FORMAL PARAMETERS:
;
;	+4	- Signal    Arguments
;	+8	- Mechanism Arguments
;
; IMPLICIT INPUTS:
;
;	The State of the Signaling Routine
;
; IMPLICIT OUTPUTS:
;
;	The Result Value of the Signaling Routine
;
;--

	.GLOBAL	LIB$FIXUP_FLT			; Fix Up Floating Point Fault
	.GLOBAL	LIB$SIM_TRAP			; Simulate Floating Trap


	.ENTRY	PAS$_Arith_ERROR_HANDLER, ^M<>

	CALLG	(AP),L^LIB$SIM_TRAP		; Simulate Floating Trap

	MOVL	4(AP),R0			; Pointer to Signal Arguments
	MOVL	8(AP),R1			; Pointer to Mechanism Arguments

	CMPL	CHF$L_SIG_NAME(R0),#SS$_FLTOVF	; Check for Floating Overflow
	BNEQ	2$				; 'tisn't
1$:	MOVL	#DBG$_FLTOVER,CHF$L_MCH_SAVR0(R1)	; Replace Condition Code
	BRB	20$

2$:	CMPL	CHF$L_SIG_NAME(R0),#SS$_FLTUND	; Check for Floating Underflow
	BNEQ	4$				; 'tisn't
3$:	MOVL	#DBG$_FLTUNDER,CHF$L_MCH_SAVR0(R1)	; Replace Condition Code
	BRB	20$

4$:	CMPL	CHF$L_SIG_NAME(R0),#SS$_FLTDIV	; Check for Floating Divide by 0
	BNEQ	5$				; 'tisn't
	MOVL	#DBG$_DIVBYZERO,CHF$L_MCH_SAVR0(R1)	; Replace Condition Code
	BRB	20$

5$:	CMPL	CHF$L_SIG_NAME(R0),#SS$_ROPRAND		; Reserved Operand
	BNEQ	6$
	MOVL	#DBG$_ROPRAND,CHF$L_MCH_SAVR0(R1)	; Replace Condition Code
	BRB	20$

6$:	CMPL	CHF$L_SIG_NAME(R0),#MTH$_UNDEXP		; Undefined Exponentiation
	BNEQ	7$
	MOVL	#DBG$_UNDEXP,CHF$L_MCH_SAVR0(R1)	; Replace Condition Code
	BRB	20$

7$:	CMPL	CHF$L_SIG_NAME(R0),#SS$_INTOVF		; Integer Overflow
	BNEQ	8$
	MOVL	#DBG$_INTOVER,CHF$L_MCH_SAVR0(R1)	; Replace Condition Code
	BRB	20$

8$:	CMPL	CHF$L_SIG_NAME(R0),#MTH$_FLOOVEMAT	; Floating Overflow in Math Library
	BEQL	1$					; 'tis

	CMPL	CHF$L_SIG_NAME(R0),#MTH$_FLOUNDMAT	; Floating Underflow in Math Library
	BEQL	3$					; 'tis
	BRB	21$

20$:	$UNWIND_S				; Intercepted Error

21$:	MOVL	#SS$_RESIGNAL,R0		; Didn't intercept error
	RET

	.END
