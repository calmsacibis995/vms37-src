MODULE DBGSOURCE (IDENT = 'V03-000') =

BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! WRITTEN BY
!	Bert Beander	August, 1981
!	Ping Sager
!	Rich Title
!
! MODULE FUNCTION
!	This module contains all routines connected with DEBUG's source line
!	display feature.  It thus implements the TYPE, EXAMINE/SOURCE, SET
!	SOURCE, SHOW SOURCE, and CANCEL SOURCE commands, and it contains all
!	routines which look up source lines and open and read source files.
!

REQUIRE 'SRC$:DBGPROLOG.REQ';

FORWARD ROUTINE
    DBG$SRC_CANCEL_SOURCE: NOVALUE,	! Handle the CANCEL SOURCE command
    DBG$SRC_CLOSE_FILE: NOVALUE,	! Close a source file
    DBG$SRC_INIT: NOVALUE,		! Initialize data structures at DEBUG
					!      initialization time
    DBG$SRC_OPEN,			! Actually does the open and verifies
    					!      the attributes of a source file
    DBG$SRC_OPEN_FILE: NOVALUE,		! Open a source file after applying all
					!      directory search rules
    DBG$SRC_OUTPUT_LINE: NOVALUE,	! Output a source line in proper format
    DBG$SRC_READ_FILE: NOVALUE,		! Read a source line from a source file
    DBG$SRC_SEARCH,			! Actually does the search
    DBG$SRC_SEARCH_CMD: NOVALUE,	! Handle the SEARCH command
    DBG$SRC_SET_MAX_FILES: NOVALUE,	! Set maximum number of source files
					!      that can be open at one time
    DBG$SRC_SET_SOURCE: NOVALUE,	! Handle the SET SOURCE command
    DBG$SRC_SHOW_SOURCE: NOVALUE,	! Handle the SHOW SOURCE command
    DBG$SRC_TYPE_LINE,			! Retrieve and type out a source line
    DBG$SRC_TYPE_LNUM_SOURCE: NOVALUE,	! Type a set of source lines given a
					!      module and a line number range
    DBG$SRC_TYPE_PC_SOURCE: NOVALUE,	! Type a set of source lines given a
					!      Program Counter range
    OUTPUT_DIR_LIST : NOVALUE;		! Outputs a source directory list at
    					! the terminal.

EXTERNAL ROUTINE
    DBG$FAO_PUT: NOVALUE,		! Output some ASCII text
    DBG$GET_MEMORY,			! Get a permanent memory block
    DBG$GET_TEMPMEM,			! Get a tempory memory block
    !DBG$IS_IT_ENTRY,                   ! Match address to routine symbol
    DBG$OUT_PUT: NOVALUE,		! Flush the DBG$FAO_PUT output buffer
    DBG$PC_TO_LINE_LOOKUP,		! Matches an absolute PC address to a
    					!	line number
    DBG$REL_MEMORY: NOVALUE,		! Release a permanent memory block
    DBG$STA_SYMNAME: NOVALUE,		! Get module name for a given module RST
    					!	pointer
    LBR$CLOSE,				! Closes an open library
    LBR$FIND,				! Looks up a key by RFA in preparation
    					!       for reading the key's associated
    					!	text
    LBR$GET_RECORD,			! Reads a text record associated with a
    					!	module in the library
    LBR$LOOKUP_KEY,			! Looks up a module in a text library
    LBR$INI_CONTROL,			! Initializes a library index for use
    					!       by all other routines
    LBR$OPEN,				! Opens an existing library 
    LBR$SET_MODULE,			! Reads an module header in a text library
    STR$UPCASE;				! Uppercase Conversion


EXTERNAL
    DBG$CP_OUT_STR,			! Buffer pointer used by DBG$FAO_PUT
    DBG$GB_LANGUAGE: BYTE,		! Set to language code
    DBG$GL_BUF_SIZ;			! Buffer length used by DBG$FAO_PUT


LITERAL
    MAX_MAX_FILES	= 20,		! Maximum number of Source File Control
					!      Blocks we allow user to create
    NAMBUFSIZE		= 256,		! Size in bytes of name buffers pointed
					!      to by the RMS NAM block
    SEARCH_IDENT_ALL    = 1,		! SEARCH/IDENT/ALL is active
    SEARCH_IDENT_NEXT   = 2,		! SEARCH/IDENT/NEXT is active
    SEARCH_STRING_ALL	= 3,		! SEARCH/STRING/ALL is active
    SEARCH_STRING_NEXT	= 4,		! SEARCH/STRING/NEXT is active
    SRCBUFSIZE          = 256,		! Size in bytes of source record buffer
    RFATBL_SIZE 	= 300,		! Size in bytes of the RFA table
    RFATBL_ENTRIES	= 50,		! Number of entries in the RFA table
    INIT_RFATBL_SPACING = 5;		! Number of source records per RFA
    					! table entry.

GLOBAL
    DBG$SRC_LEFT_MARGIN : INITIAL(1),   ! Left margin of source output
    DBG$SRC_RIGHT_MARGIN : INITIAL(255),! Right margin of source output
    DBG$SRC_TERM_WIDTH: INITIAL(80),	! Terminal width for source line display
    DBG$SRC_MAX_FILES: INITIAL(5),	! Maximum number of source files to be
					!      kept open at any one time
    DBG$SRC_NEXT_LNUM: INITIAL(1),	! Next desired line in the current 
    					! 	module to be typed 
    DBG$SRC_NEXT_MODRSTPTR: INITIAL(0),	! Associated module RST pointer
    DBG$SRC_NEXT_STMT: INITIAL(0),	! Next desired statement number in the 
    					!	current module to be typed
    DBG$SRC_SEARCH_STRING: VECTOR[SRCBUFSIZE,BYTE]
    	INITIAL (BYTE (0, REP (SRCBUFSIZE - 1) OF (%C' ')));
    					! Contains a counted ASCII search string
    					!	filled by SEARCH Command.


OWN
    DBG$SRC_DIR_LIST: REF SDSL$HEADER	! Pointer to linked list of Source Dir-
			INITIAL(0),	!      ectory Search List Header blocks
    DBG$SRC_MODRSTPTR: REF RST$ENTRY,	! Pointer to the Module RST Entry for
					!      the "current module", the module
					!      we are now reading source from
    DBG$SRC_SEARCH_FLAG,		! Set to SEARCH_FLAG's value which
    					!	indicate whether the SEARCH
    					!	command is in action and the
    					!	kind of search option is used
    DBG$SRC_SFCB_PTR: REF SFCB$BLOCK	! Pointer to first Source File Control
			INITIAL(0),	!      Block on doubly linked list of
					!      such blocks
    DBG$SRC_REC_BUF: VECTOR[SRCBUFSIZE,	! Buffer area to hold the source file
    			BYTE];		!      record

GLOBAL ROUTINE DBG$SRC_CANCEL_SOURCE(MODRSTPTR): NOVALUE =
!
! FUNCTION
!	This routine handles the semantic processing of the CANCEL SOURCE and
!	CANCEL SOURCE/MODULE=xxx commands.  It removes the directory list for
!	the specified module, or the default directory list if the /MODULE
!	qualifier was not present, from the list of directory search lists
!	pointed to by DBG$SRC_DIR_LIST.  It thus cancels the effect of the
!	SET SOURCE or SET SOURCE/MODULE=xxx command which created that direct-
!	ory search list.
!
! INPUTS
!	MODRSTPTR - A pointer to the Module RST Entry of the module specified
!		  on the CANCEL SOURCE/MODULE command.  If the /MODULE quali-
!		  fier was not present on the command, MODRSTPTR must be zero.
!
! OUTPUTS
!	NONE
!
!--

    BEGIN

    MAP
	MODRSTPTR: REF RST$ENTRY;	! Pointer to Module RST Entry or zero

    LOCAL
    	HDRPTR : REF SDSL$HEADER,  	! Pointer to a Source Directory Search
    					!	List Header Block. 
    					! 	This pointer is used to walk 
    					!	through the linked list of
    					!	header blocks.
    	ENTRY_PTR : REF SDSL$ENTRY,	! Pointer to a Source Directory Search
    					! 	List Entry.This pointer is
    					!	used to walk through the linked
    					! 	list of entries, once the 
    					!	appropriate source directory
    					!	search list is found.
    	MODNAMEPTR,			! Points to a counted string with the
    					!	module name corresponding to
    					!	MODRSTPTR. (Needed in case an
    					!	error message is signalled).
       	PREV_HDRPTR : REF SDSL$HEADER,  ! This variable contains the previous
    					!	Source Directory Search List Header
    					!	as we walk through the linked
    					!	list. We need to remember this
    					!	so we can unlink the header 
    					!	being cancelled.
    	TEMP_PTR;			! Pointer to a source directory list
    					!	entry. Used during freeing up
    					!	of space.

    ! Attempt to find a directory list for the module specified by MODRSTPTR.
    !
    PREV_HDRPTR = DBG$SRC_DIR_LIST;
    HDRPTR = .DBG$SRC_DIR_LIST;
    WHILE .HDRPTR NEQ 0 DO
       	BEGIN
    	IF .HDRPTR [SDSL$L_MODPTR] EQL .MODRSTPTR
    	THEN
    	    EXITLOOP;
    	PREV_HDRPTR = .HDRPTR;
    	HDRPTR = .HDRPTR[SDSL$L_FLINK];
    	END;


    ! If no source directory search list header block was found for the 
    ! specified module, signal an error to the user.
    !
    IF .HDRPTR EQL 0
    THEN
    	BEGIN
    	IF .MODRSTPTR NEQ 0
    	THEN
    	    BEGIN
    	    DBG$STA_SYMNAME (.MODRSTPTR, MODNAMEPTR);
    	    SIGNAL (DBG$_NODIRLISM, 1, .MODNAMEPTR);
    	    END

    	ELSE
    	    SIGNAL (DBG$_NODIRLIST);

    	END;


    ! Unlink the Source Directory Search List Header Block for the 
    ! MODRSTPTR module from the Source Directory Search List. Then
    ! release that block and all associated Source Directory Search
    ! List Entries to the memory pool
    !
    PREV_HDRPTR[SDSL$L_FLINK] = .HDRPTR[SDSL$L_FLINK];
    ENTRY_PTR = .HDRPTR[SDSL$L_LIST_PTR];
    WHILE .ENTRY_PTR NEQ 0 DO
    	BEGIN
    	TEMP_PTR = .ENTRY_PTR[SDSL$L_ENT_FLINK];
    	DBG$REL_MEMORY (.ENTRY_PTR);
    	ENTRY_PTR = .TEMP_PTR;
    	END;
    DBG$REL_MEMORY (.HDRPTR);


    ! Reinitialize all Source File Control Blocks. This forces all open source
    ! files to be reinitialized when accessed so that the modified Source
    ! Directory Search List will be used to select and open those files.
    !
    DBG$SRC_INIT();

    RETURN;

    END; 

ROUTINE DBG$SRC_CLOSE_FILE(SFCBPTR): NOVALUE =
!
! FUNCTION
!	This routine closes an open source file.  It accepts a Source File Con-
!	trol Block (SFCB) pointer as input, determines whether the correspond-
!	ing file is an RMS file or a module in a source library, and closes the
!	file.  It returns immediately if the SFCB is not in use.
!
! INPUTS
!	SFCBPTR - A pointer to the Source File Control Block for the source file
!		  to be closed.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	SFCBPTR: REF SFCB$BLOCK;	! Pointer to Source File Control Block

    LOCAL
	STATUS;				! Close status



    ! Close the file specified by the Source File Control Block pointer
    ! SFCBPTR.  Determine the kind of the SFCBPTR block and act accordingly.
    !
    CASE .SFCBPTR[SFCB$B_KIND] FROM SFCB$K_NOTUSED TO SFCB$K_LBRFILE OF
    	SET


    	! This Source File Control Block is not used.  Nothing needs to be done.
    	!
    	[SFCB$K_NOTUSED]:
    	    0;


    	! This Source File Control Block is for an open RMS source file.  Close
    	! RMS file.
    	!
    	[SFCB$K_RMSFILE]:
    	    BEGIN
    	    STATUS = $CLOSE(FAB = .SFCBPTR[SFCB$L_FABPTR]);
    	    IF NOT .STATUS THEN SIGNAL (.STATUS);
    	    END;


    	! This Source File Control Block is for a module in an open source
    	! library.  Close the source library.
    	!
    	[SFCB$K_LBRFILE]:
    	    BEGIN
    	    STATUS = LBR$CLOSE(SFCBPTR[SFCB$L_LBRINDEX]);
    	    IF NOT .STATUS THEN SIGNAL(.STATUS);
    	    END;

    	[INRANGE, OUTRANGE]:
    	    SIGNAL(DBG$_DEBUGBUG, 1, 197);

    	TES;


    ! The file is successfully closed.  Mark the Source File Control Block as
    ! being 'NOT USED' and return.
    !
    SFCBPTR[SFCB$B_KIND] = SFCB$K_NOTUSED;
    RETURN;

    END;

GLOBAL ROUTINE DBG$SRC_INIT: NOVALUE =
!
! FUNCTION
!	This routine initializes the Source File Control Blocks and associated
!	FABs and RABs needed by the Source Line Display feature to open and read
!	source files.  It also fixes the maximum number of source files DEBUG
!	will keep open at any one time.  It is called in two situations.  First,
!	it is called during DEBUG initialization to set up the initial chain of
!	Source File Control Blocks.  And second, it is called during the proc-
!	essing of the SET SOURCE and CANCEL SOURCE commands to reset the Source
!	Line Display feature; those commands can change the source file look-up
!	rules and thus affect whether the currently open files are the correct
!	files to use for source line display.
!
!	The routine starts by looping through all existing Source File Control
!	Blocks (SFCBs) and closing any associated open files.  It calls routine
!	DBG$SRC_CLOSE_FILE for each file to be closed.  It then releases all
!	SFCBs and associated FABs and RABs on the chain.  After that, it creates
!	a new list of SFCBs, again with associated FABs and RABs, and marks each
!	SFCB as being not used.  The number of SFCBs it creates, which is also
!	the maximum number of open source files henceforth, is specified by the
!	variable DBG$SRC_MAX_FILES.  This maximum number can thus be changed by
!	setting DBG$SRC_MAX_FILES appropriately and then calling DBG$SRC_INIT.
!
! INPUTS
!	NONE
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
	SFCB_BLINK: REF SFCB$BLOCK,	! Backward link to previous SFCB
	SFCB_FLINK: REF SFCB$BLOCK,	! Forward link to next SFCB
	SFCBPTR: REF SFCB$BLOCK;	! Pointer to the current Source File
					!      Control Block (SFCB)



    ! Make sure the number of new Source File Control Blocks is reasonable.
    !
    IF (.DBG$SRC_MAX_FILES LSS 1) OR (.DBG$SRC_MAX_FILES GTR MAX_MAX_FILES)
    THEN
	SIGNAL(DBG$_DEBUGBUG, 1, 195);


    ! Go through all current Source File Control Blocks and for each one, close
    ! the corresponding file, release the FAB, RAB, and other RMS blocks back to
    ! the memory pool, and then release the Source File Control Block itself.
    !
    SFCBPTR = .DBG$SRC_SFCB_PTR;
    SFCB_FLINK = 0;
    WHILE .SFCB_FLINK NEQ .DBG$SRC_SFCB_PTR DO
	BEGIN
	DBG$SRC_CLOSE_FILE(.SFCBPTR);
	DBG$REL_MEMORY(.SFCBPTR[SFCB$L_FABPTR]);
	DBG$REL_MEMORY(.SFCBPTR[SFCB$L_RABPTR]);
	DBG$REL_MEMORY(.SFCBPTR[SFCB$L_NAMPTR]);
	DBG$REL_MEMORY(.SFCBPTR[SFCB$L_XABDATPTR]);
	DBG$REL_MEMORY(.SFCBPTR[SFCB$L_XABFHCPTR]);
	DBG$REL_MEMORY(.SFCBPTR[SFCB$L_NAMBUFFER]);
    	DBG$REL_MEMORY(.SFCBPTR[SFCB$L_RFATBLPTR]);
	SFCB_FLINK = .SFCBPTR[SFCB$L_FLINK];
	DBG$REL_MEMORY(.SFCBPTR);
    	SFCBPTR = .SFCB_FLINK;
	END;


    ! Now loop DBG$SRC_MAX_FILES times to create that number of brand new Source
    ! File Control Blocks and the associated RMS blocks.
    !
    DBG$SRC_SFCB_PTR = 0;
    INCR I FROM 1 TO .DBG$SRC_MAX_FILES DO
	BEGIN


	! Allocate memory for the Source File Control Block and mark it as
	! being Not Used.
	!
	SFCBPTR = DBG$GET_MEMORY(SFCB$K_SIZE);
	SFCBPTR[SFCB$B_KIND] = SFCB$K_NOTUSED;


	! Now allocate memory blocks for all the RMS blocks we will need for
	! this source file.
	!
	SFCBPTR[SFCB$L_FABPTR] = DBG$GET_MEMORY(FAB$C_BLN/4);
	SFCBPTR[SFCB$L_RABPTR] = DBG$GET_MEMORY(RAB$C_BLN/4);
	SFCBPTR[SFCB$L_NAMPTR] = DBG$GET_MEMORY(NAM$C_BLN/4);
	SFCBPTR[SFCB$L_XABDATPTR] = DBG$GET_MEMORY(XAB$C_DATLEN/4);
	SFCBPTR[SFCB$L_XABFHCPTR] = DBG$GET_MEMORY(XAB$C_FHCLEN/4);
	SFCBPTR[SFCB$L_NAMBUFFER] = DBG$GET_MEMORY(2*NAMBUFSIZE/4);
    	SFCBPTR[SFCB$L_RFATBLPTR] = DBG$GET_MEMORY(RFATBL_SIZE/4);
    	SFCBPTR[SFCB$W_RFASPACING] = INIT_RFATBL_SPACING;
    	SFCBPTR[SFCB$W_RFACURLEN] = 0;


	! If this is the first new block, make DBG$SRC_SFCB_PTR point to it and
	! doubly link it to itself.
	!
	IF .DBG$SRC_SFCB_PTR EQL 0
	THEN
	    BEGIN
	    SFCBPTR[SFCB$L_FLINK] = .SFCBPTR;
	    SFCBPTR[SFCB$L_BLINK] = .SFCBPTR;
	    DBG$SRC_SFCB_PTR = .SFCBPTR;
	    END


	! Otherwise, link this block into the end of the already existing doubly
	! linked list of Source File Control Blocks.
	!
	ELSE
	    BEGIN
	    SFCB_FLINK = .DBG$SRC_SFCB_PTR;
	    SFCB_BLINK = .SFCB_FLINK[SFCB$L_BLINK];
	    SFCBPTR[SFCB$L_FLINK] = .SFCB_FLINK;
	    SFCBPTR[SFCB$L_BLINK] = .SFCB_BLINK;
	    SFCB_FLINK[SFCB$L_BLINK] = .SFCBPTR;
	    SFCB_BLINK[SFCB$L_FLINK] = .SFCBPTR;
	    END;

	END;


    ! The Source File Control Block initialization is all done--now return.
    !
    RETURN;

    END;

ROUTINE DBG$SRC_OPEN(SFCB_KIND,SRCDSTPTR,PROPER_FLAG) =
!
! FUNCTION
!	This routine is called by DBG$SRC_OPEN_FILE.  It actually does the 
!	open for RMS or LBR file.
!
!	The opened file is then checked to see if it is the right file.  This 
!	consists of checking the Revision Date and Time and several other file 
!	attributes.  If this search fails to find the desired file, the proper 
!	flag is set to indicate the status.  If file could not be open at all,
!	then the returned status from RMS routines is returned.
!
!	If the desired file is a module within a source library, then checking
!	is modified to check the library in the given directory which has a
!	module of the desired name which in turn has the proper insertion date.
!	If this checking fails to find the desired module in the library,
!	the proper flag is set to indicate the proper module is not found.
!	If no library at all could be opened, then status from LBR is returned.
!
! INPUTS
!	SFCB_KIND - Indictates whether the file to be opened is an RMS file
!		    (SFCB_KIND = 2) or an LBR file (SFCB_KIND = 3). 
!
!	SRCDSTPTR - Pointer to the Declare Source File DST command which declares
!		    the file to be opened.
!
! OUTPUTS
!	PROPER_FLAG - 0: Proper file is found,
!		      non-0: file or module in the library is not proper file.
!
!		      The "proper" is defined as the first version with the
!		      same creation date and time, the same file size, and
!		      the same record format and file organization as specified
!		      in the Source File Correlation DST Record.  The "proper"
!		      file is found means such file is found during the search
!		      directory dir1, ..., dirN process.  If the "proper"
!		      version of the file is not found in any of dir1, ..., dirN,
!		      the latest version of the file in the first directory on
!		      the list to have a version of it is used.  A warning is
!		      issued.  If no file can be found at all, a warning
!		      message to this effect is issued.
!
!	STATUS - returned value from RMS or LBR, return value for this routine.
!

    BEGIN

    MAP
    	PROPER_FLAG: REF VECTOR[1],	! Flag set to indicate the status of 
    					!	the opened file
    	SRCDSTPTR: REF DST$SRC_COMMAND;	! Pointer to the Declare Source File
    					!	DST command


    LOCAL
    	BUFDESC: BLOCK[8,BYTE],		! String descriptor, it contains length
    					!	and address of the buffer
    	BUFLEN,				! Contains the length of the returned
    					!	module header
    	DSTRDT: REF VECTOR[2],		! Pointer to the revision date and time
    					!	in the DST Declare Source File
    					!	command
    	LIBMOD_PTR: REF DST$SRC_CMDTRLR,! Points to the Source Library Module
    					!	name in the Source File
    					!	Correlation DST Record
    	MHDPTR: REF BLOCK[,BYTE],	! Points to Module Header
    	MODPTR: BLOCK[8,BYTE],		! Length and address of module name
    	SRCXABDAT: REF $XABDAT_DECL,	! XABDAT for RMS file
    	SRCXABFHC: REF $XABFHC_DECL,	! XABFHC for RMS file
    	STATUS,				! RMS status or LBR status
    	TXTRFA: VECTOR[2],		! The RFA of the module text in library
    	XABRDT: REF VECTOR[2];		! Pointer to the revision date and time
    					!	in the RMS XAB block



    ! Determine whether we have an RMS or LBR file.
    !
    PROPER_FLAG[0] = 0;
    CASE .SFCB_KIND FROM SFCB$K_RMSFILE TO SFCB$K_LBRFILE OF
    	SET


    	! Open an RMS source file and check its attributes to see if this is
    	! the exact file the DST Declaresource File Command Specifies.
    	!
    	[SFCB$K_RMSFILE]:
    	    BEGIN


    	    ! Open the file and connect the RAB to the FAB.
    	    !
    	    STATUS = $OPEN(FAB = .DBG$SRC_SFCB_PTR[SFCB$L_FABPTR]);
    	    IF NOT .STATUS THEN RETURN .STATUS;
    	    STATUS = $CONNECT(RAB = .DBG$SRC_SFCB_PTR[SFCB$L_RABPTR]);
    	    IF NOT .STATUS THEN RETURN .STATUS;


    	    ! Check that the file has the proper resivion date and time.
    	    ! If not, set PROPER_FLAG to 1.
    	    !
    	    SRCXABDAT = .DBG$SRC_SFCB_PTR[SFCB$L_XABDATPTR];
    	    SRCXABFHC = .DBG$SRC_SFCB_PTR[SFCB$L_XABFHCPTR];
    	    XABRDT = SRCXABDAT[XAB$Q_RDT];
    	    DSTRDT = SRCDSTPTR[DST$Q_SRC_DF_RMS_RDT];
    	    IF .XABRDT[0] NEQ .DSTRDT[0] THEN PROPER_FLAG[0] = 1;
    	    IF .XABRDT[1] NEQ .DSTRDT[1] THEN PROPER_FLAG[0] = 1;


    	    ! Also check that the file's byte size and record format and file
    	    ! organization is as specified in the DST.  If not, set PROPER_FLAG
    	    ! to 2, 3, or 4.
    	    !
    	    IF .SRCXABFHC[XAB$L_EBK] NEQ .SRCDSTPTR[DST$L_SRC_DF_RMS_EBK]
    	    THEN
    		PROPER_FLAG[0] = 2;

    	    IF .SRCXABFHC[XAB$W_FFB] NEQ .SRCDSTPTR[DST$W_SRC_DF_RMS_FFB]
    	    THEN
    		PROPER_FLAG[0] = 3;

    	    IF .SRCXABFHC[XAB$B_RFO] NEQ .SRCDSTPTR[DST$B_SRC_DF_RMS_RFO]
    	    THEN
    		PROPER_FLAG[0] = 4;

    	    END;


    	! Open an Source Library File.  Then look up and open the desired
    	! module within that source library.  Also compare the module's
    	! inseration date and time with that in the DST Declare Source
    	! File command.
    	!
    	[SFCB$K_LBRFILE]:
    	    BEGIN


    	    ! Open the desired source library.
    	    !
    	    STATUS = LBR$INI_CONTROL(DBG$SRC_SFCB_PTR[SFCB$L_LBRINDEX],
		UPLIT(LBR$C_READ), UPLIT(LBR$C_TYP_TXT), .DBG$SRC_SFCB_PTR[SFCB$L_NAMPTR]);
    	    IF NOT .STATUS THEN RETURN .STATUS;
    	    STATUS = LBR$OPEN(DBG$SRC_SFCB_PTR[SFCB$L_LBRINDEX]);
    	    IF NOT .STATUS THEN RETURN .STATUS;


    	    ! Look up the desired module and open the module header.
    	    !
    	    LIBMOD_PTR 
    		= SRCDSTPTR[DST$A_SRC_DF_FILENAME] + .SRCDSTPTR[DST$B_SRC_DF_FILENAME];
    	    MODPTR[DSC$W_LENGTH] = .LIBMOD_PTR[DST$B_SRC_DF_LIBMODNAME];
    	    MODPTR[DSC$A_POINTER] = LIBMOD_PTR[DST$A_SRC_DF_LIBMODNAME];
    	    STATUS = LBR$LOOKUP_KEY(DBG$SRC_SFCB_PTR[SFCB$L_LBRINDEX],MODPTR,TXTRFA);
    	    IF NOT .STATUS THEN RETURN .STATUS;


    	    ! Get module's header information.
    	    !
    	    BUFDESC[DSC$W_LENGTH] = SRCBUFSIZE;
    	    BUFDESC[DSC$A_POINTER] = DBG$SRC_REC_BUF[0];
    	    STATUS = LBR$SET_MODULE(DBG$SRC_SFCB_PTR[SFCB$L_LBRINDEX],TXTRFA,
    		BUFDESC,BUFLEN);
    	    IF NOT .STATUS THEN RETURN .STATUS;


    	    ! Save the module's start Record File Address (RFA) in the Source
    	    ! File Control Block.
    	    !
    	    DBG$SRC_SFCB_PTR[SFCB$L_CUR_RFA0] = .TXTRFA[0];
    	    DBG$SRC_SFCB_PTR[SFCB$W_CUR_RFA4] = .TXTRFA[1];
    	    

    	    ! Check the module insertion date and time.  If it is not the same
    	    ! as that in the DST Declare Source File Command, set PROPER_FLAG
    	    ! to 1.
    	    !
    	    MHDPTR = DBG$SRC_REC_BUF[0];
    	    XABRDT = MHDPTR[MHD$L_DATIM];
    	    DSTRDT = SRCDSTPTR[DST$Q_SRC_DF_RMS_RDT];
    	    IF .DSTRDT[0] NEQ .XABRDT[0] THEN PROPER_FLAG[0] = 1;
    	    IF .DSTRDT[1] NEQ .XABRDT[1] THEN PROPER_FLAG[0] = 1;
    	    END;

    	[INRANGE, OUTRANGE]:
    	    SIGNAL(DBG$_DEBUGBUG, 1, 197);

    	TES;


    ! The source file or module was successfully opened although the file
    ! attributes (date and time, etc.) may not have matched those in the
    ! DST.  Return the last status we got from RMS or LBR.
    !
    RETURN .STATUS;

    END;


ROUTINE DBG$SRC_OPEN_FILE(FILDSTPTR, SFCBPTR): NOVALUE =
!
! FUNCTION
!	This routine opens a specified source file (unless the file is already
!	opened) and sets up the corresponding Source File Control Block so that
!	the file can be read with subsequent calls on DBG$SRC_READ_FILE.  In the
!	process, it applies all source directory search rules to make sure it
!	opens the file in the directory desired by the user.
!
!	The routine starts by searching the list of Source File Control Blocks
!	for the input DST pointer.  If such a control block is found, the file
!	is already open and the Source File Control Block (SFCB) pointer can be
!	returned immediately.  The SFCB is moved to the Most Recently Used posi-
!	tion in the doubly linked SFCB list before DBG$SRC_OPEN_FILE returns.
!
!	Otherwise, an SFCB must be allocated for this file.  This is done by
!	finding the Least Recently Used SFCB and closing the file using that
!	control block (if any).  The SFCB is then moved to the Most Recently
!	Used position.  Next, the Source Directory Search List for the current
!	module (which may be the default search list) is found in the linked
!	list pointed to by DBG$SRC_DIR_LIST.
!
!	At this point, the routine is ready to search all directories on the
!	list to locate the desired source file.  For each directory, it does
!	a $PARSE and loops over a $SEARCH system service.  Each file found by
!	$SEARCH is checked to see if it is the right file.  This consists of
!	checking the Revision Date and Time and several other file attributes.
!	If this search fails to find the desired file, the first file returned
!	by $SEARCH for the first directory on the list is used even though its
!	date and time or other attributes may be wrong.  An informational
!	message is signalled in this case.  If no file at all could be found,
!	an error message to that effect is signalled.
!
!	If the desired file is a module within a source library, the search is
!	modified to find the first library in the directory list which has a
!	module of the desired name which in turn has the proper insertion date.
!
!	If no Source Directory Search List was specified for this module (either
!	directly or by default), the file name as it appears in the Declare
!	Source File DST command is taken to be the file we want to open.
!
!	Once the desired file has been identified, that file is opened via the
!	RMS $OPEN and $CONNECT services.  Or, if the source file is a module in
!	a source library, the library and its module are opened via the appro-
!	priate LIBRARIAN (LBR$xxx) calls.  DBG$SRC_OPEN_FILE then returns.
!
!	The routine actually does the open and verify the attributes is in
!	"DBG$SRC_OPEN".
!
! INPUTS
!	FILDSTPTR - A pointer to the Declare Source File command in the Source
!		  File Correlation DST Record which declares the source file to
!		  be opened.  This command includes the desired file name and
!		  other file attributes.
!
!	SFCBPTR - A longword location to receive a pointer to the Source File
!		  Control Block set up for the desired file.
!
! OUTPUTS
!	SFCBPTR - A Pointer to the Source File Control Block set up for the
!		  opened source file is returned to SFCBPTR.  This pointer
!		  can then be used when later calling DBG$SRC_READ_FILE.
!

    BEGIN

    MAP
	FILDSTPTR:			! Pointer to the Declare Source File DST
		REF DST$SRC_COMMAND,	!      command which declares the file
					!      to be opened
	SFCBPTR: REF VECTOR[1];		! Pointer to longword to receive the
					!      Source File Control Block pointer

    LOCAL
    	BLINK: REF SFCB$BLOCK,		! Backward link
    	DEFAULT: VECTOR[SRCBUFSIZE,BYTE],	! Contains Default File Name 
    						!	length and filename for RMS
    	FIRST_FILE: VECTOR[SRCBUFSIZE,BYTE],	! Contains first file returned FROM
    						!	$SEARCH the directory list
    	FIRST_TIME,			! Flag set to indicate first time $SEARCH
    	FLINK: REF SFCB$BLOCK,		! Forward link
    	LIBMOD_PTR: REF DST$SRC_CMDTRLR,! Trailer field in the Declare
    					!	Source File Command
    	LRUPTR: REF SFCB$BLOCK,		! Pointer to Least Recently Used Source
    					!	File Control Block
    	PROPER_FLAG,			! Flag set to indicate proper file/module
    					!	 is used
    	SDSL_PTR: REF SDSL$HEADER,	! Pointer to Source Directory Search
    					!	List Header Block
    	SDSL_DIRPTR: REF SDSL$ENTRY,	! Pointer to Source Directory Search
    					!	List Entry
    	SFCB_KIND,			! Indicate SFCB used for RMS file or
    					!	Source Library file
    	SRCFAB: REF $FAB_DECL,		! FAB for RMS file
    	SRCNAM: REF $NAM_DECL,		! NAM for RMS file
    	STATUS;				! RMS routine status



    ! Check to see if the given file is the Most Recently Used file.  If it
    ! is, simply return.  There is no need to reorder the SFCB list.
    !
    IF (.DBG$SRC_SFCB_PTR[SFCB$B_KIND] NEQ SFCB$K_NOTUSED) AND
    	(.DBG$SRC_SFCB_PTR[SFCB$L_DSTPTR] EQL .FILDSTPTR)
    THEN
        BEGIN
    	SFCBPTR[0] = .DBG$SRC_SFCB_PTR;
    	RETURN;
    	END;


    ! Start at the location pointed to by DBG$SRC_SFCB_PTR and circle thru the
    ! doubly linked list SFCB to see if the desired file is already on the
    ! list.  If it is already on the list, move it's Source File Control Block
    ! to the Most Recently Used position (which is pointed to by DBG$SRC_SFCB_PTR)
    ! and then return.
    !
    LRUPTR = .DBG$SRC_SFCB_PTR[SFCB$L_BLINK];
    WHILE .LRUPTR NEQ .DBG$SRC_SFCB_PTR DO
    	BEGIN
        IF (.LRUPTR[SFCB$B_KIND] NEQ SFCB$K_NOTUSED) AND
    	    (.LRUPTR[SFCB$L_DSTPTR] EQL .FILDSTPTR)
    	THEN
    	    BEGIN


    	    ! The file already has a Source File Control Block.  Unlink it
    	    ! from the SFCB List.
    	    !
    	    BLINK = .LRUPTR[SFCB$L_BLINK];
    	    FLINK = .LRUPTR[SFCB$L_FLINK];
    	    BLINK[SFCB$L_FLINK] = .FLINK;
    	    FLINK[SFCB$L_BLINK] = .BLINK;


    	    ! Insert the SFCB at the Most Recently Used position.  Then return
    	    ! its address to the caller.
    	    !
    	    BLINK = .DBG$SRC_SFCB_PTR[SFCB$L_BLINK];
    	    LRUPTR[SFCB$L_FLINK] = .DBG$SRC_SFCB_PTR;
    	    LRUPTR[SFCB$L_BLINK] = .BLINK;
    	    BLINK[SFCB$L_FLINK] = .LRUPTR;
    	    DBG$SRC_SFCB_PTR[SFCB$L_BLINK] = .LRUPTR;
    	    DBG$SRC_SFCB_PTR = .LRUPTR;
    	    SFCBPTR[0] = .DBG$SRC_SFCB_PTR;
    	    RETURN;
    	    END;

    	LRUPTR = .LRUPTR[SFCB$L_BLINK];
    	END;


    ! We have circled the whole doubly linked list (the given file is not
    ! already on the list).  Advance the pointer to take the Least Recently
    ! Used SFCB and close the file using that control block (if any). 
    ! 
    DBG$SRC_SFCB_PTR = .DBG$SRC_SFCB_PTR[SFCB$L_BLINK];
    IF .DBG$SRC_SFCB_PTR[SFCB$B_KIND] NEQ SFCB$K_NOTUSED
    THEN
    	DBG$SRC_CLOSE_FILE(.DBG$SRC_SFCB_PTR);

    
    ! Determine whether the desired file is an RMS or LBR file.
    !
    LIBMOD_PTR = 
    	FILDSTPTR[DST$A_SRC_DF_FILENAME] + .FILDSTPTR[DST$B_SRC_DF_FILENAME];
    IF .LIBMOD_PTR[DST$B_SRC_DF_LIBMODNAME] EQL 0
    THEN
    	SFCB_KIND = SFCB$K_RMSFILE
    ELSE
    	SFCB_KIND = SFCB$K_LBRFILE;


    ! Initialize RMS source file control block.
    ! 
    $FAB_INIT(FAB = .DBG$SRC_SFCB_PTR[SFCB$L_FABPTR],
    		    FAC = <GET>,
		    FOP = <NAM>,
		    NAM = .DBG$SRC_SFCB_PTR[SFCB$L_NAMPTR],
		    XAB = .DBG$SRC_SFCB_PTR[SFCB$L_XABDATPTR]);
    $RAB_INIT(RAB = .DBG$SRC_SFCB_PTR[SFCB$L_RABPTR],
		    FAB = .DBG$SRC_SFCB_PTR[SFCB$L_FABPTR],
		    UBF = DBG$SRC_REC_BUF[0],
		    USZ = MIN(SRCBUFSIZE,255));
    $NAM_INIT(NAM = .DBG$SRC_SFCB_PTR[SFCB$L_NAMPTR],
		    ESA = .DBG$SRC_SFCB_PTR[SFCB$L_NAMBUFFER],
		    ESS = MIN(NAMBUFSIZE,255),
		    RSA = .DBG$SRC_SFCB_PTR[SFCB$L_NAMBUFFER] + NAMBUFSIZE,
		    RSS = MIN(NAMBUFSIZE,255));
    $XABDAT_INIT(XAB = .DBG$SRC_SFCB_PTR[SFCB$L_XABDATPTR],
		    NXT = .DBG$SRC_SFCB_PTR[SFCB$L_XABFHCPTR]);
    $XABFHC_INIT(XAB = .DBG$SRC_SFCB_PTR[SFCB$L_XABFHCPTR]);
    SRCFAB = .DBG$SRC_SFCB_PTR[SFCB$L_FABPTR];
    SRCNAM = .DBG$SRC_SFCB_PTR[SFCB$L_NAMPTR];
    PROPER_FLAG = 0;


    ! Set up default file name to be the same as that in the Source File
    ! Correlation DST Record except that we change the version number to '*'.
    !
    DEFAULT[0] = .FILDSTPTR[DST$B_SRC_DF_FILENAME];
    CH$MOVE(.DEFAULT[0],FILDSTPTR[DST$A_SRC_DF_FILENAME],DEFAULT[1]);
    DECR I FROM .DEFAULT[0] TO 1 DO
    	BEGIN
    	IF .DEFAULT[.I] EQL ';'
    	THEN
    	    BEGIN
    	    DEFAULT[.I + 1] = '*';
    	    DEFAULT[0] = .I + 1;
    	    EXITLOOP;
    	    END;
    	END;

    SRCFAB[FAB$L_DNA] = DEFAULT[1];
    SRCFAB[FAB$B_DNS] = .DEFAULT[0];


    ! Search the Source Directory Search List so we can open the given file in
    ! the proper directory.  Search all the Header Blocks for the Module RST 
    ! Entry pointer for the current module.  If the desired module is not found,
    ! the Header Block with the zero Module RST Entry pointer is used.
    !
    SDSL_DIRPTR = 0;
    SDSL_PTR = .DBG$SRC_DIR_LIST;
    WHILE .SDSL_PTR NEQ 0 DO
    	BEGIN
    	IF .SDSL_PTR[SDSL$L_MODPTR] EQL .DBG$SRC_MODRSTPTR
    	THEN
    	    BEGIN
    	    SDSL_DIRPTR = .SDSL_PTR[SDSL$L_LIST_PTR];
    	    IF .SDSL_DIRPTR EQL 0 THEN SIGNAL(DBG$_DEBUGBUG, 1, 195);
    	    EXITLOOP;
    	    END;

    	IF .SDSL_PTR[SDSL$L_MODPTR] EQL 0 
    	THEN
    	    BEGIN
    	    SDSL_DIRPTR = .SDSL_PTR[SDSL$L_LIST_PTR];
    	    IF .SDSL_DIRPTR EQL 0 THEN SIGNAL(DBG$_DEBUGBUG, 1, 195);
    	    END;

    	SDSL_PTR = .SDSL_PTR[SDSL$L_FLINK];
    	END;


    ! If no Source Directory Search List entry is present, the file name from
    ! the Declare Source File DST command is used as is.  We thus open the
    ! file and if this succeeds, return to the caller.
    !
    IF .SDSL_DIRPTR EQL 0
    THEN
    	BEGIN


    	! Set up the exact DST file name in the FAB.
    	!
    	SRCFAB[FAB$L_DNA] = 0;
    	SRCFAB[FAB$B_DNS] = 0;
	SRCFAB[FAB$L_FNA] = FILDSTPTR[DST$A_SRC_DF_FILENAME];
    	SRCFAB[FAB$B_FNS] = .FILDSTPTR[DST$B_SRC_DF_FILENAME];


    	! Do the $PARSE to initiate the $SEARCH loop.
    	!
    	STATUS = $PARSE(FAB = .SRCFAB);
    	IF NOT .STATUS
    	THEN
    	    SIGNAL(DBG$_UNAOPNSRC,2,.SRCNAM[NAM$B_ESL],.SRCNAM[NAM$L_ESA],.STATUS);


    	! Do $SEARCH to initate the NAME block.
    	!
    	STATUS = $SEARCH(FAB = .SRCFAB);
    	IF NOT .STATUS
    	THEN
    	    SIGNAL(DBG$_UNAOPNSRC,2,.SRCNAM[NAM$B_ESL],.SRCNAM[NAM$L_ESA],.STATUS);


    	! Open the file and check the status.
    	!
    	STATUS = DBG$SRC_OPEN(.SFCB_KIND,.FILDSTPTR,PROPER_FLAG);
    	IF NOT .STATUS
    	THEN
    	    SIGNAL(DBG$_UNAOPNSRC,2,.SRCNAM[NAM$B_ESL],.SRCNAM[NAM$L_ESA],.STATUS);


    	! Check to see if we got the exact version of the desired file.  If not,
    	! issue the warning message.
    	!
    	IF (.PROPER_FLAG NEQ 0) 
    	THEN
    	    SIGNAL(DBG$_NOTORIGSRC,2,.SRCNAM[NAM$B_RSL],.SRCNAM[NAM$L_RSA]);


    	! The open succeeded.  Fill in the source file control block and return
    	! to the caller.
    	!
    	DBG$SRC_SFCB_PTR[SFCB$B_KIND] = .SFCB_KIND;
    	DBG$SRC_SFCB_PTR[SFCB$L_DSTPTR] = .FILDSTPTR;
    	DBG$SRC_SFCB_PTR[SFCB$L_CURRECNUM] = 1;
    	DBG$SRC_SFCB_PTR[SFCB$W_RFASPACING] = INIT_RFATBL_SPACING;
    	DBG$SRC_SFCB_PTR[SFCB$W_RFACURLEN] = 0;
    	SFCBPTR[0] = .DBG$SRC_SFCB_PTR;
    	RETURN;
    	END;


    ! The found Header Block pointer then points to a list of directories.
    ! Search this list to find the desired file in one of the directories on
    ! that list.
    !
    FIRST_TIME = TRUE;
    WHILE .SDSL_DIRPTR NEQ 0 DO
        BEGIN


    	! Make the current directory name the primary file name in the FAB.
    	! Then do the $PARSE to initiate the $SEARCH loop.
    	!
    	SRCFAB[FAB$L_FNA] = SDSL_DIRPTR[SDSL$A_ENT_DIRNAME];
   	SRCFAB[FAB$B_FNS] = .SDSL_DIRPTR[SDSL$B_ENT_DIRLEN];
    	STATUS = $PARSE(FAB = .SRCFAB);
    	IF NOT ((.STATUS EQL RMS$_DNF) OR (.STATUS))
    	THEN
    	    SIGNAL(DBG$_UNAOPNSRC,2,.SRCNAM[NAM$B_ESL],.SRCNAM[NAM$L_ESA],.STATUS);

    	IF .STATUS
    	THEN
    	    BEGIN


    	    ! Do wild-card processing by going through a $SEARCH loop.  For
    	    ! each file found by $SEARCH, we see if it is the file we want.
    	    !
    	    WHILE TRUE DO
    	        BEGIN


    		! Get the next file from $SEARCH.
    		!
    	        STATUS = $SEARCH(FAB = .SRCFAB);
    		IF (.STATUS EQL RMS$_FNF) OR (.STATUS EQL RMS$_NMF)
    		THEN 
    		    EXITLOOP;
    		IF NOT .STATUS
    		THEN
    		    SIGNAL(DBG$_UNAOPNSRC,2,.SRCNAM[NAM$B_ESL],.SRCNAM[NAM$L_ESA],
    			   .STATUS);


    		! Try to open that file and see if it is the exact file we
    		! want.  If we find the exact file we want, exit the search
    		! loop.
    		!
	        STATUS = DBG$SRC_OPEN(.SFCB_KIND,.FILDSTPTR,PROPER_FLAG);
    	    	IF NOT .STATUS 
    		THEN
    		    SIGNAL(DBG$_UNAOPNSRC,2,.SRCNAM[NAM$B_ESL],.SRCNAM[NAM$L_ESA],
    			   .STATUS);

	        IF .PROPER_FLAG EQL 0 THEN EXITLOOP;


    		! The first time we find any file with the right name, we remember
    		! that file's name even if it file characteristics are wrong.
    		!
	        IF .FIRST_TIME
	        THEN
    	            BEGIN
    		    FIRST_FILE[0] = .SRCFAB[FAB$B_FNS];
    	            CH$MOVE(.FIRST_FILE[0],.SRCFAB[FAB$L_FNA],FIRST_FILE[1]);
    	            FIRST_TIME = FALSE;
    	            END;


    		! It is not the right file - close it and loop for another file.
    		!
    		DBG$SRC_SFCB_PTR[SFCB$B_KIND] = .SFCB_KIND;
    	        DBG$SRC_CLOSE_FILE(.DBG$SRC_SFCB_PTR);

    	        END;		! End of $SEARCH WHILE loop.

    	    END;		! End of if on good $PARSE status.


    	! If we have not yot found the desired file, get the next Source
    	! Directory Search List Entry and loop to try it.
    	!
    	IF .STATUS AND (.PROPER_FLAG EQL 0) THEN EXITLOOP;
    	SDSL_DIRPTR = .SDSL_DIRPTR[SDSL$L_ENT_FLINK];
    	END;


    ! If no proper file is found, the first file for the first directory
    ! on the list is used, so try to open it again.
    !
    IF (.PROPER_FLAG NEQ 0) AND (NOT .FIRST_TIME)
    THEN
        BEGIN
    	SRCFAB[FAB$L_FNA] = FIRST_FILE[1];
    	SRCFAB[FAB$B_FNS] = .FIRST_FILE[0];
    	STATUS = $PARSE(FAB = .SRCFAB);
    	IF NOT .STATUS THEN SIGNAL(.STATUS);
    	STATUS = $SEARCH(FAB = .SRCFAB);
    	IF NOT .STATUS THEN SIGNAL(.STATUS);
    	STATUS = DBG$SRC_OPEN(.SFCB_KIND,.FILDSTPTR,PROPER_FLAG);
        IF NOT .STATUS THEN SIGNAL(.STATUS);
    	END;


    ! If the status returned from RMS is not 'no more files' or good status,
    ! signal the bad status.
    !
    IF NOT ((.STATUS EQL RMS$_NMF) OR (.STATUS))
    THEN
        SIGNAL(DBG$_UNAOPNSRC,2,.SRCNAM[NAM$B_ESL],.SRCNAM[NAM$L_ESA],.STATUS);


    ! Issue the warning message, if the exact file is not found.
    !
    IF (.PROPER_FLAG NEQ 0)
    THEN
    	SIGNAL(DBG$_NOTORIGSRC,2,.SRCNAM[NAM$B_RSL],.SRCNAM[NAM$L_RSA]);


    ! We have now successfully opened a source file in the search directory.
    ! Fill in the Source File Control Block and return.
    !
    DBG$SRC_SFCB_PTR[SFCB$B_KIND] = .SFCB_KIND;
    DBG$SRC_SFCB_PTR[SFCB$L_DSTPTR] = .FILDSTPTR;
    DBG$SRC_SFCB_PTR[SFCB$L_CURRECNUM] = 1;
    SFCBPTR[0] = .DBG$SRC_SFCB_PTR;
    RETURN;

    END;


ROUTINE DBG$SRC_OUTPUT_LINE(LINE_NUM, STMT_NUM, BUFPTR, BUFLEN): NOVALUE =
!
! FUNCTION
!	This routine formats and outputs one source line.  The actual text of
!	the source line is passed in as a parameter.  The line's line number and
!	statement number are also passed in.  This routine then formats the line
!	number and statement number in front of the line's text and outputs the
!	line.  The statement number is omitted if it is zero (as it will be for
!	most languages).  The output for lines 12, 123, 1234, 123456, 1234567,
!	12345.6, and 123.4 would look as follows:
!
!			    12: TEXT OF LINE 12
!			   123: TEXT OF LINE 123
!			  1234: TEXT OF LINE 1234
!			123456: TEXT OF LINE 123456
!			1234567: TEXT OF LINE 1234567
!			12345.6: TEXT OF LINE 12345, STATEMENT 6
!			 123.4: TEXT OF LINE 123, STATEMENT 4
!
!	Note that all lines line up unless the line number and statement number
!	require more that six characters.
!
!	This routine also folds long source lines when they would make the out-
!	put line exceed terminal width in length.  The following format is used:
!
!			   123: TEXT OF LINE 123, FIRST PART
!			     -: TEXT OF LINE 123, SECOND PART
!			     -: TEXT OF LINE 123, LAST PART
!
!	The string "-: " thus serves as a continuation marker.  Note that this
!	routine must expand tabs to spaces in the source text.
!
!	User can use the SET MARGIN Command to set the display window size of
!	the source text.  For example, if user gives SET MARGIN 10:40, user
! 	will see the source text from the 10th character to the 40th character
!	displayed on the terminal.  However, the window size is adjused by the
!	the length of the source record (after the expension of TABs), and the
!	terminal width set by the SET TERM/WIDTH = n Command.
!
!	The final output lines are printed using DBG$FAO_PUT in the normal way.
!
! INPUTS
!	LINE_NUM - The line number of the source line to be printed.
!
!	STMT_NUM - The statement number of the source line to be printed.
!		  If there is no statement number, STMT_NUM must be zero.
!
!	BUFPTR	- A pointer to a buffer which contains the ASCII text of the
!		  source line to be printed.
!
!	BUFLEN	- The length in characters of the source line pointed to by
!		  BUFPTR.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	BUFPTR: REF VECTOR[,BYTE];	! Pointer to the ASCII image to print

    BIND
    	SPACES = UPLIT BYTE (%ASCIC '        '): VECTOR[,BYTE];
    					! A vector of 8 spaces

    LOCAL
    	FST_LINE_FLAG,			! Flag set to indicate this output line
    					!	has a line number
    	BGNPTR: REF VECTOR[,BYTE],	! Pointer to the begin search tab position
    					!	in source text buffer
	BUFFER: VECTOR[140,BYTE],	! Output buffer for DBG$FAO_PUT
    	GAP,				! Distance between the begin pointer and
    					!	the tab position
    	LENGTH,				! Search tab range length
    	LEFT_MARGIN,			! Source Text left column
    	RIGHT_MARGIN,			! Source Text right column
    	TABCNT,				! Number of tab characters
    	TABLEN,				! Spaces needed for the TAB character
    	TAB_POSITION,			! Point to the tab character
    	TMPBUF: VECTOR[SRCBUFSIZE,BYTE],! Expanded source text buffer
    	TMPBUFPTR,			! Pointer to the Expanded source text buffer
    	TERM_WIDTH,			! Terminal size - 8
    	WINDOW_WIDTH;			! The size of the source text to be displayed



    ! Expand the TAB character to spaces in the buffer which contains the
    ! ASCII text of the source line.  Finally adjust the length of the original
    ! buffer length.
    !
    TMPBUFPTR = TMPBUF;
    BGNPTR = .BUFPTR;
    LENGTH = .BUFLEN;
    TABCNT = 0;
    WHILE TRUE DO
    	BEGIN


    	! Locate the 'TAB' character in the buffer.  Pointed to by BGNPTR as
    	! the start search position, LENGTH is the given search range.
    	!
    	TAB_POSITION = CH$FIND_CH(.LENGTH,.BGNPTR,%C'	');


    	! There is no TAB character can be found, move the source text from
    	! BGNPTR position to TMPBUFPTR position.  Then exit the serach TAB loop.
    	!
    	IF .TAB_POSITION EQL 0 
    	THEN
    	    BEGIN
    	    CH$MOVE(.LENGTH, .BGNPTR, .TMPBUFPTR);
    	    EXITLOOP;
    	    END;


    	! Count the number of the TAB characters in the source text.
    	!
    	TABCNT = .TABCNT + 1;


    	! Move the source text before the TAB from BGNPTR postion to TMPBUFPTR
    	! position.
    	!
    	GAP = .TAB_POSITION - .BGNPTR;
    	IF .GAP NEQ 0 THEN CH$MOVE(.GAP, .BGNPTR, .TMPBUFPTR);
    	TMPBUFPTR = .TMPBUFPTR + .GAP;


    	! Calculate the number of spaces, this TAB character should expand to.
    	! Then move that number of spaces to the TMPBUFPTR position.
    	!
        TABLEN = .SPACES[0] - ((.TMPBUFPTR - TMPBUF) MOD .SPACES[0]);
    	CH$MOVE(.TABLEN , SPACES[1], .TMPBUFPTR);
    	TMPBUFPTR = .TMPBUFPTR + .TABLEN;


    	! Update the source text record length by the number of spaces added.
    	! Adjust the search TAB range.  Skip the TAB charcter in the original
    	! source text buffer.
    	!
    	BUFLEN = .BUFLEN + .TABLEN;
    	LENGTH = .LENGTH - .GAP - 1;
    	IF .LENGTH EQL 0 THEN EXITLOOP;
    	BGNPTR = .TAB_POSITION + 1;
    	END;


    ! Expansion is all done.  Adjust the source record length by taking off the
    ! number of TABs encounted.
    !
    BUFLEN = .BUFLEN  - .TABCNT;


    ! Adjust the window margin by the length of the source text.
    !
    LEFT_MARGIN = MAX(1, .DBG$SRC_LEFT_MARGIN);
    RIGHT_MARGIN = MIN(.BUFLEN,.DBG$SRC_RIGHT_MARGIN);


    ! Check to see if the left margin is exceed the actual source text length.
    !
    IF .LEFT_MARGIN GTR .RIGHT_MARGIN
    THEN
    	WINDOW_WIDTH = 0
    ELSE
        WINDOW_WIDTH = .RIGHT_MARGIN - .LEFT_MARGIN + 1;

    TERM_WIDTH = .DBG$SRC_TERM_WIDTH - 8;


    ! Formats the line number and statement number, and outputs the line.
    ! Also folds long source lines when the output line exceed terminal width
    ! in length.
    !
    FST_LINE_FLAG = TRUE;
    TMPBUFPTR = TMPBUF + .LEFT_MARGIN - 1;
    WHILE TRUE DO
    	BEGIN

        ! Set up the output buffer for the print routine (i. e., DBG$FAO_PUT).
    	!
        DBG$CP_OUT_STR = BUFFER[1];
    	DBG$GL_BUF_SIZ = 0;


        ! Format the Line's line number for the first line to be outputed.  For
    	! the line exceed terminal width in length, the second line starts with
        ! '        -:'.
    	!
        IF .FST_LINE_FLAG
        THEN
      	    BEGIN
            IF .STMT_NUM EQL 0
    	    THEN
    	        BEGIN
    	        SELECTONE .LINE_NUM OF
    	            SET
    	            [1 TO 9]:
    		        DBG$FAO_PUT(BUFFER, UPLIT BYTE(%ASCIC '     '), 0);
    	            [10 TO 99]:
    		        DBG$FAO_PUT(BUFFER, UPLIT BYTE(%ASCIC '    '), 0);
    	            [100 TO 999]:
    		        DBG$FAO_PUT(BUFFER, UPLIT BYTE(%ASCIC '   '), 0);
    	            [1000 TO 9999]:
    		        DBG$FAO_PUT(BUFFER, UPLIT BYTE(%ASCIC '  '), 0);
    	            [10000 TO 99999]:
    		        DBG$FAO_PUT(BUFFER, UPLIT BYTE(%ASCIC ' '), 0);

    	            TES;
    
    	        END;

    	    DBG$FAO_PUT(BUFFER, UPLIT BYTE(%ASCIC '!UL: '), .LINE_NUM);
    	    FST_LINE_FLAG = FALSE;
     	    END

        ELSE
            DBG$FAO_PUT(BUFFER, UPLIT BYTE(%ASCIC '     -: '), 0);
	

        ! Output the corresponding source record.
        !
    	LENGTH = MIN(.WINDOW_WIDTH, .TERM_WIDTH);
        DBG$FAO_PUT(BUFFER, UPLIT BYTE(%ASCIC '!AD'), .LENGTH, .TMPBUFPTR);
        DBG$OUT_PUT(BUFFER);


    	! Check to see if any source text left to be displayed.
    	!
    	WINDOW_WIDTH = .WINDOW_WIDTH - .LENGTH;
    	IF .WINDOW_WIDTH LEQ 0 THEN EXITLOOP;
    	TMPBUFPTR = .TMPBUFPTR + .LENGTH;
    	END;

    RETURN;

    END;

ROUTINE DBG$SRC_READ_FILE(SFCBPTR, REC_NUM, BUFPTR, BUFLEN): NOVALUE =
!
! FUNCTION
!	This routine reads a specified source record from a specified source
!	file and returns the address and length of the read record.  This is
!	thus the routine which actually reads source lines from source files.
!
!	This routine assumes that the source file has already been opened by
!	DBG$SRC_OPEN_FILE.  It reads the source file via RMS or the LIBRARIAN
!	until the desired record number is reached.  The image corresponding
!	to that record number is then returned to the caller.
!
!	This routine also builds the Record File Address (RFA) Table for the
!	current source file as it reads.  This table can then be used on later
!	calls to position the file pointer directly at the desired line or on
!	a line shortly before the desired line.  The RFA table is obviously
!	used whenever available to take us closer to the desired line.  That
!	table is also expanded whenever we have to read past the last RFA in
!	the table.  In other words, no source line is read just to build up the
!	RFA Table, but whenever a source line must be scanned anyway to find a
!	desired source record, its RFA is recovered for use in the RFA Table.
!
! INPUTS
!	SFCBPTR	- A pointer to the Source File Control Block for the file to be
!		  read.  It is assumed that this control block has already been
!		  set up by routine DBG$SRC_OPEN_FILE.
!
!	REC_NUM	- The Record Number within the file of the source record to be
!		  read in.
!
!	BUFPTR	- A longword location to receive a pointer to the input buffer.
!
!	BUFLEN	- A longword location to receive the input line's length.
!
! OUTPUTS
!	BUFPTR	- A pointer to the buffer which contains the just read input
!		  line is returned to BUFPTR.
!
!	BUFLEN	- The length in characters of the just read input line is
!		  returned to BUFLEN.
!

    BEGIN

    MAP
	SFCBPTR: REF SFCB$BLOCK,	! Pointer to Source File Control Block
	BUFPTR: REF VECTOR[1],		! Pointer to a longword to receive the
					!      input line's buffer pointer
	BUFLEN: REF VECTOR[1];		! Pointer to a longword to receive the
					!      input line's length

    LOCAL
    	INPTR: BLOCK[8,BYTE],		! Length and string address for the user
    					!	-supplied buffer
    	OUTPTR: BLOCK[8,BYTE],		! Pointer to a string descriptor for the
    					!	actual record returned from LBR
    	SRCNAM: REF $NAM_DECL,		! NAME Block for RMS file
    	SRCRAB: REF $RAB_DECL,		! RAB for RMS file
    	STATUS,				! RAB and FIND status
    	TXTRFA: VECTOR[2],		! Pointer to RFA
    	RFA_TABLE : REF RFATBL$BLOCKVECTOR(RFATBL_ENTRIES),
    					! The RFA table for the file
    	RFATBL_SPACING;			! Number of source records per RFA
    					! table entry.


    ! Determine whether to read from an RMS file or a module in a source library.
    !
    SRCNAM = .SFCBPTR[SFCB$L_NAMPTR];
    CASE .SFCBPTR[SFCB$B_KIND] FROM SFCB$K_RMSFILE TO SFCB$K_LBRFILE OF
    	SET


        ! Read from an RMS source file.
    	!
    	[SFCB$K_RMSFILE]:
    	    BEGIN
    	    LOCAL
    		CLOSEST_TABLE_ENTRY;

    	    ! Set up the RAB pointer and RFA table.
    	    !
            SRCRAB = .SFCBPTR[SFCB$L_RABPTR];
    	    RFA_TABLE = .SFCBPTR[SFCB$L_RFATBLPTR];
    	    RFATBL_SPACING = .SFCBPTR[SFCB$W_RFASPACING];

    	    CLOSEST_TABLE_ENTRY = MIN(.SFCBPTR[SFCB$W_RFACURLEN],
    			(.REC_NUM-1)/.RFATBL_SPACING);

    	    ! If the Source File is newly opened, get the first records's file 
    	    ! address field and store it in RFA table.
    	    !
    	    IF .SFCBPTR[SFCB$L_CURRECNUM] EQL 1
    	    THEN
    		BEGIN
    		STATUS = $FIND(RAB = .SRCRAB);
    		IF NOT .STATUS THEN SIGNAL(.STATUS);
    		RFA_TABLE[0,RFATBL$L_RFA0] = .SRCRAB[RAB$L_RFA0];
    		RFA_TABLE[0,RFATBL$W_RFA4] = .SRCRAB[RAB$W_RFA4];
    		CLOSEST_TABLE_ENTRY = 0;
    		END;


    	    ! Find the RFA table entry that is closest to the desired record.
    	    ! (If we are already positioned at the desired record we
    	    ! skip this)
    	    !
    	    IF .REC_NUM NEQ .SFCBPTR[SFCB$L_CURRECNUM]
    	    THEN
    		BEGIN
    		SRCRAB[RAB$L_RFA0] = .RFA_TABLE[.CLOSEST_TABLE_ENTRY,
    			RFATBL$L_RFA0];
    		SRCRAB[RAB$W_RFA4] = .RFA_TABLE[.CLOSEST_TABLE_ENTRY,
    			RFATBL$W_RFA4];
    		SFCBPTR[SFCB$L_CURRECNUM] = 1 + (.CLOSEST_TABLE_ENTRY *
    			.RFATBL_SPACING);
    		SRCRAB[RAB$B_RAC] = RAB$C_RFA;
    		STATUS = $FIND(RAB = .SRCRAB);
    		IF NOT .STATUS THEN SIGNAL(.STATUS);
    		END;


    	    ! Sequentially read from the current record to the desired record 
    	    ! number.  Skip over records containing only <Form Feed>;
    	    ! do not count them toward the record count.
    	    !
    	    SRCRAB[RAB$B_RAC] = RAB$C_SEQ;
    	    INCR I FROM .SFCBPTR[SFCB$L_CURRECNUM]-1 TO .REC_NUM-1 DO
    	    	BEGIN
    		WHILE TRUE DO
    		    BEGIN
	    	    STATUS = $GET(RAB = .SRCRAB);
    	    	    IF NOT .STATUS
    		    THEN
    		        SIGNAL(DBG$_UNAREASRC,2,.SRCNAM[NAM$B_RSL],.SRCNAM[NAM$L_RSA],.STATUS);

    		    IF NOT ((.DBG$SRC_REC_BUF[0] EQL 12) AND
    		            (.SRCRAB[RAB$W_RSZ] EQL 1))
    		    THEN 
    		 	EXITLOOP;

    		    END;

    		IF .I MOD .RFATBL_SPACING EQL 0
    		    AND .I / .RFATBL_SPACING NEQ .CLOSEST_TABLE_ENTRY
    		THEN
    		    BEGIN ! update table
    		    ! first check whether the table is full
    		    IF .I / .RFATBL_SPACING GEQ RFATBL_ENTRIES
    		    THEN
    			BEGIN ! compact the table
    			RFATBL_SPACING = 2 * .RFATBL_SPACING;
    			SFCBPTR[SFCB$W_RFASPACING] = .RFATBL_SPACING;
    			INCR J FROM 0 TO RFATBL_ENTRIES-2 BY 2 DO
    			    BEGIN
    			    RFA_TABLE[.J/2,RFATBL$L_RFA0] =
    				.RFA_TABLE[.J,RFATBL$L_RFA0];
    			    RFA_TABLE[.J/2,RFATBL$W_RFA4] =
    				.RFA_TABLE[.J,RFATBL$W_RFA4];
    			    END;
    			END; ! compact the table

    		    SFCBPTR[SFCB$W_RFACURLEN] = .I/.RFATBL_SPACING;
    		
    		    IF .I MOD .RFATBL_SPACING EQL 0
    		    THEN
    			BEGIN
    			RFA_TABLE[.I/.RFATBL_SPACING,RFATBL$L_RFA0] =
    			    .SRCRAB[RAB$L_RFA0];
    			RFA_TABLE[.I/.RFATBL_SPACING,RFATBL$W_RFA4] =
    			    .SRCRAB[RAB$W_RFA4];
    			END;

    		    END; ! update the table

    	    	END; ! incr loop

    	    ! Update the current record number field in SFCB. Set up the buffer
    	    ! pointer and buffer length.
    	    !
    	    SFCBPTR[SFCB$L_CURRECNUM] = .REC_NUM + 1;
    	    BUFPTR[0] = .SRCRAB[RAB$L_RBF];
    	    BUFLEN[0] = .SRCRAB[RAB$W_RSZ];

    	    END; ! RMS file case alternative


    	! Read from a module in a Source Library File.
    	!
    	[SFCB$K_LBRFILE]:
    	    BEGIN


    	    ! If the current record number is beyond the desired record number,
    	    ! reset the current record to 1 and set the record file address to the
    	    ! beginning of the module.
    	    !
    	    IF .SFCBPTR[SFCB$L_CURRECNUM] GTR .REC_NUM
    	    THEN
    		BEGIN
    		TXTRFA[0] = .SFCBPTR[SFCB$L_CUR_RFA0];
    		TXTRFA[1] = .SFCBPTR[SFCB$W_CUR_RFA4];
    		SFCBPTR[SFCB$L_CURRECNUM] = 1;
    		STATUS = LBR$FIND(SFCBPTR[SFCB$L_LBRINDEX],TXTRFA);
    		IF NOT .STATUS THEN SIGNAL(.STATUS);	
    		END;


    	    ! Sequentially read from the current record to the desired record
    	    ! number. 
    	    !
    	    INPTR[DSC$W_LENGTH] = SRCBUFSIZE;
    	    INPTR[DSC$A_POINTER] = DBG$SRC_REC_BUF[0];
    	    OUTPTR[DSC$A_POINTER] = DBG$SRC_REC_BUF[0];
    	    INCR I FROM .SFCBPTR[SFCB$L_CURRECNUM] TO .REC_NUM DO
    		BEGIN
    		WHILE TRUE DO
    		    BEGIN
    		    STATUS = LBR$GET_RECORD(SFCBPTR[SFCB$L_LBRINDEX],INPTR,OUTPTR);
    	    	    IF NOT .STATUS
    		    THEN
    		        SIGNAL(DBG$_UNAREASRC,2,.SRCNAM[NAM$B_RSL],.SRCNAM[NAM$L_RSA],.STATUS);

    		    IF NOT ((.DBG$SRC_REC_BUF[0] EQL 12) AND
    		            (.OUTPTR[DSC$W_LENGTH] EQL 1))
    		    THEN
    		        EXITLOOP;

		    END;

    		END;


    	    ! Update the current record number field in SFCB.  Set up buffer
    	    ! pointer and buffer length.
    	    ! 
    	    SFCBPTR[SFCB$L_CURRECNUM] = .REC_NUM + 1;
    	    BUFPTR[0] = .OUTPTR[DSC$A_POINTER];
    	    BUFLEN[0] = .OUTPTR[DSC$W_LENGTH];

    	    END;

        [INRANGE, OUTRANGE]:
    	    SIGNAL(DBG$_DEBUGBUG, 1, 197);

    	TES;

    RETURN;

    END;

ROUTINE DBG$SRC_SEARCH(BUFPTR, BUFLEN): =
!
! FUNCTION
!	This rouitne actually performs the search.  This routine locates the
!	desired search string in the input buffer.  Lowercase letter is
!	translated to uppercase letter before the search is performed.
!	If there is a match, this routine returns TRUE, otherwise FALSE is
!	returned.  There are two ways of searching for the desired string.
!	One is to search the string that has the match, ie. SEARCH for "ABC",
! 	then "ABCXXX", or "XXXABC", or "XXABCXX" would be found.  The other
!	is to search the string that has the exact match, ie. the right and
!	left character surround the search string "ABC" can not be one of the
!	valid identifier characters depending on the language.
!
! INPUT
!	BUFPTR - A pointer to a buffer which contains the ASCII text of the
!	       source line to be printed.
!
!	BUFLEN - The length in characters of the source line pointed to by
!	       BUFPTR.
!
! OUTPUT
!	This routine has a return value to indicate whether the desired
!	match string is found or not found.
!
    BEGIN

    MAP
    	BUFPTR: REF VECTOR[,BYTE];	! Pointer to the ASCII image to print

    OWN
    	TRTBL: VECTOR[128,WORD]		! Translation Table.
    	PRESET(				! This table serves as a way of checking
    	  ['A'] = %X'FF',		!	valid identifier character for
    	  ['B'] = %X'FF',		!	differnt language.  Identifier
    	  ['C'] = %X'FF',		!	character is used as the index to
    	  ['D'] = %X'FF',		!	the table.  The indexes of the 
    	  ['E'] = %X'FF',		!	table are 128 ASCII characters.
    	  ['F'] = %X'FF',		!	The values contained in the
    	  ['G'] = %X'FF',		!	table are used as mask values.
    	  ['H'] = %X'FF',		!	ie., CHAR is the identifier
    	  ['I'] = %X'FF',		!	character, .TRTBL[.CHAR] AND
    	  ['J'] = %X'FF',		!	language mask value = TRUE ==>
    	  ['K'] = %X'FF',		!	CHAR is an identifer character
    	  ['L'] = %X'FF',
    	  ['M'] = %X'FF',
    	  ['N'] = %X'FF',
    	  ['O'] = %X'FF',
    	  ['P'] = %X'FF',
    	  ['Q'] = %X'FF',
    	  ['R'] = %X'FF',
    	  ['S'] = %X'FF',
    	  ['T'] = %X'FF',
    	  ['U'] = %X'FF',
    	  ['V'] = %X'FF',
    	  ['W'] = %X'FF',
    	  ['X'] = %X'FF',
    	  ['Y'] = %X'FF',		! A - Z are common identifier characters
    	  ['Z'] = %X'FF',		! 	for all languages
    	  ['0'] = %X'FF',
    	  ['1'] = %X'FF',
    	  ['2'] = %X'FF',
    	  ['3'] = %X'FF',
    	  ['4'] = %X'FF',
    	  ['5'] = %X'FF',
    	  ['6'] = %X'FF',
    	  ['7'] = %X'FF',
    	  ['8'] = %X'FF',		! 0 - 9 are common identifier characters
    	  ['9'] = %X'FF',		! 	for all languages
    	  ['_'] = %X'FF',		! _ is common identifier character for
    					! 	all languages
    	  ['$'] = %X'FF',		! $ is common identifier character for
    					!	all languages
    	  ['-'] = 1 ^ DBG$K_COBOL,	! - is valid identifier character for
    					!	COBOL
    	  ['.'] = 1 ^ DBG$K_BASIC OR	! . is valid identifier character for
    		  1 ^ DBG$K_MACRO,	!	BASIC and MACRO
    	  ['%'] = 1 ^ DBG$K_BASIC);	! % is valid identifier character for
    					!	BASIC

    LOCAL
    	CHAR,				! Serve as an index character index
    					!	into the Translate Table
    	DES_STR: BLOCK[8,BYTE],		! Address of destination string
    					!	descriptor
    	SRC_STR: BLOCK[8,BYTE],		! Address of source string descriptor
    	STATUS,				! Return status from System routines
    	TMPBUF: VECTOR[SRCBUFSIZE,BYTE],! Tempory buffer which holds all the
    					!	letters in uppercase
    	TMPLEN,				! Remaining size of tempory buffer
    	TMPPTR;				! Pointer to the tempory buffer


    ! Translate all lowercase letters to uppercase via STR$UPCASE.  Before
    ! the call, build string descriptors for STR$UPCASE as passing parameters.
    ! Array descriptor, character-coded text.
    !
    DES_STR[DSC$B_CLASS] = DSC$K_CLASS_S;
    DES_STR[DSC$B_DTYPE] = DSC$K_DTYPE_T;
    DES_STR[DSC$W_LENGTH] = .BUFLEN;
    DES_STR[DSC$A_POINTER] = TMPBUF;
    SRC_STR[DSC$B_CLASS] = DSC$K_CLASS_S;
    SRC_STR[DSC$B_DTYPE] = DSC$K_DTYPE_T;
    SRC_STR[DSC$W_LENGTH] = .BUFLEN;
    SRC_STR[DSC$A_POINTER] = .BUFPTR;
    STATUS = STR$UPCASE(DES_STR,SRC_STR);


    ! Search for the desired string in the tempory buffer.  If the desired
    ! string is not found, return FALSE.  If the desired string is found
    ! and search qualifier is SEARCH, return TRUE.  If the desired
    ! string is found and search qualifier is IDENTIFIER, then the left
    ! and right characters of the desired string are checked.  If the
    ! desired string is identifier, return TRUE.  Otherwise search goes
    ! on till reaching to end of the buffer.
    !
    TMPLEN = .BUFLEN;
    TMPPTR = TMPBUF;
    STATUS = TRUE;
    WHILE TRUE DO
    	BEGIN
    	TMPPTR = CH$FIND_SUB(.TMPLEN, .TMPPTR, .DBG$SRC_SEARCH_STRING[0], 
    	   	 DBG$SRC_SEARCH_STRING[1]);


        ! Check to see if the matched string is found.  If such string is not
    	! found, return the status.  
        !
    	IF .TMPPTR EQL 0
        THEN
    	    BEGIN
      	    STATUS = FALSE;
    	    EXITLOOP;
    	    END;


        ! Check to see if the exact match option /IDENT is used.  If it is, goes on
    	! with more checking.  Otherwise, we are all done.
    	!
        IF (.DBG$SRC_SEARCH_FLAG EQL SEARCH_STRING_ALL) OR
           (.DBG$SRC_SEARCH_FLAG EQL SEARCH_STRING_NEXT)
        THEN
            BEGIN
    	    STATUS = TRUE;
    	    EXITLOOP;
    	    END;


    	! Check to see if the surrounding characters of the pattern string in the
        ! context string are one of the valid identifers for the given language.
    	! If the pattern string is found in the context, TMPPTR contains a
        ! character pointer to the first position of the sequence.  So pointer
    	! value - 1 points to the left surrounding character, pointer + the pattern
    	! string length points to the right surrounding character.   Check to see
    	! if these two characters are one of the valid identifer characters for
        ! the given language against the Translate Table.  First, make sure there
    	! is a left hand side character, if there is no such character, search is
        ! valid.
    	!
        IF .TMPPTR NEQ TMPBUF
        THEN
    	    BEGIN
            CHAR = (.TMPPTR - 1) - TMPBUF;


            ! If the match value is zero, that means we have a non_identifier character
    	    ! on the left, go on to check the character on the right.  Otherwise, this
    	    ! is not an exact match, set FALSE to declare tempory failure.
    	    !
    	    IF (.TRTBL[.TMPBUF[.CHAR]] AND (1 ^ .DBG$GB_LANGUAGE)) NEQ 0
    	    THEN
    	        STATUS = FALSE
    	    ELSE
    		STATUS = TRUE;

    	    END;


        ! Check the right hand side character.  First make sure there is a right
    	! hand side character.
    	!
    	TMPPTR = .TMPPTR + .DBG$SRC_SEARCH_STRING[0];
    	IF .TMPPTR GEQ (TMPBUF + .BUFLEN) THEN EXITLOOP;
        IF (.TMPPTR LEQ (TMPBUF + .BUFLEN)) AND .STATUS
        THEN
    	    BEGIN
    	    CHAR = .TMPPTR - TMPBUF;
	    IF (.TRTBL[.TMPBUF[.CHAR]] AND (1 ^ .DBG$GB_LANGUAGE)) NEQ 0
   	    THEN
    	        STATUS = FALSE
    	    ELSE
    	        STATUS = TRUE;

    	    END;


        ! We have found the desired match, return good status to the caller.
    	!
    	IF .STATUS THEN EXITLOOP;
    	TMPLEN = TMPBUF + .BUFLEN - .TMPPTR;
    	IF .TMPLEN LEQ 0 THEN EXITLOOP;

    	END;		! End of WHILE loop.

    RETURN .STATUS;

    END;

GLOBAL ROUTINE DBG$SRC_SEARCH_CMD(MODRSTPTR, LOW_LNUM, LOW_STMT,
    				  HIGH_LNUM, HIGH_STMT,
    				  SEARCH_BY_STRING_FLAG, SEARCH_NEXT_FLAG): NOVALUE =
!
! FUNCTION
!	This routine accepts a Module RST Entry pointer, a line number range,
!	and flags set to indicate the options are used in SEARCH command.
!	The options for the SEARCH command are SEARCH by IDENTIFIER or SEARCH
!	by STRING; find NEXT matched string or ALL matched string in the range.
!	This routine then calls DBG$SRC_TYPE_LNUM_SOURCE to type out source
!	lines in that range from that module which contains matched search 
!	string.
!
! INPUTS
!	MODRSTPTR - A pointer to the Module RST Entry of the module in which
!		  the source lines are to be looked up.
!
!	LOW_LNUM - The line number of the first source line to be searched.
!		 This is assumed to be a line number in the MODRSTPTR module.
!
!	LOW_STMT - The statement number, if any, associated with the first
!		 source line to be searched.
!
!	HIGH_LNUM - The line number of the last source line to be searched.
!		  This too is assumed to be a line in the MODRSTPTR module.
!
!	HIGH_STMT - The statement number, if any, associated with the last
!		  source line to be searched.
!
!	SEARCH_BY_STRING_FLAG - Flag set to TRUE if /STRING is used, this
!			      means search for any string that matches the
!			      given search string.  Otherwise flag set to
!			      FALSE if /IDENTIFIER is used, this means
!			      search for the exact match for the given string.
!
!	SEARCH_NEXT_FLAG - Flag set to TRUE if /NEXT is used, this means
!			   search for the first match string in the given range.
!			   Otherwise flag set to FALSE if /ALL is used, this
!			   means search for all the match stings in the range.
!
! IMPLICIT INPUT
!	DBG$SRC_SEARCH_STRING - Buffer contains the desired search string.
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
    	SEARCH_FLAG;			! Flag set to non-zero value to indicate
    					!	the kind of SEARCH option is 
    					!	active


    ! If no search string string is given, signal the warning message.
    !
    IF .DBG$SRC_SEARCH_STRING[0] EQL 0 THEN SIGNAL(DBG$_NOSRCHSTR);


    ! Set up the SEARCH command option.  The value set to the SEARCH_FLAG
    ! is 1, or 2, or 3, or 4.  1 -- SEARCH/IDENT/ALL.  2 -- SEARCH/IDENT/NEXT.
    ! 3 -- SEARCH/STRING/ALL.  4 -- SEARCH/STRING/NEXT.
    !
    SEARCH_FLAG = .SEARCH_BY_STRING_FLAG * 2 + .SEARCH_NEXT_FLAG + 1;


    ! Perform the search.
    !
    DBG$SRC_TYPE_LNUM_SOURCE(.MODRSTPTR, .LOW_LNUM, .LOW_STMT, .HIGH_LNUM,
    			     .HIGH_STMT, .SEARCH_FLAG);

    RETURN;

    END;

GLOBAL ROUTINE DBG$SRC_SET_MAX_FILES(MAX_FILES): NOVALUE =
!
! FUNCTION
!	This routine sets the maximum number of source files DEBUG will keep
!	open at any one time.  It is called during the processing of the
!	SET MAX_SOURCE_FILES command.  The purpose of this command is to give
!	the user some control over the number of source files DEBUG will keep
!	open.  The reason for this is that DEBUG can interfere with the correct
!	operation of the user program if the program itself has many files open
!	and the extra DEBUG files cause the program to exceed its open channel
!	quota.
!
! INPUTS
!	MAX_FILES - The maximum number of source files DEBUG is to keep open
!		  at any one time.
!
! OUTPUTS
!	NONE
!

    BEGIN



    ! Make sure the number of files the user specified is reasonable; otherwise
    ! signal an error.
    !
    IF (.MAX_FILES LSS 1) OR (.MAX_FILES GTR MAX_MAX_FILES)
    THEN
	SIGNAL(DBG$_INVNUMSRC);


    ! Set the maximum number of open source files in DBG$SRC_MAX_FILES and then
    ! call DBG$SRC_INIT to initialize that number of Source File Control Blocks.
    !
    DBG$SRC_MAX_FILES = .MAX_FILES;
    DBG$SRC_INIT();
    RETURN;

    END;

GLOBAL ROUTINE DBG$SRC_SET_SOURCE(MODRSTPTR, DIRLIST): NOVALUE =
!
! FUNCTION
!	This routine handles the semantic processing of the SET SOURCE and SET
!	SOURCE/MODULE=xxx commands.  It accepts a Module RST Entry pointer if
!	/MODULE was specified on the command and it accepts a list of directory
!	names, each given by a Source Directory Search List Entry.  It then
!	builds a Source Directory Search List Header Block for the specified
!	module and enters this block on the linked list pointed to by variable
!	DBG$SRC_DIR_LIST.  It also throws away any directory search list super-
!	ceded by the new list.
!
! 	This routine verfies each directory name on the list, using the $PARSE
!	system service. If any are invalid, an error is signalled.
!
!	The source directory search lists are eventually used by the routine
!	DBG$SRC_OPEN_FILE.  
!
! INPUTS
!	MODRSTPTR - A pointer to the Module RST Entry of the module specified
!		  on the SET SOURCE/MODULE command.  If the /MODULE qualifier
!		  was not present on the command, MODRSTPTR must be zero.
!
!	DIRLIST	- A pointer to a source directory search list.  More precisely,
!		  DIRLIST points to the first of a list of singly linked Source
!		  Directory Search List (SDSL) Entries.  Each SDSL Entry con-
!		  tains a directory name (or even a full file name) in counted
!		  ASCII.  DIRLIST may not be zero--an empty directory list on
!		  the SET SOURCE command is a syntax error.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	MODRSTPTR: REF RST$ENTRY,	! Pointer to Module RST Entry or zero
    	DIRLIST: REF SDSL$ENTRY;	! Pointer to directory list

    LOCAL
    	BLANK_COUNT, 			! Holds a count of the number of 
    					!     leading blanks in the directory
    					!     name as the user entered it.
    	CHAR,				! Used to hold a single character
    					!     during blank-stripping.
    	CHAR_PTR,			! Pointer that is used to step through 
    					!     a directory name
    					!     character by character, during
    					!     blank-stripping.
    	COUNT,				! Holds a count of the number of
    					!     non-blank characters in a 
    					!     directory name that is being
    					!     verified.
	DIRPTR: REF SDSL$HEADER,	! Pointer that is used to walk through
    					!     the linked list of headers.
    	DUMMY_BUF: VECTOR [132, BYTE],	! Output buffer for call to $PARSE.
    					!     (this is not actually used since
    					!     we are only interested in the
    					!     status code returned by $PARSE)
    	ENTRYPTR: REF SDSL$ENTRY,	! Pointer that is used to walk through
    					!     a linked list of directory names. 
    	LAST_DIRPTR: REF SDSL$HEADER,   ! Points to the last header in the list.
    	NEW_DIRPTR: REF SDSL$HEADER,	! Points to the new header record that
    					!     is allocated.
    	STATUS,				! Return code from $PARSE
    	STRING_BUF: VECTOR [132, BYTE],	! Input buffer for call to $PARSE
    	STRING_BUF_PTR, 		! Pointer to an output buffer where a  
    					!     directory name will be copied
    					!	during validation of that
    					!	directory name.
    	TSTFAB: $fab_decl,		! FAB block for $PARSE
    	TSTNAM: $nam_decl;		! NAM block for $PARSE



    ! Reinitialize all Source File Control Blocks. This forces presently
    ! open files to be reopened using the new source directories we are
    ! about to set.
    !
    DBG$SRC_INIT ();


    ! Initialize the fields of the FAB and the NAM blocks
    !
    $FAB_INIT ( FAB = TSTFAB,
    		DNA = STRING_BUF,
    		DNS = 132);
    $NAM_INIT ( NAM = TSTNAM,
    		ESA = DUMMY_BUF,
    		ESS = 132,
    		RSA = DUMMY_BUF,
    		RSS = 132);

    ! We first verify the list that is given to us.

    ! Walk through the list of directory names, verfifying that each one
    ! is valid.
    !
    ENTRYPTR = .DIRLIST;
    WHILE .ENTRYPTR NEQ 0 DO
    	BEGIN ! verify a single directory name


    	! Initialize char_ptr to the start of the directory name
        !
    	CHAR_PTR = ENTRYPTR[SDSL$A_ENT_DIRNAME];
    
        ! Inintialize string_buf_ptr to the address of the string buffer
    	! that is declared in the FAB
        !
        STRING_BUF_PTR = STRING_BUF;    

    	! Initialize blank_count and count
    	!
    	BLANK_COUNT = 0;
        COUNT = 0;

    	! Loop through the leading blanks to strip them off.
    	!
    	WHILE .BLANK_COUNT LSS .ENTRYPTR[SDSL$B_ENT_DIRLEN] DO
    	    BEGIN
    	    CHAR = CH$RCHAR_A (CHAR_PTR);
    	    IF .CHAR NEQ DBG$K_BLANK 
    	    THEN
    		EXITLOOP;
    	    BLANK_COUNT = .BLANK_COUNT + 1;
    	    END;
    

        ! If the name is all blanks, signal an error. This is caused by
    	! a pair of commas with only blanks between them.
    	! 
    	IF .BLANK_COUNT EQL .ENTRYPTR[SDSL$B_ENT_DIRLEN] 
    	THEN
    	    SIGNAL (DBG$_INVDIRNAM, 1, UPLIT BYTE (%ASCIC ' '), .STATUS);

    	! Now loop through the non-blank characters. Move each character
    	! to the STRING_BUF_PTR buffer temporarily and translate to
    	! upper case.
    	!
    	WHILE .COUNT + .BLANK_COUNT LSS .ENTRYPTR[SDSL$B_ENT_DIRLEN] DO
    	    BEGIN 
    	    COUNT = .COUNT + 1;
    	    IF .CHAR LEQ 'z' AND .CHAR GEQ 'a'
    	    THEN
    		CHAR = .CHAR - ('a' - 'A');
    	    CH$WCHAR_A (.CHAR, STRING_BUF_PTR);
    	    CHAR = CH$RCHAR_A (CHAR_PTR);
    	    END;


        ! Copy the blank_stripped and translated directory name back
    	! into the original entry.
    	!
    	CH$MOVE (.COUNT, STRING_BUF, ENTRYPTR[SDSL$A_ENT_DIRNAME]);
        ENTRYPTR[SDSL$B_ENT_DIRLEN] = .COUNT;

    	! Now check the directory name for syntactic validity. This is done
    	! by $PARSE so that RMS does the checking.
    	!
    	TSTFAB[FAB$B_DNS] = .COUNT;
    	STATUS = $PARSE (FAB = TSTFAB);
    	IF NOT .STATUS THEN
    	    SIGNAL (DBG$_INVDIRNAM, 1, ENTRYPTR[SDSL$B_ENT_DIRLEN]);
    	ENTRYPTR = .ENTRYPTR[SDSL$L_ENT_FLINK];

    	END; ! of loop through directory names


    ! If we get this far we have a valid directory list.

    ! Attempt to find a directory list for the same module in the current
    ! Source Directory Search List. If we find one, we remove it from the
    ! list.
    !
    DIRPTR = .DBG$SRC_DIR_LIST;
    WHILE .DIRPTR NEQ 0 DO
    	BEGIN
    	IF .DIRPTR[SDSL$L_MODPTR] EQL .MODRSTPTR
    	THEN
    	    BEGIN
    	    DBG$SRC_CANCEL_SOURCE (.DIRPTR[SDSL$L_MODPTR]);
    	    EXITLOOP;
    	    END;
    	DIRPTR = .DIRPTR[SDSL$L_FLINK];
    	END;


    ! Allocate and build a new Source Directory List Header Block. 
    ! Insert it at the end of the Source Directory Search List.
    !
    NEW_DIRPTR = DBG$GET_MEMORY (SDSL$K_HDR_SIZE);
    NEW_DIRPTR[SDSL$L_LIST_PTR] = .DIRLIST;
    NEW_DIRPTR[SDSL$L_MODPTR] = .MODRSTPTR;
    
    ! Walk to the end of the Source Directory Search List.
    !
    DIRPTR = DBG$SRC_DIR_LIST;
    WHILE .DIRPTR[SDSL$L_FLINK] NEQ 0 DO
    	DIRPTR = .DIRPTR[SDSL$L_FLINK];
    DIRPTR[SDSL$L_FLINK] = .NEW_DIRPTR;
    
    RETURN;
    
    END; 

GLOBAL ROUTINE DBG$SRC_SHOW_SOURCE: NOVALUE =
!
! FUNCTION
!	This routine handles the semantics of the SHOW SOURCE command.  It thus
!	formats and prints the contents of the directory search lists pointed to
!	by DBG$SRC_DIR_LIST.  If one or more SET SOURCE/MODULE commands are in
!	effect, the output has this general format:
!
!			source directory search list for MODNAME1:
!				[FIRST.DIR]
!				LOGNAME$
!			source directory search list for MODNAME2:
!				[DIR1]
!				[DIR2.SUBDIR]
!				DB1:[DIR3.DIR31.DIR32]
!			source directory search list for all other modules:
!				[.SUBDIR]
!
!	If a SET SOURCE command is in effect but no SET SOURCE/MODULE command is
!	in effect, this format is used:
!
!			source directory search list for all modules:
!				[DIRNAME1]
!				[DIRNAME2]
!
!	And if no SET SOURCE command is in effect at all, this is output:
!
!			no source directory search list in effect
!
!	All directory names are output exactly as the user originally entered
!	them.  There is no attempt to translate logical names or determine
!	defaults until the directory name is actually used to open a file.
!	Hence no such translations are done for the SHOW SOURCE display.
!
! INPUTS
!	NONE
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
    	BUFFER : VECTOR [140, BYTE],	! Buffer for DBG$FAO_PUT
    	DEF_DIRPTR : REF SDSL$HEADER,   ! Points to the default
    					!	Source Directory Search List,
    					!	if one exists.
    	DIRPTR : REF SDSL$HEADER,	! A pointer used to walk through the
    					!	linked list of Source Directory
    					!	Search List header blocks.
    	MODNAMEPTR;			! Points to a module name.

    ! If there is no Source Directory Search List in effect, print a message
    ! to that effect and return.
    !
    IF .DBG$SRC_DIR_LIST EQL 0 
    THEN
    	BEGIN
    	DBG$CP_OUT_STR = BUFFER[1];
    	DBG$GL_BUF_SIZ = 0;
    	DBG$FAO_PUT (BUFFER, UPLIT BYTE(
    	    %ASCIC 'no directory search list in effect'));
    	DBG$OUT_PUT (BUFFER);
    	RETURN;
    	END;


    ! If SET SOURCE is in effect but no SET SOURCE/MODULE= is in effect,
    ! print the "for all modules" header message and the corresponding
    ! list of directory names. Then return.
    !
    DIRPTR = .DBG$SRC_DIR_LIST;
    IF  .DIRPTR[SDSL$L_MODPTR] EQL 0
    	 AND
    	.DIRPTR[SDSL$L_FLINK] EQL 0
    THEN
        BEGIN
    	DBG$CP_OUT_STR = BUFFER[1];
    	DBG$GL_BUF_SIZ = 0;
    	DBG$FAO_PUT (BUFFER, UPLIT BYTE(
    		%ASCIC 'source directory search list for all modules:'));
    	DBG$OUT_PUT (BUFFER);
    	OUTPUT_DIR_LIST(.DIRPTR[SDSL$L_LIST_PTR]);
    	RETURN;
    	END;


    ! If we reach this point, there is at least one directory list for a 
    ! specific module. Loop through all the Source Directory Search List
    ! Header Blocks and print the directory list for each corresponding 
    ! module.
    !
    DEF_DIRPTR = 0;
    WHILE .DIRPTR NEQ 0 DO
    	BEGIN
    

    	! Check for default directory list (SET SOURCE with no
    	! module specified). Store this away in DEF_DIRPTR since
    	! it will be printed last.
    	!
    	IF .DIRPTR[SDSL$L_MODPTR] EQL 0
        THEN
    	    DEF_DIRPTR = .DIRPTR


    	! Else this SDSL Header Block is for a specific module. Print a
    	! header message with the module name and print the corresponding
    	! directory names.
    	!
    	ELSE
    	    BEGIN
    	    DBG$CP_OUT_STR = BUFFER[1];
    	    DBG$GL_BUF_SIZ = 0;
    	    DBG$STA_SYMNAME (.DIRPTR[SDSL$L_MODPTR], MODNAMEPTR);
    	    DBG$FAO_PUT (BUFFER, UPLIT BYTE(
    			%ASCIC 'source directory search list for !AC:'),
    			.MODNAMEPTR);
    	    DBG$OUT_PUT (BUFFER);
    	    OUTPUT_DIR_LIST (.DIRPTR[SDSL$L_LIST_PTR]);
    	    END;


    	! Link to the next SDSL Header Block and loop
    	!
    	DIRPTR = .DIRPTR[SDSL$L_FLINK];
    	END; ! While loop

    ! Now output the default directory list used for all other modules
    ! if such a list is present. Then return.
    !
    IF .DEF_DIRPTR NEQ 0
    THEN
        BEGIN
    	DBG$CP_OUT_STR = BUFFER[1];
    	DBG$GL_BUF_SIZ = 0;
    	DBG$FAO_PUT (BUFFER, UPLIT BYTE(
    		    %ASCIC 'source directory list for all other modules:'));
    	DBG$OUT_PUT (BUFFER);
    	OUTPUT_DIR_LIST (.DEF_DIRPTR[SDSL$L_LIST_PTR]);
    	END;

    RETURN;

    END;

ROUTINE DBG$SRC_TYPE_LINE(LINE_NUM, STMT_NUM, SRC_FILE, REC_NUM): =
!
! FUNCTION
!	This routine accepts the line number and statement number of a source
!	line, a pointer to the Declare Source File DST command for the corre-
!	sponding source file, and the record number of the line within that
!	file.  It then reads in the text of the source line and causes it to be
!	typed out to the user.  It is called by DBG$SRC_TYPE_LNUM_SOURCE each
!	time that routine finds a desired line number in the current module's
!	Source Line Correlation DST Record.
!
!	This routine calls DBG$SRC_OPEN_FILE with the pointer to the Declare
!	Source File DST command (where the full file declaration is found).
!	DBG$SRC_OPEN_FILE opens the file (unless it is already opened), and
!	returns a pointer to the file's Source File Control Block (SFCB).  This
!	pointer is then passed to DBG$SRC_READ_FILE to read in the actual source
!	image.  If SEARCH command is active then calls SRC$SRC_SEARCH to locate
!	the desired string.  If matched string is not found, exit from the
!	routine and return status back to caller.  Finally, DBG$SRC_OUTPUT_LINE is 
!	is called to print the source line.
!
! INPUTS
!	LINE_NUM - The line number of the line to be read and printed.  If the
!		  line is unnumbered (has no line number as is true for comments
!		  in some languages), LINE_NUM should be negative.
!
!	STMT_NUM - The statement number of the line to be read and printed.  If
!		  a statement number is not applicable (which is the case in
!		  most languages), STMT_NUM should be zero.
!
!	SRC_FILE - A pointer to the Declare Source File command for the desired
!		  source file in the Source Line Correlation DST Record.  This
!		  pointer defines which file the desired source line should be
!		  read from.
!
!	REC_NUM	- The record number in the SRC_FILE source file of the source
!		  line to be read and printed.  This record number also comes
!		  from the Source Line Correlation DST Record.
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
    	BUFLEN,				! The length in characters of the input
    					!	line 
    	BUFPTR: REF VECTOR[,BYTE],		! Pointer to the input buffer
    	SEARCH_STATUS,			! Flag set to TRUE if the search string
    					!	is found, for other conditions,
    					!	flag set to FALSE
	SRC_FILE_CNTRL_BLK: REF SFCB$BLOCK;	! Pointer to the Source File 
    						!	Control	Block



    ! Signal an error if SRC_FILE is not delcare or set in Source File 
    ! Correlation DST Record.
    !
    IF .SRC_FILE EQL 0 THEN SIGNAL(DBG$_INVDSTREC);


    ! Initialize SEARCH_STATUS to FALSE for all non-search commands, and default
    ! to no matches for SEARCH command.
    !
    SEARCH_STATUS = FALSE;


    ! Calls OPEN LINE routine to open the Source File pointed by Declare Source
    ! File DST Command in the given directory.
    ! 
    DBG$SRC_OPEN_FILE(.SRC_FILE,SRC_FILE_CNTRL_BLK);


    ! Calls READ SOURCE FILE routine to read in Source File Records.
    !
    DBG$SRC_READ_FILE(.SRC_FILE_CNTRL_BLK,.REC_NUM,BUFPTR,BUFLEN);


    ! Call SEARCH routine to search the desried string if SEARCH command is in
    ! action.  If we did not find the matched string, return the status to
    ! TYPE LNUM SOURCE, otherwise call OUTPUT LINE routine to output the line.
    !
    IF .DBG$SRC_SEARCH_FLAG NEQ 0
    THEN
    	BEGIN
    	SEARCH_STATUS = DBG$SRC_SEARCH(.BUFPTR,.BUFLEN);
    	IF NOT .SEARCH_STATUS THEN RETURN .SEARCH_STATUS;
    	END;

    ! Calls OUTPUT LINE routine to print the source line.
    !
    DBG$SRC_OUTPUT_LINE(.LINE_NUM,.STMT_NUM,.BUFPTR,.BUFLEN);
    IF .LINE_NUM NEQ -1 THEN DBG$SRC_NEXT_LNUM = .LINE_NUM + 1;
    IF .STMT_NUM NEQ 0 THEN DBG$SRC_NEXT_STMT = .STMT_NUM + 1;
    DBG$SRC_NEXT_MODRSTPTR = .DBG$SRC_MODRSTPTR;

    RETURN .SEARCH_STATUS;

    END;

GLOBAL ROUTINE DBG$SRC_TYPE_LNUM_SOURCE(MODRSTPTR, LOW_LNUM, LOW_STMT,
					HIGH_LNUM, HIGH_STMT, SEARCH_FLAG): NOVALUE =
!
! FUNCTION
!	This routine accepts a Module RST Entry pointer and a line number range
!	and types out all source lines, or, ALL matched strings or NEXT matched
!	string for SEARCH command in that range from that module.  It is
!	called to handle source line display in response to the TYPE command,
!	the EXAMINE/SOURCE command, the SEARCH command, breakpoints, watchpoints, 
!	and stepping by	line.  In fact, all source line displays go through 
!	this routine.
!
!	More specifically, this routine scans through all the Source Line Corre-
!	lation DST Records for the specified module to find the desired line
!	numbers.  It executes all the commands in these DST records as it goes
!	along, and is thus able to determine the appropriate File ID and record
!	number within the file for each desired line number.  For each such line
!	it then calls DBG$SRC_TYPE_LINE to actually retrieve, or search, and/or
!	display the text of the line.
!
!	It handles Declare Source File commands in the DST records by building a
!	File ID Table for the current module.  This table consists of a singly
!	linked list where each entry corresponds to one source file contributing
!	to the current module.  The file's File ID and a pointer to its Declare
!	Source File command block are stored in each entry.  SRC_FILEID_TBL
!	points to this linked list.  DBG$SRC_MODRSTPTR points to the current
!	module's Module RST Entry, this variable is set by this routine and
!	is later used by DBG$SRC_TYPE_LINE.
!
! INPUTS
!	MODRSTPTR - A pointer to the Module RST Entry of the module in which
!		  the source lines are to be looked up.
!
!	LOW_LNUM - The line number of the first source line to be typed out.
!		  This is assumed to be a line number in the MODRSTPTR module.
!
!	LOW_STMT - The statement number, if any, associated with the first
!		  source line to be typed out.  If no statement number should
!		  be associated with the LOW_LNUM line, LOW_STMT must be zero.
!
!	HIGH_LNUM - The line number of the last source line to be type out.
!		  This too is assumed to be a line in the MODRSTPTR module.
!		  HIGH_LNUM must be greater than or equal to LOW_LNUM.
!
!	HIGH_STMT - The statement number, if any, associated with the last
!		  source line to be typed out.  If no statement number should
!		  be associated with the HIGH_LNUM line, HIGH_STMT must be zero.
!		  If HIGH_LNUM equals LOW_LNUM, HIGH_STMT must be greater than
!		  or equal to LOW_STMT.
!
!	SEARCH_FLAG - Flag set to non-zero value to indicate the SEARCH command
!		    is active, set to zero to indicate other commands are active.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	MODRSTPTR: REF RST$ENTRY;	! Pointer to Module RST Entry of module
					!      containing desired source lines

    LOCAL
    	BUFFER: VECTOR[140,BYTE],	! Output buffer for DBG$FAO_PUT
    	DSTPTR: REF DST$SRC_COMMAND,	! Pointer to the Source File Correlation
    					!	Command 
    	DSTREC_PTR: REF DST$RECORD,	! Pointer to the Source File Correlation
    					!	DST record
    	HIGH_LINE_NUM,			! Place holder for Ending Line Number
    	LENGTH,				! Length of current Source File Correlation
    					!	DST Record
    	LINE_NUM,			! The current listing line number
    	MODNAMEPTR,			! Pointer to counted ASCII name of current
    					!	module
    	MODSRCTBL: REF VECTOR[,LONG],	! Pointer to a list of Source File
    					!	Correlation DST Record pointers
    					!	for the current module
    	SEARCH_FND,			! Used for SEARCH command only.  Flag
    					!	set to TRUE if the search string
    					!	is found
    	SFIT_PTR: REF SFIT$ENTRY,	! Pointer to the Source File ID Table
    	SRC_FILEID_TBL,			! Pointer to a linked list of File ID
    					!	Table entries for current module
    	SRC_DSTPTR,			! Pointer to Declare Source File Command
    					!	in DST Record
    	SRC_REC,			! The record number in the current source
    					!	file of the current source line
    	STATEMENT_MODE,			! Flag set to TRUE if we are currently
    					!	in Statement Mode
    	STMT_NUM,			! The current statement number
    	TYPE_FLAG;			! Flag set to TRUE if TYPE LINE routine
    					!	has been called at least once



    ! Make sure Module RST pointer is not null.
    !
    IF .MODRSTPTR EQL 0 THEN SIGNAL(DBG$_DEBUGBUG, 1, 195);


    ! Start by doing some consistency checks to ensure that the line number
    ! of the last source line is greater than or equal to the line number
    ! of the first source line.  If no statement number should be associated
    ! with line number, statement number must be zero.  If HIGH_LNUM equals
    ! LOW_LNUM, HIGH_STMT must be greater than or equal to LOW_STMT.  If
    ! either is wrong, signal an error and give up.
    !
    IF (.LOW_LNUM GTR .HIGH_LNUM) THEN SIGNAL(DBG$_INVSRCLIN);
    IF (.LOW_LNUM EQL .HIGH_LNUM) AND (.LOW_STMT GTR .HIGH_STMT)
    THEN
    	SIGNAL(DBG$_INVSRCLIN);


    ! Initialization.  Assume that Line Number is set to the beginning of the
    ! listing, Source File Record Number is set to the beginning of the
    ! source file, no Source File ID is found, Statement Mode is not set,
    ! no line is yet typed out, and statement number is set to 0.
    !
    IF .SEARCH_FLAG EQL 0 THEN DBG$SRC_NEXT_MODRSTPTR = 0;
    DBG$SRC_SEARCH_FLAG = .SEARCH_FLAG;
    LINE_NUM = 1;
    STMT_NUM = 0;
    SEARCH_FLAG = FALSE;
    SEARCH_FND = FALSE;
    SRC_DSTPTR = 0;
    SRC_REC = 1;
    STATEMENT_MODE = FALSE;
    SRC_FILEID_TBL = 0;
    TYPE_FLAG = FALSE;


    ! Set up the output buffer for the print routine (i.e., DBG$FAO_PUT).
    !
    DBG$CP_OUT_STR = BUFFER[1];
    DBG$GL_BUF_SIZ = 0;


    ! Points to the current modules's Module RST Entry, this is later used 
    ! by DBG$SRC_TYPE_LINE routine.  And also get the Module Name.
    !
    DBG$SRC_MODRSTPTR = .MODRSTPTR;
    DBG$STA_SYMNAME(.MODRSTPTR,MODNAMEPTR);


    ! Make sure Module Source Table pointer in module's Module RST Entry
    ! points to a list of Source File DST Record Pointers.
    !
    IF .MODRSTPTR[RST$L_MODSRCTBL] EQL 0
    THEN 
    	BEGIN
    	SIGNAL(DBG$_SRCLINNOT,1,.MODNAMEPTR);
    	RETURN;
    	END;


    ! Loop thru Module's Source Line Correlation DST Records.  
    !
    MODSRCTBL = .MODRSTPTR[RST$L_MODSRCTBL];
    INCR COUNT FROM 1 TO .MODSRCTBL[0] DO
    	BEGIN
    	IF (.LINE_NUM GTR .HIGH_LNUM) AND (.STMT_NUM GEQ .HIGH_STMT)
    	THEN
    	    EXITLOOP;


    	! We have found the 1st match string for the SERACH/IDENT/NEXT or
    	! SEARCH/STRING/NEXT command.  Exit the loop.
    	!
    	IF .SEARCH_FND AND 
    	   ((.DBG$SRC_SEARCH_FLAG EQL SEARCH_IDENT_NEXT) OR
    	    (.DBG$SRC_SEARCH_FLAG EQL SEARCH_STRING_NEXT))
    	THEN
    	    EXITLOOP;


    	! Get Source Line Correlation DST Record pointer.
    	!
    	DSTREC_PTR = .MODSRCTBL[.COUNT];
    	IF .DSTREC_PTR[DST$B_TYPE] NEQ DST$K_SOURCE
    	THEN 
    	    SIGNAL(DBG$_DEBUGBUG,1,195);


    	! Scans thru Source File DST Record to decode the Source File Correlation
    	! Commands.  Pick up the length of this DST record.  Set pointer to the
    	! first command entry.
    	!
    	LENGTH = .DSTREC_PTR[DST$B_LENGTH];
    	DSTPTR = DSTREC_PTR[DST$A_SRC_FIRST_CMD];    	
    	WHILE (.DSTPTR - .DSTREC_PTR - 1) NEQ .LENGTH DO
    	    BEGIN
    	    IF (.LINE_NUM GTR .HIGH_LNUM) AND (.STMT_NUM GEQ .HIGH_STMT)
    	    THEN
    		EXITLOOP;


    	    ! We have found the 1st match string for SEARCH/IDENT/NEXT or
    	    ! SEARCH/STRING/NEXT command.  Exit the loop.
    	    !
    	    IF .SEARCH_FND AND
    	       ((.DBG$SRC_SEARCH_FLAG EQL SEARCH_IDENT_NEXT) OR
    		(.DBG$SRC_SEARCH_FLAG EQL SEARCH_STRING_NEXT))
    	    THEN
    		EXITLOOP;


    	    ! Pick up the command code defined in Source File DST Record
    	    ! and use it as a CASE index so each significant command code
    	    ! can be interpreted individually.
    	    !
    	    CASE .DSTPTR[DST$B_SRC_COMMAND] FROM DST$K_SRC_MIN_CMD TO
                                                 DST$K_SRC_MAX_CMD OF
    	        SET


    	        ! Declare Source File Command.  Allocate some space to build 
    	        ! the File ID Table.
    	        !
    	        [DST$K_SRC_DECLFILE]:
    	            BEGIN
    	            SFIT_PTR = DBG$GET_TEMPMEM(SFIT$K_SIZE);
    	            SFIT_PTR[SFIT$L_FLINK] = .SRC_FILEID_TBL;
    	            SFIT_PTR[SFIT$L_FILE_ID] = .DSTPTR[DST$W_SRC_DF_FILEID];
    	            SFIT_PTR[SFIT$L_DSTPTR] = .DSTPTR;
    		    SFIT_PTR[SFIT$L_CURRECNUM] = 1;
    	            SRC_FILEID_TBL = .SFIT_PTR;
    	            DSTPTR = .DSTPTR + .DSTPTR[DST$B_SRC_DF_LENGTH] + 2;
    	            END;


    	        ! Set Source File Command.  This command sets the current
    	        ! source file to the file denoted by the File ID given in
    	        ! the command.  This File ID must be pre-defined by the 
    	        ! Declare Source File Command.
    	        !
    	        [DST$K_SRC_SETFILE]:
    	            BEGIN
    		    SFIT_PTR[SFIT$L_CURRECNUM] = .SRC_REC;
    	            SRC_DSTPTR = 0;	        
    	            SFIT_PTR = .SRC_FILEID_TBL;
    	            WHILE .SFIT_PTR NEQ 0 DO
    	                BEGIN
    	                IF .DSTPTR[DST$W_SRC_UNSWORD] EQL .SFIT_PTR[SFIT$L_FILE_ID]
    	                THEN
    	                    BEGIN
    	                    SRC_DSTPTR = .SFIT_PTR[SFIT$L_DSTPTR];
    	                    SRC_REC = .SFIT_PTR[SFIT$L_CURRECNUM];
    	                    EXITLOOP;
    	                    END;

    	                SFIT_PTR = .SFIT_PTR[SFIT$L_FLINK];
    	                END;


    	            ! If this File ID has not yet been declared, signal an
    		    ! invalid DST Record.
    	            !
    	            IF .SRC_DSTPTR EQL 0 THEN SIGNAL(DBG$_INVDSTREC);
    	            DSTPTR = .DSTPTR + 3;
    	            END;


    	        ! Set Source Record Number Long Command.  Set the current source
    	        ! file record number.  Advance DSTPTR.
    	        !
    	        [DST$K_SRC_SETREC_L]:
    	            BEGIN
    	            SRC_REC = .DSTPTR[DST$L_SRC_UNSLONG];
    	            DSTPTR = .DSTPTR + 5;
    	            END;


   	        ! Set Source Record Number Word Command. (More compact form).
    	        !
    	        [DST$K_SRC_SETREC_W]:
    	            BEGIN
    	            SRC_REC = .DSTPTR[DST$W_SRC_UNSWORD];
    	            DSTPTR = .DSTPTR + 3;
    	            END;


    	        ! Set Line Number Long Command.  Set the current listing line
    	        ! number.  Advance DSTPTR.
    	        !
    	        [DST$K_SRC_SETLNUM_L]:
    	            BEGIN
    	            LINE_NUM = .DSTPTR[DST$L_SRC_UNSLONG];
    	            DSTPTR = .DSTPTR + 5;
    	            END;


    	        ! Set Line Number Word Command. (More compact form).
    	        !
    	        [DST$K_SRC_SETLNUM_W]:
    	            BEGIN
    	            LINE_NUM = .DSTPTR[DST$W_SRC_UNSWORD];
    	            DSTPTR = .DSTPTR + 3;
    	            END;


    	        ! Increment Line Number Byte Command.  Increment the current
    	        ! listing line number by a byte value given in this command.
    	        ! Advance DSTPTR.
    	        !
    	        [DST$K_SRC_INCRLNUM_B]:
    	            BEGIN
    	            LINE_NUM = .LINE_NUM + .DSTPTR[DST$B_SRC_UNSBYTE];
    	            DSTPTR = .DSTPTR + 2;
    	            END;


    	        ! Enter Statement Mode Command.  Statement mode allows separate
    	        ! source lines to have statement numbers. (BASIC only).
    	        ! Advance DSTPTR.
    	        !
    	        [DST$K_SRC_ENTER_STMODE]:
    	            BEGIN
    		    SIGNAL(DBG$_INVDSTREC);	! *** Not yet implemented ***
    		    IF .STATEMENT_MODE THEN SIGNAL(DBG$_INVDSTREC);
    	            STATEMENT_MODE = TRUE;
    	            DSTPTR = .DSTPTR + 1;
    	            END;


    	        ! Leave Statement Mode Command.  Leave statement mode, return to
    	        ! line mode.  Advance DSTPTR.
    	        !
    	        [DST$K_SRC_LEAVE_STMODE]:
    	            BEGIN
    		    SIGNAL(DBG$_INVDSTREC);	! *** Not yet implemented ***
    		    IF NOT .STATEMENT_MODE THEN SIGNAL(DBG$_INVDSTREC);
    	            STATEMENT_MODE = FALSE;
    	            DSTPTR = .DSTPTR + 1;
    	            END;


    	        ! Define N Separate Lines Word Command, and Define N Separate
    		! Lines Byte Command (More Compant Form).  If a Source File is not
    	        ! set, signal and give up.  Defines the Source File and Source
    	        ! Record Numbers for a specified number of Listing Line Numbers.
    	        ! Call TYPE LINE routine, if LOW_LNUM <= LINE_NUM <= HIGH_LNUM.
    	        !
    	        [DST$K_SRC_DEFLINES_W, DST$K_SRC_DEFLINES_B]:
    	            BEGIN
    	            IF .SRC_DSTPTR EQL 0 THEN SIGNAL(DBG$_INVDSTREC);


    		    ! Calculate the listing line number range.
    		    !
    		    IF .DSTPTR[DST$B_SRC_COMMAND] EQL DST$K_SRC_DEFLINES_W
    		    THEN
    			HIGH_LINE_NUM = .LINE_NUM + .DSTPTR[DST$W_SRC_UNSWORD] - 1
    		    ELSE
    			HIGH_LINE_NUM = .LINE_NUM + .DSTPTR[DST$B_SRC_UNSBYTE] - 1;


    		    ! Test to see if the listing line number exceeds the type
    		    ! line range.  If it is, increments the source record number
    		    ! listing line number and DST pointer, then returns.
    		    !
    		    IF (.LINE_NUM GTR .HIGH_LNUM) OR
    		       (.HIGH_LINE_NUM LSS .LOW_LNUM)
    		    THEN
    			BEGIN
    			IF .DSTPTR[DST$B_SRC_COMMAND] EQL DST$K_SRC_DEFLINES_W
    			THEN
    			    SRC_REC = .SRC_REC + .DSTPTR[DST$W_SRC_UNSWORD]
    			ELSE
    			    SRC_REC = .SRC_REC + .DSTPTR[DST$B_SRC_UNSBYTE];

    			END

    		    ELSE
    			BEGIN
    			TYPE_FLAG = TRUE;


    		        ! Synchronize the Source Record Number with the Listing Line
    		        ! Number.
    		        !
    		        IF (.LOW_LNUM - .LINE_NUM) GTR 0
    		        THEN
    			    SRC_REC = .SRC_REC + (.LOW_LNUM - .LINE_NUM);

    	                INCR I FROM MAX(.LOW_LNUM,.LINE_NUM) TO 
    		   	    	    MIN(.HIGH_LNUM,.HIGH_LINE_NUM) DO
    	                    BEGIN
    			    SEARCH_FND = DBG$SRC_TYPE_LINE(.I,.STMT_NUM,.SRC_DSTPTR,.SRC_REC);
    	                    IF .SEARCH_FND THEN SEARCH_FLAG = TRUE;
    			    SRC_REC = .SRC_REC + 1;
    			    IF .SEARCH_FND AND
    			       ((.DBG$SRC_SEARCH_FLAG EQL SEARCH_IDENT_NEXT) OR
    			        (.DBG$SRC_SEARCH_FLAG EQL SEARCH_STRING_NEXT))
    			    THEN
    				EXITLOOP;

    	                    END;

    		        END;

	            LINE_NUM = .HIGH_LINE_NUM + 1;
    	            IF .DSTPTR[DST$B_SRC_COMMAND] EQL DST$K_SRC_DEFLINES_W
    		    THEN
    		        DSTPTR = .DSTPTR + 3
    		    ELSE
    			DSTPTR = .DSTPTR + 2;

    	            END;


    	        ! Define N Lines With Same Line Number Word or Byte Command.
    		! Define N Unnumbered Lines Word or Byte Command.  If a Source
    	        ! File is not set, signal and give up.  The first two defines
    		! a specified number of source lines to have the same listing
    		! line number.  This happens with continuation lines in some 
    		! languages.  The last two specifies number of source lines do
    		! not have line numbers, such as Comment Lines in some langes.
    		! Call the TYPE LINE routine when LOW_LNUM <= LINE_NUM <= HIGH_LNUM
    	        !
    	        [DST$K_SRC_DEFSAME_W, DST$K_SRC_DEFSAME_B,
    		 DST$K_SRC_DEFUNNUM_W, DST$K_SRC_DEFUNNUM_B]:
    	            BEGIN
    	            IF .SRC_DSTPTR EQL 0 THEN SIGNAL(DBG$_INVDSTREC);
    		    IF (.LINE_NUM GTR .HIGH_LNUM) OR (.LINE_NUM LSS .LOW_LNUM)
    		    THEN
    			BEGIN
    			IF (.DSTPTR[DST$B_SRC_COMMAND] EQL DST$K_SRC_DEFSAME_W) OR
    			   (.DSTPTR[DST$B_SRC_COMMAND] EQL DST$K_SRC_DEFUNNUM_W)
    			THEN
    			    BEGIN
    			    SRC_REC = .SRC_REC + .DSTPTR[DST$W_SRC_UNSWORD];
    			    DSTPTR = .DSTPTR + 3;
    			    END
    			ELSE
    			    BEGIN
    			    SRC_REC = .SRC_REC + .DSTPTR[DST$B_SRC_UNSBYTE];
    			    DSTPTR = .DSTPTR + 2;
    			    END;

    			END

    		    ELSE
    			BEGIN
    		        TYPE_FLAG = TRUE;
    		        CASE .DSTPTR[DST$B_SRC_COMMAND] FROM DST$K_SRC_DEFSAME_W TO
    							     DST$K_SRC_DEFUNNUM_B OF
    			    SET


    			    ! Define N Lines with Same Line Number Word Command.
    			    !
    			    [DST$K_SRC_DEFSAME_W]:
    			        BEGIN
    	                        INCR I FROM 1 TO .DSTPTR[DST$W_SRC_UNSWORD] DO
    			           BEGIN
    	                           SEARCH_FND = DBG$SRC_TYPE_LINE(.LINE_NUM,.STMT_NUM,.SRC_DSTPTR,.SRC_REC);
    				   IF .SEARCH_FND THEN SEARCH_FLAG = TRUE;
    	                           SRC_REC = .SRC_REC + 1;
    			    	   IF .SEARCH_FND AND
    			           ((.DBG$SRC_SEARCH_FLAG EQL SEARCH_IDENT_NEXT) OR
    			            (.DBG$SRC_SEARCH_FLAG EQL SEARCH_STRING_NEXT))
    			           THEN
    				       EXITLOOP;

    	                           END;

    	                        DSTPTR = .DSTPTR + 3;
    	                        END;


    	        	    ! Define N Lines With Same Line Number Byte Command.  
    	        	    !
    	        	    [DST$K_SRC_DEFSAME_B]:
    	            	        BEGIN
    			        INCR I FROM 1 TO .DSTPTR[DST$B_SRC_UNSBYTE] DO
    				    BEGIN
    	                            SEARCH_FND = DBG$SRC_TYPE_LINE(.LINE_NUM,.STMT_NUM,.SRC_DSTPTR,.SRC_REC);
    				    IF .SEARCH_FND THEN SEARCH_FLAG = TRUE;
    	                	    SRC_REC = .SRC_REC + 1;
        			    IF .SEARCH_FND AND
    				       ((.DBG$SRC_SEARCH_FLAG EQL SEARCH_IDENT_NEXT) OR
    				        (.DBG$SRC_SEARCH_FLAG EQL SEARCH_STRING_NEXT))
    				    THEN
    					EXITLOOP;

    				    END;
    	                    
    	            	        DSTPTR = .DSTPTR + 2;
    	            	        END;


    	        	    ! Define N Unnumbered Lines Word Command.
	        	    !
    	        	    [DST$K_SRC_DEFUNNUM_W]:
    	            	        BEGIN
    	            	        INCR I FROM 1 TO .DSTPTR[DST$W_SRC_UNSWORD] DO
    	                	    BEGIN
       	                            SEARCH_FND = DBG$SRC_TYPE_LINE(-1,.STMT_NUM,.SRC_DSTPTR,.SRC_REC);
    				    IF .SEARCH_FND THEN SEARCH_FLAG = TRUE;
    	                	    SRC_REC = .SRC_REC + 1;
        			    IF .SEARCH_FND AND
    				       ((.DBG$SRC_SEARCH_FLAG EQL SEARCH_IDENT_NEXT) OR
    				        (.DBG$SRC_SEARCH_FLAG EQL SEARCH_STRING_NEXT))
    				    THEN
    					EXITLOOP;

    	                	    END;

    	            	        DSTPTR = .DSTPTR + 3;
    	            	        END;


    	        	    ! Define N Unnumbered Lines Byte Command.  
    	        	    !
    	        	    [DST$K_SRC_DEFUNNUM_B]:
    	            	        BEGIN
        	                INCR I FROM 1 TO .DSTPTR[DST$B_SRC_UNSBYTE] DO
    	                            BEGIN
    	                            SEARCH_FND = DBG$SRC_TYPE_LINE(-1,.STMT_NUM,.SRC_DSTPTR,.SRC_REC);
    				    IF .SEARCH_FND THEN SEARCH_FLAG = TRUE;
    	                	    SRC_REC = .SRC_REC + 1;
    				    IF .SEARCH_FND AND
    				       ((.DBG$SRC_SEARCH_FLAG EQL SEARCH_IDENT_NEXT) OR
    				        (.DBG$SRC_SEARCH_FLAG EQL SEARCH_STRING_NEXT))
    				    THEN
    					EXITLOOP;

    	                	    END;
    	                    
    	            	        DSTPTR = .DSTPTR + 2;
    	            	        END;

    			    [INRANGE, OUTRANGE]:
    				SIGNAL(DBG$_DEBUGBUG, 1, 197);

    			    TES;

    			END;		! End of IF statement.

    		    END;		! End of DST$K_SRC_DEFSAME_W,
    					!        DST$K_SRC_DEFSAME_B,
    					!        DST$K_SRC_DEFUNNUM_W,
    					!        DST$K_SRC_DEFUNNUM_B commands.

    		[INRANGE, OUTRANGE]:
    		    SIGNAL(DBG$_DEBUGBUG, 1, 197);

    	        TES;

    	    END;			! End of WHILE Loop through commands.

    	END;				! End of INCR Loop through DST records.


    ! Check to see if the source file is declared in the Source File Correlation
    ! DST.
    !
    IF .SRC_FILEID_TBL EQL 0 
    THEN
    	SIGNAL(DBG$_INVDSTREC);


    ! Issue a warning message if no lines were typed out.  This situation occurs
    ! if the specified line numbers do not exist in this module.
    !
    IF NOT .TYPE_FLAG
    THEN
    	BEGIN
    	IF (.LOW_LNUM EQL .HIGH_LNUM) AND (.LOW_STMT EQL .HIGH_STMT)
    	THEN
    	    DBG$FAO_PUT(BUFFER, UPLIT BYTE(%ASCIC 'line '), 0)
    	ELSE
    	    DBG$FAO_PUT(BUFFER, UPLIT BYTE(%ASCIC 'lines '), 0);

	DBG$FAO_PUT(BUFFER, UPLIT BYTE(%ASCIC '!UL'), .LOW_LNUM);
    	IF .LOW_STMT NEQ 0
    	THEN
    	    DBG$FAO_PUT(BUFFER, UPLIT BYTE(%ASCIC '.!UL'), .LOW_STMT);

    	IF (.LOW_LNUM NEQ .HIGH_LNUM) OR (.LOW_STMT NEQ .HIGH_STMT)
    	THEN
    	    DBG$FAO_PUT(BUFFER, UPLIT BYTE(%ASCIC ':!UL'), .HIGH_LNUM);

    	IF .HIGH_STMT NEQ 0
    	THEN
    	    DBG$FAO_PUT(BUFFER, UPLIT BYTE(%ASCIC '.!UL'), .HIGH_STMT);

    	IF (.LOW_LNUM EQL .HIGH_LNUM) AND (.LOW_STMT EQL .HIGH_STMT)
    	THEN
    	    DBG$FAO_PUT(BUFFER, UPLIT BYTE(%ASCIC ' does'), 0)
    	ELSE
    	    DBG$FAO_PUT(BUFFER, UPLIT BYTE(%ASCIC ' do'), 0);

    	DBG$FAO_PUT(BUFFER, UPLIT BYTE(%ASCIC ' not exist in module !AC'),
    		    .MODNAMEPTR);
    	BUFFER[0] = .DBG$GL_BUF_SIZ;
    	IF .DBG$SRC_SEARCH_FLAG NEQ 0
    	THEN
    	    SIGNAL(DBG$_NOMATCH)
    	ELSE
    	    SIGNAL(DBG$_NOLINXXX, 1, BUFFER);
    	END;

    
    ! Check to see if any matches were found for the SEARCH command.
    !
    IF .TYPE_FLAG AND NOT .SEARCH_FLAG AND .DBG$SRC_SEARCH_FLAG NEQ 0
    THEN
    	SIGNAL(DBG$_NOMATCH);

    RETURN;

    END;

GLOBAL ROUTINE DBG$SRC_TYPE_PC_SOURCE(LOW_PC, HIGH_PC, MODPRTFLG): NOVALUE =
!
! FUNCTION
!	This routine accepts a range of Program Counter values and prints all
!	source lines which cover that PC range.  This assumes that both PC
!	values are located in the same module and that a line number is associ-
!	ated with each end of the PC range.  It also assums that the lower PC
!	value is associated with the lower line number of the range.  This
!	routine is called in the processing of the EXAMINE/SOURCE command and
!	does the source display in response to breakpoints, watchpoints, and
!	stepping by lines.
!
!	The routine calls DBG$PC_TO_LINE_LOOPUP for the two PC values to get the corre-
!	sponding line numbers.  If both PC values are the same (which is always
!	the case on breakpoints or when stepping), DBG$PC_TO_LINE_LOOKUP is only called
!	once.  The routine then checks that both PC values are in the same mod-
!	ule and signals an error if they are not.  It also signals an error if
!	one or the other PC value does not correspond to a line number or if the
!	line numbers they correspond to are not in the proper order.  Routine
!	DBG$SRC_TYPE_LNUM_SOURCE is then called to retrieve and type the source
!	images.
!
! INPUTS
!	LOW_PC	- The lower PC value of the address range whose source lines
!		  are to be displayed.
!
!	HIGH_PC	- The higher PC value of the address range whose source lines
!		  are to be displayed.  HIGH_PC must be greater than or equal
!		  to LOW_PC.
!
!	MODPRTFLG - Flag set to FALSE when the routine is called in reponse to
!                   breakpoints, watchpoints, and stepping by lines, so that the
!		    module name will not be printed.
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
    	BUFFER: VECTOR[140,BYTE],	! Output buffer for DBG$FAO_PUT
    	LLINE_END,			! Low End PC of the selected line/stmt
    	LLINE_NUM,			! Low line number
    	LLINE_START,			! Low Start PC of the selected line/stmt
    	LMODNAMEPTR,			! Low PC module name pointer
    	LOW_MODPTR : REF RST$ENTRY,	! Low PC module pointer
    	LSTMT_NUM,			! Low stmt number
    	HLINE_END,			! High End PC of the selected line/stmt
    	HLINE_NUM,			! High line number
    	HLINE_START,			! High Start PC of the selected line/stmt
    	HMODNAMEPTR,			! High PC module name pointer
    	HIGH_MODPTR,			! High PC module pointer
    	HSTMT_NUM,			! High stmt number
    	STATUS;				! return status from PC to LINE translation



    ! Check to see if the PC is an entry point, if it is then PC = PC + 2.
    ! Separately handle the case where LOW_PC = HIGH_PC, so that we only
    ! have to call IS_IT_ENTRY once.
    !
    !IF .HIGH_PC EQL .LOW_PC 
    !THEN
    !	BEGIN
    !    IF (DBG$IS_IT_ENTRY(.LOW_PC)) 
    !	THEN
    !	    BEGIN
    !	    LOW_PC = .LOW_PC + 2;
    !	    HIGH_PC = .LOW_PC;
    !	    END;
    !	END
    !
    !ELSE
    !	BEGIN
    !    IF (DBG$IS_IT_ENTRY(.LOW_PC)) THEN LOW_PC = .LOW_PC + 2;
    !    IF (DBG$IS_IT_ENTRY(.HIGH_PC)) THEN HIGH_PC = .HIGH_PC + 2;
    !	END;


    ! Ensure that higher PC value is greater than or equal to lower PC value.
    ! If it is wrong, signal an error and give up.
    !
    IF (.LOW_PC GTR .HIGH_PC) THEN SIGNAL(DBG$_EXARANGE);


    ! Set up the output buffer for the print routine (i.e., DBG$FAO_PUT).
    !
    DBG$CP_OUT_STR = BUFFER[1];
    DBG$GL_BUF_SIZ = 0;


    ! Match an absolute PC address to a line number.
    !
    STATUS = DBG$PC_TO_LINE_LOOKUP(.LOW_PC, LLINE_NUM, LSTMT_NUM, LLINE_START,
    			     	   LLINE_END, LOW_MODPTR);


    ! Check to see if any error or if match cannot be made in PC to LINE 
    ! translation.
    !
    IF NOT .STATUS
    THEN
    	BEGIN
    	IF .MODPRTFLG
    	THEN
    	    SIGNAL(DBG$_NOSRCLIN,1,.LOW_PC)
    	ELSE
    	    RETURN;

    	END;


    ! Get Module Name for lower PC value.
    !
    DBG$STA_SYMNAME(.LOW_MODPTR,LMODNAMEPTR);


    ! If two PC values are not the same, calls PC to LINE routine for the
    ! higher PC value to get the corresponding line number.  If both PC values
    ! are the same, set up parameters for routine TYPE_LNUM_SOURCE.
    !
    IF .LOW_PC EQL .HIGH_PC
    THEN
    	BEGIN
    	HLINE_NUM = .LLINE_NUM;
    	HSTMT_NUM = .LSTMT_NUM;
    	END
    ELSE
    	BEGIN
    	STATUS = DBG$PC_TO_LINE_LOOKUP(.HIGH_PC,HLINE_NUM,HSTMT_NUM,HLINE_START,
    				       HLINE_END,HIGH_MODPTR);


    	! Check to see if any error or if match cannot be made in PC to LINE
        ! translation.
    	!
    	IF NOT .STATUS
    	THEN
    	    BEGIN
    	    IF .MODPRTFLG
    	    THEN
    		SIGNAL(DBG$_NOSRCLIN,1,.HIGH_PC)
    	    ELSE
    	        RETURN;

    	    END;


        ! Get the Module Name for higher PC value.
        !
    	DBG$STA_SYMNAME(.HIGH_MODPTR,HMODNAMEPTR);


    	! Check that both PC values are in the same module.
    	!
    	IF .LOW_MODPTR NEQ .HIGH_MODPTR
    	THEN
    	    BEGIN
    	    IF .MODPRTFLG
    	    THEN
    		SIGNAL(DBG$_ADDRANCOV,4,.LOW_PC,.LMODNAMEPTR,.HIGH_PC,.HMODNAMEPTR)
    	    ELSE
    	        RETURN;

	    END;

    	END;		! End of matching high PC value to a line number.


    ! Check for the entry point.
    !
    IF (.LLINE_NUM EQL 0) AND (.HLINE_NUM EQL 0)
    THEN
    	BEGIN
    	IF .MODPRTFLG
    	THEN
    	    SIGNAL(DBG$_NOSRCLIN,1,.LOW_PC)
    	ELSE
    	    RETURN;

    	END;


    ! Make sure Module Source Table pointer in module's Module RST Entry
    ! points to a list of Source File DST Record Pointers.
    ! If not, then check whether we have reached this point through a step
    ! or breakpoint. In this case we do not want to signal an error, so
    ! we just return.
    !
    IF (.LOW_MODPTR[RST$L_MODSRCTBL] EQL 0) AND (NOT .MODPRTFLG)
    THEN
    	RETURN;


    ! Print out Module name if the flag is set to TRUE.
    !
    IF .MODPRTFLG
    THEN
    	BEGIN
    	DBG$FAO_PUT(BUFFER, UPLIT BYTE(%ASCIC 'module !AC'), .LMODNAMEPTR);
    	DBG$OUT_PUT(BUFFER);
    	END;


    ! Call TYPE_LNUM_SOURCE to type out the given source line number ranges.
    !
    DBG$SRC_TYPE_LNUM_SOURCE(.LOW_MODPTR, .LLINE_NUM, .LSTMT_NUM,
    			     .HLINE_NUM, .HSTMT_NUM, 0);

    RETURN;

    END;

ROUTINE OUTPUT_DIR_LIST (DIRPTR) : NOVALUE =
!
! FUNCTION
!	This routine outputs the Source Directory Search List 
!	for one module (or the default list) on the user's terminal.
!	It prints each directory name on a separate line, indented 
!	eight spaces. This routine is called during the SHOW SOURCE
!	command.
!
! INPUTS
!	DIRPTR	-	The first of a linked list of Source Directory
!			Search List Entries.
!
! OUTPUTS
!	NONE


    BEGIN
    MAP
    	DIRPTR : REF SDSL$ENTRY; 	! A pointer to a Source Directory
    					!	Search List Entry. This is
    					! 	used to walk through the
    					! 	linked list.
    LOCAL
    	BUFFER : VECTOR [140, BYTE]; 	! Holds the output for DBG$FAO_PUT



    ! Loop through the list, outputting the directory name in each Source
    ! Directory Search List Entry.
    !
    WHILE .DIRPTR NEQ 0 DO
    	BEGIN
    	DBG$CP_OUT_STR = BUFFER[1];
    	DBG$GL_BUF_SIZ = 0;
    	DBG$FAO_PUT (BUFFER, UPLIT BYTE(
    	    %ASCIC '        !AC'), DIRPTR[SDSL$B_ENT_DIRLEN]);
    	DBG$OUT_PUT (BUFFER);
    	DIRPTR = .DIRPTR[SDSL$L_ENT_FLINK];
    	END;

    RETURN;

    END;

END ELUDOM
