MODULE DBGNEXMNE (IDENT = 'V03-000') =

BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:
!
!	DEBUG
!
! ABSTRACT:
!
!	This module contains the parse and execution networks for the EXAMINE
!	verb. The parsing method employed is that of ATN's.
!
! ENVIRONMENT:
!
!	VAX/VMS
!
! AUTHOR:
!
!	David Plummer
!
! CREATION DATE:
!
!	7-2-80
!
! VERSION:
!
!	V02.2-001
!
! MODIFIED BY:
!	Richard Title	3-Jul-81
!
! REVISION HISTORY:
! 3.01	3-Jul-81	 RT	Put in calls to DBG$OUT_TYP_VAL for the
!				case where a type override is in effect
!				during the examine command. This means
!				that EX/FLOAT, EX/D_FLOAT, etc, are 
!				handled in a language-independent way.
! 3.02	17-Sep-81	 RT	Implemented EX/SOURCE. Also implemented
!				examine lists (e.g., EX A,B,C,D)
!--

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE	
	DBG$NPARSE_EXAMINE,			! Parse network
	DBG$NEXECUTE_EXAMINE,			! Execution network
	SYMBOLIZE_REGNAME 	: NOVALUE,	! Formats a register name
	DBG$NFORMAT_WITH_RADIX 	: NOVALUE;	! Formats a value with radix override

!
! REQUIRE FILES:
!

REQUIRE 'SRC$:DBGPROLOG.REQ';

REQUIRE 'SRC$:DBGGEN.REQ';
REQUIRE 'SRC$:SYSSER.REQ';

!
! EQUATED SYMBOLS:
!

LITERAL

	! Legal verb composites
	!
	EXAMINE			= 1,
	EXAMINE_INSTRUCTION	= 2,
	EXAMINE_REGISTER	= 3,
    	EXAMINE_SOURCE		= 4;

LITERAL	
	DUMMY_TYPE = dbg$k_notype;	! Used in type node

!
! OWN STORAGE:
!

!
! EXTERNAL REFERENCES:
!

EXTERNAL ROUTINE
	DBG$NPSEUDO_SYM_INT,			! Kernal pseudo symbol interpreter
	DBG$NSET_LAST_TYPLEN 	: NOVALUE, 	! Saves pseudo type and length
	DBG$NSAVE_LAST_LOC 	: NOVALUE,	! Saves '.'
	DBG$OUTPUT_PSL 		: NOVALUE,	! Outputs the PSL in special format
	DBG$OUT_NUM_VAL 	: NOVALUE,	! Outputs a numeric address
	DBG$OUT_TYP_VAL,			! Outputs contents of an address
						! according to a specified
						! type.
	DBG$OUT_PUT 		: NOVALUE,	! Outputs a formatted line
	DBG$FAO_PUT 		: NOVALUE,	! Formats an output line
    	DBG$SRC_TYPE_PC_SOURCE : NOVALUE,	! Implements EX/SOURCE
	DBG$NGET_RADIX,				! Obtains user set radix
	DBG$OUT_SYM_VAL,			! Symbolizes virtual addresses
	DBG$NGET_TRANS_RADIX,			! Returns real radix for dbg$k_default
	DBG$NGET_DEFAULT_TYPE 	: NOVALUE,	! Obtains default type
	DBG$NGET_TYPE,				! Obtains type of primary
	DBG$NGET_OVERRIDE_TYPE,			! Obtains override type
	DBG$NGET_POTENTIAL_TYPE,		! Returns potential type for current loc
	DBG$NGET_MODE,				! Returns true if SYMBOLS, false otherwise
	DBG$INS_DECODE,				! Decodes an instruction
	DBG$NGET_RVAL,				! Obtains a named constant's r value
	DBG$NGET_LVAL,				! Obtains a primary's lvalue
	DBG$NGET_LENGTH,			! Obtains a primary's rvalue length
	DBG$NGET_ADDRESS,			! Obtains an address from addr exp desc
	DBG$READ_ACCESS,			! Probes for read access of virtual address
	DBG$NPARSE_ADDRESS,			! Interface to Address Expression Interpreter
	DBG$NLIST_FREEZ,			! Allocates dynamic listed storage
	DBG$NMATCH,				! Matches input to counted strings
	DBG$NSAVE_DECIMAL_INTEGER,		! Converts user input to integer
	DBG$NMAKE_ARG_VECT,			! Creates a message arguent vector
	DBG$NSYNTAX_ERROR,			! Formats a syntax error
	DBG$NNEXT_WORD,				! Obtains next word of input
	DBG$SET_MOD_LVL,			! Sets MODE pointer
	DBG$NMAKE_VAL_DESC,			! Constructs a value descriptor
	DBG$NTYPE_CONV,				! Type converter
	DBG$NSYMBOLIZE,				! Symbolizes from a primary descriptor
	DBG$NPRIM_OUT;				! Outputs a primary descriptor

EXTERNAL
	DBG$GL_CMND_RADIX,		     	! Holds radix of command
	DBG$GB_MOD_PTR : REF VECTOR [,BYTE], 	! Pointer to MODE structure
	DBG$CP_OUT_STR : REF VECTOR [,BYTE], 	! Points to current output buffer
	DBG$GL_BUF_SIZ;			     	! Holds character count of output buffer


GLOBAL ROUTINE DBG$NPARSE_EXAMINE (INPUT_DESC, VERB_NODE, MESSAGE_VECT) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	ATN parse network for the EXAMINE verb. The network constructs a command
!	execution tree consisting of a linked list of command operands which the
!	execution network accepts as input to perform the command.
!
!	Three adverb nodes are ALWAYS created and linked. They are in the order:
!
!	1) Type node 	- This node contains override or default type info. It may
!			  have the value of dummy_type when the source of the
!			  EXAMINE is described by a primary descriptor and
!			  no override type has been specified.
!
!	2) Radix node   - The radix to be used in outputting the value. DBG$K_DEFAULT
!			  is translated to the real radix.
!			  
!
!	3) Mode node	- Either true or false. True means symbolic output. False
!			  means no symbolic output.
!
! FORMAL PARAMETERS:
!
!	INPUT_DESC		- A longword containing the address of the command
!				  input descriptor
!
!	VERB_NODE		- A longword containing the address of the command
!				  execution tree verb (head) node
!
!	MESSAGE_VECT		- The address of a longword to contain the address
!				  of a standard message argument vector on errors
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	On success, the command execution tree is constructed.
!
!	On failure, a message argument vector is constructed or obtained.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	sts$k_success (1)	- Success. Command execution tree constructed.
!
!	sts$k_severe  (4)	- Failure. Error encountered. Message argument
!				  constructed and returned.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
    	INPUT_DESC	: REF BLOCK [ ,BYTE],
	VERB_NODE 	: REF dbg$verb_node;

    BIND			

        ! Strings used at this level of parsing
	!
	DBG$CS_INSTRUCTION 	= UPLIT BYTE (11, 'INSTRUCTION'),
	DBG$CS_SYMBOLS		= UPLIT BYTE (8, 'SYMBOLIC'),
	DBG$CS_NOSYMBOLS	= UPLIT BYTE (10, 'NOSYMBOLIC'),
	DBG$CS_OCTAL		= UPLIT BYTE (5, 'OCTAL'),
	DBG$CS_DECIMAL		= UPLIT BYTE (7, 'DECIMAL'),
	DBG$CS_HEXADECIMAL	= UPLIT BYTE (11, 'HEXADECIMAL'),
	DBG$CS_ASCII		= UPLIT BYTE (5, 'ASCII'),
	DBG$CS_BYTE		= UPLIT BYTE (4, 'BYTE'),
	DBG$CS_WORD		= UPLIT BYTE (4, 'WORD'),
	DBG$CS_LONGWORD		= UPLIT BYTE (8, 'LONG'),
	DBG$CS_QUADWORD		= UPLIT BYTE (8, 'QUADWORD'),
	DBG$CS_OCTAWORD		= UPLIT BYTE (8, 'OCTAWORD'),
	DBG$CS_FLOAT		= UPLIT BYTE (5, 'FLOAT'),
	DBG$CS_F_FLOAT		= UPLIT BYTE (7, 'F_FLOAT'),
	DBG$CS_D_FLOAT		= UPLIT BYTE (7, 'D_FLOAT'),
	DBG$CS_G_FLOAT		= UPLIT BYTE (7, 'G_FLOAT'),
	DBG$CS_H_FLOAT		= UPLIT BYTE (7, 'H_FLOAT'),
    	DBG$CS_SOURCE		= UPLIT BYTE (6, 'SOURCE'),
    	DBG$CS_COMMA		= UPLIT BYTE (1, dbg$k_comma),
	DBG$CS_COLON		= UPLIT BYTE (1, dbg$k_colon),
	DBG$CS_SLASH		= UPLIT BYTE (1, dbg$k_slash),
	DBG$CS_CR		= UPLIT BYTE (1, dbg$k_car_return);

    LOCAL
	ADDR_EXP_DESC 		: REF dbg$aed,		! Address expression descriptor
	NOUN_NODE 		: REF dbg$noun_node, 	! Object
    	NEW_NOUN_NODE		: REF dbg$noun_node,    
    	ADVERB_NODE 		: REF dbg$adverb_node,	! Adverb
	LINK,						! Pointer
	RADIX,						! Radix for numeric literals
	TYPE,						! Type of source
	SYMBOL_FLAG,					! IF true then SYMBOLIC EXAMINE
    	LOWER_PC_FLAG,					! TRUE if we are parsing
    							! the lower pc in the
    							! pc range.
    	SOURCE_FLAG,					! TRUE for EX/SOURCE
	LENGTH,						! Length of source
	ADDRESS 		: VECTOR [2],		! Address of source
	STATUS;						! Return status

    ! Create and link a noun node to contain the target
    !
    IF NOT dbg$nlist_freez (dbg$k_noun_node_size, noun_node, .message_vect)
    THEN
	RETURN sts$k_severe;

    verb_node [dbg$l_verb_object_ptr] = .noun_node;


    ! Initialize target type and length 
    !
    type = -1;		! -1 indicates that we have not found an override type
    length = 0;


    ! Initialize the symbolic - nosymbolic flag and source flag
    !
    symbol_flag = dbg$nget_mode ();
    source_flag = FALSE;

    ! Initialize the lower_pc flag
    !
    lower_pc_flag = TRUE;

    ! Initialize the radix.
    !
    radix = dbg$nget_radix ();


    ! Accept any command switches. We start out with a verb composite representing
    ! a plain EXAMINE. This may change as a result of command or user set overrides.
    ! We changes the composite to EXAMINE_INSTRUCTION if we find /INSTRUCTION.
    !
    verb_node [dbg$b_verb_composite] = examine;

    WHILE dbg$nmatch (.input_desc, dbg$cs_slash, 1)
    DO
	BEGIN
	SELECTONE true
	    OF
	    SET

	    [dbg$nmatch (.input_desc, dbg$cs_instruction, 1)] : 
		BEGIN
		type = dsc$k_dtype_zi;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_byte, 1)] :
		BEGIN
		type = dsc$k_dtype_b;
		length = byte_length;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_word, 1)] : 
		BEGIN
		type = dsc$k_dtype_w;
		length = word_length;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_longword, 1)] : 
		BEGIN
		type = dsc$k_dtype_l;
		length = long_length;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_ascii, 1)] : 
		BEGIN

		! Accept the ':' and integer. If there is no colon, we assume
		! a length of 4
		!
		IF NOT dbg$nmatch (.input_desc, dbg$cs_colon, 1)
		THEN
		    BEGIN
		    length = 4;
		    END
		ELSE
		    BEGIN

		    ! We found the colon. Accept the integer
		    !
		    IF NOT dbg$nsave_decimal_integer (.input_desc, length, .message_vect)
		    THEN
		    	RETURN sts$k_severe;
		    END;

		type = dsc$k_dtype_t;


		! Check to see that the length of the ascii examine is not 0
		!
		IF .length LEQ 0
	  	THEN
		    BEGIN
		    OWN
			num_desc : dbg$stg_desc;

		    num_desc [dsc$w_length] = 1;
		    num_desc [dsc$a_pointer] = UPLIT TYPE ('0');
		    .message_vect = dbg$nmake_arg_vect (dbg$_invnumber, 1, num_desc);
		    RETURN sts$k_severe;
		    END;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_octal, 1)] : 
		BEGIN
		radix = dbg$k_octal;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_decimal, 1)] : 
		BEGIN
		radix = dbg$k_decimal;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_hexadecimal, 1)] : 
		BEGIN
		radix = dbg$k_hex;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_symbols, 1)] :
		BEGIN
		symbol_flag = true;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_nosymbols, 1)] :
		BEGIN
		symbol_flag = false;
		END;

    	    [dbg$nmatch (.input_desc, dbg$cs_source, 2)] : ! EX/SOURCE
    		BEGIN
    		source_flag = TRUE;
    		END;

	    [dbg$nmatch (.input_desc, dbg$cs_quadword, 1)] :
		BEGIN
		type = dsc$k_dtype_q;
		length = 8;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_octaword, 5)] :
		BEGIN
		type = dsc$k_dtype_o;
		length = 16;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_float, 1),
	     dbg$nmatch (.input_desc, dbg$cs_f_float, 1)] :
		BEGIN
		type = dsc$k_dtype_f;
		length = 4;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_d_float, 2)] :
		BEGIN
		type = dsc$k_dtype_d;
		length = 8;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_g_float, 1)] :
		BEGIN
		type = dsc$k_dtype_g;
		length = 8;
		END;

	    [dbg$nmatch (.input_desc, dbg$cs_h_float, 1)] :
		BEGIN
		type = dsc$k_dtype_h;
		length = 16;
		END;

	    [OTHERWISE] :	! Some flavor of user error
		BEGIN
		.message_vect =
		( IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
		  THEN
		      dbg$nmake_arg_vect (dbg$_needmore)
		  ELSE
		      dbg$nsyntax_error (dbg$nnext_word (.input_desc)));
		RETURN sts$k_severe;
		END;
	    
	    TES;

	END;


    ! Check for EXAMINE <CR>. If this is the case, we call the pseudo symbol
    ! interpreter to find the meaning of successor ourselves.
    !
    IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
    THEN
	BEGIN
	LOCAL
	    AE_DESC	: REF dbg$aed,	! Address expression descriptor
	    SYMBOL_TYPE,
	    SYMBOL_VALUE,
	    TYPE,
	    LENGTH;

	! Have to construct our own address expression descriptor
	!
	IF NOT dbg$nlist_freez (dbg$k_aed_size, ae_desc, .message_vect)
	THEN
	    RETURN sts$k_severe;


	! Call the PSI to get the successor
	!
	IF NOT dbg$npseudo_sym_int (dbg$k_successor,
				    symbol_type,
				    symbol_value,
				    type,
				    length,
				    .message_vect)
	THEN
	    RETURN sts$k_severe;


	! Store the type and length of the pseudo
	!
	dbg$nset_last_typlen (.type, .length);


	! Fill in our address expression descriptor and link it.
	!
	ae_desc [dbg$b_aed_type] = .symbol_type;
	ae_desc [dbg$l_aed_value] = .symbol_value;
	noun_node [dbg$l_noun_value] = .ae_desc;
    	noun_node [dbg$l_noun_value2] = .ae_desc;
	END
    ELSE

    	! Loop through the examine list

    	WHILE TRUE DO 
    	    BEGIN

    	    ! Check for exhausted input

    	    IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
    		OR .input_desc[dsc$w_length] EQL 0
    	    THEN
    		BEGIN

    		! Fill in high line num if it was not specified

    		IF .lower_pc_flag
    		THEN
    		    noun_node[dbg$l_noun_value2] =
    			.noun_node[dbg$l_noun_value];

  	        EXITLOOP;

    		END;

    	    ! Input left. Let the AEI deal with it.
    	    !
            IF .lower_pc_flag 
            THEN
            status = dbg$nparse_address (.input_desc, noun_node [dbg$l_noun_value],
				     .radix,
				     .message_vect)
    	    ELSE
            status = dbg$nparse_address (.input_desc, noun_node [dbg$l_noun_value2],
    				     .radix,
    				     .message_vect);

            IF .status NEQ sts$k_success
	    THEN
	   	IF .status EQL sts$k_warning
	    	THEN
    		    BEGIN
    	
    		    ! Check for comma.

    		    IF dbg$nmatch (.input_desc, dbg$cs_comma, 1)
    		    THEN

    		    	BEGIN

        		! Fill in high line num if it was not specified
    			!
    			IF .lower_pc_flag
    			THEN
    		    	    noun_node[dbg$l_noun_value2] =
    				.noun_node[dbg$l_noun_value];

    			! Check for end of line after the comma.
    			!
    			IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
    			THEN
    			    BEGIN
    			    .message_vect = dbg$nmake_arg_vect (dbg$_needmore);
    			    RETURN sts$k_severe;
    			    END;
    	
    		    	! Link in another noun node
    			!
    		    	IF NOT dbg$nlist_freez (dbg$k_noun_node_size,
    			    new_noun_node, .message_vect)
    		    	THEN
    			    RETURN sts$k_severe;
    		    	noun_node[dbg$l_noun_link] = .new_noun_node; 

    		        noun_node = .new_noun_node;

    		    	! set lower_pc_flag back to true for the next
    		    	! pc range in the list.
    		    	lower_pc_flag = TRUE;

   		    	END

    		    ELSE
    		    	IF .lower_pc_flag
    		    	THEN
        	            IF dbg$nmatch (.input_desc, dbg$cs_colon, 1)
    		            THEN
    			    	lower_pc_flag = FALSE
    		        ELSE
    			    BEGIN
    			    .message_vect = dbg$nsyntax_error(
    			    	dbg$nnext_word (.input_desc));
    			    RETURN sts$k_severe;
    			    END;

    		    END ! check for comma
    
    	    	ELSE
    		    RETURN sts$k_severe;

        ! Set up for next time around loop

        END; ! While loop


    ! The first adverb node we set up is the type node. We start by setting up a
    ! dummy type. If we find a real type, we change the adverb value.
    !
    ! We check to see if type is instruction. If so, we change the verb
    ! composite to an EXAMINE_INSTRUCTION.
    !
    ! Override types and default types apply, as well as command override
    ! types.
    !
    IF NOT dbg$nlist_freez (dbg$k_adverb_node_size, adverb_node, .message_vect)
    THEN
	RETURN sts$k_severe;

    verb_node [dbg$l_verb_adverb_ptr] = .adverb_node;
    adverb_node [dbg$b_adverb_literal] = dummy_type;


    ! Obtain the address expression descriptor
    !
    addr_exp_desc = .noun_node [dbg$l_noun_value];


    ! Check for command override
    !
    IF .type NEQ -1
    THEN
	BEGIN
	    
	! Check for instruction examine
	!
	IF .type EQL dsc$k_dtype_zi
	THEN
	    BEGIN
	    verb_node [dbg$b_verb_composite] = examine_instruction;
	    END
	ELSE
	    BEGIN
	    adverb_node [dbg$b_adverb_literal] = .type;
	    adverb_node [dbg$l_adverb_value] = .length;
	    END;
	END

    ELSE
	BEGIN

	! There was no command override. Check for a type/override.
	!
	IF dbg$nget_override_type (type, length)
	THEN
	    BEGIN

	    ! Check for instruction override
	    !
	    IF .type EQL dsc$k_dtype_zi
	    THEN
		BEGIN
		verb_node [dbg$b_verb_composite] = examine_instruction;
		END
	    ELSE
		BEGIN
		adverb_node [dbg$b_adverb_literal] = .type;
		adverb_node [dbg$l_adverb_value] = .length;
		END;
	    END
	ELSE
	    BEGIN

	    ! There was no type override. We supply a type based on the contents
	    ! of the address expression descriptor, current location type,
	    ! and/or default type. We may also change the verb composite value.
	    !
	    ! Check for a current loc type. If this is other than 0 or notype,
	    ! then we use this type for display.
	    !
	    dbg$nget_potential_type (type, length);

	    IF .type NEQ dbg$k_notype AND .type NEQ 0
	    THEN
		BEGIN

		! If an instruction, then change the verb composite.
		!
		IF .type EQL dsc$k_dtype_zi
		THEN
		    BEGIN
		    verb_node [dbg$b_verb_composite] = examine_instruction;
		    END
		ELSE
		    BEGIN
		    adverb_node [dbg$b_adverb_literal] = .type;
		    adverb_node [dbg$l_adverb_value] = .length;
		    END;
		END
	    ELSE
		BEGIN

		! No type on current location. Use the contents of the address
		! expression descriptor to type the source location.
		!
		CASE .addr_exp_desc [dbg$b_aed_type] FROM dbg$k_primary_desc TO dbg$k_notype
		    OF
		    SET

		    [dbg$k_primary_desc] :
			BEGIN
			
			! Check for nc_other and nc_instruction
			!
			IF NOT dbg$nget_type (.addr_exp_desc [dbg$l_aed_value],
					      type, .message_vect)
			THEN
			    RETURN sts$k_severe;

			IF .type EQL dbg$k_nc_instruction
			THEN
			    BEGIN
			    verb_node [dbg$b_verb_composite] = examine_instruction;
			    END
			ELSE
			    BEGIN
			    IF .type EQL dbg$k_nc_other
			    THEN
				BEGIN

				! Attach the default type,and cancel symbol flag
				! since we don't symbolize name constants
				!
				symbol_flag = false;
				dbg$nget_default_type (type, length);

				IF .type EQL dsc$k_dtype_zi
				THEN
				    BEGIN
				    verb_node [dbg$b_verb_composite] = examine_instruction;
				    END
				ELSE
				    BEGIN
				    adverb_node [dbg$b_adverb_literal] = .type;
				    adverb_node [dbg$l_adverb_value] = .length;
				    END;
				END;
			    END;
			END;

		    [dbg$k_perm_desc] :
			BEGIN
			verb_node [dbg$b_verb_composite] = examine_register;
			END;

		    [dbg$k_instruction] :
			BEGIN
			verb_node [dbg$b_verb_composite] = examine_instruction;
			END;

		    [dbg$k_notype] :
			BEGIN

			! We have an untyped virtual address. Use the default type.
			!
			dbg$nget_default_type (type, length);

			IF .type EQL dsc$k_dtype_zi
			THEN
			    BEGIN
			    verb_node [dbg$b_verb_composite] = examine_instruction;
			    END
			ELSE
			    BEGIN
			    adverb_node [dbg$b_adverb_literal] = .type;
			    adverb_node [dbg$l_adverb_value] = .length;
			    END;
			END;

		    [INRANGE, OUTRANGE] :
			BEGIN
			SIGNAL (dbg$_debugbug, 1, dbg$k_bad_aed_field);
			RETURN sts$k_severe;
			END;

		    TES;
		END;
	    END;
	END;

    
    ! The adverb type node has been set up, and the command has been classified as
    ! either EXAMINE, EXAMINE_INSTRUCTION, or EXAMINE_REGISTER. The source has
    ! been placed in the first noun node. Now we construct adverb nodes for 
    ! radix and mode.
    !
    link = adverb_node [dbg$l_adverb_link];
    IF NOT dbg$nlist_freez (dbg$k_adverb_node_size, adverb_node, .message_vect)
    THEN
	RETURN sts$k_severe;

    .link = .adverb_node;


    ! Fill in the radix value.
    !
    adverb_node [dbg$b_adverb_literal] = dbg$nget_trans_radix (.radix);
					 

    ! Create as adverb node for the mode (symbolic or nosymbolic).
    !
    link = adverb_node [dbg$l_adverb_link];
    IF NOT dbg$nlist_freez (dbg$k_adverb_node_size, adverb_node, .message_vect)
    THEN
	RETURN sts$k_severe;

    .link = .adverb_node;
    adverb_node [dbg$b_adverb_literal] = .symbol_flag;

    IF .source_flag
    THEN
    	verb_node[dbg$b_verb_composite] = examine_source;

    RETURN sts$k_success;

    END;			! End of dbg$nparse_examine


GLOBAL ROUTINE DBG$NEXECUTE_EXAMINE (VERB_NODE, MESSAGE_VECT) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine performs the action associated with EXAMINE xxx.
!
!	We always get three adverb nodes linked to the verb node. See the
!	routine header for dbg$nparse_examine above for details.
!
! FORMAL PARAMETERS:
!
!	VERB_NODE		- A longword containing the address of the command
!				  execution tree verb (head) node
!
!	MESSAGE_VECT		- The address of a longword to contain the address
!				  of a standard message argument vector for errors
!
! IMPLICIT INPUTS:
!
!	The entire command execution tree linked list.
!
! IMPLICIT OUTPUTS:
!
!	The object of the EXAMINE is displayed to the user.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	sts$k_success (1)	- Success. Command executed.
!
!	sts$k_severe  (4)	- Failure. The command could not be executed. Message
!				  argument vector constructed and returned.
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN

    MAP
	VERB_NODE 	: REF dbg$verb_node;
	
    BIND
	COLON		= UPLIT BYTE ( %ASCIC ':  '),
	AC		= UPLIT BYTE ( %ASCIC '!AC'),
	AS		= UPLIT BYTE ( %ASCIC '!AS'),
	NO_SUPPORT 	= UPLIT BYTE (17, 'full verb support'); 

    LOCAL
	OUTPUT_BUFFER	: VECTOR [tty_out_width,BYTE],
	STRING_DESC 	: dbg$stg_desc,
	NOUN_NODE 	: REF dbg$noun_node,
	TYPE_NODE 	: REF dbg$adverb_node,
	RADIX_NODE 	: REF dbg$adverb_node,
	MODE_NODE 	: REF dbg$adverb_node,
	ADDR_EXP_DESC 	: REF dbg$aed,
	VALUE_PTR,
	ADDRESS		: VECTOR [2],
	LENGTH,
	TYPE;


    ! Recover the noun node
    !
    noun_node = .verb_node [dbg$l_verb_object_ptr];


    ! Recover the three adverb nodes
    !
    type_node = .verb_node [dbg$l_verb_adverb_ptr];
    radix_node = .type_node [dbg$l_adverb_link];
    mode_node = .radix_node [dbg$l_adverb_link];
    dbg$gl_cmnd_radix = .radix_node [dbg$b_adverb_literal];


    ! Initialize the string descriptor
    !
    string_desc [dsc$b_class] = dsc$k_class_s;
    string_desc [dsc$b_dtype] = dsc$k_dtype_t;
    string_desc [dsc$w_length] = 0;
    string_desc [dsc$a_pointer] = 0;

    ! Loop through the examine list

    WHILE TRUE DO
    BEGIN

    ! Recover the address expression descriptor
    !
    addr_exp_desc = .noun_node [dbg$l_noun_value];

    ! Set up to do standard DEBUG output
    !
    dbg$cp_out_str = output_buffer [1];
    dbg$gl_buf_siz = 0;

    ! Check for instruction EXAMINE, data EXAMINE, or PSL EXAMINE
    !
    CASE .verb_node [dbg$b_verb_composite] FROM examine to examine_source
	OF
	SET

	[examine] :	! data EXAMINE
	    BEGIN

	    ! Output the object described by the address expression descriptor
	    ! based on the mode, override type and radix nodes.
	    !
	    SELECTONE true
	    	OF
	    	SET

		[.mode_node [dbg$b_adverb_literal]			! Symbols
	 		AND
	 	.type_node [dbg$b_adverb_literal] EQL dummy_type  	! No type override
			AND
	 	.radix_node [dbg$b_adverb_literal] EQL dbg$nget_trans_radix (dbg$k_default) ] :

		    BEGIN

	    	    ! This is the case that we will have 90% of the time - a
		    ! primary descriptor with no overrides of any sort.
		    ! We just let Primary Out do its thing.
		    !
	    	    IF NOT dbg$nprim_out (.addr_exp_desc [dbg$l_aed_value], 
					  string_desc,
				  	  .message_vect)
	    	    THEN
			RETURN sts$k_severe;


	    	    ! Place the string into the output buffer
		    !
	   	    dbg$fao_put (output_buffer, AS, string_desc);
	    	    END;



		[.mode_node [dbg$b_adverb_literal]			! Symbols
	 		AND
	 	.type_node [dbg$b_adverb_literal] EQL dummy_type  	! No type override
			AND
	 	.radix_node [dbg$b_adverb_literal] NEQ dbg$nget_trans_radix (dbg$k_default) ] :

		    BEGIN

		    ! We have a primary descriptor with no type override, but
		    ! there is a radix override. Obtain symbolic information.
		    !
		    IF NOT dbg$nsymbolize (.addr_exp_desc [dbg$l_aed_value],
					   string_desc,
					   .message_vect)
		    THEN
			RETURN sts$k_severe;


		    ! Encode the symbolic info into the output buffer and follow
		    ! it with a ': '.
		    !
		    dbg$fao_put (output_buffer, AS, string_desc);
		    dbg$fao_put (output_buffer, AC, COLON);


		    ! Obtain the starting byte address and offset
		    !
		    IF NOT dbg$nget_lval (.addr_exp_desc [dbg$l_aed_value],
					  address [0],
					  .message_vect)
		    THEN
			RETURN sts$k_severe;


		    ! Obtain the rvalue length
		    !
		    IF NOT dbg$nget_length (.addr_exp_desc [dbg$l_aed_value],
					    length,
					    .message_vect)
		    THEN
			RETURN sts$k_severe;


		    ! Encode the value into the output stream
		    !
		    dbg$nformat_with_radix (.address [0],
				       .address [1],
				       .length,
				       .radix_node [dbg$b_adverb_literal],
				       output_buffer);
		    END;

				    

		[NOT .mode_node [dbg$b_adverb_literal]			! No symbolic
			AND
	 	.type_node [dbg$b_adverb_literal] EQL dummy_type	! No type override
			AND
	 	.radix_node [dbg$b_adverb_literal] EQL dbg$nget_trans_radix (dbg$k_default)] :

	    	    BEGIN

	    	    ! We have a primary descriptor but we don't want symbolic output.
	    	    ! Obtain the address we are going to display.
		    !
	    	    IF NOT dbg$nget_address (.addr_exp_desc, address [0], 
					     type, .message_vect)
	    	    THEN
			RETURN sts$k_severe;


	    	    ! Encode the address into the output buffer, using the correct radix
		    !
	    	    dbg$out_num_val (output_buffer, 
				     .address [0], 
				     long_length,
			     	     .radix_node [dbg$b_adverb_literal],
			     	     true);


	    	    ! Get a value descriptor for the primary descriptor
		    !
	    	    IF NOT dbg$nmake_val_desc (.addr_exp_desc [dbg$l_aed_value],
					       false,	! Not requesting a target descriptor
				       	       value_ptr,
				       	       .message_vect)
	    	    THEN
			RETURN sts$k_severe;


	    	    ! Turn the value descriptor to printable format
		    !
	    	    IF NOT dbg$ntype_conv (.value_ptr, dbg$k_default, 
					   dbg$k_external_desc, string_desc,
				   	   .message_vect)
	    	    THEN
			RETURN sts$k_severe;


	    	    ! Encode  ': ' into the output buffer, followed by the string
	    	    ! produced by the type converter.
		    !
	    	    dbg$fao_put (output_buffer, AC, COLON);
	    	    dbg$fao_put (output_buffer, AS, string_desc);
	    	    END;


		[NOT .mode_node [dbg$b_adverb_literal]			! No symbolic
			AND
	 	.type_node [dbg$b_adverb_literal] EQL dummy_type	! No type override
			AND
	 	.radix_node [dbg$b_adverb_literal] NEQ dbg$nget_trans_radix (dbg$k_default)] :

	    	    BEGIN

	    	    ! We have a primary descriptor but we don't want symbolic output.
	    	    ! Obtain the address we are going to display.
		    !
	    	    IF NOT dbg$nget_address (.addr_exp_desc, address [0], 
					     type, .message_vect)
	    	    THEN
			RETURN sts$k_severe;


	    	    ! Encode the address into the output buffer, using the correct radix
		    !
	    	    dbg$out_num_val (output_buffer, 
				     .address [0], 
				     long_length,
			     	     .radix_node [dbg$b_adverb_literal],
			     	     true);


		    ! Encode ': ' 
		    !
		    dbg$fao_put (output_buffer, AC, COLON);


		    ! Obtain the rvalue length
		    !
		    IF NOT dbg$nget_length (.addr_exp_desc [dbg$l_aed_value],
					    length,
					    .message_vect)
		    THEN
			RETURN sts$k_severe;


		    ! Format the rvalue
		    !
		    dbg$nformat_with_radix (.address [0], 
				       .address [1],
				       .length,
				       .radix_node [dbg$b_adverb_literal],
				       output_buffer);
		    END;



	    	[.mode_node [dbg$b_adverb_literal]			! Symbolic
			AND
	         .type_node [dbg$b_adverb_literal] NEQ dummy_type] :    ! Type override
		    BEGIN

		    ! We have an override type associated with the source of the EXAMINE
		    ! The address expression descriptor may point to a primary
		    ! descriptor, a virtual address, or a permanent symbol descriptor.
		    ! Output on the basis of the addr_exp_desc type.
		    !
		    IF .addr_exp_desc [dbg$b_aed_type] EQL dbg$k_primary_desc
		    THEN
			BEGIN
			
			! Call symbolize to get symbolic information
			!
			IF NOT dbg$nsymbolize (.addr_exp_desc [dbg$l_aed_value],
					       string_desc,
					       .message_vect)
		 	THEN
			    RETURN sts$k_severe;

		        ! Encode the symbolic info into the output buffer
			!
			dbg$fao_put (output_buffer, AS, string_desc);
			END
		    ELSE
			BEGIN

			! We don't have a primary descriptor.
			! Get the address we are to format. Note that we
			! do NOT symbolize, unless we have a permanent symbol
			!
			IF NOT dbg$nget_address (.addr_exp_desc,
						 address [0],
						 type,
						 .message_vect)
			THEN
			    RETURN sts$k_severe;


			! Format the address
			!
			IF .addr_exp_desc [dbg$b_aed_type] EQL dbg$k_perm_desc
			THEN
			    BEGIN
			    symbolize_regname (output_buffer, .addr_exp_desc [dbg$l_aed_value]);
			    END
			ELSE
			    BEGIN
			    dbg$out_num_val (output_buffer,
			 		     .address [0],
					     long_length,
					     .radix_node [dbg$b_adverb_literal],
					     true); ! Unsigned output
			    END;

			END;


		    ! Place the ':  '.
		    !
		    dbg$fao_put (output_buffer, AC, COLON);


		    ! Obtain the address for the examine and check for read access.
		    !
		    IF NOT dbg$nget_address (.addr_exp_desc,
					     address [0],
					     type,
					     .message_vect)
		    THEN
			RETURN sts$k_severe;

		    IF NOT dbg$read_access (.address [0], 
					    .type_node [dbg$l_adverb_value], ! Length
					    .message_vect)
		    THEN
			RETURN sts$k_severe;


		    ! Format the contents of the address. Check for ASCII.
		    !
		    IF .type_node [dbg$b_adverb_literal] EQL dsc$k_dtype_t
		    THEN
			BEGIN
			string_desc [dsc$w_length] = .type_node [dbg$l_adverb_value];
			string_desc [dsc$a_pointer] = .address [0];
			dbg$fao_put (output_buffer, AS, string_desc);
			END
		    ELSE
			BEGIN
			! Output the contents of the address according to
			! the type in type_node.
			! Since the user has given a type override, we
			! output the address in a language-independent
			! way, using the 'old debugger' routine 
			! dbg$out_typ_val.

			! The 'old debugger' looks at the radix 
			! in dbg$gb_mod_ptr, while the 'new debugger'
			! looks at the radix_node. The following is
			! a hack to get the old debugger routine
			! dbg$out_typ_val to use the correct radix.

			LOCAL
			    save_radix;
			save_radix = .dbg$gb_mod_ptr[mode_radix];
			dbg$gb_mod_ptr[mode_radix] = 
			     .radix_node[dbg$b_adverb_literal];
			
		    	dbg$out_typ_val (output_buffer,
					 .address [0],
				         .type_node [dbg$b_adverb_literal]);

			! restore old radix
			dbg$gb_mod_ptr[mode_radix] = .save_radix;
			END;
		    END;



		[NOT .mode_node [dbg$b_adverb_literal]	 	       ! No symbols
				AND
		 .type_node [dbg$b_adverb_literal] NEQ dummy_type] :   ! Type override
		    BEGIN

		    ! No symbolic output wanted, and we are overriding the type
		    ! Resymbolize permanent symbols.
		    !
		    IF NOT dbg$nget_address (.addr_exp_desc,
					     address [0],
					     type,
					     .message_vect)
		    THEN
			RETURN sts$k_severe;


		    ! Encode the address
		    !
		    IF .addr_exp_desc [dbg$b_aed_type] EQL dbg$k_perm_desc
		    THEN
			BEGIN
			symbolize_regname (output_buffer, .addr_exp_desc [dbg$l_aed_value]);
			END
		    ELSE
			BEGIN
		        dbg$out_num_val (output_buffer,
				         .address [0],
				         long_length,
				         .radix_node [dbg$b_adverb_literal],
				         true); 	! We want unsigned output
			END;
	

		    ! Check for read access
		    !
		    IF NOT dbg$read_access (.address [0], 
					    .type_node [dbg$l_adverb_value], ! Length
					    .message_vect)
		    THEN
		        RETURN sts$k_severe;


		    ! Place the ':  '
		    !
		    dbg$fao_put (output_buffer, AC, COLON);


		    ! Format the contents of the address. Check for ASCII.
		    !
		    IF .type_node [dbg$b_adverb_literal] EQL dsc$k_dtype_t
		    THEN
			BEGIN
			string_desc [dsc$w_length] = .type_node [dbg$l_adverb_value];
			string_desc [dsc$a_pointer] = .address [0];
			dbg$fao_put (output_buffer, AS, string_desc);
			END
		    ELSE
			BEGIN
			! Output the contents of the address according to
			! the type in type_node.
			! Since the user has given a type override, we
			! output the address in a language-independent
			! way, using the 'old debugger' routine 
			! dbg$out_typ_val.

			! The 'old debugger' looks at the radix 
			! in dbg$gb_mod_ptr, while the 'new debugger'
			! looks at the radix_node. The following is
			! a hack to get the old debugger routine
			! dbg$out_typ_val to use the correct radix.

			LOCAL
			    save_radix;
			save_radix = .dbg$gb_mod_ptr[mode_radix];
			dbg$gb_mod_ptr[mode_radix] = 
			     .radix_node[dbg$b_adverb_literal];
			
		    	dbg$out_typ_val (output_buffer,
					 .address [0],
				         .type_node [dbg$b_adverb_literal]);

			! restore old radix
			dbg$gb_mod_ptr[mode_radix] = .save_radix;
			END;
		    END;



		[OTHERWISE] :	
		    BEGIN
		    .message_vect = dbg$nmake_arg_vect (dbg$_notimplan, 1, no_support);
		    RETURN sts$k_severe;
		    END;

		TES;


	    ! Save current location. If a type modifier has been given, use it
	    ! and associated length as overrides.
	    !
	    IF .type_node [dbg$b_adverb_literal] EQL dummy_type
	    THEN
		BEGIN

		! No override type and length
		!
		dbg$nsave_last_loc (.addr_exp_desc, -1, -1);
		END

	    ELSE
		BEGIN

		! Override type and length
		!
		dbg$nsave_last_loc (.addr_exp_desc,
				    .type_node [dbg$b_adverb_literal],
				    .type_node [dbg$l_adverb_value]);
		END;

	    END;

	[examine_instruction] :
	    BEGIN

	    LOCAL
	  	NEXT_LOC;		! Beginning address of next instruction

	    ! We must make sure that the mode is correct
	    !
	    dbg$set_mod_lvl (override_mode);
	    dbg$gb_mod_ptr [mode_symbols] = .mode_node [dbg$b_adverb_literal];
	    dbg$gb_mod_ptr [mode_radix] = .radix_node [dbg$b_adverb_literal];


	    ! Obtain the address for the EXAMINE
	    !
	    IF NOT dbg$nget_address (.addr_exp_desc, address [0], type, .message_vect)
	    THEN
		RETURN sts$k_severe;


	    ! We must produce the symbolic address or numeric address. Check for
	    ! a primary descriptor and symbols mode.
	    !
	    IF .addr_exp_desc [dbg$b_aed_type] EQL dbg$k_primary_desc
				AND
	       .mode_node [dbg$b_adverb_literal] ! Checking for symbols mode
	    THEN
		BEGIN
		IF NOT dbg$nsymbolize (.addr_exp_desc [dbg$l_aed_value],
				       string_desc,
				       .message_vect)
		THEN
		    RETURN sts$k_severe;


		! Encode the string
		!
		dbg$fao_put (output_buffer, AS, string_desc);
		END
	    ELSE
		BEGIN


		! Re-symbolize if mode symbols is set
		!
		IF .mode_node [dbg$b_adverb_literal]
		THEN
		    BEGIN

		    ! Check for permanent symbol descriptor
		    !
		    IF .addr_exp_desc [dbg$b_aed_type] EQL dbg$k_perm_desc
		    THEN
		        BEGIN
		        symbolize_regname (output_buffer, .addr_exp_desc [dbg$l_aed_value]);
		        END
		    ELSE
			BEGIN
			dbg$out_sym_val (.address [0], long_length, 0, output_buffer);
			END;
		    END
		ELSE
		    BEGIN
		    dbg$out_num_val (output_buffer,
				     .address [0],
				     long_length,
				     .radix_node [dbg$b_adverb_literal],
				     true); ! Unsigned output.
		    END;

		END;


	    ! The address has been formatted. Place the ':  ' and try to
	    ! decode the instruction
	    !
	    dbg$fao_put (output_buffer, AC, COLON);
	    IF (next_loc = dbg$ins_decode (.address [0], output_buffer)) EQL 0
	    THEN
		BEGIN
		.message_vect = dbg$nmake_arg_vect (dbg$_nodecode);
		RETURN sts$k_severe;
		END;


	    ! Save current location. Set override to type instruction and set
	    ! the length to the length of the EXAMINEd instruction.
	    !
	    dbg$nsave_last_loc (.addr_exp_desc,
				dsc$k_dtype_zi,
				.next_loc - .address [0]);

	    END;

	[examine_register] :
	    BEGIN

	    ! The source is described by a permanent symbol descriptor. We always
	    ! symbolize the register, even if mode_nosymbols is set. However,
	    ! mode_nosymbols causes us to override the special format for PSL.
	    !
	    LOCAL
		PERM_DESC : REF dbg$permsd;


	    ! Recover the permanent symbol descriptor
	    !
	    perm_desc = .addr_exp_desc [dbg$l_aed_value];


	    ! Format the register name
	    !
	    symbolize_regname (output_buffer, .perm_desc);


	    ! Place the ':  '
	    !
	    dbg$fao_put (output_buffer, AC, COLON);


	    ! Check for no_symbols and not PSL
	    !
	    IF NOT .mode_node [dbg$b_adverb_literal]
				OR
	           .perm_desc [dbg$b_permsd_id] NEQ dbg$k_psl
	    THEN
		BEGIN

		! Simply format the contents of the register.
		!
		dbg$out_num_val (output_buffer,
				 ..perm_desc [dbg$l_permsd_addr],
				 long_length,
				 .radix_node [dbg$b_adverb_literal],
				 true);  ! Registers are unsigned.
		END
	    ELSE
		BEGIN

		! If we are outputting the PSL then we use a special format.
		!
		dbg$output_psl (..perm_desc [dbg$l_permsd_addr], output_buffer);
		END;


	    ! Save current location
	    !	
	    dbg$nsave_last_loc (.addr_exp_desc, dbg$k_notype, 0);

	    END;

    	[examine_source] :
    	    BEGIN
    	    LOCAL
    		low_pc,
    		high_pc;

    	    	! recover the addresses

    	    	IF NOT dbg$nget_address (.noun_node[dbg$l_noun_value],
    		    low_pc, type, .message_vect)
    	    	THEN
    		    RETURN sts$k_severe;

    	    	IF NOT dbg$nget_address (.noun_node[dbg$l_noun_value2],
    		    high_pc, type, .message_vect)
    	    	THEN
    		    RETURN sts$k_severe;

    	    	! Output the source. The third parameter indicates that the
    	    	! module name is to be displayed.

    	    	dbg$src_type_pc_source(.low_pc, .high_pc, TRUE);
    
    	    END; ! EXAMINE/SOURCE

	[INRANGE,OUTRANGE] :
	    BEGIN
	    .message_vect = dbg$nmake_arg_vect (dbg$_notimplan, 1, no_support);
	    RETURN sts$k_severe;
	    END;

	TES;


    ! Simply output the buffer and we're done.
    !

    IF .verb_node[dbg$b_verb_composite] NEQ examine_source
    THEN
        dbg$out_put (output_buffer);

    ! Get the next element of the list

    noun_node = .noun_node[dbg$l_noun_link];

    IF .noun_node EQL 0 
    THEN
        EXITLOOP;

    END; ! while loop

    RETURN sts$k_success;

    END;		! End of dbg$nexecute_examine


ROUTINE SYMBOLIZE_REGNAME (BUFFER, PERM_DESC) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Encodes the name of a register into the output buffer.
!
! FORMAL PARAMETERS:
!
!	BUFFER		- The longword address of the buffer
!
!	PERM_DESC	- The longword address of a permanent symbol descriptor
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN

    MAP
	PERM_DESC : REF dbg$permsd;


    ! Register name strings
    !
    BIND
	REG_0 	= UPLIT BYTE (%ASCIC '%R0'),
	REG_1	= UPLIT BYTE (%ASCIC '%R1'),
	REG_2	= UPLIT BYTE (%ASCIC '%R2'),
	REG_3	= UPLIT BYTE (%ASCIC '%R3'),
	REG_4	= UPLIT BYTE (%ASCIC '%R4'),
	REG_5	= UPLIT BYTE (%ASCIC '%R5'),
	REG_6	= UPLIT BYTE (%ASCIC '%R6'),
	REG_7	= UPLIT BYTE (%ASCIC '%R7'),
	REG_8	= UPLIT BYTE (%ASCIC '%R8'),
	REG_9	= UPLIT BYTE (%ASCIC '%R9'),
	REG_10	= UPLIT BYTE (%ASCIC '%R10'),
	REG_11	= UPLIT BYTE (%ASCIC '%R11'),
	REG_12	= UPLIT BYTE (%ASCIC '%AP'),
	REG_13	= UPLIT BYTE (%ASCIC '%FP'),
	REG_14	= UPLIT BYTE (%ASCIC '%SP'),
	REG_15	= UPLIT BYTE (%ASCIC '%PC'),
	REG_16	= UPLIT BYTE (%ASCIC '%PSL');


    ! Format the register name
    !
    dbg$fao_put (.buffer,
		 UPLIT BYTE (%ASCIC '!AC'),
		 (CASE .perm_desc [dbg$b_permsd_id] FROM dbg$k_r0 TO dbg$k_psl
		     OF
		     SET

		     [dbg$k_r0] : reg_0;
		     [dbg$k_r1] : reg_1;
		     [dbg$k_r2] : reg_2;
		     [dbg$k_r3] : reg_3;
		     [dbg$k_r4] : reg_4;
		     [dbg$k_r5] : reg_5;
		     [dbg$k_r6] : reg_6;
		     [dbg$k_r7] : reg_7;
		     [dbg$k_r8] : reg_8;
		     [dbg$k_r9] : reg_9;
		     [dbg$k_r10] : reg_10;
		     [dbg$k_r11] : reg_11;
		     [dbg$k_ap] : reg_12;
		     [dbg$k_fp] : reg_13;
		     [dbg$k_sp] : reg_14;
		     [dbg$k_pc] : reg_15;
		     [dbg$k_psl] : reg_16;
		     TES));

    END;		! End of symbolize_regname


GLOBAL ROUTINE DBG$NFORMAT_WITH_RADIX (ADDRESS, OFFSET, LENGTH, RADIX, BUFFER) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Formats the contents of a arbitrary number of bits into a printable
!	hex or octal number, or a sequence of unsigned decimal longwords.
!
! FORMAL PARAMETERS:
!
!	ADDRESS		-	A longword containing the byte address of the
!				location to be printed
!
!	OFFSET		-	A longword containing the starting bit offset
!
!	LENGTH		-	A longword containing the number of bits to be
!				printed
!
!	RADIX		-	A longword containing dbg$k_octal, dbg$k_decimal, or
!				dbg$k_hex, indicating the radix to be used for output
!
!	BUFFER		- 	A longword containing the address of the buffer
!				in which the translated number is to be placed
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	The byte stream corresponding to the translated number is filled
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN

    LOCAL
	CHAR_TABLE		: VECTOR [16],		! Character trans table
	NIBBLE			: BLOCK [1],		! Nexts bits for char trans
	BIT_VECT		: REF BITVECTOR,	! Bits to be translated
	BITS_PER_NIBBLE,				! Number of bits for 1 char
	FIRST_NIBBLE_BITS,				! Number of bits for first nibble
	FIRST_FLAG,					! Indicates first nibble
	START,						! Start bitvect position
	FINISH,						! End bitvect position
	LONG_WORD 		: REF BLOCK,		! Longword for decimal output
	INDEX;						! Loop counter

    MACRO
	GET_NIBBLE	=

	BEGIN

	! This macro obtains the next nibble of bits for octal or hex output
	!
	nibble = 0;


	! Obtain the correct number of bits
	!
	IF .bits_per_nibble EQL 3
	THEN
	    BEGIN
	    nibble [0, 2, 1, 0] = .bit_vect [.start];
	    nibble [0, 1, 1, 0] = .bit_vect [.start - 1];
	    nibble [0, 0, 1, 0] = .bit_vect [.start - 2];
	    END
	ELSE
	    BEGIN
	    nibble [0, 3, 1, 0] = .bit_vect [.start];
	    nibble [0, 2, 1, 0] = .bit_vect [.start - 1];
	    nibble [0, 1, 1, 0] = .bit_vect [.start - 2];
	    nibble [0, 0, 1, 0] = .bit_vect [.start - 3];
	    END;

	start = .start - .bits_per_nibble;

	END %;


    ! Check for decimal or other radix
    !
    IF .radix EQL dbg$k_decimal
    THEN
	BEGIN

	! Line up the longword and take bits corresponding to the
	! the first longword and output them
	!
	long_word = .address;
	IF .length + .offset LEQU %BPVAL
	THEN
	    BEGIN

	    ! The entity has less than a longword of bits, counting the offset
	    !
	    nibble = .long_word [0, .offset, .length, 0];
	    length = 0;
	    END
	ELSE
	    BEGIN

	    ! Atleast a longword of bits counting the offset
	    !
	    nibble = .long_word [0, .offset, %BPVAL - .offset, 0];
	    length = .length - (%BPVAL - .offset);
	    END;


	! Output the first longword
	!
	dbg$fao_put (.buffer, UPLIT BYTE (%ASCIC '!ZL'), .nibble);


	! Loop, outputting the bits a longword at a time
	!
	index = 1;
	WHILE .length GEQU %BPVAL
	DO
	    BEGIN

	    ! Output a space
	    !
	    dbg$fao_put (.buffer, UPLIT BYTE (%ASCIC '!AC'), UPLIT BYTE (%ASCIC ' '));


	    ! Output the next longword
	    !
	     dbg$fao_put (.buffer, UPLIT BYTE (%ASCIC '!ZL'),
			  .long_word [.index, 0, 32, 0]);


	    ! Increase index and decrease length
	    !
	    index = .index + 1;
	    length = .length - %BPVAL;

	    END;

	! Output remaining bits, if any
	!
	IF .length GTRU 0
	THEN
	    BEGIN
	    dbg$fao_put (.buffer, UPLIT BYTE (%ASCIC '!AC'), UPLIT BYTE (%ASCIC ' '));
	    nibble = .long_word [.index, 0, .length, 0];
	    dbg$fao_put (.buffer, UPLIT BYTE (%ASCIC '!ZL'), .nibble);
	    END;

	END

    ELSE
	BEGIN

	! Octal or hex radix. Set up the bit vector and the start and finish
	! indicies
	!
    	first_flag = true;
	bit_vect = .address;
	finish = .offset;
	start = .finish + .length - 1;


	! Set up bits_per_nibble based on radix
	!
	bits_per_nibble = (IF .radix EQL dbg$k_octal THEN 3 ELSE 4);


	! Load up the character trans table
	!
	char_table [0] =  UPLIT BYTE (%ASCIC '0');
	char_table [1] =  UPLIT BYTE (%ASCIC '1');
	char_table [2] =  UPLIT BYTE (%ASCIC '2');
	char_table [3] =  UPLIT BYTE (%ASCIC '3');
	char_table [4] =  UPLIT BYTE (%ASCIC '4');
	char_table [5] =  UPLIT BYTE (%ASCIC '5');
	char_table [6] =  UPLIT BYTE (%ASCIC '6');
	char_table [7] =  UPLIT BYTE (%ASCIC '7');
	char_table [8] =  UPLIT BYTE (%ASCIC '8');
	char_table [9] =  UPLIT BYTE (%ASCIC '9');
	char_table [10] = UPLIT BYTE (%ASCIC 'A');
	char_table [11] = UPLIT BYTE (%ASCIC 'B');
	char_table [12] = UPLIT BYTE (%ASCIC 'C');
	char_table [13] = UPLIT BYTE (%ASCIC 'D');
	char_table [14] = UPLIT BYTE (%ASCIC 'E');
	char_table [15] = UPLIT BYTE (%ASCIC 'F');


	! Determine how many bits go in the first nibble and format the first nibble
	!
	first_nibble_bits = .length MOD .bits_per_nibble;
	nibble = 0;

	CASE .first_nibble_bits FROM 0 TO 3
	    OF
	    SET

	    [0] :
		BEGIN
		0;		! Do nothing since no remainder
		END;

	    [1] :
		BEGIN
		nibble [0, 0, 1, 0] = .bit_vect [.start];	
		END;

	    [2] :
		BEGIN
		nibble [0, 1, 1, 0] = .bit_vect [.start];
		nibble [0, 0, 1, 0] = .bit_vect [.start - 1];
		END;

	    [3] :
		BEGIN
		nibble [0, 2, 1, 0] = .bit_vect [.start];
		nibble [0, 1, 1, 0] = .bit_vect [.start - 1];
		nibble [0, 0, 1, 0] = .bit_vect [.start - 2];
		END;

	    TES;

	start = .start - .first_nibble_bits;

	IF .first_nibble_bits NEQ 0
	THEN
	    BEGIN
	    first_flag = false;
	    dbg$fao_put (.buffer, UPLIT BYTE (%ASCIC '!AC'), .char_table [.nibble]);
	    END;


	! Format the rest of the bits
	!
	WHILE .start GTR .finish
	    DO
		BEGIN
		get_nibble;


		! IF the first character emitted is alphabetic, prepend a '0'
		!
		IF .first_flag AND .nibble GTR 9
		THEN
		    dbg$fao_put (.buffer, UPLIT BYTE (%ASCIC '!AC'), UPLIT BYTE (%ASCIC '0'));
	      
		dbg$fao_put (.buffer, UPLIT BYTE (%ASCIC '!AC'), .char_table [.nibble]);
		first_flag = false;
		END;

	END;

    RETURN;

    END;		! End of format_with_radix
   

END				!End of module
ELUDOM
