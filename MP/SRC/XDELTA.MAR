	.IF	DF,SW_PROCESS		;
	.TITLE	DELTA - MULTIMODE PROCESS DEBUGGER
	.IFF				;
	.TITLE	XDELTA - EXECUTIVE DEBUGGER
	.ENDC				;
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY: EXECUTIVE, DEBUGGING TOOLS
;
; ABSTRACT:
;	THIS MODULE PRODUCES TWO DIFFERENT DEBUGGERS DEPENDING ON THE SETTING
;	OF THE ASSEMBLY SWITCH, SW_PROCESS.  DELTA IS A MULTIMODE PROCESS
;	DEBUGGER USING SYSTEM SERVICES WHILE XDELTA IS A STANDALONE EXEC
;	DEBUGGING TOOL.
;
;	COMMAND SYNTAX IS IDENTICAL FOR BOTH VERSIONS EXCEPT FOR ENVIRONMENTAL
;	DIFFERENCES.  THE SYNTAX IS QUITE TERSE AND SOMEWHAT CRYPTIC AND
;	IS DOCUMENTED IN THE "GUIDE TO WRITING AN I/O DRIVER".
;
; ENVIRONMENT:
;	DELTA - NORMAL PROCESS ENVIRONMENT, VARIOUS ACCESS MODES.
;	XDELTA - STANDALONE, RESIDENT, KERNEL MODE, IPL=31
;	BOTH VERSIONS MUST BE POSITION INDEPENDENT - BEWARE!
;--
	.PAGE
	.SBTTL	HISTORY			; DETAILED
;
; AUTHOR:	R. HUSTVEDT	 CREATION DATE: 15-NOV-76
;
; REVISION HISTORY:
;
;	V02-009	LJK0030		Lawrence J. Kenah	31-Jul-1981
;		Make changes necessary to support large physical memory
;		configurations. Change names of PFN listhead cells. Add
;		labels to cells for XE and XF stored strings to allow
;		access from INIT.
;
;	V02-008	TCM0001		Trudy C. Matthews	29-Jul-1981
;		Change all "7ZZ"s to "730"s.
;
;	V02-007	KDM0003		Kathleen D. Morse	15-Sep-1980
;		Make changes to run with multi-processor privileged program.
;
	.PAGE
	.SBTTL	DECLARATIONS

;
; INCLUDE FILES:
;
	$ACBDEF				; DEFINE AST CONTROL BLOCK
	$CADEF				; DEFINE ASSEMBLY SWITCHES
	$CLIDEF				; DEFINE CLI VALUES
	$IPLDEF				; DEFINE IPL VALUES
	$IRPDEF				; DEFINE IRP VALUES
	$PCBDEF				; DEFINE PROCESS CONTROL BLOCK
	$PRDEF				; DEFINE PROCESSOR REGISTERS
	$PRIDEF				; DEFINE PRIORITY INCREMENT CLASSES
	$PRTDEF				; DEFINE PROTECTION VALUES
	$PSLDEF				; DEFINE PSL FIELDS
	$SSDEF				; DEFINE SYSTEM SERVICE STATUS CODES

;
; MACROS:
;

;
; CPU TYPE DISPATCH MACRO:
;
;	THE ADDRESSES IN THE ADDRESS LIST ARE:
;		-ADDRESS OF CODE FOR CPU TYPE=1 (11/780)
;		-ADDRESS OF CODE FOR CPU TYPE=2 (11/750)
;		-ADDRESS OF CODE FOR CPU TYPE=3 (11/730)
;		-ADDRESS OF CODE FOR CPU TYPE=4 (?)
;		-ETC.
;
;	CPUDISP IN INVOKED TO HANDLE CPU DIFFERENCES IN LINE.  WHEN THE
;	NEXT CPU IS ADDED, ALL OCCURRENCES OF CPUDISP MUST BE EXPANDED
;	TO HANDLE FOUR CPU SPECIFIC PATHS.
;
	.MACRO	CPUDISP,ADDRLIST
	CASE	G^EXE$GB_CPUTYPE,<ADDRLIST>,LIMIT=#PR$_SID_TYP780,TYPE=B
	.ENDM	CPUDISP

;
; EQUATED SYMBOLS:
;
V_F1=8					; FIELD 1 PRESENT FLAG
V_F2=9					; FIELD 2 PRESENT FLAG
V_F3=10					; FIELD 3 PRESENT FLAG
V_F4=11					; FIELD 4 PRESENT FLAG
V_F5=12					; FIELD 5 PRESENT FLAG

V_OPEN=0				; OPEN CELL FLAG
V_ASCII=1				; ASCII
V_INFIELD=2				; FIELD IN PROGRESS
V_TBIT=3				; ENABLE TBIT
V_ATBRK=4				; AT BREAKPOINT
V_TBITOK=5				; TBIT EXPECTED
V_RUB=6					; RUBOUT IN PROGRESS
V_NEGATE=7				; NEGATE BIT
V_PRMODE=15				; PROCESSOR REGISTER MODE
V_PREG=31				; PROCESSOR REGISTER FLAG

RDCR=0					; READ CSR
RDBUF=2					; READ BUFFER
OUTCR=4					; OUTPUT CSR
OUTB=6					; OUTPUT BUFFER

BSLSH=92				; BACK SLASH CODE
CR=13					; CARRIAGE RETURN
LF=10					; LINE FEED
QUOT=39					; QUOTE
RUBOUT=127				; RUBOUT CODE
SLSH=47					; SLASH CODE



;
;	OWN STORAGE:
;
	.LIST	MEB			; DISPLAY MACRO EXPANSIONS
	.IF	DF,SW_PROCESS
	.PSECT	_DELTA,LONG
DELBASE:.LONG	DELBASE-DELBASE		; RELATIVE PAGE NUMBER OF WRITABLE
	.LONG	<511+DELEND-DELBASE>&^C511; REL PAGE NUMBER OF END OF WRITABLE
	.LONG	DELTA_START-DELBASE	; START ADDRESS
	.IFF
	.PSECT	Z$DEBUGXDELTA,LONG
	.ENDC
CONTEXT:				;
	.LONG	0			; BUFFER PADDING
INBUF:	.BLKB	48			; INPUT BUFFER
STATUS:	.LONG	0			; STATUS FLAGS
F1:	.LONG	0			; FIELDS
F2:	.LONG	0			; 0-7
F3:	.LONG	0			;
F4:	.LONG	0			;
F5:	.LONG	0			;

MFYFLG:	.LONG	0			; MODIFY ENABLE FLAG FOR OTHER PROCESS
					; ADDRESS SPACES
PID:	.LONG	0			; PID FOR ADDRESS SPACE 0=>SELF

FCTR:	.BYTE	0			; FIELD COUNTER

DTYPE:	.BYTE	2			; DATA TYPE
CURTYPE:.BYTE	2			; CURRENT TYPE

OPER:	.BYTE	0			; OPERATOR
B:					; BASE OF DATA AREA(CENTER)
CURDOT:	.LONG	0			; CURRENT LOCATION
QUAN:	.LONG	0			; QUANTITY (;Q)
OUTBUF:	.BLKL	4			; OUTPUT BUFFER
;
;	REGISTER SAVE AREA
;
SAVREG:					; REGISTER SAVE AREA
	.BLKL	1			; R0
	.BLKL	1			; R1
SAVR2:	.BLKL	1			; R2
	.BLKL	1			; R3
	.BLKL	1			; R4
	.BLKL	1			; R5
	.BLKL	1			; R6
	.BLKL	1			; R7
	.BLKL	1			; R8
	.BLKL	1			; R9
	.BLKL	1			; R10
	.BLKL	1			; R11
SAVAP:	.BLKL	1			; AP
	.BLKL	1			; (FP)
SAVSP:	.BLKL	1			; SP
SAVPC:	.BLKL	1			; PC
SAVPSL:	.BLKL	1			; PSL
SAVOCR:	.BLKW	1			; OUTPUT CSR SAVE
SAVRCR:	.BLKW	1			; INPUT CSR SAVE
ASTEN:					; AST ENABLE SAVE LOCATION
SAVRXCS:.BLKL	1			; CONSOLE RECEIVER STATUS

CONTEXTSZ=.-CONTEXT			; SIZE OF PER MODE CONTEXT AREA
;
;	RESERVE SPACE FOR MULTIPLE MODE CONTEXT AREA
;
	.IF	DF,SW_PROCESS		;
	.REPT	3			;
	.BLKB	CONTEXTSZ		; FOR EXEC,SUPER AND USER
SAV...=	.
	.=.-CONTEXTSZ+<DTYPE-CONTEXT>	; POINT AT DTYPE,CURTYP
	.BYTE	2,2			; SET TYPE TO LONGWORD
	.=SAV...			; RESTORE LOCATION COUNTER
	.ENDR				;
	.ENDC				;


;
;	BREAK POINT DATA
;
BRKADR=.-4	
	.IF	NDF,SW_PROCESS	;
XDELIBRK::			;
	.LONG	INI$BRK			; ADDRESS OF INITIAL BREAKPOINT
	.IFF				; FOR PROCESS VERSION
INIBRKA:.LONG	0			; INITIAL BREAKPOINT
	.ENDC				;
	.BLKL	7			; OTHER BREAK POINT ADDRESSES
NBRK=<.-4-BRKADR>/4			; NUMBER OF BREAKPOINTS
BRKOP=.-1				; SAVED OPCODE
	NOP				; INITIAL OPCODE
	.BLKB	7			; REMAINING OPCODES


BRKDSP=.-4
	.BLKL	8			; DISPLAY LOCATION START
BRKCOM=.-4
	.BLKL	8			; COMMAND START

XREGV:	.BLKL	3			; X REGISTER VECTOR
XDEL_LOADBASE::				; BASE OF LOADABLE
	.LONG	0			;  CPU DEPENDENT CODE
	.LONG	SCH$GL_CURPCB		; X4 = CURRENT PCB ADDRESS
	.LONG	SCH$GL_PCBVEC		; X5 = BASE OF PCB VECTOR
	.IF	NDF,SW_PROCESS		;
	.LONG	PFN$AW_SWPVBN		; X6 = SWAP VBN
	.LONG	PFN$AL_PTE		; X7 = PTE BACK POINTER
	.LONG	PFN$AL_BAK		; X8 = BACKUP ADDRESS
	.LONG	PFN$AW_REFCNT		; X9 = REFERENCE COUNT
	.LONG	PFN$Ax_FLINK		; XA = FORWARD LINK
	.LONG	PFN$Ax_BLINK		; XB = BACK LINK
	.LONG	PFN$AB_STATE		; XC = STATE
	.LONG	PFN$AB_TYPE		; XD = TYPE
XDS$GL_XESTRING::
	.LONG	XDS$GT_WORD_PFN		; XE;E WITH X0 = PFN , DEFAULT TO WORD ARRAYS
XDS$GL_XFSTRING::
	.LONG	XDS$GT_WORD_PFN		; XF;E WITH R0 = PFN , DEFAULT TO WORD ARRAYS
MCHKSAV:.BLKL	1			; SAVED CONTENT OF MACHINE CHECK VECTOR
	.IFF				; FOR PROCESS VERSION
	.BLKL	10			;
TTIOSB:	.BLKL	2			; IO STATUS BLOCK FOR TERMINAL READ
TTCHAN:	.BLKL	1			; CHANNEL NUMBER
TTNAMD:	.LONG	2,TTSTR			; ACTUAL ADDRESS FOR DESCR SET BY INIT
TTSTR:	.ASCII	/TT/			;
DBGACTIVE:				; ACTIVE FLAGS BY ACCESS MODE
	.LONG	0			;
EXITBLK:				; EXIT HANDLER BLOCK
	.LONG	0			;
EXIHADR:.LONG	EXIHANDLE		; EXIT HANDLER
	.LONG	1			; ARGUMENT COUNT
EXCODA:	.LONG	EXITCODE		; ADDRESS TO STORE EXIT CODE
EXITCODE:				;
	.LONG	1			; RECEIVER FOR EXIT CODE
KCOND:	.LONG	0			; PREVIOUS KERNEL HANDLER
ECOND:	.LONG	0			; PREVIOUS EXEC HANDLER
SCOND:	.LONG	0			; PREVIOUS SUPER HANDLER
TERMASKD:				; TERMINATOR MASK DESCRIPTOR
	.LONG	16			; MASK LENGTH
	.LONG	TERMASK			; MASK ADDRESS
TERMASK:.LONG	<1@9>!<1@10>!<1@13>!<1@27>	; TAB,LF,CR,ESC
	.LONG	<1@2>!<1@15>!<1@29>	; DOUBLE QUOTE,SLASH,EQUALS
	.LONG	<1@19>			; 'S'
	.LONG	0			;

	.ENDC				;
	.PAGE
	.SBTTL	PRIMARY COMMAND CHARACTER SWITCH

;
;	PRIMARY CHARACTER LIST
;
PRIMARY:				;
	.ASCII	/0123456789ABCDEF/	; DECIMAL AND HEX CHARS
	.ASCII	/./			; DOT - CURRENT LOCATION
	.ASCII	/,/			; COMMA - FIELD SEPARATOR
OPERBAS=.-PRIMARY			; OPERATORS
	.ASCII	/+/			; PLUS - ADD
	.ASCII	/ /			; BLANK - SAME AS PLUS
	.ASCII	/@/			; SHIFT OPERATOR
	.ASCII	/*/			; MULTIPLY OPERATOR
	.ASCII	/%/			; DIVIDE OPERATOR
	.ASCII	/-/			; MINUS - SUBTRACT OPERATOR
	.ASCII	/[/			; LBRACKET - LEFT BRACKET
TERM:					; BASE OF TERMINATOR LIST
	.ASCII	<9>			; TAB - INDIRECT
	.ASCII	<10>			; LINEFEED -
	.ASCII	<CR>			; RETURN - 
	.ASCII	'/'			; SLASH - OPEN FOR DISPLAY
	.ASCII	'"'			; DOUBLE QUOTE - OPEN FOR ASCII DISPLAY
	.ASCII	/=/			; EQUALS - DISPLAY
	.ASCII	<27>			; ESCAPE - PREVIOUS LOCATION
	.ASCII	/S/			; STEP
NTERM=.-TERM				; NUMBER OF TERMINATORS
	.ASCII	<59>			; SEMI - INITIATE SECONDARY
	.ASCII	/:/			; COLON - SEPARATE PID FORM ADDRESS
	.ASCII	/P/			; P - PROCESSOR REGISTER PREFIX
	.ASCII	/Q/			; Q - LAST QUANTITY
	.ASCII	/'/			; QUOTE - BEGIN CHAR STRING
	.ASCII	/R/			; REGISTER PREFIX
	.ASCII	/G/			; G - GLOBAL PREFIX
	.ASCII	/H/			; H - HIGH, P1 SPACE PREFIX
	.ASCII	/X/			; X REGISTER PREFIX
NPRIM=.-PRIMARY				; NUMBER OF PRIMARY COMMANDS

	.PAGE
	.SBTTL	PRIMARY COMMAND SCANNER

;
;	PRIMARY COMMAND SCANNER
;


OUTER:	.ASCIZ	<LF><CR>/EH?/<LF><CR>

DCOM:	.WORD				; CALL ENTRY POINT
	.IF	DF,SW_PROCESS		; FOR PROCESS VERSION ONLY
	MOVAB	W^DBGEXCEP,(FP)		; SET CONDITION HANDLER ADDRESS
	.ENDC				;
	BRB	SCANP			; ENTER SCANP
ERROR:	MOVAB	OUTER,R4		; SET ADDR OF CONTROL STRING
	BSBW	OUTZSTRING		; OUTPUT ASCIZ STRING
SUPERST:MOVL	FP,SP			; RESET STACK
	MOVAB	INBUF-B(R11),R9		; RESET STRING ADDRESS
	CLRB	(R9)			; AND FORCE READ
	BSBW	RESET			; RESET SCANNER
SCANP:	BSBB	NEXTP			; SCAN INPUT
	BRB	SCANP			; SCAN IT ALL
NEXTP:					; PROCESS NEXT PRIMARY CHAR
	BSBW	GETCHAR			; GET CHARACTER
	LOCC	R8,#NPRIM,PRIMARY	; CHECK IT
	BEQL	ERROR			; NOT FOUND, ERROR
	SUBL3	R0,#NPRIM,R0		; RATIONALIZE INDEX
	CASE	R0,LIMIT=#16,<-		; 
		DOT,-			; DOT - CURRENT LOCATION
		COMMA,-			; COMMA - FIELD SEPARATOR
		OPERATOR,-		; PLUS - ADD OPERATOR
		OPERATOR,-		; BLANK - ADD OPERATOR
		OPERATOR,-		; @ - SHIFT OPERATOR
		OPERATOR,-		; * - MULTIPLY OPERATOR
		OPERATOR,-		; % - DIVIDE OPERATOR
		NEGATE,-		; MINUS - SUBTRACT/NEGATE
		LBRACKET,-		; LEFT BRACKET - MODE SELECT
		TAB,-			; TAB - INDIRECT
		LINEFEED,-		; LINE FEED - NEXT LOCATION
		RETURN,-		; RETURN - CLOSE OPEN CELL
		SLASH,-			; SLASH - OPEN FOR DISPLAY
		DQUOTE,-		; DOUBLE QUOTE - OPEN FOR ASCII DISPLAY
		EQUALS,-		; EQUALS - DISPLAY VALUE
		ESCAP,-			; ESCAPE - PREVIOUS LOCATION
		STEP,-			; 'S' - SINGLE STEP
		SEMI,-			; SEMI COLON - SECONDARY COMMAND
		COLON,-			; COLON - SEPARATE PID FROM ADDRESS
		PREG,-			; 'P' - PROCESSOR REGISTER
		QUANT,-			; 'Q' - LAST QUANTITY
		QUOTE,-			; QUOTE - BEGIN ASCII STRING
		REGISTER,-		;
		GLOBL,-			; G - GLOBAL PREFIX
		HIGH,-			; H - P1 SPACE PREFIX
		XREG,-			; X REGISTER
		>			;
	CMPW	R0,#16			; IS NUMBER > RADIX
	BGEQ	ERROR			; YES
	MULL	#16,R6			; SCALE BY RADIX
	ADDL	R0,R6			; AND ADD NEW DIGIT
INFLD:	BISL	#<1@V_INFIELD>,(R10)	; NOTE FIELD INPUT
	RSB				; NEXT PRIMARY CHARACTER


GLOBL:	ROTL	#31,#1,R4		; GENERATE SYSTEM SPACE PREFIX
	BRB	PRE1			; MERGE WITH COMMON
HIGH:	MOVL	#^X7FFE0000,R4		; P1 SPACE BASE ADDRESS
PRE1:	BSBB	ENDEXPR			; END EXPRESSION
	MOVL	R4,R6			; SET INTO ACCUM
	PUSHAB	INFLD			; RETURN THROUGH INFLD
;	BRB	ENDEXPR

	.PAGE
	.SBTTL	ENDEXPR	- END EXPRESSION

;
;
;
ENDEXPR:				;
	BBCC	#V_NEGATE,(R10),5$	; SKIP IF NOT NEGATE
	MNEGL	R6,R6			; NEGATE ACCUMULATOR
5$:	BSBB	10$			; PERFORM OPERATION
	CLRL	R6			; CLEAR ACCUMULATOR
	CLRB	OPER-B(R11)		; INIT OPERATOR
	RSB				; AND RETURN
10$:	CASE	OPER-B(R11),TYPE=B,<-	; DO OPERATION
		ADD,-			; ADD, PLUS
		ADD,-			; BLANK, PLUS
		SHFT,-			; SHIFT, @
		MUL,-			; MULTIPLY, *
		DIV,-			; DIVIDE, %
		>			; 
SHFT:	ASHL	R6,R7,R7		; SHIFT
	RSB				; AND EXIT
MUL:	MULL	R6,R7	; MULTIPLY
	RSB				; AND EXIT
DIV:	DIVL	R6,R7	; DIVIDE
	RSB				; AND EXIT
ADD:	ADDL	R6,R7	; ADD
	RSB				; AND EXIT

	.PAGE
	.SBTTL	SLASH - OPEN CELL

;
;	OPEN SPECIFIED CELL
;
DQUOTE:					; DISPLAY IN ASCII
	BISB	#<1@V_ASCII>,(R10)	; SET ASCII FLAG
	BRB	OPEN			; 

SLASH:					;
	BICB	#<1@V_ASCII>,(R10)	; CLEAR ASCII DISPLAY MODE
OPEN:	BSBB	ENDFIELD		; TERMINATE FIELD
	BBS	#V_F1,(R10),5$		; ADDR SPECIFIED?
	MOVL	QUAN-B(R11),CURDOT-B(R11)	; NO, GO INDIRECT
	BRB	10$			; AND DISPLAY CONTENT
5$:	MOVL	F1-B(R11),CURDOT-B(R11)	; SET NEW DOT
10$:	EXTZV	#V_PRMODE,#1,(R10),R0	; GET PROCESSOR REGISTER MODE FLAG
	INSV	R0,#V_PREG,#1,(R10)	; AND MOVE TO SEMI-PERMANENT COPY
	BSBW	LOCOUT			; OUTPUT AND OPEN
	BBC	#V_F2,(R10),RSET	; RANGE SPECIFIED?
15$:	CMPL	F2-B(R11),CURDOT-B(R11)	; CHECK FOR END
	BLEQ	RSET			; YES
	.IF	NDF,SW_PROCESS		;
	BSBB	NEXTLOC			; INCREMENT TO NEXT DOT
	.IFF				;
	BSBW	NEXTLOC			; INCREMENT TO NEXT DOT
	.ENDC				;
	BRB	15$			; AND CONTINUE
ERR4:	BRW	ERROR			; DECLARE ERROR

	.PAGE
	.SBTTL	RETURN - CLOSE CURRENT OPEN CELL

;
;	RETURN - CLOSE CURRENT OPEN CELL
;

RETURN:					;
	BSBB	ENDFIELD		; TERMINATE CURRENT FIELD
	.ENABL	LSB			;
	BBCC	#V_OPEN,(R10),10$	; SKIP IF NONE OPEN
	BBC	#V_F1,(R10),RSET	; SKIP IF NOTHING TO STORE
	BSBW	DEPOSIT			; DEPOSIT
RSET:	BRW	RESET			; RESET SCANNER
10$:	BBC	#V_F1,(R10),RSET	; DONE IF NO INPUT
	BRW	EQL1			; OTHERWISE OUTPUT
	.DSABL	LSB			;
	.PAGE
	.SBTTL	ENDFIELD - TERMINATE CURRENT FIELD

;
;	COMMA TERMINATE CURRENT FIELD
;
COMMA:	BSBW	INFLD			; ZERO IF NULL FIELD

;
;	TERMINATE CURRENT FIELD
;
ENDFIELD:				;
	BBCC	#V_INFIELD,(R10),10$	; CLEAR PENDING FIELD
	BSBW	ENDEXPR			; END EXPRESSION
	MOVZBL	FCTR-B(R11),R0		; GET FIELD POINTER
	BBSS	R0,1(R10),ERR4		; ERROR IF TOO MANY FIELDS
	MOVL	R7,F1-B(R11)[R0]	; STORE FIELD VALUE
	INCB	FCTR-B(R11)		; INCREMENT FIELD COUNTER
	CLRQ	R6			; CLEAR ACCUMULATORS
10$:	RSB				; RETURN

	.PAGE
	.SBTTL	FETCH - OBTAIN DATA SPECIFIED

;
;	FETCH SPECIFIED DATA
;
FETCH:					;
	BBS	#V_PREG,(R10),40$	; BR IF PROCESSOR REGISTER
	.IF	DF,SW_PROCESS		;
	TSTL	PID-B(R11)		; CHECK FOR PROCESS GET
	BNEQ	50$			; BR IF YES
	.ENDC				;
	CASE	CURTYPE-B(R11),TYPE=B,<-	; OPERATE ON TYPE
		10$,-			; BYTE
		20$,-			; WORD
		30$,-			; LONG
		>			;
10$:	MOVZBL	@CURDOT-B(R11),QUAN-B(R11)	; GET BYTE
	RSB				; RETURN
20$:	MOVZWL	@CURDOT-B(R11),QUAN-B(R11)	; GET WORD
	RSB				; RETURN
30$:	MOVL	@CURDOT-B(R11),QUAN-B(R11)	; GET LONGWORD
	RSB				; RETURN
	.IF	NDF,SW_PROCESS		;
40$:	MFPR	CURDOT-B(R11),QUAN-B(R11)	; GET PROCESSOR REGISTER
	RSB				;
	.IFF				; FALSE IF PROCESS VERSION
40$:					;
	$CMKRNL_S	B^FTCHPREG,(AP)	; CALL IN KERNEL MODE TO FETCH
	RSB				;
50$:	BRW	FETCHP			; FETCH FROM FOREIGN PROCESS
	.ENDC

	.IF	DF,SW_PROCESS		;
FTCHPREG:				;
	.WORD	0			; ENTRY MASK
	MOVAB	W^PREXC,(FP)		; SET EXCEPTION HANDLER
	MFPR	CURDOT-B(R11),QUAN-B(R11)	; GET PROCESSOR REGISTER
	MOVL	#1,R0			; RETURN SUCCESS
	RET				;

	.ENDC				;
	.PAGE
	.SBTTL	NEXTDOT - INCREMENT CURRENT LOCATION

;
;	INCREMENT TO NEXT LOCATION
;
NEXTDOT:				;
	MOVL	#1,R1			; ASSUME UNIT INCREMENT
	TSTL	(R10)			; CHECK FOR PREG
	BLSS	10$			; YES, USE UNIT INCREMENT
	ROTL	CURTYPE-B(R11),R1,R1	; FORM INCREMENT
10$:	ADDL	R1,CURDOT-B(R11)	; AND ADD TO DOT
	RSB				; RETURN

	.PAGE
	.SBTTL	OUTPUT - DISPLAY CONTENT
;
;	OUTPUT CONTENT
;
OUTBB:	
	.BYTE	4,12,28			; STARTING DIGIT LIST
	.SBTTL	LINE FEED - DISPLAY NEXT
;
;
;
LINEFEED:				;
	BSBW	RETURN			; CLOSE OPEN CELL
NEXTLOC:				; PROMPT WITH NEXT LOCATION
	BSBB	NEXTDOT			; INCREMENT LOCATION
LOCPROMPT:				; DISPLAY ADDR/CONTENT
	BSBB	OUTPUTA			; OUTPUT ADDRESS
LOCOUT:	BSBB	FETCH			; FETCH CONTENT
	BISL	#<1@V_OPEN>,(R10)	; INDICATE OPEN CELL

OUTPUT:					;
	MOVZBL	CURTYPE-B(R11),R1	; GET TYPE
	MOVZBL	OUTBB[R1],R2		; INIT DIGIT SELECTOR
	MOVL	QUAN-B(R11),R3		; GET QUANTITY TO DISPLAY
	BBS	#V_ASCII,(R10),10$	; CHECK FOR ASCII OUT
	BSBB	OUTCOM			; OUTPUT NUMBER IN HEX
	BRB	20$			; AND EXIT THROUGH OUTSPACE
10$:	MOVL	R3,OUTBUF-B(R11)	; PUT STRING IN BUFFER
	ASHL	R1,#1,R2		; GET COUNT
	CLRB	OUTBUF-B(R11)[R2]	; MARK END OF STRING
	BSBB	OUTZBUF			; OUTBUT ASCIIZ BUFFER
20$:	BRW	OUTSPACE		; FOLLOW WITH SPACE

	.PAGE
	.SBTTL	OUTPUTA - OUTPUT ADDRESS
;
;	OUTPUT ADDRESS
;
OUTPUTA:				; OUTPUT ADDRESS
	BSBW	CRLF			; OUTPUT CR/LF
	MOVAB	SAVREG-B(R11),R3	; BASE OF REGISTER AREA
	.IF	DF,SW_PROCESS		; ONLY FOR PROCESS VERSION
	TSTL	PID-B(R11)		; CHECK FOR OTHER PROCESS ADDRESS
	BNEQ	3$			; BR IF YES
	.ENDC				;
	SUBL3	R3,CURDOT-B(R11),R3	; COMPUTE OFFSET INTO REGISTER AREA
	BLSS	5$			; NOT GENERAL REGISTER
	DIVL	#4,R3			; SCALE TO LONGWORD NUMBER
	CMPL	R3,#15			; CHECK FOR MAX REG NUMBER
	BGTR	5$			; GTR, NOT A REGISTER
	MOVZBL	#^A'R',R0		; OUTPUT PREFIX
	BSBB	OUTCHAR			; OF 'R'
	CLRL	R2			; AND SET FOR ONE DIGIT OF OUTPUT
	BRB	10$			;
	.IF	DF,SW_PROCESS		; FOR PROCESS VERSION ONLY
3$:	TSTL	(R10)			; CHECK FOR PROCESSOR REGISTER
	BLSS	5$			; BR IF YES
	MOVL	#28,R2			; SET FOR LONGWORD OUTPUT
	MOVL	PID-B(R11),R3		; GET PID OF TARGET
	BSBB	OUTCOM			; OUTPUT PID AS LONGWORD
	MOVZBL	#^A':',R0		; SEPARATE WITH ':'
	BSBB	OUTCHAR			; OUTPUT COLON
	.ENDC				;
5$:	MOVL	CURDOT-B(R11),R3	; GET ADDRESS
	MOVL	#28,R2			; ASSUME LONGWORD OUTPUT
	TSTL	(R10)			; CHECK FOR PROCESSOR REGISTER
	BGEQ	10$			; NO, JUST A LONGWORD
	MOVZBL	#^A'P',R0		; PRECEDE WITH A 'P'
	BSBB	OUTCHAR			; OUTPUT P
	MOVL	#4,R2			; SET FIELD TO 2 DIGITS
10$:	BSBB	OUTCOM			; COMMON OUTPUT
	MOVZBL	#SLSH,R0		; OUTPUT SLASH
	BRB	OUTCHAR			; RETURN THROUGH OUTCHAR
OUTDIGIT:				; OUTPUT ONE DIGIT
	CLRL	R2			; ZAP DIGIT SELECTOR
	BRB	OUTCOM			; AND MERGE WITH COMMON

OUTLONG:				; OUTPUT LONGWORD
	MOVL	#28,R2			; SET DIGIT SELECTOR
OUTCOM:					; FORMAT IT
	MOVAB	OUTBUF-B(R11),R4	; GET ADDRESS OF OUTPUT BUFFER
10$:	EXTZV	R2,#4,R3,R1		; GET DIGIT
	MOVB	PRIMARY[R1],(R4)+	; BUFFER IT
	SUBL	#4,R2			; NEXT DIGIT
	BGEQ	10$			; DO ALL REQUESTED
	CLRB	(R4)			; MARK END OF BUFFER
OUTZBUF:MOVAB	OUTBUF-B(R11),R4	; GET START OF BUFFER

OUTZSTRING:				; OUTPUT ASCIZ STRING
	MOVZBL	(R4)+,R0		; GET A CHAR
	BEQL	10$			; BR IF DONE
	BSBB	OUTCHAR			; OUTPUT CHAR
	BRB	OUTZSTRING		; CONTINUE
10$:	RSB				; RETURN IF DONE


OUTBSLSH:				; OUTPUT BACK SLASH
	MOVZBL	#BSLSH,R0		; SET CHARACTER CODE
	BRB	OUTCHAR			; AND OUTPUT IT
OUTR8:	MOVZBL	R8,R0			; GET CHAR TO OUTPUT
OUTCHAR:				; OUTPUT CHAR IN R0
	.IF	NDF,SW_PROCESS		;
	TSTL	AP			; CHECK FOR CONSOLE
	BNEQ	10$			; NO, USE DEVICE DIRECTLY
	MFPR	#PR$_TXCS,R1		; GET CONSOLE TRANSMIT STATUS
	BRB	20$			; MERGE WITH COMMON CODE
10$:	MOVW	OUTCR(AP),R1		; GET STATUS
20$:	BBC	#7,R1,OUTCHAR		; WAIT FOR READY
	TSTL	AP			; CHECK FOR CONSOLE
	BNEQ	30$			; YES
	MTPR	R0,#PR$_TXDB		; SEND CHARACTER TO CONSOLE
	RSB				; RETURN
30$:	MOVB	R0,OUTB(AP)		; OUTPUT CHAR
	.IFF				; FALSE FOR PROCESS VERSION
	PUSHL	R0			; BUFFER CHARACTER ON STACK
	MOVL	SP,R0			; SAVE POINTER TO IT
	$QIO_S	EFN=#30,-		;
		CHAN=TTCHAN,-		; 
		FUNC=#IO$_WRITEVBLK,-	;
		P1=(R0),-		; BUFFER ADDRESS
		P2=#1			; ONE CHARACTER
	POPR	#^M<R0>			; RESTORE CHARACTER
	.ENDC				;
	RSB				; AND RETURN
OUTSPACE:				;
	MOVZBL	#32,R0			; SET CODE FOR SPACE
	BRB	OUTCHAR			; AND SEND IT
CRLF:	MOVZBL	#CR,R0			; RETURN
	BSBB	OUTCHAR			; SEND IT
	MOVZBL	#LF,R0			; LINE FEED
	BRB	OUTCHAR			; SEND IT


	.PAGE
	.SBTTL	GETCHAR - GET INPUT CHARACTER ROUTINE

;
;	GETCHAR - GET INPUT CHARACTER
;
; OUTPUT:
;	R8 - INPUT CHARACTER
;	R9 - BUFFER POINTER UPDATED (BUFFER IN ASCIZ FORMAT)
;

GETCHAR:				;
	MOVZBL	(R9)+,R8		; GET NEXT CHARACTER
	BEQL	10$			; READ IF NONE AVAIL
	RSB
10$:	MOVAB	INBUF-B(R11),R9		; SET ADDRESS OF INPUT BUFFER
	.IF	NDF,SW_PROCESS		;
20$:	TSTL	AP			; CHECK FOR CONSOLE
	BEQL	30$			; YES
	MOVW	RDCR(AP),R0		; GET STATUS
	BRB	40$			; CHECK STATUS
30$:	MFPR	#PR$_RXCS,R0		; GET CONSOLE STATUS
40$:	BBC	#7,R0,20$		; WAIT FOR READY
	TSTL	AP			; CHECK FOR CONSOLE
	BEQL	50$			; YES
	MOVB	RDBUF(AP),R8		; GET CHARACTER
	BRB	60$			; MERGE WITH COMMON
50$:	MFPR	#PR$_RXDB,R8		; GET CONSOLE CHARACTER
	.IFF				; FALSE IF PROCESS VERSION
15$:	MOVAB	TERMASKD,R1		; ADDRESS OF TERMINATOR MASK DESCR
	$QIOW_S	EFN=#31,-		; 
		CHAN=TTCHAN,-		; INPUT DEVICE CHANNEL
		IOSB=TTIOSB,-		; IO STATUS BLOCK
		FUNC=#<IO$_READVBLK>,-	;
		P1=(R9),-		; BUFFER ADDRESS
		P2=#80,-		; READ SIZE
	P4=R1				;
	MOVZWL	TTIOSB+2,R0		; GET SIZE READ
	MOVB	TTIOSB+4,(R0)+[R9]	; BUFFER TERMINATOR 
	CLRB	(R9)[R0]		; MARK END OF BUFFER
	MOVL	R9,R2			; POINT TO START OF STRING
20$:	MOVZBL	(R2)+,R8		; GET A CHARACTER
	BEQL	15$			; EMPTY, READ SOME MORE
	.ENDC				;
60$:	BICB	#^X80,R8		; STRIP PARITY
	CMPB	R8,#RUBOUT		; CHECK FOR RUBOUT
	BNEQ	90$			; NO
	BBSS	#V_RUB,(R10),70$	; SET START OF RUBOUT SEQUENCE
	BSBW	OUTBSLSH		; OUTPUT BACK SLASH
70$:	MOVZBL	-(R9),R8		; GET RUBBED OUT CHAR
	BNEQ	80$			; SKIP INC
	INCL	R9			; POINT AT START OF BUFFER
	BRB	20$			; AND GET ANOTHER
80$:	BSBW	OUTR8			; OUTPUT RUBBED OUT CHAR
	BRB	20$			; AND GET ANOTHER
90$:	BBCC	#V_RUB,(R10),100$	; TERMINATE RUBOUT SEQUENCE
	BSBW	OUTBSLSH		; OUTPUT BACK SLASH
100$:	BBC	#6,R8,110$		; BR IF NOT ALPHA
	BICB	#32,R8			; SET TO UPPER CASE
110$:					;
	.IF	NDF,SW_PROCESS		;
	BSBW	OUTR8			; ECHO CHARACTER
	.ENDC				;
	MOVB	R8,(R9)+		; BUFFER NEW CHAR
	LOCC	R8,#NTERM,TERM		; CHECK FOR TERMINATOR
	BEQL	20$			; NOT A TERMINATOR
	CMPB	#CR,R8			; IS CHAR = RETURN
	BNEQ	120$			; NO,
	BSBW	CRLF			; YES, SEND CR/LF
120$:	CLRB	(R9)			; MARK END OF BUFFER
	MOVAB	INBUF-B(R11),R9		; RESTORE BUFFER BASE
	BRW	GETCHAR			; AND TRY AGAIN
	.PAGE
	.SBTTL	PLUS/MINUS OPERATORS
;
;	PLUS/MINUS OPERATORS
;
BLANK:					; SAME AS PLUS
OPERATOR:				; 
	BSBW	ENDEXPR			; END EXPR
	SUBB3	#OPERBAS,R0,OPER-B(R11)	; SET OPERATOR
	RSB				; RETURN
;
;	MONADIC MINUS - NEGATE
;
NEGATE:	TSTL	R6			; TEST ACCUMULATOR
	BEQL	5$			; EMPTY
	BSBW	ENDEXPR			; OTHERWISE PERFORM OPERATION
5$:	XORB	#<1@V_NEGATE>,(R10)	; TOGGLE NEGATE FLAG
10$:	RSB				; AND RETURN


	.PAGE
	.SBTTL	TAB - INDIRECT DISPLAY
;
;	TAB
;
TAB:	MOVL	QUAN-B(R11),CURDOT-B(R11)	; GO INDIRECT
	EXTZV	#V_PRMODE,#1,(R10),R0	; GET PROCESSOR REGISTER MODE
	INSV	R0,#V_PREG,#1,(R10)	; AND COPY TO SEMI-PERMANENT FLAG
	BRB	LOCP			; AND DISPLAY IT

;
;	ESCAPE - DISPLAY PREVIOUS LOCATION
;

ESCAP:					;
	MOVL	#1,R1			; ASSUME UNIT INCREMENT
	TSTL	(R10)			; CHECK FOR PROCESSOR REGISTER
	BLSS	10$			; YES, USE UNIT INCREMENT
	ROTL	CURTYPE-B(R11),R1,R1	; FORM INCREMENT
10$:	SUBL	R1,CURDOT-B(R11)	; AND SUBTRACT FROM DOT
LOCP:	BRW	LOCPROMPT		; PROMPT WITH CONTENT
	.PAGE
	.SBTTL	EQUALS - DISPLAY VALUE
;
;	EQUALS - VALUE DISPLAY
;
EQUALS:					;
	.ENABL	LSB			;
	BSBW	ENDFIELD		; TERMINATE FIELD
	BBC	#V_F1,(R10),10$		; IGNORE IF FIELD BLANK
EQL1:	MOVL	F1-B(R11),QUAN-B(R11)	; SET QUANTITY
10$:	BSBW	OUTPUT			; OUTPUT IT
;	BRB	RESET			; RESET SCANNER
	.DSABL	LSB			;

;
;	RESET
;

RESET:	BICL	#^X0FFFF80,(R10)		; CLEAR FIELD AND NEGATE FLAGS
	CLRB	FCTR-B(R11)		; CLEAR FIELD COUNTER
	CLRQ	R6			; RESET ACCUMULATORS
	RSB				; RETURN
	.PAGE
	.SBTTL	SEMI - SECONDARY COMMAND SET
;
;	SEMI
;

SECOND:					;
	.ASCII	/X/			; X REGISTER SET/DISPLAY
	.ASCII	/P/			; P - PROCEED
	.ASCII	/M/			; M - SET MODIFY FLAG
	.ASCII	/I/			; I - PROGRAM COUNTER
	.ASCII	/G/			; G - GO, START
	.ASCII	/E/			; E - EXECUTE STRING
	.ASCII	/B/			; B - SET/CLR BREAKPOINT
NSEC=.-SECOND				; NUMBER OF SECONDARY COMMANDS

SEMI:					;
	BICB	#<1@V_OPEN>,(R10)	; CLEAR OPEN FLAG
	BSBW	ENDFIELD		; TERMINATE FIELD
	BSBW	GETCHAR			; GET SECONDARY COMMAND CHAR
	LOCC	R8,#NSEC,SECOND		; LOCATE SECONDARY COMMAND
10$:	CASE	R0,LIMIT=#1,<-		; SWITCH ON TYPE
		BRKPOINT,-		; SET BREAKPOINT
		EXECUTE,-		; EXECUTE STRING
		GO,-			; SEMI-G, GO
		PROGCTR,-		; SEMI-I, INSTRUCTION CONTER
		MFYFLGS,-		; SEMI-M, MODIFY FLAG
		PROCED,-		; SEMI-P, PROCEED
		XSET,-			; SET XREGISTER
		>			;
ERR2:	BRW	ERROR			; ERROR
	.PAGE
	.SBTTL	LEFT BRACKET - MODE SELECTION
;
;
;	LEFT BRACKET
;
MODES:					; MODE CHARACTER LIST
	.ASCII	/C/			; CHARACTER
	.ASCII	/L/			; LONG, HEX
	.ASCII	/W/			; WORD, HEX
	.ASCII	/B/			; BYTE, HEX
NMODES=.-MODES				; NUMBER OF MODE CHARACTERS


LBRACKET:				; MODE SELECTION
	BSBW	GETCHAR			; GET MODE CHAR
	LOCC	R8,#NMODES,MODES	; CONVERT TO INDEX
	BEQL	ERR2			; NOT FOUND, ERROR
	BBS	#2,R0,10$		; CHECK FOR 'C'
	SUBB3	#1,R0,CURTYPE-B(R11)	; SET MODE
	BICB	#<1@V_ASCII>,(R10)	; CLEAR CHAR MODE
	RSB				; RETURN
10$:	BISB	#<1@V_ASCII>,(R10)	; SET CHARACTER MODE
	RSB
	.PAGE
	.SBTTL	SINGLE STEP
;
;	STEP
;
STEP:	INSV	#1,#V_TBIT,#2,(R10)	; CLR V_ATBRK, SET V_TBIT
	BBCC	#V_PRMODE,(R10),20$	; CLEAR PROCESSOR REGISTER DISPLAY MODE
20$:	RET				; AND RETURN
	.PAGE
	.SBTTL	BRKPOINT - SET/CLEAR BREAKPOINTS
;
;	BRKPOINT
;
BRKPOINT:				; 
	BBC	#V_F1,(R10),SHOBRK	; DISPLAY BREAKPOINTS
	BBS	#V_F2,(R10),20$		; YES, IT WAS SPECIFIED
	MOVL	#1,R2			; INIT INDEX
10$:	TSTL	BRKADR[R2]		; FIND FREE SLOT
	BEQL	30$			; YES, GOT ONE
	ACBL	#NBRK,#1,R2,10$		; CHECK THEM ALL
	BRB	ERR2			; ERROR
20$:	MOVL	F2-B(R11),R2		; GET BRKPOINT NUMBER
	BEQL	10$			; NULL FIELD, SCAN FOR SLOT
	CMPL	#NBRK,R2		; CHECK FOR LEGAL
	BLSS	ERR2			; OUT OF RANGE
30$:	CLRL	BRKDSP[R2]		; CLEAR DISPLAY
	CLRL	BRKCOM[R2]		; CLEAR COMMAND ADDRESS
	MOVL	F1-B(R11),R0		; GET BREAKPOINT ADDRESS
	BEQL	35$			; ALLOW CLEAR OF BREAKPOINT
	.IF	DF,SW_PROCESS		;
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6>	; SAVE REGISTERS FOR PROTECTION CHANGE
	MOVL	R0,R5			; SET START ADDRESS
	MOVL	R0,R6			; AND END ADDRESS
	BSBW	SETWRT			; SET PAGE WRITABLE
	MOVL	(SP),R0			; RESTORE BPT ADDRESS
	.ENDC				;
	MOVB	(R0),(R0)		; TEST WRITABILITY OF ADDRESS
	.IF	DF,SW_PROCESS		;
	BSBW	REPROT			; RESTORE PROTECTION
	POPR	#^M<R0,R1,R2,R3,R4,R5,R6>	; AND REGISTERS
	.ENDC				;
35$:	BBC	#V_F3,(R10),40$		; DISPLAY SPECIFIED?
	MOVL	F3-B(R11),BRKDSP[R2]	; SET DISPLAY START
	BEQL	40$			; SKIP TEST IF NULL
	TSTL	@F3-B(R11)		; CHECK READABILITY
40$:	BBC	#V_F4,(R10),45$		; SKIP IF NO COMMAND ADDRESS
	MOVL	F4-B(R11),BRKCOM[R2]	; SET COMMAND STRING
45$:	MOVL	R0,BRKADR[R2]		; SAVE BREAKPOINT ADDRESS
	BRW	RESET			; RESET SCANNER AND RETURN
;
;	SHOBRK
;
SHOBRK:					;
	MOVL	#1,R5			; INIT INDEX FOR LOOP
10$:	MOVL	BRKADR[R5],R8		; GET BREAKPOINT ADDRESS
	BEQL	20$			; SKIP IF NULL
	MOVL	R5,R3			; BREAKPOINT NUMBER
	BSBW	CRLF			; NEW LINE
	BSBW	OUTDIGIT		; BPT NUMBER
	BSBW	OUTSPACE		; SPACE
	MOVL	R8,R3			; ADDRESS OF BPT
	BSBW	OUTLONG			; OUTPUT ADDRESS
	BSBW	OUTSPACE		; SPACE OVER
	MOVL	BRKDSP[R5],R3		; GET DISPLAY START
	BEQL	15$			; NONE
	BSBW	OUTLONG			; OUTPUT DISPLAY START
15$:	MOVL	BRKCOM[R5],R3		; GET COMMAND STRING ADDRESS
	BEQL	20$			; NONE
	BSBW	OUTSPACE		; SPACE ANOTHER
	BSBW	OUTLONG			; AND OUTPUT A LONGWORD
20$:	ACBL	#NBRK,#1,R5,10$		; DO THEM ALL
	BRW	CRLF			; AND EXIT THROUGH CRLF
	.PAGE
	.SBTTL	GO - START EXECUTION AT SPECIFIED LOCATION
;
;	GO
;
GO:	BBC	#V_F1,(R10),PROCED	; JUST PROCEED IF NO VALUE
	MOVL	F1-B(R11),SAVPC-B(R11)	; SET NEW PC
;	BRW	PROCED			; FALL INTO PROCEED
;
;	PROCEED
;
PROCED:					;
	RET				; RETURN
	.PAGE
	.SBTTL	SEMI-I, PC VALUE
;
;	SEMI-I
;
COLON:	BSBW	ENDEXPR			; TERMINATE EXPRESSION
	MOVL	R7,PID-B(R11)		; SET PID FOR PROCESS 
	CLRQ	R6			; RESET ACCUMULATORS
	RSB				; 

MFYFLGS:MOVAL	MFYFLG-B(R11),R1	; SET MODIFY FLAG ADDRESS
	BRB	VALUE			; SET/GET VALUE
DOT:	MOVAL	CURDOT-B(R11),R1	; SET ADDRESS OF DOT
	BBC	#V_PREG,(R10),VALR	; WAS IT PROCESSOR REGISTER?
	BBSS	#V_PRMODE,(R10),VALR	; YES, SET PROCESSOR REGISTER MODE
	BRB	VALR			; READ VALUE
QUANT:	MOVAL	QUAN-B(R11),R1		; SET QUANTITY ADDRESS
	BRB	VALR			; READ VALUE
PROGCTR:				;
	MOVAL	SAVPC-B(R11),R1		; SET PC ADDRESS
VALUE:	BBC	#V_F1,(R10),VALR	; SKIP IF NO VALUE
	MOVL	F1-B(R11),(R1)		; SET NEW VALUE FOR PC
VALR:	MOVL	(R1),R6	; AND GET VALUE
VALI:	BRW	INFLD			; SET FIELD IN PROGRESS
REGISTER:				;
	MOVAL	SAVREG-B(R11),R5	; SET BASE OF REGISTER AREA
	BSBB	REGCOM			; FETCH ADDRESS
	BRB	VALI			; AND USE IT
REGCOM:	BSBW	GETCHAR			; GET SECOND CHAR
	LOCC	R8,#16,PRIMARY		; TRANSLATE TO HEX
	.IF	DF,SW_PROCESS		; FOR PROCESS VERSION
	BNEQ	10$			; LEGAL HEX DIGIT
	CMPW	#^A/XI/,-2(R9)		; CHECK FOR EXIT COMMAND
	BNEQ	ERR3			; NO, ERROR
	$EXIT_S	EXITCODE		; YES EXIT
	.IFF				;
	BEQL	ERR3			; ERROR, NOT HEX
	.ENDC				;
10$:					;
	SUBL3	R0,#16,R0		; INVERT
	MOVAL	(R5)[R0],R6		; ACCUMULATE
	RSB				; RETURN

XSET:	BBC	#V_F2,(R10),ERR3	; ERROR IF NOT TWO FIELDS
	EXTZV	#0,#4,F2-B(R11),R1	; GET REGISTER NUMBER
	MOVAL	XREGV[R1],R1		; AND COMPUTE REGISTER ADDRESS
	BRB	VALUE			; PROCESS VALUE
XREG:					; X-REGISTER VALUE
	MOVAL	XREGV,R5		; SET ADDRESS OF REGISTER VECTOR
	BSBB	REGCOM			; ADDRESS TO R6
	MOVL	(R6),R6			; GET VALUE
	BRB	VALI			; AND NOTE INPUT IN FIELD
	.ALIGN	LONG			; LONGWORD ALIGN EXCEPTION ROUTINES
XDELACV:				; ACCESS VIOLATION HANDLER
MCHK:					; MACHINE CHECK
	.IF	NDF,SW_PROCESS		;
	TSTL	AP			; CHECK FOR SIMULATOR
	BNEQ	ERR3			; YES, SKIP RESET
					;
					;
	CPUDISP	<CLR_780,-		; *DISPATCH ON CPU TYPE*
		CLR_750,-		;
		CLR_730>
					;
CLR_780:				; FOR 11/780:
	MTPR	#0,#PR$_SBIFS		; CLEAR SBI FAULT
	BRB	CLR_END			; ERROR CLEARED
					;
CLR_730:				; FOR 11/730:
CLR_750:				; FOR 11/750:
	MTPR	#^XF,#PR$_MCESR		; SET 1 TO CLEAR MCHECK ERROR SUMMARY
					;
CLR_END:				; *END OF CPU-DEPENDENT CODE*
					;
					;
	.ENDC				;
10$:					;
ERR3:	BRW	ERROR			; AND DECLARE ERROR

	.PAGE
	.SBTTL	REGISTER SAVE AND RESTORE

;
;	SAVE - SAVE TARGET REGISTERS, PC, PSL
;
SAVE:					;
	.IF	NDF,SW_PROCESS		;
	SETIPL	#31			; DISABLE
;	JSB	INI$WRITABLE		; MAKE THE SYSTEM WRITABLE
	MOVQ	R0,SAVREG		; SAVE R0,R1
	MOVAB	SAVR2,R1		; SETUP BASE FOR REMAINING REGS
	.IFF				; FALSE IF PROCESS VERSION
	$SETAST_S	#0		; DISABLE ASTS
	PUSHAB	-(R0)			; SAVE ENABLE VALUE-1
	MOVPSL	R1			; GET CURRENT PSL
	EXTZV	#PSL$V_CURMOD,#PSL$S_CURMOD,R1,R1	; ISOLATE CURRENT MODE
	MULW	#CONTEXTSZ,R1		; COMPUTE OFFSET TO PROPER CONTEXT AREA
	MOVAB	SAVREG[R1],R1		; FORM ADDRESS OF REGISTER SAVE
	MOVL	8(AP),R0		; GET POINTER TO MECHANISM
	MOVQ	12(R0),(R1)+		; SAVE R0,R1
	.ENDC				;
	MOVQ	R2,(R1)+		; SAVE R2,R3
	MOVQ	R4,(R1)+		; SAVE R4,R5
	MOVQ	R6,(R1)+		; SAVE R6,R7
	MOVQ	R8,(R1)+		; SAVE R8,R9
	MOVQ	R10,(R1)+		; SAVE R10,R11
	.IF	NDF,SW_PROCESS		;
	MOVQ	AP,(R1)+		; SAVE AP,FP
	MOVAB	12(SP),(R1)+		; ASSUME KERNEL STACK
	MOVQ	4(SP),(R1)+		; SAVE PC,PSL
	.IFF				;
	MOVQ	8(FP),(R1)+		; SAVE AP,FP
	SUBL3	#1,@4(AP),R0		; GET NUMBER OF ARGS IN SIGNAL
	MOVAL	@4(AP)[R0],R0		; POINT TO PC,PSL
	MOVAL	8(R0),(R1)+		; COMPUTE SP
	MOVQ	(R0),(R1)+		; SAVE PC,PSL
	.ENDC				;
	.IF	NDF,SW_PROCESS		;
	MFPR	#PR$_TXCS,(R1)+		; SAVE CONSOLE TRANSMIT STATUS
	MFPR	#PR$_RXCS,(R1)+		; SAVE CONSOLE RECVR STATUS
	CLRL	AP			; ZAP DEVICE ADDRESS BASE
	.ENDC				;
	.IF	NDF,SW_PROCESS		;
	MTPR	#0,#PR$_TXCS		; CLEAR INTERRUPT ENABLE
	MTPR	#0,#PR$_RXCS		; FOR BOTH TRANSMIT AND RECEIVE
	.ENDC				;
	.IF	NDF,SW_PROCESS		;
20$:	MOVAB	B,R11			; AND DATA BASE ADDRESS
	.IFF				; FALSE FOR PROCESS VERSION
	MOVAB	W^<B-<SAVPSL+4>>(R1),R11	; SET BASE OF CONTEXT AREA
	MOVL	(SP)+,ASTEN-B(R11)	; SAVE AST ENABLE
	.ENDC				;
	MOVAB	STATUS-B(R11),R10	; SET STATUS BASE
	MOVAB	INBUF-B(R11),R9		; POINT TO INPUT BUFFER
	CLRB	(R9)			; MAKE BUFFER EMPTY
	.IF	NDF,SW_PROCESS		;
	BSBW	GETSCB			; GET BASE OF SCB
	MOVL	4(R0),MCHKSAV		; SAVE ORIGINAL MCHK VECTOR
	MOVAB	MCHK,4(R0)		; SET TO XDELTA VECTOR
	MOVAB	XDELACV,^X20(R0)	; SET ACCESS VIOLATION VECTOR
	MOVAB	XDELACV,^X24(R0)	; SET PG FAULT VECTOR
	MOVAB	XDELACV,^X18(R0)	; SET RESERVED OPERAND HANDLER
	EXTZV	#PSL$V_CURMOD,#PSL$S_CURMOD,8(SP),R0	; GET MODE
	BEQL	30$			; CORRECT ALREADY IF KERNEL
	ADDL	#PR$_KSP,R0		; COMPUTE PROCESSOR REGISTER
	MFPR	R0,SAVSP-B(R11)		; AND SAVE CORRECT SP
	.ENDC				;
30$:	BRW	RESET			; RESET SCANNER

;
;	RESTORE - RESTORE TARGET REGISTERS
;
RESTORE:				; RESTORE EVERYTHING
	.IF	NDF,SW_PROCESS		;
	MOVQ	SAVPC-B(R11),4(SP)	; SET PC,PSL
	.IFF				; FALSE IF PROCESS
	SUBL3	#1,@4(AP),R0		; GET SIGNAL ARG COUNT
	MOVAL	@4(AP)[R0],R0		; COMPUTE ADDRESS OF PC,PSL
	MOVQ	SAVPC-B(R11),(R0)	; STORE UPDATED PC,PSL
	.ENDC				;
RESTORR:				; RESTORE REGISTERS ONLY
	.IF	NDF,SW_PROCESS		;
	BSBB	GETSCB			; GET BASE OF SCB
	MOVAB	EXE$ACVIOLAT,^X20(R0)	; RESTORE ACCESS VECTOR
	MOVAB	MMG$PAGEFAULT,^X24(R0)	; AND PAGE FAULT VECTOR
	MOVL	MCHKSAV,4(R0)		; RESTORE MACHINE CHECK VECTOR
	MOVAB	EXE$ROPRAND,^X18(R0)	; RESTORE RESERVED OPERAND VECTOR
	TSTW	AP			; CHECK FOR CONSOLE
	BNEQ	10$			; NO, OTHER DEVICE
	MTPR	SAVOCR-B(R11),#PR$_TXCS	; RESTORE INITIAL TX STATUS
	MTPR	SAVRXCS-B(R11),#PR$_RXCS; AND INITIAL RECEIVER STATE
	BRB	20$			; MERGE WITH COMMON CODE
10$:	MOVW	SAVOCR-B(R11),OUTCR(AP)	; RESTORE OUTPUT CSR
	MOVW	SAVRCR-B(R11),RDCR(AP)	; AND INPUT CSR CONTENT
	.IFF				;
	PUSHL	ASTEN-B(R11)		; SAVE AST ENABLE
	.ENDC				;
20$:	MOVAB	SAVR2-B(R11),R1		; SET BASE FOR RESTORE
	MOVQ	(R1)+,R2		; RESTORE R2,R3
	MOVQ	(R1)+,R4		; RESTORE R4,R5
	MOVQ	(R1)+,R6		; RESTORE R6,R7
	MOVQ	(R1)+,R8		; RESTORE R8,R9
	MOVQ	(R1)+,R10		; RESTORE R10,R11
	.IF	NDF,SW_PROCESS		;
	MOVQ	(R1)+,AP		; RESTORE AP,FP
	MOVQ	SAVREG,R0		; RESTORE R0,R1
	.IFF				; FALSE IF PROCESS VERSION
	MOVQ	(R1)+,8(FP)		; SET NEW VALUES FOR AP,FP
	MOVL	8(AP),R0		; GET MECHANISM POINTER
	MOVQ	<SAVREG-SAVSP>(R1),12(R0)	; STORE UPDATED R0,R1
	MOVPSL	R1			; GET CURRENT PSL
	EXTZV	#PSL$V_CURMOD,#PSL$S_CURMOD,R1,R1	; GET CURRENT MODE
	BBCC	R1,DBGACTIVE,30$	; CLEAR ACTIVE BIT FOR MODE
30$:					;
	TSTL	(SP)+			; CHECK FOR AST ENABLE
	BEQL	35$			; NO
	$SETAST_S	#1		; RE- ENABLE AST RECOGNITION
35$:					;
	.ENDC				;
	.IF	NDF,SW_PROCESS		;
;	JSB	INI$RDONLY		; REPROTECT THE SYSTEM CODE
	.ENDC				;
	RSB				; AND RETURN
	.PAGE
	.PAGE
	.SBTTL	GET SCB ADDRESS

;
; SUBROUTINE GETSCB IS CALLED TO GET THE PHYSICAL OR VIRTUAL
; ADDRESS OF THE CURRENT SCB.
;
; INPUTS:	NONE
;
; OUTPUTS:	R0 = SCB ADDRESS
;		OTHER REGISTERS PRESERVED
;

	.IF	NDF,SW_PROCESS		; NOT FOR PROCESS VERSION
GETSCB:	MFPR	#PR$_MAPEN,R0		; GET MAPPING STATUS
	BNEQ	10$			; BRANCH IF MAPPING ENABLED
	MFPR	#PR$_SCBB,R0		; ELSE GET PHY ADDR OF SCB
	BRB	20$			; JOIN COMMON RETURN
10$:	MOVAL	SCB$AL_BASE,R0		; IF MAPPING ENABLED, GET SCB VA
20$:	RSB				; RETURN
	.ENDC				;
	.PAGE
	.SBTTL	BPT TRAP HANDLER
;
;	HANDLE BREAKPOINT TRAPS
;
BMSG:	.ASCIZ	/ BRK AT /		; BREAK POINT MESSAGE
	.ALIGN	LONG			; LONGWORD ALIGNMENT
	.IF	NDF,SW_PROCESS		; EXEC VERSION
XDELBPT::				; XDELTA BPT ENTRY
	.IFF				;
XDELBPT:				; DELTA BPT ENTRY
	.ENDC				;
	BSBW	SAVE			; SAVE REGS AND DISABLE
	BSBW	GETBPTX			; GET INDEX OF BPT
	TSTL	R3			; CHECK FOR MATCH
	BNEQ	10$			; YES, FOUND IT
	BSBW	RESTORR			; RESTORE REGISTERS ONLY
	.IF	NDF,SW_PROCESS		;
	MOVZBL	6(SP),-(SP)		; GET IPL
	ENBINT				; ENABLE
	JMP	EXE$BREAK		; AND HANDLE NORMALLY
	.IFF				; FALSE IF PROCESS VERSION
;
;	***** UNEXPECTED BREAKPOINT *****
	CLRL	R0			; RETURN FALSE
	RET				;
	.ENDC				;
10$:	BISB	#<<1@V_TBIT>!<1@V_ATBRK>>,(R10)	; SET STATUS
30$:					;
	BSBW	UNBRK			; RESTORE OPCODES
	BBS	#PSL$V_TBIT,SAVPSL-B(R11),PROCEED	; PROCEED IF BPT AND TBIT
	MOVL	R3,R5			; SAVE BPT NUMBER
	BSBW	CRLF			; OUTPUT CR/LF PAIR
	BSBW	OUTDIGIT		; OUTPUT BPT NUMBER
	MOVAB	BMSG,R4			; MSG ADDRESS
	BSBW	OUTZSTRING		; OUTPUT ASCIIZ
	MOVL	SAVPC-B(R11),R3		; OUTPUT PC
	BSBW	OUTLONG			; OUTPUT HEX LONGWORD
	BSBW	OUTSPACE		; SEND SPACE
	MOVL	BRKDSP[R5],R1		; GET ADDRESS TO DISPLAY
	BEQL	40$			; NONE
	MOVL	R1,CURDOT-B(R11)	; SET AS CURRENT DOT
	BSBW	LOCPROMPT		; AND DISPLAY
40$:	MOVL	BRKCOM[R5],R1		; GET COMMAND STRING ADDRESS
	BEQL	GETCMD			; NONE GET COMMAND
	MOVL	R1,R9			; SET TO SCAN STORED COMMAND
GETCMD:					; GET COMMANDS

	CALLG	(AP),DCOM		; PERFORM DEBUG COMMANDS
PROCEED:				; PROCEED
	BSBB	SETBRK			; SET BREAKPOINTS
	BBCC	#V_TBIT,(R10),50$	; TEST AND CLR TRACE FLAG
30$:	BBSS	#PSL$V_TBIT,SAVPSL-B(R11),40$	; SET TBIT
40$:					;
	.IF	DF,SW_PROCESS		; FOR PROCESS VERSION
	CMPB	#2,@SAVPC-B(R11)	; CHECK FOR REI OPCODE
	BNEQ	45$			; NO, NOTHING SPECIAL
	EXTZV	#PSL$V_CURMOD,#PSL$S_CURMOD,SAVPSL-B(R11),R0	; GET NEW MODE
	MULW	#CONTEXTSZ,R0		; SCALE BY PER MODE CONTEXT AREA SIZE
	MOVAB	STATUS-B(R0),R10	; POINT TO NEW FLAGS
	.ENDC				;
45$:	BBSS	#V_TBITOK,(R10),50$	; SET TBIT EXPECTED
50$:	BSBW	RESTORE			; RESTORE EVERYTHING
	.IF	NDF,SW_PROCESS		;
	REI				; AND RETURN
	.IFF				; FALSE IF PROCESS VERSION
	MOVL	#1,R0			; RETURN TRUE
	RET				;
	.ENDC				;

	.PAGE
	.SBTTL	TBIT EXCEPTION HANDLER
;
;	HANDLER FOR TBIT EXCEPTION
;
	.ALIGN	LONG			; LONGWORD ALIGNED
	.IF	NDF,SW_PROCESS		;
XDELTBIT::				; XDELTA TBIT HANDLER
	.IFF				;
XDELTBIT:				;
	.ENDC				;
	BSBW	SAVE			; SAVE AND DISABLE
	BBSC	#V_TBITOK,(R10),XDELDBG	; BR IF TBIT EXPECTED
	BSBW	RESTORR			; RESTORE REGISTERS
	.IF	NDF,SW_PROCESS		;
	MOVZBL	6(SP),-(SP)		; GET IPL FOR ENABLE
	ENBINT				; ENABLE
	JMP	EXE$TBIT		; OTHERWISE LET EXEC HANDLE
	.IFF				; FALSE IF PROCESS VERSION
	CLRL	R0			; RESIGNAL
	RET				; UNEXPECTED TBIT EXCEPTION
	.ENDC				;
XDELDBG:				; COMMON WITH DEBUG EXCEPTION
	BICL	#<1@PSL$V_TBIT>,SAVPSL-B(R11)	; CLEAR TBIT IN PSL
	BSBB	UNBRK			; REPLACE OPCODES
	BBSC	#V_ATBRK,(R10),PROCEED	; CHECK FOR PROCEED
;
;	OUTPUT STEP MESSAGE
;
	MOVL	SAVPC-B(R11),CURDOT-B(R11)	; SET ADDRESS
	IFNORD	#4,@CURDOT-B(R11),GETCMD	; SKIP DISPLAY IF NOT READABLE
	BSBW	LOCPROMPT		; PROMPT WITH ADDRESS/CONTENT
	BRB	GETCMD			; GO GET COMMANDS

	.PAGE
	.SBTTL	UNBRK - RESTORE OPCODES FOR BREAKPOINTS
;
;	UNBRK
;
UNBRK:					;
	MOVL	#NBRK,R1		; INIT LOOP
10$:	MOVL	BRKADR[R1],R0		; GET BREAKPOINT ADDRESS
	BEQL	20$			; SKIP IF NOT ENABLED
	.IF	DF,SW_PROCESS		;
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; SAVE REGS FOR PROTECTION CHANGE
	MOVL	R0,R4			; FORM INADR RANGE FOR SET PROTECTION
	MOVL	R0,R5			;
	BSBW	SETWRT			; SET PAGE WRITABLE
	MOVQ	(SP),R0			; RESTORE R0,R1
	.ENDC				;
	MOVB	BRKOP[R1],(R0)		; RESTORE OPCODE
	.IF	DF,SW_PROCESS		;
	BSBW	REPROT			; RESTORE PROTECTION
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; RESTORE REGISTERS
	.ENDC				;
20$:	SOBGTR	R1,10$			; DO THEM ALL
	RSB				; AND RETURN

	.PAGE
	.SBTTL	SETBRK - SET BREAK POINT INSTRUCTIONS
;
;	SETBRK
;
SETBRK:	MOVL	#NBRK,R1		; INIT LOOP
10$:	MOVL	BRKADR[R1],R0		; GET ADDRESS
	BEQL	20$			; SKIP IF NOT ENABLED
	MOVB	(R0),BRKOP[R1]		; SAVE OPCODE
	BITB	#<<1@V_TBIT>!<1@V_ATBRK>>,(R10)	; CHECK FOR TRACE
	BEQL	15$			; NO TRACE, SET ANYWAY
	CMPL	R0,SAVPC-B(R11)		; CHECK FOR AT BPT
	BEQL	20$			; YES, DONT SET IT
15$:					;
	.IF	DF,SW_PROCESS		;
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; SAVE REGISTERS FOR PROTECTION CHANGE
	MOVL	R0,R4			; SET START ADDRESS OF RANGE
	MOVL	R0,R5			; AND END ADDRESS
	BSBW	SETWRT			;SET PAGE WRITABLE
	MOVL	(SP),R0			; RESTORE BPT ADDRESS
	.ENDC				;
	MOVB	#3,(R0)			; SET BREAKPOINT OPCODE
	.IF	DF,SW_PROCESS		;
	BSBW	REPROT			; RESTORE ORIGINAL PROTECTION VALUE
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; AND REGISTERS
	.ENDC				;
20$:	SOBGTR	R1,10$			; DO THEM ALL
	RSB				; AND RETURN

	.PAGE
	.SBTTL	GETBPTX - GET INDEX FOR BREAKPOINT
;
;	GETBPTX
;
GETBPTX:				;
	MOVL	#NBRK,R3		; INIT LOOP
10$:	CMPL	SAVPC-B(R11),BRKADR[R3]	; IS THIS A BPT?
	BEQL	20$			; YES
	SOBGTR	R3,10$			; NO, CONTINUE
20$:	RSB				; RETURN
	.PAGE
	.SBTTL	QUOTE - INPUT CHARACTER STRING
;
;	QUOTE - START CHARACTER STRING INPUT
;
QUOTE:					;
	MOVL	CURDOT-B(R11),R5	; POINT TO STRING BUFFER
5$:	BSBW	GETCHAR			; GET CHARACTER
	CMPB	#QUOT,R8		; CHECK FOR QUOTE
	BEQL	10$			; YES, END OF STRING
	MOVB	R8,(R5)+		; INSERT IN BUFFER
	BRB	5$			; AND CONTINUE
10$:	MOVL	R5,CURDOT-B(R11)	; SAVE NEW DOT
	RSB				; RETURN
	.PAGE
	.SBTTL	DEPOSIT
;
;	DEPOSIT DATA
;
DEPOSIT:				;
	BBS	#V_PREG,(R10),40$	; BR IF PROCESSOR REGISTER
	.IF	DF,SW_PROCESS		;
	MOVL	CURDOT-B(R11),R4	; GET CURRENT DOT
	TSTL	PID-B(R11)		; CHECK FOR ARBITRARY PROCESS DEPOSIT
	BNEQ	50$			; BR IF YES
	.ENDC				;
	CASE	CURTYPE-B(R11),TYPE=B,<-	; SWITCH ON TYPE
		10$,-			; BYTE
		20$,-			; WORD
		30$,-			; LONG
		>			;
	.IF	NDF,SW_PROCESS		;
10$:	MOVB	F1-B(R11),@CURDOT-B(R11); STORE BYTE
	RSB				; RETURN
20$:	MOVW	F1-B(R11),@CURDOT-B(R11); STORE WORD
	RSB				; RETURN
30$:	MOVL	F1-B(R11),@CURDOT-B(R11); STORE LONG
	RSB				; RETURN
40$:	MTPR	F1-B(R11),CURDOT-B(R11)	; SET VALUE IN PROCESSOR REGISTER
	RSB
	.IFF				; FALSE IF PROCESS VERSION
10$:					; BYTE DEPOSIT
	MOVL	R4,R5			; START AND END ADDRESSES EQUAL
	BSBW	SETWRT			; SET WRITABLE, OLD PROT TO R2
	MOVB	F1-B(R11),(R4)		; STORE BYTE
	BSBW	REPROT			; RESTORE PROTECTION
	RSB				;

20$:	ADDL3	#1,R4,R5		; WORD DEPOSIT, FORM END ADDRESS
	BSBW	SETWRT			; SET WRITABLE
	MOVW	F1-B(R11),(R4)		; STORE WORD
	BSBW	REPROT			; RESTORE PROTECTION
	RSB				;

30$:	ADDL3	#3,R4,R5		; LONGWORD DEPOSIT, FORM END ADDRESS
	BSBW	SETWRT			; SET WRITABLE
	MOVL	F1-B(R11),(R4)		; STORE LONG WORD
	BSBW	REPROT			; RESTORE PROTECTION
	RSB				;

40$:					; PROCESSOR REGISTER
	$CMKRNL_S	B^DEPPREG,(AP)	; DEPOSIT IN PROCESSOR REGISTER
	RSB				;
50$:					; DEPOSIT IN ARBITRARY PROCESS
	CASE	CURTYPE-B(R11),TYPE=B,<-	; SWITCH ON TYPE
		60$,-			; BYTE
		70$,-			; WORD
		80$>			; LONGWORD
	RSB				;
60$:	PUSHAB	W^DPBYTE		; SET ADDRESS OF BYTE ROUTINE
	BRB	90$			;
70$:	PUSHAB	W^DPWORD		; SET ADDRESS OF WORD ROUTINE
	BRB	90$			;
80$:	PUSHAB	W^DPLONG		; SET ADDRESS OF LONG ROUTINE
90$:	PUSHL	PID-B(R11)		; SET PID OF TARGET
	PUSHL	CURDOT-B(R11)		; ADDRESS FOR STORE
	PUSHL	F1-B(R11)		; VALUE TO STORE
	PUSHL	#4			; ARGUMENT COUNT
	MOVL	SP,R0			; POINTER TO ARGUMENT LIST
	TSTL	MFYFLG-B(R11)		; CHECK FOR STORE ENABLED
	BEQL	100$			; BR IF NOT
	$CMKRNL_S	W^QGET,(R0)	; CALL TO QUEUE REQUEST
100$:	ADDL	#20,SP			; CLEAN STACK
	RSB				; AND RETURN

DEPPREG:.WORD	0			; DEPOSIT INTO PROCESSOR REGISTER
	MOVAB	W^PREXC,(FP)		; SET EXCEPTION HANDLER
	MTPR	F1-B(R11),CURDOT-B(R11)	; PLACE FIELD VALUE IN REG
	MOVL	#1,R0			; RETURN SUCESS
	RET				;

PREXC:	.WORD	0			; PROCESSOR REGISTER EXCEPTION HANDLER
	ADDL3	#4,8(AP),R1		; POINT TO EXCEPTION FP
	MOVL	(R1),12(FP)		; SET AS RETURN FP
	MOVAB	B^10$,16(FP)		; SET RETURN ADDRESS
10$:	MOVZWL	#1,R0		;SET NORMAL STATUS
	RET				; AND RETURN

	.ENDC
	.PAGE
	.SBTTL	EXECUTE - PERFORM COMMAND STRING
;
;	EXECUTE
;
EXECUTE:				;
	BBC	#V_F1,(R10),10$		; EXIT IF NO ADDRESS
	MOVL	F1-B(R11),R9		; SET CHAR STRING
	BNEQ	10$			; NOT NULL
	BRW	SUPERST			; SUPER RESET
10$:	RSB				; RETURN

	.PAGE
	.SBTTL	P - PROCESSOR REGISTER PREFIX
;
;	SET PROCESSOR REGISTER MODE
;
PREG:					; PROCESSOR REGISTER MODE
	BBSS	#V_PRMODE,(R10),10$	; SET PROCESSOR REG FLAG
10$:	RSB				; RETURN
	.PAGE
	.SBTTL	PROCESS DEBUGGER INITIALIZATION

	.IF	DF,SW_PROCESS		;
SALUTE:	.ASCIZ	<CR><LF>/DELTA Version X2.1/<CR><LF>	;

TEST:					; START ADDRESS OF IMAGE ENTRY
XDT$START::				; GLOBAL START ADDRESS FOR CLI DEBUG
	.WORD	0
DELTA_START:				; START ADDRESS FOR DEBUGGER ENTRY
	$WAKE_S				; NULL WAKE AND
	$HIBER_S			; HIBERNATE TO GET SYNCHRONIZED
	MOVAB	TERMASK,TERMASKD+4	; RELOCATE TERMINATOR MASK DESCR
	MOVAB	TTSTR,TTNAMD+4		; RELOCATE DESCRIPTOR
	MOVAB	EXIHANDLE,EXIHADR	;
	MOVAB	EXITCODE,EXCODA		; RELOCATE EXIT HANDLER ARGS
	CALLG	(AP),B^INITCALL		; GENERATE CALL FRAME
	RET				;

NOBRK:	MOVL	4(AP),AP		; GET EXCEPTION ARGUMENT LIST
	BRW	EXCEPT+2		; AND GOTO EXCEPTION HANDLER

INITCALL:
	.WORD	0			; ENTRY MASK
	MOVAB	W^CATCHALL,(FP)		; SET CATCHALL EXCEPTION HANDLER
	$DCLEXH_S	EXITBLK		; DECLARE USER MODE EXIT HANDLER
	$CMKRNL_S	W^SETEXC,(AP)	; SET EXCEPTION VECTORS
	$SETEXV_S	ADDRES=W^EXCEPT,-	;
			ACMODE=#3,-	;
			VECTOR=#0	; SET PRIMARY FOR USER
	$SETEXV_S	ADDRES=W^CATCHALL,-	; SET LAST CHANCE HANDLER
			ACMODE=#3,-	; FOR USER MODE
			VECTOR=#2	; SPECIFY LAST CHANCE HANDLER
	$ASSIGN_S	TTNAMD,TTCHAN	; ASSIGN DEVICE
	BLBS	R0,10$			; CONTINUE IF SUCCESS
	RET				; ELSE EXIT WITH ERROR CODE IN R0
10$:	MOVAB	SALUTE,R4		; SET ADDRESS OF SALUTATION
	BSBW	OUTZSTRING		; OUTPUT IT
	BBS	#CLI$V_DBGEXCP,24(AP),NOBRK	; BR IF LATER INVOCATION
					; VIA $DEBUG COMMAND
	CALLG	(AP),B^20$		; CREATE TOP CALL FRAME
	RET				;
20$:	.WORD	0			; NULL ENTRY MASK
	ADDL	#4,4(AP)		; ADVANCE STARTING ADDRESS POINTER
	MOVPSL	-(SP)			; SAVE PSL
	ADDL3	#2,@4(AP),-(SP)		; FETCH CURRENT STARTING ADDRESS
	MOVZWL	#SS$_DEBUG,-(SP)	; SET EXCEPTION CODE
	PUSHL	#3			; SIGNAL ARG COUNT
	MOVL	SP,R0			; SAVE POINTER
	MOVQ	R0,-(SP)		; SAVE PHONY R0,R1
	PUSHL	#0			; DEPTH
	PUSHL	FP			; FP
	PUSHL	#4			; ARG COUNT
	PUSHL	SP			; POINTER TO MECH
	PUSHL	R0			; POINTER TO SIGNAL
	CALLS	#2,W^EXCEPT		; SIGNAL PHONY EXCEPTION
	ADDL	#12,SP			; CLEAN BACK TO R0,R1
	MOVQ	(SP)+,R0		; RESTORE R0,R1
	ADDL	#8,SP			; CLEAN BACK TO PC,PSL
	REI				; RETURN TO TARGET PROGRAM


SETEXC:	.WORD	0			; ENTRY MASK
	$SETEXV_S	ADDRES=B^EXCEPT,-	;
			PRVHND=KCOND,-	;
			ACMODE=#0	; SET KERNEL
	$SETEXV_S	ADDRES=W^CATCHALL,-	;
			ACMODE=#0,-	; SET KERNEL MODE LAST CHANCE HANDLER
			VECTOR=#2	; SPECIFY LAST CHANCE VECTOR
;----------------------------------------------------------------------------
	$SETEXV_S	ADDRES=B^EXCEPT,-	;
			PRVHND=ECOND,-	;
			ACMODE=#1	; SET EXEC MODE EXCEPTION HANDLER
	$SETEXV_S	ADDRES=W^CATCHALL,-	;
			ACMODE=#1,-	; SET EXEC MODE LAST CHANCE HANDLER
			VECTOR=#2	; SPECIFY LAST CHANCE VECTOR
;----------------------------------------------------------------------------
	$SETEXV_S	ADDRES=B^EXCEPT,-	;
			PRVHND=SCOND,-	;
			ACMODE=#2	; SET SUPERVISOR MODE EXCEPTION HANDLER
	$SETEXV_S	ADDRES=W^CATCHALL,-	;
			ACMODE=#2,-	; SET SUPERVISOR LAST CHANCE HANDLER
			VECTOR=#2	; SPECIFY LAST CHANCE VECTOR
	RET				;

EXCEPT:	.WORD	0			; EXCEPTION HANDLER ENTRY MASK
	$SETEXV_S	ADDRES=B^EXCEPT,-	;
			ACMODE=#3,-	;
			VECTOR=#0	; RE-ESTABLISH USER PRIMARY VECTOR
	ADDL3	#4,4(AP),R0		; GET POINTER TO SIGNAL
	MOVPSL	R1			; GET CURRENT PSL
	EXTZV	#PSL$V_CURMOD,#PSL$S_CURMOD,R1,R1	;
	BBSS	R1,DBGACTIVE,40$	; BR IF ALREADY ACTIVE
	CMPL	#SS$_TBIT,(R0)		; IS IT TBIT?
	BNEQ	10$			; NO,
5$:	BRW	XDELTBIT		; YES, A TBIT
10$:	CMPL	#SS$_BREAK,(R0)		; IS IT BREAKPOINT?
	BNEQ	20$			; NO,
15$:	BRW	XDELBPT			; YES, A BREAKPOINT
20$:					; SOME OTHER EXCEPTION
	CMPL	#SS$_UNWINDING,(R0)	; IS IT UNWINDING
	BEQL	60$			; YES
	CMPL	#SS$_COMPAT,(R0)+	; IS IT COMPATIBILITY MODE EXCEPT?
	BNEQ	30$			; NO
	CMPL	#1,(R0)			; IS IT COMPATIBILITY BPT?
	BEQL	15$			; YES
	CMPL	#7,(R0)			; IS IT COMPATIBILITY TBIT?
	BEQL	5$			; YES
30$:	CMPL	#SS$_DEBUG,-(R0)	; IS IT DEBUG EXCEPTION?
	BNEQ	40$			; NO,
	BSBW	SAVE			; SAVE EVERYTHING
	BRW	XDELDBG			; AND TREAT AS FUNNY BPT
40$:					; UNEXPECTED EXCEPTION
	BBCC	R1,DBGACTIVE,50$	; CLEAR DEBUG ACTIVE
50$:	CLRL	R0			; RETURN FALSE FOR RESIGNAL
	RET				;
60$:	MOVL	#1,R0			; IGNORE AND RESIGNAL
	RET				;
	.PAGE
	.SBTTL	HANDLER FOR DEBUG EXCEPTIONS

DBGEXCEP:				;
	.WORD	0			;
	ADDL3	#4,8(AP),R1		; POINT TO EXCEPTION FP
	MOVL	FP,R0			; INIT LINK FOR CALL FRAMES
10$:	CMPL	12(R0),(R1)		; IS THIS THE LAST ONE?
	BEQL	20$			; YES
	MOVAB	B^30$,16(R0)		; SET FOR RETURN
	MOVL	12(R0),R0		;
	BRB	10$			; CONTINUE
20$:	MOVAB	XDELACV,16(R0)		; SET RETURN FOR ERROR
30$:	RET				;

CATCHALL:				; CATCHALL EXCEPTION HANDLER
	.WORD	0			; ENTRY MASK
	MOVPSL	R1			; GET CURMOD
	EXTZV	#PSL$V_CURMOD,#PSL$S_CURMOD,R1,R1	; ISOLATE CURRENT MODE
	BBCS	R1,DBGACTIVE,10$	; MUST NOT BE DEBUGGER EXCEPTION
	CLRL	R0			; RESIGNAL
	RET				;
10$:	BSBW	SAVE			; SAVE EVERYTHING
	ADDL3	#4,4(AP),R0		; POINT TO EXCEPTION CODE
	MOVL	(R0),R3			; GET IT
	BSBW	CRLF			; OUTPUT CR/LF
	BSBW	OUTLONG			; OUTPUT EXCEPTION CODE
	MOVAB	B^EXCMSG,R4		; OUTPUT MESSAGE
	BSBW	OUTZSTRING		; TEXT FOR EXCEPTION
	BRW	XDELDBG			; AND DISPLAY INSTRUCTION
EXCMSG:	.ASCIZ	/ EXCEPTION /		;

EXIHANDLE:				; EXIT HANDLER
	.WORD	0			; ENTRY MASK
	BITB	#15,DBGACTIVE		; TEST FOR DEBUG ACTIVE IN ANY MODE
	BEQL	10$			; NO, REPORT EXIT
	$CMKRNL_S	CLREXV,(AP)	; RESET EXCEPTION VECTORS
	MOVL	@4(AP),R0		; RESTORE
	RET				; RETURN
10$:					; PROGRAM EXIT
	MOVPSL	-(SP)			; BUILD EXCEPTION FRAME
	PUSHL	16(FP)			;
	PUSHL	@4(AP)			; EXIT CODE FOR EXCEPTION CODE
	PUSHL	#3			; ARG COUNT
	PUSHR	#^M<R0,R1>		;
	MOVQ	AP,-(SP)		;
	PUSHL	#4			; MECHANISM COUNT
	PUSHL	SP			; POINTER TO MECHANISM
	PUSHAL	24(SP)			; POINTER TO SIGNAL
	PUSHL	#2			;
	MOVL	SP,AP			; SET AP FOR EXCEPTION
	BSBW	SAVE			; SAVE EVERYTHING
	MOVAB	B^EXIMSG,R4		; DISPLAY EXIT MESSAGE
	BSBW	OUTZSTRING		; OUTPUT TEXT
	MOVL	SAVAP-B(R11),R3		; GET POINTER TO EXCEPTION ARGLIST
	MOVL	4(R3),R3		; GET EXIT CODE ADDRESS
	BSBW	OUTLONG			; DISPLAY IT
	$DCLEXH_S	EXITBLK		; RE-ESTABLISH EXIT HANDLER
	MOVPSL	R1			; GET CURRENT PSL
	EXTZV	#PSL$V_CURMOD,#PSL$S_CURMOD,R1,R1 ; GET CURRENT MODE
	BBSS	R1,DBGACTIVE,20$	; SET DELTA ACTIVE FOR MODE
20$:	BRW	XDELDBG			;

EXIMSG:	.ASCIZ	<CR><LF>/ EXIT /	;

CLREXV:					; CLR EXCEPTION VECTORS
	.WORD	0			; ENTRY MASK
	$SETEXV_S	ADDRES=@KCOND,-	;
			ACMODE=#0	;
	$SETEXV_S	ADDRES=@ECOND,-	;
			ACMODE=#1	;
	$SETEXV_S	ADDRES=@SCOND,-	;
			ACMODE=#2	;
	RET				;

	.PAGE
	.SBTTL	SETWRT - SET PAGES WRITABLE

SETWRT:					;
	MOVAL	-(SP),R2		; ADDRESS FOR RETURN OF PROT
	$CMKRNL_S	B^SETPRTK,(R2)	;
	BLBS	R0,10$			; CONTINUE IF NO ERROR
	CALLG	(R2),B^SETPRTK		;
10$:	POPR	#^M<R2>			; RESTORE PROTECTION VALUE
	RSB				; RETURN

SETPRTK:.WORD	0			;
	MOVQ	R5,-(SP)		; INADR, START AND END ADDRESSES
	MOVL	SP,R1			; ADDRESS OF INADR
	$SETPRT_S	INADR=(R1),-	;
			PROT=#PRT$C_UW,-; WRITABLE BY ALL
			ACMODE=#0,-	;
			PRVPRT=(AP)	; ADDRESS AT WHICH TO RETURN PROT
	MOVL	#1,R0			; ALWAYS SUCCESS
	RET				;

REPROT:					; RESTORE PROTECTION
	RSB				; 
	.PAGE
	.SBTTL	FETCHP - FETCH DATA FROM ANOTHER PROCESS
FETCHP:	CASE	CURTYPE-B(R11),TYPE=B,<-	;
		10$,-			; 0 => BYTE
		20$,-			; 1 => WORD
		30$>			; 2 => LONG
	RSB				; UNKNOWN
10$:	PUSHAB	W^FPBYTE		; SET FOR BYTE FETCH
	BRB	40$			;
20$:	PUSHAB	W^FPWORD		; SET FOR WORD FETCH
	BRB	40$			;
30$:	PUSHAB	W^FPLONG		; SET FOR LONGWORD FETCH
40$:	PUSHL	PID-B(R11)		; PID OF TARGET PROCESS
	PUSHAB	QUAN-B(R11)		; SET ADDRESS TO RETURN VALUE
	PUSHL	CURDOT-B(R11)		; AND ADDRESS OF VALUE
	PUSHL	#4			; ARGUMENT COUNT
	MOVL	SP,R0			; SAVE POINTER TO ARG LIST
	$CMKRNL_S	W^QGET,(R0)	; Q AST FOR DATA FETCH
	BLBC	R0,50$			; BR IF FAILED
	$HIBER_S			; WAIT FOR DATA TO RETURN
50$:	ADDL	#20,SP			; CLEAN STACK
	RSB				; AND RETURN DATA
	.PAGE
	.SBTTL	QGET - QUEUE AST TO GET DATA FROM ANOTHER PROCESS
;
;	INPUTS:	04(AP) - LOCATION OF DATA
;		08(AP) - RETURN LOCATION
;		12(AP) - PID OF TARGET PROCESS
;		16(AP) - CODE SEGMENT POINTER
;
	FP_ORIGPID=ACB$L_AST
	FP_ADDR=ACB$L_ASTPRM
	FP_VALUE=ACB$L_ASTPRM
	FP_RETLOC=ACB$L_KAST+4
QGET:	.WORD	^M<R2,R3,R4,R5>		; ENTRY MASK
	MOVZWL	#SS$_NONEXPR,R0		; ASSUME BAD PIX
	CMPW	12(AP),@#SCH$GL_MAXPIX	; CHECK PIX FOR LEGAL PROCESS
	BGTR	10$			; BR IF NOT
	MOVZWL	@16(AP),R1		; GET SIZE OF CODE SEGMENT
	MOVAB	IRP$C_LENGTH(R1),R1	; ADD SIZE OF PACKET DATA
	JSB	@#EXE$ALLOCBUF		; ALLOCATE BUFFER TO CONTAIN CODE
	BLBC	R0,10$			; BRANCH IF NONE
	MOVL	R2,R5			; SAVE ADDRESS OF PACKET
	MOVL	PCB$L_PID(R4),FP_ORIGPID(R5)	; SET PID FOR RETURN
	MOVB	#^X80,ACB$B_RMOD(R5)	; SET FOR SPECIAL KERNEL AST
	MOVAB	ACB$L_KAST+8(R5),ACB$L_KAST(R5) ; SET ADDRESS FOR AST
	MOVL	4(AP),FP_ADDR(R5)	; SET ADDRESS FOR FETCH
	MOVL	8(AP),FP_RETLOC(R5)	; AND ADDRESS OF RETURN LOCATION
	MOVL	16(AP),R0		; GET ADDRESS OF CODE SEGMENT
	MOVL	12(AP),ACB$L_PID(R5)	; SET TARGET PID
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; SAVE REGS FOR MOVC
	MOVC3	(R0)+,(R0),ACB$L_KAST+8(R5); COPY CODE SEGMENT TO BUFFER
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; RESTORE REGISTERS
	MOVZBL	#PRI$_TICOM,R2		; SET PRIORITY INCREMENT CLASS
	JSB	@#SCH$QAST		; QUEUE AST FOR TARGET
10$:	RET				; RETURN TO ORIGINAL MODE

	.SBTTL	FPBYTE - FETCH BYTE FROM PROCESS
FPBYTE:	.WORD	90$-.-2			; SIZE OF CODE SEGMENT
	IFNORD	#1,@FP_ADDR(R5),10$	; BRANCH IF NOT READABLE
	MOVB	@FP_ADDR(R5),FP_VALUE(R5) ; GET VALUE
10$:	MOVL	FP_ORIGPID(R5),ACB$L_PID(R5) ; SET PID FOR RETURN AST
	MOVB	#^X80,ACB$B_RMOD(R5)	; SET FOR KAST AGAIN
	MOVAB	B^20$,ACB$L_KAST(R5)	; SET NEW AST ADDRESS
	MOVZBL	#PRI$_TICOM,R2		; SET PRIORITY INCREMENT CLASS
	JMP	@#SCH$QAST		; QUEUE RETURN AST
20$:	IFNOWRT	#1,@FP_RETLOC(R5),30$	; IF NOT WRITABLE THEN SKIP IT
	MOVB	FP_VALUE(R5),@FP_RETLOC(R5)	; RETURN VALUE
30$:	MOVL	ACB$L_PID(R5),R1	; GET PID FOR WAKE
	SETIPL	#IPL$_SYNCH		; RAISE TO SYNCH
	JSB	@#SCH$WAKE		; WAKE PROCESS
	SETIPL	#IPL$_ASTDEL		; LOWER IPL
	MOVL	R5,R0			; SET ADDRESS FOR RELEASE
	JMP	@#EXE$DEANONPAGED	; FREE BLOCK AND EXIT
90$:					; END OF CODE SEGMENT

	.PAGE
	.SBTTL	DPBYTE - DEPOSIT BYTE TO PROCESS
DPBYTE:	.WORD	90$-.-2			; SIZE OF CODE SEGMENT
20$:	IFNOWRT	#1,@FP_RETLOC(R5),30$	; IF NOT WRITABLE THEN SKIP IT
	MOVB	FP_VALUE(R5),@FP_RETLOC(R5)	; RETURN VALUE
30$:	MOVL	R5,R0			; SET ADDRESS FOR RELEASE
	JMP	@#EXE$DEANONPAGED	; FREE BLOCK AND EXIT
90$:					; END OF CODE SEGMENT

	.PAGE
	.SBTTL	FPWORD - FETCH WORD FROM PROCESS
FPWORD:	.WORD	90$-.-2			; SIZE OF CODE SEGMENT
	IFNORD	#2,@FP_ADDR(R5),10$	; BRANCH IF NOT READABLE
	MOVW	@FP_ADDR(R5),FP_VALUE(R5) ; GET VALUE
10$:	MOVL	FP_ORIGPID(R5),ACB$L_PID(R5) ; SET PID FOR RETURN AST
	MOVB	#^X80,ACB$B_RMOD(R5)	; SET FOR KAST AGAIN
	MOVAB	B^20$,ACB$L_KAST(R5)	; SET FOR NEW AST ADDRESS
	MOVZBL	#PRI$_TICOM,R2		; SET PRIORITY INCREMENT CLASS
	JMP	@#SCH$QAST		; QUEUE RETURN AST
20$:	IFNOWRT	#2,@FP_RETLOC(R5),30$	; IF NOT WRITABLE THEN SKIP IT
	MOVW	FP_VALUE(R5),@FP_RETLOC(R5)	; RETURN VALUE
30$:	MOVL	ACB$L_PID(R5),R1	; GET PID FOR WAKE
	SETIPL	#IPL$_SYNCH		; RAISE TO SYNCH
	JSB	@#SCH$WAKE		; WAKE PROCESS
	SETIPL	#IPL$_ASTDEL		; LOWER IPL
	MOVL	R5,R0			; SET ADDRESS FOR RELEASE
	JMP	@#EXE$DEANONPAGED	; FREE BLOCK AND EXIT
90$:					; END OF CODE SEGMENT

	.PAGE
	.SBTTL	DPWORD - DEPOSIT WORD TO PROCESS
DPWORD:	.WORD	90$-.-2			; SIZE OF CODE SEGMENT
20$:	IFNOWRT	#2,@FP_RETLOC(R5),30$	; IF NOT WRITABLE THEN SKIP IT
	MOVW	FP_VALUE(R5),@FP_RETLOC(R5)	; RETURN VALUE
30$:	MOVL	R5,R0			; SET ADDRESS FOR RELEASE
	JMP	@#EXE$DEANONPAGED	; FREE BLOCK AND EXIT
90$:					; END OF CODE SEGMENT

	.PAGE
	.SBTTL	FPLONG - FETCH LONG FROM PROCESS
FPLONG:	.WORD	90$-.-2			; SIZE OF CODE SEGMENT
	IFNORD	#4,@FP_ADDR(R5),10$	; BRANCH IF NOT READABLE
	MOVL	@FP_ADDR(R5),FP_VALUE(R5) ; GET VALUE
10$:	MOVL	FP_ORIGPID(R5),ACB$L_PID(R5) ; SET PID FOR RETURN AST
	MOVB	#^X80,ACB$B_RMOD(R5)	; SET FOR KAST AGAIN
	MOVAB	B^20$,ACB$L_KAST(R5)	; SET NEW KAST ADDRESS
	CLRL	R2			; NULL PRIO INCR
	JMP	@#SCH$QAST		; QUEUE RETURN AST
20$:	IFNOWRT	#4,@FP_RETLOC(R5),30$	; IF NOT WRITABLE THEN SKIP IT
	MOVL	FP_VALUE(R5),@FP_RETLOC(R5)	; RETURN VALUE
30$:	MOVL	ACB$L_PID(R5),R1	; GET PID FOR WAKE
	SETIPL	#IPL$_SYNCH		; RAISE TO SYNCH
	JSB	@#SCH$WAKE		; WAKE PROCESS
	SETIPL	#IPL$_ASTDEL		; LOWER IPL
	MOVL	R5,R0			; SET ADDRESS FOR RELEASE	
	JMP	@#EXE$DEANONPAGED	; FREE BLOCK AND EXIT
90$:					; END OF CODE SEGMENT

	.PAGE
	.SBTTL	DPLONG - DEPOSIT LONGWORD TO PROCESS
DPLONG:	.WORD	90$-.-2			; SIZE OF CODE SEGMENT
20$:	IFNOWRT	#4,@FP_RETLOC(R5),30$	; IF NOT WRITABLE THEN SKIP IT
	MOVL	FP_VALUE(R5),@FP_RETLOC(R5)	; RETURN VALUE
30$:	MOVL	R5,R0			; SET ADDRESS FOR RELEASE
	JMP	@#EXE$DEANONPAGED	; FREE BLOCK AND EXIT
90$:					; END OF CODE SEGMENT
DELEND:					; 
	.ENDC				;
