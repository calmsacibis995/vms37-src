	.TITLE	MPMCHECK - MACHINE CHECK EXCEPTION HANDLER FOR MP SECONDARY
	.IDENT	'V03-001'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:	EXECUTIVE, ERROR HANDLING
;
; ABSTRACT: IN A NUTSHELL, LOG IT AND TRY TO RECOVER.
;
; ENVIRONMENT:	RUNS ON INTERRUPT STACK AT IPL 31 UNTIL ERROR TYPE IS KNOWN
;;		AND (IF POSSIBLE) CORRECTED, THEN RUNS AT SYNCH LEVEL
;		TO DO THE ERROR LOGGING.

;--
	.SBTTL	HISTORY			; DETAILED
;
; AUTHOR:  KATHLEEN D. MORSE	, CREATION DATE:  24-JUN-1981
;
; MODIFIED BY:
;
;	V03-001	KDM0080		Kathleen D. Morse	31-Mar-1982
;		Assembly switch the debug and performance measurement
;		code.
;
;	V02-004	KDM0025		Kathleen D. Morse	23-Jul-1981
;		Fix cache parity path literal.
;
;	V02-003	KDM0021		Kathleen D. Morse	21-Jul-1981
;		Change macro for secondary bugchecks to SECBUG_CHECK.
;
;	V02-002	KDM0019		Kathleen D. Morse	20-Jul-1981
;		Add new code to fold up a process and hand back to
;		primary to run in EXCEPTION.
;

	.SBTTL	SYMBOL DEFINITIONS


CH_THRESHOLD	=	10.		;3 ERRORS IN 100 MS TO DISABLE CACHE
CH_MISSG0	=	^X10000		;"FORCE MISS GROUP 0" BIT
CH_MISSG1	=	^X8000		;"FORCE MISS GROUP 1" BIT
CH_REPLG0	=	^X4000		;"FORCE REPLACE GROUP 0" BIT
CH_REPLG1	=	^X2000		;"FORCE REPLACE GROUP 1" BIT
CH$V_G0ERRS	=	3		;START OF GROUP 0 ERRORS IN PARITY REG
CH$S_G0ERRS	=	7		;LENGTH OF GROUP 0 ERROR BITS
CHLOG_DISAB0	=	1		;LOG BIT SAYING WE DISABLED GROUP 0
CHLOG_DISAB1	=	2		;LOG BIT SAYING WE DISABLED GROUP 1


SBIFS$V_NEF	=	25		;NESTED ERROR FLAG IN SBI FAULT/STATUS

;THE FOLLOWING 5 DEFINITIONS ARE IN THE SBI ERROR REGISTER
SBIER$M_IBTO	=	^X40		;IB TIMEOUT LATCH
SBIER$M_IBRDS	=	^X80		;IB RDS LATCH
SBIER$M_CPTO	=	^X1000		;CP TIMEOUT LATCH
SBIER$M_RDS	=	^X2000		;RDS LATCH
SBIER$M_CRD	=	^X4000		;CRD LATCH

;
;	MACHINE CHECK HARDWARE LOG OFFSETS
;
MCL_COUNT	=	0		;BYTE LENGTH OF AREA (28 HEX)
MCL_SUMMARY	=	4		;SUMMARY WORD - BYTE 0=CODE, BYTE 1=
					;TIMEOUT PENDING FLAG
MCL_CES		=	8		;CPU ERROR STATUS
MCL_UPC		=	12.		;MICRO-PC AT FAULT TIME
MCL_VA		=	16.		;VIRTUAL ADDR AT FAULT TIME
MCL_D		=	20.		;CPU D REGISTER AT FAULT TIME
MCL_TBER0	=	24.		;TRANSLATION BUFFER STATUS REG 0
MCL_TBER1	=	28.		;TBUF STATUS REG 1
MCL_TIMOADDR	=	32.		;PHYSICAL ADDRESS CAUSING SBI TIMEOUT
MCL_PARITY	=	36.		;CACHE STATUS REGISTER
MCL_SBIERR	=	40.		;SBI ERROR REGISTER
MCL_PC		=	44.		;PC OF INSTRUCTION WHICH CAUSED CHECK
MCL_PSL		=	48.		;PSL OF MACHINE AT FAULT TIME
	.PAGE
;MEMORY CONTROLLOR AND ERROR DEFINITIONS

MRC$V_ELSRF	=	28		;ERROR LOG SERVICE REQUEST
MRC$M_ELSRF	=	^X10000000	;WRITE 1 TO CLEAR FLAG
MRC$V_HERIMF	=	29		;HIGH ERROR RATE IN MEMORY
MRC$M_HERIMF	=	^X20000000	;WRITE 1 TO CLEAR FLAG
MRC$V_INHBCRD	=	30		;1 DISABLES CRD INTERRUPT
MRC$M_INHBCRD	=	^X40000000	;0 CRD INTERRUPT ENABLE, 1 CRD DISABLE
MRC$V_INVMAPPTY	=	31		;INVALID MAP PARITY ERROR
MRC$M_INVMAPPTY	=	^X80000000	;WRITE 1 TO CLEAR THE FLAG

REENABTIME	= 60*15			;REENABLE INTERRUPT ERROR LOGGING
					;EVERY 15 MINUTES
SOMETIME	= 60			;SCAN FOR NON-INTERRUPT ERRORS
					;EVERY 60 SECONDS
CRDINTMAX	= 3			;MAXIMUM NUMBER OF INTERRUPTS A CONT
					;IS ALLOWED WITHIN REENABTIME
CRDWATCHMAX	= 6			;MAXIMUM NUMBER OF ERRORS TO BE LOGGED
					;WITHIN REENABTIME
; 
;	INCLUDED SYMBOL DEFINITIONS
;
	$EMBDEF	<MC,SB,SE>		;DEFINE EMB OFFSETS
	$IPLDEF				;DEFINE INTERRUPT PRIORITY LEVELS
	$MCHKDEF			;DEFINE RECOVERY BLOCK MASK BITS
	$PRDEF				;DEFINE PROCESSOR REGISTER NUMBERS
	$PSLDEF				;DEFINE PSL

;
; Macros
;
;
;	LOCAL DATA STORAGE
; 
	.PSECT	$$$$MPDATA,QUAD,WRT
MPS$GL_CSBITA::	.LONG	0		;USED TO HOLD COMPLEMENT OF SBITA
MPS$GL_CH1OLD::	.LONG	0		;TIME OF LAST CACHE ERROR
MPS$GL_CH2OLD::	.LONG	0		;TIME OF NEXT-TO-LAST CACHE ERROR
MPS$GL_CPTIMOUT::.LONG	0		;TIME OF LAST CP TIMEOUT/SBI ERROR
MPS$AB_MEMERR::	.BLKB	16		;ERROR COUNTERS FOR 16 ADAPTERS
MPS$GW_REENAB::	.WORD	0		;REENABLE TIMER
MPS$GW_WATCH::	.WORD	0		;SCAN MEMORY CONTROLLER TIMER
MPS$GL_CRDCNT::	.LONG	0		;COUNT OF CORRECTED MEMORY ERRORS
MPS$GL_CHSTATE::.LONG	^X200200	;CURRENT STATE OF CACHE
MPS$GL_BADTIMOUT::			;TIME SINCE LAST BAD MCHK CODE
		.LONG	0
 
	.PAGE
	.PSECT	WIONONPAGED,QUAD,RD,WRT
;
; MACHINE CHECK ENTRY POINT - SCB VECTOR POINTS HERE.
;	IPL ^X1F = 31
;
	.ALIGN	LONG			;A VECTOR MUST HAVE LONGWORD ALIGNMENT
MPS$MCHK::
	MTPR	#<CH_MISSG0!CH_MISSG1!CH_REPLG0>,#PR$_SBIMT
					;DISABLE CACHE COMPLETELY
	PUSHL	#MCHK$M_LOG		;MASK WORD FOR PRTCTEST
	PUSHAL	MCL_PC+4(SP)		;PC,PSL POINTER FOR PRTCTEST
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,AP>
	ADDL3	#<9*4>,SP,AP		;POINT AP TO LOG FRAME ON STACK
					;ALL INTERRUPTS ARE LOCKED OUT!
	BICB3	#^XF0,MCL_SUMMARY(AP),-(SP) ;GET LOW 4 BITS OF TYPE CODE
	CASE	(SP)+,<-		;BREAKOUT TYPE CODE
		CPTIMEOUT,-		;CPU TIMEOUT/SBI ERROR CONFIRMATION
		CSPARITY,-		;CONTROL STORE PARITY ERROR
		TBUFPARITY,-		;TRANSLATION BUFFER PARITY ERROR
		CACHEPARITY,-		;CACHE PARITY ERROR
		BADTYPE,-		;THIS CODE DOESN'T EXIST
		READSUBST,-		;READ DATA SUBSTITUTE (MEM READ ERROR)
		IBROMCHECK,-		;"CAN'T GET HERE" ERROR FROM INST ROMS
		BADTYPE,-
		BADTYPE,-
		BADTYPE,-	
		TBUFPARITY,-		;IB-DETECTED TBUF ERROR
		BADTYPE,-
		READSUBST,-		;IB-DETECTED MEMORY ERROR
		CPTIMEOUT,-		;IB-DETECTED TIMEOUT OR SBI ERROR CONF
		BADTYPE,-
		CACHEPARITY>, TYPE=B	;IB-DETECTED CACHE PROBLEM

BADTYPE:
	MTPR	W^MPS$GL_CHSTATE,#PR$_SBIMT ;RE-ENABLE THE CACHE
	BISL	#MCHK$M_MCK,-4(AP)	;MASK FOR PRTCTEST
	PUSHL	W^MPS$GL_BADTIMOUT	;TIME OF LAST BAD TYPE FAULT
	.LIST ME
	MFPR	#PR$_TODR,W^MPS$GL_BADTIMOUT ;TIME OF CURRENT FAULT
	.NLIST ME
	CMPL	(SP)+,W^MPS$GL_BADTIMOUT ;COMING TOO FAST?
	BNEQ	DAMPUTATE		;YES, ABORT
100$:
	POPR	#^M<R0,R1,R2,R3,R4,R5,AP>
	SECBUG_CHECK MPBADMCK,FATAL	;BAD MACHINE CHECK CODE
	.PAGE
	.SBTTL	TRANSLATION BUFFER PARITY ERRORS

TBUFPARITY:
	MTPR	W^MPS$GL_CHSTATE,#PR$_SBIMT	;RE-ENABLE CACHE
	MTPR	#0,#PR$_TBIA		;CLEAR ENTIRE TBUF
	BISL	#MCHK$M_MCK,-4(AP)	;SET MACHINE CHECK CODE FOR PRTCTEST


TRYRESUME:
	BITW	#^X1F0,MCL_SUMMARY(AP)	;IS ERROR ABORT OR TIMEOUT PENDING
DAMPUTATE:
	BNEQ	AMPUTATE		;BRANCH IF YES, NO HOPE OF RESUMING
	BITB	#8,MCL_SUMMARY(AP)	;SEE IF ERROR WAS IB ERROR
	BNEQ	10$			;IF SO, WE CAN "DEFINITELY" RESUME
	MOVZBL	@MCL_PC(AP),-(SP)	;GET OPCODE FOR RESTARTABILITY CHECK
	BBC	(SP)+,W^RESUMABLE,AMPUTATE ;BRANCH IF INST NOT RESUMABLE,ABORT
10$:	;THERE IS A LOW PROBABILITY CASE HERE THAT MAY ALLOW THIS CODE TO
	;CONTINUE WHEN WE CAN'T - IF A LOCATION IS READ FROM THE IO PAGE AND
	;HAS A SIDE AFFECT WHICH MODIFIES THAT LOCATION, THE INSTRUCTION IS
	;NOT RETRYABLE, A SOFTWARE SOLUTION IS TO IMPLEMENT A FLAG SET BY ANY
	;POTENTIAL REFERENCE TO THE IO PAGE THAT MAY CAUSE A SIDE AFFECT.
	;BBS	#IOSAFLAG,FLAG,AMPUTATE	;BRANCH IF INST MAY OF HAD SIDE AFFECT
RESUME:
	MOVW	#EMB$K_MC,R3		;SET TYPE OF LOG ENTRY
	BSBB	LOGGER			;WE'RE GOING TO MAKE IT - LOG ERROR
	POPR	#^M<R0,R1,R2,R3,R4,R5,AP>	;RESTORE REGISTERS
	ADDL	#8,SP			;REMOVE PRTCTEST STUFF FROM STACK
	ADDL	(SP)+,SP		;POP HARDWARE LOG FROM STACK
	REI				;AND TRY AGAIN
	.PAGE
	.SBTTL	INTERFACE FROM MACHINE CHECK HANDLER TO ERROR LOGGER
;++
; LOGGER - Routine to log Machine Check interrupts and aborts
;
; INPUTS:
;
;	R3 - Error log type
;	AP - Pointer to Machine Check error log frame
;	-4(AP) - MASK FOR PRTCTEST
;	-8(AP) - PC,PSL POINTER FOR PRTCTEST
;
; OUTPUTS:
;
;	Entry made in error log conditional on PRTCTEST
;	R0-R5 destroyed
;--
 
LOGGER:
	ADDL3	MCL_COUNT(AP),#<2*4>,R4	;GET SIZE OF ENTRY IN BYTES
	MOVAB	MCL_SUMMARY(AP),R5	;GET ADDRESS OF ENTRY
	MOVQ	-8(AP),R1		;GET MASK AND PC POINTER FOR PRTCTEST
					;FALL THROUGH TO "LOGIT"
 
;++
; LOGIT - INTERFACE TO SYSTEM ERROR LOG
;
; INPUTS:
;
;	R1 = PC,PSL POINTER FOR PRTCTEST
;	R2 = MASK FOR PRTCTEST
;	R3 = ERROR LOG TYPE
;	R4 = SIZE OF LOG ENTRY IN BYTES
;	R5 = ADDRESS OF LOG ENTRY
;	(SP) = RETURN ADDRESS
;--
	.ENABL	LSB

LOGIT:
	MFPR	#PR$_SBIFS,R0		;GET SBI FAULT/STATUS REGISTER
	BBCC	#SBIFS$V_NEF,R0,10$	;CLEAR NESTED ERROR FLAG
10$:	MTPR	R0,#PR$_SBIFS		;WRITE IT BACK TO CLEAR SILO LOCK
					;AND FAULT LATCH
	MFPR	#PR$_SBIER,R0		;GET SBI ERROR REGISTER
	BISW	#SBIER$M_IBTO!SBIER$M_IBRDS!SBIER$M_CPTO!SBIER$M_RDS!-
		SBIER$M_CRD,R0		;SET BITS FOR ERRORS WE'RE HANDLING
	MTPR	R0,#PR$_SBIER		;WRITE IT BACK TO CLEAR LATCHES
	 
 
MCHK$GL_LOG::
 
	ADDL3	#EMB$B_MC_SUMCOD,R4,R1	;ADD SPACE FOR HEADER FOR BUFFER SIZE
	JSB	G^MPS$ALLOCEMB		;GET AN ERROR LOGGING BUFFER
	BLBC	R0,20$			;BRANCH IF DIDN'T GET IT
	PUSHL	R2			;SAVE ADDRESS OF ERROR LOG BUFFER
	MOVW	R3,EMB$W_MC_ENTRY(R2)	;SET ENTRY TYPE TO FAULT TYPE
	MOVC3	R4,(R5),EMB$B_MC_SUMCOD(R2) ;IN ONE SWELL FOOP.....
	MOVL	(SP)+,R2		;GET POINTER TO BUFFER START IN R2
	JSB	G^MPS$RELEASEMB		;INDICATE BUFFER READY TO LOG
20$:	RSB				;EXIT WITH HARDWARE LOG STILL ON STACK
 
	.DSABL	LSB
	.PAGE
	.SBTTL	ERRORS DETECTED IN INSTRUCTION DECODE ROMS
	.SBTTL	CONTROL STORE PARITY ERRORS

IBROMCHECK:
CSPARITY:
	MTPR	W^MPS$GL_CHSTATE,#PR$_SBIMT	;CACHE PROBABLY OK - ENABLE IT
	MOVB	@MCL_PC(AP),MCL_SUMMARY+2(AP) ;SAVE OPCODE IN LOG
	BISL	#MCHK$M_MCK,-4(AP)	;SET MASK CODE FOR PRTCTEST
AMPUTATE:
	MOVW	#EMB$K_MC,R3		;SET TYPE OF LOG ENTRY
	BSBB	LOGGER			;LOG THE ERROR
	BBS	#PSL$V_CURMOD+1,MCL_PSL(AP),REFLECTCHK ;BRANCH IF
					;FAILURE IN USER OR SUPERVISOR MODE
 
	POPR	#^M<R0,R1,R2,R3,R4,R5,AP> ;RESTORE REGS
 
	SECBUG_CHECK MPMCHECK,FATAL	;MACHINE CHECK IN KERNEL OR EXEC MODE

;
; THIS CODE FOLDS UP A PROCESS AND HANDS IT BACK TO THE PRIMARY,
; FORCING IT TO EXECUTE IN THE EXCEPTION HANDLER.  THIS IS DONE BY
; REMOVING ALL TRACES OF THE INTERRUPT FROM THE SECONDARY'S INTERRUPT
; STACK, AND PLACING THE APPROPRIATE PC AND PSL PAIRS ON THE PROCESS'S
; KERNEL STACK.  THEN A NORMAL RESCHEDULE REQUEST IS MADE BY THE SECONDARY.
;
REFLECTCHK:
	MFPR	#PR$_KSP,R0		;GET THE KERNEL MODE STACK POINTER
	MOVQ	MCL_PC(AP),-(R0)	;INTERRUPT PC,PSL TO KERNEL STACK
					;IT IS NOT NECCESARY TO PROBE KERNEL
					;STACK FOR VALIDITY, THE FAILURE WILL
					;BE A KERNEL STACK NOT VALID BUGCHECK
					;FROM WITHIN MACHINE CHECK
	MTPR	R0,#PR$_KSP		;REPLACE THE NEW KERNEL STACK POINTER
	POPR	#^M<R0,R1,R2,R3,R4,R5,AP> ;RESTORE REGISTERS
	ADDL	#8,SP			;CLEAN PRTCTST STUFF OFF INTERRUPT STACK
	ADDL	(SP)+,SP		;POP HARDWARE LOG FROM INTERRUPT STACK
	EXTZV	#PSL$V_CURMOD,#PSL$S_CURMOD,4(SP),4(SP) ;PUT PC/PSL PAIR
					;ON INTRPT STACK TO EXECUTE IN EXCEPTION
	ROTL	#PSL$V_PRVMOD,4(SP),4(SP) ;CREATE A PSL WITH CURRENT MODE OF
					;KERNEL AND CORRECT PREVIOUS MODE
					;AS FROM A FAULT, 0'S IN REST OF PSL
	MOVAB	G^EXE$MCHECK,(SP)	;THE PC IS IN THE EXCEPTION HANDLER
	SETIPL	#IPL$_SYNCH		;LOWER IPL, ENABLING INTER-PROC INTRPT

	.IF	DF,MPPFMSWT
	BSBW	MPS$PFM_MCHK		;GATHER PERFORMANCE MEASUREMENT DATA
	.ENDC

	BRW	W^MPS$MPSCHED2		;RETURN PROCESS TO PRIMARY TO EXECUTE
	.SBTTL	SBI ERROR INTERRUPTS
;++
; Handle SBI error interrupts here: SBI Faults and Asynchronous Write
; Timeouts on the SBI.
;
; SBI Fault:
;	Log the error.
;	Try to resume normal execution.
;
; Asynchronous Write Timeouts:
;	Log the error.
;	Set up a "fake" machine check log on the stack.  This is so we
;	can share the exception exit path (REFLECTCHK) that machine checks
;	take if the current process is executing in USER or SUPER mode.
;	If the current process is in EXEC or KERNEL mode, bugcheck.
;--
	.ENABL	LSB

	.ALIGN	LONG			;THIS IS VECTORED TO
MPS$INT5C::				;SBI FAULT VECTOR
MPS$LOGSBF::
	SETIPL	#^X1F			;DISABLE ALL INTERRUPTS
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,R7>	;SAVE SOME WORK REGS
	MOVZBL	#EMB$K_BE,R3		;ERROR LOG TYPE
	MOVL	#MCHK$M_MCK!MCHK$M_LOG,R2 ;MASK FOR PRTCTEST
	BSBB	LOGSBI			;USE SAME CODE AS ASYNC WRITE FAILURE
	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,R7>	;RESTORE R0-R7
	REI				;TRY TO CONTINUE

	.ALIGN	LONG			;THIS IS VECTORED TO
MPS$INT60::				;ASYNCHRONOUS WRITE TIMEOUT
MPS$LOGAWE::
	SETIPL	#^X1F			;DISABLE ALL INTERRUPTS
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,R7>	;SAVE SOME WORK REGS
	MOVZBL	#EMB$K_AW,R3		;ERROR LOG TYPE
	MOVL	#MCHK$M_LOG!MCHK$M_MCK!MCHK$M_NEXM,R2 ;PRTCTEST MASK
	BSBB	LOGSBI			;USE SAME CODE AS SBI FAULT ERROR
	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,R7>	;RESTORE R0-R7
	SUBL	#40,SP			;ALLOCATE FAKE MACHINE CHECK FRAME
	PUSHL	#40			;SIZE OF FRAME
	PUSHL	#MCHK$M_MCK!MCHK$M_LOG!MCHK$M_NEXM
	PUSHAL	MCL_PC+4(SP)		;MASK AND PC,PSL FOR PRTCTEST
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,AP> ;SAVE REGISTERS FOR COMMON CODE
	ADDL3	#<9*4>,SP,AP		;POINT AP TO FAKE MACHINE CHECK FRAME
	BITB	#^B10100000,W^MPS$GL_CSBITA+3 ;WAS WRITE IN USER OR SUPERVISOR
					;MODE AND NOT UPDATING A PAGE TABLE
	BEQL	REFLECTCHK		;BRANCH IF OK TO CONTINUE
 
	POPR	#^M<R0,R1,R2,R3,R4,R5,AP>
	SECBUG_CHECK MPASYNCWRT,FATAL	;WRITE ERROR IN KERNAL OR EXEC MODE
					;OR WHILE UPDATING PAGE TABLE
 
	.PAGE
;++
; LOGSBI -- Subroutine to log SBI errors.
;
; Create an SBI error log buffer that contains:
;	A copy of the VA of every SBI adapter on the bus.
;	A copy of the SBI silo.
;	SBI processor registers SBIER,SBIMT,SBISC, and SBIFS.
;--
LOGSBI:	MOVQ	<9*4>(SP),-(SP)		;MAKE A SECOND COPY OF PC,PSL
	MOVL	G^EXE$GL_CONFREG,R7	;ARRAY OF NEXUS DEVICE TYPE CODES
	MOVL	G^MMG$GL_SBICONF,R5	;ARRAY OF ADAPTER VA'S
	MOVL	#15,R0			;INDEX OF LAST POSSIBLE ITEM ON SBI
10$:	MOVL	(R5)[R0],R1		;GET VA OF CONTROLLER/ADAPTER
	CLRL	-(SP)			;ASSUME NO ADAPTOR HERE
	TSTB	(R7)[R0]		;TEST ADAPTER TYPE
	BEQL	20$			;IF EQL, NO ADAPTOR HERE
	MOVL	(R1),(SP)		;STORE ADAPTOR CSR0 ON STACK
20$:	SOBGEQ	R0,10$			;LOOP THRU ALL POSSIBLE 16
	MOVL	#15,R0			;SET UP COUNT OF NUMBER OF TIMES TO
					;READ SILO
30$:	MFPR	#PR$_SBIS,-(SP)		;SAVE INFORMATION FOR ERROR LOGGER
	SOBGEQ	R0,30$			;LOOP THRU ALL 16
	MFPR	#PR$_SBITA,-(SP)	;SAVE SBI TIMEOUT REGISTER
	MCOML	(SP),W^MPS$GL_CSBITA	;SAVE COMPLEMENT SBITA FOR LATER CHECK
	MFPR	#PR$_SBIER,-(SP)	;SAVE SBI ERROR REGISTER
	MFPR	#PR$_SBIMT,-(SP)	;SAVE SBI MAINTENANCE REGISTER
	MFPR	#PR$_SBISC,-(SP)	;SAVE SBI SILO COMPARATOR
	MFPR	#PR$_SBIFS,-(SP)	;SAVE SBI FAULT/STATUS REGISTER
	MOVZWL	#<16*4>+<16*4>+<7*4>,-(SP) ;SAVE NUMBER OF BYTES OF ENTRY
 
	MOVAL	<<16*4>+<16*4>+<6*4>>(SP),R1 ;ADDRESS OF PC,PSL FOR PRTCTEST
	MOVL	(SP),R4			;# OF BYTES TO LOG
	MOVAB	4(SP),R5		;ADDRESS OF LOG ENTRY
	BSBW	LOGIT			;CALL ERROR LOGGER
	ADDL	(SP)+,SP		;CLEAN STACK OF LOG AND FAKE PC,PSL
	RSB				;RETURN

	.DSABL	LSB
	.PAGE
	.ENABL	LSB

	.ALIGN	LONG			;THIS IS VECTORED TO
MPS$INT58::				;SBI ALERT
MPS$LOGSBA::
	SETIPL	#^X1F			;DISABLE ALL INTERRUPTS
	BSBB	LOGMEM			;USE SAME CODE AS ECC ERRORS
					;THIS WILL CAUSE ALERTS TO GO THRU THE
					;CRD CODE, THIS SHOULD BE HARMLESS
	.BYTE	EMB$K_SA		;THIS IS AN SBI ALERT INTERRUPT
	REI				;TRY TO CONTINUE

LOGMEM:	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9> ;SAVE SOME WORK REGS
	MOVZBW	@<10*4>(SP),R3		;GET FAILURE TYPE
	MOVQ	<11*4>(SP),-(SP)		;MAKE A SECOND COPY OF PC AND PSL
	CLRQ	R4			;CNT OF MEM CONTROLERS & REG PUSHED
	MOVL	#15,R8			;INDEX OF LAST POSSIBLE ITEM ON SBI
10$:
	MOVL	G^EXE$GL_CONFREG,R2	;ADDR OF ARRAY OF NEXUS DEVICE TYPES
	MOVZBL	(R2)[R8],R2		;GET ADAPTER TYPE
	BEQL	130$			;BRANCH IF NO ADAPTOR HERE
	MOVL	G^MMG$GL_SBICONF,R1	;ADDR OF ARRAY OF ADAPTER VA'S
	MOVL	(R1)[R8],R1		;GET CONTROLLER/ADAPTER VA
	CLRL	R6			;SET INDICATOR TO LOCAL MEM TYPE
	BITB	#^B11100000,R2		;IS THIS A MEMORY?
	BEQL	15$			;BRANCH IF A MEMORY, (BITS 5-7 ARE 0)
	CMPB	R2,#^X40		;IS THIS A MULTIPORT MEMORY? (MA780)
	BLSSU	130$			;BR IF NOT MEM, LESS THAN RANGE (40-43)
	CMPB	R2,#^X43		;IS THIS A MULTIPORT MEMORY? (MA780)
	BGTRU	130$			;BR IF NOT MA780, GREATER THAN RANGE
	MOVL	SP,R9
	SUBL	#<7*4>,SP
	MOVL	(R1)+,R2		;GET REAL CSR
	MOVZBL	#6,R6			;LARGEST INDEX TO REGISTERS
13$:	MOVL	(R1)[R6],-(R9)		;PUSH REGISTERS IN REVERSE ORDER
	SOBGEQ	R6,13$			;PUSH 8 REGISTERS FOR ERROR LOG
					;R6=-1, INDICATING WAS MA780 MEMORY
;
; NOW CLEAR THE ERROR BITS IN THE MA780 REGISTERS.  THE BITS CLEARED IN THE
; PORT INTERFACE CONTROL REGISTER ARE:  BDI PTY FLT INPUT (31), BDI PTY FLT
; OUTPUT (30), IVDT LOST ON BDI (29), RAM PAR ERR (28), IVDT ACK NOT REC (27),
; RAM OV (26), MRK REQ (25), AND MRK TMO (24).  THE BITS CLEARED IN THE PORT
; CONTROLLER STATUS REGISTER ARE:  ADMI CMD ABORT (31), MLT XMT FLT (30),
; ADMI GRNT PAR ERR (28), INTLK TMO (15), AND IVDT DATA LOST IN MPC (14).
;
	BISL	#^XFF000000,(R1)	;CLR ERR BITS IN PORT INTERFACE CTL REG
	BISL	#^XD000C000,4(R1)	;CLR ERR BITS IN PORT CTLR STATUS REG
	BLBS	R0,114$			;BRANCH IF MA780 STILL AROUND
	ADDL	#<7*4>,SP		;NOTHING TO LOG IF NO MA780
130$:	BRB	30$			;CONTINUE
114$:
	ADDL2	#<9*4>,R5		;ADD # OF BYTES IN LOG FOR THIS MEM
	BRB	17$			;JOIN COMMON CODE FOR ALL MEMORIES
100$:	BRB	10$			;INTERMEDIATE FOR OUT OF RANGE BRANCH
15$:	MOVL	(R1)+,R2		;GET REAL MEMORY CONTROLLER A
	PUSHL	4(R1)			;SAVE MEMORY CONT REGISTER C
	PUSHL	(R1)			;SAVE MEMORY CONT REGISTER B
	ADDL2	#<4*4>,R5		;COUNT # OF LOG BYTES FOR THIS MEM
17$:	PUSHL	R2			;SAVE MEMORY CONT REGISTER A
	PUSHL	R8			;SAVE TR NUMBER
	INCL	R4			;COUNT NUMBER OF MEMORIES
	ROTL	#MRC$V_ELSRF,#<MRC$M_HERIMF!MRC$M_ELSRF>@<-MRC$V_ELSRF>,R2
;	MOVL	#MRC$M_HERIMF!MRC$M_ELSRF,R2 ;SET UP DEFAULT MEM REG C
	BBC	#MRC$V_ELSRF,<3*4>(SP),30$ ;BRANCH IF THIS MEM CONT NO ERROR
	INCB	W^MPS$AB_MEMERR[R8]	;ACCOUNT ANOTHER MEMORY ERROR TO CONT
	CMPB	#CRDINTMAX,W^MPS$AB_MEMERR[R8] ;IS THIS MEMORY A TROUBL SPOT
	BGTRU	19$			;BRANCH IF NOT, KEEP TAKING INTERRUPT
	BBSS	#MRC$V_INHBCRD,R2,19$	;DISABLE CRD INTERRUPT FROM CONT
19$:	BBSS	#MRC$V_INVMAPPTY,R2,20$	;CLEAR MA780 INV MAP PARITY ERROR BIT
20$:	BLBC	R6,25$			;BRANCH IF LOCAL TYPE OF MEMORY
	MOVL	R2,12(R1)		;RESET MA780 ARRAY ERROR REGISTER
	BRB	30$			;JOIN COMMON CODE
25$:	MOVL	R2,4(R1)		;RESET LOCAL TYP MEM REGISTER C
30$:	SOBGEQ	R8,100$			;LOOP THRU ALL POSSIBLE 16
	ADDL3	R5,SP,R1		;ADDRESS OF PC,PSL FOR PRTCTEST
	CLRL	R2			;ALWAYS LOG MEMORY FAILURES
	PUSHL	R4			;SAVE NUMBER OF MEMORY CONTROLLERS
	ADDL3	#<3*4>,R5,-(SP)		;SET # OF BYTES OF INFO TO LOG
	MOVL	(SP),R4			;SET R4,R5 FOR LOG ROUTINE
	MOVAL	4(SP),R5		;ADDRESS OF LOG INFO
	BSBW	LOGIT			;LOG THE ERROR
	ADDL	(SP)+,SP		;CLEAN UP THE STACK
	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9> ;RESTORE REGISTERS
	INCL	(SP)			;BUMP RETURN ADDRESS PAST CODE
	RSB				;BACK TO CALLER

	.ALIGN	LONG			;THIS IS VECTORED TO
MPS$INT54::				;CRD FAULT
MPS$LOGCRD::
	SETIPL	#^X1F			;DISABLE ALL INTERRUPTS
	INCL	G^MPS$GL_CRDCNT		;KEEP COUNT OF THE ERRORS
	BSBW	LOGMEM			;USE SAME CODE AS SBI ALERT ERRORS
	.BYTE	EMB$K_SE		;THIS IS A CORRECTABLE ECC ERROR
	REI				;CONTINUE
	.DSABL	LSB
	.PAGE
	.SBTTL	MEMORY ERROR TIMERS

MPS$REENABLE::
					;WE SHOULD BE ENTERED WITH IPL SYNCH
	DECW	W^MPS$GW_WATCH		;COUNT SECONDS DOWN
	BLEQ	1$			;BRANCH IF TIME HAS EXPIRED
	BRW	40$			;ELSE BRANCH IF SCAN TIME NOT ELAPSED
1$:
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,R7>
	MOVL	G^EXE$GL_CONFREG,R5	;ARRAY OF NEXUS DEVICE TYPE CODES
	MOVL	G^MMG$GL_SBICONF,R7	;ARRAY OF ADAPTER VA'S
	CLRL	R4			;SET UP FOR COUNT OF MEMORY CONTROLLERS
	MOVL	#15,R6			;INDEX OF LAST POSSIBL ITEM ON SBI
	DSBINT				;LOOP AT IPL 31
	MOVW	#SOMETIME,W^MPS$GW_WATCH ;RESET THE TIME INTERVAL
10$:
	MOVZBL	(R5)[R6],R2		;GET ADAPTER TYPE
	BEQL	20$			;BRANCH IF NO ADAPTOR HERE
	MOVL	(R7)[R6],R1		;GET VA OF ADAPTER/CONTROLLER
	BITB	#^B11100000,R2		;IS THIS A MEMORY?
	BEQL	15$			;BR IF LOCAL TYPE MEM, (BITS 5-7 ZERO)
	CMPB	R2,#^X40		;IS THIS A MULTIPORT MEMORY? (MA780)
	BLSSU	20$			;BR IF NOT MEM, LESS THAN RANGE (40-43)
	CMPB	R2,#^X43		;IS THIS A MULTIPORT MEMORY? (MA780)
	BGTRU	20$			;BR IF NOT MA780, GREATER THAN RANGE
	MOVL	16(R1),R1		;GET MA780 ARRAY ERROR REGISTER
	BRB	17$			;JOIN COMMON CODE FOR MEMORIES
15$:	MOVL	8(R1),R1		;GET LOCAL TYPE MEMORY CONT REG C
17$:	INCL	R4			;COUNT NUMBER OF MEMORIES
	BBC	#MRC$V_ELSRF,R1,20$	;BRANCH IF THIS MEM CONT NO ERROR
	INCL	W^MPS$GL_CRDCNT		;COUNT TOTAL CRD ERRORS IN SYSTEM
	CMPB	#CRDWATCHMAX,W^MPS$AB_MEMERR[R6] ;IS THIS MEMORY A HOT SPOT?
	BLEQU	20$			;BRANCH IF YES, WE HAVE LOGGED ENOUGH
	MOVPSL	-(SP)			;SET UP AN INTERRUPT PC,PSL
	BSBW	MPS$LOGCRD		;LOG THE ERROR AND RETURN TO HERE
	BRB	30$			;GET OUT
20$:	SOBGEQ	R6,10$			;LOOP THRU ALL POSSIBLE 16
30$:	ENBINT				;DROP BACK TO ORIGONAL IPL
	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,R7>
40$:					;WE SHOULD BE ENTERED WITH IPL SYNCH
	DECW	W^MPS$GW_REENAB		;COUNT SECONDS DOWN
	BGTR	70$			;BRANCH IF REENABLE TIME NOT ELAPSED
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>
	MOVL	G^EXE$GL_CONFREG,R3	;ARRAY OF NEXUS DEVICE TYPE CODES
	MOVL	G^MMG$GL_SBICONF,R5	;ARRAY OF ADAPTER VA'S
	MOVW	#REENABTIME,W^MPS$GW_REENAB ;RESET THE TIME INTERVAL
	CLRQ	W^MPS$AB_MEMERR		;RESET THE ERROR COUNTS TO 0
	CLRQ	W^MPS$AB_MEMERR+8	;DITO
	MOVL	#15,R4			;SET UP TO SEARCH THE TR SLOTS
50$:
	MOVZBL	(R3)[R4],R2		;GET ADAPTER TYPE
	BEQL	60$			;BRANCH IF NO ADAPTOR HERE
	MOVL	(R5)[R4],R1		;GET VA OF ADAPTER/CONTROLLER
	BITB	#^B11100000,R2		;IS THIS A MEMORY?
	BEQL	55$			;BRANCH IF IS MEM, (BITS 5-7 ZERO)
	CMPB	R2,#^X40		;IS THIS A MULTIPORT MEMORY? (MA780)
	BLSSU	60$			;BR IF NOT MEM, LESS THAN RANGE (40-43)
	CMPB	R2,#^X43		;IS THIS A MULTIPORT MEMORY? (MA780)
	BGTRU	60$			;BR IF NOT MA780, GREATER THAN RANGE
	BBC	S^#EXE$V_CRDENABL,G^EXE$GL_FLAGS,60$ ;BRANCH IF NO CRD INTS
	ROTL	#MRC$V_ELSRF,#<MRC$M_HERIMF!MRC$M_ELSRF>@<-MRC$V_ELSRF>,16(R1)
	BRB	60$			;JOIN COMMON CODE TO FIND NEXT MEMORY
55$:	BBC	S^#EXE$V_CRDENABL,G^EXE$GL_FLAGS,60$ ; BRANCH IF NO CRD INTS
	ROTL	#MRC$V_ELSRF,#<MRC$M_HERIMF!MRC$M_ELSRF>@<-MRC$V_ELSRF>,8(R1)
;	MOVL	#MRC$M_HERIMF!MRC#M_ELSRF,8(R1) ;ENABLE INT AND CLEAR FLAGS
60$:	SOBGEQ	R4,50$			;LOOP THRU THE CONFIGURATION
	POPR	#^M<R0,R1,R2,R3,R4,R5>
70$:	RSB				;RETURN TO TIMER SCHEDULER AT SYNCH
	.PAGE
	.SBTTL	CACHE PARITY ERROR

CACHEPARITY:	;ENTER WITH CACHE DISABLED REPLACING GROUP 0
	BISL	#MCHK$M_MCK,-4(AP)	;SET MACHINE CHECK TYPE FOR PRTCTEST
	TSTB	@MCL_VA(AP)	;FORCE DATA INTO GROUP 0 OF BAD CACHE LINE
	MTPR	#CH_MISSG0!CH_MISSG1!CH_REPLG1,#PR$_SBIMT
				;NOW FORCE GROUP 1 REPLACEMENT
	TSTB	@MCL_VA(AP)	;AND FORCE GROUP 1 OF BAD LINE TO GOOD DATA
	.LIST ME
	MFPR	#PR$_TODR,-(SP)		;GET TIME-OF-YEAR IN 10MS TICKS
	.NLIST ME
	SUBL3	W^MPS$GL_CH2OLD,(SP),-(SP) ;GET TIME SPAN OF LAST 2 ERRORS-NOW
	CMPL	(SP)+,#CH_THRESHOLD	;ARE THE ERRORS WIDELY SPACED
	BGTRU	20$			;BRANCH IF YES TO FORGIVE THE CACHE
	CMPZV	#CH$V_G0ERRS,#CH$S_G0ERRS,MCL_PARITY(AP),#^B1111111
					;IS GROUP 0 ALL GOOD?
	BNEQ	10$			;BRANCH IF GROUP 0 WAS BAD
	BISB	#CH_MISSG1!CH_REPLG0@-8,W^MPS$GL_CHSTATE+1 ;DISABLE GROUP 1
	BICB	#CH_REPLG1@-8,W^MPS$GL_CHSTATE+1 ;CANNOT FORCE REPLACE IN BOTH
	MOVB	#CHLOG_DISAB1,MCL_SUMMARY+3(AP) ;LOG THAT WE DID IT
	BRB	20$
10$:	BISW	#CH_MISSG0!CH_REPLG1@-8,W^MPS$GL_CHSTATE+1 ;DISABLE GROUP 0
	BICB	#CH_REPLG0@-8,W^MPS$GL_CHSTATE+1 ;DON'T FORCE REPLACE IN BOTH!
	MOVB	#CHLOG_DISAB0,MCL_SUMMARY+3(AP) ;LOG THAT WE DID IT
20$:	MOVL	W^MPS$GL_CH1OLD,W^MPS$GL_CH2OLD ;MAINTAIN THE TIMING HISTORY
	MOVL	(SP)+,W^MPS$GL_CH1OLD	;UNTO THE THIRD GENERATION
	MTPR	W^MPS$GL_CHSTATE,#PR$_SBIMT	;RE-ENABLE THE CACHE - FINALLY!
BRESUM:	BRW	TRYRESUME		;SEE IF WE CAN CONTINUE FROM THE ERROR
	.PAGE
	.SBTTL	CP TIMEOUT / SBI ERROR CONFIRMATION

CPTIMEOUT:
	MTPR	W^MPS$GL_CHSTATE,#PR$_SBIMT	;ENABLE THE CACHE
	BISL	#MCHK$M_MCK!MCHK$M_NEXM,-4(AP) ;SET TYPE FOR PRTCTEST
	PUSHL	W^MPS$GL_CPTIMOUT	;WE ONLY KEEP TRACK OF ONE TIMEOUT
	.LIST ME
	MFPR	#PR$_TODR,W^MPS$GL_CPTIMOUT ;UPDATE THAT HISTORY
	.NLIST ME
	CMPL	(SP)+,W^MPS$GL_CPTIMOUT	;ARE TIMEOUTS LESS THAN 10 MS APART?
	BNEQ	BRESUM			;BRANCH IF NOT TO TRY AND CONTINUE
	BRW	AMPUTATE		;OTHERWISE SOMETHING IS VERY WRONG

	.PAGE
	.SBTTL	READ DATA SUBSTITUTE ERROR

	.ENABL	LSB
READSUBST:
	MTPR	W^MPS$GL_CHSTATE,#PR$_SBIMT	;REENABLE CACHE
	BISL	#MCHK$M_MCK,-4(AP)	;SET MACHINE CHECK TYPE FOR PRTCTEST
	MOVQ	MCL_PC(AP),-(SP)	;MAKE COPY OF PC AND PSL
	BSBW	LOGMEM			;LOG THIS AS A MEMORY ERROR
	.BYTE	EMB$K_HE		;CODE OF HARD ECC ERROR
	ADDL	#8,SP			;REMOVE TEMP PC, PSL AND LOG AS CHECK
	BRW	AMPUTATE		;ABORT - RECOVERY IS USELESS

	.DSABL	LSB
	.PAGE
	.SBTTL	TABLE OF RESUMABLE INSTRUCTIONS.
;	EACH BIT IN THE TABLE IS A 1 IF THE INSTRUCTION IS RESUMABLE,
;	AND A 0 IF IT IS NOT.

RESUMABLE:
	.WORD	^B0011110000111011	;REI, LDPCTX, SVPCTX, INSQUE, REMQUE
					;CVTPS, CVTSP
	.WORD	^B1111111111111111
	.WORD	^B1111111100000000	;PACKED DECIMAL INSTRUCTIONS
	.WORD	^B1111111011111111	;EDITPC
	.WORD	^B1111111111111111
	.WORD	^B1111111010101111	;EMODF, CVTFD, ADAWI
	.WORD	^B0000111100000000	;DOUBLE PRECISION FLOATING POINT
	.WORD	^B1100000111001010	;MORE DOUBLE PREC/QUAD, EMUL, EDIV
	.WORD	^B1111111111111111
	.WORD	^B1111111111111111
	.WORD	^B1111111111111111
	.WORD	^B1111001111111111	;PUSHR, POPR
	.WORD	^B1111111111111111
	.WORD	^B1111010011111111	;ADWC, SBWC, MFPR
	.WORD	^B1111111100111111	;BBSSI, BBCCI
	.WORD	^B0000000011111111	;ASHP, CVTLP, CALLG, CALLS, XFC, EXPANSION
 
	.END
