MODULE CHANGE(IDENT='V03-000') =
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! Functional Description:
!
! 	This module contains the code to parse and execute change mode
!	subcommands.  The module KEYTRAN is used to get keypad commands
!	and translate them into change mode command strings.  For no-
!	keypad mode, this module does it all.
!
! Bob Kushlis, 5-SEP-1979
!
!	Major re-write.
!
! Bob Kushlis, 12-MAY-1980
!
!	Fix the GET_BUFFER routine so it no longer looks beyond the end
!	of the command line when getting the buffer name.
!
! Dan Szymanski, 29-MAY-1980
!
!	Divide SPLIT_LINE into SPL_LINE and SPLIT_LINE so that the
!	WF_END_INSERT call can be delayed until all text insertion
!	associated with a paste is complete.  This ensures that at most
!	one line number resequence will occur on a paste.
!
! Bob Kushlis, 30-MAY-1980
!
!	Make the substitute command position to the beginning of the
!	replacement string when in backup mode.
!
! Dan Szymanski, 21-JUL-80,  24
!
!	Add the DEFK change mode subcommand.
!
! Dan Szymanski, 14-NOV-80, 25
!
!	GET_BUFFER changed to accept '_' in buffer/macro names to
!	agree with line mode parsing.	
!
! Dan Szymanski, 17-NOV-80, 26
!
!	Add code and param to BEG_WORD to allow search to beginning of
!	word which does not go beyond the beginning of the current line.
!	Calls to this routine modified accordingly.  Intent is to fix a
!	bug which occurs when word-wrapping is performed and CR/LF are
!	not included in the definition of the word entity delimiters.
!
! John Sauter, 29-Dec-1981, 27
!
!	Add a check for counted CHGCSR's.  If the count is greater than 1
!	then ignore any possible search string.  Without this change, with
!	SET SEARCH END the direction can change in the middle of the scan,
!	with the result that the start position can be after the end position.
!--

BEGIN

LIBRARY 'EDT';

PSECTS

FORWARD ROUTINE
    C_MESSAGE:		NOVALUE,	! Output a message on the last line of the terminal
    C_BEEP:		NOVALUE,	! Output a message to the terminal with a warning bell
    C_E_MESSAGE:	NOVALUE,	! Erase the message line
    C_CHECK_CC,				! Check to see if a CTRL/C has been typed
    MARK_CHANGE:	NOVALUE,	! Keep track of the bounds within which the current line must be updated
    NEW_LENGTH:		NOVALUE,	! Update the length of the current line
    SEL_POS,				! Compare the select line with the current line
    SPL_LINE:		NOVALUE,	! Split a line of text at the current cursor position
    SPLIT_LINE:		NOVALUE,	! Split a line of text at the current cursor position
    INSERT_CHARS,			! Insert a string of characters at the current position
    INSERT_STRING,			! Insert a string of characters which may include carriage returns
    SAVE_POS:		NOVALUE,	! Save the current buffer position
    RE_POS:		NOVALUE,	! Restore the saved buffer position
    HLP_KEYPAD:		NOVALUE,	! Keypad mode help processor
    COMBINE_LINE:	NOVALUE,	! Combine the current line with the one immediately above it
    DO_PASTE,				! Execute the paste command
    ENT_TERM,				! Determine if the current character is an entity delimiter
    BEG_WORD,				! Move backwards to the beginning of a word
    END_WORD,				! Find the end of a word
    SENT_DELIM,				! Look for a sentence delimiter
    BEG_SENT:		NOVALUE,	! Find the beginning of a sentence
    SCH_STRING,
    ON_STRING,				! Compare the current character position with a string descriptor
    FIND_STRING,			! Search for a specific string
    UNDELETE,				! Insert the contents of an undelete buffer
    PROCESS_CHGC:	NOVALUE,	! Process the CHGC command
    SAVE_LINE:		NOVALUE,	! Save a line in the auxiliary buffer
    PROCESS_LINES:	NOVALUE,	! Process each line in a select range
    DELETE_CHARS:	NOVALUE,	! Delete part of the current line
    DELETE_LINES:	NOVALUE,	! Delete whole lines of text
    INSERT_TABS,			! Insert tabs and spaces
    DO_TADJ:		NOVALUE,	! Execute the TADJ command
    INSERT_MODE:	NOVALUE,	! Process no-keypad insertion
    DO_SUBS,				! Execute the substitute command
    SAVE_TEXT:		NOVALUE,	! Save a deleted word or line in an undelete buffer
    FIND_ENTITY,			! Search for a page or paragraph entity
    EXECUTE_VERB,			! Execute the verbs which take an entity specification
    EXECUTE_COM,			! Execute the verbs which do not take an entity specification
    PAREN_COM:		NOVALUE,	! Collect and execute a parenthesized string of commands
    GET_DIRECTION:	NOVALUE,	! Determine the current direction
    GET_COUNT,				! Look for a repeat/entity count
    GET_INSERT_STR:	NOVALUE,	! Scan over the string of characters to be inserted
    GET_SUBS_STR:	NOVALUE,	! Isolate the search and replace strings for the substitute command
    GET_QUOTE_STR:	NOVALUE,	! Scan over the search string when used as an entity
    KEY_WORD,				! Compare the command buffer contents to a table of keywords
    GET_BUFFER:		NOVALUE,	! Look for a buffer specification for the cut, paste, and append commands
    PARSE_COM,				! Parse and execute a change mode command string
    C_EOL,				! Determine if we are currently at the end of a line
    C_E_INPUT,				! Try to optimize terminal input
    C_INIT:		NOVALUE,	! Initialization on entering change mode
    C_MODE:		NOVALUE;	! Driver for change mode processing

LITERAL
    NO_UPDATE	=	256,	! Indicating no update of current line needed
    NO_REFRESH	=	100,	! Indicating no refresh of screen needed
    MESSAGE_LINE=	22,	! Line on which messages are displayed
    COMMAND_LINE=	23,	! Line on which command prompts are displayed
    DIR_FORWARD	=	1,	! Forward direction.
    DIR_BACKWARD=	0,	! Backward direction.

    TAB		=	9,	! Mnemonic defs for some special characters.
    LF		=	10,
    CR		=	13,
    CTRL_Z	=	26,
    DEL		=	127,
    ESC		=	27;

EXTERNAL
    C_SHFT,				! The number of columns shifted.
    C_CHG,				! Indicates current line has changed.
    C_ACOL,				! The column we should be on.

    C_DIR,				! The current direction.
    C_DMODE,				! The directional mode.

    C_DLBUF	: BLOCK			! Deleted line buffer.
	[CH$ALLOCATION(257)],
    C_DLLEN,				! Deleted line length.
    C_DWBUF	: BLOCK			! Deleted word buffer.
	[CH$ALLOCATION(81)],
    C_DWLEN,				! Length of del word string.
    C_DCBUF	: BLOCK			! Deleted character buffer.
        [CH$ALLOCATION(2)],

    C_SBUF,				! Pointer to select buffer.
    C_SELL : LN_BLOCK,			! Relative line number of select.
    C_MFLG,				! Indicates a message has been disp.
					! -1 for backup, 1 for advance.
    C_LNO,				! current line number.
    C_CCOL,				! current column
    C_CLIN,				! cursor line.
    C_LOS,				! number of lines on screen.
    P_LNO,				! Previous line number.
    P_COL,				! Previous column number.
    C_EXIT,				! Change mode has been exited.
    C_SELP,				! select position.
    C_ERR,				! Error message number.
    C_TOP : LN_BLOCK,			! The forced to top line.

    C_SADR,				! Address of search string.
    C_SLEN,				! Length of search string.
    C_RADR,				! Address of replace string.
    C_RLEN,				! Length of replace string.

    C_VERT,				! Last entity was VERT flag.
    C_PSTC,				! No. of characters pasted.
    C_SINFO : SCREEN_VEC;		! The screen info vector.

EXTERNAL
    C_BUF,				! Command string buffer
    C_POINT,				! Command string pointer
    C_END,				! End of command pointer
    C_LEN,				! Length of command buffer
    L_BUF,				! Current line buffer
    L_POINT,				! Current character pointer
    L_END,				! End of current line pointer
    L_LEN,				! Length of current line
    LNO_0,				! Line number 10**0 (1)
    LNO_1,				! Line number 10**1 (10)
    K_RAH,				! Read ahead flag
    E_CC,				! Control c.
    E_I_SOURCE,				! Source of command input.
    E_SLIN,				! Number of lines on the screen.
    E_SBEGIN,				! Leave search at begining if on
    E_SBOUND,				! Is search bounded.
    E_PASTE_TBCB: REF TBCB_BLOCK,	! The paste buffer tbcb
    E_TBCB	: REF TBCB_BLOCK,	! The current buffer tbcb
    E_T_WIDTH,				! Width of terminal line
    E_T_TYPE,				! Terminal type.
    E_EXITED,				! Exit from edt
    E_EXACT,				! Exact search or no.
    E_WRAP,				! Word wrap
    E_S_TOP,				! Top line for scrolling up
    E_S_BOT,				! Bottom line for scrolling down
    E_KEYPAD,				! Keypad activated?
    E_ENT : VECTOR,			! Pointers to user defined entities
    E_RECOVER,				! In recovery mode?
    E_TAB,				! Structured tab size
    E_TLEV,				! Structured tab level.
    E_TADJ,				! Count for tabs adjust.
    E_ABUF : REF TBCB_BLOCK,		! Alternate buffer used for cut/paste.
    E_QUIET,				! Should I ring the bell or not?
    E_SCRCHG,				! Was screen changed by EXT command?
    SY_COM_RAB,				! The RAB for the recovery command file.
    U_STR_COMP,				! Address of current compare routine
    U_SLEN,				! Length of current search string
    U_SRCHSTR,				! Current search string
    U_SUBSTR,				! Current substitute string
    U_SUBLEN,				! Length of subs string
    F_BUF,				! Format buffer
    F_CUR,				! Pointer into format buffer
    W_LINE	: REF LIN_BLOCK;	! Current line pointer

EXTERNAL ROUTINE
    EXT_DECS 
    E_PUT_AUDIT,			! Put a string to the journal file
    DEFINE_KEY:	NOVALUE,		! Define a key for keypad editing
    E_EXT,				! Extend command handler
    E_S_AUDIT,				! Stop recovering routine
    F_CHAR,				! Format a charcter
    F_COL_INC,				! Compute character size.
    F_CRLF,				! Format a CRLF
    F_DEC,				! Format a decimal number
    F_LITERAL,				! Format a literal string
    F_STRING,				! Format a string
    F_PUT,				! Dump the format buffer
    F_SET_COL,				! Set the current column
    F_WRITE,				! Change address of write routine
    FLL_FILL,				! Do a text fill
    IO_GC,				! Get a character
    IO_REC,				! Read with echo
    IO_WT,				! Write to terminal
    IO_WTU,				! Write to terminal unformatted
    IO_COM,				! Get a command line
    IO_GET,				! Get a record from a file
    H_CHANGE,				! Get change mode help
    K_TRAN_CHAR,			! Translate an escape sequence
    KEY_COM,				! Get a keypad command
    MC_BOTTOM,				! Move to bottom of buffer
    MC_CHANGE,				! Declare current line as changed
    MC_DOWN,				! Move down a line
    MC_GET_LINE,			! Get current line in line buffer
    MC_LEFT,				! Move left a character
    MC_RIGHT,				! Move right a character
    MC_TOP,				! Move to top of buffer
    MC_UP,				! Move up a line
    SC_COMP_CURSOR,			! Compute the cursor position
    C_CURSOR,				! Do a cursor position
    SC_CURSOR,				! Put cursor position in format buffer
    SC_FCURSOR,				! Force cursor position in format buffer
    SC_E_LINE,				! Erase to end of line
    SC_E_SCREEN,			! Erase to end of screen
    SC_INIT,				! Initialize for screen mode
    SC_MCOL,				! Match column
    SC_NCOL,				! Compute new column
    SC_RESET,				! Reset screen parameters
    SC_REV,				! Start reverse video
    SC_NOREV,				! End reverse video
    SC_UPDATE,				! Update the screen
    SC_ZAP_SINFO,			! Zero all screen info
    SC_NOSCR,				! Reset the scrolling region
    SC_SCRREG,				! Set the scrolling region
    SC_INSERT,				! Insert lines on screen
    SC_DELETE,				! Delete lines from screen
    SYS_WORK,				! Set up working AST
    SYS_EWORK,				! Terminate working AST
    SY_GET_MESS,			! Get message text
    TI_E_STRING,			! Echo a string
    TI_LINE,				! Get a line of input
    TI_CHAR,				! Get a character of input
    TI_CLEAR_AUDIT,			! Flush the journal buffer
    TI_START_ECHO,			! Start command echoing
    TI_TYPE_AHEAD,			! Check for type ahead
    U_S_STRING,				! Setup string search buffer
    U_S_SUBS,				! Setup substitute strings
    U_DIGIT,				! Check for digit character
    WF_CLEAR,				! Clear a buffer
    WF_COMP_LNO,			! Compare line numbers
    WF_DELETE_LINE,			! Delete a line from buffer
    WF_R_FORWARD,			! Move forward a line
    WF_R_BACKWRD,			! Move backward a line
    WF_R_CURRENT,			! Get the current line
    WF_TOP,				! Go to top of buffer
    WF_EOB,				! Check for end of buffer
    WF_REPLACE_LINE,			! Replace a line in text buffer
    WF_START_INSERT,			! Start an insert sequence
    WF_INSERT_LINE,			! Insert a line into buffer
    WF_END_INSERT,			! End an insert sequence
    WF_BOTTOM,				! Go to bottom of file
    U_F_BUFFER,				! Search for a text buffer
    U_CVTCASE,				! Convert string to upper case
    U_LETTER,				! Check for alphabetic character
    U_LETDIG;				! Check for alphanumeric character

!+
! Define the entity types.
!-

LITERAL

    ENT_CHAR	= 1,
    ENT_WORD	= 3,
    ENT_BW	= 5,
    ENT_EW	= 7,
    ENT_LINE	= 9,
    ENT_BL	= 11,
    ENT_NL	= 13,
    ENT_VERT	= 15,
    ENT_EL	= 17,
    ENT_SEN	= 19,
    ENT_BSEN	= 21,
    ENT_ESEN	= 23,
    ENT_PAR	= 25,
    ENT_BPAR	= 27,
    ENT_EPAR	= 29,
    ENT_PAGE	= 31,
    ENT_BPAGE	= 33,
    ENT_EPAGE	= 35,
    ENT_BR	= 37,
    ENT_ER	= 39,
    ENT_QUOTE	= 41,
    ENT_SR	= 43,
    LAST_ENT	= 43;

!+
! Define the verb numbers.
!
! These are the codes used to represent the change mode subcommands.
!
! The verbs from VERB_MOVE through VERB_APPEND require entities and
! their verb numbers must remain contiguous.
!-

LITERAL

    VERB_MOVE	= 	0,
    VERB_DELETE	= 	1,
    VERB_REPLACE= 	2,
    VERB_CHGC	= 	3,
    VERB_FILL	=	4,
    VERB_TADJ	=	5,
    VERB_CUT	= 	6,
    VERB_APPEND	=	7,

    VERB_SEL	=	8,
    VERB_SUBS	=	9,
    VERB_PASTE	=	10,
    VERB_INSERT	=	11,
    VERB_CC	=	12,
    VERB_EXIT	=	13,
    VERB_SN	=	14,
    VERB_UNDC	=	15,
    VERB_UNDW	=	16,
    VERB_UNDL	=	17,
    VERB_ADV	=	18,
    VERB_BACK	=	19,
    VERB_REF	=	20,
    VERB_TOP	=	21,
    VERB_HELP	=	22,
    VERB_ASC	=	23,
    VERB_QUIT	=	24,
    VERB_SHL	=	25,
    VERB_SHR	=	26,
    VERB_TAB	=	27,
    VERB_TC	=	28,
    VERB_TD	=	29,
    VERB_TI	=	30,
    VERB_EXT	=	31,
    VERB_KS	=	32,
    VERB_DEFK	=	33,
    LAST_VERB	=	33;

!+
! Define the keywords used to make up change mode sub-commands.
!
! Each record in this table contains a byte length of the keyword,
! the value of the keyword, and the ASCII characters which comprise it.
!-

BIND COM_KEY_WORDS = UPLIT BYTE (

	6,	VERB_APPEND,	'APPEND',
	5,	VERB_PASTE,	'PASTE',
        4,	VERB_BACK,	'BACK',
	4,	VERB_CHGC,	'CHGC',
    	4,	VERB_DEFK,	'DEFK',
        4,	VERB_FILL,	'FILL',
        4,	VERB_HELP,	'HELP',
        4,	VERB_QUIT,	'QUIT',
	4,	VERB_TADJ,	'TADJ',
        4,	VERB_UNDC,	'UNDC',
        4,	VERB_UNDL,	'UNDL',
        4,	VERB_UNDW,	'UNDW',
        3,	VERB_ADV,	'ADV',
        3,	VERB_ASC,	'ASC',
	3,	VERB_CUT,	'CUT',
	3,	VERB_EXT,	'EXT',
        3,	VERB_REF,	'REF',
	3,	VERB_SEL,	'SEL',
	3,	VERB_SHL,	'SHL',
        3,	VERB_SHR,	'SHR',
	3,	VERB_TAB,	'TAB',
	3,	VERB_TOP,	'TOP',
	2,	VERB_EXIT,	'EX',
    	2,	VERB_KS,	'KS',
	2,	VERB_SN,	'SN',
        2,	VERB_TC,	'TC',
        2,	VERB_TD,	'TD',
        2,	VERB_TI,	'TI',
	1,	VERB_DELETE,	'D',
	1,	VERB_INSERT,	'I',
	1,	VERB_SUBS,	'S',
        1,	VERB_REPLACE,	'R',
	1,	VERB_CC,	'^',
	0);

!+
! The following are keywords which are entities.
!
! The values must be separated by two so we can add the direction to
! the entity for use as a case index.
!-

BIND ENT_KEY_WORDS = UPLIT BYTE(

	1,	ENT_CHAR,	'C',		! Character
	1,	ENT_WORD,	'W',		! Word
	1,	ENT_LINE,	'L',		! Line
        3,	ENT_SEN,	'SEN',		! Sentence
        3,	ENT_PAR,	'PAR',		! Paragraph
        4,	ENT_PAGE,	'PAGE',		! Page

        2,	ENT_BW,		'BW',		! Beginning of ...
	2,	ENT_BL,		'BL',
        4,	ENT_BSEN,	'BSEN',	
	4,	ENT_BPAR,	'BPAR',
	5,	ENT_BPAGE,	'BPAGE',
	2,	ENT_BR,		'BR',

	2,	ENT_EW,		'EW',		! End of ...
	2,	ENT_NL,		'NL',
        4,	ENT_ESEN,	'ESEN',	
	4,	ENT_EPAR,	'EPAR',
	5,	ENT_EPAGE,	'EPAGE',
	2,	ENT_ER,		'ER',

        1,	ENT_VERT,	'V',		! Vertical line
	2,	ENT_EL,		'EL',		! End of line (not including terminator)
        1,	ENT_QUOTE,	'''',		! Quoted string
	1,	ENT_QUOTE,	'"',		! Alternate form of quoted string.
	1,	ENT_QUOTE,	0,		! Third form of quoted string
	2,	ENT_SR,		'SR',		! Selected range.
	0);

!+
! C_MESSAGE.
!
! This routine outputs a message on the last line of the terminal.
! The input parameter is the message number.
!-

GLOBAL ROUTINE C_MESSAGE(MESS) : NOVALUE =
    BEGIN
    SYS_EWORK();
    !
    ! Force the cursor to the last line.
    !
    SC_CURSOR(MESSAGE_LINE,0);
    !
    ! Erase the line.
    !
    SC_E_LINE();
    !
    ! Turn reverse video on.
    !
    SC_REV();
    !
    ! Get the message.
    !
    SY_GET_MESS(.MESS);
    !
    ! Make cursor position unknown to force a positioning sequence.
    !
    P_COL = 99;
    !
    ! Put it out to the terminal.
    !
    F_PUT();
    !
    ! And set a flag saying a message has been displayed, so we can erase
    ! it when the user types a character.
    !
    C_MFLG = 1;
    END;

!+
! C_BEEP
!
! Put an error message to the terminal, and if the quiet mode
! is not set, ring the bell.
!-

GLOBAL ROUTINE C_BEEP(MSG_NUM) : NOVALUE =
    BEGIN
    IF .E_QUIET EQL 0 THEN F_LITERAL(UPLIT(7),1);
    C_MESSAGE(.MSG_NUM);
    END;

!+
! C_E_MESSAGE
!
! This routine erases the message line if there is currently a message
! on it.
!-

GLOBAL ROUTINE C_E_MESSAGE : NOVALUE =
    BEGIN
    !
    ! Check for message.
    !
    IF .C_MFLG THEN
	BEGIN
	!
	! Position to the message line.
	!
	SC_CURSOR(MESSAGE_LINE,0);
	!
	! Erase the line.
	!
	SC_E_LINE();
	F_PUT();
	!
	! And reset the message flag.
	!
	C_MFLG = 0;
	END;
    END;

!+
! C_CHECK_CC
!
! This routine checks to see if a CTRL/C has been typed.  This routine
! is called from each loop in the code, so that it can be terminated by CTRL/C.
!
! If CTRL/C has been typed, the screen is repainted and 1 is returned
! by this function, otherwise 0 is returned.
!-

GLOBAL ROUTINE C_CHECK_CC =
    BEGIN
    IF .E_CC THEN
	BEGIN
	SC_INIT();
	RETURN 1;
	END;
    RETURN 0;
    END;

!+
! Mark change.
!
! This routine keeps track of the bounds between which the current line
! must be updated, if the line is on the screen.  If the line is not on
! the screen, it merely notes the fact that the line has changed, causing
! it to be replaced in the work file when we move off of it.
!
! F is a pointer to the character at which the update begins
! T is a pointer to the character to which the update continues
!-

ROUTINE MARK_CHANGE(F,T) : NOVALUE =
    BEGIN
    !
    ! Is line on the screen?
    !
    IF .C_LNO LEQU .C_LOS THEN
	BEGIN
	!
	! Minimize and maximize the starting positions of the update with their
	! current values.
	!
	IF .C_SINFO[.C_LNO,SI_UPD_FROM] GTR CH$DIFF(.F,L_BUF) THEN
	    C_SINFO[.C_LNO,SI_UPD_FROM] = CH$DIFF(.F,L_BUF);
	IF .C_SINFO[.C_LNO,SI_UPD_TO] LSS CH$DIFF(.T,L_BUF) THEN
	   C_SINFO[.C_LNO,SI_UPD_TO] = CH$DIFF(.T,L_BUF);
	END;
    END;

!+
! New length.
!
! This routine is called when the current line changes in length.  It updates
! the L_END and L_LEN variables and insures that the last character of the
! line is a carriage return
!
! L is the change in the length of the line.
!-

ROUTINE NEW_LENGTH(L) : NOVALUE =
    BEGIN
    L_LEN = .L_LEN + .L;
    L_END = CH$PTR(L_BUF,.L_LEN);
    CH$WCHAR(CR,.L_END);
    C_CHG = 1;
    END;

!+
! This little routine returns a comparison between the select line
! and the current line.  If no select is in effect as follows:
!
!	-1  if the select is before the current line or there is no select
!	 0  if it is on the current line
!	 1  if it is after the current line
!
! This is useful, because, when text is changed, the select position is
! affected only if it is on or after the current line.
!-

ROUTINE SEL_POS =
    BEGIN
    IF .C_SBUF NEQ .E_TBCB THEN
	RETURN -1
    ELSE
	RETURN WF_COMP_LNO(C_SELL,E_TBCB[TBCB_CUR_LIN]);
    END;

!+
! Split a line of text at the current cursor position.
!
! The characters in front of the cursor become a new line, inserted
! in front of the current one.  The cursor is left on the original
! line.
!
! The scroll parameter indicates that we should attemp to scroll the
! VT100 screen to make room for the inserted line.
!-

ROUTINE SPL_LINE(SCROLL) : NOVALUE =
    BEGIN
    LOCAL
	LEN;
    !
    ! Get length of the new line.
    !
    LEN = CH$DIFF(.L_POINT,CH$PTR(L_BUF));
    IF .LEN EQL 0 THEN IF .SCROLL THEN SC_INSERT();
    !
    ! Fix up select range if necessary.
    !
    SELECT SEL_POS() OF
	SET
	[0]: IF CH$PTR_GTR(.C_SELP,.L_POINT) THEN
		 BEGIN
		 C_SELP = CH$PLUS(.C_SELP,-.LEN);
		 ADDLINE(LNO_0,C_SELL,C_SELL);
		 END;

	[1]: ADDLINE(LNO_0,C_SELL,C_SELL);
	TES;
    !
    ! Insert the new line.
    !
    WF_INSERT_LINE(CH$PTR(L_BUF),.LEN);
    MARK_CHANGE(.L_POINT,.L_END);
    C_CHG = 1;
    C_LNO = .C_LNO + 1;
    !
    ! Adjust the old one.
    !
    IF .LEN NEQ 0 THEN
	BEGIN
	CH$MOVE(CH$DIFF(.L_END,.L_POINT),.L_POINT,CH$PTR(L_BUF));
	IF .SCROLL THEN SC_INSERT();
	END;
    NEW_LENGTH(-.LEN);
    IF CH$PTR_NEQ(.L_POINT,CH$PTR(L_BUF)) THEN MARK_CHANGE(L_BUF,.L_END);
    L_POINT = CH$PTR(L_BUF);
    END;

!+
! Split a line of text at the current cursor position.
!-

ROUTINE SPLIT_LINE(SCROLL) : NOVALUE =
    BEGIN
    WF_START_INSERT();		! Perform initialization for text insertion
    SPL_LINE(.SCROLL);		! Split the line
    WF_END_INSERT();		! End the insertion sequence
    END;

!+
! Insert a string of characters at the current position in the text.
!
! S is a pointer to the string.
! L is the length.
!-

ROUTINE INSERT_CHARS(S,L) =
    BEGIN
    !
    ! First make sure the line will not overflow.
    !
    IF .L_LEN+.L GTRU 255 THEN
	BEGIN
	C_BEEP(ERR_LINEXC255);
	RETURN 0;
	END
    ELSE
	BEGIN
	LOCAL
	    OLD_LPOINT;
	!
	! Check for the old EOB.
	!
	IF WF_EOB() THEN
	    BEGIN
	    MARK_CHANGE(.L_END,.L_END);
	    SPLIT_LINE(1);
	    MC_UP();
	    END;
	!
	! Compute the new cursor position.
	!
	OLD_LPOINT = .L_POINT;
	L_POINT = CH$PLUS(.L_POINT,.L);
	!
	! Open up a hole for the new characters.
	!
	CH$MOVE(CH$DIFF(.L_END,.OLD_LPOINT),.OLD_LPOINT,.L_POINT);
	!
	! And move the new one(s) in.
	!
	CH$MOVE(.L,.S,.OLD_LPOINT);
	!
	! Update the length of the line.
	!
	NEW_LENGTH(.L);
	!
	! And mark the line as changed from the original cursor to the end.
	!
	MARK_CHANGE(.OLD_LPOINT,.L_END);
	!
	! Update select ranges if necessary.
	!
	IF SEL_POS() EQL 0 THEN
	    IF CH$PTR_LSS(.OLD_LPOINT,.C_SELP) THEN
		C_SELP = CH$PLUS(.C_SELP,.L);
	RETURN 1;
	END;
    END;

!+
! Insert a string of characters which may include carriage returns.
! Carriage returns are treated as line terminators, having the effect of
! breaking the current line of text into two.
!
! S is a pointer to the character string to insert.
! L is the length of the string.
!
! A value of 0 is returned if a line exceeded 255 characters during the
! insert (further insertions were lost).
!-

ROUTINE INSERT_STRING(S,L) =
    BEGIN
    LOCAL
	END_STRING,
	POINT,
	MY_S,
	MY_L;
    !
    ! Initialize a pointer to the current character and one to the end of the
    ! string.
    !
    POINT = .S;
    END_STRING = CH$PLUS(.S,.L);
    !
    ! Now, loop until no more characters remaining.
    !
    WHILE CH$PTR_NEQ(.END_STRING,.POINT) DO
	BEGIN
	IF CH$RCHAR(.POINT) EQL CR THEN
	    !
	    ! The character is a carriage return.  Split the line, scrolling
	    ! the screen if possible to make room for the new line.
	    !
	    BEGIN
	    SPLIT_LINE(1);
	    POINT = CH$PLUS(.POINT,1);
	    END
	ELSE
	    BEGIN
	    !
	    ! The character is not a carriage return.  Insert the string of
	    ! characters up to the end or to the next carriage return.
	    !
	    MY_S = .POINT;
	    WHILE CH$PTR_NEQ(.END_STRING,.POINT) AND
		  CH$RCHAR(.POINT) NEQ CR DO POINT = CH$PLUS(.POINT,1);
	    IF INSERT_CHARS(.MY_S,CH$DIFF(.POINT,.MY_S)) EQL 0 THEN RETURN 0;
	    END;
	END;
    RETURN 1;
    END;

!+
! This routine saves the current buffer position in a position block.
!-
ROUTINE SAVE_POS(POS) : NOVALUE =
    BEGIN
    MAP
	POS : REF POS_BLOCK;
    !
    ! Update the current line if necessary.
    !
    MC_CHANGE();
    CH$MOVE(POS_SIZE,.E_TBCB,.POS);
    POS[POS_CHAR_POS] = CH$DIFF(.L_POINT,CH$PTR(L_BUF));
    END;

!+
! This routine re-positions to the buffer postion saved by the
! above routine.
!-

ROUTINE RE_POS(POS) : NOVALUE =
    BEGIN
    MAP
	POS : REF POS_BLOCK;
    LOCAL
	DIFF : LN_BLOCK;
    !
    ! Update current line if necessary.
    !
    MC_CHANGE();
    !
    ! Reposition the text buffer.
    !
    SUBLINE(E_TBCB[TBCB_CUR_LIN],POS[POS_CUR_LIN],DIFF);
    CH$MOVE(POS_SIZE,.POS,.E_TBCB);
    !
    ! Get the new line in the buffer.
    !
    MC_GET_LINE();
    !
    ! And keep track of the relative line number.
    !
    C_LNO = .C_LNO + .DIFF;
    END;

!+
! HLP_KEYPAD
! 
! This routine handles help while in keypad mode.  The help processor
! is first called to put up the keypad diagram.  Then we go into a loop
! accepting characters and, if they are definable keys, we give the help
! message for the key.
!-

GLOBAL ROUTINE HLP_KEYPAD : NOVALUE =
    BEGIN
    LOCAL
	HELP_STRING : BLOCK[CH$ALLOCATION(16)],
	C;

    !
    ! Get the right terminal type.
    !
    IF .E_T_TYPE EQL TERM_VT100 THEN
	CH$MOVE(15,UPLIT(%STRING('KEYPAD VT100   ')),HELP_STRING)
    ELSE
	CH$MOVE(15,UPLIT(%STRING('KEYPAD VT52    ')),HELP_STRING);
    !
    ! Home the cursor and erase the screen.
    !
    SC_CURSOR(0,0);
    SC_E_SCREEN();
    F_PUT();
    !
    ! Call help to get the keypad diagram.
    !
    H_CHANGE(HELP_STRING,12,0);

    !
    ! Loop, displaying help on keypad keys.
    !
    WHILE 1 DO
	BEGIN
	!
	! Get next character.
	!
	TI_CHAR(C);
	!
	! Erase the screen.
	!
	P_LNO = 999;
	SC_CURSOR(0,0);
	SC_E_SCREEN();
	!
	! If character is escape, translate the escape sequence.
	!
	IF .C EQL 27 THEN K_TRAN_CHAR(C);
	!
	! If character is carriage return, then re-display the keypad diagram.
	!
	IF .C EQL 13 THEN
	    H_CHANGE(HELP_STRING,12,0)
	ELSE
	    BEGIN
	    !
	    ! If key is a control character, translate to our internal rep.
	    !
	    IF .C LSSU %C' ' THEN
		BEGIN
		CH$WCHAR(%C'C',CH$PTR(HELP_STRING,15));
		C = .C + 301;
		END
	    ELSE IF .C LSSU 256 THEN 	! Get out if not a definable key.
		EXITLOOP;

	    !
	    ! Get key number so we can create the topic.
	    !
	    C = .C - 257;
	    CH$WCHAR(.C/10+%C'0',CH$PTR(HELP_STRING,13));
	    CH$WCHAR(.C MOD 10+%C'0',CH$PTR(HELP_STRING,14));
	    !
	    ! Get the help text for the key.
	    !
	    H_CHANGE(HELP_STRING,15,0);
	    !
	    ! Output the help instructions.
	    !	
	    F_CRLF();
	    SY_GET_MESS(ERR_TORETKEY);
	    F_CRLF();
	    SY_GET_MESS(ERR_FORHLPANO);
	    F_CRLF();
	    SY_GET_MESS(ERR_TOEXITHLP);
	    F_PUT();
	    END;
	END;
    END;

!+
! This routine combines the current line with the one immediately
! above it.
!-

ROUTINE COMBINE_LINE : NOVALUE =
    BEGIN
    LOCAL
	EOB,
	S_POS,
	LEN;
    !
    ! Remember if we are at the end of the buffer.
    !
    EOB = WF_EOB();
    !
    ! Remember the position relative to select.
    !
    S_POS = SEL_POS();
    !
    ! Move back a line, give up if it fails.
    !
    IF NOT WF_R_BACKWRD() THEN RETURN;
    C_LNO = .C_LNO-1;
    !
    ! Get length of add on line.
    !
    LEN = .W_LINE[LIN_LENGTH];
    !
    ! Make sure the two do not exceed 255 characters.
    !
    IF .L_LEN + .LEN GTR 255 THEN
	BEGIN
	C_BEEP(ERR_LINEXC255);
	WF_R_FORWARD();
	RETURN;
	END;
    !
    ! Move the current line over.
    !
    L_POINT = CH$PTR(L_BUF,.LEN);
    CH$MOVE(.L_LEN,CH$PTR(L_BUF),.L_POINT);
    !
    ! And move in the new text.
    !
    CH$MOVE(.LEN,W_LINE[LIN_TEXT],CH$PTR(L_BUF));
    !
    ! Update the length field.
    !
    NEW_LENGTH(.LEN);
    MARK_CHANGE(.L_POINT,.L_END);
    !
    ! Delete the first line unless it is the last and is non-empty.
    !
    IF NOT .EOB OR .L_LEN EQL 0 THEN WF_DELETE_LINE();
    !
    ! And check for updating the select range.
    !
    SELECT .S_POS OF
	SET
	[0]: BEGIN
	     C_SELP = CH$PLUS(.C_SELP,.LEN);
	     SUBLINE(LNO_0,C_SELL,C_SELL);
	     END;

	[1]: SUBLINE(LNO_0,C_SELL,C_SELL);
	TES;
    END;

!+
! DO_PASTE
!
! This routine executes the paste command.  The variable E_ABUF has
! the address of the TBCB for the buffer to be pasted.
!
! A value of 0 is returned if the paste failed.
!-

ROUTINE DO_PASTE =
    BEGIN
    LOCAL
	SCROLL,
	SAVE_TBCB;

    IF .E_ABUF EQL 0 THEN RETURN 0;
    !
    ! Check for paste of the current buffer.
    !
    IF .E_ABUF EQL .E_TBCB THEN
	BEGIN
	C_BEEP(ERR_ATTPASCUR);
	RETURN 0;
	END;
    !
    ! Save the address of the current text buffer.
    !
    SAVE_TBCB = .E_TBCB;
    C_PSTC = 0;
    !
    ! Check for empty buffer.
    !
    IF WF_COMP_LNO(LNO_0,E_ABUF[TBCB_LINE_COUNT]) EQL 1 THEN RETURN 1;
    IF (SCROLL = WF_COMP_LNO(LNO_1,E_ABUF[TBCB_LINE_COUNT]) GEQ 0) EQL 0 THEN
	SC_ZAP_SINFO(MAX(0,.C_LNO),23);
    !
    ! Split the current line.
    !
    SPLIT_LINE(0);
    MC_LEFT();
    WF_START_INSERT();		! Perform initialization for text insertion
    !
    ! Position to the front of the paste buffer.
    !
    E_TBCB = .E_ABUF;
    WF_TOP();
    WHILE 1 DO ! Loop through all of the paste buffer.
	BEGIN
	!
	! Check for CTRL/C.
	!
	IF C_CHECK_CC() NEQ 0 THEN EXITLOOP;
	!
	! Handle the next line.
	!
	INSERT_CHARS(W_LINE[LIN_TEXT],.W_LINE[LIN_LENGTH]);
	C_PSTC = .C_PSTC + .W_LINE[LIN_LENGTH] + 1;
	IF NOT WF_R_FORWARD() THEN EXITLOOP;
	E_TBCB = .SAVE_TBCB;
	WF_R_CURRENT();
	SPL_LINE(.SCROLL);
	E_TBCB = .E_ABUF;
	WF_R_CURRENT();
	END;
    E_TBCB = .SAVE_TBCB;
    WF_R_CURRENT();
    MC_DOWN();
    COMBINE_LINE();
    WF_END_INSERT();		! End the text insertion sequence
    C_PSTC = .C_PSTC - 1;
    RETURN 1
    END;

!+
! This function returns a 1 if the current character is an entity delimiter.
!
! TERM_STRING is a counted string of valid delimiter characters
!-

ROUTINE ENT_TERM(TERM_STRING) =
    BEGIN
    LOCAL
	NT,
	TS;
    TS = .TERM_STRING;
    NT = CH$RCHAR_A(TS);
    DECR I FROM .NT-1 TO 0 DO
	IF CH$RCHAR(.L_POINT) EQL CH$RCHAR_A(TS) THEN RETURN 1;
    RETURN 0;
    END;

!+
! Move backwards to the beginning of a word.
!-

ROUTINE BEG_WORD(L_FLAG) =
    BEGIN
    LOCAL
	SIZE;
    SIZE = 0;
    !
    ! Go past all spaces to the left first.
    !
    WHILE CH$RCHAR(.L_POINT) EQL %C' ' DO
       IF MC_LEFT() THEN  SIZE = .SIZE + 1 ELSE EXITLOOP;
    !
    ! Keep moving left until we hit a terminator or beginning of file.
    !
    WHILE NOT ENT_TERM(.E_ENT[0]) DO
	BEGIN
	!
	! If L_FLAG is 1, do not go beyond the beginning of line.
	!
	IF (.L_FLAG EQL 1) AND CH$PTR_EQL(.L_POINT, CH$PTR(L_BUF))
	    THEN EXITLOOP;
	!
	! Do not go beyond the beginning of file.
	!
	IF NOT MC_LEFT() THEN EXITLOOP;
	!
	! Continue search.
	!
	SIZE = .SIZE + 1;
	END;
    !
    ! If we moved across any characters before finding a delimiter, then do
    ! not include the delimiter in the word, otherwise, the word is the delimiter
    ! character.
    !
    IF .SIZE GTR 0 AND ENT_TERM(.E_ENT[0]) THEN
	BEGIN
	SIZE = .SIZE-1;
	MC_RIGHT();
	END;
    RETURN .SIZE
    END;

!+
! Find the end of a word.
!
! The number of characters between the cursor and the end of the word
! is returned.
!-

ROUTINE END_WORD =
    BEGIN
    LOCAL
	SIZE;
    SIZE = 0;
    !
    ! Scan up to a delimiter.
    !
    WHILE NOT ENT_TERM(.E_ENT[0]) DO
	BEGIN
	IF NOT MC_RIGHT() THEN EXITLOOP;
	SIZE = .SIZE+1;
	END;
    !
    ! If the delimiter was a space, or there were no characters before the
    ! delimiter, then scan past all trailing spaces (but do not cross a line).
    !
    IF .SIZE EQL 0 OR CH$RCHAR(.L_POINT) EQL %C' ' THEN
	DO  BEGIN
	    MC_RIGHT();
	    SIZE = .SIZE + 1;
	    END
	UNTIL CH$PTR_EQL(.L_POINT,CH$PTR(L_BUF)) OR
	      CH$RCHAR(.L_POINT) NEQ %C' ';
    
    RETURN .SIZE
    END;

!+
! Look for a sentence delimiter.  If one is found, move to the right
! over it.  A sentence delimiter must be a character in the set of
! delimiters followed by a space or a <CR>.
!
! The parameter INC indicates whether or not the delimiter should
! be included.
!
! A value of 1 is returned if a delimiter is found, 0 otherwise.
!-

ROUTINE SENT_DELIM(INC) =
    BEGIN
    !
    ! Look for a sentence delimiter.
    !
    IF ENT_TERM(.E_ENT[1]) THEN
	BEGIN
	!
	! Move to next character.
	!
	MC_RIGHT();
	!
	! If we are at the end of a line, accept the sentence and
	! position either in front of or after the delimiter.
	!
	IF CH$PTR_EQL(.L_POINT,.L_END) THEN
	    BEGIN
	    IF .INC THEN MC_RIGHT() ELSE MC_LEFT();
	    RETURN 1;
	    END;
	!
	! If the character is a blank, then accept the delimiter.
	! If we are to include the delimiter, include all trailing spaces.
	!
	IF CH$RCHAR(.L_POINT) EQL %C' ' THEN
	    BEGIN
	    IF .INC THEN 
		WHILE CH$RCHAR(.L_POINT) EQL %C' ' DO MC_RIGHT()
	    ELSE
		MC_LEFT();
	    RETURN 1;
	    END;
	MC_LEFT();
	END;
    !
    ! We are not at a sentence delimiter, return 0;
    !
    RETURN 0;
    END;

!+
! Find the beginning of a sentence.  Scan backwards until we find
! a sentence delimiter, then include forward over the delimiter and
! the <CR> or all spaces.
!-

ROUTINE BEG_SENT : NOVALUE =
    BEGIN
    !
    ! Scan back to a delimiter.
    !
    DO (IF NOT MC_LEFT() THEN RETURN) UNTIL SENT_DELIM(1);
    END;

ROUTINE SCH_STRING(ADDR,LEN,DIR) =
    BEGIN
    LOCAL
	REM,
	LP,
	LE,
	FC,
	AFC;
    !
    ! Remember the first character and the alternate first character
    ! (case equivalent) so we can avoid compares when first characters
    ! do not match.
    !
    AFC = FC = CH$RCHAR(.ADDR);
    IF .E_EXACT EQL 0 AND
       U_LETTER(.ADDR) THEN
	AFC = .AFC XOR 32;

    LP = CH$PTR(W_LINE[LIN_TEXT],.E_TBCB[TBCB_CHAR_POS]);
    LE = CH$PTR(W_LINE[LIN_TEXT],.W_LINE[LIN_LENGTH]);
    WHILE 1 DO
	BEGIN
	IF C_CHECK_CC() THEN RETURN 2;
	IF (REM = CH$DIFF(.LE,.LP)) GEQ .LEN THEN
	    IF CH$RCHAR(.LP) EQL .FC OR CH$RCHAR(.LP) EQL .AFC THEN
		IF (.U_STR_COMP)(.LP,.ADDR,.LEN) THEN
		    BEGIN
		    E_TBCB[TBCB_CHAR_POS] = CH$DIFF(.LP,CH$PTR(W_LINE[LIN_TEXT]));
		    RETURN 1;
		    END;
	IF .DIR EQL DIR_BACKWARD THEN
	    IF .LP EQL CH$PTR(W_LINE[LIN_TEXT]) THEN
		BEGIN
		IF NOT WF_R_BACKWRD() THEN RETURN 0;
		LP = LE = CH$PTR(W_LINE[LIN_TEXT],.W_LINE[LIN_LENGTH]);
		END
	    ELSE
		LP = CH$PLUS(.LP,-1)
	ELSE
	    IF .REM LEQ .LEN THEN
		BEGIN
		IF NOT WF_R_FORWARD() THEN RETURN 0;
		LP = CH$PTR(W_LINE[LIN_TEXT]);
		LE = CH$PTR(.LP,.W_LINE[LIN_LENGTH]);
		END
	    ELSE
		LP = CH$PLUS(.LP,1)
	END
    END;

!+
! This routine checks to see if the string specified by ADDR and
! LEN matches at the current character position.
!
! The value 1 is returned if it matches, 0 otherwise.
!-

ROUTINE ON_STRING(ADDR,LEN) =
    BEGIN
    LOCAL
	C,
	CP,
	MATCHED;
    !
    ! Keep track of how many characters matched so we can back up.
    !
    MATCHED = 0;
    CP = .ADDR;
    !
    ! Loop over size of the string.
    DECR I FROM .LEN-1 TO 0 DO
	BEGIN
	IF CH$PTR_EQL(.L_POINT,.L_END) THEN
	    IF CH$RCHAR_A(CP) EQL CR THEN
		IF WF_EOB() THEN EXITLOOP ELSE MC_DOWN()
	    ELSE
		EXITLOOP
	ELSE
	    BEGIN
	    C = CH$RCHAR(.L_POINT);
	    IF .E_EXACT EQL 0 THEN
		IF .C GEQ %C'a' AND .C LEQ %C'z' THEN C = .C - 32;
	    IF CH$RCHAR_A(CP) NEQ .C THEN EXITLOOP;
	    L_POINT = CH$PLUS(.L_POINT,1);
	    END;
	MATCHED = .MATCHED + 1;
	END;
    !
    ! Back up to the original position.
    !
    DECR I FROM .MATCHED-1 TO 0 DO MC_LEFT();

    .MATCHED EQL .LEN
    END;

!+
! FIND_STRING
!
! This routine searches either forward or backward from the current
! position looking for a specific string.
!
! ADDR is the address of the string to find
! LEN is the length of the string
! M indicates whether or not we should move a character before beginning.
! DIR is the direction of the search.
! 
! 1 is returned if the string is found, 0 if not.
!-

ROUTINE FIND_STRING(ADDR,LEN,M,DIR) =
    BEGIN
    LABEL
	SEARCH_LOOP;
    LOCAL
	MOVE,
	INIT_LEN,
	CP,
	C,
	ORIG_LNO : LN_BLOCK,
	LINE_DIFF,
	START_POS : POS_BLOCK,
	STS;

    MOVE = .M;
    !
    ! Remember where we started.
    !
    ORIG_LNO = .C_LNO;
    SAVE_POS(START_POS);
    !
    ! If searching backward, with search at end, move length of search string back
    ! before starting, so we won't keep finding the same string!  Also, if searching
    ! forward with search at end, do not move before starting search.
    !
    IF .E_SBEGIN EQL 0 THEN
	IF .DIR EQL DIR_BACKWARD THEN
	    BEGIN
	    INCR I FROM 1 TO .LEN DO IF NOT MC_LEFT() THEN RETURN 1
	    END
	ELSE
	    MOVE = 0;
    !
    ! Find the prefix of the search string up to the first carriage return.
    !
    INIT_LEN = 0;
    CP = .ADDR;
    WHILE .INIT_LEN LSS .LEN AND
	  CH$RCHAR_A(CP) NEQ CR DO INIT_LEN = .INIT_LEN + 1;
    !
    ! Now, look for the string.
    !
    STS = 0;
    SEARCH_LOOP:
	BEGIN
	WHILE 1 DO
	    BEGIN
	    IF C_CHECK_CC() THEN 
		BEGIN
		STS = 2;
		EXITLOOP;
		END;
	    IF .MOVE THEN
		IF (IF .DIR EQL DIR_BACKWARD THEN MC_LEFT() ELSE MC_RIGHT()) EQL 0 THEN
		    EXITLOOP;
	    MOVE = 1;
	    !
	    ! Find next occurrence of the initial string.
	    !
	    IF .E_SBOUND EQL 0 THEN
		IF .INIT_LEN NEQ 0 THEN
		    BEGIN
		    E_TBCB[TBCB_CHAR_POS] = CH$DIFF(.L_POINT,CH$PTR(L_BUF));
		    IF NOT (STS = SCH_STRING(.ADDR,.INIT_LEN,.DIR)) THEN EXITLOOP;
		    MC_GET_LINE();
		    END
		ELSE
		    !
		    ! Look for the next carriage return.
		    !
		    WHILE CH$RCHAR(.L_POINT) NEQ CR DO
			IF .DIR EQL DIR_BACKWARD THEN
			    IF CH$PTR_EQL(.L_POINT,CH$PTR(L_BUF)) THEN
				IF MC_UP() THEN 
				    L_POINT = .L_END
				ELSE
				    LEAVE SEARCH_LOOP
			    ELSE
				L_POINT = CH$PLUS(.L_POINT,-1)
			ELSE
			    L_POINT = CH$PLUS(.L_POINT,1);
	    !
	    ! Now check to see if the entire string matches.
	    !
	    IF ON_STRING(.ADDR,.LEN) THEN
		BEGIN
		!
		! If we have gotten here, the string matched.
		!
		!
		! Compute the new relative line number.
		!
		SUBLINE(START_POS[POS_CUR_LIN],E_TBCB[TBCB_CUR_LIN],LINE_DIFF);
		C_LNO = .ORIG_LNO + .LINE_DIFF;
		RETURN 1;
		END;
	    !
	    ! If search is bounded, fail if we are on a page mark.
	    !
	    IF .E_SBOUND NEQ 0 THEN
		IF ON_STRING(CH$PLUS(.E_ENT[3],1),CH$RCHAR(.E_ENT[3])) THEN
		    EXITLOOP;
	    END;
	END;
    !
    ! String was not found, reposition.
    !
    RE_POS(START_POS);
    C_LNO = .ORIG_LNO;
    RETURN .STS;
    END;

!+
! UNDELETE
!
! Insert the contents of an undelete buffer and move to whichever end.
!
! BUF is the address of the undelete buffer.  Its first character is
!     the direction indicator.
!
! LEN is the length of the buffer.
!
! 1 is returned if successful, 0 otherwise.
!-

ROUTINE UNDELETE(BUF,LEN) =
    BEGIN
    LOCAL
	DIR,
	RLEN,
	BUF_POINT;
    RLEN = .LEN;
    !
    ! Check for special case of entering an unnecessary carriage return
    ! at the end of the buffer.
    !
    IF WF_EOB() AND CH$RCHAR(CH$PTR(.BUF,.RLEN)) EQL CR THEN
	RLEN = .RLEN - 1;
    BUF_POINT = CH$PTR(.BUF);
    !
    ! Get the direction indicator.
    !
    DIR = CH$RCHAR_A(BUF_POINT);
    IF INSERT_STRING(.BUF_POINT,.RLEN) EQL 0 THEN RETURN 0;
    !
    ! If the delete was a forward one, position to the beginning of the
    ! string we just inserted.
    !
    IF .DIR NEQ DIR_BACKWARD THEN
	DECR I FROM .RLEN-1 TO 0 DO MC_LEFT();
    RETURN 1;
    END;

!+
! PROCESS_CHGC
!
! The is the processing routine for the CHGC command.  We go through
! all of the selected text flipping (ugh) the case of each alphabetic
! character.  This routine is called by the process lines command
! for each line of the selected text.
!-

ROUTINE PROCESS_CHGC(FC,LC) : NOVALUE =
    BEGIN
    LOCAL
	C,
	CP;
    CP = .FC;
    WHILE CH$PTR_NEQ(.CP,.LC) DO
	BEGIN
	IF U_LETTER(.CP) THEN
    	    CH$WCHAR(CH$RCHAR(.CP) XOR 32, .CP);
	CP = CH$PLUS(.CP,1);
	END;
    MARK_CHANGE(.FC,.LC);
    C_CHG = 1;
    END;

!+
! SAVE_LINE
!
! This routine saves a line to the auxiliary buffer if there is one.
! The routine is called by the deletes, and the aux buffer will be set
! if it is really a cut command rather than a delete.
!
!-

ROUTINE SAVE_LINE(LINE,LEN) : NOVALUE =
    BEGIN
    LOCAL
	SAVE_TBCB;
    !
    ! See if there is an aux buffer.
    !
    IF .E_ABUF EQL 0 THEN RETURN;
    !
    ! Switch to the aux buffer.
    !
    SAVE_TBCB = .E_TBCB;
    E_TBCB = .E_ABUF;
    !
    ! Read the current line.
    !
    WF_R_CURRENT();
    !
    ! Insert the line to be saved.
    !
    WF_INSERT_LINE(.LINE,.LEN);
    !
    ! And switch back to the main buffer.
    !
    E_TBCB = .SAVE_TBCB;
    WF_R_CURRENT();
    END;

!+
! This is the controlling routine for processing all the text selected
! by an entity specification.
!
! NUM_LINES  is the number of lines to process
!
! START_POS is the character position in the first line at which we
!	    should start
!
! END_POS is the character position in the last line at which we should stop
!
! PROCESS is the address of a routine to be called for each line.
!
!-

ROUTINE PROCESS_LINES(NUM_LINES,START_POS,END_POS,PROCESS) : NOVALUE =
    BEGIN
    MAP
	END_POS : REF POS_BLOCK;
    LOCAL
	LC;
    !
    ! Loop through all lines.
    !
    INCR I FROM 1 TO .NUM_LINES DO
	BEGIN
	!
	! Set up pointer to last character in line.
	!
	LC = CH$PTR(.L_END);
	IF .I EQL .NUM_LINES THEN LC = CH$PTR(L_BUF,.END_POS[POS_CHAR_POS]);
	(.PROCESS)(.L_POINT,.LC);
	MC_DOWN();
	END;
    !
    ! If the direction was backward, then position to the start of the range
    ! if forward, position to the end of the range.
    !
    IF .C_DIR EQL DIR_BACKWARD THEN 
	RE_POS(.START_POS)
    ELSE
	RE_POS(.END_POS);
    END;

!+
! This routine deletes text on the current line between the
! two pointers FC and LC.
!-

ROUTINE DELETE_CHARS(FC,LC) : NOVALUE =
    BEGIN
    LOCAL LEN;
    !
    ! Compute length of the delete, and quit if zero.
    ! 
    LEN = CH$DIFF(.LC,.FC);
    SAVE_LINE(.FC,.LEN);
    IF .LEN EQL 0 THEN RETURN;
    !
    ! Watch out for select range, adjust as necessary.
    !
    IF SEL_POS() EQL 0 THEN
	IF CH$PTR_GTR(.C_SELP,.FC) THEN
	    IF CH$PTR_GTR(.C_SELP,.LC) THEN
		C_SELP = CH$PLUS(.C_SELP,-.LEN)
	    ELSE
		C_SELP = .FC;
    !
    ! Now, adjust the line.
    !
    CH$MOVE(CH$DIFF(.L_END,.LC),.LC,.FC);
    NEW_LENGTH(-.LEN);
    MARK_CHANGE(.FC,.L_END);
    L_POINT = .FC;
    END;

!+
! This routine deletes text on NUM_LINES lines starting on the
! current line at L_POINT and going to the END_POS on the last
! line.
!-

ROUTINE DELETE_LINES(NUM_LINES,END_POS) : NOVALUE =
    BEGIN
    LOCAL
	LC;
    !
    ! Handle the first line.
    !
    LC = .L_END;
    IF .NUM_LINES EQL 1 THEN LC = .END_POS;
    DELETE_CHARS(.L_POINT,.LC);
    !
    ! Now, if there are more, loop though the middle ones.
    !
    IF .NUM_LINES GTR 1 THEN
	BEGIN
	MC_DOWN();
	INCR I FROM 3 TO .NUM_LINES DO
	    BEGIN
	    !
	    ! Delete the entire line.
	    !
	    SAVE_LINE(L_BUF,.L_LEN);
	    WF_DELETE_LINE();
	    SELECTONE SEL_POS() OF
		SET
		[0]: C_SELP = CH$PTR(L_BUF);
		[1]: SUBLINE(LNO_0,C_SELL,C_SELL);
		TES;
	    MC_GET_LINE();
	    END;
	!
	! Handle the last line.
	!
	DELETE_CHARS(.L_POINT,.END_POS);
	!
	! And combine the various fragments.
	!
	SC_DELETE(.NUM_LINES-1);
	COMBINE_LINE();
	MARK_CHANGE(.L_POINT,.L_END);
	END;
    END;

!+
! INSERT_TABS
!
! This routine inserts enough tabs and spaces to bring us to the
! column specified by count.
!
! 1 is returned if it succeeds, 0 if the line overflows.
!-

ROUTINE INSERT_TABS(COUNT) =
    BEGIN
    !
    ! Insert count/8 tabs.
    !
    INCR I FROM 1 TO .COUNT/8 DO 
	IF INSERT_CHARS(UPLIT(TAB),1) EQL 0 THEN RETURN 0;
    !
    ! Insert count mod 8 spaces.
    !
    INCR I FROM 1 TO .COUNT MOD 8 DO 
	IF INSERT_CHARS(UPLIT(' '),1) EQL 0 THEN RETURN 0;
    RETURN 1;
    END;

!+
! DO_TADJ
!
! This routine executes the TADJ (tabs adjust) command.
! 
!	Compute the column of the first non-blank non-tab character.
!	Strip out all leading spaces and tabs.
! 	Insert enough tabs and spaces to bring us to column + E_TADJ.
!-

ROUTINE DO_TADJ : NOVALUE =
    BEGIN
    LOCAL
	CP,
	COL;
    LABEL
	BL;

    CP = CH$PTR(L_BUF);
    COL = 0;

    BL: BEGIN
	WHILE 1 DO
	    BEGIN
	    IF CH$PTR_EQL(.L_END,.CP) THEN LEAVE BL;
	    SELECTONE CH$RCHAR_A(CP) OF
		SET
		[%C' ']: COL = .COL+1;
		[TAB]: COL = .COL + F_COL_INC(TAB,.COL);
		[OTHERWISE]: EXITLOOP;
		TES;
	    END;
	DELETE_CHARS(CH$PTR(L_BUF),CH$PLUS(.CP,-1));
	INSERT_TABS(.COL + .E_TADJ*.E_TAB);
	END;
    MARK_CHANGE(CH$PTR(L_BUF),.L_END);
    END;

!+
! This routine implements the no-keypad insert mode.  Process insertions
! and the delete character until a CTRL/Z is seen, then return.
!-

ROUTINE INSERT_MODE : NOVALUE =
    BEGIN
    LOCAL
	C : BYTE;
    IF .E_KEYPAD NEQ 0 OR
       .E_T_TYPE EQL TERM_HCPY THEN RETURN;
    SYS_EWORK();
    WHILE 1 DO
	BEGIN
	SC_UPDATE();
	TI_CHAR(C);
	IF .C EQL CTRL_Z OR .C EQL ESC THEN EXITLOOP;
	IF .C EQL DEL THEN 
	    IF CH$PTR_EQL(.L_POINT,CH$PTR(L_BUF)) THEN
		BEGIN
		SC_DELETE(1);
		COMBINE_LINE()
		END
	    ELSE
		DELETE_CHARS(CH$PLUS(.L_POINT,-1),.L_POINT)
	ELSE 
	    INSERT_STRING(C,1);
	END;
    END;

!+
! This routine implements the substitute command.  Just search for the
! search string, delete it and insert the replace string.
!-

ROUTINE DO_SUBS =
    BEGIN
    LOCAL
	STS,
	NUM_LINES,
	END_POS;
    !
    ! Search for the string.
    !
    STS = FIND_STRING(U_SRCHSTR,.U_SLEN,0,.C_DIR);
    IF .STS EQL 1 THEN
	!
	! String was found, do the substitute.
	!
	BEGIN
	!
	! Move to the end of the string, counting the lines involved.
	!
	NUM_LINES = .C_LNO;
	DECR I FROM .U_SLEN-1 TO 0 DO MC_RIGHT();
	NUM_LINES = .C_LNO - .NUM_LINES + 1;
	END_POS = .L_POINT;
	!
	! Move back to the beginning.
	!
	DECR I FROM .U_SLEN-1 TO 0 DO MC_LEFT();
	!
	! Delete the string.
	!
	DELETE_LINES(.NUM_LINES,.END_POS);
	!
	! Insert the replacement string.
	!
	INSERT_STRING(U_SUBSTR,.U_SUBLEN);
	!
	! If we are moving backward, then move back across the string
	!
	IF .C_DIR EQL DIR_BACKWARD THEN
	    DECR I FROM .U_SUBLEN-1 TO 0 DO MC_LEFT();
	RETURN 1
	END
    ELSE 
	BEGIN
	!
	! String was not found, C_BEEP an error.
	!
	IF .STS EQL 0 THEN C_BEEP(ERR_STRNOTFND);
	RETURN 0
	END;
    END;

!+
! SAVE_TEXT
!
! Save the text deleted by a delete line or word command in the
! associated undelete buffer.
!
! NC is the number of characters to save
!
! DEL_BUF is the address of the delete buffer
!
! DEL_LEN is the address to save the length
!-

ROUTINE SAVE_TEXT(NC,DEL_BUF,BUF_LEN) : NOVALUE =
    BEGIN
    LOCAL
	BUF_POINT;
    !
    ! Put the direction in the first char of the buffer.
    !
    BUF_POINT = CH$PTR(.DEL_BUF);
    CH$WCHAR_A(.C_DIR,BUF_POINT);
    !
    ! If it is a forward delete, then go back to the beginning.
    !
    IF .C_DIR NEQ DIR_BACKWARD THEN DECR I FROM .NC-1 TO 0 DO MC_LEFT();
    !
    ! Save the text, ending up at the end.
    !
    INCR I FROM 1 TO .NC DO
	BEGIN
	IF .I LEQ .BUF_LEN THEN CH$WCHAR_A(CH$RCHAR(.L_POINT),BUF_POINT);
	MC_RIGHT();
	END;
    !
    ! If is is a backward delete, move back to the beginning.
    !
    IF .C_DIR EQL DIR_BACKWARD THEN DECR I FROM .NC-1 TO 0 DO MC_LEFT();
    END;

!+
! This routine is used to isolate the page and paragraph entities, which
! are based upon a search string which must be found.
!-

ROUTINE FIND_ENTITY(ENT,DIR,INC_DELIM) =
    BEGIN
    LOCAL
	SAVE_BEGIN,
	SUCCEED;
    !
    ! Temporarily put us in BEGIN mode, so we position to the beginning
    ! of the entity delimiter.
    !
    SAVE_BEGIN = .E_SBEGIN;
    E_SBEGIN = 1;
    !
    ! If searching backward, move back the length of the delimiter before
    ! starting.
    !
    IF .DIR EQL DIR_BACKWARD THEN
	INCR I FROM 0 TO CH$RCHAR(.ENT) DO MC_LEFT();
    !
    ! Do the search.
    !
    SUCCEED = FIND_STRING(CH$PTR(.ENT,1),CH$RCHAR(CH$PTR(.ENT)),0,.DIR);
    !
    ! Restore the BEGIN/END parameter.
    !
    E_SBEGIN = .SAVE_BEGIN;
    !
    ! Check to see whether or not it was found.  If not then move
    ! to the top or bottom depending on the direction.  In this case
    ! we want to fail if we are already at top or bottom.
    !
    IF .SUCCEED EQL 0 THEN
	BEGIN
	IF .DIR EQL DIR_BACKWARD THEN 
	    BEGIN
	    SUCCEED = MC_LEFT();
	    MC_TOP();
	    END
	ELSE 
	    BEGIN
	    SUCCEED = MC_RIGHT();
	    MC_BOTTOM();
	    END;
	END
    ELSE IF .SUCCEED EQL 1 THEN
	IF .INC_DELIM NEQ 0 THEN	! include the delimiter.
	    INCR I FROM 1 TO CH$RCHAR(.ENT) DO MC_RIGHT();
    RETURN .SUCCEED;
    END;

!+
! This routine executes verbs which take an entity specification.
! 
! First it isolates the text defined by the entity type and the entity
! count which are passed as parameters, then performs the verb on the
! selected text.  It then executes the verb on the text it has selected.
!
! ENTITY is the entity to use
! COUNT is the number of entities to include
! VERB is the command to execute.
!-

ROUTINE EXECUTE_VERB(ENTITY,COUNT,VERB) =
    BEGIN
    LOCAL
	START_POS : POS_BLOCK,	! Position of start of text.
	END_POS : POS_BLOCK,	! Position of end of text.
	ORIG_LNO,			! Original relative line.
	NUM_LINES,			! Number of lines in the range.
	SR,				! Set if range was a select range.
	NC,				! Number of characters included in this entity.
	SUCCEED;			! Set to zero if we hit a boundary.

    SUCCEED = 1;
    SR = 0;
    NC = 0;
    !
    ! Setup the search string if it is a quoted string.
    !
    IF .ENTITY EQL ENT_QUOTE THEN
	BEGIN
	U_S_STRING(.C_SADR,.C_SLEN);
	!
	! If the next command is advance or backup, set the direction now
	! so we can use the advance and backup keys to terminate the search
	! string like KED does.
	!
	IF CH$EQL(3,.C_POINT,3,UPLIT(%STRING('ADV'))) THEN
	    C_DIR = DIR_FORWARD
	ELSE IF CH$EQL(4,.C_POINT,4,UPLIT(%STRING('BACK'))) THEN
	    C_DIR = DIR_BACKWARD
	END;
    !
    ! To make the line, word, sent, etc entities work properly for deletes
    ! we must first move to the beginning of the entity.  This does not
    ! apply for moves.
    !
    IF .VERB NEQ VERB_MOVE THEN
	CASE .ENTITY/2 FROM ENT_WORD/2 TO ENT_PAGE/2 OF
	    SET
	    [ENT_LINE/2]: 
		L_POINT = CH$PTR(L_BUF);
	    [ENT_WORD/2]: 
		BEG_WORD(0);
	    [ENT_SEN/2]:
		BEG_SENT();
	    [ENT_PAGE/2,ENT_PAR/2]:
		BEGIN
		MC_RIGHT();
		FIND_ENTITY(.E_ENT[2+(.ENTITY EQL ENT_PAGE)],DIR_BACKWARD,1);
		END;
	    [INRANGE,OUTRANGE]:
    		0;
	    TES;
    !
    ! Save the original position in the buffer.
    !
    SAVE_POS(START_POS);
    ORIG_LNO = .C_LNO;
    !
    ! Loop over the entity count moving by one entity each time.
    !
    INCR I FROM 1 TO .COUNT DO
	BEGIN
	IF C_CHECK_CC() NEQ 0 THEN EXITLOOP;
	!
	! Process one entity of the specified type.
	!
	CASE .ENTITY + .C_DIR FROM 1 TO LAST_ENT+1 OF
	    SET

	    [ENT_CHAR+DIR_FORWARD]:
		BEGIN
		IF (SUCCEED = MC_RIGHT()) THEN NC = 1;
		END;

	    [ENT_CHAR+DIR_BACKWARD]:
		BEGIN
		IF (SUCCEED = MC_LEFT()) THEN NC = 1;
		END;

	    [ENT_VERT+DIR_FORWARD]:
		BEGIN
		IF .C_VERT EQL 0 THEN SC_NCOL();
		IF WF_EOB() THEN
		    SUCCEED = 0
		ELSE
		    BEGIN
		    MC_DOWN();
		    SC_MCOL();
		    END;
		C_VERT = 1;
		END;

	    [ENT_VERT+DIR_BACKWARD]:
		BEGIN
		IF .C_VERT EQL 0 THEN SC_NCOL();
		SUCCEED = MC_UP();
		SC_MCOL();
		C_VERT = 1;
		END;
    
	    [ENT_BW+DIR_FORWARD,ENT_BW+DIR_BACKWARD,ENT_WORD+DIR_BACKWARD]:
		BEGIN
		IF MC_LEFT() THEN
		    NC = BEG_WORD(0) + 1
		ELSE
		    SUCCEED = 0;
		C_DIR = DIR_BACKWARD;
		END;
    
	    [ENT_BSEN+DIR_FORWARD,ENT_BSEN+DIR_BACKWARD,ENT_SEN+DIR_BACKWARD]:
		BEGIN
		IF MC_LEFT() THEN
		    BEGIN
		    IF CH$RCHAR(.L_POINT) EQL CR THEN
			MC_LEFT()
		    ELSE
			WHILE CH$RCHAR(.L_POINT) EQL %C' ' DO MC_LEFT();
		    BEG_SENT();
		    END
		ELSE
		    SUCCEED = 0;
		C_DIR = DIR_BACKWARD;
		END;

	    [ENT_EW+DIR_FORWARD,ENT_EW+DIR_BACKWARD,ENT_WORD+DIR_FORWARD]:
		BEGIN
		IF WF_EOB() THEN
		    SUCCEED = 0
		ELSE
		    NC = END_WORD();
		C_DIR = DIR_FORWARD;
		END;

	    [ENT_SEN+DIR_FORWARD]:
		BEGIN
		IF WF_EOB() THEN
		    SUCCEED = 0
		ELSE
		    WHILE MC_RIGHT() DO IF SENT_DELIM(1) THEN EXITLOOP;
		END;

	    [ENT_ESEN+DIR_FORWARD,ENT_ESEN+DIR_BACKWARD]:
		BEGIN
		IF WF_EOB() THEN
		    SUCCEED = 0
		ELSE
		    WHILE MC_RIGHT() DO IF SENT_DELIM(0) THEN EXITLOOP;
		C_DIR = DIR_FORWARD;
		END;

	    [ENT_NL+DIR_FORWARD,ENT_NL+DIR_BACKWARD,ENT_LINE+DIR_FORWARD]:
		BEGIN
		IF WF_EOB() THEN
		    SUCCEED = 0
		ELSE
		    BEGIN
		    NC = CH$DIFF(.L_END,.L_POINT)+1;
		    SUCCEED = MC_DOWN();
		    END;
		END;

	    [ENT_EL+DIR_FORWARD]:
		BEGIN
		IF WF_EOB() THEN
		    SUCCEED = 0
		ELSE
		    BEGIN
		    NC = 0;
		    IF CH$PTR_EQL(.L_END,.L_POINT) THEN
			BEGIN
			MC_DOWN();
			NC = 1;
			END;
		    NC = .NC + CH$DIFF(.L_END,.L_POINT);
		    L_POINT = .L_END;
		    END;
		END;

	    [ENT_EL+DIR_BACKWARD]:
		BEGIN
		LOCAL
		    LEN;
		LEN = CH$DIFF(.L_POINT,CH$PTR(L_BUF));
		IF (SUCCEED = MC_UP()) THEN
		    BEGIN
		    NC = .LEN;
		    L_POINT = .L_END;
		    END;
		END;

	    [ENT_BL+DIR_FORWARD,ENT_BL+DIR_BACKWARD,ENT_LINE+DIR_BACKWARD]:
		BEGIN
		IF CH$PTR_EQL(.L_POINT,CH$PTR(L_BUF)) THEN
		    (IF (SUCCEED = MC_UP()) THEN NC = .L_LEN+1)
		ELSE
		    BEGIN
		    NC = CH$DIFF(.L_POINT,CH$PTR(L_BUF));
		    L_POINT = CH$PTR(L_BUF);
		    END;
		C_DIR = DIR_BACKWARD;
		END;

	    [ENT_PAGE+DIR_FORWARD,ENT_EPAGE+DIR_FORWARD,ENT_EPAGE+DIR_BACKWARD]:
		BEGIN
		SUCCEED = FIND_ENTITY(.E_ENT[3],DIR_FORWARD,.ENTITY EQL ENT_PAGE);
		C_DIR = DIR_FORWARD;
		END;

	    [ENT_PAR+DIR_FORWARD,ENT_EPAR+DIR_FORWARD,ENT_EPAR+DIR_BACKWARD]:
		BEGIN
		SUCCEED = FIND_ENTITY(.E_ENT[2],DIR_FORWARD,.ENTITY EQL ENT_PAR);
		C_DIR = DIR_FORWARD;
		END;

	    [ENT_PAGE+DIR_BACKWARD,ENT_BPAGE+DIR_BACKWARD,ENT_BPAGE+DIR_FORWARD]:
		BEGIN
		SUCCEED = FIND_ENTITY(.E_ENT[3],DIR_BACKWARD,1);
		C_DIR = DIR_BACKWARD;
		END;
    
	    [ENT_PAR+DIR_BACKWARD,ENT_BPAR+DIR_BACKWARD,ENT_BPAR+DIR_FORWARD]:
		BEGIN
		SUCCEED = FIND_ENTITY(.E_ENT[2],DIR_BACKWARD,1);
		C_DIR = DIR_BACKWARD;
		END;

	    [ENT_BR+DIR_FORWARD,ENT_BR+DIR_BACKWARD]:
		BEGIN
		MC_TOP();
		C_DIR = DIR_BACKWARD;
		END;

	    [ENT_ER+DIR_FORWARD,ENT_ER+DIR_BACKWARD]:
		BEGIN
		MC_BOTTOM();
		C_DIR = DIR_FORWARD;
		END;

	    [ENT_QUOTE+DIR_FORWARD,ENT_QUOTE+DIR_BACKWARD]:
		BEGIN
		IF (SUCCEED = FIND_STRING(U_SRCHSTR,.U_SLEN,1,.C_DIR)) THEN
		    IF .E_SBEGIN EQL 0 THEN DECR I FROM .U_SLEN-1 TO 0 DO MC_RIGHT();
		END;

	    [ENT_SR+DIR_FORWARD,ENT_SR+DIR_BACKWARD]:
		BEGIN
		IF .C_SBUF EQL .E_TBCB THEN
		    BEGIN
		    !
		    ! Determine the direction.
		    !
		    SELECTONE SEL_POS() OF
			SET
			[-1]: C_DIR = DIR_BACKWARD;
			[0]:  C_DIR = CH$PTR_LSS(.L_POINT,.C_SELP);
			[1]:  C_DIR = DIR_FORWARD
			TES;
		    !
		    ! Move up or down until we get to the right line.
		    !
		    WHILE 1 DO
			SELECTONE SEL_POS() OF
			    SET
			    [-1]: MC_UP();
			    [0]:  EXITLOOP;
			    [1]:  MC_DOWN()
			    TES;
		    !
		    ! Point to the selected position.
		    !
		    L_POINT = .C_SELP;
		    !
		    ! This should not happen, but is catastrophic if it
		    ! does, and I don't fix it!
		    !
		    IF CH$PTR_LSS(.L_END,.L_POINT) THEN L_POINT = .L_END;
		    !
		    ! And turn off the select range, now that we've used it.
		    !
		    C_SBUF = 0;
		    SR = .SR + 1;
		    EXITLOOP;
		    END
		ELSE
		    BEGIN
		    IF .E_SBEGIN EQL 0 THEN DECR I FROM .U_SLEN-1 TO 0 DO MC_LEFT();
		    IF (.COUNT EQL 1) AND (.U_SLEN GTR 0) AND
		       ON_STRING(U_SRCHSTR,.U_SLEN) THEN
			IF .E_SBEGIN NEQ 0 THEN
			    BEGIN
			    DECR I FROM .U_SLEN-1 TO 0 DO MC_RIGHT();
			    C_DIR = DIR_FORWARD;
			    END
			ELSE
			    C_DIR = DIR_BACKWARD
		    ELSE
			BEGIN
			IF .E_SBEGIN EQL 0 THEN DECR I FROM .U_SLEN-1 TO 0 DO MC_RIGHT();
			IF .VERB EQL VERB_CHGC THEN
			    IF .C_DIR EQL DIR_BACKWARD THEN MC_LEFT() ELSE MC_RIGHT()
			ELSE
			    BEGIN
			    C_BEEP(ERR_NOSELRAN);
			    RETURN 0;
			    END;
			END;
		    END;
		END;

	    TES;
	IF NOT .SUCCEED THEN EXITLOOP;
	END;

    ! If the verb was delete, then save the last entity in the proper
    ! save buffer.
    !
    IF .NC NEQ 0 AND
       (.VERB EQL VERB_DELETE OR .VERB EQL VERB_REPLACE) THEN

	CASE .ENTITY/2 FROM 0 TO ENT_EL/2 OF
	    SET
	    [ENT_CHAR/2]:
	    	BEGIN
		SAVE_TEXT(.NC,C_DCBUF,1);
	    	END;
	    [ENT_WORD/2,ENT_BW/2,ENT_EW/2]:
		BEGIN
		SAVE_TEXT(.NC,C_DWBUF,80);
		C_DWLEN = MIN(.NC,80);
		END;
	    [ENT_LINE/2,ENT_NL/2,ENT_BL/2,ENT_EL/2]:
		BEGIN
		SAVE_TEXT(.NC,C_DLBUF,256);
		C_DLLEN = MIN(.NC,256);
		END;
	    [INRANGE,OUTRANGE]:
	    	0;
	    TES;
    !
    ! If the entity was not VERT then turn off the vert flag.
    !
    IF .ENTITY NEQ ENT_VERT THEN
	C_VERT = 0;
    !
    ! Calculate the number of lines in the range.
    !
    NUM_LINES = .C_LNO - .ORIG_LNO;
    IF .NUM_LINES LSS 0 THEN NUM_LINES = -.NUM_LINES;
    NUM_LINES = .NUM_LINES + 1;
    !
    ! Now set up the start and end position blocks, and
    ! position to the front of the range.
    !
    IF .C_DIR EQL DIR_BACKWARD THEN
	BEGIN
	CH$MOVE(POS_SIZE,START_POS,END_POS);
	SAVE_POS(START_POS);
	END
    ELSE
	BEGIN
	SAVE_POS(END_POS);
	RE_POS(START_POS);
	END;

    !
    ! Now, execute the command.
    !
    CASE .VERB FROM VERB_MOVE TO VERB_APPEND OF
	SET

	[VERB_MOVE]:
	    BEGIN
	    IF (.C_SBUF EQLA .E_TBCB OR .ENTITY EQL ENT_SR)
	       AND .E_T_TYPE EQL TERM_VT100 THEN
		PROCESS_LINES(.NUM_LINES,START_POS,END_POS,MARK_CHANGE)
	    ELSE
		IF .C_DIR EQL DIR_FORWARD THEN
		    RE_POS(END_POS);
	    END;

	[VERB_CHGC]:
	    BEGIN
	    PROCESS_LINES(.NUM_LINES,START_POS,END_POS,PROCESS_CHGC);
	    IF .SR NEQ 0 THEN
		IF .C_DIR EQL DIR_BACKWARD THEN RE_POS(END_POS) ELSE RE_POS(START_POS);
	    END;

	[VERB_TADJ]:
	    BEGIN
	    INCR I FROM 1 TO .NUM_LINES - (.END_POS[POS_CHAR_POS] EQL 0) DO
		BEGIN
		DO_TADJ();
		MC_DOWN();
		END;
	    END;

	[VERB_DELETE,VERB_REPLACE]:
	    BEGIN
	    E_ABUF = 0;
	    DELETE_LINES(.NUM_LINES,CH$PTR(L_BUF,.END_POS[POS_CHAR_POS]));
	    IF .VERB EQL VERB_REPLACE THEN INSERT_MODE();
	    END;

	[VERB_FILL]:
	    BEGIN
	    MC_CHANGE();
	    SC_ZAP_SINFO(MAX(.C_LNO,0),23);
	    C_LNO = .C_LNO + FLL_FILL(.NUM_LINES - (.END_POS[POS_CHAR_POS] EQL 0));
	    MC_GET_LINE();
	    END;

	[VERB_CUT,VERB_APPEND]:
	    BEGIN
	    LOCAL
		SAVE_BUF;
	    IF .E_ABUF EQL 0 THEN RETURN 0;
	    IF .E_ABUF EQL .E_TBCB THEN
		BEGIN
		C_BEEP(ERR_ATTCUTAPP);
		RETURN 0;
		END;
	    SAVE_BUF = .E_TBCB;
	    E_TBCB = .E_ABUF;
	    IF .VERB EQL VERB_APPEND THEN WF_BOTTOM() ELSE WF_CLEAR();
	    WF_START_INSERT();
	    E_TBCB = .SAVE_BUF;
	    DELETE_LINES(.NUM_LINES,CH$PTR(L_BUF,.END_POS[POS_CHAR_POS]));
	    MC_CHANGE();
	    E_TBCB[TBCB_CHAR_POS] = CH$DIFF(.L_POINT,CH$PTR(L_BUF));
	    E_TBCB = .E_ABUF;
	    WF_R_CURRENT();
	    WF_END_INSERT();
	    !
	    ! If this is an append, combine first line appended with previous line.
	    !
	    IF .VERB EQL VERB_APPEND THEN
		BEGIN
		DECR I FROM .NUM_LINES-1 TO 0 DO WF_R_BACKWRD();
		MC_GET_LINE();
		IF WF_R_BACKWRD() THEN
		    IF .L_LEN + .W_LINE[LIN_LENGTH] LEQ 255 THEN
			BEGIN
			CH$MOVE(.L_LEN,CH$PTR(L_BUF),CH$PTR(L_BUF,.W_LINE[LIN_LENGTH]));
			CH$MOVE(.W_LINE[LIN_LENGTH],W_LINE[LIN_TEXT],CH$PTR(L_BUF));
			L_LEN = .L_LEN + .W_LINE[LIN_LENGTH];
			WF_DELETE_LINE();
			WF_REPLACE_LINE(L_BUF,.L_LEN);
			END;	    
		END;
	    E_TBCB = .SAVE_BUF;
	    MC_GET_LINE();
	    END;
	TES;

    IF .SUCCEED EQL 0 THEN
	C_BEEP(IF .ENTITY EQL ENT_QUOTE THEN ERR_STRNOTFND
	     ELSE IF .C_DIR EQL DIR_BACKWARD THEN ERR_TOPOFBUF
	     ELSE ERR_BOTOFBUF);

    RETURN .SUCCEED<0,1>;
    END;

!+
! This routine executes a command which is not of the verb entity form.
!
! Input parameters:
!
!	VERB	- The command number
!	COUNT	- The repeat count
!	OPERAND	- Pointer to start of operand for insert, insert_cc etc.
!-

ROUTINE EXECUTE_COM(VERB,COUNT,OPERAND,EXPLICIT) =
    BEGIN
    LOCAL
	SUCCEED;
    !
    ! If verb is substitute, setup the search and substitute strings.
    !
    IF .VERB EQL VERB_SUBS THEN
	U_S_SUBS(.C_SADR,.C_SLEN,.C_RADR,.C_RLEN);
    SUCCEED = 1;
    DO
	BEGIN
	CASE .VERB FROM VERB_SEL TO LAST_VERB OF
	    SET

	    [VERB_UNDC]:
		BEGIN
		SUCCEED = UNDELETE(C_DCBUF,1);
		END;
    
	    [VERB_UNDW]:
		BEGIN
		SUCCEED = UNDELETE(C_DWBUF,.C_DWLEN);
		END;
    
	    [VERB_UNDL]:
		BEGIN
		SUCCEED = UNDELETE(C_DLBUF,.C_DLLEN);
		END;
    
	    [VERB_INSERT]:
		BEGIN
		SUCCEED = INSERT_STRING(.OPERAND,.C_SLEN);
		IF .SUCCEED THEN
		    BEGIN
		    !
		    ! Check for word wrapping.
		    !
		    IF .E_WRAP NEQ 256 THEN
			BEGIN
			LOCAL
			    SAVE_POINT,
			    LINE,
			    DIFF,
			    COL;
			!
			! Compute the current cursor position.
			!
			SC_COMP_CURSOR(LINE,COL);
			IF .COL GTR .E_WRAP THEN
			    BEGIN
			    SAVE_POINT = .L_POINT;
			    MC_LEFT();
			    IF CH$RCHAR(.L_POINT) EQL %C' ' THEN
				MC_RIGHT()
			    ELSE
				BEG_WORD(1);
			    DIFF = CH$DIFF(.SAVE_POINT,.L_POINT);
			    IF CH$PTR_NEQ(.L_POINT,CH$PTR(L_BUF)) THEN
				SPLIT_LINE(1);
			    L_POINT = CH$PLUS(.L_POINT,.DIFF);
			    END;
			END;
		    END;
		END;
    
	    [VERB_CC]:
		BEGIN
		SUCCEED = INSERT_STRING(%REF(CH$RCHAR(.OPERAND)-%C'@'),1);
		END;
    
	    [VERB_BACK]:
		BEGIN
		C_DMODE = DIR_BACKWARD;
		EXITLOOP;
		END;

	    [VERB_ADV]:
		BEGIN
		C_DMODE = DIR_FORWARD;
		EXITLOOP;
		END;

	    [VERB_EXIT,VERB_QUIT]:
		BEGIN
		C_EXIT = 1;
		IF .VERB EQL VERB_QUIT THEN E_EXITED = 1;
		RETURN 1;
		END;
    
	    [VERB_PASTE]:
		BEGIN
		SUCCEED = DO_PASTE();
		END;
    
	    [VERB_SEL]:
		BEGIN
		IF .C_SBUF NEQ 0 THEN
		    C_BEEP(ERR_SELALRACT)
		ELSE
		    BEGIN
		    MOVELINE(E_TBCB[TBCB_CUR_LIN],C_SELL);
		    C_SBUF = .E_TBCB;
		    C_SELP = .L_POINT;
		    END;
		EXITLOOP;
		END;
    
	    [VERB_REF]:
		BEGIN
		SC_INIT();
		EXITLOOP;
		END;

	    [VERB_DEFK]:
		BEGIN
		DEFINE_KEY();
		EXITLOOP;
		END;

	    [VERB_TOP]:
		BEGIN
		MOVELINE(E_TBCB[TBCB_CUR_LIN],C_TOP);
		EXITLOOP;
		END;
    
	    [VERB_HELP]:
		BEGIN
		SC_NOREV();
		SYS_EWORK();
		HLP_KEYPAD();
		P_LNO = 999;	! Make sure it positions before writing.
		SC_ZAP_SINFO(0,23);
		EXITLOOP;		    
		END;
    
	    [VERB_ASC]:
		BEGIN
		INSERT_CHARS(%REF(.COUNT),1);
		EXITLOOP;
		END;
    
	    [VERB_SUBS,VERB_SN]:
		BEGIN
		SUCCEED = DO_SUBS(.C_DIR);
		END;
    
	    [VERB_KS]: ! Adjust for KED substitute.
		BEGIN
		IF .C_DIR EQL DIR_BACKWARD THEN
		    DECR I FROM .C_PSTC-1 TO 0 DO MC_LEFT()
		ELSE
		    MC_LEFT();
		END;

	    [VERB_SHL]:
		BEGIN
		C_SHFT = .C_SHFT + 8;
		IF .C_SHFT GEQ 255 THEN C_SHFT = 0;
		SC_ZAP_SINFO(0,23);
		END;
    
	    [VERB_SHR]:
		BEGIN
		C_SHFT = .C_SHFT - 8;
		IF .C_SHFT LSS 0 THEN C_SHFT = 0;
		SC_ZAP_SINFO(0,23);
		END;

	    [VERB_TAB]:
		BEGIN
		LOCAL
		    TAB_COUNT;
		IF CH$PTR_NEQ(.L_POINT,CH$PTR(L_BUF)) OR
		   .E_TAB EQL 0 THEN
		    TAB_COUNT = 8
		ELSE
		    TAB_COUNT = .E_TLEV*.E_TAB;
		SUCCEED = INSERT_TABS(.TAB_COUNT);
		END;

	    [VERB_TC]:
		BEGIN
		LOCAL
		    COL,
		    LIN;
		IF .E_TAB EQL 0 THEN EXITLOOP;
		SC_COMP_CURSOR(LIN,COL);
		IF .COL MOD .E_TAB NEQ 0 THEN 
		    C_BEEP(ERR_CLDNOTALN)
		ELSE
		    E_TLEV = .COL/.E_TAB;
		EXITLOOP;
		END;

	    [VERB_TD]:
		BEGIN
		E_TLEV = MAX(0,.E_TLEV-1);
		END;

	    [VERB_TI]:
		BEGIN
		E_TLEV = .E_TLEV+1;
		END;

	    [VERB_EXT]:
		BEGIN
		SYS_EWORK();
		SC_NOSCR();
		SC_CURSOR(23,0);
		F_PUT();
		F_WRITE(IO_WT);
		F_LITERAL(UPLIT(%STRING(%CHAR(LF))),1);
		MC_CHANGE();
		TI_CLEAR_AUDIT();
		E_TBCB[TBCB_CHAR_POS] = CH$DIFF(.L_POINT,CH$PTR(L_BUF));
		E_EXT();
		F_CUR = F_BUF;
		P_LNO = 999;
		IF .E_T_TYPE EQL TERM_VT52 OR
		   .E_T_TYPE EQL TERM_VT100 THEN
		    F_WRITE(IO_WTU);
		MC_GET_LINE();
		L_POINT = CH$PTR(L_BUF,.E_TBCB[TBCB_CHAR_POS]);
		SC_SCRREG();
		IF .E_SCRCHG NEQ 0 THEN (C_LNO = 999; SC_INIT()); ! Force full screen update.
		EXITLOOP;
		END;
	    TES;

	IF C_CHECK_CC() THEN EXITLOOP;
	IF .EXPLICIT NEQ 0 THEN
	    COUNT = .COUNT - 1;
	IF .SUCCEED EQL 0 THEN EXITLOOP;
	END
    UNTIL .COUNT LEQ 0;
    !
    ! Unless the command was advance or backup, turn off the C_VERT flag.
    !
    IF .VERB NEQ VERB_ADV AND .VERB NEQ VERB_BACK THEN
	C_VERT = 0;

    .SUCCEED
    END;

!+
! PAREN_COM
!
! This routine implements a parenthesized string of commands.  The
! string is analyzed without execution in order to verify it syntactically,
! and find the end of the string.  It is then executed COUNT times, or until
! a command in the string fails.  In either case, com_point is left pointing
! at the first character after the parenthesized command list.
!-

ROUTINE PAREN_COM(COUNT,EXECUTE) : NOVALUE =
    BEGIN
    LOCAL
	SUCCEED,
	COM_END,
	COM_START;
    C_POINT = COM_START = CH$PLUS(.C_POINT,1);
    PARSE_COM(0);
    COM_END = .C_POINT;
    IF CH$RCHAR(.COM_END) NEQ %C')' THEN
	BEGIN
	C_BEEP(ERR_PARENMIS);
	RETURN 0;
	END;
    IF .EXECUTE THEN
	DECR I FROM .COUNT-1 TO 0 DO
	    BEGIN
	    IF C_CHECK_CC() THEN RETURN;
	    C_POINT = .COM_START;
	    IF NOT PARSE_COM(1) THEN 
		EXITLOOP;
	    END;
    C_POINT = CH$PLUS(.COM_END,1);
    END;

!+
! This little routine looks for an explicit direction indicator (+ or -)
! and sets C_DIR accordingly.  If no direction is seen, C_DIR is left
! unchanged.
!-

ROUTINE GET_DIRECTION : NOVALUE =
    BEGIN
    IF CH$RCHAR(.C_POINT) EQL %C'-' THEN
	C_DIR = DIR_BACKWARD
    ELSE IF CH$RCHAR(.C_POINT) EQL %C'+' THEN
	C_DIR = DIR_FORWARD
    ELSE RETURN;
    C_POINT = CH$PLUS(.C_POINT,1);
    END;

!+
! This routine looks for a repeat/entity count, and stores it in the
! formal parameter COUNT.
!
! A value of 1 is returned if an explicit count was seen, 0 otherwise.
!-

ROUTINE GET_COUNT(COUNT) =
    BEGIN
    !
    ! **** Insert code here for handling of expressions in repeat counts.
    !
    IF NOT U_DIGIT(.C_POINT) THEN RETURN 0;
    .COUNT = 0;
    WHILE U_DIGIT(.C_POINT) DO
	.COUNT = ..COUNT * 10 + CH$RCHAR_A(C_POINT) - %C'0';
    RETURN 1
    END;

!+
! This routine scans over the string of characters to be inserted by
! an insert command.
!
! An insert string is delimited by either a CTRL/Z character, or the printable
! equivalent of ^Z or ^z.
!
! The command pointer C_POINT is left pointing one character beyond the command.
!-

ROUTINE GET_INSERT_STR : NOVALUE =
    BEGIN
    C_SLEN = 0;
    WHILE 1 DO
	BEGIN
	IF CH$PTR_EQL(.C_POINT,.C_END) THEN
	    BEGIN
	    INSERT_MODE();
	    EXITLOOP;
	    END;
	IF CH$RCHAR(.C_POINT) EQL CTRL_Z THEN
	    BEGIN
	    C_POINT = CH$PLUS(.C_POINT,1);
	    EXITLOOP;
	    END;
	IF CH$RCHAR(.C_POINT) EQL %C'^' AND
	  (CH$RCHAR(CH$PTR(.C_POINT,1)) EQL %C'Z' OR
	   CH$RCHAR(CH$PTR(.C_POINT,1)) EQL %C'z') THEN
	    BEGIN
	    C_POINT = CH$PLUS(.C_POINT,2);
	    EXITLOOP;
	    END;
	C_POINT = CH$PLUS(.C_POINT,1);
	C_SLEN = .C_SLEN + 1;
	END;
    END;

!+
! This routine isolates the search and replace strings for the substitute
! command.
!
! The length and address of the search and replace strings respectively
! are placed in the global variables: C_SLEN, C_SADR, C_RLEN and C_RADR.
!
! The command line pointer C_POINT is left pointing 1 character beyond the
! command.
!-

ROUTINE GET_SUBS_STR : NOVALUE =
    BEGIN
    LOCAL
	QUOTE,
	R_ADDR,
	R_LEN;
    QUOTE = CH$RCHAR_A(C_POINT);
    C_SADR = .C_POINT;
    C_SLEN = 0;
    WHILE CH$PTR_GTR(.C_END,.C_POINT) AND
	  CH$RCHAR_A(C_POINT) NEQ .QUOTE DO
	C_SLEN = .C_SLEN + 1;
    C_RADR = .C_POINT;
    C_RLEN = 0;
    WHILE CH$PTR_GTR(.C_END,.C_POINT) AND
	  CH$RCHAR_A(C_POINT) NEQ .QUOTE DO
	C_RLEN = .C_RLEN + 1;
    END;

!+
! This routine scans over the search string when used as an entity.
! The address of the string is placed in the global variable C_SADR
! and the length in C_SLEN.
!
! The command pointer C_POINT is left pointing one character beyond the
! end of the command.
!-

ROUTINE GET_QUOTE_STR : NOVALUE =
    BEGIN
    LOCAL
	QUOTE_CHAR;
    !
    ! The quote character is one character back, get it so we can match.
    !
    C_SADR = .C_POINT;
    C_SLEN = 0;
    QUOTE_CHAR = CH$RCHAR(CH$PLUS(.C_POINT,-1));
    WHILE CH$PTR_NEQ(.C_POINT,.C_END) AND
	  CH$RCHAR_A(C_POINT) NEQ .QUOTE_CHAR DO C_SLEN = .C_SLEN + 1;
    END;

!+
! This routine scans a table of keywords, attempting to find a match
! in the current command buffer pointed to by C_POINT.
!-

ROUTINE KEY_WORD(TABLE) =
    BEGIN
    LOCAL
	C,
	LEN,
	KW_POINTER,
	C_POINTER,
	KW_NUM,
	FOUND;
    KW_POINTER = CH$PTR(.TABLE,0);
    DO
	BEGIN
	FOUND = 1;
	LEN = CH$RCHAR_A(KW_POINTER);
	IF .LEN EQL 0 THEN
	    RETURN 0;
	KW_NUM = CH$RCHAR_A(KW_POINTER);
	C_POINTER = .C_POINT;
	IF CH$PTR_GTR(CH$PLUS(.C_POINTER,.LEN),.C_END) THEN
	    BEGIN
	    FOUND = 0;
	    KW_POINTER = CH$PLUS(.KW_POINTER,.LEN);
	    END
	ELSE
	    INCR I FROM 1 TO .LEN DO
		BEGIN
		C = CH$RCHAR_A(C_POINTER);
		IF .C GEQ %C'a' THEN C = .C - %C'a' + %C'A';
		IF .C NEQ CH$RCHAR_A(KW_POINTER) THEN
		    FOUND = 0;
		END;
	END
    UNTIL .FOUND;
    C_POINT = CH$PLUS(.C_POINT,.LEN);

    RETURN .KW_NUM;
    END;

!+
! This routine looks for a buffer spec for use by cut paste and append.
! If an '=' is seen, an explicit buffer spec is there, otherwise, use
! the paste buffer.  The routine places the address of the buffer in
! E_ABUF, with a zero indicating failure.
!-

ROUTINE GET_BUFFER : NOVALUE =
    BEGIN
    LOCAL
	SAVE_TBCB,
	NEW,
	NAME_LEN,
	NAME_START;
    NAME_LEN = 0;
    IF CH$RCHAR(.C_POINT) EQL %C'=' THEN
	BEGIN
	C_POINT = CH$PLUS(.C_POINT,1);
	NAME_START = .C_POINT;
	WHILE CH$PTR_LSS(.C_POINT,.C_END) DO
	    BEGIN
	    IF (NOT U_LETDIG(.C_POINT)) AND (CH$RCHAR(.C_POINT) NEQ %C'_')
		THEN EXITLOOP;
	    NAME_LEN = .NAME_LEN + 1;
	    C_POINT = CH$PLUS(.C_POINT,1);
	    END;
	IF .NAME_LEN EQL 0 OR NOT U_LETTER(.NAME_START) THEN
	    BEGIN
	    C_BEEP(ERR_INVBUFNAM);
	    RETURN;
	    END;
	U_CVTCASE(.NAME_START,.NAME_LEN);
	SAVE_TBCB = .E_TBCB;
	IF U_F_BUFFER(.NAME_START,.NAME_LEN) THEN
	    E_ABUF = .E_TBCB
	ELSE
	    C_BEEP(ERR_INSMEM);
	E_TBCB = .SAVE_TBCB;
	WF_R_CURRENT();
	END
    ELSE
	E_ABUF = .E_PASTE_TBCB;
    END;

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine parses and executes a change mode command string.
!
! FORMAL PARAMETERS:
!
!	EXECUTE - 1 if we should execute the command, 0 to parse only.
!
! IMPLICIT INPUTS:
!
!	C_BUF	- Command buffer
!	C_POINT	- Pointer to next character in command buffer
!	C_END	- Pointer to end of command buffer
!	
!	State variables too numerous to mention
!
! IMPLICIT OUTPUTS:
!
!	Practically everything
!
! RETURNED VALUE:
!
!	0 - Command failed
!	1 - Command succeeded
!
! SIDE EFFECTS:
!
!	Many
!
!--

ROUTINE PARSE_COM(EXECUTE) =
    BEGIN
    LOCAL
	REPT_COUNT,
	EXPLICIT_REPEAT,
	VERB,
	ENTITY,
	ENTITY_COUNT,
	OPERAND;
    !
    ! Loop until we hit the end of the command buffer or a closing parenthesis.
    !
    WHILE CH$PTR_GTR(.C_END,.C_POINT) DO
	BEGIN
	IF C_CHECK_CC() THEN RETURN 0;
	!
	! Skip blanks at beginning of command.
	!
	WHILE CH$RCHAR(.C_POINT) EQL %C' ' DO C_POINT = CH$PLUS(.C_POINT,1);
	!
	! Look for closing paren.
	!
	IF CH$RCHAR(.C_POINT) EQL %C')' THEN EXITLOOP;
	!
	! Set default direction.  And zero the alternate buffer.
	!
	C_DIR = .C_DMODE;
	E_ABUF = 0;
	!
	! Check for explicit direction specified.
	!
	GET_DIRECTION();
	!
	! Look for a count, and remember whether one was seen.
	!
	REPT_COUNT = 0;
	EXPLICIT_REPEAT = GET_COUNT(REPT_COUNT);
	!
	! Look for the loop.
	!
	IF CH$RCHAR(.C_POINT) EQL %C'(' THEN
	    BEGIN
	    IF .REPT_COUNT EQL 0 AND .EXPLICIT_REPEAT EQL 0 THEN
		REPT_COUNT = 1;
	    PAREN_COM(.REPT_COUNT,.EXECUTE);
	    END
	ELSE
	    BEGIN
	    !
	    ! And now, find the verb of the command.
	    !
	    VERB = KEY_WORD(COM_KEY_WORDS);
	    !
	    ! This hack prevents the entities SEN and SR from being assumed
	    ! to be a substitute command.
	    !
	    IF .VERB EQL VERB_SUBS THEN 
		IF U_LETTER(.C_POINT) THEN 
		    BEGIN
		    VERB = 0;
		    C_POINT = CH$PLUS(.C_POINT,-1);
		    END;
	    !
	    ! Check to see if it is truly a verb which uses an entity specification.
	    !
	    IF .VERB LSS VERB_SEL THEN
		BEGIN
		!
		! And once again, look for the explicit direction.
		!
		GET_DIRECTION();
		!
		! Set the entity count to the default of 1, then see if there
		! was a count specified.
		!
		ENTITY_COUNT = 1;
		GET_COUNT(ENTITY_COUNT);
		!
		! And try for a direction once again.
		!
		GET_DIRECTION();
		!
		! Now get the entity.
		!
		ENTITY = KEY_WORD(ENT_KEY_WORDS);
		!
		! If entity was not found, something is wrong.
		!
		IF .ENTITY EQL 0 THEN
		    !
		    ! If verb was defaulted to move, assume it was wrong, otherwise
		    ! it must be the entity which is wrong.
		    !
		    BEGIN
		    IF .VERB NEQ 0 THEN
			C_BEEP(ERR_INVENT)
		    ELSE
			C_BEEP(ERR_INVSUBCOM);
		    RETURN 0;
		    END;
		!
		! If the command is tabs adjust, then process it specially.
		! The repeat count and direction are used to determine the
		! adjustment and the entity count and direction to select the
		! text.
		!
		IF .VERB EQL VERB_TADJ THEN
		    BEGIN
		    IF .EXPLICIT_REPEAT EQL 0 THEN REPT_COUNT = 1;
		    E_TADJ = .REPT_COUNT;
		    IF .C_DIR EQL DIR_BACKWARD THEN E_TADJ = -.E_TADJ;
		    C_DIR = .C_DMODE;
		    EXPLICIT_REPEAT = 0;
		    END;
		!
		! If there was a repeat count as well as an entity count, multiply
		! them out to get the actual number of entities, and only execute
		! the command once.
		!
		IF .EXPLICIT_REPEAT THEN
		    ENTITY_COUNT = .REPT_COUNT * .ENTITY_COUNT;
		REPT_COUNT = 1;
		!
		! If entity is quoted, get the string.
		!
		IF .ENTITY EQL ENT_QUOTE THEN
		    GET_QUOTE_STR();
		!
		! Get the buffer spec if command is cut or append.
		!
		IF .VERB GEQ VERB_CUT THEN GET_BUFFER();
		!
		! And execute it.
		!
		IF .EXECUTE THEN 
		    IF NOT EXECUTE_VERB(.ENTITY,.ENTITY_COUNT,.VERB) THEN
			RETURN 0;
		END
	    ELSE
		BEGIN
		!
		! Handle the parsing of the 'funny' verbs, i.e. those which have
		! variable length strings as a part.
		!
		OPERAND = .C_POINT;
		CASE .VERB FROM VERB_SUBS TO VERB_CC OF
		    SET
		    [VERB_INSERT]:
			GET_INSERT_STR();
		    [VERB_SUBS]:
			GET_SUBS_STR();
		    [VERB_CC]:
			BEGIN
			U_CVTCASE(.C_POINT,1);
			C_POINT = CH$PLUS(.C_POINT,1);
			END;
		    [VERB_PASTE]:
			GET_BUFFER();
		    [OUTRANGE]:
			0;
		    TES;
		!
		! Now, execute the command, and terminate the loop if it fails.
		!
		IF .EXECUTE THEN 
		    IF NOT EXECUTE_COM(.VERB,.REPT_COUNT,.OPERAND,.EXPLICIT_REPEAT) THEN 
			RETURN 0;
		END;
	    END;
	IF .C_EXIT THEN RETURN 1;
	END;
    RETURN 1
    END;  ! Of C_COM

!+
! This routine returns a value of 1 if we are currently positioned at the
! end of a line and not at the end of the buffer.
!-

GLOBAL ROUTINE C_EOL =
    BEGIN
    RETURN CH$PTR_EQL(.L_POINT,.L_END) AND
	   NOT WF_EOB();
    END;

!+
! This routines determines whether or not an optimization for terminal
! input can be done.  If we are currently positioned at the end of a line,
! then it is possible to let the terminal driver do the echoing of printable
! characters for us up to the input of a character which may be a definable
! key.  This is much more efficient than the single character input with no
! echo which is normally done.  This routine checks a whole series of conditions
! which must be met before this is possible, then comes up with the number of
! characters which can be read with echo.  If this is non-zero, then a special
! read routine is called to do the input.  If the input is terminated by an
! escape or control character, that character will be put in the type-ahead
! character, so it is the next character returned by a TI_CHAR.
!-

GLOBAL ROUTINE C_E_INPUT =
    BEGIN
    LOCAL
	BUF_LEFT,
	NUM_CHARS,
	READ;
    !
    ! We can only do this in keypad mode.
    !
    IF NOT .E_KEYPAD THEN RETURN 0;
    !
    ! If we are on the last line, the echo of a line-feed will screw up the
    ! screen, so don't do it.
    !
    IF .C_LNO EQL .E_SLIN-1 THEN RETURN 0;
    !
    ! If we are to the left of the shifted screen don't do it.
    !
    IF .C_CCOL LEQ .C_SHFT THEN RETURN 0;
    !
    ! If in recovery mode don't do it.
    !
    IF .E_RECOVER THEN RETURN 0;
    !
    ! If not at end of line, don't do it.
    !
    IF NOT C_EOL() THEN RETURN 0;
    !
    ! Finally, it looks possible.  Compute the number of character left on the
    ! line.
    !
    NUM_CHARS = .E_T_WIDTH - 1;
    !
    ! If we are in wrap mode, make sure we get control at the wrap column.
    !
    IF .E_WRAP LSS .NUM_CHARS THEN NUM_CHARS = .E_WRAP;
    !
    ! Subtract the current cursor position.
    !
    NUM_CHARS = .NUM_CHARS - .C_CCOL;
    !
    ! Make sure there is enough room left in the line buffer.
    !
    BUF_LEFT = 255-CH$DIFF(.L_POINT,L_BUF);
    IF .BUF_LEFT LSS .NUM_CHARS THEN NUM_CHARS = .BUF_LEFT;
    !
    ! Now, if we have a non_zero size, we can read with echo.
    !
    IF .NUM_CHARS LEQ 0 THEN
	RETURN 0;
    !
    ! Make sure the video attributes are right.
    !
    IF .C_SBUF EQL .E_TBCB THEN IF SEL_POS() LEQ 0 THEN SC_REV() ELSE SC_NOREV();
    !
    ! Put out a carriage return to make the terminal driver think we are at the
    ! beginning of a line, then reposition the cursor.  (UGLY KLUDGE TO GET AROUND
    ! DRIVER PROBLEMS)
    !
    F_LITERAL(UPLIT(%STRING(%CHAR(CR))),1);
    SC_FCURSOR(.C_CLIN,.C_CCOL);
    !
    ! Do the special read with echo.
    !
    IO_REC(.L_POINT,.NUM_CHARS,READ);
    !
    ! Add the number of characters read to the line size.
    !
    NEW_LENGTH(.READ);
    !
    ! If we actually read some characters then, save the new text in the
    ! journal file, and update the cursor position.
    !
    IF .READ NEQ 0 THEN
	BEGIN
	P_COL = .P_COL + .READ;
	C_CHG = 1;
	TI_CLEAR_AUDIT();
	E_PUT_AUDIT(.L_POINT,.READ);
	C_VERT = 0;
	END;
    !
    ! Update the current character pointer.
    !
    L_POINT = CH$PLUS(.L_POINT,.READ);
    RETURN 1
    END;

!+
! This is the initialization routine called when change mode is entered.
!
! The following are done:
!
! The current line is fetched into the line buffer and the cursor pointer
! is initialized.
!
! The exit flag is cleared.
!
! The vertical flag is cleared.
!
! The type ahead flag is cleared.
!-

ROUTINE C_INIT : NOVALUE =
    BEGIN
    MC_GET_LINE();
    L_POINT = CH$PTR(L_BUF,.E_TBCB[TBCB_CHAR_POS]);
    C_EXIT = 0;
    C_VERT = 0;
    K_RAH = 0;
    END;

!+
! This is the main routine for change mode execution.  First we initialize
! for change mode, then execute any change mode commands on the current
! command line.  After we have finished with them, we check to see if an
! exit was done and if so get out.  Otherwise we enter into the change mode
! command loop, getting commands and executing them until an exit is done.
!-

GLOBAL ROUTINE C_MODE : NOVALUE =
    BEGIN
    C_INIT();
    !
    ! Execute remainder of command line if there is a semicolon.
    !
    IF CH$RCHAR(.C_POINT) NEQ %C'!' THEN 
	 PARSE_COM(1);
    !
    ! If an exit command was seen, get out now.
    !
    IF .C_EXIT THEN 
	BEGIN
	MC_CHANGE();
	RETURN;
	END;
    !
    ! Before entering the command loop, make sure the input is either coming
    ! from the terminal or from a recovery file.  We do not allow the startup
    ! file or macros to enter change mode.
    !
    IF .E_I_SOURCE NEQ INP_TERM AND
       NOT .E_RECOVER OR .E_T_TYPE EQL TERM_UNKNOWN THEN
	BEGIN
	SY_GET_MESS(ERR_CHGMODTER);
	F_PUT();
	RETURN;
	END;
    C_LNO = 999;
    !
    ! Set up for change mode editing.
    !
    IF .E_T_TYPE EQL TERM_VT52 OR
       .E_T_TYPE EQL TERM_VT100 THEN
	BEGIN
	F_WRITE(IO_WTU);
	SC_INIT();
	END;
    !
    ! Now loop through, getting commands until an exit is seen.
    !
    DO
	BEGIN
	!
	! Check for a hardcopy terminal.
	!
	IF .E_T_TYPE EQL TERM_HCPY THEN
	    BEGIN
	    !
	    ! Hard copy change mode.  Type the current line with the cursor
	    ! bracketed.
	    !
	    IF WF_EOB() THEN
		F_STRING(UPLIT(%STRING('[EOB]')),5)
	    ELSE
		BEGIN
		F_STRING(L_BUF,CH$DIFF(.L_POINT,CH$PTR(L_BUF)));
		F_CHAR('[');
		F_CHAR(CH$RCHAR(.L_POINT));
		F_CHAR(']');
		IF CH$PTR_NEQ(.L_POINT,.L_END) THEN
		    F_STRING(CH$PLUS(.L_POINT,1),CH$DIFF(.L_END,.L_POINT)-1);
		END;
	    F_PUT();
	    !
	    ! Now get the next command string.
	    !
	    IF .E_RECOVER EQL 1 THEN
		BEGIN
		LOCAL
		    LINE;
		IF IO_GET(SY_COM_RAB,LINE,C_LEN) EQL 0 THEN
		    E_S_AUDIT()
		ELSE
		    BEGIN
		    CH$MOVE(.C_LEN,.LINE,C_BUF);
		    IF .C_LEN EQL 2 THEN
			IF CH$RCHAR(CH$PTR(C_BUF)) EQL %C'^' THEN
			    IF CH$RCHAR(CH$PTR(C_BUF,1)) EQL %C'Z' OR
			       CH$RCHAR(CH$PTR(C_BUF,1)) EQL %C'z' THEN
				C_EXIT = 1;
		    END;
		END;
	    IF .E_RECOVER EQL 0 THEN
		BEGIN
		C_EXIT = IO_COM(UPLIT BYTE(13,10,'C*'),4,C_BUF,C_LEN,255);
		E_PUT_AUDIT(C_BUF,.C_LEN);
		END;
	    C_END = CH$PTR(C_BUF,.C_LEN);
	    END
	ELSE
	    BEGIN
	    !
	    ! Set up the command echo line.
	    !
	    TI_START_ECHO();
	    !
	    ! Check for characters in type ahead.  Do not update if there
	    ! are more characters to handle.
	    !
	    IF NOT TI_TYPE_AHEAD() THEN
		BEGIN
		!
		! Update the screen.
		!
		SC_UPDATE();
		!
		! Check for the optimized input applying.
		!
		IF NOT C_E_INPUT() THEN C_CURSOR(.C_CLIN,.C_CCOL);
		END;
	    !
	    ! Check for a CTRL/C abort, and if there was one, put out the message
	    ! and turn the flag off again.
	    !
	    IF .E_CC THEN
		BEGIN
		C_BEEP(ERR_ABOBYCC);
		E_CC = 0;
		END;
	    !
	    ! Get the next command string.
	    !
	    C_POINT = CH$PTR(C_BUF);
	    C_END = CH$PTR(C_BUF,256);
	    KEY_COM();
	    !
	    ! Start up the 'working' AST.
	    !
	    SYS_WORK();
	    END;
	!
	! Execute the command string in C_BUF.
	!
	C_POINT = CH$PTR(C_BUF);
	PARSE_COM(1);
	!
	! Turn off the working AST.
	!
	SYS_EWORK();
	END
    UNTIL .C_EXIT NEQ 0;
    MC_CHANGE();
    !
    ! Clean up after ourselves.
    !
    ! First, flush the journal file buffer.
    !
    TI_CLEAR_AUDIT();
    !
    ! Reset the terminal as required.
    !
    IF .E_T_TYPE NEQ TERM_HCPY THEN SC_RESET();
    !
    ! Reset the formatted write routine for line mode.
    !
    F_WRITE(IO_WT);
    E_TBCB[TBCB_CHAR_POS] = CH$DIFF(.L_POINT,CH$PTR(L_BUF));
    C_POINT = CH$PTR(C_BUF);
    CH$WCHAR('!',.C_POINT);
    END;


END
ELUDOM
