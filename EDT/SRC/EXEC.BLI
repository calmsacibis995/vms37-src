MODULE EXEC(IDENT='V03-000') =

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY: EDT Version 2
!
! FUNCTIONAL DESCRIPTION:
!
!	This module contains the code to execute an EDT command.
!
! ENVIRONMENT: User mode
!
! AUTHOR: Bob Kushlis, CREATION DATE: 3-Feb-1978
!
! MODIFIED BY:
!
! Bob Kushlis, 14-JUL-1979
!	Put in code for SET SCROLL.
!
! Bob Kushlis, 19-JUL-1979
!	Change prompt for input mode to include <CR> <LF>
!
! Dan Szymanski, 21-JUL-80, 04
!	Show Key case in SHOW_COM modified to handle expanded key
!	definition capability.
!
! Dan Szymanski, 08-OCT-80, 05
!	EXIT_COM changed to ignore an EXIT command seen while recovering.
!
! Dan Szymanski, 14-NOV-80, 06
!	In QUERY, the IO_COM prompt changed from '?' to CR, LF, '?'.
!	IO_COM specifies this is the format of the parameter and accounts
!	for the unusual behavior on RSTS, i.e. no prompt seen.
!	Also, the response buffer QUERY_RESP made larger to avoid
!	improper error recovery if more than one character is typed in
!	response to the Query option prompt.
!
! Dan Szymanski, 14-NOV-80, 07
!	VERIFY command removed.
!
! Dan Szymanski, 17-NOV-80, 08
!	The statement E_TXT = .E_TXT + 1 added after a number of F_PUT
!	calls so that when executed from change mode, the message is not
!	lost.  Routines affected were DELETE, SUBS_COM, WRITE_FILE,
!	MOVE_COM, and RES_COM.
!
! Dan Szymanski, 17-NOV-80, 09
!	IF E_I_SOURCE changed to IF .E_I_SOURCE in INSERT.
!
! Dan Szymanski, 20-NOV-80, 10
!	Routine QUERY modified so that when multiple substitutions are
!	possible on the same line, the line printed before the QUERY
!	prompt reflects any substitutions already made on the line.
!
! Dan Szymanski, 09-DEC-80, 11
!	The changes made in 08 introduced unexpected disagreement with
!	existing documentation and practically destroyed macros by
!	requiring many commonly used commands to be followed by carriage
!	returns even when informational messages were not wanted.  The
!	08 changes were removed.
!--
BEGIN
LIBRARY 'EDT';

PSECTS

FORWARD ROUTINE
    F_LNO:		NOVALUE,	! Format a line number for printing
    F_COUNT:		NOVALUE,	! Format a count for printing
    X_PRINT,				! Display the current line
    INSERT:		NOVALUE,	! Insert text
    INS_COM:		NOVALUE,	! Process the INSERT command
    QUERY,				! Process the QUERY qualifier
    DELETE,				! Delete a range of lines
    DEL_COM:		NOVALUE,	! Process the DELETE command
    TYPE_COM:		NOVALUE,	! Process the TYPE command
    NULL_COM:		NOVALUE,	! Process the null command
    PUT_CHAR:		NOVALUE,	! Put a character in a line buffer
    SUBSTITUTE:		NOVALUE,	! Do a substitution within one line of text
    GET_STRINGS:	NOVALUE,	! Setup the search strings
    SUBS_COM:		NOVALUE,	! Process the SUBSTITUTE command
    SUBS_NEXT_COM:	NOVALUE,	! Process the SUBSTITUTE NEXT command
    WRITE_FILE,				! Write an output file
    EXIT_COM:		NOVALUE,	! Process the EXIT command
    WRITE_COM:		NOVALUE,	! Process the WRITE command
!   VERIFY_COM:		NOVALUE,	! Process the VERIFY command
    INCL_COM:		NOVALUE,	! Process the INCLUDE command
    PRINT,				! Format write routine for PRINT command
    PRINT_COM:		NOVALUE,	! Process the PRINT command
    SET_COM:		NOVALUE,	! Process the SET command
    SHOW_COM:		NOVALUE,	! Process the SHOW command
    NON_CONTIG,				! Determine if a range is contiguous
    MOVE_COM:		NOVALUE,	! Process the MOVE and COPY commands
    DEFINE_COM:		NOVALUE,	! Process the DEFINE KEY command
    RES_COM:		NOVALUE,	! Process the RESEQUENCE command
    TADJ_COM:		NOVALUE,	! Process the TABS ADJUST command
    FILL_COM:		NOVALUE,	! Process the FILL command
    DEF_MAC_COM:	NOVALUE,	! Process the DEFINE MACRO command
    CHANGE_COM:		NOVALUE,	! Process the CHANGE command
    CLEAR_COM:		NOVALUE,	! Process the CLEAR command
    X_COM:		NOVALUE;	! Execute the last parsed command

EXTERNAL ROUTINE
    EXT_DECS
    E_BAD_KEY,
    E_M_CALL,
    E_PUT_AUDIT,
    FLL_FILL,
    F_CHAR,
    F_STRING,
    F_LITERAL,
    F_PUT,
    F_DEC,
    F_SET_COL,
    F_WRITE,
    F_PUT_MESS,
    F_COL_INC,
    BUG_CHECK,
    H_SET_NAME,
    INP_GET_LINE,
    IO_COM,
    IO_CLO,
    IO_NAM,
    IO_GET,
    IO_OI,
    IO_OO,
    IO_PUT,
    IO_WT,
    IO_WTU,
    IO_ERR,
    X_NO_OPEN,
    P_COM,
    RAN_POS,
    RAN_NEXT,
    RAN_REPOS,
    U_F_BUFFER,
    U_CASE_COMP,
    U_EXACT_COMP,
    U_S_SUBS,
    RAN_NLINES,
    U_CVTCASE,
    U_STR_COMP,
    HLP_COM,
    SYS_GET_MEM,
    SY_GET_MESS,
    WF_COMP_LNO,
    WF_CLEAR,
    WF_SCOPY,
    WF_COPY_LINE,
    WF_ECOPY,
    WF_OPEN_BUFFER,
    WF_DELETE_LINE,
    WF_EOB,
    WF_R_CURRENT,
    WF_R_FORWARD,
    WF_R_BACKWRD,
    WF_REPLACE_LINE,
    WF_RESEQUENCE,
    WF_START_INSERT,
    WF_INSERT_LINE,
    WF_END_INSERT,
    WF_TOP,
    WF_BOTTOM,
    WF_LOCATE_LINE,
    E_K_DEF;
    
EXTERNAL
    E_MODE,
    E_RECOVER,
    E_EXITED,
    E_O_NAME,
    E_O_LEN,
    E_SLIN,
    E_TBCB:	REF TBCB_BLOCK,
    E_NUMBERS,
    E_CASEFLAG,
    E_EXACT,
    E_T_TYPE,
    E_TRUNC,
    E_VERIFY,
    E_VERSION,
    E_BUF_LIST,
    E_T_WIDTH,
    E_KEYPAD,
    E_WRAP,
    E_S_TOP,
    E_S_BOT,
    E_DEF_MODE,
    E_MAC_LIST,
    E_SBEGIN,
    E_SBOUND,
    E_QUIET,
    E_ENT:	VECTOR,
    E_TAB,
    E_TLEV,
    E_SCRCHG,
    E_TXT,
    F_BUF,
    F_CUR,
    E_I_SOURCE,
    L_BUF:	VECTOR[255,BYTE],
    L_LEN,
    IO_RHB:	LN_BLOCK,
    IO_STS,
    LNO_0,
    LNO_9,
    LNO_1,
    LNO_ZERO,
    P_T_ADDR,
    C_END,
    C_BUF,
    C_POINT,
    C_LEN,
    SY_ALT_RAB,
    SY_COM_RAB,
    TRAN_TAB:	VECTOR,
    R_SAVE_POS:	POS_BLOCK,
    R_ORIG_POS:	POS_BLOCK,
    LNO_5,
    U_SRCHSTR,
    U_SLEN,
    U_SUBSTR,
    U_SUBLEN,
    P_STACK,
    VT52_TAB:	VECTOR,
    W_LINE:	REF LIN_BLOCK;

EXTERNAL LITERAL
    IO_FNF;

BIND
    COMP_ROUTINE = UPLIT(U_CASE_COMP,U_EXACT_COMP): VECTOR[2];

EXTERNAL
    X_LINE_NUM : VECTOR[12,BYTE],	! Place to compute the line number.
    X_SUBS_COUNT,			! No. of substitutions done.
    X_QUERY_QUIT,			! Quit flag  for /QUERY operations.
    X_S_BITS,				! The options switches.
    X_S_BLOCK : REF NODE_BLOCK,		! The option switch value block.
    X_CUR_COM : REF NODE_BLOCK;		! Pointer to the current command.

!
! Define upper and lower limits used for case flagging
! The zero element is for no flagging, 1 for upper case
! flagging and 2 for lower case.
!
BIND
    LOWLIM = UPLIT(1,'A','a') : VECTOR,
    HIGHLIM = UPLIT(0,'Z','z') : VECTOR;

! 
! Define the prompt used for input mode.  The prompt length
! is dependent on the E_NUMBERS flag.
!

BIND
    PROMPT = UPLIT BYTE(13,10,'		'), ! <CR> <LF> and 2 tabs.
    PR_LEN = UPLIT BYTE(2,4) : VECTOR[2,BYTE];

!
! Define the table containing valid options for each command.
!
BIND OPT_TABLE = UPLIT(BYTE(
    0,				! Options for null command
    0,				! Options for change
    OPT_DUPL+OPT_QUERY,		! Options for copy
    0,				! Options for define
    OPT_QUERY,			! Options for delete
    OPT_SAVE+OPT_SEQ,		! Options for exit
    0,				! Options for find
    0,				! Options for include
    0,				! Options for insert
    OPT_QUERY,			! Options for move
    0,				! Options for print
    OPT_SAVE,			! Options for quit
    0,				! Options for replace
    OPT_SEQ,			! Options for resequence
    0,				! Options for set
    0,				! Options for show
    OPT_QUERY+OPT_NOTYP+
	OPT_BRIEF,		! Options for substitute
    OPT_BRIEF+OPT_STAY,		! Options for type
    OPT_SEQ,			! Options for write
    0,				! Options for subs next
    0,				! Options for help
    OPT_NOTYP,			! Options for verify
    0,				! Options for tab adjust
    0,				! Options for fill
    0,				! Options for def macro
    0				! Options for mac call
	)) : VECTOR[LAST_COM,BYTE];

LITERAL
    ESC	=	27;

!+
! F_LNO
!
! Format a line number for printing.  The line number of the current
! line is converted to a decimal number with leading zeros and
! trailing zeroes after the decimal point suppressed.  The decimal
! point is suppressed if the number is an integer.
!-

GLOBAL ROUTINE F_LNO  : NOVALUE =
    BEGIN
    LOCAL 
        SIGNIF,			! Flag indicating a sig. digit has been seen
	DIGIT : LN_BLOCK,	! The current digit
	DIVISOR : LN_BLOCK,	! A power of ten to divide by
	LINNO : LN_BLOCK,	! the line number we are putting out
        X_LINE_NUM,		! pointer into the output buffer.
	FRAC : LN_BLOCK;

    !
    ! Init the pointer to the beginning of the format buffer.
    !    
    X_LINE_NUM = .F_CUR;
    !
    ! Fetch the line number into a local
    !
    MOVELINE(W_LINE[LIN_NUM],LINNO);
    !
    ! Inititialize the divisor to 10**9 to get the most significant digit
    !
    MOVELINE(LNO_9,DIVISOR);
    SIGNIF = 0;
    !
    ! Initilize the line number field to spaces and a tab.
    !
    CH$MOVE(12,UPLIT(%STRING('           	')),.X_LINE_NUM);
    !
    ! Loop once for each possible digit in the number + 1 for the decimal point
    !
    INCR I FROM 0 TO 10 DO
        BEGIN
	!
	! If we are down the the decimal position, then write out
	! the decimal point.
	!
        IF .I EQL 5 THEN
            CH$WCHAR_A('.',X_LINE_NUM)
        ELSE
            BEGIN
	    !
	    ! Divide the line number by the current divisor to get the
	    ! next digit.
	    !
       	    DIVLINE(DIVISOR,LINNO,DIGIT);
	    !
	    ! throw away all the higher order digits
	    !
            MODLINE(DIVISOR,LINNO,LINNO);
	    !
	    ! Write the digit out the current digit is non-zero or
	    ! we have seen a previous non zero digit or we are down
	    ! to the unit digit.
	    !
            IF .DIGIT NEQ 0 OR .SIGNIF NEQ 0 OR .I EQL 4 THEN
                BEGIN 
	        CH$WCHAR(.DIGIT + %C'0',.X_LINE_NUM);
                SIGNIF = .SIGNIF+1;
                END;
	    !
	    ! Bump the character pointer.
	    !
            X_LINE_NUM = CH$PLUS(.X_LINE_NUM,1);
	    !
	    ! If we are into the fractional part and the rest of 
	    ! the number is zero, then get out of the loop.
	    !
	    IF .I GEQ 4 AND .LINNO EQL 0 THEN EXITLOOP;
	    !
	    ! Reduce the divisor to get the next lower digit
	    !
	    DIVLINE(LNO_1,DIVISOR,DIVISOR);
            END;       
	END;
    !
    ! Set the format buffer pointer and column number.
    !
    F_CUR = F_BUF+12;
    F_SET_COL(16);
    END;

!+
! This routine writes out the portion of a message giving a count.
!
! N is the count, which is written as a decimal number unless it
!   is zero, in which case it is written as 'No'
!
! S is a pointre to a string of characters which is written after the count,
!   followed by an 's' unless the count is exactly 1.
!
! L is the length of the sting pointed to by S.
!-

GLOBAL ROUTINE F_COUNT(N,S,L) : NOVALUE =
    BEGIN
    IF .N EQL 0 THEN
	F_STRING(UPLIT('No'),2)
    ELSE
	F_DEC(.N);
    F_STRING(.S,.L);
    IF .N NEQ 1 THEN F_CHAR('s');
    END;

!+
! This routine displays the current line on the terminal.  If the
! E_NUMBERS flag is on the line number is displayed before the line.
!
! If case flagging is enabled it is handled by this routine.
!-

GLOBAL ROUTINE X_PRINT =
    BEGIN
    LOCAL
	POINTER,
	LEN;
    !
    ! Check for the special case of end of buffer and display [EOB]
    !
    IF WF_EOB() THEN
	F_STRING(UPLIT('[EOB]'),5)
    ELSE
	BEGIN
	!
	! Print the line number if numbers are enabled.
	!
	IF .E_NUMBERS THEN
	    F_LNO();
	!
	! Get the length of the line to display.  Normally this is just the
	! length of the line, but is the /BRIEF option is on, we need to
	! minimize it with the value of the qualifier.
	!
	LEN = .W_LINE[LIN_LENGTH];
	IF .X_S_BITS<OPB_BRIEF> THEN
	    BEGIN
	    !
	    ! If no value was specified, use 10 for the length.
	    !
	    IF .X_S_BLOCK[SW_VAL1] EQL 0 THEN
		X_S_BLOCK[SW_VAL1] = 10;
	    IF .X_S_BLOCK[SW_VAL1] LSSU .LEN THEN
		LEN = .X_S_BLOCK[SW_VAL1];
	    END;
	!
	! get a pointer to the line.
	!
	POINTER = W_LINE[LIN_TEXT];
	!
	! Increment our way through the line.
	!
	INCR I FROM 1 TO .LEN DO
	    BEGIN
	    !
	    ! Determine if the character needs to be flagged with
	    ! a leading apostrophe.
	    !
	    IF CH$RCHAR(.POINTER) GEQ .LOWLIM[.E_CASEFLAG] AND
	       CH$RCHAR(.POINTER) LEQ .HIGHLIM[.E_CASEFLAG] THEN
		F_CHAR('''');
	    !
	    ! And, finally, output the character.
	    !
	    F_CHAR(CH$RCHAR_A(POINTER));
	    END;
	END;
    !
    ! Output the line.
    !
    RETURN F_PUT()
    END;

!+
! This routine handles the insertion of text from and INSERT or REPLACE
! command.
!
! If the current token from the parser is a ';', then the text to be
! inserted is the remainder of the command line, otherwise, loop reading
! a line and inserting it until an end of file is detected.
!-

ROUTINE INSERT : NOVALUE =
    BEGIN
    LOCAL
	EOF;

    !
    ! Set up the work-file system for insertion
    !
    WF_START_INSERT();
    !
    ! Look for the immediate insertion signalled by a ';' following the command.
    !
    IF CH$RCHAR(.P_T_ADDR) EQL %C';' THEN
	BEGIN
	WF_INSERT_LINE(.P_T_ADDR+1,.C_END-.P_T_ADDR-1);
        C_POINT = .C_END;
	END
    ELSE
	!
	! Insert mode loop.  Keep reading and inserting lines until EOF.
	!
	DO
	    BEGIN
	    EOF = INP_GET_LINE(PROMPT,.PR_LEN[.E_NUMBERS]);
	    IF NOT .EOF OR .C_LEN NEQ 0 THEN
		WF_INSERT_LINE(C_BUF,.C_LEN)
	    END
	UNTIL .EOF;
    !
    ! Inform work-file system that the insert is complete, and print
    ! the next line.
    !
    WF_END_INSERT();
    IF .E_I_SOURCE EQL INP_TERM THEN X_PRINT();
    END;

!+
! Command processing routine for the INSERT command.
!
! Position to the specified range and, if it positioned successfully
! do the insert.
!-

ROUTINE INS_COM : NOVALUE =
    BEGIN
    IF RAN_POS(.X_CUR_COM[RANGE1]) THEN
	BEGIN
	INSERT();
	END;
    END;

!+
! Query processing routine.
!
! This routine is called before operating on each line by those commands
! which can take a /QUERY qualifier.  
!
! The options bits are checked to see if the /QUERY qualifier was used.
! If not the routine returns success immediately.  If it was specified,
! then the user is prompted for verification.  The actions for each
! possible answer are:
!
!	Y - Return a 1 to indcate operation should be performed.
!	N - Return a 0 to indicat operation should not be performed.
!	Q - The global flag X_QUERY_QUIT is set to stop further processing.
!	A - The /QUERY option bit is cleared so no more queries are done.
!
! If the answer is not one of the above, then a message is displayed and the
! user is prompted again.
!
!-

ROUTINE QUERY(WPTR, WEND)=
    BEGIN
    LITERAL
	QUERY_LEN = 80;
    LOCAL
	QUERY_RESP: BLOCK[CH$ALLOCATION(QUERY_LEN)],
	LINE,			
	LEN;
    !
    ! Check for the /QUERY bit
    !
    IF .X_S_BITS<OPB_QUERY> THEN
	BEGIN
	!
	! Display the line so the user can see what he is verifying.
	!
	IF .WPTR EQL 0 THEN
	    X_PRINT()
	ELSE
	    BEGIN
	    !
	    ! During a SUBSTITUTE command, the current line is in various
	    ! pieces which are here reconstructed so that any substitution
	    ! already made on the line are shown.
	    !
	    LOCAL
		SW_LINE,				! Save W_LINE
		IN,					! Input char ptr
		OUT,					! Output char ptr
	        WLEN,					! Length of rest of line
		T_LINE:					! Current line with substitutions
		    BLOCK[CH$ALLOCATION(LIN_FIXED_SIZE+255)];
	    MAP
		T_LINE: LIN_BLOCK;
	    !
	    ! Initialize the description for the line to be constructed.
	    !
	    CH$MOVE(LIN_FIXED_SIZE, .W_LINE, T_LINE);
	    !
	    ! Copy the line up to the last substitution.
	    !
	    IN = CH$PTR(L_BUF);
	    OUT = CH$PTR(T_LINE[LIN_TEXT]);
	    INCR I FROM 1 TO .L_LEN DO CH$WCHAR_A(CH$RCHAR_A(IN), OUT);
	    !
	    ! Copy the current line from the last match to the end.
	    !
	    WLEN = CH$DIFF(.WEND, .WPTR);
	    IF .L_LEN + .WLEN GTR 255 THEN WLEN = MAX(0, 255-.L_LEN);
	    INCR I FROM 1 TO .WLEN DO CH$WCHAR_A(CH$RCHAR_A(WPTR), OUT);
	    !
	    ! Fixup the description of the fake current line.
	    !
	    T_LINE[LIN_LENGTH] = .L_LEN + .WLEN;
	    !
	    ! Write the line.
	    !
	    SW_LINE = .W_LINE;		! Save the current line description
	    W_LINE = T_LINE;		! Make the constructed line the current one
	    X_PRINT();			! Format and output this line
	    W_LINE = .SW_LINE;		! Restore the current line description
	    END;
	WHILE 1 DO
	    BEGIN
	    !
	    ! Get the line from either the terminal or the journal file.
	    !
	    IF .E_RECOVER THEN
		BEGIN
		IO_GET(SY_COM_RAB,LINE,LEN);
		CH$WCHAR(CH$RCHAR(.LINE),QUERY_RESP);
		END
	    ELSE
		BEGIN
		IO_COM(UPLIT BYTE(13,10,'?'),3,QUERY_RESP,LEN,QUERY_LEN);
		E_PUT_AUDIT(QUERY_RESP,1);
		END;
	    !
	    ! Check out the answer.
	    !
	    U_CVTCASE(QUERY_RESP,1);
	    SELECT CH$RCHAR(QUERY_RESP) OF
		SET

		[%C'Y']:
		    RETURN 1;

		[%C'N']:
		    RETURN 0;

		[%C'A']:
		    BEGIN
		    X_S_BITS<OPB_QUERY> = 0;
		    RETURN 1;
		    END;

		[%C'Q']:
		    BEGIN
		    X_QUERY_QUIT = 1;
		    RETURN 0;
		    END;

		[OTHERWISE]:
		    F_PUT_MESS(ERR_PLSANSYNQ);

		TES;
		END;
	    END;
    RETURN 1
    END;

!+
! This routine is used by DELETE and REPLACE to delete a range of lines.
!
! We process through the range, checking for query before deleting each
! line.  When we are done a message indicating the number of lines
! deleted is displayed.
!-

ROUTINE DELETE =
    BEGIN
    LOCAL
	NUM_DELETED;
    NUM_DELETED = 0;
    !
    ! Position to the first line in the range.
    !
    RAN_POS(.X_CUR_COM[RANGE1]);
    !
    ! Loop until the end of the range, or the user typed 'Q' in response to
    ! a QUERY.
    !
    WHILE RAN_NEXT(1) AND NOT .X_QUERY_QUIT DO
	IF QUERY(0, 0) THEN
	    BEGIN
	    NUM_DELETED = .NUM_DELETED + 1;
	    WF_DELETE_LINE()
	    END
	ELSE
	    WF_R_FORWARD();
    !
    ! Display message about the count.
    !
    F_COUNT(.NUM_DELETED,UPLIT(' line'),5);
    F_STRING(UPLIT(' deleted'),8);
    F_PUT();
    RETURN .NUM_DELETED NEQ 0;
    END;

!+
! Command processing routine for DELETE
!
! All the work is done by the DELETE routine, then display the current
! line after the deletions.
!-

ROUTINE DEL_COM : NOVALUE =
    BEGIN
    DELETE();
    IF .E_I_SOURCE EQL INP_TERM THEN X_PRINT();
    END;

!+
! Command processing routine for the TYPE command.
!
! Position to the first line of the range, then loop through the
! range displaying each line.
!
! If the /STAY qualifier was used, then reposition to the position
! at the start of the command, otherwise, reposition to the first
! line typed.
!-

ROUTINE TYPE_COM : NOVALUE =
    BEGIN
    RAN_POS(.X_CUR_COM[RANGE1]);
    WHILE RAN_NEXT(0) DO
	X_PRINT();
    IF RAN_NLINES() EQL 0 THEN X_PRINT();
    IF NOT .X_S_BITS<OPB_STAY> THEN
	RAN_REPOS()
    ELSE
	BEGIN
	CH$MOVE(POS_SIZE,R_ORIG_POS,.E_TBCB);
	WF_R_CURRENT();
	END;
    END;

!+
! Command processing routine for the null command.
!
! If the range is '.' then move one line forward and display it
! otherwise, process it as a TYPE comamnd.
!-

ROUTINE NULL_COM : NOVALUE =
    BEGIN
    BIND RANGE = .X_CUR_COM[RANGE1] : NODE_BLOCK;
    IF .RANGE[RAN_TYPE] EQL RAN_NULL THEN
	BEGIN
	WF_R_FORWARD();
	X_PRINT()
	END
    ELSE
	TYPE_COM()
    END;

!+
! Put character into line buffer.
!
! This routine is used by commands such as SUBTITUTE which are modifying a
! line of text.  The new line is built in the line buffer (L_BUF) by calling
! put_char to place each character in the buffer.  If the number of characters
! in the line buffer is already 255, then the new character is not moved.
!
! C is the character to place in the line buffer.
!-

ROUTINE PUT_CHAR(C) : NOVALUE = 
    BEGIN
    IF .L_LEN LSS 255 THEN
        L_BUF[.L_LEN] = .C;
    L_LEN = .L_LEN + 1;
    END;

!+
! Do substitutions in one line of text.
!
! This routine scans the current line of text, starting at the character
! position START_POS, looking for a string that mathces the search string.
! if it is found, that string is replaced by the subsitute string.  If the
! SINGLE flag is on, it returns after one substitution, otherwise all
! matches in the line are substituted.
!-
    
ROUTINE SUBSTITUTE(SINGLE,START_POS) : NOVALUE =
    BEGIN
    LOCAL
	OLD : REF VECTOR[255,BYTE],	! Pointer to the original line
	END_LINE,			! Pointer to end of the line
	OLD_LEN,			! Length of original line
	REPPOINT,			! Pointer to the replacement string
	NEW_POS,			! Character position after last subs.
	CHANGED;			! Flag indicating this line was changed.

    !
    ! Get a local pointer to the line and it length;
    !
    OLD = W_LINE[LIN_TEXT];
    OLD_LEN = .W_LINE[LIN_LENGTH];
    !
    ! Initialize the length of the new line, changed flag and position of
    ! last substitute.
    !
    L_LEN = 0;
    CHANGED = 0;
    NEW_POS = 0;
    !
    ! Get a pointer to the end of the old line.
    !
    END_LINE = CH$PTR(.OLD,.W_LINE[LIN_LENGTH]);
    !
    ! Loop until either we finish the line or the new line exceed 255 chars.
    !
    WHILE .OLD LSSA .END_LINE AND .L_LEN LSS 256 DO 
	!
	! Look for a match if the position is greater or equal to
	! start position.
	!
	IF .L_LEN GEQ .START_POS AND
	    .OLD+.U_SLEN LEQA .END_LINE AND
	   (.U_STR_COMP)(.OLD,U_SRCHSTR,.U_SLEN) AND
	   NOT .X_QUERY_QUIT AND QUERY(.OLD, .END_LINE) THEN
	    BEGIN
	    !
	    ! A match was found.  Set flag indicating that a change has been
	    ! made and increment the count.
	    !
	    CHANGED = 1;
	    X_SUBS_COUNT = .X_SUBS_COUNT + 1;
	    !
	    ! Get a pointer to the replacement string.
	    !
	    REPPOINT = U_SUBSTR;
	    !
	    ! Move the replacement string into the new line buffer.
	    !
	    INCR J FROM 1 TO .U_SUBLEN DO PUT_CHAR(CH$RCHAR_A(REPPOINT));
	    NEW_POS = .L_LEN;
	    !
	    ! Bump the old line pointer by the length of the search string.
	    !
	    OLD = CH$PLUS(.OLD,.U_SLEN);
	    !
	    ! If we are allowing only one substitution, then copy the rest
	    ! of the line.
	    !
	    IF .SINGLE THEN
		WHILE .OLD LSSA .END_LINE DO PUT_CHAR(CH$RCHAR_A(OLD));
	    END
	ELSE
	    BEGIN
	    !
	    ! No match, just copy the chararacter and continue.
	    !
	    PUT_CHAR(CH$RCHAR_A(OLD));
	    END;
    !
    ! Check to see if any substitutions have been done.
    !
    IF .CHANGED THEN
	BEGIN
	!
	! Check for overflow of the newly constructed line.	
	!
	IF .L_LEN GTR 255 THEN
	    BEGIN
	    F_PUT_MESS(ERR_LINEXC255);
	    L_LEN = 255;
	    END;
	!
	! Replace the line in the buffer, and update the position to
	! the position after the last substitution.
	!
	WF_REPLACE_LINE(L_BUF,.L_LEN);
	E_TBCB[TBCB_CHAR_POS] = .NEW_POS;
	!
	! Unless /NOTYPE was specified, display the updated line.
	!
	IF NOT .X_S_BITS<OPB_NOTYP> THEN
	    X_PRINT()
	END;
    END;

!+
! Setup the search and replace strings for a substitute or substitute next
! command.  The strings are described by the node block pointed to by
! the STR_PNT field of the current command node block.
!-

ROUTINE GET_STRINGS : NOVALUE =
    BEGIN
    BIND STRINGS = .X_CUR_COM[STR_PNT] : NODE_BLOCK;
    U_S_SUBS(.STRINGS[SRCHADDR],.STRINGS[SRCHLEN],
		 .STRINGS[REPADDR],.STRINGS[REPLEN]);
    END;

!+
! Command processing routine for SUBSTITUTE.
!
! Position to the first line of the range, then enter a loop getting
! the next line and calling the SUBSTITUTE routine to do substituions
! within that line.  If the range was null, then we do only a single
! substituion, otherwise all are done.
!-

ROUTINE SUBS_COM : NOVALUE =
    BEGIN
    LOCAL  
	SINGLE,			! Flag indicating single subs only
	FIRST;			! Flag indicating whether this is the first one.
    !
    ! Get the range node.
    !
    BIND RANGE = .X_CUR_COM[RANGE1] : NODE_BLOCK;
    !
    ! Position to the first line.
    !
    RAN_POS(.X_CUR_COM[RANGE1]);
    !
    ! Set the single substitution flag if the range was null.
    !
    SINGLE = .RANGE[RAN_TYPE] EQL RAN_NULL;
    !
    ! Set flag indicating this if the first substitution, and zero the
    ! substitution count.
    !
    FIRST = 1;
    X_SUBS_COUNT = 0;
    !
    ! Loop over the range.
    !
    WHILE RAN_NEXT(0) AND NOT .X_QUERY_QUIT DO
	IF NOT WF_EOB() THEN
	    BEGIN
	    !
	    ! Must set up the search and replace string each time through
	    ! in case the range involved a search string which would clobber
	    ! it.
	    !
	    GET_STRINGS();
	    !
	    ! Do substitutions in this line starting at position 0.
	    !
	    SUBSTITUTE(.SINGLE,0);
	    !
	    ! Check to see if this was the first line in the range.
	    !
	    IF .FIRST THEN
		!
		! Save position after first substitute so we can
		! correctly reposition there.  This is nescessary since
		! modifying the first line might change it's position in
		! the text buffer, invalidating the previously saved position.
		!
		BEGIN
		CH$MOVE(POS_SIZE,.E_TBCB,R_SAVE_POS);
		FIRST = 0;
		END;
	    END;
    !
    ! If the command came from the terminal, the report the number of 
    ! substitutions.
    !
    IF .E_I_SOURCE EQL INP_TERM THEN
	BEGIN
	F_COUNT(.X_SUBS_COUNT,UPLIT(' substitution'),13);
	F_PUT();
	END;
    !
    ! And re-position.
    !
    RAN_REPOS();
    END;

!+
! Command processing routine for SUBSTITUTE NEXT.
!
! This command keeps trying to do a subtitution until it succeeds.
!-

ROUTINE SUBS_NEXT_COM : NOVALUE =
    BEGIN
    !
    ! Check to see if new search and replace strings were specified and, if
    ! they were, set them up.
    !
    IF .X_CUR_COM[STR_PNT] NEQ 0 THEN
	GET_STRINGS();
    !
    ! Zero the substitute count.
    !
    X_SUBS_COUNT = 0;
    !
    ! Make sure we are correctly positioned at the current line.
    !
    WF_R_CURRENT();
    !
    ! Loop until a substitution is done or the end of buffer is encountered.
    !
    WHILE NOT WF_EOB() AND .X_SUBS_COUNT EQL 0 DO
	BEGIN
	!
	! Attempt a single substition on this line starting at the cursor
	! position.
	!
	SUBSTITUTE(1,.E_TBCB[TBCB_CHAR_POS]);
	!
	! If X_SUBS_COUNT was non-zero then read to the next line.
	!
	IF .X_SUBS_COUNT EQL 0 THEN
		WF_R_FORWARD();
	END;
    END;

!+
! Write an output file routine.  This routine is used by the WRITE and
! EXIT commands to write an output file.  The /SEQ switch determines whether
! sequence numbers should be written.
!
! RANGE is the range block for the range to be written.
!
! CHECK is a flag indicating that the consistence check should be done
!       (set if we are exiting, clear otherwise).
!-

ROUTINE WRITE_FILE(RANGE,CHECK) =
    BEGIN
    LOCAL
	IFI,				! Internal file identifier of file
	NAME,				! File name string pointer
	NAME_LEN,				! File name string length
	L_COUNT : LN_BLOCK,			! Number of lines written.
	C_COUNT,				! Number of characters written
	SEQ,				! Flag indicating sequenced
	SEQ_NUM : LN_BLOCK,			! Current sequence number
	SEQ_INCR : LN_BLOCK;		! Sequence number increment
    !
    ! Check for an explicit file specification, if none, use the output file name.
    !
    IF .X_CUR_COM[FSPCLEN] NEQ 0 THEN
	BEGIN
	NAME = .X_CUR_COM[FILSPEC];
	NAME_LEN = .X_CUR_COM[FSPCLEN];
	END
    ELSE
	BEGIN
	NAME = .E_O_NAME;
	NAME_LEN = .E_O_LEN;
	END;
    !
    ! Did we get a non null file spec?
    !
    IF .NAME_LEN EQL 0 THEN
	BEGIN
	F_PUT_MESS(ERR_NOOUTFIL);
	E_TXT = .E_TXT+1;
	RETURN 0;
	END;
    !
    ! Position to the front of the range.
    !
    RAN_POS(.RANGE);
    !
    ! Check for the /SEQ option.
    !
    IF (SEQ = .X_S_BITS<OPB_SEQ>) THEN
	BEGIN
	DIVLINE(LNO_5,X_S_BLOCK[SW_VAL1],SEQ_NUM);
	DIVLINE(LNO_5,X_S_BLOCK[SW_VAL2],SEQ_INCR);
	END;
    !
    ! Try to open the file.
    !    
    IF (IFI = IO_OO(SY_ALT_RAB,.NAME,.NAME_LEN,.SEQ)) NEQ 0 THEN
	BEGIN
	IO_NAM();
	MOVELINE(LNO_ZERO,L_COUNT);
	C_COUNT = 0;
	WHILE RAN_NEXT(0) AND NOT WF_EOB() DO
	    BEGIN
	    !
	    ! Set up the RHB if /SEQ was used.
	    !
	    IF .SEQ NEQ 0 THEN 
		IF .X_S_BLOCK[SEQ_VAL] EQL 0 THEN
		    CH$MOVE(2,W_LINE[LIN_ORIG_NUM],IO_RHB)
		ELSE
		    BEGIN
		    IO_RHB = .SEQ_NUM;
		    SEQ_NUM = .SEQ_NUM + .SEQ_INCR;
		    END;
	    !
	    ! Write a line to the file.
	    !
	    IF NOT IO_PUT(SY_ALT_RAB,W_LINE[LIN_TEXT],.W_LINE[LIN_LENGTH]) THEN
		BEGIN
		IO_CLO(.IFI,SY_ALT_RAB);
		RETURN 0;
		END;
	    !
	    ! Count lines and characters for consistency check.
	    !
	    ADDLINE(LNO_0,L_COUNT,L_COUNT);
	    C_COUNT = .C_COUNT + .W_LINE[LIN_LENGTH];
	    END;
	!
	! Do the consistency check.
	!
	IF .CHECK NEQ 0 THEN
	    IF WF_COMP_LNO(L_COUNT,E_TBCB[TBCB_LINE_COUNT]) NEQ 0 OR
		.C_COUNT NEQ .E_TBCB[TBCB_CHAR_COUNT] THEN
		BEGIN
		F_PUT_MESS(ERR_CONCHKFLD);
		X_S_BITS = .X_S_BITS OR OPT_SAVE;
		END;
	!
	! Check for the special case of exiting and there is still
	! text in the input file.
	!
	IF .E_EXITED AND .E_TBCB[TBCB_INPUT_RAB] NEQ 0 THEN
	    BEGIN
	    LOCAL
		REC,
		RECLEN;
	    WHILE IO_GET(.E_TBCB[TBCB_INPUT_RAB],REC,RECLEN) DO
		BEGIN
		!
		! Set up the RHB if /SEQ was used.
		!
		IF .SEQ NEQ 0 THEN 
		    IF .X_S_BLOCK[SEQ_VAL] NEQ 0 THEN
			BEGIN
			IO_RHB = .SEQ_NUM;
			SEQ_NUM = .SEQ_NUM + .SEQ_INCR;
			END;
		IF NOT IO_PUT(SY_ALT_RAB,.REC,.RECLEN) THEN
		    BEGIN
		    IO_CLO(.IFI,SY_ALT_RAB);
		    RETURN 0;
		    END;
		L_COUNT = .L_COUNT + 1;
		END;
	    END;
	F_CHAR(' ');
	F_COUNT(.L_COUNT,UPLIT(' line'),5);
	F_PUT();
	IO_CLO(.IFI,SY_ALT_RAB);
	RETURN 1
	END
    ELSE
	BEGIN
	!
	! File was not created, output error message.
	!
	X_NO_OPEN(ERR_OUTFILCRE);
	RETURN 0
	END
    END;

!+
! Command processing routine for exit.
!
! Switch to the main buffer, write the output file and set the E_EXIT
! flag if it succeeded.
!-

ROUTINE EXIT_COM : NOVALUE =
    BEGIN
    LOCAL
	RANGE : NODE_BLOCK;

    ! Ignore the EXIT command encountered during recovery.
    !
    IF .E_RECOVER THEN RETURN;

    ! Setup the range as WHOLE.
    !
    RANGE[NODE_TYPE] = RANGE_NODE;
    RANGE[RAN_TYPE] = RAN_WHOLE;

    ! Position into the MAIN buffer.
    !
    U_F_BUFFER(UPLIT(%STRING('MAIN')),4);

    ! Attempt to write the file, and set the EXITED flag it it succeeds.
    !
    E_EXITED = WRITE_FILE(RANGE,1);
    END;

!+
! Command processing routine for the write command.
!
! Look at the current range, if it is null, then use the whole buffer.
! then write the file.
!-

ROUTINE WRITE_COM : NOVALUE =
    BEGIN
    LOCAL
	RANGE : REF NODE_BLOCK;
    RANGE = .X_CUR_COM[RANGE1];
    IF .RANGE[RAN_TYPE] EQL RAN_NULL THEN RANGE[RAN_TYPE] = RAN_WHOLE;
    WRITE_FILE(.RANGE,0);
    !
    ! Reposition to the original line.
    !
    CH$MOVE(POS_SIZE,R_ORIG_POS,.E_TBCB);
    WF_R_CURRENT();
    END;

%(
!+
! Command processing routine for the VERIFY (undocumented) command.
!
! Read though the file, first forward, then backward doing a consitency
! check.
!-

ROUTINE VERIFY_COM : NOVALUE =
    BEGIN
    LOCAL
	L_COUNT : LN_BLOCK,
	C_COUNT,
	SAVE_POS : POS_BLOCK;
    CH$MOVE(POS_SIZE,.E_TBCB,SAVE_POS);
    WF_TOP();
    MOVELINE(LNO_ZERO,L_COUNT);
    C_COUNT = 0;
    UNTIL WF_EOB()
    DO  BEGIN
	ADDLINE(LNO_0,L_COUNT,L_COUNT);
	C_COUNT = .C_COUNT + .W_LINE[LIN_LENGTH];
	IF NOT .X_S_BITS<OPB_NOTYP> THEN
	    X_PRINT();
	WF_R_FORWARD();
	END;
    IF WF_COMP_LNO(L_COUNT,E_TBCB[TBCB_LINE_COUNT]) NEQ 0 OR
	.C_COUNT NEQ .E_TBCB[TBCB_CHAR_COUNT] THEN
	BEGIN
	F_LITERAL(UPLIT('Consistency check 1 failed'),26); F_PUT();
	END
    ELSE
	BEGIN
	F_LITERAL(UPLIT('Looking good'),12); F_PUT();
	END;
    WF_BOTTOM();
    MOVELINE(LNO_ZERO,L_COUNT);
    C_COUNT = 0;
    WHILE WF_R_BACKWRD() DO
	BEGIN
	ADDLINE(LNO_0,L_COUNT,L_COUNT);
	C_COUNT = .C_COUNT + .W_LINE[LIN_LENGTH];
	IF NOT .X_S_BITS<OPB_NOTYP> THEN
	    X_PRINT()
	END;
    IF WF_COMP_LNO(L_COUNT,E_TBCB[TBCB_LINE_COUNT]) NEQ 0 OR
       .C_COUNT NEQ .E_TBCB[TBCB_CHAR_COUNT] THEN
	BEGIN
	F_LITERAL(UPLIT BYTE('Failed consistency check 2'),26); F_PUT();
	END
    ELSE
	BEGIN
	F_LITERAL(UPLIT BYTE('Looking good'),12); F_PUT();
	END;
    CH$MOVE(POS_SIZE,SAVE_POS,.E_TBCB);
    WF_R_CURRENT();
    END;
)%

!+
! Command processing routing for the INCLUDE command.
!
! Attempt to open the file, if it succeeds then position as indicated
! by the range and read the file into the buffer in front of that line.
!-

ROUTINE INCL_COM : NOVALUE =
    BEGIN
    LOCAL
	REC_LEN,			! Length of record read.
	IFI,			! Internal file identifier of file.
	REC_ADDR;			! Address of record read.
    !
    ! Open the file.
    !
    IFI = IO_OI(SY_ALT_RAB,.X_CUR_COM[FILSPEC],.X_CUR_COM[FSPCLEN]);
    IF .IFI NEQ 0 THEN
	BEGIN
	!
	! file was opened.  Position to start of the range.
	!
	RAN_POS(.X_CUR_COM[RANGE1]);
	!
	! Insert all the lines from the file at the current position.
	!
	WF_START_INSERT();
	WHILE IO_GET(SY_ALT_RAB,REC_ADDR,REC_LEN) DO
	    WF_INSERT_LINE(.REC_ADDR,.REC_LEN);
	WF_END_INSERT();
	!
	! And close the file.
	!
	IO_CLO(.IFI,SY_ALT_RAB);
	RETURN 1;
	END
    ELSE
	BEGIN
	!
	! The open failed, put out an error message.
	!
	X_NO_OPEN(IF .IO_STS EQL IO_FNF THEN
			ERR_INPFILNEX
		    ELSE
			ERR_INPFILOPN);
	RETURN 0
	END
    END;

!+
! This routine is made the format write routine when doing a PRINT
! command.  Whenever the formatting routines are to output a record
! this routine is called, which in turn writes the line to the file.
!-

ROUTINE PRINT(RECADDR,RECLEN) =
    BEGIN
    IO_PUT(SY_ALT_RAB,.RECADDR,.RECLEN)
    END;

!+
! Command processing for PRINT
!
! First, attempt to open the file,  if it succeeds then set up the
! little routine above as the format write routine and process the
! range.  A page skip is done after 55 lines, or when the first character
! of a line is a form feed, whichever comes first.
!-

ROUTINE PRINT_COM : NOVALUE =
    BEGIN
    LITERAL
	MAX_LINES = 55;
    LOCAL
	COUNT,				! Number of line on this page
	SAVE_WIDTH,				! Save the terminal width
	IFI;				! IFI of the output file.

    BIND RAN = .X_CUR_COM[RANGE1] : NODE_BLOCK;
    !
    ! Make sure there is a file spec.
    !
    IF .X_CUR_COM[FSPCLEN] EQL 0 THEN
	BEGIN
	F_PUT_MESS(ERR_NOFILSPC);
	E_TXT = .E_TXT+1;
	RETURN 0;
	END;
    !
    ! Set up so a form feed will be output immediately.
    !
    COUNT = MAX_LINES;
    !
    ! If the range is null, then make it the whole buffer.
    !
    IF .RAN[RAN_TYPE] EQL RAN_NULL THEN
	RAN[RAN_TYPE] = RAN_WHOLE;
    !
    ! Open the file.
    !
    IFI = IO_OO(SY_ALT_RAB,.X_CUR_COM[FILSPEC],.X_CUR_COM[FSPCLEN],0);
    IF .IFI NEQ 0 THEN
	BEGIN
	!
	! Save the current terminal width and make it 132 characters for the printer.
	!
	SAVE_WIDTH = .E_T_WIDTH;
	E_T_WIDTH = 132;
	!
	! Reset the format writing routine.
	!
	F_WRITE(PRINT);
	!
	! Position to top of range.
	!
	RAN_POS(.X_CUR_COM[RANGE1]);
	!
	! Loop thourgh the range.
	!
	WHILE RAN_NEXT(0) DO
	    BEGIN
	    IF NOT WF_EOB() THEN
		BEGIN
		!
		! Look for form-feed in the record.
		!
		IF CH$RCHAR(W_LINE[LIN_TEXT]) EQL 12 THEN COUNT = MAX_LINES;
		!
		! Check for a page skip.
		!
		IF .COUNT EQL MAX_LINES THEN
		    BEGIN
		    PRINT(UPLIT BYTE(12),1);
		    F_PUT();
		    F_PUT();
		    COUNT = 0;
		    END;
		COUNT = .COUNT + 1;
		!
		! And print the line.
		!
		IF NOT X_PRINT() THEN EXITLOOP;
		END;
	    END;
	!
	! Reposition to the first line of the range.
	!
	RAN_REPOS();
	!
	! Close the file.
	!
	IO_CLO(.IFI,SY_ALT_RAB);
	!
	! Restore the terminal width and the format write routine,
	! and reposition to the original line.
	!
	E_T_WIDTH = .SAVE_WIDTH;
	F_WRITE(IO_WT);
	CH$MOVE(POS_SIZE,R_ORIG_POS,.E_TBCB);
	WF_R_CURRENT();
	END
    ELSE
	!
	! Here if file was not opened.
	!
	X_NO_OPEN(ERR_OUTFILCRE);
    END;

!+
! Command processing routine for SET.
!
! The SET_TYPE field contains an index identifying the type of SET command,
! case on it and handle the particular command.
!-

ROUTINE SET_COM : NOVALUE =
    BEGIN
    CASE .X_CUR_COM[SET_TYPE] FROM 1 TO 23 OF
	SET

	[1]: ! Set numbers
	    E_NUMBERS = 1;	

	[2]: ! Set nonumbers
	    E_NUMBERS = 0;

	[3]: ! Set case
	    E_CASEFLAG = .X_CUR_COM[SET_VAL]-1;

	[4]: ! Set search
	    CASE .X_CUR_COM[SET_VAL] FROM 1 TO 6 OF
		SET
		[1,2]:	! Exact/Noexact
		    BEGIN
		    E_EXACT = .X_CUR_COM[SET_VAL] - 1;
		    U_STR_COMP = .COMP_ROUTINE[.E_EXACT];
		    END;
		[3,4]: ! Begin/End
		    E_SBEGIN = .X_CUR_COM[SET_VAL] - 3;
		[5,6]: ! Bounded/Unbounded
		    E_SBOUND = .X_CUR_COM[SET_VAL] - 5;
		TES;

	[5]: ! Terminal
	    E_T_TYPE = .X_CUR_COM[SET_VAL];

	[6]: ! Verify
	    E_VERIFY = 1;

	[7]: ! Noverify
	    E_VERIFY = 0;

	[8]: ! Truncate
	    (E_TRUNC = 1; E_SCRCHG = 1);

	[9]: ! Notruncate
	    (E_TRUNC = 0; E_SCRCHG = 1);

	[10]:! Keypad
	     E_KEYPAD = 1;

	[11]:! Nokeypad
	     E_KEYPAD = 0;

	[12]:! Wrap
	    BEGIN 
	    E_WRAP = .X_CUR_COM[SET_VAL];
	    IF .E_WRAP GTRU 255 THEN E_WRAP = 255;
	    END;

	[13]:! Nowrap
	     E_WRAP = 256;

	[14]:! Cursor
	    BEGIN
	    !
	    ! Set top and bottom margin, making sure neither exceeds the
	    ! number of lines on the screen.
	    !
	    E_S_TOP = .X_CUR_COM[SET_VAL1];
	    IF .E_S_TOP GEQU .E_SLIN THEN E_S_TOP = .E_SLIN-1;
	    E_S_BOT = .X_CUR_COM[SET_VAL];
	    IF .E_S_BOT GEQU .E_SLIN THEN E_S_BOT = .E_SLIN-1;
	    E_SCRCHG = .E_SCRCHG+1;
	    END;

	[15]:! Screen
	    BEGIN
	    E_T_WIDTH = .X_CUR_COM[SET_VAL];
	    IF .E_T_TYPE EQL TERM_VT100 THEN
		BEGIN
		!
		! This is a VT100, set the proper terminal width.
		!
		IF .E_T_WIDTH LEQ 80 THEN
		    F_LITERAL(UPLIT(%STRING(%CHAR(ESC),'[?3l')),5)
		ELSE
		    F_LITERAL(UPLIT(%STRING(%CHAR(ESC),'[?3h')),5);
		F_PUT();
		END;
	    E_SCRCHG = .E_SCRCHG+1;
	    END;

	[16]:! Mode
	    E_DEF_MODE = .X_CUR_COM[SET_VAL]-1;

	[17]:! Lines
	    BEGIN
	    E_SLIN = .X_CUR_COM[SET_VAL];
	    IF .E_SLIN GTRU 22 THEN E_SLIN = 22;
	    !
	    ! Re-adjust the top and bottom lines if necessary.
	    !
	    IF .E_S_TOP GEQ .E_SLIN THEN E_S_TOP = .E_SLIN-1;
	    IF .E_S_BOT GEQ .E_SLIN THEN E_S_BOT = .E_SLIN-1;
	    E_SCRCHG = .E_SCRCHG+1;
	    END;

	[18]:! Entity
	    BEGIN
	    LOCAL
		LEN,
		ENT_NUM;
        
	    U_CVTCASE(.X_CUR_COM[AS_STR],.X_CUR_COM[AS_LEN]);
	    LEN = .X_CUR_COM[AS_LEN] + 1;
	    ENT_NUM = .X_CUR_COM[SET_VAL] - 1;
	    IF SYS_GET_MEM(LEN,E_ENT[.ENT_NUM]) THEN
		BEGIN
		CH$WCHAR(.LEN-1,CH$PTR(.E_ENT[.ENT_NUM]));
		CH$MOVE(.LEN-1,.X_CUR_COM[AS_STR],CH$PTR(.E_ENT[.ENT_NUM],1));
		END
	    ELSE
		F_PUT_MESS(ERR_INSMEM);
	    END;        

	[19]:! Quiet
	    E_QUIET = 1;

	[20]:! Noquiet
	    E_QUIET = 0;

	[21]:! Tab
	    BEGIN
	    E_TAB = .X_CUR_COM[SET_VAL];
	    E_TLEV = 1;
	    IF .E_TAB GTR 255 THEN E_TAB = 255;
	    END;

	[22]:! Notab
	    E_TAB = 0;

	[23]:! Help
	    H_SET_NAME(.X_CUR_COM[FILSPEC],.X_CUR_COM[FSPCLEN]);

	TES;
    END;

!
! Define keywords used in the show command.
!
BIND CASE_STRING = UPLIT BYTE('None UpperLower') : BLOCKVECTOR[,5,BYTE];
BIND TERM_NAME = UPLIT BYTE('Unknown   VT52      VT100     Hardcopy  ');

!+
! Command processing routine for SHOW.
!
! The current command node field SET_TYPE gives an index for the type of
! SHOW which is being done.  Case on this and put the stuff out.
!-

ROUTINE SHOW_COM : NOVALUE =
    BEGIN
    CASE .X_CUR_COM[SET_TYPE] FROM 1 TO 9 OF
	SET

	[1]: ! Show buffers
	    BEGIN
	    LOCAL
		BUF : REF TBCB_BLOCK;
	    !
	    ! Point to first buffer.
	    !
	    BUF = .E_BUF_LIST;
	    !
	    ! Loop through all buffer, displaying the number of lines
	    ! in each.
	    WHILE .BUF NEQ 0 DO
		BEGIN
		!
		! Put an equal sign before the current buffer.
		!
		IF .BUF EQL .E_TBCB THEN
		    F_CHAR('=')
		ELSE 
		    F_CHAR(' ');
		F_STRING(BUF[TBCB_NAME],.BUF[TBCB_NAME_LEN]);
		F_CHAR('	');
		F_DEC(.BUF[TBCB_LINE_COUNT]);
		!
		! If the buffer still has a file attached to it, then print
		! and aterisk after the count to indicate there may be more
		! lines than we have indicated.
		!
		IF .BUF[TBCB_INPUT_RAB] NEQ 0 THEN
		    F_CHAR('*');
		F_STRING(UPLIT BYTE('	lines'),6);
		F_PUT();
		BUF = .BUF[TBCB_NEXT_BUF];
		END;
	    END;

	[2]: ! Show case
	    BEGIN
	    F_STRING(CASE_STRING[.E_CASEFLAG,0,0,0,0],5);
	    F_PUT();
	    END;

	[3]: ! Show search
	    BEGIN
	    IF .E_EXACT THEN
		F_STRING(UPLIT BYTE('exact'),5)
	    ELSE
		F_STRING(UPLIT BYTE('general'),7);
	    IF .E_SBEGIN THEN
		F_STRING(UPLIT BYTE(' begin '),7)
	    ELSE
		F_STRING(UPLIT BYTE(' end '),5);
	    IF .E_SBOUND EQL 0 THEN
		F_STRING(UPLIT BYTE('un'),2);
	    F_STRING(UPLIT BYTE('bounded'),7);
	    F_PUT();
	    END;

	[4]: ! Show terminal
	    BEGIN
	    F_STRING(CH$PTR(TERM_NAME,10*.E_T_TYPE),10);
	    F_PUT();
	    END;

	[5]: ! Show version
	    BEGIN
	    F_STRING(E_VERSION,10);
	    F_PUT();
	    END;

	[6]: ! Show ent
	    BEGIN
	    LOCAL
		LEN,
		ENT;
	    ENT = .E_ENT[.X_CUR_COM[SET_VAL]-1];
	    LEN = CH$RCHAR_A(ENT);
	    F_STRING(.ENT,.LEN);
	    F_PUT();
	    END;

	[7]: ! Show key
	    BEGIN
	    EXTERNAL
		C_TRAN,			! True if translation table has been initialized
		VT52_TAB:	VECTOR, ! Default definitions for the VT52 keypad
		VT100_TAB:	VECTOR; ! Default definitions for the VT100 keypad
	    LOCAL
		KEY_POINT;
	    IF E_BAD_KEY(.X_CUR_COM[KEY_VAL])
    	    THEN
		SY_GET_MESS(ERR_KEYNOTDEF)
	    ELSE
		BEGIN
    		!
    		! Get a pointer to the key definition.  If the key has been defined,
		! show that; if the keypad has been defined already, the
		! definition is in TRAN_TAB; otherwise use the appropriate
		! default keypad tables.
    		!
		KEY_POINT = 0;
		IF .TRAN_TAB[.X_CUR_COM[KEY_VAL]-256] NEQ 0
		THEN
		    KEY_POINT = .TRAN_TAB[.X_CUR_COM[KEY_VAL]-256]
		ELSE IF .C_TRAN
    		THEN
    		    KEY_POINT = .TRAN_TAB[.X_CUR_COM[KEY_VAL]-256]
    		ELSE IF .E_T_TYPE EQL TERM_VT52
    		THEN
		    BEGIN
		    IF .VT52_TAB[.X_CUR_COM[KEY_VAL]-256] NEQ 0
		    THEN
    			KEY_POINT = VT52_TAB + .VT52_TAB[.X_CUR_COM[KEY_VAL]-256];
		    END
    		ELSE IF .E_T_TYPE EQL TERM_VT100
    		THEN
		    BEGIN
		    IF .VT100_TAB[.X_CUR_COM[KEY_VAL]-256] NEQ 0
		    THEN
    			KEY_POINT = VT100_TAB + .VT100_TAB[.X_CUR_COM[KEY_VAL]-256];
		    END;
    		!
    		! Output the defining string or the 'no definition' message.
    		!
    		IF .KEY_POINT EQL 0
    		THEN
    		    SY_GET_MESS(ERR_NODEFN)
    		ELSE IF CH$RCHAR(.KEY_POINT) EQL 0
    		THEN
    		    SY_GET_MESS(ERR_NODEFN)
    		ELSE
    		    F_STRING(CH$PLUS(.KEY_POINT,1), CH$RCHAR(.KEY_POINT));
		END;
	    F_PUT();
	    END;

	[8]: ! Show cursor
	    BEGIN
	    F_DEC(.E_S_TOP);
	    F_CHAR(':');
	    F_DEC(.E_S_BOT);
	    F_PUT();
	    END;

	[9]: ! Show screen.
	    BEGIN
	    F_DEC(.E_T_WIDTH);
	    F_PUT();
	    END;

	TES;
    E_TXT = 1;
    END;

!+
! This routine takes a range node and determines whether or not it
! defines a contiguous range.  The range is non-contiguous if it is
! a ALL or if the next range field is non-zero, indicating and AND.
!-

ROUTINE NON_CONTIG(RANGE) =
    BEGIN
    MAP
	RANGE : REF NODE_BLOCK;
    IF .RANGE[RAN_TYPE] EQL RAN_ALL OR
       .RANGE[NEXT_RANGE] NEQ 0 THEN
	BEGIN
	F_PUT_MESS(ERR_RANNONCON);
	RETURN 1
	END
    ELSE
	!
	! If is is a buffer range, we better look at the range below it.
	!
	IF .RANGE[RAN_TYPE] EQL RAN_BUFFER THEN
	    RETURN NON_CONTIG(.RANGE[RANGE1])
	ELSE
	    RETURN 0
    END;

!+
! Command processing for MOVE and COPY.
!
! First, find the destination range to make sure we can position there.
! Next process the source range, copying all the lines to an intermediate
! buffer.  The position to the destination range again, and copy the
! temporary buffer the indicated number of times.  If the command is 
! MOVE the DELETE parameter will be true, causing us to delete the source
! lines as they are processed.
!-

ROUTINE MOVE_COM(DELETE) : NOVALUE =
    BEGIN
    LOCAL
	NLINES,				! Number of lines copied.
	DEST_LINE : LN_BLOCK,		! Line number of the destination.
	S_TBCB,				! Address of TBCB for the source.
	D_TBCB,				! Address of TBCB for the destination.
	NUM_COPIES,			! Number of times to copy it.
	START_POS : POS_BLOCK,		! The start position.
	TEMP : TBCB_BLOCK;		! Temporary buffer TBCB.
    !
    ! Save the current position for future restoration.
    !
    CH$MOVE(POS_SIZE,.E_TBCB,START_POS);
    !
    ! Save the current TBCB address so we can detect a buffer change
    !
    S_TBCB = .E_TBCB;
    !
    ! First check to make sure we can locate the destination line.
    !
    IF NOT RAN_POS(.X_CUR_COM[RANGE1]) THEN
	BEGIN
	F_PUT_MESS(ERR_DSTMOVCOP);
	RETURN;
	END;
    !
    ! Save the line number of the destination line so we are able to reposition 
    ! there when we are ready to move it.
    !
    MOVELINE(W_LINE[LIN_NUM],DEST_LINE);
    D_TBCB = .E_TBCB;
    !
    ! Create a temporary buffer to copy the lines.
    !
    E_TBCB = TEMP;
    CH$FILL(0,TBCB_SIZE,TEMP);
    WF_OPEN_BUFFER();
    E_TBCB = .S_TBCB;
    CH$MOVE(POS_SIZE,START_POS,.E_TBCB);
    WF_R_CURRENT();
    !
    ! Now position to the front of the source range.
    !
    RAN_POS(.X_CUR_COM[RANGE2]);
    !
    ! Copy the source lines to a temporary buffer.
    !
    WF_SCOPY(TEMP);
    NLINES = 0;
    WHILE RAN_NEXT(.DELETE) AND NOT WF_EOB() AND .X_QUERY_QUIT EQL 0 DO
	IF QUERY(0, 0) THEN
	    BEGIN
	    NLINES = .NLINES + 1;
	    WF_COPY_LINE(.DELETE);
	    END
	ELSE
	    IF .DELETE THEN WF_R_FORWARD();
    WF_ECOPY(0);
    !
    ! Now, re-position to the destination range.
    !
    E_TBCB = .D_TBCB;
    WF_R_CURRENT();
    WF_LOCATE_LINE(DEST_LINE);
    !
    ! Switch to the temp buffer we just created.
    !
    E_TBCB = TEMP;
    WF_R_CURRENT();
    !
    ! Get number of times to copy.
    !
    IF .X_S_BITS<OPB_DUPL> THEN
	NUM_COPIES = .X_S_BLOCK[SW_VAL1]
    ELSE
	NUM_COPIES = 1;
    !
    ! And finally, do the copy.
    !
    WF_SCOPY(.D_TBCB);
    INCR I FROM 1 TO .NUM_COPIES DO
	BEGIN
	WF_TOP();
	WHILE NOT WF_EOB() DO
	    BEGIN
	    WF_COPY_LINE(0);
	    WF_R_FORWARD();
	    END;
	END;
    WF_ECOPY(1);
    !
    ! Report the number of lines moved or copied.
    !
    F_COUNT(.NLINES,UPLIT(%STRING(' line')),5);
    IF .DELETE NEQ 0 THEN
	F_STRING(UPLIT(%STRING(' moved')),6)
    ELSE
	F_STRING(UPLIT(%STRING(' copied ')),8);
    IF .NUM_COPIES NEQ 1 THEN
	F_COUNT(.NUM_COPIES,UPLIT(%STRING(' time')),5);
    F_PUT();
    END;

!+
! Command processing for DEFINE KEY.
!
! Simply call the define key routine contained in the EDTCTRL module, and
! display an error message if it fails.
!-

ROUTINE DEFINE_COM : NOVALUE =
    BEGIN
    IF NOT E_K_DEF(.X_CUR_COM[KEY_VAL],.X_CUR_COM[AS_STR],.X_CUR_COM[AS_LEN]) THEN
        F_PUT_MESS(ERR_KEYNOTDEF);
    END;

!+
! Command processing routine for RESEQUENCE.
!
! 
ROUTINE RES_COM : NOVALUE =
    BEGIN
    LOCAL
	 COUNT,				! The number of lines in the range.
	 RANGE : REF NODE_BLOCK,		! Address of the range block
	 SWB : NODE_BLOCK;			! Address of the switch value block.
    !
    ! Check for the /SEQ option.  If not specified, then default the values
    ! to 1 and 1.
    !
    IF NOT .X_S_BITS<OPB_SEQ> THEN
	BEGIN
	X_S_BLOCK = SWB;
	MOVELINE(LNO_5,SWB[SW_VAL1]);
	MOVELINE(LNO_5,SWB[SW_VAL2]);
	END;
    !
    ! Check for the null range, making it WHOLE.
    !
    RANGE = .X_CUR_COM[RANGE1];
    IF .RANGE[RAN_TYPE] EQL RAN_NULL THEN
	RANGE[RAN_TYPE] = RAN_WHOLE;
    !
    ! Position to the first line of the range.
    !
    IF NOT RAN_POS(.RANGE) THEN RETURN;
    !
    ! If there is a preceding line, then make sure the starting line number
    ! is okay.
    !
    IF WF_R_BACKWRD() THEN
	BEGIN
	IF WF_COMP_LNO(W_LINE[LIN_NUM],X_S_BLOCK[SW_VAL1]) GEQ 0 THEN
	    BEGIN
	    F_PUT_MESS(ERR_RANSPCSEQ);
	    CH$MOVE(POS_SIZE,R_ORIG_POS,.E_TBCB);
	    WF_R_CURRENT();
	    RETURN;
	    END;
	WF_R_FORWARD();
	END;
    !
    ! Count the lines in the range.
    !
    COUNT = 0;
    WHILE RAN_NEXT(0) AND NOT WF_EOB() DO COUNT = .COUNT+1;
    !
    ! Reposition to the first line of the range.
    !
    RAN_REPOS();
    !
    ! Do the resequence.
    !
    WF_RESEQUENCE(.COUNT,X_S_BLOCK[SW_VAL1],X_S_BLOCK[SW_VAL2]);
    !
    ! Reposition to our place before starting the command.
    !
    CH$MOVE(POS_SIZE,R_ORIG_POS,.E_TBCB);
    WF_R_CURRENT();
    !
    ! And display the number of lines processed.
    !
    F_COUNT(.COUNT,UPLIT(%STRING(' line')),5);
    F_STRING(UPLIT(%STRING(' resequenced')),12);
    F_PUT();
    END;

!+
! Command processing routine for TABS ADJUST.
!
! Process each line in the range as follows:
!
!	1. Count the leading tabs and spaces.
!	2. Remove them all.
!	3. Add the tab increment value.
!	4. Re-insert a standard sequence of tabs and spaces.
!-

ROUTINE TADJ_COM : NOVALUE =
    BEGIN
    LOCAL
	RANGE : REF NODE_BLOCK,		! The range block
	CP,					! Character position
	EP,					! Position of end of line
	TC;					! Column number
    LITERAL
	TAB = 9;
    !
    ! Examine the range and if null, default to SELECT.
    !
    RANGE = .X_CUR_COM[RANGE1];
    IF .RANGE[RAN_TYPE] EQL RAN_NULL THEN RANGE[RAN_TYPE] = RAN_SELECT;
    !
    ! Position to the first line in the range.
    !
    RAN_POS(.RANGE);
    !
    ! Process each line in the range.
    !
    WHILE RAN_NEXT(0) AND NOT WF_EOB() DO
	BEGIN
	!
	! Initialize pointers to the beginning and end of the current line.
	!
	CP = CH$PTR(W_LINE[LIN_TEXT]);
	EP = CH$PLUS(.CP,.W_LINE[LIN_LENGTH]);
	!
	! Initialize the current column number.
	!
	TC = 0;
	!
	! Look for the first non-blank, non-tab character.
	!
	WHILE CH$PTR_NEQ(.CP,.EP) DO
	    BEGIN
	    SELECTONE CH$RCHAR(.CP) OF
		SET
		[%C' ']: TC = .TC + 1;
		[TAB]: TC = .TC + F_COL_INC(TAB,.TC);
		[OTHERWISE]: EXITLOOP;
		TES;
	    CP = CH$PLUS(.CP,1);
	    END;
	!
	! Determine the number of columns the line should be indented.  Do
	! not let it go below zero.
	!
	TC = MAX(0,.TC+.X_CUR_COM[TAB_COUNT]*.E_TAB);
	L_LEN = 0;
	!
	! Insert tabs and spaces into the new line.
	!
	INCR I FROM 1 TO .TC/8 DO PUT_CHAR(TAB);
	INCR I FROM 1 TO .TC MOD 8 DO PUT_CHAR(' ');
	!
	! And move the remainder of the old line.
	!
	CH$MOVE(CH$DIFF(.EP,.CP),.CP,CH$PTR(L_BUF,.L_LEN));
	L_LEN = .L_LEN + CH$DIFF(.EP,.CP);
	!
	! Replace it in the text buffer.
	!
	WF_REPLACE_LINE(L_BUF,.L_LEN);
	END;
    !
    ! Re-position to first line in the range.
    !
    RAN_REPOS();
    END;

!+
! Command processing for the FILL command.
!
! If the range is null, then assume SELECT.   Make sure the range
! is contiguous.  Count the number of lines, then call the FILL
! routine.
!-

ROUTINE FILL_COM : NOVALUE =
    BEGIN
    LOCAL
	RANGE : REF NODE_BLOCK,
	NLINES;
    RANGE = .X_CUR_COM[RANGE1];
    IF .RANGE[RAN_TYPE] EQL RAN_NULL THEN RANGE[RAN_TYPE] = RAN_SELECT;
    IF NON_CONTIG(.X_CUR_COM[RANGE1]) THEN RETURN;
    IF RAN_POS(.X_CUR_COM[RANGE1]) THEN
	BEGIN
	NLINES = 0;
	WHILE RAN_NEXT(0) AND NOT WF_EOB() DO NLINES = .NLINES+1;
	RAN_REPOS();
	FLL_FILL(.NLINES);
	END;
    END;

!+
! Command processing routine for DEFINE MACRO
!
! A new text buffer is created if it did not already exist, and it is
! added to the list of macros.  Each macro is described by a control
! block called a MAC_DESC which has a pointer to the TBCB for the macro
! and the address of the next MAC_DESC.
!-

ROUTINE DEF_MAC_COM : NOVALUE =
    BEGIN
    LOCAL
	SAVE_TBCB,
	RANGE : REF NODE_BLOCK,
	MAC_DESC : REF MAC_BLOCK;
    !
    ! Save current TBCB so we can get back,
    !
    SAVE_TBCB = .E_TBCB;
    RANGE = .X_CUR_COM[RANGE1];
    !
    ! Find or create the buffer to be defined.
    !
    IF U_F_BUFFER(.RANGE[BUF_NAME],.RANGE[BUF_LEN]) AND
       SYS_GET_MEM(%REF(MAC_SIZE),MAC_DESC) THEN
	BEGIN
	MAC_DESC[MAC_BUF] = .E_TBCB;
	MAC_DESC[MAC_NEXT] = .E_MAC_LIST;
	E_MAC_LIST = .MAC_DESC;
	END
    ELSE
	!
	! Memory allocation failed.  Put out a message.
	!
	F_PUT_MESS(ERR_INSMEM);
    !
    ! Position back to the original text buffer.
    !
    E_TBCB = .SAVE_TBCB;
    WF_R_CURRENT();
    END;

!+
! Command processing for CHANGE.
!
! This routine simply positions to the first line of the specified range
! and sets the current mode to change mode.
!-

ROUTINE CHANGE_COM : NOVALUE =
    BEGIN
    RAN_POS(.X_CUR_COM[RANGE1]);
    E_MODE = CHANGE_MODE;
    END;

!+
! Command processing for CLEAR.
!
! Position to the buffer to be cleared, then call the work file system
! to clear it.
ROUTINE CLEAR_COM : NOVALUE =
    BEGIN
    LOCAL
	SAVE_TBCB,
	RANGE : REF NODE_BLOCK;
    !
    ! Save the current TBCB so we can get back.
    !
    SAVE_TBCB = .E_TBCB;
    RANGE = .X_CUR_COM[RANGE1];
    IF U_F_BUFFER(.RANGE[BUF_NAME],.RANGE[BUF_LEN]) THEN
	WF_CLEAR();
    E_SCRCHG = .E_TBCB EQL .SAVE_TBCB;
    !
    ! Go back to the original buffer.
    !
    E_TBCB = .SAVE_TBCB;
    WF_R_CURRENT();
    END;

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine executes the command which was last parsed.
!	It is assumed that the command is described in the first
!	node on the parsing stack.
!
! FORMAL PARAMETERS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	P_STACK	-	The semantic stack containing the
!				command to be executed
!
! IMPLICIT OUTPUTS:
!
!	Everything to be accomplished by the command.
!	
!	E_EXITED 	-	Set to 1 if command was exit or quit.
!
! COMPLETION CODES:
!
!	none
!
! SIDE EFFECTS:
!
!	many
!
!--

GLOBAL ROUTINE X_COM(COM_START) : NOVALUE =
    BEGIN

    X_CUR_COM = .COM_START;
    IF .X_CUR_COM[NODE_TYPE] NEQ COM_NODE THEN
	BEGIN
	BUG_CHECK(NOT_COM);
	RETURN
	END;
    X_S_BLOCK = .X_CUR_COM[SWITS];
    IF .X_S_BLOCK NEQ 0 THEN
	BEGIN
	IF (.X_S_BLOCK[SW_BITS] AND
	    NOT .OPT_TABLE[.X_CUR_COM[COM_NUM]]) NEQ 0 THEN
	    BEGIN
	    F_PUT_MESS(ERR_INVOPTCOM);
	    RETURN;
	    END;
	X_S_BITS = .X_S_BLOCK[SW_BITS];
	END
    ELSE
	X_S_BITS = 0;
    X_QUERY_QUIT = 0;
    CASE .X_CUR_COM[COM_NUM] FROM COM_NULL TO LAST_COM OF
	SET

	[COM_QUIT]:
	    BEGIN
	    E_EXITED = 1;
	    F_PUT();
	    END;

	[COM_INSERT]: 
	    BEGIN
	    INS_COM();
	    E_SCRCHG = 1;
	    END;

	[COM_DELETE]: 
	    BEGIN
	    DEL_COM();
	    E_SCRCHG = 1;
	    END;

	[COM_TYPE]: 
	    BEGIN
	    TYPE_COM();
	    E_SCRCHG = 1;
	    END;

	[COM_NULL]: 
	    BEGIN
	    NULL_COM();
	    E_SCRCHG = 1;
	    END;

	[COM_FIND]: 
	    BEGIN
	    RAN_POS(.X_CUR_COM[RANGE1]);
	    E_SCRCHG = 1;
	    END;

	[COM_SUBS]: 
	    BEGIN
	    SUBS_COM();
	    E_SCRCHG = 1;
	    END;

	[COM_EXIT]: 
	    BEGIN
	    EXIT_COM();
	    END;

	[COM_REPLACE]: 
	    BEGIN
	    IF DELETE() THEN INSERT();
	    E_SCRCHG = 1;
	    END;

	[COM_INCLUDE]: 
	    BEGIN
	    INCL_COM();
	    E_SCRCHG = 1;
	    END;

	[COM_WRITE]: 
	    BEGIN
	    WRITE_COM();
	    E_SCRCHG = 1;
	    END;

	[COM_SUBS_NEXT]: 
	    BEGIN
	    SUBS_NEXT_COM();
	    E_SCRCHG = 1;
	    END;

	[COM_HELP]: 
	    BEGIN
	    HLP_COM(.X_CUR_COM[FILSPEC],.X_CUR_COM[FSPCLEN],1);
	    E_TXT = 1;
	    E_SCRCHG = 1;
	    END;

%(
	[COM_VERIFY]: 
	    BEGIN
	    VERIFY_COM();
	    END;
)%

	[COM_SET]: 
	    BEGIN
	    SET_COM();
	    END;

	[COM_SHOW]: 
	    BEGIN
	    SHOW_COM();
	    E_TXT = 1;
	    E_SCRCHG = 1;
	    END;

	[COM_CHANGE]:
	    BEGIN
	    CHANGE_COM();
	    E_SCRCHG = 1;
	    END;

	[COM_MOVE,COM_COPY]: 
	    BEGIN
	    MOVE_COM(.X_CUR_COM[COM_NUM] EQL COM_MOVE);
	    E_SCRCHG = 1;
	    END;

	[COM_DEFINE]: 
	    BEGIN
	    DEFINE_COM();
	    END;

	[COM_PRINT]: 
	    BEGIN
	    PRINT_COM();
	    E_SCRCHG = 1;
	    END;

	[COM_RESEQ]: 
	    BEGIN
	    RES_COM();
	    END;

	[COM_TADJ]: 
	    BEGIN
	    TADJ_COM();
	    E_SCRCHG = 1;
	    END;

	[COM_FILL]:
	    BEGIN
	    FILL_COM();
	    E_SCRCHG = 1;
	    END;

	[COM_DEF_MAC]: 
	    BEGIN
	    DEF_MAC_COM();
	    END;

	[COM_MAC_CALL]: 
	    BEGIN
	    E_M_CALL(.X_CUR_COM[RANGE1]);
	    E_SCRCHG = 1;
	    END;

	[COM_CLEAR]: 
	    BEGIN
	    CLEAR_COM();
	    END;

	[OUTRANGE]:
	    BEGIN
	    BUG_CHECK(BAD_COM);
	    END;

	TES;
    IF .E_EXITED THEN
	IF .X_S_BITS<OPB_SAVE> THEN
	    E_EXITED = 3;
    IF .E_RECOVER THEN E_EXITED = 0;
    END;


END
ELUDOM
