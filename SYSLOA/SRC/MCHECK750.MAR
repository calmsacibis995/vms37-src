	.TITLE	MCHECK750 - VAX 11/750 MACHINE CHECK HANDLER
	.IDENT	'V03-001'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
;
; FACILITY:
;
;	EXECUTIVE, ERROR HANDLING
;
; ABSTRACT:
;
;	MACHINE CHECK INTERRUPT AND ABORT HANDLER, MEMORY ECC ERROR LOGGER.
;	LOGS ERRORS AND ATTEMPTS TO CONTINUE IF POSSIBLE.
;
; ENVIRONMENT:
;
;	INTERRUPT STACK AT IPL 31 UNTIL ERROR IS IDENTIFIED.  IPL SYNCH TO
;	LOG ERRORS.
;
; SIDE EFFECTS:
;
;	IF ERROR IS UNRECOVERABLE OR ERROR IS RESULT OF INSTRUCTION EXECUTION
;	IN EXECUTIVE OR KERNAL MODE, THEN A FATAL BUG-CHECK IS TAKEN.
;
; AUTHOR:
;
;	C. SAMUELSON, APRIL, 1979
;
; MODIFIED BY:
;
;	V02-011	HRJ0050		Herb Jacobs		27-Jan-1982
;	V03-001	TCM0001		Trudy C. Matthews	5-Apr-1982
;		Altered table of resumable instructions to make all the
;		interlocked queue and the "reserved to DIGITAL" instructions
;		non-resumable.
;
;		Add global counts for machine checks and memory errors.
;		Fix bits for B0-BF restartable instructions mask.
;
;	V02-010	TCM0002		Trudy C. Matthews	14-Aug-1981
;		Corrected bug introduced in V02-008 that overwrote the
;		error log entry type for memory error logs with garbage.
;		Also, change Uncorrected Memory Error handling code to
;		not look at PFN data base or try to resume if page is
;		PFN-mapped.
;
;	V02-009	LJK0030		Lawrence J. Kenah	10-Jun-1981
;		Replace all PFN references to FLINK and BLINK with
;		the PFN_REFERENCE macro to support large physical
;		memory configurations.
;
;	V02-008	TCM0001		Trudy C. Matthews	8-May-1981
;		Change all references to RPB$B_CONFREG to refer to
;		EXE$GL_CONFREG instead.  Also change references to
;		MMG$AL_SBICONF to use MMG$GL_SBICONF.
;
;	V02-007	CAS0205		C. A. Samuelson		14-Aug-1980
;		Add global symbol deffinition for RH780 MBA error routine.
;
;	V02-006	CAS0001		C. A. Samuelson		9-Jun-1980
;		Add work-around for COMET micro-code bug
;		Fix handler to recover properly from control store errors
;
;--

	.PAGE
	.SBTTL	LOCAL SYMBOL DEFFINITIONS AND LOCAL DATA STORAGE
;++
; MACHINE CHECK INTERRUPT STACK OFFSETS
;--
	$DEFINI	MCK
$DEF	MCK_LENGTH	.BLKL	1	;LENGTH OF MACHINE CHECK STACK FRAME
$DEF	MCK_CODE	.BLKL	1	;MACHINE CHECK ERROR CODE
$DEF	MCK_VA		.BLKL	1	;VIRTUAL ADDRESS OF LAST FETCH/STORE
$DEF	MCK_ERROR_PC	.BLKL	1	;PROGRAM COUNTER AT TIME OF ABORT
$DEF	MCK_MDR		.BLKL	1	;MEMEORY DATA OF LAST FETCH/STORE
$DEF	MCK_SMR		.BLKL	1	;SAVED MODE REGISTER
	$VIELD	SMR,0,<-		;BITS DEFINED IN SAVED MODE REGISTER
		<MODE,2,M>-		;ACCESS MODE AT TIME OF ABORT
		<PV,,M>,-		;PHYSICAL/VIRTUAL FLAG
	>
$DEF	MCK_RLT		.BLKL	1	;READ LOCK TIMEOUT - WRITE VECTOR OCCURED
	$VIELD	RLT,0,<-		;BITS DEFINED IN READ LOCK TIMEOUT REGISTER
		<VMDR,,M>,-		;VECTOR IN MDR IF 1
	>
$DEF	MCK_TBP		.BLKL	1	;TRANSLATION BUFFER PARITY ERROR
	$VIELD	TBP,0,<-		;BITS IN TB PARITY REGISTER
		<GRP0D,,M>-		;GROUP 0 DATA ERROR
		<GRP1D,,M>-		;GROUP 1 DATA ERROR
		<GRP0T,,M>-		;GROUP 0 TAG ERROR
		<GRP1T,,M>-		;GROUP 1 TAG ERROR
	>
$DEF	MCK_CER		.BLKL	1	;CACHE ERROR REGISTER
	$VIELD	CER,0,<-		;BITS IN CACHE ERROR REGISTER
		<HIT,,M>-		;HIT IF 1
		<LOST,,M>-		;LOST ERROR
		<DATA,,M>-		;DATA ERROR
		<TAG,,M>-		;TAG ERROR
	>
$DEF	MCK_BER		.BLKL	1	;BUS ERROR REGISTER
	$VIELD	BER,0,<-		;BITS IN BUS ERROR REGISTER
		<CD,,M>-		;CORRECTED DATA
		<LOST,,M>-		;LOST ERROR
		<UCD,,M>-		;UNCORRECTED DATA
		<NEX,,M>-		;NON EXISTANT MEMORY
	>
$DEF	MCK_ESR		.BLKL	1	;ERROR SUMMARY REGISTER
	$VIELD	ESR,0,<-		;BITS IN SUMMARY REG
		<XB,,M>-		;INSTRUCTION BUFFER IF 1
		<,,M>-
		<TB,,M>-		;TRANSLATION BUFFER ERROR
		<CMI,,M>-		;CMI BUS ERROR
	>
$DEF	MCK_PC		.BLKL	1	;PC OF ABORTED OP-CODE
$DEF	MCK_PSL		.BLKL	1	;PSL AT TIME OF ABORT
	$DEFEND	MCK
 
;
; BITS DEFINED IN OTHER MEMORY CONTROL AND STATUS REGISTERS
;
	$VIELD	TBDR,0,<-		;TB DISABLE REGISTER
		<DG0,,M>-		;DISABLE GROUP 0
		<DG1,,M>-		;DISABLE GROUP 1
		<GRDP,,M>-		;REPLACE GROUP (0=GROUP 0,1=GROUP 1)
		<REPL,,M>-		;REPLACE
	>
	$VIELD	CADR,0,<-		;CACHE DISABLE REGISTER
		<DIS,,M>-		;DISABLE CACHE
	>
;
; 11/750 MEMORY CONTROLLER REGISTER DEFFINITIONS
;
	$DEFINI	MEM
$DEF	MEM$L_CSR0	.BLKL	1	;MEMORY CSR ZERO
	$VIELD	CSR0,0,<-		;BITS IN CSR0
		<SYN,7,M>-		;ERROR SYNDROME
		<,2,M>-
		<PAGE,15,M>-		;PAGE WHERE ERROR OCCURED
		<,5,>-
		<COREF,,M>-		;CORRECTABLE ERROR FLAG
		<EILOS,,M>-		;ERROR INFORMATION LOST FLAG
		<UNCER,,M>-		;UNCORRECTABLE ERROR FLAG
	>
$DEF	MEM$L_CSR1	.BLKL	1	;MEMORY CSR 1
	$VIELD	CSR1,0,<-		;BITS IN MEMORY CSR 1
		<CHCK,7,M>-		;DIAGNOSTIC CHECK BITS
		<,2,>-
		<PMA,15,M>-		;PAGE MODE ADDRESS
		<,1,>-
		<ECCD,,M>-		;ECC DISABLE MODE
		<DIAG,,M>-		;DIAGNOSTIC CHECK MODE
		<PMOD,,M>-		;DIAGNOSTIC PAGE MODE
		<IERP,,M>-		;INHIBIT CORRECTABLE ECC ERROR REPORTS
		<,3,>-
	>
$DEF	MEM$L_CSR2	.BLKL	1	;MEMORY PRESENT MAP
	$DEFEND	MEM
;
; INCLUDED SYSTEM SYMBOL DEFFINITIONS
;
	$EMBDEF	<MC>			;DEFINE EMB OFFSETS AND VALUES
	$IPLDEF				;DEFINE PROCESSOR INTERRUPT LEVELS
	$MCHKDEF			;DEFINE RECOVERY BLOCK MASK BITS
	$MPMDEF				;MULTIPORT MEMORY
	$PCBDEF				;DEFINE PROCESS CONTROL BLOCK
	$PFNDEF				;DEFINE PFN DATABASE
	$PRDEF				;DEFINE PROCESSOR REGISTERS
	$PSLDEF				;DEFINE PSL
	$PTEDEF				;DEFINE PTE SYMBOLS
	$RPBDEF				;DEFINE RPB
 
 
;
; LOCAL DATA STORAGE
;
	.PSECT	$$$260,QUAD,WRT
 
TB_THRESHOLD = 10			;ALLOWABLE TIME BETWEEN TB ERRORS
CH_THRESHOLD = 10			;ALLOWABLE TIME BETWEEN CACHE ERRORS
CRDINTMAX = 3				;NO. OF CORRECTED MEMORY ERRORS TO LOG
CRDWATCHMAX = 6				;NO. OF ERRORS TO LOG IN REENABLE TIME
SOMETIME = 60				;SCAN FOR NON INTERRUPT ERRORS EVER 60 SECONDS
REENABTIME = 60*15			;RENENABLE INTERRUPT ERROR LOGGING TIME
 
; THE FOLLOWING SYMBOL IS DEFINED FOR A TRANSFER VECTOR IN SYSLOAVEC.
; IT IS  N O T  J U M P E D  T O O !!!   IT IS USED TO DEFINE A GLOBAL
; SYMBOL IN THE SYSTEM MAP (SYS.MAP) TO LOCATE THESE COUNTERS.
 
EXE$MCHK_ERRCNT::
EXE$GL_TB1AOLD::	.LONG	0	;TIME OF LAST TB ERROR, GROUP 0
EXE$GL_TB2AOLD::	.LONG	0	;TIME OF NEXT TO LAST TB ERROR, GROUP 0
EXE$GL_TB1BOLD::	.LONG	0	;TIME OF LAST TB ERROR, GROUP 1
EXE$GL_TB2BOLD::	.LONG	0	;TIME OF NEXT TO LAST TB ERROR, GROUP 1
ECC$AB_MEMERR::	.BLKB	16		;MEMORY ERROR COUNTERS FOR 16 SLOTS
 
EXE$GL_CH1OLD::	.LONG	0		;TIME OF LAST CACHE ERROR
EXE$GL_CH2OLD::	.LONG	0		;TIME OF NEXT TO LAST CACHE ERROR
EXE$GL_CHSTATE::.LONG	0		;CURRENT STATE OF CACHE
					; 1 = DISABLED, 0 = ENABLED
ECC$GW_WATCH::	.WORD	0		;SCAN MEMEORY CONTROLLER TIMER
ECC$GW_REENAB::	.WORD	0		;REENABLE TIMER
MMG$GL_CRDCNT::	.LONG	0		;COUNT OF CORRECTED MEMORY ERRORS
EXE$GL_BADTIMOUT::
		.LONG	0		;TIME SINCE LAST BAD MCHK CODE
EXE$GL_VECTIMOUT::
		.LONG	0		;TIME SINCE LAST UNDEFINED VECTOR INT

	.SBTTL	MACHINE CHECK ENTRY POINTS
	.PSECT	WIONONPAGED,QUAD,RD,WRT
;++
; ALL MACHINE CHECK ABORTS ARE VECTORED HERE.  11/750
; MACHINE CHECK FOR ALL CONDITIONS RESULTS IN THE SAME STACK FRAME.  THUS
; WE CAN DISPATCH FROM HERE ACCORDING TO THE ERROR CODE.
; ENTRY IPL=31=^X1F FOR ABORTS
;--
 
	.ALIGN	LONG
 
EXE$MCHK::				;MACHINE CHECK EXCEPTION
 
	INVALID				;INVALIDATE TRANSLATION BUFFER
	MTPR	#CADR$M_DIS,#PR$_CADR	;DISABLE CACHE
	PUSHL	#MCHK$M_LOG		;MASK FOR PRTCTEST
	PUSHAL	MCK_PC+4(SP)		;PC,PSL POINTER FOR PRTCTEST
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,AP> ;GET SOME WORKING REGISTERS
	ADDL3	#<9*4>,SP,AP		;POINT AP TO MACHINE CHECK LOG FRAME
					;EXTRACT ERROR CODE FIELD FROM STACK
	CASE	MCK_CODE(AP),<-		;DISPATCH ON ERROR TYPE CODE
		BAD_TYPE,-		;NO CODE 0
		CS_PARITY,-		;CONTROL STORE PARITY ERROR
		TB_BUS,-		;TB ERROR, BUS ERROR (UNCORRECTED READ)
		BAD_TYPE,-		;NO CODE 3 (USED TO BE CACHE PARITY)
		BAD_TYPE,-		;NO CODE 4 (USED TO BE CRD)
		BAD_TYPE,-		;NO CODE 5 (USED TO BE AWE)
		FUBAR,-			;NOT SUPPOSED TO BE HERE - CS LOCATION
		IRD_SLOT>, TYPE=B	;UNUSED IRD ROM SLOT
BAD_TYPE:				;UNDEFINED EXCEPTION ERROR CODE
	MTPR	W^EXE$GL_CHSTATE,#PR$_CADR ;RE-ENABLE THE CACHE
	BISL	#MCHK$M_MCK,-4(AP)	;MASK FOR PRTCTEST
	MOVZWL	#EMB$K_MC,R3		;LOG TYPE FOR ERROR REPORTING
	PUSHL	W^EXE$GL_BADTIMOUT	;TIME OF LAST BAD CODE MCHK
	MFPR	#PR$_TODR,W^EXE$GL_BADTIMOUT ;SET TIME OF THIS ONE
	CMPL	(SP)+,W^EXE$GL_BADTIMOUT ;COMMING TOO FAST?
	BEQL	100$			;YES, SOMETHING IS WRONG
	BRW	TRYRESUME		;LOG IT, CONTINUE AND HOPE FOR THE BEST
100$:
	POPR	#^M<R0,R1,R2,R3,R4,R5,AP>	;RESTORE REGISTERS
	JSB	G^EXE$MCHK_BUGCHK	;RECOVERY BLOCK IN EFFECT?
					;RECOVERY FROM THIS TYPE OF MACHINE
					;CHECK IS VERY DUBIOUS - SOMETHING
					;MUST BE BROAKEN TO KEEP GETTING THIS
 
	BUG_CHECK	BADMCKCOD,FATAL	;BAD MACHINE CHECK CODE
 
;
; THE FOLLOWING VECTORS ARE VESTIGAL FROM THE 11/780 SBI
; THEY ARE NOT DEFINED IN COMET.
; IF WE VECTOR HERE, EITHER THE HARDWARE GLITCHED OR SOMETHING
; IS VERY BROAKEN.   THUS, IGNORE INTERRUPTS IF THEY DON'T COME
; VERY FAST.  ELSE, CRASH - AND CALL YOUR LOCAL REPAIR MAN.
;
 
	.ALIGN	LONG			;VECTORED TO
 
EXE$LOGSBF::				;SBI FAULT
EXE$LOGSBA::				;SBI ALERT
EXE$INT58::
EXE$INT5C::
EXE$DW780_INT::				;DEFINED FOR SYSLOAVEC, NOT USED IN 750
EXE$RH780_INT::				;DEFINED FOR SYSLOAVEC, NOT USED IN 750
 
	PUSHL	#MCHK$M_MCK		;MASK FOR PRTCTEST
	PUSHAL	4(SP)			;PC,PSL POINTER FOR PRTCTEST
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	;SAVE SOME REGISTERS
	PUSHL	W^EXE$GL_VECTIMOUT	;TIME SINCE LAST ERROR
	MFPR	#PR$_TODR,W^EXE$GL_VECTIMOUT ;SAVE TIME OF THIS ERROR
	CMPL	(SP)+,W^EXE$GL_VECTIMOUT ;ERRORS COMMING TOO FAST?
	BNEQ	200$			;NO, TRY AND CONTINUE
	 
	POPR	#^M<R0,R1,R2,R3,R4,R5>	;RESTORE REGISTERS
	JSB	G^EXE$MCHK_BUGCHK	;RECOVERY BLOCK IN EFFECT?
	BUG_CHECK BADMCKCOD,FATAL	;NO, CRASH
 
200$:
	MOVQ	<6*4>(SP),R1		;SET UP TO LOG THE ERROR
	MOVZWL	#EMB$K_SI,R3		;UNEXPECTED INTERRUPT
	MOVL	#<2*4>,R4		;LOG PC,PSL
	MOVAL	<8*4>(SP),R5		;POINT TO LOG ENTRY
	BSBW	LOGGER			;LOG THE ERROR
	JSB	G^EXE$MCHK_TEST		;RECOVERY BLOCK IN EFFECT?
	BLBS	R0,201$			;YES, DO NOT LOG THIS ERROR
	INCL	G^EXE$GL_MCHKERRS	; BUMP THE GLOBAL MACHINE CHECK COUNTER
201$:	POPR	#^M<R0,R1,R2,R3,R4,R5>	;RESTORE REGISTERS
	ADDL	#<2*4>,SP		;REMOVER PRTCTEST STUFF
	REI				;LETS HOPE THINGS ARE OK

	.PAGE
	.SBTTL	CONTROL STORE PARITY ERRORS
;
; CONTROL STORE PARITY ERROR ABORT
; NOT SUPPOSED TO BE HERE - UNUSED C/S LOCATION
; UNUSED IRD ROM SLOT ABORT
;
; LOG THE ERROR
; IF ERROR WAS IN KERNAL OR EXECUTIVE MODE, DECLARE A FATAL BUG-CHECK
; IF ERROR WAS IN USER OR SUPERVISOR MODE, PASS EXCEPTION TO PROCESS
; 
 
CS_PARITY:				;CONTROL STORE PARITY ERROR ABORT
FUBAR:					;NOT SUPPOSED TO BE HERE ABORT
IRD_SLOT:				;UNUSED IRD ROM SLOB ABORT
 
	MTPR	W^EXE$GL_CHSTATE,#PR$_CADR ;CACHE OK, ENABLE IT
	BISL	#MCHK$M_MCK,-4(AP)	;MASK FOR PRTCTEST
	MOVZBW	@MCK_PC(AP),MCK_ESR+2(AP) ;SAVE OP-CODE THAT FAULTED
	MOVZWL	#EMB$K_MC,R3		;SET ERROR TYPE IN R3
	BSBW	LOGIT			;LOG ERROR
	BRW	TRYRESUME		;CONTINUE IF POSSIBLE
;
; 

	.PAGE
	.SBTTL	ASYNCHRONOUS WRITE ERROR INTERRUPT
;
; THIS ERROR IS CAUSED WHEN CMI WRITE OPERATION DID NOT COMPLETE SUCCESSFULLY.
; THERE COULD BE ANY NUMBER OF REASONS FOR THIS.  THE CMI COULD BE BROAKEN
; (UNLIKELY, SINCE WE WOULDN'T HAVE GOTTEN THIS FAR) OR AN ADAPTER ON THE CMI
; COULD BE BROAKEN.  THERE IS NO SPECIFIC CODE HERE TO LOOK FOR A BROAKEN
; DEVICE.  SUSPECTED DEVICES COULD BE MEMORY, DR750, MA750, OR ICCS.
; ANOTHER CAUSE IS WRITE TO NON-EXISTANT ADDRESS.
;
 
	.ALIGN	LONG
 
EXE$LOGAWE::
EXE$INT60::
	SUBL	#<10*4>,SP		; KLUDGE UP STACK TO LOOK LIKE MACHINE CHECK
	MOVZBL	#5,(SP)			; THIS IS THE TYPE - REST OF FRAME GARBAGE
	MOVZBL	#^X28,-(SP)		; LENGTH OF MACHINE CHECK ERROR FRAME
	PUSHL	#MCHK$M_LOG!MCHK$M_MCK!MCHK$M_NEXM ;MASK FOR PRTCTEST
	PUSHAL	MCK_PC+4(SP)		; AND PC POINTER
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,AP> ; SAVE REGISTERS
	ADDL3	#<9*4>,SP,AP		; POINT AP TO FAKE MACHINE CHECK LOG
	MOVZWL	#EMB$K_AW,R3		; ERROR TYPE
	MOVZBL	#<2*4>,R4		; SIZE OF LOG ENTRY (PC,PSL)
	MOVAB	MCK_PC(AP),R5		; ADDRESS OF LOG ENTRY (ON STACK)
	BSBW	LOGGER			; LOG THE ERROR
	JSB	G^EXE$MCHK_TEST		;RECOVERY BLOCK IN EFFECT?
	BLBS	R0,10$			;YES, DO NOT LOG THIS ERROR
	INCL	G^EXE$GL_MCHKERRS	; BUMP THE GLOBAL MACHINE CHECK COUNTER
10$:	BRW	REFLECTCHK		; CONTINUE IF USER OR SUPER MODE

	.PAGE
	.SBTTL	TB, BUS, CACHE PARITY
;
; TRANSLATION BUFFER ERROR ABORT
; CMI BUS ERROR ABORT (UNCORRECTED READ)
; CACHE PARITY ERRORS
;
; LOG ERROR
;
; HANDLE TRANSLATION BUFFER ERROR AS FOLLOWS
;
;	INVALIDATE TB
;	IF MANY RECENT TB ERRORS, DISABLE HALF OF TB
;	IF THIS RESULTS IN BOTH HALVES DISABLED, BUG CHECK
;	ELSE IF THE INSTRUCTION IS RESUMABLE, TRY TO RESTART IT
;	ELSE IF THE ABORT WAS IN EXEC OR KERNAL MODE, BUG CHECK
;	ELSE REFLECT ERROR TO USER OR SUPERVISOR AS EXCEPTION
;
;
; HANDLE BUS ERRORS AS FOLLOWS
;
;	IF THE INSTRUCTION WAS RESUMABLE, TRY AND RESTART
;	ELSE IF THE ABORT WAS IN EXEC OR KERNAL MODE, BUG CHECK
;	ELSE REFLECT ERROR TO USER OR SUPERVISOR MODE AS EXCEPTION
;
; HANDLE CACHE ERRORS AS FOLLOWS
;
;	IF MANY RECENT CACHE ERRORS, DISABLE CACHE
;	IF ERROR WAS IN USER OR SUPERVISOR MODE, REFLECT ERROR TO PROCESS
;	ELSE ISSUE A FATAL BUG-CHECK
;
	.ENABLE	LSB
 
TB_BUS:
 
	MTPR	MCK_ESR(AP),#PR$_MCESR	;CLEAR PROCESSOR ERROR BITS
	BBC	#ESR$V_TB,MCK_ESR(AP),BUS_CACHE ;BRANCH IF NOT TB ERROR
	MTPR	W^EXE$GL_CHSTATE,#PR$_CADR ;CACHE PROBABLY OK, ENABLE IT
	BISL	#MCHK$M_MCK,-4(AP)	;MASK FOR PRTCTEST
 
; TRANSLATION BUFFER ERRORS HANDLED HERE
 
	MOVZWL	#EMB$K_MC,R3		;PLACE ERROR TYPE IN R3 FOR LOGGER
	MFPR	#PR$_TODR,R0		;CURRENT TIME IN 10MS TICKS
	MFPR	#PR$_TBDR,R1		;GET TB DISABLE REGISTER
 
; DISCOVER WHICH HALF OF TB THE ERROR IS IN
 
	BITL	MCK_TBP(AP),#<TBP$M_GRP0D!TBP$M_GRP0T>
					;HANDLE EACH HALF SEPARATELY
	BEQLU	20$			;ERROR IN SECOND HALF
 
; ERROR IS IN FIRST HALF OF TB
 
	SUBL3	W^EXE$GL_TB1AOLD,R0,R2	;HOW LONG SINCE LAST ERROR?
	CMPL	R2,#TB_THRESHOLD	;ERRORS COMMING TOO FAST?
	BGTRU	10$			;NO, CONTINUE
 
; DISABLE FIRST HALF OF TB
 
	BBS	#TBDR$V_DG1,R1,TB_BAD	;BOTH HALVES BAD, FATAL ERROR
	MTPR	#<TBDR$M_DG0!TBDR$M_GRDP!TBDR$M_REPL>,#PR$_TBDR ;DISABLE
					;AND FORCE REPLACEMENT IN OTHER GROUP
	MOVZBW	#TBDR$M_DG0,MCK_TBP+2(AP) ;LOG THAT WE DID IT
 
; REMEMBER HISTORY OF GROUP 0 TB ERRORS
 
10$:	MOVL	W^EXE$GL_TB1AOLD,W^EXE$GL_TB2AOLD ;TIME OF LAST TO NEXT TO LAST
	MOVL	R0,W^EXE$GL_TB1AOLD	;TIME OF THIS TO TIME OF LAST
	BRW	TRYRESUME		;TRY TO RECOVER
 
; ERROR IS IN SECOND HALF OF TB
 
20$:	SUBL3	W^EXE$GL_TB1BOLD,R0,R2	;TIME SINCE LAST ERROR IN 2nd HALF
	CMPL	R2,#TB_THRESHOLD	;ERRORS COMMING TOO FAST?
	BGTRU	25$			;NO, CONTINUE
 
; DISABLE 2ND HALF OF TB
 
	BBS	#TBDR$V_DG0,R1,TB_BAD	;BRANCH IF OTHER HALF BAD ALSO
	MTPR	#<TBDR$M_DG1!TBDR$M_REPL>,#PR$_TBDR ;DISABLE 2ND HALF
	MOVZBW	#TBDR$M_DG1,MCK_TBP+2(AP) ;LOG THAT WE DID IT
 
; REMEMBER HISTORY OF GROUP 1 TB ERRORS
 
25$:	MOVL	W^EXE$GL_TB1BOLD,W^EXE$GL_TB2BOLD ;TIME OF LAST TO NEXT TO LAST
	MOVL	R0,W^EXE$GL_TB1BOLD	;TIME OF THIS TO TIME OF LAST
	BRW	TRYRESUME		;TRY TO RECOVER
 
; BOTH HALVES OF TB BAD, LOG ERROR AND CRASH
 
TB_BAD:
	BSBW	LOGIT			;LOG THE ERROR
	BUG_CHECK MACHINECHK,FATAL	;FATAL ERROR - BOTH HALVES OF TB BAD
 
; CMI BUS ERRORS HANDLED HERE
 
; EXAMINE BUS ERROR REGISTER TO FIND OUT WHAT HAPPENED
 
BUS_CACHE:
	BBS	#CER$V_DATA,MCK_CER(AP),26$ ;BRANCH IF CACHE DATA ERROR
	BBC	#CER$V_TAG,MCK_CER(AP),27$ ;BRANCH IF NOT CACHE TAG ERROR
26$:	BRW	CH_PARITY		; HANDLE CACHE PARITY ERRORS

27$:	BBS	#BER$V_UCD,MCK_BER(AP),UCD ;BRANCH IF UNCORRECTED DATA
	BBS	#BER$V_NEX,MCK_BER(AP),BUS ;BRANCH IF NON-EXISTANT REFFERENCE
	BRW	BAD_TYPE		; CANNOT IDENTIFY ERROR TYPE
 
; THE ERROR WAS CAUSED BY NON-EXISTANT MEMORY ON A READ
 
BUS:
	MTPR	W^EXE$GL_CHSTATE,#PR$_CADR ;CACHE PROBABLY OK, ENABLE IT
	BISL	#MCHK$M_NEXM!MCHK$M_MCK,-4(AP) ;MASK FOR PRTCTEST
	MOVZWL	#EMB$K_MC,R3		;HANDLE AS A MACHINE CHECK
	BSBW	LOGIT			;LOG THE ERROR
	BRW	REFLECTCHK		;CONTINUE IF USER OR SUPER MODE
 
 
;++
; UNCORRECTED MEMORY READ ERROR (READ DATA SUBSTITUTE)
; ATTEMPT TO REPLACE PAGE WITH A GOOD ONE
; PAGE CAN BE REPLACED IF
;	FAULT OCCURED AT PAGEABLE PRIORITY
;	PAGE WAS VALID FOR THE ACCESSING PROCESS
;	PAGE WAS NOT MODIFIED OR IS READ-ONLY
;	INSTRUCTION CAUSING PROBLEM IS RESUMABLE
;	NO I/O WAS IN PROGRESS FOR THE PAGE
;	PAGE IS SYSTEM OR PROCESS PRIVATE
; BAD PAGE IS PLACED ON BAD PAGE LIST
;--
 
UCD:
	MTPR	W^EXE$GL_CHSTATE,#PR$_CADR	;CACHE PROBABLY OK, ENABLE IT
	BISL	#MCHK$M_MCK,-4(AP)	;MASK FOR PRTCTEST	**************
	EXTZV	#PSL$V_IPL,#PSL$S_IPL,MCK_PSL(AP),R0 ;GET IPL
	CMPL	R0,#IPL$_ASTDEL		;ARE WE AT NON-PAGEABLE PRIORITY?
	BGTR	NO_RESUME		;NO, NOTHING WE CAN DO
 
	MOVL	MCK_VA(AP),R2		;GET VIRTUAL ADDRESS OF ERROR
	MOVL	G^SCH$GL_CURPCB,R4	;CURRENT USER'S PCB ADDRESS
	MOVL	PCB$L_PHD(R4),R5	;PROCESS HEADER ADDRESS
	JSB	G^MMG$SVAPTECHK		;TURN VA INTO VA OF PTE
	MOVL	(R3),R0			;GET THE PTE WHICH MAPS THE BAD PAGE
	BLSS	28$			;BRANCH IF PAGE VALID FOR THIS PROCESS
 
 
; PROCESS EXECUTED A READ TO A NON VALID PAGE, CRASH
 
RDSNONRES:
 
	POPR	#^M<R0,R1,R2,R3,R4,R5,AP> ;RESTORE REGISTERS
	JSB	G^EXE$MCHK_BUGCHK	;RECOVERY BLOCK IN EFFECT?
 
	BUG_CHECK RDSNONRES,FATAL	;FATAL BUG-CHECK
 
 
	ASSUME	PTE$V_PFN EQ 0
 
28$:
	BBS	#PTE$V_WINDOW,R0,NO_RESUME
					;BRANCH IF PAGE IS PFN-MAPPED
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R0,R0
					;ISOLATE PAGE FRAME NUMBER IN PTE
	CMPL	R0,G^MMG$GL_MAXPFN	;PFN DATA BASE FOR THIS PAGE?
	BGTRU	NO_RESUME		;NO, CANNOT CONTINUE
	MOVL	G^PFN$AB_TYPE,-(SP)	;GET ADDRESS OF PFN TYPE ARRAY *******
	BISB	#PFN$M_BADPAG,@(SP)+[R0];MARK PAGE BAD		**************
	CLRL	R1			;CLEAR MODIFY BIT FLAG
	BBCC	#PTE$V_MODIFY,(R3),30$	;TEST AND CLEAR MODIFY BIT IN PTE
	MOVZBL	#PFN$M_MODIFY,R1	;SET MODIFY BIT FLAG
30$:	MOVL	G^PFN$AB_STATE,-(SP)	;ADDRESS OF PFN STATE	**************
	BISB	R1,@(SP)+[R0]		;SET MODIFY BIT FLAG IN PFN DATABASE **
 
	ASSUME	PFN$M_MODIFY EQ 128
 
	BGEQ	33$			;PAGE NOT MODIFIED, CONTINUE
 
 
; FOR ANY OF THE VARIOUS REASONS, CANNONT TRY TO RESUME INSTRUCTION STREAM
 
NO_RESUME:
	MOVZBL	#EMB$K_HE,R3		;ERROR TYPE FOR ERROR LOGGER
	BSBW	EXE$LOGMEM		;LOG THE MEMORY ERROR
	MOVZWL	#EMB$K_MC,R3		;LOG A MACHINE CHECK ERROR
	BSBW	LOGIT
	BRW	REFLECTCHK		;CONTINUE ONLY IF USER OR SUPER MODE
 
33$:	MOVZBL	@MCK_PC(AP),-(SP)	;GET OPCODE FOR RESUMEABILITY CHECK
	BBC	(SP)+,W^RESUMABLE,NO_RESUME ;BRANCH IF CANNOT RESUME INSTRUCTION
 
	MOVL	G^PFN$AW_REFCNT,-(SP)	;GET ADDRESS OF PFN REFCNT ARRAY ******
	CMPW	@(SP)+[R0],#1		;CHECK FOR I/O IN PROGRESS *************
	BGTRU	NO_RESUME		;IF SO, DON'T MESS WITH PAGE
 
	MOVL	G^PFN$AB_TYPE,-(SP)	;ADDRESS OF PFN TYPE ARRAY  *********
	CMPV	#PFN$V_PAGTYP,#PFN$S_PAGTYP,@(SP)+[R0],#PFN$C_SYSTEM ;*****
					;CHECK TO SEE IF SYSTEM OR GLOBAL PAGE
 
	ASSUME	PFN$C_SYSTEM EQ 1
	ASSUME	PFN$C_PROCESS EQ 0
 
	BGTRU	NO_RESUME		;BRANCH IF GLOBAL PAGE
 
	TSTL	R2			;TEST THE VIRTUAL ADDRESS
	BGTR	35$			;BRANCH IF PAGE IS PROCESS PRIVATE
	MOVAB	G^MMG$AL_SYSPCB,R4	;SYSTEM WORKING SET LIST
	MOVL	PCB$L_PHD(R4),R5
35$:	BBCC	#PTE$V_VALID,(R3),40$	;CLEAR VALID BIT FROM PTE
40$:	INVALID	R2			;INVALIDATE TRANSLATION BUFFER OF VA
	MOVL	G^PFN$AW_REFCNT,-(SP)	;ADDRESS OF PFN REFCNT ARRAY  *******
	DECW	@(SP)+[R0]		;DECREMENT REFERENCE COUNT FOR PAGE ****
	BGEQ	50$
	JSB	G^MMG$REFCNTNEG
50$:
	MOVL	G^PFN$Ax_WSLX,-(SP)	;ADDRESS OF WORK SET LIST  **********
		PFN_REFERENCE	-
	MOVZWL	<@(SP)+[R0],R1>,-		;WORKING SET LIST INDEX FOR PAGE ******
		LONG_OPCODE=MOVL,-
		IMAGE=SYSLOA750.EXE
	JSB	G^MMG$DELWSLEX		;DELETE PAGE FROM WORKING SET
	JSB	G^MMG$DELCONPFN		;DELETE PAGE FROM PAGE TABLE
	MOVZBL	#PFN$C_BADPAGLST,R2
	JSB	G^MMG$INSPFNT		;PUT PAGE ON BAD PAGE LIST
 
	MOVZWL	#EMB$K_HE,R3		;PLACE ERROR TYPE IN R3
	BSBW	EXE$LOGMEM		;LOG MEMORY ERROR
	MOVZWL	#EMB$K_MC,R3		;LOG MACHINE CHECK
 
;
; TRYRESUME - TRY TO RESTART AN INSTRUCTION AFTER A FAULT
;
;	IF PROCESSOR MODE WAS NOT CHANGED DURING EXECUTION OF INSTRUCION
;	IF INSTRUCTION IS LISTED AS RETRIABLE IN TABLE
;	IF INSTRUCIION IS SINGLE BYTE INSTRUCTION
;    THEN - RESTART
;
; INPUTS - R3 CONTAINS ERROR TYPE FOR ERROR LOGGING
;
 
TRYRESUME:				; TRY TO RESUME DEPENDING ON OP-CODE
 
	BSBW	LOGIT			;MACHINE CHECK ERROR LOGGER
	EXTZV	#SMR$V_MODE,#SMR$S_MODE,MCK_SMR(AP),R5
					;GET MODE AT TIME OF FAULT
	CMPZV	#PSL$V_CURMOD,#PSL$S_CURMOD,MCK_PSL(AP),R5
					;COMPARE WITH MODE WHEN FAULT WAS DISCOVERED
	BNEQU	70$			;IF NOT EQUAL, DON'T TRY TO RESUME
	MOVZBL	@MCK_PC(AP),R5		;FETCH OP-CODE
	BBC	R5,W^RESUMABLE,70$	;LOOK UP OP-CODE IN TABLE
 
	POPR	#^M<R0,R1,R2,R3,R4,R5,AP> ;IF BIT IS SET, RETRY INSTRUCTION
	ADDL	#<2*4>,SP		;REMOVE PRTCTEST STUFF
	ADDL	(SP)+,SP		;CLEAR LOG OFF STACK
	REI
 
70$:
	BRW	REFLECTCHK		;ELSE CONTINUE DEPENDING ON ACCESS MODE
 
	.DSABL	LSB

	.PAGE
	.SBTTL	CACHE PARITY ERRORS
;
; CACHE PARITY ERROR HANDLER
;
; LOG ERROR
;
; IF MANY RECENT CACHE ERRORS, DISABLE CACHE
; IF ERROR WAS IN USER OR SUPERVISOR MODE, REFLECT ERROR TO PROCESS
; ELSE ISSUE A FATAL BUG-CHECK
;
 
CH_PARITY:				;CACHE PARITY ERROR HANDLER
 
	MOVZWL	#EMB$K_MC,R3		;PLACE ERROR TYPE IN R3 FOR LOGING
	BISL	#MCHK$M_MCK,-4(AP)	;MASK FOR PRTCTEST
	MFPR	#PR$_TODR,R0		;CURRENT TIME IN 10MS TICKS
	SUBL3	W^EXE$GL_CH1OLD,R0,R1	;TIME SINCE LAST ERROR
	CMPL	R1,#CH_THRESHOLD	;ERRORS COMING TOO FAST?
	BGTRU	30$			;NO, CONTINUE
 
;
; TOO MANY CACHE ERRORS IN TIME INTERVAL, DISABLE CACHE PERMANENTLY
;
	MOVZBW	#CADR$M_DIS,MCK_CER+2(AP) ;LOG THAT WE DISABLED CACHE
	MOVZBL	#CADR$M_DIS,W^EXE$GL_CHSTATE ;RESET CURRENT CACHE STATE
 
;
; LOG ERROR - CONTINUE IF IN USER OR SUPERVISOR MODE
;
 
30$:
	MTPR	W^EXE$GL_CHSTATE,#PR$_CADR ;RE-ENABLE CACHE IF OK
	MOVL	W^EXE$GL_CH1OLD,W^EXE$GL_CH2OLD ;SAVE TIME OF LAST ERROR
	MOVL	R0,W^EXE$GL_CH1OLD	;SAVE TIME OF THIS ERROR
	MTPR	MCK_CER(AP),#PR$_CAER	;CLEAR ERROR BITS
	BRB	TRYRESUME		;TRY TO RESUME DEPENDING ON OP-CODE

	.PAGE
	.SBTTL	CORRECTED MEMORY DATA INTERRUPTS
;
; CM_DATA - CORRECTED MEMORY DATA INTERRUPT HANDLER
;
; LOG ALL INTERRUPTS
; IF TOO MANY INTERRUPTS ARE RECEIVED, THE MEMORY ERROR LOGGER WILL TURN
; OFF THE CRD INTERRUPT BIT.
;
; CONTINUE ALWAYS
;
 
	.ALIGN	LONG			;VECTORED TO
 
EXE$LOGCRD::				;CORRECTED MEMORY DATA INTERRUPT
EXE$INT54::
 
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>
	INCL	W^MMG$GL_CRDCNT		;COUNT CORRECTED MEMORY ERRORS
	MOVZWL	#EMB$K_SE,R3		;SOFT ERROR
	BSBW	EXE$LOGMEM		;LOG A MEMORY ERROR
	POPR	#^M<R0,R1,R2,R3,R4,R5>
	REI				;AND RETURN
 
;
; ECC$REENABLE - TIMER CALL FROM SYSTEM CLOCK ROUTINE
;
; THIS ROUTINE SCANS ALL MEMEORY CONTROLLERS FOR CORRECTED ECC ERRORS
; WHICH HAVE EITHER BEEN CAUSED BY A READ ISSUED FROM AN I/O DEVICE OR
; WHICH HAVE OCCURED WHEN CRD INTERRUPTS ARE TURNED OFF.  IF A MEMORY
; ERROR HAS OCCURED, ALL MEMORY CSR'S ARE LOGGED.
;
ECC$REENABLE::				;RE-ENABLE CORRECTED MEMORY DATA INTERRUPTS
 
	DECW	W^ECC$GW_WATCH		;TIME TO SCAN MEMORY CONTROLLER?
	BGTR	50$			;NOT YET IF GTR
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6>	;SAVE WORKING REGISTERS
	MOVL	#15,R6			;R0 INDEXES AND COUNTS SLOTS
	MOVL	G^EXE$GL_CONFREG,R3	;ARRAY OF NEXUS DEVICE TYPE CODES
	MOVL	G^MMG$GL_SBICONF,R5	;ARRAY OF ADAPTER VA'S
	DSBINT				;DO SCAN AT IPL 31
	MOVW	#SOMETIME,W^ECC$GW_WATCH ;RESET SCAN TIMER
10$:
	MOVZBL	(R3)[R6],R2		;GET ADAPTER TYPE
	BEQL	40$			;NO ADAPTER IN THIS SLOT
	MOVL	(R5)[R6],R1		;GET VA OF NEXT CMI SLOT
	BITB	#^B11100000,R2		;LOCAL MEMORY?
	BEQL	20$			;YES IF EQL
 
	CMPB	R2,#^X40		;MULTI-PORT MEMORY?
	BLSSU	40$			;NO IF TYPE LSS 40
	CMPB	R2,#^X43
	BGTRU	40$			;NO IF TYPE GTR 43
 
	$PRTCTINI W^15$,#<MCHK$M_LOG!MCHK$M_NEXM>
 
	MOVL	MPM$L_ERR(R1),R4	;GET MULTI-PORT ERROR REGISTER
 
	$PRTCTEND 15$
	BLBC	R0,40$			;NO MA750 ANY MORE
 
	BBC	#MPM$V_ERR_ELR,R4,40$	;NO ERROR HERE
	BRB	30$			;ERROR, SEE IF WE SHOULD LOG IT
 
20$:	MOVL	MEM$L_CSR0(R1),R4		;LOCAL MEMORY CSR
	BBC	#CSR0$V_COREF,R4,40$	;CORRECTED ECC ERROR IN THIS MEMORY?
30$:
	INCL	W^MMG$GL_CRDCNT		;COUNT TOTAL CRD ERRORS IN SYSTEM
	CMPB	#CRDWATCHMAX,W^ECC$AB_MEMERR[R6] ;LOGGED ENOUGH ERRORS HERE?
	BLEQU	40$			;YES
	MOVZWL	#EMB$K_SE,R3		;ERROR TYPE IN R3
	BSBW	EXE$LOGMEM		;LOG MEMORY ERRORS
	BRB	45$			;LOGGER LOGS ALL MEMORIES
 
40$:	SOBGEQ	R6,10$			;LOOP THROUGH ALL POSSIBLE SLOT NOS.
45$:	ENBINT				;RE-ENABLE INTERRUPTS
	POPR	#^M<R0,R1,R2,R3,R4,R5,R6>	;RESTORE REGS
 
 
50$:					;CHECK IF TIME TO REENABLE CRD INTS
	DECW	W^ECC$GW_REENAB		;REEANABLE TIME ELAPSED
	BLEQ	52$			;YES
	RSB				;NO, RETURN
52$:	MOVW	#REENABTIME,W^ECC$GW_REENAB ;RESET REENABLE TIMER
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6>	;SAVE WORKING REGISTERS
	MOVC5	#0,ECC$AB_MEMERR,#0,#16,ECC$AB_MEMERR ;RESET ERROR COUNTERS TO ZERO
	MOVL	#15,R6			;R0 INDEXES SLOT NOS.
	MOVL	G^EXE$GL_CONFREG,R3	;ARRAY OF NEXUS DEVICE TYPE CODES
	MOVL	G^MMG$GL_SBICONF,R5	;ARRAY OF ADAPTER VA'S
55$:
	MOVZBL	(R3)[R6],R2		;ADAPTER TYPE CODE
	BEQL	65$			;NO ADAPTER IN THIS SLOT
	MOVL	(R5)[R6],R1		;VA OF ADAPTER
	BITB	#^B11100000,R2		;LOCAL MEMORY?
	BEQL	60$			;YES IF EQL
	CMPB	R2,#^X40		;MULTIPORT MEMORY?
	BLSSU	65$
	CMPB	R2,#^X43
	BGTRU	65$
 
; HANDLE MA750 ECC INTERRUPT ENABLE
 
	BBC	S^#EXE$V_CRDENABL,G^EXE$GL_FLAGS,65$
					;BRANCH IF CRD INTERRUPTS NOT WANTED
 
	$PRTCTINI W^58$,#<MCHK$M_LOG!MCHK$M_NEXM>
 
	MOVL	MPM$L_ERR(R1),R2	;GET MA750 ERROR REGISTER
	BBSS	#MPM$V_ERR_ICRD,R2,57$	;RE-ENABLE MA750 CRD INTERRUPTS
57$:	MOVL	R2,MPM$L_ERR(R1)
 
	$PRTCTEND 58$
 
	BRB	65$
 
; HANDLE MAIN MEMORY ECC INTERRUPT ENABLE
 
; ***** NOTE *****
;	IF ECC INTERRUPT BIT IS NOT SET (A SYSGEN PARAMATER), THEN NO
;	SOFT ECC ERROR REPORTING WILL TAKE PLACE, EVEN WHEN ECC$REENABLE
;	SCANS THE MAIN MEMORY CONTROLLER.  THIS IS DIFFERENT THAN IN THE
;	11/780 WHERE THE MEMORY CSR ERROR REPORTING BITS ARE SET WHETHER
;	OR NOT INTERRUPTS ARE ENABLED.
 
60$:	BBC	S^#EXE$V_CRDENABL,G^EXE$GL_FLAGS,65$
					;BRANCH IF CRD INTERRUPTS NOT WANTED
	MOVL	MEM$L_CSR1(R1),R2	;GET LOCAL MEMORY CSR
	BBSS	#CSR1$V_IERP,R2,62$	;SET INTERRUPT ENABLE
62$:	MOVL	R2,MEM$L_CSR1(R1)	;WRITE BACK TO MEMORY CSR
 
65$:	SOBGEQ	R6,55$			;LOOP THROUGH ALL POSSIBLE SLOTS
	POPR	#^M<R0,R1,R2,R3,R4,R5,R6>
70$:	RSB				;RETURN AT LAST
	

	.PAGE
	.SBTTL	ERROR LOGGING ROUTINES
;
; LOGIT - ERROR LOGGING FOR MACHINE CHECKS
;
; COMMON ERROR LOGGING CODE FOR NON MEMORY MACHINE CHECKS
;
; INPUT:
;
;	R3 = ERROR LOG TYPE CODE
;	0(SP) = RETURN ADDRESS
;	4(SP) TO 28(SP) SAVED REGISTERS 0-5,AP
;	32(SP) -40(SP) MASK, PC-PSL POINTER FOR PRTCTEST
;	(AP) = LENGTH OF HARDWARE ERROR LOG FRAME (28 HEX)
;	4(AP) TO 44(AP) HARDWARE ERROR LOG INFORMATION
;	48(AP) = INTERRUPT PC
;	52(AP) = INTERRUPT PSL
;
 
LOGIT:					;LOG MACHINE CHECK ERRORS
	MOVQ	-8(AP),R1		;MASK AND PC,PSL POINTER OF PRTCTEST
	ADDL3	MCK_LENGTH(AP),#<2*4>,R4 ;# OF BYTES TO LOG + PC&PSL
	MOVAB	MCK_CODE(AP),R5		;GET ADDRESS OF LOG
	JSB	G^EXE$MCHK_TEST		;RECOVERY BLOCK IN EFFECT?
	BLBS	R0,20$			;YES, DO NOT LOG THIS ERROR
	INCL	G^EXE$GL_MCHKERRS	;BUMP THE GLOBAL MACHINE CHECK COUNTER
20$:					;FALL THROUGH TO ERROR LOG ROUTINE
 
;
; LOGGER - MACHINE CHECK ERROR LOGGER
;	ALLOCATE ERROR LOG BUFFER
;	SET ENTRY TYPE IN LOG
;	MOVE LOG INTO ERROR LOG BUFFER
;	RELEASE ERROR LOG BUFFER
;
; INPUTS:
;
;	R1 = PC,PSL POINTER FOR PRTCTEST
;	R2 = MASK FOR PRTCTEST
;	R3 = ERROR TYPE
;	R4 = NUMBER OF BYTES TO LOG
;	R5 = ADDRESS OF INFORMATION TO PLACE INTO LOG
;
; OUTPUTS:
;
;	ERROR LOG IS INSERTED INTO ERROR LOG BUFFER
;
;
 
LOGGER:
	JSB	G^EXE$MCHK_TEST		;RECOVERY BLOCK IN EFFECT?
	BLBS	R0,20$			;YES, DO NOT LOG THIS ERROR
 
	ADDL3	#EMB$B_MC_SUMCOD,R4,R1	;SPACE FOR LOG HEADER
	JSB	G^ERL$ALLOCEMB		;GET ERROR LOGGING BUFFER
	BLBC	R0,20$			;FAILED TO GET BUFFER
	PUSHL	R2			;SAVE BUFFER ADDRESS
	MOVW	R3,EMB$W_MC_ENTRY(R2)	;SET ENTRY TYPE IN LOG
	MOVC3	R4,(R5),EMB$B_MC_SUMCOD(R2) ;TRANSFER STACK TO LOG
	MOVL	(SP)+,R2		;RETRIEVE BUFFER ADDRESS
	JSB	G^ERL$RELEASEMB		;RELEASE BUFFER TO LOGGER
20$:
	RSB				;EXIT
;
; EXE$LOGMEM - ERROR LOGGING FOR MEMORY CONTROLLERS
;
; ERROR LOGGING FOR PROCESSOR MEMORY
; MEMORIES CAN INCLUDE LOCAL AND MULTIPORT
;
; INPUTS:
;
;	R3 = ERROR LOG TYPE CODE
;	0(SP) = RETURN ADDRESS
;
; OUTPUTS:
;
;	ALL MEMORY CONTROLLERS ARE EXAMINED
;	THEIR CSR'S ARE READ AND LOGGED TO THE ERRORLOGGER
;	R0 = SUCCESS OR FAILURE INDICATION
;		SUCCESS = .TRUE. - THE MEMORY CSR'S WERE LOGGED
;		FAILURE = .FALSE. - NO DYNAMIC MEMORY AVAILABLE FOR LOG BUFFER
;	R1-R5 ARE DESTROYED
;
 
EXE$LOGMEM::
 
	INCL	G^EXE$GL_MEMERRS	;BUMP THE GLOBAL MEMORY ERROR COUNTER
	PUSHR	#^M<R6,R7,R8,R9,R10>	;SAVE MORE REGISTERS
	MOVL	G^EXE$GL_CONFREG,R6	;ARRAY OF NEXUS DEVICE TYPE CODES
	MOVL	G^MMG$GL_SBICONF,R10	;ARRAY OF ADAPTER VA'S
	CLRQ	R4			;COUNTER FOR NO. OF BYTES TO LOG
	MOVL	#15,R8			;INDEX INTO CMI SLOTS
10$:
	MOVZBL	(R6)[R8],R2		;ADAPTER TYPE
	BNEQ	12$			;PROCEED IF ADAPTER PRESENT
	BRW	60$
12$:
	MOVL	(R10)[R8],R1		;VA OF ADAPTER REGISTER
	BITB	#^B11100000,R2		;MEMORY (BITS 5:7 ARE 0) ?
	BEQL	20$			;YES
 
	CMPB	R2,#^X40		;MULTI-PORT MEMORY (3F<TYPE<44) ?
	BLSSU	160$			;NO
	CMPB	R2,#^X43
	BGTRU	160$			;NO
	MOVZBL	#7,R7
	MOVL	SP,R9			;MARK STACK IN R9
	SUBL	#<8*4>,SP		;SPACE FOR MA750 LOG
 
	$PRTCTINI W^100$,#<MCHK$M_LOG!MCHK$M_NEXM>
 
15$:	MOVL	(R1)[R7],-(R9)		;PUSH REGISTERS ON STACK
	SOBGEQ	R7,15$			;LOOP THROUGH ALL
 
;
; CLEAR ERRORS FROM MA750
;
 
	BISL	#^XFF000000,MPM$L_CR(R1) ;CLEAR PORT INTERFACE CONTROL REG
	BISL	#^XD000C000,MPM$L_SR(R1) ;CLEAR PORT CONTROLER STATUS REG
 
	MOVL	MPM$L_ERR(R1),R7	;READ MULTIPORT ERROR REGISTER
	BBC	#MPM$V_ERR_ELR,R7,30$	;IF CLEAR, NO ERRORS TO LOG NOW
	INCB	W^ECC$AB_MEMERR[R8]	;ACCOUNT AN ERROR
	CMPB	#CRDINTMAX,W^ECC$AB_MEMERR[R8] ;TOO MANY ERRORS?
	BGTRU	18$			;NO, KEEP LOGGING THEM
	BBSS	#MPM$V_ERR_ICRD,R7,17$	;SET INHIBIT LOGGING BIT
17$:	MOVL	R7,MPM$L_ERR(R1)	;WRITE IT BACK
18$:
 
	$PRTCTEND 100$
 
	BLBS	R0,110$			;BRANCH IF MA750 STILL HERE
	ADDL	#<7*4>,SP		;REMOVE LOG SPACE FROM STACK
160$:	BRB	60$			;CONTINUE TO LOOK FOR SLOTS
110$:	ADDL	#<9*4>,R4		;COUNT NO OF BYTES TO LOG
	BRB	30$
 
19$:	BRB	10$
20$:	ADDL	#<4*4>,R4		;MEMORY, LOG 3 LONGWORDS + SLOT INDEX
	MOVZBL	#2,R7
25$:	PUSHL	(R1)[R7]		;PUSH REGISTERS ON STACK
	SOBGEQ	R7,25$
	MOVL	(SP),(R1)		;WRITE BACK TO CLEAR MEMORY CSR
	INCB	W^ECC$AB_MEMERR[R8]	;ACCOUNT ERROR TO THIS CONTROLLER
	CMPB	#CRDINTMAX,W^ECC$AB_MEMERR[R8] ;TOO MANY ERRORS FOR THIS MEMORY?
	BGTRU	30$			;NOT YET, KEEP LOGGING
	MOVL	MEM$L_CSR1(R1),R7	;DISABLE LOGGING OF CORRECTED ERRORS
	BBCC	#CSR1$V_IERP,R7,28$	;CLEAR CONDITIONAL LOG BIT IN CSR 1
28$:	MOVL	R7,MEM$L_CSR1(R1)	;WRITE BACK TO MEMORY CSR 1
 
30$:	PUSHL	R8			;SAVE SLOT INDEX
	MOVZBW	R2,2(SP)		;SAVE ADAPTOR TYPE
	INCL	R5			;COUNT NUMBER OF ENTRIES PUSHED
 
60$:	SOBGEQ	R8,19$			;LOOP THROUGH ALL 16 POSSIBLE SLOTS
	PUSHL	R5			;SAVE COUNT OF NUMBER OF ENTRIES
	ADDL	#<4*1>,R4
	MOVL	SP,R5			;POINT TO LOG INFO
	PUSHL	R4			;SAVE LOG SIZE
	MOVPSL	-(SP)			;GET CURRENT PSL FOR PRTCTEST
	MOVAL	-4(SP),R1		;ADDRESS OF PC,PSL PAIR (AFTER BSB)
	CLRL	R2			;ALWAYS LOG MEMORY ERRORS
	BSBW	LOGGER			;PUT INFO INTO ERROR LOG
	ADDL	#<1*4>,SP		;CLEAR PSL
	ADDL	(SP)+,SP		;CLEAN UP THE STACK
	POPR	#^M<R6,R7,R8,R9,R10>	;RESTORE REGISTERS
	RSB				;RETURN
;	

	.PAGE
	.SBTTL	REFLECT EXCETION TO USER
;
; REFLECT ERROR TO USER
;
; IF CURRENT MODE WAS USER OR SUPERVISOR MODE, SET UP EXCEPTION ON
; USERS KERNEL STACK AND REI TO IT
;
; IF CURRENT MODE WAS KERNEL OR EXECUTIVE MODE, ISSUE A FATAL BUG-CHECK
;
 
REFLECTCHK:				;REFLECT EXCEPTION TO CURRENT ACCESS MODE
 
	BBS	#PSL$V_CURMOD+1,MCK_PSL(AP),20$	;USER OR SUPER MODE?
 
	POPR	#^M<R0,R1,R2,R3,R4,R5,AP>	;RESTORE REGISTERS
	JSB	G^EXE$MCHK_BUGCHK	;RECOVERY BLOCK IN EFFECT?
 
	BUG_CHECK MACHINECHK,FATAL	;BUG-CHECK IN EXEC OR KERNAL MODE
 
20$:
	MFPR	#PR$_KSP,R0		;GET KERNEL MODE STACK POINTER
					;FOR CURRENT PROCESS
	MOVQ	MCK_PC(AP),-(R0)	;MOVE INTERRUPT PC AND PSL OF MACHINE
					;CHECK TO PROCESS'S KERNEL STACK
	MTPR	R0,#PR$_KSP		;REPLACE NEW KERNAL STACK POINTER
	POPR	#^M<R0,R1,R2,R3,R4,R5,AP> ;RESTORE REGISTERS SAVED AT BEGINNING
	ADDL	#<2*4>,SP		;REMOVE PRTCTEST STUFF
	ADDL	(SP)+,SP		;POP HARDWARE MACHINE CHECK LOG FROM STACK
;
; THIS IS A SLIGHT PIECE OF MAGIC - NOTHING SPECTACULAR
; IF YOU HAVE RETRIEVED THE PIRATE'S CHEST, THEN THIS SHOULD BE EASY
;
; WE ARE NOW EXECUTING ON THE SYSTEM INTERRUPT STACK AT IPL 31
; THE PC AND PSL FROM THIS MACHINE CHECK IS PLACED ON THE CURRENT PROCESS'S
; KERNEL STACK.
; THE PC AND PSL FROM THIS MACHINE CHECK ON THE INTERRUPT STACK IS REPLACED
; BY A PC WHICH POINTS INTO THE MODULE "EXCEPTION".  THE PSL IS REPLACED
; WITH A PSL INDICATING A KERNEL MODE EXCEPTION.
; WHEN THE FOLLOWING REI IS EXECUTED, WE END EXECUTING ON THE KERNEL
; STACK OF THE CURRENT PROCESS IN THE SYSTEM EXCEPTION INTERRUPT HANDLER.
; THE CODE THERE REPORTS AN EXCEPTION TO THE CURRENT PROCESS AND REI'S BACK
; TO WHERE THE ORIGONAL MACHINE CHECK HAPPENED.
; IF THE CURRENT PROCESS HAS AN EXCEPTION HANDLER FOR MACHINE CHECK'S THEN
; SOME KIND OF FORWARD ERROR RECOVERY CAN BE ENVOKED.  IF NOT, THE SYSTEM
; LAST CHANCE HANDLER WILL END UP DELEATING THE PROCESS.
;
	MOVAB	G^EXE$MCHECK,(SP)	;WITH MIRRORS - SET UP A PC AND
					;PSL FOR EXCEPTION
	EXTZV	#PSL$V_CURMOD,#PSL$S_CURMOD,4(SP),4(SP) ;GET MODE WE WERE IN
	ROTL	#PSL$V_PRVMOD,4(SP),4(SP) ;CREATE A PSL OF CURRENT TO BE
					;KERNAL WITH CORRECT PREVIOUS MODE
	REI				;GET TO EXCEPTION HANDLER


	.PAGE
	.SBTTL	TABLE OF RESUMABLE INSTRUCTIONS.
;	EACH BIT IN THE TABLE IS A 1 IF THE INSTRUCTION IS RESUMABLE,
;	AND A 0 IF IT IS NOT.

RESUMABLE:
	.WORD	^B0000111101101011	;REI,RET,SVPCTX,PROBEx,INSQUE,REMQUE
	.WORD	^B1111111110111111	;JSB
	.WORD	^B1111111111111111
	.WORD	^B1111111111111111
	.WORD	^B1111111111111111
	.WORD	^B0000000000101111	;EMODF,CVTFD,INTERLOCKED INSTRUCTIONS
	.WORD	^B0000111100000000	;DOUBLE PRECISION FLOATING POINT
	.WORD	^B1100000101001010	;MORE DOUBLE PREC/QUAD, EMUL, EDIV
	.WORD	^B1111111111111111
	.WORD	^B1111111111111111
	.WORD	^B1111111111111111
	.WORD	^B0000001111111111	;PUSHR,POPR,CHMK,CHME,CHMS,CHMU
	.WORD	^B1111111111111111
	.WORD	^B1111111111111111
	.WORD	^B1111111111111111
	.WORD	^B0000000111111111	;CVTLP,CALLG,CALLS,XFC,ESCD,ESCE,EXCF


	.END
