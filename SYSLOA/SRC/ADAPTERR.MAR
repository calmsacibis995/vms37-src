	.TITLE	ADAPTERR - I/O ADAPTER ERROR HANDLERS
	.IDENT	'V03-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:	EXECUTIVE, ERROR HANDLING
;
; ABSTRACT: 	HANDLE ERROR INTERRUPTS GENERATED BY I/O ADAPTERS (UBA AND MBA)
;
; ENVIRONMENT:	RUNS ON INTERRUPT STACK AT ADPATER IPL.

;--
	.SBTTL	HISTORY			; DETAILED
;
; AUTHOR: CHARLES A. SAMUELSON, CREATION DATE: 12-AUG-1980
;
; MODIFIED BY:
;
;	V02-008	KTA0057		Kerbey T. Altmann	28-Dec-1981
;		Clean up some problems with BLS0118 & KTA0050 and
;		use common routine for UBA initialization.
;
;	V02-007	BLS0118		Benn Schreiber		08-Dec-1981
;		Correct KTA0050 to call INI$ALONONPAGED rather than
;		EXE$ALONONPAGED
;
;	V02-006	KTA0050		Kerbey T. Altmann	01-Dec-1981
;		Added new routine INI$MPMADAP.
;
;	V02-005	TCM0002		Trudy C. Matthews	11-Aug-1981
;		Replaced reference to ECC$AB_MEMERR with EXE$AB_MEMERR.
;
;	V004	TMH0004		Tim Halvorsen		29-Jun-1981
;		Fix UBA re-initialization code after power up is signaled,
;		to save/restore registers outside of protected code segment,
;		in case a machine check occurs during the code segment.
;
;	V02-003	TCM0001		Trudy C. Matthews	8-May-1981
;		Change reference to RPB$B_CONFREG to use EXE$GL_CONFREG.
;
;	V02-002	CAS0007		C. A. Samuelson		5-Jan-1981
;		Added support for Massbus Adapter powerfail.  Changed
;		map and unmap and SCB vector save routines to use
;		pre-initialized fields in ADP.  Modified error vector
;		entry-point routines.
;---

;
; LOCALLY DEFINED SYMBOLS
;
UBALOGMAX	= 3			;MAXIMUM NUMBER OF SOFT UBA ADAPTER
					;ERRORS TO LOG IN 15 MINUTES
UBAMAXRETRY	= 3			;MAXIMUM TIMES TO TRY AND RE-INITIALIZE
					;THE UBA AFTER POWER FAIL
UBAMAXTIM	= 6			;NUMBER OF 10MS CLOCK TICKS TO WAIT
					;FOR UBA STATUS BITS TO ASSERT
 
;	INCLUDED SYMBOL DEFINITIONS

	$ADPDEF				;DEFINE ADAPTER CONTROL BLOCK SYMBOLS
	$DYNDEF				;DEFINE DYNAMIC BLOCK TYPES
	$EMBDEF	<MC,SB,SE>		;DEFINE EMB OFFSETS
	$MCHKDEF			;DEFINE RECOVERY BLOCK MASK BITS
	$IDBDEF				; DEFINE INTERRUPT DISPATCH BLOCK SYMBOLS
	$MBADEF				; DEFINE MASSBUS ADAPTER SYMBOLS
	$MPMDEF				;DEFINE MULTI-PORT MEMORY
	$PRDEF				;DEFINE PROCESSOR REGISTER NUMBERS
	$UBADEF				;DEFINE UNIBUS ADAPTOR SYMBOLS
	$VADEF				;DEF IN PFN PITS


;	LOCAL DATA STORAGE
 
;	LOCAL MACROS

	.MACRO	VECGEN			; Macro to generate ISR entry point
$$$TEMP=.
	PUSHL	I^#0			; Replaced by ADP address for this NEXUS
	BRB	VECEND			; Join common code
$$$TEMP=.-$$$TEMP
	ASSUME	$$$TEMP EQ 8		; Each entry must be 8 bytes long
	.ENDM
 
	.PSECT	WIONONPAGED,QUAD,RD,WRT

	.SBTTL	EXE$DW780_INT - UBA ERROR INTERRUPT HANDLER
 
;++
; EXE$DW780_INT - UBA ADAPTOR ERROR INTERRUPT HANDLER
;
; FUNCTIONAL DESCRIPTION:
;
;	PROCESS ALL INTERRUPTS FROM DW780, 11/780 UBA
;	LOG AND TRY TO RECOVER.
;
; INPUTS:
;
;	R4 = ADDRESS OF UBA ADP
;	R5 = UNIBUS VECTOR DISPATCH ADDRESS
;	R2-R5 SAVED ON STACK+PC,PSL FROM INTERRUPT
;
; OUTPUTS:
;
;--
 
 
	.ENABL	LSB
 
EXE$DW780_INT::
 
	MOVQ	R0,-(SP)		; SAVE R0,R1 ON STACK
	MOVQ	R4,-(SP)		; SAVE ADP ADDRESS AND VECTOR ADDRESS
	DSBINT				; LOCK OUT THE WORLD
RESTART_UBA:				; ENTER HERE ON POWER UP
	MOVQ	<9*4>(SP),-(SP)		; MAKE SECOND COPY OF PC,PSL FOR LOGGER
	MOVL	SP,R3			; Mark stack
	SUBL	#<7*4>,SP		; Make room for registers on stack
	BSBW	READ_REGISTERS		; Read Adapter Registers
	BLBS	R0,30$			; UBA THERE, KEEP GOING
	BRW	NO_UBA			; CANNOT ACCESS UBA, ERROR
 
; AT THIS POINT IN TIME THE STACK LOOKS AS FOLLOWS
;
;	PSL
;	PC
;	R5
;	R4
;	R3
;	R2
;	R1
;	R0
;	UNIBUS VECTOR DISPATCH ADDRESS
;	ADP ADDRESS FOR THIS UBA
;	IPL
;	PSL (COPY)
;	PC  (COPY)
;	TR # OF THIS ADAPTER
;	UBA$L_FUBAR
;	UBA$L_FMER
;	UBA$L_DCR
;	UBA$L_SR
;	UBA$L_CR
; SP -->UBA$L_CSR
 
; DISPATCH ON ERROR TYPE BITS IN UBA REGISTERS
;	THE ORDER OF LOOKING AT THE BITS AND THE ACTION TAKEN IS SHOWN
;	ALL ERRORS ARE LOGGED
;		1) ADAPTER POWER DOWN - UNMAP UBA AND WAIT FOR POWER UP
;		2) ADAPTER POWER UP - REMAP THE UNIBUS AND CONTINUE
;		3) UNIBUS INIT ASSERTED - UNMAP THE UBA AND WAIT FOR POWER UP
;		4) UNIBUS POWER DOWN - UNMAP UBA AND WAIT FOR UNIBUS POWER UP
;		5) UNIBUS POWER UP - REMAP UBA, INITIALIZE DRIVERS AND CONTINUE
;		6) UBSTO - RESET UBA, INITIALIZE DRIVERS AND CONTINUE
;		7) UBSSYNTO - CONTINUE - ONLY LOG 3 EVERY 15 MINUTES
;		8) SBI ERRORS - CONTINUE - ONLY LOG 3 EVERY 15 MINUTES
 
30$:
	BITL	#<UBA$M_CSR_PD!UBA$M_CSR_UBIIP!UBA$M_CSR_UBPDN>,(SP)
	BNEQ	UBA_POWER_DOWN
 
	BBC	#UBA$V_CSR_UBIC,(SP),210$	 ; BRANCH IF NO POWER UP
200$:	BRW	UBA_POWER_UP			; POWER IS UP
210$:	BBS	#UBA$V_CSR_PU,(SP),200$		  ; BRANCH IF ADAPTER POWER UP
 
	BBC	#UBA$V_SR_UBSTO,<2*4>(SP),220$	 ; BRANCH IF TIME-OUT
	BRW	UBA_STO
 
220$:	BBS	#UBA$V_SR_SSYNC,<2*4>(SP),UBA_SSYNC ; BRANCH IF SLAVE SYNCH
 
	BITL	#<UBA$M_SR_CXTER!-
		UBA$M_SR_CXTMO!-
		UBA$M_SR_DPPE!-
		UBA$M_SR_IVMR!-
		UBA$M_SR_MRPE!-
		UBA$M_SR_RDS!-
		UBA$M_SR_RDTO>,<2*4>(SP) ; ALL THE OTHER RANDOM ERRORS
	BEQL	UBA_NOLOG_RET		; BRANCH IF NONE OF THEM
 
UBA_SSYNC:				; DO NOTHING HERE AND HOPE FOR THE BEST **
UBA_ADAPTER_ERR:			; JUST FOR THE RECORD **
 
	MOVZWL	ADP$W_TR(R4),R0		; GET TR NUMBER
	CMPB	#UBALOGMAX,W^EXE$AB_MEMERR[R0] ; Log 3 of these error in 15 minutes
	BLEQU	UBA_NOLOG_RET
	INCB	W^EXE$AB_MEMERR[R0]	; Count another one.
 
UBA_RETURN:
 
	BSBW	LOG_ADAPTER		; Log UBA error
	.BYTE	EMB$K_UBA		; UBA errorlog type
 
UBA_NOLOG_RET:
 
	MOVL	SP,R3			; GET POINTER TO ADAPTER REGISTERS
 
	$PRTCTINI B^40$,#MCHK$M_NEXM
 
	MOVL	(R3),UBA$L_CSR(R5)	; CLEAR UBA ERRORS
	MOVL	<2*4>(R3),UBA$L_SR(R5)	; DITO
 
	$PRTCTEND 40$
	BLBC	R0,NO_UBA		; CANNOT ACCESS ADAPTER
 
	ADDL	#<9*4>,SP		; GET RID OF  STUFF ON STACK
	ENBINT				; BACK TO DEVICE IPL
	MOVQ	(SP)+,R4		; GET VECTOR DISPATCH ADDRESS IN R5
	JMP	@(R5)+			; OFF TO ISR
 

	.SBTTL	ADAPTER ERROR HANDLERS
 
ADP_POWER_DOWN:				; UNIBUS ADAPTER POWER LOSS
UBA_POWER_DOWN:				; UNIBUS (NOT ADAPTER) HAS LOST POWER
 
	$PRTCTINI B^55$,#MCHK$M_NEXM
 
	MOVL	#UBA$M_CR_CNFIE,UBA$L_CR(R5) ; ALLOW ONLY CONFIGURATION INTERRUPTS
	MCOML	#0,UBA$L_CSR(R5)	; CLEAR ALL UBA ERROR BITS
	MCOML	#0,UBA$L_SR(R5)		; DITO
 
	$PRTCTEND 55$
 
NO_UBA:
	BSBW	UNMAP_UNIBUS		; REMAP UBA ADDRESS SPACE TO RABIT HOLE PAGE
 
VEC_RETURN:				; RETURN, NOT GOING THRU VECTOR
 
	BSBW	LOG_ADAPTER		; Log UBA error
	.BYTE	EMB$K_UBA		; Log UBA error
VEC_NOLOG_RET:
	ADDL	#<9*4>,SP		; CLEAR STACK OF LOG
UBA_PWR_RET:
	ENBINT				; RE-ENABLE INTERRRUPTS
	ADDL	#<2*4>,SP		; CLEAR STACK OF VECTOR ADDRESS, ETC.
UBA_VEC_DSPAT:
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; RESTORE GENERAL REGISTERS
	REI				; AT LAST!
 
UBA_POWER_UP:				; UNIBUS HAS REGAINED IS STRENGTH
RESTORE_UBA:
 
	PUSHR	#^M<R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,AP,FP> ; Save regs destroyed by INIT_DEVICE
	$PRTCTINI B^100$,#MCHK$M_NEXM
	MOVZWL	ADP$W_TR(R4),AP		; Initialize for this adapter only
	PUSHR	#^M<R4,R5>		; Need ADP/CSR after INIT_DEVICE
	JSB	G^EXE$INIT_DEVICE	; Initialize devices on this TR level
	POPR	#^M<R2,R4>		; Restore registers for next routine
	JSB	G^UBA$INITIAL		; Re-enable interrupts/init registers
	$PRTCTEND 100$
	POPR	#^M<R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,AP,FP>
	BLBS	R0,VEC_RETURN		; We made it
	BRB	NO_UBA			; No Unibus Yet
 
UBA_STO:				; UBA SACK TIMEOUT, BAD ERROR
 
	$PRTCTINI B^120$,#MCHK$M_NEXM
 
	MOVL	#UBA$M_CR_INIT,UBA$L_CR(R5) ; HARD INIT THE UBA
 
; WAIT FOR 60 MS OR INIT COMPLET, WHICH EVER COMES FIRST
 
	MOVL	ADP$L_CSR(R4),R0	; ADDRESS OF UBA CSR
	BSBW	WAIT_TEST		; TEST BIT AND/OR TIME OUT
	.BYTE	UBA$V_CSR_UBIC		; BIT POSITION TO TEST
	MOVL	R0,R2			; PUT RETURN STATUS IN R2
 
	$PRTCTEND 120$
 
	BLBS	R2,130$			; R2 IS SET, NO TIMEOUT
115$:	BRW	ADP_POWER_DOWN		; ERROR,WHAT ELSE CAN WE DO?
130$:	BLBC	R0,115$			; NO UBA, TAKE IT AWAY FROM SYSTEM
	BRB	RESTORE_UBA		; RESTORE THE UNIBUS
 
	.DSABL	LSB

	.SBTTL	EXE$RH780_INT - MBA ERROR INTERRUPT HANDLER

;++
; EXE$RH780_INT - MBA ADAPTER ERROR INTERRUPT HANDLER
;
; FUNCTIONAL DESCRIPTION:
;
;	Process Adapter power down interrupt from MBA.  Log error.
;	Remap MBA adapter address space to black hole page.  Reset
;	SCB vectors for this NEXUS to point to power up ISR in this
;	module.  REI and wait for power up interrupt.
;
; INPUTS:
;
;	R3 - Address of IDB
;	R4 - Adapter CSR address
;	00(SP) - Address of IDB address
;	04(SP) to 24(SP) - Saved R2 to R5 plus PC,PSL from interrupt
;
; OUTPUTS:
;
;--

EXE$RH780_INT::

	MOVL	R1,(SP)			; Save R1, replace IDB address
	PUSHL	R0			; Save R0
	DSBINT				; Raise to IPL 31
	MOVL	IDB$L_ADP(R3),R4	; ADP address
RESTART_MBA:
	MOVQ	<7*4>(SP),-(SP)		; Make second copy of PC,PSL for logger
	MOVL	SP,R3			; Mark Stack
	SUBL	#<7*3>,SP		; Make room for registers on stack
	BSBW	READ_REGISTERS		; Read Adapter Registers
	BLBC	R0,NO_MBA		; Cannot access MBA registers

; The stack now looks as follows:
;
;	PSL
;	PC
;	R5
;	R4
;	R3
;	R2
;	R1
;	R0
;	IPL
;	PSL (copy)
;	PC  (copy)
;	TR # of this adapter
;	MBA$L_DR
;	MBA$L_BCR
;	MBA$L_VAR
;	MBA$L_SR
;	MBA$L_CR
; SP -->MBA$L_CSR

; Log MBA status

	BSBW	LOG_ADAPTER		; Call logger routine
	.BYTE	EMB$K_MBA		; Error log type code

; Dispatch on either Power up or Power down
;	If power down, remap MBA address to black hole page and change
;	adapter SCB vectors to point into power up ISR in this module.
;	If power up, map MBA addresses back to normal system virtual and
;	point SCB vectors into normal system ISR.

	BITL	#MBA$M_CSR_PD,(SP)	; Check for power down first
	BNEQ	MBA_POWER_DOWN
	BITL	#MBA$M_CSR_PU,(SP)	; Better be power up
	BNEQ	MBA_POWER_UP
	BRB	MBA_RETURN		; No status, just REI

MBA_POWER_DOWN:				; Handle MBA power down interrupt
NO_MBA:
	$PRTCTINI B^100$,#MCHK$M_NEXM
	JSB	G^MBA$INITIAL		; Clear MBA status and enable interrupts
	$PRTCTEND 100$
	BSBW	UNMAP_MASSBUS		; Remap to black hole page
	BRB	MBA_RETURN

MBA_POWER_UP:				; Handle MBA power up interrupt
	BSBW	MAP_MASSBUS		; Restore normal system mapping
	PUSHR	#^M<R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,AP,FP> ; Save regs destroyed by INIT_DEVICE
	$PRTCTINI B^100$,#MCHK$M_NEXM
	JSB	G^MBA$INITIAL		; Start up MBA
	MOVZWL	ADP$W_TR(R4),AP		; Initialize for this adapter only
	JSB	G^EXE$INIT_DEVICE	; Initialize devices on this TR level
	$PRTCTEND 100$
	POPR	#^M<R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,AP,FP>
	BLBC	R0,MBA_POWER_DOWN	; No MBA yet
MBA_RETURN:				; Common interrupt return
	ADDL	#<9*4>,SP		; Clear logging stuff off stack
	ENBINT				; Re-enable interrupts
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore GPR's
	REI				; Return	

	.SBTTL	READ_REGISTERS - READ ADAPTER REGISTERS
;++
; READ_REGISTERS - READ ADAPTER REGISTERS INTO BUFFER
;
;
; FUNCTIONAL DESCRIPTION:
;
;	Called on adapter error entry to save TR number of adapter and
;	six adapter registers in buffer.
;
; INPUTS:
;
;	R3 - Address of buffer to read registers into
;	R4 - ADP address for adapter
;
; OUTPUTS:
;
;	Adapter's TR # saved in buffer
;	Six adapter registers pushed onto buffer in reverse order
;	R1,R3 destroyed
;	R5 <- Adpater CSR address
;	R0 - LBC if adapter could not be referenced
;--

READ_REGISTERS:

	MOVL	ADP$L_CSR(R4),R5	; Fetch adapter CSR address
	MOVZWL	ADP$W_TR(R4),-(R3)	; Save TR of this adapter for log
	MOVL	#5,R1			; Counter for 6 registers

	$PRTCTINI B^20$,#MCHK$M_NEXM	; Protect from machine check

10$:	MOVL	(R5)[R1],-(R3)		; Place registers in buffer
	SOBGEQ	R1,10$			; Loop thru all 6

	$PRTCTEND 20$			; End of protected code
	RSB

	.SBTTL	LOG_ADAPTER - ERROR LOG ADAPTER ERROR
;++
; LOG_ADAPTER - ERROR LOGGING FOR UBA AND MBA ADAPTER ERROR INTERRUPTS
;
; FUNCTIONAL DESCRIPTION:
;
;	INTERFACE TO ERROR LOGGING ROUTINE IN MACHINE CHECK
;
; INPUTS:
;
;	(SP) - Points to error log type code
;	(SP)+1 - Return address
;	9 longwords are logged, defined as follows:
;		6 Adapter registers
;		TR # of this adapter
;		PC
;		PSL
;
; OUTPUTS:
;
;	Entry made in error log
;	R0-R3 modified
;--

LOG_ADAPTER:

	PUSHR	#^M<R4,R5>		; Save R4, R5
	MOVAL	<3*4>(SP),R5		; Address of error log frame
	MOVL	#<9*4>,R4		; Length of error log frame
	MOVZBL	@<2*4>(SP),R3		; Error log type
	BSBW	MCHK$GL_LOG		; Call error loggin routine in MCHK780
	POPR	#^M<R4,R5>		; Restore R4, R5
	INCL	(SP)			; Bump Stack past type
	RSB

	.SBTTL	UNMAP ADAPTER ADDRESSES, REPLACE SCB VECTOR
;++
; UNMAP_UNIBUS - Remap UBA address space to black hole page
; UNMAP_MASSBUS - Remap MBA address space to black hole page
;
; FUNCTIONAL DESCRIPTION:
;
;	For each supported adapter, modify SPTE's that map the adapter
;	to point PFN to black hole page.  Replace the ISR address of
;	the four adapter SCB vectors and point to entry point in this
;	module.  This allows this routine to handle the power up
;	interrupts.  Remap to the black hole page allows all code which
;	touches the adapter I/O address space to continue without
;	machine checks.  Note that any such code (drivers, map register
;	initialization, etc.) will of course not do what it thought it
;	was doing.  The result should be device timeout for any I/O
;	request.
;
; INPUTS:
;
;	R4 - ADP address of the adapter
;	IPL 31
;
; OUTPUTS:
;
;	Adpater address space (and Unibus I/O space for UBA) mapped to
;	black hole page.
;	Adapter SCB vectors replace to point to this module
;	All general registers preserved.
;
;
;--

UNMAP_UNIBUS:
	PUSHR	#^M<R0,R1,R2,R3,R6>	; Save GPR's used
	MOVL	#24,R0			; Number of SPTE's to modify
	BRB	UNMAP

UNMAP_MASSBUS:
	PUSHR	#^M<R0,R1,R2,R3,R6>	; Save GPR's used
	MOVL	#8,R0			; Number of SPTE's to modify

;++
; UNMAP - Common routine to unmap adapter address space and replace adpater
;	  SCB vector ISR addresses
;
; INPUTS:
;
;	R0 - Number of pages to remap to black hole page for this adapter
;	R4 - Adapter ADP address
;
; There are interrupt service routine entry points in module ADAPTERR for
; each of the 16 possible NEXUS on the system.  When a NEXUS is unmapped,
; its four SCB vectors are redirected to the interrupt service routine
; in this module.  Thus, this module receives all interrupts from an
; unmapped adapter.
;
; Each interrupt service routine entry point is of the form:
;
;	PUSHL	I^#0
;	BRB	VECEND
;
; When an adapter is unmapped, its ADP address is stored in the immediate
; constant that is pushed on the stack.   This location is cleared when
; the adapter is mapped and is used as a flag to prevent double mapping or
; unmapping.
;
; The interrupt service routines form an array with each entry being
; exactly 8 bytes long (a quadword).  Thus the vectors are all long word
; alligned and some assumptions can be made for indexing into the array.
; The index is based on the TR number of the NEXUS.  Index into the
; array must be PIC.  With this introduction, understanding the following
; code is left as an exercise for the student.
;--

UNMAP:
	MOVZWL	ADP$W_TR(R4),R3		; Get adapter TR number
	MULL3	#2,R3,R2		; Quadword index (used with indexed addressing)
	MOVAL	W^ADP_BASE,R6		; Get address of base of ISR table
	TSTL	(R6)[R2]		; Test saved ADP address cell
	BNEQ	100$			; If not zero, already unmapped
	MOVL	R4,(R6)[R2]		; Save ADP address for power up
	MOVL	G^MMG$A_SYSPARAM+<EXE$GL_SCB-EXE$A_SYSPARAM>,R1 ; SCB base address
	MOVAL	^X100(R1)[R3],R1	; Base of NEXUS vectors for this TR
	DECL	R6			; Calculate ISR base +1 (vector) address
	MOVAL	(R6)[R2],(R1)		; Change ISR address for 4 vectors
	MOVL	(R1),64(R1)
	MOVL	(R1),128(R1)
	MOVL	(R1),192(R1)
	MOVL	ADP$L_CSR(R4),R2	; Virtural address of adapter space
	JSB	G^MMG$SVAPTECHK		; Address of SPTE that maps adapter
	MOVL	G^EXE$GL_BLAKHOLE,R1	; PFN of black hole page
10$:	INSV	R1,#0,#VA$S_VPN,(R3)	; Insert new PFN in SPTE
	ADDL	#4,R3			; Point to next SPTE
	SOBGTR	R0,10$			; Do for all
	INVALID				; Invalidate TB
100$:	POPR	#^M<R0,R1,R2,R3,R6>	; Restore GPR's
	RSB

	.SBTTL	MAP ADAPTER ADDRESS, RESTORE SCB VECTORS
;++
; MAP_UNIBUS - Map UBA adapter addresses, restore UBA SCB vectors
; MAP_MASSBUS - Map MBA adapter addresses, restore MBA SCB vectors
;
; FUNCTIONAL DESCRIPTION:
;
;	Restore SCB vector address from ADP for the adapter.  Restore
;	SPTE contents that map adpater and I/O address space.  These
;	routines essentially undo are restore everything done by
;	UNMAP_ADAPTER.
;
; INPUTS:
;
;	R4 - Adapter ADP address
;	IPL 31
;
; OUTPUTS:
;
;	PFN field of SPTE's that map adapter and adapter I/O space are
;	restored to point to the adapter.
;	SCB vectors are pointed to the origonal system adapter ISR.
;--

MAP_UNIBUS:
	PUSHR	#^M<R0,R1,R2,R3>	; Save GPR's
	MOVAL	ADP$L_UBASCB(R4),R0	; Address of table containing ISR address
	BSBB	MAP			; Common re-map routine
	MOVL	ADP$L_UBASPTE(R4),R2	; Saved SPTE value that maps adapter
	MOVL	#24,R0			; UBA uses 24 SPTE's
10$:	MOVL	R2,(R3)+		; Replace each SPTE
	INCL	R2			; Point to next page
	CMPL	#17,R0			; Switch from adapter to I/O space
	BNEQ	20$			; For Unibus I/O page
	MOVL	ADP$L_UBASPTE+4(R4),R2	; SPTE value that maps I/O space
20$:	SOBGTR	R0,10$			; All SPTE's
	BRB	MAP_RET			; Join common code

MAP_MASSBUS:
	PUSHR	#^M<R0,R1,R2,R3>	; Save GPR's
	MOVAL	ADP$L_MBASCB(R4),R0	; Address of tabel containing ISR addresses
	BSBB	MAP			; Common re-map routine
	MOVL	ADP$L_MBASPTE(R4),R2	; Saved SPTE value that maps adapter
	MOVL	#8,R0			; MBA uses 8 SPTE's
10$:	MOVL	R2,(R3)+		; Replace each SPTE
	INCL	R2			; Point to next page
	SOBGTR	R0,10$			; All SPTE's
MAP_RET:
	INVALID				; Invalidate TB
MAP_END:
	POPR	#^M<R0,R1,R2,R3>	; Restore GPR's
	RSB

;++
; MAP - Common adapter re-map routines
;
; INPUTS:
;
;	R0 - address of table containing saved values for adapter SCB ISR's
;	R4 - address of adapter ADP
;	return address plus R0,R1,R2,R3 saved on stack
;
; OUTPUTS:
;
;	R3 - address of first SPTE that maps adapter addresses
;	Adapter SCB vectors restored to system ISR's
;	R0,R1,R2 modified
;	If Adapter already mapped, stack is cleared and return to caller's
;	caller is made.
;
; Refer to comments at start of paragraph "UNMAP".
;--

MAP:
	MOVZWL	ADP$W_TR(R4),R3		; Adapter NEXUS TR number
	MULL3	#2,R3,R2		; Make quadword index
	MOVAL	W^ADP_BASE,R1		; Address of vector table
	TSTL	(R1)[R2]		; Adapter already mapped?
	BEQL	100$			; Yes, exit
	CLRL	(R1)[R2]		; Flag adapter already mapped
	MOVL	G^EXE$GL_SCB,R1 	; SCB base address
	MOVAL	^X100(R1)[R3],R1	; Base of NEXUS vectors for this TR
	MOVL	(R0)+,(R1)		; Restore 4 SCB vectors
	MOVL	(R0)+,64(R1)
	MOVL	(R0)+,128(R1)
	MOVL	(R0),192(R1)
	MOVL	ADP$L_CSR(R4),R2	; Address of Adapter CSR
	JSB	G^MMG$SVAPTECHK		; Address of SPTE that maps adapter CSR
	RSB
100$:	ADDL	#4,SP			; Clear callers return address from stack
	BRB	MAP_END			; Restore GPR's and return to caller's caller

	.SBTTL	ADAPTER_ISR - Adapter power-up interrupt service
;++
; FUNCTIONAL DESCRIPTION:
;
;	ISR Vector intry points for adapter interrupt service on adapter
;	power up after remapping adapter I/O space to black hole page and
;	replacing adapter SCB vector pointers.  The adapter type is determined.
;	Adapter specific power up code is dispatched to.
;
; INPUTS:
;
;	NONE - directly vectored to from SCB
;
; OUTPUS:
;
;	R0-R5 saved on stack
;	R4 <- ADP address
;	IPL Raised to 31
;--

	.ALIGN	LONG
ADP_BASE=.+2				; Base of ADP address save table
ISR_BASE=.				; Base of ISR entry point table
	.REPT	16			; Repete once for each SCB NEXUS vector
	VECGEN				; Generate a vector entry point
	.ENDR
VECEND:
	PUSHL	R5			; Save R5
	MOVL	4(SP),R5		; Replace R5 with ADP address
	MOVL	(SP)+,(SP)		; Move stack up one longword
	PUSHR	#^M<R0,R1,R2,R3,R4>	; Save rest of GPR's
	MOVL	R5,R4			; R4 <- ADP address
	BEQL	120$			; If no ADP address, we're in trouble

; Now retrieve adapter TR # and adapter type.  Dispatch on adapter type to
; proper adapter handling code.

	MOVZWL	ADP$W_TR(R4),R0		; Fetch adapter TR number
	MOVL	G^EXE$GL_CONFREG,R3	; Get address of CONFREG array
	MOVZBL	(R3)[R0],R3		; Get adapter type code.
	BEQL	120$			; If type is 0, its bad news
	CMPB	R3,#^X20		; Is adapter an MBA?
	BNEQ	100$			; No, test for UBA
	BRW	500$			; Yes, go to MBA interrupt handler
100$:	CMPB	R3,#^X28		; Is adapter an UBA?
	BLSS	120$			; No, inconsistent
	CMPB	R3,#^X2B
	BGTR	120$

; This is a UBA interrupt

	MOVAL	W^UBA_VEC_DSPAT,R5	; IN CASE WE TAKE UBA_RETURN
	MOVQ	R4,-(SP)		; MAKE STACK COMMON
	DSBINT				; TO IPL 31
 
	BSBW	MAP_UNIBUS		; REMAP THE UNIBUS ADDRESS SPACE
 
	$PRTCTINI B^200$,#MCHK$M_NEXM
 
	MOVL	ADP$L_CSR(R4),R0	; GET ADAPTER CSR ADDRESS
 
; NOTE: THIS IS THE FIRST REFERENCE TO THE UNIBUS ADAPTER ADDRESS SPACE
; ON THE WAY UP.
 
	MOVL	(R0),R1			; READ UBA CSR
	CMPB	R3,R1			; IS THIS THE SAME ADAPTER TYPE?
	BEQL	150$			; YES, CONTINUE
 
120$:	BUG_CHECK UNEXUBAINT,FATAL	; CRASH, CANNOT SWITCH ADAPTERS
 
150$:
	CLRL	R2			; ASSUME NO POWER YET
	BITL	#<UBA$M_CSR_UBIC!UBA$M_CSR_PU>,R1
					; IS THIS A POWER UP INTERRUPT?
	BEQL	165$			; NO, IGNORE
	PUSHR	#^M<R0,R1>		; SAVE REGISTERS
	BSBW	WAIT_TEST		; WAIT FOR INIT COMPLETE, ADDRESS IN R0
	.BYTE	UBA$V_CSR_UBIC		; BIT TO WAIT ON
	MOVL	R0,R2			; COPY RETURN CODE
	POPR	#^M<R0,R1>		; RESTORE REGISTERS
	BLBS	R2,170$			; BRANCH IF OK
165$:
	MOVL	R1,(R0)			; CLEAR UBA CSR ERROR BITS
170$:
	$PRTCTEND 200$			; END PROTECTED CODE
 
	BLBC	R0,300$			; UBA CANNOT BE ACCESSED
	BLBC	R2,300$			; UBA INIT COMPLETE NOT ASSERTED
	BRW	RESTART_UBA		; UBA IS UP AND KICKING
300$:
	BSBW	UNMAP_UNIBUS		; WELL, WE'RE NOT THERE YET
	BRW	UBA_PWR_RET		; REI AND WAIT FOR ANOTHER POWER UP

; This is a MBA interrupt

500$:
	DSBINT				; To IPL 31
	BSBW	MAP_MASSBUS		; Remap the Massbus address space

	$PRTCTINI B^600$,#MCHK$M_NEXM

	MOVL	ADP$L_CSR(R4),R0	; Get adapter CSR address

; This is the first reference to the Massbus Adapter address space

	MOVL	MBA$L_CSR(R0),R1	; Read MBA CSR
	CMPB	R3,R1			; Is this he same adapter type?
	BNEQ	120$			; No, time to reboot
	MOVZBL	#1,R2			; Assume success
	BITL	#MBA$M_CSR_PU,MBA$L_CSR(R0) ; Power up?
	BNEQ	560$			; Yes
	MOVL	#MBA$M_CSR_PD,MBA$L_CSR(R0) ; No, clear other MBA CSR error bits
	CLRL	R2			; Flag no power up yet
560$:
	$PRTCTEND 600$

	BLBC	R0,700$			; MBA cannot be accessed
	BLBC	R2,700$			; MBA power up not asserted
	BRW	RESTART_MBA		; MBA is up and kicking
700$:
	BSBW	UNMAP_MASSBUS		; Not there yet
	BRW	UBA_PWR_RET		; REI and wait for another interrupt
 

	.SBTTL	WAIT_TEST - WAIT FOR BIT OR TIMEOUT
;++
; WAIT_TEST - TEST FOR BIT SET OR WAIT FOR 60 MS, WHICHEVER COMES FIRST
;
; FUNCTIONAL DESCRIPTION:
;
;	WAIT FOR SPECIFIED BIT TO BE SET IN SPECIFIED REGISTER
;	WAIT FOR MAXIMUM SIX 10MS TODR CLOCK TICKS (50-60 MS)
;	RETURN SUCCESS IF BIT SET, FAILURE IF BIT DID NOT SET IN 60 MS
;
; INPUTS:
;
;	R0 - ADDRESS OF LOCATION THAT CONTAINS BIT TO TEST
;	(SP) - BIT NUMBER TO TEST
;
; OUTPUTS:
;
;	R0 - 1 --> BIT SET IN TIME
;	R0 - 0 --> BIT DID NOT SET WITHIN 60 MS
;	R1,R2,R3 DESTROYED, OTHER REGISTERS PRESERVED
;--
 
WAIT_TEST:
	MOVZBL	@(SP),R2		; GET BIT NUMBER TO TEST
	INCL	(SP)			; BUMP RETURN PAST PARAMATER
	MFPR	#PR$_TODR,R1		; GET CURRENT TIME IN 10 MS TICKS
10$:	MOVL	(R0),R3			; READ REGISTER
	BBS	R2,R3,20$		; BRANCH IF BIT SET
	MFPR	#PR$_TODR,R3		; GET NEW TIME
	SUBL	R1,R3			; GET ELAPSED TIME
	CMPL	#UBAMAXTIM,R3		; HAVE 6 TICKS GONE BY?
	BGTRU	10$			; NO, KEEP LOOKING
	CLRL	R0			; YES, RETURN .FALSE.
	RSB
20$:	MOVL	#1,R0				; BIT BECAME SET, RETURN .TRUE.
	RSB

	.SBTTL	INI$MPMADP - BUILD ADP AND INITIALIZE MULTI-PORT MEMORY
;+
; INI$MPMADP IS CALLED AFTER  MAPPING THE REGISTERS FOR A MULTI-PORT
; MEMORY ADAPTER.  AN ADAPTER CONTROL BLOCK IS ALLOCATED AND FILLED.
; THE HARDWARE ADAPTER IS THEN INITIALIZED BY CALLING MPM$INITIAL.
;
; NOTE:	THIS ROUTINE HAS BEEN LOCATED HERE IN SYSLOAXXX.EXE INSTEAD OF
;	INILOA.EXE BECAUSE IT CAN BE CALLED WHILE THE SYSTEM IS RUNNING
;	LONG AFTER INILOA.EXE HAS BEEN DELETED!!!
;
; INPUT:
;	R4 - nexus identification number of this nexus
;
; OUTPUTS:
;	ALL REGISTERS PRESERVED
;-
NUMMPMVEC = 16				; NUMBER OF INTER-PORT INTERRUPT VECTORS

INI$MPMADP::				; INITIALIZE MPM DATA STRUCTURES
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10> ; SAVE REGISTERS
;
; Allocate and initialize Adapter Control Block (ADP).
;
	MOVZWL	#ADP$C_MPMADPLEN+-	; GET SIZE OF ADP PLUS VECTOR
		<NUMMPMVEC * 4>,R1	; DISPATCH TABLE
	JSB	@#EXE$ALONONPAGED	; ALLOCATE ADP FOR ADAPTER
	MOVL	R2,R3			; COPY ADDRESS
	MOVL	@#MMG$GL_SBICONF,R8	; GET SYSTEM ADDRESS OF CONFIG ARRAY
	ASSUME	ADP$L_CSR EQ 0
	MOVL	(R8)[R4],(R3)+		; SET ADDRESS OF CONFIG REGISTER
	ASSUME	ADP$L_LINK EQ 4
	CLRL	(R3)+			; CLEAR LINK FIELD
	ASSUME	ADP$W_SIZE EQ 8
	MOVW	R1,(R3)+		; SET SIZE OF STRUCTURE
	MOVZBW	#DYN$C_ADP,(R3)+	; SET TYPE OF STRUCTURE
	ASSUME	ADP$W_TR EQ 12
	MOVW	R4,(R3)+		; SET NEXUS NUMBER OF ADAPTER
	ASSUME	ADP$W_ADPTYPE EQ 14
	MOVW	#AT$_MPM,(R3)+		; SET THE ADAPTER TYPE
	ASSUME	ADP$L_VECTOR EQ 16
	MOVAL	ADP$L_INTD+8(R2),R1	; GET ADDRESS OF DISPATCH TABLE
	MOVL	R1,(R3)+		; SET ADDRESS OF DISPATCH TABLE
	ASSUME	ADP$L_PRQQFL EQ 20
	MOVL	R3,(R3)+		; INIT PRQ WAIT QUEUE HEAD
	MOVAL	ADP$L_PRQQFL(R2),(R3)+ 	; INIT PRQ WAIT QUEUE
	CLRL	(R3)+			; CLEAR CELL
;
; Initialize adapter interrupt vectors in System Control Block.
;
	MOVL	@#EXE$GL_SCB,R0		; GET ADDRESS OF SCB
	EXTZV	#0,#4,R4,R4		; Get low 4 bits of nexus number.
	MOVAL	^X100(R0)[R4],R0	; COMPUTE ADDR OF 1ST INT VECTOR
					; *** VECTORS WITHOUT JUMPER ***
	MOVAB	ADP$L_INTD+1(R2),(R0)	; CONNECT IPL 20 TO DISPATCHER
	MOVAB	G^EXE$INT58+1,64(R0)	; CONNECT IPL 21 TO ERROR LOGGER
					; *** VECTORS WITH JUMPER ***
	MOVAB	ADP$L_INTD+1(R2),128(R0) ; CONNECT IPL 22 TO DISPATCHER
	MOVAB	G^EXE$INT58+1,192(R0)	; CONNECT IPL 23 TO ERROR LOGGER
					; ***
;
; Initialize inter-port dispatcher.
;
	MOVQ	B^MPMINTD,ADP$L_INTD(R2) ; INIT INTER-PORT DISPATCHER
	MOVL	#NUMMPMVEC,R0		; GET NUMBER OF VECTORS IN TABLE
10$:
	CLRL	(R1)+			; SET VECTOR TO "NOT IN USE"
	SOBGTR	R0,10$			; DECREMENT COUNT AND LOOP
	MOVL	ADP$L_CSR(R2),R4	; GET ADAPTER CSR ADDRESS
	MOVL	MPM$L_CSR(R4),R0	; GET CSR VALUE
	EXTZV	#MPM$V_CSR_PORT,-	; GET PORT NUMBER
		#MPM$S_CSR_PORT,R0,R0	;
	MOVB	R0,ADP$B_PORT(R2)	; SAVE PORT NUMBER
	BSBB	ADPLINK			; LINK ADP TO END OF CHAIN
;
; Initialize adapter hardware.
;
	JSB	@#MA$INITIAL 		; INITIALIZE THE ADAPTER
	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10> ; RESTORE REGS
	RSB

MPMINTD:				; MULTI-PORT INTERRUPT DISPATCHER
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	;
	JSB	@#MA$INT 		;


	.SBTTL	ADPLINK - LINK ADAPTER CONTROL BLOCK INTO ADP LIST
;+
; ADPLINK LINKS THE ADAPTER CONTROL BLOCK  TO THE END OF THE ADP LIST
;
; INPUT:
;	R2 - ADDRESS OF NEW ADP
; OUTPUTS:
;	ADP IS LINK TO THE END OF THE ADPLIST LOCATED BY IOC$GL_ADPLIST.
;	R0,R1 destroyed.
;-

ADPLINK:				;
	MOVAB	@#<IOC$GL_ADPLIST-ADP$L_LINK>,R0
					; START OF LIST
10$:	MOVL	ADP$L_LINK(R0),R1	; FLINK TO FIRST ENTRY
	BEQL	20$			; AT END
	MOVL	R1,R0			; TRY AGAIN
	BRB	10$			;
20$:	MOVL	R2,ADP$L_LINK(R0)	; CHAIN NEW ADP TO END OF LIST
	RSB				; AND RETURN

	.END
