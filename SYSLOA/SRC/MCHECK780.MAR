	.IF	NDF,PRMSW		; PRMSW => Multi-processor copy.
	.TITLE	MCHECK780 - MACHINE CHECK EXCEPTION HANDLER FOR 11/780
	.IFF				; no PRMSW => SYS.EXE copy.
	.TITLE	MPMCHECK - MACHINE CHECK EXCEPTION HANDLER FOR MP SECONDARY
	.ENDC
	.IDENT	'V03-004'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:	EXECUTIVE, ERROR HANDLING
;
; ABSTRACT: IN A NUTSHELL, LOG IT AND TRY TO RECOVER.
;
; ENVIRONMENT:	RUNS ON INTERRUPT STACK AT IPL 31 UNTIL ERROR TYPE IS KNOWN
;		AND (IF POSSIBLE) CORRECTED, THEN RUNS AT SYNCH LEVEL
;		TO DO THE ERROR LOGGING.

;--
	.SBTTL	HISTORY			; DETAILED
;
; AUTHOR: RICHARD LARY	, CREATION DATE: 6-NOV-77
;
; MODIFIED BY:
;
;	V03-004	TCM0010		Trudy C. Matthews	13-Apr-1982
;		Corrected code in CPUTIMEOUT paragraph.  There was an
;		error in the way it determined if this machine check was
;		the result of reading a BRRVR register in the UBA.
;
;	V03-003	TCM0009		Trudy C. Matthews	5-Apr-1982
;		Altered table of resumable instructions to make interlocked
;		queue instructions and "reserved to DIGITAL" instructions
;		non-resumable.
;
;	V03-002	NPK2017		N. Kronenberg		23-Mar-1982
;		Fixed mchk and cache parity to not inhibit SBI cache
;		invalidates.  Fixed count of number of memory error
;		counters zeroed to 16 which is the number of counters
;		actually defined.
;
;	V02-026	TCM0008		Trudy C. Matthews	17-Mar-1982
;		Update MS780E bit definitions.  Also, attempt to log fatal
;		MS780E memory controller errors.
;
;	V02-025	HRJ0050		Herb Jacobs		25-Jan-1982
;		Add counters for machine checks and memory errors.
;
;	V02-024	TCM0007		Trudy C. Matthews	18-Nov-1981
;		Add a threshold of CRD memory errors, above which CRD errors
;		are no longer logged.  This can prevent the error log file
;		from being filled with CRD error reports from one bad memory
;		location.
;
;	V02-023	TCM0006		Trudy C. Matthews	11-Nov-1981
;		In the memory timer scan routine (ECC$REENABLE), disable all
;		interrupts only when taking copies of memory registers for
;		the error log.  This ensures a consistent snapshot of the
;		registers, and avoids executing at IPL 31 for longer than
;		necessary.
;
;	V02-022	KDM0068		Kathleen D. Morse	10-Nov-1981
;		Clear MA780 power-up bit in the Port Configuration
;		Register, so that power-up of a port does not cause
;		repeated machine-checks.  Also, clear all error bits by
;		writing the register contents into the register rather
;		than with hex bit masks.
;
;	V02-021	TCM0005		Trudy C. Matthews	2-Nov-1981
;		Update support for MS780E memory controller error handling.
;
;	V02-020	TCM0004		Trudy C. Matthews	31-Aug-1981
;		Protect against machine checks when reading the MA780's
;		Port Controller Status register.
;
;	V02-019	TCM0003		Trudy C. Matthews	14-Aug-1981
;		When handling hard memory errors (RDS), don't try to look
;		at PFN data base of PFNMAP pages.
;
;	V02-018	TCM0002		Trudy C. Matthews	8-Jul-1981
;		Re-wrote much of the memory error handling code.  The goals
;		were to (1) separate the error code for each type of memory
;		controller into its own routine, and (2) add support for the
;		MS780E memory controller.  Also merged multi-processor
;		machine check with this module; the different objects are
;		created by assembling with PRMSW defined (for the secondary
;		processor) or with PRMSW not defined (for the primary
;		processor or a single processor system).
;
;	V02-017	CAS0028		C. A. Samuelson		6-Jul-1981
;		Fixed bug in cache error handling logic.
;
;	V02-016	LJK0030		Lawrence J. Kenah	10-Jun-1981
;		Replace all PFN references to FLINK and BLINK with
;		the PFN_REFERENCE macro to support large physical
;		memory configurations.
;
;	V0215	TCM0001		Trudy C. Matthews	08-May-1981
;		Change all references to RPB$B_CONFREG to use EXE$GL_CONFREG
;		instead.  Also change references to MMG$AL_SBICONF to use
;		MMG$GL_SBICONF.
;
;	V0214	CAS0015		C. A. Samuelson		17-Apr-1981
;		Add test for UBA BRRVR register refference in CPU TIMEOUT
;		machine check.  If machine check occurs when reading BRRVR
;		register, log it and REI.
;
;	V0213	CAS0006		C. A. Samuelson		31-Dec-1980
;		Happy New Year
;		Fixed bug in RDS error handling code
;
;	V0212	CAS0203		C. A. Samuelson		12-Aug-1980
;		Removed I/O Adapter error handling code to separate module
;
;	V0211	CAS0016		C. A. Samuelson		7-Mar-1980
;		Saved registers destroyed by SBI Fault and Asynch write errors
;

	.SBTTL	MEMORY_ROUTINES Macro
;++
; Macro MEMORY_ROUTINES
;	Build action routine vectors for different memory types.
;
; Inputs:
;	MEMTYPES	- A list of "NDT$_" type codes for this controller.
;	LOGERR_RTN	- Action routine that determines if an error was
;			  reported for this controller; if so, it logs it.
;	LOGALL_RTN	- Action routine to unconditionally log this
;			  controller's registers.
;	ENAB_RTN	- Action routine to enable CRD interrupts for this
;			  memory controller.
;
; Outputs:
;	Addtions to LOGERR_ROUTINES, LOGALL_ROUTINES, and ENAB_ROUTINES arrays.
;
; Note:	Each invocation of this macro corresponds to one "general" memory type.
;	Each element in MEMTYPES list corresponds to one "specific" type.
;__
	.MACRO	MEMORY_ROUTINES		MEMTYPES,LOGERR_RTN,LOGALL_RTN,ENAB_RTN
	.SAVE
;
; Create arrays to map a set of specific type codes to one general memory type.
; Note: Psects MCHK$DATA0 and MCHK$DATA1 must be contiguous.
;
	.IRP	MEMTYP,MEMTYPES		; Repeat for each memory type...

	.PSECT	MCHK$DATA0		; Add specific-type entry to MEMTYP
	.BYTE	MEMTYP			; array.

	.PSECT	MCHK$DATA1		; Add general-type entry to array.
	.BYTE	GENERAL_MEMTYP

MEMTYPCNT = MEMTYPCNT + 1
	.ENDR
GENERAL_MEMTYP = GENERAL_MEMTYP + 1
;
; Now create action routine vectors.
;
	.PSECT	MCHK$DATA2		; LOGERR_ROUTINES array:
	.LONG	<LOGERR_RTN-.>		; Add self-relative offset to routine.

	.PSECT	MCHK$DATA3		; LOGALL_ROUTINES array:
	.LONG	<LOGALL_RTN-.>		; Add self-relative offset to routine.

	.PSECT	MCHK$DATA4		; ENAB_ROUTINES array:
	.LONG	<ENAB_RTN-.>		; Add self-relative offset to routine.

	.RESTORE
	.ENDM	MEMORY_ROUTINES

	.SBTTL	SYMBOL DEFINITIONS


CH_THRESHOLD	=	10.		;3 ERRORS IN 100 MS TO DISABLE CACHE
CH_MISSG0	=	^X10000		;"FORCE MISS GROUP 0" BIT
CH_MISSG1	=	^X8000		;"FORCE MISS GROUP 1" BIT
CH_REPLG0	=	^X4000		;"FORCE REPLACE GROUP 0" BIT
CH_REPLG1	=	^X2000		;"FORCE REPLACE GROUP 1" BIT
CH_REPAIR	=	^X21C000	;BITS TO SET IN SBIMT ON CACHE ERRORS
CH$V_G0ERRS	=	3		;START OF GROUP 0 ERRORS IN PARITY REG
CH$S_G0ERRS	=	7		;LENGTH OF GROUP 0 ERROR BITS
CHLOG_DISAB0	=	1		;LOG BIT SAYING WE DISABLED GROUP 0
CHLOG_DISAB1	=	2		;LOG BIT SAYING WE DISABLED GROUP 1


SBIFS$V_NEF	=	25		;NESTED ERROR FLAG IN SBI FAULT/STATUS

;THE FOLLOWING 5 DEFINITIONS ARE IN THE SBI ERROR REGISTER
SBIER$M_IBTO	=	^X40		;IB TIMEOUT LATCH
SBIER$M_IBRDS	=	^X80		;IB RDS LATCH
SBIER$M_CPTO	=	^X1000		;CP TIMEOUT LATCH
SBIER$M_RDS	=	^X2000		;RDS LATCH
SBIER$M_CRD	=	^X4000		;CRD LATCH


;	MACHINE CHECK HARDWARE LOG OFFSETS

MCL_COUNT	=	0		;BYTE LENGTH OF AREA (28 HEX)
MCL_SUMMARY	=	4		;SUMMARY WORD - BYTE 0=CODE, BYTE 1=
					;TIMEOUT PENDING FLAG
MCL_CES		=	8		;CPU ERROR STATUS
MCL_UPC		=	12.		;MICRO-PC AT FAULT TIME
MCL_VA		=	16.		;VIRTUAL ADDR AT FAULT TIME
MCL_D		=	20.		;CPU D REGISTER AT FAULT TIME
MCL_TBER0	=	24.		;TRANSLATION BUFFER STATUS REG 0
MCL_TBER1	=	28.		;TBUF STATUS REG 1
MCL_TIMOADDR	=	32.		;PHYSICAL ADDRESS CAUSING SBI TIMEOUT
MCL_PARITY	=	36.		;CACHE STATUS REGISTER
MCL_SBIERR	=	40.		;SBI ERROR REGISTER
MCL_PC		=	44.		;PC OF INSTRUCTION WHICH CAUSED CHECK
MCL_PSL		=	48.		;PSL OF MACHINE AT FAULT TIME

	.SBTTL MEMORY CONTROLLOR AND ERROR DEFINITIONS

;
; Common error bit definitions.
;
MRC$V_ELSRF	=	28		;ERROR LOG SERVICE REQUEST
MRC$M_ELSRF	=	^X10000000	;WRITE 1 TO CLEAR FLAG
MRC$V_HERIMF	=	29		;HIGH ERROR RATE IN MEMORY
MRC$M_HERIMF	=	^X20000000	;WRITE 1 TO CLEAR FLAG
MRC$V_INHBCRD	=	30		;1 DISABLES CRD INTERRUPT
MRC$M_INHBCRD	=	^X40000000	;0 CRD INTERRUPT ENABLE, 1 CRD DISABLE
;
; MA780-specific error bit definitions (in Array Error Register).
;
MRC$V_INVMAPPTY	=	31		;INVALID MAP PARITY ERROR
MRC$M_INVMAPPTY	=	^X80000000	;WRITE 1 TO CLEAR THE FLAG
;
; MS780E-specific error bit definitions.
;
					;FOLLOWING BITS ARE IN REGISTER A
MRC$V_SUMMARY	=	20		;ERROR SUMMARY BIT
MRC$M_SUMMARY	=	^X00100000	;OR OF ALL ERROR BITS -- READ ONLY
MRC$V_CTL1PTY	=	19		;PARITY ERROR ON READ DATA FROM
MRC$M_CTL1PTY	=	^X00080000	;CONTROLLER 1 TO SBI INTERFACE.
MCR$V_CTL0PTY	=	18		;PARITY ERROR ON READ DATA FROM
MRC$M_CTL0PTY	=	^X00040000	;CONTROLLER 0 TO SBI INTERFACE.
					;FOLLOWING BITS ARE IN REGISTERS C & D
MRC$V_MSEQPTY	=	7		;MICROSEQUENCER PARITY ERROR
MRC$M_MSEQPTY	=	^X00000080	;
MRC$V_IFPTY	=	8		;PARITY ERROR ON WRITE DATA FROM
MRC$M_IFPTY	=	^X00000100	;SBI INTERFACE TO CONTROLLER.

REENABTIME	= 60*15			;REENABLE INTERRUPT ERROR LOGGING
					;EVERY 15 MINUTES
SOMETIME	= 60			;SCAN FOR NON-INTERRUPT ERRORS
					;EVERY 60 SECONDS
CRDINTMAX	= 3			;MAXIMUM NUMBER OF INTERRUPTS A CONT
					;IS ALLOWED WITHIN REENABTIME
CRDWATCHMAX	= 6			;MAXIMUM NUMBER OF ERRORS TO BE LOGGED
					;WITHIN REENABTIME
 
;	INCLUDED SYMBOL DEFINITIONS

	$ADPDEF				;DEFINE ADAPTER CONTROL BLOCK SYMBOLS
	$EMBDEF	<MC,SB,SE>		;DEFINE EMB OFFSETS
	$IPLDEF				;PROCESSOR INTERRUPT LEVELS
	$MCHKDEF			;DEFINE RECOVERY BLOCK MASK BITS
	$NDTDEF				;DEFINE NEXUS DEVICE TYPES
	$PCBDEF				;PROCESS CTL BLOCK
	$PFNDEF				;PFN DATA BASE
	$PRDEF				;DEFINE PROCESSOR REGISTER NUMBERS
	$PSLDEF				;DEFINE PSL
	$PTEDEF				;PTE SYMBOLS
	$SSDEF				;DEFINE SYSTEM STATUS VALUES
	$VADEF				;DEF IN PFN PITS

	.SBTTL	MEMORY ACTION ROUTINE ARRAYS

	.PSECT	MCHK$DATA0,LONG,WRT
MEMTYP:					; Define base of array of memory type
					; codes.
	.PSECT	MCHK$DATA2,LONG,WRT
LOGERR_ROUTINES:			; Define base of array of routines to
					; log memories with errors.
	.PSECT	MCHK$DATA3,LONG,WRT
LOGALL_ROUTINES:			; Define base of array of routines to
					; unconditionally log memories.
	.PSECT	MCHK$DATA4,LONG,WRT
ENAB_ROUTINES:				; Define base of array of routines to
					; enable CRD interrupts in memories.
;
; The following macro invocations add elements to the above arrays for each
; memory type.
;

MEMTYPCNT = 0
GENERAL_MEMTYP = 0

	MEMORY_ROUTINES -		; MS780C memory controller.
		MEMTYPES=<NDT$_MEM4NI,NDT$_MEM4I,NDT$_MEM16NI,NDT$_MEM16I>, -
		LOGERR_RTN = LOG_MS780C, -
		LOGALL_RTN = LOGC, -
		ENAB_RTN = ENAB_MS780C

	MEMORY_ROUTINES -		; MA780 memory controller.
		MEMTYPES=<NDT$_MPM0,NDT$_MPM1,NDT$_MPM2,NDT$_MPM3>, -
		LOGERR_RTN = LOG_MA780, -
		LOGALL_RTN = LOGMA, -
		ENAB_RTN = ENAB_MA780

	MEMORY_ROUTINES -		; MS780E memory controller.
		MEMTYPES=<NDT$_MEM64NIL,NDT$_MEM64EIL,NDT$_MEM64NIU, -
			  NDT$_MEM64EIU,NDT$_MEM64I>, -
		LOGERR_RTN = LOG_MS780E, -
		LOGALL_RTN = LOGE, -
		ENAB_RTN = ENAB_MS780E

	.SBTTL	LOCAL DATA STORAGE
 
;
; Macro that will define a global name of the form MPS$ if
; PRMSW is defined, else EXE$.  It will also define a local name
; to be used within this module.
;
	.MACRO	GBLDEF	NAME
	.IF	DF,PRMSW		; For multi-processor code...
MPS$'NAME'::
	.IFF				; For MCHECK780...
EXE$'NAME'::
	.ENDC
'NAME':					; For local use...
	.ENDM	GBLDEF

	.PSECT	MCHK$DATA,QUAD,WRT

; The following symbol is defined for a transfer vectror in SYSLOAVEC
; This location is NEVER JUMPED TO.  It is defined so these counters
; Can be located using a global symbol in the system map.

EXE$MCHK_ERRCNT::			;GLOBAL SYMBOL FOR SYSLOAVEC POINTER
GBLDEF	GL_CSBITA			;USED TO HOLD COMPLEMENT OF SBITA
		.LONG	0
GBLDEF	GL_CH1OLD			;TIME OF LAST CACHE ERROR
		.LONG	0
GBLDEF	GL_CH2OLD			;TIME OF NEXT-TO-LAST CACHE ERROR
		.LONG	0
GBLDEF	GL_CPTIMOUT			;TIME OF LAST CP TIMEOUT/SBI ERROR
		.LONG	0
GBLDEF	AB_MEMERR			;ERROR COUNTERS FOR 16 ADAPTERS
	.BLKB	16
GBLDEF	GW_REENAB			;REENABLE TIMER
		.WORD	0
GBLDEF	GW_WATCH			;SCAN MEMORY CONTROLLER TIMER
		.WORD	0
GBLDEF	GL_CRDCNT			;COUNT OF CORRECTED MEMORY ERRORS
		.LONG	0
GBLDEF	GL_CHSTATE			;CURRENT STATE OF CACHE
		.LONG	^X200200
GBLDEF	GL_BADTIMOUT			;TIME SINCE LAST BAD MCHK CODE
		.LONG	0
 

	.SBTTL	MACHINE CHECK ENTRY POINT
	.PSECT	MCHK$CODE,QUAD,RD,WRT

;	MACHINE CHECK ENTRY POINT - SCB VECTOR POINTS HERE.
;	IPL ^X1F = 31

	.ALIGN	LONG			;A VECTOR MUST HAVE LONGWORD ALIGNMENT
GBLDEF	MCHK				;EITHER EXE$MCHK:: OR MPS$MCHK::

	MTPR	#CH_REPAIR,#PR$_SBIMT	;FORCE MISSES AND GROUP 0 REPLACE,
					; BUT ALLOW SBI TO INVALIDATE CACHE
	PUSHL	#MCHK$M_LOG		;MASK WORD FOR PRTCTEST
	PUSHAL	MCL_PC+4(SP)		;PC,PSL POINTER FOR PRTCTEST
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,AP>
	ADDL3	#<9*4>,SP,AP		;POINT AP TO LOG FRAME ON STACK
					;ALL INTERRUPTS ARE LOCKED OUT!
	BICB3	#^XF0,MCL_SUMMARY(AP),-(SP) ;GET LOW 4 BITS OF TYPE CODE
	CASE	(SP)+,<-		;BREAKOUT TYPE CODE
		CPTIMEOUT,-		;CPU TIMEOUT/SBI ERROR CONFIRMATION
		CSPARITY,-		;CONTROL STORE PARITY ERROR
		TBUFPARITY,-		;TRANSLATION BUFFER PARITY ERROR
		CACHEPARITY,-		;CACHE PARITY ERROR
		BADTYPE,-		;THIS CODE DOESN'T EXIST
		READSUBST,-		;READ DATA SUBSTITUTE (MEM READ ERROR)
		IBROMCHECK,-		;"CAN'T GET HERE" ERROR FROM INST ROMS
		BADTYPE,-
		BADTYPE,-
		BADTYPE,-	
		TBUFPARITY,-		;IB-DETECTED TBUF ERROR
		BADTYPE,-
		READSUBST,-		;IB-DETECTED MEMORY ERROR
		CPTIMEOUT,-		;IB-DETECTED TIMEOUT OR SBI ERROR CONF
		BADTYPE,-
		CACHEPARITY>, TYPE=B	;IB-DETECTED CACHE PROBLEM

BADTYPE:
	MTPR	W^GL_CHSTATE,#PR$_SBIMT ;RE-ENABLE THE CACHE
	BISL	#MCHK$M_MCK,-4(AP)	;MASK FOR PRTCTEST
	PUSHL	W^GL_BADTIMOUT		;TIME OF LAST BAD TYPE FAULT
	MFPR	#PR$_TODR,W^GL_BADTIMOUT ;TIME OF CURRENT FAULT
	CMPL	(SP)+,W^GL_BADTIMOUT	;COMMING TOO FAST?
	BNEQ	DAMPUTATE		;YES, ABORT
100$:
	POPR	#^M<R0,R1,R2,R3,R4,R5,AP>
	.IF	NDF,PRMSW		;*****FOR PRIMARY PROCESSOR...
	JSB	G^EXE$MCHK_BUGCHK	;RECOVERY BLOCK ENABLED?
	BUG_CHECK BADMCKCOD,FATAL	;BAD MACHINE CHECK CODE
	.IFF				;*****FOR SECONDARY PROCESSOR...
	SECBUG_CHECK	MPBADMCK,FATAL	;BAD MACHINE CHECK CODE
	.ENDC

	.SBTTL	TRANSLATION BUFFER PARITY ERRORS

TBUFPARITY:
	MTPR	W^GL_CHSTATE,#PR$_SBIMT	;RE-ENABLE CACHE
	MTPR	#0,#PR$_TBIA		;CLEAR ENTIRE TBUF
	BISL	#MCHK$M_MCK,-4(AP)	;SET MACHINE CHECK CODE FOR PRTCTEST


TRYRESUME:
	BITW	#^X1F0,MCL_SUMMARY(AP)	;IS ERROR ABORT OR TIMEOUT PENDING
DAMPUTATE:
	BNEQ	AMPUTATE		;BRANCH IF YES, NO HOPE OF RESUMING
	BITB	#8,MCL_SUMMARY(AP)	;SEE IF ERROR WAS IB ERROR
	BNEQ	10$			;IF SO, WE CAN "DEFINITELY" RESUME
	MOVZBL	@MCL_PC(AP),-(SP)	;GET OPCODE FOR RESTARTABILITY CHECK
	BBC	(SP)+,W^RESUMABLE,AMPUTATE ;BRANCH IF INST NOT RESUMABLE,ABORT
10$:	;THERE IS A LOW PROBABILITY CASE HERE THAT MAY ALLOW THIS CODE TO
	;CONTINUE WHEN WE CAN'T - IF A LOCATION IS READ FROM THE IO PAGE AND
	;HAS A SIDE AFFECT WHICH MODIFIES THAT LOCATION, THE INSTRUCTION IS
	;NOT RETRYABLE, A SOFTWARE SOLUTION IS TO IMPLEMENT A FLAG SET BY ANY
	;POTENTIAL REFERENCE TO THE IO PAGE THAT MAY CAUSE A SIDE AFFECT.
	;BBS	#IOSAFLAG,FLAG,AMPUTATE	;BRANCH IF INST MAY OF HAD SIDE AFFECT
RESUME:
	MOVW	#EMB$K_MC,R3		;SET TYPE OF LOG ENTRY
	BSBW	LOGGER			;WE'RE GOING TO MAKE IT - LOG ERROR
	POPR	#^M<R0,R1,R2,R3,R4,R5,AP>	;RESTORE REGISTERS
	ADDL	#8,SP			;REMOVE PRTCTEST STUFF FROM STACK
	ADDL	(SP)+,SP		;POP HARDWARE LOG FROM STACK
	REI				;AND TRY AGAIN

	.SBTTL	ERRORS DETECTED IN INSTRUCTION DECODE ROMS
	.SBTTL	CONTROL STORE PARITY ERRORS

IBROMCHECK:
CSPARITY:
	MTPR	W^GL_CHSTATE,#PR$_SBIMT	;CACHE PROBABLY OK - ENABLE IT
	MOVB	@MCL_PC(AP),MCL_SUMMARY+2(AP) ;SAVE OPCODE IN LOG
	BISL	#MCHK$M_MCK,-4(AP)	;SET MASK CODE FOR PRTCTEST
AMPUTATE:
	MOVW	#EMB$K_MC,R3		;SET TYPE OF LOG ENTRY
	BSBW	LOGGER			;LOG THE ERROR
	BBS	#PSL$V_CURMOD+1,MCL_PSL(AP),REFLECTCHK ;BRANCH IF
					;FAILURE IN USER OR SUPERVISOR MODE
 
	POPR	#^M<R0,R1,R2,R3,R4,R5,AP> ;RESTORE REGS
	.IF	NDF,PRMSW		;*****FOR PRIMARY...
	JSB	G^EXE$MCHK_BUGCHK	;RECOVERY BLOCK IN EFFECT?
	BUG_CHECK MACHINECHK,FATAL	;MACHINE CHECK IN KERNEL OR EXEC MODE
	.IFF				;*****FOR SECONDARY...
	SECBUG_CHECK	MPMCHECK,FATAL	;MACHINE CHECK IN KERNEL OR EXEC MODE
	.ENDC

REFLECTCHK:
	MFPR	#PR$_KSP,R0		;GET THE KERNEL MODE STACK POINTER
	MOVQ	MCL_PC(AP),-(R0)	;INTERRUPT PC,PSL TO KERNEL STACK
					;IT IS NOT NECCESARY TO PROBE KERNEL
					;STACK FOR VALIDITY, THE FAILURE WILL
					;BE A KERNEL STACK NOT VALID BUGCHECK
					;FROM WITHIN MACHINE CHECK
	MTPR	R0,#PR$_KSP		;REPLACE THE NEW KERNEL STACK POINTER
	POPR	#^M<R0,R1,R2,R3,R4,R5,AP>	;RESTORE REGISTERS
	ADDL	#8,SP			;CLEAR PRTCTST STUFF
	ADDL	(SP)+,SP		;POP HARDWARE LOG FROM STACK
	MOVAB	G^EXE$MCHECK,(SP)	;SET UP A PC AND PSL FOR EXCEPTION
	EXTZV	#PSL$V_CURMOD,#PSL$S_CURMOD,4(SP),4(SP)
					;GET MODE WE WERE EXECUTING IN
	ROTL	#PSL$V_PRVMOD,4(SP),4(SP) ;CREATE A PSL OF CURRENT TO BE
					;KERNEL WITH CORRECT PREVIOUS MODE
					;AS FROM A FAULT, 0'S IN REST OF PSL
	.IF	NDF,PRMSW		;*****FOR PRIMARY...
	REI				;GET TO EXCEPTION HANDLER
	.IFF				;*****FOR SECONDARY...
	SETIPL	#IPL$_SYNCH		;LOWER IPL, ENABLING INTER-PROC INT.
	BRW	MPS$MPSCHED2		;RETURN PROCESS TO PRIMARY
	.ENDC

	.SBTTL	CACHE PARITY ERROR

CACHEPARITY:	;ENTER WITH CACHE DISABLED REPLACING GROUP 0
	BISL	#MCHK$M_MCK,-4(AP)	;SET MACHINE CHECK TYPE FOR PRTCTEST
	TSTB	@MCL_VA(AP)	;FORCE DATA INTO GROUP 0 OF BAD CACHE LINE
	MTPR	#CH_REPAIR,#PR$_SBIMT
				;NOW FORCE GROUP 1 REPLACEMENT
	TSTB	@MCL_VA(AP)	;AND FORCE GROUP 1 OF BAD LINE TO GOOD DATA
	MFPR	#PR$_TODR,-(SP)		;GET TIME-OF-YEAR IN 10MS TICKS
	SUBL3	W^GL_CH2OLD,(SP),-(SP)	;GET TIME SPAN OF LAST 2 ERRORS-NOW
	CMPL	(SP)+,#CH_THRESHOLD	;ARE THE ERRORS WIDELY SPACED
	BGTRU	20$			;BRANCH IF YES TO FORGIVE THE CACHE
	CMPZV	#CH$V_G0ERRS,#CH$S_G0ERRS,MCL_PARITY(AP),#^B1111111
					;IS GROUP 0 ALL GOOD?
	BNEQ	10$			;BRANCH IF GROUP 0 WAS BAD
	BISB	#CH_MISSG1!CH_REPLG0@-8,W^GL_CHSTATE+1 ;DISABLE GROUP 1
	BICB	#CH_REPLG1@-8,W^GL_CHSTATE+1 ;CANNOT FORCE REPLACE IN BOTH
	MOVB	#CHLOG_DISAB1,MCL_SUMMARY+3(AP) ;LOG THAT WE DID IT
	BRB	20$
10$:	BISW	#CH_MISSG0!CH_REPLG1@-8,W^GL_CHSTATE+1 ;DISABLE GROUP 0
	BICB	#CH_REPLG0@-8,W^GL_CHSTATE+1 ;DON'T FORCE REPLACE IN BOTH!
	MOVB	#CHLOG_DISAB0,MCL_SUMMARY+3(AP) ;LOG THAT WE DID IT
20$:	MOVL	W^GL_CH1OLD,W^GL_CH2OLD ;MAINTAIN THE TIMING HISTORY
	MOVL	(SP)+,W^GL_CH1OLD	;UNTO THE THIRD GENERATION
	MTPR	W^GL_CHSTATE,#PR$_SBIMT	;RE-ENABLE THE CACHE - FINALLY!
BRESUM:	BRW	TRYRESUME		;SEE IF WE CAN CONTINUE FROM THE ERROR

	.SBTTL	CP TIMEOUT / SBI ERROR CONFIRMATION

CPTIMEOUT:
	MTPR	W^GL_CHSTATE,#PR$_SBIMT	;ENABLE THE CACHE
	BISL	#MCHK$M_MCK!MCHK$M_NEXM,-4(AP) ;SET TYPE FOR PRTCTEST

	.IF	NDF,PRMSW		;*****ONLY ON PRIMARY...
; Add check for read of BRRVR register in UBA.  If this machine check
; is the result of a BRRVR read, then just REI.  Someone will either loose
; a character from a terminal, or a device timeout will result.  This is
; better than a system crash.

	MOVL	G^IOC$GL_ADPLIST,R0	;POINT TO ADP LIST
5$:	BEQL	25$			;DONE IF NOTHING LEFT ON LIST
	CMPW	ADP$W_ADPTYPE(R0),#AT$_UBA ;IS THIS ADP FOR A UBA?
	BNEQ	20$			;NO, LOOK AT REST OF LIST
	MOVL	#3,R1			;LOOK AT VA'S OF ALL 4 BRRVR REGISTERS
10$:	ADDL3	#9,ADP$L_UBASCB(R0)[R1],R2 ;CALCULATE ADDRESS OF BRRVR FROM
					;THE SCB VECTOR ADDRESS SAVED IN THE ADP
; **** NOTE ****  THE PREVIOUS INSTRUCTION ASSUMES THE CURRENTLY USED CODING
; SEQUENCE FOR DISPATCHING UBA INTERRUPTS IN THE MODULE INITADP.MAR.  ANY
; CHANGES TO THAT CODE MY AFFECT THIS ROUTINE.  THE ASSUMPTIONS ARE THAT THE
; VIRTUAL ADDRESS OF THE UBA BRRVR REGISTER IS AT AN OFFSET OF 10 BYTES PAST
; THE INTERRUPT VECTOR ADDRESS (9 IS ADDED TO THE SCB VECTOR VALUE BECAUSE
; THE VECTOR HAS BIT 0 SET TO INDICATE HANDLING THE INTERRUPT ON THE INTERRUPT
; STACK) AND THAT R4 AND R5 HAVE BEEN PUSHED ONTO THE STACK.

	CMPL	(R2),MCL_VA(AP)		;SAME VA AS IN MACHINE CHECK STACK?
	BEQL	30$			;YES - WE CAN SAVE THIS ONE
	SOBGEQ	R1,10$			;LOOP THROUGH ALL 4
20$:	MOVL	ADP$L_LINK(R0),R0	;FOLLOW ADP LIST TO END
	BRB	5$
25$:

	.ENDC
					;EXECUTES FOR BOTH PRIMARY AND SECONDARY
	PUSHL	W^GL_CPTIMOUT		;WE ONLY KEEP TRACK OF ONE TIMEOUT
	MFPR	#PR$_TODR,W^GL_CPTIMOUT ;UPDATE THAT HISTORY
	CMPL	(SP)+,W^GL_CPTIMOUT	;ARE TIMEOUTS LESS THAN 10 MS APART?
	BNEQ	BRESUM			;BRANCH IF NOT TO TRY AND CONTINUE
	BRW	AMPUTATE		;OTHERWISE SOMETHING IS VERY WRONG

	.IF	NDF,PRMSW		;*****ONLY ON PRIMARY...
; This machine check was a CPU timeout caused by a read of the BRRVR register
; in the UBA.  Log the error as a machine check, clean up the stack and REI.
; This ignores the interrupt.

; ********* WHAT IS THE "REAL" STATE OF THE UBA AT THIS POINT? *********

30$:	MOVW	#EMB$K_MC,R3		;LOG THE ERROR AS A MACHINE CHECK
	BSBW	LOGGER
	POPR	#^M<R0,R1,R2,R3,R4,R5,AP> ;RESTORE SAVED REGISTERS
	ADDL	#8,SP			;CLEAR PRTCTEST STUFF FROM STACK
	ADDL	(SP)+,SP		;CLEAR MACHINE CHECK FRAME FROM STACK
	ADDL	#8,SP			;CLEAR MACHINE CHECK PC,PSL FROM STACK
	MOVQ	(SP)+,R4		;R4 AND R5 SAVED BY UBA INT DESPATCHER
	REI				;REI ON THE UBA INTERRUPT PC,PSL

	.ENDC

	.SBTTL	READ DATA SUBSTITUTE ERROR

	.ENABL	LSB
READSUBST:
	MTPR	W^GL_CHSTATE,#PR$_SBIMT	;REENABLE CACHE
	BISL	#MCHK$M_MCK,-4(AP)	;SET MACHINE CHECK TYPE FOR PRTCTEST
	MOVAL	MCL_PC(AP),R1		;SET POINTER TO PC,PSL
	MOVL	#EMB$K_HE,R3		;SET HARD MEMORY ERROR TYPE
	BSBW	LOG_ERROR_MEM		;LOG MEMORY ERROR
	.IF	DF,PRMSW		;*****ONLY FOR SECONDARY PROCESSOR...
	BRW	AMPUTATE		;ABORT -- RECOVERY IS USELESS
	.IFF				;*****FOR PRIMARY PROCESSOR...
	EXTZV	#PSL$V_IPL,#PSL$S_IPL,MCL_PSL(AP),-(SP) ;GET IPL WE WERE AT
	CMPL	(SP)+,#IPL$_ASTDEL	;ARE WE AT A NON-PAGEABLE PRIORITY?
	BGTR	BAMPUTATE		;ABORT - RECOVERY IS USELESS
	MOVL	MCL_VA(AP),R2		;GET VIRTUAL ADDRESS OF ERROR
	MOVL	G^SCH$GL_CURPCB,R4	;CURRENT USER'S PCB ADDRESS
	MOVL	PCB$L_PHD(R4),R5	;CURRENT USERS PROCESS HEADER ADDRESS
	JSB	G^MMG$SVAPTECHK		;TURN VA INTO VA OF PTE
	MOVL	(R3),R0			;GET THE PTE WHICH MAPS THE BAD PAGE
	BLSS	5$			;BRANCH IF PAGE VALID
	BRW	RDSNONRES		;ELSE FATAL ERROR
5$:
	BBS	#PTE$V_WINDOW,R0,BAMPUTATE ;BR IF PAGE IS PFN-MAPPED
	ASSUME	PTE$V_PFN EQ 0
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R0,R0 ;ISOLATE PAGE FRAME NUMBER IN PTE
	CMPL	R0,G^MMG$GL_MAXPFN	;IS THERE PFN DATA BASE FOR PAG?
	BGTRU	BAMPUTATE		;BR IF NO PFN DATA BASE FOR PAGE
	MOVL	G^PFN$AB_TYPE,-(SP)	;PFN TYPE ARRAY ADDRESS *********
	BISB	#PFN$M_BADPAG,@(SP)+[R0] ;MARK PAGE BAD		*******
	CLRL	R1			;CLEAR MODIFY BIT PROPAGATOR
	BBCC	#PTE$V_MODIFY,(R3),10$	;TEST (& CLEAR) MODIFY BIT IN PTE
	MOVZBL	#PFN$M_MODIFY,R1	;SET MODIFY PROPAGATOR
10$:	MOVL	G^PFN$AB_STATE,-(SP)	;ADDRESS OF PFN STATE ARRAY ******
	BISB	R1,@(SP)+[R0]		;PROPAGATE MODIFY BIT TO PFN DATABASE **
 
	ASSUME	PFN$M_MODIFY EQ 128
 
	BGTR	15$			;PAGE NOT MODIFIED - HE'S OK
BAMPUTATE:
	BRW	AMPUTATE
15$:	BITW	#^X1F0,MCL_SUMMARY(AP) ;WAS ERROR FAULT OR ABORT?
	BNEQ	BAMPUTATE		;ABORT - DON'T TRY ANY REPAIRS
	BITB	#8,MCL_SUMMARY(AP)	;IS ERROR IB ERROR FAULT
	BNEQ	20$			;BRANCH IF YES, IB ERRORS RESUME
	MOVZBL	@MCL_PC(AP),-(SP)	;GET OPCODE FOR RESTARTABILITY CHECK
	BBC	(SP)+,W^RESUMABLE,BAMPUTATE ;BRANCH IF INST NOT RESUMABLE
20$:	MOVL	G^PFN$AW_REFCNT,-(SP)	;ADDRESS OF PFN REFCNT ARRAY *****
	CMPW	@(SP)+[R0],#1		;CHECK FOR I/O IN PROGRESS, ETC. ***
	BGTRU	BAMPUTATE		;IF SO, DON'T TRY ANYTHING FANCY
	MOVL	G^PFN$AB_TYPE,-(SP)	;ADDRESS OF PFN TYPE ARRAY  *****
	CMPV	#PFN$V_PAGTYP,#PFN$S_PAGTYP,@(SP)+[R0],#PFN$C_SYSTEM ;****
					;CHECK FOR SYSTEM OR GLOBAL PAGE
 
	ASSUME	PFN$C_SYSTEM EQ 1	;CHECK TYPE OF PAGE
	ASSUME	PFN$C_PROCESS EQ 0
 
	BGTRU	BAMPUTATE		;BRANCH IF GLOBAL PAGE

;	IN THE FUTURE WE MAY RECOVER FROM HARD ECC ERRORS ON GLOBAL PAGES
;	AS WELL, BUT FOR NOW WE ABORT THE IMAGE.


30$:	TSTL	R2			;CHECK THE VIRTUAL ADDRESS
	BGTR	40$			;BRANCH IF PAGE IS PROCESS PRIVATE
	MOVAB	G^MMG$AL_SYSPCB,R4	;SYSTEM PAGES ARE KEPT TRACK OF IN
	MOVL	PCB$L_PHD(R4),R5	;A WORKING SET LIST IN THE SYSTEM PCB
40$:	BBCC	#PTE$V_VALID,(R3),50$	;CLEAR VALID BIT FROM PTE
50$:	INVALID	R2			;INVALIDATE TRANSLATION BUFFER OF VA
	MOVL	G^PFN$AW_REFCNT,-(SP)	;ADDRESS OF PFN REFCNT ARRAY  *****
	DECW	@(SP)+[R0]		;REDUCE REFERENCE COUNT TO 0 *****
	BGEQ	60$			;
	JSB	G^MMG$REFCNTNEG		;
60$:	MOVL	G^PFN$Ax_WSLX,-(SP)	;ADDRESS OF PFN WSLX ARRAY  *****
		PFN_REFERENCE	-
	MOVZWL	<@(SP)+[R0],R1>,-	;GET WORKING-SET LIST INDEX FOR PAGE **
		LONG_OPCODE=MOVL,-
		IMAGE=SYSLOA780.EXE
	JSB	G^MMG$DELWSLEX		;DELETE IT FROM THE WORKING SET ITS IN
	JSB	G^MMG$DELCONPFN		;DELETE PAGE FROM PAGE TABLE
	MOVZBL	#PFN$C_BADPAGLST,R2	;SET UP LIST TO PUT PAGE ON
	JSB	G^MMG$INSPFNT		;PUT PAGE ONTO BAD PAGE LIST

; AT THIS POINT, THE PTE FOR THE BAD PAGE CONTAINS ITS MASS STORAGE
; ADDRESS. THIS WILL CAUSE A FRESH COPY OF THE PAGE TO BE FETCHED WHEN
; THE PROCESS IS RESUMED.

	BRW	RESUME			;LOG MACHINE CHECK AND RESUME PROCESS

RDSNONRES:				;
 
	POPR	#^M<R0,R1,R2,R3,R4,R5,AP>
	JSB	G^EXE$MCHK_BUGCHK	;RECOVERY BLOCK IN EFFECT?
	BUG_CHECK RDSNONRES,FATAL	;READ DATA SUBSTITUTE PAGE NONRESIDENT

	.DSABL	LSB

	.ENDC

	.SBTTL	INTERFACE FROM MACHINE CHECK HANDLER TO ERROR LOGGER
;++
; LOGGER - Routine to log Machine Check interrupts and aborts
;
; INPUTS:
;
;	R3 - Error log type
;	AP - Pointer to Machine Check error log frame
;	-4(AP) - MASK FOR PRTCTEST
;	-8(AP) - PC,PSL POINTER FOR PRTCTEST
;
; OUTPUTS:
;
;	Entry made in error log conditional on PRTCTEST
;	R0-R5 destroyed
;--
 
LOGGER:
	ADDL3	MCL_COUNT(AP),#<2*4>,R4	;GET SIZE OF ENTRY IN BYTES
	MOVAB	MCL_SUMMARY(AP),R5	;GET ADDRESS OF ENTRY
	MOVQ	-8(AP),R1		;GET MASK AND PC POINTER FOR PRTCTEST
	JSB	G^EXE$MCHK_TEST		;ARE WE TO LOG THIS ERROR?
	BLBS	R0,10$			;NO, RECOVERY BLOCK IGNORES IT
	INCL	G^EXE$GL_MCHKERRS	;KEEP COUNT OF MACHINE CHECKS
10$:					;FALL THROUGH TO "LOGIT"
 
;++
; LOGIT - INTERFACE TO SYSTEM ERROR LOG
;
; INPUTS:
;
;	R1 = PC,PSL POINTER FOR PRTCTEST
;	R2 = MASK FOR PRTCTEST
;	R3 = ERROR LOG TYPE
;	R4 = SIZE OF LOG ENTRY IN BYTES
;	R5 = ADDRESS OF LOG ENTRY
;	(SP) = RETURN ADDRESS
;--
	.ENABL	LSB

LOGIT:
	MFPR	#PR$_SBIFS,R0		;GET SBI FAULT/STATUS REGISTER
	BBCC	#SBIFS$V_NEF,R0,10$	;CLEAR NESTED ERROR FLAG
10$:	MTPR	R0,#PR$_SBIFS		;WRITE IT BACK TO CLEAR SILO LOCK
					;AND FAULT LATCH
	MFPR	#PR$_SBIER,R0		;GET SBI ERROR REGISTER
	BISW	#SBIER$M_IBTO!SBIER$M_IBRDS!SBIER$M_CPTO!SBIER$M_RDS!-
		SBIER$M_CRD,R0		;SET BITS FOR ERRORS WE'RE HANDLING
	MTPR	R0,#PR$_SBIER		;WRITE IT BACK TO CLEAR LATCHES
	 
	.IF	NDF,PRMSW		;*****ONLY ON PRIMARY PROCESSOR...
	JSB	G^EXE$MCHK_TEST		;ARE WE TO LOG THIS ERROR?
	BLBS	R0,20$			;NO, RECOVERY BLOCK IGNORES IT
	.ENDC
 
MCHK$GL_LOG::
 
	ADDL3	#EMB$B_MC_SUMCOD,R4,R1	;ADD SPACE FOR HEADER FOR BUFFER SIZE

	.IF	NDF,PRMSW		;*****FOR PRIMARY PROCESSOR...
	JSB	G^ERL$ALLOCEMB		;GET AN ERROR LOGGING BUFFER
	.IFF				;*****FOR SECONDARY PROCESSOR...
	JSB	G^MPS$ALLOCEMB		;GET AN ERROR LOGGING BUFFER
	.ENDC

	BLBC	R0,20$			;BRANCH IF DIDN'T GET IT
	PUSHL	R2			;SAVE ADDRESS OF ERROR LOG BUFFER
	MOVW	R3,EMB$W_MC_ENTRY(R2)	;SET ENTRY TYPE TO FAULT TYPE
	MOVC3	R4,(R5),EMB$B_MC_SUMCOD(R2) ;IN ONE SWELL FOOP.....
	MOVL	(SP)+,R2		;GET POINTER TO BUFFER START IN R2

	.IF	NDF,PRMSW		;*****FOR PRIMARY PROCESOR...
	JSB	G^ERL$RELEASEMB		;INDICATE BUFFER READY TO LOG
	.IFF				;*****FOR SECONDARY PROCESSOR...
	JSB	G^MPS$RELEASEMB		;INDICATE BUFFER READY TO LOG
	.ENDC

20$:	RSB				;EXIT WITH HARDWARE LOG STILL ON STACK
 
	.DSABL	LSB


	.SBTTL	SBI ERROR INTERRUPTS
;++
; Handle SBI Faults and Asynchronous Write Timeouts on the SBI.
;
; SBI Fault:
;	Log the error; try to resume normal execution.
;
; Asynchronous Write Timeouts:
;	Log the error.
;	Set up a "fake" machine check log on the stack.  This is so we
;	can share the exception exit path (REFLECTCHK) that machine checks
;	take if the current process is executing in USER or SUPER mode.
;	If the current process is in EXEC or KERNEL mode, bugcheck.
;--
	.ALIGN	LONG			;THIS IS VECTORED TO
GBLDEF	INT5C				;SBI FAULT VECTOR
GBLDEF	LOGSBF
	SETIPL	#^X1F			;DISABLE ALL INTERRUPTS
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,R7>	;SAVE SOME WORK REGS
	MOVZBL	#EMB$K_BE,R3		;ERROR LOG TYPE
	MOVL	#MCHK$M_MCK!MCHK$M_LOG,R2 ;MASK FOR PRTCTEST
	BSBB	LOGSBI			;USE SAME CODE AS ASYNC WRITE FAILURE
	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,R7>	;RESTORE R0-R7
	REI				;TRY TO CONTINUE

	.ALIGN	LONG			;THIS IS VECTORED TO
GBLDEF	INT60				;ASYNCHRONOUS WRITE TIMEOUT
GBLDEF	LOGAWE
	SETIPL	#^X1F			;DISABLE ALL INTERRUPTS
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,R7>	;SAVE SOME WORK REGS
	MOVZBL	#EMB$K_AW,R3		;ERROR LOG TYPE
	MOVL	#MCHK$M_LOG!MCHK$M_MCK!MCHK$M_NEXM,R2 ;PRTCTEST MASK
	BSBB	LOGSBI			;USE SAME CODE AS SBI FAULT ERROR
	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,R7>	;RESTORE R0-R7
	SUBL	#40,SP			;ALLOCATE FAKE MACHINE CHECK FRAME
	PUSHL	#40			;SIZE OF FRAME
	PUSHL	#MCHK$M_MCK!MCHK$M_LOG!MCHK$M_NEXM
	PUSHAL	MCL_PC+4(SP)		;MASK AND PC,PSL FOR PRTCTEST
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,AP> ;SAVE REGISTERS FOR COMMON CODE
	ADDL3	#<9*4>,SP,AP		;POINT AP TO FAKE MACHINE CHECK FRAME
	BITB	#^B10100000,W^GL_CSBITA+3 ;WAS WRITE IN USER OR SUPERVISOR
					;MODE AND NOT UPDATING A PAGE TABLE
	BNEQ	10$			;IF NOT, MUST BUGCHECK
	BRW	REFLECTCHK		;BRANCH IF OK TO CONTINUE
10$: 
	POPR	#^M<R0,R1,R2,R3,R4,R5,AP>
	.IF	NDF,PRMSW		;*****FOR PRIMARY PROCESSOR...
	JSB	G^EXE$MCHK_BUGCHK	;RECOVERY BLOCK IN EFFECT?
	BUG_CHECK ASYNCWRTER,FATAL	;WRITE ERROR IN KERNAL OR EXEC MODE
					;OR WHILE UPDATING PAGE TABLE
	.IFF				;*****FOR SECONDARY PROCESSOR...
	SECBUG_CHECK	MPASYNCWRT,FATAL;WRITE ERROR IN KERNEL OR EXEC MODE
	.ENDC

;++
; LOGSBI -- Subroutine to log SBI errors.
;
; Implicit Inputs:
;	+-----------------------+
;	|   return address	| :(SP)
;	+-----------------------+
;	|	saved		|
;	|	R0 - R7		|
;	+-----------------------+
;	|   interrupt PC	|
;	+-----------------------+
;	|   interrupt PSL	|
;	+-----------------------+
;
; Create an SBI error log buffer that contains:
;	The contents of the configuration register of every SBI adapter on
;	the bus (16 longwords).
;	A copy of the SBI silo (16 longwords).
;	SBI processor registers SBITA, SBIER, SBIMT, SBISC, and SBIFS.
;--
LOGSBI:	JSB	G^EXE$MCHK_TEST		;ARE WE TO LOG THIS ERROR?
	BLBS	R0,5$			;NO, RECOVERY BLOCK IGNORES IT
	INCL	G^EXE$GL_MCHKERRS	;KEEP COUNT OF MACHINE CHECKS
5$:	MOVQ	<9*4>(SP),-(SP)		;MAKE A SECOND COPY OF PC,PSL
	MOVL	G^EXE$GL_CONFREG,R7	;ARRAY OF NEXUS DEVICE TYPE CODES
	MOVL	G^MMG$GL_SBICONF,R5	;ARRAY OF ADAPTER VA'S
	MOVL	#15,R0			;INDEX OF LAST POSSIBLE ITEM ON SBI
10$:	MOVL	(R5)[R0],R1		;GET VA OF CONTROLLER/ADAPTER
	CLRL	-(SP)			;ASSUME NO ADAPTOR HERE
	TSTB	(R7)[R0]		;TEST ADAPTER TYPE
	BEQL	20$			;IF EQL, NO ADAPTOR HERE
	MOVL	(R1),(SP)		;STORE ADAPTOR CSR0 ON STACK
20$:	SOBGEQ	R0,10$			;LOOP THRU ALL POSSIBLE 16
	MOVL	#15,R0			;SET UP COUNT OF NUMBER OF TIMES TO
					;READ SILO
30$:	MFPR	#PR$_SBIS,-(SP)		;SAVE INFORMATION FOR ERROR LOGGER
	SOBGEQ	R0,30$			;LOOP THRU ALL 16
	MFPR	#PR$_SBITA,-(SP)	;SAVE SBI TIMEOUT REGISTER
	MCOML	(SP),W^GL_CSBITA	;SAVE COMPLEMENT SBITA FOR LATER CHECK
	MFPR	#PR$_SBIER,-(SP)	;SAVE SBI ERROR REGISTER
	MFPR	#PR$_SBIMT,-(SP)	;SAVE SBI MAINTENANCE REGISTER
	MFPR	#PR$_SBISC,-(SP)	;SAVE SBI SILO COMPARATOR
	MFPR	#PR$_SBIFS,-(SP)	;SAVE SBI FAULT/STATUS REGISTER
	MOVZWL	#<16*4>+<16*4>+<7*4>,-(SP) ;SAVE NUMBER OF BYTES OF ENTRY
 
	MOVAL	<<16*4>+<16*4>+<6*4>>(SP),R1 ;ADDRESS OF PC,PSL FOR PRTCTEST
	MOVL	(SP),R4			;# OF BYTES TO LOG
	MOVAB	4(SP),R5		;ADDRESS OF LOG ENTRY
	BSBW	LOGIT			;CALL ERROR LOGGER
	ADDL	(SP)+,SP		;CLEAN STACK OF LOG AND FAKE PC,PSL
	RSB				;RETURN


	.SBTTL	MEMORY TIMER SCAN

	.IF	NDF,PRMSW		; *****For primary processor...
ECC$REENABLE::				; Define timer scan entry point.
	.IFF				; *****For secondary processor...
MPS$REENABLE::				; Define timer scan entry point.
	.ENDC

	DECW	W^GW_WATCH		; Count seconds down.
	BGTR	REENABLE_INTS		; Br if time hasn't elapsed yet.
;
; Scan all memory controllers for unreported errors.  This will yield a
; representative sample of memory errors in the error log, even if CRD
; interrupts are disabled.
;
	MOVW	#SOMETIME,W^GW_WATCH	; Reset time interval.
	PUSHR	#^M<R1,R3>		; Save working registers.
	MOVPSL	-(SP)			; Set up interrupt PSL.
	BSBB	10$			; Fake interrupt PC on stack.
10$:	MOVAL	(SP),R1			; Point to exception PC,PSL.
	MOVL	#EMB$K_SE,R3		; Log soft memory errors.
	BSBW	LOG_ERROR_MEM		; Scan all memory controllers, and
					; log any that report errors.
	ADDL	#8,SP			; Pop PC,PSL pair from stack.
	POPR	#^M<R1,R3>		; Restore registers.

REENABLE_INTS:
	DECW	W^GW_REENAB		; Count seconds down.
	BGTR	10$			; Branch if reenable time not elapsed.
	MOVW	#REENABTIME,W^GW_REENAB ; Reset the time interval.
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save working registers.
	MOVC5	#0,#0,#0,#16,W^AB_MEMERR; Reset 16 bytes of error count to 0.
	BBC	S^#EXE$V_CRDENABL, -	; Branch if SYSGEN parameter specifies
		G^EXE$GL_FLAGS,5$	; no CRD interrupts.
	MOVL	G^MMG$GL_SBICONF,R5	; Get addr of SBICONF for action routines.
	MOVAL	W^ENAB_ROUTINES,R3	; Array of action routine vectors.
	BSBW	LOCATE_MEM		; Locate mem and call action routines
					; to re-enable CRD interrupts.
5$:	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore registers.
10$:	RSB

	.SBTTL	Memory Error Interrupts
;
; SBI Alert interrupts are vectored here.
;
	.ALIGN	LONG
GBLDEF	INT58				; EXE$INT58:: or MPS$INT58::
GBLDEF	LOGSBA				; EXE$LOGSBA:: or MPS$LOGSBA::

	PUSHR	#^M<R1,R3>		; Save some registers.
	SETIPL	#^X1F			; Disable all interrupts.
	MOVAL	8(SP),R1		; Set pointer to interrupt PC,PSL.
	MOVL	#EMB$K_SA,R3		; Set SBI Alert error log type.
	BSBW	LOG_ERROR_MEM		; Log memory controller registers.
	POPR	#^M<R1,R3>		; Restore registers.
	REI

;
; CRD (Soft, or Corrected) memory error interrupts are vectored here.
;
	.ALIGN	LONG
GBLDEF	INT54				; EXE$INT54:: or MPS$INT54::
GBLDEF	LOGCRD				; EXE$LOGCRD:: or MPS$LOGCRD::

	PUSHR	#^M<R1,R3>		; Save some registers.
	SETIPL	#^X1F			; Disable all interrupts.
	INCL	W^GL_CRDCNT		; Keep count of these errors.
	MOVAL	8(SP),R1		; Set pointer to interrupt PC,PSL.
	MOVL	#EMB$K_SE,R3		; Set soft memory error type.
	BSBW	LOG_ERROR_MEM		; Log memory controller registers.
	POPR	#^M<R1,R3>
	REI

	.SBTTL	LOGMEM Master Routine
;++
;
; FUNCTIONAL DESCRIPTION:
;	This routine is called to build an errorlog containing the device
;	registers of the memory controllers on an 11/780 system.  If called
;	at the LOG_ERROR_MEM entry point, it will scan the memory controller
;	status registers, and only log those controllers which report errors.
;	If called at the LOG_ALL_MEM entry point, it will unconditionally log
;	all memory controllers on the system.
;
; INPUTS:
;	R1	- pointer to exception PC,PSL
;	R3	- Error log type code (e.g. EMB$K_type)
;	
; OUTPUTS:
;	Format of error log:
;		# of memory controllers logged
;		memory type-specific log #1
;		memory type-specific log #2
;			.
;			.
;		PC of instruction at fault time
;		PSL at fault time
;
;	All registers are preserved.
;
;--

LOG_ERROR_MEM:				; Log controllers with errors.
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,AP>
	MOVAL	W^LOGERR_ROUTINES,R3	; Array of action routine vectors.
	BRB	LOGMEM			; Join common code.

LOG_ALL_MEM:				; Unconditionally log all controllers.
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,AP>
	MOVAL	W^LOGALL_ROUTINES,R3	; Array of action routine vectors.

LOGMEM:					; Log memory controller registers.
	CLRQ	R5			; Zero error log byte count and number
					; of controllers logged.
	MOVL	G^MMG$GL_SBICONF,R7	; For use by action routines.
	MOVL	#SS$_NORMAL,AP		; Assume no fatal memory errors.
;
; Locate all memory controllers on the SBI.  When a memory controller is
; found, call the appropriate action routine to create that controller's
; portion of the common error log buffer on the stack.
;
	BSBW	LOCATE_MEM
;
; The error log buffer has been built on the stack; SP points to the beginning.
; Add the number of memory controllers logged, then log the errors.
; Current register usage:
;	R5	- Number of bytes in the error log.
;	R6	- Number of memory controllers logged.
;	SP	- Points to the beginning of the error log buffer.
;	AP	- LBS if no fatal memory errors were discovered, else LBC.
;
	MOVAB	(SP)[R5],R1		; Get address of saved R0 on stack.
	MOVL	12(R1),R3		; Restore input value of R3.
	MOVL	4(R1),R1		; Restore input value of R1.
	PUSHL	R6			; Add # of controllers to log buffer.
	ADDL3	#<1*4>,R5,-(SP)		; Total # bytes in error log buffer.
	TSTL	R5			; Were any memory registers logged?
	BEQL	10$			; No.  Skip call to error logger.
	INCL	G^EXE$GL_MEMERRS	; Keep count of memory errors
	MOVL	(SP),R4			; Use # bytes as input to LOGIT.
	MOVAL	4(SP),R5		; Address of error log buffer.
	CLRL	R2			; Always log memory errors.
	BSBW	LOGIT			; Log the error.
10$:	ADDL	(SP)+,SP		; Remove error log buffer from stack.
	BLBS	AP,20$			; Br if fatal error not signalled.
	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,AP>
	BUG_CHECK ASYNCWRTER,FATAL	; Unrecoverable memory controller error.
20$:
	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,AP>
	RSB

	.SBTTL	LOCATE_MEM Dispatching Routine
;++
;	Routine to locate memory controllers on 11/780 SBI.
;
; FUNCTIONAL DESCRIPTION:
;	This routine scans an array of adapter type codes that tell which
;	adapters are attached to the SBI.  When it finds a memory controller
;	adapter, it dispatches to an action routine for that memory controller
;	type.
;
; INPUTS:
;	R3 - address of action routine table; 1 action routine/memory controller
;	Current format of action routine tables (the tables are created by the
;	MEMORY_ROUTINES macro):
;		 (R3):	self-relative offset to MS780C action routine
;		4(R3):	self-relative offset to MA780 action routine
;		8(R3):	self-relative offset to MS780E action routine
;
; On entry to memory action routine:
;	R0,R1	- local registers, not preserved across calls to action routines
;	R2	- TR# of this memory controller
;	R3	- not available to be used by action routines
;	R4	- address of CONFREG array
;	R5-AP	- available; contents are preserved across calls to multiple
;		  action routines (i.e. can be used for global storage)
;
;	Note: an action routine may deposit a -1 in R2 to cause LOCATE_MEM
;	to prematurely exit the memory scan loop (and not call any other
;	memory action routines).
;
; OUTPUTS:
;	R0-R4 destroyed.  (Other registers may be destroyed by action routines.)
;--

LOCATE_MEM:
	MOVL	G^EXE$GL_CONFREG,R4	; Get address of CONFREG.
	SUBL3	#1,G^EXE$GL_NUMNEXUS,R2	; Get index into nexus arrays.
;
; Loop through all nexuses.  If a memory controller is found at any of the
; nexus slots, then call the action routine associated with that memory.
;
10$:	MOVZBL	(R4)[R2],R1		; Get nexus device type from CONFREG.
	BEQL	20$			; Not a memory; go to next nexus.
	LOCC	R1,#MEMTYPCNT,W^MEMTYP	; Find type in memory type array.
					; R1 <- addr of type code (if found).
	BEQL	20$			; Not a memory; go to next nexus.
	MOVZBL	MEMTYPCNT(R1),R1	; Use offset to get general memory type.
	MOVAL	(R3)[R1],R1		; Get self-relative address of action
	JSB	@(R1)[R1]		; routine, and call it.
20$:	SOBGEQ	R2,10$			; Loop through all nexuses.
	RSB				; Return.

	.SBTTL	ENAB Action Routines
;++
;
; FUNCTIONAL DESCRIPTION:
;	These action routines re-enable CRD interrupts for each 11/780 memory
;	controller.  Memory types currently supported:
;
;		MS780C (local memory - 4k and 16k chips)
;		MS780E (local memory - 64k chips)
;		MA780  (multiport memory)
;
; INPUTS:
;	R2	- TR# of this memory
;	R4	- address of EXE$GL_CONFREG array
;	R5	- address of MMG$GL_SBICONF array
;
; OUTPUTS:
;	R0,R1 destroyed; all other registers preserved.
;
;--
ENAB_MS780C:
	MOVL	(R5)[R2],R1		; Get address of controller registers.
	BISL	#<MRC$M_ELSRF!MRC$M_HERIMF>,8(R1)	; Enable interrupts
					; and clear error flags.
	RSB				; That's it.

ENAB_MS780E:
	MOVL	(R5)[R2],R1		; Get address of controller registers.
	BISL	#<MRC$M_ELSRF!MRC$M_HERIMF>,8(R1)	; Enable interrupts
					; and clear error flags in 1st contr.
	BISL	#<MRC$M_ELSRF!MRC$M_HERIMF>,12(R1)	; Enable interrupts
					; and clear error flags in 2nd contr.
	RSB				; That's it.

ENAB_MA780:
	MOVL	(R5)[R2],R1		; Get address of controller registers.
	$PRTCTINI	B^10$, -	; Protect against non-existent memory
		#<MCHK$M_LOG!MCHK$M_NEXM>	; machine checks.
	BISL	#<MRC$M_ELSRF!MRC$M_HERIMF>,16(R1)	; Enable interrupts
					; and clear error flags.
	$PRTCTEND	10$		; End of protected code.
	RSB				; That's it.

	.SBTTL	LOGMEM Action Routines
;++
;  FUNCTIONAL DESCRIPTION:
;	One action routine per memory controller type follows.  These
;	routines create an 11/780 memory error log entry.  Currently, the
;	following memory controllers are supported:
;
;		MS780C (local memory - 4K and 16K chips)
;		MS780E (local memory - 64K chips)
;		MA780  (multiport memory)
;
;	Each action routine contributes to the common error log buffer being
;	built on the stack.  Because different routines are being used to build
;	a common error log buffer on the stack, the contents of the stack is
;	significant at all times.
;
; INPUTS:
;	R2 - nexus index for this memory (TR #)
;	R3 - not available for use by action routines
;	R4 - address of SBI configuration array (CONFREG)
;	R5 - current errorlog byte count
;	R6 - current number of controllers logged
;	R7 - address of array of SBI virtual addresses (SBICONF)
;	R8-R11 - scratch
;	AP - memory controller status: LBC = fatal controller error discovered
;
; IMPLICIT INPUTS:
;		+---------------------------------------+
;	(SP):	|	caller's return address		|
;		+---------------------------------------+
;		|	return to caller's caller	|
;		+---------------------------------------+
;		|	  previous error log		|
;		|		.			|
;		|		.			|
;
; OUTPUTS:
;	R2-R4 preserved
;	R5 and R6 updated
;
; IMPLICIT OUTPUTS:
;		+---------------------------------------+
;	(SP):	|	return to caller's caller	|
;		+---------------------------------------+
;		|  error log entry for this controller	|
;		|  (null if no error for this memory)	|
;		+---------------------------------------+
;		|	previous error log		|
;		|		.			|
;		|		.			|
;
;--

	.SBTTL	LOG_MS780C
;++
;	LOG_MS780C - Build error log for MS780C memory controller
;
;	The portion of the error log built for the MS780C memory controller
;	has the following format:
;		+-------------------------------+
;		|	adapter TR#		|
;		+-------------------------------+
;		|	memory register A	|
;		+-------------------------------+
;		|	memory register B	|
;		+-------------------------------+
;		|	memory register C	|
;		+-------------------------------+
;	Register A contains the type code in the low-order byte.  For MS780C
;	memories, this type code is in the range of 8 - 11 (hex).
;--

LOG_MS780C:
;
; Determine whether to log this controller.
;
	MOVL	(R7)[R2],R8		; Get VA of controller registers.
	MOVL	8(R8),R10		; Read memory controller register C.
	BBS	#MRC$V_ELSRF,R10,LOGC	; Branch if error log requested.
	RSB				; Else return.
;
; Build error log on stack.
; This is the entry point used when unconditionally logging all memories.
;
LOGC:
	POPR	#^M<R0,R1>		; Get return addr in R0, caller's
					; return in R1.
	DSBINT	DST=R9			; Raise IPL while reading registers.
	PUSHL	R10			; Save memory register C in log.
	PUSHL	4(R8)			; Save memory register B in log.
	PUSHL	(R8)			; Save memory register A in log.
	ENBINT	SRC=R9			; Drop back to previous IPL.
	PUSHL	R2			; Save TR# in log.
;
; Check for CRD error.  If the number of recent CRD errors > CRDINTMAX, then
; disable CRD interrupts.  If the number of recent CRD errors > CRDWATCHMAX,
; then stop logging CRD errors.
;
	BBC	#MRC$V_ELSRF,R10,20$	; Branch if no error log requested.
	INCB	W^AB_MEMERR[R2]		; Count memory errors for this contr.
	CMPB	W^AB_MEMERR[R2],#CRDINTMAX	; Too many CRD interrupts?
	BLEQ	10$			; No, skip CRD interrupt disable.
	BBSS	#MRC$V_INHBCRD,R10,10$	; Set bit to inhibit CRD interrupts.
10$:
	CMPB	W^AB_MEMERR[R2],#CRDWATCHMAX	; Too many CRD error logs?
	BLEQ	20$			; No, go log this one.
	ADDL2	#<4*4>,SP		; Pop memory CSRs from stack.
	BRB	30$			; Skip logging CRD for this controller.
20$:
	ADDL2	#<4*4>,R5		; Add # of bytes in this log to total.
	INCL	R6			; Count number of controllers logged.
30$:
	MOVL	R10,8(R8)		; Clear errors from register C.
	PUSHL	R1			; Restore caller's caller to stack.
	JMP	(R0)			; Return to caller.

	.SBTTL	LOG_MS780E
;++
;	LOG_MS780E - Build error log for MS780E memory controller
;
;	The portion of the error log built for the MS780E memory controller
;	has the following format:
;		+-------------------------------+
;		|	adapter TR#		|
;		+-------------------------------+
;		|	memory register A	|
;		+-------------------------------+
;		|	memory register B	|
;		+-------------------------------+
;		|	memory register C	|
;		+-------------------------------+
;		|	memory register D	|
;		+-------------------------------+
;
;	Register A contains the type code in the low-order byte.  For MS780E
;	memories, this type code is in the range of 68 - 6C (hex).
;
;--

LOG_MS780E:
;
; Determine whether to log any errors for this controller.
;
	MOVL	(R7)[R2],R8		; Get VA of controller registers.
	BITL	#^X00100000,(R8)	; Test error summary bit in Register A.
	BNEQ	LOGE			; Branch if there are any errors.
	RSB				; Else return.

;
; This is the entry point used when unconditionally logging all memories.
;
LOGE:
	POPR	#^M<R0,R1>		; Get return address in R0, caller's
					; return in R1.
	MOVL	#3,R9			; Initialize loop counter.
	DSBINT	DST=R10			; Raise IPL while reading registers.
10$:	PUSHL	(R8)[R9]		; Push registers in reverse order.
	SOBGEQ	R9,10$			; Push 4 registers for error log.
	PUSHL	R2			; Save TR# in error log.
	ENBINT	SRC=R10			; Drop back to previous IPL.
;
; The MS780E memory subsystem consists of 1 SBI Interface module and 2 Memory
; Controller modules.  Each controller can control up to 8 memory array cards.
; The MS780E subsystem can operate in any one of 3 interleave modes: when both
; Control Cards are present, the subsystem will usually operate in internally
; interleaved mode; if only one Control Card is present, the sub-system may
; operate in non-interleaved mode, or may be externally interleaved with
; another memory subsystem on a different SBI slot.
;
; MS780E controller registers A and B reside on the SBI Interface module and
; are always accessible and valid when the subsystem is present.  Register C
; gives information about the lower controller and array cards while Register
; D gives information about the upper set.  If either controller is not
; present, its status register (C or D) will be accessible but the contents
; are UNDEFINED.
;
	MOVL	4(SP),(R8)		; Clear error bits set in Register A.
	MOVL	8(SP),4(R8)		; Clear error bits set in Register B.
;
; Check Register A for interleave mode.
;
	CLRQ	R9			; Will hold copies of Register C and D.
	BBS	#2,4(SP),LOWER		; If internally interleaved, check both
					; upper and lower controllers.
	BBS	#1,4(SP),UPPER		; Branch if upper controller is enabled.
;
; Check lower controller for fatal parity errors.
;
LOWER:
	MOVL	12(SP),R9		; Get copy of Register C from stack.
	BBS	#MRC$V_MSEQPTY,R9,-	; Branch if microsequencer parity
		FATAL_MEM		; error.
	BBS	#MRC$V_IFPTY,R9,-	; Branch if SBI Interface write data
		FATAL_MEM		; parity error.
	BBC	#2,4(SP),CHK_CRD_LOW	; Branch if not internally interleaved.
;
; Check upper controller for fatal parity errors.
;
UPPER:
	MOVL	16(SP),R10		; Get copy of Register D from stack.
	BBS	#MRC$V_MSEQPTY,R10,-	; Branch if microsequencer parity
		FATAL_MEM		; error.
	BBS	#MRC$V_IFPTY,R10,-	; Branch if SBI interface write data
		FATAL_MEM		; parity error.
;
; Determine if this error was a CRD in either controller.
;
	BBS	#9,R10,CRD_MS780E	; Branch if CRD error in upper contr.
CHK_CRD_LOW:
	BBC	#9,R9,LOG_E		; Branch if not a CRD error in lower.
;
; This was a CRD error.  If the number of recent CRD errors > CRDINTMAX, then
; disable CRD interrupts for this subsystem.  If the number of recent CRD
; errors > CRDWATCHMAX, then don't log another CRD error.
;
; NOTE: it is always safe to write to both register C and D even if one of the
; controllers is disabled.
;
CRD_MS780E:
	INCB	W^AB_MEMERR[R2]		; Count memory errors for this contr.
	CMPB	W^AB_MEMERR[R2],#CRDINTMAX	; Too many CRD interrupts?
	BLEQ	11$			; No, skip CRD interrupt disable.
	BBSS	#MRC$V_INHBCRD,R9,10$	; Set bit to inhibit CRD interrupts.
10$:	BBSS	#MRC$V_INHBCRD,R10,11$	; Set bit to inhibit in upper contr.
11$:
	CMPB	W^AB_MEMERR[R2],#CRDWATCHMAX	; Too many CRD error logs?
	BLEQ	LOG_E			; No, go ahead and log this one.
	ADDL2	#<5*4>,SP		; Pop memory CSRs from stack.
	BRB	CLEAR_ERRS_E		; Skip logging CRDs for this controller.
;
; Found a fatal controller error.  Report it, try to log the error and return.
;
FATAL_MEM:
	CLRL	AP			; Signal fatal memory error.
;
; Increment log counts.
;
LOG_E:
	ADDL2	#<5*4>,R5		; Add # of bytes in this log to total.
	INCL	R6			; Count number of controllers logged.
CLEAR_ERRS_E:
	MOVL	R9,8(R8)		; Clear errors from register C.
	MOVL	R10,12(R8)		; Clear errors from register D.
	PUSHL	R1			; Restore caller's caller to stack.
	JMP	(R0)			; Return to caller.

	.SBTTL	LOG_MA780
;++
;	LOG_MA780 - Build error log for MA780 memory controller
;
;	The portion of the error log built for the MA780 memory controller
;	has the following format:
;		+-------------------------------+
;		|	adapter TR#		|
;		+-------------------------------+
;		| Port Configuration Register	|
;		+-------------------------------+
;		| Port Interface Control Reg	|
;		+-------------------------------+
;		| Port Controller Status Reg	|
;		+-------------------------------+
;		| Port Invalidation Control Reg	|
;		+-------------------------------+
;		| Array Error Register		|
;		+-------------------------------+
;		| Configuration Status Reg 0	|
;		+-------------------------------+
;		| Configuration Status Reg 1	|
;		+-------------------------------+
;		| Maintenance Control Register	|
;		+-------------------------------+
;
;	The Port Configuration Register contains the type code in the
;	low-order byte.  For MS780E memories, this type code is in the
;	range of 40 - 43 (hex).
;
;--

LOG_MA780:
;
; Determine whether to log any errors for this controller.
;

	MOVL	(R7)[R2],R8		; Get VA of controller register.
	CLRL	R10			; Use R10 as memory error flag; assume
					; there is an error condition.
	$PRTCTINI	B^10$, -	; Protect following code from
		#<MCHK$M_LOG!MCHK$M_MCK>; all machine checks.
	BITL	#^X00400000,(R8)	; Check for power-up interrupt.
	BNEQ	5$			; Branch if found.
	BITL	#^XFF000000,4(R8)	; Check Port Interface Control Reg.
	BNEQ	5$			; Branch if found error.
	BITL	#MRC$M_ELSRF,16(R8)	; Check Array Error register.
	BNEQ	5$			; Branch if found error.
	BITL	#^X00000400,20(R8)	; Check Multiple Interlock Accepted err.
	BNEQ	5$			; Branch if found error.
	BITL	#^XD000C000,8(R8)	; Lastly, check Port Contr. Status Reg.
	BNEQ	5$			; Branch if found error.
	MOVL	#1,R10			; Signal no errors found.
5$:	$PRTCTEND	10$		; End of protected code.
	BLBC	R0,20$			; If MA780 has disappeared, just return.
	BLBC	R10,LOGMA		; If any errors were found, log them.
20$:	RSB				; Else return.
;
; This is the entry point used when unconditionally logging all memories.
;
; Build error log on stack.  First set SP to where the top of the buffer
; will be, and use R9 as a temporary stack pointer while the log is being
; built.  This is so the machine check protection routines can freely use the
; stack above where the error log is being built.
;
LOGMA:
	POPR	#^M<R1,R11>		; Get return address in R1, caller's
					; return in R11.
	MOVL	SP,R9			; Use R9 as temporary stack pointer.
	SUBL	#<9*4>,SP		; Point SP to where stack top will be.
	$PRTCTINI	W^50$	-	; Protect following code from
		#<MCHK$M_LOG!MCHK$M_NEXM>	;non-existent memory errors.
	DSBINT	DST=R10			; Raise IPL while logging registers.
	MOVL	28(R8),-(R9)		; Maintenance Control Register
	MOVL	24(R8),-(R9)		; Configuration Status Register 1
	MOVL	20(R8),-(R9)		; Configuration Status Register 0
	MOVL	16(R8),-(R9)		; Array Error Register
	MOVL	12(R8),-(R9)		; Port Invalidation Control Register
	$PRTCTINI	B^10$,-		; Protect this register access against
		#<MCHK$M_LOG!MCHK$M_MCK>; all machine checks.
	MOVL	8(R8),-(R9)		; Read Port Controller Status Register.
	$PRTCTEND	10$		; End of protected code.
	BLBS	R0,15$			; Branch if no machine check occurred.
	MOVL	#0,-(R9)		; Else put fake copy of register in log.
15$:
	MOVL	4(R8),-(R9)		; Port Interface Control Register
	MOVL	(R8),-(R9)		; Port Configuration Register
	ENBINT	SRC=R10			; Restore IPL to previous level.
	MOVL	R2,-(R9)		; Save TR# in error log.
;
; Clear errors from registers.
;
	BISL	4(R9),(R8)		; Clear errs in Port Config Reg (pwr-up)
	BISL	8(R9),4(R8)		; Clear errors in Port Interface
					; Control Register.
	$PRTCTINI	B^20$,-		; Protect this register access against
		#<MCHK$M_LOG!MCHK$M_MCK>; all machine checks.
	BISL	12(R9),8(R8)		; Clear errors in Port Controller
					; Status register.
	$PRTCTEND	20$		; End of protected code.
	BISL	24(R9),20(R8)		; Clear errors in Port Configuration
					; Status Register (Mult Interlock Accpt)
	PUSHL	20(R9)			; Get copy of Array Error Register
					; on top of stack.
;
; Check for CRD error.  If the # of recent CRD errors > CRDINTMAX, then disable
; CRD interrupts for this controller.  If the # of recent CRD errors >
; CRDWATCHMAX, then don't log another CRD error for this controller.
;
	BBC	#MRC$V_ELSRF,(SP),40$	; Branch if this wasn't a data error.
	INCB	W^AB_MEMERR[R2]		; Count data errors for this contr.
	CMPB	W^AB_MEMERR[R2],#CRDINTMAX	; Too many CRD interrupts?
	BLEQ	30$			; No, skip CRD interrupt disable.
	BBSS	#MRC$V_INHBCRD,(SP),30$	; Set bit to inhibit CRD interrupts.
30$:
	MOVL	#1,R10			; Assume error will be logged.
	CMPB	W^AB_MEMERR[R2],#CRDWATCHMAX	; Too many CRD error logs?
	BLEQ	40$			; No, go ahead and log this one.
	CLRL	R10			; Signal "don't log this error".
40$:
	MOVL	(SP)+,16(R8)		; Clear errors from Array Error Reg.

	$PRTCTEND	50$		; End of protected code.
;
; Note: If no machine check occurred, R9 and SP are now identical.  We can
; resume using SP.
;
	BLBC	R0,NOLOG_MA		; MA780 disappeared, nothing to log.
	BLBS	R10,LOG_MA		; Branch to log the error.
NOLOG_MA:
	ADDL	#<9*4>,SP		; Clean error log off the stack.
	BRB	EXIT_MA			; And return.
LOG_MA:
	ADDL	#<9*4>,R5		; Add # of bytes in this log to total.
	INCL	R6			; Increment count of memories logged.
EXIT_MA:
	PUSHL	R11			; Restore caller's caller to stack.
	JMP	(R1)			; Return to caller.

	.SBTTL	TABLE OF RESUMABLE INSTRUCTIONS.
;	EACH BIT IN THE TABLE IS A 1 IF THE INSTRUCTION IS RESUMABLE,
;	AND A 0 IF IT IS NOT.

RESUMABLE:
	.WORD	^B0011110000111011	;REI, LDPCTX, SVPCTX, INSQUE, REMQUE
					;CVTPS, CVTSP
	.WORD	^B1111111111111111
	.WORD	^B1111111100000000	;PACKED DECIMAL INSTRUCTIONS
	.WORD	^B1111111011111111	;EDITPC
	.WORD	^B1111111111111111
	.WORD	^B0000000000101111	;EMODF,CVTFD,INTERLOCKED INSTRUCTIONS
	.WORD	^B0000111100000000	;DOUBLE PRECISION FLOATING POINT
	.WORD	^B1100000101001010	;MORE DOUBLE PREC/QUAD, EMUL, EDIV
	.WORD	^B1111111111111111
	.WORD	^B1111111111111111
	.WORD	^B1111111111111111
	.WORD	^B1111001111111111	;PUSHR, POPR
	.WORD	^B1111111111111111
	.WORD	^B1111010011111111	;ADWC, SBWC, MFPR
	.WORD	^B1111111100111111	;BBSSI, BBCCI
	.WORD	^B0000000011111111	;ASHP, CVTLP, CALLG, CALLS, XFC, EXPANSION

	.end
