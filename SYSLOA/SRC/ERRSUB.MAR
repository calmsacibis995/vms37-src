	.IF	EQ,CPU_TYPE-PR$_SID_TYP780
	.TITLE	ERRSUB780 - ERROR SUBROUTINES FOR VAX 11/780
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP750
	.TITLE	ERRSUB750 - ERROR SUBROUTINES FOR VAX 11/750
	.ENDC

	.IF	EQ,CPU_TYPE-PR$_SID_TYP730
	.TITLE	ERRSUB730 - ERROR SUBROUTINES FOR VAX 11/730
	.ENDC

	.IDENT	'V03-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
;
; FACILITY:
;
;	EXECUTIVE,  LOADABLE SUBROUTINES USED BY POWERFAIL AND BUGCHECK.
;
; ABSTRACT:
;
; LOADABLE SUBROUTINES USED BY POWERFAIL AND BUGCHECK.
;
; AUTHOR:
;
;	N. KRONENBERG, JULY 2, 1979.
;
; MODIFIED BY:
;
;	V03-001	PHL0040		Peter H. Lipman		23-Mar-1982
;		EXE$DUMPCPUREG for the 750 was clearing one too many
;		long words.
;
;	V02-016	KTA0085		Kerbey T. Altmann	01-Mar-1982
;		Insert a "#" left out somewhere along the line.
;
;	V02-015	KTA0083		Kerbey T. Altmann	22-Feb-1982
;		Add routines EXE$SHUTDWNADP to shut down any adapters
;		that need it during a bugcheck, CI$INT and CI$INITIAL -
;		dummy routines for CI errors if no driver loaded
;
;	V02-014	KTA0074		Kerbey T. Altmann	04-Feb-1982
;		Once more in the breach for the UBA.
;
;	V02-013	KTA0070		Kerbey T. Altmann	28-Jan-1982
;		Refine KTA0055 due to some subtle undocumented
;		"features" in different UBA designs.
;
;	V02-012	KTA0055		Kerbey T. Altmann	29-Dec-1981
;		Add code to set UMR disable on 780 UBA.
;
;	V02-011	KTA0050		Kerbey T. Altmann	26-Nov-1981
;		Fixed EXE$ADPINIT for the CI. Add routine INIPROCREG
;		and UBA$INITIAL from INIT.
;
;	V02-010	JLV0069		Jake VanNoy		26-Aug-1981
;		Change 730/750 EXE$TEST_CSR to understand IDC CSR 
;		addresses and ignore the call.
;
;	V0209	TCM0004		Trudy C. Matthews	29-Jul-1981
;		Change all "7ZZ"s to "730"s.
;
;
;	V0208	TCM0003		Trudy C. Matthews	8-May-1981
;		Get boot adapter's nexus device type from RPB$B_BOOTNDT
;		instead of from RPB$B_CONFREG.
;
;	V0207	TCM0002		Trudy C Matthews	18-Sep-1980
;		Added comments to EXE$TEST_CSR.
;
;
;--


;
; MACRO LIBRARY CALLS:
;

	$ADPDEF				;DEFINE ADAPTER OFFSETS
	$BQODEF				;DEFINE BOOT QIO OFFSETS
	$BTDDEF				;DEFINE BOOT DEVICE TYPES
	$EMBCRDEF			;DEFINE ERROR MSG BUFFER OFFSETS
	$IDBDEF				;DEFINE INTERRUPT DISPACH OFFSETS
	$MBADEF				;DEFINE MASSBUS ADAPTER OFFSETS
	$NDTDEF				;DEFINE NEXUS DEVICE TYPES
	$PRDEF				;DEFINE INTERNAL PROCESSOR REGISTERS
	$RPBDEF				;DEFINE RESTART PARAM BLOCK OFFSETS
	$SSDEF				;DEFINE SYSTEM STATUS CODES
	$UBADEF				;DEFINE UNIBUS ADAPTER OFFSETS

;
; EQUATED SYMBOLS:
;

;+
; $PAREGDEF -- Define offsets to CI registers and fields in the registers.
;-

	$DEFINI	PAREG

	$DEF	PA_CNF	.BLKL	1		; Configuration register

	_VIELD	PA_CNF,0,<-			; Define config register fields:
	<ADPTYP,8,M>,-				;  Adapter type code
	<PFD,,M>,-				;  Powerfail disable
	<TDEAD,,M>,-				;  Transmit dead
	<TFAIL,,M>,-				;  Transmit fail
	<,5>,-					;  5 unused bits
	<CRD,,M>,-				;  CRD on port init'd read
	<RDS,,M>,-				;  RDS on port init'd read
	<CXTER,,M>,-				;  SBI error confirm
	<RDTO,,M>,-				;  Port init'd read timeout on SBI
	<CSTMO,,M>,-				;  Port init'd command xmit timeout
	<,1>,-					;  1 unused bit
	<PUP,,M>,-				;  Adapter power up
	<PDN,,M>,-				;  Adaptor power down
	>					;

	$DEF	PA_PMC	.BLKL	1		; Port maint control/status register

	_VIELD	PA_PMC,0,<-			; Define register fields:
	<MIN,,M>,-				;  Maint initialized
	<MTD,,M>,-				;  Maint timer disable
	<MIE,,M>,-				;  Maint interrupt enable
	<MIF,,M>,-				;  Maint intterupt flag 
	>					;

	$DEFEND PAREG

	.SBTTL	EXE$INIBOOTADP - INITIALIZE THE BOOT DEVICE ADAPTER
;+
; EXE$INIBOOTADP - GET THE SYSTEM BOOT DEVICE ADAPTER AND INIT IT.
;	THIS ROUTINE IS CALLED FROM BUGCHECK BEFORE THE BOOTDRIVER IS CALLED.
;
; INPUTS:
;
;	R6 = RPB ADDRESS
;
; OUTPUTS:
;
;	R0-R2 DESTROYED
;	OTHER REGISTERS PRESERVED
;-

	.PSECT	WIONONPAGED,LONG
	.ENABL	LSB

EXE$INIBOOTADP::			;SUBROUTINE ENTRY
	CMPB	RPB$B_DEVTYP(R6),-	;IS BOOT DEVICE THE CONSOLE
		#BTD$K_CONSOLE		;BLOCK STORAGE DEVICE?
	BEQL	20$			;YES, RETURN
	MOVL	RPB$L_ADPVIR(R6),R0	;GET ADDR OF ADAPTER REG SPACE
	BICB3	#3,RPB$B_BOOTNDT(R6),R2	;GET GENERIC ADAPTER TYPE
	CMPB	R2,#NDT$_CI		;CI ADAPTER?
	BEQL	20$			;YES, RETURN
	CMPB	R2,#NDT$_MB		;MASS BUS ADAPTER?
	BNEQ	INI_UBADP		;BRANCH IF NOT
INI_MBADP:				;INIT MBA
	MOVL	#MBA$M_CR_ABORT,-	;ABORT ACTIVE TRANSFER
		MBA$L_CR(R0)		;
	MFPR	#PR$_TODR,R1		;GET CURRENT TIME (10 MS UNITS)
	MOVAB	100(R1),R1		;ALLOW ONE SECOND
10$:	TSTL	MBA$L_SR(R0)		;WAIT UNTIL TRANSFER
	BGEQ	15$			; IS COMPLETE
	MFPR	#PR$_TODR,R2		;GET CURRENT TIME
	CMPL	R1,R2			;CHECK FOR INTERVAL EXPIRED
	BGTRU	10$			;NOT YET, WAIT SOME MORE
15$:	MOVL	#MBA$M_CR_INIT,-	;NOW INIT MBA
		MBA$L_CR(R0)		;
20$:	RSB				;DONE

	.DSABL	LSB
INI_UBADP:				;INIT UBA


	.IF	EQ,CPU_TYPE-PR$_SID_TYP780
	MOVL	#UBA$M_CR_INIT,-
		UBA$L_CR(R0) 		;INIT UBA
20$:	BITL	#UBA$M_CSR_UBIC,-
		UBA$L_CSR(R0) 		;WAIT FOR UBA INIT
	BEQL	20$			; TO COMPLETE
	.ENDC

;
; THIS CODE IS EXECUTED FOR THE 11/750 AND THE 11/730.
; THE LOGICAL OR IS ACCOMPLISHED BY EXCLUDING ALL OTHER CPU TYPES.
;

	.IF	NE,CPU_TYPE-PR$_SID_TYP780
	MTPR	#0,#PR$_UBRESET		;INIT UBI AND UNIBUS
	.ENDC

;
; CHECK THE VMB VERSION NUMBER.  IF IT EXISTS AND IF IT IS 7 OR GREATER, THEN
; SEE IF ANY UNIBUS MAP REGISTERS TO DISABLE.
;

	MOVL	RPB$L_IOVEC(R6),R2	;PICK UP THE IOVECTOR FROM RPB
	MCOMW	BQO$W_VERSION(R2),R1	;GET VMB VERSION NUMBER 1'S COMPLEMENTED
	CMPW	R1,BQO$W_VERSION+2(R2)	;CHECK AGAINST CHECK WORD IN VMB
	BNEQ	40$			;IF NOT, ASSUME NO VERSION NUMBER
	CMPW	BQO$W_VERSION(R2),#7	;VERSION 7 OR GREATER OF VMB?
	BLSSU	40$			;NO, DON'T BOTH WITH UMR'S
	MOVL	BQO$L_UMR_DIS(R2),R2	;GRAB THE NUMBER OF UMR'S TO DISABLE
	BEQL	40$			;NONE, LEAVE

	.IF	EQ,CPU_TYPE-PR$_SID_TYP780
	ASHL	#22,R2,UBA$L_CR(R0)	;SET THE UMR DISABLE BITS
	.ENDC


;
; THIS CODE IS EXECUTED FOR ALL PROCESSORS.  ITS DISABLES ANY UNIBUS MAP
; REGISTERS ASSOCIATED WITH UNIBUS MEMORY TO PREVENT CONTENTION BETWEEN
; SBI AND UNIBUS ADDRESSES.
;

	MOVAL	UBA$L_MAP(R0),R1	;ADDRESS OF FIRST REGISTER
30$:	CLRL	(R1)+			;DISABLE IT
	SOBGTR	R2,30$			;LOOP UNTIL ALL DONE
40$:	RSB				;DONE WITH UBA INIT

	.SBTTL	EXE$SHUTDWNADP - SHUTDOWN ANY ADAPTERS DURING BUGCHECK
;+
; EXE$SHUTDWNADP - SHUTDOWN ANY ADAPTERS DURING BUGCHECK
;	THIS ROUTINE IS CALLED FROM BUGCHECK BEFORE THE DUMP IS TAKEN TO
;	ENSURE THAT ALL ADAPTERS THAT NEED TO BE QUIESENT ARE.
;
; INPUTS:
;
;	IPL = 31
;
; OUTPUTS:
;
;	OTHER REGISTERS PRESERVED
;-
	.ENABLE LSB

EXE$SHUTDWNADP::
	PUSHR	#^M<R0,R1,R2,R4>	; Save a register
	MOVAL	@#<IOC$GL_ADPLIST- -
		   ADP$L_LINK>,R2	; Get pointer to head of adapter list
10$:	MOVL	ADP$L_LINK(R2),R2	; Flink onward
	BEQL	20$			; Branch if at end of list
	MOVL	ADP$L_CSR(R2),R4	; Get address of CSR
	MOVZWL	ADP$W_ADPTYPE(R2),R0	; Get adapter type code
	MOVAL	ADPTABLE[R0],R0		; Get table entry of adap shutdown
	JSB	@(R0)[R0]		; Call adapter shutdown
	BRB	10$			; Next adapter

20$:	POPR	#^M<R0,R1,R2,R4>
30$:	RSB

;
; Table of addresses of adapter shutdown routines ordered
; by adapter type in ADP$W_ADPTYPE.
;

ADPTABLE:				; Address table start
	.LONG	30$-.			; 0-MBA
	.LONG	30$-.			; 1-UBA
	.LONG	30$-.			; 2-DR32
	.LONG	30$-.			; 3-MA780
	.LONG	CI$SHUTDOWN-.		; 4-CI
	.LONG	30$-.			; Rsvrd for future expansion

	.DISABLE LSB

	.SBTTL	CI$INT - CI INTERRUPT HANDLER
;+
; CI$INT - CI INTERRUPT HANDLER
;
;	THIS MODULE IS A DUMMY CI32 INTERRUPT HANDLER WHICH IS USED
;	UNTIL THE REAL CI DRIVER (PADRIVER) IS LOADED. IT ALSO CONTAINS
;	A DUMMY CI32 CONTROLLER INITIALIZATION	ENTRY POINT.
;
; INPUTS:
;
;	THE STACK ON ENTRY IS AS FOLLOWS:
;
;		0(SP)		ADDRESS OF IDB ADDRESS
;      4(SP) - 16(SP)		SAVED R2 - R5
;	       20(SP)		INTERRUPT PC
;	       24(SP)		INTERRUPT PSL
;
; OUTPUTS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	INTERRUPTS ARE DISABLED ON THE CI32
;
;-

CI$INT::
	MOVL	@(SP)+,R3			; GET ADDRESS OF IDB
	MOVL	IDB$L_CSR(R3),R4		; GET ADDRESS OF FIRST CSR
	MOVL	#PA_CNF_M_PUP,PA_CNF(R4)	; CLEAR POWER UP
	MOVL	#PA_CNF_M_PDN,PA_CNF(R4)	; CLEAR POWER DOWN
	MOVL	#PA_PMC_M_MIN,PA_PMC(R4)	; SET MAINTENCE INITIALIZE
	MOVQ	(SP)+,R2			; RESTORE REGISTERS
	MOVQ	(SP)+,R4
	REI


CI$INITIAL::					; CONTROLLER INITIALIZATION
CI$SHUTDOWN:					; CONTROLLER SHUTDOWN
	MOVL	#PA_PMC_M_MIN,PA_PMC(R4)	; SET MAINTENCE INITIALIZE
	RSB

	.SBTTL	EXE$DUMPCPUREG - DUMP CPU-SPECIFIC IPR'S
;+
; DUMP CPU-SPECIFIC IPR'S INTO ERROR MESSAGE BUFFER.
;
; TWENTY-ONE LONGWORDS ARE RESERVED IN THE EMB FOR CPU-SPECIFIC
; IPR'S.  THE FORMATS FOR VARIOUS CPU'S ARE:
;
; 11780:	11/750:		11/730:
;
; SBIFS		TBDR		21 UNUSED(0)
; SBISC		CADR
; SBIMT		MCESR
; SBIER		CAER
; SBIS		CMIERR
; 16 SBI SILO	16 UNUSED(0)
;
; INPUTS:
;
;	R0 - ADDR IN EMB OF START OF CPU-SPECIFIC REGISTERS=
;	     OFFSET EMB$L_CR_CPUREG
;
; OUTPUTS:
;
;	R0,R1 DESTROYED
;	ALL OTHER REGISTERS PRESERVED
;-

	.ENABL	LSB

EXE$DUMPCPUREG::			;SUBROUTINE ENTRY


	.IF	EQ,CPU_TYPE-PR$_SID_TYP780
	MFPR	#PR$_SBIFS,(R0)+	;LOG SBI FAULT REG,
	MFPR	#PR$_SBISC,(R0)+	; SBI COMPARATOR REG
	MFPR	#PR$_SBIMT,(R0)+	; SBI MAINT REG,
	MFPR	#PR$_SBIER,(R0)+	; SBI ERROR REG,
	MFPR	#PR$_SBIS,(R0)+		; SBI TIMEOUT REG.
	MOVL	#16,R1			;GET # SILO ENTRIES TO DUMP
10$:	MFPR	#PR$_SBIS,(R0)+		;DUMP SILO TO EMB
	SOBGTR	R1,10$			;
	.ENDC


	.IF	EQ,CPU_TYPE-PR$_SID_TYP750
	MFPR	#PR$_TBDR,(R0)+		;LOG TB DISABLE REG,
	MFPR	#PR$_CADR,(R0)+		; CACHE DISABLE REG,
	MFPR	#PR$_MCESR,(R0)+	; MCHECK ERROR SUMMARY REG
	MFPR	#PR$_CAER,(R0)+		; CACHE ERROR REG
	MFPR	#PR$_CMIERR,(R0)+	; CMI ERROR SUMMARY REGISTER
	MOVL	#<EMB$L_CR_CODE-<EMB$L_CR_CMIERR+4>>/4,R1 ;GET # LONGWDS OF
10$:	CLRL	(R0)+			; CPU-SPECIFIC REG LEFT IN EMB
	SOBGTR	R1,10$			; AND ZERO THEM
	.ENDC


	.IF	EQ,CPU_TYPE-PR$_SID_TYP730
	MOVL	#<EMB$L_CR_CODE - EMB$L_CR_CPUREG>/4, R1
					; THERE ARE NO CPU-SPECIFIC
10$:	CLRL	(R0)+			; REGISTERS TO LOG, SO ZERO THE
	SOBGTR	R1, 10$			; SPACE IN THE ERROR MSG BUFFER
	.ENDC


	RSB

	.DSABL	LSB


	.SBTTL	EXE$REGSAVE - SAVE CPU-SPECIFIC IPR'S
;+
; EXE$REGSAVE - CALLED BY POWERFAIL TO SAVE CPU-SPECIFIC IPR'S ON
;		THE STACK
;
; INPUTS: NONE
;
; OUTPUTS:
;
;		R0 DESTROYED
;		OTHER GENERAL REGISTERS PRESERVED
;		IPR'S SAVED ON THE STACK AS FOLLOWS:
;
;	11/780:		11/750:		11/730:
;
; 0(SP):SBIMT		TBDR		no registers
; 4(SP):		CADR		are saved
;
;-

	.ENABL	LSB

EXE$REGSAVE::				;SUBROUTINE ENTRY
	POPR	#^M<R0>			;CLEAR RETURN FROM STACK


	.IF	EQ,CPU_TYPE-PR$_SID_TYP780
	MFPR	#PR$_SBIMT,-(SP)	;SAVE SBI MAINT REG
	.ENDC


	.IF	EQ,CPU_TYPE-PR$_SID_TYP750
	MFPR	#PR$_CADR,-(SP)		;SAVE CACHE DISABLE REG,
	MFPR	#PR$_TBDR,-(SP)		; AND TB DISABLE REG
	.ENDC


	.IF	EQ,CPU_TYPE-PR$_SID_TYP730
	.ENDC				;NOTHING TO DO


	JMP	(R0)			;DONE, RETURN

	.DSABL	LSB

	.SBTTL	EXE$REGRESTOR - RESTORE CPU-SPECIFIC IPR'S
;+
; EXE$REGRESTOR - CALLED BY POWERFAIL RECOVERY TO RESTORE CPU-SPECIFIC
;		  IPR'S FROM THE STACK.
;
; INPUTS:
;
;		R6 - TOP OF STACK
;		STACK SET UP AS DEFINED IN OUTPUTS OF EXE$REGSAVE.
;
; OUTPUTS:
;
;		R0 DESTROYED
;		OTHER GENERAL REGISTERS PRESERVED
;		CPU-SPECIFIC IPR'S RESTORED FROM STACK
;		R6 - ADDRESS OF 1ST CPU-INDEPENDENT SAVED IPR
;
;-

	.ENABL	LSB

EXE$REGRESTOR::				;SUBROUTINE ENTRY
	POPR	#^M<R0>			;CLEAR RETURN FROM STACK


	.IF	EQ,CPU_TYPE-PR$_SID_TYP780
	MTPR	(R6)+,#PR$_SBIMT	;RESTORE SBI MAINT REGISTER
	.ENDC


	.IF	EQ,CPU_TYPE-PR$_SID_TYP750
	MTPR	(R6)+,#PR$_TBDR		;RESTORE TB DISABLE REG,
	MTPR	(R6)+,#PR$_CADR		; AND CACHE DISABLE REG
	.ENDC


	.IF	EQ,CPU_TYPE-PR$_SID_TYP730
	.ENDC				;NOTHING TO RESTORE


	JMP	(R0)			;DONE, RETURN

	.DSABL	LSB

	.SBTTL	EXE$INIPROCREG - CPU-DEPENDENT INITIALIZATION OF IPR'S
;+
; EXE$INIPROCREG - PERFORM INITIALIZATION OF INTERVAL TIMER AND 
;	CPU-DEPENDENT REGISTERS. CALLED FROM INIT AND POWERFAIL.
;
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	NONE
;-

EXE$INIPROCREG::			; INIT PROCESSOR REGISTERS
	BBS	S^#EXE$V_NOCLOCK,-
		@#EXE$GL_FLAGS,30$ 	; BRANCH IF NOT USING CLOCK

	.IF	EQ,CPU_TYPE-PR$_SID_TYP780
					; FOR 11/780, CONTINUE
					;
	BBC	S^#EXE$V_CRDENABL,-
		@#EXE$GL_FLAGS,10$  	; IF CLR, IGNORE CRD ERRORS
	MTPR	#<3@14>,S^#PR$_SBIER	; SET CRD INTERRUPT ENABLE
10$:	BBC	S^#EXE$V_SBIERR,-
		@#EXE$GL_FLAGS,20$    	; IF CLR, IGNORE SBI ERRORS
	MTPR	#<1@18>,S^#PR$_SBIFS	; SET SBI FAULT ENABLE

	.IFF				; FOR 11/730, 11/750

	BBC	S^#EXE$V_CRDENABL,-	; BRANCH IF FLAG CLEAR
		@#EXE$GL_FLAGS,20$	;  (IGNORE ERRORS)
	MOVL	@#MMG$GL_SBICONF,R0	; GET ADDR OF MEMORY CONTROLLER
	MOVL	(R0),R0			;  CONFIG REGISTER (1ST SLOT)
	BISL	#<1@28>,4(R0)		; SET CRD REPORT BIT
					;
	.ENDC				; *END OF CPU-DEPENDENT CODE*
					;
20$:	MTPR	#-<10*1000>,S^#PR$_NICR	; LOAD NEXT INTERVAL REGISTER
	MTPR	#^X800000D1,S^#PR$_ICCS	; CLEAR ERROR AND START CLOCK
30$:	RSB				; AND RETURN

	.SBTTL	UBA$INITIAL - CPU-DEPENDENT UNIBUS ADAPTER INITIALIZATION
;+
; UBA$INITIAL - UNIBUS ADAPTER INITIALIZATION
;
; THIS ROUTINE IS CALLED VIA A JSB INSTRUCTION AT SYSTEM STARTUP AND AFTER
; A POWER RECOVERY RESTART TO ALLOW INITIALIZATION OF UNIBUS ADAPTERS.
;	(POWERFAIL AND INITADP)
; 
; INPUTS:
;
;	R2 = ADDRESS OF ADAPTER CONTROL BLOCK
;	R4 = ADDRESS OF UNIBUS ADAPTER CONFIGURATION STATUS REGISTER.
;
;	ALL INTERRUPTS ARE LOCKED OUT.
;
; OUTPUTS:
;
;	THE UNIBUS ADAPTER IS INITIALIZED AND INTERRUPTS ARE ENABLED.
;-
 
UBA$INITIAL::				;UNIBUS ADAPTER INITIALIZATION


	.IF	EQ,CPU_TYPE-PR$_SID_TYP780
					;
	MCOML	#0,UBA$L_CSR(R4)	;CLEAR ALL ADAPTER CONFIGURATION ERRORS
	MCOML	#0,UBA$L_SR(R4)		;CLEAR ALL ADAPTER STATUS BITS
	MOVZWL	ADP$W_UMR_DIS(R2),R0	;PICK UP THE NUMBER OF UMR'S TO DISABLE
	ASHL	#UBA$V_CR_MRDSB-4,R0,R0	;DIVIDE BY 16 THEN SHIFT INTO POSITION
	BISL3	#UBA$M_CR_SUEFIE!-	;ENABLE INTERRUPTS
		 UBA$M_CR_BRIE!-
		 UBA$M_CR_CNFIE!-
		 UBA$M_CR_USEFIE!-
		 UBA$M_CR_IFSIE,-
		R0,UBA$L_CR(R4)
 
					; FOR 11/730 AND 11/750,
					;   NO SPECIAL INIT
	.ENDC

	RSB				;
;
; IGNORE UNEXPECTED UNIBUS INTERRUPTS
;
 
	.PSECT	$AEXENONPAGED,LONG

	.ALIGN	LONG

 
UBA$INT0::				; PASSIVE RELEASES THROUGH VECTOR 0
 
	INCL	@#IO$GL_UBA_INT0	; COUNT THEM
	BRB	UBA$UNEXINT		; JOIN COMMON CODE, VECTORS ARE ALLIGNED
 
	.ALIGN	LONG

UBA$UNEXINT::				; UNEXPECTED INTERRUPT CODE
					;
					;
	.IF	EQ,CPU_TYPE-PR$_SID_TYP780
					; FOR 11/780, RESTORE SAVED REGISTERS
	POPR	#^M<R0,R1,R2,R3,R4,R5>	;
	.ENDC
					; FOR 11/750, NO REGISTERS SAVED
	REI				; IGNORE INTERRUPT

	.SBTTL	EXE$TEST_CSR
;+
; EXE$TEST_CSR - TEST A UNIBUS CONTROLLER CSR FOR EXISTENCE
;
; THIS TEST IS CPU-DEPENDENT.  THE FOLLOWING CPU'S ARE SUPPORTED:
;
;	11/780	-TEST CSR AND CHECK RESULT IN THE UBA STATUS REGISTER.
;	11/750	-NON-EXISTENT CSR IS REPORTED VIA MACHINE CHECK AS A
;		 NON-EXISTENT MEMORY REGERENCE.  CONNECT A TEMPORARY
;		 MACHINE CHECK HANDLER, TEST THE CSR, AND RESTORE THE
;		 ORIGINAL MACHINE CHECK HANDLER.
;	11/730	-ACTION IS THE SAME AS FOR THE 11/750.
;
; THIS SUBROUTINE SHOULD BE CALLED VIA BRANCH OR JUMP TO SUBROUTINE AT IPL 31.
;
; INPUTS:
;
;	R0 = CSR ADDRESS
;	R6 = ADAPTER CONFIGURATION REGISTER ADDRESS
;
; OUTPUTS:
;
;	R0 LOW BIT SET/CLEAR FOR EXISTENT/NONEX CSR
;	OTHER REGISTERS PRESERVED.
;-

	.ENABL	LSB

EXE$TEST_CSR::				;SUBROUTINE ENTRY

	PUSHR	#^M<R1,R2>		;SAVE REGISTERS

	.IF	EQ,CPU_TYPE-PR$_SID_TYP780
;
; This next line of code is present so that this routine continues to function
; correctly when the UNIBUS adapter is powered down.  Moving 0 into the UBA
; Status Register has no effect when addressing the actual adapter register,
; and clears out any garbage bits in memory when UNIBUS space is re-mapped to
; the "black hole" page.
;
	MOVL	#0,UBA$L_SR(R6)		;WHEN UBA IS REMAPPED
	MOVL	G^EXE$GL_SCB,R1		;GET SCB ADDRESS
	PUSHL	4(R1)			;SAVE CURRENT MCHECK HANDLER ADDR
	MOVL	SP,R2			;MARK CURRENT STACK POSITION
	MOVAL	MCHK_780,4(R1)		;CONNECT TEMP MCHECK HANDLER
	TSTW	(R0)			;ATTEMPT TO READ CSR
	MOVL	UBA$L_SR(R6),UBA$L_SR(R6) ;CLEAR AND CHECK FOR ERROR
	BNEQ	NONEX_DEV		;BRANCH IF ERROR
OK:	MOVZBL	#SS$_NORMAL,R0		;SET STATUS TO SUCCESS
	BRB	TEST_DONE		;JOIN COMMON EXIT

;
; TEMPORARY CSR TEST MACHINE CHECK HANDLER FOR THE 11/780:
;

	.ALIGN	LONG
MCHK_780:
	MTPR	#0,S^#PR$_SBIFS		;CLEAR THE FAULT
	MOVL	4(SP),R0		;PICK UP SUMMARY PARAMETER
	MOVL	R2,SP
	CMPL	R0,#5			;IS IT READ DATA SUBSTITUTE?
	BEQL	OK			;YES, THEN IT IS READ W/BAD PARITY
	.ENDC


;
; THIS CODE IS EXECUTED FOR THE 11/750 AND THE 11/730.
; THE LOGICAL OR IS ACCOMPLISHED BY EXCLUDING ALL OTHER CPU TYPES.
;

	.IF	NE, CPU_TYPE-PR$_SID_TYP780

	MCK_BER	= ^X24			;OFFSET INTO 750 MACHINE CHECK FRAME
					; FOR BUS ERROR REGISTER
	NEX	= 3			; BIT POSITION FOR NON-EXISTENT MEMORY

;
; Test for non-UNIBUS I/O space addres first (IDC specific code)
;
	ADDL3	#512*4,R6,R1		;GET LOWEST LEGAL ADDRESS
	CMPL	R0,R1			;IS CSR GREATER ?
	BGTRU	10$			;IF YES, DO CHECK
	MOVZBL	#SS$_NORMAL,R0		;NO CHECK TO DO, EXIT
	BRB	TEST_DONE_2		;

10$:	MOVL	G^EXE$GL_SCB,R1		;GET SCB ADDRESS
	PUSHL	4(R1)			;SAVE CURRENT MCHECK HANDLER ADDR
	MOVL	SP,R2			;MARK CURRENT STACK POSITION
	MOVAL	MCHK_750,4(R1)		;CONNECT TEMP MCHECK HANDLER
	TSTW	(R0)			;ATTEMPT TO READ CSR
OK:	MOVZBL	#SS$_NORMAL,R0		;IF NO MCHECK, SET STATUS TO 
					; SUCCESS
	BRB	TEST_DONE		;JOIN COMMON EXIT

;
; TEMPORARY CSR TEST MACHINE CHECK HANDLER FOR THE 11/750:
;

	.ALIGN	LONG			;REQ'D MACHINE CHECK ALIGNMENT
MCHK_750:				;
	MTPR	#^XF,#PR$_MCESR		;CLEAR NON-EX MEMORY CONDITION
	MOVL	#<1@NEX>,R0		;SETUP
	CMPL	(SP),#^X0C		;IS THIS A 730 FRAME?
	BEQL	50$			;YES, THEN DON'T CHECK FURTHER
	MOVL	MCK_BER(SP),R0		;SAVE BUS ERROR REGISTER
50$:	MOVL	R2,SP			;CLEAR MCHECK INFO FROM STACK
	BBC	#NEX,R0,OK		;MEMORY EXISTS, PARITY FAILURE
	.ENDC
NONEX_DEV:				;
	CLRL	R0			;SET STATUS TO FAILURE
TEST_DONE:
	POPL	4(R1)			;RESTORE SYSTEM MCHECK HANDLER
TEST_DONE_2:
	POPR	#^M<R1,R2>		;RESTORE REGISTERS
	RSB				;RETURN RESULT TO CALLER

	.END
