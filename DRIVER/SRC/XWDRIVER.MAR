	.SBTTL	MODULE - XWDRIVER
	.TITLE	XWDRIVER - BSC DUP11 Device Driver
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; Modified by:
;
;	V02-001	EAD0001		Elliott A. Drayton		30-JUN-1981
;		Added symbolic definition for UCBSIZE.
;
;
; MACRO LIBRARY CALLS
;
 
	$XWDEF
	$EBCDEF
	$CRBDEF				;DEFINE CRB OFFSETS
	$DDBDEF				;DEFINE DDB OFFSETS
	$DPTDEF				;DEFINE DPT OFFSETS
	$IDBDEF				;DEFINE IDB OFFSETS
	$IODEF				;DEFINE I/O FUNCTION CODES
	$IRPDEF				;DEFINE IRP OFFSETS
	$JIBDEF
	$MSGDEF				;DEFINE SYSTEM MESSAGE TYPES
	$PCBDEF				;DEFINE PCB OFFSETS
	$UCBDEF				;DEFINE UCB OFFSETS
	$VECDEF				;DEFINE VEC OFFSETS
 
;
; LOCAL SYMBOLS
;
; ARGUMENT LIST OFFSET DEFINITIONS
;
 
P1=0					;FIRST FUNCTION DEPENDENT PARAMETER
P2=4					;SECOND FUNCTION DEPENDENT PARAMETER
P3=8					;THIRD FUNCTION DEPENDENT PARAMETER
P4=12					;FOURTH FUNCTION DEPENDENT PARAMETER
P5=16					;FIFTH FUNCTION DEPENDENT PARAMETER
P6=20					;SIZTH FUNCTION DEPENDENT PARAMETER
 
;
; Error recording macro
;
	.MACRO	PROTLO	ERRNO
	MOVZBL	#ERRNO,-(SP)		; Put the error on the stack
	BSBW	ERR_RECORD		; Call the error recorder
	.ENDM	PROTLO

	REP=1*2				; Out of phase ACK after REP
	NAK=2*2				; RECEIVED NAKS
	NAKOUT=3*2!1			; Fatal nak retry
	BADACK=4*2!1			; Out-of-phase ACK other than as
					;  a response to a ENQ
	DSR_LOST=5*2!1			; DSR lost durring a buffer
	GARBLED_RESP=6*2		; Unrecognizable response to text
	CON_RESP=7*2			; Conversational response received
	REC_BKTOLONG=8*2		; Receive block to long for buffer
	REC_REP=9*2			; Reply lost (ENQ received)
	REC_FORABORT=10*2		; Forward abort received (ENQ in text)
	REC_TXTFORMAT=11*2		; Block format undecipherable
	REC_DISCON=12*2!1		; Disconnect received
	ABEOT=13*2			; Abnormal EOT (durring xmt text)
	REPOUT=14*2!1			; Transmit retry threshold
	SEN_RES_TIMOUT=15*2!1		; Timout durring response
	TMO_XMT_TXTBLK=16*2		; Timout sending a text block
	NAK_SENT=17*2			; Nak transmitted
	REP_SENT=18*2			; Rep (ENQ) sent

	NO_ERRORS=18			; Highest error number+3 rounded up
;	.LIST	MEB
;
;Define Device Dependent Unit Control Block Offsets
;
	$DEFINI	UCB
		.=UCB$L_DPC
	$DEF	UCB$L_XW_SPBF	.BLKL 1		; Short protocol buffer
	$DEF	UCB$L_XW_SYCNT .BLKL 1		; Sync count (also offline ct)
	$DEF	UCB$L_XW_ITBPTR	.BLKL 1		; Internal CRC pointer
	$DEF	UCB$B_XW_ITBCNT	.BLKB 1		; Internal CRC count
	$DEF	UCB$B_XW_TISTA	.BLKB 1		; Interrupt state
	$DEF	UCB$B_XW_RISTA	.BLKB 1		; Receive interrupt state
	$DEF	UCB$W_XW_LSTCSR	.BLKW 1		; CSR at end of last transfer
	$DEF	UCB$B_XW_ERRORS	.BLKB NO_ERRORS+2 ; Error talleys + 2 bytes
						;   for current err & 0 spare
UCB$K_SIZE=.

	$DEFEND	UCB
	
;
; Device specific flags definition (for UCB$W_DEVSTS)
;
	UCB$V_XW_REP=0			; Retry state
	UCB$M_XW_REP=^O1		;...
	
	UCB$V_XW_AK1=1			; ACK1 next
	UCB$M_XW_AK1=2			; ACK1 next

	UCB$V_XW_NAK=2			; NAK sent last flag
	UCB$M_XW_NAK=^O4		; ...
					;  to a long word

	UCB$M_XW_PIPE=^o10		; Cancel pipeline marker
	UCB$V_XW_PIPE=3
;
; DUP-11 CSR Offset And Bit Definitions
;
	DUP_CSR_RDBF=2			; Receiver data buffer
	DUP_CSR_PARM=2			; Parameter register
	DUP_CSR_TXCSR=4			; Transmitter command register
	DUP_CSR_TXDBF=6			; Transmitter data buffer
	DUP_CSR_M_DTR=^O2		; Data terminal ready
	DUP_CSR_M_RTS=^O4		; Request to send
	DUP_CSR_M_REN=^O20		; Receiver enable
	DUP_CSR_M_RIE=^O100		; Receiver interrupt enable
	DUP_CSR_M_RDN=^O200		; Receiver done
	DUP_CSR_M_SSY=^O400		; Strip SYN
	DUP_CSR_M_DSR=^O1000		; Data set ready
	DUP_CSR_M_CTS=^O20000		; Clear to send
	DUP_CSR_M_BYM=^O100000		; Byte mode
	DUP_CSR_M_SND=^O20		; Send
	DUP_CSR_M_TIE=^O100		; Transmit interrupt enable
	DUP_CSR_M_TDN=^O200		; Transmit done
	DUP_CSR_M_RES=^O400		; Reset
	DUP_CSR_M_SOM=^O400		; Transmit start of message
	DUP_CSR_M_EOM=^O1000		; Transmit end of message
	DUP_CSR_M_CRI=^O1000		; CRC inhibit bit
	DUP_CSR_M_HDX=^O10		; Half duplex bit
	DUP_CSR_M_ETM=^O10000		; Maintenance clock bit
	DUP_CSR_M_STM=^O4000		; System (internal)loop mode
;
; Transmit interrupt state definition
;
	TSTA$IDLE=0			; No interrupt expected
	TSTA$CTS=1			; Wait forCTS
	TSTA$SYN=2			; Transmit SYN
	TSTA$TEXT=3			; Transmit text
	TSTA$ENDPAD=4			; Transmit trailing pad
	TSTA$DIAG=5			; Diagnostic (no CTS wait) state

;
; Receive interrupt state definition
;
	RST$IDLE=0			; No interrupts expected
	RST$BINARY=1			; Read until byte count runout
	RST$FIRST=2			; Starting state
	RST$NTTX=3			; Non-transparent text state
	RST$STOP1=4			; Last CRC byte
	RST$STOP=5			; Stop after next byte
	RST$ITB=6			; First byte of internal CRC next
	RST$ITB1=7			; Second byte of internal CRC next
	RST$XPRTEXT=8			; Transparent text state
	RST$DLE=9			; Control character or stuffed DLE next
	RST$XPRITB=10			; First byte of internal CRC next
	RST$XPRITB1=11			; Second byte of internal CRC next
	RST$DIAG=12			; Diagnostic receive interrupt state
	RST$LOOP_TEST=13		; Diagnostic slave loop state
;
;DRIVER PROLOG TABLE
;
	DPTAB	-			; Define driver prolog table
		END=XW_END,-		; End of driver
		ADAPTER=UBA,-		; Adapter type
		UCBSIZE=UCB$K_SIZE,-	; UCB size
		NAME=XWDRIVER		; Driver name
	DPT_STORE	INIT		; Control block init values
	DPT_STORE	UCB,-
			UCB$B_ERTMAX,B,8 ; Retry count
	DPT_STORE	UCB,-		; Fork IPL
			UCB$B_FIPL,B,8
	DPT_STORE	UCB,UCB$L_DEVCHAR,L,- ; Device characteristics bits
			<DEV$M_AVL-	; Device avalable
			!DEV$M_IDV-	; Input device
			!DEV$M_ODV>	; Output device
	DPT_STORE	UCB,UCB$W_DEVBUFSIZ,- ; Device buffer size
			W,520
	DPT_STORE	UCB,UCB$B_DIPL,B,21 ; Device IPL
	DPT_STORE	REINIT		; Fields to reinit. at driver roload
	DPT_STORE	DDB,DDB$L_DDT,-	; Device dispatch table
			D,XW$DDT
	DPT_STORE	CRB,CRB$L_INTD+4,- ; Receive interrupt entry point
			D,XW_RINT
	DPT_STORE	CRB,CRB$L_INTD2+4,- ; Transmit interrupt entry point
			D,XW_TINT
	DPT_STORE	CRB,CRB$L_INTD+VEC$L_UNITINIT,- ; Unit initalization
			D,XW_INIT
	DPT_STORE	END
;
; Driver Dispatch Table
;
	DDTAB	XW,-			; Driver dispatch table
		XW_STARTIO,-		; Start IO entry point
		0,-			; Unexpected interrupt
		XW_FUNCTABLE,-		; FDT lable
		XW_CANCELIO,-		; Cancel IO label
		REGDUMP,-		; Register dump routine
		170,-			; Size of diagnostic buffer
		170			; Size of errlog buffer
;
;FDT tables for BSC DUP-11 driver
;
XW_FUNCTABLE:
	FUNCTAB	,-		; Legal functions
		<READLBLK,-	; Read logical block
		READPBLK,-	; Read physical block
		WRITELBLK,-	; Write logical block
		WRITEPBLK,-	; Write physical block
		SETMODE,-	; Set mode
		SENSEMODE,-
		>
;
	FUNCTAB	,-		; Legal functions
		<READLBLK,-	; Read logical block
		READPBLK,-	; Read  block
		WRITELBLK,-	; Write logical block
		WRITEPBLK,-	; Write physical block
		SETMODE,-	; Set mode
		SENSEMODE,-
		>
;
	FUNCTAB	XW_WRITE,-	; Write entry
		<WRITEPBLK-	; Write physical block
		WRITELBLK-	; Write logical block
		>
;
	FUNCTAB	XW_READ,-	; Read processing entry
		<READPBLK-	; Read physical block
		READLBLK-	; Read logical block
		>
;
	FUNCTAB	+EXE$SETMODE,-	; Set mode
		SETMODE
;
	FUNCTAB	+EXE$ZEROPARM,-
		SENSEMODE
	.PAGE
	.SBTTL	XWDRIVER Write FDT Routines
;+
; XW_WRITE - WRITE FUNCTION PROCESSING
;
; THIS ROUTINE IS CALLED FROM THE FUNCTION DECISION TABLE DISPATCHER TO PROCESS
; A WRITE LOGICAL OR WRITE PHYSICAL FUNCTION TO A DUP-11.
;
; INPUTS:
;
;	R0 = SCRATCH.
;	R1 = SCRATCH.
;	R2 = SCRATCH.
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R5 = ASSIGNED DEVICE UCB ADDRESS.
;	R6 = ADDRESS OF CCB.
;	R7 = I/O FUNCTION CODE.
;	R8 = FUNCTION DECISION TABLE DISPATCH ADDRESS.
;	R9 = SCRATCH.
;	R10 = SCRATCH.
;	R11 = SCRATCH.
;	AP = ADDRESS OF FIRST FUNCTION DEPENDENT PARAMETER.
;
; OUTPUTS:
;
;	THE FUNCTION PARAMETERS ARE CHECKED AND A BUFFER IS ALLOCATED FOR THE
;	DUP-11 DRIVER TO BUILD A MESSAGE INTO.
;-
 
	.ENABL	LSB
XW_WRITE:
	EXTZV	#XW$V_IOMOD,#XW$S_IOMOD,- ; Extract the IO modifier field
		IRP$W_FUNC(R3),R0
	CASE	R0,-			; Dispatch on the modifier
		<XMT_BINARY,-		; Send until count runout
		XMT_PTPBSC,-		; Add point to point BSC control
		BAD_MODIFIER,-
		BAD_MODIFIER,-
		BAD_MODIFIER,-
		BAD_MODIFIER,-
		BAD_MODIFIER,-
		XMT_DIAG,-		; Full duplex diagnostic processing
		>			; Last modifier
;
; Modifier was out of range so abort the request
;
BAD_MODIFIER:
	MOVZWL	#XW$M_ILLMOD,R1		; Get device dependant status
	JMP	G^EXE$ABORTIO		; Abort the request
;
; Send the users buffer with no processing
;
XMT_BINARY:
	MOVL	P1(AP),R0		; Get the user buffer pointer
	MOVL	P2(AP),R1		; Get the user count
	BEQL	10$			; Complete now if zero count
	JSB	G^EXE$WRITECHK		; Check the user buffer
	JSB	ALLOC_SETUP		; Allocate and set up a buffer
	MOVW	P2(AP),IRP$W_BCNT(R3)	; Store the byte count
	MOVL	@IRP$L_SVAPTE(R3),R2	; Get the system buffer pointer
	PUSHR	#^M<R3,R4,R5>		; MOVC uses these
	MOVC	P2(AP),@P1(AP),(R2)		; Move the buffer
	POPR	#^M<R3,R4,R5>		; Restore pointers
	JMP	G^EXE$QIODRVPKT		; Post the packet to the driver
	.PAGE
;
; Format the users list of records into a bisync block
;
XMT_PTPBSC:
	MOVL	P1(AP),R0		; Get user buffer pointer
	MOVL	P2(AP),R1		; Get user buffer count
	BNEQ	20$			; BR if not zero count
10$:	MOVZWL	#SS$_NORMAL,R0		; Get normal completion status
	CLRL	R1			; No device dependant status
	JMP	G^EXE$FINISHIOC		; Complete the IO request
20$:	JSB	G^EXE$WRITECHK		; Check the user buffer descripter
;
; Check the buffer chain
;
	ADDL3	R1,R0,R9		; Point to the end of the user buffer
	CLRL	R2			; Set zero record count
	SUBL2	#2,R9			; Point before last count
30$:	MOVZWL	(R0)+,R8		; Get the the count
	CMPW	#-1,R8			; Last count ?
	BEQL	50$			; yes - branch out
	INCL	R2			; Step record count
	ACBL	R9,R8,R0,30$		; BR if next count is in buffer
	MOVZWL	#XW$M_BADCHAIN,R1	; Get bad buffer status
40$:	JMP	G^EXE$ABORTIO		; Abort the operation

50$:	BBS	#XW$V_CHA_XPR,-		; Is transparency called for
		UCB$L_DEVDEPEND(R5),XPRTXT
	BRW	NXPRTXT			; Go to nontransparent code
	.DSABL	LSB
; Build a transparent text block
;
XPRTXT:
	MULL3	#2,P2(AP),R1		; Get the count
	MULL2	#3,R2			; Each record needs 7 extra bytes
	ADDL	R2,R1			; Get the total size
	BSBW	ALLOC_SETUP		; Get a system buffer
;	R9 -From data pointer
;	R10 -To data pointer
;	R11 -Record count
	PUSHR	#^M<R3,R4,R5,R8>
	MOVZWL	IRP$W_FUNC(R3),R8	; Save the function
	CLRL	-(SP)			; No starting CRC
	MOVL	@IRP$L_SVAPTE(R3),R10	; Set the to pointer
	MOVL	P1(AP),R9		; Set the from pointer
	MOVZWL	(R9)+,R11		; Get the first record,s count
10$:	MOVW	#EBCDLE!<EBCSTX*256>,(R10)+ ; All records start with DLE STX
	CRC	POLY_TABLE,(SP),R11,(R9) ; Get the CRC on the Record
	MOVW	R0,(SP)			; Save the CRC until end of record
20$:	LOCC	#EBCDLE,R11,(R9)	; Find any DLE in the data
	BEQL	30$			; BR if end of record and no CRC
	INCL	R1			; Include the DLE in the "found" data
	SOBGTR	R0,30$			; ...
	DECL	R0			; Flag a DLE ended the record
30$:	MOVL	R0,R11			; Set remaining data count
	SUBL3	R9,R1,R0		; Get scaned data count
	MOVC	R0,(R9),(R10)		; And move the data
	MOVL	R1,R9			; Set new from pointer
	MOVL	R3,R10			; Set new to pointer
	MOVB	#EBCDLE,(R10)+		; Stuff the DLE or end with DLE
	TSTL	R11			; Is this the end of block
	BGTR	20$			; NO -find more DLE,s
	BEQL	40$			; If eql, was the end of the block
	MOVB	#EBCDLE,(R10)+		; Else block ended with DLE, so stuff
					; an extra DLE in for control character
40$:	MOVW	(R9)+,R11		; Get the next record count
	CMPW	#-1,R11			; Is it the sentenal
	BEQL	50$			; BR if it is
	MOVB	#EBCITB,(R10)		; Store a record seperator
	BSB	70$			; Add the trcord end char. to CRC
	MOVW	#EBCSYN!<EBCSYN*256>,(R10)+ ; Followed by SYN SYN sin
	MOVZWL	#DLE_STX_CRC,(SP)	; Assume the next partial CRC
	BRB	10$			; Get another record
50$:	MOVB	#EBCETB,(R10)		; Assume not last block
	BBC	#IO$V_LASTBLOCK,-	; Is it the last block
		R8,60$
	MOVB	#EBCETX,(R10)		; Set end of last block
60$:	BSB	70$			; Include the block end chsr. in CRC
	ADDL	#4,SP			; Remove the partial CRC
	POPR	#^M<R3,R4,R5,R8>
	SUBL2	@IRP$L_SVAPTE(R3),R10	; Get the block count
	MOVW	R10,IRP$W_BCNT(R3)	; Save the byte count
	JMP	G^EXE$QIODRVPKT		; Post the IRP to the driver

70$:	CRC	POLY_TABLE,4(SP),#1,(R10) ; include the last chara. in the CRC
	INCL	R10			; Step by the last byte
	MOVW	R0,(R10)+		; And store the last byte
	RSB
;
; Nontransparent record blocking and CRC generation
;
NXPRTXT:
	MULL2	#3,R2			; Need count space +3 byte for each rec
	ADDL	#4,R2			; Room for STX and luck
	ADDW3	P2(AP),R2,R1		; get eventual size
	BSBW	ALLOC_SETUP		; allocate and set up a system buffer
	PUSHR	#^M<R3,R4,R5,R6>		; save the FDT call reg. setup
	MOVZWL	IRP$W_FUNC(R3),R6	; Get the IO function & mod.
	MOVL	@IRP$L_SVAPTE(R3),R3	; Get the system buffer pointer
	MOVB	#EBCSTX,(R3)+		; Start the block with a stx
	MOVL	P1(AP),R11		; Get the user buffer pointer
10$:	MOVZWL	(R11)+,R2		; And the first record count
	CMPW	#-1,R2			; Is it the sentenal
	BEQL	40$			; BR if it is
	MOVQ	R2,R9			; Save the start of rec. ptr. &cnt.
	MOVC	R2,(R11),(R3)		; Move the record into the sys. buf.
	; R1- start of next record, R3- end of this record
	MOVL	R1,R11			; Save a pointer to next record
	INCL	R9			; Include the record end character
					;  (not yet added) in the count
	MOVB	#EBCITB,(R3)		; Add an ITB to the block
	CMPW	#-1,(R11)		; Is this to be end of block
	BNEQ	30$			; BR- if it is ITB CRC CRC
	MOVB	#EBCETB,(R3)		; Assume intermediate block
	BBC	#IO$V_LASTBLOCK,-	; BR if not last block
		R6,30$
	MOVB	#EBCETX,(R3)		; Add an ETX to the block
30$:	CRC	POLY_TABLE,#0,R9,(R10)	; Get the crc for the whole record
					;  after the CRC instruction r0=CRC
					;  and R3 points after the last byte
	MOVW	R0,(R3)+		; Store the CRC in the block
	MOVW	#EBCSYN!<EBCSYN*256>,(R3)+ ; Start each record with syn-syn
	BRB	10$			; Do next record
40$:	SUBL3	#2,R3,R1		; Point after last CRC (before syn)
	POPR	#^M<R3,R4,R5,R6>
	SUBL2	@IRP$L_SVAPTE(R3),R1	; Calculate the count
	MOVW	R1,IRP$W_BCNT(R3)	; And save it in the IRP
	JMP	G^EXE$QIODRVPKT		; Queue the packet to the driver

	.PAGE
;
; Allocate and set up a system buffer utility
;
ALLOC_SETUP:
	PUSHL	R3			; Save the IRP pointer
	ADDL	#12,R1			; include overhead size
	JSB	G^EXE$BUFQUOPRC		; Does the user have quota
	BLBC	R0,10$			; BR if not
	JSB	G^EXE$ALLOCBUF		; Get the buffer
10$:	POPL	R3			; Get back the IRP pointer
	BLBC	R0,20$			;BR if allocation failure
	MOVL	R2,IRP$L_SVAPTE(R3)	;Save the new buffer pointer
	MOVW	R1,IRP$W_BOFF(R3)	; Save the no. bytes allocated and charged
	MOVL	PCB$L_JIB(R4),R0	; GET JIB ADDRESS
	SUBL	R1,JIB$L_BYTCNT(R0)	; ADJUST QUOTA
	MOVAB	12(R2),(R2)+		;Set up pointer to first byte of buffer
	MOVL	P1(AP),(R2)		; Set up pointer to start of user buffer
	MOVW	P2(AP),IRP$W_ABCNT(R3)	; Save the users transfer count
	RSB

20$:	ADDL	#4,SP			; Pop the return off the stack
	JMP	G^EXE$ABORTIO		; Abort the operation

;
; Diagnostic full duplex read/write FDT processing
;
XMT_DIAG:
	MOVQ	P3(AP),R0		; Check the read buffer
	JSB	G^EXE$READCHK		; ...
	MOVQ	P1(AP),R0		; Check the write buffer
	JSB	G^EXE$WRITECHK		; ...
	ADDL3	P2(AP),P4(AP),R1	; Get the total buffer count
	JSB	ALLOC_SETUP		; Allocate a system buffer
	MOVL	P3(AP),(R2)		; Set receive buffer addr. for
					;  IO completion code
	MOVZWL	P4(AP),IRP$W_BCNT(R3)	; Set the rec. count
	ADDL3	@IRP$L_SVAPTE(R3),P4(AP),R0 ; Get the transmit pointer
	PUSHR	#^M<R3,R4,R5>
	MOVC	P2(AP),@P1(AP),(R0)	; Move the transmit data
	POPR	#^M<R3,R4,R5>
	JMP	G^EXE$QIODRVPKT		; Queue the packet to the driver
	.PAGE
	.SBTTL	XW/DUP-11 Read FDT Routines
;+
; XW_READ - READ FUNCTION PROCESSING
;
; THIS ROUTINE IS CALLED FROM THE FUNCTION DECISION TABLE DISPATCHER TO PROCESS
; A READ LOGICAL OR READ PHYSICAL FUNCTION TO A DUP11 DEVICE.
;
; INPUTS:
;
;	R0 = SCRATCH.
;	R1 = SCRATCH.
;	R2 = SCRATCH.
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R5 = ASSIGNED DEVICE UCB ADDRESS.
;	R6 = ADDRESS OF CCB.
;	R7 = I/O FUNCTION CODE.
;	R8 = FUNCTION DECISION TABLE DISPATCH ADDRESS.
;	R9 = SCRATCH.
;	R10 = SCRATCH.
;	R11 = SCRATCH.
;	AP = ADDRESS OF FIRST FUNCTION DEPENDENT PARAMETER.
;
; OUTPUTS:
;
;	THE FUNCTION PARAMETERS ARE CHECKED AND A BUFFER IS ALLOCATED FOR THE
;	DUP-11 DRIVER TO  RECEIVE A MESSAGE INTO.
;-
 
XW_READ:
	EXTZV	#XW$V_IOMOD,#XW$S_IOMOD,- ; Extract the IO modifier field
		IRP$W_FUNC(R3),R0
	CASE	R0,-			; Dispatch on the modifier
		<REC_BINARY,-		; receive until count runout
		REC_PTPBSC,-		; Add point to point BSC control
		>			; Last modifier
	BRW	BAD_MODIFIER		; Out of range function
;
; Receive until byte count run out- no line protocol or data processing
;
	.ENABL	LSB
REC_BINARY:
;
; Receive data and manage point-to-point BSC line protocol
;
REC_PTPBSC:
	MOVL	P1(AP),R0		; Get the user pointer
	MOVL	P2(AP),R1		; Get the users count
	BNEQ	20$			; Complete the request now if zero
10$:	CLRL	R1			; No device dependant status
	MOVZWL	#SS$_NORMAL,R0		; Get normal completion status
	JMP	G^EXE$FINISHIOC		; Return the packet
20$:	JSB	G^EXE$READCHK		; Check the user buffer
	CMPZV	#XW$V_IOMOD,#XW$S_IOMOD,- ; Is this a binary operation
		IRP$W_FUNC(R3),#IO$K_SRRUNOUT
	BEQL	30$			; BR if it is
	MOVZWL	UCB$W_DEVBUFSIZ(R5),R1	; Get the block size
	ADDL	#8*4,R1			; Room for ITB pointers
30$:	BSBW	ALLOC_SETUP		; Get a system buffer and set it up
	SUBW3	#12,R1,IRP$W_BCNT(R3)	; Save the transfer count
40$:	JMP	G^EXE$QIODRVPKT		; Post the packet to the driver
	.PAGE
	.SBTTL	Start IO on the DUP-11
;+
; XW_STARTIO - START I/O OPERATION ON THE DUP-11
;
; THIS ROUTINE IS ENTERED WHEN THE ASSOCIATED UNIT IS IDLE AND A PACKET IS
; AVAILABLE FOR PROCESSING.
;
; INPUTS:
;
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;	R5 = ADDRESS OF DEVICE UNIT UCB.
;
; OUTPUTS:
;
; LOTSATEXT
;
;-
 
XW_STARTIO:
	.ENABL	LSB
	MOVL	UCB$L_CRB(R5),R4	; Get the DUP csr pointer
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R4 ; ...
	CMPZV	#IRP$V_FCODE,-		;Is this a set function
		#IRP$S_FCODE,IRP$W_FUNC(R3),-
		#IO$_SETMODE
	BNEQ	50$			; BR if not set
;
; Set mode
;
	MOVW	IRP$L_MEDIA+2(R3),UCB$W_DEVBUFSIZ(R5) ; Set block size
	MOVL	IRP$L_MEDIA+4(R3),UCB$L_DEVDEPEND(R5) ; Save characteristics
	BBC	#IO$V_SHUTDOWN,-	; Is dorp line requested
		IRP$W_FUNC(R3),10$
	BISW	#DUP_CSR_M_RES,DUP_CSR_TXCSR(R4) ;Reset the DUP
	BRB	40$			; Complete the request

10$:	BBC	#IO$V_STARTUP,-		; Is enable line requested
		IRP$W_FUNC(R3),40$
	BISW	#DUP_CSR_M_DTR,(R4)	; Assert DTR
20$:	BITW	#DUP_CSR_M_DSR,(R4)	; Is DSR up ?
	BNEQ	40$			; BR if it is
	BBS	#IO$V_NODSRWAIT,-	; Is a non wait diagnostic function here
		IRP$W_FUNC(R3),40$
	BSBW	110$			; Send a line off message
	DSBINT
	WFIKPCH	30$,#2
30$:	SETIPL	UCB$B_FIPL(R5)
	BBC	#UCB$V_CANCEL,UCB$W_STS(R5),20$ ; Cancel requested ?
	BRW	CANCEL_CUR		; Return this packet
40$:	BRW	COMP_GOOD		; Complete the request

50$:	CMPZV	#IRP$V_FCODE,#IRP$S_FCODE,-	; Is it a sense mode ?
		IRP$W_FUNC(R3),#IO$_SENSEMODE
	BEQL	90$				; BR if it is
;
; Send/receive request
;
	BICL	#UCB$M_XW_NAK!UCB$M_XW_REP,UCB$W_DEVSTS(R5) ; Reset status bits
	MOVB	UCB$B_ERTMAX(R5),UCB$B_ERTCNT(R5) ; Init the retry count
SND_REC_REQ:
	BBC	#UCB$V_CANCEL,UCB$W_STS(R5),60$	; BR if not canceled
	BRW	CANCEL_CUR			; Cancel this IRP
60$:	MOVW	IRP$W_FUNC(R3),UCB$W_FUNC(R5) ; Save the function code for ELG.
	MOVL	@IRP$L_SVAPTE(R3),UCB$L_SVAPTE(R5) ; copy buffer desc. to UCB
	MOVW	IRP$W_BCNT(R3),UCB$W_BCNT(R5) ; ...
	BITW	#DUP_CSR_M_DSR,(R4)	; Is the line up
	BNEQ	70$			; BR if it is
	BBS	#IO$V_NODSRWAIT,-	; Is it a diagnostic bypass????????
		IRP$W_FUNC(R3),70$
;
; The line is not connected (no DSR) abort the request
;
ABORT_NO_DSR:
	MOVZWL	#XW$M_NODSR,R1		; Get no DSR status
	BRW	ABORT_CUR		; Conplete this IRP with abort status

70$:	EXTZV	#XW$V_IOMOD,#XW$S_IOMOD,- ; Extract the IO modifier field
		IRP$W_FUNC(R3),R0
	BBC	#IRP$V_FUNC,IRP$W_STS(R3),80$ ; BR if a write
	CASE	R0,-			; READ dispatch on the modifier
		<REC_INI_BINARY,-	; Send until count runout
		REC_INI_PTPBSC,-	; Add point to point BSC control
		>			; Last modifier
80$:	CASE	R0,-			; WRITE dispatch on the modifier
		<XMT_INI_BINARY,-		; Send until count runout
		XMT_INI_PTPBSC,-		; Add point to point BSC control
		ABORT_CUR,-
		ABORT_CUR,-
		ABORT_CUR,-
		ABORT_CUR,-
		ABORT_CUR,-
		XMT_INI_DIAG,-			; Start a diagnostic QIO
		>			; Last modifier
;
; Sense mode
;
90$:	MOVL	UCB$L_DEVDEPEND(R5),R1	; Get the device char.
	BICL	#XW$M_CHA_DSR,R1	; Assume no DSR
	BITW	#DUP_CSR_M_DSR,(R4)	; Is DSR up ?
	BEQL	100$			; BR if not
	BISL	#XW$M_CHA_DSR,R1	; Mark DSR active
100$:	BRW	COMP_GOOD		; Return the IRP

;
; Send a message to the operator
;
110$:	ACBB	#15,#1,UCB$L_XW_SYCNT(R5),130$ ; Time for a message
	CLRB	UCB$L_XW_SYCNT(R5)	; Reset the message counter
	MOVZBL	#MSG$_DEVOFFLIN,R0	; Get a device off line message
120$:	PUSHR	#^M<R3,R4>
	MOVL	R0,R4			; Set up the message no.
	MOVAB	G^SYS$GL_OPRMBX,R3	; Get the operators box no.
	JSB	G^EXE$SNDEVMSG		; And send it
	POPR	#^M<R3,R4>
130$:	RSB
	.PAGE
	.DSABL	LSB
;
;Receive until byte count runout with no protocol or processing set up code
;
REC_INI_BINARY:
	BICW	#UCB$M_XW_PIPE,UCB$W_DEVSTS(R5) ; Reset any abort pipeline mark
	MOVB	#RST$BINARY,UCB$B_XW_RISTA(R5) ; Set interrupt processor state
	BBC	#IO$V_SLAVLOOP,IRP$W_FUNC(R3),10$ ; Is this a diagnostic loop
	MOVB	#RST$LOOP_TEST,UCB$B_XW_RISTA(R5) ; Set loop state
10$:	BSBW	RCV_START		; Start the receiver
REC_BIN_WAIT:
	WFIKPCH	REC_BIN_TMO,#2		; Wait for the receive to complete
	IOFORK				; Create a fork process
	SUBL3	@IRP$L_SVAPTE(R3),-	; Get the actual transfer size
		UCB$L_SVAPTE(R5),R0
	MOVW	R0,IRP$W_BCNT(R3)	; and set it for the iocompletion code
	BRW	COMP_GOOD		; Return the packet to the user
	.page
;
; Receive a buffer then check its' CRC and do the proper PTP BSC line protocol
;
	.ENABL	LSB
REC_INI_PTPBSC:
	BBC	#UCB$V_XW_PIPE,-	; is the cancel pipe active
		UCB$W_DEVSTS(R5),5$
PIPE_MARK:
	MOVZWL	#XW$M_PIPE_MARK,R1	; Get the pipe mark error
	BRW	ABORT_CUR		; And abort the current IRP
5$:	MOVZWL	UCB$W_BCNT(R5),R0	; Get the rec buffer size
	SUBW	#8*4,R0			; Remove the CRC pointers from count
	ADDL3	UCB$L_SVAPTE(R5),R0,R1	; Point to the first CRC pointer
	MOVL	R1,UCB$L_XW_ITBPTR(R5)	; Set up the ITB pointer pointer
	MOVB	#7,UCB$B_XW_ITBCNT(R5) ; Init. the ITB count
	DECL	R0			; Save a byte for a count
	MOVW	R0,UCB$W_BCNT(R5)	; Set the receive buffer count
	INCL	UCB$L_SVAPTE(R5)	; Save the count byte
	CLRQ	(R1)+			; Init. the ITB pointer area
	CLRQ	(R1)+			; ...
	CLRQ	(R1)+			; ...
	CLRQ	(R1)+			; ...
	MOVB	#RST$FIRST,UCB$B_XW_RISTA(R5) ; Set the starting int. state
	BSBW	RCV_START		; Start the device
REC_TEXT_WAIT:
	WFIKPCH	REC_TEXT_TMO,#4		; Wait for the buffer to complete
	IOFORK				; Create a fork process
	MOVL	@IRP$L_SVAPTE(R3),R1	; Get the start of the buffer
	INCL	R1			; Skip the hidden byte
	SUBL3	R1,UCB$L_SVAPTE(R5),R0	; Get the no. bytes received
	TSTW	UCB$W_BCNT(R5)		; Did the byte count run out
	BGTR	10$			; BR if not
	PROTLO	REC_BKTOLONG
	BRW	SND_REC_REQ		; Reassign the buffer

10$:	DECL	R0			; Redice the buff. count by one
	MOVB	(R1)+,R2		; Get the first char. of the block
	CMPB	#EBCENQ,R2		; Is the last response requested
	BNEQ	20$			; BR if not
	PROTLO	REC_REP
	BSBW	SEND_RESP		; Set up the last response
	WFIKPCH	REC_REP_TMO,#4
	IOFORK				; Create a fork process
	BRW	SND_REC_REQ		; Reassign the buffer

20$:	CMPB	#EBCEOT,R2		; Is it an EOT
	BNEQ	30$			; BR if not
	MOVZWL	#XW$M_EOT,R1		; Get an EOT status
	BRW	ABORT_CUR		; Abort the packet

30$:	CMPB	#EBCSTX,R2		; Is it a STX
	BNEQ	70$			; BR if not
	CMPB	#EBCENQ,-1(R1)[R0]	; Is it a TTD or abort
	BNEQ	50$			; BR if not
	CMPB	#EBCETX,-3(R1)[R0]	; Is the ENQ a CRC char. ?
	BEQL	50$			; BR if it is
	CMPB	#EBCETB,-3(R1)[R0]	; ...
	BEQL	50$			; BR if it is
;
; TTD or Forward Abort
;
	MOVZBL	#EBCNAK,R1		; Get a NAK
	BSBW	XMT_START_PRO1		; And send it
	WFIKPCH	REC_FABO_TMO,#4
	IOFORK				; Create a fork process
	MOVL	@IRP$L_SVAPTE(R3),R0	; Get the old buffer pointer
	INCL	R0			; Point to first received byte
	CMPW	#EBCSTX!<EBCENQ*256>,(R0) ; Was it a TTD
	BEQL	40$			; Yes- only log aborts
	PROTLO	REC_FORABORT
40$:	BRW	SND_REC_REQ		; Reassign the buffer
50$:	CLRL	IRP$L_MEDIA+4(R3)	; Start with no status
	CMPB	#EBCETX,-3(R1)[R0]	; Is it an ETX block
	BNEQ	60$			; BR if not
	MOVZWL	#XW$M_ETXEND,-		; Set the completion status
		IRP$L_MEDIA+4(R3)
60$:	BRW	BLK_CHECK		; Go do the CRC check

70$:	MOVW	-1(R1),R2		; Get the first two bytes from the buff.
	INCL	R1			; Step the buffer pointer
	DECL	R0			; And count
	CMPW	#EBCDLE!<EBCEOT*256>,R2	; Is it a disconnect
	BNEQ	80$			; Br in not
	PROTLO	REC_DISCON
	MOVZWL	#XW$M_DISCON,R1		; Get a disconnect status
	BRW	ABORT_CUR		; Return the packet to the user

80$:	CMPW	#EBCDLE!<EBCSTX*256>,R2	; Is it xpr text
	BEQL	90$			; BR if it is
85$:	PROTLO	REC_TXTFORMAT
	BRW	SND_REC_REQ		; Reassign the buffer

90$:	MOVZWL	#XW$M_XPR,R2		; Get transparent status
	CMPB	#EBCETX,-3(R1)[R0]	; Is it the last block
	BNEQ	100$			; Br if not
	BISL	#XW$M_ETXEND,R2		; Save the status for the completion
100$:	MOVL	R2,IRP$L_MEDIA+4(R3)	; ...
	BRW	BLK_CHECK		; Check transparent text block
	.DSABL	LSB
;
; Set up response utility
;
SEND_RESP:
	BBC	#UCB$V_XW_NAK,-		; Is a NAK called for
		UCB$W_DEVSTS(R5),10$
	MOVZBL	#EBCNAK,R1		; Get a NAK message
	BRW	XMT_START_PRO1		; Start the device and return to caller
10$:	BBC	#UCB$V_XW_AK1,-		; BR if an AK1 is needed
		UCB$W_DEVSTS(R5),20$
	MOVZWL	#EBCDLE!<EBCAK0*256>,R1	; Get an AK0
	BRB	30$			; And send it
20$:	MOVZWL	#EBCDLE!<EBCAK1*256>,R1	; Get an AK1
30$:	BRW	XMT_START_PRO2		; Start the device
	.PAGE
;
; Timout during protocol response processing
;
	.ENABL	LSB
REC_BIN_TMO:
	BSB	10$			; Call common timout processing
	BRW	REC_BIN_WAIT		; Cont. waiting
REC_TEXT_TMO:
	BSB	10$			; Join common timout processing
	BRW	REC_TEXT_WAIT		; Continue waiting
REC_REP_TMO:
REC_SNAK_TMO:
REC_FABO_TMO:
	BRW	SND_REC_REQ		; Try again
REC_GACK_TMO:
	BRW	REC_DONE		; Complete it

10$:	BBC	#UCB$V_CANCEL,UCB$W_STS(R5),20$ ; Is a cancel requested ?
	BSB	TMO_RESET		; Reset the device
	POPL	R0			; Remove the return
	BRW	CANCEL_CUR		; Cancel this IRP

20$:	BITW	#DUP_CSR_M_DSR,(R4)	; Is the line connected ?
	BNEQ	30$			; BR if it is
	BSB	TMO_RESET		; Reset the device
	PROTLO	DSR_LOST
	POPL	R0			; Remove the return
	BRW	ABORT_NO_DSR		; Abort this IRP

30$:	MOVL	(SP)+,R0		; Get the return
	DSBINT				; Disable interrupts
	MOVL	R0,-(SP)		; Put the return back
	RSB

TMO_RESET:
	MOVW	(R4),UCB$W_XW_LSTCSR(R5) ; Save the modem lines at end of trans.
	MOVW	#DUP_CSR_M_DTR,(R4)	; Turn off the receiver
	CLRW	DUP_CSR_TXCSR(R4)	; Turn off the transmiter
	SETIPL	UCB$B_FIPL(R5)		; Drop to fork
	MOVB	#RST$IDLE,UCB$B_XW_RISTA(R5) ; Set receiver to idle
	MOVB	#TSTA$IDLE,UCB$B_XW_TISTA(R5) ; Set transmiter to idle
	RSB
	.DSABL	LSB
	.PAGE
;
; Send as binary adding only SYN and trailing PAD characters
;
XMT_INI_BINARY:
	BISW	#UCB$M_XW_AK1,UCB$W_DEVSTS(R5)
	BICW	#UCB$M_XW_PIPE,UCB$W_DEVSTS(R5)
	BSBW	XMT_START		; Start up the transmitter
	MOVZBL	UCB$L_DEVDEPEND+3(R5),R1 ; Get the time to wait in a long word
	WFIKPCH	10$,R1			; Wait for interrupt or timeout
	IOFORK				; Create a fork process
	BRW	COMP_GOOD		; Complete the request with good status
10$:	BSBW	TMO_RESET		; Turn off the device
	MOVZWL	#XW$M_TRABINTMO,R1	; Get a timout sending binary error
	BRW	ABORT_CUR		; And abort the request

	.PAGE
;
; Send as point-to-point BSC
;
	.ENABL	LSB
XMT_INI_PTPBSC:
	BBC	#UCB$V_XW_PIPE,-	; Is the cancel pipe active
		UCB$W_DEVSTS(R5),5$
	BRW	PIPE_MARK
5$:	BSBW	XMT_START		; Start up the transmitter
XMT_TEXT_WAIT:	WFIKPCH	150$,#4			; Wait for interrupt or timeout
	IOFORK				; Create a fork process
GET_RESPONSE:
	BSBW	RCV_START_PRO		; Start a protocol response receive
	WFIKPCH	160$,#4			; Wait for a response
	IOFORK				; Create a fork process
	MOVL	UCB$L_XW_SPBF(R5),R1	; Get the response in R1
	CMPB	#EBCDLE,R1		; Is it a DLE response
	BEQL	6$			; BR if DLE
	BRW	100$			; BR if not DLE
6$:	ASHL	#-8,R1,R1		; Set up the next byte
	CMPB	#EBCEOT,R1		; Is it a disconnect
	BNEQ	10$			; BR if not
	MOVZWL	#XW$M_DISCON,R1		; Get disconnect status
	BRW	ABORT_CUR		; Complete the IRP
10$:	CMPB	#EBCRVI,R1		; Was it an RVI
	BNEQ	20$			; BR if not
	MOVZWL	#XW$M_RVI,R1		; Get RVI status
	BRW	COMP_GOOD_AB		; Complete the IRP
20$:	CMPB	#EBCWACK,R1		; Is it a WACK
	BNEQ	50$			; BR if not WACK
	DSBINT				; Lock out interrupts for the wait
	WFIKPCH	30$,#2			; Wait for 2 seconds
30$:	SETIPL	UCB$B_FIPL(R5)		; Drop IPL to fork
	BBC	#UCB$V_CANCEL,UCB$W_STS(R5),40$ ; BR if no user cancel
	BRW	CANCEL_CUR		; Return the packet to the user
40$:	MOVZBL	#EBCENQ,R1		; Get an ENQ
	BSBW	XMT_START_PRO1		; And send it
	BRB	XMT_TEXT_WAIT		; Wait for a response
;
; Check ACKs
;
50$:	BBC	#UCB$V_XW_AK1,UCB$W_DEVSTS(R5),60$ ; Which ACK is needed
	CMPB	#EBCAK1,R1		; Is it an ACK 1
	BNEQ	52$			; BR if not
	BRW	COMP_GOOD_TGL		; Complete the IRP and toggle ACKs
52$:	CMPB	#EBCAK0,R1		; Is it the other ACK
	BEQL	80$			; BR if it is
	BRW	170$			; NO- consider it garbled
60$:	CMPB	#EBCAK0,R1		; Is it an ACK 0
	BNEQ	62$			; BR if not
	BRW	COMP_GOOD_TGL		; Complete the IRP and toggle the ACKs
62$:	CMPB	#EBCAK1,R1		; Is it the other ACK
	BEQL	80$			; BR if it is
	BRW	170$			; No- consider it garbled
;
; Out of phase ACK
;
80$:	BBSC	#UCB$V_XW_REP,-		; Are we in a rep state
		UCB$W_DEVSTS(R5),90$
	PROTLO	BADACK
	BRW	180$			; Retry without rep state
90$:	MOVB	UCB$B_ERTMAX(R5),-	; Reset the retry counter
		UCB$B_ERTCNT(R5)
	PROTLO	REP			; Record a retry
	BRW	SND_REC_REQ		; Resend the last block
100$:	CMPB	#EBCNAK,R1		; Is it a NAK
	BNEQ	120$			; BR if not
	PROTLO	NAK			; Report a nak sent
	BICW	#UCB$M_XW_REP,UCB$W_DEVSTS(R5) ; Reset possiable rep state
	DECB	UCB$B_ERTCNT(R5)	; Dec. the retry count
	BLEQ	110$			; Retry if threshold not exceeded
	BRW	SND_REC_REQ		; Try again
110$:	MOVZWL	#XW$M_DATACK,R1		; Get retry threshold exceeded status
	PROTLO	NAKOUT
	BRW	ABORT_CUR		; And abort the request and queue
120$:	CMPB	#EBCEOT,R1		; Is it an EOT
	BNEQ	130$			; BR if not
	PROTLO	ABEOT
	MOVZWL	#XW$M_EOT,R1		; Get EOT status
	BRW	ABORT_CUR		; Abort the IRP and queue
130$:	CMPB	#EBCSTX,R1		; Is it a conversational response
	BNEQ	140$			; Consider it a garbled response
	PROTLO	CON_RESP
	MOVZWL	#XW$M_CONACK,R1		; Get conversational response status
	; Toggle ACKs here ?
	BRW	COMP_GOOD_AB		; Complete the request with status
140$:	PROTLO	GARBLED_RESP
	BRB	170$			; Go to garbled response processing
;
; Response timout processing- send an ENQ to see what happened
;
150$:	BSBW	TMO_RESET		; Reset the transmitter
	PROTLO	TMO_XMT_TXTBLK
160$:	BSBW	TMO_RESET		; Reset the device and go to fork
	BBC	#UCB$V_CANCEL,UCB$W_STS(R5),170$ ;If user cancel get out now
	BRW	CANCEL_CUR		; Gancet the IRP
170$:	BBSS	#UCB$V_XW_REP,-		; Is this a new rep state
		UCB$W_DEVSTS(R5),180$
	MOVB	UCB$B_ERTMAX(R5),-	; Reset the retry count
		UCB$B_ERTCNT(R5)
180$:	DECB	UCB$B_ERTCNT(R5)	; Retry error ?
	BGTR	190$			; BR if not
	MOVZWL	#XW$M_DATACK,R1		; Get a threshold exceeded
	PROTLO	REPOUT
	BRW	ABORT_CUR		; Complete the request
190$:	MOVZBL	#EBCENQ,R1		; Get retry protocol
	PROTLO	REP_SENT
	BITW	#DUP_CSR_M_DSR,(R4)	; Is DSR up
	BNEQ	195$			; Br if not
	PROTLO	DSR_LOST
	BRW	ABORT_NO_DSR		; Get out
195$:	BSBW	XMT_START_PRO1		; Start up a protocol transmission
	WFIKPCH	200$,#3			; And wait for it to complete
	IOFORK				; Create a fork process
	BRW	GET_RESPONSE		; Join common response processing
					;  with rep flag set
200$:	BSBW	TMO_RESET		; Stop the device
	PROTLO	SEN_RES_TIMOUT
	BRW	GET_RESPONSE		; Try again
	.DSABL	LSB

	.PAGE
;
; Complete the request succesfully
;
	.ENABL	LSB
COMP_GOOD_TGL:
	MOVW	IRP$W_ABCNT(R3),IRP$W_BCNT(R3) ; Set the origional user size
	BBCS	#UCB$V_XW_AK1,-
		UCB$W_DEVSTS(R5),10$	; Toggel the ack switch
	BICL	#UCB$M_XW_AK1,UCB$W_DEVSTS(R5)
10$:
COMP_GOOD:
	CLRL	R1			; No device dependant status
COMP_GOOD_AB:
	MOVW	IRP$W_BCNT(R3),R0	; Set the transfer size in status
	ASHL	#16,R0,R0		; Move it to the high byte
	MOVW	#SS$_NORMAL,R0		; Get success code
COMPLETE:
20$:	CLRW	IRP$W_ABCNT(R3)		; Clean up unused field
	BBC	#IRP$V_DIAGBUF,IRP$W_STS(R3),25$ ; Is a diagnostic buffer here
	MOVQ	R0,-(SP)		; Save the completion status
	JSB	G^IOC$DIAGBUFILL	; Fill the diagnostic buffer if any
	MOVQ	(SP)+,R0		; Get the status back
25$:	REQCOM				; Complete the request

CANCEL_CUR:
	CLRL	R1			; No device dependant status
	MOVZWL	#SS$_CANCEL,R0		; Get cancel status
	BRB	30$			; And complete the request

ABORT_CUR:
	BISW	#UCB$M_XW_PIPE,UCB$W_DEVSTS(R5) ; set pipeline marker
	MOVZWL	#SS$_ABORT,R0		; Get aborted status (device dependant
					;  status is already set
30$:
BAD_COMP:	CLRW	IRP$W_BCNT(R3)		; Zero byte count
	BRB	20$			; Complete the request
	.DSABL	LSB
	.PAGE
;
; Start a full duplex diagnostic read/write
;
XMT_INI_DIAG:
	MOVZWL	IRP$W_BCNT(R3),R0	; Get the receive count
	ADDL2	R0,UCB$L_SVAPTE(R5)	; Point to transmit buffer
	MOVW	IRP$W_ABCNT(R3),UCB$W_BCNT(R5) ; Set xmt. buffer count
	MOVW	R0,UCB$B_SLAVE(R5)	; Set receive count
	MOVL	@IRP$L_SVAPTE(R3),-	; Set receive buffer pointer
		UCB$L_XW_SPBF(R5)
; UCB$L_SVAPTE = transmit buffer pointer
; UCB$W_BCNT = transmit buffer count
; UCB$L_XW_SPBF = receive buffer pointer
; UCB$B_SLAVE = receive buffer count
	MOVB	#TSTA$CTS,UCB$B_XW_TISTA(R5) ;set transmit int. state
	MOVB	#RST$DIAG,UCB$B_XW_RISTA(R5) ; Set receive state
	MOVZBL	#4,UCB$L_XW_SYCNT(R5)	; Set the sync count
	DSBINT				; Disable interrupts
	MOVZBL	UCB$L_DEVDEPEND+2(R5),R0 ; Get the sync character
	ADDW3	#DUP_CSR_M_BYM!DUP_CSR_M_CRI,- ; Set up the param. csr
		R0,DUP_CSR_PARM(R4)
	BICW	#DUP_CSR_M_REN,(R4)	; Force a resync
	BISW	#DUP_CSR_M_SSY!DUP_CSR_M_REN!- ; Set RTS,REN,SSY,RIE
		DUP_CSR_M_RIE!DUP_CSR_M_RTS,(R4)
	BISW	#DUP_CSR_M_TIE!DUP_CSR_M_SND,- ; Set TIE and SEND
		DUP_CSR_TXCSR(R4)
	MOVW	#DUP_CSR_M_SOM!PAD,-	; Set start of message and a PAD
		DUP_CSR_TXDBF(R4)
	BBC	#IO$V_MAINTLOOP,-	; Is it a internal loop
		IRP$W_FUNC(R3),2$
	BISW	#DUP_CSR_M_STM,-	; Set the system test mode bit
		DUP_CSR_TXCSR(R4)
2$:	BBC	#IO$V_NOCTSWAIT,-	; Is the no CTS wait state requested
		IRP$W_FUNC(R3),5$
	MOVB	#TSTA$DIAG,UCB$B_XW_TISTA(R5) ; Set the no CTS wait state
5$:	BBC	#IO$V_INTCLOCK,-	; Is this a internal clock test
		IRP$W_FUNC(R3),10$
	BISW	#DUP_CSR_M_ETM,DUP_CSR_TXCSR(R4) ; Yes turn it on
10$:	WFIKPCH	30$,#2			; Wait for request to finish
	DSBINT
15$:	WFIKPCH	40$,#2			; Wait for receiver to finish
	IOFORK				; Go to fork level
	PUSHAL	COMPLETE		; Set up a normal cpmpletion
	MOVZWL	#SS$_NORMAL,R0		; Get normal status
20$:	SUBW3	UCB$B_SLAVE(R5),-	; Get the receive size
		IRP$W_BCNT(R3),R1
	MOVW	R1,IRP$W_BCNT(R3)	; Fake transfer size
	ASHL	#16,R1,R1		; Put it in the high byte
	SUBW3	UCB$W_BCNT(R5),-	; Get the transmit count
		IRP$W_ABCNT(R3),R1
	BISW	#IRP$M_FUNC,IRP$W_STS(R3) ; Set read for completion code
	RSB				; Join the common completion code

30$:	BBS	#UCB$V_CANCEL,UCB$W_STS(R5),50$ ; Is a cancel requested
	DSBINT
	BRB	10$			; NO keep waiting
40$:	BBS	#UCB$V_CANCEL,UCB$W_STS(R5),50$ ; Is a cancel requested
	DSBINT
	BRB	15$

50$:	BSBW	TMO_RESET
	MOVZWL	#SS$_CANCEL,R0		; Get cancel status
	PUSHAL	BAD_COMP		; and complete the request
	BRB	20$			; In the common code
	.PAGE
;
; Transmit startup utility
;
XMT_START_PRO1:
	.ENABL	LSB
	MOVW	#1,UCB$W_BCNT(R5)	; Set the transfer count at one
	BRB	10$			; Now load the buffer with the message
XMT_START_PRO2:
	MOVW	#2,UCB$W_BCNT(R5)	; Set the transfer count at two
10$:	MOVL	R1,UCB$L_XW_SPBF(R5)	; Load the buffer with the protocol mes.
	MOVAL	UCB$L_XW_SPBF(R5),-	; Set the protocol buffer pointer
		UCB$L_SVAPTE(R5)
XMT_START:
	MOVB	#TSTA$CTS,UCB$B_XW_TISTA(R5) ; Set the starting state to CTS
	MOVZBL	#8,UCB$L_XW_SYCNT(R5)	; set the sync count
	BISW	#DUP_CSR_M_RTS,(R4)	; Set request to send
	MOVL	(SP)+,R0		; Save the return
	DSBINT				; Disable interrupts
	MOVL	R0,-(SP)		; Put the return back
	MOVW	#DUP_CSR_M_CRI!DUP_CSR_M_BYM,-
		DUP_CSR_PARM(R4)
	BISW	#DUP_CSR_M_TIE!DUP_CSR_M_HDX!DUP_CSR_M_SND,- ; Turn on interrupt
		DUP_CSR_TXCSR(R4)
	MOVW	#DUP_CSR_M_SOM!PAD,DUP_CSR_TXDBF(R4) ; Set SOM and PAD
	; Is the TSOM and SEND order inportant ?
	RSB				;Return from subroutine
	.DSABL	LSB
;
;Receive startup utility
;
RCV_START_PRO:
	MOVB	#RST$FIRST,UCB$B_XW_RISTA(R5) ; Set starting receive state
	MOVAL	UCB$L_XW_SPBF(R5),UCB$L_SVAPTE(R5) ; Set the protocol buffer
	MOVW	#2,UCB$W_BCNT(R5)	; Set the protocol response
RCV_START:
	MOVZBL	UCB$L_DEVDEPEND+2(R5),R0 ; Set the SYN character in R0
	ADDW3	#DUP_CSR_M_BYM!DUP_CSR_M_CRI,- ; Set SYN char. and no crc
		R0,DUP_CSR_PARM(R4)
	BICW	#DUP_CSR_M_REN,(R4)	; Force a resync
	MOVL	(SP)+,R0		; Save the return
	DSBINT				; Disable interrupts

	MOVL	R0,-(SP)		; Put the return back
	BISW	#DUP_CSR_M_SSY!DUP_CSR_M_REN!DUP_CSR_M_RIE,(R4) ; Start the rcv.
	RSB				; Return to caller
	.PAGE
	.SBTTL	Block Checking
;+
;
; Remove all control characters, check all CRCs, and compact the data into
; the same buffer.
;
;
; input
;	R0- count from R1 to end of buffer
;	R1- pointer to byte after STX
;
; output
;	R0, R1- destroyed
;	control is passed to either the NAK or ACK routine after checking
;
; Register conventions
;	R6-ITB pointer
;	R7-count pointer
;	R8-ITB count
;	R9- pointer to beginning of raw data
;	R10-count to CRC
;
;
;-
	DLE_STX_CRC=^X18C		; DLE, STX string CRC
	STX_CRC=^XC181			; Partial CRC for STX

BLK_CHECK:
	.ENABL	LSB
	PUSHR	#^m<R3,R4,R5,R6,R7,R9,R10>
	MOVL	R1,R9			; Save the input pointer
	MOVL	@IRP$L_SVAPTE(R3),R7	; Get the output pointer
	MOVL	UCB$L_XW_ITBPTR(R5),R6	; Get the ITB table base
	ADDL	#7*4,R6			; Point to tne first ITB
	ADDL3	R0,R1,-(SP)		; Point to end of block
	CLRL	-(SP)			; No partial CRC
	MOVL	(R6),R10		; Are there any internal CRC
	BNEQ	20$			; BR if there are
	MOVAW	-(R9),@IRP$L_SVAPTE(R3) ; Fake the system buffer pointer
	SUBW3	#3,R0,(R9)+		; Set count for user
	MOVL	R0,R10			; Set up the count
5$:	CRC	POLY_TABLE,(SP),R10,(R9) ; DO the CRC on the whole block
	BNEQ	BAD_CRC			; BR if not zero
	MOVW	#-1,-3(R3)		; Store the sentenal
	SUBL3	#1,R3,R0		; Point to end of block
	BRW	GOOD_TEXT		; Send a ACk
10$:	MOVL	-(R6),R10		; Get count to end of CRC
	BNEQ	20$			; Not end so branch
	SUBL3	R9,4(SP),R10		; Get the remaining count
	SUBW3	#3,R10,(R7)+		; Set the last count
	MOVC	R10,(R9),(R7)		; Move the last record
	MOVL	R7,R9			; Fake the last CRC
	BRB	5$			; Do the last CRC
20$:	SUBL	R9,R10			; Get count to next ITB CRC
30$:	CRC	POLY_TABLE,(SP),R10,(R9) ; Do the partial CRC
	BNEQ	BAD_CRC			; BR if bad CRC
	SUBW3	#3,R10,(R7)+		; store the count in the buffer
	MOVC	R10,(R9),(R7)		; And compact the data
	SUBL3	#3,R3,R7		; Point to next count
	SUBL3	R1,4(SP),R10		; Get the count remaining
	SKPC	#EBCSYN,R10,(R1)	; Skip the SYN
	BEQL	BAD_CRC			; BR if bad CRC
	MOVL	#DLE_STX_CRC,(SP)	; start the next CRC
	CMPW	#EBCDLE!<EBCSTX*256>,(R1)+ ; The DLE STX are in the CRC
	BEQL	40$			; BR if  here
	CLRL	(SP)			; Set no partial CRC
	TSTW	-(R1)			; Back up
	CMPB	#EBCSTX,(R1)		; Dies the next record start with STX
	BNEQ	40$			; Br if not
	MOVZWL	#STX_CRC,(SP)		; Get the STX partial crc
	INCL	R1			; Remove the STX
40$:	MOVL	R1,R9			; Set the new from pointer
	BRB	10$			; Get next record
BAD_CRC:
	ADDL	#2*4,SP			; Pop the CRC and end
	POPR	#^M<R3,R4,R5,R6,R7,R9,R10>
	BISL	#UCB$M_XW_NAK,-	; Mark a NAK sent
		UCB$W_DEVSTS(R5)
	PROTLO	NAK_SENT
	BSBW	SEND_RESP		; Set up and start the NAK
	WFIKPCH	REC_SNAK_TMO,#4
	IOFORK				; Create a fork process
	BRW	SND_REC_REQ		; Restart the receive buffer
GOOD_TEXT:
	ADDL	#2*4,SP			; Pop the CRC and end
	POPR	#^M<R3,R4,R5,R6,R7,R9,R10>
	SUBL	@IRP$L_SVAPTE(R3),R0	; Get buffer size
	CMPW	R0,IRP$W_ABCNT(R3)	; Is the users buffer large enough
	BLSS	55$			; Br if it is
	MOVZWL	#SS$_TOOMUCHDATA,R0	; Get a error message for the user
	BRW	BAD_COMP		; And return the buffer with a fatal err
55$:	MOVW	R0,IRP$W_BCNT(R3)	; Set the transfer size for the iocomp.
	BBCS	#UCB$V_XW_AK1,-		; Toggel the ACK switch
		UCB$W_DEVSTS(R5),60$	; ...
	BICL	#UCB$M_XW_AK1,UCB$W_DEVSTS(R5) ;...
60$:	BICL	#UCB$M_XW_NAK,-		; Reset NAK sent last switch
		UCB$W_DEVSTS(R5)
	BBC	#UCB$V_CANCEL,UCB$W_STS(R5),70$ ; If canceled the higher
					;  levels will want to send an EOT
					;  Rather than this ACK
	BRW	CANCEL_CUR		; Return this packet cancled
70$:	BSBW	SEND_RESP		; Set up the correct response
	WFIKPCH	REC_GACK_TMO,#4		; And wait for it to be sent
	IOFORK				; Create a fork process
REC_DONE:
	MOVL	IRP$L_MEDIA+4(R3),R1	; Get the dev. dep. status
	BRW	COMP_GOOD_AB		; Complete the request

	.DSABL	LSB
	.page
	.SBTTL	DUP_11 Receive Interrupt Processing
;+
;XW_RINT - DUP-11 RECEIVE INTERRUPT PROCESSING
;
; THIS ROUTINE IS ENTERED VIA A JSB INSTRUCTION WHEN AN INTERRUPT OCCURS ON A
; DUP-11 LINE INTERFACE. THE STATE OF THE STACK ON ENTRY IS:
;
;	00(SP) = ADDRESS OF IDB ADDRESS.
;	04(SP) = SAVED R3.
;	08(SP) = SAVED R4.
;	12(SP) = SAVED R5.
;	16(SP) = INTERRUPT PC.
;	20(SP) = INTERRUPT PSL.
;
; Interrupt dispatching occurs according to received data.
;
;-
XW_RINT::
	.ENABL	LSB
	MOVL	@(SP)+,R3		; Get the IDB pointer
	MOVQ	IDB$L_CSR(R3),R4	; Set CSR and UCB pointer
	MOVZBL	DUP_CSR_RDBF(R4),R0	; Get the received byte
	CASE	UCB$B_XW_RISTA(R5),-	; Vector the interrupt
		TYPE=B,-		; Byte data type
		<RST_IDLE,-		; Idle state
		RST_BINARY,-		; Binary reception
		RST_FIRST,-		; First character state
		RST_NTTX,-		; Nontransparent text
		RST_STOP1,-		; First byte of last CRC
		RST_STOP,-		; Store last byte and complete request
		RST_ITB,-		; Store internal CRC
		RST_ITB1,-		; Store last byte of internal CRC
		RST_XPRTEXT,-		; Transparent text
		RST_DLE,-		; transparent DLE processing
		RST_XPRITB,-		; Transparent internal CRC
		RST_XPRITB1,-		; Second byte of internal CRC
		RST_DIAG,-		; Diagnostic function
		RST_LOOP_TEST,-		; Slave loop diagnostic function
		>

;
; Second byte of internal CRC state
;
RST_XPRITB1:
	MOVB	#RST$XPRTEXT,UCB$B_XW_RISTA(R5) ;Go back to transparent text
	BRB	100$			; Go to common internal CRC code
;
; Store the second internal CRC
;
RST_ITB1:
	MOVB	#RST$NTTX,UCB$B_XW_RISTA(R5) ; Go back to text state
;
; Internal CRC processing
;
100$:	MOVB	R0,@UCB$L_SVAPTE(R5)	; Store the last CRC byte
	INCL	UCB$L_SVAPTE(R5)	; Step pointer
	DECW	UCB$W_BCNT(R5)		; And reduce count
	BLEQ	50$			; The end of the buffer!!
	MOVZBL	UCB$B_XW_ITBCNT(R5),R0	; Get the index
	MOVL	UCB$L_SVAPTE(R5),-	; Save the pointer
		@UCB$L_XW_ITBPTR(R5)[R0]
	DECB	R0			; One less CRC
	BLEQ	50$			; More than 8 ??
	MOVB	R0,UCB$B_XW_ITBCNT(R5)	; Save the new count
	BRB	25$			; get out

;
; First character state
;
RST_FIRST:
	BICW	#DUP_CSR_M_SSY,(R4)	; Reset strip sync
	MOVB	#RST$NTTX,UCB$B_XW_RISTA(R5) ; Assume non-transparent text
	CMPB	#EBCDLE,R0		; Is it non-transparent
	BNEQ	RST_NTTX		; Process it if not
	MOVB	#RST$XPRTEXT,UCB$B_XW_RISTA(R5) ; Set state to transparent text
	BRB	RIDONE			; Clean up stack and exit

30$:	CMPB	#EBCITB,R0		; Will an internal CRC be next
	BNEQ	35$			; BR if not
	MOVB	#RST$ITB,UCB$B_XW_RISTA(R5) ; Set state to store CRC
	BRB	RIDONE			; Complete interrupt
35$:	CMPB	#EBCSYN,R0		; Is it a SYN in text
	BEQL	25$			; If it is BR and ignore it
	CMPB	#EBCENQ,R0		; Is it a forward abort
	BEQL	RST_STOP		; Complete the block now if it is
	MOVB	#RST$STOP1,UCB$B_XW_RISTA(R5) ; Set state to get last CRC
	BRB	RIDONE			; Complete the interrupt
;
; First byte of last CRC state
;
RST_STOP1:
	MOVB	#RST$STOP,UCB$B_XW_RISTA(R5) ; Set state for stop after next
	BRB	RIDONE			; Complete the interrupt
;
; End of buffer state
;
RST_STOP:
	MOVB	R0,@UCB$L_SVAPTE(R5)	; Store it in the buffer
	INCL	UCB$L_SVAPTE(R5)	; Step the buffer pointer
	DECW	UCB$W_BCNT(R5)		; Include the byte in the count
50$:	MOVB	#RST$IDLE,UCB$B_XW_RISTA(R5) ; Set state to idle
	BICW	#DUP_CSR_M_RIE!DUP_CSR_M_REN,(R4) ; Turn interrupts off
	MOVL	UCB$L_FR3(R5),R3	; Restore the fork R3
	MOVW	(R4),UCB$W_XW_LSTCSR(R5) ; Save the ending CSR
	JSB	@UCB$L_FPC(R5)		; Call back in line to complete request
	BRW	25$			; Clean up and exit the interrupt

;
; Non-transparent text state
;
RST_NTTX:
	BBS	R0,CCHRMASK,30$		; BR if a control char.
RIDONE:
	MOVB	R0,@UCB$L_SVAPTE(R5)	; Store it in the buffer
	INCL	UCB$L_SVAPTE(R5)	; Step the buffer pointer
	DECW	UCB$W_BCNT(R5)		; Include the byte in the count
24$:
	BLEQ	50$			; BR if the buffer is full
RST_IDLE:
25$:	MOVQ	(SP)+,R0		; Restore R0-1
	MOVQ	(SP)+,R2		; Restore R2-3
	MOVQ	(SP)+,R4		; Restore R4-5
	REI				; Return from interrupt
;
; Store the first internal CRC character
;
RST_ITB:
	MOVB	#RST$ITB1,UCB$B_XW_RISTA(R5) ; Set state to store second CRC
	BRB	RIDONE			; Complete the interrupt
;
; Transparent text state- if DLE is found drop it and go to DLE state
;
RST_XPRTEXT:
	CMPB	#EBCDLE,R0		; Is it a DLE
	BNEQ	RIDONE			; If not continue
	MOVB	#RST$DLE,UCB$B_XW_RISTA(R5) ; Set state to DLE
	BRB	RIDONE			; Complete the interrupt
;
; Transparent character after a DLE
;
RST_DLE:
	CMPB	#EBCITB,R0		; Is it an internal CRC
	BNEQ	40$			; Check sone more
	MOVB	#RST$XPRITB,UCB$B_XW_RISTA(R5) ; Set transparent ITB state
42$:	DECL	UCB$L_SVAPTE(R5)	; Remove the DLE
	INCW	UCB$W_BCNT(R5)		; ...
	BRB	RIDONE			; Exit the interrupt
40$:	CMPB	#EBCSYN,R0		; Is it a SYN in text
	BNEQ	45$			; BR if not
	MOVB	#RST$XPRTEXT,UCB$B_XW_RISTA(R5) ; Set state to text
	DECL	UCB$L_SVAPTE(R5)	; Remove the DLE also
	INCW	UCB$W_BCNT(R5)		; ...
	BRB	25$			; And exit the interrupt
45$:	BBS	R0,CCHRMASK,47$		; If it is a cont. cha. strip the DLE
	MOVB	#RST$XPRTEXT,UCB$B_XW_RISTA(R5) ;Go back to transparent text
	CMPB	#EBCDLE,R0		; Is it a DLE in text
	BEQL	25$			; If so dump it
	BRB	RIDONE			; get out
47$:	MOVB	#RST$STOP1,UCB$B_XW_RISTA(R5) ; Set state to stop after CRC
	BRB	42$			; Complete the interrupt
;
; Transparent ITB state
;
RST_XPRITB:
	MOVB	#RST$XPRITB1,UCB$B_XW_RISTA(R5) ; Go to second byte of CRC
	BRB	RIDONE			; Complete the interrupt
RST_BINARY:
	BICW	#DUP_CSR_M_SSY,(R4)	; Reset strip sync
	BRW	RIDONE

;
; Diagnostic interrupt service
;
RST_DIAG:
	BICW	#DUP_CSR_M_SSY,(R4)	; Drop strip sync
	MOVB	R0,@UCB$L_XW_SPBF(R5)	; Store the received byte
	INCL	UCB$L_XW_SPBF(R5)	; Step the pointer
	DECW	UCB$B_SLAVE(R5)		; Reduce the count
	BRW	24$
;
; Diagnostic slave loop function- receive until the first PAD
;
RST_LOOP_TEST:
	CMPB	#PAD,R0			; Is it a pad ?
	BNEQ	RST_BINARY		; If not handle it like binary
	BRW	50$			; If it is the message is done
	.DSABL	LSB

	.PAGE
	.SBTTL	DUP-11 Transmit Interrupt Processing
;+
; XW_TINIT - DUP-11 TRANSMIT PROCESSING
;
; THIS ROUTINE IS ENTERED VIA A JSB INSTRUCTION WHEN AN INTERRUPT OCCURS ON A
; DUP-11 LINE INTERFACE. THE STATE OF THE STACK ON ENTRY IS:
;
;	00(SP) = ADDRESS OF IDB ADDRESS.
;	04(SP) = SAVED R3.
;	08(SP) = SAVED R4.
;	12(SP) = SAVED R5.
;	16(SP) = INTERRUPT PC.
;	20(SP) = INTERRUPT PSL.
;
; INTERRUPT DISPATCHING OCCURS BASED ON TRANSMIT STATE
;
;-
XW_TINT::
	MOVL	@(SP)+,R3		; Get the IDB pointer
	MOVQ	IDB$L_CSR(R3),R4	; And the UDP csr and the UCB
	CASE	UCB$B_XW_TISTA(R5),-	; And vector the interrupt
		TYPE=B,-
		<IPRO_IDLE,-		; No interrupt expected
		IPRO_CTS,-		; Wait for clear to send
		IPRO_SYN,-		; synch state
		IPRO_TEXT,-		; Text state
		IPRO_ENDPAD,-		; Last pad state
		IPRO_DIAG,-		; Diagnostic (no CTS wait state)
		>

IPRO_CTS:
	BITW	#DUP_CSR_M_CTS,(R4)
	BNEQ	10$
	MOVB	#PAD,DUP_CSR_TXDBF(R4)	; send a pad and wait for CTS
	BRB	IDONE			; Go exit the interrupt
10$:
IPRO_DIAG:
	MOVB	#TSTA$SYN,UCB$B_XW_TISTA(R5) ; Set state to send synch
IPRO_SYN:
	MOVB	UCB$L_DEVDEPEND+2(R5),DUP_CSR_TXDBF(R4) ; send a synch
	SOBGTR	UCB$L_XW_SYCNT(R5),IDONE ; Dec SYN count
	MOVB	#TSTA$TEXT,UCB$B_XW_TISTA(R5) ; set state to text
	BRB	IDONE			; Exit this interrupt
	.ENABL	LSB
IPRO_TEXT:
	DECW	UCB$W_BCNT(R5)		; Reduce the byte count
	BLSS	10$			; Change to trailing pad state
	MOVB	@UCB$L_SVAPTE(R5),-	; Send the next byte
		DUP_CSR_TXDBF(R4)
	INCL	UCB$L_SVAPTE(R5)	; Step the pointer to next byte
IPRO_IDLE:
IDONE:	MOVQ	(SP)+,R0		; Restore saved regesters
	MOVQ	(SP)+,R2		; ...
	MOVQ	(SP)+,R4		; ...
	REI				; Return from the interrupt

10$:	MOVB	#TSTA$ENDPAD,UCB$B_XW_TISTA(R5) ; Set trailing pad state
	MOVB	#PAD,DUP_CSR_TXDBF(R4)	; Send the trailing pad
	INCW	UCB$W_BCNT(R5)		; Fix the count
	BRB	IDONE			; Exit the interrupt
	.DSABL	LSB
IPRO_ENDPAD:
	MOVW	(R4),UCB$W_XW_LSTCSR(R5) ; Save the last CSR
	CLRW	DUP_CSR_TXDBF(R4)
	BICW	#DUP_CSR_M_TIE!DUP_CSR_M_SND,- ; Turn off interrupt enable
		DUP_CSR_TXCSR(R4)
	BBS	#XW$V_CHA_FDX,UCB$L_DEVDEPEND(R5),10$ ; Is this line HDX
	BICW	#DUP_CSR_M_RTS,(R4)	; Drop request to send
10$:	MOVB	#TSTA$IDLE,UCB$B_XW_TISTA(R5) ; Set state to idle
	MOVL	UCB$L_FR3(R5),R3	;Get the fork R3
	JSB	@UCB$L_FPC(R5)		; Pass control back to where IO was strt
	BRB	IDONE			; Exit the interrupt
	.page
	.SBTTL	REGDUMP Dump the errors and device CSRs
;+
;	Move the accumulated errors and CSR 0 into an error log buffer
; or a diagnostic buffer.
;
; input
;	R0- buffer pointer
;	R5- UCB pointer
;	R4- CSR pointer
;
; output
;	@R0 is filled with:
;		# long words filled
;		last (or current) fatal error
;		CSR 0
;		accumulated errors (see UCB definition)
;
;-
REGDUMP:
	PUSHR	#^M<R1,R2>
	ADDL3	#UCB$B_XW_ERRORS,R5,R1	; Get a pointer to the first error
	MOVL	#NO_ERRORS+1,R2		; Get the number of error fields
	MOVL	#<NO_ERRORS+3>,(R0)+ ; Store no. long words
	MOVZBL	(R1)+,(R0)+		; Store the last error logged
	MOVZWL	UCB$W_XW_LSTCSR(R5),(R0)+ ; Store the CSR
10$:	MOVZBL	(R1)+,(R0)+		; Store a long word
	SOBGTR	R2,10$			; BR if not done
	MOVL	#-1,(R0)+		; Put in sentinal
	POPR	#^M<R1,R2>
	RSB

	.SBTTL	ERR_RECORD Save an error in the UCB
;+
; The error is recorded in the appropriate UCB field, if it
; is fatal the error logger is called.
;
; input
;	R5- UCB
;	R4- Device CSR
;	4(SP)- error
;	(SP)- return
;
; output
;	The UCB is updated and the error is logged if fatal
;
;
ERR_RECORD:
	MOVL	R0,-(SP)		; Save a reg.
	ASHL	#-1,2*4(SP),R0		; Get the error number
	MOVB	R0,UCB$B_XW_ERRORS(R5)	; Save the last error
	INCB	UCB$B_XW_ERRORS+1(R5)[R0] ; Step the error cell
	BNEQ	5$			; Dont pass 0
	DECB	UCB$B_XW_ERRORS+1(R5)[R0] ; ...
5$:	BLBC	2*4(SP),10$		; Is this a fatal error
	JSB	G^ERL$DEVICERR		; Yes call the error logger
10$:	MOVL	(SP)+,R0		; Restore R0
	MOVL	(SP)+,(SP)		; Remove the error
	RSB
	.PAGE
	.SBTTL	CANCEL I/O ON CHANNEL
;+
; XW_CANCELIO - CANCEL I/O ON CHANNEL
;
; THIS ROUTINE IS CALLED WHEN THE LAST CHANNEL ASSIGNED TO A DEVICE IS DEASSIGNED,
; THE DEVICE IS DEALLOCATED, AND WHEN THE CANCEL I/O ON CHANNEL SYSTEM SERVICE IS
; EXECUTED.
;
; INPUTS:
;
;	R2 = NEGATIVE CHANNEL NUMBER.
;	R3 = ADDRESS OF CURRENT I/O REQUEST PACKET.
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R5 = DEVICE UCB ADDRESS.
;
; OUTPUTS:
;
;	THE DEVICE INDEPENDENT CANCEL I/O ROUTINE IS CALLED.
;
;-

XW_CANCELIO:
	JMP	G^IOC$CANCELIO
	.PAGE
	.SBTTL	DUP-11 Unit Initalization
;+
; XW_INIT - DUP-11 LINE INTERFACE UNIT INITIALIZATION
;
; THIS ROUTINE IS CALLED AT SYSTEM STARTUP AND AFTER A POWER FAILURE. THE
; ONLINE BIT IS SET IN THE DEVICE UCB.
;
; INPUTS:
;
;	R5 = ADDRESS OF DEVICE UCB.
;
; OUTPUTS:
;
;	THE ONLINE BIT IS SET IN THE DEVICE UCB AND THE ADDRESS OF THE UCB
;	IS FILLED INTO THE OWNER FIELD OF THE IDB.
;-
 
XW_INIT:
	BISW	#UCB$M_ONLINE,UCB$W_STS(R5) ; Mark unit on line
	MOVL	UCB$L_CRB(R5),R0	; Get the CRB pointer
	MOVL	CRB$L_INTD+VEC$L_IDB(R0),R0 ; Get the IDB pointer
	MOVL	R5,IDB$L_OWNER(R0)	; Store the UCB pointer
	RSB

	.PAGE
	.SBTTL	Control character table
CCHRMASK:
	.LONG	^B10000000000000000000000000001000	;ETX,ENQ
	.LONG	^B00000000100001000010000001000000	; EOT, SYN, ETB
	.LONG	^B00000000000000000000000000000000	;
	.LONG	^B00000000000000000000000000000000	;
	.LONG	^B00000000000000000000000000000000	;
	.LONG	^B00000000000000000000000000000000	;
	.LONG	^B00000000000000000000000000000000	;
	.LONG	^B00000000000000000000000000000000	;
	.SBTTL	CRC16 Polynomial Table
POLY_TABLE:
	.LONG	0
	.LONG	52225
	.LONG	55297
	.LONG	5120
	.LONG	61441
	.LONG	15360
	.LONG	10240
	.LONG	58369
	.LONG	40961
	.LONG	27648
	.LONG	30720
	.LONG	46081
	.LONG	20480
	.LONG	39937
	.LONG	34817
	.LONG	17408

XW_END:
	.END
