	.TITLE TSDRIVER - VAX/VMS TS11/TS04 MAGTAPE SUBSYSTEM DRIVER
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

; E. E. OUYANG 2-APR-79
;
; MODIFIED BY:
;	V02-013	RLRAVAIL	Robert L. Rappaport		28-Dec-1981
;		Added support for IO$_AVAILABLE function which is in effect
;		a REWIND (NOWAIT) that also clears the UCB$M_VALID bit in
;		UCB$W_STS.
;
;	V02-012	RLREOV		Robert L. Rappaport		3-Sep-1981
;		Corrected END OF VOLUME recognition in space file operation.
;
;	V02-011	RLRCLEAN	Robert L. Rappaport		19-Aug-1981
;		Eliminated CLEAN operation from error retry logic for
;		READ, WRITE and WRITE TAPEMARK operations.
;
;	V02-010	RLR0006		Robert L. Rappaport		28-May-1981
;		Corrected bug that used Buffered Data Path for Reread
;		Previous Opposite commands.  Fix implies use of Direct
;		Data Path for all Reread Previous commands (big deal).
;
;	V02-009	RLR0005		Robert L. Rappaport		13-Feb-1981
;		Prevent logging errors when only problem is SS$_MEDOFL.
;
;	V02-008	RLR0004		Robert L. Rappaport		8-Oct-1980
;		Initialize UCB$L_MS_TIMEOUT to 20 seconds in HCEX.
;		This corrects bug introduced in V02-006.
;
;	V02-007	RLR0003		Robert L. Rappaport		30-Sept-1980
;		Increase timeout for rewind.
;
;	V02-006	RLR0002		Robert L. Rappaport		19-August-1980
;		Check to see whether NBA (Need Buffer Address) set at
;		STARTIO time and if necessary do a WRITE CHARACTERISTICS to
;		refresh the buffer address before attempting the I/O function.
;		Also increase timeout value for spacing operations.
;
;	V02-005	RLR0001		Robert L. Rappaport		17-April-1980
;		Corrected a bug that a) Logged an error on DATAOVERUN and
;		also b) Failed to return the length of the record on tape,
;		in the case of DATAOVERUN, in the high order word of the
;		first longword of the I/O status block.  Also corrected a
;		bug that sometimes put an incorrect Previous Map Pointer
;		in the error log.
;
;
; TS11/TS04 MAGTAPE DRIVER
;
; MACRO LIBRARY CALLS
;

	$CRBDEF				;DEFINE CRB OFFSETS
	$DDBDEF				;DEFINE DDB OFFSETS
	$DPTDEF				;DEFINE DPT OFFSETS
	$EMBDEF				;DEFINE EMB OFFSETS
	$IDBDEF				;DEFINE IDB OFFSETS
	$IODEF				;DEFINE I/O FUNCTION CODES
	$IRPDEF				;DEFINE IRP OFFSETS
	$MTDEF				;DEFINE MAGTAPE STATUS BITS
	$SSDEF				;DEFINE QIO STATUS RETURN CODES
	$UCBDEF				;DEFINE UCB OFFSETS
	$VECDEF				;DEFINE INTERRUPT DISPATCH VECTOR OFFSETS
	$WCBDEF				;DEFINE WCB OFFSETS

;
; LOCAL MACROS
;
; EXECUTE HARDWARE COMMAND AND BRANCH ON RETRIABLE ERROR CONDITION
;

	.MACRO	EXHC	BDST,HC
		.IF NB	HC
		MOVZBL	#CD'HC,R0	;GET HARDWARE COMMAND INDEX
		.ENDC
		BSBW	HCEX		;CALL HARDWARE COMMAND EXECUTION ROUTINE
		.WORD	BDST-.-2	;BRANCH ADDR. ON ERROR CONDITION
	.ENDM	EXHC

; MACRO TO CALL G^IOC$LOADUBAMAPA

	.MACRO	LOADUBAA
	JSB	G^IOC$LOADUBAMAPA
	.ENDM	LOADUBAA


;
; GENERATE HARDWARE COMMAND TABLE ENTRY AND CASE TABLE INDEX SYMBOL
;

	.MACRO	GENHC	HC
		CD'HC=<.-HCTAB>/2	;DEFINE TABLE INDEX SYMBOL
		.WORD	HC		;HARDWARE COMMAND TABLE ENTRY
	.ENDM	GENHC


;
; LOCAL SYMBOLS
;
;
; TS11/TS04 COMMAND PACKET DEFINITION
;
;

	$DEFINI MS


.=0					;RESET PC??????
$DEF	MS_CPHD	.BLKW	1		;COMMAND PACKET HEADER
	_VIELD	MS_CPHD,0,<-		;
		<COD,5>,-		;COMMAND CODE FIELD
		<,2>,-			;B5-B6 ALWAYS 0 FOR TS04
		<IE,,M>,-		;INTERRUPT ENABLE
		<MOD,4>,-		;COMMAND MODE FIELD(B11-B8)
			-		; B8=REVERSE & B9=RETRY
		<SWB,,M>,-		;SWAP BYTES BIT(B12)
		<OPP,,M>,-		;OPPOSITE BIT(B13)
		<CVC,,M>,-		;CLEAR VOLUME CHECK(B14)
		<ACK,,M>,-		;ACKNOWLEDGE BIT(B15)
	>
$DEF	MS_BACT	.BLKW 	1		;BUS ADDRESS(B15-B0) OR COUNT
$DEF	MS_BA1	.BLKW	1		;BUS ADDRESS B17-B16(RIGHT JUST)
$DEF	MS_CNT	.BLKW	1		;BYTE COUNT
					;FOR WRITE CHARACTERISTIC DATA
$DEF	MS_MBA0	.BLKW	1		;MESSAGE BUFFER ADDR. WRD 1
$DEF	MS_MBA1	.BLKW	1		;MESSAGE BUFFER ADDR. WRD 2
$DEF	MS_LNTH	.BLKW 	1		;MESSAGE BUFFER LENGTH(ALWAYS 14.)
$DEF	MS_CHWD	.BLKW	1		;CHARACTERISTIC WORD
	_VIELD	MS_CHWD,4,<-		;
		<ERI,,M>,-		;ENABLE MESSAGE BUFFER RELEASE INTERRUPTS
		<EAI,,M>,-		;ENABLE ATTENTION INTERRUPTS
		<ENB,,M>,-		;USED WITH ESS BIT***
		<ESS,,M>,-		;ENABLE SKIP TAPE MARKS STOP
	>

;
; TS11/TS04 MESSAGE PACKET DEFINITION
;


$DEF	MS_MHD	.BLKW	1		;MESSAGE PACKET
	_VIELD	MS_MHD,0,<-		;MESSAGE HEADER WORD
		<COD,5>,-		;MESSAGE CODE FIELD
		<FMT,3>,-		;FORMAT FIELD
		<CLS,4>,-		;CLASS CODE FIELD
		<RSR,3>,-		;RESERVED FIELD
		<ACK,,M>,-		;MESSAGE ACKNOWLEDGE BIT(B15)
	>				;
$DEF	MS_LNH	.BLKW	1		;MESSAGE LENGTH WORD
					;HIGH BYTE=0,LOW BYTE=1010(LENGTH)
$DEF	MS_RBPC	.BLKW	1		;RESIDUAL BYTE/POSITION COUNT
$DEF	MS_XSR0	.BLKW	1		;EXTENDED STATUS REGISTER 0
	_VIELD	MS_XSR0,0,<-		;
		<EOT,,M>,-		;END OF TAPE DETECTED(B0)
		<BOT,,M>,-		;BEGINNING OF TAPE(B1)
		<WLK,,M>,-		;WRITE LOCKED(B2)
		<PED,,M>,-		;PHASE ENCODED DRIVE(B3)
		<VCK,,M>,-		;VOLUME CHECK(B4)
		<IE,,M>,-		;INTERRUPT WAS ENABLED(B5)
		<ONL,,M>,-		;DEVICE ON-LINE(B6)
		<MOT,,M>,-		;TAPE MOVING ON LAST COMMAND(B7)
		<ILA,,M>,-		;ILLEGAL ADDRESS(B8)
		<ILC,,M>,-		;ILLEGAL COMMAND(B9)
		<NEF,,M>,-		;NON-EXECUTALBE FUNCTION(B10)
		<WLE,,M>,-		;WRITE LOCK ERROR(B11)
		<RLL,,M>,-		;RECORD LENGTH LONG(B12)
		<LET,,M>,-		;LOGICAL END OF TAPE(B13)
		<RLS,,M>,-		;RECORD LENGTH SHORT(B14)
		<TMK,,M>,-		;TAPE MARK DETECTED(B15)
	>				;
$DEF	MS_XSR1	.BLKW	1		;EXTENDED STATUS REGISTER 1
	_VIELD	MS_XSR1,0,<-		;
		<MTE,,M>,-		;(PE) MULTI-TRACK ERROR
			-		;(NRZ) VERTICAL PARITY ERROR
		<UNC,,M>,-		;(PE) UNCORRECTABLE DATA ERROR(B1)
			-		;(NRZ) CYCLIC REDUNDANCY CHECK ERROR
		<POL,,M>,-		;(PE) POSTAMBLE LONG(B2)
			-		;(NRZ) LONGITUDINAL REDUNDANCY CHECK ERROR
		<POS,,M>,-		;(PE) POSTAMBLE SHORT(B3)
			-		;(NRZ) NOISE RECORD
		<IED,,M>,-		;(PE) INVALID END DATA(B4)
			-		;(NRZ) LRC WAS 0.
		<IPO,,M>,-		;(PE) INVALID POSTAMBLE(B5)
			-		;(NRZ) ILLEGAL TAPE MARK
		<SYN,,M>,-		;(PE) SYNCH ERROR(B6)
			-		;(NRZ) FRAME DROPOUT
		<IPR,,M>,-		;(PE) INVALID PREAMBLE(B7)
		<,1>,-			;RESERVED BIT
		<SCK,,M>,-		;SPEED CHECK(B9)
		<DBF,,M>,-		;(PE) DESKEW BUFFER FAIL(B10)
			-		;(NRZ) NRZ BOARD FIFO OVERFLOW
		<TIG,,M>,-		;TRASH IN GAP(B11)
		<CRS,,M>,-		;CREASE DETECTED(B12)
		<COR,,M>,-		;CORRCTABLE DATA(B13)
		<,1>,-			;UNUSED BIT(B14)
		<DLT,,M>,-		;DATA LATE(B15)
	>
$DEF	MS_XSR2	.BLKW	1		;EXTENDED STATUS REGISTER 2
	_VIELD	MS_XSR2,0,<-		;
		<DTP,8>,-		;DEAD TRACK PARITY,B7-B0
		<XSK,,M>,-		;EXCESSIVE SKEW(B9)
		<WCF,,M>,-		;WRITE CLOCK FAIL(B10),BROKEN HARDWARE
		<,1>,-			;B11 NOT USED
		<CAF,,M>,-		;CAPSTAN ACCELERATION FAIL(B12)
		<BPE,,M>,-		;SERIAL BUS PARITY ERROR AT DRIVE(B13)
		<SIP,,M>,-		;SILO PARITY ERROR(B14)
		<OPM,,M>,-		;OPERATION IN PROGRESS(B15)
	>
$DEF	MS_XSR3	.BLKW	1		;EXTENDED STATUS REGISER 3
	_VIELD	MS_XSR3,0,<-		;
		<RIB,,M>,-		;REVERSE INTO BOT(B0)
		<LXS,,M>,-		;LIMIT EXCEEDED STATICALLY(B1)
		<NOI,,M>,-		;NOISE RECORD(B2)
		<DCK,,M>,-		;DENSITY CHECK(B3)
		<CRF,,M>,-		;CAPSTAN RESPONSE FAIL(B4)
		<REV,,M>,-		;TAPE MOVED BACKWARDS(B5)
		<OPI,,M>,-		;OPERATION IN COMPLETE(B6)
		<LMX,,M>,-		;TAPE LIMIT EXCEEDED(B7)
		<FEC,8>,-		;B15-B8, FATAL ERROR CODE(U-DIAGNOSTIC)
	>

	$DEFEND	MS

;
; TS11/TS04 TSSR TERMINATION CLASS CODES
;

TCC_NML=0				;NORAML TERMINATION
TCC_ATN=1				;ATTENTION CONDITION
TCC_TSA=2				;TAPE STATUS ALERT
TCC_FNR=3				;FUNCTION REJECT
TCC_REM=4				;RECOVERABLE ERROR(TAPE MOVED)
TCC_REN=5				;RECOVERABLE ERROR(TAPE NOT MOVED)
TCC_UER=6				;UNRECOVERABLE ERROR(TAPE POSI. LOST)
TCC_FTL=7				;FATAL CONTROLLER ERROR

;
; FATAL CLASS (FC) CODES IN TSSR
;

FCC_IDF=0				;INTERNAL DIAG. FAILURE
FCC_CPE=1				;IO SEQUENCE CROM PARITY ERROR
FCC_UPE=2				;U-PROCESSOR CROM PARITY ERROR OR OTHER
FCC_LAP=3				;LOSS OF AC POWER DETECTED

;
; TS11/TS04 MESSAGE CODES IN MS_MHD_COD
;

MSG_END=^O020				;END
MSG_FAL=^O021				;FAIL
MSG_ERR=^O022				;ERROR
MSG_ATN=^O023				;ATTENTION
MSG_LOG=^O024				;LOG (NOT USED)

;
; CLASS CODE FOR MESSAGE CODES (MS_MHD_CLS VALUES)
;

				;**WHEN MSG TYPE=ATTENTION**
CLS_ONF=0				;ON OR OFFLINE
CLS_MDF=1				;MICRO DIAG. FAILURE
				;**WHEN MSG TYPE=FAIL**
CLS_PTB=0				;PACKET BAD(SERIAL BUS PARITY ERROR)
CLS_OTHER=1				;OTHERS
CLS_WLN=2				;WRITE LOCK ERROR OR NON-EXECUTABLE FUNCTION
CLS_MDE=3				;MICRO DIAGNOSTIC ERROR

;
; TS11/TS04 HARDWARE COMMAND MODES/CODES
;

					; INTERRUPT ENABLE & ACKNOWLEDGE
HC_NOP=0			;SIMULATED NOP(REAL NO OPERATION)
HC_PAK=HC_NOP				;SIMULATED PACK ACKNOWLEDGE
HC_WCK=HC_NOP				;SIMULATED WRITE CHECK
HC_WKR=HC_NOP				;SIMULATED WRITE CHECK REVERSE
HC_RPS=HC_NOP				;SIMULATED READ IN PRESET
HC_SCH=HC_NOP				;SIMULATED SET CHARACTERISTICS


HC_RDN=^O0001!MS_CPHD_M_IE!MS_CPHD_M_CVC!MS_CPHD_M_ACK	;* READ NEXT (FORWARD)
HC_RDP=^O0401!MS_CPHD_M_IE!MS_CPHD_M_CVC!MS_CPHD_M_ACK	;* READ PREVIOUS (REVERSE)
HC_RRP=^O1001!MS_CPHD_M_IE!MS_CPHD_M_CVC!MS_CPHD_M_ACK	;* REREAD PREVIOUS (SPACE REV,READ FWD)
HC_RRN=^O1401!MS_CPHD_M_IE!MS_CPHD_M_CVC!MS_CPHD_M_ACK	;* REREAD NEXT (SPACE FWD, READ REV)
HC_WRC=^O0004!MS_CPHD_M_IE!MS_CPHD_M_CVC!MS_CPHD_M_ACK	;+ WRITE CHARACTERISTICS
HC_WRD=^O0005!MS_CPHD_M_IE!MS_CPHD_M_CVC!MS_CPHD_M_ACK	;* WRITE DAT
HC_WDR=^O1005!MS_CPHD_M_IE!MS_CPHD_M_CVC!MS_CPHD_M_ACK	;* WRITE DATA RETRY (SPACE REV, ERASE, 
					; WRITE DATA)
HC_WSM=^O0006!MS_CPHD_M_IE!MS_CPHD_M_CVC!MS_CPHD_M_ACK	;* WRITE SUBSYSTEM MEMORY
HC_SRF=^O0010!MS_CPHD_M_IE!MS_CPHD_M_CVC!MS_CPHD_M_ACK	;$ SPACE RECORDS FORWARD
HC_SRR=^O0410!MS_CPHD_M_IE!MS_CPHD_M_CVC!MS_CPHD_M_ACK	;$ SPACE RECORDS REVERSE
;HC_STF=^O1010!MS_CPHD_M_IE!MS_CPHD_M_CVC!MS_CPHD_M_ACK	;$ SKIP TAPE MARKS FORWARD
;HC_STR=^O1410!MS_CPHD_M_IE!MS_CPHD_M_CVC!MS_CPHD_M_ACK	;$ SKIP TAPE MARKS REVERSE
 ;**NOTE** SKIP TAPE MARK COMMANDS ARE SIMULATED BY SKIP RECORD COMMANDS***
HC_STF=^O0010!MS_CPHD_M_IE!MS_CPHD_M_CVC!MS_CPHD_M_ACK	;$ SPACE TAPE MARK FORWARD
HC_STR=^O0410!MS_CPHD_M_IE!MS_CPHD_M_CVC!MS_CPHD_M_ACK	;$ SPACE TAPE MARKS REVERSE
HC_RWD=^O2010!MS_CPHD_M_IE!MS_CPHD_M_CVC!MS_CPHD_M_ACK	;$ REWIND
HC_WTM=^O0011!MS_CPHD_M_IE!MS_CPHD_M_CVC!MS_CPHD_M_ACK	;- WRITE TAPE MARK
HC_ERS=^O0411!MS_CPHD_M_IE!MS_CPHD_M_CVC!MS_CPHD_M_ACK	;- ERASE
HC_WTR=^O1011!MS_CPHD_M_IE!MS_CPHD_M_CVC!MS_CPHD_M_ACK	;- WRITE TAPE MARK RETRY (SPACE REV,
					; ERASE, WRTIE TAPE MARK)
HC_BRL=^O0012!MS_CPHD_M_IE!MS_CPHD_M_CVC!MS_CPHD_M_ACK	;- MESSAGE BUFFER RELEASE
HC_UNL=^O0412!MS_CPHD_M_IE!MS_CPHD_M_CVC!MS_CPHD_M_ACK	;- REWIND AND UNLOAD
HC_CLN=^O1012!MS_CPHD_M_IE!MS_CPHD_M_CVC!MS_CPHD_M_ACK	;- CLEAN
HC_DRI=^O0013!MS_CPHD_M_IE!MS_CPHD_M_CVC!MS_CPHD_M_ACK	;- DRIVER INITIALIZE
HC_GST=^O0017!MS_CPHD_M_IE!MS_CPHD_M_CVC!MS_CPHD_M_ACK	;- GET STATUS IMMEDIATE
				;**NOTE**
				; * => DATA XFR
				; + => (SPECIAL)
				; $ => POSITION
				; - => FORMAT,CONTROL,INITIALIZE,& STATUS

;
; DEFINE DEVICE DEPENDENT UNIT CONTROL BLOCK OFFSETS
;

	$DEFINI	UCB,GLOBAL		;

	$VIELD	UCB,0,<-		;DEV. DEP. STATUS BITS IN UCB$W_DEVSTS
		<MS_FEF,,M>,-		;TAPE IS PAST ONE TAPE MARK
		<MS_SWAP,,M>,-		;*SWAP BYTES FOR COMPATIBILITY MODE
		<MS_IWR,,M>,-		;*INHIBIT WRITE RETRIES
		<MS_SER,,M>,-		;SELECT ERROR HAS OCCURRED????
		<MS_RWD,,M>,-		;UNIT IS REWINDING
		<MS_RDPR,,M>,-		;REQUEST DATAPATH FLAG
		<MS_SWE,,M>,-		;DOING SOFTWARE EMULATION 
		<MS_NER,,M>,-		;NO ERROR RECOVERY
		<MS_UMD,,M>,-		;USER MODE DIAGNOSTIC REQUEST
		<MS_RSP,,M>,-		;REWIND/SPACE IN PROGRESS
		<MS_LBA,,M>,-		;LOADING BUFFER ADDR. INTO TS04
		<MS_RPI,,M>,-		;RPOSITIONING IN PROGRESS
		<MS_VCK,,M>,-		;VOLUME CHECK
		<MS_RIP,,M>,-		;RETRY IN PROGRESS FLAG
	>

		;** STATUS BITS DEFINED ELSWHERE***
		;** IN UCB$L_DEVDEPEND:
		;**	MT$M_PARITY=1, IF EVEN;0, IF ODD
		;**	MT$V_FORMAT=MT$K_DEFAULT/NORMAL11/CORDMP11/NORMAL15
		;**	MT$V_DENSITY=MT$K_PE_1600/MT$K_NRZI-800
		;**	MT$M_BOT=TAPE IS AT BOT
		;**	MT$M_EOF=TAPE AT EOF
		;**	MT$M_EOT=TAPE AT EOT
		;**	MT$M_HWL=HARDWARE WRITE LOCKED
		;**	MT$M_LOST=TAPE POSITION LOST
		;** IN UCB$W_STS:
		;**	UCB$M_TIM=TIMEOUT ENABLED
		;**	UCB$M_INT=INTERRUPT EXPECTED
		;**	UCB$M_ERLOGIP=ERRORLOG IN PROGRESS
		;**	UCB$M_CANCEL=CANCEL I/O
		;**	UCB$M_ONLINE=UNIT ONLINE
		;**	UCB$M_POWER=POWER FAILED WHILE UNIT BUSY
		;**	UCB$M_TIMOUT=UNIT TIME OUT
		;**	UCB$M_INTTYPE=RECEIVER INTERRUPT,IF SET
		;**	UCB$M_BSY=UNIT IS BUSY
		;**	UCB$M_MOUNTING=DEVICE IS BEING MOUNTED
		;**	UCB$M_DEADMO=DEALLOCATE AT DISMOUNT
		;**	UCB$M_VALID=VOLUME IS SOFTWARE VALID
		;**	UCB$M_UNLOAD=UNLOAD VOLUME AT DISMOUNT
		;** IN UCB$L_DEVCHAR:
		;** .......
		;**	DEV$M_SWL=SOFTWARE WRITE LOCKED
		;** .......
;
; NEW EXTENSION TO UCB FOR TS11/TS04
;

.=UCB$L_DPC+4				;**AS IN TMDRIVER**RESET PC
$DEF	UCB$W_MS_SPACNT	.BLKW	1	;SPACING COUNT
$DEF	UCB$L_MS_TSPT1	.BLKL	1	;PTR. TO TS04 BUFFER IN 
					;NON-PAGED POOL
$DEF	UCB$L_MS_TSPT2	.BLKL	1	;CORRESPONDING UNIBUS ADDR.
$DEF	UCB$W_MS_TSPT3	.BLKW	1	;COMMAND PTR FOR TS11/TS04
$DEF	UCB$W_MS_TSBA	.BLKW	1	;TS11/TS04 DEVICE REGISTER(TSBA)
$DEF	UCB$W_MS_TSSR	.BLKW	1	;TS11/TS04 DEVICE REGISTER(TSSR)
	_VIELD	MS_TSSR,1,<-		;TS11/TS04 STATUS REGISTER(B0 UNUSED)
		<TCC,3>,-		;TERMINATION CLASS CODE FIELD
		<FC,2>,-		;FATAL ERROR CLASS CODE FIELD
		<OFL,,M>,-		;DEVICE IS OFF-LINE(B6) 
		<SSR,,M>,-		;SUBSYSTEM READY(B7)
		<A16,,M>,-		;BUFFER ADDRESS BIT 16
		<A17,,M>,-		;BUFFER ADDRESS BIT 17
		<NBA,,M>,-		;NEED BUFFER ADDRESS(B10)
		<NXM,,M>,-		;NON-EXISTENT MEMORY(B11)
		<RMR,,M>,-		;REGISTER MODIFICATION REFUSED(B12)
		<SPE,,M>,-		;SERIAL BUS PARITY ERROR(B13)
		<UPE,,M>,-		;UNIBUS PARITY ERROR(B14)
		<SC,,M>,-		;SPECIAL CONDITION(B15)
	>				;
			;**FATAL ERROR CONDITION: UPE!SPE!NXM!NBA
$DEF	UCB$L_MS_RECORD	.BLKL	1	;CURRENT RECORD+TMK COUNT(AFTER BOT)
					;**MAX. NO. OF RCORDS+TMKS=2**32.
					;ABOVE COUNT DETERMINE TAPE POSITION
					; 0 WHEN AT BOT
$DEF	UCB$W_MS_XC	.BLKW	1	;BYTES XFERRED OR RECORDS/FILES SKIPPED
$DEF	UCB$B_MS_DPN	.BLKB	1	;DATA PATH NUMBER
$DEF	UCB$B_MS_PER	.BLKB	1	;PURGE ERROR IF BIT 0 SET
$DEF	UCB$L_MS_DPR	.BLKL	1	;DATA PATH REGISTER USED
$DEF	UCB$L_MS_FMPR	.BLKL	1	;FINAL MAP REGISTER
$DEF	UCB$L_MS_PMPR	.BLKL	1	;FINAL-1(PREVIOUS) MAP REGISTER
				;**NOTE**LAST 1 LONGWORD IS USED DURING
				;****POWERFAIL REPOSITIONING
$DEF	UCB$L_MS_NMPR	.BLKL	1	;FINAL+1(NEXT) MAP REGISTER
$DEF	UCB$L_MS_OMPR	.BLKL	1	;COPY OF VEC$W_MAPREG(LONGWORD IN CRB)
$DEF	UCB$L_MS_TIMOUT	.BLKL	1	; Timout value for function in progress
$DEF	UCB$Q_MS_TMP1	.BLKQ	1	;TEMP FOR UCB$W_BCNT,BOFF, and SVAPTE
$DEF	UCB$L_MS_TMP2	.BLKL	1	;TEMP. FOR CRB$L_INTD+VEC$W_MAPREG
$DEF	UCB$Q_MS_BUFSVAPTE		;AREA TO SAVE PARAMETERS TO MAP MESSAGE
			.BLKQ	1	; BUFFER IN UNIBUS SPACE
$DEF	UCB$L_MS_TPOSITN .BLKL	1	;TAPE POSITION AT POWERFAIL
$DEF	UCB$W_MS_MHD	.BLKW	1	;MESSAGE PACKET**COPY IN UCB**
$DEF	UCB$W_MS_LNH	.BLKW	1	;MESSAGE LENGTH WORD
$DEF	UCB$W_MS_RBPC	.BLKW	1	;RESIDUAL BYTE/POSITOIN COUNT
$DEF	UCB$W_MS_XSR0	.BLKW	1	;EXTENDED STATUS REGISTER 0
$DEF	UCB$W_MS_XSR1	.BLKW	1	;EXTENDED STATUS REGISTER 1
$DEF	UCB$W_MS_XSR2	.BLKW	1	;EXTENDED STATUS REGISTER 2
$DEF	UCB$W_MS_XSR3	.BLKW	1	;EXTENDED STATUS REGISTER 3
UCB$K_MS_LENGTH=.
	$DEFEND UCB


.PAGE
.SBTTL	DRIVER TABLES

;
; DRIVER PROLOGUE TABLE
;

	DPTAB	-			;DEFINE DRIVER PROLOGUE TABLE
		END=TS_END,-		;END OF DRIVER
		ADAPTER=UBA,-		;UNIBUS ADAPTER
		UCBSIZE=UCB$K_MS_LENGTH,-
		NAME=TSDRIVER		;DRIVER NAME
	DPT_STORE INIT			;CONTROL BLOCK INIT VALUE
	DPT_STORE DDB,DDB$L_ACPD,L,<^A\MTA\> ;DEFAULT ACP NAME
	DPT_STORE UCB,UCB$B_FIPL,B,8	;FORK IPL
	DPT_STORE UCB,UCB$L_DEVCHAR,L,-	;DEVICE CHARACTERISTICS
		<DEV$M_FOD-		; FILES ORIENTED
		!DEV$M_DIR-		; DIRECTORY STRUCTURED
		!DEV$M_AVL-		; AVAILABLE
		!DEV$M_ELG-		; ERROR LOGGING ENABLED
		!DEV$M_IDV-		; INPUT DEVICE
		!DEV$M_ODV-		; OUTPUT DEVICE
		!DEV$M_SDI-		; SINGLE DIRECTORY DEVICE
		!DEV$M_SQD>		; SEQUENTIAL DEVICE
	DPT_STORE UCB,UCB$B_DEVCLASS,B,DC$_TAPE ;DEVICE CLASS
	DPT_STORE UCB,UCB$B_DEVTYPE,B,DT$_TS11	;DEVICE TYPE
	DPT_STORE UCB,UCB$W_DEVBUFSIZ,W,2048 ;DEFAULT BUFFER SIZE
	DPT_STORE UCB,UCB$L_DEVDEPEND,W,<^X4C0> ;DEFAULT TAPE PARAMETERS
					; FORMAT=NORMAL11,DENSITY=1600BPI
	DPT_STORE UCB,UCB$B_DIPL,B,21	;DEVICE IPL
	DPT_STORE UCB,UCB$B_ERTCNT,B,16	;ERROR RETRY COUNT
	DPT_STORE UCB,UCB$B_ERTMAX,B,16	;MAX ERROR RETRY COUNT
	DPT_STORE REINIT		;CONTROL BLOCK RE-INIT VALUES
	DPT_STORE CRB,CRB$L_INTD+4,D,TS$INT ;INTERRUPT SERVICE ROUTINE ADDR.
	DPT_STORE CRB,CRB$L_INTD+VEC$L_UNITINIT,D,TS_INIT ;UNIT INIT
	DPT_STORE DDB,DDB$L_DDT,D,MS$DDT ;DDT ADDRESS
	DPT_STORE END			;
	.MDELETE DPT_STORE

;
; DRIVER DISPATCH TABLE
;

	DDTAB	MS,-			;(MS=GENERIC NAME)DRIVER DISPATCH TABLE
		TS_STARTIO,-		;START I/O OPERATION
		0,-			;UNSOLICITED INTERRUPT
		TS_FUNCTABLE,-		;FUNCTION DECISION TABLE
		+IOC$CANCELIO,-		;CANCEL I/O ENTRY POINT(STANDARD)
		TS_REGDUMP,-		;REGISTER DUMP ROUTINE
		<8+4+<1+23>*4>,-		;DIAG. BUFFER SIZE
		<<1+23>*4+EMB$L_DV_REGSAV> ;ERROR BUFFER SIZE

;
; HARDWARE COMMAND TABLE - MODES/CODES
;

HCTAB:
	GENHC	HC_NOP			;SIMULATED NOP
	GENHC	HC_UNL			;REWIND & UNLOAD
	GENHC	HC_STF			;SKIP TAPE MARK FORWARD(SPACE FILE)
	GENHC	HC_RWD			;REWIND
	GENHC	HC_DRI			;DRIVE INITIALIZE(DRIVE CLEAR)
	GENHC	HC_STR			;SKIP TAPE MARK REVERSE
	GENHC	HC_ERS			;ERASE
	GENHC	HC_SRR			;SKIP RECORD REVERSE
	GENHC	HC_PAK			;SIMULATED PACK ACKNOWLEDGE
	GENHC	HC_SRF			;SKIP RECORD FORWARD
	GENHC	HC_WCK			;SIMULATED WRITECHECK
	GENHC	HC_WRD			;WRITE DATA(WRITEPBLK)
	GENHC	HC_RDN			;READ DATA NEXT(READPBLK)
	GENHC	HC_WKR			;SIMULATED WRITECHECK REV.
	GENHC	HC_WRD			;WRITE DATA(NO WRITEPBLK REV.)
	GENHC	HC_RDP			;READ DATA PREVIOUS
	GENHC	HC_RRN			;REREAD DATA NEXT
	GENHC	HC_RRP			;REREAD DATA PREVIOUS
	GENHC	HC_WDR			;WRITE DATA RETRY
	GENHC	HC_RPS			;SIMULATED READ PRESET
	GENHC	HC_SCH			;SIMULATED SET CHARACTERISTIC
	GENHC	HC_GST			;GET STATUS IMMEDIATE
	GENHC	HC_WTM			;WRITE TAPE MARK
	GENHC	HC_WTR			;WRITE TAPE MARK RETRY
	GENHC	HC_CLN			;CLEAN
	GENHC	HC_BRL			;MESSAGE BUFFER RELEASE
	GENHC	HC_WSM			;WRITE SUBSYSTEM MEMORY
	GENHC	HC_WRC			;WRITE CHARACTERISTIC


.PAGE
;+

; TS11/TS04 FUNCTION DECISION TABLE
;-

TS_FUNCTABLE:				;FUNCTION DECISION TABLE
	FUNCTAB	,-			;LEGAL FUNCTIONS
		<NOP,-			;NO OPERATION
		 UNLOAD,-		;UNLOAD VOLUME
		 SPACERECORD,-		;SPACE RECORDS
		 RECAL,-		;RECALIBRATE (REWIND)
		 DRVCLR,-		;DRIVER CLEAR
		 READPRESET,-		;READ IN PRESET
		 PACKACK,-		;PACK ACKNOWLEDGE
		 ERASETAPE,-		;ERASE TAPE
		 SENSECHAR,-		;SENSE TAPE CHARACTERISTICS
		 SETCHAR,-		;SET CHARACTERISTICS
		 SPACEFILE,-		;SPACE FILE
		 WRITECHECK,-		;WRITE CHECK FORWARD
		 WRITEPBLK,-		;WRITE PHYSICAL BLOCK
		 WRITERET,-		;**NEW**WRITE PHYSICAL BLOCK RETRY
		 READPBLK,-		;READ PHYSICAL BLOCK
		 REREADN,-		;**NEW**REREAD NEXT
		 REREADP,-		;**NEW**REREAD PREVIOUS
		 AVAILABLE,-		;AVAILABLE (REWIND/NOWAIT CLEAR VALID)
		 WRITEMARK,-		;WRITE TAPE MARK
		 WRTTMKR,-		;**NEW**WRITE TAPE MARK RETRY
		 CLEAN,-		;**NEW**CLEAN TAPE
		 READLBLK,-		;READ LOGICAL BLOCK
		 WRITELBLK,-		;WRITE LOGICAL BLOCK
		 SENSEMODE,-		;SENSE TAPE MODE
		 SETMODE,-		;SET MODE
		 REWIND,-		;REWIND
		 REWINDOFF,-		;REWIND AND SET OFFLINE
		 SKIPRECORD,-		;SKIP RECORDS
		 SKIPFILE,-		;SKIP FILES
		 WRITEOF,-		;WRITE END OF FILE
		 READVBLK,-		;READ VIRTUAL BLOCK
		 WRITEVBLK,-		;WRITE VIRTUAL BLOCK
		 ACCESS,-		;ACCESS FILE AND/OR FIND DIRECTORY
		 ACPCONTROL,-		;ACP CONNTROL FUNCTION
		 CREATE,-		;CREATE FILE AND/OR CREATE DIRECTORY
		 DEACCESS,-		;DEACCESS FILE
		 DELETE,-		;DELETE FILE AND/OR DIRECTORY ENTRY
		 MODIFY,-		;MODIFY FILE ATTRIBUTES
		 MOUNT>			;MOUNT VOLUME
	FUNCTAB,-			;BUFFERED I/O FUNCTIONS
		<NOP,-			;NO OPERATION
		 UNLOAD,-		;UNLOAD VOLUME
		 SPACERECORD,-		;SPACE RECORDS
		 RECAL,-		;RECALIBRATE (REWIND)
		 DRVCLR,-		;DRIVE CLEAR
		 READPRESET,-		;READ PRESET
		 PACKACK,-		;PACK ACKNOWLEDGE
		 ERASETAPE,-		;ERASE TAPE
		 SENSECHAR,-		;SENSE CHARACTERISTICS
		 SETCHAR,-		;SET CHARACTERISTICS
		 SPACEFILE,-		;SPACE FILES
		 WRITEMARK,-		;WRITE TAPE MARK
		 WRTTMKR,-		;**NEW**WRITE TAPE MARK RETRY
		 CLEAN,-		;**NEW**CLEAN TAPE
		 SENSEMODE,-		;SENSE MODE
		 SETMODE,-		;SET MODE
		 REWIND,-		;REWIND
		 REWINDOFF,-		;REWIND AND UNLOAD
		 SKIPRECORD,-		;SKIP RECORDS
		 SKIPFILE,-		;SKIP FILES
		 WRITEOF,-		;WRITE END OF FILE
		 ACCESS,-		;ACCESS FILE AND/OR FIND DIRECTORY ENTRY
		 ACPCONTROL,-		;ACP CONTROL FUNCTION
		 CREATE,-		;CREATE FILE AND/OR CREATE DIRECTORY ENTRY
		 DEACCESS,-		;DEACCESS FILE
		 DELETE,-		;DELETE FILE AND/OR DIRECTORY ENTRY
		 MODIFY,-		;MODIFY FILE ATTRIBUTES
		 MOUNT>			;MOUNT VOLUME
	FUNCTAB	+ACP$READBLK,-		;READ FUNCTIONS
		<READLBLK,-		;READ LOGICAL BLOCK FORWARD
		 READPBLK,-		;READ PHYSICAL BLOCK FORWARD
		 REREADN,-		;*NEW*REREAD NEXT
		 REREADP,-		;*NEW*REREAD PREVIOUS
		 READVBLK>		;READ VIRTUAL BLOCK
	FUNCTAB	+ACP$WRITEBLK,-		;WRITE FUNCTIONS
		<WRITECHECK,-		;WRITE CHECK FORWARD
		 WRITELBLK,-		;WRITE LOGICAL BLOCK
		 WRITEPBLK,-		;WRITE PHYSICAL BLOCK
		 WRITERET,-		;*NEW*WRITE RETRY
		 WRITEVBLK>		;WRITE VIRTUAL BLOCK
	FUNCTAB	+ACP$ACCESS,<ACCESS,CREATE> ;ACCESS AND CREATE FILE OR DIRECTORY
	FUNCTAB	+ACP$DEACCESS,<DEACCESS> ;DEACCESS FILE
	FUNCTAB	+ACP$MODIFY,-		;
		<ACPCONTROL,-		;ACP CONTROL FUNCTION
		 DELETE,-		;DELETE FILE OR DIRECTORY ENTRY
		 MODIFY>		;MODIFY FILE ATTRIBUTES
	FUNCTAB	+ACP$MOUNT,<MOUNT>	;MOUNT VOLUME
	FUNCTAB	+MT$CHECK_ACCESS,-	;MAGTAPE CHECK ACCESS FUNCITONS
		<ERASETAPE,-		;ERASE TAPE
		 CLEAN,-		;**NEW**CLEAN TAPE
		 WRITEMARK,-		;WRITE TAPE MARK
		 WRTTMKR,-		;*NEW*WRITE TAPE MARK RETRY
		 WRITEOF>		;WRITE END OF FILE
	FUNCTAB	+EXE$ZEROPARM,-		;ZERO PARAMETER FUNCTIONS
		<NOP,-			;NO OPERATION
		 UNLOAD,-		;UNLOAD VOLUME
		 RECAL,-		;RECALIBRATE (REWIND)
		 REWIND,-		;REWIND
		 REWINDOFF,-		;REWIND AND SET OFFLINE
		 DRVCLR,-		;DRIVE CLEAR
		 READPRESET,-		;READ IN PRESET
		 PACKACK,-		;PACK ACKNOWLEDGE
		 ERASETAPE,-		;ERASE TAPE
		 CLEAN,-		;**NEW**CLEAN TAPE
		 SENSECHAR,-		;SENSE TAPE CHARACTERISTICS
		 SENSEMODE,-		;SENSE TAPE MODE
		 AVAILABLE,-		;AVAILABLE (REWIND/NOWAIT CLEAR VALID)
		 WRITEMARK,-		;WRITE TAPE MARK
		 WRTTMKR,-		;*NEW*WRITE TAPE MARK RETRY
		 WRITEOF>		;WRITE END OF FILE
	FUNCTAB	+EXE$ONEPARM,-		;ONE PARAMETER FUNCTIONS
		<SPACERECORD,-		;SPACE RECORDS
		 SPACEFILE,-		;SPACE FILES
		 SKIPRECORD,-		;SKIP RECORDS
		 SKIPFILE>		;SKIP FILES
	FUNCTAB	+EXE$SETMODE,-		;SET TAPE CHARACTERISTICS
		<SETCHAR,-		;
		SETMODE>		;

.PAGE
.SBTTL	UNIT INITIALIZATION ROUTINE
;+
; THIS ROUTINE IS CALLED WHEN THE DRIVER IS LOADED OR ON POWERFAIL
; RECOVERY.
;
; CALLING SEQUENCE:
;	JSB	TS_INIT
;
; INPUT:
;	R5 = UCB ADDRESS
;	R4 = EQUIVALENT CSR FOR TS11
;
; OUTPUT:
;

TS_INIT:
	BISW	#UCB$M_ONLINE,-		; Always mark TS11 as online since
		UCB$W_STS(R5)		;  interrupts are not normally enabled
					;  we have no method to set it on
					;  dynamically.
	BBC	#UCB$V_POWER,-		; If NOT powerfail, (i.e. SYSTEM INIT)
		UCB$W_STS(R5),50$	;  branch around.

	BITW	#MS_TSSR_M_SSR,2(R4)	;IS TS11 SUBSYSTEM READY?
	BNEQ	50$			;YES
;
;WAS POWERFAIL, AND TS11 NOT READY
;
10$:
	JSB	G^EXE$PWRTIMCHK		;POWERFAIL MAX.TIM EXCEED?
	BLBC	R0,20$			;YES, TS11 NOT READY FOR GOOD
	BITW	#MS_TSSR_M_SSR,2(R4)	;NO, SEE IF TS11 READY NOW
	BNEQ	50$			;YES, GO AHEAD
	BRB	10$			;NO, LOOP BACK
15$:
	BICW	#UCB$M_ONLINE,-		; Only reason for marking TS11 offline
		UCB$W_STS(R5)		;  is lack of pool space for PACKET.
20$:
	RSB				;RETURN
50$:
	MOVL	UCB$L_CRB(R5),R1	;GET POINTER TO CRB
	MOVL	CRB$L_INTD+VEC$W_MAPREG(R1),-
		UCB$L_MS_TMP2(R5)	;SAVE CURRENT UBA MAP CONTEXT.
	MOVL	CRB$L_INTD+VEC$L_IDB(R1),R0 ;GET POINTER TO IDB
	MOVL	R5,IDB$L_OWNER(R0)	;MAKE UCB OWNER OF IDB
	MOVL	#32,R1			;SIZE OF WORK BUFFER FOR TS11(=32.)
	BBC	#UCB$V_POWER,UCB$W_STS(R5),55$ ; BR IF NOT POWER RECOVERY
	MOVL	UCB$L_MS_TSPT1(R5),R2	;GET BUFFER GOTTEN BEFORE
	BRW	60$			;BR POWER RECOVERY

;
; DRIVER LOAD
;

55$:
	PUSHL	G^EXE$GL_NONPAGED	;SAVE NONPAGED IPL
	MFPR	#PR$_IPL,G^EXE$GL_NONPAGED ;USE CURRENT IPL
	JSB	G^EXE$ALONONPAGED	;GET FROM NON-PAGED MEMORY
	POPL	G^EXE$GL_NONPAGED	;RESTORE NONPAGED IPL
	BLBC	R0,15$			; Space not available, goto EXIT.
					;YES, R1=SIZE OF ALLOCATED BLOCK
					; R2 HAS ADDR. OF THE BLOCK
	MOVL	R2,UCB$L_MS_TSPT1(R5)	;STORE ADDR. IN UCB
60$:
	ASSUME	UCB$W_BOFF  EQ  UCB$L_SVAPTE+4
	ASSUME	UCB$W_BCNT  EQ  UCB$W_BOFF+2
	MOVQ	UCB$L_SVAPTE(R5),-
		UCB$Q_MS_TMP1(R5)	;SAVE UCB$L_SVAPTE, W_BCNT, W_BOFF.

	MOVW	R1,UCB$W_BCNT(R5)	;LOAD BYTE COUNT INTO UCB
	BICW3	#^XFE00,R2,UCB$W_BOFF(R5) ;LOAD BYTE OFFSET IN UCB
	EXTZV	S^#VA$V_VPN,S^#VA$S_VPN,R2,R2 ;GET VIRTUAL PAGE #
	MOVL	G^MMG$GL_SPTBASE,R0	;GET ADDR. OF SYS. PAGE TABLE
	MOVAL	(R0)[R2],UCB$L_SVAPTE(R5) ;STORE SVA OF PTE FOR WORK BUFFER
				;LOADED BCNT,BOFF,&SVAPTE FOR WORK BUFFER
				;DIRECT DATA PATH IS USED FOR COMMUNICATION
	MOVL	UCB$L_CRB(R5),R1	; R1 => CRB
	BBC	#UCB$V_POWER,UCB$W_STS(R5),70$ ;BR IF NOT POWERFAIL
	MOVL	UCB$L_MS_OMPR(R5),CRB$L_INTD+VEC$W_MAPREG(R1) ;USE OLD MAP REGISTER
	BRB	80$		;GOTO LOAD MAP REGISTER
70$:
	CLRB	CRB$L_INTD+VEC$B_DATAPATH(R1) ;INSURE DIRECT DATA PATH(=0)
	REQMPR			;ALLOCATE MAP REGISTER(S) TO MAP UNIBUS
	MOVL	UCB$L_CRB(R5),R1	;GET POINTER TO CRB
	MOVL	CRB$L_INTD+VEC$W_MAPREG(R1),UCB$L_MS_OMPR(R5) ;SAVE OLD MAP REGISTER
80$:
	MOVQ	UCB$L_SVAPTE(R5),-	; Save message buffer parameters to
		UCB$Q_MS_BUFSVAPTE(R5)	;  facilitate later remapping.
				;TO SBI ADDRESSES
				; THE NO. OF MAP REGISTER AND STARTING
				; MAP REG. NO. ARE STORED IN CRB
	LOADUBA			;LOAD MAP REG. TO BE USED
;
; CALCULATE UNIBUS ADDR. FOR COMMAND PACKET, STORE IT IN UCB
;
	MOVZWL	UCB$W_BOFF(R5),R0	;GET BYTE OFFSET
	MOVQ	UCB$Q_MS_TMP1(R5),-
		UCB$L_SVAPTE(R5)	;RESTORE SVAPTE, BOFF, BCNT

	MOVL	UCB$L_CRB(R5),R1	;GET CRB
	INSV	CRB$L_INTD+VEC$W_MAPREG(R1),#9,#9,R0 ; HGH 9 BITS
	MOVL	R0,UCB$L_MS_TSPT2(R5)	;STORE IN UCB
	MOVL	UCB$L_MS_TMP2(R5),-
		CRB$L_INTD+VEC$W_MAPREG(R1) ;RESTORE UNIBUS MAPPING CONTEXT
	CLRL	R1			;CLEAR R1
	ASHL	#-2,R0,R0		;MODULO 4,SHIFT OUT 2 0'S
	INSV	R0,#2,#14,R1		;INSERT B2-B15
	ASHL	#-14,R0,R0		;SHIFT OUT B2-B15
	INSV	R0,#0,#2,R1		;INSERT B16-B17
	MOVW	R1,UCB$W_MS_TSPT3(R5)	;STORE COMMAND PTR IN UCB

;
; ISSUE WRITE CHARACTERISTIC COMMAND TO TELL MESSAGE BUFFER ADDR. TO TS11
;
	MOVL	UCB$L_MS_TSPT1(R5),R0	;COMMAND PACKET ADDR. IN R0
	MOVW	#<HC_WRC!MS_CPHD_M_ACK>,MS_CPHD(R0) ;GET COMMAND PACKET HEADER
	MOVL	UCB$L_MS_TSPT2(R5),MS_BACT(R0) ;STORE CHAR. BUFFER ADDR.
	ADDL	#8,MS_BACT(R0)		;POINT TO CHAR. BUFFER NOW
	MOVW	#8,MS_CNT(R0)		;STORE BYTE COUNT FOR CHAR. DATA
	MOVL	UCB$L_MS_TSPT2(R5),MS_MBA0(R0) 	;STORE MESSAGE BUFFER ADDR.
	ADDL	#16,MS_MBA0(R0)		; AS CHAR. DATA
	MOVW	#14,MS_LNTH(R0)		;LENGTH OF CHAR. DATA=14.
	CLRW	MS_CHWD(R0)		;ZERO CHARACTERISTIC WORD
				;**=>NO MESSAGE BUFFER RELEASE INTERRUPT
				;**  ,NO ATTENTION INTERRUPT, AND NO
				;**  SKIP TAPE MARKS STOP
;
; LOAD COMMAND PTR IN DEVICE REGISTER TSDB, UCB
;
	MOVW	UCB$W_MS_TSPT3(R5),(R4)	;LOAD INTO TSDB
	BISW	#UCB$M_MS_LBA,UCB$W_DEVSTS(R5) ;MARK LOADING MESSAGE BUFFER
					; ADDR. INTO TS11.
	RSB				;RETURN

	
.PAGE
	.SBTTL	TEST NBA (NEED BUFFER ADDRESS)

; TEST_NBA - Subroutine called from STARTIO to determine if the TS11 has
;	a valid message buffer.  If YES, then we merely return.  If NOT, we
;	re-establish the message buffer obtained at SYSTEM INIT time.
;
;	This routine assumes that the following UCB fields were initialized
;	at UNIT INIT time:
;
;	UCB$Q_MS_BUFSVAPTE
;	UCB$L_MS_OMPR
;
; INPUTS:
;	R5 => UCB
;
; OUTPUTS:
;	Message buffer established in TS11.
;

TEST_NBA:
	POPL	UCB$L_DPC(R5)		; Pop return off stack in case.
	BICW	#UCB$M_MS_LBA,-		; This bit maybe left on from INIT if
		UCB$W_DEVSTS(R5)	;  setting of switches inside drive so
					;  dictate.  We clear it here because
					;  this is a convenient place.

	MOVL	UCB$L_CRB(R5),R1		; R1 => CRB
	ASSUME	IDB$L_CSR  EQ  0
	MOVL	@CRB$L_INTD+VEC$L_IDB(R1),R4	; R4 => CSR.
	MOVW	2(R4),R0			; R0 contains TSSR register.
	BBS	#MS_TSSR_V_SSR,R0,10$	; Branch to continue if TS11 ready.
	BRW	60$			; Branch to failure if NOT ready.
10$:
	BBS	#MS_TSSR_V_NBA,R0,20$	; Branch around if we NEED to re-
					;  establish message buffer address.
	MOVZBL	S^#SS$_NORMAL,R0	; Else indicate success and
	JMP	@UCB$L_DPC(R5)		;  return to caller.
20$:
	MOVL	CRB$L_INTD+VEC$W_MAPREG(R1),-
		UCB$L_MS_TMP2(R5)	;SAVE CURRENT UBA MAP CONTEXT.
	MOVL	UCB$L_MS_OMPR(R5),-	; Setup to map UNIBUS just in case
		CRB$L_INTD+VEC$W_MAPREG(R1)

	ASSUME	UCB$W_BOFF  EQ  UCB$L_SVAPTE+4
	ASSUME	UCB$W_BCNT  EQ  UCB$W_BOFF+2
	MOVQ	UCB$L_SVAPTE(R5),-
		UCB$Q_MS_TMP1(R5)	;SAVE UCB$L_SVAPTE, W_BCNT, W_BOFF.
	MOVQ	UCB$Q_MS_BUFSVAPTE(R5),-; Restore parameters to remap message
		UCB$L_SVAPTE(R5)	;  buffer in UNIBUS space.

	LOADUBA				; Reload UNIBUS map registers for
					;  message buffer.

;
; ISSUE WRITE CHARACTERISTIC COMMAND TO TELL MESSAGE BUFFER ADDR. TO TS11
;
	MOVL	UCB$L_MS_TSPT1(R5),R0	; R0 => command packet
	MOVW	#<HC_WRC!MS_CPHD_M_ACK>,-
		MS_CPHD(R0)		; Move command (WRITE CHARACTERISTICS)
					;  to 1ST word of command packet.
	MOVL	UCB$L_MS_TSPT2(R5),-	; Store UNIBUS address of packet in
		MS_BACT(R0)		;  packet.
	ADDL	#8,MS_BACT(R0)		; Update to point to CHARACTERISTICS
					;  buffer beyond packet.
	MOVW	#8,MS_CNT(R0)		;Store byte count for char. data
	MOVL	UCB$L_MS_TSPT2(R5),-	; Store UNIBUS address of PACKET
		MS_MBA0(R0)		;  into the CHARACTERISTICS data.
	ADDL	#16,MS_MBA0(R0)		; Message BUFF is 16 beyond packet.

	MOVW	#14,MS_LNTH(R0)		;LENGTH OF CHAR. DATA=14.
	CLRW	MS_CHWD(R0)		;ZERO CHARACTERISTIC WORD
				;**=>NO MESSAGE BUFFER RELEASE INTERRUPT
				;**  ,NO ATTENTION INTERRUPT, AND NO
				;**  SKIP TAPE MARKS STOP
	DSBINT
	BBS	#UCB$V_POWER,UCB$W_STS(R5),30$
	MOVW	UCB$W_MS_TSPT3(R5),(R4)	;LOAD INTO TSDB
	WFIKPCH	40$,#2		; Wait for interrupt.
	IOFORK
	BRB	50$			; Branch around powerfail branch.
30$:	ENBINT
40$:	SETIPL	UCB$B_FIPL(R5)		; Lower IPL in case of TIMEOUT.
	BRB	60$			; Branch if we had POWERFAIL.

50$:
	MOVL	UCB$L_CRB(R5),R1	; R1 => CRB.
	MOVL	UCB$L_MS_TMP2(R5),-	; Restore previous mapping context.
		CRB$L_INTD+VEC$W_MAPREG(R1)
	MOVQ	UCB$Q_MS_TMP1(R5),-	; And also transfer parameters.
		UCB$L_SVAPTE(R5)
	BBS	#MS_TSSR_V_NBA,-	; Test if all that had any effect
		UCB$W_MS_TSSR(R5),60$	;  by seeing if we still have NBA.
	MOVZBL	S^#SS$_NORMAL,R0	; Else indicate success and
	JMP	@UCB$L_DPC(R5)		;  return to caller.
60$:
					;  Terminate the I/O function
	MOVZWL	#SS$_DEVOFFLINE,R0	;  by returning the OFFLINE status and
	JMP	@UCB$L_DPC(R5)		;  return to caller.
	.PAGE
.SBTTL	START I/O OPERATION
;+
; TS_STARTIO - START I/O OPERATION ON DEVICE
;
; THIS ENTRY POINT IS ENTERED TO START AN I/O OPERATION ON TS11/TS04
;
; INPUTS:
;
;	R3 = ADDRESS OF I/O PACKET.
;	R5 = UCB ADDRESS OF DEVICE UNIT
;
; OUTPUT:
;
;	FUNCTION DEPENDENT PARAMETERS ARE STORED INTO THE DEVICE UCB,
;	ERROR RETRY COUNT IS RESET, AND THE FUNCTION IS EXECUTED.  AT
;	FUNCTION COMPLETION THE OPERATION IS TERMINATED THRU REQUEST COMPLETE.
;
;-

TS_STARTIO:					;START I/O OPERATION
	BSBW	TEST_NBA		; Assure that TS11 has valid MESSAGE
					;  BUFFER.
	BLBS	R0,5$			; LBS implies success. GOTO continue.
	BRW	FCNEXT			;  Else branch to terminate function.
5$:
	MOVB	UCB$B_ERTMAX(R5),UCB$B_ERTCNT(R5) ;INITIALIZE ERROR RETRY COUNT
	MOVW	IRP$W_FUNC(R3),UCB$W_FUNC(R5) ;SAVE FUNCTION CODE & MODIFIER
	MOVL	IRP$L_MEDIA(R3),R0	;GET PARAMETER LONGWORD

;
; MOVE FUNCTION DEPENDENT PARAMETERS TO UCB
;

	EXTZV	#IRP$V_FCODE,#IRP$S_FCODE,- ;EXTRACT I/O FUNCTION CODEE
		IRP$W_FUNC(R3),R1	;
	CMPL	#IO$_SPACEFILE,R1	;SPACE FILE FUNCTION?
	BEQL	10$			;IF EQL YES
	CMPL	#IO$_SPACERECORD,R1	;SPACE RECORD FUNCTION?
	BEQL	20$			;IF EQL YES
	CMPL	#IO$_SETCHAR,R1		;SET CHARACTERISTICS FUNCTION?
	BEQL	50$			;IF EQL YES
	CMPL	#IO$_AVAILABLE,R1	;AVAILABLE function?
	BEQL	75$			;IF EQL YES
	CMPL	#IO$_READPBLK+1,R1	;DISJOINT CODE?
	BGTRU	100$			;IF GTRU NO
	CASE	R1,<-			;DISPATCH LOGICAL FUNCTIONS
		70$,-			;REWIND AND SET OFFLINE
		60$,-			;SET MODE
		80$,-			;REWIND
		10$,-			;SKIP FILE
		20$,-			;SKIP RECORD
		90$,-			;SENSE TAPE MODE
		90$,-			;WRITE EOF
		>,LIMIT=#IO$_REWINDOFF	;
	SUBW	#IO$_READPRESET-IO$_READPBLK-7,R1 ;CONVERT TO DENSE FUNCTION CODE
	BRB	110$			;**LAST LINE NEED BE ADJUSTED

;
; SPACE FILE FUNCTION - SET SPACE COUNT AND PROPER FUNCTION
;

10$:	MOVZWL	#CDHC_STF,R1		;SET SPACE FILE FORWARD
	TSTW	R0			;SPACE FILE FORWARD?
	BGTR	40$			;IF GTR YES
	MOVZBL	#CDHC_STR,R1		;SET FOR SPACE FILE REVERSE
	BRB	30$			;

;
; SPACE RECORD FUNCTION - SET SPACE COUNT AND PROPER HARDWARE COMMAND
;

20$:	MOVZBL	#CDHC_SRF,R1		;SET FOR SPACE RECORD FORWARD
	TSTW	R0			;SPACE RECORD FORWARD?
	BGTR	40$			;IF GTR YES
	MOVZBL	#CDHC_SRR,R1		;SET FOR SPACE RECORD REVERSE
30$:	MNEGW	R0,R0			;CONVERT TO POSITIVE COUNT
40$:	MOVW	R0,UCB$W_MS_SPACNT(R5)	;SET SPACE COUNT
	BNEQ	110$			;IF NEQ SPACING REQUIRED
	MOVZBL	#CDHC_NOP,R1		;SET FOR NO OPERATION
	BRB	110$			;


;
; SET CHARACTERISTICS FUNCTION - STORE NEW TAPE CHARACTERISTICS
;
;****TS11/TS04 HAS ONLY ONE CLASS AND TYPE****

50$:	MOVW	IRP$L_MEDIA(R3),UCB$B_DEVCLASS(R5) ;SET NEW DEVICE CLASS AND TYPE

;
; SET MODE FUNCTION - STORE NEW TAPE MODE
;

60$:	MOVW	IRP$L_MEDIA+2(R3),UCB$W_DEVBUFSIZ(R5) ;SET NEW DEFAULT BUFFER SIZE
	MOVW	IRP$L_MEDIA+4(R3),UCB$W_BOFF(R5) ;SAVE NEW TAPE CONTROL PARAMETERS
	MOVZBL	#CDHC_SCH,R1		;SET DISPATCH INDEX
	BRB	110$			;

;
; LOGICAL REWIND AND SET TAPE OFFLINE - CONVERT TO UNLOAD COMMAND
;

70$:	MOVZBL	#CDHC_UNL,R1		;SET FOR UNLOAD COMMAND
	BRB	110$			;

;
; AVAILABLE FUNCTION - Equivalent of REWIND(NOWAIT) and clear of UCB$M_VALID.
;

75$:
	MOVW	#IO$_REWIND!IO$M_NOWAIT,-; Simulate a REWIND NOWAIT.
		UCB$W_FUNC(R5)
	BICW	#UCB$M_VALID,-		 ; And clear valid bit.
		UCB$W_STS(R5)		 ;  and fall thru to rewind logic.

;
; LOGICAL REWIND FUNCTION - CONVERT TO PHYSICAL FUNCTION
;

80$:	MOVZBL	#CDHC_RWD,R1		;SET FOR REWIND
	BRB	110$			;

;
; LOGICAL WRITE EOF OR SENSE MODE FUNCTION - CONVERT TO PHYSICAL FUNCTION
;

90$:	SUBW	#IO$_SENSEMODE-IO$_READPBLK-9,R1 ;CONVERT TO PHYSICAL****
	BRB	110$			;

;
; DENSE FUNCTION CODE - CHECK FOR READ, WRITE, OR WRITECHECK FUNCTION
;

100$:	CMPL	#IO$_WRITECHECK,R1	;DATA TRANSFER FUNCTION?
	BGTRU	110$			;IF GTRU NO
	BBC	#IO$V_REVERSE,UCB$W_FUNC(R5),110$ ;IF CLEAR,NOT REVERSE
	ADDW	#CDHC_WKR-CDHC_WCK,R1	;CONVERT TO REVERSE FUNCTION

;
; FINISH PREPROCESSING
;

110$:	MOVB	R1,UCB$B_FEX(R5)	;SAVE FUNCTION DISPATCH INDEX
				;****NOTE ABOUT BYTE FOR INDEX

;
;CENTRAL FUNCTION DISPATCH
;

FDISPATCH:
	MOVL	UCB$L_IRP(R5),R3	;RETRIEVE ADDR. OF I/O PACKET
	BBS	#IRP$V_PHYSIO,IRP$W_STS(R3),10$ ;IF SET, PHYSICAL I/O FUNCTION
	BBS	#UCB$V_VALID,UCB$W_STS(R5),10$ ;IF SET, VOLUME SOFTWARE VALID
	MOVZWL	#SS$_VOLINV,R0		;SET VOLUME INVALID STATUS
	BRW	FCNEXT		;**NO CHANGE ON UCB$V_VALID BIT HERE**

;
; UNIT IS SOFTWARE VALID OR FUNCTION IS PHYSICAL I/O
;

10$:	
	MOVL	UCB$L_CRB(R5),R4	;GET CSR ADDRESS INTO R4...
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R4 ;
	MOVZBL	UCB$B_FEX(R5),R0	;GET DISPATCH INDEX
	CASE	R0,<-			;DISPATCH TO COMMAND HANDLING ROUTINE
		NOP,-			;NO OPERATION
		UNLOAD,-		;REWIND & UNLOAD
		SPCFILFOR,-		;SPACE FILE FORWARD
		REWIND,-		;REWIND
		DRVCLR,-		;DRIVE CLEAR
		SPCFILREV,-		;SPACE FILE REVERSE
		ERASE,-			;ERASE
		SPCRECREV,-		;SPACE RECORD REVERSE
		PACKACK,-		;PACK ACKNOWLEDGE
		SPCRECFOR,-		;SPACE RECORD FORWARD
		WRITECHECK,-		;SIMULATED WRITECHECK
		WRITEDATA,-		;WRITE DATA FORWARD
		READDATA,-		;READ DATA FORWARD
		WRITECHECKR,-		;WRITE CHECK REVERSE
		WRITEDATA,-		;WRITE DATA(NO REVERSE)
		READDATAR,-		;READ DATA REVERSE
		REREADN,-		;REREAD DATA NEXT
		REREADP,-		;REREAD DATA PREVIOUS
		WRITERET,-		;WRITE DATA RETRY
		READPRESET,-		;SIMULATED READ PRESET
		SETCHAR,-		;SIMULATED SET CHARACTERISTIC
		GETSTS,-		;GET STATUS IMMEDIATE(SENS CHAR.)
		WRTTMK,-		;WRITE TAPE MARK
		WRTTMKR,-		;WRITE TAPE MARK RETRY
		CLEAN,-			;CLEAN
		MSGREL,-		;MESSAGE BUFFER RELEASE
		WRITESUBS,-		;WRITE SUBSYSTEM MEMEORY
		WRITECHAR,-		;WRITE CHARACTERISTICS
		>
				;***NOTE INDEX OUT OF BOUND***
.PAGE
.SBTTL	NOP AND SIMULATED FUNCTIONS

;
; SET CHARACTERISTIC FUNCTION
;

SETCHAR:				;SET CHARACTERISTIC
	BICW	#UCB$M_MS_SWAP,UCB$W_DEVSTS(R5)	;CLEAR SWAP BIT 1ST
	EXTZV	#MT$V_FORMAT,-			;GET FORMAT FIELD
		#MT$S_FORMAT,-			;
		UCB$W_BOFF(R5),R1		;
	CMPW	#MT$K_NORMAL15,R1		;IS IT INDUSTRIAL COMPATIBLE?
	BNEQ	5$				;BR IF NO
	BISW	#UCB$M_MS_SWAP,UCB$W_DEVSTS(R5)	;SET SWAP BIT FOR
						; SUBSEQUENT IO FUNCTIONS
5$:

;
; NO OPERATION AND SIMULATED NON-EXISTENT TS11/TS04 HARDWARE COMMAND
;

PACKACK:					;PACK ACKNOWLEDGE
	BISW	#UCB$M_VALID,UCB$W_STS(R5)	; PACKACK implies set volume valid.
NOP:						;NO OPERATION
WRITECHECK:					;SIMULATED WRITECHECK
WRITECHECKR:					;SIMULATED WRITECHECK REVERSE
READPRESET:					;READ IN PRESET

	EXHC	10$			;EXECUTE HARDWARE COMMAND, IF ANY
10$:
	BRW	FCNEXT			;GOTO FUNCTION EXIT
					;10$ AS RETRIABLE ERROR OCCURRED
			;NO RETRIABLE ERROR, NOP ALWAYS SUCCESSFUL

.PAGE
.SBTTL	READ HARDWARE FUNCTIONS

;
; READ HARDWARE FUNCTIONS
;

READDATA:				;READ DATA FORWARD
	EXHC	10$			;EXECUTE HARDWARE COMMAND
	INCL	UCB$L_MS_RECORD(R5)	;INCREMENT RECORD COUNT
	BRW 	FCNEXT			;GOTO SUCCESSFUL RETURN
				;10$ HANDLES RETRIABLE ERRORS
10$:
	PUSHL	R0			;SAVE R0 HAS TCC
	JSB	G^ERL$DEVICERR		;LOG BEFORE RETRY
	POPL	R0			;RESTORE
20$:
	CMPL	#TCC_REM,R0		;DID TAPE MOVED
	BEQL	22$			;YES BRANCH
	DECB	UCB$B_ERTCNT(R5)		;ANY RETRIES REMAINING?
	BLSS	30$		;NO, GO AS FATAL
	EXHC	20$,HC_RDN		;DO READ AGAIN
	INCL	UCB$L_MS_RECORD(R5)	;INCREMENT RECORD COUNNT
	BRW	RFCNEXT			;SUCEED, RETURN
22$:
	DECB	UCB$B_ERTCNT(R5)		;ANY RETRIES REMAINING?
	BLSS	30$		;NO, GO AS FATAL ERROR
	EXHC	22$,HC_RRP		;DO REREAD PREVIOUS
	INCL	UCB$L_MS_RECORD(R5)	;INCREMENT RECORD COUNT
	BRW	RFCNEXT			;SUCCEED, RETURN
30$:
	JMP	FATALER0

;
; REREAD PREVIOUS (SPACE REV,READ FWD)
;

REREADP:				;REREAD DATA PREVIOUS
	EXHC	10$			;
	BRW	FCNEXT			;SUCCESS RETURN
10$:
	BRW	FATALER0		;TREATED AS FATAL AS NOW

;
; READ PREVIOUS
;

READDATAR:				;READ DATA REVERSE
	EXHC	10$
	DECL	UCB$L_MS_RECORD(R5)	;DECREMENT RECORD COUNT
				;*NOTE*TMK PROBLEM???
	BRW	FCNEXT			;DO SUCCESSFUL RETURN
10$:					;RETRIABLE
	PUSHL	R0			;SAVE R0 WHICH HAS TCC CODE
	JSB	G^ERL$DEVICERR		;LOG BEFORE RETRY
	POPL	R0			;RESTORE
20$:
	CMPL	#TCC_REM,R0		;TAPE MOVED?
	BEQL	22$			;YES
	DECB	UCB$B_ERTCNT(R5)	;ANY RETRIES LEFT?
	BLSS	30$			;NO, AS FATAL ERROR
	EXHC	20$,HC_RDP		;DO READ DATA PREVIOUS AGAIN
	DECL	UCB$L_MS_RECORD(R5)	;DECREMENT RECORD COUNT
	BRW	RFCNEXT			;SUCCESS RETURN
22$:
	DECB	UCB$B_ERTCNT(R5)	;ANY RETRIES LEFT?
	BLSS	30$			;NO, AS FATAL ERROR
	EXHC	22$,HC_RRN		;DO REREAD DATA NEXT
	DECL	UCB$L_MS_RECORD(R5)	;DECREMENT RECORD COUNT
	BRW	RFCNEXT			;SUCCESS RETURN
30$:
	BRW	FATALER0


;
; REREAD DATA NEXT(SPACE FWD, READ REV)
;

REREADN:				;REREAD DATA NEXT
	EXHC	10$
	BRW	FCNEXT			;SUCCESS RETURN
10$:
	BRW	FATALER0		;AS FATAL ERROR AS NOW


.PAGE
.SBTTL	WRITE FUNCTIONS

;
; WRITE DATA
;

WRITEDATA:				;WRITE DATA FORWARD
	BICW	#<MT$M_HWL>@-16,UCB$L_DEVDEPEND+2(R5) ;CLEAR 
					; HARDWARE WRITE LOCK BIT
	EXHC	10$			;
	INCL	UCB$L_MS_RECORD(R5)	;INCREMENT RECORD COUNT
	BRW	FCNEXT			;TAKE FUNCTION EXIT
10$:
	PUSHL	R0			;SAVE R0
	JSB	G^ERL$DEVICERR		;LOG BEFORE RETRY
	POPL	R0			;RESTORE
20$:
	CMPL	#TCC_REM,R0		;TAPE MOVED?
	BEQL	22$			;YES
	DECB	UCB$B_ERTCNT(R5)	;ANY RETRIES LEFT?
	BLSS	30$			;NO, AS FATAL ERROR
	EXHC	20$,HC_WRD		;YES, DO WRITE AGAIN
	INCL	UCB$L_MS_RECORD(R5)	;INCREMENT RECORD COUNT
	BRW	RFCNEXT			;TAKE SUCCESS RETURN
22$:
	DECB	UCB$B_ERTCNT(R5)	;ANY RETRIES LEFT?
	BLSS	30$		;NO, FATAL
	EXHC	22$,HC_WDR		;DO WRITE DATA RETRY
	INCL	UCB$L_MS_RECORD(R5)	;INCREMENT RECORD COUNT
	BRW	RFCNEXT			;SUCCESS RETURN
30$:
	BRW	FATALER0

;
; WRITE DATA RETRY(SPACE REV,ERASE,WRITE DATA)
;

WRITERET:				;WRITE DATA RETRY
	EXHC	10$			;
	BRW	FCNEXT			;TAKE SUCCESS RETURN
10$:
	BRW	FATALER0		;AS FATAL

;
; WRITE SUBSYSTEM MEMORY
;

WRITESUBS:				;WRITE SUBSYSTEM MEMORY
	EXHC	10$			;
	BRW	FCNEXT			;SUCCESS RETURN
10$:

	BRW	FATALER0

;
; WRITE CHARACTERISTICS
; USED TO TELL SUBSYSTEM MSG BUFFER ADDR. & SET CHARACTERISTIC WORD
;

WRITECHAR:				;WRITE CHARACTERISTICS

	EXHC	10$			;
	BRW	FCNEXT			;SUCCESS RETURN
10$:
	BRW	FATALER0		;

.PAGE
.SBTTL	POSITIONING FUNCTIONS

;
; SPACE FILE FORWARD
; NOTE: HARDWARE SKIPFILE COMMAND IS NOT USED.
; SKIPFILE IS SIMULATED BY A SERIES SKIPRECORD COMMANDS.
;

SPCFILFOR:				;SPACE FILE FORWARD
	MOVW	UCB$W_MS_SPACNT(R5),UCB$W_BOFF(R5) ;SAVE NO. OF 
	MOVW	UCB$W_MS_SPACNT(R5),UCB$W_BCNT(R5) ; TAPE MARKS TO SKIP
	MOVL	UCB$L_MS_RECORD(R5),UCB$L_MS_PMPR(R5) ;SAVE TAPE POSITION
	BISW	#UCB$M_MS_SWE,UCB$W_DEVSTS(R5)	;USE OLD TAPE POSITION IF POWERFAIL
					;**SOFTWARE EMULATED FUNCTION**
0$:
	BICW	#UCB$M_MS_FEF,UCB$W_DEVSTS(R5)	;CLEAR FLAG FOR 1ST EOF SEEN
1$:
	MOVW	#^X7FFF,UCB$W_MS_SPACNT(R5) ;SKIP 32,768 RECORDS INSTEAD
	EXHC	10$,HC_STF			;DO IT
	MOVZWL	UCB$W_MS_XC(R5),R1	;GET NO. OF RECORDS PASSED
	ADDL	R1,UCB$L_MS_RECORD(R5)	;ADD IT
	BBC	#MT$V_EOF,UCB$L_DEVDEPEND(R5),0$ ;BR IF DIDN'T SEE TAPE MARK
	DECW	UCB$W_BCNT(R5)		;DECREMENT TAPE MARK PASSED
	BBC	#DEV$V_MNT,-		;BR IF NOT MOUNTED
		UCB$L_DEVCHAR(R5),2$	;
	BBC	#DEV$V_FOR,-		;BR IF MOUNTED NOT FOREIGN
		UCB$L_DEVCHAR(R5),5$	;
2$:
	BBC	#UCB$V_MS_FEF,UCB$W_DEVSTS(R5),4$ ;BR IF 1ST TMK 
	CMPW	#1,UCB$W_MS_XC(R5)	;**1 RECORD=TAPE MARK??**
	BNEQ	5$			;BR IF NO
	MOVW	#1,UCB$W_MS_SPACNT(R5)	;SKIP 1 TMK REVERSE
	EXHC	10$,HC_STR		;
	INCW	UCB$W_BCNT(R5)		;BACKUP 1 TMK PASSED
	DECL	UCB$L_MS_RECORD(R5)	;UPDATE TAPE POSITION
	MOVZWL	#SS$_ENDOFVOLUME,R0	;YES, DOUBLE TMKS=ENDOFVOLUME
	SUBW3	UCB$W_BCNT(R5),UCB$W_BOFF(R5),UCB$W_MS_XC(R5) ;GET NO. OF
					; TAPE MARKS PASSED
	BRW	FCNEXT			;GO EXIT
4$:
	BISW	#UCB$M_MS_FEF,UCB$W_DEVSTS(R5) ;SET 1ST EOF
5$:
	TSTW	UCB$W_BCNT(R5)		;PASSED ALL TAPE MARKS
	BNEQ	1$			;NO, GO BACK
	MOVW	UCB$W_BOFF(R5),UCB$W_MS_XC(R5) ;YES,COPY TMKS PASSED
	BRW	FCNEXT			;GO EXIT
10$:
	BRW	FATALER0		;TAKE FAILURE RETURN

;
; SPACEFILE REVERSE
;

SPCFILREV:				;SPACE FILE REVERSE
	MOVW	UCB$W_MS_SPACNT(R5),UCB$W_BOFF(R5) ;SAVE NO. OF 
	MOVW	UCB$W_MS_SPACNT(R5),UCB$W_BCNT(R5) ; TAPE MARKS TO SKIP
	MOVL	UCB$L_MS_RECORD(R5),UCB$L_MS_PMPR(R5) ;SAVE TAPE POSITION
	BISW	#UCB$M_MS_SWE,UCB$W_DEVSTS(R5)	;USE OLD TAPE POSITION IF POWERFAIL
					;**SOFTWARE EMULATED FUNCTION**
1$:
	MOVW	#^X7FFF,UCB$W_MS_SPACNT(R5) ;SKIP 32,768 RECORDS INSTEAD
	EXHC	10$,HC_STR			;DO IT
	MOVZWL	UCB$W_MS_XC(R5),R1	;GET NO. OF RECORDS PASSED
	SUBL	R1,UCB$L_MS_RECORD(R5)	;SUBTRACT
	BBC	#MT$V_EOF,UCB$L_DEVDEPEND(R5),1$ ;BR IF DIDN'T SEE TAPE MARK
	DECW	UCB$W_BCNT(R5)		;DECREMENT TAPE MARK PASSED
	TSTW	UCB$W_BCNT(R5)		;PASSED ALL TAPE MARKS?
	BNEQ	1$			;NO, BR BACK
	MOVW	UCB$W_BOFF(R5),UCB$W_MS_XC(R5) ;YES,COPY TMKS PASSED
	BRW	FCNEXT			;GO EXIT
10$:
	BRW	FATALER0

;
; SPACE RECORD FORWARD
;

SPCRECFOR:				;SPACE RECORD FORWARD
	EXHC	10$			;
	BBC	#MT$V_EOF,UCB$L_DEVDEPEND(R5),8$ ;BR IF NO TMK
	CMPW	#1,UCB$W_MS_XC(R5)	;**1 RECORD=TMK?**
	BNEQ	8$			;BR IF NO
	BBC	#DEV$V_MNT,-		;BR IF NOT MOUNTED
		UCB$L_DEVCHAR(R5),2$	;
	BBC	#DEV$V_FOR,-		;BR IF MOUNTED NOT FOREIGN
		UCB$L_DEVCHAR(R5),8$	;
2$:
	TSTL	UCB$L_MS_RECORD(R5)	;WAS AT BOT?
	BEQL	8$			;BR IF YES
	MOVW	#1,UCB$W_MS_SPACNT(R5)	;SKIP 1 RECORD REVERSE
	EXHC	10$,HC_SRR		;
	MOVW	#1,UCB$W_MS_SPACNT(R5)	;SKIP 1 RECORD REVERSE
	EXHC	10$,HC_SRR		;
	MOVW	#1,UCB$W_MS_SPACNT(R5)	;SKIP 1 RECORD FORWARD
	EXHC	10$,HC_SRF		;
	BBC	#MT$V_EOF,UCB$L_DEVDEPEND(R5),6$ ;BR IF NO TMK
	MOVZWL	#SS$_ENDOFVOLUME,R0	;WAS AT ENDOFVOLUME
	CLRW	UCB$W_MS_XC(R5)		;NO RESULTANT MOVEMENT
	BRW	FCNEXT			;RETURN
6$:
	MOVW	#1,UCB$W_MS_SPACNT(R5)	;SKIP 1 RECORD FORWARD
	EXHC	10$,HC_SRF		;
8$:
	MOVZWL	UCB$W_MS_XC(R5),R1	;GET NO. OF RECORDS PASSED
	ADDL	R1,UCB$L_MS_RECORD(R5)	;UPDATE
	BRW	FCNEXT			;
10$:
	BRW	FATALER0

;
; SPACE RECORD REVERSE
;

SPCRECREV:				;SPACE RECORD REVERSE
	EXHC	10$			;
	MOVZWL	UCB$W_MS_XC(R5),R1	;GET NO. OF RECORDS PASSED
	SUBL	R1,UCB$L_MS_RECORD(R5)	;UPDATE
	BRW	FCNEXT			;
10$:
	BRW	FATALER0

;
; REWIND
;

REWIND:					;REWIND
	EXHC	10$
	BISW	#<MT$M_BOT@-16>,UCB$L_DEVDEPEND+2(R5) ;MARK BOT
	BICW	#<MT$M_LOST@-16>,UCB$L_DEVDEPEND+2(R5) ;CLEAR POSITION-LOST
	CLRL	UCB$L_MS_RECORD(R5)
	BRW	FCNEXT
10$:
	BRW	FATALER0	

.PAGE
.SBTTL	FORMAT COMMANDS

;
; WRITE TAPE MARK
;

WRTTMK:					;WRITE TAPE MARK
	BICW	#<MT$M_HWL>@-16,UCB$L_DEVDEPEND+2(R5) ;CLEAR
					; WRITE LOCK BIT FIRST
	EXHC	10$			;
	INCL	UCB$L_MS_RECORD(R5)	;INCREMENT RECORD COUNT
	BRW	FCNEXT			;GOTO EXIT
10$:
	PUSHL	R0			;SAVE R0
	JSB	G^ERL$DEVICERR		;LOG BEFORE RETRY
	POPL	R0			;RESTORE
20$:
	CMPL	#TCC_REM,R0		;TAPE MOVED?
	BEQL	22$			;YES
	DECB	UCB$B_ERTCNT(R5)	;ANY RETRIES LEFT?
	BLSS	30$			;NO, FATAL
	EXHC	20$,HC_WTM		;DO IT AGAIN
	INCL	UCB$L_MS_RECORD(R5)	;INCREMENT RECORD COUNT
	BRW	RFCNEXT			;RETURN
22$:
	DECB	UCB$B_ERTCNT(R5)	;ANY RETRIES LEFT?
	BLSS	30$			;NO, FATAL
	EXHC	22$,HC_WTR		;DO WRITE TAPE MARK RETRY
	INCL	UCB$L_MS_RECORD(R5)	;INCREMENT RECORD COUNT
	BRW	RFCNEXT			;

30$:	BRW	FATALER0		;BRANCH FATAL ERROR
;
; WRITE TAPE MARK RETRY(SPACE REV,ERASE,WRITE TAPE MARK)
;

WRTTMKR:					;WRITE TAPE MARK RETRY
	EXHC	10$			;
	BRW	FCNEXT			;GO EXIT
10$:
	BRW	FATALER0		;FATAL AS NOW
;
; ERASE
;

ERASE:					;ERASE
	EXHC	10$				;
	BRW	FCNEXT
10$:
	BRW	FATALER0

.PAGE
.SBTTL	CONTROL COMMANDS

;
; CONTROL COMMANDS
;

MSGREL:					;MESSAGE BUFFER RELEASE
	EXHC	10$				;
	BRW 	FCNEXT
10$:

	BRW	FATALER0

UNLOAD:					;
	EXHC	10$				;
	BRW	FCNEXT
10$:
	BRW	FATALER0

CLEAN:					;CLEAN
	EXHC	10$				;
	BRW	FCNEXT
10$:
	BRW	FATALER0

.PAGE
.SBTTL	INITIALIZE AND GET STATUS

;
; DRIVE INITIALIZE
;

DRVCLR:					;DRIVE INITIALIZE
	EXHC	10$
	BRW	FCNEXT
10$:
	BRW	FATALER0

;
; GET STATUS (END MESSAGE ONLY)
;

GETSTS:					;
	EXHC	10$
	BICW	#<MT$M_BOT!-		;CLEAR BITS IN UCB$L_DEVDEPEND+2
		MT$M_EOF!-		;
		MT$M_EOT!-		;END OF TAPE
		MT$M_HWL>@-16,UCB$L_DEVDEPEND+2(R5) ;
	BBC	#MS_XSR0_V_BOT,-	;AT BOT?
		UCB$W_MS_XSR0(R5),1$		;BR IF NO
	CLRL	UCB$L_MS_RECORD(R5)	;CLEAR RECORD COUNT
	BISW	#<MT$M_BOT@-16>,UCB$L_DEVDEPEND+2(R5) ;SET BOT
	BICW	#<MT$M_LOST@-16>,UCB$L_DEVDEPEND+2(R5) ;CLEAR LOST BIT
1$:
	BBC	#MS_XSR0_V_TMK,-	;AT TAPE MARK
		UCB$W_MS_XSR0(R5),2$		;BR IF NO
	BISW	#<MT$M_EOF@-16>,UCB$L_DEVDEPEND+2(R5) ;SET EOF
2$:
	BBC	#MS_XSR0_V_WLK,-	;WRITE-LOCKED?
		UCB$W_MS_XSR0(R5),3$		;BR IF NO
	BISW	#<MT$M_HWL@-16>,UCB$L_DEVDEPEND+2(R5) ;SET WRITE-LOCKED
3$:
	BBC	#MS_XSR0_V_EOT,-	;END OF TAPE
		UCB$W_MS_XSR0(R5),4$		;BR IF NO
	BICW	#<MT$M_LOST@-16>,UCB$L_DEVDEPEND+2(R5) ;CLEAR POS.LOST
	BISW	#<MT$M_EOT@-16>,UCB$L_DEVDEPEND+2(R5) ;SET END OF TAPE
	MOVZWL	#SS$_ENDOFTAPE,R0	;PUT IN RETURN STATUS
4$:
	BBS	#MS_XSR0_V_ONL,-	;CHECK IF ONLINE?
		UCB$W_MS_XSR0(R5),6$	;BR IF YES

	MOVZWL	#SS$_MEDOFL,R0		;RETURN MEDIUM-OFFLINE
6$:
	BRW	FCNEXT
10$:
	BRW	FATALER0		;TREAT AS FATAL

.PAGE
.SBTTL	COMPLETION PROCESSING
;
; FATALERR - FINISHING UP THE I/O REQUEST PROCESSING WHEN THE OPERATION
; ENDS WITH FATAL OR HARD ERROR.
; R0 HAS THE FINAL STATUS CODE ALREADY.
;

FATALER0:				;NO ERROR CODE IN R0
	MOVZWL	#SS$_DRVERR,R0		;GIVE IT ONE FOR NOW
FATALERR:
	CLRW	UCB$W_MS_XC(R5)		;MAKE SURE NOTHING XFERRED/SKIPPED
RFCNEXT:				;SUCCESS RETURN AFTER RETRY
	CMPW	#SS$_MEDOFL,R0		; See if error is MEDIA OFF LINE.
	BEQL	FCNEXT			; If so, then branch around logging error.
	PUSHL	R0			;SAVE FINAL STATUS
	JSB	G^ERL$DEVICERR		;LOG DEVICE ERROR
	POPL	R0			;
FCNEXT:
	BICW	#<UCB$M_MS_RPI!UCB$M_MS_SWE>,UCB$W_DEVSTS(R5) ;ASSURE FLAGS CLEARED
	PUSHL	R0			;SAVE FINAL STATUS
	JSB	G^IOC$DIAGBUFILL	;FILL DIAGNOSTIC BUFFER IF PRESENT
	MOVW	UCB$W_MS_XC(R5),2(SP)	;SET BYTES XFERRED OR RECORDS/FILES SKIPED
	BLBS	(SP),70$		;IF LBS SUCCESSFUL COMPLETION
	MOVL	UCB$L_IRP(R5),R4	;GET ADDRESS OF CURRENT I/O PACKET
	BBC	#IRP$V_VIRTUAL,IRP$W_STS(R4),70$ ;IF CLR, NOT VIRTUAL FUNCTION
	MOVL	IRP$L_WIND(R4),R4	;GET ADDRESS OF WINDOW BLOCK
	CLRW	WCB$W_NMAP(R4)		;CLEAR NUMBER OF MAPPING POINTERS
	MOVL	UCB$L_VCB(R5),R4	;GET ADDRESS OF VCB LISTHEAD
	MOVAB	UCB$L_IOQFL(R5),R2	;GET ADDRESS OF I/O QUEUE
	MOVL	R2,R3			;SET ADDRESS OF PREVIOUS ENTRY
60$:	MOVL	(R3),R3			;GET ADDRESS OF NEXT ENTRY
	CMPL	R3,R2			;END OF LIST?
	BEQL	70$			;IF EQL YES
	BBC	#IRP$V_VIRTUAL,IRP$W_STS(R3),60$ ;IF CLR,NOT VIRTUAL FUNCTION
	MOVL	4(R3),R3			;RETRIEVE ADDRESS OF PREVIOUS ENTRY
	REMQUE	@(R3),R1		;REMOVE ENTRY FROM DRIVER QUEUE
	INSQUE	(R1),@4(R4)		;INSERT ENTRY IN BLOCKED I/O LIST
	BRB	60$			;
70$:	POPL	R0			;RETRIEVE FINAL STATUS
	MOVL	UCB$L_DEVDEPEND(R5),R1	;SET MAGTAPE STATUS AND CHARACTERISTIC
	REQCOM				;COMPLETE REQUEST

.PAGE
.SBTTL	HARDWARE COMMAND EXECUTOR
;+
; HCEX - EXECUTES HARDWARE COMMAND
;
; THIS ROUTINE IS CALLED VIA A BSB WITH A WORD IMMEDIATELY FOLLOWING THAT
; SPECIFIES THE ADDRESS OF AN (RETRIABLE) ERROR ROUTINE. ALL DATA IS ASSUMED TO HAVE
; BEEN SET UP IN THE UCB BEFORE THE CALL. THE COMMAND PACKET IS APPROPRIEATELY
; SETUP AND INITIATED BY LOADING THE ADDR. OF COMMAND PACKET INTO THE
; TS11/TS04 DEVICE REGISTER, TSDB. THEN, A WAITFOR INTERRUPT IS EXECUTED
; AND WHEN THE INTERRUPT OCCURS, CONTROL IS RETURNED TO THE CALLER.
; THE ROUTINE MAINLY DEALS WITH THE HARDWARE INTERFACE.
;
; INPUTS:
;	R0=HARDWARE COMMAND TABLE DISPATCH INDEX
;	R4=EQUIVALENT CSR ADDR. FOR TS11/TS04
;	R5=DEVICE UNIT UCB ADDRESS
;
;	00(SP) = RETURN ADDRESS OF CALLER
;	04(SP) = RETURN ADDRESS OF CALLER'S CALLER
;
;	IMMEDIATELY FOLLOWING INLINE AT THE CALL SITE IS A WORD WHICH HAS
;	A BRANCH DESTINATION TO AN ERROR RETRY ROUTINE, IF APPROPRIATE.
; OUTPUTS:
;	THE DRIVE STATUS, SUCH AS BOT, EOT, ETC, ARE RECORDED IN UCB.
;
;	THERE ARE THREE EXITS FROM THIS ROUTINE:
;	1) NORMAL RETURN,
;	2) FATAL OR HARD ERROR  EXIT, AND
;	3) RETRIABLE ERROR RETURN.
; WHEN EXITS, R0 HAS THE FINAL STATUS CODE IF NORMAL OR FATAL,
; R0 HAS TERMINATION CODE, 4 OR 5, IF RETRIABLE.
; THE DRIVE STATUS IS RECORDED INTO UCB WHILE PROCESSING TERMINATION CODE
;

HCEX:					;
	POPL	UCB$L_DPC(R5)		;SAVE DRIVER PC VALUE
	MOVZBL	#20,UCB$L_MS_TIMOUT(R5)	; Initialize timeout to 20 seconds.
	CLRW	UCB$B_MS_DPN(R5)	;CLEAR DATA PATH NO. & PURGE ERROR
	CLRQ	UCB$L_MS_DPR(R5)	;ZERO DATAPATH REG. & FINAL MAP REG.
	CLRW	UCB$W_MS_XC(R5)		;INITIALIZE COUNT
	MOVB	R0,UCB$B_CEX(R5)	;SAVE CASE INDEX
	MOVL	UCB$L_MS_TSPT1(R5),R1	;GET COMMAND PACKET POINTER
	MOVW	HCTAB[R0],MS_CPHD(R1)	;LOAD COMMAND PACKET HEAD WORD

	MOVW	#^XFFFF,MS_MHD(R1)	;MARK MSG HEAD TO ENSURE MSG BUFFER RETURNED
	BBCC	#UCB$V_MS_VCK,UCB$W_DEVSTS(R5),7$ ;BR IF NOT VOLUME CHECK
	BISW	#MS_CPHD_M_CVC,MS_CPHD(R1) ;YES, FLAG TO CLEAR VOLUME CHECK
7$:
	CASE	R0,<-			;DISPATCH TO PROPER COMMAND ROUTINE
		PNOP,-			;NOP
		PMIS,-			;UNLOAD
		PPOS,-			;SPACE FILE FORWARD
		PPOS,-			;REWIND
		PMIS,-			;DRIVE CLEAR
		PPOS,-			;SPACE FILE REVERSE
		PMIS,-			;ERASE
		PPOS,-			;SPACE RECORD REVERSE
		PNOP,-			;SIMULATED PACK ACKNOWLEDGE
		PPOS,-			;SPACE RECORD FORWARD
		PNOP,-			;SIMULATED WRITECHECK
		PXFR,-			;WRITE DATA FORWARD
		PXFR,-			;READ DATA FORWARD
		PNOP,-			;SIMULATED WRITE CHECK REVERSE
		PXFR,-			;WRITE DATA (NO REVERSE)
		PXFRR,-			;READ DATA REVERSE
		PXFRR,-			;REREAD DATA NEXT
		PXFRR,-			;REREAD DATA PREVIOUS
		PXFR,-			;WRITE DATA RETRY
		PNOP,-			;SIMULATED READ PRESET
		PNOP,-			;SIMULATED SET CHARACTERISTIC
		PMIS,-			;GET STATUS IMMEDIATE(SENS CHAR.)
		PMIS,-			;WRITE TAPE MARK
		PMIS,-			;WRITE TAPE MARK RETRY
		PMIS,-			;CLEAN
		PMIS,-			;MESSAGE BUFFER RELEASE
		PXFR,-			;WRITE SUBSYSTEM MEMORY
		PWCH,-			;WRITE CHARACTERISTICS
		>			;

.PAGE
;+PNOP - NO OPERATION ON HARDWARE FOR MANY SIMULATED FUNCTIONS
;	THEY ARE: NOP,PACK ACKNOWLEDGE,WRITECHECK,WRITE CHECK REVERSE,
;	READ IN PRESET,SET CHARACTERISTICS.
;	THE ROUTINE SIMPLY RETURNS.

PNOP:				;
RET:					;
	MOVZWL	#SS$_NORMAL,R0		;ALWAYS SUCCESS
	ADDL	#2,UCB$L_DPC(R5)	;ADJUST TO CORRECT RETURN
	JMP	@UCB$L_DPC(R5)		;RETURN TO DRIVER


; PPOS - CONSTRUCT COMMNAD PACKET FOR POSITIONING COMMANDS:
; SPACE RECORDS FORWARD, SPACE RECORDS REVERSE, SKIP TAPE MARKS FORWARD,
; SPACE TAPE MARKS REVERSE, AND REWIND.

PPOS:					;
	CMPB	#CDHC_RWD,R0		;REWIND COMMAND?
	BNEQ	5$			;NO
	DSBINT				;YES, DISABLE INTERRUPTS
	BBC	#UCB$V_POWER,-
		UCB$W_STS(R5),1$	; Continue if NO powerfail
	BRW	PWRFL1			; Branch around if we had POWERFAIL.
1$:
	MOVW	UCB$W_MS_TSPT3(R5),(R4)	;LOAD COMMAND POINTER
	WFIKPCH	MSTMO1,#^D300		;TIMEOUT FOR 5 MIN.'S FOR 2400 FEET TAPE
	IOFORK				;MAKE IT FORK FIRST
	BRW	XTC			;GO PROCESS TERMINATION CODE
5$:					;NOT REWIND OR UNLOAD
	MOVW	UCB$W_MS_SPACNT(R5),MS_BACT(R1) ;LOAD THE COUNT
	MOVW	UCB$W_MS_SPACNT(R5),UCB$W_MS_XC(R5) ;COPY COUNT
					;FALL INTO CODE TO LOAD COMMAND
	MOVZWL	UCB$W_MS_SPACNT(R5),-	; Maximum size record takes one second
		UCB$L_MS_TIMOUT(R5)	;  to skip (approximately).
	CMPL	#11*60,-		; Compare time to skip entire tape to
		UCB$L_MS_TIMOUT(R5)	;  time to skip this # records.
	BGEQ	10$			; GEQ implies skipping small # records
	MOVZWL	#11*60,-		; Else use maximum time to skip whole
		UCB$L_MS_TIMOUT(R5)	;  tape.
	BRB	20$			; And branch around.
10$:	ADDL	#2,UCB$L_MS_TIMOUT(R5)	; Add in fudge factor for small skips.
20$:

;+PMIS - CONSTRUCT COMMAND PACKET FOR FORMAT COMMANDS: WRITE TAPE MARK, 
; ERASE,WRITE TAPE MARK RETRY; CONTROL COMMANDS: MESSAGE BUFFER RELEASE,
; UNLOAD, & CLEAN; INITIALIZE COMMAND: DRIVE INITIALIZE; AND GET STATUS
; COMMAND: GET STATUS IMMEDIATE.

PMIS:					;
	BRW	LDTSDB			;GO LOAD DEVICE REGISTER

; PWCH - CONSTRUCT COMMAND PACKET FOR WRITE CHARACTERISTIC COMMAND

PWCH:					; R1 POINTS TO COMMAND PACKET
	MOVL	UCB$L_MS_TSPT2(R5),MS_BACT(R1) ;STORE CHAR. BUFFER ADDR.
	ADDL	#8,MS_BACT(R1)		;POINT TO CHAR. BUFFER NOW
	MOVW	#8,MS_CNT(R1)		;STORE BYTE COUNT FOR CHAR. DATA
	MOVL	UCB$L_MS_TSPT2(R5),MS_MBA0(R1)		;STORE MESSAGE BUFFER ADDR.
	ADDL	#16,MS_MBA0(R1)		; AS CHAR. DATA
	MOVW	#14,MS_LNTH(R1)		;LENGTH OF CHAR. DATA=14.
	CLRW	MS_CHWD(R1)		;ZERO CHARACTERISTIC WORD
;
; NOW, COMMAND PACKET IS SETUP, READY TO LOAD DEVICE REGISTER
;

LDTSDB:					;TS11/TS04 CSR EQUIVALENT=TSDB
	DSBINT				;DISABLE INTERRUPTS
	BBS	#UCB$V_POWER,UCB$W_STS(R5),PWRFL1 ;BR IF POWERFAILED
	MOVW	UCB$W_MS_TSPT3(R5),(R4)	;LOAD THE COMMAND POINTER
	WFIKPCH	MSTMO1,UCB$L_MS_TIMOUT(R5)
	IOFORK				;MAKE IT FORK FIRST
	BRW	XTC			;PROCESS TERMINATION CODE

;
; HERE, TREAT POWERFAIL AS TIMEOUT
;

PWRFL1:
	ENBINT				;ENABLE INTERRUPTS
	BRW	MSTMO1			;GOTO TIMEOUT ROUTINE

; PXFR - CONSTRUCT COMMAND PACKET FOR DATA TRANSFER COMMANDS:
; READ NEXT(FORWARD), READ PREVIOUS(REVERSE), REREAD PREVIOUS(SPACE REV, READ
; FWD), REREAD NEXT(SPACE FWD, READ REV), WRITE DATA, WRITE DATA RETRY,
; AND WRITE SUBSYSTEM MEMORY.

PXFR:					;
	BISW	#UCB$M_MS_RDPR,UCB$W_DEVSTS(R5) ;FLAG BUFFERED DATAPATH
	REQDPR				;REQUEST DATAPATH
PXFRR:				;*ENTRY PT FOR READ REVERSE*
				;**WHICH USES DIRECT DATA PATH**
	REQMPR				;REQUEST MAP REGISTER
	LOADUBAA			;LOAD MAP REGISTER
	MOVZWL	UCB$W_BOFF(R5),R0	;GET BYTE OFFSET
	MOVL	UCB$L_CRB(R5),R1	;GET CRB
	INSV	CRB$L_INTD+VEC$W_MAPREG(R1),#9,#9,R0 ;INSERT HGH 9 BITS
	MOVL	UCB$L_MS_TSPT1(R5),R1	;GET COMMAND PACKET ADDR.
	MOVL	R0,MS_BACT(R1)		;STORE XFR ADDR.
	BBC	#IO$V_OPPOSITE,UCB$W_FUNC(R5),10$ ;BR IF OPPOSITE BIT NOT SET??
	BISW	#MS_CPHD_M_OPP,MS_CPHD(R1) ;YES, SET IT IN CMND HEADER
					;***ONLY FOR REREAD COMMANDS***
10$:
	BBS	#UCB$V_MS_SWAP,UCB$W_DEVSTS(R5),12$ ;BR IF INDUSTRI.COMP.
						; (SET BY SETCHAR COMMAND)
	BBC	#IO$V_SWAP,UCB$W_FUNC(R5),15$ ;SWAP BIT SET??
12$:
	BISW	#MS_CPHD_M_SWB,MS_CPHD(R1) ;YES, SET IT IN CMD HEADER
15$:
	MOVW	UCB$W_BCNT(R5),MS_CNT(R1) ;STORE BYTE COUNT
	MOVW	UCB$W_BCNT(R5),UCB$W_MS_XC(R5) ;COPY BYTE COUNT
	DSBINT				;DISABLE INTERRUPTS
	BBS	#UCB$V_POWER,UCB$W_STS(R5),20$ ;BR IF POWERFAILED
	MOVW	UCB$W_MS_TSPT3(R5),(R4)	;LOAD THE COMMAND POINTER
	WFIKPCH	MSTMO,#^D20		;TIMEOUT FOR 20. SEC.'S
	IOFORK			;
	JSB	G^IOC$PURGDATAP		;PURGE DATAPATH
	BLBS	R0,18$			;BR IF NO ERROR
	MOVB	#1,UCB$B_MS_PER(R5)	;MARK PURGE ERROR
18$:
	BBS	#UCB$V_POWER,UCB$W_STS(R5),21$ ;BR IF POWERFAILED
	;** WANT TO SAVE DATAPATH REG. & NO. & ETC. FOR ERRLOG
	SUBW	UCB$W_MS_RBPC(R5),UCB$W_MS_XC(R5) ;GET BYTES ACTUALLY XFERRED
	MOVL	R1,UCB$L_MS_DPR(R5)	;GET DATA PATH REGISTER
	MOVB	CRB$L_INTD+VEC$B_DATAPATH(R3),-
		UCB$B_MS_DPN(R5)	;GET DATA PATH NO.
	MOVZWL	UCB$W_BOFF(R5),R1	;GET BYTE OFFSET
	TSTB	UCB$B_MS_DPN(R5)	;DATAPATH NO.=0(DIRECT)?
	BNEQ	22$			;NO
	ADDW	UCB$W_MS_RBPC(R5),R1		;YES, REVERSE OPERATION
	BRB	24$			;SKIP AROUND

;
; HERE,TREAT POWERFAIL AS TIMEOUT
;

20$:
	ENBINT				;ENABLE INTERRUPTS
21$:
	BRW	MSTMO

22$:
	ADDW	UCB$W_MS_XC(R5),R1	;GET FINAL ADDR. OFFSET
24$:
	ASHL	#<-9>,R1,R1		;MODULO 512
	MOVZWL	CRB$L_INTD+VEC$W_MAPREG(R3),R0 ;MOVE START MAP REG. NO.
	ADDL	R0,R1			;R1 HAS FINAL MAP REG. NO.
				;**R2 HAS START ADDR. OF 1ST MAP REGISTER
				;**R3 HAS CRB ADDRESS
				;** WHICH WERE GOTTEN FROM IOC$PURGDATAP
	CMPW	#495,R1		;LEGAL MAP REG. NO.?
	BGTR	25$		;BR IF YES
	MOVZWL	#495,R1		;MAKE IT FINAL MAP REG. NO.=495
	MOVL	(R2)[R1],UCB$L_MS_FMPR(R5) ;SAVE FINAL MAP REG
	MOVL	-4(R2)[R1],UCB$L_MS_PMPR(R5) ;SAVE PREVIOS MAP REG
	MOVL	(R2)[R1],UCB$L_MS_NMPR(R5) ;SAVE NEXT MAP REG(=495)
	BRB	27$		;GO AHEAD NOW
25$:				;LEGAL MAP REG. NO.
	MOVL	(R2)[R1],UCB$L_MS_FMPR(R5) ;SAVE FINAL MAP REG
	MNEGL	#1,UCB$L_MS_PMPR(R5)	;ASSUME NO PREVIOUS MAP REG
	CMPL	R0,R1		;WAS FINAL MAP REG. 1ST MAP REG
	BEQL	26$		;YES, THERE WAS NO PREVIOUS ONE
	MOVL	-4(R2)[R1],UCB$L_MS_PMPR(R5) ;OTHERWISE,SAVE PREVIOUS MAP REG
26$:
	MOVL	4(R2)[R1],UCB$L_MS_NMPR(R5) ;SAVE NEXT MAP REG
27$:
	TSTB	UCB$B_MS_DPN(R5) ;TEST IF DIRECT DATAPATH?
	BEQL	30$		;YES
	;*RELEASE DATAPATH AND MAP REG.'S
	RELDPR				;RELEASE DATA PATH
	BICW	#UCB$M_MS_RDPR,UCB$W_DEVSTS(R5) ;CLEAR FLAG
30$:					;
	RELMPR				;RELEASE MAP REGISTERS

	BRB	XTC1			;


;
; XTC - PROCESS TERMINATION CODE
; HERE, THE FINAL STATUS CODE IS PUT IN R0, &
; THE DRIVE STATUS IS RECORDED INTO UCB
;

XTC:
	TSTW	UCB$W_MS_XC(R5)		;SHOULD ANYTHING XFERRED?
	BEQL	XTC1			;NO, BRANCH
	SUBW	UCB$W_MS_RBPC(R5),UCB$W_MS_XC(R5) ;GET ACTUALLY XFERRED
XTC1:
	BBC	#MS_XSR0_V_MOT,-	;DID TAPE MOVE?
		UCB$W_MS_XSR0(R5),7$		;BR IF NO
	BICW	#<MT$M_BOT!-		;CLEAR BOT, AND
		MT$M_EOF!-		;END OF FILE,
		MT$M_EOT>@-16,UCB$L_DEVDEPEND+2(R5) ;END OF TAPE
7$:
	EXTZV	#MS_TSSR_V_TCC,#MS_TSSR_S_TCC,-	;EXTRACT TERMINATION CODE
		UCB$W_MS_TSSR(R5),R0	; INTO R0
	CASE	R0,<-			;DISPATCH TO ROUTINES
		100$,-			;NORMAL TERMINATION
		110$,-			;ATTENTION CONDITION
		120$,-			;TAPE STATUS SLERT
		130$,-			;FUNCTION REJECT
		140$,-			;RECOVERABLE ERROR(TAPE MOVED)
		150$,-			;RECOVERABLE ERROR(TAPE NOT MOVED)
		160$,-			;UNRECOVERABLE ERROR(TAPE POSI LOST)
		170$,-			;FATAL CONTROLLER ERROR
		>
;
; FATLAL CONTROLLER ERROR(TCC=7)
;

170$:					;
	MOVZWL	#SS$_CTRLERR,R0		;PUT IN FINAL STATUS CODE
	BRW	FATALERR		;GOTO FATAL ERROR

;
; UNRECOVERABLE ERROR(TAPE POSITION LOST)
; (TCC=6)

160$:
	BISW	#<MT$M_LOST@-16>,UCB$L_DEVDEPEND+2(R5) ;MARK POSITION LOST
	MOVZWL	#SS$_DRVERR,R0		;PUT IN FINAL STATUS CODE
	BBS	#MS_XSR0_V_ONL,-	;CHECK IF ON-LINE
		UCB$W_MS_XSR0(R5),165$	;BR IF YES
	MOVZWL	#SS$_MEDOFL,R0		;NO, RETURN MEDIUM OFFLINE
165$:
	BRW	FATALERR		;

;
; NORMAL TERMINATION
; (TCC=0)

100$:					;
	MOVZWL	#SS$_NORMAL,R0		;PUT IN STATUS CODE
101$:
	ADDL	#2,UCB$L_DPC(R5)	;ADJUST TO CORRECT RETURN ADDRESS
	JMP	@UCB$L_DPC(R5)		;RETURN TO DRIVER

;
; ATTENTION CONDITION
; DRIVE HAS UNDERGONE STATUS CHANGE SUCH AS GOING OFFLINE OR COMING ONLINE
; (TCC=1)

110$:
	BBC	#MS_XSR0_V_ONL,-	;CHECK IF ONLINE?
		UCB$W_MS_XSR0(R5),112$	;BR IF OFFLINE.
	MOVZWL	#TCC_REN,R0		;BECOME ONLINE, BUT
					;SHOULDN'T HAVE BEEN OFFLINE
	BRW	150$			;RETRY THE COMMAND
112$:
	MOVB	UCB$B_CEX(R5),R0	; GET HARDWARE COMMAND INDEX 
	CMPB	#CDHC_UNL,R0		;WAS IT UNLOAD?
	BEQL	100$			;YES, ITS OK
	MOVZWL	#SS$_MEDOFL,R0		;MARK AS MEDIUM OFFLINE
	BRW	FATALERR		;GOTO FATAL ERROR

;
; TAPE STATUS ALERT
;(BITS OF INTEREST: TMK, LET, RLS, EOT, RIB, AND RLL)
;**LET BIT IS LOGICAL END OF TAPE FOR DOS, NOT USED FOR NOW**
; (TCC=2) 

120$:					;
	BBC	#MS_XSR3_V_RIB,-	;REVERSE INTO BOT?
		UCB$W_MS_XSR3(R5),121$	;
	BISW	#<MT$M_BOT@-16>,UCB$L_DEVDEPEND+2(R5) ;YES
	CLRL	UCB$L_MS_RECORD(R5)	;
	MOVZWL	#SS$_OPINCOMPL,R0	;MARK OPERATION INCOMPLETE AT BOT
	BRW	FATALERR		;TAKE FATAL ERROR RETURN
121$:
	BBC	#MS_XSR0_V_RLL,-	;CHECK IF RECORD LENGTH LONG?
		UCB$W_MS_XSR0(R5),122$	;TAKE NORMAL RETURN, IF NOT
	MOVZWL	#SS$_DATAOVERUN,R0	;YES, ITS DATAOVERRUN
	BRB	101$			;TAKE NORMAL RETURN
122$:
	BBC	#MS_XSR0_V_TMK,-	;CHECK IF SEE TAPE MARK
		UCB$W_MS_XSR0(R5),125$	; ??
	BISW	#<MT$M_EOF@-16>,UCB$L_DEVDEPEND+2(R5) ;YES
	CMPB	#CDHC_WTM,UCB$B_FEX(R5)	;WAS IT WRITE TMK?
	BEQL	125$			;YES, LOOK FOR EOT
	CMPB	#CDHC_STR,UCB$B_FEX(R5)	;WAS IT SKIPFILE REVERSE?
	BEQL	128$			;YES
	CMPB	#CDHC_STF,UCB$B_FEX(R5)	;WAS IT SKIPFILE FORWARD?
	BEQL	128$			;YES
				;**NOTE UCB$L_MS_RECORD WAS ADJUSTED**
	MOVZWL	#SS$_ENDOFFILE,R0	;SET EOF
	BRW	101$			;TAKE NORMAL RETURN
125$:
	BBC	#MS_XSR0_V_EOT,-	;CHECK IF AT EOT?
		UCB$W_MS_XSR0(R5),128$	;
	BISW	#<MT$M_EOT@-16>,UCB$L_DEVDEPEND+2(R5) ;YES, SET FLAG
	MOVZWL	#SS$_ENDOFTAPE,R0	;WRITE ERROR INTO EOT
	BRW	101$		;
128$:					;ANYTHING ELSE?
	BRW	100$			;TAKE NORMAL RETURN**TEMP**

;
; FUNCTION REJECT
;(BITS OF INTEREST:BOT,WLK,VCK,ONL,ILA,ILC,NEF,WLE)
; (TCC=3)

130$:
	MOVZWL	#SS$_DRVERR,R0		;MARK AS DRIVE ERROR
	BBC	#MS_XSR0_V_BOT,-	;CHECK IF AT BOT
		UCB$W_MS_XSR0(R5),132$	;
	BISW	#<MT$M_BOT@-16>,UCB$L_DEVDEPEND+2(R5) ;YES
	CLRL	UCB$L_MS_RECORD(R5)	;
132$:					;
	BBC	#MS_XSR0_V_VCK,-	;WAS VOLUME CHECK?
		UCB$W_MS_XSR0(R5),134$	;
	BISW	#UCB$M_MS_VCK,UCB$W_DEVSTS(R5) ;YES,RECORD IT
134$:
	BBC	#MS_XSR0_V_WLE,-	;CHECK IF WRITE LOCK ERROR
		UCB$W_MS_XSR0(R5),136$	;
	BISW	#<MT$M_HWL@-16>,UCB$L_DEVDEPEND+2(R5) ;YES, SET FLAG
	MOVZWL	#SS$_WRITLCK,R0		;MARK AS WRITE-LOCKED ERROR
136$:					;
	BBS	#MS_XSR0_V_ONL,-	;CHECK IF ONLINE
		UCB$W_MS_XSR0(R5),138$	;BR IF YES
	MOVZWL	#SS$_MEDOFL,R0		;MARK MEDIUM OFFLINE
138$:					;
	BRW	FATALERR		;TAKE FATAL OR HARD ERROR RETURN

;
; RECOVERABLE ERROR(TAPE MOVED)
; RECOVERABLE ERROR(TAPE NOT MOVED)
;(TCC=4 OR 5)

140$:					;

150$:					;
	BBS	#IO$V_INHRETRY,UCB$W_FUNC(R5),155$ ;IF SET, RETRY INHIBITED
	CVTWL	@UCB$L_DPC(R5),-(SP)	;GET BRANCH DISPLACEMENT
	ADDL	(SP)+,UCB$L_DPC(R5)	;CALCULATE RETURN ADDRESS -2
	ADDL	#2,UCB$L_DPC(R5)	;ADUST TO CORRECT RETURN ADDRESS
	JMP	@UCB$L_DPC(R5)		;RETURN TO DRIVER

155$:	BRW	170$			;RETURN AS FATAL

.PAGE
.SBTTL	TS11/TS04 INTERRUPT SERVICE ROUTINE
;+
; TS$INT - TS11/TS04 MAGTAPE INTERRUPTS
;
; THIS ROUTINE IS ENTERED VIA A JSB INSTRUCTION WHEN AN INTERRUPT OCCURS
; ON TS11/TS04 CONTROLLER. THE STATE OF THE STACK ON ENTRY IS:
;
;	00(SP) = ADDR. OF IDB ADDRESS
;	04-28(SP) = SAVED R0-R5
;	32(SP) = INTERRUPT PC
;	36(SP) = INTERRUPT PSL
;
; INTERRUPT DISPATCHING OCCURS AS FOLLOWS:
;
;(MUMBLE)
;
;-

TS$INT::
	MOVL	@(SP)+,R3		;GET ADDR. OF IDB
	MOVQ	IDB$L_CSR(R3),R4	;GET CONTROLLER CSR AND UCB ADDR.
	MOVL	UCB$L_MS_TSPT1(R5),R0	;COMMAND PACKET ADDR. IN R0
	MOVW	(R4),UCB$W_MS_TSBA(R5)	;GET DEVICE REGISTER TSBA(TSDB)
	MOVW	2(R4),UCB$W_MS_TSSR(R5)	;GET TSSR INTO UCB
	BBCC	#UCB$V_INT,UCB$W_STS(R5),10$ ;IF CLR, INTERRUPT NOT EXPECTED
	MOVW	MS_MHD(R0),UCB$W_MS_MHD(R5) ;SAVE MSG BUFFER IN UCB
	MOVL	MS_LNH(R0),UCB$W_MS_LNH(R5) ;SAVE NEXT LONG WORD
	MOVQ	MS_XSR0(R0),UCB$W_MS_XSR0(R5) ;SAVE REST OF MSG BUFFER
	MOVL	UCB$L_FR3(R5),R3	;RESTORE REMAINING DRIVER CONTEXT
	JSB	@UCB$L_FPC(R5)		;CALL DRIVER
5$:
	MOVQ	(SP)+,R0		;RESTORE REGISTERS
	MOVQ	(SP)+,R2		;
	MOVQ	(SP)+,R4		;
	REI				;RETURN FROM INTERRUPT

;
; NON-QIO RESPONSE INTERRUPT
;

10$:
	BBSC	#UCB$V_MS_LBA,UCB$W_DEVSTS(R5),20$ ;YES. LOADING BUFFER ADDR.?
	BRB	5$			; Branch to dismiss interrupt.

;
; HERE, WAS LOADING BUFFER ADDRESS
;
20$:
	BBS	#MS_TSSR_V_NBA,-
		UCB$W_MS_TSSR(R5),5$	;FAIL TO LOAD BUFFER ADDR.
;
; BUFFER ADDRESS LOADED SUCESSFULLY
; DO RELEASE MESSAGE BUFFER TO TS11/TS04
;
30$:
					;**MUST BE AT BOT
	BISW	#<MT$M_BOT@-16>,UCB$L_DEVDEPEND+2(R5) ;MARK IT
	BBC	#UCB$V_POWER,UCB$W_STS(R5),35$ ;BR IF NOT POWERFAIL
	BBS	#UCB$V_MS_RPI,UCB$W_DEVSTS(R5),35$ ;BR IF REPOSITION IN PROGRESS
	BBC	#UCB$V_MS_SWE,UCB$W_DEVSTS(R5),34$ ;BR IF NOT SOFTWARE EMULATION
	MOVL	UCB$L_MS_PMPR(R5),UCB$L_MS_TPOSITN(R5) ;GET FROM ELSEWHERE
	BRB	35$
34$:
	MOVL	UCB$L_MS_RECORD(R5),UCB$L_MS_TPOSITN(R5) ;SAVE TAPE POSITION
35$:
	CLRL	UCB$L_MS_RECORD(R5)	;
					; WHICH TELL TAPE POSITION
	BRW	5$			;DO RETURN FROM INTERRUPT


.PAGE
.SBTTL	TIMEOUT HANDLER
;+MSTMO - HANDLES TIME-OUT WHEN TS11/TS04 DOES NOT INTERRUPT AFTER
; A HARDWARE COMMAND ISSUED FOR A SPECIFIED PERIOD OF TIME.
; THE ROUTINE DEALLOCATES DATA PATH AND MAP REGISTER IF IT'S DATA
; TRANSFER COMMAND, AND ABORTS THE I/O OPERATION.
; IF IT WAS DUE TO POWERFAIL, REPOSITIONING IS ATTEMPTED, AND
; THE TIME-OUTED IRP IS RE-ISSUED
; 
; INPUT:
;
; OUTPUT:

	.ENABL	LSB			;ENABLE LOCAL SYMBOL
MSTMO:
	SETIPL	UCB$B_FIPL(R5)		;LOWER IPL TO DEVICE FORK LEVEL
			;**ASSUME NO PURGING OF DATAPATH FOR TIMEOUT**
	BBCC	#UCB$V_MS_RDPR,UCB$W_DEVSTS(R5),1$ ;BR IF DATAPATH NOT REQUESTED
	RELDPR				;RELEASE DATA PATH
1$:
	RELMPR				;RELEASE MAP REGISTERS
	BRB 2$				;
;
; TIMEOUT FOR NON-I/O XFR OPERATION
;

MSTMO1:
	SETIPL	UCB$B_FIPL(R5)		;LOWER IPL TO DEVICE FORK LEVEL
2$:
	BBSC	#UCB$V_POWER,-		; Branch around to reposition if
		UCB$W_STS(R5),5$	;  we had POWERFAIL.
	BRW	90$
;
; HERE, CHECK DRIVE OFF-LINE UNLOADED OR NOT
;

5$:
	BSBW	TEST_NBA		; Test to assure we DON'T need TS11
					;  message buffer address loaded.
	BLBS	R0,6$			; LBS implies TS11 READY and able.
	BRW	FATALERR		; If TS11 not ready, we can't even
					;  try to reposition.
6$:
	MFPR	#PR$_TODR,R0		;GET CURRENT TIME OF DAY
	ADDL	#1500,R0		;ADD 15 SEC. TO WAIT
	MOVL	R0,UCB$W_BOFF(R5)	;STORE IT IN UCB
;
; HERE, GET TS11'S CSR EQUIVALENT INTO R4
;

7$:
	DSBINT				;DISABLE INTERRUPTS
	WFIKPCH	8$,#2			;WAITFOR INTERRUPT OR TIMEOUT
	IOFORK				;
8$:
	SETIPL	UCB$B_FIPL(R5)		;LOWER IPL TO FORK LEVEL
	EXHC	FAIL,HC_RWD		;DO A REWIND
	BRW	9$			;BR IF SUCCESS=>DRIVE ONLINE
FAIL:
;
; HERE, TO SEND MESSAGE TO OPERATOR TO INFORM DRIVE OFFLINE
;
 
	MFPR	#PR$_TODR,R0		;GET CURRENT TIME OF DAY
	CMPL	R0,UCB$W_BOFF(R5)	;15 SEC. PASSED?
	BLEQU	7$			;NO , GO TRY AGAIN
	
	
	MOVZBL	#MSG$_DEVOFFLIN,R4	;SET MESSAGE NUMBER
	MOVAB	G^SYS$GL_OPRMBX,R3	;GET ADDRESS OF OPERATOR MAILBOX
	JSB	G^EXE$SNDEVMSG		;SEND MESSAGE TO OPERATOR
	BRW	6$			;
;
	
; OTHERWISE DO REPOSITIONING TAPE
;
9$:
	BISW	#UCB$M_MS_RPI,UCB$W_DEVSTS(R5) ;FLAG REPOSITION IN PROGRESS
	EXHC	50$,HC_RWD		;DO REWIND 1ST
					; & CLEAR UCB$L_MS_RECORD
10$:
	CMPL	UCB$L_MS_RECORD(R5),UCB$L_MS_TPOSITN(R5) ;CHECK REPOSITIONING
	BEQL	80$			;BR IF YES
	CMPL	UCB$L_MS_RECORD(R5),UCB$L_MS_TPOSITN(R5) ;IS IT GTR THAN
	BGTR	50$			;BR IF YES
	SUBL3	UCB$L_MS_RECORD(R5),UCB$L_MS_TPOSITN(R5),R0 ;GET WHAT'S LEFT
	CMPL	#^X7FFF,R0		;LESS THAN 32,768?
	BGTR	20$			;BR IF YES
	MOVW	#^X7FFF,UCB$W_MS_SPACNT(R5) ;SKIP 32,768 RECORDS TILL DONE
	BRB	30$			;
20$:
	MOVW	R0,UCB$W_MS_SPACNT(R5)	;SKIP WHAT'S LEFT
30$:
	EXHC	50$,HC_SRF		;
	MOVZWL	UCB$W_MS_XC(R5),R1	;GET NO. OF RECORDS PASSED
	ADDL	R1,UCB$L_MS_RECORD(R5)	;UPDATE TAPE POSITION
	BRB	10$			;GO BACK
50$:
	BICW	#UCB$M_MS_RPI,UCB$W_DEVSTS(R5) ;CLEAR FLAG, REPOSI. FAILED
	JMP	FATALER0		;
;
; HERE, GO AHEAD WITH THE CURRENT QIO
;
80$:
	BICW	#UCB$M_MS_RPI,UCB$W_DEVSTS(R5) ;CLEAR FLAG,REPOSITION DONE
	MOVL	UCB$L_IRP(R5),R3	;R3 HAS IRP ADDRESS
	MOVQ	IRP$L_SVAPTE(R3),UCB$L_SVAPTE(R5) ;RESTORE XFER PARAMETERS
	JMP	TS_STARTIO
90$:
	JSB	G^ERL$DEVICTMO		;LOG TIMEOUT ERROR
	MOVZWL	#SS$_TIMEOUT,R0		;SET TIMEOUT STATUS
	REQCOM				;GO COMPLETE I/O REQUEST PROCESSING

	.DSABL	LSB
.PAGE
.SBTTL	TS11/TS04 REGISTER DUMP ROUTINE
;+
; TS_REGDUMP - TS11/TS04 REGISTER DUMP ROUTINE
;
; THIS ROUTINE IS CALLED TO SAVE THE CONTROLLER AND DRIVE REGISTERS IN A
; SPECIFIED BUFFER. IT IS CALLED FROM THE DEVICE ERRORLOGGING ROUTINE AND
; FROM THE DIAGNOSTIC BUFFER FILL ROUTINE
;
; INPUT:
;	R0 = ADDRESS OF REGISTER SAVE BUFFER
;	R4 = ADDRESS OF CSR (EQUIVALENT)
;	R5 = UCB ADDRESS
;
; OUTPUT:
;
; THE CONTROLLER AND DRIVE REGISTERS ARE SAVED IN THE SPECIFIED BUFFER
;-

TS_REGDUMP:
	MOVL	#23,(R0)+		;23 REGISTERS FOLLOW TO BE DUMPED
	MOVZWL	UCB$W_MS_TSBA(R5),(R0)+	;GET TSBA
	MOVZWL	UCB$W_MS_TSSR(R5),(R0)+	;GET TSSR
	MOVZBL	UCB$B_MS_DPN(R5),(R0)+	;GET DATAPATH NO.
	MOVL	UCB$L_MS_DPR(R5),(R0)+	;GET DATAPATH REG.
	MOVL	UCB$L_MS_FMPR(R5),(R0)+	;GET FINAL MAP REGISTER
	MOVL	UCB$L_MS_PMPR(R5),(R0)+	;GET FINAL-1 MAP REGISTER
	MOVL	UCB$L_MS_NMPR(R5),(R0)+	;GET FINAL+1 MAP REGISTER
	MOVL	UCB$L_MS_TSPT1(R5),R1	;GET MESSAGE BUFFER ADDR
	MOVZBL	#15,R2			;15 WORDS IN MSG BUFFER
10$:
	MOVZWL	(R1)+,(R0)+		;COPY FROM MSG BUFFER
			;**FROM MS_CPHD TO MS_XSR3, SEE $DEFINI MS**
	SOBGTR	R2,10$			;LOOP BACK
	MOVZBL	UCB$B_MS_PER(R5),(R0)+	;GET PURGE ERROR INDICATOR
	RSB				;

TS_END:					;ADDRESS OF LAST LOCATION IN DRIVER

	.END
