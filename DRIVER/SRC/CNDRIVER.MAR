	.TITLE	CNDRIVER - VAX/VMS DECnet-CI Class Driver
	.IDENT	'V03-002'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1982                                                      *
;*  BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.			    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED  *
;*  ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE  *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER  *
;*  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY  *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY  *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE  *
;*  AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT  *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS  *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;*									    *
;****************************************************************************
;++
; FACILITY:
;
;	VAX/VMS DECnet-CI class driver
;
; ABSTRACT:
;
;	This module contains the DECnet-CI class driver FDT routines,
;	SCS dispatcher, and fork routines.
;
; AUTHOR:
;
;	Kerbey T. Altmann, 17-Aug-1981
;
; MODIFIED BY:
;
;	V03-002	KTA0094			Kerbey T. Altmann	11-Apr-1982
;		Remove all debug hooks and clean up for final version.
;
;--
	.PAGE
	.SBTTL	External and local symbol definitions

;
; System definitions
;

	.nocross
	$ADPDEF				; Adapter control block
	$CDRPDEF			; Class Driver Request Packet
	$CDTDEF				; Connection descriptor
	$CRBDEF				; Channel request block
	$CXBDEF				; Complex buffers
	$DCDEF				; Device classes and types
	$DDBDEF				; Device data block
	$DEVDEF				; Device characteristics
	$DPTDEF				; Driver prologue table defs
	$DYNDEF				; Control block defs
	$IODEF				; I/O function codes
	$IPLDEF				; Hardware IPL definitions
	$JIBDEF				; Job info block
	$IRPDEF				; I/O request packet
	$NMADEF				; Network Management definitions
	$PBDEF				; Path block defininitions
	$PCBDEF				; Process control block
	$PDTDEF				; Port Descriptor Table
	$SBDEF				; System block definitions
	$SSDEF				; System status codes
	$UCBDEF				; Unit control block
	$VECDEF				; Interrupt vector block
	$XMDEF				; XMDRIVER symbols

;
; Local macros
;
	.MACRO	SETBIT	POS,BAS,?L	; Set a single bit
		BBSS	POS,BAS,L
	L:
	.ENDM	SETBIT
 
	.MACRO	CLRBIT	POS,BAS,?L	; Clear a single bit
		BBCC	POS,BAS,L
	L:
	.ENDM	CLRBIT
 
	.MACRO	INCC	COUNTER,CONTEXT=L,?L  ; Increment counter
		INC'CONTEXT	COUNTER	; Do Increment
		BCC	L		; Br if no carry set
		DEC'CONTEXT	COUNTER	; Leave at maximum value
	L:
	.ENDM	INCC
 
	.MACRO	PUSHQ	ARG		; Push a quadword
		MOVQ	ARG,-(SP)	; Save argument on stack
	.ENDM	PUSHQ
 
	.MACRO	POPQ	ARG		; Pop a quadword
		MOVQ	(SP)+,ARG	; Restore argument
	.ENDM	POPQ
 
	.MACRO	PARAM	TYPE,OFFSET,WIDTH,MIN,MAX,REQUIRED,INVALID,BASE
			; NOTE - The REQUIRED field can only check 1 bit!
	.IF BLANK TYPE
	.WORD	0
	.IF_FALSE
	$$$TYP = TYPE & PRM_M_TYPE		; Isolate type code
	.IIF NOT_BLANK	<MIN>, $$$TYP = $$$TYP!PRM_M_MIN
	.IIF NOT_BLANK	<MAX>, $$$TYP = $$$TYP!PRM_M_MAX
	.IIF NOT_BLANK	<REQUIRED>, $$$TYP = $$$TYP!PRM_M_REQUIRE
	.IIF NOT_BLANK	<INVALID>, $$$TYP = $$$TYP!PRM_M_INVALID
		.WORD	$$$TYP
	$$$OFF = OFFSET & OFF_M_VALUE		; Isolate offset only
	$$$WID = 0				; Set null width
	.IIF IDN <WIDTH><B>, $$$WID = <1@OFF_V_WIDTH>
	.IIF IDN <WIDTH><W>, $$$WID = <2@OFF_V_WIDTH>
	.IIF IDN <WIDTH><L>, $$$WID = <3@OFF_V_WIDTH>
		.WORD	$$$OFF!$$$WID
		.WORD	MIN
		.WORD	MAX
		.WORD	REQUIRED
		.WORD	INVALID
	'BASE'_PRM_BUFSIZ = 'BASE'_PRM_BUFSIZ + 6
	.ENDC
	.ENDM	PARAM
 
	.MACRO	COUNT	TYPE,BITMAP=NO,WIDTH=8,BASE
	$$$TYP = TYPE & NMA$M_CNT_TYP
	.IIF IDN <BITMAP><YES>, $$$TYP = $$$TYP!<NMA$M_CNT_MAP>
	$$$WID = 0			; Set reserved mask width
	.IIF IDN <WIDTH><8>, $$$WID = <1@NMA$V_CNT_WID>
	.IIF IDN <WIDTH><16>, $$$WID = <2@NMA$V_CNT_WID>
	.IIF IDN <WIDTH><32>, $$$WID = <3@NMA$V_CNT_WID>
	.IIF EQ $$$WID, .ERROR		; Invalid bit width value
	.WORD	NMA$M_CNT_COU!$$$WID!$$$TYP
	'BASE'_CNT_BUFSIZ = 'BASE'_CNT_BUFSIZ + 2 + <WIDTH/8>
	.IIF IDN <BITMAP><YES>, 'BASE'_CNT_BUFSIZ = 'BASE'_CNT_BUFSIZ + 2
	.ENDM	COUNT
 
	.cross
 
;
; Local symbols
;

;
; $QIO parameter offsets
;

P1	= 0				; Parameter 1
P2	= 1*4				; Parameter 2
P6	= 5*4				; Parameter 6

;
; Other constants
;

DEF_RBF = 6				; Default number of receive buffers
CN_DEF_BUFSIZ	= 512			; Default buffer size
MAX_TRB		= 16			; Max tributaries on CI device
DSC$A_POINTER   = 4			; Descriptor buffer address field
	.PAGE
;
; Overlays of IRP
;
	$DEFINI	IRP
 
. = IRP$Q_NT_PRVMSK			; Overlay network priv mask
 
$DEF	IRP$B_INDEX	.BLKB	1	; Vector index for CDB

. = IRP$L_EXTEND

$DEF	IRP$L_CDB	.BLKL	1

	$DEFEND	IRP			; End of IRP overlays
	.PAGE
;
; Definitions that follow the standard UCB fields
;

	$DEFINI	UCB			; Start of UCB definitions

. = UCB$C_LENGTH			; Position at end of UCB

$DEF	UCB$L_LIS_CDT	 .BLKL	1	; Addr of listening CDT
$DEF	UCB$L_TWIN_CDT	 .BLKL	1	; Addr of loopbacked accept CDT
$DEF	UCB$L_DGHDRSZ	 .BLKL	1	; Size of the SCS header for DG's
 
$DEF	UCB$B_CN_TRB_CNT .BLKB	1	; Number of active tributaries
$DEF	UCB$B_CN_PORT	 .BLKB	1	; Our port number
$DEF	UCB$W_CN_RCV_CNT .BLKW	1	; Number of receive buffers
 
$DEF	UCB$B_CN_VC_OPEN .BLKB	<<MAX_TRB+7>/8>	; Virtual circuit OPEN vector
			 .BLKW	1
$DEF	UCB$L_CN_CDB_VEC .BLKL	MAX_TRB	; CDB address vector
$DEF	UCB$W_CN_CHAN_VEC .BLKW MAX_TRB ; Channel number lookup vector
VEC_LEN=.-UCB$B_CN_VC_OPEN
 
			LC=.
			.=<LC+15>&-16	
$DEF	UCB$C_CN_LENGTH			; Size of CNDRIVER UCB
 
;
; Define device status bits
;
	$VIELD	UCB,0,<-		; CNDRIVER UCB$W_DEVSTS bits
		<CN_INITED,,M>,-	; Device init'ed
		>			;

	$DEFEND	UCB			; End of UCB definitions
	.PAGE
;
; CNDRIVER CDB definitions
;

	$DEFINI	CDB

.=CDRP$C_LENGTH

$DEF	CDB_L_CONN_IRP	.BLKL	1	; Ptr to the IRP used in a CONNECT

$DEF	CDB_Q_QUEUES			; Message and I/O request queue heads
$DEF	CDB_Q_XMT_REQ	.BLKQ	1	; Transmit I/O requests waiting
$DEF	CDB_Q_RCV_REQ	.BLKQ	1	; Receive I/O requests awaiting message
$DEF	CDB_Q_RCV_MSG	.BLKQ	1	; Receive buffers containing messages
CDB_C_ABRT_Q = <.-CDB_Q_QUEUES>/8	; Number of queue to abort
$DEF	CDB_Q_XMT_PND	.BLKQ	1	; Transmit I/O requests to be posted
CDB_C_QUEUES = <.-CDB_Q_QUEUES>/8	; Number of queue heads in CDB

$DEF	CDB_L_DG_BUF	.BLKL	1	; Ptr to DG buffer (CDRP$L_MSG_BUF)
$DEF	CDB_L_UCB	.BLKL	1	; Addr of UCB
$DEF	CDB_L_CDT	.BLKL	1	; Ptr to CDT (CDRP$L_MSG_BUF)
$DEF	CDB_W_STS	.BLKW	1	; Circuit status
$DEF	CDB_W_BUFSIZ	.BLKW	1	; Buffer size
$DEF	CDB_L_DEVDEPEND	.BLKL	1	; Circuit dependent status
$DEF	CDB_B_RCV_CNT	.BLKB	1	; Receive buffer count
$DEF	CDB_B_RCV_FQ	.BLKB	1	; Receive buffers on free queue
$DEF	CDB_B_THRES	.BLKB	1	; Buffer threshold to send XOFF
$DEF	CDB_B_TRB_ADDR	.BLKB	1	; Tributary address

$DEF	CDB_L_CNTS			; Start of counters area of CDB
$DEF	CDB_L_BRC	.BLKL	1	; Receive byte count
$DEF	CDB_L_BSN	.BLKL	1	; Transmit byte count
$DEF	CDB_L_DMR	.BLKL	1	; Receive message count
$DEF	CDB_L_DMS	.BLKL	1	; Transmit message count
CDB_C_CNTS = .-CDB_L_CNTS		; Size of counter section of CDB

CDB_L_DGCDRP = CDB_L_CDT-CDRP$L_CDT	; Start of DATAGRAM CDRP

$DEF	CDB_L_DISC_IRP	.BLKL		; IRP for DISC qiow

$DEF	CDB_W_RCV_MV	.BLKW

			LC=.
			.=<LC+15>&-16	
$DEF	CDB_C_LENGTH			; Size of CNDRIVER CDB

;
; Define status bits used in CDB_B_STS
;
 
	_VIELD	CDB,0,<-		; Tributary status bits for CDB_W_STS
		<ESTB,,M>,-		; Tributary established
		<STRT,,M>,-		; Tributary starting
		<ACPT,,M>,-		; Tributary did an ACCEPT
		<DISC,,M>,-		; Tributary DISCONNECTing
		<MOP,,M>,-		; Tributary is in MOP mode
		<DSCB,,M>,-		; Tributary to be disconnected
		<CLRC,,M>,-		; Clear CDB and release
		<WAIT,,M>,-		; Wait for DISCONNECT
		<XOFF,,M>,-		; Trib is XOFFed
		<XFSN,,M>,-		; XOFF sent to other side
		>			;

	$DEFEND	CDB
	.PAGE
	.SBTTL	Standard tables

;
; Driver prologue table
;

	DPTAB	-				; DPT-creation macro
		END=CN_END,-			; End of driver label
		ADAPTER=NULL,-			; Adapter type
		FLAGS=DPT$M_SCS,-		; Driver requires SCS
		UCBSIZE=<UCB$C_CN_LENGTH>,-	; Length of UCB
		NAME=CNDRIVER,-			; Driver name
 
	DPT_STORE INIT				; Start of load
						; initialization table
	DPT_STORE UCB,UCB$B_FIPL,B,8		; Device fork IPL
	DPT_STORE UCB,UCB$B_DIPL,B,8		; Device interrupt IPL
	DPT_STORE UCB,UCB$L_OWNUIC,L,65537	; [1,1] owns the device
	DPT_STORE UCB,UCB$L_DEVCHAR,L,<-	; Device characteristics
		DEV$M_NET!-			;   e.g., network device
		DEV$M_REC!-			;   record oriented
		DEV$M_IDV!-			;   input device
		DEV$M_ODV>			;   output device
	DPT_STORE UCB,UCB$B_DEVCLASS,B,DC$_SCOM	; Sample device class
	DPT_STORE UCB,UCB$W_DEVBUFSIZ,@W,-	; Default buffer size
		SCS$GW_MAXDG
 
	DPT_STORE REINIT			; Start of reload
						; initialization table
	DPT_STORE DDB,DDB$L_DDT,D,CN$DDT	; Address of DDT
	DPT_STORE CRB,-				; Address of device
		CRB$L_INTD+VEC$L_UNITINIT,-	; unit initialization
		D,UNIT_INIT			; routine

	DPT_STORE END				; End of initialization
						; tables

;
; Driver dispatch table
;

	DDTAB	-				; DDT-creation macro
		DEVNAM=CN,-			; Name of device
		FUNCTB=CN_FUNCTABLE,-		; FDT address
		CANCEL=CANCEL,-			; Cancel I/O routine
		REGDMP=REG_DUMP,-		; Register dump routine
		DIAGBF=<36+8>,-			; Diagnostic buffer sizing
		ALTSTART=ALT_START		; Alternate start I/O

;
; Function dispatch table
;

CN_FUNCTABLE:					; FDT for driver
	FUNCTAB	,-				; Valid I/O functions
		<READVBLK,-			; Read virtual
		READLBLK,-			; Read logical
		READPBLK,-			; Read physical
		WRITEVBLK,-			; Write virtual
		WRITELBLK,-			; Write logical
		WRITEPBLK,-			; Write physical
		SETMODE,-			; Set device mode
		SENSEMODE,-			; Sense mode
		SETCHAR>			; Set device chars.
	FUNCTAB	,-				; Buffered functions:
		<READVBLK,-			; Read virtual
		READLBLK,-			; Read logical
		READPBLK,-			; Read physical
		WRITEVBLK,-			; Write virtual
		WRITELBLK,-			; Write logical
		WRITEPBLK>			; Write physical
	FUNCTAB	RCV_FDT,-			; FDT read routine for
		<READVBLK,-			; read virtual,
		READLBLK,-			; read logical,
		READPBLK>			; and read physical.
	FUNCTAB	XMT_FDT,-			; FDT write routine for
		<WRITEVBLK,-			; write virtual,
		WRITELBLK,-			; write logical,
		WRITEPBLK>			; and write physical.
	FUNCTAB	SETMODE_FDT,-			; FDT set mode routine
		<SETMODE,SETCHAR>		; for set mode, set char.
	FUNCTAB SENSEMODE_FDT,-			; FDT sense mode routine
		<SENSEMODE>			; for sensemode 
	.PAGE
	.SBTTL	P2 buffer verification tables
 
;
; Define P2 buffer verification offsets
;
PARAM_C_SKIP=2*5
	$DEFINI	PARAM
 
	_VIELD	PRM,0,<-			; Parameter bits and sizes
		<TYPE,12,M>,-			; Parameter type
		<MIN,1,M>,-			; Parameter minimum value
		<MAX,1,M>,-			; Parameter maximum value
		<REQUIRE,1,M>,-			; Parameter required flags
		<INVALID,1,M>,-			; Parameter invalid flags
		>
 
	_VIELD	OFF,0,<-			; Offset word fields
		<VALUE,14,M>,-			; Offset value
		<WIDTH,2,M>,-			; Size of field in structure
		>
 
	$DEFEND	PARAM
 
 
;
; Define CDB parameters
;
TRIB_PRM_BUFSIZ	= 0				; Trib parameter buffer size
TRIB_PARAM:					; Start of trib parameters
 
	PARAM	NMA$C_PCCI_TRI,-		; Trib address
		OFFSET=CDB_B_TRB_ADDR,-
		WIDTH=B,-
		MIN=0,-
		MAX=15,-
		REQUIRED=0,-
		INVALID=CDB_M_ESTB,-		; Trib can't be established
		BASE=TRIB
 
	PARAM	NMA$C_PCCI_MRB,-		; Trib max buf
		OFFSET=CDB_L_UCB,-		; Dummy location
		WIDTH=B,-
		MIN=0,-
		MAX=255,-
		REQUIRED=0,-
		INVALID=CDB_M_ESTB,-		; Trib can't be established
		BASE=TRIB
 
	PARAM	NMA$C_PCCI_MST,-		; Trib maint state
		OFFSET=CDB_L_UCB,-		; Dummy location
		WIDTH=B,-
		MIN=NMA$C_STATE_ON,-
		MAX=NMA$C_STATE_OFF,-
		REQUIRED=0,-
		INVALID=CDB_M_ESTB,-		; Trib can't be established
		BASE=TRIB
 
	PARAM

;
; Define UCB parameters
;
LINE_PRM_BUFSIZ = 0
LINE_PARAM:

	PARAM	NMA$C_PCLI_BUS,-		; Block size
		OFFSET=UCB$W_DEVBUFSIZ,-
		WIDTH=W,-
		MIN=32,-
		MAX=948,-
		REQUIRED=0,-
		INVALID=UCB$M_CN_INITED,-
		BASE=LINE

	PARAM	NMA$C_PCLI_DUP,-		; Duplex
		OFFSET=UCB$L_MAXBLOCK,-		; Just dump it
		WIDTH=B,-
		MIN=NMA$C_DPX_FUL,-
		MAX=NMA$C_DPX_HAL,-
		REQUIRED=0,-
		INVALID=UCB$M_CN_INITED,-
		BASE=LINE

	PARAM	NMA$C_PCLI_CON,-		; Controller mode
		OFFSET=UCB$L_MAXBLOCK,-		; Just dump it
		WIDTH=B,-
		MIN=NMA$C_LINCN_NOR,-
		MAX=NMA$C_LINCN_LOO,-
		REQUIRED=0,-
		INVALID=UCB$M_CN_INITED,-
		BASE=LINE

	PARAM	NMA$C_PCLI_BFN,-		; Maximum receive buffers
		OFFSET=UCB$W_CN_RCV_CNT,-
		WIDTH=B,-
		MIN=1,-
		MAX=255,-
		REQUIRED=0,-
		INVALID=UCB$M_CN_INITED,-	; Line can't be STARTING
		BASE=LINE


	PARAM					; End of trib tables

;
; Tributary counter type codes
;
TRIB_CNT_BUFSIZ	= 0
TRIB_COUNTER:

	COUNT	NMA$C_CTCIR_BRC,-		; Bytes received
		WIDTH=32,BASE=TRIB

	COUNT	NMA$C_CTCIR_BSN,-		; Bytes sent
		WIDTH=32,BASE=TRIB

	COUNT	NMA$C_CTCIR_DBR,-		; Data blocks received
		WIDTH=32,BASE=TRIB

	COUNT	NMA$C_CTCIR_DBS,-		; Data blocks sent
		WIDTH=32,BASE=TRIB

;
; Our SCS process name
;
PROC_NAM:
	.ASCII	/DECNET$PHASE_III/		; How SCS knows us
	.PAGE
	.SBTTL	UNIT_INIT,  Unit initialization routine

;++
; UNIT_INIT - Readies unit for I/O operations
;
; Functional description:
;
;	The operating system calls this routine after calling the
;	controller initialization routine:
;
;		at system startup
;		during driver loading
;		during recovery from a power failure
;
;	The unit is put online.
;
; Inputs:
;
;	R5 = UCB address
;
; Outputs:
;
;	R0 destroyed
;
;--

UNIT_INIT:					; Initialize unit
	BISW	#UCB$M_ONLINE,UCB$W_STS(R5)	; Set unit online
	RSB					; Return
	.PAGE
	.SBTTL	XMT_FDT,  Transmit I/O Operation FDT Routine

;++
; XMT_FDT - Transmit I/O Operation FDT Routine
;
; Functional description:
;
; This routine is called by the SYS$QIO system service to dispatch a
; WRITE I/O request.
;
; The QIO parameters for WRITEs are:
;
;	P1 = address of the buffer
;	P2 = size of the buffer
;	All other parameters are unused.
;
; The buffer is validated for access and locked into memory. The I/O operation
; is started if possible else it is blocked temporarily on one of the various
; wait queues of the UCB or CDB.
;
;
; Inputs:
;
;	R3	- IRP address (I/O request packet)
;	R4	- PCB address (process control block)
;	R5	- UCB address (unit control block)
;	R6	- CCB address (channel control block)
;	R7	- bit number of the I/O function code
;
;	IPL = ASTDEL (2)
;
; Outputs:
;
;	R0 = status of transmit request initiation
;
;	R3-R7 are preserved.
;
;--

	.enable lsb
45$:	MOVZWL	#SS$_INSFMEM,R0			; Set error code
	POPR	#^M<R3,R4,R5>
10$:	BRW	STRT_FIN			; Finish up else where

XMT_FDT:					; Transmit FDT routine
	MOVZWL	S^#SS$_BADPARAM,R0		; Assume bad parameters
	MOVZWL	P2(AP),R1			; Get buffer size
	BEQL	10$				; Br if zero - abort I/O
	CMPW	R1,UCB$W_DEVBUFSIZ(R5)		; Is buffer too big?
	BGTRU	10$				; Br if yes - abort I/O
	MOVL	P1(AP),R0			; Get user buffer virtual address
	MOVL	R0,IRP$L_SVAPTE(R3)		; Point at user data
	JSB	G^EXE$WRITECHK			; Check access and lock pages
						; (no return means no acess)
;
; Copy user's data to a SCS DG buffer.  This is necessary since
; SCS requires a header on the front of the message.
;
	MOVQ	R4,-(SP)			; Save registers
	MOVAB	CXB$C_OVERHEAD(R1),R1		; Pick up overhead
	PUSHL	R3				; Save register
	JSB	G^EXE$BUFFRQUOTA		; Check if process has sufficient quota
	BLBC	R0,45$				; If LBC quota check failure
	JSB	G^EXE$ALONONPAGED		; Allocate buffer for output
	BLBC	R0,45$				; If LBC allocation failure
	MOVL	(SP),R3				; Retrieve address of IRP
	MOVL	PCB$L_JIB(R4),R0		; Get JIB address
	SUBW	R1,JIB$L_BYTCNT(R0)		; Adjust buffered I/O quota
	MOVW	R1,IRP$W_BOFF(R3)		; Set number of bytes charged to quota
	PUSHL	R2				; Save start address
	ADDL3	#<DYN$C_CXB@16>,R1,-
		 IRP$W_SIZE(R2)			; Set the size
	SUBL2	#CXB$C_HEADER,R1		; Account for header
	MOVC3	R1,@IRP$L_SVAPTE(R3),-
		 CXB$C_HEADER(R2)		; Move characters to system buffer
	MOVQ	(SP)+,R2			; Restore start address + IRP
	MOVL	R2,IRP$L_SVAPTE(R3)		; Save buffer address
	MOVQ	(SP)+,R4			; Restore UCB address
	SETIPL	UCB$B_FIPL(R5)			; Sync acces to UCB
	PUSHAB	W^STRT_FIN			; "Ret addr" to finish up at
						; Fall thru to XMT_START
	.PAGE
	.SBTTL	XMT_START,  Start Transmit Operation
 
;++
; XMT_START - Start Transmit Operation
;
; Functional description:
;
; This routine is called to start a transmit operation. If the tributary
; is running and there are not too many transmit requests already pending,
; then the request is given to the device to transmit immediately if possible.
;
; If the circuit is not running yet or the circuit has too many requests
; pending, then the request is queued to the CDB xmit wait queue.
;
; Inputs:
;
;	R3 = IRP address
;	R5 = UCB address
;
;	IPL = FIPL
;
; Outputs
;
;	R0 = status of transmit request
;
;	R3-R7 are preserved.
;
;--
 
XMT_START:
	BSBW	XLATE				; Get CDB address
	BLBC	R0,40$				; Br if error
	MOVZWL	#SS$_DEVOFFLINE,R0		; Assume trib shutting down
	ASSUME	CDB_V_ESTB EQ 0
	BLBC	CDB_W_STS(R9),40$		; Br if trib not established
;
; Insert entry on CDB transmit wait queue if circuit not running or
; there are too many transmit requests pending.
;
	BBC	#CDB_V_XOFF,-			; Br if trib is running
		 CDB_W_STS(R9),SEND_XMT
	INSQUE	(R3),@CDB_Q_XMT_REQ+4(R9)	; Insert IRP on CDB xmit wait queue
	MOVZWL	S^#SS$_NORMAL,R0		; Set success
	RSB					; And leave
 
;
; Send the buffer off to SCS
;
SEND_XMT:
	INSQUE	(R3),@CDB_Q_XMT_PND+4(R9)	; Insert IRP on CDB xmit wait queue
	MOVL	UCB$L_PDT(R5),R4		; Recover the PDT
	MOVL	IRP$L_BCNT(R3),R1		; Pick up length
	MOVL	IRP$L_SVAPTE(R3),R2		; Pick up head of buffer
	ADDL3	#<DYN$C_CIDG@16!^X20>,R1,-
		 <IRP$W_SIZE+^X18>(R2) 		; Make a header
	ADDL3	#CXB$C_HEADER,R2,-		; Transfer the address
		 CDB_L_DG_BUF(R9)
	MOVAL	CDB_L_DGCDRP(R9),R5		; Cover CDRP with correct reg
	SEND_DG_BUF  #1				; Send it and get it back
						; Control returns immediately
	MOVL	CDB_L_UCB(R5),R5		; Recover UCB
40$:	RSB					; Return to await completion

	.DISABLE LSB
	.PAGE
	.SBTTL	RCV_FDT,  Read I/O Operation FDT Routine

;++
; RCV_FDT - Read I/O Operation FDT Routine
;
; Functional description:
;
; This routine is called by the SYS$QIO system service to dispatch a
; READ I/O request.
;
; The QIO parameters for READs are:
;
;	P1 = address of the buffer
;	P2 = size of the buffer
;	All other parameters are unused.
;
; The specified buffer is checked for accessibility. The buffer address and
; count are saved in the packet. Then IPL is raised to device fork IPL and if
; a message is available the operation is complete. Otherwise the packet is
; queued onto the waiting receive list of the CDB.
;
; If the function specifies a modifier of IO$M_NOW, if no message is
; available when the test is made, a status of SS$_ENDOFFILE is
; returned.
;
; Inputs:
;
;	R3 = I/O Packet Address
;	R4 = PCB Address
;	R5 = UCB Address
;	R6 = CCB Address
;	R7 = Function Code
;	AP = Address of first operation-specific QIO parameter
;
;	IPL = ASTDEL (2)
;
; Outputs:
;
;	R0 = status of the receive QIO operation
;	R3-R7 - unchanged
;
;--

STRT_FIN:
	BLBC	R0,ABORTIO			; Br if error
QIORET:	JMP	G^EXE$QIORETURN			; Exit QIO and wait

ABORTCN:					; Abort connection request
	CLRL	IRP$L_SVAPTE(R3)		; Clear out any trash
ABORTIO:					; Abort the I/O request
	JMP	G^EXE$ABORTIO			; and exit QIO service

RCV_FDT:					; Read FDT process routine
;
; Check request parameters
;
	MOVZWL	S^#SS$_BADPARAM,R0		; Assume bad parameters
	MOVZWL	P2(AP),R1			; Get length of buffer
	BEQL	ABORTIO				; Br if zero - abort I/O
	MOVL	P1(AP),R0			; Get buffer address
	MOVL	R0,IRP$L_MEDIA(R3)		; Save buffer addr in IRP
	CLRW	IRP$W_BOFF(R3)			; No quota to return during completion
	JSB	G^EXE$READCHK			; Check accessibility
						; (No return on no access)
	SETIPL	UCB$B_FIPL(R5)			; Raise IPL to fork level
						;  to lock the data base
	BSBW	XLATE				; Get CDB address
	BLBC	R0,ABORTIO			; Error
	PUSHAB	STRT_FIN			; "Ret addr" of where to finish
						; Fall thru to RCV_STRT
	.DISABLE LSB 
	.PAGE
	.SBTTL	RCV_START,  Start Receive Operation
 
;++
; RCV_START - Start Receive Operation
;
; Functional description:
;
; At this point, the buffer is okay and we are now at fork IPL.  Now check
; to make sure the tributary has been established.  If not, we will return
; an SS$_DEVOFFLINE error status.  Note that the circuit need not be turned
; on in order to do a read request.
; 
; Inputs:
;
;	R3 = IRP address
;	R5 = UCB address
;	R9 = CDB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0 = return status of receive request
;	R3-R7 are preserved.
;
;--
 
RCV_START:
	MOVZWL	#SS$_DEVOFFLINE,R0		; Assume trib not established
	ASSUME	CDB_V_ESTB EQ 0
	BLBC	CDB_W_STS(R9),40$		; Br if trib not established
;
; Check to see if message is available
;
	REMQUE	@CDB_Q_RCV_MSG(R9),R2		; Dequeue a received message
	BVS	10$				; Br if none
;***
	DECW	CDB_W_RCV_MV(R9)		; Decrement the outstand count
	CMPB	CDB_W_RCV_MV(R9),-
		 CDB_B_THRES(R9)		; Did it bring us below threshold?
	BGTR	5$				; No, so don't even check
	BBCC	#CDB_V_XFSN,-			; Yes, check for XOFF
		 CDB_W_STS(R9),5$		; Send XON if XOFF outstanding
	PUSHR	#^M<R2,R3,R4,R5>		; Save registers
	CLRL	R0				; Set for XON
	MOVL	R9,R4				; Transfer CDB pointer
	BSBW	SEND_XMSG			; Send a message
	POPR	#^M<R2,R3,R4,R5>		; Restore registers
5$:
;***
;
; Complete the receive with available message
;
	MOVL	R9,R4				; Transfer CDB address
	BSBW	FINISH_RCV_IO			; Complete the I/O request
	BRB	30$				; and exit
;
; No message available.  If IO$M_NOW specified, return with SS$_ENDOFFILE
; status. Otherwise, queue IRP to await arrival of message and continue.
;
10$:	BBC	#IO$V_NOW,IRP$W_FUNC(R3),20$	; Branch if not READ NOW
	MOVZWL	#SS$_ENDOFFILE,R0		; Set no message status
	BSBW	IO_DONE				; Complete the I/O
	BRB	30$				; and exit
;
; Queue the IRP to CDB receive IRP wait queue
;
20$:	INSQUE	(R3),@CDB_Q_RCV_REQ+4(R9) 	; Queue IRP to await message
30$:	MOVZBL	S^#SS$_NORMAL,R0		; Set successful return
40$:	RSB					; Return
	.PAGE
	.SBTTL	ALT_START,  Alternate Start I/O Routine

;++
; ALT_START - Alternate Start I/O Routine
;
; Functional description:
;
; This entry point is used by the "internal IRP" interface.  IRP's
; which enter the driver at this point have not been pre-processed
; by our FDT routines.  These IRP's have been built by another
; driver and look exactly like a regular IRP.
;
; This routine, therefore, must do the same processing which the FDT
; routines would do if they had been called as in the case of a normal
; IRP.
;
; NOTE: The CHAN field of the IRP is sufficient to map to a CDB.
;
; Inputs:
;
;	R3 - IRP address
;	R5 - UCB address
;
;	All pertinent fields of the IRP are assumed to be valid.
;
;	IPL = FIPL
;
; Outputs:
;
;	R0 = status of the transmit/receive request.
;
;	R3-R5 are preserved.
;
;--
 
ALT_START:
	PUSHL	R9				; Save reg
	PUSHL	R4
	BBS	#IRP$V_FUNC,IRP$W_STS(R3),10$	; Br if read request
;
; WRITE
;
	BSBW	XMT_START			; Initiate the transmit
	BRB	30$				; Return

;
; READ
;
10$:	BSBW	XLATE				; Get CDB address
	BLBC	R0,40$				; Error
	MOVL	IRP$L_SVAPTE(R3),R2		; Pick up any buffer
	BEQL	20$				; None, continue
	CLRL	IRP$L_SVAPTE(R3)		; Clear out the buffer addr
	MOVL	R9,R4				; Transfer CDB pointer
	BSBW	ADDRCVLIST			; Add it to the free queue
20$:	BSBB	RCV_START			; Initiate the read
30$:	POPL	R4
	POPL	R9				; Restore reg
	BLBC	R0,40$				; Branch if error
	RSB					; Return to caller

40$:	BRW	IO_DONE				; Post the I/O request in error
	.PAGE
	.SBTTL	SETMODE_FDT,  Set mode I/O operation FDT routine
 
;++
; SETMODE_FDT - Set mode I/O operation FDT routine
;
; Functional description:
;
; This routine is used to set the configuration of the DMP11 hardware
; device.  Subfunction modifier bits are used to specify the type of
; action to be taken.  The characteristics buffer (P2) is used to
; to describe specific characteristics.  
;
; The QIO parameter for SETMODE is:
;
;	P2 = Optional address of buffer descriptor for extended characteristics
;
;
; The subfunction modifiers are as follows:
;
;
; 	o STARTUP - establish a tributary - this modifier is used to
;		establish a tributary so that communication between
;		a unit and the CI device can occur.
;
; 	o SHUTDOWN - shutdown the assigned tributary - this modifier
; 		is used to stop the device and delete the tributary
; 		by the user of that tributary.  Only the assigned
; 		tributary may be shutdown and this command does not
; 		require privilege.
;
;	o CTRL - perform the request on the Controller not the
;		 tributary.
;
; Inputs:
;
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;	R6 = CCB address
;	R7 = Function code
;	AP = address of first QIO parameter
;
; Outputs:
;
;	R0 = status of setmode request
;
;	R3-R5 are preserved.
;
;	R7-R9 = destroyed
;
;--

	.ENABLE LSB
SETMODE_FDT:					; Setmode FDT processing
	CLRQ	IRP$B_INDEX(R3)			; Clear station address
	MOVZWL	IRP$W_FUNC(R3),R7		; Get entire function code
	BBC	S^#IO$V_CTRL,R7,5$		; Br if not controller request
3$:	BRW	SETMODE_CTRL			; Process controller request
;
; Perform setmode request on a tributary
;
5$:	BBC	S^#IO$V_SHUTDOWN,R7,50$		; Branch if not trib shutdown
;
; Shutdown tributary modifier specified
;
	BSBW	XLATE				; Get CDB address
	BLBC	R0,40$				; Br if error - abort I/O
	SETIPL	UCB$B_FIPL(R5)			; Sync access
	BSBW	SHUTDOWN_TRIB			; Do the dirty work
	BRW	QIORET				; Return the qio
;
; Error exits
;
34$:	MOVZWL	#SS$_INSFMEM,R0			; Insufficient memory
35$:	POPL	R3				; Recover IRP address 
40$:	BRW	ABORTCN				; Abort the conn request
;
; Startup tributary modifier specified or no modifier
;
50$:	BSBW	GET_CHAR_BUFS			; Get P2 characteristics
	BLBC	R0,40$				; Br if error - abort I/O
	BSBW	XLATE				; Get CDB address
	BLBC	R0,55$				; Br if CDB address not found
	BRW	110$				; Else, change existing trib
;
; We are establishing a new tributary.
;
55$:	MOVZWL	#SS$_DEVINACT,R0		; Assume ctrl not inited
	BBC	#UCB$V_CN_INITED,-
		UCB$W_DEVSTS(R5),40$ 		; Br if ctrl not inited
;
; Validate P2 and allocate a CDB
;
	MOVAB	TRIB_PARAM,R1			; Set address of verification table
	CLRL	R2				; No status flags yet
	BSBW	VALIDATE_P2			; Validate the P2 buffer
	BLBS	R0,57$				; Br if success
	BRW	FINISH_IO			; Else error out
;
; Make sure trib address given if new trip request.
; We make this requirement, because this is a new CDB and the tributary
; address is required.
;
57$:	MOVZWL	#NMA$C_PCCI_TRI,R2		; Get trib address
	BSBW	UNPACK_P2_BUF			; From P2 buffer
	BLBS	R0,60$				; Br if given - Okay
	MOVZWL	#SS$_INSFARG,R0			; Insufficient arguments
	MOVL	R2,R1				; Put parameter in R1
	BRW	FINISH_IO			; Finish the I/O
 
60$:	MOVB	R1,IRP$B_INDEX(R3)		; Set the trib number
	PUSHL	R3				; Save IRP address
	MOVZWL	#CDB_C_LENGTH,R1		; Get size of CDB
	JSB	G^EXE$ALONONPAGED		; Allocate the CDB
	BLBC	R0,35$				; Br if error
	POPL	R3				; Recover R3
;
; Initialize CDB
;
	MOVL	R2,R9				; Copy CDB address
	PUSHR	#^M<R1,R3,R4,R5>		; Save registers
	MOVC5	#0,(R2),#0,R1,(R2)		; Zero the CDB
	POPR	#^M<R1,R3,R4,R5>		; Restore registers
	MOVB	#DYN$C_CDRP,CDRP$B_CD_TYPE(R9)	; Set type
	MOVW	R1,CDRP$W_CDRPSIZE(R9)		;  and size
	MOVZBL	S^#CDB_C_QUEUES,R0		; Set number of queue heads
	MOVAB	CDB_Q_QUEUES(R9),R2		; Set address of first head
90$:	MOVAB	(R2),(R2)+			; Init forward link pointer
	MOVAB	-4(R2),(R2)+			; Init backward link pointer
	SOBGTR	R0,90$				; Loop if more queues
	MOVL	R5,CDB_L_UCB(R9)		; Set UCB address
80$:	MOVZBL	IRP$B_INDEX(R3),R8		; Get vector index
	MOVB	R8,CDB_B_TRB_ADDR(R9)		; Set port number
	SETIPL	UCB$B_FIPL(R5)			; Sync access to UCB
	MOVW	UCB$W_CN_RCV_CNT(R5),-
		CDB_B_RCV_CNT(R9)		; Set default receive buffers
	MOVB	CDB_B_RCV_CNT(R9),-
		 CDB_B_RCV_FQ(R9)		; Transfer buffer count
	DIVB3	#2,CDB_B_RCV_CNT(R9),-
		 CDB_B_THRES(R9)		; Set the flow cntrl threshold
	MOVW	UCB$W_DEVBUFSIZ(R5),-		; Set the unit's default
		CDB_W_BUFSIZ(R9)		;  buffer size into the CDB
	CLRL	CDB_L_DEVDEPEND(R9) 		; Init CDB status
	MOVL	R9,UCB$L_CN_CDB_VEC(R5)[R8]	; Store CDB address in UCB
	MOVW	IRP$W_CHAN(R3),-		; Save channel index in UCB
		UCB$W_CN_CHAN_VEC(R5)[R8]	;
	INCB	UCB$B_CN_TRB_CNT(R5)		; Tally one more tributary
	BRB	125$				; Skip P2 validation

;
; Tributary was already established .. validate P2
;
110$:	MOVAB	TRIB_PARAM,R1			; Get address of verification table
	MOVZWL	CDB_W_STS(R9),R2		; Get Trib status
	BSBW	VALIDATE_P2			; Validate P2
	BLBC	R0,FINISH_IO			; Br if error - Abort I/O
	SETIPL	UCB$B_FIPL(R5)			; Sync access to UCB
;
; Tributary now exists change its characteristics and set them
; if trib is established.
; All characteristics have been set, now check for STARTUP modifier
;
125$:	BBS	S^#IO$V_STARTUP,R7,130$		; Br if not startup request
FINISH_SUC:
	MOVZWL	S^#SS$_NORMAL,R0		; Set success
FINISH_ERR:
	CLRL	R1				; Clear devdep
	BBS	S^#IO$V_CTRL,IRP$W_FUNC(R3),-
		FINISH_IO 			; Skip for controllers
	BISL2	CDB_L_DEVDEPEND(R9),R1		; Get CDB dependent status
FINISH_IO:
	CLRL	IRP$L_SVAPTE(R3)		; Clear temp field
	JMP	G^EXE$FINISHIO			; Complete the I/O
 
;
; Startup tributary requested
;
130$:	MOVZWL	#SS$_DEVACTIVE,R0		; Assume trib already active
	BBS	#CDB_V_DISC,CDB_W_STS(R9),ABO	; Fail if still disconnecting
	BBSS	#CDB_V_ESTB,CDB_W_STS(R9),ABO	; Fail if trib already active
	BSBW	START_TRIB			; Startup the trip
	BRW	QIORET				; Finish the qio w/success

ABO:	BRW	ABORTCN				; Abort the conn request
	.DISABLE LSB
	.PAGE
	.SBTTL	SETMODE_CTRL,  Perform setmode FDT operation on controller
 
;++
; SETMODE_CTRL - Perform setmode FDT operation on controller
;
; Functional description:
;
; This routine performs the SETMODE FDT setup for the controller.
;
; Inputs:
;
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;	R7 = IRP function word
;
; Outputs:
;
;	R0 = status of setmode request
;
;	R3-R5 are preserved.
;
;--
 
SETMODE_CTRL:					; Perform setmode on controller
	CLRL	IRP$L_CDB(R3)			; Clear out any trash
	BBC	S^#IO$V_SHUTDOWN,R7,10$		; Br if not shutdown request
;
; Shutdown modifier specified
;
	BBC	#UCB$V_CN_INITED,-		; Br if controller not up
		UCB$W_DEVSTS(R5),FINISH_SUC
	SETIPL	UCB$B_FIPL(R5)			; Must be at FORK IPL
	BSBW	SHUTDOWN_DEV			; Shut it down
	BRW	QIORET				; Finish the QIO
;
; Startup line modifier specified or no modifier
;
10$:	BSBW	GET_CHAR_BUFS			; Get P2 characteristics
	BLBC	R0,ABO				; Br if error - Abort I/O
	BBS	#UCB$V_CN_INITED,-		; Br if controller up already
		UCB$W_DEVSTS(R5),40$
;
; Validate P2
;
	MOVAB	LINE_PARAM,R1			; Address of verif table
	MOVZWL	UCB$W_DEVSTS(R5),R2		; Status flags
	BSBW	VALIDATE_P2			; Validate P2 buffer
	BLBS	R0,30$				; BR if success
	BRW	FINISH_IO			; Else error out
;
; Initialize the buffer and I/O request queue heads
;
30$:	SETIPL	UCB$B_FIPL(R5)			; Synch access to UCB
	CLRL	UCB$L_DEVDEPEND(R5)		; Reset status and error flags
	PUSHR	#^M<R3,R4,R5>
	MOVC5	#0,(R5),#0,#VEC_LEN,UCB$B_CN_VC_OPEN(R5)
	POPR	#^M<R3,R4,R5>
	BSBW	CHG_UCB				; Set the UCB characteristics
40$:	BBC	S^#IO$V_STARTUP,R7,50$		; Finish up if not starting
;
; Device initialized - then do a LISTEN
; Do all the wonderful SCS magic needed to start up
;
; NOTE: The following code assumes that we have only 1 CI port on
;	the current system!!!!!
;
	SETIPL	UCB$B_FIPL(R5)			; Must be done at FORK IPL
	SUBL2	#44,SP				; Get some space
	MOVL	SP,R7				; Save buffer addr
	MOVL	R3,R9				; Save R3
	CONFIG_SYS  G^SCS$GB_SYSTEMID,(SP)	; Get our system block
	BLBC	R0,60$				; Error
	MOVL	SB$L_PBCONNX(R1),R6		; Get path block
	MOVL	PB$L_PDT(R6), R6		; Pick up PDT
	MOVL	R6, UCB$L_PDT(R5)		; Save in UCB
	MOVB	28(R7),UCB$B_CN_PORT(R5)	; Get our port number
	ADDL	#44,SP				; Restore stack
	LISTEN	MSGADR=W^LIS_FORK,-
		ERRADR=W^LIS_ERR,-
		LPRNAM=PROC_NAM,-
		PRINFO=PROC_NAM			; Set up a LISTEN
	BLBC	R0, 70$				; Error
	MOVL	R3,UCB$L_LIS_CDT(R5)		; Save listen CDT
	MOVL	R5,CDT$L_AUXSTRUC(R3)		; Set addr of UCB into CDT
	MOVL	R9,R3				; Restore IRP addr
	BISW	#UCB$M_CN_INITED,UCB$W_DEVSTS(R5) ; Indicate device inited
50$:	BRW	FINISH_SUC			; Finished

60$:	ADDL	#44,SP				; Restore stack
	MOVZWL	#SS$_DEVOFFLINE,R0		; Device offline error(no PA)
70$:	MOVL	R9,R3				; Restore IRP address
	BRW	ABORTCN				; Abort the conn request
	.PAGE
	.SBTTL	GET_CHAR_BUFS,  Get P2 characteristics buffer
 
;++
; GET_CHAR_BUFS - Get P2 characteristics buffer
;
; Functional description:
;
; This routine saves the address of P2 buffer for later use by the driver.
; The P2 buffer address is saved in IRP$L_SVAPTE of the IRP, and the size
; in IRP$L_BCNT
;
; Inputs:
;
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;
; Outputs:
;
;	R0 = status of buffers
;
;	R3-R5 are preserved.
;
;--
 
GET_CHAR_BUFS:					; Get characteristics buffers
	MOVL	P2(AP),R2			; Get address P2 char buf desc
	BEQL	20$				; Br if no P2 buffer
	MOVZWL	#SS$_ACCVIO,R0			; Assume access violation
	IFNORD	#8,(R2),30$			; Check access to descriptor
	MOVZWL	(R2),R1				; Get buffer length in bytes
	BICL	#1,R1				; Must be multiple of 2 bytes
	BEQL	30$				; Br if size is zero
	MOVL	DSC$A_POINTER(R2),R2		; Get buffer address
	IFNORD	R1,(R2),30$			; Check entire P2 buffer
	MOVL	R1,IRP$L_BCNT(R3)		; Save size
	MOVL	R2,IRP$L_SVAPTE(R3)		;  and address
20$:	MOVL	#1,R0				; Assume success
30$:	RSB					; Return
	.PAGE
	.SBTTL	SENSEMODE_FDT,  Sense Mode I/O operation FDT routine

;++
; SENSEMODE_FDT - Sense Mode FDT routine
;
; Functional Description:
;
;  This routine returns information to the caller about the configuration
;  and status of the CI device.  Depending on the function modifier,
;  either the device characteristics or error counters contents are returned.
;
;
;  The QIO parameters for SENSEMODE are:
;
;	P2 = optional address of buffer descriptor for extended characteristics
;	
;
; Inputs:
;
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;	R6 = CCB address
;	R7 = Function code
;	AP = Address of first function-dependent QIO parameter
;
; Outputs:
;
;	R0 = status return of sensemode request
;
;	R3-R5 are preserved.
;
;--

SENSEMODE_FDT:					; Sensemode FDT I/O processing
	MOVW	IRP$W_FUNC(R3),R7		; Get entire function code
	BBS	S^#IO$V_CTRL,R7,10$		;
	BSBW	XLATE				; Get CDB address
	BLBC	R0,30$				; Br if error
	BRB	11$

10$:	MOVL	R5,R9				; Set UCB
11$:	MOVL	P2(AP),R2			; Get address of P2 desc
	BEQL	20$				; None, leave quietly
	MOVL	#SS$_ACCVIO,R0			; Assume the worst
	IFNORD	#8,(R2),30$			; Br if no access
	MOVZWL	(R2),R1				; Get length of buffer
	BICL	#1,R1				; Must be multiple of 2 bytes
	BEQL	25$				; Br if zero
	MOVL	DSC$A_POINTER(R2),R2		; Get buffer address
	BBC	S^#IO$V_RD_COUNT,R7,40$		; Br if not read counters
;
; Read tributary counters - modifier RD_COUNT
;
	BBC	S^#IO$V_CTRL,R7,13$		; Not controller
	BRW	FINISH_SUC			; Always success

13$:	MOVZWL	#TRIB_CNT_BUFSIZ,R10		; Size needed
	BSBW	CHECK_P2			; Check P2 buffer
	BLBC	R0,30$				; Error
	MOVL	R2,R11				; Save starting address
	MOVAB	TRIB_COUNTER,R6			; Get address of counter codes
	DSBINT	UCB$B_FIPL(R5)			; Synch access to UCB/CDB
	MOVAL	CDB_L_CNTS(R9),R1		; Get address of counts
	ASSUME	CDB_C_CNTS EQ 16		; Assume 16 bytes of XD counts
12$:	SUBL	#6,R10				; Space left in buffer
	BLSS	15$				; None, leave
	MOVW	(R6)+,(R2)+			; Set next code
	MOVL	(R1)+,(R2)+			; Set next value
	BRB	12$				; Loop again

15$:	BBC	S^#IO$V_CLR_COUNT,R7,20$	; Skip if not a clear counter
	CLRQ	CDB_L_CNTS(R9)			; Else, clear counters
	CLRQ	CDB_L_CNTS+8(R9)		;	...
20$:	ENBINT
22$:	SUBL2	R11,R2				; Get length
	ROTL	#16,R2,R2			; Get in high 16
	BISL	R2,R0				; Set length/status	
	BRW	FINISH_ERR			; Leave setting R0 in IOSB

25$:	MOVZWL	#SS$_BADPARAM,R0		; No buffer
30$:	BRW	ABORTIO				; Abort the I/O request
 
;
; Read tributary parameters - no modifier
;
40$:	BBC	S^#IO$V_CTRL,R7,43$		; Not controller
	MOVZWL	#LINE_PRM_BUFSIZ,R10		; Size of P2 needed
	MOVAB	LINE_PARAM,R6			; Get address of return table
	BRB	44$

43$:	MOVZWL	#TRIB_PRM_BUFSIZ,R10		; Size of P2 needed
	MOVAB	TRIB_PARAM,R6			; Get address of return table
44$:	BSBW	CHECK_P2			; Check P2 buffer
	BLBC	R0,30$				; Error
	MOVL	R2,R11				; Copy starting address
	MOVL	R6,R1				; Transfer address
	DSBINT	UCB$B_FIPL(R5)			; Synch access to UCB/CDB
50$:	MOVW	(R1)+,R7			; Get parameter + flags
	BEQL	20$				; Br if end of verify table
	EXTZV	#PRM_V_TYPE,#PRM_S_TYPE,R7,R7	; Get type field
	SUBL	#6,R10				; Bytes left
	BLEQ	20$				; None, leave
	MOVW	R7,(R2)+			; Return parameter
	MOVW	(R1)+,R7			; Get offset + width
	EXTZV	#OFF_V_WIDTH,#OFF_S_WIDTH,R7,R6	; Get width only
	BICL	#^C<OFF_M_VALUE>,R7		; Get offset only
	ADDL	R9,R7				; Calculate address of datum
	CASE	R6,TYPE=B,LIMIT=#1,<-		; Br to handler
		60$,-				;   Byte value
		70$,-				;   Word value
		80$>				;   Longword value
;
; Byte, word, longword value in structure
;
60$:	MOVZBL	(R7),(R2)+			; Store byte value
	BRB	90$				; 

70$:	MOVZWL	(R7),(R2)+			; Store word value
	BRB	90$				;

80$:	MOVL	(R7),(R2)+			; Store longword value
90$:	ADDL	#PARAM_C_SKIP-2,R1		; Skip non-essential fields
	BRB	50$				; Try for more parameters
;
; CHECK_P2
;
CHECK_P2:
	MOVL	#1, R0				; Assume success
	CMPL	R1,R10				; Will it fit
	BGEQU	10$				; Yes
	MOVL	R1,R10				; No, update
	MOVZWL	#SS$_BUFFEROVF,R0		; Show warning
10$:	IFWRT	R10,(R2),20$			; Error
	MOVL	#SS$_ACCVIO,R0
	RSB

20$:	MOVL	R10,R11				; Save for later
	RSB
	.PAGE
	.SBTTL	LIS_FORK, Listen action routine

;++
; LIS_FORK - Listen action routine
;
; Functional description:
;
; This routine is entered as a fork process activated by the PADRIVER
; when some other process has sent a CONNECT to us.  We can then decide
; to ACCEPT or REJECT the connection.
;
; Inputs:
;
;	R2 -->	CONNECT_REQ message
;	R3 -->	Listening CDT
;	R4 -->	PDT
;
;	IPL = FIPL
;
;--

LIS_FORK:
	MOVL	CDT$L_AUXSTRUC(R3),R5		; Pick up UCB from listen cdt
	PUSHQ	R2				; Save some registers
	CMPC3	#16,PROC_NAM,16(R2)		; Check the connect proc nam
	POPR	#^M<R2,R3>			; Restore regs (but save CC's)
	BNEQ	10$				; Not same, reject this guy
	MOVZBL	CDT$B_RSTATION(R3),R1		; Get other guy's port
	MOVL	UCB$L_CN_CDB_VEC(R5)[R1],R0	; Pick up the CDB
	BEQL	10$				; We don't have one, reject
	ASSUME	CDB_V_ESTB EQ 0
	BLBC	CDB_W_STS(R0),10$		; REJECT if not established
	CMPB	UCB$B_CN_PORT(R5),R1		; Is the other guy lower?
	BGEQ	20$				; Yes, accept him
	BBC	#CDB_V_STRT,CDB_W_STS(R0),20$	; No, are we trying to talk?
;
; REJECT the connection.
;
10$:	MOVL	#1, R0				; Reject reason
	REJECT					; Yes, reject him
	RSB
;
; ACCEPT the connection.
;
20$:	MOVL	R0,R5				; Cover the CDB
	SETBIT	#CDB_V_ACPT,CDB_W_STS(R5)	; Set status
	MOVZBL	CDB_B_RCV_CNT(R5),R0		; Pick up rec buf count
	MOVZBL	CDB_B_THRES(R5),R1		; Pick up threshold
	INCL	R1				; Add one for XON
	ACCEPT	MSGADR=W^MSG_FORK,-		; Message address
		DGADR =W^DG_FORK,-		; Psuedo interrupt rtn
		ERRADR=W^CONN_ERR,-		; Error address
		INITCR=R1,-			; Allow for messages
		INITDG=R0,-			; Receive buffers
		CONDAT=PROC_NAM,-		; Accept data
		AUXSTR=(R5)			; Auxiliary strucure (CDB)
;
; Control returns to caller's caller - the fork proccess in the PADRIVER.
; When the ACCEPT completes, the following is called as a fork process
; NOT necessarily in the context of user's process.
;
;	R0  =	Status
;	R1  =	?
;	R2 -->  ACCEPT_RSP message
;	R3 -->	CDT
;	R4 -->	PDT
;	R5 -->	CDB
;		
	MOVL	R5,R4				; Restore CDB pointer
	MOVL	CDB_L_UCB(R5),R5		; Restore UCB pointer
	BLBC	R0,50$				; VC broken
	MOVZBL	CDT$B_RSTATION(R3),R2		; Remote node
	CMPB	R2,UCB$B_CN_PORT(R5)		; Are we talking to ourselves?
	BNEQ	45$				; No
	MOVL	R3,UCB$L_TWIN_CDT(R5)		;  and save the CDT in UCB
40$:	RSB					; Leave

45$:	BRW	CONN_FIN			; Fin

50$:	MOVL	CDB_L_CONN_IRP(R4),R3		; Pick up IRP address
	BEQL	40$				; None
	CLRL	CDB_L_CONN_IRP(R4)		; Clear pointer
	BRW	IO_DONE				; Post it as error

LIS_ERR:					; Error on LISTEN CDT
	DISCONNECT				; Put it back to listen
	RSB					; Leave
	.PAGE 
	.SBTTL	START_TRIB,  Start tributary routine

;++
; START_TRIB - Start tributary routine
;
; Functional description:
;
; This routine is called when a tributary is to be established and started.
; The polling parameters are initialized also.
;
;  Inputs:
;
;	R3 = IRP address
;	R5 = UCB address
;	R9 = CDB address
;
;	IPL = FIPL
;
;  Outputs:
;
;	R5 is preserved.
;
;--

	.ENABLE	LSB
START_TRIB:					; Start tributary
	MOVL	R3,CDB_L_CONN_IRP(R9)		; Save the IRP addr
	SUBL2	#44,SP				; Get some scratch space
	CONFIG_PTH  IRP$B_INDEX(R3),(SP)	; Recover path info
	MOVQ	36(SP),CDB_L_CNTS(R9)		; Set station address temp
	ADDL	#44,SP				; Release storage
	BLBC	R0,20$				; Error
	SETBIT	#CDB_V_STRT,CDB_W_STS(R9)	; Show us starting
	MOVL	R9,R5				; Save CDB across call
	MOVZBL	CDB_B_RCV_CNT(R5),R0		; Pick up rec buf count
	MOVZBL	CDB_B_THRES(R5),R1		; Pick up threshold
	INCL	R1				; Add one for XON
	CONNECT	MSGADR=W^MSG_FORK,-		; Message address
		DGADR =W^DG_FORK,-		; Psuedo interrupt routine
		ERRADR=W^CONN_ERR,-		; Connect errors
		RSYSID=CDB_L_CNTS(R5),-		; His system id
		RPRNAM=PROC_NAM,-		; To whom we will speak
		LPRNAM=PROC_NAM,-		; Our name
		INITCR=R1,-			; Allow for messages
		INITDG=R0,-			; Number of receive buffers
		CONDAT=PROC_NAM,-		; Connect data
		AUXSTR=(R5)			; Auxiliary structure
;
; Control returns to caller's caller - the JMP G^EXE$QIORETURN.
; When the connection completes, the following is called as a fork
; process NOT necessarily in the context of process.
;
;	R0  =	Status code
;	R1  =	Reject reason if status = reject
;	R2 -->	ACCEPT_REQ msg if status = success
;	R3 -->	Connection CDT
;	R4 -->	PDT
;	R5 -->  CDB
;
	MOVL	R5,R4				; Restore CDB pointer
	MOVL	CDB_L_UCB(R4),R5		; Restore UCB pointer
	BLBS	R0,30$				; Success
;
; CONNECT failed
;
	CLRBIT	#CDB_V_STRT,CDB_W_STS(R4)	; Clear the starting state
20$:	RSB					; Wait the qio until contacted

;
; CONNECT (or ACCEPT) succeded
;
30$:	MOVZBL	CDB_B_TRB_ADDR(R4),R2		; Find out remote port #
CONN_FIN:
	BBCS	R2,UCB$B_CN_VC_OPEN(R5),40$	; Check open status
	BUG_CHECK INCONSTATE

40$:	MOVL	R3,CDRP$L_CDT(R4)		; Set pointer to open CDT
	MOVL	R3,CDB_L_CDT(R4)		; Again
	CLRQ	CDB_L_CNTS(R4)			; Clean up counts
	CLRQ	CDB_L_CNTS+8(R4)		; Clean up counts
	BISL	#XM$M_STS_ACTIVE!-
		 XM$M_STS_RUNNING,-
		 CDB_L_DEVDEPEND(R4)		; Set status
;
; Allocate a message buffer for XON/XOFF
;
	MOVL	R4,R5				; Cover CDRP
	MOVL	CDT$L_PDT(R3),R4		; Pick up PDT
	ALLOC_MSG_BUF
	MOVL	R5,R4				; Recover CDB pointer
;*** need to check for failure !!! ****
	MOVL	CDB_L_UCB(R4),R5		; Restore UCB pointer
	MOVL	CDB_L_CONN_IRP(R4),R3		; Pick up possible IRP
	BEQL	CLR_XMT				; None
	CLRL	CDB_L_CONN_IRP(R4)		; Clear, so no later post
	CLRL	IRP$L_SVAPTE(R3)		; No buffers to return
	BSBW	IO_DONE				; Post it
CLR_XMT:
	BBS	#CDB_V_XOFF,CDB_W_STS(R4),70$	; Don't do if any XOFF active
	REMQUE	@CDB_Q_XMT_REQ(R4),R3		; Pick up any stuck transmits
	BVS	70$				; None
	PUSHL	R9				; Save a register
	MOVL	R4, R9				; Expected pointer
	BSBW	SEND_XMT			; Send it out
	POPL	R9				; Restore R4
70$:	RSB					; Done
	.disable lsb

;
; Error after connection established - VC disconnect most likely
;
;  Inputs:
;	R0  =  Status
;	R3 --> CDT
;	R4 --> PDT
;
CONN_ERR:
	MOVL	CDT$L_AUXSTRUC(R3),R4	; Pick up associated CDB
	MOVL	CDB_L_UCB(R4),R5	; Pick up UCB address
	SETBIT	#CDB_V_DSCB,CDB_W_STS(R4) ; Set for disconnect
	CMPB	UCB$B_CN_PORT(R5),-
		CDT$B_RSTATION(R3)	; Are we talking to ourselves?
	BNEQ	10$			; No
	CLRL	UCB$L_TWIN_CDT(R5)	; Yes, clear out entry
	BRW	ZAP_CDB_SELF		; Yes, use special entry point

10$:	BRW	ZAP_CDB			; Cancel I/O & disconnect VC
	.PAGE
	.SBTTL	SHUTDOWN_DEV,  Device shutdown routine

;++
; SHUTDOWN_DEV,  Device shutdown routine
;
; Functional description:
;
; This routine is called to shutdown the CI device.  All 
; tributaries are halted and deleted.  Finally all of the driver's
; receive control blocks are deallocated as well as the receive
; buffer pool.
;
; Inputs:
;
;	R3 = IRP address
;	R5 = UCB address
;	R9 = CDB address
;
;	IPL = FIPL
;
; Outputs:
;
;	All structures in the driver are deallocated.
;??? SHOULD FINAL STATUS WAIT UNTIL ALL CDB VC DISCONNECTED????
;
;--

SHUTDOWN_DEV:
	BBC	#UCB$V_CN_INITED,-
		UCB$W_DEVSTS(R5),10$ 		; Br if dev not inited
	BSBB	CAN_DEV				; Do all the clean up
	MOVL	#SS$_NORMAL,R0			; Set success
10$:	BRW	IO_DONE				; Post the packet

;
; Abort all I/O for all tribs and deallocate CDB's
;
CAN_DEV:
	BBCC	#UCB$V_CN_INITED,-
		UCB$W_DEVSTS(R5),50$ 		; Br if dev not inited
	PUSHR	#^M<R2,R3,R4,R5,R6>
	MOVL	#MAX_TRB-1,R6			; Loop counter
30$:	MOVL	UCB$L_CN_CDB_VEC(R5)[R6],R4	; Get next CDB
	BEQL	40$				; Br if none
	BISW	#<CDB_M_DSCB!CDB_M_CLRC>,-	; Set for disconnect & clear
		 CDB_W_STS(R4)
	BSBB	ZAP_CDB				; Cancel all I/O on trib
	MOVL	^X0C(SP),R5			; Restore UCB address
40$:	SOBGTR	R6,30$
;
; Remove our listener
;
	MOVL	UCB$L_LIS_CDT(R5),R3		; Pick up listening CDT
	BEQL	45$				; None
	MOVL	UCB$L_PDT(R5),R4		; PDT address, just in case
	DISCONNECT				; Clear our name out of table
45$:	CLRL	UCB$L_LIS_CDT(R5)		;  and clear any trace
;
; CLean up the UCB
;
	BICW2	#^C<UCB$M_ONLINE!UCB$M_POWER>,-
		UCB$W_STS(R5)			; Reset status
	CLRL	UCB$L_DEVDEPEND(R5)		; Reset status and error flags
	MOVC5	#0,(SP),#0,#VEC_LEN,-
		UCB$B_CN_VC_OPEN(R5) 		; Clean up
	POPR	#^M<R2,R3,R4,R5,R6>		; Restore registers
50$:	RSB					; Return
	.PAGE
	.SBTTL	SHUTDOWN_TRIB,  Shutdown the tributary
 
;++
; SHUTDOWN_TRIB - Shutdown the tributary
;
; Functional description:
;
; This routine is called to abort all I/O pending for this tributary.
;
; Inputs:
;
;	R5 = UCB address
;	R9 = CDB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0-R2 are destroyed.
;
;--
 
SHUTDOWN_TRIB:					; Shutdown a tributary
	MOVL	R9,R4				; Shift address
	MOVL	R3,CDB_L_DISC_IRP(R4)		; Save IRP
	PUSHR	#^M<R3,R5>			; Save registers
	BISW	#<CDB_M_DSCB!CDB_M_WAIT>,-
		  CDB_W_STS(R4)			; Set to disconnect & wait
	BSBB	ZAP_CDB				; Get rid of I/O
	POPR	#^M<R3,R5>			; Restore IRP
	RSB
;
; Routines to clean up the CDB
;
;	1) Cancel all outstanding I/O, abort all IRP, return
;		all receive buffers to pool.
;	2) Disconnect the Virtual Circuit, clear device dependent status,
;		and if successful, clear status bits.
;	3) Clear out entire CDB and return to pool removing entry from
;		UCB vector.
;
ZAP_CDB:
	.ENABLE LSB

;
; 1) Complete all IRPs for this tributary
;
	PUSHR	#^M<R3,R4,R5,R6,R7,R8>		; Save registers
	MOVAB	CDB_Q_QUEUES(R4),R6		; Get address of first queue listhead
	MOVZWL	#CDB_C_ABRT_Q,R7		; Get number of queues
40$:	REMQUE	@(R6),R3			; Get next IRP/buffer
	BVS	80$				; Br if none - queue empty
	CMPB	IRP$B_TYPE(R3),S^#DYN$C_IRP	; Is this an IRP?
	BEQL	50$				; Br if yes
	CMPB	IRP$B_TYPE(R3),S^#DYN$C_NET	; Is it a receive buffer?
	BEQL	70$				; Br if yes
	CMPB	IRP$B_TYPE(R3),S^#DYN$C_CXB	; Is it a receive buffer?
	BEQL	70$				; Br if yes
	CMPB	IRP$B_TYPE(R3),S^#DYN$C_CIDG	; Is it a receive buffer?
	BEQL	70$				; Br if yes
	BUG_CHECK NOBUFPCKT,FATAL		; Else, fatal error
;
; IRP
;
50$:	BSBW	ABORT_PKT			; Abort the I/O request
	BRB	40$				; Get next entry
;
; Receive buffer
;
70$:	MOVL	R3,R0				; Set receive buffer address
	BSBW	DEALLMEM			; Get rid of it
;***
	DECW	CDB_W_RCV_MV(R4)		; Account for it
;***
	BRB	40$				; Get next entry
;
; Loop to next queue
;
80$:	ADDL	#8,R6				; Skip to next queue listhead
	SOBGTR	R7,40$				; Loop if more queues
;
; Final clean up
;
	MOVL	CDB_L_CONN_IRP(R4),R3		; Any connection qio outstand?
	BEQL	90$				; No, clean up
	BSBW	ABORT_PKT			; Yes, post it
	CLRL	CDB_L_CONN_IRP(R4)		; Clear out pointer (???)
90$:	POPR	#^M<R3,R4,R5,R6,R7,R8>		; Restore registers

;
; 2) Disconnect and return resources.
;

	BBCC	#CDB_V_DSCB,CDB_W_STS(R4),130$	; Skip unless bit set
;
; Disconnect the virtual circuit
;
	MOVZBL	CDB_B_TRB_ADDR(R4),R0		; Pick up trib address
	CLRBIT	R0,UCB$B_CN_VC_OPEN(R5)		; Show circuit down
	CLRBIT	#CDB_V_ESTB,CDB_W_STS(R4)	; Clear status
	INSV	#0,#8,#24,CDB_L_DEVDEPEND(R4)	; Reset status and error flags
	MOVL	#1,R0				; Set for success
	BBS	#CDB_V_DISC,CDB_W_STS(R4),120$	; No DISC if one in progress
	MOVL	CDRP$L_CDT(R4),R3		; Pick up CDT address
	BEQL	120$				; None there
ZAP_CDB_SELF:
	MOVL	R4,R5				; Save CDB pointer over call
	MOVL	CDT$L_PDT(R3),R4		; Pick up PDT address	
	TSTL	CDRP$L_MSG_BUF(R5)		; Is there a message?
	BEQL	115$				; No
	DEALLOC_MSG_BUF				; Yes, get rid of it
115$:	SETBIT	#CDB_V_DISC,CDB_W_STS(R5)	; Show we are disconnecting
	DISCONNECT #0
	MOVL	R5,R4				; Recover CDB address
	BLBC	R0,125$				; Did not complete
	CLRBIT	#CDB_V_DISC,CDB_W_STS(R4)	; Show we are back
	CLRL	CDRP$L_CDT(R4)			; Get rid of any trace
120$:	BICW	#<CDB_M_STRT!CDB_M_ACPT-
		 !CDB_M_XOFF!CDB_M_XFSN>,-
		 CDB_W_STS(R4)			; Finish
125$:	BBCC	#CDB_V_WAIT,CDB_W_STS(R4),130$	; If we had to wait for DISC
	MOVL	CDB_L_DISC_IRP(R4),R3		; Recover IRP
	BEQL	130$				; None there
	MOVL	CDB_L_UCB(R4),R5		; Pick up UCB
	CLRL	CDB_L_DISC_IRP(R4)		; Clear out the field
	PUSHL	R0				; Save status
	BSBW	IO_DONE				; Finish up
	POPL	R0				; Restore status
130$:	BBSC	#CDB_V_CLRC,CDB_W_STS(R4),140$	; If keeping the CDB...
135$:	RSB					; Return to caller

;
; 3) Clear and return CDB
;

140$:	BLBC	R0,135$				; Only deallocate if success
	MOVL	CDB_L_UCB(R4),R5		; Pick up UCB address
	DECB	UCB$B_CN_TRB_CNT(R5)		; One less trib
	MOVZBL	CDB_B_TRB_ADDR(R4),R0		; Pick up trib address
	CLRL	UCB$L_CN_CDB_VEC(R5)[R0]	; Clear out pointer
	CLRW	UCB$W_CN_CHAN_VEC(R5)[R0]	; Zero channel entry
	MOVL	R4,R0				; Transfer address
;	BSBB	DEALLMEM			; Deallocate the CDB
;	RSB					; Return to caller

DEALLMEM:
	JMP	G^COM$DRVDEALMEM		; Get rid of memory
	.DISABLE LSB
	.PAGE
	.SBTTL	CANCEL,  Cancel I/O routine

;++
; CANCEL, Cancels an I/O operation in progress
;
; Functional description:
;
;	This routine cancels all I/O on the tributary.
;
; Inputs:
;
;	R2 = channel number 
;	R3 = current IRP address
;	R4 = PCB address 
;	R5 = UCB address
;	R8 = Cancel reason code (zero is for vanila flavored cancel).
;
;	IPL = FIPL
;
; Outputs:
;
;	R0-R3 are destroyed.
;
;--

CANCEL:					; Cancel an I/O operation
	PUSHR	#^M<R4,R5,R9>		; Save registers
	TSTW	UCB$W_REFC(R5)		; Last reference to unit?
	BNEQ	5$			; Br if no
;
; Last $DEASSIGN on unit
;
	BSBW	CAN_DEV			; Shut down the controller
	BRB	20$			; And leave
;
; Not the last deassign - either $CANCEL or $DASSGN
;
5$:	MOVL	R2,R3			; Copy channel number
	BSBW	XLATE_CHAN		; Translate channel
	BLBC	R0,20$			; Br if none
	TSTL	R8			; Is this a plain cancel?
	BEQL	10$			; Br if yes
;
; Deassign channel request
;
	BISW	#<CDB_M_DSCB-
		 !CDB_M_CLRC>,-		; Do it all
		 CDB_W_STS(R9)
;
; Cancel request
;
10$:	MOVL	R9,R4
	BSBW	ZAP_CDB			; Clear all CDB I/O
20$:	POPR	#^M<R4,R5,R9>		; Restore registers
	RSB				; Return to caller
	.PAGE
	.SBTTL	MSG_FORK,  Fork process for receipt of Seq Messages

;++
; MSG_FORK - Process received MSG
;
; Inputs:
;
;	R1  =	Bytes send/received
;	R2 -->	Start of user data
;	R3 -->	CDT
;	R4 -->	PDT
;
;	IPL =	FIPL
;
; Outputs:
;
;--

MSG_FORK:
	MOVL	CDT$L_AUXSTRUC(R3),R0		; Recover CDB address
	BICW	#CDB_M_XOFF,CDB_W_STS(R0)	; Start from scratch
	BISW	4(R2),CDB_W_STS(R0)		; Update the bit status
	DEALLOC_MSG_BUF_REG			; Deallocate the message buffer
	MOVL	CDT$L_AUXSTRUC(R3),R4		; Recover CDB address
	MOVL	CDB_L_UCB(R4),R5		; Recover UCB
	BRW	CLR_XMT				; Start any stuck transmits
	.PAGE
	.SBTTL	DG_FORK,  Fork process for receipt of DG

;++
; DG_FORK - Process received DG
;
; Inputs:
;
;	R0  =   0 - Received a DG
;	    =	1 - Transmit finished
;	R1  =	Bytes send/received
;	R2 -->	Start of user data
;	R3 -->	CDT
;	R4 -->	PDT
;
;	IPL =	FIPL
;
; Outputs:
;
;--
EMPTY:	MOVL	R2,R0				; Pick up buffer
	BRW	DEALLMEM			; Get rid of it

DG_FORK:
	SUBL	#CXB$C_HEADER,R2		; Reset R2 to head of buffer
	MOVL	CDT$L_AUXSTRUC(R3),R4		; Pick up pointer to CDB
	BEQL	EMPTY				; Closed CDB, discard
	MOVL	CDB_L_UCB(R4),R5		; Pick up ptr to UCB
	TSTL	R0				; Check flag
	BNEQ	40$				; Transmit	
;
; Receive complete - if there is a pending receive I/O request, complete it.
; Otherwise, queue the buffer.
;
	ASSUME	CDB_V_ESTB EQ 0
	BLBC	CDB_W_STS(R4),EMPTY		; Br if trib not established
	DECB	CDB_B_RCV_FQ(R4)		; Dec the buffer count
	MOVW	R1,CXB$W_LENGTH(R2)		; Set size
	ADDL	R1,CDB_L_BRC(R4)		; Update byte count
	BCC	10$				; Br if no overflow
	MNEGL	#1,CDB_L_BRC(R4)		; Else, latch it
10$:	INCC	CDB_L_DMR(R4)			; Update message count
	REMQUE	@CDB_Q_RCV_REQ(R4),R3		; Remove waiting IRP
	BVS	20$				; Br if none - queue for later
	BRW	FINISH_RCV_IO			; Else, finish the I/O & exit
 
20$:	INSQUE	(R2),@CDB_Q_RCV_MSG+4(R4)	; Queue receive msg for late
;***
	INCW	CDB_W_RCV_MV(R4)		; Incr the outstanding count
	CMPB	CDB_W_RCV_MV(R4),-
		 CDB_B_THRES(R4)		; Are we less?
	BLEQ	88$				; Yes, all is okay
	BBSS	#CDB_V_XFSN,-
		 CDB_W_STS(R4),50$		; If one is out, don't bother
	PUSHQ	R4				; Save CDB and UCB pointers
	MOVW	#CDB_M_XOFF,R0			; Set for XOFF
	BSBW	SEND_XMSG			; Send a message
	POPQ	R4				; Restore pointers
88$:
;***
	BRW	FILLRCVLIST			; Fill the receive buffer pool
;
; Transmit completed - deque XMIT IRP and post it.
;
	ASSUME	CDB_V_ESTB EQ 0
40$:	MOVL	#SS$_ABORT,R0			; Assume the worst
	BLBC	CDB_W_STS(R4),55$		; Br if trib not established
	ADDL	R1,CDB_L_BSN(R4)		; Update byte count
	BCC	50$				; Br if no overflow
	MNEGL	#1,CDB_L_BSN(R4)		; Else, latch it
50$:	INCC	CDB_L_DMS(R4)			; Update message count
	ROTL	#16,R1,R0			; Size in R0
	MOVW	#SS$_NORMAL,R0			; Status
55$:	REMQUE	@CDB_Q_XMT_PND(R4),R3		; Recover the associated IRP
	BVS	57$				; None, error
	CMPL	R2,IRP$L_SVAPTE(R3)		; Match?
	BEQL	58$				; Yes, all is okay
;
; Returned packet does not match address in IRP.  Rummage thru the queued
; IRP's looking for a match.  This should only occur during a powerfail.
;
	MOVAL	CDB_Q_XMT_PND(R4),R0		; Point a que head
	INSQUE	(R3),(R0)			; Put this one back
	MOVL	R0,R1				; Copy que head pointer
77$:	MOVL	(R0),R0				; Get next entry
	CMPL	R0,R1				; Back to head?
	BEQL	57$				; Yes, no match - error
	CMPL	R2,IRP$L_SVAPTE(R0)		; No, does buffer match?
	BNEQ	77$				; No, try again
	REMQUE	(R0),R3				; Yes, remove it
58$:	BSBW	IO_DONE				; Complete the I/O
	CMPL	@CDB_Q_XMT_REQ(R4),-
		 CDB_Q_XMT_REQ(R4)		; Anything on stall queue?
	BNEQ	60$				; Yes, unstall it
	RSB					; No, leave

60$:	BRW	CLR_XMT				; Get next packet

57$:	BUG_CHECK NOBUFPCKT,FATAL		; Fatal error
	.PAGE
	.SBTTL	FINISH_RCV_IO,  Finish receive I/O processing

;++
; FINISH_RCV_IO - Finish receive I/O processing
;
; Functional description:
;
; This routine completes a receive operation that has been matched with a
; message block. After the receive has been completed the message free list
; is filled and a receive is started if needed.
;
;  Inputs:
;
;	R2 = message buffer address
;	R3 = IRP address
;	R4 = CDB address
;	R5 = UCB address
;
;	IPL = FIPL
;
;  Outputs:
;
;	R5 is preserved.
;
;	The request is completed vias I/O post.
;--

FINISH_RCV_IO:				; Finish recieve I/O request
	MOVL	R2,IRP$L_SVAPTE(R3)	; Save block address
	MOVAL	CXB$C_HEADER(R2),(R2)	; Set the buffer pointer
	MOVL	IRP$L_MEDIA(R3),4(R2)	; Set address of user buffer
	MOVW	CXB$W_LENGTH(R2),R1	; Get size of transfer
	CMPW	R1,IRP$W_BCNT(R3)	; Request larger than actual?
	BLEQU	10$			; Br if no
	MOVZWL	IRP$W_BCNT(R3),R1	; Set size to minimum of two
10$:	MOVW	R1,IRP$W_BCNT(R3)	; Set size to transfer
	ASHL	#16,R1,R0		; Set buffer size in status
	BNEQ	20$			; Br if success
	MOVW	#SS$_CTRLERR,R0		; Set data path error
	BRB	30$			; Fill receive list
 
20$:	MOVW	#SS$_NORMAL,R0		; Set success
30$:	PUSHL	R0			; Save code
	BSBB	FILLRCVLIST		; Fill up the receive buffers
	POPL	R0			; Restore code
;
; Complete an I/O request packet
;
	.enable lsb
IO_DONE:				; Complete a transfer I/O request
	MOVL	R0,IRP$L_IOST1(R3)	; Set status return and size
	CLRL	IRP$L_IOST2(R3)		; Clear second word of status
	MOVL	IRP$L_CDB(R3),R0	; Get CDB address
	BEQL	10$			; Br if none
	CLRL	IRP$L_CDB(R3)		; Clear it out
	BISL	CDB_L_DEVDEPEND(R0),-
		IRP$L_IOST2(R3) 	; Set circuit bits
10$:	BBC	#IRP$V_DIAGBUF,-
		IRP$W_STS(R3),20$	; Br if no diagnostic buffer
	ADDL3	#8,@IRP$L_DIAGBUF(R3),R0; Address buffer past start time
	MOVQ	G^EXE$GQ_SYSTIME,(R0)+	; Insert stop time
	MOVZWL	UCB$W_ERRCNT(R5),(R0)+	; Insert error counter
	BSBW	REG_DUMP		; Dump registers
20$:	JMP	G^COM$POST		; Post the I/O and return

ABORT_PKT:
	MOVZWL	#SS$_ABORT,-
		IRP$L_IOST1(R3)		; Set aborted status
	CLRL	IRP$L_IOST2(R3)		; Set circuit error status
	BRB	10$			; Finish up
	.disable lsb
	.PAGE
	.SBTTL	FILLRCVLIST,  Fill receive buffer list

;++
; FILLRCVLIST - Fill receive buffer list
;
; Functional description:
;
; This routine is entered to make sure that the receive buffer pool
; is full.  If it is not, buffers are allocated and queued to the
; list until it is.
;
; Inputs:
;
;	R4 - CDB address
;	R5 - UCB address
;
; Outputs:
;
;	Receive buffer pool filled.
;
;--

FILLRCVLIST:				; Fill receive buffer list
	CLRL	R2			; Show no buffer

ADDRCVLIST:
	PUSHQ	R3			; Save IRP address
10$:	CMPB	CDB_B_RCV_FQ(R4),-
		CDB_B_RCV_CNT(R4) 	; Should new block be added?
	BGEQ	40$			; Br if no - list filled
	CLRL	R1			; Zero size
	TSTL	R2			; Any block as input?
	BNEQ	20$			; Yes, do not need to allocate
;
; Attempt to allocate a new block.
;
	ADDW3	#CXB$C_OVERHEAD,-	; Compute block size need
		 CDB_W_BUFSIZ(R4),R1	;
	JSB	G^EXE$ALONONPAGED	; Allocate nonpaged memory
	BLBC	R0,30$			; Br if failure
 	MOVW	R1,IRP$W_SIZE(R2)	; Insert block size
20$:	MOVL	CDRP$L_CDT(R4),R3	; Pick up CDT address
	CMPB	UCB$B_CN_PORT(R5),-
		 CDT$B_RSTATION(R3) 	; Talking to ourselves?
	BNEQ	25$			; No
	MOVL	UCB$L_TWIN_CDT(R5),R3	; Yes, use other CDT
25$:	MOVL	UCB$L_PDT(R5),R4	;  and PDT address
	MOVZBW	S^#DYN$C_CXB,-
		 IRP$B_TYPE(R2)		; Insert block type
	QUEUE_DG_BUF			; Put the block on the free que
	BLBC	R0,45$			; Br if failure
	MOVL	4(SP),R4		; Pick up CDB pointer
	INCB	CDB_B_RCV_FQ(R4)	; Bump free que count
	CLRL	R2			; Clear any buffer address
	BRB	10$			; Try for more
;
; Buffer allocation failure - Set a status bit
;
30$:	SETBIT	#XM$V_STS_BUFFAIL,-	; Set buffer alloc failure
		 CDB_L_DEVDEPEND(R4)
	BRB	50$			; And give any receives to device
;
; Buffer allocation success - Number of buffers is now back to the 
; normal quota.  Clear a status bit
;
40$:	CLRBIT	#XM$V_STS_BUFFAIL,-	; Clear buffer alloc failure
		 CDB_L_DEVDEPEND(R4)	;
45$:	MOVL	R2,R0			; Pick up the buffer
	BEQL	50$			; There is none
	BSBW	DEALLMEM		; Get rid of the buffer
50$:	POPQ	R3			; Restore IRP
	RSB				; Return
	.PAGE
	.SBTTL	SEND_XMSG, Send the XOFF message to other side

;++
; SEND_XMSG
;
; Functional description:
;
;	This routine formats and sends a XON/XOFF message to the
;	other side to inform it of the buffer status.
;
; Inputs:
;
;	R0  =	XON or XOFF message
;	R4 -->	CDB
;	R5 -->	UCB
;
; Outputs:
;
;	None
;
;--

SEND_XMSG:
	MOVL	UCB$L_PDT(R5),R2	; Pick up PDT
	MOVL	R4,R5			; Set R5 to cover CDRP
	MOVL	R2,R4			; Transfer PDT
	MOVL	CDRP$L_MSG_BUF(R5),R2	; Pick up the message address
	MOVW	R0,4(R2)		; Set the message
	SEND_MSG_BUF			; Send it on its way
	ALLOC_MSG_BUF			; Get another one
	RSB				; Return eventually	
	.PAGE
	.SBTTL	REG_DUMP,  Device register dump routine

;++
; REG_DUMP, Dumps the contents of device dependent longword to a buffer
;
; Functional description:
;
; Writes the number of longwords returned, and the contents of the
; device dependent longword into a diagnostic or error buffer.
;
; Inputs:
;
;	R0 = Diagnostic buffer address
;	R5 = UCB address
;
; Outputs:
;
;	R0 is destroyed.
;
;	R5 is preserved.
;
;--

REG_DUMP:				; Dump device registers
	MOVZBL	#1,(R0)+		; Store # of longwords returned
	MOVL	UCB$L_DEVDEPEND(R5),(R0)+ ; Store device dependent longword
	RSB				; Return
	.PAGE
	.SBTTL	XLATE,  Translate Channel to CDB address
 
;++
; XLATE - Translate Channel to CDB address
;
; Functional Description:
;
; This routine is called to return the CDB address for a particular
; channel. This routine hashes the middle order 4 bits of the channel
; to start the search. This should optimize scanning of the channel
; vector only if the CDB already exists.
;
; Inputs:
;
;	R3 = IRP address
;	R5 = UCB address
;
; Outputs:
;
;	R0 - status return for success of call.
;
;	R9 = CDB address
;
;	R3-R7 are preserved.
;
;--
 
XLATE:					; Translate CHAN into CDB address
	PUSHL	R3			; Save IRP address
	CVTWL	IRP$W_CHAN(R3),R3	; Get channel
	BLSS	9$			;** Okay
	MNEGL	R3,R3			;** Fix it	
9$:	BSBB	XLATE_CHAN		; Translate channel
	POPL	R3			; Restore IRP address
	BLBC	R0,10$			; Br if error
;
; Found Channel in translation vector, get CDB address
;
40$:	MOVB	R1,IRP$B_INDEX(R3)	; Save index in IRP
	MOVL	R9,IRP$L_CDB(R3)	; Store CDB address in IRP
10$:	RSB				; Return to caller

XLATE_CHAN:
	EXTZV	#4,#4,R3,R1		; Hash channel into 16 indices
	MOVL	R1,R2			; Save start hash
10$:	CMPW	R3,UCB$W_CN_CHAN_VEC(R5)[R1] ; Channels match?
	BEQL	40$			; Br if yes - got it
20$:	INCL	R1			; Else, set to next entry
	BICL	#^C<15>,R1		; Modulo 16
	CMPL	R1,R2			; Back to start?
	BNEQ	10$			; Br if more to check
30$:	MOVZWL	#SS$_DEVOFFLINE,R0	; Return channel offline
	RSB				; And leave
;
; Found match on channel
;
40$:	MOVL	UCB$L_CN_CDB_VEC(R5)[R1],R9 ; Get CDB address
	BEQL	30$			; Br if no CDB address - error
	MOVZWL	S^#SS$_NORMAL,R0	; Set successful return status
	RSB				; Return
	.PAGE
	.SBTTL	CHG_UCB,  Change UCB parameter values
 
;++
; CHG_UCB - Change UCB parameter values
;
; Functional description:
;
; This routine is called to initialize the UCB with new P1 and P2 buffer
; characteristics. It is assumed here that the parameters have already
; been validated.
;
; Inputs:
;
;	R3 = IRP address
;	R5 = UCB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0 = status return for request
;
;	R1,R2 = destroyed.
;--
 
CHG_UCB:				; Validate P2 buffer
;
; Maximum receive buffers
;
	MOVZWL	#NMA$C_PCLI_BFN,R2	; Set to find MAX RCV
	BSBB	UNPACK_P2_BUF		; In P2 buffer
	BLBC	R0,50$			; Br if not found
	MOVB	R1,UCB$W_CN_RCV_CNT(R5)	; Initialize number of RCV
;
; Blocksize
;
50$:	MOVZWL	#NMA$C_PCLI_BUS,R2	; Get buffer size
	BSBB	UNPACK_P2_BUF		; From P2 buffer
	BLBC	R0,60$			; Br if not found
	MOVW	R1,UCB$W_DEVBUFSIZ(R5)	;  and in UCB
60$:	RSB				; Return to caller
	.PAGE
	.SBTTL	VALIDATE_P2,  Validate P2 buffer parameters
 
;++
; VALIDATE_P2 - Validate P2 buffer parameters
;
; This routine is called to validate the P2 buffer parameters. The parameters
; are checked against a parameter table which verifies that the minimum value
; and maximum value is not violated, and that status flags are set or clear
; as required.
;
; The way in this routine is written, the require word of the verification
; table can only have 1 bit set at a time.
;
; Inputs:
;
;	R1 = Address of parameter verification table
;	R2 = Status word from UCB or CDB
;	R3 = IRP address
;	R5 = UCB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0 = status return of parameters
;
;	All other registers are preserved.
;
;--
 
VALIDATE_P2:				; Validate P2 buffer parameters
	PUSHR	#^M<R1,R5,R6,R7,R8>	; Save registers
					; NB:R1 must be on top of stack
	MOVL	IRP$L_SVAPTE(R3),R6	; Get system P2 buffer address
	BEQL	40$			; Br if none
	MOVZWL	IRP$W_BCNT(R3),R8	; Get size of P2 buffer
	DIVL	#6,R8			; Get number of params in P2
;
; Loop to check next parameter in P2 buffer
;
10$:	MOVZWL	(R6)+,R0		; Get parameter type from P2
	MOVL	(R6)+,R5		; Get parameter value from P2
	MOVL	(SP),R7			; Get parameter table address
;
; Loop to check P2 buffer parameter to circuit parameter table
;
20$:	TSTW	(R7)			; End of table?
	BEQL	50$			; Br if yes - error
	MOVW	(R7)+,R1		; Pick up param
	BICW2	#^C<PRM_M_TYPE>,R1	; Clean out other bits
	CMPW	R0,R1			; Parameters match?
	BEQL	30$			; Br if yes
	ADDL2	#PARAM_C_SKIP,R7	; Else, skip to next parameter
	BRB	20$			; Try next parameter
;
; Match found - check min,max,valid,invalid
;
30$:	TSTW	(R7)+			; Skip type/offset
	CMPW	R5,(R7)+		; Is the value too small?
	BLSSU	50$			; Br if yes - error
	CMPW	R5,(R7)+		; Is the value too big?
	BGTRU	50$			; Br if yes - error
	MOVW	(R7)+,R5		; Pick up required
	BEQL	35$			; None
	BITW	R5,R2			; Check required bit
	BEQL	50$			; Br if not on - error
35$:	BITW	(R7)+,R2		; Check invalid bits
	BNEQ	50$			; Br if on - error
	SOBGTR	R8,10$			; Br if more parameters
40$:	MOVZWL	S^#SS$_NORMAL,R0	; Set success return
	BRB	60$			; And return
 
50$:	MOVZWL	R0,(SP)			; Return bad parameter type
	MOVL	#SS$_BADPARAM,R0	; Set error return
60$:	POPR	#^M<R1,R5,R6,R7,R8>	; Restore registers
	RSB				; Return to caller
	.PAGE
	.SBTTL	UNPACK_P2_BUF,  Unpack a P2 parameter from P2 buffer
 
;++
; UNPACK_P2_BUF - Unpack a P2 parameter from P2 buffer
;
; Functional description:
;
; This routine is called to get a P2 parameter from the P2 buffer.
;
; Inputs:
;
;	R2 = Parameter type code
;	R3 = IRP address
;	R5 = UCB address
;
; Outputs:
;
;	R0 = Low bit clear if specified Parameter type code is found in P2
;	R1 = Parameter value if success else destroyed
;
;	All other registers are preserved.
;
;--
 
UNPACK_P2_BUF:				; Unpack P2 buffer
	PUSHR	#^M<R5,R6,R7>		; Save registers
	MOVL	IRP$L_SVAPTE(R3),R6	; Get system P2 buffer address
	BEQL	20$			; Br if none
	MOVZWL	IRP$W_BCNT(R3),R7	; Get size of P2 buffer
	DIVL	#6,R7			; Get number of params in P2
	MOVZWL	S^#SS$_NORMAL,R0	; Assume success
;
; Loop to check next parameter in P2 buffer
;
10$:	MOVZWL	(R6)+,R5		; Get parameter type from P2
	MOVL	(R6)+,R1		; Get parameter value from P2
	CMPW	R2,R5			; Parameters match?
	BEQL	30$			; Br if yes
	SOBGTR	R7,10$			; Br if more parameters
 
20$:	CLRQ	R0			; Return error
30$:	POPR	#^M<R5,R6,R7>		; Restore registers
	RSB				; Return to caller
	.PAGE
	.SBTTL	CN_END,  End of driver
	LC=.
	.=<<LC+15>&-16>
PATCH::	.LONG	32-8
	.LONG	PATCH+8
	.BLKB	32-8
 
;++
; Label that marks the end of the driver
;--

CN_END:					; Last location in driver
 
	.END
