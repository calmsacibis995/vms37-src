	.TITLE	RTTDRIVER - Remote Terminal Driver
	.IDENT	'V03-002'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
;
; FACILITY:
;
;	VAX/VMS Remote Terminal Driver
;
; ABSTRACT:
;
;	This module contains the remote terminal driver routines.  This driver
;	is used by the application process side of the operation.  In other
;	words, it receives the QIO requests from the process that does not
;	have local access to the terminal.
;
;	This driver's primary function is to receive QIO system service
;	requests, repackage the QIO arguments, and hand the new package to
;	the tranport mechanism for delivery to the remote terminal
;	handler process on the system with local access to the terminal.
;	The transport mechanism is DECnet.  Netdriver is called directly
;	via the internal IRP mechanism.
;
; AUTHOR:
;
;	Len Kawell, 01-AUG-1979
;
; MODIFICATION HISTORY:
;
;	V03-002	DJD3007		Darrell Duffy	5-April-1982
;		Trap IO$M_ESCAPE and IO$M_EXTEND with reads to V2 systems.
;		Trap IO$M_ENABL_ALT IO$M_DSABL_ALT in SETMODE.
;
;	V03-001	DJD3006		Darrell Duffy	31-March-1982
;		Fix SENSEMODE TYPAHDCNT to return correct status.
;		Insert setting of mode bits for fixing spawn.
;
;	V02-016	DJD3005		Darrell Duffy	13-January-1982
;		Fix flushing of CTRL/Y to occur at deassign.
;		Use new cancel interface to distinguish cancel and deassign.
;
;	V02-015	DJD3004		Darrell Duffy	20-December-1981
;		Revert to use of attn ast processing for CTRL C and Y.
;		Remove privileges associated with declaring a ctrl/y ast.
;
;	V02-014	DJD3003		Darrell Duffy	24-November-1981
;		Add out-of-band ast support.  Fix bug in delivery
;		of hangup ast when the link has broken before it
;		was enabled.
;
;	V02-013	DJD3002		Darrell Duffy	12-November-1981
;		More of the same.
;
;	V02-012 DJD3001		Darrell Duffy	21-October-1981
;		Update for changes to terminal driver for V3.0
;
;	V02-011	DJD2004		Darrell Duffy	31-July-1981
;		Change broadcast interface to return failure on
;		terminal set for NOBROADCAST
;
;	V02-010 DJD2003		Darrell Duffy	2-May-1981
;		Fix double deallocate of rtt ucb.
;
;	V02-009 RLRLBCNT	Robert L. Rappaport	8-April-1981
;		Changes associated with IRP modifications to all BCNT
;		fields which have grown to longwords.  Also fix old bug
;		in RTT_WRITE which sometimes left garbage in R1.
;
;	V02-008 DJD2002		Darrell Duffy	8-Apr-1981
;		Fix race condition with broadcast messages after hangup.
;
;	V02-007	DJD2001		Darrell Duffy	5-Mar-1981
;		Change to call network driver directly to read and
;		write packets.
;
;	V02-006	LMK0006		Len Kawell	27-Feb-1981
;		Fix problem with immediate delivery of hangup AST when
;		AST is being cancelled.
;
;	1.05	LMK0005		Len Kawell	18-Mar-1980
;		Change broadcast to call EXE$ALONONPAGED.
;
;	1.04	LMK0004		Len Kawell	29-Feb-1980
;		Change adapter type in DPTAB to be NULL.
;
;	1.03	LMK0003		Len Kawell	25-Feb-1980
;		Change broadcast to not wait for completion to avoid
;		causing issuing process to indefinitely wait if delays
;		occur during remote delivery.
;
;	1.02	LMK0002		Len Kawell	21-Jan-1980
;		Add UCB$M_HANGUP flag so hangup is never lost.
;
;--

	.SBTTL	External and local symbol definitions

;
; External symbols
;

	$ACBDEF				; AST control block
	$AQBDEF				; ACP queue block
	$CANDEF				; Cancel interface codes
	$CRBDEF				; Channel request block
	$DCDEF				; Device classes and types
	$DDBDEF				; Device data block
	$DEVDEF				; Device characteristics
	$DYNDEF				; Buffer type codes
	$IDBDEF				; Interrupt data block
	$IODEF				; I/O function codes
	$IPLDEF				; Hardware IPL definitions
	$IRPDEF				; I/O request packet
	$JIBDEF				; Job Information block
	$MSGDEF				; Mailbox message types
	$PCBDEF				; Process control block
	$PRDEF				; Processor registers
	$PRVDEF				; Privilege bits
	$PSLDEF				; Processor status longword
	$RBFDEF				; Remote Device Buffer definitions
	$RDPDEF				; Remote device packet
	$REMDEF				; General constants
	$SSDEF				; System status codes
	$TTDEF				; Terminal definitions
	$TT2DEF				; More definitions
	$TTYDEF				; Terminal driver definitions
	$UCBDEF				; Unit control block
	$VCBDEF				; Volume control block
	$VECDEF				; Interrupt vector block

;
; Local symbols
;

;
; Argument list (AP) offsets for device-dependent QIO parameters
;

P1	= 0				; First QIO parameter
P2	= 4				; Second QIO parameter
P3	= 8				; Third QIO parameter
P4	= 12				; Fourth QIO parameter
P5	= 16				; Fifth QIO parameter
P6	= 20				; Sixth QIO parameter



;
; Other constants
;

RTT$K_FIPL = 8				; IPL to synchronize

;
; Definitions that follow the standard UCB fields
;

	$RTTUCBEXT			; UCB Extensions

;
; Redefinitions of the irp fields
;

IRP$W_RTT_COMPAT = IRP$Q_TT_STATE	; Set for compatiblity error

	.SBTTL	Standard tables

;
; Driver prologue table
;

	DPTAB	-				; DPT-creation macro
		END=RTT_END,-			; End of driver label
		ADAPTER=NULL,-			; Adapter type
		UCBSIZE=<UCB$K_RTT_LEN>,-	; Length of UCB
		NAME=RTTDRIVER			; Driver name
	DPT_STORE INIT				; Start of load
						; initialization table
	DPT_STORE DDB,DDB$L_ACPD,L,<^A\REM\> 	; Default ACP name
	DPT_STORE DDB,DDB$L_ACPD+3,B,3		; ACP class
	DPT_STORE UCB,UCB$B_FIPL,B,RTT$K_FIPL	; Device fork IPL
	DPT_STORE UCB,UCB$B_DIPL,B,RTT$K_FIPL	; Device interrupt IPL
	DPT_STORE UCB,UCB$L_DEVCHAR,L,<-	; Device characteristics
		DEV$M_REC!-			;   record device
		DEV$M_AVL!-			;   available
		DEV$M_IDV!-			;   input device
		DEV$M_ODV!-			;   output device
		DEV$M_TRM!-			;   terminal device
		DEV$M_CCL>			;   carriage control device
	DPT_STORE UCB,UCB$B_DEVCLASS,B,DC$_TERM	; Terminal device
	DPT_STORE UCB,UCB$B_DEVTYPE,B,TT$_UNKNOWN ; Unknown type
	DPT_STORE UCB,UCB$W_DEVBUFSIZ,@W,TTY$GW_DEFBUF ; Default buffer size
	DPT_STORE UCB,UCB$L_DEVDEPEND,@L,TTY$GL_DEFCHAR ; Default characteristics
	DPT_STORE UCB,UCB$W_VPROT,@W,TTY$GW_PROT ; Default allocation protection
	DPT_STORE UCB,UCB$L_OWNUIC,@L,TTY$GL_OWNUIC ; Default owner UIC

	DPT_STORE REINIT			; Start of reload
						; initialization table
	DPT_STORE DDB,DDB$L_DDT,D,RTT$DDT	; Address of DDT
	DPT_STORE CRB,CRB$L_INTD+4,D,-		; Address of interrupt
		RTT_INTERRUPT			; service routine

	DPT_STORE END				; End of initialization
						; tables

;
; Driver dispatch table
;

	DDTAB	-				; DDT-creation macro
		DEVNAM=RTT,-			; Name of device
		FUNCTB=RTT_FUNCTABLE,-		; FDT address
		UNSOLIC=RTT_UNSOLIC,-		; Unsolicited attention routine
		ALTSTART=RTT_BROADCAST,-	; Broadcast start I/O routine
		CANCEL=RTT_CANCEL		; Cancel I/O routine

;
; Function dispatch table
;

RTT_FUNCTABLE:					; FDT for driver
	FUNCTAB	,-				; Valid I/O functions
		<READVBLK,-			; Read virtual
		READLBLK,-			; Read logical
		READPBLK,-			; Read physical
		READPROMPT,-			; Read with prompt
		TTYREADALL,-			; Read passall
		TTYREADPALL,-			; Read with prompt passall
		WRITEVBLK,-			; Write virtual
		WRITELBLK,-			; Write logical
		WRITEPBLK,-			; Write physical
		SENSEMODE,-			; Sense device mode
		SENSECHAR,-			; Sense device characteristics
		SETMODE,-			; Set device mode
		SETCHAR>			; Set device characteristics
	FUNCTAB	,-				; Buffered functions
		<READVBLK,-			; Read virtual
		READLBLK,-			; Read logical
		READPBLK,-			; Read physical
		READPROMPT,-			; Read with prompt
		TTYREADALL,-			; Read passall
		TTYREADPALL,-			; Read with prompt passall
		WRITEVBLK,-			; Write virtual
		WRITELBLK,-			; Write logical
		WRITEPBLK,-			; Write physical
		SENSEMODE,-			; Sense device mode
		SENSECHAR,-			; Sense device characteristics
		SETMODE,-			; Set device mode
		SETCHAR>			; Set device characteristics
	FUNCTAB	RTT_READ,-			; FDT read routine for
		<READVBLK,-			; read virtual,
		READLBLK,-			; read logical,
		READPBLK,-			; read physical,
		READPROMPT,-			; read with prompt
		TTYREADALL,-			; read passall,
		TTYREADPALL>			; and read with prompt passall
	FUNCTAB	RTT_WRITE,-			; FDT write routine for
		<WRITEVBLK,-			; write virtual,
		WRITELBLK,-			; write logical,
		WRITEPBLK>			; and write physical.
	FUNCTAB	RTT_SENSEMODE,-			; FDT sense mode routine
		<SENSECHAR,-			; for sense characteristics
		SENSEMODE>			; and sense mode.
	FUNCTAB	RTT_SETMODE,-			; FDT set mode routine
		<SETCHAR,-			; for set characteristics and
		SETMODE>			; set mode.

	.SBTTL	RTT_WRITE - Function Decision Routine for WRITE Functions
.SHOW BINARY
;++
; RTT_WRITE - Function Decision Routine for WRITE Functions
;
; Functional description:
;
;	This routine is called by the SYS$QIO service to dispatch a WRITE
;	I/O request.
;
;	The QIO parameters for terminal WRITES are:
;
;	P1 = address of the buffer
;	P2 = size of the buffer
;	P3 = (unused)
;	P4 = carriage control specifier
;
;	The buffer is validated for access, the process's quota checked and
;	decremented, the data and carriage control are copied to a message
;	block, the address of the message block is stored in the IRP,
;	and the IRP is queued to the ACP for delivery to the remote system.
;
; Inputs:
;
;	R0-R2 = scratch registers
;	R3 = address of the IRP (I/O request packet)
;	R4 = address of the PCB (process control block)
;	R5 = address of the UCB (unit control block)
;	R6 = address of the CCB (channel control block)
;	R7 = bit number of the I/O function code
;	R8 = address of the FDT table entry for this routine
;	R9-R11 = scratch registers
;	AP = address of the 1st function dependent QIO parameter
;
; Outputs:
;
;	IRP$L_SVAPTE(R3) = address of message buffer
;	IRP$W_BOFF(R3) = size of message buffer
;	IRP$W_BCNT(R3) = size of user buffer
;
;	The routine preserves all registers except R0-R2, and
;	R9-R11.
;
;--
RTT_WRITE:				; WRITE FDT routine
	MOVL	P1(AP),R6		; Get user buffer virtual address
	MOVL	R6,R0			; Set up for write check call
	MOVZWL	P2(AP),R7		; Get buffer size
	MOVL	R7,R1			; Set up for write check call
	BEQL	10$			; Skip check if zero
	JSB	G^EXE$WRITECHK		; Check buffer access
					; (no return means no access)
;
; Allocate the message buffer
;
10$:
	ADDL	#RBF$T_TT_WDATA,R1	; Add header to request size
	BSBW	ALLOC_MESSAGE		; Allocate the message buffer
;
; Copy the data and carriage control to the message
;
	MOVZWL	R7,RBF$L_TT_BCNT(R2)	; Set requested byte count
	PUSHR	#^M<R2,R3,R4,R5>	; Save registers
	MOVC3	R7,(R6),RBF$T_TT_WDATA(R2) ; Copy data
	MOVL	R3,R1			; Save adr beyond data
	POPR	#^M<R2,R3,R4,R5>	; Restore the registers
	MOVL	P4(AP),RBF$L_TT_CARCON(R2) ; Copy carriage control
;
; Send the message to the remote device and exit QIO service
;
	MOVL	R1,R2			; Pointer beyond data in message
	CLRW	IRP$W_RTT_COMPAT(R3)	; No compatibility error
	BRW	RTT_NETMSGSENDX		;

	.SBTTL	RTT_READ - Function Decision Routine for READ Functions

;++
; RTT_READ - Function Decision Routine for READ Functions
;
; Functional description:
;
;	This routine is called by the SYS$QIO service to dispatch a READ
;	I/O request.
;
;	The QIO parameters for terminal READS are:
;
;	P1 = address of the buffer
;	P2 = size of the buffer
;	P3 = number of seconds to wait for characters
;	P4 = address of terminator class bitmask or 0 if standard
;	P5 = address of prompt string for IO$_READPROMPT or IO$_TTYREADPALL
;	P6 = size of prompt string for IO$_READPROMPT or IO$_TTYREADPALL
;
;	The buffer is validated for access, the process's quota checked and
;	decremented, the timeout, terminator mask, and prompt are copied to a
;	message block, the address of the message block is stored in the IRP,
;	and the IRP is queued to the ACP for delivery to the remote system.
;
; Inputs:
;
;	R0-R2 = scratch registers
;	R3 = address of the IRP (I/O request packet)
;	R4 = address of the PCB (process control block)
;	R5 = address of the UCB (unit control block)
;	R6 = address of the CCB (channel control block)
;	R7 = bit number of the I/O function code
;	R8 = address of the FDT table entry for this routine
;	R9-R11 = scratch registers
;	AP = address of the 1st function dependent QIO parameter
;
; Outputs:
;
;	IRP$L_SVAPTE(R3) = address of message buffer
;	IRP$W_BOFF(R3) = size of message buffer
;	IRP$L_MEDIA(R3) = address of user buffer
;	IRP$W_BCNT(R3) = size of user buffer
;
;	The routine preserves all registers except R0-R2, and
;	R9-R11.
;
;--
RTT_READ:				; READ FDT routine
	TSTB	UCB$B_RTT_PROECO(R5)	; Old system
	BNEQ	5$			; Nope
	BITW	#<IO$M_ESCAPE!-		; Look for new modifiers
		IO$M_EXTEND>,-		; for the read function
		IRP$W_FUNC(R3)		;
	BEQL	5$			; Nope, they are not here
	MOVZWL	#SS$_INCOMPAT+3, R0	; Reject the new modifiers
	BRW	READ_ERROR		; with an incompat error not success
5$:
;
; Check access to user's buffer
;
	MOVL	P1(AP),R10		; Get user buffer virtual address
	MOVL	R10,R0			; Set up for read check call
	MOVL	R0,IRP$L_MEDIA(R3)	; Save address in packet
	MOVZWL	P2(AP),R11		; Get buffer size
	BEQL	10$			; Skip check if zero
	MOVL	R11,R1			; Set up for read check call
	JSB	G^EXE$READCHK		; Check buffer access
					; (no return means no access)
;
; Get prompt, if specified
;
10$:
	MOVL	#2,R1			; Initialize size of message required
					; with size of prompt size
	CLRL	R7			; Assume no prompt specified
	CMPZV	#IRP$V_FCODE,#IRP$S_FCODE,- ; Read with prompt function?
		IRP$W_FUNC(R3),#IO$_READPROMPT	
	BEQL	20$			; Branch if yes
	CMPZV	#IRP$V_FCODE,#IRP$S_FCODE,- ; Read with prompt passall function?
		IRP$W_FUNC(R3),#IO$_TTYREADPALL
	BNEQ	50$			; Branch if not
20$:	MOVZWL	P6(AP),R7		; Get size of prompt
	BEQL	50$			; If eql then make this normal read
	MOVL	P5(AP),R6		; Get prompt buffer address
;
; Check access to prompt string
;
	MOVQ	R6,R0			; Set up address and size for check
	JSB	G^EXE$WRITECHK		; Check prompt access
					; (no return means no access)
	MOVW	R11,IRP$W_BCNT(R3)	; Reset read buffer size
					; (modified by EXE$WRITECHK)
	ADDW	#2,R1			; Add size of prompt size to total
;
; Get terminator bitmask and check access
;
50$:
	CLRL	R8			; Assume no terminator specified
	MOVL	P4(AP),R9		; Get address of terminator desc
	BEQL	65$			; If eql none specified
	MOVZWL	#SS$_ACCVIO,R0		; Assume no access
	IFNORD	#8,(R9),READ_ERROR	; Descriptor accessible?
	MOVZWL	(R9),R8			; Get bitmask size
	BNEQ	60$			; If neq long format
	MOVL	#4,R8			; Size of short format
	ADDL	#4,R9			; Set address of bitmask
	BRB	65$			;
60$:
	MOVL	4(R9),R9		; Get address of long format bitmask
	IFNORD	R8,(R9),READ_ERROR	; Bitmask accessible?
	CMPW	R8,#32			; Bitmask greater than allowed size?
	BGTRU	READ_ERROR		; If gtru yes
65$:
	ADDL	R8,R1			; Add size of bitmask to message size
	INCL	R1			; Plus one for size byte
;
; Allocate the message buffer
;
	ADDL	#RBF$T_TT_TERM,R1	; Add header size to message size
	BSBW	ALLOC_MESSAGE		; Allocate the message buffer
;
; Copy the timeout, terminator bitmask, and prompt string to the message
;
	MOVZWL	R11,RBF$L_TT_BCNT(R2)	; Set requested byte count
	MOVL	P3(AP),RBF$L_TT_TIMOUT(R2) ; Set timeout value
	MOVB	R8,RBF$T_TT_TERM(R2)	; Set terminator bitmask size
	PUSHR	#^M<R2,R3,R4,R5>	; Save registers
	MOVC	R8,(R9),RBF$T_TT_TERM+1(R2) ; Copy terminator bitmask
	MOVW	R7,(R3)+		; Set size of prompt
	MOVC	R7,(R6),(R3)		; Copy prompt string
	MOVL	R3,R1			; Save adr beyond data
	POPR	#^M<R2,R3,R4,R5>	; Restore registers
;
; Send the message the remote device and exit the QIO service
;
	MOVL	R1,R2			; Set address beyond data
	CLRW	IRP$W_RTT_COMPAT(R3)	; No compatiblity error
	BRW	RTT_NETMSGSENDX		;
;
; Error in processing
;
READ_ERROR:				; READ FDT error
	JMP	G^EXE$ABORTIO		; Abort the I/O request

	.SBTTL	RTT_SETMODE, Function Decision Routine for SETMODE/SETCHAR
;++
; RTT_SETMODE, Function Decision Routine for SETMODE/SETCHAR Functions
;
; Functional description:
;
;	This routine is called by the SYS$QIO service to dispatch a SETMODE
;	or SETCHAR I/O request.
;
;	The QIO parameters for terminal SETMODE or SETCHAR are:
;
;
;		P1 = address of 8 byte characteristics buffer
;		P2 = 0, 8 or 12
;		P3 = speed specifier
;		P4 = fill specifier
;		P5 = parity flags
;
;	IO$V_CTRLYAST -
;		P1 = AST routine address or zero to cancel
;
;	IO$V_CTRLCAST -
;		 P1 = AST routine address or zero to cancel
;
;	IO$V_HANGUP -
;		NONE
;
;	The buffer (if any) is validated for access, the process's quota
;	checked and decremented, a message block is allocated, the parameters
;	(if any) are stored in the  message block, the address of the message
;	block is stored in the IRP, and the IRP is queued to the ACP for
;	delivery to the remote system.
;
;	If an AST is to be enabled, an AST control block is allocated locally
;	hung off the UCB for later delivery upon receipt of a corresponding
;	attention message from the remote system.
;
; Inputs:
;
;	R0-R2 = scratch registers
;	R3 = address of the IRP (I/O request packet)
;	R4 = address of the PCB (process control block)
;	R5 = address of the UCB (unit control block)
;	R6 = address of the CCB (channel control block)
;	R7 = bit number of the I/O function code
;	R8 = address of the FDT table entry for this routine
;	R9-R11 = scratch registers
;	AP = address of the 1st function dependent QIO parameter
;
; Outputs:
;
;	IRP$L_SVAPTE(R3) = address of message buffer
;	IRP$W_BOFF(R3) = size of message buffer
;
;	The routine preserves all registers except R0-R2, R7, and R9-R11
;--
RTT_SETMODE:				; SETMODE/SETCHAR FDT routine
	CLRW	IRP$W_RTT_COMPAT(R3)	; No compatibility error
	BBC	#IO$V_HANGUP,-		; Hangup ignores params
		IRP$W_FUNC(R3),10$	;
	BRW	SET_MESSAGE		;
10$:	MOVAL	UCB$L_RTT_CTRLC(R5),R7	; Assume CNTRL/C AST enable
	BBS	#IO$V_CTRLCAST,-	; Branch if CNTRL/C enable
		IRP$W_FUNC(R3),20$	;
	MOVAL	UCB$L_RTT_CTRLY(R5),R7	; Get address of CNTRL/Y AST list
	BBC	#IO$V_CTRLYAST,-	; Branch if not CNTRL/Y enable
		IRP$W_FUNC(R3),SET_CHAR	;
;	IFPRIV	LOG_IO,20$		; Branch if LOG_IO privilege
;	MOVZWL	#SS$_NOPRIV,R0		; Assume no privilege
;	MOVPSL	R1			; Get PSL
;	CMPZV	#PSL$V_PRVMOD,#PSL$S_PRVMOD,R1,#PSL$C_SUPER ; Privileged caller?
;	BLEQ	20$			; If leq yes
;	BRW	ABORT			; Else, error
20$:
	JSB	G^COM$SETATTNAST	; Enable an attention AST
	BBC	#IO$V_CTRLYAST,IRP$W_FUNC(R3),30$ ; Branch if not CNTRL/Y enabl
	BBC	#UCB$V_TT_HANGUP,UCB$W_DEVSTS(R5),30$ ; Branch if no hangup
	MOVL	(R7),R0			; Get address of AST block
	BEQL	30$			; If eql, no AST to deliver
	MOVL	R7,R4			; Set address of AST listhead
	MOVZWL	#SS$_HANGUP,ACB$L_KAST+4(R0) ; Set AST parameter to hangup
	JSB	G^COM$DELATTNAST	; Deliver the AST immediately
	MOVZWL	#SS$_NORMAL,R0		; Set success
	JMP	G^EXE$FINISHIOC		; Complete the I/O
30$:
	MOVL	P1(AP),R9		; Get address of AST routine
	BRB	SET_MESSAGE		;	
;
; Set terminal characteristics
;
SET_CHAR:				; Set characteristics
	TSTB	UCB$B_RTT_PROECO(R5)	; Previous version
	BNEQ	10$			; Nope
	BITW	#^CIRP$M_FCODE, -	; Extra bits?
		IRP$W_FUNC(R3)		; as modifier
	BEQL	10$			; Nope
	MOVZWL	#SS$_INCOMPAT+3, R0	; Abort maintenance, outband, etc.
5$:	BRW	ABORT			; with an error not success
10$:	BBS	#IO$V_OUTBAND,-		; Is this an outofband
		IRP$W_FUNC(R3),-	; enable
		RTT_SETBAND		; function?
	BITW	#<IO$M_ENABL_ALT!-	; Trap enable and disable alternate
		IO$M_DSABL_ALT>,-	; driver stuff
		IRP$W_FUNC(R3)		; since FDT routine is not here
	BEQL	11$			; to process QIO.
	MOVZWL	#SS$_ILLIOFUNC, R0	; Return as illegal operation
	BRB	5$			; Issue the error

11$:	MOVL	P1(AP),R1		; Get address of characteristics
	BSBW	RTT_CHARSIZE		; Obtain the size of the char buffer
	MOVZWL	#SS$_ACCVIO,R0		; Assume access violation
	IFNORD	R2,(R1),5$		; Characteristics accessible?
	MOVL	UCB$L_RTT_DEVDEPEND2(R5),- ;
		R11			; Extended word is defaulted
	MOVQ	(R1)+,R9		; Get characteristics
	CMPL	R2, #12			; Do we get another longword?
	BLSS	20$			; Nope
	MOVL	(R1)+, R11		; Obtain the third longword
20$:	MOVQ	R9,UCB$B_DEVCLASS(R5)	; Set local copy of characteristics
	MOVL	R11, -			; And extended longword
		UCB$L_RTT_DEVDEPEND2(R5);
	TSTB	UCB$B_RTT_PROECO(R5)	; If old version
	BNEQ	30$			; Nope
	BITL	# <<<1@24>-1>-<<1@TT$V_HALFDUP>-1>>,-
		UCB$L_DEVDEPEND(R5)	; If extra bits set, then
	BEQL	30$			; return incompat error
	MOVW	#SS$_INCOMPAT,-		; but carry on with function
		IRP$W_RTT_COMPAT(R3)	;
30$:
;
; Create SET message and send to remote device
;
SET_MESSAGE:				; Create and queue SET message
	MOVL	#RBF$L_TT_CHAR2+4,R1	; Set size of message buffer
	BSBW	ALLOC_MESSAGE		; Allocate a message buffer
	MOVQ	R9,RBF$Q_TT_CHAR(R2)	; Set characteristics or AST parameter
	MOVL	R11, RBF$L_TT_CHAR2(R2)	; And the next longword
	MOVL	P3(AP),RBF$L_TT_SPEED(R2) ; Set speed
	MOVL	P4(AP),RBF$L_TT_FILL(R2) ; Set fills
	MOVL	P5(AP),RBF$L_TT_PARITY(R2) ; Set parity
	CMPB	UCB$B_RTT_PROECO(R5), -	; How long should the message be?
		#REM$C_CURECO		; Long or short
	BNEQ	10$			; Shorter message
	MOVAB	RBF$L_TT_CHAR2+4(R2),R2	; Address of longer message
	BRB	20$
10$:	MOVAB	RBF$L_TT_PARITY+4(R2),R2; Set address beyond data
20$:	BRW	RTT_NETMSGSENDX		; Send message to remote and exit service

;
; Process a setmode for an outofband ast
;

RTT_SETBAND:
	BBS	#IO$V_INCLUDE, -	; Include list?
		IRP$W_FUNC(R3), 10$	;
	MOVAB	UCB$L_RTT_BANDEXCL(R5),- ; Address of exclude ast list
		R7			;
	MOVAB	UCB$L_RTT_BANDEXMSK(R5),- ; Address of the exclude mask
		R2			;
	BRB	20$

10$:	MOVAB	UCB$L_RTT_BANDINCL(R5),- ; Address of include ast list
		R7			;
	MOVAB	UCB$L_RTT_BANDINMSK(R5),- ; Address of the include mask
		R2			;
20$:
	JSB	G^COM$SETCTRLAST	; Enable the asts
	MOVL	#RBF$B_TT_OUTBAND+1+4+1+4,-;
		R1			; Set size of message
	BSBW	ALLOC_MESSAGE		; Allocate a message
	MOVAB	RBF$B_TT_OUTBAND(R2),-	; Address of data in message
		R2			;
	MOVB	#4, (R2)+		; Count for include mask
	MOVL	UCB$L_RTT_BANDINMSK(R5),-; Include mask
		(R2)+			;
	MOVB	#4, (R2)+		; Count for exclude mask
	MOVL	UCB$L_RTT_BANDEXMSK(R5),- ; Now the exclude mask
		(R2)+			;
	BRW	RTT_NETMSGSENDX		; Send the message

	.SBTTL	ABORT, Transfer to EXE$ABORTIO

;
; Error processing - abort I/O request
;
ABORT:					;
	JMP	G^EXE$ABORTIO		;



	.SBTTL	RTT_CHARSIZE, Size of characteristics buffer
;++
; RTT_CHARSIZE
;
; inputs
;	AP -> qio argument list
;
; outputs
;	r2 = 8 or 12 for size of characteristics buffer
;
; ABORT if P2(ap) is not 0, 8, 12.
; Return ss$_incompat if not current system and size is 12.
;--

RTT_CHARSIZE:
	MOVL	P2(AP), R2	; Size of characters buffer
	BEQL	10$		; Zero is for 8
	CMPL	R2, #8		; 8 is allowed
	BEQL	20$		; Ok
	BLSSU	30$		; Less is no good
	BSBB	RTT_ECOQ	; If greater then we must be latest
	CMPL	R2, #12		; Must be 12 and nothing else
	BNEQ	30$		; No good
	RSB			; Ok
10$:	MOVL	#8, R2		; Use 8 if zero
20$:	RSB

30$:	MOVZWL	#SS$_BADPARAM, R0	; Abort qio with an error
	BRW	ABORT

	.SBTTL	RTT_ECOQ, Validate latest eco number
;++
; RTT_ECOQ
;
; inputs
;	r3 -> irp
;	r5 -> ucb
; outputs
;	return if eco is latest,
;	else abort QIO with ss$_badparam
;--

RTT_ECOQ:
	CLRW	IRP$W_RTT_COMPAT(R3)	; Make sure its zero
	TSTB	UCB$B_RTT_PROECO(R5)	; Latest for now is just a one
	BNEQ	10$			; zero is last eco level
	MOVW	#SS$_INCOMPAT,-		; Return quiet error
		IRP$W_RTT_COMPAT(R3)	; message
10$:	RSB

	.SBTTL	RTT_SENSEMODE, Function Decision Routine for SENSEMODE/SENSECHAR
;++
; RTT_SENSEMODE, Function Decision Routine for SENSEMODE/SENSECHAR Functions
;
; Functional description:
;
;	This routine is called by the SYS$QIO service to dispatch a SENSEMODE
;	or SENSECHAR I/O request.
;
;	The QIO parameters for terminal SENSEMODE/SENSECHAR are:
;
;	P1 = address of 8 or 12 byte characteristics buffer
;	P2 = 0, 8 or 12
;
;	The buffer is validated for access, the process's quota checked and
;	decremented, a message block is allocated, the address of the message
;	block is stored in the IRP, and the IRP is queued to the ACP for
;	delivery to the remote system.
;
; Inputs:
;
;	R0-R2 = scratch registers
;	R3 = address of the IRP (I/O request packet)
;	R4 = address of the PCB (process control block)
;	R5 = address of the UCB (unit control block)
;	R6 = address of the CCB (channel control block)
;	R7 = bit number of the I/O function code
;	R8 = address of the FDT table entry for this routine
;	R9-R11 = scratch registers
;	AP = address of the 1st function dependent QIO parameter
;
; Outputs:
;
;	IRP$L_SVAPTE(R3) = address of message buffer
;	IRP$W_BOFF(R3) = size of message buffer
;	IRP$L_MEDIA(R3) = address of user characteristics buffer
;	IRP$W_BCNT(R3) = size of user characteristics buffer, 8
;
;	The routine preserves all registers except R0-R2, and R9-R11
;--
RTT_SENSEMODE:				; SENSEMODE/SENSECHAR FDT routine
	CLRW	IRP$W_RTT_COMPAT(R3)	; No compatibility error
	MOVL	P1(AP),R1		; Get address of characteristics buffer
	BSBB	RTT_CHARSIZE		; Size of chars buffer
	MOVZWL	#SS$_ACCVIO,R0		; Assume access violation
	IFNOWRT	R2,(R1),ABORT		; Buffer accessible?
	TSTB	UCB$B_RTT_PROECO(R5)	; Previous version
	BNEQ	10$			; Nope
	BICW3	#IRP$M_FCODE,-		; Obtain the modifiers
		IRP$W_FUNC(R3), R0	; to look for bad ones
	CMPW	R0, #IO$M_TYPEAHDCNT	; Only good one
	BEQL	10$			; Ok
	MOVW	#SS$_INCOMPAT,-		; Return quiet error
		IRP$W_RTT_COMPAT(R3)	; to signal the incompatibility
10$:	MOVL	R1,IRP$L_MEDIA(R3)	; Save address in packet
	MOVW	R2,IRP$W_BCNT(R3)	; Set size in packet
	BISW	#IRP$M_FUNC,IRP$W_STS(R3) ; Set READ type function
	MOVL	#RBF$K_HEADERLEN,R1	; Set size of message buffer
	BSBW	ALLOC_MESSAGE		; Allocate the message buffer
	MOVAB	RBF$L_PARAM1(R2),R2	; R2 points to end of data
	BRW	RTT_NETMSGSENDX		; Send the message and exit service

	.SBTTL	RTT_BROADCAST - Broadcast Start I/O Routine
;++
; RTT_BROADCAST - Broadcast Start I/O Routine
;
; Functional description:
;
;	This routine is called by the SYS$BRDCST service to dispatch a
;	broadcast I/O request.
;
; Inputs:
;
;	R0-R2 = scratch registers
;	R3 = address of write I/O packet
;	R4 = address of the PCB (process conrol block)
;	R5 = address of the UCB (unit control block)
;
; Outputs:
;
;	A message block is allocated, the broadcast message is
;	copied to the block,  the function code in the message is set to
;	-1, an I/O packet is allocated the addresss of the message block is 
;	stored in the I/O packet, and the I/O packet is queued to the ACP for
;	delivery to the remote system.  The SYS$BRDCST service is returned
;	to with a status indicating that the broadcast shouldn't be waited
;	for.  This prevents the issuing process from waiting indefinitely
;	should some delay occur during delivery.
;
;--
RTT_BROADCAST:				; BROADCAST routine
	PUSHR	#^M<R4,R5,R6,R7>	; Save registers
	MOVL	R3,R7			; Save address of broadcast message
	BBC	#UCB$V_ONLINE,-		; If clr, device is offline - ignore it
		UCB$W_STS(R5),10$
	BBS	#DEV$V_DMT,-		; If set, device marked for dismount
		UCB$L_DEVCHAR(R5),10$
	BITL	#TT$M_PASSALL!TT$M_NOBRDCST,- ; Terminal in PASSALL or NOBRDCST?
		UCB$L_DEVDEPEND(R5)	;
	BEQL	20$			; If eql, no
10$:	MOVL	R7,R3			; Restore broadcast packet address
	CLRL	TTY$L_WB_END(R3)	; Indicate no need to wait and we
					; don't want the packet.
	POPR	#^M<R4,R5,R6,R7>	; Restore registers
	RSB				;
;
; Allocate an I/O packet
;
20$:	MOVZWL	#IRP$C_LENGTH,R1	; Set packet size
	JSB	G^EXE$ALONONPAGED	; Allocate an I/O request packet
	BLBC	R0,10$			; Branch if failure
	MOVL	R2,R3			; Save address of packet
	MOVB	#DYN$C_IRP,IRP$B_TYPE(R3) ; Set block type
	MOVW	R1,IRP$W_SIZE(R3)	; Set block size
	MOVL	R5,IRP$L_UCB(R3)	; Set UCB address
	MOVAB	W^RTT_NETWRTDONE,-	; Set PID for harmless post to cover
		IRP$L_PID(R3)		; race on hangup.
	CLRW	IRP$W_FUNC(R3)		; Zero function code
	BISW	#IRP$M_FUNC,IRP$W_STS(R3) ; Set special function flag
;
; Allocate a message buffer and copy broadcast message to it
;
	PUSHL	R3			; Save I/O packet address
	SUBL3	TTY$L_WB_NEXT(R7),-	; Compute size of data
		TTY$L_WB_END(R7),R6	;
	ADDL3	#RBF$T_TT_WDATA,R6,R1	; Add header to request size
	JSB	G^EXE$ALONONPAGED	; Allocate the buffer
	BLBS	R0,30$			; Branch if success
	POPL	R0			; Restore address of I/O packet
	JSB	G^EXE$DEANONPAGED	; Deallocate the I/O packet
	BRB	10$			; Quit

30$:	MOVL	(SP),R3			; Get address of I/O packet
	BSBW	SET_MSGHDR		; Setup the message header
	MNEGW	#1,RBF$W_OPCODE(R2)	; Set function code for broadcast
	CLRW	RBF$W_MOD(R2)		; No modifier bits here
	MOVL	R6,RBF$L_TT_BCNT(R2)	; Set size of data
	MOVC3	R6,@TTY$L_WB_NEXT(R7),-	; Copy data 
		RBF$T_TT_WDATA(R2)	;
	MOVL	R3,R2			; Setup address beyond data for call
	POPR	#^M<R3,R4,R5,R6>	; Restore registers
;
; Send the message to the remote device and return to SYS$BRDCST
;
	BSBW	RTT_NETMSGSEND		;
	MOVL	R7,R3			; Restore broadcast message address
	MOVL	#1,TTY$L_WB_END(R3)	; Indicate no need to wait and we took
					; the packet.
	POPL	R7			; Restore register
	RSB				;

	.SBTTL	ALLOC_MESSAGE, Allocate a message buffer
;++
; ALLOC_MESSAGE, Allocate a message buffer to send to remote process
; SET_MSGHDR,    Setup a message header for broadcast
;
; Functional description:
;
;	This routine checks that the process has sufficient buffered I/O
;	byte count quota for the message buffer, and then allocates the
;	buffer from non-paged pool.  The process's buffered I/O byte count
;	quota is decreased by the size of the allocated buffer and the
;	message header information is stored.
;
; Inputs:
;
;	R1 = size of message required
;	R3 = address of IRP
;	R4 = address of PCB
;
; Outputs:
;
;	R1 = size of buffer
;	R2 = address of buffer 
;
;	IRP$L_SVAPTE(R3) = address of buffer
;	IRP$W_BOFF(R3) = size of buffer
;
;	RBF$B_TYPE(R2)	= Block type
;	RBF$W_SIZE(R2) = size of message buffer
;	RBF$W_OPCODE(R2) = I/O function
;	RBF$W_MOD(R2) = I/O function modifiers
;	RBF$L_REFID(R2) = Reference id of function
;	RBF$W_UNIT(R2) = Set to SVPN of the ucb (?? not used really)
;
;	If process does not have sufficient quota, the I/O request
;	is aborted.
;--
ALLOC_MESSAGE:				; Allocate message buffer
	PUSHL	R3			; Save packet address
	JSB	G^EXE$BUFFRQUOTA	; Check quota
	BLBS	R0,10$			; Branch if success
	BRW	ABORT			; Else, abort the I/O
;
; Allocate the message buffer
;
10$:	JSB	G^EXE$ALLOCBUF		; Allocate the buffer	
	POPL	R3			; Restore packet address
;
; Adjust process's quota
;
	MOVL	PCB$L_JIB(R4),R0	; Get Job Information Block address
	SUBL	R1,JIB$L_BYTCNT(R0)	; Adjust buffered I/O byte count quota
	MOVW	R1,IRP$W_BOFF(R3)	; Save buffer size as quota

;
; Store message header information
;

;
;	R0	= Clobbered
;	R1	= Buffer size
;	R2	= Buffer address
;	R3	= IRP address
;

SET_MSGHDR:

	MOVL	IRP$L_SEQNUM(R3), -	; Sequence number of the operation
		RBF$L_REFID(R2)
	MOVL	IRP$L_UCB(R3), R0	; Unit control block address
	MOVW	UCB$L_SVPN(R0), -	; Bogus unit number, not used
		RBF$W_UNIT(R2)
	EXTZV	#IRP$V_FCODE,-		; Set requested function code
		#IRP$S_FCODE,IRP$W_FUNC(R3),RBF$W_OPCODE(R2)
	BICW3	#IRP$M_FCODE,IRP$W_FUNC(R3),RBF$W_MOD(R2) ; Set requested modifiers

;
; Setup a message header but don't depend on the irp address
; except for svapte.
;

SET_MSGHDRX:

	MOVL	R2,IRP$L_SVAPTE(R3)	; Save buffer address in packet
	MOVW	R1,RBF$W_SIZE(R2)	; Save buffer size in message
	MOVB	#DYN$C_BUFIO,-		; Set block type
		RBF$B_TYPE(R2)
	MOVAB	RBF$W_OPCODE(R2),-	; Set address of data
		RBF$L_MSGDAT(R2)
	CLRL	RBF$L_USRBFR(R2)	; Set user buffer address
	RSB				;

	.SBTTL	RTT_INTERRUPT Interrupt handler
;++
; RTT_INTERRUPT, I/O completion interrupt handler
;
; Functional description:
;
;	This routine handles an I/O completion "interrupt" from the ACP.
;	The I/O status and data is obtained from the response packet from 
;	the remote terminal handler process, and the I/O request is completed.
;
; Inputs:
;
;	R3 = address of the IRP
;	R5 = address of UCB
;	IRP$L_SVAPTE(R3) = address of response message
;
;	IPL = 0
;
; Outputs:
;
;	I/O status copied to IRP$L_IOST and I/O request posted.
;
;	This routine only needs to preserve R11.
;--
RTT_INTERRUPT:				; I/O completion interrupt handler
	MOVL	IRP$L_SVAPTE(R3),R2	; Get address of message
	MOVL	(R2),R1			; Address of data in buffer
	BBC	#IRP$V_FUNC,-		; If clr not READ/SENSE/BROADCAST
		IRP$W_STS(R3),POST 
	EXTZV	#IRP$V_FCODE,-		; Get original function code
		#IRP$S_FCODE,-
		IRP$W_FUNC(R3),R0
	BEQL	POST_BROADCAST		; If eql BROADCAST function
	CMPB	R0,#IO$_SENSEMODE	; SENSEMODE function?
	BEQL	POST_SENSE		; If eql yes
	CMPB	R0,#IO$_SENSECHAR	; SENSECHAR function?
	BEQL	POST_SENSE		;If eql yes - else read function
;
; Set up buffer to post READ
;
	MOVAB	RDP$T_TT_RDATA+2(R1),(R2) ; Set address of data
	MOVL	IRP$L_MEDIA(R3),4(R2)	; Set address of user buffer
	CMPW	RDP$T_TT_RDATA(R1),-	; Size of data greater than user buffer?
		IRP$W_BCNT(R3)		;
	BGTRU	POST			; If gtru yes - leave user's size
	MOVW	RDP$T_TT_RDATA(R1),-	; Else, set size to actual data size
		IRP$W_BCNT(R3)		;
	BRB	POST			;
;
; Set up buffer to post SENSEMODE/CHAR
;
POST_SENSE:				;
;
;	Note that for the latest protocol, either 8 or 12 bytes will come
;	from this part of the message.  Size is already in IRP.
;
	MOVAB	RDP$Q_TT_SCHAR(R1),(R2)	; Set address of data
	MOVL	IRP$L_MEDIA(R3),4(R2)	; Set address of user data
	TSTB	UCB$B_RTT_PROECO(R5)	; Latest version
	BNEQ	10$			; Yes
	MOVL	UCB$L_RTT_DEVDEPEND2(R5),- ; Return additional characters if
		RDP$L_TT_SCHAR2(R1)	; they are requested
10$:
	BITW	#^CIRP$M_FCODE,-	; Check for spawn bits only if no
		IRP$W_FUNC(R3)		; modifier on the sensemode
	BNEQ	20$			; We have modifiers
	BSBB	SENSE_SPAWN		; Set the three bits for spawn
20$:
POST:					; Post the I/O
	BISW	#IRP$M_TERMIO,IRP$W_STS(R3) ; Set terminal I/O completion
	MOVQ	RDP$Q_STATUS(R1),-	; Set I/O status
		IRP$L_IOST1(R3)		;
	CMPW	IRP$L_IOST1(R3),-	; If normal return
		#SS$_NORMAL		; 
	BNEQ	10$			; Nope
	TSTW	IRP$W_RTT_COMPAT(R3)	; Check for compatibility error
	BEQL	10$			; Nope
	MOVW	IRP$W_RTT_COMPAT(R3),-	; Return compatibility error
		IRP$L_IOST1(R3)		; to user
10$:	JMP	G^COM$POST		; Post the I/O
;
; Post a BROADCAST completion
;
POST_BROADCAST:				;
	PUSHL	R3			; Save I/O packet address
	MOVL	R2,R0			; Set address of the message
	BSBB	10$			; Deallocate the message
	POPL	R0			; Restore I/O packet address
10$:	JSB	G^EXE$DEANONPAGED	; Deallocate the I/O packet
	RSB


	.SBTTL	SENSE_SPAWN  Sense for spawn

;	Sense special characteristics bits for DCL spawn command.
;	Return bits for ctrl/c ast, outofband ast and associated mailbox.
;	These bits may be reused later and are not for customer application
;	consumption.
;
; inputs:
;	r1 -> RDP message
;

SENSE_SPAWN:
	MOVAB	RDP$L_TT_SCHAR2(R1), R0	; Address of the characteristics
	BICL	#<TT2$M_DCL_MAILBX!-	; Reset them all
		TT2$M_DCL_CTRLC!-	;
		TT2$M_DCL_OUTBND>, (R0);
	TSTL	UCB$L_AMB(R5)		; Any associated mailbox?
	BEQL	10$			; No
	BISL	#TT2$M_DCL_MAILBX,(R0)	; Yes, so set characteristic
10$:
	TSTL	UCB$L_RTT_CTRLC(R5)	; Any enabled control c?
	BEQL	20$			; No
	BISL	#TT2$M_DCL_CTRLC,(R0)	; Yes, so set it
20$:
	BISL3	UCB$L_RTT_BANDEXCL(R5),- ; Check both masks with one instr
		UCB$L_RTT_BANDINCL(R5),- ; Note at least 800 bit is set 
		-(SP)			; in both addresses.
	TSTL	(SP)+			; Remove temp from stack
	BEQL	30$			; Not either set
	BISL	#TT2$M_DCL_OUTBND,(R0)	; Return bit for we have one.
30$:
	RSB

	.SBTTL	RTT_CANCEL, Cancel I/O routine
;++
; RTT_CANCEL, Cancels an I/O operation in progress
;
; Functional description:
;
;	This routine cancels any CTRL/C or CTRL/Y AST's that were
;	requested by the cancelling process on the cancelling channel.
;
;	If there are no more references remaining to the device, the UCB
;	is queued to the ACP to notify it that the device is no longer in
;	use.  The ACP will then check that the reference count is still zero
;	and remove the UCB from I/O database and deallocate it.
;
; Inputs:
;
;	R2 = negated value of the channel index number
;	R3 = address of the current IRP (I/O request packet)
;	R4 = address of the PCB (process control block) for the
;		  process canceling I/O
;	R5 = address of the UCB (unit control block)
;
;	IPL = driver fork IPL
;
; Outputs:
;
;	DEV$M_DMT is set in UCB$L_DEVCHAR to prevent a race if someone
;	assigns and deassigns another channel to the UCB before the ACP 
;	dequeues the UCB.
;
;	The routine preserves all registers except R0-R3.
;--
.ENABLE	LOCAL_BLOCK

ASSUME	CAN$C_CANCEL EQ 0
ASSUME	CAN$C_DASSGN EQ 1

10$:	BRW	50$
20$:	BRW	40$

RTT_CANCEL:				; Cancel an I/O operation
	PUSHR	#^M<R4,R5,R6,R7>	; Save registers
	BBC	#UCB$V_ONLINE,-		; If clr unit offline - probably template
		UCB$W_STS(R5),10$	;
	TSTW	UCB$W_REFC(R5)		; Any more references to device?
	BEQL	20$			; Nope all done.

	MOVL	R2,R6			; Make a copy of channel number
	TSTL	R8			; Cancel or deassign
	BEQL	25$			; Cancel

	MOVAL	UCB$L_RTT_CTRLY(R5),R7	; Get address of CTRL/Y AST list
	JSB	G^COM$FLUSHATTNS	; Flush all cancelled AST's

25$:	MOVAL	UCB$L_RTT_CTRLC(R5),R7	; Get address of CTRL/C AST list
	JSB	G^COM$FLUSHATTNS	; Flush any cancelled AST's
	MOVAB	UCB$L_RTT_BANDINCL(R5), R7 ; Flush any outofband asts
	MOVAB	UCB$L_RTT_BANDINMSK(R5), R2 ; mask address
	JSB	G^COM$FLUSHCTRLS	; Flush them by channel etc
	MOVAB	UCB$L_RTT_BANDEXCL(R5), R7 ; Flush any outofband asts
	MOVAB	UCB$L_RTT_BANDEXMSK(R5), R2 ; mask address
	JSB	G^COM$FLUSHCTRLS	; Flush them by channel etc
;
; If we are talking to new version, tell him the new masks.
;
	TSTB	UCB$B_RTT_PROECO(R5)	; Nonzero for latest
	BEQL	30$			; Old version
	MOVL	#RBF$B_TT_OUTBAND+1+4+1+4,- ; Size of the outband message
		R1			; buffer
	PUSHL	R3			; Save across dirty routine
	JSB	G^EXE$ALONONPAGED	; Get me some memory
	POPL	R3			; restore packet address
	BLBC	R0, 30$			; Hang it up for lack of space?

;
; Here comes an incredible hack.  We are going to build a message to be
; transmitted which has no irp context.  It will have a REFID of zero.
; To do this we need an irp address with a svapte field to save the
; packet address.  We make an "irp" by passing the address of a cell in
; the ucb which can be used.  The address is backed up by the svapte offset
; so that for this purpose it looks like an irp.
;

	PUSHL	R3			; Save the bad r3
	MOVAB	<UCB$L_SVAPTE - -	; Make a bogus irp address
		IRP$L_SVAPTE>(R5), R3	; with only a good svapte
	BSBW	SET_MSGHDRX		; Set up the message header
	CLRL	RBF$L_REFID(R2)		; Ref id is zero
	CLRW	RBF$W_UNIT(R2)		; No unit specified
	MOVW	#RDP$B_TT_OUTBAND+1+4+1+4,- ; Size of data to be sent
		RBF$W_DATSIZE(R2)	; to the server
	MOVW	#IO$_SETMODE, -		; Set the op
		RBF$W_OPCODE(R2)	; code of the message
	MOVW	#IO$M_OUTBAND, -	; and the modifier
		RBF$W_MOD(R2)		; for the message
	MOVAB	RBF$B_TT_OUTBAND(R2), R2; Now build the message itself
	MOVB	#4, (R2)+		; Count for include mask
	MOVL	UCB$L_RTT_BANDINMSK(R5),-; Include mask
		(R2)+			;
	MOVB	#4, (R2)+		; Count for exclude mask
	MOVL	UCB$L_RTT_BANDEXMSK(R5),- ; Now the exclude mask
		(R2)+			;
	BSBW	RTT_NETCANSEND		; Send the message to the server
	POPL	R3			; Restore the bogus irp address
30$:

	BSBW	RTT_CANIRPS		; Cancel outstanding IRPs
	BRB	50$

40$:
;
; Clean up the ucb after all references have gone
;
	BSBW	RTT_ABORTIRPS		; Flush all irps from queue
					; Insert UCB in ACP queue
50$:
	POPR	#^M<R4,R5,R6,R7>	; Restore registers
	RSB				; Return

.DISABLE LOCAL_BLOCK

	.SBTTL	RTT_UNSOLIC Unsolicited interrupt handler
;++
; RTT_UNSOLIC, Unsolicted interrupt handler
;
; Functional description:
;
;	This routine handles unsolicted attention messages from the remote
;	terminal handler process.  If the message is:
;
;		Unsolicited data: If device has any references, deliver message
;				  to associated mailbox; if no references,
;				  deliver a message to the Job Controller.
;
;		Hang-up:	  Deliver any CNTRL/Y AST's, specifying hang-up;
;				  deliver a hangup message to associated mailbox.
;
;		CTRL/C or CTRL/Y: Any corresponding AST's are delivered.
;
;		STARTRCV	 Start the receive to the net.
;
; Inputs:
;
;	R3 = address of attention message
;	R5 = address of UCB
;
;	IPL = 0
;
; Outputs:
;
;	Message or AST(s) delivered and attention message block deallocated.
;
;--
RTT_UNSOLIC:				; Unsolicted interrupt handler
	PUSHL	R3			; Save address of mesage block
	DSBINT	UCB$B_FIPL(R5)		; Synchronize access to UCB
	MOVL	(R3),R1			; Obtain the address of the data
	CASE	RDP$W_MOD(R1),<-	; Case on message modifier type
		UNSOL_DATA,-		;  Unsolicited data
		HANGUP,-		;  Hangup
		CTRLC,-			;  CNTRL/C
		CTRLY,-			;  CNTRL/Y
		STARTRCV,-		;  Start network receive
		RTT_BRDCST,-		; Broadcast message for mailbox
		RTT_OUTBAND,-		; Out of band ast character
		>,LIMIT=#RBF$C_TT_UNSOL	;
	BRW	UNSOLIC_EXIT		;
;
; Deliver unsolicited data notification
;
UNSOL_DATA:				; Unsolicited data
	MOVZBL	#MSG$_TRMUNSOLIC,R4	; Set mailbox message type
	TSTW	UCB$W_REFC(R5)		; Any references to device?
	BEQL	10$			; If eql no - notify Job Controller
	MOVL	UCB$L_AMB(R5),R3	; Get address of associated mailbox
	BEQL	20$			; If eql none - forget it
	JSB	G^EXE$SNDEVMSG		; Deliver notification to mailbox
	BLBC	R0,20$			; If lbc failure
	BRB	20$			;
10$:
	MOVAB	G^SYS$GL_JOBCTLMB,R3	; Get address of Job Controller mailbox
	BBS	#UCB$V_JOB,UCB$W_DEVSTS(R5),20$ ; Branch if notified already
	JSB	G^EXE$SNDEVMSG		; Deliver notification to mailbox
	BLBC	R0,20$			; If lbc failure
	BISW	#UCB$M_JOB,UCB$W_DEVSTS(R5) ; Set Job Controller notified
20$:
	BRB	UNSOLIC_EXIT		;

;
; Deliver hangup notification
;

HANGUP:					; Dataset hangup
	BSBW	RTT_HANGUP		; Do the hangup stuff
	BRB	UNSOLIC_EXIT		;

;
; Start network receive
;

STARTRCV:
	BSBW	RTT_STARTNETRCV		; Start it out of line
	BRB	UNSOLIC_EXIT

;
; Deliver any CNTRL/C AST's
;

CTRLC:					; Deliver CNTRL/C AST's
	MOVAL	UCB$L_RTT_CTRLC(R5),R4	; Get address of CNTRL/C AST list
	BRB	DELAST			;

;
; Deliver any CNTRL/Y AST'S
;

CTRLY:					; Deliver CNTRL/Y AST's
	MOVAL	UCB$L_RTT_CTRLY(R5),R4	; Get address of CNTRL/Y AST list
DELAST:					; 
	JSB	G^COM$DELATTNAST	; Deliver the AST's
					;
UNSOLIC_EXIT:				; Exit unsolicited message handler
	ENBINT				; Re-enable interrupts
	POPL	R0			; Get address of message block
	MOVB	#DYN$C_BUFIO,IRP$B_TYPE(R0) ; Be sure buffer type is valid
	JSB	G^EXE$DEANONPAGED	; Deallocate the message block
	RSB


;+
; RTT_BRDCST
;
; Deliver broadcast message to the mailbox.
;
; The unit number and name of the device is fixed up in the packet first.
;
;-

RTT_BRDCST:

	BBC	#TT2$V_BRDCSTMBX, -		; If we are allowing mailbox
		UCB$L_RTT_DEVDEPEND2(R5),-	; to receive the messages
		10$				; from broadcasts
	TSTL	UCB$L_AMB(R5)			; and we have a mailbox
	BEQL	10$				; Nope
	MOVW	UCB$W_UNIT(R5), -		; Then fix the unit number
		RDP$W_TT_BRDUNIT(R1)		; in the message
	MOVL	UCB$L_DDB(R5), R2		; and get the proper name of
	EXTZV	#0, #4, DDB$T_NAME(R2), R0	; this device for the message
	INCL	R0				; including the count

	PUSHR	#^M<R0, R1, R2, R3, R4, R5>	; Copy the new name and
	MOVC5	R0, DDB$T_NAME(R2), #0, -	; clobber the remainder of the
		#RDP$C_TT_BRDNAME, -		; stuff in the fixed length
		RDP$T_TT_BRDNAME(R1)		; field
	POPR	#^M<R0, R1, R2, R3, R4, R5>	; restore the regs

	PUSHR	#^M<R3, R4, R5>			; Save a few
	MOVZWL	RDP$W_TT_BRDTOTSIZE(R1), R3	; Size of the message
	MOVAB	RDP$W_TT_BRDMSG(R1), R4		; Address of the message
	MOVL	UCB$L_AMB(R5), R5		; Mailbox ucb address
	JSB	G^EXE$WRTMAILBOX		; Write the message to it
	POPR	#^M<R3, R4, R5>			; and ignore the errors

10$:	BRW	UNSOLIC_EXIT			; Go clean up the packet.


;+
; RTT_OUTBAND
;
; Deliver an out of band ast
;-

RTT_OUTBAND:
	MOVZBL	RDP$B_TT_OUTBAND(R1), R3	; Deliver the asts (char)
	PUSHL	R3				; Save the character
	MOVAB	UCB$L_RTT_BANDINCL(R5), R4	; List address
	JSB	G^COM$DELCTRLAST		; Deliver the asts
	POPL	R3				; Recover the character
	MOVAB	UCB$L_RTT_BANDEXCL(R5), R4	; List address
	JSB	G^COM$DELCTRLAST		; Deliver the asts
	BRW	UNSOLIC_EXIT			; Thats all done

	.SBTTL	RTT_HANGUP  - Perform hangup functions
	.SBTTL	RTT_ABORTIRPS - Abort irps outstanding
;++
; RTT_HANGUP  Perform hangup functions
; RTT_ABORTIRPS
;
; Functional description:
;
;	Deliver any CNTRL/Y AST's, specifying hang-up;
;	deliver a hangup message to associated mailbox.
;	Post any irps outstanding with abort.
;	Set hangup status in device status.
;	The ucb is passed on to the acp if there are no more
;	channels open to it.
;	HANGUP is called by net device errors and hangup operations
;	from the line on the other end.
;	ABORTIRPS is called on net device cancels and channel deassigns.
;
; Inputs:
;
;	R5 = address of UCB
;
;
; Outputs:
;
;	Message or AST(s) delivered.
;
;--
RTT_HANGUP:
	MOVAL	UCB$L_RTT_CTRLY(R5),R4	; Get address of CTRL/Y AST list
	MOVL	R4,R0			; Copy list address
10$:
	MOVL	(R0),R0			; Get address of next entry
	BEQL	20$			; If eql none
	MOVZWL	#SS$_HANGUP,-		; Insert new parameter for AST
		ACB$L_KAST+4(R0)	;
	BRB	10$			;
20$:
	JSB	G^COM$DELATTNAST	; Deliver the AST's
	MOVL	#MSG$_TRMHANGUP,R4	; Set mailbox message type
	MOVL	UCB$L_AMB(R5),R3	; Get associated mailbox address
	BEQL	30$			; If eql none - forget it
	JSB	G^EXE$SNDEVMSG		; Deliver notification to mailbox
30$:
	BISW	#UCB$M_TT_HANGUP,-	; Save hangup status
		UCB$W_DEVSTS(R5) 	;

;
;	Clean up the outstanding iirp read to network so it completes
;	without calling driver again.  Post all outstanding irps with
;	abort.
;

RTT_ABORTIRPS:

;
;	We must be at ipl 7 or above here
;
	DSBINT	UCB$B_FIPL(R5)		; Synchronize owth other entries

;
;	Fix the interlock with the receive iirp so it will be deallocated
;	when it completes.  We must say we did so here.  The condition is
;	NETIRP = 1 and IRP$L_AST = 0 means that its gone.  If NETIRP = 0
;	it has never been allocated and given to netdriver.
;

	MOVL	UCB$L_RTT_NETIRP(R5),R0	; Look at address of receive iirp
	BEQL	10$			; Nope not here
	BLBS	R0,10$			; Dummy, all done?
	CLRL	IRP$L_AST(R0)		; Nope so tell receive iirp
10$:	MOVL	#1,UCB$L_RTT_NETIRP(R5)	; Clobber address here

;
;	Now we abort all of the irps that we have at this time.
;

20$:	REMQUE	@UCB$L_RTT_IRPFL(R5), R3; Obtain an irp from queue
	BVS	30$			; No more
	MOVZWL	#SS$_ABORT, -		; Complete with abort status
		IRP$L_IOST1(R3)		;
	CLRL	IRP$L_IOST2(R3)		;
	JSB	G^COM$POST		; and poast
	BRB	20$			; and back for more irps

;
;	If there are no more channels to this device, then pass it on
;	to the acp for disposal.
;

30$:	TSTW	UCB$W_REFC(R5)		; Any channels to device?
	BNEQ	50$			; Yes

	BICW	#UCB$M_JOB,-		; Clear Job Controller notified
		UCB$W_DEVSTS(R5)	;
	BBSS	#DEV$V_DMT,-		; If set, UCB already queued
		UCB$L_DEVCHAR(R5),50$	;
	MOVL	R5,R3			; Set up ucb as the packet
	MOVL	UCB$L_VCB(R5),R2	; Get address of VCB
	MOVL	VCB$L_AQB(R2),R2	; Get address of ACP AQB
	JSB	G^EXE$INSERTIRP		; Insert UCB in ACP queue
	BNEQ	40$			; If neq, not first entry in queue
	MOVL	AQB$L_ACPPID(R2),R1	; Get ACP process ID
	JSB	G^SCH$WAKE		; Wake the ACP process
40$:
50$:	ENBINT				; Restore IPL
	RSB				;

	.SBTTL RTT_NETMSGSEND  - Send message to net driver
;
; RTT_NETMSGSENDX  -  Send message to netdriver and exit qio
; RTT_NETMSGSEND   -  Send message to netdriver
; RTT_NETCANSEND   -  Send message for cancel
; RTT_NETQUEPKT    -  Queue message to net driver
;
; inputs:
;	r2 -> address beyond message data (NETMSGSEND)
;	r3 -> rtt irp
;	r4 -> pcb
;	r5 -> rtt ucb
;

RTT_NETMSGSENDX:
	BSBB	RTT_NETMSGSEND		; Send the message and
	JMP	G^EXE$QIORETURN		; Return from the qio

RTT_NETMSGSEND:
	MOVL	IRP$L_SVAPTE(R3),R0	; The buffer address
	BEQL	10$			; none
	SUBL3	(R0),R2,R1		; Make the length of the data
	MOVW	R1,RBF$W_DATSIZE(R0)	; save in the buffer
10$:	BLBS	UCB$L_RTT_NETIRP(R5),-	; We do not have a receive posted
		RTT_NETHUNGUP		; so this cannot work. We have hungup.
	INSQUE	(R3), -			; Queue the irp on the ucb
		@UCB$L_RTT_IRPBL(R5)
	CLRL	IRP$L_IOST2(R3)		; No cancel has been sent yet

RTT_NETCANSEND:				; Send cancel message

	BSBW	RTT_MAKEIIRP		; Make iirp for this message
	BLBC	R0,RTT_CLEANUP		; No memory, hangup and goaway
	MOVAB	W^RTT_NETWRTDONE,-	; Place to post io
		IRP$L_PID(R2)		;
	MOVL	IRP$L_SVAPTE(R3), -	; Move buffer to iirp
		IRP$L_SVAPTE(R2)	;
	CLRL	IRP$L_SVAPTE(R3)	; drop it from rtt irp
	MOVL	IRP$L_SVAPTE(R2),R1	; fix the byte count in the iirp
	MOVW	RBF$W_DATSIZE(R1), -	; from the size in the buffer
		IRP$W_BCNT(R2)		;

RTT_NETQUEPKT:				; Queue a packet to the netdriver

;
;	r2 -> net iirp
;	r3 -> rtt irp
;	r5 -> rtt ucb
;

	PUSHR	#^M<R3,R4,R5>		; Save the magic three
	MOVL	R2,R3			; Point to iirp
	MOVL	IRP$L_UCB(R3),R5	; The netucb from this packet
	JSB	G^EXE$ALTQUEPKT		; Queue iirp to netdriver
	POPR	#^M<R3,R4,R5>		; restore magic three
	MOVL	#1,R0			; return success
	RSB



;
;	R5 -> RTT UCB
;	R3 -> RTT IRP
;
;
; The net connection is broken, so we must post the irps that come
; in with an error code.
;

RTT_NETHUNGUP:
	MOVL	IRP$L_SVAPTE(R3),R0	; Do we have a buffer
	BEQL	10$			; Nope
	PUSHL	R3			; Push address we care about
	CLRL	IRP$L_SVAPTE(R3)	; Forget we had buffer
	JSB	G^EXE$DEANONPAGED	; Get rid of the buffer
	POPL	R3			; Restore irp address
10$:	MOVQ	#SS$_LINKABORT,-	; Return a nasty error
		IRP$L_IOST1(R3)		; 
	JSB	G^COM$POST		; Post the irp since we don't have
	CLRL	R0			; a link anymore and return error here
	RSB


	.SBTTL	RTT_CLEANUP  - Hangup terminal
;
; RTT_CLEANUP
;
;	We are in deep trouble.  Hangup the terminal to run it down
;	and return failure in r0.  This is done when we cannot obtain
;	memory for an iirp or any thing else.  IPL can be anything.
;
; inputs:
;	r5 -> rtt ucb
;

RTT_CLEANUP:

	BSBW	RTT_HANGUP		; Post irps and attn asts
	CLRL	R0			; return failure
	RSB

	.SBTTL	RTT_STARTNETRCV  - Start receive to net driver
;
; RTT_STARTNETRCV
;
;	Start the first receive iirp to the netdriver.  We make an iirp
;	and queue it to the netdriver with a read function in it.
;
; inputs:
;	r5 -> rtt ucb
;

RTT_STARTNETRCV:

	TSTL	UCB$L_RTT_NETIRP(R5)	; Is the iirp already out?
	BNEQ	20$			; Yes, then ignore it
	BSBW	RTT_MAKEIIRP		; Make an iirp for use
	BLBC	R0, RTT_CLEANUP		; No good, clean it all up
	MOVL	R2, UCB$L_RTT_NETIRP(R5); Save the address of the iirp
	MOVAB	W^RTT_NETREADDONE, -	; Stuff the post address
		IRP$L_PID(R2)		;
	MOVW	#IO$_READLBLK, -	; Set the function
		IRP$W_FUNC(R2)		;
	CLRL	IRP$L_SVAPTE(R2)	; Yes we have no buffer
	MOVW	G^IOC$GW_MAXBUF,-	; Set the requested size
		IRP$W_BCNT(R2)		;
	BBSS	#IRP$V_FUNC, -		; Say this is a read function
		IRP$W_STS(R2), 10$	;
10$:	BSBB	RTT_NETQUEPKT		; and queue the packet to the net
20$:	RSB

	.SBTTL	RTT_NETREADDONE  - Post routine for net receive
;
; RTT_NETREADDONE  Post net receive
;
;	This is the post routine for receives from the netdriver.
;	We look at the packet and send it to the unsolic or interrupt
;	routine based on the type of the message.  If the type is
;	not recognised or we can't find the irp, we hangup the terminal.
;
;	We are going to run this code at rtt driver ipl.
;
; inputs:
;	r5 -> net iirp
;	ipl = iopost
;

RTT_NETREADDONE:

	PUSHR	#^M<R3,R4,R5>		; Save the magic three
	DSBINT	#RTT$K_FIPL		; Do this work at driver ipl
	MOVL	R5,R3			; The iirp address is here
	MOVL	IRP$L_AST(R3),R5	; The rtt ucb?
	BEQL	10$			; Its gone, we are hung up
	BLBC	IRP$L_IOST1(R3), 60$	; Error? if so then hang up
	MOVL	IRP$L_SVAPTE(R3), R2	; The buffer address
	MOVL	(R2),R1			; Point to message
	ADDW3	#1,RDP$W_OPCODE(R1),R0	; Look at the opcode
	BNEQ	20$			; Its not attention packet
	CLRL	IRP$L_SVAPTE(R3)	; Buffer not in net packet now
	MOVL	R2,R3			; Point to buffer with r3
	BSBW	RTT_UNSOLIC		; Unsolicited input attention message
	BRB	40$			; Requeue a read

10$:	ENBINT				; Restore ipl
	POPR	#^M<R3,R4,R5>		; Restore all the regs we saved
	BSBW	RTT_NETWRTDONE		; Dispose of the iirp and its buffer
	RSB				;

20$:	INCW	R0			; Is this an end message?
	BNEQ	60$			; Nope, hangup the terminal
	MOVL	(R2),R0			; Point to data
	MOVL	RDP$L_REFID(R0),R0	; Obtain the reference id
	BEQL	40$			; ** Ignore refids of zero to make
					; ** cancel of outofband work
	MOVAQ	UCB$L_RTT_IRPFL(R5),R4	; Look through the irps for ours
	MOVL	R4,R1			; head of queue here
30$:	MOVL	(R4),R4			; Link through chain
	CMPL	R4,R1			; end of irps?
	BEQL	60$			; Yes, could not find it, hangup
	CMPL	R0,IRP$L_SEQNUM(R4)	; Match? on ref id
	BNEQ	30$			; nope
	CLRL	IRP$L_SVAPTE(R3)	; Buffer not in net iirp now
	REMQUE	(R4),R3			; Remove the rtt irp from queue
	MOVL	R2,IRP$L_SVAPTE(R3)	; stick buffer there
	BSBW	RTT_INTERRUPT		; and call interrupt routine
40$:
;
;	16(SP)	RTNADR
;	12(SP)	R5 (iirp address)
;	8(SP)	R4
;	4(SP)	R3
;	0(SP)	SAVED IPL (iopost)
;
	MOVL	12(SP),R3		; Obtain the net iirp
	MOVL	IRP$L_UCB(R3),R5	; Set the net ucb address up
	MOVL	IRP$L_SVAPTE(R3),R0	; dump the buffer
	BEQL	50$			; if there is one to dump
	PUSHL	R3			; Save possibly clobbered register
	JSB	G^EXE$DEANONPAGED	; back into swimming pool
	POPL	R3			; Restore register
	CLRL	IRP$L_SVAPTE(R3)	; forget it
50$:	MOVW	G^IOC$GW_MAXBUF,-	; setup for another read from net
		IRP$W_BCNT(R3)		; with requested buffer size
	JSB	G^EXE$ALTQUEPKT		; queue to net driver
	BRB	70$			; Now we are done here

;
;	If we had on io error in the packet, then hangup the terminal
;	deallocate the packet and any buffer and exit.
;	If there is no rtt ucb left anymore, just deallocate the packet
;	and buffer and get out.
;

60$:	BSBW	RTT_HANGUP		; Bad error - hangup the terminal
	MOVL	12(SP),R5		; Net iirp to r5
	BSBB	RTT_NETWRTDONE		; Dump the buffer and the iirp
70$:	ENBINT				; Restore the ipl
	POPR	#^M<R3,R4,R5>		; restore registers of iopost
	RSB

	.SBTTL	RTT_NETWRTDONE  - Post routine for net write
;
; RTT_NETWRTDONE
;
;	Enter here to post writes to net also.
;	Deallocate the iirp and the message if any.
;
;	r5 -> iirp
;	ipl = iopost or higher
;

RTT_NETWRTDONE:

	MOVL	IRP$L_SVAPTE(R5),R0	; Buffer on this iirp?
	BEQL	10$			; nope
	BSBB	20$			; deallocate the buffer
10$:	MOVL	R5,R0			; Now for the iirp itself
20$:	JSB	G^EXE$DEANONPAGED	; back to the pool
	RSB

	.SBTTL	RTT_CANIRPS  - Cancel irps
;
; RTT_CANIRPS
;
;	Cancel irps by sending a message to the terminal system.
;
; inputs:
;	r4 -> pcb for process
;	r5 -> rtt ucb
;	r6 -> channel
;

RTT_CANIRPS:

	PUSHR	#^M<R2,R3,R4,R5,R6>
	MOVAQ	UCB$L_RTT_IRPFL(R5),R6	; Point to the irp queue
	PUSHL	R6			; save its address
;
;	20(SP)	R6
;	16	R5
;	12	R4
;	8	R3
;	4	R2
;	0	IRP LIST HEAD

10$:	MOVL	(R6),R6			; Point to next irp
	CMPL	R6,(SP)			; End of queue?
	BEQL	20$			; Yes
	CMPW	20(SP),IRP$W_CHAN(R6)	; Is this the correct channel?
	BNEQ	10$			; Nope, try next?
	CMPL	PCB$L_PID(R4), -	; Do the pids match?
		IRP$L_PID(R6)		;
	BNEQ	10$			; Nope, try next
	MOVL	R6,R3			; Set up as the irp of choice
	TSTL	IRP$L_IOST2(R3)		; Did we send a cancel?
	BNEQ	20$			; We are done. just return
	MOVL	#RBF$W_UNIT+2, R1	; Get a message buffer for cancel
	PUSHL	R3			; Save across call
	JSB	G^EXE$ALONONPAGED	;
	POPL	R3			; Its clobbered if quick irps are gone
	BLBC	R0,15$			; If error, just say we did it
	BSBW	SET_MSGHDR		; build the message
	ASSUME	RBF$W_MOD EQ -
		RBF$W_OPCODE+2
	MOVL	#IO$_ACPCONTROL,-	; The message opcode and modifier
		RBF$W_OPCODE(R2)	;
	MOVW	#RDP$W_UNIT+2,-		; The datasize
		RBF$W_DATSIZE(R2)	;
;	MOVL	R2,IRP$L_SVAPTE(R3)	; Save the buffer address **
	BSBW	RTT_NETCANSEND		; Send the message
	BLBC	R0,20$			; Error, IRPS are all gone
15$:	MOVL	#1,IRP$L_IOST2(R3)	; Mark for we sent it
	BRB	10$			; try another irp

20$:	POPR	#^M<R1,R2,R3,R4,R5,R6>	; Restore regs and return
	RSB				; Discard stack longword to r1

	.SBTTL RTT_MAKEIIRP  - Manufacture an internal irp
;
; RTT_MAKEIIRP
;
;	Make an internal IRP for sending to the netdriver.
;	If we can't get the space, return failure.
;
; inputs:
;	r3 -> rtt irp
;	r5 -> rtt ucb
;
; outputs:
;	r0 = success or fail
;

RTT_MAKEIIRP:

	MOVZBL	#IRP$C_LENGTH,R1	; Obtain a buffer of correct size
	PUSHL	R3			; Save across call to get memory
	JSB	G^EXE$ALONONPAGED	; from dynamic memory
	POPL	R3			; Restore irp address
	BLBC	R0,10$			; No memory left, so return error
	MOVB	#DYN$C_IRP, -		; Set the type and size fields
		IRP$B_TYPE(R2)		;
	MOVW	R1,IRP$W_SIZE(R2)	;
	CLRL	IRP$L_PID(R2)		; No pid here
	MOVL	R5,IRP$L_AST(R2)	; Save the rtt ucb field
	MOVL	UCB$L_RTT_NETWIND(R5),-	; Set up the window
		IRP$L_WIND(R2)		;
	MOVL	UCB$L_RTT_NETUCB(R5),-	; and the ucb for the net
		IRP$L_UCB(R2)		;
	MOVW	#IO$_WRITELBLK,-	; the function
		IRP$W_FUNC(R2)		;
	MOVB	#4,IRP$B_PRI(R2)	; priority of this in queue
	MOVW	#IRP$M_BUFIO,-		; Its a buffered io function
		IRP$W_STS(R2)		; and assume a write
	CLRW	IRP$W_BOFF(R2)		; no quota to return for iirp
	CLRQ	IRP$L_IOST1(R2)		; no status yet
	ASSUME	IRP$L_OBCNT -
		EQ -
		IRP$L_ABCNT+4
	CLRQ	IRP$L_ABCNT(R2)		; Some more byte counts
	MOVL	IRP$L_SEQNUM(R3),-	; Grab a quick sequence number
		IRP$L_SEQNUM(R2)	;
	MOVL	IRP$L_ARB(R3),-		; Access rights block, incase needed
		IRP$L_ARB(R2)		;
10$:	RSB

	.SBTTL	RTT_END, End of driver

;
; Label that marks the end of the driver
;
RTT_END:
	.END
