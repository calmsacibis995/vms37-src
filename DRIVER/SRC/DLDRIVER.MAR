	.TITLE	DLDRIVER - VAX/VMS RL11/RL01,RL02 DISK DRIVER
	.IDENT	'V03-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
; 
; 
; FACILITY:
; 
; 	VAX/VMS RL11/RL01,RL02 DISK DRIVER
; 
; AUTHOR:
; 
; C. FRANKS	05-OCT-1979
; 
; MODIFIED BY:
;
;	V02-009	ROW0058		Ralph O. Weber		 9-DEC-1981
;		Cause IO$_PACKACK to set UCB$V_VALID in UCB$W_STS.  Add two 
;		new functions IO$_UNLOAD and IO$_AVAILABLE both of which clear 
;		UCB$V_VALID.  NB: none of the drives supported by this driver 
;		provide a hardware unload function; therefore, this driver 
;		need support unload only to the extent of clearing 
;		UCB$V_VALID.
;
;	V02-008	RLRMNTVR	Robert L. Rappaport	14-Oct-1981
;		Change logical to physical mapping logic so as to NOT
;		alter IRP$L_MEDIA so that MOUNT VERIFICATION can resubmit
;		IRP's.
;
;	V02-007	EAD0001		Elliott A. Drayton	15-Aug-1981
;		Add test of owner UCB address in the interrupt dispatcher.
;
;	V02-006	SPF0001		Steve Forgey		29-Jan-1981
;		Use TIMEWAIT macro instead of clock to time for
;		controller ready.
;
;	V02-005	RLR0002		Robert L. Rappaport	27-Oct-1980
;		Changed error status returned when odd length transfer
;		specified from SS$_BUFBYTALI to SS$_IVBUFLEN.
;
;	V02-004	RLR0001		Robert L. Rappaport	25-Jul-1980
;		Fix unit initialization routine to NOT hang waiting for
;		drive to spinup if NO valid volume is present.
;
;	V02-003	ACG0179		Andrew C. Goldstein,	23-Jul-1980  18:12
;		Fix ACP class code in DPT
;
;	V02-002	LMK0001		LEN KAWELL		27-MAR-1980
;		ALLOW SEEK FAILURE RETRIES AND SET PROPER IPL ON TIMEOUT.
;**
.PAGE
; ABSTRACT:
; 
; 	THIS MODULE CONTAINS THE TABLES AND ROUTINES NECESSARY TO
; 	PERFORM ALL DEVICE-DEPENDENT PROCESSING OF AN I/O REQUEST
; 	FOR RL11/RL01,RL02 DISK TYPES ON A VAX/VMS SYSTEM.
; 
; 	THE DISKS HAVE THE FOLLOWING PHYSICAL GEOMETRY:
;
; 			TRACKS/	   SECTORS/	BYTES/	   MAXIMUM	
;	   # CYL	CYLINDER   TRACK	SECTOR	   BLOCKS
; 
; RL01	    256		   2	     40		  256	   10240
; RL02	    512		   2	     40		  256	   20480
; 
; 	SINCE THE SECTOR SIZE IS ONLY 1/2 BLOCK, LOGICAL TO PHYSICAL
; 	CONVERSION OF THE DISK ADDRESS IS DONE IN THE DRIVER STARTIO
; 	ROUTINE RATHER THAN IN THE IOC$CVTLOGPHY FDT ROUTINE.
; 
; 	OVERLAPPED SEEKS ARE NOT ATTEMPTED BECAUSE THE DEVICE DOES
; 	NOT INTERRUPT AT THE COMPLETION OF A SEEK.
; 
; 	ALSO, THE DEVICE DOES NOT PERFORM AN IMPLICIT SEEK WHEN PERFORMING
; 	A READ OR WRITE FUNCTION,SO SEEK FUNCTIONS ARE ISSUED BY THIS
; 	DRIVER WHERE NECESSARY PRIOR TO ISSUING A READ OR WRITE FUNCTION.
; 	THE READ OR WRITE FUNCTION IS THEN ISSUED AS SOON AS THE RL11
; 	CONTROLLER COMES READY (WHILE THE SEEK IS IN PROGRESS), AND A
; 	WAIT FOR INTERRUPT (UPON COMPLETION OF THE READ OR WRITE) IS
; 	ISSUED.  IF A SEEK FUNCTION IS REQUESTED SEPARATELY FROM A READ OR
; 	WRITE, A DUMMY READ HEADER FUNCTION IS ISSUED FOLLOWING THE SEEK
; 	FUNCTION AND A WAIT FOR INTERRUPT (UPON COMPLETION OF THE READ
; 	HEADER) IS ISSUED.
; 
; 	THE IO$X_INHSEEK FUNCTION MODIFIER IS TREATED AS A NO-OP BY
; 	THIS DRIVER, SINCE AN EXPLICIT SEEK IS NECESSARY FOR THE RL02
; 	TO TRANSFER DATA PROPERLY.
; 
; 	THE RL'S DO NOT READ OR WRITE BEYOND THE END OF TRACK (THEY DO NOT
; 	AUTOMATICALLY SEEK THE NEXT TRACK), SO  ALL READ AND WRITE FUNCTIONS
; 	ARE BROKEN UP BY THIS DRIVER INTO PARTIAL TRANSFERS TO THE END OF
; 	TRACK, FOLLOWED BY A SEEK TO THE NEXT TRACK, THEN ANOTHER READ OR
; 	WRITE FUNCTION UNTIL THE TOTAL DATA TRANSFER IS COMPLETE.
; 
;--
	.PAGE
	.SBTTL	EXTERNAL AND LOCAL DEFINITIONS

; 
; EXTERNAL SYMBOLS
; 

	$ADPDEF				;DEFINE ADAPTER CONTROL BLOCK
	$CRBDEF				;DEFINE CHANNEL REQUEST BLOCK
	$DCDEF				;DEFINE DEVICE CLASS
	$DDBDEF				;DEFINE DEVICE DATA BLOCK
	$DEVDEF				;DEFINE DEVICE CHARACTERISTICS
	$DPTDEF				;DEFINE DRIVER PROLOGUE TABLE
	$EMBDEF				;DEFINE ERROR MESSAGE BUFFER
	$IDBDEF				;DEFINE INTERRUPT DATA BLOCK
	$IODEF				;DEFINE I/O FUNCTION CODES
	$IRPDEF				;DEFINE I/O REQUEST PACKET
	$PRDEF				;DEFINE PROCESSOR REGISTERS
	$SSDEF				;DEFINE SYSTEM STATUS CODES
	$UCBDEF				;DEFINE UNIT CONTROL BLOCK
	$VECDEF				;DEFINE INTERRUPT VECTOR BLOCK

; 
; LOCAL MACROS
; 

; 	EXFUNCL
;	BRANCH TO SUBROUTINE WHICH REQUESTS CHANNEL (IF NOT ALREADY OWNED),
; 	EXECUTES FCODE (OR R3) FUNCTION, AND BRANCHES TO BDST ON ERROR

	.MACRO	EXFUNCL BDST,FCODE	
		.IF NB	FCODE		;IS FCODE NON-BLANK?
		MOVZBL	#CD'FCODE,R3	;IF NB - SPECIFY FCODE FUNCTION
		.ENDC			;IF B - SPECIFY FNTN IN EXISTING R3
		BSBW	FEXL		;EXECUTE FUNCTION
		.BYTE	BDST-.-1	;WHERE TO GO IF ERROR
	.ENDM


; 	GENF
; 	GENERATE FUNCTION TABLE ENTRY AND CASE TABLE INDEX SYMBOL

	.MACRO	GENF FCODE
		CD'FCODE=.-FTAB/2
		.WORD	FCODE!RL_CS_M_IE  ;FCODE WITH INT ENABLE BIT
	.ENDM


;	CKPWR
; 	DISABLE INTERRUPTS, CHECK IF POWER HAS FAILED,
; 	AND PUT DEVICE UNIT NUMBER IN R2<9:8>
; 

	.MACRO	CKPWR ?L1
		CLRL	R2		;CLEAR R2 FOR UNIT NUMBER
		INSV	UCB$W_UNIT(R5),-  ;PUT UNIT # IN R2<9:8>
			#8,#2,R2	;...
		DSBINT			;DISABLE INTERRUPTS
		BBC	#UCB$V_POWER,-	;IF CLR - NO POWER FAILURE
			UCB$W_STS(R5),L1  ;...
		ENBINT			;POWER FAILURE - ENABLE INTERRUPTS
		BRW	RETREG		;EXIT
L1:					;RETURN FOR NO POWER FAILURE
	.ENDM


; 
; LOCAL SYMBOLS
; 

RL_NUM_REGS	=4			;NUMBER OF DEVICE REGISTERS
RL_SLM		=5			;STATE=SEEK LINEAR MODE (READY TO GO)
UCB$B_DL_DCHEK	=UCB$W_OFFSET+1		;REDEFINE FOR DATA CHECK USE

; 
; UCB OFFSETS WHICH FOLLOW THE STANDARD UCB FIELDS
; 
	$DEFINI	UCB			;START OF UCB DEFINITIONS

.=UCB$W_BCR+2				;BEGIN DEFINITIONS AT END OF UCB
$DEF	UCB$W_DL_PBCR	.BLKW	1	;PARTIAL BYTE COUNT
$DEF	UCB$W_DL_CS	.BLKW	1	;CONTROL STATUS REGISTER
$DEF	UCB$W_DL_BA	.BLKW	1	;BUS ADDRESS REGISTER
$DEF	UCB$W_DL_DA	.BLKW	1	;DISK ADDRESS REGISTER
$DEF	UCB$W_DL_MP	.BLKW	1	;MULTIPURPOSE REGISTER
$DEF	UCB$W_DL_DPN	.BLKW	1	;DATA PATH NUMBER
$DEF	UCB$L_DL_DPR	.BLKL	1	;DATAPATH REGISTER
$DEF	UCB$L_DL_FMPR	.BLKL	1	;FINAL MAP REGISTER
$DEF	UCB$L_DL_PMPR	.BLKL	1	;PREVIOUS MAP REGISTER
$DEF	UCB$B_DL_DPPE	.BLKB	1	;DATAPATH PURGE ERROR
$DEF	UCB$W_DL_DB	.BLKW	3	;DATA BUFFER REGISTER
$DEF	UCB$B_DL_XBA	.BLKB	1	;BUS ADDRESS EXTENSION BITS
$DEF	UCB$W_DL_SBA	.BLKW	1	;SAVED BUFFER ADDRESS
$DEF	UCB$K_DL_LEN	.BLKW	1	;LENGTH OF UCB
	$DEFEND	UCB			;END OF UCB DEFINITONS
 
; 
; RL11/RL01 REGISTER OFFSETS FROM CSR ADDRESS
; 
	$DEFINI	RL			; START OF REGISTER DEFINITIONS

$DEF	RL_CS		.BLKW	1	;CONTROL STATUS REGISTER (CSR)
	_VIELD	RL_CS,0,<-		;START OF CSR BIT DEFINITIONS
		<DRDY,,M>,-		; DRIVE READY
		<FCODE,3>,-		; FUNCTION CODE
		<XBA,2>,-		; BUS ADDRESS EXTENSION BITS
		<IE,,M>,-		; INTERRUPT ENABLE
		<CRDY,,M>,-		; CONTROLLER READY
		<DS,2>,-		; DRIVE SELECT
		<OPI,,M>,-		; OPERATION INCOMPLETE
		<CRC,,M>,-		; DATA CRC OR HEADER CRC
		<DLT,,M>,-		; DATA LATE OR HEADER NOT FOUND
		<NXM,,M>,-		; NON-EXISTENT MEMORY
		<DE,,M>,-		; DRIVE ERROR
		<CE,,M>-		; COMPOSITE ERROR
	>				;END CSR BIT DEFINITIONS

$DEF	RL_BA		.BLKW	1	;BUS ADDRESS REGISTER (BAR)

$DEF	RL_DA		.BLKW	1	;DISK ADDRESS REGISTER (DAR)
	_VIELD	RL_DA,0,<-		;START OF DAR BIT DEFINITIONS
		<MRK,,M>,-		; MARK (ALWAYS 1)
		<STS,,M>,-		; GET STATUS
		<,1>,-			; RESERVED BIT
		<RST,,M>,-		; RESET
		<,12>,-			; RESERVED BITS
	>				;END OF DAR BIT DEFINITIONS

$DEF	RL_MP		.BLKW	1	;MULTIPURPOSE REGISTER (MPR)
	_VIELD	RL_MP,0,<-		;START OF MPR BIT DEFINITIONS
		<STA,3>,-		; DRIVE STATE
		<BH,,M>,-		; BRUSH HOME
		<HO,,M>,-		; HEADS OUT
		<CO,,M>,-		; COVER OPEN
		<HS,,M>,-		; HEAD SELECT
		<TYP,,M>,-		; DRIVE TYPE
		<DSE,,M>,-		; DRIVE SELECT ERROR
		<VC,,M>,-		; VOLUME CHECK
		<WGE,,M>,-		; WRITE GATE ERROR
		<SPE,,M>,-		; SPIN ERROR
		<SKTO,,M>,-		; SEEK TIME OUT
		<WL,,M>,-		; WRITE LOCK
		<CHE,,M>,-		; CURRENT HEAD ERROR
		<WDE,,M>-		; WRITE DATA ERROR
	>				;END MPR BIT DEFINITIONS

	$DEFEND	RL			;END RL11/RL01 REGISTER DEFINITIONS

; 
; HARDWARE FUNCTION CODES
; 
F_NOP=0*2				;NO OPERATION
F_UNLOAD=F_NOP				;NO OPERATION
F_SEEK=3*2				;SEEK CYLINDER
F_RECAL=F_NOP				;NO OPERATION
F_DRVCLR=2*2				;DRIVE CLEAR (GET STATUS)
F_RELEASE=F_NOP				;NO OPERATION
F_OFFSET=F_NOP				;NO OPERATION
F_RETCENTER=F_NOP			;NO OPERATION
F_PACKACK=2*2				;PACK ACKNOWLEDGE (SET VOLUME VALID)
F_SEARCH=F_NOP				;NO OPERATION
F_WRITECHECK=1*2			;WRITE CHECK
F_WRITEDATA=5*2				;WRITE DATA
F_WRITEHEAD=F_NOP			;NO OPERATION
F_READDATA=6*2				;READ DATA
F_READHEAD=4*2				;READ HEADER
F_AVAILABLE=F_NOP			;NO OPERATION
F_GETSTATUS=2*2				;GET STATUS (DRIVER INTERNAL USE)

	.PAGE
	.SBTTL	STANDARD TABLES

; 
; DRIVER PROLOGUE TABLE
; 
; 	THE DPT DESCRIBES DRIVER PARAMETERS AND I/O DATABASE FIELDS
; 	THAT ARE TO BE INITIALIZED DURING DRIVER LOADING AND RELOADING
; 

	DPTAB	-			;DPT CREATION MACRO
		END=DL_END,-		;END OF DRIVER LABEL
		ADAPTER=UBA,-		;ADAPTER TYPE = UNIBUS
		FLAGS=DPT$M_SVP,-	;SYSTEM PAGE TABLE ENTRY REQUIRED
		UCBSIZE=UCB$K_DL_LEN,-	;LENGTH OF UCB
		NAME=DLDRIVER		;DRIVER NAME

	DPT_STORE INIT			;START CONTROL BLOCK INIT VALUES
	DPT_STORE DDB,DDB$L_ACPD,L,<^A\F11\>  ;DEFAULT ACP NAME
	DPT_STORE DDB,DDB$L_ACPD+3,B,DDB$K_CART	;ACP CLASS
	DPT_STORE UCB,UCB$B_FIPL,B,8	;FORK IPL
	DPT_STORE UCB,UCB$L_DEVCHAR,L,-	;DEVICE CHARACTERISTICS
		<DEV$M_FOD-		; FILES ORIENTED
		!DEV$M_DIR-		; DIRECTORY STRUCTURED
		!DEV$M_AVL-		; AVAILABLE
		!DEV$M_ELG-		; ERROR LOGGING
		!DEV$M_SHR-		; SHAREABLE
		!DEV$M_IDV-		; INPUT DEVICE
		!DEV$M_ODV-		; OUTPUT DEVICE
		!DEV$M_RND>		; RANDOM ACCESS
	DPT_STORE UCB,UCB$B_DEVCLASS,B,DC$_DISK  ;DEVICE CLASS
	DPT_STORE UCB,UCB$W_DEVBUFSIZ,W,512  ;DEFAULT BUFFER SIZE
	DPT_STORE UCB,UCB$B_SECTORS,B,40  ;NUMBER OF SECTORS PER TRACK
	DPT_STORE UCB,UCB$B_TRACKS,B,2	;NUMBER OF TRACKS PER CYLINDER
	DPT_STORE UCB,UCB$B_DIPL,B,21	;DEVICE IPL
	DPT_STORE UCB,UCB$B_ERTMAX,B,8	;MAX ERROR RETRY COUNT
	DPT_STORE UCB,UCB$W_DEVSTS,W,-	;INHIBIT LOG TO PHYS CONVERSION IN FDT
		<UCB$M_NOCNVRT>		;...

	DPT_STORE REINIT		;START CONTROL BLOCK RE-INIT VALUES
	DPT_STORE CRB,CRB$L_INTD+4,D,DL_INT  ;INTERRUPT SERVICE ROUTINE ADDRESS
	DPT_STORE CRB,CRB$L_INTD+VEC$L_INITIAL,-  ;CONTROLLER INIT ADDRESS
		      D,DL_RL11_INIT		  ;...
	DPT_STORE CRB,CRB$L_INTD+VEC$L_UNITINIT,- ;UNIT INIT ADDRESS
		      D,DL_RL0X_INIT		  ;...
	DPT_STORE DDB,DDB$L_DDT,D,DL$DDT	  ;DDT ADDRESS

	DPT_STORE END			;END OF INITIALIZATION TABLE

; 
; DRIVER DISPATCH TABLE
; 
; 	THE DDT LISTS ENTRY POINTS FOR DRIVER SUBROUTINES WHICH ARE
; 	CALLED BY THE OPERATING SYSTEM.
; 

	DDTAB	-			;DDT CREATION MACRO
		DEVNAM=DL,-		;NAME OF DEVICE
		START=DL_STARTIO,-	;START I/O ROUTINE
		UNSOLIC=DL_UNSOLNT,-	;UNSOLICITED INTERRUPT
		FUNCTB=DL_FUNCTABLE,-	;FUNCTION DECISION TABLE
		CANCEL=0,-		;CANCEL=NO-OP FOR FILES DEVICE
		REGDMP=DL_REGDUMP,-	;REGISTER DUMP ROUTINE
		DIAGBF=<<RL_NUM_REGS+5+5+3+1>*4>,-  ;BYTES IN DIAG BUFFER
		ERLGBF=<<<RL_NUM_REGS+5+1>*4>+EMB$L_DV_REGSAV>  ;BYTES IN
							;ERROR LOG BUFFER

; DIAGNOSTIC BUFFER SIZE = <<4 RL02 REGISTER LONGWORDS + 5 UCB FIELD LONGWORDS 
;			   + 5 IOC$DIAGBUFILL LONGWORDS + 3 BUFFER ALLOCATION
;			   LONGWORDS + 1 LONGWORD FOR # REGISTERS IN DL_REGDUMP>
;			   * 4 BYTES/LONGWORD>
;
; ERROR LOG BUFFER SIZE  = <<<4 RL02 REGISTER LONGWORDS + 5 UCB FIELD LONGWORDS
; 			   + 1 LONGWORD FOR # REGISTERS IN DL_REGDUMP>
;			   * 4 BYTES/LONGWORD> + BYTES NEEDED FOR ERROR LOGGER
;			   TO SAVE SOFTWARE REGISTERS>


; 
; HARDWARE FUNCTION CODE TABLE
; 
; 	THIS TABLE MERGES THE FUNCTION CODE BITS WITH THE 
; 	INTERRUPT ENABLE BIT AND GENERATES THE CASE TABLE
; 	INDEX SYMBOL.

FTAB:	GENF	F_NOP			;NO-OP
	GENF	F_UNLOAD		;UNLOAD VOLUME (NOP)
	GENF	F_SEEK			;SEEK
	GENF	F_RECAL			;RECALIBRATE (NOP)
	GENF	F_DRVCLR		;DRIVE CLEAR (RESET & GET STATUS)
	GENF	F_RELEASE		;RELEASE PORT (NOP)
	GENF	F_OFFSET		;OFFSET HEADS (NOP)
	GENF	F_RETCENTER		;RETURN HEADS TO CENTERLINE (NOP)
	GENF	F_PACKACK		;PACK ACKNOWLEDGE (RESET & GET STATUS)
	GENF	F_SEARCH		;SEARCH (NOP)
	GENF	F_WRITECHECK		;WRITE CHECK
	GENF	F_WRITEDATA		;WRITE DATA
	GENF	F_READDATA		;READ DATA
	GENF	F_WRITEHEAD		;WRITE HEADERS (NOP)
	GENF	F_READHEAD		;READ HEADERS
	GENF	F_NOP			;place holder
	GENF	F_NOP			;place holder
	GENF	F_AVAILABLE		;AVAILABLE

	.PAGE
; 
; FUNCTION DECISION TABLE
; 
; 	THE FDT LISTS VALID FUNCTION CODES, SPECIFIES WHICH
; 	CODES ARE BUFFERED, AND DESIGNATES SUBROUTINES TO
; 	PERFORM PREPROCESSING FOR PARTICULAR FUNCTIONS.
; 

DL_FUNCTABLE:
	FUNCTAB	,-			;LIST LEGAL FUNCTIONS
		<NOP,-			; NO-OP
		UNLOAD,-		; UNLOAD
		SEEK,-			; SEEK
		DRVCLR,-		; DRIVE CLEAR
		PACKACK,-		; PACK ACKNOWLEDGE
		SENSECHAR,-		; SENSE CHARACTERISTICS
		SETCHAR,-		; SET CHARACTERISTICS
		SENSEMODE,-		; SENSE MODE
		SETMODE,-		; SET MODE
		WRITECHECK,-		; WRITE CHECK
		READHEAD,-		; READ HEADER
		READLBLK,-		; READ LOGICAL BLOCK
		WRITELBLK,-		; WRITE LOGICAL BLOCK
		READPBLK,-		; READ PHYSICAL BLOCK
		WRITEPBLK,-		; WRITE PHYSICAL BLOCK
		READVBLK,-		; READ VIRTUAL BLOCK
		WRITEVBLK,-		; WRITE VIRTUAL BLOCK
		AVAILABLE,-		; AVAILABLE
		ACCESS,-		; ACCESS FILE / FIND DIRECTORY ENTRY
		ACPCONTROL,-		; ACP CONTROL FUNCTION
		CREATE,-		; CREATE FILE AND/OR DIRECTORY ENTRY
		DEACCESS,-		; DEACCESS FILE
		DELETE,-		; DELETE FILE AND/OR DIRECTORY ENTRY
		MODIFY,-		; MODIFY FILE ATTRIBUTES
		MOUNT-			; MOUNT VOLUME
		>
	FUNCTAB	,-			;BUFFERED FUNCTIONS
		<NOP,-			; NO-OP
		UNLOAD,-		; UNLOAD
		SEEK,-			; SEEK
		DRVCLR,-		; DRIVE CLEAR
		PACKACK,-		; PACK ACKNOWLEDGE
		SENSECHAR,-		; SENSE CHARACTERISTICS
		SETCHAR,-		; SET CHARACTERISTICS
		SENSEMODE,-		; SENSE MODE
		SETMODE,-		; SET MODE
		AVAILABLE,-		; AVAILABLE
		ACCESS,-		; ACCESS FILE / FIND DIRECTORY ENTRY
		ACPCONTROL,-		; ACP CONTROL FUNCTION
		CREATE,-		; CREATE FILE AND/OR DIRECTORY ENTRY
		DEACCESS,-		; DEACCESS FILE
		DELETE,-		; DELETE FILE AND/OR DIRECTORY ENTRY
		MODIFY,-		; MODIFY FILE ATTRIBUTES
		MOUNT-			; MOUNT VOLUME
		>
	FUNCTAB	DL_ALIGN,-		;TEST ALIGNMENT FUNCTIONS
		<READHEAD,-		; READ HEADER
		READLBLK,-		; READ LOGICAL BLOCK
		READPBLK,-		; READ PHYSICAL BLOCK
		READVBLK,-		; READ VIRTUAL BLOCK
		WRITECHECK,-		; WRITE CHECK
		WRITELBLK,-		; WRITE LOGICAL BLOCK
		WRITEPBLK,-		; WRITE PHYSICAL BLOCK
		WRITEVBLK-		; WRITE VIRTUAL BLOCK
		>
	FUNCTAB	+ACP$READBLK,-		;READ FUNCTIONS
		<READHEAD,-		; READ HEADER
		READLBLK,-		; READ LOGICAL BLOCK
		READPBLK,-		; READ PHYSICAL BLOCK
		READVBLK-		; READ VIRTUAL BLOCK
		>
	FUNCTAB	+ACP$WRITEBLK,-		;WRITE FUNCTIONS
		<WRITECHECK,-		; WRITE CHECK
		WRITELBLK,-		; WRITE LOGICAL BLOCK
		WRITEPBLK,-		; WRITE PHYSICAL BLOCK
		WRITEVBLK-		; WRITE VIRTUAL BLOCK
		>
	FUNCTAB	+ACP$ACCESS,-		;ACCESS FUNCTIONS
		<ACCESS,-		; ACCEESS FILE / FIND DIRECTORY ENTRY
		CREATE-			; CREATE FILE AND/OR DIRECTORY ENTRY
		>
	FUNCTAB	+ACP$DEACCESS,-		;DEACCESS FUNCTION
		<DEACCESS-		; DEACCESS FILE
		>
	FUNCTAB	+ACP$MODIFY,-		;MODIFY FUNCTIONS
		<ACPCONTROL,-		; ACP CONTROL FUNCTION
		DELETE,-		; DELETE FILE AND/OR DIRECTORY ENTRY
		MODIFY-			; MODIFY FILE ATTRIBUTES
		>
	FUNCTAB	+ACP$MOUNT,-		;MOUNT FUNCTION
		<MOUNT-			; MOUNT VOLUME
		>
	FUNCTAB	+EXE$ZEROPARM,-		;ZERO PARAMETER FUNCTIONS
		<NOP,-			; NO-OP
		UNLOAD,-		; UNLOAD
		DRVCLR,-		; DRIVE CLEAR
		PACKACK,-		; PACK ACKNOWLEDGE
		AVAILABLE,-		; AVAILABLE
		>
	FUNCTAB	+EXE$ONEPARM,-		;ONE PARAMETER FUNCTION
		<SEEK-			; SEEK
		>
	FUNCTAB	+EXE$SENSEMODE,-	;SENSE FUNCTIONS
		<SENSECHAR,-		; SENSE CHARACTERISTICS
		SENSEMODE-		; SENSE MODE
		>
	FUNCTAB	+EXE$SETCHAR,-		;SET FUNCTIONS
		<SETCHAR,-		; SET CHARACTERISTICS
		SETMODE-		; SET MODE
		>
	.PAGE

	.SBTTL	CONTROLLER INITIALIZATION ROUTINE
;++
; 
; FUNCTIONAL DESCRIPTION:
; 
; 	THIS ROUTINE IS A NO-OP FOR THE RL11 BUT MUST BE INCLUDED
; 	SINCE IT IS CALLED WHEN THE RL02 IS BOOTED AS A SYSTEM DEVICE.
; 
; 	THE OPERATING SYSTEM CALLS THIS ROUTINE:
; 		- AT SYSTEM STARTUP
; 		- DURING DRIVER LOADING
; 		- DURING RECOVERY FROM POWER FAILURE
; 
; INPUTS:
; 
; 	R4	- CSR ADDRESS (DEVICE CONTROL STATUS REGISTER)
; 	R5	- IDB ADDRESS (INTERRUPT DATA BLOCK)
; 	ALL INTERRUPTS ARE LOCKED OUT
; 
; OUTPUTS:
; 
; 	CONTROL IS RETURNED TO THE CALLER.
; 
;--

DL_RL11_INIT:				;CONTROLLER INITIALIZATION
	RSB				;RETURN TO CALLER
	.PAGE
	.SBTTL	UNIT INITIALIZATION ROUTINE

;++
; 
; DL_RL0X_INIT - UNIT INITIALIZATION ROUTINE
; 
; FUNCTIONAL DESCRIPTION:
; 
; 	THIS ROUTINE READIES THE RL01/RL02 UNITS FOR I/O OPERATIONS.
; 
; 	THE OPERATING SYSTEM CALLS THIS ROUTINE:
; 		- AT SYSTEM STARTUP
; 		- DURING DRIVER LOADING
; 		- DURING RECOVERY FROM POWER FAILURE
; 
; INPUTS:
; 
; 	R4	- CSR ADDRESS (CONTROLLER STATUS REGISTER)
; 	R5	- UCB ADDRESS (UNIT CONTROL BLOCK)
; 
; OUTPUTS:
; 
; 	THE DRIVE UNIT IS RESET, UCB FIELDS ARE INITIALIZED, AND THE
; 	ROUTINE WAITS FOR ONLINE UNITS TO SPIN UP.  ALL REGISTERS
; 	EXCEPT R0-R3 ARE PRESERVED.
; 
;--

DL_RL0X_INIT:				;RL01/RL02 UNIT INITIALIZATION
	MOVZWL	UCB$W_STS(R5),R3	;SAVE CURRENT UNIT STATUS
	BICW	#UCB$M_ONLINE!UCB$M_VALID,-  ;ASSUME OFFLINE/INVALID
		UCB$W_STS(R5)		;...

; 
; WAIT FOR CONTROLLER (6 SECONDS MAX) IF CHANNEL IS BUSY WITH ANOTHER UNIT
; 

	MOVL	UCB$L_CRB(R5),R0	;GET CRB ADDRESS
	BBC	#CRB$V_BSY,CRB$B_MASK(R0),20$  ;IF CLEAR - CHANNEL NOT BUSY
	MFPR	#PR$_TODR,R0		;GET TIME OF DAY (10 MS UNITS)
	ADDL	#100*6,R0		;ADD 6 SECONDS
10$:	TSTB	RL_CS(R4)		;IS CONTROLLER READY
	BLSS	20$			;IF LSS - YES
	MFPR	#PR$_TODR,R1		;GET CURRENT TIME OF DAY
	CMPL	R0,R1			;HAVE 6 SECONDS ELAPSED?
	BGEQ	10$			;IF GEQ - NO
	BRB	70$			;TIME EXPIRED - EXIT
; 
; GET CURRENT DRIVE STATUS AND RESET DRIVE
; 

20$:	MOVW	#RL_DA_M_RST!-		;PUT RESET AND GET STATUS IN DAR
		RL_DA_M_STS!RL_DA_M_MRK,RL_DA(R4)  ;...
	CLRL	R1			;CLEAR R1 FOR UNIT NUMBER
	INSV	UCB$W_UNIT(R5),#8,#8,R1	;GET UNIT NUMBER 
	BISW3	R1,#F_GETSTATUS,RL_CS(R4)  ;EXECUTE GET STATUS FUNCTION 
	BSBW	DL_WAIT			;WAIT FOR CONTROLLER
	TSTB	RL_CS(R4)		;WAS CONTROLLER READY?
	BGEQ	70$			;IF GEQ - NO

; 
; CLASSIFY DRIVE TYPE
; 

	BITW	#RL_MP_M_TYP,RL_MP(R4)	;IS DRIVE TYPE = RL02?
	BNEQ	30$			;IF NEQ - YES
	MOVB	S^#DT$_RL01,UCB$B_DEVTYPE(R5)  ;SET RL01 DEVICE TYPE
	MOVW	#256,UCB$W_CYLINDERS(R5)  ;SET NUMBER OF RL01 CYLINDERS
	MOVZWL	#10240,UCB$L_MAXBLOCK(R5) ;SET MAX RL01 BLOCK NUMBER
	BRB	40$			;
30$:	MOVB	S^#DT$_RL02,UCB$B_DEVTYPE(R5)  ;SET RL02 DEVICE TYPE
	MOVW	#512,UCB$W_CYLINDERS(R5)  ;SET NUMBER OF RL02 CYLINDERS
	MOVZWL	#20480,UCB$L_MAXBLOCK(R5) ;SET MAX RL02 BLOCK NUMBER
40$:
	BBC	#UCB$V_VALID,R3,60$	; Branch around wait for drive to spinup
					;  if the drive did NOT have a VALID
					;  volume on it before POWER failure.

; 
; INITIALIZE UCB FIELDS AND WAIT FOR ONLINE UNITS TO SPIN UP
; 

45$:	BITW	#RL_CS_M_DRDY,RL_CS(R4)	; Is drive ready?
	BNEQ	50$			;IF NEQ - YES
	JSB	G^EXE$PWRTIMCHK		;IS MAX TIME EXCEEDED?
	BLBS	R0,45$			;IF LBS - NO, STILL MORE TIME NEEDED
	BRB	60$			;POWER UP TIME EXCEEDED
50$:
	BISW	#UCB$M_VALID,UCB$W_STS(R5) ;SET UCB STATUS VOLUME VALID

60$:	BISW	#UCB$M_ONLINE,UCB$W_STS(R5)  ;SET UCB STATUS VOLUME VALID
70$:	RSB
	.PAGE
	.SBTTL	DRIVER SPECIFIC SUBROUTINES
; 
; DL_WAIT - WAIT FOR CONTROLLER READY
; 
; INPUTS:
; 	R4	- DEVICE CSR ADDRESS
; 
; FUNCTIONAL DESCRIPTION:
; 
; 	THIS ROUTINE IS CALLED FROM THE DRIVER UNIT INITIALIZATION ROUTINE
; 	TO WAIT UNTIL THE RL11 CONTROLLER IS READY.  TO PREVENT HANGING UP
; 	AT HIGH IPL, A MAXIMUM OF 30 USEC ELAPSES BEFORE CONTROL IS
; 	RETURNED TO THE CALLER.
; 

DL_WAIT:				;WAIT FOR CONTROLLER READY
	MOVQ	R0,-(SP)		;SAVE R0, R1
	DSBINT				;DISABLE INTERRUPTS
	TIMEWAIT	#3,#RL_CS_M_CRDY,RL_CS(R4),W
	ENBINT				;ENABLE INTERRUPTS
	MOVQ	(SP)+,R0		;RESTORE R0, R1
	RSB				;RETURN TO UNIT INIT OR STARTIO
	.PAGE
	.SBTTL	FDT ROUTINE - TEST TRANSFER BYTE COUNT ALIGNMENT 

;++
; 
; DL_ALIGN - FDT ROUTINE TO TEST XFER BYTE COUNT
; 
; FUNCTIONAL DESCRIPTION:
; 
; 	THIS ROUTINE IS CALLED FROM THE FUNCTION DECISION TABLE DISPATCHER
; 	TO CHECK THE BYTE COUNT PARAMETER SPECIFIED BY THE USER PROCESS
; 	FOR AN EVEN NUMBER OF BYTES (WORD BOUNDARY).
; 
; INPUTS:
; 
; 	R3	- IRP ADDRESS (I/O REQUEST PACKET)
; 	R4	- PCB ADDRESS (PROCESS CONTROL BLOCK)
; 	R5	- UCB ADDRESS (UNIT CONTROL BLOCK)
; 	R6	- CCB ADDRESS (CHANNEL CONTROL BLOCK)
; 	R7	- BIT NUMBER OF THE I/O FUNCTION CODE
; 	R8	- ADDRESS OF FDT TABLE ENTRY FOR THIS ROUTINE
; 	4(AP)	- ADDRESS OF FIRST FUNCTION DEPENDENT QIO PARAMETER
; 
; OUTPUTS:
; 
; 	IF THE QIO BYTE COUNT PARAMETER IS ODD, THE I/O OPERATION IS
; 	TERMINATED WITH AN ERROR. IF IT IS EVEN, CONTROL IS RETURNED
; 	TO THE FDT DISPATCHER.
; 
;--

DL_ALIGN:				;CHECK BYTE COUNT AT P1(AP)
	BLBS	4(AP),10$		;IF LBS - ODD BYTE COUNT
	RSB				;EVEN - RETURN TO CALLER
10$:	MOVZWL	#SS$_IVBUFLEN,R0	;SET BUFFER ALIGNMENT STATUS
	JMP	G^EXE$ABORTIO		;ABORT I/O
	.PAGE
	.SBTTL	START I/O ROUTINE

;++
; 
; DL_STARTIO - START I/O ROUTINE
; 
; FUNCTIONAL DESCRIPTION:
; 
; 	THIS FORK PROCESS IS ENTERED FROM THE EXECUTIVE AFTER AN I/O REQUEST
; 	PACKET HAS BEEN DEQUEUED, AND PERFORMS THE FOLLOWING:
; 
; 		- ACTIVATES THE DISK AFTER SETTING UCB FIELDS, OBTAINING
; 		  UBA AND CONTROLLER RESOURCES, AND SETTING RL11 REGISTERS
; 
; 		- WAITS FOR AN INTERRUPT
; 
; 		- REGAINS CONTROL AFTER THE ISR SERVICES THE INTERRUPT, AND
; 			-  RE-ACTIVATES THE DISK IF THE ORIGINAL FUNCTION
; 			   IS NOT YET COMPLETE, OR
; 			-  COMPLETES THE I/O REQUEST BY RELEASING RESOURCES,
;			   SETTING STATUS CODES, AND RETURNING TO THE EXECUTIVE.
; 
; INPUTS:
; 
; 	R3		- IRP ADDRESS (I/O REQUEST PACKET)
; 	R5		- UCB ADDRESS (UNIT CONTROL BLOCK)
; 	IRP$L_MEDIA	- PARAMETER LONGWORD (LOGICAL BLOCK NUMBER)
; 
; OUTPUTS:
; 
; 	R0	- FIRST I/O STATUS LONGWORD: STATUS CODE & BYTES XFERED
; 	R1	- SECOND I/O STATUS LONGWORD: 0 FOR DISKS
; 
; 	THE I/O FUNCTION IS EXECUTED.
; 
; 	ALL REGISTERS EXCEPT R0-R4 ARE PRESERVED.
; 
;--

DL_STARTIO:				;START I/O OPERATION

; 
; 	COMPUTE PHYSICAL MEDIA ADDRESS
; 
;		LBN = LBN * (SECTORS/BLOCK)
; 		LBN/(SECTORS/TRACK) = D + SECTOR
; 		D/(TRACKS/CYLINDER) = CYLINDER + TRACK
; 

; 
; 	PREPROCESS UCB FIELDS
; 

PREPROCESS:				;
	MOVL	IRP$L_MEDIA(R3),-	; Copy given MEDIA address (logical)
		UCB$L_MEDIA(R5)		;  to the UCB.
	BBS	#IRP$V_PHYSIO,-		;IF SET - PHYSICAL I/O
		IRP$W_STS(R3),10$
	MULL3	#2,UCB$L_MEDIA(R5),R0	;SCALE LBN IN R0
	MOVZBL	UCB$B_SECTORS(R5),R2	;GET NUMBER OF SECTORS PER TRACK
	CLRL	R1			;CLEAR HIGH PART OF DIVIDEND
	EDIV	R2,R0,R0,UCB$L_MEDIA(R5);CALCULATE SECTOR NUMBER AND STORE
	MOVZBL	UCB$B_TRACKS(R5),R2	;GET NUMBER OF TRACKS PER CYLINDER
	EDIV	R2,R0,R0,R1		;CALCULATE TRACK AND CYLINDER
	MOVB	R1,UCB$L_MEDIA+1(R5)	;STORE TRACK NUMBER
	MOVW	R0,UCB$L_MEDIA+2(R5)	;STORE CYLINDER NUMBER
10$:
	MOVB	UCB$B_ERTMAX(R5),-	;INITIALIZE ERROR RETRY COUNT
		UCB$B_ERTCNT(R5)	;...
	MNEGW	UCB$W_BCNT(R5),UCB$W_BCR(R5)  ;INIT NEG BYTES LEFT TO XFER
	CLRW	UCB$W_DL_DPN(R5)	;CLEAR DATA PATH NO. FOR USE AS-
					;UBA RESOURCE ALLOCATION FLAG
	CLRB	UCB$B_DL_DPPE(R5)	;CLEAR DATAPATH PURGE ERROR REGISTER
	MOVW	IRP$W_FUNC(R3),UCB$W_FUNC(R5)  ;SAVE FUNCTION CODE
	EXTZV	#IRP$V_FCODE,-		;EXTRACT I/O FUNCTION CODE
		#IRP$S_FCODE,IRP$W_FUNC(R3),R1  ;...
	MOVB	R1,UCB$B_FEX(R5)	;STORE FUNCTION DISPATCH INDEX
	CMPB	#IO$_SEEK,R1		;SEEK FUNCTION?
	BNEQ	20$			;IF NEQ - NO
	MOVW	IRP$L_MEDIA(R3),-	;STORE CYLINDER ADDRESS
		UCB$W_DC(R5)		;...
20$:
	BICW	#UCB$M_DIAGBUF,-
		UCB$W_DEVSTS(R5)	;CLR DIAGNOSTIC BUFFER PRESENT
	BBC	#IRP$V_DIAGBUF,-	;IF CLR - NO DIAG BUFFER
		IRP$W_STS(R3),FDISPATCH ;...
	BISW	#UCB$M_DIAGBUF,UCB$W_DEVSTS(R5)  ;SET DIAG BUFFER PRESENT

; 
; 	CENTRAL FUNCTION DISPATCH
; 

FDISPATCH:				;FUNCTION DISPATCH
	MOVL	UCB$L_IRP(R5),R3	;GET IRP ADDRESS
	BBS	#IRP$V_PHYSIO,-		;IF SET - PHYSICAL I/O FUNCTION
		IRP$W_STS(R3),10$	;...
	BBS	#UCB$V_VALID,-		;IF SET - VOLUME SOFTWARE VALID
		UCB$W_STS(R5),10$	;...
	MOVZWL	#SS$_VOLINV,R0		;SET VOLUME INVALID STATUS
	BRW	RESETXFR		;RESET BYTE COUNT AND EXIT
10$:	CLRB	UCB$B_DL_DCHEK(R5)	;CLEAR DATA CHECK IN PROGRESS
	MOVZBL	UCB$B_FEX(R5),R3	;GET FUNCTION DISPATCH INDEX
	CASE	R3,<-			;DISPATCH TO FUNCTION HANDLING ROUTINE
		UNLOAD,-		; UNLOAD
		SEEK,-			; SEEK
		NOP,-			; RECALIBRATE (unsupported)
		DRVCLR,-		; DRVCLR
		NOP,-			; RELEASE PORT (unsupported)
		NOP,-			; OFFSET HEADS (unsupported)
		NOP,-			; RETURN TO CENTER (unsupported)
		PACKACK,-		; PACK ACKNOWLEDGE
		NOP,-			; SEARCH (unsupported)
		WRITECHECK,-		; WRITE CHECK
		WRITEDATA,-		; WRITE DATA
		READDATA,-		; READ DATA
		NOP,-			; WRITE HEADER (unsupported)
		READHEAD,-		; READ HEADER
		NOP,-			; place holder
		NOP,-			; place holder
		AVAILABLE-		; AVAILABLE
		>,LIMIT=#CDF_UNLOAD	; 

NOP:					;NO-OP
SEEK:					;SEEK
DRVCLR:					;DRIVE CLEAR (GET STATUS & RESET)
DO_FUNCTION:
	EXFUNCL	RETRYERR		;EXECUTE FUNCTION - RETRY IF FAILURE
	BRB	NORMAL			;SUCCESSFUL - EXIT WITH NORMAL STATUS

PACKACK:				;PACK ACKNOWLEDGE (GET STATUS & RESET)
	BISW	#UCB$M_VALID, -		;Set software volume valid bit.
		UCB$W_STS(R5)
	BRB	DO_FUNCTION		;Then go do hardware function.

UNLOAD:					;UNLOAD
AVAILABLE:				;AVAILABLE
	BICW	#UCB$M_VALID, -		;Clear software volume valid bit.
		UCB$W_STS(R5)		;and go complete operation without
	BRB	NORMAL			;any hardware interaction.

WRITECHECK:				;WRITE CHECK
READHEAD:				;READ HEADER
	BICW	#IO$M_DATACHECK,-	;CLEAR DATA CHECK REQUEST-
		UCB$W_FUNC(R5)		;TO PREVENT EXTRA WRITE CHECK

WRITEDATA:				;WRITE DATA
READDATA:				;READ DATA
	EXFUNCL	RETRYERR,F_SEEK		;EXECUTE EXPLICIT SEEK - RETRY IF FAIL

	MOVZBL	UCB$B_FEX(R5),R3	;GET FUNCTION DISPATCH INDEX
	EXFUNCL	RETRYERR		;EXECUTE TRANSFER FUNCTION

; 
; 	OPERATON COMPLETION
; 

NORMAL:					;SUCCESSFUL OPERATION COMPLETE
	MOVZWL	#SS$_NORMAL,R0		;SET NORMAL COMPLETION STATUS
	BRW	FUNCXT			;FUNCTION EXIT

RETRYERR:				;RETRIABLE ERROR
	DECB	UCB$B_ERTCNT(R5)	;ANY RETRIES LEFT?
	BEQL	FATALERR		;IF EQL - NO
	BRW	FDISPATCH		;RETRY FUNCTION

FATALERR:				;UNRECOVERABLE ERROR
	MOVZWL	#SS$_VOLINV,R0		;ASSUME VOLUME INVALID STATUS
	BBS	#RL_MP_V_VC,-		;IF SET - VOLUME INVALID
		UCB$W_DL_MP(R5),FUNCXT	;...

	MOVZWL	#SS$_WRITLCK,R0		;ASSUME WRITE LOCK ERROR STATUS
	BBC	#RL_MP_V_WL,-		;IF CLR - VOLUME NOT WRITE LOCKED
		UCB$W_DL_MP(R5),5$	;...
	BBS	#RL_MP_V_WGE,-		;IF SET - WRITE GATE ERROR
		UCB$W_DL_MP(R5),FUNCXT	;IF WL & WGE SET - WRITE LOCK ERROR

5$:	MOVZWL	#SS$_DATACHECK,R0	;ASSUME DATA CHECK ERROR STATUS
	TSTB	UCB$B_DL_DCHEK(R5)	;WRITE CHECK IN PROGRESS?
	BEQL	10$			;IF EQL - NO
	BBS	#RL_CS_V_OPI,-		;IF SET - NOT WRITE CHECK ERROR
		UCB$W_DL_CS(R5),10$	;...
	BBS	#RL_CS_V_CRC,-		;IF SET - WRITE CHECK ERROR
		UCB$W_DL_CS(R5),FUNCXT	;...

10$:	MOVZWL	#SS$_PARITY,R0		;ASSUME PARITY ERROR STATUS
	BBS	#RL_CS_V_CRC,-		;IF SET - CRC ERROR
		UCB$W_DL_CS(R5),FUNCXT	;OR DATAPATH PURGE ERROR
	BBC	#RL_CS_V_OPI,UCB$W_DL_CS(R5),20$  ;HEADER NOT FOUND ERROR?
	BBS	#RL_CS_V_DLT,-		;...
		UCB$W_DL_CS(R5),FUNCXT	;IF OPI & DLT SET - YES

20$:	MOVZWL	#SS$_DRVERR,R0		;ASSUME DRIVE ERROR STATUS
	BBS	#RL_CS_V_DE,-		;IF SET - DRIVE ERROR
		UCB$W_DL_CS(R5),FUNCXT	;...

	MOVZWL	#SS$_CTRLERR,R0		;ASSUME CONTROLLER ERROR STATUS

FUNCXT:					;FUNCTION EXIT
	PUSHL	R0			;SAVE FINAL REQUEST STATUS
	JSB	G^IOC$DIAGBUFILL	;FILL DIAGNOSTIC BUFFER IF PRESENT
	CMPB	#CDF_WRITECHECK,UCB$B_FEX(R5)  ;DRIVE RELATED FUNCTION?
	BGTRU	10$			;IF GTRU - YES
	CMPB	#CDF_AVAILABLE,UCB$B_FEX(R5)   ;DRIVE RELATED FUNCTION?
	BEQL	10$			;IF EQL  - YES
	MOVL	UCB$L_IRP(R5),R3	;RETRIEVE ADDRESS OF IRP
	ADDW3	UCB$W_BCR(R5),-		;CALCULATE BYTES TRANSFERRED
		IRP$W_BCNT(R3),2(SP)	;...
	TSTW	UCB$W_DL_DPN(R5)	;ARE UBA RESOURCES ALLOCATED?
	BEQL	10$			;IF EQL - NO

	RELDPR				;RELEASE DATA PATH
	RELMPR				;RELEASE MAP REGISTERS
10$:	RELCHAN				;RELEASE CHANNEL IF OWNED

	CLRL	R1			;CLEAR SECOND STATUS LONGWORD
	POPL	R0			;RETRIEVE FINAL REQUEST STATUS
	REQCOM				;COMPLETE REQUEST
	.PAGE
; 
; FEXL - RL11 HARDWARE FUNCTION EXECUTION 
; 
; THIS ROUTINE IS CALLED VIA A BSB WITH A BYTE IMMEDIATELY FOLLOWING THAT
; SPECIFIES THE ADDRESS OF AN ERROR ROUTINE. ALL DATA IS ASSUMED TO HAVE BEEN
; SET UP IN THE UCB BEFORE THE CALL. THE APPROPRIATE PARAMETERS ARE LOADED
; INTO DEVICE REGISTERS AND THE FUNCTION IS INITIATED. THE RETURN ADDRESS
; IS STORED IN THE UCB AND A WAITFOR INTERRUPT IS EXECUTED. WHEN THE
; INTERRUPT OCCURS, CONTROL IS RETURNED TO THE CALLER.
; 
; INPUTS:
; 
; 	R3 = FUNCTION TABLE DISPATCH INDEX
; 	R5 = DEVICE UNIT UCB ADDRESS
; 
; 	00(SP) = RETURN ADDRESS OF CALLER
; 	04(SP) = RETURN ADDRESS OF CALLER'S CALLER
; 
; 	IMMEDIATELY FOLLOWING INLINE AT THE CALL SITE IS A BYTE WHICH CONTAINS
; 	A BRANCH DESTINATION TO AN ERROR RETRY ROUTINE.
; 
; OUTPUTS:
; 
; 	THERE ARE FOUR EXITS FROM THIS ROUTINE:
; 
; 	1. SPECIAL CONDITION - THIS EXIT IS TAKEN IF A POWER FAILURE OCCURS
; 		OR THE OPERATION TIMES OUT. IT IS A JUMP TO THE APPROPRIATE
; 		ERROR ROUTINE.
; 
; 	2. FATAL ERROR - THIS EXIT IS TAKEN IF A FATAL CONTROLLER OR DRIVE
; 		ERROR OCCURS OR IF ANY ERROR OCCURS AND ERROR RETRY IS EITHER
; 		INHIBITED OR EXHAUSTED. IT IS A JUMP TO THE FATAL ERROR EXIT
; 		ROUTINE.
; 
; 	3. RETRIABLE ERROR - THIS EXIT IS TAKEN IF A RETRIABLE CONTROLLER
; 		OR DRIVE ERROR OCCURS AND ERROR RETRY IS NEITHER INHIBITED
; 		NOR EXHAUSTED. IT CONSISTS OF TAKING THE ERROR BRANCH EXIT
; 		SPECIFIED AT THE CALL SITE.
; 
; 	4. SUCCESSFUL OPERATION - THIS EXIT IS TAKEN IF NO ERRORS OCCUR
; 		DURING THE OPERATION. IT CONSISTS OF A RETURN INLINE.
; 
; 	IN ALL CASES IF AN ERROR OCCURS, AN ATTEMPT IS MADE TO LOG THE ERROR.
; 
; 	IN ALL CASES FINAL DEVICE REGISTERS ARE RETURNED VIA THE UCB.
; 
; 	UCB$W_BCR(R5) = NEGATIVE BYTES REMAINING TO TRANSFER
	.PAGE
FEXL:					;FUNCTION EXECUTOR 
	POPL	UCB$L_DPC(R5)		;SAVE DRIVER PC VALUE
	MOVB	R3,UCB$B_CEX(R5)	;SAVE CASE INDEX
	MOVL	UCB$L_CRB(R5),R0	;GET ADDRESS OF PRIMARY CRB
	MOVL	CRB$L_INTD+VEC$L_IDB(R0),R1  ;GET ADDRESS OF IDB
	CMPL	R5,IDB$L_OWNER(R1)	;DOES THIS PROCESS OWN CHANNEL?
	BNEQ	10$			;IF NEQ - NO
	MOVL	IDB$L_CSR(R1),R4	;SET ASSIGNED CHANNEL CSR ADDRESS
	BRB	20$			;
10$:	REQPCHAN			;REQUEST CHANNEL (RETURNS R4 = CSR ADR)

20$:	CASE	R3,<-			;DISPATCH TO PROPER FUNCTION ROUTINE
		IMMED,-			;NO OPERATION
		IMMED,-			;UNLOAD VOLUME (NOP)
		POSIT,-			;SEEK CYLINDER
		IMMED,-			;RECALIBRATE (NOP)
		DRCLR,-			;DRIVE CLEAR (GET STATUS & RESET)
		IMMED,-			;RELEASE DRIVE (NOP)
		IMMED,-			;OFFSET HEADS (NOP)
		IMMED,-			;RETURN TO CENTERLINE (NOP)
		DRCLR,-			;PACK ACKNOWLEDGE 
		IMMED,-			;SEARCH (NOP)
		>			;
	BRW	XFER			;TRANSFER FUNCTION
	.PAGE
; 
; IMMEDIATE FUNCTION EXECUTION
; 
; 	FUNCTIONS INCLUDE:
; 
; 		NO OPERATION,
; 		DRIVE CLEAR, AND
; 		PACK ACKNOWLEDGE
; 
; INPUTS:
; 	R3	- CASE INDEX
; 	R4	- CSR ADDRESS
; 	R5	- UCB ADDRESS
; 
; FUNCTIONAL DESRIPTION:
; 
; INTERRUPTS ARE LOCKED OUT, THE APPROPRIATE FUNCTION IS INITIATED WITH
; INTERRUPT ENABLE, AND A WAITFOR INTERRUPT AND KEEP CHANNEL IS EXECUTED.
; 

DRCLR:					;DRIVE CLEAR
	BISW	#RL_DA_M_STS!-		;SET GETSTATUS,RESET,AND MARK IN DAR
		RL_DA_M_RST!RL_DA_M_MRK,RL_DA(R4)  ;...
 
IMMED:					;IMMEDIATE FUNCTION EXECUTION
	CKPWR				;DISABLE INTERRUPTS, CHECK POWER,-
					;AND PUT UNIT NUMBER IN R2<9:8>
	BISW3	R2,FTAB[R3],RL_CS(R4)	;MERGE UNIT WITH FNTN AND EXECUTE
	WFIKPCH	RETREG,#2		;WAITFOR INTERRUPT
	IOFORK				;RETURN FROM ISR-
					;CREATE FORK PROCESS (&JSB BACK TO ISR)
	BRW	RETREG			;
	.PAGE
; 
; POSITIONING FUNCTION EXECUTION
; 
; 	FUNCTIONS INCLUDE:
; 
; 		SEEK CYLINDER
; 
; INPUTS:
; 	R3	- CASE INDEX
; 	R4	- DEVICE CSR ADDRESS
; 	R5	- UCB ADDRESS
; 
; FUNCTIONAL DESRIPTION:
; 
; THE CYLINDER DIFFERENCE WORD IS CALCULATED AND LOADED INTO THE DISK
; ADDRESS REGISTER, INTERRUPTS ARE LOCKED OUT, AND THE SEEK FUNCTION
; IS INITIATED WITHOUT INTERRUPT ENABLE. THE CONTROLLER IS THEN POLLED
; FOR READY, AND DEVICE INTERRUPTS ARE ENABLED.
; 
; SINCE THE RL01/RL02 DO NOT ISSUE AN INTERRUPT UPON COMPLETION OF A
; SEEK, OVERLAPPED SEEKS ARE NOT ATTEMPTED, AND ONE OF THE FOLLOWING IS
; PERFORMED.
; 
; 	IF ONLY A SEEK FUNCTION IS BEING REQUESTED, A DUMMY READ HEADER
; 	FUNCTION IS ISSUED AND A WAITFOR INTERRUPT IS INITIATED.
; 	THE READ HEADER IS USED TO SIGNAL THE END OF THE SEEK, SINCE IT
; 	WILL ISSUE AN INTERRUPT SHORTLY (315 USEC AVG) AFTER THE SEEK IS
; 	COMPLETE. IT WILL ALSO SENSE FOR A TIMEOUT DURING THE SEEK.
; 
; 	IF THE SEEK IS ASSOCIATED WITH A DATA TRANSFER REQUEST (RL01/RL02
; 	TRANSFER FUNCTIONS REQUIRE EXPLICIT SEEKS), THE PROGRAM KEEPS THE
; 	CHANNEL AND RETURNS TO FDISPATCH TO ISSUE THE TRANSFER REQUEST
; 	WHILE THE SEEK IS STILL IN PROGREES. WHEN THE SEEK COMPLETES, THE
; 	RL11 CONTROLLER WILL BEGIN THE TRANSFER.
; 

POSIT:					;POSITIONING FUNCTION
; 
; OBTAIN CURRENT DISK ADDRESS
; 
; IF THERE HAS NOT BEEN A PREVIOUS TRANSFER DURING THIS REQUEST,
; A READ HEADER IS EXECUTED TO DETERMINE THE CURRENT DISK ADDRESS.
; 
	TSTW	UCB$W_DL_DPN(R5)	;WAS THERE A PREVIOUS TRANSFER?
	BEQL	10$			;IF EQL - NO, READ HEADER
	BICW3	#^O77,UCB$W_DL_DA(R5),R1  ;PUT CURRENT CYL & SURFACE IN R1
	BRW	60$			;CALCULATE DIFFERENCE WORD

10$:	MOVZBL	#8,R3			;SET READ HEADER RETRY COUNT IN R3
20$:	CKPWR				;DISABLE INTERRUPTS, CHECK POWER,-
					;AND PUT UNIT NUMBER IN R2<9:8>
	BISW3	R2,#F_READHEAD!RL_CS_M_IE,-  ;EXECUTE READ HEADER
		RL_CS(R4)		;...
	WFIKPCH	40$,#2			;WAIT FOR INTERRUPT OR TIMEOUT
	IOFORK				;CREATE FORK PROCESS
	BITW	#RL_CS_M_CE,UCB$W_DL_CS(R5)  ;ANY ERRORS?
	BEQL	50$			;IF EQL - NO
	DECB	R3			;DECREMENT READ HEADER RETRY COUNT
	BNEQ	20$			;IF NEQ - RETRY READ HEADER
					;IF EQL - READ HEADER RETRY EXHAUSTED -
					;TRY PREVIOUS TRACK
	MOVW	#^O200!RL_DA_M_MRK,-	;LOAD REVERSE SEEK DIFFERENCE WORD
		RL_DA(R4)		;...
	CKPWR				;DISABLE INTERRUPTS, CHECK POWER,-
					;AND PUT UNIT NUMBER IN R2<9:8>
	BISW3	R2,#F_SEEK!RL_CS_M_IE,-	;EXECUTE REVERSE SEEK
		RL_CS(R4)		;...
	WFIKPCH	40$,#2			;WAIT FOR SEEK TO BEGIN (INTERRUPT)
	IOFORK				;CREATE FORK PROCESS
	CKPWR				;DISABLE INTERRUPTS, CHECK POWER,-
					;AND PUT UNIT NUMBER IN R2<9:8>
	BISW3	R2,#F_READHEAD!RL_CS_M_IE,-  ;TRY READ HEADER ON NEW TRACK
		RL_CS(R4)		;...
	WFIKPCH	40$,#2			;WAITFOR INTERRUPT OR TIMEOUT
	IOFORK				;CREATE FORK PROCESS
	BITW	#RL_CS_M_CE,UCB$W_DL_CS(R5)  ;READ HEADER ERROR?
	BEQL	50$			;IF EQL - NO
40$:					;CAN NOT READ CURRENT DISK ADDRESS
;	CLRB	UCB$B_ERTCNT(R5)	;CLEAR RETRY COUNT
	BRW	RETREG			;
50$:					;FOUND CURRENT DISK ADDRESS
	BICW3	#^O77,UCB$W_DL_MP(R5),R1  ;PUT CURRENT CYL & SURFACE IN R1

; 
; CALCULATE CYLINDER DIFFERENCE WORD
; 

60$:	CLRL	R0			;CLEAR R0 FOR DESIRED ADDRESS
	INSV	UCB$W_DA+1(R5),#6,#1,R0	;INSERT DESIRED SURFACE IN R0<6>
	INSV	UCB$W_DC(R5),#7,#9,R0	;INSERT DESIRED CYLINDER IN R0<15:7>
	CMPW	R0,R1			;IS A SEEK NEEDED?
	BEQL	80$			;IF EQL - NO
	BICW	#^O177,R1		;REMOVE SURFACE BIT
	BICW	#^O177,R0		;REMOVE SURFACE BIT
	SUBW	R0,R1			;SUBTRACT DESIRED FROM ACTUAL
	BEQL	70$			;IF EQL - ONLY CHANGE SURFACE
	BCC	70$			;IF CC - ACTUAL>=DESIRED
	MNEGW	R1,R1			;ACTUAL<DESIRED, MAKE POSITIVE DIFF
	BISW	#4,R1			;SET SIGN FOR MOVE TO CENTER OF DISK
70$:	INSV	UCB$W_DA+1(R5),#4,#1,R1	;INSERT SURFACE BIT
	BISW3	#RL_DA_M_MRK,R1,RL_DA(R4)  ;SET MARKER AND LOAD DIFFERENCE WORD

; 
; EXECUTE SEEK
; 

	CKPWR				;DISABLE INTERRUPTS, CHECK POWER,-
					;AND PUT UNIT NUMBER IN R2<9:8>
	BISW3	R2,#F_SEEK!RL_CS_M_IE,-	;EXECUTE SEEK FUNCTION
		RL_CS(R4)		;...
	WFIKPCH	40$,#2			;WAIT FOR SEEK TO BEGIN (INTERRUPT)
	IOFORK				;CREATE FORK PROCESS
80$:	CMPB	#IO$_SEEK,UCB$B_FEX(R5)	;IS SEEK ASSOCIATED WITH A TRANSFER?
	BEQL	90$			;IF EQL - NO, SEEK ONLY

; 
; RETURN FOR SEEK ASSOCIATED WITH A TRANSFER REQUEST
; 

	INCL	UCB$L_DPC(R5)		;ADJUST TO CORRECT RETURN ADDRESS
	JMP	@UCB$L_DPC(R5)		;RETURN TO DRIVER FOR TRANSFER
; 
; RETURN FOR SEEK ONLY REQUEST
; 

90$:	CKPWR				;DISABLE INTERRUPTS, CHECK POWER,-
					;AND PUT UNIT NUMBER IN R2<9:8>
	BISW3	R2,#F_READHEAD!RL_CS_M_IE,-  ;EXECUTE DUMMY READ HEADER
		RL_CS(R4)		;...
	WFIKPCH	RETREG,#2		;WAIT FOR SEEK TO COMPLETE (INTERRUPT)
	IOFORK				;CREATE FORK PROCESS
	BRW	RETREG			;
	.PAGE

; 
; TRANSFER FUNCTION EXECUTION
; 
; 	FUNCTIONS INCLUDE:
; 
; 		WRITE CHECK
; 		WRITE DATA
; 		READ DATA, AND
; 		READ HEADER
; 
; INPUTS:
; 	R3	- CASE INDEX
; 	R4	- DEVICE CSR ADDRESS
; 	R5	- UCB ADDRESS
; 
; FUNCTIONAL DESCRIPTION:
; 
; A UNIBUS DATAPATH IS REQUESTED FOLLOWED BY THE APPROPRIATE NUMBER OF MAP
; REGISTERS REQUIRED FOR THE TRANSFER. THE TRANSFER PARAMETERS ARE LOADED
; INTO THE DEVICE REGISTERS, INTERRUPTS ARE LOCKED OUT, THE FUNCTION IS
; INITIATED, AND A WAITFOR INTERRUPT AND KEEP CHANNEL IS EXECUTED.
; 
; UPON RETURN FROM THE INTERRUPT SERVICE ROUTINE, IF THE TRANSFER IS 
; COMPLETE, THE APPROPRIATE EXIT IS TAKEN. IF THE FUNCTION IS NOT COMPLETE
; TRANSFER PARAMETERS ARE UPDATED AND A RETURN TO FDISPATCH IS EXECUTED TO 
; RE-ISSUE SEEK AND TRANSFER FUNCTIONS WHILE KEEPING CHANNEL AND UBA 
; RESOURCES. IF A DATA CHECK HAS BEEN REQUESTED, IT IS PERFORMED
; BEFORE RETURNING TO FDISPATCH.
; 

XFER:					;TRANSFER FUNCTION EXECUTION
	TSTW	UCB$W_DL_DPN(R5)	;UBA RESOURCES ALREADY ALLOCATED?
	BNEQ	5$			;IF NEQ - YES

; 
; FIRST TRANSFER OF THIS I/O REQUEST - ALLOCATE RESOURCES
; 

	REQDPR				;REQUEST DATAPATH
	REQMPR				;REQUEST MAP REGISTERS
	LOADUBA				;LOAD UNIBUS MAP REGISTERS
	MOVL	UCB$L_CRB(R5),R1	;GET CRB ADDRESS
	EXTZV	#VEC$V_DATAPATH,#VEC$S_DATAPATH,-  ;EXTRACT DATAPATH NUMBER - 
		CRB$L_INTD+VEC$B_DATAPATH(R1),R0   ;FOR UBA RESOURCE FLAG
	MOVW	R0,UCB$W_DL_DPN(R5)	;INDICATE UBA RESOURCES ALLOCATED
 
	MOVZWL	UCB$W_BOFF(R5),R0	;GET BYTE OFFSET IN PAGE
	INSV	CRB$L_INTD+VEC$W_MAPREG(R1),-  ;INSERT HIGH 7 BITS OF ADDRESS
		#9,#7,R0		;...
	MOVW	R0,UCB$W_DL_SBA(R5)	;SET BUFFER ADDRESS
	EXTZV	#7,#2,CRB$L_INTD+VEC$W_MAPREG(R1),R0  ;GET MEMORY EXTENSION BITS
	MULB3	#16,R0,UCB$B_DL_XBA(R5)	;POSITION MEMORY EXTENSION BITS TO <5:4>

; 
; COMMON TRANSFER POINT
; 

; 
; PUT BUFFER ADDRESS, WORD COUNT, AND DISK ADDRESS IN DEVICE REGISTERS
; 

5$:	MOVZBL	UCB$B_DL_XBA(R5),R0	;SET MEMORY EXTENSION BITS
	BISW	FTAB[R3],R0		;MERGE XBA BITS WITH FUNCTION
	MOVW	UCB$W_DL_SBA(R5),RL_BA(R4)  ;SET BUFFER ADDRESS

	MNEGW	UCB$W_BCR(R5),-		;GET BYTES LEFT TO TRANSFER AND -
		UCB$W_DL_PBCR(R5)	;ASSUME ONLY ONE TRANSFER NEEDED
	MOVZBL	UCB$B_SECTORS(R5),R2	;GET SECTORS/SURFACE
	MOVZBL	UCB$W_DA(R5),R1		;GET DESIRED SECTOR
	SUBW	R1,R2			;CALCULATE SECTORS LEFT ON SURFACE
	MULW	#256,R2			;CONVERT TO BYTES LEFT ON SURFACE
	CMPW	UCB$W_DL_PBCR(R5),R2	;ARE ADDITIONAL TRANSFERS REQUIRED?
	BLEQU	10$			;IF LEQU - NO
	MOVW	R2,UCB$W_DL_PBCR(R5)	;SET BYTE COUNT FOR THIS TRANSFER
10$:	DIVW3	#2,UCB$W_DL_PBCR(R5),R2	;CALCULATE TRANSFER WORD COUNT
	MNEGW	R2,RL_MP(R4)		;SET TRANSFER WORD COUNT

	MOVZBL	UCB$W_DA(R5),R1		;PUT DESIRED SECTOR IN R1<5:0>
	INSV	UCB$W_DA+1(R5),#6,#1,R1	;INSERT DESIRED SURFACE IN R1<6>
	INSV	UCB$W_DC(R5),#7,#9,R1	;INSERT DESIRED CYLINDER IN R1<15:7>
	MOVW	R1,RL_DA(R4)		;SET DESIRED DISK ADDRESS

; 
; EXECUTE THE TRANSFER FUNCTION
; 

	CKPWR				;DISABLE INTERRUPTS, CHECK POWER,-
					;AND PUT UNIT NUMBER IN R2<9:8>
	BISW3	R2,R0,RL_CS(R4)		;EXECUTE FUNCTION
	WFIKPCH	RETREG,#6		;WAITFOR INTERRUPT AND KEEP CHANNEL
					;RETURN HERE FROM ISR SAVING REGISTERS
	IOFORK				;CREATE FORK PROCESS (RETURN TO ISR)
					;RETURN HERE FROM ISR REI ROUTINE

; 
; PURGE DATAPATH
; 

	CLRB	UCB$B_DL_DPPE(R5)	;CLEAR DATAPATH PURGE ERROR
	JSB	G^IOC$PURGDATAP		;PURGE DATAPATH
	BLBS	R0,20$			;IF SET - NO PURGE ERRORS
	INCB	UCB$B_DL_DPPE(R5)	;SET DATAPATH PURGE ERROR

; 
; SAVE UBA REGISTERS FOR UPDATE AND REGDUMP ROUTINES
; 

20$:	MOVL	R1,UCB$L_DL_DPR(R5)	;SAVE DATAPATH REGISTER
	EXTZV	#9,#7,UCB$W_DL_BA(R5),R0  ;EXTRACT LOW BITS OF FINAL MAP REG NO.
	EXTZV	#4,#2,UCB$W_DL_CS(R5),R1  ;EXTRACT HI BITS OF FINAL MAP REG NO.
	INSV	R1,#7,#2,R0		;INSERT HIGH BITS OF FINAL MAP REGISTER
	CMPW	#495,R0			;LEGAL MAP REGISTER NUMBER?
	BGEQ	25$			;IF GEQ - YES
	MOVZWL	#495,R0			;RESTRICT MAP REGISTER NUMBER
25$:	MOVL	(R2)[R0],UCB$L_DL_FMPR(R5)  ;SAVE FINAL MAP REGISTER NUMBER
	CLRL	UCB$L_DL_PMPR(R5)	;CLEAR PREVIOUS MAP REGISTER CONTENTS
	DECL	R0			;CALCULATE PREVIOUS MAP REGISTER NUMBER
	CMPV	#VEC$V_MAPREG,#VEC$S_MAPREG,-  ;ANY PREVIOUS MAP REGISTER?
		CRB$L_INTD+VEC$W_MAPREG(R3),R0 ;...
	BGTR	30$			;IF GTR - NO
	MOVL	(R2)[R0],UCB$L_DL_PMPR(R5)  ;SAVE PREVIOUS MAP REGISTER
30$:	BBC	#RL_CS_V_CE,UCB$W_DL_CS(R5),40$  ;IF CLR - NO RL ERRORS
	BRW	RETREG			;DEVICE ERROR
40$:	BLBC	UCB$B_DL_DPPE(R5),45$	;IF CLR - NO PURGE ERROR
	BRW	RETREG			;PURGE ERROR

; 
; RETURN HEADER INFORMATION FOR READ HEADER FUNCTION
; 

45$:	CMPB	#CDF_READHEAD,UCB$B_CEX(R5)  ;READ HEADER FUNCTION?
	BNEQ	DATACHECK		;IF NEQ - NO
	PUSHL	UCB$W_BCR(R5)		;SAVE NEG BYTES REMAINING
	PUSHL	UCB$L_SVAPTE(R5)	;SAVE ADDRESS OF PTE
	MOVAB	UCB$W_DL_DB(R5),R1	;SET ADDRESS OF INTERNAL BUFFER
	MOVL	#6,R2			;SET NUMBER OF BYTES TO MOVE
	CMPW	R2,UCB$W_BCNT(R5)	;ROOM FOR FULL HEADER?
	BLSSU	50$			;IF LSSU - YES
	MOVZWL	UCB$W_BCNT(R5),R2	;SET LENGTH OF PARTIAL HEADER
50$:	SUBW3	UCB$W_BCNT(R5),R2,UCB$W_BCR(R5)  ;CALCULATE TRANSFER BYTE COUNT
	JSB	G^IOC$MOVTOUSER		;MOVE HEADER TO USER BUFFER
	POPL	UCB$L_SVAPTE(R5)	;RESTORE ADDRESS OF PTE
	POPL	UCB$W_BCR(R5)		;RESTORE NEG BYTES REMAINING

; 
; PERFORM DATA CHECK, IF REQUESTED
; 

DATACHECK:				;DATACHECK AFTER PARTIAL TRANSFER
	BBC	#IO$V_DATACHECK,-	;IF CLR - DATA CHECK NOT REQUESTED
		UCB$W_FUNC(R5),UPDATE	;...
	BBSC	#0,UCB$B_DL_DCHEK(R5),-	;IF SET - DATA CHECK ALREADY PERFORMED
		UPDATE			;...
	INCB	UCB$B_DL_DCHEK(R5)	;SET DATA CHECK IN PROGRESS
	MOVZBL	#IO$_WRITECHECK,R3	;SET CASE INDEX TO WRITE CHECK
	BRW	XFER			;BRANCH TO PERFORM WRITE CHECK

; 
; UPDATE BUFFER ADDRESS, CURRENT DISK ADDRESS, AND BYTES REMAINING
; FOR NEXT TRANSFER 
; 

UPDATE:					;UPDATE TRANSFER PARAMETERS
	BICB3	#^XCF,UCB$W_DL_CS(R5),-	;SAVE MEMORY EXTENSION BITS
		UCB$B_DL_XBA(R5)	;...
	MOVW	UCB$W_DL_BA(R5),-	;UPDATE SAVED BUFFER ADDRESS
		UCB$W_DL_SBA(R5)	;...

	CLRB	UCB$W_DA(R5)		;UPDATE DESIRED SECTOR TO ZERO
	ADDL3	#^O100,UCB$W_DL_DA(R5),R1  ;INCREMENT CYLINDER & SURFACE
	EXTZV	#6,#1,R1,R2		;EXTRACT DESIRED DISK SURFACE
	MOVB	R2,UCB$W_DA+1(R5)	;UPDATE DESIRED DISK SURFACE
	EXTZV	#7,#9,R1,R2		;EXTRACT DESIRED DISK CYLINDER
	MOVW	R2,UCB$W_DC(R5)		;UPDATE DESIRED DISK CYLINDER
	ADDW	UCB$W_DL_PBCR(R5),-	;UPDATE NEG BYTES REMAINING TO XFER
		UCB$W_BCR(R5)		;...
	BEQL	RETREG			;IF EQL - TRANSFER COMPLETE
	BRW	FDISPATCH		;MORE BYTES REMAINING - CONTINUE

; 
; GET STATUS AND RESET ERRORS
; 

RETREG:					;GET STATUS AND RESET ERRORS
	SETIPL	UCB$B_FIPL(R5)		;MAKE SURE AT FORK IPL (TIMEOUT)
	MOVW	#RL_DA_M_STS!-		;PUT GET STATUS IN DAR
		RL_DA_M_MRK,RL_DA(R4)	;...
	CLRL	R2			;CLEAR R2 FOR UNIT NUMBER
	INSV	UCB$W_UNIT(R5),#8,#8,R2	;GET UNIT NUMBER
	BISW3	R2,#F_GETSTATUS,RL_CS(R4)  ;EXECUTE GET STATUS
	BSBW	DL_WAIT			;WAIT FOR CONTROLLER
	MOVW	RL_MP(R4),UCB$W_DL_MP(R5)  ;RETRIEVE ERROR REGISTER
	MOVW	#RL_DA_M_RST!-		;PUT GET STATUS & RESET IN DAR
		RL_DA_M_STS!RL_DA_M_MRK,RL_DA(R4)  ;...
	BISW3	R2,#F_GETSTATUS,RL_CS(R4)  ;EXECUTE RESET
	BSBW	DL_WAIT			;WAIT FOR CONTROLLER

; 
; DETERMINE EXIT - SPECIAL CONDITION, FATAL ERROR, RETRIABLE ERROR, OR SUCCESS
; 

	CMPZV	#0,#5,UCB$W_DL_MP(R5),-	;HEADS, BRUSHES, STATE OK?
		#RL_MP_M_BH!RL_MP_M_HO!RL_SLM  ;...
	BEQL	1$			;IF EQL - YES, ONLINE
	BICW	#UCB$M_TIMOUT,UCB$W_STS(R5)  ;CLEAR DEVICE TIME OUT
	MOVZWL	#SS$_MEDOFL,R0		;SET MEDIUM OFFLINE STATUS
	BRW	FUNCXT			;RETURN
1$:	BITW	#UCB$M_POWER!-		;POWER FAIL OR DEVICE TIMEOUT?
		UCB$M_TIMOUT,UCB$W_STS(R5)  ;...
	BNEQ	SPECOND			;IF NEQ - YES, SPECIAL CONDITION

	BBS	#RL_MP_V_VC,UCB$W_DL_MP(R5),20$  ;IF SET - VOLUME INVALID
	BBS	#RL_CS_V_CE,UCB$W_DL_CS(R5),2$  ;IF SET - RL ERROR
	BLBC	UCB$B_DL_DPPE(R5),10$	;IF CLR - NO PURGE ERROR
2$:	JSB	G^ERL$DEVICERR		;ALLOCATE AND FILL ERROR MESSAGE BUFFER
	BBS	#IO$V_INHRETRY,UCB$W_FUNC(R5),20$  ;IF SET - RETRY INHIBITED
	BBS	#RL_CS_V_NXM,UCB$W_DL_CS(R5),20$  ;IF SET - NONEXISTENT MEMORY
	BBC	#RL_CS_V_DE,UCB$W_DL_CS(R5),5$  ;IF CLR - NO DRIVE ERRORS
	BBC	#RL_MP_V_WL,UCB$W_DL_MP(R5),4$  ;IF CLR - NOT WRITE LOCKED 
	BBS	#RL_MP_V_WGE,UCB$W_DL_MP(R5),20$  ;IF WL & WGE SET - WL ERROR
4$:	BITW	#RL_MP_M_WDE!-		;WRITE DATA ERROR, OR
		RL_MP_M_CHE!-		;CURRENT HEAD ERROR, OR
		RL_MP_M_WGE!-		;WRITE GATE ERROR, OR
		RL_MP_M_DSE,UCB$W_DL_MP(R5)  ;DRIVE SELECT ERROR?
	BNEQ	20$			;IF NEQ - YES

; 
; RETRIABLE ERROR EXIT
; 

5$:	CVTBL	@UCB$L_DPC(R5),-(SP)	;GET BRANCH DISPLACEMENT
	ADDL	(SP)+,UCB$L_DPC(R5)	;CALCULATE RETURN ADDRESS - 1

; 
; SUCCESSFUL OPERATION EXIT
; 

10$:	INCL	UCB$L_DPC(R5)		;ADJUST TO CORRECT RETURN ADDRESS
	JMP	@UCB$L_DPC(R5)		;RETURN TO DRIVER

; 
; FATAL ERROR EXIT
; 

20$:	BRW	FATALERR		;FATAL ERROR EXIT

; 
; SPECIAL CONDITION EXIT (POWER FAILURE OR DEVICE TIMEOUT)
; 

SPECOND:
	BBS	#UCB$V_POWER,UCB$W_STS(R5),PWRFAIL  ;IF SET - POWER FAILURE
					;IF CLR - DEVICE TIMEOUT
	JSB	G^ERL$DEVICTMO		;LOG DEVICE TIMEOUT
	BICW	#UCB$M_TIMOUT,UCB$W_STS(R5)  ;CLEAR TIMEOUT STATUS
	MOVZWL	#SS$_TIMEOUT,R0		;SET DEVICE TIMEOUT STATUS
	DECB	UCB$B_ERTCNT(R5)	;ANY ERROR RETRIES REMAINING?
	BEQL	RESETXFR		;IF EQL - NO
	BRW	FDISPATCH		;RETURN

RESETXFR:				;RESET TRANSFER BYTE COUNT
	MOVL	UCB$L_IRP(R5),R3	;GET ADDRESS OF I/O PACKET
	MNEGW	IRP$W_BCNT(R3),UCB$W_BCR(R5)  ;RESET BYTE COUNT
	BRW	FUNCXT			;EXIT

PWRFAIL:				;POWER FAILURE
	BICW	#UCB$M_POWER,UCB$W_STS(R5)  ;CLEAR POWER FAILURE BIT
	TSTW	UCB$W_DL_DPN(R5)	;ARE UCB RESOURCES ALLOCATED?
	BEQL	50$			;IF EQL - NO
	RELDPR				;RELEASE DATA PATH
	RELMPR				;RELEASE MAP REGISTERS
50$:	RELCHAN				;RELEASE CHANNEL IF OWNED
	MOVL	UCB$L_IRP(R5),R3	;GET ADDRESS OF I/O PACKET
	MOVQ	IRP$L_SVAPTE(R3),-	;RESTORE TRANSFER PARAMETERS
		UCB$L_SVAPTE(R5)	;...
	BRW	PREPROCESS		;RETURN TO PREPROCESS UCB FIELDS
	.PAGE
	.SBTTL	INTERRUPT SERVICE ROUTINE
;++
; DL$INT - RL11 INTERRUPT SERVICE ROUTINE
; 
; FUNCTIONAL DESCRIPTION:
; 
; 	THIS ROUTINE IS ENTERED VIA A JSB INSTRUCTION WHEN AN INTERRUPT
; 	OCCURS ON AN RL11 DISK CONTROLLER. IF THE INTERRUPT IS NOT EXPECTED,
; 	THE UNSOLICITED INTERRUPT ROUTINE DISMISSES THE INTERRUPT. IF 
; 	THE INTERRUPT IS EXPECTED, DEVICE REGISTERS ARE SAVED AND THE
; 	DRIVER IS CALLED AT ITS INTERRUPT RETURN ADDRESS. THE DRIVER FORKS,
; 	CAUSING A RETURN TO THIS ROUTINE, WHICH RESTORES GENERAL REGISTERS 
; 	AND DISMISSES THE INTERRUPT. 
; 
; INPUTS:
; 
; 	00(SP)	- POINTER TO ADDRESS OF THE IDB 
; 	04(SP)	- SAVED R0
; 	08(SP)	- SAVED R1
; 	12(SP)	- SAVED R2
; 	16(SP)	- SAVED R3
; 	20(SP)	- SAVED R4
; 	24(SP)	- SAVED R5
; 	28(SP)	- PC AT THE TIME OF THE INTERRUPT
; 	32(SP)	- PSL AT THE TIME OF THE INTERRUPT
; 
; OUTPUTS:
; 
; 	DEVICE REGISTERS ARE SAVED, IPL IS LOWERED TO FORK LEVEL, THE
; 	INTERRUPT IS DISMISSED, ALL REGISTERS EXCEPT R0-R5 ARE PRESERVED.
;
;--

DL_INT::				;INTERRUPT SERVICE ROUTINE
	MOVL	@(SP)+,R3		;REMOVE ADDRESS OF IDB FROM STACK
	MOVQ	(R3),R4			;GET ADDRESS OF CSR AND UCB
	TSTL	R5			;IS R5 A ZERO
	BEQL	DL_UNSOLNT		;IF EQL NO OWNER
	BBCC	#UCB$V_INT,-		;IF CLR - INTERRUPT NOT EXPECTED
		UCB$W_STS(R5),DL_UNSOLNT  ;...

	CMPB	#CDF_READHEAD,UCB$B_CEX(R5)  ;READ HEADER FUNCTION?
	BNEQ	10$			;IF NEQ - NO
	MOVW	RL_MP(R4),UCB$W_DL_DB(R5)    ;SAVE SECTOR HEADER INFORMATION
	MOVW	RL_MP(R4),UCB$W_DL_DB+2(R5)  ;...
	MOVW	RL_MP(R4),UCB$W_DL_DB+4(R5)  ;...

10$:	MOVAB	RL_CS(R4),R2		;GET ADDRESS OF CONTROL STATUS REGISTER
	MOVAB	UCB$W_DL_CS(R5),R3	;GET ADDRESS OF REGISTER SAVE AREA
	MOVW	(R2)+,(R3)+		;SAVE CONTROL STATUS REGISTER
	MOVW	(R2)+,(R3)+		;SAVE BUFFER ADDRESS REGISTER
	MOVW	(R2)+,(R3)+		;SAVE DISK ADDRESS REGISTER
	MOVW	(R2)+,(R3)+		;SAVE MULTIPURPOSE REGISTER

	MOVQ	UCB$L_FR3(R5),R3	;RESTORE DRIVER CONTEXT
	JSB	@UCB$L_FPC(R5)		;CALL DRIVER AT INTERRUPT RETURN ADDRESS

DL_UNSOLNT:				;UNSOLICITED INTERRUPT
	POPR	#^M<R0,R1,R2,R3,R4,R5>	;RESTORE R0-R5
	REI				;RETURN FROM INTERRUPT
	.PAGE
	.SBTTL	REGISTER DUMP ROUTINE
;++
; 
; DL_REGDUMP - REGISTER DUMP ROUTINE
; 
; FUNCTIONAL DESCRIPTION:
; 
; THIS ROUTINE IS CALLED TO SAVE THE DEVICE REGISTERS AND UBA RESOURCE
; REGISTERS IN A SPECIFIED BUFFER. IT IS CALLED FROM THE DEVICE ERROR
; LOGGING ROUTINE AND FROM THE DIAGNOSTIC BUFFER FILL ROUTINE.
; 
; INPUTS:
; 
; 	R0	- ADDRESS OF REGISTER SAVE BUFFER
; 	R4	- ADDRESS OF DEVICE CONTROL STATUS REGISTER (CSR)
; 	R5	- ADDRESS OF UNIT CONTROL BLOCK (UCB)
; 
; OUTPUTS:
; 
; 	THE DEVICE AND UBA REGISTERS ARE SAVED IN THE SPECIFIED BUFFER.
; 	R0 CONTAINS THE ADDRESS OF THE NEXT EMPTY LONGWORD IN THE BUFFER.
; 	ALL REGISTERS EXCEPT R1 AND R2 ARE PRESERVED.
; 
;--

DL_REGDUMP:				;REGISTER DUMP ROUTINE
	MOVL	#<RL_NUM_REGS+5>,(R0)+	;INSERT NUMBER OF REGISTERS
	MOVAL	UCB$W_DL_CS(R5),R1	;GET ADDRESS OF SAVED DEVICE REGISTERS
	MOVZBL	#RL_NUM_REGS,R2		;GET NUMBER OF DEVICE REGISTERS TO MOVE
10$:	MOVZWL	(R1)+,(R0)+		;DUMP REGISTER IN BUFFER
	SOBGTR	R2,10$			;IF GTR - STILL MORE TO MOVE
	MOVZWL	(R1)+,(R0)+		;DUMP DATAPATH NUMBER
	MOVL	(R1)+,(R0)+		;DUMP DATAPATH REGISTER
	MOVL	(R1)+,(R0)+		;DUMP FINAL MAP REGISTER
	MOVL	(R1)+,(R0)+		;DUMP PREVIOUS MAP REGISTER
	MOVZBL	(R1)+,(R0)+		;DUMP DATAPATH PURGE ERROR REGISTER
	RSB				;RETURN

DL_END:					;ADDRESS OF LAST LOCATION IN DRIVER
	.END
