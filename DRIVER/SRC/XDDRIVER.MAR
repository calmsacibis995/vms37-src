	.TITLE	XDDRIVER - VAX/VMS DMP11 Device Driver
	.IDENT	'V03-018'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;++
; FACILITY:
;
;	VAX/VMS DMP11 Device driver
;
; ABSTRACT:
;
;	This module contains the DMP11 driver FDT routines,
;	interrupt dispatcher, interrupt service and fork routines.
;
; AUTHOR:
;
;	R. GAMACHE	13-JUL-81
;
; MODIFICATION HISTORY:
;
;	V03-018	RNG0018		Rod N. Gamache		01-Apr-1982
;		Adjust JIB quotas if startup failure.
;
;	V03-017	RNG0017		Rod N. Gamache		15-Mar-1982
;		Use executive routine to probe users P2 buffer. Fix problem
;		in setting tributary Select timer.
;
;	V03-016	RNG0016		Rod N. Gamache		10-Feb-1982
;		Use immediate mode on reference to a constant.
;
;	V03-015	RNG0015		Rod N. Gamache		02-Feb-1982
;		Insert packets at end of queue in "generic" insertion routines.
;
;	V03-014	RNG0014		Rod N. Gamache		11-Jan-1982
;		Pop R8 in cancel routine after call to CLEAR_CDB.
;
;	V03-013	RNG0013		Rod N. Gamache		06-Jan-1982
;		Add retransmit timer as line parameter.
;
;	V03-012	RNG0012		Rod N. Gamache		21-Dec-1981
;		Allow for more than 1 trib in trib mode. Save R3 around
;		Allocating non-paged pool. Don't do cancel when circuit
;		has not been established!
;
;	V03-011	RNG0011		Rod N. Gamache		13-Dec-1981
;		Allow P1 characteristic buffer to set MOP mode.
;
;	V03-010	RNG0010		Rod N. Gamache		9-Dec-1981
;		Allow for new CXB header. Set fork process PC after
;		startup timeout. Save controller on master clear error.
;		Set poll state and set number of sync characters.
;
;	V03-009	RNG0009		Rod N. Gamache		4-Nov-1981
;		Fix cancel register problem for matching channel.
;		Fix CHG_UCB to establish trib mode from P1 buffer.
;		Adjust BYTLM in JIB as well as BYTCNT for receive
;		buffer pool.
;		Set Disconnect and threshold error bits as needed.
;
;	V03-008	RNG0008		Rod N. Gamache		27-Oct-1981
;		Return only user buffer size worth of data on read
;		parameters request with small buffer.
;
;	V03-007	RNG0007		Rod N. Gamache		23-Oct-1981
;		Fix byte offset problem on VAX-11/750.
;
;	V03-006	RNG0006		Rod N. Gamache		9-Oct-1981
;		Fix shutdown bug, with receives complete in error.
;
;	V03-005	RNG0005		Rod N. Gamache		7-Oct-1981
;		Fix cancel bug, set fatal bit in fork process.
;
;	V03-004 RNG0004		Rod N. Gamache		22-Sep-1981
;		Add buffer quota scheme for circuit, NMA$C_PCCI_MST.
;
;	V03-001	RNG0001		Rod N. Gamache		1-Sep-1981
;		Add new Network Management parameters.
;
;--

	.SBTTL	External and local symbol definitions

;
; System definitions
;

	$ACBDEF				; AST control block
	$ADPDEF				; Adapter control block
	$CRBDEF				; Channel request block
	$CXBDEF				; Define CXB header
	$DCDEF				; Device classes and types
	$DDBDEF				; Device data block
	$DEVDEF				; Device characteristics
	$DPTDEF				; Driver prologue table defs
	$DYNDEF				; Control block defs
	$IDBDEF				; Interrupt data block
	$IODEF				; I/O function codes
	$IPLDEF				; Hardware IPL definitions
	$IRPDEF				; I/O request packet
	$JIBDEF				; Job information block defs
	$NMADEF				; Network Management definitions
	$PCBDEF				; Process control block
	$SSDEF				; System status codes
	$UBADEF				; UBA definitions
	$UCBDEF				; Unit control block
	$VADEF				; Virtual address defs
	$VECDEF				; Interrupt vector block
	$XMDEF				; XMDRIVER symbols

;
; Local macros
;
	.MACRO	SETBIT	POS,BAS,?L	; Set a single bit
		BBSS	POS,BAS,L
	L:
	.ENDM	SETBIT
 
	.MACRO	CLRBIT	POS,BAS,?L	; Clear a single bit
		BBCC	POS,BAS,L
	L:
	.ENDM	CLRBIT
 
	.MACRO	INCC	COUNTER,CONTEXT=L,?L  ; Increment counter
		INC'CONTEXT	COUNTER	; Do Increment
		BCC	L		; Br if no carry set
		DEC'CONTEXT	COUNTER	; Leave at maximum value
	L:
	.ENDM	INCC
 
	.MACRO	PUSHQ	ARG		; Push a quadword
		MOVQ	ARG,-(SP)	; Save argument on stack
	.ENDM	PUSHQ
 
	.MACRO	POPQ	ARG		; Pop a quadword
		MOVQ	(SP)+,ARG	; Restore argument
	.ENDM	POPQ
 
	.MACRO	PARAM	TYPE,OFFSET,WIDTH,MIN,MAX,INVALID,BASE
;
; Inputs:
;
;	TYPE = Parameter type
;	OFFSET = Offset in UCB/CDB to current value
;	WIDTH = Width of field in UCB/CDB (B,W,L)
;	MIN = Minimum value parameter is allowed to take
;	MAX = Maximum value parameter is allowed to take
;	INVALID = Invalid flags in status word
;	BASE = Data base (LINE,TRIB)
;
	.IF BLANK TYPE
	.WORD	0
	.IF_FALSE
	$$$TYP = TYPE & PRM_M_TYPE		; Isolate type code
	.IIF NOT_BLANK	<MIN>, $$$TYP = $$$TYP!PRM_M_MIN
	.IIF NOT_BLANK	<MAX>, $$$TYP = $$$TYP!PRM_M_MAX
	.IIF NOT_BLANK	<INVALID>, $$$TYP = $$$TYP!PRM_M_INVALID
		.WORD	$$$TYP
	$$$OFF = OFFSET & OFF_M_VALUE		; Isolate offset only
	$$$WID = 0				; Set null width
	.IIF IDN <WIDTH><B>, $$$WID = <1@OFF_V_WIDTH>
	.IIF IDN <WIDTH><W>, $$$WID = <2@OFF_V_WIDTH>
	.IIF IDN <WIDTH><L>, $$$WID = <3@OFF_V_WIDTH>
		.WORD	$$$OFF!$$$WID
	.IIF NOT_BLANK	<MIN>, .WORD	MIN
	.IIF NOT_BLANK	<MAX>, .WORD	MAX
	.IIF NOT_BLANK	<INVALID>, .WORD	INVALID
	'BASE'_PRM_BUFSIZ = 'BASE'_PRM_BUFSIZ + 6
	.ENDC
	.ENDM	PARAM
 
	.MACRO	COUNT	TYPE,BITMAP=NO,WIDTH=8,BASE
	$$$TYP = TYPE & NMA$M_CNT_TYP
	.IIF IDN <BITMAP><YES>, $$$TYP = $$$TYP!<NMA$M_CNT_MAP>
	$$$WID = 0			; Set reserved mask width
	.IIF IDN <WIDTH><8>, $$$WID = <1@NMA$V_CNT_WID>
	.IIF IDN <WIDTH><16>, $$$WID = <2@NMA$V_CNT_WID>
	.IIF IDN <WIDTH><32>, $$$WID = <3@NMA$V_CNT_WID>
	.IIF EQ $$$WID, .ERROR		; Invalid bit width value
	.WORD	NMA$M_CNT_COU!$$$WID!$$$TYP
	'BASE'_CNT_BUFSIZ = 'BASE'_CNT_BUFSIZ + 2 + <WIDTH/8>
	.IIF IDN <BITMAP><YES>, 'BASE'_CNT_BUFSIZ = 'BASE'_CNT_BUFSIZ + 2
	.ENDM	COUNT
 
	.MACRO	SKIP	BIT,LOC,REG,CONTEXT=W,?L	; SKIP FIELD
	BBC	#BIT,LOC,L		; Br if field not present
	TST'CONTEXT	(REG)+		; Skip next field
L:
	.ENDM	SKIP
 
;
; Local symbols
;

;
; $QIO parameter offsets
;
P1	= 0				; Parameter 1
P2	= 4				; Parameter 2
P3	= 8				; Parameter 3
P4	= 12				; Parameter 4
P5	= 16				; Parameter 5

;
; Other constants
;

MAX_RCV = 7				; Maximum number outstanding receives
MAX_XMT = 7				; Maximum number outstanding transmits
INF_RCV = 255				; "Logical" infinite receives (unlimited)
INF_XMT = 127				; "Logical" infinite transmits
 
XD_DEF_BUFSIZ	= 512			; Default buffer size
MAX_TRB		= 32			; Max tributaries on DMP11 device
MAX_XMT_TRB	= 4			; Maximum number of xmits per trib
DSC$A_POINTER   = 4			; Descriptor buffer address field
P1_TRIB_MASK	= XM$M_STS_ACTIVE!-	; Mask of user "read only" bits
		  XM$M_STS_RUNNING!^X<FF> ; in CDB device dependent longword
P1_LINE_MASK	= ^X<FF>		; Mask of user "read only" bits
					; in UCB device dependent longword

;
; Overlays of IRP
;
	$DEFINI	IRP
 
. = IRP$Q_NT_PRVMSK			; Overlay network priv mask
 
$DEF	IRP$Q_STATION	.BLKQ	1	; Tributary station address
 
. = IRP$W_FUNC+1			; Overlay Function word
 
$DEF	IRP$B_XDFUNC	.BLKB	1	; DMP driver internal function code
 
. = IRP$Q_STATION+1			; Overlay Station address
 
$DEF	IRP$B_INDEX	.BLKB	1	; Vector index for CDB
 
. = IRP$Q_STATION+2			; Overlay Station address
 
$DEF	IRP$W_QUOTA	.BLKW	1	; Number of recieve buffers
 
. = IRP$Q_STATION+4			; Overlay ditto
 
$DEF	IRP$L_CDB	.BLKL	1	; CDB address
 
. = IRP$Q_STATION+2			; Overlay ditto
 
$DEF	IRP$W_CSTATUS	.BLKW	1	; Completion status
 
;
; Define driver internal function codes stored in IRP$B_XDFUNC of IRP.
; NOTE: These are not really used as bit offsets - but as values.
;
	_VIELD	XD_FC,0,<-		; Internal function codes
		<INITT>,-		; Establish tributary
		<INITC>,-		; Init the device
		<STOPT>,-		; Shutdown tributary
		<STOPC>,-		; Shutdown controller (device)
		<CHGC>,-		; Change controller characteristics
		<CHGT>,-		; Change trib characteristics
		<RDMODEM>,-		; Read line unit modem register
		<RDTERR>,-		; Read tributary error counters
		<RDGERR>,-		; Read global error counters
		<RCTERR>,-		; Read trib counters and clear
		<RCGERR>,-		; Read global counters and clear
		<RDTSS>,-		; Read tributary status slot
		<RDGSS>,-		; Read global status slot
		<WTMODEM>,-		; Write line unit modem register
		<HALTT>,-		; CANCEL request to halt trib
		<KILLT>,-		; CANCEL request to kill trib
		<XMIT>,-		; Transmit request
		<RECV>,-		; Receive request
		<CANCEL>,-		; Cancel request - halt trib
		<NUMSYNC>,-		; Set number of sync chars
		<POLSTAT>,-		; Latch polling state
		>			;

	$DEFEND	IRP			; End of IRP overlays

;
; Definitions that follow the standard UCB fields
;

	$DEFINI	UCB			; Start of UCB definitions

. = UCB$L_FR3				; Position at R3 of fork block
 
$DEF	UCB$L_XD_SEL0	.BLKL	1	; Saved SEL0 and SEL2 from interrupt
$DEF	UCB$L_XD_SEL4	.BLKL	1	; Saved SEL4 and SEL6 from interrupt
 
. = UCB$C_LENGTH			; Position at end of UCB

$DEF	UCB$Q_XD_QUEUES			; Message and I/O request queue heads
$DEF	UCB$Q_XD_INPUTQ	 .BLKQ	1	; Request awaiting input port
$DEF	UCB$Q_XD_XMT_REQ .BLKQ	1	; Transmit I/O requests waiting mapping
$DEF	UCB$Q_XD_RCV_PND .BLKQ	1	; Receive buffers given to device
$DEF	UCB$Q_XD_INFOUT	 .BLKQ	1	; Information Out queue
$DEF	UCB$Q_XD_POST	 .BLKQ	1	; Requests awaiting posting
$DEF	UCB$Q_XD_RCV_BUF .BLKQ	1	; Free receive buffers (lookaside list)
UCB$C_XD_QUEUES = <.-UCB$Q_XD_QUEUES>/8	; Number of queue heads
 
$DEF	UCB$L_XD_RCV_MAP .BLKL	MAX_RCV	; Receive mapping vector
$DEF	UCB$L_XD_XMT_MAP .BLKL	MAX_XMT ; Transmit mapping vector
$DEF	UCB$B_XD_RCV_MAP .BLKB	1	; Receive mapping in use flags
$DEF	UCB$B_XD_XMT_MAP .BLKB	1	; Transmit mapping in use flags
$DEF	UCB$B_XD_RCV_MAX .BLKB	1	; Maximum concurrent receives
$DEF	UCB$B_XD_XMT_MAX .BLKB	1	; Maximum concurrent transmits
$DEF	UCB$B_XD_TRB_CNT .BLKB	1	; Number of active tributaries
$DEF	UCB$B_XD_XMT_TRB .BLKB	1	; Maximum number of xmits per trib
$DEF	UCB$W_XD_QUOTA	 .BLKW	1	; Receive buffer quota
 
$DEF	UCB$L_XD_VECS			; Start of vector areas
$DEF	UCB$B_XD_TRIB_VEC .BLKB	MAX_TRB	; Tributary address vector
$DEF	UCB$L_XD_PID_VEC .BLKL	MAX_TRB ; PID Lookup vector
$DEF	UCB$W_XD_CHAN_VEC .BLKW MAX_TRB ; Channel number lookup vector
$DEF	UCB$L_XD_CDB_VEC .BLKL	MAX_TRB	; CDB address vector
UCB$C_XD_VECS = <.-UCB$L_XD_VECS>/4 	; Number of longwords in vectors
 
$DEF	UCB$L_XD_RUN	 .BLKL	1	; Tribs that entered Run state
$DEF	UCB$L_XD_HALT	 .BLKL	1	; Tribs that were forced to halt
$DEF	UCB$L_XD_PID	 .BLKL	1	; Starter's PID
$DEF	UCB$B_XD_MODE	 .BLKB	1	; Mode of operation in DMP11 format
$DEF	UCB$B_XD_INTIM	 .BLKB	1	; Input wait timer
$DEF	UCB$B_XD_OUTTIM	 .BLKB	1	; Output wait timer

$DEF	UCB$B_XD_SETPRM			; Start of parameter section
$DEF	UCB$B_XD_NMS	 .BLKB	1	; Number of sync chars (0=>default)
$DEF	UCB$B_XD_PRO	 .BLKB	1	; Protocol selection
$DEF	UCB$B_XD_DUP	 .BLKB	1	; Duplex mode
$DEF	UCB$B_XD_CON	 .BLKB	1	; Controller mode
$DEF	UCB$B_XD_BFN	 .BLKB	1	; Number of receive buffers
 
$DEF	UCB$W_XD_POLLPRM		; Start of polling parameter section
$DEF	UCB$W_XD_SRT	 .BLKW	1	; Streaming tributary timer
$DEF	UCB$W_XD_SLT	 .BLKW	1	; Delta timer
$DEF	UCB$W_XD_DDT	 .BLKW	1	; Dead timer
$DEF	UCB$W_XD_DLT	 .BLKW	1	; Poll delay time
$DEF	UCB$W_XD_RTT	 .BLKW	1	; Retransmit timer
UCB$C_XD_SETPRM = .-UCB$B_XD_SETPRM	; Size of parameter section
 
$DEF	UCB$C_XD_LENGTH			; Size of XDDRIVER UCB
 
;
; Define device status bits
;
	$VIELD	UCB,0,<-		; XDDRIVER UCB$W_DEVSTS bits
		<XD_INITED,,M>,-	; Device is initialized
		<XD_INITING,,M>,-	; Device is initing - waiting for Timeout
		<XD_PTP,,M>,-		; Device in point to point operation
		<XD_FORK_PEND,,M>,-	; Fork process scheduling in progress
		<XD_DTRCLR,,M>,-	; DTR modem signal is cleared
		>			;

	$DEFEND	UCB			; End of UCB definitions

;
; Device register offsets and bit definitions
;

	$DEFINI	XD			; Start of status definitions


$DEF	SEL0				; 1st word of CSR
$DEF	BSEL0				; Byte select 0 / Control & status
			.BLKB	1

;
; Bit positions for device control/status register
;

	_VIELD	XD_BSEL0,0,<-		; Control & status bits
	<IEI,,M>,-			; Input interrupt enable
	<,3>,-				;
	<IEO,,M>,-			; Output interrupt enable
	<,2>,-				;
	<RQI,,M>,-			; Request input
	>

$DEF	BSEL1				; Byte select 1 / Control & status
			.BLKB	1

	_VIELD  XD_BSEL1,0,<-		; Control & status bits
	<,3>,-				;
	<LOOPB,,M>,-			; Loop back
	<,2>,-				;
	<MCLR,,M>,-			; Master clear
	<RUN,,M>,-			; RUN state
	>

$DEF	SEL2				; 2nd word of CSR
$DEF	BSEL2				; Byte select 2 / Command register
			.BLKB	1

	_VIELD  XD_BSEL2,0,<-		; Command register fields
	<TYPE,3,M>,-			; Command type code
	<,1>,-				;
	<RDI,,M>,-			; Ready input
	<ERR,,M>,-			; ** DRIVER DEFINED error indicator **
	<,1>,-				;
	<RDO,,M>,-			; Ready output
	>
 
	_VIELD	XD_I,0,<-		; Define input command codes
	<RCV>,-				; Receive in 	  - 0
	<CONTROL>,-			; Control in 	  - 1
	<MODE_DEF>,-			; Mode definition - 2
	<,1>,-				; RESERVED
	<XMIT>,-			; Xmit in	  - 4
	>

$DEF	BSEL3		.BLKB	1	; Byte select 3 / Tributary address

$DEF	SEL4				; 3rd word of CSR
$DEF	BSEL4		.BLKB	1	; Byte select 4 / Misc.

$DEF	BSEL5		.BLKB	1	; Byte select 5 / Misc.

$DEF	SEL6				; 4th word of CSR
$DEF	BSEL6		.BLKB	1	; TSS/GSS read/write requests

	_VIELD XD_SEL6,0,<-		; TSS/GSS control register
	<,5>,-				;
	<RTSS,,M>,-			; Read TSS
	<RCTS,,M>,-			; Read/clear TSS
	<WTSS,,M>,-			; Write TSS
	<ECOM,,M>,-			; Enable common pool
	<DCOM,,M>,-			; Disable common pool
	<,2>,-				;
	<UPOL,,M>,-			; Unlatch polling
	<LPOL,,M>,-			; Latch polling
	<,2>,-				;
	>
 
	_VIELD	XD_CI,0,<-		; SEL6 command codes
	<NOOP>,-			; NOOP request
	<ESTAB>,-			; Establish tributary
	<KILL>,-			; Kill tributary
	<ISTRT>,-			; Start tributary
	<MAINT>,-			; Start trib in MOP mode
	<HALT>,-			; Halt tributary
	<,10>,-				; RESERVED
	<RDMODEM>,-			; Read Modem request
	<WTMODEM>,-			; Write Modem request
	<INTDIAG>-			; Interface diagnostics
	>

$DEF	BSEL7				; Byte select 7 / Misc.
			.BLKB	1
	$DEFEND	XD			; End of device register definitions

;
; XDDRIVER CDB definitions
;
	$DEFINI	CDB
.=0
$DEF	CDB_L_DEVDEPEND	.BLKL	1	; Circuit dependent status
$DEF	CDB_L_AST	.BLKL	1	; Attention AST list
$DEF	CDB_W_SIZE	.BLKW	1	; Size of CDB
$DEF	CDB_B_TYPE	.BLKB	1	; Type of structure
$DEF	CDB_B_POL	.BLKB	1	; Polling state
$DEF	CDB_W_STS	.BLKW	1	; Circuit status
$DEF	CDB_B_TRB_ADDR	.BLKB	1	; Tributary address
$DEF	CDB_B_XMT_CNT	.BLKB	1	; Number of xmits outstanding

$DEF	CDB_Q_QUEUES			; Message and I/O request queue heads
$DEF	CDB_Q_XMT_REQ	.BLKQ	1	; Transmit requests awaiting RUN
$DEF	CDB_Q_RCV_REQ	.BLKQ	1	; Receive I/O requests awaiting message
$DEF	CDB_Q_RCV_MSG	.BLKQ	1	; Receive buffers containing messages
$DEF	CDB_Q_XMT_PND	.BLKQ	1	; Transmit I/Os given to device
$DEF	CDB_Q_INFOUT	.BLKQ	1	; Information Out queue
CDB_C_QUEUES = <.-CDB_Q_QUEUES>/8	; Number of queue heads in CDB

$DEF	CDB_L_CNTS			; Start of counters area of CDB
$DEF	CDB_L_BRC	.BLKL	1	; Receive byte count
$DEF	CDB_L_BSN	.BLKL	1	; Transmit byte count
$DEF	CDB_L_DMR	.BLKL	1	; Receive message count
$DEF	CDB_L_DMS	.BLKL	1	; Transmit message count
CDB_C_CNTS = .-CDB_L_CNTS		; Size of counter section of CDB
 
$DEF	CDB_L_PID	.BLKL	1	; Starter's process ID
$DEF	CDB_W_CHAN	.BLKW	1	; Channel number associated with this CDB

$DEF	CDB_B_SETPRM			; Start of settable parameters
$DEF	CDB_B_MRB	.BLKB	1	; Receive buffer count
$DEF	CDB_B_MST	.BLKB	1	; Maintenance State given by P2 buffer

$DEF	CDB_W_POLLPRM			; Start of Poll parameter section of CDB
$DEF	CDB_W_DEL_TIMER	.BLKW	1	; Delay timer
$DEF	CDB_B_POL_QACT	.BLKB	1	; Active trib Q value
$DEF	CDB_B_POL_RACT	.BLKB	1	; Active trib R value
$DEF	CDB_B_POL_QIN	.BLKB	1	; Inactive trib Q value
$DEF	CDB_B_POL_RIN	.BLKB	1	; Inactive triv R value
$DEF	CDB_B_POL_QDYI	.BLKB	1	; Dying Q value
$DEF	CDB_B_POL_RDYI	.BLKB	1	; Dying R value
$DEF	CDB_B_TO_INACT	.BLKB	1	; Number of NDM to Inactive
$DEF	CDB_B_TO_DYING	.BLKB	1	; Number of no responses to Dying
$DEF	CDB_B_TO_DEAD	.BLKB	1	; Number of no responses to Dead
$DEF	CDB_B_MAX_MSGS	.BLKB	1	; Maximum number of xmits per selection
$DEF	CDB_W_SEL_TIMER	.BLKW	1	; Selection timer
$DEF	CDB_W_BAB_TIMER	.BLKW	1	; Babbling trib timer
CDB_C_SETPRM = .-CDB_B_SETPRM		; Size of settable param section of CDB
 
$DEF	CDB_C_LENGTH			; Size of XDDRIVER CDB

;
; Define status bits used in CDB_B_STS
;
 
	_VIELD	CD_TS,0,<-		; Tributary status bits for CDB_W_STS
		<ESTAB,,M>,-		; Tributary established
		<MOP,,M>,-		; Tributary is in MOP mode
		<CANCEL,,M>,-		; Cancel I/O in progress
		<BUFRET,,M>,-		; Buffers have been returned
		<BUFQUO,,M>,-		; Buffer quota management needed
		>			;

	$DEFEND	CDB

;
; Receive buffer definition
;
	$DEFINI	RCV
.=0
$DEF	RCV_L_LINK	.BLKL	2	; Forward and backward queue links
$DEF	RCV_W_BLKSIZE	.BLKW	1	; Total block size
$DEF	RCV_B_BLKTYPE	.BLKB	1	; Block type
$DEF	RCV_B_MAPSLOT	.BLKB	1	; Mapping slot number
$DEF	RCV_L_BACC	.BLKL	1	; Buffer address / character count
	.IIF LT .-CXB$C_HEADER, .=CXB$C_HEADER ; (allow for CXB header)
$DEF	RCV_T_DATA			; Receive data
 
	$DEFEND	RCV

;
; P2 buffer header definition
;
	$DEFINI	P2B
.=0
$DEF	P2B_L_POINTER	.BLKL	1	; Pointer to start of data
$DEF	P2B_L_BUFFER	.BLKL	1	; Address of user's data buffer
$DEF	P2B_W_SIZE	.BLKW	1	; Size of P2 buffer
$DEF	P2B_B_TYPE	.BLKB	1	; Type of structure
$DEF	P2B_B_SPARE	.BLKB	1	; Spare byte
$DEF	P2B_C_LENGTH			; Size of P2 buffer header
$DEF	P2B_T_DATA			; Start of data
 
	$DEFEND	P2B

	.SBTTL	Standard tables

;
; Driver prologue table
;

	DPTAB	-				; DPT-creation macro
		END=XD_END,-			; End of driver label
		ADAPTER=UBA,-			; Adapter type
		UCBSIZE=<UCB$C_XD_LENGTH>,-	; Length of UCB
		NAME=XDDRIVER,-			; Driver name
 
	DPT_STORE INIT				; Start of load
						; initialization table
	DPT_STORE UCB,UCB$B_FIPL,B,8		; Device fork IPL
	DPT_STORE UCB,UCB$B_DIPL,B,22		; Device interrupt IPL
	DPT_STORE UCB,UCB$L_DEVCHAR,L,<-	; Device characteristics:
		DEV$M_NET!-			;   network device
		DEV$M_SHR!-			;   shared device
		DEV$M_IDV!-			;   input device
		DEV$M_ODV>			;   output device
	DPT_STORE UCB,UCB$B_DEVCLASS,B,DC$_SCOM	; Device class - synch comm
	DPT_STORE UCB,UCB$B_DEVTYPE,B,DT$_DMP11	; Device type
 
	DPT_STORE REINIT			; Start of reload
						; initialization table
	DPT_STORE DDB,DDB$L_DDT,D,XD$DDT	; Address of DDT
	DPT_STORE CRB,-				; Address of device
		CRB$L_INTD+VEC$L_UNITINIT,-	; unit initialization
		D,UNIT_INIT			; routine
	DPT_STORE CRB,-				; Address of CSR RDI
		CRB$L_INTD+4,D,RDI_INTRPT	; interrupt routine
	DPT_STORE CRB,-				; Address of CSR RDO
		CRB$L_INTD2+4,D,RDO_INTRPT	; interrupt routine
	DPT_STORE UCB,UCB$L_FPC,D,TIMEOUT	; Set up timeout vector

	DPT_STORE END				; End of initialization
						; tables

;
; Driver dispatch table
;

	DDTAB	-				; DDT-creation macro
		DEVNAM=XD,-			; Name of device
		START=STARTIO,-			; Start I/O routine
		FUNCTB=XD_FUNCTABLE,-		; FDT address
		CANCEL=CANCEL,-			; Cancel I/O routine
		REGDMP=REG_DUMP,-		; Register dump routine
		DIAGBF=<36+12>,-		; Diagnostic buffer sizing
		ALTSTART=ALT_START		; Alternate start I/O

;
; Function dispatch table
;

XD_FUNCTABLE:					; FDT for driver
	FUNCTAB	,-				; Valid I/O functions
		<READVBLK,-			; Read virtual
		READLBLK,-			; Read logical
		READPBLK,-			; Read physical
		WRITEVBLK,-			; Write virtual
		WRITELBLK,-			; Write logical
		WRITEPBLK,-			; Write physical
		SETMODE,-			; Set device mode
		SENSEMODE,-			; Sense mode
		SETCHAR>			; Set device chars.
	FUNCTAB	,-				; Buffered functions:
		<READVBLK,-			; Read virtual
		READLBLK,-			; Read logical
		READPBLK,-			; Read physical
		SETMODE,-			; Set mode
		SENSEMODE,-			; Sense mode
		SETCHAR>			; Set char
	FUNCTAB	RCV_FDT,-			; FDT read routine for
		<READVBLK,-			; read virtual,
		READLBLK,-			; read logical,
		READPBLK>			; and read physical.
	FUNCTAB	XMT_FDT,-			; FDT write routine for
		<WRITEVBLK,-			; write virtual,
		WRITELBLK,-			; write logical,
		WRITEPBLK>			; and write physical.
	FUNCTAB	SETMODE_FDT,-			; FDT set mode routine
		<SETMODE,SETCHAR>		; for set mode, set char.
	FUNCTAB SENSEMODE_FDT,-			; FDT sense mode routine
		<SENSEMODE>			; for sensemode 

	.SBTTL	P2 buffer verification tables
 
;
; Define P2 buffer verification offsets
;
	$DEFINI	PARAM
 
	_VIELD	PRM,0,<-			; Parameter bits and sizes
		<TYPE,12,M>,-			; Parameter type
		<MIN,1,M>,-			; Parameter minimum value
		<MAX,1,M>,-			; Parameter maximum value
		<INVALID,1,M>,-			; Parameter invalid flags
		>
 
	_VIELD	OFF,0,<-			; Offset word fields
		<VALUE,14,M>,-			; Offset value
		<WIDTH,2,M>,-			; Size of field in structure
		>
 
	$DEFEND	PARAM
 
;
; Define UCB parameters
;
LINE_PRM_BUFSIZ	= 0				; Line parameter buffer size
LINE_PARAM:					; Start of line parameters

	PARAM	NMA$C_PCLI_PRO,-		; Protocol selection
		OFFSET=UCB$B_XD_PRO,WIDTH=B,-
		MAX=NMA$C_LINPR_DMC,-
		INVALID=UCB$M_XD_INITED,-	; Device can't be ON
		BASE=LINE
 
	PARAM	NMA$C_PCLI_DUP,-		; Duplex mode
		OFFSET=UCB$B_XD_DUP,WIDTH=B,-
		MAX=NMA$C_DPX_HAL,-
		INVALID=UCB$M_XD_INITED,-	; Device can't be ON
		BASE=LINE

	PARAM	NMA$C_PCLI_CON,-		; Conroller mode
		OFFSET=UCB$B_XD_CON,WIDTH=B,-
		MAX=NMA$C_LINCN_LOO,-
		INVALID=UCB$M_XD_INITED,-	; Device can't be ON
		BASE=LINE
 
	PARAM	NMA$C_PCLI_BFN,-		; Number of receives
		OFFSET=UCB$B_XD_BFN,WIDTH=B,-
		MIN=1,MAX=255,-
		INVALID=UCB$M_XD_INITED,-	; Device can't be ON
		BASE=LINE
 
	PARAM	NMA$C_PCLI_BUS,-		; Buffer size
		OFFSET=UCB$W_DEVBUFSIZ,WIDTH=W,-
		MIN=1,MAX=16383,-
		INVALID=UCB$M_XD_INITED,-	; Device can't be ON
		BASE=LINE
 
	PARAM	NMA$C_PCLI_SLT,-		; Delta timer
		OFFSET=UCB$W_XD_SLT,WIDTH=W,-
		MIN=50,-
		BASE=LINE
 
	PARAM	NMA$C_PCLI_DDT,-		; Dead timer
		OFFSET=UCB$W_XD_DDT,WIDTH=W,-
		MIN=50,-
		BASE=LINE
 
	PARAM	NMA$C_PCLI_DLT,-		; Delay timer
		OFFSET=UCB$W_XD_DLT,WIDTH=W,-
		BASE=LINE
 
	PARAM	NMA$C_PCLI_SRT,-		; Streaming trib timer
		OFFSET=UCB$W_XD_SRT,WIDTH=W,-
		MIN=50,-
		BASE=LINE

	PARAM	NMA$C_PCLI_NMS,-		; Number of sync chars
		OFFSET=UCB$B_XD_NMS,WIDTH=B,-
		MIN=8,MAX=255,-
		BASE=LINE

	PARAM	NMA$C_PCLI_RTT,-		; Retransmit timer
		OFFSET=UCB$W_XD_RTT,WIDTH=W,-
		MIN=50,-
		BASE=LINE

	PARAM					; End of table
;
; Define CDB parameters
;
TRIB_PRM_BUFSIZ  = 0				; Trib parameter buffer size
TRIB_PARAM:					; Start of trib parameters
 
	PARAM	NMA$C_PCCI_TRI,-		; Trib address
		OFFSET=CDB_B_TRB_ADDR,WIDTH=B,-
		MIN=1,-
		INVALID=XM$M_STS_ACTIVE,-	; Trib can't be established
		BASE=TRIB
 
	PARAM	NMA$C_PCCI_MRB,-		; Maximum receive buffers
		OFFSET=CDB_B_MRB,WIDTH=B,-
		MIN=1,-
		INVALID=XM$M_STS_ACTIVE,-	; Trib can't be STARTING
		BASE=TRIB

	ASSUME	NMA$C_STATE_ON EQ 0
	PARAM	NMA$C_PCCI_MST,-		; Maintenance state
		OFFSET=CDB_B_MST,WIDTH=B,-
		MAX=NMA$C_STATE_OFF,-
		BASE=TRIB
 
	PARAM	NMA$C_PCCI_POL,-		; Latch polling state
		OFFSET=CDB_B_POL,WIDTH=B,-
		MAX=NMA$C_CIRPST_DED,-
		BASE=TRIB
 
	PARAM	NMA$C_PCCI_TRT,-		; Transmit delay timer
		OFFSET=CDB_W_DEL_TIMER,WIDTH=W,-
		BASE=TRIB
 
	PARAM	NMA$C_PCCI_ACB,-		; Active base
		OFFSET=CDB_B_POL_QACT,WIDTH=B,-
		BASE=TRIB
 
	PARAM	NMA$C_PCCI_ACI,-		; Active increment
		OFFSET=CDB_B_POL_RACT,WIDTH=B,-
		BASE=TRIB
 
	PARAM	NMA$C_PCCI_IAB,-		; Inactive base
		OFFSET=CDB_B_POL_QIN,WIDTH=B,-
		BASE=TRIB
 
	PARAM	NMA$C_PCCI_IAI,-		; Inactive increment
		OFFSET=CDB_B_POL_RIN,WIDTH=B,-
		BASE=TRIB
 
	PARAM	NMA$C_PCCI_DYB,-		; Dying base
		OFFSET=CDB_B_POL_QDYI,WIDTH=B,-
		BASE=TRIB
 
	PARAM	NMA$C_PCCI_DYI,-		; Dying increment
		OFFSET=CDB_B_POL_RDYI,WIDTH=B,-
		BASE=TRIB
 
	PARAM	NMA$C_PCCI_IAT,-		; Inactive threshold
		OFFSET=CDB_B_TO_INACT,WIDTH=B,-
		BASE=TRIB
 
	PARAM	NMA$C_PCCI_DYT,-		; Dying threshold
		OFFSET=CDB_B_TO_DYING,WIDTH=B,-
		BASE=TRIB
 
	PARAM	NMA$C_PCCI_DTH,-		; Dead threshold
		OFFSET=CDB_B_TO_DEAD,WIDTH=B,-
		BASE=TRIB
 
	PARAM	NMA$C_PCCI_MTR,-		; Max abutted xmits
		OFFSET=CDB_B_MAX_MSGS,WIDTH=B,-
		MIN=1,-
		MAX=100,-
		BASE=TRIB
 
	PARAM	NMA$C_PCCI_BBT,-		; Babbling trib timer
		OFFSET=CDB_W_BAB_TIMER,WIDTH=W,-
		MIN=50,-
		BASE=TRIB
 
	PARAM	NMA$C_PCCI_RTT,-		; Selection timer
		OFFSET=CDB_W_SEL_TIMER,WIDTH=W,-
		MIN=50,-
		BASE=TRIB
 
	PARAM					; End of trib tables
;
; DEFAULT TRIBUTARY PARAMETERS
;
DEF_TRIB_PARAM::
	ASSUME	CDB_B_MRB EQ CDB_B_SETPRM
	ASSUME	CDB_B_MST EQ CDB_B_MRB+1
	ASSUME	CDB_W_DEL_TIMER EQ CDB_B_MST+1
	ASSUME	CDB_B_POL_QACT EQ CDB_W_DEL_TIMER+2
	ASSUME	CDB_B_POL_RACT EQ CDB_B_POL_QACT+1
	ASSUME	CDB_B_POL_QIN EQ CDB_B_POL_RACT+1
	ASSUME	CDB_B_POL_RIN EQ CDB_B_POL_QIN+1
	ASSUME	CDB_B_POL_QDYI EQ CDB_B_POL_RIN+1
	ASSUME	CDB_B_POL_RDYI EQ CDB_B_POL_QDYI+1
	ASSUME	CDB_B_TO_INACT EQ CDB_B_POL_RDYI+1
	ASSUME	CDB_B_TO_DYING EQ CDB_B_TO_INACT+1
	ASSUME	CDB_B_TO_DEAD EQ CDB_B_TO_DYING+1
	ASSUME	CDB_B_MAX_MSGS EQ CDB_B_TO_DEAD+1
	ASSUME	CDB_W_SEL_TIMER EQ CDB_B_MAX_MSGS+1
	ASSUME	CDB_W_BAB_TIMER EQ CDB_W_SEL_TIMER+2
	.BYTE	INF_RCV				; Default # of receive buffers
	.BYTE	NMA$C_STATE_OFF			; Default maint state is OFF
	.WORD	0				; Transmit delay timer
	.BYTE	255				; Q for active
	.BYTE	0				; R for active
	.BYTE	0				; Q for inactive
	.BYTE	64				; R for inactive
	.BYTE	0				; Q for dying
	.BYTE	16				; R for dying
	.BYTE	8				; Inactive threshold
	.BYTE	2				; Dying threshold
	.BYTE	16				; Dead threshold
	.BYTE	4				; Maximum abutted messages
	.WORD	3000				; Selection timer (dummy entry)
	.WORD	6000				; Babble timer in Msec
	DEF_TRIB_PARAMSZ = .-DEF_TRIB_PARAM
	ASSUME	CDB_C_SETPRM EQ DEF_TRIB_PARAMSZ
;
; Default line parameter values
;
DEF_LINE_PARAM::
	ASSUME	UCB$B_XD_NMS EQ UCB$B_XD_SETPRM
	ASSUME	UCB$B_XD_PRO EQ UCB$B_XD_NMS+1
	ASSUME	UCB$B_XD_DUP EQ UCB$B_XD_PRO+1
	ASSUME	UCB$B_XD_CON EQ UCB$B_XD_DUP+1
	ASSUME	UCB$B_XD_BFN EQ UCB$B_XD_CON+1
	ASSUME	UCB$W_XD_SRT EQ UCB$B_XD_BFN+1
	ASSUME	UCB$W_XD_SLT EQ UCB$W_XD_SRT+2
	ASSUME	UCB$W_XD_DDT EQ UCB$W_XD_SLT+2
	ASSUME	UCB$W_XD_DLT EQ UCB$W_XD_DDT+2
	ASSUME	UCB$W_XD_RTT EQ UCB$W_XD_DLT+2
	.BYTE	0				; Number of sync chars (default)
	.BYTE	NMA$C_LINPR_POI			; Protocol is point-point
	.BYTE	NMA$C_DPX_FUL			; Duplex is full
	.BYTE	NMA$C_LINCN_NOR			; Controller mode is normal
	.BYTE	0				; Number of receive buffers
	.WORD	6000				; Streaming trib timer in Msec
	.WORD	50				; Delta timer in Msec
	.WORD	10000				; Dead timer
	.WORD	0				; Poll delay timer in Msec
	.WORD	3000				; Selection timer in Msec
	DEF_LINE_PARAMSZ = .-DEF_LINE_PARAM
	ASSUME	UCB$C_XD_SETPRM EQ DEF_LINE_PARAMSZ
;
; Line counter type codes
;
LINE_CNT_BUFSIZ = 0				; Size of ctrl counter buffer
LINE_COUNTER:
	COUNT	NMA$C_CTLIN_RPE,-		; Remote process errors
		BITMAP=YES,WIDTH=8,BASE=LINE
 
	COUNT	NMA$C_CTLIN_LPE,-		; Local process errors
		BITMAP=YES,WIDTH=8,BASE=LINE
 
;
; Tributary counter type codes
;
; NOTE: The first set of trib counters are kept by the driver, since
; the device only keeps 16 bit counters for these counters.
;
TRIB_CNT_BUFSIZ	= 0				; Size of return buffer for trib counts
TRIB_COUNTER:
	COUNT	NMA$C_CTCIR_BRC,-		; Bytes received
		WIDTH=32,BASE=TRIB
 
	COUNT	NMA$C_CTCIR_BSN,-		; Bytes sent
		WIDTH=32,BASE=TRIB
 
	COUNT	NMA$C_CTCIR_DBR,-		; Data blocks received
		WIDTH=32,BASE=TRIB
 
	COUNT	NMA$C_CTCIR_DBS,-		; Data blocks sent
		WIDTH=32,BASE=TRIB

TRIB_COUNTER1:
	COUNT	NMA$C_CTCIR_SIE,-		; Selection intervals elapsed
		WIDTH=16,BASE=TRIB
 
	COUNT	NMA$C_CTCIR_DEO,-		; Data errors outbound
		BITMAP=YES,WIDTH=8,BASE=TRIB
 
	COUNT	NMA$C_CTCIR_DEI,-		; Data errors inbound
		BITMAP=YES,WIDTH=8,BASE=TRIB
 
	COUNT	NMA$C_CTCIR_LBE,-		; Local buffer errors
		BITMAP=YES,WIDTH=8,BASE=TRIB
 
	COUNT	NMA$C_CTCIR_RBE,-		; Remote buffer errors
		BITMAP=YES,WIDTH=8,BASE=TRIB
 
	COUNT	NMA$C_CTCIR_SLT,-		; Selection timeouts
		BITMAP=YES,WIDTH=8,BASE=TRIB
 
	COUNT	NMA$C_CTCIR_LRT,-		; Local reply timeouts
		WIDTH=8,BASE=TRIB
 
	COUNT	NMA$C_CTCIR_RRT,-		; Remote reply timeouts
		WIDTH=8,BASE=TRIB

	.SBTTL	UNIT_INIT,  Unit initialization routine

;++
; UNIT_INIT - Readies unit for I/O operations
;
; Functional description:
;
;	The operating system calls this routine after calling the
;	controller initialization routine:
;
;		at system startup
;		during driver loading
;		during recovery from a power failure
;
;	The unit is put online.  If power has failed, the unit will
;	be forced to timeout.
;
; Inputs:
;
;	R4 = CSR address
;	R5 = UCB address
;
; Outputs:
;
;	R0 destroyed
;
;--

UNIT_INIT:					; Initialize unit
	PUSHR	#^M<R0,R1,R2,R3,R4>		; Save all registers
	BISW	#UCB$M_ONLINE,UCB$W_STS(R5)	; Set unit online
	BSBW	INIT_UCB			; Initialize the UCB
	BBC	#UCB$V_POWER,UCB$W_STS(R5),10$	; Branch if not powerfail
	BBC	#UCB$V_XD_INITED,-		; Br if not inited
		UCB$W_DEVSTS(R5),10$		; 
	MOVB	#XD_BSEL1_M_MCLR,BSEL1(R3)	; Master clear the device
	ASHL	#XD_BSEL2_V_ERR+16,#1,R3	; Indicate error
	ASHL	#16,#1,R4			; Indicate powerfail
	BSBW	SCHED_FORK			; Schedule fork process
10$:	POPR	#^M<R0,R1,R2,R3,R4>		; Restore registers
	RSB					; Return

	.SBTTL	XMT_FDT,  Transmit I/O Operation FDT Routine

;++
; XMT_FDT - Transmit I/O Operation FDT Routine
;
; Functional description:
;
; This routine is called by the SYS$QIO system service to dispatch a
; WRITE I/O request.
;
; The QIO parameters for WRITEs are:
;
;	P1 = address of the buffer
;	P2 = size of the buffer
;	All other parameters are unused.
;
; The buffer is validated for access and locked into memory. The I/O operation
; is started if possible else it is blocked temporarily on one of the various
; wait queues of the UCB or CDB.
;
;
; Inputs:
;
;	R3 = IRP address (I/O request packet)
;	R4 = PCB address (process control block)
;	R5 = UCB address (unit control block)
;	R6 = CCB address (channel control block)
;	R7 = bit number of the I/O function code
;
; Outputs:
;
;	R0 = status of transmit request initiation
;
;	R3-R7 are preserved.
;
;--

XMT_FDT:					; Transmit FDT routine
	CLRQ	IRP$Q_STATION(R3)		; Clear trib address field
	MOVZWL	S^#SS$_BADPARAM,R0		; Assume bad parameters
	MOVZWL	P2(AP),R1			; Get buffer size
	BEQL	ABORTIO				; Br if zero - abort I/O
	CMPW	R1,UCB$W_DEVBUFSIZ(R5)		; Is buffer too big?
	BGTRU	ABORTIO				; Br if yes - abort I/O
	MOVL	P1(AP),R0			; Get user buffer virtual address
	JSB	G^EXE$WRITELOCK			; Check access and lock pages
						; (no return means no acess)
	BSBW	XLATE				; Get CDB address
	BLBC	R0,ABORTIO			; Br if error
	SETIPL	UCB$B_FIPL(R5)			; Sync acces to UCB
	BSBB	XMT_START			; Start transmit operation
	BLBC	R0,ABORTIO			; Br if error
	JMP	G^EXE$QIORETURN			; Exit QIO service to await completion
 
ABORTIO:					; Abort the I/O request
	JMP	G^EXE$ABORTIO			; and exit QIO service

	.SBTTL	XMT_START,  Start Transmit Operation
 
;++
; XMT_START - Start Transmit Operation
;
; Functional description:
;
; This routine is called to start a transmit operation. If the tributary
; is running and there are not too many transmit requests already pending,
; then the request is given to the device to transmit immediately if possible.
; If there are no more mapping register slots available, or a UNIBUS mapping
; register set cannot be allocated then the request is queued to the UCB xmit
; wait queue.
;
; If the circuit is not running yet or the circuit has too many requests
; pending, then the request is queued to the CDB xmit wait queue.
;
; Inputs:
;
;	R3 = IRP address
;	R5 = UCB address
;	R9 = CDB address
;
;	IPL = FIPL
;
; Outputs
;
;	R0 = status of transmit request
;
;	R3-R7 are preserved.
;
;--
	.ENABL	LSB
XMT_START:
	MOVZWL	#SS$_DEVOFFLINE,R0		; Assume trib shutting down
	BBC	#CD_TS_V_ESTAB,-		; Br if trib not established
		CDB_W_STS(R9),40$		;
;
; Insert entry on CDB transmit wait queue if circuit not running or
; there are too many transmit requests pending.
;
	MOVB	#XD_FC_V_XMIT,IRP$B_XDFUNC(R3)	; Set function request in IRP
	INSQUE	(R3),@CDB_Q_XMT_REQ+4(R9)	; Insert IRP on CDB xmit wait Q

XMT_ALT_START:					; Alternate start of xmits
;
; Inputs:
;	R9 = CDB address
;
	BBC	#XM$V_STS_RUNNING,-		; Br if trib is not running
		CDB_L_DEVDEPEND(R9),10$		;
	REMQUE	@CDB_Q_XMT_REQ(R9),R3		; Get oldest xmit request
	BVS	10$				; Br if none - process others
	DECB	CDB_B_XMT_CNT(R9)		; One less xmit possible for this circuit
	BGEQ	5$				; Br if we can handle this request
	INCB	CDB_B_XMT_CNT(R9)		; Else, set count back to zero
	INSQUE	(R3),CDB_Q_XMT_REQ(R9)		; Re-insert on front of queue
	BRB	10$				; Try to start waiting xmits
 
5$:	INSQUE	(R3),@UCB$Q_XD_XMT_REQ+4(R5)	; Insert request on UCB wait Q
;
; Find a free mapping register slot.  If none currently available, put the
; I/O request in the CCB wait queue.
;
10$:	PUSHQ	R6				; Save R6,R7
	MOVZBL	UCB$B_XD_XMT_MAX(R5),R6		; Get max concurrent transmits
	FFC	#0,R6,UCB$B_XD_XMT_MAP(R5),R6	; Find a free transmit slot
	BEQL	30$				; Br if none free
;
; Store IRP info in UCB
;
	ASSUME	IRP$W_BOFF+2 EQ IRP$W_BCNT
	ASSUME	UCB$W_BOFF+2 EQ UCB$W_BCNT
	REMQUE	@UCB$Q_XD_XMT_REQ(R5),R3	; Get oldest xmit request
	BVS	30$				; Br if none, leave
	MOVL	IRP$W_BOFF(R3),UCB$W_BOFF(R5) 	; Set buffer offset and count
	MOVL	IRP$L_SVAPTE(R3),UCB$L_SVAPTE(R5) ; Set buffer PTE address
	MOVL	UCB$L_CRB(R5),R7		; Get CRB address
	TSTL	R6				; Is mapping slot the preallocated one
	BNEQ	20$				; Br if not - need to allocate one
	MOVL	UCB$L_XD_XMT_MAP(R5),-		; Store preallocated map
		CRB$L_INTD+VEC$W_MAPREG(R7)	; register info into CRB
	BRB	60$				; Continue
 
;
; Allocate UNIBUS map registers
;
20$:	JSB	G^IOC$ALOUBAMAP			; Allocate UNIBUS map registers
	BLBS	R0,50$				; Br if one available
	INSQUE	(R3),UCB$Q_XD_XMT_REQ(R5)	; Re-insert IRP on UCB wait Q
30$:	POPQ	R6				; Restore R6,R7
	MOVZWL	S^#SS$_NORMAL,R0		; Set success
40$:	RSB					; Return to caller
 
50$:	ASSUME	VEC$W_MAPREG+2 EQ VEC$B_NUMREG
	ASSUME	VEC$B_NUMREG+1 EQ VEC$B_DATAPATH
	MOVL	CRB$L_INTD+VEC$W_MAPREG(R7),-	; Save mapping info
		UCB$L_XD_XMT_MAP(R5)[R6]	; into UCB
 
;
; Map the buffer
;
60$:	SETBIT	R6,UCB$B_XD_XMT_MAP(R5)		; Set mapping slot in use flag
	MOVB	R6,IRP$L_MEDIA+4(R3)		; Save mapping slot number used
	ASSUME	IRP$W_BOFF+2 EQ IRP$W_BCNT
	MOVL	IRP$W_BOFF(R3),IRP$L_MEDIA(R3)	; Move byte offset and size
	INSV	CRB$L_INTD+VEC$W_MAPREG(R7),-	; Insert BA9-BA15
		#9,#7,IRP$L_MEDIA(R3)
	EXTZV	#7,#2,CRB$L_INTD+VEC$W_MAPREG(R7),R0 ; Get BA16-BA17
	INSV	R0,#30,#2,IRP$L_MEDIA(R3)	; Insert BA16-BA17
	JSB	G^IOC$LOADUBAMAPA		; Loadmap registers
;
; Request and load the port with the buffer address and size, and return
;
	POPQ	R6				; Restore R6,R7
	INSQUE	(R3),@UCB$Q_XD_INPUTQ+4(R5)	; Insert transmit request at end of
						;     UCB input wait queue.
	PUSHL	R9				; Save CDB address
	DSBINT	UCB$B_DIPL(R5)			; Sync access to device
	BSBW	LOAD_PORT			; Load port
	ENBINT					; Restore IPL
	POPL	R9				; Restore CDB address
	BRW	XMT_ALT_START			; Lets try it again
	.DSABL	LSB

	.SBTTL	RCV_FDT,  Read I/O Operation FDT Routine

;++
; RCV_FDT - Read I/O Operation FDT Routine
;
; Functional description:
;
; This routine is called by the SYS$QIO system service to dispatch a
; READ I/O request.
;
; The QIO parameters for READs are:
;
;	P1 = address of the buffer
;	P2 = size of the buffer
;	All other parameters are unused.
;
; The specified buffer is checked for accessibility. The buffer address and
; count are saved in the packet. Then IPL is raised to device fork IPL and if
; a message is available the operation is complete. Otherwise the packet is
; queued onto the waiting receive list of the CDB.
;
; If the function specifies a modifier of IO$M_NOW, if no message is
; available when the test is made, a status of SS$_ENDOFFILE is
; returned.
;
; Inputs:
;
;	R3 = I/O Packet Address
;	R4 = PCB Address
;	R5 = UCB Address
;	R6 = CCB Address
;	R7 = Function Code
;	AP = Address of first operation-specific QIO parameter
;
; Outputs:
;
;	R0 = status of the receive QIO operation
;	R3-R7 - unchanged
;
;--

RCV_FDT:					; Read FDT process routine
	CLRQ	IRP$Q_STATION(R3)		; Clear tributary address field
;
; Check request parameters
;
	MOVZWL	S^#SS$_BADPARAM,R0		; Assume bad parameters
	MOVZWL	P2(AP),R1			; Get length of buffer
	BEQL	10$				; Br if zero - abort I/O
	MOVL	P1(AP),R0			; Get buffer address
	MOVL	R0,IRP$L_MEDIA(R3)		; Save buffer addr in IRP
	CLRW	IRP$W_BOFF(R3)			; No quota to return during completion
	JSB	G^EXE$READCHK			; Check accessibility
						; (No return on no access)
	BSBW	XLATE				; Get CDB address
	BLBC	R0,10$				; Br if error
	SETIPL	UCB$B_FIPL(R5)			; Raise IPL to fork level
						;  to lock the data base
	BSBB	RCV_START			; Start receive operation
	BLBC	R0,10$				; Br if error
	JMP	G^EXE$QIORETURN			; Return to await completion
 
10$:	BRW	ABORTIO				; Abort the I/O request

	.SBTTL	RCV_START,  Start Receive Operation
 
;++
; RCV_START - Start Receive Operation
;
; Functional description:
;
; At this point, the buffer is okay and we are now at fork IPL.  Now check
; to make sure the tributary has been established.  If not, we will return
; an SS$_DEVOFFLINE error status.  Note that the circuit need not be turned
; on in order to do a read request.
; 
; Inputs:
;
;	R3 = IRP address
;	R5 = UCB address
;	R9 = CDB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0 = return status of receive request
;	R3-R7 are preserved.
;
;--
	.ENABL	LSB
RCV_START:
	MOVZWL	#SS$_DEVOFFLINE,R0		; Assume trib not established
	BBC	#CD_TS_V_ESTAB,CDB_W_STS(R9),40$ ; Br if trib not established
	BBC	#CD_TS_V_BUFQUO,CDB_W_STS(R9),-	; Br if no buffer management
		RCV_START_ALT			;
	MOVB	#XD_FC_V_RECV,IRP$B_XDFUNC(R3)	; Set function request in IRP
	BBC	#IO$V_NOW,IRP$W_FUNC(R3),5$	; Br if not READ NOW
	MOVAB	CDB_Q_RCV_MSG(R9),R2		; Get address of received msgs
	CMPL	(R2),R2				; Is there a message?
	BEQL	15$				; Br if no - return EOF
5$:	DSBINT	UCB$B_DIPL(R5)			; Sync access to device
	INSQUE	(R3),@UCB$Q_XD_INPUTQ+4(R5)	; Insert at end of input Q
	BSBW	LOAD_PORT			; Bump quota for trib
	ENBINT					; Restore IPL
	BRB	30$				; Return with success
 
RCV_START_ALT:					; Alternate receive startup
;
;  Check to see if message is available
;
	REMQUE	@CDB_Q_RCV_MSG(R9),R2		; Dequeue a received message
	BVS	10$				; Br if none
;
; Complete the receive with available message
;
	BSBW	FINISH_RCV_IO			; Complete the I/O request
	BRB	30$				; and exit
;
; No message available.  If IO$M_NOW specified, return with SS$_ENDOFFILE
; status. Otherwise, queue IRP to await arrival of message and continue.
;
10$:	BBC	#IO$V_NOW,IRP$W_FUNC(R3),20$	; Branch if not READ NOW
15$:	MOVZWL	#SS$_ENDOFFILE,R0		; Set no message status
	BSBW	IO_DONE				; Complete the I/O
	BRB	30$				; and exit
;
; Queue the IRP to CDB receive IRP wait queue
;
20$:	INSQUE	(R3),@CDB_Q_RCV_REQ+4(R9)	; Queue IRP to await message
30$:	MOVZBL	S^#SS$_NORMAL,R0		; Set successful return
40$:	RSB					; Return
	.DSABL	LSB

	.SBTTL	ALT_START,  Alternate Start I/O Routine

;++
; ALT_START - Alternate Start I/O Routine
;
; Functional description:
;
; This entry point is used by the "internal IRP" interface.  IRP's
; which enter the driver at this point have not been pre-processed
; by our FDT routines.  These IRP's have been built by another
; driver and look exactly like a regular IRP.
;
; This routine, therefore, must do the same processing which the FDT
; routines would do if they had been called as in the case of a normal
; IRP.
;
; NOTE: The PID and CHAN fields of the IRP are sufficient to map to a
; CDB.
;
; Inputs:
;
;	R3 - IRP address
;	R5 - UCB address
;
;	All pertinent fields of the IRP are assumed to be valid.
;
;	IPL = FIPL
;
; Outputs:
;
;	R0 = status of the transmit/receive request.
;
;	R3-R5 are preserved.
;
;--
 
ALT_START:
	PUSHL	R9				; Save R9
	CLRQ	IRP$Q_STATION(R3)		; Clear station field
	TSTW	IRP$W_CHAN(R3)			;****temporary****
	BLSS	3$				;****temporary****
	MNEGW	IRP$W_CHAN(R3),IRP$W_CHAN(R3)	;****temporary****
3$:	MOVL	UCB$L_XD_PID(R5),R0		; Use starter's PID
	BSBW	XLATE_ALT			; Get CDB address
	BLBC	R0,30$				; Br if error
	BBS	#IRP$V_FUNC,IRP$W_STS(R3),10$	; Br if read request
	BSBW	XMT_START			; Initiate the transmit
	BRB	30$				; Return

10$:	MOVL	IRP$L_SVAPTE(R3),R2		; Get address of input buffer
	BEQL	20$				; Br if none
	CLRL	IRP$L_SVAPTE(R3)		; Make sure SVAPTE is cleared
	BSBW	ADDRCVLIST			; Else, add it to the receive list
20$:	BSBW	RCV_START			; Initiate the read
30$:	POPL	R9				; Restore R9
	BLBC	R0,40$				; Branch if error
	RSB					; Return to caller

40$:	BRW	IO_DONE				; Post the I/O request in error

	.SBTTL	SETMODE_FDT,  Set mode I/O operation FDT routine
 
;++
; SETMODE_FDT - Set mode I/O operation FDT routine
;
; Functional description:
;
; This routine is used to set the configuration of the DMP11 hardware
; device.  Subfunction modifier bits are used to specify the type of
; action to be taken.  The two characteristics buffers (P1 and P2)
; are used to describe specific characteristics.  
;
; The QIO parameters for SETMODE are:
;
;	P1 = Optional address of quadword or longword buffer
;	P2 = Optional address of buffer descriptor for extended characteristics
;	P3 = Number of receive buffers to pre-allocate. Required on
;	     controller startup.
;
;
; The subfunction modifiers are as follows:
;
;
; 	 o STARTUP - establish a tributary - this modifier is used to
;		establish a tributary so that communication between
;		a unit and the DMP11 device can occur.  Polling 
;		parameters may also be modified with this command 
;		either at startup time or at any subsequent point
;		in time.
;
; 	o SHUTDOWN - shutdown the assigned tributary - this modifier
; 		is used to stop the polling and delete the tributary
; 		by the user of that tributary.  Only the assigned
; 		tributary may be shutdown and this command does not
; 		require privilege.
;
; 	o ATTNAST - request an attention AST - this modifier is used
;	 	to set up an AST to be delivered when a change of
;	 	status occurs on this tributary.
;
;	o CTRL - perform the request on the Controller not the
;		 tributary.
;
;	o SET_MODEM - set line unit's mode register.
;
; Inputs:
;
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;	R6 = CCB address
;	R7 = Function code
;	AP = address of first QIO parameter
;
; Outputs:
;
;	R0 = status of setmode request
;
;	R3-R5 are preserved.
;
;	R7-R9 = destroyed
;
;--

SETMODE_FDT:					; Setmode FDT processing
	CLRQ	IRP$Q_STATION(R3)		; Clean up station field
	MOVZWL	IRP$W_FUNC(R3),R7		; Get entire function code
	BBS	#IO$V_SET_MODEM,R7,3$		; Br if SET_MODEM request
	BBC	#IO$V_CTRL,R7,5$		; Br if not controller request
3$:	BRW	SETMODE_CTRL			; Process controller request
;
; Perform setmode request on a tributary
;
5$:	BBC	#IO$V_ATTNAST,R7,30$		; Branch if not attention AST
 
;
; User is requesting an attention AST.
;
	BSBW	XLATE				; Get CDB address
	BLBC	R0,40$				; Br if error - abort I/O
	MOVAL	CDB_L_AST(R9),R7		; Get addr of AST list
	JSB	G^COM$SETATTNAST		; Set up attention AST
	BBC	#CD_TS_V_ESTAB,CDB_W_STS(R9),20$ ; Br if tributary not estab
	MOVAB	CDB_Q_RCV_MSG(R9),R1		; Check for empty rcv list
	CMPL	R1,(R1)				; Empty?
	BEQL	20$				; Yes, no need to inform user
10$:	PUSHL	R3				; Else, save IRP address
	BSBW	POKE_USER			; Inform the user
	POPL	R3				; Restore IRP address
20$:	MOVL	CDB_L_DEVDEPEND(R9),R1		; Get CDB dependent status
	BISL	UCB$L_DEVDEPEND(R5),R1		; OR in UCB status
23$:	MOVZWL	S^#SS$_NORMAL,R0		; Set success
25$:	JMP	G^EXE$FINISHIO			; Complete the I/O
 
 
30$:	BSBW	GET_CHAR_BUFS			; Get P1 and P2 characteristics
	BLBC	R0,40$				; Br if error - abort I/O
	BBC	#IO$V_SHUTDOWN,R7,50$		; Branch if not trib shutdown
;
; Shutdown tributary modifier specified.
;
; Validate P2 buffer. Try to find CDB, if found then update CDB and stop
; tributary.
;
	BSBW	XLATE				; Get CDB address
	CLRL	R2				; Assume no CDB present
	BLBC	R0,35$				; Br if not CDB present
	MOVZWL	CDB_W_STS(R9),R2		; Else, get status
35$:	BSBW	VALIDATE_P2_CDB			; Validate the P2 buffer
	BLBC	R0,25$				; Br if error
	MOVL	UCB$L_DEVDEPEND(R5),R1		; Assume no CDB
	TSTL	R9				; Was CDB found?
	BEQL	23$				; No - leave now
	BSBW	CHG_CDB				; Change CDB parameters
	BBC	#CD_TS_V_ESTAB,CDB_W_STS(R9),20$ ; Br if nothing to delete
	MOVB	S^#XD_FC_V_STOPT,IRP$B_XDFUNC(R3) ; Set internal function code
	BRW	QUEPKT				; Queue packet to driver
 
37$:	POPL	R3				; Restore R3
40$:	BRW	ABORTIO				; Abort the I/O request
;
; Startup tributary modifier specified or no modifier
;
50$:	BSBW	XLATE				; Get CDB address
	BLBC	R0,55$				; Br if CDB address not found
	BRW	150$				; Else, change existing trib
;
; We are creating a new tributary.
;
55$:	MOVZWL	#SS$_DEVINACT,R0		; Assume ctrl not active
	BBC	#UCB$V_XD_INITED,-		; Br if ctrl not inited
		UCB$W_DEVSTS(R5),40$		;
;
; Allow only 1 trib for point to point or tributary mode
;
	BBC	#UCB$V_XD_PTP,UCB$W_DEVSTS(R5),60$ ; Br if not point to point
;	BBS	#XM$V_CHR_CTRL,-		; Br if control station
;		UCB$L_DEVDEPEND(R5),60$ 	;	
	CMPL	IRP$L_PID(R3),UCB$L_XD_PID(R5)	; Make sure same PID
	BNEQ	70$				; Br if not - sneaky devil
	TSTB	UCB$B_XD_TRB_CNT(R5)		; Any tribs yet?
	BNEQ	70$				; Br if trib already exists
;
; Find an empty tributary slot in UCB
;
60$:	BSBW	FIND_SLOT			; Find an empty slot
	BLBS	R0,80$				; Br if found one
70$:	MOVZWL	#SS$_DEVICEFULL,R0		; Return error
	BRB	40$				; Abort I/O
;
; Found empty slot in UCB translation vector, validate P2 and allocate a CDB
;
80$:	CLRL	R2				; No status flags yet
	CLRL	R9				; No CDB address - Yet
	BSBW	VALIDATE_P2_CDB			; Validate the P2 buffer
	BLBC	R0,40$				; Br if error
;
; Make sure trib address given if startup request.
; We make this requirement, because this is a new CDB and the tributary
; address is required for all modes except Point to Point.
;
	BBC	#IO$V_STARTUP,R7,85$		; Br if not startup request
	BBS	#UCB$V_XD_PTP,UCB$W_DEVSTS(R5),85$ ; Br if point-to-point
	MOVZWL	#NMA$C_PCCI_TRI,R1		; Get trib address
	BSBW	UNPACK_P2_BUF			; From P2 buffer
	BLBS	R0,85$				; Br if given - Okay
	MOVZWL	#SS$_INSFARG,R0			; Insufficient arguments
	BRW	ABORTIO				; Abort the I/O
 
85$:	MOVZWL	#CDB_C_LENGTH,R1		; Get size of CDB
	PUSHL	R3				; Save IRP address
	JSB	G^EXE$BUFQUOPRC			; Check caller's quota
	BLBC	R0,37$				; Br if error
	JSB	G^EXE$ALONONPAGED		; Allocate the CDB
	BLBC	R0,37$				; Br if error
	POPL	R3				; Restore IRP address
	MOVL	PCB$L_JIB(R4),R0		; Get JIB address
	SUBL	#CDB_C_LENGTH,JIB$L_BYTCNT(R0)	; Charge user for CDB
	SUBL	#CDB_C_LENGTH,JIB$L_BYTLM(R0)	; ..and limit
;
; Zero the CDB
;
	MOVL	R2,R9				; Copy CDB address
	PUSHR	#^M<R3,R4,R5>			; Save registers
	MOVC5	#0,(R2),#0,#CDB_C_LENGTH,(R2)	; Zero the CDB
	POPR	#^M<R3,R4,R5>			; Restore registers
	MOVL	IRP$L_PID(R3),CDB_L_PID(R9)	; Save starter's PID
	MOVW	IRP$W_CHAN(R3),CDB_W_CHAN(R9)	; Save associated channel
	ASSUME	CDB_B_TYPE EQ CDB_W_SIZE+2
	ASSUME	CDB_B_POL EQ CDB_B_TYPE+1
;
; We will init the Polling state to unlatched. It is assumed that
; a zero polling state means unlatched!
;
	MOVL	#<<DYN$C_BUFIO@16>!CDB_C_LENGTH>,- ; Set type and size
		CDB_W_SIZE(R9)			;
;
; Initialize CDB queues
;
	MOVZBL	S^#CDB_C_QUEUES,R0		; Set number of queue heads
	MOVAB	CDB_Q_QUEUES(R9),R2		; Set address of first head
90$:	MOVAB	(R2),(R2)+			; Init forward link pointer
	MOVAB	-4(R2),(R2)+			; Init backward link pointer
	SOBGTR	R0,90$				; Loop if more queues
;
; Initialize CDB default parameters
;
	MOVZWL	#DEF_TRIB_PARAMSZ,R0		; Set size of parameters in bytes
	MOVAB	DEF_TRIB_PARAM,R1		; Set address of defaults
	MOVAB	CDB_B_SETPRM(R9),R2		; Set address of parameters
100$:	MOVB	(R1)+,(R2)+			; Set default
	SOBGTR	R0,100$				; Loop for all parameters
 
	MOVW	UCB$W_XD_RTT(R5),CDB_W_SEL_TIMER(R9) ; Set default retransmit timer
	MOVB	UCB$B_XD_XMT_TRB(R5),CDB_B_XMT_CNT(R9) ; Init max xmits allowed
	BBS	#XM$V_CHR_CTRL,UCB$L_DEVDEPEND(R5),110$ ; Br if control mode
	MOVB	#INF_XMT,CDB_B_XMT_CNT(R9)	; Else, allow infinite xmits
110$:	MOVZBL	IRP$B_INDEX(R3),R8		; Get vector index
	SETIPL	UCB$B_FIPL(R5)			; Sync access to UCB
	MOVL	R9,UCB$L_XD_CDB_VEC(R5)[R8]	; Store CDB address in UCB
	MOVAL	UCB$L_XD_CDB_VEC(R5)[R8],-	; Store address of CDB address
		IRP$L_CDB(R3)			; ..in CDB
	MOVL	IRP$L_PID(R3),-			; Save PID in UCB
		UCB$L_XD_PID_VEC(R5)[R8]	;
	MOVW	IRP$W_CHAN(R3),-		; Save channel index in UCB
		UCB$W_XD_CHAN_VEC(R5)[R8]	;
	INCB	UCB$B_XD_TRB_CNT(R5)		; Tally one more tributary
;
; Tributary now exists change its characteristics and set them
; if trib is established.
;
120$:	BSBW	CHG_CDB				; Change CDB parameters
	BBS	#IO$V_STARTUP,R7,125$		; Br if startup request
	MOVZWL	#SS$_NORMAL,R0			; Else, set successful return
	MOVL	CDB_L_DEVDEPEND(R9),R1		; Set IOSB1 return
	BISL	UCB$L_DEVDEPEND(R5),R1		; ..plus UCB status
123$:	JMP	G^EXE$FINISHIO			; Finish the I/O request
;
; Startup tributary requested
;
125$:	MOVB	S^#XD_FC_V_INITT,IRP$B_XDFUNC(R3) ; Set internal function code
	CMPL	CDB_L_PID(R9),UCB$L_XD_PID(R5)	; Same PID as starter?
	BNEQ	127$				; Br if not
	BBC	#XM$V_CHR_MOP,CDB_L_DEVDEPEND(R9),128$ ; Br if not MOP mode
	BBC	#XM$V_CHR_CTRL,UCB$L_DEVDEPEND(R9),128$ ; Br if not control station
127$:	MOVB	#1,CDB_B_MRB(R9)		; Else, set MRB to one
128$:	CMPB	#INF_RCV,CDB_B_MRB(R9)		; Is MRB at 'unlimited'?
	BEQL	129$				; Br if yes
	SETBIT	#CD_TS_V_BUFQUO,CDB_W_STS(R9)	; Else, must user buffer manager
129$:	BBC	#UCB$V_XD_PTP,UCB$W_DEVSTS(R5),130$ ; Br if not point-point
	MOVB	#1,CDB_B_TRB_ADDR(R9)		; Else set trib address
	MOVB	#1,IRP$Q_STATION(R3)		; Again in IRP
	MOVZBL	IRP$B_INDEX(R3),R0		; Get vector index
	MOVB	#1,UCB$B_XD_TRIB_VEC(R5)[R0]	; And again in UCB trib vector
130$:	MOVZWL	#SS$_INSFARG,R0			; Assume trib address missing
	TSTB	CDB_B_TRB_ADDR(R9)		; Trib address given?
	BNEQ	170$				; Br if yes - okay
140$:	BRW	ABORTIO				; Else, abort the I/O request
 
;
; Tributary already exists .. validate P2
;
150$:	MOVL	CDB_L_DEVDEPEND(R9),R2		; Get trib status
	BSBW	VALIDATE_P2_CDB			; Validate P2
	BLBC	R0,123$				; Br if error
	SETIPL	UCB$B_FIPL(R5)			; Sync access to CDB
	BBS	#CD_TS_V_ESTAB,CDB_W_STS(R9),160$ ; Br if trib established
;
; Tributary not active .. change CDB parameters and do startup if necessary
;
	CLRB	CDB_L_DEVDEPEND(R9)		; Clear old characteristics
	BRB	120$				; Change CDB and start if needed
;
; Tributary already active .. set CDB and give request to device
;
160$:	CLRB	IRP$L_MEDIA+4(R3)		; Clear trib characteristics
	BSBW	CHG_CDB				; Change the CDB params
	MOVB	S^#XD_FC_V_CHGT,IRP$B_XDFUNC(R3) ; Set new CDB params
	MOVB	#255,IRP$L_MEDIA(R3)		; Set 8 parameters
170$:	BRW	QUEPKT				; Queue packet to driver

	.SBTTL	SETMODE_CTRL,  Perform setmode FDT operation on controller
 
;++
; SETMODE_CTRL - Perform setmode FDT operation on controller
;
; Functional description:
;
; This routine performs the SETMODE FDT setup for the controller.
;
; Inputs:
;
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;	R7 = IRP function word
;
; Outputs:
;
;	R0 = status of setmode request
;
;	R3-R5 are preserved.
;
;--
 
SETMODE_CTRL:					; Perform setmode on controller
	BBC	#IO$V_SET_MODEM,R7,10$		; Br if not setmodem request
;
; Set modem modifier specified
;
;	P1(AP) = address of modem longword bit settings
;
	MOVZWL	#SS$_BADPARAM,R0		; Assume P1 buffer not given
	MOVL	P1(AP),R2			; Get address of P1 buffer
	BEQL	20$				; Br if none specified
	MOVZWL	#SS$_ACCVIO,R0			; Assume access violation
	IFNORD	#4,(R2),20$			; Br if access violation
	MOVL	(R2),IRP$L_MEDIA(R3)		; Store modem bits in IRP
	MOVB	S^#XD_FC_V_WTMODEM,IRP$B_XDFUNC(R3) ; Set function request
	BRW	QUEPKT				; Queue packet to driver
 
10$:	BSBW	GET_CHAR_BUFS			; Get P1 and P2 characteristics
	BLBC	R0,20$				; Br if error - Abort I/O
	MOVZWL	UCB$W_DEVSTS(R5),R2		; Get device status
	BSBW	VALIDATE_P2_UCB			; Validate the P2 buffer
	BLBC	R0,17$				; Br if error

	BBC	#IO$V_SHUTDOWN,R7,25$		; Br if not shutdown request
;
; Shutdown modifier specified
;
	BSBW	CHG_UCB				; Update the UCB
	BBC	#UCB$V_XD_INITED,-		; Br if controller not up
		UCB$W_DEVSTS(R5),15$		;
	MOVB	#XD_FC_V_STOPC,IRP$B_XDFUNC(R3)	; Set function request
	BRW	QUEPKT				; Queue packet to driver
 
15$:	MOVL	UCB$L_DEVDEPEND(R5),R1		; Get IOSB1 return
	MOVZBL	S^#SS$_NORMAL,R0		; Set success
17$:	JMP	G^EXE$FINISHIO			; Complete the I/O request

20$:	BRW	ABORTIO				; Abort the I/O request
;
; Make sure this request is from the starter PID unless device not inited
; or device is running in control station mode.
;
25$:	BBC	#UCB$V_XD_INITED,-		; Br if device not inited
		UCB$W_DEVSTS(R5),30$		;
	BBS	#XM$V_CHR_CTRL,-		; Br if control station
		UCB$L_DEVDEPEND(R5),30$		;
	MOVZWL	#SS$_DEVICEFULL,R0		; Assume someone has device
	CMPL	IRP$L_PID(R3),UCB$L_XD_PID(R5)	; Is this the owner PID?
	BNEQ	20$				; Br if no - wrong user
 
30$:	BBS	#IO$V_STARTUP,R7,31$		; Br if startup request
	BRW	50$				; Else, no modifier
;
; Controller startup requested
;
;	P3(AP) = number of receive buffers desired
;
31$:	MOVZWL	P3(AP),R1			; Get number of receive buffers
	BEQL	35$				; Br if no - ignore it
	BBC	#UCB$V_XD_INITED,-		; Br if device not inited
		UCB$W_DEVSTS(R5),33$		;
	CMPB	R1,UCB$B_XD_BFN(R5)		; Are the buffer numbers the same?
	BEQL	33$				; Br if yes
	MOVZWL	#NMA$C_PCLI_BFN,R1		; Set IOSB1 return
	MOVZWL	#SS$_BADPARAM,R0		; Set error return
	BRB	17$				; Finish the I/O request
33$:	MOVB	R1,UCB$B_XD_BFN(R5)		; Store new receive buffer number
;
; Set new P1, P2 parameters
;
35$:	BBS	#UCB$V_XD_INITED,-		; Br if device already inited
		UCB$W_DEVSTS(R5),70$		;
	BLBC	IRP$L_MEDIA(R3),37$		; Br if no P1
	CLRB	UCB$L_DEVDEPEND(R5)		; Clear old characteristics
37$:	BSBW	CHG_UCB				; Change the UCB characteristics
	MOVZBL	UCB$B_XD_BFN(R5),R1		; Get number of receive buffers
	MOVZWL	IRP$L_MEDIA+2(R3),R2		; Get message size from P1
	BLBS	IRP$L_MEDIA(R3),40$		; Br if P1 buffer valid
	MOVZWL	UCB$W_DEVBUFSIZ(R5),R2		; Else, get buffer size from UCB
40$:	MOVZWL	#SS$_BADPARAM,R0		; Assume bad parameter
	MULL	R2,R1				; Compute total needed for buffers
	BEQL	60$				; Br if zero - error
	MOVZWL	R1,R7				; Copy quota
	CMPL	R1,R7				; Overflow?
	BNEQ	60$				; Br if error
	PUSHL	R3				; Save R3
	JSB	G^EXE$BUFQUOPRC			; Check caller's quota
	POPL	R3				; Restore R3
	BLBC	R0,60$				; Br if error
	MOVW	R7,IRP$W_QUOTA(R3)		; Save quota in packet
	MOVL	PCB$L_JIB(R4),R0		; Get JIB address
	SUBL	R7,JIB$L_BYTCNT(R0)		; Charge user for rec. bufs
	SUBL	R7,JIB$L_BYTLM(R0)		; ..and limit
	MOVB	S^#XD_FC_V_INITC,IRP$B_XDFUNC(R3) ; Set function request in IRP
	MOVB	S^#XD_FC_V_INITC,IRP$L_MEDIA+1(R3) ; ..Twice for fork process
	BRW	QUEPKT				; Queue request to driver
;
; No modifier specified - change controller parameters
;
50$:	BBS	#UCB$V_XD_INITED,-		; Br if already inited
		UCB$W_DEVSTS(R5),70$		;
	BLBC	IRP$L_MEDIA(R3),53$		; Br if no P1 buffer
	CLRB	UCB$L_DEVDEPEND(R5)		; Clear old UCB characteristics
53$:	BSBW	CHG_UCB				; Change UCB parameters
	MOVZWL	S^#SS$_NORMAL,R0		; Else, set success
	MOVL	UCB$L_DEVDEPEND(R5),R1		; Set IOSB1 return
55$:	JMP	G^EXE$FINISHIO			; Finish the I/O request
 
60$:	BRW	ABORTIO				; Abort the I/O request
;
; Device already inited - set new parameters and give them to device
;
70$:	BLBC	IRP$L_MEDIA(R3),80$		; Br if no P1 buffer
	CMPB	IRP$L_MEDIA+4(R3),UCB$L_DEVDEPEND(R5) ; Are characteristics okay?
	BEQL	80$				; Yes - let it go
	MOVZWL	#SS$_BADPARAM,R0		; Return error
	MNEGL	S^#1,R1				; No specific parameter
	BRB	55$				; Complete the I/O
 
80$:	BSBW	CHG_UCB				; Change UCB parameters
	MOVB	S^#XD_FC_V_CHGC,IRP$B_XDFUNC(R3) ; Set function request
	MOVB	S^#XD_FC_V_CHGC,IRP$L_MEDIA+1(R3) ; ..Twice for fork process
	MOVB	#<15@4>,IRP$L_MEDIA(R3)		; Set only four parameters
	BRW	QUEPKT				; Queue packet to driver

	.SBTTL	GET_CHAR_BUFS,  Get P1 and P2 characteristics buffers
 
;++
; GET_CHAR_BUFS - Get P1 and P2 characteristics buffers
;
; Functional description:
;
; This routine saves the P1 and P2 buffers for later use by the driver.
; The P1 buffer is saved in the IRP (IRP$L_MEDIA) as a quadword value.
; The P2 buffer is saved by allocating the appropriate amount of memory from
; non-paged pool.   The user's quota is checked before the allocation is made.
; And the non-paged pool buffer is charged against the user's quota. The P2
; system buffer address is passed in IRP$L_SVAPTE of the IRP.
;
;
; Inputs:
;
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;
; Outputs:
;
;	R0 = status of buffers
;
;	R3-R5 are preserved.
;
;--
 
GET_CHAR_BUFS:					; Get characteristics buffers
;
; Check access to P1 buffer and save P1 characteristics
;
	CLRQ	IRP$L_MEDIA(R3)			; Reset P1 chars
	MOVL	P1(AP),R2			; Get address of P1 char buf
	BEQL	10$				; Branch if no P1 buffer
	MOVZWL	#SS$_ACCVIO,R0			; Assume access violation
	IFNORD	#8,(R2),20$			; Check access
	MOVQ	(R2),IRP$L_MEDIA(R3)		; Save P1 characteristics
	MOVB	#1,IRP$L_MEDIA(R3)		; Indicate valid P1 buffer
;
; Check access to P2 buffer and check process's buffer quota
;
10$:	MOVL	P2(AP),R1			; Get address P2 char buf desc
	BEQL	40$				; Br if no P2 buffer
	PUSHL	R3				; Save R3
	JSB	G^EXE$PROBER_DSC		; Check access to buffer
	BLBC	R0,15$				; Br if error
	PUSHL	R2				; Save R2
	JSB	G^EXE$BUFQUOPRC			; Check for buffered quota
	POPL	R2				; Restore R2
15$:	POPL	R3				; Restore R3
	BLBS	R0,30$				; Branch if quota ok
20$:	RSB					; Return
 
;
; Quota OKAY, allocate buffer and copy info.
;
30$:	BSBW	ALLOC_P2BUF			; Allocate buffer
	BLBC	R0,50$				; Br if error
	MOVL	IRP$L_SVAPTE(R3),R0		; Get P2 buffer address
	PUSHR	#^M<R3,R4,R5>			; Save sacred registers
	MOVC3	R1,(R2),P2B_T_DATA(R0)		; Save P2 char buffer
	POPR	#^M<R3,R4,R5>			; Restore registers
40$:	MOVZBL	S^#SS$_NORMAL,R0		; Set success
50$:	RSB					; Return

	.SBTTL	SENSEMODE_FDT,  Sense Mode I/O operation FDT routine

;++
; SENSEMODE_FDT - Sense Mode FDT routine
;
; Functional Description:
;
;  This routine returns information to the caller about the configuration
;  and status of the DMP11 device.  Depending on the function modifier,
;  either the device characteristics, error counters or modem register
;  contents are returned.
;
;
;  The QIO parameters for SENSEMODE are:
;
;	P1 = optional address of quadword or longword buffer
;	P2 = optional address of buffer descriptor for extended characteristics
;	
;
; Inputs:
;
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;	R6 = CCB address
;	R7 = Function code
;	AP = Address of first function-dependent QIO parameter
;
; Outputs:
;
;	R0 = status return of sensemode request
;
;	R3-R5 are preserved.
;
;--

SENSEMODE_FDT:					; Sensemode FDT I/O processing
	CLRQ	IRP$Q_STATION(R3)		; Clear station address field
	MOVW	IRP$W_FUNC(R3),R7		; Get entire function code
	BBC	#IO$V_RD_MODEM,R7,3$		; Br if not read modem request
	BRW	SENSE_MODEM			; Else, process read modem
 
3$:	BBC	#IO$V_CTRL,R7,5$		; Br if not controller request
	BRW	SENSEMODE_CTRL			; Else, process controller req.
;
; Tributary sensemode request
;
5$:	BSBW	XLATE				; Get CDB address
	BLBC	R0,30$				; Br if error
	BBC	#IO$V_RD_COUNT,R7,20$		; Br if not read counters
;
; Read tributary counters - modifier RD_COUNT
;
	BSBW	CHECK_P2			; Check P2 buffer
	MOVZWL	#SS$_BADPARAM,R0		; Assume zero length buffer
	MOVW	R1,IRP$L_MEDIA+2(R3)		; Save user size of P2 buffer
	BEQL	30$				; Br if none
	MOVZWL	S^#TRIB_CNT_BUFSIZ,R1		; Get size of tributary P2 buf
	BSBW	ALLOC_P2BUF			; Allocate a buffer
	BLBC	R0,30$				; Br if error
	MOVL	IRP$L_SVAPTE(R3),R1		; Get system P2 buffer addr
	MOVL	R2,P2B_L_BUFFER(R1)		; Save user's P2 buffer addr
	MOVB	#254,IRP$L_MEDIA(R3)		; Get 7 counters
	MOVB	S^#XD_FC_V_RDTERR,IRP$B_XDFUNC(R3) ; Assume Read counts
	BBC	#IO$V_CLR_COUNT,R7,10$		; Br if not clear counts
	MOVB	S^#XD_FC_V_RCTERR,IRP$B_XDFUNC(R3) ; Else, Read and Clear
10$:	BRW	QUEPKT				; Queue packet to driver

20$:	BBC	#IO$V_RD_MEM,R7,40$		; Br if read tss request
;
; Read TSS address - modifier RD_MEM
;
	MOVZBL	P2(AP),R1			; Get TSS address
	CMPB	R1,S^#31			; Is TSS address too big?
	BGTRU	30$				; Br if yes - error
	MOVB	R1,IRP$L_MEDIA+6(R3)		; Save TSS address in IRP
	MOVZBL	S^#4,R1				; Check access to P1 buffer
	BSBW	CHECK_P1			; Check P1 buffer
	BSBW	ALLOC_P2BUF			; Allocate a P2 buffer
	BLBC	R0,30$				; Br if allocation error
	MOVL	IRP$L_SVAPTE(R3),R1		; Get system buffer address
	MOVL	IRP$L_MEDIA(R3),P2B_L_BUFFER(R1) ; Save user P1 buffer VA
	CLRL	IRP$L_MEDIA(R3)			; Indicate NOT a counter IRP
	MOVB	S^#XD_FC_V_RDTSS,IRP$B_XDFUNC(R3) ; Set function request
	BRB	10$				; Queue packet
 
30$:	BRW	ABORTIO				; Abort the I/O request
 
;
; Read tributary parameters - no modifier
;
40$:	MOVZWL	S^#8,R1				; Size of P1 buffer if present
	BSBW	CHECK_BUFS			; Check P1 and P2 buffers
	MOVW	R1,IRP$L_MEDIA+4(R3)		; Save user P2 buffer length
	BEQL	60$				; Br if no P2 buffer present

	MOVZWL	#TRIB_PRM_BUFSIZ,R1		; Set size of required buffer
	BSBW	ALLOC_P2BUF			; Allocate a P2 buffer
	BLBC	R0,30$				; Br if error
	MOVL	IRP$L_SVAPTE(R3),R1		; Get system P2 buffer address
	MOVL	R2,P2B_L_BUFFER(R1)		; Set user's P2 buffer address
	MOVAB	TRIB_PARAM,R1			; Get address of return table
	MOVL	R9,R4				; Get CDB address
	BSBW	RETURN_P2			; Return the P2 parameters
	MOVW	S^#SS$_NORMAL,IRP$W_CSTATUS(R3)	; Assume success
	MOVW	IRP$W_BCNT(R3),R0		; Assume user has good size buffer
	CMPW	IRP$L_MEDIA+4(R3),R0		; Is user buffer large enough?
	BGEQU	50$				; Br if yes
	MOVW	#SS$_BUFFEROVF,IRP$W_CSTATUS(R3) ; Return partial success
	MOVW	IRP$L_MEDIA+4(R3),R0		; Set size of return
	MOVW	R0,IRP$W_BCNT(R3)		;	...
50$:	ASHL	#16,R0,R0			; Shift size of buffer return
	MOVW	IRP$W_CSTATUS(R3),R0		; Set success status
 
60$:	MOVL	IRP$L_MEDIA(R3),R2		; Retrieve P1 buffer address
	BEQL	70$				; Br if none
	MOVQ	UCB$B_DEVCLASS(R5),(R2)		; Else, return characteristics
	BISL	CDB_L_DEVDEPEND(R9),4(R2)	;	...
70$:	MOVL	CDB_L_DEVDEPEND(R9),R1		; Get device dependend info
	BISL	UCB$L_DEVDEPEND(R5),R1		; ..from UCB also
	JMP	G^EXE$FINISHIO			; Complete the I/O request

	.SBTTL	SENSEMODE_CTRL,  Perform SENSEMODE FDT processing for controller
 
;++
; SENSEMODE_CTRL - Perform SENSEMODE FDT processing for controller
;
; Functional description:
;
; This routine performs all FDT checking for a controller SENSEMODE request.
; The P2 buffer if present is check for write access and if okay, a system
; buffer is allocated for temporarily saving the needed information. The
; P1 sensemode information is returned through IRP$L_MEDIA and IRP$L_MEDIA+4.
;
; Inputs:
;
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;	R7 = Function code
;
; Outputs:
;
;	R0 = status return for request
;
;	R3-R5 are preserved.
;
;--
 
SENSEMODE_CTRL:					; Process controller sensemode FDT
	BBC	#IO$V_RD_COUNT,R7,20$		; Br if not read counters
;
; Read controller counters - modifier RD_COUNT
;
	BSBW	CHECK_P2			; Check P2 buffer
	MOVZWL	#SS$_BADPARAM,R0		; Assume zero length buffer
	MOVW	R1,IRP$L_MEDIA+2(R3)		; Save user P2 buffer size
	BEQL	30$				; Br if no P2 buffer
	MOVZWL	S^#LINE_CNT_BUFSIZ,R1		; Get size of controller counts
	BSBW	ALLOC_P2BUF			; Allocate a buffer
	BLBC	R0,30$				; Br if error
	MOVL	IRP$L_SVAPTE(R3),R1		; Get system P2 buffer address
	MOVL	R2,P2B_L_BUFFER(R1)		; Save user P2 buffer address
	MOVB	#<3@5>,IRP$L_MEDIA(R3)		; Get 2 counters
	MOVB	S^#XD_FC_V_RDGERR,IRP$B_XDFUNC(R3) ; Assume only read counts
	BBC	#IO$V_CLR_COUNT,R7,10$		; Br if not clear count request
	MOVB	S^#XD_FC_V_RCGERR,IRP$B_XDFUNC(R3) ; Else, Read and Clear
10$:	BRW	QUEPKT				; Queue packet to driver

20$:	BBC	#IO$V_RD_MEM,R7,40$		; Br if read tss request
;
; Read GSS address - modifier RD_MEM
;
	MOVZBL	P2(AP),R1			; Get GSS address
	CMPB	R1,S^#31			; Is GSS address too big?
	BGTRU	30$				; Br if yes - error
	MOVB	R1,IRP$L_MEDIA+6(R3)		; Save GSS address in IRP
	MOVZBL	S^#4,R1				; Check access to P1 buffer
	BSBW	CHECK_P1			; Check P1 buffer
	BSBW	ALLOC_P2BUF			; Allocate a P2 buffer
	BLBC	R0,30$				; Br if error
	MOVL	IRP$L_SVAPTE(R3),R1		; Get system buffer address
	MOVL	IRP$L_MEDIA(R3),P2B_L_BUFFER(R1) ; Set user buffer VA
	CLRL	IRP$L_MEDIA(R3)			; Indicate NOT a counter IRP
	MOVB	S^#XD_FC_V_RDGSS,IRP$B_XDFUNC(R3) ; Set function request
	BRB	10$				; Queue packet
 
30$:	BRW	ABORTIO				; Abort the I/O request
 
;
; Read controller parameters - no modifier
;
40$:	MOVZWL	S^#8,R1				; Size of P1 buffer if present
	BSBW	CHECK_BUFS			; Check P1 and P2 buffers
	MOVL	R1,IRP$L_MEDIA+4(R3)		; Save user P2 buffer length
	BEQL	60$				; Br if no P2 buffer
	MOVZWL	#LINE_PRM_BUFSIZ,R1		; Set size of required buffer
	BSBW	ALLOC_P2BUF			; Allocate a P2 buffer
	BLBC	R0,30$				; Br if error
	MOVL	IRP$L_SVAPTE(R3),R1		; Get system P2 buffer address
	MOVL	R2,P2B_L_BUFFER(R1)		; Set user's P2 buffer address
	MOVAB	LINE_PARAM,R1			; Get address of return table
	MOVL	R5,R4				; Get UCB address
	BSBW	RETURN_P2			; Return the P2 buffer data
	MOVW	S^#SS$_NORMAL,IRP$W_CSTATUS(R3)	; Assume success
	MOVW	IRP$W_BCNT(R3),R0		; Assume user has good size buffer
	CMPW	IRP$L_MEDIA+4(R3),R0		; Is user buffer large enough?
	BGEQU	50$				; Br if yes
	MOVW	#SS$_BUFFEROVF,IRP$W_CSTATUS(R3) ; Return partial success
	MOVW	IRP$L_MEDIA+4(R3),R0		; Set size of return
	MOVW	R0,IRP$W_BCNT(R3)		;	...
50$:	ASHL	#16,R0,R0			; Shift return buffer size
	MOVW	IRP$W_CSTATUS(R3),R0		; Set return status
 
60$:	MOVL	IRP$L_MEDIA(R3),R2		; Retrieve P1 buffer address
	BEQL	70$				; Br if none
	MOVQ	UCB$B_DEVCLASS(R5),(R2)		; Else, return characteristics
70$:	MOVL	UCB$L_DEVDEPEND(R5),R1		; Get device dependend info
	JMP	G^EXE$FINISHIO			; Complete the I/O request

	.SBTTL	SENSE_MODEM,  Perform SENSEMODE READ_MODEM FDT processing
 
;++
; SENSE_MODEM - Perform SENSEMODE READ_MODEM FDT processing
;
; Functional description:
;
; This routine performs all FDT checking for a SENSEMODE read modem request.
; The P1 buffer is checked for write access and the request is queued to the
; driver. When complete the P1 sensemode information is returned in IRP$L_MEDIA
; and IRP$L_MEDIA+4.
;
; Inputs:
;
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;	R7 = Function code
;
; Outputs:
;
;	R0 = status return for request
;
;	R3-R5 are preserved.
;
;--
 
SENSE_MODEM:					; Process read modem request
	MOVZWL	S^#4,R1				; Size of P1 buffer
	BSBB	CHECK_P1			; Check access to P1
						; (no return on no access)
	BSBW	ALLOC_P2BUF			; Allocate a P2 buffer
	BLBS	R0,10$				; Br if success
	BRW	ABORTIO				; Else, abort the I/O request
 
10$:	MOVL	IRP$L_SVAPTE(R3),R1		; Get system buffer address
	MOVL	IRP$L_MEDIA(R3),P2B_L_BUFFER(R1) ; Set user buffer VA
	CLRL	IRP$L_MEDIA(R3)			; Indicate NOT a counter IRP
	MOVB	S^#XD_FC_V_RDMODEM,IRP$B_XDFUNC(R3) ; Set function request
	;BRB	QUEPKT				; Give request to driver
 
;
; I/O Request packet to driver
;
QUEPKT:						; Queue packet to driver
	SETIPL	UCB$B_FIPL(R5)			; Raise IPL to fork IPL
	JSB	G^IOC$INITIATE			; Initiate I/O request
	JMP	G^EXE$QIORETURN			; Lower IPL, and RET

	.SBTTL	CHECK_BUFS,  Check P1 and P2 buffers for write access
 
;++
; CHECK_BUFS - Check P1 and P2 buffers for write access
;
; Functional description:
;
; This routines checks the P1 and P2 buffers for write access if supplied.
;
; Inputs:
;
;	R1 = Size of P1 buffer needed for write access
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;	R7 = Function code
;	R9 = CDB address
;
; Outputs:
;
;	R1 = Length of P2 buffer (zero if no P2 buffer)
;	R2 = Address of P2 buffer in user's process space
;
;	R0-R2 are destroyed.
;
;	No RETURN on NO ACCESS
;
; Implicit Outputs:
;
;	IRP$V_FUNC bit set in IRP$W_STS by EXE$READCHK subroutine.
;
;--
 
CHECK_BUFS:
	BSBB	CHECK_P1			; Check P1 buffer
CHECK_P2:
	CLRL	R1				; Assume no P2 buffer desc
	MOVL	P2(AP),R2			; Get address of P2 desc
	BEQL	10$				; Br if no P2
	IFNORD	#8,(R2),ACCESS			; Br if no access
	MOVZWL	(R2),R1				; Get length of buffer
	BICL	#1,R1				; Must be multiple of 2 bytes
	BEQL	10$				; Br if zero
	MOVL	DSC$A_POINTER(R2),R0		; Get buffer address
	JSB	G^EXE$READCHK			; Check write access to buffer
						; (no return no access)
						; Also sets IRP$V_FUNC in IRP
	MOVL	R0,R2				; Copy buffer address
10$:	RSB					; Return to caller
 
ACCESS:	MOVZWL	#SS$_ACCVIO,R0			; Return access violation
	BRW	ABORTIO				; Abort the I/O request

	.SBTTL	CHECK_P1,  Check P1 buffer address for write access
 
;++
; CHECK_P1 - Check P1 buffer address for write access
;
; Functional description:
;
;  This routine checks the P1 buffer and if okay, the buffer address
;  is saved in IRP$L_MEDIA of the IRP.
;
; Inputs:
;
;	R1 = Size of buffer for write access
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;	R7 = Function code
;	R9 = CDB address
;
; Outputs:
;
;	R0 is destroyed.
;
;	No RETURN on NO ACCESS.
;
; Implicit Outputs:
;
;	IRP$L_MEDIA(R3) = User P1 buffer address.
;	IRP$V_FUNC bit set in IRP$W_STS by EXE$READCHK subroutine.
;
;--

CHECK_P1:
	CLRL	IRP$L_MEDIA(R3)			; Assume no P1 buffer
	MOVL	P1(AP),R0			; Get address of user buffer
	BEQL	10$				; Br if none
	JSB	G^EXE$READCHK			; Check access to buffer
						; (No return - no access)
	MOVL	R0,IRP$L_MEDIA(R3)		; Save P1 buffer address in IRP
10$:	RSB					; Return to caller

	.SBTTL	ALLOC_P2BUF,  Allocate a P2 buffer and charge user's quota
 
;++
; ALLOC_P2BUF - Allocate a P2 buffer and charge user's quota
;
; Functional description:
;
; This routine allocates a system buffer and returns the address in the IRP at
; IRP$L_SVAPTE.  The size of the allocation, including buffer header must
; be at least 24 bytes in length.
;
; Inputs:
;
;	R1 = Size of allocation desired
;	R3 = IRP address
;
; Outputs:
;
;	R0 = status of request
;
;	R1-R5 are preserved.
;
; Implicit Outputs:
;
;	IRP$L_SVAPTE(R3) = address of system buffer
;	IRP$W_BOFF(R3) = byte count charged to user's process
;	IRP$W_BCNT(R3) = original byte count requested
;
;	All parts of the P2 buffer header are initialized, except for the
;	user's P2 buffer address.
;
;--
 
ALLOC_P2BUF:					; Allocate a non-paged buffer
	TSTL	R1				; Zero length buffer?
	BEQL	30$				; Br if yes
	PUSHR	#^M<R1,R2,R3>			; Save registers
	MOVW	R1,IRP$W_BCNT(R3)		; Save original byte count
	CMPL	R1,S^#24-P2B_C_LENGTH		; Is buffer big enough?
	BGTRU	5$				; Br if yes
	MOVL	S^#24-P2B_C_LENGTH,R1		; Else, set size to minimum
5$:	ADDL2	S^#P2B_C_LENGTH,R1		; Add in size of header
	JSB	G^EXE$BUFQUOPRC			; Check for buffered quota
	BLBC	R0,10$				; Branch if quota bad
;
; Quota OKAY, allocate buffer and copy info.
;
	PUSHL	R1				; Save size to charge user
	JSB	G^EXE$ALONONPAGED		; Go allocate a buffer
	BLBS	R0,20$				; Br if success
	TSTL	(SP)+				; Pop saved size
10$:	POPR	#^M<R1,R2,R3>			; Restore registers
	RSB					; Return with error code in R0
;
; System buffer allocated decrement user's quota
;
20$:	POPL	R3				; Restore user quota charge
	MOVAB	P2B_T_DATA(R2),P2B_L_POINTER(R2) ; Set address to start of data
	MOVW	R3,P2B_W_SIZE(R2)		; Save buffer size in buffer
	MOVB	S^#DYN$C_BUFIO,P2B_B_TYPE(R2)	; Set structure type
	MOVL	R2,R0				; Save P2 char buf addr
	MOVL	PCB$L_JIB(R4),R2		; Get JIB address
	SUBL	R3,JIB$L_BYTCNT(R2)		; Decrement user's quota
	POPR	#^M<R1,R2,R3>			; Restore registers
	MOVL	R0,IRP$L_SVAPTE(R3)		; Save P2 buffer address in IRP
	MOVW	P2B_W_SIZE(R0),IRP$W_BOFF(R3)	; Return buffer size in IRP
30$:	MOVZWL	S^#SS$_NORMAL,R0		; Set success
	RSB					; Return to caller

	.SBTTL	STARTIO,  Start I/O routine

;++
; STARTIO - Start a transmit, receive, or set mode operation
;
; Functional description:
;
; This routine is called when an IRP is given to EXE$QIODRVPKT.
; From here, depending on the type of function., the appropriate
; routine is called.
;	
; Inputs:
;
;	R3 = IRP address (I/O request packet)
;	R5 = UCB address (unit control block)
;	R9 = CDB address (only if circuit request)
;
;
;	IPL = FIPL
;
; Outputs:
;
;	R3,R5 are preserved.
;
;	The routine must preserve all registers except R0-R2 and R4.
;
;--

STARTIO:					; Process an I/O packet
	MOVZBL	IRP$B_XDFUNC(R3),R1		; Get the function code
	CMPB	R1,S^#XD_FC_V_INITC		; Startup device?
	BEQL	10$				; Branch if so
	MOVZWL	#SS$_DEVOFFLINE,R0		; Assume device not running
	BBS	#XM$V_ERR_FATAL,-		; Br if hung
		UCB$L_DEVDEPEND(R5),DRV_DONE	;
10$:	CASE	R1,TYPE=B,<START_TRIB,START_DEV,-
		TRIB_ACTIVE,DEV_ACTIVE,DEV_ACTIVE,-
		TRIB_ACTIVE,DEV_ACTIVE,TRIB_ERRS,-
		DEV_ACTIVE,TRIB_ERRS,DEV_ACTIVE,-
		TRIB_ACTIVE,DEV_ACTIVE,DEV_ACTIVE> ; Process function
;
; Other request types - if we fall thru case instruction.
;
	BUG_CHECK NOBUFPCKT,FATAL		; Fatal error
;
; Start up controller
;
START_DEV:					; Startup controller
	BSBB	STARTUP				; Startup device
	BLBC	R0,10$				; Br if error
	RSB					; Return to caller
;
; Error on startup - shutdown the controller
;
10$:	PUSHL	R0				; Else, save status return
	BSBW	SHUTDOWN_DEV			; Shutdown the device
	POPL	R0				; Restore status return
	;BRB	DRV_DONE			; Complete request in error
 
DRV_DONE:					; Driver request complete
	BRW	REQ_COM_ERR			; Complete the request

	.SBTTL	STARTUP,  Device initialization routine

;++
; STARTUP - Device initialization routine
;
; Functional description:
;
; The configuration is read from the P1 and P2 buffers and a MODE DEFINITION
; command is issued to the DMP11 device.  The buffers which have been set
; up for the common receive pool are then given to the device.
;
; Inputs:
;
;	R3 = IRP address
;	R5 = UCB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0 = status return for startup operation
;
;	R3,R5 are preserved
;
;--

STARTUP:					; Controller startup processing
	BBC	#UCB$V_XD_INITED,-		; Br if not inited yet
		UCB$W_DEVSTS(R5),5$ 		;
	MOVZWL	#SS$_DEVACTIVE,R0		; Else, device already active
	BSBW	REQ_COM_ERR			; Complete request in error
	MOVZBL	S^#SS$_NORMAL,R0		; DO NOT STOP CONTROLLER!
	RSB					; Return to caller
 
5$:	INSV	#0,#8,#24,UCB$L_DEVDEPEND(R5)	; Reset status and error flags
	MOVL	IRP$L_PID(R3),UCB$L_XD_PID(R5)	; Save starter's PID
	ASSUME	UCB$B_XD_OUTTIM EQ UCB$B_XD_INTIM+1
	CLRW	UCB$B_XD_INTIM(R5)		; Init timer cells
	SETBIT	#UCB$V_XD_INITING,UCB$W_DEVSTS(R5) ; Indicate device initing
;
; Initialize the buffer and I/O request queue heads
;
	MOVZWL	#UCB$C_XD_QUEUES,R0		; Set number of queue heads
	MOVAB	UCB$Q_XD_QUEUES(R5),R2		; Set address of first head
10$:	MOVAB	(R2),(R2)+			; Init forward link
	MOVAB	-4(R2),(R2)+			; Init backward link
	SOBGTR	R0,10$				; Br if more queues
;
; Initialize the transmit and receive mapping info vector.
;
	CLRL	UCB$L_XD_RUN(R5)		; Initialize tribs in run
	CLRL	UCB$L_XD_HALT(R5)		; Initialize halted tribs
	CLRB	UCB$B_XD_TRB_CNT(R5)		; Init number of active tribs
	MOVZWL	#MAX_RCV+MAX_XMT,R0		; Set number of rcv and xmit slots
	ASSUME	UCB$L_XD_RCV_MAP+<4*MAX_RCV> EQ UCB$L_XD_XMT_MAP
	MOVAL	UCB$L_XD_RCV_MAP(R5),R1		; Get map vector address
20$:	MNEGL	#1,(R1)+			; Indicate no map info.
	SOBGTR	R0,20$				; Br if more map slots
	MOVB	#MAX_RCV,UCB$B_XD_RCV_MAX(R5)	; Set max concurrent receives
	MOVB	#MAX_XMT,UCB$B_XD_XMT_MAX(R5)	; Set max concurrent transmits
	MOVW	IRP$W_QUOTA(R3),UCB$W_XD_QUOTA(R5) ; Store receive buffer quota
	CLRW	IRP$W_QUOTA(R3)			; No buffer quota to return
	DIVW3	UCB$W_DEVBUFSIZ(R5),-		; Compute quota for rcv buffers
		UCB$W_XD_QUOTA(R5),R1		;
	CMPB	R1,UCB$B_XD_RCV_MAX(R5)		; Is number less than max?
	BGEQU	30$				; Br if not - leave max alone
	MOVB	R1,UCB$B_XD_RCV_MAX(R5)		; Else, reduce max rcvs allowed
30$:	CLRW	IRP$W_BCNT(R3)			; No read buffer for I/O post
;
; Initialize vector areas of UCB
;
	MOVAL	UCB$L_XD_VECS(R5),R1		; Get address of start of vectors
	MOVZWL	#UCB$C_XD_VECS,R2		; Get number of longwords
35$:	CLRL	(R1)+				; Initialize vector area
	SOBGTR	R2,35$				; Loop if more
;
; Allocate map registers for recieve buffers and one transmit buffer (2?).
; The unbuffered datapath (DP0) is used for all I/O's du to the fact that
; the controller can initiate retransmissions but on the 11/780, the datapath
; requires purging before it can be reused.
;
	MOVW	UCB$W_DEVBUFSIZ(R5),UCB$W_BCNT(R5) ; Set buffer size
	MOVW	#511,UCB$W_BOFF(R5)		; Set worst case byte offset
	MOVL	UCB$L_CRB(R5),R4		; Get CRB address
	ASSUME	VEC$W_MAPREG+2 EQ VEC$B_NUMREG
	ASSUME	VEC$B_NUMREG+1 EQ VEC$B_DATAPATH
	CLRL	CRB$L_INTD+VEC$W_MAPREG(R4)	; Clear map register + datapath
	PUSHQ	R6				; Save R6,R7
	MOVAL	UCB$L_XD_RCV_MAP(R5),R6		; Get mapping slot address
	MOVZBL	UCB$B_XD_RCV_MAX(R5),R7		; Get number of rcv map slots
40$:	JSB	G^IOC$ALOUBAMAP			; Allocate a set of map registers
	BLBC	R0,50$				; Br if unavailable
	MOVL	CRB$L_INTD+VEC$W_MAPREG(R4),(R6)+ ; Save receive map info
	SOBGTR	R7,40$				; Br if more slots available
 
	JSB	G^IOC$ALOUBAMAP			; Allocate at least 1 set for xmits
	BLBC	R0,50$				; Br if unavailable
	MOVL	CRB$L_INTD+VEC$W_MAPREG(R4),-	; Save transmit map info
		UCB$L_XD_XMT_MAP(R5)		;
50$:	POPQ	R6				; Restore R6,R7
	BLBS	R0,60$				; Br if okay so far
	MOVZWL	#SS$_INSFMAPREG,R0		; Set insufficient map registers
	RSB					; Return with error
;
;  Now the DMP11 device is master cleared.  A timeout is setup to occur
;  in approximately one to two seconds.  That should give the DMP enough
;  time to run the micro-diagnostics. After the timeout, we will procede
;  and initialize the device.
;
;  We will use the WFIKPCH macro which will wait for interrupt or timeout,
;  but the interrupt should never occur - only the timeout!  It was a handy
;  way to schedule a 2 second timeout without a lot of fuss and bother.
;
60$:	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R4	; Get CSR address
	DSBINT	UCB$B_DIPL(R5)			; Disable device interrupts
	MOVB	#XD_BSEL1_M_MCLR,BSEL1(R4)	; Set the master clear bit
;
; WFIKPCH does not destroy R0, therefore R0 should still have SS$_NORMAL
; success return status.
;
	WFIKPCH	START_CONT,#2			; Wait 2 seconds for master clr

	.SBTTL	START_CONT,  Continue after timeout
 
;++
; START_CONT - Continue after timeout
;
; Functional description:
;
; This routine is called by the system after the startup timeout was set
; when the device was master cleared.
;
;
; Inputs:
;
;	R3 = IRP address
;	R4 = CSR address
;	R5 = UCB address
;
;	IPL = DIPL
;
; Outputs:
;
;	R5 is preserved.
;
;--
 
START_CONT:					; Continue with startup
	CLRBIT	#UCB$V_TIMOUT,UCB$W_STS(R5)	; Clear timeout status
	MOVAB	FORK_PROC,UCB$L_FPC(R5)		; Set fork process PC
	BITB	#XD_BSEL1_M_RUN,BSEL1(R4)	; Is run bit on?
	BEQL	10$				; Br if not - error
	CMPB	#^O305,BSEL6(R4)		; Successful master clear?
	BEQL	20$				; Yes, continue
10$:	MOVB	BSEL6(R4),UCB$L_DEVDEPEND+3(R5)	; Save BSEL6 on error
	INSQUE	(R3),@UCB$Q_XD_POST+4(R5)	; Insert IRP on posting Q
	ASHL	#XD_BSEL2_V_ERR+16,#1,R3	; Indicate fatal error
	ASHL	#16,#3,R4			; Indicate device error
	BRW	SCHED_FORK			; Request complete
	
;
; The device seems to be running - give mode definition
;
20$:	SETBIT	#UCB$V_XD_INITED,UCB$W_DEVSTS(R5) ; Indicate device inited
	CLRBIT	#UCB$V_XD_INITING,UCB$W_DEVSTS(R5) ; No longer initing
	BISB	#XD_BSEL0_M_IEO,BSEL0(R4)	; Enable output interrupts
	BBC	#XM$V_CHR_LOOPB,-		; Br if no loopback
		UCB$L_DEVDEPEND(R5),30$		;
	BISB	#XD_BSEL1_M_LOOPB,BSEL1(R4)	; Else, enable device loopback
30$:	INSQUE	(R3),UCB$Q_XD_INPUTQ(R5)	; Insert at front of input Q
	BRW	LOAD_PORT			; Request input port

	.SBTTL	START_TRIB,  Start tributary routine

;++
; START_TRIB - Start tributary routine
;
; Functional description:
;
; This routine is called when a tributary is to be established and started.
; The polling parameters are initialized also.
;
;  Inputs:
;
;	R3 = IRP address
;	R5 = UCB address
;	R9 = CDB address
;
;
;	IPL = FIPL
;
;  Outputs:
;
;	R5 is preserved.
;
;--

START_TRIB:					; Start tributary
	BBC	#CD_TS_V_ESTAB,CDB_W_STS(R9),10$ ; Br if trib not active
	MOVZWL	#SS$_DEVACTIVE,R0		; Else, trib already active
	BRW	IO_DONE				; Request complete
 
10$:	SETIPL	UCB$B_DIPL(R5)			; Sync access to device
	INSQUE	(R3),@UCB$Q_XD_INPUTQ+4(R5)	; Insert at end of input Q
	BRW	LOAD_PORT			; Request the CSR
						; Let return to IOC$INITIATE
						; ..clean up IPL

	.SBTTL	DEV_ACTIVE,  Device must be active

;++
; DEV_ACTIVE - Device must be active
;
; Functional description:
;
; This routine is called to queue a request to the device input queue.
; The routine must first verify that the device is active, before the
; request can be queued, however. If the device is not active, the request
; is posted in error.
;
; Inputs:
;
;	R3 = IRP address
;	R5 = UCB address
;
;	IPL = FIPL
;
; Outputs:
;
;	None.
;
;--
 
DEV_ACTIVE:					; Check if device is active
	BBS	#UCB$V_XD_INITED,UCB$W_DEVSTS(R5),10$ ; Br if device inited
	MOVZWL	#SS$_DEVINACT,R0		; Else, return error
	BRW	IO_DONE				; Finish I/O
 
10$:	SETIPL	UCB$B_DIPL(R5)			; Sync access to device
	INSQUE	(R3),@UCB$Q_XD_INPUTQ+4(R5)	; Insert at end of Q
	BRW	LOAD_PORT			; Give request to device
						; Let return to IOC$INITIATE
						; ..clean up IPL

	.SBTTL	TRIB_ACTIVE,  Tributary must be active

;++
; TRIB_ACTIVE - Tributary must be active
;
; Functional description:
;
; This routine is called to queue a request to the device for a tributary.
; The routine must first verify that the trib is active and if so, queue
; the request, else it must post the request in error.
;
; Inputs:
;
;	R3 = IRP address
;	R5 = UCB address
;	R9 = CDB address
;
;	IPL = FIPL
;
; Outputs:
;
;	None.
;
;--
 
TRIB_ACTIVE:					; Check if trib is active
	BBS	#CD_TS_V_ESTAB,CDB_W_STS(R9),10$ ; Br if trib established
	MOVZWL	#SS$_DEVINACT,R0		; Set error return
	BRW	IO_DONE				; Finish the request
 
10$:	SETIPL	UCB$B_DIPL(R5)			; Sync access to device
	INSQUE	(R3),@UCB$Q_XD_INPUTQ+4(R5)	; Insert at end of Q
	BRW	LOAD_PORT			; Load CSR's
						; Let return to IOC$INITIATE
						; ..clean up IPL

	.SBTTL	TRIB_ERRS,  Read trib errors routine

;++
; TRIB_ERRS - Read trib errors routine
;
; Functional description:
;
; This routine is called to read the tributary error counters.  All
; counters are read from the device except for data messages and bytes
; transmitted and received.  These counters are 32 bits in length and
; are kept by the driver itself.
;
; Inputs:
;
;	R3 = IRP address
;	R5 = UCB address
;	R9 = CDB address
;
;	IPL = FIPL
;
; Outputs:
;
;	The error counters are returned and the request is completed.
;
;--

TRIB_ERRS:
	BBS	#CD_TS_V_ESTAB,CDB_W_STS(R9),10$ ; Br if trib established
	MOVZWL	#SS$_DEVINACT,R0		; Set error return
	BRW	IO_DONE				; Finish the request
 
10$:	MOVL	IRP$L_SVAPTE(R3),R2		; Get system P2 address
	BEQL	20$				; Br if none
	MOVAB	TRIB_COUNTER,R0			; Get address of counter codes
	MOVL	(R2),R1				; Get address of data
	PUSHQ	R2				; Save P2 buffer address + IRP
	MOVAL	CDB_L_CNTS(R9),R2		; Get address of counts
	ASSUME	CDB_C_CNTS EQ 16		; Assume 16 bytes of XD counts
	MOVZWL	S^#4,R3				; Set number of counters
 
15$:	MOVW	(R0)+,(R1)+			; Set next code
	MOVL	(R2)+,(R1)+			; Set next value
	SOBGTR	R3,15$				; Loop if more
 
	POPQ	R2				; Restore P2 buffer address + IRP
	MOVL	R1,(R2)				; Reset address of next byte
	CMPB	#XD_FC_V_RCTERR,IRP$B_XDFUNC(R3) ; Is this a clear counter?
	BNEQ	20$				; Br if not
	CLRQ	CDB_L_CNTS(R9)			; Else, clear counters
	CLRQ	CDB_L_CNTS+8(R9)		;	...

20$:	SETIPL	UCB$B_DIPL(R5)			; Sync access to device
	INSQUE	(R3),@UCB$Q_XD_INPUTQ+4(R5)	; Insert at end of Q
	BRW	LOAD_PORT			; Give to device
						; Let return to IOC$INITIATE
						; ..clean up IPL

	.SBTTL	FILLRCVLIST,  Fill receive buffer list
	.SBTTL	ADDRCVLIST,  Add a buffer to the receive list

;++
; FILLRCVLIST - Fill receive buffer list
; ADDRCVLIST - Add a buffer to the receive list
;
; Functional description:
;
; This routine is entered to make sure that the receive buffer pool
; is full.  If it is not, buffers are allocated and queued to the
; list until it is.
;
; Inputs:
;
;	R2 = Buffer address (ADDRCVLIST only)
;	R5 = UCB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0-R2 are destroyed.
;
;--
	.ENABL	LSB
FILLRCVLIST:					; Fill receive buffer list
	BBC	#UCB$V_XD_INITED,-		; Exit if not inited
		UCB$W_DEVSTS(R5),40$		;
	CLRL	R2				; No buffer here

ADDRCVLIST:					; Add a buffer to the receive list
	PUSHQ	R3				; Save R3, R4
5$:	CMPW	UCB$W_DEVBUFSIZ(R5),-		; Can new block be allocated?
		UCB$W_XD_QUOTA(R5)		;
	BGTRU	20$				; Br if no - list filled
	CLRL	R1				; Zero size
	ADDW3	#RCV_T_DATA+CXB$C_TRAILER,-	; Compute block size needed
		UCB$W_DEVBUFSIZ(R5),R1		;
	TSTL	R2				; Buffer already allocated?
	BNEQ	7$				; Br if yes
	JSB	G^EXE$ALONONPAGED		; Allocate nonpaged memory
	BLBC	R0,10$				; Br if failure
7$: 	MOVW	R1,RCV_W_BLKSIZE(R2)		; Insert block size
	MOVB	S^#DYN$C_NET,RCV_B_BLKTYPE(R2)	; Insert block type
	INSQUE	(R2),UCB$Q_XD_RCV_BUF(R5)	; Insert block on free receive list
	SUBW	UCB$W_DEVBUFSIZ(R5),-		; Decrement quota
		UCB$W_XD_QUOTA(R5)		;
	CLRL	R2				; No more buffers given
	BRB	5$				; Try for more
;
; Buffer allocation failure
;
10$:	SETBIT	#XM$V_STS_BUFFAIL,-		; Set buffer alloc failure
		UCB$L_DEVDEPEND(R5)		;
	BRB	30$				; And give any receives to device
 
20$:	CLRBIT	#XM$V_STS_BUFFAIL,-		; Clear buffer alloc failure
		UCB$L_DEVDEPEND(R5)		;
	MOVL	R2,R0				; Get address of buffer
	BEQL	30$				; Br if none
	JSB	G^COM$DRVDEALMEM		; Deallocate it
 
30$:	DSBINT	UCB$B_DIPL(R5)			; Sync access to device
	BSBB	START_RECEIVE			; Start the receives
	ENBINT					; Restore previous IPL
	POPQ	R3				; Restore R3, R4
40$:	RSB					; Return
	.DSABL	LSB

	.SBTTL	START_RECEIVE,  Start any receive requests pending
 
;++
; START_RECEIVE - Start any receive requests
;
; Functional description:
;
; This routine attemptes to start any receives that may be pending.  This
; involves dequeueing a free receive buffer, mapping it, and loading it's
; address and size into the device.
;
; Inputs:
;
;	R5 = UCB address
;
;	IPL = DIPL
;
; Outputs:
;
;	R5 is preserved.
;
;	R0-R4 are destroyed
;
;--
 
START_RECEIVE:					; Start receive operation
	MOVZBL	UCB$B_XD_RCV_MAX(R5),R1		; Get max concurrent receives
	FFC	#0,R1,UCB$B_XD_RCV_MAP(R5),R1	; Get a free mapping slot
	BEQL	10$				; Br if none - just exit
	REMQUE	@UCB$Q_XD_RCV_BUF(R5),R3	; Get a free buffer
	BVC	20$				; Br if buffer found
10$:	RSB					; Return to caller
;
; Mark slot in use and create buffer address/character count image
; in receive buffer and load UNIBUS adapter map registers.
;
20$:	SETBIT	R1,UCB$B_XD_RCV_MAP(R5)		; Mark slot in use
	MOVB	R1,RCV_B_MAPSLOT(R3)		; Save mapping slot index
	MOVAL	UCB$L_XD_RCV_MAP(R5)[R1],R4	; Get mapping info slot address
	MOVAB	RCV_T_DATA(R3),R1		; Get receive buffer data addr
	MOVW	R1,RCV_L_BACC(R3)		; Set BA0-BA8
	MOVW	UCB$W_DEVBUFSIZ(R5),-		; Insert character count
		RCV_L_BACC+2(R3)		;
	INSV	(R4),#9,#7,RCV_L_BACC(R3)	; Set BA9-BA15 from map reg
	EXTZV	#7,#2,(R4),R0			; Get BA16-BA17 also
	INSV	R0,#30,#2,RCV_L_BACC(R3)	; Set BA16-BA17
 
	PUSHL	R3				; Save buffer address
	MOVZWL	2(R4),R2			; Set number of map registers
	MOVZWL	(R4),R3				; Set first map register number
	CLRL	R4				; Use unbuffered datapath
	JSB	G^IOC$LOADUBAMAPN		; Load the map registers
	POPL	R3				; Restore buffer address
	INSQUE	(R3),UCB$Q_XD_INPUTQ(R5)	; Insert receive buffer at
						;   FRONT of input queue
	BSBB	LOAD_PORT			; Request port and give request
	BRB	START_RECEIVE			; Let's try it again

	.SBTTL	LOAD_PORT,  Request CSR routine

;++
; LOAD_PORT -  Request CSR port routine
;
; Functional description:
;
; Request the controller's input port to give it a request.  Since the
; controller doesn't service the input port when it is busy, we may have
; to request an interrupt to service the request.  The input request is
; assume to be on the input waiting queue.
;
;
; Inputs:
;
;	R5 = UCB address
;
;	IPL = DIPL
;
; Outputs:
;
;	R0 = Success if port loaded immediately
;	R1-R3,R9 = destroyed.
;	R4 = CSR address
;
;--

LOAD_PORT:					; Give next request to device
	MOVL	UCB$L_CRB(R5),R4		; Get CRB address
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R4	; Get CSR address
	BITB	#XD_BSEL0_M_RQI,(R4)		; Is an input request pending?
	BNEQ	10$				; Br if yes - wait for interrupt
	BISB	#XD_BSEL0_M_RQI,(R4)		; Request input port
	MOVZWL	S^#5,R3				; Spin loop count
5$:	BITB	#XD_BSEL2_M_RDO,BSEL2(R4)	; Is an output interrupt pend?
	BNEQ	10$				; Br if yes - wait for interrupt
	TIMEWAIT #1,#XD_BSEL2_M_RDI,SEL2(R4),W	; Wait for RDI to be set-10uSEC
	BLBS	R0,LOAD_PORT_AVAIL		; Br if true - port is available
	SOBGTR	R3,5$				; Loop if more time left
;
; Port is not currently available - request an interrupt to process the input.
;
10$:	BISB	#XD_BSEL0_M_IEI,(R4)		; Request input interrupt
	BSBW	SET_INTIM			; Start input wait timer
	CLRL	R0				; Indicate failure to get port
	RSB					; Return to caller
 
;
; Port is available - load request into CSRs
;
LOAD_PORT_AVAIL:				; Load CSR ports
	BICB	#XD_BSEL0_M_RQI,(R4)		; Clear request for port
	REMQUE	@UCB$Q_XD_INPUTQ(R5),R3		; Get next request on input Q
	BVC	10$				; Br if one there
	MOVB	#XD_CI_V_NOOP,BSEL6(R4)		; Else, release input port
	MOVW	#XD_I_V_CONTROL,SEL2(R4)	; Set request type, clear RDI
	RSB					; Return to caller
;
; Give request from input queue to device
;
10$:	CMPB	IRP$B_TYPE(R3),S^#DYN$C_IRP	; Is buffer an IRP ?
	BEQL	30$				; Br if yes - dispatch
	CMPB	IRP$B_TYPE(R3),S^#DYN$C_NET	; Is this a receive msg?
	BEQL	20$				; Br if yes
	BUG_CHECK NOBUFPCKT,FATAL		; Else, fatal error
;
; Load receive request
;
20$:	MOVW	RCV_L_BACC(R3),SEL4(R4)		; Load buffer address
	MOVW	RCV_L_BACC+2(R3),SEL6(R4)	;  and character count
	MOVW	#XD_I_V_RCV,SEL2(R4)		; Set request type, clear RDI
						;  for trib #0
	INSQUE	(R3),@UCB$Q_XD_RCV_PND+4(R5)	; Insert on end of pending Q
	RSB					; Return to caller
;
; Dispatch to input process handler
;
30$:	MOVB	IRP$B_XDFUNC(R3),R1		; Get specific request
	BSBB	IN_DISP				; Dipatch to input service
	MOVZWL	S^#SS$_NORMAL,R0		; Indicate port success
	RSB
 
IN_DISP:					; Dispatch to input service
	CASE	R1,TYPE=B,<IN_INITT,IN_INITC,-
		IN_STOPT,IN_STOPC,IN_CHGC,IN_CHGT,-
		IN_RDMODEM,IN_RDTERR,IN_RDGERR,-
		IN_RCTERR,IN_RCGERR,IN_RDTSS,-
		IN_RDGSS,IN_WTMODEM,IN_HALTT,-
		IN_KILLT,IN_XMIT,IN_RECV,IN_HALTT,-
		IN_NUMSYNC,IN_POLSTAT>		; Dispatch on request type
;
; OTHERS: if not one of the above, then error
;
	BUG_CHECK NOBUFPCKT,FATAL		; Fatal error
 
 
;+
; Establish tributary
;-
IN_INITT:					; Initialize tributary
	BSBW	GET_CDB				; Get CDB address
	BLBS	R0,10$				; Br if CDB found
	BRW	REQ_ABORT			; Else, abort the request
 
10$:	BBSS	#CD_TS_V_ESTAB,CDB_W_STS(R9),20$ ; Br if trib established
						; and indicate trib established
	MOVW	#XD_CI_V_ESTAB!XD_SEL6_M_ECOM,-	; Establish the trib
		SEL6(R4)			;
	MOVB	IRP$Q_STATION(R3),BSEL3(R4)	; Give trib address
	MOVB	#XD_I_V_CONTROL,BSEL2(R4)	; Give request, clear RDI
	INSQUE	(R3),UCB$Q_XD_INPUTQ(R5)	; Insert at front of input Q
	BRW	LOAD_PORT			; Request input again
 
20$:						; Start tributary
	MOVW	S^#XD_CI_V_ISTRT,SEL6(R4)	; ISTRT the trib
	BBC	#XM$V_CHR_MOP,CDB_L_DEVDEPEND(R9),30$ ; Br if not MOP mode
	SETBIT	#XM$V_STS_RUNNING,-		; Indicate trib running
		CDB_L_DEVDEPEND(R9)		;
	MOVW	S^#XD_CI_V_MAINT,SEL6(R4)	; Else, MOP mode
30$:	BISW	#XD_SEL6_M_ECOM,SEL6(R4)	; Enable common buffers
	MOVB	CDB_B_MRB(R9),BSEL4(R4)		; Set buffer quota
	MOVB	IRP$Q_STATION(R3),BSEL3(R4)	; Set trib address
	MOVB	S^#XD_I_V_CONTROL,BSEL2(R4)	; Give request, clear RDI
 
	SETBIT	#XM$V_STS_ACTIVE,-		; Indicate trib active
		CDB_L_DEVDEPEND(R9)		;
	MOVB	#255,IRP$L_MEDIA(R3)		; Set 8 parameters
	MOVB	#XD_FC_V_CHGT,IRP$B_XDFUNC(R3)	; Set new function request
	INSQUE	(R3),UCB$Q_XD_INPUTQ(R5)	; Insert at front of Q
	BRW	LOAD_PORT			; Request port again
;+
; Define mode
;-
IN_INITC:					; Give mode definition
	MOVB	UCB$B_XD_MODE(R5),BSEL6(R4)	; Set mode of operation
	MOVW	#XD_I_V_MODE_DEF,SEL2(R4)	; Give request, clear RDI
	MOVB	#<15@4>,IRP$L_MEDIA(R3)		; Set 4 parameters
	MOVB	#XD_FC_V_CHGC,IRP$B_XDFUNC(R3)	; Set new function request
	INSQUE	(R3),UCB$Q_XD_INPUTQ(R5)	; Insert at front of Q
	BRW	LOAD_PORT			; Request port again
;+
; Stop tributary
;-
	.ENABL	LSB
IN_STOPT:					; Stop tributary
	BSBW	GET_CDB				; Get CDB address
	BLBS	R0,10$				; Br if CDB present
5$:	BRW	REQ_ABORT			; Else, abort the request
 
10$:	BBSC	#CD_TS_V_BUFRET,CDB_W_STS(R9),20$ ; Br if buffers back
	BBS	#XM$V_ERR_TRIB,-		; Br if trib error
		CDB_L_DEVDEPEND(R9),12$		; ..try to halt trib
	BBC	#XM$V_STS_ACTIVE,-		; Br if already halted
		CDB_L_DEVDEPEND(R9),15$		; ..trib halted itself
12$:	MOVW	S^#XD_CI_V_HALT,SEL6(R4)	; Halt the trib
	MOVB	IRP$Q_STATION(R3),BSEL3(R4)	; Set trib address
	MOVB	S^#XD_I_V_CONTROL,BSEL2(R4)	; Set request, clear RDI
	BICL	#XM$M_STS_ACTIVE!XM$M_STS_RUNNING,- ; Indicate trib halted
		CDB_L_DEVDEPEND(R9)		;	...
15$:	INSQUE	(R3),@CDB_Q_INFOUT+4(R9)	; Wait for buffer returns
	BSBW	SET_OUTTIM			; Start output wait timer
	RSB					;
 
IN_KILLT:					; Kill trib request
20$:	BBC	#UCB$V_XD_INITED,-		; Br if device halted
		UCB$W_DEVSTS(R5),5$		; ..and abort request
	MOVW	S^#XD_CI_V_KILL,SEL6(R4)	; Set to kill trib
	MOVB	IRP$Q_STATION(R3),BSEL3(R4)	; Set trib address
	MOVB	S^#XD_I_V_CONTROL,BSEL2(R4)	; Give request, clear RDI
	BRW	REQ_COM				; Request complete
	.DSABL	LSB
;+
; Stop controller
;-
IN_STOPC:
	BBSS	#UCB$V_XD_DTRCLR,UCB$W_DEVSTS(R5),10$ ; Br if DTR is clear
	CLRW	SEL4(R4)			; Clear DTR
	MOVB	#XD_CI_V_WTMODEM,BSEL6(R4)	; Set request type
	MOVW	#XD_I_V_CONTROL,SEL2(R4)	; Give request, clear RDI
	INSQUE	(R3),UCB$Q_XD_INPUTQ(R5)	; Insert at front of Q
	BRW	LOAD_PORT

10$:	CLRBIT	#UCB$V_XD_DTRCLR,UCB$W_DEVSTS(R5) ; Clear DTR flag
	MOVB	#XD_BSEL1_M_MCLR,BSEL1(R4)	; Master clear device

REQ_COM1:					; Long branch to REQ_COM
	BRW	REQ_COM				; Request complete
;+
; Change controller parameters
;-
IN_CHGC:					; Change controller parameters
	BBC	#UCB$V_XD_INITED,-		; Br if device not inited
		UCB$W_DEVSTS(R5),DEV_INACT1	; ..to device offline
	FFS	#0,#8,IRP$L_MEDIA(R3),R1	; Find next bit set
	CLRBIT	R1,IRP$L_MEDIA(R3)		; Indicate parameter set
	MOVW	UCB$W_XD_POLLPRM-<2*4>(R5)[R1],- ; Set parameter value
		SEL4(R4)			;	...
	ADDW3	#24,R1,SEL6(R4)			; Set GSS address
	BISB	#XD_SEL6_M_WTSS,BSEL6(R4)	; Request write of GSS
	MOVW	S^#XD_I_V_CONTROL,SEL2(R4)	; Set request, clear RDI
	TSTB	IRP$L_MEDIA(R3)			; All done?
	BEQL	20$				; If EQL, yes
10$:	INSQUE	(R3),UCB$Q_XD_INPUTQ(R5)	; Insert at front of Q
	BRW	LOAD_PORT			; Request port again
;
; Check if number of sync chars given
;
20$:	TSTB	UCB$B_XD_NMS(R5)		; Is number of sync chars given
	BEQL	REQ_COM1			; Br if not - all done
	MOVB	#XD_FC_V_NUMSYNC,IRP$B_XDFUNC(R3) ; Set new function request
	BRB	10$				; Give new request to device
;+
; Set number of sync chars
;-
IN_NUMSYNC:
	BBC	#UCB$V_XD_INITED,-		; Br if device not inited
		UCB$W_DEVSTS(R5),DEV_INACT1	; ..to device offline
	MOVB	UCB$B_XD_NMS(R5),BSEL4(R4)	; Set parameter value
	MOVW	#XD_SEL6_M_WTSS!27,SEL6(R4)	; Set GSS address + WRITE TSS
	MOVW	S^#XD_I_V_CONTROL,SEL2(R4)	; Set request, clear RDI
	BRW	REQ_COM				; Request complete
;+
; Change tributary
;-
	.ENABL	LSB
IN_CHGT:					; Change controller parameters
	BSBW	GET_CDB				; Get CDB address
	BLBS	R0,10$				; Br if CDB present
	BRW	REQ_ABORT			; Else, abort the request

10$:	BBS	#CD_TS_V_ESTAB,-		; Br if trib inited
		CDB_W_STS(R9),20$		;	...
DEV_INACT1:					; Long branch to inactive
	BRW	DEV_INACT			; Br to device inactive
 
20$:	FFS	#0,#8,IRP$L_MEDIA(R3),R1	; Find next bit set
	CLRBIT	R1,IRP$L_MEDIA(R3)		; Indicate parameter set
	MOVW	CDB_W_POLLPRM(R9)[R1],SEL4(R4)	; Set parameter value
	ADDW3	#24,R1,SEL6(R4)			; Set TSS address
	BISB	#XD_SEL6_M_WTSS,BSEL6(R4)	; Request write of TSS
	MOVB	IRP$Q_STATION(R3),BSEL3(R4)	; Set trib address
	MOVB	S^#XD_I_V_CONTROL,BSEL2(R4)	; Set request, clear RDI
	TSTB	IRP$L_MEDIA(R3)			; All done?
	BEQL	40$				; If EQL, yes
30$:	INSQUE	(R3),UCB$Q_XD_INPUTQ(R5)	; Insert at front of Q
	BRW	LOAD_PORT			; Request port again
;
; Set new polling state - if needed else unlatch poll state
;
40$:	MOVB	#XD_FC_V_POLSTAT,IRP$B_XDFUNC(R3) ; Set new request
	BRB	30$				; Ask for port again	
	.DSABL	LSB
;+
; Set new Poll State
;-
IN_POLSTAT:
	BSBW	GET_CDB				; Get CDB address
	BLBS	R0,10$				; Br if CDB present
	BRW	REQ_ABORT			; Else, abort the request

10$:	BBC	#CD_TS_V_ESTAB,-		; Br if trib NOT inited
		CDB_W_STS(R9),DEV_INACT1	;	...
	ASSUME	NMA$C_CIRPST_AUT EQ 1
	ASSUME	NMA$C_CIRPST_ACT EQ 2
	ASSUME	NMA$C_CIRPST_INA EQ 3
	ASSUME	NMA$C_CIRPST_DIE EQ 4
	ASSUME	NMA$C_CIRPST_DED EQ 5
	CASE	CDB_B_POL(R9),TYPE=B,<-
		20$,-				; Nothing - unlatch
		20$,-				; AUTOMATIC - unlatch
		30$,-				; ACTIVE - latch
		40$,-				; INACTIVE - latch
		50$,-				; DYING - latch
		60$>				; DEAD - latch

20$:	MOVW	#XD_SEL6_M_UPOL,SEL6(R4)	; Unlatch polling state
	BRB	80$				; Continue

30$:	CLRB	BSEL4(R4)			; Latch at ACTIVE
	BRB	70$				;
40$:	MOVB	S^#1,BSEL4(R4)			; Latch at INACTIVE
	BRB	70$				;
50$:	MOVB	S^#2,BSEL4(R4)			; Latch at DYING
	BRB	70$				;
60$:	MOVB	S^#3,BSEL4(R4)			; Latch at DEAD
70$:	MOVW	#XD_SEL6_M_LPOL,SEL6(R4)	; Latch the poll state

80$:	MOVB	IRP$Q_STATION(R3),BSEL3(R4)	; Set trib address
	MOVB	S^#XD_I_V_CONTROL,BSEL2(R4)	; Set request, clear RDI
	BRW	REQ_COM				; Request complete
;+
; Read modem request
;-
IN_RDMODEM:					; Read modem register
	BBS	#UCB$V_XD_INITED,-		; Br if device inited
		UCB$W_DEVSTS(R5),10$		; 
	BRW	DEV_INACT			; Else, device inactive

10$:	MOVW	S^#XD_CI_V_RDMODEM,SEL6(R4)	; Set to read modem register
	MOVW	S^#XD_I_V_CONTROL,SEL2(R4)	; Set request, clear RDI
	INSQUE	(R3),@UCB$Q_XD_INFOUT+4(R5)	; Insert request at end of Q
	BSBW	SET_OUTTIM			; Set output wait timer
	RSB
;+
; Transmit request
;-
	.ENABL	LSB
IN_XMIT:					; Transmit request
	BSBW	GET_CDB				; Get CDB address
	BLBS	R0,20$				; Br if okay
10$:	MOVB	S^#XD_CI_V_NOOP,BSEL6(R4)	; Set noop request
	MOVW	S^#XD_I_V_CONTROL,SEL2(R4)	; Set request type, clear RDI
	BRW	REQ_ABORT			; And abort the request

20$:	BBC	#XM$V_STS_ACTIVE,-		; Br if trib not active
		CDB_L_DEVDEPEND(R9),10$		;
	MOVW	IRP$L_MEDIA(R3),SEL4(R4)	; Load buffer address
	MOVW	IRP$L_MEDIA+2(R3),SEL6(R4)	;   and character count
	MOVB	IRP$Q_STATION(R3),BSEL3(R4)	; Set trib address
	MOVB	S^#XD_I_V_XMIT,BSEL2(R4)	; Set request, clear RDI
	INSQUE	(R3),@CDB_Q_XMT_PND+4(R9)	; Insert at end of pending Q
	RSB					;
;+
; Receive request
;-
IN_RECV:					; Bump receive buffer quota
	BSBW	GET_CDB				; Get CDB address
	BLBC	R0,10$				; Br if error
	BBC	#XM$V_STS_ACTIVE,-		; Br if trib not active
		CDB_L_DEVDEPEND(R9),10$ 	;
	MOVB	S^#1,BSEL4(R4)			; Else, bump quota by 1 buffer
	MOVW	#XD_SEL6_M_ECOM,SEL6(R4)	; Set request type
	MOVB	IRP$Q_STATION(R3),BSEL3(R4)	; Set trib address
	MOVB	S^#XD_I_V_CONTROL,BSEL2(R4)	; Set request, clear RDI
	BRW	REQ_COM
	.DSABL	LSB
;+
; Read selected tss address
;-
IN_RDTSS:					; Read tss address
	BSBW	GET_CDB				; Get CDB address
	BLBS	R0,10$				; Br if got it
	BRW	REQ_ABORT			; Else, abort the request

10$:	MOVB	IRP$L_MEDIA+6(R3),BSEL6(R4)	; Set tss address
	BISB	#XD_SEL6_M_RTSS,BSEL6(R4)	; Read the tss address
	BRB	IN_READT			; Join common code
;+
; Read tributary counters
;-
	.ENABL	LSB
IN_RDTERR:					; Read tributary counters
	MOVW	S^#XD_SEL6_M_RTSS,-(SP)		; Set to read TSS
	BRB	10$				; Continue

;+
; Read and clear tributary counters
;-
IN_RCTERR:					; Read and clear trib counters
	MOVW	#XD_SEL6_M_RCTS,-(SP)		; Set to read and clear TSS

10$:	BSBW	GET_CDB				; Get CDB address
	BLBS	R0,15$				; Br if got one
	BRW	REQ_ABORT			; Else, abort the request

15$:	BBS	#CD_TS_V_ESTAB,-		; Br if trib established
		CDB_W_STS(R9),20$		;
	BRW	DEV_INACT_SP			; Else, device inactive
 
20$:	FFS	#0,#8,IRP$L_MEDIA(R3),R1	; Get next counter index
	ADDW3	#8,R1,SEL6(R4)			; Calculate TSS address
	BISW	(SP)+,SEL6(R4)			; Set read mode
	.DSABL	LSB
IN_READT:					; Finish read tss request
	MOVB	IRP$Q_STATION(R3),BSEL3(R4)	; Set tributary address
	MOVB	S^#XD_I_V_CONTROL,BSEL2(R4)	; Set request, clear RDI
	INSQUE	(R3),@CDB_Q_INFOUT+4(R9)	; Insert request at end of Q
	BSBW	SET_OUTTIM			; Start output wait timer
	RSB					; Return to caller
;+
; Read selected gss address
;-
IN_RDGSS:					; Read gss address
	MOVB	IRP$L_MEDIA+6(R3),BSEL6(R4)	; Set gss address
	BISB	S^#XD_SEL6_M_RTSS,BSEL6(R4)	; Request read of gss address
	BRB	IN_READG			; Finish read gss
;+
; Read global counters
;-
	.ENABL	LSB
IN_RDGERR:					; Read global counters
	MOVW	S^#XD_SEL6_M_RTSS,-(SP)		; Set to read GSS
	BRB	10$				; Continue

;+
; Read and clear global counters
;-
IN_RCGERR:					; Read global counters
	MOVW	#XD_SEL6_M_RCTS,-(SP)		; Set to read and clear GSS

10$:	BBC	#UCB$V_XD_INITED,-		; Br if device not inited
		UCB$W_DEVSTS(R5),DEV_INACT_SP	; ..to device inactive
	FFS	#0,#8,IRP$L_MEDIA(R3),R1	; Get next counter index
	ADDW3	#8,R1,SEL6(R4)			; Calculate GSS address
	BISW	(SP)+,SEL6(R4)			; Set read mode
	.DSABL	LSB
IN_READG:					; Finish read gss request
	MOVW	S^#XD_I_V_CONTROL,SEL2(R4)	; Set request, clear RDI
						;  for trib #0
	INSQUE	(R3),@UCB$Q_XD_INFOUT+4(R5)	; Insert request at end of Q
	BSBW	SET_OUTTIM			; Start output wait timer
	RSB					; Return to caller
;+
; Write modem request
;-
IN_WTMODEM:					; Write modem register
	MOVB	S^#XD_CI_V_WTMODEM,BSEL6(R4)	; Write modem request
	MOVW	IRP$L_MEDIA(R3),SEL4(R4)	; Set new modem values
	MOVW	S^#XD_I_V_CONTROL,SEL2(R4)	; Set request, clear RDI
	BRB	REQ_COM				; Request complete
;+
; Halt trib
;-
IN_HALTT:					; Halt trib - no status checks
	BBC	#UCB$V_XD_INITED,-		; Br if device halted
		UCB$W_DEVSTS(R5),REQ_ABORT	; ..and abort the request
	MOVB	S^#XD_CI_V_HALT,BSEL6(R4)	; Halt trib request
	MOVB	IRP$Q_STATION(R3),BSEL3(R4)	; Set trib address
	MOVB	S^#XD_I_V_CONTROL,SEL2(R4)	; Set request, clear RDI
	BRB	REQ_COM				; Request complete
;+
; Device inactive
;-
DEV_INACT_SP:					; Device inactive and pop stack
	TSTW	(SP)+				; Pop one word from stack
DEV_INACT:					; Device inactive
	MOVW	#SS$_DEVINACT,R0		; Set error return code
	MOVB	S^#XD_CI_V_NOOP,BSEL6(R4)	; Set noop request
	MOVW	S^#XD_I_V_CONTROL,SEL2(R4)	; Set request type, clear RDI
	BRB	REQ_COM_ERR			; Complete request
;+
; Complete request
;-
REQ_ABORT:					; Abort request
	MOVW	#SS$_ABORT,R0			; Set status return
	BRB	REQ_COM_ERR			; Complete request in error
REQ_COM:					; Request complete
	MOVW	S^#SS$_NORMAL,R0		; Return success
REQ_COM_ERR:
	MOVW	R0,IRP$W_CSTATUS(R3)		; Set completion status
	INSQUE	(R3),@UCB$Q_XD_POST+4(R5)	; Insert IRP on completion Q
	BRW	SCHED_FORKC			; Schedule a fork process

	.SBTTL	RDI_INTRPT,  CSR Ready Input Interrupt Service Routine

;++
; RDI_INTRPT  -  CSR Ready Input Interrupt Service Routine
;
; Functional description:
;
; This routine is called when an interrupt occurs to give an input waiting
; request to the controller.  Prior to execution of this routine, a request
; was made to LOAD_PORT, but the port was unavailable at that time.
;
;
; Inputs:
;
;	00(SP) = address of IDB address
;	04(SP) - 1C(SP) = R0 - R5 
;
;	IPL = DIPL
;
; Outputs:
;
;	The request is loaded and if there are more requests pending,
;	they are given until there are no more.  Finally, the interrupt
;	is dismissed.
;
;--

RDI_INTRPT:
	MOVL	@(SP)+,R4			; Get IDB address
	PUSHL	R9				; Save R9
	MOVL	IDB$L_UCBLST(R4),R5		; Get UCB address
	MOVL	(R4),R4				; Get CSR address
	BICB	#XD_BSEL0_M_IEI!XD_BSEL0_M_RQI,(R4) ; Clear input request flags
	BBC	#UCB$V_XD_INITED,-		; Exit if controller not inited
		UCB$W_DEVSTS(R5),INTERR		;
	CLRB	UCB$B_XD_INTIM(R5)		; Reset input wait timer
;
; Find CDB address
;
	REMQUE	@UCB$Q_XD_INPUTQ(R5),R3		; Get next request on input Q
	BVS	INTERR				; Br if none - error
	INSQUE	(R3),UCB$Q_XD_INPUTQ(R5)	; Re-insert packet on Q
	BSBW	LOAD_PORT_AVAIL			; Load CSRs
 
10$:	REMQUE	@UCB$Q_XD_INPUTQ(R5),R3		; Get next request on input Q
	BVS	INTEXIT				; Br if none - exit
	INSQUE	(R3),UCB$Q_XD_INPUTQ(R5)	; Re-insert packet on Q
	BSBW	LOAD_PORT			; Load CSRs
	BLBS	R0,10$				; Br if port was available
;
; Exit interrupt
;
INTEXIT:					; Exit interrupt
	POPL	R9				; Restore R9
	MOVQ	(SP)+,R0			; Restore registers
	MOVQ	(SP)+,R2			;
	MOVQ	(SP)+,R4			;
	REI					; Return from interrupt.
;
; An input interrupt occurred with nothing on input queue. Set a noop
; request to device and hope a mode definition has been given previously.
;
INTERR:
	MOVB	S^#XD_CI_V_NOOP,BSEL6(R4)	; Set noop request
	MOVW	S^#XD_I_V_CONTROL,SEL2(R4)	; Set request type, clear RDI
	BRB	INTEXIT				; Exit the interrupt

	.SBTTL	RDO_INTRPT,  CSR Ready Output Interrupt Service Routine

;++
; RDO_INTRPT - CSR Ready Output Interrupt Service Routine
;
; Functional description:
;
; This routine is called when the DMP11 device generates an output
; interrupt after setting the RDO bit in the BSEL2.  This means that
; the device has some type of information for the driver, solicited
; or otherwise.  This may be buffers being returned from transmits
; or receives, error counters or polling parameters being read, or
; error conditions.
;
;
; Inputs:
;
;	00(SP) = address of IDB address
;	04(SP) - 1C(SP) = R0 - R5
;
;	IPL = DIPL
;
; Outputs:
;
;	Interrupt is dismissed.
;
;--

RDO_INTRPT:
	MOVL	@(SP)+,R4			; Get IDB address
	PUSHL	R9				; Save R9
	MOVL	IDB$L_UCBLST(R4),R5		; Get UCB address
	MOVL	(R4),R2				; Get CSR address
	BBS	#UCB$V_XD_INITED,-		; Br if inited
		UCB$W_DEVSTS(R5),5$		;
	BICB	#XD_BSEL2_M_RDO,BSEL2(R2)	; Else, release CSRs
	BRB	INTEXIT				; And exit interrupt
 
5$:	MOVW	SEL2(R2),R3			; Get SEL2 in R3
	MOVL	R3,R1				; Save type code
	ASHL	#16,R3,R3			; Shift to high word of R3
	MOVW	SEL0(R2),R3			; Get SEL0 in low
						;  word of R3
	MOVW	SEL6(R2),R4			; Get SEL6 in high
	ASHL	#16,R4,R4			;  word of R4
	MOVW	SEL4(R2),R4			; Get SEL4 in low
						;  word of R4
	MOVB	BSEL3(R2),R0			; Get trib address
	BICB	#XD_BSEL2_M_RDO,SEL2(R2)	; Release CSRs
	CLRL	R9				; Assume no CDB
	TSTB	R0				; Trib #0?
	BEQL	10$				; Br if yes - no CDB
	BSBW	FIND_TRIB			; Find CDB from trib address
	BLBC	R0,INTEXIT			; Br if trib not found - exit
10$:	BICL	#^C<XD_BSEL2_M_TYPE>,R1		; Clear all but type code
	CASE	R1,TYPE=B,<OUT_RCV,OUT_CTL,OUT_INFO,OUT_RCV_ERR,- ;
		OUT_XMIT,INTEXIT,OUT_XMIT_ERR,OUT_XMIT_ERR> ;
						; Case on the type code
;+
; Process receives completed by the DMP11. After the receive buffer is
; posted for completion, any receive buffers that are need are given to
; the device.
;-
	.ENABL	LSB
OUT_RCV:					; Process receive complete
	REMQUE	@UCB$Q_XD_RCV_PND(R5),R2	; Get oldest pending receive
	BVS	INTEXIT				; Error if none.
	BICL	#^XC0000000,R4			; Clear BA16 and BA17 from BA/CC
	CMPW	R4,RCV_L_BACC(R2)		; Buffer address match?
	BEQL	20$				; Br if yes - ok
10$:	INSQUE	(R2),UCB$Q_XD_RCV_PND(R5)	; Requeue the receive buffer
	BRW	INTEXIT				; Exit the interrupt
20$:	MOVZBL	RCV_B_MAPSLOT(R2),R0		; Get mapping slot number
	BBCC	R0,UCB$B_XD_RCV_MAP(R5),10$	; Mark as free - error if not
	MOVL	R4,RCV_L_BACC(R2)		; Save byte count
	EXTZV	#24,#8,R3,R3			; Get trib address
	BEQL	23$				; Br if trib zero????
	MOVB	R3,RCV_L_BACC(R2)		; Return trib address
	BRB	40$				; Complete the rcv in fork
;
; Bogus trib address
;
23$:	INSQUE	(R2),UCB$Q_XD_RCV_BUF(R5)	; Requeue buffer to device
	BRW	INTEXIT				; Exit the interrupt
;+
; Process a transmit buffer complete.
;-
OUT_XMIT:					; Process xmit complete
	TSTL	R9				; CDB address given?
	BEQL	25$				; Br if not - exit interrupt
	REMQUE	@CDB_Q_XMT_PND(R9),R2		; Get next xmit for trib
	BVS	25$				; Error if none
	BICL	#^XC0000000,R4			; Clear BA16 and BA17 from BA/CC
	CMPW	R4,IRP$L_MEDIA(R2)		; Buffer address match?
	BEQL	30$				; Br if yes - ok
	INSQUE	(R2),CDB_Q_XMT_PND(R9)		; Else, requeue the request
25$:	BRW	INTEXIT				; Exit the interrupt

30$:	MOVL	R4,IRP$L_IOST1(R2)		; Save byte count
	MOVW	S^#SS$_NORMAL,IRP$W_CSTATUS(R2)	; Set success
	BRB	40$				; Queue the xmit for completion
 
OUT_XMIT_ERR:					; Xmit not sent
	TSTL	R9				; CDB address present
	BEQL	25$				; Br if not - exit
	REMQUE	@CDB_Q_XMT_PND(R9),R2		; Get next xmit pending
	BVS	25$				; Br if none
	BRB	35$				;

OUT_RCV_ERR:					; Receive buffer unused
	REMQUE	@UCB$Q_XD_RCV_PND(R5),R2	; Get oldest pending receive
	BVS	25$				; Br if none
	CLRB	RCV_L_BACC(R2)			; Set receive error return
35$:	MOVW	#SS$_ABORT,IRP$W_CSTATUS(R2)	; Set error return
 
40$:	INSQUE	(R2),@UCB$Q_XD_POST+4(R5)	; Queue request for posting
	BNEQ	50$				; Br if not first entry
	BSBW	SCHED_FORKC			; Schedule fork process
50$:	BSBW	START_RECEIVE			; Start any receives 
	BRW	INTEXIT				; Exit interrupt
	.DSABL	LSB

;+
; This routine is called when the device interrupts with a INFORMATION OUT
; command being returned to the driver.  This command results from an
; associated CONTROL IN command, requesting some information from the device.
; Since the information may be of some global type, such as global error
; counters, or the modem register contents; the DMP11 device may not return
; a tributary address on OUTPUT. In this case all global requests are
; assumed to be processed in a FIFO order and the global requests are
; queued to the UCB INFO OUT QUEUE (and not the CDB INFO OUT QUEUE).
;-
OUT_INFO:					; Process information out
	EXTZV	#16,#8,R4,R2			; Get BSEL6
	BITB	#<XD_SEL6_M_RTSS!XD_SEL6_M_RCTS>,R2 ; Was this a read request?
	BNEQ	5$				; Br if yes
	CMPB	#8,R2				; Was it a read modem request?
	BNEQ	10$				; Br if not
5$:	BSBW	OUT_STATUS			; Else, process status
	BRW	INTEXIT				; Exit interrupt

10$:	CMPB	#16,R2				; Is it a BUFFER RETURN COMPLETE?
	BNEQ	30$				; Br if not - exit interrupt
	TSTL	R9				; CDB address found?
	BEQL	30$				; Br if no - exit interrupt
	BICL	#<XM$M_STS_ACTIVE!XM$M_STS_RUNNING>,- ; Can't be in these states
		CDB_L_DEVDEPEND(R9)		;
	SETBIT	#CD_TS_V_BUFRET,CDB_W_STS(R9)	; Note buffers returned
;
; We will scan the information out queue for the stop request
;
	MOVAB	CDB_Q_INFOUT(R9),R3		; Get address
	MOVL	R3,R0				; Save queue listhead address
20$:	MOVL	(R3),R3				; Get next IRP
	CMPL	R3,R0				; End of queue?
	BEQL	30$				; Br if yes - exit interrupt
	CMPB	#XD_FC_V_STOPT,IRP$B_XDFUNC(R3)	; Is this the stop request?
	BNEQ	20$				; Br if no - keep looking
	REMQUE	IRP$L_IOQFL(R3),R3		; Else get Stop IRP
	BSBW	SET_OUTTIM			; Start output wait timer
	INSQUE	(R3),UCB$Q_XD_INPUTQ(R5)	; Insert stop at front of Q
	BSBW	LOAD_PORT			; Give request to device
30$:	BRW	INTEXIT				; Else, exit interrupt

;+
; This routine is called when the DMP11 device interrupts with a CONTROL
; OUT command.  Some type of error has occurred and the driver must notify
; the user and also must take any appropriate steps to handle the error.
;-
OUT_CTL:					; Process control out
	EXTZV	#16,#8,R4,R1			; Get BSEL6
	CMPB	#^O<300>,R1			; Is this buffer too small?
	BEQL	PROCEDURE_ERR			; Br if yes - procedure error
	CMPB	#^O<304>,R1			; Is this a disconnect?
	BNEQ	10$				; Br if not
	SETBIT	#XM$V_STS_DISC,UCB$L_DEVDEPEND(R5) ; Set error flag
10$:	EXTZV	#6,#2,R1,R2			; Else, get severity code
	CASE	R2,TYPE=B,<-			; Process by severity
		SOFT_ERR,-			;   Soft error
		PROCEDURE_ERR,-			;   Procedure error
		PROCEDURE_ERR,-			;   Lots of procedure errors
		FATAL_ERR>			;   Fatal error
;+
; PROCEDURE_ERR - Process procedure error from device
;-
PROCEDURE_ERR:					; Process procedure error
	TSTL	R9				; CDB address found?
	BEQL	NOOP				; Br if no - exit now
	SETBIT	#XM$V_ERR_TRIB,CDB_L_DEVDEPEND(R9) ; Indicate trib error
	;BRB	FORCE_HALT			; Force trib to shutdown
 
FORCE_HALT:					; Force trib to shutdown
	EXTZV	#16,#8,R4,R3			; Get BSEL6 value
	MOVB	R3,CDB_L_DEVDEPEND+3(R9)	; Save BSEL6 in CDB
	BICL	#XM$M_STS_ACTIVE!XM$M_STS_RUNNING,- ; Tributary is halted
		CDB_L_DEVDEPEND(R9)		;
	MOVAL	UCB$L_XD_HALT(R5),R3		; Set address of halted trib list
SET_INDEX:					; Set trib index in list
	MOVZBL	CDB_B_TRB_ADDR(R9),R2		; Get trib address from CDB
	LOCC	R2,#32,UCB$B_XD_TRIB_VEC(R5)	; Find trib address
	BEQL	NOOP				; Exit if not found ???
	MOVAB	UCB$B_XD_TRIB_VEC(R5),R2	; Else, get address of vector
	SUBL2	R2,R1				; Calculate index
	SETBIT	R1,(R3)				; Set trib index
SFORK_EXIT:					; Exit with a fork process
	BSBW	SCHED_FORKC			; Schedule a fork process
	BRB	NOOP				; Exit the interrupt
 
;+
; SOFT_ERR - Process soft error from device
;-
SOFT_ERR:					; Process soft error
	TSTL	R9				; CDB address found?
	BEQL	NOOP				; Br if no - exit now
	EXTZV	#0,#6,R1,R2			; Get error type
	ASHL	#-1,R2,R2			; Convert type to case code
	CASE	R2,TYPE=B,LIMIT=#1,<-		; Process by type
		THRESH,-			;   Receive threshold error
		THRESH,-			;   Transmit threshold error
		THRESH,-			;   Select threshold error
		START_ERR,-			;   Start when running
		MAINT_ERR,-			;   MOP when running
		NOOP,-				;   MOP when halted
		START_ERR1,-			;   Start when in MOP
		NOOP,-				;   Reserved
		DEAD_ERR,-			;   Dead tributary
		RUNNING_NOTIF,-			;   Running tributary
		PROCEDURE_ERR,-			;   Babbling trib
		PROCEDURE_ERR>			;   Streaming trib
;
; All others
;
NOOP:						; No special operation
	BRW	INTEXIT				; Just exit the interrupt

THRESH:						; Threshold errors
	SETBIT	#XM$V_ERR_THRESH,CDB_L_DEVDEPEND(R9) ; Indicate warning
	BRB	NOOP				; And exit interrupt

START_ERR:					; Start received in RUN
	SETBIT	#XM$V_ERR_START,CDB_L_DEVDEPEND(R9) ; Indicate cause of error
	BRB	FORCE_HALT			; Force trib to shutdown
 
START_ERR1:					; Start received in MOP
	SETBIT	#XM$V_ERR_START,CDB_L_DEVDEPEND(R9) ; Indicate start received
	BRB	NOOP				; Exit the interrupt

MAINT_ERR:					; MOP received while running
	SETBIT	#XM$V_ERR_MAINT,CDB_L_DEVDEPEND(R9) ; Indicate cause of error
	BRB	FORCE_HALT			; Force trib shutdown

DEAD_ERR:					; Dead tributary
	CLRBIT	#XM$V_STS_RUNNING,CDB_L_DEVDEPEND(R9) ; No longer running
	BRB	NOOP				; Exit the interrupt
 
RUNNING_NOTIF:					; Running tributary
	SETBIT	#XM$V_STS_RUNNING,-		; Indicate trib is running
		CDB_L_DEVDEPEND(R9)		;
	MOVAL	UCB$L_XD_RUN(R5),R3		; Set address of run list
	BRB	SET_INDEX			; Set trib index in run list
 
;+
; FATAL_ERR - Process a fatal device error
;-
FATAL_ERR:					; Process a fatal device error
	MOVL	UCB$L_CRB(R5),R2		; Get CRB address
	MOVL	@CRB$L_INTD+VEC$L_IDB(R2),R2	; Get CSR address
	MOVB	#XD_BSEL1_M_MCLR,BSEL1(R2)	; Master clear the device
	EXTZV	#16,#8,R4,R3			; Get BSEL6 value
	MOVB	R3,UCB$L_DEVDEPEND+3(R5)	; Save error code
	ASHL	#XD_BSEL2_V_ERR+16,#1,R3	; Note fatal error
	BSBW	SCHED_FORK			; Schedule a fork process
	BRB	NOOP				; And exit

	.SBTTL	OUT_STATUS,  Process Information Out from device
 
;++
; OUT_STATUS - Process Information Out from device
;
; Functional description:
;
; This routine get the next request from the information out waiting queue
; and returns the information from the CSRs.
;
; Inputs:
;
;	R3 = SEL0 and SEL2
;	R4 = SEL4 and SEL6
;	R5 = UCB address
;	R9 = CDB address (only if tributary information)
;
;	IPL = DIPL
;
; Outputs:
;
;	R0-R3 = Destroyed
;--
 
OUT_STATUS:					; Process information out
	EXTZV	#24,#8,R3,R1			; Get trib address
	BEQL	40$				; Br if global request
;
; Read from TSS
;
	MOVAB	CDB_Q_INFOUT(R9),R2		; Get address
	MOVL	R2,R0				; Save queue listhead address
5$:	MOVL	(R2),R2				; Get next IRP
	CMPL	R2,R0				; End of queue?
	BEQL	20$				; Br if yes - exit
;
; Only a read TSS, read counter and a stop can be on the INFOUT queue.
; Find the first non-stop request.
;
	CMPB	#XD_FC_V_STOPT,IRP$B_XDFUNC(R2)	; Is this a stop request?
	BEQL	5$				; Br if yes - keep looking
	REMQUE	IRP$L_IOQFL(R2),R2		; Else get read request
	BSBW	SET_OUTTIM			; Start output wait timer
	MOVL	IRP$L_SVAPTE(R2),R1		; Get system buffer address
	TSTL	IRP$L_MEDIA(R2)			; Is this a counter request?
	BNEQ	30$				; Br if yes
10$:	MOVZWL	R4,P2B_T_DATA(R1)		; Else, store return info.
15$:	MOVW	#SS$_NORMAL,IRP$W_CSTATUS(R2)	; Set success return
	INSQUE	(R2),@UCB$Q_XD_POST+4(R5)	; Queue request for posting
	BNEQ	20$				; Br if not first entry
	BSBW	SCHED_FORKC			; Schedule fork process
20$:	RSB					; Return to caller
;
; Trib counters request
;
30$:	MOVAB	TRIB_COUNTER1-2,R0		; Get address of counter types
	BRB	50$				; Complete the request
;
; Global request
;
; Only a read GSS or read global counters can be on INFOUT queue.
;
40$:	REMQUE	@UCB$Q_XD_INFOUT(R5),R2		; Get next global request
	BVS	20$				; Br if none waiting
	BSBW	SET_OUTTIM			; Start output wait timer
	MOVL	IRP$L_SVAPTE(R2),R1		; Get system buffer address
	TSTL	IRP$L_MEDIA(R2)			; Is this a counters request?
	BEQL	10$				; Br if no - read of GSS
;
; Global counters request
;
	MOVAB	LINE_COUNTER-<2*5>,R0		; Get address of counter types
 
;
; Handle DMP error counter types.
;
50$:	FFS	#0,#8,IRP$L_MEDIA(R2),R3	; Get counter index
	CLRBIT	R3,IRP$L_MEDIA(R2)		; Indicate counter complete
	MOVL	(R1),R1				; Get next data pointer
	PUSHL	R2				; Save IRP address
	MOVW	(R0)+[R3],(R1)+			; Set next counter type
	EXTZV	#NMA$V_CNT_MAP,#3,-2(R1),R2	; Get width + bit map
	CASE	R2,TYPE=B,LIMIT=#2,<-		; Handle only DMP counter types
		60$,-				;   8 bit counter (2 per read)
		70$,-				;   8 bit counter, bit map
		80$>				;   16 bit counter
 
60$:	MOVB	R4,(R1)+			; Store 1st 8 bit counter
	MOVW	(R0)[R3],(R1)+			; Set next counter type
	ASHL	#-8,R4,R4			; Shift down next counter
	MOVB	R4,(R1)+			; Store 2nd 8 bit counter
	BRB	90$				; Check if all done
 
70$:	EXTZV	#8,#8,R4,R2			; Get bit map
	MOVZBW	R2,(R1)+			; Store bit map
	MOVB	R4,(R1)+			; Store counter value
	BRB	90$				; Check if all done
 
80$:	MOVW	R4,(R1)+			; Store 16 bit counter
 
90$:	POPL	R2				; Restore IRP address
	MOVL	IRP$L_SVAPTE(R2),R3		; Get system PTE address
	MOVL	R1,(R3)				; Reset next data pointer
	TSTB	IRP$L_MEDIA(R2)			; All done?
	BNEQ	100$				; Br if not
	MOVAB	P2B_T_DATA(R3),(R3)		; Else, reset start of data
	BRW	15$				; And complete request
 
100$:	INSQUE	(R2),UCB$Q_XD_INPUTQ(R5)	; Insert IRP on input Q
	BRW	LOAD_PORT			; Request input

	.SBTTL	SCHED_FORK,  Schedule the fork process
	.SBTTL	SCHED_FORKC, Schedule the fork process with R3 clear

;++
; SCHED_FORK - Schedule the fork process
; SCHED_FORKC - Schedule the fork process with R3 clear
;
; Functional description:
;
; This routine is called to schedule the error and I/O completion fork process.
; The last controller port and CSR values are saved for examination.  If the
; fork process is already pending, only the last CSR values are saved if there
; was an error.
;
; Inputs:
;
;	R3 = Last SEL0 and SEL2 values
;	R4 = Last SEL4 and SEL6 values
;	R5 = UCB address
;
;	IPL = DIPL or higher
;
; Outputs:
;
;	R3 is cleared if SCHED_FORKC entry.
;	R5 = UCB address
;
; If XD_BSEL2_V_ERR is set in BSEL2 the following is returned:
;
;	UCB$L_XD_SEL0(R5) = SEL0 and SEL2 values
;	UCB$L_XD_SEL4(R5) = SEL4 and SEL6 values
;
;--
 
SCHED_FORKC:					; Schedule fork process, clr R3
	CLRL	R3				; No device error
SCHED_FORK:					; Schedule fork process
	BBSS	#UCB$V_XD_FORK_PEND,UCB$W_DEVSTS(R5),10$ ; Br if fork pending
	PUSHAB	B^FORK_PROC			; Else, set address of fork process
	JMP	G^EXE$FORK			; Schedule the fork and return
 
10$:	BBC	#XD_BSEL2_V_ERR+16,R3,20$	; Br if not error
	MOVQ	R3,UCB$L_XD_SEL0(R5)		; Save last CSR values
20$:	RSB					; Return to caller

	.SBTTL	FORK_PROC,  Error and completion fork process handling
 
;++
; FORK_PROC - Error and completion fork processing
;
; Functional description:
;
; This routine is called as a fork process to handle errors and all completions
; pending.
;
; Inputs:
;
;	R3 = Last SEL0 and SEL2 values
;	R4 = Last SEL4 and SEL6 values
;	R5 = UCB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R5 is preserved.
;
;--
	.WORD	TIMEOUT-.			; Offset to timeout routine
	.ENABL	LSB
FORK_PROC:					; Error/completion fork process
	CLRBIT	#UCB$V_XD_FORK_PEND,UCB$W_DEVSTS(R5) ; Clear fork process flag
	BBC	#XD_BSEL2_V_ERR+16,R3,5$	; Br if not an error
	SETBIT	#XM$V_ERR_FATAL,UCB$L_DEVDEPEND(R5) ; Indicate fatal error
	INCW	UCB$W_ERRCNT(R5)		; Bump error counter
	BRW	SHUTDOWN_DEV			; Shutdown the device
;
; Complete any requests on completion queue
;
5$:	PUSHL	R9				; Save R9
10$:	REMQUE	@UCB$Q_XD_POST(R5),R2		; Get next completed block
	BVC	20$				; Br if got one
	BSBW	HALT_TRIBS			; Halt all tribs with errors
	BSBW	START_XMITS			; Start xmits for tribs in run
	POPL	R9				; Restore R9
	RSB					; Return to caller
;
; Found a completed block - finish it
;
20$:	CMPB	IRP$B_TYPE(R2),S^#DYN$C_NET	; Was it a receive?
	BEQL	30$				; Br if yes - complete it
	CMPB	IRP$B_TYPE(R2),S^#DYN$C_IRP	; Was it an IRP?
	BEQL	50$				; Br if yes - complete it
	BUG_CHECK NOBUFPCKT,FATAL		; Else, fatal error
;
; Receive complete - if there is a pending receive I/O request, complete it.
; Otherwise, queue the buffer and, if enabled, deliver attention AST.
;
30$:	MOVZBL	RCV_L_BACC(R2),R0		; Get trib address
	BNEQ	32$				; Br if no error
	ADDW	UCB$W_DEVBUFSIZ(R5),-		; Adjust receive buffer quota
		UCB$W_XD_QUOTA(R5)		;
	MOVL	R2,R0				; Get address of buffer
	JSB	G^COM$DRVDEALMEM		; Deallocate buffer
	BRB	10$				; Get next completion

32$:	BSBW	FIND_TRIB			; Get CDB address
	BLBS	R0,33$				; Br if got CDB
	BUG_CHECK NOBUFPCKT,FATAL		; Else, fatal error
 
33$:	MOVZWL	RCV_L_BACC+2(R2),R1		; Get the byte count
	ADDL	R1,CDB_L_BRC(R9)		; Update byte count
	BCC	35$				; Br if no overflow
	MNEGL	#1,CDB_L_BRC(R9)		; Else, latch it
35$:	INCC	CDB_L_DMR(R9)			; Update message count
	REMQUE	@CDB_Q_RCV_REQ(R9),R3		; Remove waiting IRP
	BVS	40$				; Br if none - queue for later
	BSBW	FINISH_RCV_IO			; Else, finish the I/O
	BRB	10$				; Look for next completion
 
40$:	INSQUE	(R2),@CDB_Q_RCV_MSG+4(R9)	; Queue receive msg for later
	BSBW	POKE_USER			; Deliver ASTs
	BRB	10$				; Look for more completions
;
; IRP packet completion - branch to proper completion handling routine.
;
50$:	MOVL	R2,R3				; Copy IRP address
	MOVZBL	IRP$B_XDFUNC(R3),R2		; Get function type
	CASE	R2,TYPE=B,<FORK_PKT,FORK_INITC,-
		FORK_STOPT,FORK_STOPC,FORK_INITC,-
		FORK_PKT,FORK_SSLOT,FORK_COUNTER,-
		FORK_COUNTER,FORK_COUNTER,-
		FORK_COUNTER,FORK_SSLOT,FORK_SSLOT,-
		FORK_PKT,FORK_HALTT,FORK_KILLT,-
		FORK_XMIT,FORK_RECV,FORK_KILLT,-
		FORK_INITC,FORK_PKT>		; Complete specific request
;
; Otherwise if not a valid IRP
;
	BUG_CHECK NOBUFPCKT,FATAL		; Fatal driver error
 
FORK_PKT:					; Process completion on packet
	MOVZWL	IRP$W_CSTATUS(R3),R0		; Get status of completion
	BSBW	IO_DONE				; Complete the I/O
	BRW	10$				; Get next packet
 
FORK_INITC:					; Process ctrl init completion
	CMPB	S^#XD_FC_V_INITC,IRP$L_MEDIA+1(R3) ; Was this an init controller?
	BNEQ	FORK_PKT			; Br if not
	TSTW	IRP$W_QUOTA(R3)			; Any quota to return?
	BEQL	55$				; Br if no
	MOVZWL	IRP$L_PID(R3),R0		; Get process index from IRP
	MOVL	G^SCH$GL_PCBVEC,R1		; Get address of PCB addr vec
	MOVL	(R1)[R0],R0			; Get PCB address
	CMPL	PCB$L_PID(R0),-			; Still same process?
		IRP$L_PID(R3)			; 
	BNEQ	55$				; Br if not - forget it
	MOVL	PCB$L_JIB(R0),R0		; Get JIB address
	MOVZWL	IRP$W_QUOTA(R3),R1		; Convert quota to longword
	ADDL	R1,JIB$L_BYTCNT(R0)		; Return byte count quota
	ADDL	R1,JIB$L_BYTLM(R0)		; ..and byte limit quota

55$:	MOVZWL	IRP$W_CSTATUS(R3),R0		; Get completion status
	PUSHL	R0				; Save completion status
	BSBW	IO_DONE				; Complete the I/O request
	POPL	R0				; Restore status
	BLBC	R0,57$				; Br ir error on startup
	BSBW	FILLRCVLIST			; Start the receives on success
57$:	BRW	10$				; Get next packet
 
FORK_STOPT:					; Process stop of tributary
	BSBW	GET_CDB				; Get CDB address
	BLBC	R0,58$				; Br if no CDB
	BSBW	SHUTDOWN_TRIB			; Abort all I/O
	MOVZWL	S^#SS$_NORMAL,R0		; Set completion status
;
; Cleanup CDB in case we use it again
;
	CLRW	CDB_W_STS(R9)			; Clean up status word
	INSV	#0,#8,#24,CDB_L_DEVDEPEND(R9)	; Clean up device status
	CLRQ	CDB_L_CNTS(R9)			; Clean up counts
	CLRQ	CDB_L_CNTS+8(R9)		;	...
	MOVB	UCB$B_XD_XMT_TRB(R5),CDB_B_XMT_CNT(R9) ; Init max xmits allowed
	BBS	#XM$V_CHR_CTRL,UCB$L_DEVDEPEND(R5),58$ ; Br if control station
	MOVB	#INF_XMT,CDB_B_XMT_CNT(R9)	; Else, allow infinite xmits
58$:	BSBW	IO_DONE				; Complete the I/O request
	BRW	10$				; Get next packet
 
FORK_STOPC:					; Process stop of controller
	BSBW	SHUTDOWN_DEV			; Abort all I/O on all tribs
	MOVZWL	S^#SS$_NORMAL,R0		; Set completion status
	BSBW	IO_DONE				; Complete the I/O request
	BRW	10$				; Get next packet
 
FORK_COUNTER:					; Process counter done
	MOVZWL	IRP$W_BCNT(R3),R0		; Get size of P2 buffer
	CLRW	IRP$W_BCNT(R3)			; Assume error - no data return
	BLBC	IRP$W_CSTATUS(R3),70$		; Br if err when getting counts
	MOVW	R0,IRP$W_BCNT(R3)		; Else, reset size of data
	CMPW	IRP$L_MEDIA+2(R3),R0		; Is user buffer larger than P2?
	BGEQU	60$				; Br if yes - okay
	MOVW	IRP$L_MEDIA+2(R3),R0		; Else, set user return size
	MOVW	#SS$_BUFFEROVF,IRP$W_CSTATUS(R3) ; Set error return
60$:	ASHL	#16,R0,R0			; Move count to high word
70$:	MOVW	IRP$W_CSTATUS(R3),R0		; Set return status
	BSBW	IO_DONE				; Complete the I/O request
	BRW	10$				; Get next packet

FORK_SSLOT:					; Process status slot read
	MOVZWL	IRP$W_CSTATUS(R3),R0		; Get completion status
	BLBS	R0,75$				; Br if success
	CLRB	IRP$W_BCNT(R3)			; Else, no data to return
75$:	BSBW	IO_DONE				; Complete the I/O request
	BRW	10$				; Get next packet
 
FORK_XMIT:					; Process transmit done
	BSBW	GET_CDB				; Get CDB address
	BLBS	R0,78$				; Br if CDB present
	MOVW	R0,IRP$W_CSTATUS(R3)		; Else, set error return
	BRB	85$				; Return map registers
 
78$:	INCB	CDB_B_XMT_CNT(R9)		; Indicate another xmit complete
	BLBC	IRP$W_CSTATUS(R3),85$		; Br if xmit error
	MOVZWL	IRP$W_BCNT(R3),R1		; Get size of transmit
	ADDL	R1,CDB_L_BSN(R9)		; Update byte count
	BCC	80$				; Br if no overflow
	MNEGL	#1,CDB_L_BSN(R9)		; Else, latch it
80$:	INCC	CDB_L_DMS(R9)			; Update message count
85$:	MOVZBL	IRP$L_MEDIA+4(R3),R1		; Get mapping slot number used
	CLRBIT	R1,UCB$B_XD_XMT_MAP(R5)		; Clear in use flag
	TSTB	R1				; Was slot permanently allocated one?
	BEQL	90$				; Br if yes - don't deallocate
	MOVL	UCB$L_CRB(R5),R2		; Get CRB address
	MOVL	UCB$L_XD_XMT_MAP(R5)[R1],-	; Setup map register data
		CRB$L_INTD+VEC$W_MAPREG(R2)	;
	MNEGL	#1,UCB$L_XD_XMT_MAP(R5)[R1]	; Set mapping data not allocated
	RELMPR					; Release the map registers
90$:	MOVZWL	IRP$W_CSTATUS(R3),R0		; Get return status
	BLBC	R0,100$				; Br if error
	MOVW	IRP$W_BCNT(R3),R0		; Get count of bytes transmitted
	ASHL	#16,R0,R0			; Shift into place
	MOVW	S^#SS$_NORMAL,R0		; Set success
100$:	BSBW	IO_DONE				; Complete the I/O
	BSBW	XMT_ALT_START			; Give other xmits to device
	BRW	10$				; Get next packet
 
FORK_RECV:					; Process receive request
	BSBW	GET_CDB				; Get CDB address
	BLBC	R0,110$				; Br if error
	MOVZWL	IRP$W_CSTATUS(R3),R0		; Get completion status
	BLBC	R0,110$				; Br if error
	BSBW	RCV_START_ALT			; Get any receives waiting
	BRB	120$				; Continue

110$:	BSBW	IO_DONE				; Complete the I/O request
120$:	BRW	10$				; Get next packet
	
FORK_HALTT:
	BLBC	IRP$W_CSTATUS(R3),FORK_KILLT	; Br if error
	MOVB	#XD_FC_V_KILLT,IRP$B_XDFUNC(R3)	; Set to kill trib
	DSBINT	UCB$B_DIPL(R5)			; Sync access to device
	INSQUE	(R3),@UCB$Q_XD_INPUTQ+4(R5)	; Insert at end of input Q
	BSBW	LOAD_PORT			; Give request to device
	ENBINT					; Restore IPL
	BRW	10$				; Get next packet
 
FORK_KILLT:					; Process completion of kill
	JSB	G^COM$POST			; Deallocate CDB from IOPOST
	BRW	10$				; Get next packet
	.DSABL	LSB

	.SBTTL	FINISH_RCV_IO,  Finish receive I/O processing

;++
; FINISH_RCV_IO - Finish receive I/O processing
;
; Functional description:
;
; This routine completes a receive operation that has been matched with a
; message block. After the receive has been completed the message free list
; is filled and a receive is started if needed.
;
;  Inputs:
;
;	R2 = message buffer address
;	R3 = I/O packet address
;	R5 = UCB address
;	R9 = CDB address
;
;	IPL = FIPL
;
;  Outputs:
;
;	R5 is preserved.
;
;	The request is completed via I/O post.
;--

FINISH_RCV_IO:					; Finish recieve I/O request
	MOVL	R2,IRP$L_SVAPTE(R3)		; Save block address
	MOVAB	RCV_T_DATA(R2),(R2)		; Set address of received data
	MOVL	IRP$L_MEDIA(R3),4(R2)		; Set address of user buffer
	ADDW	UCB$W_DEVBUFSIZ(R5),-		; Adjust receive buffer quota
		UCB$W_XD_QUOTA(R5)		;
	MOVW	RCV_L_BACC+2(R2),R1		; Get size of transfer
	CMPW	R1,IRP$W_BCNT(R3)		; Request larger than actual?
	BLEQU	10$				; Br if no
	MOVZWL	IRP$W_BCNT(R3),R1		; Set size to minimum of two
10$:	MOVW	R1,IRP$W_BCNT(R3)		; Set size to transfer
	ASHL	#16,R1,R0			; Set buffer size in status
	BNEQ	20$				; Br if success
	MOVW	#SS$_CTRLERR,R0			; Set data path error
	BRB	30$				; Fill receive list
 
20$:	MOVW	S^#SS$_NORMAL,R0		; Set success
30$:	BSBB	IO_DONE				; Post the I/O request
	BRW	FILLRCVLIST			; Fill up the receive buffers
;
; Complete an I/O request packet
;
ABORT_PKT:					; Abort the I/O request
	MOVZWL	#SS$_ABORT,R0			; Return aborted status
IO_DONE:					; Complete a transfer I/O request
	MOVL	R0,IRP$L_IOST1(R3)		; Set status return and size
IO_DONE1:					; Alternate entry point
	MOVL	UCB$L_DEVDEPEND(R5),IRP$L_IOST2(R3) ; Set other info
	MOVL	IRP$L_CDB(R3),R0		; Get address of CDB address
	BEQL	10$				; Br if none

	MOVL	(R0),R0				; Get CDB address
	BEQL	10$				; Br if none
	BISL	CDB_L_DEVDEPEND(R0),IRP$L_IOST2(R3) ; Set circuit bits
10$:	BBC	#IRP$V_DIAGBUF,IRP$W_STS(R3),20$ ; Br if no diagnostic buffer
	ADDL3	#8,@IRP$L_DIAGBUF(R3),R0	; Address buffer past start time
	MOVQ	G^EXE$GQ_SYSTIME,(R0)+		; Insert stop time
	MOVZWL	UCB$W_ERRCNT(R5),(R0)+		; Insert error counter
	BSBW	REG_DUMP			; Dump registers
20$:	JMP	G^COM$POST			; Post the I/O and return

	.SBTTL	HALT_TRIBS,  Halt all tribs that were forced to shutdown
 
;++
; HALT_TRIBS - Halt all tribs that were forced to shutdown
;
; Functional description:
;
; This routine scans the UCB halt longword for any trib that were recently
; shutdown due to device errors.
;
; Inputs:
;
;	R5 = UCB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0-R2,R9 are destroyed.
;
;--
 
HALT_TRIBS:					; Shutdown all tribs that are halted
	FFS	#0,#32,UCB$L_XD_HALT(R5),R2	; Get index of next halted trib
	BEQL	10$				; Br if none
	CLRBIT	R2,UCB$L_XD_HALT(R5)		; Else, indicate trib shutdown
	MOVL	UCB$L_XD_CDB_VEC(R5)[R2],R9	; Get CDB address
	BEQL	HALT_TRIBS			; Br if no CDB address
	BSBW	SHUTDOWN_TRIB			; Shutdown the tributary
	BRB	HALT_TRIBS			; Look for next halted trib
10$:	RSB					; Return to caller

	.SBTTL	START_XMITS,  Start xmits for tribs in run state

;++
; START_XMITS - Start xmits for tribs in run state
;
; Functional description:
;
; This routine scans the UCB run longword for any tribs that have recently
; entered the run state, to start the xmit requests for that tributary.
;
;  Inputs:
;
;	R5 = UCB address
;
;	IPL = FIPL
;
;  Outputs:
;
;	R0-R2,R9 are destroyed.
;
;--

START_XMITS:					; Start xmits on running tribs
	FFS	#0,#32,UCB$L_XD_RUN(R5),R2	; Get index of next running trib
	BEQL	10$				; Br if none running
	CLRBIT	R2,UCB$L_XD_RUN(R5)		; Else, indicate xmits started
	MOVL	UCB$L_XD_CDB_VEC(R5)[R2],R9	; Get CDB address
	BEQL	START_XMITS			; Br if no CDB address
	BSBW	XMT_ALT_START			; Start xmits for this trib
	BRB	START_XMITS			; Get next trib
10$:	RSB					; Return to caller

	.SBTTL	SHUTDOWN_TRIB,  Shutdown the tributary
 
;++
; SHUTDOWN_TRIB - Shutdown the tributary
;
; Functional description:
;
; This routine is called to abort all I/O pending for this tributary.
;
; Inputs:
;
;	R5 = UCB address
;	R9 = CDB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0-R2 are destroyed.
;
;--
 
SHUTDOWN_TRIB:					; Shutdown a tributary
	BBS	#CD_TS_V_ESTAB,CDB_W_STS(R9),10$ ; Br if trib established
	RSB
;
; Flush all attention ASTs
;
10$:	PUSHR	#^M<R3,R4,R6,R7>		; Save registers
20$:	MOVAB	CDB_L_AST(R9),R7		; Get address of AST listhead
	MOVL	(R7),R0				; Anything in list?
	BEQL	30$				; Br if not
	MOVZWL	ACB$L_KAST+10(R0),R6		; Force channel match
	MOVZWL	ACB$L_KAST+12(R0),R2		; Get process index
	MOVL	G^SCH$GL_PCBVEC,R4		; Get PCB address vector address
	MOVL	(R4)[R2],R4			; Get PCB address
	JSB	G^COM$FLUSHATTNS		; Flush AST
	BRB	20$				; Continue flushing ASTs
;
; Complete all IRPs for this tributary
;
30$:	MOVAB	CDB_Q_QUEUES(R9),R6		; Get address of first queue listhead
	MOVZWL	#CDB_C_QUEUES,R7		; Get number of queues
40$:	REMQUE	@(R6),R3			; Get next IRP/buffer
	BVS	80$				; Br if none - queue empty
	CMPB	IRP$B_TYPE(R3),S^#DYN$C_IRP	; Is this an IRP?
	BEQL	50$				; Br if yes
	CMPB	IRP$B_TYPE(R3),S^#DYN$C_NET	; Is it a receive buffer?
	BEQL	70$				; Br if yes
	BUG_CHECK NOBUFPCKT,FATAL		; Else, fatal error
;
; IRP
;
50$:	BSBW	ABORT_PKT			; Abort the I/O request
	BRB	40$				; Get next entry
;
; Receive buffer
;
70$:	MOVL	R3,R2				; Set receive buffer address
	BSBW	ADDRCVLIST			; Try to add to receive list
	BRB	40$				; Get next entry
;
; Loop to next queue
;
80$:	ADDL	#8,R6				; Skip to next queue listhead
	SOBGTR	R7,40$				; Loop if more queues
;
; Restart output timers if not a fatal device error
;
	BBS	#XM$V_ERR_FATAL,UCB$L_DEVDEPEND(R5),90$ ; Br if fatal error
	BSBW	SET_OUTTIM			; Reset output timer
90$:	POPR	#^M<R3,R4,R6,R7>		; Restore registers
	RSB					; Return to caller

	.SBTTL	SHUTDOWN_DEV,  Shutdown the controller
 
;++
; SHUTDOWN_DEV - Shutdown the controller
;
; Functional description:
;
; This routine is called to abort all I/O pending on all tributaries.
;
; Inputs:
;
;	R5 = UCB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0-R2 are destroyed.
;
;--
 
SHUTDOWN_DEV:					; Shutdown controller
	BBC	#UCB$V_ONLINE,UCB$W_STS(R5),10$	; Br if not online
	BBS	#UCB$V_XD_INITED,UCB$W_DEVSTS(R5),20$ ; Br if device inited
	BBS	#UCB$V_XD_INITING,UCB$W_DEVSTS(R5),20$ ; Br if device initing
10$:	RSB
;
; Abort all I/O for all tribs and deallocate CDBs
;
20$:	PUSHR	#^M<R3,R4,R6,R7,R9>		; Save registers
	ASSUME	UCB$B_XD_OUTTIM EQ UCB$B_XD_INTIM+1
	CLRW	UCB$B_XD_INTIM(R5)		; Stop all timers
	ASSUME	UCB$B_XD_DUP EQ UCB$B_XD_PRO+1
	ASSUME	UCB$B_XD_CON EQ UCB$B_XD_DUP+1
	ASSUME	UCB$B_XD_BFN EQ UCB$B_XD_CON+1
	CLRL	UCB$B_XD_PRO(R5)		; Reset all line characteristics
	MOVZBL	S^#31,R7			; Set number of tributaries
30$:	MOVL	UCB$L_XD_CDB_VEC(R5)[R7],R9	; Get next CDB address
	BEQL	40$				; Br if none
	CLRL	UCB$L_XD_CDB_VEC(R5)[R7]	; Remove CDB from vector
	CLRL	UCB$L_XD_PID_VEC(R5)[R7]	; Zero PID entry
	CLRW	UCB$W_XD_CHAN_VEC(R5)[R7]	; Zero channel entry
	CLRB	UCB$B_XD_TRIB_VEC(R5)[R7]	; Reset trib address
	BSBW	SHUTDOWN_TRIB			; Abort all I/O on CDB
	BSBW	CLEAR_CDB			; Deallocate CDB and restore quota
40$:	SOBGEQ	R7,30$				; Loop if more tribs
;
; Clear device status flags
;
	CLRB	UCB$B_XD_TRB_CNT(R5)		; No tributaries
	DSBINT	UCB$B_DIPL(R5)			; Sync access to UCB
	BICW	#UCB$M_INT!UCB$M_POWER,-	; Reset device status flags
		UCB$W_STS(R5)			;
	BICW	#^C<UCB$M_XD_FORK_PEND>,-	; Reset all but fork pending
		UCB$W_DEVSTS(R5)		; ..bit.
	ENBINT					; Restore IPL
;
; Release the receive and transmit buffer map registers
;
	MOVL	UCB$L_CRB(R5),R4		; Get CRB address
	CLRL	R7				; Init slot number
	ASSUME	UCB$L_XD_RCV_MAP+<4*MAX_RCV> EQ UCB$L_XD_XMT_MAP
	MOVAB	UCB$L_XD_RCV_MAP(R5),R6		; Get address of mapping slots
50$:	MOVL	(R6)+,CRB$L_INTD+VEC$W_MAPREG(R4) ; Set mapping info.
	BLSS	60$				; Br if none allocated
	RELMPR					; Release the map registers
	MNEGL	#1,-4(R6)			; Reset mapping info
60$:	CLRBIT	R7,UCB$B_XD_RCV_MAP(R5)		; Clear mapping slot flag
	AOBLSS	#MAX_RCV+MAX_XMT,R7,50$		; Loop if more map registers
;
; Deallocate all receive buffers and complete all I/O request packets
;
70$:	MOVAB	UCB$Q_XD_QUEUES(R5),R6		; Get address of first queue listhead
	MOVZWL	#UCB$C_XD_QUEUES,R7		; Set number of queues
80$:	REMQUE	@(R6),R3			; Get next IRP/buffer
	BVS	120$				; Br if none - queue empty
	CMPB	IRP$B_TYPE(R3),S^#DYN$C_IRP	; Is this an IRP?
	BEQL	90$				; Br if yes
	CMPB	IRP$B_TYPE(R3),S^#DYN$C_NET	; Is it a receive buffer?
	BEQL	110$				; Br if yes
	BUG_CHECK NOBUFPCKT,FATAL		; Else, fatal error
;
; IRP
;
90$:	CLRL	IRP$L_CDB(R3)			; Definitely no CDB
	BSBW	ABORT_PKT			; Abort the I/O request
	BRB	80$				; Get next entry
;
; Receive buffer
;
110$:	MOVL	R3,R0				; Set receive buffer address
	ADDW	UCB$W_DEVBUFSIZ(R5),-		; Restore quota
		UCB$W_XD_QUOTA(R5)		;
	JSB	G^COM$DRVDEALMEM		; Deallocate the receive buffer
	BRB	80$				; Get next entry
;
; Loop to next queue
;
120$:	ADDL	#8,R6				; Skip to next queue listhead
	SOBGTR	R7,80$				; Loop if more queues
;
; Restore the buffered I/O quota to the starter
;
	MOVZWL	UCB$L_XD_PID(R5),R0		; Get process index of starter
	MOVL	G^SCH$GL_PCBVEC,R1		; Get address of PCB address vector
	MOVL	(R1)[R0],R0			; Get PCB address of starter
	CMPL	PCB$L_PID(R0),UCB$L_XD_PID(R5)	; Still the same process?
	BNEQ	130$				; Br if not
	MOVL	PCB$L_JIB(R0),R0		; Get JIB address
	MOVZWL	UCB$W_XD_QUOTA(R5),R1		; Convert quota to longword
	ADDL	R1,JIB$L_BYTCNT(R0)		; Return byte count quota
	ADDL	R1,JIB$L_BYTLM(R0)		; ..and limit
	CLRW	UCB$W_XD_QUOTA(R5)		; Reset quota
130$:	POPR	#^M<R3,R4,R6,R7,R9>		; Restore registers
	RSB					; Return to caller

	.SBTTL	REG_DUMP,  Device register dump routine

;++
; REG_DUMP, Dumps the contents of device registers to a buffer
;
; Functional description:
;
; Writes the number of longwords returned, and the contents of the
; device registers into a diagnostic or error buffer.
;
; Inputs:
;
;	R0 = Diagnostic buffer address
;	R5 = UCB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0 is destroyed.
;
;	R5 is preserved.
;
;--

REG_DUMP:					; Dump device registers
	MOVZBL	#3,(R0)+			; Store # of longwords returned
	ASSUME	UCB$L_XD_SEL4 EQ UCB$L_XD_SEL0+4
	MOVQ	UCB$L_XD_SEL0(R5),(R0)+		; Store all CSR registers
	MOVL	UCB$L_DEVDEPEND(R5),(R0)+	; Store device dependent longword
	RSB					; Return

	.SBTTL	RETURN_IRP,  Deallocate IRP
	.SBTTL	RETURN_CDB,  Deallocate CDB
	.SBTTL	CLEAR_CDB,  Deallocate CDB
 
;++
; RETURN_IRP - Deallocate IRP (Called from IOPOST)
; RETURN_CDB - Deallocate CDB (Called from IOPOST)
; CLEAR_CDB - Deallocate CDB (Called from CANCEL or the Fork Process)
;
; Functional description:
;
; These subroutines are called to deallocate the CDB and restore the byte
; count quota.
;
; Inputs:
;
;	R5 = IRP address (RETURN_IRP entry only)
;	R5 = CDB address (RETURN_CDB entry only)
;	R9 = CDB address (CLEAR_CDB entry only)
;
;	IPL = FIPL
;
; Outputs:
;
;	R0-R2 are destroyed.
;	R9 destroyed if CLEAR_CDB entry.
;
;--
 
RETURN_IRP:					; Deallocate the IRP
	MOVL	R5,R0				; Copy IRP address
	JMP	G^COM$DRVDEALMEM		; Deallocate the IRP
 
RETURN_CDB:					; Deallocate the CDB
	PUSHL	R9				; Save R9
	MOVL	R5,R9				; Copy CDB address
	MOVL	IRP$L_MEDIA(R5),CDB_L_PID(R5)	; Move PID to proper place
	BSBB	CLEAR_CDB			; Deallocate CDB
	POPL	R9				; Restore R9
	RSB					; Return to caller (IOPOST)
	
CLEAR_CDB:					; Deallocate CDB
	MOVL	R9,R0				; Copy CDB address
	MOVL	CDB_L_PID(R0),R9		; Get PID
	JSB	G^COM$DRVDEALMEM		; Deallocate the CDB
	MOVZWL	R9,R0				; Get process index
	MOVL	G^SCH$GL_PCBVEC,R1		; Get address of PCB vector
	MOVL	(R1)[R0],R1			; Get PCB address
	CMPL	PCB$L_PID(R1),R9		; Is this the same PID?
	BNEQ	10$				; Br if not - just leave
	MOVL	PCB$L_JIB(R1),R1		; Get JIB address
	ADDL	#CDB_C_LENGTH,JIB$L_BYTCNT(R1)	; Restore byte count quota
	ADDL	#CDB_C_LENGTH,JIB$L_BYTLM(R1)	; ..and limit
10$:	RSB					; Return to caller

	.SBTTL	FIND_SLOT,  Find an empty slot in translation vector
 
;++
; FIND_SLOT - Find an empty slot in the translation vector
;
; Functional Description:
;
; This routine is called to return the index of the first available
; slot in the translation vector starting from the hash point.
;
; Inputs:
;
;	R3 = IRP address
;	R5 = UCB address
;
; Outputs:
;
;	R0 = status return
;	R1,R2 = destroyed.
;
; If success:
;
;	IRP$B_INDEX(R3) = Index of empty slot in translation vector.
;
;--
 
FIND_SLOT:					; Find empty slot in vector
	EXTZV	#0,#5,IRP$L_PID(R3),R1		; Get start hash
	MOVZWL	S^#32,R2			; Get size of vector
	CLRL	R0				; Assume failure

10$:	TSTL	UCB$L_XD_PID_VEC(R5)[R1]	; Empty slot?
	BEQL	20$				; Br if yes
	INCL	R1				; Set to next slot
	BICL	#^C<31>,R1			; Modulo 32
	SOBGTR	R2,10$				; Br if more
	RSB					; Return in error
;
; Empty slot found - save in IRP
;
20$:	MOVB	R1,IRP$B_INDEX(R3)		; Save index
	MOVZWL	S^#SS$_NORMAL,R0		; Set success
	RSB					; Return to caller

	.SBTTL	FIND_TRIB,  Find CDB from trib address
 
;++
; FIND_TRIB - Find CDB from trib address
;
; Functional Description:
;
; This routine is called to return the CDB address for a given tributary
; address. The tributary address vector is scanned to make the comparison.
;
; Inputs:
;
;	R0 = tributary address
;	R5 = UCB address
;
; Outputs:
;
;	R0 = status return
;
; If Success:
;
;	R9 = CDB address
;
;--
 
FIND_TRIB:					; Find CDB from trib address
	PUSHQ	R1				; Save R1, R2
	MOVL	R0,R2				; Copy trib address
	LOCC	R2,#32,UCB$B_XD_TRIB_VEC(R5)	; Find trib in vector
	BEQL	10$				; Leave if not found (R0 = 0)
 
	MOVAB	UCB$B_XD_TRIB_VEC(R5),R2	; Get address of trib vector
	SUBL2	R2,R1				; Calculate index
	MOVL	UCB$L_XD_CDB_VEC(R5)[R1],R0	; Get CDB address
	BEQL	10$				; Leave if none
	MOVL	R0,R9				; Return CDB address
	MOVZWL	S^#SS$_NORMAL,R0		; Set success
10$:	POPQ	R1				; Restore R1, R2
	RSB					; Return to caller

	.SBTTL	XLATE,  Translate PID and Channel to CDB address
	.SBTTL	XLATE_ALT,  Translate PID and Channel to CDB address
 
;++
; XLATE - Translate PID and Channel to CDB address
; XLATE_ALT - Translate PID and Channel to CDB address
;
; Functional Description:
;
; This routine is called to return the CDB address for a particular
; channel. If the controller is running in point to point mode or
; the controller is a tributary then it is assumed that the first
; hash into the CDB address vector has the one and only CDB address.
;
; This routine hashes the low order 5 bits of the PID to start the
; search. This should optimize scanning of the PID vector only if
; the CDB already exists.
;
; Inputs:
;
;	R0 = PID (XLATE_ALT only)
;	R3 = IRP address
;	R5 = UCB address
;
; Implicit Inputs:
;
;	IRP$L_PID(R3) = PID of requestor (XLATE only)
;	IRP$W_CHAN(R3) = Channel of requestor
;
; Outputs:
;
;	R0 = status return for success of call.
;	R9 = CDB address (if success, else zero)
;
;	R1,R2 are destroyed.
;
;--
 
XLATE:						; Translate IRP into CDB address
	MOVL	IRP$L_PID(R3),R0		; Get PID
XLATE_ALT:					; Alternate translation entry
	PUSHL	R3				; Save IRP address
	MOVZWL	IRP$W_CHAN(R3),R3		; Get channel
	BSBB	XLATE_PID_CHAN			; Translate PID and channel
	POPL	R3				; Restore IRP address
	BLBC	R0,10$				; Br if error
;
; Found PID and Channel in translation vector, get CDB address
;
	MOVB	R1,IRP$B_INDEX(R3)		; Save index in IRP
	MOVAL	UCB$L_XD_CDB_VEC(R5)[R1],-	; Store address of CDB address
		IRP$L_CDB(R3)			;
	MOVB	CDB_B_TRB_ADDR(R9),-		; Store trib address also
		IRP$Q_STATION(R3)		;
10$:	RSB					; Return to caller
;+
; The Following entry point is called by the CANCEL routine also.
;
; Inputs:
;
;	R0 = PID
;	R3 = Channel for request
;
; Outputs:
;
;	R0 = Status return for request
;	R9 = CDB address if success, else zero
;-
XLATE_PID_CHAN:					; Translate PID & CHAN into CDB address
	EXTZV	#0,#5,R0,R1			; Hash PID into 32 indices
	BBS	#UCB$V_XD_PTP,UCB$W_DEVSTS(R5),40$ ; Br if point to point
;	BBC	#XM$V_CHR_CTRL,UCB$L_DEVDEPEND(R5),40$ ; Br if not control station
	MOVL	R1,R2				; Save start hash
10$:	CMPL	R0,UCB$L_XD_PID_VEC(R5)[R1]	; PIDs match?
	BNEQ	20$				; Br if not
	CMPW	R3,UCB$W_XD_CHAN_VEC(R5)[R1]	; Channels match?
	BEQL	40$				; Br if yes - got it
20$:	INCL	R1				; Else, set to next entry
	BICL	#^C<31>,R1			; Modulo 32
	CMPL	R1,R2				; Back to start?
	BNEQ	10$				; Br if more to check
30$:	MOVZWL	#SS$_DEVOFFLINE,R0		; Return channel offline
	CLRL	R9				; Return zero in R9
	RSB					; Return to caller
;
; Found match on PID and Channel
; 
40$:	MOVL	UCB$L_XD_CDB_VEC(R5)[R1],R9	; Get CDB address
	BEQL	30$				; Br if no CDB address - error
	MOVZWL	S^#SS$_NORMAL,R0		; Set successful return status
	RSB					; Return

	.SBTTL	GET_CDB,  Get CDB address from IRP
 
;++
; GET_CDB - Get CDB address from IRP
;
; Inputs:
;
;	R3 = IRP address
;	R5 = UCB address
;
; Implicit Inputs:
;
;	IRP$L_CDB(R3) = address of CDB address (pointer into UCB vector)
;
; Outputs:
;
;	R0 = status of request
;	R9 = CDB address if present in UCB vector
;
;--
 
GET_CDB:					; Get CDB address from IRP
	MOVL	IRP$L_CDB(R3),R9		; Get address of CDB address
	BNEQ	10$				; Br if present
	BUG_CHECK NOBUFPCKT,FATAL		; Else, fatal error
 
10$:	MOVZWL	S^#SS$_NORMAL,R0		; Assume good CDB address
	MOVL	(R9),R9				; Get CDB address
	BNEQ	20$				; Br if good
	MOVZWL	#SS$_ABORT,R0			; Else, abort the request
20$:	RSB					; Return to caller

	.SBTTL	CHG_UCB,  Change UCB parameter values
 
;++
; CHG_UCB - Change UCB parameter values
;
; Functional description:
;
; This routine is called to initialize the UCB with new P1 and P2 buffer
; characteristics. It is assumed here that the parameters have already
; been validated.
;
; Inputs:
;
;	R3 = IRP address
;	R5 = UCB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0-R2 = destroyed.
;
;--
 
CHG_UCB:					; Change UCB parameters
	PUSHL	R4				; Save R4
	BLBC	IRP$L_MEDIA(R3),10$		; Br if no P1 buffer
;
; Set new P1 buffer characteristics
;
	BBS	#UCB$V_XD_INITED,UCB$W_DEVSTS(R5),5$ ; Br if device inited
	MOVW	IRP$L_MEDIA+2(R3),UCB$W_DEVBUFSIZ(R5) ; Set new buffer size
5$:	ASSUME	P1_LINE_MASK EQ <^XFF>
	INSV	#0,#8,#24,UCB$L_DEVDEPEND(R5)	; Reset all Read/Write flags
	BISL	IRP$L_MEDIA+4(R3),UCB$L_DEVDEPEND(R5) ; Set new characteristics
;
; Now update UCB based on P1 buffer
;
	ASSUME	NMA$C_LINPR_POI EQ 0
	CLRB	UCB$B_XD_PRO(R5)		; Assume point to point mode
	BITB	#XM$M_CHR_DMC!XM$M_CHR_TRIB!-	; Is this point to point mode?
		XM$M_CHR_CTRL,UCB$L_DEVDEPEND(R5) ;
	BEQL	6$				; Br if yes
	ASSUME	NMA$C_LINPR_CON EQ 1
	INCB	UCB$B_XD_PRO(R5)		; Assume control station
	BBS	#XM$V_CHR_CTRL,-		; Br if control mode
		UCB$L_DEVDEPEND(R5),6$		;
	ASSUME	NMA$C_LINPR_TRI EQ 2
	INCB	UCB$B_XD_PRO(R5)		; Assume trib station
	BBS	#XM$V_CHR_TRIB,-		; Br if trib station
		UCB$L_DEVDEPEND(R5),6$		;
	MOVB	#NMA$C_LINPR_DMC,UCB$B_XD_PRO(R5) ; Must be DMC compatible mode
6$:	ASSUME	NMA$C_LINCN_NOR EQ 0
	CLRB	UCB$B_XD_CON(R5)		; Assume normal mode
	BBC	#XM$V_CHR_LOOPB,-		; Br if not loopback mode
		UCB$L_DEVDEPEND(R5),7$		;
	ASSUME	NMA$C_LINCN_LOO EQ 1
	INCB	UCB$B_XD_CON(R5)		; Must be loopback mode
7$:	ASSUME	NMA$C_DPX_FUL EQ 0
	CLRB	UCB$B_XD_DUP(R5)		; Assume full duplex
	BBC	#XM$V_CHR_HDPLX,-		; Br if not half duplex
		UCB$L_DEVDEPEND(R5),10$		;
	ASSUME	NMA$C_DPX_HAL EQ 1
	INCB	UCB$B_XD_DUP(R5)		; Must be half duplex

;
; Set new P2 buffer characteristics
;
10$:	MOVL	R5,R4				; Copy UCB address
	MOVAB	LINE_PARAM,R1			; Get address of verification table
	BSBW	UPDATE_P2			; Update the UCB
;
; Set device characteristics and device mode definition
;
	MOVZBL	S^#1,R1				; Assume point to point mode
	CLRB	UCB$L_DEVDEPEND(R5)		; Reset all characteristics
	ASSUME	NMA$C_LINPR_POI EQ 0
	MOVZBL	UCB$B_XD_PRO(R5),R2		; Get protocol mode
	BEQL	30$				; Br if point to point mode
 
	ASSUME	NMA$C_LINPR_CON EQ 1
	INCL	R1				; Assume control station mode
	DECL	R2				; Control station mode?
	BNEQ	15$				; Br if not
	SETBIT	#XM$V_CHR_CTRL,UCB$L_DEVDEPEND(R5) ; Indicate control station
	BRB	30$				;
 
15$:	ASSUME	NMA$C_LINPR_TRI EQ 2
	DECL	R2				; Tributary station protocol?
	BNEQ	20$				; Br if no
	INCL	R1				; Set mode to trib station
	SETBIT	#XM$V_CHR_TRIB,UCB$L_DEVDEPEND(R5) ; Indicate tributary station
	BRB	30$				; And continue
 
20$:	SETBIT	#XM$V_CHR_DMC,UCB$L_DEVDEPEND(R5) ; Must be DMC compatible mode
	CLRL	R1				; Set mode to DMC compatible
 
30$:	ASHL	#1,R1,R1			; Shift for mode definition code
	SETBIT	#XM$V_CHR_HDPLX,UCB$L_DEVDEPEND(R5) ; Assume half duplex mode
	ASSUME	NMA$C_DPX_FUL EQ 0
	TSTB	UCB$B_XD_DUP(R5)		; Full duplex mode?
	BNEQ	40$				; Br if no - okay
	INCL	R1				; Set new device mode
	CLRBIT	#XM$V_CHR_HDPLX,UCB$L_DEVDEPEND(R5) ; Set to full duplex mode
40$:	MOVB	R1,UCB$B_XD_MODE(R5)		; Save device mode (DMP format)
	CLRBIT	#XM$V_CHR_LOOPB,UCB$L_DEVDEPEND(R5) ; Clear loopback bit
	ASSUME	NMA$C_LINCN_NOR EQ 0
	TSTB	UCB$B_XD_CON(R5)		; Is line in normal mode?
	BEQL	50$				; Br if yes
	SETBIT	#XM$V_CHR_LOOPB,UCB$L_DEVDEPEND(R5) ; Set loopback mode
50$:	CLRBIT	#UCB$V_XD_PTP,UCB$W_DEVSTS(R5)	; Assume not pt-pt
	BITL	#XM$M_CHR_CTRL!XM$M_CHR_TRIB,-	; Is this trib or ctrl station?
		UCB$L_DEVDEPEND(R5)		;
	BNEQ	60$				; Br if yes
	SETBIT	#UCB$V_XD_PTP,UCB$W_DEVSTS(R5)	; Else, indicate pt-pt
60$:	POPL	R4				; Restore R4
	RSB					; Return to caller

	.SBTTL	CHG_CDB,  Change CDB parameter values
 
;++
; CHG_CDB - Change CDB parameter values
;
; Functional description:
;
; This routine is called to initialize the CDB with new P1 and P2 buffer
; characteristics. It is assumed here that the parameters have already
; been validated.
;
; Inputs:
;
;	R3 = IRP address
;	R5 = UCB address
;	R9 = CDB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R1,R2 = destroyed.
;--
 
CHG_CDB:					; Validate P2 buffer
	PUSHL	R4				; Save R4
	BLBC	IRP$L_MEDIA(R3),10$		; Br if no P1 buffer
;
; Set new P1 buffer characteristics
;
	BICL	#^C<P1_TRIB_MASK>,-		; Clear all but special
		CDB_L_DEVDEPEND(R9) 		; ..fields in CDB
	BICL	#XM$M_STS_ACTIVE!XM$M_STS_RUNNING,- ; Clear special fields
		IRP$L_MEDIA+4(R3)		; ..from IRP
	BISL	IRP$L_MEDIA+4(R3),CDB_L_DEVDEPEND(R9) ; Set new characteristics
	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1
	CLRB	CDB_B_MST(R9)			; Assume MOP
	BBS	#XM$V_CHR_MOP,CDB_L_DEVDEPEND(R9),10$ ; Br if true
	INCB	CDB_B_MST(R9)			; Else, NORMAL mode
;
; Set new P2 buffer characteristics
;
10$:	MOVL	R9,R4				; Copy CDB address
	MOVAB	TRIB_PARAM,R1			; Get address of verification table
	BSBW	UPDATE_P2			; Update CDB
	MOVZBL	CDB_B_TRB_ADDR(R9),R1		; Get trib address
	MOVB	R1,IRP$Q_STATION(R3)		; Return trib address
	MOVZBL	IRP$B_INDEX(R3),R2		; Get vector index
	MOVB	R1,UCB$B_XD_TRIB_VEC(R5)[R2]	; Set new trib address
	CLRBIT	#XM$V_CHR_MOP,CDB_L_DEVDEPEND(R9) ; Assume not MOP mode
	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1
	BLBS	CDB_B_MST(R9),20$		; Br if MAINT state is OFF
	SETBIT	#XM$V_CHR_MOP,CDB_L_DEVDEPEND(R9) ; Else, indicate MOP
20$:	POPL	R4				; Restore R4
	RSB					; Return to caller

	.SBTTL	VALIDATE_P2,  Validate P2 buffer parameters
	.SBTTL	VALIDATE_P2_CDB,  Validate P2 buffer with CDB
	.SBTTL	VALIDATE_P2_UCB,  Validate P2 buffer with UCB
 
;++
; VALIDATE_P2 - Validate P2 buffer parameters
; VALIDATE_P2_CDB - Validate P2 buffer with CDB
; VALIDATE_P2_UCB - Validate P2 buffer with UCB
;
; This routine is called to validate the P2 buffer parameters. The parameters
; are checked against a parameter table which verifies that the minimum value
; and maximum value is not violated, and that invalid status flags are not set.
;
; Inputs:
;
;	R1 = Address of parameter verification table (VALIDATE_P2 entry only)
;	R2 = Status word from UCB or CDB
;	R3 = IRP address
;	R4 = UCB or CDB address for value checking (VALIDATE_P2 entry only)
;	R5 = UCB address
;	R9 = CDB address (VALIDATE_P2_CDB entry only)
;
;	IPL = FIPL
;
; Outputs:
;
;	R0 = status return of parameters
;
; If no error:
;	R1 = Address of parameter verification table
; If error:
;	R1 = Bad parameter value
;
;	All other registers are preserved.
;
;--
	.ENABL	LSB
VALIDATE_P2_CDB:				; Validate P2 buffer with CDB
	PUSHL	R4				; Save R4
	MOVAB	TRIB_PARAM,R1			; Get address of verification table
	MOVL	R9,R4				; Copy CDB address
	BRB	10$				;
VALIDATE_P2_UCB:				; Validate P2 buffer with UCB
	PUSHL	R4				; Save R4
	MOVAB	LINE_PARAM,R1			; Get address of verification table
	MOVL	R5,R4				; Copy UCB address
10$:	BSBB	VALIDATE_P2			; Do the validation
	POPL	R4				; Restore R4
	RSB					; Return to caller
	.DSABL	LSB
 
VALIDATE_P2:					; Validate P2 buffer parameters
	PUSHR	#^M<R1,R2,R3,R5,R6,R7,R8,R9>	; Save registers
						; NB:R1 must be on top of stack
	MOVL	IRP$L_SVAPTE(R3),R6		; Get system P2 buffer address
	BNEQ	10$				; Br if a system buffer
	BRW	150$				; Else, leave
;
; Make sure that if trib address given, that it is unique, or belongs to this
; circuit.
;
10$:	MOVL	R2,R9				; Save status word
	MOVZWL	#NMA$C_PCCI_TRI,R1		; Get trib address
	BSBW	UNPACK_P2_BUF			; From P2 buffer
	BLBC	R0,20$				; Br if no trib address
	LOCC	R2,#32,UCB$B_XD_TRIB_VEC(R5)	; Try to find same trib address
	BEQL	20$				; Br if unique
	MOVAB	UCB$B_XD_TRIB_VEC(R5),R8	; Else, get address of trib vec
	SUBL2	R8,R1				; Calculate index
	CMPB	IRP$B_INDEX(R3),R1		; If not unique, must be same CEB
	BEQL	20$				; Br if same circuit
	MOVZWL	#NMA$C_PCCI_TRI,R0		; Return bad parameter
	BRW	170$				; Else, error
 
20$:	MOVL	R9,R2				; Restore status word
	MOVZWL	IRP$W_BCNT(R3),R8		; Get size of P2 buffer
	DIVL	#6,R8				; Calculate number of parameters
	MOVL	P2B_L_POINTER(R6),R6		; Point to start of P2 data
;
; Loop to check next parameter in P2 buffer
;
30$:	MOVZWL	(R6)+,R0			; Get parameter type from P2
	MOVL	(R6)+,R5			; Get parameter value from P2
	MOVL	(SP),R7				; Get parameter table address
;
; Loop to check P2 buffer parameter to Line parameter table
;
40$:	MOVW	(R7)+,R9			; Get parameter + flags
	BEQL	170$				; Br if end of verify table
	CMPZV	#PRM_V_TYPE,#PRM_S_TYPE,R9,R0	; Parameters match?
	BEQL	50$				; Br if yes
	TSTW	(R7)+				; Skip offset word
	SKIP	PRM_V_MIN,R9,R7			; Skip minimum value
	SKIP	PRM_V_MAX,R9,R7			; Skip maximum value
	SKIP	PRM_V_INVALID,R9,R7		; Skip invalid flags
	BRB	40$				; Try next parameter
;
; Match found - nullify if same value & check min,max,valid,invalid
;
50$:	MOVW	(R7)+,R1			; Get offset + width
	TSTL	R4				; Is data structure present?
	BEQL	100$				; Br if not - check values
	EXTZV	#OFF_V_WIDTH,#OFF_S_WIDTH,R1,R3	; Get width only
	EXTZV	#OFF_V_VALUE,#OFF_S_VALUE,R1,R1	; Get offset only
	ADDL	R4,R1				; Calculate address of datum
	CASE	R3,TYPE=B,LIMIT=#1,<-		; Br to handler
		60$,-				;   Byte value
		70$,-				;   Word value
		80$>				;   Longword value
;
; Byte value in structure
;
60$:	CMPB	R5,(R1)				; Is this the same?
	BRB	90$				; Check result
;
; Word value
;
70$:	CMPW	R5,(R1)				; Is this the same?
	BRB	90$				; Check result
 
80$:	CMPL	R5,(R1)				; Is this the same?
90$:	BNEQ	100$				; Br if no - continue checks
	CLRW	-6(R6)				; Nullify the parameter code
	BRB	140$				; Try next parameter - skip checks

100$:	BBC	#PRM_V_MIN,R9,110$		; Br if no minimum value
	CMPW	R5,(R7)+			; Is the value too small?
	BLSSU	170$				; Br if yes - error
110$:	BBC	#PRM_V_MAX,R9,130$		; Br if no maximum value
	CMPW	R5,(R7)+			; Is the value too big?
	BGTRU	170$				; Br if yes - error
130$:	BBC	#PRM_V_INVALID,R9,140$		; Br if no invalid flags
	BITW	(R7)+,R2			; Check invalid bits
	BNEQ	170$				; Br if on - error
140$:	SOBGTR	R8,30$				; Loop if more parameters
 
150$:	MOVZWL	S^#SS$_NORMAL,R0		; Set success return
	BRB	180$				; And return
 
170$:	MOVZWL	R0,(SP)				; Return bad parameter code
						; * R1 Must be on top of stack
	MOVZWL	#SS$_BADPARAM,R0		; Set error return
180$:	POPR	#^M<R1,R2,R3,R5,R6,R7,R8,R9>	; Restore registers
	RSB					; Return to caller

	.SBTTL	UPDATE_P2,  Update UCB/CDB based on P2 buffer parameters
 
;++
; UPDATE_P2 - Update UCB/CDB with P2 buffer parameters
;
; This routine is called to update the UCB/CDB with the P2 buffer parameters.
; The parameters are stored in the appropriate cells of the UCB/CDB.
;
; Inputs:
;
;	R1 = Address of parameter verification table
;	R3 = IRP address
;	R4 = UCB or CDB address for storing
;	R5 = UCB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0 = destroyed.
;	All other registers are preserved.
;
;--
 
UPDATE_P2:					; Update the UCB/CDB
	PUSHR	#^M<R1,R2,R5,R6,R7,R8,R9>	; Save registers
						; NB:R1 must be on top of stack
	MOVL	IRP$L_SVAPTE(R3),R6		; Get system P2 buffer address
	BEQL	80$				; Br if no system buffer
	MOVZWL	IRP$W_BCNT(R3),R8		; Get size of P2 buffer
	DIVL	#6,R8				; Calculate number of parameters
	MOVL	P2B_L_POINTER(R6),R6		; Point to start of data
;
; Loop to get next parameter from P2 buffer
;
10$:	MOVZWL	(R6)+,R0			; Get parameter type from P2
	MOVL	(R6)+,R5			; Get parameter value from P2
	MOVL	(SP),R7				; Get parameter table address
;
; Loop to store buffer parameter in UCB/CDB
;
20$:	MOVW	(R7)+,R9			; Get parameter + flags
	BEQL	70$				; Br if end of verify table
	EXTZV	#PRM_V_TYPE,#PRM_S_TYPE,R9,R1	; Get type field
	CMPW	R0,R1				; Parameters match?
	BEQL	30$				; Br if yes
	TSTW	(R7)+				; Skip offset word
	SKIP	PRM_V_MIN,R9,R7			; Skip minimum value
	SKIP	PRM_V_MAX,R9,R7			; Skip maximum value
	SKIP	PRM_V_INVALID,R9,R7		; Skip invalid flags
	BRB	20$				; Try next parameter
;
; Match found - nullify if same value & check min,max,valid,invalid
;
30$:	MOVW	(R7)+,R1			; Get offset + width
	EXTZV	#OFF_V_WIDTH,#OFF_S_WIDTH,R1,R2	; Get width only
	EXTZV	#OFF_V_VALUE,#OFF_S_VALUE,R1,R1	; Get offset only
	ADDL	R4,R1				; Calculate address of datum
	CASE	R2,TYPE=B,LIMIT=#1,<-		; Br to handler
		40$,-				;   Byte value
		50$,-				;   Word value
		60$>				;   Longword value
;
; Byte, word, longword value in structure
;
40$:	MOVB	R5,(R1)				; Store byte value
	BRB	70$				; 
50$:	MOVW	R5,(R1)				; Store word value
	BRB	70$				;
60$:	MOVL	R5,(R1)				; Store longword value
70$:	SOBGTR	R8,10$				; Br if more parameters
 
80$:	POPR	#^M<R1,R2,R5,R6,R7,R8,R9>	; Restore registers
	RSB					; Return to caller

	.SBTTL	RETURN_P2,  Return UCB/CDB buffer parameters
 
;++
; RETURN_P2 - Return P2 buffer parameters
;
; This routine is called to return the UCB/CDB buffer parameters.
;
; Inputs:
;
;	R1 = Address of return table (same format as verification table)
;	R3 = IRP address
;	R4 = UCB or CDB address for storing
;	R5 = UCB address
;
; Outputs:
;
;	R0 = destroyed.
;	All other registers are preserved.
;
;--
 
RETURN_P2:					; Return P2 buffer parameters
	PUSHR	#^M<R1,R2,R5,R6,R7>		; Save registers
	MOVL	IRP$L_SVAPTE(R3),R6		; Get system P2 buffer address
	BEQL	60$				; Br if no system buffer
	MOVL	P2B_L_POINTER(R6),R6		; Point to start of output buf
;
; Loop to return next parameter
;
10$:	MOVW	(R1)+,R5			; Get parameter + flags
	BEQL	60$				; Br if end of verify table
	EXTZV	#PRM_V_TYPE,#PRM_S_TYPE,R5,R7	; Get type field
	MOVW	R7,(R6)+			; Return parameter
	MOVW	(R1)+,R7			; Get offset + width
	EXTZV	#OFF_V_WIDTH,#OFF_S_WIDTH,R7,R2	; Get width only
	EXTZV	#OFF_V_VALUE,#OFF_S_VALUE,R7,R7	; Get offset only
	ADDL	R4,R7				; Calculate address of datum
	CASE	R2,TYPE=B,LIMIT=#1,<-		; Br to handler
		20$,-				;   Byte value
		30$,-				;   Word value
		40$>				;   Longword value
;
; Byte, word, longword value in structure
;
20$:	MOVZBL	(R7),(R6)+			; Store byte value
	BRB	50$				; 
30$:	MOVZWL	(R7),(R6)+			; Store word value
	BRB	50$				;
40$:	MOVL	(R7),(R6)+			; Store longword value
50$:	SKIP	PRM_V_MIN,R5,R1			; Skip minimum value
	SKIP	PRM_V_MAX,R5,R1			; Skip maximum value
	SKIP	PRM_V_INVALID,R5,R1		; Skip invalid flags
	BRB	10$				; Try for more parameters
 
60$:	POPR	#^M<R1,R2,R5,R6,R7>		; Restore registers
	RSB					; Return to caller

	.SBTTL	UNPACK_P2_BUF,  Unpack a P2 parameter from P2 buffer
 
;++
; UNPACK_P2_BUF - Unpack a P2 parameter from P2 buffer
;
; Functional description:
;
; This routine is called to get a P2 parameter from the P2 buffer.
;
; Inputs:
;
;	R1 = Parameter type code
;	R3 = IRP address
;	R5 = UCB address
;
; Outputs:
;
;	R0 = Low bit clear if specified Parameter type code is found in P2
;	R2 = Parameter value if success else destroyed
;
;	All other registers are preserved.
;
;--
 
UNPACK_P2_BUF:					; Unpack P2 buffer
	PUSHR	#^M<R5,R6,R7>			; Save registers
	MOVL	IRP$L_SVAPTE(R3),R6		; Get system P2 buffer address
	BEQL	20$				; Br if none
	MOVZWL	IRP$W_BCNT(R3),R7		; Get size of P2 buffer
	DIVL	#6,R7				; Caculate number of parameters
	MOVAB	P2B_T_DATA(R6),R6		; Point to start of data
	MOVZWL	S^#SS$_NORMAL,R0		; Assume success
;
; Loop to check next parameter in P2 buffer
;
10$:	MOVZWL	(R6)+,R5			; Get parameter type from P2
	MOVL	(R6)+,R2			; Get parameter value from P2
	CMPW	R1,R5				; Parameters match?
	BEQL	30$				; Br if yes
	SOBGTR	R7,10$				; Br if more parameters
 
20$:	CLRL	R0				; Return error
30$:	POPR	#^M<R5,R6,R7>			; Restore registers
	RSB					; Return to caller

	.SBTTL	POKE_USER,  Deliver attention AST

;++
; POKE_USER, Deliver attention AST
;
; Functional description:
;
;	This routine is used to deliver an attention AST if one has been
;	requested.
;
; Inputs:
;
;	R5 = UCB address
;	R9 = CDB address
;
; Outputs:
;
;	R0 = Low bit clear only if user is not notified
;	R1-R4 = destroyed.
;
;--

POKE_USER:					; Poke user process
	DSBINT	UCB$B_FIPL(R5)			; Sync access to CDB
	CLRL	-(SP)				; Assume failure
	MOVAB	CDB_L_AST(R9),R1		; Get AST listhead
	TSTL	(R1)				; Empty?
	BEQL	30$				; Branch if yes
	INCL	(SP)				; Indicate success
	PUSHL	R4				; Save R4
	MOVL	R1,R4				; Copy listhead address
10$:	MOVL	(R1),R1				; Address a block
	BEQL	20$				; Branch if done
	MOVL	UCB$L_DEVDEPEND(R5),-		; Change parameter
		ACB$L_KAST+4(R1)		;    return status
	BISL	CDB_L_DEVDEPEND(R9),-		; OR in circuit status
		ACB$L_KAST+4(R1)		;
	BRB	10$				; Continue thru AST blocks
20$:	JSB	G^COM$DELATTNAST		; Deliver the AST's
	POPL	R4				; Restore R4
 
30$:	POPL	R0				; Return success indicator
	ENBINT					; Restore IPL
	RSB					; Return to caller

	.SBTTL	CANCEL,  Cancel I/O routine

;++
; CANCEL, Cancels an I/O operation in progress
;
; Functional description:
;
;	This routine cancels all I/O on the tributary.
;
; Inputs:
;
;	R2 = channel number 
;	R3 = current IRP address
;	R4 = PCB address 
;	R5 = UCB address
;	R8 = Cancel reason code (zero is for vanila flavored cancel).
;
;	IPL = FIPL
;
; Outputs:
;
;	R0-R3 are destroyed.
;
;--

CANCEL:						; Cancel an I/O operation
	PUSHQ	R8				; Save R8, R9
;;;;	MOVZBL	S^#1,R8				;***** ALWAYS DEASSIGN ****
	TSTW	UCB$W_REFC(R5)			; Last reference to unit?
	BNEQ	5$				; Br if no
;
; Last deassign on unit
;
	MOVL	UCB$L_CRB(R5),R3		; Get CRB address
	MOVL	@CRB$L_INTD+VEC$L_IDB(R3),R3	; Get CSR address
	MOVB	#XD_BSEL1_M_MCLR,BSEL1(R3)	; Master clear device
	BSBW	SHUTDOWN_DEV			; Shutdown the controller
	BSBW	INIT_UCB			; Re-initialize the UCB
	BRW	20$				; And leave
 
5$:	MOVL	PCB$L_PID(R4),R0		; Get PID
	MOVL	R2,R3				; Copy channel number
	BSBW	XLATE_PID_CHAN			; Translate PID and channel
	BLBC	R0,8$				; Br if none
	TSTL	R8				; Is this a plain cancel?
	BEQL	10$				; Br if yes
;
; Deassign channel request
;
	CLRL	UCB$L_XD_CDB_VEC(R5)[R1]	; Remove CDB address from vector
	CLRL	UCB$L_XD_PID_VEC(R5)[R1]	; Zero PID entry
	CLRW	UCB$W_XD_CHAN_VEC(R5)[R1]	; Zero channel entry
	CLRB	UCB$B_XD_TRIB_VEC(R5)[R1]	; Reset trib address
	DECB	UCB$B_XD_TRB_CNT(R5)		; One less tributary
	BBS	#CD_TS_V_ESTAB,CDB_W_STS(R9),7$	; Br if trib established
	BSBW	CLEAR_CDB			; Clean up CDB
	BRB	20$				; Pop registers and return

7$:	BSBW	DO_CANCEL			; Cancel waiting I/O
;
; Turn CDB into IRP to halt/kill trib
;
	MOVL	CDB_L_PID(R9),R0		; Save PID
       	MOVB	CDB_B_TRB_ADDR(R9),R1		; Save trib address
	MOVL	R9,R2				; Copy pointer to IRP
	BSBW	BLD_IRP				; Build the IRP
	MOVL	R0,IRP$L_MEDIA(R3)		; Save PID in IRP
	MOVB	R1,IRP$Q_STATION(R3)		; Store trib address
	MOVB	#XD_FC_V_HALTT,IRP$B_XDFUNC(R3) ; Set to halt tributary
	DSBINT	UCB$B_DIPL(R5)			; Sync access to device
	INSQUE	(R3),UCB$Q_XD_INPUTQ(R5)	; Insert at front of input Q
	BSBW	LOAD_PORT			; Give request to device
	ENBINT					; Restore IPL
8$:	BRB	20$				;
;
; Cancel request
;
10$:	BBC	#CD_TS_V_ESTAB,CDB_W_STS(R9),20$ ; Br if trib not established
	JSB	G^EXE$ALLOCIRP			; Allocate an IRP
	BLBS	R0,15$				; Br if success
	MOVZWL	#SS$_INSFMEM,R0			; Else, set error return
	SETIPL	#0				; Allow interrupts
	RET					; RETURN to caller
 
15$:	CLRBIT	#XM$V_STS_ACTIVE,-		; Clear active flag
		CDB_L_DEVDEPEND(R9)		; ..to flush pending I/O
	BSBW	BLD_IRP				; Build an IRP
	MOVAB	W^RETURN_IRP,IRP$L_PID(R3)	; Set return address in IRP
	MOVB	CDB_B_TRB_ADDR(R9),IRP$Q_STATION(R3) ; Store trib address
	MOVB	#XD_FC_V_CANCEL,IRP$B_XDFUNC(R3) ; Set function request
	DSBINT	UCB$B_DIPL(R5)			; Sync access to device
	INSQUE	(R3),UCB$Q_XD_INPUTQ(R5)	; Insert at front of input Q
	BSBW	LOAD_PORT			; Give request to device
	ENBINT					; Restore IPL
	BSBB	DO_CANCEL			; Cancel waiting I/O
20$:	POPQ	R8				; Restore R8, R9
	RSB					; Return to caller
 
DO_CANCEL:					; Do the cancel on waiting I/O
;
; NOTE: The xmit request queue on the UCB must only be accessed at FIPL
;
	MOVAL	UCB$Q_XD_XMT_REQ(R5),R2		; Get address of xmit request Q
	MOVL	R2,R1				; Copy listhead address
10$:	MOVL	IRP$L_IOQBL(R1),R1		; Get address of next entry
	CMPL	R2,R1				; End of queue?
	BEQL	20$				; Br ir yes
	CMPL	IRP$L_PID(R1),CDB_L_PID(R9)	; Do the PIDs match?
	BNEQ	10$				; Br if no - try next packet
	CMPL	IRP$W_CHAN(R1),CDB_W_CHAN(R5)	; Do the Channels match?
	BNEQ	10$				; Br if no - try next packet
	REMQUE	IRP$L_IOQFL(R1),R3		; Remove packet from queue
	BSBW	ABORT_PKT			; Abort the IRP
	BRB	10$				; Check entire queue
 
20$:	BSBW	SHUTDOWN_TRIB			; Clear all CDB I/O
	RSB					; Return
 
;++
; BLD_IRP - Build an IRP
;
; Inputs:
;
;	R2 = address of IRP
;	R5 = UCB address
;
; Outputs:
;
;	R2 = Address of IRP$Q_STATION in IRP
;	R3 = Original address of IRP
;--
 
BLD_IRP:					; Build an IRP
	MOVAQ	(R2)+,R3			; Save IRP address, skip to size field
	ASSUME	IRP$W_SIZE EQ 8
	ASSUME	IRP$B_TYPE EQ IRP$W_SIZE+2
	ASSUME	IRP$B_RMOD EQ IRP$B_TYPE+1
	MOVL	#<<DYN$C_IRP@16>!CDB_C_LENGTH>,(R2)+ ; Make it look like an IRP
	ASSUME	IRP$L_PID EQ IRP$B_RMOD+1
	MOVAB	W^RETURN_CDB,(R2)+		; Store return address from IOPOST
	ASSUME	IRP$L_AST EQ IRP$L_PID+4
	ASSUME	IRP$L_ASTPRM EQ IRP$L_AST+4
	CLRQ	(R2)+				; Clear AST, ASTPRM
	ASSUME	IRP$L_WIND EQ IRP$L_ASTPRM+4
	CLRL	(R2)+				; Clear WIND
	ASSUME	IRP$L_UCB EQ IRP$L_WIND+4
	MOVL	R5,(R2)+			; Store UCB address
	ASSUME	IRP$W_FUNC EQ IRP$L_UCB+4
	ASSUME	IRP$B_EFN EQ IRP$W_FUNC+2
	ASSUME	IRP$B_PRI EQ IRP$B_EFN+1
	ASSUME	IRP$L_IOSB EQ IRP$B_PRI+1
	CLRQ	(R2)+				; Clear FUNC, EFN, PRI, IOSB
	ASSUME	IRP$W_CHAN EQ IRP$L_IOSB+4
	ASSUME	IRP$W_STS EQ IRP$W_CHAN+2
	ASSUME	IRP$L_SVAPTE EQ IRP$W_STS+2
	CLRQ	(R2)+				; Clear CHAN, STS, SVAPTE
	ASSUME	IRP$W_BOFF EQ IRP$L_SVAPTE+4
	ASSUME	IRP$W_BCNT EQ IRP$W_BOFF+2
	ASSUME	IRP$L_MEDIA EQ IRP$W_BCNT+6	; BCNT is really a longword
	CLRQ	(R2)+				; Clear BOFF, BCNT
	CLRQ	(R2)+				; Clear MEDIA
	ASSUME	IRP$Q_STATION EQ IRP$L_MEDIA+8
	CLRQ	(R2)+				; Clear STATION
	RSB					; Return to caller

	.SBTTL	INIT_UCB,  Initialize UCB parameters
 
;++
; INIT_UCB - Initialize UCB parameters
;
; Functional description:
;
; This routine is called to reset the UCB default parameters when
; the last channel is deassigned or when the unit is initialized.
;
; Inputs:
;
;	R5 = UCB address
;
;	IRP = FIPL or higher
;
; Outputs:
;
;	R0-R2 are destroyed.
;
;--
 
INIT_UCB:					; Initialize the UCB
	ASSUME	UCB$B_XD_OUTTIM EQ UCB$B_XD_INTIM+1
	CLRW	UCB$B_XD_INTIM(R5)		; Stop all timers
	ASSUME	UCB$B_XD_DUP EQ UCB$B_XD_PRO+1
	ASSUME	UCB$B_XD_CON EQ UCB$B_XD_DUP+1
	ASSUME	UCB$B_XD_BFN EQ UCB$B_XD_CON+1
	CLRL	UCB$B_XD_PRO(R5)		; Reset all line characteristics
	MOVW	#XD_DEF_BUFSIZ,UCB$W_DEVBUFSIZ(R5) ; Set default buffer size
	MOVB	#MAX_XMT_TRB,-			; Set maximum number of xmits
		UCB$B_XD_XMT_TRB(R5)		; ..per tributary
	MOVZWL	#DEF_LINE_PARAMSZ,R0		; Set size of defaults in bytes
	MOVAB	DEF_LINE_PARAM,R1		; Set address of defaults
	MOVAB	UCB$B_XD_SETPRM(R5),R2		; Set address of parameters
10$:	MOVB	(R1)+,(R2)+			; Set next default
	SOBGTR	R0,10$				; Loop on all parameters
	RSB

	.SBTTL	Timer setup routines
 
;++
; Timer setup routines
;
; Functional description:
;
; These routines set/reset the input and output wait timers.
;
; Inputs:
;
;	R5 = UCB address
;
; Outputs:
;
;	R0,R1 are destroyed.
;
;--
 
SET_INTIM:					; Start input timer
	MOVAB	UCB$Q_XD_INPUTQ(R5),R1		; Get address of input queue
	CMPL	(R1),R1				; Anything on queue?
	BNEQ	20$				; Br if yes - reset timer
10$:	RSB					; Else, exit
 
20$:	TSTB	UCB$B_XD_INTIM(R5)		; Timer already going?
	BNEQ	10$				; Br if yes - exit
	MOVB	#3,UCB$B_XD_INTIM(R5)		; Reset timeout cell
	BRB	START_TIMER			; Start timer if needed
 
SET_OUTTIM:					; Start output timer
	DSBINT	UCB$B_DIPL(R5)			; Disable device interrupts
	CLRB	UCB$B_XD_OUTTIM(R5)		; Clear output timer
	MOVAB	UCB$Q_XD_INFOUT(R5),R1		; Get address of UCB output queue
	CMPL	(R1),R1				; Anything on queue?
	BNEQ	30$				; Br if yes - reset timer
	MOVZBL	S^#31,R0			; Get maximum number of CDBs
10$:	MOVL	UCB$L_XD_CDB_VEC(R5)[R0],R1	; Get address of next CDB
	BEQL	20$				; Br if none
	BBC	#CD_TS_V_ESTAB,CDB_W_STS(R1),20$ ; Br if trib not established
	MOVAB	CDB_Q_INFOUT(R1),R1		; Get address of output queue
	CMPL	(R1),R1				; Anything on queue?
	BNEQ	30$				; Br if yes - reset timer
20$:	SOBGEQ	R0,10$				; Loop on all CDBs
	ENBINT					; Restore IPL
	RSB					; Else, exit
 
30$:	ENBINT					; Restore IPL
	MOVB	#10,UCB$B_XD_OUTTIM(R5)		; Reset timeout cell
	;BRB	START_TIMER			; Start timer
 
START_TIMER:					; Startup timer
	BBS	#UCB$V_TIM,UCB$W_STS(R5),10$	; Br if timer going
	ADDL3	#2,G^EXE$GL_ABSTIM,UCB$L_DUETIM(R5) ; Set 2 second timer
	BISW	#UCB$M_TIM!UCB$M_INT,UCB$W_STS(R5) ; Enable timer
10$:	RSB

	.SBTTL	TIMEOUT,  Timeout Routine

;++
; TIMEOUT - Timeout Routine
;
; Functional description:
;
; This routine is entered on tributary timeout.  The action is to set
; the error status and branch to the error routine.
;
; Inputs:
;
;	R5 = UCB address
;
; Outputs:
;
;	R3,R4 are destroyed.
;	R5 is preserved.
;
;--

TIMEOUT:
	BICW	#UCB$M_TIM!UCB$M_INT,UCB$W_STS(R5) ; Disable timer
	BBC	#UCB$V_XD_INITED,UCB$W_DEVSTS(R5),40$ ; Br if not inited
	ASHL	#XD_BSEL2_V_ERR+16,#1,R3	; Set error indicator
	ASHL	#16,#1,R4			; Assume powerfail
	BBS	#UCB$V_POWER,UCB$W_STS(R5),30$	; Br if powerfail
	TSTB	UCB$B_XD_INTIM(R5)		; Input timer going?
	BEQL	10$				; Br if not
	DECB	UCB$B_XD_INTIM(R5)		; Input wait timeout?
	BEQL	20$				; Br if yes - error
	PUSHAB	B^START_TIMER			; Else, remember to restart timer
10$:	TSTB	UCB$B_XD_OUTTIM(R5)		; Output timer going?
	BEQL	40$				; Br if not - exit
	DECB	UCB$B_XD_OUTTIM(R5)		; Output wait timeout?
	BNEQ	START_TIMER			; Br it not - restart timer
20$:	MOVL	UCB$L_CRB(R5),R4		; Get CRB address
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R4	; Get CSR address
	MOVB	#XD_BSEL1_M_MCLR,BSEL1(R4)	; Stop the device
	CLRL	R4				; Indicate timeout
	SETBIT	#XM$V_STS_TIMO,UCB$L_DEVDEPEND(R5) ; Set error status
30$:	BSBW	SCHED_FORK			; Schedule a fork process
40$:	RSB					; Return to caller
 

XD_END:						; Last location in driver
	.END
