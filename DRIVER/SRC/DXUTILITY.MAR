	.TITLE	DXUTILITY - FLOPPY DISK DRIVER UTILITY ROUTINES
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; C. A. MONIA 25-JUN-77
;
; MODIFIED BY:
;
;	V02-003	TCM0001		Trudy C. Matthews	19-Jun-1981
;		Clear R1 (which becomes the second longword of the IOSB)
;		before exiting.  This is because certain code paths through
;		I/O completion (notably for paging I/O and swapping I/O,
;		when this driver is being used for standalone sysgen systems)
;		expect the second longword of the IOSB to be zero.
;
;
; STAR FLOPPY DRIVER UTILITY ROUTINES
;
; MACRO LIBRARY CALLS
;
 
	$ADPDEF				;DEFINE ADP OFFSETS
	$CRBDEF				;DEFINE CRB OFFSETS
	$EMBDEF				;DEFINE EMB OFFSETS
	$IDBDEF				;DEFINE IDB OFFSETS
	$IODEF				;DEFINE I/O FUNCTION CODES
	$IRPDEF				;DEFINE IRP OFFSETS
	$PRDEF				;DEFINE PROCESSOR REGISTERS
	$SSDEF				;DEFINE SYSTEM STATUS VALUES
	$UBADEF				;DEFINE UBA REGISTER OFFSETS
	$UCBDEF				;DEFINE UCB OFFSETS
	$VECDEF				;DEFINE INTERRUPT DISPATCH VECTOR OFFSETS
 
;
; LOCAL MACROS
;
; REPORT DEVICE ERROR
;
 
	.MACRO	RPTERR	CODE
	MOVZWL	CODE,R0
	BRB	FUNCXT
	.ENDM
	.PAGE
	.SBTTL	RX FUNCTION DECISION TABLE
;+
; RX FUNCTION DECISION TABLE
;-
 
	.PSECT	$$$115_DRIVER,LONG
DX$FUNCTABLE::				;FUNCTION DECISION TABLE
	FUNCTAB	,-			;LEGAL FUNCTIONS
		<SENSECHAR,-		;SENSE CHARACTERISTICS
		SETCHAR,-		;SET CHARACTERISTICS
		SENSEMODE,-		;SENSE MODE
		SETMODE,-		;SET MODE
		READLBLK,-		;READ LOGICAL BLOCK
		WRITELBLK,-		;WRITE LOGICAL BLOCK
		READPBLK,-		;READ PHYSICAL BLOCK
		WRITEPBLK,-		;WRITE PHYSICAL BLOCK
		READVBLK,-		;READ VIRTUAL BLOCK
		WRITEVBLK,-		;WRITE VIRTUAL BLOCK
		ACCESS,-		;ACCESS FILE AND/OR FIND DIRECTORY ENTRY
		ACPCONTROL,-		;ACP CONTROL FUNCTION
		CREATE,-		;CREATE FILE AND/OR DIRECTORY ENTRY
		DEACCESS,-		;DEACCESS FILE
		DELETE,-		;DELETE FILE AND/OR DIRECTORY ENTRY
		MODIFY,-		;MODIFY FILE ATTRIBUTES
		MOUNT>			;MOUNT VOLUME
	FUNCTAB	,-			;BUFFERED I/O FUNCTIONS
		<SENSECHAR,-		;SENSE CHARACTERISTICS
		SETCHAR,-		;SET CHARACTERISTICS
		SENSEMODE,-		;SENSE MODE
		SETMODE,-		;SET MODE
		ACCESS,-		;ACCESS FILE AND/OR FIND DIRECTORY ENTRY
		ACPCONTROL,-		;ACP CONTROL FUNCTION
		CREATE,-		;CREATE FILE AND/OR DIRECTORY ENTRY
		DEACCESS,-		;DEACCESS FILE
		DELETE,-		;DELETE FILE AND/OR DIRECTORY ENTRY
		MODIFY,-		;MODIFY FILE ATTRIBUTES
		MOUNT>			;MOUNT VOLUME
	FUNCTAB	+ACP$READBLK,-		;READ FUNCTIONS
		<READLBLK,-		;READ LOGICAL BLOCK
		READPBLK,-		;READ PHYSICAL BLOCK
		READVBLK>		;READ VIRTUAL BLOCK
	FUNCTAB	+ACP$WRITEBLK,-		;WRITE FUNCTIONS
		<WRITELBLK,-		;WRITE LOGICAL BLOCK
		WRITEPBLK,-		;WRITE PHYSICAL BLOCK
		WRITEVBLK>		;WRITE VIRTUAL BLOCK
	FUNCTAB	+ACP$ACCESS,<ACCESS,CREATE> ;ACCESS AND CREATE FILE OR DIRECTORY
	FUNCTAB	+ACP$DEACCESS,<DEACCESS>;DEACCESS FILE
	FUNCTAB	+ACP$MODIFY,-		;
		<ACPCONTROL,-		;ACP CONTROL FUNCTION
		DELETE,-		;DELETE FILE OR DIRECTORY ENTRY
		MODIFY>			;MODIFY FILE ATTRIBUTES
	FUNCTAB	+ACP$MOUNT,<MOUNT>	;MOUNT VOLUME
	FUNCTAB	+EXE$SENSEMODE,-	;
		<SENSECHAR,-		;SENSE CHARACTERISTICS
		SENSEMODE>		;SENSE MODE
	FUNCTAB	+EXE$SETCHAR,-		;
		<SETCHAR,-		;SET CHARACTERISTICS
		SETMODE>		;SET MODE
	.PAGE
	.SBTTL	START I/O OPERATION
 
;+
; DX$STARTIO - START I/O ON FLOPPY DEVICE UNIT
;
; THIS ROUTINE IS ENTERED VIA A 'BSBW' TO START I/O ON A DEVICE UNIT.
; CONTROL ALTERNATES BETWEEN THE FLOPPY DRIVER AND THIS CODE. THIS ROU-
; TINE IS CALLED TO PERFORM HARDWARE INDEPENDANT PROCESSING. ALL HARD-
; WARE SPECIFIC PROCESSING IS PERORMED BY DEVICE-SPECIFIC CODE IN THE
; DRIVER. 
;
; THE PROTOCOL IS AS FOLLOWS:
;
;	1. THE DRIVER CALLS DX$STARTIO TO ESTABLISH INITIAL CONDITIONS.
;
;	2. DXUTILITY COMPUTES THE PHYSICAL MEDIA ADDRESS AND BUFFER ADDRESS
;	   AND EXECUTES A CO-ROUTINE CALL TO THE DRIVER.
;
;	3. THE DRIVER POSITIONS THE MEDIA, PERFORMS ANY ADDITIONAL HARDWARE
;	   FUNCTIONS AND RETURNS CONTROL TO DXUTILITY.
;
;	4. CONTROL ALTERNATES BETWEEN THE DRIVER AND DXUTILITY UNTIL ONE
;	   SECTOR OF DATA HAS BEEN TRANSFERRED TO THE INTERNAL BUFFER.
;
;	5. DXUTILITY FLAGS COMPLETION OF A SECTOR TRANSFER AND CALLS THE DRI-
;	   VER TO PERFORM END-OF-SECTOR PROCESSING AND DROP TO FORK LEVEL.
;
;	6. THE DRIVER CALLS DXUTILITY TO UPDATE THE MEDIA ADDRESS. IF MORE
;	   DATA REMAINS TO BE TRANSFERRED, DXUTILITY TRANSFERS CONTROL TO
;	   STEP 2 TO CONTINUE PROCESSING.
;
; EACH CO-ROUTINE CALL SITE CONTAINS A CONTINGENCY EXIT ADDRESS. IN THE
; EVENT OF A HARDWARE ERROR, CONTROL WILL BE PASSED TO THE ERROR HANDLER
; TO EFFECT A RE-TRY OR TERMINATE THE REQUEST.
;
; INPUTS:
;
;	R3 = ADDRESS OF I/O PACKET
;
;	R5 = UCB ADDRESS OF DEVICE UNIT
;
; OUTPUTS:
;
;	*******OUTPUTS*******
;
;-
 
	.ENABL	LSB
 
DX$STARTIO::				;START I/O OPERATION
	BBS	#IRP$V_PHYSIO,IRP$W_STS(R3),1$ ;BYPASS BLOCK COMPUTATION IF PHYSICAL I/O
	EMUL	#4,IRP$L_MEDIA(R3),#0,R0 ;SCALE LBN, QUAD RESULT TO R0
	MOVZBL	UCB$L_DEVDEPEND(R5),R2	;GET NUMBER OF SECTORS PER TRACK
	EDIV	R2,R0,R0,IRP$L_MEDIA(R3) ;COMPUTE SECTOR
	MOVZBL	UCB$L_DEVDEPEND+1(R5),R2 ;GET TRACKS PER CYLINDER
	EDIV	R2,R0,R0,R1		;COMPUTE TRACKS (R1), CYL. (R0)
	MOVB	R1,IRP$L_MEDIA+1(R3)	;SAVE TRACK ADDRESS
	MOVW	R0,IRP$L_MEDIA+2(R3)	;SAVE CYLINDER ADDRESS
1$:					;
	MOVW	UCB$W_BCNT(R5),UCB$W_DX_BCR(R5) ;STORE BYTE COUNT
	BBCC	#UCB$V_DX_WRITE,UCB$W_DEVSTS(R5),2$ ;CLEAR WRITE FLAG
2$:					;
	BSBW	SETBUF			;SETUP BUFFER PARAMETERS
	EXTZV	#IRP$V_FCODE,#IRP$S_FCODE,IRP$W_FUNC(R3),R0 ;GET FUNCTION CODE
	CMPB	R0,#IO$_READPBLK	;READ PHYSICAL BLOCK?
	BEQL	5$			;IF EQL YES
	BBSS	#UCB$V_DX_WRITE,UCB$W_DEVSTS(R5),3$ ;SET WRITE FLAG
3$:					;
	BSBW	MOVFRUSER		;GET INITIAL SECTOR FULL OF DATA
5$:					;
	MOVB	UCB$B_ERTMAX(R5),UCB$B_ERTCNT(R5) ;INITIALIZE ERROR RETRY COUNT
	BBC	#IO$V_INHRETRY,IRP$W_FUNC(R3),10$ ;IF BIT CLEAR, PERFORM NORMAL RETRIES
	CLRB	UCB$B_ERTCNT(R5)	;INHIBIT RETRIES ON ERROR
10$:					;
	BSBB	TRKSEC			;COMPUTE MEDIA ADDRESS
	CMPB	2(R2),UCB$W_CYLINDERS(R5) ;LEGAL DISK ADDRESS?
	BGEQU	62$			;IF GEQU NO
	BICW	#UCB$M_CANCEL!-		;CLEAR CANCEL I/O,
	UCB$M_INTTYPE!-			;INTERRUPT TYPE
	UCB$M_POWER!-			;POWERFAIL,AND
	UCB$M_TIMOUT,UCB$W_STS(R5)	;TIMEOUT STATUS BITS
20$:					;
	INCL	R3			;FLAG READY FOR TRANSFER
	JSB	@(SP)+			;SEEK/TRANSFER ONE BYTE OF DATA
	CLRL	R3			;ASSUME TRANSFERRED LAST BYTE
	INCL	UCB$L_DX_BFPNT(R5)	;INCREMENT BUFFER POINTER
	DECB	UCB$B_DX_SCTCNT(R5)	;DECREMENT SECTOR COUNT
	BNEQ	20$			;IF NEQ TRANSFER ANOTHER BYTE
	JSB	@(SP)+			;CALL THE CALLER
	BSBW	XFER			;TRANSFER DATA TO/FROM USER
	BLBC	R0,IOSUCC		;IF LBC DONE
 
;
; COMPUTE NEXT MEDIA ADDRESS
;
 
40$:					;
	MOVL	#2,R0			;SET LOOP COUNT
	MOVL	UCB$L_IRP(R5),R3	;GET ADDRESS OF I/O PACKET
	MOVAB	IRP$L_MEDIA(R3),R2	;POINT TO MEDIA LOGICAL ADDRESS
	MOVAB	UCB$B_SECTORS(R5),R1	;POINT TO DISK DIMENSIONS
50$:					;
	INCB	(R2)			;INCREMENT MEDIA ADDRESS
	CMPB	(R2),(R1)+		;TEST AGAINST DISK SIZE
	BLSSU	10$			;IF LSSU HAVE NEXT MEDIA ADDRESS
	CLRB	(R2)+			;RESET ADDRESS
	SOBGEQ	R0,50$			;LOOP TO NEXT ADDRESS
62$:					;
	RPTERR	#SS$_IVADDR		;REPORT INVALID DISK ADDRESS
 
;+
; DX$ERR - CONTINGENCY EXIT HANDLER
;
; THIS ROUTINE IS ENTERED WHENEVER THE DRIVER DETECTS A POWER-FAIL, DEVICE
; TIMEOUT OR HARDWARE ERROR CONDITION.  IF THE ERROR WAS CAUSED BY DEVICE
; TIMEOUT OR POWER FAIL, THE TRANSFER IS RESTARTED. IF THE ERROR IS NON-
; FATAL, THE RETRY COUNT IS DECREMENTED AND THE TRANSFER IS REPEATED IF
; THE RESULT IS NONZERO. ALL OTHER CONDITIONS RESULT IN REQUEST TERMINA-
; TION WITH STATUS CONTAINED IN R0
;
; INPUTS:
;
;	R0 = ERROR STATUS CODE
;	R3 = ERROR SEVERITY INDICATION
;
;	R5 = ADDRESS OF UCB
;	(SP) = RETURN TO DRIVER RESTART CODE
;
; 	R3 LBC = FATAL ERROR
;	R3 LBS = RETRIABLE ERROR
;
; OUTPUTS:
;
;	NONE
;-
 
DX$ERR::				;
	BLBC	R3,FUNCXT		;IF LBC, FATAL HARDWARE ERROR
	BBS	#UCB$V_POWER,UCB$W_STS(R5),10$ ;RETRY ON POWER FAIL
	DECB	UCB$B_ERTCNT(R5)	;DECREMENT RETRY COUNT
	BGTR	10$			;IF GTR, TRY AGAIN
	BRB	FUNCXT			;TERMINATE REQUEST
 
	.DSABL	LSB
 
;
; TERMINATE REQUEST SUCCESFULLY
;
 
IOSUCC:					;
	MOVZWL	#SS$_NORMAL,R0		;SET SUCCESS
 
;
; FUNCTION COMPLETION COMMON EXIT
;
 
FUNCXT:					;
	CLRL	(SP)			;ZERO COROUTINE ADDRESS ON STACK
	PUSHL	R0			;SAVE REGISTER
	JSB	G^IOC$DIAGBUFILL	;FILL DIAGNOSTIC BUFFER IF PRESENT
	SUBW3	UCB$W_DX_BCR(R5),UCB$W_BCNT(R5),2(SP) ;COMPUTE BYTES TRANSFERRED
	POPR	#^M<R0,R1>		;RESTORE R0 AND PUT ZERO IN R1
	REQCOM				;TERMINATE REQUEST
 
;+
; TRKSEC - CONVERT LOGICAL TO PHYSICAL DISK ADDRESS
;
; THIS ROUTINE IS ENTERED VIA A 'BSB' TO CONVERT A LOGICAL DISK
; ADDRESS TO A PHYSICAL ADDRESS. IF THE PHYSICAL I/O FLAG IS SET
; IN THE I/O REQUEST PACKET, THE CONVERSION CONSISTS OF SIMPLY
; MOVING THE LOGICAL TRACK, SECTOR AND CYLINDER ADDRESSES IN
; THE PACKET MEDIA LONGWORD TO THE MEDIA ADDRESS LONGWORD IN
; THE UCB. IF LOGICAL I/O IS BEING PERFORMED, THEN THE LOGICAL
; ADDRESS IN THE I/O PACKET IS CONVERTED TO A PHYSICAL ADDRESS
; BY APPLYING INTERLEAVE AND TRACK-TO-TRACK SKEW. THE RESULT IS
; PLACED IN THE UCB MEDIA ADDRESS LONGWORD.
;
; INPUTS:
;
;
;	R5 = ADDRESS OF UCB
;
; OUTPUTS:
;
;	R2 = POINTER TO PHYSICAL MEDIA ADDRESS
;
;	UCB$L_MEDIA CONTAINS THE PHYSICAL MEDIA ADDRESS
;
; 
;-
 
TRKSEC:					;
	MOVL	UCB$L_IRP(R5),R3	;GET ADDRESS OF REQUEST PACKET
	MOVAB	UCB$L_MEDIA(R5),R2	;POINT TO PHYSICAL MEDIA ADDRESS
	MOVL	IRP$L_MEDIA(R3),(R2)	;COPY LOGICAL ADDRESS
	BBS	#IRP$V_PHYSIO,IRP$W_STS(R3),10$ ;BYPASS CONVERSION IF PHYSICAL I/O
	MOVZBL	(R2),R1			;GET CURRENT LOGICAL SECTOR
	CMPB	#12,R1			;SET C IF 12 < SECTOR <= 26
	ADWC	R1,R1			;DOUBLE SECTOR NUMBER, ADD INTERLEAVE FACTOR
	MOVZBL	2(R2),R0		;GET CYLINDER NUMBER
	EMUL	#6,R0,R1,R0		;COMPUTE SKEW (6 * CYL + SECT)
	MOVZBL	UCB$B_SECTORS(R5),-(SP) ;GET SECTORS/TRACK
	EDIV	(SP)+,R0,R0,R1		;MODULO SECTOR INTO SECTORS PER TRACK
	INCL	R1			;OFFSET SECTOR NUMBER BY 1
	MOVB	R1,(R2)			;SAVE SECTOR NUMBER
	INCB	2(R2)			;INCREMENT PAST UNUSED CYLINDER
10$:					;
	RSB				;
 
;+
; XFER - TRANSFER DATA TO OR FROM USER
;
; THIS ROUTINE IS ENTERED VIA A BSB TO TRANSFER ONE SECTOR'S WORTH OF DATA
; TO OR FROM THE USER'S PROCESS.
;
; INPUTS:
;
;	R5 = ADDRESS OF UCB
;	UCB$W_DX_BCR = BYTES LEFT TO TRANSFER
;
; OUTPUTS:
;
;	R0 LSB SET = MORE DATA TO TRANSFER
;	UCB$W_DX_BCR = COUNT OF BYTES REMAINING
;	R0 LSB CLEAR = NO MORE DATA TO TRANSFER
;
;-
 
	.ENABL	LSB
 
XFER:					;
	CLRL	-(SP)			;ASSUME REQUEST COMPLETE
	BSBB	SETBUF			;SETUP TRANSFER PARAMETERS
	SUBW	R2,UCB$W_DX_BCR(R5)	;UPDATE BYTE COUNT
	BBC	#UCB$V_DX_WRITE,UCB$W_DEVSTS(R5),10$ ;BRANCH IF READ REQUEST
	BEQL	30$			;IF EQL DONE
	BSBB	SETBUF			;GET MORE DATA FROM USER
	BSBB	MOVFRUSER		;...
	BRB	20$			;EXIT SUCCESSFULLY
10$:					;
	BSBB	MOVTOUSER		;MOVE DATA TO USER
	TSTW	UCB$W_DX_BCR(R5)	;TRANSFER COMPLETE NOW?
	BEQL	30$			;IF EQL YES
20$:					;
	INCL	(SP)			;SET SUCCESS
30$:					;
	MOVL	(SP)+,R0		;SET SUCCESS
	RSB				;
 
	.DSABL	LSB
 
;+
; MOVFRUSER - MOVE DATA FROM USER TO FLOPPY BUFFER
;
; INPUTS:
;
;	R1 = ADDRESS OF FLOPPY BUFFER
;	R2 = BYTE COUNT
;	R5 = ADDRESS OF UCB
;
; OUTPUTS:
;
;	THE CONTENTS OF THE INTERNAL BUFFER ARE COPIED FROM THE USER'S
;	ADDRESS SPACE.
;
;-
 
	.ENABL	LSB
 
MOVFRUSER:				;
	MOVL	R2,R4			;SAVE BYTE COUNT
	JSB	G^IOC$MOVFRUSER		;MOVE DATA
	BRB	10$			;UPDATE BUFFER ADDRESS
 
;+
; MOVTOUSER - MOVE CONTENTS OF FLOPPY INTERNAL BUFFER TO USER
;
; THIS ROUTINE IS CALLED TO TRANSFER THE CONTENTS OF THE FLOPPY DATA
; BUFFER TO THE USER'S ADDRESS SPACE.
;
; INPUTS:
;
;	R1 = ADDRESS OF FLOPPY BUFFER
;	R2 = BYTE COUNT
;	R5 = ADDRESS OF UCB
;
; OUTPUTS:
;
;	THE FLOPPY BUFFER CONTENTS ARE COPIED TO THE USER'S ADDRESS SPACE
;
;-
 
MOVTOUSER:				;
	MOVL	R2,R4			;SAVE BYTE COUNT
	JSB	G^IOC$MOVTOUSER		;MOVE DATA TO USER'S BUFFER
10$:					;
	ADDW	R4,UCB$W_BOFF(R5)	;UPDATE PAGE OFFSET
	BICW	#^C<^X01FF>,UCB$W_BOFF(R5) ;MAKE MODULO PAGE SIZE
	BNEQ	20$			;IF NEQ PAGE BOUNDARY NOT CROSSED
	ADDL	#4,UCB$L_SVAPTE(R5)	;UPDATE ADDRESS OF USER PTE
20$:					;
	RSB				;
 
	.DSABL	LSB
 
;+
; SETBUF - SETUP PARAMETERS FOR TRANSFER TO OR FROM USER'S BUFFER
;
; THIS ROUTINE IS ENTERED VIA A BSB TO INITIALIZE ALL PARAMETERS REQUIRED
; TO TRANSFER ONE SECTOR OF DATA TO OR FROM THE USER'S PROCESS.
;
; INPUTS:
;
;	R5 = ADDRESS OF UCB
;
; OUTPUTS:
;
;	R1 = ADDRESS OF SECTOR BUFFER
;	R2 = NUMBER OF BYTES TO TRANSFER TO OR FROM USER
;	UCB$B_SECTCNT = 128
;	UCB$L_DXBFPNT = ADDRESS OF SECTOR BUFFER
;-
 
SETBUF:					;
	MOVZWL	UCB$W_DX_BCR(R5),R0	;GET COUNT OF BYTES REMAINING
	MOVZBL	#128,R2			;ASSUME FULL SECTOR TO TRANSFER
	MOVB	R2,UCB$B_DX_SCTCNT(R5)	;RESET SECTOR COUNT
	MOVL	UCB$L_DX_BUF(R5),R1	;GET BUFFER ADDRESS
	MOVL	R1,UCB$L_DX_BFPNT(R5)	;SET ADDRESS
	CMPW	R2,R0			;SECTOR EXCEED BYTES LEFT
	BLSSU	10$			;IF LSSU NO
	MOVL	R0,R2			;SET COUNT TO SMALLER AMOUNT
10$:					;
	RSB				;

DXP_END::

	.END
