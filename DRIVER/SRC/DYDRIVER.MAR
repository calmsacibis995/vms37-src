	.TITLE	DYDRIVER - VAX/VMS RX211/RX02 DISK DRIVER
	.IDENT	'V03-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
; 
;++
; 
; FACILITY:
; 
; 	VAX/VMS RX211/RX02 DISK DRIVER
; 
; AUTHOR:
; 
; C. FRANKS	15-FEB-80
; 
; MODIFIED BY:
;
;	V02-017	ROW0064		Ralph O. Weber			26-JAN-1982
;		Correct bug in the interrupt service routine which was 
;		preventing SS$_RDDELDATA from being returned.  Also add pre-
;		execution check on validity of physical block number (and, 
;		by implication, of logical block number).  SS$_IVADDR will be 
;		returned when block numbers are found.
;
;	V02-016	JLV0168		Jake VanNoy			25-Jan-1982
;		Add DPTAB DEFUNITS.
;	
;	V02-015	ROW0059		Ralph O. Weber			10-DEC-1981
;		Cause IO$_PACKACK to set UCB$V_VALID in UCB$W_STS.  Add two 
;		new functions IO$_UNLOAD and IO$_AVAILABLE both of which clear 
;		UCB$V_VALID.  NB: none of the drives supported by this driver 
;		provide a hardware unload function; therefore, this driver 
;		need support unload only to the extent of clearing 
;		UCB$V_VALID.
;
;	V02-014	RLRINIT		Robert L. Rappaport		30-Nov-1981
;		Added internal routine RX211_REINIT, which issues an RX211
;		initialize, but does not hang the system at high IPL while
;		doing it.  Also redirected all internal calls to DY_RX211_INIT
;		to call this subroutine.  Also added call to it from RETRYERR,
;		when only one retry remains.
;
;	V02-013	RLR0005		Robert L. Rappaport		5-Oct-1981
;		Added instruction in DY_RX02_INIT to initialize the
;		UCB$B_DEVTYPE field with the value DT$_RX02.
;	V02-012	RLR39644	Robert L. Rappaport		30-July-1981
;		Added call to DY_RX211_INIT (internal subroutine) in
;		TIMEOUT recovery code so as to try to initialize the RX02.
;
;	V02-009 RLR36239	Robert L. Rappaport		17-Mar-1981
;		Correct problem in PACKACK that left RX02 inoperable
;		until reboot of system.
;
;	V02-007	RLR33679	Robert L. Rappaport		3-NOV-1980
;		Give longer timeout for F_READSTATUS operation due
;		to failures noted with non-DIGITAL floppies.
;	V02-006	RLR0004		Robert L. Rappaport		27-Oct-1980
;		Change odd byte count error status from SS$_BUFBYTALI
;		to SS$_IVBUFLEN.
;	V02-005	ACG0179		Andrew C. Goldstein,	23-Jul-1980  18:35
;		Fix ACP class code in DPT
;
;	V02-004	RLR0003		Robert L. Rappaport		19-May-1980
;		Added RX04 (Single Sided Quad Density) support.
;
;	V02-003	RLR0002		Robert L. Rappaport		19-May-1980
;		Added READ ERROR REGISTER command logic for recording
;		error log data in case of hardware errors.
;
;	V02-002	RLR0001		Robert L. Rappaport		15-May-1980
;		Corrected two bugs affecting PHYSICAL I/O, one
;		bug where we failed to lower IPL to fork level after
;		a TIMEOUT while doing a READSTATUS and one bug
;		where we issued the WAIT_TR macro with the IPL on
;		the stack which causes problems if WAIT_TR takes
;		the error exit and branches to RETREG.  Of the PHYSICAL
;		I/O bugs one had to do with transfers upto and
;		including the last sector on the diskette and the other
;		bug had to do with keeping physical sector numbers
;		in the range 1-26 instead of 0-25.
;
	.PAGE
; 
; ABSTRACT:
; 
; 	THIS MODULE CONTAINS THE TABLES AND ROUTINES NECESSARY TO
; 	PERFORM ALL DEVICE-DEPENDENT PROCESSING OF AN I/O REQUEST
;	FOR RX211/RX02 AND RX411/RX04 DISK TYPES ON A VAX/VMS SYSTEM.
; 
; 	THE PYSICAL GEOMETRY OF THE DISKETTES ARE:
; 
; 		TRACKS/	  SECTORS/    BYTES/	MAXIMUM	    DISKETTE
; 	#CYL	CYLINDER  TRACK	      SECTOR	BLOCKS	    TYPE
; 
; 	 77	   1	    26	       128	 494	    RX02 (SINGLE DEN)
; 	 77	   1	    26	       256	 988	    RX02 (DOUBLE DEN)
; 	 77	   1	    26	       512	 1976	    RX04 (QUAD DEN)
; 	 77	   2	    26	       256	 1989	      *
; 
;	SINCE THE SECTOR SIZE IS NOT NECESSARILY ONE BLOCK, AND SINCE
;	SECTORS ARE INTERLEAVED FOR EFFICIENCY, LOGICAL TO PHYSICAL
; 	CONVERSION OF THE DISK ADDRESS IS PERFORMED IN THIS DRIVER'S
; 	STARTIO ROUTINE RATHER THAN THE IOC$CVTLOGPHY FDT ROUTINE.
; 
; 	IF VIRTUAL OR LOGICAL I/O IS BEING PERFORMED, SECTOR NUMBERS
; 	ARE INTERLEAVED TO OPTIMIZE DATA TRANSFER, AND A SKEW OF SIX
; 	SECTORS IS ADDED FOR EACH CYLINDER TO ALLOW FOR SWITCHING TIME.
; 	ALSO, THE FIRST TRACK IS SKIPPED FOR INDUSTRY COMPATIBILITY.
; 
; 	SINGLE SIDED DISKETTES CAN BE RECORDED WITH SINGLE (RX01 COMPATIBLE)
;	OR DOUBLE DENSITY DATA.  DISKETTE DENSITY IS CHANGED VIA THE
; 	IO$_FORMAT FUNCTION.  EXISTING DISKETTE DENSITY CAN BE DETERMINED BY
;	EXAMINING UCB$L_MAXBLOCK VIA THE $GETCHN OR $GETDEV SYSTEM SERVICES.
; 
; 	THE IO$_WRITEPBLK FUNCTION CAN BE ISSUED WITH A "DELETED DATA"
; 	MODIFIER WHICH WILL CAUSE A DELETED DATA ADDRESS MARK TO BE
; 	WRITTEN PRIOR TO WRITING THE DATA IN EACH SECTOR.  SUBSEQUENT
; 	READING OF DATA FROM A SECTOR WITH A DELETED DATA ADDRESS MARK
; 	WILL CAUSE THE DATA TO BE RETURNED WITH THE STATUS CODE 
; 	SS$_RDDELDATA IF SUCCESSFUL.
; 
; 	IO$_PACKACK MUST BE THE FIRST FUNCTION ISSUED TO A DISKETTE
; 	AFTER IT HAS BEEN PLACED IN A DRIVE (TO UPDATE THE UCB
; 	WITH THE DISKETTE'S DENSITY AND # SIDES).
; 
; 	THE RX211 DOES NOT PERFORM EXPLICIT SEEKS, SO OVERLAPPED SEEKS
; 	ARE NOT SUPPORTED BY THIS DRIVER.
; 
; 	THIS DRIVER WILL ONLY SUPPORT RX211 CONTROLLERS WHOSE HARDWARE
; 	SWITCH IS IN THE RX02 (NOT RX01) POSITION.
; 
; 	* NOTE:	CODE HAS BEEN INCLUDED FOR A FUTURE DOUBLE SIDED, DOUBLE
; 	DENSITY FLOPPY.  IF THIS PRODUCT BECOMES A REALITY, COMPATIBILITY
; 	WITH OTHER DEC OPERATING SYSTEMS SHOULD BE CHECKED WITH REGARD TO
; 	THE FOLLOWING ASSUMPTIONS MADE BY THIS DRIVER:
; 	    (1) THE SIX SECTOR SKEW IS APPLIED ONLY WHEN SWITCHING
; 		CYLINDERS, NOT WHEN SWITCHING SURFACES.
; 	    (2) AS WITH OTHER DISKS, ADDRESSES ARE SPIRALLED.  THAT IS, UPON
; 		REACHING THE END OF TRACK, THE NEXT SURFACE IS ADDRESSED.  ONLY
; 		WHEN NO MORE SURFACES REMAIN IS THE NEXT CYLINDER ADDRESSED.
;--
	.PAGE
	.SBTTL	EXTERNAL AND LOCAL DEFINITIONS

; 
; EXTERNAL SYMBOLS
; 

	$ADPDEF				;DEFINE ADAPTER CONTROL BLOCK
	$CRBDEF				;DEFINE CHANNEL REQUEST BLOCK
	$DCDEF				;DEFINE DEVICE CLASS
	$DDBDEF				;DEFINE DEVICE DATA BLOCK
	$DEVDEF				;DEFINE DEVICE CHARACTERISTICS
	$DPTDEF				;DEFINE DRIVER PROLOGUE TABLE
	$EMBDEF				;DEFINE ERROR MESSAGE BUFFER
	$IDBDEF				;DEFINE INTERRUPT DATA BLOCK
	$IODEF				;DEFINE I/O FUNCTION CODES
	$IRPDEF				;DEFINE I/O REQUEST PACKET
	$PRDEF				;DEFINE PROCESSOR REGISTERS
	$SSDEF				;DEFINE SYSTEM STATUS CODES
	$UCBDEF				;DEFINE UNIT CONTROL BLOCK
	$VECDEF				;DEFINE INTERRUPT VECTOR BLOCK

; 
; LOCAL MACROS
; 

;	
; 	DISABLE INTERRUPTS AND CHECK IF POWER HAS FAILED
; 

	.MACRO	CKPWR ?L1
	DSBINT				;DISABLE INTERRUPTS
	BBC	#UCB$V_POWER,-		;IF CLR - NO POWER FAILURE
		UCB$W_STS(R5),L1	;...
	ENBINT				;POWER FAILURE - ENABLE INTERRUPTS
	BRW	PWRFAIL			;EXIT
L1:					;RETURN FOR NO POWER FAILURE
	.ENDM


; 
; 	CHECK IF DEVICE IS OFFLINE
; 

	.MACRO	CKOFL ?L2,?L3
	BSBW	DY_MERGE		;MERGE UNIT,DEN,IE,GO,HS,XBA BITS IN R2
	CKPWR				;CHECK FOR PWR FAILURE & DSBINT
	BISW3	R2,#F_READSTATUS,RY_CS(R4)  ;EXECUTE READ STATUS FUNCTION
	WFIKPCH	L2,#10			; Wait for interrupt.
	IOFORK				;CREATE FORK PROCESS
L2:
	SETIPL	UCB$B_FIPL(R5)		; Lower IPL in case due to TIMEOUT.
	BICW	#UCB$M_TIMOUT,UCB$W_STS(R5)  ;CLEAR DEVICE TIMOUT
	BITW	#RY_DB_M_DRDY,UCB$W_DY_DB(R5)  ;IS DRIVE READY?
	BNEQ	L3			;IF NEQ - YES, ONLINE
	MOVZWL	#SS$_MEDOFL,R0		;SET MEDIUM OFFLINE STATUS
	BRW	FUNCXT			;AND EXIT
L3:					;RETURN FOR DEVICE ONLINE
	.ENDM

; 
; 	WAIT FOR CONTROLLER T/R BIT
; 

	.MACRO	WAIT_TR	ERROR_EXIT,?L4,?L5,?L6
	PUSHL	R2			;SAVE R2
	MFPR	#PR$_TODR,R2		;GET CURRENT TIME OF DAY
	ADDL	#100,R2			;ADD ONE SECOND FOR WAIT TIMEOUT
L4:	BITB	#RY_CS_M_TR!RY_CS_M_DONE,-  ;T/R OR DONE?
		RY_CS(R4)		;...
	BLSS	L5			;IF LSS - TRANSFER COMPLETE (T/R)
	BEQL	L6			;IF EQL - NEITHER, WAIT
	POPL	R2			;RESTORE R2
	.IF	BLANK	ERROR_EXIT
		BRW	RETREG		; Done bit set - ERROR
	.IFF
		BRB	ERROR_EXIT	; Done bit set - ERROR
	.ENDC
L6:	MFPR	#PR$_TODR,-(SP)		;GET CURRENT TIME OF DAY
	CMPL	R2,(SP)+		;HAS TIME EXPIRED?
	BGEQ	L4			;IF GEQ - NO, CONTINUE WAITING
L5:	POPL	R2			;RESTORE R2
					;NORMAL RETURN
	.ENDM

		
; 
; LOCAL SYMBOLS
; 

RY_NUM_REGS	=2			;NUMBER OF DEVICE REGISTERS
RY_SSSD		=494			;S SIDED,S DENSITY MAXBLOCKS (26*76/4)
RY_SSDD		=988			;S SIDED,D DENSITY MAXBLOCKS (26*76/2)
RY_DSDD		=1989			;D SIDE,D DEN MXBLK (26*76/2)+(26*77/2)
RY_SWPS		=64			;SINGLE DENSITY WORDS/SECTOR
RY_SECTORS	=26			;NUMBER OF SECTORS PER TRACK
RY_CYLINDERS	=77			;NUMBER OF CYLINDERS
RY_RX01SW	=2			;UCB$B_DY_ER BIT FOR RX01 SW ERROR
RY_DPPE		=1			;UCB$B_DY_ER BIT FOR PURGE ERROR

; Symbols added for RX04 support.

RY_SSQD		=1976			;S sided,q density maxblocks (26*76)
RY_DWPS		=128			;Double density Words/sector.
RY_QWPS		=256			;Quad density WORDS/SECTOR.
RY_DENSITY_SINGLE=0			;Value to insert in RY_CS register.
RY_DENSITY_DOUBLE=1			;       "  "
RY_DENSITY_QUAD	=2			;       "  "

; 
; UCB OFFSETS WHICH FOLLOW THE STANDARD UCB FIELDS
; 
	$DEFINI	UCB			;START OF UCB DEFINITIONS

.=UCB$W_BCR+2				;BEGIN DEFINITIONS AT END OF UCB
$DEF	UCB$W_DY_WPS	.BLKW	1	;Words per sector.
$DEF	UCB$W_DY_CS	.BLKW	1	;CONTROL STATUS REGISTER
$DEF	UCB$W_DY_DB	.BLKW	1	;DATA BUFFER REGISTER
$DEF	UCB$W_DY_DPN	.BLKW	1	;DATA PATH NUMBER
$DEF	UCB$L_DY_DPR	.BLKL	1	;DATAPATH REGISTER
$DEF	UCB$L_DY_FMPR	.BLKL	1	;FINAL MAP REGISTER
$DEF	UCB$L_DY_PMPR	.BLKL	1	;PREVIOUS MAP REGISTER
$DEF	UCB$B_DY_ER	.BLKB	1	;SPECIAL ERROR REGISTER
			.BLKB	1	;Reserved.
$DEF	UCB$B_DY_LCT	.BLKB	1	;LOOP COUNTER
$DEF	UCB$B_DY_XBA	.BLKB	1	;BUS ADDRESS EXTENSION BITS
$DEF	UCB$W_DY_PWC	.BLKW	1	;PARTIAL WORD COUNT
$DEF	UCB$W_DY_SBA	.BLKW	1	;SAVED BUFFER ADDRESS
$DEF	UCB$L_DY_XFER	.BLKL	1	;TRANSFER FUNCTION CSR BITS
$DEF	UCB$L_DY_LMEDIA	.BLKL	1	;LOGICAL MEDIA ADDRESS
$DEF	UCB$Q_DY_EXTENDED_STATUS	; Area into which we do READ ERROR
			.BLKQ	1	;  REGISTER command.

	RY_EXTENDED_STATUS_LENGTH = .-UCB$Q_DY_EXTENDED_STATUS

$DEF	UCB$Q_DY_SVAPTETMP		; Area in which we save UCB fields -
			.BLKQ	1	;  SVAPTE, BOFF, and BCNT.
$DEF	UCB$L_DY_MAPREGTMP		; Area in which we save CRB fields -
			.BLKL	1	;  MAPREG, NUMREG, and DATAPATH.
$DEF	UCB$L_DY_SAVECS	.BLKL	1	; Area in which we save CS and DB regs.

UCB$K_DY_LEN=.				;LENGTH OF UCB

	$DEFEND	UCB			;END OF UCB DEFINITONS
 
; 
; RX211/RX02 REGISTER OFFSETS FROM CSR ADDRESS
; 
	$DEFINI	RY			; START OF REGISTER DEFINITIONS

$DEF	RY_CS		.BLKW	1	;CONTROL STATUS REGISTER (CSR)
	_VIELD	RY_CS,0,<-		;START OF CSR BIT DEFINITIONS
		<GO,,M>,-		; GO
		<FCODE,3>,-		; FUNCTION CODE
		<US,,M>,-		; UNIT SELECT
		<DONE,,M>,-		; DONE - FUNCTION COMPLETE
		<IE,,M>,-		; INTERRUPT ENABLE
		<TR,,M>,-		; TRANSFER REQUEST
		<DEN,2>,-		; Density
		<,1>,-			; RESERVED BIT
		<RX02,,M>,-		; DEVICE TYPE
		<XBA,2>,-		; BUS ADDRESS EXTENSION BITS
		<INIT,,M>,-		; INITIALIZE
		<ERR,,M>-		; ERROR
	>				;END CSR BIT DEFINITIONS

$DEF	RY_DB		.BLKW	1	;DATA BUFFER REGISTER (DBR)
	_VIELD	RY_DB,0,<-		;START OF DBR BIT DEFINITIONS
		<CRC,,M>,-		; CRC ERROR
		<QDEN,,M>,-		; Quad density
		<ID,,M>,-		; INITIALIZE DONE
		<ACLO,,M>,-		; AC PWR FAILURE
		<DE,,M>,-		; DENSITY ERROR
		<DDEN,,M>,-		; DRIVE DENSITY
		<DELD,,M>,-		; DELETED DATA
		<DRDY,,M>,-		; DRIVE READY
		<US,,M>,-		; UNIT SELECT
		<RX04,,M>,-		; RX04 bit
		<WCO,,M>,-		; WORD COUNT OVERFLOW
		<NXM,,M>,-		; NON-EXISTENT MEMORY
		<,4>-			; RESERVED BITS
	>				;END DBR BIT DEFINITIONS

	$DEFEND	RY			;END RX211/RX02,RX03 REGISTER DEFINITIONS

; 
; HARDWARE FUNCTION CODES
; 

F_FILLBUFFER	=0*2			;FILL BUFFER
F_EMPTYBUFFER	=1*2			;EMPTY BUFFER
F_WRITESECTOR	=2*2			;WRITE SECTOR
F_READSECTOR	=3*2			;READ SECTOR
F_SETDEN	=4*2			;SET DENSITY
F_READSTATUS	=5*2			;READ STATUS
F_WRITEDEL	=6*2			;WRITE DELETED DATA
F_READERROR	=7*2			;Read Error Register.
	.PAGE
	.SBTTL	STANDARD TABLES

; 
; DRIVER PROLOGUE TABLE
; 
; 	THE DPT DESCRIBES DRIVER PARAMETERS AND I/O DATABASE FIELDS
; 	THAT ARE TO BE INITIALIZED DURING DRIVER LOADING AND RELOADING
; 

	DPTAB	-			;DPT CREATION MACRO
		END=DY_END,-		;END OF DRIVER LABEL
		ADAPTER=UBA,-		;ADAPTER TYPE = UNIBUS
		FLAGS=DPT$M_SVP,-	;SYSTEM PAGE TABLE ENTRY REQUIRED
		DEFUNITS=2,-		;UNITS 0 AND 1
		UCBSIZE=UCB$K_DY_LEN,-	;LENGTH OF UCB
		NAME=DYDRIVER		;DRIVER NAME

	DPT_STORE INIT			;START CONTROL BLOCK INIT VALUES
	DPT_STORE DDB,DDB$L_ACPD,L,<^A\F11\>  ;DEFAULT ACP NAME
	DPT_STORE DDB,DDB$L_ACPD+3,B,DDB$K_SLOW	;ACP CLASS
	DPT_STORE UCB,UCB$B_FIPL,B,8	;FORK IPL
	DPT_STORE UCB,UCB$L_DEVCHAR,L,-	;DEVICE CHARACTERISTICS
		<DEV$M_FOD-		; FILES ORIENTED
		!DEV$M_DIR-		; DIRECTORY STRUCTURED
		!DEV$M_AVL-		; AVAILABLE
		!DEV$M_ELG-		; ERROR LOGGING
		!DEV$M_SHR-		; SHAREABLE
		!DEV$M_IDV-		; INPUT DEVICE
		!DEV$M_ODV-		; OUTPUT DEVICE
		!DEV$M_RND>		; RANDOM ACCESS
	DPT_STORE UCB,UCB$B_DEVCLASS,B,DC$_DISK  ;DEVICE CLASS
	DPT_STORE UCB,UCB$W_DEVBUFSIZ,W,512  ;DEFAULT BUFFER SIZE
	DPT_STORE UCB,UCB$B_SECTORS,B,26  ;NUMBER OF SECTORS PER TRACK
	DPT_STORE UCB,UCB$W_CYLINDERS,W,77  ;NUMBER OF TRACKS PER CYLINDER
	DPT_STORE UCB,UCB$B_DIPL,B,21	;DEVICE IPL
	DPT_STORE UCB,UCB$B_ERTMAX,B,10	;MAX ERROR RETRY COUNT
	DPT_STORE UCB,UCB$W_DEVSTS,W,-	;INHIBIT LOG TO PHYS CONVERSION IN FDT
		<UCB$M_NOCNVRT>		;...

	DPT_STORE REINIT		;START CONTROL BLOCK RE-INIT VALUES
	DPT_STORE CRB,CRB$L_INTD+4,D,DY_INT  ;INTERRUPT SERVICE ROUTINE ADDRESS
	DPT_STORE CRB,CRB$L_INTD+VEC$L_INITIAL,-  ;CONTROLLER INIT ADDRESS
		      D,DY_RX211_INIT		  ;...
	DPT_STORE CRB,CRB$L_INTD+VEC$L_UNITINIT,- ;UNIT INIT ADDRESS
		      D,DY_RX02_INIT		  ;...
	DPT_STORE DDB,DDB$L_DDT,D,DY$DDT	  ;DDT ADDRESS

	DPT_STORE END			;END OF INITIALIZATION TABLE

; 
; DRIVER DISPATCH TABLE
; 
; 	THE DDT LISTS ENTRY POINTS FOR DRIVER SUBROUTINES WHICH ARE
; 	CALLED BY THE OPERATING SYSTEM.
; 

	DDTAB	-			;DDT CREATION MACRO
		DEVNAM=DY,-		;NAME OF DEVICE
		START=DY_STARTIO,-	;START I/O ROUTINE
		UNSOLIC=DY_UNSOLNT,-	;UNSOLICITED INTERRUPT
		FUNCTB=DY_FUNCTABLE,-	;FUNCTION DECISION TABLE
		CANCEL=0,-		;CANCEL=NO-OP FOR FILES DEVICE
		REGDMP=DY_REGDUMP,-	;REGISTER DUMP ROUTINE
		DIAGBF=<<RY_NUM_REGS+7+5+3+1>*4>,-  ;BYTES IN DIAG BUFFER
		ERLGBF=<<<RY_NUM_REGS+7+1>*4>+<EMB$L_DV_REGSAV>>;BYTES IN
								;ERRLOG BUFFER
; DIAGNOSTIC BUFFER SIZE = <<2 RX02 REGISTER LONGWORDS + 7 UCB FIELD LONGWORDS
; 			   + 5 IOC$DIAGBUFILL LONGWORDS + 3 BUFFER ALLOCATION
; 			   LONGWORDS + 1 LONGWORD FOR # REGISTERS IN DY_REGDUMP>
; 			   * 4 BYTES/LONGWORD>
; 
; ERROR LOG BUFFER SIZE	 = <<<2 RX02 REGISTER LONGWORDS + 7 UCB FIELD LONGWORDS
; 			   +1 LONGWORD FOR # REGISTERS IN DY_REGDUMP>
; 			   * 4 BYTES/LONGWORD> + BYTES NEEDED FOR ERROR LOGGER
; 			   TO SAVE SOFTWARE REGISTERS>
	.PAGE
; 
; FUNCTION DECISION TABLE
; 
; 	THE FDT LISTS VALID FUNCTION CODES, SPECIFIES WHICH
; 	CODES ARE BUFFERED, AND DESIGNATES SUBROUTINES TO
; 	PERFORM PREPROCESSING FOR PARTICULAR FUNCTIONS.
; 

DY_FUNCTABLE:
	FUNCTAB	,-			;LIST LEGAL FUNCTIONS
		<FORMAT,-		; SET MEDIA DENSITY AND REFORMAT DISK
		UNLOAD,-		; UNLOAD
		PACKACK,-		; PACK ACKNOWLEDGE
		AVAILABLE,-		; AVAILABLE
		SENSECHAR,-		; SENSE CHARACTERISTICS
		SETCHAR,-		; SET CHARACTERISTICS
		SENSEMODE,-		; SENSE MODE
		SETMODE,-		; SET MODE
		READLBLK,-		; READ LOGICAL BLOCK
		WRITELBLK,-		; WRITE LOGICAL BLOCK
		READPBLK,-		; READ PHYSICAL BLOCK
		WRITEPBLK,-		; WRITE PHYSICAL BLOCK
		READVBLK,-		; READ VIRTUAL BLOCK
		WRITEVBLK,-		; WRITE VIRTUAL BLOCK
		ACCESS,-		; ACCESS FILE / FIND DIRECTORY ENTRY
		ACPCONTROL,-		; ACP CONTROL FUNCTION
		CREATE,-		; CREATE FILE AND/OR DIRECTORY ENTRY
		DEACCESS,-		; DEACCESS FILE
		DELETE,-		; DELETE FILE AND/OR DIRECTORY ENTRY
		MODIFY,-		; MODIFY FILE ATTRIBUTES
		MOUNT-			; MOUNT VOLUME
		>
	FUNCTAB	,-			;BUFFERED FUNCTIONS
		<FORMAT,-		; FORMAT
		UNLOAD,-		; UNLOAD
		PACKACK,-		; PACK ACKNOWLEDGE
		AVAILABLE,-		; AVAILABLE
		SENSECHAR,-		; SENSE CHARACTERISTICS
		SETCHAR,-		; SET CHARACTERISTICS
		SENSEMODE,-		; SENSE MODE
		SETMODE,-		; SET MODE
		ACCESS,-		; ACCESS FILE / FIND DIRECTORY ENTRY
		ACPCONTROL,-		; ACP CONTROL FUNCTION
		CREATE,-		; CREATE FILE AND/OR DIRECTORY ENTRY
		DEACCESS,-		; DEACCESS FILE
		DELETE,-		; DELETE FILE AND/OR DIRECTORY ENTRY
		MODIFY,-		; MODIFY FILE ATTRIBUTES
		MOUNT-			; MOUNT VOLUME
		>
	FUNCTAB	DY_ALIGN,-		;TEST ALIGNMENT FUNCTIONS
		<READLBLK,-		; READ LOGICAL BLOCK
		READPBLK,-		; READ PHYSICAL BLOCK
		READVBLK,-		; READ VIRTUAL BLOCK
		WRITELBLK,-		; WRITE LOGICAL BLOCK
		WRITEPBLK,-		; WRITE PHYSICAL BLOCK
		WRITEVBLK-		; WRITE VIRTUAL BLOCK
		>
	FUNCTAB	+ACP$READBLK,-		;READ FUNCTIONS
		<READLBLK,-		; READ LOGICAL BLOCK
		READPBLK,-		; READ PHYSICAL BLOCK
		READVBLK-		; READ VIRTUAL BLOCK
		>
	FUNCTAB	+ACP$WRITEBLK,-		;WRITE FUNCTIONS
		<WRITELBLK,-		; WRITE LOGICAL BLOCK
		WRITEPBLK,-		; WRITE PHYSICAL BLOCK
		WRITEVBLK-		; WRITE VIRTUAL BLOCK
		>
	FUNCTAB	+ACP$ACCESS,-		;ACCESS FUNCTIONS
		<ACCESS,-		; ACCEESS FILE / FIND DIRECTORY ENTRY
		CREATE-			; CREATE FILE AND/OR DIRECTORY ENTRY
		>
	FUNCTAB	+ACP$DEACCESS,-		;DEACCESS FUNCTION
		<DEACCESS-		; DEACCESS FILE
		>
	FUNCTAB	+ACP$MODIFY,-		;MODIFY FUNCTIONS
		<ACPCONTROL,-		; ACP CONTROL FUNCTION
		DELETE,-		; DELETE FILE AND/OR DIRECTORY ENTRY
		MODIFY-			; MODIFY FILE ATTRIBUTES
		>
	FUNCTAB	+ACP$MOUNT,-		;MOUNT FUNCTION
		<MOUNT-			; MOUNT VOLUME
		>
	FUNCTAB	+EXE$ZEROPARM,-		;ZERO PARAMETER FUNCTIONS
		<UNLOAD,-		; UNLOAD
		PACKACK,-		; PACK ACKNOWLEDGE
		AVAILABLE,-		; AVAILABLE
		>
	FUNCTAB	+EXE$ONEPARM,-		;ONE PARAMETER FUNCTION
		<FORMAT-		; FORMAT
		>
	FUNCTAB	+EXE$SENSEMODE,-	;SENSE FUNCTIONS
		<SENSECHAR,-		; SENSE CHARACTERISTICS
		SENSEMODE-		; SENSE MODE
		>
	FUNCTAB	+EXE$SETCHAR,-		;SET FUNCTIONS
		<SETCHAR,-		; SET CHARACTERISTICS
		SETMODE-		; SET MODE
		>
	.PAGE
	.SBTTL	CONTROLLER INITIALIZATION ROUTINE

; ++
; 
; DY_RX211_INIT - CONTROLLER INITIALIZATION ROUTINE
; 
; FUNCTIONAL DESCRIPTION:
; 
; 	THIS ROUTINE INITIALIZES THE RX211 CONTROLLER FOR I/O OPERATIONS.
; 	IF THE INITIALIZATION IS NOT COMPLETE WITHIN ONE SECOND, CONTROL
; 	IS RETURNED TO THE CALLER.
; 
; 	THE OPERATING SYSTEM CALLS THIS ROUTINE:
; 		- AT SYSTEM STARTUP
; 		- DURING DRIVER LOADING
; 		- DURING RECOVERY FROM POWER FAILURE
; 	THE DRIVER CALLS THIS ROUTINE TO INIT AFTER AN NXM ERROR.
; 
; INPUTS:
; 
; 	R4	- CSR ADDRESS (CONTROLLER STATUS REGISTER)
; 	R5	- IDB ADDRESS (INTERRUPT DATA BLOCK)
; 
; OUTPUTS:
; 
; 	THE HEADS FOR ALL DRIVES CONNECTED TO THIS CONTROLLER ARE LOCATED AT
; 	TRACK ZERO, AND THE ERROR AND STATUS REGISTER IS CLEARED.
; 	ALL GENERAL REGISTERS (R0 - R15) ARE PRESERVED.
; 	
;--

DY_RX211_INIT:				;RX211 CONTROLLER INITIALIZATION
	PUSHL	R2			;SAVE R2
	MFPR	#PR$_TODR,R2		;GET CURRENT TIME OF DAY
	ADDL	#100,R2			;ADD ONE SECOND FOR WAIT TIMEOUT
	MOVW	#RY_CS_M_INIT,RY_CS(R4)	;EXECUTE RX211 INITIALIZE
10$:	BITW	#RY_CS_M_DONE,RY_CS(R4)	;DONE ?
	BNEQ	20$			;IF NEQ - YES
	MFPR	#PR$_TODR,-(SP)		;GET CURRENT TIME OF DAY
	CMPL	R2,(SP)+		;HAS TIME EXPIRED ?
	BGTRU	10$			;IF GTRU - NO, CONTINUE WAITING
20$:	POPL	R2			;RESTORE R2
	RSB				;RETURN
	.PAGE
	.SBTTL	INTERNAL CONTROLLER RE-INITIALIZATION

;++
;
; RX211_REINIT - Internal subroutine used to issue an RX211 initialize function
;	without hanging on at elevated IPL waiting for it to finish.
;	Because the RX211 initialize does not interrupt when complete,
;	we rely upon a device timeout to resume the driver thread after
;	invoking the initialize.
;
; INPUTS:
;	R4 => RX211 CSR
;	R5 => UCB
;

RX211_REINIT:
	POPL	R3			; Save return point.
	DSBINT
	MOVW	#RY_CS_M_INIT,RY_CS(R4)	; Execute RX211 initialize.
	WFIKPCH	10$,#2			; Wait for interrupt that doesn't come.
	IOFORK				; We should never come here.
10$:
	SETIPL	UCB$B_FIPL(R5)		; Lower to fork level.
	BICW	#UCB$M_TIMOUT,-		; Clear timeout status.
		UCB$W_STS(R5)
	JMP	(R3)			; Return to caller.
	.PAGE
	.SBTTL	UNIT INITIALIZATION ROUTINE

;++
; 
; DY_RX02_INIT - UNIT INITIALIZATION ROUTINE
; 
; FUNCTIONAL DESCRIPTION:
; 
; 	THIS ROUTINE SETS THE RX02 UNIT ONLINE.
; 
; 	NO ATTEMPT IS MADE TO READ THE DENSITY, OR # SIDES OF THE UNIT IN
; 	THIS ROUTINE SINCE THE DRIVE MUST BE LOADED WITH A DISKETTE FOR
; 	THAT OPERATION TO BE VALID.  THESE CHARACTERISTICS CAN BE UPDATED IN
; 	THE UCB BY ISSUING AN IO$_PACKACK FUNCTION.
; 
; 	THE OPERATING SYSTEM CALLS THIS ROUTINE:
; 		- AT SYSTEM STARTUP
; 		- DURING DRIVER LOADING
; 		- DURING RECOVERY FROM POWER FAILURE
; 
; INPUTS:
; 
; 	R4	- CSR ADDRESS (CONTROLLER STATUS REGISTER)
; 	R5	- UCB ADDRESS (UNIT CONTROL BLOCK)
; 
; OUTPUTS:
; 
; 	THE UNIT IS SET ONLINE.
; 	ALL GENERAL REGISTERS (R0-R15) ARE PRESERVED.
; 
;--

DY_RX02_INIT:				;RX02 UNIT INITIALIZATION

	BISW	#UCB$M_ONLINE,UCB$W_STS(R5)  ;SET UCB STATUS ONLINE
	MOVB	#DC$_DISK,UCB$B_DEVCLASS(R5) ;SET DISK DEVICE CLASS
	MOVB	#DT$_RX02,UCB$B_DEVTYPE(R5)  ;ASSUME RX02 DEVICE TYPE
	RSB				;RETURN 
	.PAGE
	.SBTTL	DRIVER SPECIFIC SUBROUTINES
; 
; DY_MERGE - MERGE CSR BITS
; 
; FUNCTIONAL DESCRIPTION:
; 
; 	THIS ROUTINE IS CALLED FROM THE STARTIO HARDWARE FUNCTION
; 	EXECUTION ROUTINES TO MERGE THE GO, UNITSELECT, INTERRUPT ENABLE,
; 	AND DENSITY BITS IN R2 PRIOR TO INITIATING THE INTENDED I/O FUNCTION.
; 
; INPUTS:
; 
; 	R5	- UCB ADDRESS
; 
; OUTPUTS:
; 
; 	R2 CONTAINS THE CSR BITS FOR: GO, UNIT, IE, AND DENSITY. 
; 	ALL REGISTERS EXCEPT R0 AND R2 ARE PRESERVED.
; 

DY_MERGE:				;MERGE CSR BITS IN R2
	MOVW	#RY_CS_M_GO!RY_CS_M_IE,R2  ;SET GO AND IE BITS IN R2
	INSV	UCB$W_UNIT(R5),#4,#1,R2	;MERGE UNIT NUMBER IN R2<4>
	ASSUME	RY_DENSITY_SINGLE  EQ  0
	CMPW	#RY_SSSD,UCB$L_MAXBLOCK(R5)  ;SINGLE DENSITY?
	BEQL	10$			;IF EQL - YES
	INSV	#RY_DENSITY_QUAD,-	; Setup as if we have QUAD density
		#RY_CS_V_DEN,-
		#RY_CS_S_DEN,R2
	CMPW	#RY_SSQD,-
		UCB$L_MAXBLOCK(R5)	; See if indeed QUAD density.
	BEQL	10$			; If QUAD, then we are all set.
	INSV	#RY_DENSITY_DOUBLE,-	; Else must be DOUBLE density so
		#RY_CS_V_DEN,-		;  setup CSR register value accordingly.
		#RY_CS_S_DEN,R2
10$:	RSB				;RETURN
	.PAGE
	.SBTTL	FDT ROUTINES 
;++
; 
; DY_ALIGN - FDT ROUTINE TO TEST XFER BYTE COUNT
; 
; FUNCTIONAL DESCRIPTION:
; 
; 	THIS ROUTINE IS CALLED FROM THE FUNCTION DECISION TABLE DISPATCHER
; 	TO CHECK THE BYTE COUNT PARAMETER SPECIFIED BY THE USER PROCESS
; 	FOR AN EVEN NUMBER OF BYTES (WORD BOUNDARY).
; 
; INPUTS:
; 
; 	R3	- IRP ADDRESS (I/O REQUEST PACKET)
; 	R4	- PCB ADDRESS (PROCESS CONTROL BLOCK)
; 	R5	- UCB ADDRESS (UNIT CONTROL BLOCK)
; 	R6	- CCB ADDRESS (CHANNEL CONTROL BLOCK)
; 	R7	- BIT NUMBER OF THE I/O FUNCTION CODE
; 	R8	- ADDRESS OF FDT TABLE ENTRY FOR THIS ROUTINE
; 	4(AP)	- ADDRESS OF FIRST FUNCTION DEPENDENT QIO PARAMETER
; 
; OUTPUTS:
; 
; 	IF THE QIO BYTE COUNT PARAMETER IS ODD, THE I/O OPERATION IS
; 	TERMINATED WITH AN ERROR. IF IT IS EVEN, CONTROL IS RETURNED
; 	TO THE FDT DISPATCHER.
; 
;--

DY_ALIGN:				;CHECK BYTE COUNT AT P1(AP)
	BLBS	4(AP),10$		;IF LBS - ODD BYTE COUNT
	RSB				;EVEN - RETURN TO CALLER
10$:	MOVZWL	#SS$_IVBUFLEN,R0	;SET BUFFER ALIGNMENT STATUS
	JMP	G^EXE$ABORTIO		;ABORT I/O
	.PAGE
	.SBTTL	START I/O ROUTINE

;++
; 
; DY_STARTIO - START I/O ROUTINE
; 
; FUNCTIONAL DESCRIPTION:
; 
; 	THIS FORK PROCESS IS ENTERED FROM THE EXECUTIVE AFTER AN I/O REQUEST
; 	PACKET HAS BEEN DEQUEUED, AND PERFORMS THE FOLLOWING:
; 
; 		- ACTIVATES THE DISK AFTER SETTING UCB FIELDS, OBTAINING
; 		  UBA AND CONTROLLER RESOURCES, AND SETTING RX211 REGISTERS
; 
; 		- WAITS FOR AN INTERRUPT
; 
; 		- REGAINS CONTROL AFTER THE ISR SERVICES THE INTERRUPT, AND
; 			-  RE-ACTIVATES THE DISK IF THE ORIGINAL FUNCTION
; 			   IS NOT YET COMPLETE, OR
; 			-  COMPLETES THE I/O REQUEST BY RELEASING RESOURCES,
;			   SETTING STATUS CODES, AND RETURNING TO THE EXECUTIVE.
; 
; INPUTS:
; 
; 	R3		- IRP ADDRESS (I/O REQUEST PACKET)
; 	R5		- UCB ADDRESS (UNIT CONTROL BLOCK)
; 	IRP$L_MEDIA	- PARAMETER LONGWORD (LOGICAL BLOCK NUMBER)
; 
; OUTPUTS:
; 
; 	R0	- FIRST I/O STATUS LONGWORD: STATUS CODE & BYTES XFERED
; 	R1	- SECOND I/O STATUS LONGWORD: 0 FOR DISKS
; 
; 	THE I/O FUNCTION IS EXECUTED.
; 
; 	ALL REGISTERS EXCEPT R0-R4 ARE PRESERVED.
; 
;--

DY_STARTIO:				;START I/O OPERATION

; 
; 	PREPROCESS UCB FIELDS
; 

	ASSUME	RY_EXTENDED_STATUS_LENGTH  EQ  8
	CLRQ	UCB$Q_DY_EXTENDED_STATUS(R5)	; Zero READ ERROR REGISTER area.

	MOVB	UCB$B_ERTMAX(R5),-	;INITIALIZE ERROR RETRY COUNT
		UCB$B_ERTCNT(R5)	;...
	MNEGW	UCB$W_BCNT(R5),UCB$W_BCR(R5)  ;INIT NEG BYTES LEFT TO XFER
	CLRW	UCB$W_DY_DPN(R5)	;CLEAR DATA PATH NO. FOR USE AS-
					;UBA RESOURCE ALLOCATION FLAG
	CLRB	UCB$B_DY_ER(R5)		;CLEAR SPECIAL ERROR REGISTER
	MOVW	IRP$W_FUNC(R3),UCB$W_FUNC(R5)  ;SAVE FUNCTION CODE
	EXTZV	#IRP$V_FCODE,-		;EXTRACT I/O FUNCTION CODE
		#IRP$S_FCODE,IRP$W_FUNC(R3),R1  ;...
	MOVB	R1,UCB$B_FEX(R5)	;STORE FUNCTION DISPATCH INDEX
	BICW	#UCB$M_DIAGBUF,UCB$W_DEVSTS(R5)  ;CLR DIAGNOSTIC BUFFER PRESENT
	BBC	#IRP$V_DIAGBUF,-	;IF CLR - NO DIAG BUFFER
		IRP$W_STS(R3),10$	;...
	BISW	#UCB$M_DIAGBUF,UCB$W_DEVSTS(R5)  ;SET DIAG BUFFER PRESENT

; 
; 	BRANCH TO FUNCTION EXECUTION
; 

10$:	BBS	#IRP$V_PHYSIO,-		;IF SET - PHYSICAL I/O FUNCTION
		IRP$W_STS(R3),20$	;...
	BBS	#UCB$V_VALID,-		;IF SET - VOLUME SOFTWARE VALID
		UCB$W_STS(R5),20$	;...
	MOVZWL	#SS$_VOLINV,R0		;SET VOLUME INVALID STATUS
	BRW	RESETXFR		;RESET BYTE COUNT AND EXIT
20$:	CMPB	#IO$_UNLOAD, R1		;Unload function?
	BEQL	UNLOAD			;Branch if yes.
	CMPB	#IO$_AVAILABLE, R1	;Available function?
	BEQL	AVAILABLE		;Branch if yes.
	BRW	FEXL			;Else, branch to execute function.

;
;	UNLOAD and AVAILABLE Functions
;	Clear UCB$V_VALID in UCB$W_STS
;
UNLOAD:
AVAILABLE:
	BICW	#UCB$M_VALID, -		;Clear sofware volume valid bit.
		UCB$W_STS(R5)
;	BRB	NORMAL			;Then complete the operation.


; 
; 	OPERATON COMPLETION
; 

NORMAL:					;SUCCESSFUL OPERATION COMPLETE
	MOVZWL	#SS$_NORMAL,R0		;ASSUME NORMAL COMPLETION STATUS
	CMPB	#IO$_READPBLK,UCB$B_FEX(R5)  ;READ FUNCTION?
	BNEQ	FUNCXT			;IF NEQ - NO
	BBC	#RY_DB_V_DELD,-		;IF CLR - NO DELETED DATA MARK
		UCB$W_DY_DB(R5),FUNCXT	;...
	MOVZWL	#SS$_RDDELDATA,R0	;SET READ DELETED DATA STATUS
	BRB	FUNCXT			;FUNCTION EXIT

RETRYERR:				;RETRIABLE ERROR
	DECB	UCB$B_ERTCNT(R5)	;ANY RETRIES LEFT?
	BEQL	FATALERR		;IF EQL - NO
	CMPB	#1,UCB$B_ERTCNT(R5)	; See if only one more retry left.
	BNEQ	10$			; If NOT, branch around.
	BSBW	RX211_REINIT		; If YES, re-INITIALIZE RX211.
10$:
	MOVL	UCB$L_IRP(R5),R3	; Refresh R3 => IRP.
	BRB	FEXL			;RETRY FUNCTION

FATALERR:				;UNRECOVERABLE ERROR
	MOVZWL	#SS$_PARITY,R0		;ASSUME PARITY ERROR STATUS
	BBS	#RY_DB_V_CRC,-		;IF SET - CRC ERROR
		UCB$W_DY_DB(R5),FUNCXT	;...
	MOVZWL	#SS$_DRVERR,R0		;ASSUME DRIVE ERROR STATUS
	BITW	#RY_DB_M_DE!RY_DB_M_ACLO,-  ;DENSITY OR PWR ERROR?
		UCB$W_DY_DB(R5)		;...
	BNEQ	FUNCXT			;IF NEQ - YES
	MOVZWL	#SS$_CTRLERR,R0		;SET CONTROLLER ERROR STATUS

FUNCXT:					;FUNCTION EXIT
	PUSHL	R0			;SAVE FINAL REQUEST STATUS
	JSB	G^IOC$DIAGBUFILL	;FILL DIAGNOSTIC BUFFER IF PRESENT
	TSTW	UCB$W_DY_DPN(R5)	;ARE UBA RESOURCES ALLOCATED?
	BEQL	10$			;IF EQL - NO
	ADDW3	UCB$W_BCR(R5),-		;CALCULATE BYTES TRANSFERRED
		IRP$W_BCNT(R3),2(SP)	;AND PUT IN I/O STATUS BLOCK
	RELDPR				;RELEASE DATA PATH
	RELMPR				;RELEASE MAP REGISTERS
10$:	RELCHAN				;RELEASE CHANNEL IF OWNED
	CLRL	R1			;CLEAR 2ND LONGWORD OF IOSB
	POPL	R0			;GET 1ST LONGWORD OF IOSB
	REQCOM				;COMPLETE REQUEST
	.PAGE
; FEXL - RX211 HARDWARE FUNCTION EXECUTION 
; 
; THIS ROUTINE IS CALLED VIA A BRB FROM STARTIO. PARAMETERS ARE LOADED
; INTO DEVICE REGISTERS AND THE FUNCTION IS INITIATED. THE RETURN ADDRESS
; IS STORED IN THE UCB AND A WAITFOR INTERRUPT IS EXECUTED. WHEN THE
; INTERRUPT OCCURS, CONTROL IS RETURNED TO THE CALLER.
; 
; INPUTS:
; 	R3 = IRP ADDRESS (I/O REQUEST PACKET)
; 	R5 = UCB ADDRESS (UNIT CONTROL BLOCK)
; 	00(SP) = RETURN ADDRESS OF CALLER
; 
; OUTPUTS:
; 	THERE ARE FOUR EXITS FROM THIS ROUTINE:
; 
; 	1. SPECIAL CONDITION - THIS EXIT IS TAKEN IF A POWER FAILURE OCCURS
; 		OR THE OPERATION TIMES OUT. 
; 
; 	2. FATAL ERROR - THIS EXIT IS TAKEN IF A FATAL CONTROLLER OR DRIVE
; 		ERROR OCCURS OR IF ANY ERROR OCCURS AND ERROR RETRY IS EITHER
; 		INHIBITED OR EXHAUSTED. 
; 
; 	3. RETRIABLE ERROR - THIS EXIT IS TAKEN IF A RETRIABLE CONTROLLER
; 		OR DRIVE ERROR OCCURS AND ERROR RETRY IS NEITHER INHIBITED
; 		NOR EXHAUSTED. 
; 
; 	4. SUCCESSFUL OPERATION - THIS EXIT IS TAKEN IF NO ERRORS OCCUR
; 		DURING THE OPERATION. 
; 
; 	IN ALL CASES IF AN ERROR OCCURS, AN ATTEMPT IS MADE TO LOG THE ERROR.
; 	IN ALL CASES FINAL DEVICE REGISTERS ARE RETURNED VIA THE UCB.
; 	UCB$W_BCR(R5) = NEGATIVE BYTES REMAINING TO TRANSFER

FEXL:					;FUNCTION EXECUTOR 
	MOVL	UCB$L_CRB(R5),R0	;GET ADDRESS OF PRIMARY CRB
	MOVL	CRB$L_INTD+VEC$L_IDB(R0),R1  ;GET ADDRESS OF IDB
	CMPL	R5,IDB$L_OWNER(R1)	;DOES THIS PROCESS OWN CHANNEL?
	BNEQ	10$			;IF NEQ - NO
	MOVL	IDB$L_CSR(R1),R4	;SET ASSIGNED CHANNEL CSR ADDRESS
	BRB	20$			;
10$:	REQPCHAN			;REQUEST CHANNEL (RETURNS R4 = CSR ADR)

20$:	BITW	#RY_CS_M_RX02,RY_CS(R4)	;IS DEVICE RX02?
	BNEQ	30$			;IF NEQ - YES
	BISB	#RY_RX01SW,UCB$B_DY_ER(R5)  ;SET ERROR BIT IN UCB
	JSB	G^ERL$DEVICERR		;ALLOCATE AND FILL ERROR MESSAGE BUFFER
	MOVZWL	#SS$_CTRLERR,R0		;SET CONTROLLER ERROR (RX01 SWITCH SET)
	BRW	RESETXFR		;EXIT

30$:	CMPB	#IO$_FORMAT,UCB$B_FEX(R5)  ;FORMAT FUNCTION?
	BEQL	FORMAT			;IF EQL - YES
	CMPB	#IO$_PACKACK,UCB$B_FEX(R5)  ;PACK ACKNOWLEDGE FUNCTION?
	BEQL	40$			;IF EQL - YES
	BRW	XFER			;MUST BE A TRANSFER FUNCTION
40$:	BRW	PACKACK			;PACK ACKNOWLEDGE FUNCTION
	.PAGE
; 
; FORMAT FUNCTION EXECUTION (SET MEDIA DENSITY)
; 
; FUNCTIONAL DESCRIPTION:
; 
; THIS FUNCTION CAUSES THE ENTIRE DISKETTE TO BE REASSIGNED TO A NEW
; DENSITY.  THIS OPERATION TAKES ABOUT 15 SECONDS TO COMPLETE.
; 
; IT IS ASSUMED THAT AN IO$_PACKACK HAS ALREADY BEEN PERFORMED ON THIS
; DISKETTE TO SET UP UCB$B_TRACKS.
;
; THE DRIVER EXITS WITH SS$_CTRLERR STATUS IF SINGLE DENSITY FORMAT
; IS REQUESTED FOR A DOUBLE SIDED DISKETTE.
; 
; The Driver exits with SS$_FORMAT status if an attempt is made to reformat
;	a quad density diskette.  The diskette is not modified.
;
; INPUTS:
; 	R3	- IRP ADDRESS
; 	R4	- CSR ADDRESS
; 	R5	- UCB ADDRESS
; 

FORMAT:					;REFORMAT DISK TO NEW DENSITY

; 
; SET NEW DENSITY (VIA MAXBLOCK) IN UCB
; 

	MOVL	IRP$L_MEDIA(R3),-	;SET PARAMETER LONGWORD IN UCB
		UCB$L_MEDIA(R5)		;...
	CMPB	UCB$B_TRACKS(R5),#2	;IS IT DOUBLE SIDED?
	BLSS	10$			;IF LSS - NO
	MOVZWL	#RY_DSDD,UCB$L_MAXBLOCK(R5)  ;SET DOUBLE SIDED MAXBLOCKS
	CMPL	UCB$L_MEDIA(R5),#2	;IS DOUBLE DENSITY REQUESTED?
	BEQL	20$			;IF EQL - YES
	MOVZWL	#SS$_CTRLERR,R0		;SET ERROR STATUS
	BRW	FUNCXT			;AND EXIT

10$:	MOVZWL	#RY_SSSD,UCB$L_MAXBLOCK(R5)  ;ASSUME SINGLE DENSITY
	CMPL	UCB$L_MEDIA(R5),#2	;IS DOUBLE DENSITY REQUESTED?
	BLSS	20$			;IF LSS - NO, SINGLE DENSITY
	MOVZWL	#RY_SSDD,UCB$L_MAXBLOCK(R5)  ;SET DOUBLE DENSITY MAXBLOCKS

;
; REFORMAT DISKETTE
; 

20$:	BSBW	DY_MERGE		;MERGE GO,UNIT,IE,DEN IN R2
	BISW3	R2,#F_SETDEN,RY_CS(R4)	;INITIATE SET DENSITY FUNCTION
	WAIT_TR				;WAIT FOR CONTROLLER T/R
	CKPWR				;DSBINT & CHECK FOR PWR FAILURE
	MOVW	#^X49,RY_DB(R4)		;PUT ASCII "I" IN DBR TO START FNTN
	WFIKPCH	SPECOND,#25		;WAITFOR INTERRUPT
	IOFORK				;CREATE FORK PROCESS (&JSB BACK TO ISR)

	BBC	#RY_CS_V_ERR,-		; If no error at all, branch around.
		UCB$W_DY_CS(R5),30$
	BBC	#RY_DB_V_DE,-		; If no DENSITY error, branch around.
		UCB$W_DY_DB(R5),30$
	BBC	#RY_DB_V_QDEN,-		; If NOT quad density, branch around.
		UCB$W_DY_DB(R5),30$
	MOVZWL	#SS$_FORMAT,R0		; If we tried to change QUAD diskette.
	BRW	FUNCXT			;  Return error and branch.
30$:
	BRW	RETREG			;
	.PAGE
; 
; PACK ACKNOWLEDGE FUNCTION EXECUTION
; 
; INPUTS:
; 
; 	R4	- CSR ADDRESS
; 	R5	- UCB ADDRESS
; 
; FUNCTIONAL DESRIPTION:
; 
; 	THIS OPERATION ESTABLISHES THE CURRENT DISKETTE'S DENSITY AND
; 	NUMBER OF SIDES.  THIS INFORMATION IS THEN STORED IN THE UCB.
; 
; 	IO$PACKACK MUST BE THE FIRST FUNCTION ISSUED TO A DISKETTE AFTER
; 	IT HAS BEEN PLACED IN A DRIVE.
; 
; OUTPUTS:
; 
; 	UCB$L_MAXBLOCK, UCB$B_TRACKS, UCB$B_SECTORS, UCB$W_CYLINDERS,
; 	UCB$B_DEVTYPE, AND UCB$B_DEVCLASS ARE UPDATED.  UCB$V_VALID IS
;	SET IN UCB$W_STS.
; 

PACKACK:				;PACK ACKNOWLEDGE
	BISW	#UCB$M_VALID,UCB$W_STS(R5)  ;Set software volume valid bit.
	MOVB	#RY_SECTORS,UCB$B_SECTORS(R5)  ;SET SECTORS/TRACK
	MOVZBW	#RY_CYLINDERS,UCB$W_CYLINDERS(R5)  ;SET # CYLINDERS
	MOVB	#DC$_DISK,UCB$B_DEVCLASS(R5)  ;SET DISK DEVICE CLASS
	MOVB	#DT$_RX02,UCB$B_DEVTYPE(R5)  ;ASSUME RX02 DEVICE TYPE
	MOVB	#1,UCB$B_TRACKS(R5)	;ASSUME SINGLE SIDED
	MOVZWL	#RY_SSSD,UCB$L_MAXBLOCK(R5)  ;ASSUME SINGLE DENSITY

	BSBW	DY_MERGE		;MERGE GO,UNIT,DEN,IE IN R2
	CKPWR				;DSBINT & CHECK FOR PWR FAILURE
	BISW3	R2,#F_READSTATUS,RY_CS(R4)  ;EXECUTE READ STATUS FUNCTION
	WFIKPCH	SPECOND,#10		; Wait for interrupt.
	IOFORK				;CREATE FORK PROCESS (& JSB BACK TO ISR)

	BITW	#RY_DB_M_DRDY,UCB$W_DY_DB(R5)  ;WAS DRIVE READY?
	BNEQ	10$			;IF NEQ - YES
	MOVZWL	#SS$_MEDOFL,R0		;SET MEDIUM OFFLINE STATUS
	BRW	FUNCXT			;AND EXIT

10$:
	BBCC	#RY_DB_V_DE,-		; If clear, Single density so
		UCB$W_DY_DB(R5),15$	;  branch around.
	MOVZWL	#RY_SSQD,-		; If NOT single, setup for QUAD and
		UCB$L_MAXBLOCK(R5)	;  then we will test to see if so.
	BBS	#RY_DB_V_QDEN,-		; If set, then it IS quad density so
		UCB$W_DY_DB(R5),15$	;  we branch around next instruction.
	MOVZWL	#RY_SSDD,UCB$L_MAXBLOCK(R5)  ;SET DOUBLE DENSITY IN UCB
15$:
	BITW	#RY_DB_M_CRC!-		;ANY ERRORS BESIDES DENSITY ERROR?
		RY_DB_M_ACLO!-		;...
		RY_DB_M_WCO!-		;...
		RY_DB_M_NXM,-		;...
		UCB$W_DY_DB(R5)		;...
	BNEQ	20$			;IF NEQ - YES
	BICW	#RY_CS_M_ERR,UCB$W_DY_CS(R5)  ;NO, CLEAR CSR ERROR BIT

20$:
	BBC	#RY_DB_V_RX04,-			; See if controller is RX04.
		UCB$W_DY_DB(R5),30$		;  and if NOT branch around.
	MOVB	#DT$_RX04,UCB$B_DEVTYPE(R5)	; Set proper device type.
30$:	BRW	RETREG			;
	.PAGE
; 
; TRANSFER FUNCTION EXECUTION
; 
; 	FUNCTIONS INCLUDE:
; 
; 		WRITE DATA, AND
; 		READ DATA
; 
; INPUTS:
; 
; 	R3	- IRP ADDRESS
; 	R4	- DEVICE CSR ADDRESS
; 	R5	- UCB ADDRESS
; 
; FUNCTIONAL DESCRIPTION:
; 
; THE LBN IS CONVERTED TO CYLINDER, TRACK, AND SECTOR, THEN SKEW AND
; INTERLEAVE FACTORS ARE CALCULATED TO ARRIVE AT A PHYSICAL MEDIA ADDRESS.
; 
; A UNIBUS DATAPATH IS REQUESTED FOLLOWED BY THE APPROPRIATE NUMBER OF MAP
; REGISTERS REQUIRED FOR THE TRANSFER.
; 
; SINCE THE RX211 ALLOWS A MAXIMUM DATA TRANSFER OF ONE SECTOR, SINGLE
; SECTOR TRANSFERS ARE REPEATED (VIA THE "COMXFER:" LOOP) UNTIL THE I/O
; REQUEST IS COMPLETE.
; 
; EACH SECTOR TRANSFER IS ACCOMPLISHED BY A SEQUENCE OF TWO FUNCTION CODES:
; 	F_FILLBUFFER AND F_WRITESECTOR FOR A WRITE FUNCTION, OR
; 	F_READSECTOR AND F_EMPTYBUFFER FOR A READ FUNCTION.
; THE CSR BITS FOR THE FIRST FUNCTION IN THE SEQUENCE ARE LOADED INTO THE
; LOWER WORD OF UCB$L_DY_XFER; THOSE FOR THE SECOND FUNCTION ARE PUT IN
; THE UPPER WORD.  AFTER EXECUTING EACH FUNCTION, UCB$L_DY_XFER IS ROTATED
; SO THAT THE LOWER WORD ALWAYS CONTAINS THE CSR BITS FOR THE NEXT FUNCTION.
; 
; A PROTOCALL OF LOADING THE RX211 DATA BUFFER REGISTER (DBR) WITH TWO UCB
; FIELDS IS REQUIRED AFTER LOADING THE CSR.  R3 IS LOADED AND ROTATED SO
; THAT ITS LOWER WORD ALWAYS CONTAINS THE FIRST UCB OFFSET TO BE LOADED
; INTO THE DBR FOR THE CURRENT FUNCTION CODE.
; 
; THE CHANNEL AND UBA RESOURCES ARE NOT RELEASED UNTIL THE ENTIRE I/O
; REQUEST IS COMPLETE.
; 
; IT IS ASSUMED THAT AN IO$_PACKACK FUNCTION HAS ALREADY BEEN PERFORMED
; ON THIS DISKETTE TO SET UP UCB$B_TRACKS AND UCB$L_MAXBLOCK.
; 

XFER:					;TRANSFER FUNCTION EXECUTION

	TSTW	UCB$W_DY_DPN(R5)	;IS THIS A RETRY?
	BEQL	2$			;IF EQL - NO 
	BRW	15$			;DATAPATH ALREADY OWNED

; 
; FIRST TRANSFER OF THIS I/O REQUEST
; 

; 
; DETERMINE SECTOR SIZE
; 

2$:	MOVW	#RY_SWPS,UCB$W_DY_WPS(R5)	; Assume single dens. WORDS/SECTOR
	CMPW	UCB$L_MAXBLOCK(R5),#RY_SSSD  ;SINGLE DENSITY?
	BLEQ	5$			;IF LEQ - YES
	MOVW	#RY_DWPS,UCB$W_DY_WPS(R5)	; Assume double dens. WORDS/SECTOR
	CMPW	UCB$L_MAXBLOCK(R5),#RY_SSDD	; Double density?
	BLEQ	5$				; If LEQ - yes.
	MOVW	#RY_QWPS,UCB$W_DY_WPS(R5)	; Adjust for QUAD density.

; 
; CONVERT LOGICAL BLOCK NUMBER TO CYLINDER, TRACK, AND SECTOR
; 
; 	LBN = LBN * (SECTORS/BLOCK)
; 	LBN/(SECTORS/TRACK) = D + SECTOR
; 	D/(TRACKS/CYLINDER) = CYLINDER + TRACK
; 

5$:	MOVL	IRP$L_MEDIA(R3),UCB$L_DY_LMEDIA(R5)  ;ASSUME PHYSICAL I/O
	BBS	#IRP$V_PHYSIO,-		;IF SET - PHYSICAL I/O
		IRP$W_STS(R3),10$	;...
	MOVZWL	UCB$W_DY_WPS(R5),R0	; Get words per sector.
	DIVW3	R0,#256,R0		;FORM SECTORS/BLOCK IN R0
	MULL	IRP$L_MEDIA(R3),R0	;SCALE LBN IN R0
	MOVZBL	UCB$B_SECTORS(R5),R2	;PUT SECTORS/TRACK IN R2
	CLRL	R1			;CLEAR HIGH PART OF DIVIDEND
	EDIV	R2,R0,R0,UCB$L_DY_LMEDIA(R5)  ;CALCULATE SECTOR NUMBER AND STORE
	MOVZBL	UCB$B_TRACKS(R5),R2	;PUT TRACKS/CYLINDER IN R2
	EDIV	R2,R0,R0,R1		;CALCULATE TRACK AND CYLINDER
	MOVB	R1,UCB$L_DY_LMEDIA+1(R5)  ;STORE TRACK NUMBER
	MOVW	R0,UCB$L_DY_LMEDIA+2(R5)  ;STORE CYLINDER NUMBER

;
; Output of above code is to produce the logical sector number in UCB$L_DY_LMEDIA
;	in the following format:
;
;		31	      16 15    8 7      0
;		.................................
;		:		:	:	:
;		:   cylinder	: track	: sector:
;		:	#	:   #	:   #	:
;		:		:(always:  see  :
;		:    0 to 76	: zero)	: below :
;		.................................
;
;		Sector number ranges:
;		  Physical I/O  1 to 26
;		  Logical I/O   0 to 25

10$:	MOVZBL	UCB$B_SECTORS(R5), R1	; Get maximum sectors information.
	CMPW	R1, UCB$L_DY_LMEDIA(R5)	; Maximum sector exceeded?
	BBS	#IRP$V_PHYSIO, -	; Seperate the logical from the
		IRP$W_STS(R3), 110$	; physical I/O; branch if physical.
	BLEQU	190$			; Branch if too big for logical I/O.
	BRB	130$			; All ok, so far, continue tests.
110$:	BLSSU	190$			; Branch if physical sector too big.
	TSTL	UCB$L_DY_LMEDIA(R5)	; Zero physical sector is also illegal.
	BEQL	190$			; Branch if zero physical sector.
130$:	CMPW	UCB$W_CYLINDERS(R5), -	; Check for, maximum cylinder
		UCB$L_DY_LMEDIA+2(R5)	; exceeded.
	BGTRU	12$			; Branch if max. cylinder not exceeded.
190$:	MOVZWL	#SS$_IVADDR, R0		; Otherwise, give invalid address 
	BRW	FUNCXT			; status and kill request.

; 
; ALLOCATE UBA RESOURCES
; 

12$:	REQDPR				;REQUEST DATAPATH
	REQMPR				;REQUEST MAP REGISTERS
	LOADUBA				;LOAD UNIBUS MAP REGISTERS
	MOVL	UCB$L_CRB(R5),R1	;GET CRB ADDRESS
	EXTZV	#VEC$V_DATAPATH,#VEC$S_DATAPATH,-  ;EXTRACT DATAPATH NUMBER - 
		CRB$L_INTD+VEC$B_DATAPATH(R1),R0   ;FOR UBA RESOURCE FLAG
	MOVW	R0,UCB$W_DY_DPN(R5)	;INDICATE UBA RESOURCES ALLOCATED
	MOVZWL	UCB$W_BOFF(R5),R0	;GET BYTE OFFSET IN PAGE
	INSV	CRB$L_INTD+VEC$W_MAPREG(R1),-  ;INSERT HIGH 7 BITS OF ADDRESS
		#9,#7,R0		;...
	MOVW	R0,UCB$W_DY_SBA(R5)	;PUT BUFFER ADDRESS IN UCB
	EXTZV	#7,#2,CRB$L_INTD+VEC$W_MAPREG(R1),R0  ;GET MEMORY EXTENSION BITS
	MOVB	R0,UCB$B_DY_XBA(R5)	;AND SAVE THEM IN THE UCB

;
; Output of above section of code is put the UNIBUS Virtual Address of the
;	transfer into UCB$W_DY_SBA and the two high order bits of this UNIBUS
;	Virtual Address into UCB$B_DY_XBA.
;

; 
; SET CSR BITS IN UCB$L_DY_XFER
; SET UCB OFFSETS IN R3 FOR USE AS POINTERS DURING DEVICE DBR PROTOCALL
; 

15$:	BSBW	DY_MERGE		;SET GO,IE,UNIT,DEN BITS IN R2

					;SET UCB OFFSETS IN R3
	MOVZBL	#UCB$W_DY_PWC,R3	;ASSUME WC OFFSET AS POINTER TO UCB-
					;FIELDS FOR 2ND FUNCTION CODE
	ASHL	#16,R3,R3		;MAKE ROOM FOR SECTOR ADDRESS
	MOVB	#UCB$L_MEDIA,R3		;ASSUME DA OFFSET AS POINTER TO UCB-
					;FIELDS FOR 1ST FUNCTION CODE

	CMPB	#IO$_READPBLK,UCB$B_FEX(R5)  ;READ FUNCTION?
	BNEQ	20$			;IF NEQ - NO, MUST BE WRITE

					;READ FUNCTION
	BISW3	#F_READSECTOR,R2,-	;SET READ SECTOR AS 1ST FUNCTION
		UCB$L_DY_XFER(R5)	;...
	BISW3	#F_EMPTYBUFFER,R2,-	;SET EMPTY BUFFER AS 2ND FUNCTION
		UCB$L_DY_XFER+2(R5)	;...
	BRB	COMXFER			;

20$:					;WRITE FUNCTION
	ROTL	#16,R3,R3		;SHIFT ORDER OF UCB OFFSETS FOR WRITE
	BISW3	#F_FILLBUFFER,R2,-	;SET FILL BUFFER AS 1ST FUNCTION
		UCB$L_DY_XFER(R5)	;...
	BISW3	#F_WRITESECTOR,R2,-	;ASSUME WRITE SECTOR AS 2ND FUNCTION
		UCB$L_DY_XFER+2(R5)	;...
	BBC	#IO$V_DELDATA,-		;IF CLR - NOT WRITE DELETED DATA
		UCB$W_FUNC(R5),COMXFER	;...
	CLRW	UCB$L_DY_XFER+2(R5)	;CLEAR 2ND FUNCTION FIELD
	BISW3	#F_WRITEDEL,R2,-	;SET WRITE DELETED DATA AS 2ND FUNCTION
		UCB$L_DY_XFER+2(R5)	;...

; 
; COMMON TRANSFER POINT - LOOP POINT FOR INDIVIDUAL SECTOR TRANSFERS 
; 
; NOTE:	CODE IN THIS LOOP IS IN-LINE AS MUCH AS POSSIBLE TO DECREASE
; 	EXECUTION TIME IN ORDER THAT THE NEXT INTERLEAVED SECTOR ON THE
; 	DISKETTE IS NOT MISSED (WHICH WOULD CAUSE A WAIT FOR AN ENTIRE
; 	DISKETTE REVOLUTION).
; 
; INPUTS TO LOOP:
; 
; 	R3	- UCB OFFSETS FOR DEVICE DBR PROTOCALL
; 	R4	- DEVICE CSR ADDRESS
; 	R5	- UCB ADDRESS
; 	UCB$L_DY_XFER	- LOW WORD: FCODE,GO,IE,DENSITY,UNIT FOR 1ST FUNCITON
; 			- HIGH WORD: FCODE,GO,IE,DENSITY,UNIT FOR 2ND FUNCTION
; 

COMXFER:				;START TRANSFER LOOP

; 
; CALCULATE SKEW AND INTERLEAVE FACTORS
; 
; IF THE PHYSICAL I/O FLAG IS SET, THE ADDRESS IN UCB$L_DY_LMEDIA
; IS MOVED TO UCB$L_MEDIA.
; IF LOGICAL I/O IS BEING PERFORMED, THE LOGICAL ADDRESS IN UCB$L_DY_LMEDIA
; IS CONVERTED TO A PHYSICAL DISK ADDRESS BY APPLYING INTERLEAVE AND SKEW
; FACTORS, AND THE FIRST TRACK (RESERVED FOR INDUSTRY COMPATIBLILITY)
; IS SKIPPED.  THE RESULT IS PLACED IN UCB$L_MEDIA.
; 

	MOVL	UCB$L_IRP(R5),R1	;GET ADDRESS OF REQUEST PACKET
	MOVAB	UCB$L_MEDIA(R5),R2	;POINT TO PHYSICAL MEDIA ADDRESS
	MOVL	UCB$L_DY_LMEDIA(R5),(R2)  ;COPY LOGICAL ADDRESS
	BBS	#IRP$V_PHYSIO,-		;IF SET - PHYSICAL I/O
		IRP$W_STS(R1),10$	;...
	MOVZBL	(R2),R1			;GET CURRENT LOGICAL SECTOR
	ASHL	#1,R1,R0		; 2* Current Logical Sector => R0 needed
					;  in case of QUAD density to compute
					;  interleave factor of four.
	CMPB	#12,R1			;SET C IF SECTOR .GT. 12
	ADWC	R1,R1			;DOUBLE SECTOR #, ADD INTERLEAVE FACTOR
	CMPW	#RY_QWPS,-		; See if this is a QUAD density diskette
		UCB$W_DY_WPS(R5)
	BNEQ	5$			; If NOT, branch around.
	ADDL	R0,R1			; If QUAD, add in 2*Sector for interleave
					;  factor of 4.
5$:
	MOVZBL	2(R2),R0		;GET CYLINDER NUMBER
	EMUL	#6,R0,R1,R0		;COMPUTE SKEW (6 * CYL + SECTOR)
	MOVZBL	UCB$B_SECTORS(R5),-(SP)	;GET SECTORS/TRACK
	EDIV	(SP)+,R0,R0,R1		;MODULO SECTOR INTO SECTORS PER TRACK
	INCL	R1			;OFFSET SECTOR NUMBER BY ONE
	MOVB	R1,(R2)			;SAVE SECTOR NUMBER IN UCB

	INCB	1(R2)			;INCREMENT PAST RESERVED TRACK
	CMPB	1(R2),UCB$B_TRACKS(R5)	;STILL WITHIN DISK DIMENSIONS?
	BLSS	10$			;IF LSS - YES
	CLRB	1(R2)			;RESET TRACK ADDRESS
	INCB	2(R2)			;INCREMENT CYLINDER ADDRESS

; 
; CALCULATE WORD COUNT FOR THIS TRANSFER
; 

10$:	MNEGW	UCB$W_BCR(R5),-		;GET BYTES LEFT TO TRANSFER AND -
		UCB$W_DY_PWC(R5)	;ASSUME ONLY ONE TRANSFER NEEDED
	DIVW	#2,UCB$W_DY_PWC(R5)	;FORM WORDS LEFT TO TRANSFER
	CMPW	UCB$W_DY_PWC(R5),-
		UCB$W_DY_WPS(R5)	; Are additional transfers required?
	BLEQU	20$			;IF LEQU - NO
	MOVW	UCB$W_DY_WPS(R5),-	; Set word count for one sector.
		UCB$W_DY_PWC(R5)	;...

20$:	INSV	UCB$B_DY_XBA(R5),-	;PUT EXTENDED BA IN 1ST FUNCTION<13:12>
		#12,#2,UCB$L_DY_XFER(R5)  ;...
	MOVB	UCB$L_DY_XFER+1(R5),-	;PUT XBA AND HS IN 2ND FUNCTION TOO
		UCB$L_DY_XFER+3(R5)	;...

; 
; EXECUTE TRANSFER FUNCTION
; 
; INPUTS:
; 			.....................................
; 	UCB$L_DY_XFER	:      CSR2       :	 CSR1 	    :
; 			:.................:.................:
; 			.....................................
; 		R3	:      DBR3       :  	 DBR1       :
; 			:.................:.................:
; 
; 		CSRn = BITS FOR nTH LOAD OF DEVICE CSR
; 		DBRn = OFFSET IN UCB FOR nTH LOAD OF DEVICE DBR
; 
; FUNCTIONAL DESCRIPTION:
; 	THE CSR IS LOADED WITH THE LOW WORD OF UCB$L_DY_XFER.
; 	THE DBR IS LOADED WITH THE UCB FIELD SPECIFIED BY THE UCB OFFSET
; 	IN THE LOW WORD OF R3.
; 	THE DBR IS THEN LOADED WITH THE NEXT SEQUENTIAL UCB FIELD.
; 	AFTER THE INTERRUPT, UCB$L_DY_XFER AND R3 ARE ROTATED, AND THE 
; 	PROCESS IS REPEATED FOR FUNCTION 2.
; 

	MOVB	#2,UCB$B_DY_LCT(R5)	;SET LOOP COUNTER
30$:
	MOVW	UCB$L_DY_XFER(R5),RY_CS(R4)  ;PUT FUNCTION IN CSR
	WAIT_TR				;WAIT FOR CONTROLLER T/R

					;LOAD WORD COUNT OR SECTOR ADR IN DBR
	MOVZWL	R3,R0			;GET UCB OFFSET 
	ADDL	R5,R0			;CALCULATE UCB FIELD ADDRESS
	MOVW	(R0)+,RY_DB(R4)		;PUT UCB FIELD IN DBR
	WAIT_TR				;WAIT FOR CONTROLLER T/R

					;LOAD BUS ADR OR CYLINDER ADR IN DBR
	DSBINT
	BBC	#UCB$V_POWER,UCB$W_STS(R5),35$  ;IF CLR - NO POWER FAILURE
	ENBINT				;ENABLE INTERRUPTS
	BRW	PWRFAIL			;HANDLE POWER FAILURE
35$:	MOVW	(R0),RY_DB(R4)		;PUT NEXT UCB FIELD IN DBR
	WFIKPCH	SPECOND,#2		;WAIT FOR INTERRUPT
	IOFORK				;CREATE FORK PROCESS (&JSB BACK TO ISR)
	ROTL	#16,R3,R3		;SETUP UCB FIELDS FOR NEXT FUNCTION
	ROTL	#16,UCB$L_DY_XFER(R5),-	;SET UP NEXT FUNCTION
		UCB$L_DY_XFER(R5)	;...

	BBC	#RY_CS_V_ERR,UCB$W_DY_CS(R5),40$  ;IF CLR - NO ERRORS
	BRW	DY_PURGE		; Error - Goto Purge datapath

40$:	DECB	UCB$B_DY_LCT(R5)	;DECREMENT LOOP COUNTER
	BLEQ	45$			;IF LEQ - DONE, DON'T LOOP AGAIN
	BRW	30$			;LOOP FOR 2ND FUNCTION

; 
; UPDATE BUFFER ADDRESS, DISK ADDRESS, AND BYTES REMAINING FOR NEXT SECTOR
; 

					;UPDATE BYTES REMAINING TO TRANSFER
45$:	MOVZWL	UCB$W_DY_PWC(R5),R0	;GET WORDS TRANSFERRED
	MULL	#2,R0			;FORM BYTES TRANSFERRED
	ADDW	R0,UCB$W_BCR(R5)	;UPDATE NEG BYTES REMAINING TO TRANSFER

					;UPDATE BUFFER ADDRESS
	MOVZWL	UCB$W_DY_SBA(R5),R1	;GET ORIGINAL BUFFER ADDRESS IN R1
	INSV	UCB$B_DY_XBA(R5),#16,#2,R1  ;INSERT EXTENDED BITS
	ADDL	R0,R1			;UPDATE BA WITH BYTES TRANSFERRED
	EXTZV	#16,#2,R1,R0		;GET NEW MEMORY EXTENSION BITS
	MOVB	R0,UCB$B_DY_XBA(R5)	;AND SAVE IN UCB
	MOVW	R1,UCB$W_DY_SBA(R5)	;SAVE BUFFER ADDRESS IN UCB

					;UPDATE DISK ADDRESS
;
; Here we update the disk address contained in UCB$L_DY_LMEDIA.
;	If we are doing LOGICAL I/O then we simply add one to
;	the logical sector number and if the sum of this addition
;	is EQUAL to the # of sectors on a track (26) we have an
;	overflow condition so we zero the logical sector # and bump
;	the logical track #.  We do the same for the logical track #
;	and the logical cylinder number.
;
;	Unfortunately if we are doing PHYSICAL I/O we have one little
;	glitch in that physical sector numbers are in the range
;	of 1 to 26 rather than in the range of 0 to 25.  Therefore
;	the following code treats the updating of the disk address
;	slightly differently in the case of LOGICAL and PHYSICAL I/O.
;

	MOVAB	UCB$L_DY_LMEDIA(R5),R2	; R2 => Logical Media Address.
	MOVAB	UCB$B_SECTORS(R5),R1	; R1 => disk dimensions.
	MOVL	UCB$L_IRP(R5),R0	; R0 => IRP.
	BBS	#IRP$V_PHYSIO,-		; If SET this IS PHYSICAL I/O so
		IRP$W_STS(R0),60$	;  branch to special treatment.
	MOVL	#2,R0			; Set loop count for LOGICAL I/O case.
50$:	INCB	(R2)			; Increment sector, track or cyl. #
	CMPB	(R2),(R1)+		; Test against limit for field.
	BLSSU	80$			; LSSU implies NO overflow - so goto OK
	CLRB	(R2)+			; Overflow, so reset to zero and
	SOBGEQ	R0,50$			;  if GEQ loop to increment next field
	BRB	70$			; If we overflowed cylinders, branch.
60$:					; Special PHYSICAL I/O case.
	INCB	(R2)			; Increment sector #.
	CMPB	(R2),(R1)+		; Compare to limit.
	BLEQ	80$			; If < or = to 26 - OK so branch.
	MOVB	#1,(R2)+		; If overflow reset to 1 for sectors.
	INCB	(R2)			; And bump tracks.
	CMPB	(R2),(R1)+		; Compare to limit.
	BLSSU	80$			; If < OK so branch out.
	CLRB	(R2)+			; Clear overflowed track field and
	INCB	(R2)			;  increment cylinders.
	CMPB	(R2),(R1)		; Test if we overflowed cylinders.
	BLSSU	80$			; If NOT, branch around to OK.
70$:					; Here we have overflowed the cylinder
					;  field, but if the XFER is done it
					;  doesn't matter.
	TSTW	UCB$W_BCR(R5)		; Beyond last LBN - is XFER complete?
	BEQL	DY_PURGE		; If EQL - yes, so branch around.
	MOVZWL	#SS$_IVADDR,R0		;SET INVALID DISK ADDRESS STATUS
	BRW	FUNCXT			;AND EXIT

80$:
	TSTW	UCB$W_BCR(R5)		; Any bytes remaining to transfer?
	BEQL	DY_PURGE		;IF EQL - TRANSFER COMPLETE
	BRW	COMXFER			;MORE BYTES REMAINING - CONTINUE

					; 
					; END OF "COMXFER:" LOOP
					; 

; 
; PURGE DATAPATH 
; 

DY_PURGE:				;PURGE DATAPATH
	JSB	G^IOC$PURGDATAP		;PURGE DATAPATH
	BLBS	R0,DY_SAVE		;IF SET - NO PURGE ERROR
	INCB	UCB$B_DY_ER(R5)		;SET PURGE ERROR 

; 
; SAVE UBA REGISTERS FOR REGDUMP ROUTINE
; 

DY_SAVE:				;SAVE UBA REGISTERS
	MOVL	R1,UCB$L_DY_DPR(R5)	;SAVE DATAPATH REGISTER
	MOVZWL	UCB$W_DY_SBA(R5),R1	;GET ORIGINAL BUFFER ADDRESS
	INSV	UCB$B_DY_XBA(R5),#16,#2,R1  ;INSERT EXTENDED ADDRESS BITS
	CLRL	R0			;CLEAR R0 FOR WORD COUNT
	ADDW3	UCB$W_BCNT(R5),-	;CALCULATE BYTES TRANSFERRED
		UCB$W_BCR(R5),R0	;...
	DIVW	#2,R0			;FORM WORDS TRANSFERRED IN R0
	ADDL	R0,R1			;FORM FINAL BUFFER ADDRESS IN R1
	ASHL	#-7,R1,R0		;SHIFT IN R0 FOR FINAL MAP REG NO.
	CMPW	#495,R0			;LEGAL MAP REGISTER?
	BGEQ	10$			;IF GEQ - YES
	MOVZWL	#495,R0			;RESTRICT MAP REGISTER NUMBER
10$:	MOVL	(R2)[R0],UCB$L_DY_FMPR(R5)  ;SAVE FINAL MAP REGISTER NUMBER
	CLRL	UCB$L_DY_PMPR(R5)	;CLEAR PREVIOUS MAP REGISTER CONTENTS
	DECL	R0			;CALCULATE PREVIOUS MAP REGISTER NUMBER
	CMPV	#VEC$V_MAPREG,#VEC$S_MAPREG,-  ;ANY PREVIOUS MAP REGISTER?
		CRB$L_INTD+VEC$W_MAPREG(R3),R0 ;...
	BGTR	RETREG			;IF GTR - NO
	MOVL	(R2)[R0],UCB$L_DY_PMPR(R5)  ;SAVE PREVIOUS MAP REGISTER

; 
; DETERMINE EXIT - SPECIAL CONDITION, FATAL ERROR, RETRIABLE ERROR, OR SUCCESS
; 

RETREG:					;DETERMINE EXIT
	BBS	#RY_CS_V_ERR,UCB$W_DY_CS(R5),2$  ;IF SET - DEVICE ERROR
	BLBC	UCB$B_DY_ER(R5),10$	;IF CLR - NO PURGE ERROR
2$:
	ASSUME	UCB$W_DY_DB	EQ	UCB$W_DY_CS+2
	MOVL	UCB$W_DY_CS(R5),-	; Remember values before reading
		UCB$L_DY_SAVECS(R5)	;  extended sense.
	BSBW	READ_ERROR_REGISTER	; Read hardware error data into UCB.
	CKOFL				; Check if device is offline.
	MOVL	UCB$L_DY_SAVECS(R5),-	; Restore values after reading
		UCB$W_DY_CS(R5)		;  extended sense.
	JSB	G^ERL$DEVICERR		;ALLOCATE AND FILL ERROR MESSAGE BUFFER
	BBS	#IO$V_INHRETRY,UCB$W_FUNC(R5),20$  ;IF SET - RETRY INHIBITED
	BBS	#RY_DB_V_NXM,UCB$W_DY_DB(R5),15$  ;IF SET - NONEXISTENT MEMORY
	BBS	#RY_DB_V_CRC,UCB$W_DY_DB(R5),5$  ;IF SET - CRC ERROR
	BSBW	RX211_REINIT			 ; Else go try to reset RX211.

; 
; RETRIABLE ERROR EXIT
; 

5$:	BRW	RETRYERR		;RETRY EXIT

; 
; SUCCESSFUL OPERATION EXIT
; 

10$:	BRW	NORMAL			;SUCCESSFUL EXIT

; 
; FATAL ERROR EXIT
; 

15$:					;NXM ERROR - INIT TO CLEAR
	BSBW	RX211_REINIT		; Execute RX211 initialize.
20$:	BRW	FATALERR		;FATAL ERROR EXIT

; 
; SPECIAL CONDITION EXIT (POWER FAILURE OR DEVICE TIMEOUT)
; 

SPECOND:
	BBS	#UCB$V_POWER,-		;IF SET - POWER FAILURE
		UCB$W_STS(R5),PWRFAIL	;IF CLR - DEVICE TIMEOUT
	JSB	G^ERL$DEVICTMO		;LOG DEVICE TIMEOUT
	SETIPL	UCB$B_FIPL(R5)		;LOWER TO FORK LEVEL
	BSBW	RX211_REINIT		; Execute RX211 initialize.
	MOVZWL	#SS$_TIMEOUT,R0		;SET DEVICE TIMEOUT STATUS
	DECB	UCB$B_ERTCNT(R5)	;ANY ERROR RETRIES REMAINING?
	BEQL	RESETXFR		;IF EQL - NO
	BICW	#UCB$M_TIMOUT,UCB$W_STS(R5)  ;CLEAR TIMEOUT STATUS
	MOVL	UCB$L_IRP(R5),R3	;RESTORE IRP ADDRESS
	BRW	FEXL			;RETURN

RESETXFR:				;RESET TRANSFER BYTE COUNT
	MOVL	UCB$L_IRP(R5),R3	;GET ADDRESS OF I/O PACKET
	MNEGW	IRP$W_BCNT(R3),UCB$W_BCR(R5)  ;RESET BYTE COUNT
	BRW	FUNCXT			;EXIT

PWRFAIL:				;POWER FAILURE
	BICW	#UCB$M_POWER,UCB$W_STS(R5)  ;CLEAR POWER FAILURE BIT
	TSTW	UCB$W_DY_DPN(R5)	;ARE UBA RESOURCES ALLOCATED?
	BEQL	10$			;IF EQL - NO
	RELDPR				;RELEASE DATA PATH
	RELMPR				;RELEASE MAP REGISTERS
10$:	RELCHAN				;RELEASE CHANNEL IF OWNED
	MOVL	UCB$L_IRP(R5),R3	;GET ADDRESS OF I/O PACKET
	MOVQ	IRP$L_SVAPTE(R3),-	;RESTORE TRANSFER PARAMETERS
		UCB$L_SVAPTE(R5)	;...
	BRW	DY_STARTIO		;START REQUEST OVER
	.PAGE
	.SBTTL	INTERRUPT SERVICE ROUTINE
;++
; DY_INT - RX211 INTERRUPT SERVICE ROUTINE
; 
; FUNCTIONAL DESCRIPTION:
; 
; 	THIS ROUTINE IS ENTERED VIA A JSB INSTRUCTION WHEN AN INTERRUPT
; 	OCCURS ON AN RX211 DISK CONTROLLER. IF THE INTERRUPT IS NOT EXPECTED,
; 	THE UNSOLICITED INTERRUPT ROUTINE DISMISSES THE INTERRUPT. IF 
; 	THE INTERRUPT IS EXPECTED, DEVICE REGISTERS ARE SAVED AND THE
; 	DRIVER IS CALLED AT ITS INTERRUPT RETURN ADDRESS. THE DRIVER FORKS,
; 	CAUSING A RETURN TO THIS ROUTINE, WHICH RESTORES GENERAL REGISTERS 
; 	AND DISMISSES THE INTERRUPT. 
; 
; INPUTS:
; 
; 	00(SP)	- POINTER TO ADDRESS OF THE IDB 
; 	04(SP)	- SAVED R0
; 	08(SP)	- SAVED R1
; 	12(SP)	- SAVED R2
; 	16(SP)	- SAVED R3
; 	20(SP)	- SAVED R4
; 	24(SP)	- SAVED R5
; 	28(SP)	- PC AT THE TIME OF THE INTERRUPT
; 	32(SP)	- PSL AT THE TIME OF THE INTERRUPT
; 
; OUTPUTS:
; 
; 	DEVICE REGISTERS ARE SAVED, IPL IS LOWERED TO FORK LEVEL, THE
; 	INTERRUPT IS DISMISSED, ALL REGISTERS EXCEPT R0-R5 ARE PRESERVED.
;--

DY_INT::				;INTERRUPT SERVICE ROUTINE
	MOVL	@(SP)+,R3		;REMOVE ADDRESS OF IDB FROM STACK
	ASSUME	IDB$L_CSR    EQ  0
	ASSUME	IDB$L_OWNER  EQ  4
	MOVQ	(R3),R4			;GET ADDRESS OF CSR AND UCB
	TSTL	R5			; Make sure we have OWNER.
	BEQL	DY_UNSOLNT		; EQL implies RX controller has NO owner.
	MOVW	RY_CS(R4),UCB$W_DY_CS(R5)  ;SAVE CONTROL STATUS REGISTER
	MOVZBL	#F_READSECTOR/2,R3	;GET READ SECTOR FUNCTION CODE
	CMPZV	#1,#3,UCB$L_DY_XFER(R5),R3  ;WAS THIS A READ SECTOR FUNCTION?
	BNEQ	10$			;IF NEQ - NO, SAVE ORIGINAL DELD BIT
	MOVW	RY_DB(R4),UCB$W_DY_DB(R5)  ;SAVE DATA BUFFER REGISTER
	BRB	20$			;
10$:	BICW	#^C<RY_DB_M_DELD>,-	;SAVE DELETED DATA BIT NOW IN UCB
		UCB$W_DY_DB(R5)		;...
	BICW3	#RY_DB_M_DELD,RY_DB(R4),R3  ;GET ALL BUT DELD BIT FROM DBR
	BISW	R3,UCB$W_DY_DB(R5)	;SAVE DATA BUFFER REGISTER
20$:	BICW	#RY_CS_M_IE!RY_CS_M_GO!-  ;DISABLE FURTHER INTERRUPTS
		RY_CS_M_INIT,RY_CS(R4)	;...
	BBCC	#UCB$V_INT,-		;IF CLR - INTERRUPT NOT EXPECTED
		UCB$W_STS(R5),DY_UNSOLNT  ;...

	MOVQ	UCB$L_FR3(R5),R3	;RESTORE DRIVER CONTEXT
	JSB	@UCB$L_FPC(R5)		;CALL DRIVER AT INTERRUPT RETURN ADDRESS

DY_UNSOLNT:				;UNSOLICITED INTERRUPT
	POPR	#^M<R0,R1,R2,R3,R4,R5>	;RESTORE R0-R5
	REI				;RETURN FROM INTERRUPT
	.PAGE
	.SBTTL	REGISTER DUMP ROUTINE
;++
; 
; DY_REGDUMP - REGISTER DUMP ROUTINE
; 
; FUNCTIONAL DESCRIPTION:
; 
; THIS ROUTINE IS CALLED TO SAVE THE DEVICE REGISTERS AND UBA RESOURCE
; REGISTERS IN A SPECIFIED BUFFER. IT IS CALLED FROM THE DEVICE ERROR
; LOGGING ROUTINE AND FROM THE DIAGNOSTIC BUFFER FILL ROUTINE.
; 
; INPUTS:
; 
; 	R0	- ADDRESS OF REGISTER SAVE BUFFER
; 	R4	- ADDRESS OF DEVICE CONTROL STATUS REGISTER (CSR)
; 	R5	- ADDRESS OF UNIT CONTROL BLOCK (UCB)
; 	UCB$B_DY_ER   - SPECIAL ERRORS: BIT 0 - DATAPATH PURGE ERROR
; 					BIT 1 - RX211 SWITCH SET FOR RX01
; 
; OUTPUTS:
; 
; 	THE DEVICE AND UBA REGISTERS ARE SAVED IN THE SPECIFIED BUFFER.
; 	R0 CONTAINS THE ADDRESS OF THE NEXT EMPTY LONGWORD IN THE BUFFER.
; 	ALL REGISTERS EXCEPT R1 AND R2 ARE PRESERVED.
; 
;--

DY_REGDUMP:				;REGISTER DUMP ROUTINE
	MOVL	#<RY_NUM_REGS+7>,(R0)+	; Insert number of registers.
	MOVAL	UCB$W_DY_CS(R5),R1	;GET ADDRESS OF SAVED DEVICE REGISTERS
	MOVZWL	(R1)+,(R0)+		;DUMP DEVICE CONTROL STATUS REGISTER
	MOVZWL	(R1)+,(R0)+		;DUMP DEVICE DATA BUFFER REGISTER
	MOVZWL	(R1)+,(R0)+		;DUMP DATAPATH NUMBER
	MOVL	(R1)+,(R0)+		;DUMP DATAPATH REGISTER
	MOVL	(R1)+,(R0)+		;DUMP FINAL MAP REGISTER
	MOVL	(R1)+,(R0)+		;DUMP PREVIOUS MAP REGISTER
	MOVZBL	(R1)+,(R0)+		;DUMP SPECIAL ERROR REGISTER
	ASSUME	RY_EXTENDED_STATUS_LENGTH  EQ  8
	MOVQ	UCB$Q_DY_EXTENDED_STATUS(R5),(R0)+	; Copy ERROR REGISTER data.
	RSB				;RETURN
	.PAGE
	.SBTTL	READ_ERROR_REGISTER - Subroutine to read hardware error data

;
; READ_ERROR_REGISTER - subroutine called after a hardware error condition and
;	used to issue the READ ERROR REGISTER command.
;
; The Read Error Register command performs a DMA transfer of 4 words (8 bytes)
;	of hardware error status.  In order to accomplish our task here we must:
;
;	1. Save CRB and UCB fields having to do with the data transfer I/O
;		operation in progress.  These fields are:
;
;		a) CRB$L_INTD+VEC$W_MAPREG - the first UBA map register used
;			to map the I/O buffer in Unibus virtual space.
;		b) CRB$L_INTD+VEC$B_NUMREG - the number UBA map registers
;			currently allocated to map the I/O buffer.
;		c) CRB$L_INTD+VEC$B_DATAPATH - the UBA datapath being used for
;			the transfer in progress.
;		d) UCB$L_SVAPTE, UCB$W_BOFF, and UCB$W_BCNT.
;
;	2. Load a zero into CRB$L_INTD+VEC$B_DATAPATH since the DMA transfer
;		of 8 bytes can easily make use of the direct datapath.
;
;	3. Load UCB$L_SVAPTE with the system virtual address of the page table
;		entry which maps the UCB$Q_DY_EXTENDED_STATUS field, the field
;		into which we will do the DMA transfer of the 8 bytes.
;
;	4. Load UCB$W_BOFF with the offset in its page of UCB$Q_DY_EXTENDED_STATUS.
;
;	5. Load UCB$W_BCNT with the length of UCB$Q_DY_EXTENDED_STATUS (8 bytes).
;
;	6. Once the above fields (steps 2-6) are loaded we can make use of
;		system routines to:
;
;		a) REQMPR - request UBA map registers to map
;			UCB$Q_DY_EXTENDED_STATUS.
;		b) LOADUBA - load the allocated map registers with the
;			appropriate data to realize the mapping.
;
;	7. Calculate the Unibus virtual address of UCB$Q_DY_EXTENDED_STATUS
;		and produce the values to insert into the RX211 (RX411)
;		registers, according to protocol, to effect the Read Error
;		Register command.
;
;	8. Execute the command.
;
;	9. Release UBA map registers and restore CRB and UCB fields.
;
;	10. If no TIMEOUT or POWERFAIL occurred, return to caller, else branch
;		to SPECOND.
;
; INPUTS:
;		R4 => CSR
;		R5 => UCB
;
; OUTPUTS:
;		Error Register data in UCB$Q_DY_EXTENDED_STATUS.
;
;		Registers R0, R1 and R2 are modified.
;


READ_ERROR_REGISTER:
	POPL	UCB$L_DPC(R5)			; Save caller's return address.

	ASSUME	VEC$W_MAPREG+2  EQ  VEC$B_NUMREG
	ASSUME	VEC$B_NUMREG+1  EQ  VEC$B_DATAPATH
	MOVL	UCB$L_CRB(R5),R0		; R0 => CRB.
	MOVL	CRB$L_INTD+VEC$W_MAPREG(R0),-	; Save MAPREG, NUMREG, and
		UCB$L_DY_MAPREGTMP(R5)		;  DATAPATH of current operation
	CLRB	CRB$L_INTD+VEC$B_DATAPATH(R0)	; Insure direct path for READERROR

	ASSUME	UCB$L_SVAPTE+4  EQ  UCB$W_BOFF
	ASSUME	UCB$W_BOFF+2    EQ  UCB$W_BCNT
	MOVQ	UCB$L_SVAPTE(R5),-		; Save contents of UCB$L_SVAPTE,
		UCB$Q_DY_SVAPTETMP(R5)		;  UCB$W_BOFF, and UCB$W_BCNT.

;
; Upto here we have saved all relevent data from the CRB and UCB.  Now we
;	doctor up those fields in the CRB and UCB in order to:
;
;		1. Request UBA map registers to map the 4 word field
;			in the UCB which will serve as the target of the
;			READ ERROR REGISTER command.
;
;		2. Load these UBA map registers with the UBA Virtual Address
;			of this target area.
;

	MOVW	#RY_EXTENDED_STATUS_LENGTH,-	; Put length of target area so
		UCB$W_BCNT(R5)			;  to allocate correct number
						;  of UBA map registers.

	MOVAB	UCB$Q_DY_EXTENDED_STATUS(R5),R0	; R0 => target area.
	BICW3	#^XFE00,R0,UCB$W_BOFF(R5)	; Put offset in page of target.
	EXTZV	S^#VA$V_VPN,S^#VA$S_VPN,R0,R0	; R0 = VPN of target's page in
						;  system space.

	MOVL	G^MMG$GL_SPTBASE,R1		; R1 => base of S0 page table.
	MOVAL	(R1)[R0],UCB$L_SVAPTE(R5)	; NOT SURE IF THIS SHOULDN'T BE
						;  INDIRECT MOV.************

	REQMPR					; Request map registers.
	LOADUBA					; Load map registers with proper
						;  contents to map the target.

;
; Now we calculate the UBA virtual address of the target so as to be able to
;	issue the proper device command.
;
	BSBW	DY_MERGE			; Merge GO_BIT, IE, etc into R2.
	BISW	#F_READERROR,R2			; Or in the command.

	MOVL	UCB$L_CRB(R5),R1		; R1 => CRB.
	MOVZWL	UCB$W_BOFF(R5),R0		; R0 = page offset of target.

	INSV	CRB$L_INTD+VEC$W_MAPREG(R1),-	; Place low order 7 bits of map
		#9,#7,R0			;  reg number into R0 giving
						;  low order 16 bits of UBA
						;  virtual address of target.

	EXTZV	#7,#2,-				; Get high order 2 bits of map
		CRB$L_INTD+VEC$W_MAPREG(R1),R1	;  register number.
	INSV	R1,#RY_CS_V_XBA,-		; Or in the high order two bits
		#RY_CS_S_XBA,R2			;  of the UBA virtual address.

	MOVW	R2,RY_CS(R4)			; Move command to hardware reg.

	WAIT_TR		20$			; Wait for T/R (goto 20$ if error).

;
; Now we load the UBA virtual address into the hardware DB register and wait
;	for the interrupt to occur.
;

	DSBINT
	BBC	#UCB$V_POWER,UCB$W_STS(R5),10$	; If clear, then proceed.
	ENBINT
	BRB	30$				; Branch around if POWERFAIL.

10$:
	MOVW	R0,RY_DB(R4)			; Load register according to
						;  protocol for command.

	WFIKPCH	30$,#2				; Wait for interrupt.
	IOFORK
	BRB	30$				; Branch around timeout re-entry.
20$:
	BISW	#UCB$M_TIMOUT,UCB$W_STS(R5)	; Set timeout flag.
30$:
	SETIPL	UCB$B_FIPL(R5)			; Lower IPL in case TIMEOUT.

;
; Now we deallocate the Unibus map register we allocated above to map the
;	target area and then we restore the UCB and CRB fields to their
;	original values.
;

	RELMPR

	MOVQ	UCB$Q_DY_SVAPTETMP(R5),-	; Restore UCB$L_SVAPTE,
		UCB$L_SVAPTE(R5)		;  UCB$W_BOFF and UCB$W_BCNT.
	MOVL	UCB$L_CRB(R5),R0		; R0 => CRB
	MOVL	UCB$L_DY_MAPREGTMP(R5),-	; Restore MAPREG, NUMREG and
		CRB$L_INTD+VEC$W_MAPREG(R0)	;  DATAPATH.

	BITW	#UCB$M_TIMOUT!UCB$M_POWER,-	; See if we had a POWERFAIL
		UCB$W_STS(R5)			;  or a TIMEOUT.
	BEQL	40$				; EQL implies NO - so branch.
	BRW	SPECOND				; Branch out if POWER or TIMEOUT.
40$:
	JMP	@UCB$L_DPC(R5)			; Return to caller.
DY_END:					;ADDRESS OF LAST LOCATION IN DRIVER
	.END
