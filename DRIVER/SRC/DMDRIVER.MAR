	.TITLE	DMDRIVER - RK611-RK06/RK07 DISK DRIVER
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 12-MAR-77
;
; MODIFIED BY:
;
;	V02-012	ROW0063		Ralph O. Weber		18-JAN-1982
;		Add a unit delivery routine for SYSGEN AUTOCONFIGURE.
;
;	V02-011	ROW0060		Ralph O. Weber		21-DEC-1981
;		Cause IO$_PACKACK function to set UCB$M_VALID in UCB$W_STS.  
;		Cause IO$_UNLOAD to clear it.  Add a new function, 
;		IO$_AVAILABLE, which clears UCB$M_VALID without issuing an 
;		unload function to the drive.
;
;	V02-010	RLR0002		Robert L. Rappaport	21-July-1980
;		Fixed unreachable branch destination caused by EXFUNCH
;		macro using one byte signed offset and the expansion
;		of code generated by new UCB fields.
;
;	V02-009	SRB0027		Steve Beckhardt		30-Jun-1980
;		Fixed UCBSIZE in DPTAB macro to use symbolic name.
;
;	V02-008	SPF0001		Steve Forgey		29-Jan-1981
;		Replace use of clock in timing loop with TIMEWAIT
;		macro.
;
;	V02-007 EAD001		Elliott A. Drayton	5-Dec-1980
;		Return medium offline status if device not ready.
;
;	V02-006	RLR0001		Robert L. Rappaport	6-Nov-1980
;		Eliminated potential semi-infinite loop induced by
;		RECAL performed at end of function exit.
;
;	V02-005	ACG0179		Andrew C. Goldstein,	23-Jul-1980  18:15
;		Fix ACP class code in DPT
;
;	V2.04	LMK0005		LEN KAWELL	24-JAN-1980
;		CHANGE ODD BYTE COUNT ERROR STATUS FROM SS$_BUFBYTALI
;		TO SS$_IVBUFLEN.
;
; 	V2.03	CHF0002		C. FRANKS	16-OCT-1979
; 		FIX RECAL AFTER UNLOAD BUG.
; 
; 	V2.02	CHF0001		C. FRANKS	01-OCT-1979
; 		PER ECO TO RK611 SPEC: RE-READ BEFORE INVOKING ECC,
; 		AND (IF IN OFFSET MODE) RECALIBRATE BEFORE EXITING.
;
;	V2.01	NPKCOMET	N. KRONENBERG	1-FEB-1979
;		MODIFIED TO CALL IOC$PURGDATAP
;
;
;	V1.05	LMK0005		LEN KAWELL	7-AUG-1979
;		RESET BYTE COUNT WHEN A DRIVE FUNCTION FAILS. THIS
;		CORRECTS INVALID BYTE COUNT QIO RETURN WHEN OVERLAPPED
;		SEEK FAILS.
;		
;		ALSO CHANGED BRANCH DISPLACEMENT FROM A .BYTE TO A
;		.SIGNED_BYTE IN EXFUNCL AND EXFUNCH MACROS TO BE SURE
;		OUT OF RANGE DISPLACEMENTS ARE DETECTED.
;
;	V1.04	LMK0003		LEN KAWELL	06-NOV-1978
;		FIX TO CLEAR UBA XMTER ERROR.
;
;	V1.03	LMK0002		LEN KAWELL	20-OCT-1978
;		FIX TO SET PROPER IPL FOR TRANSFER TIMEOUTS.
;
;	V1.02	LMK0001		LEN KAWELL	24-OCT-1978
;		FIX OCCASIONAL OPI ERRORS.
;
;**
	.PAGE
; RK611-RK06/RK07 DISK DRIVER
;
; MACRO LIBRARY CALLS
;
 
	$ADPDEF				;DEFINE ADP OFFSETS
	$ACFDEF				;DEFINE ACF OFFSETS
	$CRBDEF				;DEFINE CRB OFFSETS
	$DDBDEF				;DEFINE DDB OFFSETS
	$DPTDEF				;DEFINE DPT OFFSETS
	$EMBDEF				;DEFINE EMB OFFSETS
	$IDBDEF				;DEFINE IDB OFFSETS
	$IPLDEF				;DEFINE USEFUL IPLs
	$IODEF				;DEFINE I/O FUNCTION CODES
	$IRPDEF				;DEFINE IRP OFFSETS
	$UCBDEF				;DEFINE UCB OFFSETS
	$VECDEF				;DEFINE INTERRUPT DISPATCH VECTOR OFFSETS
 
;
; LOCAL MACROS
;
; EXECUTE FUNCTION AND BRANCH ON RETRIABLE ERROR CONDITION
;
 
	.MACRO	EXFUNCH BDST,FCODE
		.IF NB	FCODE
		MOVZBL	#CD'FCODE,R3
		.ENDC
		BSBW	FEXH
		.SIGNED_BYTE BDST-.-1
	.ENDM
 
	.MACRO	EXFUNCL BDST,FCODE
		.IF NB	FCODE
		MOVZBL	#CD'FCODE,R3
		.ENDC
		BSBW	FEXL
		.SIGNED_BYTE BDST-.-1
	.ENDM
 
;
; GENERATE FUNCTION TABLE ENTRY AND CASE TABLE INDEX SYMBOL
;
 
	.MACRO	GENF FCODE
		CD'FCODE=.-FTAB/2
		.WORD	FCODE!RK_CS1_M_GO!RK_CS1_M_IE
	.ENDM
 
;
; LOCAL SYMBOLS
;
; RK611-RK06/RK07 CONTROLLER REGISTER OFFSETS
;
 
	$DEFINI	RK
 
$DEF	RK_CS1		.BLKW	1	;CONTROL STATUS REGISTER 1
	_VIELD	RK_CS1,0,<-		; CONTROL STATUS REGISTER 1 FIELD DEFINITIONS
		<GO,,M>,-		; GO BIT
		<FCODE,4>,-		; FUNCTION CODE
		<DPPE,,M>,-		; DATA PATH PURGE ERROR
		<IE,,M>,-		; INTERRUPT ENABLE
		<RDY,,M>,-		; CONTROLLER READY
		<MEX,2>,-		; MEMORY EXTENSION BITS
		<CDT,,M>,-		; CONTROLLER DRIVE TYPE
		<CTO,,M>,-		; CONTROLLER TIME OUT
		<CFMT,,M>,-		; CONTROLLER FORMAT ERROR
		<SPAR,,M>,-		; SERIAL BUS PARITY ERROR
		<DI,,M>,-		; DRIVE INTERRUPT
		<CERR,,M>-		; CONTROLLER ERROR
	>				;
$DEF	RK_WC		.BLKW	1	;WORD COUNT REGISTER
$DEF	RK_BA		.BLKW	1	;BUFFER ADDRESS REGISTER
$DEF	RK_DA		.BLKW	1	;DESIRED SECTOR/TRACK ADDRESS REGISTER
	_VIELD	RK_DA,0,<-		; DESIRED ADDRESS FIELD DEFINITIONS
		<SA,5>,-		; DESIRED SECTOR ADDRESS
		<,3>,-			; RESERVED BITS
		<TA,3>-			; DESIRED TRACK ADDRESS
	>				;
$DEF	RK_CS2		.BLKW	1	;CONTROL STATUS REGISTER 2
	_VIELD	RK_CS2,0,<-		; CONTROL STATUS REGISTER 2 FIELD DEFINITIONS
		<DS,3>,-		; DRIVE SELECT
		<RLS,,M>,-		; RELEASE DRIVE
		<BAI,,M>,-		; BUFFER ADDRESS INCREMENT INHIBIT
		<SCLR,,M>,-		; SUBSYSTEM CLEAR
		<IR,,M>,-		; INPUT READY
		<OR,,M>,-		; OUTPUT READY
		<UFE,,M>,-		; UNIT FIELD ERROR
		<MDS,,M>,-		; MULTIPLE DRIVE SELECT
		<PGE,,M>,-		; PROGRAMMING ERROR
		<NEM,,M>,-		; NONEXISTENT MEMORY
		<NED,,M>,-		; NONEXISTENT DRIVE
		<UPE,,M>,-		; UNIBUS PARITY ERROR
		<WCE,,M>,-		; WRITE CHECK ERROR
		<DLT,,M>-		; DATA LATE ERROR
	>				;
$DEF	RK_DS		.BLKW	1	;DRIVE STATUS REGISTER
	_VIELD	RK_DS,0,<-		; DRIVE STATUS REGISTER BIT DEFINTIONS
		<DRA,,M>,-		; DRIVE AVAILABLE
		<,1>,-			; RESERVED BIT
		<OFST,,M>,-		; DRIVE OFFSET
		<ACLO,,M>,-		; DRIVE AC LOW
		<DCLO,,M>,-		; DRIVE DC LOW
		<DROT,,M>,-		; DRIVE OFF TRACK
		<VV,,M>,-		; VOLUME VALID
		<DRDY,,M>,-		; DRIVE READY
		<DDT,,M>,-		; DRIVE DRIVE TYPE
		<,2>,-			; RESERVED BITS
		<WRL,,M>,-		; DRIVE WRITE LOCKED
		<,1>,-			; RESERVED BIT
		<PIP,,M>,-		; POSITIONING IN PROGRESS
		<DSC,,M>,-		; DRIVE STATUS CHANGE
		<SVAL,,M>-		; DRIVE STATUS VALID
	>				;
$DEF	RK_ER		.BLKW	1	;ERROR REGISTER
	_VIELD	RK_ER,0,<-		; ERROR REGISTER BIT DEFINITIONS
		<ILF,,M>,-		; ILLEGAL FUNCTION
		<SKI,,M>,-		; SEEK INCOMPLETE
		<NXF,,M>,-		; NONEXECUTABLE FUNCTION
		<DRPAR,,M>,-		; DRIVE PARITY ERROR
		<FMTE,,M>,-		; FORMAT ERROR
		<DTYE,,M>,-		; DRIVE TYPE ERROR
		<ECH,,M>,-		; ECC HARD ERROR
		<BSE,,M>,-		; BAD SECTOR ERROR
		<HVRC,,M>,-		; HEADER VRC ERROR
		<COE,,M>,-		; CYLINDER OVERFLOW ERROR
		<IDAE,,M>,-		; INVALID DISK ADDRESS ERROR
		<WLE,,M>,-		; WRITE LOCK ERROR
		<DTE,,M>,-		; DRIVE TIMING ERROR
		<OPI,,M>,-		; OPERATION INCOMPLETE
		<UNS,,M>,-		; DRIVE UNSAFE
		<DCK,,M>-		; DATA CHECK ERROR
	>				;
$DEF	RK_AS		.BLKW	1	;ATTENTION SUMMARY/OFFSET REGISTER
	_VIELD	RK_AS,0,<-		; ATTENSION SUMMARY/OFFSET REGISTER FIELDS
		<OF,7>,-		; DRIVE OFFSET
		<,1>,-			; RESERVED BIT
		<ATTN,8,M>-		; DRIVE ATTENTION SUMARY
	>				;
$DEF	RK_DC		.BLKW	1	;DESIRED CYLINDER ADDRESS
$DEF	RK_SPR		.BLKW	1	;UNUSED REGISTER
$DEF	RK_DB		.BLKW	1	;DATA BUFFER REGISTER
$DEF	RK_MR1		.BLKW	1	;MAINTENANCE REGISTER 1
	_VIELD	RK_MR1,0,<<MS,3>>	; MAINTENANCE REGISTER 1 FIELD DEFINITION
$DEF	RK_EC1		.BLKW	1	;ECC POSITION REGISTER
	_VIELD	RK_EC1,0,<<EPS,13>>	; ECC POSITION FIELD
$DEF	RK_EC2		.BLKW	1	;ECC PATTERN REGISTER
	_VIELD	RK_EC2,0,<<EPT,11>>	; ECC PATTERN FIELD
$DEF	RK_MR2		.BLKW	1	;MAINTENANCE REGISTER 2
$DEF	RK_MR3		.BLKW	1	;MAINTENANCE REGISTER 3
 
	$DEFEND	RK
 
;
; SOFTWARE STATUS IN UPPER BYTE OF OFFSET WORD
;
 
	_VIELD	DM,0,<-			;SOFTWARE STATUS BIT DEFINTIONS
		<ECI,,M>,-		; ECC INHIBIT
		<DCK,,M>-		; DATACHECK IN PROGRESS
	>				;
 
;
; DEFINE DEVICE DEPENDENT UNIT CONTROL BLOCK  OFFSETS
;
 
	$DEFINI	UCB
 
.=UCB$W_BCR+2				;
 
$DEF	UCB$W_DM_DTYP	.BLKW	1	;DRIVE TYPE MASK
$DEF	UCB$W_DM_CS1	.BLKW	1	;CONTROL STATUS REGISTER 1
$DEF	UCB$W_DM_WC	.BLKW	1	;WORK COUNT REGISTER
$DEF	UCB$W_DM_BA	.BLKW	1	;BUFFER ADDRESS REGISTER
$DEF	UCB$W_DM_DA	.BLKW	1	;DISK ADDRESS REGISTER
$DEF	UCB$W_DM_CS2	.BLKW	1	;CONTROL STATUS REGISTER 2
$DEF	UCB$W_DM_DS	.BLKW	1	;DRIVE STATUS REGISTER
$DEF	UCB$W_DM_ER	.BLKW	1	;ERROR REGISTER
$DEF	UCB$W_DM_AS	.BLKW	1	;ATTENTION SUMMARY REGISTER
$DEF	UCB$W_DM_DC	.BLKW	1	;DESIRED CYLINDER REGISTER
$DEF	UCB$W_DM_MR1	.BLKW	1	;MAINTENANCE REGISTER 1
$DEF	UCB$W_DM_MR2	.BLKW	1	;MAINTENANCE REGISTER 2
$DEF	UCB$W_DM_MR3	.BLKW	1	;MAINTENANCE REGISTER 3
$DEF	UCB$W_DM_DPN	.BLKW	1	;DATAPATH NUMBER
$DEF	UCB$L_DM_DPR	.BLKL	1	;DATAPATH REGISTER
$DEF	UCB$L_DM_FMPR	.BLKL	1	;FINAL MAP REGISTER
$DEF	UCB$L_DM_PMPR	.BLKL	1	;PREVIOUS MAP REGISTER
$DEF	UCB$W_DM_DB	.BLKW	3	;DATA BUFFER REGISTER
$DEF	UCB$B_DM_IND	.BLKB	1	;SOFTWARE INDICATORS
	_VIELD	DM_IND,0,<-		;INDICATOR BIT DEFINITIONS
		<RR,,M>,-		; RE-READ IN PROGRESS PRIOR TO ECC
		<OF,,M>-		; OFFSET FLAG
	>				; 
$DEF	UCB$L_DM_FRS	.BLKL	1	;FINAL REQUEST STATUS
			.BLKB	1	;SPARE USED BYTE
 
UCB$K_DM_LENGTH=.

	$DEFEND	UCB
 
;
; HARDWARE FUNCTION CODES
;
 
F_NOP=0*2				;NO OPERATION (SELECT DRIVE)
F_UNLOAD=3*2				;UNLOAD DRIVE
F_SEEK=7*2				;SEEK CYLINDER
F_RECAL=5*2				;RECALIBRATE
F_DRVCLR=2*2				;DRIVE CLEAR
F_RELEASE=0*2				;RELEASE DRIVE
F_OFFSET=6*2				;OFFSET HEADS
F_RETCENTER=6*2				;RETURN TO CENTERLINE
F_PACKACK=1*2				;PACK ACKNOWLEDGE
F_STARTSPNDL=4*2			;START SPINDLE
F_WRITECHECK=12*2			;WRITE CHECK DATA
F_WRITEDATA=9*2				;WRITE DATA
F_WRITEHEAD=11*2			;WRITE HEADER AND DATA
F_READDATA=8*2				;READ DATA
F_READHEAD=10*2				;READ HEADER AND DATA
F_AVAILABLE=F_NOP			;DRIVE AVAILABLE (a NOP)
 
;
; LOCAL DATA
;
; DRIVER PROLOGUE TABLE
;
 
	DPTAB	-			;DEFINE DRIVER PROLOGUE TABLE
		END=DM_END,-		;END OF DRIVER
		ADAPTER=UBA,-		;ADAPTER TYPE
		FLAGS=DPT$M_SVP,-	;SYSTEM PAGE TABLE ENTRY REQUIRED
		UCBSIZE=UCB$K_DM_LENGTH,-	;UCB SIZE
		DEFUNITS=8,-		;Default number of AUTOCONFIGURE units
		DELIVER=DM$DELIVER,-	;AUTOCONFIGURE units delivery routine
		NAME=DMDRIVER		;DRIVER NAME
	DPT_STORE INIT			;CONTROL BLOCK INIT VALUES
	DPT_STORE DDB,DDB$L_ACPD,L,<^A\F11\> ;DEFAULT ACP NAME
	DPT_STORE DDB,DDB$L_ACPD+3,B,DDB$K_CART	;ACP CLASS
	DPT_STORE UCB,UCB$B_FIPL,B,8	;FORK IPL
	DPT_STORE UCB,UCB$L_DEVCHAR,L,-	;DEVICE CHARACTERISTICS
		<DEV$M_FOD-		; FILES ORIENTED
		!DEV$M_DIR-		; DIRECTORY STRUCTURED
		!DEV$M_AVL-		; AVAILABLE
		!DEV$M_ELG-		; ERROR LOGGING ENABLED
		!DEV$M_SHR-		; SHAREABLE
		!DEV$M_IDV-		; INPUT DEVICE
		!DEV$M_ODV-		; OUTPUT DEVICE
		!DEV$M_RND>		; RANDOM ACCESS
	DPT_STORE UCB,UCB$B_DEVCLASS,B,DC$_DISK ;DEVICE CLASS
	DPT_STORE UCB,UCB$W_DEVBUFSIZ,W,512 ;DEFAULT BUFFER SIZE
	DPT_STORE UCB,UCB$B_SECTORS,B,22 ;NUMBER OF SECTORS PER TRACK
	DPT_STORE UCB,UCB$B_TRACKS,B,3	;NUMBER OF TRACKS PER CYLINDER
	DPT_STORE UCB,UCB$B_DIPL,B,21	;DEVICE IPL
	DPT_STORE UCB,UCB$B_ERTCNT,B,8	;ERROR RETRY COUNT
	DPT_STORE UCB,UCB$B_ERTMAX,B,8	;MAX ERROR RETRY COUNT
	DPT_STORE REINIT		;CONTROL BLOCK RE-INIT VALUES
	DPT_STORE CRB,CRB$L_INTD+4,D,DM$INT ;INTERRUPT SERVICE ROUTINE ADDRESS
	DPT_STORE CRB,CRB$L_INTD+VEC$L_INITIAL,D,DM_RK611_INIT ;CONTROLLER INIT
	DPT_STORE CRB,CRB$L_INTD+VEC$L_UNITINIT,D,DM_RK0X_INIT ;UNIT INIT
	DPT_STORE DDB,DDB$L_DDT,D,DM$DDT ;DDT ADDRESS
	DPT_STORE END			;
 
;
; DRIVER DISPATCH TABLE
;
 
	DDTAB	DM,-			;DRIVER DISPATCH TABLE
		DM_STARTIO,-		;START I/O OPERATION
		DM_UNSOLNT,-		;UNSOLICITED INTERRUPT
		DM_FUNCTABLE,-		;FUNCTION DECISION TABLE
		0,-			;CANCEL I/O ENTRY POINT
		DM_REGDUMP,-		;REGISTER DUMP ROUTINE
		<<<RK_MR3+2-4+8>*2>+<<3+5+1>*4>>,- ;SIZE OF DIAGNOSTIC BUFFER
		<<<RK_MR3+2-4+8>*2>+<1*4>+<EMB$L_DV_REGSAV>> ;SIZE OF ERROR BUFFER
 
;
; HARDWARE I/O FUNCTION CODE TABLE
;
 
FTAB:					;
	GENF	F_NOP			;NO OPERATION
	GENF	F_UNLOAD		;UNLOAD VOLUME
	GENF	F_SEEK			;SEEK CYLINDER
	GENF	F_RECAL			;RECALIBRATE
	GENF	F_DRVCLR		;DRIVE CLEAR
	GENF	F_RELEASE		;RELEASE PORT
	GENF	F_OFFSET		;OFFSET HEADS
	GENF	F_RETCENTER		;RETURN HEADS TO CENTERLINE
	GENF	F_PACKACK		;PACK ACKNOWLEDGE
	GENF	F_STARTSPNDL		;START SPINDLE
	GENF	F_WRITECHECK		;WRITE CHECK
	GENF	F_WRITEDATA		;WRITE DATA
	GENF	F_READDATA		;READ DATA
	GENF	F_WRITEHEAD		;WRITE HEADERS
	GENF	F_READHEAD		;READ HEADER
	GENF	F_AVAILABLE		;DRIVE AVAILABLE
 
;
; OFFSET TABLE FOR RK611-RK06/RK07
;
 
OFFTAB:					;
	.BYTE	0			;RETURN TO CENTERLINE
	.BYTE	^X10			;+400
	.BYTE	^X90			;-400
	.BYTE	^X20			;+800
	.BYTE	^XA0			;-800
	.BYTE	^X30			;+1200
	.BYTE	^XB0			;-1200
	.BYTE	0			;RETURN TO CENTERLINE
OFFSIZ=.-OFFTAB				;SIZE OF OFFSET TABLE
	.PAGE
	.SBTTL	RK611-RK06/RK07 FUNCTION DECISION TABLE
;+
; RK611-RK06/RK07 FUNCTION DECISION TABLE
;-
 
DM_FUNCTABLE:				;FUNCTION DECISION TABLE
	FUNCTAB	,-			;LEGAL FUNCTIONS
		<NOP,-			;NO OPERATION
		 UNLOAD,-		;UNLOAD VOLUME
		 SEEK,-			;SEEK CYLINDER
		 RECAL,-		;RECALIBRATE
		 DRVCLR,-		;DRIVE CLEAR
		 RELEASE,-		;RELEASE PORT
		 OFFSET,-		;OFFSET HEADS
		 RETCENTER,-		;RETURN HEADS TO CENTERLINE
		 PACKACK,-		;PACK ACKNOWLEDGE
		 AVAILABLE,-		;DRIVE AVAILABLE
		 STARTSPNDL,-		;START SPINDLE
		 SENSECHAR,-		;SENSE CHARACTERISTICS
		 SETCHAR,-		;SET CHARACTERISITCS
		 SENSEMODE,-		;SENSE MODE
		 SETMODE,-		;SET MODE
		 WRITECHECK,-		;WRITE CHECK
		 WRITEHEAD,-		;WRITE HEADERS
		 READHEAD,-		;READ HEADER
		 READLBLK,-		;READ LOGICAL BLOCK
		 WRITELBLK,-		;WRITE LOGICAL BLOCK
		 READPBLK,-		;READ PHYSICAL BLOCK
		 WRITEPBLK,-		;WRITE PHYSICAL BLOCK
		 READVBLK,-		;READ VIRTUAL BLOCK
		 WRITEVBLK,-		;WRITE VIRTUAL BLOCK
		 ACCESS,-		;ACCESS FILE AND/OR FIND DIRECTORY ENTRY
		 ACPCONTROL,-		;ACP CONTROL FUNCTION
		 CREATE,-		;CREATE FILE AND/OR CREATE DIRECTORY ENTRY
		 DEACCESS,-		;DEACCESS FILE
		 DELETE,-		;DELETE FILE AND/OR DIRECTORY ENTRY
		 MODIFY,-		;MODIFY FILE ATTRIBUTES
		 MOUNT>			;MOUNT VOLUME
	FUNCTAB	,-			;BUFFERED I/O FUNCTIONS
		<NOP,-			;NO OPERATION
		 UNLOAD,-		;UNLOAD VOLUME
		 SEEK,-			;SEEK CYLINDER
		 RECAL,-		;RECALIBRATE
		 DRVCLR,-		;DRIVE CLEAR
		 RELEASE,-		;RELEASE PORT
		 OFFSET,-		;OFFSET HEADS
		 RETCENTER,-		;RETURN HEADS TO CENTERLINE
		 PACKACK,-		;PACK ACKNOWLEDGE
		 AVAILABLE,-		;DRIVE AVAILABLE
		 STARTSPNDL,-		;START SPINDLE
		 SENSECHAR,-		;SENSE CHARACTERISTICS
		 SETCHAR,-		;SET CHARACTERISITCS
		 SENSEMODE,-		;SENSE MODE
		 SETMODE,-		;SET MODE
		 ACCESS,-		;ACCESS FILE AND/OR FIND DIRECTORY ENTRY
		 ACPCONTROL,-		;ACP CONTROL FUNCTION
		 CREATE,-		;CREATE FILE AND/OR CREATE DIRECTORY ENTRY
		 DEACCESS,-		;DEACCESS FILE
		 DELETE,-		;DELETE FILE AND/OR DIRECTORY ENTRY
		 MODIFY,-		;MODIFY FILE ATTRIBUTES
		 MOUNT>			;MOUNT VOLUME
	FUNCTAB	DM_BYTECNT,-		;EVEN BYTE COUNT REQUIRED FUNCTIONS
		<READHEAD,-		;READ HEADER
		 READLBLK,-		;READ LOGICAL BLOCK
		 READPBLK,-		;READ PHYSICAL BLOCK
		 READVBLK,-		;READ VIRTUAL BLOCK
		 WRITECHECK,-		;WRITE CHECK
		 WRITEHEAD,-		;WRITE HEADERS
		 WRITELBLK,-		;WRITE LOGICAL BLOCK
		 WRITEPBLK,-		;WRITE PHYSICAL BLOCK
		 WRITEVBLK>		;WRITE VIRTUAL BLOCK
	FUNCTAB	+ACP$READBLK,-		;READ FUNCTIONS
		<READHEAD,-		;READ HEADER
		 READLBLK,-		;READ LOGICAL BLOCK
		 READPBLK,-		;READ PHYSICAL BLOCK
		 READVBLK>		;READ VIRTUAL BLOCK
	FUNCTAB	+ACP$WRITEBLK,-		;WRITE FUNCTIONS
		<WRITECHECK,-		;WRITE CHECK
		 WRITEHEAD,-		;WRITE HEADERS
		 WRITELBLK,-		;WRITE LOGICAL BLOCK
		 WRITEPBLK,-		;WRITE PHYSICAL BLOCK
		 WRITEVBLK>		;WRITE VIRTUAL BLOCK
	FUNCTAB	+ACP$ACCESS,<ACCESS,CREATE> ;ACCESS AND CREATE FILE OR DIRECTORY
	FUNCTAB	+ACP$DEACCESS,<DEACCESS> ;DEACCESS FILE
	FUNCTAB	+ACP$MODIFY,-		;
		<ACPCONTROL,-		;ACP CONTROL FUNCTION
		 DELETE,-		;DELETE FILE OR DIRECTORY ENTRY
		 MODIFY>		;MODIFY FILE ATTRIBUTES
	FUNCTAB	+ACP$MOUNT,<MOUNT>	;MOUNT VOLUME
	FUNCTAB	+EXE$ZEROPARM,-		;ZERO PARAMETER FUNCTIONS
		<NOP,-			;NO OPERATION
		 UNLOAD,-		;UNLOAD VOLUME
		 RECAL,-		;RECALIBRATE
		 DRVCLR,-		;DRIVE CLEAR
		 RELEASE,-		;RELEASE PORT
		 RETCENTER,-		;RETURN HEADS TO CENTERLINE
		 STARTSPNDL,-		;START SPINDLE
		 PACKACK,-		;PACK ACKNOWLEDGE
		 AVAILABLE>		;DRIVE AVAILABLE
	FUNCTAB	+EXE$ONEPARM,-		;ONE PARAMETER FUNCTIONS
		<SEEK,-			;SEEK CYLINDER
		 OFFSET>		;OFFSET HEADS
	FUNCTAB	+EXE$SENSEMODE,-		;
		<SENSECHAR,-		;SENSE CHARACTERISTICS
		 SENSEMODE>		;SENSE MODE
	FUNCTAB	+EXE$SETCHAR,-		;
		<SETCHAR,-		;SET CHARACTERISTICS
		 SETMODE>		;SET MODE
	.PAGE
	.SBTTL	TEST EVEN BYTE COUNT
;+
; DM_BYTECNT - TEST EVEN BYTE COUNT
;
; THIS ROUTINE IS CALLED FROM THE FUNCTION DECISION TABLE DISPATCHER TO CHECK
; THAT THE NUMBER OF BYTES TO BE TRANSFERED IS EVEN AS THE RK611 HAS A WORD
; COUNT RATHER THAN A BYTE COUNT REGISTER.
;
; INPUTS:
;
;	R0 = SCRATCH.
;	R1 = SCRATCH.
;	R2 = SCRATCH.
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R5 = ASSIGNED DEVICE UCB ADDRESS.
;	R6 = ADDRESS OF CCB.
;	R7 = I/O FUNCTION CODE.
;	R8 = FUNCTION DECISION TABLE DISPATCH ADDRESS.
;	R9 = SCRATCH.
;	R10 = SCRATCH.
;	R11 = SCRATCH.
;	AP = ADDRESS OF FIRST FUNCTION DEPENDENT PARAMETER.
;
; OUTPUTS:
;
;	THE BUFFER BYTE COUNT IS CHECKED FOR BEING EQUAL TO 0 MOD 2. IF THE CHECK
;	FAILS, THEN THE I/O OPERATION IS TERMINATED WITH AN ERROR. ELSE A RETURN
;	TO THE FUNCTION DECISION TABLE DISPATCHER IS EXECUTED.
;-
 
DM_BYTECNT:				;
	BBS	#0,4(AP),10$		;IF SET, ODD BYTE COUNT
	RSB				;
10$:	MOVZWL	#SS$_IVBUFLEN,R0	;SET ODD BYTE COUNT STATUS
	JMP	G^EXE$ABORTIO		;
	.PAGE
	.SBTTL	START I/O OPERATION
;+
; STARTIO - START I/O OPERATION ON DEVICE UNIT
;
; THIS ENTRY POINT IS ENTERED TO START AN I/O OPERATION ON A DEVICE UNIT.
;
; INPUTS:
;
;	R3 = ADDRESS OF I/O PACKET.
;	R5 = UCB ADDRESS OF DEVICE UNIT.
;
; OUTPUTS:
;
;	FUNCTION DEPENDENT PARAMETERS ARE STORED IN THE DEVICE UCB, THE ERROR
;	RETRY COUNT IS RESET, AND THE FUNCTION IS EXECUTED. AT FUNCTION COMPLETION
;	THE OPERATION IS TERMINATED THROUGH REQUEST COMPLETE.
;-
 
DM_STARTIO:				;START I/O OPERATION
	MOVB	UCB$B_ERTMAX(R5),UCB$B_ERTCNT(R5) ;INITIALIZE ERROR RETRY COUNT
	MOVW	IRP$W_FUNC(R3),UCB$W_FUNC(R5) ;SAVE FUNCTION CODE AND MODIFIERS
	MOVL	IRP$L_MEDIA(R3),R0	;GET PARAMETER LONGWORD
	CLRB	UCB$B_DM_IND(R5)	;CLEAR SOFTWARE INDICATOR BYTE
 
;
; MOVE FUNCTION DEPENDENT PARAMETERS TO UCB
;
 
10$:	EXTZV	#IRP$V_FCODE,#IRP$S_FCODE,- ;EXTRACT I/O FUNCTION CODE
		IRP$W_FUNC(R3),R1	;
	CMPB	#IO$_SEEK,R1 		;SEEK FUNCTION?
	BEQL	20$			;IF EQL YES
	CMPB	#IO$_RETCENTER,R1	;RETURN HEADS TO CENTERLINE?
	BEQL	30$			;IF EQL YES
	CMPB	#IO$_OFFSET,R1 		;OFFSET FUNCTION?
	BEQL	40$			;IF EQL YES
	MOVL	R0,UCB$W_DA(R5)		;STORE PARAMETER LONGWORD
	CMPB	#IO$_STARTSPNDL,R1	;Check for IO$_STARTSPNDL
	BEQL	16$			;and
	CMPB	#IO$_AVAILABLE,R1	;IO$_AVAILABLE, the two function
	BNEQ	50$			;codes which have different internal
					;values.
	MOVB	#CDF_AVAILABLE,R1	;Map IO$_AVAILABLE to CDF_AVAILABLE.
	BRB	50$
16$:	MOVB	#CDF_STARTSPNDL,R1	;Map IO$_STARTSPNDL to CDF_STARTSPNDL.
	BRB	50$
 
;
; SEEK FUNCTION - SET CYLINDER ADDRESS
;
 
20$:	MOVW	R0,UCB$W_DC(R5)		;SET CYLINDER ADDRESS
	BRB	50$			;
 
;
; RETURN HEADS TO CENTERLINE FUNCTION - CLEAR OFFSET VALUE
;
 
30$:	CLRL	R0			;CLEAR OFFSET VALUE
 
;
; OFFSET FUNCTION - SET CURRENT OFFSET VALUE
;
 
40$:	MOVB	R0,UCB$W_OFFSET(R5)	;SET OFFSET VALUE
	BISB	#DM_IND_M_OF,UCB$B_DM_IND(R5)  ;SET OFFSET FLAG
 
;
; FINISH PREPROCESSING
;
 
50$:	MOVB	R1,UCB$B_FEX(R5)	;SAVE FUNCTION DISPATCH INDEX
	BICW	#UCB$M_ECC!-		;CLEAR ECC CORRECTION MADE AND,
		UCB$M_DIAGBUF,UCB$W_DEVSTS(R5) ;DIAGNOSTIC BUFFER PRESENT
	BBC	#IRP$V_DIAGBUF,IRP$W_STS(R3),FDISPATCH ;IF CLR, NO BUFFER
	BISW	#UCB$M_DIAGBUF,UCB$W_DEVSTS(R5) ;SET DIAGNOSTIC BUFFER PRESENT
 
;
; CENTRAL FUNCTION DISPATCH
;
 
FDISPATCH:				;FUNCTION DISPATCH
	MOVL	UCB$L_IRP(R5),R3	;RETRIEVE ADDRESS OF I/O PACKET
	BBS	#IRP$V_PHYSIO,IRP$W_STS(R3),10$ ;IF SET, PHYSICAL I/O FUNCTION
	BBS	#UCB$V_VALID,UCB$W_STS(R5),10$ ;IF SET, VOLUME SOFTWARE VALID
	MOVZWL	#SS$_VOLINV,R0		;SET VOLUME INVALID STATUS
	BRW	RESETXFR		;
 
;
; UNIT IS SOFTWARE VALID OR FUNCTION IS PHYSICAL I/O
;
 
10$:	CLRB	UCB$W_OFFSET+1(R5)	;CLEAR ECC INHIBIT AND DATACHECK IN PROGRESS
	MOVB	#1,UCB$B_OFFRTC(R5)	;SET INITIAL OFFSET RETRY COUNT
	CLRB	UCB$B_OFFNDX(R5)	;CLEAR INITIAL OFFSET TABLE INDEX
	MOVZBL	UCB$B_FEX(R5),R3	;GET FUNCTION DISPATCH INDEX
	CASE	R3,<-			;DISPATCH TO FUNCTION HANDLING ROUTINE
		NOP,-			;NO OPERATION
		UNLOAD,-		;UNLOAD DRIVE
		SEEK,-			;SEEK CYLINDER
		RECAL,-			;RECALIBRATE
		DRVCLR,-		;DRIVE CLEAR
		RELEASE,-		;RELEASE PORT
		OFFSET,-		;OFFSET HEADS
		RETCENTER,-		;RETURN TO CENTERLINE
		PACKACK,-		;PACK ACKNOWLEDGE
		STARTSPNDL,-		;START SPINDLE
		WRITECHECK,-		;WRITE CHECK DATA
		WRITEDATA,-		;WRITE DATA
		READDATA,-		;READ DATA
		WRITEHEAD,-		;WRITE HEADER
		READHEAD>		;READ HEADER
 
;
; AVAILABLE -- Mark volume not valid
;

AVAILABLE:				;DRIVE AVAILABLE
	BICW	#UCB$M_VALID, UCB$W_STS(R5) ;Mark volume "invalid."
	BRB	NORMAL			;Complete I/O processing.

;
; UNLOAD -- Mark volume not valid
;

UNLOAD:					;UNLOAD DRIVE
	BICW	#UCB$M_VALID, UCB$W_STS(R5) ;Mark volume "invalid."
	BRB	EXEC_FUNCTION		;Do hardware I/O operation.

;
; PACK ACKNOWLEDGE -- Mark volume valid
;

PACKACK:				;PACK ACKNOWLEDGE
	BISW	#UCB$M_VALID, UCB$W_STS(R5) ;Mark volume "valid."
;	BRB	EXEC_FUNCTION		;Do hardware I/O operation.

;
; NO OPERATION, SEEK, RECALIBRATE, DRIVE CLEAR, RELEASE, OFFSET,
; RETURN TO CENTER LINE, AND START SPINDLE
;
 
NOP:					;NO OPERATION
SEEK:					;SEEK CYLINDER
RECAL:					;RECALIBRATE
DRVCLR:					;DRIVE CLEAR
RELEASE:				;RELEASE PORT
OFFSET:					;OFFSET READ HEADS
RETCENTER:				;RETURN TO CENTERLINE
STARTSPNDL:				;START SPINDLE
EXEC_FUNCTION:
	EXFUNCH	10$			;EXECUTE HOUSEKEEPING FUNCTION
	BRB	NORMAL			;
10$:
	BRW	RETRY			; Use BRW since EXFUNCH only allows
					;  for byte offset.
 
;
; WRITE CHECK DATA, WRITE HEADERS, AND READ HEAD
;
 
WRITECHECK:				;WRITE CHECK DATA
WRITEHEAD:				;WRITE HEADERS
READHEAD:				;READ HEADER
	BICW	#IO$M_DATACHECK,UCB$W_FUNC(R5) ;CLEAR DATA CHECK REQUEST
 
;
; WRITE DATA, WRITE CHECK DATA, WRITE HEADERS, AND READ HEADER
;
 
WRITEDATA:				;WRITE DATA
	BISB	#DM_M_ECI,UCB$W_OFFSET+1(R5) ;SET ECC INHIBIT
 
;
; READ DATA, WRITE DATA, WRITE CHECK DATA, WRITE HEADERS, AND READ HEADER
;
 
READDATA:				;READ DATA
	BBS	#IO$V_INHSEEK,UCB$W_FUNC(R5),TRANSFR ;IF SET, NO EXPLICIT SEEK
	EXFUNCH	RETRY,F_SEEK		;SEEK DESIRED CYLINDER
 
;
; DATA TRANSFER
;
 
TRANSFR:				;DATA TRANSFER REQUEST CHANNEL
	MOVZBL	UCB$B_FEX(R5),R3	;GET FUNCTION DISPATCH INDEX
	EXFUNCL	TRANXT			;EXECUTE TRANSFER FUNCTION
 
;
; DATA CHECK
;
 
DATACHECK:				;DATA CHECK
	BBC	#IO$V_DATACHECK,UCB$W_FUNC(R5),NORMAL ;IF CLR, NO DATA CHECK
	MOVZWL	#SS$_WASECC,R0		;ASSUME ECC CORRECTION WAS MADE
	BBS	#UCB$V_ECC,UCB$W_FUNC(R5),CHECKXT ;IF SET, ECC CORRECTION MADE
	MOVB	#DM_M_DCK!-		;SET DATA CHECK IN PROGRESS
		DM_M_ECI,UCB$W_OFFSET+1(R5) ;AND INHIBIT ECC CORRECTION
	MOVB	#1,UCB$B_OFFRTC(R5)	;SET INITIAL OFFSET RETRY COUNT
	CLRB	UCB$B_OFFNDX(R5)	;CLEAR INITIAL OFFSET TABLE INDEX
	MOVL	UCB$L_IRP(R5),R2	;GET ADDRESS OF IRP
	MOVQ	IRP$L_SVAPTE(R2),UCB$L_SVAPTE(R5) ;RESET TRANSFER PARAMETERS
	MOVL	IRP$L_MEDIA(R2),UCB$W_DA(R5) ;
 
;
; DATA CHECK RETRY
;
 
CHECKRETRY:				;DATA CHECK RETRY
	EXFUNCL	TRANXT,F_WRITECHECK	;EXECUTE WRITECHECK FUNCTION
 
;
; SUCCESSFUL OPERATION COMPLETION
;
 
NORMAL:					;
	MOVZWL	S^#SS$_NORMAL,R0	;SET NORMAL COMPLETION STATUS
CHECKXT:				;
	BRW	FUNCXT			;
 
;
; TRANSFER ENDED WITH A RETRIABLE ERROR
;
 
TRANXT:					;TRANSFER EXIT
	CMPB	#CDF_WRITEDATA,UCB$B_CEX(R5) ;WRITE DATA FUNCTION?
	BEQL	RETRY			;IF EQL YES
	CMPB	#CDF_WRITEHEAD,UCB$B_CEX(R5) ;WRITE HEADER FUNCTION?
	BEQL	RETRY			;IF EQL YES
	BITW	#RK_CS1_M_CTO!-		;CONTROLLER TIMEOUT OR,
		RK_CS1_M_DPPE!-		;DATAPATH PURGE ERROR OR,
		RK_CS1_M_SPAR,R1	;SERIAL BUS PARITY ERROR?
	BNEQ	RETRY			;IF NEQ YES
	BITW	#RK_CS2_M_DLT!-		;DATA LATE OR,
		RK_CS2_M_UPE!-		;UNIBUS PARITY ERROR OR,
		RK_CS2_M_NEM!-		;NONEXISTENT MEMORY OR,
		RK_CS2_M_WCE,R2		;WRITE CHECK ERROR?
	BNEQ	RETRY			;IF NEQ YES
	BITW	#RK_ER_M_DRPAR!-	;DRIVE PARITY ERROR OR,
		RK_ER_M_OPI!-		;OPERATION INCOMPLETE OR,
		RK_ER_M_SKI,R3		;SEEK INCOMPLETE?
	BEQL	ECC			;IF EQL NO
RETRY:					;
	BRW	RETRYERR		;RETRIABLE ERROR
 
;
; ECC, DRIVE TIMING, OR HEADER ERROR - APPLY ECC OR PERFORM OFFSET RECOVERY
;
 
ECC:					;ECC CORRECTION
	MOVZWL	UCB$W_BCR(R5),R0	;GET NEGATIVE NUMBER OF BYTES REMAINING
	ADDW	UCB$W_BCNT(R5),R0	;CALCULATE NUMBER OF BYTES TRANSFERED
	MOVL	R0,R1			;COPY NUMBER OF BYTES TRANSFERED
	BEQL	OFF			;IF EQL NONE - PERFORM OFFSET RECOVERY
	BBS	#RK_ER_V_HVRC,R3,10$	;IF SET, HEADER VRC ERROR
	DECL	R0			;SET TO TRUNCATE LAST BLOCK TRANSFERED
10$:	BICW	#^X1FF,R0		;TRUNCATE RESIDUAL BYTES TRANSFERED
	BITW	#RK_ER_M_DTE!-		;DRIVE TIMING ERROR OR,
		RK_ER_M_ECH!-		;ECC HARD ERROR OR,
		RK_ER_M_HVRC,R3		;HEADER VRC ERROR?
	BNEQ	OFF			;IF NEQ YES - PERFORM OFFSET RECOVERY
	BBSC	#DM_IND_V_RR,-		;IF SET, READ JUST RETRIED - APPLY ECC
		UCB$B_DM_IND(R5),15$	;... AND CLEAR RE-READ IN PROGRESS BIT
	JSB	G^IOC$UPDATRANSP	;UPDATE XFER PARAMETERS TO LAST SECTOR
	BBCS	#DM_IND_V_RR,-		;RETRY READ BEFORE APPLYING ECC
		UCB$B_DM_IND(R5),RETRY	;... AND SET RE-READ IN PROGRESS BIT
15$:	PUSHL	R1			;SAVE TOTAL NUMBER OF BYTES TRANSFERRED
	JSB	G^IOC$APPLYECC		;APPLY ECC CORRECTION
	POPL	R0			;RETRIEVE TRANSFERED BYTE COUNT
	JSB	G^IOC$UPDATRANSP	;UPDATE TRANSFER PARAMETERS
	TSTW	UCB$W_BCNT(R5)		;ANY MORE TO TRANSFER?
	BEQL	20$			;IF EQL NO
	BRW	TRANSFR			;TRANSFER NEXT SEGMENT
20$:	BRW	DATACHECK		;CHECK FOR WRITE CHECK
 
;
; OFF - OFFSET RECOVERY
;
; THIS CODE IS EXECUTED WHEN A DRIVE TIMING ERROR, HEADER VRC, OR ECC HARD
; ERROR IS DETECTED ON A READ FUNCTION.
;
 
OFF:					;OFFSET RECOVERY
	BISB	#DM_IND_M_OF,UCB$B_DM_IND(R5)  ;SET OFFSET FLAG
	TSTL	R0			;ANY GOOD DATA TRANSFERED?
	BEQL	10$			;IF EQL NO
 
;
; THE TRANSFER ENDED IN AN ERROR BUT THERE WERE SECTORS TRANSFERED THAT
; CONTAINED GOOD DATA. SINCE THE ERROR COULD HAVE BEEN CAUSED BY A CYLIN-
; DER CROSSING, THE GOOD DATA IS SAVED AND THE TRANSFER IS RETRIED FROM THE
; POINT OF ERROR.
;
 
	JSB	G^IOC$UPDATRANSP	;UPDATE TRANSFER PARAMETERS
	CLRB	UCB$B_OFFNDX(R5)	;RESET OFFSET TABLE INDEX
	BRB	20$			;
 
;
; NO GOOD DATA TRANSFERED - CHECK IF CHANGE IN OFFSET NEEDED
;
 
10$:	DECB	UCB$B_OFFRTC(R5)	;CHANGE CURRENT OFFSET?
	BNEQ	40$			;IF NEQ NO
	MOVB	#2,UCB$B_OFFRTC(R5)	;SET OFFSET RETRY COUNT
20$:	INCB	UCB$B_OFFNDX(R5)	;UPDATE OFFSET TABLE INDEX
	MOVZBL	UCB$B_OFFNDX(R5),R0	;GET NEXT OFFSET TABLE INDEX
	CMPB	#OFFSIZ,R0		;ALL OFFSETS TRIED?
	BEQL	OFFSETERR		;IF EQL YES
	MOVB	OFFTAB-1[R0],UCB$W_OFFSET(R5) ;SET NEXT OFFSET VALUE
	BNEQ	30$			;IF NEQ NOT OFFSET ZERO
	MOVB	#16,UCB$B_OFFRTC(R5)	;SET OFFSET RETRY COUNT
30$:	EXFUNCH	FATALERR,F_OFFSET	;OFFSET TO NEXT POSITION
40$:	BBS	#DM_V_DCK,UCB$W_OFFSET+1(R5),50$ ;IF SET, DATA CHECK FUNCTION
	BRW	TRANSFR			;TRY FUNCTION AGAIN
50$:	BRW	CHECKRETRY		;TRY DATA CHECK AGAIN
 
;
; RETRIABLE ERROR
;
 
RETRYERR:				;RETRIABLE ERROR
	DECB	UCB$B_ERTCNT(R5)	;ANY RETRIES LEFT?
	BEQL	FATALERR		;IF EQL NO
	BITW	#RK_ER_M_OPI!-		;OPERATION INCOMPLETE OR,
		RK_ER_M_SKI,R3		;SEEK INCOMPLETE?
	BEQL	10$			;IF EQL NO
	EXFUNCH	FATALERR,F_RECAL	;RECALIBRATE DRIVE
10$:	BRW	FDISPATCH		;
 
;
; ALL OFFSETS TRIED - RETRIEVE FINAL TRANSFER STATUS
;
 
OFFSETERR:				;OFFSET RECOVERY ERROR
	MOVZWL	UCB$W_DM_CS1(R5),R1	;RETRIEVE CONTROL STATUS REGISTER 1
 
;
; FATAL CONTROLLER/DRIVE ERROR, ERROR RETRY COUNT EXHAUSTED, ERROR RETRY
; INHIBITED, OR FINAL OFFSET TRIED
;
 
FATALERR:				;FATAL ERROR - SET STATUS
	MOVZWL	#SS$_VOLINV,R0		;SET VOLUME INVALID STATUS
	BBC	#RK_DS_V_VV,UCB$W_DM_DS(R5),FUNCXT ;IF CLR, VOLUME INVALID
	MOVZWL	#SS$_UNSAFE,R0		;SET DRIVE UNSAFE STATUS
	BBS	#RK_ER_V_UNS,R3,FUNCXT	;IF SET, DRIVE UNSAFE
	MOVZWL	#SS$_FORMAT,R0		;SET FORMAT ERROR STATUS
	BITW	#RK_ER_M_DTYE!-		;DRIVE TYPE ERROR OR,
		RK_ER_M_FMTE,R3		;FORMAT ERROR?
	BNEQ	FUNCXT			;IF NEQ YES
	MOVZWL	#SS$_WRITLCK,R0		;SET WRITE LOCK ERROR
	BBS	#RK_ER_V_WLE,R3,FUNCXT	;IF SET, WRITE LOCK ERROR
	MOVZWL	#SS$_IVADDR,R0		;SET INVALID DISK ADDRESS STATUS
	BITW	#RK_ER_M_COE!-		;CYLINDER ADDRESS OVERFLOW OR,
		RK_ER_M_IDAE,R3		;INVALID DISK ADDRESS ERROR?
	BNEQ	FUNCXT			;IF NEQ YES
	MOVZWL	#SS$_DRVERR,R0		;SET DRIVE ERROR STATUS
	BITW	#RK_ER_M_DTE!-		;DRIVE TIMING ERROR OR,
		RK_ER_M_ILF!-		;ILLEGAL FUNCTION OR,
		RK_ER_M_NXF!-		;NONEXECUTABLE FUNCTION OR,
		RK_ER_M_OPI!-		;OPERATION INCOMPLETE OR,
		RK_ER_M_SKI,R3		;SEEK INCOMPLETE?
	BNEQ	FUNCXT			;IF NEQ YES
	MOVZWL	#SS$_PARITY,R0		;SET PARITY ERROR STATUS
	BITW	#RK_ER_M_BSE!-		;BAD SECTOR ERROR OR,
		RK_ER_M_DCK!-		;DATA CHECK ERROR OR,
		RK_ER_M_DRPAR!-		;DRIVE PARITY ERROR OR,
		RK_ER_M_ECH!-		;ECC HARD ERROR OR,
		RK_ER_M_HVRC,R3		;HEADER VRC ERROR?
	BNEQ	FUNCXT			;IF NEQ YES
	BITW	#RK_CS1_M_DPPE!-	;DATAPATH PURGE ERROR OR,
		RK_CS1_M_SPAR,R1	;SERIAL BUS PARITY ERROR?
	BNEQ	FUNCXT			;IF NEQ YES
	BBS	#RK_CS2_V_UPE,R2,FUNCXT	;IF SET, UNIBUS PARITY ERROR
	MOVZWL	#SS$_DATACHECK,R0	;SET DATA CHECK ERROR STATUS
	BBS	#RK_CS2_V_WCE,R2,FUNCXT	;IF SET, WRITE CHECK ERROR
	MOVZWL	#SS$_NONEXDRV,R0	;SET NONEXISTENT DRIVE STATUS
	BBS	#RK_CS2_V_NED,R2,FUNCXT	;IF SET, NONEXISTENT DRIVE
	MOVZWL	#SS$_CTRLERR,R0		;SET CONTROLLER ERROR STATUS
 
;
; FUNCTION COMPLETION COMMON EXIT
;
 
FUNCXT:					;FUNCTION EXIT
	MOVL	R0,UCB$L_DM_FRS(R5)	;SAVE FINAL REQUEST STATUS ACROSS RECAL
	JSB	G^IOC$DIAGBUFILL	;FILL DIAGNOSTIC BUFFER IF PRESENT
	CMPB	#CDF_WRITECHECK,UCB$B_FEX(R5) ;DRIVE RELATED FUNCTION?
	BGTRU	10$			;IF GTRU YES
	CMPB	#CDF_AVAILABLE, UCB$B_FEX(R5) ;DRIVE RELATED FUNCTION?
	BEQL	10$			;IF EQL YES
	MOVL	UCB$L_IRP(R5),R3	;RETRIEVE ADDRESS OF IRP
	ADDW3	UCB$W_BCR(R5),-		;CALCULATE AND SAVE BYTES TRANSFERRED
		IRP$W_BCNT(R3),UCB$L_DM_FRS+2(R5)  ;...
10$:	BBCC	#DM_IND_V_OF,UCB$B_DM_IND(R5),20$  ;IF CLEAR, NOT IN OFFSET MODE
	MOVB	#1,UCB$B_ERTCNT(R5)	; Set error retry count to 1 to
					;  prevent a timeout on the following
					;  RECAL from decrementing the count
					;  to a negative number and thereby
					;  triggering a semi-infinite loop.
	EXFUNCH	20$,F_RECAL		;RECALIBRATE DRIVE
20$:	CLRL	R1			;CLEAR SECOND STATUS LONGWORD
	MOVL	UCB$L_DM_FRS(R5),R0	;RETRIEVE FINAL REQUEST STATUS
	REQCOM				;COMPLETE REQUEST
	.PAGE
	.SBTTL	RK611-RK06/RK07 HARDWARE FUNCTION EXECUTION
;
; FEXH - RK611-RK06/RK07 HARDWARE FUNCTION EXECUTION (HIGH PRIORITY)
; FEXL - RK611-RK06/RK07 HARDWARE FUNCTION EXECUTION (LOW PRIORITY)
;
; THIS ROUTINE IS CALLED VIA A BSB WITH A BYTE IMMEDIATELY FOLLOWING THAT
; SPECIFIES THE ADDRESS OF AN ERROR ROUTINE. ALL DATA IS ASSUMED TO HAVE BEEN
; SET UP IN THE UCB BEFORE THE CALL. THE APPROPRIATE PARAMETERS ARE LOADED
; INTO DEVICE REGISTERS AND THE FUNCTION IS INITIATED. THE RETURN ADDRESS
; IS STORED IN THE UCB AND A WAITFOR INTERRUPT IS EXECUTED. WHEN THE INTER-
; RUPT OCCURS, CONTROL IS RETURNED TO THE CALLER.
;
; INPUTS:
;
;	R3 = FUNCTION TABLE DISPATCH INDEX.
;	R4 = ADDRESS OF CONTROL STATUS REGISTER 1.
;	R5 = DEVICE UNIT UCB ADDRESS.
;
;	00(SP) = RETURN ADDRESS OF CALLER.
;	04(SP) = RETURN ADDRESS OF CALLER'S CALLER.
;
;	IMMEDIATELY FOLLOWING INLINE AT THE CALL SITE IS A BYTE WHICH CONTAINS
;	A BRANCH DESTINATION TO AN ERROR RETRY ROUTINE.
;
; OUTPUTS:
;
;	THERE ARE FOUR EXITS FROM THIS ROUTINE:
;
;	1. SPECIAL CONDITION - THIS EXIT IS TAKEN IF A POWER FAILURE OCCURS
;		OR THE OPERATION TIMES OUT. IT IS A JUMP TO THE APPROPRIATE
;		ERROR ROUTINE.
;
;	2. FATAL ERROR - THIS EXIT IS TAKEN IF A FATAL CONTROLLER OR DRIVE
;		ERROR OCCURS OR IF ANY ERROR OCCURS AND ERROR RETRY IS
;		INHIBITED. IT IS A JUMP TO THE FATAL ERROR EXIT ROUTINE.
;
;	3. RETRIABLE ERROR - THIS EXIT IS TAKEN IF A RETRIABLE CONTROLLER
;		OR DRIVE ERROR OCCURS AND ERROR RETRY IS NOT INHIBITED.
;		IT CONSISTS OF TAKING THE ERROR BRANCH EXIT.
;
;	4. SUCCESSFUL OPERATION - THIS EXIT IS TAKEN IF NO ERROR OCCURS
;		DURING THE OPERATION. IT CONSISTS OF A RETURN INLINE.
;
;	IN ALL CASES IF AN ERROR OCCURS, AN ATTEMPT IS MADE TO LOG THE ERROR.
;
;	IN ALL CASES FINAL DRIVE AND CONTROLLER REGISTERS ARE RETURNED VIA
;	THE GENERAL REGISTERS R1, R2, AND R3, AND THE UCB.
;
;	R1 = CONTROL STATUS REGISTER 1.
;	R2 = CONTROL STATUS REGISTER 2.
;	R3 = ERROR REGISTER.
;
;	UCB$W_EC1(R5) = ECC POSITION REGISTER.
;	UCB$W_EC2(R5) = ECC PATTERN REGISTER.
;	UCB$W_BCR(R5) = BYTE COUNT REGISTER.
;
 
	.ENABL	LSB
FEXH:					;FUNCTION EXECUTOR (HIGH PRIORITY)
	MOVAB	G^IOC$REQPCHANH,R2	;SET ADDRESS OF REQUEST CHANNEL ROUTINE
	BRB	10$			;
FEXL:					;FUNCTION EXECUTOR (LOW PRIORITY)
	MOVAB	G^IOC$REQPCHANL,R2	;SET ADDRESS OF REQUEST CHANNEL ROUTINE
10$:	POPL	UCB$L_DPC(R5)		;SAVE DRIVER PC VALUE
	MOVB	R3,UCB$B_CEX(R5)	;SAVE CASE INDEX
	JSB	(R2)			;REQUEST CHANNEL
	MOVZWL	UCB$W_UNIT(R5),R2	;GET DEVICE UNIT NUMBER
	CASE	R3,<-			;DISPATCH TO PROPER FUNCTION ROUTINE
		IMMED,-			;NO OPERATION
		IMMED,-			;UNLOAD VOLUME
		POSIT,-			;SEEK CYLINDER
		POSIT,-			;RECALIBRATE
		IMMED,-			;DRIVE CLEAR
		RELES,-			;RELEASE DRIVE
		POSIT,-			;OFFSET HEADS
		POSIT,-			;RETURN TO CENTERLINE
		IMMED,-			;PACK ACKNOWLEDGE
		IMMED,-			;START SPINDLE
		>			;
	BRW	XFER			;TRANSFER FUNCTION
	.DSABL	LSB
 
;
; IMMEDIATE FUNCTION EXECUTION
;
;	FUNCTIONS INCLUDE:
;
;		NO OPERATION,
;		UNLOAD VOLUME,
;		DRIVE CLEAR,
;		RELEASE PORT,
;		PACK ACKNOWLEDGE, AND
;		START SPINDLE.
;
; INTERRUPTS ARE LOCKED OUT, THE APPROPRIATE FUNCTION IS INITIATED WITH
; INTERRUPT ENABLE, AND A WAITFOR INTERRUPT AND KEEP CHANNEL IS EXECUTED.
;
; THESE FUNCTIONS ALL EXECUTE WITHIN A VERY SHORT TIME (15 US), BUT ARE
; VERY INFREQUENT AND THEREFORE ARE DONE WITH INTERRUPTS TO AVOID AN EXTRA
; SET OF REGISTER SAVE LOGIC.
;
 
RELES:					;RELEASE PORT
	BISW	#RK_CS2_M_RLS,R2	;SET PORT RELEASE BIT
IMMED:					;IMMEDIATE FUNCTION EXECUTION
	DSBINT				;DISABLE INTERRUPTS
	BBC	#UCB$V_POWER,UCB$W_STS(R5),10$ ;IF CLR, POWER HAS NOT FAILED
	BRW	ENBXIT			;ELSE, POWER HAS FAILED
10$:	MOVW	R2,RK_CS2(R4)		;SET UNIT NUMBER
	BISW3	UCB$W_DM_DTYP(R5),FTAB[R3],RK_CS1(R4) ;EXECUTE FUNCTION
	WFIKPCH	RLSCHN,#2		;WAITFOR INTERRUPT
	IOFORK				;CREATE FORK PROCESS
	BRW	RLSCHN			;
 
;
; POSITIONING FUNCTION EXECUTION
;
;	FUNCTIONS INCLUDE:
;
;		SEEK CYLINDER,
;		RECALIBRATE,
;		OFFSET HEADS, AND
;		RETURN HEADS TO CENTERLINE.
;
; THE OFFSET REGISTER AND CYLINDER ADDRESS REGISTERS ARE LOADED, INTERRUPTS
; ARE LOCKED OUT, AND THE APPROPRIATE POSITIONING FUNCTION IS INITIATED
; WITHOUT INTERRUPT ENABLE. THE CONTROLLER IS THEN POLLED FOR READY, DEVICE
; INTERRUPTS ARE ENABLED, AND A WAITFOR INTERRUPT AND RELEASE CHANNEL IS
; EXECUTED.
;
 
POSIT:					;POSITIONING FUNCTION
	DSBINT				;DISABLE INTERRUPTS
	BBS	#UCB$V_POWER,UCB$W_STS(R5),ENBXIT ;IF SET, POWER HAS FAILED
	MOVW	UCB$W_OFFSET(R5),RK_AS(R4) ;SET OFFSET VALUE
	MOVW	UCB$W_DC(R5),RK_DC(R4)	;SET DESIRED CYLINDER ADDRESS
	MOVW	R2,RK_CS2(R4)		;SET UNIT NUMBER
	BISW3	UCB$W_DM_DTYP(R5),FTAB[R3],RK_CS1(R4) ;EXECUTE FUNCTION
	BSBW	DM_WAIT			;WAIT FOR FUNCTION TO COMPLETE
	WFIRLCH	RETREG,#6		;WAITFOR INTERRUPT
5$:
	DSBINT				;DISABLE INTERRUPTS
	BBS	#UCB$V_POWER,UCB$W_STS(R5),10$ ;IF SET, POWER FAILURE
	MOVW	UCB$W_UNIT(R5),RK_CS2(R4) ;SET UNIT NUMBER
	BISW3	UCB$W_DM_DTYP(R5),#F_NOP!1,RK_CS1(R4) ;SELECT DRIVE TO GET STATUS
	BSBW	DM_WAIT			;WAIT FOR CONTROLLER READY
	BITW	#RK_DS_M_DSC,RK_DS(R4)	;OPERATION COMPLETE?
	BNEQ	10$			;BR IF YES
	WFIKPCH	RETREG,#6		;WAITFOR INTERRUPT
	BRB	5$			;
10$:	ENBINT				;ENABLE INTERRUPTS
20$:	IOFORK				;CREATE FORK PROCESS
	BRW	RETREG			;
ENBXIT:					;
	ENBINT				;
	BRW	RLSCHN			;
 
;
; TRANSFER FUNCTION EXECUTION
;
;	FUNCTIONS INCLUDE:
;
;		WRITE CHECK,
;		WRITE DATA,
;		WRITE HEADERS,
;		READ DATA, AND
;		READ HEADER.
;
; A UNIBUS DATAPATH IS REQUESTED FOLLOWED BY THE APPROPRIATE NUMBER OF MAP
; REGISTERS REQUIRED FOR THE TRANSFER. THE TRANSFER PARAMETERS ARE LOADED  
; INTO THE DEVICE REGISTERS, INTERRUPTS ARE LOCKED OUT, THE FUNCTION IS
; INITIATED, AND A WAITFOR INTERRUPT AND KEEP CHANNEL IS EXECUTED.
;
 
XFER:					;TRANSFER FUNCTION EXECUTION
	REQDPR				;REQUEST DATAPATH
	REQMPR				;REQUEST MAP REGISTERS
	LOADUBA				;LOAD UNIBUS MAP REGISTERS
	MOVZWL	UCB$W_BCNT(R5),R0	;GET TRANSFER BYTE COUNT
	DIVL	#2,R0			;CALCULATE TRANSFER WORD COUNT
	DSBINT	UCB$B_DIPL(R5)		;DISABLE DEVICE INTERRUPTS
	MNEGW	R0,RK_WC(R4)		;SET TRANSFER WORD COUNT
	MOVZWL	UCB$W_BOFF(R5),R0	;GET BYTE OFFSET IN PAGE
	MOVL	UCB$L_CRB(R5),R1	;GET ADDRESS OF CRB
	INSV	CRB$L_INTD+VEC$W_MAPREG(R1),#9,#7,R0 ;INSERT HIGH 7 BITS OF ADDRESS
	MOVW	R0,RK_BA(R4)		;SET BUFFER ADDRESS
	EXTZV	#7,#2,CRB$L_INTD+VEC$W_MAPREG(R1),R0 ;GET MEMORY EXTENSION BITS
	ASHL	#8,R0,R0		;SHIFT LEFT ONE BYTE
	BISW	FTAB[R3],R0		;MERGE FUNCTION CODE
	MOVW	UCB$W_DA(R5),RK_DA(R4)	;SET DESIRED TRACK AND SECTOR ADDRESS
	MOVW	UCB$W_DC(R5),RK_DC(R4)	;SET DESIRED CYLINDER ADDRESS
	MOVW	UCB$W_UNIT(R5),RK_CS2(R4) ;SET UNIT NUMBER
	SETIPL	#31			;DISABLE INTERRUPTS
	BBC	#UCB$V_POWER,UCB$W_STS(R5),10$ ;IF CLR, NO POWER FAILURE
	ENBINT				;ENABLE INTERRUPTS
	BRW	60$			;
10$:	BISW3	UCB$W_DM_DTYP(R5),R0,RK_CS1(R4) ;EXECUTE FUNCTION
	WFIKPCH	60$,#6			;WAITFOR INTERRUPT AND KEEP CHANNEL
	IOFORK				;CREATE FORK PROCESS
	PURDPR				;PURGE DATAPATH, CHECK/CLEAR ERRORS
	BLBS	R0,20$			;BRANCH IF NO DATAPATH ERROR
	BISW	#RK_CS1_M_CERR!-	;SET CONTROLLER ERROR AND,
		RK_CS1_M_DPPE,UCB$W_DM_CS1(R5) ;DATAPATH PURGE ERROR
	CLRW	UCB$W_DM_CS2(R5)	;CLEAR CONTROL STATUS REGISTER 2
	CLRW	UCB$W_DM_ER(R5)		;CLEAR ERROR REGISTER
	BICW	#^C<RK_DS_M_VV>,UCB$W_DM_DS(R5) ;CLEAR ALL BUT VOLUME VALID
20$:	BBS	#RK_CS1_V_CERR,UCB$W_DM_CS1(R5),30$ ;IF SET , DEVICE ERRORS
	BBC	#UCB$V_DIAGBUF,UCB$W_DEVSTS(R5),40$ ;IF CLR, NO DIAGNOSTIC BUFFER
30$:	EXTZV	#VEC$V_DATAPATH,-	;EXTRACT DATAPATH #
		#VEC$S_DATAPATH,-	; FROM CRB AND SAVE IT
		CRB$L_INTD+VEC$B_DATAPATH(R3),-
		UCB$W_DM_DPN(R5)	;
	MOVL	R1,UCB$L_DM_DPR(R5)	;SAVE DATAPATH REGISTER CONTENTS
	EXTZV	#9,#7,UCB$W_DM_BA(R5),R0 ;GET LOW BITS OF FINAL
					; MAP REGISTER NUMBER
	INSV	UCB$W_DM_CS1+1(R5),#7,#2,R0 ;INSERT HIGH BITS OF FINAL MAP REGISTER
	CMPW	#495,R0			;LEGAL MAP REGISTER NUMBER?
	BGEQ	35$			;IF GEQ YES
	MOVZWL	#495,R0			;RESTRICT MAP REGISTER NUMBER
35$:	MOVL	(R2)[R0],UCB$L_DM_FMPR(R5) ;SAVE FINAL MAP REGISTER
	CLRL	UCB$L_DM_PMPR(R5)	;CLEAR PREVIOUS MAP REGISTER CONTENTS
	DECL	R0			;CALCULATE PREVIOUS MAP REGISTER NUMBER
	CMPV	#VEC$V_MAPREG,#VEC$S_MAPREG,- ;ANY PREVIOUS MAP REGISTER?
		CRB$L_INTD+VEC$W_MAPREG(R3),R0 ;
	BGTR	40$			;IF GTR NO
	MOVL	(R2)[R0],UCB$L_DM_PMPR(R5) ;SAVE PREVIOUS MAP REGISTER
40$:	MULW3	#2,UCB$W_DM_WC(R5),UCB$W_BCR(R5) ;CONVERT WD TO BYTE COUNT
	BBS	#RK_CS1_V_CERR,UCB$W_DM_CS1(R5),60$ ;IF SET, DEVICE ERRORS
	CMPB	#CDF_READHEAD,UCB$B_CEX(R5) ;READ HEADER FUNCTION?
	BNEQ	60$			;IF NEQ NO
	PUSHL	UCB$L_SVAPTE(R5)	;SAVE ADDRESS OF PTE
	MOVAB	UCB$W_DM_DB(R5),R1	;SET ADDRESS OF INTERNAL BUFFER
	MOVL	#6,R2			;SET NUMBER OF BYTES TO MOVE
	CMPW	R2,UCB$W_BCNT(R5)	;ROOM FOR FULL HEADER?
	BLSSU	50$			;IF LSSU YES
	MOVZWL	UCB$W_BCNT(R5),R2	;SET LENGTH OF PARTIAL HEADER
50$:	SUBW3	UCB$W_BCNT(R5),R2,UCB$W_BCR(R5) ;CALCULATE TRANSFER BYTE COUNT
	JSB	G^IOC$MOVTOUSER		;MOVE HEADER TO USER BUFFER
	POPL	UCB$L_SVAPTE(R5)	;RESTORE ADDRESS OF PTE
60$:	SETIPL	UCB$B_FIPL(R5)		;INSURE PROPER IPL FOR RELEASE
	RELDPR				;RELEASE DATA PATH
	RELMPR				;RELEASE MAP REGISTERS
RLSCHN:					;
	RELCHAN				;RELEASE CHANNEL
 
;
; RETURN REGISTERS
;
 
	.ENABL	LSB
RETREG:					;RETURN FINAL DEVICE REGISTERS
	MOVZWL	UCB$W_DM_CS1(R5),R1	;RETRIEVE CONTROL STATUS REGISTER 1
	MOVZWL	UCB$W_DM_CS2(R5),R2	;RETRIEVE CONTROL STATUS REGISTER 2
	MOVZWL	UCB$W_DM_ER(R5),R3	;RETRIEVE ERROR REGISTER
	BITW	#UCB$M_POWER!-		;POWER FAIL OR DEVICE TIMEOUT?
		UCB$M_TIMOUT,UCB$W_STS(R5) ;
	BNEQ	30$			;IF NEQ YES - SPECIAL CONDITION
	BBC	#RK_CS1_V_CERR,R1,10$	;IF CLR, NO ERRORS
	CMPB	#CDF_WRITECHECK,UCB$B_CEX(R5) ;DRIVE RELATED FUNCTION?
	BLEQU	5$			;IF LEQU NO
	MNEGW	UCB$W_BCNT(R5),UCB$W_BCR(R5) ;RESET BYTE COUNT - NO TRANSFER
5$:
	JSB	G^ERL$DEVICERR		;ALLOCATE AND FILL ERROR MESSAGE BUFFER
	BBS	#IO$V_INHRETRY,UCB$W_FUNC(R5),20$ ;IF SET, RETRY INHIBITED
	BITW	#RK_CS2_M_MDS!-		;MULTIPLE DRIVE SELECT OR,
		RK_CS2_M_NED!-		;NONEXISTENT DISK OR,
		RK_CS2_M_PGE!-		;PROGRAMMING ERROR OR,
		RK_CS2_M_UFE,R2		;UNIT FIELD ERROR?
	BNEQ	20$			;IF NEQ YES
	BITW	#RK_ER_M_BSE!-		;BAD SECTOR ERROR OR,
		RK_ER_M_COE!-		;CYLINDER ADDRESS OVERFLOW OR,
		RK_ER_M_DTYE!-		;DRIVE TYPE ERROR OR,
		RK_ER_M_FMTE!-		;FORMAT ERROR OR,
		RK_ER_M_IDAE!-		;INVALID DISK ADDRESS ERROR OR,
		RK_ER_M_ILF!-		;ILLEGAL FUNCTION OR,
		RK_ER_M_NXF!-		;NONEXECUTABLE FUNCTION OR,
		RK_ER_M_UNS!-		;DRIVE UNSAFE OR,
		RK_ER_M_WLE,R3		;WRITE LOCK ERROR?
	BNEQ	20$			;IF NEQ YES
	BBC	#RK_DS_V_VV,UCB$W_DM_DS(R5),20$ ;IF CLR, VOLUME INVALID
 
;
; RETRIABLE ERROR EXIT
;
 
	CVTBL	@UCB$L_DPC(R5),-(SP)	;GET BRANCH DISPLACEMENT
	ADDL	(SP)+,UCB$L_DPC(R5)	;CALCULATE RETURN ADDRESS - 1
10$:	INCL	UCB$L_DPC(R5)		;ADJUST TO CORRECT RETURN ADDRESS
	JMP	@UCB$L_DPC(R5)		;RETURN TO DRIVER
 
;
; FATAL CONTROLLER OR DRIVE ERROR EXIT
;
 
20$:	BRW	FATALERR		;
 
;
; SPECIAL CONDITION (POWER FAILURE OR DEVICE TIME OUT)
;
 
30$:	BBSC	#UCB$V_POWER,UCB$W_STS(R5),50$ ;IF SET, POWER FAILURE
 
;
; DEVICE TIME OUT
;
 
	JSB	G^ERL$DEVICTMO		;LOG DEVICE TIME OUT
	MOVL	UCB$L_CRB(R5),R3	;GET ADDRESS OF CRB
	MOVL	CRB$L_INTD+VEC$L_IDB(R3),R3 ;GET ADDRESS OF IDB
	CMPL	R5,IDB$L_OWNER(R3)	;DEVICE OWN CONTROLLER?
	BNEQ	40$			;IF NEQ NO
	MOVW	#RK_CS2_M_SCLR,RK_CS2(R4) ;CLEAR ENTIRE RK611 SUBSYSTEM
	MOVZBW	#RK_CS1_M_IE,RK_CS1(R4)	;ENABLE DEVICE INTERRUPTS
40$:	SETIPL	UCB$B_FIPL(R5)		;LOWER TO FORK LEVEL

	BBS	#RK_DS_M_DRDY,-
		UCB$W_DM_DS(R5),45$	;BR. IF DEVICE READY
	MOVZWL	#SS$_MEDOFL,R0		;RETURN MEDIUM OFFLINE ERROR
	BRB	RESETXFR		;EXIT WITHOUT RETRY

45$:	MOVZWL	#SS$_TIMEOUT,R0		;SET DEVICE TIMEOUT STATUS
	DECB	UCB$B_ERTCNT(R5)	;ANY ERROR RETRIES REMAINING?
	BEQL	RESETXFR		;IF EQL NO
	RELCHAN				;RELEASE CHANNEL IF OWNED
	BICW	#UCB$M_TIMOUT,UCB$W_STS(R5) ;CLEAR TIME OUT STATUS
	BRW	FDISPATCH		;
 
;
; RESET TRANSFER BYTE COUNT TO ZERO
;
 
RESETXFR:				;
	MOVL	UCB$L_IRP(R5),R3	;RETRIEVE ADDRESS OF I/O PACKET
	MNEGW	IRP$W_BCNT(R3),UCB$W_BCR(R5) ;RESET TRANSFER BYTE COUNT
	BRW	FUNCXT			;
 
;
; POWER FAILURE
;
 
50$:	RELCHAN				;RELEASE CHANNEL IF OWNED
	MOVL	UCB$L_IRP(R5),R3	;RETRIEVE ADDRESS OF I/O PACKET
	MOVQ	IRP$L_SVAPTE(R3),UCB$L_SVAPTE(R5) ;RESTORE TRANSFER PARAMETERS
	BRW	DM_STARTIO		;
	.DSABL	LSB
	.PAGE
	.SBTTL	RK611-RK06/RK07 CLASSIFY DRIVE TYPE AND SET PARAMETERS
;
; DM_DTYPE - RK611-RK06/RK07 CLASSIFY DRIVE TYPE AND SET PARAMETERS
;
; THIS ROUTINE IS CALLED WHEN AN UNSOLICITED INTERRUPT OCCURS ON A DRIVE, DURING
; SYSTEM INITIALIZATION, AND AT POWER RECOVERY TO DETERMINE THE DRIVE TYPE AND
; SET UNIT PARAMETERS.
;
; INPUTS:
;
;	R4 = ADDRESS OF CONTROL STATUS REGISTER 1.
;	R5 = DEVICE UNIT UCB ADDRESS.
;
; OUTPUTS:
;
;	THE DRIVE STATUS REGISTER IS INTERROGATED AND UNIT PARAMETERS ARE SET.
;
 
DM_DTYPE:				;CLASSIFY DRIVE TYPE AND SET UNIT PARAMETERS
	MOVB	S^#DT$_RK06,UCB$B_DEVTYPE(R5) ;SET RK06 DEVICE TYPE
	MOVW	#411,UCB$W_CYLINDERS(R5) ;SET NUMBER OF RK06 CYLINDERS
	MOVZWL	#411*3*22,UCB$L_MAXBLOCK(R5) ;SET MAXIMUM BLOCK NUMBER
	CLRW	UCB$W_DM_DTYP(R5)	;SET RK06 CONTROLLER DRIVE TYPE
	BITW	#RK_DS_M_DDT,RK_DS(R4)	;RK06 DRIVE?
	BEQL	10$			;IF EQL YES
	MOVB	S^#DT$_RK07,UCB$B_DEVTYPE(R5) ;SET RK07 DEVICE TYPE
	MOVW	#815,UCB$W_CYLINDERS(R5) ;SET NUMBER OF RK07 CYLINDERS
	MOVZWL	#815*3*22,UCB$L_MAXBLOCK(R5) ;SET MAXIMUM BLOCK NUMBER
	BISW	#RK_CS1_M_CDT,UCB$W_DM_DTYP(R5) ;SET RK07 CONTROLLER DRIVE TYPE
10$:	RSB				;
	.PAGE
	.SBTTL	RK611-RK06/RK07 REGISTER DUMP ROUTINE
;
; DM_REGDUMP - RK611-RK06/RK07 REGISTER DUMP ROUTINE
;
; THIS ROUTINE IS CALLED TO SAVE THE CONTROLLER AND DRIVE REGISTERS IN A
; SPECIFIED BUFFER. IT IS CALLED FROM THE DEVICE ERROR LOGGING ROUTINE AND
; FROM THE DIAGNOSTIC BUFFER FILL ROUTINE.
;
; INPUTS:
;
;	R0 = ADDRESS OF REGISTER SAVE BUFFER.
;	R4 = ADDRESS OF CONTROL STATUS REGISTER 1.
;	R5 = DEVICE UNIT UCB ADDRESS.
;
; OUTPUTS:
;
;	THE CONTROLLER AND DRIVE REGISTERS ARE SAVED IN THE SPECIFIED BUFFER.
;
 
DM_REGDUMP:				;RK611-RK06/RK07 REGISTER DUMP ROUTINE
	MOVL	#<RK_MR3+2-4+8>/2,(R0)+	;INSERT NUMBER OF DEVICE REGISTERS
	MOVAL	UCB$W_DM_CS1(R5),R1	;GET ADDRESS OF SAVED DEVICE REGISTERS
	MOVL	#<RK_MR1+2-4>/2,R2	;SET NUMBER OF REGISTERS TO MOVE
10$:	MOVZWL	(R1)+,(R0)+		;MOVE REGISTER TO BUFFER
	SOBGTR	R2,10$			;ANY MORE TO MOVE?
	MOVZWL	UCB$W_EC1(R5),(R0)+	;INSERT ECC POSITION REGISTER
	MOVZWL	UCB$W_EC2(R5),(R0)+	;INSERT ECC PATTERN REGISTER
	MOVZWL	(R1)+,(R0)+		;INSERT MAINTENANCE REGISTER 2
	MOVZWL	(R1)+,(R0)+		;INSERT MAINTENANCE REGISTER 3
	MOVZWL	(R1)+,(R0)+		;INSERT DATAPATH NUMBER
	MOVL	(R1)+,(R0)+		;INSERT DATAPATH REGISTER
	MOVL	(R1)+,(R0)+		;INSERT FINAL MAP REGISTER
	MOVL	(R1),(R0)+		;INSERT PREVIOUS MAP REGISTER
	RSB				;
	.PAGE
	.SBTTL	RK06/RK07 DISK DRIVE INITIALIZATION
;
; DM_RK0X_INIT - RK06/RK07 DISK DRIVE INITIALIZATION
;
; THIS ROUTINE IS CALLED AT SYSTEM INITIALIZATION AND AT POWER RECOVERY TO SET
; DRIVE PARAMETERS AND TO WAIT FOR ONLINE DRIVES TO SPIN UP.
;
; INPUTS:
;
;	R4 = ADDRESS OF CONTROL STATUS REGISTER 1.
;	R5 = DEVICE UNIT UCB ADDRESS.
;
; OUTPUTS:
;
;	UNIT PARAMETERS ARE ESTABLISHED AND THE DRIVE IS SPUN UP IF IT WAS ONLINE.
;
 
DM_RK0X_INIT:				;RK06/RK07 UNIT INITIALIZATION
	MOVW	#RK_CS1_M_CERR,RK_CS1(R4) ;CLEAR CONTROLLER ERRORS
	MOVW	UCB$W_UNIT(R5),RK_CS2(R4) ;SET UNIT NUMBER
	MOVW	#F_DRVCLR!1,RK_CS1(R4)	;CLEAR DRIVE AND OBTAIN STATUS
	BSBW	DM_WAIT			;WAIT FOR FUNCTION TO COMPLETE
	BSBW	DM_DTYPE		;CLASSIFY DRIVE TYPE
	MOVZWL	UCB$W_STS(R5),R3	;SAVE CURRENT UNIT STATUS
	BICW	#UCB$M_ONLINE!UCB$M_VALID,UCB$W_STS(R5) ;SET UNIT OFFLINE/INVALID
	BITW	#RK_CS2_M_NED,RK_CS2(R4) ;NONEXISTENT DISK?
	BNEQ	50$			;IF NEQ YES
	BISW	#UCB$M_ONLINE,UCB$W_STS(R5) ;SET UNIT ONLINE
	BBC	#UCB$V_VALID,R3,40$	;IF CLR, VOLUME SOFTWARE INVALID
10$:	MOVW	#RK_CS1_M_CERR,RK_CS1(R4) ;CLEAR CONTROLLER ERRORS
	MOVW	UCB$W_UNIT(R5),RK_CS2(R4) ;SET UNIT NUMBER
	BISW3	UCB$W_DM_DTYP(R5),#F_DRVCLR!1,RK_CS1(R4) ;CLEAR DRIVE
	BSBW	DM_WAIT			;WAIT FOR FUNCTION TO COMPLETE
	BITW	#RK_CS1_M_CERR,RK_CS1(R4) ;ANY CONTROLLER ERRORS?
	BNEQ	20$			;IF NEQ YES
	BITW	#RK_DS_M_DRDY,RK_DS(R4)	;DRIVE READY?
	BNEQ	30$			;IF NEQ YES
20$:	JSB	G^EXE$PWRTIMCHK		;CHECK FOR MAXIMUM TIME EXCEEDED
	BLBS	R0,10$			;IF LBS MORE TIME TO GO
	BRB	40$			;
30$:	BISW3	UCB$W_DM_DTYP(R5),#F_PACKACK!1,RK_CS1(R4) ;ACKNOWLEDGE PACK
	BSBW	DM_WAIT			;WAIT FOR FUNCTION TO COMPLETE
	BITW	#RK_CS1_M_CERR,RK_CS1(R4) ;ANY CONTROLLER ERRORS?
	BNEQ	40$			;IF NEQ YES
	BISW	#UCB$M_VALID,UCB$W_STS(R5) ;SET VOLUME SOFTWARE VALID
40$:	MOVW	#RK_CS1_M_CERR,RK_CS1(R4) ;CLEAR CONTROLLER ERRORS
	MOVW	UCB$W_UNIT(R5),RK_CS2(R4) ;SET UNIT NUMBER
	BISW3	UCB$W_DM_DTYP(R5),#F_DRVCLR!1,RK_CS1(R4) ;CLEAR DRIVE
	BSBW	DM_WAIT			;WAIT FOR FUNCTION TO COMPLETE
50$:	MOVW	#RK_CS1_M_CERR,RK_CS1(R4) ;CLEAR CONTROLLER ERRORS
	MOVZBW	#RK_CS1_M_IE,RK_CS1(R4)	;ENABLE DEVICE INTERRUPTS
	RSB				;
	.PAGE
	.SBTTL	RK611-RK06/RK07 UNSOLICITED INTERRUPT ROUTINE
;
; DM_UNSOLNT - RK611-RK06/RK07 UNSOLICITED INTERRUPT ROUTINE
;
; THIS ROUTINE IS CALLED WHEN AN UNSOLICITED ATTENTION CONDITION IS DETECTED FOR
; AN RK06 OR RK07 DRIVE.
;
; INPUTS:
;
;	R4 = ADDRESS OF CONTROL STATUS REGISTER 1.
;	R5 = DEVICE UNIT UCB ADDRESS.
;
; OUTPUTS:
;
;	IF VOLUME VALID IS CLEAR, THEN SOFTWARE VOLUME VALID IS CLEARED. THE
;	UNIT STATUS IS CHANGED TO ONLINE AND THE DRIVE TYPE AND PARAMETERS ARE
;	CLASSIFIED.
;
 
DM_UNSOLNT:				;RK611-RK06/RK07 UNSOLICITED INTERRUPT
	BISW	#UCB$M_ONLINE,UCB$W_STS(R5) ;SET UNIT ONLINE
	BSBW	DM_DTYPE		;CLASSIFY DRIVE TYPE
	BBC	#UCB$V_VALID,UCB$W_STS(R5),10$ ;IF CLR, VOLUME SOFTWARE INVALID
	BITW	#RK_DS_M_VV,RK_DS(R4)	;VOLUME VALID?
	BNEQ	10$			;IF NEQ YES
	BICW	#UCB$M_VALID,UCB$W_STS(R5) ;CLEAR SOFTWARE VOLUME VALID
10$:	RSB				;
	.PAGE
	.SBTTL	WAIT FOR CONTROLLER READY
;
; DM_WAIT - WAIT FOR CONTROLLER READY
;
; THIS SUBROUTINE IS CALLED TO POLL THE RK611 CONTROLLER FOR READY. A MAX-
; IMUM OF APPROXIMATELY 20 US ELAPSES BEFORE CONTROL IS RETURNED TO THE
; CALLER.
;
 
DM_WAIT:					;WAIT FOR CONTROLLER READY
	MOVQ	R0,-(SP)		;SAVE R0, R1
	DSBINT				;DISABLE INTERRUPTS
	TIMEWAIT	#2,#RK_CS1_M_RDY,RK_CS1(R4),W
	ENBINT				;ENABLE INTERRUPTS
	MOVQ	(SP)+,R0		;RESTORE R0, R1
	RSB				;
	.PAGE
	.SBTTL	RK611 DISK CONTROLLER INTERRUPT DISPATCHER
;+
; DM$INT - RK611 DISK CONTROLLER INTERRUPT DISPATCHER
;
; THIS ROUTINE IS ENTERED VIA A JSB INSTRUCTION WHEN AN INTERRUPT OCCURS
; ON AN RK611 DISK CONTROLLER. THE STATE OF THE STACK ON ENTRY IS:
;
;	00(SP) = ADDRESS OF IDB ADDRESS.
;	04(SP) = SAVED R2.
;	08(SP) = SAVED R3.
;	12(SP) = SAVED R4.
;	16(SP) = SAVED R5.
;	20(SP) = INTERRUPT PC.
;	24(SP) = INTERRUPT PSL.
;
; INTERRUPT DISPATCHING OCCURS AS FOLLOWS:
;
;	IF THE INTERRUPTING CONTROLLER IS CURRENTLY OWNED AND THE OWNER
;	UNIT IS EXPECTING AN INTERRUPT, THEN THAT UNIT IS DISPATCHED FIRST.
;	ALL OTHER UNITS ARE DISPATCHED BY READING THE ATTENTION SUMMARY
;	REGISTER AND SCANNING FOR UNITS THAT HAVE ATTENTION SET. AS EACH
;	UNIT IS FOUND,  A TEST IS MADE TO DETERMINE IF AN INTERRUPT IS
;	EXPECTED ON THE UNIT. IF YES, THEN THE DRIVER IS CALLED AT ITS
;	INTERRUPT RETURN ADDRESS. ELSE THE DRIVER IS CALLED AT ITS UNSOL-
;	ICITED INTERRUPT ADDRESS. AS EACH CALL TO THE DRIVER RETURNS, THE
;	ATTENTION SUMMARY REGISTER IS REREAD AND AN ATTEMPT IS MADE TO FIND
;	ANOTHER UNIT TO DISPATCH. WHEN NO UNITS REQUESTING ATTENTION REMAIN,
;	THE INTERRUPT IS DISMISSED.
;-
 
DM$INT::				;RK611 DISK CONTROLLER INTERRUPT DISPATCHER
	MOVL	@(SP),R3		;GET ADDRESS OF IDB
	MOVL	IDB$L_CSR(R3),R4	;GET ADDRESS OF CONTROL STATUS REGISTER 1
	MOVL	IDB$L_OWNER(R3),R5	;GET OWNER UNIT UCB ADDRESS
	BEQL	10$			;IF EQL NO OWNER
	BBSC	#UCB$V_INT,UCB$W_STS(R5),30$ ;IF SET, INTERRUPT EXPECTED
10$:	MOVW	#RK_CS1_M_CERR,RK_CS1(R4) ;CLEAR CONTROLLER
	MOVZWL	RK_AS(R4),R2		;READ ATTENTION SUMMARY REGISTER
	FFS	#8,#8,R2,R2		;FIND FIRST UNIT REQUESTING ATTENTION
	BNEQ	20$			;IF NEQ UNIT FOUND
	MOVZBW	#RK_CS1_M_IE,RK_CS1(R4)	;ENABLE DEVICE INTERRUPTS
	ADDL	#4,SP			;CLEAN STACK
	MOVQ	(SP)+,R0		;RESTORE REGISTERS
	MOVQ	(SP)+,R2		;
	MOVQ	(SP)+,R4		;
	REI				;
20$:	SUBL	#8,R2			;CALCULATE UNIT NUMBER
	MOVW	R2,RK_CS2(R4)		;SET UNIT NUMBER
	MOVL	IDB$L_UCBLST(R3)[R2],R5	;GET ADDRESS OF UCB
	BEQL	80$			;IF EQL NO CORRESPONDING UNIT
	BISW3	UCB$W_DM_DTYP(R5),#F_NOP!1,RK_CS1(R4) ;SELECT DRIVE AND GET STATUS
	BSBW	DM_WAIT			;WAIT FOR CONTROLLER READY
	BBCC	#UCB$V_INT,UCB$W_STS(R5),70$ ;IF CLR, INTERRUPT NOT EXPECTED
30$:	CMPB	#CDF_READHEAD,UCB$B_CEX(R5) ;READ HEADER FUNCTION?
	BNEQ	40$			;IF NEQ NO
	MOVW	RK_DB(R4),UCB$W_DM_DB(R5) ;SAVE SECTOR HEADER INFORMATION
	MOVW	RK_DB(R4),UCB$W_DM_DB+2(R5) ;
	MOVW	RK_DB(R4),UCB$W_DM_DB+4(R5) ;
40$:	MOVAB	RK_CS1(R4),R2		;GET ADDRESS OF CONTROL STATUS REGISTER 1
	MOVAB	UCB$W_DM_CS1(R5),R3	;GET ADDRESS OF REGISTER SAVE AREA
	MOVW	(R2)+,(R3)+		;SAVE CONTROL STATUS REGISTER 1
	BLSS	100$			;IF LSS ERROR ENCOUNTERED
	BBS	#UCB$V_DIAGBUF,UCB$W_DEVSTS(R5),100$ ;IF SET, DIAGNOSTIC BUFFER
	MOVW	(R2)+,(R3)+		;SAVE WORD COUNT REGISTER
	MOVW	(R2),(R3)		;SAVE BUFFER ADDRESS REGISTER
50$:	MOVQ	UCB$L_FR3(R5),R3	;RESTORE DRIVER CONTEXT
	JSB	@UCB$L_FPC(R5)		;CALL DRIVER AT INTERRUPT RETURN ADDRESS
	MOVL	@(SP),R3		;GET ADDRESS OF IDB
	MOVL	IDB$L_CSR(R3),R4	;GET ADDRESS OF CONTROL STATUS REGISTER 1
60$:	MOVW	#RK_CS1_M_CERR,RK_CS1(R4) ;CLEAR CONTROLLER
	MOVW	UCB$W_UNIT(R5),RK_CS2(R4) ;SET UNIT NUMBER
	BISW3	UCB$W_DM_DTYP(R5),#F_DRVCLR!1,RK_CS1(R4) ;CLEAR DRIVE ERRORS
	BSBW	DM_WAIT			;WAIT FOR CONTROLLER READY
	BRW	10$			;
70$:	BSBW	DM_UNSOLNT		;CALL UNSOLICITED INTERRUPT ROUTINE
	MOVL	@(SP),R3		;GET ADDRESS OF IDB
	MOVL	IDB$L_CSR(R3),R4	;GET ADDRESS OF CONTROL STATUS REGISTER 1
	BITW	#RK_CS1_M_CERR,RK_CS1(R4) ;ANY ERROR CONDITION PRESENT?
	BEQL	60$			;IF EQL NO
	MOVW	#RK_CS2_M_SCLR,RK_CS2(R4) ;CLEAR ENTIRE RK611 SUBSYSTEM
	BRW	10$			;
80$:	MOVW	#RK_CS1_M_CDT!F_DRVCLR!1,RK_CS1(R4) ;CLEAR RK07 DRIVE
	BSBW	DM_WAIT			;WAIT FOR FUNCTION TO COMPLETE
	TSTW	RK_CS1(R4)		;SUCCESSFUL COMPLETION?
	BGEQ	90$			;IF GEQ YES
	MOVW	#RK_CS1_M_CERR,RK_CS1(R4) ;CLEAR CONTROLLER
	MOVW	R2,RK_CS2(R4)		;SET UNIT NUMBER
	MOVW	#F_DRVCLR!1,RK_CS1(R4)	;CLEAR RK06 DRIVE
	BSBW	DM_WAIT			;WAIT FOR FUNCTION TO COMPLETE
90$:	BRW	10$			;
100$:	MOVW	(R2)+,(R3)+		;SAVE WORD COUNT REGISTER
	MOVW	(R2)+,(R3)+		;SAVE BUFFER ADDRESS REGISTER
	MOVW	(R2)+,(R3)+		;SAVE DESIRED SECTOR/TRACK ADDRESS REGISTER
	MOVW	(R2)+,(R3)+		;SAVE CONTROL STATUS REGISTER 2
	MOVW	(R2)+,(R3)+		;SAVE DRIVE STATUS REGISTER
	MOVW	(R2)+,(R3)+		;SAVE ERROR REGISTER
	MOVW	(R2)+,(R3)+		;SAVE ATTENTION SUMMARY/OFFSET REGISTER
	MOVW	(R2)+,(R3)+		;SAVE DESIRED CYLINDER ADDRESS REGISTER
	ADDL	#4,R2			;POINT TO MAINTENANCE REGISTER 1
	MOVW	(R2)+,(R3)+		;SAVE MAINTENANCE REGISTER 1
	MOVW	(R2)+,UCB$W_EC1(R5)	;SAVE ECC POSITION REGISTER
	MOVW	(R2)+,UCB$W_EC2(R5)	;SAVE ECC PATTERN REGISTER
	MOVW	(R2)+,(R3)+		;SAVE MAINTENANCE REGISTER 2
	MOVW	(R2),(R3)		;SAVE MAINTENANCE REGISTER 3
	BBC	#RK_CS2_V_MDS,UCB$W_DM_CS2(R5),110$ ;IF CLR, NO MULTI-DRIVE SELECT
	MOVW	#RK_CS2_M_SCLR,RK_CS2(R4) ;CLEAR ENTIRE SUBSYSTEM
110$:	BRW	50$			;
	.PAGE
	.SBTTL	RK611 DISK CONTROLLER INITIALIZATION
;+
; DM_RK611_INIT - RK611 DISK CONTROLLER INITIALIZATION
;
; THIS ROUTINE IS CALLED VIA A JSB INSTRUCTION AT SYSTEM STARTUP AND AFTER
; A POWER RECOVERY RESTART TO ALLOW INITIALIZATION OF RK611 DISK CONTROLLERS.
; 
; INPUTS:
;
;	R0 = SCRATCH.
;	R1 = SCRATCH.
;	R2 = SCRATCH.
;	R3 = SCRATCH.
;	R4 = ADDRESS OF CONTROL STATUS REGISTER 1.
;	R5 = ADDRESS OF CONTROLLER IDB.
;
;	ALL INTERRUPTS ARE LOCKED OUT.
;
; OUTPUTS:
;
;	THE RK611 CONTROLLER IS INITIALIZED AND INTERRUPTS ARE ENABLED.
;-
 
DM_RK611_INIT:				;RK611 DISK CONTROLLER INITIALIZATION
	MOVW	#RK_CS2_M_SCLR,RK_CS2(R4) ;CLEAR CONTROLLER AND ALL DRIVES
	MOVZBW	#RK_CS1_M_IE,RK_CS1(R4)	;ENABLE DEVICE INTERRUPTS
	RSB				;
	.PAGE
	.SBTTL	RK611 Autoconfigure Unit Delivery Routine
;+
; DM$DELIVER - RK611 Autoconfigure Unit Delivery Routine
;
; This routine is called by the SYSGEN AUTOCONFIGURE command to determine 
; which RK611 unit numbers to configure.  It is called once for each possible 
; unit, 0 through 7.
;
; INPUTS:
;	R3 Address of controller IDB, or zero if none exists
;	R4 Address of CSR
;	R5 Unit number which this routine must decide whether or not to 
;	   configure
;	R6 Base addres of UNIBUS adapter I/O space
;	R7 Address of AUTOCONFIGURE ACF
;	R8 Address of UNIBUS ADP
;	IPL = 31
;
; OUTPUTS:
;	R0 TRUE  ==> configure unit indicated in R5
;	   FALSE ==> do not configure unit indicated in R5
;
; Interference with "normal" data transfers is a major concern for this unit 
; delivery routine.  Since it is called without the controls of the QIO 
; mechanism, the state of data transfers when it is entered is unpredictable. 
; Experience has shown that conditions are so unpredictable that the only 
; option open to this routine is forcing all current activitiy to be retried. 
; To this end, all UCBs listed in the IDB passed to this routine, if any, are 
; made to appear as if a power failure has occured.  Having done this, the 
; retrying of currently active opeations is relative assured.  We do not 
; simulate a power failure to the extent of calling the controller and unit 
; initialization routines; after all, this routine determines the state of the 
; controller and its units quite completely.
;
;-

DM$DELIVER:
	TSTL	R5			; Is this the first call for this
	BNEQ	10$			; for this controller?  If so, get
	BSBB	GET_UNITS		; complete units present information.
10$:	EXTZV	R5, #1, -		; For each unit, get presense data from
		ACF$L_DLVR_SCRH(R7), R0	; information prepared by GET_UNITS.
	RSB				; Then, return to AUTOCONFIGURE.

;+
; NB: the use of the one-time get-units-information routine GET_UNITS reduces 
; to one the number of times we must fool with the controller and thus our 
; pontential for munging "normal" opeations.  It also insures that all 
; controller munging occurs at the same time that a power failure is 
; simulated.
;-

GET_UNITS:
	DSBINT				; Insure no interruptions.

;+
; SIMULATE A POWER FAILURE ON ALL KNOWN UCBs
;-
	TSTL	R3			; Is there an IDB?  If not, the RK611
	BEQL	500$			; must be inactive.
	MOVL	IDB$W_UNITS(R3), R0	; Get count of UCBs to test.
10$:	MOVL	IDB$L_UCBLST-4(R3)[R0], R1 ; Get a UCB address.
	BEQL	19$			; Branch if not really a UCB address.
	BISW	#UCB$M_POWER, UCB$W_STS(R1) ; Pretend power failure.
	BITW	#<UCB$M_INT!UCB$M_TIM>, -   ; Test for timeout in progress.
		UCB$W_STS(R1)
	BEQL	19$			; Branch if no timeout in progress.
	BICW	#UCB$M_INT, UCB$W_STS(R1) ; Clear interrupt expected.
	BISW	#UCB$M_TIM, UCB$W_STS(R1) ; Indicate that a timeout is expected
	CLRL	UCB$L_DUETIM(R1)	  ; immediately.
19$:	SOBGTR	R0, 10$			; Loop through all UCBs.

;+
; DISCOVERING WHICH UNITS ARE PRESENT
;-
500$:	CLRL	ACF$L_DLVR_SCRH(R7)	; Clear all units present bits.
	CLRL	R0			; Initialize unit number.
600$:	BSBW	DM_WAIT			; Wait for controller ready.
	MOVW	#RK_CS1_M_CERR, RK_CS1(R4) ; Clear controller.
	MOVW	R0, RK_CS2(R4)		; Set unit number.
	MOVW	#1, RK_CS1(R4)		; Select drive and get status.
	BSBW	DM_WAIT			; Wait for controller ready.
	BITW	#RK_CS2_M_NED, RK_CS2(R4) ; Nonexistent drive?
	BNEQ	690$			; If nonexistent, no more to do here.
	BBSS	R0, ACF$L_DLVR_SCRH(R7), 610$ ; Set device present bit.
610$:	MOVW	#RK_CS1_M_CERR, RK_CS1(R4) ; Clear controller.
	MOVW	R0, RK_CS2(R4)		; Set unit number.
	MOVW	#^X405, RK_CS1(R4)	; Clear drive as a RK07.
	BSBW	DM_WAIT			; Wait for function to complete.
	TSTW	RK_CS1(R4)		; Controller errors?  Errors mean its a
	BGEQ	690$			; RK06 and must be cleared differently.
	MOVW	#RK_CS1_M_CERR, RK_CS1(R4) ; Clear controller.
	MOVW	R0, RK_CS2(R4)		; Set unit number.
	MOVW	#5, RK_CS1(R4)		; Clear drive as a RK06.
690$:	AOBLEQ	#7, R0, 600$		; Loop over all possible drives.
	BSBW	DM_WAIT			; Wait for last operation to complete.
	MOVW	#RK_CS1_M_CERR, RK_CS1(R4) ; Clear controller.
	ENBINT				; Restore previous interrupt state.
	RSB				; Return to main unit-deliver routine.

DM_END:					;ADDRESS OF LAST LOCATION IN DRIVER
 
	.END
