	.TITLE	DQDRIVER - VAX/VMS RB730:RB02/RB80 DISK DRIVER
	.IDENT	'V03-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
; 
; 
; FACILITY:
; 
; 	VAX/VMS RB730:RB02/RB80 DISK DRIVER
; 
; AUTHOR:
; 
; G. ROBERT	21-JAN-1981
; 
; MODIFIED BY:
;
;	V02-005	GRR2005		GREG ROBERT		08-FEB-1981
;		ALLOW THE REPORTING OF PARTIAL TRANSFERS ON NON-DRIVE
;		RELATED ERRORS.
;
;	V02-004	GRR2004		GREG ROBERT		02-DEC-1981
;		CLEANED UP HANDLING OF IO$AVAILABLE AND ADDED CHECK
;		FOR DRIVE ERRORS IN COMPUTATION OF FINAL TRANSFER COUNT.
;
;	V02-003	GRR2003		GREG ROBERT		11-NOV-1981
;		FIX READ HEADER LOGIC TO ONLY READ A SINGLE HEADER
;		AND TO PROPERLY COMPUTE BYTES TRANSFERED.  FIX SEGMENTED
;		TRANSFER UPDATE LOGIC TO HANDLE ODD SECTOR ADDRESSES
;		AND TO ALLOW FOR 32 SECTORS PER TRACK ON R80'S WHEN
;		SKIP SECTORING IS DISABLED.
;
;	V02-002	GRR2002		GREG ROBERT		28-OCT-1981
;		SET UCB$V_VALID ON IO$_PACKACK.  CLEAR IT ON
;		IO$_UNLOAD AND IO$_AVAILABLE
;
;**
	.PAGE
	.SBTTL	PROGRAM ABSTRACT

; ABSTRACT:
; 
; 	THIS MODULE CONTAINS THE TABLES AND ROUTINES NECESSARY TO
; 	PERFORM ALL DEVICE-DEPENDENT PROCESSING OF AN I/O REQUEST
; 	FOR RB730:RB02/RB80 DISK TYPES ON A VAX/VMS SYSTEM.
; 
; 	THE DISKS HAVE THE FOLLOWING PHYSICAL GEOMETRY:
;
; 			TRACKS/	   SECTORS/	BYTES/	   MAXIMUM	
;	   # CYL	CYLINDER   TRACK	SECTOR	   BLOCKS
; 
; RB02	    512		   2	     40		  256	   20480
; RB80      561           14         32           512     251328
; 
; 	SINCE THE RB02 SECTOR SIZE IS ONLY 1/2 BLOCK, LOGICAL TO PHYSICAL
; 	CONVERSION OF RB02 DISK ADDRESSES BY IOC$CVTLOGPHY IS DELAYED
;	UNTIL STARTIO IS CALLED, AND THE DISK ADDRESS IS DOUBLED PRIOR
;	TO CONVERSION.
;
;	ON THE RB80, THE LAST SECTOR IN EVERY TRACK IS RESERVED FOR
;	"SKIP SECTORING", AND THE LAST TWO CYLINDERS ARE RESERVED
;	FOR FIELD SERVICE.  THE USER AVAILABLE RB80 GEOMETRY IS THEREFORE:
;	
; RB80	    559		  14	     31		  512     242606
; 
; 
; 	THE CONTROLLER DOES NOT READ OR WRITE BEYOND THE END OF TRACK 
; 	(SPIRALLING), SO READ AND WRITE FUNCTIONS ARE BROKEN UP BY THIS
;	DRIVER INTO PARTIAL TRANSFERS TO THE END OF TRACK, FOLLOWED BY
;	AN EXPLICIT SEEK TO THE NEXT TRACK, THEN ANOTHER READ OR
; 	WRITE FUNCTION UNTIL THE TOTAL DATA TRANSFER IS COMPLETE.
;	(TRACK TO TRACK SPIRALLING FOR R80'S, WITHIN A CYLINDER,
;	IS DONE INSIDE THE XFER ROUTINE BY WRITING THE DAR).
;
;	THE IO$_INHSEEK MODIFIER IS IGNORED BY THIS DRIVER.
;
;	THE R02 DRIVE ON AN RB730 CONTROLLER IS CALLED AN RB02.  THE
;	SAME DRIVE ON AN RL11 CONTROLLER IS KNOWN AS AN RL02.  SIMILARILY
;	THE R80 DRIVE IS KNOWN AS THE RM80, RA80, AND RB80 WHEN PLACED
;	ON DIFFERENT CONTROLLERS.  DRIVE DEPENDENT CHARACTERISTICS (SPEED,
;	SIZE, MECHANICAL TIMINGS) REMAIN THE SAME.  CONTROLLER DEPENDENT
;	CHARACTERISTICS (COMMANDS, COMMAND TIMINGS, ERROR REPORTING) VARY
;	FROM CONTROLLER TO CONTROLLER.
;	
;	
;--
	.PAGE
	.SBTTL	EXTERNAL DEFINITIONS

; 
; EXTERNAL SYMBOLS
; 

	$ADPDEF				;DEFINE ADAPTER CONTROL BLOCK
	$CRBDEF				;DEFINE CHANNEL REQUEST BLOCK
	$DCDEF				;DEFINE DEVICE CLASS
	$DDBDEF				;DEFINE DEVICE DATA BLOCK
	$DEVDEF				;DEFINE DEVICE CHARACTERISTICS
	$DPTDEF				;DEFINE DRIVER PROLOGUE TABLE
	$EMBDEF				;DEFINE ERROR MESSAGE BUFFER
	$IDBDEF				;DEFINE INTERRUPT DATA BLOCK
	$IODEF				;DEFINE I/O FUNCTION CODES
	$IPLDEF				;DEFINE IPL CODES
	$IRPDEF				;DEFINE I/O REQUEST PACKET
	$PRDEF				;DEFINE PROCESSOR REGISTERS
	$SSDEF				;DEFINE SYSTEM STATUS CODES
	$UBIDEF				;DEFINE UNIBUS ADAPTOR OFFSETS
	$UCBDEF				;DEFINE UNIT CONTROL BLOCK
	$VECDEF				;DEFINE INTERRUPT VECTOR BLOCK

	.PAGE
	.SBTTL	LOCAL MACRO DEFINITIONS

; 
; LOCAL MACROS
; 
	.MACRO	REQDPRNW
		JSB	G^IOC$REQDATAPNW
	.ENDM	REQDPRNW

	.MACRO	LOADUBAA
		JSB	G^IOC$LOADUBAMAPA
	.ENDM	LOADUBAA

;
;EXFUNCL
; BRANCH TO SUBROUTINE WHICH REQUESTS CHANNEL (IF NOT ALREADY OWNED),
; EXECUTES FCODE (OR R3) FUNCTION, AND BRANCHES TO BDST ON ERROR
;

	.MACRO	EXFUNCL BDST,FCODE	
		.IF NB	FCODE		;IS FCODE NON-BLANK?
		MOVZBL	#CD'FCODE,R3	;IF NB - SPECIFY FCODE FUNCTION
		.ENDC			;IF B - SPECIFY FNTN IN EXISTING R3
		BSBW	FEXL		;EXECUTE FUNCTION
		.BYTE	BDST-.-1	;WHERE TO GO IF ERROR
	.ENDM

;
;GENF
; GENERATE FUNCTION TABLE ENTRY AND CASE TABLE INDEX SYMBOL
;
	.MACRO	GENF FCODE,MODS
		CD'FCODE=.-FTAB/4
		_TMP$VAL = FCODE
		_TMP$VAL = _TMP$VAL ! RB_CS_M_IE
		.IRP MODBIT,MODS
			_TMP$VAL = _TMP$VAL ! RB_CS_M_'MODBIT'
		.ENDR
		.LONG	_TMP$VAL
	.ENDM

		
;
;CKPWR
; DISABLE INTERRUPTS, CHECK IF POWER HAS FAILED,
; 
	.MACRO	CKPWR,DEST=RETREG,?L1

		SETIPL	#IPL$_POWER	;RAISE TO POWER
		BBC	#UCB$V_POWER,-	;IF CLR - NO POWER FAILURE
			UCB$W_STS(R5),L1  ;...
		ENBINT			;POWER FAILURE - RETURN TO SAVED IPL
		BRB	DEST		;EXIT
L1:					;RETURN FOR NO POWER FAILURE
	.ENDM


;
;GETUNIT
; GET UNIT NUMBER FROM UCB, PLACE IN SPECIFIED LOCATION OR
; R2 BY DEFAULT
;
	.MACRO	GETUNIT,DEST=R2
		CLRL	DEST		;CLEAR DEST FOR UNIT NUMBER
		INSV	UCB$W_UNIT(R5),	#8,#2,DEST ;PUT UNIT NUMBER IN DEST
	.ENDM


;
;INITIATE
; INITIATE A HARDWARE FUNCTION BY CLEARING CONTROLLER READY.
; PRESERVE THE ATTENTION AND INTERRUPT PENDING BITS BY CLEARING
; THEM (SINCE THEY ARE "WRITE ONES TO CLEAR" THE FOLLOWING
; INSTRUCTION LEAVES THEM UNMODIFIED).
;
	.MACRO	INITIATE
	BICL	#RB_CS_M_CRDY-		;CLEAR CONTROLLER READY
		!RB_CS_M_ATN-		;...AND PRESERVE ATTENTION BITS
		!RB_CS_M_IR,-		;...AND INTERRUPT REQUEST BIT
		RB_CS(R4)		;...IN THE CSR
	.ENDM

;
;BDRVTYP
; BRANCH ON DRIVE TYPE
;
	.MACRO	BDRVTYP TYPE,DEST
	CMPB	#DT$_'TYPE,UCB$B_DEVTYPE(R5)	;COMPARE DRIVE TYPE
	BEQL	DEST				;BRANCH IF SPECIFIED TYPE
	.ENDM

	.PAGE
	.SBTTL	LOCAL SYMBOLS AND UCB EXTENSIONS

; 
; LOCAL SYMBOLS
; 
RB_NUM_REGS	=7			;NUMBER OF DEVICE REGISTERS
RB_MP_C_SLM	=5			;STATE=SEEK LINEAR MODE (READY TO GO)

; 
; UCB OFFSETS WHICH FOLLOW THE STANDARD UCB FIELDS
; 
	$DEFINI	UCB			;START OF UCB DEFINITIONS
.=UCB$W_OFFSET+1			;REDEFINE FOR LOCAL USE

$DEF	UCB$B_DQ_FLAGS			;LOCAL DRIVER FLAGS
	$VIELD	UCB,0,<-		;START OF DQ FLAGS DEFINITIONS
		<DQ_SIP,,M>,-		; SEEK IN PROGRESS
		<DQ_DIP,,M>,-		; DATA CHECK IN PROGRESS
	>				;END OF DQ FLAGS BIT DEFINITIONS

.=UCB$W_BCR+2				;BEGIN DEFINITIONS AT END OF UCB

$DEF	UCB$L_DQ_CS	.BLKL	1	;CONTROL STATUS REGISTER
$DEF	UCB$L_DQ_BA	.BLKL	1	;BUS ADDRESS REGISTER
$DEF	UCB$L_DQ_BC	.BLKL	1	;BYTE COUNT REGISTER
$DEF	UCB$L_DQ_DA	.BLKL	1	;DISK ADDRESS REGISTER
$DEF	UCB$L_DQ_MP	.BLKL	1	;MULTIPURPOSE REGISTER
$DEF	UCB$L_DQ_FMPR	.BLKL	1	;FINAL MAP REGISTER
$DEF	UCB$L_DQ_PMPR	.BLKL	1	;PREVIOUS MAP REGISTER
$DEF	UCB$L_DQ_DPR	.BLKL	1	;DATAPATH REGISTER (NEVER LOADED)
$DEF	UCB$W_DQ_HDR1	.BLKW	1	;SAVED HEADER WORD 1
$DEF	UCB$W_DQ_HDR2	.BLKW	1	;SAVED HEADER WORD 2
$DEF	UCB$W_DQ_HDR3	.BLKW	1	;SAVED HEADER WORD 3
$DEF	UCB$L_DQ_CURDA	.BLKL	1	;CURRENT DISK ADDRESS

UCB$K_DQ_LEN = .			;LENGTH OF EXTENDED UCB
	$DEFEND	UCB			;END OF UCB DEFINITONS
 
; 
; RB730:RB02/RB80 REGISTER OFFSETS FROM CSR ADDRESS
; 
	$DEFINI	RB			; START OF REGISTER DEFINITIONS

$DEF	RB_CS		.BLKL	1	;CONTROL STATUS REGISTER (CSR)
	_VIELD	RB_CS,0,<-		;START OF CSR BIT DEFINITIONS
		<DRDY,,M>,-		; DRIVE READY
		<FCODE,3,M>,-		; FUNCTION CODE
		<,2>,-			; RESERVED BITS
		<IE,,M>,-		; INTERRUPT ENABLE
		<CRDY,,M>,-		; CONTROLLER READY
		<DS,2,M>,-		; DRIVE SELECT
		<OPI,,M>,-		; OPERATION INCOMPLETE
		<DCK,,M>,-		; DATA CRC OR HEADER CRC OR DATA ECC
		<DLT,,M>,-		; DATA LATE OR HEADER NOT FOUND
		<NXM,,M>,-		; NON-EXISTENT MEMORY
		<DE,,M>,-		; DRIVE ERROR
		<CE,,M>,-		; COMPOSITE ERROR
		<ATN,4,M>,-		; DRIVE ATTENTION BITS
		<ECS,2>,-		; ECC STATUS
		<SSEI,,M>,-		; SKIP SECTOR ERROR INHIBIT
		<SSE,,M>,-		; SKIP SECTOR ERROR
		<IR,,M>,-		; RB730 INTERRUPT REQUEST
		<MTN,,M>,-		; MAINTENANCE MODE
		<TYP,,M>,-		; DRIVE TYPE 1=RB80, 0=RB02
		<ASSI,,M>,-		; AUTOMATIC SKIP SECTOR INHIBIT
		<TOI,,M>,-		; TIME OUT INHIBIT (U-DIAG'S)
		<FMT,,M>,-		; R80 FORMAT CONTROL
		<,2>-			; RESERVED BITS
	>				;END CSR BIT DEFINITIONS

$DEF	RB_BA		.BLKL	1	;BUS ADDRESS REGISTER (BAR)

$DEF	RB_BC		.BLKL	1	;BYTE COUNT REGISTER (BCR)

$DEF	RB_DA		.BLKL	1	;DISK ADDRESS REGISTER (DAR)
	_VIELD	RB_DA,0,<-		;START OF DAR BIT DEFINITIONS
		<SEC,8>,-		; SECTOR
		<TRK,8>,-		; TRACK
		<CYL,16>-		; CYLINDER
	>				;END OF DAR BIT DEFINITIONS

$DEF	RB_MP		.BLKL	1	;MULTIPURPOSE REGISTER (MPR)
	_VIELD	RB_MP,0,<-		;RB02 STATUS WORD DEFINITIONS
		<STA,3>,-		; DRIVE STATE
		<BH,,M>,-		; BRUSH HOME
		<HO,,M>,-		; HEADS OUT
		<CO,,M>,-		; COVER OPEN
		<HS,,M>,-		; HEAD SELECT
		<,1>,-			; RESERVED
		<DSE,,M>,-		; DRIVE SELECT ERROR
		<VC,,M>,-		; VOLUME CHECK
		<WGE,,M>,-		; WRITE GATE ERROR
		<SPD,,M>,-		; SPIN ERROR
		<SKTO,,M>,-		; SEEK TIME OUT
		<WL,,M>,-		; WRITE LOCK
		<HCE,,M>,-		; CURRENT HEAD ERROR
		<WDE,,M>-		; WRITE DATA ERROR
	>				;
	_VIELD	RB_MP,0,<-		;GET STATUS COMMAND DEFINITIONS
		<MRK,,M>,-		; MARK (ALWAYS 1)
		<STS,,M>,-		; GET STATUS
		<,1>,-			; RESERVED
		<RST,,M>,-		; RESET
	>
	_VIELD	RB_MP,0,<-		;RB80 STATUS WORD DEFINITIONS
		<SEC,5>,-		; CURRENT RB80 SECTOR
		<,3>,-			; RESERVED
		<FLT,,M>,-		; DRIVE FAULT
		<PLGV,,M>,-		; PLUG VALID
		<SKE,,M>,-		; SEEK ERROR
		<ONCY,,M>,-		; ON CYLINDER
		<DRDY,,M>,-		; DRIVE READY
		<WTP,,M>,-		; WRITE PROTECT
		<,2>,-			; RESERVED
	>				;END MPR BIT DEFINITIONS

$DEF	RB_EC1		.BLKL	1	;ECC POSITION REGISTER (EPOR)
	_VIELD	RB_EC1,0,<-		;START OF EC1 BIT DEFINITIONS
		<POS,13>,-		; STARTING BIT POSITION OF ECC ERROR
		<,21>-			; RESERVED
	>				;END EC1 BIT DEFINITIONS

$DEF	RB_EC2		.BLKL	1	;ECC PATTERN REGISTER (EPAR)
	_VIELD	RB_EC2,0,<-		;START OF EC2 BIT DEFINITIONS
		<PAT,11>,-		; PATTERN OF ECC ERROR BURST
		<,21>-			; RESERVED
	>				;END EC2 BIT DEFINITIONS

$DEF	RB_CMD		.BLKL	1	;AUXILLARY COMMAND REGISTER
	_VIELD	RB_CMD,0,<-		;START OF CMD BIT DEFINITIONS
		<INIT,32>,-		; SUBSYSTEM CLEAR <-- -1
	>				;END CMD BIT DEFINITIONS

	$DEFEND	RB			;END RB730:RB80/RB02 REGISTER DEFS

; 
; HARDWARE FUNCTION CODES
; 
F_NOP=0*2				;NO OPERATION
F_UNLOAD=2*2				;GET STATUS/RESET
F_SEEK=3*2				;SEEK CYLINDER
F_RECAL=3*2				;RECALIBRATE (SEEK -1)
F_DRVCLR=2*2				;DRIVE CLEAR (GET STATUS)
F_RELEASE=0*2				;NO OPERATION
F_OFFSET=0*2				;NO OPERATION
F_RETCENTER=0*2				;NO OPERATION
F_PACKACK=2*2				;PACK ACKNOWLEDGE (SET VOLUME VALID)
F_STARTSPNDL=0*2			;NO OPERATION
F_WRITECHECK=1*2			;WRITE CHECK
F_WRITEDATA=5*2				;WRITE DATA
F_WRITEHEAD=0*2				;WRITE HEADER (WHEN FMT BIT SET)
F_READDATA=6*2				;READ DATA
F_READHEAD=4*2				;READ HEADER
F_GETSTATUS=2*2				;GET STATUS (DRIVER INTERNAL USE)
F_WRITETRACKD=0*2			;NOP
F_READTRACKD=0*2			;NOP
F_AVAILABLE=2*2				;GET STATUS/RESET

	.PAGE
	.SBTTL	STANDARD TABLES

; 
; DRIVER PROLOGUE TABLE
; 
; 	THE DPT DESCRIBES DRIVER PARAMETERS AND I/O DATABASE FIELDS
; 	THAT ARE TO BE INITIALIZED DURING DRIVER LOADING AND RELOADING
; 

	DPTAB	-				;DPT CREATION MACRO
		END=DQ_END,-			;END OF DRIVER LABEL
		ADAPTER=UBA,-			;ADAPTER TYPE = UNIBUS
		FLAGS=DPT$M_SVP,-		;SYSTEM PAGE TABLE ENTRY REQ.
		MAXUNITS=4,-			;MAXIMUM FOUR DRIVES PER RB730
		DEFUNITS=4,-			;INTERROGATE FOUR DRIVES
		DELIVER=DQ_DELIVER,-		;UNIT TEST ROUTINE
		UCBSIZE=UCB$K_DQ_LEN,-		;LENGTH OF UCB
		NAME=DQDRIVER			;DRIVER NAME

	DPT_STORE INIT				;START CONTROL BLOCK INIT VALS.
	DPT_STORE DDB,DDB$L_ACPD,L,<^A\F11\>  	;DEFAULT ACP NAME
	DPT_STORE DDB,DDB$L_ACPD+3,B,DDB$K_PACK	;ACP CLASS
	DPT_STORE UCB,UCB$B_FIPL,B,8		;FORK IPL
	DPT_STORE UCB,UCB$L_DEVCHAR,L,-		;DEVICE CHARACTERISTICS
		<DEV$M_FOD-		; FILES ORIENTED
		!DEV$M_DIR-		; DIRECTORY STRUCTURED
		!DEV$M_AVL-		; AVAILABLE
		!DEV$M_ELG-		; ERROR LOGGING
		!DEV$M_SHR-		; SHAREABLE
		!DEV$M_IDV-		; INPUT DEVICE
		!DEV$M_ODV-		; OUTPUT DEVICE
		!DEV$M_RND>		; RANDOM ACCESS
	DPT_STORE UCB,UCB$B_DEVCLASS,B,DC$_DISK	;DEVICE CLASS
	DPT_STORE UCB,UCB$W_DEVBUFSIZ,W,512	;DEFAULT BUFFER SIZE
	DPT_STORE UCB,UCB$B_DIPL,B,21		;DEVICE IPL
	DPT_STORE UCB,UCB$B_ERTMAX,B,8		;MAX ERROR RETRY COUNT
	DPT_STORE UCB,UCB$L_DQ_CURDA,L,-1	;CURRENT DISK ADDRESS

	DPT_STORE REINIT			;START CONTROL BLOCK RE-INIT
	DPT_STORE CRB,CRB$L_INTD+4,D,DQ_INT  	;INTERRUPT SERV. ROUT. ADDRESS
	DPT_STORE CRB,CRB$L_INTD+VEC$L_INITIAL,-;CONTROLLER INIT ADDRESS
		      D,DQ_RB730_INIT		;...
	DPT_STORE CRB,CRB$L_INTD+VEC$L_UNITINIT,- ;UNIT INIT ADDRESS
		      D,DQ_UNIT_INIT		;...
	DPT_STORE DDB,DDB$L_DDT,D,DQ$DDT	;DDT ADDRESS

	DPT_STORE END			;END OF INITIALIZATION TABLE

; 
; DRIVER DISPATCH TABLE
; 
; 	THE DDT LISTS ENTRY POINTS FOR DRIVER SUBROUTINES WHICH ARE
; 	CALLED BY THE OPERATING SYSTEM.
; 

	DDTAB	-			;DDT CREATION MACRO
		DEVNAM=DQ,-		;NAME OF DEVICE
		START=DQ_STARTIO,-	;START I/O ROUTINE
		FUNCTB=DQ_FUNCTABLE,-	;FUNCTION DECISION TABLE
		CANCEL=0,-		;CANCEL=NO-OP FOR FILES DEVICE
		REGDMP=DQ_REGDUMP,-	;REGISTER DUMP ROUTINE
		DIAGBF=<<RB_NUM_REGS+5+5+3+1>*4>,-  ;BYTES IN DIAG BUFFER
		ERLGBF=<<<RB_NUM_REGS+5+1>*4>+EMB$L_DV_REGSAV>  ;BYTES IN
							;ERROR LOG BUFFER

; DIAGNOSTIC BUFFER SIZE = <<7 RB730 REGISTER LONGWORDS + 5 UCB FIELD LONGWORDS 
;			   + 5 IOC$DIAGBUFILL LONGWORDS + 3 BUFFER ALLOCATION
;			   LONGWORDS + 1 LONGWORD FOR # REGISTERS IN DQ_REGDUMP>
;			   * 4 BYTES/LONGWORD>
;
; ERROR LOG BUFFER SIZE  = <<<7 RB730 REGISTER LONGWORDS + 5 UCB FIELD LONGWORDS
; 			   + 1 LONGWORD FOR # REGISTERS IN DQ_REGDUMP>
;			   * 4 BYTES/LONGWORD> + BYTES NEEDED FOR ERROR LOGGER
;			   TO SAVE SOFTWARE REGISTERS>


; 
; HARDWARE FUNCTION CODE TABLE
; 
; 	THIS TABLE MERGES THE FUNCTION CODE BITS WITH THE 
; 	INTERRUPT ENABLE BIT AND GENERATES THE CASE TABLE
; 	INDEX SYMBOL.  THIS IS AN ORDERED TABLE

FTAB:	GENF	F_NOP			;NO-OP
	GENF	F_UNLOAD		;UNLOAD VOLUME (GET STATUS/RESET)
	GENF	F_SEEK,CRDY		;SEEK
	GENF	F_RECAL,CRDY		;RECALIBRATE
	GENF	F_DRVCLR		;DRIVE CLEAR (GET STATUS/RESET)
	GENF	F_RELEASE		;RELEASE PORT (NOP)
	GENF	F_OFFSET		;OFFSET HEADS (NOP)
	GENF	F_RETCENTER		;RETURN HEADS TO CENTERLINE (NOP)
	GENF	F_PACKACK		;PACK ACKNOWLEDGE (GET STATUS/RESET)
	GENF	F_STARTSPNDL		;START SPINDLE (NOP)
	GENF	F_WRITECHECK,CRDY	;WRITE CHECK
	GENF	F_WRITEDATA,CRDY	;WRITE DATA
	GENF	F_READDATA,CRDY		;READ DATA
	GENF	F_WRITEHEAD,<CRDY,FMT>	;WRITE HEADERS
	GENF	F_READHEAD,CRDY		;READ HEADERS
	GENF	F_WRITETRACKD		;WRITE TRACK DESCRIPTOR (NOP)
	GENF	F_READTRACKD		;READ TRACK DESCRIPTOR (NOP)
	GENF	F_AVAILABLE		;SET UNIT AVAILABLE (GET STATUS/RESET)

	.PAGE
	.SBTTL	FUNCTION DECISION TABLES

; 
; FUNCTION DECISION TABLE
; 
; 	THE FDT LISTS VALID FUNCTION CODES, SPECIFIES WHICH
; 	CODES ARE BUFFERED, AND DESIGNATES SUBROUTINES TO
; 	PERFORM PREPROCESSING FOR PARTICULAR FUNCTIONS.
; 

DQ_FUNCTABLE:
	FUNCTAB	,-			;LIST LEGAL FUNCTIONS
		<NOP,-			; NO-OP
		UNLOAD,-		; UNLOAD
		SEEK,-			; SEEK
		RECAL,-			; RECALIBRATE DRIVE
		DRVCLR,-		; DRIVE CLEAR
		PACKACK,-		; PACK ACKNOWLEDGE
		SENSECHAR,-		; SENSE CHARACTERISTICS
		SETCHAR,-		; SET CHARACTERISTICS
		SENSEMODE,-		; SENSE MODE
		SETMODE,-		; SET MODE
		WRITECHECK,-		; WRITE CHECK
		READHEAD,-		; READ HEADER
		READLBLK,-		; READ LOGICAL BLOCK
		WRITELBLK,-		; WRITE LOGICAL BLOCK
		READPBLK,-		; READ PHYSICAL BLOCK
		WRITEPBLK,-		; WRITE PHYSICAL BLOCK
		READVBLK,-		; READ VIRTUAL BLOCK
		WRITEVBLK,-		; WRITE VIRTUAL BLOCK
		WRITEHEAD,-		; WRITE DISK HEADERS
		AVAILABLE,-		; AVAILABLE
		ACCESS,-		; ACCESS FILE / FIND DIRECTORY ENTRY
		ACPCONTROL,-		; ACP CONTROL FUNCTION
		CREATE,-		; CREATE FILE AND/OR DIRECTORY ENTRY
		DEACCESS,-		; DEACCESS FILE
		DELETE,-		; DELETE FILE AND/OR DIRECTORY ENTRY
		MODIFY,-		; MODIFY FILE ATTRIBUTES
		MOUNT-			; MOUNT VOLUME
		>
	FUNCTAB	,-			;BUFFERED FUNCTIONS
		<NOP,-			; NO-OP
		UNLOAD,-		; UNLOAD
		SEEK,-			; SEEK
		RECAL,-			; RECALIBRATE
		DRVCLR,-		; DRIVE CLEAR
		PACKACK,-		; PACK ACKNOWLEDGE
		AVAILABLE,-		; AVAILABLE
		SENSECHAR,-		; SENSE CHARACTERISTICS
		SETCHAR,-		; SET CHARACTERISTICS
		SENSEMODE,-		; SENSE MODE
		SETMODE,-		; SET MODE
		ACCESS,-		; ACCESS FILE / FIND DIRECTORY ENTRY
		ACPCONTROL,-		; ACP CONTROL FUNCTION
		CREATE,-		; CREATE FILE AND/OR DIRECTORY ENTRY
		DEACCESS,-		; DEACCESS FILE
		DELETE,-		; DELETE FILE AND/OR DIRECTORY ENTRY
		MODIFY,-		; MODIFY FILE ATTRIBUTES
		MOUNT-			; MOUNT VOLUME
		>
	FUNCTAB	+ACP$READBLK,-		;READ FUNCTIONS
		<READHEAD,-		; READ HEADER
		READLBLK,-		; READ LOGICAL BLOCK
		READPBLK,-		; READ PHYSICAL BLOCK
		READVBLK-		; READ VIRTUAL BLOCK
		>
	FUNCTAB	+ACP$WRITEBLK,-		;WRITE FUNCTIONS
		<WRITECHECK,-		; WRITE CHECK
		WRITEHEAD,-		; WRITE HEADER
		WRITELBLK,-		; WRITE LOGICAL BLOCK
		WRITEPBLK,-		; WRITE PHYSICAL BLOCK
		WRITEVBLK-		; WRITE VIRTUAL BLOCK
		>
	FUNCTAB	+ACP$ACCESS,-		;ACCESS FUNCTIONS
		<ACCESS,-		; ACCEESS FILE / FIND DIRECTORY ENTRY
		CREATE-			; CREATE FILE AND/OR DIRECTORY ENTRY
		>
	FUNCTAB	+ACP$DEACCESS,-		;DEACCESS FUNCTION
		<DEACCESS-		; DEACCESS FILE
		>
	FUNCTAB	+ACP$MODIFY,-		;MODIFY FUNCTIONS
		<ACPCONTROL,-		; ACP CONTROL FUNCTION
		DELETE,-		; DELETE FILE AND/OR DIRECTORY ENTRY
		MODIFY-			; MODIFY FILE ATTRIBUTES
		>
	FUNCTAB	+ACP$MOUNT,-		;MOUNT FUNCTION
		<MOUNT-			; MOUNT VOLUME
		>
	FUNCTAB	+EXE$ZEROPARM,-		;ZERO PARAMETER FUNCTIONS
		<NOP,-			; NO-OP
		UNLOAD,-		; UNLOAD
		RECAL,-			; RECALIBRATE
		DRVCLR,-		; DRIVE CLEAR
		PACKACK,-		; PACK ACKNOWLEDGE
		AVAILABLE-		; AVAILABLE
		>
	FUNCTAB	+EXE$ONEPARM,-		;ONE PARAMETER FUNCTION
		<SEEK-			; SEEK
		>
	FUNCTAB	+EXE$SENSEMODE,-	;SENSE FUNCTIONS
		<SENSECHAR,-		; SENSE CHARACTERISTICS
		SENSEMODE-		; SENSE MODE
		>
	FUNCTAB	+EXE$SETCHAR,-		;SET FUNCTIONS
		<SETCHAR,-		; SET CHARACTERISTICS
		SETMODE-		; SET MODE
		>

	.PAGE
	.SBTTL	START I/O ROUTINE

;++
; 
; DQ_STARTIO - START I/O ROUTINE
; 
; FUNCTIONAL DESCRIPTION:
; 
; 	THIS FORK PROCESS IS ENTERED FROM THE EXECUTIVE AFTER AN I/O REQUEST
; 	PACKET HAS BEEN DEQUEUED, AND PERFORMS THE FOLLOWING:
; 
; 		- ACTIVATES THE DISK AFTER SETTING UCB FIELDS, OBTAINING
; 		  UBA AND CONTROLLER RESOURCES, AND SETTING RB730 REGISTERS
; 
; 		- WAITS FOR AN INTERRUPT
; 
; 		- REGAINS CONTROL AFTER THE ISR SERVICES THE INTERRUPT, AND
; 			-  RE-ACTIVATES THE DISK IF THE ORIGINAL FUNCTION
; 			   IS NOT YET COMPLETE, OR
; 			-  COMPLETES THE I/O REQUEST BY RELEASING RESOURCES,
;			   SETTING STATUS CODES, AND RETURNING TO THE EXEC.
; 
; INPUTS:
; 
; 	R3		- IRP ADDRESS (I/O REQUEST PACKET)
; 	R5		- UCB ADDRESS (UNIT CONTROL BLOCK)
; 	IRP$L_MEDIA	- PARAMETER LONGWORD (LOGICAL BLOCK NUMBER)
; 
; OUTPUTS:
; 
; 	R0	- FIRST I/O STATUS LONGWORD: STATUS CODE & BYTES XFERED
; 	R1	- SECOND I/O STATUS LONGWORD: 0 FOR DISKS
; 
; 	THE I/O FUNCTION IS EXECUTED.
; 
; 	ALL REGISTERS EXCEPT R0-R4 ARE PRESERVED.
; 
;--

DQ_STARTIO:				;START I/O OPERATION

; 
; 	PREPROCESS UCB FIELDS
; 

PREPROCESS:				;ALTERNATE ENTRY NAME
	MOVL	IRP$L_MEDIA(R3),-	;STORE DISK ADDRESS
		UCB$L_MEDIA(R5)		;...
	BDRVTYP	RB80,10$		;BRANCH IF RB80
	BBS	#IRP$V_PHYSIO,-		;IF SET - PHYSICAL I/O
		IRP$W_STS(R3),10$	;...
	MULL3	#2,UCB$L_MEDIA(R5),R0	;RB02 HAS 1/2 SECTOR PER BLOCK
	MOVZBL	UCB$B_SECTORS(R5),R2	;GET NUMBER OF SECTORS PER TRACK
	CLRL	R1			;CLEAR HIGH PART OF DIVIDEND
	EDIV	R2,R0,R0,UCB$L_MEDIA(R5)  ;CALCULATE SECTOR NUMBER AND STORE
	MOVZBL	UCB$B_TRACKS(R5),R2	;GET NUMBER OF TRACKS PER CYLINDER
	EDIV	R2,R0,R0,R1		;CALCULATE TRACK AND CYLINDER
	MOVB	R1,UCB$L_MEDIA+1(R5)	;STORE TRACK NUMBER
	MOVW	R0,UCB$L_MEDIA+2(R5)	;STORE CYLINDER NUMBER

10$:	MOVB	UCB$B_ERTMAX(R5),-	;INITIALIZE ERROR RETRY COUNT
		UCB$B_ERTCNT(R5)	;...
	MOVW	UCB$W_BCNT(R5),UCB$W_BCR(R5)  ;INITIALIZE REMAINING BYTE COUNT
	MOVW	IRP$W_FUNC(R3),UCB$W_FUNC(R5) ;SAVE FUNCTION CODE AND MODIFIERS
	EXTZV	#IRP$V_FCODE,-		;EXTRACT I/O FUNCTION CODE
		#IRP$S_FCODE,IRP$W_FUNC(R3),R1  ;...
	MOVB	R1,UCB$B_FEX(R5)	;STORE FUNCTION DISPATCH INDEX
	CMPB	#IO$_SEEK,R1		;SEEK FUNCTION?
	BNEQ	30$			;IF NEQ - NO
	ASHL	#16,UCB$L_MEDIA(R5),-	;SHIFT CYLINDER ADDRESS
		UCB$L_MEDIA(R5)		;...INTO HIGH WORD
30$:	BICW	#UCB$M_DIAGBUF-		;CLEAR DIAGNOSTIC BUFFER PRESENT
		!UCB$M_ECC,-		;...AND ECC CORRECTION MADE FLAGS
		UCB$W_DEVSTS(R5)	;...IN DEVICE STATUS WORD
	BBC	#IRP$V_DIAGBUF,-	;IF CLR - NO DIAG BUFFER
		IRP$W_STS(R3),FDISPATCH ;...
	BISW	#UCB$M_DIAGBUF,UCB$W_DEVSTS(R5)  ;SET DIAG BUFFER PRESENT


; 
; 	CENTRAL FUNCTION DISPATCH
;

FDISPATCH:				;FUNCTION DISPATCH
	MOVL	UCB$L_IRP(R5),R3	;GET IRP ADDRESS
	BBS	#IRP$V_PHYSIO,-		;IF SET - PHYSICAL I/O FUNCTION
		IRP$W_STS(R3),10$	;...
	BBS	#UCB$V_VALID,-		;IF SET - VOLUME SOFTWARE VALID
		UCB$W_STS(R5),10$	;...
	MOVZWL	#SS$_VOLINV,R0		;SET VOLUME INVALID STATUS
	CLRW	UCB$W_BCNT(R5)		;SET ZERO BYTES TRANSFERRED
	BRW	FUNCXT			;AND RETURN TO CALLER

10$:	CLRB	UCB$B_DQ_FLAGS(R5)	;CLEAR LOCAL FLAGS
	MOVZBL	UCB$B_FEX(R5),R3	;GET FUNCTION DISPATCH INDEX
	CASE	R3,<-			;DISPATCH TO FUNCTION HANDLING ROUTINE
		NOP,-			; NO OPERATION
		UNLOAD,-		; UNLOAD
		SEEK,-			; SEEK
		RECAL,-			; RECALIBRATE
		DRVCLR,-		; DRIVE CLEAR
		RELEASE,-		; RELEASE
		OFFSET,-		; OFFSET HEADS
		RETCENTER,-		; RETURN TO CENTER
		PACKACK,-		; PACKACK
		STARTSPNDL,-		; START SPINDLE
		WRITECHECK,-		; WRITE CHECK
		WRITEDATA,-		; WRITE DATA
		READDATA,-		; READ DATA
		WRITEHEAD,-		; WRITE HEADER
		READHEAD,-		; READ HEADER
		WRITETRACKD,-		; WRITE TRACK DESCRIPTOR
		READTRACKD,-		; READ TRACK DESCRIPTOR
		AVAILABLE,-		; UNIT AVAILABLE
		>

;
; IO$_UNLOAD AND IO$_AVAILABLE INDICATE THE UNIT IS NOT MOUNTED
; SO WE CLEAR SOFTWARE VOLUME VALID.  IO$_PACKACK INDICATES THAT
; SOFTWARE IS READY TO MOUNT OR ACCESS VOLUE SO WE SET SOFTWARE
; VALID.  ON PACKACKS'S WE FOLLOW THIS WITH A GET STATUS AND RESET.
; IF THE OBTAINED STATUS INDICATES THAT THE DRIVE IS NOT READY
; THEN VOLUME VALID WILL BE CLEARED.
;

PACKACK:				;PACK ACKNOWLEDGE
	BBSS	#UCB$V_VALID,-		;SET SOFTWARE VOLUME VALID
		UCB$W_STS(R5),NOP	;...
	EXFUNCL	RETRYERR,F_DRVCLR	;GET STS AND RESET, RETRY ERRORS
	BRB	NORMAL			;SUCCESSFUL - EXIT WITH NORMAL STATUS

UNLOAD:					;UNLOAD
AVAILABLE:				;UNIT AVAILABLE
	BBCC	#UCB$V_VALID,-		;CLEAR SOFTWARE VALID
		UCB$W_STS(R5),NOP	;...
NOP:					;NO-OP
RELEASE:				;RELEASE PORT (NOP)
OFFSET:					;OFFSET HEADS (NOP)
RETCENTER:				;RETURN TO CENTERLINE (NOP)
STARTSPNDL:				;START SPINDLE (NOP)
WRITETRACKD:				;WRITE TRACK DESCRIPTOR (NOP)
READTRACKD:				;READ TRACK DESCRIPTOR (NOP)
	EXFUNCL	RETRYERR,F_NOP		;EXECUTE A HARDWARE NOP, RETRY ERRORS
	BRB	NORMAL			;SUCCESSFUL - EXIT WITH NORMAL STATUS

SEEK:					;SEEK
RECAL:					;RECALIBRATE
DRVCLR:					;DRIVE CLEAR (GET STATUS & RESET)
WRITEHEAD:				;WRITE HEADERS (AND DATA)
	EXFUNCL	RETRYERR		;EXECUTE FUNCTION - RETRY IF FAILURE
	BRB	NORMAL			;SUCCESSFUL - EXIT WITH NORMAL STATUS

WRITECHECK:				;WRITE CHECK
READHEAD:				;READ HEADER
	BICW	#IO$M_DATACHECK,-	;CLEAR DATA CHECK REQUEST-
		UCB$W_FUNC(R5)		;TO PREVENT EXTRA WRITE CHECK

WRITEDATA:				;WRITE DATA
READDATA:				;READ DATA
	CMPW	UCB$L_MEDIA+2(R5),-	;NEW CYLINDER?
		UCB$L_DQ_CURDA+2(R5)	;...
	BNEQ	20$			;BRANCH IF SO
	BDRVTYP	RB80,TRANSFER		;BRANCH IF RB80
	CMPB	UCB$L_MEDIA+1(R5),-	;OR NEW TRACK? (MUST DO SEEK TO
		UCB$L_DQ_CURDA+1(R5)	;...SELECT HEAD ON RB02)
	BEQL	TRANSFER		;BRANCH IF NO SEEK REQUIRED
20$:	EXFUNCL	RETRYERR,F_SEEK		;EXECUTE EXPLICIT SEEK - RETRY IF ERROR
	MOVZBL	UCB$B_FEX(R5),R3	;RESTORE FUNCTION DISPATCH INDEX

;
;	DRIVE HAS BEEN POSITIONED -- NOW EXECUTE THE TRANSFER
;

TRANSFER:
	EXFUNCL	CHECKECC		;EXECUTE TRANSFER FUNCTION


; 
; 	OPERATON COMPLETION
; 

NORMAL:					;SUCCESSFUL OPERATION COMPLETE
	MOVZWL	#SS$_WASECC,R0		;ASSUME CORRECTED ECC ERROR
	BBS	#UCB$V_ECC,-		;BRANCH IF CORRECTED ECC
		UCB$W_DEVSTS(R5),10$	;...ERROR OCCURED
	MOVZWL	#SS$_NORMAL,R0		;SET NORMAL COMPLETION STATUS
10$:	BRW	FUNCXT			;FUNCTION EXIT

	.PAGE
	.SBTTL	RETRIABLE ERROR ANALYSIS
;
;	A RETRIALABLE ERROR HAS OCCURED ON A TRANSFER
;	CHECK TO SEE IF ECC CORRECTION CAN BE APPLIED
;
;	R1	- CSR AT TIME OF ERROR
;	R2	- MPR OF GET STATUS FOLLOWING ERROR
;
CHECKECC:
	CMPZV	#RB_CS_V_FCODE,-	;WAS THIS A READ DATA OPERATION?
		#RB_CS_S_FCODE,R1,-	;...
		#<F_READDATA @ -1>	;...
	BNEQ	RETRYERR		;BRANCH IF NOT
	BDRVTYP	RB02,RETRYERR		;BRANCH IF RB02
	BITW	#RB_CS_M_DE-		;DRIVE ERROR
		!RB_CS_M_NXM-		;...OR NON EXISTENT MEMORY
		!RB_CS_M_DLT-		;...OR DATA LATE
		!RB_CS_M_OPI,-		;...OR OPERATION INCOMPLETE (HDR CRC)
		R1			;...?
	BNEQ	RETRYERR		;BRANCH IF SO
	BBC	#RB_CS_V_DCK,R1,RETRYERR;BRANCH IF NOT A DATACHECK
	CMPZV	#RB_CS_V_ECS,-		;COMPARE ECC STATUS BITS (START)
		#RB_CS_S_ECS,-		;...(SIZE)
		R1,-			;...(FROM)
		#^B11			;...TO BINARY 11 (BOTH SET)
	BNEQ	RETRYERR		;BRANCH IF NOT CORRECTABLE

;
;	THIS IS A CORRECTABLE ECC ERROR -- FINISH PROCESSING THE
;	GOOD BLOCKS IN FRONT OF THE ERROR, REREAD THE ERROR BLOCK,
;	AND THEN APPLY CORRECTION IF ERROR OCCURS AGAIN
;
	BICW	#RB_CS_M_CE,-		;CLEAR COMBINED ERROR IN
		UCB$L_DQ_CS(R5)		;...CASE WE CONTINUE
	MOVZWL	UCB$W_BCNT(R5),R0	;FETCH ORIGINAL XFER COUNT
	ADDL	UCB$L_DQ_BC(R5),R0	;COMPUTE BYTES TRANSFERED
	SUBL	#^X200,R0		;BACKUP TO LAST GOOD BLOCK
	BEQL	20$			;BRANCH IF ERROR OCCURED ON 1ST BLOCK
	BLSS	RETRYERR		;NEGATIVE, SOMETHING WRONG, TRY AGAIN
	BITW	#^X1FF,R0		;WHOLE BLOCKS TRANSFERED?
	BNEQ	RETRYERR		;NO, SOMETHING WRONG, TRY AGAIN
	SUBW	#^X200,UCB$W_BCNT(R5)	;SHORTEN XFER BY ONE PAGE
	BRW	WRITECHK		;CONTINUE PROCESSING

20$:	JSB	G^IOC$APPLYECC		;APPLY ECC CORRECTION
	MOVW	#^X200,UCB$W_BCNT(R5)	;CORRECT BYTES TRANSFERRED
	BRW	UPDATE			;CONTINUE TRANSFER BUT SUPPRESS
					;...WRITECHECK OF ECC BLOCK
	
	
;
;	A RETRIABLE ERROR HAS OCCURED
;
;	R1	- CSR AT TIME OF ERROR
;	R2	- MPR OF GET STATUS FOLLOWING ERROR
;

RETRYERR:
	DECB	UCB$B_ERTCNT(R5)	;ANY RETRIES LEFT?
	BLEQ	FATALERR		;IF EQL - NO

;
; ATTEMPT TO RESET STUBBORN DRIVE ERRORS BEFORE EXECUTING THE FUNCTION AGAIN
;

RESETDRIVE:
	EXFUNCL	RETRYERR,F_RECAL	;RECALIBRATE THE DRIVE
	BRW	FDISPATCH		;RETRY FUNCTION

	.PAGE
	.SBTTL	FATAL ERROR ANALYSIS

;
;	A FATAL ERROR HAS OCCURED
;
;	R1	- CSR AT TIME OF ERROR OR 
;	R2	- MPR OF GET STATUS FOLLOWING ERROR
;
FATALERR:				;UNRECOVERABLE ERROR
	ASSUME	RB_MP_V_WL EQ RB_MP_V_WTP	;ASSUME RB02 AND RB80 USE
						;SAME BIT FOR WRITE LOCK

	BBC	#RB_MP_V_WL,R2,30$	;BRANCH IF DRIVE IS NOT WRITELOCKED
	MOVZWL	#SS$_WRITLCK,R0		;ASSUME WRITELOCK ERROR STATUS
	CMPB	#CDF_WRITEDATA,-	;WAS THIS A WRITE DATA OPERATION?
		UCB$B_CEX(R5)		;...
	BEQL	FUNCXT			;BRANCH IF SO
	CMPB	#CDF_WRITEHEAD,-	;WAS THIS A WRITE HEADER OPERATION?
		UCB$B_CEX(R5)		;...
	BEQL	FUNCXT			;BRANCH IF SO

30$:	MOVZWL	#SS$_VOLINV,R0		;ASSUME VOLUME INVALID
	BDRVTYP	RB02,50$		;BRANCH IF RB02

;
;	RB80 ERROR ANALYSIS
;
	BRB	70$			;CONTINUE IN COMMON


;
;	RB02 ERROR ANALYSIS
;
	
50$:	BBS	#RB_MP_V_VC,R2,FUNCXT	;IF SET - VOLUME INVALID
	MOVZWL	#SS$_WRITLCK,R0		;ASSUME WRITE LOCK ERROR STATUS
	BBC	#RB_MP_V_WL,R2,70$	;IF CLR - VOLUME NOT WRITE LOCKED
	BBS	#RB_MP_V_WGE,R2,FUNCXT	;IF SET - WRITE GATE ERROR

70$:	MOVZWL	#SS$_DATACHECK,R0	;ASSUME DATA CHECK ERROR STATUS
	BBC	#UCB$V_DQ_DIP,-		;BRANCH IF NO DATA CHECK IN PROGRESS
		UCB$B_DQ_FLAGS(R5),80$	;...
	BBC	#RB_CS_V_OPI,R1,80$	;DATA CHECK INDICATED BY OPI AND
	BBS	#RB_CS_V_DCK,R1,FUNCXT	;... DATA CHECK SET

80$:	MOVZWL	#SS$_PARITY,R0		;ASSUME PARITY ERROR STATUS
	BBS	#RB_CS_V_DCK,R1,FUNCXT	;IF SET - CRC ERROR
	BBC	#RB_CS_V_OPI,R1,90$	;HEADER NOT FOUND ERROR?
	BBS	#RB_CS_V_DLT,R1,FUNCXT	;IF OPI & DLT SET - YES

90$:	MOVZWL	#SS$_DRVERR,R0		;ASSUME DRIVE ERROR STATUS
	BBS	#RB_CS_V_DE,R1,FUNCXT	;IF SET - DRIVE ERROR

	MOVZWL	#SS$_CTRLERR,R0		;ASSUME CONTROLLER ERROR STATUS

	.PAGE
	.SBTTL	FUNCTION COMPLETION

;
;	HERE WHEN THE FUNCTION IS COMPLETE (OR ABORTED) TO
;	EXIT FROM DRIVER WITH REQUEST COMPLETE
;

FUNCXT:				;FUNCTION EXIT
	PUSHL	R0			;SAVE FINAL REQUEST STATUS
	JSB	G^IOC$DIAGBUFILL	;FILL DIAGNOSTIC BUFFER IF PRESENT
	CMPB	#CDF_WRITECHECK,UCB$B_FEX(R5)  ;DRIVE RELATED FUNCTION?
	BGTRU	50$			;IF GTRU - YES
	MOVL	UCB$L_IRP(R5),R3	;RETRIEVE ADDRESS OF IRP
	BLBS	(SP),10$		;BRANCH IF XFER SUCCESSFUL
;
;THE TRANSFER ENDED IN AN ERROR -- COMPUTE BYTES SUCCESSFULLY TRANSFERRED.
;THE BYTE-COUNT-REMAINING REPORTED BY THE DRIVE CANNOT BE TRUSTED IF A
;DRIVE ERROR OCCURED.
;
	BBS	#RB_CS_V_DE,R1,10$	;IGNORE FINAL SEGMENT IF DRIVE ERROR
	SUBW	UCB$W_BCNT(R5),-	;UPDATE BCR WITH PARTIAL XFER COUNT
		UCB$W_BCR(R5)		;...FROM FINAL SEGMENT
10$:	SUBW3	UCB$W_BCR(R5),-		;CALCULATE BYTES TRANSFERRED
		IRP$W_BCNT(R3),2(SP)	;...

50$:	RELCHAN				;RELEASE CHANNEL IF OWNED
	CLRL	R1			;CLEAR SECOND STATUS LONGWORD
	POPL	R0			;RETRIEVE FINAL REQUEST STATUS
	REQCOM				;COMPLETE REQUEST

	.PAGE
	.SBTTL	HARDWARE FUNCTION DISPATCH
; 
; FEXL - RB730 HARDWARE FUNCTION EXECUTION 
; 
; THIS ROUTINE IS CALLED VIA A BSB WITH A BYTE IMMEDIATELY FOLLOWING THAT
; SPECIFIES THE ADDRESS OF AN ERROR ROUTINE. ALL DATA IS ASSUMED TO HAVE BEEN
; SET UP IN THE UCB BEFORE THE CALL. THE APPROPRIATE PARAMETERS ARE LOADED
; INTO DEVICE REGISTERS AND THE FUNCTION IS INITIATED. THE RETURN ADDRESS
; IS STORED IN THE UCB AND A WAITFOR INTERRUPT IS EXECUTED. WHEN THE
; INTERRUPT OCCURS, CONTROL IS RETURNED TO THE CALLER.
; 
; INPUTS:
; 
; 	R3 = FUNCTION TABLE DISPATCH INDEX
; 	R5 = DEVICE UNIT UCB ADDRESS
; 
; 	00(SP) = RETURN ADDRESS OF CALLER
; 	04(SP) = RETURN ADDRESS OF CALLER'S CALLER
; 
; 	IMMEDIATELY FOLLOWING INLINE AT THE CALL SITE IS A BYTE WHICH CONTAINS
; 	A BRANCH DESTINATION TO AN ERROR RETRY ROUTINE.
; 
; OUTPUTS:
; 
; 	THERE ARE FOUR EXITS FROM THIS ROUTINE:
; 
; 	1. SPECIAL CONDITION - THIS EXIT IS TAKEN IF A POWER FAILURE OCCURS
; 		OR THE OPERATION TIMES OUT. IT IS A JUMP TO THE APPROPRIATE
; 		ERROR ROUTINE.  NO DEVICE REGISTERS ARE SAVED.
; 
; 	2. FATAL ERROR - THIS EXIT IS TAKEN IF A FATAL CONTROLLER OR DRIVE
; 		ERROR OCCURS OR IF ANY ERROR OCCURS AND ERROR RETRY IS EITHER
; 		INHIBITED OR EXHAUSTED. IT IS A JUMP TO THE FATAL ERROR EXIT
; 		ROUTINE.  ALL DEVICE REGISTERS ARE SAVED.
; 
; 	3. RETRIABLE ERROR - THIS EXIT IS TAKEN IF A RETRIABLE CONTROLLER
; 		OR DRIVE ERROR OCCURS AND ERROR RETRY IS NEITHER INHIBITED
; 		NOR EXHAUSTED. IT CONSISTS OF TAKING THE ERROR BRANCH EXIT
; 		SPECIFIED AT THE CALL SITE.  ALL DEVICE REGISTERS ARE SAVED.
; 
; 	4. SUCCESSFUL OPERATION - THIS EXIT IS TAKEN IF NO ERRORS OCCUR
; 		DURING THE OPERATION. IT CONSISTS OF A RETURN INLINE.
;		ONLY THE CSR IS SAVED.
; 
; 	IN ALL CASES IF AN ERROR OCCURS, AN ATTEMPT IS MADE TO LOG THE ERROR.
; 
; 	
; 
	.PAGE
FEXL:					;FUNCTION EXECUTOR 
	POPL	UCB$L_DPC(R5)		;SAVE DRIVER PC VALUE
	MOVB	R3,UCB$B_CEX(R5)	;SAVE CASE INDEX
	MOVL	UCB$L_CRB(R5),R0	;GET ADDRESS OF PRIMARY CRB
	MOVL	CRB$L_INTD+VEC$L_IDB(R0),R1  ;GET ADDRESS OF IDB
	CMPL	R5,IDB$L_OWNER(R1)	;DOES THIS PROCESS OWN CHANNEL?
	BNEQ	10$			;IF NEQ - NO
	MOVL	IDB$L_CSR(R1),R4	;SET ASSIGNED CHANNEL CSR ADDRESS
	BRB	20$			;
10$:	REQPCHAN			;REQUEST CHANNEL (RETURNS R4 = CSR ADR)

20$:	CASE	R3,<-			;DISPATCH TO PROPER FUNCTION ROUTINE
		IMMED,-			;NO OPERATION
		IMMED,-			;UNLOAD VOLUME (NOP)
		POSIT,-			;SEEK CYLINDER
		RECALB,-		;RECALIBRATE
		DRCLR,-			;DRIVE CLEAR (GET STATUS & RESET)
		IMMED,-			;RELEASE DRIVE (NOP)
		IMMED,-			;OFFSET HEADS (NOP)
		IMMED,-			;RETURN TO CENTERLINE (NOP)
		DRCLR,-			;PACK ACKNOWLEDGE 
		IMMED,-			;START SPINDLE (NOP)
		>			;
	BRW	XFER			;TRANSFER FUNCTION
	.PAGE
	.SBTTL	IMEDIATE FUNCTION EXECUTION
; 
; IMMEDIATE FUNCTION EXECUTION
; 
; 	FUNCTIONS INCLUDE:
; 
; 		NO OPERATION,
; 		DRIVE CLEAR, AND
; 		PACK ACKNOWLEDGE
; 
; INPUTS:
; 	R3	- CASE INDEX
; 	R4	- CSR ADDRESS
; 	R5	- UCB ADDRESS
; 
; FUNCTIONAL DESRIPTION:
; 
; INTERRUPTS ARE LOCKED OUT, THE APPROPRIATE FUNCTION IS INITIATED WITH
; INTERRUPT ENABLE, AND A WAITFOR INTERRUPT AND KEEP CHANNEL IS EXECUTED.
;
; THE RESET COMMAND DOES NOT AFFECT AN R80 SO A RECALIBRATE, WHICH CLEARS
; ERRORS, IS PERFORMED INSTEAD
; 

DRCLR:				;GET STATUS AND RESET
	BDRVTYP	RB02,10$		;BRANCH IF RB02
	MOVZBL	#CDF_RECAL,R3		;SET FUNCTION AS RECALIBRATE
	MOVB	R3,UCB$B_CEX(R5)	;SAVE CASE INDEX
	BRB	RECALB			;AND BRANCH TO EXECUTION

10$:	MOVL	#RB_MP_M_STS-		;GET STATUS AND
		!RB_MP_M_RST-		;...RESET DRIVE
		!RB_MP_M_MRK,-		;...INDICATE GET STATUS COMMAND PRESENT
		R0			;...IN R0
	BRB	EX_IMED			;EXECUTE THE FUNCTION
 
IMMED:				;GET STATUS
	MOVL	#RB_MP_M_STS-		;GET STATUS AND
		!RB_MP_M_MRK,-		;...INDICATE GET STATUS COMMAND PRESENT
		R0	  		;...IN R0

EX_IMED:			;EXECUTE IMMEDIATE FUNCTION
	MOVL	FTAB[R3],R2		;FETCH FUNCTION CODE AND MODIFIERS
	INSV	UCB$W_UNIT(R5),#8,#2,R2	;MERGE UNIT NUMBER
	SAVIPL				;SAVE CURRENT IPL ON STACK
	CKPWR	10$			;RAISE IPL AND CHECK FOR POWERFAIL
	MOVL	R0,RB_MP(R4)		;PREPARE FOR GETSTATUS OR RESET
	MOVL	R2,RB_CS(R4)		;INITIATE FUNCTION
	WFIKPCH	RETREG,#10		;WAITFOR INTERRUPT
	IOFORK				;CREATE FORK PROCESS
10$:	BRW	RETREG			;

	.PAGE
	.SBTTL	RECALIBRATE FUNCTION EXECUTION
; 
; RECALIBRATE FUNCTION EXECUTION
; 
; 	FUNCTIONS INCLUDE:
; 
; 		RECALIBRATE
; 
; INPUTS:
; 	R3	- CASE INDEX
; 	R4	- DEVICE CSR ADDRESS
; 	R5	- UCB ADDRESS
; 
; FUNCTIONAL DESRIPTION:
; 
; FOR AN RB80, A RECALIBRATE IS PERFORMED.  THE HEADS SEEK TO A KNOWN
; POSITION TO RESET THE DRIVES PHYSICAL POSITIONING LOGIC.  THIS IS
; SIGNALED BY REQUESTING A SEEK TO -1
;
; FOR AN RB02, A READ HEADER IS PERFORMED.  THE RB02 DOES NOT SUPPORT
; A RECALIBRATE FUNCTION.  HOWEVER, THE SUPPORT MICROCODE FOR THE RB02
; KEEPS AN INTERNAL RECORD OF THE CURRENT DISK POSITION.  WHENEVER A
; READ HEADER IS PERFORMED, IT UPDATES THAT POSITION WITH THE VALUE
; FOUND IN THE HEADER.
; 

RECALB:					;RECALIBRATE FUNCTION
	MNEGL	#1,UCB$L_DQ_CURDA(R5)	;DISABLE SEEK OPTIMIZATION
	BDRVTYP	RB02,50$		;BRANCH IF RB02
	GETUNIT				;GET UNIT NUMBER IN R2
	DSBINT	UCB$B_DIPL(R5)		;SAVE IPL AND LOCK OUT DEVICE INTERUPTS
	BISL3	FTAB[R3],R2,RB_CS(R4)	;LOAD CSR (EXECUTION SUPPRESED)
	BITL	#RB_CS_M_DRDY,RB_CS(R4)	;IS DRIVE READY?
	BNEQ	10$			;BRANCH IF SO
	MNEGL	#1,RB_CMD(R4)		;INITIALIZE ENTIRE SUBSYSTEM
10$:	MNEGL	#1,RB_DA(R4)		;LOAD -1 IN DISK ADDRESS REGISTER
	BRB	SEEKI			;INITIATE SEEK

50$:	MOVZBL	#CDF_READHEAD,R3	;SET FUNCTION AS READ HEADER
	MOVB	R3,UCB$B_CEX(R5)	;SAVE CASE INDEX
	BRW	XFER			;EXECUTE TRANSFER FUNCTION

	.PAGE
	.SBTTL	POSITIONING FUNCTION EXECUTION
; 
; POSITIONING FUNCTION EXECUTION
; 
; 	FUNCTIONS INCLUDE:
; 
; 		SEEK CYLINDER
; 
; INPUTS:
; 	R3	- CASE INDEX
; 	R4	- DEVICE CSR ADDRESS
; 	R5	- UCB ADDRESS
; 
; FUNCTIONAL DESRIPTION:
; 
; THE CYLINDER ADDRESS IS LOADED INTO THE DISK ADDRESS REGISTER.
; INTERRUPTS ARE LOCKED OUT, AND THE SEEK FUNCTION IS INITIATED.
; WITH INTERRUPT ENABLE.  THE UNIT MUST BE SELECTED BEFORE LOADING
; THE CYLINDER ADDRESS (SO UCODE KNOWS WHETHER ITS AN RB80 OR RB02).
;
; WHEN THE FIRST INTERRUPT IS RECEIVED THE CHANNEL IS RELEASED (MUST
; OCCUR AT FORK LEVEL) AND THE COMPLETION INTERRUPT IS WAITED FOR.
; THE SEEK MAY COMPLETE WHILE AT FORK LEVEL SO A FLAG IS USED TO
; SYNCRONIZE THE OPERATION.
;
; 

POSIT:					;POSITIONING FUNCTION
	GETUNIT				;GET UNIT NUMBER IN R2
	DSBINT	UCB$B_DIPL(R5)		;SAVE IPL AND LOCK OUT DEVICE INTERUPTS
	BISL3	FTAB[R3],R2,RB_CS(R4)	;LOAD CSR (EXECUTION SUPPRESED)
	MOVL	UCB$L_MEDIA(R5),RB_DA(R4) ;LOAD CYLINDER ADDRESS IN DAR
	MOVL	UCB$L_MEDIA(R5),-	;REMEMBER CURRENT DISK ADDRESS
		UCB$L_DQ_CURDA(R5)	;...FOR SEEK OPTIMIZATION

SEEKI:					;SEEK INITIATE
	CKPWR	25$			;DISABLE INTERRUPTS, CHECK POWER
	INITIATE			;INITIATE THE FUNCTION
	BISB	#UCB$M_DQ_SIP,-		;SIGNAL SEEK IN PROGRESS
		UCB$B_DQ_FLAGS(R5)	;...
	BDRVTYP	RB02,10$		;BRANCH IF RB02
;
; RB80'S INITIATE SEEKS VERY QUICKLY (APPROX 30 USECS).  CONSEQUENTLY
; WE WAIT FOR THE SEEK TO INITIATE IN A LOOP, THEN CLEAR THE INITIATION
; INTERRUPT AND WAIT FOR THE COMPLETION INTERRUPT.
;

	TIMEWAIT #3,#RB_CS_M_CRDY,-	;WAIT FOR CONTROLLER READY
		RB_CS(R4),L		;... 3*10 MICS
	BLBC	R0,10$			;BRANCH IF CONTROLLER STILL NOT READY
	BICL	#RB_CS_M_ATN,RB_CS(R4)	;CLEAR INTERRUPT REQUEST FROM INITIATE
	ENBINT				;DROP IPL AND CLEANUP STACK
	BRB	20$			;
;
; RB02'S CAN TAKE UPTO A FULL SECTOR TIME TO INITIATE AN INTERRUPT.
; CONSEQUENTLY WE TAKE TWO INTERUPTS, ONE FOR SEEK INITIATE, THE OTHER
; FOR SEEK COMPLETION
;
10$:	WFIKPCH	RETREG,#10		;WAIT FOR INITIATION INTERRUPT
	BBS	#RB_CS_V_CE,-		;BRANCH IF SEEK INITIATE FAILED
		UCB$L_DQ_CS(R5),40$	;...
	IOFORK				;DROP TO FORK IPL
20$:	RELCHAN				;RELEASE THE CHANNEL
	DSBINT	UCB$B_DIPL(R5)		;RETURN TO DEVICE IPL
	BBSC	#UCB$V_DQ_SIP,-		;BRANCH IF SEEK NOT COMPLETED YET
		UCB$B_DQ_FLAGS(R5),30$	;...
	ENBINT				;RESTORE IPL
25$:	BRB	50$			;DON'T WAIT FOR A SECOND INTERRUPT
30$:	WFIKPCH	RETREG,#10		;WAIT FOR COMPLETION (CHANNEL RELEASED)
40$:	IOFORK				;DROP TO FORK IPL
50$:	BRW	RETREG			;SEEK COMPLETION

	.PAGE
	.SBTTL	TRANSFER FUNCTION EXECUTION

; 
; TRANSFER FUNCTION EXECUTION
; 
; 	FUNCTIONS INCLUDE:
; 
; 		WRITE CHECK
; 		WRITE DATA
; 		READ DATA, AND
; 		READ HEADER
; 
; INPUTS:
; 	R3	- CASE INDEX
; 	R4	- DEVICE CSR ADDRESS
; 	R5	- UCB ADDRESS
; 
; FUNCTIONAL DESCRIPTION:
; 
; THE TRANSFER PARAMETERS ARE LOADED INTO THE DEVICE REGISTERS, INTERRUPTS
; ARE LOCKED OUT, THE FUNCTION IS INITIATED, AND A WAITFOR INTERRUPT AND
; KEEP CHANNEL IS EXECUTED.
; 
; UPON RETURN FROM THE INTERRUPT SERVICE ROUTINE, IF THE TRANSFER IS 
; COMPLETE, THE APPROPRIATE EXIT IS TAKEN. IF THE FUNCTION IS NOT COMPLETE
; TRANSFER PARAMETERS ARE UPDATED AND A RETURN TO FDISPATCH IS EXECUTED TO 
; RE-ISSUE SEEK AND TRANSFER FUNCTIONS WHILE KEEPING CHANNEL AND UBA 
; RESOURCES. IF A DATA CHECK HAS BEEN REQUESTED, IT IS PERFORMED
; BEFORE RETURNING TO FDISPATCH.
; 

XFER:					;TRANSFER FUNCTION EXECUTION
;
; LOAD UBA MAPS
;
	MOVW	UCB$W_BCR(R5),-		;GET BYTES LEFT TO TRANSFER AND -
		UCB$W_BCNT(R5)		;ASSUME ONLY ONE TRANSFER NEEDED
	CMPB	#CDF_READHEAD,R3	;IS THIS A READ HEADER OPERATION
	BEQL	NOMAPS			;BRANCH IF SO, DON'T NEED MAPS


; 
; COMPUTE SIZE OF THIS TRANSFER -- MAXIMUM = 1 TRACK 
; 
	MOVZBL	UCB$B_SECTORS(R5),R2	;GET SECTORS/SURFACE
	SUBB	UCB$W_DA(R5),R2		;CALCULATE SECTORS LEFT ON SURFACE
	MULW	#256,R2			;COMPUTE BYTES REMAINING ON SURFACE
	BDRVTYP	RB02,10$		;BRANCH IF AN RB02
	MULW	#2,R2			;RB80 HAS 512 BYTE SECTORS
	BBC	#IO$V_SKPSECINH,-	;BRANCH NO SKIP SECTOR INHIBIT
		UCB$W_FUNC(R5),10$	;...
	ADDW	#512,R2			;ALLOW ACCESS TO 32ND SECTOR
10$:	CMPW	UCB$W_BCNT(R5),R2	;ARE ADDITIONAL TRANSFERS REQUIRED?
	BLEQU	20$			;BRANCH IF NOT
	MOVW	R2,UCB$W_BCNT(R5)	;STORE PARTIAL TRANSFER BYTE COUNT
20$:	LOADUBAA			;LOAD UNIBUS MAP REGISTERS

;
; MAPS LOADED (IF NECESSARY) AND BYTE COUNT DETERMINED.
; LOAD BYTE COUNT
;

NOMAPS:
	DSBINT	UCB$B_DIPL(R5)		;SAVE IPL AND LOCK OUT DEVICE INTERUPTS
	MOVZWL	UCB$W_BCNT(R5),R2	;FETCH BYTE COUNT
	MNEGL	R2,RB_BC(R4)		;SET NEGATIVE BYTE COUNT


;
; COMPUTE AND LOAD 18 BIT UNIBUS ADDRESS
;

	MOVZWL	UCB$W_BOFF(R5),R0	;FETCH BYTE OFFSET
	MOVL	UCB$L_CRB(R5),R1	;GET CRB ADDRESS
	INSV	CRB$L_INTD+VEC$W_MAPREG(R1),-  ;INSERT STARTING MAP REGISTER
		#9,#9,R0		;...NUMBER IN HIGH NINE BITS
	MOVL	R0,RB_BA(R4)		;SET BUFFER ADDRESS


; 
; PERFORM R80 TRACK-TO-TRACK SPIRALLING
;	THE R80 CAN CHANGE HEADS JUST BY LOADING A SEEK COMMAND,
;	AND LOADING THE DAR.  WE TAKE ADVANTAGE OF THIS FEATURE
;	TO REDUCE SEEK TIMES
;

	GETUNIT				;GET UNIT NUMBER IN R2
	CMPB	UCB$L_MEDIA+1(R5),-	;COMPARE DESIRED TRACK
		UCB$L_DQ_CURDA+1(R5)	;...TO CURRENT TRACK
	BEQL	20$			;BRANCH IF ON TRACK
	CMPB	#CDF_READHEAD,R3	;IS THIS A READ HEADER OPERATION?
	BEQL	20$			;BRANCH IF SO, DON'T CHANGE HEADS
	BISL3	FTAB+<CDF_SEEK*4>,R2,-	;SET CONTROLLER TO SEEK MODE
		RB_CS(R4)		;...
	MOVL	UCB$L_MEDIA(R5),RB_DA(R4) ;DO A HEAD SELECT
	MOVB	UCB$L_MEDIA+1(R5),-	;UPDATE CURRENT DISK ADDRESS
		UCB$L_DQ_CURDA+1(R5)	;...WITH NEW TRACK

; 
; EXECUTE THE TRANSFER FUNCTION --
;	NOTE: THE FUNCTION MUST BE SPECIFIED BEFORE LOADING THE DAR
;	BECAUSE THE UCODE MUST KNOW WHETHER THE TRANSFER IS TO AN
;	RB02 OR AN RB80.
; 

20$:	BBC	#IO$V_SKPSECINH,-	;BRANCH NO SKIP SECTOR INHIBIT
		UCB$W_FUNC(R5),30$	;...
	BISL	#RB_CS_M_SSEI-		;INHIBIT SKIP SECTOR ERRORS
		!RB_CS_M_ASSI,R2	;...AND AUTOMATIC SKIP SECTORING
30$:	BISL3	FTAB[R3],R2,RB_CS(R4)	;LOAD UNIT NUMBER AND FUNCTION
	CKPWR	BRW_RETREG		;DISABLE INTERRUPTS, CHECK POWER
	MOVL	UCB$L_MEDIA(R5),RB_DA(R4);SET DESIRED DISK ADDRESS
	INITIATE			;INITIATE THE FUNCTION
	WFIKPCH	RETREG,#10		;WAITFOR INTERRUPT AND KEEP CHANNEL
;
;THE R80 PRODUCES SPURIOUS ATTENTION BITS ON XFER'S.  UNTIL FIXED WE
;FOLLOW EACH TRANSFER WITH AN EXPLICIT CLEAR OF THE UNIT'S ATTENTION BIT.
;
	ASHL	#RB_CS_V_ATN,#^X0F,R1	;FORM BIT MASK
	MOVZWL	UCB$W_UNIT(R5),R0	;FETCH UNIT NUMBER
	ADDL	#RB_CS_V_ATN,R0		;POINT INTO MASK
	BBCC	R0,R1,50$		;CLEAR THIS UNIT'S ATTENTION BIT
50$:	BICL	R1,RB_CS(R4)		;CLEAR THIS UNIT'S BIT IN THE CSR
	IOFORK				;CREATE FORK PROCESS (RETURN TO ISR)
	BBC	#RB_CS_V_CE,-		;BRANCH IF NO ERRORS
		UCB$L_DQ_CS(R5),RETHDR	;...
BRW_RETREG:			; WORD DISPLACEMENT, UNCONDITIONAL BRANCH
	BRW	RETREG			;RETURN REGISTERS

	.PAGE
	.SBTTL	TRANSFER POST PROCESSING

; 
; PURGE DATAPATH -- NOTE: THE DATAPATH IS NOT PURGED BECAUSE THIS
; DRIVER IS SPECIFIC TO THE VAX730 PROCESS WHICH DOES NOT REQUIRE
; DATAPATH PURGING. CONSEQUENTLY THE DATAPATH REGISTER WILL ALWAYS
; BE ZERO IN ERRLOG AND DIAGNOSTIC BUFFERS.
;


; 
; RETURN HEADER INFORMATION FOR READ HEADER FUNCTION --
; IF AN INTERNAL READY HEADER THEN SIMPLY EXIT.
; 

RETHDR:				;RETURN HEADER INFO
	CMPB	#CDF_READHEAD, -	;WAS THIS A READ HEADER?
		UCB$B_CEX(R5)		;...
	BNEQ	WRITECHK		;BRANCH IF NOT
	CMPB	#IO$_READHEAD, -	;INTERNAL READ HEADER?
		UCB$B_FEX(R5)		;...
	BNEQ	BRW_RETREG		;BRANCH IF SO
	PUSHL	UCB$L_SVAPTE(R5)	;SAVE ADDRESS OF PTE
	MOVAB	UCB$W_DQ_HDR1(R5),R1	;SET ADDRESS OF INTERNAL BUFFER
	MOVL	#6,R2			;SET NUMBER OF BYTES TO MOVE
	CMPW	R2,UCB$W_BCNT(R5)	;ROOM FOR FULL HEADER?
	BLEQU	30$			;BRANCH IF SO
	MOVZWL	UCB$W_BCNT(R5),R2	;SET LENGTH OF PARTIAL HEADER
30$:	SUBW2	R2,UCB$W_BCR(R5)	;UPDATE BYTE COUNT REMAINING
	JSB	G^IOC$MOVTOUSER		;MOVE HEADER TO USER BUFFER
	POPL	UCB$L_SVAPTE(R5)	;RESTORE ADDRESS OF PTE
	BRB	BRW_RETREG		;TERMINATE FUNCTION

	.PAGE
	.SBTTL	DATA CHECK AND PARAMETER UPDATE

; 
; PERFORM WRITE CHECK, IF REQUESTED
; 

WRITECHK:			;WRITECHECK AFTER PARTIAL TRANSFER
	BBC	#IO$V_DATACHECK,-	;IF CLR - DATA CHECK NOT REQUESTED
		UCB$W_FUNC(R5),UPDATE	;...
	BBSC	#UCB$V_DQ_DIP,-		;CLEAR DATA CHECK IN PROGRESS
		UCB$B_DQ_FLAGS(R5),-	;...AND BRANCH IF SET
		UPDATE			;...
	BISB	#UCB$M_DQ_DIP,-		;SET DATA CHECK IN PROGRESS
		UCB$B_DQ_FLAGS(R5)	;...
	MOVZBL	#IO$_WRITECHECK,R3	;SET CASE INDEX TO WRITE CHECK
	BRW	NOMAPS			;BRANCH TO PERFORM WRITE CHECK


; 
; UPDATE BUFFER ADDRESS, CURRENT DISK ADDRESS, AND BYTES REMAINING
; FOR NEXT TRANSFER 
; 

UPDATE:				;UPDATE TRANSFER PARAMETERS
	MOVZWL	UCB$W_BCNT(R5),R0	;FETCH BYTES TRANSFERRED
	SUBW	R0,UCB$W_BCR(R5)	;UPDATE BYTES REMAINING TO XFER
	BEQL	BRW_RETREG		;BRANCH IF TRANSFER COMPLETE

;
; COMPUTE NUMBER OF 512 BYTE BLOCKS TRANSFERED
;
10$:	ASHL	#-7,R0,R0		;COMPUTE PAGES * 4
	ADDL	R0,UCB$L_SVAPTE(R5)	;UPDATE THE ADDRESS OF THE PTE
	BICB2	#^X3,UCB$L_SVAPTE(R5)	;ROUND DOWN TO FULL PAGES (RL02'S!)
	ASHL	#-1,R0,R0		;CONVERT TO 256 BYTE SECTORS
	BDRVTYP	RB80,15$		;BRANCH IF RB80
	BLBC	R0,20$			;CHECK FOR ODD SECTOR ADDRESSING
	INCB	UCB$W_BOFF+1(R5)	;ADD ^X100 TO BOFF
	BICB	#^XFE,UCB$W_BOFF+1(R5)	;MAKE BOFF MODULO ^X200
	BRB	20$			;CONTINUE IN COMMON
	
15$:	ASHL	#-1,R0,R0		;CONVERT TO 512 BYTE SECTORS
20$:	ADDB	R0,UCB$W_DA(R5)		;UPDATE SECTOR
	CMPB	UCB$W_DA(R5),-		;COMPARE UPDATED SECTOR
		UCB$B_SECTORS(R5)	;...TO SECTORS PER TRACK
	BLSSU	50$			;BRANCH IF MORE REMAIN
	BNEQ	30$			;BRANCH IF PAST LOGICAL END OF TRACK
	BDRVTYP	RB02,30$		;BRANCH IF RB02
	BBC	#IO$V_SKPSECINH,-	;BRANCH NO SKIP SECTOR INHIBIT
		UCB$W_FUNC(R5),30$	;...
;
;THIS IS AN R80 DRIVE, ON THE LAST LOGICAL SECTOR, AND SKIP SECTOR
;INHIBIT IS SET -- THERE IS ONE PHYSICALLY ACCESSABLE BLOCK REMAINING, SO
;CONTINUE ON THE SAME TRACK
;
	BRB	50$			;ONE MORE SECTOR REMAINS

30$:	CLRB	UCB$W_DA(R5)		;CLEAR SECTOR ADDRESS
	INCB	UCB$W_DA+1(R5)		;INCREMENT TRACK
	CMPB	UCB$W_DA+1(R5),-	;COMPARE UPDATED TRACK
		UCB$B_TRACKS(R5)	;...TO TRACKS PER CYLINDER
	BLSSU	50$			;BRANCH IF MORE REMAIN
	CLRB	UCB$W_DA+1(R5)		;RESET DESIRED TRACK (SURFACE) TO 0
	INCW	UCB$W_DC(R5)		;INCREMENT CYLINDER

50$:	BRW	FDISPATCH		;MORE BYTES REMAINING - CONTINUE

	.PAGE
	.SBTTL	SPECIAL CONDITION (POWER, TIMEOUT)

; 
; SPECIAL CONDITION EXIT (POWER FAILURE OR DEVICE TIMEOUT)
; 

SPECOND:
	MNEGL	#1,UCB$L_DQ_CURDA(R5)	;DISABLE SEEK OPTIMIZATION
	BBSC	#UCB$V_POWER,-		;IF SET - POWER FAILURE
		UCB$W_STS(R5),PWRFAIL	;...ELSE TIMEOUT
	SETIPL	UCB$B_FIPL(R5)		;TIMEOUTS ENTER AT DEVICE IPL
	JSB	G^ERL$DEVICTMO		;LOG DEVICE TIMEOUT
	CLRW	UCB$W_BCNT(R5)		;SET ZERO BYTES TRANSFERED
	BICW	#UCB$M_TIMOUT,UCB$W_STS(R5)  ;CLEAR TIMEOUT STATUS
	MOVZWL	#SS$_TIMEOUT,R0		;SET DEVICE TIMEOUT STATUS
	DECB	UCB$B_ERTCNT(R5)	;ANY ERROR RETRIES REMAINING?
	BLEQ	10$			;BRANCH IF NOT
	BRW	RESETDRIVE		;RETRY THE FUNCTION
10$:	BRW	FUNCXT			;GIVE UP

PWRFAIL:				;POWER FAILURE
	BICW	#UCB$M_POWER,UCB$W_STS(R5)  ;CLEAR POWER FAILURE BIT
	MOVL	UCB$L_IRP(R5),R3	;GET ADDRESS OF I/O PACKET
	MOVQ	IRP$L_SVAPTE(R3),-	;RESTORE TRANSFER PARAMETERS
		UCB$L_SVAPTE(R5)	;...
	BRW	PREPROCESS		;RETURN TO PREPROCESS UCB FIELDS

	.PAGE
	.SBTTL	HARDWARE FUNCTION EXIT PROCESSING

; 
; DETERMINE EXIT - SPECIAL CONDITION, FATAL ERROR, RETRIABLE ERROR, OR SUCCESS
; 

RETREG:	BITW	#UCB$M_POWER!-		;POWER FAIL
		UCB$M_TIMOUT,-		;...OR DEVICE TIMEOUT
		UCB$W_STS(R5)		;...IN STATUS WORD?
	BNEQ	SPECOND			;BRANCH IF SO -- SPECIAL CONDITION
	MOVL	UCB$L_DQ_CS(R5),R1	;FETCH CSR
	BBC	#RB_CS_V_CE,R1,SUCCESS	;BRANCH IF NO ERRORS
	MNEGL	#1,UCB$L_DQ_CURDA(R5)	;DISABLE SEEK OPTIMIZATION
	ADDW	UCB$L_DQ_BC(R5),-	;ADD NEGATIVE BYTE COUNT REMAINING
		UCB$W_BCNT(R5)		;...TO PARTIAL TRANSFER COUNT
	MOVL	UCB$L_DQ_MP(R5),R2	;FETCH MPR

;
; CHECK TO SEE IF THERE IS ANY ERROR OTHER THAN OPI.  IF NO OTHER
; ERRORS, AND THE DRIVE IS NOT READY, THEN ASSUME IT WAS SIMPLY SPUN DOWN
;
	BITL	#RB_CS_M_SSE -		;SKIP SECTOR ERROR
		!RB_CS_M_DE -		;... OR DRIVE ERROR
		!RB_CS_M_NXM -		;... OR NON-EXISTANT MEMORY
		!RB_CS_M_DLT -		;... OR DATA LATE
		!RB_CS_M_DCK -		;... OR DATA CHECK
		!RB_CS_M_DRDY,R1	;... OR DRIVE READY?
	BNEQ	20$			;BRACH IF SO
10$:	BBCC	#UCB$V_VALID,-		;CLEAR VALID BIT
		UCB$W_STS(R5),15$	;...
15$:	MOVZWL	#SS$_MEDOFL,R0		;SET MEDIUM OFFLINE STATUS
	BRW	FUNCXT			;RETURN

20$:	JSB	G^ERL$DEVICERR		;ALLOCATE AND FILL ERROR MESSAGE BUFFER
	BBS	#RB_CS_V_NXM,R1,FATAL	;BRANCH IF NON-EXISTENT MEMORY
	BBS	#RB_CS_V_SSE,R1,FATAL	;BRANCH IF SKIP SECTOR ERROR
	BBC	#RB_CS_V_DE,R1,RETRY	;BRANCH IF NO DRIVE ERRORS
	BDRVTYP	RB02,50$		;BRANCH IF RB02

;
;CLASSIFY RB80 ERRORS AS FATAL OR RETRIABLE
;

	BBC	#RB_MP_V_PLGV,R2,10$	;BRANCH IF PLUG NOT VALID
	BRB	RETRY			;

;
;CLASSIFY RB02 ERRORS AS FATAL OR RETRIABLE
;
50$:	CMPZV	#0,#6,R2,-		;STATE OK? ...COVER CLOSED
		#RB_MP_M_HO-		;...HEADS OUT
		!RB_MP_M_BH-		;...BRUSHES HOME
		!RB_MP_C_SLM		;...READY TO GO
	BNEQ	10$			;BRANCH IF NOT

	BBC	#RB_MP_V_VC,R2,60$	;BRANCH IF VOLUME VALID
	BBCC	#UCB$V_VALID,-		;CLEAR VALID BIT
		UCB$W_STS(R5),55$	;...
55$:	BRB	FATAL			;RETURN

60$:	BBC	#RB_MP_V_WL,R2,70$	;BRANCH IF NOT WRITE LOCKED 
	BBS	#RB_MP_V_WGE,R2,FATAL	;IF WL & WGE THEN WL ERROR
70$:	BITL	#RB_MP_M_WDE-		;WRITE DATA ERROR
		!RB_MP_M_HCE-		;...OR HEAD CURRENT ERROR
		!RB_MP_M_SPD-		;...OR SPINDLE SPEED ERROR
		!RB_MP_M_WGE-		;...OR WRITE GATE ERROR
		!RB_MP_M_DSE,R2		;...OR DRIVE SELECT ERROR?
	BNEQ	FATAL			;BRANCH IF SO

; 
; RETRIABLE ERROR EXIT
; 

RETRY:	BBS	#IO$V_INHRETRY,-	;BRANCH IF RETRIES INHIBITED
		UCB$W_FUNC(R5),FATAL	;...
	CVTBL	@UCB$L_DPC(R5),R0	;GET BRANCH DISPLACEMENT
	ADDL	UCB$L_DPC(R5),R0	;COMPUTE JUMP ADDRESS -1
	INCL	R0			;COMPUTE JUMP ADDRESS
	JMP	(R0)			;RETURN TO ERROR ROUTINE

; 
; SUCCESSFUL OPERATION EXIT
; 

SUCCESS:INCL	UCB$L_DPC(R5)		;ADJUST TO CORRECT RETURN ADDRESS
	JMP	@UCB$L_DPC(R5)		;RETURN TO DRIVER

; 
; FATAL ERROR EXIT
; 

FATAL:	BRW	FATALERR		;FATAL ERROR EXIT

	.PAGE
	.SBTTL	INTERRUPT SERVICE ROUTINE

;++
; DQ$INT - RB730 INTERRUPT SERVICE ROUTINE
; 
; FUNCTIONAL DESCRIPTION:
; 
; 	THIS ROUTINE IS ENTERED VIA A JSB INSTRUCTION WHEN AN INTERRUPT
; 	OCCURS ON AN RB730 DISK CONTROLLER. IF THE INTERRUPT IS NOT EXPECTED,
; 	THE UNSOLICITED INTERRUPT ROUTINE DISMISSES THE INTERRUPT. IF 
; 	THE INTERRUPT IS EXPECTED, DEVICE REGISTERS ARE SAVED AND THE
;	INTERRUPTING UNIT IS DETERMINED. THE DRIVER IS CALLED AT ITS INTERRUPT
;	RETURN ADDRESS. THE DRIVER FORKS, CAUSING A RETURN TO THIS ROUTINE
;	WHICH CONTINUES TO SCAN THE ATTENTION SUMMARY REGISTER IN CASE
;	ANY MORE DRIVES REQUIRE SERVICE.  AFTER THE LAST DRIVE IS SERVICED
;	THIS ROUTINE RESTORES GENERAL REGISTERS AND DISMISSES THE INTERRUPT. 
; 
; INPUTS:
; 
; 	00(SP)	- POINTER TO ADDRESS OF THE IDB 
; 	04(SP)	- SAVED R0
; 	08(SP)	- SAVED R1
; 	12(SP)	- SAVED R2
; 	16(SP)	- SAVED R3
; 	20(SP)	- SAVED R4
; 	24(SP)	- SAVED R5
; 	28(SP)	- PC AT THE TIME OF THE INTERRUPT
; 	32(SP)	- PSL AT THE TIME OF THE INTERRUPT
; 
; OUTPUTS:
; 
; 	DEVICE REGISTERS ARE SAVED, IPL IS LOWERED TO FORK LEVEL, THE
; 	INTERRUPT IS DISMISSED, ALL REGISTERS EXCEPT R0-R5 ARE PRESERVED.
;
;--

DQ_REI:					;INTERRUPT EXIT CODE
	ADDL	#4,SP			;POP IDB ADDRESS
	POPR	#^M<R0,R1,R2,R3,R4,R5>	;RESTORE R0-R5
	REI				;RETURN FROM INTERRUPT

DQ_INT:				;INTERRUPT SERVICE ROUTINE
	MOVL	@(SP),R3		;FETCH ADDRESS OF IDB
	MOVL	IDB$L_CSR(R3),R4	;GET ADDRESS OF CSR
	MOVL	IDB$L_OWNER(R3),R5	;GET OWNER UCB ADDRESS
	BEQL	12$			;BRANCH IF NOT OWNED
	BBSC	#UCB$V_INT,-		;BRANCH IF INTERRUPT EXPECTED
		UCB$W_STS(R5),40$	;...
;
;SCAN ATTENTION BITS TO DETERMINE INTERRUPTING DRIVE
;
10$:	MOVL	@(SP),R3		;FETCH ADDRESS OF IDB
	MOVL	IDB$L_CSR(R3),R4	;GET ADDRESS OF CSR
12$:	MOVL	RB_CS(R4),R1		;GET CSR
	FFS	#RB_CS_V_ATN,-		;FIND REQUESTING DRIVE
		#RB_CS_S_ATN,R1,R1	;...
	BEQL	DQ_REI			;BRANCH IF NO MORE DRIVES TO SERVICE
	ASHL	#RB_CS_V_ATN,#^X0F,R0	;PREPARE MASK OF ATTENTION BITS
	BBCC	R1,R0,15$		;CLEAR THIS UNIT'S BIT IN THE MASK
15$:	BICL	R0,RB_CS(R4)		;CLEAR THIS UNIT'S BIT IN THE CSR
	SUBL	#RB_CS_V_ATN,R1		;COMPUTE UNIT NUMBER
	ASHL	#RB_CS_V_DS,R1,R2	;MOVE UNIT INTO DRIVE SELECT BITS
	BISL3	R2,-			;SELECT THE UNIT
		#RB_CS_M_IE-		;...WITH INTERRUPT ENABLE
		!RB_CS_M_CRDY,-		;...AND CONTROLLER READY
		RB_CS(R4)		;...DEVICE CSR
	MOVL	IDB$L_UCBLST(R3)[R1],R5	;GET ADDRESS OF UCB
	BEQL	25$			;BRANCH IF UCB WAS NOT FOUND
	BBSC	#UCB$V_INT,-		;BRANCH IF INTERRUPT WAS EXPECTED
		UCB$W_STS(R5),40$	;...
	MOVL	RB_CS(R4),UCB$L_DQ_CS(R5);SAVE CSR
	BBSC	#UCB$V_DQ_SIP,-		;BRANCH IF SEEK IN PROGRESS
		UCB$B_DQ_FLAGS(R5),12$	;...AND CONTINUE SCANNING
25$:	
	BSBW	DQ_UNEXINT		;HANDLE UNEXPECED INTERRUPT
	BRB	12$			;CONTINUE SCANNING

;
;HERE WHEN UNIT DETERMINED, INTERRUPT EXPECTED, DRIVE SELECTED
;AND STATUS AVAILABLE
;
40$:	CMPB	#CDF_READHEAD,UCB$B_CEX(R5)	;READ HEADER FUNCTION?
	BNEQ	50$				;IF NEQ - NO
	CVTLW	RB_MP(R4),UCB$W_DQ_HDR1(R5)	;SAVE SECTOR HEADER INFORMATION
	CVTLW	RB_MP(R4),UCB$W_DQ_HDR2(R5)	;...(THIS MUST BE DONE EVEN
	CVTLW	RB_MP(R4),UCB$W_DQ_HDR3(R5)	;...FOR INTERNAL READ HEADERS)

50$:	BITL	#RB_CS_M_CE,RB_CS(R4)		;COMPOSITE ERROR?
	BNEQ	80$				;BRANCH IF SO
	BBS	#UCB$V_DIAGBUF,-		;BRANCH IF DIAGNOSTIC BUFFER
		UCB$W_DEVSTS(R5),80$		;...IS PRESENT
	MOVL	RB_CS(R4),UCB$L_DQ_CS(R5)	;SAVE CSR ONLY

;
;RETURN TO FUNCTION EXECUTION
;
60$:	MOVQ	UCB$L_FR3(R5),R3	;RESTORE DRIVER CONTEXT
	JSB	@UCB$L_FPC(R5)		;CALL DRIVER AT INTERRUPT RETURN ADDRESS
	BRW	10$			;CHECK FOR MORE DRIVES TO SERVICE

;
;DEVICE ERROR OR DIAGNOSTIC BUFFER -- SAVE THE DEVICE REGISTERS
;AND RESET THE DRIVE
;
80$:	BSBB	DQ_REGSAVE		;SAVE DEVICE REGISTERS
	BRB	60$			;CONTINUE

	.PAGE
	.SBTTL	REGISTER SAVE ROUTINE
;++
; 
; DQ_REGSAVE - REGISTER SAVE ROUTINE
; 
; FUNCTIONAL DESCRIPTION:
; 
; THIS ROUTINE IS CALLED TO SAVE THE DEVICE REGISTERS AND UBA RESOURCE
; REGISTERS IN THE UCB.  STATUS IS OBTAINED FROM THE DRIVE AND IF AN
; ERROR HAS OCCURED THEN THE DRIVE IS RESET (COULD BE HERE BECAUSE
; DIAGNOSTIC BUFFER PRESENT.
; 
; INPUTS:
; 
; 	R4	- ADDRESS OF DEVICE CONTROL STATUS REGISTER (CSR)
; 	R5	- ADDRESS OF UNIT CONTROL BLOCK (UCB)
; 
; OUTPUTS:
; 
;	R0-R3	- DESTROYED
; 	THE DEVICE REGISTERS ARE SAVED IN THE UCB.
; 
;--

DQ_REGSAVE:				;REGISTER SAVE ROUTINE
	MOVAB	RB_CS(R4),R2		;GET ADDRESS OF CONTROL STATUS REGISTER
	MOVAB	UCB$L_DQ_CS(R5),R3	;GET ADDRESS OF REGISTER SAVE AREA
	MOVL	(R2)+,(R3)+		;SAVE CONTROL STATUS REGISTER
	MOVL	(R2)+,(R3)+		;SAVE BUFFER ADDRESS REGISTER
	MOVL	(R2)+,(R3)+		;SAVE BYTE COUNT REGISTER
	MOVL	(R2)+,(R3)+		;SAVE DISK ADDRESS REGISTER
	MOVL	(R2)+,(R3)+		;SAVE MPR REGISTER
	CVTLW	(R2)+,UCB$W_EC1(R5)	;SAVE ECC POSITION REGISTER
	CVTLW	(R2)+,UCB$W_EC2(R5)	;SAVE ECC PATTERN REGISTER
; 
; GET STATUS
; 
	GETUNIT				;GET UNIT NUMBER IN R2
	CMPZV	#RB_CS_V_FCODE,-	;WAS ORIGIANL FUNCTION A GET STATUS?
		#RB_CS_S_FCODE,-	;...
		UCB$L_DQ_CS(R5),-	;...
		#F_GETSTATUS		;...
	BEQL	20$			;BRANCH IF SO (USE ORIGINAL STATUS)
	MOVZBL	#-1,UCB$L_DQ_MP(R5)	;SET TO -1 IF GET STATUS FAILS
	BSBW	DQ_GETSTS		;GET THE STATUS
	BLBC	R0,20$			;BRANCH IF GET STATUS FAILED
	MOVL	RB_MP(R4),UCB$L_DQ_MP(R5);SAVE MPR (STATUS WORD)
20$:	BBC	#RB_CS_V_CE,-		;BRANCH IF NO ERRORS (DON'T CLEAR IF
		UCB$L_DQ_CS(R5),30$	;...ONLY HERE FOR DIAGNOSTIC BUFFER)
	BSBW	DQ_RESET		;CLEAR DRIVE ERRORS IF ANY


; 
; SAVE UBA REGISTERS
; 

30$:	ASSUME	UCB$L_DQ_FMPR EQ UCB$L_DQ_MP+4 ;ASSUME REGISTER AREA CONTIG
	MOVQ	#-1,(R3)		;SET DEFAULT VALUE -1
	CMPB	#CDF_WRITECHECK,-	;DRIVE RELATED FUNCTION?
		UCB$B_CEX(R5)		;...
	BGTRU	70$			;BRANCH IF SO
	
	ASHL	#-9,UCB$L_DQ_BA(R5),R0	;COMPUTE MAP REGISTER NUMBER
	CMPW	#495,R0			;LEGAL MAP REGISTER NUMBER?
	BLSSU	70$			;BRANCH IF NOT

	MOVL	UCB$L_CRB(R5),R1	;FETCH CRB
	MOVL	@CRB$L_INTD+VEC$L_ADP(R1),R2 ;FETCH ADDRESS OF ADAPTOR CSR
	MOVL	UBI$L_MAP(R2)[R0],(R3)+	;SAVE FINAL MAP REGISTER
	DECL	R0			;CALCULATE PREVIOUS MAP REGISTER NUMBER
	CMPV	#VEC$V_MAPREG,-		;COMPARE STARTING MAP REGISTER NUMBER
		#VEC$S_MAPREG,-		;...
		CRB$L_INTD+VEC$W_MAPREG(R1),- ;...FROM CRB
		R0 			;...TO ENDING MAP REGISTER MINUS 1
	BGTR	70$			;BRANCH IF WE'RE STILL ON FIRST MAP
	MOVL	UBI$L_MAP(R2)[R0],(R3)	;SAVE PREVIOUS MAP REGISTER
70$:	RSB				;RETURN

	.PAGE
	.SBTTL	UNEXEPECTED INTERRUPT HANDLER
;++
; 
; FUNCTIONAL DESCRIPTION:
;
; UNEXPECTED INTERRUPTS ARE FIELDED.  STATUS IS OBTAINED FROM
; THE DRIVE, VOLUME VALID IS CLEARED IF APPROPRIATE AND THE
; DRIVE IS RESET

; INPUTS:
; 
;	R2	- UNIT NUMBER OF DRIVE
;	R4	- RB730 CSR ADDRESS
;	R5	- UCB ADDRESS
; 
; OUTPUTS:
; 
;	R0	- DESTROYED
;	UCB$V_VALID IN UCB$W_STS
; 
;--

DQ_UNEXINT:			;UNEXPECTED INTERRUPT
	TSTL	R5			;IS THERE AN UCB?
	BEQL	50$			;BRANCH IF NOT

	BSBB	DQ_GETSTS		;GET DRIVE STATUS
	BLBC	R0,20$			;BRANCH IF TIMEOUT OR OPI
	BISW	#UCB$M_ONLINE,UCB$W_STS(R5)	;SET UCB STATUS VOLUME ONLINE

	BITL	#RB_CS_M_TYP,RB_CS(R4)	;IS THIS AN R80
	BNEQ	10$			;BRANCH IF SO
	BITL	#RB_MP_M_VC,RB_MP(R4)	;VOLUME CHECK?
	BEQL	30$			;BRANCH IF NOT
	BRB	20$			;SET VOLUME INVALID

10$:	BITL	#RB_MP_M_PLGV,RB_MP(R4)	;PLUG VALID?
	BNEQ	30$			;BRANCH IF SO

20$:	BBCC	#UCB$V_VALID,-  	;CLEAR VALID BIT
		UCB$W_STS(R5),30$	;...

30$:	BSBW	DQ_CLASSIFY		;CLASSIFY DRIVE AND INIT UCB

50$:	BSBB	DQ_RESET		;RESET THE DRIVE
	RSB				;RETURN TO CALLER

	.PAGE
	.SBTTL	GET STATUS, RESET, READ HEADER
;++
; 
; DQ_READHDR - READ HEADER (EITHER DRIVE)
; DQ_RESET   - GET STATUS AND RESET ROUTINE
; DQ_GETSTS  - GET STATUS ROUTINE
; 
; FUNCTIONAL DESCRIPTION:
; 
; THIS ROUTINE HANDLES NON-INTERRUPT DRIVEN DEVICE OPERATIONS INCLUDING:
;
;	RESET DRIVE
;	GET STATUS
;	READ HEADER
;
; AFTER EXECUTING THE FUNCTION A WAIT FOR CONTROLLER READY IS DONE.
; THE WAIT WILL TIMEOUT IF CONTROLLER READY DOES NOT APPEAR WITHIN
; 2 SECONDS
;
; THIS ROUTINE SHOULD ONLY BE CALLED AT DEVICE IPL OR ABOVE
; 
; INPUTS:
; 
;	R2	- UNIT NUMBER IN DRIVE SELECT BITS
; 	R4	- ADDRESS OF DEVICE CONTROL STATUS REGISTER (CSR)
; 
; OUTPUTS:
; 
; 	RB_MP(R4)	- DRIVE STATUS IF DQ_GETSTS OR DQ_RESET
;	R0		- LOW BIT CLEAR IF A TIMEOUT OR OPERATION INCOMPLETE
;	
; 
;--

;
;TO READ A HEADER, THE COMMAND IS LOADED AND THE WAIT ROUTINE
;IS JUMPED TO.
;
;THE RB730 HOST (VAX730) MICROCODE MAINTAINS AN INTERNAL RECORD
;OF THE CURRENT DISK CYLINDER FOR RB02'S.  THIS REGISTER IS USED TO
;COMPUTE THE RELATIVE CYLINDER ADDRESSES REQUIRED BY THE DRIVE.  THE
;CONTENTS OF THIS REGISTER MAY DISAGREE WITH THE ACTAUL DISK POSITION.
;
;THE REGISTER IS RECALIBRATED BY DOING A READ HEADER.  THE MICROCODE
;RELOADS THE REGISTER WITH THE CURRENT CYLINDER ADDRESS AS SPECIFIED
;IN THE HEADER WORD, WHEN THE MACRO CODE READS THE MPR.
;

DQ_READHDR:				;DRIVE READ HEADER ENTRY
	BSBB	DQ_WAIT				;MAKE SURE CONTROLLER FREE
	BLBS	R0,10$				;BRANCH IF SO
	RSB					;RETURN WITH R0 LBC
10$:	BISL3	R2,-				;MERGE UNIT NUMBER
		#F_READHEAD-			;...WITH FUNCTION
		!RB_CS_M_IE,-			;...AND INTERRUPT ENABLE
		RB_CS(R4)  			;INTO CSR CLEARING CRDY
	BSBW	DQ_WAIT				;WAIT FOR COMPLETION
	CMPL	RB_MP(R4),RB_MP(R4)		;READ HEADER WORDS
	BRB	CHECKOPI			;CHECK FOR COMPLETION
;
;TO RESET THE DRIVE, A GET STATUS SUBCOMMAND IS LOADED INTO THE
;MULTIPURPOSE REGISTER WITH THE RESET BIT SET.
;

DQ_RESET:				;DRIVE RESET ENTRY
	MOVL	#RB_MP_M_STS!-			;PUT GET STATUS IN MPR
		RB_MP_M_RST!-			;...AND RESET THE DRIVE
		RB_MP_M_MRK,RB_MP(R4)		;...MARK SUBCOMMAND PRESENT
	BRB	EXGETSTS			;CONTINUE IN COMMON

;
;TO GET STATUS WITHOUT RESET, A GET STATUS SUBCOMMAND IS LOADED INTO
;THE MULTIPURPOSE REGISTER.  DRIVE STATUS IS NOT RESET
;

DQ_GETSTS:				;GET STATUS ENTRY
	MOVL	#RB_MP_M_STS!-			;PUT GET STATUS IN MPR
		RB_MP_M_MRK,RB_MP(R4)		;...MARK SUBCOMMAND PRESENT
;
;NOW EXECUTE THE ACTUAL COMMAND BY MERGING THE UNIT NUMBER WITH
;THE GET STATUS COMMAND AND LOADING THE CSR.  INTERUPTS ARE NOT ENABLED
;

EXGETSTS:				;COMMAND EXECUTION
	BSBB	DQ_WAIT				;MAKE SURE CONTROLLER FREE
	BLBS	R0,10$				;BRANCH IF SO
	RSB					;RETURN WITH R0 LBC
10$:	BISL3	R2,-				;MERGE UNIT NUMBER
		#F_GETSTATUS-			;...WITH FUNCTION
		!RB_CS_M_IE,-			;...AND INTERRUPT ENABLE
		RB_CS(R4)  			;INTO CSR CLEARING CRDY

CHECKOPI:				;CHECK FOR OPERATION INCOMPLETE
	BSBB	DQ_WAIT				;WAIT FOR READY
	BITL	#RB_CS_M_OPI,RB_CS(R4)		;OPERATION COMPLETE?
	BEQL	10$				;BRANCH IF SO
	CLRL	R0				;SET FAILURE
10$:	RSB					;R0 LBC IF TIMEOUT

	.PAGE
	.SBTTL	WAIT FOR CONTROLLER READY
;++
; 
; DQ_WAIT    - WAIT FOR CONTROLLER READY ROUTINE
; 
; FUNCTIONAL DESCRIPTION:
; 
; THIS ROUTINE WAIT FOR CONTROLLER READY -- THE WAIT WILL TIMEOUT
; IF CONTROLLER READY DOES NOT APPEAR WITHIN 2 SECONDS
;
; THIS ROUTINE SHOULD ONLY BE CALLED AT DEVICE IPL OR ABOVE
; 
; INPUTS:
; 
;	R2	- UNIT NUMBER IN DRIVE SELECT BITS
; 	R4	- ADDRESS OF DEVICE CONTROL STATUS REGISTER (CSR)
; 
; OUTPUTS:
; 
;	R0		- LOW BIT CLEAR IF A TIMEOUT
;	
; 
;--

;
; WAIT FOR CONTROLLER READY.  IF NOT PRESENT WITHIN APPROXIMATELY
; 2 SECONDS, THEN R0 WILL HAVE LOW BIT CLEAR
;
DQ_WAIT:				;WAIT FOR CONTROLLER READY
	TIMEWAIT #200000,#RB_CS_M_CRDY,-	;WAIT FOR CONTROLLER READY
		RB_CS(R4),L			;... 200000*10 MICS
	RSB					;RETURN TO CALLER

	.PAGE
	.SBTTL	UNIT INITIALIZATION ROUTINE

;++
; 
; DQ_UNIT_INIT - UNIT INITIALIZATION ROUTINE
; 
; FUNCTIONAL DESCRIPTION:
; 
; 	THIS ROUTINE READIES THE RB02/RB80 UNITS FOR I/O OPERATIONS.
; 
; 	THE OPERATING SYSTEM CALLS THIS ROUTINE:
; 		- AT SYSTEM STARTUP
; 		- DURING DRIVER LOADING
; 		- DURING RECOVERY FROM POWER FAILURE
; 
; INPUTS:
; 
; 	R4	- CSR ADDRESS (CONTROLLER STATUS REGISTER)
; 	R5	- UCB ADDRESS (UNIT CONTROL BLOCK)
; 
; OUTPUTS:
; 
; 	THE DRIVE IS RESET, UCB FIELDS ARE INITIALIZED, AND THE
; 	ROUTINE WAITS FOR ONLINE UNITS TO SPIN UP.  ALL REGISTERS
; 	EXCEPT R0-R3 ARE PRESERVED.  RB80'S ARE DIFFERENTIATED FROM
;	RB02 UNITS FOR UCB INITIALIZATION PURPOSES
; 
;	A PERMANENT BUFFERED DATAPATH AND A PERMANENT SET OF MAP
;	REGISTERS ARE ALLOCATED ON THE FIRST CALL TO THIS ROUTINE.
;	ON SUCESSIVE ENTRYS, THE CALLS TO ALLOCATE RESOURCES ARE
;	IGNORED BY THE SYSTEM.
;--


DQ_UNIT_INIT:					;RB02/RB80 UNIT INITIALIZATION

; 
; GET CURRENT DRIVE STATUS AND RESET DRIVE
; 
	MOVZWL	UCB$W_STS(R5),R3		;SAVE CURRENT UNIT STATUS
	BICW	#UCB$M_ONLINE!UCB$M_VALID,-  	;ASSUME OFFLINE/INVALID
		UCB$W_STS(R5)			;...
	GETUNIT					;LOAD UNIT NUMBER IN R2
	BSBB	DQ_WAIT				;WAIT FOR CONTROLLER
	BLBC	R0,50$				;BRANCH IF CONTROLLER BUSY
	BSBW	DQ_RESET			;GET STATUS AND RESET DRIVE
	BLBC	R0,50$				;BRANCH IF TIMEOUT OR OPI

; 
; WAIT FOR ONLINE UNITS TO SPIN UP
; 

	BBC	#UCB$V_VALID,R3,40$		;BYPASS SPINUP WAIT IF NOT
						;...VALID BEFORE POWER FAIL
10$:	BITL	#RB_CS_M_DRDY,RB_CS(R4)		;IS DRIVE READY?
	BNEQ	30$				;BRANCH IF READY
	JSB	G^EXE$PWRTIMCHK			;IS MAX TIME EXCEEDED?
	BLBS	R0,10$				;IF LBS - NO, STILL MORE TIME NEEDED
	BRB	40$				;POWER UP TIME EXCEEDED

30$:	BISW	#UCB$M_VALID,UCB$W_STS(R5)	;SET UCB STATUS VOLUME VALID
40$:	BISW	#UCB$M_ONLINE,UCB$W_STS(R5)	;SET UCB STATUS VOLUME ONLINE
	BSBB	DQ_CLASSIFY			;CLASSIFY DRIVE


;
; ALLOCATE A PERMANENT BUFFERED DATAPATH.  (ON A VAX730, ALL DATAPATHS
; ARE DIRECT.  IT IS ALLOCATED HERE ONLY OUT OF CONVENTION.)
;
50$:	REQDPRNW			;REQUEST A PATH -- NO WAIT
	BLBS	R0,55$			;BRANCH IF SUCCESSFUL
	BUG_CHECK UBMAPEXCED,FATAL	;SERIOUS PROBLEM
55$:	MOVL	UCB$L_CRB(R5),R1	;FETCH CRB ADDRESS
	BBSS	#VEC$V_PATHLOCK,-	;LOCK THE DATA PATH
		CRB$L_INTD+VEC$B_DATAPATH(R1),65$ ;...IN THE CRB

;
; ACCOCATE ENOUGH PERMANENT MAP REGISTERS TO HOLD THE LARGEST POSSIBLE
; DATA TRANSFER.  SINCE NEITHER THE RB02 OR RB80 SUPPORT SPIRALLING THE
; LARGEST TRANSFER IS A SINGLE TRACK
;
;	32 (RB80 BLOCKS PER TRACK) +
;	 1 (IN CASE TRANSFER CROSSES PAGE BOUND) +
;	 1 (FOR INVALID SENTINAL PAGE)
;	-- =
;	34 PERMANENTLY ALLOCATED MAP REGISTERS
;
65$:	MOVL	#34,R3			;34 MAP REGISTERS NEEDED
	JSB	G^IOC$ALOUBAMAPN	;REQUEST THEM

	BLBS	R0,67$			;BRANCH IF SUCCESSFUL
	BUG_CHECK UBMAPEXCED,FATAL	;SERIOUS PROBLEM

67$:	MOVL	UCB$L_CRB(R5),R1	;FETCH CRB ADDRESS
	BBSS	#VEC$V_MAPLOCK,-	;LOCK THE MAPS
		CRB$L_INTD+VEC$W_MAPREG(R1),75$ ;...IN THE CRB
75$:	RSB				;RETURN

	.PAGE
	.SBTTL	DRIVE CLASSIFICATION ROUTINE
;++
; 
; DQ_CLASSIFY - DRIVE CLASSIFICATION ROUTINE
; 
; FUNCTIONAL DESCRIPTION:
; 
; THIS ROUTINE IS CALLED TO CLASSIFY THE DRIVE TYPE AND INITIALIZE
; THE UCB FEILDS.  IT IS CALLED AT DRIVE INIT TIME, AND FOLLOWING AN
; UNEXPECT INTERRUPT.
; 
; INPUTS:
; 
; 	R4	- ADDRESS OF DEVICE CONTROL STATUS REGISTER (CSR)
; 	R5	- ADDRESS OF UNIT CONTROL BLOCK (UCB)
; 
; OUTPUTS:
; 
;	R0-R2	- DESTROYED
; 	THE UCB FEILDS ARE INITIALIZED
; 
;--

DQ_CLASSIFY:				;DRIVE CLASSIFICATION ROUTINE
;
; ASSUME THAT SECTORS, TRACKS, AND CYLINDERS FEILDS ARE CONTAINED IN
; UCB$L_DEVDEPEND
;
ASSUME	UCB$B_SECTORS	EQ	UCB$L_DEVDEPEND
ASSUME	UCB$B_TRACKS	EQ	UCB$L_DEVDEPEND+1
ASSUME	UCB$W_CYLINDERS	EQ	UCB$L_DEVDEPEND+2

;
; ASSUME ITS AN RB02 AND INITIALIZE ACCORDINGLY
;
	MOVB	#DT$_RB02,UCB$B_DEVTYPE(R5)	;SET RB02 DEVICE TYPE AND
	MOVL	#<40+<2@8>+<512@16>>,-		;LOAD SECTORS+TRACKS+CYLINDERS
		UCB$L_DEVDEPEND(R5)		;...INTO UCB
	MOVZWL	#<20*2*512>,UCB$L_MAXBLOCK(R5)	;(512 BYTE) BLOCKS PER SPINDLE
	BISW2	#UCB$M_NOCNVRT,UCB$W_DEVSTS(R5)	;DISABLE LOG TO PHYS CONV.
	GETUNIT					;PUT UNIT NUMBER IN R2
	BSBW	DQ_READHDR			;READ HEADER TO SYNCRONIZE UCODE

	BITL	#RB_CS_M_TYP,RB_CS(R4)		;TEST DRIVE TYPE
	BEQL	30$				;BRANCH IF AN RB02

	MOVB	#DT$_RB80,UCB$B_DEVTYPE(R5)	;SET RB80 DEVICE TYPE AND
	MOVL	#<31+<14@8>+<559@16>>,-		;LOAD SECTORS+TRACKS+CYLINDERS
		UCB$L_DEVDEPEND(R5)		;...INTO UCB
	MOVL	#<31*14*559>,UCB$L_MAXBLOCK(R5)	;(512 BYTE) BLOCKS PER SPINDLE
	BICW2	#UCB$M_NOCNVRT,UCB$W_DEVSTS(R5)	;ENABLE LOG TO PHYS CONV.

30$:	RSB

	.PAGE
	.SBTTL	CONTROLLER INITIALIZATION ROUTINE
;++
; 
; FUNCTIONAL DESCRIPTION:
; 
;	THE CORRECT RB730 CSR ADDRESS IS COMPUTED.
;
; 	AUTOCONFIGURE UTILIZES A TEMPORARY UNIBUS CSR ADDRESS FOR
;	CONFIGURING THIS CONTROLLER.  THE TRUE CSR ADDRESS IS LOCATED
;	EXACTLY ONE PAGE ABOVE THE ADAPTOR CSR (THE DEVICE REGISTERS
;	ARE ACTUALLY IN THE ADAPTOR CONTROL REGISTER REGION)
; 
; 	THE OPERATING SYSTEM CALLS THIS ROUTINE:
; 		- AT SYSTEM STARTUP
; 		- DURING DRIVER LOADING
; 		- DURING RECOVERY FROM POWER FAILURE
; 
; INPUTS:
; 
; 	R4	- CSR ADDRESS (DEVICE CONTROL STATUS REGISTER)
; 	R5	- IDB ADDRESS (INTERRUPT DATA BLOCK)
;	R6	- DDB ADDRESS (DEVICE DATA BLOCK)
;	R8	- CRB ADDRESS (CHANNEL REQUEST BLOCK)
; 	ALL INTERRUPTS ARE LOCKED OUT
; 
; OUTPUTS:
; 
;	IDB$L_CSR	- CORRECT RB730 CSR ADDRESS
; 
;--

DQ_RB730_INIT:				;CONTROLLER INITIALIZATION
	ASSUME	ADP$L_CSR EQ 0
	MOVL	@IDB$L_ADP(R5),R0		;FETCH ADAPTOR CSR ADDRESS
	MOVAL	^X200(R0),IDB$L_CSR(R5)		;STORE CSR IN IDB
	RSB

	.PAGE
	.SBTTL	UNIT DELIVERY ROUTINE
;++
; 
; DQ_DELIVER - UNIT DELIVERY ROUTINE
; 
; FUNCTIONAL DESCRIPTION:
; 
; THIS ROUTINE IS CALLED BY AUTOCONFIGURE TO TEST FOR A UNITS
; PRESCENCE OR ABSCENCE ON THE CONTROLLER
; 
; INPUTS:
; 
; 	R0-R3	- SCRATCH
; 	R4	- ADDRESS OF ADAPTOR CONFIGURATION REGISTER
; 	R5	- UNIT NUMBER TO BE CONFIGURED
;	R6	- ADDRESS OF CONFIGURATION CONTROL REGISTER
;	R7	- ADDRESS OF CONFIGURATION CONTROL BLOCK (ACF BLOCK)
;	R8	- ADDRESS OF ADAPTOR CONTROL BLOCK
;
;	ACF$B_CUNIT(R7) - UNIT NUMBER TO BE TESTED
; 
; OUTPUTS:
; 
; 	R0	- LBS IF UNIT FOUND, LBC IF NO SUCH UNIT
; 
;--

DQ_DELIVER:				;UNIT DELIVERY ROUTINE
	PUSHL	R4				;SAVE R4
	MOVAB	^X200(R6),R4			;COMPUTE ADDRESS OF CSR
	CLRL	R2				;PREPARE FOR UNIT NUMBER
	INSV	R5,#8,#2,R2			;LOAD DRIVE SELECT BITS
	BSBW	DQ_WAIT				;WAIT FOR CONTROLLER READY
	BLBC	R0,50$				;BRANCH IF CONTROLLER BUSY
	BSBW	DQ_GETSTS			;ATTEMPT GET STATUS
						;R0=1 IF OK, 0 IF NO UNIT
50$:	BICL	#RB_CS_M_IE,RB_CS(R4)		;DISABLE INTERRUPTS
	MOVL	(SP)+,R4			;RESTORE R4
	RSB				;RETURN STATUS TO CALLER
	

	.PAGE
	.SBTTL	REGISTER DUMP ROUTINE
;++
; 
; DQ_REGDUMP - REGISTER DUMP ROUTINE
; 
; FUNCTIONAL DESCRIPTION:
; 
; THIS ROUTINE IS CALLED TO SAVE THE DEVICE REGISTERS AND UBA RESOURCE
; REGISTERS IN A SPECIFIED BUFFER. IT IS CALLED FROM THE DEVICE ERROR
; LOGGING ROUTINE AND FROM THE DIAGNOSTIC BUFFER FILL ROUTINE.
; 
; INPUTS:
; 
; 	R0	- ADDRESS OF REGISTER SAVE BUFFER
; 	R4	- ADDRESS OF DEVICE CONTROL STATUS REGISTER (CSR)
; 	R5	- ADDRESS OF UNIT CONTROL BLOCK (UCB)
; 
; OUTPUTS:
; 
; 	THE DEVICE AND UBA REGISTERS ARE SAVED IN THE SPECIFIED BUFFER.
; 	R0 CONTAINS THE ADDRESS OF THE NEXT EMPTY LONGWORD IN THE BUFFER.
; 	ALL REGISTERS EXCEPT R1 AND R2 ARE PRESERVED.
; 
;--

DQ_REGDUMP:				;REGISTER DUMP ROUTINE
	MOVL	#<RB_NUM_REGS+5>,(R0)+	;INSERT NUMBER OF REGISTERS
	MOVAL	UCB$L_DQ_CS(R5),R1	;GET ADDRESS OF SAVED DEVICE REGISTERS
	MOVZBL	#<RB_NUM_REGS-2>,R2	;GET NUMBER OF DEVICE REGISTERS TO MOVE
10$:	MOVL	(R1)+,(R0)+		;DUMP REGISTER IN BUFFER
	SOBGTR	R2,10$			;IF GTR - STILL MORE TO MOVE

	MOVZWL	UCB$W_EC1(R5),(R0)+	;ECC POSITION REGISTER
	MOVZWL	UCB$W_EC2(R5),(R0)+	;ECC PATTERN REGISTER

	MOVL	UCB$L_CRB(R5),R2	;FETCH CRB ADDRESS
	MOVZBL	CRB$L_INTD+VEC$B_DATAPATH(R2),(R0)+ ;DUMP DATAPATH NUMBER
	CLRL	(R0)+			;DUMP DATAPATH REGISTER (ALWAYS 0)
	MOVL	(R1)+,(R0)+		;DUMP FINAL MAP REGISTER
	MOVL	(R1)+,(R0)+		;DUMP PREVIOUS MAP REGISTER

	ASSUME	VEC$B_NUMREG EQ VEC$W_MAPREG+2 ;ASSUME START AND NUMBER CONTIG
	MOVL	CRB$L_INTD+VEC$W_MAPREG(R2),(R0)+;DUMP MAP REGISTERS

	RSB				;RETURN

DQ_END:					;ADDRESS OF LAST LOCATION IN DRIVER
	.END
