	.TITLE	PAFPCALL
	.IDENT	'V03-003'

;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1981, 1982                                                *
;*  BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.			    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED  *
;*  ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE  *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER  *
;*  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY  *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY  *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE  *
;*  AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT  *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS  *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;*									    *
;****************************************************************************
;
;++
;
; FACILITY:
;
;	VAX/VMS EXECUTIVE, I/O DRIVERS
;
; ABSTRACT:  SCS ROUTINES AVAILABLE TO FORK PROCESSES WHICH
;	     ARE CI PORT-SPECIFIC.
;
; AUTHOR:  N. KRONENBERG,  MAY 1981
;
; MODIFIED BY:
;
;	V03-003	NPK2019		N. Kronenberg		5-Apr-1982
;		Changed disconnect of CDT in undefined state to 
;		return success in case of nonfatal bugcheck.
;		Changed unmap of bad buffer descriptor to noop in
;		case of nonfatal bugcheck.  Added check on buffer
;		descriptor index.
;
;	V03-002	NPK2018		N. Kronenberg		25-Mar-1982
;		Fixed wakeup after pool allocate failure to allocate
;		message buffer.
;		Fixed two comments in MAP.
;
;	V03-001	NPK2016		N. Kronenberg		18-Mar-1982
;		Removed $SYSAPDEF invokaction. Fixed .TITLE
;
;--

	.SBTTL	DEFINITIONS

;
; Set PSECT to driver code:
;

	.PSECT	$$$115_DRIVER,LONG


;
; System definitions (LIB.MLB):
;

	$CDRPDEF			; Class driver request packet format
	$CDTDEF				; Connection descriptor format
	$CIBDDEF			; CI buffer descriptor format
	$CIBDTDEF			; CI buffer desc table format
	$CIBHANDEF			; CI buffer handle format
	$IRPDEF				; Define IRP offsets and bits
	$PBDEF				; Path Block format
	$PDTDEF				; Port descriptor format
	$SCSDEF				; SCS message format
	$SSDEF				; System-wide status codes

; PADRIVER definitions (PALIB.MLB):
;

	$PAPDTDEF			; CI PDT extensions
	$PAREGDEF			; CI port registers
	$PPDDEF				; PPD layer header format


	.SBTTL	UNIMPLEMENTED FORK PROCESS CALLS

FPC$MAINTFCN::

	MOVZWL	#SS$_ILLIOFUNC,R0	; Set error status for caller
	RSB				; Return to caller

	.SBTTL	CONNECTION MANAGEMENT CALLS
	.SBTTL	-	FPC$CONNECT,	COMPLETE PROCESSING A CONNECT

;+
; This routine is JMP'ed to from SCS$CONNECT with a CDT allocated
; (and in the closed state) and initialized with the SYSAP's
; connect parameters or 0's for fields not yet used.  FPC$CONNECT
; does port-specific processing:  allocates SCS control message
; receive buffer, initial credit worth of receive message buffers,
; and initial datagram buffers.  FPC$CONNECT then sets the CDT
; state to connect sent and queues the CDT to send a CONNECT_REQ 
; message to the remote system.  Finally, FPC$CONNECT suspends the
; SYSAP.
;
; Inputs:
;
;	R3			-Addr of CDT
;	R4			-Addr of PDT
;
;	CDT initialized as follows:
;
;	CDT$L_LCONID		-Local conid
;	      MSGINPUT		-Addr to call in SYSAP for rec'd msgs
;	      DGINPUT		-Addr to call in SYSAP for rec'd dgs
;	      ERRADDR		-Addr to call in SYSAP for connection errors
;	      RSTATION		-Remote station addr
;	      PDT		-Addr of PDT
;	      MINSEND		-Minimum send credit req'd by SYSAP
;	      INITLREC		-Initial credit extended by SYSAP
;	      DGREC		-Initial # of dg's queued 
;	      STATE		-CLOSED
;	      PB		-Addr of selected PB to remote system
;	      WAITQFL/BL	-Set to show no entries
;	      RPROCNAM		-Addr of dest process name
;	      LPROCNAM		-Addr of local process name
;	      CONDAT		-Addr of connect data
;
;	other CDT fields	-0
;
;
;	(SP)			-Return PC in SYSAP
;
; Outputs:
;
;	R0			-Status:  SS$_NORMAL, SS$_FAILRSP,
;					  SS$_REJECT, SS$_INSFMEM
;	R1			-Reject reason or fail response reason
;				 if R0 = REJECT or FAILRSP
;	R2			-Addr of ACCEPT_REQ if R0 = success
;	other registers		-Preserved
;-

	.ENABL	LSB

FPC$CONNECT::

	$CHK_CDTSTATE -			; Verify that CDT state 
		CLOSED,-		;  is closed;  if not,
		ERROR=STATE_ERR		;  caller made error
	BSBW	SCS$ALL_ALLBUF		; Allocate all buffers needed
	BLBC	R0,CON_MEM_FAIL		; Branch if failed
	MOVL	CDT$L_PB(R3),R0		; Get path block addr for CDT
	MOVL	PB$L_CDTLST(R0),-	; Link this new CDT onto
		CDT$L_CDTLST(R3)	;  the head of the CDT list
	MOVL	R3,PB$L_CDTLST(R0)	;  for this path
	MOVW	#CDT$C_CON_SENT,-	; Move CDT state to
		CDT$W_STATE(R3)		;  connect sent
	MOVZWL	#CDT$C_CON_PEND,R0	; Get block state
	BSBW	SCS$REQ_SCSSEND		; Request send process to send
					;  CONNECT_REQ
	BRW	SUSP_CONCALL		; Suspend SYSAP connection call

CON_MEM_FAIL:

	PUSHL	R0			; Save error status
	JSB	G^SCS$DEALL_CDT		; Deallocate CDT
	POPL	R0			; Retreive status
	RSB				; Return error to SYSAP

	.DSABL	LSB

	.SBTTL	-	FPC$ACCEPT,	COMPLETE PROCESSING AN ACCEPT

;+
; This routine is JMP'ed to by SCS$ACCEPT which allocates and inits
; a CDT on which the connection is to be completed.  FPC$ACCEPT
; allocates the SCS receive buffer, message buffers, and datagram
; buffers the new connection will need and requests the SCS send 
; process to send an ACCEPT_REQ message to the remote system.  
; Finally, the SYSAP is suspended until the ACCEPT_RSP is received.
;
; Inputs:
;
;	R2			-Addr of listening CDT
;	R3			-Addr of accepting CDT
;	R4			-Addr of PDT
;
;	Listening CDT:
;
;	CDT$W_STATE		-Connect received state
;	CDT$L_SCSMSG		-Addr of message buffer containing CONNECT_REQ
;	CDT$L_PB		-Path Blk of connect request
;	CDT$B_RSTATION		-Remote station addr of connect req
;	CDT$L_PDT		-PDT of connect request
;
;	Accepting CDT:		-All fields zeroed except:
;				 MSGINPUT,DGINPUT,ERRADDR,MINSENT,
;				 INITLREC, and DGREC as specified
;				 by SYSAP;
;				 LCONID, SIZE, TYPE, SUBTYP, WAITQFL
;				 and WAITQBL
;
; Outputs (upon resumption of SYSAP):
;
;	R0			-Status:  SS$_NORMAL, SS$_INSFMEM
;	R1,R2			-Destroyed
;	Other registers		-Preserved
;
;	Listening CDT:
;
;	CDT$W_STATE		-LISTEN state
;
;	Accepting CDT:		-All fields initialized
;
;-

;
; CDT adjacency assumptions:
;

ASSUME	CDT$L_PB+4  EQ CDT$B_RSTATION

	.ENABL	LSB

FPC$ACCEPT::

	$CHK_CDTSTATE -			; Verify that accepting CDT
		CLOSED,-		;  state is closed;  if not,
		ERROR=STATE_ERR		;  caller made error
	MOVL	R4,CDT$L_PDT(R3)	; Set PDT addr in accepting CDT
	MOVQ	CDT$L_PB(R2),-		; Copy from listener CDT to accepting:
		CDT$L_PB(R3)		;  PB addr, remote station, l.o.,
	MOVW	CDT$B_RSTATION+4(R2),-	;  remote station, h.o. 2 bytes
		CDT$B_RSTATION+4(R3)	;
	MOVL	CDT$L_PB(R2),R0		; Get path blk addr of connect
					;  request that was saved in listener
	MOVL	PB$L_CDTLST(R0),-	; Link the new CDT to the
		CDT$L_CDTLST(R3)	;  head of the CDT list
	MOVL	R3,PB$L_CDTLST(R0)	;  for this path
	MOVL	R2,R0			; Save listening CDT addr temporarily
	MOVL	CDT$L_SCSMSG(R2),R2	; Get addr of CONNECT_REQ msg
	CLRL	CDT$L_SCSMSG(R0)	; Zero listener scs recv buffer addr
	MOVL	R0,SCS$L_DST_CONID(R2)	; Save listening CDT addr in msg
	MOVL	R2,CDT$L_SCSMSG(R3)	; Put msg addr in accepting CDT
	BSBW	SCS$COPY_ACCP		; Copy credit, RCONID info from
					;  CONNECT_REQ  to accepting CDT
	MOVAL	SCS$T_SRC_PROC(R2),-	; Set addr of remote proc name
		CDT$L_RPROCNAM(R3)	;
	MOVAL	SCS$T_DST_PROC(R2),-	;  and local proc name in CDT
		CDT$L_LPROCNAM(R3)	;  for later xmit of ACCEPT_REQ
	BSBW	SCS$ALL_ALLBUF2		; Allocate all msg and dg buffers
	BLBS	R0,10$			; Branch if got them
	BSBW	SCS$DEAL_SCSREC		; Deallocate extra SCS recv buffer
	BRW	CON_MEM_FAIL		;  and clean up rest

10$:	MOVW	#CDT$C_ACCP_SENT,-	; Move state to accept sent
		CDT$W_STATE(R3)		;
	MOVZWL	#CDT$C_ACCP_PEND,R0	; Set block state to accept pending
	BSBW	SCS$REQ_SCSSEND		; Ask to send ACCEPT_REQ
	BRW	SUSP_CONCALL		; Suspend SYSAP connection call

	.DSABL	LSB

	.SBTTL	-	FPC$REJECT,	PROCESS A REJECT CALL

;+
; FPC$REJECT is called directly from the SYSAP.  It requests
; the SCS send process to send a REJECT_REQ message with SYSAP-
; specified reject reason.  FPC$REJECT then suspends the SYSAP 
; until the reject response arrives.
;
; Inputs:
;
;	R0			-Reject reason (l.o. 16 bits)
;	R3			-Addr of CDT (listening CDT)
;	R4			-Addr of PDT
;
;	CDT$L_SCSMSG		-Addr of msg buffer containing CONNECT_REQ
;
; Outputs (upon resumption of SYSAP):
;
; 	R0			-SS$_NORMAL, SS$_ILLCDTST
;	R1,R2			-Destroyed
;	other registers		-Preserved
;
;	CDT$W_STATE(R3)		-Connect rec'd --> listen
;-

	.ENABL	LSB

FPC$REJECT::

	$CHK_CDTSTATE -			; Verify CDT state is 
		CON_REC,-		;  connect received;  if not,
		ERROR=STATE_ERR		;  caller made error
	BSBW	SCS$MAP_VMSSTS		; Map VMS status to SCS
	MOVW	R0,CDT$W_REASON(R3)	; Save reject reason
	MOVW	#CDT$C_REJ_SENT,-	; Move CDT state to reject sent
		CDT$W_STATE(R3)		;
	MOVZWL	#CDT$C_REJ_PEND,R0	; Set block state = reject pending
	BSBW	SCS$REQ_SCSSEND		; Ask to send REJECT_REQ msg
	BRW	SUSP_CONCALL		; Suspend the SYSAP connection call

	.DSABL	LSB

	.SBTTL	-	FPC$DCONNECT,	PROCESS A DISCONNECT CALL

;+
; FPC$DCONNECT is called by the SYSAP.  It may be called from 
; three states.  Depending upon the state, the following actions
; are taken:
;
;	STATE		ACTIONS			NEW STATE
;
;	CLOSED		No action; return success to the SYSAP,
;			SS$ALRDYCLOSED.
;
;	OPEN		Trade DISCONNECT's with the remote SYSAP.
;			When the trade is done, return success to 
;			the SYSAP.  The state changes seen by the
;			side initiating the DISCONNECT are:
;			OPEN-->DISC_SENT-->DISC_ACK-->CLOSED.
;			The state changes seen by the passive side are:
;			OPEN-->DISC_REC-->DISC_MTCH-->CLOSED.
;			If both sides initiate a DISCONNECT 
;			simultaneously, so that the requests cross
;			in the mail, then each side sees the
;			following state transitions:
;			OPEN-->DISC_SENT-->DISC_MTCH-->CLOSED.
;
;	CON_ACK,	Unilaterally deallocate CDT and associated
;	DISC_ACK	receive buffers.  Complete original
;			outstanding CONNECT/DISCONNECT with abort
;			status, SS$_ABORT.  Return success on the
;			DISCONNECT call.
;
;	CON_REC		Do a REJECT.
;
;	DISC_REC	Send out a DISCONNECT (part of the normal
;			handshake discussed for OPEN.)  The 
;			DISCONNECT request is sent on the lowest
;			priority queue to delay it till all other
;			pending traffic, including block transfers,
;			is done.  A credit message is forced out
;			first in order to make sure the remote
;			knows about all the credits we have to extend.
;
;	Other states	All other states represent the window 
;			between sending an SCS request and getting 
;			the response.  During this window the CDT
;			cannot be unilaterally destroyed and so
;			error status SS$_ILLCDTST is returned to
;			the SYSAP.
;
;	Inputs:
;
;		R0			-Disconnect reason
;		R3			-Addr of CDT being disconnected
;		R4			-Addr of PDT
;
; 	Outputs:
;
;		R0			-Status:  SS$_NORMAL, SS$_ILLCDTST
;		R1,R2,R3		-Destroyed
;		Other registers		-Preserved
;-

	.ENABL	LSB

FPC$DCONNECT::

	MOVL	CDT$L_PB(R3),R1		; Get PB addr
	CMPW	PB$W_STATE(R1),-	; Is path in either
		#PB$C_VC_FAIL		;  virtual circuit fail or
	BNEQ	2$			; 
	BRW	ERR$DISC_VCFAIL		;

2$:	CMPW	PB$W_STATE(R1),-	;  power fail state?  
		#PB$C_PWR_FAIL		;
	BNEQ	3$			;
	BRW	ERR$DISC_PWFAIL		; If so, call different DISCONNECT

3$:	$DISPATCH -
		CDT$W_STATE(R3),-		; Dispatch on CDT state:
		<-				;  (CLOSED/LISTEN handled by SCSLOA)
		<CDT$C_OPEN,	DISC_OPEN>,-	;  OPEN,
		<CDT$C_CON_ACK,	DISC_CON_ACK>,-	;  CON_ACK,
		<CDT$C_DISC_ACK,DISC_DISC_ACK>,-;  DISC_ACK,
		<CDT$C_CON_REC,	FPC$REJECT>,-	;  CON_REC,
		<CDT$C_DISC_REC,DISC_DISC_REC>,-;  DISC_REC,
		<CDT$C_CON_SENT,DISC_ILLSTATE>,-;  CON_SENT,
		<CDT$C_DISC_SENT,DISC_ILLSTATE>,- ;  DISC_SENT,
		<CDT$C_REJ_SENT,DISC_ILLSTATE>,-;  REJ_SENT,
		<CDT$C_ACCP_SENT,DISC_ILLSTATE>,- ;  ACCP_SENT
		<CDT$C_DISC_MTCH,DISC_ILLSTATE>,- ;  Matching DISC sent
		 >				  ;  (CDT$C_VC_FAIL went to ERR$DISC_x

	BUGCHECK  CIPORT,NONFATAL	; If none of the above
					;  states, system error,
					;  possibly recoverable
	MOVZWL	#SS$_NORMAL,R0		; If bugcheck nonfatal, return
	RSB				;  success to SYSAP

;
; Connection can't be closed right now.  Return error to SYSAP:
;

DISC_ILLSTATE:

	MOVZWL	#SS$_ILLCDTST,R0	; Status = illegal connx state
	RSB				; Return error to SYSAP

;
; CDT has a CONNECT or DISCONNECT request already pending.  Unilaterally
; clean up the CDT.  Complete pending request with abort status. 
; Complete this DISCONNECT with success.
;

DISC_CON_ACK:
DISC_DISC_ACK:

	MOVQ	R4,-(SP)		; Save R4, R5
	MOVL	CDT$L_FR5(R3),R5	; Restore context from pending
	PUSHL	CDT$L_FPC(R3)		;  connx mgmt call
	BSBW	SCS$DEAL_ALLBUF		; Clean up all receive buffers
	JSB	G^SCS$DEALL_CDT		; Deallocate CDT (close status)
	MOVZWL	#SS$_ABORT,R0		; Set status to abort
	JSB	@(SP)+			; Restore pending call thread
	MOVQ	(SP)+,R4		; Restore R4, R5
	MOVZWL	#SS$_NORMAL,R0		; Set DISCONNECT status to ok
	RSB				; Return from DISCONNECT

;
; SYSAP has received an unsolicited DISCONNECT request from the
; remote SYSAP and now wishes to issue the matching DISCONNECT.
;

DISC_DISC_REC:

	BSBW	SCS$MAP_VMSSTS		; Convert reason from VMS to SCS
	MOVW	R0,CDT$W_REASON(R3)	; Save DISCONNECT reason
	MOVW	#CDT$C_DISC_MTCH,-	; Move CDT state to
		CDT$W_STATE(R3)		;  matching DISCONNECT sent
	MOVZWL	#CDT$C_DISC_PEND,R0	; Set block state to send DISCONNECT
	BSBW	SCS$REQ_SCSSEND		; Send out the DISCONNECT
	BRW	SUSP_CONCALL		; Suspend SYSAP till done

;
; Connection is OPEN.  Force sending of any unextended credits (may
; send 0 credits).  Send out a DISCONNECT on the lowest priority queue.
; Move CDT state from OPEN to DISC_SENT.
;

DISC_OPEN:

	BSBW	SCS$MAP_VMSSTS		; Convert status to SCS
	MOVW	R0,CDT$W_REASON(R3)	; Save DISCONNECT reason
	MOVW	#CDT$C_DISC_SENT,-	; Set CDT state to 
		CDT$W_STATE(R3)		;  show DISCONNECT sent
	MOVW	#CDT$C_DCR_PEND,R0	; Block state will be disconnect
					;  + credit pending
	TSTW	CDT$W_BLKSTATE(R3)	; CDT currently on SCS send
					;  queue for a credit msg?
	BNEQ	10$			; Branch if yes
	BSBW	SCS$REQ_SCSSEND		; Request credit msg followed
					;  by disconnect
	BRB	20$			; Join common suspend

10$:	MOVW	R0,CDT$W_BLKSTATE(R3)	; Change credit pending to
					;  credit+disconnect pending
	
20$:	BRW	SUSP_CONCALL		; Suspend SYSAP till DISCONNECT
					;  is done

	.DSABL	LSB

	.SBTTL	SEQUENCED MESSAGE CALLS
	.SBTTL	-	FPC$ALLOCMSG,	ALLOCATE A MESSAGE BUFFER

;+
; FPC$ALLOCMSG checks if there is at least one send credit.  If not, the
; SYSAP is suspended behind other waiting SYSAP's until there is.  The
; message buffer is allocated from nonpaged pool.  If insufficient pool
; is available, then the SYSAP is suspended until pool is available.
; The destination connection ID is then copied to the SCS header
; at this time so that the message can be sent harmlessly even if
; a power failure should occur.  (It will be discarded at the receiving
; end upon detection of connect ID sequence number mismatch.)  Finally,
; the address of the start of the application data within the buffer is 
; computed and returned to the SYSAP.
;
; Inputs:
;
;	R4			-Addr of PDT
;	R5			-Addr of CDRP
;	CDRP$L_CDT		-Addr of CDT
;
; Outputs:
;
;	R0			-Status:  SS$_NORMAL, SS$_ILLCDTST
;	R1			-Destroyed
;	R2			-Addr of message buffer, if status=success
;	Other registers		-Preserved
;
;	CDRP$L_MSG_BUF		-Addr of message buffer, if status=success
;-

	.ENABL	LSB

FPC$ALLOCMSG::

	MOVL	CDRP$L_CDT(R5),R1	; Get CDT addr
	$CHK_CDTSTATE	-		; Verify connection state
		OPEN,-			;  is open.
		ERROR=STATE_ERR,-	; Else report error to SYSAP
		CDT=R1			;
	POPL	CDRP$L_SAVD_RTN(R5)	; Save 1st level return
	TSTW	CDT$W_SEND(R1)		; Got any credit for send?
	BGTRU	10$			; Branch if so
	$SUSP_SCS	-		; Else suspend SCS routine
		@CDT$L_CRWAITQBL(R1)	;  on credit wait queue
	
10$:	BSBW	SCS$ALLOC_MSG		; Allocate a message buffer
	BLBS	R0,20$			; Branch if got it
	$SUSP_SCS	-		; Else suspend this routine
		@PDT$L_WAITQBL(R4)	;  on pool wait queue
	BRB	10$			; Try to allocate now
	
20$:	MOVL	CDRP$L_CDT(R5),R1	; Get CDT addr again
	MOVL	CDT$L_RCONID(R1),-	; Set destination connect
		SCS$L_DST_CONID(R2)	;  ID in SCS header
	DECW	CDT$W_SEND(R1)		; Mark one credit used
	ADDL	PDT$L_MSGHDRSZ(R4),R2	; compute addr of start of appl
	MOVL	R2,CDRP$L_MSG_BUF(R5)	;  data and save in CDRP
	MOVZWL	#SS$_NORMAL,R0		; Set status  to success
	JMP	@CDRP$L_SAVD_RTN(R5)	; Return to SYSAP

	.DSABL	LSB

	.SBTTL	-	FPC$DEALLOMSG,	DEALLOCATE A MESSAGE BUFFER
	.SBTTL	-	FPC$DEALRGMSG,	DEALLOCATE A MESSAGE BUFFER,
	.SBTTL	-			ARGUMENTS PASSED IN REGISTERS

;+
; FPC$DEALLOMSG resets the message address specified by the caller to
; the top of the message buffer and compares the current number of 
; receive message buffers with the initial count specified at the 
; time of the connect.  If the current receive count is not less than
; the initial, then the message buffer is deallocated to nonpaged
; pool.  If the current receive count is less than the initial,
; then the buffer is added to the free message queue and the pending
; receive count is incremented.  If the receive count was also less
; than the minimum required by the remote SYSAP plus the flow control
; cushion (SCS$GW_FLOWCUSH), then the CDT is queued for sending a
; CREDIT message to the remote.
;
; Entry FPC$DEALLMSG2 is called from PADRIVER with the buffer
; address and CDT address already set up in registers.
;
; Entry FPC$DEALRGMSG is called with the same arguments as DEALLOMSG,
; but in registers instead of the CDRP.
;
; Inputs:
;
;	R2			-Addr of message buffer (FPC$DEALLMSG2)
;	R3			-Addr of CDT (FPC$DEALLMSG2)
;	R4			-Addr of PDT
;	R5			-Addr of CDRP
;	CDRP$L_CDT		-Addr of CDT (FPC$DEALLOMSG)
;	CDRP$L_MSG_BUF		-Addr of msg buffer (FPC$DEALLOMSG)
;
; Outputs:
;
;	R0-R2			-Destroyed
;	Other registers		-Preserved
;	CDRP$L_MSG_BUF(R5)	-0 (FPC$DEALLOMSG only)
;-

	.ENABL	LSB

FPC$DEALLOMSG::

	SUBL3	PDT$L_MSGHDRSZ(R4),-	; Get addr of buffer
		CDRP$L_MSG_BUF(R5),R2	; in R2
	PUSHL	R3			; Save caller's R3
	MOVL	CDRP$L_CDT(R5),R3	; Get addr of CDT
	BSBB	FPC$DEALLMSG2		; Call routine to deallocate
	POPL	R3			; Restore caller's R3
	CLRL	CDRP$L_MSG_BUF(R5)	; Zero msg addr in CDRP
	RSB				; Return
	
FPC$DEALRGMSG::				; Entry for appl data pointer in R2
					;  and CDT addr in R3
	SUBL2	PDT$L_MSGHDRSZ(R4),R2	; Get addr of buffer

FPC$DEALLMSG2::				; Entry for buffer addr in R2 already

	CMPW	CDT$W_REC(R3),-		; Credits held by remote less than
		CDT$W_INITLREC(R3)	;  the initial credit extended?
	BLSSU	10$			; Branch if so
	BSBW	SCS$DEAL_MSG		; Deallocate message buffer
					;  to nonpaged pool
	CLRL	R2			;***Debug code
	RSB				; Return to SYSAP

10$:	BSBW	SCS$QUEUE_MSG		; Insert buffer on free queue
	INCW	CDT$W_PENDREC(R3)	; Reflect insert in credit
	ADDW3	G^SCS$GW_FLOWCUSH,-	; Compute cushion + minimum #
		CDT$W_MINREC(R3),R0	;  send credits req'd by remote
	CMPW	CDT$W_REC(R3),R0	; Is current # recv buffers less
					;  cushion + minimum?
	BGTRU	30$			; Branch if not
	MOVZWL	#CDT$C_CR_PEND,R0	; Get credit block state code
	TSTW	CDT$W_BLKSTATE(R3)	; CDT waiting to send credit or
					;  or DISCONNECT bookkeeping already?
	BNEQ	30$			; Branch if so

20$:	BSBW	SCS$REQ_SCSSEND		; Request xmit of credit message

30$:	RSB				; Return to SYSAP

	.DSABL	LSB

	.SBTTL	-	FPC$RCHMSGBUF,	RECYCLE MESSAGE BUFFER
	.SBTTL	-			AT HIGH PRIORITY
	.SBTTL	-	FPC$RCLMSGBUF,	RECYCLE MESSAGE BUFFER
	.SBTTL	-			AT LOW PRIORITY

;+
; FPC$RCxMSGBUF checks if there is at least one send credit.  If
; not, the SYSAP is suspended until there is.  FPC$RCxMSGBUF then
; decrements the send credit.  The wait, if required, places the 
; SYSAP CDRP at the end of the wait queue for low priority and at
; the head of the queue for high priority.  The address of the
; buffer being recycled is returned in both R2 and CDRP$L_MSG_BUF.
; The remote connection ID s set in the SCS header so that the
; message can be sent harmlessly even if a power failure should occur.
; (It will be discarded by the receiving SCS.)
;
; Inputs:
;
;	R4			-Addr of PDT
;	R5			-Addr of CDRP
;	CDRP$L_CDT		-Addr of CDT
;	CDRP$L_MSG_BUF		-Addr of msg buffer
;
; Outputs:
;
;	R0			-Status:  SS$_NORMAL, SS$_ILLCDTST
;	R2			-Addr of message buffer
;	R1			-Destroyed
;	Other registers		-Preserved
;	CDRP$L_MSG_BUF(R5)	-Addr of message buffer
;-

	.ENABL	LSB

FPC$RCHMSGBUF::

	MOVL	CDRP$L_CDT(R5),R1	; Get CDT addr
	MOVAL	CDT$L_CRWAITQFL(R1),R0	; Get addr of head of wait queue
	BRB	10$			; Join common processing

FPC$RCLMSGBUF::

	MOVL	CDRP$L_CDT(R5),R1	; Get CDT addr
	MOVL	CDT$L_CRWAITQBL(R1),R0	; Get addr of end of wait queue
	
10$:	$CHK_CDTSTATE	-		; Verify connection state
		OPEN,-			;  is open
		ERROR=STATE_ERR,-		; Else report error to SYSAP
		CDT=R1			;
	POPL	CDRP$L_SAVD_RTN(R5)	; Copy return to SYSAP from stack
					;  to CDRP
	TSTW	CDT$W_SEND(R1)		; Got a send credit?
	BGTRU	20$			; Branch if so
	MOVL	R0,R1			; Get queue hdr in less volatile
					;  register
	$SUSP_SCS (R1)			; Else suspend this routine
	MOVL	CDRP$L_CDT(R5),R1	; Retreive CDT addr

20$:	MOVL	CDRP$L_MSG_BUF(R5),R2	; Get msg addr in register
	DECW	CDT$W_SEND(R1)		; Mark one credit used
	MOVL	CDT$L_RCONID(R1),-	; Set remote CONID in SCS header
		<SCS$L_DST_CONID - SCS$C_APPL_BASE>(R2)
	MOVZWL	#SS$_NORMAL,R0		; Set status to success
	JMP	@CDRP$L_SAVD_RTN(R5)	; Return to SYSAP

	.DSABL	LSB

	.SBTTL	-	FPC$SENDMSG,	SEND A SEQUENCED MESSAGE

;+
; The SCS header of the specified message buffer is filled in.
; If the response ID is 0, then the message is queued for transmission
; with RETFLAG = 0 thus channeling the sent buffer to the response
; queue for reclaim.  If the response ID is non-zero, then a
; responsed is expected from the remote SYSAP and the messag is sent
; with RETFLAG = FALSE.  RETFLAG = FALSE channels the sent buffer to
; the message free queue in anticipation of the response.  In this
; case the receive credit is also incremented to account for the
; buffer being added to the free queue.  All messages are sent
; on the high priority queue.
;
; Inputs:
;
;	R1			-# bytes application data (FPC$SENDCNTMSG)
;	R4			-Addr of PDT
;	R5			-Addr of CDRP
;	CDRP$L_CDT(R5)		-Addr of CDT
;	CDRP$L_MSG_BUF(R5)	-Addr of message 
;	CDRP$L_RSPID(R5)	-RSPID (to set RETFLG)
;
; Outputs:
;
;	R0			-Status:  SS$_NORMAL, SS$_ILLCDTST
;	R1,R2			-Destroyed
;	Other registers		-Preserved
;
;	CDRP$L_MSG_BUF(R5)	-Zeroed to show msg buffer gone
;-

	.ENABL	LSB

FPC$SNDCNTMSG::

	PUSHL	R3			; Save caller's R3
	MOVL	CDRP$L_CDT(R5),R3	; Get CDT addr in R3
	$CHK_CDTSTATE	-		; Verify connection is
		OPEN,-			;  OPEN
		ERROR=STATE_ERR_R3,-	; Else report error to SYSAP
		CDT=R3			;
	SUBL3	PDT$L_MSGHDRSZ(R4),-	; Get start of
		CDRP$L_MSG_BUF(R5),R2	;  message buffer
	ADDW3	#<SCS$C_APPL_BASE - PPD$C_LENGTH>,-
		R1,SCS$W_LENGTH(R2)	; Msg length = SCS header size +
					;  application data length
	BRB	COMMON_SEND		; Join common message send code

FPC$SENDMSG::

	PUSHL	R3			; Save caller's R3
	MOVL	CDRP$L_CDT(R5),R3	; Get CDT addr in R3
	$CHK_CDTSTATE	-		; Verify connection is
		OPEN,-			;  open
		ERROR=STATE_ERR_R3,-	; Else report error to SYSAP
		CDT=R3			;
	SUBL3	PDT$L_MSGHDRSZ(R4),-	; Get start of message buffer
		CDRP$L_MSG_BUF(R5),R2	;
	SUBW3	#PPD$C_LENGTH,-		; Msg length = standard max
		PDT$W_MQELEN(R4),-	;  size - PPD layer size
		SCS$W_LENGTH(R2)	;

COMMON_SEND:

	MOVZBL	#1,R1			; Assume RETFLAG will be true
	TSTL	CDRP$L_RSPID(R5)	; RSPID = 0?
	BEQL	10$			; Branch if so
	CLRL	R1			; Else set flag to false
	INCW	CDT$W_PENDREC(R3)	; Incr pending receive credit

10$:	BSBW	FMT_SCSMSGHDR		; Fill in the SCS header
	$SNDMSG	R1			; Send the message with RETFLAG in R1
	POPL	R3			; Restore SYSAP's R3
	CLRL	CDRP$L_MSG_BUF(R5)	; Mark msg as no longer held by CDRP
	TSTL	R1			; Was RETFLAG true?
	BNEQ	20$			; Branch if yes
	$SUSP_FP			; Save fork process' context

20$:	MOVZWL	#SS$_NORMAL,R0		; Set status = success
	RSB				; Return to SYSAP

	.DSABL	LSB

	.SBTTL	DATAGRAM SERVICE CALLS
	.SBTTL	-	FPC$ALLOCDG,	ALLOCATE A DATAGRAM BUFFER

;+
; FPC$ALLOCDG allocates one datagram buffer from nonpaged pool.  If
; none is available, error status is returned to the caller.  Otherwise,
; the address of space for application data within the buffer
; is computed and returned to the caller.
;
; Inputs:
;
;	R4			-Addr of PDT
;	R5			-Addr of CDRP
;
; Outputs:
;	
;	R0			-Status:  SS$_NORMAL, SS$_INSFMEM
;	R2			-Addr of dg, start of application data
;	CDRP$L_MSG_BUF		-Copy of R2
;	Other registers		-Preserved
;-

	.ENABL	LSB

FPC$ALLOCDG::

	BSBW	SCS$ALLOC_DG		; Allocate 1 dg buffer from pool
	BLBC	R0,DG_ALC_FAIL		; Branch if failed
	ADDL	PDT$L_DGHDRSZ(R4),R2	; Compute addr of appl data
	MOVL	R2,CDRP$L_MSG_BUF(R5)	; Save addr in CDRP
	MOVZWL	#SS$_NORMAL,R0		; Set status to success
	RSB				; Return

DG_ALC_FAIL:

	MOVZWL	#SS$_INSFMEM,R0		; Set status to failure
	RSB				; Return

	.DSABL	LSB

	.SBTTL	-	FPC$DEALLOCDG,	DEALLOCATE A DATAGRAM BUFFER
	.SBTTL	-			TO NONPAGED POOL

;+
; FPC$DEALLOCDG simply converts the datagram aaddress to the address
; of the start of the buffer containing the datagram and calls
; COM$DRVDEALMEM.
;
; Inputs:
;
;	R2			-Addr of datagram
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0			-Destroyed
;	R2			-0
;	Other registers		-Preserved
;-

	.ENABL	LSB

FPC$DEALLOCDG::

	SUBL3	PDT$L_DGOVRHD(R4),R2,R0	; Compute start of buffer
	JSB	G^COM$DRVDEALMEM	; Deallocate buffer
	CLRL	R2			; Mark dg addr as gone
	RSB				; Return to SYSAP

	.DSABL	LSB

	.SBTTL	-	FPC$QUEUEDG,	QUEUE A SYSAP SUPPLIED BUFFER
	.SBTTL	-			TO THE DATAGRAM FREE QUEUE

;+
; FPC$QUEUE allows a SYSAP to supply the port with a buffer to insert
; on the datagram free queue.  The SYSAP must correctly set the type
; and size field before calling this routine.  The datagram receive
; count in the SYSAP's CDT is incremented.
;
; INPUTS:
;
;	R2			-Addr of start of buffer (NOT appl data)
;	R3			-Addr of CDT
;	R4			-Addr of PDT
;	CDT$W_DGREC(R3)		-Current DG receive count
;
; OUTPUTS:
;
;	R0			-Status:  SS$_NORMAL
;	R1			-Preserved
;	R2			-Preserved
;	CDT$W_DGREC(R3)		-Incremented
;-

FPC$QUEUEDG::

	MOVW	PPD$W_SIZE(R2),R0	; Compute size of dg - net
	SUBW	PDT$L_DGNETHD(R4),R0	;  overhead
	ADDL	PDT$L_DGNETHD(R4),R2	; Step to start of PPD
	MOVW	R0,PPD$W_SIZE(R2)	; Save size of remainder
	MOVW	#DYN$C_CIDG,-		;  and structure type in 
		PPD$B_TYPE(R2)		;  PPD header
	BSBW	SCS$QUEUE_DG		; Insert buffer on port queue
	INCW	CDT$W_DGREC(R3)		; Step SYSAP's receive count
	BRB	Q_SUCCESS		; Finish up

	.SBTTL	-	FPC$QUEUEMDGS,	ALLOCATE DG'S AND QUEUE FOR
	.SBTTL	-			RECEIVES OR
	.SBTTL	-			DEQUEUE DG'S AND RETURN TO
	.SBTTL	-			NONPAGED POOL

;+
; FPC$QUEUEMDGS is used by SYSAP's to alter the number of datagram buffers
; they have queued for receives.  The datagram count is positive if
; datagrams are to be allocated from pool and queued for receives.  The
; count agrument is negative if datagrams are to be removed from the queue
; and returned to nonpaged pool.
;
; If datagrams are being added, then for each one allocated and queued,
; the datagram receive count in the SYSAP's CDT is incremented.  If there
; is insufficient pool for all to be allocated, then the number actually
; queued is returned to the SYSAP with a warning status.
;
; If datagrams are being withdrawn from the queue, then for each
; one dequeued and returned to pool, the datagram receive count in the
; SYSAP's CDT is decremented. If the datagram receive count reaches 
; 0 before all that the SYSAP requested have been dequeued, then the
; number actually dequeued is returned to the caller with warning
; status.
;
; Inputs:
;
; 	R1			-# of dg's to add (+) or
;				 to withdraw (-)
;	R3			-Addr of CDT
;	R4			-Addr of PDT
;	CDT$W_DGREC(R3)		-Current dg receive count
;
; Outputs:
;
;	R0			-Status:  SS$_NORMAL, SS$_DGQINCOMP
;				 (Datagram queuing incomplete)
;	R1			-# actually added (+) or withdrawn (-)
;	R2			-Destroyed
;	Other registers		-Preserved
;	CDT$W_DGREC(R3)		-Updated
;-

	.ENABL	LSB

FPC$QUEUEMDGS::

	CLRL	-(SP)			; Set running dg count = 0
	TSTL	R1			; Check dg count requested
	BEQL	Q_SUCCESS		; Branch if nothing to do
	BLSS	DQUEUE_DG		; Branch if withdrawing

QUEUE_DG:

	PUSHL	R1			; Save count argument
	BSBW	SCS$ALLOC_DG		; Allocate a dg buffer
	POPL	R1			; Restore argument
	BLBC	R0,Q_INCOMPLETE		; Branch if allocate failed
	BSBW	SCS$QUEUE_DG		; Else insert buffer on port queue
	INCW	CDT$W_DGREC(R3)		; Step SYSAP's receive count
	AOBLSS	R1,(SP),QUEUE_DG	; Step running tally and branch 
					;  if less than requested
	POPL	R1			; Retreive total tally from stack

Q_SUCCESS:

	MOVZWL	#SS$_NORMAL,R0		; Set status to success
	RSB				; Return to SYSAP

DQUEUE_DG:

	MNEGL	R1,R1			; Trun request count positive

20$:	TSTW	CDT$W_DGREC(R3)		; SYSAP have more dg's queued?
	BLEQ	DQ_INCOMPLETE		; Branch if not
	$REM_DFREEQ			; Remove a dg from free queue
	BVS	Q_INCOMPLETE		; Branch if none
	BSBW	SCS$DEAL_DG		; Return dg buffer to pool
	DECW	CDT$W_DGREC(R3)		; Decrement SYSAP's recv count
	AOBLSS	R1,(SP),20$		; Step running tally, branch
					;  if more to do
	MNEGL	(SP)+,R1		; Retreive total tally and negate
	BRB	Q_SUCCESS		; Join common success exit

DQ_INCOMPLETE:

	MNEGL	(SP),(SP)		; Turn tally into negative #

Q_INCOMPLETE:

	POPL	R1			; Retreive tally from stack
	MOVZWL	#SS$_DGQINCOMP,R0	; Set status to error
	RSB				; Return

	.DSABL	LSB

	.SBTTL	-	FPC$SENDDG,	SEND DATAGRAM

;+
; FPC$SENDDG formats and sends the caller-specified datagram.  The
; SYSAP can specify via the flags input argument what happens to the
; buffer once it has been sent:
;
;	flags	= SYSAP$C_DISPQ implies that the buffer is placed
;		  on the datagram free queue for a future receive.
;		  The SYSAP's datagram receive count is incremented
;		  in the CDT in anticipation of the buffer going on
;		  the free queue.
;
;		= SYSAP$C_DISPRET says that the SYSAP wants the sent
;		  buffer back, so RETFLAG is set to 1 (true) and
;		  DISPOSAL is 1.
;		
;		= SYSAP$C_DISPPO says that the SYSAP wants SCS to 
;		  put the sent buffer in nonpaged pool, so RETFLAG
;		  is set to 1 (true) and DISPOSAL = 0.
;
; This data is all expressed in table DG_SENT_FLGS.
;
; Inputs:
;
;	R0			-Input flag described above
;	R1			-Length of application data in dg
;	R4			-Addr of PDT
;	R5			-Addr of CDRP
;	CDRP$L_CDT		-Addr of CDT
;	CDRP$L_MSG_BUF		-Addr of datagram
;
; Outputs:
;
;	R0			-Status:  SS$_NORMAL, SS$_ILLCDTST
;	Other registers		-Preserved
;-

;
; Table of correct settings of RETFLAG and DISPOSAL flag respectively
; for each option the SYSAP can specify in R0:
;

DG_SENT_FLGS:

	.BYTE	0,0			; R0 = SYSAP$C_DISPQ
	.BYTE	1,1			; R0 = SYSAP$C_DISPRET
	.BYTE	1,0			; R0 = SYSAP$C_DISPPO

	.ENABL	LSB

FPC$SENDDG::

	PUSHL	R3			; Save caller's R3
	MOVL	CDRP$L_CDT(R5),R3	; Get addr of CDT
	$CHK_CDTSTATE	-		; Verify that connection state
		OPEN,-			;  is open
		ERROR=STATE_ERR_R3,-	; Else report error to SYSAP
		CDT=R3			;
	SUBL3	PDT$L_DGHDRSZ(R4),-	; Back up dg addr to start of PPD
		CDRP$L_MSG_BUF(R5),R2	; 
	BSBW	FMT_SCSDGHDR		; Fill in rest of SCS header
	TSTB	R0			; Dg going on to free queue?
	BNEQ	10$			; Branch if not
	INCW	CDT$W_DGREC(R3)		; Else step recv count in anticipation
	
10$:	MOVAW	DG_SENT_FLGS[R0],R0	; Get addr of RETFLAG/DISPOSAL flags
	$SNDDG	RETFLAG=0(R0),-		; Send datagram
		DISPOSAL=1(R0)		;
	POPL	R3			; Restore caller's R3
	CLRL	R2			;***DEBUG
	CLRL	CDRP$L_MSG_BUF(R5)	; Show dg buffer gone
	MOVZWL	#SS$_NORMAL,R0		; Set status to success
	RSB				; Return to SYSAP

	.DSABL	LSB

	.SBTTL	BLOCK TRANSFER CALLS
	.SBTTL	-	FPC$MAP,	MAP A BUFFER
	.SBTTL	-	FPC$MAPBYPASS,	MAP A BUFFER W/
	.SBTTL	-			NO ACCESS CHECKING
	.SBTTL	-	FPC$MAPIRP,	MAP A BUFFER W/
	.SBTTL	-			ARGUMENTS IN IRP
	.SBTTL	-	FPC$MAPIRPBYP,	MAP A BUFFER W/
	.SBTTL	-			ARGUMENTS IN IRP AND NO
	.SBTTL	-			ACCESS CHECKING

;+
; Each of the entries converts its inputs to a set of common inputs:
;
;	R1			-Addr of 3 longwd array containing
;				 SVAPTE, BOFF, and BCNT (size) of
;				 buffer to map.
;	R2			-Buffer descriptor flags consisting of 
;				 valid (bit 15), access mode = 0/1/2/3
;				 (bits 13,14), and access checking = 0/1
;				 for disabled/enabled (bit 12).
;
; Common map processing then consists of allocating a buffer descriptor
; from the pool (common to all CI ports), filling in the buffer descriptor
; and then filling in the SYSAP's buffer handle.
;
; If no buffer descriptor is available, then the common inputs are
; saved temporarily in CDT$L_RPROCNAM/LPROCNAM.  The SCS MAP routine
; is suspended until resumed by the deallocation of a buffer 
; descriptor.  Upon resumption, all context is retreived including R1
; and R2 and a buffer descriptor allocated.
;
; Inputs to all MAP calls:
;
;	R4			-PDT addr
;	R5			-CDRP addr
;
;	CDRP$L_CDT		-Addr of CDT
;	CDRP$L_LBUFH_AD		-Addr of SYSAP's buffer handle
;
;	CDT$L_RCONID		-Remote connection ID
;
; Inputs to MAP, MAPBYPASS:
;
;	R1			-Addr of SVAPTE/BOFF/BCNT array
;	R2			-Access mode = 0/1/2/3 for kernel/
;				 exec/super/user
;
; Inputs to MAPIRP, MAPIRPBYP:
;
;	CDRP$L_SVAPTE(R5)	= Addr of SVAPTE in IRP
;	CDRP$B_RMOD(R5)		= Addr of access mode
;
; Outputs for all map routines:
;
;	@CDRP$L_LBUFH_AD(R5)	-Filled in with byte offset of buffer,
;				 buffer name, local connection ID
;-

	.ENABL	LSB

FPC$MAPIRPBYP::

	MOVAL	CDRP$L_SVAPTE(R5),R1	; Get addr in IRP of SVAPTE
	MOVZBL	CDRP$B_RMOD(R5),R2	;  and access mode

FPC$MAPBYPASS::

	ASSUME	CIBD$V_V EQ 15

	BISW	#4,R2			; Set valid bit to left of access mode
	ASHL	#CIBD$V_ACMOD,R2,R2	; Position valid, access mode
	BRB	MAP_COMMON		; Join common code

FPC$MAPIRP::

	BITW	#<IRP$M_PAGIO!IRP$M_SWAPIO>,-
		CDRP$W_STS(R5)		; Is this page/swap I/O?
	BNEQ	FPC$MAPIRPBYP		; Branch if so to bypass 
	MOVAL	CDRP$L_SVAPTE(R5),R1	; Get addr in IRP of SVAPTE
	MOVZBL	CDRP$B_RMOD(R5),R2	;  and access mode

FPC$MAP::

	ASHL	#CIBD$V_ACMOD,R2,R2	; Position access mode
	BISW	#CIBD$M_V!CIBD$M_AC,R2	; Set valid and access check

MAP_COMMON:

	POPL	CDRP$L_SAVD_RTN(R5)	; Pop return from stack to CDRP
	
ALLOC_BD:

	PUSHL	R3			; Save SYSAP register
	MOVL	G^SCS$GL_BDT,R0		; Get addr of buffer desc table
	MOVL	CIBDT$L_FREEBD(R0),R3	; Get addr of 1st free desc
	BEQL	WAIT_BD			; Branch if none
	MOVL	CIBD$L_LINK(R3),-	; Remove BD from linked 
		CIBDT$L_FREEBD(R0)	;  List

	ASSUME	CDRP$L_SVAPTE+4 EQ CDRP$W_BOFF
	ASSUME	CDRP$W_BOFF+2   EQ CDRP$L_BCNT

					; Fill in buffer descriptor:
	MOVL	(R1)+,CIBD$L_SVAPTE(R3)	;  Addr of PTE mapping buff
	ADDW3	R2,(R1)+,CIBD$W_FLAGS(R3) ;  Byte offset, access, valid
	MOVL	(R1),CIBD$L_BLEN(R3)	;  Size of buffer
	MOVL	R5,CIBD$L_CDRP(R3)	;  CDRP

	SUBL3	G^SCS$GL_BDT,R3,R0	; Compute index
	ASHL	#-4,R0,R0		;  to buffer descriptor
	INSV	CIBD$W_KEY(R3),#16,#16,R0  ; Put seq # in h.o. bits
					   ;  to make buffer name
	MOVL	CDRP$L_LBUFH_AD(R5),R3	; Get buffer handle to fill in

	ASSUME	CIBHAN$L_BOFF+4 EQ CIBHAN$L_BNAME
	ASSUME	CIBHAN$L_BNAME+4 EQ CIBHAN$L_RCONID

	CLRL	(R3)+			; Clear transfer offset
	MOVL	R0,(R3)+		; Copy buffer name
	MOVL	CDRP$L_CDT(R5),R0	; Get CDT addr
	MOVL	CDT$L_RCONID(R0),(R3)	; Put CONID into handle
	POPL	R3			; Restore SYSAP's R3
	JMP	@CDRP$L_SAVD_RTN(R5)	; Return to SYSAP

WAIT_BD:

	MOVL	CDRP$L_CDT(R5),R3	; Get CDT addr
	MOVQ	R1,CDT$L_RPROCNAM(R3)	; Save R1, R2 arguments
	MOVL	CDRP$L_LBUFH_AD(R5),R1	; Get buffer handle addr
	CLRL	CIBHAN$L_BNAME(R1)	;  and zero buffer name to show
					;  that none is allocated
	POPL	R3			; Restore SYSAP's R3
	$SUSP_SCS	-		; Suspend this routine
		@CIBDT$L_WAITBL(R0)	;  on availability of BD
	MOVL	CDRP$L_CDT(R5),R0	; Get CDT addr again
	MOVQ	CDT$L_RPROCNAM(R0),R1	; Get SYSAP inputs again
	BRW	ALLOC_BD		; Try to allocate now

	.DSABL	LSB

	.SBTTL	-	FPC$REQDATA,	BLOCK XFER READ
	.SBTTL	-	FPC$SENDDATA,	BLOCK XFER WRITE

;+
; These two calls are the same except for the direction of
; the block transfer.  FPC$REQDATA runs as follows:
;
; 1.	Using the CDT address specified in the SYSAP's remote buffer
;	handle, fill in the allcoated message buffer with the REQDAT
;	opcode, remote station, and all frills set to 0. (512 byte
;	data pkt, response bit off, path select auto.)  The response
;	bit = 0 will cause the REQDAT buffer to be put on the free
;	queue once  it has been sent where it will wait to receive the
;	DATRET/DATREC notification of transfer completion.
;
; 2.	Fill in the sender buffer name and byte offset with info
;	from the remote buffer handle.  Note that the net buffer offset
;	is the sum of the offset in the buffer handle and the offset
;	specified by the SYSAP in the CDRP.  The buffer handle offset
;	is normally 0.  for third party transfers, it may be transformed
;	by the SYSAP acting as the manager of the third party transaction
;	in the case where that SYSAP discovers that it must break a
;	transfer into transfers from different sources.  The CDRP byte
;	offset is intended for use by a SYSAP doing segmented transfers.
;
; 3.	Fill in the receiver buffer name and byte offset with info
;	from the local buffer handle.
;
; 4.	Set the XCT_ID to the local CONID (from the local buffer handle)
;	followed by the RSPID from the CDRP.  Set the XCT_LEN to the
;	value specified in the CDRP.
;
; 5.	Map the RSPID to the CDRP, save the SYSAP's context in the CDRP;
;	send the REQDAT message, and return to the caller's caller.
;	The SYSAP remains suspended until the transfer completes at which
;	time the SYSAP is resumed at the instruction following the call
;	to request data.
;
; FPC$SENDDATA has its own version of steps 1-3.  In this case the
; send buffer information is in the local buffer handle and the receive 
; buffer information is in the remote buffer handle.
;
; Inputs:
;
;	R4			-PDT addr
;	R5			-CDRP addr
;
;	CDRP$L_RSPID		-RSPID to use to correlate tramsfer
;				 completion with initiation thread
;	CDRP$L_MSG_BUF		-Message buffer to use for xfer command
;	CDRP$L_XCT_LEN		-# bytes to xfer
;	CDRP$L_LBUFH_AD		-Addr of local buffer handle
;	CDRP$L_LBOFF		-Local byte offset for segmentation
;	CDRP$L_RBUFH_AD		-Addr of remote buffer handle
;	CDRP$L_RBOFF		-Remote byte offset for segmentation
;
; Outputs:
;
;	R0			-Status:  SS$_NORMAL, SS$_ILLPORTOPR
;	R1, R2			-Destroyed
;	R3			-Preserved
;	R4			-PDT addr
;	R5			-CDRP addr
;
;	RSPID, msg buffer	-Deallocated
;
;	CDRP$L_MSG_BUF(R5)	;Zeroed to show msg buffer gone
;-

	.ENABL	LSB

FPC$REQDATA::

	PUSHL	R3			; Save SYSAP's R3
	MOVL	CDRP$L_RBUFH_AD(R5),R1	; Get addr of remote buffer handle
	MOVZWL	CIBHAN$L_RCONID(R1),R3	; COmpute addr of CDT
	MOVL	G^SCS$GL_CDL,R0		;  specified by local 
	MOVL	(R0)[R3],R3		;  buffer handle
	MOVL	CDRP$L_MSG_BUF(R5),R2	; Get base of buffer
	SUBL	PDT$L_MSGHDRSZ(R4),R2	;  available for command 
	BISL3	#PPD$C_REQDAT@16,-	; Set opcode
		CDT$B_RSTATION(R3),-	;  and dst port
		PPD$B_PORT(R2)		;  in msg header
	MOVL	CIBHAN$L_BNAME(R1),-	; Set send buffer name
		PPD$L_SND_NAME(R2)	;  to remote
	ADDL3	CIBHAN$L_BOFF(R1),-	; Set send byte offset to
		CDRP$L_RBOFF(R5),-	;  xfer offset +
		PPD$L_SND_BOFF(R2)	;  segmentation
	MOVL	CDRP$L_LBUFH_AD(R5),R1	; Get local buffer handle
	MOVL	CIBHAN$L_BNAME(R1),-	; Set receive buffer name
		PPD$L_REC_NAME(R2)	;  to local
	ADDL3	CIBHAN$L_BOFF(R1),-	; Set receive byte offset to
		CDRP$L_LBOFF(R5),-	;  xfer offset
		PPD$L_REC_BOFF(R2)	;  + segmentation
	BRB	COMMON_XFER		; Join common code

FPC$SENDDATA::

	PUSHL	R3			; Save SYSAP register
	MOVL	CDRP$L_RBUFH_AD(R5),R1	; Get addr of remote buffer handle
	MOVZWL	CIBHAN$L_RCONID(R1),R3	; Compute addr
	MOVL	G^SCS$GL_CDL,R0		;  CDT specified by
	MOVL	(R0)[R3],R3		;  local buffer handle
	MOVL	CDRP$L_MSG_BUF(R5),R2	; Get base of buffer
	SUBL	PDT$L_MSGHDRSZ(R4),R2	;  available for SNDDAT command
	BISL3	#PPD$C_SNDDAT@16,-	; Set opcode
		CDT$B_RSTATION(R3),-	;  and dest port #
		PPD$B_PORT(R2)		;  in msg header
	MOVL	CIBHAN$L_BNAME(R1),-	; Set receive buffer name
		PPD$L_REC_NAME(R2)	;  to remote
	ADDL3	CIBHAN$L_BOFF(R1),-	; Set receive byte offset to
		CDRP$L_RBOFF(R5),-	;  xfer offset +
		PPD$L_REC_BOFF(R2)	;  segmentation
	MOVL	CDRP$L_LBUFH_AD(R5),R1	; Get local buffer handle
	MOVL	CIBHAN$L_BNAME(R1),-	; Set send buffer name 
		PPD$L_SND_NAME(R2)	;  to local
	ADDL3	CIBHAN$L_BOFF(R1),-	; Set send byte offset to
		CDRP$L_LBOFF(R5),-	;  xfer offset +
		PPD$L_SND_BOFF(R2)	;  segmentation

COMMON_XFER:

	$CHK_CDTSTATE	-		; Verify connection state is
		OPEN,-			;  open.
		ERROR=STATE_ERR_R3,-	; Else notify caller
		CDT=R3		;
	MOVL	CDT$L_LCONID(R3),-	; Set transaction ID =
		PPD$Q_XCT_ID(R2)	;  local CONID followed
	MOVL	CDRP$L_RSPID(R5),-	;  by RSPID
		PPD$Q_XCT_ID+4(R2)	;
	MOVL	CDRP$L_XCT_LEN(R5),-	; Set transfer size
		PPD$L_XCT_LEN(R2)	;
	CLRL	CDRP$L_MSG_BUF(R5)	; Zero msg buffer addr
	$INS_COMQLOW			; Send off xfer command
	POPL	R3			; Restore SYSAP's R3
	$SUSP_FP			; Suspend caller

	.DSABL	LSB

	.SBTTL	-	UNMAP,		UNMAP A BUFFER

;+
; UNMAP converts the buffer name specified in the local buffer handle
; to a buffer descriptor address.  If the buffer descriptor is not 
; good (sequence number check), then the routine bugchecks.  Otherwise,
; the descriptor valid bit is cleared, the sequence number incremented,
; and the descriptor is linked to the free list.  Any CDRP waiting for 
; a buffer descriptor is resumed.
;
; Inputs:
;
;	R4			-PDT addr
;	R5			-CDRP addr
;
;	CDRP$L_LBUFH_AD		-Addr of local buffer handle
;
; Outputs:
;
;	R0-R2			-Destroyed
;	Other registers		-Preserved
;
;	CIBHAN$L_BNAME		-Zeroed
;-

	.ENABL	LSB

FPC$UNMAP::

	MOVL	CDRP$L_LBUFH_AD(R5),R1	; Get addr of local buff handle
	MOVL	CIBHAN$L_BNAME(R1),R2	; Get buffer name
	BEQL	30$			; Branch if none allocated
	MOVZWL	R2,R2			; Isolate BD index
	MOVL	G^SCS$GL_BDT,R0		; Get addr of BDT
	CMPL	R2,CIBDT$L_MAXIDX(R0)	; Index greater than maximum?
	BGTR	BD_SEQ_ERROR		; Branch if so, same as bad seq number

	ASSUME	CIBD$C_LENGTH EQ 16	
	
	ADDL	R2,R2			; Prepare for net 16 byte index
	MOVAQ	(R0)[R2],R2		; Get addr of BD
	CMPW	CIBD$W_KEY(R2),-	; Sequence # in BD =
		CIBHAN$L_BNAME+2(R1)	;  that in buffer handle?
	BNEQ	BD_SEQ_ERROR		; Branch if not
	INCW	CIBD$W_KEY(R2)		; Step sequence number
	BNEQ	10$			; Branch if nonzero
	INCW	CIBD$W_KEY(R2)		; Else step again

10$:	BBCC	#CIBD$V_V,-		; Clear valid bit
		CIBD$W_FLAGS(R2),20$	;

20$:	MOVL	CIBDT$L_FREEBD(R0),-	; Link this BD to
		CIBD$L_LINK(R2)		;  free list
	MOVL	R2,CIBDT$L_FREEBD(R0)	;
	CLRL	CIBHAN$L_BNAME(R1)	; Zero buffer name to show
					;  none mapped
	$RESUME_FP	-		; Resume waiter, if nay
		@CIBDT$L_WAITFL(R0)	;

30$:	RSB				; Return to caller

BD_SEQ_ERROR:				; SYSAP tried to unmap buffer
					;
	BUGCHECK  CIPORT,NONFATAL	;  without right key -- leave
					;  buffer descriptor permanently
					;  allocated and do nothing to it.

40$:	RSB				;  return to caller

	.DSABL	LSB

	.SBTTL	MAINTENANCE FUNCTION CALLS
	.SBTTL	-	FPC$READCOUNT,	READ AND LOCK
	.SBTTL	-			PORT COUNTERS

;+
; This routine is called by a SYSAP to reset the port counters to begin
; counting ACKS/NAKS/NO_RESPONSES on each path and total datagrams discarded
;f rom a particular port or all ports.  The SYSAP 'owns' the counters until it
; does a RLS_COUNTERS call.  If another SYSAP owns the counters, then
; error status is returned to the SYSAP.
;
; Inputs:
;
;	R0			-Addr of remote station to count for;
;				 0 addr means count for all stations
;	R1			-Addr of local process name
;	R2			-Addr of base of datagram sized buffer
;	R4			-Addr of PDT
;	R5			-Addr of CDRP
;
; Outputs:
;
;	R0			-Status:  SS$_NORMAL, SS$_INTERLOCK,
; 				 SS$_NOSUCHNODE
;	R2			-Addr of datagram buffer, current counters
;				 to all ports since last release
;	R1			-Destroyed
;
;	Other registers		-Preserved
;
;	PDT$B_FLAGS(R4)		-Counters busy flag set
;	PDT$T_CNTOWNER(R4)	-Name of owning SYSAP
;	
;	PPD$L_P0_ACK(R2)	-ACKS on path 0
;	PPD$L_P0_NAK(R2)	-NAKS on path 0
;	PPD$L_P0_NRSP(R2)	-No responses on path 0
;	PPD$L_P1_ACK(R2)	-ACKS on path 1
;	PPD$L_P1_NAK(R2)	-NAKS on path 1
;	PPD$L_P1_NRSP(R2)	-No responses on path 1
;	PPD$L_DG_DISC(R2)	-Datagrams discarded
;-

	.ENABL	LSB

FPC$READCOUNT::

	BBSS	#PDT$V_CNTBSY,-		; Branch if counters busy; else
		PDT$W_FLAGS(R4),BSY_ERR	;  set busy and continue
	MOVQ	(R1)+,PDT$T_CNTOWNER(R4); Save new owner's name
	MOVQ	(R1),PDT$T_CNTOWNER+8(R4)

10$:	BICW	#PDT$M_CNTRLS,-		; Clear release pending
		PDT$W_FLAGS(R4)		;
	MOVZBL	#255,R1			; Assume counting to all ports
	TSTL	R0			; All stations?
	BEQL	ISSUE_RDCNT		; Branch if so
	MOVZBL	(R0),R1			; Else get port caller wants
	CMPB	R1,PDT$B_MAX_PORT(R4)	; Legal?
	BGTRU	PORT_ERR		; Branch if not

ISSUE_RDCNT:
	
	BISL3	#<<PPD$M_RSP@24>!<PPD$C_RDCNT@16>>,-
		R1,PPD$B_PORT(R2)	; Put opcode and port # in 
					;  dg buffer; specify response wanted
	$INS_COMQLOW			; Issue command to port
	MOVL	R5,PDT$L_CNTCDRP(R4)	; Save caller's CDRP addr
	$SUSP_FP			; Save fork process' context
					;  till response arrives

BSY_ERR:
	
	MOVQ	R2,-(SP)		; Save registers for CMPC
	CMPC3	#16,(R1),-		; Is current owner = requestor?
		PDT$T_CNTOWNER(R4)	;
	MOVQ	(SP)+,R2		; Restore registers
	TSTL	R0			; Check compare result
	BEQL	10$			; Branch if requestor is owner

20$:	MOVZWL	#SS$_INTERLOCK,R0	; Else set error status
	RSB				; Return to SYSAP

PORT_ERR:

	MOVZWL	#SS$_NOSUCHNODE,R0	; Set error status
	RSB				; Return to SYSAP

	.DSABL	LSB

	.SBTTL	-	FPC$RLSCOUNT,	READ AND RELEASE
	.SBTTL	-			PORT COUNTERS

;+
; FPC$RLSCOUNT has the same function as FPC$READCOUNT except that the
; caller is asusmed to already own the counters so no check is done, and
; the port is reset to count all ports again.  (Count all is the default
; while the counters are unowned.)
;
; Inputs:
;
;	R2			-Addr of base of dg sized buffer
;	R4			-Addr of PDT
;	R5			-Addr of CDRP
;
; Outputs:
;
;	R0			-Status:  SS$_NORMAL
;	R2			-Addr of datagram buffer filled
;				 as specified in FPC$READCOUNT
;	R1			-Destroyed
;	
;	Other registers 	-Preserved
;-

	.ENABL	LSB

FPC$RLSCOUNT::

	BISW	#PDT$M_CNTRLS,-		; Set count release pending
		PDT$W_FLAGS(R4)		;
	MOVZBL	#255,R1			; Set port to count all ports
	BRW	ISSUE_RDCNT		; Go give read count command

	.DSABL	LSB

	.SBTTL	-	FPC$MRESET,	RESET REMOTE PORT/SYSTEM

;+
; FPC$MRESET allocates a datagram buffer and uses it to send
; a maintenacne reset to the specified remote port.
;
; Inputs:
;
;	R0			-0/1 for dont/do force reset
;	R1			-Addr of remote station to reset
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0			-Status:  SS$_NORMAL, SS$_INSFMEM,
;				 SS$_NOSUCHNODE
;	R1,R2			-Destroyed
;	
;	Other registers		-Preserved
;-

	.ENABL	LSB

FPC$MRESET::

	MOVZBL	(R1),R1			; Get remote port #
	CMPB	R1,PDT$B_MAX_PORT(R4)	; Legal?
	BGTRU	PORT_ERR		; Branch if not
	MOVQ	R0,-(SP)		; Save input arguments
	BSBW	SCS$ALLOC_DG		; Get a dg buffer
	BLBC	R0,MEM_ERR		; Branch if no buffer available
	MOVQ	(SP)+,R0		; Retreive input arguments
	ROTL	#-1,R0,R0		; Reposition force bit in h.o.
					;  bit of flags and 
	BISL	R0,R1			;  OR into port #
	BISL3	#<<PPD$M_RSP@24>!<PPD$C_SNDRST@16>>,-
		R1,PPD$B_PORT(R2)	; OR in opcode, specify response
					;  wanted, and put in dg
	
ISSUE_MRESET:
	
	CLRQ	PPD$Q_XCT_ID(R2)	; Set transaction ID = 0
	$INS_COMQLOW			; Issue reset command
	MOVZWL	#SS$_NORMAL,R0		; Set status to success
	RSB				; Return to SYSAP

MEM_ERR:

	MOVQ	(SP)+,R0		; Clear input arguments
	MOVZWL	#SS$_INSFMEM,R0		; Set error status
	RSB				;  and return to SYSAP

	.DSABL	LSB

	.SBTTL	-	FPC$MSTART,	SEND START TO REMOTE
	.SBTTL	-			SYSTEM

;+
; FPC$MSTART allocates a datagram buffer and sends a start command
; to the specified remote port/system.
;
; Inputs:
;
;	R0			-1/0 for use default start addr/
;				 specified start addr
;	R1			-Addr of remote station addr
;	R2			-Start addr to send if R0 = 0
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0			-Status:  SS$_NORMAL, SS$_INSFMEM,
;				 SS$_NOSUCHNODE
;	R1,R2			-Destroyed
;
;	Other registers		-Preserved
;-

	.ENABL	LSB

FPC$MSTART::

	MOVZBL	(R1),R1			; Get specified remote port
	CMPB	R1,PDT$B_MAX_PORT(R4)	; Legal?
	BGTRU	PORT_ERR		; Branch if not
	PUSHR	#^M<R0,R1,R2>		; Save input arguments
	BSBW	SCS$ALLOC_DG		; Get a dg buffer
	BLBC	R0,MEM_ERR		; Branch if none
	MOVQ	(SP)+,R0		; Retreive two input arguments
	ROTL	#-1,R0,R0		; Position default start addr flag
	BISL	R0,R1			;  and OR into port #
	BISL3	#<<PPD$M_RSP@24>!<PPD$C_SNDSTRT@16>>,-
		R1,PPD$B_PORT(R2)	; OR in opcode, specify response
					;  wanted, and put in dg
	POPL	PPD$L_ST_ADDR(R2)	; Set start addr in case used
	BRB	ISSUE_MRESET		; Join common code.

	.DSABL	LSB

	.SBTTL	SUBROUTINES
	.SBTTL	-	FMT_SCSDGHDR,	FORMAT SCS HEADER
	.SBTTL	-			FOR A DATAGRAM
	.SBTTL	-	FMT_SCSMSGHDR,	FORMAT SCS HEADER
	.SBTTL	-			FOR A MESSAGE

;+
; These routines fill in the SCS header portion of a message or
; datagram, including the length and PPD type fields which are
; shared with the PPD layer of protocol.
;
; Note that the callers of FMT_SCSMSGHDR must fill in the message
; length themselves because it may be either caller-specified or
; defaulted.  FMT_SCSDGHDR on the other hand fills in the length for
; the caller.
;
; Inputs:
;
;	R1			-# bytes of application data
;				 (FMT_SCSDGHDR only)
;	R2			-Msg/dg buffer address
;	R3			-Addr of CDT
;
; Outputs:
;
;	All registers 		-Preserved
;-

	.ENABL	LSB

FMT_SCSDGHDR:

	ADDW3	#<SCS$C_APPL_BASE - PPD$C_LENGTH>,-
		R1,SCS$W_LENGTH(R2)	; Dg length = SCS header size +
					;  application data
	MOVW	#PPD$C_SCS_DG,-		; Set PPD type to application
		PPD$W_MTYPE(R2)		;  datagram
	MOVW	#SCS$C_APPL_DG,-	; Set SCS type to application
		SCS$W_MTYPE(R2)		;  datagram
	MOVL	CDT$L_RCONID(R3),-	; Set destination connection
		SCS$L_DST_CONID(R2)	;  ID in SCS header
	BRB	10$			; Join common code

FMT_SCSMSGHDR:

	MOVW	#PPD$C_SCS_MSG,-	; Set PPD type to application
		PPD$W_MTYPE(R2)		;  message
	MOVW	#SCS$C_APPL_MSG,-	; Set SCS type to application
		SCS$W_MTYPE(R2)		;  message
	MOVW	CDT$W_PENDREC(R3),-	; Extend any pending receive
		SCS$W_CREDIT(R2)	;  credits to the remote
	ADDW	CDT$W_PENDREC(R3),-	; Move pending receives to
		CDT$W_REC(R3)		;  actual receives (real send
					;  credits extended)
	CLRW	CDT$W_PENDREC(R3)	; No more pending credit
	
10$:	MOVL	CDT$L_LCONID(R3),-	; Put local connection ID
		SCS$L_SRC_CONID(R2)	;  into header
	RSB				; Return 

	.DSABL	LSB

	.SBTTL	-	SUSP_CONCALL,	SUSPEND CONNECTION
	.SBTTL	-			MANAGEMENT CALL

;+
; Connection management calls assume that the SYSAP's fork process
; consists of R3 = CDT address, R4 = PDT address, R5, and (SP) =
; return from the connection management call.  R3 is automatically 
; restored by the event (response) triggering call completion;  R4
; is restorable from the CDT.  Therefore, the only context saved is
; R5 and return from call.
;
; Inputs:
;
;	R3			-CDT addr
;	R4			-PDT addr
;	R5			-SYSAP's R5
;	(SP)			-SYSAP PC
;
; Outputs:
;
;	R5, (SP)+		-Saved in CDT
;	Return to caller's caller
;-

	.ENABL	LSB

SUSP_CONCALL:

	MOVL	R5,CDT$L_FR5(R3)	; Save SYSAP R5
	POPL	CDT$L_FPC(R3)		; Save SYSAP PC and remove it from stack
	RSB				; Return to caller's caller

	.DSABL	LSB

	.SBTTL	-	STATE_ERR,	RETURN CDT STATE ERROR
	.SBTTL	-			TO SYSAP

;+
; Set error status code and return to caller.
;-

STATE_ERR_R3:				; Entry if caller's R3 is saved on stack
	
	POPL	R3			; Restore R3 for caller

STATE_ERR:

	MOVZWL	#SS$_ILLCDTST,R0		; Status = illegal CDT state
	RSB				; Return to SYSAP





	.END
