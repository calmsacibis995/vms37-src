	.TITLE	LADRIVER - LPA-11 DRIVER
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	EXECUTIVE, I/O DRIVERS
;
; ABSTRACT:
;	THIS MODULE IS THE DRIVER FOR THE LPA-11 (LABORATORY PERIPHERAL
;	ACCELERATOR).
;
; ENVIRONMENT:	KERNEL MODE, NON-PAGED
;
; AUTHOR:  STEVE BECKHARDT,	CREATION DATE:  7-APR-78
;
; MODIFIED BY:
;
;	V02-012	RLR0001		Robert L. Rappaport	11-Nov-1981
;		Moved logic similar to what previously existed in IOSUBNPAG
;		to manipulate UBA map register bitmap, into new local
;		subroutines added here; ALLOC_LOCALMR and ALT_LOCALBITMAP.
;		These changes (including altering calls to use new local
;		routines) were made at the time that UBA map register
;		allocation structures were implemented.
;
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
	$ACBDEF				; AST CONTROL BLOCK OFFSETS
	$ADPDEF				; ADP OFFSETS
	$CCBDEF				; CCB OFFSETS
	$CRBDEF				; CRB OFFSETS
	$DDBDEF				; DDB OFFSETS
	$DPTDEF				; DRIVER PROLOGUE TABLE DEFINITIONS
	$DYNDEF				; STRUCTURE TYPE CODE DEFINITIONS
	$EMBDEF				; EMB OFFSETS
	$FKBDEF				; FKB OFFSETS
	$IDBDEF				; IDB OFFSETS
	$IPLDEF				; IPL DEFINITIONS
	$IODEF				; I/O FUNCTION CODES
	$IRPDEF				; IRP OFFSETS
	$LADEF				; LPA-11 DEFINITIONS
	$PCBDEF				; PCB OFFSETS
	$PRDEF				; PROCESSOR REGISTER DEFINITIONS
	$PRIDEF				; PRIORITY INCREMENT CLASS DEFINITIONS
	$UCBDEF				; UCB OFFSETS
	$VADEF				; VIRTUAL ADDRESS FIELD DEFINITIONS
	$VECDEF				; INTERRUPT DISPATCH VECTOR OFFSETS

;
; MACROS:
;

;
; EQUATED SYMBOLS:
;

;
; QIO ARGUMENT LIST OFFSETS
;

P1=0
P2=4
P3=8
P4=12

;
; MISC. DEFINITIONS
;

DEVADDR=2				; OFFSET TO DEVICE ADDRESSES IN DMDT
STOP_MODE=3				; MODE FOR STOP RDA
IRP$L_SIP=IRP$L_SEGVBN			; POINTER TO SIP IN IRP
IRP$L_BFR_AST=IRP$B_CARCON		; BUFFER FULL AST ADDRESS IN IRP
IRP$L_OVR_AST=IRP$W_ABCNT		; BUFFER OVERRUN AST ADDRESS IN IRP
IRP$L_RDAMAPREG=IRP$W_ABCNT		; MAP REG. ALLOCATED FOR INTIALIZE

;
; LPA-11 DEVICE REGISTER OFFSETS
;

	$DEFINI	LA

$DEF	LA_CISR		.BLKW	1	; CONTROL IN STATUS REGISTER
	_VIELD	LA_CISR,0,<-
		<G0,,M>,-		; GO BIT
		<,1>,-			; RESERVED BIT
		<MEX,2>,-		; MEMORY EXTENSIOON BITS
		<,2>,-			; RESERVED BITS
		<IE,,M>,-		; READY IN INTERRUPT ENABLE
		<RDY,,M>,-		; READY IN
		<,2>,-			; RESERVED BITS
		<ROMO,,M>,-		; ROM OUTPUT BIT
		<ENA,,M>,-		; ENABLE ARBITRATION 
		<,1>,-			; RESERVED BIT
		<CRAM,,M>,-		; CRAM WRITE
		<RESET,,M>,-		; RESET (MASTER CLEAR)
		<RUN,,M>,-		; RUN
	>

$DEF	LA_COSR		.BLKW	1	; CONTROL OUT STATUS REGISTER
	_VIELD	LA_COSR,0,<-
		<USER,3>,-		; USER INDEX
		<,3>,-			; RESERVED BITS
		<IE,,M>,-		; READY OUT INTERRUPT ENABLE
		<RDY,,M>,-		; READY OUT
		<ERRCD,5>,-		; ERROR CODE
		<ERRTP,2>,-		; ERROR TYPE
		<ERROR,,M>,-		; ERROR BIT
	>

$DEF	LA_RDA		.BLKW	1	; RDA ADDRESS REGISTER

$DEF	LA_MAINT	.BLKW	1	; MAINTENANCE STATUS REGISTER

	$DEFEND	LA


;
; LPA-11 SPECIFIC UCB OFFSETS
;

	$DEFINI	UCB

.=UCB$L_DPC+4

$DEF	UCB$L_RDABA	.BLKL	1	; UNIBUS ADDRESS OF RDA IN UCB
$DEF	UCB$L_RDAMR	.BLKL	1	; RDA IN UCB MAP REGISTER INFO.
$DEF	UCB$L_PREALLOC	.BLKL	1	; PREALLOCATED MAP REGISTER INFO.
$DEF	UCB$L_INQFL	.BLKL	1	; INPUT QUEUE FORWARD LINK
$DEF	UCB$L_INQBL	.BLKL	1	; INPUT QUEUE BACKWARD LINK
$DEF	UCB$L_FORKO	.BLKL	6	; READY OUT INTERRUPTS FORK BLOCK
$DEF	UCB$L_FORKP	.BLKL	6	; POWER RECOVERY FORK BLOCK
$DEF	UCB$L_REGSAVE	.BLKL	4	; REGISTER SAVE AREA
$DEF	UCB$W_RISAVE	.BLKW	4	; REG. SAVE AREA FOR READY-IN INTERRUPTS
$DEF	UCB$W_ROSAVE	.BLKW	4	; REG. SAVE AREA FOR READY-OUT INTS.
$DEF	UCB$L_RQLIST	.BLKL	8	; USER REQUEST LIST
$DEF	UCB$W_MRBITMAP	.BLKW	31	; MAP REGISTER BITMAP
			.BLKW	1	; SPARE WORD
$DEF	UCB$W_RDA	.BLKW	29	; RDA
			.BLKW	1	; SPARE WORD

UCB$K_SIZE=.

	$DEFEND	UCB

;
;	SECONDARY I/O PACKET (SIP) OFFSETS
;
	$DEFINI	SIP

$DEF	SIP$W_MODE	.BLKW	1	; LPA-11 MODE WORD
$DEF	SIP$W_BCNT	.BLKW	1	; SIZE OF EACH BUFFER (IN BYTES)
			.BLKB	3	; SPARE BYTES
$DEF	SIP$B_VBFRMASK	.BLKB	1	; VALID BUFFER MASK
$DEF	SIP$W_SIZE	.BLKW	1	; SIZE OF SIP
$DEF	SIP$B_TYPE	.BLKB	1	; TYPE OF DATA STRUCTURE
			.BLKB	1	; SPARE
$DEF	SIP$L_SLVDATA	.BLKL	4	; SLAVE DATA
$DEF	SIP$L_USW_SVAPT	.BLKL	1	; USW SVAPTE
$DEF	SIP$W_USW_BOFF	.BLKW	1	; USW BYTE OFFSET
$DEF	SIP$W_USW_BCNT	.BLKW	1	; USW BYTE COUNT
$DEF	SIP$W_USW_MAPRE	.BLKW	1	; USW STARTING MAP REGISTER
$DEF	SIP$B_USW_NUMRE	.BLKB	1	; USW NUMBER OF MAP REGISTERS
$DEF	SIP$B_USW_DATAP	.BLKB	1	; USW DATAPATH #
$DEF	SIP$L_BFR_SVAPT	.BLKL	1	; BFR SVAPTE
$DEF	SIP$W_BFR_BOFF	.BLKW	1	; BFR BYTE OFFSET
$DEF	SIP$W_BFR_BCNT	.BLKW	1	; BFR BYTE COUNT
$DEF	SIP$W_BFR_MAPRE	.BLKW	1	; BFR STARTING MAP REGISTER
$DEF	SIP$B_BFR_NUMRE	.BLKB	1	; BFR NUMBER OF MAP REGISTERS
$DEF	SIP$B_BFR_DATAP	.BLKB	1	; BFR DATAPATH #
$DEF	SIP$L_RCL_SVAPT	.BLKL	1	; RCL SVAPTE
$DEF	SIP$W_RCL_BOFF	.BLKW	1	; RCL BYTE OFFSET
$DEF	SIP$W_RCL_BCNT	.BLKW	1	; RCL BYTE COUNT
$DEF	SIP$W_RCL_MAPRE	.BLKW	1	; RCL STARTING MAP REGISTER
$DEF	SIP$B_RCL_NUMRE	.BLKB	1	; RCL NUMBER OF MAP REGISTERS
$DEF	SIP$B_RCL_DATAP	.BLKB	1	; RCL DATAPATH #

	$DEFEND	SIP


;
; OWN STORAGE:
;

;
; DRIVER PROLOGUE TABLE
;
	DPTAB	END=LA_END,-		; END OF DRIVER
		ADAPTER=UBA,-		; ADAPTER TYPE
		FLAGS=DPT$M_NOUNLOAD,-	; DRIVER IS NOT RELOADABLE
		UCBSIZE=UCB$K_SIZE,-	; UCB SIZE
		NAME=LADRIVER		; DRIVER NAME

	DPT_STORE INIT
	DPT_STORE UCB,UCB$B_FIPL,B,8	; FORK IPL
	DPT_STORE UCB,UCB$L_DEVCHAR,L,-	; DEVICE CHARACTERISTICS
		<DEV$M_RTM-		; REAL TIME DEVICE
		!DEV$M_AVL-		; AVAILABLE
		!DEV$M_SHR-		; SHAREABLE
		!DEV$M_ELG-		; ERROR LOGGING ENABLED
		!DEV$M_IDV-		; INPUT DEVICE
		!DEV$M_ODV>		; OUTPUT DEVICE
	DPT_STORE UCB,UCB$B_DEVCLASS,B,DC$_REALTIME	; DEVICE CLASS
	DPT_STORE UCB,UCB$B_DEVTYPE,B,DT$_LPA11		; DEVICE TYPE
	DPT_STORE UCB,UCB$B_DIPL,B,22			; DEVICE IPL
	DPT_STORE UCB,UCB$L_FORKO+8,L,-			; READY OUT FORK BLOCK
		<<8@24>+<DYN$C_FRK@16>+FKB$K_LENGTH>	; SIZE, TYPE, AND IPL
	DPT_STORE UCB,UCB$L_FORKP+8,L,-			; POWER REC. FORK BLOCK
		<<8@24>+<DYN$C_FRK@16>+FKB$K_LENGTH>	; SIZE, TYPE, AND IPL

	DPT_STORE REINIT
	DPT_STORE DDB,DDB$L_DDT,D,LA$DDT		; DDT ADDRESS
	DPT_STORE CRB,CRB$L_INTD+4,D,LA$RDYOUTINTSV	; READY OUT INT. SERVICE
	DPT_STORE CRB,CRB$L_INTD2+4,D,LA$RDYININTSV	; READY IN INT. SERVICE
	DPT_STORE CRB,CRB$L_INTD+VEC$L_UNITINIT,D,UNIT_INIT ; UNIT INIT
	DPT_STORE END

;
;	DRIVER DISPATCH TABLE
;
	DDTAB	LA,-			; DEVICE NAME
		STARTIO,-		; START I/O ENTRY POINT
		0,-			; UNSOLICITED INTERRUPT
		FUNCTABLE,-		; FUNCTION DECISION TABLE
		CANCEL_IO,-		; CANCEL I/O
		LA_REGDUMP,-		; REGISTER DUMP ROUTINE
		<36+24>,-		; SIZE OF DIAGNOSTIC BUFFER
		<EMB$L_DV_REGSAV+4+24>	; SIZE OF ERROR LOGGING BUFFER


;
;	FUNCTION DECISION TABLE
;
FUNCTABLE:
	FUNCTAB	,<LOADMCODE,STARTMPROC,-	; LEGAL FUNCTIONS
		INITIALIZE,SETCLOCK,SETCLOCKP,-
		STARTDATA,STARTDATAP,-
		QSTOP>
	FUNCTAB					; NO BUFFERED I/O FUNCTIONS
	FUNCTAB	LOAD_MICROCODE,<LOADMCODE>	; LOAD MICROCODE
	FUNCTAB	STARTMP_FDT,<STARTMPROC>	; START MICROPROCESSOR
	FUNCTAB	INIT_FDT,<INITIALIZE>		; INITIALIZE
	FUNCTAB	SETCLOCK_FDT,<SETCLOCK,-	; SET CLOCK
				SETCLOCKP>	; SET CLOCK (PHYSICAL)
	FUNCTAB	STARTDATA_FDT,<STARTDATA,-	; START DATA
				STARTDATAP>	; START DATA (PHYSICAL)
	FUNCTAB	QSTOP_FDT,<QSTOP>		; QUEUE STOP


;
; THE FOLLOWING TABLE IS USED FOR DISPATCHING IN STARTIO.
; THE ORDER OF THE ENTRIES MUST NOT BE CHANGED!
;
IOFCTBL:  ; I/O FUNCTION CODE TABLE - USED FOR DISPATCHING IN STARTIO
	.BYTE	IO$_STARTMPROC
	.BYTE	IO$_INITIALIZE
	.BYTE	IO$_SETCLOCK
	.BYTE	IO$_SETCLOCKP
	.BYTE	IO$_STARTDATA
	.BYTE	IO$_STARTDATAP
	.BYTE	IO$_STOP
IOFCTBLN=.-IOFCTBL

	.SBTTL	LOAD_MICROCODE - FDT ROUTINE TO LOAD MICROCODE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS AN FDT ROUTINE WHICH PERFORMS THE LOAD MICROCODE
;	QIO.  IT LOCKS THE MICROCODE IMAGE IN MEMORY, CHECKS FOR NO ONGOING
;	DATA TRANSFERS, MASTER CLEAR'S THE LPA-11, CLEARS THE MICROCODE VALID
; 	BIT, AND LOADS AND VERIFIES THE MICROCODE.  AFTER A SUCCESSFUL LOAD,
;	THE SHAREABLE BIT IS SET IF MULTIREQUEST MODE MICROCODE WAS LOADED
;	AND CLEARED OTHERWISE.  ALSO, THE MICROCODE TYPE IS SAVED AND THE
;	MICROCODE VALID BIT IS SET.
;
; CALLING SEQUENCE:
;
;	CALLED FROM THE FDT ROUTINE DISPATCHER IN THE QIO SYSTEM SERVICE.
;	ON COMPLETION JUMPS TO EXE$FINISHIOC.
;
; INPUT PARAMETERS:
;
;	R3	ADDRESS OF I/O PACKET
;	R4	CURRENT PROCESS PCB ADDRESS
;	R5	ADDRESS OF UCB
;	R6	ADDRESS OF CCB
;	AP	ADDRESS OF FIRST FUNCTION DEPENDENT PARAMETER
;
; OUTPUT PARAMETERS:
;
;	R0	THE LOW ORDER WORD CONTAINS A COMPLETION CODE;
;		THE HIGH ORDER WORD CONTAINS THE NUMBER OF BYTES OF 
;		MICROCODE LOADED.
;
; COMPLETION CODES:
;
;	THESE ARE IN ADDITION TO THE ONES EXE$WRITELOCK CAN RETURN:
;
;	SS$_NORMAL	NORMAL
;	SS$_DATACHECK	MICROCODE LOAD ERROR
;	SS$_DEVACTIVE	DEVICE ACTIVE
;
; SIDE EFFECTS:
;
;	R1,R2,R4,R9,R10 ARE NOT SAVED
;
;--

LOAD_MICROCODE:
	MOVL	P1(AP),R0		; ADDRESS OF MICROCODE IMAGE
	MOVZWL	P2(AP),R1		; LENGTH OF IMAGE
	MOVQ	R0,R9			; PUT ADDRESS, SIZE INTO R9, R10
	JSB	G^EXE$WRITELOCK		; LOCK IT DOWN
	BICW	#UCB$M_POWER,UCB$W_STS(R5)  ; CLEAR POWERFAIL BIT

5$:	; COME HERE TO TRY AGAIN AFTER A POWERFAIL
	MOVQ	R9,R0			; RESTORE R0, R1

	; RESET MICROPROCESSOR
	DSBINT	UCB$B_FIPL(R5)		; RAISE IPL TO FORK LEVEL
	BSBW	RESET
	BICL	#LA$M_MCVALID,-		; CLEAR MICROCODE VALID BIT
		UCB$L_DEVDEPEND(R5)
	ENBINT				; LOWER IPL
	MOVZWL	P3(AP),R2		; GET MICRO PC TO START LOADING AT
	PUSHL	#0			; COUNTER OF WORDS LOADED
	ASHL	#-1,R1,R1		; CONVERT BYTE TO WORD COUNT
	BEQL	15$			; WORD COUNT = 0

10$:	; LOAD NEXT MICROCODE WORD
	CLRW	LA_CISR(R4)		; CLEAR CONTROL IN STATUS REGISTER
	MOVW	R2,LA_RDA(R4)		; ADDRESS TO LOAD
	MOVW	(R0),LA_MAINT(R4)	; MICROCODE WORD BEING LOADED
	MOVW	#LA_CISR_M_ROMO,LA_CISR(R4)  ; SELECT ADDRESS
	BISW	#LA_CISR_M_CRAM,LA_CISR(R4)  ; SET CRAM WRITE
	CLRW	LA_CISR(R4)		; RESET

	; NOW VERIFY WORD WAS LOADED CORRECTLY
	MOVW	R2,LA_RDA(R4)		; MICRO ADDRESS
	MOVW	#LA_CISR_M_ROMO,LA_CISR(R4)  ; SELECT CRAM AT ADDRESS
	CMPW	(R0)+,LA_MAINT(R4)	; COMPARE CONTENTS WITH ORIGINAL WORD
	BNEQ	20$			; ERROR - NOT EQUAL
	INCW	R2			; ADD 1 TO MICRO PC
	AOBLSS	R1,(SP),10$		; GO BACK AND LOAD NEXT WORD

	; SUCCESSFUL LOAD
	INSV	-2(R0),#LA$V_MCTYPE,#LA$S_MCTYPE,-  ; STORE MICROCODE TYPE
		UCB$L_DEVDEPEND(R5)	; IN DEVICE DEPENDENT CHARACTERISTICS
15$:	MOVZWL	S^#SS$_NORMAL,R0
	BRB	30$

20$:	; ERROR DURING LOAD
	MOVZWL	#SS$_DATACHECK,R0

30$:	; CONVERT # OF WORDS LOADED TO BYTES AND STORE IN HIGH WORD OF R0
	INSV	(SP)+,#17,#15,R0
	; IF POWERFAIL OCCURRED THEN RETRY
	DSBINT	#31
	BBCC	#UCB$V_POWER,UCB$W_STS(R5),40$	;  BRANCH IF POWER DIDN'T FAIL
	ENBINT				; POWERFAIL OCCURRED, RETRY
	BRW	5$

40$:	; NO POWERFAIL - IF SUCCESSFUL LOAD, THEN SET MICROCODE VALID
	CMPW	S^#SS$_NORMAL,R0	; SUCCESSFUL?
	BNEQ	50$			; NO
	BISB	#LA$M_MCVALID,-		; YES, SET MICROCODE VALID BIT
		UCB$L_DEVDEPEND(R5)
50$:	ENBINT
	JMP	G^EXE$FINISHIOC		; RETURN TO USER

	.SBTTL	RESET - RESET MICROPROCESSOR

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE VERIFIES THAT THERE ARE NO ONGOING DATA TRANSFERS,
;	AND THAT THE UCB IS NOT BUSY. IF THESE CONDITIONS ARE MET, THEN
;	A MASTER CLEAR IS ISSUED TO THE LPA-11.  OTHERWISE, THE I/O
;	IS FINISHED WITH AN ERROR STATUS.  THIS ROUTINE MUST BE CALLED
;	AT FORK IPL TO AVOID RACE CONDITIONS.
;
; CALLING SEQUENCE:
;
;	BSBW	RESET
;
; INPUT PARAMETERS:
;
;	R5	ADDRESS OF UCB
;
; IMPLICIT INPUTS:
;
;	IPL IS AT FORK LEVEL ON ENTRY
;
; OUTPUT PARAMETERS:
;
;	R4	UNIBUS ADDRESS OF FIRST LPA-11 REGISTER
;
; COMPLETION CODES:
;
;	SS$_DEVACTIVE	DEVICE ACTIVE (NOT RETURNED TO CALLER - GOES
;			DIRECTLY TO EXE$FINISHIOC)
;
; SIDE EFFECTS:
;
;	R2 IS NOT PRESERVED
;--

RESET:
	BBS	#UCB$V_BSY,UCB$W_STS(R5),20$	; MAKE SURE UCB IS NOT BUSY

	; MAKE SURE THERE ARE NO ONGOING DATA TRANSFERS
	CLRL	R2
10$:	TSTL	UCB$L_RQLIST(R5)[R2]	; A REQUEST HERE?
	BNEQ	20$			; YES, ERROR!
	AOBLSS	#8,R2,10$		; TRY NEXT SLOT

	; GET POINTER TO DEVICE REGISTERS
	MOVL	UCB$L_CRB(R5),R4	; GET POINTER TO CRB
	ASSUME	IDB$L_CSR EQ 0
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R4  ; GET PTR TO 1ST DEVICE REGISTER

	; RAISE IPL TO HARDWARE DEVICE LEVEL AND DO A MASTER CLEAR
	DSBINT	UCB$B_DIPL(R5)
	MOVW	#LA_CISR_M_RESET,LA_CISR(R4)  ; DO MASTER CLEAR
	ENBINT
	RSB

20$:	; ERROR - LPA-11 IS BUSY
	MOVZWL	#SS$_DEVACTIVE,R0	; STATUS
	JMP	G^EXE$FINISHIOC		; FINISH I/O

	.SBTTL	STARTMP_FDT	START MICROPROCESSOR FDT ROUTINE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS THE FDT ROUTINE FOR THE START MICROPROCESSOR
;	QIO.  IT CHECKS FOR NO ACTIVE USERS, MASTER CLEARS THE LPA-11,
;	AND THEN QUEUES THE PACKET ONTO THE UCB'S INPUT QUEUE.
;
; CALLING SEQUENCE:
;
;	CALLED BY THE FDT ROUTINE DISPATCHER IN THE QIO SYSTEM SERVICE.
;	ON COMPLETION BRANCHES TO QUE_PKT
;
; INPUT PARAMETERS:
;
;	R3	ADDRESS OF I/O PACKET
;	R5	ADDRESS OF UCB
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_DEVACTIVE	DEVICE ACTIVE (GETS RETURNED DIRECTLY TO EXE$FINISHIOC)
;
; SIDE EFFECTS:
;
;	R2,R4 ARE NOT PRESERVED
;--

STARTMP_FDT:
	SETIPL	UCB$B_FIPL(R5)		; RAISE IPL TO FORK LEVEL
	BSBB	RESET			; RESET MICROPROCESSOR
	BRW	QUE_PKT			; INITIATE FUNCTION


	.SBTTL	INIT_FDT - INITIALIZE FDT ROUTINE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS THE FDT ROUTINE FOR THE INITIALIZE QIO.
;	IT CHECKS FOR SEVERAL ERRORS, LOCKS THE INITIALIZE TABLE INTO
;	MEMORY, AND FORMATS THE CONFIGURATION BITS WHICH GET STORED
;	IN THE DEVICE CHARACTERISTICS IF THE INITIALIZE IS SUCCESSFUL.
;
; CALLING SEQUENCE:
;
;	CALLED FROM THE FDT ROUTINE DISPATCHER IN THE QIO SYSTEM SERVICE.
;
; INPUT PARAMETERS:
;
;	R3	ADDRESS OF I/O PACKET
;	R4	CURRENT PROCESS PCB ADDRESS
;	R5	ADDRESS OF UCB
;	R6	ADDRESS OF CCB
;	AP	ADDRESS OF FIRST FUNCTION DEPENDENT PARAMETER
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_IVMODE	INVALID MODE
;	SS$_IVBUFLEN	INVALID BUFFER LENGTH
;	SS$_BUFNOTALIGN	BUFFER NOT ALIGNED CORRECTLY
;	(THESE ERRORS GET RETURNED DIRECTLY TO EXE$FINISHIOC)
;--


INIT_FDT:
	MOVZWL	#SS$_BUFNOTALIGN,R2	; ASSUME ALIGNMENT ERROR
	MOVL	P1(AP),R0		; GET ADDRESS OF INITIALIZE TABLE
	BLBS	R0,10$			; VERIFY IT'S WORD ALIGNED
	MOVL	R0,R9			; SAVE FOR LATER USE
	MOVZWL	#SS$_IVBUFLEN,R2	; ASSUME INVALID LENGTH ERROR
	MOVZWL	P2(AP),R1		; GET LENGTH
	CMPL	R1,#278			; IS IT THE RIGHT LENGTH?
	BNEQ	10$			; NO - ERROR
	JSB	G^EXE$WRITELOCK		; YES, LOCK IT DOWN
	MOVZWL	#SS$_IVMODE,R2		; ASSUME INVALID MODE ERROR
	BITB	#7,(R9)			; MAKE SURE MODE = INITIALIZE
	BNEQ	10$			; IT DOESN'T - ERROR

	; BUILD CONFIGURATION BITS FOR DEVICE CHARACTERISTICS
	CLRL	R1			; LOOP COUNTER AND BIT POSITION
5$:	MOVW	DEVADDR(R9)[R1],R2	; GET DEVICE ADDRESS OF NEXT DEVICE
	INSV	R2,R1,#1,R0		; STORE LOW BIT OF ADDRESS IN R0
	AOBLSS	#10,R1,5$		; DO NEXT DEVICE
	MCOML	R0,IRP$L_MEDIA(R3)	; COMPLEMENT BITS AND SAVE
	BRW	QUE_PKT			; QUEUE PACKET TO DRIVER

10$:	; ERROR - EITHER INCORRECT LENGTH, MODE NOT EQUAL TO INIT,
	; OR NOT WORD ALIGNED.
	MOVL	R2,R0			; COMPLETION CODE
	JMP	G^EXE$FINISHIOC

	.SBTTL	SETCLOCK_FDT - SET CLOCK FDT ROUTINE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS THE FDT ROUTINE FOR THE SET CLOCK QIO.
;	IT COPIES THE FUNCTION DEPENDENT PARAMETERS INTO THE I/O
;	PACKET AND THEN STORES THE CLOCK A RATE AND PRESET IN THE
;	SPARE CHARACTERISTICS.  THIS WILL GET STORED IN THE DEVICE
;	CHARACTERISTICS IF THE QIO IS SUCCESSFUL.
;
; CALLING SEQUENCE:
;
;	CALLED BY THE FDT ROUTINE DISPATCHER IN THE QIO SYSTEM SERVICE.
;
; INPUT PARAMETERS:
;
;	R3	ADDRESS OF I/O PACKET
;	R5	UCB ADDRESS
;	AP	ADDRESS OF FIRST FUNCTION DEPENDENT PARAMETER
;
; OUTPUT PARAMETERS:
;
;	NONE
;--

SETCLOCK_FDT:
	; COPY P2 - P4 INTO I/O PACKET
	MOVW	P2(AP),IRP$L_MEDIA(R3)	; MODE WORD
	MOVW	P3(AP),IRP$L_MEDIA+2(R3) ; CLOCK STATUS
	MOVW	P4(AP),IRP$L_MEDIA+4(R3) ; CLOCK PRESET
	INSV	#1,#0,#3,IRP$L_MEDIA(R3) ; SET MODE TO START CLOCK

	BRW	QUE_PKT			; QUEUE PACKET TO DRIVER

	.SBTTL	STARTDATA_FDT - START DATA FDT ROUTINE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS THE FDT ROUTINE FOR THE START DATA QIO.  IT
;	ALLOCATES A SECONDARY I/O PACKET (SIP), LOCKS THE USW, BUFFERS,
;	AND RCL INTO MEMORY AND LINKS THE SIP TO THE IRP.
;
; CALLING SEQUENCE:
;
;	CALLED FROM THE FDT ROUTINE DISPATCHER IN THE QIO SYSTEM SERVICE
;
; INPUT PARAMETERS:
;
;	R3	ADDRESS OF I/O PACKET
;	R4	CURRENT PROCESS PCB ADDRESS
;	R5	ADDRESS OF UCB
;	R6	ADDRESS OF CCB
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_INSFMEM	INSUFFICIENT MEMEORY
;	SS$_BUFNOTALIGN	ALIGNMENT ERROR
;	SS$_IVBUFLEN	INVALID BUFFER LENGTH
;	(THESE ERRORS GET RETURNED DIRECTLY TO EXE$FINISHIOC)
;
; SIDE EFFECTS:
;
;	R1,R2,R7,R8 ARE NOT PRESERVED
;--

	.ENABL	LSB
STARTDATA_FDT:
	; FIRST CHECK THAT ARGUMENT BLOCK POINTED TO BY P1 IS THE CORRECT
	; LENGTH AND ACCESSIBLE
	CLRL	R10			; MEANS NO SIP IN CASE OF ERROR
	MOVZWL	P2(AP),R1		; GET LENGTH
	CMPL	R1,#40			; IS IT CORRECT LENGTH?
	BEQL	5$			; YES
	BRW	LENGTHERR		; NO - ERROR
5$:	MOVL	P1(AP),R0		; YES, GET POINTER
	JSB	G^EXE$WRITECHK		; CHECK FOR READ ACCESS
	MOVL	R0,R9			; R9 WILL STEP THRU ARGUMENT BLOCK

	; NOW ALLOCATE SECONDARY I/O PACKET (SIP)
	MOVZWL	#IRP$C_LENGTH,R1	; LENGTH
	PUSHL	R3			; SAVE R3
	JSB	G^EXE$ALONONPAGED	; ALLOCATE IT
	MOVL	(SP)+,R3		; RESTORE R3
	BLBS	R0,10$			; SUCCESSFUL
	MOVZWL	#SS$_INSFMEM,R0		; ERROR
	BRW	ABORT

10$:	; CLEAR PACKET AND PUT IN SIZE
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>
	MOVC5	#0,(R2),#0,R1,(R2)	; CLEAR PACKET
	POPR	#^M<R0,R1,R2,R3,R4,R5>
	MOVW	#IRP$C_LENGTH,IRP$W_SIZE(R2)
	MOVL	R2,R10			; R10 WILL POINT TO SIP

	; START BUILDING SIP FROM ARGUMENT BLOCK
	MOVW	(R9)+,SIP$W_MODE(R10)	; COPY MODE WORD
	INSV	#2,#0,#3,SIP$W_MODE(R10); MAKE SURE FUNCTION = START DATA
	MOVZWL	(R9)+,R11		; GET VALID BUFFER MASK
	MOVB	R11,SIP$B_VBFRMASK(R10)	; STORE IN SIP
	BICW	#^XFFF8,R11		; MASK EVERYTHING BUT # OF BUFFERS
	INCL	R11			; ADD 1 TO GET TRUE # OF BUFFERS

20$:	; CHECK AND LOCK USW
	MOVL	(R9)+,R0		; POINTER TO USW
	BLBS	R0,45$			; BRANCH IF NOT WORD ALIGNED (ERROR)
	MOVL	#2,R1			; LENGTH OF USW
	BSBW	READLOCK		; CHECK AND LOCK FOR WRITE ACCESS
	MOVQ	IRP$L_SVAPTE(R3),SIP$L_USW_SVAPT(R10) ; SAVE SVAPTE, BOFF, BCNT

	; CHECK DATA BUFFER AREA FOR PROPER ALIGNMENT AND SIZE RESTRICTIONS
	MOVZWL	(R9),R1			; LENGTH OF BUFFER AREA
	ADDL	#4,R9
	MOVL	(R9)+,R0		; POINTER TO BUFFER AREA
	BITL	#3,R0			; MAKE SURE ITS LONGWORD ALIGNED
	BNEQ	ALIGNERR		; IT'S NOT - ERROR!
	CLRL	R2
	EDIV	R11,R1,R2,R8		; GET SIZE OF EACH DATA BUFFER
	BEQL	LENGTHERR		; BUFFER LENGTH CAN'T BE ZERO!
	TSTL	R8			; MAKE SURE REMAINDER IS ZERO
	BNEQ	LENGTHERR		; IT'S NOT - ERROR!
	BLBS	R2,LENGTHERR		; BUFFER SIZE MUST BE A MULTIPLE
					; OF 2 IN MULTIREQUEST MODE.
	BBS	#3,SIP$W_MODE(R10),27$	; BR. IF THIS IS A M.R. MODE REQUEST
	BITL	#3,R2			; BUFFER SIZE MUST BE A MULTIPLE
					; OF 4 IN DEDICATED MODE.
	BNEQ	LENGTHERR		; IT'S NOT - ERROR!
27$:	MOVW	R2,SIP$W_BCNT(R10)	; STORE BUFFER SIZE IN SIP

	; NOW CHECK AND LOCK BUFFERS FOR READ OR WRITE ACCESS DEPENDING
	; ON TRANSFER DIRECTION
	TSTB	SIP$W_MODE(R10)		; TEST FOR TRANSFER DIRECTION
	BLSS	30$
	BSBB	READLOCK		; FROM LPA TO MEMORY
	BRB	40$
30$:	BSBB	WRITELOCK		; FROM MEMORY TO LPA
40$:	MOVQ	IRP$L_SVAPTE(R3),SIP$L_BFR_SVAPT(R10) ; SAVE SVAPTE, BOFF, BCNT

	; REPEAT FOR RCL
	MOVZWL	(R9),R1			; LENGTH OF RCL
	ADDL	#4,R9
	MOVL	(R9)+,R0		; ADDRESS OF RCL
	BITW	#^X300,SIP$W_MODE(R10)	; IS RCL SPECIFIED?
	BNEQ	50$			; NO
	TSTW	R1			; YES, MAKE SURE LENGTH IS NOT ZERO
	BEQL	LENGTHERR		; IT IS ZERO - ERROR
45$:	BLBS	R0,ALIGNERR		; RCL MUST BE WORD ALIGNED
	BLBS	R1,LENGTHERR		; AND A MULTIPLE OF 2 IN LENGTH
	MOVQ	R0,R7			; SAVE R0,R1 IN R7,R8
	BSBB	WRITELOCK		; CHECK ACCESS AND LOCK DOWN
	MOVQ	IRP$L_SVAPTE(R3),SIP$L_RCL_SVAPT(R10) ; SAVE SVAPTE, BCNT, BOFF
	BBC	#7,-1(R7)[R8],LENGTHERR	; MAKE SURE END OF RCL HAS HIGH BIT SET

50$:	MOVQ	(R9)+,SIP$L_SLVDATA(R10)  ; COPY SLAVE DATA
	MOVQ	(R9)+,SIP$L_SLVDATA+8(R10)
	ASSUME	IRP$L_OVR_AST EQ IRP$L_BFR_AST+4
	MOVQ	P3(AP),IRP$L_BFR_AST(R3)  ; COPY AST ADDRESSES
	CLRQ	IRP$L_SVAPTE(R3)	; CLEAR SVAPTE, BCNT, AND BOFF IN IRP
	MOVL	R10,IRP$L_SIP(R3)	; LINK SIP TO IRP
	BRW	QUE_PKT			; QUEUE PACKET TO DRIVER


	; ERRORS COME HERE

ALIGNERR:  ; ALIGNMENT ERROR
	MOVZWL	#SS$_BUFNOTALIGN,R0
	BRB	60$

LENGTHERR:  ; INVALID LENGTH ERROR
	MOVZWL	#SS$_IVBUFLEN,R0
60$:	BSBB	CLEANUP			; UNLOCK PAGES, DEALLOCATE SIP

ABORT:	JMP	G^EXE$FINISHIOC


	; LOCAL SUBROUTINES

READLOCK:
	JSB	G^EXE$READLOCKR		; LOCK PAGES FOR WRITE ACCESS
	BRB	70$

WRITELOCK:
	JSB	G^EXE$WRITELOCKR	; LOCK PAGES FOR READ ACCESS
70$:	BLBS	R0,90$			; BRANCH IF EVERYTHING IS OK

	; ERROR OR HAVE TO FAULT PAGES IN.  FALL THROUGH TO ...


CLEANUP:  ; UNLOCK PAGES AND DEALLOCATE SIP
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>
	CLRQ	IRP$L_SVAPTE(R3)	; CLEAR SVAPTE, BCNT, AND BOFF IN IRP
	MOVL	R10,R5			; ADDRESS OF SIP
	BEQL	80$			; NO SIP - NOTHING TO UNLOCK
	BSBW	UNLOCK			; UNLOCK PAGES, DEALLOCATE SIP
80$:	POPR	#^M<R0,R1,R2,R3,R4,R5>
90$:	RSB				; RETURN TO CALLER OR COROUTINE
	.DSABL	LSB

	.SBTTL	QSTOP_FDT - QUEUE STOP FDT ROUTINE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS AN FDT ROUTINE WHICH PERFORMS THE QUEUE STOP
;	QIO.  NOTE THAT THIS QIO DOES NOT ITSELF STOP A DATA TRANSFER;
;	RATHER IT QUEUES THE ORIGINAL START DATA I/O PACKET BACK TO THE
;	DRIVER AS A STOP.  THEREFORE, THIS QIO COMPLETES AS SOON AS
;	THE STOP IS QUEUED.  THE ORIGINAL START DATA COMPLETES AFTER THE
;	DATA TRANSFER HAS ACTUALLY STOPPED.
;
; CALLING SEQUENCE:
;
;	CALLED FROM THE FDT ROUTINE DISPATCHER IN THE QIO SYSTEM SERVICE.
;	ON COMPLETION JUMPS TO EXE$FINISHIOC.
;
; INPUT PARAMETERS:
;
;	R3	ADDRESS OF I/O PACKET
;	R4	CURRENT PROCESS PCB ADDRESS
;	R5	ADDRESS OF UCB
;	AP	ADDRESS OF FIRST FUNCTION DEPENDENT PARAMETER
;
; OUTPUT PARAMETERS:
;
;	R0	COMPLETION CODE
;
; COMPLETION CODES:
;
;	SS$_NORMAL	NORMAL
;	SS$_BADPARAM	NO SUCH REQUEST
;
; SIDE EFFECTS:
;
;	R2 IS NOT PRESERVED
;--

QSTOP_FDT:
	MOVZBL	P2(AP),R2		; GET REQUEST NUMBER
	BICB	#^XF8,R2		; CLEAR ALL BUT LOW THREE BITS
	MOVZWL	#SS$_BADPARAM,R0	; ASSUME ERROR
	SETIPL	UCB$B_FIPL(R5)		; RAISE TO FORK IPL
	TSTL	UCB$L_RQLIST(R5)[R2]	; IS THERE A REQUEST IN THIS SLOT?
	BEQL	10$			; NO - ERROR
	MOVZWL	#SS$_ABORT,R0		; YES - QUEUE A STOP WITH ABORT STATUS
	BSBW	QUEUE_STOP_REQ
	MOVZWL	S^#SS$_NORMAL,R0	; RETURN NORMAL STATUS
10$:	JMP	G^EXE$FINISHIOC		; FINISH I/O

	.SBTTL	QUE_PKT - QUEUE I/O PACKET TO DRIVER

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS JUMPED TO FROM AN FDT ROUTINE TO QUEUE AN
;	I/O PACKET TO THE DRIVER.  IF THE DRIVER IS NOT BUSY, THEN
;	THE DRIVER IS CALLED IMMEDIATELY.  THIS ROUTINE IS SIMILAR TO
;	THE EXEC'S, EXCEPT IT USES A DIFFERENT QUEUE.
;
; CALLING SEQUENCE:
;
;	JUMPED TO FROM AN FDT ROUTINE
;
; INPUT PARAMETERS:
;
;	R3	ADDRESS OF I/O PACKET
;	R5	ADDRESS OF UCB
;
; OUTPUT PARAMETERS:
;
;	NONE
;--

QUE_PKT:
	DSBINT	UCB$B_FIPL(R5)		; RAISE IPL TO FORK LEVEL
	BBSS	#UCB$V_BSY,UCB$W_STS(R5),10$  ; SET BUSY AND SEE IF IT WAS SET
	JSB	G^IOC$INITIATE		; NOT BUSY, INITIATE FUNCTION
	BRB	20$

10$:	MOVAL	UCB$L_INQFL(R5),R2	; GET ADDRESS OF I/O QUEUE LISTHEAD
	JSB	G^EXE$INSERTIRP		; INSERT IN QUEUE BY PRIORITY

20$:	ENBINT				; LOWER IPL
	JMP	G^EXE$QIORETURN		; RETURN FROM QIO

	.SBTTL	STARTIO - MAIN DRIVER ENTRY POINT

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS THE MAIN DRIVER ENTRY POINT.  IT STARTS THE I/O,
;	WAITS FOR AN INTERRUPT, COMPLETES THE I/O, AND STARTS THE NEXT ONE.
;
; CALLING SEQUENCE:
;
;	CALLED THROUGH THE DRIVER DISPATCH TABLE
;
; INPUT PARAMETERS:
;
;	R3	ADDRESS OF I/O PACKET
;	R5	ADDRESS OF UCB
;
; OUTPUT PARAMETERS:
;
;	NONE
;--

	.ENABL	LSB
STARTIO:

	ASSUME	IRP$S_FCODE EQ 6
	BICB3	#^XC0,IRP$W_FUNC(R3),R2	; GET FUNCTION CODE

	; DISPATCH TO APPROPRIATE ROUTINE
	LOCC	R2,#IOFCTBLN,IOFCTBL	; LOCATE FUNCTION CODE IN TABLE
	MOVL	UCB$L_CRB(R5),R1	; GET POINTER TO CRB IN R1
	CASE	TYPE=B,SRC=R0,DISPLIST=<-
		STRT_NXT_REQ,-		; INVALID FUNCTION
		STOP,-			; STOP
		START_DATA,-		; START DATA (PHYSICAL)
		START_DATA,-		; START DATA
		SET_CLOCK,-		; SET CLOCK (PHYSICAL)
		SET_CLOCK,-		; SET CLOCK
		INITIALIZE,-		; INITIALIZE
		>

	; FALL THROUGH TO ...

;
;	S T A R T   M I C R O P R O C E S S O R
;
	; NOTE:  THIS QIO COMES HERE DIRECTLY FROM THE FDT ROUTINE.
	; THEREFORE R4 POINTS TO LPA-11 CSR.
	; CHECK FOR VALID MICROCODE BEFORE STARTING MICROPROCESSOR
	ASSUME	LA$M_MCVALID EQ 1
	DSBINT	#31			; DON'T ALLOW INTERRUPTS (LIKE PWRFAIL)
	BLBC	UCB$L_DEVDEPEND(R5),MCNVALID  ; BRANCH IF MICROCODE NOT VALID

	; ACTUALLY START MICROPROCESSOR
	MOVW	#LA_CISR_M_RUN!LA_CISR_M_ENA,-  ; SET RUN AND ENABLE
		LA_CISR(R4)		; ARBITRATION BITS
	ENBINT				; ALLOW INTERRUPTS

	; WAIT FOR AT LEAST 1 MICROSECOND BEFORE ENABLING INTERRUPTS
	CLRL	R0
7$:	MFPR	#PR$_ICR,R1		; GET INTERVAL CLOCK CONTENTS
8$:	MFPR	#PR$_ICR,R2		; GET CLOCK CONTENTS AGAIN
	CMPL	R1,R2			; COMPARE BOTH CLOCK READINGS
	BEQL	8$			; REPEAT TILL THEY DIFFER
	AOBLSS	#2,R0,7$		; DO THIS TWICE

	DSBINT	#31			; CHECK FOR VALID MICROCODE AGAIN
	BLBC	UCB$L_DEVDEPEND(R5),MCNVALID  ; BRANCH IF MICROCODE NOT VALID
	BISW	#LA_CISR_M_IE,LA_CISR(R4)  ; ENABLE READY IN INTERRUPTS
	BISW	#LA_COSR_M_IE,LA_COSR(R4)  ; ENABLE READY OUT INTERRUPTS
	BRB	WAIT			; WAIT FOR INTERRUPT

;
;	S E T   C L O C K
;
SET_CLOCK:
	MOVQ	IRP$L_MEDIA(R3),UCB$W_RDA(R5)	; BUILD RDA IN UCB
	BRB	RDA_IN_UCB

;
;	S T A R T   D A T A
;
START_DATA:
	BSBW	SDATA			; PREPARE FOR START DATA
	BLBC	R0,DONE			; ERROR
	BRB	RDA_IN_UCB

;
;	S T O P
;
STOP:
	; RDA IS IN SIP (FROM WHEN REQUEST WAS STARTED)
	ASSUME	SIP$W_MODE EQ 0
	MOVW	@IRP$L_SIP(R3),UCB$W_RDA(R5)  ; COPY RDA INTO UCB

RDA_IN_UCB:
	; SET CLOCK, START DATA, AND STOP COME HERE.  THE RDA IS IN UCB$W_RDA.
	; GET 18 BIT UNIBUS ADDRESS OF RDA
	MOVL	UCB$L_RDABA(R5),R2
	BRB	COMMON

;
;	I N I T I A L I Z E
;
INITIALIZE:
	; INITIALIZE IS THE ONLY FUNCTION WHERE THE RDA IS IN THE PROCESS
	; ADDRESS SPACE.  MOVE RDA DESCRIPTOR FROM IRP TO UCB.
	MOVQ	IRP$L_SVAPTE(R3),UCB$L_SVAPTE(R5)

	; SET UP MAP REGISTERS
	CLRB	CRB$L_INTD+VEC$B_DATAPATH(R1)  ; USE DIRECT DATAPATH
	BSBW	SETMAPREG		; REQUEST AND LOAD UBA MAP REGISTERS
	BLBC	R0,DONE			; ALLOCATION FAILURE
	MOVL	CRB$L_INTD+VEC$W_MAPREG(R1),-  ; SAVE ALLOCATED MAP REGISTER
		IRP$L_RDAMAPREG(R3)	; INFO. IN IRP.

COMMON:	; COMMON FUNCTION PROCESSING.  INITIALIZE, SET CLOCK, START
	; DATA, AND STOP ALL COME HERE.  R2 CONTAINS 18 BIT UNIBUS ADDRESS
	; OF RDA.

	; GET POINTER TO LPA-11 DEVICE REGISTERS
	ASSUME	IDB$L_CSR EQ 0
	MOVL	@CRB$L_INTD+VEC$L_IDB(R1),R4	; GET PTR TO 1ST DEVICE REGISTER

	; BUILD WORD TO LOAD INTO LA_CISR IN R1
	ASHL	#-14,R2,R1		; PUT HIGH TWO BITS INTO POSITION IN R1
	BICW	#3,R1			; CLEAR LOW TWO BITS
	INCW	R1			; SET GO BIT

	; CHECK FOR VALID MICROCODE, LOAD LPA-11 REGISTERS, AND THEN WAIT
	; FOR INTERRUPT (THIS ALSO CHECKS FOR POWERFAIL)
	DSBINT	#31			; DON'T ALLOW INTERRUPTS (LIKE PWRFAIL)
	BLBS	UCB$L_DEVDEPEND(R5),LOAD  ; BRANCH IF MICROCODE IS VALID

MCNVALID:  ; MICROCODE IS NOT VALID - COMPLETE REQUEST WITH ERROR
	ENBINT				; ALLOW INTERRUPTS
	MOVZWL	#SS$_MCNOTVALID,R0	; ERROR CODE
	BRB	DONE			; COMPLETE REQUEST

LOAD:	; LOAD LPA-11 REGISTERS
	MOVW	R2,LA_RDA(R4)		; LOAD UNIBUS ADDRESS OF RDA
	BISW2	R1,LA_CISR(R4)		; GO!

WAIT:	; WAIT FOR INTERRUPT
	WFIKPCH	TIMEOUT,#2		; WAIT FOR READY IN INTERRUPT.
					; READY OUT INTERRUPTS DON'T COME HERE.
					; (GO TO 'TIMEOUT' ON TIMEOUT OR
					; POWERFAIL)
	IOFORK				; FORK TO DRIVER LEVEL
	MOVL	UCB$L_IRP(R5),R3	; GET ADDRESS OF CURRENT I/O PACKET
	BEQL	STRT_NXT_REQ		; THERE IS NONE - ALREADY HANDLED
	CLRL	UCB$L_IRP(R5)		; CLEAR CURRENT I/O PACKET
	BSBB	SETCHAR			; SET CHARACTERISTICS IF APPROPRIATE

	; COPY LPA REGISTERS FROM INTERRUPT SAVE AREA TO COMMON SAVE AREA
	MOVQ	UCB$W_RISAVE(R5),UCB$L_REGSAVE(R5)

	MOVZWL	S^#SS$_NORMAL,R0	; SUCCESS STATUS

DONE:	; REQUESTS COME HERE WHEN DONE WITH STATUS IN R0
	CLRL	R1
	BSBW	REQ_COMPLETE

STRT_NXT_REQ:	; START NEXT REQUEST
	REMQUE	@UCB$L_INQFL(R5),R3	; GET NEXT I/O PACKET IN QUEUE
	BVS	60$			; THERE ISN'T ONE
	JMP	G^IOC$INITIATE
60$:	BICW	#UCB$M_BSY,UCB$W_STS(R5)  ; CLEAR UNIT BUSY
	RSB

	.DSABL	LSB

	.SBTTL	SETCHAR - SET CHARACTERISTICS

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SETS DEVICE DEPENDENT CHARACTERISTICS AFTER THE
;	SUCCESSFUL COMPLETION OF AN INITIALIZE OR SET CLOCK QIO.
;	FOR INITIALIZE, THE CONFIGURATION BITS ARE SET.  FOR SET CLOCK
;	THE CLOCK RATE AND PRESET ARE STORED IF CLOCK A WAS SET.
;
; CALLING SEQUENCE:
;
;	BSBW/B
;
; INPUT PARAMETERS:
;
;	R3	ADDRESS OF IRP
;	R5	ADDRESS OF UCB
;
; IMPLICIT INPUTS:
;
;	THE CHARACTERISTICS ARE IN OFFSETS IRP$L_MEDIA THROUGH
;	IRP$L_MEDIA+5 OF THE I/O PACKET
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0,R2 ARE NOT PRESERVED
;--

SETCHAR:
	ASSUME	IRP$S_FCODE EQ 6
	BICB3	#^XC0,IRP$W_FUNC(R3),R2  ; GET I/O FUNCTION CODE

	; IS IT INITIALIZE?
	CMPB	R2,#IO$_INITIALIZE
	BNEQ	10$			; NO
	INSV	IRP$L_MEDIA(R3),#LA$V_CONFIG,-   ; YES, STORE CONFIGURATION
		#LA$S_CONFIG,UCB$L_DEVDEPEND(R5) ; BITS
	BRB	30$

10$:	; IS IT A SET CLOCK (EITHER ONE)
	CMPB	R2,#IO$_SETCLOCK
	BEQL	20$			; YES
	CMPB	R2,#IO$_SETCLOCKP
	BNEQ	30$			; NO

20$:	; IT'S A SET CLOCK.  ONLY SET CHARACTERISTICS IF CLOCK A WAS SET
	BBS	#4,IRP$L_MEDIA(R3),30$	; BRANCH IF CLOCK B IS BEING SET
	ASHL	#-1,IRP$L_MEDIA+2(R3),R0  ; GET CLOCK A RATE IN LOW BITS OF R0
	INSV	R0,#LA$V_RATE,-		; STORE RATE IN CHARACTERISTICS
		#LA$S_RATE,UCB$L_DEVDEPEND(R5)

	ASSUME LA$V_PRESET EQ 16
	MOVW	IRP$L_MEDIA+4(R3),-	; STORE PRESET
		UCB$L_DEVDEPEND+2(R5)

30$:	RSB

	.SBTTL	SDATA - START DATA PROCESSING

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE PERFORMS THE PROCESSING NECESSARY FOR START DATA.
;	IT ALLOCATES A BUFFERED DATAPATH (IF THE REQUEST IS A DEDICATED
;	MODE REQUEST), ALLOCATES AND LOADS MAP REGISTERS FOR THE USW,
;	BUFFERS, AND RCL AND BUILDS THE RDA FROM INFORMATION IN THE SIP.
;
; CALLING SEQUENCE:
;
;	BSBW	SDATA
;
; INPUT PARAMETERS:
;
;	R1	ADDRESS OF CRB
;	R3	ADDRESS OF IRP
;	R5	ADDRESS OF UCB
;
; OUTPUT PARAMETERS:
;
;	R0	COMPLETION CODE
;
; COMPLETION CODES:
;	
;	SS$_NORMAL	NORMAL
;	SS$_INSFMAPREG	INSUFFICIENT MAP REGISTERS
;	SS$_INSFBUFDP	NO DATAPATHS AVAILABLE
;
; SIDE EFFECTS:
;
;	R2,R4 ARE DESTROYED
;--

SDATA:	MOVL	IRP$L_SIP(R3),R4	; GET PTR TO SECONDARY I/O PACKET

	; IF A DEDICATED MODE TRANSFER, REQUEST A BUFFERED DATAPATH
	BBS	#3,SIP$W_MODE(R4),10$	; BRANCH IF MULTI-REQUEST MODE

	JSB	G^IOC$REQDATAPNW	; DEDICATED MODE - GET A BDP
	MOVL	UCB$L_CRB(R5),R1	; RESTORE POINTER TO CRB
	BLBC	R0,60$			; ALLOCATION FAILURE
	BISB3	CRB$L_INTD+VEC$B_DATAPATH(R1),-  ; SAVE DATAPATH NUMBER AND
		#VEC$M_LWAE,SIP$B_BFR_DATAP(R4)  ; SET LONGWORD ACCESS BIT

10$:	; ALLOCATE AND LOAD MAP REGISTERS FOR BUFFERS, USW, AND RCL
	ASSUME	SIP$L_BFR_SVAPT EQ SIP$L_USW_SVAPT+12  ; USW MUST BE FIRST!
	ASSUME	SIP$L_RCL_SVAPT EQ SIP$L_BFR_SVAPT+12  ; RCL MUST BE LAST!
	ADDL	#SIP$L_USW_SVAPT,R4	; POINT TO FIRST SVAPTE
	PUSHL	#3

15$:	MOVQ	(R4)+,UCB$L_SVAPTE(R5)	; LOAD SVAPTE, BOFF, BCNT
	BEQL	20$			; (ONLY IN CASE OF NO RCL - THIS 
					; WORKS ONLY IF RCL INFO. IS LAST)
	MOVB	3(R4),CRB$L_INTD+VEC$B_DATAPATH(R1)  ; LOAD DATAPATH #
	BSBW	SETMAPREG		; ALLOCATE AND LOAD MAP REGISTERS
	BLBC	R0,50$			; ALLOCATION FAILURE
	MOVL	CRB$L_INTD+VEC$W_MAPREG(R1),(R4)+  ; SAVE MAPREG, NUMREG
20$:	SOBGTR	(SP),15$

	; NOW BUILD THE RDA
	MOVL	IRP$L_SIP(R3),R4	; RESTORE POINTER TO BEGINNING OF SIP
	MOVAW	UCB$W_RDA(R5),R0	; POINT TO RDA IN UCB
	MOVQ	SIP$W_MODE(R4),(R0)+	; STORE MODE, BYTE COUNT, AND VALID
					; BUFFER MASK IN RDA
	DIVW2	#2,-6(R0)		; CONVERT BYTE TO WORD COUNT IN RDA

	; INSERT USW ADDRESS
	MOVW	SIP$W_USW_BOFF(R4),-4(R0)  ; BYTE OFFSET
	INSV	SIP$W_USW_MAPRE(R4),#9,#9,-4(R0)  ; PAGE NUMBER

	; NOW INSERT BUFFER ADDRESSES
	MOVL	#7,(SP)
	MOVZWL	SIP$W_BCNT(R4),R2	; BUFFER LENGTH
	MOVZWL	SIP$W_BFR_BOFF(R4),(R0)	; BYTE OFFSET
	INSV	SIP$W_BFR_MAPRE(R4),#9,#9,(R0)  ; FIRST BUFFER ADDRESS
	ADDL	#4,R0			; POINT TO SECOND BUFFER
40$:	ADDL3	R2,-4(R0),(R0)+		; DO REMAINING 7 BUFFERS (ALWAYS CALC.
	SOBGTR	(SP),40$		; ALL 8 BUFFERS EVEN IF THERE AREN'T
					; THAT MANY).

	; NOW STORE RCL ADDRESS IF THERE IS ONE
	MOVZWL	SIP$W_RCL_BOFF(R4),(R0)+  ; IF THERE IS NO RCL, 
	INSV	SIP$W_RCL_MAPRE(R4),#9,#9,-4(R0)  ; THIS STORES A ZERO
	MOVQ	SIP$L_SLVDATA(R4),(R0)+	; COPY REST OF RDA
	MOVQ	SIP$L_SLVDATA+8(R4),(R0)+
	MOVZWL	S^#SS$_NORMAL,R0

50$:	ADDL	#4,SP
	RSB

60$:	; NO DATAPATH
	MOVZWL	#SS$_INSFBUFDP,R0
	RSB


	.SBTTL	REQUEST COMPLETE PROCESSING

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE RELEASES VARIOUS RESOURCES (UNLOCKS PAGES, RELEASES
;	MAP REGISTERS AND DATAPATH, AND DEALLOCATES SIP) BEFORE SENDING
;	AN I/O PACKET TO I/O POST PROCESSING.
;	THIS ROUTINE ALSO DOES SOME STUFF FOR ERROR LOGGING AND DIAGNOSTICS
;
; CALLING SEQUENCE:
;
;	BSBW	REQ_COMPLETE
;	BRW	REQ_COMPLETE
;
; INPUT PARAMETERS:
;
;	R0	FIRST LONGWORD OF I/O STATUS BLOCK
;	R1	SECOND LONGWORD OF I/O STATUS BLOCK
;		NOTE:	IF QIO IS A STOP, THEN STATUS IS ALREADY IN I/O PACKET
;	R3	ADDRESS OF I/O PACKET
;	R5	ADDRESS OF UCB
;
; OUTPUT PARAMETERS:
;
;	NONE
;--


REQ_COMPLETE:
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>
	BICB3	#^XC0,IRP$W_FUNC(R3),R4	; GET FUNCTION CODE
	CLRQ	UCB$L_REGSAVE+8(R5)	; CLEAR DATAPATH # AND REGISTER IN
					; REGISTER SAVE AREA

	; IF THIS IS A STOP REQUEST, THEN DON'T LOAD I/O STATUS
	CMPB	#IO$_STOP,R4		; STOP REQUEST?
	BEQL	5$			; YES, DON'T LOAD STATUS
	MOVQ	R0,IRP$L_IOST1(R3)	; NO, LOAD IOSB

5$:	; GET POINTER TO CRB
	MOVL	UCB$L_CRB(R5),R1

	; IF THIS IS AN INITIALIZE QIO, RELEASE MAP REGISTERS POINTING TO RDA
	CMPB	#IO$_INITIALIZE,R4	; INITIALIZE?
	BNEQ	10$			; NO
	MOVL	IRP$L_RDAMAPREG(R3),-	; GET STARTING MAP # AND NUMBER OF 
		CRB$L_INTD+VEC$W_MAPREG(R1)  ; REGISTERS AND MOVE INTO CRB
	BSBW	REL_MRDP		; RELEASE THEM

10$:	; IF THIS WAS A START DATA OR STOP, GET POINTER TO SEC. I/O PACKET (SIP)
	CMPB	#IO$_STARTDATA,R4	; START DATA?
	BEQL	15$			; YES
	CMPB	#IO$_STARTDATAP,R4	; START DATA PHYSICAL?
	BEQL	15$			; YES
	CMPB	#IO$_STOP,R4		; STOP?
	BNEQ	30$			; NO
15$:	MOVL	IRP$L_SIP(R3),R4	; GET POINTER TO SIP

	; RELEASE MAP REGISTERS FOR USW, DATA BUFFERS, AND RCL.
	MOVL	SIP$W_USW_MAPRE(R4),-	; STARTING MAP REGISTER # AND NUMBER
		CRB$L_INTD+VEC$W_MAPREG(R1)  ; OF REGISTERS FOR USW.
	BEQL	16$			; NONE
	BSBW	REL_MRDP		; RELEASE USW MAP REGISTERS
16$:	MOVL	SIP$W_BFR_MAPRE(R4),-	; SAME FOR DATA BUFFERS, BUT ALSO
		CRB$L_INTD+VEC$W_MAPREG(R1)  ; INCLUDE BUFFERED DP #, IF ANY
	BEQL	18$			; NONE
	BSBW	REL_MRDP		; RELEASE MAP REGISTERS AND DATAPATH
18$:	MOVL	SIP$W_RCL_MAPRE(R4),-	; SAME FOR RCL, IF THERE IS ONE
		CRB$L_INTD+VEC$W_MAPREG(R1)
	BEQL	20$			; NONE
	BSBW	REL_MRDP		; RELEASE RCL MAP REGISTERS

20$:	; NOW UNLOCK PAGES FOR USW, DATA BUFFERS, AND RCL AND DEALLOCATE SIP.
	MOVL	R4,R5
	BSBB	UNLOCKF

30$:	; DO ERROR LOGGING AND DIAGNOSTIC STUFF
	POPR	#^M<R0,R1,R2,R3,R4,R5>
	BSBW	DODIAGERL

	; NOW QUEUE I/O PACKET FOR I/O POST PROCESSING
	JSB	G^COM$POST
	RSB

	.SBTTL	UNLOCK - UNLOCK PAGES AND DEALLOCATE SIP

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE UNLOCKS PAGES WHICH WERE LOCKED FOR A DATA TRANSFER
;	AND DEALLOCATES THE SIP.  IT HAS TWO ENTRY POINTS: ONE SIMPLY
;	UNLOCKS THE PAGES; THE OTHER FORKS (USING THE SIP AS A FORK BLOCK)
;	BEFORE UNLOCKING THE PAGES.  PAGES ARE UNLOCKED FOR THE USW, THE
;	DATA BUFFERS, AND THE RCL.
;
; CALLING SEQUENCE:
;
;	BSBW	UNLOCK		(DOESN'T FORK)
;	BSBW	UNLOCKF		(FORKS)
;
; INPUT PARAMETERS:
;
;	R5	ADDRESS OF SIP
;
; OUTPUT PARAMEMTERS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0 - R5 ARE NOT PRESERVED
;--

UNLOCKF:  ; FORK ENTRY POINT
	MOVB	#IPL$_QUEUEAST,FKB$B_FIPL(R5)  ; LOAD FORK IPL
	FORK

UNLOCK:  ; NO FORK ENTRY POINT

	; UNLOCK PAGES
	PUSHL	R5			; SAVE POINTER TO BEGINNING OF SIP
	ADDL	#SIP$L_USW_SVAPT,R5	; POINT TO FIRST SVAPTE
	MOVL	#3,R4			; LOOP 3 TIMES (USW, DATA BUFFERS, RCL)

10$:	; UNLOCK NEXT AREA
	MOVL	(R5),R3			; GET SVAPTE
	BEQL	20$			; NOTHING THERE
	MOVZWL	4(R5),R1		; GET BOFF
	MOVZWL	6(R5),R2		; GET BCNT
	MOVAB	511(R1)[R2],R1		; COMBINE OFFSET AND COUNT AND ROUND
	ASHL	#-VA$S_BYTE,R1,R1	; CONVERT TO # OF PAGES (TO UNLOCK)
	JSB	G^MMG$UNLOCK		; UNLOCK THEM
20$:	ADDL	#12,R5			; POINT TO NEXT SET OF INFO.
	SOBGTR	R4,10$

	; NOW DEALLOCATE SIP
	MOVL	(SP)+,R0		; GET POINTER TO BEGINNING OF SIP
	JSB	G^EXE$DEANONPAGED
	RSB

	.SBTTL	SETMAPREG - ALLOCATE AND LOAD UBA MAP REGISTERS

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE ALLOCATES AND LOADS UBA MAPPING REGISTERS.
;	IF MAPPING REGISTERS WERE PREALLOCATED THEN THE ALLOCATION IS FROM
;	THE BITMAP IN THE UCB.  OTHERWISE THE ALLOCATION IS FROM THE BITMAP
;	IN THE ADP.
;
; CALLING SEQUENCE:
;
;	BSBW	SETMAPREG
;
; INPUT PARAMETERS:
;
;	R1	POINTS TO CRB
;	R5	POINTS TO UCB
;
; IMPLICIT INPUTS:
;
;	UCB$L_SVAPTE, UCB$W_BCNT, UCB$W_BOFF DESCRIBE THE AREA TO BE MAPPED
;	UCB$L_PREALLOC IS NON-ZERO IF MAP REGISTERS WERE PREALLOCATED
;	CRB$L_INTD+VEC$B_DATAPATH CONTAINS THE DATAPATH NUMBER TO USE
;
; OUTPUT PARAMETERS:
;
; 	R0	CONTAINS A COMPLETION CODE (SEE BELOW)
;	R2	CONTAINS 18 BIT STARTING UNIBUS ADDRESS OF AREA MAPPED
;
; IMPLICIT OUTPUTS:
;
;	CRB$L_INTD+VEC$W_MAPREG CONTAINS STARTING MAP REGISTER NUMBER
;	CRB$L_INTD+VEC$B_NUMREG CONTAINS NUMBER OF MAPPING REGISTERS ALLOCATED
;
; COMPLETION CODES:
;
;	SS$_NORMAL	ALLOCATION WAS SUCCESSFUL
;	SS$_INSFMAPREG	ALLOCATION FAILED (INSUFFICIENT MAP REGISTERS)
;
; SIDE EFFECTS:
;
;	NONE
;
;--
SETMAPREG:

; If map registers were preallocated, then we call local subroutine
;	ALLOC_LOCALMR to use some of preallocated registers.  Else we
;	use normal system subroutine to allocate from central pool.

	TSTL	UCB$L_PREALLOC(R5)	; ANY REGISTERS PREALLOCATED?
	BEQL	10$			; NO, PROCEED NORMALLY
	BSBB	ALLOC_LOCALMR		; Allocate from local pool.
	BRB	20$			;  and branch around normal path.

10$:	; ALLOCATE MAPPING REGISTERS
	JSB	G^IOC$ALOUBAMAP
	MOVL	UCB$L_CRB(R5),R1	; REFRESH R1 => CRB.
20$:
	BLBC	R0,50$			; ALLOCATION FAILURE

	; LOAD UNIBUS MAPPING REGISTERS
	PUSHR	#^M<R1,R4>
	JSB	G^IOC$LOADUBAMAP
	POPR	#^M<R1,R4>

	; SET UP STARTING UNIBUS ADDRESS OF AREA MAPPED
	MOVZWL	UCB$W_BOFF(R5),R2	; BYTE OFFSET IN PAGE (LOW 9 BITS)
	INSV	CRB$L_INTD+VEC$W_MAPREG(R1),#9,#9,R2  ; HIGH 9 BITS

	MOVZWL	S^#SS$_NORMAL,R0	; SUCCESSFUL ALLOCATION
	RSB


50$:	; ALLOCATION FAILED
	MOVZWL	#SS$_INSFMAPREG,R0	; INSUFFICIENT MAP REGISTERS
	RSB

	.SBTTL	ALLOCATE UBA MAP REGISTERS FROM LOCAL POOL
;+
; ALLOC_LOCALMR
;
; THIS ROUTINE IS CALLED TO ALLOCATE UBA MAP REGISTERS AND TO MARK THE ALLOCATION
; IN THE UBA MAP REGISTER ALLOCATION BITMAP MAINTAINED LOCALLY.
;
; INPUTS:
;
;	R5 = DEVICE UNIT UCB ADDRESS.
;
; OUTPUTS:
;
;	R0 = SUCCESS INDICATION.
;-
 
ALLOC_LOCALMR:				;ALLOCATE UBA MAP REGISTERS CRB SPECIFIED
	MOVQ	R3,-(SP)		; Save R3 and R4.
	MOVZWL	UCB$W_BCNT(R5),R3	;GET TRANSFER BYTE COUNT
	MOVZWL	UCB$W_BOFF(R5),R4	;GET BYTE OFFSET IN PAGE
	MOVAB	^X3FF(R3)[R4],R3	;CALCULATE HIGHEST RELATIVE BYTE AND ROUND
	ASHL	#-9,R3,R3		;CALCULATE NUMBER OF MAP REGISTERS REQUIRED
5$:	CLRL	R0			;ASSUME ALLOCATION FAILURE
	MOVL	UCB$L_CRB(R5),R1	;GET ADDRESS OF CRB
	MOVB	R3,CRB$L_INTD+VEC$B_NUMREG(R1) ;SET NUMBER OF MAP REGISTERS ALLOCATED
	CLRL	R4			;CLEAR STARTING BIT POSITION
10$:	ADDL3	R3,R4,R2		;CALCULATE HIGHEST BIT IN REQUIRED SCAN
	CMPW	R2,#496			;BEYOND END OF ALLOCATION BITMAP?
	BGTR	50$			;IF GTR YES
	FFS	R4,#32,UCB$W_MRBITMAP(R5),R4 ;FIND A SET BIT
	BEQL	10$			;IF EQL BIT NOT FOUND
	ADDL3	R3,R4,R2		;CALCULATE HIGH BIT FOR SUCCESSFUL ALLOCATION
	MOVW	R4,CRB$L_INTD+VEC$W_MAPREG(R1) ;SAVE STARTING BIT NUMBER
20$:	FFC	R4,#32,UCB$W_MRBITMAP(R5),R4 ;FIND A CLEAR BIT
	CMPL	R4,R2			;ENOUGH SET BITS SCANNED OVER?
	BGEQ	30$			;IF GEQ YES
	BBS	R4,UCB$W_MRBITMAP(R5),20$ ;IF SET, CONTINUE SCAN
	BRB	10$			;
30$:	MOVZWL	CRB$L_INTD+VEC$W_MAPREG(R1),R4 ;RETRIEVE STARTING MAP REGISTER
	BSBB	ALT_LOCALBITMAP		;ALTER MAP REGISTER BITMAP
40$:	INCL	R0			;SET SUCCESS INDICATOR
50$:	MOVQ	(SP)+,R3		;RESTORE REGISTERS
	RSB				;
	.PAGE
	.SBTTL	ALTER LOCAL UBA MAP REGISTER BITMAP
;+
; ALT_LOCALBITMAP
;
; THIS ROUTINE IS CALLED TO EITHER CLEAR OR SET A FIELD OF BITS IN THE UBA MAP
; REGISTER ALLOCATION BITMAP MAINTAINED LOCALLY IN THE UCB.
;
; INPUTS:
;
;	R0 = ALTERATION BIT MASK.
;	R1 = ADDRESS OF CRB.
;	R4 = STARTING MAP REGISTER NUMBER.
;	R5 => UCB
;
; OUTPUTS:
;
;	THE SPECIFIED BIT FIELD IN THE UBA MAP ALLOCATION BIT MAP IS EITHER SET
;	OR CLEARED DEPENDING ON THE STATE OF THE ALTERATION MASK.
;
;	R3 AND R4 ARE DESTROYED.
;-
 
ALT_LOCALBITMAP:
	MOVZBL	CRB$L_INTD+VEC$B_NUMREG(R1),R3 ;GET NUMBER OF BITS TO ALTER
10$:	CMPL	#32,R3			;MORE THAN LONGWORD LEFT?
	BGEQ	20$			;IF GEQ NO
	INSV	R0,R4,#32,UCB$W_MRBITMAP(R5) ;ALTER BITMAP WITH SUPPLIED PATTERN
	ADDL	#32,R4			;UPDATE STARTING BIT POSITION
	SUBL	#32,R3			;REDUCE NUMBER OF BITS TO ALTER
	BRB	10$			;
20$:	INSV	R0,R4,R3,UCB$W_MRBITMAP(R5) ;ALTER BITMAP WITH SUPPLIED PATTERN
	RSB				;
	.PAGE
	.SBTTL	REL_MRDP - RELEASE UBA MAP REGISTERS AND DATAPATH

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE RELEASES UBA MAP REGISTERS AND A BUFFERED
;	DATAPATH IF ONE WAS ASSIGNED.  IF MAPPING REGISTERS
;	WERE PREALLOCATED, THEN THEY ARE RELEASED INTO THE BITMAP IN THE
;	UCB.  OTHERWISE, THEY ARE RELEASED INTO THE BITMAP IN THE ADP.
;	IN THE LATTER CASE AN ATTEMPT IS MADE TO CALL ANY DRIVERS WAITING
;	FOR MAP REGISTERS (ON THE ADP QUEUE).  BUFFERED DATAPATHS ARE
;	ALWAYS RELEASED INTO THE ADP BITMAP BECAUSE THEY ARE NOT PREALLOCATED.
;	ALSO, THE DATAPATH IS PURGED BEFORE IT IS RELEASED.
;	ALSO, THE DATAPATH NUMBER AND DATAPATH REGISTER ARE COPIED INTO
;	THE REGISTER SAVE AREA FOR DIAGNOSTICS AND ERROR LOGGING USE.
;
; CALLING SEQUENCE:
;
;	BSBW	REL_MRDP
;
; INPUT PARAMETERS:
;
;	R1	POINTS TO CRB
;	R3	POINTS TO IRP
;	R5	POINTS TO UCB
;
; IMPLICIT INPUTS:
;
;	UCB$L_PREALLOC IS NON-ZERO IF MAP REGISTERS WERE PREALLOCATED
;	CRB$L_INTD+VEC$W_MAPREG CONTAINS THE STARTING MAP REGISTER NUMBER
;	CRB$L_INTD+VEC$B_NUMREG CONTAINS NUMBER OF MAP REGISTERS TO RELEASE
;	CRB$L_INTD+VEC$B_DATAPATH CONTAINS THE DATAPATH NUMBER (ZERO MEANS
;		A BUFFERED DATAPATH WASN'T ALLOCATED).
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	IF THERE IS A DATAPATH ERROR, THEN THE STATUS SS$_PARITY IS STORED
;	IN THE I/O PACKET.
;--

REL_MRDP:
	PUSHR	#^M<R0,R1,R2,R4>
	PUSHL	R3			; SAVE R3 SEPARATELY
	TSTL	UCB$L_PREALLOC(R5)	; REGISTERS PREALLOCATED?
	BEQL	10$			; NO

	; REGISTERS WERE PREALLOCATED SO SET UP TO ALTER BITMAP IN UCB.
	MOVZWL	CRB$L_INTD+VEC$W_MAPREG(R1),R4  ; STARTING MAP REGISTER #
	MCOML	#0,R0			; ALTER PATTERN
	BSBB	ALT_LOCALBITMAP		; Alter local bit map.
	BRB	20$

10$:	; REGISTERS WERE NOT PREALLOCATED SO RETURN THEM TO ADP BITMAP
	JSB	G^IOC$RELMAPREG
	MOVL	UCB$L_CRB(R5),R1	; RESTORE POINTER TO CRB

20$:	; RELEASE DATAPATH IF ONE WAS ALLOCATED
	MOVL	(SP)+,R3		; RESTORE R3 (POINTER TO IRP)
	EXTZV	#VEC$V_DATAPATH,#VEC$S_DATAPATH,- ; EXTRACT DATAPATH NUMBER
		CRB$L_INTD+VEC$B_DATAPATH(R1),R2  ; INTO R2
	BEQL	30$			; NONE ALLOCATED

	; PURGE DATAPATH
	PUSHR	#^M<R2,R3>		; SAVE D.P. NUMBER AND IRP POINTER
	JSB	G^IOC$PURGDATAP		; RETURNS STATUS IN R0, D.P. REG. IN R1
	POPR	#^M<R2,R3>
	BLBS	R0,25$			; NO TRANSMISSION ERROR
	MOVZWL	#SS$_PARITY,IRP$L_IOST1(R3)	; YES, RETURN ERROR STATUS

25$:	; SAVE DATAPATH NUMBER AND CONTENTS OF DATAPATH REGISTER IN REGISTER
	; SAVE AREA
	MOVL	R2,UCB$L_REGSAVE+8(R5)	; SAVE DATAPATH NUMBER
	MOVL	R1,UCB$L_REGSAVE+12(R5)	; SAVE DATAPATH REGISTER

	JSB	G^IOC$RELDATAP		; RELEASE DATAPATH

30$:	POPR	#^M<R0,R1,R2,R4>
	RSB

	.SBTTL	READY IN INTERRUPT SERVICE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS THE READY-IN INTERRUPT SERVICE ROUTINE.
;	ASSUMING THE INTERRUPT WAS EXPECTED, IT CALLS THE DRIVER AT
;	THE INTERRUPT WAIT ADDRESS AND THEN RETURNS.  UNEXPECTED
;	INTERRUPTS ARE IGNORED BY RETURNING IMMEDIATELY.
;
; CALLING SEQUENCE:
;
;	JSB FROM INTERRUPT VECTOR IN CRB
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	THE STACK ON ENTRY IS AS FOLLOWS:
;
;		 0(SP)		ADDRESS OF IDB ADDRESS
;	4(SP) - 24(SP)		SAVED R0 - R5
;		28(SP)		INTERRUPT PC
;		32(SP)		INTERRUPT PSL
;
; OUTPUT PARAMETERS:
;
;	NONE
;--


LA$RDYININTSV::
	MOVL	@(SP)+,R3		; GET ADDRESS OF IDB
	ASSUME	IDB$L_CSR+4 EQ IDB$L_OWNER
	MOVQ	IDB$L_CSR(R3),R4	; CSR -> R4;   UCB -> R5

	BBCC	#UCB$V_INT,UCB$W_STS(R5),INTEXIT  ; IF CLR, INT. NOT EXPECTED

	; COPY LPA-11 REGISTERS INTO READY-IN INTERRUPT SAVE AREA
	MOVW	LA_CISR(R4),UCB$W_RISAVE(R5)
	MOVW	LA_COSR(R4),UCB$W_RISAVE+2(R5)
	MOVW	LA_RDA(R4),UCB$W_RISAVE+4(R5)
	MOVW	LA_MAINT(R4),UCB$W_RISAVE+6(R5)

	MOVQ	UCB$L_FR3(R5),R3	; RESTORE DRIVER CONTEXT
	JSB	@UCB$L_FPC(R5)		; CALL DRIVER AT INTERRUPT WAIT ADDRESS

INTEXIT:
	MOVQ	(SP)+,R0		; RESTORE REGISTERS
	MOVQ	(SP)+,R2
	MOVQ	(SP)+,R4
	REI

	.SBTTL	READY OUT INTERRUPT SERVICE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS THE READY-OUT INTERRUPT SERVICE ROUTINE.
;	AFTER RECEIVING THE INTERRUPT, THIS ROUTINE FORKS, DETERMINES
;	THE CAUSE OF THE INTERRUPT, AND DISPATCHES TO AN APPROPRIATE
;	ROUTINE.  THERE ARE BASICALLY FOUR CASES:
;		1)  NO ERROR
;			A)  START REQUEST PROCESSED
;			B)  BUFFER FULL OR EMPTY
;			C)  BUFFER OVER/UNDERRUN
;		2)  COMMAND ERROR
;		3)  USER REQUEST ERROR (DURING A DATA TRANSFER)
;		4)  FATAL HARDWARE ERROR
;
; CALLING SEQUENCE:
;
;	JSB FROM INTERRUPT VECTOR IN CRB
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	THE STACK ON ENTRY IS AS FOLLOWS:
;
;		 0(SP)		ADDRESS OF IDB ADDRESS
;	4(SP) - 24(SP)		SAVED R0 - R5
;		28(SP)		INTERRUPT PC
;		32(SP)		INTERRUPT PSL
;
; OUTPUT PARAMETERS:
;
;	NONE
;--

LA$RDYOUTINTSV::
	MOVL	@(SP)+,R3		; GET ADDRESS OF IDB
	ASSUME	IDB$L_CSR+4 EQ IDB$L_OWNER
	MOVQ	IDB$L_CSR(R3),R4	; CSR -> R4;   UCB -> R5

	; COPY LPA-11 REGISTERS INTO READY-OUT INTERRUPT SAVE AREA
	MOVW	LA_CISR(R4),UCB$W_ROSAVE(R5)
	MOVW	LA_COSR(R4),UCB$W_ROSAVE+2(R5)
	MOVW	LA_RDA(R4),UCB$W_ROSAVE+4(R5)
	MOVW	LA_MAINT(R4),UCB$W_ROSAVE+6(R5)

	PUSHAB	INTEXIT			; ADDRESS TO RETURN TO AFTER FORK
	MOVAL	UCB$L_FORKO(R5),R5	; HAVE TO USE DIFFERENT FORK BLOCK THAN
	FORK				; READY IN INTERRUPTS USE.

	MOVAL	-UCB$L_FORKO(R5),R5	; RESTORE POINTER TO UCB

	; COPY LPA-11 REGISTERS FROM INTERRUPT SAVE AREA TO COMMON SAVE AREA
	MOVQ	UCB$W_ROSAVE(R5),UCB$L_REGSAVE(R5)

	; GET CONTENTS OF CONTROL OUT STATUS REGISTER, AND MAINTENANCE REGISTER
	; AND THEN ACKNOWLEGE INTERRUPT (WHICH ALLOWS THE NEXT READY OUT
	; INTERRUPT TO OCCUR)
	MOVZWL	LA_COSR(R4),R0		; CONTROL OUT STATUS
	MOVZWL	LA_MAINT(R4),R1		; MAINTENANCE REGISTER
	BICW2	#LA_COSR_M_RDY,LA_COSR(R4)  ; ACKNOWLEGE INTERRUPT

	; PUT BOTH LPA-11 REGISTERS INTO R1 TO BE USED AS SECOND
	; LONGWORD OF IOSB IN CASE OF ERROR.
	ASHL	#16,R1,R1		; PUT MAINT. REGISTER IN HIGH WORD
	MOVW	R0,R1			; PUT CONTROL OUT STATUS IN LOW WORD

	; GET USER # IN R2 AND DETERMINE IF THIS IS AN ERROR
	BICL3	#^XFFFFFFF8,R0,R2	; GET USER INDEX IN R2
	ASHL	#-8,R0,R0		; PUT STATUS ON LOW BYTE
	TSTB	R0			; ERROR?
	BLSS	ERROR			; YES
	BRW	NO_ERROR		; NO

;
;	E R R O R
;
ERROR:	; SOME SORT OF ERROR -  DETERMINE WHAT TYPE AND DISPATCH TO
	; APPROPRIATE ROUTINE.  ERROR TYPE IS SPECIFIED BY FIELD
	; LA_COSR_V_ERRTP WHICH HAS BEEN SHIFTED 8 BITS TO THE RIGHT IN R0
	CMPZV	#LA_COSR_V_ERRTP-8,#LA_COSR_S_ERRTP,R0,#2
	BLSS	REQERR			; USER REQUEST ERROR
	BEQL	CMDERR			; COMMAND ERROR

	; FALL THROUGH TO ...

;
;	F A T A L   H A R D W A R E   E R R O R
;
	MOVZWL	#SS$_CTRLERR,R0		; STATUS
	BRB	COMPL_ALL_REQS

;
;	T I M E O U T   O R   P O W E R F A I L
;
TIMEOUT:  ; DEVICE TIMEOUT AND POWERFAIL COME HERE (AT DEVICE IPL).
	SETIPL	UCB$B_FIPL(R5)		; LOWER TO FORK IPL
	MOVZWL	#SS$_POWERFAIL,R0	; ASSUME POWERFAIL
	CLRL	R1			; CLEAR SECOND LONGWORD OF IOSB
	BBS	#UCB$V_POWER,-		; BRANCH IF POWERFAIL
		UCB$W_STS(R5),COMPL_ALL_REQS
	MOVZWL	#SS$_TIMEOUT,R0		; MUST BE TIMEOUT

COMPL_ALL_REQS:   ; COMPLETE ALL OUTSTANDING I/O REQUESTS
	MOVL	UCB$L_IRP(R5),R3	; GET CURRENT I/O REQUEST PACKET
	BEQL	10$			; THERE ISN'T ONE
	CLRL	UCB$L_IRP(R5)		; CLEAR CURRENT I/O PACKET
	BSBW	REQ_COMPLETE		; SEND IT TO REQUEST COMPLETE

10$:	; NOW COMPLETE ALL OUTSTANDING DATA TRANSFER REQUESTS
	BSBW	COMPLETE_ALL

	; DO A DEVICE RESET (MASTER CLEAR) TO STOP MICROPROCESSOR
	DSBINT	UCB$B_DIPL(R5)		; RAISE IPL TO DEVICE LEVEL
	MOVW	#LA_CISR_M_RESET,LA_CISR(R4)  ; RESET
	ENBINT				; LOWER IPL

	; REQUESTS ON THE INPUT QUEUE ARE STARTED IN THE NORMAL FASHION.
	; HOWEVER, THEY ARE EXPECTED TO TIMEOUT.
	BRW	STRT_NXT_REQ		; START NEXT REQUEST.


;
;	U S E R   R E Q U E S T   E R R O R
;
REQERR:	; USER REQUEST ERROR
	MOVL	UCB$L_RQLIST(R5)[R2],R3	; GET POINTER TO I/O PACKET
	BEQL	30$			; CAN HAPPEN IF STOP HAS BEEN QUEUED
					; FOR THIS REQUEST
	CLRL	UCB$L_RQLIST(R5)[R2]	; CLEAR SLOT
	CMPB	#^O250,R0		; STOPPED BY USW REQUEST?
	BEQL	10$			; YES
	MOVZWL	#SS$_DEVREQERR,R0	; NO - ERROR.  LOAD STATUS RETURN
	BRB	20$

10$:	; STOPPED BY USW REQUEST
	MOVZWL	S^#SS$_NORMAL,R0	; RETURN NORMAL STATUS
	CLRL	R1			; CLEAR SECOND LONGWORD OF IOSB
20$:	BSBW	REQ_COMPLETE
30$:	RSB

;
;	C O M M A N D   E R R O R
;
CMDERR:	; COMMAND ERROR
	MOVL	UCB$L_IRP(R5),R3	; GET POINTER TO CURRENT PACKET
	CLRL	UCB$L_IRP(R5)		; CLEAR CURRENT PACKET ENTRY
	MOVZWL	#SS$_DEVCMDERR,R0	; STATUS RETURN
	BSBW	REQ_COMPLETE
	RSB


;
;	N O   E R R O R
;
NO_ERROR:  ; COME HERE IF THE INTERRUPT WAS NOT DUE TO AN ERROR.
	; THERE ARE THREE CASES: 
	;	R0 = 0		START REQUEST PROCESSED
	;	R0 = 1		NORMAL BUFFER FULL/EMPTY
	;	R0 = 2		BUFFER OVER/UNDERRUN
	; NOTE:  WHEN WE GET HERE R0 HAS JUST BEEN TESTED.

	BNEQ	BFRFULL			; BUFFER FULL OR OVER/UNDERRUN

;
;	S T A R T   R E Q U E S T   P R O C E S S E D
;
STARTREQ:
	; START REQUEST PROCESSED
	MOVL	UCB$L_IRP(R5),R3	; GET POINTER TO I/O PACKET
	MOVL	IRP$L_SIP(R3),R4	; GET POINTER TO SIP
	MOVB	#STOP_MODE,SIP$W_MODE(R4)  ; BUILD STOP RDA IN SIP
	MOVB	R2,SIP$W_MODE+1(R4)	; USER #
	MOVL	R3,UCB$L_RQLIST(R5)[R2]	; STORE ENTRY IN REQUEST LIST
	CLRL	UCB$L_IRP(R5)		; NO LONGER CURRENT PACKET
	ADDL	I^#10,UCB$L_DUETIM(R5)	; ADD 10 SECONDS TO DUE TIME TO PREVENT
					; TIMEOUTS IN DEDICATED MODE WITH
					; SLOW TRANSFERS.

	; NOW CHECK TO SEE IF THIS REQUEST HAS BEEN CANCELED
	MOVZWL	#SS$_ABORT,R0		; ASSUME IT HAS
	BBS	#UCB$V_CANCEL,UCB$W_STS(R5),-   ; BRANCH IF IT HAS BEEN CANCELED
		QUEUE_STOP_REQ

10$:	; NOW SIGNAL THAT REQUEST WAS STARTED
	MOVL	IRP$L_BFR_AST(R3),R4	; USE BUFFER FULL AST ADDRESS
	BSBB	SIGNAL_BFR_FULL
	BLBC	R0,QUEUE_STOP_REQ	; ERROR
	RSB



;
;	B U F F E R   F U L L   O R   O V E R / U N D E R R U N
;
BFRFULL:
	; BUFFER FULL OR EMPTY (AND POSSIBLY OVER/UNDERRUN)
	MOVL	UCB$L_RQLIST(R5)[R2],R3	; GET POINTER TO I/O PACKET
	BEQL	30$			; CAN HAPPEN IF STOP HAS BEEN QUEUED
	MOVL	IRP$L_BFR_AST(R3),R4	; GET BUFFER FULL AST ADDRESS
	CMPB	R0,#1			; BUFFER OVER/UNDERRUN?
	BEQL	20$			; NO
	MOVL	IRP$L_OVR_AST(R3),R4	; YES, GET BFR OVER/UNDERRUN AST ADDRESS
20$:	BSBB	SIGNAL_BFR_FULL
	BLBC	R0,QUEUE_STOP_REQ	; ERROR
30$:	RSB

	.SBTTL	QUEUE_STOP_REQ - QUEUE A STOP REQUEST

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE TAKES AN I/O PACKET, CHANGES THE FUNCTION CODE TO
;	STOP, AND QUEUES THE PACKET TO THE DRIVER (AT THE HEAD OF THE
;	QUEUE).  IF THE DRIVER IS NOT BUSY, IT IS CALLED IMMEDIATELY.
;	IT IS ASSUMED THAT THE STOP RDA HAS ALREADY BEEN BUILT IN THE PACKET.
;	NOTE:  THIS ROUTINE MUST BE CALLED AT DRIVER FORK LEVEL.
;
; CALLING SEQUENCE:
;
;	BSBW	QUEUE_STOP_REQ   OR
;	BRW	QUEUE_STOP_REQ
;
; INPUT PARAMETERS:
;
;	R0	FIRST LONGWORD OF I/O STATUS BLOCK
;	R2	USER INDEX
;	R5	POINTER TO UCB
;
; OUTPUT PARAMETERS:
;
;	NONE
;--

QUEUE_STOP_REQ:
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>
	MOVL	UCB$L_RQLIST(R5)[R2],R3	; GET POINTER TO I/O PACKET
	BEQL	40$			; PACKET ALREADY WENT AWAY
	CLRL	UCB$L_RQLIST(R5)[R2]	; CLEAR SLOT
	MOVB	#IO$_STOP,IRP$W_FUNC(R3)  ; STORE STOP FUNCTION CODE IN IRP
	MOVL	R0,IRP$L_IOST1(R3)	; STORE STATUS CODE IN IOSB
	CLRL	IRP$L_IOST2(R3)		; CLEAR SECOND LONGWORD

	; REQUEUE PACKET IN FRONT IF I/O QUEUE (OR IF NOT BUSY, HANDLE IT NOW)
	BBSS	#UCB$V_BSY,UCB$W_STS(R5),30$  ; SET BUSY; WAS IT ALREADY SET?
	JSB	G^IOC$INITIATE		; NO, START DRIVER GOING
	BRB	40$

30$:	; DRIVER IS BUSY.  QUEUE PACKET
	INSQUE	IRP$L_IOQFL(R3),UCB$L_INQFL(R5)
40$:	POPR	#^M<R0,R1,R2,R3,R4,R5>
	RSB

	.SBTTL	SIGNAL_BFR_FULL - SIGNAL BUFFER FULL (OR EMPTY) TO USER

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SIGNALS A USER PROCESS THAT A BUFFER HAS BEEN FILLED
;	OR EMPTIED.  SIGNALING IS DONE BY SETTING AN EVENT FLAG OR
;	ISSUING AN AST OR BOTH.  NOTE THAT THE SIGNALING IS DONE
;	AFTER A FORK HAS BEEN PERFORMED.
;
; CALLING SEQUENCE:
;
;	BSBB	SIGNAL_BFR_FULL
;
; INPUT PARAMETERS:
;
;	R3	ADDRESS OF I/O PACKET
;	R4	(USER) AST ADDRESS OR ZERO WHICH MEANS DON'T GIVE AN AST
;	R5	ADDRESS OF UCB
;
; IMPLICIT INPUTS:
;
;	VARIOUS FIELDS IN THE I/O PACKET
;
; OUTPUT PARAMETERS:
;
;	R0	COMPLETION CODE
;
; COMPLETION CODES:
;
;	SS$_NORMAL	NORMAL SUCCESSFUL COMPLETION
;	SS$_INSFMEM	INSUFFICIENT DYNAMIC MEMORY
;	SS$_EXQUOTA	EXCEEDED AST QUOTA
;
; SIDE EFFECTS:
;
;	R1 IS NOT PRESERVED
;--

SIGNAL_BFR_FULL:
	PUSHR	#^M<R2,R5>		; SAVE REGISTERS HERE SO R5 CAN BE
	BSBB	5$			; RESTORED AFTER FORK
	POPR	#^M<R2,R5>
	RSB

5$:	; MAKE SURE THERE IS ENOUGH AST QUOTA TO ALLOCATE A FORK/AST BLOCK
	MOVZWL	IRP$L_PID(R3),R5	; GET PROCESS INDEX
	PUSHL	G^SCH$GL_PCBVEC		; PUSH ADDRESS OF PCB TABLE
	MOVL	@(SP)+[R5],R5		; GET PCB ADDRESS
	MOVZWL	#SS$_EXQUOTA,R0		; ASSUME ERROR
	TSTW	PCB$W_ASTCNT(R5)	; ENOUGH AST QUOTA LEFT?
	BLEQ	10$			; NO
	DECW	PCB$W_ASTCNT(R5)	; YES, TAKE ONE AWAY

	; ALLOCATE A PACKET TO BE USED AS A FORK BLOCK AND AST CONTROL BLOCK
	MOVZWL	#IRP$C_LENGTH,R1	; LENGTH = AN I/O PACKET
	PUSHL	R3			; SAVE R3
	JSB	G^EXE$ALONONPAGED	; RETURNS POINTER TO PACKET IN R2
	MOVL	(SP)+,R3		; RESTORE R3
	BLBS	R0,20$			; SUCCESSFUL ALLOCATION
	MOVZWL	#SS$_INSFMEM,R0		; ERROR - INSUFFICIENT DYNAMIC MEMORY
	INCW	PCB$W_ASTCNT(R5)	; ADD 1 BACK TO AST QUOTA
10$:	RSB				; ERROR RETURN

20$:	; PUT SIZE AND TYPE INTO PACKET
	ASSUME	IRP$B_TYPE EQ IRP$W_SIZE+2
	MOVL	#<DYN$C_ACB@16>+IRP$C_LENGTH,IRP$W_SIZE(R2)

	; NOW FORK (AND RETURN STATUS TO CALLER)
	ASSUME FKB$B_FIPL EQ IRP$B_RMOD
	MOVB	#IPL$_QUEUEAST,FKB$B_FIPL(R2)  ; SET FORK IPL
	MOVL	R2,R5
	MOVZWL	S^#SS$_NORMAL,R0	; RETURN NORMAL STATUS TO CALLER
	FORK

	; SET VARIOUS VALUES IN AST CONTROL BLOCK IN PREPARATION FOR
	; QUEUING AST
	MOVL	IRP$L_PID(R3),R1	; SAVE PID FOR CALL TO SCH$POSTEF
	MOVL	R1,ACB$L_PID(R5)	; PID
	MOVL	R4,ACB$L_AST(R5)	; AST ADDRESS
	BEQL	30$			; NO AST
	MOVB	IRP$B_RMOD(R3),ACB$B_RMOD(R5)	; ACCESS MODE
	BISB	#ACB$M_QUOTA,ACB$B_RMOD(R5)  ; SET AST QUOTA ACCOUNTING FLAG
	MOVL	IRP$L_ASTPRM(R3),ACB$L_ASTPRM(R5)  ; COPY AST PARAMETER

30$:	; NOW POST EVENT FLAG IF SUBFUNCTION CODE SPECIFIES IT
	MOVZBL	#PRI$_IOCOM,R2		; PRIORITY INCREMENT CLASS
	BBC	#IO$V_SETEVF,IRP$W_FUNC(R3),35$  ; BRANCH IF DON'T POST E.F.
	MOVZBL	IRP$B_EFN(R3),R3	; EVENT FLAG NUMBER
	JSB	G^SCH$POSTEF		; POST EVENT FLAG

35$:	; NOW EITHER GIVE AST OR DEALLOCATE BLOCK
	TSTL	ACB$L_AST(R5)		; GIVE AST?
	BEQL	40$			; NO
	JMP	G^SCH$QAST		; YES

40$:	; DON'T GIVE AST SO DEALLOCATE PACKET
	MOVZWL	ACB$L_PID(R5),R2	; BUT FIRST INCR. AST QUOTA
	PUSHL	G^SCH$GL_PCBVEC		; PUSH ADDRESS OF PCB TABLE
	MOVL	@(SP)+[R2],R2		; GET PCB ADDRESS
	INCW	PCB$W_ASTCNT(R2)	; INCR. QUOTA
	MOVL	R5,R0
	JMP	G^EXE$DEANONPAGED

	.SBTTL	DODIAGERL - DO DIAG. AND ERROR LOGGING STUFF
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE DOES THE FOLLOWING:
;		1)  CALLS THE DIAGNOSTIC BUFFER FILL ROUTINE WHICH COPIES
;		    THE REGISTER SAVE INFO. INTO A DIAGNOSTIC BUFFER IF ONE
;		    WAS SUPPLIED WITH THE REQUEST.
;		2)  IF THE I/O STATUS INDICATES A LOGGABLE ERROR, THEN
;		    THE ERROR IS LOGGED.  NOTE THAT THIS ROUTINE DOES THE 
;		    PROCESSING NORMALLY DONE IN IOC$REQCOM SINCE THIS DRIVER
;		    DOESN'T CALL IOC$REQCOM.
;
; CALLING SEQUENCE:
;
;	BSBW	DODIAGERL
;
; INPUT PARAMETERS:
;
;	R0	FIRST LONGWORD OF I/O STATUS
;	R1	SECOND LONGWORD OF I/O STATUS
;	R3	ADDRESS OF IRP
;	R5	ADDRESS OF UCB
;
; IMPLICIT INPUTS:
;
;	VARIOUS FIELDS IN THE IRP AND UCB
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	OFFSET UCB$W_FUNC IN THE UCB IS MODIFIED
;--

DODIAGERL:
	PUSHR	#^M<R0,R1,R2>
	PUSHL	UCB$L_IRP(R5)		; SAVE THIS 'CAUSE WE MODIFY IT

	MOVW	IRP$W_FUNC(R3),UCB$W_FUNC(R5)	; SAVE FUNCTION CODE
	MOVL	R3,UCB$L_IRP(R5)	; MAKE THIS IRP THE 'CURRENT' ONE

	; CALL DIAGNOSTIC BUFFER FILL ROUTINE
	JSB	G^IOC$DIAGBUFILL

	; CALL ERROR LOGGER IF WE HAVE A LOGGABLE ERROR
	CMPW	IRP$L_IOST1(R3),#SS$_TIMEOUT	; IS IT A TIMEOUT?
	BNEQ	10$				; NO
	JSB	G^ERL$DEVICTMO			; YES, LOG TIMEOUT
	BRB	40$

10$:	; IS IT ANY OTHER LOGGABLE ERROR?
	CMPW	IRP$L_IOST1(R3),#SS$_CTRLERR	; IS IT A FATAL HRDWRE ERROR?
	BEQL	30$				; YES
	CMPW	IRP$L_IOST1(R3),#SS$_DEVREQERR	; IS IT A DEVICE REQUEST ERROR?
	BEQL	30$			; YES
	CMPW	IRP$L_IOST1(R3),#SS$_PARITY	; UBA PARITY ERROR?
	BNEQ	50$				; NO

30$:	JSB	G^ERL$DEVICERR			; LOG DEVICE ERROR

40$:	; NOW FILL IN REST OF BUFFER LIKE IOC$REQCOM DOES
	BICW	#UCB$M_ERLOGIP,UCB$W_STS(R5)	; CLEAR ERROR LOG IN PROGRESS
	MOVL	UCB$L_EMB(R5),R2	; GET ADDRESS OF ERROR MESSAGE BUFFER
	MOVW	UCB$W_STS(R5),EMB$W_DV_STS(R2) ;INSERT FINAL DEVICE STATUS
	MOVW	UCB$B_ERTCNT(R5),EMB$B_DV_ERTCNT(R2)	; INSERT ERROR COUNTERS
	MOVQ	R0,EMB$Q_DV_IOSB(R2)	; INSERT I/O STATUS

	JSB	G^ERL$RELEASEMB		; RELEASE ERROR MESSAGE BUFFER

50$:	POPL	UCB$L_IRP(R5)		; RESTORE THIS LOCATION
	POPR	#^M<R0,R1,R2>
	RSB

	.SBTTL	LA_REGDUMP - REGISTER DUMP ROUTINE
;++
; FUNCTIONAL DESCRIPTION
;
;	THIS ROUTINE WRITES THE SAVED REGISTERS INTO A BUFFER.  IT IS
;	CALLED FROM THE ERROR LOGGING ROUTINE AND THE DIAGNOSTIC BUFFER
;	FILL ROUTINE.
;
; CALLING SEQUENCE:
;
;	BSBW	LA_REGDUMP
;
; INPUT PARAMETERS:
;
;	R0	ADDRESS OF REGISTER SAVE BUFFER
;	R5	ADDRESS OF UCB
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R1,R2 ARE NOT PRESERVED
;--

LA_REGDUMP:
	MOVL	#6,(R0)+		; INSERT NUMBER OF REGISTERS INTO BFR
	MOVAL	UCB$L_REGSAVE(R5),R1	; GET ADDRESS OF SAVE AREA
	MOVL	#4,R2			; NUMBER OF LPA-11 REGISTERS
10$:	MOVZWL	(R1)+,(R0)+		; COPY INTO BUFFER
	SOBGTR	R2,10$			; LOOP BACK

	MOVQ	(R1),(R0)		; COPY DATAPATH NUMBER AND REGISTER
	RSB


	.SBTTL	CANCEL_IO - CANCEL I/O

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE PERFORMS THE CANCEL I/O FUNCTION.  ONLY PACKETS
;	THAT HAVE A MATCHING CHANNEL INDEX AND PID ARE CANCELED.  FIRST, THE
;	CURRENT PACKET (IF THERE IS ONE) IS CANCELED BY SETTING THE CANCEL I/O
;	BIT IN THE UCB.  THEN ANY PACKETS ON THE INPUT QUEUE ARE CANCELED
;	BY SENDING THEM TO REQ_COMPLETE WITH A STATUS OF SS$_CANCEL.  THE
;	ONLY EXCEPTION IS THAT STOP QIO'S ARE NOT CANCELED.  FINALLY,
;	ONGOING DATA TRANSFERS ARE CANCELED BY SENDING THEM TO QUEUE_STOP_REQ
;	WITH A STATUS OF SS$_ABORT.
;
; CALLING SEQUENCE:
;
;	BSBW/B
;
; INPUT PARAMETERS:
;
;	R2	CHANNEL INDEX
;	R3	POINTER TO CURRENT I/O PACKET
;	R4	PCB ADDRESS
;	R5	POINTER TO UCB
;
; OUTPUT PARAMETERS:
;
;	NONE
;--

CANCEL_IO:
	PUSHR	#^M<R2,R3,R4,R6,R7>
	MOVL	R2,R7			; CHANNEL INDEX
	MOVL	PCB$L_PID(R4),R4	; PUT PID IN R4

	; FIRST CANCEL CURRENT I/O PACKET IF THERE IS ONE
	TSTL	R3			; POINTER TO CURRENT PACKET
	BEQL	10$			; NO CURRENT PACKET
	BSBB	CANCELCK		; CHECK CHANNEL AND PID
	BNEQ	10$			; NOT A MATCH
	BISW	#UCB$M_CANCEL,UCB$W_STS(R5)  ; SET CANCEL BIT

10$:	; NOW CANCEL THE PACKETS ON THE INPUT QUEUE
	MOVZWL	#SS$_CANCEL,R0		; STATUS
	CLRL	R1
	MOVAB	UCB$L_INQFL(R5),R3	; GET POINTER TO QUEUE HEAD
	MOVL	R3,R6			; SAVE POINTER TO QUEUE HEAD

20$:	; EXAMINE NEXT PACKET IN QUEUE
	MOVL	IRP$L_IOQFL(R3),R3	; GET POINTER TO NEXT PACKET
	CMPL	R3,R6			; REACHED END OF QUEUE YET?
	BEQL	30$			; YES, DONE WITH THIS PHASE
	BSBB	CANCELCK		; CHECK CHANNEL AND PID
	BNEQ	20$			; NOT A MATCH, GET NEXT PACKET
	CMPB	#IO$_STOP,IRP$W_FUNC(R3)  ; DON'T CANCEL STOP REQUESTS
	BEQL	20$			; IT'S A STOP.  GET NEXT PACKET
	MOVL	IRP$L_IOQBL(R3),R2	; HAVE A PACKET TO REMOVE.  BACK UP
	REMQUE	@IRP$L_IOQFL(R2),R3	; REMOVE PACKET FROM QUEUE
	BSBW	REQ_COMPLETE		; SEND PACKET TO REQUEST COMPLETE
	MOVL	R2,R3
	BRB	20$			; GET NEXT PACKET

30$:	; NOW STOP ANY MATCHING DATA TRANSFER REQUESTS
	MOVZWL	#SS$_ABORT,R0		; STATUS
	CLRL	R2

40$:	; EXAMINE NEXT ENTRY IN REQUEST LIST
	MOVL	UCB$L_RQLIST(R5)[R2],R3  ; GET POINTER TO PACKET
	BEQL	50$			; EMPTY SLOT
	BSBB	CANCELCK		; CHECK CHANNEL AND PID
	BNEQ	50$			; NOT A MATCH
	BSBW	QUEUE_STOP_REQ		; QUEUE A STOP REQUEST
50$:	AOBLSS	#8,R2,40$		; REPEAT FOR ALL 8 REQUESTS

	POPR	#^M<R2,R3,R4,R6,R7>
	RSB




; LOCAL SUBROUTINE TO CHECK FOR MATCHING CHANNEL AND PID
;
; INPUT:
;	R3	POINTS TO I/O PACKET
;	R4	CONTAINS PID
;	R7	CONTAINS CHANNEL INDEX
; OUTPUT:
;	Z BIT	IS SET IF BOTH MATCH, CLEARED OTHERWISE

CANCELCK:
	CMPL	IRP$L_PID(R3),R4	; CHECK PID
	BNEQ	10$			; NO MATCH
	CMPW	IRP$W_CHAN(R3),R7	; CHECK CHANNEL AND SET OR CLEAR Z BIT
10$:	RSB

	.SBTTL	COMPLETE_ALL - COMPLETE ALL DATA TRANSFER REQUESTS

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE GOES THROUGH THE USER TABLE SENDING ALL CURRENT
;	DATA TRANSFER REQUESTS TO REQ_COMPLETE.
;
; CALLING SEQUENCE:
;
;	BSBW	COMPLETE_ALL
;
; INPUT PARAMETERS:
;
;	R0	FIRST LONGWORD OF I/O STATUS BLOCK
;	R1	SECOND LONGWORD OF I/O STATUS BLOCK
;	R5	ADDRESS OF UCB
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R2,R3 ARE NOT SAVED
;--

COMPLETE_ALL:

	CLRL	R2			; INITIALIZE INDEX INTO REQUEST LIST

20$:	; DO NEXT ONE IN REQUEST LIST
	MOVL	UCB$L_RQLIST(R5)[R2],R3	; GET POINTER TO I/O PACKET
	BEQL	30$			; NO REQUEST IN THIS SLOT
	CLRL	UCB$L_RQLIST(R5)[R2]	; CLEAR SLOT
	BSBW	REQ_COMPLETE		; SEND IT TO REQUEST COMPLETE
30$:	AOBLSS	#8,R2,20$		; GO BACK FOR NEXT
	RSB

	.SBTTL	UNIT_INIT - LPA-11 UNIT INITIALIZATION
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS ENTERED WHEN THE DRIVER IS LOADED AND ON POWER
;	RECOVERY.  ON DRIVER LOAD IT INITIALIZES THE UCB, OPTIONALLY
;	PREALLOCATES MAP REGISTERS, AND ALLOCATES AND LOADS MAP REGISTERS
;	TO PERMANENTLY MAP THE RDA IN THE UCB.  ON POWER RECOVERY, IT
;	CLEARS THE MICROCODE VALID BIT, RELOADS THE MAP REGISTERS THAT
;	MAP THE RDA IN THE UCB, AND THEN FORKS TO COMPLETE ALL ACTIVE
;	REQUESTS WITH A STATUS OF SS$_POWERFAIL.
;
; CALLING SEQUENCE:
;
;	JSB 	UNIT_INIT
;
; INPUT PARAMETERS:
;
;	R5	ADDRESS OF UCB
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0 - R4 ARE NOT PRESERVED
;--

UNIT_INIT:
	MOVL	UCB$L_CRB(R5),R1	; GET POINTER TO CRB

	; DETERMINE IF THIS IS INITIAL LOADING OR POWER RECOVERY
	BBS	#UCB$V_POWER,UCB$W_STS(R5),60$	; BRANCH IF POWER RECOVERY
;
;	D R I V E R   L O A D
;
	; INITIALIZE INPUT QUEUE
	MOVAL	UCB$L_INQFL(R5),UCB$L_INQFL(R5)
	MOVAL	UCB$L_INQFL(R5),UCB$L_INQBL(R5)

	; MAKE UCB OWNER OF IDB
	MOVL	CRB$L_INTD+VEC$L_IDB(R1),R0  ; GET POINTER TO IDB
	MOVL	R5,IDB$L_OWNER(R0)	; MAKE UCB OWNER OF IDB

	; OPTIONALLY PREALLOCATE MAP REGISTERS
	MOVZBL	G^IOC$GW_LAMAPREG,R3	; NUM. TO PREALLOCATE (SYSGEN PARAM.)
	BEQL	20$			; DON'T PREALLOCATE
	CMPW	R3,#254			; Prevent allocating more than 254.
	BLEQ	10$			; LEQ implies we are OK.
	MOVZWL	#254,R3			; Else reduce request to 254 registers.
10$:
	JSB	G^IOC$ALOUBMAPRMN	; Permanently allocate specified number.
	BLBC	R0,50$			; ERROR - DIDN'T ALLOCATE
	MOVL	UCB$L_CRB(R5),R1	; Refresh R1 => CRB.
	BICW	#VEC$M_MAPLOCK,-	; Undo permanent bit set by IOC$ALOUBMAPRMN.
		CRB$L_INTD+VEC$W_MAPREG(R1)
	MOVL	CRB$L_INTD+VEC$W_MAPREG(R1),-	; SAVE INFO. ON MAP REGISTERS
		UCB$L_PREALLOC(R5)		; ALLOCATED

	; NOW MARK IN UCB BITMAP AS AVAILABLE, THE MAP REGISTERS ALLOCATED
	MCOML	#0,R0			; BITMAP PATTERN (1 MEANS AVAILABLE)
	MOVZWL	UCB$L_PREALLOC(R5),R4	; R4 contains starting map register #
	BSBW	ALT_LOCALBITMAP		; ALTER MAP

20$:	; ALLOCATE AND LOAD MAP REGISTERS TO PERMANENTLY MAP RDA IN UCB
	BSBB	LOADUCB			; LOAD BOFF, BCNT, AND SVAPTE IN UCB
	BSBW	SETMAPREG		; REQUEST AND LOAD UBA MAP REGISTERS
	BLBC	R0,50$			; ALLOCATION FAILURE
	MOVL	CRB$L_INTD+VEC$W_MAPREG(R1),-  ; SAVE ALLOCATED MAP REGISTER
		UCB$L_RDAMR(R5)		; INFO. IN UCB
	MOVL	R2,UCB$L_RDABA(R5)	; UNIBUS ADDRESS OF RDA
	BISW	#UCB$M_ONLINE,UCB$W_STS(R5)	; SET UNIT ONLINE
50$:	RSB


;
;	P O W E R   R E C O V E R Y
;
60$:	BICL	#LA$M_MCVALID,UCB$L_DEVDEPEND(R5)  ; CLEAR MICROCODE VALID
	BISW	#UCB$M_ONLINE,UCB$W_STS(R5)	; SET UNIT ONLINE

	; RELOAD UBA MAP REGISTERS TO MAP RDA IN UCB
	BSBB	LOADUCB			; LOAD BCNT, BOFF, AND SVAPTE IN UCB
	MOVL	UCB$L_RDAMR(R5),-	; LOAD MAPREG, NUMREG, AND DATAPATH
		CRB$L_INTD+VEC$W_MAPREG(R1)	; IN CRB
	JSB	G^IOC$LOADUBAMAP		; LOAD MAP REGISTERS

	; FORK TO COMPLETE ALL ACTIVE REQUESTS
	TSTL	UCB$L_FORKP(R5)		; INTERLOCK AGAINST MULTIPLE PWR FAILS
	BNEQ	90$			; IT'S ALREADY QUEUED!
	MOVAL	UCB$L_FORKP(R5),R5	; POINT TO FORK BLOCK
	FORK
	MOVAL	-UCB$L_FORKP(R5),R5	; RESTORE POINTER TO UCB
	CLRL	UCB$L_FORKP(R5)		; INDICATE THAT FORK BLOCK IS AVAILABLE
	MOVZWL	#SS$_POWERFAIL,R0	; RETURN STATUS
	CLRL	R1
	BSBW	COMPLETE_ALL		; COMPLETE ALL REQUESTS
90$:	RSB



	; LOCAL SUBROUTINE TO LOAD BCNT, BOFF, AND SVAPTE FIELDS IN
	; UCB WITH VALUES WHICH DESCRIBE UCB$W_RDA

LOADUCB:
	MOVW	#58,UCB$W_BCNT(R5)	; SIZE OF RDA
	MOVAW	UCB$W_RDA(R5),R0	; GET ADDRESS OF RDA

	ASSUME	VA$S_BYTE EQ 9
	BICW3	#^XFE00,R0,UCB$W_BOFF(R5)  ;  INSERT BYTE OFFSET IN PAGE
	EXTZV	#VA$V_VPN,#VA$S_VPN,R0,R0  ; GET VIRTUAL PAGE #
	MOVL	G^MMG$GL_SPTBASE,R2	; GET ADDRESS OF SYSTEM PAGE TABLE
	MOVAL	(R2)[R0],UCB$L_SVAPTE(R5)  ; STORE SVA OF PTE FOR RDA
	RSB



LA_END:					; ADDRESS OF LAST LOCATION IN DRIVER




	.END
