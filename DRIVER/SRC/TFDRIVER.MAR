	.TITLE	TFDRIVER - TM78/TU78 MAGTAPE DRIVER
	.IDENT	'V03-002'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; Robert Rappaport  29-February-1980
;
; MODIFIED BY:
;
;	V03-002	RLVV3A1		Robert L. Rappaport	20-Apr-1982
;		Fixed bug reported in QAR 542 wherein a SPACERECORD
;		operation initiated when the tape is positioned between
;		adajacent tape marks.  Bug returned number of records
;		skippped as "1" instead of "0". Also corrected recording
;		of previous tape mark position in this case.
;
;	V03-001	RLRV3A0		Robert L. Rappaport	12-Mar-1982
;		Corrected two problems. First, in several places added
;		code to mark UCB$L_DEVDEPEND bit MT$M_BOT set when
;		we are at BOT.  Second, added code to prevent issuing
;		of multiple TMCLRs.  This fix makes use of CRB$L_AUXSTRUC
;		as the field in which we save the value of EXE$GL_ABSTIM
;		at the time of the last TMCLR.  TFDRIVER will refuse to
;		do a TMCLR if less than 10 minutes (10*60 seconds) have
;		gone by since then.
;
;	V02-015	RLRASYN		Robert L. Rappaport		15-Feb-1982
;		Corrected bug triggered by getting an asynchronous FAULT B
;		interrupt while in the middle of handling a previous one.
;		Bug caused double forking and resetting of SUBSTACK while
;		the SUBSTACK was in use.  Bug was in FAULT_INTERRUPT and
;		the error was that UCB$M_MF_UCBBUSY was being set unequivo-
;		cally.  Changed BISW #UCB$M_MF_UCBBUSY to
;		BBSS #UCB$V_MF_UCBBUSY.
;
;	V02-014	RLRLGSFT	Robert L. Rappaport		29-Dec-1981
;		Added support to allow user settable enabling and disabling
;		of the logging of SOFT ERRORS.  In SET MODE we test for the
;		presence of the new MT$V_LOGSOFTOG toggle flag and if it is
;		set we reverse the polarity of the permanent MT$M_LOGSOFT
;		bit in UCB$L_DEVDEPEND.  Also in DEVICE_ERROR, if the error
;		being logged is a SOFT ERROR and the MT$V_LOGSOFT flag is
;		clear in UCB$L_DEVDEPEND, then the error is NOT logged.
;
;	V02-013	RLRAVAIL	Robert L. Rappaport		28-Dec-1981
;		Added support for IO$_AVAILABLE function which is in effect
;		a REWIND (NOWAIT) that also clears the UCB$M_VALID bit in
;		UCB$W_STS.
;
;	V02-012	RLR0011		Robert L. Rappaport		20-Nov-1981
;		Fixed double forking bug by setting of UCB$M_MF_UCBFREE
;		in FUNCTION_EXIT only while interrupts are disabled.
;
;	V02-011	RLR0010		Robert L. Rappaport		14-Sep-1981
;		Removed temporary code in ISSUE_TMCLR and inserted call
;		to ERL$DEVICEATTN.
;
;	V02-010	RLR0009		Robert L. Rappaport		20-July-1981
;		Fixed ASSUME as to offset of UCB$L_MF_RECORD so as to
;		be independent of the length of the basic UCB.  I.e. the
;		assumption is now relative to the beginning of the device
;		specific part of the UCB.
;
;	V02-009	RLR0008		Robert L. Rappaport		24-June-1981
;		Fixed assume as to offset of UCB$L_MF_RECORD so as to
;		conform to new length of basic UCB.
;
;	V02-008	RLR0007		Robert L. Rappaport		29-May-1981
;		Fixed bug that prevented call to DEVICE_ERROR after
;		WRITE TAPE MARK function.  Also defined bit in DEVSTS that
;		signals DEVICE_ERROR to not decrement UCB$B_ERTCNT for
;		soft errors (i.e. errors that give a DONE status but report
;		some recovered condition).
;
;	V02-007	RLRPWRCN	Robert L. Rappaport		1-April-1981
;		Added code to allow I/O CANCEL to succeed if current
;		operation is stalled while the DRIVER is repositioning
;		the tape following POWERFAIL recovery.
;	V02-006	RLR0006		Robert L. Rappaport		17-Feb-1981
;		Capture EXTENDED SENSE on HIC_DONE interrupts with
;		non-zero failure codes.
;
;	V02-005	RLR0005		Robert L. Rappaport		4-Dec-1980
;		On IO$_SKIPRECORD operations that end due to encountering
;		a tape mark, increment by one, the count of records skipped
;		returned in the I/O status block, so as to include the
;		tape mark as a record skipped.
;	V02-004	RLR0004		Robert L. Rappaport		20-Nov-1980
;		Increased minimum timeout for any operation to 5 seconds.
;
;	V02-003	RLR0003		Robert L. Rappaport		31-OCT-1980
;		Corrected bug in REWIND_ROUTINE which failed to cleanup
;		the SUBSTACK when the error exit was taken from an
;		invocation of the EX_NDT_CMD macro.
;
;	V02-002	RLR0002		Robert L. Rappaport		23-SEP-1980
;		Increased timeout values for REWIND, SPACE and DSE.
;
;	V02-001	RLR0001		Robert L. Rappaport		2-SEP-1980
;		1. Fixed minor problem in SKIP FILE and SKIP RECORD functions
;		that expected a long word count instead of word count in a
;		long word field.
;		2. Fixed PACKACK (SENSEMODE,SENSECHAR, DRVCLR, NOP) to return
;		SS$_MEDOFL if no tape physically mounted.
;		3. Fixed REWINDOFF (UNLOAD) to clear volume valid.
;		4. Also eliminated IO$_DSE explicit definition.
;
; TM78/TU78 MAGTAPE DRIVER
;
;
; MACRO LIBRARY CALLS
;

	$ADPDEF				;Define ADP offsets.
	$CRBDEF				;Define CRB offsets
	$DDBDEF				;Define DDB offsets
	$DEVDEF				;Define DEVICE CHARACTERISTICS bits
	$DPTDEF				;Define DPT offsets
	$EMBDEF				;Define EMB offsets
	$IDBDEF				;Define IDB offsets
	$IODEF				;Define I/O FUNCTION codes
	$IRPDEF				;Define IRP offsets
	$MBADEF				;Define MBA REGISTER offsets
	$MTDEF				;Define MAGTAPE STATUS bits
	$UCBDEF				;Define UCB offsets
	$VECDEF				;Define INTERRUPT DISPATCH VECTOR offsets
	$WCBDEF				;Define WCB offsets

;
;
; Local Macros
;

;
; SUBSAVE - macro to save the return point of a subroutine in the SUBSTACK
;	located in the UCB.  The SUBSTACK is a mechanism that allows for
;	saving several nested return points in a context where data cannot
;	be left on the normal stack;  such as when IOFORKs or WFIKPCH macros
;	are executed.  The SUBSTACK is implemented by allocating an array of
;	longwords in the UCB known as UCB$L_MF_SUBSTACK and by also providing
;	another longword in the UCB known as UCB$L_MF_SUBSP which is used to
;	point to the next available longword in the SUBSTACK array.  At
;	STARTIO time we initialize UCB$L_SUBSP to point to the base of this
;	array and from then on the SUBSAVE, SUBRETURN, SUBPUSH and SUBPOP
;	macro invocations keep this pointer upto date.
;

	.MACRO	SUBSAVE
	POPL	@UCB$L_MF_SUBSP(R5)	; Save return on SUBSTACK.
	ADDL	#4,UCB$L_MF_SUBSP(R5)	; Update SUBSTACK pointer.
	.ENDM	SUBSAVE

;
; SUBRETURN - macro to pop the next value off the SUBSTACK and return control
;	to this address.
;

	.MACRO	SUBRETURN
	SUBL	#4,UCB$L_MF_SUBSP(R5)	; Set SUBSTACK ptr to last used entry.
	PUSHL	@UCB$L_MF_SUBSP(R5)	; Pop return from SUBSTACK to stack.
	RSB				; Return to caller.
	.ENDM	SUBRETURN


;
; SUBPUSH - macro to push upto ten LONGWORDs onto the SUBSTACK.
;

	.MACRO	SUBPUSH LW0,LW1,LW2,LW3,LW4,LW5,LW6,LW7,LW8,LW9
	.NARG	..X..
..Y..=0
	.IRP	LONGWORD,<LW0,LW1,LW2,LW3,LW4,LW5,LW6,LW7,LW8,LW9>
	  .IF	LT	..Y..-..X..		; Do only for explicit args.
..Y..=..Y..+1
	    .IF	NOT_BLANK	LONGWORD
		MOVL	LONGWORD,@UCB$L_MF_SUBSP(R5)	; Move value to SUBSTACK
	    .IFF
		CLRL	@UCB$L_MF_SUBSP(R5)	; Clear SUBSTACK entry.
	    .ENDC

	    ADDL #4,UCB$L_MF_SUBSP(R5)		; Update SUBSTACK pointer.
	  .ENDC
	.ENDR
	.ENDM	SUBPUSH

;
; SUBPOP - macro to pop upto ten LONGWORD values off the SUBSTACK.
;

	.MACRO	SUBPOP	LW0,LW1,LW2,LW3,LW4,LW5,LW6,LW7,LW8,LW9
	.NARG	..X..
..Y..=0
	.IRP	LONGWORD,<LW0,LW1,LW2,LW3,LW4,LW5,LW6,LW7,LW8,LW9>
	  .IF	LT	..Y..-..X..		; Do only for explicit args.
..Y..=..Y..+1
	    SUBL #4,UCB$L_MF_SUBSP(R5)		; Update SUBSTACK pointer.
	    .IF	NOT_BLANK	LONGWORD
		MOVL	@UCB$L_MF_SUBSP(R5),LONGWORD	; Move value from SUBSTACK
	    .ENDC
	.ENDR
	.ENDM	SUBPOP

;
; REWIND - macro to invoke REWIND_ROUTINE.  Invoked in normal START_REWIND
;	logic and also in POWERFAIL_TIMEOUT routine.  The macro prepares a
;	call to REWIND_ROUTINE by placing the needed arguments in R0 and R1.
;	The calling sequence provides for a REWIND command (be it UNLOAD or
;	REWIND) to be passed in R0, and a bitmask to be passed in R1.  The
;	only bit of interest in R1 is IO$M_NOWAIT, which instructs REWIND_ROUTINE
;	as to whether it should wait for the rewind to terminate.
;	It also provides for an error return.
;

	.MACRO	REWIND	CMD,WAIT,ERROR_LABEL
	.IF	B	CMD
		MOVZBL	#F_REWIND!GO_BIT,R0	; If no CMD specified, assume REWIND
	.IFF
		.IF	DIFFERENT	R0,<CMD>
			MOVZBL	CMD,R0		; If specified, and different from
		.ENDC				;  R0, then move it to R0.
	.ENDC

	.IF	IDENTICAL	YES,<WAIT>
		CLRL	R1			; Clear IO$M_NOWAIT bit in R1.
	.IFF
		.IF	IDENTICAL	NO,<WAIT>
			MOVZWL	#IO$M_NOWAIT,R1	; Set IO$M_NOWAIT bit in R1.
		.IFF
			.IF	DIFFERENT R1,<WAIT>
				MOVZWL	WAIT,R1	; Move specified mask to R1.
			.ENDC
		.ENDC
	.ENDC

	BSBW	REWIND_ROUTINE			; Call REWIND_ROUTINE.
	.WORD	ERROR_LABEL-.-2			; Relative address of ERROR_LABEL.
	.ENDM	REWIND

;
; Two macros to help coordinate with asynchronous "B" type fault attention
;	interrupts and the actions we take as a result of them.  TEST_TMRDY
;	is invoked prior to loading final device registers and setting the
;	GO bit.  POST_TEST_TMRDY is invoked after awakening from a WFIKPCH.
;	Briefly they test to make sure nothing horrible has happened to the
;	TM78 controller.  If either finds a problem, it branches to
;	a special piece of code which tries to recover as best it can.
;

	.MACRO	PRIOR_TEST_TMRDY	?L0
	BITW	#UCB$M_MF_TMRDY!-		; Is TMRDY or an ATTN
		 UCB$M_MF_ATTN,-		;  pending?
		UCB$W_DEVSTS(R5)
	BEQL	L0				; If NOT, branch around.
	BRW	TM78_NOTREADY_PRIOR
L0:
	.ENDM	PRIOR_TEST_TMRDY

	.MACRO	POST_TEST_TMRDY		?L0
	BITW	#UCB$M_MF_TMRDY!-		; Is TMRDY or an ATTN
		 UCB$M_MF_ATTN,-		;  pending?
		UCB$W_DEVSTS(R5)
	BEQL	L0				; If NOT, branch around.
	BRW	TM78_NOTREADY_POST
L0:
	.ENDM	POST_TEST_TMRDY

;
; EX_NDT_CMD - Macro to EXECUTE a NDT command.
;	Macro accepts four parameters:
;		1. CMD - the symbolic name of the NDT command.
;		2. REPEAT - the repeat count to be loaded in the register.
;		3. TIMEOUT - the number of seconds to allow for TIMEOUT for
;			this command.
;		4. ERROR_LABEL - the label to which control should be
;			transferred in the event a call to TIMEOUT_POWERFAIL
;			should experience return.
;
;	The macro loads UCB$W_MF_NDTCR with the template command including
;	the repeat count.  It also loads UCB$L_MF_TIMOUT with the
;	value passed as the TIMEOUT parameter.  It then calls the common
;	NDT command executor subroutine NDT_EXECUTOR.
;

	.MACRO	EX_NDT_CMD	CMD,REPEAT,TIMEOUT,ERROR_LABEL
	.NTYPE	.XX.,CMD		; Determine if operand is register.
.XX.=.XX.@-4&^XF
	.IF	EQUAL	.XX.-5		; If it is a register then...

		MOVZBW	CMD,-		; Move command code and GO_BIT from register
			UCB$W_MF_NDTCR(R5)	;  to NDT command template in UCB.
	.IFF				; If operand is NOT a register then...
		MOVZBW	#F_'CMD'!GO_BIT,-	; Move literal command code + GO_BIT
			UCB$W_MF_NDTCR(R5)	;  to NDT command template in UCB.
	.ENDC
	.IF	NB	REPEAT		; Only if we have an explicit REPEAT.
	ASSUME	MF_NDT0_V_CCNT  EQ  8
	ASSUME	MF_NDT0_S_CCNT  EQ  8
	MOVB	REPEAT,-
		UCB$W_MF_NDTCR+1(R5)	; Move explicit REPEAT count to template.
	.ENDC

	.IF	NB	TIMEOUT		; Only assemble following if TIMEOUT 
					;  is specified.
	MOVL	TIMEOUT,-
		UCB$L_MF_TIMOUT(R5)	; Remember TIMEOUT spec in UCB.
	.ENDC

	BSBW	NDT_EXECUTOR		; Call common NDT Executor subroutine.
	.WORD	ERROR_LABEL-.-2		; Relative address of ERROR_LABEL.
	.ENDM	EX_NDT_CMD


	$DEFINI	TAT		; Transfer Action Table entry layout.

$DEF	TAT_HIC		.BLKB 1	; Hardware Interrupt Code.
$DEF	TAT_SOFT_STAT	.BLKW 1	; Software status returned to user.
$DEF	TAT_DEVDEPEND	.BLKW 1	; Bits to set in UCB$L_DEVDEPEND+2.
$DEF	TAT_FLAGS	.BLKB 1	; Flags that determine actions.

	_VIELD	TAT,0,<-
		<ERRLOG,,M>,-	; If set then we perform error logging.
		<POSITION,,M>,-	; If set then we update UCB$L_MF_RECORD.
		<COUNT,,M>,-	; If set then we return UCB$W_MF_BC in R0.
		<PREVTM,,M>,-	; If set then we update UCB$L_MF_PREVTM.
	>

TAT_LENGTH=.

	$DEFEND	TAT
;
; TAT_ENTRY - macro to declare a Transfer Action Table entry.  These
;	entries serve as a decision table which determines actions to
;	take after executing a data transfer command.  The first
;	byte of the TAT entry contains a possible Hardware Interrupt
;	Code (HIC).  The next word contains the Software status that
;	we return to the user corresponding to this HIC.  The next
;	word contains a bit mask which we OR into the high word of
;	UCB$L_DEVDEPEND when we get this HIC.  Finally the last byte
;	is a bit mask that determines certain actions to take.  Bits
;	defined in this mask determine whether we ERROR LOG the condition;
;	whether we return the byte count of bytes transferred to the user;
;	and whether we update UCB$L_MF_RECORD as a result of this HIC.
;


	.MACRO	TAT_ENTRY	HIC,SOFTWARE_STATUS,-
				DEVDEPEND,ERRLOG,POSITION,COUNT,PREVTM

	.BYTE	HIC		; Hardware Interrupt Code
	.WORD	SOFTWARE_STATUS	; Software status to return to user.

	.IF	NB	DEVDEPEND
		.WORD	DEVDEPEND@-16
	.IFF
		.WORD	0
	.ENDC

	.IF	IDENTICAL	YES,<ERRLOG>
		..XX..=TAT_M_ERRLOG
	.IFF
		..XX..=0
	.ENDC
	.IF	IDENTICAL	YES,<POSITION>
		..YY..=TAT_M_POSITION
	.IFF
		..YY..=0
	.ENDC
	.IF	IDENTICAL	YES,<COUNT>
		..ZZ..=TAT_M_COUNT
	.IFF
		..ZZ..=0
	.ENDC
	.IF	IDENTICAL	YES,<PREVTM>
		..QQ..=TAT_M_PREVTM
	.IFF
		..QQ..=0
	.ENDC

	.BYTE	..XX..!..YY..!..ZZ..!..QQ..
	.ENDM

;
; Expanded opcode macros - Branch word conditional psuedo opcodes.
;

;
; BWNEQ - Branch (word offset) not equal
;

	.MACRO	BWNEQ	DEST,?L1
	BEQL	L1		; Branch around if NOT NEQ.
	BRW	DEST		; Branch to destination if NEQ.
L1:				; Around.
	.ENDM	BWNEQ

;
; BWEQL - Branch (word offset) equal
;

	.MACRO	BWEQL	DEST,?L1
	BNEQ	L1		; Branch around if NOT EQL.
	BRW	DEST		; Branch to destination if EQL.
L1:				; Around.
	.ENDM	BWEQL

;
; BWLSS - Branch (word offset) on less
;

	.MACRO	BWLSS	DEST,?L1
	BGEQ	L1		; Branch around if NOT LSS.
	BRW	DEST		; Branch to destination if LSS.
L1:				; Around.
	.ENDM	BWLSS

;
; BWGEQ - Branch (word offset) greater than or equal
;

	.MACRO	BWGEQ	DEST,?L1
	BLSS	L1		; Branch around if NOT GEQ.
	BRW	DEST		; Branch to destination if GEQ.
L1:				; Around.
	.ENDM	BWGEQ

;
; BWBS - Branch (word offset) bit set.
;

	.MACRO	BWBS	BIT,FIELD,DEST,?L1
	BBC	BIT,FIELD,L1		; Branch around if bit NOT set.
	BRW	DEST			; Branch to destination if bit set.
L1:					; Around.
	.ENDM	BWBS

;
; BWBC - Branch (word offset) bit clear.
;

	.MACRO	BWBC	BIT,FIELD,DEST,?L1
	BBS	BIT,FIELD,L1		; Branch around if bit NOT clear.
	BRW	DEST			; Branch to destination if bit clear.
L1:					; Around.
	.ENDM	BWBC
	.PAGE
	.SBTTL	TM78/TU78 MASSBUS REGISTER OFFSETS

	$DEFINI	MF

$DEF	MF_CS1		.BLKL	1	;DRIVE CONTROL REGISTER
	_VIELD	MF_CS1,0,<-		; DRIVE CONTROL REGISTER BIT DEFINITIONS
		<GO,,M>,-		; GO BIT
		<FCODE,5>,-		; FUNCTION CODE
		<IE,,M>,-		;
		<RDY,,M>,-		;
		<A16,,M>,-		;
		<A17,,M>,-		;
		<PSEL,,M>,-		;
		<DVA,,M>,-		; Device available
		<,1>,-			;
		<MCPE,,M>,-		;
		<TRE,,M>,-		;
		<SC,,M>,-		;
	>				;
$DEF	MF_IS		.BLKL	1	;INTERRUPT STATUS REGISTER.
	_VIELD	MF_IS,0,<-		; Interrupt status dit definitions.
		<DTIC,6>,-		; Data transfer interrupt code.
		<,2>,-			; Reserved bits.
		<DPR,,M>,-		;
		<,1>,-			; Reserved bit.
		<DTFC,6>,-		; Data transfer failure code.
	>
$DEF	MF_TC		.BLKL	1	;TAPE CONTROL REGISTER.
	_VIELD	MF_TC,0,<-		; Tape control bit definitions.
		<CMDADR,2>,-		; CMDADR specifies which tape unit.
		<RC,6,M>,-		; Record count.
		<SC,4>,-		; Skip count.
		<FMT,3>,-		; Format.
		<SER,,M>,-		; Suppress error repositioning.
	>
$DEF	MF_MR1		.BLKL	1	;DIAGNOSTICS/MAINTENANCE REGISTER #1.
$DEF	MF_AB		.BLKL	1	;ATTENTION BIT REGISTER
$DEF	MF_BC		.BLKL	1	;BYTE COUNT REGISTER.
$DEF	MF_DT		.BLKL	1	;DRIVE TYPE REGISTER
	_VIELD	MF_DT,0,<-		; Drive type register field definitions
		<DTN,9,M>,-		; Drive type number.
		<,1>,-			; Reserved bit.
		<,1>,-			; Reserved bit.
		<DMB,,M>,-		; Dual MASSBUS port option if set.
		<7CH,,M>,-		; 7-Channel tape (always 0).
		<MOH,,M>,-		; Moving head (always 0).
		<TAP,,M>,-		; Tape drive (always 1).
		<NSA,,M>,-		; Not sector addressable (always 0).
	>				;
$DEF	MF_DS		.BLKL	1	;DRIVE STATUS REGISTER
	_VIELD	MF_DS,0,<-		; Drive status register bit definitions.
		<,4>,-			; Reserved bits.
		<DSE,,M>,-		; Unit doing erase portion of DSE cmd.
		<MAINT,,M>,-		; Unit is in maintenance mode.
		<SHR,,M>,-		; Unit available to both MASSBUS ports.
		<AVAIL,,M>,-		; Unit available to this MASSBUS.
		<FPT,,M>,-		; Unit is file protected.
		<EOT,,M>,-		; End of tape.
		<BOT,,M>,-		; Beginning of tape.
		<PE,,M>,-		; Unit set for PE (1600 BPI) format.
		<REW,,M>,-		; Rewind is in progress.
		<ONL,,M>,-		; Unit on-line, tape is mounted.
		<PRES,,M>,-		; Unit is powered up.
		<RDY,,M>,-		; Unit ready.
	>				;
$DEF	MF_SN		.BLKL	1	;SERIAL NUMBER REGISTER
$DEF	MF_MR2		.BLKL	1	;DIAGNOSTICS/MAINTENANCE REGISTER #2.
$DEF	MF_MR3		.BLKL	1	;DIAGNOSTICS/MAINTENANCE REGISTER #3.
$DEF	MF_NDTA		.BLKL	1	;NON-DATA TRANSFER ATTENTION REGISTER.
	_VIELD	MF_NDTA,0,<-		; Non-data transfer field definitions.
		<NDIC,6,>,-		; NDT interrupt code.
		<,2>,-			; Reserved bits.
		<ATAD,2>,-		; Attention address (unit #).
		<NDFC,6>,-		; NDT failure code.
	>
$DEF	MF_NDT0		.BLKL	1	;NONDATA TRANSFER CMD REG. (UNIT #0).
	_VIELD	MF_NDT0,0,<-		; Nondata transfer command field defs.
		<GO,,M>,-		; Go bit.
		<FCODE,5>,-		; Function code.
		<,2>,-			; Reserved bits.
		<CCNT,8>,-		; Command count.
	>
$DEF	MF_NDT1		.BLKL	1	;NONDATA TRANSFER CMD REG. (UNIT #1).
	_VIELD	MF_NDT1,0,<-		; Nondata transfer command field defs.
		<GO,,M>,-		; Go bit.
		<FCODE,5>,-		; Function code.
		<,2>,-			; Reserved bits.
		<CCNT,8>,-		; Command count.
	>
$DEF	MF_NDT2		.BLKL	1	;NONDATA TRANSFER CMD REG. (UNIT #2).
	_VIELD	MF_NDT2,0,<-		; Nondata transfer command field defs.
		<GO,,M>,-		; Go bit.
		<FCODE,5>,-		; Function code.
		<,2>,-			; Reserved bits.
		<CCNT,8>,-		; Command count.
	>
$DEF	MF_NDT3		.BLKL	1	;NONDATA TRANSFER CMD REG. (UNIT #3).
	_VIELD	MF_NDT3,0,<-		; Nondata transfer command field defs.
		<GO,,M>,-		; Go bit.
		<FCODE,5>,-		; Function code.
		<,2>,-			; Reserved bits.
		<CCNT,8>,-		; Command count.
	>
$DEF	MF_IA		.BLKL	1	;INTERNAL ADDRESS REGISTER.
$DEF	MF_ID		.BLKL	1	;INTERNAL DATA REGISTER.
	_VIELD	MF_ID,0,<-		; Internal data field definitions.
		<ID,8>,-		; Actual internal data to be sent.
		<HOLD,,M>,-		;
		<HLDA,,M>,-		; (Read-only)
		<EVPAR,,M>,-		;
		<CPE,,M>,-		; (Read only)
		<ILR,,M>,-		; (Read only)
		<MCPE,,M>,-		; (Read only)
		<TMCLR,,M>,-		;
		<TMRDY,,M>,-		; (Read only)
	>

	$DEFEND	MF
	.PAGE
	.SBTTL	TM78/TU78 DEVICE DEPENDENT UNIT CONTROL BLOCK OFFSETS

MAX_SUBSTACK_DEPTH=15

	$DEFINI	UCB,GLOBAL

	$VIELD	UCB,0,<-		;DEVICE DEPENDENT STATUS BITS
		<MF_REWIND,,M>,-	; REWIND IN PROGRESS
		<MF_POWER,,M>,-		; Currently executing in POWERFAIL_TIMEOUT
		<MF_CNCLP,,M>,-		; CANCEL I/O pending.
		<MF_REPOS,,M>,-		; Tape needs repositioning.
		<MF_TMRDY,,M>,-		; TM CLR has been issued; TMRDY pending
		<MF_ATTN,,M>,-		; "B" type fault has occurred; issue
-					;  TMCLR at earliest moment.
		<MF_UCBFREE,,M>,-	; UCB may be used for ASYNCHRONOUS fork.
		<MF_UCBBUSY,,M>,-	; UCB being used for ASYNCHRONOUS fork.
		<MF_SOFT_ERR,,M>,-	; Pass SOFT ERROR flag to DEVICE_ERROR.
		<MF_EXSNS_DONE,,M>,-	; Extended sense already done.
		<MF_OWNPCHN,,M>,-
		<MF_OWNSCHN,,M>,-	; Bits whose value are only of interest
		>			;  to the routine that invokes EXTENDED
					;  SENSE command.  Since this command
					;  requires ownership of the channels,
					;  these bits indicate whether the
					;  channels were owned prior to calling
					;  the routine.  Therefore the
					;  MF_OWNPCHN bit set means that the
					;  primary (i.e. the TM78) channel was
					;  owned by the caller of the routine
					;  and the MF_OWNSCHN bit set means that
					;  the secondary (i.e. MBA) channel was
					;  owned.  Previously owned channels are
					;  not released prior to return.
					; NOTE- TM CLR resets TM78 and is only used
					;  if a FAULT B or an MBA error has occurred

; NOTE - The UCB$M_MF_UCBFREE and UCB$M_MF_UCBBUSY bits in UCB$W_DEVSTS are
;	interpreted in conjunction with the UCB$M_BSY bit in UCB$W_STS.  The
;	UCBFREE bit equal to 1 (i.e. set) implies that no one is currently
;	executing in the context of the UCB between STARTIO and FUNCTION_EXIT.
;	The bit is originally set (to 1) at system init time, reset upon entry
;	to STARTIO and then set again in FUNCTION_EXIT prior to REQCOM.  When
;	set (to 1) it declares to the Interrupt routine that the Interrupt
;	routine CAN do an IOFORK and a call to ISSUE_TMCLR since the UCB is
;	in a state that is guaranteed to not do another IOFORK on top of this
;	one.  When UCBFREE is zero, it declares that an IOFORK may not be
;	issued asynchronously and the Interrupt routine must instead simply
;	set the UCB$M_MF_ATTN in the event of a "B" type fault attention.
;
;	UCB$M_MF_UCBBUSY in UCB$W_DEVSTS is turned on (to 1) by the Interrupt
;	routine when in servicing a "B" type fault, it finds UCBFREE set and
;	therefore decides to take over the fork block in the UCB by issuing
;	an IOFORK.  It sets UCBBUSY to warn a driver process entering STARTIO
;	of the situation.  Such a driver process, upon finding the UCBBUSY bit
;	on, would simply execute an RSB instruction.  The I/O function will
;	be started later when the TMCLR is resolved.
;

	.PAGE

.=UCB$L_DPC+4				;

$DEF	UCB$W_MF_CS1	.BLKW	1	;Setup space for Control register.
$DEF	UCB$W_MF_TC	.BLKW	1	;Saved Tapedrive Control register.
$DEF	UCB$W_MF_TMPLTC	.BLKW	1	;Template Tapedrive Control register.
$DEF	UCB$B_MF_DENSITY
			.BLKB	1	;Current DENSITY of drive.
					; 0=> 1600 BPI - 1 => 6250 BPI
$DEF	UCB$B_MF_RSTCNT	.BLKB	1	; Count of number of times this
					;  I/O function has been restarted.

$DEF	UCB$W_MF_NDTCR	.BLKW	1	; Non-data transfer command word.
					;  Scratch space where we build a
					;  non-data transfer command and count.
$DEF	UCB$W_MF_MAX_REWIND
			.BLKW	1	; Maximum time that a rewind can take
					;  for this unit before a timeout.
$DEF	UCB$L_MF_TIMOUT	.BLKL	1	; Number of seconds for TIMEOUT
					;  parameter to WFIKPCH macro.

$DEF	UCB$L_MF_RECORD	.BLKL	1	; Current tape position -NOTE- this
					;  longword must be located at offset
					;  X^94 in the UCB to remain compatible
					;  with other magtape Device Drivers.

$DEF	UCB$L_MF_ORGPOS	.BLKL	1	; Original value of UCB$L_MF_RECORD at
					;  start of current I/O operation.
					;  Used in POWERFAIL recovery.

$DEF	UCB$L_MF_PREVTM	.BLKL	1	; Position of previous TAPEMARK; used
					;  in forward SKIPFILE and SPACEFILE
					;  operations in detecting consecutive
					;  TAPEMARKS.

$DEF	UCB$L_MF_ORGPTM	.BLKL	1	; Original value of UCB$L_MF_PREVTM at
					;  start of current I/O operation.
					;  Used in POWERFAIL recovery.

$DEF	UCB$L_MF_SVAPTE	.BLKL	1	; Virtual address of the System PTE for
					;  UCB$L_MF_EXSNS.
$DEF	UCB$W_MF_BOFF	.BLKW	1	; Byte offset of UCB$L_MF_EXSNS in its page.
$DEF	UCB$W_MF_BCNT	.BLKW	1	; Count of # of bytes (60) transferred
					;  by an EXTENDED SENSE command.
$DEF	UCB$Q_MF_TEMP	.BLKL	2	; Temporary space used to store UCB$L_SVAPTE
					;  and UCB$W_BOFF during EXTENDED SENSE.

$DEF	UCB$L_MF_SUBSP	.BLKL	1	; SUBSTACK depth indicator (Stack ptr).

$DEF	UCB$L_MF_SUBSTACK		; Space for SUBSTACK array.
			.BLKL	MAX_SUBSTACK_DEPTH

;
; Space to save device registers for error logging.
;

$DEF	UCB$L_MFMBA_CSR	.BLKL	1	;Saved MBA Configuration register.
$DEF	UCB$L_MFMBA_CR	.BLKL	1	;Saved MBA Control register.
$DEF	UCB$L_MFMBA_SR	.BLKL	1	;Saved MBA Status register.
$DEF	UCB$L_MFMBA_VAR	.BLKL	1	;Saved MBA Virtual Address register.
$DEF	UCB$L_MFMBA_BCR	.BLKL	1	;Saved MBA Byte Count Register.
$DEF	UCB$L_MFMBA_FMAP
			.BLKL	1	;Saved MBA Final Map register.
$DEF	UCB$L_MFMBA_PMAP
			.BLKL	1	;Saved MBA Previous Map register.

$DEF	UCB$L_MF_CS1	.BLKL	1	;Saved data transfer Control register.
$DEF	UCB$L_MF_IS	.BLKL	1	;Saved data transfer Interrupt status.
$DEF	UCB$L_MF_TC	.BLKL	1	;Saved data transfer Tape control.
$DEF	UCB$L_MF_MR1	.BLKL	1	;Saved Maintenance Register 1.
$DEF	UCB$L_MF_AB	.BLKL	1	;Saved Attention Bit.
$DEF	UCB$L_MF_BC	.BLKL	1	;Saved data transfer Byte Count reg.
$DEF	UCB$L_MF_DT	.BLKL	1	;Saved Device Type register.
$DEF	UCB$L_MF_DS	.BLKL	1	;Saved Drive Status register.
$DEF	UCB$L_MF_SN	.BLKL	1	;Saved Serial Number register.
$DEF	UCB$L_MF_MR2	.BLKL	1	;saved Maintenance Register 2.
$DEF	UCB$L_MF_MR3	.BLKL	1	;saved Maintenance Register 3.
$DEF	UCB$L_MF_NDTA	.BLKL	1	;Saved Non-Data Transfer Attention reg.
$DEF	UCB$L_MF_NDT0	.BLKL	1	;Saved NDT command register drive 0.
$DEF	UCB$L_MF_NDT1	.BLKL	1	;Saved NDT command register drive 1.
$DEF	UCB$L_MF_NDT2	.BLKL	1	;Saved NDT command register drive 2.
$DEF	UCB$L_MF_NDT3	.BLKL	1	;Saved NDT command register drive 3.
$DEF	UCB$L_MF_ID	.BLKL	1	;Saved Internal Data register.

UCB_TM78REGS_LEN=.-UCB$L_MF_CS1		; Length to store all TM78 registers.

$DEF	UCB$L_MF_CMD	.BLKL	1	;Copy of currently active TM78 COMMAND
					;  (for this UCB) be it NDT or Transfer.
$DEF	UCB$L_MF_NDTA_C	.BLKL	1	; Space to copy contents of UCB$L_MF_NDTA
					;  immediately after wakeup from WFIKPCH
					;  so that we can preserve a stable copy
					;  of the attention data associated with
					;  the interrupt.

$DEF	UCB$L_MF_EXSNS	.BLKL	15	; Space for output of EXTENDED SENSE.

UCB_REGDUMP_LEN=.-UCB$L_MFMBA_CSR	; Length of data to copy to ERROR LOG.
UCB$K_MF_LENGTH=.			; Length of a TU78 UCB.

	$DEFEND	UCB

	ASSUME	UCB$L_MF_RECORD-UCB$L_DPC  EQ  20	; Assure offset conforms
							;  to that of TMDRIVER.

;
; Maximum rewind times for the units that can be on a TM78. For now these
;	are only TU78's.
;

TU78_MAX_REWIND=100		; (2400*12)/440 + slop factor.
TU78_MAX_DSE=350+100		; Approximately 3.5*100 + 100.
TU78_MAX_SPACE=350		; In bizarre situations a tape could have huge
				;  physical records which could mean that the
				;  entire 2400 feet might contain less than
				;  255 records so that the maximum spacing time
				;  must be the time to space the entire tape at
				;  125 IPS.
MAX_RESTARTIO=5			; Maximum number of times to allow RESTARTIO to
				;  be attempted before giving up on the I/O
				;  operation.
MF$K_DENSITY_1600=0		; Value put in UCB$B_MF_DENSITY for 1600 BPI.
MF$K_DENSITY_6250=1		; Value in UCB$B_MF_DENSITY which means 6250 BPI
MINIMUM_TIMEOUT=5		; Generous minimum timeout far TU78 operations.
				;  All data transfer operations and most Non-data
				;  transfer operations specify this amount.
	.PAGE
	.SBTTL	Hardware function and interrupt codes
GO_BIT=1

; Non-data transfer hardware function codes.

F_NOP=1*2		; No-op
F_UNLOAD=2*2		; Unload tape and interrupt immediately
F_REWIND=3*2		; Rewind tape and interrupt after tape motion stops
F_SENSE=4*2		; Put status info into MF_DT, MF_DS and MF_SN registers
			;  NOTE- Status valid only while attention bit is set
F_DSE=5*2		; Erase remainder of tape and rewind
			;  NOTE- Erases at least 10 feet beyond EOT marker
F_WTM_PE=6*2		; Write PE (1600 BPI) tape mark.  NOTE- Recording format
			;  is ignored except when tape is at load point (BOT).
			;  It is specified by the low-order bit of code.
F_WTM_GCR=7*2		; Write GCR (6250 BPI) tape mark.  NOTE- Recording format
			;  is ignored except when tape is at load point (BOT).
			;  It is specified by the low-order bit of code.
F_SP_FWD_REC=8*2	; Space forward record, stop if tape mark
F_SP_REV_REC=9*2	; Space reverse record, stop if tape mark or BOT
F_SP_FWD_FILE=10*2	; Space forward file (to tape mark)
F_SP_REV_FILE=11*2	; Space reverse file (to tape mark)
F_SP_FWD_EITHER=12*2	; Space forward either record or file
F_SP_REV_EITHER=13*2	; Space reverse either record or file
F_ERG_PE=14*2		; Erase three inches of tape, set PE (1600).
			;  NOTE- Recording format is ignored except at BOT.
			;   It is specified by the low-order bit of code.
F_ERG_GCR=15*2		; Erase three inches of tape, set GCR (6250).
			;  NOTE- Recording format is ignored except at BOT.
			;   It is specified by the low-order bit of code.
F_CLOSE_FILE_PE=16*2	; Write 2 tape marks, space reverse 1, set PE.
			;  NOTE- Recording format is ignored except at BOT.
			;   It is specified by the low-order bit of code.
F_CLOSE_FILE_GCR=17*2	; Write 2 tape marks, space reverse 1, set GCR.
			;  NOTE- Recording format is ignored except at BOT.
			;   It is specified by the low-order bit of code.
F_SP_LEOT=18*2		; Space forward until 2 tape marks, space reverse 1
F_SP_FWD_FILE_LEOT=19*2	; Space forward to tape mark, stop if 2 successive
			;  tape marks (LEOT), then space reverse one tape mark.
			;   NOTE- Not to be used after any reverse operation,
			;    or the TM78 may skip over an LEOT located
			;    where direction was reversed.

; Data transfer hardware function codes

F_WRITE_CHECK_FWD=20*2	; Write Check Forward. Tape drive reads a record in the
			;  forward direction while at the same time the MBA
			;  reads a buffer from memory and compares the buffer
			;  to the contents of the record read from tape.

F_WRITE_CHECK_REV=23*2	; Write Check Reverse. Same as previous except the
			;  record is read in the reverse direction and the
			;  buffer contents are compared in the reverse
			;  direction also.

F_WRITE_PE=24*2		; Write PE (1600 BPI) encoded records.  -NOTE- The
			;   recording format is ignored unless the tape is posi-
			;   tioned at the load point.  At load point, the write
			;   command specifies the recording format of the entire tape.
F_WRITE_GCR=25*2	; Write GCR (6250 BPI) encoded records.  -NOTE- The
			;   recording format is ignored unless the tape is posi-
			;   tioned at the load point.  At load point, the write
			;   command specifies the recording format of the entire tape.
F_READ_FWD=28*2		; Read records forward
F_READ_REV=31*2		; Read records reverse
F_EXSNS=29*2		; Extended sense
	.PAGE
; HARDWARE INTERRUPT CODES

;
; Interrupt codes that may result from both data transfer operations and
;	non-data transfer operations.
;

HIC_DONE=1		; Operation completed as expected
HIC_TM=2		; Unexpected tape mark
HIC_BOT=3		; Unexpected beginning of tape
HIC_EOT=4		; Tape is positioned beyond end of tape marker (write)
HIC_FPT=8		; Write was attempted on a file protected tape
HIC_NOT_RDY=9		; TU is on line but tape is rewinding or loading, or
			;  a DSE or rewind is being performed from the other
			;  port
HIC_NOT_AVAIL=10	; TU is not switched to this port, but is on-line
HIC_OFF_LINE=11		; TU is not switched on-line with a tape loaded
HIC_NON_EX=12		; TU does not exist or power is off
HIC_NOT_CAPABLE=13	;  1.  Incorrect I.D. burst
			;  2.  No record or tape mark detected
HIC_BAD_TAPE=23		; Tape position is lost
HIC_TM_FAULT_A=24	; Software (microcode) or TM78 hardware is broken -
			;  see failure code for details
HIC_TU_FAULT_A=25	; Tape unit hardware is broken - see failure code

;
; Interrupt codes which result only from data transfer operations.
;

HIC_LONG_REC=16		; Last record read was longer than BYTE COUNT value,
			;  but was otherwise correctly read.  The tape position
			;  is after the long record.  BYTE COUNT is set to actual
			;  record length.  RECORD COUNT is set to number of
			;  records left.

HIC_SHORT_REC=17	; Last record read was shorter than initial BYTE COUNT
			;  value, but is otherwise correctly in memory.  Tape
			;  position is after the short record.  BYTE COUNT is
			;  set to the actual record length.  RECORD COUNT is
			;  set to the number of records left.

HIC_RETRY=18		; Error, the initial operation should be repeated.
			;  Tape positioned for retry.  BYTE COUNT is set to
			;  its initial value.  RECORD COUNT is set to the number
			;  of records left.

HIC_READ_OPP=19		; Read error.  The initial read should be performed in
			;  the opposite direction.  Tape is positioned after the
			;  bad record.  BYTE COUNT is set to number of bytes to
			;  be read.  RECORD COUNT is set to number of records left.

HIC_UNREADABLE=20	; Read retries have failed to read the record.  Tape is
			;  positioned after the record.  BYTE COUNT is set to
			;  the number of bytes transfered.  RECORD COUNT is set
			;  the number of records left.

HIC_ERROR=21		; An error has occurred which requires a retry, but SER
			;  is set.  (EXCLUDES length errors).  Tape is positioned
			;  after the bad record.  BYTE COUNT is set to the number
			;  of bytes transfered.  RECORD COUNT is set to the number
			;  of records left.

HIC_EOT_ERROR=22	; A write error has occurred beyond the EOT marker, and
			;  SER is set.  Tape is positioned after the bad record.
			;  BYTE COUNT is set to the number of records transferred.
			;  RECORD COUNT is set to the number of records left.

;
; Interrupt codes which result only from non-data transfer operations.
;

HIC_LEOT=5		; Unexpected logical EOT (2 tape marks)
HIC_NOP=6		; No-op completed
HIC_REWINDING=7		; Rewind in progress, done interrupt will follow when
			;  at BOT

;
; TM78 initiated interrupt codes.
;

HIC_ON_LINE=15		; A tape unit has come on-line with a tape loaded, or
			;  a rewind has finished on the other port for the
			;  accessed tape unit.
HIC_TM_FAULT_B=26	; The TM78 is broken.
HIC_TU_FAULT_B=27	; The tape unit is broken.
HIC_MB_FAULT=28		; A MASSBUS error has occurred.
	.PAGE
;
; LOCAL DATA
;
; DRIVER PROLOGUE TABLE
;

	DPTAB	-			;DEFINE DRIVER PROLOGUE TABLE
		END=TF_END,-		;END OF DRIVER
		FLAGS=DPT$M_SUBCNTRL,-	;INDICATE SUBCONTROLLER
		ADAPTER=MBA,-		;ADAPTER TYPE
		UCBSIZE=UCB$K_MF_LENGTH,- ;UCB SIZE
		MAXUNITS=4,-		;TM78 LIMITED TO 4 TU78'S
		NAME=TFDRIVER		;DRIVER NAME
	DPT_STORE INIT			;CONTROL BLOCK INIT VALUES
	DPT_STORE DDB,DDB$L_ACPD,L,<^A\MTA\> ;DEFAULT ACP NAME
	DPT_STORE UCB,UCB$B_FIPL,B,8	;FORK IPL
	DPT_STORE UCB,UCB$L_DEVCHAR,L,-	;DEVICE CHARACTERISTICS
		<DEV$M_FOD-		; FILES ORIENTED
		!DEV$M_DIR-		; DIRECTORY STRUCTURED
		!DEV$M_AVL-		; AVAILABLE
		!DEV$M_ELG-		; ERROR LOGGING ENABLED
		!DEV$M_IDV-		; INPUT DEVICE
		!DEV$M_ODV-		; OUTPUT DEVICE
		!DEV$M_SDI-		; SINGLE DIRECTORY DEVICE
		!DEV$M_SQD>		; SEQUENTIAL DEVICE
	DPT_STORE UCB,UCB$B_DEVCLASS,B,DC$_TAPE ;DEVICE CLASS
	DPT_STORE UCB,UCB$W_DEVBUFSIZ,W,2048 ;DEFAULT BUFFER SIZE
	DPT_STORE UCB,UCB$L_DEVDEPEND,W,<^X4C0> ;DEFAULT TAPE PARAMETERS
	DPT_STORE UCB,UCB$B_DIPL,B,21	;DEVICE IPL
	DPT_STORE UCB,UCB$B_ERTCNT,B,127; Error retry count
	DPT_STORE UCB,UCB$B_ERTMAX,B,127; Maximum error retry
	DPT_STORE REINIT		;CONTROL BLOCK RE-INIT VALUES
	DPT_STORE CRB,CRB$L_INTD+4,D,TF$INT ;INTERRUPT SERVICE ROUTINE ADDRESS
	DPT_STORE CRB,CRB$L_INTD+VEC$L_INITIAL,D,TM78_INIT ;CONTROLLER INIT
	DPT_STORE CRB,CRB$L_INTD+VEC$L_UNITINIT,D,TM78_TXXX_INIT ;UNIT INIT
	DPT_STORE DDB,DDB$L_DDT,D,TF$DDT ;DDT ADDRESS
	DPT_STORE END			;
	.MDELETE DPT_STORE

;
; DRIVER DISPATCH TABLE
;

	DDTAB	TF,-			;DRIVER DISPATCH TABLE
		TF_STARTIO,-		;START I/O OPERATION
		TF_UNSOLNT,-		;UNSOLICITED INTERRUPT
		TF_FUNCTABLE,-		;FUNCTION DECISION TABLE
		TF_CANCELIO,-		;CANCEL I/O ENTRY POINT
		TF_REGDUMP,-		;REGISTER DUMP ROUTINE
		<<UCB_REGDUMP_LEN>+<<3+5+1>*4>>,-	    ;DIAGNOSTIC BUFFER SIZE
		<<UCB_REGDUMP_LEN>+<1*4>+<EMB$L_DV_REGSAV>> ;ERROR BUFFER SIZE

;
; TM78 DRIVE TYPE DESCRIPTOR TABLE
;

TF_DTDESC:				;
	.WORD	^X41			;TU78 125 IPS
	.BYTE	DT$_TU78		;
TF_DTDESCLEN=.-TF_DTDESC		;LENGTH OF DRIVE TYPE DESCRIPTOR
	.WORD	0			;END OF TABLE
	.BLKB	TF_DTDESCLEN		;SPARE DRIVE TYPE SLOT

;
; Format code translation table
;
;	The following table relates software defined tape formats to
;	TM78 specific codes used to realize these formats.  The table
;	contains 16 bytes, one for each of the possible values of the
;	4 bit field which specifies the software format (MT$M_FORMAT).
;	The contents of each byte of the table is the respective code
;	to load into the TM78 register.
;

	ASSUME	MT$S_FORMAT    EQ  4	; Assume a 4 bit field.
	ASSUME	MT$K_DEFAULT   EQ  0	; Assume values defined by STARDEF.MDL
	ASSUME	MT$K_NORMAL11  EQ  12
	ASSUME	MT$K_CORDMP11  EQ  13
	ASSUME	MT$K_NORMAL15  EQ  14

MF$K_FORMAT_NORMAL_11=0		; TM78 code to specify normal 11 tape format.
MF$K_FORMAT_NORMAL_15=1		; TM78 code to specify normal 15 tape format.
MF$K_FORMAT_COMPATIBLE_10=2	; TM78 code to specify PDP 10 tape format.
MF$K_FORMAT_COREDUMP_10=3	; TM78 code to specify PDP 10 coredump format.
MF$K_FORMAT_HI_DENS_COMPAT_10=4	; TM78 code to specify high density PDP 10 format.
MF$K_FORMAT_IMAGE=5		; TM78 code to specify IMAGE tape format.
MF$K_FORMAT_HI_DENS_DUMP_10=6	; TM78 code to specify high density PDP 10 dump format.
FORMAT_TABLE:
	.BYTE	MF$K_FORMAT_NORMAL_11	; Defaults to NORMAL11.
	.BYTE	MF$K_FORMAT_NORMAL_11	; Illegal value defaults to NORMAL11.
	.BYTE	MF$K_FORMAT_NORMAL_11	; Illegal value defaults to NORMAL11.
	.BYTE	MF$K_FORMAT_NORMAL_11	; Illegal value defaults to NORMAL11.
	.BYTE	MF$K_FORMAT_NORMAL_11	; Illegal value defaults to NORMAL11.
	.BYTE	MF$K_FORMAT_NORMAL_11	; Illegal value defaults to NORMAL11.
	.BYTE	MF$K_FORMAT_NORMAL_11	; Illegal value defaults to NORMAL11.
	.BYTE	MF$K_FORMAT_NORMAL_11	; Illegal value defaults to NORMAL11.
	.BYTE	MF$K_FORMAT_NORMAL_11	; Illegal value defaults to NORMAL11.
	.BYTE	MF$K_FORMAT_NORMAL_11	; Illegal value defaults to NORMAL11.
	.BYTE	MF$K_FORMAT_NORMAL_11	; Illegal value defaults to NORMAL11.
	.BYTE	MF$K_FORMAT_NORMAL_11	; Illegal value defaults to NORMAL11.
	.BYTE	MF$K_FORMAT_NORMAL_11	; NORMAL11.
	.BYTE	MF$K_FORMAT_IMAGE	; CORE-DUMP11 - IMAGE 11
	.BYTE	MF$K_FORMAT_NORMAL_15	; NORMAL15
	.BYTE	MF$K_FORMAT_NORMAL_11	; Illegal value defaults to NORMAL11.
	.PAGE
	.SBTTL	TM78/TU78 FUNCTION DECISION TABLE
;+
; TM78/TU78 FUNCTION DECISION TABLE
;-

TF_FUNCTABLE:				;FUNCTION DECISION TABLE
	FUNCTAB	,-			;LEGAL FUNCTIONS
		<NOP,-			;NO OPERATION
		 UNLOAD,-		;UNLOAD VOLUME
		 SPACERECORD,-		;SPACE RECORDS
		 RECAL,-		;RECALIBRATE (REWIND)
		 DRVCLR,-		;DRIVE CLEAR
		 READPRESET,-		;READ IN PRESET
		 PACKACK,-		;PACK ACKNOWLEDGE
		 ERASETAPE,-		;ERASE TAPE
		 SENSECHAR,-		;SENSE TAPE CHARACTERISTICS
		 SETCHAR,-		;SET CHARACTERISTICS
		 SPACEFILE,-		;SPACE FILE
		 WRITECHECK,-		;WRITE CHECK FORWARD
		 WRITEPBLK,-		;WRITE PHYSICAL BLOCK
		 READPBLK,-		;READ PHYSICAL BLOCK
		 WRITEMARK,-		;WRITE TAPE MARK
		 DSE,-			;ERASE REST OF TAPE & REWIND **NEW FUNCTION
		 AVAILABLE,-		;AVAILABLE (REWIND/NOWAIT CLEAR VALID)
		 READLBLK,-		;READ LOGICAL BLOCK
		 WRITELBLK,-		;WRITE LOGICAL BLOCK
		 SENSEMODE,-		;SENSE TAPE MODE
		 SETMODE,-		;SET MODE
		 REWIND,-		;REWIND
		 REWINDOFF,-		;REWIND AND SET OFFLINE
		 SKIPRECORD,-		;SKIP RECORDS
		 SKIPFILE,-		;SKIP FILES
		 WRITEOF,-		;WRITE END OF FILE
		 READVBLK,-		;READ VIRTUAL BLOCK
		 WRITEVBLK,-		;WRITE VIRTUAL BLOCK
		 ACCESS,-		;ACCESS FILE AND/OR FIND DIRECTORY ENTRY
		 ACPCONTROL,-		;ACP CONTROL FUNCTION
		 CREATE,-		;CREATE FILE AND/OR CREATE DIRECTORY ENTRY
		 DEACCESS,-		;DEACCESS FILE
		 DELETE,-		;DELETE FILE AND/OR DIRECTORY ENTRY
		 MODIFY,-		;MODIFY FILE ATTRIBUTES
		 MOUNT>			;MOUNT VOLUME
	FUNCTAB	,-			;BUFFERED I/O FUNCTIONS
		<NOP,-			;NO OPERATION
		 UNLOAD,-		;UNLOAD VOLUME
		 SPACERECORD,-		;SPACE RECORDS
		 RECAL,-		;RECALIBRATE (REWIND)
		 DRVCLR,-		;DRIVE CLEAR
		 READPRESET,-		;READ IN PRESET
		 PACKACK,-		;PACK ACKNOWLEDGE
		 ERASETAPE,-		;ERASE TAPE
		 SENSECHAR,-		;SENSE CHARACTERISTICS
		 SETCHAR,-		;SET CHARACTERISTICS
		 SPACEFILE,-		;SPACE FILES
		 WRITEMARK,-		;WRITE TAPE MARK
		 DSE,-			;ERASE REST OF TAPE & REWIND **NEW FUNCTION
		 SENSEMODE,-		;SENSE MODE
		 SETMODE,-		;SET MODE
		 REWIND,-		;REWIND
		 REWINDOFF,-		;REWIND AND UNLOAD
		 SKIPRECORD,-		;SKIP RECORDS
		 SKIPFILE,-		;SKIP FILES
		 WRITEOF,-		;WRITE END OF FILE
		 ACCESS,-		;ACCESS FILE AND/OR FIND DIRECTORY ENTRY
		 ACPCONTROL,-		;ACP CONTROL FUNCTION
		 CREATE,-		;CREATE FILE AND/OR CREATE DIRECTORY ENTRY
		 DEACCESS,-		;DEACCESS FILE
		 DELETE,-		;DELETE FILE AND/OR DIRECTORY ENTRY
		 MODIFY,-		;MODIFY FILE ATTRIBUTES
		 MOUNT>			;MOUNT VOLUME
	FUNCTAB	+ACP$READBLK,-		;READ FUNCTIONS
		<READLBLK,-		;READ LOGICAL BLOCK FORWARD
		 READPBLK,-		;READ PHYSICAL BLOCK FORWARD
		 READVBLK>		;READ VIRTUAL BLOCK
	FUNCTAB	+ACP$WRITEBLK,-		;WRITE FUNCTIONS
		<WRITECHECK,-		;WRITE CHECK FORWARD
		 WRITELBLK,-		;WRITE LOGICAL BLOCK
		 WRITEPBLK,-		;WRITE PHYSICAL BLOCK
		 WRITEVBLK>		;WRITE VIRTUAL BLOCK
	FUNCTAB	+ACP$ACCESS,<ACCESS,CREATE> ;ACCESS AND CREATE FILE OR DIRECTORY
	FUNCTAB	+ACP$DEACCESS,<DEACCESS> ;DEACCESS FILE
	FUNCTAB	+ACP$MODIFY,-		;
		<ACPCONTROL,-		;ACP CONTROL FUNCTION
		 DELETE,-		;DELETE FILE OR DIRECTORY ENTRY
		 MODIFY>		;MODIFY FILE ATTRIBUTES
	FUNCTAB	+ACP$MOUNT,<MOUNT>	;MOUNT VOLUME
	FUNCTAB	+MT$CHECK_ACCESS,-	;MAGTAPE CHECK ACCESS FUNCTIONS
		<ERASETAPE,-		;ERASE TAPE
		 WRITEMARK,-		;WRITE TAPE MARK
		 DSE,-			;ERASE REST OF TAPE & REWIND **NEW FUNCTION
		 WRITEOF>		;WRITE END OF FILE
	FUNCTAB	+EXE$ZEROPARM,-		;ZERO PARAMETER FUNCTIONS
		<NOP,-			;NO OPERATION
		 UNLOAD,-		;UNLOAD VOLUME
		 RECAL,-		;RECALIBRATE (REWIND)
		 REWIND,-		;REWIND
		 REWINDOFF,-		;REWIND AND SET OFFLINE
		 DRVCLR,-		;DRIVE CLEAR
		 READPRESET,-		;READ IN PRESET
		 PACKACK,-		;PACK ACKNOWLEDGE
		 ERASETAPE,-		;ERASE TAPE
		 SENSECHAR,-		;SENSE TAPE CHARACTERISTICS
		 SENSEMODE,-		;SENSE TAPE MODE
		 WRITEMARK,-		;WRITE TAPE MARK
		 DSE,-			;ERASE REST OF TAPE & REWIND **NEW FUNCTION
		 AVAILABLE,-		;AVAILABLE (REWIND/NOWAIT CLEAR VALID)
		 WRITEOF>		;WRITE END OF FILE
	FUNCTAB	+EXE$ONEPARM,-		;ONE PARAMETER FUNCTIONS
		<SPACERECORD,-		;SPACE RECORDS
		 SPACEFILE,-		;SPACE FILES
		 SKIPRECORD,-		;SKIP RECORDS
		 SKIPFILE>		;SKIP FILES
	FUNCTAB	+EXE$SETMODE,-		;SET TAPE CHARACTERISTICS
		<SETCHAR,-		;
		 SETMODE>		;
	.PAGE
	.SBTTL	CANCEL I/O ON CHANNEL
;+
; TF_CANCELIO - CANCEL I/O ON CHANNEL
;
; THIS ROUTINE IS CALLED WHEN THE LAST CHANNEL ASSIGNED TO A DEVICE IS DEASSIGNED,
; THE DEVICE IS DEALLOCATED, AND WHEN THE CANCEL I/O ON CHANNEL SYSTEM SERVICE IS
; EXECUTED.
;
; INPUTS:
;
;	R2 = NEGATIVE CHANNEL NUMBER.
;	R3 = ADDRESS OF CURRENT I/O REQUEST PACKET.
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R5 = DEVICE UCB ADDRESS.
;
; OUTPUTS:
;
;	IF THE DEVICE IS CURRENTLY BUSY, DOING A REWIND, AND IN A WAITFOR INTERRUPT
;	STATE, THEN THE REWIND FUNCTION IS CANCELLED.
;-

TF_CANCELIO:				;CANCEL I/O ON CHANNEL
	JSB	G^IOC$CANCELIO		;TEST IF FUNCTION SHOULD BE CANCELLED
	BBC	#UCB$V_CANCEL,-
		UCB$W_STS(R5),30$	;IF CLR, NO CANCEL PENDING
	DSBINT				;DISABLE INTERRUPTS
	BBC	#UCB$V_MF_POWER,-	; See if currently repositioning tape
		UCB$W_DEVSTS(R5),5$	;  due to POWERFAIL.  If NOT, branch around
	BISW	#UCB$M_MF_CNCLP,-	; If SO, set CANCEL PENDING flag on.
		UCB$W_DEVSTS(R5)	;  This bit is needed only if the driver
					;   thread in POWERFAIL is currently
					;   not waiting for an interrupt.  That
					;   would imply that the driver thread
					;   is on a resource wait queue and
					;   would have to abort the operation
					;   itself.

	BITW	#UCB$M_INT!UCB$M_TIM,-
		UCB$W_STS(R5)		; Interrupt or timeout expected?
	BEQL	20$			; If NOT, branch around and let CANCEL
					;  PENDING flag advise repositioning
					;  thread of the need to ABORT operation.

	BICW	#UCB$M_MF_POWER!UCB$M_MF_CNCLP,-
		UCB$W_DEVSTS(R5)	; Here we are awaiting interrupt; so
					;  we can safely kill the driver thread.

	BRB	15$			; Branch around.
5$:
	CMPB	#F_REWIND!GO_BIT,-	; Was last command executed a REWIND
		UCB$L_MF_CMD(R5)
	BEQL	10$			;IF EQL YES
	CMPB	#F_DSE!GO_BIT,-		; Or was it a DSE (ERASE REST OF TAPE
		UCB$L_MF_CMD(R5)	;  AND REWIND) command?
	BEQL	10$			; If EQL yes.
	BBC	#UCB$V_MF_REWIND,-	; Is a REWIND in progress holding up
		UCB$W_DEVSTS(R5),20$	;  current IRP?  If NOT, branch.
10$:	BITW	#UCB$M_INT!UCB$M_TIM,-
		UCB$W_STS(R5)		;INTERRUPT OR TIMEOUT EXPECTED?
	BEQL	20$			;IF EQL NO
15$:
	BICW	#UCB$M_INT!UCB$M_TIM,-
		UCB$W_STS(R5)		;CLEAR INTERRUPT AND TIMEOUT EXPECTED
	BISW	#UCB$M_MF_REWIND,-
		UCB$W_DEVSTS(R5)	;SET REWIND IN PROGRESS
	SETIPL	UCB$B_FIPL(R5)		;LOWER TO FORK LEVEL
	MOVZWL	#SS$_ABORT,R0		;SET ABORT STATUS
	PUSHL	R4			;SAVE CURRENT PROCESS PCB ADDRESS
	BSBW	STSXIT			;FINISH I/O OPERATION
	POPL	R4			;RESTORE CURRENT PROCESS PCB ADDRESS
20$:	ENBINT				;LOWER TO FORK LEVEL
30$:	RSB				;
	.PAGE
	.SBTTL	START I/O OPERATION (and RESTARTIO)
;+
; TF_STARTIO - START I/O OPERATION ON DEVICE UNIT
;
; THIS ENTRY POINT IS ENTERED TO START AN I/O OPERATION ON A DEVICE UNIT.
;
; INPUTS:
;
;	R3 = ADDRESS OF I/O PACKET.
;	R5 = UCB ADDRESS OF DEVICE UNIT.
;
; OUTPUTS:
;
;	FUNCTION DEPENDENT PARAMETERS ARE STORED IN THE DEVICE UCB, THE ERROR
;	RETRY COUNT IS RESET, AND THE FUNCTION IS EXECUTED. AT FUNCTION COMPLETION
;	THE OPERATION IS TERMINATED THROUGH REQUEST COMPLETE.
;-

	.ENABLE	LSB
TF_RESTARTIO:				; Come here to setup registers to
					;  RESTART the current I/O operation.
	INCB	UCB$B_MF_RSTCNT(R5)	; Remember # times restarted.
	MOVL	UCB$L_IRP(R5),R3	; R3 => IRP.
	MOVQ	IRP$L_SVAPTE(R3),-	; Initialize UCB fields
		UCB$L_SVAPTE(R5)
	CMPB	#MAX_RESTARTIO,-	; Prevent endless loop at fork level
		UCB$B_MF_RSTCNT(R5)	;  from hanging system.
	BGEQ	10$			; GEQ implies that we may try again.
	MOVZWL	#SS$_CTRLERR,R0		; Else indicate controller problem.
	BRW	FUNCTION_EXIT		; And terminate.

TF_STARTIO:				;START I/O OPERATION
	CLRB	UCB$B_MF_RSTCNT(R5)	; Clear RESTARTIO count.
10$:
	BICW	#UCB$M_MF_UCBFREE,-	; Indicate that UCB FORK block cannot
		UCB$W_DEVSTS(R5)	;  be used asynchronously for now.
	BBC	#UCB$V_MF_UCBBUSY,-	; If UCB FORK block NOT currently in use
		UCB$W_DEVSTS(R5),20$	;  then branch around to continue.
	RSB				; If FORK block in use, return to caller
20$:
	MOVAB	UCB$L_MF_SUBSTACK(R5),-	; Initialize SUBSTACK pointer to base
		UCB$L_MF_SUBSP(R5)	;  of SUBSTACK array.
	BBC	#UCB$V_MF_ATTN,-	; Bit set implies we must CLEAR the
		UCB$W_DEVSTS(R5),30$	;  TM78.  Clear implies continue.
	BSBW	ISSUE_TMCLR		; Call to clear TM78.
	BLBS	R0,30$			; LBS implies successful TM78 clearing.
	BRW	FUNCTION_EXIT		; If we couldn't reset TM78, exit.
30$:
	BBC	#UCB$V_MF_TMRDY,-	; Bit set implies that we must await
		UCB$W_DEVSTS(R5),40$	;  TM78 coming ready, Clear implies AOK.
	BSBW	AWAIT_TMRDY		; Wait for TM78 to come READY.
40$:
	MOVW	IRP$W_FUNC(R3),-
		UCB$W_FUNC(R5)		; Save function code and modifiers.
	MOVB	UCB$B_ERTMAX(R5),-	; Copy maximum retry count to error
		UCB$B_ERTCNT(R5)	;  retry count.
	PUSHR	#^M<R3,R5>		; Save registers destroyed by MOVC5.
	MOVC5	#0,.,#0,#UCB_REGDUMP_LEN,-
		UCB$L_MFMBA_CSR(R5)	; Clear out Register Dump area in UCB.
	POPR	#^M<R3,R5>		; Restore input registers.

	BICW	#UCB$M_MF_EXSNS_DONE,-	; Clear bit so as to allow EXTENDED
		UCB$W_DEVSTS(R5)	;  SENSE to proceed.
	BICW	#<MT$M_BOT!-		; Clear beginning of tape and,
		  MT$M_EOF!-		;  End of File and
		  MT$M_EOT>@-16,-	;  End of Tape
		UCB$L_DEVDEPEND+2(R5)
	MNEGL	#1,R0			; Prepare to initialize UCB$L_MF_ORGPOS
	MNEGL	#2,R1			;  and UCB$L_MF_ORGPTM with the values
	BBC	#UCB$V_VALID,-		;  in UCB$L_MF_RECORD and UCB$L_MF_PREVTM.
		UCB$W_STS(R5),50$	;  However if invalid, leave them set to
					;  -1 and -2 respectively.
	MOVL	UCB$L_MF_RECORD(R5),R0	; Pickup original position in volume.
	MOVL	UCB$L_MF_PREVTM(R5),R1	; Also position of last TAPEMARK.
50$:	MOVL	R0,UCB$L_MF_ORGPOS(R5)	; Remember original position and
	MOVL	R1,UCB$L_MF_ORGPTM(R5)	;  original previous TAPEMARK.

	BBS	#IRP$V_PHYSIO,-
		IRP$W_STS(R3),60$	;IF SET, PHYSICAL I/O FUNCTION
	BBS	#UCB$V_VALID,-
		UCB$W_STS(R5),60$	;IF SET, VOLUME SOFTWARE VALID
	MOVZWL	#SS$_VOLINV,R0		;SET VOLUME INVALID STATUS
	BRW	FUNCTION_EXIT		;
60$:
	EXTZV	#IRP$V_FCODE,-		; Extract I/O function code and
		#IRP$S_FCODE,-		;  place code into a register that
		IRP$W_FUNC(R3),R4	;  will survive an IOFORK.


	MOVL	UCB$L_CRB(R5),R3		; R3=>TM78-CRB.
	ASSUME	IDB$L_CSR  EQ  0
	MOVL	@CRB$L_INTD+VEC$L_IDB(R3),R3	; R3=>TM78-CSR.

;
; Here we wait if an unfinished REWIND is in progress.
;

70$:
	DSBINT				; Block interrupts
	PRIOR_TEST_TMRDY		; Assure that TM78 ready.

	BBS	#UCB$V_POWER,-
		UCB$W_STS(R5),80$	; Branch if there has been a POWERFAIL
	BBC	#UCB$V_MF_REWIND,-	; Branch around WAIT if NO REWIND in
		UCB$W_DEVSTS(R5),100$	;  progress.
	WFIKPCH	90$,#TU78_MAX_DSE	; Wait for REWIND to finish.
WAITING_FOR_REWIND:			; Label of return point for this WFIKPCH.
	POST_TEST_TMRDY			; Assure that TM78 ready.
	BSBW	TF_UNSOLNT		; Update UCB after REWIND.
	IOFORK
	BRB	70$			; Branch back to test REWIND bit again.

80$:	ENBINT
90$:	SETIPL	UCB$B_FIPL(R5)		; Set to fork IPL.
	BSBW	TIMEOUT_POWERFAIL	; Call to indicate problem.
	BRW	FUNCTION_EXIT		; If we experience return, goto EXIT.
100$:
	ENBINT				; Enable interrupts if REWIND done.

	MOVL	R4,R1			; Copy I/O function code to R1.

; Now we have the I/O function code without modifiers in R1.  We use it to
;	branch to the particular code that handles the function.

	ASSUME	IO$_NOP		EQ   0
	ASSUME	IO$_UNLOAD	EQ   1
	ASSUME	IO$_SPACEFILE	EQ   2
	ASSUME	IO$_RECAL	EQ   3
	ASSUME	IO$_DRVCLR	EQ   4
	ASSUME	IO$_ERASETAPE	EQ   6
	ASSUME	IO$_PACKACK	EQ   8
	ASSUME	IO$_SPACERECORD	EQ   9
	ASSUME	IO$_WRITECHECK	EQ   10
	ASSUME	IO$_WRITEPBLK	EQ   11
	ASSUME	IO$_READPBLK	EQ   12
	ASSUME	IO$_DSE		EQ   21
	ASSUME	IO$_AVAILABLE	EQ   17
	ASSUME	IO$_READPRESET	EQ   25
	ASSUME	IO$_SETCHAR	EQ   26
	ASSUME	IO$_SENSECHAR	EQ   27
	ASSUME	IO$_WRITEMARK	EQ   28
	ASSUME	IO$_WRITELBLK	EQ   32
	ASSUME	IO$_READLBLK	EQ   33
	ASSUME	IO$_REWINDOFF	EQ   34
	ASSUME	IO$_SETMODE	EQ   35
	ASSUME	IO$_REWIND	EQ   36
	ASSUME	IO$_SKIPFILE	EQ   37
	ASSUME	IO$_SKIPRECORD	EQ   38
	ASSUME	IO$_SENSEMODE	EQ   39
	ASSUME	IO$_WRITEOF	EQ   40
	CASE	R1,<-
			START_NOP,-			; 0
			START_UNLOAD,-			; 1
			START_SPACEFILE,-		; 2
			START_RECAL,-			; 3
			START_DRVCLR,-			; 4
				START_NOSUCH,-		; 5
			START_ERASETAPE,-		; 6
				START_NOSUCH,-		; 7
			START_PACKACK,-			; 8
			START_SPACERECORD,-		; 9
			START_WRITECHECK,-		; 10
			START_WRITEPBLK,-		; 11
			START_READPBLK,-		; 12
				START_NOSUCH,-		; 13
				START_NOSUCH,-		; 14
				START_NOSUCH,-		; 15
				START_NOSUCH,-		; 16
			START_AVAILABLE,-		; 17
				START_NOSUCH,-		; 18
				START_NOSUCH,-		; 19
				START_NOSUCH,-		; 20
			START_DSE,-			; 21
				START_NOSUCH,-		; 22
				START_NOSUCH,-		; 23
				START_NOSUCH,-		; 24
			START_READPRESET,-		; 25
			START_SETCHAR,-			; 26
			START_SENSECHAR,-		; 27
			START_WRITEMARK,-		; 28
				START_NOSUCH,-		; 29
				START_NOSUCH,-		; 30
				START_NOSUCH,-		; 31
			START_WRITELBLK,-		; 32
			START_READLBLK,-		; 33
			START_REWINDOFF,-		; 34
			START_SETMODE,-			; 35
			START_REWIND,-			; 36
			START_SKIPFILE,-		; 37
			START_SKIPRECORD,-		; 38
			START_SENSEMODE,-		; 39
			START_WRITEOF,-			; 40
		>
START_NOSUCH:
	MOVZWL	#SS$_ILLIOFUNC,R0
	BRW	STSXIT			; Branch to exit I/O function.
	.DISABLE	LSB
	.PAGE
	.SBTTL	Start NOP, DRVCLR, PACKACK, SENSECHAR or SENSEMODE I/O functions

; START_NOP, START_DRVCLR, PACKACK, SENSECHAR and SENSEMODE
;
; INPUTS:
;	R3 => TM78 CSR
;	R5 => UCB
;

START_SENSEMODE:
START_SENSECHAR:
START_DRVCLR:
START_PACKACK:
START_NOP:
	EX_NDT_CMD	CMD=SENSE,-	; Execute a SENSE command
			TIMEOUT=#MINIMUM_TIMEOUT,-;  which should not take much time.
			ERROR_LABEL=NOP_EXIT

;
; EX_NDT_CMD returns the interrupt code in R0.  The only possible interrupt
;	codes that can occur after a SENSE command are:
;
;	1. HIC_DONE - which implies a successful completion.
;	2. HIC_TM_FAULT_A - which implies a controller error.
;	3. HIC_TU_FAULT_A - which implies a drive error.
;

	CMPB	#HIC_DONE,R0		; Was it successful?
	BNEQ	20$			; If not, branch to see why not.
	BSBW	RECORD_SENSE_INFO	; Update UCB fields with latest data.
	BBS	#MF_DS_V_RDY,-		; If tape physically mounted,
		UCB$L_MF_DS(R5),5$	;  branch around.
	MOVZWL	#SS$_MEDOFL,R0		; Set proper return status.
	BRB	NOP_EXIT		; Branch around to exit.
5$:
	CMPZV	#IRP$V_FCODE,-		; See if the active I/O operation is
		#IRP$S_FCODE,-		;  a PACKACK function and if NOT then
		UCB$W_FUNC(R5),-	;  we will branch around.
		#IO$_PACKACK
	BNEQ	10$			; Branch if not PACKACK.
	BISW	#UCB$M_VALID,-		; For successful PACKACK functions we
		UCB$W_STS(R5)		;  set the volume software valid.
10$:
	MOVZWL	S^#SS$_NORMAL,R0	; Else indicate success status.
	BRB	NOP_EXIT		; And branch around to exit.

20$:	BSBW	DEVICE_ERROR		; Do EXTENDED SENSE and log device error
	CMPB	#HIC_TM_FAULT_A,R0	; Was it a controller failure?
	BNEQ	30$			; If not, go to indicate DRIVE error.
	MOVZWL	#SS$_CTRLERR,R0		; Else indicate controller failure.
	BRB	NOP_EXIT		; And branch around to exit.

30$:	MOVZWL	#SS$_DRVERR,R0		; Indicate drive error.
NOP_EXIT:
	BRW	FUNCTION_EXIT		; Branch to common exit.
	.PAGE
	.SBTTL	Start REWIND, RECAL, READPRESET, REWINDOFF or UNLOAD function.

; START_REWIND, START_RECAL, START_READPRESET, START_REWINDOFF and START_UNLOAD
;	and START_AVAILABLE
;
; INPUTS:
;	R3 => TM78 CSR
;	R5 => UCB
;

START_AVAILABLE:
	BISW	#IO$M_NOWAIT,-		; Available is equivalent of REWIND-
		UCB$W_FUNC(R5)		;  NOWAIT and clear UCB$M_VALID.
	BICW	#UCB$M_VALID,-		; Mark volume as invalid
		UCB$W_STS(R5)		;  and fall thru to REWIND.

START_REWIND:
START_RECAL:
START_READPRESET:
	MOVZBL	#F_REWIND!GO_BIT,R0		; Set command code in register.
	BRB	REWIND_COMMON			; Branch around to common code.

START_REWINDOFF:
START_UNLOAD:
	MOVZBL	#F_UNLOAD!GO_BIT,R0		; Set command code in register.
REWIND_COMMON:
	MOVB	R0,UCB$B_FEX(R5)	; Save command in convenient place.
	REWIND	CMD=R0,-		; Execute REWIND or UNLOAD.
		WAIT=UCB$W_FUNC(R5),-	; Pass value of IO$M_NOWAIT.
		ERROR_LABEL=REWIND_EXIT

;
; REWIND returns the interrupt code in R0.
;
; The only possible interrupt codes here are:
;
;	1. HIC_DONE
;	2. HIC_NOT_AVAIL
;	3. HIC_OFF_LINE
;	4. HIC_NON_EX
;	5. HIC_TM_FAULT_A
;	6. HIC_TU_FAULT_A
;

	CMPB	#HIC_DONE,R0		; See if DONE,
	BNEQ	10$			; If NOT, branch to test interrupt code.
	CMPB	#F_UNLOAD!GO_BIT,-	; See if tape has been unloaded and
		UCB$B_FEX(R5)		;  if so then we mark the volume as
					;  invalid.
	BNEQ	5$			; If NOT UNLOAD, branch around.
	BICW	#UCB$M_VALID,-		; Mark volume as invalid.
		UCB$W_STS(R5)
5$:
	MOVZWL	S^#SS$_NORMAL,R0	; Indicate success code and
	BISW	#<MT$M_BOT@-16>,-	; Set BOT bit on in UCB field.
		UCB$L_DEVDEPEND+2(R5)
	BICW	#<MT$M_LOST@-16>,-	; Clear the fact that we may have
		UCB$L_DEVDEPEND+2(R5)	;  been lost
	CLRL	UCB$L_MF_RECORD(R5)	; Indicate tape is positioned at start.
	MNEGL	#2,UCB$L_MF_PREVTM(R5)	; And indicate ignorance of TAPEMARK positions.
	BRB	REWIND_EXIT		;  branch around to exit.

10$:
	CMPB	#HIC_OFF_LINE,R0	; See if OFF-LINE.
	BNEQ	20$			; If not, branch around to test further.
	MOVZWL	#SS$_MEDOFL,R0		; Indicate media off-line and
	BRB	REWIND_EXIT		;  branch around to end.

20$:
	BSBW	DEVICE_ERROR		; Do EXTENDED SENSE and log device error
	CMPB	#HIC_TM_FAULT_A,R0	; See if controller error.
	BNEQ	30$			; If not, branch around to next test.
	MOVZWL	#SS$_CTRLERR,R0		; Indicate controller error and
	BRB	REWIND_EXIT		;  branch around.

30$:	CMPB	#HIC_NON_EX,R0		; Test if non-existent drive.
	BNEQ	40$			; If not then branch to drive error.
	MOVZWL	#SS$_NONEXDRV,R0	; Indicate non-existent drive and
	BRB	REWIND_EXIT		;  branch around to exit.

40$:	MOVZWL	#SS$_DRVERR,R0		; Indicate drive error

REWIND_EXIT:
	BRW	FUNCTION_EXIT		; Branch to common exit.
	.PAGE
	.SBTTL	Start a SETCHAR or a SETMODE function

; START_SETCHAR and START_SETMODE
;	The quad-word of data for the operation is contained in IRP$L_MEDIA.
;	This "PHYSICAL" I/O function and the "LOGICAL" I/O function
;	SET MODE are almost identical.  The only difference is that while
;	both allow for the setting of:
;
;		1. Default buffer size
;		2. Tape density (1600 BPI or 6250 BPI).
;		3. Tape format
;
;	the former function (i.e. SET CHARACTERISTICS) also allows for
;	the resetting of the DEVICE CLASS and the DEVICE TYPE fields in
;	the UCB.
;
;	The first two bytes of the QUADWORD of data at IRP$L_MEDIA contain
;	the DEVICE CLASS and DEVICE TYPE respectively for a SETCHAR.
;	The next word of the QUADWORD contains the new buffer size.  The
;	third word contains new density and format information.  The fourth
;	word of the QUADWORD is reserved.
;
; INPUTS:
;	R3 => TM78 CSR
;	R5 => UCB
;

START_SETCHAR:
	MOVL	UCB$L_IRP(R5),R2			; R2 => current IRP.
	ASSUME	UCB$B_DEVTYPE EQ UCB$B_DEVCLASS+1
	MOVW	IRP$L_MEDIA(R2),UCB$B_DEVCLASS(R5)	; Reset CLASS and TYPE.

START_SETMODE:
	MOVL	UCB$L_IRP(R5),R2			; R2 => current IRP.
	MOVW	IRP$L_MEDIA+2(R2),UCB$W_DEVBUFSIZ(R5)	; Copy new buffer size.
	MOVW	IRP$L_MEDIA+4(R2),UCB$W_BOFF(R5)	; Copy density, format
							; to unused UCB field
							; for now.

	EX_NDT_CMD	CMD=SENSE,-	; Execute Non-data transfer SENSE command
			TIMEOUT=#MINIMUM_TIMEOUT,-;  don't wait for long, and
			ERROR_LABEL=SETMODE_EXIT
					;  branch around to EXIT if unable.

; Remember EX_NDT_CMD returns the interrupt code in R0.

	CMPB	#HIC_DONE,R0		; Compare to success code.
	BEQL	20$			; If no error, branch.

	BSBW	DEVICE_ERROR		; Do EXTENDED SENSE and log device error

	CMPB	#HIC_TU_FAULT_A,R0	; See if DRIVE error.
	BEQL	10$			; Branch if yes.
	MOVZWL	#SS$_CTRLERR,R0		; Indicate CONTROLLER error.
	BRB	SETMODE_EXIT		; Branch around to exit.

10$:
	MOVZWL	#SS$_DRVERR,R0		; Indicate DRIVE error.
	BRB	SETMODE_EXIT		; And branch around to exit.

20$:
	ASSUME	MT$V_LOGSOFT	LT	16
	ASSUME	MT$V_LOGSOFTOG	LT	16
	BBC	#MT$V_LOGSOFTOG,-	; Test if caller has specified the
		UCB$W_BOFF(R5),25$	;  toggling of MT$M_LOGSOFT in
					;  UCB$L_DEVDEPEND. If NOT, branch.
	BBCS	#MT$V_LOGSOFT,-		; Toggle bit.  Here if clear, set it
		UCB$L_DEVDEPEND(R5),25$	;  and branch around.
	BICW	#MT$M_LOGSOFT,-		; Here it was set so we clear it.
		UCB$L_DEVDEPEND(R5)
25$:
	BSBW	RECORD_SENSE_INFO	; Call to record the sense information.
	EXTZV	#MT$V_DENSITY,-
		#MT$S_DENSITY,-
		UCB$W_BOFF(R5),R0	; Extract user designated DENSITY parameter.

	EXTZV	#MT$V_FORMAT,-
		#MT$S_FORMAT,-
		UCB$W_BOFF(R5),R1	; Likewise the FORMAT parameter

	MOVZBL	FORMAT_TABLE[R1],R1	; Replace software FORMAT with TM78
					;  specific code.

	MOVZWL	#MT$M_FORMAT,R2		; Set up mask to reset UCB field

	BBC	#MF_DS_V_BOT,-
		UCB$L_MF_DS(R5),30$	; We only reset the DENSITY if we are at
					;  beginning of tape.  Else branch around.

	BISW	#MT$M_DENSITY,R2	; Set mask to accept DENSITY.
	CLRB	UCB$B_MF_DENSITY(R5)	; Initialize UCB DENSITY byte.
	CMPB	#MT$K_PE_1600,R0	; See if user specified 1600.
	ASSUME	MF$K_DENSITY_1600  EQ  0
	BEQL	30$			; Branch if yes, 1600 BPI.
	ASSUME	MF$K_DENSITY_6250  EQ  1
	INCB	UCB$B_MF_DENSITY(R5)	; Else indicate 6250 BPI.
	INSV	#MT$K_GCR_6250,-	; And insure that UCB$L_DEVDEPEND winds
		#MT$V_DENSITY,-		;  up with the correct value for DENSITY
		#MT$S_DENSITY,-		;  even though we may have arrived here
		UCB$W_BOFF(R5)		;  by default.

30$:
	INSV	R1,-
		#MF_TC_V_FMT,-
		#MF_TC_S_FMT,-
		UCB$W_MF_TMPLTC(R5)	; Set new FORMAT in UCB.
	BICW	R2,UCB$L_DEVDEPEND(R5)	; Use mask to clear out fields.
	MCOML	R2,R2			; Reverse mask for setting.
	BICW	R2,UCB$W_BOFF(R5)	; Clear unwanted user specified parameters.
	BISW	UCB$W_BOFF(R5),-
		UCB$L_DEVDEPEND(R5)	; Reset the verified parameters
	MOVZWL	S^#SS$_NORMAL,R0	; Indicate success.
SETMODE_EXIT:
	BRW	FUNCTION_EXIT		; Branch to common exit.
	.PAGE
	.SBTTL	Start a SKIPFILE or a SPACEFILE function

; START_SKIPFILE and START_SPACEFILE
;
; INPUTS:
;	IRP$L_MEDIA = # files to skip (word count in longword field)
;	R3 => TM78 CSR
;	R5 => UCB
;

START_SKIPFILE:				; Logical I/O operation.
START_SPACEFILE:			; Physical I/O operation.
	MOVL	UCB$L_IRP(R5),R2	; R2 => current IRP.
	CVTWL	IRP$L_MEDIA(R2),R1	; Pickup number of files to skip.
	BwLSS	REV_SPACEFILE		; Branch if reverse skip.

	MOVW	R1,UCB$W_BOFF(R5)	; Use convenient place in UCB to retain
					;  number of files left to skip.
	MOVW	R1,UCB$W_BCNT(R5)	; Use convenient place in UCB to keep
					;  original number of files to skip.

;
; Here we loop skipping records at a clip of 255 per skip since the repeat
;	count in the hardware command register is only 8 bits long.  After
;	each TAPEMARK is encountered we subtract 1 from UCB$W_BOFF until it
;	reaches zero.  Meanwhile we keep UCB$L_MF_RECORD uptodate with the
;	current tape position.
;

SKIP_FF_LOOP:				; SKIP FILE FORWARD LOOP.
	TSTW	UCB$W_BOFF(R5)		; See if any more files left to skip.
	BwEQL	SKIP_NORMAL_EXIT	; EQL implies all done, so branch.

	EX_NDT_CMD	CMD=SP_FWD_REC,-	; Execute space forward record
			REPEAT=#255,-		;  NDT command to skip 255 records
			TIMEOUT=#TU78_MAX_SPACE,-;  and timeout in N seconds and
			ERROR_LABEL=SKIP_EXIT	;  branch to SKIP_EXIT if we fail.

;
; Test interrupt code.  Remember EX_NDT_CMD returns the interrupt code in R0.
;

	CMPB	#HIC_DONE,R0		; See if the command DONE.
	BNEQ	10$			; If not, branch around for more tests.

; If HIC_DONE then,

	MOVZBL	UCB$W_MF_NDTCR+1(R5),R0	; Pickup number of RECORDS skipped.
	ADDL	R0,UCB$L_MF_RECORD(R5)	; Add in to maintain tape position.
	BRW	SKIP_FF_LOOP		; And loop back to continue skipping.

10$:	CMPB	#HIC_TM,R0		; See if TAPEMARK encountered.
	BwNEQ	SKIP_ERROR		; If not, branch around for more tests
					;  to determine exact error condition.

; If HIC_TM then,

	BSBW	COMPUTE_NDT_REPEAT	; R1 = # records skipped before
					;  TAPEMARK encountered.

	INCL	R1			; Add in TAPEMARK.
	ADDL	R1,UCB$L_MF_RECORD(R5)	; Update tape position.
	DECW	UCB$W_BOFF(R5)		; Decrement # files left to skip.
	SUBL3	UCB$L_MF_PREVTM(R5),-
		UCB$L_MF_RECORD(R5),R0	; R0 = distance between last 2 TAPEMARKS.
	BBC	#DEV$V_MNT,-		; If NOT mounted then go
		UCB$L_DEVCHAR(R5),20$	;  test for possible EOV.
	BBC	#DEV$V_FOR,-		; If mounted NOT foreign, (i.e. ACP NOT
		UCB$L_DEVCHAR(R5),30$	;  NOT involved) branch around test EOV.
20$:	DECL	R0			; See if last 2 TAPEMARKs adjacent.
	BwEQL	SKIP_FILE_SETEOV	; EQL => yes so branch.

; We are here if either the volume is mounted, NOT foreign (i.e. ANSI mounted
;	with the ACP involved) and/or the last two TAPEMARKs are NOT adjacent.

	MOVL	UCB$L_MF_RECORD(R5),-	; If NOT between tapemarks on /FOR tape,
		UCB$L_MF_PREVTM(R5)	;  remember position of this TAPEMARK.
30$:	BRW	SKIP_FF_LOOP		; Branch back to skip some more.
	.PAGE
; REV_SPACEFILE - reverse spacefile.
;
; R1 = negative of number of files to skip.
; R3 => TM78 CSR
; R5 => UCB
;

REV_SPACEFILE:
	MNEGW	R1,UCB$W_BOFF(R5)	; Use convenient place in UCB to retain
					;  the number of files left to skip.
	MNEGW	R1,UCB$W_BCNT(R5)	; Use convenient place in UCB to keep
					;  original number of files to skip.

;
; Here we loop skipping records in reverse at a clip of 255 records per skip
;	since the repeat count in the hardware command register is only 8
;	bits long.  After each TAPEMARK is encountered we subtract 1 from
;	UCB$W_BOFF until it reaches zero.  Meanwhile we keep UCB$L_MF_RECORD
;	uptodate with the current tape position.  BOT ends the operation
;	prematurely.
;

SKIP_FR_LOOP:				; SKIP FILE REVERSE LOOP
	TSTW	UCB$W_BOFF(R5)		; See if done.
	BwEQL	SKIP_NORMAL_EXIT	; EQL implies done, so branch end.

	EX_NDT_CMD	CMD=SP_REV_REC,-	; Execute space reverse record
			REPEAT=#255,-		;  NDT command with a REPEAT of
			TIMEOUT=#TU78_MAX_SPACE,-;  255 and a TIMEOUT of N secs.
			ERROR_LABEL=SKIP_EXIT	;  Branch to SKIP_EXIT if we fail.

;
; Test interrupt code which EX_NDT_CMD returns in R0.
;

	CMPB	#HIC_DONE,R0		; DONE implies that we skipped 255 recs.
	BNEQ	10$			; If not, branch for further tests.

; If HIC_DONE then,

	MOVZBL	UCB$W_MF_NDTCR+1(R5),R0	; R0 = original repeat count (255).
	SUBL	R0,UCB$L_MF_RECORD(R5)	; Subtract to update tape position.
	BRW	SKIP_FR_LOOP		; Loop back to continue skipping.

10$:
	CMPB	#HIC_TM,R0		; Did we encounter a TAPEMARK?
	BEQL	20$			; EQL implies yes.
	CMPB	#HIC_BOT,R0		; Did we encounter BOT?
	BwNEQ	SKIP_ERROR		; NEQ implies no; so branch around.

; If HIC_TM or HIC_BOT then,

20$:
	BSBW	COMPUTE_NDT_REPEAT	; R1 = # of records actually skipped.


	CMPB	#HIC_BOT,R0		; Are we at BOT or TAPEMARK?
	BEQL	30$			; EQL implies BOT, so branch around.
	INCL	R1			; Bump count to include TAPEMARK skipped.
	DECW	UCB$W_BOFF(R5)		; Decrement # files left to skip.
30$:
	SUBL	R1,UCB$L_MF_RECORD(R5)	; Update tape position.
	MNEGL	#2,UCB$L_MF_PREVTM(R5)	; After reverse motion, set previous TM to -2.
	CMPB	#HIC_TM,R0		; Was it TAPEMARK?
	BwEQL	SKIP_FR_LOOP		; If so, branch back to continue skipping.
	CLRL	UCB$L_MF_RECORD(R5)	; If at BOT, then should be zero.
	BISW	#<MT$M_BOT@-16>,-	; Set BOT bit on in UCB field.
		UCB$L_DEVDEPEND+2(R5)
	BICW	#<MT$M_LOST@-16>,-	; Clear the fact that we may have
		UCB$L_DEVDEPEND+2(R5)	;  been lost
	BRW	SKIP_NORMAL_EXIT	; If at BOT, then we are done.
	.PAGE
	.SBTTL	Start a SKIPRECORD or a SPACERECORD function

; START_SKIPRECORD and START_SPACERECORD
;
; INPUTS:
;	IRP$L_MEDIA = # records to skip (word count in longword field)
;	R3 => TM78 CSR
;	R5 => UCB
;

START_SKIPRECORD:			; Logical I/O operation.
START_SPACERECORD:			; Physical I/O/operation.
	MOVL	UCB$L_IRP(R5),R2	; R2 => current IRP.
	CVTWL	IRP$L_MEDIA(R2),R1	; Pickup number of records to skip.
	BwLSS	REV_SPACERECORD		; Branch if reverse skip.

	MOVW	R1,UCB$W_BOFF(R5)	; Use convenient place in UCB to retain
					;  number of records left to skip.
	MOVW	R1,UCB$W_BCNT(R5)	; Use convenient place in UCB to keep
					;  original number of records to skip.

;
; Here we loop skipping records at a clip of 255 or UCB$W_BOFF 
;	per skip since the repeat count in the hardware command
;	register is only 8 bits long.  After each HIC_DONE interrupt,
;	we subtract the number of records skipped from UCB$W_BOFF
;	until we are done.
;

SKIP_RF_LOOP:				; SKIP RECORD FORWARD LOOP.
	TSTW	UCB$W_BOFF(R5)		; See if any more records left to skip.
	BwEQL	SKIP_NORMAL_EXIT	; EQL implies all done, so branch.

	MOVZBL	#255,R0			; Calculate repeat count, 255 or
	CMPW	R0,UCB$W_BOFF(R5)	;  UCB$W_BOFF, whichever is less.
	BLSS	10$			; LSS => 255 if less.
	MOVZWL	UCB$W_BOFF(R5),R0	; Else UCB$W_BOFF is less.
10$:
	EX_NDT_CMD	CMD=SP_FWD_REC,-	; Execute space forward record
			REPEAT=R0,-		;  NDT command to skip records
			TIMEOUT=#TU78_MAX_SPACE,-;  and timeout in N seconds and
			ERROR_LABEL=SKIP_EXIT	;  branch to SKIP_EXIT if we fail.

;
; Test interrupt code.  Remember EX_NDT_CMD returns the interrupt code in R0.
;

	CMPB	#HIC_DONE,R0		; See if the command DONE.
	BNEQ	20$			; If not, branch around for more tests.

; If HIC_DONE then,

	MOVZBL	UCB$W_MF_NDTCR+1(R5),R0	; Pickup number of RECORDS skipped.
	ADDL	R0,UCB$L_MF_RECORD(R5)	; Add in to maintain tape position.
	SUBW	R0,UCB$W_BOFF(R5)	; Subtract # of records just skipped.
	BRW	SKIP_RF_LOOP		; And loop back to continue skipping.

20$:	CMPB	#HIC_TM,R0		; See if TAPEMARK encountered.
	BwNEQ	SKIP_ERROR		; If not, branch around for more tests
					;  to determine exact error condition.

; If HIC_TM then,

	BSBW	COMPUTE_NDT_REPEAT	; R1 = # records skipped before
					;  TAPEMARK encountered.
	INCL	R1			; Add in TAPEMARK.

	SUBW	R1,UCB$W_BOFF(R5)	; Decrement # records left to skip.
	ADDL	R1,UCB$L_MF_RECORD(R5)	; Update tape position.
	SUBL3	UCB$L_MF_PREVTM(R5),-
		UCB$L_MF_RECORD(R5),R0	; R0 = distance between last 2 TAPEMARKS.
	BBC	#DEV$V_MNT,-		; If NOT mounted then go
		UCB$L_DEVCHAR(R5),30$	;  test for possible EOV.
	BBC	#DEV$V_FOR,-		; If mounted NOT foreign, (i.e. ACP NOT
		UCB$L_DEVCHAR(R5),40$	;  NOT involved) branch around test EOV.
30$:	DECL	R0			; See if last 2 TAPEMARKs adjacent.
	BwEQL	SKIP_RECORD_SETEOV	; EQL => yes so branch.

; We are here if either the volume is mounted, NOT foreign (i.e. ANSI mounted
;	with the ACP involved) and/or the last two TAPEMARKs are NOT adjacent.

	MOVL	UCB$L_MF_RECORD(R5),-	; If NOT between tapemarks on /FOR tape,
		UCB$L_MF_PREVTM(R5)	;  remember position of this TAPEMARK.
40$:	BRW	SKIP_SETEOF		; Branch to set status and exit.
	.PAGE
; REV_SPACERECORD - reverse spacerecord.
;
; R1 = negative of number of records to skip.
; R3 => TM78 CSR
; R5 => UCB
;

REV_SPACERECORD:
	MNEGW	R1,UCB$W_BOFF(R5)	; Use convenient place in UCB to retain
					;  the number of records left to skip.
	MNEGW	R1,UCB$W_BCNT(R5)	; Use convenient place in UCB to keep
					;  original number of records to skip.
;
; Here we loop skipping records in reverse at a clip of 255 or UCB$W_BOFF 
;	per skip since the repeat count in the hardware command
;	register is only 8 bits long.  After each HIC_DONE interrupt,
;	we subtract the number of records skipped from UCB$W_BOFF
;	until we are done.
;

SKIP_RR_LOOP:				; SKIP RECORD REVERSE LOOP.
	TSTW	UCB$W_BOFF(R5)		; See if any more records left to skip.
	BwEQL	SKIP_NORMAL_EXIT	; EQL implies all done, so branch.

	MOVZBL	#255,R0			; Calculate repeat count, 255 or
	CMPW	R0,UCB$W_BOFF(R5)	;  UCB$W_BOFF, whichever is less.
	BLSS	10$			; LSS => 255 if less.
	MOVZWL	UCB$W_BOFF(R5),R0	; Else UCB$W_BOFF is less.
10$:
	EX_NDT_CMD	CMD=SP_REV_REC,-	; Execute space reverse record
			REPEAT=R0,-		;  NDT command to skip records
			TIMEOUT=#TU78_MAX_SPACE,-;  and timeout in N seconds and
			ERROR_LABEL=SKIP_EXIT	;  go to SKIP_EXIT if we fail.

;
; Test interrupt code.  Remember EX_NDT_CMD returns the interrupt code in R0.
;

	CMPB	#HIC_DONE,R0		; See if the command DONE.
	BNEQ	20$			; If not, branch around for more tests.

; If HIC_DONE then,

	MOVZBL	UCB$W_MF_NDTCR+1(R5),R0	; Pickup number of RECORDS skipped.
	SUBL	R0,UCB$L_MF_RECORD(R5)	; Subtract to maintain tape position.
	SUBW	R0,UCB$W_BOFF(R5)	; Subtract # of records just skipped.
	BRW	SKIP_RR_LOOP		; And loop back to continue skipping.

20$:	CMPB	#HIC_TM,R0		; See if TAPEMARK encountered.
	BEQL	30$			; EQL implies yes.
	CMPB	#HIC_BOT,R0		; Did we encounter BOT?
	BwNEQ	SKIP_ERROR		; NEQ implies no; so branch around.

; If HIC_TM or HIC_BOT then,

30$:
	BSBW	COMPUTE_NDT_REPEAT	; R1 = # of records actually skipped.

	CMPB	#HIC_BOT,R0		; Are we at BOT or TAPEMARK?
	BEQL	40$			; EQL implies BOT, so branch around.
	INCL	R1			; Bump count to include TAPEMARK skipped.
40$:
	SUBW	R1,UCB$W_BOFF(R5)	; Decrement # records left to skip.
	SUBL	R1,UCB$L_MF_RECORD(R5)	; Update tape position.
	MNEGL	#2,UCB$L_MF_PREVTM(R5)	; After reverse motion, set previous TM to -2.
	CMPB	#HIC_TM,R0		; Was it TAPEMARK?
	BwEQL	SKIP_SETEOF		; If so, branch around to exit.
	CLRL	UCB$L_MF_RECORD(R5)	; If at BOT, then should be zero.
	BISW	#<MT$M_BOT@-16>,-	; Set BOT bit on in UCB field.
		UCB$L_DEVDEPEND+2(R5)
	BICW	#<MT$M_LOST@-16>,-	; Clear the fact that we may have
		UCB$L_DEVDEPEND+2(R5)	;  been lost
	BRW	SKIP_SETEOF		; If at BOT, then we are all done.
	.PAGE
; SKIP EXIT AND ERROR PROCESSING.

SKIP_FILE_SETEOV:
SKIP_RECORD_SETEOV:
	INCW	UCB$W_BOFF(R5)		; Increment to indicate 1 less file skipped.
	EX_NDT_CMD	CMD=SP_REV_REC,-	; Execute  space REVERSE record
			REPEAT=#1,-		;  NDT command to skip back over
			TIMEOUT=#MINIMUM_TIMEOUT,-;  last of 2 adjacent TAPEMARKs.
			ERROR_LABEL=SKIP_EXIT	; Branch to SKIP_EXIT if we fail.

; EX_NDT_CMD returns interrupt code in R0.

	CMPB	#HIC_TM,R0		; It had better be a TAPEMARK.
	BNEQ	SKIP_HARD_ERROR		; NEQ implies some error.

	DECL	UCB$L_MF_RECORD(R5)	; Decrement to record backward movement.
	MOVZWL	#SS$_ENDOFVOLUME,R0	; Set final I/O status.
	BRB	SKIP_EXIT		; Branch around to exit.

SKIP_ERROR:
	CMPB	#HIC_NOT_CAPABLE,R0	; See if blank tape.
	BNEQ	10$			; NEQ means no, not blank tape.
	MOVZWL	#SS$_OPINCOMPL,R0	; Else get proper error status and
	BRB	SKIP_EXIT		;  branch around to end.

10$:	CMPB	#HIC_OFF_LINE,R0	; See if OFF-LINE.
	BNEQ	SKIP_HARD_ERROR		; If not, branch around to test further.
	MOVZWL	#SS$_MEDOFL,R0		; Indicate media off-line and
	BRB	SKIP_EXIT		;  branch around to end.

SKIP_HARD_ERROR:
	BSBW	DEVICE_ERROR		; Do EXTENDED SENSE and log device error

	CMPB	#HIC_TM_FAULT_A,R0	; See if controller error.
	BNEQ	20$			; If not, branch around to next test.
	MOVZWL	#SS$_CTRLERR,R0		; Indicate controller error and
	BRB	SKIP_EXIT		;  branch around.

20$:	CMPB	#HIC_NON_EX,R0		; Test if non-existent drive.
	BNEQ	30$			; If not then branch to drive error.
	MOVZWL	#SS$_NONEXDRV,R0	; Indicate non-existent drive and
	BRB	SKIP_EXIT		;  branch around to exit.

30$:	MOVZWL	#SS$_DRVERR,R0		; Indicate drive error
	BRB	SKIP_EXIT		; Branch around to end.
SKIP_SETEOF:
	MOVZWL	#SS$_ENDOFFILE,R0	; Indicate status return.
	BRB	SKIP_EXIT		; And branch around to exit.
SKIP_NORMAL_EXIT:
	MOVZBL	S^#SS$_NORMAL,R0	; Indicate normal status.
SKIP_EXIT:
	SUBW3	UCB$W_BOFF(R5),-	; Calculate the number of files
		UCB$W_BCNT(R5),R1	;  skipped.
	INSV	R1,#16,#16,R0		; And place count in high word of R0.
	BRW	FUNCTION_EXIT		; Branch to common exit.
	.PAGE
	.SBTTL	COMPUTE_NDT_REPEAT subroutine

; COMPUTE_NDT_REPEAT - subroutine to compute the actual number of times a
;	Non-data transfer (NDT) command has been repeated.
;
; INPUTS:
;	R3 => TM78 CSR
;	R5 => UCB
;	UCB$W_MF_NDTCR contains a copy of original NDT
;		command loaded into unit's NDT register.
;
; OUTPUT:
;	R1 = actual number of times the NDT command was repeated.
;
;	Subroutine extracts original repeat count from UCB$W_MF_NDTCR and
;	subtracts residue count from device unit's NDT command register.
;

COMPUTE_NDT_REPEAT:

	MOVZWL	UCB$W_UNIT(R5),R1	; Get this device's unit number.
	PUSHL	MF_NDT0(R3)[R1]		; Push residue of previous NDT command.
	EXTZV	#MF_NDT0_V_CCNT,-	; Extract residual repeat count and
		#MF_NDT0_S_CCNT,(SP),-	;  zero extend it and then leave
		(SP)			;  on the top of the stack.
	MOVZBL	UCB$W_MF_NDTCR+1(R5),R1	; Pickup original repeat count.
	SUBL	(SP)+,R1		; Subtract to get # completed.
	RSB				; Return to caller.
	.PAGE
	.SBTTL	Start WRITEOF or WRITEMARK or DSE function

; START_WRITEOF and START_WRITEMARK and START_DSE
;
; INPUTS:
;	R3 => TM78 CSR
;	R5 => UCB
;

START_WRITEOF:				; Logical I/O function.
START_WRITEMARK:			; Physical I/O function.
	MOVL	#MINIMUM_TIMEOUT,-
		UCB$L_MF_TIMOUT(R5)	; Indicate TIMEOUT for next NDT operation.
	MOVZBL	#F_WTM_GCR!GO_BIT,R0	; Assume 6250 density
	TSTB	UCB$B_MF_DENSITY(R5)	; Test the density.
	BNEQ	GO_WRITEMARK_OR_ERASE	; NEQ implies 6250, so branch around.
	MOVZBL	#F_WTM_PE!GO_BIT,R0	; If 1600, set proper command code
	BRB	GO_WRITEMARK_OR_ERASE	; Join common WRITE_TAPEMARK/ERASETAPE code.
START_ERASETAPE:
	MOVL	#MINIMUM_TIMEOUT,-
		UCB$L_MF_TIMOUT(R5)	; Indicate TIMEOUT for next NDT operation.
	MOVZBL	#F_ERG_GCR!GO_BIT,R0	; Assume 6250 density.
	TSTB	UCB$B_MF_DENSITY(R5)	; Test the density.
	BNEQ	GO_WRITEMARK_OR_ERASE	; NEQ implies 6250, so branch around.
	MOVZBL	#F_ERG_PE!GO_BIT,R0	; If 1600, set proper command code.
	BRB	GO_WRITEMARK_OR_ERASE	; Join common WRITE_TAPEMARK/ERASETAPE code.
START_DSE:
	MOVL	#TU78_MAX_DSE,UCB$L_MF_TIMOUT(R5)
					; Indicate TIMEOUT for next NDT operation.
	MOVZBL	#F_DSE!GO_BIT,R0	; Set NDT command in R0.
GO_WRITEMARK_OR_ERASE:			; COMMON CODE.
	EX_NDT_CMD	CMD=R0,-	; Execute write tape mark or erase command
			ERROR_LABEL=WRITEMARK_EXIT

;
; EX_NDT_CMD returns the interrupt code in R0.  After a WRITE-TAPE-MARK or
;	ERASE command the following interrupt codes are possible and the
;	following actions are taken:
;
;	1. HIC_DONE - indicates that the operation terminated successfully.
;		We simply increment the tape position counter (UCB$L_MF_RECORD)
;		and return SS$_NORMAL status.
;	2. HIC_EOT - indicates that the operation terminated successfully but
;		the tape is now positioned beyond the reflective strip at the
;		end of the tape.  We increment the tape position counter
;		(UCB$L_MF_RECORD) and return SS$_ENDOFTAPE status.  Also
;		we set the MT$M_EOT bit in UCB$L_DEVDEPEND.
;	3. HIC_FPT - we could not write the TAPEMARK due to the fact that the
;		tape was WRITE-LOCKED.  We return SS$_WRITLCK status.
;	4. HIC_OFF_LINE - indicates that the drive is offline and therefore we
;		were unable to complete the operation.  We return SS$_MEDOFL
;		status.
;	5. HIC_NON_EX - indicates that the HARDWARE device is non-existent and
;		therefore we were unable to complete the operation.  We return
;		SS$_NONEXDRV status.
;	6. HIC_TM_FAULT_A - indicates the TM78 controller experienced an error
;		that prevented successful completion of the operation.  We
;		return SS$_CTRLERR status.
;	7. HIC_NOT_AVAIL, HIC_BAD_TAPE, HIC_TU_FAULT_A - all indicate that
;		a hardware error prevented successful termination of the I/O
;		function.  We return SS$_DRVERR status.
;

	CMPB	#HIC_DONE,R0		; See if sucessful.
	BEQL	10$			; EQL implies yes.
	CMPB	#HIC_EOT,R0		; See if successful but beyond EOT.
	BNEQ	40$			; If not, branch around to next test.
	MOVZWL	#SS$_ENDOFTAPE,R0	; Indicate final status.
	BISW	#<MT$M_EOT@-16>,-	; Set bit indicating we are
		UCB$L_DEVDEPEND+2(R5)	;  beyond EOT marker.
	BRB	20$			; Branch around.

10$:	MOVZWL	S^#SS$_NORMAL,R0	; Indicate success.
20$:
	EXTZV	#IRP$V_FCODE,-		; See which command we are executing.
		#IRP$S_FCODE,-		; If it is ERASETAPE, then branch
		UCB$W_FUNC(R5),R1	;  around the incrementation of
	CMPL	R1,#IO$_ERASETAPE	;  UCB$L_MF_RECORD and the setting of
	BEQL	30$			;  UCB$L_MF_PREVTM.
	CMPL	R1,#IO$_DSE		; If it is NOT IO$_DSE, branch around
	BNEQ	25$			;  the clearing of UCB$L_MF_RECORD and
	CLRL	UCB$L_MF_RECORD(R5)	;  the initializing of UCB$L_MF_PREVTM
	MNEGL	#2,UCB$L_MF_PREVTM(R5)	;  to the value negative 2 (-2).
	BRB	30$			; Branch around.
25$:
	INCL	UCB$L_MF_RECORD(R5)	; Increment position counter.
	MOVL	UCB$L_MF_RECORD(R5),-	; Remember this as position of previous
		UCB$L_MF_PREVTM(R5)	;  TAPEMARK which we have just written.
30$:	BRB	WRITEMARK_EXIT		; Branch around to exit.

40$:	CMPB	#HIC_FPT,R0		; Was the problem lack of RING.
	BNEQ	50$			; NEQ implies no, so branch to next test.
	MOVZWL	#SS$_WRITLCK,R0		; Indicate WRITELOCK status and
	BRB	WRITEMARK_EXIT		;  branch around to exit.

50$:	CMPB	#HIC_OFF_LINE,R0	; Is drive offline?
	BNEQ	60$			; NEQ implies no, so branch to next test.
	MOVZWL	#SS$_MEDOFL,R0		; Indicate final status and
	BRB	WRITEMARK_EXIT		;  branch around to exit.
60$:
	BSBW	DEVICE_ERROR		; Do EXTENDED SENSE and log device error

	CMPB	#HIC_TM_FAULT_A,R0	; Is problem, controller problem?
	BNEQ	70$			; If not, branch around to next test.
	MOVZWL	#SS$_CTRLERR,R0		; Else indicate final status and
	BRB	WRITEMARK_EXIT		;  branch around to exit.

70$:	CMPB	#HIC_NON_EX,R0		; Is problem, NON-existent drive?
	BNEQ	80$			; If not, branch around to next test.
	MOVZWL	#SS$_NONEXDRV,R0	; Else indicate final status and
	BRB	WRITEMARK_EXIT		;  branch around to exit.

80$:	MOVZWL	#SS$_DRVERR,R0		; Indicate DRIVE error.

WRITEMARK_EXIT:
	BRW	FUNCTION_EXIT		; Branch to common exit.
	.PAGE
	.SBTTL	NDT Function Executor.

; NDT_EXECUTOR - Subroutine called by code generated by EX_NDT_CMD macro.
;	This subroutine performs the common part of the execution of all
;	NDT commands.
;
; INPUTS:
;	R3 => TM78 CSR
;	R5 => UCB
;	UCB$W_MF_NDTCR(R5) contains the command to put into the NDT register
;	UCB$L_MF_TIMOUT(R5) contains the TIMEOUT amount
;
; OUTPUTS:
;	If we do NOT get timed out, we return to the point of invocation plus 2
;	and:
;
;	R0 = HIC (Hardware Interrupt Code) returned by TM78
;
;	If we get a TIMEOUT and experience return from POWERFAIL_TIMEOUT we
;		return to the ERROR_LABEL whose relative address is stored
;		at the point of invocation.
;

NDT_EXECUTOR:

	SUBSAVE				; Push invocation point onto SUBSTACK.
	MOVZWL	UCB$W_MF_NDTCR(R5),R0	; Record Hardware command about to
	MOVL	R0,UCB$L_MF_CMD(R5)	;  become the CURRENT command.

;
; For all but REWIND, UNLOAD, and DSE, we sequentialize the following so as
;	not to software timeout due to activity on other drives.
; This is due to the fact that although the TM78 will allow us to queue up
;	parallel requests it in fact will not process them in parallel and
;	therefore activity on other drives can mean inordinate waits which
;	would trigger software timeouts.
; Sequentialization is enforced by using the PRIMARY channel (i.e. the TM78
;	IDB) as an interlock or MUTEX.
;

	CMPB	#F_REWIND!GO_BIT,R0	; See if a REWIND.
	BEQL	10$			; If SO branch around and DON'T REQPCHAN
	CMPB	#F_UNLOAD!GO_BIT,R0	; See if a UNLOAD.
	BEQL	10$			; If SO branch around and DON'T REQPCHAN
	CMPB	#F_DSE!GO_BIT,R0	; See if a DSE.
	BEQL	10$			; If SO branch around and DON'T REQPCHAN
	REQPCHAN			; Request TM78 channel for all others.
10$:
	DSBINT
	PRIOR_TEST_TMRDY		; Assure that TM78 ready.
	BBS	#UCB$V_POWER,-
		UCB$W_STS(R5),40$	; Branch if POWERFAIL.
	MOVZWL	UCB$W_UNIT(R5),R0	; R0 = unit number of device.
	MOVZWL	UCB$W_MF_NDTCR(R5),-
		MF_NDT0(R3)[R0]		; Move command to proper register.
	WFIKPCH	50$,UCB$L_MF_TIMOUT(R5)	; Wait for interrupt.
	POST_TEST_TMRDY			; Assure that TM78 ready.

					; Assure not REWINDING or LOADING.
	EXTZV	#MF_NDTA_V_NDIC,-	; Extract interrupt code from attention
		#MF_NDTA_S_NDIC,-	;  data saved in UCB by interrupt
		UCB$L_MF_NDTA(R5),R2	;  dispatcher, and place in R2.
	CMPB	#HIC_NOT_RDY,R2		; See if NOT-READY.
					;  NOT_READY implies the drive has been
					;  MANUALLY rewound or loaded.
	BNEQ	20$			; If NOT, branch around.
	BISW	#UCB$M_MF_REWIND,-	; If in the middle of MANUAL REWIND,
		UCB$W_DEVSTS(R5)	;  then set appropriate bit.
	BRW	AWAIT_MANUAL_REWIND	; If NOT-READY, branch to wait for
					;  rewind or load to finish before
					;  trying to restart the I/O operation.
20$:
	CMPB	#HIC_REWINDING,R2	; See if REWINDING interrupt.
	BNEQ	30$			; If not, branch around.
	BISW	#UCB$M_MF_REWIND,-	; If in the middle of REWIND, then
		UCB$W_DEVSTS(R5)	;  set appropriate bit.
30$:

	MOVL	UCB$L_MF_NDTA(R5),-		; Copy NDT attention data to a
		UCB$L_MF_NDTA_C(R5)		;  stable place in the UCB.
	BSBW	SAVE_TM78_REGS		; Save hardware registers for ERROR LOG
	IOFORK				; Lower IPL to FORK level.
	BBS	#UCB$V_POWER,-
		UCB$W_STS(R5),50$	; Branch if we had a POWERFAIL.
	RELCHAN				; Release channel in case we have it.
	BRB	60$			; Branch around if not.
40$:	ENBINT				; We had a POWERFAIL.
50$:	SETIPL	UCB$B_FIPL(R5)		;  or a TIMEOUT.
	BSBW	TIMEOUT_POWERFAIL	; Call routine.
	SUBPOP	R1			; R1 => point of invocation.
	CVTWL	(R1),-(SP)		; Rel. addr of ERROR_LABEL to TOP of STACK
	ADDL	(SP)+,R1		; R1 => ERROR_LABEL
	BRB	70$			; Branch around.
60$:
	EXTZV	#MF_NDTA_V_NDIC,-	; Extract interrupt code from where
		#MF_NDTA_S_NDIC,-
		UCB$L_MF_NDTA_C(R5),R0	;  we stashed it above.

	SUBPOP	R1			; R1 => point of invocation.
70$:
	ADDL	#2,R1			; Adjust to correct return or error address
	JMP	(R1)			; Return to caller or ERROR_LABEL.
	.PAGE
	.SBTTL	Start READLBLK or READPBLK functions.

; START_READLBLK and START_READPBLK
;
; INPUTS:
;	R3 => TM78 CSR
;	R5 => UCB

START_READLBLK:
START_READPBLK:
	BBC	#IO$V_REVERSE,-		; If NOT reverse operation, branch
		UCB$W_FUNC(R5),10$	;  around to handle it.

					; READ REVERSE code
	MOVB	#F_READ_REV!GO_BIT,-	; Save the primary hardware OPCODE in
		UCB$B_FEX(R5)		;  the UCB.
	MOVB	#F_READ_FWD!GO_BIT,-	; And also save the OPPOSITE hardware
		UCB$B_CEX(R5)		;  OPCODE in the UCB.  The OPPOSITE
					;  OPCODE is used when we get READ_OPP
					;  status back from the controller.
	BRB	20$			; Branch around READ FORWARD logic.
10$:
					; READ FORWARD code
	MOVB	#F_READ_FWD!GO_BIT,-	; Save the primary hardware OPCODE in
		UCB$B_FEX(R5)		;  the UCB.
	MOVB	#F_READ_REV!GO_BIT,-	; And also save the OPPOSITE hardware
		UCB$B_CEX(R5)		;  OPCODE in the UCB.  The OPPOSITE
					;  OPCODE is used when we get READ_OPP
					;  status back from the controller.
20$:
	BSBW	READ_OR_WRITECHECK_BLOCK; Call internal subroutine to effect
					;  I/O data transfer.

	BLBC	R0,READ_EXIT		; If transfer failed, branch to exit.
	BBC	#IO$V_DATACHECK,-	; If no DATACHECK has been specified
		UCB$W_FUNC(R5),-	;  then we are finished so we branch
		READ_EXIT		;  around to exit.

	BBC	#IO$V_REVERSE,-		; If NOT reverse operation, branch
		UCB$W_FUNC(R5),30$	;  around to handle it.

					; For READ REVERSE with WRITECHECK,
	MOVB	#F_SP_FWD_REC!GO_BIT,-	;  we reposition FORWARD one block
		UCB$B_FEX(R5)		;  so as to be able to do the WRITECHECK
	BRB	40$			; And we branch around.
30$:
					; For READ FORWARD with WRITECHECK,
	MOVB	#F_SP_REV_REC!GO_BIT,-	;  we reposition back one block
		UCB$B_FEX(R5)		;  so as to be able to do the WRITECHECK
40$:
	BSBW	INTERNAL_SPACE		; Execute command in UCB$B_FEX
					;  for one tape position.
	BLBS	R0,START_WRITECHECK	; If positioning succeeds, branch to
					;  execute WRITECHECK.  Else fall thru.
READ_EXIT:
	BRW	FUNCTION_EXIT		; Branch to common exit.
	.PAGE
	.SBTTL	Start WRITELBLK or WRITEPBLK functions.

; START_WRITELBLK and START_WRITEPBLK
;
; INPUTS:
;	R3 => TM78 CSR
;	R5 => UCB
;

START_WRITELBLK:
START_WRITEPBLK:
	BSBW	WRITE_BLOCK		; Call internal subroutine to effect
					;  I/O data transfer.

	CMPW	R0,#SS$_ENDOFTAPE	; ENDOFTAPE is not really an ERROR.
	BEQL	10$			;  therefore branch around if we got it.

	BLBC	R0,WRITE_EXIT		; If transfer failed, branch to exit.
10$:
	BBS	#UCB$V_ERLOGIP,-	; If we had a recoverable write error,
		UCB$W_STS(R5),20$	;  force a DATACHECK operation.

	BBC	#IO$V_DATACHECK,-	; If no DATACHECK has been specified
		UCB$W_FUNC(R5),-	;  then we are finished so we branch
		WRITE_EXIT		;  around to exit.

20$:
	MOVB	#F_SP_REV_REC!GO_BIT,-	; Else we reposition back one block
		UCB$B_FEX(R5)		;  so as to be able to do the WRITECHECK
	BSBW	INTERNAL_SPACE		; Execute command in UCB$B_FEX
					;  for one tape position.
	BLBS	R0,WRITECHECK_FORWARD	; Branch to command WRITECHECK code,
					;  if we successfully positioned.  Else
					;  we fall thru.
WRITE_EXIT:
	BRW	FUNCTION_EXIT		; Branch to common exit.
	.PAGE
	.SBTTL	Start WRITECHECK function.

; START_WRITECHECK
;
; INPUTS:
;	R3 => TM78 CSR
;	R5 => UCB
;

START_WRITECHECK:
	BBC	#IO$V_REVERSE,-			; If NOT WRITECHECK REVERSE,
		UCB$W_FUNC(R5),-		;  branch around to handle it.
		WRITECHECK_FORWARD

						; WRITECHECK REVERSE.
	MOVB	#F_WRITE_CHECK_REV!GO_BIT,-	; Save Primary hardware opcode
		UCB$B_FEX(R5)			;  in the UCB.
	MOVB	#F_WRITE_CHECK_FWD!GO_BIT,-	; Save Secondary hardware OPCODE
		UCB$B_CEX(R5)			;  in the UCB also.
	BRB	WRITECHECK_COMMON		; And branch around.
WRITECHECK_FORWARD:
						; WRITECHECK FORWARD.
	MOVB	#F_WRITE_CHECK_FWD!GO_BIT,-	; Establish primary hardware OPCODE
		UCB$B_FEX(R5)			;  and save it in the UCB.
	MOVB	#F_WRITE_CHECK_REV!GO_BIT,-	; And save OPPOSITE hardware
		UCB$B_CEX(R5)			;  in the UCB also.
WRITECHECK_COMMON:
	BSBW	READ_OR_WRITECHECK_BLOCK	; Effectuate I/O transfer.
	BLBC	R0,WRITECHECK_EXIT		; Branch around if error.

	ASSUME	MBA$V_SR_WCKLWR  LT 16		; Assumptions that allow
	ASSUME	MBA$V_SR_WCKUPR  LT 16		;  word compare in following.
	BITW	#MBA$M_SR_WCKLWR!-		; See if we got a DATACHECK
		 MBA$M_SR_WCKUPR,-		;  comparison error.
		UCB$L_MFMBA_SR(R5)
	BNEQ	10$				; NEQ implies DATACHECK error

	BBC	#MT$V_EOT-16,-			; If NO DATACHECK, see if
		UCB$L_DEVDEPEND+2(R5),-		;  beyond the EOT on a write.
		WRITECHECK_EXIT			; If NOT, then branch around.
	MOVW	#SS$_ENDOFTAPE,R0		; If SO, return proper status
	BRB	WRITECHECK_EXIT			;  and branch around to exit.

10$:						; We had a DATACHECK error.
	CVTWL	UCB$L_MFMBA_BCR+2(R5),R0	; R0 now contains negative of
						;  # bytes left to transfer.
	MOVZWL	UCB$W_BCNT(R5),R1		; R1 has length of transfer.
	ADDL	R1,R0				; R0 = byte # of WORD following error.
	DECL	R0				; R0 = relative byte # of 2ND
						;  byte of WORD in error.
	CMPB	#F_WRITE_CHECK_FWD!GO_BIT,-	; See if a REVERSE operation.
		UCB$B_FEX(R5)
	BNEQ	20$				; NEQ implies REVERSE.

	BBS	#MBA$V_SR_WCKLWR,-		; For FORWARD operation 1ST
		UCB$L_MFMBA_SR(R5),30$		;  byte is LOW order byte.
	BRB	40$				; Branch around if 1st byte OK.
20$:						; For REVERSE 1ST byte is HIGH.
	BBC	#MBA$V_SR_WCKUPR,-		; So branch around decrement if
		UCB$L_MFMBA_SR(R5),40$		;  it is error free.
30$:
	DECL	R0				; R0 = relative byte # of 1ST
						;  byte of WORD in error.
40$:
	ASHL	#16,R0,R0			; Shift count to hi word of R0.
	MOVW	#SS$_DATACHECK,R0		; And indicate DATACHECK error.
WRITECHECK_EXIT:
	BRW	FUNCTION_EXIT		; Branch to common exit.
	.PAGE
	.SBTTL	READ TRANSFER ACTION TABLE

; READ_TAT - the following table is used by subroutine READ_OR_WRITECHECK_BLOCK
;	to determine the actions it should take as the result of the Hardware
;	Interrupt Code (HIC) that occurs after executing a TM78 read
;	command.  The TAT (Transfer Action Table) contains an entry for
;	each possible HIC that could be generated by a READ command.
;

READ_TAT:

	TAT_ENTRY	HIC_DONE,SS$_NORMAL,-
			POSITION=YES,COUNT=YES

	TAT_ENTRY	HIC_SHORT_REC,SS$_NORMAL,-
			POSITION=YES,COUNT=YES

	TAT_ENTRY	HIC_LONG_REC,SS$_DATAOVERUN,-
			POSITION=YES,COUNT=YES

	TAT_ENTRY	HIC_ERROR,SS$_DRVERR,-
			POSITION=YES,ERRLOG=YES

	TAT_ENTRY	HIC_TM,SS$_ENDOFFILE,-
			DEVDEPEND=MT$M_EOF,-
			PREVTM=YES,-
			POSITION=YES

	TAT_ENTRY	HIC_BOT,SS$_ENDOFFILE,-
			DEVDEPEND=MT$M_BOT,-
			PREVTM=YES

	TAT_ENTRY	HIC_NOT_CAPABLE,SS$_OPINCOMPL,-
			ERRLOG=YES

	TAT_ENTRY	HIC_OFF_LINE,SS$_MEDOFL

	TAT_ENTRY	HIC_NON_EX,SS$_NONEXDRV

	TAT_ENTRY	HIC_NOT_AVAIL,SS$_DRVERR,-
			ERRLOG=YES

	TAT_ENTRY	HIC_TU_FAULT_A,SS$_DRVERR,-
			DEVDEPEND=MT$M_LOST,-
			ERRLOG=YES

	TAT_ENTRY	HIC_TM_FAULT_A,SS$_CTRLERR,-
			DEVDEPEND=MT$M_LOST,-
			ERRLOG=YES

	TAT_ENTRY	HIC_BAD_TAPE,SS$_DRVERR,-
			DEVDEPEND=MT$M_LOST,-
			ERRLOG=YES

	TAT_ENTRY	HIC_UNREADABLE,SS$_DRVERR,-
			POSITION=YES,-
			ERRLOG=YES


	TAT_ENTRY	0,SS$_CTRLERR,-			; END OF TABLE.
			DEVDEPEND=MT$M_LOST,-
			ERRLOG=YES
	.PAGE
	.SBTTL	READ_OR_WRITECHECK_BLOCK


; READ_OR_WRITECHECK_BLOCK - internal subroutine to read or writecheck a
;	block.
;
; INPUTS:
;	UCB$B_FEX contains the primary hardware OPCODE to perform.
;	UCB$B_CEX contains the OPPOSITE hardware OPCODE to perform in case
;		we get READ_OPP status.
;	IO$V_REVERSE in UCB$W_FUNC is set if the primary OPCODE is a
;		reverse operation.
;	IO$V_INHRETRY in UCB$W_FUNC is set if we should inhibit RETRY
;		attempts.
;
;	R5 => UCB
;
; OUTPUTS:
;


READ_OR_WRITECHECK_BLOCK:
	SUBSAVE				; Save return point on the SUBSTACK.
	REQPCHAN			; Allocate the TM78.
	MOVL	R4,R3			; Copy so that R3 => TM78 CSR.
	REQSCHAN			; Allocate MBA. Returns R4 => MBA CSR.

	MOVZBW	UCB$B_FEX(R5),-		; Move primary command code and GO_BIT
		UCB$W_MF_CS1(R5)	;  to command template in UCB.

	MOVW	UCB$W_MF_TMPLTC(R5),-	; Copy template copy of TC register to
		UCB$W_MF_TC(R5)		;  other UCB word.
	BBC	#IO$V_INHRETRY,-	; Branch around setting of SER bit if
		UCB$W_FUNC(R5),1$	;  Inhibit RETRY is specified.
	BISW	#MF_TC_M_SER,-		; Set SER bit if INHRETRY specified.
		UCB$W_MF_TC(R5)
1$:
	MOVZWL	UCB$W_BCNT(R5),-
		MF_BC(R3)		; Copy BYTE COUNT to TM78 register.
					; NOTICE that we set up the byte count
					;  register before the retry label since
					;  the TM78 retry logic sets an appropriate
					;  value in this register which we would
					;  not not want to reset.

	MOVL	#MINIMUM_TIMEOUT,-	; Copy TIMEOUT parameter to UCB
		UCB$L_MF_TIMOUT(R5)	;  for safe keeping.

READ_WRITECHECK_RETRY:
	BSBW	LOAD_MBA_REGISTERS	; Call to set MBA registers.

	MOVZWL	UCB$W_MF_CS1(R5),-	; Record Hardware command about to
		UCB$L_MF_CMD(R5)	;  become the CURRENT command.
	MOVZWL	UCB$W_MF_TC(R5),-
		MF_TC(R3)		; Copy control info to TM78 register
					; NOTICE that this TM78 register is set
					;  after the RETRY label since there is
					;  a field in this register that we may
					;  wish to reset before the retry oper-
					;  ation.  This field is the RECORD
					;  COUNT field which is set to zero if
					;  we attempt a READ OPPOSITE.

	DSBINT				; Stop interrupts.
	PRIOR_TEST_TMRDY		; Assure that TM78 ready.
	BBS	#UCB$V_POWER,-		; Make sure we have not just had a
		UCB$W_STS(R5),3$	;  power failure.
	MOVZWL	UCB$W_MF_CS1(R5),-
		MF_CS1(R3)		; Copy command to TM78 register.
	WFIKPCH	4$,UCB$L_MF_TIMOUT(R5)
	POST_TEST_TMRDY			; Assure that TM78 ready.

	MOVL	MF_IS(R3),R2		; Copy interrupt status to available reg
	EXTZV	#MF_IS_V_DTIC,-		; Here we extract the interrupt code
		#MF_IS_S_DTIC,-		;  from the interrupt status returned
		R2,R2			;  by the TM78.
	CMPB	#HIC_NOT_RDY,R2		; Test for MANUAL REWIND or LOADING.
	BNEQ	2$			; If neither of the above, branch around
	BISW	#UCB$M_MF_REWIND,-	; If in the middle of manual REWIND,
		UCB$W_DEVSTS(R5)	;  then set appropriate bit.
	BRW	AWAIT_MANUAL_REWIND	; Branch to RELEASE CHANNELS, wait for
					;  rewind or load to finish, and then
					;  restart the I/O operation.

2$:	BSBW	SAVE_TM78_REGS		; Save copies of data transfer registers
	BSBW	SAVE_MBA_REGS		; Save copies of MBA registers
	IOFORK				; Lower IPL.

	BBC	#UCB$V_POWER,-		; Make sure we have not just had a
		UCB$W_STS(R5),6$	;  power failure.
	BRB	5$			; Branch around if we had POWERFAIL.
3$:	ENBINT
4$:	SETIPL	UCB$B_FIPL(R5)
	BSBW	SAVE_MBA_REGS		; Save copies of MBA registers
5$:	BSBW	TIMEOUT_POWERFAIL
	BRW	READ_BLOCK_EXIT
6$:	EXTZV	#MF_IS_V_DTIC,-		; Again we extract the interrupt code
		#MF_IS_S_DTIC,-		;  from the interrupt status returned
		UCB$L_MF_IS(R5),R0	;  by the TM78.

;
; The interrupt code is in R0.
;

	CMPB	#HIC_DONE,R0		; See if we received DONE interrupt code.
	BNEQ	8$			; If NOT, branch around.
	EXTZV	#MF_IS_V_DTFC,-		; Extract Data Transfer Failure Code
		#MF_IS_S_DTFC,-		;  if we had a DONE interrupt code.
		UCB$L_MF_IS(R5),R1	; And put this failure code in R1.
	BEQL	8$			; EQL implies no failure.
	BISW	#UCB$M_MF_SOFT_ERR,-	; Indicate to DEVICE_ERROR that we had
		UCB$W_DEVSTS(R5)	;  a soft error.
	BSBW	DEVICE_ERROR		; Do EXTENDED SENSE and log device error
8$:
	CMPB	#HIC_RETRY,R0		; See if the HIC must be handled
	BwEQL	140$			;  outside the Transfer Action Table
	CMPB	#HIC_READ_OPP,R0	;  logic.  Those HIC's that are
	BwEQL	150$			;  handled apart are RETRY, READ_OPP,
	CMPB	#HIC_SHORT_REC,R0	;  and SHORT_REC (the latter only in
	BNEQ	10$			;  the case that the last thing done
	CMPB	UCB$B_CEX(R5),-		;  was a READ_OPP).  Therefore if the
		UCB$W_MF_CS1(R5)	;  HIC = RETRY or READ_OPP, or the
	BwEQL	160$			;  HIC = SHORT_REC and UCB$B_CEX is
					;  the current command, we branch.

10$:
	MOVAB	READ_TAT,R1		; R1 => Read Transfer Action Table.
20$:
	CMPB	R0,TAT_HIC(R1)		; See if current HIC matches TAT entry.
	BEQL	40$			; If so, branch out of loop.
	TSTB	TAT_HIC(R1)		; See if we ran off end of table.
	BEQL	40$			; EQL implies End of Table.
	MOVAB	TAT_LENGTH(R1),R1	; R1 => next TAT entry.
	BRB	20$			; Loop back.
40$:
	BBC	#TAT_V_ERRLOG,-		; Branch around if NO error logging
		TAT_FLAGS(R1),50$	;  for this condition.
	BSBW	DEVICE_ERROR		; Do EXTENDED SENSE and log device error
50$:
	MOVZWL	TAT_SOFT_STAT(R1),R0	; Copy status to R0 for user.
	BISW	TAT_DEVDEPEND(R1),-	; Set the appropriate bits in UCB for
		UCB$L_DEVDEPEND+2(R5)	;  the current HIC.

	BBC	#MT$V_BOT-16,-		; If we are NOT at BOT, then we
		TAT_DEVDEPEND(R1),55$	;  branch around.
	CLRL	UCB$L_MF_RECORD(R5)	; Else we update position.
	BICW	#<MT$M_LOST>@-16,-	; And we are definitely not LOST
		UCB$L_DEVDEPEND+2(R5)	;  anymore.
55$:
	BBC	#TAT_V_POSITION,-	; See if the tape position indicator
		TAT_FLAGS(R1),70$	;  should be updated.  Branch if not.
	BBS	#IO$V_REVERSE,-		; A reverse operation implies decrement
		UCB$W_FUNC(R5),60$	;  while forward motion means increment.
	INCL	UCB$L_MF_RECORD(R5)	; Increment when we read forward.
	BRB	70$			; Branch around decrement.
60$:
	DECL	UCB$L_MF_RECORD(R5)	; Decrement when we read backward.
70$:
	BBC	#TAT_V_COUNT,-		; Branch around if we should NOT return
		TAT_FLAGS(R1),80$	;  the byte count of data transferred.
	INSV	UCB$L_MF_BC(R5),-	; Return the number of bytes
		#16,#16,R0		;  transferred in the high word of R0.
80$:
	BBC	#TAT_V_PREVTM,-		; Branch around if we should NOT
		TAT_FLAGS(R1),100$	;  update PREVTM.
	BBS	#IO$V_REVERSE,-		; See if operation is reverse.
		UCB$W_FUNC(R5),90$	; And if so, branch to put negative 2.
	MOVL	UCB$L_MF_RECORD(R5),-	; Copy current tape position to PREVTM.
		UCB$L_MF_PREVTM(R5)	;
	BRB	100$			; Branch around reverse motion actions.
90$:
	MNEGL	#2,UCB$L_MF_PREVTM(R5)	; Indicate unknown previous TAPEMARK.
100$:
	BRB	READ_BLOCK_EXIT		; Branch around to exit.

140$:
	BSBW	DEVICE_ERROR		; Do EXTENDED SENSE and log device error
	INSV	#1,-			; Set RECORD COUNT to 1 in case it
		#MF_TC_V_RC,-		;  had been reset by a READ OPPOSITE
		#MF_TC_S_RC,-		;  in a previous RETRY.
		UCB$W_MF_TC(R5)

	MOVZBW	UCB$B_FEX(R5),-		; Copy primary OPCODE to template
		UCB$W_MF_CS1(R5)	;  copy of CSR in UCB.
	BRW	READ_WRITECHECK_RETRY	; And branch back to retry.

150$:
	BSBW	DEVICE_ERROR		; Do EXTENDED SENSE and log device error

	MOVL	UCB$L_MF_BC(R3),R1	; R1 = best guess as to record length.
	CMPW	R1,UCB$W_BCNT(R5)	; See if larger than buffer.
	BGTRU	170$			; If so, branch around.
160$:					; Here we attempt a READ OPPOSITE.
	BICW	#MF_TC_M_RC,-		; Clear the record count prior to READ
		UCB$W_MF_TC(R5)		;  OPPOSITE.
	MOVZBW	UCB$B_CEX(R5),-		; Copy opposite OPCODE to template
		UCB$W_MF_CS1(R5)	;  copy of CSR in UCB.
	BRW	READ_WRITECHECK_RETRY	; And branch back to retry.

170$:					; Here if record too long for READ OPPOSITE

	BBS	#IO$V_REVERSE,-		; See if we are doing REVERSE operation.
		UCB$W_FUNC(R5),173$	; And if so, branch.
	INCL	UCB$L_MF_RECORD(R5)	; If FORWARD, increment position count.
	BRB	176$			; And branch around.
173$:
	DECL	UCB$L_MF_RECORD(R5)	; Decrement count for REVERSE movement.
176$:
	DSBINT				; HERE WE GET THE TM78 TO STOP ERROR RETRIES.
	PRIOR_TEST_TMRDY		; Assure that TM78 ready.
	MOVZWL	UCB$W_UNIT(R5),R0	; R0 = unit number of this drive.
	MOVZWL	#F_NOP!GO_BIT,-		; Move NDT NOP command to NDT command
		MF_NDT0(R3)[R0]		;  register.
	WFIKPCH	180$,#MINIMUM_TIMEOUT	; Should be immediate.
	POST_TEST_TMRDY			; Assure that TM78 ready.
	IOFORK
180$:
	SETIPL	UCB$B_FIPL(R5)		; Lower IPL in case of TIMEOUT.
	MOVZWL	#SS$_DRVERR,R0		; Indicate drive error.
READ_BLOCK_EXIT:

	SUBPUSH	R0			; Save R0 on SUBSTACK.

	RELCHAN

	SUBPOP	R0			; Likewise R0.

	SUBRETURN
	.PAGE
	.SBTTL	WRITE TRANSFER ACTION TABLE

; WRITE_TAT - the following table is used by subroutine WRITE_BLOCK to
;	determine the actions it should take as the result of the Hardware
;	Interrupt Code (HIC) that occurs after executing a TM78 write
;	command.  The TAT (Transfer Action Table) contains an entry for
;	each possible HIC that could be generated by a WRITE command.
;

WRITE_TAT:

	TAT_ENTRY	HIC_DONE,SS$_NORMAL,-
			POSITION=YES,COUNT=YES

	TAT_ENTRY	HIC_EOT,SS$_ENDOFTAPE,-
			DEVDEPEND=MT$M_EOT,-
			POSITION=YES,COUNT=YES

	TAT_ENTRY	HIC_FPT,SS$_WRITLCK,-
			DEVDEPEND=MT$M_HWL

	TAT_ENTRY	HIC_ERROR,SS$_DRVERR,-
			POSITION=YES,ERRLOG=YES

	TAT_ENTRY	HIC_BAD_TAPE,SS$_DRVERR,-
			POSITION=YES,ERRLOG=YES

	TAT_ENTRY	HIC_EOT_ERROR,SS$_DRVERR,-
			DEVDEPEND=MT$M_EOT,-
			POSITION=YES,ERRLOG=YES

	TAT_ENTRY	HIC_NON_EX,SS$_NONEXDRV,-
			ERRLOG=YES

	TAT_ENTRY	HIC_NOT_AVAIL,SS$_DRVERR,-
			ERRLOG=YES

	TAT_ENTRY	HIC_OFF_LINE,SS$_MEDOFL

	TAT_ENTRY	HIC_TU_FAULT_A,SS$_DRVERR,-
			DEVDEPEND=MT$M_LOST,-
			ERRLOG=YES

	TAT_ENTRY	HIC_TM_FAULT_A,SS$_CTRLERR,-
			DEVDEPEND=MT$M_LOST,-
			ERRLOG=YES

	TAT_ENTRY	0,SS$_CTRLERR,-			; END OF TABLE.
			DEVDEPEND=MT$M_LOST,-
			ERRLOG=YES
	.PAGE
	.SBTTL	WRITE_BLOCK

; WRITE_BLOCK - internal subroutine to write a block.
;
; INPUTS:
;	IO$V_INHRETRY in UCB$W_FUNC is set if we should inhibit RETRY
;
;	R5 => UCB
;
; OUTPUTS:
;
;

WRITE_BLOCK:
	SUBSAVE				; Save return point on the SUBSTACK.
	REQPCHAN			; Allocate the TM78.
	MOVL	R4,R3			; Copy so that R3 => TM78 CSR.
	REQSCHAN			; Allocate MBA. Returns R4 => MBA CSR.
	MOVZBL	#F_WRITE_PE!GO_BIT,R0	; Load write 1600 BPI command to R0.
	TSTB	UCB$B_MF_DENSITY(R5)	; Zero implies 1600 BPI on tape.
	ASSUME	MF$K_DENSITY_1600  EQ  0
	BEQL	10$			; Branch if it is indeed 1600.
	MOVZBL	#F_WRITE_GCR!GO_BIT,R0	; Else load write 6250 BPI command in R0
10$:
	MOVW	R0,UCB$W_MF_CS1(R5)	; Remember command in UCB.

	MOVW	UCB$W_MF_TMPLTC(R5),-	; Copy template copy of TC register to
		UCB$W_MF_TC(R5)		;  other UCB word.
	BBC	#IO$V_INHRETRY,-	; Branch around setting of SER bit if
		UCB$W_FUNC(R5),20$	;  Inhibit RETRY is specified.
	BISW	#MF_TC_M_SER,-		; Set SER bit if INHRETRY specified.
		UCB$W_MF_TC(R5)
20$:
	MOVL	#MINIMUM_TIMEOUT,-	; Copy TIMEOUT parameter to UCB
		UCB$L_MF_TIMOUT(R5)	;  for safe keeping.
	MOVZWL	UCB$W_BCNT(R5),-
		MF_BC(R3)		; Copy BYTE COUNT to TM78 register.

	MOVZWL	UCB$W_MF_TC(R5),-
		MF_TC(R3)		; Copy control info to TM78 register
WRITE_RETRY:
	BSBW	LOAD_MBA_REGISTERS	; Set MBA registers.
	MOVZWL	UCB$W_MF_CS1(R5),-	; Record Hardware command about to
		UCB$L_MF_CMD(R5)	;  become the CURRENT command.
	BICW	#<MT$M_BOT!-		; Clear beginning of tape and,
		  MT$M_EOF!-		;  End of File and
		  MT$M_EOT!-		;  End of Tape and
		  MT$M_HWL>@-16,-	;  Hardware Write Lock
		UCB$L_DEVDEPEND+2(R5)
	DSBINT				; Stop interrupts.
	PRIOR_TEST_TMRDY		; Assure that TM78 ready.
	BBS	#UCB$V_POWER,-		; Make sure we have not just had a
		UCB$W_STS(R5),40$	;  power failure.
	MOVZWL	UCB$W_MF_CS1(R5),-
		MF_CS1(R3)		; Copy command to TM78 register.
	WFIKPCH	50$,UCB$L_MF_TIMOUT(R5)
	POST_TEST_TMRDY			; Assure that TM78 ready.

	MOVL	MF_IS(R3),R2		; Interrupt status to available register
	EXTZV	#MF_IS_V_DTIC,-		; Here we extract the interrupt code
		#MF_IS_S_DTIC,-		;  from the interrupt status returned
		R2,R2			;  by the TM78.
	CMPB	#HIC_NOT_RDY,R2		; Test for manual REWIND or LOADING.
	BNEQ	30$			; If neither of the above, branch around
	BISW	#UCB$M_MF_REWIND,-	; If in the middle of manual REWIND,
		UCB$W_DEVSTS(R5)	;  then set appropriate bit.
	BRW	AWAIT_MANUAL_REWIND	; Branch to RELEASE CHANNELS, wait for
					;  rewind or load to finish, and then
					;  restart the I/O operation.

30$:	BSBW	SAVE_TM78_REGS		; Save copies of data transfer registers
	BSBW	SAVE_MBA_REGS		; Save copies of MBA registers
	IOFORK				; Lower IPL.

	BBC	#UCB$V_POWER,-		; Make sure we have not just had a
		UCB$W_STS(R5),60$	;  power failure.
	BRB	55$			; Branch around if POWERFAIL.
40$:	ENBINT
50$:	SETIPL	UCB$B_FIPL(R5)
	BSBW	SAVE_MBA_REGS		; Save copies of MBA registers
55$:	BSBW	TIMEOUT_POWERFAIL
	BRW	WRITE_BLOCK_EXIT
60$:	EXTZV	#MF_IS_V_DTIC,-		; Again we extract the interrupt code
		#MF_IS_S_DTIC,-		;  from the interrupt status returned
		UCB$L_MF_IS(R5),R0	;  by the TM78.

;
; The interrupt code is in R0.
;

	CMPB	#HIC_DONE,R0		; See if we received DONE interrupt code.
	BNEQ	65$			; If NOT, branch around.
	EXTZV	#MF_IS_V_DTFC,-		; Extract Data Transfer Failure Code
		#MF_IS_S_DTFC,-		;  if we had a DONE interrupt code.
		UCB$L_MF_IS(R5),R1	; And put this failure code in R1.
	BEQL	65$			; EQL implies no failure.
	BISW	#UCB$M_MF_SOFT_ERR,-	; Indicate to DEVICE_ERROR that we had
		UCB$W_DEVSTS(R5)	;  a soft error.
	BSBW	DEVICE_ERROR		; Do EXTENDED SENSE and log device error
65$:
	CMPB	#HIC_RETRY,R0		; Should we attempt a retry?
	BNEQ	70$			; If so, branch around.
	BSBW	DEVICE_ERROR		; Do EXTENDED SENSE and log device error

	BRW	WRITE_RETRY		; Branch back to try again.

;
; Here we use the WRITE_TAT (Write Transfer Action Table) to determine the
;	actions to take as a result of the WRITE COMMAND we have just executed.
;

70$:
	MOVAB	WRITE_TAT,R1		; R1 => WRITE Transfer Action Table.
80$:
	CMPB	R0,TAT_HIC(R1)		; See if this TAT entry corresponds to
					;  the current Hardware Interrupt Code.
	BEQL	100$			; If so, branch out of loop.
	TSTB	TAT_HIC(R1)		; Test for end of table.
	BEQL	100$			; EQL implies End of Table.
	MOVAB	TAT_LENGTH(R1),R1	; R1 => next TAT entry.
	BRB	80$			; And branch back to loop start.
100$:					; If here, R1 => correct TAT entry.
	BBC	#TAT_V_ERRLOG,-		; Branch around if NO error logging
		TAT_FLAGS(R1),110$	;  for this condition.
	BSBW	DEVICE_ERROR		; Do EXTENDED SENSE and log device error
110$:
	MOVZWL	TAT_SOFT_STAT(R1),R0	; Copy status to R0 for user.
	BISW	TAT_DEVDEPEND(R1),-	; Set the appropriate bits in UCB for
		UCB$L_DEVDEPEND+2(R5)	;  the current HIC.
	BBC	#TAT_V_POSITION,-	; See if the tape position indicator
		TAT_FLAGS(R1),120$	;  should be updated.  Branch if not.
	INCL	UCB$L_MF_RECORD(R5)	; Increment since we always write forward.
120$:
	BBC	#TAT_V_COUNT,-		; Branch around if we should NOT return
		TAT_FLAGS(R1),130$	;  the byte count of data transferred.
	INSV	UCB$L_MF_BC(R5),-	; Return the number of bytes
		#16,#16,R0		;  transferred in the high word of R0.
130$:
WRITE_BLOCK_EXIT:

	SUBPUSH	R0			; Save R0 on SUBSTACK.

	RELCHAN				; Release all channels.

	SUBPOP	R0			; Likewise R0.

	SUBRETURN			; Return to caller.
	.PAGE
	.SBTTL	LOAD_MBA_REGISTERS


; LOAD_MBA_REGISTERS
;
; INPUTS:
;	R3 => TM78 CSR
;	UCB$W_MF_CS1(R5) = HARDWARE OPCODE FOR DATA TRANSFER
;	UCB$W_BOFF(R5) = BYTE OFFSET IN PAGE OF TRANSFER
;	MF_BC(R3) = BYTE COUNT
;	R4 => MBA CSR
;		it is assumed that both channels are owned.
;
; OUTPUTS:
;	MBA MAP REGISTERS AND MBA$L_VAR ARE LOADED.
; Note this internal subroutine does NOT do a SUBSAVE upon entry and a
;	SUBRETURN at exit since it is assured that it cannot lose control
;	during its execution.  It can therefore use the normal stack to
;	save its return point and temporary variables.
;

LOAD_MBA_REGISTERS:

	MCOML	#0,MBA$L_SR(R4)	; Clear MASSBUS adapter errors.
	LOADMBA			; Load MBA map registers.

;
; The following section of code was put here to correct a timing glitch that
;	introduces erros on systems where the TM78 is connected to the MBA by
;	a MASSBUS cable less than 100 feet in length.  The problem occurs in
;	writing odd length records.  Apparently the MBA shuts down before
;	transferring the last byte.  The work around is to load the MBA byte
;	count register with a count one greater than the desired transfer
;	length.  The TM78 byte count register still contains the correct count.
;	If this incrementation of the transfer length happens to overflow the
;	apparent transfer to a new page, then this must be handled by providing
;	a valid MBA map register value in the currently last position (i.e. the
;	one with the invalid entry) and by moving the invalid value down one
;	slot.  Since the contents of this new last entry is not pertinent, (i.e.
;	it only needs to be valid so as to not cause an invalid access) we
;	merely replicate the current last valid value into the new last position.
;	All of this is, needless to say, extremely ugly!!!
;

	MOVL	MF_BC(R3),R1		; Get byte count from TM78 register.
	MOVZWL	R1,R1			; Erase high word of register.
	BLBC	R1,20$			; If EVEN byte count branch around
					;  timing glitch workaround.
	CMPB	#F_WRITE_PE!GO_BIT,-	; If ODD byte count, see if a WRITE
		UCB$W_MF_CS1(R5)	;  operation at 1600 BPI.
	BEQL	10$			; If yes, WRITE branch.
	CMPB	#F_WRITE_GCR!GO_BIT,-	; Still ODD byte count see if WRITE
		UCB$W_MF_CS1(R5)	;  operation at 6250 BPI.
	BNEQ	20$			; If NOT write of any kind branch.
10$:
					; If here we have an ODD byte count on
					;  a WRITE operation
	MOVZWL	UCB$W_BOFF(R5),R0	; We must determine if we will overflow
					;  onto a new page by bumping count.
	ADDL	R1,R0			; R0 contains MBA virtual address of
					;  last byte of transfer including
					;  increment.

	INCL	R1			; Increment count to next higher even.
	MNEGL	R1,MBA$L_BCR(R4)	; Move incremented negated count to MBA.

	CMPZV	#0,#9,R0,#0		; If overflowed, then low order is zero.
	BNEQ	40$			; If not zero, then ok, so branch around
	ASHL	#-9,R0,R0		; Get # valid MBA map registers used.
	MOVL	MBA$L_MAP(R4)[R0],R1	; Get invalid map register value.
	MOVL	R1,MBA$L_MAP+4(R4)[R0]	;  And move it up one position.
	MOVL	MBA$L_MAP-4(R4)[R0],R1	; Now get last valid entry.
	MOVL	R1,MBA$L_MAP(R4)[R0]	;  And also slide it up one slot.
	BRB	40$			; And branch around rest since we
					;  know that we have no REVERSE.
20$:
					; R1 contains transfer byte count.

	CMPB	#F_READ_REV!GO_BIT,-
		UCB$W_MF_CS1(R5)		; Is it a REVERSE read?
	BEQL	30$				; If so, branch.
	CMPB	#F_WRITE_CHECK_REV!GO_BIT,-
		UCB$W_MF_CS1(R5)		; Is it a REVERSE writecheck?
	BNEQ	40$				; If NOT, then skip around
						;  since MBA$L_VAR is ok.
30$:
	DECL	R1			; Decrement transfer byte count.
	ADDL	R1,MBA$L_VAR(R4)	; Calculate ending address of buffer
					;  for REVERSE operation.
40$:
	RSB				; Return to caller.
	.PAGE
	.SBTTL	INTERNAL_SPACE

; INTERNAL_SPACE - subroutine to space the tape one position.
;
; INPUTS:
;
;	UCB$B_FEX(R5) - contains hardware command; either F_SP_FWD_REC!GO_BIT or
;			F_SP_REV_REC!GO_BIT
;
; OUTPUTS:
;
;	R0 = success or failure code.
;	UCB$L_MF_RECORD is updated if the tape is moved.
;

INTERNAL_SPACE:

	SUBSAVE				; Save return point on SUBSTACK.
	MOVZBL	UCB$B_FEX(R5),R0	; Copy hardware command to R0.

	MOVL	UCB$L_CRB(R5),R3		; R3=>TM78-CRB.
	ASSUME	IDB$L_CSR  EQ  0
	MOVL	@CRB$L_INTD+VEC$L_IDB(R3),R3	; R3=>TM78-CSR.

	EX_NDT_CMD	CMD=R0,-		; Execute space command
			REPEAT=#1,-		;  to space one position
			TIMEOUT=#MINIMUM_TIMEOUT,-;  which shouldn't take long.
			ERROR_LABEL=50$

;
; HARDWARE STATUS RETURNED IN R0.
;

	CMPB	#HIC_DONE,R0		; Done successfully?
	BNEQ	30$			; If not, branch around.
	CMPB	#F_SP_REV_REC!GO_BIT,-	; If yes, see if we moved forward or
		UCB$B_FEX(R5)		;  backward.
	BEQL	10$			; If backward, branch.
	INCL	UCB$L_MF_RECORD(R5)	; If forward, increment position count.
	BRB	20$			;  and branch around.
10$:	DECL	UCB$L_MF_RECORD(R5)	; If backward, decrement.
20$:	MOVZWL	S^#SS$_NORMAL,R0	; Indicate successful spacing operation.
	BRB	50$			; And branch to exit.

30$:					; Here if some kind of error.
	BSBW	DEVICE_ERROR		; Do EXTENDED SENSE and log device error

	CMPB	#HIC_TM_FAULT_A,R0	; See if it was a controller failure.
	BNEQ	40$			; If not, branch around.
	MOVZWL	#SS$_CTRLERR,R0		; Else indicate controller problem.
	BRB	50$			; And branch to common exit.
40$:
	MOVZWL	#SS$_DRVERR,R0		; Indicate drive error.
50$:	SUBRETURN			;
	.PAGE
	.SBTTL	TIMEOUT_POWERFAIL

; TIMEOUT_POWERFAIL - we call here if we have experienced either a TIMEOUT
;	or a POWERFAILure.
;
; INPUTS:
;
;	R3 => TM78 CSR
;	R5 => UCB
;
; OUTPUTS:
;
;	In the case of TIMEOUT, various things are recorded in the UCB:
;
;
;	In the case of POWERFAIL, 
;
;
;
;


TIMEOUT_POWERFAIL:
REPOSITION:
	BBC	#UCB$V_MF_POWER,-	; Do NOT enter this routine RECURSIVELY.
		UCB$W_DEVSTS(R5),10$	;  Branch around only if bit clear.
	RSB				; Return immediately if RECURSIVE call.
10$:
	BISW	#UCB$M_MF_POWER,-	; Set bit to prevent RECURSIVE entry.
		UCB$W_DEVSTS(R5)
	SUBSAVE				; Pop return off stack and onto SUBSTACK
	RELCHAN				; Release any channels.
	BICW	#UCB$M_MF_REWIND,-
		UCB$W_DEVSTS(R5)	; Clear rewind in progress.
	BISW	#<MT$M_LOST@-16>,-
		UCB$L_DEVDEPEND+2(R5)	; Set position lost.
	BBSC	#UCB$V_POWER,-
		UCB$W_STS(R5),POWERFAIL	; Branch and clear if powerfail.
	BBS	#UCB$V_MF_REPOS,-	; Treat REPOSITIONING request as if
		UCB$W_DEVSTS(R5),-	;  it were a POWERFAIL.
		POWERFAIL
TIMEOUT:
	BSBW	SAVE_TM78_REGS			; Save TM78 regs for ERROR LOG
	JSB	G^ERL$DEVICTMO			; Log device time out.

	MOVL	UCB$L_CRB(R5),R4		; R4 => TM78 CRB.
	MOVL	CRB$L_LINK(R4),R4		; R4 => MBA CRB.
	MOVL	CRB$L_INTD+VEC$L_IDB(R4),R4	; R4 => MBA IDB
	CMPL	R5,IDB$L_OWNER(R4)		; Are we owners of the MBA.
	BNEQ	20$				; If not, branch around.

	MOVL	IDB$L_CSR(R4),R4	; R4 => MBA CSR.
	DSBINT				; We want to abort the operation.
	MOVL	#MBA$M_CR_ABORT!-
		 MBA$M_CR_IE,-		; Set abort and interrupt enable
		MBA$L_CR(R4)		; In MBA control register.
	WFIKPCH	10$,#15			; Wait for abort and keep channel.
	IOFORK
10$:
	MOVL	#MBA$M_CR_INIT,-
		MBA$L_CR(R4)		; Initialize entire MBA.
	MOVL	#MBA$M_CR_IE,-
		MBA$L_CR(R4)		; And enable MBA interrupts.
20$:	SETIPL	UCB$B_FIPL(R5)		; Lower IPL to device level.

TIMEOUT_RETURN:
	RELCHAN				; In case we own the channel(s).
	BICW	#UCB$M_MF_POWER,-
		UCB$W_DEVSTS(R5)	; Clear bit to prevent RECURSIVE entry.
	BICW	#UCB$M_VALID,-
		UCB$W_STS(R5)		; Set volume - SOFTWARE INVALID.
	MOVZWL	#SS$_TIMEOUT,R0		; Indicate final status.
	SUBRETURN			; Return to caller with TIMEOUT status.

POWERFAIL:
	RELCHAN				; In case we own the channel(s).
	BICW	#UCB$M_MF_REPOS,-	; Clear bit in case also at POWERFAIL.
		UCB$W_DEVSTS(R5)
	BBC	#UCB$V_VALID,-
		UCB$W_STS(R5),-
		TIMEOUT_RETURN		; If invalid, treat as TIMEOUT.

	REWIND	WAIT=YES,ERROR_LABEL=10$; Here we try to rewind the drive
					;  if we still have vacuum in the
					;  columns.  If it works we branch to
	CMPB	#HIC_DONE,R0		;  80$.  The status is returned in R0.
	BwEQL	80$			; If it doesn't work for any reason we
					;  wind up at 10$.

;
; Here we will wait for the drive to be rewound manually.
;

10$:	CLRB	UCB$B_CEX(R5)		; Clear byte we use for message time counter
20$:	MOVL	UCB$L_CRB(R5),R3	; R3 => TM78 CRB.
	ASSUME	IDB$L_CSR  EQ  0
	MOVL	@CRB$L_INTD+VEC$L_IDB(R3),R3	; R3 => TM78 CSR

	DSBINT
	WFIKPCH	30$,#2				; Waste some time.
	IOFORK
30$:	SETIPL	UCB$B_FIPL(R5)			; Lower IPL to fork level.
	REQPCHAN				; Sequentialize access to TM78.
	BwBS	#UCB$V_MF_CNCLP,-	; If CANCEL pending set while we were
		UCB$W_DEVSTS(R5),190$	;  resource waiting, branch around to end.

	DSBINT				; Here we will get SENSE info.
	PRIOR_TEST_TMRDY		; Assure that TM78 ready.
	BBSC	#UCB$V_POWER,-
		UCB$W_STS(R5),40$	; Branch if another POWERFAIL.
	MOVZWL	UCB$W_UNIT(R5),R0	; R0 = unit number of this drive.
	MOVZBL	#F_SENSE!GO_BIT,-	; Record Hardware command about to
		UCB$L_MF_CMD(R5)	;  become the CURRENT command.
	MOVZBL	#F_SENSE!GO_BIT,-
		MF_NDT0(R3)[R0]		; Set command in device.
	WFIKPCH	50$,#MINIMUM_TIMEOUT	; Wait for interrupt.
	POST_TEST_TMRDY			; Assure that TM78 ready.
	MOVL	UCB$L_MF_NDTA(R5),-	; Copy NDT attention data for this
		UCB$L_MF_NDTA_C(R5)	;  interrupt to stable place.
	MOVL	MF_DS(R3),-
		UCB$L_MF_DS(R5)		; Save pertinent register from SENSE.
	IOFORK
	BBSC	#UCB$V_POWER,-
		UCB$W_STS(R5),45$	; Branch if another POWERFAIL.
	RELCHAN				; Release the channel.
	BRB	60$			; Branch around.

40$:	ENBINT				; We had another POWERFAIL.
45$:	BRW	POWERFAIL		; Branch back to start again.

50$:	SETIPL	UCB$B_FIPL(R5)		; We timed out on the SENSE.
	BRW	TIMEOUT			; Branch back to record TIMEOUT.

60$:					; We have the SENSE info.
	EXTZV	#MF_NDTA_V_NDIC,-	; Extract the interrupt code from
		#MF_NDTA_S_NDIC,-	;  the status code returned as a result
		UCB$L_MF_NDTA_C(R5),R0	;  of the SENSE command.
	CMPB	#HIC_DONE,R0		; See if SENSE was a success.
	BEQL	65$			; EQL => yes.
	BRW	170$			; If not successful, branch to FATAL error.

65$:	MOVZWL	UCB$L_MF_DS(R5),R2	; R2 has SENSE info.
	BBS	#MF_DS_V_REW,R2,75$	; Branch if REWINDING.
	BBC	#MF_DS_V_ONL,R2,70$	; Branch forward if offline.
	BBS	#MF_DS_V_BOT,R2,80$	; Branch out of loop if at BOT.
70$:
	ACBB	#15,#1,UCB$B_CEX(R5),20$; Loop 15 times between operator messages.
	MOVZBL	#MSG$_DEVOFFLIN,R4	; Get message number.
	MOVAB	G^SYS$GL_OPRMBX,R3	; R3 => operator mailbox.
	JSB	G^EXE$SNDEVMSG		; Send message to operator.
75$:	BRW	10$			; Go kill some more time.

80$:
;
; Medium on-line and positioned at Bottom Of Tape.
;	We want to position the volume to its position at the start of the
;	current I/O operation, i.e. to the position indicated by UCB$L_MF_ORGPOS.
;

90$:	CLRL	UCB$L_MF_RECORD(R5)	; Clear current tape position indicator.
	BISW	#<MT$M_BOT@-16>,-	; Set BOT bit on in UCB field.
		UCB$L_DEVDEPEND+2(R5)
	BICW	#<MT$M_LOST@-16>,-	; Clear the fact that we may have
		UCB$L_DEVDEPEND+2(R5)	;  been lost

	MOVZBW	#F_SP_FWD_EITHER!GO_BIT,-
		UCB$W_MF_NDTCR(R5)	; Setup space command template.
100$:
	SUBL3	UCB$L_MF_RECORD(R5),-
		UCB$L_MF_ORGPOS(R5),R0	; R0 = how much more to space.
	BwEQL	180$			; Branch around if all done.
105$:
	CMPL	#255,R0			; See if greater than register limit.
	BGEQ	110$			; If 255 > count, branch to use count.
	MOVZBL	#255,R0			; If count > 255, use 255.
110$:
	ASSUME	MF_NDT0_S_CCNT  EQ  8	; Assume count field in register is
	ASSUME	MF_NDT0_V_CCNT  EQ  8	;  located in high byte.
	MOVB	R0,UCB$W_MF_NDTCR+1(R5)	; Complete command template with count.
	MOVZWL	UCB$W_MF_NDTCR(R5),-	; Record Hardware command about to
		UCB$L_MF_CMD(R5)	;  become the CURRENT command.

	REQPCHAN			; Sequentialize access to TM78.
	BwBS	#UCB$V_MF_CNCLP,-	; If CANCEL pending set while we were
		UCB$W_DEVSTS(R5),190$	;  resource waiting, branch around to end.

	DSBINT
	PRIOR_TEST_TMRDY		; Assure that TM78 ready.
	BBSC	#UCB$V_POWER,-
		UCB$W_STS(R5),120$	; Forget it if another POWERFAIL.
	MOVZWL	UCB$W_UNIT(R5),R0	; Pickup unit number.
	MOVZWL	UCB$W_MF_NDTCR(R5),-	; Move command template to
		MF_NDT0(R3)[R0]		;  device register to initiate command.
	WFIKPCH	130$,#TU78_MAX_SPACE	; Longest space should terminate in
	POST_TEST_TMRDY			; Assure that TM78 ready.
					;  less than 60 seconds.
	MOVL	UCB$L_MF_NDTA(R5),-	; Copy NDT attention data for this
		UCB$L_MF_NDTA_C(R5)	;  interrupt to stable place.
	BSBW	SAVE_TM78_REGS		; Save hardware registers for ERROR LOG
	IOFORK
	BBSC	#UCB$V_POWER,-
		UCB$W_STS(R5),125$	; If another POWERFAIL, branch and clear.
	RELCHAN				; Else release the channel.
	BRB	140$			;  and branch around to continue.
120$:	ENBINT				; Enable after pre-POWERFAIL.
125$:	BRW	150$			; Branch to restart entire rewind, etc.

130$:	SETIPL	UCB$B_FIPL(R5)		; After TIMEOUT on space, lower IPL and
	BRW	TIMEOUT			; Branch back to treat as TIMEOUT.

140$:	EXTZV	#MF_NDTA_V_NDIC,-	; Extract the interrupt code from
		#MF_NDTA_S_NDIC,-	;  the status code returned as a result
		UCB$L_MF_NDTA_C(R5),R0	;  of the space command.
	CMPB	#HIC_DONE,R0		; See if it is a success.
	BEQL	160$			; If EQL, then OK so branch.

	CMPB	#HIC_OFF_LINE,R0	; See if drive has gone off-line.
	BNEQ	170$			; NEQ => some hardware error
150$:
	BRW	POWERFAIL		; We had another POWERFAIL
					;  so branch back to try again.

160$:					; Here we apparently successfully spaced
					;  forward a group of records and TAPEMARKs.
	ASSUME	MF_NDT0_S_CCNT  EQ  8
	ASSUME	MF_NDT0_V_CCNT  EQ  8	; Assume command register format.
	MOVZBL	UCB$W_MF_NDTCR+1(R5),R0	; Pickup number of places spaced over.
	ADDL	R0,UCB$L_MF_RECORD(R5)	; Update position variable in UCB.
	BRW	100$			; Branch back to continue spacing.

170$:					; We had a fatal HARDWARE error.
	BICW	#UCB$M_MF_POWER,-
		UCB$W_DEVSTS(R5)	; Clear bit to prevent RECURSIVE entry.
	BICW	#UCB$M_VALID,-
		UCB$W_STS(R5)		; Indicate invalid volume.

	BSBW	DEVICE_ERROR		; Do EXTENDED SENSE and log device error

	MOVZWL	#SS$_DRVERR,R0		; Indicate error status.
	SUBRETURN			; Return to caller.

180$:					; Here we have successfully repositioned.
	BICW	#UCB$M_MF_POWER,-
		UCB$W_DEVSTS(R5)	; Clear bit to prevent RECURSIVE entry.
	BICW	#<MT$M_LOST@-16>,-
		UCB$L_DEVDEPEND+2(R5)	; Clear lost position bit.
	BISW	#UCB$M_VALID,-
		UCB$W_STS(R5)		; Indicate VALID volume.
	MOVL	UCB$L_MF_ORGPTM(R5),-	; Restore value of position of
		UCB$L_MF_PREVTM(R5)	;  previous TAPEMARK.
	BRW	TF_RESTARTIO		;  branch to restart I/O function.

190$:					; CANCEL pending flag noticed.
	BICW	#UCB$M_MF_POWER!UCB$M_MF_CNCLP,-
		UCB$W_DEVSTS(R5)	; Clear flag signalling that we are
					;  repositioning AND that CANCEL was
					;  signalled.
	BICW	#UCB$M_VALID,-
		UCB$W_STS(R5)		; Set volume software invalid.
	MOVL	#SS$_ABORT,R0		; Set abort status.
	BRW	FUNCTION_EXIT		; Branch to end function.
	.PAGE
	.SBTTL	REWIND_ROUTINE

; REWIND_ROUTINE - routine to execute a hardware REWIND or UNLOAD command,
;	wait for it to be done if bit IO$M_NOWAIT in R1 is clear, and
;	return the hardware HIC code in R0.  If we experience TIMEOUT or
;	POWERFAIL and the TIMEOUT_POWERFAIL returns to us we take the
;	error exit.  Else we return to 2 beyond the calling address.
;
; INPUTS:
;	R0 = Hardware command and GO_BIT (REWIND or UNLOAD)
;	R1 = Bitmask whose only bit of interest is IO$M_NOWAIT
;	R3 => TM78 CSR
;	R5 => UCB
;
; OUTPUTS:
;	If no error exit.
;		R0 = HIC code returned by hardware.
;

REWIND_ROUTINE:

	SUBSAVE
	SUBPUSH	R1			; Save bitmask.

	EX_NDT_CMD	CMD=R0,-		  ; Command is in R0.
			TIMEOUT=#TU78_MAX_REWIND,-;  It may take a while.
			ERROR_LABEL=30$		  ; Where to go if NO GOOD.

;
; EX_NDT_CMD returns HIC in R0.
;

	SUBPOP	R1			; Restore bitmask.
	CMPB	#HIC_REWINDING,R0	; Did we get REWINDING interrupt?
	BwNEQ	50$			; If NOT, branch around.
	MOVZBL	#HIC_DONE,R0		; If YES, change it to DONE for now.

	DSBINT				; If REWINDING, then block interrupts
	PRIOR_TEST_TMRDY		; Assure that TM78 ready.
	BBS	#UCB$V_POWER,-		; And then if IO$V_NOWAIT not specified
		UCB$W_STS(R5),10$	;  then wait for DONE interrupt unless
	BBS	#IO$V_NOWAIT,R1,40$	;  it has already occurred. Here we test
					;  IO$V_NOWAIT.
	BBC	#UCB$V_MF_REWIND,-	; And here we test if DONE has already
		UCB$W_DEVSTS(R5),40$	;  occurred.

	WFIKPCH	20$,#TU78_MAX_REWIND	; Here we wait for the DONE interrupt.
	POST_TEST_TMRDY			; Assure that TM78 ready.
	BSBW	TF_UNSOLNT		; Record data after interrupt after
					;  REWIND supposedly done.
	MOVL	UCB$L_MF_NDTA(R5),-	; Copy NDT attention data for this
		UCB$L_MF_NDTA_C(R5)	;  interrupt to stable place.
	BSBW	SAVE_TM78_REGS		; Save Hardware registers.

	IOFORK
	BBS	#UCB$V_POWER,-		; Test for the last time for
		UCB$W_STS(R5),20$	;  POWERFAIL.
	EXTZV	#MF_NDTA_V_NDIC,-	; Here we extract the interrupt code
		#MF_NDTA_S_NDIC,-	;  from the register copy deposited
		UCB$L_MF_NDTA_C(R5),R0	;  in the UCB above.

	BRB	50$			; Branch around.

10$:	ENBINT				; Enable interrupts after POWER bit set.
20$:	SETIPL	UCB$B_FIPL(R5)		; Lower IPL if TIMEOUT.
	BSBW	TIMEOUT_POWERFAIL	; We had a TIMEOUT or a POWERFAIL, call
					;  to handle it.
	BRB	35$			; Branch around the label where the
					;  error path from above EX_NDT_CMD
					;  rejoins the normal flow.

30$:					; We are here after experiencing
					;  an error return from EX_NDT_CMD.
	SUBPOP	R1			; Cleanup bitmask left on stack.
35$:					; Here we had an error in EX_NDT_CMD
					;  or we experienced return from
					;  TIMEOUT_POWERFAIL routine. Either
					;  way we want to effect an error
					;  return to our caller.

	SUBPOP	R1			; R1 => our return point.
	CVTWL	(R1),-(SP)		; Put relative addr of error return onto
					;  the top of the stack.
	ADDL	(SP)+,R1		; Add in absolute offset. R1 => error return
	BRB	60$			; Branch around
40$:
	ENBINT
50$:
	SUBPOP	R1			; R1 => return point.
60$:
	ADDL	#2,R1			; Adjust to correct return or error address
	JMP	(R1)			; Jump to return or ERROR_LABEL.
	.PAGE
	.SBTTL	Device Error Routine.

; DEVICE_ERROR - routine to interface to INVOKE_EXTENDED_SENSE and the
;	ERROR LOGGER.
;


DEVICE_ERROR:

	SUBSAVE
	SUBPUSH	R0,R1,R2		; Save volatile registers.
	BBCC	#UCB$V_MF_SOFT_ERR,-	; If we NOT only a soft error, branch
		UCB$W_DEVSTS(R5),10$	;  around. Else clear bit.
	BBC	#MT$V_LOGSOFT,-		; If only soft error, branch around if
		UCB$L_DEVDEPEND(R5),30$	;  soft logging not enabled.
	BRB	20$			; Soft logging enabled, branch around
					;  decrementing of retry count.
10$:
	DECB	UCB$B_ERTCNT(R5)	; Indicate another error has occurred
					;  on this I/O operation.
20$:
	BSBW	INVOKE_EXTENDED_SENSE
	JSB	G^ERL$DEVICERR		; Invoke ERROR LOGGER.
30$:
	SUBPOP	R2,R1,R0		; Restore registers.
	SUBRETURN
	.PAGE
	.SBTTL	Invoke Extended Sense routine

; INVOKE_EXTENDED_SENSE - subroutine used to issue an ENTENDED SENSE command.
;
; INPUTS:
;	R5 => UCB
;
;	If the channels are owned upon entry then
;		R3 => TM78 CSR
;		R4 => MBA CSR
;	else R3 and R4 have random junk that must be preserved.
;
; OUTPUTS:
;	No specific outputs.
;
; SIDE EFFECTS:
;	The results of the EXTENDED SENSE command are left in the UCB.
;
;	Registers R0 - R2 are destroyed.
;

INVOKE_EXTENDED_SENSE:

	BBC	#UCB$V_MF_EXSNS_DONE,-		; Never do more than one EXTENDED
		UCB$W_DEVSTS(R5),10$		;  SENSE per I/O operation.
	RSB					; So RETURN if already done.
10$:
	BISW	#UCB$M_MF_EXSNS_DONE,-		; Set bit to indicate that we
		UCB$W_DEVSTS(R5)		;  are doing an EXTENDED SENSE.
	SUBSAVE
	SUBPUSH		R3
	SUBPUSH		R4

	MOVL	UCB$L_CRB(R5),R0		; R0 => TM78 CRB.
	MOVL	CRB$L_INTD+VEC$L_IDB(R0),R0	; R0 => TM78 IDB.
	CMPL	R5,IDB$L_OWNER(R0)		; Are we channel owner?
	BEQL	20$				; EQL implies yes.

	REQPCHAN			; Returns R4 => TM78 CSR.
	MOVL	R4,R3			; Copy so R3 => TM78 CSR.
	BRB	30$			; Branch around.
20$:
	BISW	#UCB$M_MF_OWNPCHN,-
		UCB$W_DEVSTS(R5)	; Set bit to indicate ownership.
30$:
	MOVL	UCB$L_CRB(R5),R0		; R0 => TM78 CRB.
	MOVL	CRB$L_LINK(R0),R0		; R0 => MBA CRB.
	MOVL	CRB$L_INTD+VEC$L_IDB(R0),R0	; R0 => MBA IDB.
	CMPL	R5,IDB$L_OWNER(R0)		; Are we channel owner?
	BEQL	40$				; EQL implies yes.

	REQSCHAN			; R4 => MBA CSR.
	BRB	50$			; Branch around.
40$:
	BISW	#UCB$M_MF_OWNSCHN,-
		UCB$W_DEVSTS(R5)	; Set bit to indicate ownership.
50$:
	ASSUME	UCB$L_SVAPTE+4  EQ  UCB$W_BOFF
	ASSUME	UCB$W_BOFF+2    EQ  UCB$W_BCNT

	MOVQ	UCB$L_SVAPTE(R5),-
		UCB$Q_MF_TEMP(R5)	; Save data in temporary.
	SUBPUSH	UCB$W_MF_CS1(R5)	; Ditto.

	ASSUME	UCB$L_MF_SVAPTE+4  EQ  UCB$W_MF_BOFF
	ASSUME	UCB$W_MF_BOFF+2    EQ  UCB$W_MF_BCNT

	MOVQ	UCB$L_MF_SVAPTE(R5),-	; Copy parameters needed to load MBA
		UCB$L_SVAPTE(R5)	;  registers to effect EXTENDED SENSE.
	MOVZBW	#F_EXSNS!GO_BIT,-
		UCB$W_MF_CS1(R5)	; Indicate command about to invoke.
	BSBW	LOAD_MBA_REGISTERS
	MOVZWL	UCB$W_MF_TMPLTC(R5),-	; Copy TEMPLATE TC to get CMD ADR field
		MF_TC(R3)		;  into hardware register.  Other fields
					;  are ignored anyway.

	DSBINT
	BBS	#UCB$V_MF_ATTN,-	; If we got another "B" type fault,
		UCB$W_DEVSTS(R5),60$	;  then branch around the EXTENDED SENSE
	BBS	#UCB$V_POWER,-
		UCB$W_STS(R5),60$	; Branch around if we had POWERFAIL.
	MOVZWL	UCB$W_MF_CS1(R5),-
		MF_CS1(R3)		; Move command to hardware register.
	WFIKPCH	70$,#MINIMUM_TIMEOUT	; Wait.
	IOFORK
	BRB	80$
60$:	ENBINT
70$:	SETIPL	UCB$B_FIPL(R5)		; Lower IPL after timeout.
80$:

;
; Note - We come here under all circumstances.  Either the command worked,
;	it didn't work, we had a POWERFAIL or we had a timeout.  In the
;	first case (i.e. the command worked) we have the EXTENDED SENSE
;	data in the UCB.  In the other cases we do not have it and we lose
;	all information as to why the command failed.
;

	SUBPOP	UCB$W_MF_CS1(R5)	; Restore
	MOVQ	UCB$Q_MF_TEMP(R5),-
		UCB$L_SVAPTE(R5)	; Restore.
	BBSC	#UCB$V_MF_OWNSCHN,-
		UCB$W_DEVSTS(R5),90$	; Branch around if we owned the channel.
	RELSCHAN			; Release channel obtained only for
					;  EXTENDED SENSE.
90$:
	BBSC	#UCB$V_MF_OWNPCHN,-
		UCB$W_DEVSTS(R5),100$	; Branch around if we owned the channel.
	RELCHAN				; Release channel obtained only for
					;  EXTENDED SENSE.
100$:
	SUBPOP	R4
	SUBPOP	R3

	SUBRETURN
	.PAGE
	.SBTTL	AWAIT_MANUAL_REWIND

; AWAIT_MANUAL_REWIND
;
; INPUTS:
;
;	We are at device IPL following a WFIKPCH.
;	We have just received an HIC_NOT_RDY interrupt code in response
;	to a hardware command implying that the drive is undergoing a
;	manual REWIND or LOAD operation.  What we do here is simply wait
;	for this MANUAL operation to finish before trying to start the
;	I/O operation that was requested.
;
;	We may currently own the primary channel and the secondary channel.
;
;	R3 => TM78 CSR
;	R5 => UCB
;

	.ENABLE	LSB
AWAIT_MANUAL_REWIND:

	IOFORK				; Lower IPL.
	RELCHAN				; Release all channels.
	DSBINT				; Block interrupts
	PRIOR_TEST_TMRDY		; Assure that TM78 ready.

	BBS	#UCB$V_POWER,-
		UCB$W_STS(R5),10$	; Branch if there has been a POWERFAIL
	BBC	#UCB$V_MF_REWIND,-
		UCB$W_DEVSTS(R5),30$	; Branch around WAIT if REWIND done.
	WFIKPCH	20$,#TU78_MAX_REWIND	; Wait for REWIND, LOAD or DSE to finish.
WAITING_FOR_MANUAL:			; Label of return point for WFIKPCH.
	POST_TEST_TMRDY			; Assure that TM78 ready.
	BSBW	TF_UNSOLNT		; Update UCB after REWIND or LOAD.
	IOFORK
	BRB	40$			; Branch around.

10$:	ENBINT
20$:	SETIPL	UCB$B_FIPL(R5)		; Set to fork IPL.
	BSBW	TIMEOUT_POWERFAIL	; Call to indicate problem.
	BRB	FUNCTION_EXIT		; If we experience return, goto EXIT.
30$:
	ENBINT				; Enable interrupts if REWIND done.
40$:

	BRW	TF_RESTARTIO		; Goto restart I/O operation.
	.DISABLE	LSB
	.PAGE
	.SBTTL	Function Completion Common Exit

; FUNCTION_EXIT - We branch here to terminate processing of a request.
;
; INPUTS:
;
;	R0 = Final I/O completion status in the low word, # bytes transfered
;			or records/files skipped in the high word.
;	R5 => UCB
;

FUNCTION_EXIT:

	PUSHL	R0			; Save final status and count.
	JSB	G^IOC$DIAGBUFILL	; Fill diagnostic buffer if present.
	BLBS	(SP),20$		; LBS implies successful completion.
	MOVL	UCB$L_IRP(R5),R4	; R4 => current I/O packet.
	BBC	#IRP$V_VIRTUAL,-
		IRP$W_STS(R4),20$	; If CLEAR, NOT virtual function.
	MOVL	IRP$L_WIND(R4),R4	; R4 => Window Block.
	CLRW	WCB$W_NMAP(R4)		; Clear number of mapping pointers.
	MOVL	UCB$L_VCB(R5),R4	; R4 => VCB listhead.
	MOVAB	UCB$L_IOQFL(R5),R2	; R2 => I/O Queue.
	MOVL	R2,R3			; Initialize R3 => previous entry.
10$:	MOVL	(R3),R3			; R3 => next entry.
	CMPL	R3,R2			; End of list?
	BEQL	20$			; EQL implies yes, end of list.
	BBC	#IRP$V_VIRTUAL,-
		IRP$W_STS(R3),10$	; Clear implies NOT virtual function.
	MOVL	4(R3),R3		; Retrieve address of previous entry.
	REMQUE	@(R3),R1		; Remove entry from Driver queue.
	INSQUE	(R1),@4(R4)		; Insert entry in blocked I/O list.
	BRB	10$			; Loop back.

20$:	POPL	R0			; Retrieve final I/O status.
STSXIT:
	DSBINT				; No interrupts while we decide whether
					;  to clear UCBFREE.
	BBC	#UCB$V_MF_ATTN,-	; If no "B" type faults pending, branch
		UCB$W_DEVSTS(R5),30$	;  around.
	ENBINT				; Re-enable interrupts.
	MOVAB	UCB$L_MF_SUBSTACK(R5),-	; Initialize SUBSTACK pointer in case we
		UCB$L_MF_SUBSP(R5)	;  go here via CANCEL_IO.
	SUBPUSH	R0			; Save final I/O status.
	BSBW	ISSUE_TMCLR		; Go try to reset TM78.
	SUBPOP	R0			; Restore final I/O status.
	DSBINT				; Disable to match with coming ENBINT.
30$:
	BISW	#UCB$M_MF_UCBFREE,-	; UCB fork block now free for asynchronous
		UCB$W_DEVSTS(R5)	;  use.
	ENBINT				; Re-enable interrupts.
	MOVL	UCB$L_DEVDEPEND(R5),R1	; Set magtape status and characteristics.
	REQCOM				; Complete I/O request.
	.PAGE
		.SBTTL	TM78/TU78 REGISTER DUMP ROUTINE
;
; TF_REGDUMP - TM78/TU78 REGISTER DUMP ROUTINE
;
; THIS ROUTINE IS CALLED TO SAVE THE CONTROLLER AND DRIVE REGISTERS IN A
; SPECIFIED BUFFER. IT IS CALLED FROM THE DEVICE ERROR LOGGING ROUTINE AND
; FROM THE DIAGNOSTIC BUFFER FILL ROUTINE.
;
; INPUTS:
;
;	R0 = ADDRESS OF REGISTER SAVE BUFFER.
;	R4 = ADDRESS OF ADAPTER CONFIGURATION REGISTER.
;	R5 = DEVICE UNIT UCB ADDRESS.
;
; OUTPUTS:
;
;	THE CONTROLLER AND DRIVE REGISTERS ARE SAVED IN THE SPECIFIED BUFFER.
;

TF_REGDUMP:				;TM78/TU78 REGISTER DUMP ROUTINE
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save registers destroyed by MOVC3.
	MOVL	#UCB_REGDUMP_LEN/4,(R0)+; Copy number of longwords.
	MOVC3	#UCB_REGDUMP_LEN,-	; Copy previously saved device and
		UCB$L_MFMBA_CSR(R5),(R0);  MBA register values and other data.
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore registers destroyed by MOVC3.
	RSB				;
	.PAGE
	.SBTTL	TM78 CONTROLLER INITIALIZATION

; TM78_INIT
;
; This routine is called via a JSB instruction at system startup and after
;	power recovery restart to allow initialization of the TM78 controller.
;
; INPUTS:
;	R4 => TM78 CSR
;	R5 => IDB
;
; OUTPUTS:
;	The TM78 is cleared.
;

TM78_INIT:

	BISL	#MF_ID_M_TMCLR,MF_ID(R4)	; Start controller clear.
	PUSHL	R0				; Save register.
	MOVZBL	#250,R0				; Count to register.
10$:	SOBGTR	R0,10$				; Waste some time as TM78
						;  settles down after clear.

	MOVL	#2000000,R0			; Count to register again.
20$:
	PUSHL	MF_ID(R4)			; Push TM78 register to stack.
	BITL	#MF_ID_M_TMRDY,(SP)+		; See if TM78 has come READY.
	BNEQ	30$				; NEQ implies READY, so branch.
	SOBGTR	R0,20$				; Loop waiting for device READY.
30$:
	POPL	R0				; Restore register.
	RSB					; Return to caller.
	.PAGE
	.SBTTL	TM78-TU78 TAPE DRIVE INITIALIZATION
;
; TM78_TXXX_INIT - TM78-TU78 TAPE DRIVE INITIALIZATION
;
; THIS ROUTINE IS CALLED AT SYSTEM INITIALIZATION AND AT POWER RECOVERY TO SET
; DRIVE PARAMETERS.
;
; INPUTS:
;
;	R3 = ADDRESS OF TM78 DRIVE CONTROL REGISTER.
;	R4 = ADDRESS OF MBA CONFIGURATION STATUS REGISTER.
;	R5 = DEVICE UNIT UCB ADDRESS.
;
; OUTPUTS:
;
;	UNIT PARAMETERS ARE ESTABLISHED.
;

TM78_TXXX_INIT:				;TU78 TAPE DRIVE INITIALIZATION
	SUBL3	R4,R3,R2		;CALCULATE OFFSET TO DRIVE CONTROL REGISTER
	MOVAB	-MBA$L_ERB(R2),R2	;SUBTRACT OUT EXTERNAL REGISTER BASE
	DIVW3	#1@7,R2,UCB$B_SLAVE(R5)	;SET ADAPTER DRIVE NUMBER
	MULB3	#1@7/4,UCB$B_SLAVE(R5),UCB$B_SLAVE+1(R5) ;SET DRIVE OFFSET CONSTANT

	PUSHL	MBA$L_SR(R4)		;READ MBA STATUS REGISTER

	BwBS	#UCB$V_POWER,-		; Branch around if here at POWERFAIL.
		UCB$W_STS(R5),50$

	BISW	#UCB$M_MF_UCBFREE,-	; Initialize bit that indicates the UCB
		UCB$W_DEVSTS(R5)	;  fork block is free for asynchronous
					;  use.

	MOVZBL	UCB$B_SLAVE(R5),R1	; R1 = MBA port number for TM78.
	ASHL	R1,#1,R1		; R1 = mask corresponding to attention bit.
	MOVL	R1,MF_AB(R3)		; Clear it just in case set.

	MOVZBL	#250,R2			; Set a counter with small number
5$:	SOBGTR	R2,5$			; Waste time while ATTN bit clears.

	MOVZWL	UCB$W_UNIT(R5),R2	; R2 = unit number of this drive.
	MOVZBL	#F_SENSE!GO_BIT,-	; Do a SENSE command to see what kind
		MF_NDT0(R3)[R2]		;  drive we have.
	MOVL	#2000000,R2		; Set count to prevent hang.
10$:
	PUSHL	MBA$L_SR(R4)		; Copy MBA status register to stack.
	BITL	#MBA$M_SR_ATTN,(SP)+	; Wait for SENSE to set MBA attention
					;  bit on.
	BNEQ	20$			; NEQ implies the bit came on.
	SOBGTR	R2,10$			; Branch back to test again until
					;  count overflows.
20$:
	BITL	R1,MF_AB(R3)		; Did we get attention yet?
	BNEQ	30$			; NEQ implies that TM78 attention set.
	BICW	#UCB$M_ONLINE!UCB$M_VALID,-	; If attention not set yet,
		UCB$W_STS(R5)			;  set unit offline/invalid.
	BRB	40$				; And branch around.
30$:
	PUSHL	UCB$L_MF_DT(R5)		; Save current value in case at POWERFAIL
	MOVL	MF_DT(R3),-		; And move new value to UCB so as to
		UCB$L_MF_DT(R5)		;  subroutine TF_DTYPE.
	BISW	#UCB$M_ONLINE,-		; TF_DTYPE assumes this bit is set and
		UCB$W_STS(R5)		;  clears if it does not like DRIVE TYPE
	BSBW	TF_DTYPE		;CLASSIFY DRIVE TYPE
	POPL	UCB$L_MF_DT(R5)		; Restore in case we are in POWERFAIL.

	PUSHL	UCB$L_MF_DS(R5)		; Save current value in case at POWERFAIL
	MOVL	MF_DS(R3),-		; And move new value to UCB so as to
		UCB$L_MF_DS(R5)		;  call subroutine RECORD_SENSE_INFO
	BSBW	RECORD_SENSE_INFO	; Record the sense info in UCB.
	MOVZBL	UCB$B_SLAVE(R5),R1	; R1 = MBA port number for TM78.
	ASHL	R1,#1,R1		; R1 = mask corresponding to attention bit.
	MOVL	R1,MF_AB(R3)		; Clear attention bit.
	POPL	UCB$L_MF_DS(R5)		; Restore in case we are in POWERFAIL.

	BBS	#UCB$V_ONLINE,-
		UCB$W_STS(R5),40$	; If SET, OK drive.
	BICW	#UCB$M_VALID,-
		UCB$W_STS(R5)		;Clear VOLUME SOFTWARE VALID
40$:
	CLRW	UCB$W_MF_TMPLTC(R5)	; Clear template tape control register.
	INSV	UCB$W_UNIT(R5),-	; Put Unit number of drive
		#MF_TC_V_CMDADR,-	;  in template tape control register.
		#MF_TC_S_CMDADR,-
		UCB$W_MF_TMPLTC(R5)

	INSV	#1,-			; Initialize the record count to 1
		#MF_TC_V_RC,-		;  in template tape control register.
		#MF_TC_S_RC,-
		UCB$W_MF_TMPLTC(R5)

	INSV	#MF$K_FORMAT_NORMAL_11,-; Initialize format field
		#MF_TC_V_FMT,-		;  in template tape control register.
		#MF_TC_S_FMT,-
		UCB$W_MF_TMPLTC(R5)
	MOVW	#TU78_MAX_REWIND,-
		UCB$W_MF_MAX_REWIND(R5)	; Init UCB field.

;
; Here we determine the address of the PTE for the EXTENDED SENSE area
;	in the UCB so as to be able to efficiently execute this command
;	during system operation.  We also determine this area's offset in
;	its page.  The results of these calculations are deposited in
;	UCB$L_MF_SVAPTE and UCB$W_MF_BOFF respectively.  In order to
;	effect an EXTENDED SENSE command during system operation, we
;	move the contents of these items in the UCB to UCB$L_SVAPTE and
;	UCB$W_BOFF, prior to invoking the macros that load the appropriate
;	MBA registers.
;

	MOVAB	UCB$L_MF_EXSNS(R5),R0	; R0 => EXTENDED SENSE area in UCB.

	ASSUME	UCB$W_MF_BOFF+2 EQ UCB$W_MF_BCNT
	EXTZV	#0,#9,R0,-		; Extract byte offset of area in page.
		UCB$W_MF_BOFF(R5)	;  (also clear next word UCB$W_MF_BCNT)
	MOVZBW	#60,UCB$W_MF_BCNT(R5)	; Init EXTENDED SENSE byte count.
	EXTZV	#9,#21,R0,R0		; R0 = VPN of area in System Space.
	MOVL	G^MMG$GL_SPTBASE,R1	; R1 => System Page Table base.
	MOVAL	(R1)[R0],-
		UCB$L_MF_SVAPTE(R5)	; Point to PTE for area.

50$:
	POPL	MBA$L_SR(R4)		;CLEAR MBA STATUS
	RSB
	.PAGE
	.SBTTL	TM78/TU78 UNSOLICITED INTERRUPT PROCESSING
;
; TF_UNSOLNT - TM78/TU78 UNSOLICITED INTERRUPT PROCESSING
;
; This routine is called when an unsolicited interrupt is received for a unit.
;	Only three types of unsolicited interrupts (i.e. TM78 initiated) can
;	occur.  These are DONE interrupts which occur when a REWIND operation
;	terminates; ON-LINE interrupts which occur when a drive makes the
;	transition to online with a tape volume loaded; and finally hardware
;	fault interrupts.  The subroutine determines which class of interrupt
;	has occurred and branches to code to handle that type of interrupt.
;
; INPUTS:
;
;	R3 = Address of TM78 drive control register (CSR)
;	R5 = Address of the device unit UCB
;	UCB$W_MF_NDTA(R5) = Copy of the Non-data transfer attention register.
;
; OUTPUTS:
;	Depending upon the class of interrupt, various bits are set and
;		cleared.  See below for details of how each class of
;		unsolicited interrupt is handled.
;
;
;

TF_UNSOLNT:				;UNSOLICITED INTERRUPT PROCESSING
	PUSHL	R2
	EXTZV	#MF_NDTA_V_NDIC,-
		#MF_NDTA_S_NDIC,-
		UCB$L_MF_NDTA(R5),R2	; R2 = Hardware interrupt code.
	CMPB	#HIC_DONE,R2		; See if a REWIND is done.
	BEQL	30$			; Branch if DONE.
	CMPB	#HIC_ON_LINE,R2		; See if unit has come ON-LINE.
	BEQL	50$			; Branch if so.
;
; If we are here we have experienced some sort of attention for which no one
;	is waiting.  If so we just ignore it.
;

	BRB	70$

;
; We come here if the unsolicited interrupt was a DONE.  This implies that
;	a REWIND may have completed.
;

30$:
	CMPB	#F_REWIND!GO_BIT,-	; Was last command executed a REWIND
		UCB$L_MF_CMD(R5)
	BEQL	40$			;IF EQL YES
	CMPB	#F_DSE!GO_BIT,-		; Or was it a DSE (ERASE REST OF TAPE
		UCB$L_MF_CMD(R5)	;  AND REWIND) command?
	BNEQ	70$			; If NEQ just noise, branch to end.
40$:
	BICW	#<MT$M_EOF!-		; We know that we are at BOT so update
		  MT$M_LOST!-		;  fields in UCB$L_DEVDEPEND to reflect
		  MT$M_EOT>@-16,-	;  our exact position knowledge.
		UCB$L_DEVDEPEND+2(R5)
	BISW	#<MT$M_BOT@-16>,-	; Show that we are at BOT.
		UCB$L_DEVDEPEND+2(R5)
	CLRL	UCB$L_MF_RECORD(R5)	; Show absolute tape position.
	MNEGL	#2,UCB$L_MF_PREVTM(R5)	; Also show ignorance of last TAPEMARK.
	BRB	70$			; Branch around to return.

;
; If we come here we have experienced an ON-LINE interrupt;  i.e. the unit
;	has made a transition to ON-LINE with a volume loaded.  Also note
;	that SENSE information is valid at this time.
;

50$:
	MOVL	MF_DT(R3),UCB$L_MF_DT(R5)	; Save SENSE data which
	MOVL	MF_DS(R3),UCB$L_MF_DS(R5)	;  is valid after an ON-LINE
	MOVL	MF_SN(R3),UCB$L_MF_SN(R5)	;  interrupt.
	BSBW	RECORD_SENSE_INFO		; Call to update SENSE info to
						;  appropriate UCB fields.

	BISW	#UCB$M_ONLINE,-
		UCB$W_STS(R5)		; Tentatively mark unit ON-LINE.
	BSBW	TF_DTYPE		; Classify drive type.
					;  later ONLINE to OFFLINE transition.
	CLRL	UCB$L_MF_NDTA(R5)	; Prevent a redundant call to TF_UNSOLNT
					;  (which might occur if we were waiting
					;   for the UCB$M_MF_REWIND bit to go
					;   zero).

;
; Now we either clear, set or leave as is the UCB$M_VALID bit depending on
;	conditions.  If we are here due to a power failure, we leave the
;	valid bit as is.  If the unit has a volume that is mounted FOREIGN,
;	we set the bit to mark the volume as valid.  In all other
;	circumstances we clear the bit since a manual intervention has
;	taken place on the drive and we can no longer be sure of the
;	volume.
;

	BBS	#UCB$V_POWER,-
		UCB$W_STS(R5),70$	; If powerfail, leave as is and branch.
	BBC	#DEV$V_MNT,-
		UCB$L_DEVCHAR(R5),60$	; If NOT mounted, branch to invalidate.
	BBC	#DEV$V_FOR,-
		UCB$L_DEVCHAR(R5),60$	; If mounted but NOT foreign, go to invalidate.
	BISW	#UCB$M_VALID,-		; Tape is mounted foreign, so
		UCB$W_STS(R5)		;  set volume valid.
	BRB	70$			; Branch around to return.
60$:	BICW	#UCB$M_VALID,-
		UCB$W_STS(R5)		; Mark volume software INVALID.
70$:
	POPL	R2
	RSB				;
	.PAGE
	.SBTTL	TM78 Classify Drive Type and set parameters.

; TF_DTYPE - Routine called when an unsolicited ON-LINE interrupt occurs
;	on a drive or at unit initialization time at system startup or
;	after power recovery.
;
; INPUTS:
;	R5 => UCB
;	 UCB$W_MF_DT(R5) contains a valid copy of the Drive Type register.
;
; OUTPUTS:
;	UCB$B_DEVTYPE is set to valid value.
;	UCB$M_ONLINE in UCB$W_STS is cleared if the device type does not
;		match any valid device connected to a TM78 controller.
;

TF_DTYPE:
	BICL3	#^C<MF_DT_M_DTN>,-
		UCB$L_MF_DT(R5),-(SP)	; Drive type to top of stack.
	MOVAB	TF_DTDESC,R2		; R2 => Drive descriptor table.
10$:	CMPW	(SP),(R2)+		; Drive type match?
	BEQL	20$			; If EQL yes.
	ASSUME	TF_DTDESCLEN-2  EQ  1	; Assumption allows subsequent INCL and DECL.
	INCL	R2			; Advance R2 to next entry.
	TSTW	(R2)			; End of table?
	BNEQ	10$			; If NEQ no.
	BICW	#UCB$M_ONLINE,-
		UCB$W_STS(R5)		; If unknown type, set unit offline.
	DECL	R2			; Back up to last driver descriptor.
20$:	MOVB	(R2),UCB$B_DEVTYPE(R5)	; Set drive type.
	TSTL	(SP)+			; Erase drive type from stack.
	RSB				; Return to caller.
	.PAGE
	.SBTTL	RECORD_SENSE_INFO

; RECORD_SENSE_INFO - subroutine to update UCB$L_DEVDEPEND fields given
;	that we currently have valid sense information in hand.
;
; INPUTS:
;	R5 => UCB of interest.
;	UCB$L_MF_DS(R5) is a valid copy of TM78 register.
;

RECORD_SENSE_INFO:
	BICW	#<MT$M_BOT!-		; We have exact SENSE information as
		  MT$M_EOF!-		;  to position (i.e. BOT and EOT) and
		  MT$M_EOT!-		;  also whether we have a RING or not.
		  MT$M_HWL>@-16,-	; So we clear these bits and then set
		UCB$L_DEVDEPEND+2(R5)	;  those which still hold true.

	BBC	#MF_DS_V_BOT,-		; Branch if NOT at BOT
		UCB$L_MF_DS(R5),10$
	BISW	#<MT$M_BOT@-16>,-	; Set BOT bit on in UCB field.
		UCB$L_DEVDEPEND+2(R5)
	BICW	#<MT$M_LOST@-16>,-	; Clear the fact that we may have
		UCB$L_DEVDEPEND+2(R5)	;  been lost
	CLRL	UCB$L_MF_RECORD(R5)	; Set tape position marker to zero.
	MNEGL	#2,UCB$L_MF_PREVTM(R5)	; And show ignorance of TAPEMARKs.
10$:
	BBC	#MF_DS_V_EOT,-		; Branch if not beyond EOT marker.
		UCB$L_MF_DS(R5),20$
	BISW	#<MT$M_EOT@-16>,-	; Set bit if we are indeed beyond the
		UCB$L_DEVDEPEND+2(R5)	;  EOT marker.
20$:
	BBC	#MF_DS_V_FPT,-		; Branch around if NO ring present on
		UCB$L_MF_DS(R5),30$	;  tape reel.
	BISW	#<MT$M_HWL@-16>,-	; Set bit if NO ring present on
		UCB$L_DEVDEPEND+2(R5)	;  tape reel.
30$:
	BBS	#MT$V_LOST,-		; Branch around if LOST.
		UCB$L_DEVDEPEND(R5),40$
	CMPL	UCB$L_MF_RECORD(R5),-	; See if we are at a TAPEMARK by comparing
		UCB$L_MF_PREVTM(R5)	;  current position with last TAPEMARK.
	BNEQ	40$			; NEQ implies not at a TAPEMARK.
	BISW	#<MT$M_EOF@-16>,-	; Set bit indicating currently positioned
		UCB$L_DEVDEPEND+2(R5)	;  at a TAPEMARK.
40$:
	ASSUME	MF$K_DENSITY_1600  EQ  0; Here we find out the drive density
	CLRB	UCB$B_MF_DENSITY(R5)	;  and set UCB variables accordingly.
	PUSHL	R0			; We set the density to the default 1600
	MOVL	#MT$K_PE_1600,R0	;  and prepare to test the actual status
	BBS	#MF_DS_V_PE,-		; Branch if 1600 BPI bit set in device
		UCB$L_MF_DS(R5),50$	;  status register.
	ASSUME	MF$K_DENSITY_6250  EQ  1; We fall thru here if the drive is 6250
	INCB	UCB$B_MF_DENSITY(R5)	; We set density to 6250 in that case
	MOVL	#MT$K_GCR_6250,R0	; And get set to update UCB$L_DEVDEPEND
50$:
	INSV	R0,-			; Insert the density value into the
		#MT$V_DENSITY,-		;  proper field of UCB$L_DEVDEPEND
		#MT$S_DENSITY,-		;  so as to indicate the current
		UCB$L_DEVDEPEND(R5)	;  density passed in R0.
	POPL	R0			; Restore
	RSB				; Return to caller.
	.PAGE
; SAVE_TM78_REGS - Subroutine to simply copy all TM78 registers to the UCB.
;
;
; INPUTS:
;
;	R3 => TM78 CSR
;	R5 => UCB
;
; OUTPUTS:
;
;	Register values saved in the UCB.
;
; Note that since this routine is called at interrupt time (i.e. between
;	WFIKPCH and IOFORK) it must comform to the register conventions in
;	force at that time, which include NOT destroying registers R0 and R1.
;

SAVE_TM78_REGS:

	ASSUME	UCB$L_MF_IS-UCB$L_MF_CS1  EQ  MF_IS
	ASSUME	UCB$L_MF_TC-UCB$L_MF_CS1  EQ  MF_TC
	ASSUME	UCB$L_MF_MR1-UCB$L_MF_CS1  EQ  MF_MR1
	ASSUME	UCB$L_MF_AB-UCB$L_MF_CS1  EQ  MF_AB
	ASSUME	UCB$L_MF_BC-UCB$L_MF_CS1  EQ  MF_BC
	ASSUME	UCB$L_MF_DT-UCB$L_MF_CS1  EQ  MF_DT
	ASSUME	UCB$L_MF_DS-UCB$L_MF_CS1  EQ  MF_DS
	ASSUME	UCB$L_MF_SN-UCB$L_MF_CS1  EQ  MF_SN
	ASSUME	UCB$L_MF_MR2-UCB$L_MF_CS1  EQ  MF_MR2
	ASSUME	UCB$L_MF_MR3-UCB$L_MF_CS1  EQ  MF_MR3
	ASSUME	UCB$L_MF_NDTA-UCB$L_MF_CS1  EQ  MF_NDTA
	ASSUME	UCB$L_MF_NDT0-UCB$L_MF_CS1  EQ  MF_NDT0
	ASSUME	UCB$L_MF_NDT1-UCB$L_MF_CS1  EQ  MF_NDT1
	ASSUME	UCB$L_MF_NDT2-UCB$L_MF_CS1  EQ  MF_NDT2
	ASSUME	UCB$L_MF_NDT3-UCB$L_MF_CS1  EQ  MF_NDT3

	PUSHR	#^M<R0,R1,R2>		; Save registers.
	MOVAB	UCB$L_MF_CS1(R5),R0	; R0 => Block in UCB where we save regs
	MOVAB	MF_CS1(R3),R1		; R1 => start of TM78 registers.
	MOVL	#MF_NDT3+4-MF_CS1/4,R2	; R2 =  number of registers to copy.
10$:
	MOVL	(R1)+,(R0)+		; Copy one Register to UCB.
	SOBGTR	R2,10$			; Loop thru all contiguous registers.
	MOVL	MF_ID(R3),-
		UCB$L_MF_ID(R5)		; Copy non-contiguous register.
	POPR	#^M<R0,R1,R2>		; Restore registers.
	RSB				; Return to caller.
	.PAGE
; SAVE_MBA_REGS - Routine to record non-volatile MBA registers involved
;	in Data Transfer operations for ERROR LOGGING use.
;
; INPUTS:
;
;	R3 => TM78 CSR
;	R4 => MBA CSR
;	R5 => UCB
;
; OUTPUTS:
;
;	Register values saved in the UCB.
;
;
; Note that since this routine is called at interrupt time (i.e. between
;	WFIKPCH and IOFORK) it must comform to the register conventions in
;	force at that time, which include NOT destroying registers R0 and R1.
;

SAVE_MBA_REGS:

	ASSUME	UCB$L_MFMBA_CSR+4   EQ  UCB$L_MFMBA_CR
	ASSUME	UCB$L_MFMBA_CR+4    EQ  UCB$L_MFMBA_SR
	ASSUME	UCB$L_MFMBA_SR+4    EQ  UCB$L_MFMBA_VAR
	ASSUME	UCB$L_MFMBA_VAR+4   EQ  UCB$L_MFMBA_BCR
	ASSUME	UCB$L_MFMBA_BCR+4   EQ  UCB$L_MFMBA_FMAP
	ASSUME	UCB$L_MFMBA_FMAP+4  EQ  UCB$L_MFMBA_PMAP

	PUSHR	#^M<R0,R1>		; Save registers.
	MOVAB	UCB$L_MFMBA_CSR(R5),R1		; R1 => MBA dump area in UCB.
	MOVL	MBA$L_CSR(R4),(R1)+		; Save MBA CSR contents
	MOVL	MBA$L_CR(R4),(R1)+		; Save MBA Control Reg.
	MOVL	MBA$L_SR(R4),(R1)+		; Save MBA Status Reg.
	MOVL	MBA$L_VAR(R4),(R1)+		; Save MBA  Virtual ADDR Reg.
	MOVL	MBA$L_BCR(R4),(R1)+		; Save MBA Byte Count Reg.
	EXTZV	#9,#8,-8(R1),R0			; R0 = Final Map Reg. Number.
						;  NOTE; -8(R1) corresponds to
						;   UCB$L_MFMBA_VAR(R5).
	MOVL	MBA$L_MAP(R4)[R0],(R1)+		; Save Final Map Register.
	CLRL	(R1)				; Zero UCB$L_MFMBA_PMAP in case
						;  there is NO previous Map Reg.
	DECL	R0				; R0 = Previous Map Reg #
	BLSS	10$				; LSS implies NO previous.
	MOVL	MBA$L_MAP(R4)[R0],(R1)		; Save Previous Map Register.
10$:
	POPR	#^M<R0,R1>		; Restore registers.
	RSB
	.PAGE
	.SBTTL	TM78_NOTREADY (PRIOR and POST)

; Code branched to when either  of the bits UCB$M_MF_TMRDY or UCB$M_MF_ATTN
;	is found set to 1, either PRIOR to losing control via a WFIKPCH
;	or just after regaining control after a WFIKPCH (POST).  The
;	setting of either bit means the TM78 is out of whack and must be
;	reset.  If the UCB$M_MF_ATTN bit is set then we must reset the TM78.
;	If UCB$M_MF_ATTN is not set but the other one is we must wait for
;	the TM78 to come ready again after it is reset.  The first entry here
;	is branched to when one of the bits is found on PRIOR to the WFIKPCH
;	and therefore we have just issued a DSBINT macro.  Thus we must
;	perform an ENBINT to undo this.  The second entry is branched to
;	after a WFIKPCH so we must IOFORK to get down from interrupt state.
;
; INPUTS:
;	R3 => TM78 CSR.
;	R5 => UCB
;

	.ENABLE		LSB
TM78_NOTREADY_PRIOR:
	ENBINT
	BRB	10$
TM78_NOTREADY_POST:
	IOFORK
10$:
	BBC	#UCB$V_MF_ATTN,-	; Is it our responsibility to TMCLR?
		UCB$W_DEVSTS(R5),20$	; Bit clear implies NO, so branch.
	BSBW	ISSUE_TMCLR
	BLBS	R0,20$			; LBS implies successful TMCLR.
	BRW	FUNCTION_EXIT		; If failure, exit.
20$:
	RELCHAN				; In case we own channel release it.
	BBC	#UCB$V_MF_TMRDY,-	; See if we must await the TM78.
		UCB$W_DEVSTS(R5),30$	; Clear bit means NO, so branch.
	BSBW	AWAIT_TMRDY
30$:
	BISW	#UCB$M_MF_REPOS,-	; Signal need to reposition.
		UCB$W_DEVSTS(R5)
	BSBW	REPOSITION		; Call but if successful it branches
					;  to TF_RESTARTIO.
	BICW	#UCB$M_MF_REPOS,-	; Clear bit if unsuccessful reposition
		UCB$W_DEVSTS(R5)	;  operation.
	MOVZWL	#SS$_CTRLERR,R0		; Indicate final I/O status.
	BRW	FUNCTION_EXIT
	.DISABLE	LSB
	.PAGE
	.SBTTL	FAULT_INTERRUPT

; FAULT_INTERRUPT - subroutine called at interrupt level when a "B" type
;	fault interrupt has been received.  The strategy here is as follows:
;
;	1.  We set the UCB$M_MF_ATTN bit in our UCB$W_DEVSTS to indicate that
;		it is our responsibility to do the TMCLR.
;	2.  We loop thru all UCBs associated with this TM78 and set the
;		UCB$M_MF_TMRDY bits in each UCB$W_DEVSTS to inidcate to
;		processes that may currently be using these UCBs that they
;		must AWAIT_TMRDY prior to proceeding with use of the TM78.
;	3.  We next determine whether we ISSUE_TMCLR inline (via IOFORK)
;		or simply return to our caller confident that we will shortly
;		call ISSUE_TMCLR at fork level.  This determination is made
;		on the following basis:  if our UCB is NOT busy (i.e.
;		UCB$M_BSY is zero in UCB$W_STS) then we do the ISSUE_TMCLR
;		inline.  Also if the UCB IS busy but bit UCB$M_MF_UCBFREE
;		in our UCB$W_DEVSTS is set then we can call ISSUE_TMCLR
;		inline.  In all other circumstances (i.e. BUSY and
;		UCB$M_MF_UCBFREE zero) we simply RSB to the interrupt
;		handler.
;	4.  If we decide to proceed inline, we set bit UCB$M_MF_UCBBUSY
;		in our UCB$W_DEVSTS to signal the fact that we are going
;		to use the UCB fork block asynchronously and that anyone
;		entering STARTIO had better defer until we finish.
;	5.  We IOFORK to get out of interrupt context and then we call
;		ISSUE_TMCLR.
;	6.  We reset UCB$M_MF_UCBBUSY.
;	7.  Now we either evaporate (i.e. RSB) or we go to startup a pending
;		I/O operation.  The determining factor in this is whether
;		the UCB$M_BSY bit is set in UCB$W_STS.  A set bit means that
;		some process has entered STARTIO since we began inline
;		operation and therefore deferred its operation.  It therefore
;		is our responsibility to start this operation.  To do it
;		we clear the UCB$B_MF_RSTCNT to indicate that we are starting
;		an operation and then to branch to TF_RESTARTIO.  If the
;		UCB$M_BSY bit was zero we simply RSB.
;
; INPUTS:
;	R2 =  hardware fault code.
;	R3 => TM78 CSR
;	R4 => TM78 IDB
;	R5 => our UCB.
;

FAULT_INTERRUPT:

	BISW	#UCB$M_MF_ATTN,-	; We must do the ISSUE_TMCLR
		UCB$W_DEVSTS(R5)
	PUSHR	#^M<R0,R1>
	CLRL	R0			; Clear loop variable.
10$:
	MOVL	IDB$L_UCBLST(R4)[R0],R1	; R1 => a UCB.
	BEQL	20$			; EQL implies no such UCB.
	BISW	#UCB$M_MF_TMRDY,-	; Tell all others to wait.
		UCB$W_DEVSTS(R1)
20$:	AOBLEQ	#3,R0,10$		; Loop thru all possible UCBs.
	POPR	#^M<R0,R1>

	BBC	#UCB$V_BSY,-
		UCB$W_STS(R5),30$	; If clear we can go inline, so branch.
	BBS	#UCB$V_MF_UCBFREE,-	; If set, UCB busy but FORK block free
		UCB$W_DEVSTS(R5),30$	;  so we branch to continue inline.
	BSBW	SAVE_TM78_REGS		; Record TM78 register values.
25$:
	RSB				; We cannot continue inline, so return.
30$:
	BBSS	#UCB$V_MF_UCBBUSY,-	; Indicate we are about to asynchronously
		UCB$W_DEVSTS(R5),25$	;  use the UCB fork block unless it is
					;  already in use.
	BSBW	SAVE_TM78_REGS		; Record TM78 register values.
	IOFORK				; Leave interrupt level.

	MOVAB	UCB$L_MF_SUBSTACK(R5),-	; Initialize SUBSTACK pointer in case
		UCB$L_MF_SUBSP(R5)		;  it is NG.
	BSBW	ISSUE_TMCLR
	BICW	#UCB$M_MF_UCBBUSY,-	; We no longer need the UCB fork block.
		UCB$W_DEVSTS(R5)

	BBC	#UCB$V_BSY,-		; If UCB NOT busy, branch.
		UCB$W_STS(R5),40$
	
	CLRB	UCB$B_MF_RSTCNT(R5)	; Begin operation with zero count.
	BRW	TF_RESTARTIO		; Go begin I/O operation/
40$:
	RSB				; Evaporate.
	.PAGE
	.SBTTL	AWAIT_TMRDY

; AWAIT_TMRDY - subroutine called when the driver finds UCB$M_MF_TMRDY bit
;	set in UCB$W_DEVSTS.  This bit set means that a "B" type fault has
;	occurred on some other TU78 drive connected to this TM78 and that
;	a TMCLR has been or soon will be issued within the context of the
;	UCB associated with the drive that experienced the fault.  When the
;	TMRDY bit in TM78 register MF_ID comes on after the TMCLR has been
;	issued, this other process will reset our UCB$M_MF_TMRDY and we will
;	be able to continue.  Here we simply wait for this bit to clear.  The
;	method of waiting is to simply IOFORK.  This puts us on the end of
;	the fork list.  We are guaranteed that the other process which will
;	reset our bit is also at fork level and is also looping, via IOFORK,
;	awaiting the TM78 hardware bit to come on.
;
; INPUTS:
;	R5 => UCB
;
; OUTPUTS:
;	NONE
;

AWAIT_TMRDY:
	SUBSAVE
	SUBPUSH	R3
	MOVZBL	#255,R3			; Prevent infinite loop.
10$:
	BBC	#UCB$V_MF_TMRDY,-	; If clear then our wait is over so
		UCB$W_DEVSTS(R5),20$	;  branch around.
	IOFORK				; Allow other process in to reset bit.
	SOBGTR	R3,10$			; Loop a limited number of times.
	BICW	#UCB$M_MF_TMRDY,-	; If it doesn't get reset, then we do it
		UCB$W_DEVSTS(R5)	;  ourselves.
	MOVZWL	#SS$_CTRLERR,R0		; If it doesn't reset soon, forget it.
	BRW	FUNCTION_EXIT		; Set error status and goto exit.
20$:
	SUBPOP	R3
	SUBRETURN
	.PAGE
	.SBTTL	ISSUE_TMCLR

; ISSUE_TMCLR - subroutine to invoke extended sense, errorlog, and to
;	issue a TMCLR to reset the TM78 hardware which is apparently
;	out of whack.  After a successful TMCLR we reset the UCB$M_MF_TMRDY
;	bits in UCB$W_DEVSTS in all UCBs attached to the TM78.
;
; INPUTS:
;	R5 => UCB
;
; OUTPUTS:
;	R0 = status return.
;		SS$_NORMAL implies successful TMCLR.
;		SS$_CTRLERR implies unable to complete TMCLR.
;
; Registers R1 and R2 are modified due to IOFORKING.
;

ISSUE_TMCLR:

	SUBSAVE
	SUBPUSH	R3,R4
	MOVL	UCB$L_CRB(R5),R3		; R3 => TM78 CRB

; Here make sure that we do not bog down the system with multiple TMCLRs
;	to a sick TM78.  We do this by refusing to do a TMCLR if less than
;	10 minutes have occurred since the last one.  The time of the last
;	one is kept in CRB$L_AUXSTRUC.

	ADDL3	#10*60,CRB$L_AUXSTRUC(R3),R0	; R0 has time 10 minutes after
	CMPL	R0,G^EXE$GL_ABSTIM		;  last TMCLR.  Is that in the
	BLSS	15$				;  past?.  LSS means no.
	MOVL	G^EXE$GL_ABSTIM,-		; If we are going to do TMCLR,
		CRB$L_AUXSTRUC(R3)		;  then record time now in CRB.

	ASSUME	IDB$L_CSR EQ 0
	MOVL	@CRB$L_INTD+VEC$L_IDB(R3),R3	; R3 => TM78 CSR

	BICW	#UCB$M_MF_ATTN!-	; Reset bit that provoked this call.
		 UCB$M_MF_EXSNS_DONE,-	;  and bit that prevents redundant
		UCB$W_DEVSTS(R5)	;  extended sense operations.
	RELCHAN				; Just in case we had channels.

	BISL	#MF_ID_M_TMCLR,MF_ID(R3); Reset TM78 hardware.
	MOVZBL	#255,R4			; Setup count to prevent infinte loop.
10$:
	IOFORK				; Waste a little time.
	BITL	#MF_ID_M_TMRDY,MF_ID(R3); Has TM78 settled down?
	BNEQ	20$			; NEQ implies TM78 now reset.
	SOBGTR	R4,10$			; Loop a limited number of times.
15$:					; Either failed or refused to do TMCLR.
	BICW	#UCB$M_MF_TMRDY,-	; In the case of failure, reset our
		UCB$W_DEVSTS(R5)	;  bit.
	MOVZWL	#SS$_CTRLERR,R0		; Set final I/O status.
	BRB	50$			; And branch around.
20$:
	MOVL	UCB$L_CRB(R5),R4		; R4 => TM78 CRB.
	MOVL	CRB$L_INTD+VEC$L_IDB(R4),R4	; R4 => TM78 IDB.
	CLRL	R0				; Loop counter.
30$:
	MOVL	IDB$L_UCBLST(R4)[R0],R3	; R3 => a UCB.
	BEQL	40$			; EQL implies no such UCB.
	BICW	#UCB$M_MF_TMRDY,-	; Signal other processes that they
		UCB$W_DEVSTS(R3)	;  may continue.
40$:	AOBLEQ	#3,R0,30$		; Loop thru all 4 possible drives.

	MOVZWL	S^#SS$_NORMAL,R0	; Set final status.
50$:
	SUBPUSH	R0			; Save STATUS.
	BLBC	R0,60$			; If TMCLR was UNsuccessful, branch,
					;  since if we couldn't TMCLR, we can't
					;  do an EXTENDED SENSE either.

	BSBW	INVOKE_EXTENDED_SENSE
60$:
	BICW	#UCB$M_MF_EXSNS_DONE,-	; Clear again so we can get SENSE on
		UCB$W_DEVSTS(R5)	;  regular I/O operation errorlog.

	JSB	G^ERL$DEVICEATTN	; Call special errorlog entry.

	SUBPOP	R0			; Restore STATUS.
	SUBPOP	R4,R3
	SUBRETURN
	.PAGE
	.SBTTL	TM78/TU78 SLAVE CONTROLLER INTERRUPT DISPATCHER
;+
; TF$INT - TM78/TU78 SLAVE CONTROLLER INTERRUPT DISPATCHER
;
; THIS ROUTINE IS ENTERED VIA A JSB INSTRUCTION WHEN AN ATTENTION
; INTERRUPT OCCURS ON A TM78/TU78 SLAVE CONTROLLER.
; THE STATE OF THE STACK ON ENTRY IS:
;
;	00(SP) = ADDRESS OF IDB ADDRESS.
;	04(SP) = SAVED R2.
;	08(SP) = SAVED R3.
;	12(SP) = SAVED R4.
;	16(SP) = SAVED R5.
;	20(SP) = INTERRUPT PC.
;	24(SP) = INTERRUPT PSL.
;
; INTERRUPT DISPATCHING OCCURS AS FOLLOWS:
;
;	For DATA TRANSFER interrupts we simply restore registers R3 and R4
;	call back the DRIVER at the return address.  We determine that we
;	are processing a DATA TRANSFER interrupt if both the PRIMARY and
;	SECONDARY channels (i.e. the TM78 CRB-IDB and the MBA CRB-IDB) are
;	owned by the UCB of interest and the UCB is expecting an interrupt.
;
;	If we did NOT have a DATA TRANSFER interrupt we simply branch around
;	the call back to the DRIVER.
;
;	After return from the DRIVER call back or after branching around the
;	DRIVER call back, as the case may be, we proceed to determine if an
;	ATTENTION interrupt is present and if so we process.
;
;	We determine if the attention bit is set for the TM78.  If this is
;	not so, we simply branch around to dismiss the interrupt.  If
;	however the attention bit for the TM78 is set we proceed to read the
;	Non-Data Transfer Attention register in order to determine which
;	drive caused the ATTENTION.  If the unit is expecting an interrupt
;	then the DRIVER is called at its interrupt return address.  If no
;	interrupt was expected, then the DRIVER is called at its UNSOLICITED
;	interrupt address.  Upon return from either call the attention bit is
;	cleared and the interrupt is dismissed.
;
;-

TF$INT::				;TM78/TU78 SLAVE CONTROLLER INTERRUPT DISPATHCER
	MOVL	@(SP),R4		; R4 => IDB.
	MOVL	IDB$L_OWNER(R4),R5	; R5 => owner UCB.
	BEQL	10$			; EQL => no owner.

					; If here we own PRIMARY channel.
	MOVL	UCB$L_CRB(R5),R4		; R4 => TM78 CRB
	MOVL	CRB$L_LINK(R4),R4		; R4 => MBA CRB
	MOVL	CRB$L_INTD+VEC$L_IDB(R4),R4	; R4 => MBA IDB
	CMPL	R5,IDB$L_OWNER(R4)		; Are we owners of MBA also?
	BNEQ	10$				; If NOT, branch around call back.

					; If here we also own SECONDARY channel.
	BBCC	#UCB$V_INT,-		; If clear DATA TRANSFER interrupt not
		UCB$W_STS(R5),10$	;  expected, so branch around call back.
	MOVQ	UCB$L_FR3(R5),R3	; Restore driver registers R3 and R4.
	JSB	@UCB$L_FPC(R5)		; Call back driver at return address.

;
; Here we determine if the TM78 has a pending attention interrupt.  To do that
;	we first determine which port on the MASSBUS is occupied by this TM78.
;	To do this we obtain a pointer to the MBA-CSR indirectly
;	through the IDB=>ADP.  With the TM78-CSR address already in hand,
;	we subtract to determine the distance of the TM78-CSR to the base
;	of the MBA external registers.  This difference divided by 128
;	(right shifted by 7) gives the port number of interest.  We then test
;	the attention bit corresponding to the port number.


10$:	MOVL	@(SP),R4		; Again R4 => IDB.
	MOVL	IDB$L_CSR(R4),R3	; R3 => TM78-CSR.
	ASSUME	ADP$L_CSR  EQ  0
	MOVL	@IDB$L_ADP(R4),R5	; R5 => MBA-CSR
	MOVAB	MBA$L_ERB(R5),R2	; R2 => base of MBA external registers
	SUBL3	R2,R3,R2		; R2 = distance of TM78-CSR from base
	ASHL	#-7,R2,R2		; R2 = MBA port number.
	MOVL	MBA$L_AS(R5),R4		; R4 = MBA attention summary.
	BBC	R2,R4,70$		; Branch if no attention pending.
	MOVL	@(SP),R4		; Again R4 => IDB.
	PUSHR	#^M<R2,R5>		; Remember registers to clear attention.

;
; If we are here we have a pending attention condition.  We read the
;	non-data transfer attention register (MF_NDTA) and extract the
;	unit number of the device which generated the attention.  If
;	the UCB corresponding to this unit indicates that an interrupt is
;	expected, then we reload the driver fork context and call back the
;	driver.  If however no interrupt is expected, we call the unsolicited
;	interrupt entry.  In either case we then clear the attention bit
;	and proceed to dismiss the interrupt.
;

	PUSHL	MF_NDTA(R3)		; Save Non-Data Transfer Attention
					;  register on stack.

	EXTZV	#MF_NDTA_V_ATAD,#MF_NDTA_S_ATAD,-
		(SP),R2			; R2 = Unit number of device of interest
	MOVL	IDB$L_UCBLST(R4)[R2],R5	; R5 => UCB of unit of interest.
	BNEQ	20$			; If we got a UCB, OK branch.
	TSTL	(SP)+			; Else clear MF_NDTA from stack.
	BRB	60$			; And branch around.
20$:
	BICW	#UCB$M_MF_REWIND,-
		UCB$W_DEVSTS(R5)	; Reset REWIND in progress, just in case.
	EXTZV	#MF_NDTA_V_NDIC,-	; Extract interrupt code from
		#MF_NDTA_S_NDIC,-	;  interrupt status returned by
		(SP),R2			;  TM78
	POPL	UCB$L_MF_NDTA(R5)	; Copy contents of register to UCB.

	CMPB	#HIC_ON_LINE,R2		; See if UNSOLICITED On-line interrupt.
	BEQL	50$			; If so, branch around even if we are
					;  expecting an interrupt since the
					;  other interrupt will occur later.

	CMPB	#HIC_TM_FAULT_B,R2	; See if the interrupt code coincides
	BEQL	30$			;  with one of the UNSOLICITED type
	CMPB	#HIC_TU_FAULT_B,R2	;  FAULT codes.  If so then
	BEQL	30$			;  we treat it as both an UNSOLICITED
	CMPB	#HIC_MB_FAULT,R2	;  interrupt and then see if we were
	BNEQ	40$			;  expecting something.
30$:
	PUSHR	#^M<R3,R4,R5>		; Since we may IOFORK in FAULT_INTERRUPT
	BSBW	FAULT_INTERRUPT		; Record FAULT data.
	POPR	#^M<R3,R4,R5>		; Restore.
40$:
	BBCC	#UCB$V_INT,-
		UCB$W_STS(R5),50$	; Branch to call TF_UNSOLNT if not expected.

	MOVQ	UCB$L_FR3(R5),R3	; Restore registers R3 and R4.
	JSB	@UCB$L_FPC(R5)		; Call back driver at return address.
	BRB	60$			; Branch around.
50$:
	BSBW	TF_UNSOLNT		; Call unsolicited interrupt entry.
	BBC	#UCB$V_INT,-		; If NOT waiting for an interrupt,
		UCB$W_STS(R5),60$	;  branch around the following KLUDGE.

					; Here, we MUST have received an ON-LINE
					;  interrupt while also awaiting a
					;  DONE interrupt.  Unless this is due
					;  to awaiting a MANUAL rewind or to
					;  waiting for the UCB$M_MF_REWIND bit
					;  in START_IO, we ignore it.  To deter-
					;  mine whether either of these two
					;  conditions obtain, we compare the
					;  FORK return point to those associated
					;  with these two conditions.
	MOVAB	WAITING_FOR_REWIND,R2	; R2 => return point waiting for bit to
					;  reset.
	CMPL	R2,UCB$L_FPC(R5)	; See if the same.
	BEQL	40$			; If =, honor interrupt and resume thread.
	MOVAB	WAITING_FOR_MANUAL,R2	; R2 => return for manual rewind.
	CMPL	R2,UCB$L_FPC(R5)	; Are they =?
	BEQL	40$			; If =, branch to resume thread.
60$:					; Here we clear the attention bit.
	POPR	#^M<R2,R5>		; Restore R2 = port #, R5 => MBA-CSR.
	ASHL	R2,#1,MBA$L_AS(R5)	; Clear attention summary bit.
70$:
	TSTL	(SP)+			; Clear IDB ptr from stack.
	MOVQ	(SP)+,R2		;RESTORE REGISTERS
	MOVQ	(SP)+,R4		;
	REI				;
TF_END:					;ADDRESS OF LAST LOCATION IN DRIVER

	.END
