	.TITLE	DRDRIVER - RM03/RM05/RM80/RP07 DISK DRIVER
	.IDENT	'V03-001'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER, LEN KAWELL 23-NOV-77
; 
;  MODIFIED BY:
;
;	V03-001	ROW0084		Ralph O. Weber			15-FEB-1982
;		Change retryable error recovery to save volital registers 
;		before RELCHAN, and restore them after.  Also eliminate 
;		now extranous register restores before decrementing error 
;		retry counter.
;
;	V02-021	ROW0068		Ralph O. Weber			17-FEB-1982
;		Modify unit initialization routine to compensate for the fact 
;		that the RP07 presents a false medium-online status during the 
;		power up sequence following a power failure.  This situtation 
;		is compensated for by a do nothing wait of about 50 milli-
;		seconds at the critical point during power failure recovery.
;
;	V02-020	EAD0013		Elliott A. Drayton		 2-Feb-1982
;		Add test of DEV$M_DUA (DUAL_PORT) bit in UCB$L_DEVCHAR.
;
;	V02-019	ROW0062		Ralph O. Weber		 	4-JAN-1982
;		Modify unit initialization routine to compensate for the fact 
;		that the RP07 reports itself as a non-existant drive for a 
;		short period following a power failure.  The correction is to 
;		add a wait loop which waits for drives already having UCBs to 
;		report themselves existant.  Also changed several RM03 
;		specific references in the comments to generic references.
;
;	V02-018	ROW0055		Ralph O. Weber			 8-DEC-1981
;		Add code to conditionaly seize a port based on the presence of 
;		a dual-port kit.  Method taken for Elliott's work in the 
;		DBDRIVER, EAD0009.
;		Remove setting of ECI bit in offset register.  Previously this 
;		bit served two purposes; eliminating time required to perform 
;		ECC on write check operations, and signaling when ECC 
;		information should be ignored.  The first use inhibits 
;		production of useful diagnostic information on the RP07 and 
;		RM80 drives.  Since a software ignore ECC bit must be 
;		introduced to replace the ECI bit during write check 
;		operations, that bit can also serve generally to signal when 
;		ECC information should be ignored, thus eliminating the second 
;		use of the ECI bit.
;
;	V02-017	ROW0052		Ralph O. Weber			29-NOV-1981
;		Add check in unsolicited interrupt routine which prevents 
;		unsolicited interrupts which occur during PACKACK sequence 
;		from clearing the software volume valid bit.
;
;	V02-016	ROW0047		Ralph O. Weber			19-NOV-1981
;		Backout the retry-after-search-ahead changes made in version 
;		14 and replace them with a special section in FEX.  The new 
;		method seperates the error recovery for search-ahead 
;		operations from other error recovery in a manner which 
;		prevents error log entries for failed search-ahead operations.
;
;	V02-015	ROW0046		Ralph O. Weber			16-NOV-1981
;		Cause IO$_PACKACK to set UCB$V_VALID in UCB$W_STS.  Add two 
;		new functions IO$_UNLOAD and IO$_AVAILABLE both of which clear 
;		UCB$V_VALID.  NB: none of the drives supported by this driver 
;		provide a hardware unload function; therefore, this driver 
;		need support unload only to the extent of clearing 
;		UCB$V_VALID.
;
;	V02-014	ROW0044		Ralph O. Weber			13-NOV-1981
;		1. Remove geometry information for drives not supported by 
;		   this driver from the Drive Type Description Table.
;		2. Alter retry logic for search-ahead retriable errors to 
;		   perform retry only if error reported is seek incomplete.
;		3. Alter wait-for-drive-to-spinup logic in unit initialization 
;		   routine to wait for medium-online bit to become set rather 
;		   than for the volume-valid bit.
;
;	V02-013 EAD00012	Elliott A. Drayton		26-Oct-1981
;		Corrected bug in retriable error logic so that valid data for
;		disk status is available in R0, R1. Also removed two
;		instructions which have been commented out.
;
;	V02-012	RLRFRMAT	Robert L. Rappaport		6-July-1981
;		Corrected minor bug introduced by correction to SKIP
;		SECTORING problem.  Bug causes IAE (Illegal Address Error)
;		errors when doing physical I/O with IO$M_SKPSECINH specified.
;		Since this is only done by the online FORMATTER the bug
;		has only minor impact on most users.  The bug resulted
;		from the unconditional decrement from UCB$W_DA whenever
;		Skip Sector Error Inhibit was found to be set.  The
;		correction consists of determining the reason that Skip
;		Sector Errors are inhibited and only if it is due to
;		having encountered a Skip Sector error do we proceed to
;		decrement this value.
;
;	V02-011	EAD0001		Elliott A. Drayton		 6-July-1981
;		Added support for dual porting.
;
;	V02-010	RLR0004		Robert L. Rappaport		19-June-1981
;		Correct error introduced by RLR32161, wherein HCRC errors
;		were being handled via RECAL rather than with offset recovery.
;
;	V02-009	RLR33329A	Robert L. Rappaport		10-June-1981
;		Prevent creation of error log entries if Medium offline
;		prior to beginning of operation.
;
;	V02-008	RLR0003		Robert L. Rappaport		30-Apr-1981
;		Corrected bugs in skip sectoring.  First bug involved
;		use of UCB$W_DA to bias sector number by one when a SKIP
;		SECTOR error was encountered.  Problem arose when another
;		track in the same I/O transfer also had SKIP SECTORS.  Then
;		biased value in UCB$W_DA confused IOC$UPDATRANSP.
;		The other bug involved setting and clearing of SSEI bit in
;		software word UCB$W_OFFSET.  The problem arose when, while
;		in a SKIP SECTOR region, if another error (such as ECC)
;		were to occur on the last normal sector (#30) of the
;		track, IOC$UPDATRANSP would spiral to the next track
;		without making use of the reserve sector and also
;		we would leave on the SSEI bit when this next track
;		did not have skip sectoring in force.
;
;	V02-007	RLR0002		Robert L. Rappaport		5-Nov-1980
;		Changed determination of the number of bytes transferred
;		when errors occur during a data transfer to the more
;		more conservative of the two halves of the value
;		contained in MBA$L_BCR.  Briefly, the high word of the
;		contents of this register reflects the number of bytes
;		transferred over the MASSBUS (i.e to or from the drive)
;		while the low word reflects the number of bytes transferred
;		to or from memory.  On a read (from disk) the more
;		conservative value is the low word while on a write (to disk)
;		the high word is the more conservative value.
;	V02-006	RLR32161	Robert L. Rappaport		3-Sept-1980
;		Fixed two problems:
;		  1.  Placed RELCHAN before doing a RECAL due to HCE errors
;			to prevent attention interrupts on other MASSBUS
;			devices from being interpreted as the interrupt
;			following the RECAL.
;		  2.  Reordered the checking of error bits to check HCRC then
;			HCE followed by BSE,FER and SSE; as per SKIP WITHROW
;			memo of 1-APR-1980.
;
;	V02-005	ACG0179		Andrew C. Goldstein,	23-Jul-1980  18:30
;		Fix ACP class code in DPT
;
;	V02-004	RLR0001		Robert L. Rappaport		4-JUNE-1980
;		Changed WRITETRACKD and READTRACKD to SEEK rather than to
;		SEARCH to arrive on cylinder since SEARCH doesn't work if
;		the track descriptors have been clobbered.
;
; RM03/RM05/RM80/RP07 DISK DRIVER
;
; MACRO LIBRARY CALLS
;
 
	$CRBDEF				;DEFINE CRB OFFSETS
	$DDBDEF				;DEFINE DDB OFFSETS
	$DPTDEF				;DEFINE DPT OFFSETS
	$EMBDEF				;DEFINE EMB OFFSETS
	$IDBDEF				;DEFINE IDB OFFSETS
	$IODEF				;DEFINE I/O FUNCTION CODES
	$IRPDEF				;DEFINE IRP OFFSETS
	$MBADEF				;DEFINE MBA REGISTER OFFSETS
	$PRDEF				;Define processor register numbers
	$UCBDEF				;DEFINE UCB OFFSETS
	$VECDEF				;DEFINE INTERRUPT DISPATCH VECTOR OFFSETS
 
;
; LOCAL MACROS
;
; EXECUTE FUNCTION AND BRANCH ON RETRIABLE ERROR CONDITION
;
 
	.MACRO	EXFUNC BDST,FCODE
		.IF NB	FCODE
		MOVZBL	#CD'FCODE,R0
		.ENDC
		BSBW	FEX
		.SIGNED_WORD BDST-.-2
	.ENDM
 
;
; GENERATE FUNCTION TABLE ENTRY AND CASE TABLE INDEX SYMBOL
;
 
	.MACRO	GENF FCODE
		CD'FCODE=.-FTAB
		.BYTE	FCODE!RM_CS1_M_GO
	.ENDM
 
;
; LOCAL SYMBOLS
;
; MASSBUS REGISTER OFFSETS
;
 
	$DEFINI	RM
 
$DEF	RM_CS1		.BLKL	1	;DRIVE CONTROL REGISTER
	_VIELD	RM_CS1,0,<-		; DRIVE CONTROL REGISTER BIT DEFINITIONS
		<GO,,M>,-		; GO BIT
		<FCODE,5>-		; FUNCTION CODE
	>				;
$DEF	RM_DS		.BLKL	1	;DRIVE STATUS REGISTER
	_VIELD	RM_DS,0,<-		; DRIVE STATUS REGISTER BIT DEFINITIONS
		<OM,,M>,-		; OFFSET MODE
		<,5>,-			; RESERVED BITS
		<VV,,M>,-		; VOLUME VALID
		<DRY,,M>,-		; DRIVE READY
		<DPR,,M>,-		; DRIVE PRESENT
		<PGM,,M>,-		; PROGRAMMABLE
		<LST,,M>,-		; LAST SECTOR TRANSFERED
		<WRL,,M>,-		; DRIVE WRITE LOCKED
		<MOL,,M>,-		; MEDIUM ONLINE
		<PIP,,M>,-		; POSITIONING IN PROGRESS
		<ERR,,M>,-		; COMPOSITE ERROR
		<ATA,,M>-		; ATTENTION ACTIVE
	>				;
$DEF	RM_ER1		.BLKL	1	;ERROR REGISTER 1
	_VIELD	RM_ER1,0,<-		; ERROR REGISTER 1 BIT DEFINITIONS
		<ILF,,M>,-		; ILLEGAL FUNCTION
		<ILR,,M>,-		; ILLEGAL REGISTER
		<RMR,,M>,-		; REGISTER MODIFY REFUSED
		<PAR,,M>,-		; PARITY ERROR
		<FER,,M>,-		; FORMAT ERROR
		<WCF,,M>,-		; WRITE CLOCK FAIL
		<ECH,,M>,-		; ECC HARD ERROR
		<HCE,,M>,-		; HEADER COMPARE ERROR
		<HCRC,,M>,-		; HEADER CRC ERROR
		<AOE,,M>,-		; ADDRESS OVERFLOW ERROR
		<IAE,,M>,-		; ILLEGAL ADDRESS ERROR
		<WLE,,M>,-		; WRITE LOCK ERROR
		<DTE,,M>,-		; DRIVE TIMING ERROR
		<OPI,,M>,-		; OPERATION INCOMPLETE
		<UNS,,M>,-		; DRIVE UNSAFE
		<DCK,,M>-		; DATA CHECK ERROR
	>				;
$DEF	RM_MR		.BLKL	1	;MAINTENANCE REGISTER
	_VIELD	RM_MR,0,<-		; MAINTENANCE REGISTER DEFINITIONS
		<PAR,8>,-		; DIAGNOSTIC PARAMETER
		<RTN,7>,-		; DIAGNOSTIC ROUTINE NUMBER
		<DM,,M>,-		; DIAGNOSTIC MODE
	>
$DEF	RM_AS		.BLKL	1	;ATTENTION SUMMARY REGISTER
$DEF	RM_DA		.BLKL	1	;DESIRED SECTOR/TRACK ADDRESS REGISTER
	_VIELD	RM_DA,0,<-		; DESIRED ADDRESS FIELD DEFINITIONS
		<SA,5>,-		; DESIRED SECTOR ADDRESS
		<,3>,-			; RESERVED BITS
		<TA,5>-			; DESIRED TRACK ADDRESS
	>				;
$DEF	RM_DT		.BLKL	1	;DRIVE TYPE REGISTER
	_VIELD	RM_DT,0,<-		; DRIVE TYPE REGISTER FIELD DEFINITIONS
		<DTN,9>,-		; DRIVE TYPE NUMBER
		<,2>,-			; RESERVED BITS
		<DRQ,,M>-		; DRIVE REQUEST REQUIRED
	>				;
$DEF	RM_LA		.BLKL	1	;LOOKAHEAD REGISTER
$DEF	RM_SN		.BLKL	1	;SERIAL NUMBER REGISTER
$DEF	RM_OF		.BLKL	1	;OFFSET REGISTER
	_VIELD	RM_OF,0,<-		; OFFSET REGISTER BIT DEFINITIONS
		<OFF,8>,-		; OFFSET VALUE
		<,1>,-			; RESERVED
		<SSEI,,M>,-		; SKIP SECTOR INHIBIT (RM80)
		<HCI,,M>,-		; HEADER COMPARE INHIBIT
		<ECI,,M>,-		; ECC INHIBIT (avoid using this bit)
		<FMT,,M>,-		; 16-BIT FORMAT
		<,1>,-			; RESERVED
		<MTD,,M>,-		; MOVE TRACK DESCRIPTOR
		<CMO,,M>-		; COMMAND MODIFIER
	>				;
$DEF	RM_DC		.BLKL	1	;DESIRED CYLINDER ADDRESS
$DEF	RM_UNUSED	.BLKL	1	;UNUSED
$DEF	RM_MR2		.BLKL	1	;MAINTENANCE REGISTER 2
$DEF	RM_ER2		.BLKL	1	;ERROR REGISTER 2
	_VIELD	RM_ER2,3,<-		; ERROR REGISTER 2 BIT DEFINITIONS
		<DPE,,M>,-		; DATA PARITY ERROR
		<,1>,-			; RESERVED BIT
		<SSE,,M>,-		; SKIP SECTOR ERROR (RM80)
		<,1>,-			; RESERVED BIT
		<DVC,,M>,-		; DEVICE CHECK ERROR
		<,2>,-			; RESERVED BITS
		<LBC,,M>,-		; LOSS OF BIT CLOCK ERROR
		<LSC,,M>,-		; LOSS OF SYSTEM CLOCK ERROR
		<IVC,,M>,-		; INVALID COMMAND ERROR
		<OPE,,M>,-		; OPERATOR PLUG ERROR
		<SKI,,M>,-		; SEEK INCOMPLETE ERROR
		<BSE,,M>-		; BAD SECTOR ERROR
	>				;
$DEF	RM_EC1		.BLKL	1	;ECC POSITION REGISTER
	_VIELD	RM_EC1,0,<<POS,13>>	; ECC POSITION FIELD
$DEF	RM_EC2		.BLKL	1	;ECC PATTERN REGISTER
	_VIELD	RM_EC2,0,<<PAT,11>>	; ECC PATTERN FIELD
 
	$DEFEND	RM
 
;
; DEFINE DEVICE DEPENDENT UNIT CONTROL BLOCK OFFSETS
;
 
	$DEFINI	UCB
 
.=UCB$W_BCR+2				;
 
$DEF	UCB$L_DR_SR	.BLKL	1	;SAVED MBA STATUS REGISTER
$DEF	UCB$W_DR_ER2	.BLKW	1	;SAVED ERROR REGISTER 2
$DEF	UCB$W_DR_MR	.BLKW	1	;MAINTENANCE REGISTER
$DEF	UCB$B_DR_SSTS	.BLKB	1	;SOFTWARE STATUS BYTE
	_VIELD	DR,0,<-			; SOFTWARE STATUS BIT DEFINITIONS
		<DCK,,M>,-		; DATACHECK IN PROGRESS
		<OM,,M>,-		; OFFSET MODE
		<NOECC,,M>,-		; Don't correct with ECC
		<DUALPORT,,M>-		; Drive has a dualport kit
	>
$DEF	UCB$B_DR_ERL	.BLKB	1	;ERROR LOGGING REGISTER FOR MED OFFLINE
$DEF	UCB$W_DR_OFR	.BLKW	1	;SAVED OFFSET REGISTER
$DEF	UCB$L_DR_BCR	.BLKL	1	; Saved (longword) MBA byte count reg.
UCB$K_DR_LENGTH=.
 
	$DEFEND	UCB
 
;
; HARDWARE FUNCTION CODES
;
 
F_NOP=0*2				;NO OPERATION
F_SEEK=2*2				;SEEK CYLINDER
F_RECAL=3*2				;RECALIBRATE
F_DRVCLR=4*2				;DRIVE CLEAR
F_RELEASE=5*2				;RELEASE DRIVE
F_OFFSET=6*2				;OFFSET HEADS
F_RETCENTER=7*2				;RETURN TO CENTERLINE
F_READPRESET=8*2			;READ IN PRESET
F_PACKACK=9*2				;PACK ACKNOWLEDGE
F_SEARCH=12*2				;SEARCH FOR SECTOR
F_SEARCHA=12*2				;SEARCH AHEAD FOR SECTOR
F_DIAGNOSE=14*2				;DIAGNOSE DRIVE
F_WRITECHECK=20*2			;WRITE CHECK DATA
F_WRITECHECKH=21*2			;WRITE CHECK HEADER AND DATA
F_WRITEDATA=24*2			;WRITE DATA
F_WRITEHEAD=25*2			;WRITE HEADER AND DATA
F_WRITETRACKD=26*2			;WRITE TRACK DESCRIPTOR
F_READDATA=28*2				;READ DATA
F_READHEAD=29*2				;READ HEADER AND DATA
F_READTRACKD=30*2			;READ TRACK DESCRIPTOR
F_AVAILABLE=F_NOP			;AVAILABLE
 
;
; LOCAL DATA
;
; DRIVER PROLOGUE TABLE
;
 
	DPTAB	-			;DEFINE DRIVER PROLOGUE TABLE
		END=DR_END,-		;END OF DRIVER
		ADAPTER=MBA,-		;ADAPTER TYPE
		FLAGS=DPT$M_SVP,-	;SYSTEM PAGE TABLE ENTRY REQUIRED
		UCBSIZE=UCB$K_DR_LENGTH,-	;UCB size
		NAME=DRDRIVER		;DRIVER NAME
	DPT_STORE INIT			;CONTROL BLOCK INIT VALUES
	DPT_STORE DDB,DDB$L_ACPD,L,<^A\F11\> ;DEFAULT ACP NAME
	DPT_STORE DDB,DDB$L_ACPD+3,B,DDB$K_PACK	;ACP CLASS
	DPT_STORE UCB,UCB$B_FIPL,B,8	;FORK IPL
	DPT_STORE UCB,UCB$L_DEVCHAR,L,-	;DEVICE CHARACTERISTICS
		<DEV$M_FOD-		; FILES ORIENTED
		!DEV$M_DIR-		; DIRECTORY STRUCTURED
		!DEV$M_AVL-		; AVAILABLE
		!DEV$M_ELG-		; ERROR LOGGING ENABLED
		!DEV$M_SHR-		; SHAREABLE
		!DEV$M_IDV-		; INPUT DEVICE
		!DEV$M_ODV-		; OUTPUT DEVICE
		!DEV$M_RND>		; RANDOM ACCESS
	DPT_STORE UCB,UCB$B_DEVCLASS,B,DC$_DISK ;DEVICE CLASS
	DPT_STORE UCB,UCB$W_DEVBUFSIZ,W,512 ;DEFAULT BUFFER SIZE
	DPT_STORE UCB,UCB$B_DIPL,B,21	;DEVICE IPL
	DPT_STORE UCB,UCB$B_ERTCNT,B,8	;ERROR RETRY COUNT
	DPT_STORE UCB,UCB$B_ERTMAX,B,8	;MAX ERROR RETRY COUNT
	DPT_STORE REINIT		;CONTROL BLOCK RE-INIT VALUES
	DPT_STORE DDB,DDB$L_DDT,D,DR$DDT ;DDT ADDRESS
	DPT_STORE END			;
 
;
; DRIVER DISPATCH TABLE
;
 
	DDTAB	DR,-			;DRIVER DISPATCH TABLE
		DR_STARTIO,-		;START I/O OPERATION
		DR_UNSOLNT,-		;UNSOLICITED INTERRUPT
		DR_FUNCTABLE,-		;FUNCTION DECISION TABLE
		0,-			;CANCEL I/O ENTRY POINT
		DR_REGDUMP,-		;REGISTER DUMP ROUTINE
		<<RM_EC2+4+4+MBA$L_BCR+4+8>+<<5+5+1>*4>>,- ;DIAG BUFF SIZE
		<<RM_EC2+4+4+MBA$L_BCR+4+8>+<1*4>+<EMB$L_DV_REGSAV>>,- ;ERLG BUFF SIZE
		DR_UNIT_INIT		;UNIT INITIALIZATION
 
;
; DATA CHECK FUNCTION TRANSLATION TABLE
;
 
CHECKTAB:				;
	.BYTE	CDF_WRITECHECK		;WRITE DATA
	.BYTE	CDF_WRITECHECK		;READ DATA
	.BYTE	CDF_WRITECHECKH		;WRITE HEADER AND DATA
	.BYTE	CDF_WRITECHECKH		;READ HEADER AND DATA
 
;
; DRIVE TYPE DESCRIPTOR TABLE
;
DR_DTDESC:				;
	.WORD	^X14			; RM03
	.BYTE	DT$_RM03		;
	.BYTE	32			; 32 SECTORS
	.BYTE	5			; 5 TRACKS
	.WORD	823			; 823 CYLINDERS
	.LONG	823*5*32		; MAXIMUM BLOCKS
DR_DTDESCLEN=.-DR_DTDESC		;LENGTH OF DRIVE TYPE DESCRIPTOR

	.WORD	^X16			; RM80
	.BYTE	DT$_RM80		;
	.BYTE	31			; 31 SECTORS
	.BYTE	14			; 14 TRACKS
	.WORD	559			; 559 CYLINDERS 
	.LONG	559*14*31		; MAXIMUM BLOCKS 
	.WORD	^X17			; RM05
	.BYTE	DT$_RM05		; 
	.BYTE	32			; 32 SECTORS
	.BYTE	19			; 19 TRACKS
	.WORD	823			; 823 CYLINDERS
	.LONG	823*19*32		; MAXIMUM BLOCKS
	.WORD	^X22			; RP07
	.BYTE	DT$_RP07		; 
	.BYTE	50			; 50 SECTORS
	.BYTE	32			; 32 TRACKS
	.WORD	630			; 630 CYLINDERS
	.LONG	630*32*50		; MAXIMUM BLOCKS

	.WORD	0			; END OF TABLE
	.BLKB	DR_DTDESCLEN		; SPARE DRIVE TYPE SLOT
	.BLKB	DR_DTDESCLEN		; SPARE DRIVE TYPE SLOT

;
; HARDWARE I/O FUNCTION CODE TABLE
;
 
FTAB:					;
	GENF	F_NOP			;NO OPERATION
	GENF	F_NOP			;(NO UNLOAD FUNCTION)
	GENF	F_SEEK			;SEEK CYLINDER
	GENF	F_RECAL			;RECALIBRATE
	GENF	F_DRVCLR		;DRIVE CLEAR
	GENF	F_NOP			;(NO RELEASE PORT)
	GENF	F_OFFSET		;OFFSET HEADS
	GENF	F_RETCENTER		;RETURN HEADS TO CENTERLINE
	GENF	F_PACKACK		;PACK ACKNOWLEDGE
	GENF	F_SEARCH		;SEARCH FOR SECTOR
	GENF	F_WRITECHECK		;WRITE CHECK
	GENF	F_WRITEDATA		;WRITE DATA
	GENF	F_READDATA		;READ DATA
	GENF	F_WRITEHEAD		;WRITE HEADER AND DATA
	GENF	F_READHEAD		;READ HEADER AND DATA
	GENF	F_WRITETRACKD		;WRITE TRACK DESCRIPTOR
	GENF	F_READTRACKD		;READ TRACK DESCRIPTOR
	GENF	F_AVAILABLE		;AVAILABLE
	GENF	F_WRITECHECKH		;WRITE CHECK HEADER AND DATA
	GENF	F_READPRESET		;READ IN PRESET
	GENF	F_DIAGNOSE		;DIAGNOSE THE DRIVE
	GENF	F_SEARCHA		;SEARCH AHEAD OF SECTOR
 
;
; OFFSET TABLE 
;
 
OFFTAB:					;
	.BYTE	0			;RETURN TO CENTERLINE
	.BYTE	^X01			;+ OFFSET (BIT 0 = OFFSET FLAG)
	.BYTE	^X81			;- OFFSET (BIT 0 = OFFSET FLAG)
	.BYTE	0			;RETURN TO CENTERLINE
OFFSIZ=.-OFFTAB				;SIZE OF OFFSET TABLE
	.PAGE
	.SBTTL	FUNCTION DECISION TABLE
;+
; RM03 FUNCTION DECISION TABLE
;-
 
DR_FUNCTABLE:				;FUNCTION DECISION TABLE
	FUNCTAB	,-			;LEGAL FUNCTIONS
		<NOP,-			;NO OPERATION
		UNLOAD,-		;UNLOAD VOLUME
		SEEK,-			;SEEK CYLINDER
		RECAL,-			;RECALIBRATE
		DRVCLR,-		;DRIVE CLEAR
		RELEASE,-		;RELEASE PORT
		OFFSET,-		;OFFSET HEADS
		RETCENTER,-		;RETURN HEADS TO CENTERLINE
		PACKACK,-		;PACK ACKNOWLEDGE
		SEARCH,-		;SEARCH FOR SECTOR
		READPRESET,-		;READ IN PRESET
		SENSECHAR,-		;SENSE CHARACTERISTICS
		SETCHAR,-		;SET CHARACTERISTICS
		SENSEMODE,-		;SENSE MODE
		SETMODE,-		;SET MODE
		WRITECHECK,-		;WRITE CHECK
		WRITEHEAD,-		;WRITE HEADER AND DATA
		READHEAD,-		;READ HEADER AND DATA
		WRITETRACKD,-		;WRITE TRACK DESCRIPTOR
		READTRACKD,-		;READ TRACK DESCRIPTOR
		WRITECHECKH,-		;WRITE CHECK HEADER AND DATA
		DIAGNOSE,-		;DIAGNOSE THE DRIVE
		READLBLK,-		;READ LOGICAL BLOCK
		WRITELBLK,-		;WRITE LOGICAL BLOCK
		READPBLK,-		;READ PHYSICAL BLOCK
		WRITEPBLK,-		;WRITE PHYSICAL BLOCK
		READVBLK,-		;READ VIRTUAL BLOCK
		WRITEVBLK,-		;WRITE VIRTUAL BLOCK
		AVAILABLE,-		;AVAILABLE
		ACCESS,-		;ACCESS FILE AND/OR FIND DIRECTORY ENTRY
		ACPCONTROL,-		;ACP CONTROL FUNCTION
		CREATE,-		;CREATE FILE AND/OR CREATE DIRECTORY ENTRY
		DEACCESS,-		;DEACCESS FILE
		DELETE,-		;DELETE FILE AND/OR DIRECTORY ENTRY
		MODIFY,-		;MODIFY FILE ATTRIBUTES
		MOUNT>			;MOUNT VOLUME
	FUNCTAB	,-			;BUFFERED I/O FUNCTIONS
		<NOP,-			;NO OPERATION
		 UNLOAD,-		;UNLOAD VOLUME
		 SEEK,-			;SEEK CYLINDER
		 RECAL,-		;RECALIBRATE
		 DRVCLR,-		;DRIVE CLEAR
		 RELEASE,-		;RELEASE PORT
		 OFFSET,-		;OFFSET HEADS
		 RETCENTER,-		;RETURN HEADS TO CENTERLINE
		 PACKACK,-		;PACK ACKNOWLEDGE
		 SEARCH,-		;SEARCH FOR SECTOR
		 READPRESET,-		;READ IN PRESET
		 DIAGNOSE,-		;DIAGNOSE DRIVE
		 SENSECHAR,-		;SENSE CHARACTERISTICS
		 SETCHAR,-		;SET CHARACTERISTICS
		 SENSEMODE,-		;SENSE MODE
		 SETMODE,-		;SET MODE
		 AVAILABLE,-		;AVAILABLE
		 ACCESS,-		;ACCESS FILE AND/OR FIND DIRECTORY ENTRY
		 ACPCONTROL,-		;ACP CONTROL FUNCTION
		 CREATE,-		;CREATE FILE AND/OR CREATE DIRECTORY ENTRY
		 DEACCESS,-		;DEACCESS FILE
		 DELETE,-		;DELETE FILE AND/OR DIRECTORY ENTRY
		 MODIFY,-		;MODIFY FILE ATTRIBUTES
		 MOUNT>			;MOUNT VOLUME
	FUNCTAB	+ACP$READBLK,-		;READ FUNCTIONS
		<READTRACKD,-		;READ TRACK DESCRIPTOR
		 READHEAD,-		;READ HEADER
		 READLBLK,-		;READ LOGICAL BLOCK
		 READPBLK,-		;READ PHYSICAL BLOCK
		 READVBLK>		;READ VIRTUAL BLOCK
	FUNCTAB	+ACP$WRITEBLK,-		;WRITE FUNCTIONS
		<WRITETRACKD,-		;WRITE TRACK DESCRIPTOR
		 WRITECHECK,-		;WRITE CHECK
		 WRITECHECKH,-		;WRITE CHECK HEADER AND DATA
		 WRITEHEAD,-		;WRITE HEADER
		 WRITELBLK,-		;WRITE LOGICAL BLOCK
		 WRITEPBLK,-		;WRITE PHYSICAL BLOCK
		 WRITEVBLK>		;WRITE VIRTUAL BLOCK
	FUNCTAB	+ACP$ACCESS,<ACCESS,CREATE> ;ACCESS AND CREATE FILE OR DIRECTORY
	FUNCTAB	+ACP$DEACCESS,<DEACCESS> ;DEACCESS FILE
	FUNCTAB	+ACP$MODIFY,-		;
		<ACPCONTROL,-		;ACP CONTROL FUNCTION
		 DELETE,-		;DELETE FILE OR DIRECTORY ENTRY
		 MODIFY>		;MODIFY FILE ATTRIBUTES
	FUNCTAB	+ACP$MOUNT,<MOUNT>	;MOUNT VOLUME
	FUNCTAB	+EXE$ZEROPARM,-		;ZERO PARAMETER FUNCTIONS
		<NOP,-			;NO OPERATION
		 UNLOAD,-		;UNLOAD VOLUME
		 RECAL,-		;RECALIBRATE
		 DRVCLR,-		;DRIVE CLEAR
		 RELEASE,-		;RELEASE PORT
		 RETCENTER,-		;RETURN HEADS TO CENTERLINE
		 READPRESET,-		;READ IN PRESET
		 PACKACK,-		;PACK ACKNOWLEDGE
		 AVAILABLE>		;AVAILABLE
	FUNCTAB	+EXE$ONEPARM,-		;ONE PARAMETER FUNCTIONS
		<SEEK,-			;SEEK CYLINDER
		 OFFSET,-		;OFFSET HEADS
		 SEARCH,-		;SEARCH FOR SECTOR
		 DIAGNOSE>		;DIAGNOSE THE DRIVE
	FUNCTAB	+EXE$SENSEMODE,-	;
		<SENSECHAR,-		;SENSE CHARACTERISTICS
		 SENSEMODE>		;SENSE MODE
	FUNCTAB	+EXE$SETCHAR,-		;
		<SETCHAR,-		;SET CHARACTERISTICS
		 SETMODE>		;SET MODE
	.PAGE
	.SBTTL	START I/O OPERATION
;+
; DR_STARTIO - START I/O OPERATION ON DEVICE UNIT
;
; THIS ENTRY POINT IS ENTERED TO START AN I/O OPERATION ON A DEVICE UNIT.
;
; INPUTS:
;
;	R3 = ADDRESS OF I/O PACKET.
;	R5 = UCB ADDRESS OF DEVICE UNIT.
;
; OUTPUTS:
;
;	FUNCTION DEPENDENT PARAMETERS ARE STORED IN THE DEVICE UCB, THE ERROR
;	RETRY COUNT IS RESET, AND THE FUNCTION IS EXECUTED. AT FUNCTION COMPLETION
;	THE OPERATION IS TERMINATED THROUGH REQUEST COMPLETE.
;-
 
DR_STARTIO:				;START I/O OPERATION
	MOVB	UCB$B_ERTMAX(R5),UCB$B_ERTCNT(R5) ;INITIALIZE ERROR RETRY COUNT
	MOVW	IRP$W_FUNC(R3),UCB$W_FUNC(R5) ;SAVE FUNCTION CODE AND MODIFIERS
	CLRW	UCB$W_DR_MR(R5)		;CLEAR THE MAINTENANCE VALUE
	BICW	#^CDR_M_DUALPORT, -	;Clear software status and error log
		UCB$B_DR_SSTS(R5) 	;bytes, except for dualport bit.
	MOVL	IRP$L_MEDIA(R3),R0	;GET PARAMETER LONGWORD
 
;
; MOVE FUNCTION DEPENDENT PARAMETERS TO UCB
;
 
10$:	EXTZV	#IRP$V_FCODE,#IRP$S_FCODE,- ;EXTRACT I/O FUNCTION CODE
		IRP$W_FUNC(R3),R1	;
	CMPB	#IO$_SEEK,R1 		;SEEK FUNCTION?
	BEQL	20$			;IF EQL YES
	CMPB	#IO$_OFFSET,R1 		;OFFSET FUNCTION?
	BEQL	30$			;IF EQL YES
	CMPB	#IO$_SEARCH,R1		;SEARCH FUNCTION?
	BEQL	40$			;IF EQL YES
	CMPB	#IO$_DIAGNOSE,R1	;DIAGNOSE FUNCTION?
	BEQL	45$			;IF EQL YES
	MOVL	R0,UCB$W_DA(R5)		;STORE PARAMETER LONGWORD
	CMPB	#IO$_WRITECHECKH,R1	;DISJOINT FUNCTION CODE?
	BGTRU	50$			;IF GTRU NO
	SUBW	#IO$_WRITECHECKH-IO$_AVAILABLE-1,R1 ;MAKE FUNCTION TABLE INDEX
	BRB	50$			;
 
;
; SEEK FUNCTION - SET CYLINDER ADDRESS
;
 
20$:	MOVW	R0,UCB$W_DC(R5)		;SET CYLINDER ADDRESS
	BRB	50$			;
 
;
; OFFSET FUNCTION - SET CURRENT OFFSET VALUE
;
 
30$:	MOVB	R0,UCB$W_OFFSET(R5)	;SET OFFSET VALUE
	BRB	50$			;
 
;
; SEARCH FUNCTION - SET SECTOR ADDRESS
;
 
40$:	MOVB	R0,UCB$W_DA(R5)		;SET SECTOR ADDRESS
	BRB	50$			;

;
; DIAGNOSE FUNCTION - SET MAINTENANCE VALUE
;

45$:	MOVW	R0,UCB$W_DR_MR(R5)	;SET MAINTENANCE VALUE
	SUBW	#IO$_DIAGNOSE-IO$_READPRESET-1,R1 ;MAKE A FUNCTION TABLE INDEX
 
;
; FINISH PREPROCESSING
;
 
50$:	MOVB	R1,UCB$B_FEX(R5)	;SAVE FUNCTION DISPATCH INDEX
	MOVL	UCB$L_CRB(R5),R4	;GET ADDRESS OF CRB
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R4 ;GET FIRST CONTROLLER CSR ADDRESS
	BBSC	#UCB$V_ECC,UCB$W_DEVSTS(R5),FDISPATCH ;CLEAR ECC CORRECTION MADE
 
;
; CENTRAL FUNCTION DISPATCH
;
 
FDISPATCH:				;FUNCTION DISPATCH
	MOVL	UCB$L_IRP(R5),R3	;RETRIEVE ADDRESS OF I/O PACKET
	BBS	#IRP$V_PHYSIO,IRP$W_STS(R3),10$ ;IF SET, PHYSICAL I/O FUNCTION
	BBS	#UCB$V_VALID,UCB$W_STS(R5),10$ ;IF SET, VOLUME SOFTWARE VALID
	MOVZWL	#SS$_VOLINV,R0		;SET VOLUME INVALID STATUS
	BRW	RESETXFR		;
 
;
; UNIT IS SOFTWARE VALID OR FUNCTION IS PHYSICAL I/O
;
 
10$:	MOVZBL	UCB$B_FEX(R5),R0	;GET DISPATCH FUNCTION CODE
	MOVB	#RM_OF_M_FMT/256,UCB$W_OFFSET+1(R5) ;CLEAR ECI, HCI, AND SET FORMAT
	MOVB	#1,UCB$B_OFFRTC(R5)	;SET INITIAL OFFSET RETRY COUNT
	CLRB	UCB$B_OFFNDX(R5)	;CLEAR INITIAL OFFSET TABLE INDEX

; 
; CHECK FOR DIAGNOSTIC MODIFIERS
; 
	BBC	#IRP$V_PHYSIO,IRP$W_STS(R3),40$  ;IF CLEAR, NOT PHYSICAL I/O
	BBC	#IO$V_COMMOD,UCB$W_FUNC(R5),15$  ;IF CLEAR, NO COMMAND MODIFIER
	BISB	#RM_OF_M_CMO/256,UCB$W_OFFSET+1(R5)  ;SET COMMAND MODIFIER

15$:	BBC	#IO$V_MOVETRACKD,UCB$W_FUNC(R5),20$  ;IF CLR, NO MOVE TRACK DESC
	BISB	#RM_OF_M_MTD/256,UCB$W_OFFSET+1(R5)  ;SET MOVE TRACK DESCRIPTOR

20$:	BBC	#IO$V_DIAGNOSTIC,UCB$W_FUNC(R5),30$  ;IF CLEAR, NOT DIAG MODE
	BISB	#RM_MR_M_DM/256,UCB$W_DR_MR+1(R5)  ;SET DIAGNOSTIC MODE

30$:	BBC	#IO$V_SKPSECINH,UCB$W_FUNC(R5),40$  ;IF CLEAR, NO SSEI MODIFIER
	BISB	#RM_OF_M_SSEI/256,UCB$W_OFFSET+1(R5)  ;SET SKIP SECTOR ERR INH

; 
; DISPATCH TO FUNCTION HANDLING ROUTINE
; 
40$:
	CASE	R0,<-			;DISPATCH TO FUNCTION HANDLING ROUTINE
		NOP,-			;NO OPERATION
		UNLOAD,-		;UNLOAD VOLUME
		SEEK,-			;SEEK CYLINDER
		RECAL,-			;RECALIBRATE
		DRVCLR,-		;DRIVE CLEAR
		RELEASE,-		;RELEASE PORT
		OFFSET,-		;OFFSET HEADS
		RETCENTER,-		;RETURN HEADS TO CENTER
		PACKACK,-		;PACK ACKNOWLEDGE
		SEARCH,-		;SEARCH FOR SECTOR
		WRITECHECK,-		;WRITE CHECK DATA
		WRITEDATA,-		;WRITE DATA
		READDATA,-		;READ DATA
		WRITEHEAD,-		;WRITE HEADER AND DATA
		READHEAD,-		;READ HEADER AND DATA
		WRITETRACKD,-		;WRITE TRACK DESCRIPTOR
		READTRACKD,-		;READ TRACK DESCRIPTOR
		AVAILABLE,-		;AVAILABLE
		WRITECHECKH,-		;WRITE CHECK HEADER AND DATA
		READPRESET,-		;READIN PRESET
		DIAGNOSE>		;DIAGNOSE DRIVE

; UNLOAD or AVAILABLE - Clear UCB$V_VALID
;   This is the only operation which these functions need to perform.  All
;   devices supported by this driver do not have an unload function, and the
;   available function code should only clear the UCB$V_VALID bit.

UNLOAD:
AVAILABLE:
	BICW	#UCB$M_VALID, UCB$W_STS(R5) ;Clear the software volume valid 
	BRW	NORMAL			    ;bit and complete function.

;
; PACKACK - Set UCB$V_VALID and proceed with hardware pack acknowledge
;	    function
;
PACKACK:
	BISW	#UCB$M_VALID, UCB$W_STS(R5) ;Set the software volume valid
;	BRB	NOP			    ;bit and complete function.

;
; NO OPERATION, SEEK, RECALIBRATE, DRIVE CLEAR, RELEASE, OFFSET,
; RETURN TO CENTER LINE, SEARCH, AND READ IN PRESET
;
 
NOP:					;NO OPERATION
SEEK:					;SEEK CYLINDER
RECAL:					;RECALIBRATE
DRVCLR:					;DRIVE CLEAR
RELEASE:				;RELEASE PORT
OFFSET:					;OFFSET READ HEADS
RETCENTER:				;RETURN TO CENTERLINE
SEARCH:					;SEARCH FOR SECTOR
READPRESET:				;READIN PRESET
	EXFUNC	RETRY			;EXECUTE HOUSEKEEPING FUNCTION
	BRW	NORMAL			;
 
;
; WRITE TRACK DESCRIPTOR and READ TRACK DESCRIPTOR
;	Both want to SEEK rather than to SEARCH to arrive on cylinder.
;
 
WRITETRACKD:				;WRITE TRACK DESCRIPTOR
	BISB	#DR_M_NOECC, UCB$B_DR_SSTS(R5) ; Signal don't correct with ECC.

READTRACKD:				;READ TRACK DESCRIPTOR
	BBS	#IO$V_INHSEEK,-
		UCB$W_FUNC(R5),TRANRQCH ; If set, NO explicit SEEK
	EXFUNC	RETRY,F_SEEK		; Seek to cylinder
	BRB	TRANRQCH		;  and branch around to common code.

;
; WRITE CHECK DATA AND WRITE CHECK HEADER AND DATA
;
 
WRITECHECK:				;WRITE CHECK DATA
WRITECHECKH:				;WRITE CHECK HEADER AND DATA
	BBSC	#IO$V_DATACHECK,UCB$W_FUNC(R5),WRITEDATA ;CLEAR DATA CHECK REQUEST
 
;
; WRITE DATA, WRITE HEADER AND DATA,
; WRITE CHECK DATA, AND WRITE CHECK HEADER AND DATA
;
 
WRITEDATA:				;WRITE DATA
WRITEHEAD:				;WRITE HEADER AND DATA
	BISB	#DR_M_NOECC, UCB$B_DR_SSTS(R5) ; Signal don't correct with ECC.
 
;
; READ DATA, READ HEADER AND DATA, 
; WRITE DATA, WRITE HEADER AND DATA,
; WRITE CHECK DATA, AND WRITE CHECK HEADER AND DATA
;
 
READDATA:				;READ DATA
READHEAD:				;READ HEADER AND DATA
	BBS	#IO$V_INHSEEK,UCB$W_FUNC(R5),TRANRQCH ;IF SET, NO EXPLICIT SEEK
	EXFUNC	RETRY,F_SEARCHA		;SEARCH AHEAD OF STARTING SECTOR

;
; DATA TRANSFER OR DIAGNOSE - REQUEST CHANNEL
;
 
DIAGNOSE:				;DIAGNOSE 
TRANRQCH:				;DATA TRANSFER
	REQPCHAN LOW			;REQUEST PRIMARY CHANNEL
 
;
; DATA TRANSFER - CHANNEL ALREADY OWNED
;
 
TRANNOCH:				;DATA TRANSFER CHANNEL OWNED
	MOVZBL	UCB$B_FEX(R5),R0	;GET FUNCTION DISPATCH INDEX
	EXFUNC	TRANXT			;EXECUTE TRANSFER FUNCTION
 
;
; DATA CHECK
;
 
DATACHECK:				;DATA CHECK
	BBC	#IO$V_DATACHECK,UCB$W_FUNC(R5),NORMAL ;IF CLR, NO DATA CHECK
	MOVZWL	#SS$_WASECC,R0		;ASSUME ECC CORRECTION WAS MADE
	BBS	#UCB$V_ECC,UCB$W_DEVSTS(R5),CHECKXT ;IF SET, ECC CORRECTION MADE
	RELCHAN				;RELEASE CHANNEL
	BISB	#DR_M_DCK,UCB$B_DR_SSTS(R5)  ;SET DATA CHECK IN PROGRESS
	MOVB	#RM_OF_M_FMT/256,UCB$W_OFFSET+1(R5) ;CLEAR ECI, HCI, AND SET FORMAT
	BISB	#DR_M_NOECC, UCB$B_DR_SSTS(R5) ; Signal don't correct with ECC.
	MOVB	#1,UCB$B_OFFRTC(R5)	;SET INITIAL OFFSET RETRY COUNT
	CLRB	UCB$B_OFFNDX(R5)	;CLEAR INITIAL OFFSET TABLE INDEX
	MOVL	UCB$L_IRP(R5),R2	;GET ADDRESS OF IRP
	MOVQ	IRP$L_SVAPTE(R2),UCB$L_SVAPTE(R5) ;RESET TRANSFER PARAMETERS
	MOVL	IRP$L_MEDIA(R2),UCB$W_DA(R5) ;
	BBC	#IRP$V_PHYSIO,IRP$W_STS(R2),CHECKRETRY  ;IF CLEAR NOT PHYS I/O
	BBC	#IO$V_SKPSECINH,UCB$W_FUNC(R5),CHECKRETRY  ;IF CLEAR NO SSEI MOD
	BISB	#RM_OF_M_SSEI/256,UCB$W_OFFSET+1(R5)  ;SET SKIP SECTOR ERR INH
 
;
; DATA CHECK RETRY
;
 
CHECKRETRY:				;DATA CHECK RETRY
	REQPCHAN LOW			;REQUEST PRIMARY CHANNEL FOR DATA CHECK
	MOVZBL	UCB$B_FEX(R5),R0	;GET FUNCTION DISPATCH INDEX
	MOVZBL	CHECKTAB-CDF_WRITEDATA[R0],R0 ;GET CASE TABLE INDEX
	EXFUNC	TRANXT			;EXECUTE DATA CHECK FUNCTION
 
;
; SUCCESSFUL OPERATION COMPLETION
;
 
NORMAL:					;
	MOVZWL	#SS$_NORMAL,R0		;SET NORMAL COMPLETION STATUS
CHECKXT:				;
	BRW	FUNCXT			;
 
;
; TRANSFER ENDED WITH A RETRIABLE ERROR
;
 
TRANXT:					;TRANSFER EXIT
	CMPB	#CDF_WRITEDATA,UCB$B_CEX(R5) ;WRITE DATA FUNCTION?
	BEQL	RETRY			;IF EQL YES
	CMPB	#CDF_WRITEHEAD,UCB$B_CEX(R5) ;WRITE HEADER FUNCTION?
	BEQL	RETRY			;IF EQL YES
	BITL	#MBA$M_SR_DLT!-		;DATA LATE OR,
		MBA$M_SR_INVMAP!-	;INVALID MAP REGISTER OR,
		MBA$M_SR_MAPPE!-	;MAP REGISTER PARITY ERROR OR,
		MBA$M_SR_MCPE!-		;MASSBUS CONTROL PARITY ERROR OR,
		MBA$M_SR_SPE!-		;MBA SILO PARITY ERROR OR,
		MBA$M_SR_MDPE!-		;MASSBUS DATA PARITY ERROR OR,
		MBA$M_SR_MXF!-		;MISSED TRANSFER OR,
		MBA$M_SR_NED!-		;NONEXISTENT DISK OR,
		MBA$M_SR_RDS!-		;READ DATA SUBSTITUTE OR,
		MBA$M_SR_WCKLWR!-	;WRITE CHECK LOWER BYTE OR,
		MBA$M_SR_WCKUPR,R1	;WRITE CHECK UPPER BYTE?
	BNEQ	RETRY			;IF NEQ YES - RETRY FUNCTION
	BITW	#RM_ER2_M_DPE!-		;DATA PARITY ERROR OR,
		RM_ER2_M_DVC!-		;DEVICE CHECK OR,
		RM_ER2_M_LBC!-		;LOSS OF BIT CLOCK OR,
		RM_ER2_M_LSC!-		;LOSS OF SYSTEM CLOCK OR,
		RM_ER2_M_IVC,UCB$W_DR_ER2(R5) ;INVALID COMMAND?
	BNEQ	RETRY			;IF NEQ YES - RETRY FUNCTION
	BBS	#RM_ER1_V_HCRC,R2,ECC	;Test HCRC before HCE.
	BITW	#RM_ER1_M_OPI!-		;OPERATION INCOMPLETE OR,
		RM_ER1_M_PAR!-		;PARITY ERROR OR,
		RM_ER1_M_HCE!-		;HEADER COMPARE ERROR OR,
		RM_ER1_M_WCF,R2		;WRITE CLOCK FAIL?
	BEQL	ECC			;IF EQL NO
RETRY:					;
	BRW	RETRYERR		;RETRIABLE ERROR
 
;
; ECC, DRIVE TIMING, OR HEADER ERROR - APPLY ECC OR PERFORM OFFSET RECOVERY
;
 
ECC:					;ECC CORRECTION
	MOVZWL	UCB$L_DR_BCR(R5),R0	;GET NEGATIVE NUMBER OF BYTES REMAINING
	ADDW	UCB$W_BCNT(R5),R0	;CALCULATE NUMBER OF BYTES TRANSFERED
	MOVL	R0,R1			;COPY NUMBER OF BYTES TRANSFERED
	BEQL	OFF			;IF EQL NONE - PERFORM OFFSET RECOVERY
	BBS	#RM_ER1_V_HCRC,R2,10$	;IF SET, HEADER CRC ERROR
	DECL	R0			;SET TO TRUNCATE LAST BLOCK TRANSFERED
10$:	BICW	#^X1FF,R0		;TRUNCATE RESIDUAL BYTES TRANSFERED
	BITW	#RM_ER1_M_DTE!-		;DRIVE TIMING ERROR OR,
		RM_ER1_M_ECH!-		;ECC HARD ERROR OR,
		RM_ER1_M_HCRC,R2	;HEADER CRC ERROR?
	BNEQ	OFF			;IF NEQ YES - PERFORM OFFSET RECOVERY
	BBS	#DR_V_NOECC, -		;If it won't help, 
		UCB$B_DR_SSTS(R5), OFF	;skip ECC correction.
	PUSHL	R1			;SAVE TOTAL NUMBER OF BYTES TRANSFERED
	JSB	G^IOC$APPLYECC		;APPLY ECC CORRECTION
	POPL	R0			;RETRIEVE TRANSFERED BYTE COUNT
	JSB	G^IOC$UPDATRANSP	;UPDATE TRANSFER PARAMETERS
	TSTW	UCB$W_BCNT(R5)		;ANY MORE TO TRANSFER?
	BEQL	20$			;IF EQL NO
	BRW	TRANNOCH		;TRANSFER NEXT SEGMENT
20$:	BRW	DATACHECK		;CHECK FOR WRITE CHECK
 
;
; OFF - OFFSET RECOVERY
;
; THIS CODE IS EXECUTED WHEN A DRIVE TIMING ERROR, HEADER CRC, OR ECC
; HARD ERROR IS DETECTED ON A READ FUNCTION.
;
 
OFF:					;OFFSET RECOVERY
	TSTL	R0			;ANY GOOD DATA TRANSFERED?
	BEQL	20$			;IF EQL NO
 
;
; THE TRANSFER ENDED IN AN ERROR BUT THERE WERE SECTORS TRANSFERED THAT
; CONTAINED GOOD DATA. SINCE THE ERROR COULD HAVE BEEN CAUSED BY A CYLIN-
; DER CROSSING, THE GOOD DATA IS SAVED AND THE TRANSFER IS RETRIED FROM THE
; POINT OF ERROR.
;
 
	JSB	G^IOC$UPDATRANSP	;UPDATE TRANSFER PARAMETERS
	CLRB	UCB$B_OFFNDX(R5)	;RESET OFFSET TABLE INDEX
10$:	MOVB	#16,UCB$B_OFFRTC(R5)	;SET OFFSET RETRY COUNT
	CMPB	#OFFSIZ,UCB$B_OFFNDX(R5) ;ALL OFFSETS TRIED?
	BEQL	80$			;IF EQL YES
	RELCHAN				;RELEASE CHANNEL
	BICB	#DR_M_OM,UCB$B_DR_SSTS(R5)  ;CLEAR OFFSET MODE
	BRB	50$			;

;
; NO GOOD DATA TRANSFERED - CHECK IF CHANGE IN OFFSET NEEDED
;
 
20$:	BITW	#RM_ER1_M_DCK!-		;DATA CHECK OR,
		RM_ER1_M_DTE!-		;DRIVE TIMING OR,
		RM_ER1_M_ECH,R2		;ECC HARD ERROR?
	BNEQ	30$			;IF NEQ YES
	BISB	#RM_OF_M_HCI/256,UCB$W_OFFSET+1(R5) ;SET HEADER COMPARE INHIBIT
30$:	DECB	UCB$B_OFFRTC(R5)	;CHANGE CURRENT OFFSET?
	BNEQ	60$			;IF NEQ NO
	INCB	UCB$B_OFFNDX(R5)	;UPDATE OFFSET TABLE INDEX
	MOVZBL	UCB$B_OFFNDX(R5),R0	;GET NEXT OFFSET TABLE INDEX
	MOVB	OFFTAB-1[R0],UCB$W_OFFSET(R5) ;GET NEXT OFFSET VALUE
	BEQL	10$			;IF EQL RETURN TO CENTERLINE
	MOVB	#2,UCB$B_OFFRTC(R5)	;SET OFFSET RETRY COUNT
	RELCHAN				;RELEASE CHANNEL
	BISB	#DR_M_OM,UCB$B_DR_SSTS(R5)  ;SET OFFSET MODE
50$:	BICB	#RM_OF_M_HCI/256,UCB$W_OFFSET+1(R5) ;CLEAR HEADER COMPARE INHIBIT
60$:	BBS	#DR_V_DCK,UCB$B_DR_SSTS(R5),70$	;IF SET, DATA CHECK FUNCTION
	BRW	TRANRQCH		;TRY FUNCTION AGAIN
70$:	BRW	CHECKRETRY		;TRY DATA CHECK AGAIN
 
80$:	MOVL	RM_DS(R3),R0		;GET DRIVE STATUS
	MOVL	UCB$L_DR_SR(R5),R1	;GET MBA STATUS
	BRB	FATALERR		;

;
; RETRIABLE ERROR
;
 
RETRYERR:				;RETRIABLE ERROR
	PUSHR	#^M<R0,R1,R2>		; Save error status registers.
	RELCHAN				; Release channel before possible RECAL
	POPR	#^M<R0,R1,R2>		; Restore error status registers.
	BBS	#RM_ER2_V_SKI,UCB$W_DR_ER2(R5),10$ ;IF SET, SEEK INCOMPLETE
	BBC	#RM_ER1_V_HCE,R2,20$	;IF CLR, HEADER COMPARED
10$:	EXFUNC	FATALERR,F_RECAL	;RECALIBRATE HEADS
	MOVZWL	#RM_ER1_M_OPI,R2	;SET AN ERROR FOR CALLER TO SEE
20$:	DECB	UCB$B_ERTCNT(R5)	;ANY RETRIES LEFT?
	BEQL	FATALERR		;IF EQL NO
	BRW	FDISPATCH		;
 
;
; FATAL CONTROLLER/DRIVE ERROR, ERROR RETRY COUNT EXHAUSTED, ERROR RETRY
; INHIBITED, OR FINAL OFFSET TRIED
;
 
FATALERR:				;FATAL ERROR - SET STATUS
	BBC	#RM_DS_V_MOL,R0,10$	;IF CLR, MEDIUM OFFLINE
	BBC	#RM_DS_V_VV,R0,20$	;IF CLR, VOLUME INVALID
	MOVZWL	#SS$_UNSAFE,R0		;SET DRIVE UNSAFE STATUS
	BBS	#RM_ER1_V_UNS,R2,FUNCXT	;IF SET, DRIVE UNSAFE
	MOVZWL	#SS$_OPINCOMPL,R0	;SET OPERATION INCOMPLETE STATUS
	BBS	#RM_ER1_V_OPI,R2,FUNCXT	;IF SET, OPERATION INCOMPLETE
	MOVZWL	#SS$_WRITLCK,R0		;SET WRITE LOCK ERROR STATUS
	BBS	#RM_ER1_V_WLE,R2,FUNCXT	;IF SET, WRITE LOCK ERROR
	MOVZWL	#SS$_IVADDR,R0		;SET INVALID DISK ADDRESS STATUS
	BITW	#RM_ER1_M_AOE!-		;DISK ADDRESS OVERFLOW OR,
		RM_ER1_M_IAE,R2		;INVALID DISK ADDRESS ERROR?
	BNEQ	FUNCXT			;IF NEQ YES
	MOVZWL	#SS$_DRVERR,R0		;SET DRIVE ERROR STATUS
	BITW	#RM_ER1_M_DTE!-		;DRIVE TIMING ERROR OR,
		RM_ER1_M_ILF!-		;ILLEGAL FUNCTION OR,
		RM_ER1_M_ILR!-		;ILLEGAL REGISTER OR,
		RM_ER1_M_RMR!-		;REGISTER MODIFY REFUSE OR,
		RM_ER1_M_WCF,R2		;WRITE CLOCK FAIL ERROR?
	BNEQ	FUNCXT			;IF NEQ YES
	MOVZWL	#SS$_PARITY,R0		;SET PARITY ERROR STATUS
	BITW	#RM_ER1_M_DCK!-		;DATA CHECK ERROR OR,
		RM_ER1_M_ECH!-		;ECC HARD ERROR OR,
		RM_ER1_M_HCE!-		;HEADER COMPARE ERROR OR,
		RM_ER1_M_HCRC!-		;HEADER CRC ERROR OR,
		RM_ER1_M_PAR,R2		;PARITY ERROR?
	BNEQ	FUNCXT			;IF NEQ YES
	BBS	#RM_ER2_V_BSE,UCB$W_DR_ER2(R5),FUNCXT ;IF SET, BAD SECTOR ERROR
	BITL	#MBA$M_SR_MAPPE!-	;MAP PARITY ERROR OR,
		MBA$M_SR_MCPE!-		;MASSBUS CONTROL PARITY ERROR OR,
		MBA$M_SR_SPE!-		;MBA SILO PARITY ERROR OR,
		MBA$M_SR_MDPE!-		;MASSBUS DATA PARITY ERROR OR,
		MBA$M_SR_RDS,R1		;READ DATA SUBSTITUTE?
	BNEQ	FUNCXT			;IF NEQ YES
	MOVZWL	#SS$_FORMAT,R0		;SET FORMAT ERROR STATUS
	BBS	#RM_ER1_V_FER,R2,FUNCXT	;IF SET, FORMAT ERROR
	MOVZWL	#SS$_DATACHECK,R0	;SET DATA CHECK ERROR STATUS
	BITW	#MBA$M_SR_WCKLWR!-	;WRITE CHECK ERROR LOWER BYTE OR,
		MBA$M_SR_WCKUPR,R1	;WRITE CHECK ERROR UPPER BYTE?
	BNEQ	FUNCXT			;IF NEQ YES
	MOVZWL	#SS$_NONEXDRV,R0	;SET NONEXISTENT DRIVE STATUS
	BBS	#MBA$V_SR_NED,R1,FUNCXT	;IF SET, NONEXISTENT DRIVE
	MOVZWL	#SS$_CTRLERR,R0		;SET CONTROLLER ERROR STATUS
	BRB	FUNCXT			;
10$:	MOVZWL	#SS$_MEDOFL,R0		;SET MEDIUM OFFLINE STATUS
	BRB	FUNCXT			;
20$:	MOVZWL	#SS$_VOLINV,R0		;SET VOLUME INVALID STATUS
 
;
; FUNCTION COMPLETION COMMON EXIT
;
 
FUNCXT:					;FUNCTION EXIT
	PUSHL	R0			;SAVE FINAL REQUEST STATUS
	JSB	G^IOC$DIAGBUFILL		;FILL DIAGNOSTIC BUFFER IF PRESENT
	RELCHAN				;RELEASE CHANNEL IF OWNED
	CMPB	#CDF_WRITECHECK,UCB$B_FEX(R5) ;DRIVE RELATED FUNCTION?
	BGTRU	10$			;IF GTRU YES
	CMPB	#CDF_READPRESET,UCB$B_FEX(R5) ;DRIVE RELATED FUNCTION?
	BLEQU	10$			;IF LEQU YES
	CMPB	#CDF_AVAILABLE,UCB$B_FEX(R5) ;DRIVE RELATED FUNCTION?
	BEQL	10$			;IF EQL YES
	MOVL	UCB$L_IRP(R5),R2	;RETRIEVE ADDRESS OF IRP
	ADDW3	UCB$L_DR_BCR(R5),-
		IRP$W_BCNT(R2),2(SP)	; Calculate bytes transfered
10$:	CLRL	R1			;CLEAR SECOND STATUS LONGWORD
	POPL	R0			;RETRIEVE FINAL REQUEST STATUS
	MOVZBL	UCB$B_SLAVE+1(R5),R3	;GET DRIVE OFFSET CONSTANT
	MOVAL	MBA$L_ERB(R4)[R3],R3	;GET ADDRESS OF DRIVE REGISTERS
	MOVZBL	#F_RELEASE!1,RM_CS1(R3)	;RELEASE PORT
	REQCOM				;COMPLETE REQUEST
	.PAGE
	.SBTTL	HARDWARE FUNCTION EXECUTION
;
; FEX - HARDWARE FUNCTION EXECUTION
;
; THIS ROUTINE IS CALLED VIA A BSB WITH A BYTE IMMEDIATELY FOLLOWING THAT
; SPECIFIES THE ADDRESS OF AN ERROR ROUTINE. ALL DATA IS ASSUMED TO HAVE BEEN
; SET UP IN THE UCB BEFORE THE CALL. THE APPROPRIATE PARAMETERS ARE LOADED
; INTO DEVICE REGISTERS AND THE FUNCTION IS INITIATED. IF THE FUNCTION IS AN
; IMMEDIATE FUNCTION CONTROL RETURNS IMMEDIATELY. ELSE THE RETURN ADDRESS
; IS STORED IN THE UCB AND A WAITFOR INTERRUPT IS EXECUTED. WHEN THE INTER-
; RUPT OCCURS, CONTROL IS RETURNED TO THE CALLER.
;
; INPUTS:
;
;	R0 = FUNCTION TABLE DISPATCH INDEX.
;	R3 = ADDRESS OF DRIVE CONTROL STATUS REGISTER 1.
;	R4 = ADDRESS OF MBA CONFIGURATION STATUS REGISTER.
;	R5 = DEVICE UNIT UCB ADDRESS.
;
;	00(SP) = RETURN ADDRESS OF CALLER.
;	04(SP) = RETURN ADDRESS OF CALLER'S CALLER.
;
;	IMMEDIATELY FOLLOWING INLINE AT THE CALL SITE IS A BYTE WHICH CONTAINS
;	A BRANCH DESTINATION TO AN ERROR RETRY ROUTINE.
;
; OUTPUTS:
;
;	THERE ARE FOUR EXITS FROM THIS ROUTINE:
;
;	1. SPECIAL CONDITION - THIS EXIT IS TAKEN IF A POWER FAILURE OCCURS
;		OR THE OPERATION TIMES OUT. IT IS A JUMP TO THE APPROPRIATE
;		ERROR ROUTINE.
;
;	2. FATAL ERROR - THIS EXIT IS TAKEN IF A FATAL CONTROLLER OR DRIVE
;		ERROR OCCURS OR IF ANY ERROR OCCURS AND ERROR RETRY IS
;		INHIBITED. IT IS A JUMP TO THE FATAL ERROR EXIT ROUTINE.
;
;	3. RETRIABLE ERROR - THIS EXIT IS TAKEN IF A RETRIABLE CONTROLLER
;		OR DRIVE ERROR OCCURS AND ERROR RETRY IS NOT INHIBITED.
;		IT CONSISTS OF TAKING THE ERROR BRANCH EXIT.
;
;	4. SUCCESSFUL OPERATION - THIS EXIT IS TAKEN IF NO ERROR OCCURS
;		DURING THE OPERATION. IT CONSISTS OF A RETURN INLINE.
;
;	IN ALL CASES IF AN ERROR OCCURS, AN ATTEMPT IS MADE TO LOG THE ERROR.
;
;	IN ALL CASES FINAL DRIVE AND CONTROLLER REGISTERS ARE RETURNED VIA
;	THE GENERAL REGISTERS R0, R1, AND R2, AND THE UCB.
;
;	R0 = DRIVE STATUS REGISTER.
;	R1 = MBA STATUS REGISTER.
;	R2 = DRIVE ERROR REGISTER 1.
;
;	UCB$W_EC1(R5) = ECC POSITION REGISTER.
;	UCB$W_EC2(R5) = ECC PATTERN REGISTER.
;	UCB$W_BCR(R5) = BYTE COUNT REGISTER.
;	UCB$W_DR_ER2(R5) = DRIVE ERROR REGISTER 2.
;
 
FEX:					;FUNCTION EXECUTOR
	POPL	UCB$L_DPC(R5)		;SAVE DRIVER PC VALUE
	MOVB	R0,UCB$B_CEX(R5)	;SAVE CASE INDEX
	MOVZBL	UCB$B_SLAVE+1(R5),R3	;GET DRIVE OFFSET CONSTANT
	MOVAL	MBA$L_ERB(R4)[R3],R3	;GET ADDRESS OF DRIVE REGISTERS
	BITL	#DEV$M_DUA,UCB$L_DEVCHAR(R5) ;DUAL PORTED DRIVE?
	BNEQ	SEIZE			;IF NEQ, YES
GO:	MOVZBL	UCB$B_CEX(R5),R0	;Restore case index (func. code)
	CASE	R0,<-			;DISPATCH TO PROPER FUNCTION ROUTINE
		POSIT,-			;SEEK CYLINDER
		EXFNC,-			;RECALIBRATE
		IMMED,-			;DRIVE CLEAR
		IMMED,-			;RELEASE DRIVE
		IMMED,-			;OFFSET HEADS
		EXFNC,-			;RETURN TO CENTERLINE
		IMMED,-			;PACK ACKNOWLEDGE
		POSIT,-			;SEARCH FOR SECTOR
		XFER,-			;WRITE CHECK
		XFER,-			;WRITE DATA
		XFER,-			;READ DATA
		XFER,-			;WRITE HEADER AND DATA
		XFER,-			;READ HEADER AND DATA
		XFER,-			;WRITE TRACK DESCRIPTOR
		XFER,-			;READ TRACK DESCRIPTOR
		IMMED,-			;AVAILABLE
		XFER,-			;WRITE CHECK HEADER AND DATA
		IMMED,-			;READIN PRESET
		EXFNC,-			;DIAGNOSE
		SEARCHA,-		;SEARCH AHEAD
		>,LIMIT=#CDF_SEEK	;
 
;
; IMMEDIATE FUNCTION EXECUTION
;
;	FUNCTIONS INCLUDE:
;
;		NO OPERATION,
;		DRIVE CLEAR,
;		RELEASE PORT,
;		OFFSET,
;		READ IN PRESET, AND
;		PACK ACKNOWLEDGE.
;
; Two other functions which might (but hopefully don't) pass through this code 
; are UNLOAD and AVAILABLE.  If such functions get here they are treated as 
; NOPs.
;
; THESE FUNCTIONS ARE EXECUTED IMMEDIATELY AND THE FINAL DEVICE REGISTERS
; ARE RETURNED TO THE CALLER.
;
 
IMMED:					;IMMEDIATE FUNCTION EXECUTION
	DSBINT				;DISABLE INTERRUPTS
	BBS	#UCB$V_POWER,UCB$W_STS(R5),10$ ;IF SET, POWER HAS FAILED
	MOVZBL	#F_DRVCLR!1,RM_CS1(R3)	;CLEAR DRIVE ERRORS
	MOVZBL	FTAB[R0],RM_CS1(R3)	;EXECUTE FUNCTION
10$:	BRW	ENBXIT			;

;
; ATTEMPT TO SEIZE THE PORT ON A DUAL PORTED DISK.
;

SEIZE:	BBC	#DR_V_DUALPORT, -	; IF CLEAR, DUALPORT KIT
		UCB$B_DR_SSTS(R5),GO	;IS NOT PRESENT
	DSBINT				;DISABLE INTERRUPTS
	CLRL	RM_DS(R3)		;ATTEMPT TO SEIZE PORT
	BITL	#RM_DS_M_DPR,-		;DID WE SEIZE THE PORT?
		RM_DS(R3)
	BNEQ	4$			;IF NEQ, WE SEIZED THE PORT
	WFIKPCH RETREG,#15		;LETS WAIT FOR THE PORT, ELSE TIMEOUT
	IOFORK				;CREATE FORK PROCESS
	BRB	GO			;CONTINUE WE HAVE THE PORT
4$:	ENBINT				;ENABLE INTERRUPTS
	BRB	GO			;LET'S CONTINUE, WE HAVE THE PORT

;
; SEARCH AHEAD FUNCTION EXECUTION
;
; THIS FUNCTION MINIMIZES ROTATIONAL LATENCY BY SEARCHING FOR THE SECTOR THAT IS
; FOUR SECTORS AHEAD OF THE STARTING SECTOR OF A TRANSFER.
;
; THE DESIRED CYLINDER, TRACK, AND SECTOR ADDRESS REGISTERS ARE LOADED, THE
; FUNCTION IS INITIATED, AND A WAITFOR INTERRUPT IS EXECUTED. WHEN THE INTER-
; RUPT OCCURS, THE FINAL DEVICE REGISTERS ARE RETURNED TO THE CALLER.
;

SEARCHA:				;
	MOVZWL	UCB$W_DA(R5),R1		;GET DESIRED TRACK AND SECTOR ADDRESS
	SUBB	#4,R1			;COMPUTE FOUR SECTORS BEFORE IT
	BGEQ	10$			;IF GEQ BEFORE SECTOR ZERO
	ADDB	UCB$B_SECTORS(R5),R1 	;CONVERT TO AFTER SECTOR ZERO
10$:	MOVL	R1,RM_DA(R3)		;SET TRACK AND SECTOR ADDRESS
	BRB	LDCYL			;
 
;
; TRANSFER FUNCTION EXECUTION
;
;	FUNCTIONS INCLUDE:
;
;		WRITE TRACK DESCRIPTOR,
;		WRITE CHECK,
;		WRITE CHECK HEADER AND DATA,
;		WRITE DATA,
;		WRITE HEADER AND DATA,
;		READ TRACK DESCRIPTOR,
;		READ DATA, AND
;		READ HEADER AND DATA.
;
; THE MAP REGISTERS, BYTE COUNT REGISTER, AND VIRTUAL ADDRESS REGISTER ARE
; LOADED FOLLOWED BY THE DESIRED CYLINDER, TRACK, AND SECTOR ADDRESS REGISTERS.
; THE FUNCTION IS INITIATED AND A WAITFOR INTERRUPT IS EXECUTED. WHEN THE
; INTERRUPT OCCURS, THE FINAL DEVICE REGISTERS ARE RETURNED TO THE CALLER.
;
; IT ASSUMED THAT THE CALLER OWNS THE CHANNEL ON WHICH THE I/O IS TO OCCUR.
;
 
XFER:					;TRANSFER FUNCTION EXECUTION
	MCOML	#0,MBA$L_SR(R4)		;CLEAR MASSBUS ADAPTER ERRORS
	LOADMBA				;LOAD MAP, BYTE COUNT, AND VIRTUAL ADDRESS
	MOVZBL	UCB$B_CEX(R5),R0	;RETRIEVE FUNCTION TABLE INDEX
 
;
; POSITIONING FUNCTION EXECUTION
;
;	FUNCTIONS INCLUDE:
;
;		SEEK CYLINDER, AND
;		SEARCH FOR SECTOR.
;
; THE DESIRED CYLINDER, TRACK, AND SECTOR ADDRESS REGISTERS ARE LOADED, THE
; FUNCTION IS INITIATED, AND A WAITFOR INTERRUPT IS EXECUTED. WHEN THE INTER-
; RUPT OCCURS, THE FINAL DEVICE REGISTERS ARE RETURNED TO THE CALLER.
;
 
POSIT:					;POSITION FUNCTION EXECUTION
	MOVZWL	UCB$W_DA(R5),RM_DA(R3)	;SET DESIRED TRACK AND SECTOR ADDRESS
LDCYL:					;
	MOVZWL	UCB$W_DC(R5),RM_DC(R3)	;SET DESIRED CYLINDER ADDRESS
 
;
; INTERRUPT WAIT FUNCTION EXECUTION
;
;	FUNCTIONS INCLUDE:
;
;		DIAGNOSE,
;		RECALIBRATE, AND
;		RETURN TO CENTERLINE.
;
; THE OFFSET REGISTER IS LOADED, THE FUNCTION IS INITIATED, AND A WAITFOR
; INTERRUPT IS EXECUTED. WHEN THE INTERRUPT OCCURS, THE FINAL DEVICE REGISTERS
; ARE RETURNED TO THE CALLER.
;
 
EXFNC:					;EXECUTE FUNCTION
	MOVZBL	#F_DRVCLR!1,RM_CS1(R3)	;CLEAR DRIVE ERRORS
	BBC	#DR_V_OM,UCB$B_DR_SSTS(R5),10$  ;IF CLR, NO OFFSET ACTIVE
	MOVZBL	#F_OFFSET!1,RM_CS1(R3)	;SET DRIVE IN OFFSET MODE
10$:	DSBINT				;DISABLE INTERRUPTS
	BBS	#UCB$V_POWER,UCB$W_STS(R5),ENBXIT ;IF SET, POWER FAILED
	MOVZWL	UCB$W_DR_MR(R5),RM_MR(R3)	;SET DIAGNOSTIC INFO
	MOVZWL	UCB$W_OFFSET(R5),RM_OF(R3) ;SET FORMAT, INHIBIT BITS, AND OFFSET
	BBC	#RM_OF_V_SSEI,-		; If Skip Sector Error Inhibit is clear
		UCB$W_OFFSET(R5),12$	;  branch around.
	BBS	#IO$V_SKPSECINH,-	; If reason for SSEI is EXPLICIT user
		UCB$W_FUNC(R5),12$	;  request, then branch around.
	BICB	#RM_OF_M_SSEI/256,-	; If here, SSEI set due to error on
		UCB$W_OFFSET+1(R5)	;  this track. Hence clear SSEI in
	DECB	UCB$W_DA(R5)		;  software only and decrement sector
					;  bias in software also.
12$:
	ASHL	#31-RM_DS_V_MOL,RM_DS(R3),R2 ;MEDIUM ONLINE?
	BGEQ	15$			;IF GEQ NO
	MOVZBL	FTAB[R0],RM_CS1(R3)	;INITIATE FUNCTION
	WFIKPCH	RETREG,#6		;WAITFOR INTERRUPT AND KEEP CHANNEL
	MOVL	MBA$L_SR(R4),UCB$L_DR_SR(R5) ;SAVE FINAL CONTROLLER STATUS
	IOFORK				;CREATE FORK PROCESS
	BRB	RETREG			;
 
;
; MEDIUM OFFLINE AT START OF FUNCTION
;
 
15$:	ENBINT				;ENABLE INTERRUPTS
	CLRB	UCB$B_CEX(R5)		;FORCE DRIVE FUNCTION
	MOVZWL	#RM_DS_M_ERR,R0		;SET DRIVE ERROR
	CLRL	UCB$L_DR_SR(R5)		;CLEAR SAVED MBA STATUS REGISTER
	INCB	UCB$B_DR_ERL(R5)	;SET MEDIUM OFFLINE FOR ERROR LOG
	BRB	ERROR			;
 
;
; ENABLE INTERRUPTS
;
 
ENBXIT:					;
	ENBINT				;ENABLE INTERRUPTS
 
;
; RETURN REGISTERS
;
 
RETREG:					;RETURN FINAL DEVICE REGISTERS
	CVTLW	RM_ER2(R3),UCB$W_DR_ER2(R5) ;SAVE ERROR REGISTER 2
	CVTLW	RM_EC1(R3),UCB$W_EC1(R5) ;SAVE ECC POSITION REGISTER
	CVTLW	RM_EC2(R3),UCB$W_EC2(R5) ;SAVE ECC PATTERN REGISTER
; Here we save the more conservative of the two byte counts contained in
;	the MBA$L_BCR register.  The high word of this register is the
;	(negative of the) number of bytes transferred to or from the
;	drive, while the low word is the (negative of the) number of
;	bytes transferred to or memory.  On a read, the more conservative
;	value is that of the number of bytes transferred to memory (low word)
;	while on a write the more conservative value is the number of
;	bytes transferred to the drive (high word).  Here we deposit
;	the entire register into a longword in the UCB.  If the operation
;	was a read we leave the value as is.  However if the operation
;	was a write (or anything but a read) we move the high word to
;	the low word in memory.  All other pieces of this driver use the
;	low word of this longword as the valid byte count.

	MOVL	MBA$L_BCR(R4),-		; Save entire byte count register
		UCB$L_DR_BCR(R5)	;  in the UCB.
	MOVL	UCB$L_IRP(R5),R0	; Retrieve IRP pointer.
	BBS	#IRP$V_FUNC,-		; If we had a read operation then
		IRP$W_STS(R0),5$	;  just branch around since all OK.
	MOVW	UCB$L_DR_BCR+2(R5),-	; If NOT read, then copy high word to
		UCB$L_DR_BCR(R5)	;  low order word for later use.
5$:
	CVTLW	RM_OF(R3),UCB$W_DR_OFR(R5)  ;SAVE OFFSET REGISTER
	MOVL	RM_DS(R3),R0		;GET CONTENTS OF DRIVE STATUS REGISTER
ERROR:					;
	MOVL	UCB$L_DR_SR(R5),R1	;RETRIEVE FINAL CONTROLLER STATUS
	MOVL	RM_ER1(R3),R2		;GET CONTENTS OF DRIVE ERROR REGISTER 1
	BITW	#UCB$M_POWER!-		;POWER FAIL OR DEVICE TIMEOUT?
		UCB$M_TIMOUT,UCB$W_STS(R5) ;
	BEQL	10$			;IF EQL - NO
	BRW	SPECOND			;BRANCH TO SPECIAL CONDITION
10$:	CMPB	#CDF_SEARCHA, UCB$B_CEX(R5) ;Search Ahead?
	BEQL	SAFUNC			;Branch to special search-ahead code.
	CMPB	#CDF_WRITECHECK,UCB$B_CEX(R5)  ;DRIVE RELATED FUNCTION?
	BGTRU	20$			;IF GTRU - YES
	CMPB	#CDF_READPRESET,UCB$B_CEX(R5) ;DRIVE RELATED FUNCTION?
	BGTRU	30$			;IF GTRU - NO
20$:	BRW	DFUNC			;DRIVE FUNCTION

; 
; CHECK FOR RM80 SKIP SECTOR ERROR 
; 

30$:	CMPB	#DT$_RM80,UCB$B_DEVTYPE(R5)  ;RM80?
	BNEQ	CFUNC			;IF NEQ - NO
	BBC	#RM_ER2_V_SSE,-		; If clear, No Skip Sectoring error,
		UCB$W_DR_ER2(R5),CFUNC	;  so branch around.
	BITW	#RM_ER1_M_HCE!RM_ER1_M_HCRC,R2  ;HEADER COMPARE OR HDR CRC ERR?
	BNEQ	CFUNC			;IF NEQ - YES
	BISB	#RM_OF_M_SSEI/256,UCB$W_OFFSET+1(R5)  ;SET SKIP SECTOR INHIBIT
	PUSHL	R0			;SAVE R0 (DRIVE STATUS REGISTER)
	MOVZWL	UCB$L_DR_BCR(R5),R0	; Get negative bytes remaining
	BNEQ	40$			;IF NEQ - PARTIAL TRANSFER
	MOVW	#-1,R0			;FAKE A PARTIAL TRANSFER
40$:	ADDW	UCB$W_BCNT(R5),R0	;CALCULATE BYTES TRANSFERRED
	BICW	#^X1FF,R0		;TRUNCATE TO LAST BLOCK TRANSFERRED
	JSB	G^IOC$UPDATRANSP	;UPDATE TRANSFER PARAMETERS
	INCB	UCB$W_DA(R5)		;INCREMENT TO NEXT SECTOR
	POPL	R0			;RESTORE R0 (DRIVE STATUS REGISTER)
	BBS	#DR_V_DCK,UCB$B_DR_SSTS(R5),45$  ;IF SET - DATACHECK IN PROGRESS
	BRW	TRANNOCH		;RESTART TRANSFER
45$:	RELCHAN				;RELEASE CHANNEL
	BRW	CHECKRETRY		;RESTART DATA CHECK
					;NO SSE - CHECK FOR TRACK-TRACK SSEI CLR
	.ENABL	LSB

;
; SEARCH AHEAD ERROR CHECKING
;

SAFUNC:
	BBC	#RM_ER2_V_SKI, -	;The only error worth checking on
		UCB$W_DR_ER2(R5), 30$	;seach-ahead is seek incomplete.
	JSB	G^ERL$DEVICERR		;SKI errors, however, must be logged
	BRB	25$			;and retried.

;
; CONTROLLER RELATED FUNCTION
;

CFUNC:
	BITL	#MBA$M_ERROR,R1		;ANY CONTROLLER ERRORS?
	BEQL	30$			;IF EQL NO
	JSB	G^ERL$DEVICERR		;ALLOCATE AND FILL ERROR MESSAGE BUFFER
	BBS	#IO$V_INHRETRY,UCB$W_FUNC(R5),40$ ;IF SET, RETRY INHIBITED
	BITL	#MBA$M_SR_ERCONF!-	;ERROR CONFIRMATION OR,
		MBA$M_SR_ISTO!-		;INTERFACE SEQUENCE TIMEOUT OR,
		MBA$M_SR_PGE!-		;PROGRAMMING ERROR OR,
		MBA$M_SR_RDTO,R1	;READ TIMEOUT?
	BNEQ	40$			;IF NEQ YES - FATAL CONTROLLER ERROR
	BITL	#MBA$M_SR_DLT!-		;DATA LATE OR,
		MBA$M_SR_INVMAP!-	;INVALID MAP REGISTER OR,
		MBA$M_SR_MAPPE!-	;MAP REGISTER PARITY ERROR OR,
		MBA$M_SR_MBEXC!-	;MASSBUS EXCEPTION OR,
		MBA$M_SR_MCPE!-		;MASSBUS CONTROL PARITY ERROR OR,
		MBA$M_SR_SPE!-		;MBA SILO PARITY ERROR OR,
		MBA$M_SR_MDPE!-		;MASSBUS DATA PARITY ERROR OR,
		MBA$M_SR_MXF!-		;MISSED TRANSFER OR,
		MBA$M_SR_NED!-		;NONEXISTENT DRIVE OR,
		MBA$M_SR_RDS!-		;READ DATA SUBSTITUTE OR,
		MBA$M_SR_WCKLWR!-	;WRITE CHECK LOWER BYTE OR,
		MBA$M_SR_WCKUPR,R1	;WRITE CHECK UPPER BYTE?
	BNEQ	20$			;IF NEQ YES - RETRIABLE CONTROLLER ERROR
 
;
; DRIVE RELATED FUNCTION
;
 
DFUNC:
10$:	BBC	#RM_DS_V_ERR,R0,30$	;IF CLR, NO DRIVE ERRORS
	MNEGW	UCB$W_BCNT(R5),-
		UCB$L_DR_BCR(R5)	; Reset byte count - NO TRANSFER
	BLBS	UCB$B_DR_ERL(R5),40$	; Don't log error if Medium offline at
					;  start of function.
	JSB	G^ERL$DEVICERR		;ALLOCATE AND FILL ERROR MESSAGE BUFFER
	BBS	#IO$V_INHRETRY,UCB$W_FUNC(R5),40$ ;IF SET, RETRY INHIBITED
20$:	BBC	#RM_DS_V_MOL,R0,40$	;IF CLR, MEDIUM OFFLINE
	BBC	#RM_DS_V_VV,R0,40$	;IF CLR, INVALID VOLUME
	BITW	#RM_ER1_M_HCRC!-	; Check HCRC and HCE before checking
		RM_ER1_M_HCE,R2		;  BSE and FER.
	BNEQ	25$			; NEQ means HCRC or HCE is set.
	BITW	#RM_ER1_M_AOE!-		;ADDRESS OVERFLOW OR,
		RM_ER1_M_FER!-		;FORMAT ERROR OR,
		RM_ER1_M_IAE!-		;INVALID ADDRESS OR,
		RM_ER1_M_ILF!-		;ILLEGAL FUNCTION OR,
		RM_ER1_M_ILR!-		;ILLEGAL REGISTER OR,
		RM_ER1_M_RMR!-		;REGISTER MODIFY REFUSE OR,
		RM_ER1_M_UNS!-		;DRIVE UNSAFE OR,
		RM_ER1_M_WLE,R2		;WRITE LOCK ERROR?
	BNEQ	40$			;IF NEQ YES - FATAL DRIVE ERROR
	BITW	#RM_ER2_M_BSE!-		;BAD SECTOR ERROR OR,
		RM_ER2_M_OPE,UCB$W_DR_ER2(R5) ;OPERATOR PLUG ERROR?
	BNEQ	40$			;IF NEQ YES - FATAL DRIVE ERROR
 
;
; RETRIABLE ERROR EXIT
;
 
25$:
	CVTWL	@UCB$L_DPC(R5),-(SP)	;GET BRANCH DISPLACEMENT
	ADDL	(SP)+,UCB$L_DPC(R5)	;CALCULATE RETURN ADDRESS - 2
30$:	ADDL	#2,UCB$L_DPC(R5)	;SKIP PAST BRANCH DISPLACEMENT WORD
	JMP	@UCB$L_DPC(R5)		;RETURN TO DRIVER
 
;
; FATAL CONTROLLER OR DRIVE ERROR EXIT
;
 
40$:	BRW	FATALERR		;

;
; SPECIAL CONDITION (POWER FAILURE OR DEVICE TIME OUT)
;
 
SPECOND:
50$:	BBSC	#UCB$V_POWER,UCB$W_STS(R5),70$ ;IF SET, POWER FAILURE
 
;
; DEVICE TIME OUT
;
 
	JSB	G^ERL$DEVICTMO		;LOG DEVICE TIME OUT
	MOVL	UCB$L_CRB(R5),R3	;GET ADDRESS OF CRB
	MOVL	CRB$L_INTD+VEC$L_IDB(R3),R3 ;GET ADDRESS OF IDB
	CMPL	R5,IDB$L_OWNER(R3)	;DEVICE OWN CONTROLLER?
	BNEQ	60$			;IF NEQ NO
	DSBINT				;DISABLE INTERRUPTS
	MOVL	#MBA$M_CR_ABORT!MBA$M_CR_IE,- ;ABORT THE DATA TRANSFER
		MBA$L_CR(R4)		;
	WFIKPCH	55$,#15			;WAIT FOR ABORT AND KEEP CHANNEL
	IOFORK				;CREATE FORK PROCESS
55$:
	MOVL	#MBA$M_CR_INIT,MBA$L_CR(R4) ;INITIALIZE ENTIRE MBA
	MOVL	#MBA$M_CR_IE,MBA$L_CR(R4) ;ENABLE DEVICE INTERRUPTS
60$:	SETIPL	UCB$B_FIPL(R5)		;LOWER TO FORK LEVEL
	MOVZWL	#SS$_TIMEOUT,R0		;SET DEVICE TIMEOUT STATUS
	DECB	UCB$B_ERTCNT(R5)	;ANY ERROR RETRIES REMAINING?
	BEQL	RESETXFR		;IF EQL NO
	RELCHAN				;RELEASE CHANNEL IF OWNED
	BICW	#UCB$M_TIMOUT,UCB$W_STS(R5) ;CLEAR TIME OUT STATUS
	BRW	FDISPATCH		;
 
;
; RESET TRANSFER BYTE COUNT TO ZERO
;
 
RESETXFR:				;
	MOVL	UCB$L_IRP(R5),R3	;RETRIEVE ADDRESS OF I/O PACKET
	MNEGW	IRP$W_BCNT(R3),-
		UCB$L_DR_BCR(R5)	; Reset transfer byte count
	BRW	FUNCXT			;
 
;
; POWER FAILURE
;
 
70$:	RELCHAN				;RELEASE CHANNEL
	MOVL	UCB$L_IRP(R5),R3	;RETRIEVE ADDRESS OF I/O PACKET
	MOVQ	IRP$L_SVAPTE(R3),UCB$L_SVAPTE(R5) ;RESTORE TRANSFER PARAMETERS
	BRW	DR_STARTIO			;
	.DSABL	LSB

	.PAGE
	.SBTTL	REGISTER DUMP ROUTINE
;
; DR_REGDUMP - REGISTER DUMP ROUTINE
;
; THIS ROUTINE IS CALLED TO SAVE THE CONTROLLER AND DRIVE REGISTERS IN A
; SPECIFIED BUFFER. IT IS CALLED FROM THE DEVICE ERROR LOGGING ROUTINE AND
; FROM THE DIAGNOSTIC BUFFER FILL ROUTINE.
;
; INPUTS:
;
;	R0 = ADDRESS OF REGISTER SAVE BUFFER.
;	R4 = ADDRESS OF ADAPTER CONFIGURATION REGISTER.
;	R5 = DEVICE UNIT UCB ADDRESS.
;
; OUTPUTS:
;
;	THE CONTROLLER AND DRIVE REGISTERS ARE SAVED IN THE SPECIFIED BUFFER.
;
 
DR_REGDUMP:				;REGISTER DUMP ROUTINE
	MOVL	#<RM_EC2+4+MBA$L_BCR+4+8+4>/4,(R0)+ ;INSERT NUMBER OF DEVICE REGS
	MOVL	MBA$L_CSR(R4),(R0)+	;SAVE CONFIGURATION REGISTER
	MOVL	MBA$L_CR(R4),(R0)+	;SAVE CONTROL REGISTER
	MOVL	UCB$L_DR_SR(R5),(R0)+	;SAVE STATUS REGISTER
	MOVL	MBA$L_VAR(R4),(R0)+	;SAVE VIRTUAL ADDRESS REGISTER
	MOVL	MBA$L_BCR(R4),(R0)+	;SAVE BYTE COUNT REGISTER
	EXTZV	#9,#8,-8(R0),R1		;GET FINAL MAP REGISTER NUMBER
	MOVL	MBA$L_MAP(R4)[R1],(R0)+	;SAVE FINAL MAP REGISTER CONTENTS
	CLRL	(R0)+			;ASSUME NO PREVIOUS MAP REGISTER
	DECL	R1			;CALCULATE PREVIOUS MAP REGISTER NUMBER
	BLSS	10$			;IF LSS NONE
	MOVL	MBA$L_MAP(R4)[R1],-4(R0) ;SAVE PREVIOUS MAP REGISTER CONTENTS
10$:	MOVZBL	#<RM_EC2+4>/4,R1	;SET NUMBER OF DRIVE REGISTERS TO SAVE
	MOVZBL	UCB$B_SLAVE+1(R5),R2	;GET DRIVE OFFSET CONSTANT
	MOVAL	MBA$L_ERB(R4)[R2],R2	;GET ADDRESS OF DRIVE REGISTERS
20$:	MOVL	(R2)+,(R0)+		;SAVE DRIVE REGISTER
	SOBGTR	R1,20$			;ANY MORE TO SAVE?
	MOVZBL	UCB$B_DR_ERL(R5),(R0)+	;SAVE MEDIUM OFFLINE INDICATOR
	RSB				;
 
	.PAGE
	.SBTTL	DISK DRIVE INITIALIZATION
;
; DR_UNIT_INIT - DISK DRIVE UNIT INITIALIZATION
;
; THIS ROUTINE IS CALLED AT SYSTEM INITIALIZATION AND AT POWER RECOVERY TO SET
; DRIVE PARAMETERS AND TO WAIT FOR ONLINE DRIVES TO SPIN UP.
;
; INPUTS:
;
;	R4 = ADDRESS OF MBA CONFIGURATION STATUS REGISTER.
;	R5 = DEVICE UNIT UCB ADDRESS.
;
; OUTPUTS:
;
;	UNIT PARAMETERS ARE ESTABLISHED AND THE DRIVE IS SPUN UP IF IT WAS ONLINE.
;
; SPECIAL NOTES:
;	This routine performs several special operations to support power 
;	failure recovery in the RP07.  To provide an understanding of these 
;	operations, power failure recovery within in the RP07 is discussed 
;	first.  Then, the special actions taken by this routine are discussed.
;
;	The power up sequence in a RP07 drive is best described in terms of a 
;	series of numbered states.  The state numbers are shown in the LED 
;	readout on the micro-processor control pannel, the section labeled 
;	"PROGRAM CODE."  The following lists these states and gives the 
;	author's understanding what they mean.
;
;	STATE		COMMENTS
;	00,11,22,...,FF	These states occur upon restoration of DC power.  
;			Presumably they are related to micro-processor 
;			initialization and testing.  During these states, 
;			no MASSBUS interaction with the drive is possible.
;
;	00,01,02	These states occur after the above states during power 
;			failure recovery or after the START/STOP switch is 
;			moved from the STOP to the START position.  These 
;			states also are related to micro-processor and disk 
;			system testing.  The disk system is not spinning 
;			during these states.  During these states, no 
;			MASSBUS interaction with the drive is possible.
;
;	03		During power failure recovery, this is the state in 
;			which multiple RP07 drives on a single system will 
;			synchronize their attempts to spin their disk media.  
;			Limited communication with the drive via the MASSBUS 
;			is enabled while the drive is in this state.  The 
;			drive type register can be read, and the clear-drive 
;			command is accepted.  The drive status register also 
;			can be read while the drive is in this state.  For 
;			between 20 and 40 milliseconds after this state is 
;			entered, however, the drive status register contains 
;			garbage -- probably all bits except ATA and ERR set, 
;			a remnant of some internal test.  After this initial 
;			period, the drive status register contains reasonable, 
;			valid information.
;
;	04,05,06,07,08	These states occur while the disk medium is spining 
;			upto speed.  While in these states, no MASSBUS 
;			interaction with the drive is possible.
;
;	The following aspects of this routine relate specificially to dealing 
;	with power failure recovery as practiced by the RP07.
;
;	    o	The sieze port operation, performed near the beginning of this 
;		routine, also has the effect of waiting for the RP07 drive to 
;		reach state 03.  To allow both wait operations -- the sieze 
;		port function and the wait for RP07 to reach state 03 function 
;		-- to be combined, EXE$PWRTIMCHK is used to time both 
;		functions.  When this routine is called for reasons other than 
;		power failure recovery, it establishes a 20 millisecond wait 
;		interval for EXE$PWRTIMCHK.
;
;	    o	Once access to the RP07 has been established, this routine 
;		proceeds to determine the drive type, that register can be 
;		read and contains valid.
;
;	    o	Before proceeding to test for medium-online, however, this 
;		routine waits for 50 milliseconds.  This is intended to allow 
;		the drive status register to reach a valid state.
;
;	    o	The medium-online test will wait for the drive to spin up.  
;		Because all drive registers show zero while MASSBUS access to 
;		the drive is disabled, it will correctly wait throughout 
;		states 03, 04, 05, 06, 07, and 08.
;

DR_UNIT_INIT:				;DISK DRIVE UNIT INITIALIZATION
	MOVZWL	UCB$W_UNIT(R5),R3	;GET DRIVE UNIT NUMBER
	MOVB	R3,UCB$B_SLAVE(R5)	;SET SLAVE UNIT NUMBER
	MULL	#<1@7>/4,R3		;CALCULATE DRIVE OFFSET CONSTANT
	MOVB	R3,UCB$B_SLAVE+1(R5)	;SET SLAVE OFFSET CONSTANT
	MOVAL	MBA$L_ERB(R4)[R3],R3	;GET ADDRESS OF DRIVE CONTROL REGISTER
	MOVL	G^EXE$GL_PWRDONE, -(SP)	;Save current powerfail limit time.
	BNEQ	105$			;Non-zero value indicates powerfail.
	MFPR	#PR$_TODR, -(SP)	;If not powerfail, construct our
	ADDL3	#2, (SP)+, G^EXE$GL_PWRDONE ;limit time for port seizure.
105$:	CLRL	RM_DS(R3)		;Attempt to seize port.
110$:	ASHL	#31-RM_DS_V_DPR, RM_DS(R3), R2 ;Did we seize the port?
	BLSS	120$			;If LSS, we seized the port.
	JSB	G^EXE$PWRTIMCHK		;Wait for port to be siezed.
	BLBS	R0, 110$		;Branch if haven't waited long enough.
	BICW	#UCB$M_ONLINE, UCB$W_STS(R5) ;If never get the port,
	BRB	15$			;mark the drive offline and invalid.
120$:	ASHL	#31-RM_DT_V_DRQ, RM_DT(R3), R2 ;Is there a dualport kit?
	BGEQ	5$			;If GEQ, no dualport kit; continue.
	BISB	#DR_M_DUALPORT, -	;Else, set flag indicating that disk
		UCB$B_DR_SSTS(R5)	;has a dualport kit.
5$:	BISW	#UCB$M_ONLINE,UCB$W_STS(R5) ;SET UNIT ONLINE
	BSBW	DR_DTYPE		;CLASSIFY DRIVE TYPE
	BBC	#UCB$V_ONLINE,UCB$W_STS(R5),15$ ;IF CLR, UNKNOWN DRIVE TYPE
	BBC	#UCB$V_VALID,UCB$W_STS(R5),30$	;IF CLR, VOLUME SOFTWARE INVALID
	CMPB	#DT$_RP07, UCB$B_DEVTYPE(R5) ;Is this a RP07?
	BNEQ	10$			; Branch if not a RP07.
	.SHOW	MEB
	TIMEWAIT -			; If this is a RP07,
		time = #5000, -		; wait for it to finish its
		bitval = #0, -		; cup of coffee.
		source = #0, -
		context = B
	.NOSHOW	MEB
10$:	MOVZBL	#F_DRVCLR!1,RM_CS1(R3)	;CLEAR DRIVE
	ASHL	#31-RM_DS_V_MOL,RM_DS(R3),R2 ;MEDIUM ONLINE?
	BLSS	20$			;IF LSS YES
	JSB	G^EXE$PWRTIMCHK		;CHECK FOR MAXIMUM TIME EXCEEDED
	BLBS	R0,10$			;IF LBS MORE TIME TO GO
15$:	BICW	#UCB$M_VALID,UCB$W_STS(R5) ;MARK THE VOLUME INVALID
	BRB	30$
20$:	MOVZBL	#F_PACKACK!1,RM_CS1(R3)	;ACKNOWLEDGE PACK
30$:	MOVZBL	#F_RELEASE!1,RM_CS1(R3)	;CLEAR DRIVE
40$:	BISL	MBA$L_SR(R4), MBA$L_SR(R4) ;CLEAR MBA STATUS
	TSTL	(SP)+			;If powerfail limit time was zero
	BNEQ	50$			;when we started, make sure its
	CLRL	G^EXE$GL_PWRDONE	;zero when we leave.
50$:	RSB
	.PAGE
	.SBTTL	UNSOLICITED INTERRUPT ROUTINE
;
; DR_UNSOLNT - UNSOLICITED INTERRUPT ROUTINE
;
; THIS ROUTINE IS CALLED WHEN AN UNSOLICITED ATTENTION CONDITION IS DETECTED.
;
; INPUTS:
;
;	R4 = ADDRESS OF CONFIGURATION STATUS REGISTER.
;	R5 = DEVICE UNIT UCB ADDRESS.
;
; OUTPUTS:
;
;	IF VOLUME VALID IS CLEAR, THEN SOFTWARE VOLUME VALID IS CLEARED. THE
;	UNIT STATUS IS CHANGED TO ONLINE AND THE DRIVE TYPE AND PARAMETERS ARE
;	CLASSIFIED.
;
 
DR_UNSOLNT:				;UNSOLICITED INTERRUPT
	MOVZBL	UCB$B_SLAVE+1(R5),R3	;GET DRIVE OFFSET CONSTANT
	MOVAL	MBA$L_ERB(R4)[R3],R3	;GET ADDRESS OF DRIVE CONTROL REGISTER
	BISW	#UCB$M_ONLINE,UCB$W_STS(R5) ;SET UNIT ONLINE
	BSBW	DR_DTYPE		;CLASSIFY DRIVE TYPE
	BBC	#UCB$V_ONLINE,UCB$W_STS(R5),10$ ;IF CLR, UNKNOWN DRIVE TYPE
	BBC	#UCB$V_VALID,UCB$W_STS(R5),20$ ;IF CLR, VOLUME SOFTWARE INVALID
	ASHL	#31-RM_DS_V_MOL,RM_DS(R3),R2 ;MEDIUM ONLINE?
	BGEQ	10$			;IF GEQ NO
	BBC	#UCB$V_BSY,UCB$W_STS(R5),5$ ;We know the drive is online; thus,
	CMPB	#CDF_PACKACK,UCB$B_CEX(R5)  ;if busy doing a PACKACK function,
	BEQL	20$			    ;then don't clear software valid.
5$:	ASHL	#31-RM_DS_V_VV,RM_DS(R3),R2 ;VOLUME VALID?
	BLSS	20$			;IF LSS YES
10$:	BICW	#UCB$M_VALID,UCB$W_STS(R5) ;CLEAR SOFTWARE VOLUME VALID
20$:	RSB				;
	.PAGE
	.SBTTL	CLASSIFY DRIVE TYPE AND SET PARAMETERS
;
; RM_DTYPE - CLASSIFY DRIVE TYPE AND SET PARAMETERS
;
; THIS ROUTINE IS CALLED WHEN AN UNSOLICITED INTERRUPT OCCURS ON A DRIVE, DURING
; SYSTEM INITIALIZATION, AND AT POWER RECOVERY TO DETERMINE THE DRIVE TYPE AND
; SET UNIT PARAMETERS.
;
; INPUTS:
;
;	R3 = ADDRESS OF DRIVE CONTROL REGISTER.
;	R4 = ADDRESS OF MBA CONFIGURATION STATUS REGISTER.
;	R5 = DEVICE UNIT UCB ADDRESS.
;
; OUTPUTS:
;
;	THE DRIVE TYPE REGISTER IS INTERROGATED AND UNIT PARAMETERS ARE SET.
;
 
DR_DTYPE:				;CLASSIFY DRIVE TYPE AND SET PARAMETERS
	PUSHL	RM_DT(R3)		;READ DRIVE TYPE REGISTER
	BICW	#^C<^X1FF>,(SP)		;CLEAR EXTRANEOUS BITS
	MOVAB	DR_DTDESC,R2		;GET ADDRESS OF DESCRIPTOR TABLE
10$:	CMPW	(SP),(R2)+		;DRIVE TYPE MATCH?
	BEQL	20$			;IF EQL YES
	ADDL	#DR_DTDESCLEN-2,R2	;ADVANCE TO NEXT ENTRY
	TSTW	(R2)			;END OF TABLE?
	BNEQ	10$			;IF NEQ NO
	BICW	#UCB$M_ONLINE,UCB$W_STS(R5) ;SET UNIT OFFLINE
	SUBL	#DR_DTDESCLEN-2,R2	;BACK UP TO LAST DRIVE DESCRIPTOR
20$:	MOVB	(R2)+,UCB$B_DEVTYPE(R5)	;SET DEVICE TYPE
	MOVL	(R2)+,UCB$L_DEVDEPEND(R5) ;SET DISK PACK GEOMETRY
	MOVL	(R2),UCB$L_MAXBLOCK(R5) ;SET MAXIMUM BLOCKS PER PACK
	TSTL	(SP)+			;REMOVE DRIVE TYPE FROM STACK
	RSB				;
DR_END:					;ADDRESS OF LAST LOCATION IN DRIVER

	.END
