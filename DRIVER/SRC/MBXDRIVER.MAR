	.TITLE	MBXDRIVER - SHARED MEMORY MAILBOX DEVICE DRIVER
	.IDENT	'V03-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
; FACILITY:
;
;	VAX/VMS EXECUTIVE
;
; ABSTRACT:
;
;	THIS MODULE CONTAINS THE SHARED MEMORY MAILBOX DRIVER 
;	I/O ROUTINES.
;
; AUTHOR: LEN KAWELL 13-MAR-1979
;
; MODIFIED BY:
;
;	V02-008	KDM0074		Kathleen D. Morse	8-Jan-1982
;		Clear IDB pointer to UCB for shared memory mailbox,
;		when no more references to the UCB and it is going
;		to be deallocated.
;
;	V02-007	KDM0067		Kathleen D. Morse	10-Nov-1981
;		Fix stack and synchronization problems.
;
;	V02-006	STJ0026		Steven T. Jeffreys	05-Feb-1981
;		Modified FDTSET to default to IO$M_WRTATTN if no
;		function modifier is present.
;
;	V02-005	STJ0020		Steven T. Jeffreys	20-Jan-1981
;		Modified FDTSET routine to handle SETPROT function.
;
;
;--
;
; EXTERNAL SYMBOLS
;
	$ACBDEF				; DEFINE AST CONTROL BLOCK
	$CADEF				; DEFINE CONDITIONAL ASSEMBLY
	$CRBDEF				; DEFINE CHANNEL REQUEST BLOCK
	$CXBDEF				; DEFINE COMPLEX CHAINED BUFFERS
	$DDBDEF				; DEFINE DDB
	$DYNDEF				; DEFINE DYNAMIC BLOCK TYPES
	$FKBDEF				; DEFINE FORK BLOCK
	$IDBDEF				; DEFINE INTERRUPT DISPATCHER
	$IODEF				; DEFINE FUNCTION CODES
	$IRPDEF				; DEFINE I/O PACKET OFFSETS
	$IRPEDEF			; DEFINE I/O PACKET EXTENSION OFFSETS
	$IPLDEF				; DEFINE IPL NUMBERS
	$MBXDEF				; DEFINE MAILBOX
	$PCBDEF				; DEFINE PCB OFFSETS
	$PRDEF				; DEFINE PROCESSOR REGISTERS
	$PRIDEF				; DEFINE PRIORITY INCREMENTS
	$PRQDEF				; DEFINE INTER-PROCESSOR REQUESTS
	$RSNDEF				; DEFINE RESOURCE NUMBERS
	$SHBDEF				; DEFINE SHARED MEMORY CONTROL BLOCK
	$SHDDEF				; DEFINE SHARED MEMORY DATAPAGE
	$SSDEF				; DEFINE SYSTEM STATUS CODES
	$UCBDEF				; DEFINE UCB OFFSETS
	$VECDEF				; DEFINE INTERRUPT TRANSFER VECTOR

;
; LOCAL DEFINITIONS
;

;
; MACRO TO SET PORT FLAG CORRESPONDING TO THIS PROCESSOR
;
	.MACRO	SET_PORTFLAG MASK,?LABEL
	BBSSI	UCB$L_MB_PORT(R5),MASK,LABEL
LABEL:
	.ENDM	SET_PORTFLAG
;
; MACRO TO CLEAR PORT FLAG CORRESPONDING TO THIS PROCESSOR
;
	.MACRO	CLR_PORTFLAG MASK,?LABEL
	BBCCI	UCB$L_MB_PORT(R5),MASK,LABEL
LABEL:
	.ENDM	CLR_PORTFLAG


;
; DEVICE SPECIFIC I/O REQUEST PACKET EXTENSION DEFINITIONS
;
	$DEFINI	IRPE

. = FKB$K_LENGTH			; (BEGINNING IS FORK BLOCK)
$DEF	IRPE$W_MB_PORTS	.BLKW	1	; PORTS TO NOTIFY (1 BIT/PORT)
$DEF	IRPE$W_MB_RQTYP	.BLKW	1	; REQUEST TYPE CODE
$DEF	IRPE$L_MB_PARAM	.BLKL	1	; REQUEST PARAMETER
$DEF	IRPE$L_MB_PORT	.BLKL	1	; NEXT PORT TO NOTIFY

	$DEFEND	IRPE

;
; MAILBOX MESSAGE BUFFER DEFINITION
;
;	SINCE THE SHARED MEMORY POOL IS ONLY ALLOCATABLE IN FIXED
;	SIZE BLOCKS, A MESSAGE IS STORED AS A LIST OF CHAINED BLOCKS.
;
	$DEFINI	MSG
$DEF	MSG_Q_MSGLINK			; MESSAGE QUEUE LINK
$DEF	MSG_L_POSTIOBUF	.BLKL	1	;  I/O POST I/O BUFFER ADDRESS
$DEF	MSG_L_POSTUBUF	.BLKL	1	;  I/O POST USER BUFFER ADDRESS
$DEF	MSG_W_SIZE	.BLKW	1	; SIZE OF BLOCK
$DEF	MSG_B_TYPE	.BLKB	1	; TYPE OF BLOCK (DYN$C_SHRBUFIO)
$DEF	MSG_B_PORT	.BLKB	1	; PORT NUMBER OF MESSAGE WRITER
$DEF	MSG_W_LENGTH	.BLKW	1	; LENGTH OF MESSAGE IN BLOCK
$DEF	MSG_W_MSGLENGTH	.BLKW	1	; TOTAL LENGTH OF MESSAGE DATA
$DEF	MSG_L_CHAINLINK	.BLKL	1	; LINK TO NEXT CHAINED BLOCK
$DEF	MSG_L_IRPSEQ	.BLKL	1	; IRP SEQUENCE NUMBER OF MESSAGE WRITER
$DEF	MSG_L_PID	.BLKL	1	; PID OF MESSAGE WRITER
$DEF	MSG_B_MESSAGE			; START OF MESSAGE IN BLOCK
	$DEFEND	MSG
;
;	SINCE THE MESSAGE IS PASSED DIRECTLY TO I/O POST, IT MUST
;	CONFORM TO THE DEFINITION FOR A COMPLEX CHAINED BUFFER
;
	ASSUME	MSG_L_POSTIOBUF EQ 0
	ASSUME	MSG_L_POSTUBUF	EQ 4
	ASSUME	MSG_W_LENGTH EQ CXB$W_LENGTH
	ASSUME 	MSG_L_CHAINLINK EQ CXB$L_LINK

;
; INTER-PROCESSOR REQUEST TYPE CODES
;
PRQ_READ	= 1			; MESSAGE WAS READ
PRQ_WRITE	= 2			; MESSAGE WAS WRITTEN
PRQ_READER	= 3			; READER IS WAITING

;
; FDT ROUTINE ARGUMENT LIST OFFSETS
;
P1		= 0			; BUFFER ADDRESS ARGUMENT
P2		= 4			; BUFFER SIZE ARGUMENT
P3		= 8			; PARAMETER 3
P4		= 12			; PARAMETER 4

;
; LOCAL DATA STORAGE
;

;
; DRIVER PROLOGUE TABLE
;
	DPTAB	-			; DRIVER PROLOGUE TABLE
		END=MB_END,-		; END OF DRIVER
		ADAPTER=MPM,-		; MULTI-PORT MEMORY ADAPTER
		UCBSIZE=UCB$K_MB_LENGTH,- ; SIZE OF UCB
		NAME=MBXDRIVER		; DRIVER NAME
	DPT_STORE INIT			;
		DPT_STORE UCB,UCB$B_FIPL,B,IPL$_MAILBOX
		DPT_STORE UCB,UCB$B_DIPL,B,IPL$_MAILBOX
		DPT_STORE UCB,UCB$L_OWNUIC,L,<^X010001>
		DPT_STORE UCB,UCB$L_DEVCHAR,L,-
			<DEV$M_REC!-
			DEV$M_AVL!-
			DEV$M_MBX!-
			DEV$M_IDV!-
			DEV$M_ODV!-
			DEV$M_SHR>
		DPT_STORE UCB,UCB$B_DEVCLASS,B,DC$_MAILBOX
		DPT_STORE UCB,UCB$W_DEVSTS,W,UCB$M_SHMMBX
	DPT_STORE REINIT		;
	DPT_STORE CRB,CRB$L_INTD+4,D,MBX$INT ;INTERRUPT SERVICE ROTINE ADDRESS
	DPT_STORE DDB,DDB$L_DDT,D,MBX$DDT ;DDT ADDRESS
	DPT_STORE END			; 

;
; DRIVER DISPATCH TABLE
;
	DDTAB	-			; DRIVER DISPATCH TABLE
		DEVNAM=MBX,-		;  DEVICE NAME
		START=STARTIO,-		;  START I/O OPERATION
		FUNCTB=FUNCTABLE,-	;  FUNCTION DECISION TABLE
		CANCEL=CANCELIO		;  CANCEL I/O OPERATION

;
; FUNCTION DECISION TABLE
;

FUNCTABLE:				; FUNCTION DECISION TABLE
	FUNCTAB	,<-			; LEGAL FUNCTIONS
		SETMODE,-		;  SET ATTENTION AST
		WRITEOF,-		;  WRITE END-OF-FILE
		READLBLK,WRITELBLK,-	;  READ/WRITE LOGICAL BLOCKS
		READVBLK,WRITEVBLK,-	;  READ/WRITE VIRTUAL BLOCKS
		READPBLK,WRITEPBLK>	;  READ/WRITE PHYSICAL BLOCKS
	FUNCTAB	,<-			; BUFFERED I/O FUNCTIONS
		READLBLK,WRITELBLK,-	;  READ/WRITE LOGICAL BLOCKS
		READVBLK,WRITEVBLK,-	;  READ/WRITE VIRTUAL BLOCKS
		READPBLK,WRITEPBLK>	;  READ/WRITE PHYSICAL BLOCKS
	FUNCTAB	FDTREAD,-		; READ FDT ACTION ROUTINE
		 <READLBLK,READPBLK,READVBLK>
	FUNCTAB	FDTWRITE,-		; WRITE FDT ACTION ROUTINE
		<WRITELBLK,WRITEPBLK,WRITEVBLK>
	FUNCTAB	FDTSET,<SETMODE>	; SET ATTENTION AST FDT ROUTINE
	FUNCTAB	FDTEOF,<WRITEOF>	; WRITE END-OF-FILE FDT ROUTINE

	.SBTTL	CANCELIO - CANCEL I/O ON MAILBOX UNIT
;++
; CANCELIO - CANCEL I/O ON MAILBOX UNIT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED TO CANCEL ALL OUTSTANDING I/O FOR A PARTICULAR
; PROCESS AND CHANNEL ON A MAILBOX UNIT.
;
;	o  IF THE UNIT IS BUSY, AND THE CURRENT READ PACKET BELONGS TO
;	   THE CANCELLING PROCESS, AND IS FROM THE CANCELLING CHANNEL,
;	   IT IS COMPLETED.
;
;	o  THE WRITE I/O QUEUE IS SCANNED.  IF A PACKET BELONGS TO THE
;	   CANCELLING PROCESS, AND IS FROM THE CANCELLING CHANNEL, IT IS
;	   COMPLETED.
;
;	o  THE READ AND WRITE ATTENTION AST LISTS ARE SCANNED.  IF
;	   AN AST BELONGS TO THE CANCELLING PROCESS AND IS FROM THE
;	   CANCELLING CHANNEL, IT IS REMOVED AND DEALLOCATED.
;
;	o  IF THE REFERENCE COUNT OF THE MAILBOX UCB IS ZERO AND MARKED FOR
;	   DELETE, THE PORT'S REFERENCE TO THE MAILBOX CONTROL BLOCK IS
;	   REMOVED.  IF THAT WAS THE ONLY REFERENCE LEFT, DEALLOCATE ALL THE
;	   REMAINING MESSAGE BLOCKS, AND DEALLOCATE THE MAILBOX CONTROL BLOCK.
;
; INPUTS:
;
;	R2 = NEGATIVE OF CHANNEL NUMBER
;	R3 = CURRENT PACKET ADDRESS
;	R4 = PCB OF CANCELLING PROCESS
;	R5 = UCB OF UNIT
;
;	IPL = IPL$_MAILBOX
;
; OUTPUTS:
;
;	R4,R5,R6,R7 ARE PRESERVED
;
;--
CANCELIO:				; CANCEL I/O ON MAILBOX UNIT
	BBS	#UCB$V_ONLINE,UCB$W_STS(R5),10$ ; IF ONLINE CONTINUE
	RSB
10$:
	PUSHR	#^M<R4,R5,R6,R7,R10,R11> ; SAVE REGISTERS
	MOVL	R2,R6			; COPY CHANNEL NUMBER
;
; CHECK CURRENT READ I/O REQUEST AND COMPLETE IF CANCELLED
;
	BBC	#UCB$V_BSY,UCB$W_STS(R5),20$ ; READ IN PROGRESS?
	CMPL	PCB$L_PID(R4),IRP$L_PID(R3) ; IS IT FROM CANCELLING PROCESS?
	BNEQ	20$			; IF NEQ THEN NO
	CMPW	R6,IRP$W_CHAN(R3)	; CHANNEL MATCH?
	BNEQ	20$			; IF NEQ THEN NO
	MOVQ	#SS$_ABORT,R0		; SET STATUS TO ABORT
	JSB	G^IOC$REQCOM		; COMPLETE THE REQUEST
;
; CHECK WRITE I/O REQUESTS AND COMPLETE IF CANCELLED
;
20$:	MOVAB	UCB$L_MB_WIOQFL(R5),R2	; GET ADDRESS OF WRITE I/O QUEUE
	MOVL	R2,R0			; COPY LIST HEAD ADDRESS
30$:	MOVL	(R2),R2			; GET ADDRESS OF LIST ENTRY
	CMPL	R0,R2			; END OF LIST?
	BEQL	40$			; IF YES THEN DONE
	CMPL	PCB$L_PID(R4),-		; REQUEST FROM CANCELLING PROCESS?
		IRP$L_PID(R2)		;
	BNEQ	30$			; IF NO THEN SEARCH MORE
	CMPW	R6,IRP$W_CHAN(R2)	; CHANNEL MATCH?
	BNEQ	30$			; IF NEQ THEN NO
	REMQUE	(R2),R3			; REMOVE PACKET FROM QUEUE
	MOVQ	#SS$_ABORT,IRP$L_IOST1(R3) ; SET STATUS TO ABORT
	JSB	G^COM$POST		; COMPLETE THE OPERATION
	BRB	20$			; SEARCH LIST FROM THE START
;
; CHECK ATTENTION AST REQUESTS AND DELETE IF CANCELLED
;
40$:	MOVAB	UCB$L_MB_WAST(R5),R7	; GET ADDRESS OF WRITE AST'S
	JSB	G^COM$FLUSHATTNS	; FLUSH ATTENTION AST'S
	MOVAB	UCB$L_MB_RAST(R5),R7	; GET ADDRESS OF READ AST'S
	JSB	G^COM$FLUSHATTNS	; FLUSH THAT LIST
;
; CHECK IF MAILBOX CONTROL BLOCK SHOULD BE DEALLOCATED. IF SO, DEALLOCATE
; ANY REMAINING MESSAGE BLOCKS AND MARK THE MAILBOX AS NO LONGER VALID.
;
	TSTW	UCB$W_REFC(R5)		; REFERENCE COUNT ZERO?
	BNEQ	80$			; IF NEQ NO
	BBC	#UCB$V_DELMBX,UCB$W_DEVSTS(R5),80$ ; IF CLR, NO DELETE
	MOVL	UCB$L_MB_SHB(R5),R0	; GET ADDRESS OF SHB
	DECL	SHB$L_REFCNT(R0)	; DECREMENT SHARED MEMORY REFERENCE COUNT
	MOVL	SHB$L_DATAPAGE(R0),R1	; GET DATAPAGE ADDRESS
	LOCK	#SHD$V_MBXLCK,SHD$B_FLAGS(R1) ; LOCK MAILBOX TABLE
	MOVL	UCB$L_MB_MBX(R5),R2	; GET MAILBOX CONTROL BLOCK ADDRESS
	BBCCI	UCB$L_MB_PORT(R5),MBX$W_REF(R2),50$ ; CLEAR PORT'S REFERENCE
50$:	TSTW	MBX$W_REF(R2)		; ANY OTHER REFERENCES?
	BNEQ	70$			; IF NEQ YES
	BICB	#MBX$M_VALID,MBX$B_FLAGS(R2) ; CLEAR VALID FLAG
	MOVZBL	MBX$B_CREATPORT(R2),R0	; GET CREATOR PORT NUMBER
	INCW	SHD$W_MBXQUOTA(R1)[R0]	; RESTORE CREATOR'S QUOTA
60$:	REMQHI	MBX$Q_MSG(R2),R11	; GET ADDRESS OF NEXT MESSAGE BLOCK
	BVS	70$			; IF VS NO MORE BLOCKS
	BSBW	DALLOC_BLOCKS		; DEALLOCATE THE MESSAGE BLOCK(S)
	BRB	60$			;
70$:
	UNLOCK	#SHD$V_MBXLCK,SHD$B_FLAGS(R1) ; UNLOCK MAILBOX TABLE
	MOVL	UCB$L_CRB(R5),R4	; CLEAR OUT THE POINTER IN THE
	MOVZWL	UCB$W_UNIT(R5),R6	; IDB TO THIS UCB, PREVENTING A
	MOVL	<CRB$L_INTD+VEC$L_IDB>(R4),R4 ; RACE CONDITION BY ANOTHER
	CLRL	IDB$L_UCBLST(R4)[R6]	; PORT QUEUING A PRQ FOR THIS MAILBOX.
80$:
	POPR	#^M<R4,R5,R6,R7,R10,R11> ; RESTORE REGISTERS
	RSB				;

	.SBTTL	CHECKIO - CHECK READ AND WRITE ACCESS AND PARAMETERS
;++
; READCHECKIO - CHECK READ ACCESS AND PARAMETERS
; WRITECHECKIO - CHECK WRITE ACCESS AND PARAMETERS
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED BY THE READ AND WRITE FDT ROUTINES TO VALIDATE
; THE I/O REQUEST. THE CHECKS ARE:
;
;	o  ACCESS TO UNIT BY UIC
;
;	o  MESSAGE SIZE WITHIN MAX MESSAGE SIZE
;
;	o  BUFFER ACCESSABLE
;
;
; ZERO LENGTH TRANSFERS AND ACCESS VIOLATIONS CAUSE COMPLETIONS HERE.
;
; INPUTS:
;
;	R0-R2 = SCRATCH
;	R3 = PACKET ADDRESS
;	R4 = PCB ADDRESS
;	R5 = UCB ADDRESS
;	R6 = CCB ADDRESS
;	R7 = FUNCTION CODE
;	R8 = ADDRESS OF FDT TABLE ENTRY FOR THIS ROUTINE
;	R9-R11 = SCRATCH
;	AP = ADDRESS OF THE FIRST QIO PARAMETER
;
; OUTPUTS:
;
;	R3 = PACKET ADDRESS
;	R4 = PCB ADDRESS
;	R5 = UCB ADDRESS
;
;	IRP$L_MEDIA(R3) = BUFFER ADDRESS.
;	IRP$W_BCNT(R3) = BUFFER SIZE.
;
;--
READCHECKIO:				; CHECK FOR READ ACCESS
	PUSHAB	G^EXE$READCHK		; SET UP FOR BUFFER READ I/O ACCESS
	MOVAB	G^EXE$CHKRDACCES,R9	; SET UP FOR UNIT READ ACCESS
	BRB	CHECKIO			;
WRITECHECKIO:				; CHECK FOR WRITE ACCESS
	MOVAB	G^EXE$CHKWRTACCES,R9	; SET UP FOR BUFFER WRITE I/O ACCESS
	PUSHAB	G^EXE$WRITECHK		; SET UP FOR UNIT WRITE ACCESS
CHECKIO:				; CHECK I/O ACCESS AND PARAMETERS
	MOVL	PCB$L_ARB(R4),R0	; GET ACCESS RIGHTS BLOCK
	MOVZWL	UCB$W_VPROT(R5),R1	; GET PROTECTION MASK
	MOVL	UCB$L_OWNUIC(R5),R2	; GET MAILBOX OWNER'S UIC
	CLRW	IRP$W_BOFF(R3)		; RESET QUOTA
	JSB	(R9)			; CHECK READ/WRITE ACCESS
	BLBC	R0,ERROR		; BR IF ACCESS FAILURE
	MOVZWL	P2(AP),R1		; GET BUFFER SIZE
	BEQL	ZEROLENGTH		; IF EQL THEN COMPLETE HERE
	CMPW	R1,UCB$W_DEVBUFSIZ(R5)	; MESSAGE SIZE IN RANGE?
	BGTRU	TOOSMALL		; IF GTRU THEN NO
	MOVL	P1(AP),R0		; GET BUFFER ADDRESS
	MOVL	R0,IRP$L_MEDIA(R3)	; SAVE BUFFER ADDRESS
	RSB				; RETURN AND CHECK BUFFER ACCESS

ZEROLENGTH:				; COMPLETE ZERO LENGTH TRANSFERS
	MOVZBL	#SS$_NORMAL,R0		; SET SUCCESS
	JMP	G^EXE$FINISHIOC		;
TOOSMALL:				; MAILBOX TOO SMALL FOR MESSAGE
	MOVZWL	#SS$_MBTOOSML,R0	; SET BOX TOO SMALL
ERROR:					; ERROR - ABORT THE I/O REQUEST
	JMP	G^EXE$ABORTIO		; ABORT THE I/O

	.SBTTL	FDTREAD - READ FUNCTION DECISION ROUTINE
;++
; FDTREAD - FUNCTION DECISION ROUTINE FOR READ OPERATIONS
;
; FUNCTIONAL DESCRIPTION:
;
; THE REQUEST IS FIRST CHECKED FOR READ ACCESS TO THE MAILBOX AND
; WRITE ACCESS TO THE SPECIFIED BUFFER.  THE PACKET IS THEN QUEUED
; TO THE UNIT'S I/O QUEUE (UCB$L_IOQFL) FOR PROCESSING WHEN THE UNIT
; IS NOT BUSY, IN OTHER WORDS, WHEN ANY PREVIOUS READ REQUESTS ON THIS
; PROCESSOR HAVE BEEN SATISFIED.
;
; IF THE FUNCTION MODIFIER IO$M_NOW IS SPECIFIED, THE MAILBOX IS CHECKED
; TO SEE IF ANY MESSAGES ARE WAITING.  IF THERE AREN'T MESSAGES, THE
; REQUEST IS COMPLETED WITH FAILURE, OTHERWISE IT IS QUEUED AS FOR A
; NORMAL READ REQUEST.
;
; INPUTS:
;
;	R0-R2 = SCRATCH
;	R3 = I/O PACKET ADDRESS
;	R4 = CURRENT PCB ADDRESS
;	R5 = UCB ADDRESS
;	R6 = CCB ADDRESS
;	R7 = FUNCTION CODE
;	R8 = ADDRESS OF FDT TABLE ENTRY FOR THIS ROUTINE
;	R9-R11 = SCRATCH
;	AP = FIRST QIO PARAMETER ADDRESS
;
; OUTPUTS:
;
;	THE PACKET IS QUEUED VIA "EXE$QIODRVPKT" OR
;	THE REQUEST IS COMPLETED WITH AN ERROR VIA "EXE$ABORTIO" OR
;	"EXE$FINISHIOC"
;
; STATUS CODES:
;
;	SS$_NOPRIV - USER DOES NOT HAVE PRIVILEGE TO READ MAILBOX
;	SS$_ACCVIO - BUFFER ACCESS VIOLATION
;	SS$_MBTOOSML - REQUEST EXCEEDS THE MAXIMUM MESSAGE SIZE
;	SS$_ENDOFFILE - NO MESSAGE AVAILABLE AND IO$M_NOW SPECIFIED
;	SS$_NORMAL - NORMAL STATUS
;--
FDTREAD:				;
	BSBB	READCHECKIO		; VALIDATE THE REQUEST
	BISW	#IRP$M_MBXIO,IRP$W_STS(R3) ; SET MAILBOX READ
;
; UPDATE MEASUREMENT COUNTER IF ENABLED
;
	.IF NE CA$_MEASURE
	INCL	G^PMS$GL_MBREADS	; COUNT MAILBOX READS
	.ENDC
;
; ALLOCATE TWO I/O PACKET EXTENSIONS TO USE AS FORK BLOCKS IF WE'RE 
; FORCED TO WAIT WHEN: 1) NOTIFYING OTHER PROCESSOR OF WAITING READER
; 2) NOTIFYING OTHER PROCESSOR WHEN MESSAGE IS READ
;
	CLRL	IRP$L_EXTEND(R3)	; SET NO EXTENSION YET
	BSBW	ALLOC_IRPE		; ALLOCATE AN EXTENSION
	BSBW	ALLOC_IRPE		; ALLOCATE ANOTHER EXTENSION
;
; IF IO$M_NOW IS SPECIFIED, CHECK IF THERE ARE ANY MESSAGES WAITING.
; IF THERE ARE OR IO$M_NOW IS NOT SPECIFIED, QUEUE THE REQUEST.
; OTHERWISE COMPLETE THE REQUEST WITH FAILURE.
;
	BBC	#IO$V_NOW,IRP$W_FUNC(R3),10$; BR IF NOT "NOW"
	SETIPL	#IPL$_MAILBOX		; RAISE IPL TO MAKE SURE NO
					; OTHER REQUEST SNEAKS IN QUEUE
	MOVL	UCB$L_MB_MBX(R5),R2	; GET MAILBOX ADDRESS
	TSTL	MBX$Q_MSG(R2)		; ANY MESSAGES IN MAILBOX?
	BNEQ	10$			; IF NEQ THEN YES
	MOVZWL	#SS$_ENDOFFILE,R0	; SET NO TRANSFER AND STATUS
	JMP	G^EXE$FINISHIOC		; COMPLETE THE I/O
10$:
	JMP	G^EXE$QIODRVPKT		; QUEUE PACKET TO STARTIO

	.SBTTL	FDTSET - HANDLE SET MODE FUNCTIONS
;++
; FDTSET - HANDLE SET MODE FUNCTIONS
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IMPLEMENTS THE IO$_SETMODE FUNCTIONS.
; THE DIFFERENT FUNCTIONS ARE SELECTED BY A FUNCTION CODE MODIFIER.
; THE FUNCTIONS ARE:
;
;	IO$M_SETPROT	- SET VOLUME PROTECTION
;	IO$M_READATTN	- SET READ ATTENTION AST
;	IO$M_WRTATTN	- SET WRITE ATTENTION AST
;
; INPUTS:
;
;	R0-R2 = SCRATCH
;	R3 = I/O PACKET ADDRESS
;	R4 = CURRENT PCB
;	R5 = UCB ADDRESS FOR MAILBOX UNIT
;	AP = ADDRESS OF QIO PARAMETER BLOCK
;
; OUTPUTS:
;
;	NONE.
;
; STATUS RETURNS:
;
;	SS$_NORMAL - SUCCESSUFL COMPLETION
;	SS$_INSFMEM - INSUFICIENT MEMORY TO ALLOCATE AST BLOCK
;	SS$_EXQUOTA - AST QUOTA EXCEEDED
;	SS$_ILLIOFUNC - ILLEGAL SET MODE FUNCTION
;	SS$_NOPRIV - THE USER CANNOT SET THE VOLUME PROTECTION
;--
FDTSET:					; SET RECEIVE AST FUNCTION
;
; SEE IF THIS IS A SETPROT FUNCTION.
;
	BBS	#IO$V_SETPROT,-		; BRANCH IF SETPROT FUNCTION
		IRP$W_FUNC(R3),50$	;
;
; SEE IF USER CAN READ THIS MAILBOX
;
	MOVL	PCB$L_ARB(R4),R0	; GET ACCESS RIGHTS BLOCK
	MOVZWL	UCB$W_VPROT(R5),R1	; GET UNIT PROTECTION
	MOVL	UCB$L_OWNUIC(R5),R2	; GET OWNER UIC
	JSB	G^EXE$CHKRDACCES	; CHECK READ ACCESS TO UNIT
	BLBC	R0,ERROR		; IF LOW CLEAR THEN ERROR
;
; CREATE AN AST CONTROL BLOCK AND ENTER IT IN APPROPRIATE ATTENTION LIST
;
	MOVAL	UCB$L_MB_WAST(R5),R7	; ASSUME WRITE AST LIST ADDR
	BBC	#IO$V_READATTN,IRP$W_FUNC(R3),10$; BR IF NOT READ AST
	MOVAL	UCB$L_MB_RAST(R5),R7	; GET ADDR OF READ AST LIST
10$:	PUSHL	R4			; SAVE PCB ADDRESS
	PUSHL	R7			; SAVE AST LIST HEAD ADDRESS
	JSB	G^COM$SETATTNAST	; ENTER AN AST REQUEST IN LIST
	POPL	R4			; GET AST LIST HEAD ADDRESS
;
; SET WAITING ATTENTION AST FLAG IN MAILBOX AND CHECK IF ATTENTION
; CONDITION ALREADY EXISTS.  IF IT DOES, CLEAR THE WAITING ATTENTION
; AST FLAG IN MAILBOX AND DELIVER THE AST.  FLAG MUST BE SET BEFORE
; CHECK IN CASE ANOTHER PROCESSOR CHECKED FOR WAITING ATTENTIONS AFTER
; WE DID, BUT BEFORE WE COULD SET OUR WAITING FLAG.
;
	MOVL	UCB$L_MB_MBX(R5),R2	; GET ADDR OF MAILBOX
	BBS	#IO$V_READATTN,IRP$W_FUNC(R3),20$ ; BR IF READ AST
					; WRITE ATTENTION AST REQUEST
	SET_PORTFLAG MBX$W_WRITAST(R2)	; SET FLAG TO NOTIFY IF WRITE OCCURS
	TSTL	MBX$Q_MSG(R2)		; ANY MESSAGES WRITTEN?
	BEQL	40$			; IF EQL THEN NO - JUST COMPLETE
	CLR_PORTFLAG MBX$W_WRITAST(R2)	; CLEAR NOTIFY FLAG
	BRB	30$			; DELIVER THE AST
20$:					; READ ATTENTION AST REQUEST
	SET_PORTFLAG MBX$W_READAST(R2)	; SET FLAG TO NOTIFY IF READ OCCURS
	TSTW	MBX$W_READER(R2)	; ANY READERS WAITING?
	BEQL	40$			; IF EQL THEN NO - JUST COMPLETE
	CLR_PORTFLAG MBX$W_READAST(R2)	; CLEAR NOTIFY FLAG
30$:
	JSB	G^COM$DELATTNAST	; DELIVER THE AST IMMEDIATELY
;
; COMPLETE THE SETMODE REQUEST
;
40$:	POPL	R4			; RESTORE PCB ADDRESS
45$:	JMP	G^EXE$FINISHIOC		; COMPLETE THE I/O
;
; HANDLE THE SETPROT FUNCTION
;
50$:	MOVZWL	#SS$_NOPRIV,R0		; ASSUME NO PRIVILEGE
	CMPL	PCB$L_UIC(R4),-		; IS THIS THE VOLUME OWNER?
		UCB$L_OWNUIC(R5)	;
	BNEQ	52$			; BRANCH IF NOT
51$:	MOVW	P2(AP),R1		; GET THE PROTECTION MASK
	MOVL	UCB$L_MB_MBX(R5),R2	; GET MBX ADDRESS
	MOVZWL	#SS$_NORMAL,R0		; SET SUCCESS STATUS
	SETIPL	UCB$B_DIPL(R5)		; BLOCK DEVICE INTERRUPTS
	MOVW	R1,UCB$W_VPROT(R5)	; SET THE NEW PROTECTION MASK
	MOVW	R1,MBX$W_PROT(R2)	; SET SECOND COPY OF PROTECTION MASK
	BRB	45$			; COMPLETE THE I/O
52$:	BBS	#PRV$V_BYPASS,-		; BRANCH IF USER HAS BYPASS
		@PCB$L_PHD(R4),51$	;
	BRW	ERROR			; ABORT THE I/O

	.SBTTL	FDTEOF - WRITE EOF MESSAGE TO MAILBOX
;++
; FDTEOF - WRITE EOF MESSAGE TO THE MAILBOX
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS THE FDT ROUTINE FOR IO$WRITEOF. THE ACTION IS TO BUILD A
; ZERO LENGTH MESSAGE AND TO INSERT IT IN THE MAILBOX.
; THIS MESSAGE, WHEN READ RESULTS IN AN SS$_ENDOFILE STATUS RETURN.
;
; INPUTS:
;
;	R0-R2 = SCRATCH
;	R3 = I/O PACKET ADDRESS
;	R4 = CURRENT PCB ADDRESS
;	R5 = MAILBOX UCB ADDRESS
;	R6 = CCB ADDRESS
;	R7 = FUNCTION CODE
;	R8 = ADDRESS OF FDT TABLE ENTRY FOR THIS ROUTINE
;	R9-R11 = SCRATCH
;	AP = ADDRESS OF USER ARGUMENT BLOCK AT "P1"
;
; OUTPUTS:
;
;	IRP$L_MEDIA(R3) = FAKE BUFFER ADDRESS.
;	IRP$W_BCNT(R3) = ZERO BUFFER SIZE.
;
;	THE I/O IS COMPLETED IN THE WRITE FDT LOGIC. ( SEE BELOW )
;--
FDTEOF:					;
	CLRL	IRP$W_BOFF(R3)		; SET NO TRANSFER AND NO QUOTA
	MOVL	PCB$L_ARB(R4),R0	; GET ACCESS RIGHTS BLOCK
	MOVZWL	UCB$W_VPROT(R5),R1	; GET VOLUME PROTECTION
	MOVL	UCB$L_OWNUIC(R5),R2	; GET THE OWNER UIC
	JSB	G^EXE$CHKWRTACCES	; CHECK WRITE ACCESS TO UNIT
	BLBC	R0,10$			; IF ERROR THEN BRANCH
	CLRL	IRP$W_BCNT(R3)		; SET ZERO LENGTH BUFFER
	MOVAB	(SP),IRP$L_MEDIA(R3)	; SET FAKE ADDR OF BUFFER
	BRB	WRITE			; WRITE THE MESSAGE
10$:	BRW	ERROR			; CONTINUE

	.SBTTL	FDTWRITE - WRITE OPERATION FDT ROUTINE
;++
; FDTWRITE -- FUNCTION DECISION ACTION ROUTINE FOR WRITE FUNCTIONS
;
; FUNCTIONAL DESCRIPTION:
;
; THE USER REQUEST IS VALIDATED FOR PRIVILEGE, SIZE, ACCESS AND AVAILABLE
; SPACE. IF VALID, A BUFFERED I/O BLOCK IS ALLOCATED (IMPLIED RESOURCE WAIT).
; THE BLOCK IS SET UP AND QUEUED TO THE UNIT MESSAGE LIST. IF THE UNIT
; IS BUSY, THE OUTSTANDING READ OPERATION IS COMPLETED DIRECTLY.
; IN THE CASE OF "WRITENOW" FUNCTIONS THE I/O IS COMPLETED BEFORE THE
; MESSAGE IS QUEUED. OTHERWISE THE READ COMPLETE ROUTINE COMPLETES
; THE MESSAGE ASSOCIATED WRITE.
;
; INPUTS:
;
;	R3 = I/O PACKET ADDRESS
;	R4 = CURRENT PCB ADDRESS
;	R5 = UCB ADDRESS
;	R6 = CCB ADDRESS
;	R7 = FUNCTION CODE
;	R8 = ADDRESS OF FDT TABLE ENTRY FOR THIS ROUTINE
;	R9-R11 = SCRATCH
;	AP = ADDRESS OF USER ARGUMENT BLOCK AT "P1"
;
; OUTPUTS:
;
;	THE I/O IS COMPLETED IN ERROR, THE I/O IS RESTARTED BECAUSE OF
;	RESOURCE WAIT, OR THE I/O IS COMPETED NORMALLY.
;
; STATUS RETURNS:
;
;	SS$_MBTOOSML - MESSAGE IS TOO BIG
;	SS$_ACCVIO - BUFFER ACCESS VIOLATION ( "EXE$WRITECHK" )
;	SS$_MBFULL - MAILBOX IS FULL
;	SS$_NOPRIV - USER DOES NOT HAVE WRITE PRIVILEGE
;	SS$_NORMAL - SUCCESSFUL STATUS
;	SS$_INSFMEM - NO MEMORY FOR BUFFER ALLOCATION
;--
FDTWRITE:				;
	BSBW	WRITECHECKIO		; CHECK OPERATION PARAMETERS
WRITE:
	MOVZWL	IRP$W_BCNT(R3),R9	; R9 = SIZE OF USER DATA
	MOVL	IRP$L_MEDIA(R3),R10	; R10 = ADDRESS OF USER DATA
	CLRL	R11			; R11 = ADDRESS OF FIRST BLOCK
;
; ALLOCATE AN I/O PACKET EXTENSION TO USE AS A FORK BLOCK IF WE'RE FORCED
; TO WAIT WHEN NOTIFYING OTHER PROCESSORS OF THE AVAILABILITY OF A MESSAGE.
;
	CLRL	IRP$L_EXTEND(R3)	; SET NO EXTENSION YET
	BSBW	ALLOC_IRPE		; ALLOCATE A EXTENSION
;
; ALLOCATE SHARED MEMORY POOL BLOCK
;
ALLOC_BLOCK:				; ALLOCATE SHARED MEMORY BLOCK
	MOVL	UCB$L_MB_SHB(R5),R2	; GET ADDR OF SHB
	MOVL	SHB$L_DATAPAGE(R2),R1	; GET ADDR OF DATAPAGE
	MOVL	#RSN$_NPDYNMEM,R0	; GET RESOURCE NUMBER
	DSBINT	#IPL$_SYNCH		; PREVENT SCHEDULING
	MOVAW	SHD$W_RESWAIT(R1)[R0],-(SP) ; SAVE ADDR OF WAIT MASK
	SET_PORTFLAG @(SP)		; ASSUME ALLOCATION FAILURE
					; (AVOIDS MISSING NOTIFICATION)
	JSB	G^EXE$ALOSHARED		; ALLOCATE A SHARED MEMORY BLOCK
	BLBS	R0,10$			; IF LBS SUCCESS
	BRW	ALLOC_FAIL		; ELSE - FAILURE
10$:	CLR_PORTFLAG @(SP)+		; CLEAR FLAG SINCE BLOCK OBTAINED
	ENBINT				; ALLOW SCHEDULING
	TSTL	R11			; IS THIS THE FIRST BLOCK?
	BNEQ	20$			; IF NEQ NO
	MOVL	R2,R11			; SAVE ADDRESS OF FIRST BLOCK
	MOVW	R9,MSG_W_MSGLENGTH(R2)	; SET SIZE OF MESSAGE DATA
	BRB	SETUP_BLOCK		;
20$:
	SUBL3	R11,R2,MSG_L_CHAINLINK(R8) ; SET OFFSET FROM FIRST BLOCK TO NEW BLOCK
;
; SET UP MESSAGE BLOCK
;
SETUP_BLOCK:				; SET UP MESSAGE BLOCK
	MOVB	#DYN$C_SHRBUFIO,MSG_B_TYPE(R2) ; SET TYPE OF BLOCK
	
	MOVB	UCB$L_MB_PORT(R5),MSG_B_PORT(R2) ; SET WRITER'S PORT NUMBER
	ASSUME	PRQ$C_MINLENGTH GE MSG_B_MESSAGE+4 ;NEED ROOM FOR SOME DATA
	SUBL	#MSG_B_MESSAGE,R1	; COMPUTE SIZE FOR DATA IN BLOCK
	MOVW	R9,MSG_W_LENGTH(R2)	; ASSUME ALL DATA FITS IN BLOCK
	CMPL	R9,R1			; IS DATA TOO BIG?
	BLEQ	10$			; IF LEQ NO - DATA FITS
	MOVW	R1,MSG_W_LENGTH(R2)	; ELSE - SET LOWER SIZE
10$:
	CLRL	MSG_L_CHAINLINK(R2)	; CLEAR CHAIN LINK POINTER
	MOVL	IRP$L_SEQNUM(R3),-	; SET WRITER'S IRP SEQUENCE NUMBER
		MSG_L_IRPSEQ(R2)	;
	BBC	#IO$V_NOW,IRP$W_FUNC(R3),15$ ; BR IF NOT "NOW"
	CLRL	MSG_L_IRPSEQ(R2)	; CLEAR WRITER'S IRP SEQUENCE NUMBER
					; INDICATES NO NEED TO NOTIFY WRITER
15$:	MOVL	PCB$L_PID(R4),-		; INSERT PID OF WRITER
		MSG_L_PID(R2)		;
	MOVL	R2,R8			; SAVE ADDRESS OF BLOCK
;
; COPY DATA FROM USER BUFFER TO SHARED MEMORY
;
	PUSHR	#^M<R2,R3,R4,R5>	; SAVE REGISTERS
	MOVC3	MSG_W_LENGTH(R2),-	; MOVE FROM USER TO SHARED MEMORY
		(R10),MSG_B_MESSAGE(R2)	;
	POPR	#^M<R2,R3,R4,R5>	; RESTORE REGISTERS
	MOVZWL	MSG_W_LENGTH(R2),R0	; GET SIZE OF MESSAGE AGAIN
	ADDL	R0,R10			; INCREMENT USER BUFFER ADDR
	SUBL	R0,R9			; DECREMENT USER BUFFER SIZE
	BEQL	CHECK_QUOTAS		; IF EQL, NO MORE
	BRW	ALLOC_BLOCK		; ELSE, ALLOCATE ANOTHER BLOCK
;
; INTERLOCK QUOTA CHECKS
;
CHECK_QUOTAS:				; CHECK MAILBOX QUOTAS
	DSBINT	#IPL$_MAILBOX		; DISABLE MAILBOX I/O INTERRUPTS
	MOVL	UCB$L_MB_SHB(R5),R1	; GET ADDRESS OF SHB
	MOVL	SHB$L_DATAPAGE(R1),R1	; GET ADDRESS OF DATAPAGE
	MOVL	#RSN$_MAILBOX,R0	; GET RESOURCE NUMBER
	MOVAW	SHD$W_RESWAIT(R1)[R0],-(SP) ; SAVE ADDRESS OF WAIT MASK
	SET_PORTFLAG @(SP)		; ASSUME MAILBOX FULL FAILURE
					; (AVOIDS MISSING NOTIFICATION)
	MOVL	UCB$L_MB_MBX(R5),R2	; GET ADDRESS OF MAILBOX
	LOCK	#MBX$V_QUOTALCK,MBX$B_FLAGS(R2) ; INTERLOCK QUOTA CHECKS
;
; SEE IF MESSAGE WILL EXCEED MAILBOX BUFFER QUOTA, IN OTHER WORDS, IS
; THE MAILBOX FULL?
;
	CMPW	IRP$W_BCNT(R3),MBX$W_BUFFQUO(R2) ; MESSAGE FIT?
	BGTRU	MAILBOX_FULL		; IF GTR THEN NO
;
; ADJUST MESSAGE COUNT AND BUFFER QUOTA
;
	INCW	MBX$W_MSGCNT(R2)	; INCREMENT MESSAGE COUNT
	SUBW	IRP$W_BCNT(R3),-	; DECREASE BUFFER QUOTA
		MBX$W_BUFFQUO(R2)	;
	UNLOCK	#MBX$V_QUOTALCK,MBX$B_FLAGS(R2) ; UNLOCK MAILBOX QUOTAS
	MOVW	MBX$W_MSGCNT(R2),UCB$L_DEVDEPEND(R5) ; SAVE MESSAGE COUNT
	CLR_PORTFLAG @(SP)+		; CLEAR WAIT FLAG AS MAILBOX NOT FULL	
;
; QUEUE THE MESSAGE.  MUST BE QUEUED BEFORE WE LOOK FOR ANYONE WAITING
; TO AVOID MISSING AN INTERESTED PROCESSOR.
;
	QRETRY	SUCCESS=20$,-		; INSERT MESSAGE IN QUEUE
	INSQTI	(R11),MBX$Q_MSG(R2)	;
	ENBINT				; RE-ENABLE INTERRUPTS
	BSBW	DALLOC_BLOCKS		; DEALLOCATE MESSAGE BLOCKS
	MOVZWL	#SS$_BADQUEUEHDR,R0	; SET FAILURE STATUS
	JMP	G^EXE$FINISHIOC		; COMPLETE THE I/O
;
; NOTIFY OTHER INTERESTED PROCESSORS THAT A MESSAGE WAS WRITTEN.
;
20$:
	PUSHR	#^M<R3,R5>		; SAVE REGISTERS
	BSBW	NOTIFY_WRITE		; NOTIFY INTERESTED PROCESSORS
	POPR	#^M<R3,R5>		; RESTORE REGISTERS
;
; UPDATE MEASUREMENT COUNTER IF ENABLED
;
	.IF NE CA$_MEASURE		; CHECK FOR MEASUREMENT ENABLED
	INCL	G^PMS$GL_MBWRITES	; COUNT MAILBOX WRITES
	.ENDC
;
; IF I/O REQUEST SPECIFIED IO$M_NOW, COMPLETE IT.  ELSE, INSERT I/O
; PACKET IN WRITE QUEUE AND IT WILL BE COMPLETED WHEN MESSAGE IS READ.
;
	BBS	#IO$V_NOW,IRP$W_FUNC(R3),30$; BR IF WRITE NOW
	INSQUE	(R3),UCB$L_MB_WIOQFL(R5) ; INSERT IRP IN WRITE I/O QUEUE
	ENBINT				; RE-ENABLE INTERRUPTS
	JMP	G^EXE$QIORETURN		; RETURN TO CALLER
30$:
	ENBINT				; RE-ENABLE INTERRUPTS
	MOVL	IRP$W_BCNT-2(R3),R0	; SET BYTE COUNT IN 2ND WORD
	MOVW	#SS$_NORMAL,R0		; SET STATUS IN 1ST WORD
	JMP	G^EXE$FINISHIOC		; COMPLETE THE I/O

	.SBTTL	ALLOC_FAIL/MAILBOX_FULL - WRITE FDT ROUTINE FAILURES
;++
;
; ALLOC_FAIL - SHARED MEMORY POOL ALLOCATION  FAILURE.
; MAILBOX_FULL - MAILBOX QUOTA FAILURE.
;
; INPUTS:
;
;	R5 = UCB ADDRESS.
;	R11 = FIRST SHARED MEMORY MESSAGE BLOCK ADDRESS.
;
; ALLOC_FAIL:
;	(SP) = ADDRESS OF SHARED MEMORY WAIT MASK.
;	4(SP) = OLD IPL (IPL$_ASTDEL)
;
; MAILBOX_FULL:
;	(SP) = OLD IPL (IPL$_MAILBOX)
;	4(SP) = ADDRESS OF SHARED MEMORY WAIT MASK
;	8(SP) = OLD IPL (IPL$_ASTDEL)
;
; OUTPUTS:
;
;	ALL SHARED MEMORY MESSAGE BLOCKS IN THE CHAIN ARE DEALLOCATED
;	AND THE REQUESTING PROCESS IS PUT IN A WAIT STATE UNTIL THE
;	NEEDED RESOURCE BECOMES AVAILABLE.
;--
ALLOC_FAIL:				; SHARED MEMORY ALLOCATION FAILURE
	ADDL	#4,SP			; POP ADDR. OF WAIT MASK OFF STACK
	MOVZWL	#SS$_INSFMEM,(SP)	; SET FAILURE STATUS, FORGETTING IPL
	MOVZBL	#RSN$_NPDYNMEM,R1	; SET RESOURCE TO AWAIT
	BRB	SHMRES_WAIT		;
MAILBOX_FULL:				; MAILBOX IS FULL
	UNLOCK	#MBX$V_QUOTALCK,MBX$B_FLAGS(R2) ; UNLOCK QUOTAS
	ADDL	#4,SP			; POP MASK ADDRESS OFF STACK
	MOVZWL	#SS$_MBFULL,(SP)	; SET FAILURES STATUS, FORGETTING IPL
	SETIPL	#IPL$_SYNCH
	MOVZBL	#RSN$_MAILBOX,R1	; SET RESOURCE TO AWAIT
SHMRES_WAIT:				; WAIT FOR SHARED MEMORY RESOURCE
	BSBB	DALLOC_BLOCKS		; DEALLOCATE SHARED MEMORY BLOCKS
;
; WAIT FOR NEEDED RESOURCE, BY DEALLOCATING I/O PACKETS, RESTORING
; I/O QUOTAS AND COUNTS AND INSERTING PROCESS IN MWAIT STATE QUEUE.
; WHEN RESOURCE BECOMES AVAILABLE, PROCESS WILL BE RESTARTED AT
; BEGININNING OF $QIO REQUEST.
;
RES_WAIT:				; WAIT FOR NEEDED RESOURCE
	BSBW	DALLOC_IRPE		; DEALLOCATE IRPE'S
	POPL	R0			; GET FAILURE STATUS
	SETIPL	#IPL$_SYNCH		; SYNCHRONIZE WITH EVENT REPORTING
	JMP	G^EXE$IORSNWAIT		; WAIT FOR RESOURCE

	.SBTTL	DALLOC_BLOCKS - DEALLOCATE SHARED MEMORY BLOCKS
;++
;
; DALLOC_BLOCKS - DEALLOCATE ANY SHARED MEMORY BLOCKS
;
; INPUTS:
;
;	R11 = FIRST BLOCK ADDRESS.
;
; OUTPUTS:
;
;	ALL SHARED MEMORY MESSAGE BLOCKS IN THE CHAIN ARE DEALLOCATED.
;
;	R1,R2,R3 ARE PRESERVED.
;
;--
DALLOC_BLOCKS:				; DEALLOCATE SHARED MEMORY
	PUSHR	#^M<R1,R2,R3>		; SAVE REGISTERS
	MOVL	R11,R0			; GET ADDRESS OF FIRST BLOCK
	BEQL	20$			; IF EQL NOT ALLOCATED
10$:
	MOVL	MSG_L_CHAINLINK(R0),R10	; GET OFFSET TO NEXT BLOCK
	JSB	G^EXE$DEASHARED		; DEALLOCATE THE BLOCK
	ADDL3	R11,R10,R0		; COMPUTE ADDRESS OF NEXT BLOCK
	TSTL	R10			; IS THERE A NEXT BLOCK?
	BNEQ	10$			; IF NEQ YES
20$:
	POPR	#^M<R1,R2,R3>		; RESTORE REGISTERS
	RSB				;


	.SBTTL	STARTIO - STARTIO OPERATION
;++
; STARTIO - START READ OPERATION ON SHARED MEMORY MAILBOX
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED WHEN THE UNIT IS NOT BUSY AND THERE IS A
; PACKET TO PROCESS. 
;
; IF THERE IS A MESSAGE WAITING IN THE MAILBOX:
;
;	o  THE MESSAGE IS DEQUEUED
;
;	o  THE MAILBOX QUOTAS ARE ADJUSTED
;
;	o  IF THE MESSAGE CONTAINED THE MESSAGE WRITER'S IRP SEQUENCE
;	   NUMBER, A MESSAGE IS SENT TO THE APPROPRIATE PROCESSOR TO
;	   TO INDICATE THE WRITE I/O SHOULD BE COMPLETED.
;
;	o  THE READ I/O REQUEST IS POSTED WITH THE ADDRESS OF THE MESSAGE
;
; IF THERE IS NO MESSAGE WAITING IN THE MAILBOX AND THE I/O REQUEST
; SPECIFIED IO$M_NOW, THE REQUEST IS COMPLETED WITH FAILURE (SS$_ENDOFILE).
;
; IF THERE IS NO MESSAGE WAITING IN THE MAILBOX AND THE I/O REQUEST
; DID NOT SPECIFY IO$M_NOW:
;
;	o  THE PORT'S WAITING READER FLAG (MBX$W_READER) IS SET
;
;	o  THE READ ATTENTION AST FLAGS (MBX$W_READAST) FOR ALL PORTS
;	   ARE SCANNED AND IF SET, A MESSAGE IS SENT TO THE APPROPRIATE
;	   PROCESSOR TO INDICATE THAT THE AST'S SHOULD BE DELIVERED.
;
;	o  AN RSB TO THE DRIVERS CALLER IS EXECUTED LEAVING THE DRIVER
;	   TO AWAIT MESSAGE WRITTEN NOTIFICATION.
;
; INPUTS:
;
;	R3 = I/O PACKET ADDRESS
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R1 = OUR PORT NUMBER.
;	R2 = FIRST MESSAGE BLOCK ADDRESS.
;	R4 = MAILBOX ADDRESS.
;
;	OTHERWISE AN RSB IS DONE.
;--
STARTIO:				;
	MOVL	UCB$L_MB_MBX(R5),R4	; GET MAILBOX ADDRESS
	SET_PORTFLAG MBX$W_READER(R4)	; SET THAT WE HAVE A READER
	QRETRY	SUCCESS=10$,-		; ATTEMPT TO DEQUEUE A MESSAGE
	REMQHI	MBX$Q_MSG(R4),R2	;
	MOVZWL	#SS$_BADQUEUEHDR,R0	; SET FAILURE STATUS
	CLRL	R1			;
	REQCOM				; COMPLETE THE READ REQUEST
;
; IF A MESSAGE WAS DEQUEUED, COMPLETE THE I/O REQUEST.  OTHERWISE,
; IF IO$M_NOW WAS SPECIFIED EXIT WITH FAILURE.  OTHERWISE, NOTIFY
; ANY INTERESTED PROCESSORS THAT A READER IS WAITING AND JUST RETURN
; TO WAIT FOR A MESSAGE TO BE WRITTEN.
;
10$:
	BVC	FINISHREAD		; IF V-CLEAR, MESSAGE DEQUEUED
	BBC	#IO$V_NOW,IRP$W_FUNC(R3),20$ ; IF CLEAR, WAIT
	MOVZWL	#SS$_ENDOFFILE,R0	; SET FAILURE STATUS
15$:	CLRL	R1			;
	REQCOM				; COMPLETE THE READ REQUEST
20$:
	PUSHR	#^M<R3,R5>		; SAVE REGISTERS
	BSBW	NOTIFY_READER		; NOTIFY PROCESSORS OF READER
	POPR	#^M<R3,R5>		; RESTORE REGISTERS
	BLBC	R0,15$			; IF FAILURE, EXIT
	RSB				; ELSE, WAIT FOR MESSAGE NOTIFICATION

	.SBTTL	FINISHREAD - FINISH READ I/O OPERATION
;++
; FINISHREAD - FINISH READ OPERATION
;
; FUNCTIONAL DECRIPTION:
;
; THIS ROUTINE IS ENTERED WHEN A MESSAGE IS AVAILABLE FOR A READ I/O
; REQUEST.
;
; INPUTS:
;
;	R2 = FIRST MESSAGE BLOCK ADDRESS.
;	R3 = I/O REQUEST PACKET ADDRESS
;	R4 = MAILBOX ADDRESS.
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;--
FINISHREAD:				;
	CLR_PORTFLAG MBX$W_READER(R4)	; CLEAR WAITING READER FLAG
;
; FORMAT MESSAGE BLOCKS FOR I/O POST
;
	BISW	#IRP$M_COMPLX!IRP$M_CHAINED,- ;SET COMPLEX/CHAINED I/O
		IRP$W_STS(R3)		;
	MOVL	R2,IRP$L_SVAPTE(R3)	; INSERT BLOCK ADDRESS IN PACKET
	MOVL	IRP$L_MEDIA(R3),-	; INSERT USER BUFFER ADDRESS
		MSG_L_POSTUBUF(R2)	;
	MOVL	R2,R0			; GET FIRST BLOCK ADDRESS
10$:
	MOVAB	MSG_B_MESSAGE(R0),-	; INSERT ADDRESS OF DATA
		MSG_L_POSTIOBUF(R0)	;
	MOVL	MSG_L_CHAINLINK(R0),R1	; GET OFFSET TO NEXT BLOCK
	BEQL	RESTORE_QUOTAS		; IF EQL NONE
	ADDL	R2,R1			; COMPUTE ADDRESS OF BLOCK
	MOVL	R1,MSG_L_CHAINLINK(R0)	; SET ADDRESS AS LINK
	MOVL	R1,R0			; GET NEW ADDRESS
	BRB	10$			;
;
; RESTORE MAILBOX QUOTAS
;
RESTORE_QUOTAS:				; RESTORE MAILBOX QUOTAS
	LOCK	#MBX$V_QUOTALCK,MBX$B_FLAGS(R4) ; LOCK MAILBOX QUOTAS
	DECW	MBX$W_MSGCNT(R4)	; DECREMENT MESSAGE COUNT
	ADDW	MSG_W_MSGLENGTH(R2),-	; RESTORE BUFFER QUOTA
		MBX$W_BUFFQUO(R4)	;
	UNLOCK	#MBX$V_QUOTALCK,MBX$B_FLAGS(R4) ; UNLOCK MAILBOX QUOTAS
	MOVW	MBX$W_MSGCNT(R4),-	; SAVE MESSAGE COUNT
		UCB$L_DEVDEPEND(R5)	;
;
; NOTIFY WRITER THAT THE MESSAGE WAS READ (IF WRITER WANTED TO KNOW)
; AND REPORT MAILBOX RESOURCE AVAILABILITY.
;
	PUSHR	#^M<R2,R3,R4,R5>	; SAVE REGISTERS
	PUSHL	UCB$L_MB_SHB(R5)	; SAVE ADDRESS OF SHB
	BSBW	NOTIFY_READ		; NOTIFY WRITER
	MOVL	#RSN$_MAILBOX,R0	; GET MAILBOX RESOURCE NUMBER
	POPL	R1			; RESTORE ADDRESS OF SHB
	JSB	G^MA$RAVAIL		; REPORT THE RESOURCE AVAILABLE
	POPR	#^M<R2,R3,R4,R5>	; RESTORE REGISTERS
;
; COMPUTE SIZE OF DATA AND STATUS, AND COMPLETE THE READ I/O REQUEST.
;
	MOVW	MSG_W_MSGLENGTH(R2),R0	; GET SIZE OF ENTIRE MESSAGE
	CMPW	IRP$W_BCNT(R3),R0	; REQUEST SIZE GTRU MESSAGE?
	BGTRU	10$			; IF GTRU THEN MESSAGE SIZE CORRECT
	MOVW	IRP$W_BCNT(R3),R0	; OTHERWISE REQUEST SIZE IS CORRECT
10$:	ASHL	#16,R0,R0		; GET SIZE TO UPPER WORD
	MOVW	#SS$_NORMAL,R0		; ASSUME NORMAL STATUS
	TSTW	MSG_W_MSGLENGTH(R2)	; DID MESSAGE CONTAIN DATA?
	BNEQ	20$			; IF NEQ YES
	MOVW	#SS$_ENDOFFILE,R0	; ELSE SET EOF STATUS
20$:
	MOVL	MSG_L_PID(R2),R1	; GET PID OF WRITER
	REQCOM				; COMPLETE READ I/O REQUEST

	.SBTTL	MBX$INT - INTERRUPT DISPATCHER
;++
;
; MBX$INT - PORT REQUEST INTERRUPT DISPATCHER
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED WHEN THE PORT DRIVER RECEIVES A 
;	REQUEST FROM A PROCESSOR THAT SPECIFIES THE MAILBOX
;	DRIVER AS THE MESSAGE DISPATCHER ID (PRQ$C_MAILBOX).
;
;	THIS ROUTINE EXAMINES THE REQUEST TYPE CODE AND DETERMINES
;	WHETHER IT SHOULD:
;
;	  o  DELIVER ALL THE WRITE ATTENTION AST'S FOR A UNIT AND
;	     COMPLETE ANY WAITING READ REQUEST(S) (PRQ_WRITE)
;
;	  o  DELIVER ALL THE READ ATTENTION AST'S FOR A UNIT BECAUSE
;	     A READER IS WAITING (PRQ_READER)
;
;	  o  COMPLETE A WRITE I/O REQUEST BECAUSE THE MESSAGE WRITTEN
;	     WAS READ BY ANOTHER PROCESS (PRQ_READ)
;
; INPUTS:
;
;	R0-R4 = SCRATCH.
;	R5 = INTER-PROCESSOR REQUEST BLOCK ADDRESS.
;
;	00(SP) = ADDRESS OF IDB ADDRESS.
;
;	IPL = IPL$_MAILBOX
;
; OUTPUTS:
;
;	APPROPRIATE ACTION IS TAKEN DEPENDING ON THE REQUEST TYPE.
;
;--
MBX$INT:				; INTERRUPT DISPATCHER
	MOVL	@(SP)+,R3		; GET ADDRESS OF IDB
	MOVL	R5,R2			; SAVE REQUEST BLOCK ADDRESS
	MOVZWL	PRQ$W_UNIT(R2),R5	; GET UNIT NUMBER OF REQUEST
	MOVL	IDB$L_UCBLST(R3)[R5],R5	; GET UCB ADDRESS
	BEQL	INT_EXIT		; IF EQL NO CORRESPONDING UNIT
	MOVL	UCB$L_MB_MBX(R5),R4	; GET MAILBOX ADDRESS
	CASE	PRQ$W_REQTYPE(R2),-	; DISPATCH ON REQUEST TYPE
		LIMIT=#PRQ_READ,<-	;  LOW LIMIT
		READ_REQ,-		;  MESSAGE WAS READ
		WRITE_REQ,-		;  MESSAGE WAS WRITTEN
		READER_REQ,-		;  READER WAITING
		>			;
INT_EXIT:				; EXIT INTERRUPT
	RSB				;
;
; READER WAITING REQUEST - DELIVER ANY READ ATTENTION AST'S
;
READER_REQ:				; READER WAITING REQUEST
	CLR_PORTFLAG MBX$W_READAST(R4)	; CLEAR NOTIFY FLAG
	MOVAL	UCB$L_MB_RAST(R5),R4	; GET ADDRESS OF READ AST LIST
	JMP	G^COM$DELATTNAST	; DELIVER ANY AST'S AND EXIT
;
; MESSAGE WAS WRITTEN REQUEST - DELIVER ANY WRITE ATTENTION AST'S AND
; IF A READ I/O REQUEST IS ALREADY WAITING FOR A MESSAGE, ATTEMPT TO
; DEQUEUE A MESSAGE AND COMPLETE THE I/O REQUEST.
;
WRITE_REQ:				; MESSAGE WAS WRITTEN REQUEST
	CLR_PORTFLAG MBX$W_WRITAST(R4)	; CLEAR NOTIFY FLAG
	MOVAL	UCB$L_MB_WAST(R5),R4	; GET ADDRESS OF WRITE AST LIST
	JSB	G^COM$DELATTNAST	; DELIVER ANY AST'S
	MOVL	UCB$L_MB_MBX(R5),R4	; GET MAILBOX ADDRESS AGAIN
	BBC	#UCB$V_BSY,UCB$W_STS(R5),INT_EXIT ; IF CLEAR, NO READER WAITING
	MOVL	UCB$L_IRP(R5),R3	; GET I/O PACKET ADDRESS
	QRETRY	ERROR=10$,-		; ATTEMPT TO DEQUEUE A MESSAGE
	REMQHI	MBX$Q_MSG(R4),R2	;
	BVS	INT_EXIT		; IF V-SET, NO MESSAGE
	BRW	FINISHREAD		; ELSE, MESSAGE DEQUEUED
10$:
	MOVZWL	#SS$_BADQUEUEHDR,R0	; SET FAILURE STATUS
	CLRL	R1			;
	REQCOM				; COMPLETE THE READ REQUEST
;
; MESSAGE WAS READ REQUEST - COMPLETE THE ORIGINAL WRITE I/O REQUEST
;
READ_REQ:				; MESSAGE WAS READ REQUEST
	MOVAL	UCB$L_MB_WIOQFL(R5),R3	; GET ADDRESS OF WRITE PACKET LISTHEAD
	MOVL	R3,R1			; SAVE A COPY OF IT
10$:
	MOVL	(R3),R3			; GET ADDRESS OF NEXT PACKET
	CMPL	R3,R1			; END OF QUEUE?
	BEQL	INT_EXIT		; IF EQL YES - REQUEST GONE
	CMPL	IRP$L_SEQNUM(R3),-	; IS THIS THE CORRECT REQUEST?
		PRQ$L_PARAM(R2)		;
	BNEQ	10$			; IF NEQ NO
	REMQUE	(R3),R3			; REMOVE PACKET FROM QUEUE
	MOVW	IRP$W_BCNT(R3),R0	; GET BYTE COUNT OF MESSAGE
	ASHL	#16,R0,R0		; MOVE TO UPPER WORD
	MOVW	#SS$_NORMAL,R0		; SET SUCCESS STATUS
	CLRL	R1			; (NO PID)
	MOVQ	R0,IRP$L_IOST1(R3)	; SET I/O STATUS IN IRP
	JMP	G^COM$POST		; COMPLETE THE WRITE REQUEST

	.SBTTL	NOTIFY - NOTIFY OTHER PROCESSORS OF CONDITIONS
;++
;
; NOTIFY_READER - NOTIFY OTHER PROCESSORS OF A READER
; NOTIFY_READ - NOTIFY OTHER PROCESSOR THAT A MESSAGE WAS READ
; NOTIFY_WRITE - NOTIFY OTHER PROCESSORS THAT A MESSAGE WAS WRITTEN
;
; THESE ROUTINES ARE CALLED TO FORMAT AND SEND A REQUEST TO THE
; MAILBOX DRIVERS ON OTHER PROCESSORS.
;
; INPUTS:
;
;	R2 = FIRST MESSAGE BLOCK ADDRESS (NOTIFY_READ ONLY)
;	R3 = I/O PACKET ADDRESS
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R0 = SUCCESS/FAILURE.
;
;	REQUEST(S) FORMATTED AND PASSED TO PORT DRIVER FOR DELIVERY
;	TO REQUIRED PROCESSORS.
;
;	R0,R1,R2,R3,R4,R5 DESTROYED
;
;--

;
; NOTIFY ANY INTERESTED PROCESSORS THAT A READER IS WAITING
;
NOTIFY_READER:				; NOTIFY READER AVAILABLE
	MOVL	UCB$L_MB_MBX(R5),R2	; GET ADDRESS OF MAILBOX
	MOVW	MBX$W_READAST(R2),R0	; GET PORT #'S TO NOTIFY
	MOVZWL	#PRQ_READER,R1		; SET REQUEST TYPE
	BRB	NOTIFY			; NOTIFY THEM
;
; IF IT WANTED TO KNOW, NOTIFY PROCESSOR THAT WROTE MESSAGE THAT IT
; WAS READ.
;
NOTIFY_READ:				; NOTIFY MESSAGE READ
	ASHL	MSG_B_PORT(R2),#1,R0	; GET PORT # NOTIFY
	MOVZWL	#PRQ_READ,R1		; SET REQUEST TYPE
	MOVL	MSG_L_IRPSEQ(R2),R2	; GET WRITER'S PACKET #
	BNEQ	NOTIFY			; IF NEQ - WRITER IS INTERESTED
	RSB				; ELSE - JUST RETURN
;
; NOTIFY ANY INTERESTED PROCESSORS THAT A MESSAGE WAS WRITTEN
;
NOTIFY_WRITE:				; NOTIFY MESSAGE WRITTEN
	MOVL	UCB$L_MB_MBX(R5),R2	; GET ADDRESS OF MAILBOX
	MOVZWL	MBX$W_WRITAST(R2),R0	; GET PORT #'S TO NOTIFY
	BISW	MBX$W_READER(R2),R0	; ...
	MOVZWL	#PRQ_WRITE,R1		; SET REQUEST TYPE
;
; NOTIFY PROCESSOR(S) THAT A CONDITION HAS OCCURED
;
NOTIFY:					; NOTIFY PORT(S)
	PUSHL	R5			; SAVE UCB ADDRESS
	MOVL	IRP$L_EXTEND(R3),R5	; GET FORK BLOCK ADDRESS
	MOVL	IRPE$L_EXTEND(R5),-	; REMOVE BLOCK FROM LIST
		IRP$L_EXTEND(R3)	;
	BNEQ	10$			; IF NEQ NOT LAST BLOCK
	BICW	#IRP$M_EXTEND,IRP$W_STS(R3) ; ELSE, CLEAR EXTEND FLAG
10$:
	MOVW	R0,IRPE$W_MB_PORTS(R5)	; SAVE PORT #'S TO NOTIFY
	MOVW	R1,IRPE$W_MB_RQTYP(R5)	; SAVE REQUEST TYPE
	MOVL	R2,IRPE$L_MB_PARAM(R5)	; SAVE PARAMETER
	MOVB	#IPL$_MAILBOX,FKB$B_FIPL(R5) ; SET FORK IPL
	POPL	R0			; RESTORE UCB ADDRESS
	MOVL	UCB$L_MB_SHB(R0),R1	; GET SHB ADDRESS
	MOVL	SHB$L_DATAPAGE(R1),R1	; GET DATAPAGE ADDRESS
	MOVZBL	SHD$B_PORTS(R1),R1	; GET NUMBER OF PORTS
	SUBL3	#1,R1,IRPE$L_MB_PORT(R5) ; COMPUTE STARTING PORT NUMBER
	MOVL	UCB$L_CRB(R0),R4	; GET CRB ADDRESS
	MOVL	CRB$L_INTD+VEC$L_ADP(R4),R4 ; GET ADP ADDRESS
;
; FORMAT PROCESSOR REQUEST MESSAGE AND RETURN TO PORT DRIVER FOR
; DELIVERY TO OTHER PROCESSOR.
;
FORMAT_PRQ:				; FORMAT PROCESSOR REQUEST
	BBC	IRPE$L_MB_PORT(R5),-	; IF CLR, DON'T NOTIFY THE PORT
		IRPE$W_MB_PORTS(R5),10$	;
	JSB	G^MA$REQUEST		; CALL PORT DRIVER FOR A REQUEST BLOCK
					; R2 = MESSAGE BLOCK ADDRESS
	BLBC	R0,NOTIFY_DONE		; IF LBC, FAILURE
	MOVW	IRPE$L_MB_PORT(R5),-	; SET PORT NUMBER TO SEND TO
		PRQ$W_TO_PORT(R2)	;
	MOVW	#PRQ$C_MAILBOX,-	; SET MESSAGE DISPATCHER ID
		PRQ$W_DISPATCH(R2)	;
	MOVL	IRP$L_UCB(R3),R0	; GET UCB ADDRESS
	MOVW	UCB$W_UNIT(R0),-	; SET UNIT NUMBER
		PRQ$W_UNIT(R2)		;
	MOVW	IRPE$W_MB_RQTYP(R5),-	; SET REQUEST TYPE
		PRQ$W_REQTYPE(R2)	;
	MOVL	IRPE$L_MB_PARAM(R5),-	; SET PARAMETER
		PRQ$L_PARAM(R2)		;
	MOVB	#IPL$_MAILBOX,FKB$B_FIPL(R2) ; SET DISPATCH IPL
	JSB	@(SP)+			; RETURN TO PORT DRIVER FOR DELIVERY
	BLBC	R0,NOTIFY_DONE		; IF LBC, FAILURE
10$:
	SOBGEQ	IRPE$L_MB_PORT(R5),FORMAT_PRQ ; DECREMENT PORT # AND LOOP
	MOVL	#SS$_NORMAL,R0		; SET SUCCESS
;
; DONE WITH NOTIFICATION, DEALLOCATE THE FORK BLOCK
;
NOTIFY_DONE:				; DONE WITH NOTIFICATION
	PUSHL	R0			; SAVE EXIT STATUS
	MOVL	R5,R0			; SET ADDRESS OF BLOCK
	JSB	G^EXE$DEANONPAGED	; DEALLOCATE FORK BLOCK
	POPL	R0			; RESTORE EXIT STATUS
	RSB

	.SBTTL	ALLOC_IRPE - ALLOCATE AN I/O REQUEST PACKET EXTENSION
;++
; ALLOC_IRPE - SUBROUTINE TO ALLOCATE AN I/O REQUEST PACKET EXTENSION
;
; THIS ROUTINE IS CALLED TO ALLOCATE AN I/O REQUEST PACKET EXTENSION
; FOR LATER USE AS A FORK BLOCK.
;
; INPUTS:
;
;	R3 = I/O PACKET ADDRESS.
;
; OUTPUTS:
;
;	IRPE ALLOCATED FROM NON-PAGED POOL AND LINKED TO END
;	OF I/O PACKET (IRP$L_EXTEND).  IF ALLOCATION FAILS, ANY
;	PREVIOUSLY ALLOCATED IRPE IS DEALLOCATED AND THE
;	PROCESS IS PUT IN RESOURCE WAIT STATE TO AWAIT NON-PAGED POOL
;	AVAILABILITY.
;--
ALLOC_IRPE:				; ALLOCATE AN IRPE
	PUSHL	R3			; SAVE REGISTER
	MOVZWL	#IRP$K_LENGTH,R1	; SET SIZE OF BLOCK
	JSB	G^EXE$ALONONPAGED		; ALLOCATE BLOCK
	POPL	R3			; RESTORE REGISTER
	BLBC	R0,20$			; IF LBC FAILURE
	MOVW	R1,IRPE$W_SIZE(R2)	; SET SIZE IN BLOCK
	MOVB	#DYN$C_IRPE,IRPE$B_TYPE(R2) ; SET BLOCK TYPE IN BLOCK
	MOVL	IRP$L_EXTEND(R3),-	; SET NEXT IRPE ADDRESS IN BLOCK
		IRPE$L_EXTEND(R2)	;
	BEQL	10$			; IF EQL NONE
	BISW	#IRPE$M_EXTEND,IRPE$W_STS(R2) ; SET EXTENSION FLAG
10$:
	MOVL	R2,IRP$L_EXTEND(R3)	; SET IRPE ADDRESS IN IRP
	BISW	#IRP$M_EXTEND,IRP$W_STS(R3) ; SET EXTENSION FLAG
	CLRL	IRPE$L_SVAPTE1(R2)	; CLEAR SVAPTE SO I/O POST WILL
	CLRL	IRPE$L_SVAPTE2(R2)	;  JUST DEALLOCATE THE BLOCKS
	RSB				;
20$:
	ADDL	#4,SP			; REMOVE RETURN ADDRESS
	MOVZWL	#SS$_INSFMEM,-(SP)	; SET FAILURE STATUS
	MOVZWL	#RSN$_NPDYNMEM,R1	; SET RESOURCE TO AWAIT
	BRW	RES_WAIT		; WAIT FOR NON-PAGED POOL

	.SBTTL	DALLOC_IRPE - DEALLOCATE AN I/O REQUEST PACKET EXTENSION
;++
;
; DALLOC_IRPE - SUBROUTINE TO DEALLOCATE AN I/O REQUEST PACKET EXTENSION
;
; INPUTS:
;
;	R3 = I/O REQUEST PACKET ADDRESS.
;
; OUTPUTS:
;
;	THE I/O REQUEST PACKET EXTENSION IS DEALLOCATED TO NON-PAGED
;	POOL.
;
;	R1,R3,R5 ARE PRESERVED.
;
;--
DALLOC_IRPE:				; DEALLOCATE AN IRPE
	MOVL	IRP$L_EXTEND(R3),R0	; GET IRPE ADDRESS
	BEQL	20$			; BR IF NONE
	MOVL	IRPE$L_EXTEND(R0),-	; REMOVE IRPE FROM LIST
		IRP$L_EXTEND(R3)	;
	BNEQ	10$			; IF NEQ NOT LAST IRPE
	BICW	#IRP$M_EXTEND,IRP$W_STS(R3) ; CLEAR EXTEND FLAG
10$:
	PUSHR	#^M<R1,R3>		; SAVE REGISTERS
	JSB	G^EXE$DEANONPAGED	; DEALLOCATE IRPE
	POPR	#^M<R1,R3>		; RESTORE REGISTERS
20$:
	RSB				;
MB_END:
 	.END
