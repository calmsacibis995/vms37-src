	.TITLE	CRDRIVER - CR11 CARD READER DRIVER
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 1-SEP-77
;
;
;	V02-006	SRB0027		STEVE BECKHARDT		30-JUN-1981
;		FIXED UCBSIZE IN DPTAB MACRO TO USE SYMBOLIC NAME.
;
;	V05	SPF0001		STEVE FORGEY		27-JAN-1980
;	CHECK FOR MORE THAN 80 COL. OF DATA INPUT (HARDWARE ERROR).
;
; MACRO LIBRARY CALLS
;
 
	$CRBDEF				;DEFINE CRB OFFSETS
	$CRDEF				;DEFINE CARD READER STATUS BITS
	$DDBDEF				;DEFINE DDB OFFSETS
	$DPTDEF				;DEFINE DPT OFFSETS
	$IDBDEF				;DEFINE IDB OFFSETS
	$IODEF				;DEFINE I/O FUNCTION CODES
	$IRPDEF				;DEFINE IRP OFFSETS
	$JIBDEF				;DEFINE JIB OFFSETS
	$MSGDEF				;DEFINE SYSTEM MESSAGE TYPES
	$PCBDEF				;DEFINE PCB OFFSETS
	$UCBDEF				;DEFINE UCB OFFSETS
	$VECDEF				;DEFINE VEC OFFSETS
 
;
; LOCAL SYMBOLS
;
; ARGUMENT LIST OFFSET DEFINITIONS
;
 
P1=0					;FIRST FUNCTION DEPENDENT PARAMETER
P2=4					;SECOND FUNCTION DEPENDENT PARAMETER
P3=8					;THIRD FUNCTION DEPENDENT PARAMETER
P4=12					;FOURTH FUNCTION DEPENDENT PARAMETER
P5=16					;FIFTH FUNCTION DEPENDENT PARAMETER
P6=20					;SIZTH FUNCTION DEPENDENT PARAMETER
 
;
; SPECIAL CARD COLUMN PATTERNS
;
 
CR_EOF=^B111100001111			;END OF FILE (12-11-0-1-6-7-8-9)
CR_026=^B100010100010			;TRANSLATE 026 CARD CODE (12-2-4-8)
CR_029=^B101010101010			;TRANSLATE 029 CARD CODE (12-0-2-4-6-8)
 
;
; CR11 CONTROLLER REGISTER OFFSET DEFINITIONS
;
 
	$DEFINI	CR
 
$DEF	CR_CSR		.BLKW	1	;CONTROL STATUS REGISTER
	_VIELD	CR_CSR,0,<-		; CONTROL STATUS REGISTER FIELD DEFINITIONS
		<READ,,M>,-		; READ CARD
		<EJECT,,M>,-		; EJECT CARD
		<,4>,-			; RESERVED BITS
		<IE,,M>,-		; INTERRUPT ENABLE
		<CLDONE,,M>,-		; COLUMN DONE
		<OFFLIN,,M>,-		; READER OFFLINE
		<BUSY,,M>,-		; CARD BEING READ
		<ONLINE,,M>,-		; READER ONLINE
		<TIMERR,,M>,-		; TIMING ERROR
		<MCHECK,,M>,-		; MOTION CHECK
		<HCHECK,,M>,-		; HOPPER CHECK
		<CRDONE,,M>,-		; CARD DONE
		<ERROR,,M>,-		; ERROR CONDITION
		>			;
$DEF	CR_CRB1		.BLKW	1	;CARD READ DATA BUFFER 1 (BINARY)
$DEF	CR_CRB2		.BLKW	1	;CARD READ DATA BUFFER 2 (PACKED)
 
	$DEFEND	CR
 
;
; DEFINE DEVICE DEPENDENT UNIT CONTROL BLOCK OFFSETS
;
 
	$DEFINI	UCB
 
.=UCB$K_LENGTH				;
 
$DEF	UCB$B_CR_COLCNT	.BLKB	1	;CURRENT COLUMN COUNT
$DEF	UCB$B_CR_EOFCNT	.BLKB	1	;END OF FILE PUNCH COUNT
$DEF	UCB$B_CR_EOFCOL	.BLKB	1	;NUMBER OF END OF FILE PUNCHES REQUIRED
$DEF	UCB$B_CR_OFLCNT	.BLKB	1	;OFFLINE TIME COUNTER
$DEF	UCB$W_CR_FSTCOL	.BLKW	1	;FIRST COLUMN BINARY DATA
$DEF	UCB$W_CR_CSR	.BLKW	1	;SAVED FINAL CONTROL STATUS REGISTER
 
UCB$K_CR_LENGTH=.

	$DEFEND	UCB
 
;
; LOCAL DATA
;
; DRIVER PROLOGUE TABLE
;
 
	DPTAB	-			;DEFINE DRIVER PROLOGUE TABLE
		END=CR_END,-		;END OF DRIVER
		ADAPTER=UBA,-		;ADAPTER TYPE
		UCBSIZE=UCB$K_CR_LENGTH,-	;UCB SIZE
		NAME=CRDRIVER		;DRIVER NAME
	DPT_STORE INIT			;CONTROL BLOCK INIT VALUES
	DPT_STORE UCB,UCB$B_FIPL,B,8	;FORK IPL
	DPT_STORE UCB,UCB$L_DEVCHAR,L,-	;DEVICE CHARACTERISTICS
		<DEV$M_REC-		; RECORD ORIENTED
		!DEV$M_AVL-		; AVAILABLE
		!DEV$M_IDV>		; INPUT DEVICE
	DPT_STORE UCB,UCB$B_DEVCLASS,B,DC$_CARD ;DEVICE CLASS
	DPT_STORE UCB,UCB$B_DEVTYPE,B,DT$_CR11 ;DEVICE TYPE
	DPT_STORE UCB,UCB$W_DEVBUFSIZ,W,80 ;DEFAULT BUFFER SIZE
	DPT_STORE UCB,UCB$L_DEVDEPEND,L,CR$K_T029 ;DEFAULT TRANSLATION MODE
	DPT_STORE UCB,UCB$B_DIPL,B,22	;DEVICE IPL
	DPT_STORE REINIT		;CONTROL BLOCK RE-INIT VALUES
	DPT_STORE CRB,CRB$L_INTD+4,D,CR$INT ;INTERRUPT SERVICE ROUTINE ADDRESS
	DPT_STORE CRB,CRB$L_INTD+VEC$L_INITIAL,D,CR_INITIAL ;CONTROLLER INIT
	DPT_STORE CRB,CRB$L_INTD+VEC$L_UNITINIT,D,CR_CR11_INIT ;UNIT INIT
	DPT_STORE DDB,DDB$L_DDT,D,CR$DDT ;DDT ADDRESS
	DPT_STORE END			;
 
;
; DRIVER DISPATCH TABLE
;
 
	DDTAB	CR,-			;DRIVER DISPATCH TABLE
		CR_STARTIO,-		;START I/O OPERATION
		0,-			;UNSOLICITED INTERRUPT
		CR_FUNCTABLE,-		;FUNCTION DECISION TABLE
		CR_CANCELIO,-		;CANCEL I/O OPERATION
		0,-			;REGISTER DUMP ROUTINE
		0,-			;SIZE OF DIAGNOSTIC BUFFER
		0			;SIZE OF ERROR LOG BUFFER
 
;
; 029 CONVERSION TABLE
;
 
CR_CVT029:				;029 TRANSLATE TABLE
	.BYTE	^A/ /			;   0   ^X00   ^O000
	.BYTE	^A/1/			;   1   ^X01   ^O001
	.BYTE	^A/2/			;   2   ^X02   ^O002
	.BYTE	^A/3/			;   3   ^X03   ^O003
	.BYTE	^A/4/			;   4   ^X04   ^O004
	.BYTE	^A/5/			;   5   ^X05   ^O005
	.BYTE	^A/6/			;   6   ^X06   ^O006
	.BYTE	^A/7/			;   7   ^X07   ^O007
	.BYTE	^A/8/			;   8   ^X08   ^O010
	.BYTE	^A/`/			;   9   ^X09   ^O011
	.BYTE	^A/:/			;  10   ^X0A   ^O012
	.BYTE	^A/#/			;  11   ^X0B   ^O013
	.BYTE	^A/@/			;  12   ^X0C   ^O014
	.BYTE	^A/'/			;  13   ^X0D   ^O015
	.BYTE	^A/=/			;  14   ^X0E   ^O016
	.BYTE	^A/"/			;  15   ^X0F   ^O017
	.BYTE	^A/9/			;  16   ^X10   ^O020
	.BYTE	^A/\/			;  17   ^X11   ^O021
	.BYTE	^X16 			;  18   ^X12   ^O022
	.BYTE	^A/\/			;  19   ^X13   ^O023
	.BYTE	^A/\/			;  20   ^X14   ^O024
	.BYTE	^A/\/			;  21   ^X15   ^O025
	.BYTE	^A/\/			;  22   ^X16   ^O026
	.BYTE	^X04 			;  23   ^X17   ^O027
	.BYTE	^A/\/			;  24   ^X18   ^O030
	.BYTE	^A/\/			;  25   ^X19   ^O031
	.BYTE	^A/\/			;  26   ^X1A   ^O032
	.BYTE	^A/\/			;  27   ^X1B   ^O033
	.BYTE	^X14 			;  28   ^X1C   ^O034
	.BYTE	^X15 			;  29   ^X1D   ^O035
	.BYTE	^A/\/			;  30   ^X1E   ^O036
	.BYTE	^X1A 			;  31   ^X1F   ^O037
	.BYTE	^A/0/			;  32   ^X20   ^O040
	.BYTE	^A\/\			;  33   ^X21   ^O041
	.BYTE	^A/S/			;  34   ^X22   ^O042
	.BYTE	^A/T/			;  35   ^X23   ^O043
	.BYTE	^A/U/			;  36   ^X24   ^O044
	.BYTE	^A/V/			;  37   ^X25   ^O045
	.BYTE	^A/W/			;  38   ^X26   ^O046
	.BYTE	^A/X/			;  39   ^X27   ^O047
	.BYTE	^A/Y/			;  40   ^X28   ^O050
	.BYTE	^A/\/			;  41   ^X29   ^O051
	.BYTE	^A/\/			;  42   ^X2A   ^O052
	.BYTE	^A/,/			;  43   ^X2B   ^O053
	.BYTE	^A/%/			;  44   ^X2C   ^O054
	.BYTE	^A/_/			;  45   ^X2D   ^O055
	.BYTE	^A/>/			;  46   ^X2E   ^O056
	.BYTE	^A/?/			;  47   ^X2F   ^O057
	.BYTE	^A/Z/			;  48   ^X30   ^O060
	.BYTE	^A/\/			;  49   ^X31   ^O061
	.BYTE	^A/\/			;  50   ^X32   ^O062
	.BYTE	^A/\/			;  51   ^X33   ^O063
	.BYTE	^A/\/			;  52   ^X34   ^O064
	.BYTE	^X0A 			;  53   ^X35   ^O065
	.BYTE	^X17 			;  54   ^X36   ^O066
	.BYTE	^X1B 			;  55   ^X37   ^O067
	.BYTE	^A/\/			;  56   ^X38   ^O070
	.BYTE	^A/\/			;  57   ^X39   ^O071
	.BYTE	^A/\/			;  58   ^X3A   ^O072
	.BYTE	^A/\/			;  59   ^X3B   ^O073
	.BYTE	^A/\/			;  60   ^X3C   ^O074
	.BYTE	^X05 			;  61   ^X3D   ^O075
	.BYTE	^X06 			;  62   ^X3E   ^O076
	.BYTE	^X07 			;  63   ^X3F   ^O077
	.BYTE	^A/-/			;  64   ^X40   ^O100
	.BYTE	^A/J/			;  65   ^X41   ^O101
	.BYTE	^A/K/			;  66   ^X42   ^O102
	.BYTE	^A/L/			;  67   ^X43   ^O103
	.BYTE	^A/M/			;  68   ^X44   ^O104
	.BYTE	^A/N/			;  69   ^X45   ^O105
	.BYTE	^A/O/			;  70   ^X46   ^O106
	.BYTE	^A/P/			;  71   ^X47   ^O107
	.BYTE	^A/Q/			;  72   ^X48   ^O110
	.BYTE	^A/\/			;  73   ^X49   ^O111
	.BYTE	^A/]/			;  74   ^X4A   ^O112
	.BYTE	^A/$/			;  75   ^X4B   ^O113
	.BYTE	^A/*/			;  76   ^X4C   ^O114
	.BYTE	^A/)/			;  77   ^X4D   ^O115
	.BYTE	^A/;/			;  78   ^X4E   ^O116
	.BYTE	^A/^/			;  79   ^X4F   ^O117
	.BYTE	^A/R/			;  80   ^X50   ^O120
	.BYTE	^X11 			;  81   ^X51   ^O121
	.BYTE	^X12 			;  82   ^X52   ^O122
	.BYTE	^X13 			;  83   ^X53   ^O123
	.BYTE	^A/\/			;  84   ^X54   ^O124
	.BYTE	^A/\/			;  85   ^X55   ^O125
	.BYTE	^X08 			;  86   ^X56   ^O126
	.BYTE	^A/\/			;  87   ^X57   ^O127
	.BYTE	^X18 			;  88   ^X58   ^O130
	.BYTE	^X19 			;  89   ^X59   ^O131
	.BYTE	^A/\/			;  90   ^X5A   ^O132
	.BYTE	^A/\/			;  91   ^X5B   ^O133
	.BYTE	^X1C 			;  92   ^X5C   ^O134
	.BYTE	^X1D 			;  93   ^X5D   ^O135
	.BYTE	^X1E 			;  94   ^X5E   ^O136
	.BYTE	^X1F 			;  95   ^X5F   ^O137
	.BYTE	^A/}/			;  96   ^X60   ^O140
	.BYTE	^A/~/			;  97   ^X61   ^O141
	.BYTE	^A/s/			;  98   ^X62   ^O142
	.BYTE	^A/t/			;  99   ^X63   ^O143
	.BYTE	^A/u/			; 100   ^X64   ^O144
	.BYTE	^A/v/			; 101   ^X65   ^O145
	.BYTE	^A/w/			; 102   ^X66   ^O146
	.BYTE	^A/x/			; 103   ^X67   ^O147
	.BYTE	^A/y/			; 104   ^X68   ^O150
	.BYTE	^A/\/			; 105   ^X69   ^O151
	.BYTE	^A/\/			; 106   ^X6A   ^O152
	.BYTE	^A/\/			; 107   ^X6B   ^O153
	.BYTE	^A/\/			; 108   ^X6C   ^O154
	.BYTE	^A/\/			; 109   ^X6D   ^O155
	.BYTE	^A/\/			; 110   ^X6E   ^O156
	.BYTE	^A/\/			; 111   ^X6F   ^O157
	.BYTE	^A/z/			; 112   ^X70   ^O160
	.BYTE	^A/\/			; 113   ^X71   ^O161
	.BYTE	^A/\/			; 114   ^X72   ^O162
	.BYTE	^A/\/			; 115   ^X73   ^O163
	.BYTE	^A/\/			; 116   ^X74   ^O164
	.BYTE	^A/\/			; 117   ^X75   ^O165
	.BYTE	^A/\/			; 118   ^X76   ^O166
	.BYTE	^A/\/			; 119   ^X77   ^O167
	.BYTE	^A/\/			; 120   ^X78   ^O170
	.BYTE	^A/\/			; 121   ^X79   ^O171
	.BYTE	^A/\/			; 122   ^X7A   ^O172
	.BYTE	^A/\/			; 123   ^X7B   ^O173
	.BYTE	^A/\/			; 124   ^X7C   ^O174
	.BYTE	^A/\/			; 125   ^X7D   ^O175
	.BYTE	^A/\/			; 126   ^X7E   ^O176
	.BYTE	^A/\/			; 127   ^X7F   ^O177
	.BYTE	^A/&/			; 128   ^X80   ^O200
	.BYTE	^A/A/			; 129   ^X81   ^O201
	.BYTE	^A/B/			; 130   ^X82   ^O202
	.BYTE	^A/C/			; 131   ^X83   ^O203
	.BYTE	^A/D/			; 132   ^X84   ^O204
	.BYTE	^A/E/			; 133   ^X85   ^O205
	.BYTE	^A/F/			; 134   ^X86   ^O206
	.BYTE	^A/G/			; 135   ^X87   ^O207
	.BYTE	^A/H/			; 136   ^X88   ^O210
	.BYTE	^A/\/			; 137   ^X89   ^O211
	.BYTE	^A/[/			; 138   ^X8A   ^O212
	.BYTE	^A/./			; 139   ^X8B   ^O213
	.BYTE	^A/</			; 140   ^X8C   ^O214
	.BYTE	^A/(/			; 141   ^X8D   ^O215
	.BYTE	^A/+/			; 142   ^X8E   ^O216
	.BYTE	^A/!/			; 143   ^X8F   ^O217
	.BYTE	^A/I/			; 144   ^X90   ^O220
	.BYTE	^X01 			; 145   ^X91   ^O221
	.BYTE	^X02 			; 146   ^X92   ^O222
	.BYTE	^X03 			; 147   ^X93   ^O223
	.BYTE	^A/\/			; 148   ^X94   ^O224
	.BYTE	^X09 			; 149   ^X95   ^O225
	.BYTE	^A/\/			; 150   ^X96   ^O226
	.BYTE	^XFF 			; 151   ^X97   ^O227
	.BYTE	^A/\/			; 152   ^X98   ^O230
	.BYTE	^A/\/			; 153   ^X99   ^O231
	.BYTE	^A/\/			; 154   ^X9A   ^O232
	.BYTE	^X0B 			; 155   ^X9B   ^O233
	.BYTE	^X0C 			; 156   ^X9C   ^O234
	.BYTE	^X0D 			; 157   ^X9D   ^O235
	.BYTE	^X0E 			; 158   ^X9E   ^O236
	.BYTE	^X0F 			; 159   ^X9F   ^O237
	.BYTE	^A/{/			; 160   ^XA0   ^O240
	.BYTE	^A/a/			; 161   ^XA1   ^O241
	.BYTE	^A/b/			; 162   ^XA2   ^O242
	.BYTE	^A/c/			; 163   ^XA3   ^O243
	.BYTE	^A/d/			; 164   ^XA4   ^O244
	.BYTE	^A/e/			; 165   ^XA5   ^O245
	.BYTE	^A/f/			; 166   ^XA6   ^O246
	.BYTE	^A/g/			; 167   ^XA7   ^O247
	.BYTE	^A/h/			; 168   ^XA8   ^O250
	.BYTE	^A/\/			; 169   ^XA9   ^O251
	.BYTE	^A/\/			; 170   ^XAA   ^O252
	.BYTE	^A/\/			; 171   ^XAB   ^O253
	.BYTE	^A/\/			; 172   ^XAC   ^O254
	.BYTE	^A/\/			; 173   ^XAD   ^O255
	.BYTE	^A/\/			; 174   ^XAE   ^O256
	.BYTE	^A/\/			; 175   ^XAF   ^O257
	.BYTE	^A/i/			; 176   ^XB0   ^O260
	.BYTE	^A/\/			; 177   ^XB1   ^O261
	.BYTE	^A/\/			; 178   ^XB2   ^O262
	.BYTE	^A/\/			; 179   ^XB3   ^O263
	.BYTE	^A/\/			; 180   ^XB4   ^O264
	.BYTE	^A/\/			; 181   ^XB5   ^O265
	.BYTE	^A/\/			; 182   ^XB6   ^O266
	.BYTE	^A/\/			; 183   ^XB7   ^O267
	.BYTE	^A/\/			; 184   ^XB8   ^O270
	.BYTE	^A/\/			; 185   ^XB9   ^O271
	.BYTE	^A/\/			; 186   ^XBA   ^O272
	.BYTE	^A/\/			; 187   ^XBB   ^O273
	.BYTE	^A/\/			; 188   ^XBC   ^O274
	.BYTE	^A/\/			; 189   ^XBD   ^O275
	.BYTE	^A/\/			; 190   ^XBE   ^O276
	.BYTE	^A/\/			; 191   ^XBF   ^O277
	.BYTE	^A/|/			; 192   ^XC0   ^O300
	.BYTE	^A/j/			; 193   ^XC1   ^O301
	.BYTE	^A/k/			; 194   ^XC2   ^O302
	.BYTE	^A/l/			; 195   ^XC3   ^O303
	.BYTE	^A/m/			; 196   ^XC4   ^O304
	.BYTE	^A/n/			; 197   ^XC5   ^O305
	.BYTE	^A/o/			; 198   ^XC6   ^O306
	.BYTE	^A/p/			; 199   ^XC7   ^O307
	.BYTE	^A/q/			; 200   ^XC8   ^O310
	.BYTE	^A/\/			; 201   ^XC9   ^O311
	.BYTE	^A/\/			; 202   ^XCA   ^O312
	.BYTE	^A/\/			; 203   ^XCB   ^O313
	.BYTE	^A/\/			; 204   ^XCC   ^O314
	.BYTE	^A/\/			; 205   ^XCD   ^O315
	.BYTE	^A/\/			; 206   ^XCE   ^O316
	.BYTE	^A/\/			; 207   ^XCF   ^O317
	.BYTE	^A/r/			; 208   ^XD0   ^O320
	.BYTE	^A/\/			; 209   ^XD1   ^O321
	.BYTE	^A/\/			; 210   ^XD2   ^O322
	.BYTE	^A/\/			; 211   ^XD3   ^O323
	.BYTE	^A/\/			; 212   ^XD4   ^O324
	.BYTE	^A/\/			; 213   ^XD5   ^O325
	.BYTE	^A/\/			; 214   ^XD6   ^O326
	.BYTE	^A/\/			; 215   ^XD7   ^O327
	.BYTE	^A/\/			; 216   ^XD8   ^O330
	.BYTE	^X10 			; 217   ^XD9   ^O331
	.BYTE	^A/\/			; 218   ^XDA   ^O332
	.BYTE	^A/\/			; 219   ^XDB   ^O333
	.BYTE	^A/\/			; 220   ^XDC   ^O334
	.BYTE	^A/\/			; 221   ^XDD   ^O335
	.BYTE	^A/\/			; 222   ^XDE   ^O336
	.BYTE	^A/\/			; 223   ^XDF   ^O337
	.BYTE	^A/\/			; 224   ^XE0   ^O340
	.BYTE	^A/\/			; 225   ^XE1   ^O341
	.BYTE	^A/\/			; 226   ^XE2   ^O342
	.BYTE	^A/\/			; 227   ^XE3   ^O343
	.BYTE	^A/\/			; 228   ^XE4   ^O344
	.BYTE	^A/\/			; 229   ^XE5   ^O345
	.BYTE	^A/\/			; 230   ^XE6   ^O346
	.BYTE	^A/\/			; 231   ^XE7   ^O347
	.BYTE	^A/\/			; 232   ^XE8   ^O350
	.BYTE	^A/\/			; 233   ^XE9   ^O351
	.BYTE	^A/\/			; 234   ^XEA   ^O352
	.BYTE	^A/\/			; 235   ^XEB   ^O353
	.BYTE	^A/\/			; 236   ^XEC   ^O354
	.BYTE	^A/\/			; 237   ^XED   ^O355
	.BYTE	^A/\/			; 238   ^XEE   ^O356
	.BYTE	^A/\/			; 239   ^XEF   ^O357
	.BYTE	^A/\/			; 240   ^XF0   ^O360
	.BYTE	^A/\/			; 241   ^XF1   ^O361
	.BYTE	^A/\/			; 242   ^XF2   ^O362
	.BYTE	^A/\/			; 243   ^XF3   ^O363
	.BYTE	^A/\/			; 244   ^XF4   ^O364
	.BYTE	^A/\/			; 245   ^XF5   ^O365
	.BYTE	^A/\/			; 246   ^XF6   ^O366
	.BYTE	^A/\/			; 247   ^XF7   ^O367
	.BYTE	^A/\/			; 248   ^XF8   ^O370
	.BYTE	^A/\/			; 249   ^XF9   ^O371
	.BYTE	^A/\/			; 250   ^XFA   ^O372
	.BYTE	^A/\/			; 251   ^XFB   ^O373
	.BYTE	^A/\/			; 252   ^XFC   ^O374
	.BYTE	^A/\/			; 253   ^XFD   ^O375
	.BYTE	^A/\/			; 254   ^XFE   ^O376
	.BYTE	^A/\/			; 255   ^XFF   ^O377
 
;
; 026 CONVERSION TABLE
;
 
CR_CVT026:				;026 TRANSLATE TABLE
	.BYTE	^A/ /			;   0   ^X00   ^O000
	.BYTE	^A/1/			;   1   ^X01   ^O001
	.BYTE	^A/2/			;   2   ^X02   ^O002
	.BYTE	^A/3/			;   3   ^X03   ^O003
	.BYTE	^A/4/			;   4   ^X04   ^O004
	.BYTE	^A/5/			;   5   ^X05   ^O005
	.BYTE	^A/6/			;   6   ^X06   ^O006
	.BYTE	^A/7/			;   7   ^X07   ^O007
	.BYTE	^A/8/			;   8   ^X08   ^O010
	.BYTE	^A/`/			;   9   ^X09   ^O011
	.BYTE	^A/_/			;  10   ^X0A   ^O012
	.BYTE	^A/=/			;  11   ^X0B   ^O013
	.BYTE	^A/@/			;  12   ^X0C   ^O014
	.BYTE	^A/^/			;  13   ^X0D   ^O015
	.BYTE	^A/'/			;  14   ^X0E   ^O016
	.BYTE	^A/\/			;  15   ^X0F   ^O017
	.BYTE	^A/9/			;  16   ^X10   ^O020
	.BYTE	^A/\/			;  17   ^X11   ^O021
	.BYTE	^X16 			;  18   ^X12   ^O022
	.BYTE	^A/\/			;  19   ^X13   ^O023
	.BYTE	^A/\/			;  20   ^X14   ^O024
	.BYTE	^A/\/			;  21   ^X15   ^O025
	.BYTE	^A/\/			;  22   ^X16   ^O026
	.BYTE	^X04 			;  23   ^X17   ^O027
	.BYTE	^A/\/			;  24   ^X18   ^O030
	.BYTE	^A/\/			;  25   ^X19   ^O031
	.BYTE	^A/\/			;  26   ^X1A   ^O032
	.BYTE	^A/\/			;  27   ^X1B   ^O033
	.BYTE	^X14 			;  28   ^X1C   ^O034
	.BYTE	^X15 			;  29   ^X1D   ^O035
	.BYTE	^A/\/			;  30   ^X1E   ^O036
	.BYTE	^X1A 			;  31   ^X1F   ^O037
	.BYTE	^A/0/			;  32   ^X20   ^O040
	.BYTE	^A\/\			;  33   ^X21   ^O041
	.BYTE	^A/S/			;  34   ^X22   ^O042
	.BYTE	^A/T/			;  35   ^X23   ^O043
	.BYTE	^A/U/			;  36   ^X24   ^O044
	.BYTE	^A/V/			;  37   ^X25   ^O045
	.BYTE	^A/W/			;  38   ^X26   ^O046
	.BYTE	^A/X/			;  39   ^X27   ^O047
	.BYTE	^A/Y/			;  40   ^X28   ^O050
	.BYTE	^A/\/			;  41   ^X29   ^O051
	.BYTE	^A/;/			;  42   ^X2A   ^O052
	.BYTE	^A/,/			;  43   ^X2B   ^O053
	.BYTE	^A/(/			;  44   ^X2C   ^O054
	.BYTE	^A/"/			;  45   ^X2D   ^O055
	.BYTE	^A/#/			;  46   ^X2E   ^O056
	.BYTE	^A/%/			;  47   ^X2F   ^O057
	.BYTE	^A/Z/			;  48   ^X30   ^O060
	.BYTE	^A/\/			;  49   ^X31   ^O061
	.BYTE	^A/\/			;  50   ^X32   ^O062
	.BYTE	^A/\/			;  51   ^X33   ^O063
	.BYTE	^A/\/			;  52   ^X34   ^O064
	.BYTE	^X0A 			;  53   ^X35   ^O065
	.BYTE	^X17 			;  54   ^X36   ^O066
	.BYTE	^X1B 			;  55   ^X37   ^O067
	.BYTE	^A/\/			;  56   ^X38   ^O070
	.BYTE	^A/\/			;  57   ^X39   ^O071
	.BYTE	^A/\/			;  58   ^X3A   ^O072
	.BYTE	^A/\/			;  59   ^X3B   ^O073
	.BYTE	^A/\/			;  60   ^X3C   ^O074
	.BYTE	^X05 			;  61   ^X3D   ^O075
	.BYTE	^X06 			;  62   ^X3E   ^O076
	.BYTE	^X07 			;  63   ^X3F   ^O077
	.BYTE	^A/-/			;  64   ^X40   ^O100
	.BYTE	^A/J/			;  65   ^X41   ^O101
	.BYTE	^A/K/			;  66   ^X42   ^O102
	.BYTE	^A/L/			;  67   ^X43   ^O103
	.BYTE	^A/M/			;  68   ^X44   ^O104
	.BYTE	^A/N/			;  69   ^X45   ^O105
	.BYTE	^A/O/			;  70   ^X46   ^O106
	.BYTE	^A/P/			;  71   ^X47   ^O107
	.BYTE	^A/Q/			;  72   ^X48   ^O110
	.BYTE	^A/\/			;  73   ^X49   ^O111
	.BYTE	^A/:/			;  74   ^X4A   ^O112
	.BYTE	^A/$/			;  75   ^X4B   ^O113
	.BYTE	^A/*/			;  76   ^X4C   ^O114
	.BYTE	^A/[/			;  77   ^X4D   ^O115
	.BYTE	^A/>/			;  78   ^X4E   ^O116
	.BYTE	^A/&/			;  79   ^X4F   ^O117
	.BYTE	^A/R/			;  80   ^X50   ^O120
	.BYTE	^X11 			;  81   ^X51   ^O121
	.BYTE	^X12 			;  82   ^X52   ^O122
	.BYTE	^X13 			;  83   ^X53   ^O123
	.BYTE	^A/\/			;  84   ^X54   ^O124
	.BYTE	^A/\/			;  85   ^X55   ^O125
	.BYTE	^X08 			;  86   ^X56   ^O126
	.BYTE	^A/\/			;  87   ^X57   ^O127
	.BYTE	^X18 			;  88   ^X58   ^O130
	.BYTE	^X19 			;  89   ^X59   ^O131
	.BYTE	^A/\/			;  90   ^X5A   ^O132
	.BYTE	^A/\/			;  91   ^X5B   ^O133
	.BYTE	^X1C 			;  92   ^X5C   ^O134
	.BYTE	^X1D 			;  93   ^X5D   ^O135
	.BYTE	^X1E 			;  94   ^X5E   ^O136
	.BYTE	^X1F 			;  95   ^X5F   ^O137
	.BYTE	^A/}/			;  96   ^X60   ^O140
	.BYTE	^A/~/			;  97   ^X61   ^O141
	.BYTE	^A/s/			;  98   ^X62   ^O142
	.BYTE	^A/t/			;  99   ^X63   ^O143
	.BYTE	^A/u/			; 100   ^X64   ^O144
	.BYTE	^A/v/			; 101   ^X65   ^O145
	.BYTE	^A/w/			; 102   ^X66   ^O146
	.BYTE	^A/x/			; 103   ^X67   ^O147
	.BYTE	^A/y/			; 104   ^X68   ^O150
	.BYTE	^A/\/			; 105   ^X69   ^O151
	.BYTE	^A/\/			; 106   ^X6A   ^O152
	.BYTE	^A/\/			; 107   ^X6B   ^O153
	.BYTE	^A/\/			; 108   ^X6C   ^O154
	.BYTE	^A/\/			; 109   ^X6D   ^O155
	.BYTE	^A/\/			; 110   ^X6E   ^O156
	.BYTE	^A/\/			; 111   ^X6F   ^O157
	.BYTE	^A/z/			; 112   ^X70   ^O160
	.BYTE	^A/\/			; 113   ^X71   ^O161
	.BYTE	^A/\/			; 114   ^X72   ^O162
	.BYTE	^A/\/			; 115   ^X73   ^O163
	.BYTE	^A/\/			; 116   ^X74   ^O164
	.BYTE	^A/\/			; 117   ^X75   ^O165
	.BYTE	^A/\/			; 118   ^X76   ^O166
	.BYTE	^A/\/			; 119   ^X77   ^O167
	.BYTE	^A/\/			; 120   ^X78   ^O170
	.BYTE	^A/\/			; 121   ^X79   ^O171
	.BYTE	^A/\/			; 122   ^X7A   ^O172
	.BYTE	^A/\/			; 123   ^X7B   ^O173
	.BYTE	^A/\/			; 124   ^X7C   ^O174
	.BYTE	^A/\/			; 125   ^X7D   ^O175
	.BYTE	^A/\/			; 126   ^X7E   ^O176
	.BYTE	^A/\/			; 127   ^X7F   ^O177
	.BYTE	^A/+/			; 128   ^X80   ^O200
	.BYTE	^A/A/			; 129   ^X81   ^O201
	.BYTE	^A/B/			; 130   ^X82   ^O202
	.BYTE	^A/C/			; 131   ^X83   ^O203
	.BYTE	^A/D/			; 132   ^X84   ^O204
	.BYTE	^A/E/			; 133   ^X85   ^O205
	.BYTE	^A/F/			; 134   ^X86   ^O206
	.BYTE	^A/G/			; 135   ^X87   ^O207
	.BYTE	^A/H/			; 136   ^X88   ^O210
	.BYTE	^A/\/			; 137   ^X89   ^O211
	.BYTE	^A/?/			; 138   ^X8A   ^O212
	.BYTE	^A/./			; 139   ^X8B   ^O213
	.BYTE	^A/)/			; 140   ^X8C   ^O214
	.BYTE	^A/]/			; 141   ^X8D   ^O215
	.BYTE	^A/</			; 142   ^X8E   ^O216
	.BYTE	^A/!/			; 143   ^X8F   ^O217
	.BYTE	^A/I/			; 144   ^X90   ^O220
	.BYTE	^X01 			; 145   ^X91   ^O221
	.BYTE	^X02 			; 146   ^X92   ^O222
	.BYTE	^X03 			; 147   ^X93   ^O223
	.BYTE	^A/\/			; 148   ^X94   ^O224
	.BYTE	^X09 			; 149   ^X95   ^O225
	.BYTE	^A/\/			; 150   ^X96   ^O226
	.BYTE	^XFF 			; 151   ^X97   ^O227
	.BYTE	^A/\/			; 152   ^X98   ^O230
	.BYTE	^A/\/			; 153   ^X99   ^O231
	.BYTE	^A/\/			; 154   ^X9A   ^O232
	.BYTE	^X0B 			; 155   ^X9B   ^O233
	.BYTE	^X0C 			; 156   ^X9C   ^O234
	.BYTE	^X0D 			; 157   ^X9D   ^O235
	.BYTE	^X0E 			; 158   ^X9E   ^O236
	.BYTE	^X0F 			; 159   ^X9F   ^O237
	.BYTE	^A/{/			; 160   ^XA0   ^O240
	.BYTE	^A/a/			; 161   ^XA1   ^O241
	.BYTE	^A/b/			; 162   ^XA2   ^O242
	.BYTE	^A/c/			; 163   ^XA3   ^O243
	.BYTE	^A/d/			; 164   ^XA4   ^O244
	.BYTE	^A/e/			; 165   ^XA5   ^O245
	.BYTE	^A/f/			; 166   ^XA6   ^O246
	.BYTE	^A/g/			; 167   ^XA7   ^O247
	.BYTE	^A/h/			; 168   ^XA8   ^O250
	.BYTE	^A/\/			; 169   ^XA9   ^O251
	.BYTE	^A/\/			; 170   ^XAA   ^O252
	.BYTE	^A/\/			; 171   ^XAB   ^O253
	.BYTE	^A/\/			; 172   ^XAC   ^O254
	.BYTE	^A/\/			; 173   ^XAD   ^O255
	.BYTE	^A/\/			; 174   ^XAE   ^O256
	.BYTE	^A/\/			; 175   ^XAF   ^O257
	.BYTE	^A/i/			; 176   ^XB0   ^O260
	.BYTE	^A/\/			; 177   ^XB1   ^O261
	.BYTE	^A/\/			; 178   ^XB2   ^O262
	.BYTE	^A/\/			; 179   ^XB3   ^O263
	.BYTE	^A/\/			; 180   ^XB4   ^O264
	.BYTE	^A/\/			; 181   ^XB5   ^O265
	.BYTE	^A/\/			; 182   ^XB6   ^O266
	.BYTE	^A/\/			; 183   ^XB7   ^O267
	.BYTE	^A/\/			; 184   ^XB8   ^O270
	.BYTE	^A/\/			; 185   ^XB9   ^O271
	.BYTE	^A/\/			; 186   ^XBA   ^O272
	.BYTE	^A/\/			; 187   ^XBB   ^O273
	.BYTE	^A/\/			; 188   ^XBC   ^O274
	.BYTE	^A/\/			; 189   ^XBD   ^O275
	.BYTE	^A/\/			; 190   ^XBE   ^O276
	.BYTE	^A/\/			; 191   ^XBF   ^O277
	.BYTE	^A/|/			; 192   ^XC0   ^O300
	.BYTE	^A/j/			; 193   ^XC1   ^O301
	.BYTE	^A/k/			; 194   ^XC2   ^O302
	.BYTE	^A/l/			; 195   ^XC3   ^O303
	.BYTE	^A/m/			; 196   ^XC4   ^O304
	.BYTE	^A/n/			; 197   ^XC5   ^O305
	.BYTE	^A/o/			; 198   ^XC6   ^O306
	.BYTE	^A/p/			; 199   ^XC7   ^O307
	.BYTE	^A/q/			; 200   ^XC8   ^O310
	.BYTE	^A/\/			; 201   ^XC9   ^O311
	.BYTE	^A/\/			; 202   ^XCA   ^O312
	.BYTE	^A/\/			; 203   ^XCB   ^O313
	.BYTE	^A/\/			; 204   ^XCC   ^O314
	.BYTE	^A/\/			; 205   ^XCD   ^O315
	.BYTE	^A/\/			; 206   ^XCE   ^O316
	.BYTE	^A/\/			; 207   ^XCF   ^O317
	.BYTE	^A/r/			; 208   ^XD0   ^O320
	.BYTE	^A/\/			; 209   ^XD1   ^O321
	.BYTE	^A/\/			; 210   ^XD2   ^O322
	.BYTE	^A/\/			; 211   ^XD3   ^O323
	.BYTE	^A/\/			; 212   ^XD4   ^O324
	.BYTE	^A/\/			; 213   ^XD5   ^O325
	.BYTE	^A/\/			; 214   ^XD6   ^O326
	.BYTE	^A/\/			; 215   ^XD7   ^O327
	.BYTE	^A/\/			; 216   ^XD8   ^O330
	.BYTE	^X10 			; 217   ^XD9   ^O331
	.BYTE	^A/\/			; 218   ^XDA   ^O332
	.BYTE	^A/\/			; 219   ^XDB   ^O333
	.BYTE	^A/\/			; 220   ^XDC   ^O334
	.BYTE	^A/\/			; 221   ^XDD   ^O335
	.BYTE	^A/\/			; 222   ^XDE   ^O336
	.BYTE	^A/\/			; 223   ^XDF   ^O337
	.BYTE	^A/\/			; 224   ^XE0   ^O340
	.BYTE	^A/\/			; 225   ^XE1   ^O341
	.BYTE	^A/\/			; 226   ^XE2   ^O342
	.BYTE	^A/\/			; 227   ^XE3   ^O343
	.BYTE	^A/\/			; 228   ^XE4   ^O344
	.BYTE	^A/\/			; 229   ^XE5   ^O345
	.BYTE	^A/\/			; 230   ^XE6   ^O346
	.BYTE	^A/\/			; 231   ^XE7   ^O347
	.BYTE	^A/\/			; 232   ^XE8   ^O350
	.BYTE	^A/\/			; 233   ^XE9   ^O351
	.BYTE	^A/\/			; 234   ^XEA   ^O352
	.BYTE	^A/\/			; 235   ^XEB   ^O353
	.BYTE	^A/\/			; 236   ^XEC   ^O354
	.BYTE	^A/\/			; 237   ^XED   ^O355
	.BYTE	^A/\/			; 238   ^XEE   ^O356
	.BYTE	^A/\/			; 239   ^XEF   ^O357
	.BYTE	^A/\/			; 240   ^XF0   ^O360
	.BYTE	^A/\/			; 241   ^XF1   ^O361
	.BYTE	^A/\/			; 242   ^XF2   ^O362
	.BYTE	^A/\/			; 243   ^XF3   ^O363
	.BYTE	^A/\/			; 244   ^XF4   ^O364
	.BYTE	^A/\/			; 245   ^XF5   ^O365
	.BYTE	^A/\/			; 246   ^XF6   ^O366
	.BYTE	^A/\/			; 247   ^XF7   ^O367
	.BYTE	^A/\/			; 248   ^XF8   ^O370
	.BYTE	^A/\/			; 249   ^XF9   ^O371
	.BYTE	^A/\/			; 250   ^XFA   ^O372
	.BYTE	^A/\/			; 251   ^XFB   ^O373
	.BYTE	^A/\/			; 252   ^XFC   ^O374
	.BYTE	^A/\/			; 253   ^XFD   ^O375
	.BYTE	^A/\/			; 254   ^XFE   ^O376
	.BYTE	^A/\/			; 255   ^XFF   ^O377
	.PAGE
	.SBTTL	CR11 FUNCTION DECISION TABLE
;
; CR11 FUNCTION DECISION TABLE
;
 
CR_FUNCTABLE:				;FUNCTION DECISION TABLE
	FUNCTAB	,-			;LEGAL FUNCTION
		<READLBLK,-		;READ LOGICAL BLOCK
		 READPBLK,-		;READ PHYSICAL BLOCK
		 READVBLK,-		;READ VIRTUAL BLOCK
		 SENSEMODE,-		;SENSE READ MODE
		 SENSECHAR,-		;SENSE READER CHARACTERISTICS
		 SETMODE,-		;SET READER MODE
		 SETCHAR,-		;SET READER CHARACTERISTICS
		>			;
	FUNCTAB	,-			;BUFFERED I/O FUNCTIONS
		<READLBLK,-		;READ LOGICAL BLOCK
		 READPBLK,-		;READ PHYSICAL BLOCK
		 READVBLK,-		;READ VIRTUAL BLOCK
		 SENSEMODE,-		;SENSE READ MODE
		 SENSECHAR,-		;SENSE READER CHARACTERISTICS
		 SETMODE,-		;SET READER MODE
		 SETCHAR,-		;SET READER CHARACTERISTICS
		>			;
	FUNCTAB	CR_READ,-		;READ FUNCTIONS
		<READLBLK,-		;READ LOGICAL BLOCK
		 READPBLK,-		;READ PHYSICAL BLOCK
		 READVBLK,-		;READ VIRTUAL BLOCK
		>			;
	FUNCTAB	+EXE$SETMODE,-		;SET MODE/CHARACTERISTICS FUNCTIONS
		<SETCHAR,-		;SET READER CHARACTERISTICS
		 SETMODE,-		;SET READER MODE
		>			;
	FUNCTAB	+EXE$SENSEMODE,-	;SENSE MODE/CHARACTERISTICS FUNCTIONS
		<SENSECHAR,-		;SENSE READER CHARACTERISTICS
		 SENSEMODE,-		;SENSE READER MODE
		>			;
	.PAGE
	.SBTTL	CANCEL I/O ON CHANNEL
;+
; CR_CANCELIO - CANCEL I/O ON CHANNEL
;
; THIS ROUTINE IS CALLED WHEN THE LAST CHANNEL ASSIGNED TO A DEVICE IS DEASSIGNED,
; THE DEVICE IS DEALLOCATED, AND WHEN THE CANCEL I/O ON CHANNEL SYSTEM SERVICE IS
; EXECUTED.
;
; INPUTS:
;
;	R2 = NEGATIVE CHANNEL NUMBER.
;	R3 = ADDRESS OF CURRENT I/O REQUEST PACKET.
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R5 = DEVICE UCB ADDRESS.
;
; OUTPUTS:
;
;	THE DEVICE INDEPENDENT CANCEL I/O ROUTINE IS CALLED AND A CHECK IS MADE
;	TO SEE IF THE UCB REFERENCE COUNT IS ZERO. IF THE REFERENCE COUNT IS ZERO,
;	THEN THE MESSAGE SENT TO JOB CONTROLLER BIT IS CLEARED.
;-
 
CR_CANCELIO:				;CANCEL I/O ON CHANNEL
	TSTW	UCB$W_REFC(R5)		;REFERENCE COUNT ZERO?
	BNEQ	10$			;IF NEQ NO
	BICW	#UCB$M_JOB,UCB$W_DEVSTS(R5) ;CLEAR MESSAGE SENT BIT
10$:	JMP	G^IOC$CANCELIO		;CANCEL I/O ON CHANNEL
	.PAGE
	.SBTTL	READ FUNCTION PROCESSING
;+
; CR_READ - READ FUNCTION PROCESSING
;
; THIS ROUTINE IS CALLED FROM THE FUNCTION DECISION TABLE DISPATCHER TO PROCESS
; A READ LOGICAL, READ PHYSICAL, OR READ VIRTUAL FUNCTION TO A CARD READER.
;
; INPUTS:
;
;	R0 = SCRATCH.
;	R1 = SCRATCH.
;	R2 = SCRATCH.
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R5 = ASSIGNED DEVICE UCB ADDRESS.
;	R6 = ADDRESS OF CCB.
;	R7 = I/O FUNCTION CODE.
;	R8 = FUNCTION DECISION TABLE DISPATCH ADDRESS.
;	R9 = SCRATCH.
;	R10 = SCRATCH.
;	R11 = SCRATCH.
;	AP = ADDRESS OF FIRST FUNCTION DEPENDENT PARAMETER.
;
; OUTPUTS:
;
;	THE FUNCTION PARAMETERS ARE CHECKED AND A BUFFER IS ALLOCATED FOR THE
;	CARD READER DRIVER TO READ A CARD IMAGE INTO.
;-
 
CR_READ:				;READ FUNCTION PROCESSING
	MOVL	P1(AP),R0		;GET ADDRESS OF USER BUFFER
	MOVZWL	P2(AP),R1		;GET LENGTH OF USER BUFFER
	BEQL	30$			;IF EQL ZERO LENGTH TRANSFER
	JSB	G^EXE$READCHK		;CHECK ACCESSIBILITY OF USER BUFFER
	MOVW	R1,IRP$W_BCNT(R3)	;INSERT LENGTH OF USER BUFFER
	PUSHR	#^M<R0,R3>		;SAVE BUFFER AND I/O PACKET ADDRESSES
	MOVZBL	#80,R1			;SET LENGTH REQUIRED FOR ASCII READ
	BBC	#IO$V_BINARY,IRP$W_FUNC(R3),10$ ;IF CLR, ASCII READ
	MULL	#2,R1			;SET LENGTH REQUIRED FOR BINARY READ
10$:	CMPW	R1,IRP$W_BCNT(R3)	;LENGTH OF READ LARGER THAN USER BUFFER?
	BGEQU	20$			;IF GEQU YES
	MOVW	R1,IRP$W_BCNT(R3)	;SET LENGTH OF USER BUFFER TO SIZE OF READ
20$:	ADDL	#12,R1			;ACCOUNT FOR BUFFER OVERHEAD
	JSB	G^EXE$BUFFRQUOTA	;CHECK IF PROCESS HAS SUFFICIENT QUOTA
	BLBC	R0,40$			;IF LBC QUOTA CHECK FAILURE
	JSB	G^EXE$ALLOCBUF		;ALLOCATE BUFFER FOR CARD READ
	BLBC	R0,40$			;IF LBC ALLOCATION FAILURE
	POPR	#^M<R0,R3>		;RETRIEVE BUFFER AND I/O PACKET ADDRESSES
	MOVL	R2,IRP$L_SVAPTE(R3)	;INSERT ADDRESS OF READ BUFFER
	MOVW	R1,IRP$W_BOFF(R3)	;INSERT NUMBER OF QUOTA BYTES CHARGED
	PUSHL	R0			;SAVE BUFFER ADDRESS
	MOVL	PCB$L_JIB(R4),R0	;GET JIB ADDRESS
	SUBL	R1,JIB$L_BYTCNT(R0)	;CHARGE PROCESS FOR BUFFER
	POPL	R0			;RESTORE BUFFER ADDRESS
	MOVAB	12(R2),(R2)+		;INSERT ADDRESS OF DATA AREA
	MOVL	R0,(R2)			;SAVE ADDRESS OF USER BUFFER
	JMP	G^EXE$QIODRVPKT		;QUEUE DRIVER PACKET
 
;
; ZERO LENGTH TRANSFER
;
 
30$:	MOVZWL	#SS$_NORMAL,R0		;SET NORMAL COMPLETION STATUS
	JMP	G^EXE$FINISHIOC		;FINISH I/O
 
;
; QUOTA OR BUFFER ALLOCATION FAILURE
;
 
40$:	POPR	#^M<R2,R3>		;RETRIEVE I/O PACKET ADDRESS
	JMP	G^EXE$ABORTIO		;ABORT I/O OPERATION
	.PAGE
	.SBTTL	START I/O OPERATION ON CR11 CARD READER
;+
; CR_STARTIO - START I/O OPERATION ON CR11 CARD READER
;
; THIS ROUTINE IS ENTERED WHEN THE ASSOCIATED UNIT IS IDLE AND A PACKET IS
; AVAILABLE FOR PROCESSING.
;
; INPUTS:
;
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;	R5 = ADDRESS OF DEVICE UNIT UCB.
;
; OUTPUTS:
;
;	CARD MOTION IS STARTED BY SETTING THE APPROPRIATE FUNCTION BITS IN THE
;	CONTROL STATUS REGISTER. AS EACH COLUMN INTERRUPT OCCURS, THE DATA FROM
;	THE DATA BUFFER REGISTER(S) IS STORED IN THE BUFFER ALLOCATED BY THE
;	FDT ROUTINE. WHEN ALL 80 COLUMNS HAVE BEEN READ, A FORK PROCESS IS CREAT-
;	ED, THE COLUMN DATA IS CONVERTED ACCORDING TO THE I/O FUNCTION CODE, AND
;	REQUEST COMPLETE IS CALLED FOR POST PROCESSING.
;-
 
CR_STARTIO:				;START I/O OPERATION
	CMPZV	#IRP$V_FCODE,#IRP$S_FCODE,- ;SET MODE FUNCTION?
		IRP$W_FUNC(R3),#IO$_SETMODE ;
	BEQL	10$			;IF EQL YES
	CMPZV	#IRP$V_FCODE,#IRP$S_FCODE,- ;SET CHARACTERISTICS FUNCTION?
		IRP$W_FUNC(R3),#IO$_SETCHAR ;
	BNEQ	20$			;IF NEQ NO
 
;
; SET READER CHARACTERISTICS
;
 
	MOVW	IRP$L_MEDIA(R3),UCB$B_DEVCLASS(R5)    ;SET DEVICE CLASS AND TYPE
 
;
; SET READER MODE
;
 
10$:	MOVW	IRP$L_MEDIA+2(R3),UCB$W_DEVBUFSIZ(R5) ;SET DEFAULT BUFFER SIZE
	MOVL	IRP$L_MEDIA+4(R3),UCB$L_DEVDEPEND(R5) ;SET DEVICE DEPENDENT FLAGS
	BRW	140$			;
 
;
; SET UP PARAMETERS AND READ CARD
;
 
20$:	MOVL	@IRP$L_SVAPTE(R3),UCB$L_SVAPTE(R5) ;SET ADDRESS OF BUFFER
	MOVB	#1,UCB$B_CR_EOFCNT(R5)	;SET END OF FILE COUNT FOR ASCII
	BBC	#IO$V_BINARY,IRP$W_FUNC(R3),30$ ;IF CLR, ASCII READ
	MOVB	#8,UCB$B_CR_EOFCNT(R5)	;SET END OF FILE COUNT FOR BINARY
30$:	MOVB	UCB$B_CR_EOFCNT(R5),UCB$B_CR_EOFCOL(R5) ;SET REQUIRED NUMBER
	MNEGB	#1,UCB$B_CR_COLCNT(R5)	;SET INITIAL COLUMN COUNT
	CLRB	UCB$B_CR_OFLCNT(R5)	;SET INITIAL OFFLINE COUNT
	MOVL	UCB$L_CRB(R5),R4	;GET ADDRESS OF CRB
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R4 ;GET DEVICE CSR ADDRESS
40$:	DSBINT				;DISABLE INTERRUPTS
	BITW	#CR_CSR_M_OFFLIN,CR_CSR(R4) ;READER OFFLINE?
	BEQL	70$			;IF EQL NO
	WFIKPCH	50$,#2			;WAIT FOR TIMEOUT
	IOFORK				;CREATE FORK PROCESS
	BRB	40$			;
 
;
; READER TIME OUT OR DEVICE ERROR
;
 
50$:	MOVZBW	#CR_CSR_M_IE,CR_CSR(R4)	;CLEAR READER ERRORS
	SETIPL	UCB$B_FIPL(R5)		;LOWER TO DEVICE FORK LEVEL
	BBS	#UCB$V_CANCEL,UCB$W_STS(R5),60$ ;IF SET, CANCEL I/O REQUESTED
	ACBB	#15,#1,UCB$B_CR_OFLCNT(R5),40$ ;IF SET, NOT TIME FOR MESSAGE
	CLRB	UCB$B_CR_OFLCNT(R5)	;CLEAR OFFLINE COUNT
	PUSHR	#^M<R3,R4>		;SAVE REGISTERS
	MOVZBL	#MSG$_DEVOFFLIN,R4	;SET DEVICE MESSAGE NUMBER
	MOVAB	G^SYS$GL_OPRMBX,R3	;GET ADDRESS OF OPERATOR MAILBOX
	JSB	G^EXE$SNDEVMSG		;SEND MESSAGE TO OPERATOR
	POPR	#^M<R3,R4>		;RESTORE REGISTERS
	BRB	40$			;
 
;
; CANCEL CURRENT READ REQUEST
;
 
60$:	MOVZWL	#SS$_ABORT,R0		;SET ABORT STATUS
	BRW	150$			;
;
; DATA OVERFLOW (MORE THAN 80 COL) DETECTED
;

65$:	MOVZBW	#CR_CSR_M_IE,CR_CSR(R4) ;INHIBIT READS
	IOFORK				;
	INCW	UCB$W_ERRCNT(R5)	;INCREMENT HARDWARE ERROR COUNT
	MOVZWL	#SS$_CTRLERR,R0		;RETURN HARDWARE ERROR STATUS
	BRW	150$ 			;

;
; INITIATE READ
;
 
70$:	TSTW	CR_CRB1(R4)		;CLEAR COLUMN BUFFER
	MOVZBW	#CR_CSR_M_IE!CR_CSR_M_READ,- ;ENABLE INTERRUPTS AND START READ
		CR_CSR(R4)		;
80$:	WFIKPCH	50$,#3			;WAITFOR INTERRUPT OR TIMEOUT
	BITW	#CR_CSR_M_CRDONE!CR_CSR_M_ERROR,CR_CSR(R4) ;CARD DONE OR ERROR?
	BNEQ	120$			;IF NEQ YES
	MOVW	CR_CRB1(R4),R1		;READ BINARY COLUMN
	MOVW	CR_CRB2(R4),R2		;READ PACKED COLUMN
	INCB	UCB$B_CR_COLCNT(R5)	;INCREMENT COLUMN COUNT
	BNEQ	90$			;IF NEQ NOT FIRST COLUMN
	MOVW	R1,UCB$W_CR_FSTCOL(R5)	;SAVE FIRST COLUMN BINARY DATA
90$:	CMPB	UCB$B_CR_EOFCOL(R5),UCB$B_CR_COLCNT(R5) ;PAST END OF FILE DATA?
	BLEQ	100$			;IF LEQ YES
	CMPW	#CR_EOF,R1		;END OF FILE PUNCH?
	BNEQ	100$			;IF NEQ NO
	DECB	UCB$B_CR_EOFCNT(R5)	;DECREMENT END OF FILE COUNT
100$:	CMPB	#80,UCB$B_CR_COLCNT(R5)	;DATA OVERFLOW (MORE THAN 80 COL) ?
	BLEQU	65$			;IF LEQU, YES
	MOVB	R2,@UCB$L_SVAPTE(R5)	;STORE PACKED COLUMN
	BBC	#IO$V_BINARY,IRP$W_FUNC(R3),110$ ;IF CLR, ASCII READ
	MOVW	R1,@UCB$L_SVAPTE(R5)	;STORE BINARY COLUMN
	INCL	UCB$L_SVAPTE(R5)	;UPDATE BUFFER ADDRESS
110$:	INCL	UCB$L_SVAPTE(R5)	;UPDATE BUFFER ADDRESS
	DSBINT				;DISABLE INTERRUPTS
	BRB	80$			;
 
;
; SPECIAL CONDITION
;
 
120$:	MOVW	CR_CSR(R4),UCB$W_CR_CSR(R5) ;SAVE READER STATUS
	MOVZBW	#CR_CSR_M_IE,CR_CSR(R4)	;CLEAR READER ERRORS
	IOFORK				;CREATE FORK PROCESS
	MOVZWL	#SS$_ENDOFFILE,R0	;ASSUME END OF FILE ENCOUNTERED
	TSTB	UCB$B_CR_EOFCNT(R5)	;END OF FILE?
	BEQL	150$			;IF EQL YES
	MOVZWL	#SS$_DATAOVERUN,R0	;ASSUME TIMING ERROR
	MOVZWL	UCB$W_CR_CSR(R5),R1	;GET READER STATUS
	BBS	#CR_CSR_V_TIMERR,R1,150$ ;IF SET, TIMING ERROR - EXIT
	BBS	#CR_CSR_V_MCHECK,R1,180$ ;IF SET, MOTION CHECK - RETRY
;
;*** NOTE: SINCE HOPPER CHECK SETS ERROR, A READ CHECK IS NOT DETECTABLE
;*** IF HOPPER CHECK IS ALSO SET, IE. NO READ CHECK RETRIES ON LAST CARD
;
	BBS	#CR_CSR_V_HCHECK,R1,125$ ;IF SET, HOPPER CHECK - OK
	BBS	#CR_CSR_V_ERROR,R1,180$	 ;IF SET, READ CHECK - RETRY
125$:
	BITW	#IO$M_BINARY!IO$M_PACKED,IRP$W_FUNC(R3) ;BINARY OR PACKED READ?
	BNEQ	140$			;IF NEQ YES
	CMPW	#CR_029,UCB$W_CR_FSTCOL(R5) ;CHANGE MODE TO 029 TRANSLATION?
	BEQL	160$			;IF EQL YES
	CMPW	#CR_026,UCB$W_CR_FSTCOL(R5) ;CHANGE MODE TO 026 TRANSLATION?
	BEQL	170$			;IF EQL YES
	MOVAB	CR_CVT029,R0		;GET ADDRESS OF 029 TRANSLATION TABLE
	CMPZV	#CR$V_TMODE,#CR$S_TMODE,- ;029 TRANSLATION MODE?
		UCB$L_DEVDEPEND(R5),#CR$K_T029 ;
	BEQL	130$			;IF EQL YES
	MOVAB	CR_CVT026,R0		;GET ADDRESS OF 026 TRANSLATION TABLE
130$:	PUSHL	R5			;SAVE ADDRESS OF UCB
	MOVL	@IRP$L_SVAPTE(R3),R1	;GET ADDRESS OF I/O BUFFER
	MOVTC	IRP$W_BCNT(R3),(R1),#0,(R0),IRP$W_BCNT(R3),(R1) ;TRANSLATE
	POPL	R5			;RETRIEVE ADDRESS OF UCB
140$:	MOVZWL	#SS$_NORMAL,R0		;SET NORMAL COMPLETION
	INSV	UCB$W_BCNT(R5),#16,#16,R0 ;INSERT TRANSFER BYTE COUNT
150$:	CLRL	R1			;CLEAR SECOND I/O LONGWORD
	REQCOM				;COMPLETE REQUEST
 
;
; SET 029 TRANSLATION MODE
;
 
160$:	INSV	#CR$K_T029,#CR$V_TMODE,- ;SET 029 TRANSLATION MODE
		#CR$S_TMODE,UCB$L_DEVDEPEND(R5) ;
	BRB	180$			;
 
;
; SET 026 TRANSLATION MODE
;
 
170$:	INSV	#CR$K_T026,#CR$V_TMODE,- ;SET 026 TRANSLATION MODE
		#CR$S_TMODE,UCB$L_DEVDEPEND(R5) ;
180$:	BRW	20$			;
	.PAGE
	.SBTTL	CR11 CARD READER INTDERRUPTS
;+
; CR$INT - CR11 CARD READER INTERRUPTS
;
; THIS ROUTINE IS ENTERED VIA A JSB INSTRUCTION WHEN AN INTERRUPT OCCURS ON A
; CR11 CARD READER CONTROLLER. THE STATE OF THE STACK ON ENTRY IS:
;
;	00(SP) = ADDRESS OF IDB ADDRESS.
;	04(SP) - 24(SP) = SAVED R0 - R5.
;	28(SP) = INTERRUPT PC.
;	32(SP) = INTERRUPT PSL.
;
; INTERRUPT DISPATCHING OCCURS AS FOLLOWS:
;
;	IF THE INTERRUPT IS EXPECTED, THE DRIVER IS CALLED AT ITS
;	INTERRUPT RETURN ADDRESS (UCB$L_FPC).  IF THE INTERRUPT IS
;	NOT EXPECTED AND THE DEVICE IS NOT ALLOCATED, A MESSAGE IS
;	SENT TO THE JOB CONTROLLER TO INFORM IT THAT AN INPUT
;	SYMBIONT PROCESS SHOULD BE CREATED TO READ THE CARDS.
;-
 
CR$INT::				;CARD READER INTERRUPT
	MOVL	@(SP)+,R3		;GET ADDRESS OF IDB
	MOVQ	IDB$L_CSR(R3),R4	;GET CONTROLLER CSR AND OWNER UCB ADDRESS
	BBCC	#UCB$V_INT,UCB$W_STS(R5),10$ ;IF CLR, INTERRUPT NOT EXPECTED
	MOVL	UCB$L_FR3(R5),R3	;RESTORE REMAINING DRIVER CONTEXT
	JSB	@UCB$L_FPC(R5)		;CALL DRIVER
	MOVQ	(SP)+,R0		;RESTORE REGISTERS
	MOVQ	(SP)+,R2		;
	MOVQ	(SP)+,R4		;
	REI				;
 
;
; UNSOLICITED INTERRUPT
;
 
10$:	MOVZWL	CR_CSR(R4),R0		;GET READER STATUS
	MOVZBW	#CR_CSR_M_IE,CR_CSR(R4)	;CLEAR STATUS, ENABLE INTERRUPTS
	BITW	#CR_CSR_M_ONLINE,R0	;READER TRANSITION TO ONLINE?
	BEQL	20$			;IF EQL NO
	TSTW	UCB$W_REFC(R5)		;DEVICE ASSIGNED OR ALLOCATED?
	BNEQ	20$			;IF NEQ YES
	BBSS	#UCB$V_JOB,UCB$W_DEVSTS(R5),20$ ;IF SET, MESSAGE ALREADY SENT
	BSBB	30$			;SEND MESSAGE TO JOB CONTROLLER
20$:	MOVQ	(SP)+,R0		;RESTORE REGISTERS
	MOVQ	(SP)+,R2		;
	MOVQ	(SP)+,R4		;
	REI				;
30$:	JSB	G^EXE$FORK		;CREATE FORK PROCESS
	MOVZBL	#MSG$_CRUNSOLIC,R4	;SET MESSAGE TYPE
	MOVAB	G^SYS$GL_JOBCTLMB,R3	;SET ADDRESS OF JOB CONTROLLER MAILBOX
	JSB	G^EXE$SNDEVMSG		;SENT MESSAGE TO JOB CONTROLLER
	BLBS	R0,40$			;IF LBS SUCCESSFUL NOTIFICATION
	BICW	#UCB$M_JOB,UCB$W_DEVSTS(R5) ;CLEAR MESSAGE SENT BIT
40$:	RSB				;
	.PAGE
	.SBTTL	CARD READER INITIALIZATION
;+
; CR_INITIAL - CR11 CARD READER INITIALIZATION
;
; THIS ROUTINE IS CALLED AT SYSTEM STARTUP AND AFTER A POWER FAILURE. THE CSR
; ADDRESS OF THE RESPECTIVE CR11 CONTROLLER IS READ TO INSURE ITS PRESENCE ON
; THE UBA AND THEN CARD READER INTERRUPTS ARE ENABLED.
;
; INPUTS:
;
;	R4 = CR11 CONTROLLER CSR ADDRESS.
;	R5 = IDB ADDRESS OF DEVICE UNIT.
;
; OUTPUTS:
;
;	ALL REGISTERS ARE PRESERVED.
;-
 
CR_INITIAL:				;CR11 INITIALIZATION
	MOVZBW	#CR_CSR_M_IE,CR_CSR(R4)	;ENABLE CR11 INTERRUPTS
	RSB				;
	.PAGE
	.SBTTL	CARD READER UNIT INITIALIZATION
;+
; CR_CR11_INIT - CARD READER UNIT INITIALIZATION
;
; THIS ROUTINE IS CALLED AT SYSTEM STARTUP AND AFTER A POWER FAILURE. THE
; ONLINE BIT IS SET IN THE DEVICE UCB.
;
; INPUTS:
;
;	R5 = ADDRESS OF DEVICE UCB.
;
; OUTPUTS:
;
;	THE ONLINE BIT IS SET IN THE DEVICE UCB AND THE ADDRESS OF THE UCB
;	IS FILLED INTO THE OWNER FIELD OF THE IDB.
;-
 
CR_CR11_INIT:				;CARD READER UNIT INITIALIZATION
	BISW	#UCB$M_ONLINE,UCB$W_STS(R5) ;SET UNIT ONLINE
	MOVL	UCB$L_CRB(R5),R0	;GET ADDRESS OF CRB
	MOVL	CRB$L_INTD+VEC$L_IDB(R0),R0 ;GET ADDRESS OF IDB
	MOVL	R5,IDB$L_OWNER(R0)	;SET ADDRESS OF DEVICE UCB
	RSB				;
CR_END:					;ADDRESS OF LAST LOCATION IN DRIVER
 
	.END
