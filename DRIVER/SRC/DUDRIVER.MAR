	.TITLE	DUDRIVER - DISK CLASS DRIVER
	.IDENT	'V03-027'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; Robert Rappaport  11-May-1981
;
;  DISK CLASS DRIVER
;
; MODIFIED BY
;
;		Don't save CDDB ptr on stack before DISCONNECT, which
;		is now asynchronous, but rather recalculate R3 => CDDB
;		after return from DISCONNECT.
;
;	V03-026	RLRV3A19	Robert L. Rappaport	21-Apr-1982
;		Add branched around JSB G^INI$BRK to aid in Colorado
;		debugging.
;
;	V03-025	RLRV3A18	Robert L. Rappaport	16-Apr-1982
;		Removed use of CDDB$W_RSTRTCNT to determine when
;		restarting was finished.  Instead continue until
;		queue is empty.
;
;	V03-024	RLRV3A17	Robert L. Rappaport	16-Apr-1982
;		Return from controller init immediately if called from
;		POWERFAIL.
;
;	V03-023	RLRV3A16	Robert L. Rappaport	15-Apr-1982
;		1. Log Access Path attention Messages.
;		2. Use controller returned Controller timeout value for
;			periodic "delta" to awaken DU$TMR.
;		3. Use zero (i.e. infinite) host timeout for dedicated
;			controllers.
;
;	V03-022	RLRV3A15	Robert L. Rappaport	13-Apr-1982
;		Recode RE-CONNECTION logic to use changed SCS routines.
;
;	V03-021	RLRV3A14	Robert L. Rappaport	12-Apr-1982
;		Handle MSCP Invalid Command End messages.
;
;	V03-020	RLRV3A13	Robert L. Rappaport	12-Apr-1982
;		Change interpretation of PHYS_IO (read only) to be that
;		this operation implies a read of an RCT block and that
;		CDRP$L_MEDIA contains the LBN of the RCT block desired.
;
;	V03-019	RLRV3A12	Robert L. Rappaport	6-Apr-1982
;		Send Duplicate Unit Number opcom message for various commands
;		if a duplicate unit number is observed.
;
;	V03-018	RLRV3A11	Robert L. Rappaport	6-Apr-1982
;		Log Attention messages.
;
;	V03-017	RLRV3A10	Robert L. Rappaport	5-Apr-1982
;		Added setting of DEV$M_RCT in UCB$L_DEVCHAR and also
;		added support for Duplicate Unit Number attention messages.
;
;	V03-016	RLRV3AF		Robert L. Rappaport	1-Apr-1982
;		Corrected bug introduced by previous fix.  Since
;		DEALLOC_RESOURCES is now called also from TRANSFER_REPLACE,
;		the clearing of the CDRP$M_ERLOGIP bit must not be done when
;		we call from TRANSFER_REPLACE.  To correct this a new
;		entrypoint to DEALLOC_RESOURCES, RECYCLE_RESOURCES has
;		been added that does all that DEALLOC_RESOURCES does except
;		the clearing of the bit.
;
;	V03-015	RLRV3AE		Robert L. Rappaport	31-Mar-1982
;		Corrected two esoteric bugs introduced by repeat use of
;		RSPID for all I/O associated with one user request.
;		1.  This fouls up the timeout mechanism because now
;			the same apparent command is outstanding for
;			a long time.  Solution is to have Input
;			Dispatch Routine compare the incoming Command
;			Reference Number (RSPID) on a received End
;			Message to the CDDB$L_OLDRSPID and if equal,
;			to zero out CDDB$L_OLDRSPID.  In this way,
;			unless a command using a repeated RSPID really
;			times out, the TMR will not inadvertently think
;			it has timed out.
;		2.  In DEALLOC_RESOURCES, we must clear CDRP$M_ERLOGIP
;			or else, we will not allocate a new RSPID to the
;			restarted request and it will then have a zero
;			RSPID.
;
;	V03-014	RLRV3AD		Robert L. Rappaport	31-Mar-1982
;		Replace uses of CDRP$L_ABCNT and CDRP$L_OBCNT in
;		READ_RCT_BLOCK, WRITE_RCT_BLOCK and BUILD_RCT_PACKET
;		with uses of new HIRT fields.
;
;	V03-013	RLRV3AB		Robert L. Rappaport	30-Mar-1982
;		Change strategy of bad block replacement to use the
;		same RSPID throughout the entire operation.  This
;		ensures that all errorlog messages generated have the
;		same Command Reference Number and that they can then
;		be corelated with the Log Status message.  This change
;		required extensive modifications.
;
;	V03-012	RLRV3AB		Robert L. Rappaport	30-Mar-1982
;		Enable Errorlog and Attention messages when we do
;		Set Controller Characteristics.
;
;	V03-011	RLRV3AA		Robert L. Rappaport	29-Mar-1982
;		Corrected bug that failed to release resources after
;		successful Bad Block Replacement and before retrying
;		original operation.
;
;	V03-010	RLRV3A9		Robert L. Rappaport	29-Mar-1982
;		Corrected bug in bad block replacement by changing
;		interface to WRITE_RCT_BLOCK so that the routine gets
;		the RCT sector relative number to write implicitly from
;		HIRT$W_PG0CNTNT[R0].
;
;	V03-009	RLRV3A9		Robert L. Rappaport	26-Mar-1979
;		Corrected a typo bug in RESTART_NEXT_CDRP, where
;		R1 had been inadvertantly used instead of R3.
;
;	V03-008	RLRV3A8		Robert L. Rappaport	25-Mar-1982
;		Corrected more bugs in automatic re-synchronization.
;		1. Try off CDDB$M_IMPEND in CDDB$W_STATUS in
;			RECONN_COMMON code.
;		2. Set R4 => PDT before BRWing to DU$RE_SYNCH.
;		3. Establish new timeout wakeup BEFORE sending Immediate
;			command.  In this way we can timeout Immediate
;			commands also.
;
;	V03-007	RLRV3A6		Robert L. Rappaport	25-Mar-1982
;		Corrected bug in GET_DEVTYPE.
;		Also reduced value of INIT_DG_COUNT to 2.
;
;	V03-006	RLRV3A5		Robert L. Rappaport	25-Mar-1982
;		Corrected bug in automatic re-synchronization that
;		failed to preserve R3 => CDDB.
;	V03-005	RLRV3A4		Robert L. Rappaport	22-Mar-1982
;		Add support for setting UCB$B_DEVTYPE field.
;
;	V03-004	RLRV3A3		Robert L. Rappaport	22-Mar-1982
;		Added support for P6 buffers.
;
;	V03-003	RLRV3A2		Robert L. Rappaport	19-Mar-1982
;		Add code to support Disk Class driver automatic
;		re-synchronization with intelligent controller upon
;		timing out.
;
;	V03-002	RLRV3A1		Robert L. Rappaport	17-Mar-1982
;		Add code to recognize AVAILABLE ATTENTION message.
;
;	V03-001	RLRV3A0		Robert L. Rappaport	17-Mar-1982
;		Recode re-CONNECTION routine so as to use SCS routines.
;
;	V02-004	RLR0004		Robert L. Rappaport	1-Mar-1982
;		Introduce central ALLOC_POOL routine.
;
;	V02-003	RLR0003		Robert L. Rappaport	25-Feb-1982
;		Set UCB$B_DIPL in Template UCB to value DU_FORK_IPL.
;		Also initialize UCB$B_DIPL to this value for Boot UCB.
;
;	V02-002	RLR0002		Robert L. Rappaport	23-Feb-1982
;		Corrections for MOUNT VERIFICATION.
;
;	V02-001	RLR0001		Robert L. Rappaport	22-Feb-1982
;		Corrected two bugs each of which occurred twice.
;		First, after we are activated by the CRB wakeup mechanism
;		in INIT_HIRT, we must restore R3 => CDDB and R4 => PDT.
;		Second, in WRITE_RCT_BLOCK and READ_RCT_BLOCK, changed a
;		BLSS to BLSSU.
;
;		Also changed spelling of PDT$L_DGHDRSZ to PDT$L_DGOVRHD.
;
;
; MACRO LIBRARY CALLS
;

	$CDDBDEF			;Define CDDB offsets
	$CDRPDEF			;Define CDRP offsets
	$CDTDEF				;Define CDT offsets
	$CRBDEF				;Define CRB offsets
	$DDBDEF				;Define DDB offsets
	$DEVDEF				;Define DEVICE CHARACTERISTICS bits
	$DPTDEF				;Define DPT offsets
	$DYNDEF				;Define DYN symbols
	$EMBLTDEF			;Define EMB Log Message Types
	$FKBDEF				;Define FKB offsets
	$IDBDEF				;Define IDB offsets
	$IODEF				;Define I/O FUNCTION codes
	$IRPDEF				;Define IRP offsets
	$MSCPDEF			;Define MSCP packet offsets
	$PDTDEF				;Define PDT offsets
	$RCTDEF				;Define RCT offsets
	$RDDEF				;Define RDTE offsets
	$RDTDEF				;Define RDT offsets
	$UCBDEF				;Define UCB offsets
	$VECDEF				;Define INTERRUPT DISPATCH VECTOR offsets
	$WCBDEF				;Define WCB offsets


; Constants

DU_FORK_IPL=8			; Disk Class Driver fork IPL.
ALLOC_DELTA=1			; Number of seconds to wait to retry pool
				;  allocation that failed.
INIT_IMMED_DELTA=10		; During Controller Initialization, the
				;  timeout DELTA for immediate MSCP commands.
CONNECT_DELTA=10		; During Controller Initialization, the
				;  time interval for retrying failed
				;  CONNECT attempts.
HOST_TIMEOUT=30			; Host timeout value.

DISCONNECT_REASON=1
INITIAL_CREDIT=10
INITIAL_DG_COUNT=2
MAX_RETRY=5
MIN_SEND_CREDIT=2

TEST_PATTERN=^xB6DBCB6D				; Pattern to write on bad blocks.

CDRP$M_ERLOGIP=IRP$M_TERMIO		; Re-use UCB$W_STS bit in a compatible
CDRP$V_ERLOGIP=IRP$V_TERMIO		;  manner.
	.PAGE
	.SBTTL	MACRO DEFINITIONS

	.MACRO	RECYCL_RSPID	?L1
	MOVL	G^SCS$GL_RDT,R0		; R0 => RDT.
	MOVZWL	CDRP$L_RSPID(R5),R1	; R1 = index of RDT entry.
	MOVAQ	(R0)[R1],R1		; R1 => RDT entry.
L1:
	INCW	RD$W_SEQNUM(R1)		; Increment sequence number.
	MOVW	RD$W_SEQNUM(R1),-	; And move new sequence number to
		CDRP$L_RSPID+2(R5)	;  CDRP field.
	BEQL	L1			; If the incrementation produced zero,
					;  branch back for another bump.
	.ENDM	RECYCL_RSPID

	.MACRO	ALT_REQCOM
	JMP	G^IOC$ALTREQCOM
	.ENDM	ALT_REQCOM

	.MACRO	HIRT_SUBSAVE		; Save return on HIRT substack.
	POPL	@HIRT$L_STKPTR		; Pop return from stack onto substack.
	ADDL	#4,HIRT$L_STKPTR	; Bump substack pointer.
	.ENDM	HIRT_SUBSAVE

	.MACRO	HIRT_SUBUNSAVE		; Pop top of SUBSTACK and push onto stack.
	SUBL	#4,HIRT$L_STKPTR	; Pop substack.
	PUSHL	@HIRT$L_STKPTR		; Put top of substack onto top of stack.
	.ENDM	HIRT_SUBUNSAVE

	.MACRO	HIRT_SUBRETURN		; HIRT_SUBUNSAVE and return to caller.
	HIRT_SUBUNSAVE
	RSB				; Return to subroutine caller.
	.ENDM	HIRT_SUBRETURN

	$DEFINI	ATE			; Action Table Entry layout.

$DEF	ATE_OFFSET	.BLKW	1	; Offset of program code to JMP to.
					;  NOTE this must be first field so
					;   the address of this field is the
					;   address of the entry (ATE).
$DEF	ATE_MSCPCODE	.BLKW	1	; Value of major MSCP status code.

$DEF	ATE_SSCODE	.BLKW	1	; Value of corresponding SS$_ code.

ATE_ENTRY_LEN=.

	$DEFEND	ATE

	.MACRO	ACTION_ENTRY	MSCP_CODE,SS_CODE,ACTION_ROUTINE

	.if	NB	MSCP_CODE
		.WORD	ACTION_ROUTINE-.+ATE_OFFSET	; Offset of action routine.
		.WORD	MSCP_CODE
		.WORD	SS_CODE
	.iff
		.WORD	0			; Mark end of action table.
	.endc
	.ENDM	ACTION_ENTRY
	.PAGE
;
; Expanded opcode macros - Branch word conditional psuedo opcodes.
;

;
; BWNEQ - Branch (word offset) not equal
;

	.MACRO	BWNEQ	DEST,?L1
	BEQL	L1		; Branch around if NOT NEQ.
	BRW	DEST		; Branch to destination if NEQ.
L1:				; Around.
	.ENDM	BWNEQ
	.PAGE
	.SBTTL	ASSUMES

; The following set of ASSUME statements will all be true as long as
;	the IRP and CDRP definitions remain consistent.

	ASSUME	CDRP$L_IOQFL-CDRP$L_IOQFL	EQ	IRP$L_IOQFL
	ASSUME	CDRP$L_IOQBL-CDRP$L_IOQFL	EQ	IRP$L_IOQBL
	ASSUME	CDRP$W_IRP_SIZE-CDRP$L_IOQFL	EQ	IRP$W_SIZE
	ASSUME	CDRP$B_IRP_TYPE-CDRP$L_IOQFL	EQ	IRP$B_TYPE
	ASSUME	CDRP$B_RMOD-CDRP$L_IOQFL	EQ	IRP$B_RMOD
	ASSUME	CDRP$L_PID-CDRP$L_IOQFL		EQ	IRP$L_PID
	ASSUME	CDRP$L_AST-CDRP$L_IOQFL		EQ	IRP$L_AST
	ASSUME	CDRP$L_ASTPRM-CDRP$L_IOQFL	EQ	IRP$L_ASTPRM
	ASSUME	CDRP$L_WIND-CDRP$L_IOQFL	EQ	IRP$L_WIND
	ASSUME	CDRP$L_UCB-CDRP$L_IOQFL		EQ	IRP$L_UCB
	ASSUME	CDRP$W_FUNC-CDRP$L_IOQFL	EQ	IRP$W_FUNC
	ASSUME	CDRP$B_EFN-CDRP$L_IOQFL		EQ	IRP$B_EFN
	ASSUME	CDRP$B_PRI-CDRP$L_IOQFL		EQ	IRP$B_PRI
	ASSUME	CDRP$L_IOSB-CDRP$L_IOQFL	EQ	IRP$L_IOSB
	ASSUME	CDRP$W_CHAN-CDRP$L_IOQFL	EQ	IRP$W_CHAN
	ASSUME	CDRP$W_STS-CDRP$L_IOQFL		EQ	IRP$W_STS
	ASSUME	CDRP$L_SVAPTE-CDRP$L_IOQFL	EQ	IRP$L_SVAPTE
	ASSUME	CDRP$W_BOFF-CDRP$L_IOQFL	EQ	IRP$W_BOFF
	ASSUME	CDRP$L_BCNT-CDRP$L_IOQFL	EQ	IRP$L_BCNT
	ASSUME	CDRP$W_BCNT-CDRP$L_IOQFL	EQ	IRP$W_BCNT
	ASSUME	CDRP$L_IOST1-CDRP$L_IOQFL	EQ	IRP$L_IOST1
	ASSUME	CDRP$L_MEDIA-CDRP$L_IOQFL	EQ	IRP$L_MEDIA
	ASSUME	CDRP$L_IOST2-CDRP$L_IOQFL	EQ	IRP$L_IOST2
	ASSUME	CDRP$L_TT_TERM-CDRP$L_IOQFL	EQ	IRP$L_TT_TERM
	ASSUME	CDRP$B_CARCON-CDRP$L_IOQFL	EQ	IRP$B_CARCON
	ASSUME	CDRP$Q_NT_PRVMSK-CDRP$L_IOQFL	EQ	IRP$Q_NT_PRVMSK
	ASSUME	CDRP$L_ABCNT-CDRP$L_IOQFL	EQ	IRP$L_ABCNT
	ASSUME	CDRP$W_ABCNT-CDRP$L_IOQFL	EQ	IRP$W_ABCNT
	ASSUME	CDRP$L_OBCNT-CDRP$L_IOQFL	EQ	IRP$L_OBCNT
	ASSUME	CDRP$W_OBCNT-CDRP$L_IOQFL	EQ	IRP$W_OBCNT
	ASSUME	CDRP$L_SEGVBN-CDRP$L_IOQFL	EQ	IRP$L_SEGVBN
	ASSUME	CDRP$L_JNL_SEQNO-CDRP$L_IOQFL	EQ	IRP$L_JNL_SEQNO
	ASSUME	CDRP$L_DIAGBUF-CDRP$L_IOQFL	EQ	IRP$L_DIAGBUF
	ASSUME	CDRP$L_SEQNUM-CDRP$L_IOQFL	EQ	IRP$L_SEQNUM
	ASSUME	CDRP$L_EXTEND-CDRP$L_IOQFL	EQ	IRP$L_EXTEND
	ASSUME	CDRP$L_ARB-CDRP$L_IOQFL		EQ	IRP$L_ARB
	.PAGE
	.SBTTL	DISK CLASS DRIVER DEVICE DEPENDENT UNIT CONTROL BLOCK OFFSETS

	$DEFINI	UCB,GLOBAL


.=UCB$W_BCR+2				;

$DEF	UCB$Q_DU_UNIT_ID		; Unit ID as returned in ONLINE
			.BLKQ	1	;  end packet.
$DEF	UCB$L_DU_MEDIAID		; Media ID as returned in ONLINE end
			.BLKL	1	;  packet.
$DEF	UCB$L_DU_VOLSER	.BLKL	1	; Volume Serial number as returned
					;  in ONLINE end packet.
$DEF	UCB$L_DU_CDDB	.BLKL	1	; Pointer to Class Driver Data Block
					;  associated with controller (CRB).
$DEF	UCB$L_CDT	.BLKL	1	; Pointer to Connection Data Table.

$DEF	UCB$L_DU_MVIOQFL		;
			.BLKL	1	; List head where to relocate normal IOQ
$DEF	UCB$L_DU_MVIOQBL		;  during MOUNT VERIFICATION.
			.BLKL	1	;

$DEF	UCB$L_DU_DEV_PARM		; Device Dependent Parameters to be set
			.BLKL	1	;  in an ONLINE MSCP command packet.
$DEF	UCB$W_DU_UNT_FLGS		; Unit Flags to be set in an ONLINE
			.BLKW	1	;  MSCP command packet.
$DEF	UCB$W_DU_DEVSTS	.BLKW	1	; Class driver dependent status bits.

	$VIELD	UCB,0,<-
		<DU_MNTVERIP,,M>,-	; Mount verification in progress.
		>

$DEF	UCB$L_DU_USIZE	.BLKL	1	; Size of user visible area of unit
					;  in logical blocks.
$DEF	UCB$L_DU_TOTSZ	.BLKL	1	; Size of unit including RCT area in
					;  logical blocks.
$DEF	UCB$W_DU_RCTSIZE
			.BLKW	1	; Size of the RCT in blocks.
$DEF	UCB$B_DU_RCTCPYS
			.BLKB	1	; Number of RCT copies on the unit.
$DEF	UCB$B_DU_RBNPTRK
			.BLKB	1	; RBN's per track.
$DEF	UCB$L_DU_MEDIATYP
			.BLKL	1	; Media type.
$DEF	UCB$W_DU_LBNPTRK
			.BLKW	1	; LBN's per track.
$DEF	UCB$W_DU_TRKPGRP
			.BLKW	1	; Tracks per group.
$DEF	UCB$W_DU_GRPPCYL
			.BLKW	1	; Groups per cylinder.
			.BLKW	1	; Reserved word.

UCB$K_DU_LENGTH=.

	$DEFEND	UCB

	ASSUME	UCB$K_DU_LENGTH		LE	UCB$K_LENGTH+120

;
; If the preceeding ASSUME macro breaks it is a signal that the Disk Class
;	Driver UCB has grown larger than the space allocated to the Boot
;	Device UCB in [SYS.SRC]DEVICEDAT.MAR.  The Boot Device UCB allocated
;	in DEVICEDAT is 30 longwords longer than the nominal UCB (whose length
;	is known symbolically as UCB$K_LENGTH).  This additional length is
;	meant to accomodate all possible idiosyncracies that individual disk
;	drivers might have.  To correct such an overgrowth in UCB size entails
;	enlarging the expansion area in the Boot Device UCB (beyond the 30
;	longwords) and the relevant correction to the above ASSUME macro.
;
	.PAGE
;
; LOCAL DATA
;
; DRIVER PROLOGUE TABLE
;
 
	DPTAB	-			;DEFINE DRIVER PROLOGUE TABLE
		END=DU_END,-		; End of driver
		ADAPTER=NULL,-		; No Adapter
		FLAGS=DPT$M_SCS,-	;Driver requires SCS to be loaded
		UCBSIZE=UCB$K_DU_LENGTH,-;Sysgen insists on making a UCB
		MAXUNITS=1,-		 ;Sysgen insists on making a UCB
		NAME=DUDRIVER			; Driver name
	DPT_STORE INIT				; Control block init values
	DPT_STORE DDB,DDB$L_ACPD,L,<^A\F11\>	; Default ACP name
	DPT_STORE DDB,DDB$L_ACPD+3,B,1		; ACP class

	DPT_STORE UCB,UCB$B_FIPL,B,DU_FORK_IPL	;FORK IPL
	DPT_STORE UCB,UCB$B_DIPL,B,DU_FORK_IPL	;DEVICE IPL

	DPT_STORE CRB,CRB$L_INTD+VEC$L_INITIAL,D,-
			DU_CONTROLLER_INIT	; Controller Init Routine.

	DPT_STORE REINIT		;CONTROL BLOCK RE-INIT VALUES
	DPT_STORE DDB,DDB$L_DDT,D,DU$DDT ;DDT ADDRESS
	DPT_STORE END			;
 
;
; DRIVER DISPATCH TABLE
;
 
	DDTAB	DEVNAM=DU,-		;DRIVER DISPATCH TABLE
		START=DU_STARTIO,-	;START I/O OPERATION
		UNSOLIC=DU_UNSOLNT,-	;UNSOLICITED INTERRUPT
		FUNCTB=DU_FUNCTABLE,-	;FUNCTION DECISION TABLE
		CANCEL=0,-		;CANCEL I/O ENTRY POINT
		REGDMP=0,-		;REGISTER DUMP ROUTINE
		DIAGBF=MSCP$K_MXCMDLEN+MSCP$K_LEN+20,-	; DIAG BUFF SIZE
		ERLGBF=0,-		; ERLG BUFF SIZE
		UNITINIT=0,-		; No invokable unit initialization.
		ALTSTART=0,-		; Alternate Start I/O entry.
		MNTVER=DU_MOUNT_VEROUT	; Mount Verification routine.
	.PAGE
	.SBTTL	DISK CLASS DRIVER FUNCTION DECISION TABLE
;+
; DISK CLASS DRIVER FUNCTION DECISION TABLE
;-
 
DU_FUNCTABLE:				;Function Decision Table
	FUNCTAB	,-			; LEGAL FUNCTIONS
		<NOP,-			;  No operation
		UNLOAD,-		;  Unload (make available + spindown)
		AVAILABLE,-		;  Available (no spindown)
		PACKACK,-		;  Pack Acknowledge
		SENSECHAR,-		;  Sense Characteristics
		SETCHAR,-		;  Set Characteristics
		SENSEMODE,-		;  Sense Mode
		SETMODE,-		;  Set Mode
		WRITECHECK,-		;  Write Check
		READPBLK,-		;  Read  PHYSICAL Block
		READLBLK,-		;  Read  LOGICAL  Block
		WRITELBLK,-		;  Write LOGICAL  Block
		READVBLK,-		;  Read  VIRTUAL  Block
		WRITEVBLK,-		;  Write VIRTUAL  Block
		ACCESS,-		;  Access file and/or find directory entry
		ACPCONTROL,-		;  ACP Control Function
		CREATE,-		;  Create file and/or create directory entry
		DEACCESS,-		;  Deaccess file
		DELETE,-		;  Delete file and/or directory entry
		MODIFY,-		;  Modify file attributes
		MOUNT>			;  Mount volume
	FUNCTAB	,-			; BUFFERED I/O FUNCTIONS
		<NOP,-			;  No Operation
		 UNLOAD,-		;  Unload (make available + spindown)
		 AVAILABLE,-		;  Available (no spindown)
		 PACKACK,-		;  Pack Acknowledge
		 SENSECHAR,-		;  Sense Characteristics
		 SETCHAR,-		;  Set   Characteristics
		 SENSEMODE,-		;  Sense Mode
		 SETMODE,-		;  Set   Mode
		 ACCESS,-		;  Access file and/or find directory entry
		 ACPCONTROL,-		;  ACP Control Function
		 CREATE,-		;  Create file and/or create directory entry
		 DEACCESS,-		;  Deaccess file
		 DELETE,-		;  Delete file and/or directory entry
		 MODIFY,-		;  Modify file attributes
		 MOUNT>			;  Mount volume
	FUNCTAB	+ACP$READBLK,-		; READ FUNCTIONS
		<READLBLK,-		;  Read LOGICAL Block
		 READPBLK,-		;  Read PHYSICAL Block
		 READVBLK>		;  Read VIRTUAL Block
	FUNCTAB	+ACP$WRITEBLK,-		; WRITE FUNCTIONS
		<WRITECHECK,-		;  Write Check
		 WRITELBLK,-		;  Write LOGICAL Block
		 WRITEVBLK>		;  Write VIRTUAL Block
	FUNCTAB	+ACP$ACCESS,-		;
		<ACCESS,CREATE>		; ACCESS AND CREATE FILE OR DIRECTORY
	FUNCTAB	+ACP$DEACCESS,<DEACCESS>; DEACCESS FILE
	FUNCTAB	+ACP$MODIFY,-		;
		<ACPCONTROL,-		;  ACP Control Function
		 DELETE,-		;  Delete file or directory entry
		 MODIFY>		;  Modify File Attributes
	FUNCTAB	+ACP$MOUNT,<MOUNT>	; Mount Volume
	FUNCTAB	+EXE$ZEROPARM,-		; ZERO PARAMETER FUNCTIONS
		<NOP,-			;  No Operation
		 UNLOAD,-		;  Unload (make available + spindown)
		 AVAILABLE,-		;  Available (no spindown)
		 PACKACK>		;  Pack Acknowledge
	FUNCTAB	+EXE$SENSEMODE,-	;
		<SENSECHAR,-		;  Sense Characteristics
		 SENSEMODE>		;  Sense Mode
	FUNCTAB	+EXE$SETCHAR,-		;
		<SETCHAR,-		;  Set Characteristics
		 SETMODE>		;  Set Mode
	.PAGE
	.SBTTL	HIRT - Host Initiated Replacement Table

;+
; The following table is allocated within the Disk Class Driver since we want
;	to have only one such table per system.  The HIRT is used to control
;	resources needed by the algorithms used by Host Initiated Replacement
;	of disk blocks.  In order to limit the resources dedicated to this
;	activity, only one such replacement is allowed to proceed at any given
;	instant of time.  The HIRT allows us to queue requests.
;-

		.ALIGN	LONG,0		; Longword alignment.

HIRT$L_RPLQFL:	.LONG	0		; Request Queue FLINK.
HIRT$L_RPLQTP:	.LONG	0		; Request Queue Tail Pointer.
HIRT$W_IOST:	.WORD	0		; Static storage for routines.
HIRT$W_STS:	.WORD	0		; HIRT status word.

	$VIELD	HIRT,0,<-
			<ACTIVE,,M>,-	; Set means HIRT has been initialized.
			<BUSY,,M>,-	; Set means HIRT being used currently.
			<FE,,M>,-	; Set means force error on original data
			<MATCH,,M>,-	; SEARCH RCT bit - set => LBN matched
			<EMPTYPE,,M>,-	; SEARCH RCT BIT - set => not primary
			<RESCAN,,M>,-	; SEARCH RCT BIT - set => reached NULLS
			<RCTFULL,,M>,-	; SEARCH RCT BIT - set => no more RBNs available
			<ERLOGIP,,M>,-	; Error Log message has been generated
			<RCTFE,,M>,-	; Write RCT block with Forced Error
		       >

HIRT$L_LOOPCNT:	.LONG	0		; Loop count used in READ_RCT_BLOCK and
					;  WRITE_RCT_BLOCK.
HIRT$L_OWNUCB:	.LONG	0		; If HIRT busy, owner UCB address.
HIRT$L_LBN:	.LONG	0		; LBN being replaced for UCB.
HIRT$L_SAVDCDRP:.LONG	0		; CDRP address of I/O request of owner.
HIRT$L_CDRP:	.LONG	0		; Address of permanent CDRP for replacement.

HIRT$L_PAGE0PTR:.LONG	0		; System Virtual Address of scratch page
					;  needed by Replacement algorithm.
HIRT$L_PAGE1PTR:.LONG	0		; System Virtual Address of scratch page
					;  needed by Replacement algorithm.
HIRT$L_PAGE2PTR:.LONG	0		; System Virtual Address of scratch page
					;  needed by Replacement algorithm.
HIRT$L_PAGE3PTR:.LONG	0		; System Virtual Address of scratch page
					;  needed by Replacement algorithm.

HIRT$L_SVAPTE0:	.LONG	0		; SVAPTE of page 0.
HIRT$L_SVAPTE1:	.LONG	0		; SVAPTE of page 1.
HIRT$L_SVAPTE2:	.LONG	0		; SVAPTE of page 2.
HIRT$L_SVAPTE3:	.LONG	0		; SVAPTE of page 3.

HIRT$W_BOFF0:	.WORD	0		; BOFF of page 0.
HIRT$W_BOFF1:	.WORD	0		; BOFF of page 1.
HIRT$W_BOFF2:	.WORD	0		; BOFF of page 2.
HIRT$W_BOFF3:	.WORD	0		; BOFF of page 3.

; Array of words that give the relative RCT sector number contained in a page.

HIRT$W_PG0CNTNT:.WORD	0		; Page 0 contents.
HIRT$W_PG1CNTNT:.WORD	0		; Page 1 contents.
HIRT$W_PG2CNTNT:.WORD	0		; Page 2 contents.
HIRT$W_PG3CNTNT:.WORD	0		; Page 3 contents.

; Static storage needed by several routines that read and write RCT blocks.

HIRT$W_SECTORNO:.WORD	0		; Sector number.
HIRT$W_PAGENO:	.WORD	0		; Page number.

; Static storage needed by SEARCH_RCT subroutine.

HIRT$L_RBN:	.LONG	0 		; RBN returned to caller.
HIRT$L_MATCHRBN:.LONG	0		; Previous RBN that failed.
HIRT$L_BADRBND:	.LONG	0		; Bad RBN descriptor contents,
					;  used in STEP15 error recovery.
HIRT$L_STARTBLK:.LONG	0		; Sector number of Primary RBN.
HIRT$L_RCTBLOCK:.LONG	0		; Current RCT sector number.
HIRT$L_OFFSET:	.LONG	0		; Offset into current RCT sector.

; HIRT SUBSTACK - used by single threaded replacement algorithm as a return
;	point stack.

HIRT$L_STKPTR:	.LONG	0		; Pointer to top of SUBSTACK.
HIRT$L_SUBSTACK:.LONG	0,0,0,0,0	; SUBSTACK itself.
HIRT$K_SUBSTKLN=<.-HIRT$L_SUBSTACK>/4	; Total length of SUBSTACK in longwords.
	.PAGE
	.SBTTL	Invalid Command Log Message Buffer

	.ALIGN	LONG,0

IVCMD_ENDMSG:				; Where to copy received End Message.

	.BLKB	12+MSCP$K_MXCMDLEN	; 12 bytes plus received command.

IVCMD_ORIGMSG:

	.BLKB	MSCP$K_MXCMDLEN		; Where to reconstruct orignal command.

IVCMD_MSGLEN=.-IVCMD_ENDMSG
	.PAGE
	.SBTTL	Template UCB
DU_TEMPLATE_UCB:

	ASSUME	UCB$L_FQFL	EQ	.-DU_TEMPLATE_UCB
	ASSUME	UCB$L_FQBL	EQ	.+4-DU_TEMPLATE_UCB
	.LONG	0,0

	ASSUME	UCB$W_SIZE	EQ	.-DU_TEMPLATE_UCB
	.WORD	UCB$K_DU_LENGTH

	ASSUME	UCB$B_TYPE	EQ	.-DU_TEMPLATE_UCB
	.BYTE	DYN$C_UCB

	ASSUME	UCB$B_FIPL	EQ	.-DU_TEMPLATE_UCB
	.BYTE	DU_FORK_IPL

	ASSUME	UCB$L_FPC	EQ	.-DU_TEMPLATE_UCB
	ASSUME	UCB$L_FR3	EQ	.+4-DU_TEMPLATE_UCB
	ASSUME	UCB$L_FR4	EQ	.+8-DU_TEMPLATE_UCB
	.LONG	0,0,0

	ASSUME	UCB$W_BUFQUO	EQ	.-DU_TEMPLATE_UCB
	ASSUME	UCB$W_VPROT	EQ	.+2-DU_TEMPLATE_UCB
	.WORD	0,0

	ASSUME	UCB$L_OWNUIC	EQ	.-DU_TEMPLATE_UCB
	ASSUME	UCB$L_CRB	EQ	.+4-DU_TEMPLATE_UCB
	ASSUME	UCB$L_DDB	EQ	.+8-DU_TEMPLATE_UCB
	ASSUME	UCB$L_PID	EQ	.+12-DU_TEMPLATE_UCB
	ASSUME	UCB$L_LINK	EQ	.+16-DU_TEMPLATE_UCB
	ASSUME	UCB$L_VCB	EQ	.+20-DU_TEMPLATE_UCB
	.LONG	0,0,0,0,0,0

	ASSUME	UCB$L_DEVCHAR	EQ	.-DU_TEMPLATE_UCB
	.LONG	DEV$M_FOD!-			; Files Oriented Device
		DEV$M_DIR!-			; Directory structured device
		DEV$M_AVL!-			; Available
		DEV$M_ELG!-			; Error Log Enabled
		DEV$M_SHR!-			; Shareable
		DEV$M_IDV!-			; Input DeVice
		DEV$M_ODV!-			; Output DeVice
		DEV$M_RND			; RaNDom access

	ASSUME	UCB$B_DEVCLASS	EQ	.-DU_TEMPLATE_UCB
	.BYTE	DC$_DISK

	ASSUME	UCB$B_DEVTYPE	EQ	.-DU_TEMPLATE_UCB
	.BYTE	0

	ASSUME	UCB$W_DEVBUFSIZ	EQ	.-DU_TEMPLATE_UCB
	.WORD	512

	ASSUME	UCB$L_DEVDEPEND	EQ	.-DU_TEMPLATE_UCB
	.LONG	0

	ASSUME	UCB$L_IOQFL	EQ	.-DU_TEMPLATE_UCB
	ASSUME	UCB$L_IOQBL	EQ	.+4-DU_TEMPLATE_UCB
	.LONG	0,0

	ASSUME	UCB$W_UNIT	EQ	.-DU_TEMPLATE_UCB
	.WORD	0

	ASSUME	UCB$W_RWAITCNT	EQ	.-DU_TEMPLATE_UCB
	.WORD	1				; 1 to block I/O at init.

	ASSUME	UCB$L_IRP	EQ	.-DU_TEMPLATE_UCB
	.LONG	0

	ASSUME	UCB$W_REFC	EQ	.-DU_TEMPLATE_UCB
	.WORD	0

	ASSUME	UCB$B_DIPL	EQ	.-DU_TEMPLATE_UCB
	.BYTE	DU_FORK_IPL		; For Disk Class devices, device and
					;  fork IPL's are the same value.

	ASSUME	UCB$B_AMOD	EQ	.-DU_TEMPLATE_UCB
	.BYTE	0

	ASSUME	UCB$L_AMB	EQ	.-DU_TEMPLATE_UCB
	.LONG	0

	ASSUME	UCB$W_STS	EQ	.-DU_TEMPLATE_UCB
	.WORD	UCB$M_ONLINE

	ASSUME	UCB$W_DEVSTS	EQ	.-DU_TEMPLATE_UCB
	.WORD	UCB$M_NOCNVRT			; Do NOT convert Logical
						;  addresses to physical ones.

	ASSUME	UCB$L_DUETIM	EQ	.-DU_TEMPLATE_UCB
	ASSUME	UCB$L_OPCNT	EQ	.+4-DU_TEMPLATE_UCB
	ASSUME	UCB$L_SVPN	EQ	.+8-DU_TEMPLATE_UCB
	ASSUME	UCB$L_SVAPTE	EQ	.+12-DU_TEMPLATE_UCB
	.LONG	0,0,0,0

	ASSUME	UCB$W_BOFF	EQ	.-DU_TEMPLATE_UCB
	ASSUME	UCB$W_BCNT	EQ	.+2-DU_TEMPLATE_UCB
	.WORD	0,0

	ASSUME	UCB$B_ERTCNT	EQ	.-DU_TEMPLATE_UCB
	ASSUME	UCB$B_ERTMAX	EQ	.+1-DU_TEMPLATE_UCB
	.BYTE	0,0

	ASSUME	UCB$W_ERRCNT	EQ	.-DU_TEMPLATE_UCB
	.WORD	0

	ASSUME	UCB$L_PDT	EQ	.-DU_TEMPLATE_UCB
	ASSUME	UCB$L_DDT	EQ	.+4-DU_TEMPLATE_UCB
	.LONG	0,0

	.WORD	0				; Reserved word.
	.WORD	0				; Reserved word.

	ASSUME	UCB$L_DEVDEPND2	EQ	.-DU_TEMPLATE_UCB
	.LONG	0

	ASSUME	UCB$B_SLAVE	EQ	.-DU_TEMPLATE_UCB
	ASSUME	UCB$B_SPR	EQ	.+1-DU_TEMPLATE_UCB
	ASSUME	UCB$B_FEX	EQ	.+2-DU_TEMPLATE_UCB
	ASSUME	UCB$B_CEX	EQ	.+3-DU_TEMPLATE_UCB
	.BYTE	0,0,0,0

	ASSUME	UCB$L_EMB	EQ	.-DU_TEMPLATE_UCB
	.LONG	0

;	ASSUME	UCB$L_EMB+4	is	Reserved Word
	ASSUME	UCB$W_FUNC	EQ	.+2-DU_TEMPLATE_UCB
	.WORD	0,0

	ASSUME	UCB$L_DPC	EQ	.-DU_TEMPLATE_UCB
	ASSUME	UCB$L_MAXBLOCK	EQ	.+4-DU_TEMPLATE_UCB
	.LONG	0,0

	ASSUME	UCB$W_DIRSEQ	EQ	.-DU_TEMPLATE_UCB
	ASSUME	UCB$W_OFFSET	EQ	.+2-DU_TEMPLATE_UCB
	.WORD	0,0

	ASSUME	UCB$W_DA	EQ	.-DU_TEMPLATE_UCB
	ASSUME	UCB$W_DC	EQ	.+2-DU_TEMPLATE_UCB
	ASSUME	UCB$W_EC1	EQ	.+4-DU_TEMPLATE_UCB
	ASSUME	UCB$W_EC2	EQ	.+6-DU_TEMPLATE_UCB
	.WORD	0,0,0,0

	ASSUME	UCB$B_OFFNDX	EQ	.-DU_TEMPLATE_UCB
	ASSUME	UCB$B_OFFRTC	EQ	.+1-DU_TEMPLATE_UCB
	.BYTE	0,0

	ASSUME	UCB$W_BCR	EQ	.-DU_TEMPLATE_UCB
	.WORD	0

	ASSUME	UCB$Q_DU_UNIT_ID	EQ	.-DU_TEMPLATE_UCB
	.QUAD	0

	ASSUME	UCB$L_DU_MEDIAID	EQ	.-DU_TEMPLATE_UCB
	ASSUME	UCB$L_DU_VOLSER		EQ	.+4-DU_TEMPLATE_UCB
	ASSUME	UCB$L_DU_CDDB		EQ	.+8-DU_TEMPLATE_UCB
	ASSUME	UCB$L_CDT		EQ	.+12-DU_TEMPLATE_UCB
	ASSUME	UCB$L_DU_MVIOQFL	EQ	.+16-DU_TEMPLATE_UCB
	ASSUME	UCB$L_DU_MVIOQBL	EQ	.+20-DU_TEMPLATE_UCB
	.LONG	0,0,0,0,0,0

	ASSUME	UCB$L_DU_DEV_PARM	EQ	.-DU_TEMPLATE_UCB
	.LONG	0

	ASSUME	UCB$W_DU_UNT_FLGS	EQ	.-DU_TEMPLATE_UCB
	ASSUME	UCB$W_DU_DEVSTS		EQ	.+2-DU_TEMPLATE_UCB
	.WORD	0,0

	ASSUME	UCB$L_DU_USIZE		EQ	.-DU_TEMPLATE_UCB
	.LONG	0

	ASSUME	UCB$L_DU_TOTSZ		EQ	.-DU_TEMPLATE_UCB
	.LONG	0

	ASSUME	UCB$W_DU_RCTSIZE	EQ	.-DU_TEMPLATE_UCB
	ASSUME	UCB$B_DU_RCTCPYS	EQ	.+2-DU_TEMPLATE_UCB
	ASSUME	UCB$B_DU_RBNPTRK	EQ	.+3-DU_TEMPLATE_UCB
	.WORD	0
	.BYTE	0,0

	ASSUME	UCB$L_DU_MEDIATYP	EQ	.-DU_TEMPLATE_UCB
	.LONG	0

	ASSUME	UCB$W_DU_LBNPTRK	EQ	.-DU_TEMPLATE_UCB
	ASSUME	UCB$W_DU_TRKPGRP	EQ	.+2-DU_TEMPLATE_UCB
	ASSUME	UCB$W_DU_GRPPCYL	EQ	.+4-DU_TEMPLATE_UCB
	.WORD	0,0,0

	.WORD	0				; Reserved word

	ASSUME	UCB$K_DU_LENGTH		EQ	.-DU_TEMPLATE_UCB
	.PAGE
	.SBTTL	Controller Initialization Routine

;+
; MSCP speaking intelligent controller initialization routine.
;
; INPUTS:
;	R4 => System ID of intelligent controller.
;	R5 => IDB
;	R6 => DDB
;	R8 => CRB for intelligent controller.
;

DU_CONTROLLER_INIT:
	BRB	0$			; Branch around breakpoint.
	JSB	G^INI$BRK		; Breakpoint for debugging.
0$:

; Before starting the controller initialization we loop through all UCB's
;	on this DDB (shouldn't be more than at most one) and set their
;	UCB$W_RWAITCNT's to "1" so as to stall any IRP's that want to
;	get processed.  The reason for only one such UCB is that this UCB could
;	be that of the BOOT device.


	TSTL	CRB$L_AUXSTRUC(R8)	; CDDB, see if we already have one.
	BEQL	5$			; EQL implies CDDB not yet allocated.
	RSB				; If here, we were called from POWERFAIL,
					;  and we just return.
5$:
	MOVL	DDB$L_UCB(R6),R5	; R5 => first UCB if any.
	MOVW	#1,UCB$W_RWAITCNT(R5)	; Init count so that IRP's get hung up.
	BISW	#UCB$M_ONLINE,-		; Init fields in BOOT device UCB. Set
		UCB$W_STS(R5)		;  BOOT device ONLINE.
	BISW	#UCB$M_NOCNVRT,-	; Mark BOOT device so that we do NOT
		UCB$W_DEVSTS(R5)	;  attempt logical to physical translation.
	MOVB	#^X7F,-			; For now, make disk appear huge to
		UCB$L_MAXBLOCK+3(R5)	;  preclude comparison errors.

	MOVB	#DU_FORK_IPL,-		; For Disk Class devices, device and
		UCB$B_DIPL(R5)		;  fork IPL's are the same value.

	MOVL	UCB$L_LINK(R5),R0	; R0 => next UCB if any.
	BEQL	10$			; EQL implies no more UCB's.
	BUG_CHECK	DISKCLASS,FATAL	; For now.
10$:

; Here we begin with CONTROLLER initialization.  First we allocate the CDDB,
;	the data structure that we use to maintain controller and CONNECTION
;	related information.

	MOVL	R8,R3			; Move CRB pointer into R3.
	MOVL	R5,CRB$L_AUXSTRUC(R3)	; Before CDDB creation, UCB is AUXSTRUC.
	MOVQ	(R4),-			; Save System ID in as yet unused
		UCB$Q_DU_UNIT_ID(R5)	;  field.

;
; Here we thread the CRB onto the wakeup thread but set an infinite time to
;	start off with
;

	CLRL	CRB$L_TOUTROUT(R3)	; Insure access violation untill we
					;  establish a valid Time out routine.
	MNEGL	#1,CRB$L_DUETIME(R3)	; Establish infinite Due time.
	JSB	G^IOC$THREADCRB		; Call subroutine which threads.

	IOFORK				; Controller init called at IPL 31.
					;  Lower IPL before proceeding.

	ASSUME	CDDB$K_LENGTH+CDRP$K_LENGTH  LT  256
	MOVZBL	#CDDB$K_LENGTH+CDRP$K_LENGTH,R1		; R1 has length of block

	BSBW	ALLOC_POOL		; Call subroutine to allocate CDDB.
; Here R1 contains size of allocated block while R2 => allocated block.

	MOVW	R1,CDDB$W_SIZE(R2)	; Initialize size field of CDDB.

	ASSUME	CDDB$B_SUBTYPE  EQ  CDDB$B_TYPE+1
	MOVW	#DYN$C_CLASSDRV-	; Set type and subtype fields
		!<DYN$C_CD_CDDB@8>,-	;  with the CLASSDRV major type and
		CDDB$B_TYPE(R2)		;  CDDB subtype.

	MOVL	R2,CRB$L_AUXSTRUC(R3)	; Let CRB => CDDB.

	MOVL	R3,CDDB$L_CRB(R2)	; CDDB points back at CRB.

	ASSUME	CDDB$B_SYSTEMID+6  EQ  CDDB$W_STATUS
	MOVQ	UCB$Q_DU_UNIT_ID(R5),-	; Record SYSTEM ID.
		CDDB$B_SYSTEMID(R2)

	MOVW	#CDDB$M_INITING,-	; Initialize Status word
		CDDB$W_STATUS(R2)
	MOVL	UCB$L_DDB(R5),-		; Save DDB address.
		CDDB$L_DDB(R2)

	ASSUME	CDDB$L_OLDCMDSTS	EQ	CDDB$L_OLDRSPID+4
	CLRQ	CDDB$L_OLDRSPID(R2)	; Set impossible RSPID
					;  and clear old command status.
	CLRL	CDDB$L_RSTRTCDRP(R2)	; Clear oldest CDRP.

;	ASSUME  CDDB$W_RETRYCNT+1 is  Reserved
	ASSUME	CDDB$W_RSTRTCNT   EQ  CDDB$B_RETRYCNT+2
	CLRL	CDDB$B_RETRYCNT(R2)	; Clear CDDB$B_RETRYCNT and CDDB$W_RSTRTCNT.

	CLRQ	CDDB$Q_CNTRLID(R2)	; Clear field that will be filled later.
	MOVW	#MSCP$M_CF_ATTN!-	; Set initial Controller Flags to be
		 MSCP$M_CF_MISC!-	;  used on first SET CONTROLLER CHARACTERISTICS.
		 MSCP$M_CF_THIS,-	;  These are enable ATTENTION messages,
		CDDB$W_CNTRLFLGS(R2)	;  enable Miscellaneous Error log messages,
					;  and enable this hosts Error Log messages.

	MOVAB	CDDB$L_CDRPQFL(R2),-	; Initialize Queue listheads.
		CDDB$L_CDRPQFL(R2)
	MOVAB	CDDB$L_CDRPQFL(R2),-	;	"	"	"
		CDDB$L_CDRPQBL(R2)
	MOVAB	CDDB$L_RSTRTQFL(R2),-	;	"	"	"
		CDDB$L_RSTRTQFL(R2)
	MOVAB	CDDB$L_RSTRTQFL(R2),-	;	"	"	"
		CDDB$L_RSTRTQBL(R2)

	BBS	#UCB$V_VALID,-		; If valid, then this is the boot
		UCB$W_STS(R5),30$	;  device.
	MOVL	R5,R0			; R0 => block to deallocate.
	MOVL	R2,R5			; Save CDDB address.
	JSB	G^COM$DRVDEALMEM	; Else just deallocate the UCB that
					;  SYSGEN insisted on creating. 
	MOVL	R5,R2			; Restore R2 => CDDB.
	MOVL	CDDB$L_DDB(R2),R0	; R0 => DDB.
	CLRL	DDB$L_UCB(R0)		; CLRL DDB=>UCB.
30$:
	MOVAB	CDDB$L_PERMCDRP(R2),R5	; R5 => permanent CDRP following CDDB.

	MNEGW	#CDDB$L_PERMCDRP,-	; Set size field to be negative offset
		CDRP$W_CDRPSIZE(R5)	;  from base of this substructure to
					;  base of encompassing structure.
	MOVB	#DYN$C_CDRP,-		; Initialize CDRP portion of block
		CDRP$B_CD_TYPE(R5)	;  by saving the TYPE here.
	MOVB	#DU_FORK_IPL,-		; Save FORK IPL in CDRP.
		CDRP$B_FIPL(R5)

	CLRL	CDRP$L_RWCPTR(R5)	; Clear pointer to RWAITCNT since this
					;  CDRP has no IRP at negative offset.

	MOVAB	CDDB$L_CONNQFL(R2),-	; Initialize Q header used for
		CDDB$L_CONNQFL(R2)	;  permanent CDRP.
	MOVAB	CDDB$L_CONNQFL(R2),-	; Initialize Q header used for
		CDDB$L_CONNQBL(R2)	;  permanent CDRP.

;
; Here we call an internal subroutine which:
;
;	1. Makes a connection to the MSCP server in the intelligent
;		controller.
;
;	2. Sends an MSCP command to SET CONTROLLER CHARACTERISTICS.
;
;	3. Allocates an MSCP buffer and RSPID for our future use in
;		connection management.
;
; Upon return R4 => PDT and R5 => CDRP.
;

	BSBW	MAKE_CONNECTION		; Call internal subroutine to make
					;  a connection to the MSCP server in
					;  the intelligent controller. Input
					;  and output are R5 => CDRP.

;
; Here we determine if the Controller is capable of performing Controller
;	initiated bad block replacement.  If so we branch around.  If not,
;	we call INIT_HIRT to initialize the HIRT (Host Intitiated Replacement
;	Table.
;

	CVTWL	CDRP$W_CDRPSIZE(R5),R3	; R3 contains negative offset to CDDB.
	ADDL	R5,R3			; R3 => CDDB.

	BBS	#MSCP$V_CF_REPLC,-	; See if Controller initiated replacement.
		CDDB$W_CNTRLFLGS(R3),90$;  If so, branch around.
	BSBW	INIT_HIRT		; Call to initialize HIRT.
90$:

;
; Here we loop thru the controller finding each known unit.  This is done
;	by sending GET UNIT STATUS MSCP commands specifying the NEXT UNIT
;	modifier.  For each unit identified, we create a UCB (unless we
;	already have one for the unit) and if the unit is marked as
;	SOFTWARE valid in the UCB (this could only be true if the UCB had
;	existed previous to this invocation of DU_CONTROLLER_INIT) we send
;	an ONLINE MSCP command to bring the unit into the online state
;	with respect to us.
;

	MOVL	#1,R0			; Begin looking for units > or = 1.
					;  We do this since when no more units
					;  are known, we get back information
					;  about unit #0.
100$:
	MOVL	CDRP$L_MSG_BUF(R5),R2		; R2 => recycled end packet.
	PUSHR	#^M<R0,R2,R4,R5>		; Save registers before MOVC5
	MOVC5	#0,.,#0,#MSCP$K_MXCMDLEN,(R2)	;  to insure reserved fields
	POPR	#^M<R0,R2,R4,R5>		;  are zero. Then restore regs.

	CVTWL	CDRP$W_CDRPSIZE(R5),R3	; R3 has negative offset, from base of
					;  CDRP, of base of CDDB.
	ADDL	R5,R3			; R3 => CDDB.

	MOVL	CDRP$L_RSPID(R5),-	; Use recycled RSPID as command
		MSCP$L_CMD_REF(R2)	;  reference number.

	MOVW	R0,MSCP$W_UNIT(R2)	; Find next unit > or = contents of R0.


	MOVB	#MSCP$K_OP_GTUNT,-	; Move GET UNIT STATUS opcode to
		MSCP$B_OPCODE(R2)	;  appropriate spot.
	MOVW	#MSCP$M_MD_NXUNT,-	; Set NEXT UNIT modifier into MSCP
		MSCP$W_MODIFIER(R2)	;  packet.

	MOVL	CDDB$L_CRB(R3),R0	; R0 => CRB.
	ADDL3	#INIT_IMMED_DELTA,-	; Establish a delta time for time out
		G^EXE$GL_ABSTIM,-	;  to prevent against controller never
		CRB$L_DUETIME(R0)	;  responding.

	BSBW	DRIVER_SEND_MSG_BUF	; Returns with R2 => END PACKET.

	MOVL	CDDB$L_CRB(R3),R0	; Refresh R0 => CRB.
	MNEGL	#1,CRB$L_DUETIME(R0)	; Again put in infinite timeout.

;
; Now loop thru UCB's to see if we have one for the unit described in the END
;	PACKET.
;

	MOVZWL	MSCP$W_UNIT(R2),R0	; R0 = unit number to search for.
	BSBW	LOOKUP_UCB		; See if we have a UCB for it.
	BLBC	R0,130$			; LBC implies NO existing UCB.
	BRW	190$			; R2 => existing UCB. GOTO 190$.
130$:
	EXTZV	#MSCP$V_ST_MASK,-	; Extract major status code and put
		#MSCP$S_ST_MASK,-	;  into R0.
		MSCP$W_STATUS(R2),R0
	CMPW	R0,#MSCP$K_ST_SUCC	; See if unit ONLINE.
	BEQL	150$			; EQL implies yes, so branch.
	CMPW	R0,#MSCP$K_ST_AVLBL	; See if unit available
	BEQL	150$			; EQL implies NOT offline. Branch to
					;  create a new UCB.
	CMPW	R0,#MSCP$K_ST_OFFLN	; See if unit offline.
	BNEQ	140$			; NEQ implies some controller error.
	ASSUME	MSCP$K_SC_UNKNO		EQ	0
	CMPW	R0,MSCP$W_STATUS(R2)	; See if subcode is zero.
	BNEQ	150$			; NEQ implies unknown, so go make UCB.
140$:
	MOVZWL	MSCP$W_UNIT(R2),R3	; If UNKNOWN, get unit number in non-
					;  volatile register.
	RECYCH_MSG_BUF			; Recycle END PACKET and
	RECYCL_RSPID			;  the RSPID.
	MOVL	R3,R0			; Place saved unit number in R0 and
	BRW	210$			;  branch to look for next unit if any.
150$:
	MOVZWL	#UCB$K_DU_LENGTH,R1	; Get length of UCB to allocate.
	BSBW	ALLOC_POOL		; Allocate space. Returns R2=>space.
	MOVL	CDRP$L_MSG_BUF(R5),R0	; R0 => End Message.
	PUSHL	R0			; Save End Message Address on stack.
	MOVZWL	MSCP$W_UNIT(R0),R0	; R0 = unit number.
	BSBW	INIT_UCB		; Fill in R2 => UCB.
	POPL	R0			; R0 => End message.
	MOVL	MSCP$L_MEDIA_ID(R0),R0	; R0 = Media ID.
	BSBW	GET_DEVTYPE		; Returns R0 = DEVTYPE.
	MOVB	R0,UCB$B_DEVTYPE(R2)	; Store in UCB.

;
; Here we loop thru the UCB chain to find the point at which to link this UCB.
;	UCB's are in order of their unit numbers.
;

	BSBW	CHAIN_UCB		; Put R2 => UCB onto UCB chain.

	MOVL	CDRP$L_MSG_BUF(R5),R0	; R0 => END PACKET from GET UNIT STATUS.
	CMPZV	#MSCP$V_ST_MASK,-	; Compare major status code to
		#MSCP$S_ST_MASK,-	;  see if known unit is ONLINE.
		MSCP$W_STATUS(R0),-
		#MSCP$K_ST_SUCC
	BNEQ	190$			; NEQ implies NO.

	MOVW	MSCP$W_UNT_FLGS(R0),-	; If ONLINE copy same unit flags.
		UCB$W_DU_UNT_FLGS(R2)
190$:

; Here we initialize some connection dependent fields in the UCB.
;	We also initialize some device specific fields in the UCB that
;	would not have been done for the boot device.
;
;	Registers at this point are as follows:
;
;		R2 => UCB
;		R3 => CDDB
;		R4 => PDT
;		R5 => CDRP
;

	MOVL	CDRP$L_CDT(R5),R0	; Pass R0 => CDT.
	BSBW	INIT_CONNDEP_UCB	; Init connection dependent fields in UCB.


;
; Here we do an ONLINE MSCP command unless the unit is SOFTWARE invalid.
;

	MOVL	R2,R3			; Place UCB pointer in non-volatile reg.
	RECYCH_MSG_BUF		; Recycle END PACKET.
	RECYCL_RSPID			; And RSPID.

	BBC	#UCB$V_VALID,-		; If volume is SOFTWARE invalid, do NOT
		UCB$W_STS(R3),200$	;  bring unit ONLINE.

	BSBW	BRING_UNIT_ONLINE	; Bring unit whose R3=> UCB online.

200$:
	MOVZWL	UCB$W_UNIT(R3),R0	; Get last unit found.
210$:
	BEQL	220$			; EQL implies NO more units.
	INCL	R0			; Increment to continue the search.
	BRW	100$			; Branch back for next GET UNIT STATUS.
220$:
	CVTWL	CDRP$W_CDRPSIZE(R5),R3	; R3 contains negative offset of CDDB.
	ADDL	R5,R3			; R3 => CDDB.

	SUBL3	#UCB$L_LINK-DDB$L_UCB,-
		CDDB$L_DDB(R3),R0	; R0 => "previous" UCB.
230$:
	MOVL	UCB$L_LINK(R0),R0	; R0 => next UCB if any.
	BEQL	240$			; EQL implies no more UCB's.
	DECW	UCB$W_RWAITCNT(R0)	; Decrement count so as to allow I/O.
	BEQL	235$			; It ought to be zero now.
	BUG_CHECK	DISKCLASS,FATAL	; Else something is wrong.
235$:
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save registers before call.
	MOVL	R0,R5			; R5 => UCB to unstall.
	JSB	G^SCS$UNSTALLUCB	; Startup any queued up I/O requests.
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore registers after call.
	BRB	230$			; Loop back to test more UCB's (if any).
240$:
	MOVL	CDDB$L_CRB(R3),R0	; R0 => CRB.

	MOVAB	W^DU$TMR,-
		CRB$L_TOUTROUT(R0)	; Establish permanent timeout routine.
	MOVZWL	CDDB$W_CNTRLTMO(R3),R1	; R1 = returned controller timeout.
	ADDL3	R1,-			; And establish a normal delta time
		G^EXE$GL_ABSTIM,-	;  for future automatic wakeups of the
		CRB$L_DUETIME(R0)	;  Timeout Mechanism Routine.
	BICW	#CDDB$M_INITING,-	; Clear "initing" bit.
		CDDB$W_STATUS(R3)
	RSB				; Terminate this thread of execution.

INIT_TIMEOUT:				; Controller Init Timeout handler.
	BUG_CHECK	DISKCLASS,FATAL	; Stop for now. *********************
	.PAGE
	.SBTTL	UCB UTILITY SUBROUTINES

;+
; LOOKUP_UCB - internal subroutine to scan UCB chain looking for UCB for
;	unit number specified by R0.
;
; Inputs:
;	R0 =  unit number
;	R3 => CDDB
;
; Outputs:
;	R0 - LBS
;		R2 => UCB found
;	R0 - LBC
;		All registers except R0 preserved
;-

LOOKUP_UCB:

	PUSHL	R0			; Save unit number of interest.
	SUBL3	#UCB$L_LINK-DDB$L_UCB,-
		CDDB$L_DDB(R3),R0	; R0 => "previous" UCB.
10$:
	MOVL	UCB$L_LINK(R0),R0	; R0 => next UCB if any.
	BEQL	30$			; EQL implies no more UCB's.
	CMPW	(SP),UCB$W_UNIT(R0)	; Compare known unit # to that of unit
					;  # of UCB.
	BGTR	10$			; GTR implies we must continue search.
	BLSS	20$			; LSS implies we must create UCB.
					; EQL implies we have UCB.
	MOVL	R0,R2			; R2 => Already created UCB.
	MOVZWL	S^#SS$_NORMAL,R0	; Indicate success, we found UCB.
	BRB	30$			; Branch around.
20$:
	CLRL	R0			; Indicate failure to find UCB.
30$:
	TSTL	(SP)+			; Clean up stack.
	RSB
	.PAGE
;+
; INIT_UCB - internal subroutine to fill in a newly created UCB with standard
;		values.
;
; Inputs:
;	R0 =  unit number of device
;	R2 => UCB
;	R3 => CDDB
;

INIT_UCB:

	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save registers before MOVC.
	MOVZWL	#UCB$K_DU_LENGTH,R1	; Get length of UCB to copy.
	MOVC3	R1,DU_TEMPLATE_UCB,(R2)	; Copy contents of template to new UCB.
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore registers.

;	MOVL	R2,UCB$L_FQFL(R2)	; Initialize listheads.
;	MOVL	R2,UCB$L_FQBL(R2)	;	"	"
	MOVAB	UCB$L_IOQFL(R2),-	;	"	"
		UCB$L_IOQFL(R2)
	MOVAB	UCB$L_IOQFL(R2),-	;	"	"
		UCB$L_IOQBL(R2)

	MOVL	CDDB$L_CRB(R3),-	; Save CRB address in UCB.
		UCB$L_CRB(R2)
	MOVL	CDDB$L_DDB(R3),-	; Save DDB address in UCB.
		UCB$L_DDB(R2)

	MOVW	R0,UCB$W_UNIT(R2)	; Copy unit number to UCB.
	RSB
	.PAGE
;+
; INIT_CONNDEP_UCB - internal subroutine to initialize connection dependent
;		fields in the UCB.
;
; Inputs:
;	R0 => CDT
;	R2 => UCB
;	R3 => CDDB
;	R4 => PDT
;-

INIT_CONNDEP_UCB:

	MOVL	R0,UCB$L_CDT(R2)	; Initialize connection dependent
					;  fields like CDT,
	MOVL	R3,UCB$L_DU_CDDB(R2)	; CDDB and,
	MOVL	R4,UCB$L_PDT(R2)	; PDT.

	MOVAB	UCB$L_DU_MVIOQFL(R2),-	; Init MOUNT VERIFICATION I/O queue
		UCB$L_DU_MVIOQFL(R2)	;  listhead.
	MOVAB	UCB$L_DU_MVIOQFL(R2),-	;		"
		UCB$L_DU_MVIOQBL(R2)	;		"

	PUSHL	R0			; Save R0.
	MOVL	CDDB$L_DDB(R3),R0	; R0 => DDB.
	MOVL	DDB$L_DDT(R0),-		; Copy DDT address to UCB.
		UCB$L_DDT(R2)
	POPL	R0			; Restore R0.
	CMPB	#MSCP$K_CM_EMULA,-	; See if Controller Model is EMULATOR.
		CDDB$B_CNTRLMDL(R3)
	BEQL	10$			; If so, branch around setting of bit.
	BISL	#DEV$M_RCT,-		; Set bit saying that disk has an RCT,
		UCB$L_DEVCHAR(R2)	;  i.e. it conforms to DEC STD 166.
10$:
	RSB
	.PAGE
;+
; CHAIN_UCB - internal subroutine to place a new UCB onto UCB chain.
;
; Inputs:
;	R2 => UCB
;	R3 => CDDB
;-

CHAIN_UCB:

	MOVQ	R0,-(SP)		; Save R0,R1.
	SUBL3	#UCB$L_LINK-DDB$L_UCB,-
		CDDB$L_DDB(R3),R0	; R0 => "previous" UCB.
10$:
	MOVL	R0,R1			; R1 => previous UCB.
	MOVL	UCB$L_LINK(R1),R0	; R0 => next UCB.
	BEQL	20$			; EQL implies no more UCB's.
	CMPW	UCB$W_UNIT(R2),-	; See if known unit # is greater than
		UCB$W_UNIT(R0)		;  this UCB's unit #.
	BGTRU	10$			; GTRU implies yes, so we keep on
					;  scanning the UCB chain.
20$:
	MOVL	R0,UCB$L_LINK(R2)	; Point new UCB to higher unit UCB.
	MOVL	R2,UCB$L_LINK(R1)	; Point previous UCB to new UCB.
	MOVQ	(SP)+,R0		; Restore R0,R1.
	RSB
	.PAGE
;+
; GET_DEVTYPE - internal subroutine to translate MSCP$L_MEDIA_ID into DT$_
;	format.
;
; Input:
;	R0 = contents of MSCP$L_MEDIA_ID
;
; Output:
;	R0 = DT$_ type of definition.
;

MEDIA_ARRAY:
	.LONG	^x25641050
	.LONG	^x25641051
	.LONG	^x2065A001
	.LONG	^x2065A301
	.LONG	^x22A4103C
	.LONG	0

DEVTYPE_ARRAY:
	.BYTE	DT$_RA80
	.BYTE	DT$_RA81
	.BYTE	DT$_RZ01
	.BYTE	DT$_RZF01
	.BYTE	DT$_RA60
	.BYTE	0

GET_DEVTYPE:

	PUSHL	R1			; Save R1.
	CLRL	R1			; Index starts out with zero.
10$:
	PUSHL	MEDIA_ARRAY[R1]		; Place possible value onto stack.
	BEQL	20$			; EQL implies we ran out of values.
	CMPL	R0,(SP)+		; Compare to value received.
	BEQL	30$			; EQL implies we found it.
	INCL	R1			; Bump index.
	BRB	10$			; Go back and try again.
20$:
	TSTL	(SP)+			; Remove MEDIA_ARRAY value from stack.
30$:
	MOVZBL	DEVTYPE_ARRAY[R1],R0	; Copy corresponding DT$_ defintion.
	POPL	R1			; Retore R1.
	RSB				; Return to caller.
	.PAGE
	.SBTTL	DRIVER_SEND_MSG_BUF

;+
; DRIVER_SEND_MSG_BUF - internal funnel to call SEND_MSG_BUF for those
;	calls generated during CONNECTION.
;
; INPUTS:
;	R4 => PDT
;	R5 => CDRP
;
; OUTPUTS:
;	CDRP Queued onto list and we jump to SEND_MSG_BUF.

DRIVER_SEND_MSG_BUF:

	CVTWL	CDRP$W_CDRPSIZE(R5),R2	; R2 has negative offset, from base of
					;  CDRP, of base of CDDB.
	ADDL	R5,R2			; R2 => CDDB.

	INSQUE	(R5),@CDDB$L_CONNQBL(R2); Insert CDRP onto CONNECT Q.

	MOVL	#MSCP$K_MXCMDLEN,R1	; Pass length of MSCP packet.
	JMP	@PDT$L_SNDCNTMSG(R4)	; Jump to PORT routine.
	.PAGE
	.SBTTL	INIT_HIRT

;+
; INIT_HIRT - Internal subroutine to initialize the HIRT if it is not already
;	initialized.  There is one HIRT per system and it resides in the
;	disk class driver.  It is initialized the first time we bring
;	online an intelligent controller that requires Host Initiated Bad
;	Block Replacement.
;
;	HIRT initialization includes setting up its FLINK and BLINK, allocating
;	a permanent CDRP for it, allocating an RSPID for it, allocating an
;	MSCP buffer (without Send Credit on any connection) and allocating
;	four pages of memory that are needed by the replacement algorithm.
;
; INPUTS:
;	R3 => CDDB
;	R4 => PDT
;	R5 => Connection permanent CDRP
; OUTPUTS:
;	HIRT initialized.  I.e. we allocate a CDRP and four pages of pool
;		and set associated pointers in the HIRT.  For each page we
;		calculate the SVAPTE of it and its BOFF.
;
;	Registers R3-R5 preserved, R0-R2 modified.
;

INIT_HIRT:

	POPL	CDDB$L_SAVED_PC(R3)	; Save caller's PC in CDDB.
	BBCS	#HIRT$V_ACTIVE,-	; Now see if HIRT already init'ed.
		HIRT$W_STS,10$
	BRW	END_INIT_HIRT		; Branch around if already initialized.
10$:
	CLRL	HIRT$L_RPLQFL		; Singly linked list with second
	MOVAB	HIRT$L_RPLQFL,-		;  longword pointing to tail of list.
		HIRT$L_RPLQTP

	BISW	#HIRT$M_BUSY,-		; Prevent use of HIRT until fully
		HIRT$W_STS		;  init'ed.
;
; Here we allocate a CDRP that we will use and re-use during I/O operations
;	associated with dynamic Host Initiated Replacement of bad blocks.
;


20$:
	MOVZWL	#IRP$K_LENGTH,R1	; R1 contains amount of space to alloc.
	BSBW	ALLOC_POOL		; Allocate space. Returns R2=>space.

	MOVB	#DYN$C_IRP,-		; Make first part of CDRP look like an
		IRP$B_TYPE(R2)		;  IRP.
	MOVW	R1,IRP$W_SIZE(R2)	; Save type and size inside "IRP".
	MOVAB	-CDRP$L_IOQFL(R2),R5	; R5 => CDRP portion of packet.
	MOVL	R5,HIRT$L_CDRP		; Save address of replacement CDRP.
	MOVW	#CDRP$L_IOQFL,-		; Size field in CDRP portion is negative
		CDRP$W_CDRPSIZE(R5)	;  offset of IRP from CDRP portion.
	MOVB	#DYN$C_CDRP,-		; Mark type of CDRP portion.
		CDRP$B_CD_TYPE(R5)
	CLRL	CDRP$L_CDT(R5)		; So far we have no connection for CDRP.
	CLRL	CDRP$L_RWCPTR(R5)	; This CDRP will not use RWAITCNT.
	CLRL	CDRP$L_LBUFH_AD(R5)	; Signal that no mapping resources allocated.

	CLRL	CDRP$L_RSPID(R5)	; Clear RSPID to show none yet allocated.
	CLRL	CDRP$L_MSG_BUF(R5)	; Likewise show no MSCP buffer.

;
; Here we allocate pages from pool to serve as buffers when reading RCT sectors
;	during replacement of bad blocks on a disk.
;


50$:
	MOVZWL	#512+12,R1		; R1 contains amount of space for a
					;  page and a VMS structure header.

	MOVAB	CDDB$L_PERMCDRP(R3),R5	; ALLOC_POOL needs R5 =>Permanent CDRP.
	BSBW	ALLOC_POOL		; Allocate space. Returns R2=>space.
	MOVL	HIRT$L_CDRP,R5		; Restore R5 => Hirt CDRP.

	ASSUME	CDDB$B_SUBTYPE  EQ  CDDB$B_TYPE+1
	MOVW	#DYN$C_CLASSDRV-	; Place type and subtype descriptors
		!<DYN$C_CD_BBRPG@8>,-	;  into header using convenient (CDDB)
		CDDB$B_TYPE(R2)		;  offset definition.
	MOVW	R1,CDDB$W_SIZE(R2)	; Also place size into header.
	MOVAB	12(R2),R2		; R2 => beyond VMS structure header.
	CLRL	R1			; Clear loop index register.
80$:
	TSTL	HIRT$L_PAGE0PTR[R1]	; Test where to put address of allocated page.
	BEQL	90$			; EQL implies we have found a depository.
	INCL	R1			; Else bump index register
	BRB	80$			;  and go back and try again.
90$:
	MOVL	R2,HIRT$L_PAGE0PTR[R1]	; Else save Page address.
	BICW3	#^XFE00,R2,-		; Calculate BOFF of page just allocated
		HIRT$W_BOFF0[R1]	;  and save it in the Indexed slot.
	EXTZV	S^#VA$V_VPN,-		; Now calculate SVAPTE of allocated
		S^#VA$S_VPN,R2,R2	;  page.  First get VPN.
	MOVL	G^MMG$GL_SPTBASE,R0	; Then R0 => base of system page table.

	MOVAL	(R0)[R2],HIRT$L_SVAPTE0[R1]
					; Move SVAPTE into proper slot.
	CMPL	R1,#3			; See if we are done allocating.
	BLSS	50$			; LSS implies NO, so we go to try again.

	BICW	#HIRT$M_BUSY,-		; Allow use of HIRT now that it has
		HIRT$W_STS		;  been initialized.
	MOVAB	CDDB$L_PERMCDRP(R3),R5	; Restore R5 => Controller permanent CDRP.
END_INIT_HIRT:
	JMP	@CDDB$L_SAVED_PC(R3)	; Return to caller.
	.PAGE
	.SBTTL	ALLOC_POOL

;+
; This subroutine allocates and zeroes nonpaged pool.
;
; Inputs:
;
;	R1			-# bytes of pool to allocate
;	R5			-Addr of UCB or Addr of CDRP
;	
; Outputs:
;
;	R0			-0/1 for fail/success
;	R1			-# bytes actually allocated
;	R2			-Addr of buffer allocated
;-

ALLOC_POOL:				; Allocate and zero pool

	PUSHL	R3			; Save R3.
	JSB	G^EXE$ALONONPAGED	; Allocate from nonpaged pool
	BLBC	R0,10$			; Skip clearing structure if failure
	PUSHR	#^M<R0,R1,R2,R4,R5>	; Save MOVC registers
	MOVC5	#0,(SP),#0,R1,(R2)	; Zero initialize structure

	POPR	#^M<R0,R1,R2,R4,R5>	; Restore MOVC registers
	POPL	R3			; Restore R3.
	RSB				;
10$:					; Here we suffered an allocation failure.
					;  Prepare to wait awhile before trying
					;  again.
	POPL	FKB$L_FR3(R5)		; Save R3 in R5=>UCB or CDRP.
	MOVL	R4,FKB$L_FR4(R5)	; Likewise R4
	POPL	FKB$L_FPC(R5)		;  and caller's return point.
	CMPB	#DYN$C_UCB,-		; Now determine which kind of block.
		UCB$B_TYPE(R5)
	BEQL	20$			; EQL means UCB.

	MOVL	R1,CDRP$L_SAVD_RTN(R5)		  ; Save R1 in block dependent way.
	MOVL	-CDDB$L_PERMCDRP+CDDB$L_CRB(R5),R3; R3 => CRB.
	BRB	30$				  ; Branch around to common code.
20$:
	MOVL	R1,UCB$L_DPC(R5)	; Save R1 in block dependent way.
	MOVL	UCB$L_CRB(R5),R3	; R3 => CRB.
30$:
	MOVAB	B^40$,CRB$L_TOUTROUT(R3); Establish wakeup routine.
	ADDL3	#ALLOC_DELTA,-		; Establish a small delay.
		G^EXE$GL_ABSTIM,-
		CRB$L_DUETIME(R3)
	RSB				; Evaporate for awhile.
40$:
	SETIPL	#DU_FORK_IPL		; After wakeup lower IPL.
	MOVL	CRB$L_AUXSTRUC(R3),R5	; R5 => UCB or CDDB.
	CMPB	#DYN$C_UCB,-		; Again determine which kind of block.
		UCB$B_TYPE(R5)
	BEQL	50$			; EQL means UCB.
	MOVAB	CDDB$L_PERMCDRP(R5),R5	; Restore R5 => CDRP.
	MOVL	CDRP$L_SAVD_RTN(R5),R1	; And R1 = size of block to allocate.
	BRB	60$			; Branch around to common code.
50$:
	MOVL	UCB$L_DPC(R5),R1	; Restore R1 = size in block dependent way.
60$:
	MOVAB	INIT_TIMEOUT,-		; Restore TIME ROUTINE.
		CRB$L_TOUTROUT(R3)
	MOVQ	FKB$L_FR3(R5),R3	; Restore R3 and R4.
	PUSHL	FKB$L_FPC(R5)		; Re-establish caller's return point.
	BRB	ALLOC_POOL		; Go try again.
	.PAGE
	.SBTTL	MAKE_CONNECTION

; MAKE_CONNECTION - Internal subroutine, called from DU_CONTROLLER_INIT and
;	DU$CONNECT_ERR, that establishes a connection to the MSCP server
;	in the intelligent controller.
;
; INPUTS:
;	R5 => permanent CDRP
;
; OUTPUTS:
;	Connection established and initial SET CONTROLLER CHARACTERISTICS
;	command is sent to controller.  Also an MSCP buffer and an RSPID
;	are allocated for the connection.
;
;	Side effects include the fact that all registers, except R5, are
;	modified.
;

CLASS_DRVR_NAME:	.ASCII	/VMS$DISK_CL_DRVR/
MSCP_SRVR_NAME:		.ASCII	/MSCP$DISK       /

HSTIMEOUT_ARRAY:			; Host timeouts for various controllers.
	ASSUME	MSCP$K_CM_HSC50	EQ	1
	ASSUME	MSCP$K_CM_UDA50	EQ	2
	ASSUME	MSCP$K_CM_RC25	EQ	3
	ASSUME	MSCP$K_CM_EMULA	EQ	4
	ASSUME	MSCP$K_CM_TU81	EQ	5
	ASSUME	MSCP$K_CM_UDA52	EQ	6
	.BYTE	HOST_TIMEOUT		; Use default constant for HSC50.
	.BYTE	0			; Use zero for dedicated controller.(UDA50)
	.BYTE	0			; Use zero for dedicated controller.(AZTEC)
	.BYTE	HOST_TIMEOUT		; Use default constant for Emulator.
	.BYTE	0			; Use zero for dedicated controller.(TU81)
	.BYTE	0			; Use zero for dedicated controller.(UDA52)

MAKE_CONNECTION:

	CVTWL	CDRP$W_CDRPSIZE(R5),R2	; R2 has negative offset, from base of
					;  CDRP, of base of CDDB.
	ADDL	R5,R2			; R2 => CDDB.
	POPL	CDDB$L_SAVED_PC(R2)	; Save caller's return in CDDB field.

	CONNECT	DU$IDR,-		; Entry point of Input Dispatcher Routine.
		DU$DGDR,-		; Entry point of Datagram Dispatcher.
		DU$CONNECT_ERR,-	; Error entry point.
		CDDB$B_SYSTEMID(R2),-	; Destination SYSTEM ID.
		,-			; Remote station address.
		MSCP_SRVR_NAME,-	; MSCP server name.
		CLASS_DRVR_NAME,-	; Ascii of class driver name.
		#INITIAL_CREDIT,-	;  Needs definition
		#MIN_SEND_CREDIT,-	; Minimum send credit
		#INITIAL_DG_COUNT,-	; Initial DataGram count
		,-			; Block transfer priority
		,-			; Connect data
		(R2),-			; Also pass CDDB address to CDT$L_AUXSTRUC
		,			; Bad Response packet address

	BLBS	R0,30$			; LBS implies success, so branch around.

	CVTWL	CDRP$W_CDRPSIZE(R5),R2	; R2 has negative offset, from base of
					;  CDRP, of base of CDDB.
	ADDL	R5,R2			; R2 => CDDB.
	MOVL	CDDB$L_CRB(R2),R3	; R3 => CRB.

	MOVAB	B^20$,CRB$L_TOUTROUT(R3); Establish LABEL as place to call, for
					;  now, for periodic wakeups.
	ADDL3	#CONNECT_DELTA,-	; Establish Due time as a little in
		G^EXE$GL_ABSTIM,-	;  the future.
		CRB$L_DUETIME(R3)
	RSB				; Return to caller's caller and kill
					;  this thread.
20$:
	MOVL	CRB$L_AUXSTRUC(R3),R2	; R2 => CDDB.
	MOVAB	CDDB$L_PERMCDRP(R2),R5	; R5 => CDRP.
	SETIPL	#DU_FORK_IPL		; Lower IPL after wakeup.
	PUSHL	CDDB$L_SAVED_PC(R2)	; Restore caller's return to stack.
	BRB	MAKE_CONNECTION		; Loop back and try CONNECT again.
30$:
	MOVL	R3,CDRP$L_CDT(R5)	; Save CDT address returned by CONNECT.
	MOVL	R2,R1			; Save ACCEPT_REQ message address.
	CVTWL	CDRP$W_CDRPSIZE(R5),R2	; R2 has negative offset, from base of
					;  CDRP, of CDDB base.
	ADDL	R5,R2			; R2 => CDDB.
	MOVL	R4,CDDB$L_PDT(R2)	; Save PDT address in CDDB.

	MOVL	CDDB$L_CRB(R2),R3	; R3 => CRB.
	MNEGL	#1,CRB$L_DUETIME(R3)	; Infinite time till next timeout for now.
	MOVAB	INIT_TIMEOUT,-		; Establish TIME ROUTINE that will serve
		CRB$L_TOUTROUT(R3)	;  for rest of controller initialization.

;
; Here we prepare to send a SET CONTROLLER CHARACTERISTICS MSCP Packet to
;	the intelligent controller over the connection that we have just
;	established.
;

	MOVL	R2,R3			; Save R3 => CDDB in non-volatile register.

	ALLOC_RSPID			; ALLOCate a ReSPonse ID.
	ALLOC_MSG_BUF			; Allocate an MSCP buffer (and also
					;  allocate a unit of flow control).
	BLBS	R0,50$			; If success, branch around.
	BUG_CHECK	DISKCLASS,FATAL
50$:					; Here R2 => MSCP buffer allocated.
	CLRL	R1			; First set Controller Characteristics
					;  with zero (i.e. infinite) host timeout.
	BSBB	PRP_STCON_MSG		; Call to prepare MSCP command.
	BSBW	DRIVER_SEND_MSG_BUF	; Returns with R2 => END PACKET.
	BSBW	RECORD_STCON		; Record Controller Characteristics.

	RECYCH_MSG_BUF			; We recycle the END PACKET and
					;  thereby allocate a new send credit.
	RECYCL_RSPID			; We also recycle the RSPID.

	MOVZBL	CDDB$B_CNTRLMDL(R3),R1	; Get controller model type.
	MOVZBL	HSTIMEOUT_ARRAY-1[R1],R1; Get corresponding host timeout value.
	BEQL	60$			; If zero, branch around.
	BSBB	PRP_STCON_MSG		; Else reset controller characteristics.
	BSBW	DRIVER_SEND_MSG_BUF	; Returns with R2 => END PACKET.
	BSBB	RECORD_STCON		; Record Controller Characteristics.
	RECYCH_MSG_BUF			; Again we recycle the END PACKET and
					;  thereby allocate a new send credit.
	RECYCL_RSPID			; We also recycle the RSPID.
60$:

	JMP	@CDDB$L_SAVED_PC(R3)	; Return to caller.

; PRP_STCON_MSG - Prepare a Set Controller Characteristics Command Message.
;
; Inputs:
;	R1 =  Host Timeout Value
;	R2 => MSCP buffer to fill
;	R3 => CDDB
;	R5 => CDRP
;

PRP_STCON_MSG:
	PUSHR	#^M<R1,R2,R3,R4,R5>		; Save registers before MOVC5.
	MOVC5	#0,.,#0,#MSCP$K_MXCMDLEN,(R2)	;  to insure reserved fields
	POPR	#^M<R1,R2,R3,R4,R5>		;  are zero. Then restore regs.

	MOVL	CDRP$L_RSPID(R5),-	; Fill in MSCP buffer.  First we put
		MSCP$L_CMD_REF(R2)	;  in the command reference number.

	MOVB	#MSCP$K_OP_STCON,-	; Insert SET CONTROLLER CHARACTERISTICS
		MSCP$B_OPCODE(R2)	;  opcode with NO modifiers.

	MOVW	CDDB$W_CNTRLFLGS(R3),-	; Set host settable characteristics
		MSCP$W_CNT_FLGS(R2)	;  bits into MSCP command message.

	MOVW	R1,MSCP$W_HST_TMO(R2)	; Set host timeout into MSCP packet.

	MOVQ	G^EXE$GQ_SYSTIME,-	; Transmit time of century in clunks.
		MSCP$Q_TIME(R2)

	MOVL	CDDB$L_CRB(R3),R0	; R0 => CRB.
	ADDL3	#INIT_IMMED_DELTA,-	; Establish a delta time for time out
		G^EXE$GL_ABSTIM,-	;  to prevent against controller never
		CRB$L_DUETIME(R0)	;  responding.

	RSB				; Return to caller.


; RECORD_STCON - Record data from a Set Controller Characteristics end message
;		in the CDDB.
;
; Inputs:
;	R2 => MSCP End Message
;	R3 => CDDB


RECORD_STCON:
	MOVW	MSCP$W_CNT_FLGS(R2),-	; Pickup NON-host settable characteristics
		CDDB$W_CNTRLFLGS(R3)	;  from END PACKET and save in CDDB.

	MOVW	MSCP$W_CNT_TMO(R2),-	; Likewise with controller timeout.
		CDDB$W_CNTRLTMO(R3)

	MOVQ	MSCP$Q_CNT_ID(R2),-	; Also save controller unique ID.
		CDDB$Q_CNTRLID(R3)

	RSB				; Return to caller.
	.PAGE
	.SBTTL	BRING_UNIT_ONLINE

; BRING_UNIT_ONLINE - Internal subroutine to bring an available unit online.
;	This subroutine is called from DU_CONTROLLER_INIT and DU$CONNECT_ERR.
;
; INPUTS:
;	R3 => UCB
;	R4 => PDT
;	R5 => CDRP
;

BRING_UNIT_ONLINE:

	MOVL	CDRP$L_MSG_BUF(R5),R2		; R2 => MSCP packet.
	PUSHR	#^M<R2,R3,R4,R5>		; Save registers before MOVC5.
	MOVC5	#0,.,#0,#MSCP$K_MXCMDLEN,(R2)	;  to insure reserved fields
	POPR	#^M<R2,R3,R4,R5>		;  are zero. Then restore regs.

	CVTWL	CDRP$W_CDRPSIZE(R5),R0	; R0 has negative offset, from base of
					;  CDRP, of base of CDDB.
	ADDL	R5,R0			; R0 => CDDB.
	POPL	CDDB$L_SAVED_PC(R0)	; Save caller's return in CDDB field.

	MOVL	CDRP$L_RSPID(R5),-	; RSPID serves as command reference #.
		MSCP$L_CMD_REF(R2)

	MOVW	UCB$W_UNIT(R3),-	; Unit number from UCB to packet.
		MSCP$W_UNIT(R2)		;

	MOVB	#MSCP$K_OP_ONLIN,-	; ONLINE command, zero modifiers.
		MSCP$B_OPCODE(R2)

	MOVW	UCB$W_DU_UNT_FLGS(R3),-	; Copy UNIT flags to MSCP packet.
		MSCP$W_UNT_FLGS(R2)

	MOVL	UCB$L_DU_DEV_PARM(R3),-	; Copy Device dependent parameters to
		MSCP$L_DEV_PARM(R2)	;  MSCP packet.

	MOVL	UCB$L_CRB(R3),R0	; R0 => CRB.
	ADDL3	#INIT_IMMED_DELTA,-	; Establish a delta time for time out
		G^EXE$GL_ABSTIM,-	;  to prevent against controller never
		CRB$L_DUETIME(R0)	;  responding.

	BSBW	DRIVER_SEND_MSG_BUF	; ONLINE. Returns R2 => END PACKET.

	MOVL	UCB$L_CRB(R3),R0	; Refresh R0 => CRB.
	MNEGL	#1,CRB$L_DUETIME(R0)	; Again put in infinite timeout.

	EXTZV	#MSCP$V_ST_MASK,-	; Get major status into R0.
		#MSCP$S_ST_MASK,-
		MSCP$W_STATUS(R2),R0
	CMPW	#MSCP$K_ST_SUCC,R0	; Was it success?
	BwNEQ	20$			; NEQ implies NO.

; If here then various fields in the END PACKET are valid.
;	Here we have just brought ONLINE a unit that was online before either
;	as a result of the BOOT DRIVER or as a result of a failed previous
;	CONNECTION.  In the case of a failed CONNECTION only, let's assure
;	that the volume is identical to the one that was ONLINE here before.
;	And if so then let's setup the UCB accordingly.  If however it is
;	different, then let's unload (MSCP AVAILABLE) the disk and spin it
;	down.
;
;	In the case of booting, then since the BOOT DRIVER is not smart
;	enough to initialize the UCB with the proper values, we assume that
;	it is the same volume and branch around the comparisons.

	CVTWL	CDRP$W_CDRPSIZE(R5),R0	; R0 has negative offset, from base of
					;  CDRP, of CDDB.
	ADDL	R5,R0			; R0 => CDDB.
	BBS	#CDDB$V_INITING,-	; If set, then here because of BOOTING,
		CDDB$W_STATUS(R0),10$	;  so branch around.

	CMPL	MSCP$Q_UNIT_ID(R2),-	; Begin with the UNIT identifier,
		UCB$Q_DU_UNIT_ID(R3)	;  See if the same as before.
	BwNEQ	40$			; NEQ, branch around.
	CMPL	MSCP$Q_UNIT_ID+4(R2),-	; Test second longword of UNIT identifier.
		UCB$Q_DU_UNIT_ID+4(R3)
	BwNEQ	40$
	CMPL	MSCP$L_VOL_SER(R2),-	; Test volume serial number.
		UCB$L_DU_VOLSER(R3)
	BwNEQ	40$			; Not the same volume as before, so branch.
10$:
	BSBW	RECORD_ONLINE		; Move data from end message to UCB.

	RECYCH_MSG_BUF			; Recycle END PACKET.
	RECYCL_RSPID			; And the RSPID.

	MOVL	CDRP$L_MSG_BUF(R5),R2		; R2 => MSCP packet.
	PUSHR	#^M<R2,R3,R4,R5>		; Save registers before MOVC5.
	MOVC5	#0,.,#0,#MSCP$K_MXCMDLEN,(R2)	;  to insure reserved fields
	POPR	#^M<R2,R3,R4,R5>		;  are zero. Then restore regs.

	MOVL	CDRP$L_RSPID(R5),-	; RSPID serves as command reference #.
		MSCP$L_CMD_REF(R2)

	MOVW	UCB$W_UNIT(R3),-	; Unit number from UCB to packet.
		MSCP$W_UNIT(R2)		;

	MOVB	#MSCP$K_OP_GTUNT,-	; GET UNIT STATUS command, zero modifiers.
		MSCP$B_OPCODE(R2)

	MOVL	UCB$L_CRB(R3),R0	; R0 => CRB.
	ADDL3	#INIT_IMMED_DELTA,-	; Establish a delta time for time out
		G^EXE$GL_ABSTIM,-	;  to prevent against controller never
		CRB$L_DUETIME(R0)	;  responding.

	BSBW	DRIVER_SEND_MSG_BUF	; ONLINE. Returns R2 => END PACKET.

	MOVL	UCB$L_CRB(R3),R0	; Refresh R0 => CRB.
	MNEGL	#1,CRB$L_DUETIME(R0)	; Again put in infinite timeout.

	EXTZV	#MSCP$V_ST_MASK,-	; Get major status into R0.
		#MSCP$S_ST_MASK,-
		MSCP$W_STATUS(R2),R0
	CMPW	#MSCP$K_ST_SUCC,R0	; Was it success?
	BwNEQ	20$			; NEQ implies NO.

	BSBW	RECORD_UNIT_STATUS	; Record UNIT status data in UCB.

	BBS	#MSCP$V_UF_REPLC,-	; Branch around, if controller initiated
		UCB$W_DU_UNT_FLGS(R3),-	;  bad block replacement.
		30$
	BSBW	LOCK_HIRT		; Else grab hold of the HIRT.
	BSBW	ONLINE_COMPLETE		; Make sure no replacement in progress.
	PUSHL	R0			; Save status return.
	BSBW	UNLOCK_HIRT		; Release HIRT.
	POPL	R0			; Restore status returned by ONLINE_COMPLETE.

	BLBS	R0,30$			; LBS means all ok.
20$:
	BICW	#UCB$M_VALID,-		; If we couldn't put the drive ONLINE,
		UCB$W_STS(R3)		;  clear VOLUME VALID.
	BBC	#MSCP$V_SC_DUPUN,-	; Branch around if NOT duplicate
		MSCP$W_STATUS(R2),25$	;  unit substatus.
	PUSHL	R5			; Save R5.
	MOVL	R3,R5			; R5 => UCB for subroutine.
	BSBW	SEND_DUPUNIT		; Call to send OPCOM message.
	POPL	R5			; Restore R5.
25$:
30$:
	RECYCH_MSG_BUF			; Recycle END PACKET.
	RECYCL_RSPID			; And the RSPID.

	CVTWL	CDRP$W_CDRPSIZE(R5),R0	; R0 has negative offset, from base of
					;  CDRP, of base of CDDB.
	ADDL	R5,R0			; R0 => CDDB.
	JMP	@CDDB$L_SAVED_PC(R0)	; Return to caller.

40$:					; HERE if volume has changed.
	RECYCH_MSG_BUF			; Recycle END PACKET.
	RECYCL_RSPID			; And the RSPID.

	MOVL	CDRP$L_MSG_BUF(R5),R2		; R2 => MSCP packet.
	PUSHR	#^M<R2,R3,R4,R5>		; Save registers before MOVC5.
	MOVC5	#0,.,#0,#MSCP$K_MXCMDLEN,(R2)	;  to insure reserved fields
	POPR	#^M<R2,R3,R4,R5>		;  are zero. Then restore regs.

	MOVL	CDRP$L_RSPID(R5),-	; RSPID serves as command reference #.
		MSCP$L_CMD_REF(R2)
	MOVW	UCB$W_UNIT(R3),-	; Unit number from UCB to packet.
		MSCP$W_UNIT(R2)		;

	ASSUME	MSCP$W_MODIFIER		EQ	MSCP$B_OPCODE+2
	MOVL	#MSCP$K_OP_AVAIL-	; Available command with
		!<MSCP$M_MD_SPNDW@16>,-	;  SPINDOWN modifier.
		MSCP$B_OPCODE(R2)
	BSBW	DRIVER_SEND_MSG_BUF	; Returns with R2 => END PACKET.
	BRB	20$			; And go back to mark disk "INVALID".
	.PAGE
	.SBTTL	Mount Verification Routine

;+
; DU_MOUNT_VEROUT - Routine called (via DDT) by Mount Verification code.
;
; INPUTS:
;	R3 => IRP or R3 = 0.
;		R3 => IRP is a signal that the IRP should be inserted onto
;			the UCB$L_DU_MVIOQFL.
;		R3 =  0 is a signal that Mount Verification is complete.
;
;	R5 => UCB of unit on which we are performing Mount Verification.
;
; OUTPUTS:
;	If Mount Verification starting (i.e. R3 => IRP) we set bit
;		UBC$M_DU_MNTVERIP on in UCB$W_DU_DEVSTS and relocate all
;		IRP's currently on UCB$L_IOQFL to UCB$L_DU_MVIOQFL.
;		If this bit was already on we forgo relocation of IRP's.
;		We then insert R3 => IRP onto this UCB$L_DU_MVIOQFL in
;		the proper place according to its IRP$L_SEQNUM.
;
;	If Mount Verification is finishing, (i.e. R3 = 0) we relocate back
;		all IRP's on UCB$L_DU_MVIOQFL to UCB$L_IOQFL, clear the
;		UCB$M_DU_MNTVERIP bit in UCB$W_DU_DEVSTS and call
;		SCS$UNSTALLUCB to start up all backed up IRP's.
;
;	Register R0 and R1 are modified.
;-

DU_MOUNT_VEROUT:

	TSTL	R3			; See if Mount Verification starting.
	BEQL	END_MOUNT_VERI		; EQL implies ending,
					;  else we are starting.

START_MOUNT_VERI:

	MOVAB	UCB$L_DU_MVIOQFL(R5),R0	; R0 => relocation listhead.
	BBSS	#UCB$V_DU_MNTVERIP,-	; If NOT first time thru for this Mount
		UCB$W_DU_DEVSTS(R5),-	;  Verification, branch around.  Else
		10$			;  set bit and continue.

	MOVAB	UCB$L_IOQFL(R5),R1	; First determine if I/O queue empty.
	CMPL	(R1),R1			; Compare contents of listhead to address
	BEQL	10$			;  of listhead.  EQL implies empty.

	MOVL	UCB$L_IOQBL(R5),R1	; R1 => last IRP
	MOVL	R0,IRP$L_IOQFL(R1)	; Last IRP points forward to new listhead.
	MOVL	UCB$L_IOQFL(R5),R1	; R1 => 1st IRP.
	MOVL	R0,IRP$L_IOQBL(R1)	; 1st IRP points back to new listhead.

	MOVQ	UCB$L_IOQFL(R5),-	; Copy old listhead to new listhead.
		UCB$L_DU_MVIOQFL(R5)

	MOVAB	UCB$L_IOQFL(R5),-	; Reinitialize old listhead to empty
		UCB$L_IOQFL(R5)		;  state.
	MOVAB	UCB$L_IOQFL(R5),-	;
		UCB$L_IOQBL(R5)
10$:
	MOVL	(R0),R1			; R1 => 1st (next if any) IRP.
20$:
	CMPL	R0,R1			; See if at end of list of IRP's.
	BEQL	30$			; EQL implies at end of list.

	CMPL	IRP$L_SEQNUM(R3),-	; Else scan for higher sequence number.
		IRP$L_SEQNUM(R1)
	BLSSU	30$			; If R3 => IRP has lower sequence number,
					;  we branch to insert before R1 => IRP.
	MOVL	IRP$L_IOQFL(R1),R1	; Else R1 => next IRP.
	BRB	20$			; And we branch back to try again.
30$:
	INSQUE	(R3),@IRP$L_IOQBL(R1)	; Insert our IRP before selected one.
	RSB				; And return to our caller.

END_MOUNT_VERI:

	MOVAB	UCB$L_DU_MVIOQFL(R5),R0	; 1st determine if list is empty.
	CMPL	(R0),R0			; Compare contents of listhead to address
	BEQL	40$			;  of listhead. EQL implies empty.
					; Note - this list can only be empty
					;  here if someone has CANCELed I/O.

	MOVL	UCB$L_DU_MVIOQBL(R5),R0	; R0 => last IRP.
	MOVAB	UCB$L_IOQFL(R5),-	; Last IRP points forward to listhead.
		IRP$L_IOQFL(R0)
	MOVL	UCB$L_DU_MVIOQFL(R5),R1	; R1 => 1st IRP.
	MOVL	IRP$L_IOQFL(R0),-	; 1st IRP points back to listhead.
		IRP$L_IOQBL(R1)

	MOVQ	UCB$L_DU_MVIOQFL(R5),-	; Relocate listhead.
		UCB$L_IOQFL(R5)

	MOVAB	UCB$L_DU_MVIOQFL(R5),-	; Initialize now empty listhead.
		UCB$L_DU_MVIOQFL(R5)	;
	MOVAB	UCB$L_DU_MVIOQFL(R5),-	;
		UCB$L_DU_MVIOQBL(R5)
40$:
	BICW	#UCB$M_DU_MNTVERIP,-	; Turn off bit signifying that we are
		UCB$W_DU_DEVSTS(R5)	;  in Mount Verification.

	JSB	G^SCS$UNSTALLUCB	; Call to start up IRP's on UCB$L_IOQFL.
	RSB				; And return to our caller.
	.PAGE
	.SBTTL	START I/O
;
;+
;
;  Beginning of out of line code to deal with problems that
;	may occur in the common STARTIO code on the next page.
;

MSG_BUF_FAILURE:

; We are here only if we had an allocation failure on the Message Buffer.
;  This implies that our CONNECTION to the MSCP server is broken.  The action
;  to be taken is to kill this thread of execution since we are guaranteed
;  that a thread exists that is currently executing that is gathering all
;  CDRP's associated with this CONNECTION.  So we branch to KILL_THIS_THREAD.

	BRW	KILL_THIS_THREAD	; Branch to where we collect all active
					;  CDRP's prior to re-CONNECTION.
;
; Out of line code to handle Volume Invalid.
;

VOL_INVALID:
	MOVZWL	#SS$_VOLINV,R0		; Indicate error status.
	CLRL	R1			; Clear second word of I/O status.
	BRW	FUNCTION_EXIT		; GOTO common exit.

;
;  End of out of line code
;-
	.PAGE
DU_STARTIO:
	BICW	#UCB$M_BSY,UCB$W_STS(R5); Undo bit setting so that
					;  mulitple IRP's can be started.

	BBC	#UCB$V_DU_MNTVERIP,-	; If Mount Verification is NOT in
		UCB$W_DU_DEVSTS(R5),10$	;  progress, then branch around.
	BBS	#IRP$V_MVIRP,-		; If Mount Verification IS in progress,
		IRP$W_STS(R3),10$	;  and this IRP is an MVIRP, branch.

	INSQUE	IRP$L_IOQFL(R3),-	; Else if in Mount Verification and this
		@UCB$L_DU_MVIOQBL(R5)	;  is an ordinary IRP, Queue the IRP to
					;  the tail of the queue of IRP's await-
					;  ing the completion of Mount Verification.
	RSB				; And return (to QIO System Service).
10$:
	TSTW	UCB$W_RWAITCNT(R5)	; See if any IRP's currently waiting
					;  for resources.
	BEQL	DU_REAL_STARTIO		; EQL implies NO, so GOTO real STARTIO.
	INSQUE	IRP$L_IOQFL(R3),-	; To force sequential submission of commands
		@UCB$L_IOQBL(R5)	;  to intelligent controller, we force
					;  IRP's to be queued up here if any
					;  previous request is possibly hungup
					;  waiting for resources between the
					;  beginning of STARTIO and the SEND_MSG_BUF.
	RSB				; Return to caller (QIO system service)

DU_REAL_STARTIO:
	MOVAB	-CDRP$L_IOQFL(R3),R0	; Get address of CDRP portion of IRP.
	MOVL	R5,R3			; Let R3 => UCB.
	MOVL	R0,R5			; R5 => CDRP.
	MOVW	#CDRP$L_IOQFL,-		; Move (negative) offset from CDRP base
		CDRP$W_CDRPSIZE(R5)	;  to IRP base to size field.
	MOVB	#DYN$C_CDRP,-		; Initialize type field.
		CDRP$B_CD_TYPE(R5)

;***************** Investigate what was I thinking about here **********
;
;	CLRQ	CDRP$L_IOST1(R5)	; Clear quad area used to signal aborted
;					;  requests.
;*****************  End of investigate *********************************

DU_RESTARTIO:				; Label where we RESTART CDRP's after
					;  virtual circuit re-CONNECTION.

	MOVL	UCB$L_CDT(R3),-		; Place CDT pointer into CDRP for handy
		CDRP$L_CDT(R5)		;  reference by SCS routines. Note we
					;  do this after label DU_RESTARTIO so
					;  that it is refreshed upon restart.

	MOVAB	UCB$W_RWAITCNT(R3),-	; Point CDRP field to UCB field.
		CDRP$L_RWCPTR(R5)
	MOVL	UCB$L_PDT(R3),R4	; R4 => port's PDT.

	CLRL	CDRP$L_MSG_BUF(R5)	; Prevent spurious DEALLOC_MSG_BUF.
	CLRL	CDRP$L_LBUFH_AD(R5)	; Prevent spurious UNMAP.

	BBS	#CDRP$V_ERLOGIP,-	; Bit set means we are restarting an
		CDRP$W_STS(R5),10$	;  operation that replaced a block. We
					;  continue to use the original RSPID.
	CLRL	CDRP$L_RSPID(R5)	; Prevent spurious DEALLOC_RSPID.
	ALLOC_RSPID			; ALLOCate a ReSPonse ID.
10$:
	ALLOC_MSG_BUF			; Allocate an MSCP buffer (and also
					;  allocate a unit of flow control).
	BLBC	R0,MSG_BUF_FAILURE	; If failure, branch out of line.

	BBS	#IRP$V_PHYSIO,-
		CDRP$W_STS(R5),20$	; See if PHYSICAL I/O requested.
	BBC	#UCB$V_VALID,-		; If NOT physical, then volume must be
		UCB$W_STS(R3),-		;  valid in order to accept request. If
		VOL_INVALID		;  not, branch out of line.
20$:

; Here a little common MSCP packet initialization.

	ASSUME	MSCP$K_MXCMDLEN	EQ	36
	MOVL	R2,R1			; R1 => MSCP buffer to clear.
	CLRQ	(R1)+			; Zero out MSCP buffer to insure all
	CLRQ	(R1)+			;  reserved fields are clear.
	CLRQ	(R1)+			;
	CLRQ	(R1)+			;
	CLRL	(R1)			; Maximum length packet cleared.

	MOVL	CDRP$L_RSPID(R5),-	; Use RSPID as command reference
		MSCP$L_CMD_REF(R2)	;  number for all commands.

	MOVW	UCB$W_UNIT(R3),-	; Indicate UNIT number in MSCP
		MSCP$W_UNIT(R2)		;  packet.

	EXTZV	#IRP$V_FCODE,-		; Extract I/O function code.
		#IRP$S_FCODE,-
		CDRP$W_FUNC(R5),R1


; Now we have the I/O function code without modifiers in R1.  We use it to
;	branch to the particular code that handles the function.

	ASSUME	IO$_NOP		EQ   0
	ASSUME	IO$_UNLOAD	EQ   1
	ASSUME	IO$_PACKACK	EQ   8
	ASSUME	IO$_WRITECHECK	EQ   10
	ASSUME	IO$_WRITEPBLK	EQ   11
	ASSUME	IO$_READPBLK	EQ   12
	ASSUME	IO$_AVAILABLE	EQ   17
	CASE	R1,<-
			START_NOP,-			; 0
			START_UNLOAD,-			; 1
				START_NOSUCH,-		; 2
				START_NOSUCH,-		; 3
				START_NOSUCH,-		; 4
				START_NOSUCH,-		; 5
				START_NOSUCH,-		; 6
				START_NOSUCH,-		; 7
			START_PACKACK,-			; 8
				START_NOSUCH,-		; 9
			START_WRITECHECK,-		; 10
			START_WRITEPBLK,-		; 11
			START_READPBLK,-		; 12
				START_NOSUCH,-		; 13
				START_NOSUCH,-		; 14
				START_NOSUCH,-		; 15
				START_NOSUCH,-		; 16
			START_AVAILABLE,-		; 17
		>
START_NOSUCH:
	MOVZWL	#SS$_ILLIOFUNC,R0
	CLRL	R1
	BRW	FUNCTION_EXIT		; Branch to exit I/O function.
	.PAGE
	.SBTTL	START_NOP
; START_NOP - Prepare an MSCP packet to do a GET UNIT STATUS command.
;
; INPUTS:
;	R2 => MSCP buffer
;	R3 => UCB
;	R4 => PDT
;	R5 => CDRP
;
;	MSCP packet is zero except for MSCP$L_CMD_REF and MSCP$W_UNIT fields.
;

START_NOP:
	MOVB	#MSCP$K_OP_GTUNT,-	; Transfer GET UNIT STATUS opcode
		MSCP$B_OPCODE(R2)	;  to packet.

	BSBW	CALL_SEND_MSG_BUF	; Call common interface to SEND_MSG_BUF.

; Here the command has completed in the controller.  CDRP$L_MSG_BUF points
;	to the END PACKET that was returned by the controller.

	BSBW	INTERPRET_ACTION_TABLE_N; Interpret Action Table for Non-transfer
					;  command.

	ACTION_ENTRY	MSCP$K_ST_SUCC,SS$_NORMAL,NOP_SUCC

	ACTION_ENTRY	MSCP$K_ST_OFFLN,SS$_DEVOFFLINE,NOP_OFFLINE

	ACTION_ENTRY	MSCP$K_ST_AVLBL,SS$_MEDOFL,NOP_AVAIL

	ACTION_ENTRY	MSCP$K_ST_DRIVE,SS$_DRVERR,NOP_DRVERR

	ACTION_ENTRY	MSCP$K_ST_CNTLR,SS$_CTRLERR,NOP_CTRLERR

	ACTION_ENTRY	MSCP$K_ST_ICMD,SS$_CTRLERR,NOP_IVCMD

	ACTION_ENTRY			; End of action table.

	BUG_CHECK	DISKCLASS,FATAL	; None of the legal status codes returned.

NOP_IVCMD:
	BSBB	SETUP_IVCMD		; Setup to log invalid command data.
					; Returns R2 => MSCP command to reconstruct.
	MOVZBL	#MSCP$K_OP_GTUNT,(R2)+	; Reconstruct opcode.
	CLRQ	(R2)+			; Clear rest of invalid command buffer.
	CLRQ	(R2)+
	CLRQ	(R2)
	BSBB	LOG_IVCMD		; Call to log invalid command data.
	BISW	#CDRP$M_ERLOGIP,-	; Signal to log status.
		CDRP$W_STS(R5)
;	BRB_NOP_END			; Branch around to end.

NOP_SUCC:
NOP_OFFLINE:
NOP_AVAIL:
NOP_CTRLERR:
NOP_DRVERR:
;NOP_END:
	CLRL	R1			; Clear for I/O status block.
	BRW	FUNCTION_EXIT		; Branch to common exit.
	.PAGE
	.SBTTL	SETUP_IVCMD and LOG_IVCMD

; SETUP_IVCMD - Copy received invalid command end message to IVCMD buffer.
;
; Inputs:
;	R2 => Received invalid command end message
;	R3 => UCB
;	R4 => PDT
;	R5 => CDRP
;
; Outputs:
;	R2 => IVCMD buffer at offset MSCP$B_OPCODE so that caller can
;		reconstruct his original command.
;

SETUP_IVCMD:
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save registers.
	MOVC3	#12+MSCP$K_MXCMDLEN,-	; Copy received Invalid Command End
		(R2),IVCMD_ENDMSG	;  Message to buffer.
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore registers.

	MOVAB	IVCMD_ORIGMSG,R2	; R2 => area where to reconstruct command.

	ASSUME	MSCP$L_CMD_REF	EQ	0
	MOVL	CDRP$L_RSPID(R5),(R2)+	; Reconstruct command reference number.

	ASSUME	MSCP$W_UNIT	EQ	MSCP$L_CMD_REF+4
	MOVZWL	UCB$W_UNIT(R3),(R2)+	; Reconstruct unit number.

	ASSUME	MSCP$B_OPCODE	EQ	MSCP$W_UNIT+4
	RSB				; Return to caller.

; LOG_IVCMD - call to log IVCMD buffer.
;
; Inputs:
;	All data in IVCMD buffer.
; Outputs:
;	All registers preserved.
;

LOG_IVCMD:

	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save registers.
	MOVZWL	#EMB$C_IVCMD,R0		; Signal type of Logged Message.
	MOVZBL	#IVCMD_MSGLEN,R1	; Pass buffer length.
	MOVAB	IVCMD_ENDMSG,R2		; R2 => buffer.
	JSB	G^ERL$LOGMESSAGE	; Call to log message.
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore registers.
	RSB				; Return to caller.
	.PAGE
	.PAGE
	.SBTTL	START_PACKACK

; START_PACKACK - Prepare an MSCP packet to do an ONLINE command.
;
; INPUTS:
;	R2 => MSCP buffer
;	R3 => UCB
;	R4 => PDT
;	R5 => CDRP
;
;	MSCP packet is zero except for MSCP$L_CMD_REF and MSCP$W_UNIT fields.
;

START_PACKACK:

	MOVB	#MSCP$K_OP_ONLIN,-	; Transfer ONLINE opcode
		MSCP$B_OPCODE(R2)	;  to packet.

	MOVW	UCB$W_DU_UNT_FLGS(R3),-	; Copy unit flags to MSCP packet.
		MSCP$W_UNT_FLGS(R2)

	MOVL	UCB$L_DU_DEV_PARM(R3),-	; Copy Device dependent parameters to
		MSCP$L_DEV_PARM(R2)	;  MSCP packet.

	BSBW	CALL_SEND_MSG_BUF	; Call common interface to SEND_MSG_BUF.

; Here the command has completed in the controller.  CDRP$L_MSG_BUF and R2
;	both point to the END PACKET that was returned by the controller.

	BICW	#UCB$M_VALID,-		; Initialize software volume invalid.
		UCB$W_STS(R3)

	BSBW	INTERPRET_ACTION_TABLE_N; Interpret Action Table for Non-transfer
					;  command.

	ACTION_ENTRY	MSCP$K_ST_SUCC,SS$_NORMAL,PACKACK_SUCC

	ACTION_ENTRY	MSCP$K_ST_OFFLN,SS$_MEDOFL,PACKACK_OFFLINE

	ACTION_ENTRY	MSCP$K_ST_ABRTD,SS$_ABORT,END_PACKACK

	ACTION_ENTRY	MSCP$K_ST_DRIVE,SS$_DRVERR,END_PACKACK

	ACTION_ENTRY	MSCP$K_ST_MFMTE,SS$_FORMAT,END_PACKACK

	ACTION_ENTRY	MSCP$K_ST_ICMD,SS$_CTRLERR,PACKACK_IVCMD

	ACTION_ENTRY			; End of action table.

	BUG_CHECK	DISKCLASS,FATAL	; None of the legal status codes returned.


PACKACK_SUCC:				; Action routine for MSCP$K_ST_SUCC.

	BSBW	RECORD_ONLINE		; Record ONLINE data in UCB.

; Here having done an ONLINE we proceed to do a GET UNIT STATUS.

	MOVL	R0,CDRP$L_IOQFL(R5)	; Save final I/O status in unused spot.
	BSBW	RECYCLE_ALL		; Refresh RSPID, MSG_BUF, etc.
	MOVB	#MSCP$K_OP_GTUNT,-	; Opcode is for GET UNIT STATUS.
		MSCP$B_OPCODE(R2)
	BSBW	CALL_SEND_MSG_BUF	; Call common interface to SEND_MSG_BUF.

	BSBW	INTERPRET_ACTION_TABLE_N; Interpret Action Table for Non-transfer
					;  command.

	ACTION_ENTRY	MSCP$K_ST_SUCC,SS$_NORMAL,PACKACK_GTUNT_SUCC

	ACTION_ENTRY			; End of Action Table.

	BSBW	RECYCLE_ALL		; If here, drive went offline.
	BRW	START_PACKACK		; Go try again.

PACKACK_GTUNT_SUCC:

	BSBW	RECORD_UNIT_STATUS	; Record UNIT STATUS data in UCB.

	MOVL	CDRP$L_IOQFL(R5),R0	; Restore final I/O status.
	BBS	#MSCP$V_UF_REPLC,-	; Branch around, if controller initiated
		UCB$W_DU_UNT_FLGS(R3),-	;  bad block replacement since we already
		VALID_PACKACK		;  have our status in R0.
	BSBW	LOCK_HIRT		; Else grab hold of the HIRT.
	BSBW	ONLINE_COMPLETE		; Make sure no replacement in progress.
	PUSHL	R0			; Save status return.
	PUSHL	R1			; Save ERLOGIP bit setting.
	BSBW	UNLOCK_HIRT		; Release HIRT.
	POPL	R1			; Restore ERLOGIP setting.
	BISW	R1,CDRP$W_STS(R5)	; Set ERLOGIP bit if on in R1.
	POPL	R0			; Restore status returned by ONLINE_COMPLETE.

	BLBS	R0,VALID_PACKACK	; LBS means all ok.

; Here we will have to test some function modifier to see if the user wants
;	access to the disk even though the RCT is either full or unusable.
;	If he does we presumably give him read only access.  Otherwise we
;	terminate the I/O with the SS$_BADRCT status.

;	TEST FOR ACCESS EVEN THOUGH BAD RCT.
	BEQL	10$			; If so branch.
	MOVZWL	#SS$_BADRCT,R0		; Else return BAD RCT status.
	BRB	END_PACKACK		; And branch around to end.
10$:
;	SET READ ONLY.


PACKACK_IVCMD:
	BSBW	SETUP_IVCMD		; Setup to log invalid command data.
					; Returns R2 => MSCP command to reconstruct.
	MOVZBL	#MSCP$K_OP_ONLIN,(R2)+	; Reconstruct opcode.
	CLRW	(R2)+			; Clear reserved word.

	ASSUME	MSCP$W_UNT_FLGS	EQ	MSCP$B_OPCODE+6
	MOVW	UCB$W_DU_UNT_FLGS(R3),(R2)+; Reconstruct unit flags.

	CLRQ	(R2)+			; Clear reserved fields.
	CLRL	(R2)+			; Clear reserved fields.

	ASSUME	MSCP$L_DEV_PARM	EQ	MSCP$W_UNT_FLGS+14
	MOVL	UCB$L_DU_DEV_PARM(R3),(R2)+; Reconstruct Device dependent parameters.
	CLRL	(R2)			; Clear rest of invalid command buffer.
	BSBW	LOG_IVCMD		; Call to log invalid command data.
	BISW	#CDRP$M_ERLOGIP,-	; Signal to log status.
		CDRP$W_STS(R5)
	BRB	END_PACKACK		; Branch around to end.

PACKACK_OFFLINE:

	BBC	#MSCP$V_SC_DUPUN,-	; Branch around if NOT duplicate
		MSCP$W_STATUS(R2),-	;  unit substatus.
		END_PACKACK
	PUSHL	R5			; Save R5.
	MOVL	R3,R5			; R5 => UCB for subroutine.
	BSBW	SEND_DUPUNIT		; Call to send OPCOM message.
	POPL	R5			; Restore R5.
	MOVZWL	#SS$_DUPUNIT,R0		; Return final status.
	BRB	END_PACKACK		; Branch around.
VALID_PACKACK:

	BISW	#UCB$M_VALID,-		; Set software volume valid.
		UCB$W_STS(R3)
END_PACKACK:
	CLRL	R1			; Clear R1, for I/O status block.
	BRW	FUNCTION_EXIT
	.PAGE
	.SBTTL	PACKACK Support Routines

;+
; RECORD_ONLINE - copy data form ONLINE END MESSAGE to UCB.
;
; Inputs:
;	R2 => End Message
;	R3 => UCB
;
; Outputs:
;	UCB fields set
;-

RECORD_ONLINE:

	MOVQ	MSCP$Q_UNIT_ID(R2),-	; In the event of success, copy unit
		UCB$Q_DU_UNIT_ID(R3)	;  characteristics data to UCB.
	MOVL	MSCP$L_MEDIA_ID(R2),-	; Starting with the UNIT ID, followed
		UCB$L_DU_MEDIAID(R3)	;  by the media identifier and
	PUSHL	R0			; Save R0.
	MOVL	MSCP$L_MEDIA_ID(R2),R0	; R0 = Media ID.
	BSBW	GET_DEVTYPE		; Returns R0 = DEVTYPE.
	MOVB	R0,UCB$B_DEVTYPE(R3)	; Store in UCB.
	POPL	R0			; Restore R0.
	MOVL	MSCP$L_UNT_SIZE(R2),-	; Then followed by the unit size and
		UCB$L_MAXBLOCK(R3)
	MOVL	MSCP$L_VOL_SER(R2),-	; Then by the volume serial number.
		UCB$L_DU_VOLSER(R3)
	MOVW	MSCP$W_UNT_FLGS(R2),-	; Copy new unit flags from end packet.
		UCB$W_DU_UNT_FLGS(R3)

	RSB				; Return to caller.

;+
; RECORD_UNIT_STATUS - copy data from GET UNIT STATUS End Message to UCB.
;
; Inputs:
;	R2 => MSCP End Message
;	R3 => UCB
;
; Outputs:
;	UCB fields filled
;	R0,R1 modified
;-

RECORD_UNIT_STATUS:

	MOVW	MSCP$W_TRACK(R2),-	; Copy data from End Message to UCB.
		UCB$W_DU_LBNPTRK(R3)	; LBN's per track.
	MOVW	MSCP$W_GROUP(R2),-	; Then tracks per group.
		UCB$W_DU_TRKPGRP(R3)
	MOVW	MSCP$W_CYLINDER(R2),-	; Groups per cylinder.
		UCB$W_DU_GRPPCYL(R3)
	MOVL	UCB$L_MAXBLOCK(R3),-	; Unit size in LBNs.
		UCB$L_DU_USIZE(R3)
	MOVW	MSCP$W_RCT_SIZE(R2),-	; Size of the RCT in blocks.
		UCB$W_DU_RCTSIZE(R3)
	MOVB	MSCP$B_RBNS(R2),-	; RBN's per track.
		UCB$B_DU_RBNPTRK(R3)
	MOVB	MSCP$B_RCT_CPYS(R2),-	; Number of RCT copies on the unit.
		UCB$B_DU_RCTCPYS(R3)

	MOVZBL	MSCP$B_RCT_CPYS(R2),R0	; R0 = # of RCT copies on the unit.
	MULW2	MSCP$W_RCT_SIZE(R2),R0	; R0 = size of RCT area.
	ADDL3	UCB$L_MAXBLOCK(R3),R0,-	; Size of user visible area plus size
		UCB$L_DU_TOTSZ(R3)	;  of RCT area is total size.

	MOVB	MSCP$W_TRACK(R2),-	; Init UCB devdepend fields.
		UCB$B_SECTORS(R3)	; Tracksize is number of sectors.
	CLRL	R0			; Clear Product.
	MULW3	MSCP$W_GROUP(R2),-	; Group size * cylinder size =
		MSCP$W_CYLINDER(R2),R0	;  # of tracks in a cylinder.
	MOVB	R0,UCB$B_TRACKS(R3)
	MULW2	MSCP$W_TRACK(R2),R0	; * #sectors/track = #sectors/cyl
	CLRL	-(SP)			; Put UCB$L_MAXBLOCK into low order
	PUSHL	UCB$L_MAXBLOCK(R3)	;  longword of workarea on stack.
	EDIV	R0,(SP)+,R0,R1		; UCB$L_MAXBLOCK/R0 ... quotient -> R0,
					;  remainder -> R1, workarea popped off
					;  stack.
	TSTL	R1			; Test for any remainder.
	BEQL	5$			; EQL means no remainder.
	INCL	R0			; If remainder, round up.
5$:					; Here R0 has # of cylinders.
	MOVW	R0,UCB$W_CYLINDERS(R3)

	RSB				; Return to caller.
	.PAGE
	.SBTTL	RECYCLE_ALL

; RECYCLE_ALL - internal subroutine to recyle 


; INPUTS:
;	R3 => UCB
;	R5 => CDRP (note CDRP must have IRP at negative offset)
;
; OUTPUTS:
;	RSPID recycled
;	MSG BUFFER recycled
;	R0 destroyed
;	CDRP$L_IOQBL(R5) destroyed (in IRP, Q header)
;

RECYCLE_ALL:

	POPL	CDRP$L_IOQBL(R5)	; Save return point in unused spot.
	RECYCL_MSG_BUF			; Recycle the End packet.
	RECYCL_RSPID			; Likewise the RSPID.

	MOVL	CDRP$L_MSG_BUF(R5),R2	; R2 => Message Buffer.

	ASSUME	MSCP$K_MXCMDLEN	EQ	36
	MOVL	R2,R1			; R1 => MSCP buffer to clear.
	CLRQ	(R1)+			; Zero out MSCP buffer to insure all
	CLRQ	(R1)+			;  reserved fields are clear.
	CLRQ	(R1)+			;
	CLRQ	(R1)+			;
	CLRL	(R1)			; Maximum length packet cleared.

	MOVL	CDRP$L_RSPID(R5),-	; Use RSPID as command reference
		MSCP$L_CMD_REF(R2)	;  number for all commands.

	MOVW	UCB$W_UNIT(R3),-	; Indicate UNIT number in MSCP
		MSCP$W_UNIT(R2)		;  packet.

	JMP	@CDRP$L_IOQBL(R5)	; Return to caller.
	.PAGE
	.SBTTL	START_UNLOAD and START_AVAILABLE

; START_AVAILABLE - Prepare an MSCP packet to do an AVAILABLE command without
;	the spindown modifier.
;
; START_UNLOAD - Prepare an MSCP packet to do an AVAILABLE command with
;	spindown specified.
;
; INPUTS:
;	R2 => MSCP buffer
;	R3 => UCB
;	R4 => PDT
;	R5 => CDRP
;
;	MSCP packet is zero except for MSCP$L_CMD_REF and MSCP$W_UNIT fields.
;

START_UNLOAD:

	MOVW	#MSCP$M_MD_SPNDW,-	; Specify the SPINDOWN bit in the
		MSCP$W_MODIFIER(R2)	;  modifier word.

START_AVAILABLE:

	MOVB	#MSCP$K_OP_AVAIL,-	; Transfer AVAILABLE opcode
		MSCP$B_OPCODE(R2)	;  to packet.

	BSBW	CALL_SEND_MSG_BUF	; Call common interface to SEND_MSG_BUF.

	BICW	#UCB$M_VALID,-		; Clear software volume valid.
		UCB$W_STS(R3)

; Here the command has completed in the controller.  CDRP$L_MSG_BUF and R2
;	both point to the END PACKET that was returned by the controller.

	CMPW	UCB$W_UNIT(R3),-	; For now sanity check.
		MSCP$W_UNIT(R2)
	BEQL	5$			; EQL is kosher.
	BUG_CHECK	DISKCLASS,FATAL
5$:
	BSBW	INTERPRET_ACTION_TABLE_N; Interpret Action Table for Non-transfer
					;  command.

	ACTION_ENTRY	MSCP$K_ST_SUCC,SS$_NORMAL,AVAILABLE_SUCC

	ACTION_ENTRY	MSCP$K_ST_OFFLN,SS$_MEDOFL,AVAILABLE_MEDOFL

	ACTION_ENTRY	MSCP$K_ST_ABRTD,SS$_ABORT,AVAILABLE_ABORT

	ACTION_ENTRY	MSCP$K_ST_DRIVE,SS$_DRVERR,AVAILABLE_DRVERR

	ACTION_ENTRY	MSCP$K_ST_CNTLR,SS$_CTRLERR,AVAILABLE_CTRLERR

	ACTION_ENTRY	MSCP$K_ST_ICMD,SS$_CTRLERR,AVAIL_IVCMD

	ACTION_ENTRY			; End of action table.

	BUG_CHECK	DISKCLASS,FATAL	; None of the legal status codes returned.

AVAIL_IVCMD:
	BSBW	SETUP_IVCMD		; Setup to log invalid command data.
					; Returns R2 => MSCP command to reconstruct.
	MOVZBL	#MSCP$K_OP_AVAIL,(R2)+	; Reconstruct opcode.
	CMPZV	#IRP$V_FCODE,-		; See if UNLOAD or AVAILABLE.
		#IRP$S_FCODE,-
		CDRP$W_FUNC(R5),-
		#IO$_UNLOAD
	BNEQ	10$			; UNLOAD needs SPIN DOWN modifier.
	ASSUME	MSCP$W_MODIFIER	EQ	MSCP$B_OPCODE+2
	MOVW	#MSCP$M_MD_SPNDW,-2(R2)
10$:
	CLRQ	(R2)+			; Clear rest of invalid command buffer.
	CLRQ	(R2)+
	CLRQ	(R2)
	BSBW	LOG_IVCMD		; Call to log invalid command data.
	BISW	#CDRP$M_ERLOGIP,-	; Signal to log status.
		CDRP$W_STS(R5)

AVAILABLE_SUCC:				; Action routine for MSCP$K_ST_SUCC.
AVAILABLE_MEDOFL:			; Action routine for MSCP$K_ST_MEDOFL.
AVAILABLE_ABORT:			; Action routine for MSCP$K_ST_ABORT.
AVAILABLE_DRVERR:			; Action routine for MSCP$K_ST_DRVERR.
AVAILABLE_CTRLERR:			; Action routine for MSCP$K_ST_CNTRL.
	CLRL	R1			; Clear R1, for I/O status block.
	BRW	FUNCTION_EXIT
	.PAGE
	.SBTTL	INTERPRET_ACTION_TABLE

;+
; INTERPRET_ACTION_TABLE - internal subroutine to interpret an action table.
;	An action table lists MSCP status codes, SS$_ status codes and the
;	offset of a routine that should be JMP'ed to if the MSCP status
;	code in the gievn END MESSAGE is equal to the MSCP status code of
;	the given entry in the action table.
;
; Action table entries contain three fields:
;
;		a) offset of the program code to which to JMP.
;			NOTE that this field must be the first field
;			     in the Action table entry (ATE) so that
;			     the address of the entry is the same as the
;			     address of this field.
;		b) MSCP status code returned by this End Message.
;
;		c) SS$_ status to be code returned to user's IOSB.
;
;	The end of an action table is denoted by a zero word.
;
; INTERPRET_ACTION_TABLE_N - alternate entry for non-data transfer commands.
;	Everything exactly the same except that the SS$_ code found is returned
;	in the low order word of R0 with the high order word clear while
;	for INTERPRET_ACTION_TABLE we return this SS$_ code in the high order
;	word of R0.  This latter action is to facilitate the shifting of the
;	IOSB return data with the byte count starting in the high order word
;	of R0.
;
; INPUTS:
;	R2 => MSCP END MESSAGE
;	(SP) => action table
;
; OUTPTUS:
;	R0 = SS$_ code.  In high order word of R0 for INTERPRET_ACTION_TABLE and
;				in the low order word for INTERPRET_ACTION_TABLE_N.
;
;	Each action table entry (ATE) is scanned to find one whose MSCP status
;		code matches the major status code of the R2 => END MESSAGE.
;		If a match is found, we calculate the address of the action
;		routine and branch to it.  If however, the action table ends
;		(first word of the entry = 0) we JMP to the byte following this
;		zero word.
;
;	Note R0 and R1 are modified.
;
;-

INTERPRET_ACTION_TABLE:

	POPL	R0			; R0 => Action table (1st entry).
	EXTZV	#MSCP$V_ST_MASK,-	; Extract major status code returned
		#MSCP$S_ST_MASK,-	;  in End Packet.
		MSCP$W_STATUS(R2),R1

10$:
	CMPB	ATE_MSCPCODE(R0),R1	; See if Action Table Entry corresponds
					;  to returned MSCP status.
	BNEQ	20$			; NEQ implies NO.

	CVTWL	ATE_OFFSET(R0),R1	; R1 contains offset of action routine.
	ADDL	R0,R1			; R1 => action routine.
	MOVL	ATE_SSCODE-2(R0),R0	; Move SS$_ code to HI order of R0.
	JMP	(R1)			; Jump to action routine.
20$:
	MOVAB	ATE_ENTRY_LEN(R0),R0	; R0 => next ATE.
	TSTW	(R0)			; See if at end of table.
	BNEQ	10$			; If not, branch back.
	JMP	2(R0)			; JMP to code beyond end of action table.

INTERPRET_ACTION_TABLE_N:		; Entrypoint for NON_data_transfer commands.

	POPL	R0			; R0 => Action table (1st entry).
	EXTZV	#MSCP$V_ST_MASK,-	; Extract major status code returned
		#MSCP$S_ST_MASK,-	;  in End Packet.
		MSCP$W_STATUS(R2),R1

10$:
	CMPB	ATE_MSCPCODE(R0),R1	; See if Action Table Entry corresponds
					;  to returned MSCP status.
	BNEQ	20$			; NEQ implies NO.

	CVTWL	ATE_OFFSET(R0),R1	; R1 contains offset of action routine.
	ADDL	R0,R1			; R1 => action routine.

; Following instruction is the only difference between these two entrypoints.
	MOVZWL	ATE_SSCODE(R0),R0	; Move SS$_ code to LOW order of R0.

	JMP	(R1)			; Jump to action routine.
20$:
	MOVAB	ATE_ENTRY_LEN(R0),R0	; R0 => next ATE.
	TSTW	(R0)			; See if at end of table.
	BNEQ	10$			; If not, branch back.
	JMP	2(R0)			; JMP to code beyond end of action table.
	.PAGE
	.SBTTL	START_READPBLK and START_WRITEPBLK and START_WRITECHECK

; START_READPBLK - Prepare an MSCP packet to do a READ command.
;
; START_WRITEPBLK - Prepare an MSCP packet to do a WRITE command.
;
; START_WRITECHECK - Prepare an MSCP packet to do a COMPARE HOST DATA command.
;
; INPUTS:
;	R2 => MSCP buffer
;	R3 => UCB
;	R4 => PDT
;	R5 => CDRP
;
;	MSCP packet is zero except for MSCP$L_CMD_REF and MSCP$W_UNIT fields.
;

	.ENABLE	LSB

PHYS_IO:				; Out of line code to handle "physical"
					;  READ operations.  I.e. reads of RCT.
	CMPL	MSCP$L_LBN(R2),-	; Make sure block to be read within
		UCB$L_DU_TOTSZ(R3)	;  limits of disk.
	BGEQ	3$			; GEQ implies NOT on the disk.
	CMPL	MSCP$L_LBN(R2),-	; Make sure block to be read within
		UCB$L_MAXBLOCK(R3)	;  RCT area.
	BLSS	3$			; LSS implies NOT in RCT.
	CMPL	#512,MSCP$L_BYTE_CNT(R2); Reads of RCT should be 1 block only.
	BGEQ	24$			; GEQ implies only reading one block
					;  so we return to inline code.
	MOVZWL	#SS$_IVBUFLEN,R0	; Else indicate error and branch around.
	BRB	6$
3$:
	MOVZWL	#SS$_IVADDR,R0		; Bad address on disk.
6$:
	CLRL	R1			; Clear for I/O status block.
	BRW	FUNCTION_EXIT		; And goto common function exit.

START_WRITECHECK:

	MOVB	#MSCP$K_OP_COMP,-	; Compare host data opcode
		MSCP$B_OPCODE(R2)	;  to packet.
	BRB	20$			; Branch around to join common code

START_WRITEPBLK:

	MOVB	#MSCP$K_OP_WRITE,-	; Transfer WRITE opcode
		MSCP$B_OPCODE(R2)	;  to packet.
	BRB	10$

START_READPBLK:

	MOVB	#MSCP$K_OP_READ,-	; Transfer READ opcode
		MSCP$B_OPCODE(R2)	;  to packet.

10$:

	BBC	#IO$V_DATACHECK,-	; See if user specified compare in
		CDRP$W_FUNC(R5),20$	;  addition to data transfer. If not, branch.
	BISW	#MSCP$M_MD_COMP,-	; Else OR in compare modifier.
		MSCP$W_MODIFIER(R2)
20$:
	MOVL	CDRP$L_BCNT(R5),-
		MSCP$L_BYTE_CNT(R2)	; Copy byte count of transfer.
	MOVL	CDRP$L_MEDIA(R5),-
		MSCP$L_LBN(R2)		; And also the Logical Block Number.

	BBS	#IRP$V_PHYSIO,-		; Branch out of line if physical I/O.
		CDRP$W_STS(R5),PHYS_IO
24$:
	MOVAB	CDRP$T_LBUFHNDL(R5),-	; Put address of Local BUFfer HaNDLe
		CDRP$L_LBUFH_AD(R5)	;  field into field that points to it.
	MAP_IRP				; Allocate mapping resources and load
					;  them with data from SVAPTE, BOFF,
					;  and BCNT derived from IRP within
					;  CDRP.

	MOVL	CDRP$L_MSG_BUF(R5),R2	; Refresh R2 => MSCP packet.
	MOVQ	CDRP$T_LBUFHNDL(R5),-	; Copy contents of buffer handle to
		MSCP$B_BUFFER(R2)	;  MSCP buffer descriptor field.
	MOVL	CDRP$T_LBUFHNDL+8(R5),-	; Buffer handle is 96 bits (12 bytes)
		MSCP$B_BUFFER+8(R2)	;  in length.

	BSBW	CALL_SEND_MSG_BUF	; Call common interface to SEND_MSG_BUF.

; Here the command has completed in the controller.  CDRP$L_MSG_BUF and R2
;	both point to the END PACKET that was returned by the controller.

	BSBW	INTERPRET_ACTION_TABLE	; Call to interpret following action
					;  table

	ACTION_ENTRY	MSCP$K_ST_SUCC,SS$_NORMAL,TRANSFER_RTN_BCNT

	ACTION_ENTRY	MSCP$K_ST_AVLBL,SS$_MEDOFL,TRANSFER_RTN_BCNT

	ACTION_ENTRY	MSCP$K_ST_OFFLN,SS$_MEDOFL,TRANSFER_RTN_BCNT

	ACTION_ENTRY	MSCP$K_ST_DATA,SS$_FORCEDERROR,TRANSFER_DATA_ERROR

	ACTION_ENTRY	MSCP$K_ST_DRIVE,SS$_DRVERR,TRANSFER_RTN_BCNT

	ACTION_ENTRY	MSCP$K_ST_CNTLR,SS$_CTRLERR,TRANSFER_RTN_BCNT

	ACTION_ENTRY	MSCP$K_ST_WRTPR,SS$_WRITLCK,TRANSFER_RTN_BCNT

	ACTION_ENTRY	MSCP$K_ST_COMP,SS$_DATACHECK,TRANSFER_RTN_BCNT

	ACTION_ENTRY	MSCP$K_ST_MFMTE,SS$_FORMAT,TRANSFER_RTN_BCNT

	ACTION_ENTRY	MSCP$K_ST_ABRTD,SS$_ABORT,TRANSFER_RTN_BCNT

	ACTION_ENTRY	MSCP$K_ST_ICMD,SS$_CTRLERR,TRANSFER_INVALID_COMMAND

	ACTION_ENTRY	MSCP$K_ST_HSTBF,SS$_BUGCHECK,TRANSFER_HOST_BUFFER_ERROR ; For now only.

	ACTION_ENTRY			; End of table.

	BUG_CHECK	DISKCLASS,FATAL	; For now, if undefined MSCP status.

TRANSFER_INVALID_COMMAND:

	BSBW	SETUP_IVCMD		; Setup to log IVCMD. Returns R2 =>
					;  IVCMD buffer at MSCP$B_OPCODE offset.

	EXTZV	#IRP$V_FCODE,-		; Extract I/O function code.
		#IRP$S_FCODE,-
		CDRP$W_FUNC(R5),R1

	ASSUME	IO$_WRITECHECK	EQ   10
	ASSUME	IO$_WRITEPBLK	EQ   11
	ASSUME	IO$_READPBLK	EQ   12
	MOVB	TRANSF_OPCODES-IO$_WRITECHECK[R1],R1	; R1 has MSCP opcode.
	MOVZBL	R1,(R2)+				; Move to IVCMD buffer.

	CMPB	#MSCP$K_OP_COMP,R1	; Well was it WRITECHECK?
	BEQL	26$			; If so branch around.
	BBC	#IO$V_DATACHECK,-	; See if user specified compare in
		CDRP$W_FUNC(R5),26$	;  addition to data transfer. If NOT, branch.

	ASSUME	MSCP$W_MODIFIER	EQ	MSCP$B_OPCODE+2
	BISW	#MSCP$M_MD_COMP,-2(R2)	; Else OR in compare modifier.
26$:
	ASSUME	MSCP$L_BYTE_CNT	EQ	MSCP$W_MODIFIER+2
	MOVL	CDRP$L_BCNT(R5),(R2)+

	ASSUME	MSCP$B_BUFFER	EQ	MSCP$L_BYTE_CNT+4
	MOVQ	CDRP$T_LBUFHNDL(R5),(R2)+	; Reconstruct buffer handle.
	MOVL	CDRP$T_LBUFHNDL+8(R5),(R2)+

	ASSUME	MSCP$L_LBN	EQ	MSCP$B_BUFFER+12
	MOVL	CDRP$L_MEDIA(R5),(R2)+	; Reconstruct media address.
	CLRL	(R2)			; Clear out last longword of buffer.

	BSBW	LOG_IVCMD		; Call to log IVCMD buffer.

	BBCS	#CDRP$V_ERLOGIP,-	; Only retry this once.
		CDRP$W_STS(R5),35$	; If clear, first time so goto retry.
	CLRL	R1			; Clear for I/O status block.
	BRW	FUNCTION_EXIT		; Goto terminate I/O.

TRANSFER_HOST_BUFFER_ERROR:

	BUG_CHECK	DISKCLASS,FATAL	; Only for now.

TRANSFER_DATA_ERROR:			; TRANSFER action routine for MSCP$K_ST_DATA.
					; Here R0 contains SS$_FORCEDERROR in
					;  high order word.
	MOVZWL	MSCP$W_STATUS(R2),R1	; Zero extend MSCP status.

;	ASSUME THAT FORCED ERROR SUBCODE IS ZERO.

	ASHL	#MSCP$S_ST_MASK,R1,R1	; Shift out major status code.
	BEQL	TRANSFER_RTN_BCNT	; EQL implies that it was forced error
					;  so we simply branch since we already
					;  have R0 set up.
	MOVL	#SS$_PARITY@16,R0	; Else set up R0 with proper SS$_ code
					;  in high order word.
					; And fall thru to following code.

TRANSFER_RTN_BCNT:			; Common TRANSFER action routine.
					; Here R0 contains SS$_ code in hi order..
	MOVL	MSCP$L_BYTE_CNT(R2),R1	; Get # bytes actually transferred.
	ASHQ	#-16,R0,R0		; Shift into proper position for IOSB.

	BBS	#MSCP$V_EF_BBLKR,-	; Branch if a bad block has been
		MSCP$B_FLAGS(R2),-	;  reported and therefore means we
		TRANSFER_REPLACE		;  must replace it.
NORMAL_TRANSFEREND:
	BRW	FUNCTION_EXIT		; If NOT, goto common exit.

TRANSFER_REPLACE:			; Here perform Bad Block Replacement.

	BBC	#MSCP$V_EF_ERLOG,-	; Branch around if End Message does NOT
		MSCP$B_FLAGS(R2),30$	;  have ERLOG flag set.
	BISW	#CDRP$M_ERLOGIP,-	; Else set corresponding bit in CDRP to
		CDRP$W_STS(R5)		;  remember this fact.
30$:
	MOVQ	R0,CDRP$L_IOQFL(R5)	; Store valid I/O status in unused
					;  FLINK and BLINK of IRP portion.
	BSBW	LOCK_HIRT		; Grab hold of HIRT.
	BSBW	REPLACE_LBN		; Call subroutine to accomplish
					;  replacement.
	PUSHL	R0			; Save replacement status.
	PUSHL	R1			; Save ERLOGIP bit setting.
	BSBW	UNLOCK_HIRT		; Release HIRT.
	POPL	R1			; Restore ERLOGIP setting.
	BISW	R1,CDRP$W_STS(R5)	; Set ERLOGIP bit if on in R1.
	MOVQ	CDRP$L_IOQFL(R5),R0	; Restore I/O status of original QIO.
	POPL	R2			; Restore replacement status to R2.
	BLBC	R2,60$			; LBC means unsuccessful replacement.

					; If here replacement successful
	BLBS	R0,NORMAL_TRANSFEREND	; LBS means original I/O was success.
	
35$:
	PUSHL	CDRP$L_RSPID(R5)	; Save current RSPID so as to possibly
					;  reuse.
	BBS	#CDRP$V_ERLOGIP,-	; If set, we reuse RSPID so that error
		CDRP$W_STS(R5),40$	;  log messages co-relate. So we branch.
	CLRL	(SP)			; If no errorlog, erase RSPID to prevent
	BRB	50$			;  spurious deallocates and branch.
40$:
	CLRL	CDRP$L_RSPID(R5)	; Prevent current RSPID from being deallocated.
50$:
	BSBW	RECYCLE_RESOURCES	; Free resources owned by this CDRP before
					;  retrying operation.
	POPL	CDRP$L_RSPID(R5)	; Restore RSPID or zero to CDRP.
	BRW	DU_RESTARTIO		; Else go to retry the original request.
60$:
	MOVW	R2,R0			; Replace failed replacement status.
	BRB	NORMAL_TRANSFEREND	; And branch to FUNCTION_EXIT.
	.DISABLE	LSB

	ASSUME	IO$_WRITECHECK	EQ   10
	ASSUME	IO$_WRITEPBLK	EQ   11
	ASSUME	IO$_READPBLK	EQ   12
TRANSF_OPCODES:
	.BYTE	MSCP$K_OP_COMP		; MSCP opcodes corresponding to
	.BYTE	MSCP$K_OP_WRITE		;  IO$_WRITECHECK, IO$_WRITEPBLK,
	.BYTE	MSCP$K_OP_READ		;  and IO$_READPBLK.

;; This code previously resided prior to label 24$ above.  It is left here
;;	as reference material.
;;
;	BBC	#IRP$V_PHYSIO,-		; Branch around if NOT physical I/O.
;		CDRP$W_STS(R5),24$
;	BBC	#IRP$V_FUNC,-		; Branch around if NOT read function.
;		CDRP$W_STS(R5),24$
;
;; Here if this is a read physical function.  We must back translate the
;;	physical media address to an LBN.
;;
;; User specified physical media address has following format: (in CDRP$L_MEDIA)
;;
;;	._______________________________._______________._______________.
;;	!				!		!		!
;;	!         Cylinder		!     Track	!     Sector	!
;;	!_______________________________!_______________!_______________!
;
;
;	MOVZBL	UCB$B_TRACKS(R3),R0	; R0 = tracks/cylinder.
;	MOVZBL	UCB$B_SECTORS(R3),R1	; R1 = sectors/track.
;	MULL	R1,R0			; R0 = sectors/cylinder.
;	MOVZWL	CDRP$L_MEDIA+2(R5),-(SP); Push user specified cylinder #.
;	MULL	R0,(SP)			; (SP) = LBN of 1st sector in cylinder.
;	MOVZBL	CDRP$L_MEDIA+1(R5),R0	; R0 = user specified track #.
;	MULL	R0,R1			; R1 = relative LBN of 1st sector on track.
;	MOVZBL	CDRP$L_MEDIA(R5),R0	; R0 = user specified sector #.
;	ADDL	R0,R1			; R1 = relative LBN of user sector.
;	ADDL3	R1,(SP)+,MSCP$L_LBN(R2)	; Deposit calculated LBN into packet.
	.PAGE
	.SBTTL	LOCK_HIRT

;+
; LOCK_HIRT - grab exclusive access to the H(ost) I(initiated) bad block
;	R(eplacement) T(able).  Also we lockout new activity on the UNIT
;	by bumping UCB$W_RWAITCNT.
;
; INPUTS:
;
;	R3 => UCB
;	R5 => Fork Block
;
; OUTPUTS:
;	HIRT is owned by caller.  Caller may be suspended.
;
; SIDE EFECTS:
;	Registers R0, R1, and R2 may be modified.
;

LOCK_HIRT:

	BBS	#HIRT$V_ACTIVE,-	; Make sure HIRT is active.
		HIRT$W_STS,5$
	BUG_CHECK	DISKCLASS,FATAL
5$:
	INCW	UCB$W_RWAITCNT(R3)	; Prevent new CDRP's from being begun
					;  on this UCB.
	BBCS	#HIRT$V_BUSY,-		; Allocate the Host Initiated Replace-
		HIRT$W_STS,10$		;  ment Table (HIRT).

	MOVQ	R3,FKB$L_FR3(R5)	; If here, already allocated, save
	POPL	FKB$L_FPC(R5)		;  thread context in fork block.

; Here we thread R5 => FORK BLOCK onto the tail of the singly threaded list
;	of fork blocks awaiting use of the HIRT.  The listhead is a quadword
;	whose first longword points to the first fork block on the list and
;	whose second longword points to the last forkblock on the list.  An
;	empty list is characterized by having the first longword contain
;	a zero with the second longword pointing to the first longword.
;	Each fork block on the list, has the first longword of its link
;	quadword pointing to the next fork block on the list, with the
;	last fork block containing a zero in this longword.  The second
;	longword of each fork block's link quadword contains the address
;	of the CDDB of the intelligent controller associated with the
;	device unit for which we want to gain exclusive use of the HIRT.
;
; Note the reason for CDDB address here is to facilitate finding CDRPs
;	associated with a CONNECTION that has failed (gone down).
;

	CLRL	FKB$L_FQFL(R5)		; Prepare this fork block to be at
					;  tail of the list.
	MOVL	UCB$L_DU_CDDB(R3),-	; Second longword of link quadword
		FKB$L_FQBL(R5)		;  points to CDDB.
	MOVAB	FKB$L_FQFL(R5),-	; Move address of this fork block into
		@HIRT$L_RPLQTP		;  forward ptr of previous tail.
	MOVAB	FKB$L_FQFL(R5),-	; Also move address of this fork block
		HIRT$L_RPLQTP		;  to list tail pointer.
	RSB				; Terminate this execution thread by
					;  returning to caller's caller.

10$:					; Here we now own the HIRT.
	BSBB	GRANT_HIRT		; Call to initialize various structures
					;  with data of the new HIRT owner.
	RSB				; And return to caller who now owns HIRT.

; GRANT_HIRT - internal subroutine, called from LOCK_HIRT and UNLOCK_HIRT,
;	upon granting ownership of the HIRT to a thread.  GRANT_HIRT
;	initializes various data fields to reflect this ownership and to
;	facilitate the thread's use of the HIRT CDRP.
;
;	Note: Since both subroutines that require ownership of the HIRT,
;		REPLACE_LBN and ONLINE_COMPLETE, make use of the user's
;		original RSPID so as to be able to co-relate all Error Log
;		messages generated by a user I/O request, GRANT_HIRT passes
;		the RSPID form the user CDRP to the HIRT permanent CDRP.
;
; Inputs:
;	R3 => UCB
;	R5 => user CDRP
;Outputs:
;	Various HIRT and CDRP fields updated.
;

GRANT_HIRT:

	PUSHL	CDRP$L_RSPID(R5)	; Pass current RSPID to HIRT CDRP.
	CLRL	CDRP$L_RSPID(R5)	; Prevent spurious deallocates.
	MOVL	R5,HIRT$L_SAVDCDRP	; Save given R5.
	MOVAB	HIRT$L_SUBSTACK,-	; Initialize SUBSTACK in HIRT.
		HIRT$L_STKPTR

	MOVL	R3,HIRT$L_OWNUCB	; Indicate who owns HIRT.

	MOVZWL	(SP),R5			; R5 = index of RDTE for RSPID.
	PUSHL	R0			; Save register.
	MOVL	G^SCS$GL_RDT,R0		; R0 => base of the RDT.
	MOVAQ	(R0)[R5],R5		; R5 => RDTE of interest.
	CMPL	HIRT$L_SAVDCDRP,-	; For sanity, make sure RDTE belongs
		RD$L_CDRP(R5)		;  to user CDRP.
	BEQL	10$			; EQL implies OK.
	BUG_CHECK	DISKCLASS,FATAL	; Major inconsistancy.
10$:
	MOVL	HIRT$L_CDRP,-		; For now pass ownership of RDTE to HIRT
		RD$L_CDRP(R5)		;  permanent CDRP.
	POPL	R0
	MOVL	HIRT$L_CDRP,R5		; R5 => permanent replacement CDRP.
	POPL	CDRP$L_RSPID(R5)	; Pickup RSPID to use thruout replacement.
	CLRL	CDRP$L_LBUFH_AD(R5)	; Indicate no resources yet allocated
	CLRL	CDRP$L_MSG_BUF(R5)	;  except RSPID.
	MOVL	R3,CDRP$L_UCB(R5)	; Make HIRT permanent CDRP => this UCB.
					;  This allow UNIBUS mapping to work.
	MOVL	UCB$L_CDT(R3),-		; Place CDT pointer into CDRP for handy
		CDRP$L_CDT(R5)		;  reference by SCS routines.  Note thie
					;  must be done each time the HIRT is
					;  locked since we may be using a different
					;  port (and therefore CONNECTION) each
					;  time.
	MOVAB	UCB$W_RWAITCNT(R3),-	; Point CDRP field to UCB field.
		CDRP$L_RWCPTR(R5)
	BICW	#HIRT$M_ERLOGIP,-	; Initialize bit.
		HIRT$W_STS
	RSB				; Return to caller.
	.PAGE
	.SBTTL	UNLOCK_HIRT

;+
; UNLOCK_HIRT - Caller wishes to relinquish exclusive control of the HIRT.
;	It becomes the current owner's obligation to restart the first
;	thread (if any are there) that may be waiting on the HIRT wait
;	list.
;
;	NOTE: UNLOCK_HIRT passes back the user's RSPID from the HIRT permanent
;		CDRP to the user's CDRP.
;
; INPUTS:
;	HIRT owned by caller
;	R3 => UCB of HIRT owner
;
; OUTPUTS:
;	HIRT ownership relinquished. If any threads are on the HIRT wait list,
;		first of these is granted HIRT ownership and is started up.
;
;	R5 => Original CDRP.
;	All other registers are preserved.
;

UNLOCK_HIRT:

	DECW	UCB$W_RWAITCNT(R3)	; Decrement to again allow normal I/O.

	MOVL	HIRT$L_CDRP,R5		; R5 => HIRT CDRP.
	PUSHL	CDRP$L_RSPID(R5)	; Save current RSPID so as to restore to
					;  user CDRP.
	CLRL	CDRP$L_RSPID(R5)	; Prevent spurious deallocates.

	MOVZWL	(SP),R5			; R5 = index of RDTE for RSPID.
	PUSHL	R0			; Save register.
	MOVL	G^SCS$GL_RDT,R0		; R0 => base of the RDT.
	MOVAQ	(R0)[R5],R5		; R5 => RDTE of interest.
	CMPL	HIRT$L_CDRP,-		; For sanity, make sure RDTE belongs
		RD$L_CDRP(R5)		;  to HIRT permanent CDRP.
	BEQL	5$			; EQL implies OK.
	BUG_CHECK	DISKCLASS,FATAL	; Major inconsistancy.
5$:
	MOVL	HIRT$L_SAVDCDRP,-	; Now pass ownership of RDTE back
		RD$L_CDRP(R5)		;  to user CDRP.
	POPL	R0

	MOVL	HIRT$L_SAVDCDRP,R5	; Restore R5 => original CDRP.
	POPL	CDRP$L_RSPID(R5)	; restore user's original RSPID.
	TSTL	HIRT$L_RPLQFL		; Determine if HIRT wait list is empty.
	BEQL	20$			; EQL implies list empty.

	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save caller's registers.

	MOVL	HIRT$L_RPLQFL,R5	; R5 => 1st fork block on list.
	MOVL	FKB$L_FQFL(R5),-	; Replace 1st fork block on list with
		HIRT$L_RPLQFL		;  next fork block.
	BNEQ	10$			; NEQ implies there was a next fork block.
	MOVAB	HIRT$L_RPLQFL,-		; Else wait list is now empty, so re-
		HIRT$L_RPLQTP		;  direct list Tail Pointer to listhead.
10$:
	MOVQ	FKB$L_FR3(R5),R3	; Restore waiting thread's context.
	BSBW	GRANT_HIRT		; Call to initialize various structures
					;  with data of the new HIRT owner.

	JSB	@FKB$L_FPC(R5)		; Resume waiting thread.

	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore relinquisher's registers.
	RSB				; And return to relinquisher.

20$:					; If here, list was empty.
	BICW	#HIRT$M_BUSY,HIRT$W_STS	; So mark HIRT as NOT busy.
	RSB				; And return to relinquisher.
	.PAGE
	.SBTTL	REPLACE_LBN

;+
; REPLACE_LBN - internal subroutine to perform dynamic bad block replacement.
;	At the time of invocation, the HIRT is already owned by the caller.
;	Also entry to this routine made be made by branching (from subroutine
;	ONLINE_COMPLETE) to labels STEP7 and STEP11.
;
; INPUTS:
;	R3 => UCB
;	R5 => HIRT permanent CDRP
;	HIRT permanent CDRP$L_RSPID contains user RSPID
;	HIRT$L_SAVDCDRP => original user CDRP
;	HIRT owned by caller which implies HIRT SUBSTACK is operative
;
; OUTPUTS:
;


REPLACE_LBN:

	HIRT_SUBSAVE			; Save callers return point on SUBSTACK.
	MOVL	HIRT$L_SAVDCDRP,R0	; R0 => original CDRP.
	MOVL	CDRP$L_MSG_BUF(R0),R0	; R0 => END PACKET.
	MOVL	MSCP$L_FRST_BAD(R0),-	; Indicate which LBN we are
		HIRT$L_LBN		;  fixing on this unit.

; Invalidate contents of incore scratch pages.

	ASSUME	HIRT$W_PG0CNTNT+2	EQ	HIRT$W_PG1CNTNT
	MNEGL	#1,HIRT$W_PG0CNTNT	; Invalidate pages 0 and 1.

	ASSUME	HIRT$W_PG2CNTNT+2	EQ	HIRT$W_PG3CNTNT
	MNEGL	#1,HIRT$W_PG2CNTNT	; Invalidate pages 2 and 3.


	ALLOC_MSG_BUF			; Allocate a send credit.
	BLBS	R0,10$			; Branch around if successful alloc.
	BRW	REPLACE_CONNECT_FAILURE	; If we had an allocation failure branch,
10$:

; STEP 4 of replacement algorithm.
; We clear (zero) a sector sized buffer, then read the  current
;   contents  of  the bad block into the buffer.  The buffer is cleared first
;   for the rare case when no data can be transferred (such as a  valid  sync
;   pattern  is not detected).  The read is performed with error recovery and
;   error correction enabled.  In addition to saving the  data,  we
;   remember  whether  or  not  the  read  succeeded.   The  saved  data  is
;   considered valid if the read succeeded, or invalid if it did not.
;

; First we zero out the buffer to receive the contents of the failing block.

	PUSHR	#^M<R2,R3,R4,R5>	; Save registers.
	MOVC5	#0,.,#0,#512,-		; Clear page 1 prior to read.
		@HIRT$L_PAGE1PTR
	POPR	#^M<R2,R3,R4,R5>	; Restore registers.

; Step 4 continued.  Prepare the CDRP with SVAPTE, BOFF, and BCNT of page 1
;	(receiving field for upcoming read) so as to facilitate mapping of
;	this region.

	MOVL	#1,R0			; Pass page to map to subroutine.
	BSBW	MAP_PAGE		; Map page 1.

; Step 4 continued. Prepare the MSCP packet to read failing block into page 1.

	BSBW	FILL_RCT_PACKET		; Subroutine that fills most fields in
					;  MSCP packet. Returns R2=>MSCP packet.
	MOVB	#MSCP$K_OP_READ,-	; Copy the READ opcode, field not filled
		MSCP$B_OPCODE(R2)	;  by above subroutine.
	MOVL	HIRT$L_LBN,-		; And also the LBN of the bad block.
		MSCP$L_LBN(R2)

	BSBW	CALL_SEND_MSG_BUF	; Send MSCP packet thru port to controller.

	BBC	#MSCP$V_EF_ERLOG,-	; Test for error log message generated
		MSCP$B_FLAGS(R2),15$	;  and branch around if not.
	BISW	#HIRT$M_ERLOGIP,-	; Else remember that error log messages
		HIRT$W_STS		;  Have been generated.
15$:

	UNMAP				; Release mapping resources.
	CLRL	CDRP$L_LBUFH_AD(R5)	; Show no mapping resources allocated.
	MOVL	CDRP$L_MSG_BUF(R5),R2	; Refresh R2 after unmap.

; Remember status of read of failing block so as to be able to write it later
; 	with or without the forced error flag.

	BICW	#HIRT$M_FE,HIRT$W_STS	; Initialize bit.
	CMPZV	#MSCP$V_ST_MASK,-	; Compare major status code to
		#MSCP$S_ST_MASK,-	;  see if READ succeeded.
		MSCP$W_STATUS(R2),-
		#MSCP$K_ST_SUCC
	BEQL	20$			; If read succeeded no force error.
	BISW	#HIRT$M_FE,HIRT$W_STS	; Set bit if read failed.
20$:

; Step 5.
;  Record the data obtained when the bad block was read  during  step  4  in
;  sector  1  of each RCT copy.  If the data cannot be successfully recorded
;  in the RCT, report the error to the error log and go to  step  18.   Note
;  that  the  Multi-Write algorithm used to record the data in sector 1 uses
;  write-compare operations to  guarantee  that  the  data  is  successfully
;  recorded.
;

STEP5:

; Write contents of page 1 to sector 1 of each RCT copy.

	MOVL	#1,R0			; Pass sector and page number to routine,
	MOVW	R0,HIRT$W_PG1CNTNT	; Indicate that page 1 contains RCT sector
					;  #1.
	BSBW	WRITE_RCT_BLOCK		; Call internal subroutine to write.
	BLBS	R0,STEP6		; LBS implies successful write to at
					;  least one RCT copy.
; ****************
; ENTER THIS FAILURE IN ERROR LOG
; ****************

	BRW	STEP18			; And branch to step 18.

; Step 6. Record bad block's LBN, whether or not the saved data is valid and
;	the fact that we are now in phase 1 of replacement in sector 0 of each
;	RCT copy.  This means that we read sector 0 modify it and
;	then rewrite the updated sector to each RCT copy.  If we cannot
;	read any sector 0 successfully, we go to step 18.  If we cannot
;	successfully write at least one sector 0, we go to step 17.

STEP6:
	CLRQ	R0			; Prepare to read sector #0 into page #0.
					;  We pass the page number in R0 and
					;  the sector number in R1.

	BSBW	READ_RCT_BLOCK		; Call to read RCT block.
	BLBS	R0,10$			; LBS implies successful read.
					;  least one RCT copy.
; ****************
; ENTER THIS FAILURE IN ERROR LOG
; ****************

	BRW	STEP18			; On failure goto step 18.
10$:
	MOVL	HIRT$L_PAGE0PTR,R0	; R0 => sector 0 in memory.
	MOVL	HIRT$L_LBN,-		; Copy bad block's LBN to RCT sector
		RCT$L_LBN(R0)		;  0 copy in memory.

	BISW	#RCT$M_RP1,RCT$W_FLAGS(R0); Set bit to signal phase 1.
	BICW	#RCT$M_RP2-		  ; Clear bit to signal not phase 2
		!RCT$M_BR-		  ;  clear bad RBN flag,
		!RCT$M_FE,-		  ;  and also clear force error before
		RCT$W_FLAGS(R0)		  ;  testing for valid data.

	BBC	#HIRT$V_FE,HIRT$W_STS,20$ ; See if original data is valid.
	BISW	#RCT$M_FE,-		  ; Set force error if appropriate.
		RCT$W_FLAGS(R0)
20$:
	CLRL	R0			; Rewrite page 0.
	BSBW	WRITE_RCT_BLOCK		; Go to rewrite sector 0.
	BLBS	R0,STEP7		; LBS implies successful rewrite.
; *********************
; ERROR LOG THIS CONDITION
; *********************

	BRW	STEP17			; And go to step 17.
; STEP7.
;  Write and read test patterns on the  suspected  bad  block  to  determine
;  whether  or  not  it  is  in  fact  a  bad  block.
;  Go  to  step  9  if  the  test  patterns  fail,
;  indicating  that  the  block  is indeed bad.  Continue with step 8 if the
;  test patterns succeed, indicating that the block may be good.   The  test
;  patterns  fail if either the block is again reported as a bad block or if
;  the test patterns cannot be written and read back correctly.
;

STEP7:
	MOVL	HIRT$L_PAGE2PTR,R2	; R2 => target page.
	MOVL	#TEST_PATTERN,R1	; Get test pattern to write to bad block.
	MOVZBL	#512/4,R0		; Loop counter set to # longwords in block.
10$:
	MOVL	R1,(R2)+		; Copy test pattern to page 2.
	SOBGTR	R0,10$			; Loop thru page.

	MOVL	#2,R0			; Pass page to map to subroutine.
	BSBW	MAP_PAGE		; Call to map page 2.

; Call subroutine that recycles current END PACKET, recycles current RSPID and
;	fills in most relevant data in the MSCP packet.

	BSBW	BUILD_RCT_PACKET	; Build a packet to transfer mapped
					;  page to random LBN.

	ASSUME	MSCP$W_MODIFIER  EQ  MSCP$B_OPCODE+2
	MOVL	#MSCP$K_OP_WRITE-	; Fill in field not prepared by
		!<MSCP$M_MD_COMP@16>,-	;  BUILD_RCT_PACKET.
		MSCP$B_OPCODE(R2)

	MOVL	HIRT$L_LBN,-		; Fill in field filled in incorrectly
		MSCP$L_LBN(R2)		;  by BUILD_RCT_PACKET.
	BSBW	CALL_SEND_MSG_BUF	; Call to send packet to controller.

	BBC	#MSCP$V_EF_ERLOG,-	; Test for error log message generated
		MSCP$B_FLAGS(R2),15$	;  and branch around if not.
	BISW	#HIRT$M_ERLOGIP,-	; Else remember that error log messages
		HIRT$W_STS		;  Have been generated.
15$:
	CMPZV	#MSCP$V_ST_MASK,-	; Compare major status code to
		#MSCP$S_ST_MASK,-	;  see if write succeeded.
		MSCP$W_STATUS(R2),-
		#MSCP$K_ST_SUCC
	BEQL	30$			; If so go check for bad block reported.
20$:
	UNMAP				; If write no good, give up resources.
	CLRL	CDRP$L_LBUFH_AD(R5)	; And show that deallocation was done.
	BRW	STEP9			; Proceed to next step of replacement.
30$:
	BBS	#MSCP$V_EF_BBLKR,-	; If bad block reported again on write,
		MSCP$B_FLAGS(R2),20$	;  then branch back to proceed with
					;  replacement.
40$:

; Clear page to receive test pattern written block.

	PUSHR	#^M<R2,R3,R4,R5>	; Save registers.
	MOVC5	#0,.,#0,#512,-		; Clear page 1 prior to read.
		@HIRT$L_PAGE2PTR
	POPR	#^M<R2,R3,R4,R5>	; Restore registers.

; Call subroutine that recycles current END PACKET, recycles current RSPID and
;	fills in most relevant data in the MSCP packet.

	BSBW	BUILD_RCT_PACKET	; Build MSCP packet to transfer page 2
					;  (which is stilled mapped).

	ASSUME	MSCP$W_MODIFIER  EQ  MSCP$B_OPCODE+2
	MOVL	#MSCP$K_OP_READ-	; Fill in field not prepared by
		!<MSCP$M_MD_COMP@16>,-	;  BUILD_RCT_PACKET.
		MSCP$B_OPCODE(R2)

	MOVL	HIRT$L_LBN,-		; Fill in field filled in incorrectly
		MSCP$L_LBN(R2)		;  by BUILD_RCT_PACKET.
	BSBW	CALL_SEND_MSG_BUF	; Call to send packet to controller.

	BBC	#MSCP$V_EF_ERLOG,-	; Test for error log message generated
		MSCP$B_FLAGS(R2),45$	;  and branch around if not.
	BISW	#HIRT$M_ERLOGIP,-	; Else remember that error log messages
		HIRT$W_STS		;  Have been generated.
45$:
	UNMAP				; Give up MAP resources.
	CLRL	CDRP$L_LBUFH_AD(R5)	; And show that deallocation was done.

	CMPZV	#MSCP$V_ST_MASK,-	; Compare major status code to
		#MSCP$S_ST_MASK,-	;  see if read succeeded.
		MSCP$W_STATUS(R2),-
		#MSCP$K_ST_SUCC
	BEQL	60$			; If so go check for bad block reported.
50$:
	BRW	STEP9			; On any error, goto step 9.
60$:
	BBS	#MSCP$V_EF_BBLKR,-	; If bad block reported on read,
		MSCP$B_FLAGS(R2),50$	;  then branch back to proceed with
					;  replacement of same.
	MOVL	HIRT$L_PAGE2PTR,R2	; R2 => target page.
	MOVL	#TEST_PATTERN,R1	; Test pattern to compare to bad block.
	MOVZBL	#512/4,R0		; Loop counter set to # longwords in block.
70$:
	CMPL	R1,(R2)+		; Compare test pattern to page 2.
	BNEQ	50$			; On any discrepancy, branch.
	SOBGTR	R0,70$			; Loop thru page.

; STEP8.
;  We write the saved data back out  to  the  bad  block  using  a
;  write-compare  operation.  The write-compare is performed with the "force
;  error" modifier if and only if the saved data is invalid.  Go to step  13
;  if the write-compare both succeeds AND the block is no longer reported as
;  a bad block -- the original problem was a transient.   The  write-compare
;  succeeds if no error is detected and the saved data is valid or if only a
;  forced error is detected and the saved data is invalid.
;

STEP8:

; Try to write original data out to block originally reported as bad since
;	error now appears to have been transient.

	MOVL	#1,R0			; Data from bad block is in page 1.
	BSBW	MAP_PAGE		; Map page 1.
	BSBW	BUILD_RCT_PACKET	; Recycle etc., and fill in packet.

	ASSUME	MSCP$W_MODIFIER  EQ  MSCP$B_OPCODE+2
	MOVL	#MSCP$K_OP_WRITE-	; Fill in field not prepared by
		!<MSCP$M_MD_COMP@16>,-	;  BUILD_RCT_PACKET.
		MSCP$B_OPCODE(R2)

	BBC	#HIRT$V_FE,HIRT$W_STS,10$ ; See if original data is valid.
	BISW	#MSCP$M_MD_ERROR,-	  ; Set force error modifier if
		MSCP$W_MODIFIER(R2)	  ;  original data is invalid.
10$:
	MOVL	HIRT$L_LBN,-		; Fill in field filled in incorrectly
		MSCP$L_LBN(R2)		;  by BUILD_RCT_PACKET.
	BSBW	CALL_SEND_MSG_BUF	; Call to send packet to controller.

	BBC	#MSCP$V_EF_ERLOG,-	; Test for error log message generated
		MSCP$B_FLAGS(R2),15$	;  and branch around if not.
	BISW	#HIRT$M_ERLOGIP,-	; Else remember that error log messages
		HIRT$W_STS		;  Have been generated.
15$:
	UNMAP				; If write no good, give up resources.
	CLRL	CDRP$L_LBUFH_AD(R5)	; And show that deallocation was done.
	MOVL	CDRP$L_MSG_BUF(R5),R2	; Refresh R2 => END PACKET after unmap.

	CMPZV	#MSCP$V_ST_MASK,-	; Compare major status code to
		#MSCP$S_ST_MASK,-	;  see if write succeeded.
		MSCP$W_STATUS(R2),-
		#MSCP$K_ST_SUCC
	BNEQ	STEP9			; If NOT, problem was NOT transient.
	BBS	#MSCP$V_EF_BBLKR,-	; If bad block reported on write,
		MSCP$B_FLAGS(R2),STEP9	;  then branch ahead to proceed with
					;  replacement of same.
	BRW	STEP13			; Branch if error was transient.

; STEP9.
;  We scan the RCT and determine  what  new  RBN  the  bad  block
;  should  be  replaced  with,  whether  or  not  the the bad block has been
;  previously replaced, and (if it has previously  been  replaced)  the  bad
;  block's  old  RBN.  The RCT is NOT updated at this time.  If the RCT scan
;  fails, we report the error to the error log and go to step 16.
;


STEP9:
	BSBW	SEARCH_RCT		; Routine to search the RCT for an RBN.
	BLBS	R0,STEP10		; LBC implies success, so goto step 10.

;****************
;
; ERROR LOG FAILURE TO FIND ALLOCATABLE RBN.  This failure is due to either
;	an unreadable RCT sector (HIRT$V_RCTFULL bit clear) or a full RCT
;	(HIRT$V_RCTFULL bit set).
;
;****************

	BRW	STEP16			; Branch to step 16 after failure.

; STEP10.
;  Record the new RBN, whether or not the  bad  block  has  been  previously
;  replaced,  the  bad block's old RBN (if it has been previously replaced),
;  and the fact that we are in phase 2 of bad block replacement in sector  0
;  of  each  RCT  copy.   The  RCT must be updated without reading sector 0,
;  instead using the copy of sector 0 last read from or written to the  RCT.
;  If the RCT cannot be updated, report the error to the error log and go to
;  step 16.
;


STEP10:
	MOVL	HIRT$L_PAGE0PTR,R0	; R0 => Page 0.
	MOVL	HIRT$L_RBN,-		; Update date to sector 0 copy in
		RCT$L_RBN(R0)		;  in memory.
	BBC	#HIRT$V_MATCH,-		; See if we had a failing RBN, and
		HIRT$W_STS,10$		;  if NOT, branch around.
	BISW	#RCT$M_BR,-		; Indicate failing RBN in sector 0
		RCT$W_FLAGS(R0)		;  flags word.
	MOVL	HIRT$L_MATCHRBN,-	; And also indicate the failing RBN.
		RCT$L_BAD_RBN(R0)
10$:
	BICW	#RCT$M_RP1,-		; Show that we are leaving phase 1
		RCT$W_FLAGS(R0)		;  of replacement processing.
	BISW	#RCT$M_RP2,-		; And entering phase 2.
		RCT$W_FLAGS(R0)

	CLRL	R0			; Rewrite page 0.
	BSBW	WRITE_RCT_BLOCK		; Go write the sector.
	BLBS	R0,STEP11		; If success, go to next step.

;***************
;
; ERROR LOG WRITE FAILURE.
;
;***************

	BRW	STEP16			; Branch on failure.

; STEP11.
;  We update the RCT to indicate  that  the  bad  block  has  been
;  replaced with the new RBN, and that the old RBN (if any) is unusable.  If
;  this requires updating two blocks in the RCT, then both  blocks  must  be
;  read  before  either is written.  If a block cannot be read successfully,
;  report the error to the error log and go to step 16.  If a  block  cannot
;  be written successfully, report the error to the error log and go to step
;  15.
;


STEP11:
	EXTZV	#0,#7,HIRT$L_RBN,R0	; R0 = offset in sector of RBN descriptor.
	MOVL	HIRT$L_PAGE2PTR,R1	; R1 => sector containing RBN descriptor.
	MOVAL	(R1)[R0],R0		; R0 => RBN descriptor.

	BISL3	#RCT$M_ALLOCATED,-	; Put LBN being replaced into descriptor.
		HIRT$L_LBN,(R0)		;  and or in ALLOCATED bit.
	BBC	#HIRT$V_EMPTYPE,-	; Branch if primary RBN allocation.
		HIRT$W_STS,10$
	BISL	#RCT$M_NONPRIME,(R0)	; Indicate non prime allocation.
10$:
	BBS	#HIRT$V_MATCH,-		; Branch if RCT search showed RBN failed.
		HIRT$W_STS,20$
	BRW	60$			; If NOT RBN failure, skip RBN
					;  descriptor update.
20$:
	ASHL	#-7,HIRT$L_MATCHRBN,R1	; R1 = relative RCT block containing
					;  bad RBN descriptor.
	ADDL	#2,R1			; Add in sectors 0 and 1.
	CMPW	R1,HIRT$W_PG2CNTNT	; Page 2 contains RBN descriptor of
					;  allocatable RBN and maybe also
					;  descriptor of bad RBN.
	BEQL	40$			; EQL implies both descriptors in same
					;  block.
	MOVL	#3,R0			; Indicate that we want to read into
					;  page 3.
	BSBW	READ_RCT_BLOCK		; Read sector (R1) into page 3.
	BLBS	R0,30$			; If success, continue.

;***************
;
; ERROR LOG READ FAILURE.
;
;***************

	BRW	STEP16			; Branch on failure.

30$:
	MOVL	HIRT$L_PAGE3PTR,R2	; R2 => page with bad RBN descriptor.
	BRB	50$			; Branch around.
40$:
	MOVL	HIRT$L_PAGE2PTR,R2	; R2 => page with bad RBN descriptor.
50$:
	EXTZV	#0,#7,HIRT$L_MATCHRBN,R0; R0 = offset of bad RBN descriptor.
	MOVAL	(R2)[R0],R0		; R0 => bad RBN descriptor.
	MOVL	(R0),HIRT$L_BADRBND	; Save Bad RBN descriptor in case
					;  we have to restore due to failure.
	MOVL	#RCT$M_UNUSABLE,(R0)	; Clear LBN and mark unusable bit in
					;  descriptor.
	CMPL	R2,HIRT$L_PAGE2PTR	; See if both descriptors in same page.
	BEQL	60$			; EQL implies yes. Go do only 1 write.

	MOVL	#3,R0			; Rewrite page 3 [R0].
	BSBW	WRITE_RCT_BLOCK		; Go write.
	BLBS	R0,60$			; If success, continue.

;***************
;
; ERROR LOG WRITE FAILURE.
;
;***************

	BRW	STEP15_A		; Branch on failure.

60$:
	MOVL	#2,R0			; Prepare to write page 2.
	BSBW	WRITE_RCT_BLOCK		; Go write.
	BLBS	R0,STEP12		; If success, goto next step.

;***************
;
; ERROR LOG WRITE FAILURE.
;
;***************

	BRW	STEP15_B		; Branch on failure.

; STEP12.
;  We use the REPLACE command to revector the  bad  block  to  the
;  chosen replacement block, then use the standard WRITE command (addressed
;  to the bad block's LBN) with the "compare" modifier asserted to store the
;  saved data in the replacement block.  The write-compare is performed with
;  the "force error" modifier if and only if  the  saved  data  is  invalid.
;  Note  that  the  REPLACE command implicitly verifies that a head or servo
;  track failure has not  occurred,  causing  a  large  number  of  improper
;  replacements.  If the REPLACE command fails, go to step 15.  If the WRITE
;  command fails, go to step 9 to re-scan the RCT  for  another  RBN.   Note
;  that  the  current  new  RBN  will become the old RBN for this next pass.
;  Either failure will have already been reported to  the  error  log.   The
;  WRITE  command  succeeds  if  no  error is detected and the saved data is
;  valid or if only a forced  error  is  detected  and  the  saved  data  is
;  invalid.
;

STEP12:
	RECYCH_MSG_BUF			; Recycle END PACKET into MSCP buffer.
	BLBS	R0,5$			; LBS means allocation success.
	BRW	REPLACE_CONNECT_FAILURE	; Allocation failure means CONNECTION
					;  failure.
5$:
	MOVL	CDRP$L_MSG_BUF(R5),R2	; R2 => MSCP buffer.

; Zero out MSCP buffer.

	PUSHR	#^M<R2,R3,R4,R5>		; Save registers.
	MOVC5	#0,.,#0,#MSCP$K_MXCMDLEN,(R2)	; Clear MSCP PACKET so that
						;  reserved fields are zero.
	POPR	#^M<R2,R3,R4,R5>		; Restore registers.

	MOVL	CDRP$L_RSPID(R5),-	; Prepare the MSCP PACKET, copy
		MSCP$L_CMD_REF(R2)	;  the COMMAND REFERENCE number.

	MOVW	UCB$W_UNIT(R3),-	; Note R3 still points at UCB, copy
		MSCP$W_UNIT(R2)		;  unit number.

	ASSUME	MSCP$W_MODIFIER  EQ  MSCP$B_OPCODE+2
	MOVL	#MSCP$K_OP_REPLC-	; Fill in field not prepared by
		!<MSCP$M_MD_EXPRS@16>,-	;  BUILD_RCT_PACKET.
		MSCP$B_OPCODE(R2)

	BBS	#HIRT$V_EMPTYPE,-	; See if primary or secondary RBN,
		HIRT$W_STS,10$		;  branch if secondary.
	BISW	#MSCP$M_MD_PRIMR,-	; Set primary modifier if
		MSCP$W_MODIFIER(R2)	;  called for.
10$:
	MOVL	HIRT$L_RBN,MSCP$L_RBN(R2); Fill in special REPLACE field.
	MOVL	HIRT$L_LBN,-		 ; Fill in field filled in incorrectly
		MSCP$L_LBN(R2)		 ;  by BUILD_RCT_PACKET.
	BSBW	CALL_SEND_MSG_BUF	 ; Call to send packet to controller.

	BBC	#MSCP$V_EF_ERLOG,-	; Test for error log message generated
		MSCP$B_FLAGS(R2),15$	;  and branch around if not.
	BISW	#HIRT$M_ERLOGIP,-	; Else remember that error log messages
		HIRT$W_STS		;  Have been generated.
15$:
	CMPZV	#MSCP$V_ST_MASK,-	; Compare major status code to
		#MSCP$S_ST_MASK,-	;  see if REPLACE succeeded.
		MSCP$W_STATUS(R2),-
		#MSCP$K_ST_SUCC
	BEQL	20$			; EQL implies successful replace.

	BRW	STEP15_B
20$:
	MOVL	#1,R0			; Data from bad block is in page 1.
	BSBW	MAP_PAGE		; Map page 1.
	BSBW	BUILD_RCT_PACKET	; Recycle etc., and fill in packet.

	ASSUME	MSCP$W_MODIFIER  EQ  MSCP$B_OPCODE+2
	MOVL	#MSCP$K_OP_WRITE-	; Fill in field not prepared by
		!<MSCP$M_MD_COMP@16>,-	;  BUILD_RCT_PACKET.
		MSCP$B_OPCODE(R2)

	BBC	#HIRT$V_FE,HIRT$W_STS,30$ ; See if original data is valid.
	BISW	#MSCP$M_MD_ERROR,-	  ; Set force error modifier if
		MSCP$W_MODIFIER(R2)	  ;  original data is invalid.
30$:
	MOVL	HIRT$L_LBN,-		; Fill in field filled in incorrectly
		MSCP$L_LBN(R2)		;  by BUILD_RCT_PACKET.
	BSBW	CALL_SEND_MSG_BUF	; Call to send packet to controller.

	BBC	#MSCP$V_EF_ERLOG,-	; Test for error log message generated
		MSCP$B_FLAGS(R2),35$	;  and branch around if not.
	BISW	#HIRT$M_ERLOGIP,-	; Else remember that error log messages
		HIRT$W_STS		;  Have been generated.
35$:
	UNMAP				; If write no good, give up resources.
	CLRL	CDRP$L_LBUFH_AD(R5)	; And show that deallocation was done.
	MOVL	CDRP$L_MSG_BUF(R5),R2	; Refresh R2 => END PACKET after unmap.

	CMPZV	#MSCP$V_ST_MASK,-	; Compare major status code to
		#MSCP$S_ST_MASK,-	;  see if write succeeded.
		MSCP$W_STATUS(R2),-
		#MSCP$K_ST_SUCC
	BEQL	STEP13			; If write ok, then proceed.

;	ASSUME that the force data subcode is zero
	CMPW	#MSCP$K_ST_DATA,-	; See if data error with force error
		MSCP$W_STATUS(R2)	;  subcode.
	BNEQ	50$			; If NOT, then branch to take action.

	BBS	#HIRT$V_FE,HIRT$W_STS,STEP13	; To STEP13 if force error expected.
	BUG_CHECK	DISKCLASS,FATAL		; Shouldn't happen.
50$:
	BRW	STEP9			; Following algorithm, goto step 9.

; STEP13.
;  We update sector 0 of the RCT copies to indicate that we are no
;  longer  in  the middle of replacing a bad block.  The RCT must be updated
;  without reading sector 0, instead using the copy of sector  0  last  read
;  from  or  written  to  the RCT.  If the RCT cannot be updated, report the
;  error to the error log and go to step 17.
;

STEP13:
	MOVL	HIRT$L_PAGE0PTR,R0	; R0 => page 0, which contains sector 0.
	BICW	#RCT$M_RP1-		; Reset flags in sector zero.  We are
		!RCT$M_RP2-		;  NOT in phase 1 nor in phase 2.
		!RCT$M_BR-		;  Also we clear Bad RBN flag and
		!RCT$M_FE,-		;   force error flag as well.
		RCT$W_FLAGS(R0)

;	ASSUME	RCT$L_RBN	EQ	RCT$L_LBN+4
	CLRQ	RCT$L_LBN(R0)		; Zero out RBN and LBN.
	CLRL	RCT$L_BAD_RBN(R0)	; Also clear BADRBN field.

	CLRL	R0			; Rewrite page 0.
	BSBW	WRITE_RCT_BLOCK		; Go write page into sector.
	BLBS	R0,STEP14		; LBS is success.

;*********************
;
; ERROR LOG FAILURE TO WRITE RCT SECTOR ZERO
;
;*********************

	BRW	STEP17			; After failure goto step 17.

; STEP14.
;  We set the success return code and return to our internal caller.
;

STEP14:
	DEALLOC_MSG_BUF
	CLRL	R1			; Prepare to return ERLOGIP bit if set.
	BBCC	#HIRT$V_ERLOGIP,-	; Branch around if clear and clear if
		HIRT$W_STS,10$		;  already set.
	BISW	#CDRP$M_ERLOGIP,R1	; Set bit in R1 so as to return to caller.
10$:
	MOVL	HIRT$L_SAVDCDRP,R5	; Restore CDRP address.

	MOVZWL	S^#SS$_NORMAL,R0	; Prepare to return status to caller.
	HIRT_SUBRETURN			; Return to caller.

; STEP15 - If here we failed to update the RCT (STEP11) or we failed in the
;	REPLACE (STEP12).
;  We restore the RCT to indicate that the new RBN is  unallocated
;  and usable and that the bad block is either not replaced or revectored to
;  the old RBN, whichever was it's original status.  The RCT must be updated
;  without  reading  any  blocks  from  it,  instead using the copies of the
;  relevent blocks that were read from the RCT in step 11.  Any  errors  are
;  reported to the error log but otherwise ignored.
;

STEP15_A:

; Here we failed to write the RCT block containing the Bad RBN only when
;	this descriptor resided in a different RCT block than that of the
;	selected RBN.   Because of the way that STEP11 works the copy
;	of the RCT Block is in page 3.

	MOVL	HIRT$L_PAGE3PTR,R2	; R2 => copy of page 3 in memory.
	EXTZV	#0,#7,HIRT$L_MATCHRBN,R0; R0 = offset (longword) of Bad RBN
					;  descriptor in page 3.
	MOVAL	(R2)[R0],R0		; R0 => Bad RBN descriptor slot.
	MOVL	HIRT$L_BADRBND,(R0)	; Restore Bad RBN descriptor.
	MOVL	#3,R0			; Prepare to try to rewrite page 3.
	BSBW	WRITE_RCT_BLOCK		; Try to rewrite.
	BRW	STEP16			; And branch around whether we succeed
					;  or fail.
STEP15_B:

; If here we failed in the REPLACE operation or in updating the RCT block
;	containing the selected RBN descriptor.  So we try to restore the
;	RCT sector(s) that contained the RBN descriptor(s).  If there was
;	no Bad RBN, then we simply want to restore the contents of page 2
;	to the sector indicated by HIRT$W_PG2CNTNT, after clearing the
;	RBN descriptor slot associated with the selected RBN.

	BBC	#HIRT$V_MATCH,-		; If NO Bad RBN, branch ahead to
		HIRT$W_STS,20$		;  restore only one descriptor.

; If there was a Bad RBN, and its descriptor happened to reside in the
;	same RCT sector as the descriptor of the selected RBN, then we first
;	first restore the old contents of the Bad RBN descriptor then
;	if this descriptor resided in a different sector than the selected
;	RBN's descriptor, we rewrite this other sector first.  Note the
;	other sector is contained in page 3 while the selected
;	RBN's descriptor is always in page 2.

	MOVL	HIRT$L_PAGE2PTR,R2	; R2 => copy of page 2.
	ASHL	#-7,HIRT$L_MATCHRBN,R1	; Calculate RCT sector # for Bad RBN.
	ADDL	#2,R1			; Add in RCT sectors 0 and 1.
	CMPW	R1,HIRT$W_PG2CNTNT	; See if in same sector.
	BEQL	10$			; EQL implies yes.

	MOVL	HIRT$L_PAGE3PTR,R2	; R2 => copy of page 3.
10$:
	EXTZV	#0,#7,HIRT$L_MATCHRBN,R0; R0 = offset (longword) of Bad RBN
					;  descriptor in page 2 or 3.
	MOVAL	(R2)[R0],R0		; R0 => Bad RBN descriptor slot.
	MOVL	HIRT$L_BADRBND,(R0)	; Restore Bad RBN descriptor.
	CMPL	R2,HIRT$L_PAGE2PTR	; See if we have to do both pages.
	BEQL	20$			; EQL implies NO, only page 2.
	MOVL	#3,R0			; Prepare to try to rewrite page 3.
	BSBW	WRITE_RCT_BLOCK		; Try to rewrite.
20$:

; Here we clear the selected RBN's descriptor and rewrite the sector from
;	page 2.

	MOVL	HIRT$L_PAGE2PTR,R2	; R2 => page 2 in memory.
	EXTZV	#0,#7,HIRT$L_RBN,R0	; R0 = offset (longword) of selected RBN
					;  descriptor in page 2.
	MOVAL	(R2)[R0],R0		; R0 => RBN descriptor slot.
	CLRL	(R0)			; Restore to available RBN descriptor.

	MOVL	#2,R0			; Prepare to try to rewrite page 2.
	BSBW	WRITE_RCT_BLOCK		; Try to rewrite.
;	BRW	STEP16			; And fall through whether we succeed
					;  or fail.
; STEP16.
;  We use the standard WRITE command (addressed to the bad block's
;  LBN)  to  restore the saved data.  The write is performed with the "force
;  error" modifier if and only if the saved data is invalid.  Any errors are
;  reported to the error log but otherwise ignored.
;

STEP16:
	MOVL	#1,R0			; Prepare to try to write original data
					;  to bad block that we could not replace.
	BSBW	MAP_PAGE		; Map page 1.
	BSBW	BUILD_RCT_PACKET	; Build MSCP packet.

	ASSUME	MSCP$W_MODIFIER	EQ	MSCP$B_OPCODE+2
	MOVL	#MSCP$K_OP_WRITE,-	; Put in write opcode.
		MSCP$B_OPCODE(R2)
	BBC	#HIRT$V_FE,-		; Branch around if NO forced error.
		HIRT$W_STS,10$
	BISW	#MSCP$M_MD_ERROR,-	; Set forced error bit modifier on.
		MSCP$W_MODIFIER(R2)
10$:
	MOVL	HIRT$L_LBN,-		; Indicate LBN to write.
		MSCP$L_LBN(R2)
	BSBW	CALL_SEND_MSG_BUF	; Go to send MSCP packet.
	BBC	#MSCP$V_EF_ERLOG,-	; Test for error log message generated
		MSCP$B_FLAGS(R2),15$	;  and branch around if not.
	BISW	#HIRT$M_ERLOGIP,-	; Else remember that error log messages
		HIRT$W_STS		;  Have been generated.
15$:
	UNMAP
	CLRL	CDRP$L_LBUFH_AD(R5)	; Indicate no mapping resources.

; STEP17.
;  We update sector 0 of the RCT copies to indicate that it is  no
;  longer  in  the middle of replacing a bad block.  The RCT must be updated
;  without reading sector 0, instead using the copy of sector  0  last  read
;  from or written to the RCT.  Any errors are reported to the error log but
;  otherwise ignored.
;


STEP17:
	MOVL	HIRT$L_PAGE0PTR,R0	; R0 => page 0, which contains sector 0.
	BICW	#RCT$M_RP1-		; Reset flags in sector zero.  We are
		!RCT$M_RP2-		;  NOT in phase 1 nor in phase 2.
		!RCT$M_BR-		;  Also we clear Bad RBN flag and
		!RCT$M_FE,-		;   force error flag as well.
		RCT$W_FLAGS(R0)

;	ASSUME	RCT$L_RBN	EQ	RCT$L_LBN+4
	CLRQ	RCT$L_LBN(R0)		; Zero out RBN and LBN.
	CLRL	RCT$L_BAD_RBN(R0)	; Also clear BADRBN field.

	CLRL	R0			; Rewrite page 0.
	BSBW	WRITE_RCT_BLOCK		; Go write page into sector.

; STEP18.
;  We set the failure return code and return to our internal caller.
;

STEP18:
	DEALLOC_MSG_BUF
	CLRL	R1			; Prepare to return ERLOGIP bit if set.
	BBCC	#HIRT$V_ERLOGIP,-	; Branch around if clear and clear if
		HIRT$W_STS,10$		;  already set.
	BISW	#CDRP$M_ERLOGIP,R1	; Set bit in R1 so as to return to caller.
10$:
	MOVZWL	#SS$_BADRCT,R0		; Indicate failure to caller.
	HIRT_SUBRETURN

REPLACE_CONNECT_FAILURE:		; Come here if CONNECTION failure
					;  anywhere in REPLACE logic.

	BRW	KILL_THIS_THREAD	; Branch to kill this thread.
	.PAGE

	.SBTTL	ONLINE_COMPLETE

;+
; ONLINE_COMPLETE - internal subroutine called when bringing units ONLINE
;	for devices attached to controllers that require HOST INITIATED
;	dynamic bad block replacement.  This routine reads sector zero
;	of the RCT to see if the disk went offline in the middle of
;	bad block replacement.  If so the replacement is completed.
;
; INPUTS:
;	R3 => UCB of the unit that we are bringing ONLINE
;	R5 => HIRT permanent CDRP
;	HIRT$L_SAVDCDRP => CDRP that describes the current
;			connection and/or operation
;
;	HIRT is owned by the current thread
;	HIRT SUBSTACK is reset
;
; OUTPUTS:
;
;
;
;
;
;
;
;


ONLINE_COMPLETE:

	HIRT_SUBSAVE			; Save return point on SUBSTACK.

	ASSUME	HIRT$W_PG0CNTNT+2	EQ	HIRT$W_PG1CNTNT
	MNEGL	#1,HIRT$W_PG0CNTNT	; Invalidate contents of pages 0 and 1.

	ASSUME	HIRT$W_PG2CNTNT+2	EQ	HIRT$W_PG3CNTNT
	MNEGL	#1,HIRT$W_PG2CNTNT	; Invalidate contents of pages 2 and 3.

; Here we want to read sector 0 of the RCT into page 0 so as to be able to
;	determine whether or not we went down in the middle of Dynamic Bad
;	Block replacement.
; Note we have NOT allocated a Message Buffer.  READ_RCT_BLOCK (via a call
;	to BUILD_RCT_PACKET) will do it for us.

	CLRQ	R0			; Indicate read sector 0 (R1) into
					;  page 0 (R0).
	BSBW	READ_RCT_BLOCK		; Read indicated sector into page.
	BLBS	R0,20$			; LBS means successful read.

;*********************************
;
; ERROR LOG?
;
;*********************************

	BRW	STEP18			; Goto deallocate and set RCT_FAILURE
					;  status code before returning.
20$:

; Here we do a write of page 0 to sector 0 (all copies) to insure that we
;	did not crash in the middle of an update of sector 0 and thereby
;	get a set of inconsistent copies.

	CLRL	R0			; Rewrite page 0.
	BSBW	WRITE_RCT_BLOCK		; Write indicated sector from page.
	BLBS	R0,30$			; LBS means successful write.

;*********************************
;
; ERROR LOG?
;
;*********************************

	BRW	STEP18			; Goto deallocate and set RCT_FAILURE
					;  status code before returning.
30$:
	MOVL	HIRT$L_PAGE0PTR,R0	; R0 => sector 0 in memory.
	BITW	#RCT$M_RP1-		; Test for phase 1 of replacement
		!RCT$M_RP2,-		;  or phase 2.
		RCT$W_FLAGS(R0)
	BNEQ	40$			; NEQ implies that we were in the
					;  middle of replacement.
	DEALLOC_MSG_BUF			; Else we deallocate the buffer
	CLRL	R1			; Prepare to return ERLOGIP bit if set.
	BBCC	#HIRT$V_ERLOGIP,-	; Branch around if clear and clear if
		HIRT$W_STS,35$		;  already set.
	BISW	#CDRP$M_ERLOGIP,R1	; Set bit in R1 so as to return to caller.
35$:
	MOVZWL	#SS$_NORMAL,R0		; deallocate the RSPID, and we return
					;  to caller with a success status.
	HIRT_SUBRETURN			; Return.
40$:
	MOVL	RCT$L_LBN(R0),-		; Restore LBN to replace to HIRT.
		HIRT$L_LBN
	MOVL	#1,R0			; Read into page 1.
	MOVL	#1,R1			; From RCT sector 1.
	BSBW	READ_RCT_BLOCK		; Read RCT block.
	BLBS	R0,50$			; LBS means successful read.

;*********************************
;
; ERROR LOG?
;
;*********************************

	BRW	STEP18			; Goto deallocate and set RCT_FAILURE
					;  status code before returning.
50$:
	MOVL	HIRT$L_PAGE0PTR,R0	; Again, R0 => sector 0 contents.

	BICW	#HIRT$M_FE-		; Initialize incore bits.
		!HIRT$M_MATCH-
		!HIRT$M_EMPTYPE-
		!HIRT$M_RESCAN-
		!HIRT$M_RCTFULL,-
		HIRT$W_STS

	BBC	#RCT$V_FE,-		; Branch if no forced error.
		RCT$W_FLAGS(R0),60$
	BISW	#HIRT$M_FE,HIRT$W_STS	; Set incore forec error bit.
60$:
	BBC	#RCT$V_RP1,-		; See if NOT in phase 1.
		RCT$W_FLAGS(R0),70$
	BRW	STEP7			; Branch into step 7 to continue.
70$:
	BBS	#RCT$V_RP2,-		; Sanity check.
		RCT$W_FLAGS(R0),75$
	BUG_CHECK	DISKCLASS,FATAL
75$:
	MOVL	RCT$L_RBN(R0),-		; Remember RBN that we had selected.
		HIRT$L_RBN

	BBC	#RCT$V_BR,-		; See if we had had bad RBN.
		RCT$W_FLAGS(R0),80$	; Clear means no.
	BISW	#HIRT$M_MATCH,HIRT$W_STS; We set equivalent bit in core.
	MOVL	RCT$L_BAD_RBN(R0),-	; Copy the old bad RBN.
		HIRT$L_MATCHRBN
80$:

; Here figure out whether this is prime RBN.

	BSBW	HASH_LBN		; Hash HIRT$L_LBN to produce values
					;  for HIRT$L_RCTBLOCK and HIRT$L_OFFSET.
	SUBL3	#2,HIRT$L_RCTBLOCK,R1	; Subtract out RCT sectos 0 and 1.
	ASHL	#7,R1,R1		; R1 = relative block containing prime
					;  RBN descriptor * 128.
	ADDL	HIRT$L_OFFSET,R1	; R1 = prime RBN.
	CMPL	R1,HIRT$L_RBN		; See if this the one.
	BEQL	90$			; EQL implies yes.
	BISW	#HIRT$M_EMPTYPE,-	; Set bit meaning NOT prime RBN.
		HIRT$W_STS
90$:

; Here read sector containing allocatable RBN into page 2.

	ASHL	#-7,HIRT$L_RBN,R1	; R1 = relative RCT block containing
					;  this RBN descriptor.
	ADDL	#2,R1			; Add in sectors 0 and 1.
	MOVL	#2,R0			; Read into page 2.
	BSBW	READ_RCT_BLOCK		; Go read RCT sector.
	BLBS	R0,100$			; Branch on success.

;************************
;
; ERROR LOG?
;
;************************

	BRW	STEP18			; Goto deallocate and set RCT_FAILURE
					;  status code before returning.
100$:
	BRW	STEP11
	.PAGE
	.SBTTL	WRITE_RCT_BLOCK

;+
; WRITE_RCT_BLOCK - internal subroutine to write a block to a particular
;	relative sector in each RCT copy.
;
; INPUTS:
;	R0 =  page number from which we write the sector
;	R3 => UCB
;	R5 => CDRP
;	HIRT$W_PG0CNTNT[R0] contains relative sector number to write
;	CDRP$L_MSG_BUF contains an END PACKET to recycle
;	CDRP$L_RSPID   contains an RSPID to recycle
;
; OUTPUTS:
;	R0 - LBS indicates we were successful in writing at least one
;		RCT.
;	R0 - LBC indicates failure in all writes.
;
; SIDE EFFECTS:
;	In this routine we use HIRT$W_IOST as the repository of the
;	combined status of the writes that we execute.  In other words, if
;	on finishing the writes, the low bit of HIRT$W_IOST is set,
;	one or more of the writes was successful.
;
; NOTE:
;	Since this subroutine is one of those that calls SCS routines which
;	may fork, and since we may not leave anything permanent on the stack,
;	the caller's return point is popped off the stack and pushed onto
;	the HIRT SUBSTACK via use of the HIRT_SUBSAVE macro.  Return to the
;	caller is effected by use of the HIRT_SUBRETURN macro.
;

WRITE_RCT_BLOCK:

	HIRT_SUBSAVE			; Save return point in SUBSTACK.
	MOVW	HIRT$W_PG0CNTNT[R0],-	; Also save input argument as to which
		HIRT$W_SECTORNO		;  sector (page) to write.
	BSBW	MAP_PAGE		; Map page selected by R0.

	CLRW	HIRT$W_IOST		; Initialize combined status word.
	CLRL	HIRT$L_LOOPCNT		; Initialize loop counter. Note loop
					;  counter is longword even though we
					;  only use one byte since we MULL2
					;  with the counter in BUILD_RCT_PACKET.
20$:
	BICW	#HIRT$M_RCTFE,-		; Initialize flag each time thru loop.
		HIRT$W_STS
	CMPB	HIRT$L_LOOPCNT,-	; See if we are all done with all
		UCB$B_DU_RCTCPYS(R3)	;  RCT copies.
	BLSSU	30$			; LSSU implies NOT done.
	BRB	70$			; If done, branch around.
30$:

; Recycle the current END PACKET, the current RSPID and then prepare
;	the MSCP packet to write page into the next RCT copy at relative
;	sector of this copy.  All this is accomplished by BUILD_RCT_PACKET.

	BSBW	BUILD_RCT_PACKET	; Routine fills most MSCP fields.
					;  Returns R2 => MSCP packet.
	MOVB	#MSCP$K_OP_WRITE,-	; Copy the WRITE opcode.
		MSCP$B_OPCODE(R2)
	MOVW	#MSCP$M_MD_COMP,-	; Move in compare modifier to get a
		MSCP$W_MODIFIER(R2)	;  write compare operation.

	BBC	#HIRT$V_RCTFE,-		; Bit clear says write WITHOUT force
		HIRT$W_STS,40$		;  error.
	BISW	#MSCP$M_MD_ERROR,-	; Set force error modifier.
		MSCP$W_MODIFIER(R2)
40$:
	BSBW	CALL_SEND_MSG_BUF	; Send MSCP packet thru port to controller.

	BBC	#MSCP$V_EF_ERLOG,-	; Test for error log message generated
		MSCP$B_FLAGS(R2),45$	;  and branch around if not.
	BISW	#HIRT$M_ERLOGIP,-	; Else remember that error log messages
		HIRT$W_STS		;  Have been generated.
45$:

; See if write succeeded and if so set HIRT$W_IOST to success; otherwise
;	do nothing.  In this way if one or more writes succeed, HIRT$W_IOST
;	will have a success indication.

	BBS	#HIRT$V_RCTFE,-		; Branch around status update if
		HIRT$W_STS,60$		;  we had force error.
	CMPZV	#MSCP$V_ST_MASK,-	; Compare major status code to
		#MSCP$S_ST_MASK,-	;  see if write succeeded.
		MSCP$W_STATUS(R2),-
		#MSCP$K_ST_SUCC
	BEQL	50$			; If success go to record it.
	BISW	#HIRT$M_RCTFE,-		; Set force error flag and
		HIRT$W_STS
	BRB	30$			;  branch back to rewrite it.
50$:
	MOVW	S^#SS$_NORMAL,-		; If success, remember it in static
		HIRT$W_IOST		;  HIRT field.
60$:
	INCL	HIRT$L_LOOPCNT		; Increment loop counter.
	BRB	20$			; And branch back to do next copy.

70$:					; Here after we finish all RCT copies.
	UNMAP				; Unmap page 1.
	CLRL	CDRP$L_LBUFH_AD(R5)	; Indicate no mapping resources
					;  currently allocated.
	MOVZWL	HIRT$W_IOST,R0		; Return status to caller.
	HIRT_SUBRETURN			; Return to caller.
	.PAGE
	.SBTTL	READ_RCT_BLOCK

;+
; READ_RCT_BLOCK - internal routine to read contents of a relative sector of
;	the RCT.
;
; INPUTS:
;	R0 =  page number of page into which we read the sector
;	R1 =  relative sector number to read
;	R3 => UCB
;	R5 => CDRP
;	CDRP$L_MSG_BUF contains an END PACKET to recycle
;	CDRP$L_RSPID   contains an RSPID to recycle
;
; OUTPUTS:
;	R0 - LBS indicates we were successful in the block from one of the
;		RCT copies.
;	R0 - LBC indicates failure in reading from all RCT copies.
;
; SIDE EFFECTS:
;	We use HIRT$W_IOST to temporarily save the status to be returned
;	to out caller.
;
; NOTE:
;	Since this subroutine is one of those that calls SCS routines which
;	may fork, and since we may not leave anything permanent on the stack,
;	the caller's return point is popped off the stack and pushed onto
;	the HIRT SUBSTACK via use of the HIRT_SUBSAVE macro.  Return to the
;	caller is effected by use of the HIRT_SUBRETURN macro.
;

READ_RCT_BLOCK:

	HIRT_SUBSAVE			; Save return point in SUBSTACK.
	MOVW	R0,HIRT$W_PAGENO	; Save input argument as to which page.
	MOVW	R1,HIRT$W_SECTORNO	; Also save input argument as to which
					;  sector to write.
	MNEGW	#1,HIRT$W_PG0CNTNT[R0]	; Invalidate page(R0) contents.
	BSBW	MAP_PAGE		; Map page selected by R0.

	CLRW	HIRT$W_IOST		; Initialize combined status word.
	CLRL	HIRT$L_LOOPCNT		; Initialize loop counter.
20$:
	CMPB	HIRT$L_LOOPCNT,-	; See if we are all done with all
		UCB$B_DU_RCTCPYS(R3)	;  RCT copies.
	BLSSU	30$			; LSSU implies NOT done.

	CLRL	R0			; Pass failure to our caller.
	BRB	50$			; If done, branch around.
30$:

; Recycle the current END PACKET, the current RSPID and then prepare
;	the MSCP packet to read page from the next RCT copy at relative
;	sector of this copy.  All this is accomplished by BUILD_RCT_PACKET.

	BSBB	BUILD_RCT_PACKET	; Routine fills in most of MSCP packet.
					;  Returns R2 => MSCP packet.
	MOVB	#MSCP$K_OP_READ,-	; Copy the READ opcode since this field
		MSCP$B_OPCODE(R2)	;  is not filled in by BUILD_RCT_PACKET.
	MOVW	#MSCP$M_MD_COMP,-	; Move in compare modifier to get a
		MSCP$W_MODIFIER(R2)	;  compare operation.

	BSBW	CALL_SEND_MSG_BUF	; Send MSCP packet thru port to controller.

	BBC	#MSCP$V_EF_ERLOG,-	; Test for error log message generated
		MSCP$B_FLAGS(R2),35$	;  and branch around if not.
	BISW	#HIRT$M_ERLOGIP,-	; Else remember that error log messages
		HIRT$W_STS		;  Have been generated.
35$:

; See if read succeeded and if so we now have a valid copy of the sector so we
;	simply continue.  If we did not succeed we bump the loop counter and
;	go back to try and read the sector from the next (if any) RCT copy.

	CMPZV	#MSCP$V_ST_MASK,-	; Compare major status code to
		#MSCP$S_ST_MASK,-	;  see if read succeeded.
		MSCP$W_STATUS(R2),-
		#MSCP$K_ST_SUCC
	BEQL	40$			; EQL implies success so branch around.
	INCL	HIRT$L_LOOPCNT		; Increment loop counter.
	BRB	20$			; And branch back to try next copy.

40$:					; Here after we finish all RCT copies.
	MOVZWL	HIRT$W_PAGENO,R0	; R0 = page number into which we read.
	MOVW	HIRT$W_SECTORNO,-	; Update contents of this page by
		HIRT$W_PG0CNTNT[R0]	;  remembering sector therein contained.
	MOVZWL	S^#SS$_NORMAL,R0	; Indicate success.
50$:
	MOVW	R0,HIRT$W_IOST		; Save return status.
	UNMAP				; Unmap page 1.
	CLRL	CDRP$L_LBUFH_AD(R5)	; Indicate no mapping resources
					;  currently allocated.
	MOVZWL	HIRT$W_IOST,R0		; Return status to caller.
	HIRT_SUBRETURN			; Return to caller.
	.PAGE
	.SBTTL	BUILD_RCT_PACKET

;+
; BUILD_RCT_PACKET - internal subroutine to recycle the current END PACKET
;			and then to fall thru to
;
; FILL_RCT_PACKET - which prepares an MSCP packet to do an I/O transfer
;	to or from the RCT.
;
; INPUTS:
;	R3 => UCB
;	R5 => CDRP
;	CDRP$L_RSPID	contains a RSPID to re-cycle
;	CDRP$L_MSG_BUF	address of MSCP buffer to re-cycle or 0 (zero)
;			0 (zero) means that we must here allocate an MSCP buffer
;	CDRP$L_BUFHNDL	contains 96 bit buffer handle
;	UCB$L_ABCNT     contains which RCT copy we are accessing
;	HIRT$W_SECTORNO contains which relative sector number in the RCT copy
;
; OUTPUTS:
;	R2 => MSCP PACKET
;	Registers R0 and R1 are modified
;
; NOTE:
;	Since BUILD_RCT_PACKET is one of those that calls SCS routines which
;	may fork, and since we may not leave anything permanent on the stack,
;	the caller's return point is popped off the stack upon entry to
;	this entrypoint and pushed onto the HIRT SUBSTACK via use of the
;	HIRT_SUBSAVE macro.  Upon return from those SCS routines, the caller's
;	return point is restored to the normal stack via use of the
;	HIRT_SUBUNSAVE macro.  all this is done prior to entrypoint 
;	FILL_RCT_PACKET so that we may fall into this routine and then use
;	its RSB to return to our caller.
;

BUILD_RCT_PACKET:

	HIRT_SUBSAVE			; Save return point on HIRT SUBSTACK.

	ASSUME	MSCP$L_CMD_REF	EQ	0
	TSTL	CDRP$L_MSG_BUF(R5)	; See if we need a Message Buffer.
	BEQL	20$			; EQL means Buffer needed.

	RECYCH_MSG_BUF			; Else Recycle END PACKET into MSCP buffer.
	BLBS	R0,30$			; LBS means allocation success.
10$:	BRW	REPLACE_CONNECT_FAILURE	; Allocation failure means CONNECTION
					;  failure.
20$:
	ALLOC_MSG_BUF			; Allocate a Message Buffer.
	BLBC	R0,10$			; LBC means allocation failure.
30$:
	HIRT_SUBUNSAVE			; Restore caller's return point.

FILL_RCT_PACKET:			; Alternate entry that only fills in packet.

	MOVL	CDRP$L_MSG_BUF(R5),R2	; R2 => MSCP buffer.

; Zero out MSCP buffer.

	PUSHR	#^M<R2,R3,R4,R5>		; Save registers.
	MOVC5	#0,.,#0,#MSCP$K_MXCMDLEN,(R2)	; Clear MSCP PACKET so that
						;  reserved fields are zero.
	POPR	#^M<R2,R3,R4,R5>		; Restore registers.

	MOVL	CDRP$L_RSPID(R5),-	; Prepare the MSCP PACKET, copy
		MSCP$L_CMD_REF(R2)	;  the COMMAND REFERENCE number.

	MOVW	UCB$W_UNIT(R3),-	; Note R3 still points at UCB, copy
		MSCP$W_UNIT(R2)		;  unit number.

	MOVL	#512,MSCP$L_BYTE_CNT(R2); Copy the byte count of the transfer.

	MOVQ	CDRP$T_LBUFHNDL(R5),-	; Copy 96 bit buffer handle.
		MSCP$B_BUFFER(R2)	;		"
	MOVL	CDRP$T_LBUFHNDL+8(R5),-	;		"
		MSCP$B_BUFFER+8(R2)	;		"

; Calculate LBN of relative sector for this RCT copy.
;	It is done by multipling the number of RCT copies already written,
;	(contained in HIRT$L_LOOPCNT) by the size of an RCT copy (contained in
;	UCB$W_DU_RCTSIZE), adding in the LBN of the base of the first RCT copy
;	(UCB$L_DU_USIZE) and then adding in the relative sector number
;	passed to us when we were called (HIRT$W_SECTORNO).

	MOVZWL	UCB$W_DU_RCTSIZE(R3),R0	; R0 contains size of one RCT copy.
	MULL2	HIRT$L_LOOPCNT,R0	; R0 contains COPY# * COPYSIZE.
	ADDL	UCB$L_DU_USIZE(R3),R0	; R0 contains LBN of base of this copy.
	MOVZWL	HIRT$W_SECTORNO,R1	; R1 contains input relative sector #.
	ADDL	R1,R0			; R0 contains LBN.
	MOVL	R0,MSCP$L_LBN(R2)	; Move LBN to MSCP packet.

	RSB				; Return to caller.
	.PAGE
	.SBTTL	MAP_PAGE

;+
; MAP_PAGE - internal subroutine to map the page selected by R0.
;
; INPUTS:
;	R0    contains the number of the page to map.
;	R5 => CDRP
;
; OUTPUTS:
;	CDRP$L_SVAPTE, CDRP$W_BOFF, CDRP$L_BCNT and set to page parameters.
;
;	CDRP$L_LBUFH_AD set to => CDRP$T_LBUFHNDL
;
;	Mapping resources allocated.

MAP_PAGE:
	HIRT_SUBSAVE			; Save caller's return point on SUBSTACK.
	MOVL	HIRT$L_SVAPTE0[R0],-	; Copy mapping date for relative page 
		CDRP$L_SVAPTE(R5)	;  to CDRP.
	MOVW	HIRT$W_BOFF0[R0],-	; Copy BOFF as well as SVAPTE.
		CDRP$W_BOFF(R5)
	MOVZWL	#512,CDRP$L_BCNT(R5)	; Finally copy BCNT for page.

	MOVAB	CDRP$T_LBUFHNDL(R5),-	; Point CDRP field to local buffer
		CDRP$L_LBUFH_AD(R5)	;  handle field.
	MAP_IRP				; Map page.

	HIRT_SUBRETURN			; Return to caller.
	.PAGE
	.SBTTL	SEARCH_RCT

;+
; SEARCH_RCT - internal subroutine to search the RCT for an available RBN
;	to allocate for the current failing LBN.  This routine is called from
;	STEP9 of the replacement algorithm and is only done here as an
;	internal subroutine to simplify the reading of that algorithm.
;
; INPUTS:
;	R3 => UCB
;	R5 => CDRP
;	HIRT$L_LBN LBN that is failing
;	UCB$W_DU_LBNPTRK number of LBNs on a track of this unit
;	UCB$B_DU_RBNPTRK number of RBNs on a track of this unit
;
; OUTPUTS:
;	R0 = SS$_NORMAL then:
;		HIRT$L_RBN - new RBN selected to replace the failing LBN
;		and HIRT$V_EMPTYPE clear means this is a primary RBN, else
;		secondary RBN.
;
;		If HIRT$V_MATCH set this implies that the LBN which failed
;			had previously been replaced by an RBN which in
;			turn has failed.  This failing RBN is in
;			HIRT$L_MATCHRBN.
;
;	R0 = 0 then we could not find an allocatable RBN and HIRT$L_RBN is
;		not valid. The cause of the failure to find an RBN is
;		transmitted to the caller by:
;
;			HIRT$V_RCTFULL set implies that the RCT on the disk
;				is full
;			HIRT$V_RCTFULL clear implies we had a read error on
;				some RCT sector.
;

SEARCH_RCT:

	HIRT_SUBSAVE			; Save return on HIRT substack.

	BSBW	HASH_LBN		; Hash LBN value in HIRT$L_LBN returning
					;  HIRT$L_RCTBLOCK and HIRT$L_OFFSET.

	MOVL	HIRT$L_RCTBLOCK,-	; And remember the starting sector
		HIRT$L_STARTBLK		;  number in static storage.

; Here we initialize a few bits.

	BICW	#HIRT$M_MATCH-		; Initialize the following flags.
		!HIRT$M_EMPTYPE-	;  Match set implies valid MATCHRBN,
		!HIRT$M_RESCAN-		;  EMPTYPE set implies secondary RBN,
		!HIRT$M_RCTFULL,-	;  Rescan implies reached Nulls,
		HIRT$W_STS		;  and RCTFULL means the RCT is full.

; Here we prepare to read the RCT sector containing the primary RBN descriptor.

	MOVL	#2,R0			; Prepare to read into page #2.
	MOVL	HIRT$L_RCTBLOCK,R1	; And we read this relative sector #.
	BSBW	READ_RCT_BLOCK		; Subroutine does read.
	BLBC	R0,SEARCH_RTN		; LBC implies read failure.

; Here we scan the RCT sector containing the primary RBN descriptor.  The
;	method of scanning is to scan outward from the primary RBN descriptor.

10$:
	CLRL	R2			; Set up delta.
20$:
	ADDL3	R2,HIRT$L_OFFSET,R1	; R1 = next entry to test in first RCT
					;  sector to scan.
	BLSS	40$			; LSS implies invalid offset into page.
30$:
	CMPL	R1,#127			; See if we are within sector page.
	BGTR	40$			; GTR implies no, out of bounds, go
					;  to increment delta.
	BSBW	TEST_RCT_ENTRY		; If in bounds, go test RCT entry.
	BLBS	R0,SEARCH_RTN		; LBS implies success.
40$:
	MNEGL	R2,R2			; Negate delta.
	BLSS	20$			; Branch to try again if negative.
	INCL	R2			; Else increment delta.
	CMPL	R2,#128			; See if delta too big.
	BLSS	20$			; LSS implies not too big.
					; Else we fall thru to try next sector.
NEXT:
	INCL	HIRT$L_RCTBLOCK		; Increment RCT sector to scan.
10$:
	CMPL	HIRT$L_RCTBLOCK,-	; See if we are all done with search.
		HIRT$L_STARTBLK
	BEQL	SEARCH_FAIL		; EQL means that we are finished.

	MOVL	#2,R0			; Prepare to read into page 2.
	MOVL	HIRT$L_RCTBLOCK,R1	; And to read this sector.
	BSBW	READ_RCT_BLOCK		; Go to read sector into page.
	BLBC	R0,SEARCH_RTN		; LBC implies read failure

	BBC	#RCT$V_NULL,-		; Before linear scan of this sector,
		@HIRT$L_PAGE2PTR,20$	;  see if we are beyond RCT.
	MOVL	#2,HIRT$L_RCTBLOCK	; Here beyond RCT.  Wrap to start and
	BBCS	#HIRT$V_RESCAN,-	;  go back to search some more after
		HIRT$W_STS,10$		;  setting bit that says we have wrapped.
	BUG_CHECK	DISKCLASS,FATAL	; Impossible situation.
20$:
	CLRL	R2			; Clear loop index register.
30$:
	MOVL	R2,R1			; Pass RCT entry of interest to routine.
	BSBW	TEST_RCT_ENTRY		; Call subroutine to test entry.
	BLBS	R0,SEARCH_RTN		; LBS means we have the RBN, go from loop.
	AOBLSS	#128,R2,30$		; If we return here, (entry not avail.)
					;  then loop back after incrementing R2.
	BRB	NEXT			; If we fall thru, goto NEXT sector.

SEARCH_FAIL:
	CLRL	R0			; Indicate failure to caller and
	BISW	#HIRT$M_RCTFULL,-	;  indicate reason for failure.
		HIRT$W_STS
SEARCH_RTN:
	HIRT_SUBRETURN			; Return to caller.
	.PAGE
	.SBTTL	TEST_RCT_ENTRY

;+
; TEST_RCT_ENTRY - internal subroutine called to test an RCT entry to see
;	if it represents an allocatable RBN or if it is already allocated.
;
; INPUTS:
;	R1 = index of RCT entry.
;
; OUTPUTS:
;	R0 = success code.
;	   = SS$_NORMAL then HIRT$L_RBN is set to the RBN associated with the
;		RCT entry defined by HIRT$L_RCTBLOCK and R1 (entry index).
;
;	   = 0 implies that the entry is not allocatable.  In in addition if
;		the RBN is currently allocated and if it is allocated to this
;		LBN (i.e. to HIRT$L_LBN), then HIRT$V_MATCH is set in
;		HIRT$W_STS and the RBN associated with the current entry is
;		stored in HIRT$L_MATCHRBN.
;


TEST_RCT_ENTRY:
	PUSHL	R2			; Save register.
	SUBL3	#2,HIRT$L_RCTBLOCK,R0	; R0 = found sector without bias of 2.
	ASHL	#7,R0,R0		; Multiply by 128.
	ADDL	R1,R0			; R0 = RBN associated with this entry.

	MOVL	HIRT$L_PAGE2PTR,R2	; R2 => page 2, which contains sector.
	TSTL	(R2)[R1]		; Test contents of current entry.
	BNEQ	10$			; NEQ implies that it is not available.
	MOVL	R0,HIRT$L_RBN		; Save RBN of this entry in HIRT.
	MOVZWL	#SS$_NORMAL,R0		; Set success code.
	BRB	40$			; And branch to return to caller.
10$:
	MOVAL	(R2)[R1],R2		 ; R2 => entry of interest.
	BISW	#HIRT$M_EMPTYPE,-	 ; Set bit meaning any find will now
		HIRT$W_STS		 ;  have to be a secondary RBN.
	BBC	#RCT$V_ALLOCATED,(R2),30$; If clear, then unusable RBN.

	EXTZV	#RCT$V_LBN,-		; If allocated, see if for this LBN.
		#RCT$S_LBN,(R2),R2	; R2 = LBN for this RBN.
	CMPL	R2,HIRT$L_LBN		; See if this LBN.
	BNEQ	30$			; NEQ means not for this LBN.
	BBCS	#HIRT$V_MATCH,-		; Set bit that means we have a match.
		HIRT$W_STS,20$
	BUG_CHECK	DISKCLASS,FATAL	; Impossible situation.
20$:
	MOVL	R0,HIRT$L_MATCHRBN	; Save RBN that matched.
30$:
	CLRL	R0			; Failure to find allocatable RBN.
40$:
	POPL	R2			; Restore register.
	RSB				; Return to caller.
	.PAGE
	.SBTTL	HASH_LBN

;+
; HASH_LBN - internal routine to hash HIRT$L_LBN giving HIRT$L_RCTBLOCK and
;	HIRT$L_OFFSET.
;
; INPUTS:
;
;	R3 => UCB
;	HIRT$L_LBN
;
; OUTPUTS:
;
;	HIRT$L_RCTBLOCK = RCT sector containing prime RBN descriptor for this
;			LBN
;	HIRT$L_OFFSET = offset of prime RBN descriptor in sector.
;
; SIDE EFFECTS:
;
;	Registers R0 an R1 altered.
;

HASH_LBN:

	MOVZWL	UCB$W_DU_LBNPTRK(R3),R0	; R0 contains LBNs per track.
	DIVL3	R0,HIRT$L_LBN,R1	; R1 =  QUO(LBN/(LBNs per track)).

	MOVZBL	UCB$B_DU_RBNPTRK(R3),R0	; R0 = RBNs per track.
	MULL	R1,R0			; R0 = (RBNs per)*QUO(LBN/(LBNs per))
	CLRL	R1			; Clear high order part of dividend.

	EDIV	#128,R0,-		; Divide result by 128 giving the
		HIRT$L_RCTBLOCK,-	;  quotient and the
		HIRT$L_OFFSET		;  remainder.

	ADDL	#2,HIRT$L_RCTBLOCK	; Add in sector 0 and sector 1.
	RSB				; Return to caller
	.PAGE
	.SBTTL	CALL_SEND_MSG_BUF

; CALL_SEND_MSG_BUF - Common interface to call SEND_MSG_BUF.  All calls to
;	SEND_MSG_BUF from this driver are channeled thru this interface except
;	those calls made in Controller Initialization and in the Timeout
;	Mechanism Routine.  In other words, all calls to SEND_MSG_BUF made
;	as a result of a user QIO or as a result of dynamic bad block replace-
;	ment come through here.
;
;	This is done so as to be able to INSQUE the CDRP that generated the
;	call onto the CDDB$L_CDRPQFL.
;
;	This routine is called with a BSBW instruction and it in turn
;	transfers control to SEND_MSG_BUF via a JMP instruction.
;	The return experienced from SEND_MSG_BUF will therefore go to the
;	caller of this interface routine.
;
; INPUTS:
;	R3 => UCB
;	R4 => PDT
;	R5 => CDRP
;

CALL_SEND_MSG_BUF:

	BBC	#IRP$V_DIAGBUF,-	; Branch around if no P6 buffer.
		CDRP$W_STS(R5),10$
	BSBW	DUMP_COMMAND		; If P6 buffer, record MSCP command
					;  message sent in buffer.
10$:
	MOVL	UCB$L_DU_CDDB(R3),R1	; R1 => CDDB of intelligent controller.

	INSQUE	(R5),@CDDB$L_CDRPQBL(R1); Insert CDRP onto tail of queue
					;  of CDRP's sent to the port.

	MOVL	#MSCP$K_MXCMDLEN,R1	; Pass length of longest MSCP command.
	JMP	@PDT$L_SNDCNTMSG(R4)	;  And jump to PORT routine
	.PAGE
	.SBTTL	KILL_THIS_THREAD

; KILL_THIS_THREAD - internal subroutine that is either jumped (BRW) to or
;	called (BSBW).  It is jumped to by a thread that has suffered an
;	allocation failure indicating that its CONNECTION has failed.  This
;	should only happen when the CONNECTION fails asynchronously with
;	respect to the Disk Class Driver and the cause of the CONNECTION
;	failure (e.g. Power failure) interrupts this very driver thread in
;	mid execution.
;
;	This code is called when the Class Driver determines that the
;	intelligent controller is acting in an "insane" manner and that
;	the class driver therefore should bring down the CONNECTION and
;	re-synchronize (i.e. re-CONNECT) with the controller.
;
;	In either case, all we do here is to INSQUE the CDRP onto the
;	CDDB$L_CDRPQFL.  This Queue, then holds all those CDRP's with
;	outstanding requests in the controller plus those CDRP's of "killed"
;	driver threads.  What all these CDRP's have in common is that they
;	are NOT on any resource wait queues.  After we INSQUE the CDRP
;	we RSB which returns to caller's caller if we were BRW'ed to and
;	to caller if we were BSBW'ed to.
;
; INPUTS:
;	R3 => UCB
;	R4 => PDT
;	R5 => CDRP

KILL_THIS_THREAD:

	MOVL	UCB$L_DU_CDDB(R3),R1	; R1 => CDDB.
	INSQUE	(R5),@CDDB$L_CDRPQBL(R1); Insert CDRP onto tail of queue
					;  of CDRP's sent to the port.

	RSB				; Return to caller or caller's caller.
	.PAGE
	.SBTTL	INSERT_RSTRTQ

; INSERT_RSTRTQ - Insert a CDRP into the CDDB$L_RSTRTQFL list in ascending
;	order according to the value of CDRP$L_SEQNUM and bump CDDB$W_RSTRTCNT.
;	We also deallocate all resources allocated for this CDRP.
;
;	If however R5 => CDRP is the permanent CDRP associated with dynamic
;	bad block replacement, we instead retrieve the original user CDRP
;	and insert it here by calling ourselves recursively unless the original
;	user CDRP is the permanent CDRP associated with this CDDB. (Note this
;	is only true if the CONNECTION failed in CONTROLLER_INIT subroutine
;	BRING_UNIT_ONLINE.  In this isolated case we branch around the
;	recursive call to INSERT_RSTRTQ.)  In addition,
;	for this special CDRP, we proceed to kill the current bad block
;	replacement thread by calling UNLOCK_HIRT which results in releasing
;	ownership of the HIRT and awarding of it to the next CDRP on the wait
;	queue.
;
; INPUTS:
;	R3 => CDDB
;	R4 => PDT
;	R5 => CDRP
;
; OUTPUTS:
;	CDRP placed onto list in order of its SEQNUM.  Registers R0, R1, R2
;		modified.
;

INSERT_RSTRTQ:

	BSBW	DEALLOC_RESOURCES	; Call to deallocate resources.

	CMPL	R5,HIRT$L_CDRP		; See if this is CDRP for replacement.
	BNEQ	20$			; If not branch around.

; Here we special case the permanent replacement CDRP.

	PUSHL	R5			; Save R5 => permanent replacement CDRP.
	MOVL	HIRT$L_SAVDCDRP,R5	; R5 => I/O CDRP.

	MOVAB	CDDB$L_PERMCDRP(R3),R0	; R0 => CDDB permanent CDRP.
	CMPL	R0,R5			; See if "user" CDRP is this permanent one.
	BEQL	10$			; And if so, branch around recursive call.

	BSBW	INSERT_RSTRTQ		; Recursively call ourselves.
10$:
	POPL	R5			; R5 again => replacement CDRP.
	PUSHL	R3			; Save CDDB address.
	MOVL	CDRP$L_UCB(R5),R3	; R3 => UCB.
	BSBW	UNLOCK_HIRT		; Release HIRT.
	POPL	R3			; R3 => CDDB.
	BRB	50$			; Branch around to end.

; End of special case code.

20$:
	MOVAB	CDDB$L_RSTRTQFL(R3),R0	; R0 => Restart List head.
	MOVL	R0,R1			; R1 initialized to => List head.
30$:
	MOVL	(R1),R1			; R1 => next CDRP.  However if we have
					;  exhausted the list, R1=>listhead.
	CMPL	R1,R0			; See if R1 => listhead.
	BEQL	40$			; EQL means list is exhausted. Branch
					;  to insert on tail of list.

	CMPL	CDRP$L_SEQNUM(R5),-	; See if seqnum of CDRP of interest <
		CDRP$L_SEQNUM(R1)	;  than seqnum of current list entry.
	BGEQU	30$			; If NOT, go back to try next list
					;  entry.  Else fall thru and insert
					;  CDRP of interest before the
					;  current entry.
40$:
	INSQUE	(R5),@CDRP$L_FQBL(R1)	; Insert before current entry.
50$:
	RSB				; Return to caller.
	.PAGE
	.SBTTL	DEALLOC_RESOURCES and RECYCLE_RESOURCES

;+
; DEALLOC_RESOURCES - internal subroutine to deallocate all resources
;	owned by a CDRP.  In addition DEALLOC_RESOURCES clears the
;	CDRP$M_ERLOGIP bit in CDRP$W_STS.  DEALLOC_RESOURCES is called
;	from INSERT_RSTRTQ and FUNCTION_EXIT.
;
; RECYCLE_RESOURCES - Does all the above except the clearing of the
;	CDRP$M_ERLOGIP bit.  RECYCLE_RESOURCES is called from TRANSFER_REPLACE.
;
; INPUTS:
;	R4 => PDT
;	R5 => CDRP
;
; OUTPUTS:
;

DEALLOC_RESOURCES:

	CVTWL	CDRP$W_CDRPSIZE(R5),R0	; R0 has negative offset, from base of
					;  CDRP, of base of structure containing
					;  this CDRP.
	ADDL	R5,R0			; R0 => Structure containing CDRP.
	CMPB	#DYN$C_IRP,-		; See if this structure is an IRP.
		IRP$B_TYPE(R0)
	BNEQ	RECYCLE_RESOURCES	; If not, branch around.
	BICW	#CDRP$M_ERLOGIP,-	; Just in case clear bit.
		CDRP$W_STS(R5)
RECYCLE_RESOURCES:

	TSTL	CDRP$L_LBUFH_AD(R5)	; See if we have allocated mapping.
	BEQL	10$			; EQL implies NO, so branch around.
	UNMAP				; Free allocated mapping resources.
	CLRL	CDRP$L_LBUFH_AD(R5)	; Prevent redundant deallocations.
10$:
	TSTL	CDRP$L_MSG_BUF(R5)	; Do we have an MSCP buffer?
	BEQL	20$			; EQL implies NO, so branch around.
	DEALLOC_MSG_BUF			; Free MSCP buffer.
	CLRL	CDRP$L_MSG_BUF(R5)	; Prevent redundant deallocations.
20$:
	TSTL	CDRP$L_RSPID(R5)	; Have we allocated a RSPID?
	BEQL	30$			; EQL implies NO, so branch around.
	DEALLOC_RSPID			; Free up the ReSPonse ID.
30$:
	RSB				; Return to caller
	.PAGE
	.SBTTL	FUNCTION_EXIT

; FUNCTION_EXIT - 
;
; INPUTS:
;	R3 => UCB
;	R4 => PDT
;	R5 => CDRP
;


FUNCTION_EXIT:

	MOVL	CDRP$L_MSG_BUF(R5),R2	; R2 => end message.
	BEQL	20$			; EQL implies no buffer.
	BBS	#MSCP$V_EF_ERLOG,-	; Branch around if error log
		MSCP$B_FLAGS(R2),10$	;  message generated.
	BBC	#CDRP$V_ERLOGIP,-	; If no ERLOG flag in End Message and
		CDRP$W_STS(R5),20$	;  no remembered ERLOGIP, branch around.
10$:
	BICW	#CDRP$M_ERLOGIP,-	; Erase bit (= IRP$M_TERMIO) just in
		CDRP$W_STS(R5)		;  case it was set.
	JSB	G^ERL$LOGSTATUS		; Go log software status for errorlog.
20$:
	MOVQ	R0,-(SP)		; Save final I/O status on stack.

	BSBW	DEALLOC_RESOURCES	; Free resources owned by this CDRP.

	MOVQ	(SP)+,R0		; Restore final I/O status.
	MOVL	UCB$L_DU_CDDB(R3),R2	; R2 => CDDB.
	BBC	#CDDB$V_SNGLSTRM,-	; See if in one at a time CDRP mode.
		CDDB$W_STATUS(R2),100$	;  If NOT branch around PUSHAB which
					;  allows us to regain control after
					;  ALT_REQCOM.
	PUSHL	R2			; Save R2 => CDDB for after ALT_REQCOM.
	PUSHL	R4			; Likewise save R4 => PDT.
	PUSHAB	110$			; Push address to which to return after
					;  ALT_REQCOM.
100$:
	ALT_REQCOM
110$:
	POPL	R4			; Restore R4 => PDT.
	POPL	R3			;  And R3 => CDDB.
	BRW	RESTART_NEXT_CDRP	; Branch to code to restart next CDRP.
	.PAGE
	.SBTTL	re-CONNECTION after VC error or failure

; DU$CONNECT_ERR - Block of code invoked during the time that we
;	re-CONNECT to the intelligent controller following some disturbance
;	that caused dismanteling of the logical CONNECTION between the
;	class driver and the controller.  The ultimate purpose of the code
;	here is to locate all CDRP's relevant to this controller and place
;	them in the proper order into CDDB$L_RSTRTQFL.  Once
;	all the CDRP's are on this list we "execute" each of these CDRP's, one
;	by one, until they are all done.  When the last such CDRP is completed
;	we resume normal QIO processing.  This code works in cooperation with
;	code in FUNCTION_EXIT.
;
;	We are invoked here either by the Port Driver calling us at our error
;	entry point or by the Disk Class Driver branching here as a result of
;	deciding that the intelligent controller has gone "insane".
;
;	The actions herein taken are the following:
;
;	1.  We disable the Timeout Mechanism Routine wakeups by placing a
;		longword of all 1's in CRB$L_DUETIME.
;
;	2.  In order to prevent new CDRP's from starting up, we increment
;		UCB$W_RWAITCNT for each UCB associated with this controller.
;		This count is used to count the number of CDRP's associated
;		with a UCB that have run into resource wait situations.
;		Whenever this count is non-zero, new CDRP's are automatically
;		backed up onto the UCB$L_IRPQFL queue.  Incrementing this
;		count here, insures that it will not be run to zero and will
;		cause all new CDRP's to backup.
;
;	3.  We deallocate resources owned by the permanent CDRP used by the
;		Timeout Mechanism Routine.
;
;	4.  At the time that we are called here, our active CDRP's can be
;		found in one of the following places:
;
;		a) On the HIRT wait Q.  If here note that the associated UCB
;		   RWAITCNT has been bumped due to being on this list in
;		   addition to the bump given in step 2 above.
;
;		b) On the RDT resource wait Q.  Here also RWAITCNT has been
;		   bumped once to many times.
;
;		c) On the CDDB$L_CDRPQFL.  Here RWAITCNT is normal except for
;		   the bump given in step 1.
;
;		d) On some other resource wait Q (Flow control, message buffer,
;		   mapping resources, etc.). Here again RWAITCNT has been bumped
;		   once to much.
;
;		e) On the CDDB$L_RSTRTQ.  If here, the CONNECTION has failed
;		   while we were in the middle of cleaning up a previous
;		   CONNECTION failure.  The CDRP's here need no further
;		   gathering.
;
;		Our aim here is to gather all the active CDRP's onto the
;		CDDB$L_RSTRTQ.  To do this we search for them in the above
;		mentioned places in the order in which they were mentioned.
;		This order is important as will be explained below.
;
;	5.  Note here that at the time of the call to DU$CONNECT_ERR, we
;		may have been on the middle of MOUNT VERIFICATION.  In such
;		a case the particular volume would have been marked as
;		invalid and during re-CONNECTION we would not try to bring
;		the unit online.  Also we would have a set of inactive
;		(i.e. no resources allocated for them) CDRP'a (IRP's) on
;		the MOUNT VERIFICATION QUEUE of the UCB and possibly one
;		MOUNT VERIFICATION specific CDRP active.  This all meshes
;		perfectly with our re-CONNECTION design.  The contents of
;		the MOUNT VERIFICATION QUEUE can be ignored.  The active
;		MOUNT VERIFICATION CDRP will be treated normally.  Its
;		I/O will be retried and will probably fail and MOUNT
;		VERIFICATION will re-submit it and it will wind up on the
;		normal UCB I/O QUEUE awaiting the RWAITCNT's going to zero.
;		After re-CONNECTION, it will start up normally and everything
;		should resume transparently.
;
;	6.  First we scan the HIRT wait Q and remove any CDRP's associated
;		with the current CDDB.  We do this first so that if perchance,
;		some of our CDRP's are here, they will not be selected
;		inadvertantly when the current HIRT owner is possibly killed.
;
;		This scan is done by going down the entire HIRT wait Q and
;		removing the 1st entry of ours that we find.  If in a pass
;		we DO remove an entry , then we go bask and scan from the
;		start of the Q.  When we make an entire pass without any hits,
;		we finish.  Note that when we remove an entry, we decrement
;		the RWAITCNT prior to calling INSERT_RSTRTQ to undo the bump
;		we gave in calling LOCK_HIRT.
;
;	7.  We scan the RDT resource wait Q.  Again we scan until we find our
;		first entry and after a removal we begin to scan from the
;		beginning.  Only a clean scan wnds the process.  Also we
;		must decrement RWAITCNT for each removal.
;
;	8.  We REMQUE each entry on CDDB$L_CDRPQFL and call INSERT_RSTRTQ
;		for each one.
;
;	9.  Here we should note that INSERT_RSTRTQ deallocates all resources
;		owned by a CDRP prior to inserting it in CDDB$L_RSTRTQ.
;		Because of this, the only CDRP's belonging to us that still
;		own RSPID's are the CDRP's which are on other resource wait
;		queues.  So here we scan the RDT looking for entries that
;		belong to us.  When we find one we REMQUE it, decrement its
;		RWAITCNT and call INSERT_RSTRTQ for it.  Note that this
;		deallocates its resources and as a result of this could cause
;		another of our CDRP's to receive these resources and proceed
;		up to the CDDB$L_CDRPQFL.  Therefore after a removal here,
;		we branch back to step 7 to safeguard against this possibility.
;		A complete scan of the RDT with no hits implies that we now
;		have gathered all our CDRP's and that we can continue.
;
;*********************************************************************
;	9.  If the two counts above are equal, then we have all CDRP's on
;		CDDB$L_RSTRTQFL.  No more CDRP's will trickle in so we clear
;		CDDB$M_CDRPTRCKL in CDDB$W_STATUS.
;
;	10. We DISCONNECT the now dead connection and then re-CONNECT to
;		establish a new channel to the MSCP server in the controller.
;
;	11. We are now ready to begin single stream execution of CDRPs, until
;		exhaust the contents of the CDRP$L_RSTRTQFL.  However we
;		want to guard against the possibility that a particular
;		request (i.e. CDRP) may repeatedly hang a controller (i.e.
;		cause a re-CONNECTION) and thereby prevent anything from
;		getting through.  To deal with this we only retry a given
;		request a fixed maximum number of times (MAX_RETRY).  The
;		algorithm which resolves this retry logic dilemma relies
;		on several data items in the CDDB:
;
;			a) CDDB$L_RSTRTCDRP - the address of the CDRP that is
;			    currently being processed in single stream mode if
;			    we are in single stream mode.
;
;			b) CDDB$B_RETRYCNT - the number of remaining retries
;			    for the current CDRP being processes in single
;			    stream mode if we are in single stream mode.
;
;			c) CDDB$V_SNGLSTRM - bit in CDDB$W_STATUS which tells
;			    us if we are in single stream mode.
;
;		The algorithm is as follows: If upon selecting the first CDRP
;		on CDDB$L_RSTRTQFL, we find CDDB$V_SNGLSTRM clear, we merely
;		set it and we can be assurred that this is the first time
;		that we are attempting to retry this request in single stream
;		mode.  This is so because the bit being clear implies either
;		that this is the first re-CONNECTION since the system came up
;		or that the last re-CONNECTION ran to completion thereby leaving
;		the bit clear.  In this case we select this first CDRP, set
;		CDDB$B_RETRYCNT to the maximum and establish this CDRP as the
;		current one by storing its address in CDDB$L_RSTRTCDRP.
;
;		If however CDDB$V_SNGLSTRM is set upon selecting a CDRP, we
;		must compare the CDRP address to the current value of
;		CDDB$L_RSTRTCDRP.  If they are NOT equal, then again this is
;		the first retry attempt for this CDRP and we merely set the
;		CDDB$B_RETRYCNT to the maximum and store the CDRP in
;		CDDB$L_RSTRTCDRP.  If the CDRP has the same address however,
;		we must decrement one from the retry count and if it is not
;		exhausted attempt to process the CDRP again.
;
;		Note this all works even though the address of a CDRP is not
;		necessarily unique. That is, many I/O requests in the life of
;		the system may occupy the same CDRP in virtual space.  However,
;		once re-CONNECTION logic begins, it deals only with the CDRPs
;		on the CDDB$L_RSTRTQFL.  This list never grows until re-
;		CONNECTION is run to completion since all new IRPs are
;		being backed up.  Therefore even though we may run repeated
;		re-CONNECTIONs that do not run to completion but rather each
;		causes the connection to go down, through all this the
;		CDDB$L_RSTRTQFL is always monotonically decreasing and no
;		new CDRPs are entered onto it that were not there at the time
;		that we began to process the first re-CONNECTION.  In a fixed
;		list of CDRPs which all exist at the same time, the address
;		is a unique descriptor.
;
;	12. Note that CDDB$M_SNGLSTRM in CDDB$W_STATUS acts as a flag to
;		FUNCTION_EXIT so that it can aid in the one at a time re-
;		execution of the CDRP's.
;
;	13. For debugging sake, we loop thru all UCB's and check that their
;		UCB$W_RWAITCNT values are all equal to 1.
;		Also for debugging sake we check that CDDB$L_CDRPQFL is
;		empty.
;
;	14. We REMQUE the 1st CDRP on CDDB$L_RSTRTQFL and branch to
;		DU_RESTARTIO to begin its execution.
;
; Inputs: (for DU$RE_SYNCH)
;	R3 => CRB
;	R4 => PDT


DU$RE_SYNCH:

	MOVL	CRB$L_AUXSTRUC(R3),R3	; R3 => CDDB.
	BISW	#CDDB$M_RESYNCH,-	; Signal that we should reset
		CDDB$W_STATUS(R3)	;  intelligent controller.
	BRB	RECONN_COMMON		; Branch around to common code.

; Inputs: (for DU$CONNECT_ERR)
;	R3 => CDT
;	R4 => PDT
;

DU$CONNECT_ERR:

	MOVL	CDT$L_AUXSTRUC(R3),R3	; R3 => CDDB.
RECONN_COMMON:
	BICW	#CDDB$M_IMPEND,-	; Indicate that immediate command is
		CDDB$W_STATUS(R3)	;  no longer pending.
	MOVL	CDDB$L_CRB(R3),R0	; R0 => CRB.
	MNEGL	#1,CRB$L_DUETIME(R0)	; Prevent Timeout Mechanism wakeups.

	BBSS	#CDDB$V_RECONNECT,-	; Set bit meaning that we are in
		CDDB$W_STATUS(R3),20$	;  the re-CONNECTING state. Branch
	BBS	#CDDB$V_INITING,-	;  around if we were in this state
		CDDB$W_STATUS(R3),20$	;  already, so that we DO NOT bump
					;  the RWAITCNT's redundantly.
					; Also "initing" state bumps these
					;  RWAITCNT's.

	SUBL3	#UCB$L_LINK-DDB$L_UCB,-
		CDDB$L_DDB(R3),R1	; R1 => "previous" UCB.
10$:
	MOVL	UCB$L_LINK(R1),R1	; R1 => next UCB in chain.
	BEQL	20$			; EQL implies no more UCB's here.
	INCW	UCB$W_RWAITCNT(R1)	; Prevent new CDRP's from starting up.
	BRB	10$			; Go look for more UCB's.
20$:

;
; Now we are sure that no new CDRP's will start.
;
; Here we deallocate the permanent MSG_BUF and RSPID that are associated with
;	the permanent CDRP appended to the CDDB.

	MOVAB	CDDB$L_PERMCDRP(R3),R5	; R5 => permanent CDRP.
	BSBW	DEALLOC_RESOURCES	; Free resources owned by this CDRP.
	MOVAB	CDDB$L_CONNQFL(R3),-	; Initialize Q header used for
		CDDB$L_CONNQFL(R3)	;  permanent CDRP.
	MOVAB	CDDB$L_CONNQFL(R3),-	; Initialize Q header used for
		CDDB$L_CONNQBL(R3)	;  permanent CDRP.

;
;	Registers here are:
;		R3 => CDDB
;		R4 => PDT.
;		R5 => Permanent CDRP.
;
; Here we look for our CDRP's on the HIRT wait Q and remove them and place
;	them on the RESTART Q.  Note this must be done BEFORE we scan the
;	RDT resource wait Q, since we want to remove these CDRP's from
;	the HIRT wait Q before we possibly select an entry from this Q
;	and we do not want to select an entry associated with this CDDB.
;

	BBC	#HIRT$V_ACTIVE,-	; See if HIRT has been activated.
		HIRT$W_STS,70$		; If NOT, branch around.
30$:
	ASSUME	FKB$L_FQFL	EQ	0
	MOVAB	HIRT$L_RPLQFL,R0	; R0 => "previous" CDRP on wait list.
40$:
	MOVL	FKB$L_FQFL(R0),R5	; R5 => next CDRP on list.
	BEQL	70$			; EQL implies end of list.
	CMPL	R3,FKB$L_FQBL(R5)	; See if waiter has our CDDB.
	BNEQ	60$			; NEQ implies NO.
	MOVL	FKB$L_FQFL(R5),-
		FKB$L_FQFL(R0)		; Let previous point to our next.
	BNEQ	50$			; NEQ implies that current was NOT end.
	MOVL	R0,HIRT$L_RPLQTP	; Else previous is new end.
50$:
	DECW	@CDRP$L_RWCPTR(R5)	; Decrement extra bump given when
					;  we tried to allocate HIRT.
	BSBW	INSERT_RSTRTQ		; Insert this CDRP in restart Q.
	BRB	30$			; Branch back to re-scan entire
					;  HIRT wait Q.
60$:
	MOVL	R5,R0			; Current becomes previous.
	BRB	40$			; Loop back.

;
; If we are here the HIRT wait Q is free of our CDRP's.
; Here we scan the RDT resource wait list looking for any of our CDRPs which
;	may be waiting for a RSPID.  Since we always allocate RSPIDs first,
;	before allocating any other resources, any CDRP's thus found are
;	guaranteed to have no other resources to return.
;
; For each of our CDRPs found, we merely remove it from the wait list, insert
;	it in the CDDB$L_RSTRTQFL by calling INSERT_RSTRTQ.
;	This is done by RDTWAIT_DIS_ACT, the action routine specified by
;	the SCAN_RSPID_WAIT macro.
;

70$:
	MOVAB	CDDB$L_PERMCDRP(R3),R5	; R5 => Connection permanent CDRP.
	MOVL	CDRP$L_CDT(R5),R3	; R3 => CDT.
	SCAN_RSPID_WAIT	RDTWAIT_DIS_ACT	; Scan RDT wait Q, for all CDRP's
					;  found, call action routine.

; Here we remove all CDRP's on the CDBB$L_CDRPQFL.  These CDRP's either
;	have outstanding requests in the intelligent controller or suffered
;	allocation failures due to the CONNECTION failure or were the
;	ones that caused us to notice an "insane" controller.  In any
;	case, the CDRP's here are characterized by the fact that they are
;	NOT on any resource wait queue and therefore do not have their
;	RWAITCNT bumped for any other reason than the fact that the
;	CONNECTION is being re-started.  For each such CDRP we simply
;	REMQUE it and insert it it the restart queue.
;	This is done via a call to DRAIN_CDDBCDRPQ.
;

	BSBW	DRAIN_CDDBCDRPQ

; At this point we have removed any CDRPs from the RDT wait list and we
;  have accounted for any that were awaiting or undergoing bad block
;  replacement.
;
; Now we scan the RDT itself looking for our CDRP's using the SCAN_RDT macro.
;	This routine scans the entire RDT looking for any of our CDRP's.
;	If it finds one the specified action routine, RDT_DIS_ACTION, is
;	called.  This routine assumes that the found  CDRP is on a resource wait
;	queue and it REMQUE's the CDRP from it.  Also it decrements its
;	RWAITCNT.  The action routine then calls INSERT_RSTRTQ and then calls
;	DRAIN_CDDBCDRPQ since the release of resources may have pushed
;	other CDRP's onto this Q.
;

	SCAN_RDT	RDT_DIS_ACTION	; Scan RDT for out CDRP's.
	MOVL	CDT$L_AUXSTRUC(R3),R3	; Restore R3 => CDDB.

RESTART_FIRST_CDRP:

;
; We come here either by falling thru from above code or by branching here
;	from CALL_SEND_MSG_BUF when the last CDRP has trickled in.
;
;
; If here all CDRP's are in CDDB$L_RSTRTQFL.  So no more will trickle.
;	Clear bit that prevents CALL_SEND_MSG_BUF from doing its job.
;
; INPUTS:
;	R3 => CDDB
;	R4 => PDT
;


;
; Here we DISCONNECT the old connection.
;

	MOVAB	CDDB$L_PERMCDRP(R3),R5	; Put R5 => CDRP for coming BSBWs.
	MOVL	CDRP$L_CDT(R5),R3	; And set R3 => CDT for SCS calls.

	DISCONNECT	#DISCONNECT_REASON

					; Restore R3 => CDDB after disconnect.
	CVTWL	CDRP$W_CDRPSIZE(R5),R3	; R3 has negative offset, from base of
					;  CDRP, of base of CDDB.
	ADDL	R5,R3			; R3 => CDDB.
	BBCC	#CDDB$V_RESYNCH,-	; Do NOT branch around if we were called
		CDDB$W_STATUS(R3),5$	;  in order to re-synchronize.
	MRESET	CDDB$B_SYSTEMID(R3),#1	; Force controller to reset itself.
	MSTART	CDDB$B_SYSTEMID(R3)	; And force controller to restart itself.
5$:
;
; re-CONNECT - Here we call an internal subroutine which:
;
;	1. Makes a connection to the MSCP server in the intelligent
;		controller.
;
;	2. Sends an MSCP command to SET CONTROLLER CHARACTERISTICS.
;
;	3. Allocates an MSCP buffer and RSPID for our future use in
;		connection management.
;
; Upon return R4 => PDT and R5 => CDRP.
;

	BSBW	MAKE_CONNECTION		; Call subroutine to connect.

	CVTWL	CDRP$W_CDRPSIZE(R5),R0	; R0 contains negative offset of base
					;  of CDDB from base of CDRP.
	ADDL	R5,R0			; R0 => CDDB.

;
; Here we loop thru the UCBs on this controller and for each that has the
;	volume valid bit set, we try to bring it online.  We also refresh
;	connection dependent UCB fields.
;

	MOVL	CDDB$L_DDB(R0),R3	; R3 => DDB.
	MOVL	DDB$L_UCB(R3),R3	; R3 => 1st UCB.
	BEQL	30$			; EQL implies no UCBs.
10$:
	MOVL	R4,UCB$L_PDT(R3)		; Refresh UCB PDT pointer.
	MOVL	CDRP$L_CDT(R5),UCB$L_CDT(R3)	; Likewise the CDT address.

	BBC	#UCB$V_VALID,-		; If clear the volume is invalid,
		UCB$W_STS(R3),20$	;  so branch around online attempt.
	BSBW	BRING_UNIT_ONLINE	; Call subroutine to ONLINE unit.
20$:
	MOVL	UCB$L_LINK(R3),R3	; Point to next UCB if there are anymore.
	BNEQ	10$			; NEQ means there are more UCBs.
30$:
	CVTWL	CDRP$W_CDRPSIZE(R5),R3	; R3 contains negative offset of base
					;  of CDDB from base of CDRP.
	ADDL	R5,R3			; R3 => CDDB.


;
; Here we go thru the UCB chain and test the UCB$W_RWAITCNT word for the
;	value "1".  This is merely a debugging exercise.  In END_SINGLE_STREAM,
;	when we finish processing the last CDRP on the restart queue, we will
;	go down the UCB chain and set the UCB$W_RWAITCNT fields to zero.
;

	MOVL	CDDB$L_DDB(R3),R1	; R1 => DDB.
	MOVL	DDB$L_UCB(R1),R1	; R1 => 1st UCB in chain.
	BEQL	60$			; EQL implies NO UCB's on this CRB.
40$:
	CMPW	#1,UCB$W_RWAITCNT(R1)	; Make sure our logic works properly.
	BEQL	50$			; EQL implies all ok.

	BUG_CHECK	DISKCLASS,FATAL	; Some screwup.
50$:
	MOVL	UCB$L_LINK(R1),R1	; Point to next UCB.
	BNEQ	40$			; NEQ implies more UCB's exist.
60$:
;
; Here we are about to begin processing the first CDRP on the restart queue.
;	The queue of CDRP's which have active requests in the intelligent
;	controller, should be empty.  For debugging sake let's check it.
;

	MOVAB	CDDB$L_CDRPQFL(R3),R0	; R0 => listhead of CDRP's with active
					;  controller requests.
	CMPL	(R0),R0			; Empty listheads point to themselves.
	BEQL	RESTART_NEXT_CDRP	; EQL implies that all is correct.
	BUG_CHECK	DISKCLASS,FATAL


RESTART_NEXT_CDRP:

;
; Here we attempt to initiate the first (i.e. next) CDRP on the restart queue.
;	In order to prevent getting caught in an infinite loop trying to
;	initiate an operation that the controller cannot complete for
;	one reason or another, we maintain a retry count and the address
;	of the CDRP that we are currently single streaming.
;
;	In the normal case this is an isolated re-CONNECTION and the
;	first CDRP on the restart queue is a random CDRP.  We notice this
;	by seeing that the address of our first CDRP is not equal to the
;	current contents of CDDB$L_RSTRTCDRP.
;
;	In the other case the connection failed while we were in single
;	stream mode and the CDRP which we happened to be processing is the
;	same CDRP that now heads our restart queue.  In this case, before
;	initiating the processing of this CDRP, we decrement 1 from the
;	retry count and if it remains non-zero, we restart the CDRP
;	processing.  If the decrementing results in a zero retry count,
;	then we log the event and effectively abort the CDRP by branching to
;	FUNCTION_EXIT with an appropriate error status.  FUNCTION_EXIT, due
;	to the setting of the CDDB$M_SNGLSTRM bit will then start the
;	processing of the next CDRP on the restart queue.
;
; We can arrive here either by falling through from the above code or via
;	a branch from FUNCTION_EXIT.  In either case we have:
;
; INPUT:
;	R3 => CDDB
;

	REMQUE	@CDDB$L_RSTRTQFL(R3),R5	; R5 => 1st CDRP on restart queue.
	BVS	END_SINGLE_STREAM	; VS implies restart was empty.
	BBCS	#CDDB$V_SNGLSTRM,-	; Set bit and if clear, this is 1st
		CDDB$W_STATUS(R3),20$	;  time here for this CDRP, so branch.
	CMPL	R5,CDDB$L_RSTRTCDRP(R3)	; See if same CDRP as last time.
	BNEQ	20$			; NEQ implies not the same.
	DECB	CDDB$B_RETRYCNT(R3)	; If same, decrement 1 from retries.
	BNEQ	30$			; NEQ implies retries remaining.

;
; *******************************Log this error.******************************
;

	MOVL	#SS$_CTRLERR,R0		; Indicate appropriate error status.
	CLRL	R1			;  And set second part of I/O status.
	MOVL	CDRP$L_UCB(R5),R3	; R3 => UCB.
	BRW	FUNCTION_EXIT
20$:
	MOVL	R5,CDDB$L_RSTRTCDRP(R3)	; Establish new single stream CDRP.
	MOVB	#MAX_RETRY,-		; Establish fresh retry count.
		CDDB$B_RETRYCNT(R3)
30$:
	MOVL	CDRP$L_UCB(R5),R3	; R3 => UCB.
	BRW	DU_RESTARTIO		; Restart the CDRP.


END_SINGLE_STREAM:

;
; Here we want to resume normal operation and get each unit going.
;	To do this we pickup each UCB in turn and call SCS$UNSTALLUCB
;	for it.  This has the effect of starting up as many (perhaps all)
;	of the IRP's (that's right IRP's) as possible that may have
;	backed up on the UCB input queue while we were in single stream mode.
;	We then go on to the next UCB until we exhaust all UCB's connected
;	to this CDDB.
;

	BICW	#CDDB$M_SNGLSTRM!-	; Turn off single stream, one at a time
		 CDDB$M_RECONNECT,-	;  IRP processing mode, also clear state
		CDDB$W_STATUS(R3)	;  that we are re-CONNECTing.

	MOVL	CDDB$L_DDB(R3),R5	; R5 => DDB.
	MOVL	DDB$L_UCB(R5),R5	; R5 => 1st UCB in chain.
	BEQL	30$			; EQL implies no more UCB's.
10$:
	DECW	UCB$W_RWAITCNT(R5)	; Decrement out the "1" we put there.
	BEQL	20$			; EQL implies all OK.

	BUG_CHECK	DISKCLASS,FATAL
20$:
	JSB	G^SCS$UNSTALLUCB	; Start up IRPs on this UCB.
	MOVL	UCB$L_LINK(R5),R5	; R5 => Next UCB.
	BNEQ	10$			; NEQ implies that we have more UCBs.
30$:
	RSB				; UCB's exhausted.
	.PAGE
	.SBTTL	Re-CONNECT Action Routines

; RDTWAIT_DIS_ACT - action routine called during disconnect, when one of our
;	CDRP's is found on the RDT wait Q.
;
; Inputs:
;	R3 => CDT
;	R4 => PDT
;	R5 => CDRP found
;
; Outputs:
;	CDRP remque'd from RDT wait Q.
;	UCB$L_RWAITCNT decremented.
;	CDRP inserted on Restart Q.
;
;	R0 and R1 may be destroyed.
;

RDTWAIT_DIS_ACT:

	MOVQ	R2,-(SP)		; Save R2 and R3.
	MOVL	CDT$L_AUXSTRUC(R3),R3	; R3 => CDDB.
	REMQUE	(R5),R5			; Remove from RDT resource wait Q.
	DECW	@CDRP$L_RWCPTR(R5)	; Decrement RWAITCNT.
	BSBW	INSERT_RSTRTQ		; Insert CDRP on restart Q.
	MOVQ	(SP)+,R2		; Restore R2 and R3.
	RSB				; Return to caller.

; RDT_DIS_ACTION - action routine called during disconnect when one of our
;	CDRP's is found on the RDT.
;
; Inputs:
;	R3 => CDT
;	R4 => PDT
;	R5 => CDRP found
;
; Outputs:
;	CDRP remque'd from whichever resource wait Q it was on.
;	UCB$W_RWAITCNT decremented
;	CDRP inserted on Restart Q
;	DRAIN_CDDBCDRPQ called
;
;	Registers R0 and R1 may be altered
;

RDT_DIS_ACTION:

	MOVQ	R2,-(SP)		; Save R2 and R3.
	REMQUE	(R5),R5			; Remove from resource wait Q.
	DECW	@CDRP$L_RWCPTR(R5)	; Decrement RWAITCNT.
	MOVL	CDT$L_AUXSTRUC(R3),R3	; R3 => CDDB.
	BSBW	INSERT_RSTRTQ		; Insert CDRP on restart Q.
	MOVQ	(SP)+,R2		; Restore R2 and R3.
	BSBB	DRAIN_CDDBCDRPQ		; Call to drain any CDRP's here.
	RSB				; Return to caller.

; DRAIN_CDDBCDRPQ - routine called to remove CDRP's on CDDB$L_CDRPQFL and
;	to insert them in the Restart Q.
;
; Inputs:
;	R3 => CDT
;	R4 => PDT
;

DRAIN_CDDBCDRPQ:
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save all registers.
	MOVL	CDT$L_AUXSTRUC(R3),R3	; R3 => CDDB.
10$:
	REMQUE	@CDDB$L_CDRPQFL(R3),R5	; Remove 1st CDRP.
	BVS	20$			; VS implies queue is now empty.
	BSBW	INSERT_RSTRTQ		; Insert CDRP in CDDB$L_RSTRTQFL.
	BRB	10$			; Go back to empty this queue.
20$:
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore all registers.
	RSB				; Return to caller.
	.PAGE
	.SBTTL	DU$TMR - Class Driver Timeout Mechanism Routine

;+
; DU$TMR - Time out Mechanism Routine.  This routine is called
;  periodically whenever CRB$L_DUETIME becomes due.  At the time of a
;  periodic call to DU$TMR the Class Driver is in one of three states
;  with respect to the intelligent mass storage controller associated
;  with the CRB pointed at by R3.
;
;	1. State #1, the "normal" state for which this routine is optimized,
;	    is characterized by the following two conditions:
;
;		a) One or more MSCP commands are outstanding to the controller.
;		    This is determined by having a NON-empty queue of CDRP's
;		    hanging off the CDDB.
;
;		b) The oldest outstanding command was initiated since the
;		    previous invocation of DU$TMR and is therefore not very
;		    old.  This is determined by comparing the RSPID of the
;		    currently oldest command to the RSPID of the oldest request
;		    at the time of the previous invocation.  If they are not
;		    equal then we are in State #1.
;
;	2. State #2 is characterized by having NO outstanding MSCP commands in
;	    the controller.  This is determined by finding an empty CDRP queue
;	    in the CDDB.
;
;	3. State #3 is the state where MSCP commands are outstanding and the
;	    oldest one has been outstanding for at least one previous DU$TMR
;	    invocation.
;
;  If we determine that we are in state #1, we simply record the RSPID of the
;   currently oldest outstanding MSCP command in CDDB$L_OLDRSPID and we initial-
;   ize CDDB$L_OLDCMDSTS to all 1's.  We then calculate a new due time,
;   place it in CRB$L_DUETIME and return to our caller, which results
;   in scheduling ourselves for the next invocation of DU$TMR.
;
;  States #2 and #3 share some common code.  In both cases we will issue an
;   IMMEDIATE command to the controller but for diverse reasons.  In the case
;   of state #2 it will be an effective NOP command that is only issued to
;   insure against the controller timing out the host (i.e. us) due to lack of
;   activity on our part.  In the case of state #3, the IMMEDIATE command will
;   be a "GET COMMAND STATUS" for the oldest outstanding MSCP command.
;
;  The common code they share consists of code to appropriate the pre-allocated
;   MSCP buffer pointed at by CDRP$L_MSG_BUF and to pick up the pre-allocated
;   RSPID identified by CDRP$L_RSPID.  BOth these items are located in
;   the permanent CDRP which is appended to the CDDB of this intelligent
;   controller.  Also at this time a new due time is calculated prior to
;   doing the DRIVER_SEND_MSG so that we will be able to time out the
;   Immediate command.  Then the code for these two states diverges for
;   a while to prepare distinct MSCP packets, do the SEND_MSG_BUF,
;   and in the case of state #3, to do some specific processing upon
;   receipt of the END PACKET for the IMMEDIATE command.  This processing
;   consists of insuring that the command status returned in the END PACKET
;   indicates progress being made on the oldest outstanding command; and also
;   of saving this received command status in the CDDB$L_OLDCMDSTS so as to
;   have it available at the next invocation, if this oldest command is still
;   outstanding.  Following this the two code paths converge to recycle the
;   received END PACKET for use as the next IMMEDIATE MSCP buffer and to also
;   recycle the RSPID by bumping its sequence number.
;
; INPUTS:
;	R3 => CRB of the intelligent disk controller
;
; OUTPUTS:
;	Registers R0, R1, R2, R4, and R5 are all possibly modified.
;

DU$TMR:
	SETIPL	#DU_FORK_IPL		; After wakeup lower IPL.
	MOVL	CRB$L_AUXSTRUC(R3),R1	; R1 => CDDB.

	ASSUME	CDDB$L_CDRPQFL   EQ   0
	CMPL	(R1),R1			; If =, then list of CDRP's is empty
	BEQL	20$			; EQL means empty list of CDRP's,
					;  which implies we are in State #2.
	MOVL	(R1),R0			; R0 => CDRP associated with "oldest"
					;  outstanding MSCP command.

	CMPL	CDRP$L_RSPID(R0),-	; Compare RSPID of oldest request to
		CDDB$L_OLDRSPID(R1)	;  that of request current at time of
					;  previous invocation of DU$TMR.
	BEQL	30$			; EQL implies State #3, i.e. current
					;  oldest has been around for awhile.

	MOVL	CDRP$L_RSPID(R0),-	; State #1, we have a NEW oldest request
		CDDB$L_OLDRSPID(R1)	;  so record its RSPID in CDDB field.
	MNEGL	#1,CDDB$L_OLDCMDSTS(R1)	; And initialize its associated status.
10$:
	MOVZWL	CDDB$W_CNTRLTMO(R1),-(SP); Pickup controller delta.
	ADDL3	(SP)+,-			 ; Calculate delta time for next
		G^EXE$GL_ABSTIM,-	;  periodic invocation of DU$TMR.
		CRB$L_DUETIME(R3)
	RSB				; And return to caller.

20$:					; If we are here, there are NO outstand-
					;  ing requests in the controller since
					;  CDRP list is empty.
	CLRL	R0			; R0 flagged to indicate State #2.
	CLRL	CDDB$L_OLDRSPID(R1)	; Set to impossible value to prevent
					;  inadvertent comparison error.

30$:					; Common State #2, State #3 code path.
					; If here, for sure we will be issuing
					;  an immediate command to the controller.
					;  If we are in State #2, it will be a
					;  "GET UNIT STATUS" (NOP) command but
					;  if we are in State #3, it will be
					;  a "GET COMMAND STATUS" command.  For
					;  either case we begin the common setup.


	MOVL	CDDB$L_PDT(R1),R4	; Setup for SEND_MSG_BUF, R4=>PDT.
	MOVAB	CDDB$L_PERMCDRP(R1),R5	; R5 => CDRP appended to CDDB.
	BBCS	#CDDB$V_IMPEND,-	; Branch if an immediate command is NOT
		CDDB$W_STATUS(R1),40$	;  pending. Also set bit to show that
					;  one WILL be pending momentarily.
	BRW	DU$RE_SYNCH		; Bit set implies that an immediate
					;  "GET STATUS" type command has not
					;  completed in the timeout interval.
					;  So we goto resynchronization logic.

40$:
	MOVL	CDRP$L_MSG_BUF(R5),R2	; R2 => immediate command MSCP buffer.
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>		; Save registers before MOVC5 t0
	MOVC5	#0,.,#0,#MSCP$K_MXCMDLEN,(R2)	;  insure reserved fields zero.
	POPR	#^M<R0,R1,R2,R3,R4,R5>		; Then restore registers.

	MOVL	CDRP$L_RSPID(R5),-	; Insert RSPID
		MSCP$L_CMD_REF(R2)	;  as command reference #.

	BSBB	10$			; Establish due time so as to be able
					;  to timeout Immediate command.
	TSTL	R0			; Test for State #2 or State #3.
	BNEQ	50$			; NEQ implies State #3. Branch to handle it.

; State #2 specific code.
; Here we prepare the MSCP packet for the "GET UNIT STATUS" command for
;	unit #0, which is an effective NOP command.  This is done to
;	maintain minimum activity so that the controller will not time
;	out the host (i.e. us). NOTE that since the MSCP buffer has been
;	cleared above, there is no need to specify unit #0 in the command
;	buffer.
;

	MOVB	#MSCP$K_OP_GTUNT,-	; Move in "GET UNIT STATUS" opcode.
		MSCP$B_OPCODE(R2)

	BSBW	DRIVER_SEND_MSG_BUF	; Here we call to send the MSCP packet
					;  to the intelligent disk controller.

					; Return is experienced here after
					;  receipt of the END PACKET correspond-
					;  ing to the MSCP NOP sent above.  We
					;  regain control due to a callback
					;  from our own INPUT DISPATCHER
					;  ROUTINE.  Passed to us at this call-
					;  back are R2 => END PACKET, R3 => CRB,
					;  R4 => PDT and R5 => CDRP.
					; All we want to do is recycle the
					;  END PACKET for use as our next MSCP
					;  packet and recycle the RSPID.
					;  To do this we branch to common code.
	BRB	70$

50$:

; State #3 specific code.
; Here we prepare the MSCP packet for a "GET COMMAND STATUS" command.

	MOVL	CDRP$L_UCB(R0),R0	; R0 => UCB for oldest outstanding request.

	MOVW	UCB$W_UNIT(R0),-	; Setup UNIT field.
		MSCP$W_UNIT(R2)
	MOVB	#MSCP$K_OP_GTCMD,-	; Setup OPCODE field.
		MSCP$B_OPCODE(R2)

	MOVL	CDDB$L_OLDRSPID(R1),-	; Setup OUTSTANDING COMMAND REFERENCE
		MSCP$L_OUT_REF(R2)	;  field.

	BSBW	DRIVER_SEND_MSG_BUF	; Here we call to send the MSCP packet
					;  to the intelligent disk controller.

					; We experience return here upon receipt
					;  of the END PACKET for the above "GET
					;  COMMAND STATUS" command. We must make
					;  sure that progress has indeed been
					;  made on the outstanding command.  We
					;  therefore compare the outstanding
					;  command status returned in the END
					;  PACKET to the previous value in CDDB
					;  field CDDB$L_OLDCMDSTS.
					; Here R2=>END PACKET, R3=>CRB, R4=>PDT
					;  and R5=>CDRP.

	MOVL	CRB$L_AUXSTRUC(R3),R1	; R1 => CDDB.
	CMPL	MSCP$L_CMD_STS(R2),-	; Compare received outstanding command
		CDDB$L_OLDCMDSTS(R1)	;  status to previous value.
	BLSSU	60$			; LSSU implies progress made so branch.
	BRW	DU$RE_SYNCH		; Anything else implies no progress
					;  has been made.  So we goto
					;  re-synchronize with the intelligent
					;  disk controller and re-issue all
					;  outstanding commands.

60$:
	MOVL	MSCP$L_CMD_STS(R2),-	; Remember this received outstanding
		CDDB$L_OLDCMDSTS(R1)	;  command status for next time.

70$:					; States #2 and #3 code paths merge here.
	RECYCH_MSG_BUF		; Recycle END PACKET.
	RECYCL_RSPID			; Likewise the RSPID.

	MOVL	CRB$L_AUXSTRUC(R3),R1	; R1 => CDDB.
	BICW	#CDDB$M_IMPEND,-	; Indicate that immediate command is
		CDDB$W_STATUS(R1)	;  no longer pending.
	RSB				; Return to caller and kill thread.
	.PAGE
	.SBTTL	DU$IDR - Class Driver Input Dispatch Routine

;+
; DU$IDR - Class Driver Input Dispatching Routine.  This routine is to
;	the class driver what the Interrupt Service Routine is to a
;	conventional driver.  We are called here by the Port Driver
;	and we are passed the address of an END PACKET or an ATTENTION
;	MESSAGE buffer.  By testing a bit in the ENDCODE field of the
;	received buffer we determine which of the two has been received.
;	For ATTENTION MESSAGES we immediately branch to ATTN_MSG.
;
;	For END PACKETs we first determine if the END PACKET is still of
;	interest.  This is done by testing whether the COMMAND REFERENCE
;	NUMBER returned in the END PACKET, interpreted as a RSPID, is
;	still valid.  If not, we merely deallocate the END PACKET and
;	return to our caller in the Port Driver.
;
;	If the END PACKET is still of interest then before dispatching
;	to the code that originally issued the MSCP command for which we
;	have just received the END PACKET, we first remove the
;	CDRP associated with the command from the list of active CDRP's
;	defined by the listhead located at CDDB$L_CDRPQFL.
;
; INPUTS:
;	R1 =  Message Length
;	R2 => END PACKET or ATTENTION MESSAGE BUFFER
;	R3 => Connection Data Block
;-
	.enabl	lsb
DU$IDR:
	BBC	#MSCP$V_OP_END,-	; Is this an ATTENTION MESSAGE
		MSCP$B_OPCODE(R2),-	;  or an END PACKET;
		ATTN_MSG		;  bit clear implies ATTENTION.

	MOVL	G^SCS$GL_RDT,R0		; R0 => base of the RDT.
	MOVZWL	MSCP$L_CMD_REF(R2),R5	; Pickup RDTE index from END PACKET.
	CMPL	R5,RDT$L_MAXRDIDX(R0)	; Bounds check on index.
	BGEQ	10$			; GEQ implies out of bounds.
	MOVAQ	(R0)[R5],R5		; R5 => RDTE of interest.

	CMPW	RD$W_SEQNUM(R5),-	; See if RSPID is still valid by com-
		MSCP$L_CMD_REF+2(R2)	;  paring the sequence number.
	BEQL	20$			; EQL implies valid RSPID.
10$:
	DEALLOC_MSG_BUF_REG		; Deallocate END PACKET Buffer if invalid.
	RSB				;  And return to caller.

20$:
	MOVL	RD$L_CDRP(R5),R5	; R5 => CDRP.
	MOVL	CDRP$L_CDT(R5),R0	; R0 => CDT.
	MOVL	CDT$L_AUXSTRUC(R0),R0	; R0 => CDDB.
	CMPL	CDDB$L_OLDRSPID(R0),-	; See if oldest outstanding command has
		MSCP$L_CMD_REF(R2)	;  this Command Reference Number.
	BNEQ	25$			; If not, branch around.
	CLRL	CDDB$L_OLDRSPID(R0)	; Prevent inadvertent timeouts due to
					;  reuse of RSPID in error situations.
25$:
	MOVL	R2,CDRP$L_MSG_BUF(R5)	; Pass packet address in CDRP also.

	REMQUE	(R5),R5			; Remove R5=>CDRP from list.
	BBC	#IRP$V_DIAGBUF,-	; Branch around if no P6 buffer.
		CDRP$W_STS(R5),30$
	BSBW	DUMP_ENDMESSAGE		; If P6 buffer, record MSCP END
					;  message sent in buffer.
30$:

	MOVQ	CDRP$L_FR3(R5),R3	; Restore R3 and R4.
	JSB	@CDRP$L_FPC(R5)		; Dispatch to issuer of MSCP command.
	RSB				; Return to our caller.

ATTN_MSG:
	MOVQ	R1,-(SP)		; Save R1 = Length, R2 => Attention packet.
	CMPB	#MSCP$K_OP_AVATN,-	; Is this an AVAILABLE attention?
		MSCP$B_OPCODE(R2)
	BNEQ	50$			; If NOT, branch around.
	MOVL	R3,R5			; R5 => CDT.
	MOVL	CDT$L_AUXSTRUC(R5),R3	; R3 => CDDB.
	MOVZWL	MSCP$W_UNIT(R2),R0	; R0 = unit number.
	PUSHL	R0			; Save unit number on stack.
	BSBW	LOOKUP_UCB		; Search for existing UCB.
	BLBS	R0,40$			; LBS means we already have a UCB,
					;  so ignore this attention.
	PUSHL	R3			; Save R3.
	MOVZWL	#UCB$K_DU_LENGTH,R1	; Get length of UCB to allocate.
	JSB	G^EXE$ALONONPAGED	; Allocate non-paged pool.
	POPL	R3			; Restore R3.
	BLBC	R0,40$			; LBC means no space, so ignore.
	MOVL	(SP),R0			; Get unit number.
	BSBW	INIT_UCB		; Initialize UCB.
	MOVL	8(SP),R0		; R0 => End message.
	MOVL	MSCP$L_MEDIA_ID(R0),R0	; R0 = Media ID.
	BSBW	GET_DEVTYPE		; Returns R0 = DEVTYPE.
	MOVB	R0,UCB$B_DEVTYPE(R2)	; Store in UCB.
	MOVL	R5,R0			; R0 => CDT.
	BSBW	INIT_CONNDEP_UCB	; Init connection dependent fields.
	DECW	UCB$W_RWAITCNT(R2)	; Take away initial setting.
	BSBW	CHAIN_UCB		; Put on UCB chain.
40$:
	TSTL	(SP)+			; Cleanup unit number.
	MOVL	R2,R3			; R3 => UCB for call to log message.
	MOVQ	(SP)+,R1		; Restore R1=length, R2 => Attention Message.
	MOVZWL	#EMB$C_AVATN,R0		; Pass message sub-type.
	JSB	G^ERL$LOGMESSAGE	; Call to log attention message.
	BRW	10$			; Branch back to free up packet.
50$:
	CMPB	#MSCP$K_OP_DUPUN,-	; Is this a Duplicate Unit attention?
		MSCP$B_OPCODE(R2)
	BNEQ	70$			; If NOT, branch around.
	MOVL	CDT$L_AUXSTRUC(R3),R3	; R3 => CDDB.
	MOVZWL	MSCP$W_UNIT(R2),R0	; R0 = unit number.
	BSBW	LOOKUP_UCB		; Search for existing UCB.
	BLBC	R0,60$			; LBC means we do NOT have a UCB,
					;  so ignore this attention.
	MOVL	R2,R5			; R5 => UCB of Duplicate.
	BSBB	SEND_DUPUNIT		; Call to send OPCOM message.
	MOVL	R5,R3			; R3 => UCB for call to log message.
	MOVQ	(SP),R1			; Restore R1=length, R2 => Attention Message.
	MOVZWL	#EMB$C_DUPUN,R0		; Pass message sub-type.
	JSB	G^ERL$LOGMESSAGE	; Call to log attention message.
60$:
	MOVQ	(SP)+,R1		; Restore R1=length, R2 => Attention Message.
	BRW	10$			; Branch back to free up packet.
70$:
	CMPB	#MSCP$K_OP_ACPTH,-	; Is this an Access Path attention?
		MSCP$B_OPCODE(R2)
	BNEQ	80$			; If NOT, branch around.
	MOVL	CDT$L_AUXSTRUC(R3),R3	; R3 => CDDB.
	MOVZWL	MSCP$W_UNIT(R2),R0	; R0 = unit number.
	BSBW	LOOKUP_UCB		; Search for existing UCB.
	BLBC	R0,60$			; LBC means we do NOT have a UCB,
					;  so ignore this attention.
	MOVL	R2,R3			; R3 => UCB for call to log message.
	MOVQ	(SP),R1			; Restore R1=length, R2 => Attention Message.
	MOVZWL	#EMB$C_ACPTH,R0		; Pass message sub-type.
	JSB	G^ERL$LOGMESSAGE	; Call to log attention message.
	BRB	60$			; Branch back to restore stack and free.
80$:
	.dsabl	lsb
	BUG_CHECK	DISKCLASS,FATAL	; For now.
	.PAGE
	.SBTTL	SEND_DUPUNIT

; SEND_DUPUNIT - send a duplicate Unit number message to OPCOM.
;
; Inputs:
;	R5 => UCB
;
; Outputs:
;	All registers preserved.
;

SEND_DUPUNIT:

	PUSHR	#^M<R0,R1,R2,R3,R4>	; Save registers.
	MOVZBL	#MSG$_DUPUNITNO,R4	; Get messge #.
	MOVAB	G^SYS$GL_OPRMBX,R3	; R3 => operator mailbox.
	JSB	G^EXE$SNDEVMSG		; Call to send message.
	POPR	#^M<R0,R1,R2,R3,R4>	; Restore registers.
	RSB				; Return to caller
	.PAGE
	.SBTTL	DU$DGDR	- Data Gram Dispatch Routine
;
; Inputs:
;
;	R1 =  length of datagram
;	R2 => datagram
;	R3 => CDT
;	R4 => PDT

DU$DGDR:

	MOVL	CDT$L_AUXSTRUC(R3),R0	; R0 => CDDB
	MOVL	R3,R5			; Save pointer to CDT.
	SUBL3	#UCB$L_LINK-DDB$L_UCB,-	; R3 => "previous" UCB.
		CDDB$L_DDB(R0),R3
10$:
	MOVL	UCB$L_LINK(R3),R3	; R3 => next UCB.
	BEQL	20$			; No more UCBs.
	CMPW	UCB$W_UNIT(R3),-	; See if datagram (error log packet)
		MSCP$W_UNIT(R2)		;  for this unit.
	BNEQ	10$			; If not, branch abck to try next unit.
	MOVZWL	#EMB$C_DM,R0		; Put type of message into R0.
	JSB	G^ERL$LOGMESSAGE	; And call to log message.
20$:
	MOVL	R5,R3			; Restore R3 => CDT.
	SUBL	PDT$L_DGOVRHD(R4),R2	; R2 => SCS header of datagram.
	QUEUE_DG_BUF			; Requeue datagram buffer.
	RSB				; Return to port.
	.PAGE
	.SBTTL	"Register" Dump Routines

;+
; Routines that write the contents of the MSCP Command and MSCP End
;	Messages into the P6 buffer.
;
; DUMP_COMMAND - called before the MSCP command is sent to the Port.
; DUMP_ENDMESSAGE - called after receipt of an End message.
;
; DUMP_COMMAND Inputs:
;	R5 => CDRP
;

DUMP_COMMAND:
	MOVQ	R0,-(SP)		; Save registers that we use here.
	MOVL	@CDRP$L_DIAGBUF(R5),R0	; R0 => diagnostic buffer.
	ADDL	#20,R0			; R0 => beyond header (see
					;  IOC$DIAGBUFILL in IOSUBNPAG).
	MOVL	CDRP$L_MSG_BUF(R5),R1	; R1 => MSCP command.

	ASSUME	MSCP$K_MXCMDLEN	EQ	36
	MOVQ	(R1)+,(R0)+		; Copy MSCP command to buffer.
	MOVQ	(R1)+,(R0)+		;		"
	MOVQ	(R1)+,(R0)+		;		"
	MOVQ	(R1)+,(R0)+		;		"
	MOVL	(R1),(R0)		;		"
	MOVQ	(SP)+,R0		; Restore registers.
	RSB				; Return to caller.

;
; DUMP_ENDMESSAGE Inputs:
;
;	R1 => END Message Length
;	R2 => END Message
;	R5 => CDRP
;

DUMP_ENDMESSAGE:

	PUSHR	#^M<R0,R1,R2,R3>	; Save registers.
	MOVL	@CDRP$L_DIAGBUF(R5),R0	; R0 => P6 buffer.
	ADDL	#8,R0			; Go past start time.
	MOVQ	G^EXE$GQ_SYSTIME,(R0)+	; Save ending time.
	CLRL	(R0)+			; Clear retry counts.
	ADDL	#MSCP$K_MXCMDLEN,R0	; Go past command message.
	ASHL	#-2,R1,R1		; Shift to # longwords.
	MOVL	#MSCP$K_LEN/4,R3	; R3 = length of longest end message.
10$:
	MOVL	(R2)+,(R0)+		; Copy a longword of End message.
	DECL	R3			; Decrement.
	SOBGTR	R1,10$			; Copy entire End message.
	BRB	30$			; Branch around.
20$:
	CLRL	(R0)+			; Zero out beyond end message.
30$:
	SOBGEQ	R3,20$			; Loop thru entire P6 buffer.
	POPR	#^M<R0,R1,R2,R3>	; Restore registers.
	RSB				; Return to caller.
	.PAGE
	.SBTTL	DU_UNSOLNT

DU_UNSOLNT:
	BUG_CHECK	DISKCLASS,FATAL
	.PAGE
DU_END:
	.END
