	.TITLE	XFDRIVER - DR32 DRIVER
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	EXECUTIVE, I/O DRIVERS
;
; ABSTRACT:
;	THIS MODULE IS THE DRIVER FOR THE DR32.
;
; ENVIRONMENT:	KERNEL MODE, NON-PAGED
;
; AUTHOR:  STEVE BECKHARDT,	CREATION DATE:  23-FEB-1979
;
; MODIFIED BY:
;
;	V02-012	TCM0001		Trudy C. Matthews	31-Jul-1981
;		Change all "7ZZ"s to "730"s.
;
;	V02-011	EAD0011		Elliott A. Drayton	13-Feb-1981
;		Add code to raise and lower IPL to prevent
;		race condition.
;
;	V02-010	SRB0006		Steve Beckhardt		17-Sep-1979
;		Modified the driver to support the DR750.
;
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
	$ACBDEF				; AST CONTROL BLOCK OFFSETS
	$ADPDEF				; ADP OFFSETS
	$CRBDEF				; CRB OFFSETS
	$DCDEF				; DEVICE CLASSES AND TYPES
	$DDBDEF				; DDB OFFSETS
	$DPTDEF				; DRIVER PROLOGUE TABLE DEFINITIONS
	$DYNDEF				; STRUCTURE TYPE CODE DEFINITIONS
	$EMBDEF				; EMB OFFSETS
	$FKBDEF				; FKB OFFSETS
	$IDBDEF				; IDB OFFSETS
	$IPLDEF				; IPL DEFINITIONS
	$IODEF				; I/O FUNCTION CODES
	$IRPDEF				; IRP OFFSETS
	$IRPEDEF			; IRPE OFFSETS
	$PCBDEF				; PCB OFFSETS
	$PRDEF				; PROCESSOR REGISTER DEFINITIONS
	$PRIDEF				; PRIORITY INCREMENT CLASS DEFINITIONS
	$PRTDEF				; PROTECTION CODE DEFINITIONS
	$PTEDEF				; PTE DEFINITIONS
	$SSDEF				; SYSTEM STATUS VALUES
	$UCBDEF				; UCB OFFSETS
	$VADEF				; VIRTUAL ADDRESS FIELD DEFINTIONS
	$VECDEF				; INTERRUPT DISPATCH VECTOR OFFSETS
	$XFDEF				; DR32 DEFINITIONS

;
; MACROS:
;

;
; EQUATED SYMBOLS:
;

; 
; QIO ARGUMENT LIST OFFSETS
;

P1=0					; 1ST FUNCTION DEPENDENT PARAMETER
P2=4					; 2ND     "        "         "
P3=8					; 3RD     "        "         "

; 
; MISC. DEFINITIONS
;

DR780_MAXRATE=251			; MAXIMUM DATA RATE VALUE FOR DR780
DR750_MAXRATE=252			; MAXIMUM DATA RATE VALUE FOR DR750

IRP$L_PKTASTADR=IRP$L_ABCNT		; OFFSET OF PACKET AST ADDRESS IN IRP
IRP$L_PKTASTPRM=IRP$L_OBCNT		; OFFSET OF PACKET AST PARAMETER
IRP$B_RATE=IRP$L_IOST2			; OFFSET OF DATA RATE
IRP$B_FLAGS=IRP$L_IOST2+1		; OFFSET OF COMMAND TABLE FLAGS

IRPE$L_CBLKADR=IRPE$L_BCNT2+4		; OFFSET OF COMMAND BLOCK ADDRESS
IRPE$L_BBLKADR=IRPE$L_BCNT2+8		; OFFSET OF BUFFER BLOCK ADDRESS

;
; DR32 DEVICE REGISTER DEFINITIONS
;

	$DEFINI	DR
$DEF	DR_DCR		.BLKL	1	; DR32 CONTROL REGISTER
	_VIELD	DR_DCR,0,<-
		<ADPTYP,8>,-		; ADAPTER TYPE
		<ID2ERR,,M>,-		; ID2 ERROR
		<ID2TOC,,M>,-		; ID2 TIMEOUT CAUSE
		<ID2TO,,M>,-		; ID2 TIMEOUT
		<STALL,,M>,-		; DDI STALL
		<ID1ERR,,M>,-		; ID1 ERROR
		<ID1TOC,,M>,-		; ID1 TIMEOUT CAUSE
		<ID1TO,,M>,-		; ID1 TIMEOUT
		<RDS,,M>,-		; READ DATA SUBSTITUTE
		<CRD,,M>,-		; CORRECTED READ DATA
		<DCRHLT,,M>,-		; DCR HALT
		<DCRABT,,M>,-		; DCR ABORT INTERRUPT
		<PKTINT,,M>,-		; PACKET INTERRUPT
		<INTENB,,M>,-		; INTERRUPT ENABLE
		<,1>,-			; RESERVED
		<PWR_UP,,M>,-		; ADAPTER POWER UP
		<PWR_DN,,M>,-		; ADAPTER POWER DOWN
		<EXTABT,,M>,-		; EXTERNAL ABORT
			-		; NOTE:  THE NEXT 7 BITS ARE USED BY
			-		; DR750 ONLY.  THE DR780 HAS THESE BITS
			-		; IN THE DR_UTL REGISTER.
		<FCIPE,,M>,-		; FORCE CONTROL INTERCONNECT PARITY ERR.
		<FDIPE,,M>,-		; FORCE DATA INTERCONNECT PARITY ERROR
		<ENPEAB,,M>,-		; ENABLE D.I. PARITY ERROR ABORT
		<WCSPE,,M>,-		; WCS PARITY ERROR
		<CIPE,,M>,-		; CONTROL INTERCONNECT PARITY ERROR
		<DIPE,,M>,-		; DATA INTERCONNECT PARITY ERROR
		<PARERR,,M>,-		; PARITY ERROR (OR OF LAST 3 BITS)
	>

; DCR CONTROL FIELD A CODES (USED WHEN WRITING TO DCR)

DCR_K_CLRPWRUP=^X100			; CLEAR POWER UP
DCR_K_CLRPWRDN=^X200			; CLEAR POWER DOWN
DCR_K_CLRABTINT=^X400			; CLEAR ABORT INTERRUPT
DCR_K_CLRINTENB=^X500			; CLEAR INTERRUPT ENABLE
DCR_K_SETINTENB=^X600			; SET INTERRUPT ENABLE
DCR_K_CLRHLT=^X700			; CLEAR HALT

; DCR CONTROL FIELD B CODES (USED WHEN WRITING TO DCR)

DCR_K_CLRCRD=^X1000			; CLEAR CRD
DCR_K_SETEXTABT=^X2000			; SET EXTERNAL ABORT
DCR_K_CLRPKTINT=^X3000			; CLEAR PACKET INTERRUPT
DCR_K_RESET=^X4000			; RESET
DCR_K_SETOSQTST=^X5000			; SET OSEQ TEST
DCR_K_CLROSQTST=^X6000			; CLEAR OSEQ TEST

$DEF	DR_UTL		.BLKL	1	; UTILITY REGISTER
	_VIELD	DR_UTL,0,<-
		<RATE,8>,-		; DATA RATE
		<,3>,-			; RESERVED
		<VALID,,M>,-		; WCS VALID
		<,13>,-			; RESERVED
			-		; NOTE:  THE NEXT 7 BITS ARE USED BY
			-		; DR780 ONLY.  THE DR750 HAS THESE BITS
			-		; IN THE DR_DCR REGISTER.
		<FCIPE,,M>,-		; FORCE CONTROL INTERCONNECT PARITY ERR.
		<FDIPE,,M>,-		; FORCE DATA INTERCONNECT PARITY ERROR
		<ENPEAB,,M>,-		; ENABLE D.I. PARITY ERROR ABORT
		<WCSPE,,M>,-		; WCS PARITY ERROR
		<CIPE,,M>,-		; CONTROL INTERCONNECT PARITY ERROR
		<DIPE,,M>,-		; DATA INTERCONNECT PARITY ERROR
		<PARERR,,M>,-		; PARITY ERROR (OR OF LAST 3 BITS)
	>

$DEF	DR_WCSA		.BLKL	1	; WCS ADDRESS
	_VIELD	DR_WCSA,0,<-
		<SEL,,M>,-		; SELECT (LOW OR HI PART OF MICRO WORD)
		<ADDR,10>,-		; ADDRESS
		<,20>,-			; RESERVED
		<WCS,,M>,-		; LOAD WCS FLAG (DR750 ONLY)
	>
	_VIELD	DR_WCSA,0,<-
		<LSADR,11>,-		; LOCAL STORE ADDRESS (DR750 ONLY)
	>

$DEF	DR_WCSD		.BLKL	1	; WCS DATA

			.BLKL	1	; RESERVED

$DEF	DR_SBIADR	.BLKL	1	; SBI ADDRESS

$DEF	DR_SBIBCNT	.BLKL	1	; SBI BYTE COUNT

$DEF	DR_DDIBCNT	.BLKL	1	; DDI BYTE COUNT

	;
	; DEFINE USER CONTROL REGISTER (GO BIT)
	;

.=^X200					; STARTS ON 2ND PAGE OF DR ADDRESS SPACE

$DEF	DR_USER		.BLKL	1	; USER CONTROL REGISTER
	_VIELD	DR_USER,0,<-
		<GO,,M>,-		; GO BIT
		<,31>,-			; RESERVED
	>

	;
	; DEFINE LOCAL STORE ADDRESSES FOR DR780
	; THESE ARE ADDRESSED AS OFFSETS FROM THE FIRST DEVICE REGISTER
	;

.=^X400					; STARTS ON 3RD PAGE OF DR ADDRESS SPACE

$DEF	DR_780_DSL	.BLKL	1	; DR32 STATUS LONGWORD
$DEF	DR_780_SBR	.BLKL	1	; SYSTEM BASE REGISTER
$DEF	DR_780_GBR	.BLKL	1	; GLOBAL PAGE TABLE BASE REGISTER
$DEF	DR_780_CMDBVA	.BLKL	1	; BASE VIRTUAL ADDR. COMMAND BLOCK
$DEF	DR_780_CMDLEN	.BLKL	1	; LENGTH OF COMMAND BLOCK
$DEF	DR_780_CMDSVAPT	.BLKL	1	; SVAPTE OF COMMAND BLOCK
$DEF	DR_780_BFRBVA	.BLKL	1	; BASE VIRTUAL ADDR. BUFFER BLOCK
$DEF	DR_780_BFRLEN	.BLKL	1	; LENGTH OF BUFFER BLOCK
$DEF	DR_780_BFRSVAPT	.BLKL	1	; SVAPTE OF BUFFER BLOCK

	;
	; DEFINE LOCAL STORE ADDRESSES FOR DR750
	; THESE ARE ADDRESSED BY LOADING THEIR ADDRESS INTO THE DR_WCSA
	; REGISTER AND READING OR WRITING THE DR_WCSD REGISTER
	;

.=0					; START OF LOCAL STORE REGISTERS

$DEF	DR_750_DSL	.BLKB	1	; DR32 STATUS LONGWORD
$DEF	DR_750_SBR	.BLKB	1	; SYSTEM BASE REGISTER
$DEF	DR_750_GBR	.BLKB	1	; GLOBAL PAGE TABLE BASE REGISTER
$DEF	DR_750_CMDBVA	.BLKB	1	; BASE VIRTUAL ADDR. COMMAND BLOCK
$DEF	DR_750_CMDLEN	.BLKB	1	; LENGTH OF COMMAND BLOCK
$DEF	DR_750_CMDSVAPT	.BLKB	1	; SVAPTE OF COMMAND BLOCK
$DEF	DR_750_BFRBVA	.BLKB	1	; BASE VIRTUAL ADDR. BUFFER BLOCK
$DEF	DR_750_BFRLEN	.BLKB	1	; LENGTH OF BUFFER BLOCK
$DEF	DR_750_BFRSVAPT	.BLKB	1	; SVAPTE OF BUFFER BLOCK

	$DEFEND	DR


;
; DR32 SPECIFIC UCB OFFSETS
;

	$DEFINI	UCB

.=UCB$L_DPC+4

	_VIELD	UCB,0,<-		; DEFINE BITS FOR UCB$W_DEVSTS
		<ADPPWRUP,,M>,-		;  ADAPTER POWER UP
		<FKLOCK,,M>,-		;  FORK INTERLOCK BIT
		<ABORT,,M>,-		;  ABORT PENDING
		<DR750,,M>,-		;  INDICATES DEVICE IS DR750
	>

$DEF	UCB$L_DCR	.BLKL	1	; STORED COPY OF DCR REGISTER
$DEF	UCB$L_SAVSTATUS	.BLKL	1	; SAVED STATUS FOR DRIVER ABORTS
$DEF	UCB$L_SAVDCR	.BLKL	1	; SAVED COPY OF DCR REGISTER

UCB$K_SIZE=.

	$DEFEND	UCB


;
; OWN STORAGE:
;
;
; DRIVER PROLOGUE TABLE
;
	DPTAB	END=XF_END,-		; END OF DRIVER
		ADAPTER=DR,-		; ADAPTOR TYPE
		UCBSIZE=UCB$K_SIZE,-	; UCB SIZE
		NAME=XFDRIVER		; DRIVER NAME

	DPT_STORE INIT

	DPT_STORE UCB,UCB$B_FIPL,B,8	; FORK IPL
;***
; FORK IPL OK?
;***
	DPT_STORE UCB,UCB$L_DEVCHAR,L,-	; DEVICE CHARACTERISTICS
		<DEV$M_AVL-		; AVAILABLE
		!DEV$M_ELG-		; ERROR LOGGING ENABLED
		!DEV$M_RTM-		; REAL TIME DEVICE
		!DEV$M_IDV-		; INPUT DEVICE
		!DEV$M_ODV>		; OUTPUT DEVICE
	DPT_STORE UCB,UCB$B_DEVCLASS,B,DC$_REALTIME	; DEVICE CLASS
	DPT_STORE UCB,UCB$B_DIPL,B,22		; DEVICE IPL


	DPT_STORE REINIT

	DPT_STORE DDB,DDB$L_DDT,D,XF$DDT		; DDT ADDRESS
	DPT_STORE CRB,CRB$L_INTD+4,D,INTERRUPT_SVC	; INTERRUPT SERVICE
	DPT_STORE CRB,CRB$L_INTD+VEC$L_UNITINIT,D,UNIT_INIT ; UNIT INIT.

	DPT_STORE END

;
; DRIVER DISPATCH TABLE
;
	DDTAB	XF,-			; DEVICE NAME
		STARTIO,-		; START I/O ENTRY POINT
		0,-			; UNSOLICITED INTERRUPT
		FUNCTABLE,-		; FUNCTION DECISION TABLE
		CANCEL_IO,-		; CANCEL I/O
		REGDUMP,-		; REGISTER DUMP ROUTINE
		<36+160>,-		; SIZE OF DIAGNOSTIC BUFFER
		<EMB$L_DV_REGSAV+4+160>	; SIZE OF ERROR LOGGING BUFFER

;
; FUNCTION DECISION TABLE
;
FUNCTABLE:
	FUNCTAB	,<LOADMCODE,-			; LEGAL FUNCTIONS
		STARTDATA,-
		STARTDATAP>
	FUNCTAB					; NO BUFFERED I/O FUNCTIONS
	FUNCTAB	LOAD_MICROCODE,<LOADMCODE>	; LOAD MICROCODE
	FUNCTAB	STARTDATA_FDT,<STARTDATA,-	; START DATA
			    STARTDATAP>		; START DATA PHYSICAL


	.SBTTL	LOAD_MICROCODE - Load microcode FDT routine
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is an FDT routine which performs the Load Microcode
;	QIO.  It locks the microcode image in memory, verifies that the
;	device is not busy, loads and then verifies the microcode.
;	Verification consists of addressing all the locations in the WCS
;	and checking for a parity error.
;	If the microcode is loaded successfully, the the WCS valid bit
;	is set in the DR32.
;	This routine also sets the data rate to the last value stored
;	in the device dependent characteristics.
;
; CALLING SEQUENCE:
;
;	Called from the FDT routine dispatcher in the QIO system service.
;	On completion jumps to EXE$FINISHIOC.
;
; INPUT PARAMETERS:
;
;	R3	Address of I/O packet.
;	R4	Current process PCB address.
;	R5	Address of UCB.
;	R6	Address of CCB.
;	P1(AP)	Address of microcode image.
;	P2(AP)	Size (in bytes) of microcode image.
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0	Contains a completion code
;
; IMPLICIT OUTPUTS:
;
;	The WCS valid bit is set in the DR32.
;
; COMPLETION CODES:
;
;	These are in addition to the ones EXE$WRITELOCK can return:
;
;	SS$_NORMAL	Successful completion
;	SS$_PARITY	Parity error detected during microcode verification
;	SS$_DEVACTIVE	Device is active
;	SS$_POWERFAIL	Device is powered down
;
; SIDE EFFECTS:
;
;	None
;
;--

LOAD_MICROCODE:
	MOVL	P1(AP),R0		; Get address of microcode image
	MOVZWL	P2(AP),R1		; Get size of image (in bytes)
	MOVQ	R0,R9			; Save address and size in R9 and R10
	JSB	G^EXE$WRITELOCK		; Lock image into memory
	BICW	#UCB$M_POWER,UCB$W_STS(R5) ; Clear powerfail bit

	ASSUME	IDB$L_CSR  EQ  0

	MOVL	UCB$L_CRB(R5),R4	; Get pointer to CRB
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R4 ; Get address of 1st device CSR

10$:	; R4 contains address of 1st device CSR.  Make sure device has
	; power before accessing any device registers.  Then, if the device
	; is not busy, reset it and clear WCS valid.

	ASSUME	UCB_V_ADPPWRUP  EQ  0

	MOVZWL	#SS$_POWERFAIL,R0	; Assume error
	BLBC	UCB$W_DEVSTS(R5),15$	; Branch if adapter has no power

	MOVZWL	#SS$_DEVACTIVE,R0	; Assume device is active
	DSBINT	UCB$B_FIPL(R5)		; Raise IPL to fork level
	BBC	#UCB$V_BSY,UCB$W_STS(R5),17$	; Br. if UCB is not busy
15$:	BRW	80$			; Finish I/O
17$:	MOVZWL	#DCR_K_RESET,DR_DCR(R4)	; Reset DR32
	BICL	#DR_UTL_M_VALID,-	; Clear WCS valid bit
		DR_UTL(R4)
	ENBINT				; Lower IPL

	; Load last data rate saved in device dependent characteristics.

	MOVL	DR_UTL(R4),R0		; Get contents of Utility reg.
	MOVB	UCB$L_DEVDEPEND(R5),R0	; Load data rate
	MOVL	R0,DR_UTL(R4)		; Put back into Utility reg.

	; Set up to load microcode.  R0 will contain address of microcode image.
	; R1 will contain size of image in bytes.  Convert this to number
	; of WCS words by dividing by 5 (each WCS word contains 5 bytes).
	; R2 will be used to contain WCS address.

	ASSUME	DR_WCSA_V_SEL EQ 0
	ASSUME	DR_WCSA_V_ADDR EQ 1

	MOVQ	R9,R0			; Restore address and size in R0 and R1
	DIVL	#5,R1			; Convert bytes to number of WCS words.
	BEQL	40$			; Load zero words
	DECL	R1			; Convert to address of highest word
	MULL	#2,R1			; Account for address being incr. by 2
	MOVL	R1,R11			; Save number of WCS words
	CLRL	R2			; Start loading at zero

20$:	; Load next WCS word.  Each word gets loaded in two parts.  First
	; four bytes get loaded and then one byte gets loaded.
	; On the DR750, it is necessary to set the WCS flag bit to
	; distinguish between accessing WCS and local store.  This bit has
	; no effect on the DR780.

	BISL3	#DR_WCSA_M_WCS,-	; Load WCS address
		R2,DR_WCSA(R4)
	MOVL	(R0)+,DR_WCSD(R4)	; Load four bytes
	BISL3	#DR_WCSA_M_WCS!-	; Load WCS address and set SELECT bit
		 DR_WCSA_M_SEL,R2,DR_WCSA(R4)
	MOVZBL	(R0)+,DR_WCSD(R4)	; Load one byte
	ACBL	R1,#2,R2,20$		; Repeat load loop

	; Verify WCS by addressing each word (look for parity error later).

	ASSUME	DR_DCR  EQ  0
	ASSUME	DR_UTL  EQ  DR_DCR+4
	ASSUME  DR_UTL_M_PARERR  EQ  DR_DCR_M_PARERR

	MOVL	R4,R0			; Get address of DR750's register with
					; parity error bit (DR_DCR)
	BBS	#UCB_V_DR750,UCB$W_DEVSTS(R5),22$	; Branch if DR750
	ADDL	#4,R0			; Get address of DR780's register with
					; parity error bit (DR_UTL)
22$:	BISL	#DR_UTL_M_PARERR,(R0)	; Clear parity error
	CLRL	R2			; Clear WCS address
25$:	BISL3	#DR_WCSA_M_WCS,-	; Load WCS address
		R2,DR_WCSA(R4)
	MOVL	DR_WCSD(R4),R1		; This allowes parity errors to be seen
	ACBL	R11,#2,R2,25$		; Repeat verify loop

	; Reload if a powerfail occurred while loading.

	DSBINT	#31			; Raise IPL to lockout powerfail
	BBCC	#UCB$V_POWER,UCB$W_STS(R5),30$	; Branch if no powefail
	ENBINT				; Powerfail occurred; lower IPL and
	BRW	10$			; retry

	ASSUME  DR_UTL_V_PARERR  EQ  31

30$:	TSTL	(R0)			; No powerfail - Test for parity error
	BLSS	60$			; Branch if parity error
	BISL	#DR_UTL_M_VALID,DR_UTL(R4)  ; Set WCS valid
	ENBINT				; Lower IPL

40$:	MOVZWL	#DCR_K_SETINTENB,DR_DCR(R4)  ; Set interrupt enable
	MOVZWL	#SS$_NORMAL,R0		; Return success status
	BRB	80$			; Return to user


60$:	; ERROR - Parity error during WCS verification

	ENBINT				; Lower IPL
	MOVZWL	#SS$_PARITY,R0		; Completion code


80$:	; Common return

	JMP	G^EXE$FINISHIOC		; Finish I/O

	.SBTTL	STARTDATA_FDT - Start Data FDT routine
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is the Start Data QIO FDT routine.  After it does
;	some error checking on the user's command table, it allocates
;	an I/O Request Packet Extension (IRPE) and links it onto the IRP.
;	Then the user's command block and buffer block are locked into
;	memory, with the context for these regions stored in the IRPE.
;	Finally, the address of the DR32's go bit is returned to the user
;	and the IRP is queued to the driver.
;
; CALLING SEQUENCE:
;
;	Called from the FDT routine dispatcher in the QIO system
;	service.  On completion, jumps to either EXE$QIODRVPKT (on success),
;	EXE$FINISHIOC (on errors that complete the I/O), or EXE$ABORTIO
;	(on errors that abort the I/O).
;
; INPUT PARAMETERS:
;
;	R3	Address of IRP
;	R4	Current process PCB address
;	R5	Address of UCB
;	R6	Address of CCB
;	P1(AP)	Address of command table
;	P2(AP)	Size (in bytes) of command table (must be XF$K_CMT_LENGTH)
;
; IMPLICIT INPUTS:
;
;	The format of the command table is:
;
;   P1(AP) ->   +------------------------------+
;		|     Size of command block    |   XF$L_CMT_CBLKSZ
;		|          (in bytes)          |
;		+------------------------------+
;		|   Address of Command block   |   XF$L_CMT_CBLKAD
;		|  (Must be quadword aligned)  |
;		+------------------------------+
;		|     Size of buffer block     |   XF$L_CMT_BBLKSZ
;		|          (in bytes)          |
;		+------------------------------+
;		|   Address of buffer block    |   XF$L_CMT_BBLKAD
;		|                              |
;		+------------------------------+
;		|    Address of Packet AST     |   XF$L_CMT_PASTAD
;		|           routine            |
;		+------------------------------+
;		|     Packet AST parameter     |   XF$L_CMT_PASTPM
;		|                              |
;		+------------------------------+
;		|              | Flags |  Data |   XF$B_CMT_RATE
;		|              |       |  Rate |   XF$B_CMT_FLAGS
;		+------------------------------+
;		|    Address of longword to    |   XF$L_CMT_GBITAD
;		|   receive address of GO bit  |
;		+------------------------------+
;
; OUTPUT PARAMETERS:
;
;	R0	Completion code (error returns only)
;
; IMPLICIT OUTPUTS:
;
;	None
;
; COMPLETION CODES:
;
;	Returned to EXE$ABORTIO:
;
;	SS$_ACCVIO	Access violation
;	SS$_INSFMEM	Insufficient dynamic memory
;
;	Returned to EXE$FINISHIOC:
;
;	SS$_IVBUFLEN	Invalid buffer length
;	SS$_BUFNOTALIGN	Buffer not aligned correctly
;
; SIDE EFFECTS:
;
;	None
;--

STARTDATA_FDT:

	; First verify that the command table is accessible and of the
	; correct length (XF$K_CMT_LENGTH bytes).

	MOVQ	P1(AP),R0		; Get address of command table in R0,
					; length in R1.
	MOVZWL	#SS$_IVBUFLEN,R11	; Assume error
	CMPL	R1,#XF$K_CMT_LENGTH	; Is length correct?
	BNEQ	FINISH_IO		; No, finish I/O
	IFNORD	R1,(R0),ACCESS_VIO	; Br. if command table is not accessible

	; Copy command table onto stack so that it can't change (via I/O, for
	; instance) while this FDT routine executes.

	SUBL	R1,SP			; Allocate space on stack
	PUSHR	#^M<R3,R4,R5>		; Save some registers
	MOVC3	R1,(R0),12(SP)		; Copy command table onto stack
	POPR	#^M<R3,R4,R5>		; Restore registers

	; Now check that the command block and buffer block sizes are
	; greater than 0 and less than 2**29, that the command block is
	; quadword aligned, and that the location to store the GO bit
	; address is accessible.

	TSTL	XF$L_CMT_CBLKSZ(SP)	; Is command block size zero?
	BEQL	FINISH_IO		; Yes, finish I/O
	CMPL	XF$L_CMT_CBLKSZ(SP),-	; Is command block greater than or
		#^X20000000		; equal to 2**29?
	BGEQU	FINISH_IO		; Yes, finish I/O
	TSTL	XF$L_CMT_BBLKSZ(SP)	; Is buffer block size zero?
	BEQL	FINISH_IO		; Yes, finish I/O
	CMPL	XF$L_CMT_BBLKSZ(SP),-	; Is buffer block greater than or
		#^X20000000		; equal to 2**29?
	BGEQU	FINISH_IO		; Yes, finish I/O
	MOVZWL	#SS$_BUFNOTALIGN,R11	; Change completion code in R11
	BITL	#7,XF$L_CMT_CBLKAD(SP)	; Is command block quadword aligned?
	BNEQ	FINISH_IO		; No, finish I/O
	IFWRT	#4,@XF$L_CMT_GBITAD(SP),-; Br. if location to store GO bit
		ALL_OK			; address is writeable

	;
	; Error returns
	;

ACCESS_VIO:
	MOVZWL	#SS$_ACCVIO,R0		; Store completion code

ABORT_IO:   ; Come here with completion code in R0

	JMP	G^EXE$ABORTIO		; Abort I/O

FINISH_IO:  ; Come here with completion code in R11

	MOVL	R11,R0			; Move completion code
	JMP	G^EXE$FINISHIOC		; Finish I/O


ALL_OK:	; Everything checks out.  Allocate an IRPE and link it to
	; the IRP.

	PUSHL	R3			; Save address of IRP
	JSB	G^EXE$ALLOCIRP		; Allocate an IRPE (returns addr. in R2)
	POPL	R3			; Restore address of IRP
	BLBC	R0,ABORT_IO		; Failed do to insufficient memory
	MOVB	#DYN$C_IRPE,IRPE$B_TYPE(R2)  ; Change type from IRP to IRPE
	MOVL	R2,IRP$L_EXTEND(R3)	; Link IRPE onto IRP
	BISW	#IRP$M_EXTEND,IRP$W_STS(R3)  ; Set extend bit in status word
	CLRW	IRPE$W_STS(R2)		; Clear status bits in IRPE
	CLRL	IRPE$L_SVAPTE1(R2)	; Clear SVAPTE for region 1
	CLRL	IRPE$L_SVAPTE2(R2)	; Clear SVAPTE for region 2
	MOVL	R2,R10			; From now on R10 points to IRPE

	; Now lock command block and buffer block into memory, saving
	; the context (SVAPTE, BCNT, and BOFF) in the IRPE.  R3 points to the
	; IRP, SP points to the command table, and R10 points to the IRPE.

	ASSUME	IRPE$W_BOFF1  EQ  IRPE$L_SVAPTE1+4
	ASSUME	IRPE$W_BOFF2  EQ  IRPE$L_SVAPTE2+4

	MOVL	(SP)+,R1		; Get length of command block
	MOVL	(SP)+,R0		; Get address of command block
	MOVL	R1,IRPE$L_BCNT1(R10)	; Store length of command block in IRPE
	MOVL	R0,IRPE$L_CBLKADR(R10)	; Store address of command block in IRPE
	BSBB	LOCK_BFR		; Lock command block into memory
	MOVQ	IRP$L_SVAPTE(R3),-	; Store SVAPTE and BOFF in IRPE
		IRPE$L_SVAPTE1(R10)
	MOVL	(SP)+,R1		; Get length of buffer block
	MOVL	(SP)+,R0		; Get address of buffer block
	MOVL	R1,IRPE$L_BCNT2(R10)	; Store length of buffer block in IRPE
	MOVL	R0,IRPE$L_BBLKADR(R10)	; Store addr. of buffer block in IRPE
	BSBB	LOCK_BFR		; Lock buffer block into memory
	MOVQ	IRP$L_SVAPTE(R3),-	; Store SVAPTE and BOFF in IRPE
		IRPE$L_SVAPTE2(R10)
	CLRQ	IRP$L_SVAPTE(R3)	; Clear SVAPTE, BOFF, and BCNT in IRP

	; Now copy packet AST address and parameter into IRP and
	; return address of GO bit to user.

	ASSUME	IRP$L_PKTASTPRM EQ IRP$L_PKTASTADR+4
	ASSUME	IDB$L_CSR  EQ  0

	MOVQ	(SP)+,IRP$L_PKTASTADR(R3) ; Store packet AST address and
					; parameter in IRP
	MOVL	(SP)+,IRP$B_RATE(R3)	; Store data rate and flags in IRP
	MOVL	UCB$L_CRB(R5),R1	; Get address of CRB in R1
	ADDL3	#DR_USER,-		; Store address of GO bit
		@CRB$L_INTD+VEC$L_IDB(R1),@(SP)+

	JMP	G^EXE$QIODRVPKT		; Queue packet to driver

	.SBTTL	LOCK_BFR - Lock a buffer into memory

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called from the Start Data FDT routine to lock
;	the command block and the buffer block into memory.  If either
;	lock fails, this routine unlocks any locked memory and deallocates
;	the IRPE before during a coroutine return to EXE$MODIFYLOCKR.
;
; CALLING SEQUENCE:
;
;	BSBB	LOCK_BFR	Note that if the lock fails, this routine
;				returns to EXE$MODIFYLOCKR, not the caller.
;
; INPUT PARAMETERS:
;
;	R0	Address of buffer to lock
;	R1	Length of buffer (in bytes)
;	R3	Address of IRP
;	R4	Current process PCB address
;	R5	Address of UCB
;	R6	Address of CCB
;	R10	Address of IRPE
;
; IMPLICIT INPUTS:
;
;	Offsets IRPE$L_SVAPTE1, IRPE$W_BOFF1, and IRPE$L_BCNT1 in the
;	IRPE describe the previously locked area.
;
; OUTPUT PARAMETERS:
;
;	None (returning to the caller implies success)
;
; IMPLICIT OUTPUTS:
;
;	Offsets IRP$L_SVAPTE and IRP$W_BOFF in the IRP describe
;	the svapte and the byte offset of the locked area.
;
; COMPLETION CODES:
;
;	None
;
; SIDE EFFECTS:
;
;	As previously mentioned, on a lock failure the previously
;	locked area is unlocked, the IRPE is deallocated, and the I/O
;	is either completely backed up or aborted.
;--

LOCK_BFR:
	JSB	G^EXE$MODIFYLOCKR	; Lock buffer into memory
	BLBS	R0,90$			; Success!!!

	; Got a lock failure.  Unlock previously locked area if there is one.

	PUSHR	#^M<R0,R1,R2,R3>	; Save registers
	CLRQ	IRP$L_SVAPTE(R3)	; Cleanup IRP so that we don't
					; unlock same area twice
	BICW	#IRP$M_EXTEND,IRP$W_STS(R3)  ; Clear extend bit
	MOVL	IRPE$L_SVAPTE1(R10),R3	; Get SVAPTE
	BEQL	10$			; No area previously locked
	MOVZWL	IRPE$W_BOFF1(R10),R1	; Get byte offset
	MOVL	IRPE$L_BCNT1(R10),R2	; Get byte count
	MOVAB	511(R1)[R2],R1		; Combine offset and count and round
	ASHL	#-VA$S_BYTE,R1,R1	; Convert to number of pages (to unlock)
	JSB	G^MMG$UNLOCK		; Unlock the pages

10$:	; Now deallocate the IRPE.

	MOVL	R10,R0			; Address of packet
	JSB	G^EXE$DEANONPAGED	; Deallocate it
	POPR	#^M<R0,R1,R2,R3>	; Restore registers

90$:	RSB				; On success returns to caller,
					; On failure returns to EXE$MODIFYLOCKR

	.SBTTL	STARTIO - Entry point to start I/O

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine actually starts the DR32.  It loads the
;	required DR32 registers and clears the halt bit.
;
; CALLING SEQUENCE:
;
;	Jumped to through the driver dispatch table by IOC$INITIATE
;
; INPUT PARAMETERS:
;
;	R3	Address of the IRP
;	R5	Address of the UCB
;
; IMPLICIT INPUTS:
;
;	Various fields in the IRP, IRPE, and UCB.  In particular note
;	that offset UCB$L_IRP in the UCB contains the address of the IRP.
;
; OUTPUT PARAMETERS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	None
;
; COMPLETION CODES:
;
;	Returned to REQ_COMPLETE:
;
;	SS$_POWERFAIL	Adapter has no power
;	SS$_MCNOTVALID	Microcode is not valid
;	SS$_BADPARAM	Specified data rate is too large
;
; SIDE EFFECTS:
;
;	None
;--
STARTIO:

	; Get address of first CSR into R4.  Make sure adapter has power and
	; then clear abort bit and parity error bit.

	ASSUME	IDB$L_CSR  EQ  0
	ASSUME  UCB_V_ADPPWRUP  EQ  0

	MOVL	UCB$L_CRB(R5),R1		; Get address of CRB
	MOVL	@CRB$L_INTD+VEC$L_IDB(R1),R4	; Get address of first CSR
	BLBS	UCB$W_DEVSTS(R5),5$		; Branch if adapter has power
	BRW	40$				; Adapter has no power
5$:	MOVZWL	#DCR_K_CLRABTINT,DR_DCR(R4)	; Clear abort interrupt bit
	BICL	#DR_DCR_M_DCRABT,UCB$L_DCR(R5)	; Clear abort bit in DCR in UCB
	BISL	#DR_UTL_M_PARERR,DR_UTL(R4)	; Clear parity error bit (DR780)
	BISL	#DR_DCR_M_PARERR,DR_DCR(R4)	; Clear parity error bit (DR750)

	; Load Utility register with data rate and parity error abort bit.

	ASSUME	XF$V_CMT_SETRTE  EQ  0

	MOVL	DR_UTL(R4),R0		; Read contents of Utility register
	BICL	#DR_UTL_M_ENPEAB,R0	; Clear enable par. err. abort bit (DR780)
	BICL	#DR_DCR_M_ENPEAB,DR_DCR(R4) ; Clear enable par. err. abort (DR750)
	BLBC	IRP$B_FLAGS(R3),10$	; Branch if we shouldn't set rate
	CMPB	IRP$B_RATE(R3),-	; Compare specified rate with maximum
		G^IOC$GW_XFMXRATE	; allowed by SYSGEN parameter
	BGTRU	8$			; Rate too high - error
	MOVZBL	#DR780_MAXRATE,R1	; Get hardware maximum clock rate (DR780)
	BBC	#UCB_V_DR750,UCB$W_DEVSTS(R5),7$  ; Branch if DR780
	MOVZBL	#DR750_MAXRATE,R1	; Get hardware maximum clock rate (DR750)
7$:	CMPB	IRP$B_RATE(R3),R1	; Compare specified rate with maximum
	BLEQU	9$			; allowed by hardware and branch if ok
8$:	BRW	60$			; Rate too high - error
9$:	MOVB	IRP$B_RATE(R3),R0	; Set rate
	MOVB	R0,UCB$L_DEVDEPEND(R5)	; Put rate into device characteristics
10$:	BBS	#XF$V_CMT_DIPEAB,-	; Branch if we shouldn't set abort
		IRP$B_FLAGS(R3),20$	; on parity error bit
	BISL	#DR_UTL_M_ENPEAB,R0	; Set abort on parity error bit (DR780)
	BISL	#DR_DCR_M_ENPEAB,DR_DCR(R4)  ; Set abort on par. err. bit (DR750)
20$:	MOVL	R0,DR_UTL(R4)		; Load Utility register

	; Load up the rest of the DR32 registers.
	; Note that the DR780 registers are directly addressable while
	; the DR750 registers are accessed by loading the register number
	; into the DR_WCSA register and reading or writing the DR_WCSD register.

	MOVL	IRP$L_EXTEND(R3),R2	; R2 points to IRPE
	BBS	#UCB_V_DR750,UCB$W_DEVSTS(R5),30$  ; Branch if DR750

	; Load DR780 registers

	MOVAL	DR_780_SBR(R4),R1	; R1 will step through registers


	MFPR	#PR$_SBR,(R1)+		; DR_SBR = contents of sys. base reg.
	MOVL	G^MMG$GL_GPTBASE,(R1)+	; DR_GBR = address of global page table
	MOVL	IRPE$L_CBLKADR(R2),(R1)+; DR_CMDBVA = address of command block
	MOVL	IRPE$L_BCNT1(R2),(R1)+	; DR_CMDLEN = length of command block
	MOVL	IRPE$L_SVAPTE1(R2),(R1)+; DR_CMDSVAPTE = SVAPTE of command block
	MOVL	IRPE$L_BBLKADR(R2),(R1)+; DR_BFRBVA = address of buffer block
	MOVL	IRPE$L_BCNT2(R2),(R1)+	; DR_BFRLEN = length of buffer block
	MOVL	IRPE$L_SVAPTE2(R2),(R1)+; DR_BFRSVAPTE = SVAPTE of buffer block
	BRB	35$

30$:	; Load DR750 registers

	MOVL	#DR_750_SBR,R1		; R1 will step through registers
	MOVAL	DR_WCSD(R4),R0		; R0 will point to WCS data register

	MOVAB	(R1)+,DR_WCSA(R4)	; Store address of next register
	MFPR	#PR$_SBR,(R0)		; DR_SBR = contents of sys. base reg.
	MOVL	G^MMG$GL_GPTBASE,(R0)	; DR_GBR = address of global page table
	MOVL	IRPE$L_CBLKADR(R2),(R0)	; DR_CMDBVA = address of command block
	MOVL	IRPE$L_BCNT1(R2),(R0)	; DR_CMDLEN = length of command block
	MOVL	IRPE$L_SVAPTE1(R2),(R0)	; DR_CMDSVAPTE = SVAPTE of command block
	MOVL	IRPE$L_BBLKADR(R2),(R0)	; DR_BFRBVA = address of buffer block
	MOVL	IRPE$L_BCNT2(R2),(R0)	; DR_BFRLEN = length of buffer block
	MOVL	IRPE$L_SVAPTE2(R2),(R0)	; DR_BFRSVAPTE = SVAPTE of buffer block

35$:	; Check for WCS valid and start the DR going!

	DSBINT	#31			; Raise IPL to 31
	BITL	#DR_UTL_M_VALID,DR_UTL(R4) ; Is WCS valid?
	BEQL	50$			; No, error!
	MOVZWL	#DCR_K_CLRHLT,DR_DCR(R4) ; Clear Halt function
	ENBINT				; Lower IPL
	RSB



40$:	; Error - Adapter has no power

	MOVZWL	#SS$_POWERFAIL,R0	; Status
	BRB	70$

50$:	; Error - WCS not valid

	ENBINT				; Lower IPl
	MOVZWL	#SS$_MCNOTVALID,R0	; Status
	BRB	70$

60$:	; Error - Data rate too high

	MOVZWL	#SS$_BADPARAM,R0	; Status

70$:	; Complete I/O with error in R0

	CLRL	R1			; Clear second half of I/O status block
	BRW	REQ_COMPLETE

	.SBTTL	INTERRUPT_SVC - Interrupt service routine

;++
; FUNCTIONAL DESCRIPTION:
;
;	This is the interrupt service routine for DR32 interrupts.
;	It reads the DCR register, clears the interrupting condition(s),
;	and calls HANDLE_INT to handle the interrupt.  Note that this
;	routine executes at device IPL while HANDLE_INT forks and 
;	therefore executes at fork IPL.
;
; CALLING SEQUENCE:
;
;	JSB from interrupt vector in CRB.  This routine cleans up
;	the stack and does an REI.
;
; INPUT PARAMETERS:
;
;	None
;
; IMPLICIT INPUTS:
;
;	The stack on entry is as follows:
;
;		 0(SP)		Address of IDB address
;		 4(SP)		Saved R2
;		 8(SP)		Saved R3
;		12(SP)		Saved R4
;		16(SP)		Saved R5
;		20(SP)		Interrupt PC
;		24(SP)		Interrupt PSL
;
; OUTPUT PARAMETERS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	None
;
; COMPLETION CODES:
;
;	None
;
; SIDE EFFECTS:
;
;	None
;--

	ASSUME	IDB$L_CSR+4  EQ  IDB$L_OWNER
	ASSUME	DR_DCR_V_PWR_DN  EQ  DR_DCR_V_PWR_UP+1

INTERRUPT_SVC:
	MOVL	@(SP)+,R3		; Get address of IDB in R3
	MOVQ	IDB$L_CSR(R3),R4	; CSR -> R4,  UCB-> R5

	; Get contents of DCR and OR into DCR in UCB

	MOVL	DR_DCR(R4),R3		; Get DCR
	BISL	R3,UCB$L_DCR(R5)	; OR into DCR in UCB for use after FORK


	; Clear interrupting conditions.  Note that if there is a
	; power up/down interrupt, then those bits are jammed into
	; the DCR in the UCB.

	BBC	#DR_DCR_V_PKTINT,R3,10$	; Branch if not packet interrupt
	MOVZWL	#DCR_K_CLRPKTINT,DR_DCR(R4)  ; Clear packet interrupt
10$:	BBC	#DR_DCR_V_DCRABT,R3,20$	; Branch if not abort interrupt
	MOVZWL	#DCR_K_CLRABTINT,DR_DCR(R4)  ; Clear abort interrupt
20$:	BITL	#DR_DCR_M_PWR_UP!-	; Power up or power down bit set?
		 DR_DCR_M_PWR_DN,R3
	BEQL	40$			; No.
	EXTZV	#DR_DCR_V_PWR_UP,#2,-	; Extract power up and power down bits
		R3,R2
	INSV	R2,#DR_DCR_V_PWR_UP,-	; Insert them into DCR in UCB
		#2,UCB$L_DCR(R5)
	BBC	#DR_DCR_V_PWR_UP,R3,30$	; Branch if not power up interrupt
	MOVZWL	#DCR_K_CLRPWRUP,DR_DCR(R4)  ; Clear power up interrupt
30$:	BBC	#DR_DCR_V_PWR_DN,R3,40$	; Branch if not power down interrupt
	MOVZWL	#DCR_K_CLRPWRDN,DR_DCR(R4)  ; Clear power down interrupt

40$:	; Test and set interlock bit.  Purpose of interlock bit is to
	; prevent FORKing while the FORK block is in use as a result of
	; a previous interrupt.

	BBSS	#UCB_V_FKLOCK,-		; Branch if interlock is set
		UCB$W_DEVSTS(R5),50$

	BSBB	HANDLE_INT		; Handle interrupt (at fork IPL)

50$:	; Finish cleaning up stack and return from interrupt

	MOVQ	(SP)+,R2		; Restore R2 and R3
	MOVQ	(SP)+,R4		; Restore R4 and R5
	REI

	.SBTTL	HANDLE_INT - Handle the interrupt

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine actually handles the interrupts.  It is called
;	by INTERRUPT_SVC at device IPL but immediately forks to fork IPL.
;	There are four interrupting conditions:  power up, power down,
;	abort, and packet interrupts.  This routine checks for all of these
;	conditions.  If there is an I/O in progress, there are three possible
;	exits from this routine:  If the DR is halted, then the I/O is 
;	completed (with either a success or failure status code).  If the
;	DR is not halted, then if no errors were detected the transfer
;	continues.  If any errors were detected, the transfer is aborted.
;
; CALLING SEQUENCE:
;
;	BSBB from interrupt service routine
;
; INPUT PARAMETERS:
;
;	R4	Address of first device CSR
;	R5	Address of UCB
;
; IMPLICIT INPUTS:
;
;	Offset UCB$L_DCR in the UCB contains the device DCR register
;
; OUTPUT PARAMETERS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	None
;
; COMPLETION CODES:
;
;	None
;
; SIDE EFFECTS:
;
;	None
;--

HANDLE_INT:
	IOFORK

	; Clear FORK interlock, get DCR from UCB, and clear DCR in UCB.
	; This clear must be performed by a BICL as it is possible for
	; the interrupt service routine to OR in additional bits
	; between the get DCR and the clear DCR.  These additional bits
	; will be handled by the next interrupt.

	SETIPL	UCB$B_DIPL(R5)		; Raise IPL to prevent race condition
	BICW	#UCB_M_FKLOCK,-		; Clear fork interlock
		UCB$W_DEVSTS(R5)
	MOVL	UCB$L_DCR(R5),R2	; Get DCR from UCB
	BICL	R2,UCB$L_DCR(R5)	; Clear DCR in UCB
	SETIPL	UCB$B_FIPL(R5)		; Lower to fork IPL
	MOVL	R2,UCB$L_SAVDCR(R5)	; Save DCR for reg. dump routine

	MOVL	UCB$L_IRP(R5),R3	; Get address of IRP (if there is one)
	MOVZWL	#SS$_NORMAL,R0		; Assume success
	CLRL	R1			; Clear second half of I/O status block

	; Now test for cause of interrupt.  The possibilities are:
	;	1)  Power up interrupt
	;	2)  Power down interrupt
	;	3)  Abort interrupt
	;	4)  Packet interrupt

	; Test for power up interrupt

	BBC	#DR_DCR_V_PWR_UP,R2,20$	; Branch if not power up interrupt
	BISW	#UCB_M_ADPPWRUP,UCB$W_DEVSTS(R5)  ; Set adapter power up bit
	BBC	#DR_DCR_V_DCRHLT,R2,20$	; Branch if device is not halted
	MOVZWL	#SS$_POWERFAIL,R0	; Load powerfail status

20$:	; Test for power down interrupt

	BBC	#DR_DCR_V_PWR_DN,R2,30$	; Branch if not power down interrupt
	BICW	#UCB_M_ADPPWRUP,UCB$W_DEVSTS(R5)  ; Clear adapter power up bit
	BISW	#UCB$M_POWER,UCB$W_STS(R5)  ; Set powerfail bit in UCB
	MOVZWL	#SS$_POWERFAIL,R0	; Load powerfail status

30$:	; Skip remaining code if we don't have an IRP (UCB is not busy).

	BBC	#UCB$V_BSY,-		; Branch if we don't have an IRP
		UCB$W_STS(R5),DONE

	; Test for Abort Interrupt

	BBC	#DR_DCR_V_DCRABT,R2,40$	; Branch if not abort interrupt
	BSBW	ABORT_INT		; Handle abort interrupt

40$:	; Test for packet interrupt

	BBC	#DR_DCR_V_PKTINT,R2,60$	; Branch if not packet interrupt
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Have packet int.  Save registers.
	BSBW	QUEUE_PKT_AST		; Queue packet AST
	BLBS	R0,50$			; Success
	CLRL	R1			; Failure to queue AST
	MOVQ	R0,(SP)			; Store status
50$:	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore registers

60$:	; Come here with I/O status block in R0 and R1.  If DR is halted,
	; send IRP to request complete.  If the DR is not halted, return
	; if status is success and abort the DR if the status is failure
	; or if an abort is pending.

	BBS	#DR_DCR_V_DCRHLT,R2,-	; Branch if device is halted
		REQ_COMPLETE		; to request complete
	BBS	#UCB_V_ABORT,-		; Branch if an abort is pending
		UCB$W_DEVSTS(R5),WAIT
	BLBS	R0,DONE			; If status is success, return

ABORT:	; Abort the device by setting ext. abort.  Save the status in R0 in
	; the UCB for use when the device interrupts with an abort interrupt.
	; Note that this entry is called as a subroutine by CANCEL_IO

	MOVL	R0,UCB$L_SAVSTATUS(R5)	; Save status in UCB
WAIT:	DSBINT				; Disable interrupts
	MOVZWL	#DCR_K_SETEXTABT,DR_DCR(R4)  ; Abort the device
	BISW	#UCB_M_ABORT,UCB$W_DEVSTS(R5); Set the abort pending bit
	BBS	#UCB_V_FKLOCK,-		; Don't wait for interrupt if
		UCB$W_DEVSTS(R5),DONE	; we already have one
	WFIKPCH	TIMEOUT,#2		; Wait for interrupt - 2 second timeout


DONE:	; Common return

	RSB


TIMEOUT:
	; Come here (at device IPL) on timeout or powerfail while
	; waiting for an abort interrupt.

	MOVL	DR_DCR(R4),UCB$L_SAVDCR(R5) ; Save DCR for reg. dump routine
	MOVZWL	#DCR_K_RESET,DR_DCR(R4)	; Reset DR32
	MOVZWL	#DCR_K_SETINTENB,DR_DCR(R4)  ; Enable interrupts
	SETIPL	UCB$B_FIPL(R5)		; Drop to fork IPL
	MOVZWL	#SS$_TIMEOUT,R0		; Assume timeout status
	BBC	#UCB$V_POWER,UCB$W_STS(R5),10$  ; Branch if not powerfail
	MOVZWL	#SS$_POWERFAIL,R0	; Set powerfail status
10$:	MOVL	UCB$L_SAVSTATUS(R5),R1	; Store saved status (reason for abort) in R1
	JSB	G^ERL$DEVICTMO		; Error log timeout
					; Fall through to complete request


REQ_COMPLETE:
	BICW	#UCB_M_ABORT,UCB$W_DEVSTS(R5)  ; Clear abort pending bit
	MOVQ	R0,-(SP)		; Save R0 and R1 (I/O status block)
	JSB	G^IOC$DIAGBUFILL	; Fill diagnostic buffer (if specified)
	MOVQ	(SP)+,R0		; Restore R0 and R1
	REQCOM				; Complete the IRP.  R0 and R1
					; contain I/O status block.

	.SBTTL	ABORT_INT - Handle abort interrupts

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine handles abort interrupts.  It distinguishes among
;	four cases.  These are:
;		1)  Driver abort
;		2)  User and far end device errors
;		3)  Parity errors
;		4)  Other DR32 errors (such as bus errors)
;	This routine's main purpose is to identify the cause of the abort
;	and to return appropriate status in R0 and R1 for use as the
;	I/O status block.
;	This routine also error logs parity errors and DR32 errors (cases
;	3 and 4 above).
;
; CALLING SEQUENCE:
;
;	BSBB	ABORT_INT
;
; INPUT PARAMETERS:
;
;	R2	Contents of DCR
;	R4	Address of first device CSR
;	R5	Address of UCB
;
; IMPLICIT INPUTS:
;
;	Offset UCB$L_SAVSTATUS in the UCB contains the status for driver aborts
;
; OUTPUT PARAMETERS:
;
;	R0	First longword of I/O status block
;	R1	Second longword of I/O status block
;
; IMPLICIT OUTPUTS:
;
;	None
;
; COMPLETION CODES:
;
;	R0	contains status left in UCB$L_SAVSTATUS for driver aborts,
;		SS$_DEVREQERR for user and far end device errors,
;		SS$_PARITY for parity errors, and
;		SS$_CTRLERR for other errors.
;
;	R1	0 for driver aborts, and
;		a combination of bits from the DCR, UTILITY, and DSL 
;		registers for all other errors.
;
; SIDE EFFECTS:
;
;	None
;--

ABORT_INT:
	; Test for Driver abort.

	BBC	#DR_DCR_V_EXTABT,R2,10$	; Branch if not driver abort
	MOVL	UCB$L_SAVSTATUS(R5),R0	; Get status saved when driver set abort
	CLRL	R1			; Second longword of IOSB is 0
	RSB				; Return

10$:	; Collect bits for second longword of I/O status block as all
	; other errors require this.

	ASSUME	DR_UTL_V_WCSPE  EQ  DR_DCR_V_WCSPE
	ASSUME	DR_750_DSL  EQ  0

	BBS	#UCB_V_DR750,UCB$W_DEVSTS(R5),20$  ; Branch if DR750
	MOVL	DR_780_DSL(R4),R1	; Start out with all of the DSL
	BRB	30$
20$:	CLRL	DR_WCSA(R4)		; Store register number to get DSL
	MOVL	DR_WCSD(R4),R1		; Start out with all of the DSL
30$:	BITW	#DR_DCR_M_ID1ERR!-	; OR these four bits into 1 bit
		 DR_DCR_M_ID1TO!-	; These are sort of bus errors
		 DR_DCR_M_ID2ERR!-
		 DR_DCR_M_ID2TO,R2
	BEQL	40$			; None of those bits were set
	BBSS	#XF$V_IOS_BUSERR,R1,40$	; Set bus error bit
40$:	BBC	#DR_DCR_V_RDS,R2,45$	; Branch if Read Data Substitute not set
	BBSS	#XF$V_IOS_RDSERR,R1,45$	; Set Read Data Substitute error
45$:	MOVL	DR_UTL(R4),R0		; Get Utility register (contains parity
					; error bits on DR780)
	BBC	#UCB_V_DR750,UCB$W_DEVSTS(R5),50$  ; Branch if DR780
	MOVL	R2,R0			; Get DCR (for parity err bits on DR750)
50$:	ASHL	#-DR_UTL_V_WCSPE,R0,R0	; Shift 3 parity error bits to bit 0
	INSV	R0,#XF$V_IOS_WCSPE,-	; and insert in R1
		#3,R1

	; Test for controller error (SS$_CTRLERR)

	BITL	#XF$M_IOS_BUSERR!-	; Test for bus error,
		 XF$M_IOS_RDSERR!-	; read data substitute error,
		 XF$M_IOS_INVPTE,R1	; and invalid PTE
	BNEQ	60$			; Have a controller error

	; Test for Parity error (SS$_PARITY)

	MOVZWL	#SS$_PARITY,R0		; Assume yes
	BITL	#XF$M_IOS_WCSPE!-	; Test for WCS parity error,
		 XF$M_IOS_CIPE!-	; control interconnect parity error,
		 XF$M_IOS_DIPE,R1	; and data interconnect parity error
	BNEQ	70$			; Have a parity error

	; Test for user or far end device error (SS$_DEVREQERR)

	MOVZWL	#SS$_DEVREQERR,R0	; Assume yes
	BITL	#XF$M_IOS_DDIDIS!-	; Test for DDI disable,
		 XF$M_IOS_RNGERR!-	; range error,
		 XF$M_IOS_UNQERR!-	; unaligned queue error,
		 XF$M_IOS_INVPKT!-	; invalid packet,
		 XF$M_IOS_FREQMT!-	; free queue empty,
		 XF$M_IOS_INVDDI!-	; invalid DDI command,
		 XF$M_IOS_LENERR!-	; length error,
		<XF$M_IOS_DDIERR @ -	; and DDI error.
		 XF$V_IOS_DDISTS>,R1	; (DDIERR bit must be shifted over)
	BNEQ	70$			; Have one of those
					; Note:  Branch to 80$ if 
					; SS$_DEVREQERR errors should
					; not be error logged.

	;
	; None of the error bits are set so we have to treat it as a 
	; controller error (SS$_CTRLERR).  Fall through to ...
	;

60$:	MOVZWL	#SS$_CTRLERR,R0		; Status

70$:	JSB	G^ERL$DEVICERR		; Log device error

80$:	; Common return

	RSB

	.SBTTL	QUEUE_PKT_AST - Queue packet AST

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to queue an AST to the user process and
;	set an event flag to indicate that a packet was placed on the
;	process's termination queue.  Both queueing the AST and setting
;	the event flag are optional; either or both may occur.  An AST
;	is queued if a packet AST address is specified in the I/O packet
;	and the event flag is set if the modifier IO$_SETEVF is present
;	in the I/O subfunction code.  Note that this routine forks to
;	Queue AST IPL before queueing the AST or setting the event flag.
;
; CALLING SEQUENCE:
;
;	BSBW	QUEUE_PKT_AST
;
; INPUT PARAMETERS:
;
;	R3	Address of I/O packet
;	R5	Address of UCB
;
; IMPLICIT INPUTS:
;
;	Various fields in the I/O packet
;
; OUTPUT PARAMETERS:
;
;	R0	Completion code
;
; IMPLICIT OUTPUTS:
;
;	None
;
; COMPLETION CODES:
;
;	SS$_NORMAL	Normal successful completion
;	SS$_INSFMEM	Insufficient dynamic memory (to allocate an ACB)
;	SS$_EXQUOTA	Exceeded AST quota
;
; SIDE EFFECTS:
;
;	R1,R2,R3,R4 and R5 are not preserved.  REPEAT R5!!!
;--

QUEUE_PKT_AST:

	; Make sure the process has enough AST quota to allocate 
	; a FORK/AST block.

	MOVZWL	IRP$L_PID(R3),R5	; Get process index
	PUSHL	G^SCH$GL_PCBVEC		; Push address of PCB table
	MOVL	@(SP)+[R5],R5		; Get PCB address
	MOVZWL	#SS$_EXQUOTA,R0		; Assume error
	TSTW	PCB$W_ASTCNT(R5)	; Enough AST quota left?
	BLEQ	10$			; No!
	DECW	PCB$W_ASTCNT(R5)	; Yes, take one away

	; Allocate a packet to be used as a fork block and AST control block

	MOVZWL	#IRP$K_LENGTH,R1	; Length = an I/O pkt because it's fast
	PUSHL	R3			; Save R3
	JSB	G^EXE$ALONONPAGED	; Returns pointer to packet in R2
	POPL	R3			; Restore R3
	BLBS	R0,20$			; Successful allocation
	MOVZWL	#SS$_INSFMEM,R0		; Error - insufficient dynamic memory!
	INCW	PCB$W_ASTCNT(R5)	; Add 1 back to AST quota
10$:	RSB				; Error return

20$:	; Put size and type into packet and then fork to Queue AST IPL
	; which returns success status to caller

	ASSUME IRP$B_TYPE EQ IRP$W_SIZE+2
	ASSUME FKB$B_FIPL EQ IRP$B_RMOD

	MOVL	#<DYN$C_ACB@16>+IRP$K_LENGTH,IRP$W_SIZE(R2)	; Size and type
	MOVB	#IPL$_QUEUEAST,FKB$B_FIPL(R2)	; Set fork IPL = Queue AST IPL
	MOVL	R2,R5				; R5 must point to fork block
	MOVZWL	#SS$_NORMAL,R0			; Return normal status to caller
	FORK					; Fork!

	; Build AST control block in preparation for queueing AST.
	; R3 points to I/O packet, R5 points to AST control block.

	ASSUME	IRP$L_PKTASTPRM EQ IRP$L_PKTASTADR+4
	ASSUME	ACB$L_ASTPRM EQ ACB$L_AST+4

	MOVL	IRP$L_PID(R3),R1	; Get PID and save for SCH$POSTEF
	MOVL	R1,ACB$L_PID(R5)	; Store PID in ACB
	MOVQ	IRP$L_PKTASTADR(R3),-	; Store packet AST address and parameter
		ACB$L_AST(R5)		; in ACB
	MOVB	IRP$B_RMOD(R3),-	; Store access mode
		ACB$B_RMOD(R5)
	BISB	#ACB$M_QUOTA,ACB$B_RMOD(R5)  ; Set AST quota accounting flag

30$:	; Now post event flag if subfunction code specifies it

	MOVZBL	#PRI$_IOCOM,R2		; Priority incr. class = I/O complete
	BBC	#IO$V_SETEVF,IRP$W_FUNC(R3),40$	; Br. if don't post event flag
	MOVZBL	IRP$B_EFN(R3),R3	; Get event flag number
	JSB	G^SCH$POSTEF		; Post event flag

40$:	; Now either queue AST or deallocate AST control block.

	TSTL	ACB$L_AST(R5)		; Is AST specified?  (Address non-zero)?
	BEQL	50$			; No, deallocate ACB
	JMP	G^SCH$QAST		; Yes, queue AST.  SCH$QAST returns to 
					; caller.

50$:	; Don't give AST, so deallocate packet.

	MOVZWL	ACB$L_PID(R5),R2	; But first increment AST quota
	PUSHL	G^SCH$GL_PCBVEC		; Push address of PCB table
	MOVL	@(SP)+[R2],R2		; Get PCB address
	INCW	PCB$W_ASTCNT(R2)	; Increment AST quota
	MOVL	R5,R0			; Address of packet
	JMP	G^EXE$DEANONPAGED	; Deallocate packet.
					; returns to caller.

	.SBTTL	CANCEL_IO - Cancel I/O routine

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine performs the Cancel I/O function.  If the UCB is
;	busy, then the channel index and process id in the IRP are
;	compared with those passed by the caller.  If they match, then
;	this routine calls ABORT which aborts the DR32.
;
; CALLING SEQUENCE:
;
;	BSBW	CANCEL_IO
;
; INPUT PARAMETERS:
;
;	R2	Channel Index
;	R3	Address of IRP
;	R4	Current process PCB address
;	R5	address of UCB
;
; IMPLICIT INPUTS:
;
;	None
;
; OUTPUT PARAMETERS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	None
;
; COMPLETION CODES:
;
;	The I/O (if any) is completed with status SS$_ABORT
;
; SIDE EFFECTS:
;
;	None
;--

CANCEL_IO:
	BBC	#UCB$V_BSY,UCB$W_STS(R5),60$  ; Branch if UCB is not busy
	CMPW	R2,IRP$W_CHAN(R3)	; Compare channels
	BNEQ	60$			; No match
	CMPL	PCB$L_PID(R4),IRP$L_PID(R3)   ; Compare process id's
	BNEQ	60$			; No match

	; Channel and process id's match.  Check to make sure adapter
	; has power.  If it does, abort transfer.

	ASSUME	UCB_V_ADPPWRUP  EQ  0
	ASSUME	IDB$L_CSR  EQ  0

	BLBC	UCB$W_DEVSTS(R5),60$	; Branch if adapter has no power
	PUSHL	R4			; Save R4
	MOVL	UCB$L_CRB(R5),R4	; Get pointer to CRB
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R4 ; Get address of 1st device CSR
	MOVZWL	#SS$_ABORT,R0		; Status
	BSBW	ABORT			; Abort device
	POPL	R4			; Restore R4

60$:	RSB

	.SBTTL	REGDUMP - Register Dump Routine

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine copies relevant DR32 registers into either a diagnostic
;	buffer or an error log buffer.  It is called from the error logging
;	routine and from the diagnostic buffer fill routine.
;
; CALLING SEQUENCE:
;
;	JSB	REGDUMP
;
; INPUT PARAMETERS:
;
;	R0	Address of buffer to store registers
;	R4	Address of first device CSR
;	R5	Address of UCB
;
; IMPLICIT INPUTS:
;
;	None
;
; OUTPUT PARAMETERS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	None
;
; COMPLETION CODES:
;
;	None
;
; SIDE EFFECTS:
;
;	None
;--

REGDUMP:
	BBS	#UCB_V_DR750,-
		UCB$W_DEVSTS(R5),10$	; If set, yes DR750

	MOVL	#15,R2			; Number of reg. in first DR780 group
	BRB	20$			; Go start

10$:	MOVL	#7,R2			; Number of reg. in first DR750 group

20$:	MOVL	#40,(R0)+		; Store number of registers to be saved
	MOVL	UCB$L_SAVDCR(R5),(R0)+	; Store copy of saved DCR 

	MOVAL	DR_UTL(R4),R1		; Address of first register group
30$:	MOVL	(R1)+,(R0)+		; Store next register
	SOBGTR	R2,30$			; Repeat

	BBS	#UCB_V_DR750,-
		UCB$W_DEVSTS(R5),50$	; If set, then DR750

	MOVL	#24,R2			; Number of registers in second group
	MOVAL	DR_780_DSL(R4),R1	; Address of second register group
40$:	MOVL	(R1)+,(R0)+		; Store next register
	SOBGTR	R2,40$			; Repeat
	BRB	70$

50$:	MOVL	#32,R2			; Number of registers in second group
	CLRL	DR_WCSA(R4)		; Set indirect register address to zero
	MOVAL	DR_WCSD(R4),R1		; Address of data register
60$:	MOVL	(R1),(R0)+		; Stores next register and bumps adderss
	SOBGTR	R2,60$			; Repeat

70$:	RSB

	.SBTTL	UNIT_INIT - Unit initialization

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is entered when the driver is loaded and on
;	system power recovery.  On driver load, it initializes
;	the UCB and sets the protection on the page containing
;	the GO bit to user writeable.  It also determines which cpu type
;	it is running on (11/780 or 11/750) and sets a bit in
;	UCB$W_DEVSTS to indicate which one.
;	On power recovery, it simply returns.  Power recovery is actually
;	handled in the interrupt handler.
;
; CALLING SEQUENCE:
;
;	JSB	UNIT_INIT
;
; INPUT PARAMETERS:
;
;	R5	Address of UCB
;
; IMPLICIT INPUTS:
;
;	None
;
; OUTPUT PARAMETERS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	None
;
; COMPLETION CODES:
;
;	None
;
; SIDE EFFECTS:
;
;	R0, R1, R2, AND R4 ARE NOT PRESERVED
;--

UNIT_INIT:
	; Determine if this is initial loading or a power recovery.

	BBS	#UCB$V_POWER,UCB$W_STS(R5),INIT_DONE  ; Branch if power recovery

	; Get address of IDB and first device CSR

	MOVL	UCB$L_CRB(R5),R1	; Get address of CRB
	MOVL	CRB$L_INTD+VEC$L_IDB(R1),R2  ; Get address of IDB
	MOVL	IDB$L_CSR(R2),R4	; Get address of first device CSR

	; Make UCB owner of IDB and reset DR.

	MOVL	R5,IDB$L_OWNER(R2)	; Make UCB owner of IDB
	MOVZWL	#DCR_K_RESET,DR_DCR(R4)	; Reset DR.
	MOVZWL	#DCR_K_SETINTENB,DR_DCR(R4)	; Enable interrupts

	; Set protection on page containing GO bit to user mode writeable.

	MOVAL	DR_USER(R4),R0		; Get address of GO bit
	EXTZV	#VA$V_VPN,#VA$S_VPN,R0,R1 ; Get virtual page number
	MOVL	G^MMG$GL_SPTBASE,R2	; Get address of system page table
	MOVAL	(R2)[R1],R2		; Get address of PTE that maps GO bit
	INSV	#PRT$C_UW,#PTE$V_PROT,-	; Set protection in appropriate PTE
		#PTE$S_PROT,(R2)
	INVALID	R0			; Invalidate translation buffer

	; Assume adapter has power so set adapter power up bit

	BISW	#UCB_M_ADPPWRUP,UCB$W_DEVSTS(R5)

	; Now determine which type of DR32 we have by seeing
	; what type of cpu we have.  Currently, the only DR32s
	; supported are the DR780 and the DR750.  If we (somehow) get
	; any other cpu type, about all we can do is not set the online
	; bit in the UCB.  Also note that we set a bit in the UCB
	; to indicate which type of DR32 we have.  In the rest of the driver
	; we key off of this bit, rather than using the CPUDISP macro.

	ASSUME	DT$_DR750  EQ  DT$_DR780+1

	MOVB	#DT$_DR780,UCB$B_DEVTYPE(R5)	; Assume device type is DR780

	CPUDISP	<DR_780,DR_750,DR_730>		; * Dispatch on CPU type *

DR_750:	INCB	UCB$B_DEVTYPE(R5)		; Make device type be DR750
	BISW	#UCB_M_DR750,UCB$W_DEVSTS(R5)	; Set DR750 bit in UCB
						; Fall through to ...

DR_780:	BISW	#UCB$M_ONLINE,UCB$W_STS(R5)	; Set online bit

DR_730:

DR_END:						; * End of cpu dependent code *

INIT_DONE:
	RSB



XF_END:					; End of driver


	.END
