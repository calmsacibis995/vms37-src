	.TITLE	$DCI
	.PSECT	DCI,OVR
	.IDENT	/V03000/
	.SBTTL	EDIT 01 DONE ON 9-AUG-74 BY RASPALLO
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
.SBTTL
;		$VERSN	02
;
;
; COPYRIGHT 1971,1972,1973 DIGITAL EQUIPMENT CORPORATION, MAYNARD,MASS
;	DEC ASSUMES NO RESPONSIBILITY FOR THE USE
;	OR RELIABILITY OF ITS SOFTWARE ON EQUIPMENT
;	WHICH IS NOT SUPPLIED BY DEC.
;
;
; MODIFIED 6-NOV-73 TO RETURN 4 WORDS FOR REAL (IE SAME AS DP).
;		    TO USE UNSIGNED BRANCHES ON ADDRESS CMP.
;
;	.CSECT			;************************************
	.GLOBL	$DCI,$RCI
;	$DCI --- ASCII TO DOUBLE CONVERSION.
;	$RCI --- ASCII TO REAL CONVERSION.
;	CALLING SEQUENCE:
;	PUSH ADDRESS OF START OF FIELD
;	PUSH LENGTH OF FIELD
;	PUSH FORMAT SCALE D FROM W.D
;	PUSH P FORMAT SCALE
;	JSR	PC,$DCI	(OR $RCI)
;	RETURNS VALUE ON STACK

	R0=%0
	R1=%1
	R2=%2
	R3=%3
	R4=%4
	R5=%5
	SP=%6
	PC=%7
NUMEND=0
POINTL=2
DIGITS=4
BEXP=6
ESIGN=8.
SIGN=10.
EXP=12.
P=30.
D=32.
ERF=26.
LENGTH=34.
TEMP=LENGTH
RESULT=P
START=36.
END=START
$RCI:
$DCI:	CLR	-(SP)	;CLEAR ERROR FLAG AND SET FOR DOUBLE
	MOV	R0,-(SP)
	MOV	R1,-(SP)
	MOV	R2,-(SP)
	MOV	R3,-(SP)
	MOV	R4,-(SP)
	MOV	R5,-(SP)
	CLR	-(SP)	;CLEAR EXP
	CLR	-(SP)	;CLEAR SIGN
	CLR	-(SP)	;CLEAR ESIGN
	MOV	#65.,-(SP)	;INITIALIZE BEXP
	MOV	#18.,-(SP)	;INITIALIZE MAX DIGITS
	CLR	-(SP)	;CLEAR POINTL
	CLR	-(SP)	;CLEAR NUMEND
	MOV	START(SP),R5	;GET FIELD START ADDRESS
	ADD	LENGTH(SP),END(SP)	;POINT TO END +1
	CLR	R0	;CLEAR NUMERIC WORK SPACE
	CLR	R1
	CLR	R2
	CLR	R3
SCAN:	MOVB	(R5)+,R4	;GET NEXT INPUT CHARACTER
	BIC	#177600,R4
	CMPB	R4,#' 	;TEST FOR BLANK
	BNE	SIGNS	;IF NOT BLANK LOOK FOR + OR -
	CMP	R5,START(SP)	;CHECK END OF FIELD
	BLO	SCAN	;IF NOT DONE GO GET NEXT
	JMP	ZERO	;ENTIRE FIELD IS BLANK
SIGNS:	CMPB	R4,#'+	;CHECK FOR + SIGN
	BEQ	FIELD	;IF FOUND IGNORE IT
	CMPB	R4,#'-	;CHECK FOR - SIGN
	BNE	NUMCK	;IF NOT FOUND CHECK NUMERICS
	INC	SIGN(SP)	;SET - SIGN FLAG
	BR	FIELD
NEXT:	MOVB	(R5)+,R4	;GET NEXT INPUT CHARACTER
	BIC	#177600,R4
	CMPB	R4,#' 	;CHECK FOR BLANKS
	BNE	NUMCK
	MOV	#'0,R4	;TREAT BLANK AS 0
NUMCK:	CMPB	R4,#'0	;CHECK FOR LEGAL CHARACTER
	BLT	PNTCK	;CHECK FOR DECIMAL POINT
	BNE	NONZ	;JUMP IF NOT 0
	TST	R0	;CHECK TO SEE IF ANY NON-ZERO DIGITS FOUND
	BNE	NONZ
	TST	R1
	BNE	NONZ
	TST	R2
	BNE	NONZ
	TST	R3
	BEQ	FIELD
NONZ:	CMPB	R4,#'9
	BGT	EXPCK	;CHECK FOR EXPONENT
	DEC	DIGITS(SP)	;COUNT AS A SIGNIFICANT DIGIT
	BGE	A2I	;JUMP IF WE CAN USE THIS DIGIT
	INC	EXP(SP)	;COMPENSATE FOR SKIPPED DIGIT
	BR	FIELD
A2I:	SUB	#60,R4	;CONVERT ASCII TO INTEGER
	JSR	PC,MUL5	;MULTIPLY BY 5
	JSR	PC,LEFT	;DOUBLE RESULT FOR 10
	ADD	R4,R3	;ADD IN CURRENT DIGIT
	ADC	R2
	ADC	R1
	ADC	R0	;END OF CONVERT FOR THIS DIGIT
FIELD:	CMP	R5,END(SP)	;CHECK FOR END OF FIELD
	BLO	NEXT
	MOV	R5,@SP	;POINTER TO LAST NUMERIC TO NUMEND
SCALE:	TST	R0
	BNE	SCALE1	;JUMP IF NUMBER NOT 0
	TST	R1
	BNE	SCALE1
	TST	R2
	BNE	SCALE1
	TST	R3
	BEQ	ZERO	;INPUT NUMBER IS 0
SCALE1:	CMP	@SP,R5	;CHECK NUMEND
	BNE	NOP	;JUMP IF THERE WAS AN EXPONENT FIELD
	SUB	P(SP),EXP(SP)	;USE THE FORMAT P SCALE
NOP:	TST	POINTL(SP)
	BNE	POINT	;JUMP IF THERE WAS A DECIMAL POINT
	MOV	D(SP),@SP	;USE THE D SCALE
POINT:	SUB	POINTL(SP),@SP
	SUB	@SP,EXP(SP)	;FORM COMPLETE DECIMAL EXPONENT
	BGT	MUL	;MULTIPLY BY 10**EXP
	BLT	DIV	;JUMP IF DECIMAL EXPONENT IS NEG
	JMP	FLOAT	;JUMP IF EXP IS 0
MUL:	CMP	R0,#31462
	BHI	MDIV	;JUMP IF FRACT TOO BIG TO MULT BY 5
	JSR	PC,MUL5	;FRACT=5*FRACT
	INC	BEXP(SP)	;TIMES 2
DEC10:	DEC	EXP(SP)	;OVER 10
	BGT	MUL	;JUMP IF MORE DECIMAL EXPONENT
	JMP	FLOAT	;DECIMAL EXPONENT GONE
MDIV:	JSR	PC,MUL54	;MULTIPLY BY 5/4
	ADD	#3,BEXP(SP)	;TIMES 8
	BR	DEC10	;GO DIVIDE BY 10
PNTCK:	CMPB	R4,#'.
	BNE	ERROR	;JUMP IF NOT A DECIMAL POINT
POINTF:	TST	POINTL(SP)
	BNE	ERROR	;JUMP IF A . ALREADY ENCOUNTERED
	MOV	R5,POINTL(SP)	;SAVE A POINTER TO THE . +1
	BR	FIELD	;GO FOR NEXT CHARACTER
ERROR:	COMB	ERF+1(SP)	;FLAG ERROR
ZERO:	CLR	R0	;RESULT IS 0
	CLR	R1
	CLR	R2
	CLR	R3
	JMP	STORE	;GO PUSH RESULT AND RETURN
EXPCK:	CMPB	R4,#'E
	BEQ	EXPT	;JUMP IF E
	CMPB	R4,#'D
	BNE	ERROR	;IF NOT E OR D THEN ERROR
EXPT:	MOV	R5,@SP	;SAVE POINTER TO END OF NUM +1
	DEC	@SP	;DECREMENT NUMEND
	MOV	R3,TEMP(SP)
	CLR	R3
	CMP	R5,END(SP)
	BHIS	ERROR	;JUMP IF NO ROOM FOR EXP
	MOVB	(R5)+,R4
	BIC	#177600,R4
	CMPB	R4,#'+	;CHECK FOR +EXP
	BEQ	EFLD1
	CMPB	R4,#'-	;CHECK FOR -EXP
	BNE	ENUM	;GO CHECK FOR NUMERIC
	INC	ESIGN(SP)	;FLAG EXPONENT NEGATIVE
EFLD1:	CMP	R5,END(SP)
	BHIS	ERROR
EFLD2:	MOVB	(R5)+,R4	;GET NEXT CHAR
	BIC	#177600,R4
ENUM:	CMPB	R4,#' 	;CHECK FOR BLANK
	BNE	ENUM1
	MOV	#'0,R4	;TREAT BLANK AS 0
ENUM1:	CMPB	R4,#'0
	BLT	ERROR
	CMPB	R4,#'9
	BGT	ERROR	;NOT A VALID CHAR
	SUB	#60,R4	;CONVERT ASCII TO INTEGER
	ASL	R3	;X=10*X+D
	ADD	R3,R4
	ASL	R3
	ASL	R3
	ADD	R4,R3	;END OF ABOVE COMMENT
	CMP	R5,END(SP)
	BLO	EFLD2	;JUMP IF MORE FIELD TO GO
	TST	ESIGN(SP)	;CHECK EXPONENT SIGN
	BEQ	ENUM2	;JUMP IF IT IS +
	NEG	R3	;MAKE USER EXPONENT -
ENUM2:	ADD	R3,EXP(SP)	;GET COMPLETE DECIMAL EXPONENT
	MOV	TEMP(SP),R3
	JMP	SCALE	;GO SCALE THE NUMERIC PART
DIV:	TST	R0
	BLT	DIV1	;JUMP IF FRACT LEFT JUSTIFIED
DIV2:	DEC	BEXP(SP)	;LEFT JUSTIFY NUMERIC BITS
	JSR	PC,LEFT
	BPL	DIV2
DIV1:	MOV	#16.,R4	;SET FOR SIXTEEN ITERATIONS
	JSR	PC,RIGHT
	MOV	R3,-(SP)
	MOV	R2,-(SP)
	MOV	R1,-(SP)	;INITIALIZE QUOTIENT
	MOV	R0,-(SP)
DIV3:	JSR	PC,RIGHT
	CLC
	JSR	PC,RIGHT
	MOV	#2,R5
	CLC
DIV4:	JSR	PC,RIGHT
	ADD	6(SP),R3
	ADC	R2
	ADC	R1
	ADC	R0
	ADD	4(SP),R2
	ADC	R1
	ADC	R0
	ADD	2(SP),R1
	ADC	R0
	ADD	@SP,R0
	DEC	R5	;COUNT TWICE
	BGT	DIV4
	DEC	R4
	BGT	DIV3
	ADD	#8.,SP	;POP DIVIDEND
	SUB	#3,BEXP(SP)
	INC	EXP(SP)	;BUMP DECIMAL EXPONENT
	BLT	DIV	;JUMP IF MORE TO DO
FLOAT:	DEC	BEXP(SP)	;POST NORMALIZE THE RESULT
	JSR	PC,LEFT
	BCC	FLOAT
	ADD	#200,BEXP(SP)	;SET EXCESS 128
	BLE	UNDER	;NUMBER TOO SMALL TO REPRESENT
	CMP	BEXP(SP),#377
	BGT	OVER	;JUMP IF NUMBER TOO BIG
	CLRB	R3
	BISB	R2,R3
	SWAB	R3
	CLRB	R2
	BISB	R1,R2
	SWAB	R2
	CLRB	R1
	BISB	R0,R1	;MOVE OUT LOWEST ORDER BITS
	SWAB	R1
	CLRB	R0
	BISB	BEXP(SP),R0	;INSERT THE BINARY EXPONENT
	SWAB	R0	;PUT IN THE RIGHT ORDER
	ROR	SIGN(SP)	;TEST THE ARITHMETIC SIGN
	JSR	PC,RIGHT	;INSERT IN RESULT
	ADC	R3
	ADC	R2
	ADC	R1	;FINAL ROUND
	ADC	R0
	BVS	OVER	;JUMP IF OVERFLOW
	BCS	OVER
STORE:	MOV	R0,RESULT(SP)	;STORE RESULT ON STACK
	MOV	R1,RESULT+2(SP)
	MOV	R2,RESULT+4(SP)
	MOV	R3,RESULT+6(SP)
	ADD	#14.,SP	;CLEAR STACK OF JUNK
	MOV	(SP)+,R5
	MOV	(SP)+,R4
	MOV	(SP)+,R3
	MOV	(SP)+,R2
	MOV	(SP)+,R1
	MOV	(SP)+,R0
RETRN:	ROL	(SP)+	;FLUSH FLAG AND SET C BIT IF ERROR
	RTS	PC
;
OVER:
UNDER:	JMP	ERROR
;
MUL54:	CMP	R0,#146314
	BLO	MUL54A	;JUMP IF ROOM FOR 5/4 * FRACT
	CLC
	JSR	PC,RIGHT	;DIVIDE BY 2
	INC	BEXP+0+2(SP)	;MULTIPLY BY 2
MUL54A:	MOV	R0,-(SP)
	MOV	R1,-(SP)
	MOV	R2,-(SP)
	MOV	R3,-(SP)
	CLC
	JSR	PC,RIGHT	;HALF
	CLC
	JSR	PC,RIGHT	;QUARTER
	BR	MUL5A	;GO GET F+F/4
MUL5:	MOV	R0,-(SP)	;MULT BY 5
	MOV	R1,-(SP)
	MOV	R2,-(SP)
	MOV	R3,-(SP)
	JSR	PC,LEFT	;DOUBLE
	JSR	PC,LEFT	;QUADRUPLE
MUL5A:	ADD	(SP)+,R3
	ADC	R2
	ADC	R1
	ADC	R0
	ADD	(SP)+,R2
	ADC	R1
	ADC	R0
	ADD	(SP)+,R1
	ADC	R0
	ADD	(SP)+,R0
	RTS	PC	;CODES MAY BE TESTED ON RETURN
LEFT:	ASL	R3
	ROL	R2
	ROL	R1
	ROL	R0
	RTS	PC
RIGHT:	ROR	R0
	ROR	R1
	ROR	R2
	ROR	R3
	RTS	PC
	.END

