TITLE SORTS,<MAIN SORTING SUBROUTINES>,40,05-MAR-77,ALTMANN
;TITLE SORTS,<MAIN SORTING SUBROUTINES>,23,29-OCT-76,ALTMANN
;TITLE SORTS1,<RSORT,RELES,ENDS>,22,29-SEP-76,ALTMANN
;TITLE SORTS1<RSORT,RELES,ENDS>,21,30-AUG-76,ALTMANN
;TITLE SORTS1,<RSORT,RELES,ENDS>,20,4/1/75,INFANTE
	.PSECT	SORTS,OVR
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;
;PDP-11 SORT SUBROUTINE PACKAGE:
;	PART 1:	SELECTION FOR SORT-11 PHASE II
;
;COPYRIGHT 1977: DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
;
;VERSION NO:	 V002

;CALLING SEQUENCES:

;RSORT -- SET UP FOR SORTING
 
;	JSR	PC,RSORT
; R5==> .BYTE	7,0 ;(11.,0)
;	.WORD	<ADDRESS FOR ERROR CODE>
;	.WORD	<ADDRESS OF NUMBER OF BYTES IN KEY>
;	.WORD	<ADDRESS OF NUMBER OF BYTES IN LARGEST DATA RECORD>
;	.WORD	<LOCATION OF KEYS FOR CURRENT RECORD>
;	.WORD	<FIRST LOCATION IN A WORK AREA>
;	.WORD	<ADDRESS OF SIZE OF WORK AREA IN BYTES!!!>
;	.WORD	<ADDRESS OF NUMBER OF SCRATCH FILES>
;********************* O P T I O N A L ***********************
;	.WORD	<ADDRESS OF BIG BUFFER SIZE IN BLOCKS>
;	.WORD	<ADDRESS OF CLUSTERSIZE>
;	.WORD	<ADDRESS OF PRIMARY ALLOCATION IN BLOCKS>
;	.WORD	<ADDRESS OF FIRST LUN>

;RELES -- GIVE AN INPUT RECORD TO THE SORT

;	JSR	PC,RELES
; R5==> .BYTE	3,0
;	.WORD	<ERROR CODE>
;	.WORD	<ADDRESS OF SIZE OF THE RECORD, IN BYTES>
;	.WORD	<LOCATION OF FIRST WORD IN RECORD>

;MERGE -- MERGES STRINGS

;	JSR	PC,MERGE
; R5==> .BYTE	1,0
;	.WORD	<ERROR CODE>

;RETRN -- RETURN A SORTED RECORD TO CALLER
;         IF NO MORE RECORDS, ERROR CODE IS NEGATIVE

;	JSR	PC,RETRN
; R5==>	.BYTE	3,0; (4,0)
;	.WORD	<ERROR CODE>
;	.WORD	<ADDRESS TO RECEIVE SIZE OF RECORD>
;	.WORD	<ADDRESS OF AREA TO RECEIVE RECORD>  ;=0 FOR LOCATE MODE
;	.WORD	<ADDRESS OF WORD TO RECEIVE RECPTR IN LOCATE MODE>

;ENDS -- FINALIZATION

;	JSR	PC,ENDS
; R5==> .BYTE	1,0
;	.WORD	<ERROR CODE>
;

;FOLLOWING GLOBALS ARE LOCATIONS IN THIS MODULE:
 
	.GLOBL	$STPX1,$SOPNF,$SEFBF,$SWKHI
 
;FOLLOWING GLOBALS ARE ENTRY POINTS IN THIS MODULE:
 
	.GLOBL	RSORT,RELES,ENDS,MERGE,RETRN
	.GLOBL	$SKILL,$SDIVD,$SMULT
 
;FOLLOWING GLOBALS ARE ENTRY POINTS IN OTHER MODULES:
 
	.GLOBL	$RREAD,$RWRIT,$RCLOS,$RREWI,$RALBK
	.GLOBL	$RMRGA,$RRTBK,$REOSS,$REOFS
 
;FOLLOWING GLOBALS ARE LOCATIONS IN OTHER MODULES:
 
	.GLOBL	$RRAH,$RWBH,$RFIRL,$RSCLV,$RBGBF,$RPALQ
 
;MISCELLANEOUS CONSTANTS
 
	HEADR=10	;LENGTH OF POINTERS IN NODE
	LOSER=-2	;OFFSET IN HEADER FOR 'LOSER' NODE
	FI=-4		;     DITTO       FOR INTERNAL NODE
	FE=-6		;     DITTO       FOR EXTERNAL NODE
	RN=-10		;     DITTO       FOR RUN NUMBER

	MAXFIL=10.	;MAXIMUM NUMBER OF SCRATCH FILES

	EOSBIT=100000	;FLAG IN FIRST WORD OF SCRATCH RECORD
			;  TO SIGNIFY 'END OF STRING'
 
	EOFBIT=040000	;LIKEWISE TO SIGNIFY 'END OF FILE'

 

	.SBTTL	ROUTINE (A)  -  'RSORT' - INITIALIZE THE SORT:

;  1)  COLLECT & CHECK CALL PARAMETERS:
 
RSORT:	MOV	#SAVER4,R3	;SET POINTER TO COMM. AREA
	MOV	R4,(R3)+	;SAVE R4
	MOV	SC,(R3)+	;SAVE RETURN ADDRESS
	MOV	SP,(R3)+	;... & ENTRY STACK
	MOV	#1,R1		;NEEDED AS CONSTANT
	CMP	(SC)+,(SC)+	;SKIP EXIT & ERROR CODE
	MOV	#11,R0		;SET FIRST ERROR CODE
	TST	(R3)+		;IF SORT IN PROGRESS,
	BNE	RKILL		;... THAT'S IT
	INC	R0		;NEXT ERROR CODE #12
	MOV	@(SC)+,R4	;GET KEY-SIZE IN BYTES
	INC	R4		;MUST BE EVEN ...
	ASR	R4		;...MAKE WORDS
	MOV	R4,(R3)+	;...AND STORE AWAY
	ASL	R4		;...BACK TO EVEN BYTES
	MOV	R4,(R3)+	;... & POSITIVE (KSIZB)
	BLE	RKILL
	INC	R0		;NEW ERROR
	MOV	@(SC)+,@R3	;GET RECORD MAX IN BYTES (MAXREC)
	INC	@R3		;ALSO MUST BE EVEN ...
	BIC	R1,@R3		;... & POSITIVE
	BLE	RKILL
	ADD	(R3)+,R4	;BUILD SRATCH REC SIZE
	INC	R0		;ERROR #14 ...
	MOV	(SC)+,R2	;... IF START OF KEYS
	BIT	R1,R2		;... NOT ON WORD-BOUND
	BNE	RKILL
	TST	(R2)+		;ADJUST FOR AUTO-DECR
	MOV	R2,(R3)+	;... BEFORE STORAGE (KEYLOC)
	MOV	(SC)+,R2	;GET WORK AREA BOTTOM
	INC	R2		;... ALSO ON WORD-BOUND
	BIC	R1,R2
	MOV	@(SC)+,R1	;PICK UP WORK SIZE IN BYTES
	BIC	#1,R1		;EVEN BYTES
	ADD	R2,R1		;R1==>WORKHI
	MOV	R1,-(SP)	;SAVE FOR LATER
	MOV	R1,(R3)+	;STORE AWAY
	TST	(R0)+		;... & ERROR #16
	ADD	#2,R4		;BIGREC = KSIZB + MAXREC + 2(LEN WORD)
	BVS	RKILL		;IF IT IS TOO BIG
	CMP	R4,#37777
	BGT	RKILL		;...WE LOSE
	MOV	R4,(R3)+	;SAVE BEGREC

	INC	R0		;MOV TO ERROR #17
	MOV	@(SC)+,@R3	;GET # OF SCRATCH FILES
	BEQ	ALW		;IF ZERO, ASSUME IN-CORE
	CMP	@R3,#3		;IF LESS THAN 3...
	BLT	RKILL
	INC	R0
	CMP	@R3,#MAXFIL	;... OR MORE THAN MAX.
	BLE	ALW		
RKILL:	BR	$SKILL		;... THAT'S IT
ALW:	CMPB	@SAVESC,#7	;EXTRA PARAMETERS?
	BLE	ALWX		;NO
	MOV	@(SC)+,R0	;PICK UP BIG BUFFERING
	TST	$RBGBF		;IF NON-ZERO, IT MUST OVERRIDE
	BNE	1$
	MOV	R0,$RBGBF	;SET IN NEW VALUE
1$:	CMPB	@SAVESC,#8.	;ANY MORE?
	BLE	ALWX		;NO
	MOV	@(SC)+,R0	;PICK UP SCRATCH CLUSTER VALUE
	TST	$RSCLV		;DITTO
	BNE	2$
	MOV	R0,$RSCLV
2$:	CMPB	@SAVESC,#9.	;ANY MORE
	BLE	ALWX		;NO
	MOV	@(SC)+,R0	;PICK UP PRIMARY ALLOCATION
	TST	$RPALQ		;DITTO
	BNE	3$
	MOV	R0,$RPALQ
3$:	CMPB	@SAVESC,#10.	;ANY MORE
	BLE	ALWX		;NO
	MOV	@(SC)+,$RFIRL	;SET FIRST LUN

;  2)  ALLOCATE WORK AREA AND I/O SPACE:
 
ALWX:	MOV	R4,R0		;ADJUST 'BIGREC' SIZE ...
	ADD	#HEADR,R0	;... FOR NODE LENGTH
	MOV	R2,LSTKEY	;... SET ASIDE AREA FOR LASTKEY
	ADD	R0,R2		;... AND UPDATE LOWCORE POINTER
	CALL	$RALBK		;NOW MAKE I/O AREA CHECKS

;  3)  SET UP FILE CONTROLS:
 
	MOV	(R3)+,R0	;GET # OF FILES - 1
	BEQ	1$		;NOFILES-INCORE!
	DEC	R0
	MOV	R0,(R3)+	;STORE RESULT
	DEC	R0		;STORE TOP INDEX #2
	ASL	R0		; (2[# OF FILES - 2])
	MOV	R0,@R3
	MOV	(R3)+,@R3	;USE ALSO AS INDEX TO ...
	MOV	(R3)+,(R3)+	;... 1ST OUT FILE
	TST	(R0)+		; (IGNORED DURING PRESORT)
	MOV	R0,(R3)+	;STORE TOP INDEX #1
	ASR	R0		; (2[# OF FILES - 1])
	MOV	#STOADD,SC	;SET STRING-TO-ADD FLAGS
	MOV	#1,(SC)+	;... ON ALL FILES BUT LAST
	DEC	R0		; (= # OF FILES - 1)
	BNE	.-6
	CLR	(SC)+		;CLEAR ALL FILE STRING TOTALS
	CMP	SC,#RETDUN	;... & LAST WRITE FLAGS
	BNE	.-6
	BR	2$
;
;	IN CORE ONLY
;
1$:	CMP	(R3)+,(R3)+	;STEP R3
	CMP	(R3)+,(R3)+
	CLR	(R3)+		;SET FILE INDEX TO ZERO

;  5)  ALLOCATE SPACE FOR THE SORT TREE:
 
	LEN=%4			;LENGTH OF A NODE=HEADR+BIGREC
	K=%5			;PTR TO INTERNAL NODE
	L=%0			;PTR TO EXTERNAL NODE
	I=%2			;PTR STEPPED TO EACH NODE
	LENX=%1			;LEN+10 FOR STEPPING I
	Q=%2			;PTR TO CURRENT CHAMPION
	RQ=%3			;RUN NUMBER OF CHAMPION
	T=%4			;TEMP PTR
;
2$:	MOV	R2,(R3)+	;STORE TREE START(ROOT)
	MOV	R2,(R3)		;SET INITIAL Q(QSAV) TO THIS VALUE
	MOV	#HEADR,K	;... NEEDED BY ROUTINES
	ADD	K,(R3)+		;... OFFSET
	ADD	K,LEN		;LEN := BIGREC + HEADR
	MOV	LEN,R1		;SET UP FOR DIVIDE
	MOV	@SP,R0		;RECOVER HIGH CORE
	SUB	R2,R0		;R0 = AMOUNT LEFT
	MOV	R2,@SP		;SAVE LOW CORE PTR
	PUSH	R3		;*!*!*! R3 DESTROYED BY MULT
	CLR	R3		;CLEAR OUT HI ORDER
	CALL	$SDIVD		;CALL DIVIDE: R0 := R0/R1
	POP	R3
	MOV	@SP,R2		;RECOVER LOW CORE PTR
	BIC	#1,R0		;MAKE EVEN NUM OF NODES
	MOV	R0,@SP		;SAVE FOR LATER
	ASR	R0		;1/2 NUMBER OF NODES
	MOV	LEN,R1		;SET UP FOR MULTIPLY-NEED LENGTH
				; OF HALFWAY POINT
	PUSH	R3		;*!*!*! R3 DESTROYED BY MULT
	CALL	$SMULT		;CALL MULT: R0 := R0 * R1
	POP	R3
	MOV	LEN,LENX	;COPY LENGTH
	ADD	K,LENX		;SET UP LEN+10 FOR STEPPING
	MOV	R2,(R3)		;SET UP NODE1 POINTER
	ADD	LENX,(R3)+	;OFFSET TO PROPER PLACE
	SUB	LEN,I		;SET I==> -1 NODE
	ADD	I,K		;SET K==>-1NODE + OFFSET
	ADD	K,L		;SET L==> HALFWAY + OFFSET

; 6) INITIALIZE TREE
 
INITRE:	ADD	LENX,I		;STEP TO NEXT NODE
	BIT	#1,@SP		;IF EVEN(NODE)
	BNE	1$		;... THEN ...
	ADD	LEN,K		;... K ==> NEXT NODE
	ADD	LEN,L		;... DITTO
1$:	MOV	I,-(SP)		;TEMP STORE FOR COMPATIBILTY
	MOV	(SP)+,-(I)	;  I,-(I) NOT ON 11-20
	MOV	K,-(I)		;FI(NODE) ==> NODE DIV 2
	MOV	L,-(I)		;FE(NODE) ==> (P + NODE) DIV 2
	CLR	-(I)		;RN(NODE) := 0
	DEC	@SP		;STEP A NODE
	BGT	INITRE		;REPEAT?
 
;  7)  DO FINAL CLEAN-UP:
 
	CLR	(R3)+		;SWITCH := EOF := FALSE
	CLR	(R3)+		;RC := 0
	CLR	(R3)+		;RQ := 0
	CLR	@R3		;... NO-WRITE FLAG
;
;COMMON EXIT POINT
;
NOERR:	INC	SORTON		;SET SORT UNDERWAY FLAG
NOERRX:	CLR	R0		;SET NO ERROR
$SKILL:	MOV	SAVESP,SP	;RESTORE REGS
	MOV	SAVESC,SC
	MOV	SAVER4,R4
	MOV	R0,@2(SC)	;RETURN ERROR
	MOV	R2,R0		;RECOVER ANY I/O ERRORS
	RETURN

	.SBTTL	ROUTINE (B)  -  'RELES' - ACCEPT A RECORD
;			AND WRITE ONE TO SCRATCH FILE:

;  1)  COLLECT & CHECK CALL PARAMETERS:
 
RELES:	MOV	#SAVER4,R2	;SAVE ACTIVE REGS
	MOV	R4,(R2)+
	MOV	SC,(R2)+
	MOV	SP,(R2)+
	CMP	(SC)+,(SC)+	;SKIP EXIT & ERROR BRANCH
	CLR	R0		;PREPARE FOR ERROR
	MOV	@(SC)+,R4	;GET RECORD SIZE
	BLE	1$		;IF NOT POSITIVE, ERROR
	CMP	R4,MAXREC	;SIMILARLY IF > MAX. INDICATED
	BGT	1$
	MOV	@SC,-(SP)	;GET RECORD LOCATION
	MOV	#10,R0		;ADJUST ERROR
	BIT	#1,@SP		;IF NOT EVEN, ALSO ERROR
	BEQ	2$
1$:	ADD	#5,R0		;ERROR #15
	BR	$SKILL
2$:	TST	-(SP)		;SKIP FOR NOW
	MOV	R4,-(SP)	;SAVE RECORD SIZE IN BYTES
	INC	R4		;ROUND UP
	ASR	R4		;NOW WORDS
	MOV	R4,2(SP)	;SAVE RECORD SIZE IN WORDS
	CMP	#1,@R2		;RELES PHASE PROPER NOW?
	BNE	$SKILL		;NO, ERROR OUT

;  2)  START OF TREESORT ALGORITHM
;
	MOV	QSAV,Q		;DITTO FOR Q
	MOV	RQSAV,RQ	;PICK UP RQ VALUE
	BEQ	3$		;IF RQ NOT= 0 THEN
	INC	SWITCH		;SET SECOND RUN SWITCH
	CALL	TSELEC		;SELECT THE CHAMPION
 
;  3)  OUTPUT TOP OF TREE (THE "LOSER")
 
	MOV	Q,R1		;R1==>RECORD ADDR  SET UP FOR RITREC
	MOV	CURFIL,R4	;SET R4=CURRENT FILE INDEX
	CALL	$RWRIT		;OUTPUT RECORD AT Q
 
;  4)  INPUT NEW RECORD AT (Q)
 
3$:	MOV	Q,R1		;SET R1==>RECORD LOCATION
	MOV	(SP)+,(R1)+	;STICK IN RECSIZ(BYTES) AS HEADER
	MOV	KEYLOC,R0	;SET R0==>KEY LOCATION
	MOV	KSIZW,R5	;SET R5 = KEY SIZE IN WORDS
4$:	MOV	-(R0),(R1)+	;MOVE IN KEY(STORED BACKWARDS IN CALL)
	DEC	R5		;STEP DOWN
	BGT	4$		;REPEAT UNTIL DONE
	MOV	(SP)+,R5	;SET R5 = RECORD SIZE IN WORDS
	MOV	(SP)+,R0	;SET R0==>CALLERS RECORD
5$:	MOV	(R0)+,(R1)+	;MOVE IT
	DEC	R5		;COUNT
	BGT	5$		;REPEAT UNTIL DONE
	CALL	TREINP		;INPUT TO TREE
 
;  5)  SET NEW LOSER
 
	CALL	TUPDAT		;UPDATE THE TREE
	MOV	Q,QSAV		;SAVE Q FOR NEXT ITERATION
	MOV	RQ,RQSAV	;DITTO
	JMP	NOERRX		;RETURN WITH NO ERROR

	.SBTTL	ROUTINE (C)  -  'MERGE' -  MERGE SCRATCH FILES:

;	REDUCES EACH FILE UNTIL ONLY ONE STRING
;	REMAINS ON EACH.

;	1) CHECK VALID CALL & NEED FOR MERGE:
 
MERGE:	MOV	#SAVER4,R1	;SET PTR TO WORKSPACE
	MOV	R4,(R1)+	;SAVE REG
	MOV	SC,(R1)+
	MOV	SP,(R1)+
	CLR	R0		;PREPARE FOR ERROR
	CMP	#1,@R1		;IF NO SORT UNDERWAY ...
	BNE	MERGEE		;... SHOOT HIM DOWN
	CLR	RETDUN		;CLEAR 'RETURN DONE' FLAG
	MOV	QSAV,Q		;RESTORE IMPORTANT PTR
	MOV	RQSAV,RQ
	TST	$SOPNF		;IF NO SCRATCH FILES USED...
	BNE	MERGE0		;...THEN...
 
;	2) "PERCULATE CHAMPION TO TOP" - IN CORE
 
1$:	TST	RQ		;DID FIRST RUN END?
	BNE	3$		;YES, SKIP THIS
2$:	MOV	#-1,RQ		;SET END OF RECORD MARKER
	CALL	TUPDAT		;UPDATE WINNER
	TST	RQ		;IF RQ <> 0 
	BEQ	2$		;...THEN...
	MOV	RQ,RQSAV	;...& SAVE REGS
	MOV	Q,QSAV	
3$:	INC	SORTON		;...INDICATE MERGE DONE
	JMP	NOERR		;...& EXIT W/NO ERRORS
 
MERGEE:	JMP	RETRNE		;FOR ERROR, USE 'RETRN'
 
;	3)  FLUSH OUT TREE - TO DISK
 
MERGE0:	CALL	TSELEC		;SELECT CHAMPION
	MOV	Q,R1		;R1==>RECORD
	MOV	CURFIL,R4	;SET CURRENT OUTPUT FILE INDEX
	CALL	$RWRIT		;OUTPUT RECORD AT (Q)
	MOV	#-1,RQ		;SET LAST RUN MARKER
	CALL	TUPDAT		;UPDAT TREE
	CMP	#-1,RQ		;LAST RUN?
	BNE	MERGE0		;NO, REPEAT FLUSHING
	CALL	RITEOS		;OUTPUT 'EOS'
	INC	SORTON		;SHOW MERGE STARTED
	MOV	TOPIX2,R4	;SET TO HIGHEST FILE
3$:	CALL	$REOFS		;WRITE 'EOF' ON EACH FILE...
	SUB	#2,R4		;...EXCEPT LAST
	BGE	3$		;REPEAT
 

;	4)  RE-ALLOCATE FREE CORE FOR MERGE BUFFERS
 
	CALL	$RMRGA		;CALL MERGE ALLOCATOR IN SIOXXX
 
;	5)  REWIND ALL FILES
 
	MOV	TOPIX2,R4	;SET TO HIGHEST FILE
4$:	MOV	#$RRAH,R5	;SET FOR READ AHEAD
	CALL	$RREWI		;REWIND IT
	SUB	#2,R4		;...EXCEPT LAST
	BGE	4$
 
;	6)  COMPUTE TOTAL STRINGS:
 
	CLR	-(SP)		;CLEAR ACCUMULATOR
	MOV	TOPIX2,R4
5$:	ADD	STOADD(R4),TOTSTR(R4) ;ASSUME ALL STRINGS DONE
	ADD	TOTSTR(R4),@SP	;... & COMPUTE TOTAL
	SUB	#2,R4		;... FOR ALL FILES
	BGE	5$		;... EXCEPT EMPTY ONE
	MOV	$STPX1,R4	;THIS BECOMES 1ST FOR OUTPUT
	MOV	R4,CURFIL
	MOV	#$RWBH,R5
	CALL	$RREWI		;SET UP FOR PUT ACCESS
	BR	MERGE5

;	7)  RE-OPEN AN EMPTIED FILE FOR OUTPUT:
 
MERGE4:	MOV	$STPX1,R3	;FIND THE EMPTY FILE
	TST	(R3)+		;... BY SEARCH FROM TOP
6$:	SUB	#2,R3
	BLT	MERGE5		; (IF NONE,TRY AGAIN)
	TST	TOTSTR(R3)
	BNE	6$
	MOV	R3,-(SP)	;HOLD ITS INDEX
	MOV	CURFIL,R4	;SET EOF ON CURRENT OUTPUT FILE
	CALL	$REOFS		;...AND DO IT
	MOV	#$RRAH,R5	;...SET FOR READING
	CALL	$RREWI		;...THEN REWIND THE FILE
	MOV	(SP)+,R4	;SET EMPTY FILE AS ...
	MOV	R4,CURFIL	;... CURRENT ONE FOR OUTPUT
	MOV	#$RWBH,R5	;... & REWIND FOR WRITE
	CALL	$RREWI

;	8)  READ 1 RECORD FROM EACH INPUT FILE:
 
MERGE5:	MOV	$STPX1,R4	;SET INDEX AT TOP
	CLR	NUMEOS		;... & INIT. EOS COUNTER
1$:	CMP	R4,CURFIL	; (EXCEPT THE OUTPUT ONE)
	BEQ	2$		;... CLEAR EOS FLAG
	TST	STOADD(R4)	;IF STILL DUMMY STRINGS ...
	BLE	3$		;... ON THIS FILE
	DEC	STOADD(R4)	;... DECREMENT #
	DEC	TOTSTR(R4)	;... & TOTALS
	DEC	@SP
2$:	INC	NUMEOS		;... & COUNT IT
	BR	4$
3$:	CALL	INREC		;IF NO DUMMIES, GET RECORD
	BIT	#EOSBIT!EOFBIT,@R1	;CHECK IF PREMATURE ENDING
	BNE	BADEOS
4$:	SUB	#2,R4		;IF NOT, THEN RETURN FOR NEXT
	BGE	1$
	CMP	NUMEOS,NUMFIL	;IF ALL FILES AT EOS ...
	BLT	MERGE6
	MOV	CURFIL,R4	;... PUT A DUMMY
	INC	TOTSTR(R4)	;... ON THE OUTPUT FILE
	INC	STOADD(R4)
	BR	MERGE5		;... & TRY AGAIN
;
BADEOS:	MOV	#21,R0		;IF EOS UNEXPECTED ...
	TST	@R1
	BMI	RETRNX		;... OBJECT!
BADEOF:	MOV	#22,R0		;SIMILARLY FOR INCORRECT EOF
	BR	RETRNX

;	9)  PERFORM MERGE:
 
MERGE6:	CMP	@SP,NFLES1	;IF ONLY 1 STRING/FILE
	BGT	MERG6B
	INC	SORTON		;... SHOW MERGE DONE
	CLR	NOTFIR
	INC	NOTFIR		;SET THE FIRST TIME INTO 'RETRN' SW
MERGEX:	JMP	NOERRX		;... RETURN NO ERROR
MERG6B:	CALL	SMALL		;OTHERWISE FIND THE SMALLEST RECORD ...
	MOV	R4,-(SP)	;... (SAVE INPUT FILE INDEX)
	MOV	CURFIL,R4	;... (PICK UP OUTPUT FILE INDEX)
	CALL	$RWRIT		;... AND WRITE IT OUT...
	MOV	(SP)+,R4	;... (RESTORE INPUT FILE INDEX)
	CALL	INREC		;... AND REPLACE IT
	BIT	#EOSBIT!EOFBIT,@R1
	BEQ	MERG6B
	TST	@R1		;IF NONE THERE THRU EOF ...
	BPL	BADEOF		;... IT'S AN ERROR
	DEC	@SP		;IF IT'S AN EOS DECREASE STRING TOTALS
	DEC	TOTSTR(R4)
	INC	NUMEOS		;INCREMENT EOS COUNT
	CMP	NUMEOS,NUMFIL	;IF ALL AT END OF STRING ...
	BLT	MERG6B
	CALL	RITEOS		;... WRITE 'EOS' ON OUTPUT FILE
	INC	@SP		;... ADD TO TOTAL
	JMP	MERGE4		;... & GET NEW OUTPUT FILE

	.SBTTL	ROUTINE (D)  -  'RETRN' - RETURN A RECORD TO CALLER:

;	1)  COLLECT CALL PARAMETERS:
 
RETRN:	MOV	#SAVER4,R1	;SET PTR TO WORK DATA
	MOV	R4,(R1)+
	MOV	SC,(R1)+	;... & SAVE ACTIVE REGISTERS
	MOV	SP,(R1)+
	CLR	R0		;PREPARE FOR ERROR ...
	CMP	#3,SORTON	;... & IF NO SORT UNDERWAY
	BNE	RETRNE		;... SHOOT HIM DOWN
	CMP	(SC)+,(SC)+	;GET CALL PARAMETERS
	MOV	(SC)+,-(SP)	;... ADDRESS FOR RECSZE
	MOV	(SC)+,-(SP)	;... & RECORD BUFFER
	CMPB	#4,-10(SC)	;OPTIONAL PARAMTER?
	BNE	1$		;NO
	MOV	(SC)+,OUTPTR	;YES, STORE IT AWAY
1$:	BIT	#1,@SP		;IF LATTER NOT EVEN ...
	BEQ	RETRN0
	MOV	#5,R0		;... IT'S AN ERROR
RETRNE:	ADD	#10,R0
RETRNX:	JMP	$SKILL

;	2)  GET NEXT RECORD FOR CALLER:
 
RETRN0:	TST	$SOPNF		;IF ALL RECORDS IN CORE...
	BNE	1$
	TST	RQSAV		;IF RQ < 0...
	BLT	4$		;...THEN END OF FILE
	MOV	QSAV,Q		;ELSE RESTORE
	MOV	Q,-(SP)		;SAVE OUTPUT POINTER
	MOV	#-1,RQ		;SET END MARKER
	CALL	TUPDAT		;UPDATE THE TREE
	MOV	(SP)+,R1	;RECOVER RECORD
	MOV	Q,QSAV		;SAVE FOR LATER
	MOV	RQ,RQSAV	;RESTORE 
	BR	2$		;CONTINUE
1$:	TST	NOTFIR		;IF THIS IS NOT THE 1ST CALL
	BNE	21$		;...THEN...
	MOV	CURFIL,R4	;RESTORE FILE INDEX
	CALL	INREC		;FETCH A NEW RECORD
	BIT	#EOSBIT!EOFBIT,@R1	;ANY SPECIAL BIT SET?
	BEQ	21$		;NO, CONTINUE
	TST	@R1		;IF NO MORE THRU EOF...
	BPL	BADEOF		;...IT'S AN ERROR
	INC	NUMEOS		;ELSE UP THE EOS COUNTER
	CMP	NUMEOS,NUMFIL	;UNTIL FILES ALL AT EOS ...
	BEQ	4$
21$:	CALL	SMALL		;FIND SMALLEST RECORD
	MOV	R4,CURFIL	;HOLD FILE INDEX FOR NEXT TIME
	CLR	NOTFIR		;CLEAR NOT 1ST TIME SWITCH

;	3)  TRANSFER RECORD:
 
2$:	MOV	(SP)+,R3	;SET PTR TO CALLER BUFFER
	MOV	(R1)+,R0	;GET DATA SIZE FROM RECORD
	MOV	R0,@(SP)+	;... & GIVE TO CALLER
	ADD	KSIZB,R1	;SKIP STORED KEY
	TST	R3		;LOCATE MODE?
	BNE	3$		;IF NOT ,GO DO MOVE
	MOV	R1,@OUTPTR	;YES, STICK OUTPTR INTO CALLERS AREA
	BR	MERGEX		;... & DON'T MOVE ANYTHING
3$:	MOV	(R1)+,(R3)+	;...& PASS DATA TO CALLER
	SUB	#2,R0
	BGT	3$
	CLR	NOTFIR		;CLEAR NOT FIRST TIME SWITCH
	BR	MERGEX		;... THAT'S IT

;	4)  ALL FILES EXHAUSTED -- SORT COMPLETE:
 
4$:	MOV	#7,R0		;IF BEEN HERE BEFORE
	TST	RETDUN
	BNE	RETRNX		;... IT'S AN ERROR
	MOV	#-1,R0		;OTHERWISE INFORM CALLER
	DEC	RETDUN		;... & SET SWITCH
	BR	RETRNX

	.SBTTL	ROUTINE (E)  -  'ENDS' - FINISH UP SORT
 
ENDS:	MOV	#SAVER4,R2	;SET POINTER TO DATA AREA
	MOV	#10,R0		;PREPARE FOR ERROR
	MOV	R4,(R2)+	;SAVE REGS
	MOV	SC,(R2)+
	MOV	SP,(R2)+
	TST	@R2		;IF NO SRT IN PROGRESS,
	BEQ	RETRNX		;...ERROR OUT
	CLR	@R2		;CLEAR UNDER WAY SWITCH
	TST	$SOPNF		;IF ANY SCRATCH FILES OPENED,
	BEQ	1$		;...THEN...
	CALL	$RCLOS		;...CLOSE THEM
1$:	TST	NUMFIL		;IF INCORE ONLY
	BEQ	2$		;SKIP NEXT
	CALL	$RRTBK		;RECOVER THE I/O SPACE
2$:	JMP	NOERRX		;RETURN W/O ERRORS

	.SBTTL	SUBSIDIARY SUBROUTINES
 
	.SBTTL	1) 'COMPAR'  -  DO A LONG LOGICAL COMPARE
 
;ON ENTRY R0==>SOURCE OPERAND
;	  R1==>DESTINATION OPERAND
 
;ON EXIT  CONDITION CODES PROPERLY SET FOR LOGICAL COMPARE
;NOTE:  R5  DESTROYED
 
COMPAR:	CMP	(R0)+,(R1)+	;SKIP OVER HEADER WORD
	MOV	KSIZW,R5	;ADJUST COUNTER
1$:	CMP	(R0)+,(R1)+	;COMPARE WORD AT A TIME
	BNE	2$		;UNTIL INEQUALITY
	DEC	R5		;OR 
	BGT	1$		;UNTIL END OF AREA
2$:	RETURN			;RETURN WITH COND CODE PROPERLY SET

	.SBTTL	2) '$SDIVD' - DIVIDE ROUTINE R0 := R0 / R1
 
;ON ENTRY R0 = DIVIDEND
;	  R1 = DIVISOR
;	  R3 = HI ORDER DIVIDEND
 
;ON EXIT  R0 = QUOTIENT
;	  R2 DESTROYED
 
$SDIVD:	PUSH	#32.		;SHIFT COUNT
ZXZ:	CLR	R2		;SCRATCH
1$:	ASL	R0		;SHIFT AND SUB
	ROL	R3
	ROL	R2
	CMP	R2,R1		;SUB OUT DIVISOR?
	BLO	2$		;NO
	SUB	R1,R2
	INC	R0		;ADD IN LOW BIT
2$:	DEC	@SP		;REPEAT COUNT
	BNE	1$
	TST	(SP)+		;POP SHIF COUNT
	RETURN

	.SBTTL	3) '$SMULT' - MULTIPICATION ROUTINE R0 := R0 * R1
 
;ON ENTRY R0 = MULTIPLIER
;	  R1 = MULTIPLICAND
 
;ON EXIT  R0 = PRODUCT
;	  R3 = HI ORDER
 
$SMULT:	MOV	R0,-(SP)	;STANDARD MUL ALGORITHM
	CLR	R3
	CLR	R0
1$:	ASR	R1
	BCC	2$
	ADD	@SP,R0
	ADC	R3		;SET INTO HI ORDER
	TST	R1
2$:	BEQ	3$
	ASL	@SP
	BR	1$
3$:	TST	(SP)+		;END OF MULT
	RETURN

	.SBTTL	4) 'RITEOS' - WRITE OUT AN EOS ON CURFIL
 
;ON EXIT  CURFIL IS UPDATED WITH NEW OUTPUT FILE
;
;	(IF MORE INPUT TO COME, DETERMINE WHICH FILE
;	RECEIVES NEXT STRING)

RITEOS:	MOV	R2,-(SP)		;SAVE
	MOV	R3,-(SP)
	MOV	#EOSBUF,R1	;SET BUFFER POINTER
	MOV	CURFIL,R4	;R4=FILE INDEX
	CALL	$RWRIT		;WRITE IT OUT
	INC	TOTSTR(R4)
	CMP	#2,SORTON	;ARE WE IN MERGE PHASE?
	BEQ	8$		;YES,SKIP NEXT
	DEC	STOADD(R4)	;... ADJUST STRING COUNTS
	CALL	$REOSS		;... & DO ANY SPECIAL EOS PROCESSING
	CMP	RQ,#-1		;IS THIS THE LAST EOS?
	BEQ	8$		;YES, IGNORE NEXT ROUTINE
	MOV	#TOPIX2,R1	;OTHERWISE SET WORK PTR
	MOV	(R1)+,R3	;... TO COLLECT TOP INDEX #2

;DETERMINE WHICH FILE IS TO RECEIVE NEXT STRING
 
1$:	SUB	#2,R4		;STEP TO NEXT FILE
	BGE	2$
	MOV	R3,R4
2$:	CMP	R4,@R1		;TRY AGAIN IF THIS FILE ...
	BEQ	1$		;... TO BE IGNORED
	MOV	R4,CURFIL	;IF STRINGS CAN BE ADDED ...
	TST	STOADD(R4)	;... TO THIS FILE
	BNE	8$		;... THEN EXIT
	SUB	#2,@R1		;OTHERWISE ...
	BGE	4$		;... MAKE NEXT FILE DOWN
	MOV	R3,@R1		;... THE ONE TO BE IGNORED
4$:	MOV	(R1)+,R2	;HOLD ITS INDEX ...
	MOV	R3,R0		;... & GET FIRST FILE
	MOV	TOTSTR(R2),R4	;GET # OF STRINGS ON IGNFIL
5$:	CMP	R0,R2		;... & MAKE THIS
	BEQ	6$		;... THE # OF NEW STRINGS
	MOV	R4,STOADD(R0)	;... TO BE ADDED
6$:	SUB	#2,R0		;... TO ALL OTHER FILES
	BGE	5$
	SUB	#2,R2		;MAKE FILE BELOW IGNFIL
	BGE	7$		;... THE NEW  CURRENT FILE
	MOV	R3,R2
7$:	MOV	R2,@R1
8$:	MOV	(SP)+,R3
	MOV	(SP)+,R2
	RETURN			;THEN EXIT

	.SBTTL	5) 'SMALL' - FIND SMALLEST RECORD
 
;ON EXIT  R4 = FILE INDEX
;	  R1==>RECORD AREA
 
SMALL:	MOV	LSTHED,R3	;R3==>DUMMY NODE
	TST	(R3)+		;R3==>TAIL(DUMMY)
	MOV	@R3,R2		;R2==>CURRENT NODE
	BEQ	1$		;ERROR-LIST EXHAUSTED!!!!
	MOV	LAVS,R0		;R0=LAVS POINTER
	MOV	R2,-(R0)	;RESTACK THE NODE ON LAVS
	MOV	R0,LAVS		;RESTORE LAVS POINTER
	MOV	(R2)+,R1	;R1==>RECORD ADDRESS OF SMALLEST
	MOV	@R2,@R3		;UPDATE TAIL(DUMMY)==>TAIL(OLD)
	CLR	(R2)+		;SET TAIL(OLD)==>EOL
	MOV	@R2,R4		;R4=FILE INDEX
	RETURN			;FINISHED!!!
;
1$:	MOV	#22,R0		;SET ERROR = 22
	JMP	$SKILL		;ERROR OUT
 
;
;DATA AREA FOR LIST
;
LAVS:	.WORD	LIST		;POINTER TO LAVS STACK
LSTHED:	.WORD	DUMMY		;POINTER TO FIRST NODE
DUMMY:	.WORD	-1,0,-1		;DUMMY NODE
 
	$$T=1
	.REPT	MAXFIL
	.IRP	X,\$$T
Z'X:	.WORD	-1,0,-1
	$$T=$$T+1
	.ENDM
	.ENDR
;
LIST:
	$$T=1
	.REPT	MAXFIL
	.IRP	X,\$$T
	.WORD	Z'X
	$$T=$$T+1
	.ENDM
	.ENDR

	.SBTTL	6) 'INREC'  -  INPUT A RECORD AND STICK IN ORDERED LIST
 
;ON ENTRY R4 = FILE INDEX TO BE READ FROM
 
;ON EXIT  R1==>RECORD AREA
;         R4 = FILE INDEX
 
INREC:	CALL	$RREAD		;OBTAIN A NEW RECORD
	BIT	#EOSBIT!EOFBIT,@R1	;EOS OR EOF?
	BNE	3$		;YEP, CLEAR OUT
	MOV	R5,-(SP)	;SAVE R5-DESTROYED BY COMPARE
	MOV	R1,-(SP)	;SAVE R1-DITTO
	MOV	LSTHED,R3	;R3==>DUMMY NODE
1$:	TST	(R3)+		;R3==>TAIL(DUMMY)
	TST	@R3		;ANY REAL NODES?
	BEQ	2$		;NO, AT EOL
	MOV	@R3,R2		;YES, R2==>CURRENT NODE
	MOV	@R2,R0		;R0==>KEY OF RECORD
	MOV	@SP,R1		;RESTORE R1==>RECORD
	CALL	COMPAR		;CMP NODE,RECORD
	BHI	2$		;GO INSERT BEFOR THIS NODE
	MOV	R2,R3		;SET PREDECESSOR <-- CURRENT
	BR	1$		;AND TRY AGAIN
2$:	MOV	LAVS,R0		;R0 = LAVS POINTER
	MOV	(R0)+,R2	;POP A NEW NODE INTO R2
	MOV	R0,LAVS		;REPLACE LAVS POINTER
	MOV	@R3,2(R2)	;TAIL(PRE) <-- TAIL(CURRENT)
	MOV	R2,@R3		;CURRENT --> TAIL(PRE)
	MOV	(SP)+,R1	;RESTORE R1==>RECORD ADDR
	MOV	R1,@R2		;STORE REC ADDR IN CURR NODE
	MOV	R4,4(R2)	;... AND FILE INDEX
	MOV	(SP)+,R5	;RESTORE R5
3$:	RETURN

	.SBTTL	7) 'TSELEC' - SELECT THE CHAMPION
 
;
;
TSELEC:	CMP	RQ,RC		;IF RQ NOT= RC
	BEQ	2$		;...THEN...
	MOV	RC,RQ		;...RQ := RC + 1
	INC	RQ
	TST	RC		;IF RC <> = 0
	BEQ	1$		;...THEN...
	CALL	RITEOS		;...CALL RUNEND ROUTINE
1$:	MOV	RQ,RC		;...RC := RQ
2$:	TST	SWITCH		;ELSE IF SWITCH 
	BEQ	5$		;...THEN...
 
;	SET LASTKEY := KEY(Q)
 
	MOV	KSIZW,R5	;PICK UP LENGTH OF MOV
	INC	R5		;ALLOW FOR LENGTH HEADER WORD
	MOV	LSTKEY,R1	;ADDR OF DST
	MOV	Q,R0		;ADDR OF SRC
4$:	MOV	(R0)+,(R1)+	;MOVEIT
	DEC	R5		;STEP DOWN
	BGT	4$		;REPEAT UNTIL EXHAUSTED
5$:	RETURN

	.SBTTL	8) 'TREINP' - INPUT NEW RECORD AT (Q)
 
TREINP:	TST	SWITCH		;IF NOT SWITCH
	BEQ	1$		;...THEN
	MOV	LSTKEY,R1	;...(R1==>DST)
	MOV	Q,R0		;...(R0==>SRC)
	CALL	COMPAR		;IF KEY(Q) < LASTKEY
	BHIS	2$		;...THEN
1$:	INC	RQ		;...INCREMENT THE RUN NUMBER
2$:	RETURN			;EXIT

	.SBTTL	9) 'TUPDAT' - SET NEW LOSER
 
TUPDAT:	MOV	FE(Q),T		;T := FE(Q)
1$:	CMP	RN(T),RQ	;IF RN(T) <= RQ
	BHI	3$		;...THEN
	BLO	2$		;IF RN(T) = RQ
	MOV	LOSER(T),R1	;...R1==>DST
	MOV	Q,R0		;...R0==>SRC
	CALL	COMPAR		;...IF KEY(Q) > KEY(LOSER(Q))
	BLOS	3$		;...THEN
2$:	MOV	LOSER(T),-(SP)	;...EXCHANGE LOSER(T)
	MOV	Q,LOSER(T)	;...AND
	MOV	(SP),Q		;...Q
	MOV	RN(T),(SP)	;...EXCHANGE RN(T)
	MOV	RQ,RN(T)	;...AND
	MOV	(SP)+,RQ	;...RQ
 
;	MOVE UP PATH TO ROOT, SETTING NEW LOSERS
 
3$:	CMP	T,NODE1		;IF T==> 1ST NODE
	BEQ	4$ 		;...THEN RETURN
	MOV	FI(T),T		;...ELSE T := FI(T)
	BR	1$		;...AND REPEAT FROM TOP
4$:	RETURN			;EXIT

	.SBTTL	FIXED WORK AREA REQUIRED BY 'SORTS':
 
SAVER4:	.WORD	0	;SAVE 'R4'
SAVESC:	.WORD	0	;SAVE 'SC'
SAVESP:	.WORD	0	;SAVE 'SP'
SORTON:	.WORD	0	;SORT UNDERWAY SWITCH
KSIZW:	.WORD	0	;SIZE OF KEY IN WORDS
KSIZB:	.WORD	0	;SIZE OF KEY, IN BYTES
MAXREC:	.WORD	0	;SIZE OF LARGEST RECORD
KEYLOC:	.WORD	0	;ADDRESS OF KEY FOR CURRENT RECORD
$SWKHI:	.WORD	0	;LAST WORK LOCATION
BIGREC:	.WORD	0	;SUM OF KEYSIZ + RECSIZ + 1 (SIZE OF A
			;  RECORD ON SCRATCH FILE
NUMFIL:	.WORD	0	;NUMBER OF SCRATCH FILES
NFLES1:	.WORD	0	;C(NUMFIL) - 1
TOPIX2:	.WORD	0	;C(NFLES2) * 2
IGNFIL:	.WORD	0	;IN PRE-SORT, THIS IS NUMBER OF FILE BEING IGNORED
CURFIL:	.WORD	0	;NUMBER OF CURRENT OUTPUT FILE
$STPX1:	.WORD	0	;C(NFLES1) * 2
NODE0:	.WORD	0	;START OF FREE CORE FOR MERGE
QSAV:	.WORD	0	;SAVE Q BETWEEN CALLS
NODE1:	.WORD	0	;ADDR OF FIRST NODE IN TREE
NOTFIR:			;SWITCH SET TO INDICATE FIRST ENTRY TO RETRN
SWITCH:	.WORD	0	;FLAG SET AFTER RUN 0
RC:	.WORD	0	;CURRENT RUN NUMBER
RQSAV:	.WORD	0	;HOLDING AREA FOR RQ BETWEEN CALLS
$SOPNF:	.WORD	0	;BECOMES NON-ZERO WHEN FIRST SCRATCH
			;  RECORD WRITTEN
LSTKEY:	.WORD	0	;ADDR OF LASTKEY BUFFER
NUMEOS:	.WORD	0	;EOS COUNTER
$SEFBF:	.WORD	EOFBIT
EOSBUF:	.WORD	EOSBIT
OUTPTR:	.WORD	HOLE	;WHERE OUTPTR GOES IF LOCATE MODE
HOLE:	.WORD	0	;'SAFE' DUMP FOR ABOVE IN CASE OF ERROR!!
;
;FIXED TABLES REQUIRED BY 'SORTS':
 
MXFLWD=MAXFIL+MAXFIL
STOADD:	.=.+MXFLWD	;AREA TO STORE 'STRINGS TO ADD'
TOTSTR:	.=.+MXFLWD	;AREA TO STORE 'TOTAL STRINGS ON FILE'
RETDUN:	.WORD	0	;RETURN DONE FLAG
	.END
