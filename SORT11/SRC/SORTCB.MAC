TITLE SORTCB,<SORT COMMAND PROCESSOR-BASE>,70,10-OCT-79,REILLY
;TITLE SORTCB,<SORT COMMAND PROCESSOR-BASE>,67,31-JAN-77,ALTMANN
;TITLE SORTC,<COMMAND STRING PROCESSOR>,56,25-OCT-76,ALTMANN
;TITLE SORTC,<COMMAND STRING PROCESSOR>,53,30-AUG-76,ALTMANN
;TITLE SORTC,<COMMAND STRING PROCESSOR>,52,1-DEC-75,RASPALLO
	.PSECT	SORTCB,OVR
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;SORT CONTROL PROGRAM - PHASE I
;
;VERSION NO.:-		V002
;			.03A
;
;THIS PHASE OF THE SORT REQUESTS AND DECODES A COMMAND
;	STRING CONTAINING THE SORT PARAMETERS. PROVIDED
;	THAT NO ERRORS ARE DETECTED, THE PRESORT IS BEGUN
;	UPON COMPLETION OF THIS PHASE.
;	ERRORS ARE REPORTED TO THE USER BY MEANS OF AN
;	APPROPRIATE MESSAGE AT THE PRINTER AND A NEW INPUT
;	IS REQUESTED.
;
;THIS VERSION ALLOWS THE PARAMETERS FOR CONTROLLING THE SORT
;	TO BE ENTERED EITHER AS SWITCHES IN THE COMMAND STRING
;	BY WHICH THE FILES ARE DESIGNATED OR THROUGH A SPECIAL
;	SPECIFICATION FILE READ & PROCESSED IN THIS SECTION.
;	SELECTIVE SORTING IS POSSIBLE ONLY UNDER THE SECOND
;	METHOD.
;
; MODIFICATIONS
;
; 70 10-OCT-79 REILLY: MAKE ALL ERROR MESSAGES BEGIN WITH '?'
;		       RSTS/E PATCH 30.2.9
;
;ON EXIT TO THE NEXT PHASE, THE PARAMETER LIST FOR THE
;	CALL TO INITIALISE THE 'SORTS' PACKAGE IS STORED
;	IN FRONT OF LOCATION 'PLIST' IN SORT.
;		R2  =	ADDRESS OF 'PROCES' IN COMM. TABLE
;		R3  =	MAXIMUM RECORD SIZE
;		R5  =	1

	.SBTTL	  MISCELLANEOUS DEFINITIONS:
 
MAXFIL=10.			;TOTAL POSSIBLE SCRATCH FILES
NUMKEY=100.			;TOTAL POSSIBLE KEYS/CHAIN
;
;
;FOLLOWING GLOBALS ARE ENTRY POINTS IN OTHER MODULES:
 
	.GLOBL	CLOSE,CRSFR2,CRDSF
	.GLOBL	CMDLNE,PRINT,PLIST
 
;FOLLOWING GLOBALS ARE ENTRY POINTS IN THIS MODULE:
 
	.GLOBL	SORTCB
	.GLOBL	CCVT,CVT,CCHKC,CCHKD,CSU1,COSW,CRPT,CRDSFX,CCSER
 
;FOLLOWING GLOBALS ARE LOCATIONS IN OTHER MODULES:
 
	.GLOBL	PHASE,PTAB,FILES
	.GLOBL	SORTP$,RCNSIZ
	WAMAC			;DEFINE WORKSPACE OFFSETS
 
;FOLLOWING GLOBALS ARE LOCATIONS IN THIS MODULE:
 
	.GLOBL	CILIN,CILINX,CILINY,NUMFLS,MAXFIL,WORKA
	.GLOBL	CPRNT,ILLKEY,KEYXS,CCSERM
	.GLOBL	KYAREA

	.SBTTL 	WORKSPACE FOR TRANSMISSION OF DATA IN OVERLAY STRUCTURE:
 
;INCNT=WA			;COUNT OF INPUT RECORDS
;OUTCNT=WA+4			;COUNT OF OUTPUT RECORDS
;MAXFLD=WA+70			;LARGEST FIELD SPECIFIED
;KEYSZE=WA+72			;TOTAL SIZE OF KEY FIELDS
;OUTSZE=WA+74			;SORTR OUTPUT SIZE
;OUTFRM=WA+76			;OUTPUT OPTION
;NORDER=WA+77			;SORT ORDER SWITCH
;CSQTAB=WA+100			;START FOR CHAR. CVT. TABLE
;ECODE=WA+102			;SORTS RETURN ERROR CODE
;SPFLSQ=ECODE
;ASSW=WA+104			;ALT COLLATION SWITCH
;PROCES=WA+105			;TYPE OF SORT
;DATLOC=WA+106			;START OF SORTS DATA AREA
;MAXPOS=WA+110			;RELATIVE END OF HIGHEST KEY
;RECSZE=WA+112			;SIZE OF INPUT RECORD
;INORG=WA+114			;INPUT FILE ORGANIZATION
;INRFM=WA+115			;INPUT RECORD FORMAT
;OUTORG=WA+116			;OUTPUT
;OUTRFM=WA+117			;OUTPUT
;KEYBLD=WA+120			;START OF KEY-BUILDER
;KEYBND=WA+122			;LAST WORD OF KEY-BUILDER
;KEYCHN=WA+124			;KEYBLD CHAIN START
;RECLOC=WA+126			;START OF RECORD BUFFER
;OUTLOC=WA+130			;START OF OUTBUFFER
;KEYBEG=WA+132			;START OF KEY STORE

	.SBTTL	  MAIN BODY
 
CPRNT:	.WORD	PRINT
CRPT:	CALL	CLOSE		;CLOSE SPEC FILE
SORTCB:	MOVB	#'C,PHASE	;SET PHASE FLAG
 
;PREPARE WORK AREA:
 
	BREAK
	MOV	FILES,NUMFLS
	MOV	#KEYCHN,SP	;INIT. WORKSPACE:-
	CLR	@SP		;	KEYBLD CHAIN
	CLR	-(SP)		;	START
	CLR	-(SP)		;	... & END
	MOV	SP,R0
	CLR	-(SP)
	CLR	-(SP)
	MOV	SP,R2
	CLR	-(SP)		;... & THE REST CLEAR
	CMP	SP,#WA
	BNE	.-6
	MOV	SP,@R0		;SAVE END OF DYNAMIC BUILD SPACE
	SUB	KYAREA,SP	;... & RESERVE ITS SPACE
	CLR	-(SP)		;CLEAR SPECIAL FILE SWITCH
	MOV	SP,R1		;HOLD KEYBUILDER START
;R0=KEYBLD (WA+120)
;R2=INORG (WA+114)
;@R0=WA
;R1=WA-KYAREA-2
;SP=R1
 
;	REQUEST COMMAND LINE
 
	JMP	CMDLNE
CCSER:	JSR	R5,@CPRNT	;ERRORS
CCSERM:	.WORD	0		;ADDR(ERROR MESSAGE)
	BR	CRPT		;AND CONTINUE WITH SORT
CRDSFX:	MOV	#2,R5		;RESET CONSTANT
	TST	@SP		;IF NOT LAST INPUT SPEC
	BNE	CCSER		;...ALSO ERROR
	JMP	CRDSF		;JUMP TO SPEC FILE PROCESSOR

.SBTTL	CHECK RESULTS SO FAR (ALL SORTS):
 
CSU1:	MOV	#NOKEYS,CCSERM	;CHECK FOR KEY ENTRY ...
	CMP	R1,SP		;... WHICH IS ESSENTIAL
	BEQ	CCSERX
	MOV	4(R0),R3	;GET KEY START IF YET KNOWN
	TST	@SP		;IF SPEC. FILE ...
	BMI	CSU1B
	TST	R3		;... CHECK FOR KEYS
	BEQ	CCSERX
	TST	4(R3)		; ... & NOT JUST DATA
	BEQ	CCSERX
	TST	@SP		;IF ALSO END OF SPEC FILE
	BNE	CSU1A
	CMP	R3,SP		;... & RECORD SPEC SEEN
	BEQ	CSU1A
	TST	@R0		; (NOT 'INCLUDE-ALL')
	BNE	CSU1A
	MOV	#NOINCL,CCSERM	;... ENSURE LAST ENTRY ...
	TSTB	-4(R3)		;... IS 'INCLUDE'
	BNE	CCSERX
CSU1A:	SUB	R1,R3		;ADJUST FOR MOVE FOLLOWING
CSU1B:	CLR	-(R4)		;SET STOPPERS
	CLR	-(R4)
	ADD	R4,R3		;... & FURTHER ADJUST IF APPROP.
	TST	(R1)+		;BUMP CURRENT KEYBLD PTR
	MOV	-(R1),-(R4)	;... & RETURN SPACE UNUSED
	CMP	R1,SP
	BNE	.-4
;SET UP FOR MORE SPEC. FILE IF NECESSARY:
	MOV	(R4)+,R1	;IF NO SPEC. FILE ...
	BPL	.+4
	MOV	R4,R3		;... THIS IS KEYBLD START
	CLR	-(R4)		;SET GENERAL CHAIN LINK
	MOV	-(R0),-(R4)	;... KEYBLD END
	MOV	R3,-(R4)	;... & START FOR THIS LINK
	MOV	R4,SP		;RESET STACK
	MOV	R0,R4		;LINK THIS CHAIN TO PREVIOUS
	MOV	R4,R3
	CMP	(R3)+,(R3)+	;... BY TRACING LINKS
	MOV	@R3,R4
	BNE	.-6
	MOV	SP,@R3
	TST	R1		;IF MORE SPECS TO DO ...
	BLT	CSU1D
	BEQ	CSU1C
	MOV	SP,@R0		;SET NEW CHAIN END
	SUB	KYAREA,SP	;ALLOW NEW SPACE
	MOV	R1,-(SP)	;RESTORE SPEC FILE SW.
	MOV	SP,R1		;... & SET PTR
	MOV	#CILIN+12.,R4	;RESET LINE PTRS
	MOV	#WORKA,R3
	JMP	CRSFR2		;... & CONTINUE PROCESSING

;FURTHER CHECKS WHEN NO MORE SPEC. FILE (IF ANY):
 
CSU1C:	CALL	CLOSE		;CLOSE DOWN SPEC FILE
CSU1D:	CMP	(R0)+,(R0)+	;ADJUST WORKSPACE PTR
	MOV	(R0)+,R4	;GET START OF BLD CHAIN
CSU1E:	DEC	R2
	MOV	-(R2),R3	;IF NO RECORD SIZE ...
	BNE	1$
	JSR	R5,@CPRNT
	.WORD	NOFORM
	JMP	CRPT
1$:
	MOV	#KEYOVR,CCSERM	;OBJECT IF END OF KEY ...
	CMP	-(R2),R3	;... OVERLAPS END OF RECORD
	BLOS	CSU2
CCSERX:	JMP	CCSER

	.SBTTL	PREPARE KEYBUILDER:
 
CSU2:	MOV	#1,R5		;NEEDED FOR LATER
	TSTB	(R3)+		;ADJUST COUNT
	CMP	-(R2),-(SP)	;LEAVE SPARE FOR OUT CRLF
	BIC	R5,R3		;MAKE RECSZE WHOLE WORDS
	SUB	R3,SP		;ALLOCATE SPACE FOR RECORD
	MOV	SP,2(R0)	;SAVE ITS START AS A BASE ...
CSU3:	MOV	SP,@R0		;... & MARKER START
	CLR	@R2		;CLEAR KEY SIZE COUNT
	MOV	(R4)+,KEYBLD	;SET CONTROLS FOR CHAIN
	MOV	(R4)+,KEYBND
	MOV	(R4)+,@SP	;... & SAVE LINK TO NEXT
CSU3A:	CMP	(R4)+,KEYBND	;TEST IF CONSTANT/COMPARE
	MOV	(R4)+,R1	;... & IF NOT A STOPPER
	BEQ	CSU3D		;... BECAUSE NO SIZE
	BHIS	.+6		;... OMIT NEXT IF FOUND
	ADD	SP,-4(R4)	;MAKE START ADDRESS ABSOLUTE
	TST	(R4)+		;... & IF NOT YET KEYS
	CMP	R4,KEYBLD
	BLOS	CSU3C		;... OMIT NEXT
	TSTB	-(R4)		;GET ROUTINE CODE
	BPL	.+6		;... & IF FORCED
	MOVB	-1(R4),R1	;... ADJUST SIZE (0 IF CONT)
	ADD	R1,@R2		;BUILD FULL KEY TOTAL
	DECB	@R4		;IF KEY IS NOT BINARY
	BLE	CSU3B		; (I.E. C, Z OR P DATA)
	CMPB	@R4,#2		;... THIS SIZE O.K.
	BEQ	CSU3B		;FOR D DATA ...
	BGT	.+6		;... REAL KEY SIZE IS FIXED
	MOV	#8.,R1		;FOR D, B OR F DATA ...
				;CHECK FOR "I", "J", "K"
	CMPB	@R4,#10
	BEQ	1$
	CMPB	@R4,#11
	BEQ	1$
	CMPB	@R4,#12
	BNE	2$
1$:	MOV	#8.,R1
2$:
	BIC	R5,@R0		;... ENSURE WORD-BOUND
CSU3B:	INCB	(R4)+
	SUB	R1,@R0		;RESERVE SPACE FOR KEY
CSU3C:	MOVB	-(R4),R1	;DETERMINE CONVERSION REQD
	ASL	R1
	ADD	#PTAB+2,R1
	CLRB	@R4		;... & ADJUST IF SEQ. DESC.
	ASLB	-(R4)
	ADD	@R1,(R4)+	;STORE RESULT AS THREAD

.SBTTL	CHECK FOR MORE BUILDER CHAINS & CLEAN-UP:
 
CSU3D:	TST	-4(R4)		;IF JUST SEEN REAL KEYEND
	BNE	.+6		;... STOP FURTHER ACCUMULATION
	MOV	@PC,KEYBLD	;... IN CASE OUT SPECS FOLLOW
	CMP	R4,KEYBND	;IF ALL ENTRIES DONE ...
	BLO	CSU3A
	COM	-(R4)		;SET CHAIN DELIMITER
	MOV	KEYSZE,-(SP)	;IF KEY SIZE DECLARED IN SPEC
	BNE	.+4
	MOV	@R2,@SP
	MOV	#KEYXS,CCSERM	;... COMPLAIN IF EXCEEDED
	CMP	@SP,@R2
CCSERJ:	BLO	CCSERX
	MOV	(SP)+,@R2	;OTHERWISE HOLD FOR LATER
	CMP	(R0)+,@R0	;ALSO DETERMINE MAX ACTUAL SIZE
	BHIS	.+6
	MOV	-2(R0),@R0
	MOV	@R0,-(R0)	;... & SAVE RESULT
	MOV	@SP,R4		;IF MORE CHAINS ...
	BNE	CSU3		;... REPEAT
	MOV	@R2,R4		;OTHERWISE HOLD FULL KEY SIZE
	INC	R4		;... AS WORDS
	BIC	R5,R4
	MOV	SP,R1		;HOLD RECORD START
	BIC	R5,@R0		;... & SET STACK AT KEY START
	MOV	@R0,SP
	MOV	R1,(R0)+	;STORE RECORD START ...
	MOV	R1,(R0)+	;... & POSSIBLE OUTBUFF START
	TSTB	OUTFRM		;IF VARIABLE OUTPUT ...
	BEQ	CSU3E
	CMP	-(R1),-(SP)	;... ALLOW EXTRA WORD
	TST	(R3)+		;... FOR OUTBUFF PTR
CSU3E:	MOV	R1,@R2		;STORE START OF SORTS DATA
	MOV	R1,@R0		;IS ALSO START FOR KEYS

.SBTTL	ENTER PARAMETERS FOR CALL TO 'RSORT':
 
	MOV	#PLIST,R0	;SET LIST POINTER
	MOV	R1,-(R0)	;COMPUTE REAL KEY SIZE TOTAL
	SUB	SP,@R0
	MOV	R4,KEYSZE	;SAVE FULL KEY SIZE
	TSTB	-(R2)		;IF NOT SORTR ...
	BEQ	CSU4
	MOV	R4,R3		;... FULL KEY MAY BE SORT DATA
	CMPB	(R2)+,#3	;... OR IF NOT SORTI ...
	BEQ	.+4
	CLR	R3		;... JUST RECORD #
	ADD	RCNSIZ,R3	;ADD IN SIZE OF RECORD NUMBER
	TSTB	OUTFRM		;... & PERHAPS OUTBLD PTR
	BEQ	.+4
	TST	(R3)+
	SUB	R3,SP		;RESERVE SPACE FOR SMALLER DATA
	MOV	SP,@R2		;... & STORE ITS START
	CMPB	-(R2),R5	;OMIT NEXT IF SORTA/SORTI
	BNE	CSU4A
CSU4:	MOV	OUTSZE,@SP	;RESERVE SPACE FOR OUT BUFFER
	BEQ	CSU4B		;... IF ANY NEEDED
	NEG 	@SP
	ADD	R1,@SP		;... FROM RECORD BUFF START
	BIC	R5,@SP
	CMP	SP,@SP		;MAKE EXTRA ROOM IF NEC.
	BLOS	.+4
	MOV	@SP,SP
CSU4A:	MOV	SP,OUTLOC	;... & REMEMBER START
	MOV	R1,@SP		;SIMILARLY ALLOW BUFFER
	SUB	MAXFLD,@SP	;... FOR COMPARE FIELDS
	BIC	R5,@SP
	CMP	SP,@SP		;... IF INSUFFICIENT ALRDY
	BLOS	.+4
	MOV	@SP,SP
CSU4B:	MOV	@R0,R4		;HOLD REAL KEY SIZE
	MOV	R1,-(SP)	;... & DEFINE KEY AREA
	SUB	R4,@SP
	MOV	(SP)+,MAXFLD	;REMEMBER ITS BOTTOM
	MOV	R3,-(R0)	;STORE DATA SIZE
	CMP	-(SP),-(R1)
	MOV	R1,-(R0)	;... KEY START,
	MOV	SP,WORKHI	;SET WORK HIGH
	MOV	NUMFLS,-(R0)	;SET NUMBER OF FILES
	JMP	SORTP$		;JUMP TO PRE SORT PHASE
 

.SBTTL	  A)  SWITCH PROCESSING ANCILLARIES:
.SBTTL	1)  CHARACTER SEARCH:
;	CALL:	JSR	R5,CCHKC
;		.WORD	(CHARACTER STRING)
;	EXPECTS R3 TO POINT AT CORRECTLY SET UP BUFFER;
;	PRECEDING WORD TO BE POINTER TO INPUT BYTE (AS
;	VALUE PTR,SWITCH NAME). STRING SHOULD BE TERMINATED
;	BY 0 BYTE [RETURN TO CALLER IF INPUT NOT FOUND] OR
;	NEGATIVE BYTE [TAKE ERROR EXIT IF INPUT NOT FOUND]
;	EXITS WITH RELATIVE TABLE POSITION OF BYTE IN BUFFER
;	& POINTER BUMPED. ALSO TAKES ERROR EXIT IF POINTER
;	IS INVALID (I.E. NO VALUE ENTERED)
CCHKC:	MOV	R0,-(SP)	;FREE UP WORKING REGISTER
	MOVB	@-(R3),-(SP)	;GET INPUT BYTE
	CMP	@R3,CILINX	;VALID PTR?
	BLO	CCHKER
	INC	(R3)+		;BUMP PTR FOR NEXT TIME
CCHKCL:	MOVB	(R5)+,R0	;GET TABLE BYTE
	BEQ	CCHKCD		;EXIT IF LAST IN STRING
	BIC	#200,R0		;FORGET SIGN FOR THE MOMENT
	CMPB	R0,@SP		;IF THIS NO MATCH ...
	BEQ	CCHKCM
	INC	@R3		;... COUNT CHARS TESTED
	TST	R0		;IF NO MORE IN TABLE ...
	BPL	CCHKCL
CCHKER:	MOV	#CSWER,R5	;... TAKE ERROR EXIT
	BR	CCHKCX
CCHKCD:	CLRB	@R3		;IF TABLE ENDS 0 CLEAR COUNT
	DEC	-2(R3)		;... & PMUB PTR
CCHKCM:	DEC	R5		;IF CHAR FOUND ...
	TSTB	(R5)+		;... FIND TABLE END
	BGT	.-2
CCHKCX:	TST	(SP)+		;CLEAN UP STACK
	MOV	(SP)+,R0
	RTS	R5

CSWER:	TST	(R5)+		;FOR ANY ERROR TAKE EXIT + 2
	RTS	R5

.SBTTL	2)  CHECK FIELD SIZE AGAINST DATA MODE:
;	CALL:	JSR	R5,CCHKD
;	ASSUMES THAT R1 POINTS AT SIZE AS STORED IN THE
;	KEYBUILDER ELEMENT ON ENTRY; ON EXIT R1 IS BUMPED
;	TO THE DATA MODE ELEMENT. EXITS ARE TAKEN AS:-
;		CALL+2:-	ERROR DETECTED
;		CALL+4:-	NO PROBLEM
CCHKD:	MOV	(R1)+,-(SP)	;GET SIZE & MODE
	MOV	(R1)+,@R1	;IF C MODE ...
	SWAB	@R1
	BEQ	CCHKD3		;... NO REAL PROBLEM
	DECB	@R1		;IF Z MODE ...
	BNE	CCHKD1
	DEC	@SP		;... ONLY 1 CHAR. ALLOWED
	BR	CCHKD2
CCHKD1:	DECB	@R1		;ALSO NO PROBLEM IF D
	BEQ	CCHKD3
	CMPB	@R1,#7		;NO PROBLEM IF 'I','J','K'
	BEQ	CCHKD3
	CMPB	@R1,#10
	BEQ	CCHKD3
	CMPB	@R1,#11
	BEQ	CCHKD3
	CMP	@SP,#8.		;MAX SIZE - ALL OTHERS
	BGT	CCHKD5
	DECB	@R1		;FOR B OR F MODES ...
	BEQ	CCHKD4
	ASR	@SP		;... SIZE MUST BE EVEN
	BCS	CCHKD5
	ASR	@SP		;... & MUST BE 4 OR 8
	BCC	CCHKD4
	DECB	@R1		;... FOR F ONLY
CCHKD2:	BNE	CCHKD5
CCHKD3:	SWAB	@SP		;AS FINAL CHECK ...
	BNE	.+4		;... SIZE<256 O.K.
CCHKD4:	TST	(R5)+		;IF O.K., BUMP RETURN
CCHKD5:	CMP	(SP)+,-(R1)	;IF ERROR, ADJUST PTRS
	RTS	R5		;... & EXIT

.SBTTL	3)  CONVERT VALUE TO BINARY:
;	CALL:	JSR	R5,CCVT
;	EXPECTS R3 TO POINT TO A BUFFER FOR RESULT WITH
;	A POINTER IN THE PRECEDING WORD. IF NO POINTER
;	EXISTS, TAKES ERROR EXIT
CCVT:	MOV	-(R3),-(SP)	;SET UP D2BIN REQUEST
	MOV	#2,-(SP)
	CMP	(R3)+,CILINX	;VALID PTR?
	BLO	CCVTER		;... CANNOT GO ON
	CALL	CVT
	BVS	CCVTER		;IF CONVERSION OVERFLOW TOO MUCH
	MOV	(SP)+,@R3	;STORE RESULT ...
	MOV	(SP)+,-2(R3)	;... & POINTER FOR NEXT TIME
	RTS	R5
CCVTER:	MOV	2(SP),-(R3)	;FOR ERROR, SAVE POINTER
	MOV	R0,2(SP)	;... & SET UP FOR ...
	BR	CCHKER		;... SIMULATE CCHKC EXIT

.SBTTL	4)  CONVERT DECIMAL OR OCTAL ASCII TO BINARY
;CALL:	JSR	PC,CVT
;INPUT:		SP+4=NEXT BYTE ADDR
;		SP+2=#2 FOR DECIMAL, #4 FOR OCTAL
;		SP=SAVED PC
;OUTPUT:	SP+4=NEXT BYTE ADDR
;		SP+2=BINARY VALUE
;		C-BIT SET IF ILLEGAL CHR FOUND
;		V-BIT  SET IF OVERFLOW
CLCCLV=243			;CLC!CLV
CVT:	CALL	STM0T4
	MOV	4(SP),R0	;BYTE STRING ADDR
	CMP	#2,2(SP)	;DECIMAL OR OCTAL CONVERSION?
	BNE	3$
	CALL	CDTB
	BR	4$
3$:	CALL	COTB
4$:	MOV	R0,4(SP)	;ADDR OF NEXT BYTE
	MOV	R1,2(SP)		;CONVERTED VALUE
	TST	R3		;ERROR IN CONVERSION?
	BNE	1$		;... YES
	CALL	LM0T4		;NORMAL EXIT
	CLCCLV			;CLEAR C-BIT AND V-BIT
	RTS	PC
1$:	DEC	R3		;ILLEGAL CHR ERROR? (R3=1)
	BNE	2$
	CALL	LM0T4
	SEC			;... YES
	CLV
	RTS	PC
2$:	CALL	LM0T4		;OVERFLOW ERROR (R3=2)
	CLC
	SEV
	RTS	PC

;
;INPUTS:	R0=ADDR OF NEXT BYTE
;OUTPUTS:	R0=ADDR OF NEXT BYTE
;		R1=VALUE
;		R2=CLOBBERED
;		R3=0 IF O.K.
;		   1 IF ILLEGAL CHR
;		   2 IF OVERFLOW
;		R4=CLOBERRED
COTB:	MOVB	#'7,CNTRL
	MOV	#8.,R2		;BASE 8 RADIX
	BR	CDTB0
CDTB:	MOVB	#'9,CNTRL
	MOV	#10.,R2		;BASE 10. RADIX
CDTB0:	MOV	#5,R3		;5 CHRS MAX CONVERTED
	CMP	R2,#10.
	BEQ	1$
	INC	R3		;CHARS TO CONVERT IF OCTAL RADIX
1$:
	CLR	R1		;CLEAR ACCUMULATOR
2$:	MOVB	(R0)+,R4	;GET NEXT BYTE
	CMPB	CNTRL,R4	;TOO LARGE?
	BLO	3$
	CMPB	CNTRL+1,R4	;TOO SMALL?
	BHI	3$
	MOV	R0,-(SP)	;SAVE NEXT CHR ADDR
	MOV	R2,R0		;SET CONVERSION RADIX
	CALL	MUL
	TST	R0		;OVERFLOW? (HI RESULT)
	BNE	5$
	MOV	(SP)+,R0	;RETREIVE NEXT CHR ADDR
	SUB	#'0,R4		;SUBTRACT CHR BIAS
	ADD	R4,R1		;ACCUMULATE RESULT
	DEC	R3		;5 CHRS CONVERTED?
	BNE	2$		;... CONTINUE
	RTS	PC		;NORMAL EXIT (R3=0)
3$:	MOV	#1,R3		;ILLEGAL CHR EXIT
	TSTB	-(R0)		;BACK-UP BYTE POINTER TO ILLEGAL CHR
	RTS	PC
5$:	MOV	(SP)+,R0	;RETREIVE NEXT CHR ADDR
	MOV	#2,R3		;OVERFLOW EXIT
	RTS	PC
CNTRL:	.BYTE	'9,'0
;

;INPUTS:	R0=MULTIPLIER
;		R1=MULTIPLICAND
;OUTPUT:	R0=HIGH HALF OF RESULT
;		R1=LOW HALF OF RESULT
MUL:	MOV	#17.,-(SP)	;SET REPEAT COUNT
	MOV	R0,-(SP)	;SAVE MULTIPLIER
	CLR	R0		;CLEAR HIGH PART OF RESULT
1$:	CLC			;CLEAR CARRY
	ROR	R0		;DOUBLE RIGHT SHIFT
	ROR	R1
	BCC	2$		;IF CC NO ADD
	ADD	(SP),R0		;ADD IN  MULTIPLIER
2$:	DEC	2(SP)		;REPEAT?
	BGT	1$
	CMP	(SP)+,(SP)+	;CLEAN STACK
	RTS	PC

.SBTTL		V)  KEY SPECIFICATION:
;	EXITS WITH RESULT OF SUCCESSFUL SEARCH IN R5
COSW:	JSR	R5,CCHKC	;GET KEY CODE
	.BYTE	'D,'F,'N,'O+200
	MOV	@R3,4(SP)	;SET INTO R5 ON EXIT
	RTS	R5
;
;	REGISTER SAVE ROUTINES
;
STM0T4:	MOV	R4,R4X
	MOV	R3,R3X
STM0T2:	MOV	R2,R2X
	MOV	R1,R1X
	MOV	R0,R0X
	RTS	PC
LM0T4:	MOV	R4X,R4
	MOV	R3X,R3
LM0T2:	MOV	R2X,R2
	MOV	R1X,R1
	MOV	R0X,R0
	RTS	PC
R0X:	0
R1X:	0
R2X:	0
R3X:	0
R4X:	0

.SBTTL	DATA BLOCKS:
 
;  A)  KEYBOARD CONTROL BLOCKS & BUFFERS:
CCMDB:	.=.+14.			;ANALYSER BUFFER
CILINX:	.WORD	0
CILINY:	.WORD	0
CILIN:	.WORD	84.,0,0		;COMMAND STRING INPUT BUFFER
	.=.+84.
NUMFLS:	.WORD	4
;
WORKA:	.BLKW	50.		;WORK AREA FOR SWITCH USAGE
KYAREA:	.WORD	NUMKEY+NUMKEY+NUMKEY	;AREA FOR KEYS

.SBTTL	MESSAGES
 
	STRNG	KEYXS,<?TOO MANY KEYS>
	STRNG	NOKEYS,<?NO KEYS SPECIFIED>
	STRNG	NOINCL,<?LAST RECORD SPEC NOT 'I'>      ;*70* FORCE '?'
	STRNG	KEYOVR,<?KEY AFTER LAST BYTE OF RECORD>
	STRNG	NOFORM,<?NO /FO SWITCH>
	STRNG	ILLKEY,<?ILLEGAL KEY>

	.SBTTL	SPECIAL PSECT FOR OVERLAYING
	 
	.PSECT	SORTCX,GBL,OVR
	.GLOBL	SORTCX,SORTCB
SORTCX:	JMP	SORTCB
;
;	THIS PSECT NECESSARY TO PREVENT AUTO LOAD REFERNECES
;	TO DATA ITEMS.
;
	.END
