TITLE SIORMS,<I/O ROUTINES FOR SORTS>,32,10-OCT-79,REILLY
;TITLE SIORMS,<I/O ROUTINES FOR SORTS>,27,05-MAR-77,ALTMANN
	.PSECT	SIORMS,OVR
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;
;PDP-11 SORT SUBROUTINE PACKAGE:
;		I/O DEPENDENT ROUTINES FOR THE SORTS MODULE
;
;
;VERSION NO:	 V002
;
;MODIFICATIONS
;
; 30 10-OCT-79 REILLY: USED $INITIF INSTEAD OF $INIT BECAUSE OF USER INTERFACE
;	               RSTS/E PATCH 30.2.1
;
; 31 10-OCT-79 REILLY: FIX FOR VERY LARGE FILES
;		       RSTS/E PATCH 30.2.4
;
; 32 10-OCT-79 REILLY: FIX RMS POOL PROBLEM WHEN SIORMS IS A CALLABLE SUB.
;		       RSTS/E PATCH 30.2.6
;

;FOLLOWING GLOBALS REFERENCE LOCATIONS IN OTHER MODULES:
 
	.GLOBL	$SOPNF,$STPX1,$SEFBF 
 
;FOLLOWING GLOBALS ARE LOCATIONS IN THIS MODULE:
 
	.GLOBL	$RMLBF,$RFIRL,$RBGBF,$RSCLV,$RSCTG
	.GLOBL	$RPALQ,$RSALQ,$RRAH,$RWBH,$RXBFA
 
;FOLLOWING GLOBALS ARE ENTRY POINTS IN THIS MODULE:
 
	.GLOBL	$RREAD,$RWRIT,$RCLOS,$RREWI
	.GLOBL	$RALBK,$RMRGA,$REOSS,$REOFS,$RRTBK
;FOLLOWING GLOBALS ARE ENTRY POINTS IN OTHER MODULES:
 
	.GLOBL	$SKILL,$SDIVD,$SMULT
 
	SC=%5

;MISCELLANEOUS CONSTANTS

	MAXFIL=10.	;MAXIMUM NUMBER OF SCRATCH FILES

	$RRAH=500	;READ AHEAD & LOCATE MODE BIT
	$RWBH=1000	;WRITE BEHIND

	EOSBIT=100000	;FLAG IN FIRST WORD OF SCRATCH RECORD
			;  TO SIGNIFY 'END OF STRING'
	EOFBIT=040000	;LIKEWISE TO SIGNIFY 'END OF FILE'
 
	BADRED=1	;BAD READ ON INPUT
	BADWRT=2	;BAD WRITE ON OUTPUT
	OPNIF=3		;BAD OPEN FOR INPUT
	OPNOF=4		;BAD OPEN FOR OUTPUT

;I/O DEFINITIONS
 
	.MCALL	$INITIF,$RBCAL,$FBCAL,$GNCAL
	.MCALL	FAB$B,RAB$B,$RMSTAT,IFAOF$,IRAOF$,BDBOF$
	.GLOBL	$RTNCB,$ALNCB
	$RBCAL	
	$FBCAL
	$GNCAL
	$RMSTAT	DFIN$L
	IFAOF$	RMS$L
	IRAOF$	DEF$SZ
	BDBOF$	DEF$SZ
 

	.SBTTL	A) - '$RWRIT' - PUT A RECORD INTO THE BUFFER
 
;ON ENTRY R1==>RECORD TO BE WRITTEN
;	  R4 = FILE INDEX
 
$RWRIT:	MOV	R2,-(SP)	;SAVE REGS
	MOV	R3,-(SP)
	TST	$SOPNF		;ANY FILES OPEN?
	BNE	5$		;NO, THEN
	CALL	OPENS		;...GO OPEN THEM
5$:	TST	EOSFLG(R4)	;IS FILE AT END OF STRING?
	BEQ	1$		;NO, CONTINUE NORMAL PROCESSING
	CALL	RED1BK		;YES, WE MUST WRITE INTO PARTIAL BLOCK
1$:	MOV	R1,R0		;SET R0==>RECORD
	MOV	BUFPTR(R4),R1	;SET R1==>NEXT REC PTR
	MOV	EOBUF(R4),R3	;SET R3==>END OF BUFFER
	MOV	R1,R2		;SET UP FOR...
	ADD	SRECSZ,R2	;...R2==>NEXT REC PTR
	CMP	R2,R3		;IS THE RECORD WHOLLY WITHIN THE BUFFER?
	BHI	3$		;NO
2$:	MOV	(R0)+,(R1)+	;YES, MOVE IT IN
	CMP	R1,R2		;...UNTIL
	BLO	2$		;...DONE
	CMP	R2,R3		;COMPLETELY FILL BUFFER?
	BLO	4$		;NO, LEAVE NOW
	CALL	WRTBUF		;YES, WRITE IT OUT...
	MOV	SOBUF(R4),R2	;...& UPDATE NEXT REC PTR
	BR	4$		;...& LEAVE
;
3$:	MOV	(R0)+,(R1)+	;MOVE RECORD INTO BUFFER
	CMP	R1,R3		;... UNTIL END OF BUFFER
	BLO	3$
	CALL	WRTBUF		;...THEN DUMP IT
	SUB	LRGBUF,R1	;...& UPDATE POINTERS
	SUB	LRGBUF,R2	;...DITTO
	CMP	R2,R3		;NOW SEE IF MORE TO COME
	BHI	3$		;YES, MORE THAN ONE BLOCK, REPEAT
	BR	2$		;YES, BUT ONLY A PARTIAL BLOCK
;
4$:	MOV	R2,BUFPTR(R4)	;SET NEXT RECORD POINTER
	MOV	(SP)+,R3	;RESTORE REGS
	MOV	(SP)+,R2
	RETURN			;RETURN

	.SBTTL	B) - '$RREAD' - GET A RECORD FROM BUFFER
 
;ON EXIT  R1==>RECORD
 
$RREAD:	MOV	R2,-(SP)	;SAVE REGS
	MOV	R3,-(SP)
	MOV	BUFPTR(R4),R1	;R1==>RECORD POINTER
	MOV	EOBUF(R4),R3	;R3==>END OF BUFFER
	CMP	R1,R3		;DO WE NEED TO GET A NEW BUFFER?
	BNE	1$		;NO
	CALL	REDBUF		;YES, DO IT
	MOV	SOBUF(R4),R1	;...& UPDATE POINTER
1$:	MOV	R1,R2		;SET UP FOR
	ADD	SRECSZ,R2	;...END OF RECORD POINTER
	CMP	R2,R3		;IS THE RECORD WHOLLY WITHIN THE BUFFER?
	BLOS	4$		;YES, LEAVE SINCE LOCATE MODE
	MOV	TABUBF(R4),R0	;NO, WE MUST USE AUX REC BUF
2$:	MOV	(R1)+,(R0)+	;MOVE IN THE RECORD
	CMP	R1,R3		;...UNTIL...
	BLO	2$		;...THE END OF THE BUFFER
	CALL	REDBUF		;...& GET ANOTHER
	SUB	SMLBUF,R1	;...RESET POINTERS
	SUB	SMLBUF,R2	;...(BOTH)
	CMP	R2,R3		;IS RECORD NOW WITHIN ONE BUFFER?
	BHI	2$		;NO, REPEAT ON WHOLE BUFFER
3$:	MOV	(R1)+,(R0)+	;YES, FINISH PARTIAL BUFFER
	CMP	R1,R2		;...UNTIL...
	BLO	3$		;...DONE
	MOV	TABUBF(R4),R1	;SET RECORD POINTER TO AUX BUFFER
4$:	MOV	R2,BUFPTR(R4)	;SET NEXT RECORD POINTER
	MOV	(SP)+,R3
	MOV	(SP)+,R2
	RETURN

	.SBTTL	C) - '$RCLOS' - CLOSE ALL SCRATCH FILES
 
$RCLOS:	MOV	$STPX1,R4
	MOV	#PROFAB,R0		;R0==>PROTO FAB
	MOV	#FABPAR,R5		;R5==>PARM BLOK
1$:	$STORE	TABIFI(R4),IFI,R0	;SET FILE ID
	$CLOSE				;CLOSE IT
	SUB	#2,R4
	BGE	1$
	CLR	$SOPNF			;RESET OPEN FLAG
	RETURN

	.SBTTL	D) - '$RREWI' - REWINDS A SCRATCH FILE TO BYTE 0, BLOCK 1
 
;ON ENTRY	R4 = FILE INDEX
;		R5 = RAH OR WBH
 
$RREWI:
	ASL	R4			;SET UP FOR DOUBLE WORD
	MOV	#1,LSTBLK(R4)		;RESET BLOCK POINTER TO START
	CLR	LSTBLK+2(R4)		;CLEAR HIGH ORDER
	ASR	R4			;RESET
	CMP	R5,#$RWBH		;REWIND FOR WRITTING?
	BNE	1$			;NO
;
;	REWIND FOR   W R I T I N G 
;
	MOV	R3,-(SP)		;SAVE
	MOV	PRVOUT,R3		;PICK UP PREVIOUS OUT FILE INDX
	MOV	SOBUF(R3),R5		;EXCHANGE IT
	MOV	SOBUF(R4),SOBUF(R3)	;...AND...
	MOV	R5,SOBUF(R4)		;...CURRENT FILE
	MOV	R5,BUFPTR(R4)		;& SET INITIL REC POINTER
	MOV	EOBUF(R4),R5		;DITTO FOR EOBUF
	MOV	EOBUF(R3),EOBUF(R4)
	MOV	R5,EOBUF(R3)
	MOV	R5,BUFPTR(R3)		;& SET INITIL REC POINTER
	MOV	(SP)+,R3		;RESTORE
	BR	2$
;
;	REWIND FOR   R E A D I N G
;
1$:	MOV	EOBUF(R4),BUFPTR(R4)	;READING-SET TO GET A BUFFER
	MOV	R4,PRVOUT		;SET THIS AS PREVIOUS OUTPUT FILE
2$:	RETURN				;THAT'S IT

	.SBTTL	E) - '$REOSS' - SPECIAL END OF STRING-PASS 1 PROCESSING
 
;ON ENTRY R4 = FILE INDEX OF EOS FILE
 
;ALL REGISTERS MUST BE PRESERVED!!!
 
$REOSS:	MOV	BUFPTR(R4),R5		;PICK UP THE CURRENT BUFPTR
	SUB	SOBUF(R4),R5		;HOW MUCH TEXT?
	CMP	R5,SRECSZ		;IS IT MORE THAN ONE RECORD?
	BLO	1$			;NO, SO IGNORE IT
	BIC	#511.,R5		;YES, FIND NEXT EVEN BLOCKS
	SUB	R5,BUFPTR(R4)		;RESET TO 1ST BLOCK
	ADD	#512.,R5		;ROUND UP TO NEXT BLOCK BOUNDARY
	CALL	WRTBF1			;...& WRITE OUT ONLY THAT MUCH
	ASL	R4
	SUB	#1,LSTBLK(R4)		;BUT INDICATE PARTIALLY FULL
	SBC	LSTBLK+2(R4)
	ASR	R4
	INC	EOSFLG(R4)		;SET PARTIAL BUFF FLAG
1$:	RETURN

	.SBTTL	F) - '$REOFS' - WRITE EOF ON FILE
 
;ON ENTRY R4 = FILE INDEX
 
;R2,R3 MUST BE PRESERVED!!!!
 
$REOFS:	MOV	#$SEFBF,R1	;SET UP FOR WRITE
	CALL	$RWRIT		;WRITE IT OUT
	CALL	$REOSS		;CHECK FOR PARTIAL BUFFERS
	CLR	EOSFLG(R4)	;CLEAR PARTIAL BUF FLAG
	RETURN

	.SBTTL	G) - '$RALBK' - ALLOCATE FILE BLOCKS
 
;ON ENTRY R0 = 'BIGREC' SIZE + ANY EXTRAS
;	  R1 = HI CORE LIMIT
;	  R2 = LO CORE LIMIT
;	  R3==>'NUMFIL':NUMBER OF FILES USER SPECIFIED
;	  R4 = SCRATCH RECORD SIZE
 
;ON EXIT  R0 = UPDATED NUM OF FILES
;	  R2==>END OF ALL I/O AREAS IN WORKSPACE
 
;R3, R4   MUST NOT BE CHANGED!!!!!
 
;EACH FILE REQUIRES 1 IFAB, 1 BDB, AND 1 IRAB
;     PLUS $RBGBF * 512. FOR THE ROTATING BUFFER
 
	FSPACE=IF$BLN+BD$BLN+IR$BLN
 
$RALBK:	$INITIF			;*30* CONITIONAL INIT
	MOV	R1,$RXBFA	;SET BUFFER ADDRESS
	TST	@R3		;IF IN-CORE ONLY...
	BEQ	6$		;SKIP ALL THIS
	PUSH	R4		;NEEDED FOR SCRATCH USAGE
	MOV	R4,SRECSZ	;SET SCRATCH RECORD SIZE
	PUSH	R0		;HOLD FOR LATER
	PUSH	R1		;DITTO
1$:	MOV	#FSPACE,R0	;MOVE IN CONSTANT SPACE
	MOV	$RBGBF,R1	;NOW FOR BUFFER SPACE
	BNE	11$		;NO USER VALUE,SO...
	MOV	@SP,R1		;...CALC DEFAULT AS...
	SUB	R2,R1		;...HALF OF AVAILABLE...
	ASR	R1		;...SPACE.
	BIC	#100777,R1	;ROUND TO LOWER BLOCK
	ASR	R1		;DIV BY 2
	SWAB	R1		;NOW BY 256
11$:	MOV	R1,SMLBLK	;SET NUMBER OF BLOCKS
	MOV	R1,LRGBLK	;DITTO
	SWAB	R1		;MULT BY 256.
	ASL	R1		;NOW BY 512.
	MOV	R1,SMLBUF	;SIZE OF THE MAIN BUFFER
	MOV	R1,LRGBUF	;DIITO FOR 1ST PASS
	ADD	R1,R2		;TEMPORARILY, ADD IN FOR CORE CHECK
	MOV	(SP)+,R1	;RESTORE HI CORE PTR
	ADD	(SP)+,R0	;AMOUNT NEEDED PER FILE WITH POINTERS
	BVS	4$		;TOO BIG, ERROR OUT
	CLR	R4		;CLEAR FILE COUNTER

2$:	SUB	R0,R1		;DROP HI CORE BY AMOUNT PER FILE
	CMP	R2,R1		;HAVE WE DROPPED BELOW LO CORE?
	BHI	4$		;YES, ERROR (UNSIGNED,ADDRESS ARITH!!!!)
	INC	R4		;NO, WE'RE OKAY THIS ROUND
	CMP	R4,@R3		;REACHED CALLER'S MAX YET?
	BGE	5$		;YES, ALL IS IN ORDER
	BR	2$		;NO, TRY AGAIN
3$:	CMP	R4,#3		;ABOVE THE MINIMUM?
	BGE	5$		;YES, GO WITH THIS NUMBER
4$:	MOV	#6,R0		;NO, SET UP ERROR
	JMP	$SKILL		;AND EXIT (SP IS RESET THERE)

5$:	PUSH	R3		;DESTROYED BY MULT!!!
	MOV	R4,@R3		;UPDATE NUMFIL
	SUB	SMLBUF,R2	;RESET CORE POINTER, SO FILE INTERNALS
				;WILL BE BELOW BUFFERS
	PUSH	R2		;SAVE CORE POINTER
	MOV	#IF$BLN,R0	;R0 = SIZE OF IFAB
	MOV	R4,R1		;RECOVER NUMFIL
	CALL	$SMULT		;R0 := R0 * R1
	ADD	R0,@SP		;UPDATE CORE POINTER
	MOV	R0,R1		;SET UP FOR NEXT CALL
	MOV	R2,IFSTRT	;*32* SAVE FOR RETBLK
	MOV	#IF$BLN,R0	;DITTO
	CALL	$RTNCB		;GIVE TO RMS
;
	MOV	#IR$BLN,R0	;SET SIZE OF NEXT BLOCK
	MOV	R4,R1		;RECOVER NUMFIL
	CALL	$SMULT		;$SMULTIPLY
	MOV	@SP,R2		;RECOVER POINTER
	ADD	R0,@SP		;UPDATE CORE POINTER
	MOV	R0,R1		;SET UP
	MOV	R2,IRSTRT	;*32* SAVE FOR RETBLK
	MOV	#IR$BLN,R0	;SET UP
	CALL	$RTNCB		;GIVE TO RMS
;
	MOV	#BD$BLN,R0	;SIZE OF BLOCK
	MOV	R4,R1		;RECOVER NUMFIL
	CALL	$SMULT		;MULTIPLY
	MOV	@SP,R2		;RECOVER R2
	MOV	R2,BDSTRT	;SAVE FOR RELEASE
	ADD	R0,@SP		;UPDATE CORE POINTER
	MOV	R0,R1		;SET UP
	MOV	#BD$BLN,R0	;SET UP
	CALL	$RTNCB		;GIVE TO RMS
;
	POP	R2		;RECOVER R2
	MOV	R2,BUFSTR	;SET START OF BUFFER AREA
	MOV	R2,SOBUF	;SET INTO TABLES
	ADD	SMLBUF,R2	;SET ASIDE SPACE FOR MAIN BUFFER
	MOV	R2,EOBUF	;SET IT INTO TABLES
	POP	R3		;RECOVER R3
	POP	R4		;RECOVER R4
6$:	RETURN

	.SBTTL	H) - '$RMRGA' - REALLOCATE CORE FOR MERGE PHASE
 
;ALLOCATE NUMFIL RECORD BUFFERS FOR LOCATE MODE GETS & ANY BIG BLOCKING 
;SETS ADDRESSES IN RECBUF TABLE
 
$RMRGA:	MOV	#$STPX1,R2	;SET PTR TO WORK DATA
	MOV	(R2)+,R4	;COLLECT LAST FILE INDEX
	MOV	R4,-(SP)	;SAVE FOR LATER
	MOV	BUFSTR,R1	;...& START OF BUFFER SPACE
	SUB	#16.,R2		;...ADJUST PTR
	MOV	(R2)+,R0	;...TO GET TOP OF WORKAREA
	MOV	(R2)+,R3	;...SCRATCH RECORD SIZE
4$:	MOV	R1,TABUBF(R4)	;SET UP TABLE OF RECORD AREA
	ADD	R3,R1		;...& UP SPACE NEEDED
	SUB	#2,R4		;...FOR EACH FILE
	BGE	4$		;...REPEAT
	MOV	R0,R5		;SAVE TOP OF CORE
	SUB	R1,R0		;SIZE OF FREE AREA LEFT
	MOV	R1,R4		;SAVE CORE POINTER
	MOV	@R2,R1		;R1 = NUMFIL
	ASL	R1		;TIMES 2 FOR INDEXING
	MOV	RATIO-6(R1),R1	;PICK UP RATIO NUMBER
	CLR	R3		;CLEAR HI ORDER
	CALL	$SDIVD		;APPORTION IT BY RATIO
	MOV	R0,SMLBLK	;SAVE
	ASL	R0		;MULT BY 2
	SWAB	R0		;NOW BY 512.
	MOV	R0,SMLBUF	;SAVE SIZE
	MOV	R4,R1		;RESTORE CORE POINTER
	MOV	(SP)+,R4	;RECOVER TOPIX1
5$:	MOV	R1,SOBUF(R4)	;SET IN TABLES
	ADD	R0,R1		;NEXT BUFFER
	MOV	R1,EOBUF(R4)	;...IS END OF CURRENT BUFFER
	SUB	#2,R4		;NEXT FILE
	BGT	5$		;EXCEPT LAST ONE
	MOV	R1,SOBUF	;SET START OF FILE 0
	MOV	R1,$RXBFA	;SET START OF 'XTRA' BUFFER
	SUB	R1,R5		;CALCULATE LARGE BUFFER SIZE
	BIC	#511.,R5	;ROUND TO LOWEST INTEGRAL
	MOV	R5,LRGBUF	;STORE IT AWAY
	ADD	R5,R1		;CALC TOP
	MOV	R1,EOBUF	;...& SET ENDING
	ASR	R5		;DIV BY 2
	SWAB	R5		;NOW BY 512
	MOV	R5,LRGBLK	;STORE AWAY NUM BLKX
	RETURN

	.SBTTL	I) - '$RRTBK' - RETURN I/O SPACE
 
;R0 - R2 AND R5 DESTROYED!!
;*32* THIS MODULE AS BEEN TOTALLY REWRITTEN SO THAT SORT DOES NOT TAKE ANY
;*32 * RMS POOLS THAT DO NOT BELONG TO IT.
 
$RRTBK:	MOV	IFSTRT,R1	;*32* GET IFAB POOL ADDR ALLOC
	MOV	#10,R5		;*32* SET OFFSET FOR RMS POOL
	JSR	PC,IORTN	;*32* GET I/O SPACE BACK
	MOV	IRSTRT,R1	;*32* GET IRAB POOL ADDR ALLOC
	MOV	#4,R5		;*32* SET OFFSET FOR RMS POOL
	JSR	PC,IORTN	;*32* GET I/O SPACE BACK
	MOV	BDSTRT,R1	;*32* GET BDB POOL ADDR ALLOC
	CLR	R5		;*32* GET OFFSET FOR RMS POOL
	JSR	PC,IORTN	;*32* GET I/O SPACE BACK
	RETURN

	.SBTTL	I.A) - 'IORTN' - RETURN I/O SPACE

;+
; CALLED ONLY FROM $RRTBK
;
; THIS ROUTINE SEARCH THRU THE RMS POOL LIST AND DELETES THE BUFFER
; FROM THE LIST SPECIFIED IN R1
;
; INPUT
;	R1 = ADDR OF THE POOL TO BE RETURN
;	R5 = OFFSET FROM THE POOL HEADER
;
; OUTPUT
;	NONE
;-

IORTN::
	MOV	@#$VEXT,R0	;*32* GET THE
	MOV	-(R0),R0	;*32* ..POOL HEADER
	ADD	R5,R0		;*32* GET POOL HEADER OFFSET
96$:	TST	@R0		;*32* IF END OF POOL LIST
	BEQ	98$		;*32* ...THEN RETURN
	CMP	(R0),R1		;*32* IS IT THE SPACE THAT WE WANT
	BEQ	97$		;*32* YES THEN REMOVE SPACE
	MOV	(R0),R0		;*32* GO THRU THE LIST
	BR	96$		;*32* ...POOL SPACE
97$:	MOV	2(R0),R2	;*32* SAVE SIZE OF SPACE
	MOV	R2,2(R1)	;*32* MOVE SIZE OF INTO NEXT LIST BLOCK
	MOV	(R1),(R0)	;*32* RESET THE POINTER SO THE LIST IS LINKED
98$:	RTS	PC

	.SBTTL	J) - 'WRTBUF' - WRITE A BUFFER TO SCRATCH FILE
 
;ON ENTRY R4 = FILE INDEX
 
WRTBUF:	MOV	LRGBUF,R5		;SET FOR NORMAL WITE
;
WRTBF1:	PUSH	R0
	PUSH	R1
	PUSH	R2
	MOV	#PRORAB,R0		;R0==>PROTO RAB
	$STORE	#BADWRT,CTX,R0		;SET UP ERROR MSG
	$STORE	TABISI(R4),ISI,R0	;STICK IN STREAM ID
	$STORE	R5,RSZ,R0		;SET IN BUFFER SIZE
	MOV	R4,R2			;NEW POINTER
	ASL	R2			;SET UP FOR DOUBLE WORD
	$STORE	LSTBLK(R2),BKT,R0	;SET THE STARTING BLOCK
	ASR	R5			;DIV BY 2
	SWAB	R5			;NOW BY 512.
	ADD	R5,LSTBLK(R2)		;UPDATE BLOCK POINTER
	ADC	LSTBLK+2(R2)		;...DOUBLE WORD!!
	$STORE	SOBUF(R4),RBF,R0	;SET THE BUFFER START ADDR
	$STORE	RB$WBH,ROP,R0		;SET FOR WRITE BEHIND
	MOV	TABIFI(R4),R1		;PICK UP IFAB POINTER
3$:	CMP	LSTBLK+2(R2),F$HVBN(R1)	;WILL THE  BLOCKS FIT?
	BNE	99$			;*31* YES
	CMP	LSTBLK(R2),F$LVBN(R1)	;MAYBE
99$:	BLOS	5$			;*31* YES
4$:	MOV	#PROFAB,R0		;SET R0==>RAB
	MOV	#FABPAR,R5		;R5==>PARMETER BLOCK
	MOV	$RSALQ,O$ALQ(R0)	;SET THE DEFAULT SEC ALQ
	MOV	$RSALQ+2,2+O$ALQ(R0)
	$STORE	R1,IFI,R0		;SET IN INTERNAL FILE ID
	$EXTEND				;EXTEND THE FILE
	$COMPA	#0,STS,R0		;ANY ERRORS?
	BLT	FILERR			;YES, FIELD THEM
5$:	MOV	#PRORAB,R0		;SET R0==>RAB
	MOV	#RABPAR,R5		;R5==>PARAM BLOCK
	$WRITE				;PUT OUT THE BUFFER
	$COMPA	#0,STS,R0		;ANY ERRORS
	BLE	FILERR			;NO, SOMETHING ELSE
2$:	POP	R2
	POP	R1
	POP	R0
	RETURN				;RETURN
;
FILERR:	$FETCH	R2,STS,R0		;PICK UP THE FILE SYS ERROR
	MOV	R0,R1			;SAVE DATA BLOCK POINTER
	$FETCH	R0,CTX,R0		;PICK UP SORT ERROR CODE
	JMP	$SKILL

	.SBTTL	K) - 'OPENS'  - OPEN ALL SCRATCH FILES
 
OPENS:	MOV	R1,-(SP)		;SAVE R1, NEEDED AS SCRATCH
	MOV	R2,-(SP)
	MOV	R4,-(SP)
	MOVB	#'0,TMPFNO		;#!#!#KLUDGE    SATER AT TOP
	MOV	$RFIRL,LUN		;INIT LOGICAL UNIT NO.
	MOV	$STPX1,R4		;SET R4 = TOP OF INDEX STACK
	BEQ	5$			;IF IN-CORE, ERROR OUT
	MOV	SOBUF,R2		;R2==>START OF BUFFER AREA
	MOV	EOBUF,R1		;R1==>END OF BUFFER AREA
	MOV	#PROFAB,R0		;R0==>PROTO FAB
	TST	$RSCTG			;CONTIQUOUS FILE?
	BEQ	1$			;NO
	$SET	#FB$CTG,FOP,R0		;YES, SET IT UP
1$:	$STORE	R2,BPA,R0		;SET PRIVATE BUFFER ADDR
	$STORE	SMLBUF,BPS,R0		;SET BUFFER SIZE
	$STORE	#OPNOF,CTX,R0		;SET ERROR CODE
	$STORE	$RSCLV,RTV,R0		;SET CLUSTERSIZE
	MOV	$RPALQ,O$ALQ(R0)	;SET DEFAULT PRIMARY ALQ
	MOV	$RPALQ+2,2+O$ALQ(R0)	
2$:	MOV	#PROFAB,R0		;R0==>PROTO FAB
	MOV	#FABPAR,R5		;R5==>PARM BLOK
	$STORE	LUN,LCH,R0		;SET LOGICAL CHANNEL
	$CREATE				;OPEN FOR DELETE
	$COMPA	#0,STS,R0		;ANY ERRORS?
	BLE	FILERR			;NO, SOMETHING ELSE
3$:	$FETCH	TABIFI(R4),IFI,R0	;PICK UP THE FILE ID
	INC	$SOPNF			;INDICATE OPENED
	MOV	#PRORAB,R0		;R0==>PROTO RAB
	MOV	#RABPAR,R5		;R5==>PARM BLOK
	$CONNECT			;CONNECT THE RAB-FAB PAIR

	$COMPARE #0,STS,R0		;ANY ERRORS?
	BGE	4$			;NO
	JMP	FILERR			;YES, FIELD THEM
4$:	$FETCH	TABISI(R4),ISI,R0	;PICK UP STREAM ID
	MOV	R2,SOBUF(R4)		;SET START OF BUFFER ADDR
	MOV	R2,BUFPTR(R4)		;SET INITIAL COND FOR PUTS
	MOV	R1,EOBUF(R4)		;SET END OF BUFFER ADDR
	ASL	R4			;SET UP FOR DOUBLE WORD
	MOV	#1,LSTBLK(R4)		;SET FOR FIRST BLOCK
	CLR	LSTBLK+2(R4)		;..DOUBLE WORD
	ASR	R4			;RESTORE R4
	CLR	EOSFLG(R4)		;CLEAR ANY EOS FLAGS
	INC	LUN			;NEXT CHANNEL
	INCB	TMPFNO			;##KLUDGE!!-INCRE THE FILE NO.###
	SUB	#2,R4
	BGE	2$
	MOV	(SP)+,R4
	MOV	(SP)+,R2		;R2
	MOV	(SP)+,R1		;RESTORE R1
	RETURN	
;
;	IN CORE ERROR
;
5$:	MOV	#6,R0			;TELL USER HE BLEW IT
	JMP	$SKILL

	.SBTTL	L) - 'REDBUF' - READ A BUFFER FROM SCRATCH FILE

;ON ENTRY R4 = FILE INDEX
 
REDBUF:	MOV	SMLBUF,R5		;SET FOR NORMAL READ
;
REDBF1:	MOV	R0,-(SP)
	MOV	#PRORAB,R0		;RO==>PROTO RAB
	$STORE	TABISI(R4),ISI,R0	;SET STREAM ID
	$STORE	R5,USZ,R0		;SET BUFFER SIZE
	ASL	R4
	$STORE	LSTBLK(R4),BKT,R0	;SET FIRST BLOCK TO READ
	ASR	R5			;DIV BY 2
	SWAB	R5			;NOW BY 512.
	ADD	R5,LSTBLK(R4)		;UPDATE NEXT POINTER
	ADC	LSTBLK+2(R4)		;...DOUBLE WORD
	ASR	R4			;RESTORE
	$STORE	#BADRED,CTX,R0		;SET ERROR CODE
	$STORE	RB$RAH,ROP,R0		;SET READ-AHEAD
	$STORE	SOBUF(R4),UBF,R0	;SET ADDR OF BUFFER
	MOV	#RABPAR,R5		;R5==>RAB PAR BLOK
	$READ
	$COMPA	#0,STS,R0		;ANY ERRORS?
	BGT	1$			;NO, LEAVE QUIETLY
	$COMPA	#ER$EOF,STS,R0		;YES, EOF?
	BNE	3$			;NO, SOMETHING ELSE, ERROR
	$COMPA	#0,RSZ,R0		;DID ANYTHING GET TRANSFERRED?
	BNE	1$			;YES
3$:	JMP	FILERR			;NO, ERROR OUT
1$:	MOV	(SP)+,R0
	RETURN				;NORMAL EXIT

	.SBTTL	M) - 'RED1BK' - READ ONE BLOCK FOR PARTIAL BUFF
 
RED1BK:	MOV	#512.,R5		;ONLY ONE BLOCK
	CALL	REDBF1		;READ IT
	ASL	R4		;DOUBLE WORD
	SUB	#1,LSTBLK(R4)	;RESET BLOCK COUNT
	SBC	LSTBLK+2(R4)	;...DOUBLE WORD
	ASR	R4
	CLR	EOSFLG(R4)	;RESET PARTIAL FLAG
	RETURN

	.SBTTL	DATA AREA
;
TMPNAM:	.ASCII	/SORT0D.TMP/	;NAME FOR TMPS
TMPFNO=TMPNAM+4			;ADDR OF FILE NUMBER IN ASCII
TMPSIZ=.-TMPNAM			;SIZE OF FILE NAME
	.EVEN
;
PROFAB:	FAB$B			;PROTOTYPE FAB
	F$FAC	FB$BIO!FB$GET!FB$PUT		;BLOCK ACCESS
	F$FNA	TMPNAM		;FILE NAME STRING
	F$FNS	TMPSIZ		;SIZE OF ABOVE
	F$FOP	FB$TMD!FB$SUP	;MARK FOR DELETE
	F$ORG	FB$SEQ		;SEQUENTIAL ACCESS
	F$RFM	FB$UDF		;UNDEFINED
	F$SHR	FB$NIL		;NOT SHARED
	FAB$E
;
$RSDNA	==PROFAB+O$DNA
$RSDNS	==PROFAB+O$DNS
;

;PROTOTYPE RAB BLOCK
 
PRORAB:	RAB$B			;PROTOTYPE RAB
	R$FAB	PROFAB		;POINTER TO FAB
	RAB$E

;	FILE TABLES
;
MXFLWD=MAXFIL+MAXFIL
TABIFI:	.=.+MXFLWD		;TABLE OF FILE IDS
TABISI:	.=.+MXFLWD		;TABLE OF STREAM IDS
TABUBF:	.=.+MXFLWD		;TABLE OF RECORD BUFFERS FOR LOCATE MODE
LSTBLK:	.=.+MXFLWD+MXFLWD	;TABLE OF BLOCK NUMBERS FOR READ/WRITE
BUFPTR:	.=.+MXFLWD		;TABLE OF NEXT RECORD POINTERS
SOBUF:	.=.+MXFLWD		;TABLE OF START OF BUFFER ADDRESSES
EOBUF:	.=.+MXFLWD		;TABLE OF END OF BUFFER ADDRESSES
EOSFLG:	.=.+MXFLWD		;END OF STRING FLAGS, IF SET PARTIAL BUFFERS
LRGBLK:	.WORD	0		;NUMBER OF BLOCKS IN LRGBUF
LRGBUF:	.WORD	0		;SIZE OF LARGE BUFF
SMLBLK:	.WORD	0		;DITTO FOR SMALL
SMLBUF:	.WORD	0		;DITTO
PRVOUT:	.WORD	0		;PREVIOUS OUTPUT FILE INDEX
BDSTRT:	.WORD	0		;START OF THE BDB AREA
BUFSTR:	.WORD	0		;ADDRESS OF START OF BUFFER AREA
LUN:	.WORD	5		;LOGICAL UNIT NUM
IFSTRT:	.WORD	0		;*32* ADDR OF THE BUFFER ALLOCATED FOR IFAB
IRSTRT:	.WORD	0		;*32* ADDR OF THE BUFFER ALLOCATED FOR IRAB
SRECSZ:	.WORD	0		;SCRATCH RECORD SIZE
RABPAR:	.WORD	1,PRORAB	;RAB PARAMETER BLOCK
FABPAR:	.WORD	1,PROFAB	;FAB PARAMETER BLOCK
;
;	THESE RATIOS APPORTION BUFFER SIZE AS SQRT(FILE ACTIV)
;
RATIO:	.WORD	1748.		;3 FILES
	.WORD	2423.		;4
	.WORD	3072.		;5
	.WORD	3705.		;6
	.WORD	4326.		;7
	.WORD	4939.		;8
	.WORD	5544.		;9
	.WORD	6144.		;10
;
;	GLOBAL PARAMATERS
;
$RMLBF:	.WORD	1		;MULTI-BUFFERING
$RFIRL:	.WORD	6		;FIRST LUN FOR SCRATCH FILE
$RBGBF:	.WORD	0		;BIGBUFFERRING NUMBER
$RSCLV:	.WORD	0		;CLUSTERSIZE FOR RSTS/E
$RSCTG:	.WORD	0		;IF SET, CONTIGUOUS ALLOCATION
$RPALQ:	.WORD	0,0		;PRIMARY ALLOCATION
$RSALQ:	.WORD	64.,0		;SECONDARY
$RXBFA:	.WORD	0		;START OF 'XTRA' BUFFER
 
	.END

