TITLE SORTCD,<COMMAND LINE DECODER>,25,25-FEB-77,ALTMANN 
	.PSECT	SORTCD,OVR
 
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
; 
;
;VERSION NO.:-		V002
;			.03A

	.SBTTL	  MISCELANEOUS DEFINITIONS
 
	IDX=4
	REL=5
	SEQ=6
 
;FOLLOWING GLOBALS ARE ENTRY POINTS IN OTHER MODULES:
 
	.GLOBL	CCVT,CCHKC,CCHKD,PARSNM,CCSER,CSU1,CRDSFX,CRPT
 
;FOLLOWING GLOBALS ARE ENTRY POINTS IN THIS MODULE:
 
	.GLOBL	CMDLNE
 
;FOLLOWING GLOBALS ARE LOCATIONS IN OTHER MODULES:
	
	.GLOBL	WORKA,CILINX,CILIN,CCSERM,KEYXS,NUMFLS,MAXFIL
	.GLOBL	GCMLB,BLOCKI,BLOCKO,BUCKI,BUCKO,CLVALI,CLVALO
	.GLOBL	KEYNMI,KEYNMO,CONTGI,CONTGO,ALLCO,ALLCI
	.GLOBL	SDVDNA,SDVDNS,OUTAPP,WINSTR
	WAMAC			;DEFINE WORKSPACE
 
 
;I/O MACROS
 
	.MCALL	CSI$,GCML$,CSI$1,CSI$2
	.MCALL	CSI$ND,CSI$SV,CSI$SW
	.MCALL	EXIT$S
	CSI$	DEF$L

.SBTTL	REQUEST COMMAND STRING:
 
;THIS MODULE REQUEST A COMMAND LINE, AND INTERPRETS IT INCLUDING SWITCHES
;ON ENTRY R1 = SP
;	  R0==>KEYBLD
;	  R2==>INORG
 
;ON EXIT  R4==>END OF WORK AREA
 
CMDLNE:	BREAK
	MOV	#BADCMD,CCSERM		;SET UP FOR GENERAL ERROR
	MOV	WORKLO,CILINX		;SET LOWER BOUND FOR BUFFER ADDRS
	SAV0
	GCML$	#GCMLB,,,WORKLO,#132.	;READ COMMAND LINE
	BCC	25$
	CMPB	#GE.EOF,GCMLB+G.ERR	;EOF?
	BNE	CCSERX
	EXIT$S
25$:	TST	GCMLB+G.CMLD		;0-LENGTH COMMAND LINE?
	BEQ	CCSERX
	CSI$1	#CSIBLK,GCMLB+G.CMLD+2,GCMLB+G.CMLD
	BCC	26$
	BR	CCSERX
26$:	POP0
	CLR	R3		;DECODE INPUT SPEC.
	JSR	R5,CGTCD
	BNE	CCSERX		;REJECT STRING IF ERROR
	MOV	#2,R3		;SET OUTPUT FLAG
	INC	R2		;... AFTER ADJUST MODE PTR
	JSR	R5,CGTCD
	BNE	CCSERX
	MOV	(R0)+,R4	;ALSO REJECT FOR ERRORS ...
	BEQ	CRPTX		;... ALREADY REPORTED
	DEC	@SP		;IF SPEC. FILE REQD. ...
	BNE	CCGO
	CMP	R1,SP		;REJECT IF KEYS AS SWITCHES
	BNE	CCSERX
	MOV	#4,R3		;SET SPEC FLAG
	TST	-(R0)		;ADJ POINTER
	JSR	R5,CGTCD	;... & GET SPECIFICATION
	BNE	CCSERX		;ERROR
	JMP	CRDSFX		;NO ERROR, PROCEED TO SPEC FILE HANDLR
CCSERX:	JMP	CCSER		;ERROR, PROCEED TO PRINT IT
CCGO:	JMP	CSU1		;NO, ERROR & NO SPEC FILE
CRPTX:	JMP	CRPT		;ERROR, PRINT IT

	.SBTTL	CSI TABLES
 
ALLOMK=100000
APPEMK=040000
BLOCMK=020000
BUCKMK=010000
CONTMK=004000
DEVIMK=002000
FILEMK=001000
FORMMK=000400
INDEMK=000200
KEYEMK=000100
PROCMK=000040
RELAMK=000020
SEQUMK=000010
SIZEMK=000004
WINDMK=000002
;
SWTBL:	CSI$SW	AL,ALLOMK,,,,ALLTBL
	CSI$SW	AP,APPEMK
	CSI$SW	BL,BLOCMK,,,,BLOTBL
	CSI$SW	BU,BUCKMK,,,,BUCTBL
	CSI$SW	CO,CONTMK
	CSI$SW	DE,DEVIMK,,,,DEVTBL
	CSI$SW	FI,FILEMK,,,,FILTBL
	CSI$SW	FO,FORMMK,,,,FORTBL
	CSI$SW	IN,INDEMK,,,,INDTBL
	CSI$SW	KE,KEYEMK,,,,KEYTBL
	CSI$SW	PR,PROCMK,,,,PROTBL
	CSI$SW	RE,RELAMK
	CSI$SW	SE,SEQUMK
	CSI$SW	SI,SIZEMK,,,,SIZTBL
	CSI$SW	WI,WINDMK,,,,WINTBL
	CSI$ND
;
XSWTBL:	CSI$ND		;SWITCH TABLE FOR SPEC FILE (NO SWITCHES)
ALLTBL:	CSI$SV	DECIMAL,TMPALQ,2
	CSI$ND
BLOTBL:	CSI$SV	DECIMAL,BLOK,2
	CSI$ND
BUCTBL:	CSI$SV	DECIMAL,TMPBUC,2
	CSI$ND
DEVTBL:	CSI$SV	ASCII,SDVDNA,4
	CSI$ND
FILTBL:	CSI$SV	DECIMAL,NUMFLS,2
	CSI$ND
FORTBL:	CSI$SV	ASCII,FOADDR,8.
	CSI$SV	DECIMAL,TMPSZE,2
	CSI$ND
INDTBL:	CSI$SV	DECIMAL,TMPIND,2
	CSI$ND
PROTBL:	CSI$SV	ASCII,PRADDR,1
	CSI$ND
SIZTBL:	CSI$SV	DECIMAL,TMPCLV,2
	CSI$ND
WINTBL:	CSI$SV	DECIMAL,WINSTR,2
	CSI$SV	DECIMAL,TMPWIN,2
	CSI$ND

;
ABM.N=13.
KEYTBL:	CSI$SV	,ADDR1,ABM.N
	CSI$SV	,ADDR2,ABM.N
	CSI$SV	,ADDR3,ABM.N
	CSI$SV	,ADDR4,ABM.N
	CSI$SV	,ADDR5,ABM.N
	CSI$SV	,ADDR6,ABM.N
	CSI$SV	,ADDR7,ABM.N
	CSI$SV	,ADDR8,ABM.N
	CSI$SV	,ADDR9,ABM.N
	CSI$SV	,ADDR10,ABM.N
	CSI$ND
ADDBEG:
FOADDR:	.BLKB	8.
PRADDR:	.BLKB	1
ADDR1:	.BLKB	ABM.N
ADDR2:	.BLKB	ABM.N
ADDR3:	.BLKB	ABM.N
ADDR4:	.BLKB	ABM.N
ADDR5:	.BLKB	ABM.N
ADDR6:	.BLKB	ABM.N
ADDR7:	.BLKB	ABM.N
ADDR8:	.BLKB	ABM.N
ADDR9:	.BLKB	ABM.N
ADDR10:	.BLKB	ABM.N
ADDEND:	.EVEN
 
TMPALQ:	.WORD	0
TMPBUC:	.WORD	0
TMPSZE:	.WORD	0
TMPIND:	.WORD	0
TMPWIN:	.WORD	0
TMPCLV:	.WORD	0
BLOK:	.WORD	0
INOUT:	.WORD	0		;SWITCH, SET IF OUTPUT FILE
BUF:	.WORD	0,0
;
CSIBLK:	.BLKB	C.SIZE

	.SBTTL	DECODE FILE SPECIFICATIONS
;	CALL:	JSR	R5,CGTCD
 
;ON ENTRY R3 = 0 (INPUT FILE)
;	       2 (OUTPUT FILE)
;	       4 (SPEC FILE)
;	EXITS WITH Z-BIT CLEAR IF ERROR PRINT REQUIRED
 
MSKWRD=CSIBLK+C.MKW1
 
CGTCD:	PUT0T4
	CLR	TMPBUC
	CLR	TMPCLV
	CLR	TMPIND
	CLR	BLOK
	CLR	TMPSZE
	MOV	#ADDR1,R4
	MOV	#ADDEND-ADDR1,R2
12$:	CLRB	(R4)+
	DEC	R2
	BGT	12$
	MOVB	#CS.INP,CSIBLK+C.TYPR	;SET FOR INPUT
	CMP	R3,#4			;SPEC FILE ?
	BEQ	21$			;...ALLOW NO SWITCHES
	MOV	R3,INOUT		;INPUT OR OUTPUT FILE WANTED?
	BEQ	1$
	MOVB	#CS.OUT,CSIBLK+C.TYPR	;... OUTPUT
1$:	CSI$2	#CSIBLK,,#SWTBL
	BR	20$
21$:	CSI$2	#CSIBLK,,#XSWTBL
20$:	BCC	2$
3$:	JMP	CSWER
;
2$:	BITB	#CS.MOR,CSIBLK+C.STAT	;MORE FILE SPECIFICATIONS SEEN?
	BEQ	4$			;...NO
	CMP	R3,#2			;... INPUT OR OUTPUT?
	BEQ	3$			;...OUTPUT... ERROR
	INC	@R1			;SET SWITCH IF MORE INPUT
4$:	MOV	#CSIBLK+C.DSDS,R2	;SET R2==>DATA SET
	CALL	PARSNM			;PARSE THE FILE NAME
	BCS	3$			;ERROR
	MOV	#WORKA,R4		;SET R4==>SWITCH WORK AREA
	CMP	R3,#4			;SPEC FILE?
	BNE	5$			;NO, CONTINUE
	JMP	OK			;YES, SKIP SWITCHES
5$:	BIT	#ALLOMK,MSKWRD		;/ALLOCATION SWITCH?
	BEQ	7$			;NO
	TSTB	INOUT			;INPUT OR OUTPUT?
	BEQ	6$		
	MOV	TMPALQ,ALLCO		;OUTPUT
	BR	7$			;LEAVE
6$:	MOV	TMPALQ,ALLCI		;INPUT

7$:	BIT	#APPEMK,MSKWRD		;/APPEND SWITCH?
	BEQ	A1			;NO
	INCB	OUTAPP			;YES, SET SWITCH
A1:	BIT	#BLOCMK,MSKWRD		;/BLOCK SWITCH?
	BEQ	2$			;NO
	TSTB	INOUT			;INPUT OR OUTPUT?
	BEQ	1$		
	MOV	BLOK,BLOCKO		;OUTPUT
	BR	2$			;LEAVE
1$:	MOV	BLOK,BLOCKI		;INPUT
2$:	BIT	#BUCKMK,MSKWRD		;/BUCKET SWITCH?
	BEQ	21$			;NO
	TSTB	INOUT			;INPUT OR OUTPUT
	BEQ	22$		
	MOV	TMPBUC,BUCKO		;SET OUTPUT BUCKET
	BR	21$
22$:	MOV	TMPBUC,BUCKI		;SET INPUT BUCKET
21$:	BIT	#CONTMK,MSKWRD		;/CONTIGUOUS SWITCH?
	BEQ	3$			;NO
	TSTB	INOUT			;INPUT OR OUTPUT?
	BEQ	23$
	INCB	CONTGO			;SET CONTIG OUTPUT
	BR	3$
23$:	INCB	CONTGI			;SET CONTIG TEMP FILE
3$:	BIT	#DEVIMK,MSKWRD		;/DEVICE SWITCH?
	BEQ	20$			;NO
	MOV	#4,R2			;SET SIZE
	MOV	#SDVDNA+4,R3		;POSITION TO END
16$:	TSTB	-(R3)			;IS IT NULL?
	BNE	17$			;NO, END IS FOUND
	DEC	R2			;YES, DECREMENT LENGTH
	BGT	16$			;... AND TRY AGAIN
	BR	18$
17$:	TSTB	(R2)+			;ALLOW FOR ":"
	MOVB	#':,1(R3)		;MAKE A FULL DEVICE NAME
18$:	MOVB	R2,SDVDNS		;SET LENGTH
20$:	BIT	#FILEMK,MSKWRD		;/FILES SWITCH?
	BEQ	4$			;NO
	MOVB	#'F,SWNAME		;SET /FI NAME
	MOVB	#'I,SWNAME+1
	TST	NUMFLS			;IS IT ZERO?
	BEQ	4$			;THEN OKAY
	CMP	NUMFLS,#3		;ABOVE THE MIN?
	BLT	29$			;NO, ERROR
	CMP	NUMFLS,#MAXFIL		;BELOW THE MAX?
	BLE	4$			;YES, OK
29$:	JMP	SWERR			;NO, ERROR OUT

4$:	BIT	#FORMMK,MSKWRD		;/FORMAT SWITCH?
	BEQ	6$			;NO
	MOVB	#'F,SWNAME		;SET /FO NAME
	MOVB	#'O,SWNAME+1
	MOV	#BUF,R3			;R3==>PSUEDO-BUFFER
	MOV	#FOADDR,(R3)+		;SET BYTE ADDR
	CLR	@R3			;CLEAR OUT VALUE
	JSR	R5,CCHKC		;CHECK THE CHARACTERS
	.BYTE	1,'U,'F,'S,'V,0	
	DECB	@R3			;0 = ERROR
	BLT	29$			;FIELD IT
	TSTB	INOUT			;INPUT OR OUTPUT?
	BEQ	5$
	MOVB	@R3,OUTRFM		;OUTPUT FORMAT
	MOV	TMPSZE,OUTSZE		;SET OUTPUT SIZE
	BR	6$
5$:	MOVB	@R3,INRFM		;INPUT
	MOV	TMPSZE,RECSZE		;SET RECORD SIZE
6$:	BIT	#PROCMK,MSKWRD		;/PROCESS SWITCH?
	BEQ	7$			;NO
	MOVB	#'P,SWNAME		;SET /PR NAME
	MOVB	#'R,SWNAME+1
	MOV	#BUF,R3			;R3==>PSUEDO BUFFER
	MOV	#PRADDR,(R3)+		;SET BYTE ADDR
	CLR	@R3			;CLEAR VALUE
	JSR	R5,CCHKC		;CHECK THE CHARACTERS
	.BYTE	1,'R,'T,'A,'I,'X,'M,0	
	DECB	@R3			;0 = ERROR
	BLT	29$			;FIELD IT
	MOVB	@R3,PROCESS		;STORE IT
7$:	CLR	@R3			;CLEAR VALUE
	BIT	#INDEMK,MSKWRD		;/INDEXED SWITCH?
	BEQ	8$			;NO
	TSTB	INOUT			;INPUT OR OUTPUT?
	BEQ	27$
	MOVB	TMPIND,KEYNMO		;SET NUMBER OF OUTPUT KEYS
	BR	28$
27$:	MOVB	TMPIND,KEYNMI		;SET NUMBER OF INPUT KEYS
28$:	MOV	#IDX,@R3		;SET INDEXED ORG
	BR	10$			;...& SKIP NEXT
8$:	BIT	#RELAMK,MSKWRD		;/RELATIVE SWITCH?
	BEQ	9$			;NO
	MOV	#REL,@R3		;SET RELATIVE ORG
	BR	10$			;...& SKIP NEXT

9$:	BIT	#SEQUMK,MSKWRD		;/SEQUENTIAL SWITCH?
	BEQ	10$			;NO
	MOV	#SEQ,@R3		;SET SEQUENTIAL ORG
10$:	TSTB 	INOUT			;INPUT OR OUTPUT?
	BEQ	11$	
	MOVB	@R3,OUTORG		;OUTPUT ORGANIZATION
	BR	25$
11$:	MOVB	@R3,INORG		;INPUT
25$:	BIT	#SIZEMK,MSKWRD		;/SI SWITCH?
	BEQ	12$			;NO
	TSTB	INOUT			;INPUT OR OUTPUT?
	BEQ	24$
	MOV	TMPCLV,CLVALO		;SET OUTPUT CLVALUE
	BR	12$
24$:	MOV	TMPCLV,CLVALI		;SET TEMP FILE CLVALUE
12$:	BIT	#WINDMK,MSKWRD		;/WINDOW SWITCH?
	BEQ	19$			;NO
	MOV	TMPWIN,OUTSZE		;SET OUTPUT SIZE
19$:	BIT	#KEYEMK,MSKWRD		;/KEY SWITCH?
	BEQ	OK			;NO
	MOVB	#'K,SWNAME		;SET /KE NAME
	MOVB	#'E,SWNAME+1
	MOV	#ADDEND-ABM.N,R2
	MOV	R4,R3
	TST	(R4)+
	MOV	#1,@R3
13$:	TSTB	@R2			;VALUE TYPED?
	BEQ	14$
	INC	@R3			;... BUMP VALUE COUNTER
	MOV	R2,(R4)+
14$:	CMP	#ADDR1,R2		;VALUE LIST EXHAUSTED?
	BEQ	15$
	SUB	#ABM.N,R2		;... TRY NEXT ELEMENT
	BR	13$
15$:	MOV	#"KE,(R4)+
	CMP	#1,@R3
	BNE	OK
	MOV	R3,R4
OK:	CLR	@R4
	GET0T2				;RESTORE R0-R2
	MOV	#WORKA,R4		;FOR SPEC FILE
	MOV	@R4,R3			;/KE SWITCH?
	BEQ	CSWOKX			;IF NOT EXIT WITH Z BIT SET
	ASL	R3			;SET OFFSET
	ADD	R4,R3			;SET R3==>SWTICH NAME IN BUFFER
	BR	CKSW			;SKIP FIRST INSTR
	;

	.SBTTL  PROCESS /KE SWITCH
 
CKSWR:	CLR	-(R3)		;RESET BUFFER IF LOOP
CKSW:	TST	(R1)+		;BUMP POINTER
	MOV	R1,-(SP)	;ENSURE ROOM FOR NEW KEY
	ADD	#15.,@SP
	CMP	(SP)+,@R0
	BHI	CKSWER
	CLR	@R3		;USE NAME FOR BUFFER AREA
	JSR	R5,CCHKC	;GET DATA TYPE IF ANY
	.BYTE	'C,'Z,'D,'P,'B,'F,'C,'C,'C,'I,'J,'K,'K,0
 
;NOTE: EXTRA THREE 'C ARE TO SKIP OVER PECMP,PLCMP,PGCMP IN TABLE 
;	PTAB.
 
	SWAB	@R3		;... & SEQUENCE
	JSR	R5,CCHKC
	.BYTE	'N,'O,'N,0	;(2ND 'N IS PADDING!)
	MOV	@R3,4(R1)	;STORE RESULT
	CALL	TWOVAL		;PICK UP START POS & LENGTH
	ADD	-2(R1),@R3
	CMP	@R3,MAXPOS	;REMEMBER LAST RECORD POSITION
	BLE	.+6		;... USED IN KEY
	MOV	@R3,MAXPOS
	JSR	R5,CCHKD	;CHECK SIZE V MODE
	BR	SWERR		;OBJECT IF ERROR
CKSWX:	MOV	R3,-(SP)	;CHECK IF MORE VALUES
	SUB	R4,@SP
	CMP	(SP)+,#4
	BNE	CKSWR		;IF SO REPEAT

CSWOK:	TST	6(SP)		;FOR ENTRY FROM SPEC. FILE ...
	BPL	CSWOKX		;... OMIT NEXT
	JSR	R5,CCHKC	;AT COMMON EXIT ...
	.BYTE	'/,':,'<,215	;... ENSURE NO EXTRAS IN VALUE
	CMP	-(R3),-(R3)	;ALSO CHECK THAT NO MORE VALUES
	CMP	R3,R4
	BHI	CSWER		;ERROR
CSWOKX:	SEZ			;NO ERROR
	RTS	R5		;EXIT
;
CSWER:	GET0T4			;RESTORE REGISTERS
	CLZ			;SET ERROR INDICATOR
	RTS	R5		;EXIT
;
CKSWER:	MOV	#KEYXS,CCSERM	;SET /KEY MESSAGE
	BR	CSWER
;
SWERR:	MOV	#BADSW,CCSERM	;SET /KE MESSAGE
	BR	CSWER
;
;	SUBROUTNIE TO RECOVER TWO VALUES FROM SWITCH OF
;	FORM <VAL1>.<VAL2>
;
TWOVAL:	JSR	R5,CCVT		;NOW GET FIRST VALUE
	DEC	@R3		;MUST BE >0 ...
	BLT	SWERR		;... ALSO STARTS FROM 1
	MOV	@R3,(R1)+	;PUT IT AWAY
	CMPB	@-(R3),#'.	;CORRECTLY DELIMITED?
	BNE	SWERR
	INC	(R3)+		;IF SO MOVE TO NEXT BYTE
	JSR	R5,CCVT		;... & GET SECOND VALUE
	MOV	@R3,@R1		;MUST ALSO BE >0
	BLE	SWERR
	RETURN

	.SBTTL	DATA BLOCKS
 
	STRNG	BADCMD,<?SORT COMMAND ERROR>
	STRNG	BADSW,<?IMPROPER SWITCH:/XX>
	SWNAME=BADSW+22.
 
	.END
