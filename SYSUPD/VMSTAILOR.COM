$	SET NOCONTROLY
$	IF F$MODE () .NES. "INTERACTIVE" THEN SET NOVERIFY
$	IF "''TLR$DEBUG'" .EQS. "" THEN TLR$DEBUG = 0
$	TLR$VERIFY = F$VERIFY (0)
$	ON ERROR THEN GOTO ONERR_RUNDOWN
$	IF TLR$DEBUG THEN GOTO NO_HANDLER
$	ON CONTROL_Y THEN GOTO ERROR_CTRLY
$ NO_HANDLER:
$
$ !++
$ ! VMSTAILOR.COM - Tailor a VMS software configuration
$ !
$ ! AUTHOR:	Greg Robert		05-Oct-1981
$ !
$ ! ABSTRACT:	This command procedure tailors VMS software configurations
$ !		on tape or disk media.
$ !
$ ! NOTE:	This facility is restricted to VAX-11/730 dual RL02
$ !		configurations for VAX/VMS Version 3.0.
$ !
$ ! INPUT:
$ !
$ ! DESCRIPTION:
$ !--
$
$	!
$	! Initialize local data
$	!
$
$	VERSION = "3"
$	IF F$LOGICAL ("DATAFILE") .NES. "" THEN CLOSE DATAFILE
$	PROCESS_GROUP_RECORD = ""
$	PROCESS_GROUP_FILE = ""
$	PROCESS_GROUP_LIST = ""
$	DISPLAY		= "WRITE SYS$OUTPUT"
$	DISPLAY_L	= "WRITE LISTFILE"
$	TLR$TRUE		= "TRUE"
$	TLR$FALSE		= "FALSE"
$	TLR$SPACE		= " "
$	TLR$SLASH		= "/"
$	TLR$COMMA		= ","
$	TLR$EQUAL		= "="
$	TLR$STAR		= "*"
$	TLR$DOLLAR		= "$"
$	TLR$COLON		= ":"
$	TLR$EOS			= 9999
$	TLR$FILES_COPIED	= 0
$	TLR$FILES_DELETED	= 0
$	TLR$FILES_FOUND		= 0
$	TLR$TRGROOT		= ""
$	TLR$SRCROOT		= ""
$	TLR$DELETE		= "DELETE"
$	TLR$COPY		= "COPY"
$	TLR$BACKUP		= "BACKUP"
$	TLR$DEFINE		= "DEFINE"
$	TLR$DEASSIGN		= "DEASSIGN"
$	TLR$MOUNT		= "MOUNT"
$	TLR$DISMOUNT		= "DISMOUNT /NOUNLOAD"
$	TLR$HELP		= "HELP"
$	TLR$STATUS		= 1
$	TLR$WILD		= TLR$FALSE
$	STS$M_INHIB_MSG		= %X10000000
$	SIZE		= 0
$	TLR$DIR			= "NOSUCHDIRECTORY"
$	VERB$LIST	= -
		"/COPY/DELETE/DIRECTORY/DISMOUNT/EXIT/HELP/INSTALL/MOUNT/RECORD/SEARCH"
$	COPY_QUAL$LIST		= "/CONFIRM/FILE/LIBRARY/LOG"
$	DELETE_QUAL$LIST	= "/CONFIRM/FILE/LIBRARY/LOG/OVERRIDE"
$	DIRECTORY_QUAL$LIST	= "/GROUPS/OUTPUT/SIZE"
$	INSTALL_QUAL$LIST	= "/LOG"
$	MOUNT_QUAL$LIST		= "/WRITE"
$
$	!
$	! If tailoring was invoked with non-blank parameters then
$	! combine them to form a command line.
$	!
$
$	P1$P8		= P1 + TLR$SPACE + P2 + TLR$SPACE + P3 + TLR$SPACE + P4 + TLR$SPACE + -
			  P5 + TLR$SPACE + P6 + TLR$SPACE + P7 + TLR$SPACE + P8
$	P1$P8		:= 'P1$P8
$	ORIG$COMMAND	= P1$P8
$
$	!
$	! Check if we are being invoked from the startup process. If
$	! so then use alternate input.
$	!
$	TLR$INPUT = "SYS$COMMAND"
$	IF F$LOGICAL ("BOOT$INPUT") .NES. "" THEN TLR$INPUT = "BOOT$INPUT"
$	SET CONTROL_Y
$
$ CHECK_PARAMETERS:
$	IF P1$P8 .NES. "" THEN GOTO PARSE_INIT
$
$	!
$	! Display an announcement message
$	!
$
$ ANNOUNCE:
$	DISPLAY		"             VAX/VMS Tailoring Facility"
$	DISPLAY		""
$	DISPLAY		"Type ""HELP"" for more information"
$	DISPLAY		""
$	GOTO GET_COMMAND
$
$ DCL_COMMAND:
$	'F$EXTRACT (1, TLR$EOS, TLR$COMMAND)	! Issue DCL direct command
$
$	!
$	! If tailoring was invoked with an external command
$	! then exit.  Else get a user command.
$	!
$
$ GET_COMMAND:
$	SET NOVERIFY
$	TLR$WARN_RETURN	= ""
$	IF P1$P8 .NES. "" THEN GOTO EXIT_START
$	READ 'TLR$INPUT' ORIG$COMMAND /PROMPT="Tailor> " /END=EXIT_START
$	ORIG$COMMAND := 'ORIG$COMMAND
$	IF ORIG$COMMAND .EQS. "" THEN GOTO GET_COMMAND
$
$	!
$	! Initialize verb and parameter symbols
$	!
$
$ PARSE_INIT:
$	TLR$COMMAND = ORIG$COMMAND
$	IF F$EXTRACT (0, 1, TLR$COMMAND) .EQS. TLR$DOLLAR .AND. -
	   TLR$DEBUG THEN GOTO DCL_COMMAND
$	TLR$VERB	= ""
$	PNUMB$		= 0
$	PARAM$1		= ""
$	PARAM$2		= ""
$	PARAM$3		= ""
$	PARAM$4		= ""
$	PARAM$5		= ""
$	PARAM$6		= ""
$	PARAM$7		= ""
$	PARAM$8		= ""
$	PARAM$9		= ""
$	MAX$PARAMS	= 9
$
$	!
$	! Convert any occurences of " =" and "= " to "="
$	!
$
$ 10$:	X = F$LOCATE (" =", TLR$COMMAND)
$	IF X .EQ. F$LENGTH (TLR$COMMAND) THEN GOTO 20$
$	TLR$COMMAND = F$EXTRACT (0, X, TLR$COMMAND) + F$EXTRACT (X+1, TLR$EOS, TLR$COMMAND)
$	GOTO 10$
$
$ 20$:	X = F$LOCATE ("= ", TLR$COMMAND)
$	IF X .EQ. F$LENGTH (TLR$COMMAND) THEN GOTO PARSE_LOOP
$	TLR$COMMAND = F$EXTRACT (0, X+1, TLR$COMMAND) + F$EXTRACT (X+2, TLR$EOS, TLR$COMMAND)
$	GOTO 20$
$
$	!
$	! Locate the next token as delimited by space, comma, or slash
$	!
$
$ PARSE_LOOP:
$	TLR$COMMAND := 'TLR$COMMAND
$	IF TLR$COMMAND .EQS. "" THEN GOTO PARSE_EXIT
$	X = F$LOCATE (TLR$SPACE, TLR$COMMAND)
$	Y = F$LOCATE (TLR$SLASH, F$EXTRACT (1, TLR$EOS, TLR$COMMAND))
$	Z = F$LOCATE (TLR$COMMA, F$EXTRACT (1, TLR$EOS, TLR$COMMAND))
$	IF X .LE. Y .AND. X .LE. Z THEN GOTO PARSE_EXTRACT
$	X = Y+1
$	IF Y .LT. Z THEN GOTO PARSE_EXTRACT
$	X = Z+1
$
$	!
$	! Extract the token and remove it from the command line.
$	! Dispatch to the proper token parser (verb, qualifer, or parameter)
$	!
$
$ PARSE_EXTRACT:
$	T = F$EXTRACT (0, X, TLR$COMMAND)
$	TLR$COMMAND = F$EXTRACT (X, TLR$EOS, TLR$COMMAND)
$	IF TLR$VERB .EQS. "" THEN GOTO PARSE_VERB
$	IF F$EXTRACT (0, 1, T) .EQS. TLR$SLASH THEN GOTO PARSE_QUALIFIER
$	GOTO PARSE_PARAMETER
$
$	!
$	! Check for legal, unambiguous verb
$	!
$
$ PARSE_VERB:
$	X =  F$LOCATE (TLR$SLASH + T, VERB$LIST)
$	IF X .EQ. F$LENGTH (VERB$LIST) THEN GOTO ERROR_UNRECCMD
$	TLR$VERB = F$EXTRACT (X+1, TLR$EOS, VERB$LIST)
$	IF F$LOCATE (TLR$SLASH + T, TLR$VERB) .NE. F$LENGTH (TLR$VERB) THEN GOTO ERROR_AMBIGWRD
$	TLR$VERB = F$EXTRACT (0, F$LOCATE (TLR$SLASH, TLR$VERB), TLR$VERB)
$	FOREIGN$COMMAND = TLR$COMMAND
$	X = "'" + TLR$VERB + "_QUAL$LIST"
$	X := 'X
$	IF X .EQS. "" THEN GOTO PARSE_LOOP
$	X = F$EXTRACT (1, TLR$EOS, X)
$
$	!
$	! If the verb has a qualifer list then set all qualifers
$	! for the verb to false.
$	!
$
$ PARSE_CANCEL_QUALIFIERS:
$	Z = F$LOCATE (TLR$SLASH, X)
$	Y = F$EXTRACT (0, Z, X)
$	TLR$Q_'Y = TLR$FALSE
$	X = F$EXTRACT (Z+1, TLR$EOS, X)
$	IF X .NES. "" THEN GOTO PARSE_CANCEL_QUALIFIERS
$	GOTO PARSE_LOOP
$
$	!
$	! Parse parameters.  Allow the syntax TOKEN[,...].  Note
$	! that if a comma seperated list contains spaces then each
$	! element will be passed to this routine as a seperate token.
$	! Therefore, if the first character of the token is a comma,
$	! or the last character of the preceeding parameter is a comma,
$	! then the tokens are assembled into a single parameter list.
$	!
$
$ PARSE_PARAMETER:
$	IF PNUMB$ .NE. 0 THEN GOTO 40$
$
$	!
$	! Don't allow leading comma on first parameter
$	!
$	IF F$EXTRACT (0, 1, T) .EQS. TLR$COMMA THEN GOTO ERROR_BADCOMMA
$	GOTO 50$
$
$ 40$:	IF F$EXTRACT (F$LENGTH(PARAM$'PNUMB$) -1, 1, PARAM$'PNUMB$) .EQS. TLR$COMMA -
	.OR. F$EXTRACT (0, 1, T) .EQS. TLR$COMMA THEN GOTO 60$
$
$	!
$	! Bump parameter number and check for overflow
$	!
$ 50$:	PNUMB$ = PNUMB$ + 1
$	IF PNUMB$ .GT. MAX$PARAMS THEN GOTO ERROR_TOOMANYPARM
$
$ 60$:	PARAM$'PNUMB$ = PARAM$'PNUMB$ + T
$	GOTO PARSE_LOOP
$
$	!
$	! Parse qualifers.  A qualifier list must be defined
$	! for the verb, and the qualifier must be present in the list.
$	!
$
$ PARSE_QUALIFIER:
$	IF T .EQS. TLR$SLASH THEN GOTO ERROR_UNRECQUAL
$	Y = "'" + TLR$VERB + "_QUAL$LIST"
$	Y := 'Y
$	IF Y .EQS. "" THEN GOTO ERROR_NOQUAL
$
$ PARSE_TLR$Q_VALUE:
$	X = F$LOCATE (TLR$EQUAL, T)
$	Q = F$EXTRACT (X+1, TLR$EOS, T)
$	T = F$EXTRACT (0, X, T)
$	X = F$LOCATE (T, 'TLR$VERB'_QUAL$LIST)
$	IF X .EQ. F$LENGTH ('TLR$VERB'_QUAL$LIST) THEN GOTO ERROR_UNRECQUAL
$	Y = F$EXTRACT (X+1, TLR$EOS, 'TLR$VERB'_QUAL$LIST)
$	IF F$LOCATE (T, Y) .NE. F$LENGTH (Y) THEN GOTO ERROR_AMBIGWRD
$	Y = F$EXTRACT (0, F$LOCATE (TLR$SLASH, Y), Y)
$	TLR$Q_'Y = TLR$TRUE
$	TLR$Q_'Y'_VALUE = Q
$	GOTO PARSE_LOOP
$
$ PARSE_EXIT:
$	IF TLR$VERIFY .AND. TLR$DEBUG THEN SET VERIFY
$	GOTO 'TLR$VERB'_START
$
$ OPEN_GROUP_FILE:
$	!
$	! Extract the next group name
$	!
$
$	IF F$LOCATE (TLR$STAR, GROUP$LIST) .NE. F$LENGTH (GROUP$LIST) THEN -
		GOTO ERROR_NOWILDCARDS
$	IF GROUP$LIST .EQS. "" THEN GOTO END_GROUP_LIST
$	X = F$LOCATE (TLR$COMMA, GROUP$LIST)
$	DATAFILE = F$EXTRACT (0, X, GROUP$LIST)
$	TLR$GROUP = DATAFILE
$	GROUP$LIST = F$EXTRACT (X+1, TLR$EOS, GROUP$LIST)
$
$	!
$	! Locate the data file.
$	!
$
$	X = F$PARSE (DATAFILE, F$LOGICAL ("SYS$UPDATE") + ".TLR")
$	IF X .EQS. "" THEN GOTO ERROR_NOSUCHGROUP
$	DATAFILE = X
$	X = F$SEARCH (DATAFILE)
$	IF X .NES. "" THEN GOTO FOUND_FILENAME
$	Y = F$PARSE (DATAFILE,,,"NAME")
$	IF F$LENGTH (Y) .GE. 9 THEN GOTO ERROR_NOSUCHGROUP
$	DATAFILE = F$PARSE (Y + TLR$STAR, DATAFILE)
$	X = F$SEARCH (DATAFILE, 1)
$	IF X .EQS. "" THEN GOTO ERROR_NOSUCHGROUP
$	Y = F$SEARCH (DATAFILE, 1)
$	IF Y .NES. "" THEN GOTO ERROR_AMBIG_GROUP
$	Y = F$SEARCH ("", 1)
$
$ FOUND_FILENAME:
$	DATAFILE = X
$	TLR$GROUP = F$PARSE (DATAFILE,,,"NAME")
$	OPEN /READ DATAFILE 'DATAFILE /ERROR=ERROR_RUNDOWN
$	IF TLR$GROUP .EQS. "REQUIRED" .AND. TLR$VERB .EQS. "DELETE" -
	THEN GOTO ERROR_NODELREQ
$
$ GET_GROUP_RECORD:
$	GOTO 'PROCESS_GROUP_RECORD
$
$	!
$	! Close the group file and call user per-file routine if defined
$	!
$
$ CLOSE_GROUP_FILE:
$	CLOSE DATAFILE
$	GOTO OPEN_GROUP_FILE
$
$	!
$	! Cancel all "goto" parameters and call user exit routine if defined
$	!
$
$ END_GROUP_LIST:
$	PROCESS_GROUP_RECORD = ""
$	X = PROCESS_GROUP_LIST
$	PROCESS_GROUP_LIST = ""
$	IF X .NES. "" THEN GOTO 'X
$	GOTO GET_COMMAND
$
$	!
$	! The COPY command copies one or more file groups or files.
$	! The revision date and version number of the source file are
$	! preserved.  Any old files on the target disk are deleted.
$	!
$
$ COPY_START:
$	IF PARAM$2 .NES. "" THEN GOTO ERROR_TOOMANYPARM
$	TLR$FILES_COPIED = 0
$	TLR$FILES_FOUND = 0
$	TLR$COPY = "COPY /REPLACE"
$	IF TLR$Q_LOG THEN TLR$COPY = TLR$COPY + " /LOG"
$	TLR$DELETE = "DELETE"
$	IF TLR$Q_LOG THEN TLR$DELETE = TLR$DELETE + " /LOG"
$	IF .NOT. F$GETDVI ("LIB$SYSDEVICE", "EXISTS") THEN GOTO ERROR_LIBNOTMOUNT
$	IF .NOT. F$GETDVI ("LIB$SYSDEVICE", "MNT") THEN GOTO ERROR_LIBNOTMOUNT
$	IF TLR$Q_LIBRARY .AND. F$GETDVI ("LIB$SYSDEVICE", "SWL") THEN -
		GOTO ERROR_LIBPROTECT
$	TLR$SRCROOT = "LIB$SYSROOT:"
$	TLR$TRGROOT = "SYS$SYSROOT:"
$	IF .NOT. TLR$Q_LIBRARY THEN GOTO COPY_LIB_TO_SYS
$	TLR$SRCROOT = "SYS$SYSROOT:"
$	TLR$TRGROOT = "LIB$SYSROOT:"
$
$ COPY_LIB_TO_SYS:
$	IF TLR$Q_FILE THEN GOTO COPY_FILE_START
$	TLR$WARN_RETURN = "COPY_LOOP"
$	IF PARAM$1 .EQS. "" THEN GOTO ERROR_GROUPREQ
$	PROCESS_GROUP_RECORD = "COPY_LOOP"
$	GROUP$LIST = PARAM$1
$	GOTO OPEN_GROUP_FILE
$
$ COPY_LOOP:
$	READ DATAFILE FILENAME /END_OF_FILE=CLOSE_GROUP_FILE
$	FILENAME := 'FILENAME
$	TLR$SRCFILE = F$PARSE (FILENAME, TLR$SRCROOT + ";")
$	TLR$TRGFILE = F$PARSE (FILENAME, TLR$TRGROOT + ";")
$	IF F$SEARCH (TLR$SRCFILE) .EQS. "" THEN GOTO WARN_NOSUCHFILE
$	IF .NOT. TLR$Q_CONFIRM THEN GOTO COPY_ONE
$	SIZE = F$FILE (TLR$SRCFILE, "ALQ")
$
$ COPY_CONFIRM:
$	READ 'TLR$INPUT' Z /PROMPT="Copy ""''TLR$SRCFILE'"", ''SIZE' blocks [Y]?  " /END=ERROR_RUNDOWN
$	Z := 'Z
$	IF Z .EQS. "" THEN GOTO COPY_ONE
$	IF F$EXTRACT (0, 1, Z) .EQS. "Y" THEN GOTO COPY_ONE
$	IF F$EXTRACT (0, 1, Z) .EQS. "N" THEN GOTO COPY_LOOP
$	GOTO COPY_CONFIRM
$
$ COPY_ONE:
$	SET NOON
$	IF F$SEARCH (TLR$TRGFILE) .NES. "" THEN TLR$DELETE 'TLR$TRGFILE'*
$	TLR$COPY 'TLR$SRCFILE' 'F$PARSE ("*.*;*", TLR$TRGFILE)'
$	IF $STATUS THEN TLR$FILES_COPIED = TLR$FILES_COPIED + 1
$	SET ON
$	GOTO COPY_LOOP
$
$ COPY_FILE_START:
$	IF PARAM$1 .EQS. "" THEN GOTO ERROR_FILENAMEREQ
$	TLR$WARN_RETURN = "COPY_FILE_LOOP"
$	TLR$SRCSPEC = F$PARSE (PARAM$1, TLR$SRCROOT + "[SYSEXE].EXE;")
$	TLR$WILD = F$LOCATE ("*", TLR$SRCSPEC) .NE. F$LOCATE ("%", TLR$SRCSPEC)
$
$ COPY_FILE_LOOP:
$	TLR$SRCFILE = F$SEARCH (TLR$SRCSPEC, 1)
$	IF TLR$SRCFILE .EQS. "" THEN GOTO COPY_FILE_FINISH
$	TLR$FILES_FOUND = TLR$FILES_FOUND + 1
$	TLR$TRGFILE = F$PARSE (TLR$TRGROOT + ";", TLR$SRCFILE)
$	IF TLR$TRGFILE .EQS. "" THEN GOTO COPY_FILE_BADTARG
$	IF .NOT. TLR$Q_CONFIRM THEN GOTO COPY_FILE
$	SIZE = F$FILE (TLR$SRCFILE, "ALQ")
$
$ COPY_FILE_CONFIRM:
$	READ 'TLR$INPUT' Z /PROMPT="Copy ""''TLR$SRCFILE'"", ''SIZE' blocks [Y]?  " /END=ERROR_RUNDOWN
$	Z := 'Z
$	IF Z .EQS. "" THEN GOTO COPY_FILE
$	IF F$EXTRACT (0, 1, Z) .EQS. "Y" THEN GOTO COPY_FILE
$	IF F$EXTRACT (0, 1, Z) .EQS. "N" THEN GOTO COPY_FILE_LOOP
$	GOTO COPY_FILE_CONFIRM
$
$ COPY_FILE:
$	SET NOON
$	IF F$SEARCH (TLR$TRGFILE) .NES. "" THEN TLR$DELETE 'TLR$TRGFILE'*
$	TLR$COPY 'TLR$SRCFILE' 'TLR$TRGFILE'*
$	IF $STATUS THEN TLR$FILES_COPIED = TLR$FILES_COPIED + 1
$	SET ON
$	IF TLR$WILD THEN GOTO COPY_FILE_LOOP
$
$ COPY_FILE_FINISH:
$	IF TLR$FILES_FOUND .NE. 0 THEN GOTO GET_COMMAND
$	IF TLR$SRCSPEC .EQS. "" THEN TLR$SRCSPEC = PARAM$1
$	GOTO ERROR_NOSUCHFILE
$
$ COPY_FILE_BADTARG:
$	TLR$DIR = TLR$TRGROOT + F$PARSE (TLR$SRCFILE,,,"DIRECTORY")
$	GOTO ERROR_NOSUCHDIR
$
$	!
$	! The DELETE command deletes one or more file groups
$	! from the system disk.
$	!
$
$ DELETE_START:
$	IF PARAM$2 .NES. "" THEN GOTO ERROR_TOOMANYPARM
$	IF TLR$Q_OVERRIDE .AND. .NOT. TLR$Q_LIBRARY THEN GOTO DELETE_NODEVCHECK
$	IF .NOT. F$GETDVI ("LIB$SYSDEVICE", "EXISTS") THEN GOTO ERROR_LIBNOTMOUNT
$	IF .NOT. F$GETDVI ("LIB$SYSDEVICE", "MNT") THEN GOTO ERROR_LIBNOTMOUNT
$
$ DELETE_NODEVCHECK:
$	TLR$FILES_DELETED = 0
$	TLR$FILES_FOUND = 0
$	TLR$DELETE = "DELETE"
$	IF TLR$Q_LOG THEN TLR$DELETE = TLR$DELETE + "/LOG"
$	IF TLR$Q_CONFIRM THEN TLR$DELETE = TLR$DELETE + "/CONFIRM"
$	TLR$TRGROOT = "SYS$SYSROOT:"
$	TLR$SRCROOT = "LIB$SYSROOT:"
$	IF .NOT. TLR$Q_LIBRARY THEN GOTO DELETE_SYSTEM
$	IF F$GETDVI ("LIB$SYSDEVICE", "SWL") THEN GOTO ERROR_LIBPROTECT
$	TLR$TRGROOT = "LIB$SYSROOT:"
$	TLR$SRCROOT = "SYS$SYSROOT:"
$
$ DELETE_SYSTEM:
$	IF TLR$Q_FILE THEN GOTO DELETE_FILE_START
$	IF PARAM$1 .EQS. "" THEN GOTO ERROR_GROUPREQ
$	PROCESS_GROUP_RECORD = "DELETE_LOOP"
$	TLR$WARN_RETURN = "DELETE_LOOP"
$	GROUP$LIST = PARAM$1
$	GOTO OPEN_GROUP_FILE
$
$ DELETE_LOOP:
$	READ DATAFILE FILENAME /END_OF_FILE=CLOSE_GROUP_FILE
$	FILENAME := 'FILENAME
$	TLR$SRCFILE = F$PARSE (FILENAME, TLR$TRGROOT)
$	IF F$SEARCH (TLR$SRCFILE) .EQS. "" THEN GOTO DELETE_LOOP
$	IF TLR$Q_OVERRIDE THEN GOTO DELETE_ONE
$	IF F$SEARCH (F$PARSE (TLR$SRCROOT + ";", TLR$SRCFILE)) .EQS. "" -
	   THEN GOTO WARN_NOBACKUP
$
$ DELETE_ONE:
$	SET NOON
$	TLR$DELETE 'TLR$SRCFILE'*
$	IF $STATUS THEN TLR$FILES_DELETED = TLR$FILES_DELETED + 1
$	SET ON
$	GOTO DELETE_LOOP
$
$ DELETE_FILE_START:
$	IF PARAM$1 .EQS. "" THEN GOTO ERROR_FILENAMEREQ
$	TLR$WARN_RETURN = "DELETE_FILE_LOOP"
$	TLR$SRCSPEC = F$PARSE (PARAM$1, TLR$TRGROOT + "[SYSEXE].EXE;*")
$	TLR$WILD = F$LOCATE ("*", TLR$SRCSPEC) .NE. F$LOCATE ("%", TLR$SRCSPEC)
$
$ DELETE_FILE_LOOP:
$	TLR$SRCFILE = F$SEARCH (TLR$SRCSPEC, 1)
$	IF TLR$SRCFILE .EQS. "" THEN GOTO DELETE_FILE_FINISH
$	TLR$FILES_FOUND = TLR$FILES_FOUND + 1
$	IF TLR$Q_OVERRIDE THEN GOTO DELETE_FILE
$	IF F$SEARCH (F$PARSE (TLR$SRCROOT + ";", TLR$SRCFILE)) .EQS. "" -
	   THEN GOTO WARN_NOBACKUP
$
$ DELETE_FILE:
$	SET NOON
$	TLR$DELETE 'TLR$SRCFILE'
$	IF $STATUS THEN TLR$FILES_DELETED = TLR$FILES_DELETED + 1
$	SET ON
$	IF TLR$WILD THEN GOTO DELETE_FILE_LOOP
$
$ DELETE_FILE_FINISH:
$	IF TLR$FILES_FOUND .NE. 0 THEN GOTO GET_COMMAND
$	IF TLR$SRCSPEC .EQS. "" THEN TLR$SRCSPEC = PARAM$1
$	GOTO ERROR_NOSUCHFILE
$
$	!
$	! The DIRECTORY command lists the contents and sizes of
$	! one or more file groups
$	!
$
$ DIRECTORY_START:
$	IF PARAM$2 .NES. "" THEN GOTO ERROR_TOOMANYPARM
$	IF TLR$Q_GROUPS THEN GOTO DIR_GROUPS
$	IF PARAM$1 .EQS. "" THEN GOTO ERROR_GROUPREQ
$	FIRSTDIR = TLR$TRUE
$	ENDGROUP = TLR$FALSE
$	TLR$DIR = ""
$	DIR$BLOCKS	= 0
$	DIR$FILES	= 0
$	GROUP$BLOCKS	= 0
$	GROUP$FILES	= 0
$	GRAND$FILES	= 0
$	GRAND$BLOCKS	= 0
$	GRAND$GROUPS	= 0
$	SIZE		= 0
$
$	IF "''TLR$Q_OUTPUT_VALUE'" .EQS. "" THEN TLR$Q_OUTPUT_VALUE = "SYS$OUTPUT"
$	TLR$Q_OUTPUT_VALUE = F$PARSE (TLR$Q_OUTPUT_VALUE, "VMSTAILOR.LIS")
$	TLR$WARN_RETURN = "DIR_LOOP"
$	GROUP$LIST = PARAM$1
$	PROCESS_GROUP_RECORD = "DIR_TYPE_GROUP"
$	IF .NOT. TLR$Q_SIZE THEN GOTO OPEN_GROUP_FILE
$	OPEN /WRITE LISTFILE 'TLR$Q_OUTPUT_VALUE
$	PROCESS_GROUP_RECORD = "DIR_DEVCHECK"
$	PROCESS_GROUP_LIST = "DIR_GRAND_TOTALS"
$	GOTO OPEN_GROUP_FILE
$
$ DIR_TYPE_GROUP:
$	CLOSE DATAFILE
$	IF GRAND$GROUPS .EQ. 0 THEN OPEN /WRITE  LISTFILE 'TLR$Q_OUTPUT_VALUE
$	IF GRAND$GROUPS .NE. 0 THEN OPEN /APPEND LISTFILE 'TLR$Q_OUTPUT_VALUE
$	DISPLAY_L ""
$	DISPLAY_L ""
$	DISPLAY_L "Contents of ''TLR$GROUP' group"
$	X = F$FAO ("------------!''F$LENGTH (TLR$GROUP)'*-------")
$	DISPLAY_L X
$	CLOSE LISTFILE
$	APPEND 'DATAFILE' 'TLR$Q_OUTPUT_VALUE
$	GRAND$GROUPS = GRAND$GROUPS + 1
$	GOTO OPEN_GROUP_FILE
$
$ DIR_TYPE_TOTALS:
$	DEASSIGN SYS$OUTPUT
$	GOTO GET_COMMAND
$
$ DIR_DEVCHECK:
$	TLR$SRCROOT = "SYS$SYSROOT:"
$	IF TLR$GROUP .EQS. "REQUIRED" THEN GOTO DIR_LOOP
$	IF .NOT. F$GETDVI ("LIB$SYSDEVICE", "EXISTS") THEN GOTO ERROR_LIBNOTMOUNT
$	IF .NOT. F$GETDVI ("LIB$SYSDEVICE", "MNT") THEN GOTO ERROR_LIBNOTMOUNT
$	TLR$SRCROOT = "LIB$SYSROOT:"
$
$ DIR_LOOP:
$	READ DATAFILE FILENAME /END_OF_FILE=DIR_GROUP_END
$	FILENAME := 'FILENAME
$	TLR$SRCFILE = F$PARSE (FILENAME, TLR$SRCROOT)
$	IF F$PARSE (TLR$SRCFILE,,,"DIRECTORY") .NES. TLR$DIR THEN GOTO DIR_DIR
$
$ DIR_FILE:
$	IF F$SEARCH (TLR$SRCFILE) .EQS. "" THEN GOTO WARN_NOSUCHFILE
$	SIZE = F$FILE (TLR$SRCFILE, "ALQ")
$	DIR$FILES = DIR$FILES + 1
$	DIR$BLOCKS = DIR$BLOCKS + SIZE
$	DISPLAY_L "''F$FAO ("!15AS!5UL", FILENAME - TLR$DIR, SIZE)'"
$	GOTO DIR_LOOP
$
$ DIR_DIR:
$	TLR$DIR = F$PARSE (TLR$SRCFILE,,,"DIRECTORY") 
$	IF FIRSTDIR THEN GOTO DIR_NEW_DIR
$
$ DIR_DIR_TOTALS:
$	DISPLAY_L ""
$	DISPLAY_L "Total of ''DIR$BLOCKS' blocks, ''DIR$FILES' files."
$	DISPLAY_L ""
$	GROUP$FILES = GROUP$FILES + DIR$FILES
$	GROUP$BLOCKS = GROUP$BLOCKS + DIR$BLOCKS
$	DIR$FILES = 0
$	DIR$BLOCKS = 0
$	IF ENDGROUP THEN GOTO DIR_GROUP_TOTALS
$
$ DIR_NEW_DIR:
$	FIRSTDIR = TLR$FALSE
$	DISPLAY_L ""
$	DISPLAY_L "Directory = ''F$PARSE(TLR$SRCFILE,,,"DEVICE")'''TLR$DIR'"
$	GOTO DIR_FILE
$
$ DIR_GROUP_END:
$	ENDGROUP = TLR$TRUE
$	GOTO DIR_DIR_TOTALS
$
$ DIR_GROUP_TOTALS:
$	ENDGROUP = TLR$FALSE
$	FIRSTDIR = TLR$TRUE
$	DISPLAY_L -
"''TLR$GROUP' group total of ''GROUP$BLOCKS' blocks, ''GROUP$FILES' files"
$	DISPLAY_L ""
$	GRAND$BLOCKS = GRAND$BLOCKS + GROUP$BLOCKS
$	GRAND$FILES = GRAND$FILES + GROUP$FILES
$	GRAND$GROUPS = GRAND$GROUPS + 1
$	GROUP$BLOCKS = 0
$	GROUP$FILES = 0
$	GOTO CLOSE_GROUP_FILE
$
$	!
$	! Display grand totals if more than one group
$	!
$
$ DIR_GRAND_TOTALS:
$	IF GRAND$GROUPS .EQ. 1 THEN GOTO DIR_EXIT
$	DISPLAY_L "Grand total of ''GRAND$BLOCKS' blocks, ''GRAND$FILES' files"
$
$ DIR_EXIT:
$	CLOSE LISTFILE
$	GOTO GET_COMMAND
$
$ DIR_GROUPS:
$	IF PARAM$1 .NES. "" THEN GOTO ERROR_TOOMANYPARM
$	TLR$SRCSPEC = PARAM$1 
$	X = F$PARSE (TLR$SRCSPEC, F$LOGICAL ("SYS$UPDATE") + "*.TLR")
$	IF X .NES. "" THEN TLR$SRCSPEC = X
$	IF X .EQS. "" THEN GOTO ERROR_NOSUCHFILE
$	DIRECTORY 'TLR$SRCSPEC'
$	GOTO GET_COMMAND
$
$	!
$	! The DISMOUNT command dismounts the library disk
$	! and deassigns the library specific logical names.
$	!
$
$ DISMOUNT_START:
$	IF PARAM$2 .NES. "" THEN GOTO ERROR_TOOMANYPARM
$	IF PARAM$1 .EQS. "" THEN PARAM$1 = F$LOGICAL ("LIB$SYSDEVICE")
$	IF PARAM$1 .EQS. "" THEN GOTO ERROR_DEVICEREQ
$	PARAM$1 = PARAM$1 - ":" + ":"
$	IF .NOT. F$GETDVI (PARAM$1, "EXISTS") THEN GOTO ERROR_NOSUCHDEV
$	IF F$GETDVI (PARAM$1, "REFCNT") .GT. F$GETDVI (PARAM$1, "ALL") -
	   THEN GOTO ERROR_NONZEROREF
$	TLR$DISMOUNT 'PARAM$1
$	TLR$STATUS = $STATUS
$
$	TLR$DEASSIGN = "DEASSIGN /SYSTEM"
$	IF F$LOGICAL ("LIB$TOPSYS")	.NES. "" THEN TLR$DEASSIGN LIB$TOPSYS
$	IF F$LOGICAL ("LIB$SYSDEVICE")	.NES. "" THEN TLR$DEASSIGN LIB$SYSDEVICE
$	IF F$LOGICAL ("LIB$SYSROOT")	.NES. "" THEN TLR$DEASSIGN LIB$SYSROOT
$	IF F$LOGICAL ("LIB$SYSDISK")	.NES. "" THEN TLR$DEASSIGN LIB$SYSDISK
$
$	IF F$LOGICAL ("LIB$ERRORLOG")	.NES. "" THEN TLR$DEASSIGN LIB$ERRORLOG
$	IF F$LOGICAL ("LIB$HELP")	.NES. "" THEN TLR$DEASSIGN LIB$HELP
$	IF F$LOGICAL ("LIB$LIBRARY")	.NES. "" THEN TLR$DEASSIGN LIB$LIBRARY
$	IF F$LOGICAL ("LIB$MAINTENANCE").NES. "" THEN TLR$DEASSIGN LIB$MAINTENANCE
$	IF F$LOGICAL ("LIB$MANAGER")	.NES. "" THEN TLR$DEASSIGN LIB$MANAGER
$	IF F$LOGICAL ("LIB$MESSAGE")	.NES. "" THEN TLR$DEASSIGN LIB$MESSAGE
$	IF F$LOGICAL ("LIB$SHARE")	.NES. "" THEN TLR$DEASSIGN LIB$SHARE
$	IF F$LOGICAL ("LIB$SYSTEM")	.NES. "" THEN TLR$DEASSIGN LIB$SYSTEM
$	IF F$LOGICAL ("LIB$TEST")	.NES. "" THEN TLR$DEASSIGN LIB$TEST
$	IF F$LOGICAL ("LIB$UPDATE")	.NES. "" THEN TLR$DEASSIGN LIB$UPDATE
$
$ DISMOUNT_EXIT:
$	GOTO GET_COMMAND
$
$	!
$	! The EXIT command exits from the command procedure and
$	! returns to DCL prompt level.
$	!
$
$ EXIT_START:
$	IF F$LOGICAL ("DATAFILE") .NES. "" THEN CLOSE DATAFILE
$	IF F$LOGICAL ("LISTFILE") .NES. "" THEN CLOSE LISTFILE
$	IF TLR$VERIFY THEN SET VERIFY
$	EXIT (TLR$STATUS .OR. STS$M_INHIB_MSG)
$
$	!
$	! The HELP command invokes VMS help with the tailoring
$	! help library.
$	!
$
$ HELP_START:
$	TLR$DEFINE = "DEFINE /USER"
$	TLR$DEFINE SYS$INPUT 'TLR$INPUT'
$	TLR$HELP = "HELP"
$	IF FOREIGN$COMMAND .EQS. "" THEN TLR$HELP = TLR$HELP + "/NOPROMPT"
$	IF F$SEARCH ("SYS$HELP:VMSTLRHLP.HLB") .NES. "" THEN GOTO HELP_EXECUTE
$	IF .NOT. F$GETDVI ("LIB$SYSDEVICE", "EXISTS") THEN GOTO ERROR_NOHELP
$	IF .NOT. F$GETDVI ("LIB$SYSDEVICE", "MNT") THEN GOTO ERROR_NOHELP
$	TLR$DEFINE VMSTLRHLP LIB$HELP:VMSTLRHLP.HLB
$
$ HELP_EXECUTE:
$	TLR$HELP /LIBRARY=VMSTLRHLP 'FOREIGN$COMMAND'
$	GOTO GET_COMMAND
$
$	!
$	! The INSTALL command copies files from the OPTIONAL distribution
$	! volume to the LIBRARY disk using BACKUP.
$	!
$
$ INSTALL_START:
$	IF PARAM$1 .EQS. "" THEN GOTO ERROR_GROUPREQ
$	IF PARAM$2 .NES. "" THEN GOTO ERROR_TOOMANYPARM
$	IF .NOT. F$GETDVI ("LIB$SYSDEVICE", "EXISTS") THEN GOTO ERROR_LIBNOTMOUNT
$	IF .NOT. F$GETDVI ("LIB$SYSDEVICE", "MNT") THEN GOTO ERROR_LIBNOTMOUNT
$	IF F$GETDVI ("LIB$SYSDEVICE", "SWL") THEN GOTO ERROR_LIBPROTECT
$	IX1 = 0
$	IX2 = 0
$	TLR$COUNT = 0
$	SELECT_LIST_0 = ""
$
$	TLR$BACKUP = "BACKUP /REPLACE "
$	IF TLR$Q_LOG THEN TLR$BACKUP = TLR$BACKUP + " /LOG"
$	TLR$DEFINE = "DEFINE "
$	TLR$DEASSIGN = "DEASSIGN "
$	PROCESS_GROUP_RECORD = "INSTALL_LOOP"
$	PROCESS_GROUP_LIST = "INSTALL_RESTORE"
$	GROUP$LIST = PARAM$1
$	GOTO OPEN_GROUP_FILE
$
$ INSTALL_LOOP:
$	READ DATAFILE FILENAME /END_OF_FILE=CLOSE_GROUP_FILE
$	FILENAME := 'FILENAME
$	FILENAME = "[SYS0." + (FILENAME - "[")
$	TLR$DIR = F$PARSE (FILENAME,,,"DIRECTORY")
$	FILENAME = FILENAME - TLR$DIR
$	IF TLR$DIR .EQS. F$LOGICAL ("$$''TLR$COUNT'") THEN GOTO INSTALL_BUILD_LIST
$	TLR$COUNT = TLR$COUNT + 1
$	TLR$DEFINE $$'TLR$COUNT' 'TLR$DIR'
$
$ INSTALL_BUILD_LIST:
$	SELECT_LIST_'IX1' = SELECT_LIST_'IX1' + TLR$COMMA + "$$" + "''TLR$COUNT'" + TLR$COLON + FILENAME
$	IF F$LENGTH (SELECT_LIST_'IX1') .LT. 400 THEN GOTO INSTALL_LOOP
$	IX1 = IX1 + 1
$	SELECT_LIST_'IX1' = ""
$	GOTO INSTALL_LOOP
$
$ INSTALL_RESTORE:
$	SELECT_LIST_'IX2' = SELECT_LIST_'IX2' - TLR$COMMA
$	IF SELECT_LIST_'IX2' .EQS. "" THEN GOTO GET_COMMAND
$	TLR$X_BACKUP = TLR$BACKUP + " " -
		+ "SYS$SYSDEVICE:[000000]OPTIONAL /SAVE " -
		+ "LIB$SYSDEVICE:[*] " -
		+ "/SELECT=(" + SELECT_LIST_'IX2' + ")"
$ 	TLR$X_BACKUP
$	IX2 = IX2 + 1
$	IF IX2 .LE. IX1 THEN GOTO INSTALL_RESTORE'
$
$ INSTALL_CANCEL_LOGICAL:
$	TLR$DEASSIGN $$'TLR$COUNT'
$	TLR$COUNT = TLR$COUNT - 1
$	IF TLR$COUNT .GT. 0 THEN GOTO INSTALL_CANCEL_LOGICAL
$	GOTO GET_COMMAND
$
$	!
$	! The MOUNT command mounts the library disk and
$	! defines the library specific logical name tree.
$	!
$
$ MOUNT_START:
$	IF PARAM$1 .EQS. "" THEN GOTO ERROR_DEVICEREQ
$	IF PARAM$3 .NES. "" THEN GOTO ERROR_TOOMANYPARM
$	!
$	! Removed any concealed device and/or rooted directory syntax
$	!
$	PARAM$1 = PARAM$1 - "_" - "_"
$	PARAM$1 = F$EXTRACT (0, F$LOCATE ("[", PARAM$1), PARAM$1)
$	PARAM$1 = PARAM$1 - ":" + ":"
$	IF PARAM$2 .EQS. "" THEN PARAM$2 = "VAXVMSLB''VERSION'"
$	TLR$MOUNT = "MOUNT /NOASSIST /SYSTEM /NOWRITE"
$	IF TLR$Q_WRITE THEN TLR$MOUNT = "MOUNT /NOASSIST /SYSTEM"
$	TLR$MOUNT 'PARAM$1' 'PARAM$2'
$	TLR$STATUS = $STATUS
$	IF .NOT. TLR$STATUS THEN GOTO ERROR_RUNDOWN
$	IF .NOT. TLR$Q_WRITE .OR. .NOT. F$GETDVI (PARAM$1, "SWL") -
	    THEN GOTO MOUNT_DEFINE
$	TLR$DISMOUNT = "DISMOUNT /NOUNLOAD"
$	TLR$DISMOUNT 'PARAM$1'
$	GOTO ERROR_NOWRITE
$
$ MOUNT_DEFINE:
$	TLR$DEFINE = "DEFINE /SYSTEM"
$	TOPSYS = F$LOGICAL ("SYS$TOPSYS")
$	TLR$DEFINE LIB$TOPSYS 		'TOPSYS' 
$	IF TOPSYS .NES. "" THEN TOPSYS = TOPSYS + "."
$	TLR$DEFINE LIB$SYSDEVICE	__'PARAM$1'
$	TLR$DEFINE LIB$SYSROOT 		__'PARAM$1'['TOPSYS']
$	TLR$DEFINE LIB$SYSDISK 		LIB$SYSROOT:
$
$	TLR$DEFINE LIB$ERRORLOG 	LIB$SYSROOT:[SYSERR]
$	TLR$DEFINE LIB$HELP 		LIB$SYSROOT:[SYSHLP]
$	TLR$DEFINE LIB$LIBRARY 		LIB$SYSROOT:[SYSLIB]
$	TLR$DEFINE LIB$MAINTENANCE 	LIB$SYSROOT:[SYSMAINT]
$	TLR$DEFINE LIB$MANAGER 		LIB$SYSROOT:[SYSMGR]
$	TLR$DEFINE LIB$MESSAGE 		LIB$SYSROOT:[SYSMSG]
$	TLR$DEFINE LIB$SHARE 		LIB$SYSROOT:[SYSLIB]
$	TLR$DEFINE LIB$SYSTEM 		LIB$SYSROOT:[SYSEXE]
$	TLR$DEFINE LIB$TEST 		LIB$SYSROOT:[SYSTEST]
$	TLR$DEFINE LIB$UPDATE 		LIB$SYSROOT:[SYSUPD]
$
$ MOUNT_EXIT:
$	GOTO GET_COMMAND
$
$	!
$	! The RECORD command creates a list of all library files
$	! found on the system disk and then deletes them.
$	!
$ RECORD_START:			! "SAVE" renamed to "RECORD"
$ SAVE_START:
$	IF .NOT. F$GETDVI ("LIB$SYSDEVICE", "EXISTS") THEN GOTO ERROR_LIBNOTMOUNT
$	IF .NOT. F$GETDVI ("LIB$SYSDEVICE", "MNT") THEN GOTO ERROR_LIBNOTMOUNT
$	IF PARAM$3 .NES. "" THEN GOTO ERROR_TOOMANYPARM
$	REVDCOUNT = 0
$	SAVECOUNT = 0
$	SAVEFILE = F$PARSE (PARAM$1, F$LOGICAL ("SYS$UPDATE") + "RECORDED.TLR")
$	REVDFILE =  F$PARSE (PARAM$2, F$LOGICAL ("SYS$UPDATE") + "REVISED.TLR")
$	X = SAVEFILE
$	OPEN /WRITE SAVEFILE 'SAVEFILE /ERROR=ERROR_OPENOUT
$	X = REVDFILE
$	IF PARAM$2 .NES. "" THEN -
		OPEN /WRITE REVDFILE 'REVDFILE /ERROR=ERROR_OPENOUT
$
$ SAVE_LOOP:
$	X = F$SEARCH ("LIB$SYSROOT:[*...]*.*;", 2)
$	IF X .EQS. "" THEN GOTO SAVE_EXIT
$	Y = F$PARSE ("SYS$SYSROOT:;", X)
$	Y = F$SEARCH (Y)
$	IF Y .EQS. "" THEN GOTO SAVE_LOOP
$	IF F$PARSE (X,,,"TYPE") .EQS. ".DIR" THEN GOTO SAVE_LOOP
$	FILESPEC = X - F$PARSE (X,,,"DEVICE") - F$PARSE (X,,,"VERSION")
$	IF F$FILE (X, "RDT") .NES. F$FILE (Y, "RDT") THEN -
		GOTO SAVE_DATEMISMATCH
$	SAVECOUNT = SAVECOUNT + 1
$	WRITE SAVEFILE FILESPEC
$	GOTO SAVE_LOOP
$
$ SAVE_DATEMISMATCH:
$	REVDCOUNT = REVDCOUNT + 1
$	IF PARAM$2 .EQS. "" THEN GOTO SAVE_WARNING
$	WRITE REVDFILE FILESPEC
$	GOTO SAVE_LOOP
$
$ SAVE_WARNING:
$	DISPLAY "Warning -- revision dates disagree."
$	DISPLAY "           ''X' -- ''F$FILE (X, "RDT")'"
$	DISPLAY "           ''Y' -- ''F$FILE (Y, "RDT")'"
$	DISPLAY "File not recorded."
$	GOTO SAVE_LOOP
$
$ SAVE_EXIT:
$	DISPLAY "''SAVECOUNT' library files recorded in ''SAVEFILE'."
$	CLOSE SAVEFILE
$	IF F$LOGICAL ("REVDFILE") .NES. "" THEN GOTO SAVE_EXIT_2
$	IF REVDCOUNT .NE. 0 THEN -
	   DISPLAY "''REVDCOUNT' revised library files detected."
$	GOTO GET_COMMAND
$
$ SAVE_EXIT_2:
$	DISPLAY "''REVDCOUNT' revised library files recorded in ''REVDFILE'."
$	CLOSE REVDFILE
$	GOTO GET_COMMAND
$
$	!
$	! The SEARCH command searches all tailoring files for the
$	! specified string
$	!
$
$ SEARCH_START:
$	IF PARAM$2 .NES. "" THEN GOTO ERROR_TOOMANYPARM
$	IF PARAM$1 .EQS. "" THEN GOTO ERROR_FILENAMEREQ
$	X = PARAM$1
$	IF    F$LOCATE ("]", X) .GE. F$LENGTH (X) -
	.AND. F$LOCATE (".", X) .GE. F$LENGTH (X) -
	   THEN X = "]" + X
$	TLR$DEFINE = "DEFINE /USER "
$	IF F$SEARCH ("SYS$SYSTEM:SEARCH.EXE") .NES. "" THEN GOTO SEARCH_EXECUTE
$	IF .NOT. F$GETDVI ("LIB$SYSDEVICE", "EXISTS") THEN GOTO ERROR_NOSEARCH
$	IF .NOT. F$GETDVI ("LIB$SYSDEVICE", "MNT") THEN GOTO ERROR_NOSEARCH
$	TLR$DEFINE SEARCH LIB$SYSTEM:SEARCH
$
$ SEARCH_EXECUTE:
$	SEARCH SYS$UPDATE:*.TLR "''X'"
$	GOTO GET_COMMAND
$
$	!
$	! Error messages and handlers
$	!
$
$ ERROR_AMBIGWRD:
$	DISPLAY "%TAILOR-E-AMBIGWRD, ''T' is an ambiguous word"
$	GOTO ERROR_RUNDOWN
$
$ ERROR_AMBIG_GROUP:
$	DISPLAY "%TAILOR-E-AMBIGRP, ''TLR$GROUP' is an ambiguous group name"
$	GOTO ERROR_RUNDOWN
$
$ ERROR_BADCOMMA:
$	DISPLAY "%TAILOR-E-BADCOMMA, invalid comma in command"
$	GOTO INFO_HELPVERB
$
$ ERROR_CTRLY:
$	ON CONTROL_Y THEN GOTO ERROR_CTRLY
$	DISPLAY "%TAILOR-E-CTRLY, function aborted by CTRL/Y"
$	IF P1$P8 .EQS. "" THEN DISPLAY "-TAILOR-I-USEEXIT, type ""EXIT"" to exit"
$	GOTO ERROR_RUNDOWN
$
$ ERROR_DEVICEREQ:
$	DISPLAY "%TAILOR-E-DEVICEREQ, device must be specified"
$	GOTO INFO_HELPVERB
$
$ ERROR_FILENAMEREQ:
$	DISPLAY "%TAILOR-E-FILENAMEREQ, a filename must be specified"
$	GOTO INFO_HELPVERB
$
$ ERROR_GROUPREQ:
$	DISPLAY "%TAILOR-E-GROUPREQ, a group must be specified"
$	GOTO INFO_HELPVERB
$
$ ERROR_LIBNOTMOUNT:
$	DISPLAY "%TAILOR-E-LIBNOTMOUNT, the LIBRARY disk must be mounted"
$	GOTO ERROR_RUNDOWN
$
$ ERROR_LIBPROTECT:
$	DISPLAY "%TAILOR-E-LIBPROTECT, the LIBRARY disk must be writeable"
$	DISPLAY "-TAILOR-I-HLPMOUNTWRT, type ""HELP MOUNT /WRITE"""
$	GOTO ERROR_RUNDOWN
$
$ ERROR_NODELREQ:
$	DISPLAY "%TAILOR-E-NODELREQ, the REQUIRED file group cannot be deleted"
$	GOTO CLOSE_GROUP_FILE
$
$ ERROR_NOHELP:
$	DISPLAY "%TAILOR-E-NOHELP, help not available"
$	GOTO ERROR_LIBNOTMOUNT
$
$ ERROR_NOSEARCH:
$	DISPLAY "%TAILOR-E-NOSEARCH, search not available"
$	GOTO ERROR_LIBNOTMOUNT
$
$ ERROR_NONZEROREF:
$	DISPLAY "%TAILOR-E-NONZEROREF, open files on device, not dismounted"
$	SHOW DEVICE /FILES 'PARAM$1
$	DISPLAY ""
$	DISPLAY "%TAILOR-I-REISSUE, correct the situation and reissue the command"
$	GOTO ERROR_RUNDOWN
$
$ ERROR_NOQUAL:
$	DISPLAY "%TAILOR-E-NOQUAL, no qualifiers allowed on the ""''TLR$VERB'"" command"
$	GOTO ERROR_RUNDOWN
$
$ ERROR_NOSUCHDEV:
$	DISPLAY "%TAILOR-E-NOSUCHDEV, no such device as ''PARAM$1'"
$	GOTO ERROR_RUNDOWN
$
$ ERROR_NOSUCHDIR:
$	DISPLAY "%TAILOR-E-NOSUCHDIR, expected directory ""''TLR$DIR'"" not found"
$	GOTO ERROR_RUNDOWN
$
$ ERROR_NOSUCHFILE:
$	DISPLAY "%TAILOR-E-NOSUCHFILE, no files matching the specification ""''TLR$SRCSPEC'"" were found"
$	GOTO ERROR_RUNDOWN
$
$ ERROR_NOSUCHGROUP:
$	DISPLAY "%TAILOR-E-NOSUCHGROUP, group file ""''DATAFILE'"" not found"
$	DISPLAY "-TAILOR-I-HELPGROUPS, type ""DIR /GROUPS"" for a list of tailoring groups"
$	GOTO ERROR_RUNDOWN
$
$ ERROR_NOWILDCARDS:
$	DISPLAY "%TAILOR-E-NOWILDCARDS, wildcards not allowed in group names"
$	GOTO ERROR_RUNDOWN
$
$ ERROR_NOWRITE:
$	DISPLAY "%TAILOR-E-NOWRITE, device is not write enabled"
$	DISPLAY "-TAILOR-I-DISMOUNT, device dismounted"
$	GOTO ERROR_RUNDOWN
$
$ ERROR_OPENIN:
$	DISPLAY "%TAILOR-E-OPENIN, error opening ''X' as input"
$	GOTO ERROR_RUNDOWN
$
$ ERROR_OPENOUT:
$	DISPLAY "%TAILOR-E-OPENOUT, error opening ''X' as output"
$	GOTO ERROR_RUNDOWN
$
$ INFO_HELPVERB:
$	DISPLAY "-TAILOR-I-HELPVERB, type ""HELP ''TLR$VERB'"""
$	GOTO ERROR_RUNDOWN
$
$ ERROR_RUNDOWN:
$	SET NOON
$	IF TLR$STATUS THEN TLR$STATUS = 2	! Set error if not already set
$	IF F$LOGICAL ("DATAFILE") .NES. "" THEN CLOSE DATAFILE
$	IF F$LOGICAL ("LISTFILE") .NES. "" THEN CLOSE LISTFILE
$	IF F$LOGICAL ("SAVEFILE")  .NES. "" THEN CLOSE SAVEFILE
$	IF F$LOGICAL ("REVDFILE")  .NES. "" THEN CLOSE REVDFILE
$	X = F$SEARCH ("", 1)
$	X = F$SEARCH ("", 2)
$	DISPLAY ""
$	ON ERROR THEN GOTO ONERR_RUNDOWN
$	SET ON
$	GOTO GET_COMMAND
$
$ ERROR_TOOMANYPARM:
$	DISPLAY "%TAILOR-E-TOOMANYPARM, too many parameters"
$	GOTO INFO_HELPVERB
$
$ ERROR_UNRECCMD:
$	DISPLAY "%TAILOR-E-UNRECCMC, ""''T'"" is an unrecognized command"
$	DISPLAY "-TAILOR-I-USEHELP, type ""HELP"" for more information"
$	GOTO ERROR_RUNDOWN
$
$ ERROR_UNRECQUAL:
$	DISPLAY "%TAILOR-E-UNRECQUAL, ""''T'"" not valid for this command"
$	GOTO INFO_HELPVERB
$
$ ONERR_RUNDOWN:
$	TLR$STATUS = $STATUS
$	SET NOON
$	IF (TLR$STATUS .AND. STS$M_INHIB_MSG) .EQ. 0 -
	   THEN DISPLAY "''F$MESSAGE (TLR$STATUS)'"
$	GOTO ERROR_RUNDOWN
$
$ WARN_NOBACKUP:
$	DISPLAY "%TAILOR-W-NOTDELETED, ""''TLR$SRCFILE'"" not deleted"
$	DISPLAY "-TAILOR-I-NOBACKUP, no backup copy on device ""''TLR$SRCROOT'"""
$	GOTO WARNING_EXIT
$
$ WARN_NOSUCHFILE:
$	DISPLAY "%TAILOR-W-EXPNOTFND, expected file ""''TLR$SRCFILE'"" not found"
$	GOTO WARNING_EXIT
$
$ WARNING_EXIT:
$	IF TLR$WARN_RETURN .NES. "" THEN GOTO 'TLR$WARN_RETURN
$	GOTO ERROR_RUNDOWN
