%TITLE 'NML service function routines'
MODULE NML$SERVICE (
		LANGUAGE (BLISS32),
		ADDRESSING_MODE (NONEXTERNAL=LONG_RELATIVE),
		ADDRESSING_MODE (EXTERNAL=LONG_RELATIVE),
		IDENT = 'V03-009'
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:  DECnet-VAX V2.0 Network Management Listener
!
! ABSTRACT:
!
!	This module contains routines to handle all line service functions
!	such as load, trigger, dump, and line loop.
!
! ENVIRONMENT:  VAX/VMS Operating System
!
! AUTHOR:  Distributed Systems Software Engineering
!
! CREATION DATE:  21-JUL-1980
!
! MODIFIED BY:
!
!	V03-009	MKP0006		Kathy Perko	21-April-1982
!		Add NET.L32 as a library (to get the NFB definitions)
!
!	V03-001	LMK0003		Len Kawell	03-Mar-1982
!		Add VMS image header hanndling for downline loading VAX's.
!
!	V02-007	MKP0005		Kathy Perko	10-Jan-1982
!		Make the load file/MOP message buffer larger so the secondary
!		boot (which must be sent to the target in one piece) can be
!		large enough to handle the multipoint loaders.  Also, fix
!		the secondary's image size and transfer address so they are
!		6, as specified in the MOP spec.
!
!	V02-006	MKP0004		Kathy Perko	1-Jan_1982
!		Add DMF to device list for converting Network Management
!		device codes to their corresponding ASCII strings.
!
!	V02-005	MKP0003		Kathy Perko	16-Dec-1981
!		Add more retries to various loops in down line load.
!		Also, move error signalling for reading load files to the
!		routine that actually does the reads in the module
!		NMLSRVFIO.
!
!	V02-004	MKP0002		Kathy Perko	02-Nov-1981
!		Fix up circuit dump so that the index into the dump file
!		record is calculated correctly.  Also, add secondary error
!		status to RMS error reporting.
!
!	V02-003 MKP0001		Kathy Perko	03-Oct-1981
!		Fix bug in auto service functions so that the load
!		type is set up to circuit.
!
!	V02-002	LMK0002		Len Kawell	02-Sep-1981
!		Modify for new NETACP interface and add upline dump.
!
!	V02-001	LMK0001		Len Kawell	28-Jul-1981
!		Modify to use circuits instead of lines.
!--


%SBTTL 'Declarations'

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    NML$OPERSERVICE	: NOVALUE,
    NML$AUTOSERVICE	: NOVALUE,
    NML$ACTIVELOOP	: NOVALUE,
    NML$DUMP		: NOVALUE,
    NML$LOAD		: NOVALUE,
    NML_MBLKLOAD,
    NML_SECLOAD,
    NML_TRIGGERBOOT	: NOVALUE,
    NML_OPENLOADFILE,
    NML_READLOADFILE	: NOVALUE,
    NML_CHECK_LABEL_BLK	: NOVALUE,
    NML$PASSIVELOOP	: NOVALUE,
    NML$TRIGGER		: NOVALUE,
    NML$SERVICEHANDLER,
    NML$AUTOHANDLER,
    NML_LOGEVENT	: NOVALUE,
    NML$LOOPHANDLER,
    NML$LOADHANDLER,
    NML_CHKMOPERROR	: NOVALUE;

!
! INCLUDE FILES:
!

LIBRARY 'LIB$:NMLLIB.L32';
LIBRARY 'SHRLIB$:NMALIBRY.L32';
LIBRARY 'SHRLIB$:EVCDEF.L32';
LIBRARY 'SHRLIB$:NET.L32';
LIBRARY 'SYS$LIBRARY:LIB.L32';

!
! MACROS:
!

!
! EQUATED SYMBOLS:
!

!
! NML$K_LOADBUFSIZ must be large enough to accomodate the entire secondary
! load image, since the secondary loader is always sent in one transmit.
! NML$K_SEGBLKCNT is used to determine the number of 32 word blocks in
! each MOP transmit for a multiblock load (tertiary load and operating
! system load).
!
LITERAL
    NML$K_LOADBUFSIZ = 1024,
    NML$K_SEGBLKCNT = 4;	! Number of 32-word blocks in a multiblock
				!	load segment

!
! OWN STORAGE:
!

OWN
    NML$L_BASEADR,			! Base address of load segment
    NML$L_BLKCNT,			! Number of blocks in buffer
    NML$L_LOADSIZE,			! Size of image in 32-word blocks
    NML$L_TRANSFER,			! Image transfer address
    NML$B_AUTOFLAG  : BYTE,		! Autoservice flag (TRUE=>autoservice)
    NML$B_PROGRAM   : BYTE,		! Load program type
    NML$W_PGMDETAIL : WORD,		! Program error detail
    NML$W_SRVTIMER  : WORD,		! Service I/O timer
    NML$W_HOSTADR   : WORD		! Host node address
		      INITIAL (0),
    NML$T_HOSTNAME  : BBLOCK [6],	! Host name buffer
    NML$Q_HOSTDSC   : DESCRIPTOR
		      INITIAL (0, NML$T_HOSTNAME),
    NML$Q_SRVCIRDSC : DESCRIPTOR;	! Descriptor of service device id
					!  in the data base
!
! The following buffers are used for downline loading.
!
! NML$T_LOADBUFFER is used for transmitting memory image data.  There
! are 6 bytes of overhead at the beginning of the buffer to hold MOP
! message information.  There are 4 bytes of overhead at the end of
! the buffer to contain the transfer address if it is needed and the
! image data takes up the entire buffer.  NML$T_READBUFFER is the
! center of NML$T_LOADBUFFER.  The image data is read from disk a block 
! at a time, and transmitted piece by piece directly
! from this buffer which is why the overhead bytes are required.
! The NML$Q_DATADSC is used to describe the extent of the image data
! read in to NML$T_READBUFFER.
! 
OWN
    NML$T_LOADBUFFER : BBLOCK [6 + NML$K_LOADBUFSIZ + 4];
BIND
    NML$T_READBUFFER = NML$T_LOADBUFFER + 6
		     : BBLOCK [NML$K_LOADBUFSIZ],
    NML$Q_LOADBFDSC  = UPLIT (6 + NML$K_LOADBUFSIZ + 4, NML$T_LOADBUFFER)
		     : DESCRIPTOR,
    NML$Q_READBFDSC  = UPLIT (NML$K_LOADBUFSIZ, NML$T_READBUFFER)
		     : DESCRIPTOR;
OWN
    NML$Q_DATADSC    : DESCRIPTOR
		       INITIAL (0, NML$T_READBUFFER);
!
! Information for event logging during autoservice operations.
!
! Three different events can be logged:
!
!	Automatic line service		0.3
!	Aborted service request		0.7
!	Passive loopback		0.6
!
OWN
    NML$B_EVT_POPR : BYTE,		! Passive loopback operation code
    NML$B_EVT_PRSN : BYTE,		! Aborted service request reason code
    NML$B_EVT_PSER : BYTE,		! Automatic line service request code
    NML$W_EVT_CODE : WORD;		! Event code

!
! EXTERNAL REFERENCES:
!

$NML_EXTDEF;				! Define common external data
$NML_SRVDEF;				! Define external service data

EXTERNAL LITERAL
    NML$_ALPBFOVF,
    NML$_IMGRECSIZ,
    NML$_UNSMOPDEV;

EXTERNAL
    NML$AB_NPA_BLK : $NPA_BLKDEF,
    NML$NPA_DUMP,
    NML$NPA_LOAD,
    NML$NPA_CIRLOOP,
    NML$NPA_MOPINIT,
    NML$NPA_MOPLOAD,
    NML$NPA_TRIGGER;
 
EXTERNAL ROUTINE
    NMA$NPARSE,
    NMA$SEARCHFLD,
    NML$ADDSRVFLDS,
    NML$BLD_REPLY,
    NML$BLDMOPEMM,
    NML$BLDMOPMMR,
    NML$CHKBUFFER,
    NML$DEBUG_MSG,
    NML$DEBUG_TXT,
    NML$ERROR_1,
    NML$ERROR_2,
    NML$FREEBUFFER,
    NML$GETBUFFER,
    NML$GETSRVDATA,
    NML$GETSRVHOST,
    NML$GETSRVTIMER,
    NML$INITBUFFER,
    NML$MOPCLOSE,
    NML$MOPSETSUBSTATE,
    NML$MOPOPEN,
    NML$MOPSEND,
    NML$MOPSNDRCV,
    NML$NETQIO,
    NML$SRVCLOSE,
    NML$SRVOPEN,
    NML$SRVREAD,
    NML$SRVREWIND,
    NML$SRVWRITE;



%SBTTL 'MOP Device Table'
!
! MOP device table symbol and macro definitions.
!
MACRO
    MDT$B_DEVTYPE   = 0,0,8, 0 %,
    MDT$A_DEVSTRING = 1,0,32,0 %;

LITERAL
    MDT$K_ENTRYLEN = 5;

MACRO
    $MOPDEV (SYM, NAM) =
	SWITCHES UNAMES;
	PSECT OWN = NML$MOPDEVNAMES;
	OWN
	    STR : VECTOR [%CHARCOUNT (%ASCIC NAM), BYTE]
		  INITIAL (BYTE (%ASCIC NAM))
		  ALIGN (0);
	PSECT OWN = NML$MOPDEVTABLE;
	OWN
	    IND : VECTOR [MDT$K_ENTRYLEN, BYTE]
		  INITIAL (BYTE (SYM), LONG (STR))
		  ALIGN (0);
	UNDECLARE STR, IND;
	SWITCHES NOUNAMES;
	%ASSIGN (MDT$K_MOPDEVCNT, MDT$K_MOPDEVCNT + 1);
	PSECT OWN = $OWN$;
    %;
!
! Initialize MOP device table and psects.
!
PSECT
    OWN = NML$MOPDEVTABLE (NOWRITE, ALIGN (0));

OWN
    NML$AB_MOPDEVICES : BBLOCKVECTOR [0, MDT$K_ENTRYLEN];

PSECT
    OWN = NML$MOPDEVNAMES (NOWRITE, ALIGN (0));

OWN
    NML$AB_MOPDEVNAMES : VECTOR [0, BYTE];

PSECT
    OWN = $OWN$;

COMPILETIME
    MDT$K_MOPDEVCNT = 0;
!
! This table contains the ASCII device name strings associated with a
! given MOP device code.
!
$MOPDEV (NMA$C_SOFD_DMC, 'DMC');
$MOPDEV (NMA$C_SOFD_DUP, 'DUP');
$MOPDEV (NMA$C_SOFD_DU,  'DU');
$MOPDEV (NMA$C_SOFD_DP,  'DP');
$MOPDEV (NMA$C_SOFD_DQ,  'DQ');
$MOPDEV (NMA$C_SOFD_DL,  'DL');
$MOPDEV (NMA$C_SOFD_DA,  'DA');
$MOPDEV (NMA$C_SOFD_DTE, 'DTE');
$MOPDEV (NMA$C_SOFD_KL8, 'KL');
$MOPDEV (NMA$C_SOFD_DMP, 'DMP');
$MOPDEV (NMA$C_SOFD_DMV, 'DMV');
$MOPDEV (NMA$C_SOFD_DPV, 'DPV');
$MOPDEV (NMA$C_SOFD_DMF, 'DMF');
!
! Clean up.
!
UNDECLARE
    %QUOTE $MOPDEV;

%SBTTL 'NML$OPERSERVICE  Parse the service request (NICE) message'
GLOBAL ROUTINE NML$OPERSERVICE : NOVALUE =
 
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine parses the NICE service request message and
!	builds the permanent data base record to hold the data.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NML$B_AUTOFLAG has a value of FALSE.
!	NML$W_SRVTIMER is set according to the volatile data base information.
!	NML$Q_SRVCIRDSC describes the service circuit name.
!	NML$GQ_SRVDATDSC describes the service parameter information from the
!	    volatile data base and from the NICE message.
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Signal errors.
!
! SIDE EFFECTS:
!
!	The service circuit is open for MOP operations.
!
!--
 
    BEGIN

    LOCAL
	NML_A_NPATBL,			! Pointer to NPARSE table
	NML_A_ROUTINE,			! Address of service routine
	NML_L_MSGSIZE,			! Size of response message
	NML_L_STATUS;			! General purpose status;

!
! Enable condition handler for cleanup.
!
    ENABLE NML$SERVICEHANDLER;
!
! Indicate that this is not an autoservice function.
!
    NML$B_AUTOFLAG = FALSE;
!
! Select parse table according to function code.
!
    SELECTONEU .NML$GB_FUNC OF
	SET

	[NMA$C_FNC_LOA]:		! Load
	    BEGIN

	    NML_A_ROUTINE = NML$LOAD;
	    NML_A_NPATBL = NML$NPA_LOAD;

	    END;

	[NMA$C_FNC_TRI]:		! Trigger
	    BEGIN

	    NML_A_ROUTINE = NML$TRIGGER;
	    NML_A_NPATBL = NML$NPA_TRIGGER;

	    END;

	[NMA$C_FNC_TES]:		! Loop circuit
	    BEGIN

	    NML_A_ROUTINE = NML$ACTIVELOOP;
	    NML_A_NPATBL = NML$NPA_CIRLOOP;

	    END;

	[NMA$C_FNC_DUM]:		! Dump
	    BEGIN

	    NML_A_ROUTINE = NML$DUMP;
	    NML_A_NPATBL = NML$NPA_DUMP;

	    END;

	[OTHERWISE]:			! Invalid function
	    BEGIN

	    NML$ERROR_1 (NMA$C_STS_FUN);

	    END;

	TES;
!
! Parse the command message.
!
    NMA$NPARSE (NML$AB_NPA_BLK, .NML_A_NPATBL);
!
! If successful parse then build the data base.
!
    NML$GETSRVDATA ();			! Build data base from volatile
    NML$ADDSRVFLDS ();			! Add data from command message
!
! Get the service circuit id from the data base.
!
    NML$Q_SRVCIRDSC [DSC$A_POINTER] = 0;
    IF NOT NMA$SEARCHFLD (NML$GQ_SRVDATDSC,
			  NMA$C_PCNO_SLI,
			  NML$Q_SRVCIRDSC [0,0,32,0],
			  NML$Q_SRVCIRDSC [DSC$A_POINTER])
    THEN
	BEGIN

	NML$AB_MSGBLOCK [MSB$L_FLAGS]  = MSB$M_DET_FLD;
	NML$AB_MSGBLOCK [MSB$B_CODE]   = NMA$C_STS_PMS;
	NML$AB_MSGBLOCK [MSB$W_DETAIL] = NMA$C_PCNO_SLI;
	NML$BLD_REPLY (NML$AB_MSGBLOCK, NML_L_MSGSIZE);
	$SIGNAL_MSG (NML$AB_SNDBUFFER, .NML_L_MSGSIZE);

	END;
!
! Get the service timer from the volatile data base entry for this circuit.
!
    NML$GETSRVTIMER (NML$Q_SRVCIRDSC, NML$W_SRVTIMER);
!
! Open the circuit for the service operation.
!
    NML_L_STATUS = NML$MOPOPEN (NML$Q_SRVCIRDSC, .NML$W_SRVTIMER);
    NML_CHKMOPERROR (.NML_L_STATUS);
!
! Dispatch the function to the service routine.
! (The service routine will signal the status and cleanup will
! be performed by the condition handler.)
!
    (.NML_A_ROUTINE) ();

    END;				! End of NML$OPERSERVICE


%SBTTL 'NML$AUTOSERVICE  Automatic service function request'
GLOBAL ROUTINE NML$AUTOSERVICE : NOVALUE =
 
!++
! FUNCTIONAL DESCRIPTION:
!	This routine performs initialization and dispatching for all
!	automatic service requests.
!
! IMPLICIT OUTPUTS:
!	NML$B_AUTOFLAG has a value of TRUE.
!	NML$W_SRVTIMER is set according to the volatile data base information.
!	NML$Q_SRVCIRDSC describes the service circuit name.
!	NML$GQ_SRVDATDSC describes the service parameter information from the
!	    volatile data base and from the NICE message.
!
! ROUTINE VALUE:
! COMPLETION CODES:
!	Signal errors.
!
!--
 
BEGIN

LOCAL
    MSGSIZE,
    RCVDSC  : DESCRIPTOR,
    SNDDSC  : DESCRIPTOR,
    STATUS;

!
! Enable condition handler for cleanup.
!
ENABLE NML$AUTOHANDLER;
!
! Indicate that this is an autoservice function.
!
NML$B_AUTOFLAG = TRUE;
!
! Set up the event in case of an aborted service request.
!
NML$W_EVT_CODE = EVC$C_NMA_ABS;	! Event code (aborted service request)
NML$B_EVT_PRSN = EVC$C_NMA_PRSN_LOE;! Circuit open error
!
! Get the service data base.
!
NML$GB_SRVIDCODE = NML$C_CIRCUIT;
NML$GETSRVDATA ();

NML$Q_SRVCIRDSC [DSC$W_LENGTH]  = .NML$GQ_SRVIDDSC [DSC$W_LENGTH];
NML$Q_SRVCIRDSC [DSC$A_POINTER] = .NML$GQ_SRVIDDSC [DSC$A_POINTER];
!
! Get the service timer from the volatile data base entry for this device.
!
NML$GETSRVTIMER (NML$Q_SRVCIRDSC, NML$W_SRVTIMER);
!
! Open the circuit specified in SYS$NET (translated into NML$GQ_SRVIDDSC).
!
STATUS = NML$MOPOPEN (NML$Q_SRVCIRDSC, .NML$W_SRVTIMER);
NML_CHKMOPERROR (.STATUS);
!
! Set the circuit substate to -AUTOSERVICE.
!
STATUS = NML$MOPSETSUBSTATE (NMA$C_LINSS_ASE);
NML_CHKMOPERROR (.STATUS);
!
! Build the bad message (MOP mode running) to send.
!
NML$BLDMOPMMR (SNDDSC);
!
! Send the bad message and get a response.
!
RCVDSC [DSC$A_POINTER] = .NML$GQ_MOPRCVBFDSC [DSC$A_POINTER];

NML$B_EVT_PRSN = EVC$C_NMA_PRSN_ERR; ! Receive error reason
!
! Send the bad MOP mode running message (used to get the target to
! retransmit the last thing it send - this synchronized the handshaking
! between the two computers.
!
DECR I FROM 5 TO 0 DO
    BEGIN
    STATUS = NML$MOPSNDRCV (SNDDSC,
			    NML$GQ_MOPRCVBFDSC,
			    RCVDSC [DSC$W_LENGTH],
			    TRUE);

    NML_CHKMOPERROR (.STATUS);
!
! Parse the MOP message that was received.
!
    NML$AB_NPA_BLK [NPA$L_MSGCNT] = .RCVDSC [DSC$W_LENGTH];
    NML$AB_NPA_BLK [NPA$L_MSGPTR] = .RCVDSC [DSC$A_POINTER];
!
! If errors are encountered in parsing then signal.
!
    STATUS = NMA$NPARSE (NML$AB_NPA_BLK, NML$NPA_MOPINIT);
    IF .STATUS THEN
	EXITLOOP;
    END;
!
! If 5 bad MOP messages came back from the target, give up.
!
IF NOT .STATUS THEN
    BEGIN
    NML$BLD_REPLY (NML$AB_MSGBLOCK, MSGSIZE);
    $SIGNAL_MSG (NML$AB_MSGBLOCK, .MSGSIZE);
    END;
!
! Dispatch the autoservice function to the correct routine to handle it.
! (The service routine will signal status and the condition handler will
! take care of cleanup.)
!
SELECTONEU .NML$GB_FUNC OF
    SET
    [NMA$C_FNC_TES]: NML$PASSIVELOOP (RCVDSC);

    [NMA$C_FNC_LOA]: NML$LOAD ();

    [NMA$C_FNC_DUM]: NML$DUMP ();

    [OTHERWISE]:     NML$ERROR_1 (NMA$C_STS_FUN);

    TES;
END;				! End of NML$AUTOSERVICE

%SBTTL 'NML$ACTIVELOOP  Active loop'
GLOBAL ROUTINE NML$ACTIVELOOP : NOVALUE =
 
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine performs the active loopback function as a result
!	a LOOP CIRCUIT command.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Signal errors.
!
! SIDE EFFECTS:
!
!	NONE
!--
 
    BEGIN

    OWN
	BUFSIZ;

    LOCAL
	FLDADR,
	FLDSIZE,
	LOOP_COUNT : WORD,
	LOOP_DATA  : BYTE,
	LOOP_SIZE  : WORD,
	MSGSIZE,
	RCVDSC     : DESCRIPTOR,
	RCVLEN,
	RETRY,
	SNDDSC     : DESCRIPTOR,
	STATUS;

!
! Enable condition handler to clean up after loop operation.
!
    ENABLE NML$LOOPHANDLER;
!
! Set the circuit substate to -LOOPING.
!
    STATUS = NML$MOPSETSUBSTATE (NMA$C_LINSS_LOO);
    NML_CHKMOPERROR (.STATUS);
!
! Request buffers for loopback.
!
    FLDADR = 0;
    IF NMA$SEARCHFLD (NML$GQ_SRVDATDSC,
		      NMA$C_PCNO_LPL,
		      FLDSIZE,
		      FLDADR)
    THEN
	LOOP_SIZE = .(.FLDADR)<0,16>
    ELSE
	LOOP_SIZE = NMA$C_LOOP_DSIZ;

    BUFSIZ = .LOOP_SIZE;
    IF NOT NML$GETBUFFER (BUFSIZ, SNDDSC, RCVDSC)
    THEN
	BEGIN

	NML$AB_MSGBLOCK [MSB$L_FLAGS]  = MSB$M_DET_FLD OR
					 MSB$M_MSG_FLD OR
					 MSB$M_DATA_FLD;
	NML$AB_MSGBLOCK [MSB$B_CODE]   = NMA$C_STS_PVA;
	NML$AB_MSGBLOCK [MSB$W_DETAIL] = NMA$C_PCNO_LPL;
	NML$AB_MSGBLOCK [MSB$L_TEXT]   = NML$_ALPBFOVF;
	NML$AB_MSGBLOCK [MSB$A_DATA]   = UPLIT (2, BUFSIZ);

	NML$BLD_REPLY (NML$AB_MSGBLOCK, MSGSIZE);
	$SIGNAL_MSG (NML$AB_SNDBUFFER, .MSGSIZE);

	END;
!
! Initialize the transmit buffer with the specified data.
!
    FLDADR = 0;
    IF NMA$SEARCHFLD (NML$GQ_SRVDATDSC,
		      NMA$C_PCNO_LPD,
		      FLDSIZE,
		      FLDADR)
    THEN
	LOOP_DATA = CH$RCHAR (.FLDADR)
    ELSE
	LOOP_DATA = NMA$C_LOOP_MIX;

    NML$INITBUFFER (SNDDSC, .LOOP_DATA, NML$C_LOOP_MOP);
!
! Get the number of times to loop from the data base.
! If the parameter is not set in the data base then use default size.
!
    FLDADR = 0;
    IF NMA$SEARCHFLD (NML$GQ_SRVDATDSC,
		      NMA$C_PCNO_LPC,
		      FLDSIZE,
		      FLDADR)
    THEN
	LOOP_COUNT = .(.FLDADR)<0,16>
    ELSE
	LOOP_COUNT = NMA$C_LOOP_DCNT;
!
! Loop the specified number of times.  Allow 2 retries to give the target
! system a chance to get into MOP service mode.
!
    RETRY = 2;
    INCR I FROM 0 TO .LOOP_COUNT - 1 DO
	BEGIN
!
! Send and receive loop messages retrying on errors.
!
	WHILE .RETRY GTR 0 DO
	    BEGIN

	    STATUS = NML$MOPSNDRCV (SNDDSC, RCVDSC, RCVLEN, TRUE);
!
! If a message was received successfully then make sure that it matches
! what was sent.
!
	    IF .STATUS
	    THEN
		STATUS = NML$CHKBUFFER (.SNDDSC [DSC$W_LENGTH],
					.SNDDSC [DSC$A_POINTER],
					.RCVLEN,
					.RCVDSC [DSC$A_POINTER],
					NML$C_LOOP_MOP);
!
! If the message matched what was sent then keep sending until the loop
! count is exhausted.  If an error was encountered then set up the error
! response message and keep trying to send this one as long as the retry
! count allows.
!
	    IF .STATUS
	    THEN
		BEGIN

		STATUS = NML$_STS_SUC;
		EXITLOOP;

		END
	    ELSE
		BEGIN

		RETRY = .RETRY - 1;
		NML$AB_MSGBLOCK [MSB$L_FLAGS] = 0;
		NML$AB_MSGBLOCK [MSB$B_CODE]  = NMA$C_STS_LPR;
		STATUS = NML$_STS_LPR;

		END
	    END;
!
! If a loop message was not successfully sent and received even after 
! retries then stop trying to loop.
!
	IF NOT .STATUS
	THEN
	    BEGIN

	    BUFSIZ = .LOOP_COUNT - .I;	! Set up of count of messages
	    EXITLOOP;

	    END;
	END;
!
! If all the loop messages were sent and receive successfully then
! return a success message.  If errors were encountered, return a
! message indicating the error and the number of messages not looped.
!
    IF .STATUS
    THEN
	BEGIN

	NML$AB_MSGBLOCK [MSB$L_FLAGS] = 0;
	NML$AB_MSGBLOCK [MSB$B_CODE]  = NMA$C_STS_SUC;

	END
    ELSE
	BEGIN

	NML$AB_MSGBLOCK [MSB$V_DATA_FLD] = 1;
	NML$AB_MSGBLOCK [MSB$A_DATA]     = UPLIT (2, BUFSIZ);

	END;
!
! Build and signal the response message.
!
    NML$BLD_REPLY (NML$AB_MSGBLOCK, MSGSIZE);
    $SIGNAL_MSG (NML$AB_SNDBUFFER, .MSGSIZE);

    END;				! End of NML$ACTIVELOOP


%SBTTL 'NML$DUMP  Upline dump'
GLOBAL ROUTINE NML$DUMP : NOVALUE =
 
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine performs the upline system dump operation.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Signal errors.
!
! SIDE EFFECTS:
!
!	NONE
!--
 
    BEGIN
    MACRO
    						! MOP Request Memory Dump msg
	RMD_B_FCT     	= 0,0,8,0%,		!  Function code
	RMD_L_MEMADDR 	= 1,0,32,0%,		!  Memory address
	RMD_W_NUMLOCS 	= 5,0,16,0%,		!  Number of locations
    						! MOP Memory Dump Data message
	MDD_B_FCT	= 0,0,8,0%,		!  Function code
	MDD_L_MEMADDR 	= 1,0,32,0%,		!  Memory address
	MDD_T_DATA	= 5,0,0,0%;		!  Data

    LITERAL
	MDD_C_DATSIZ 	= 256,			! MOP Memory Dump data size
	MDD_C_HDRSIZ 	= 5,			! MOP Memory Dump header size
	RECSIZ 		= 512;			! Record buffer size

    LOCAL
	LEN,ADR,				! Temp length and address
	RETRIES,				! Retries remaining count
	MEMSIZ,					! Memory size
	MEMADR,					! Memory address
	CURMEMADR,				! Current memory address
	FILDSC : DESCRIPTOR,			! File name descriptor
	RMDBUF : BBLOCK [7],			! Request Memory Dump message
	RMDDSC : DESCRIPTOR,			! Request Memory Dump desc
	MDDLEN,					! Memory Dump data length
	MDDBUF : BBLOCK [MDD_C_HDRSIZ 		! Memory Dump Data message
			+ MDD_C_DATSIZ],
	MDDDSC : DESCRIPTOR,			! Memory Dump Data descriptor
	RECIDX,					! Record buffer index
	RECBUF : VECTOR [RECSIZ,BYTE],		! Record buffer
	RECDSC : DESCRIPTOR,			! Record buffer descriptor

	SNDDSC : DESCRIPTOR,
	MSGDSC : DESCRIPTOR,
	MSGSIZE,
	STATUS;
!
! Set the circuit substate.
!
    IF .NML$B_AUTOFLAG
    THEN
	BEGIN
	!
	! Log the automatic service event for upline dump.
	!
	NML$W_EVT_CODE = EVC$C_NMA_ALS;
	NML$B_EVT_PSER = EVC$C_NMA_PSER_DUM;
	NML_LOGEVENT (0, 0);

	STATUS = NML$MOPSETSUBSTATE (NMA$C_LINSS_ADU);! -AUTODUMPING
	END
    ELSE
	STATUS = NML$MOPSETSUBSTATE (NMA$C_LINSS_DUM); ! -DUMPING

    NML_CHKMOPERROR (.STATUS);
!
! Get the name of the target's host node.
!
    NML$GETSRVHOST (NML$W_HOSTADR, NML$Q_HOSTDSC);


!
! Get the output file name from the data base.
!
    FILDSC [DSC$A_POINTER] = 0;
    IF NOT NMA$SEARCHFLD (NML$GQ_SRVDATDSC,
	    		  NMA$C_PCNO_DUM,
			  FILDSC [DSC$W_LENGTH],
			  FILDSC [DSC$A_POINTER])
    THEN
	BEGIN
	NML$ERROR_2 (NMA$C_STS_PMS, NMA$C_PCNO_DUM);
	RETURN;
	END;
!
! Get the memory size of the system being dumped
!
    ADR = 0;
    IF NOT NMA$SEARCHFLD (NML$GQ_SRVDATDSC,
			  NMA$C_PCNO_DCT,
			  LEN,ADR)
    THEN
	BEGIN
	NML$ERROR_2 (NMA$C_STS_PMS, NMA$C_PCNO_DCT);
	RETURN;
	END;

    MEMSIZ = ..ADR;
!
! Get the starting memory address of the system being dumped
!
    ADR = 0;
    IF NMA$SEARCHFLD (NML$GQ_SRVDATDSC,
			  NMA$C_PCNO_DAD,
			  LEN,ADR)
    THEN
	MEMADR = ..ADR
    ELSE
	MEMADR = 0;

!
! Open the output file.
!
    STATUS = NML$SRVOPEN (NML$Q_HOSTDSC, FILDSC, NMA$C_OPN_AC_RW);

    IF NOT .STATUS
    THEN
	BEGIN
	NML$AB_MSGBLOCK [MSB$W_DETAIL] = NMA$C_FOPDTL_DFL;
	NML$BLD_REPLY (NML$AB_MSGBLOCK, MSGSIZE);
	$SIGNAL_MSG (NML$AB_SNDBUFFER, .MSGSIZE);
	RETURN;
	END;
!
! Output the trace message.
!
    NML$DEBUG_TXT
	(DBG$C_SRVTRC,
	 $ASCID ('Dumping'));

    RMDBUF [RMD_B_FCT] = MOP$_FCT_RMD;
    RMDBUF [RMD_W_NUMLOCS] = MDD_C_DATSIZ;
    RMDDSC [DSC$W_LENGTH] = %ALLOCATION(RMDBUF);
    RMDDSC [DSC$A_POINTER] = RMDBUF;

    MDDDSC [DSC$W_LENGTH] = %ALLOCATION(MDDBUF);
    MDDDSC [DSC$A_POINTER] = MDDBUF;
!
! Dump the remote system's memory and retry if it fails.
!
    CURMEMADR = .MEMADR;
    RECIDX = 0;
    RETRIES = 2;

    WHILE .CURMEMADR LSSU .MEMSIZ
    AND .RETRIES GTRU 0
    DO
	BEGIN
	!
	! Send 'Request Memory Dump' message and receive a response message.
	!
	RMDBUF [RMD_L_MEMADDR] = .CURMEMADR;
	STATUS = NML$MOPSNDRCV (RMDDSC, MDDDSC, MDDLEN, TRUE);

	!
	! If the response message is a 'Memory Dump Data' and the memory
	! address is the one requested, copy the data to the record buffer.
	!
	IF .STATUS
        AND (.MDDLEN GEQU MDD_C_HDRSIZ)
 	AND (.MDDBUF [MDD_B_FCT] EQL MOP$_FCT_MDD)
	AND (.MDDBUF [MDD_L_MEMADDR] EQL .CURMEMADR)
	THEN
		BEGIN
		CH$MOVE (.MDDLEN - MDD_C_HDRSIZ, MDDBUF [MDD_T_DATA],
			 RECBUF [.RECIDX]);
		RECIDX = (.RECIDX + MDD_C_DATSIZ) MOD RECSIZ;

		!
		! If the record buffer was just filled, write it to the file.
		!
		IF .RECIDX EQL 0
		THEN
			NML$SRVWRITE (RECBUF, RECSIZ);

		CURMEMADR = .CURMEMADR + MDD_C_DATSIZ;

		END
	ELSE
		BEGIN
	        !
    		! The response message isn't correct, so tell the dumper to 
		! start dump again by sending a 'MOP Mode Running' message.
		!
    	        NML$BLDMOPMMR (SNDDSC);
    	 	MSGDSC [DSC$A_POINTER] = .NML$GQ_MOPRCVBFDSC [DSC$A_POINTER];

    	        STATUS = NML$MOPSNDRCV (SNDDSC,
			    		NML$GQ_MOPRCVBFDSC,
			    		MSGDSC [DSC$W_LENGTH],
			    		TRUE);
	        NML_CHKMOPERROR (.STATUS);
    		NML$AB_NPA_BLK [NPA$L_MSGCNT] = .MSGDSC [DSC$W_LENGTH];
    		NML$AB_NPA_BLK [NPA$L_MSGPTR] = .MSGDSC [DSC$A_POINTER];
    		IF NOT NMA$NPARSE (NML$AB_NPA_BLK, NML$NPA_DUMP)
    		THEN
        	    BEGIN
		    NML$ERROR_1(NMA$C_STS_LPR);
		    RETURN;
		    END;
		!
		! Rewind the output file and reset the memory address for
		! retrying
		!
		NML$SRVREWIND ();
		RECIDX = 0;
		CURMEMADR = .MEMADR;
		RETRIES = .RETRIES - 1;

		END;
	END;
!
! Close the dump file.
!
    NML$SRVCLOSE ();
!
! If auto-dumping, tell the remote system to re-load itself by sending an
! 'Enter MOP Mode' message.
!
    IF .NML$B_AUTOFLAG
    THEN
	NML_TRIGGERBOOT (MSGDSC);
!
! Return status.
!
    NML$AB_MSGBLOCK [MSB$L_FLAGS] = 0;
    IF .RETRIES NEQ 0
    THEN
	NML$AB_MSGBLOCK [MSB$B_CODE]  = NMA$C_STS_SUC
    ELSE
	NML$AB_MSGBLOCK [MSB$B_CODE]  = NMA$C_STS_LPR;

    NML$BLD_REPLY (NML$AB_MSGBLOCK, MSGSIZE);
    $SIGNAL_MSG (NML$AB_SNDBUFFER, .MSGSIZE);

    END;				! End of NML$DUMP


%SBTTL 'NML$LOAD  Perform a downline system load'
GLOBAL ROUTINE NML$LOAD : NOVALUE =
 
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine performs the downline system load function.
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Signal errors.
!
!--
 
    BEGIN

    LOCAL
	FLDADR,
	FLDSIZE,
	LOADFLAG,
	MSGDSC : DESCRIPTOR,
	MSGSIZE,
	SNDDSC : DESCRIPTOR,
	STATUS;
!
! Enable condition handler to perform cleanup after load function.
!
    ENABLE NML$LOADHANDLER;
!
! Set the circuit substate.
!
    IF .NML$B_AUTOFLAG
    THEN
	BEGIN
!
! Log event for downline load.
!
	NML$W_EVT_CODE = EVC$C_NMA_ALS;	! Event code (automatic service)
	NML$B_EVT_PSER = EVC$C_NMA_PSER_LOA;
	NML_LOGEVENT (0,0);

	STATUS = NML$MOPSETSUBSTATE (NMA$C_LINSS_ALO); ! -AUTOLOADING

	END
    ELSE
	STATUS = NML$MOPSETSUBSTATE (NMA$C_LINSS_LOA); ! -LOADING
    NML_CHKMOPERROR (.STATUS);
!
! Get the name of the target's host node.
!
    NML$GETSRVHOST (NML$W_HOSTADR, NML$Q_HOSTDSC);
!
! Perform the load.
!
    LOADFLAG = TRUE;			! Set the load retry flag

    WHILE 1 DO
	BEGIN
!
! Get the type of file to be loaded.  If the software type
! is not found in the data base then the default file is the secondary
! loader.
!
	FLDADR = 0;
	IF NMA$SEARCHFLD (NML$GQ_SRVDATDSC,
			  NMA$C_PCNO_STY,
			  FLDSIZE,
			  FLDADR)
	THEN
	    NML$B_PROGRAM = CH$RCHAR (.FLDADR)
	ELSE
	    NML$B_PROGRAM = NMA$C_SOFT_SECL;
!
! Open the file to be loaded.
!
	STATUS = NML_OPENLOADFILE ();
!
! Load it.
!
	IF .STATUS
	THEN
	    BEGIN
!
! Output the trace message.
!
	    NML$DEBUG_TXT
		(DBG$C_SRVTRC,
		(SELECTONEU .NML$B_PROGRAM OF
		     SET
		     [NMA$C_SOFT_SECL]: $ASCID ('Loading secondary bootstrap.');
		     [NMA$C_SOFT_TERL]: $ASCID ('Loading tertiary bootstrap.');
		     [NMA$C_SOFT_OSYS]: $ASCID ('Loading operating system.');
		     TES)
		);

	    SELECTONEU .NML$B_PROGRAM OF
		SET

		[NMA$C_SOFT_SECL]:

		    STATUS = NML_SECLOAD (LOADFLAG, MSGDSC);

		[OTHERWISE]:

		    STATUS = NML_MBLKLOAD (LOADFLAG, MSGDSC);

		TES;
!
! Close the load file.
!
	    NML$SRVCLOSE ();

	    IF .STATUS
	    THEN
		BEGIN
!
! Log the file that was loaded.
!
		NML$DEBUG_TXT
		    (
		    DBG$C_SRVTRC,
		    (SELECTONEU .NML$B_PROGRAM OF
			 SET
			 [NMA$C_SOFT_OSYS]: $ASCID ('Operating system loaded.');
			 [NMA$C_SOFT_TERL]: $ASCID ('Tertiary bootstrap loaded.');
			 [NMA$C_SOFT_SECL]: $ASCID ('Secondary bootstrap loaded.');
			 TES)
		    );
!
! Check to see if the operating system has been loaded.
!
	        IF .NML$B_PROGRAM EQLU NMA$C_SOFT_OSYS
		THEN
		    BEGIN

		    NML$AB_MSGBLOCK [MSB$L_FLAGS] = 0;
		    NML$AB_MSGBLOCK [MSB$B_CODE]  = NMA$C_STS_SUC;
		    EXITLOOP;

		    END;
!
! Parse the received MOP message to get information about the next load
! attempt.
!
		NML$AB_NPA_BLK [NPA$L_MSGCNT] = .MSGDSC [DSC$W_LENGTH];
		NML$AB_NPA_BLK [NPA$L_MSGPTR] = .MSGDSC [DSC$A_POINTER];

		STATUS = NMA$NPARSE (NML$AB_NPA_BLK, NML$NPA_MOPLOAD);

		END;
	    END;
!
! If the load failed on the first message then trigger the target's
! bootstrap and try the load again.
!
	IF NOT .STATUS
	THEN
	    BEGIN

	    IF .LOADFLAG
	    THEN
		BEGIN

		NML_TRIGGERBOOT (MSGDSC);
		LOADFLAG = FALSE;	! No more retries

		NML$AB_NPA_BLK [NPA$L_MSGCNT] = .MSGDSC [DSC$W_LENGTH];
		NML$AB_NPA_BLK [NPA$L_MSGPTR] = .MSGDSC [DSC$A_POINTER];
		IF NOT NMA$NPARSE (NML$AB_NPA_BLK, NML$NPA_MOPLOAD)
		THEN
		    EXITLOOP;

		END
	    ELSE
		EXITLOOP;

	    END
	ELSE
	    LOADFLAG = FALSE;

	END;
!
! Return status.
!
    NML$BLD_REPLY (NML$AB_MSGBLOCK, MSGSIZE);
    $SIGNAL_MSG (NML$AB_SNDBUFFER, .MSGSIZE);

    END;				! End of NML$LOAD


%SBTTL 'NML_MBLKLOAD  Perform general multiblock load'
ROUTINE NML_MBLKLOAD (LOADFLAG, MSGDSC) =
 
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine performs a general multiblock system load.  It is
!	used to down-line load the tertiary loader and the operating
!	system images.
!
! FORMAL PARAMETERS:
!
!	LOADFLAG	Address of load retry flag (TRUE=>if load failed
!			it failed on the first message exchange).
!	MSGDSC		Address of descriptor for received MOP message.
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Signal errors.
!
!--
 
    BEGIN

    MAP
	MSGDSC : REF DESCRIPTOR;

    LOCAL
	BUFPTR,
	FLDADR,
	FLDSIZE,
	LOADNUM : BYTE,
	LOADBLKCNT,
	LOADBYTCNT,
	BLOCKS_LEFT,		! 64 byte blocks of data left in read buffer.
	PTR,
	SNDDSC  : DESCRIPTOR,
	STATUS;

    MSGDSC [DSC$A_POINTER] = NML$AB_MOPRCVBUFFER;
!
! LOADNUM is defined as a byte to correspond to the size of the field in the
! MOP message.  This field will overflow when it gets to load number 256 so
! it will go back to zero.  Overflow must be guaranteed in order for a load
! to succeed so great care should be taken to avoid BLISS optimizations that
! could change this situation.  Be especially careful if any compare or
! increment operations are modified.
!
    LOADNUM = 0;
!
! Load every block in the image.
!
    WHILE .NML$L_LOADSIZE GTR 0 DO
	BEGIN

	STATUS = NML$_STS_SUC;		! Reset the status code
!
! Read a block (record) from the file.
!
	NML_READLOADFILE (NML$Q_READBFDSC);
!
! Load the image block (in one or more 64-byte pieces).
!
	BUFPTR = NML$T_LOADBUFFER;

	INCR I FROM 0 TO .NML$L_BLKCNT - 1 BY NML$K_SEGBLKCNT DO
	    BEGIN
	    !
	    ! If the data left in the read buffer is less than the MOP transmit
	    ! size (NML$K_SEGBLKCNT * 64), send the data that's left.
	    !
	    BLOCKS_LEFT = .NML$L_BLKCNT - .I;
	    IF .BLOCKS_LEFT LSS NML$K_SEGBLKCNT THEN
		LOADBLKCNT = .BLOCKS_LEFT
	    ELSE
		LOADBLKCNT = NML$K_SEGBLKCNT;

	    !
	    ! Calculate the actual byte count of the data to be loaded.
	    !
	    LOADBYTCNT = .LOADBLKCNT * 64;
	    !
	    ! Build the MOP memory load message in the buffer around the
	    ! image data.
	    !
	    PTR = .BUFPTR;

	    CH$WCHAR_A (MOP$_FCT_MLD, PTR);	! Function code
	    CH$WCHAR_A (.LOADNUM, PTR);		! Load number
	    LOADNUM = .LOADNUM + 1;		! Increment load number
	    PTR = CH$MOVE (4, NML$L_BASEADR, .PTR); ! Base address
	    PTR = .PTR + .LOADBYTCNT;		! Skip image data

	    SNDDSC [DSC$A_POINTER] = .BUFPTR;
	    SNDDSC [DSC$W_LENGTH]  = .PTR - .BUFPTR;
	    !
	    ! Transmit the load data to the target node and receive a response.
	    !
	    DECR RETRY FROM 4 TO 0 DO
		BEGIN
		STATUS = NML$MOPSNDRCV (SNDDSC,
					NML$GQ_MOPRCVBFDSC,
					MSGDSC [DSC$W_LENGTH],
					TRUE);
		IF NOT .STATUS
		THEN
		    BEGIN
		    IF ..LOADFLAG
		    THEN
			BEGIN

			NML$AB_MSGBLOCK [MSB$L_FLAGS] = 0;
			NML$AB_MSGBLOCK [MSB$B_CODE]  = NMA$C_STS_LCO;
			EXITLOOP;

			END
		    ELSE
			NML_CHKMOPERROR (.STATUS);

		    END;
		!
		! Verify the response message from the target node.  It must
		! be a MOP request memory load message.
		!
		IF (.MSGDSC [DSC$W_LENGTH] LSS 2)
		OR (CH$RCHAR (NML$AB_MOPRCVBUFFER) NEQ MOP$_FCT_RML)
		THEN
		    BEGIN

		    NML$AB_MSGBLOCK [MSB$L_FLAGS] = 0;
		    NML$AB_MSGBLOCK [MSB$B_CODE]  = NMA$C_STS_LPR;
		    STATUS = NML$_STS_LPR;
		    EXITLOOP;

		    END;
		!
		! If response message from the target node is requesting the
		! the next load buffer, then don't retry.
		!
		IF .(NML$AB_MOPRCVBUFFER + 1)<0,8> EQL .LOADNUM
		THEN
		    BEGIN

		    .LOADFLAG = FALSE;
		    EXITLOOP;

		    END;
		END;

	    IF NOT .STATUS THEN EXITLOOP;
	    !
	    ! Decrement the number of blocks remaining to be loaded.
	    !
	    NML$L_LOADSIZE = .NML$L_LOADSIZE - .LOADBLKCNT;
	    NML$L_BASEADR = .NML$L_BASEADR + .LOADBYTCNT;

	    BUFPTR = .BUFPTR + .LOADBYTCNT;

	    END;

	IF NOT .STATUS THEN EXITLOOP;

	END;
!
! The load is finished (either successfully or with errors).
! If the load has been successful up to this point then send the transfer
! address and any other necessary information.
!
    IF NOT .STATUS
    THEN
	RETURN .STATUS;
!
! If the load file was a bootstrap then send an empty memory load with
! transfer address message.
!
    IF .NML$B_PROGRAM NEQU NMA$C_SOFT_OSYS
    THEN
	BEGIN

	PTR = NML$AB_MOPSNDBUFFER;

	CH$WCHAR_A (MOP$_FCT_MLT, PTR);		! Function code
	CH$WCHAR_A (.LOADNUM, PTR);		! Load segment number
	(.PTR)<0,32> = 0;			! Zero load address
	PTR = .PTR + 4;
!
! Output the MOP message to the debug log.
!
	NML$DEBUG_TXT
	    (
	    DBG$C_SRVTRC,
	    $ASCID ('Transmitting empty memory load with transfer address.')
	    );

	END
    ELSE
	BEGIN
!
! The load file was the system image so send a parameter load with transfer
! address message.
!
	PTR = NML$AB_MOPSNDBUFFER;
	CH$WCHAR_A (MOP$_FCT_PLT, PTR);		! Function code
	CH$WCHAR_A (.LOADNUM, PTR);		! Load segment number
!
! If target node name specified then add it to message.
!
	FLDADR = 0;
	IF NMA$SEARCHFLD (NML$GQ_SRVDATDSC,
			  NMA$C_PCNO_NNA,
			  FLDSIZE,
			  FLDADR)
	THEN
	    BEGIN

	    CH$WCHAR_A (MOP$C_PAR_NNA, PTR);	! Parameter code
	    CH$WCHAR_A (.FLDSIZE, PTR);		! Name length
	    PTR = CH$MOVE (.FLDSIZE, .FLDADR, .PTR); ! Name

	    END;
!
! Add target node address to message.  If address not specified then
! program error.
!
	FLDADR = 0;
	IF NMA$SEARCHFLD (NML$GQ_SRVDATDSC,
			  NMA$C_PCNO_ADD,
			  FLDSIZE,
			  FLDADR)
	THEN
	    BEGIN

	    CH$WCHAR_A (MOP$C_PAR_NAD, PTR);	! Parameter code
	    CH$WCHAR_A (2, PTR);		! Address length
	    PTR = CH$MOVE (2, .FLDADR, .PTR);	! Address

	    END;
!
! If the host node name is specified then add it to the message.
!
	IF .NML$Q_HOSTDSC [DSC$W_LENGTH] NEQ 0
	THEN
	    BEGIN

	    CH$WCHAR_A (MOP$C_PAR_HNA, PTR);	! Parameter code
	    CH$WCHAR_A (.NML$Q_HOSTDSC [DSC$W_LENGTH], PTR);! Name length
	    PTR = CH$MOVE (.NML$Q_HOSTDSC [DSC$W_LENGTH],
			   .NML$Q_HOSTDSC [DSC$A_POINTER],
			   .PTR); 		! Name
	    END;
!
! If the host address is specified then add it to the message.
!
	IF .NML$W_HOSTADR NEQ 0
	THEN
	    BEGIN

	    CH$WCHAR_A (MOP$C_PAR_HAD, PTR);	! Parameter code
	    CH$WCHAR_A (2, PTR);		! Address length
	    PTR = CH$MOVE (2, NML$W_HOSTADR, .PTR); ! Address

	    END;
!
! Add the end mark.
!
	CH$WCHAR_A (0, PTR);
!
! Output the trace message.
!
	NML$DEBUG_TXT
	    (
	    DBG$C_SRVTRC,
	    $ASCID ('Transmitting parameter load with transfer address.')
	    );

	END;
!
! Add transfer address.
!
	PTR = CH$MOVE (4, NML$L_TRANSFER, .PTR);
!
! Send the message.
!
    SNDDSC [DSC$W_LENGTH]  = .PTR - NML$AB_MOPSNDBUFFER;
    SNDDSC [DSC$A_POINTER] = NML$AB_MOPSNDBUFFER;
!
! This should retry just like memory load.
!
    DECR RETRY FROM 4 TO 0 DO
	BEGIN

	STATUS = NML$MOPSNDRCV (SNDDSC,
				NML$GQ_MOPRCVBFDSC,
				MSGDSC [DSC$W_LENGTH],
				TRUE);
	NML_CHKMOPERROR (.STATUS);

	IF (.MSGDSC [DSC$W_LENGTH] LSS 2)
	OR (.(NML$AB_MOPRCVBUFFER)<0,8> NEQU MOP$_FCT_RML)
	OR (.(NML$AB_MOPRCVBUFFER + 1)<0,8> NEQU .LOADNUM)
	THEN
	    BEGIN

	    STATUS = NML$_STS_SUC;
	    EXITLOOP;

	    END;

	STATUS = NML$_STS_LPR;

	END;

    RETURN .STATUS

    END;				! End of NML_MBLKLOAD


%SBTTL 'NML_SECLOAD  Perform secondary bootstrap load'
ROUTINE NML_SECLOAD (LOADFLAG, MSGDSC) =
 
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine down line loads the secondary bootstrap loader to the
!	target node.  It sends the entire load image in a single MOP
!	message.  This is required by MOP to keep the primary boot as simple
!	as possible.
!
! FORMAL PARAMETERS:
!
!	LOADFLAG	Address of load retry flag (TRUE=>if load failed
!			it failed on the first message exchange).
!	MSGDSC		Address of descriptor for received MOP message.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Signal errors.
!
! SIDE EFFECTS:
!
!	NONE
!--
 
    BEGIN

    MAP
	MSGDSC : REF DESCRIPTOR;

    LOCAL
	LOAD_BYTE_CNT,		! Byte count of secondary boot loader image.
	PTR,
	SNDDSC : DESCRIPTOR,
	STATUS;
!
! Check the load size.  The entire secondary loader image must fit in the
! transmit buffer.  NML$L_LOADSIZE is secondary bootstrap image size.  It
! was obtained from the secondary boostrap file header, and is specified
! in 32 word blocks.
!
    LOAD_BYTE_CNT = .NML$L_LOADSIZE * 64;
    IF .LOAD_BYTE_CNT GTRU NML$K_LOADBUFSIZ
    THEN
	NML$ERROR_2 (NMA$C_STS_FCO, .NML$W_PGMDETAIL);
!
! MOP specifies that the transfer address and image start address must be
! 6.  For generality, add 6 to the values specified for these fields in
! the secondary load file header.
!
    NML$L_BASEADR = .NML$L_BASEADR + 6;
    NML$L_TRANSFER = .NML$L_TRANSFER + 6;
!
! Read a block from the load image file.
!
    NML_READLOADFILE (NML$Q_READBFDSC);
!
! Fill in the MOP message information.
!
    PTR = NML$T_LOADBUFFER;

    CH$WCHAR_A (MOP$_FCT_MLT, PTR);	! Function code
    CH$WCHAR_A (0, PTR);		! Load number
    PTR = CH$MOVE (4, NML$L_BASEADR, .PTR); ! Load address (base)
    PTR = .PTR + .LOAD_BYTE_CNT;	! Skip image data
    PTR = CH$MOVE (4, NML$L_TRANSFER, .PTR); ! Transfer address

    SNDDSC [DSC$W_LENGTH] = .PTR - NML$T_LOADBUFFER;
    SNDDSC [DSC$A_POINTER] = NML$T_LOADBUFFER;
    MSGDSC [DSC$A_POINTER] = NML$AB_MOPRCVBUFFER;
!
! Send the message and receive the response.
!
    STATUS = NML$MOPSNDRCV (SNDDSC,
			    NML$GQ_MOPRCVBFDSC,
			    MSGDSC [DSC$W_LENGTH],
			    TRUE);
!
! If the receive failed and no messages had been previously exchanged
! then return the error status.  If the receive failed and some messages
! had been exchanged then signal a communications error to terminate
! the operation.
!
    IF (NOT .STATUS) AND (NOT ..LOADFLAG)
    THEN
	NML_CHKMOPERROR (.STATUS);

    RETURN .STATUS

    END;				! End of NML_SECLOAD


%SBTTL 'NML_TRIGGERBOOT  Trigger bootstrap'
ROUTINE NML_TRIGGERBOOT (MSGDSC) : NOVALUE =
 
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine triggers the bootstrap of the target node.  It is
!	used when an attempt to perform a load/dump fails on the first message
!	exchange.
!
! FORMAL PARAMETERS:
!
!	MSGDSC		Address of descriptor for received MOP message.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Signal errors.
!
! SIDE EFFECTS:
!
!	NONE
!--
 
    BEGIN

    MAP
	MSGDSC : REF DESCRIPTOR;

    LOCAL
	SNDDSC : DESCRIPTOR,
	STATUS;

    MSGDSC [DSC$A_POINTER] = .NML$GQ_MOPRCVBFDSC [DSC$A_POINTER];
!
! Build the trigger 'enter MOP mode' message.
!
    NML$BLDMOPEMM (SNDDSC);
!
! Output the trace message.
!
    NML$DEBUG_TXT
	(
	DBG$C_SRVTRC,
	$ASCID ('Triggering remote bootstrap.')
	);
!
! Send the message and receive the response.
!
    STATUS = NML$MOPSNDRCV (SNDDSC,
			    NML$GQ_MOPRCVBFDSC,
			    MSGDSC [DSC$W_LENGTH],
			    TRUE);
    NML_CHKMOPERROR (.STATUS);

    END;				! End of NML_TRIGGERBOOT


%SBTTL 'NML_OPENLOADFILE  Open the image file for loading'
ROUTINE NML_OPENLOADFILE =
 
!++
! FUNCTIONAL DESCRIPTION:
!
!	Open the image file to be loaded and check the validity of the image.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NML$B_PROGRAM	Type of program image to open.
!	NML$Q_HOSTDSC	Descriptor of the target's host node name.
!
! IMPLICIT OUTPUTS:
!
!	NML$W_PGMDETAIL	Detail code to use for file errors.
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	If no file name or service device is specified then FALSE is
!	returned indicating that not enough information was specified.
!	A FALSE return value indicates to the calling routine that
!	the target system must supply the missing information.  Any
!	errors encountered when trying to open the file will be signalled.
!
! SIDE EFFECTS:
!
!	NONE
!--
 
    BEGIN

    LOCAL
	ADR,
	DEV,
	FILDSC    : DESCRIPTOR,
	FILNAMBUF : BBLOCK [9],		! Default file name buffer
	LEN,
	MSGSIZE,
	PGMCODE,
	PTR,
	STATUS;

!
! Get the file type.
!
    SELECTONEU .NML$B_PROGRAM OF
	SET
	[NMA$C_SOFT_TERL]:		! Tertiary loader
	    BEGIN

	    PGMCODE = NMA$C_PCNO_TLO;
	    NML$W_PGMDETAIL = NMA$C_FOPDTL_TLF;

	    END;

	[NMA$C_SOFT_OSYS]:		! Operating system
	    BEGIN

	    PGMCODE = NMA$C_PCNO_LOA;
	    NML$W_PGMDETAIL = NMA$C_FOPDTL_LFL;

	    END;

	[OTHERWISE]:			! Secondary loader
	    BEGIN

	    PGMCODE = NMA$C_PCNO_SLO;
	    NML$W_PGMDETAIL = NMA$C_FOPDTL_SLF;

	    END;

	TES;
!
! Get the file name from the data base.
!
    FILDSC [0,0,32,0] = 0;
    IF NOT NMA$SEARCHFLD (NML$GQ_SRVDATDSC,
			  .PGMCODE,
			  FILDSC [0,0,32,0],
			  FILDSC [DSC$A_POINTER])
    THEN
	BEGIN
!
! File was not found in the data base so build it from the file type
! and the service circuit.
!
	PTR = FILNAMBUF;

	SELECTONEU .NML$B_PROGRAM OF
	    SET
	    [NMA$C_SOFT_SECL]:

		PTR = CH$MOVE (3, UPLIT BYTE ('SEC'), .PTR);

	    [NMA$C_SOFT_TERL]:

		PTR = CH$MOVE (3, UPLIT BYTE ('TER'), .PTR);

	    [OTHERWISE]:

		BEGIN
		NML$ERROR_2 (NMA$C_STS_PMS, .PGMCODE);
		RETURN FALSE;
		END;

	    TES;
!
! Get the service device type code from the data base.
!
	ADR = 0;
	IF NOT NMA$SEARCHFLD (NML$GQ_SRVDATDSC,
			      NMA$C_PCNO_SDV,
			      LEN,
			      ADR)
	THEN
	    RETURN FALSE;

	DEV = .(.ADR)<0,8>;
!
! Get the service device name string from the table.
!
	STATUS = FALSE;
	INCR I FROM 0 TO MDT$K_MOPDEVCNT - 1 DO
	    BEGIN
!
! If a match is found in the table then move the device name string into
! the file name buffer.
!
	    IF .NML$AB_MOPDEVICES [.I, MDT$B_DEVTYPE] EQL .DEV
	    THEN
		BEGIN

		ADR = .NML$AB_MOPDEVICES [.I, MDT$A_DEVSTRING];
		LEN = .(.ADR)<0,8>;
		ADR = .ADR + 1;
		PTR = CH$MOVE (.LEN, .ADR, .PTR);
		STATUS = TRUE;
		EXITLOOP;

		END;
	    END;
!
! If a service device was found in the table then set up the file name
! descriptor.
!
	IF .STATUS
	THEN
	    BEGIN

	    FILDSC [DSC$W_LENGTH]  = .PTR - FILNAMBUF;
	    FILDSC [DSC$A_POINTER] = FILNAMBUF;

	    END
	ELSE
	    BEGIN

	    NML$AB_MSGBLOCK [MSB$L_FLAGS] = MSB$M_MSG_FLD;
	    NML$AB_MSGBLOCK [MSB$L_TEXT]  = NML$_UNSMOPDEV;
	    NML$BLD_REPLY (NML$AB_MSGBLOCK, MSGSIZE);
	    $SIGNAL_MSG (NML$AB_SNDBUFFER, .MSGSIZE);

	    END;
	END;
!
! Open the file to be loaded.
!
    STATUS = NML$SRVOPEN (NML$Q_HOSTDSC, FILDSC, NMA$C_OPN_AC_RO);
!
! If the file could not be opened then build and signal an error message.
!
    IF NOT .STATUS
    THEN
	BEGIN
	NML$AB_MSGBLOCK [MSB$W_DETAIL] = .NML$W_PGMDETAIL;
	NML$BLD_REPLY (NML$AB_MSGBLOCK, MSGSIZE);
	$SIGNAL_MSG (NML$AB_SNDBUFFER, .MSGSIZE);
	RETURN .STATUS;
	END;
!
! Read in the first label block of the load file.  Get the load file attributes
! from the block, and then skip over the rest of the label blocks to the
! beginning of the load file image data.
!
    NML_CHECK_LABEL_BLK ();
    RETURN TRUE

    END;				! End of NML_OPENLOADFILE


%SBTTL 'NML_READLOADFILE  Read a block from the image file'
ROUTINE NML_READLOADFILE (READ_BUF_DSC) : NOVALUE =
 
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine reads a block from the load file that is currently open.
!
! FORMAL PARAMETERS:
!
!	READ_BUF_DSC	Address of read buffer descriptor.
!
! IMPLICIT INPUTS:
!
!	The load file to be read is open.
!
!	NML$L_LOADSIZE	.
!	NML$W_PGMDETAIL	.
!
! IMPLICIT OUTPUTS:
!
!	NML$Q_DATADSC 	Describes the extent of the data that was read.
!	NML$L_BLKCNT	Number of 64-byte blocks in the buffer.
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Signal errors.
!
! SIDE EFFECTS:
!
!	NONE
!--
 
    BEGIN

    LOCAL
	MSGSIZE,
	STATUS;

!
! Read as many records from the load file as will fit into the read buffer
! and return the byte count of the data read in NML$Q_DATADSC.
!
    NML$SRVREAD (.READ_BUF_DSC,
		NML$Q_DATADSC [DSC$W_LENGTH],
		.NML$W_PGMDETAIL);
!
! Return the number of 64 byte blocks.  If the number of blocks in the
! buffer is less than the number of blocks remaining to be loaded then
! use the number to be loaded.  This will account for extra blocks that
! were the result of zero-filling.
!
    NML$L_BLKCNT = .NML$Q_DATADSC [DSC$W_LENGTH] / 64;
!
! If the number of blocks is zero then the byte count of the record that was
! read was not valid.  The record size must be a multiple of 64.
!
    IF .NML$L_BLKCNT EQLU 0
    THEN
	BEGIN

	NML$AB_MSGBLOCK [MSB$L_FLAGS]  = MSB$M_MSG_FLD;
	NML$AB_MSGBLOCK [MSB$B_CODE]   = NMA$C_STS_FCO;
	NML$AB_MSGBLOCK [MSB$W_DETAIL] = .NML$W_PGMDETAIL;
	NML$AB_MSGBLOCK [MSB$L_TEXT]   = NML$_IMGRECSIZ;
	NML$BLD_REPLY (NML$AB_MSGBLOCK, MSGSIZE);
	$SIGNAL_MSG (NML$AB_SNDBUFFER, .MSGSIZE);

	END;

    IF .NML$L_BLKCNT GTRU .NML$L_LOADSIZE
    THEN
	NML$L_BLKCNT = .NML$L_LOADSIZE;

    END;				! End of NML_READLOADFILE


%SBTTL 'NML_CHECK_LABEL_BLK  Perform file label block check'
ROUTINE NML_CHECK_LABEL_BLK : NOVALUE =
 
!++
! FUNCTIONAL DESCRIPTION:
!
!	The load files are assumed to be built by the RSX11M task image
!	builder.  Read in the file label blocks and extract the information
!	required to down line load the image in the file.
!
! IMPLICIT INPUTS:
!
!	NML$W_PGMDETAIL	Detail code to use for file contents errors.
!
! IMPLICIT OUTPUTS:
!
!	NML$L_LOADSIZE = the size of the image to be down line loaded.
!			 The size is specified in number of 32 word blocks.
!	NML$L_BASEADR =  The address at which to start loading the image
!			 into the target node's memory.
!	NML$L_TRANSFER = The address at which to start executing the image
!			 once it has been down line loaded to the target node.
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Signal errors.
!
!--
 
    BEGIN

!
! Define RSX label block symbols.
!
    EXTERNAL LITERAL
	L$BFLG,		! Word
	L$BHGV,		! Word
	L$BMXV,		! Word
	L$BLDZ,		! Word
	L$BMXZ,		! Word
	L$BWND,		! Byte
	L$BLIB,		! Word
	L$BSGL,		! Word
	L$BOFF,		! Word
	L$BBLK,		! Word
	L$BSA,		! Word
	L$BXFR,		! Word
	TS$NHD,
	TS$CHK,
	TS$RES;

    LOCAL
	LABEL_BUF_DSC : VECTOR [2],	! Descriptor for label read buffer
	LBL : REF BBLOCK,		! Pointer to label buffer
	ISD : REF BBLOCK,		! Pointer to VMS image section desc
	IHA : REF BBLOCK;		! Pointer to VMS image activation desc

    LABEL_BUF_DSC [0] = 512;
    LABEL_BUF_DSC [1] = NML$T_READBUFFER;
!
! Read the file label block.
!
    NML_READLOADFILE (LABEL_BUF_DSC);

    LBL = NML$T_READBUFFER;
    !
    ! Determine whether image is an RSX-11 or VMS image.  This is done by
    ! testing the last word in the image header.
    !
    IF .LBL[510,0,16,1] GEQ 0
    THEN
	BEGIN
	!
	! Save the RSX task image information from the label block.
	!
	NML$L_BLKCNT = .LBL [L$BBLK,0,16,0];
	NML$L_LOADSIZE = .LBL [L$BLDZ,0,16,0]; ! Image size (32-word blocks)
	NML$L_BASEADR  = .LBL [L$BSA ,0,16,0]; ! Starting memory address
	NML$L_TRANSFER = .LBL [L$BXFR,0,16,0]; ! Image transfer address

	END
   ELSE
	BEGIN
	!
	! Save the VMS image information from the image header block.
	!
	NML$L_BLKCNT = .LBL [IHD$B_HDRBLKCNT];
	ISD = .LBL [IHD$W_SIZE] + .LBL;		    ! Get first image section desc
	NML$L_LOADSIZE = .ISD [ISD$W_PAGCNT] * 8;   ! Image size (32-word blocks)
	NML$L_BASEADR  = .ISD [ISD$V_VPN] * 512;    ! Starting memory address
	IHA = .LBL [IHD$W_ACTIVOFF] + .LBL;
	NML$L_TRANSFER = .IHA [IHA$L_TFRADR1];      ! Image transfer address
	NML$L_TRANSFER = .NML$L_TRANSFER<0,31,0>;   ! (remove S0 bit)
	
	END;
!
! Read past the load file label blocks to the beginning of the image to be
! loaded.  (The first label block has already been read.)
!
    DECR I FROM .NML$L_BLKCNT - 2 DO
	BEGIN
	NML_READLOADFILE (LABEL_BUF_DSC);
	END;
    RETURN

    END;				! End of NML_CHECK_LABEL_BLK



%SBTTL 'NML$PASSIVELOOP  Passive loop'
GLOBAL ROUTINE NML$PASSIVELOOP (RCVDSC) : NOVALUE =
 
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine performs the passive loopback function.
!	It provides the mirror function for the LOOP CIRCUIT command.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Signal errors.
!
! SIDE EFFECTS:
!
!	NONE
!--
 
    BEGIN

    MAP
	RCVDSC : REF DESCRIPTOR;

    LOCAL
	STATUS;

!
! Enable condition handler to clean up after loop operation.
!
    ENABLE NML$LOOPHANDLER;
!
! Log the event indicating that a passive loopback operation was initiated.
!
    NML$W_EVT_CODE = EVC$C_NMA_PSL;	! Event code (passive loopback)
    NML$B_EVT_POPR = EVC$C_NMA_POPR_INI;! Operation (initiated)
    NML_LOGEVENT (0, 0);
    NML$B_EVT_POPR = EVC$C_NMA_POPR_TER;! Operation (terminated)
!
! Set the circuit substate to -REFLECTING.
!
    STATUS = NML$MOPSETSUBSTATE (NMA$C_LINSS_REF);
    NML_CHKMOPERROR (.STATUS);

    WHILE 1 DO
	BEGIN

	CH$WCHAR (MOP$_FCT_PLD, .RCVDSC [DSC$A_POINTER]);

	STATUS = NML$MOPSNDRCV (.RCVDSC,
				NML$GQ_MOPRCVBFDSC,
				RCVDSC [DSC$W_LENGTH],
				FALSE);
	NML_CHKMOPERROR (.STATUS);

	IF .(.RCVDSC [DSC$A_POINTER])<0,8> NEQU MOP$_FCT_ALD
	THEN
	    EXITLOOP;

	END;

    NML$ERROR_1 (NMA$C_STS_SUC);

    END;				! End of NML$PASSIVELOOP


%SBTTL 'NML$TRIGGER Trigger the target bootstrap'
GLOBAL ROUTINE NML$TRIGGER : NOVALUE =
 
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine performs the trigger bootstrap function.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Signal errors.
!
! SIDE EFFECTS:
!
!	NONE
!--
 
    BEGIN

    LOCAL
	SNDDSC : DESCRIPTOR,
	STATUS;
!
! Set the circuit substate to -TRIGGERING.
!
    STATUS = NML$MOPSETSUBSTATE (NMA$C_LINSS_TRI);
    NML_CHKMOPERROR (.STATUS);
!
! Build the trigger ('enter MOP mode') message.
!
    NML$BLDMOPEMM (SNDDSC);
!
! Send the trigger message.
!
    STATUS = NML$MOPSEND (.SNDDSC [DSC$A_POINTER], .SNDDSC [DSC$W_LENGTH],
			   NML$Q_SRVCIRDSC);
    NML_CHKMOPERROR (.STATUS);

    NML$ERROR_1 (NMA$C_STS_SUC);

    END;				! End of NML$TRIGGER


%SBTTL 'NML$SERVICEHANDLER  Condition handler'
GLOBAL ROUTINE NML$SERVICEHANDLER (SIGNAL_VEC, MECHANISM)	=
 
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is a condition handler that performs cleanup
!	at the end of service operations.  The direct I/O
!	channel is deassigned.
!
! FORMAL PARAMETERS:
!
!	SIGNAL_VEC	Pointer to the signal vector.
!	MECHANISM	Pointer to the mechanism array.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN

    MAP
	SIGNAL_VEC : REF BBLOCK,	! Signal vector argument
	MECHANISM  : REF BBLOCK;	! Mechanism vector array pointer
!
! Deassign the service channel.
!
    NML$MOPCLOSE ();

    RETURN SS$_RESIGNAL;		! Always resignal error
  
    END;				! End of NML$SERVICEHANDLER

%SBTTL 'NML$AUTOHANDLER  Condition handler for autoservice operations'
GLOBAL ROUTINE NML$AUTOHANDLER (SIGNAL_VEC, MECHANISM)	=
 
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is a condition handler that performs cleanup
!	at the end of service operations.  The direct I/O
!	channel is deassigned.
!
! FORMAL PARAMETERS:
!
!	SIGNAL_VEC	Pointer to the signal vector.
!	MECHANISM	Pointer to the mechanism array.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN

    MAP
	SIGNAL_VEC : REF BBLOCK, 	! Signal vector argument
	MECHANISM  : REF BBLOCK;	! Mechanism vector array pointer

    LOCAL
	MSGADR,
	MSGSIZE,
	STS_CODE : BBLOCK [4];		! Status code
 
    STS_CODE = .SIGNAL_VEC [CHF$L_SIG_NAME];
 
    IF .STS_CODE [STS$V_FAC_NO] EQLU NML$K_FAC_CODE
    THEN
	BEGIN

	MSGADR = .SIGNAL_VEC [CHF$L_SIG_ARG1];
	MSGSIZE = .(SIGNAL_VEC [CHF$L_SIG_ARG1]+4);
!
! Log the event.
!
	NML_LOGEVENT (.MSGSIZE, .MSGADR);

	END;
!
! Deassign the service channel.
!
    NML$MOPCLOSE ();

    RETURN SS$_RESIGNAL;		! Always resignal error
  
    END;				! End of NML$AUTOHANDLER

%SBTTL 'NML_LOGEVENT  Log the network management layer event'
ROUTINE NML_LOGEVENT (MSGSIZE, MSGADR) : NOVALUE =
 
!++
! FUNCTIONAL DESCRIPTION:
!
!	Log the network management event.
!
! FORMAL PARAMETERS:
!
!	MSGSIZE		Size of response message (if necessary).
!	MSGADR		Address of response message (if necessary).
!
! IMPLICIT INPUTS:
!
!	NML$W_EVT_CODE
!	NML$Q_SRVCIRDSC
!	NML$B_EVT_PSER
!	NML$B_EVT_POPR
!	NML$B_EVT_PRSN
!
! ROUTINE VALUE:
! COMPLETION CODE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN

    LOCAL
	EVTBUF : BBLOCK [NML$K_QIOBFLEN],
	EVTDSC : DESCRIPTOR,
	NFB    : BBLOCK [NFB$K_LENGTH],
	NFBDSC : DESCRIPTOR,
	PTR;
!
! Initialize the event buffer pointer leaving room for the byte count word.
!
    PTR = EVTBUF + 2;
!
! Get the current system time and put it in the buffer.
!
    $GETTIM (TIMADR = .PTR);
    PTR = .PTR + 8;
!
! Put the event code in the buffer.
!
    (.PTR)<0,16> = .NML$W_EVT_CODE;
    PTR = .PTR + 2;
!
! Add the source circuit id.
!
    CH$WCHAR_A (EVC$C_SRC_LIN, PTR);	! Add source type code (Always CIRCUIT)
    CH$WCHAR_A (.NML$Q_SRVCIRDSC [DSC$W_LENGTH], PTR); ! Add byte count
    PTR = CH$COPY (.NML$Q_SRVCIRDSC [DSC$W_LENGTH],
		   .NML$Q_SRVCIRDSC [DSC$A_POINTER],
		   0,
		   16,
		   .PTR);
!
! Add the event-specific information.
!
    SELECTU .NML$W_EVT_CODE OF
	SET
!
! Add service code.
!
	[EVC$C_NMA_ALS]:
	    BEGIN

	    (.PTR)<0,16> = EVC$C_NMA_PSER;
	    PTR = .PTR + 2;
	    CH$WCHAR_A (NMA$M_PTY_COD OR 1, PTR);
	    CH$WCHAR_A (.NML$B_EVT_PSER, PTR);

	    END;
!
! Add operation code.
!
	[EVC$C_NMA_PSL]:
	    BEGIN

	    (.PTR)<0,16> = EVC$C_NMA_POPR;
	    PTR = .PTR + 2;
	    CH$WCHAR_A (NMA$M_PTY_COD OR 1, PTR);
	    CH$WCHAR_A (.NML$B_EVT_POPR, PTR);

	    END;
!
! Add reason code.
!
	[EVC$C_NMA_ABS]:
	    BEGIN

	    (.PTR)<0,16> = EVC$C_NMA_PRSN;
	    PTR = .PTR + 2;
	    CH$WCHAR_A (NMA$M_PTY_COD OR 1, PTR);
	    CH$WCHAR_A (.NML$B_EVT_PRSN, PTR);

	    END;
!
! Add status message.
!
	[EVC$C_NMA_ABS, EVC$C_NMA_ALS]:
	    BEGIN

	    (.PTR)<0,16> = EVC$C_NMA_PSTS;
	    PTR = .PTR + 2;
	    CH$WCHAR_A (NMA$M_PTY_CMU OR 3, PTR);

	    CH$WCHAR_A (NMA$M_PTY_COD OR 1, PTR);
	    IF .MSGSIZE GTR 0
	    THEN
		CH$WCHAR_A (.(.MSGADR)<0,8>, PTR)
	    ELSE
		CH$WCHAR_A (0, PTR);

	    CH$WCHAR_A (NMA$M_PTY_COD OR 2, PTR);
	    IF .MSGSIZE GTR 2
	    THEN
		(.PTR)<0,16> = .(.MSGADR + 1)<0,16>
	    ELSE
		(.PTR)<0,16> = -1;
	    PTR = .PTR + 2;

	    CH$WCHAR_A (NMA$M_PTY_ASC, PTR);
	    IF .MSGSIZE GTR 4
	    THEN
		BEGIN

		CH$WCHAR_A (.(.MSGADR + 3)<0,8>, PTR);
		PTR = CH$MOVE (.(.MSGADR + 3)<0,8>,
			       .MSGADR + 4,
			       .PTR);
		END
	    ELSE
		CH$WCHAR_A (0, PTR);

	    END;
	TES;
!
! Set up the descriptor of the event buffer.
!
    EVTDSC [DSC$W_LENGTH] = .PTR - EVTBUF;
    (EVTBUF)<0,16> = .EVTDSC [DSC$W_LENGTH];
    EVTDSC [DSC$A_POINTER] = EVTBUF;
!
! Set up the NFB.
!
    CH$FILL (0, NFB$K_LENGTH, NFB);
    NFB [NFB$B_FCT] = NFB$C_LOGEVENT;
    NFBDSC [DSC$W_LENGTH] = NFB$K_LENGTH;
    NFBDSC [DSC$A_POINTER] = NFB;
!
! Log the event to NETACP.
!
    NML$NETQIO (NFBDSC, EVTDSC, 0, 0);
!
! Dump out the event message.
!
    NML$DEBUG_MSG (DBG$C_EVENTS,
		   .EVTDSC [DSC$A_POINTER],
		   .EVTDSC [DSC$W_LENGTH],
		   $ASCID ('Event logged'));
  
    END;				! End of NML_LOGEVENT

%SBTTL 'NML$LOOPHANDLER  Condition handler'
GLOBAL ROUTINE NML$LOOPHANDLER (SIGNAL_VEC, MECHANISM)	=
 
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is a condition handler that performs cleanup
!	at the end of loop operations.  Any buffers that were
!	allocated from virtual memory are deallocated.
!
! FORMAL PARAMETERS:
!
!	SIGNAL_VEC	Pointer to the signal vector.
!	MECHANISM	Pointer to the mechanism array.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN

    MAP
	SIGNAL_VEC : REF BBLOCK,	! Signal vector argument
	MECHANISM  : REF BBLOCK;	! Mechanism vector array pointer

!
! If loop buffers were allocated, deallocate them.
!
    NML$FREEBUFFER ();

    RETURN SS$_RESIGNAL;		! Always resignal error
  
    END;				! End of NML$LOOPHANDLER

%SBTTL 'NML$LOADHANDLER  Condition handler'
GLOBAL ROUTINE NML$LOADHANDLER (SIGNAL_VEC, MECHANISM)	=
 
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is a condition handler that performs cleanup
!	at the end of load operations.  All files are closed.
!
! FORMAL PARAMETERS:
!
!	SIGNAL_VEC	Pointer to the signal vector.
!	MECHANISM	Pointer to the mechanism array.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN

    MAP
	SIGNAL_VEC : REF BBLOCK,	! Signal vector argument
	MECHANISM  : REF BBLOCK;	! Mechanism vector array pointer

!
! Close any open file.
!
    NML$SRVCLOSE ();

    RETURN SS$_RESIGNAL;		! Always resignal error
  
    END;				! End of NML$LOADHANDLER


%SBTTL 'NML_CHKMOPERROR  Get volatile byte parameter'
ROUTINE NML_CHKMOPERROR (CODE) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Check the status of a MOP function.
!
! FORMAL PARAMETERS:
!
!	CODE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	MSGSIZE;

    IF NOT .CODE
    THEN
	BEGIN

	NML$BLD_REPLY (NML$AB_MSGBLOCK, MSGSIZE);
	$SIGNAL_MSG (NML$AB_SNDBUFFER, .MSGSIZE);

	END;

    END;					! End of NML_CHKMOPERROR

END

ELUDOM
