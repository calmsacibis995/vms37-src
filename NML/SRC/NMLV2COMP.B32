%TITLE 'Process NICE V2.0 requests'
MODULE NML$V2COMP (IDENT = 'V03-002',
		ADDRESSING_MODE (NONEXTERNAL=GENERAL),
		ADDRESSING_MODE (EXTERNAL=GENERAL)) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
 
!++
! FACILITY:  DECnet-VAX V2.0 Network Management Listener
!
! ABSTRACT:
!
!	This module contains the entry points for the
!	the portions of NML dealing with NICE V2 messages.
!
! ENVIRONMENT:  VAX/VMS Operating System
!
! AUTHOR:  Tim Halvorsen & Kathy Perko, October 1981
!
! MODIFIED BY:
!
!	V03-002	MKP0006		Kathy Perko	21-April-1982
!		Add NET.L32 to get NFB definitions.
!
!	V03-001	MKP0005		Kathy Perko	17-Mar-1982
!		Fix V2-V3 SHOW LINE so that it handles multidrop
!		circuits.  I.E. it returns info for DMP-0.1, DMP-0.2, etc.
!
!	V02-004	MKP0004		Kathy Perko	1-Mar-1982
!		Fix ZERO NODE from a V2 node.
!
!	V02-003	MKP0003		Kathy Perko	31-Jan-1982
!		Fix NICE message so the line parameter, Receive Buffers
!		is returned as a word.
!
!	V02-002	MKP0002		Kathy Perko	4-Jan-1982
!		Add SHOW LINKS to V2 compatibility.
!
!	V02-001	MKP0001		Kathy Perko	29-Nov-1981
!		Add zero counters to V2 compatibility.  Also, fix
!		SHOW LINE SUMMARY and STATUS to return "on-starting"
!		instead of "synchronizing" for state.
!
!--
 
%SBTTL 'Declarations'

!
! TABLE OF CONTENTS:
!
 
FORWARD ROUTINE
    nml$v2_compatibility,		! Process any V2 NICE messages
    nml$v2_show_line:	NOVALUE,	! Dispatch a V2 SHOW LINE request
    nml_v2_dispatch:	NOVALUE,	! Dispatch to show or set routine
    nml_v2_showknown:	NOVALUE,	! Show known lines
    nml_v2_showactive:	NOVALUE,	! Show active lines
    nml_v2_showline:	NOVALUE,	! Show a single line
    nml$sho_v2line_substa,		! Put line substate into NICE message.
    nml$v2_show_links:	NOVALUE,	! Dispatch to show known links.
    nml_v2_show_links:	NOVALUE,	! Show known links [with node <id>]
    nml$sholinks,			! Format links for response message.
    nml$v2_chg_line:	NOVALUE,	! Dispatch a V2 SET LINE request
    nml$chk_v2_circ,			! Check NICE command for circuit params.
    nml$chk_v2_line,			! Check NICE command for line params.
    nml$chk_v2_sta,			! Check NICE command state parameter.
    nml_v2_chg_line:	NOVALUE,	! Process V2 SET LINE request.
    nml_v2_chg_entity,			! Update volatile entity
    nml_v2_chg_known:	NOVALUE;	! Update known volatile lines.
 
!
! INCLUDE FILES:
!
 
LIBRARY 'LIB$:NMLLIB';			! Facility-wide definitions

LIBRARY 'SHRLIB$:NMALIBRY';		! NICE definitions

LIBRARY 'SHRLIB$:NET';			! NFB definitions

LIBRARY 'SYS$LIBRARY:STARLET';		! VMS common definitions
 
!
! EXTERNAL REFERENCES:
!
 
EXTERNAL
    nml$gb_ncp_version: BYTE,		! NCP NICE version number
    nml$ab_npa_blk: $NPA_BLKDEF,	! NPARSE context block
    nml$npa_setv2line,			! NPARSE table for V2 SET LINE
					!	commands.
    nml$npa_clearv2line;		! NPARSE table for V2 CLEAR LINE
					!	commands.

$NML_EXTDEF;				! Define common external data

MAP
    nml$gb_options: BBLOCK;

EXTERNAL ROUTINE
    nml$bld_reply,
    nml$send,
    nml$mainhandler,
    nml$error_1,
    nml$error_2,
    nml$getknownlist,
    nml$getactivelist,
    nml$showentity,
    nml$shobyte,
    nml$showord,
    nml$shostring,
    nml$shoadjnode,
    nml$shoexebyte,
    nml$shoexeword,
    nml$bldp2,
    nml$getinftabs,
    nml$getdata,
    nml$processdata,
    nml$addmsgprm,
    lib$establish,
    lib$revert,
    nma$nparse,
    nml$setknown,
    nml$setentity,
    nml$saveparam,
    nml$getexeadr,
    nml$getidstring,
    nml$showparlist,
    nml$bldsetqbf,
    nml$netqio;

EXTERNAL LITERAL
    cpt$gk_pcci_sta,
    cpt$gk_pcli_sta;

!
! The NICE parameter for receive buffers (NMA$C_PCLI_BFN) got changed
! from 2700 in V2 to 1105 in V3.  Because of this, declare a V2 parameter
! id here.
!
GLOBAL LITERAL
     nma$c_pcli_bf$ = 2700;

!
! EQUATED SYMBOLS:
!
LITERAL
    NML$K_ENTBUFLEN = 32;		! Length of entity buffer

!
! Own storage
!
OWN
    nml$l_v2_entity:			! Current entity (line or circuit)
		INITIAL (nml$c_line), 
    nml$l_state,			! New state for a line
					!	and circuit.
!
! Buffers and descriptors.
!
    NML$T_NFBBUFFER  : VECTOR [100, BYTE], ! NFB QIO buffer
    NML$T_P2BUFFER   : VECTOR [NML$K_P2BUFLEN,  BYTE], ! P2 QIO buffer
    NML$T_ENTBUFFER  : VECTOR [NML$K_ENTBUFLEN, BYTE]; ! Entity buffer

BIND
    NML$Q_NFBBFDSC   = UPLIT (%ALLOCATION(NML$T_NFBBUFFER),  NML$T_NFBBUFFER)
		      : DESCRIPTOR,
    NML$Q_P2BFDSC   = UPLIT (%ALLOCATION(NML$T_P2BUFFER),  NML$T_P2BUFFER)
		      : DESCRIPTOR;
OWN
    NML$Q_ENTBFDSC : DESCRIPTOR
		     INITIAL (0, NML$T_ENTBUFFER);

!
! The data which uses the following macros would normally be put into
! NMLDAT, but, since this module will eventually be thrown away, they
! are here to make it easier to throw it out.  The macros are patterned
! after the ones in NMLDAT.
!
MACRO
    PRM_LIST (TAB, TYP) []  =
	BIND
	    %NAME ('NML$Q_',TAB, TYP, '_TABDSC') =
		UPLIT ((%LENGTH - 2) / 3,
			UPLIT BYTE ($DEXTN (%REMAINING)));
    %,

    $DEXTN [A, B, C] =
	WORD (%NAME ('PST$K_', A, '_', B)),
	LONG (C)
    %,

    EXT_LIST [TYP, ID, RTN] =
	EXTERNAL LITERAL
	    %NAME ('PST$K_', TYP, '_', ID);
    %;

%SBTTL 'NML$V2_COMPATIBILITY	Process V2.0 NICE messages'
GLOBAL ROUTINE NML$V2_COMPATIBILITY =
 
!---
!
!	This routine is called to look at an incoming NICE message
!	and if the message is coming from an NCP speaking V2.0 NICE,
!	then the message will be appropriately parsed and mapped to
!	the V3.0 network management parameters.
!
! Inputs:
!
!	nml$ab_rcvbuffer = Buffer containing NICE message
!	nml$gl_rcvdatlen = Length of NICE message
!
! Outputs:
!
!	Routine = True if message handled here, else false.
!---

BEGIN

BUILTIN FP;

.fp = nml$mainhandler;			! Indicate that all signals should
					! return to this level (with R0=0)

!
! If the NCP on the other side of the link is not speaking V2.0, then
! exit immediately and let the rest of NML handle it.
!

IF .nml$gb_ncp_version NEQ 2		! If NCP not V2.0,
THEN
    RETURN false;			! Have caller handle message

SELECTONEU .nml$gb_func			! Dispatch on function code
OF
    SET

!
! For SHOW LINE, depending on the information type requested, we must
! either convert the entity to a circuit, or issue QIOs to both the
! line and circuit database to collect the information and then collate
! the parameters back into a single response message.
!

    [nma$c_fnc_rea]:

	BEGIN
	IF NOT .nml$gl_prs_flgs [nml$v_prs_vms] THEN
	    BEGIN
	    IF .nml$gb_entcode EQL nma$c_ent_lin	! If SHOW LINE
	    THEN
	        BEGIN
	        nml$v2_show_line();	! then call processing routine
	        RETURN true;		! and indicate nothing left to do
	        END;
	    END
	ELSE
	    BEGIN
	    IF .nml$gb_entcode EQL nma$c_sent_lnk THEN	! If SHOW LINKS
		BEGIN
		nml$v2_show_links ();	! then call processing routine
		RETURN true;		! and indicate nothing left to do.
		END;
	    END;
	END;

!
! For SET LINE, we do not allow mixed parameters in the same message.  That
! is, we do not allow V2 parameters which map to both V3 lines and circuits
! in the same request.  This avoids having to issue QIOs to both databases
! in some cases, and allows us to simply change the entity and use the normal
! SET processing.
!

    [nma$c_fnc_cha]:

	IF NOT .nml$gl_prs_flgs [nml$v_prs_vms] AND
	    (.nml$gb_entcode EQL nma$c_ent_lin)	! If SET LINE
	THEN
	    BEGIN
	    nml$v2_chg_line();		! then call processing routine
	    RETURN true;		! and indicate nothing left to do
	    END;

!
! For ZERO LINE counters, change the entity ID from LINE to CIRCUIT (V2 LINE
! counters are now V3 CIRCUIT counters), and then return to the normal
! path to perform the zero.
!
    [nma$c_fnc_zer]:
	IF .nml$gb_entcode EQL nma$c_ent_lin THEN
	    nml$gb_entcode = nma$c_ent_cir;

!
! For LOAD/DUMP/TRIGGER/LOOP, NPARSE initialization has not yet processed
! the entity ID - only the option byte.  So, if LINE is indicated by the
! low bit of the option byte, then change the entity type field (low 3 bits)
! to CIRCUIT.  Else, NODE is indicated, so leave the entity type field zero.
! Either way, return to the normal path to actually perform the operation.
!

    [nma$c_fnc_loa,			! For LOAD/DUMP/TRIGGER/LOOP
     nma$c_fnc_dum,
     nma$c_fnc_tri,
     nma$c_fnc_tes]: 

	BEGIN
	IF .nml$gb_options <0,1>	! If low bit (line/node) set,
	THEN
	    nml$gb_options [nma$v_opt_ent] = nma$c_ent_cir  ! Mark CIRCUIT
	ELSE
	    nml$gb_options [nma$v_opt_ent] = nma$c_ent_nod; ! Else, mark NODE
	CH$WCHAR(.nml$gb_options, .nml$ab_npa_blk [npa$l_fldptr]);
	END;

    TES;

RETURN false;				! Indicate that caller must handle it

END;

%SBTTL 'NML$V2_SHOW_LINE  V2 compatibility read line routine'
ROUTINE NML$V2_SHOW_LINE : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
! FORMAL PARAMETERS:
!
! IMPLICIT INPUTS:
!
!	NML$GB_INFO contains the information type.
!
!--

BEGIN

LOCAL
    INDEX;				! Index into list descriptor table

MAP
    NML$GB_ENTFRM : BYTE SIGNED;

!
! Information can be read only from volatile data bases.
!
IF NOT .NML$GB_OPTIONS [NMA$V_OPT_PER]	! If volatile database requested,
THEN
    BEGIN
    !
    ! Read volatile data base
    !
    INDEX =
	(SELECTONEU .NML$GB_INFO
	OF
	    SET
	    [NMA$C_OPINF_SUM]: NML$C_SUMMARY;
	    [NMA$C_OPINF_STA]: NML$C_STATUS;
	    [NMA$C_OPINF_CHA]: NML$C_CHARACTERISTICS;
	    [NMA$C_OPINF_COU]: NML$C_COUNTERS;
	    [OTHERWISE]: -1;	! Option error
	    TES);

    IF .INDEX NEQU -1
    THEN
	BEGIN
	!
	! Dispatch to the appropriate SHOW routine.  Note that V2 lines
	! are considered circuits by V3.
	!
	SELECTONEU .NML$GB_ENTFRM OF
	    SET

	    [NMA$C_ENT_ACT]:		! Active
		NML_V2_DISPATCH (NML$C_CIRCUIT,
				 NML_V2_SHOWACTIVE,	! Routine
			         .INDEX,		! Info code
				 0, 0);

	    [NMA$C_ENT_KNO]:		! Known
		NML_V2_DISPATCH (NML$C_CIRCUIT,
				 NML_V2_SHOWKNOWN,	! Routine
			         .INDEX,		! Info code
				 0, 0);

	    [1 TO 16]:			! Line name
		NML_V2_DISPATCH (NML$C_CIRCUIT,
				 NML_V2_SHOWLINE,	! Routine
			         .INDEX,		! Info code
			         .NML$GB_ENTFRM,	! Id string length
			         NML$AB_ENTID);	! Id string address

	    TES;

	NML$ERROR_2 (NMA$C_STS_IDE,		! Identification error
	     NMA$C_ENT_LIN);
	END;
    END;

NML$ERROR_1 (NMA$C_STS_FUN);	! Send option error message

END;				! End of NML$READ

%SBTTL 'NML_V2_DISPATCH  Dispatch to V2 show or set routine'
ROUTINE NML_V2_DISPATCH (ENT, RTN, INF, PRM1, PRM2, PRM3) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called when processing a show or set command
!	from a V2 system.  It dispatches to the appropriate V2 show or
!	set routine.
!
! FORMAL PARAMETERS:
!
!	ENT		Entity type code.
!	RTN		Address of entity routine to be called.
!	INF		Information identity code (index).
!	PRM1		Routine parameter value.
!	PRM2		Routine parameter value.
!	PRM3		Routine parameter value.
!
!--

BEGIN

LOCAL
    MSG_SIZE;

!
! Send success with multiple responses message.
!
NML$BLD_REPLY (UPLIT(0, NMA$C_STS_MOR), MSG_SIZE);
NML$SEND (NML$AB_SNDBUFFER, .MSG_SIZE);
!
! Enable condition handler to allow done message to be sent.
!
LIB$ESTABLISH (NML$MAINHANDLER);
!
! Call entity-specific routine.
!
(.RTN) (.ENT, .INF, .PRM1, .PRM2, .PRM3);
!
! Signal done message.
!
LIB$REVERT ();			! Disable condition handler
NML$ERROR_1 (NMA$C_STS_DON);	! Signal no more responses

END;				! End of NML_V2_DISPATCH

%SBTTL 'NML_V2_SHOWKNOWN  Show known V2 line parameters'
ROUTINE NML_V2_SHOWKNOWN (ENTITY, INF) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!	This routine reads the volatile data base entries for all
!	lines.
!
! FORMAL PARAMETERS:
!	ENTITY		Entity type code.
!	INF		Information type code.
!
!--

BEGIN

LOCAL
	BUFEND,
	LENGTH,
	LISDSC : DESCRIPTOR,
	PTR,
	STATUS,
	STRTFLG;

STRTFLG = FALSE;

WHILE NML$GETKNOWNLIST (.ENTITY, .STRTFLG, LISDSC) DO
    BEGIN

    STRTFLG = TRUE;

    BUFEND = .LISDSC [DSC$A_POINTER] + .LISDSC [DSC$W_LENGTH];
    PTR = .LISDSC [DSC$A_POINTER];

    WHILE .PTR LSSA .BUFEND DO
	BEGIN

	LENGTH = .(.PTR)<0,16>;
	PTR = .PTR + 2;

	NML_V2_SHOWLINE (.ENTITY, .INF, .LENGTH, .PTR);

	PTR = .PTR + .LENGTH;	! Advance pointer

	END;
    END;

END;				! End of NML_V2_SHOWKNOWN

%SBTTL 'NML_V2_SHOWACTIVE  Show active line parameters'
ROUTINE NML_V2_SHOWACTIVE (ENTITY, INF) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine reads the volatile data base entries for all
!	lines.
!
! FORMAL PARAMETERS:
!
!	ENTITY		Entity type code.
!	INF		Information type code.
!
!--

BEGIN

LOCAL
	BUFEND,
	LENGTH,
	LISDSC : DESCRIPTOR,
	PTR,
	STATE : BYTE,
	STATUS,
	STRTFLG;

STRTFLG = FALSE;

WHILE NML$GETACTIVELIST (.ENTITY, .STRTFLG, LISDSC) DO
    BEGIN

    STRTFLG = TRUE;

    BUFEND = .LISDSC [DSC$A_POINTER]  + .LISDSC [DSC$W_LENGTH];
    PTR = .LISDSC [DSC$A_POINTER];

    WHILE .PTR LSSA .BUFEND DO
	BEGIN
	!
	! Get line or circuit state.
	!
	STATE = .(.PTR)<0,8>;
	PTR = .PTR + 4;

	LENGTH = .(.PTR)<0,16>;
	PTR = .PTR + 2;
	!
	! Process line or circuit.
	!
	IF .STATE NEQ NMA$C_STATE_OFF
	THEN
	   NML_V2_SHOWLINE (.ENTITY, .INF, .LENGTH, .PTR);

	PTR = .PTR + .LENGTH;	! Advance pointer

	END;
    END;

END;				! End of NML_V2_SHOWACTIVE

%SBTTL 'NML_V2_SHOWLINE  Show V2 line parameters'
ROUTINE NML_V2_SHOWLINE (ENTITY, INF, LEN, ADR) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine reads the volatile data base entries for all
!	V2 lines - I.E. it gets the appropriate LINE and CIRCUIT
!	parameters from the V3 NETACP to do a show for a V2 NCP.
!	The reason the routine is as messy as it is, is so that
!	the V2-V3 compatibility code can be easily thrown away for V4.
!
! FORMAL PARAMETERS:
!
!	ENTITY		Entity ID
!	INF		Information type code.
!	LEN		Length of entity id string.
!	ADR		Address of entity id string.
!
!--

BEGIN
!
! Data for SHOW LINE CHARACTERISTICS.
!
BIND
    NML$GQ_LINBFDSC = NML$GQ_EXEBFDSC: DESCRIPTOR,
    NML$GQ_LINDATDSC = NML$GQ_EXEDATDSC: DESCRIPTOR,
    NML$GL_LINDATPTR = NML$GL_EXEDATPTR;

BIND ROUTINE
    NML$SHOLINBYTE = NML$SHOEXEBYTE,
    NML$SHOLINWORD = NML$SHOEXEWORD;

MACRO
    CHAR_PARAMS =
	 PCCI, SER, NML$SHOBYTE		! Line service
	,PCCI, LCT, NML$SHOWORD		! Line line counter
	,PCCI, BLO, NML$SHOWORD		! Block size
	,PCCI, COS, NML$SHOBYTE		! Cost
	,PCLI, CON, NML$SHOLINBYTE	! Controller
	,PCLI, DUP, NML$SHOLINBYTE	! Duplex
	,PCLI, PRO, NML$SHOLINBYTE	! Protocol (V2 Type)
	,PCLI, STI, NML$SHOLINWORD	! Service Timer
	,PCLI, RTT, NML$SHOLINWORD	! Retransmit Timer (V2 normal timer)
	,PCCI, TRI, NML$SHOBYTE		! Tributary
	,PCLI, BF$, NML$SHOLINWORD	! Receive buffers
	%;

EXT_LIST (CHAR_PARAMS);
PRM_LIST (LIN, V2CHA, CHAR_PARAMS);

!
! NFB to get the V2 line parameters that are circuit parameters in V3.
!
$NFBDSC	(NML$Q_CIRC_NFBDSC, SHOW, , CRI
	,NAM		! Search key = circuit name
	,		! Null start key
	,NAM		! Name
	,SER		! Service
	,LCT		! Counter timer
	,BLO		! Block size
	,COS		! Cost
	,TRI		! Tributary
	);

!
! NFB to get the V2 line parameters that are line parameters in V3.
!
$NFBDSC	(NML$Q_LINE_NFBDSC, SHOW, , PLI
	,NAM		! Search key = circuit name
	,		! Null start key
	,CON		! Controller
	,DUP		! Duplex
	,PRO		! Protocol (V2 Line type)
	,STI		! Service timer
	,RTT		! Retransmit timer (V2 Normal timer)
	,BFN		! Receive buffers
	);

!
!    Circuit summary
!
MACRO
    SUMMARY_PARAMS =
	 PCCI, STA, NML$SHOBYTE			! State
	,PCCI, SUB, NML$SHO_V2LINE_SUBSTA	! Substate
	,PCCI, LOO, NML$SHOSTRING		! Loopback name
	,PCCI, ADJ, NML$SHOADJNODE		! Adjacent node
	%;

EXT_LIST (SUMMARY_PARAMS);
PRM_LIST (LIN, V2SUM, SUMMARY_PARAMS);

!
! Data for SHOW LINE SUMMARY and STATUS.
!
MACRO
!    Circuit status
    STATUS_PARAMS =
	 PCCI, STA, NML$SHOBYTE			! State
	,PCCI, SUB, NML$SHO_V2LINE_SUBSTA	! Substate
	,PCCI, LOO, NML$SHOSTRING		! Loopback name
	,PCCI, ADJ, NML$SHOADJNODE		! Adjacent node
	,PCCI, BLO, NML$SHOWORD			! Block size
	%;

PRM_LIST (LIN, V2STA, STATUS_PARAMS);


LOCAL
    DATDSC : DESCRIPTOR,		! QIO data descriptor
    DATPTR,				! Pointer into P4 buffer
    TABDSC : REF DESCRIPTOR,		! NICE parameter formatting descriptor
    DUMDSC : REF DESCRIPTOR,		! Dummy descriptor
    MSGDSC : DESCRIPTOR,		! Output message descriptor
    NFBDSC : REF DESCRIPTOR,		! NFB descriptor
    P2DSC  : DESCRIPTOR,		! P2 parameter descriptor
    TABDES : REF DESCRIPTOR,		! Information table descriptor
    PERIOD_PTR,
    LINE_LEN;				! Length of circuit's corresponding
					!	line ID.


SELECTU .INF OF
    SET
    [NML$C_STATUS, NML$C_SUMMARY, NML$C_COUNTERS]:
	!
	! For status, summary, and counters the show parameters for V3
	! circuits are the ones required for show parameters for V2 lines.
	! Formatting the SUBSTATE parameter, however, is different.
	!
	BEGIN
	!
	! Get canned NFB to get parameters from NETACP and build P2 buffer
	! to get parameters from specified circuit.
	!
	NML$GETINFTABS (NML$C_CIRCUIT, .INF, NFBDSC, TABDSC, 0);
	NML$BLDP2 (.LEN, .ADR, -1, 0, NML$Q_P2BFDSC, P2DSC);
	END;

    [NML$C_CHARACTERISTICS]:
	!
	! Some V2 line characteristics are V3 line parameters and some
	! are V3 circuit parameters.  Issue QIOs to both volatile data
	! databases to get them.
	!
	BEGIN
	!
	! If the circuit is multipoint, convert the circuit ID to a line ID.
	! (Circuit ID DMP-0.2 = line ID DMP-0).
	!
	IF CH$FAIL (PERIOD_PTR = CH$FIND_CH (.LEN, .ADR, %C'.')) THEN
	    LINE_LEN = .LEN
	ELSE
	    LINE_LEN = .PERIOD_PTR - .ADR;
	NML$BLDP2 (.LINE_LEN, .ADR, -1, 0, NML$Q_P2BFDSC, P2DSC);
	!
	! Use canned NFB to get line parameters from NETACP.
	!
	IF NOT NML$GETDATA (NML$Q_LINE_NFBDSC, P2DSC, 
			NML$GQ_LINBFDSC, NML$GQ_LINDATDSC)
	THEN
	    BEGIN
	    NML$BLD_REPLY (NML$AB_MSGBLOCK, MSGDSC [DSC$W_LENGTH]);
	    NML$SEND (NML$AB_SNDBUFFER, .MSGDSC [DSC$W_LENGTH]);
	    RETURN
	    END;
	!
	! Set up pointer to buffer with line characteristics.  The buffer
	! with the circuit characteristics is handled by DATPTR.
	!
	NML$GL_LINDATPTR = .NML$GQ_LINDATDSC [DSC$A_POINTER];
	NFBDSC = NML$Q_CIRC_NFBDSC;
	TABDSC = NML$Q_LINV2CHA_TABDSC;
	NML$BLDP2 (.LEN, .ADR, -1, 0, NML$Q_P2BFDSC, P2DSC);
	END;
    TES;
!
! Use canned NFB to get circuit parameters from NETACP.
!
IF NML$GETDATA (.NFBDSC, P2DSC, NML$GQ_QIOBFDSC, DATDSC)
THEN
    BEGIN
    TABDSC = (SELECTONEU .INF OF
	SET
	[NML$C_STATUS]:	 NML$Q_LINV2STA_TABDSC;
	[NML$C_SUMMARY]: NML$Q_LINV2SUM_TABDSC;
	[OTHERWISE]: .TABDSC;
	TES);
    DATPTR = .DATDSC [DSC$A_POINTER];
    !
    ! Format the line and circuit parameters into a single NICE
    ! response message.  NML$Q_LINV2CHA_TABDSC causes the formatting
    ! routine to switch between the line and circuit buffer when
    ! necessary.
    !
    NML$PROCESSDATA (.ENTITY, .TABDES, DATDSC, DATPTR, MSGDSC);
    END
ELSE
    BEGIN
    NML$BLD_REPLY (NML$AB_MSGBLOCK, MSGDSC [DSC$W_LENGTH]);
    MSGDSC [DSC$A_POINTER] = NML$AB_SNDBUFFER;
    END;
!
! Send NICE response message to NCP.
!
NML$SEND (.MSGDSC [DSC$A_POINTER], .MSGDSC [DSC$W_LENGTH]);
END;	! of   NML_V2_SHOWLINE

%SBTTL 'NML$SHO_V2LINE_SUBSTA  Show V2 Line substate'
GLOBAL ROUTINE NML$SHO_V2LINE_SUBSTA (SEM_LIST, BUFDSC, MSGSIZE,
					DATDSC, DATPTR)=

!++
! FUNCTIONAL DESCRIPTION:
!	This routine is called when processing a SHOW LINE command from
!	a remote NCP which is running Network Management V2.0.  It gets
!	the circuit substate from the QIO buffer, and puts it into the NICE
!	response message.
!
! FORMAL PARAMETERS:
!	SEM_LIST	Parameter semantic table entry address.
!	BUFDSC		Output message buffer descriptor address.
!	MSGSIZE		Address of current output message size.
!	DATDSC		QIO buffer descriptor address.
!	DATPTR		Current pointer into QIO data buffer.
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Always returns success (NML$_STS_SUC).
!
!--

BEGIN

MAP
    SEM_LIST : REF BLOCK [, BYTE];

IF .(..DATPTR)<0,32> NEQU -1
THEN
    BEGIN
    !
    ! Change the "synchronizing" substate to "on-starting" so the V2
    ! NCP will print out something intelligible.
    !
    IF .(..DATPTR)<0,32> EQL NMA$C_LINSS_SYN THEN
	..DATPTR = NMA$C_LINSS_STA;
    !
    ! Add the line substate to the NICE message.
    !
    NML$ADDMSGPRM (	.BUFDSC,
			.MSGSIZE,
			.SEM_LIST [PST$W_DATAID],
			.SEM_LIST [PST$B_DATATYPE],
			1,
			..DATPTR);

    END;
.DATPTR = ..DATPTR + 4;
RETURN NML$_STS_SUC
END;				! End of NML$SHO_V2LINE_SUBSTA

%SBTTL 'NML$V2_SHOW_LINKS  Dispatch to show volatile LINK parameters'
ROUTINE NML$V2_SHOW_LINKS (INDEX) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine shows a summary of V2 LINK parameters from the volatile
!	data base.
!
! FORMAL PARAMETERS:
!
!	INDEX		Entity information table index code.
!
! IMPLICIT INPUTS:
!
!	NML$GB_ENTFRM contains the entity format code.
!	NML$GL_PRS_FLGS contains the message parsing flags.
!
!--

BEGIN

MAP
    NML$GB_ENTFRM : BYTE SIGNED;

!
! All functions specifying the LINK entity must be system-specific.
!
SELECTONEU .NML$GB_ENTFRM OF
    SET
    [NMA$C_ENT_KNO]:		! Known, or known with node.
	NML_V2_DISPATCH (NML$C_LINKS,
			 NML_V2_SHOW_LINKS,	! Routine address
			 0,			! Info code not used.
			 0,			! Not used
			 0);			! Not used

    TES;

NML$ERROR_2 (NMA$C_STS_IDE,		! Identification error
	     NMA$C_SENT_LNK);

END;				! End of NML$V2_SHOW_LINKS


%SBTTL 'NML_V2_SHOW_LINKS  Show V2 volatile links parameters'
ROUTINE NML_V2_SHOW_LINKS (ENTITY, INF, DUM1, DUM2) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called to perform SHOW LINK commands from nodes
!	running V2 Network Management.  The parameters returned are
!	different from those returned to a V2 node.
!
!	V2 nodes only accept the SHOW KNOWN LINKS and the SHOW KNOWN
!	LINKS WITH NODE <node-id> commands.  The links are returned by
!	node.  I.E.  One response message is sent to NCP for each remote
!	node which there are current logical links to.  Each response
!	message contains the node ID, followed by a list of link
!	numbers and their PIDs.  For a V3 node, NML returns one link per
!	response message along with its associated parameters.
!
!	For SHOW KNOWN LINKS command, build QIO buffers to get NETACP
!	to return information about all known links on this node.
!	For SHOW KNOWN LINKS WITH NODE <nodeid> command, build QIO
!	buffers to return information about all links to the specified
!	node from this node.
!
!	The QIO is repeated until all links of the specified type have
!	been returned by the ACP.  As each link's information is received,
!	it is formatted into a NICE message and returned to NCP.
!
! FORMAL PARAMETERS:
!
!	ENTITY		Entity type code (always NML$C_LINKS)
!	INF		Read information type code (STATUS, SUMMARY, CHARS)
!	DUM1		Not used.
!	DUM2		Not used.
!
!--

BEGIN

LOCAL
	NFB	: REF BBLOCK,		! Pointer used to build NFB.
	SEARCH_KEY_LEN,
	SEARCH_KEY_VAL,			! Address of search key value.
	P2DSC	: DESCRIPTOR,		! P2 buffer descriptor.
	LAST_PNA,			! Last link's partner node address.
	LINK_CNT,			! Count of link entities returned by
					!	NETACP.
	STRDSC	: DESCRIPTOR,		! Descriptor for node id for NICE
					!    response message.
	DATDSC	: DESCRIPTOR,		! Return P4  buffer descriptor.
	DATPTR,				! P4 buffer pointer.
	LAD_BUF	: BBLOCK 		! Buffer for accumulating LADs in NICE
		    [NML$K_SNDBFLEN],	!     message format.
	LAD_BUF_DSC : DESCRIPTOR,	! Descriptor for full size of LAD_BUF.
	LAD_DATA_DSC : DESCRIPTOR,	! Descriptor for data in LAD_BUF.
	LAD_LEN,			! Longword for length of data in
					!      LAD_BUF (NML$SHOWPRMLIST needs a
					!      longword - I'm going to murder
					!      Davidson.)
	MSGSIZE,
	STATUS;


!
! For formatting the link and its PID into the NICE response message
!
MACRO
    LINK_PARAMS = PCLK,	LAD,	NML$SHOLINKS %;

EXT_LIST (LINK_PARAMS);
PRM_LIST (LNK, V2SHO, LINK_PARAMS);

!
! This NFB is used get the link information for all the links to
! a given node.
!
$NFBDSC (NML_Q_V2_SHOLNK, SHOW, NFB$M_KNO OR NFB$M_UPD, LLI
	,NFB$C_WILDCARD			! Search key = wildcard
	,NFB$C_COLLATE			! When QIO is reissued, start at
					!	entry after last one found.
    !
    ! Link parameters for NETACP to return in P4 buffer.
    !
	,PNA				! Partner node address
	,PNN				! Partner node name
	,LLN				! Logical link number
	,PID				! Process ID
	);

MAP
    NML_Q_V2_SHOLNK : DESCRIPTOR;
!
! Modify canned NFB descriptor to do the show links requested by the NICE
! command.  Use special NFBs that only get the information required for
! a V2 SHOW LINK: node name and address, link number, and PID.
! This NFB has the known bit so NETACP returns multiple links in each buffer.
!
NFB = .NML_Q_V2_SHOLNK [DSC$A_POINTER];
IF .NML$GL_PRS_FLGS [NML$V_PRS_STR] THEN
    !
    ! The NICE command was SHOW KNOWN LINKS WITH NODE <nodeid>.
    !
    BEGIN
    SEARCH_KEY_LEN = .(.NML$GQ_ENTSTRDSC [DSC$A_POINTER])<0,8>;
    IF .SEARCH_KEY_LEN EQL 0 THEN
	!
	! Set the search key up to be the node address.
	!
	BEGIN
	NFB [NFB$L_SRCH_KEY] = NFB$C_LLI_PNA;
	SEARCH_KEY_VAL = .(.NML$GQ_ENTSTRDSC [DSC$A_POINTER])<8,24>;
	IF .SEARCH_KEY_VAL EQL 0 THEN
	    NML$GETEXEADR (SEARCH_KEY_VAL);
	END
    ELSE
	!
	! Set the search key up to be the node name.
	!
	BEGIN
	NFB [NFB$L_SRCH_KEY] = NFB$C_LLI_PNN;
	SEARCH_KEY_VAL = .NML$GQ_ENTSTRDSC [DSC$A_POINTER] + 1;
	END;

    END
ELSE
    !
    ! Set up to return all links in this nodes database.
    !
    BEGIN
    NFB [NFB$L_SRCH_KEY] = NFB$C_WILDCARD;
    SEARCH_KEY_LEN = -1;
    SEARCH_KEY_VAL = 0;
    END;
NML$BLDP2 ( .SEARCH_KEY_LEN, .SEARCH_KEY_VAL, -1, 0, NML$Q_P2BFDSC, P2DSC);
!
! Set up for loop to get link info from NETACP.
!
LAD_BUF_DSC [DSC$W_LENGTH] = NML$K_SNDBFLEN;
LAD_BUF_DSC [DSC$A_POINTER] = LAD_BUF;
LAD_DATA_DSC [DSC$A_POINTER] = LAD_BUF;
LAST_PNA = -1;
STATUS = 1;
LAD_LEN = 0;
!
! If you use NFB$C_COLLATE as the start key, NETACP will return all links
! to a given node consecutively.  This routine takes advantage of this fact.
!
WHILE .STATUS DO
    BEGIN
    STATUS = NML$GETDATA (NML_Q_V2_SHOLNK, P2DSC, NML$GQ_QIOBFDSC, DATDSC);
    IF .STATUS THEN
	BEGIN
	DATPTR = .DATDSC [DSC$A_POINTER];
	LINK_CNT = .(.P2DSC [DSC$A_POINTER]);
	WHILE (LINK_CNT = .LINK_CNT - 1) GEQ 0 DO
	    BEGIN
	    !
	    ! If different node, and not first time build message and send it.
	    !
	    IF .LAST_PNA NEQ ..DATPTR THEN
		BEGIN
		IF .LAD_LEN NEQ 0 THEN
		    BEGIN
		    NML$AB_MSGBLOCK [MSB$L_FLAGS] = MSB$M_ENTD_FLD OR
								MSB$M_DATA_FLD;
		    NML$AB_MSGBLOCK [MSB$B_CODE] = NMA$C_STS_SUC;
		    NML$AB_MSGBLOCK [MSB$A_ENTITY] = STRDSC;
		    LAD_DATA_DSC [DSC$W_LENGTH] = .LAD_LEN;
		    NML$AB_MSGBLOCK [MSB$A_DATA] = LAD_DATA_DSC;
		    NML$BLD_REPLY (NML$AB_MSGBLOCK, MSGSIZE);
		    NML$SEND (NML$AB_SNDBUFFER, .MSGSIZE);
		    !
		    ! Set up to build NICE message for next node in NETACPs
		    ! logical link database.
		    !
		    LAD_LEN = 0;
		    MSGSIZE = 0;
		    END;
		!
		! Build string descriptor for node in STRDSC, and build
		! the node ID for the NICE response message.  This node ID
		! is in the standard Network Management format of node
		! address, node name length, node name.
		!
		LAST_PNA = ..DATPTR;
		NML$GETIDSTRING (NML$C_NODE, DATPTR, STRDSC);
		END
	    ELSE
	        !
	        ! Skip over node address and name here.
	        !
	        DATPTR = .DATPTR + 6 + .(.DATPTR+4)<0,16>;
	    !
	    ! Format link # and PID into a buffer in NICE format.
	    !
	    NML$SHOWPARLIST (LAD_BUF_DSC,
			     LAD_LEN,
			     NML$Q_LNKV2SHO_TABDSC,
			     DATDSC,
			     DATPTR);
	    END;
	END;
   END;
!
! Build the last NICE response message.  If there was an error, but there is
! a node id to add, do so.  If the last completion status was end-of-file
! (NML$_STS_CMP) then the end of the link data base was successfully reached,
! so add whatever links are left in the LAD buffer.
!
IF .LAD_LEN GTR 0 THEN
    BEGIN
    NML$AB_MSGBLOCK [MSB$L_FLAGS] = .NML$AB_MSGBLOCK [MSB$L_FLAGS] OR
		MSB$M_ENTD_FLD;
    NML$AB_MSGBLOCK [MSB$A_ENTITY] = STRDSC;
    IF .STATUS EQL NML$_STS_CMP THEN
	BEGIN
	NML$AB_MSGBLOCK [MSB$L_FLAGS] = MSB$M_ENTD_FLD OR MSB$M_DATA_FLD;
	NML$AB_MSGBLOCK [MSB$B_CODE] = NMA$C_STS_SUC;
	LAD_DATA_DSC [DSC$W_LENGTH] = .LAD_LEN;
	NML$AB_MSGBLOCK [MSB$A_DATA] = LAD_DATA_DSC;
	END;
    END;
!
! Put the pieces of the NICE response message together and send it
! to NCP.
!
NML$BLD_REPLY (NML$AB_MSGBLOCK, MSGSIZE);
NML$SEND (NML$AB_SNDBUFFER,
	  .MSGSIZE);
END;		! of	NML_V2_SHOW_LINKS	


%SBTTL 'NML$SHOLINKS  Get logical link parameters'
GLOBAL ROUTINE NML$SHOLINKS (SEM_LIST, BUFDSC, MSGSIZE, DATDSC, DATPTR) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine adds a logical link id to the NICE response message.
!
! FORMAL PARAMETERS:
!
!	SEM_LIST	Parameter semantic table entry address.
!	BUFDSC		Output message buffer descriptor address.
!	MSGSIZE		Address of current output message size.
!	DATDSC		QIO buffer descriptor address.
!	DATPTR		Current pointer into QIO data buffer.
!
! IMPLICIT INPUTS:
!
!	Coded multiple link address and process id fields are added to output
!	message.
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NML$_STS_SIZ if the response message buffer overflows.
!	NML$_STS_SUC
!
!--

BEGIN

MAP
    DATDSC   : REF DESCRIPTOR,
    SEM_LIST : REF BLOCK [, BYTE];

LOCAL
    PRM_BUFFER	: BBLOCK [30],
    PRMSIZE,
    STRPTR,
    STATUS;

!
! Now, get the link address and PID and format them for the
! NICE response message.
!
STRPTR = PRM_BUFFER;
CH$WCHAR_A (2, STRPTR);	! Move link address
STRPTR = CH$MOVE (2, ..DATPTR, .STRPTR);
.DATPTR = ..DATPTR + 4;

CH$WCHAR_A (%X'20' OR 4, STRPTR); ! Move process id
STRPTR = CH$MOVE (4, ..DATPTR, .STRPTR);
.DATPTR = ..DATPTR + 4;

PRMSIZE = .STRPTR - PRM_BUFFER;

STATUS = NML$ADDMSGPRM (.BUFDSC,
			.MSGSIZE,
			NMA$C_PCLK_LAD,
			NMA$M_PTY_CMU OR 2,
			.PRMSIZE,
			PRM_BUFFER);

RETURN .STATUS

END;				! End of NML$SHOLINKS

%SBTTL 'NML$V2_CHG_LINE  Set V2 line parameters'
ROUTINE NML$V2_CHG_LINE : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called when NML receives a SET or CLEAR LINE command
!	from a V2 NCP.  It transforms the V2 SET or CLEAR LINE command into
!	the appropriate V3 QIO.  Note that some V2 line parameters are
!	V3 circuit parameters.  Line and circuit parameters may not be
!	mixed in a single V2 command.
!
!--

BEGIN

MAP
	NML$GB_ENTFRM  :  BYTE SIGNED;

LOCAL
    FUNCTION,
    NPARSE_TAB;
!
! Information can be read only from volatile data bases.
!
IF NOT .NML$GB_OPTIONS [NMA$V_OPT_PER]	! If volatile database requested,
THEN
    BEGIN
    IF .NML$GB_OPTIONS [NMA$V_OPT_CLE]
    THEN
	BEGIN
	NPARSE_TAB = NML$NPA_CLEARV2LINE;
	FUNCTION = NFB$C_FC_CLEAR;
	END
    ELSE
	BEGIN
	NPARSE_TAB = NML$NPA_SETV2LINE;
	FUNCTION = NFB$C_FC_SET;
	END;
    IF NMA$NPARSE (NML$AB_NPA_BLK,
			.NPARSE_TAB)
    THEN
	SELECTONEU .NML$GB_ENTFRM OF
	    SET
	    [NMA$C_ENT_KNO]:		! Known
		NML_V2_DISPATCH (.NML$L_V2_ENTITY,
				 NML_V2_CHG_KNOWN,
				 .FUNCTION, 0);

	    [1 TO 16]:
		NML_V2_DISPATCH (.NML$L_V2_ENTITY,
				 NML_V2_CHG_LINE,
				 .NML$GB_ENTFRM,
				 NML$AB_ENTID,
				 .FUNCTION);
	    TES;
    NML$ERROR_2 (NMA$C_STS_IDE, NMA$C_ENT_LIN);
    END;
NML$ERROR_1 (NMA$C_STS_FUN, NMA$C_ENT_LIN);
END;	!  of   NML$V2_CHG_LINE

%SBTTL	'NML$CHK_V2_CIRC	Check Set V2 Circuit parameter group'
GLOBAL ROUTINE NML$CHK_V2_CIRC =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This is an NPARSE action routine that is called when parsing a
!	SET LINE command from a V2 NCP.  These commands could have both
!	line and circuit parameters in the same command.  To adhere with
!	Network Management architecture, we do not allow a mix in a single
!	SET command.  Check the parameter code to make sure it is a circuit
!	parameter.
!
! IMPLICIT INPUTS:
!	NPARSE_BLOCK (pointed to by AP) contains the parsed parameter data.
!	NPA$L_FLDPTR is a pointer to the parameter code in the received
!	message buffer.
!
!	If the parameter is not a circuit parameter, then an invalid parameter
!	grouping error (NMA$C_STS_PGP) is signalled.
!--

BEGIN

$NPA_ARGDEF;		! Define NPARSE block reference.

!
! If this is not a circuit parameter, return error.
!
IF .NML$GL_PRS_FLGS [NML$V_PRS_V2_LINE]
THEN
    NML$ERROR_2 (NMA$C_STS_PGP,
		 .(.NPARSE_BLOCK [NPA$L_FLDPTR])<0,16>);
NML$GL_PRS_FLGS [NML$V_PRS_V2_CIRCUIT] = 1;	! Set grouping flag.
NML$L_V2_ENTITY = NML$C_CIRCUIT;
RETURN NML$_STS_SUC
END;			! End of NML$CHK_V2_CIRC

%SBTTL	'NML$CHK_V2_LINE	Check Set V2 Line parameter group'
GLOBAL ROUTINE NML$CHK_V2_LINE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This is an NPARSE action routine that is called when parsing a
!	SET LINE command from a V2 NCP.  These commands could have both
!	line and circuit parameters in the same command.  To adhere with
!	Network Management architecture, we do not allow a mix in a single
!	SET command.  Check the parameter code to make sure it is a line
!	parameter.
!
! IMPLICIT INPUTS:
!	NPARSE_BLOCK (pointed to by AP) contains the parsed parameter data.
!	NPA$L_FLDPTR is a pointer to the parameter code in the received
!	message buffer.
!
!	If the parameter is not a line parameter, then an invalid parameter
!	grouping error (NMA$C_STS_PGP) is signalled.
!--

BEGIN

$NPA_ARGDEF;		! Define NPARSE block reference.

!
! If this is not a line parameter, return error.
!
IF .NML$GL_PRS_FLGS [NML$V_PRS_V2_CIRCUIT]
THEN
    NML$ERROR_2 (NMA$C_STS_PGP,
		 .(.NPARSE_BLOCK [NPA$L_FLDPTR])<0,16>);
NML$GL_PRS_FLGS [NML$V_PRS_V2_LINE] = 1;	! Set grouping flag.
NML$L_V2_ENTITY = NML$C_LINE;
RETURN NML$_STS_SUC
END;			! End of NML$CHK_V2_LINE

%SBTTL	'NML$CHK_V2_STA	Check Set V2 Line parameter group'
GLOBAL ROUTINE NML$CHK_V2_STA=

!++
! FUNCTIONAL DESCRIPTION:
!
!	This is an NPARSE action routine that is called when parsing a
!	SET LINE command from a V2 NCP, and a state change is found.
!	Set up the proper fields so the state change is made to both
!	the line and the circuit.  State is the only V2 parameter for
!	which this is done.
!
! IMPLICIT INPUTS:
!	NPARSE_BLOCK (pointed to by AP) contains the parsed parameter data.
!	NPA$L_FLDPTR is a pointer to the parameter code in the received
!	message buffer.
!
!m-

BEGIN

$NPA_ARGDEF;		! Define NPARSE block reference.


!
! Save the new state.
!
NML$L_STATE = .(.NPARSE_BLOCK [NPA$L_FLDPTR])<0,8>;
NML$GL_PRS_FLGS [NML$V_PRS_V2_STA] = 1;	! Set state change flag.
RETURN NML$_STS_SUC
END;			! End of NML$CHK_V2_LINE

%SBTTL 'NML_V2_CHG_LINE  Set volatile database line parameters'
ROUTINE NML_V2_CHG_LINE (ENT, LEN, ADR, FCN) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!	This routine adds and clears parameters in the volatile data
!	base for V2 line entities.  Since the line entity was broken
!	into the line and circuit entities for V3, this can require a
!	QIO to either data base.  Only the state parameter is updated
!	in both data bases.  
!
! FORMAL PARAMETERS:
!	ENT		Entity type code.
!	LEN		Byte count of entity id string.
!	ADR		Address of entity id string.
!	FCN		Function (set or clear)
!
!--
BEGIN

MAP
	NML$GB_ENTFRM  :  BYTE SIGNED;

LOCAL
    STATE_LGTH,
    MSGSIZE,
    STATUS;

!
! If there is a state parameter in the NICE command, add it to the
! parameter list using the field ID for the appropriate data base.
!
IF .NML$GL_PRS_FLGS [NML$V_PRS_V2_STA]
THEN
    BEGIN
    IF .FCN EQL NFB$C_FC_CLEAR THEN
	STATE_LGTH = 0
    ELSE
	STATE_LGTH = 1;
    IF .ENT EQL NML$C_LINE
    THEN
	NML$SAVEPARAM ( CPT$GK_PCLI_STA, .STATE_LGTH, NML$L_STATE)
    ELSE
	NML$SAVEPARAM ( CPT$GK_PCCI_STA, .STATE_LGTH, NML$L_STATE);
    END;
STATUS = NML_V2_CHG_ENTITY (.ENT, .LEN, .ADR, .FCN);
IF .STATUS
   AND .NML$GL_PRS_FLGS [NML$V_PRS_V2_STA]
THEN
    !
    ! If there is a state change in the NICE command, it must be made
    ! to both the circuit and line data bases.  Update the data base
    ! not already done here.
    !
    BEGIN
    NML$GW_PRMDESCNT = 0;	! Only update the state this time.
    IF .ENT EQL NML$C_LINE
    THEN
	BEGIN
	ENT = NML$C_CIRCUIT;
	NML$SAVEPARAM ( CPT$GK_PCCI_STA, .STATE_LGTH, NML$L_STATE);
	END
    ELSE
	BEGIN
	ENT = NML$C_LINE;
	NML$SAVEPARAM ( CPT$GK_PCLI_STA, .STATE_LGTH, NML$L_STATE);
	END;
    STATUS = NML_V2_CHG_ENTITY (.ENT, .LEN, .ADR, .FCN);
    END;
IF .NML$GB_ENTFRM EQL NMA$C_ENT_KNO THEN
    BEGIN
    !
    ! If updating KNOWN lines, add the entity identification to the 
    ! NICE response message.
    !
    NML$AB_MSGBLOCK [MSB$V_ENTD_FLD] = 1;
    NML$AB_MSGBLOCK [MSB$A_ENTITY] = NML$Q_ENTBFDSC;
    END;
!
! Build and send the response message.
!
NML$BLD_REPLY (NML$AB_MSGBLOCK, MSGSIZE);
NML$SEND (NML$AB_SNDBUFFER, .MSGSIZE);
END;			! End of NML_V2_CHG_LINE

%SBTTL 'NML_V2_CHG_ENTITY  Set volatile database line parameters'
ROUTINE NML_V2_CHG_ENTITY (ENT, LEN, ADR, FCN) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine adds or clears the specified V2 parameters in 
!	the volatile data base entry for the specified component.  
!
! FORMAL PARAMETERS:
!
!	ENT		Entity type code.
!	LEN		Byte count of entity id string.
!	ADR		Address of entity id string.
!	FCN		Function (set or clear)
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	The translated status of the SET QIO is returned.
!--

BEGIN

LOCAL
	DB,				! Database ID 
	SRCHKEY,			! Search key
	NFBDSC : DESCRIPTOR,		! NFB buffer descriptor
	P2DSC  : DESCRIPTOR,		! QIO P2 buffer descriptor
	QBFDSC : DESCRIPTOR,		! QIO P4 buffer descriptor
	STATUS;

STATUS = NML$_STS_SUC;
!
! Get entity information.
!
DB      = .NML$AB_ENTITYDATA [.ENT, EIT$B_DATABASE];! Database ID
SRCHKEY = .NML$AB_ENTITYDATA [.ENT, EIT$L_SRCHKEY]; ! Search key
!
! Build the NFB and P2 buffers for the QIO to NETACP.
!
NML$BLDSETQBF (.FCN, .DB, 
		.SRCHKEY, .LEN, .ADR,
		NML$Q_NFBBFDSC, NFBDSC,
		NML$Q_P2BFDSC, P2DSC,
		NML$GQ_QIOBFDSC, QBFDSC);
!
! Add the parameters to volatile data base entry.
!
STATUS = NML$NETQIO (NFBDSC, P2DSC, 0, QBFDSC);
IF .STATUS THEN
    BEGIN    
    NML$AB_MSGBLOCK [MSB$L_FLAGS] = 0;
    NML$AB_MSGBLOCK [MSB$B_CODE] = NMA$C_STS_SUC;
    END;
RETURN .STATUS
END;				! End of NML_V2_CHG_ENTITY

%SBTTL 'NML_V2_CHG_KNOWN  Set volatile entity parameters'
ROUTINE NML_V2_CHG_KNOWN (ENT, FCN) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine sets or clears the specified parameters for each
!	of the components of the given entity type.
!
! INPUTS:
!
!	ENT	Entity type code.
!	FCN	Function (set or clear).
!
!--

BEGIN

LOCAL
	BUFEND,
	ENTADD,
	ENTLEN,
	LISDSC   : DESCRIPTOR,
	ENTIDPTR,
	PTR,
	STATUS,
	STRTFLG;
!
! Process every entry in the data base.
!
STRTFLG = FALSE;
WHILE NML$GETKNOWNLIST (.ENT, .STRTFLG, LISDSC) DO
    BEGIN

    STRTFLG = TRUE;

    BUFEND = .LISDSC [DSC$A_POINTER] + .LISDSC [DSC$W_LENGTH];
    PTR = .LISDSC [DSC$A_POINTER];

    WHILE .PTR LSSA .BUFEND DO
	BEGIN

	ENTIDPTR = NML$T_ENTBUFFER;
	NML$Q_ENTBFDSC [DSC$W_LENGTH] = NML$K_ENTBUFLEN;
!
! Get entity id for SET QIO and id string for response message.
!
	ENTLEN = .(.PTR)<0,16>;
	PTR = .PTR + 2;
	ENTADD = .PTR;
	CH$WCHAR_A (.ENTLEN, ENTIDPTR);
	ENTIDPTR = CH$MOVE (.ENTLEN,
			.ENTADD,
			.ENTIDPTR);
	PTR = .PTR + .ENTLEN;

	NML$Q_ENTBFDSC [DSC$W_LENGTH] = .ENTIDPTR - NML$T_ENTBUFFER;
	!
	! Add the parameters to volatile data base entry.
	!
	NML_V2_CHG_LINE ( .ENT, .ENTLEN, .ENTADD, .FCN);
	END;
    END;
END;				! End of NML_V2_CHG_KNOWN


END					! End of module
ELUDOM
